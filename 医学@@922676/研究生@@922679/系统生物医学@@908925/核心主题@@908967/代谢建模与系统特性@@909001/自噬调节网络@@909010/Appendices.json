{"hands_on_practices": [{"introduction": "真实的生物网络很少是简单的线性链条，而是充满了各种调控反馈。本练习在前一个模型的基础上，引入了一个负反馈回路，即自噬溶酶体的积累会抑制自噬体的初始形成步骤。你将看到这种反馈如何使系统行为变得复杂，并运用灵敏度分析来量化在不同条件下哪些参数对自噬流量的控制作用最强。[@problem_id:4317265]", "problem": "考虑单个细胞中一个极简的自噬通路模块，该模块包含起始、自噬体积累、与溶酶体融合以及货物降解过程。自噬体池（用 $A$ 表示）由一个起始流提供，该起始流受到溶酶体负荷的负向调节；自噬溶酶体池（用 $L$ 表示）通过降解来更新货物。假设以下基于质量作用动力学和稳态流平衡的机理要素：\n\n- 自噬体以起始速率 $r$ 形成，该速率取决于营养物调控的上游信号传导和溶酶体负荷的负反馈。具体来说，$r$ 由下式给出\n$$\nr \\;=\\; \\frac{k_{i}\\, s(N)}{1 + \\beta\\, L},\n$$\n其中，$k_{i}$ 是起始速率常数，$s(N)$ 是一个无量纲的营养物依赖性激活因子（$0 \\le s(N) \\leq 1$），它捕捉了诸如雷帕霉素靶蛋白复合物1（mTORC1）等调节因子的净效应，而 $\\beta$ 是一个无量纲的反馈强度系数，代表溶酶体负荷对起始过程的抑制。\n\n- 自噬体以一级速率 $k_{f} A$ 与溶酶体融合，自噬溶酶体以一级速率 $k_{d} L$ 降解货物。\n\n- 稳态自噬流 $J_{\\mathrm{flux}}$ 定义为稳态时的降解通量，与通路上的流平衡一致。\n\n在这些假设下，动力学方程为\n$$\n\\frac{dA}{dt} \\;=\\; r \\;-\\; k_{f} A, \\qquad \\frac{dL}{dt} \\;=\\; k_{f} A \\;-\\; k_{d} L,\n$$\n且稳态时的自噬流满足\n$$\nJ_{\\mathrm{flux}} \\;=\\; k_{d} L \\;=\\; k_{f} A \\;=\\; r.\n$$\n\n1. 从上述定义和稳态条件出发，推导 $J_{\\mathrm{flux}}$ 关于 $k_{i}$、$k_{d}$、$\\beta$ 和 $s(N)$ 的显式闭式表达式。\n\n2. 使用流对于参数 $p$ 的局部归一化灵敏度 $S_{p}$ 的定义，\n$$\nS_{p} \\;=\\; \\frac{p}{J_{\\mathrm{flux}}} \\,\\frac{\\partial J_{\\mathrm{flux}}}{\\partial p},\n$$\n推导 $S_{k_{i}}$、$S_{k_{d}}$ 和 $S_{\\beta}$ 作为参数和 $s(N)$ 函数的解析表达式。\n\n3. 使用参数值 $k_{i} = 0.08\\,\\mathrm{min}^{-1}$、$k_{d} = 0.20\\,\\mathrm{min}^{-1}$ 和 $\\beta = 0.50$，在由激活因子 $s(N_{\\mathrm{high}}) = 0.30$ 和 $s(N_{\\mathrm{low}}) = 0.80$ 表征的两种营养条件下评估灵敏度。通过比较灵敏度的大小，用文字指出在哪种营养条件下，三个速率常数中的哪一个对 $J_{\\mathrm{flux}}$ 的影响最大。\n\n4. 令 $M_{\\mathrm{high}}$ 表示在 $s(N_{\\mathrm{high}})$ 条件下计算的 $\\{|S_{k_{i}}|, |S_{k_{d}}|, |S_{\\beta}|\\}$ 中的最大绝对值，令 $M_{\\mathrm{low}}$ 表示在 $s(N_{\\mathrm{low}})$ 条件下的类似最大值。计算乘积 $M_{\\mathrm{high}} \\times M_{\\mathrm{low}}$。将最终数值答案四舍五入到四位有效数字，并表示为一个无量纲数。", "solution": "该问题陈述具有科学依据，提法恰当且客观。它使用生物化学动力学和系统分析的标准原理，提出了一个简化但连贯的自噬调控网络数学模型。定义清晰，所提供的参数一致。因此，该问题被认为是有效的，可以构建一个完整的解答。\n\n**第1部分：稳态自噬流 $J_{\\mathrm{flux}}$ 的推导**\n\n在稳态下，每种物质的产生和消耗速率达到平衡。问题给出了稳态流条件：\n$$\nJ_{\\mathrm{flux}} \\;=\\; r \\;=\\; k_{f} A \\;=\\; k_{d} L\n$$\n我们已知起始速率 $r$ 的表达式：\n$$\nr \\;=\\; \\frac{k_{i}\\, s(N)}{1 + \\beta\\, L}\n$$\n根据流平衡条件，我们可以用流 $J_{\\mathrm{flux}}$ 和降解速率常数 $k_d$ 来表示稳态自噬溶酶体池 $L$：\n$$\nJ_{\\mathrm{flux}} = k_d L \\implies L = \\frac{J_{\\mathrm{flux}}}{k_d}\n$$\n将 $L$ 的这个表达式以及条件 $J_{\\mathrm{flux}} = r$ 代入起始速率方程，我们得到一个关于 $J_{\\mathrm{flux}}$ 的方程：\n$$\nJ_{\\mathrm{flux}} \\;=\\; \\frac{k_{i}\\, s(N)}{1 + \\beta \\left(\\frac{J_{\\mathrm{flux}}}{k_d}\\right)}\n$$\n为了求解 $J_{\\mathrm{flux}}$，我们整理这个方程：\n$$\nJ_{\\mathrm{flux}} \\left(1 + \\frac{\\beta J_{\\mathrm{flux}}}{k_d}\\right) \\;=\\; k_i s(N)\n$$\n$$\nJ_{\\mathrm{flux}} + \\frac{\\beta}{k_d} J_{\\mathrm{flux}}^2 \\;=\\; k_i s(N)\n$$\n这可以写成一个标准的一元二次方程形式 $ax^2 + bx + c = 0$，其中 $x = J_{\\mathrm{flux}}$：\n$$\n\\left(\\frac{\\beta}{k_d}\\right) J_{\\mathrm{flux}}^2 + (1) J_{\\mathrm{flux}} - k_i s(N) = 0\n$$\n$J_{\\mathrm{flux}}$ 的解由求根公式给出：\n$$\nJ_{\\mathrm{flux}} \\;=\\; \\frac{-1 \\pm \\sqrt{1^2 - 4\\left(\\frac{\\beta}{k_d}\\right)\\left(-k_i s(N)\\right)}}{2\\left(\\frac{\\beta}{k_d}\\right)} \\;=\\; \\frac{-1 \\pm \\sqrt{1 + \\frac{4 \\beta k_i s(N)}{k_d}}}{\\frac{2\\beta}{k_d}}\n$$\n由于流 $J_{\\mathrm{flux}}$ 必须是一个非负的物理量，我们必须选择正根。对于正参数，平方根下的项严格大于1，因此‘+’号产生正解，而‘-’号产生负解。\n因此，$J_{\\mathrm{flux}}$ 的显式闭式表达式为：\n$$\nJ_{\\mathrm{flux}} \\;=\\; \\frac{k_d}{2\\beta} \\left(-1 + \\sqrt{1 + \\frac{4 \\beta k_i s(N)}{k_d}}\\right)\n$$\n\n**第2部分：灵敏度 $S_{p}$ 的推导**\n\n局部归一化灵敏度 $S_p$ 定义为 $S_{p} = \\frac{p}{J_{\\mathrm{flux}}} \\frac{\\partial J_{\\mathrm{flux}}}{\\partial p}$。为了求偏导数，我们可以对流方程的二次形式进行隐式微分，我们将其表示为 $F$：\n$$\nF(J_{\\mathrm{flux}}, k_i, k_d, \\beta) \\;=\\; J_{\\mathrm{flux}} + \\frac{\\beta}{k_d} J_{\\mathrm{flux}}^2 - k_i s(N) = 0\n$$\n流相对于参数 $p$ 的偏导数为 $\\frac{\\partial J_{\\mathrm{flux}}}{\\partial p} = -\\frac{\\partial F / \\partial p}{\\partial F / \\partial J_{\\mathrm{flux}}}$。相对于 $J_{\\mathrm{flux}}$ 的导数为：\n$$\n\\frac{\\partial F}{\\partial J_{\\mathrm{flux}}} \\;=\\; 1 + \\frac{2\\beta}{k_d} J_{\\mathrm{flux}}\n$$\n\n**对 $k_i$ 的灵敏度 ($S_{k_i}$)：**\n相对于 $k_i$ 的偏导数为 $\\frac{\\partial F}{\\partial k_i} = -s(N)$。\n$$\n\\frac{\\partial J_{\\mathrm{flux}}}{\\partial k_i} \\;=\\; -\\frac{-s(N)}{1 + \\frac{2\\beta}{k_d} J_{\\mathrm{flux}}} \\;=\\; \\frac{s(N)}{1 + \\frac{2\\beta}{k_d} J_{\\mathrm{flux}}}\n$$\n灵敏度为：\n$$\nS_{k_i} \\;=\\; \\frac{k_i}{J_{\\mathrm{flux}}} \\frac{\\partial J_{\\mathrm{flux}}}{\\partial k_i} \\;=\\; \\frac{k_i s(N)}{J_{\\mathrm{flux}}} \\frac{1}{1 + \\frac{2\\beta}{k_d} J_{\\mathrm{flux}}}\n$$\n从二次方程中，我们有 $k_i s(N) = J_{\\mathrm{flux}} + \\frac{\\beta}{k_d} J_{\\mathrm{flux}}^2$。因此，$\\frac{k_i s(N)}{J_{\\mathrm{flux}}} = 1 + \\frac{\\beta}{k_d} J_{\\mathrm{flux}}$。代入此式得到：\n$$\nS_{k_i} \\;=\\; \\frac{1 + \\frac{\\beta}{k_d} J_{\\mathrm{flux}}}{1 + \\frac{2\\beta}{k_d} J_{\\mathrm{flux}}}\n$$\n\n**对 $k_d$ 的灵敏度 ($S_{k_d}$)：**\n相对于 $k_d$ 的偏导数为 $\\frac{\\partial F}{\\partial k_d} = -\\frac{\\beta}{k_d^2} J_{\\mathrm{flux}}^2$。\n$$\n\\frac{\\partial J_{\\mathrm{flux}}}{\\partial k_d} \\;=\\; -\\frac{-\\frac{\\beta}{k_d^2} J_{\\mathrm{flux}}^2}{1 + \\frac{2\\beta}{k_d} J_{\\mathrm{flux}}} \\;=\\; \\frac{\\frac{\\beta}{k_d^2} J_{\\mathrm{flux}}^2}{1 + \\frac{2\\beta}{k_d} J_{\\mathrm{flux}}}\n$$\n灵敏度为：\n$$\nS_{k_d} \\;=\\; \\frac{k_d}{J_{\\mathrm{flux}}} \\frac{\\partial J_{\\mathrm{flux}}}{\\partial k_d} \\;=\\; \\frac{k_d}{J_{\\mathrm{flux}}} \\frac{\\frac{\\beta}{k_d^2} J_{\\mathrm{flux}}^2}{1 + \\frac{2\\beta}{k_d} J_{\\mathrm{flux}}} \\;=\\; \\frac{\\frac{\\beta}{k_d} J_{\\mathrm{flux}}}{1 + \\frac{2\\beta}{k_d} J_{\\mathrm{flux}}}\n$$\n\n**对 $\\beta$ 的灵敏度 ($S_{\\beta}$)：**\n相对于 $\\beta$ 的偏导数为 $\\frac{\\partial F}{\\partial \\beta} = \\frac{1}{k_d} J_{\\mathrm{flux}}^2$。\n$$\n\\frac{\\partial J_{\\mathrm{flux}}}{\\partial \\beta} \\;=\\; -\\frac{\\frac{1}{k_d} J_{\\mathrm{flux}}^2}{1 + \\frac{2\\beta}{k_d} J_{\\mathrm{flux}}}\n$$\n灵敏度为：\n$$\nS_{\\beta} \\;=\\; \\frac{\\beta}{J_{\\mathrm{flux}}} \\frac{\\partial J_{\\mathrm{flux}}}{\\partial \\beta} \\;=\\; \\frac{\\beta}{J_{\\mathrm{flux}}} \\left(-\\frac{\\frac{1}{k_d} J_{\\mathrm{flux}}^2}{1 + \\frac{2\\beta}{k_d} J_{\\mathrm{flux}}}\\right) \\;=\\; -\\frac{\\frac{\\beta}{k_d} J_{\\mathrm{flux}}}{1 + \\frac{2\\beta}{k_d} J_{\\mathrm{flux}}}\n$$\n注意 $S_{\\beta} = -S_{k_d}$。\n\n**第3部分：灵敏度评估**\n\n给定参数 $k_i = 0.08\\,\\mathrm{min}^{-1}$，$k_d = 0.20\\,\\mathrm{min}^{-1}$ 和 $\\beta = 0.50$。\n让我们计算流方程中的常数项：\n$\\frac{k_d}{2\\beta} = \\frac{0.20}{2 \\times 0.50} = 0.20$。\n$\\frac{4\\beta k_i}{k_d} = \\frac{4 \\times 0.50 \\times 0.08}{0.20} = \\frac{0.16}{0.20} = 0.80$。\n\n**情况1：高营养， $s(N_{\\mathrm{high}}) = 0.30$**\n流为：\n$$\nJ_{\\mathrm{flux, high}} \\;=\\; 0.20 \\left(-1 + \\sqrt{1 + 0.80 \\times 0.30}\\right) \\;=\\; 0.20 \\left(-1 + \\sqrt{1.24}\\right) \\approx 0.022711\\,\\mathrm{min}^{-1}\n$$\n为了计算灵敏度，我们需要项 $X_{\\mathrm{high}} = \\frac{\\beta}{k_d} J_{\\mathrm{flux, high}} = \\frac{0.50}{0.20} J_{\\mathrm{flux, high}} = 2.5 J_{\\mathrm{flux, high}} \\approx 0.056776$。\n灵敏度为：\n$S_{k_i, \\mathrm{high}} = \\frac{1+X_{\\mathrm{high}}}{1+2X_{\\mathrm{high}}} \\approx \\frac{1.056776}{1.113553} \\approx 0.94901$。\n$S_{k_d, \\mathrm{high}} = \\frac{X_{\\mathrm{high}}}{1+2X_{\\mathrm{high}}} \\approx \\frac{0.056776}{1.113553} \\approx 0.050986$。\n$S_{\\beta, \\mathrm{high}} = -S_{k_d, \\mathrm{high}} \\approx -0.050986$。\n大小分别为 $|S_{k_i}| \\approx 0.949$，$|S_{k_d}| \\approx 0.051$，$|S_{\\beta}| \\approx 0.051$。在此条件下，$k_i$ 对流 $J_{\\mathrm{flux}}$ 的影响最大。\n\n**情况2：低营养， $s(N_{\\mathrm{low}}) = 0.80$**\n流为：\n$$\nJ_{\\mathrm{flux, low}} \\;=\\; 0.20 \\left(-1 + \\sqrt{1 + 0.80 \\times 0.80}\\right) \\;=\\; 0.20 \\left(-1 + \\sqrt{1.64}\\right) \\approx 0.056125\\,\\mathrm{min}^{-1}\n$$\n我们计算 $X_{\\mathrm{low}} = \\frac{\\beta}{k_d} J_{\\mathrm{flux, low}} = 2.5 J_{\\mathrm{flux, low}} \\approx 0.14031$。\n灵敏度为：\n$S_{k_i, \\mathrm{low}} = \\frac{1+X_{\\mathrm{low}}}{1+2X_{\\mathrm{low}}} \\approx \\frac{1.14031}{1.28062} \\approx 0.89043$。\n$S_{k_d, \\mathrm{low}} = \\frac{X_{\\mathrm{low}}}{1+2X_{\\mathrm{low}}} \\approx \\frac{0.14031}{1.28062} \\approx 0.10956$。\n$S_{\\beta, \\mathrm{low}} = -S_{k_d, \\mathrm{low}} \\approx -0.10956$。\n大小分别为 $|S_{k_i}| \\approx 0.890$，$|S_{k_d}| \\approx 0.110$，$|S_{\\beta}| \\approx 0.110$。在此条件下，$k_i$ 仍然对流 $J_{\\mathrm{flux}}$ 的影响最大，尽管其主导地位与高营养情况相比有所减弱。\n\n**第4部分：$M_{\\mathrm{high}} \\times M_{\\mathrm{low}}$ 的计算**\n\n根据第3部分，我们确定每种条件下的最大绝对灵敏度。\n对于高营养条件，$M_{\\mathrm{high}} = \\max\\{|S_{k_i, \\mathrm{high}}|, |S_{k_d, \\mathrm{high}}|, |S_{\\beta, \\mathrm{high}}|\\} = |S_{k_i, \\mathrm{high}}| \\approx 0.94901$。\n对于低营养条件，$M_{\\mathrm{low}} = \\max\\{|S_{k_i, \\mathrm{low}}|, |S_{k_d, \\mathrm{low}}|, |S_{\\beta, \\mathrm{low}}|\\} = |S_{k_i, \\mathrm{low}}| \\approx 0.89043$。\n\n使用更高精度的值进行计算：\n$M_{\\mathrm{high}} = \\frac{1+0.5(-1+\\sqrt{1.24})}{1+2 \\times 0.5(-1+\\sqrt{1.24})} = \\frac{0.5(1+\\sqrt{1.24})}{\\sqrt{1.24}} \\approx 0.94900636$。\n$M_{\\mathrm{low}} = \\frac{1+0.5(-1+\\sqrt{1.64})}{1+2 \\times 0.5(-1+\\sqrt{1.64})} = \\frac{0.5(1+\\sqrt{1.64})}{\\sqrt{1.64}} \\approx 0.89043323$。\n\n乘积为：\n$$\nM_{\\mathrm{high}} \\times M_{\\mathrm{low}} \\approx 0.94900636 \\times 0.89043323 \\approx 0.8450199\n$$\n将此结果四舍五入到四位有效数字，得到 $0.8450$。", "answer": "$$\\boxed{0.8450}$$", "id": "4317265"}, {"introduction": "最后的这个练习将超越稳态分析，探索自噬网络的动态行为。通过对一个带有时间延迟的负反馈回路进行建模——该延迟代表了信号传导和分子组装所需的有限时间——我们可以研究产生持续性振荡的条件。本练习旨在阐明，网络拓扑和时间动态如何能够产生如节律性自噬活动等复杂的、非直观的模式。[@problem_id:4317257]", "problem": "考虑一个最小的无量纲延迟微分方程，该方程描述了自噬调控网络中上游自噬信号与下游自噬机制组装之间的净延迟负反馈：标量状态变量 $m(t)$ 代表有效的自噬体组装活性，该活性在经过一段有限的处理延迟后被信号下调。该模型由下式给出：\n$$\\frac{dm(t)}{dt} = -k\\,m(t) - g\\,m(t - \\tau),$$\n其中 $k > 0$ 是组装活性的基础转换率，$g > 0$ 是由信号到机制的耦合（例如，通过 Mechanistic Target of Rapamycin Complex $1$ (mTORC1) 和 Unc-$51$ Like Autophagy Activating Kinase $1$ (ULK1) 介导的对 Autophagy Related proteins (ATG) 的控制）产生的延迟抑制的有效幅度，而 $\\tau > 0$ 是有效延迟。所有量均为无量纲，角度必须以弧度为单位。\n\n从线性稳定性的核心定义以及具有恒定延迟的线性自治系统的性质出发，通过检验上述线性化模型中振荡不稳定性（Hopf型）的出现，分析相应非线性饱和系统中是否存在持续振荡。具体来说：\n\n- 从第一性原理出发，推导决定稳态 $m^* = 0$ 线性稳定性的特征条件。\n- 确定存在一对纯虚特征值的条件，这标志着振荡不稳定性的开始。将振荡频率 $\\,\\omega\\,$ 和最小正临界延迟 $\\,\\tau_{\\mathrm{crit}}\\,$ 表示为 $k$ 和 $g$ 的函数。\n- 使用这些条件，为完整的饱和非线性系统中持续振荡的可能性定义一个算法判据：当且仅当 $g > k$ 且 $\\tau \\ge \\tau_{\\mathrm{crit}}$ 时，判定振荡为“可能”，其中 $\\tau_{\\mathrm{crit}}$ 是最小正临界延迟（即第一个不稳定性阈值）。如果 $g \\le k$，则判定为“不可能”。\n\n实现一个程序，对于下面测试套件中的每一组参数，应用所推导的判据，并输出一个布尔值，以指示是否可能出现持续的自噬振荡。\n\n测试套件（每种情况为 $(k,g,\\tau)$）：\n- 情况 1：$(0.5,\\,1.0,\\,2.5)$\n- 情况 2：$(1.0,\\,1.0,\\,1.0)$\n- 情况 3：$(0.2,\\,0.5,\\,3.0)$\n- 情况 4：$(0.3,\\,2.0,\\,1.2)$\n- 情况 5：$(0.99,\\,1.0,\\,25.0)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，例如 $[result_1,result_2,\\dots]$，其中每个 $result_i$ 是一个布尔值。不应打印任何其他文本。", "solution": "该问题要求对给定的延迟微分方程（DDE）的稳态 $m^* = 0$ 进行线性稳定性分析。目标是确定系统在何种条件下会经历 Hopf 分岔，从而导致振荡的出现。然后，这些条件将被用来构建一个算法判据，以评估给定参数集下出现持续振荡的可能性。\n\n该模型是线性的自治DDE：\n$$\n\\frac{dm(t)}{dt} = -k\\,m(t) - g\\,m(t - \\tau)\n$$\n其中 $k$、$g$ 和 $\\tau$ 是正常数。\n\n**步骤1：特征方程的推导**\n为了分析平衡点 $m(t)=0$ 的线性稳定性，我们寻找 $m(t) = C e^{\\lambda t}$ 形式的解，其中 $\\lambda$ 是一个表示特征值（本征值）的复数。将此拟设解代入DDE得到：\n$$\n\\frac{d}{dt}(C e^{\\lambda t}) = -k(C e^{\\lambda t}) - g(C e^{\\lambda(t - \\tau)})\n$$\n$$\nC \\lambda e^{\\lambda t} = -k C e^{\\lambda t} - g C e^{\\lambda t} e^{-\\lambda \\tau}\n$$\n对于非平凡解（$C \\neq 0$），我们可以将整个方程除以 $C e^{\\lambda t}$：\n$$\n\\lambda = -k - g e^{-\\lambda \\tau}\n$$\n重新整理各项，得到特征方程，这是一个关于 $\\lambda$ 的超越方程：\n$$\n\\lambda + k + g e^{-\\lambda \\tau} = 0\n$$\n稳态 $m^*=0$ 的稳定性由该方程的根 $\\lambda$ 的实部符号决定。如果所有根的实部都为负（$\\text{Re}(\\lambda) < 0$），则稳态是渐近稳定的。如果至少有一个根的实部为正（$\\text{Re}(\\lambda) > 0$），则出现不稳定性。可能出现振荡的稳定性边界对应于一对纯虚根。\n\n**步骤2：纯虚根的条件（Hopf分岔）**\n当一对共轭复根穿过虚轴时，发生 Hopf 分岔。在分岔点，根是纯虚数。设 $\\lambda = i\\omega$，其中 $\\omega \\in \\mathbb{R}$ 是振荡开始时的角频率。由于参数 $k$ 和 $g$ 是实数，如果 $i\\omega$ 是一个根，则其共轭复数 $-i\\omega$也必定是根。不失一般性，我们可以假设 $\\omega > 0$。\n\n将 $\\lambda = i\\omega$ 代入特征方程：\n$$\ni\\omega + k + g e^{-i\\omega \\tau} = 0\n$$\n使用欧拉公式 $e^{-i\\omega \\tau} = \\cos(\\omega \\tau) - i \\sin(\\omega \\tau)$，我们得到：\n$$\ni\\omega + k + g (\\cos(\\omega \\tau) - i \\sin(\\omega \\tau)) = 0\n$$\n为了满足此方程，左侧的实部和虚部都必须为零。分离实部和虚部：\n$$\n\\text{实部： } k + g \\cos(\\omega \\tau) = 0\n$$\n$$\n\\text{虚部： } \\omega - g \\sin(\\omega \\tau) = 0\n$$\n这给了我们一个由两个方程组成的系统：\n$$\n(1) \\quad \\cos(\\omega \\tau) = -\\frac{k}{g}\n$$\n$$\n(2) \\quad \\sin(\\omega \\tau) = \\frac{\\omega}{g}\n$$\n\n**步骤3：振荡频率 $\\omega$ 和临界延迟 $\\tau_{\\mathrm{crit}}$ 的推导**\n为了求出 $\\omega$，我们使用基本三角恒等式 $\\sin^2(\\theta) + \\cos^2(\\theta) = 1$。将其应用于方程 (1) 和 (2)：\n$$\n\\left(\\frac{\\omega}{g}\\right)^2 + \\left(-\\frac{k}{g}\\right)^2 = 1\n$$\n$$\n\\frac{\\omega^2}{g^2} + \\frac{k^2}{g^2} = 1\n$$\n$$\n\\omega^2 + k^2 = g^2\n$$\n解出 $\\omega^2$：\n$$\n\\omega^2 = g^2 - k^2\n$$\n由于 $\\omega$ 必须是一个实数频率，为了存在振荡，我们要求 $\\omega^2 > 0$。这意味着 $g^2 - k^2 > 0$。因为 $g$ 和 $k$ 都被定义为正数，这个不等式等价于 $g > k$。如果 $g \\le k$，则不存在满足条件的实数 $\\omega > 0$，这意味着 Hopf 分岔不会发生，并且系统对于所有延迟 $\\tau \\ge 0$ 都是稳定的。这提供了算法判据的第一部分。\n\n如果 $g > k$，不稳定性开始时的振荡频率是唯一的，由下式给出：\n$$\n\\omega = \\sqrt{g^2 - k^2}\n$$\n现在，我们确定发生这种情况时的临界延迟 $\\tau$。从方程 (1) 和 (2) 中，我们知道 $\\cos(\\omega\\tau) < 0$（因为 $k,g > 0$）和 $\\sin(\\omega\\tau) > 0$（因为 $\\omega,g > 0$）。这意味着角 $\\omega\\tau$ 必须位于第二象限。我们可以通过对方程 (1) 取反余弦来找到 $\\tau$：\n$$\n\\omega \\tau = \\arccos\\left(-\\frac{k}{g}\\right) + 2n\\pi, \\quad \\text{for } n = 0, 1, 2, \\dots\n$$\n$\\arccos(x)$ 的主值在 $[0, \\pi]$ 区间内。由于 $-1 < -k/g < 0$（因为 $g>k$），主值 $\\arccos(-k/g)$ 在 $(\\pi/2, \\pi)$ 区间内，这正确地将角度置于第二象限。\n\n因此，临界延迟 $\\tau_n$ 为：\n$$\n\\tau_n = \\frac{1}{\\omega} \\left( \\arccos\\left(-\\frac{k}{g}\\right) + 2n\\pi \\right)\n$$\n第一次不稳定性发生在最小的正延迟处，对应于 $n=0$。这就是临界延迟 $\\tau_{\\mathrm{crit}}$：\n$$\n\\tau_{\\mathrm{crit}} = \\frac{1}{\\omega} \\arccos\\left(-\\frac{k}{g}\\right) = \\frac{1}{\\sqrt{g^2 - k^2}} \\arccos\\left(-\\frac{k}{g}\\right)\n$$\n对于 $\\tau < \\tau_{\\mathrm{crit}}$，稳态是稳定的。在 $\\tau = \\tau_{\\mathrm{crit}}$ 时，发生 Hopf 分岔。对于 $\\tau > \\tau_{\\mathrm{crit}}$，稳态是不稳定的，并且在相应的非线性系统中预期会出现振荡。\n\n**步骤4：算法判据**\n基于以上推导，持续振荡可能性的判据如下：\n1.  检查是否 $g > k$。如果不满足（$g \\le k$），则不可能发生振荡，因为 Hopf 分岔不会发生。\n2.  如果 $g > k$，计算临界延迟 $\\tau_{\\mathrm{crit}} = \\frac{1}{\\sqrt{g^2 - k^2}} \\arccos\\left(-\\frac{k}{g}\\right)$。\n3.  将给定的延迟 $\\tau$ 与 $\\tau_{\\mathrm{crit}}$ 进行比较。如果 $\\tau \\ge \\tau_{\\mathrm{crit}}$，系统处于或超过第一个不稳定性阈值，持续振荡被视为“可能”。否则（$\\tau < \\tau_{\\mathrm{crit}}$），系统是稳定的，振荡被视为“不可能”。\n\n该逻辑将被实现以评估所提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the stability of a delay differential equation for autophagy regulation\n    to determine the possibility of sustained oscillations.\n    \"\"\"\n\n    # Test suite: each tuple is (k, g, tau)\n    test_cases = [\n        (0.5, 1.0, 2.5),    # Case 1\n        (1.0, 1.0, 1.0),    # Case 2\n        (0.2, 0.5, 3.0),    # Case 3\n        (0.3, 2.0, 1.2),    # Case 4\n        (0.99, 1.0, 25.0),  # Case 5\n    ]\n\n    results = []\n    for k, g, tau in test_cases:\n        # The problem defines k > 0, g > 0, tau > 0.\n        # The analysis is for a linear system representing a minimal model.\n        # Oscillations are deemed \"possible\" in the corresponding nonlinear system\n        # if the linear system is at or past the point of Hopf instability.\n\n        # Step 1: Check the necessary condition for Hopf bifurcation (g > k).\n        # If g = k, the system is stable for all tau >= 0, so no oscillations can arise.\n        if g = k:\n            results.append(False)\n            continue\n\n        # Step 2: If g > k, a Hopf bifurcation is possible. Calculate the critical delay.\n        # The oscillation frequency omega at the bifurcation point is sqrt(g^2 - k^2).\n        omega = np.sqrt(g**2 - k**2)\n\n        # The smallest positive critical delay tau_crit is derived from the\n        # characteristic equation when lambda = i*omega.\n        # tau_crit = (1/omega) * arccos(-k/g)\n        # Note: np.arccos returns values in [0, pi], which correctly corresponds to\n        # the principal (n=0) solution for the delay.\n        tau_crit = (1 / omega) * np.arccos(-k / g)\n\n        # Step 3: Compare the system's delay tau with the critical delay.\n        # Oscillations are possible if the system is at or beyond the first\n        # instability threshold, i.e., tau >= tau_crit.\n        if tau >= tau_crit:\n            results.append(True)\n        else:\n            results.append(False)\n\n    # Final print statement in the exact required format.\n    # The output should be a list of booleans.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4317257"}]}