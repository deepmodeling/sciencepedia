{"hands_on_practices": [{"introduction": "理解基因删除影响的第一步是解读基因-蛋白质-反应（GPR）规则。本练习 [@problem_id:4345204] 探讨了一种常见情况：某个代谢反应对于生长至关重要，但由于遗传冗余，与之相关的任何单个基因都不是必需的。通过分析一个涉及同工酶复合物的 GPR 结构，您将学习区分反应必需性与基因必需性，并确定终止一项代谢功能所需的最小基因删除集。", "problem": "考虑一个为稳态通量平衡分析（FBA）建模的简化代谢网络。该网络包含三种细胞内代谢物 $A$、$B$ 和 $C$，以及四个不可逆反应，其通量分别为 $v_{0}$、$v_{1}$、$v_{R}$ 和 $v_{\\mathrm{bm}}$。化学计量矩阵 $S \\in \\mathbb{R}^{3 \\times 4}$ 由以下反应定义给出：\n- $v_{0}$：从细胞外空间输入 $A$，$A_{\\mathrm{ext}} \\rightarrow A$，\n- $v_{1}$：转化 $A \\rightarrow B$，\n- $v_{R}$：转化 $B \\rightarrow C$，\n- $v_{\\mathrm{bm}}$：生物质汇 $C \\rightarrow \\text{生物质}$。\n\n这对应于化学计量约束 $S v = 0$，其中\n$$\nS = \n\\begin{pmatrix}\n1  -1  0  0 \\\\\n0  1  -1  0 \\\\\n0  0  1  -1\n\\end{pmatrix}, \\quad\nv = \n\\begin{pmatrix}\nv_{0} \\\\\nv_{1} \\\\\nv_{R} \\\\\nv_{\\mathrm{bm}}\n\\end{pmatrix}.\n$$\n假设有以下容量约束和目标：\n- 边界：$0 \\leq v_{0} \\leq b$, $0 \\leq v_{1}$, $0 \\leq v_{R}$, $0 \\leq v_{\\mathrm{bm}}$，其中 $b  0$ 是一个有限的摄取上界。\n- 目标：最大化 $v_{\\mathrm{bm}}$。\n\n反应 $v_{R}$ 由两个不相交的同工酶复合物催化，其基因-蛋白质-反应（GPR）规则为\n$$\n(g_{1} \\wedge g_{2}) \\vee (g_{3} \\wedge g_{4}),\n$$\n这意味着，催化反应的充分条件是基因 $g_{1}$ 和 $g_{2}$ 同时存在，或者基因 $g_{3}$ 和 $g_{4}$ 同时存在。对于 $i \\in \\{1,2,3,4\\}$，每个基因 $g_{i}$ 都可以被独立删除。\n\n仅从 FBA 稳态质量平衡 $S v = 0$、容量边界以及作为指示催化可行性的单调布尔公式的 GPR 规则定义出发，执行以下操作：\n1. 证明在该网络中，对于任何非零的最优生物质通量 $v_{\\mathrm{bm}}$，反应 $v_{R}$ 都是必需的。\n2. 论证在这些约束条件下，为何 $\\{g_{1}, g_{2}, g_{3}, g_{4}\\}$ 中的任何单个基因删除对于生长都不是必需的。\n3. 计算使反应 $v_{R}$ 失活所需的最小不同基因删除数，从而迫使最优生物质通量为零。将最终答案表示为一个整数。无需四舍五入，也无需单位。", "solution": "对问题陈述进行分析后，发现其是有效的。它科学地基于通量平衡分析（FBA）的原理，这是系统生物学和生物医学中的一种标准方法。该问题是适定的，提供了一套完整且一致的给定条件：一个化学计量矩阵、通量边界、一个线性目标函数和一个基因-蛋白质-反应（GPR）规则。其语言精确客观，允许通过数学推导得到一个唯一且可验证的解。\n\n该问题需要对一个简化的代谢网络进行三部分分析。我们将依次处理每个部分。\n\n**第 1 部分：反应 $v_R$ 对生物质生产的必需性**\n\n给定稳态条件 $S v = 0$，其中 $S$ 是化学计量矩阵，$v$ 是反应通量向量。将其明确写出：\n$$\n\\begin{pmatrix}\n1  -1  0  0 \\\\\n0  1  -1  0 \\\\\n0  0  1  -1\n\\end{pmatrix}\n\\begin{pmatrix}\nv_{0} \\\\\nv_{1} \\\\\nv_{R} \\\\\nv_{\\mathrm{bm}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n0\n\\end{pmatrix}\n$$\n该矩阵方程分别对应于代表代谢物 $A$、$B$ 和 $C$ 质量平衡的以下线性方程组：\n1. 对于代谢物 $A$：$1 \\cdot v_{0} - 1 \\cdot v_{1} = 0 \\implies v_{0} = v_{1}$\n2. 对于代谢物 $B$：$1 \\cdot v_{1} - 1 \\cdot v_{R} = 0 \\implies v_{1} = v_{R}$\n3. 对于代谢物 $C$：$1 \\cdot v_{R} - 1 \\cdot v_{\\mathrm{bm}} = 0 \\implies v_{R} = v_{\\mathrm{bm}}$\n\n从这些方程可以得出，对于任何有效的稳态通量分布，网络中的所有通量都必须相等：\n$$\nv_{0} = v_{1} = v_{R} = v_{\\mathrm{bm}}\n$$\nFBA 问题的目标是最大化生物质通量 $v_{\\mathrm{bm}}$。设最优生物质通量为 $v_{\\mathrm{bm}}^*$。如果存在一个非零最优解，即 $v_{\\mathrm{bm}}^*  0$，那么由于稳态约束，反应 $v_R$ 对应的最优通量也必须是非零的，并且等于生物质通量：$v_{R}^* = v_{\\mathrm{bm}}^*  0$。\n\n如果一个反应的失活（将其通量强制为零）导致该代谢功能（此处为生物质生产）的完全丧失（生物质通量为零），则该反应被定义为对该功能是必需的。如果我们将反应 $v_R$ 失活，即设置 $v_R = 0$，稳态条件 $v_R = v_{\\mathrm{bm}}$ 将直接意味着 $v_{\\mathrm{bm}}$也必须为 $0$。因此，在该网络中，反应 $v_R$ 对于任何非零的生物质生产都是必需的。\n\n**第 2 部分：单个基因删除的非必需性**\n\n反应 $v_R$ 的催化活性由基因-蛋白质-反应（GPR）规则 $(g_{1} \\wedge g_{2}) \\vee (g_{3} \\wedge g_{4})$ 决定。在这种布尔形式中，基因的存在由 `true` 值表示，其删除由 `false` 值表示。当且仅当该表达式的求值结果为 `true` 时，反应 $v_R$ 是有活性的（可以承载非零通量）。\n\n该规则描述了两种平行的催化途径：一种需要基因 $g_1$ 和 $g_2$ 的共同产物，另一种需要基因 $g_3$ 和 $g_4$ 的共同产物。这些是同工酶复合物。\n\n要确定单个基因是否是必需的，我们必须检查仅删除它是否足以使反应 $v_R$ 失活，从而迫使 $v_{\\mathrm{bm}} = 0$。让我们考虑删除基因 $g_1$。这会将 GPR 表达式中的变量 $g_1$ 设置为 `false`。假设所有其他基因都存在（`true`），则表达式变为：\n$$\n(\\text{false} \\wedge \\text{true}) \\vee (\\text{true} \\wedge \\text{true})\n$$\n其求值结果为：\n$$\n\\text{false} \\vee \\text{true} = \\text{true}\n$$\n由于 GPR 表达式的求值结果为 `true`，反应 $v_R$ 仍然保持活性。由基因 $g_3$ 和 $g_4$ 形成的酶复合物仍然可以催化该反应。由于 $v_R$ 仍可承载通量，FBA 问题基本保持不变，并且可以实现非零的最优生物质通量，仅受摄取上界 $b$ 的限制（即 $v_{\\mathrm{bm}}^* = b$）。\n\n对于删除任何其他单个基因，论证是对称的：\n- 删除 $g_2$：$(\\text{true} \\wedge \\text{false}) \\vee (\\text{true} \\wedge \\text{true}) = \\text{false} \\vee \\text{true} = \\text{true}$。\n- 删除 $g_3$：$(\\text{true} \\wedge \\text{true}) \\vee (\\text{false} \\wedge \\text{true}) = \\text{true} \\vee \\text{false} = \\text{true}$。\n- 删除 $g_4$：$(\\text{true} \\wedge \\text{true}) \\vee (\\text{true} \\wedge \\text{false}) = \\text{true} \\vee \\text{false} = \\text{true}$。\n\n在所有单个基因删除的情况下，反应 $v_R$ 仍然具有催化活性。因此，$\\{g_1, g_2, g_3, g_4\\}$ 中的任何单个基因删除对于生长都不是必需的。\n\n**第 3 部分：使 $v_R$ 失活所需的最小基因删除数**\n\n要使反应 $v_R$ 失活，GPR 表达式 $(g_1 \\wedge g_2) \\vee (g_3 \\wedge g_4)$ 的求值结果必须为 `false`。该表达式是两个子句的逻辑析取（OR）：$C_1 = (g_1 \\wedge g_2)$ 和 $C_2 = (g_3 \\wedge g_4)$。要使整个表达式 $C_1 \\vee C_2$ 为 `false`，则 $C_1$ 和 $C_2$ 都必须为 `false`。\n\n1. 要使 $C_1 = (g_1 \\wedge g_2)$ 为 `false`，集合 $\\{g_1, g_2\\}$ 中至少有一个基因必须被删除。这至少需要一次删除。\n2. 要使 $C_2 = (g_3 \\wedge g_4)$ 为 `false`，集合 $\\{g_3, g_4\\}$ 中至少有一个基因必须被删除。这也至少需要一次删除。\n\n为了保证 $v_R$ 的失活，我们必须同时满足这两个条件。这意味着任何使反应失活的基因删除集都必须包含至少一个来自 $\\{g_1, g_2\\}$ 的基因，并且至少一个来自 $\\{g_3, g_4\\}$ 的基因。\n\n从第 2 部分中，我们已经确定单个删除是不够的。因此，所需的最小删除数必须大于 $1$。\n\n让我们考虑一个包含两次删除的集合。我们可以通过从第一个子句的集合 $\\{g_1, g_2\\}$ 中选择一个基因，并从第二个子句的集合 $\\{g_3, g_4\\}$ 中选择一个基因来构建这样一个集合。例如，考虑删除基因集 $\\{g_1, g_3\\}$。GPR 表达式变为：\n$$\n(\\text{false} \\wedge g_2) \\vee (\\text{false} \\wedge g_4)\n$$\n假设 $g_2$ 和 $g_4$ 存在（`true`），其求值结果为：\n$$\n(\\text{false} \\wedge \\text{true}) \\vee (\\text{false} \\wedge \\text{true}) = \\text{false} \\vee \\text{false} = \\text{false}\n$$\n这个包含两次删除的集合成功地将 GPR 表达式强制为 `false`，从而使反应 $v_R$ 失活，并迫使最优生物质通量 $v_{\\mathrm{bm}}^*$ 为 $0$。其他包含两次删除的集合，如 $\\{g_1, g_4\\}$、$\\{g_2, g_3\\}$ 和 $\\{g_2, g_4\\}$，也同样有效。\n\n由于一次删除不足够，而两次删除是足够的，因此使反应 $v_R$ 失活所需的最小不同基因删除数是 $2$。", "answer": "$$\\boxed{2}$$", "id": "4345204"}, {"introduction": "虽然通量平衡分析（FBA）是代谢建模的基石，但其标准形式有时会因允许热力学上不可行的循环而产生不符合生物学现实的预测。本练习 [@problem_id:4345133] 演示了这样一个虚构的能量生成循环如何掩盖一个基因的真实必需性。通过比较标准 FBA 与施加了热力学约束的“无环”版本，您将对模型优化的重要性获得关键的洞察，从而实现更准确的基因必需性预测。", "problem": "给定一个最小代谢网络，用于通过流平衡分析 (FBA) 和一种禁止热力学上不可行的内部循环的无环变体来分析基因必需性。该网络有内部代谢物 $Glc$（内部葡萄糖）、$E$（三磷酸腺苷）、$D$（二磷酸腺苷）和 $P$（无机磷酸盐）。反应及其对内部代谢物的化学计量贡献和默认边界如下：\n\n- $R_{\\mathrm{upt}}$：葡萄糖的外部摄取，在内部表示为 $\\varnothing \\rightarrow Glc$，其下界为 $0$，上界参数 $U$ 由每个测试用例提供。\n- $R_{\\mathrm{cat}}$（由基因 $G_{\\mathrm{cat}}$ 催化）：葡萄糖分解代谢产生能量，$Glc + D + P \\rightarrow E$，不可逆，下界为 $0$，上界为 $1000$。\n- $R_{\\mathrm{syn}}$：三磷酸腺苷合酶，$D + P \\leftrightarrow E$，可逆，下界为 $-100$，上界为 $100$（负通量表示反向）。\n- $R_{\\mathrm{atpase}}$：三磷酸腺苷水解，$E \\rightarrow D + P$，不可逆，下界为 $0$，上界为 $100$。\n\n对于内部代谢物（顺序为 $(Glc, E, D, P)$）和反应（顺序为 $(R_{\\mathrm{upt}}, R_{\\mathrm{cat}}, R_{\\mathrm{syn}}, R_{\\mathrm{atpase}})$）的化学计量矩阵 $S \\in \\mathbb{R}^{4 \\times 4}$ 是：\n$$\nS =\n\\begin{bmatrix}\n+1  -1  0  0 \\\\\n0  +1  +1  -1 \\\\\n0  -1  -1  +1 \\\\\n0  -1  -1  +1 \\\\\n\\end{bmatrix}.\n$$\n\n建模基本依据：\n- 稳态质量平衡要求 $S \\, v = 0$，其中 $v \\in \\mathbb{R}^{4}$ 是反应通量向量。\n- 标准流平衡分析 (FBA) 选择 $v$ 以在满足 $S \\, v = 0$ 和通量边界的条件下最大化一个生物学目标。\n- 基因敲除通过将其催化的反应的通量边界设置为 $0$ 来建模。\n- 产能内部循环是一个非零通量向量 $v_{\\mathrm{loop}}$，满足 $S \\, v_{\\mathrm{loop}} = 0$，其支撑集仅在内部反应上，且无净摄取或分泌。在标准 FBA 下，这可能人为地允许在没有底物消耗的情况下获得正的目标值。\n\n目标：\n- 目标是最大化通过 $R_{\\mathrm{atpase}}$ 的通量，记为 $v_{\\mathrm{atpase}}$。在线性规划术语中，即最大化 $v_4$，其中 $v_4$ 是 $v$ 的第四个分量。\n\n必须实现两种优化模式：\n1. 标准 FBA：在满足 $S \\, v = 0$ 和默认边界（由测试用例输入修改）的条件下，最大化 $v_4$。\n2. 无环约束：通过禁止 $R_{\\mathrm{syn}}$ 的正向反应来增强标准 FBA，以消除内部循环 $D + P \\rightarrow E \\rightarrow D + P$。具体来说，施加 $v_3 \\le 0$（即将 $R_{\\mathrm{syn}}$ 的上界设置为 $0$），同时保留其下界 $-100$ 以允许反向反应。对于该网络，这是一个源自热力学一致性的充分无环约束。\n\n基因-反应关联：\n- $G_{\\mathrm{cat}}$ 催化 $R_{\\mathrm{cat}}$。敲除 $G_{\\mathrm{cat}}$ 会将 $R_{\\mathrm{cat}}$ 的边界设置为 $[0, 0]$。\n\n为便于解释，将存活性定义为实现严格为正的最优目标的能力。但是，您的程序必须直接报告最优目标值。\n\n任务：\n- 实现一个程序，该程序为每个测试用例构建并求解相应的线性规划问题，以在满足 $S \\, v = 0$ 以及指定的边界和模式的条件下最大化 $v_4$，并返回最优目标值。\n\n测试套件：\n为以下六个测试用例提供结果，每个用例以三元组 $(\\text{模式}, U, \\text{敲除})$ 形式表示：\n1. $(\\text{\"standard\"}, \\, 0, \\, \\varnothing)$。\n2. $(\\text{\"loopless\"}, \\, 0, \\, \\varnothing)$。\n3. $(\\text{\"standard\"}, \\, 10, \\, \\{G_{\\mathrm{cat}}\\})$。\n4. $(\\text{\"loopless\"}, \\, 10, \\, \\{G_{\\mathrm{cat}}\\})$。\n5. $(\\text{\"loopless\"}, \\, 2, \\, \\varnothing)$。\n6. $(\\text{\"standard\"}, \\, 2, \\, \\varnothing)$。\n\n输入中的所有数值均为无单位且无量纲的通量。您的程序应为每个测试用例求解线性规划问题，并生成一行输出，其中包含六个最优目标值（最大化的 $v_4$），格式为一个用方括号括起来的逗号分隔列表，每个值都四舍五入到恰好三位小数，例如 $[x_1,x_2,x_3,x_4,x_5,x_6]$，其中每个 $x_i$ 是一个格式化为三位小数的浮点数。", "solution": "该问题是有效的，因为它提出了一个在系统生物学领域，特别是流平衡分析 (FBA) 中，适定且有科学依据的场景。所有需要的数据、约束和目标都已明确定义，构成了一系列标准的线性规划 (LP) 问题。\n\n任务的核心是确定在不同条件下，反应 $R_{\\mathrm{atpase}}$ 的最大可能通量，由变量 $v_4$ 表示。这是一个经典的 FBA 问题，可以用线性规划来构建和求解。该优化问题是在一组线性等式和不等式约束下，最大化一个目标函数。\n\nFBA 的基本方程是稳态假设 $S v = 0$，其中 $S$ 是化学计量矩阵，$v$ 是反应通量向量。该方程对代谢网络施加了质量平衡约束，确保对于每个内部代谢物，其总生产速率等于总消耗速率。\n\n给定了化学计量矩阵 $S \\in \\mathbb{R}^{4 \\times 4}$ 和通量向量 $v \\in \\mathbb{R}^{4}$，分别对应于代谢物 $(Glc, E, D, P)$ 和反应 $(R_{\\mathrm{upt}}, R_{\\mathrm{cat}}, R_{\\mathrm{syn}}, R_{\\mathrm{atpase}})$。通量向量为 $v = [v_1, v_2, v_3, v_4]^T$。\n等式约束由 $S v = 0$ 给出：\n$$\n\\begin{bmatrix}\n+1  -1  0  0 \\\\\n0  +1  +1  -1 \\\\\n0  -1  -1  +1 \\\\\n0  -1  -1  +1 \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nv_1 \\\\ v_2 \\\\ v_3 \\\\ v_4\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\ 0 \\\\ 0 \\\\ 0\n\\end{bmatrix}\n$$\n这些矩阵方程对应于一个线性方程组：\n1. $v_1 - v_2 = 0$\n2. $v_2 + v_3 - v_4 = 0$\n3. $-v_2 - v_3 + v_4 = 0$\n4. $-v_2 - v_3 + v_4 = 0$\n\n注意，$S$ 的最后两行是相同的，并且它们都是第二行的负数。这意味着只有两个独立的线性约束：$v_1 = v_2$ 和 $v_4 = v_2 + v_3$。\n\n不等式约束是通量边界 $l_i \\le v_i \\le u_i$，它定义了每个反应 $i$ 的最小和最大允许通量。这些边界对每个测试用例都是特定的。\n\n目标是最大化通量 $v_4$。在 LP 求解器的标准形式中（通常执行最小化），这等同于最小化 $-v_4$。因此，要最小化的目标函数可以表示为 $c^T v$，其中成本向量为 $c = [0, 0, 0, -1]^T$。\n\n总体的 LP 公式为：\n最小化 $c^T v = -v_4$\n受限于：\n1. $S v = 0$\n2. $l \\le v \\le u$\n\n解决方案将通过使用 `scipy.optimize.linprog` 函数为六个测试用例中的每一个构建并求解此 LP 来实现。对于每个用例，通量边界向量 $u$ 和 $l$ 将根据指定的模式（`\"standard\"` 或 `\"loopless\"`）、葡萄糖摄取上限 $U$ 和基因敲除进行调整。\n\n每个测试用例中每个反应 $v_i$ 的具体边界确定如下：\n- **默认边界**：$v_1 \\in [0, U]$, $v_2 \\in [0, 1000]$, $v_3 \\in [-100, 100]$, $v_4 \\in [0, 100]$。\n- **葡萄糖摄取**：$v_1$ 的上界由参数 $U$ 设定。\n- **基因敲除**：敲除 $G_{\\mathrm{cat}}$ 会将其关联反应通量 $v_2$ 的边界设置为 $[0, 0]$。\n- **无环模式**：`\"loopless\"` 约束通过将 $R_{\\mathrm{syn}}$ ($v_3$) 的边界从 $[-100, 100]$ 修改为 $[-100, 0]$ 来实现。此修改禁止了 $R_{\\mathrm{syn}}$ 的正向通量，从而打破了热力学上不可行的无效循环，在该循环中，$v_3  0$ 和 $v_4  0$ 可以在没有底物消耗（$v_1=v_2=0$）的情况下产生正的目标值。\n\n程序将遍历每个测试用例，组合适当的边界，并求解相应的 LP。求解器返回的最优目标值 `res.fun` 是 $-v_4$ 的最小值。因此，最大化的 $v_4$ 是 `-res.fun`。最终结果将按要求收集和格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    为最小代谢网络求解一系列流平衡分析 (FBA) 问题。\n\n    该函数遍历六个测试用例，每个用例由一个优化模式、一个葡萄糖摄取上限和\n    一组基因敲除定义。对于每个用例，它构建并求解一个线性规划问题，以最大化\n    ATP 水解反应的通量。\n    \"\"\"\n\n    # Stoichiometric matrix S for metabolites (Glc, E, D, P) and reactions\n    # (R_upt, R_cat, R_syn, R_atpase).\n    S_matrix = np.array([\n        [1., -1., 0., 0.],\n        [0., 1., 1., -1.],\n        [0., -1., -1., 1.],\n        [0., -1., -1., 1.]\n    ])\n\n    # The problem is to maximize v4, which is equivalent to minimizing -v4.\n    # The objective vector c for linprog is thus [0, 0, 0, -1].\n    c_objective = np.array([0., 0., 0., -1.])\n\n    # The steady-state condition Sv = 0 provides the equality constraints.\n    A_eq_constraints = S_matrix\n    b_eq_constraints = np.zeros(4)\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (mode, U, knockouts)\n    test_cases = [\n        (\"standard\", 0., set()),\n        (\"loopless\", 0., set()),\n        (\"standard\", 10., {\"G_cat\"}),\n        (\"loopless\", 10., {\"G_cat\"}),\n        (\"loopless\", 2., set()),\n        (\"standard\", 2., set()),\n    ]\n\n    results = []\n    for mode, U, knockouts in test_cases:\n        # Default bounds for fluxes (v1, v2, v3, v4)\n        # v1: R_upt, v2: R_cat, v3: R_syn, v4: R_atpase\n        bounds = [\n            (0., U),            # v1: R_upt, upper bound set by U\n            (0., 1000.),         # v2: R_cat\n            (-100., 100.),       # v3: R_syn\n            (0., 100.)           # v4: R_atpase\n        ]\n\n        # Apply gene knockout constraints\n        if \"G_cat\" in knockouts:\n            # G_cat knockout sets flux of R_cat (v2) to 0.\n            bounds[1] = (0., 0.)\n\n        # Apply mode-specific constraints\n        if mode == \"loopless\":\n            # Loopless constraint forbids the forward direction of R_syn (v3).\n            bounds[2] = (-100., 0.)\n\n        # Solve the linear programming problem\n        res = linprog(\n            c=c_objective,\n            A_eq=A_eq_constraints,\n            b_eq=b_eq_constraints,\n            bounds=bounds,\n            method='highs'  # Use a robust modern solver\n        )\n\n        # The result 'res.fun' is the minimum of -v4.\n        # The maximum v4 is -res.fun.\n        # Handle small negative value close to zero from solver tolerance\n        max_v4 = -res.fun if res.success else 0.\n        if abs(max_v4)  1e-9:\n             max_v4 = 0.0\n        \n        results.append(max_v4)\n\n    # Format the results to three decimal places and print in the specified format.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4345133"}, {"introduction": "基因删除分析的一个主要应用是确定控制细胞功能的策略，例如抑制病原体生长。这需要超越单基因效应，寻找能够协同作用的基因敲除组合，即“最小切割集”。在最后的这个练习 [@problem_id:4345159] 中，您将开发并应用一种系统性算法，以枚举所有能够中止生物质生成的最小反应集，这是发现合成致死药物靶点和评估网络脆弱性的基础技术。", "problem": "给定三个基于约束的小型代谢网络，每个网络由一个化学计量矩阵、通量边界和一个指定的生物质反应来规定。这些网络在质量平衡约束下模拟稳态代谢，旨在通过反应敲除来评估基因删除的影响。您的任务是枚举所有能使生物质产量高于预定阈值的功能失效的最小反应敲除组合（即最小切集），并排除生物质反应本身。同时，通过证明每个报告的切集的任何真子集都不能阻断生物质来验证其最小性。\n\n基本原理。在基于约束的稳态建模中，设 $S \\in \\mathbb{R}^{m \\times n}$ 表示包含 $m$ 个代谢物和 $n$ 个反应的化学计量矩阵，设 $v \\in \\mathbb{R}^n$ 表示反应通量向量。稳态质量平衡约束由下式给出：\n$$\nS v = 0,\n$$\n通量边界由下界 $l \\in \\mathbb{R}^n$ 和上界 $u \\in \\mathbb{R}^n$ 给出，它们共同指定了：\n$$\nl \\le v \\le u,\n$$\n此不等式按分量进行解释。设生物质反应的索引为 $r^\\star \\in \\{0,1,\\dots,n-1\\}$，生长阈值为 $\\delta  0$，因此，任何满足 $S v = 0$、$l \\le v \\le u$ 和 $v_{r^\\star} \\ge \\delta$ 的通量向量都是一个可行的生长状态。对索引为 $i$ 的反应进行敲除会施加额外约束 $v_i = 0$。\n\n定义。切集 $C \\subseteq \\{0,1,\\dots,n-1\\} \\setminus \\{r^\\star\\}$ 是允许的反应索引的任意子集，在该子集下，对于以下约束：\n$$\nS v = 0, \\quad l \\le v \\le u, \\quad v_{r^\\star} \\ge \\delta, \\quad \\text{以及} \\quad v_i = 0 \\ \\text{对于所有} \\ i \\in C,\n$$\n不存在可行的 $v$。最小切集是一个切集 $C$，其任何真子集 $C' \\subset C$ 本身都不是切集。\n\n任务。对于以下三个网络中的每一个，枚举所有使生物质通量达到或超过阈值的功能失效的最小切集 $C$，其中敲除仅限于指定的允许反应索引集（该集合排除了生物质反应）。对于每个报告的 $C$，通过检查 $C$ 的每个真子集都无法阻断生物质（即，当仅敲除该子集中的反应时，存在一个可行的 $v$ 使得 $v_{r^\\star} \\ge \\delta$）来验证其最小性。\n\n测试用例。对于每个网络，都给出了矩阵 $S$、边界 $l$ 和 $u$、生物质索引 $r^\\star$、生长阈值 $\\delta$ 以及允许的敲除索引 $\\mathcal{R}_{\\mathrm{allow}}$。\n\n- 网络 $\\mathrm{N1}$：\n  - 维度：$m = 2$, $n = 3$。\n  - 化学计量矩阵：\n    $$\n    S = \\begin{pmatrix}\n    1  0  -1 \\\\\n    0  1  -1\n    \\end{pmatrix}.\n    $$\n    此处反应索引为 $0,1,2$；反应 $2$ 是生物质反应，消耗一个单位的代谢物 $A$ 和一个单位的代谢物 $B$。\n  - 边界：\n    $$\n    l = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad\n    u = \\begin{pmatrix} 10 \\\\ 10 \\\\ 10 \\end{pmatrix}.\n    $$\n  - 生物质索引：$r^\\star = 2$。\n  - 生长阈值：$\\delta = 1$。\n  - 允许的敲除：$\\mathcal{R}_{\\mathrm{allow}} = \\{0,1\\}$。\n\n- 网络 $\\mathrm{N2}$：\n  - 维度：$m = 2$, $n = 4$。\n  - 化学计量矩阵：\n    $$\n    S = \\begin{pmatrix}\n    1  0  0  -1 \\\\\n    0  1  1  -1\n    \\end{pmatrix}.\n    $$\n    此处反应索引为 $0,1,2,3$；反应 $3$ 是生物质反应，消耗一个单位的代谢物 $A$ 和一个单位的代谢物 $B$；代谢物 $B$ 可由两个替代反应 $1$ 和 $2$ 提供。\n  - 边界：\n    $$\n    l = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad\n    u = \\begin{pmatrix} 10 \\\\ 10 \\\\ 10 \\\\ 10 \\end{pmatrix}.\n    $$\n  - 生物质索引：$r^\\star = 3$。\n  - 生长阈值：$\\delta = 1$。\n  - 允许的敲除：$\\mathcal{R}_{\\mathrm{allow}} = \\{0,1,2\\}$。\n\n- 网络 $\\mathrm{N3}$：\n  - 维度：$m = 2$, $n = 5$。\n  - 化学计量矩阵：\n    $$\n    S = \\begin{pmatrix}\n    1  1  0  0  -1 \\\\\n    0  0  1  1  -1\n    \\end{pmatrix}.\n    $$\n    此处反应索引为 $0,1,2,3,4$；反应 $4$ 是生物质反应，消耗一个单位的代谢物 $A$ 和一个单位的代谢物 $B$；代谢物 $A$ 由两个替代反应 $0$ 和 $1$ 提供，代谢物 $B$ 由两个替代反应 $2$ 和 $3$ 提供。\n  - 边界：\n    $$\n    l = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad\n    u = \\begin{pmatrix} 10 \\\\ 10 \\\\ 10 \\\\ 10 \\\\ 10 \\end{pmatrix}.\n    $$\n  - 生物质索引：$r^\\star = 4$。\n  - 生长阈值：$\\delta = 1$。\n  - 允许的敲除：$\\mathcal{R}_{\\mathrm{allow}} = \\{0,1,2,3\\}$。\n\n输出规范。对于每个网络，以列表的列表形式返回最小切集的完整集合，其中每个切集表示为一个按升序排列的反应索引列表。按元组的字典序对切集列表进行排序。您的程序应生成单行输出，按顺序包含 $\\mathrm{N1}$、$\\mathrm{N2}$ 和 $\\mathrm{N3}$ 的结果，形式为用方括号括起来的逗号分隔列表，例如：\n$$\n[\\text{result}_{\\mathrm{N1}},\\text{result}_{\\mathrm{N2}},\\text{result}_{\\mathrm{N3}}]\n$$\n其中每个 $\\text{result}_{\\mathrm{Ni}}$ 本身是一个整数列表的列表。不涉及物理单位；所有量均为无量纲。不使用角度，也不需要百分比值。输出必须严格限制为这种单行格式。", "solution": "该问题要求为三个小型代谢网络枚举所有最小反应切集。切集是一组反应敲除的集合，它使得生物质产量超过给定阈值变得不可行。如果一个切集的任何真子集本身都不是切集，则该切集是最小的。该问题是基于约束的代谢网络建模领域中一个明确定义的任务，这是系统生物学的一个核心领域。\n\n分析的关键在于构建并求解一系列线性规划（LP）可行性问题。对于每个由化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$、通量下界 $l \\in \\mathbb{R}^n$ 和通量上界 $u \\in \\mathbb{R}^n$ 定义的网络，我们必须确定是否存在一个满足一组约束条件的通量向量 $v \\in \\mathbb{R}^n$。\n\n一个候选的反应敲除集表示为 $C \\subseteq \\mathcal{R}_{\\mathrm{allow}}$，其中 $\\mathcal{R}_{\\mathrm{allow}}$ 是允许被敲除的反应集合。是否存在可行的生长状态取决于以下线性等式和不等式系统的可行性：\n1. $S v = 0$ (稳态质量平衡)\n2. $l \\le v \\le u$ (通量的热力学和容量约束)\n3. $v_{r^\\star} \\ge \\delta$ (所需的最小生物质生产速率，其中 $r^\\star$ 是生物质反应的索引，$\\delta  0$ 是生长阈值)\n4. $v_i = 0$ 对于所有 $i \\in C$ (反应敲除)\n\n对于一个特定的候选集 $C$，这些约束可以合并为一个标准的LP可行性形式：求解 $v$ 使得 $S v = 0$，并满足边界条件 $l' \\le v \\le u'$，其中修改后的边界 $l'$ 和 $u'$ 定义如下：\n- 对于 $i \\in C$，有 $l'_i = u'_i = 0$\n- $l'_{r^\\star} = \\max(l_{r^\\star}, \\delta)$\n- 对于所有其他索引 $j \\notin C \\cup \\{r^\\star\\}$，边界保持为 $l'_j = l_j$ 和 $u'_j = u_j$。\n\n当且仅当该约束系统不可行时，集合 $C$ 是一个切集。\n\n为了找到所有的最小切集，我们采用了一种系统搜索算法。对 $\\mathcal{R}_{\\mathrm{allow}}$ 的所有 $2^{|\\mathcal{R}_{\\mathrm{allow}}|}$ 个子集进行朴素的暴力检查，在计算上是低效的，并且不能直接识别出最小集。一种更精细的、建设性的方法是按基数 $k$ 从 $k=1$ 递增到 $k=|\\mathcal{R}_{\\mathrm{allow}}|$ 来迭代候选集。\n\n算法流程如下：\n1. 初始化一个空列表 $\\mathcal{M}$，用于存储已识别的最小切集。\n2. 对于 $k = 1, 2, \\dots, |\\mathcal{R}_{\\mathrm{allow}}|$：\n3. 对于每个大小为 $|C| = k$ 的子集 $C \\subseteq \\mathcal{R}_{\\mathrm{allow}}$：\n   a. 首先，检查 $C$ 是否可能是最小的。如果一个集合 $C$ 包含一个已经是切集的真子集，那么它不可能是最小切集。因此，我们检查先前识别的任何最小切集 $C_{min} \\in \\mathcal{M}$ 是否是 $C$ 的真子集。如果存在这样的 $C_{min}$，$C$ 就被丢弃，我们继续处理下一个候选子集。\n   b. 如果 $C$ 不是任何已知最小切集的超集，我们通过求解相应的LP可行性问题来测试它是否是一个切集。这通过如上所述设置约束并使用数值LP求解器（例如，`scipy.optimize.linprog`）来实现。\n   c. 如果LP求解器确定问题不可行，这表示 $C$ 确实是一个切集。因为我们是按大小 $k$ 进行迭代，并且已经排除了所有是先前发现的最小切集的超集的候选者，所以我们在此阶段发现的任何切集 $C$ 都必须是最小的。\n   d. 将新发现的最小切集 $C$ 添加到列表 $\\mathcal{M}$ 中。\n\n该算法保证了最小性。当一个集合 $C$ 被添加到 $\\mathcal{M}$ 中时，是因为 (i) 它是一个切集，并且 (ii) 它的任何真子集都不是切集。第二个条件成立是因为 $C$ 的所有真子集的大小都小于 $k$，并且在之前的迭代中已经被测试过。由于它们没有被添加到 $\\mathcal{M}$ 中，所以它们不是切集。这个过程直接满足了问题中验证最小性的要求。\n\n该算法应用于所提供的三个网络中的每一个：\n\n- 对于网络 $\\mathrm{N1}$，允许的敲除是 $\\mathcal{R}_{\\mathrm{allow}} = \\{0,1\\}$。分析表明，单独敲除反应 $0$ 足以阻断生物质，单独敲除反应 $1$ 也是如此。这些是大小为 $1$ 的切集，因此是最小的。最小切集的集合是 $\\{\\{0\\}, \\{1\\}\\}$。\n\n- 对于网络 $\\mathrm{N2}$，$\\mathcal{R}_{\\mathrm{allow}} = \\{0,1,2\\}$。反应 $0$ 对于前体A是必需的，而反应 $1$ 和 $2$ 是前体B的平行路径。单独敲除反应 $0$ 会阻断生物质，所以 $\\{0\\}$ 是一个最小切集。单独敲除 $1$ 或 $2$ 不会阻断生物质，因为平行的反应可以补偿。然而，同时敲除 $1$ 和 $2$ 会阻断前体B的供应，从而阻断生物质。由于 $\\{1\\}$ 和 $\\{2\\}$ 都不是切集，所以 $\\{1,2\\}$ 是一个最小切集。最小切集的集合是 $\\{\\{0\\}, \\{1,2\\}\\}$。\n\n- 对于网络 $\\mathrm{N3}$，$\\mathcal{R}_{\\mathrm{allow}} = \\{0,1,2,3\\}$。在这里，反应 $\\{0,1\\}$ 是前体A的平行路径，而 $\\{2,3\\}$ 是前体B的平行路径。要阻断生物质，必须中断前体A或前体B的供应。这需要敲除A的两个反应（即 $\\{0,1\\}$）或B的两个反应（即 $\\{2,3\\}$）。单个敲除是不够的。因此，最小切集是 $\\{\\{0,1\\}\\}$ 和 $\\{\\{2,3\\}\\}$。\n\n最终结果被收集起来，每个切集表示为一个按升序排序的反应索引列表。然后对每个网络的切集列表按字典序进行排序。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations\nimport json\n\ndef check_feasibility(knockout_set, S, l, u, r_star, delta):\n    \"\"\"\n    Checks if a metabolic network is feasible for a given set of knockouts.\n\n    A network is feasible if there exists a flux vector v satisfying:\n    1. S @ v = 0\n    2. l = v = u (with modifications for knockouts and biomass)\n    \n    This is solved as a Linear Programming feasibility problem.\n\n    Returns:\n        bool: True if feasible, False if infeasible.\n    \"\"\"\n    m, n = S.shape\n    \n    # Create modified bounds\n    l_mod = np.copy(l)\n    u_mod = np.copy(u)\n\n    # Apply knockouts\n    for reaction_idx in knockout_set:\n        l_mod[reaction_idx] = 0\n        u_mod[reaction_idx] = 0\n\n    # Apply biomass threshold\n    l_mod[r_star] = max(l_mod[r_star], delta)\n\n    # The upper bound for biomass must be respected\n    if l_mod[r_star] > u_mod[r_star]:\n      return False\n\n    bounds = list(zip(l_mod, u_mod))\n    \n    # We only care about feasibility, so the objective function is irrelevant.\n    # We use a zero vector for the objective function coefficients.\n    c = np.zeros(n)\n    \n    res = linprog(\n        c=c,\n        A_eq=S,\n        b_eq=np.zeros(m),\n        bounds=bounds,\n        method='highs',\n        options={'presolve': True} # Important for stability\n    )\n    \n    # status 2 indicates infeasibility.\n    return res.status != 2\n\ndef find_minimal_cut_sets(S, l, u, r_star, delta, R_allow):\n    \"\"\"\n    Finds all minimal cut sets for a given metabolic network.\n\n    The algorithm iterates through candidate sets by increasing size, ensuring minimality.\n    \"\"\"\n    minimal_cut_sets = []\n    \n    # Sort allowed reactions to ensure combinations are generated lexicographically\n    sorted_R_allow = sorted(list(R_allow))\n    \n    for k in range(1, len(sorted_R_allow) + 1):\n        for c_tuple in combinations(sorted_R_allow, k):\n            C = list(c_tuple)\n            \n            # A set C cannot be minimal if it's a superset of an existing minimal cut set.\n            is_superset = False\n            for mcs in minimal_cut_sets:\n                if set(mcs).issubset(set(C)):\n                    is_superset = True\n                    break\n            if is_superset:\n                continue\n\n            # Check if the current knockout set C blocks biomass production.\n            is_feasible = check_feasibility(C, S, l, u, r_star, delta)\n            \n            # If it's not feasible, C is a cut set.\n            # By construction, it must be minimal.\n            if not is_feasible:\n                minimal_cut_sets.append(C)\n                \n    # The list is already sorted lexicographically by construction.\n    # Sorting again is redundant but harmless.\n    return sorted(minimal_cut_sets)\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, compute results, and print the output.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"N1\",\n            \"S\": np.array([[1, 0, -1], [0, 1, -1]], dtype=float),\n            \"l\": np.array([0, 0, 0], dtype=float),\n            \"u\": np.array([10, 10, 10], dtype=float),\n            \"r_star\": 2,\n            \"delta\": 1.0,\n            \"R_allow\": {0, 1},\n        },\n        {\n            \"name\": \"N2\",\n            \"S\": np.array([[1, 0, 0, -1], [0, 1, 1, -1]], dtype=float),\n            \"l\": np.array([0, 0, 0, 0], dtype=float),\n            \"u\": np.array([10, 10, 10, 10], dtype=float),\n            \"r_star\": 3,\n            \"delta\": 1.0,\n            \"R_allow\": {0, 1, 2},\n        },\n        {\n            \"name\": \"N3\",\n            \"S\": np.array([[1, 1, 0, 0, -1], [0, 0, 1, 1, -1]], dtype=float),\n            \"l\": np.array([0, 0, 0, 0, 0], dtype=float),\n            \"u\": np.array([10, 10, 10, 10, 10], dtype=float),\n            \"r_star\": 4,\n            \"delta\": 1.0,\n            \"R_allow\": {0, 1, 2, 3},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        mcs = find_minimal_cut_sets(\n            case[\"S\"],\n            case[\"l\"],\n            case[\"u\"],\n            case[\"r_star\"],\n            case[\"delta\"],\n            case[\"R_allow\"],\n        )\n        results.append(mcs)\n        \n    # Format the final output string to match the problem specification\n    # (no spaces). Using json.dumps is a robust way to achieve this.\n    # The output should be a single JSON-formatted list containing all results.\n    print(json.dumps(results, separators=(',',':')))\n\nsolve()\n```", "id": "4345159"}]}