{"hands_on_practices": [{"introduction": "掌握基本流模式（EFM）分析的第一步是从头开始理解其定义。本练习侧重于 EFM 的核心定义：一个处于稳态且具有最小支持集的路径。通过在一个小型网络中手动枚举和验证 EFM，您将为支持集最小性这一概念建立具体直观的理解，这是 EFM 分析的基石。[@problem_id:4337330]", "problem": "考虑一个哺乳动物细胞中的最小细胞内转化模块，该模块涉及三种内源代谢物 $A$、$B$ 和 $C$，以及六个交换和转化反应。化学计量矩阵 $S \\in \\mathbb{R}^{3 \\times 6}$（行按 $A$、$B$、$C$ 排序；列按反应 $v_{1},\\dots,v_{6}$ 排序）和不可逆性模式 $I$ 由下式给出\n$$\nS \\;=\\;\n\\begin{pmatrix}\n1  -1  0  0  -1  0 \\\\\n0  1  -1  0  0  -1 \\\\\n0  0  1  -1  1  0\n\\end{pmatrix},\n\\qquad\nI \\;=\\; (1,\\,1,\\,1,\\,1,\\,1,\\,1),\n$$\n其中 $I_{i} = 1$ 表示反应 $i$ 是不可逆的，要求对所有 $i \\in \\{1,\\dots,6\\}$ 都有 $v_{i} \\ge 0$。这些反应可以解释如下：$v_{1}$ 是 $A$ 的摄取，$v_{2}$ 是 $A \\to B$，$v_{3}$ 是 $B \\to C$，$v_{4}$ 是 $C$ 的分泌，$v_{5}$ 是 $A \\to C$，$v_{6}$ 是 $B$ 的分泌。在细胞内代谢物的标准稳态假设下，通量向量 $v \\in \\mathbb{R}^{6}$ 满足 $S v = 0$ 且分量皆为非负值 $v \\ge 0$。\n\n从基本通量模式 (EFM) 的基本定义出发，即 EFM 是一个位于通量锥 $\\{v \\in \\mathbb{R}^{6} \\mid S v = 0,\\, v \\ge 0\\}$ 中的非零通量向量，并且在所有可行通量向量中具有关于集合包含的最小支撑集，通过观察枚举该网络的所有 EFM，并通过测试所有真支撑集的可行性来验证其最小性。请提供 EFM 的总数作为最终答案。将您的最终答案表示为一个无单位的数字。不需要四舍五入。", "solution": "该问题要求枚举给定代谢网络的所有基本通量模式 (EFM)。该网络的化学计量由矩阵 $S \\in \\mathbb{R}^{3 \\times 6}$ 描述，并且所有反应都是不可逆的。\n\n首先，我们建立定义通量锥的方程组。一个通量向量 $v = (v_1, v_2, v_3, v_4, v_5, v_6)^T$ 必须满足稳态条件 $S v = 0$ 和非负性约束 $v_i \\ge 0$ (对于 $i \\in \\{1, \\dots, 6\\}$)。\n\n矩阵方程 $S v = 0$ 可转化为以下线性方程组：\n1.  $v_1 - v_2 - v_5 = 0$\n2.  $v_2 - v_3 - v_6 = 0$\n3.  $v_3 - v_4 + v_5 = 0$\n\n一个基本通量模式 (EFM) 是一个非零向量 $v$，它满足这三个方程和 $v \\ge 0$，并且其支撑集 $supp(v) = \\{i \\mid v_i \\neq 0\\}$ 在集合包含关系下是最小的。这意味着不存在其他非零通量向量 $v'$ 使得 $supp(v') \\subsetneq supp(v)$。\n\n题目建议“通过观察”来找到 EFM，这相当于识别从输入到输出的最小的、自洽的途径。唯一的摄取反应是 $v_1$，所以任何 EFM 都必须有 $v_1  0$。分泌反应是 $v_4$ 和 $v_6$。因此，任何 EFM 都必须表示一个从 $A$ 的摄取到 $B$ 或 $C$ 的分泌的途径。\n\n我们识别出三个这样的简单途径：\n\n途径 1：$v_1 \\to v_2 \\to v_3 \\to v_4$。这对应于外部底物通过中间产物 $B$ 最终转化为产物 $C$ 的过程。活跃的反应是 $v_1, v_2, v_3, v_4$。我们假设 $v_5=0$ 和 $v_6=0$。\n方程组变为：\n$v_1 - v_2 = 0 \\implies v_1 = v_2$\n$v_2 - v_3 = 0 \\implies v_2 = v_3$\n$v_3 - v_4 = 0 \\implies v_3 = v_4$\n这导致 $v_1 = v_2 = v_3 = v_4$。将通量设为归一化的值 $1$，我们得到候选通量向量 $e_1 = (1, 1, 1, 1, 0, 0)^T$。其支撑集为 $supp(e_1) = \\{1, 2, 3, 4\\}$。\n\n途径 2：$v_1 \\to v_5 \\to v_4$。这是 $A$ 到 $C$ 的直接转化。活跃的反应是 $v_1, v_5, v_4$。我们假设 $v_2=0, v_3=0, v_6=0$。\n方程组变为：\n$v_1 - v_5 = 0 \\implies v_1 = v_5$\n$0 = 0$\n$-v_4 + v_5 = 0 \\implies v_4 = v_5$\n这导致 $v_1 = v_5 = v_4$。对于归一化的通量 $1$，我们得到候选向量 $e_2 = (1, 0, 0, 1, 1, 0)^T$。其支撑集为 $supp(e_2) = \\{1, 4, 5\\}$。\n\n途径 3：$v_1 \\to v_2 \\to v_6$。该途径表示外部底物转化为产物 $B$，然后被分泌。活跃的反应是 $v_1, v_2, v_6$。我们假设 $v_3=0, v_4=0, v_5=0$。\n方程组变为：\n$v_1 - v_2 = 0 \\implies v_1 = v_2$\n$v_2 - v_6 = 0 \\implies v_2 = v_6$\n$0 = 0$\n这导致 $v_1 = v_2 = v_6$。对于归一化的通量 $1$，我们得到候选向量 $e_3 = (1, 1, 0, 0, 0, 1)^T$。其支撑集为 $supp(e_3) = \\{1, 2, 6\\}$。\n\n接下来，我们必须验证每个候选向量支撑集的最小性。\n\n对于 $e_1$，其 $supp(e_1) = \\{1, 2, 3, 4\\}$：\n如果我们考虑该支撑集的任何真子集，反应链就会中断。例如，我们通过设置 $v_4=0$（此外还有 $v_5=0, v_6=0$）来测试支撑集 $\\{1, 2, 3\\}$。第三个方程 $v_3 - v_4 + v_5 = 0$ 变为 $v_3=0$。这意味着 $v_2=v_3=0$ 和 $v_1=v_2=0$。因此，只有零通量是可能的。这对任何真子集都成立。因此，$supp(e_1)$ 是最小的，并且 $e_1$ 是一个 EFM。\n\n对于 $e_2$，其 $supp(e_2) = \\{1, 4, 5\\}$：\n我们通过设置 $v_4=0$ 来测试支撑集 $\\{1, 5\\}$。第三个方程 $v_3 - v_4 + v_5 = 0$（其中 $v_3=0$）变为 $v_5=0$。从第一个方程 $v_1 - v_2 - v_5 = 0$（其中 $v_2=0$），我们得到 $v_1=v_5=0$。同样，只有零通量是可能的。这个论证可以对其他真子集 $\\{1, 4\\}$ 和 $\\{4, 5\\}$ 重复。因此，$supp(e_2)$ 是最小的，并且 $e_2$ 是一个 EFM。\n\n对于 $e_3$，其 $supp(e_3) = \\{1, 2, 6\\}$：\n我们通过设置 $v_6=0$ 来测试支撑集 $\\{1, 2\\}$。第二个方程 $v_2 - v_3 - v_6 = 0$（其中 $v_3=0$）变为 $v_2=0$。第一个方程 $v_1 - v_2 - v_5 = 0$（其中 $v_5=0$）给出 $v_1=v_2=0$。只有平凡通量。这个逻辑适用于所有真子集。因此，$supp(e_3)$ 是最小的，并且 $e_3$ 是一个 EFM。\n\n为了确认这些是*唯一*的 EFM，我们可以完全解出这个方程组。我们可以用三个自由变量来表示三个因变量。我们选择 $v_4, v_5, v_6$ 作为自由变量。从方程组得到：\n$v_3 = v_4 - v_5$\n$v_2 = v_3 + v_6 = v_4 - v_5 + v_6$\n$v_1 = v_2 + v_5 = (v_4 - v_5 + v_6) + v_5 = v_4 + v_6$\n\n非负性约束 $v_i \\ge 0$ 对自由变量施加了条件：\n$v_4 \\ge 0, v_5 \\ge 0, v_6 \\ge 0$\n$v_3 \\ge 0 \\implies v_4 - v_5 \\ge 0 \\implies v_4 \\ge v_5$\n$v_2 \\ge 0 \\implies v_4 - v_5 + v_6 \\ge 0$ (如果 $v_4 \\ge v_5$ 且 $v_6 \\ge 0$，这个条件自动满足)\n$v_1 \\ge 0 \\implies v_4 + v_6 \\ge 0$ (如果 $v_4 \\ge 0, v_6 \\ge 0$，这个条件自动满足)\n\n可行通量锥由向量 $v = (v_4+v_6, v_4-v_5+v_6, v_4-v_5, v_4, v_5, v_6)^T$ 描述，其中 $v_4 \\ge v_5 \\ge 0$ 且 $v_6 \\ge 0$。\n为了找到极射线（即 EFM），我们可以重新参数化以消除不等式约束 $v_4 \\ge v_5$。令 $\\gamma = v_4 - v_5 \\ge 0$。那么 $v_4 = v_5 + \\gamma$。我们使用 $v_5, v_6, \\gamma$ 作为非负参数。\n令 $v_5 = \\alpha, v_6 = \\beta, \\gamma = \\delta$，其中 $\\alpha, \\beta, \\delta \\ge 0$。\n那么 $v_4 = \\alpha + \\delta$。将这些代入其他变量的表达式中：\n$v_1 = (\\alpha+\\delta) + \\beta = \\alpha + \\beta + \\delta$\n$v_2 = (\\alpha+\\delta) - \\alpha + \\beta = \\beta + \\delta$\n$v_3 = (\\alpha+\\delta) - \\alpha = \\delta$\n$v_4 = \\alpha + \\delta$\n$v_5 = \\alpha$\n$v_6 = \\beta$\n\n锥中的任何通量向量 $v$ 都可以写成三个向量的非负线性组合：\n$$\nv = \\begin{pmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\\\ v_5 \\\\ v_6 \\end{pmatrix} =\n\\alpha \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 1 \\\\ 0 \\end{pmatrix} +\n\\beta \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix} +\n\\delta \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n这个分解中的三个向量恰好是我们通过观察找到的向量 $e_2$、$e_3$ 和 $e_1$（其中 $\\delta$ 对应 $e_1$，$\\alpha$ 对应 $e_2$，$\\beta$ 对应 $e_3$）。\n这些向量构成了通量锥的极射线集合。由于我们已经验证了它们的最小支撑集属性，它们就是 EFM 的完整集合。\n\n总共有三个基本通量模式。\n1.  EFM 1: $e_1 = (1, 1, 1, 1, 0, 0)^T$\n2.  EFM 2: $e_2 = (1, 0, 0, 1, 1, 0)^T$\n3.  EFM 3: $e_3 = (1, 1, 0, 0, 0, 1)^T$\n\n问题要求 EFM 的总数。总数是 $3$。", "answer": "$$\\boxed{3}$$", "id": "4337330"}, {"introduction": "在理解了什么是 EFM 之后，探索使其分析成为可能的数学条件至关重要。本练习探讨了通量锥的几何特性，特别是“尖锥”概念以及反应不可逆性所扮演的角色。这个思想实验阐明了为何不可逆性约束不仅具有生物学相关性，而且在数学上也是必要的，它能消除热力学上不可行的循环，并确保基本模式的集合是定义良好且有限的。[@problem_id:4337289]", "problem": "考虑一个用于基本通量模式 (EFM) 分析的代谢网络中的最小内部循环，该循环包含 $3$ 个内部代谢物 $A$、$B$ 和 $C$ 之间的 $3$ 个反应：反应 $1$ 在 $A$ 和 $B$ 之间相互转换，反应 $2$ 在 $B$ 和 $C$ 之间相互转换，反应 $3$ 在 $C$ 和 $A$ 之间相互转换。化学计量矩阵 $S \\in \\mathbb{R}^{3 \\times 3}$，其行按 $\\{A,B,C\\}$ 排序，列按 $\\{1,2,3\\}$ 排序，表示为\n$$\nS \\;=\\; \\begin{pmatrix}\n-1  0  1 \\\\\n1  -1  0 \\\\\n0  1  -1\n\\end{pmatrix}.\n$$\n在稳态下，可行的通量 $v \\in \\mathbb{R}^{3}$ 必须满足质量平衡方程 $S v = 0$。将没有任何不可逆约束的通量锥定义为 $C_{0} = \\{ v \\in \\mathbb{R}^{3} \\mid S v = 0 \\}$。一个锥 $C$ 的线性空间 $\\mathcal{L}(C)$ 定义为 $\\mathcal{L}(C) = C \\cap (-C)$，并且一个锥是尖的当且仅当 $\\mathcal{L}(C) = \\{0\\}$。现在对反应 $1$ 增加一个不可逆约束，要求 $v_{1} \\ge 0$，并将约束后的通量锥定义为 $C_{1} = \\{ v \\in \\mathbb{R}^{3} \\mid S v = 0,\\; v_{1} \\ge 0 \\}$。\n\n仅使用稳态 ($S v = 0$)、通量锥和线性空间的定义，不使用任何快捷公式，确定在施加 $v_{1} \\ge 0$ 后线性空间的维度 $\\dim\\big(\\mathcal{L}(C_{1})\\big)$。将 $\\dim\\big(\\mathcal{L}(C_{1})\\big)$ 的值报告为一个没有单位的整数。不需要四舍五入。", "solution": "问题要求确定给定约束通量锥 $C_{1}$ 的线性空间的维度 $\\dim\\big(\\mathcal{L}(C_{1})\\big)$。我们将应用问题陈述中提供的定义来解决。\n\n约束通量锥定义为 $C_{1} = \\{ v \\in \\mathbb{R}^{3} \\mid S v = 0,\\; v_{1} \\ge 0 \\}$。化学计量矩阵 $S$ 和通量向量 $v$ 由下式给出：\n$$\nS \\;=\\; \\begin{pmatrix}\n-1  0  1 \\\\\n1  -1  0 \\\\\n0  1  -1\n\\end{pmatrix}, \\quad v \\;=\\; \\begin{pmatrix} v_1 \\\\ v_2 \\\\ v_3 \\end{pmatrix}\n$$\n一个锥 $C$ 的线性空间定义为 $\\mathcal{L}(C) = C \\cap (-C)$。我们将此定义应用于锥 $C_{1}$。\n一个向量 $v$ 属于线性空间 $\\mathcal{L}(C_{1})$ 当且仅当 $v \\in C_{1}$ 且 $v \\in (-C_{1})$。\n\n我们首先描述向量 $v$ 属于 $C_{1}$ 的条件。根据 $C_1$ 的定义：\n1. $S v = 0$\n2. $v_{1} \\ge 0$\n\n接下来，我们描述向量 $v$ 属于集合 $-C_{1}$ 的条件。如果向量 $-v$ 属于 $C_{1}$，那么向量 $v$ 就属于 $-C_{1}$。要使 $-v$ 属于 $C_{1}$，它必须满足 $C_{1}$ 的定义条件：\n1. $S(-v) = 0$\n2. $(-v)_{1} \\ge 0$，其中 $(-v)_{1}$ 是向量 $-v$ 的第一个分量。\n\n第一个条件 $S(-v) = 0$，由于矩阵乘法的线性性质，可以简化为 $-S v = 0$，这等价于 $S v = 0$。\n第二个条件 $(-v)_{1} \\ge 0$ 意味着 $-v_{1} \\ge 0$，这等价于 $v_{1} \\le 0$。\n因此，集合 $-C_{1}$ 由 $-C_{1} = \\{ v \\in \\mathbb{R}^{3} \\mid S v = 0,\\; v_{1} \\le 0 \\}$ 给出。\n\n现在，我们求交集 $C_{1} \\cap (-C_{1})$，即线性空间 $\\mathcal{L}(C_{1})$。一个向量 $v$ 属于 $\\mathcal{L}(C_{1})$，如果它同时满足属于 $C_{1}$ 和 $-C_{1}$ 的条件。这些条件是：\n1. $S v = 0$ (来自 $C_1$)\n2. $v_{1} \\ge 0$ (来自 $C_1$)\n3. $S v = 0$ (来自 $-C_1$，这是多余的)\n4. $v_{1} \\le 0$ (来自 $-C_1$)\n\n结合所有条件，一个向量 $v \\in \\mathcal{L}(C_{1})$ 必须满足：\n- $S v = 0$\n- $v_{1} \\ge 0$ 且 $v_{1} \\le 0$\n\n两个不等式 $v_{1} \\ge 0$ 和 $v_{1} \\le 0$ 只有在 $v_1 = 0$ 时才能同时成立。\n因此，线性空间 $\\mathcal{L}(C_{1})$ 是所有满足 $S v = 0$ 和 $v_{1} = 0$ 的向量 $v \\in \\mathbb{R}^{3}$ 的集合。\n$$\n\\mathcal{L}(C_{1}) = \\{ v \\in \\mathbb{R}^{3} \\mid S v = 0,\\; v_{1} = 0 \\}\n$$\n我们现在求解这个线性方程组。方程 $S v = 0$ 对应于：\n$$\n\\begin{pmatrix}\n-1  0  1 \\\\\n1  -1  0 \\\\\n0  1  -1\n\\end{pmatrix}\n\\begin{pmatrix}\nv_1 \\\\\nv_2 \\\\\nv_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n0\n\\end{pmatrix}\n$$\n这给出了以下方程组：\n$$\n\\begin{cases}\n-v_{1} + v_{3} = 0 \\\\\nv_{1} - v_{2} = 0 \\\\\nv_{2} - v_{3} = 0\n\\end{cases}\n$$\n我们还必须强制执行条件 $v_{1}=0$。将 $v_{1}=0$ 代入方程组得到：\n$$\n\\begin{cases}\n-0 + v_{3} = 0  \\implies v_{3} = 0 \\\\\n0 - v_{2} = 0  \\implies v_{2} = 0 \\\\\nv_{2} - v_{3} = 0\n\\end{cases}\n$$\n从第一个方程，我们得到 $v_{3} = 0$。从第二个方程，我们得到 $v_{2} = 0$。将 $v_{2} = 0$ 和 $v_{3} = 0$ 代入第三个方程得到 $0 - 0 = 0$，这是相容的。\n该方程组的唯一解是 $v_1 = 0$，$v_2 = 0$ 和 $v_3 = 0$。\n这意味着线性空间 $\\mathcal{L}(C_{1})$ 中唯一的向量是零向量：\n$$\nv = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n因此，该线性空间是只包含原点的平凡向量空间：\n$$\n\\mathcal{L}(C_{1}) = \\left\\{ \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} \\right\\}\n$$\n一个向量空间的维度是该空间任何基中向量的数量。平凡向量空间的基是空集，其维度定义为 $0$。\n因此，该线性空间的维度是 $0$。\n$$\n\\dim\\big(\\mathcal{L}(C_{1})\\big) = 0\n$$", "answer": "$$\\boxed{0}$$", "id": "4337289"}, {"introduction": "在坚实的理论基础上，我们现在可以转向 EFM 分析的一个实际计算应用。本练习将 EFM 理论与代谢工程中的一个关键目标——识别干预策略——联系起来，它展示了最小切割集（Minimal Cut Sets, MCSs）可以直接从 EFM 集合中计算出来。通过编写程序找到 MCSs，您将学习到构造性路径（EFMs）与破坏性干预（MCSs）之间的强大对偶关系，这是系统生物学中的一个核心概念。[@problem_id:4337272]", "problem": "给定一组小型的、不可逆的稳态生物化学反应网络，以及每个网络的一个目标反应索引。任务是计算所有通过目标反应且具有正通量的基本通量模式，然后计算所有通过与每个此类基本通量模式相交来阻断目标反应的最小割集。最终答案必须是一个完整的、可运行的程序。\n\n基本原理：\n- 稳态意味着内部代谢物的平衡满足 $S v = 0$，其中 $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$m$ 是内部代谢物的数量，$n$ 是反应的数量，$v \\in \\mathbb{R}^{n}$ 是通量向量。\n- 不可逆反应要求 $v \\ge 0$（分量式）。\n- 基本通量模式（EFM）定义为一个非零可行通量向量 $v$，它满足 $S v = 0$ 和 $v \\ge 0$（对于不可逆反应），其中支撑集 $\\mathrm{supp}(v) = \\{ j \\in \\{0,\\dots,n-1\\} \\mid v_j \\ne 0 \\}$ 在所有可行通量向量中关于集合包含关系是最小的。基本通量模式是由 $S v = 0$ 和 $v \\ge 0$ 定义的凸锥的射线，对于不可逆网络，基本通量模式中的每个活性反应都具有严格为正的通量。\n- 针对给定目标反应的最小割集（MCS）是一个最小的反应集合，移除该集合中的反应会阻断所有通过目标反应且具有严格为正通量的可行通量向量。等价地，MCS 正是所有通过目标反应且具有严格为正通量的基本通量模式的支撑集族的所有最小命中集（也称为最小横截集）。这里，如果对于一个集合族 $\\mathcal{F}$ 中的所有集合 $F \\in \\mathcal{F}$，都有 $C \\cap F \\ne \\emptyset$，则称集合 $C$ 是该族的一个命中集；如果 $C$ 的任何真子集都不是命中集，则称 $C$ 是最小的。\n\n您的程序必须：\n1) 对于每个测试网络，枚举出所有通过给定目标反应且具有严格为正通量的基本通量模式的支撑集，并遵循 $S v = 0$ 和 $v \\ge 0$。\n2) 计算这些支撑集的所有最小命中集，以获得所有用于阻断目标反应的最小割集。\n3) 对于每个测试网络，返回最小割集集合，形式为按字典序排序的、由零基反应索引组成的已排序列表的列表。\n\n可行性和最小性检查的形式化：\n- 对于一个包含目标索引 $t$ 的候选支撑集 $J \\subseteq \\{0,\\dots,n-1\\}$，可行性意味着存在一个向量 $x \\in \\mathbb{R}^{|J|}$ 且 $x \\ge \\mathbf{1}$，使得 $S_{:,J} x = 0$。因为约束是齐次的，存在一个严格为正的解 $x  0$ 等价于经过适当缩放后存在一个解 $x \\ge \\mathbf{1}$。这确保了候选支撑集中的每个反应都是真正活跃的，且具有严格为正的通量。\n- 支撑集最小性意味着没有真子集 $K \\subset J$ 允许 $S_{:,K} x = 0$ 有严格为正的解 $x  0$。\n\n程序内的输入规范：\n- 共有三个测试网络。对于每个案例，您将获得化学计量矩阵 $S$ 和零基的目标反应索引 $t$。所有反应都是不可逆的，并受 $v \\ge 0$ 的约束。\n\n测试套件：\n- 案例 A（通往产物的分支路径）：\n  - 代谢物：$A, B, C$ ($m = 3$)。\n  - 反应（均为不可逆，$n = 6$）：\n    - $R_0$: $S_{\\mathrm{ext}} \\to A$：列向量 $[1, 0, 0]^\\top$。\n    - $R_1$: $A \\to B$：列向量 $[-1, 1, 0]^\\top$。\n    - $R_2$: $B \\to C$：列向量 $[0, -1, 1]^\\top$。\n    - $R_3$: $C \\to P_{\\mathrm{ext}}$（目标）：列向量 $[0, 0, -1]^\\top$。\n    - $R_4$: $A \\to C$：列向量 $[-1, 0, 1]^\\top$。\n    - $R_5$: $B \\to \\mathrm{waste}$：列向量 $[0, -1, 0]^\\top$。\n  - 目标索引：$t = 3$。\n\n- 案例 B（通过转换步骤到达目标的两条路径）：\n  - 代谢物：$A, B, C$ ($m = 3$)。\n  - 反应（均为不可逆，$n = 5$）：\n    - $R_0$: $S_{\\mathrm{ext}} \\to A$：列向量 $[1, 0, 0]^\\top$。\n    - $R_1$: $A \\to B$：列向量 $[-1, 1, 0]^\\top$。\n    - $R_2$: $A \\to C$：列向量 $[-1, 0, 1]^\\top$。\n    - $R_3$: $B \\to P_{\\mathrm{ext}}$（目标）：列向量 $[0, -1, 0]^\\top$。\n    - $R_4$: $C \\to B$：列向量 $[0, 1, -1]^\\top$。\n  - 目标索引：$t = 3$。\n\n- 案例 C（不可行的目标通量）：\n  - 代谢物：$A$ ($m = 1$)。\n  - 反应（均为不可逆，$n = 1$）：\n    - $R_0$: $A \\to P_{\\mathrm{ext}}$（目标）：列向量 $[-1]^\\top$。\n  - 目标索引：$t = 0$。\n\n输出规范：\n- 对于每个测试案例，输出最小割集的列表，该列表为由已排序的零基反应索引组成的列表，并遵循以下排序约定：\n  - 每个最小割集内部的反应索引必须按严格递增顺序排列。\n  - 一个测试案例的最小割集集合必须按这些列表进行字典序排序。\n  - 整个程序的输出必须是一行，包含按给定顺序（案例A、案例B、案例C）排列的三个案例结果的列表。\n- 最终输出必须是单行，格式与 Python 列表字面量完全一致，例如：$[\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$。\n\n答案类型：\n- 每个案例的结果是一个整数列表的列表。顶层结果是一个长度为 $3$ 的列表。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，\"[resultA,resultB,resultC]\"）。", "solution": "该问题要求计算几个小型的、不可逆的生物化学网络中目标反应的最小割集（MCS）。此任务分为两个主要阶段：首先，枚举所有涉及目标反应的基本通量模式（EFM）；其次，计算这些 EFM 支撑集的最小命中集。问题正确地指出，这些最小命中集恰好就是 MCS。\n\n该解决方案将以 Python 程序的形式实现，程序被构造成几个函数，每个函数处理问题的特定部分。\n\n### 第 1 部分：枚举携带目标通量的基本通量模式\n\n基本通量模式由其支撑集（即具有非零通量的反应集合）的最小性定义。对于一个不可逆网络，EFM 中的所有反应都具有严格为正的通量。一个支撑集 $J$ 对应一个 EFM 当且仅当：\n1.  **可行性**：存在一个通量向量 $v  0$ 且 $\\mathrm{supp}(v) = J$，使得 $S v = 0$。如问题所述，这可以通过检查线性系统 $S_{:,J} x = 0$ 是否存在满足约束 $x \\ge 1$ 的解来测试，这是一个标准的线性规划可行性问题。设 $k = |J|$，该系统是寻找 $x \\in \\mathbb{R}^k$ 使得 $S_{:,J} x = 0$ 和 $x \\ge 1$。这可以使用 `scipy.optimize.linprog` 通过将目标函数设置为零来求解。\n2.  **最小性**：$J$ 的任何真子集都不是一个可行的支撑集。\n\n寻找所有包含目标反应 $t$ 的 EFM 支撑集的算法如下：\n- 生成所有包含目标反应 $t$ 的可能的反应子集 $J$。这通过获取所有其他反应的幂集，并将 $t$ 添加到每个子集中来实现。\n- 对于每个候选支撑集 $J$，使用 `scipy.optimize.linprog` 检查其可行性。收集所有可行的支撑集。\n- 从可行支撑集列表中筛选出满足最小性的集合。一个可行的支撑集 $J$ 是最小的，如果没有其他可行的支撑集 $K$ 是 $J$ 的真子集。通过先按大小对可行支撑集进行排序，然后对每个候选集检查它是否是任何已确认的最小支撑集的超集，可以高效地进行此筛选。\n\n### 第 2 部分：计算最小割集（最小命中集）\n\n一旦确定了相关的 EFM 支撑集集合 $\\mathcal{F} = \\{E_1, E_2, \\dots, E_p\\}$，下一步是计算它们的最小命中集（MHS）。如果一个集合 $C$ 与 $\\mathcal{F}$ 中的每个集合都有非空交集（即 $\\forall E_i \\in \\mathcal{F}, C \\cap E_i \\ne \\emptyset$），则称 $C$ 是 $\\mathcal{F}$ 的命中集。一个 MCS 是一个在集合包含关系下最小的命中集。\n\nMHS 的计算可以使用一种称为横截集算法（transversal algorithm）的迭代过程。算法过程如下：\n- 初始化 MHS 集合，以空族的 MHS 作为初始值，即只包含空集的集合：$\\mathcal{H}_0 = \\{\\emptyset\\}$。\n- 迭代处理每个 EFM 支撑集 $E_i \\in \\mathcal{F}$：\n  - 对于每个已有的 MHS $H \\in \\mathcal{H}_{i-1}$ 和每个反应 $r \\in E_i$，形成一个新的候选命中集 $H' = H \\cup \\{r\\}$。\n  - 新的候选集合是 $\\mathcal{H}'_i = \\{ H \\cup \\{r\\} \\mid H \\in \\mathcal{H}_{i-1}, r \\in E_i \\}$。\n  - 通过仅保留 $\\mathcal{H}'_i$ 中的最小集合来获得下一组 MHS $\\mathcal{H}_i$。\n- 在遍历所有 EFM 支撑集后，最终的集合 $\\mathcal{H}_p$ 就是所有 MCS 的集合。\n\n这个过程正确地计算了所有的 MCS。如果携带目标通量的 EFM 集合为空（如案例 C，目标通量不可行），则族 $\\mathcal{F}$ 为空。空族的最小命中集是空集 $\\emptyset$，因为成为命中集的条件被虚满足。因此，MCS 的集合是 $\\{\\emptyset\\}$，将表示为 `[[]]`。\n\n### 最终输出格式化\n\n每个测试案例得到的 MCS 列表将根据问题的规范进行排序：每个单独的 MCS（一个反应索引的列表）按升序排序，而所有 MCS 的列表按字典序排序。所有测试案例的结果随后被聚合成一个单一列表，并以紧凑的单行格式打印。\n\n以下 Python 程序实现了这一完整逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations\n\ndef _check_feasibility(S, support):\n    \"\"\"\n    Checks if a given support is feasible by solving a linear programming problem.\n    A support J is feasible if there exists a flux vector v  0 with supp(v) = J.\n    This is equivalent to checking if the system S_J * x = 0 has a solution with x = 1.\n    \"\"\"\n    if not support:\n        return False\n    \n    S_J = S[:, support]\n    m, k = S_J.shape\n\n    # We are solving a feasibility problem, so the objective function is irrelevant.\n    # min c^T * x, where c is a vector of zeros.\n    c = np.zeros(k)\n\n    # Constraints are S_J * x = 0 and x = 1.\n    bounds = [(1, None)] * k\n\n    # Solve the linear program. The 'highs' method is robust.\n    # We only care about whether a solution was found (res.success).\n    res = linprog(c, A_eq=S_J, b_eq=np.zeros(m), bounds=bounds, method='highs')\n    \n    return res.success\n\ndef find_target_efms(S, t):\n    \"\"\"\n    Enumerates all elementary flux mode supports that include the target reaction 't'.\n    It first finds all feasible supports containing 't' and then filters for minimality.\n    \"\"\"\n    num_reactions = S.shape[1]\n    other_reactions = [r for r in range(num_reactions) if r != t]\n    \n    feasible_supports = []\n    \n    # Iterate over all subsets of other_reactions to form candidate supports with 't'.\n    for i in range(len(other_reactions) + 1):\n        for combo in combinations(other_reactions, i):\n            support_candidate = sorted(list(combo) + [t])\n            if _check_feasibility(S, support_candidate):\n                feasible_supports.append(support_candidate)\n\n    # Filter for minimal supports to get EFMs.\n    # Sorting by length allows for efficient checking of minimality.\n    feasible_supports.sort(key=len)\n    \n    efm_supports = []\n    for J in feasible_supports:\n        is_minimal = True\n        # A support J is not minimal if it's a superset of an already found EFM.\n        for K in efm_supports:\n            if set(K).issubset(set(J)):\n                is_minimal = False\n                break\n        if is_minimal:\n            efm_supports.append(J)\n            \n    return efm_supports\n\ndef _minimize_sets(list_of_sets):\n    \"\"\"\n    Given a list of sets (represented as lists), returns a new list\n    containing only the minimal sets with respect to subset inclusion.\n    \"\"\"\n    if not list_of_sets:\n        return []\n\n    # Use frozensets for hashing and efficient storage.\n    set_versions = {frozenset(s) for s in list_of_sets}\n    \n    # Sort by size for efficient subset checking.\n    sorted_sets = sorted(list(set_versions), key=len)\n    \n    minimal_sets = []\n    for s_i in sorted_sets:\n        is_minimal = True\n        for m_j in minimal_sets:\n            if m_j.issubset(s_i):\n                is_minimal = False\n                break\n        if is_minimal:\n            minimal_sets.append(s_i)\n            \n    # Convert back to sorted lists of integers.\n    return [sorted(list(s)) for s in minimal_sets]\n\ndef compute_minimal_hitting_sets(family_of_sets):\n    \"\"\"\n    Computes all minimal hitting sets (transversals) for a family of sets\n    using an iterative transversal algorithm.\n    \"\"\"\n    # The minimal hitting set of an empty family is {emptyset}.\n    if not family_of_sets:\n        return [[]]\n    mhs = [[]]\n    \n    for s in family_of_sets:\n        new_mhs = []\n        for h in mhs:\n            for element in s:\n                # Form a new candidate hitting set by adding an element from the current set 's'.\n                new_h = h + [element]\n                new_mhs.append(new_h)\n        # Prune the generated candidates to keep only minimal ones for the next iteration.\n        mhs = _minimize_sets(new_mhs)\n        \n    return mhs\n\ndef compute_overall_mcs_for_case(S, t):\n    \"\"\"\n    Orchestrates the computation of MCS for a single network case.\n    1. Finds target-carrying EFMs.\n    2. Computes the minimal hitting sets of their supports.\n    3. Sorts the result as specified.\n    \"\"\"\n    # 1. Enumerate supports of elementary flux modes that use the target reaction.\n    efm_supports = find_target_efms(S, t)\n\n    # 2. Compute minimal hitting sets, which are the minimal cut sets.\n    mcs_list = compute_minimal_hitting_sets(efm_supports)\n    \n    # 3. Sort the final list of MCSs lexicographically.\n    mcs_list.sort()\n    \n    return mcs_list\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the computation, and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    \n    # Case A: Branched pathway to product\n    S_A = np.array([\n        [1., -1., 0., 0., -1., 0.],\n        [0., 1., -1., 0., 0., -1.],\n        [0., 0., 1., -1., 1., 0.]\n    ])\n    t_A = 3\n\n    # Case B: Two routes to target via a conversion step\n    S_B = np.array([\n        [1., -1., -1., 0., 0.],\n        [0., 1., 0., -1., 1.],\n        [0., 0., 1., 0., -1.]\n    ])\n    t_B = 3\n\n    # Case C: Infeasible target flux\n    S_C = np.array([[-1.]])\n    t_C = 0\n\n    test_cases = [ (S_A, t_A), (S_B, t_B), (S_C, t_C) ]\n\n    results = []\n    for S, t in test_cases:\n        result = compute_overall_mcs_for_case(S, t)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation is modified to remove spaces for a compact output.\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "4337272"}]}