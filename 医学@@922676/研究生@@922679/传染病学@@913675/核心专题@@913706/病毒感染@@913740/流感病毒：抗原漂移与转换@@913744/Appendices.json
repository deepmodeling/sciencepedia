{"hands_on_practices": [{"introduction": "要理解抗原漂变的速率和时间线，我们首先需要将病毒的进化过程置于一个时间尺度上。这项练习介绍了一种系统动力学中的基本技术：利用分子钟概念，从基因序列数据中估算最近共同祖先的时间（TMRCA）。通过这项实践，您将学习如何将遗传差异转化为具体的进化时间框架，这是分析病毒传播和演化的关键第一步 [@problem_id:4657382]。", "problem": "一个甲型流感病毒血凝素 (HA) 基因数据集包含了从单一抗原漂移谱系中同时采样的序列，在观测窗口内没有证据表明发生了重配或抗原转变。这些序列已经对齐，报告的对齐序列间平均成对距离为每位点 $0.03$ 次替换，该距离已使用标准的时间可逆模型对多次命中进行了校正。假设存在严格分子钟，其恒定的替换速率为 $r = 3 \\times 10^{-3}$ 次替换/位点/年。使用基本原理——即每个谱系中的替换累积是一个具有恒定速率的无记忆泊松过程，并且两个末端之间的成对序列分歧反映了自它们分歧以来沿两个独立谱系累积的替换总和——从这些假设出发，推导所采样序列的最近共同祖先时间 (TMRCA) 的表达式，然后使用所提供的数值计算其值。最终时间以年为单位表示。提供精确值，无需四舍五入。", "solution": "问题要求推导一组同时采样的流感病毒序列的最近共同祖先时间 (TMRCA) 的表达式，并计算其值。\n\n让我们首先将问题中陈述的原理形式化。替换的累积被建模为一个具有恒定速率 $r$ 的无记忆泊松过程。该速率的值为 $r = 3 \\times 10^{-3}$ 次替换/位点/年。\n\n考虑样本中任意两个序列，索引为 $i$ 和 $j$。由于序列是同时采样的（在同一时间），从现在到它们最近共同祖先的时间 $t_{ij}$ 对两个谱系是相同的。分隔这两个序列的总进化路径始于它们的共同祖先，沿两个独立的分支随时间向前延伸，并终止于两个末端。因此，该路径的总时长为 $t_{ij} + t_{ij} = 2t_{ij}$。\n\n根据该模型，序列 $i$ 和序列 $j$ 之间每位点的预期替换数，即遗传距离 $d_{ij}$，是替换速率 $r$ 和总分歧时间 $2t_{ij}$ 的乘积。\n$$d_{ij} = r \\times (2t_{ij}) = 2rt_{ij}$$\n\n问题提供了整个对齐序列的平均成对距离，我们将其表示为 $\\bar{d}$。这是样本中所有不同配对 $(i, j)$ 的距离 $d_{ij}$ 的算术平均值。\n$$\\bar{d} = \\text{avg}(d_{ij})$$\n鉴于距离和时间之间的线性关系，我们可以将平均距离与一对序列的平均最近共同祖先时间联系起来，我们将其表示为 $\\bar{t}_{\\text{pair}} = \\text{avg}(t_{ij})$。\n$$\\bar{d} = \\text{avg}(2rt_{ij}) = 2r \\, \\text{avg}(t_{ij}) = 2r\\bar{t}_{\\text{pair}}$$\n\n题目要求我们找到*整个样本*的 TMRCA，而不仅仅是一对序列的。我们将整个样本的 TMRCA 表示为 $T$。这是从现在到样本中所有序列都源自的单一祖先序列的时间。在一个普遍的系统发育树中，特定一对序列的共同祖先时间 $t_{ij}$ 小于或等于整个样本的共同祖先时间 $T$。因此，平均成对 TMRCA，$\\bar{t}_{\\text{pair}}$，通常不等于 $T$。确切的关系取决于系统发育的分支结构（树拓扑结构），而这又由种群的动态历史决定。\n\n问题没有提供关于样本大小或潜在种群动态模型的信息。为了从基本原理出发推导一个单一、唯一的表达式，我们必须采用最简单的系统发育模型。这就是“星状”系统发育模型，其中假设样本中的所有谱系都同时从单一共同祖先分歧而来。在缺乏更复杂信息的情况下，这个模型是一个简约的选择。\n\n在星状系统发育的假设下，任何一对序列 $(i, j)$ 的最近共同祖先与整个样本的最近共同祖先是相同的。因此，任何一对序列的 MRCA 时间等于整个样本的 TMRCA。\n$$t_{ij} = T \\quad \\text{for all } i, j$$\n因此，平均成对 TMRCA 也等于 $T$。\n$$\\bar{t}_{\\text{pair}} = \\text{avg}(T) = T$$\n将此结果代入我们关于平均距离的表达式中，得到：\n$$\\bar{d} = 2rT$$\n这个方程在星状树的简化假设下，提供了平均成对距离、替换速率和样本 TMRCA 之间的直接关系。求解 $T$ 得到所需的表达式：\n$$T = \\frac{\\bar{d}}{2r}$$\n这就是所采样序列 TMRCA 的推导表达式。\n\n现在，我们使用所提供的数值计算 $T$ 的值：\n平均成对距离为 $\\bar{d} = 0.03$ 次替换/位点。\n替换速率为 $r = 3 \\times 10^{-3}$ 次替换/位点/年。\n\n将这些值代入我们推导的表达式中：\n$$T = \\frac{0.03}{2 \\times (3 \\times 10^{-3})} = \\frac{3 \\times 10^{-2}}{6 \\times 10^{-3}}$$\n单位 (替换数/位点) / ((替换数/位点)/年) 正确地得到年份。\n$$T = \\frac{3}{6} \\times 10^{(-2 - (-3))} = \\frac{1}{2} \\times 10^{1} = 0.5 \\times 10 = 5$$\n因此，最近共同祖先的时间是 $5$ 年。", "answer": "$$\\boxed{5}$$", "id": "4657382"}, {"introduction": "抗原漂变是由正选择驱动的，即那些能帮助病毒逃避宿主免疫的突变会受到青睐。这项练习提供了一种强大的实践方法，可以直接从蛋白质编码序列中检测到这种进化压力。您将实现一个密码子替换模型来计算非同义替换率与同义替换率之比（$dN/dS$ 或 $\\omega$），这是识别血凝素蛋白中为逃避免疫系统而快速进化的位点的关键指标 [@problem_id:4657325]。", "problem": "您的任务是使用基于密码子的连续时间马尔可夫链，对流感血凝素 (HA) 蛋白编码序列实现非同义与同义替换速率比（记为 $dN/dS$，通常称为 $\\omega$）的逐位点推断，并将抗原位点上该比值的升高解释为与抗原漂移一致的正选择证据。您的程序必须构建一个密码子替换模型，在一个小型的固定星状系统发育树上计算 $\\omega$ 的位点特异性最大似然估计，然后总结抗原位点相对于非抗原位点是否显示出升高的 $\\omega$。\n\n基本原理：\n- 遗传密码将每个有义密码子映射到一个氨基酸，另有三个不编码氨基酸的终止密码子。\n- 一个状态空间仅限于有义密码子的、基于密码子的连续时间马尔可夫链可以模拟密码子替换，其中瞬时速率反映了单核苷酸变化、转换与颠换突变偏好以及对非同义变化的缩放因子。\n- 对于一个速率矩阵 $Q$，时间为 $t$ 时的转移概率矩阵为 $P(t) = \\exp(Qt)$，在星状系统发育树上，观察到的叶尖状态的似然通过平稳分布 $\\pi$ 对未观察到的祖先状态进行边缘化得到。\n- 非同义与同义速率比 $\\omega = dN/dS$ 捕捉了在选择作用下非同义变化与同义变化的相对固定速率；$\\omega > 1$ 表示正选择，$\\omega \\approx 1$ 表示中性选择，$\\omega < 1$ 表示纯化选择。\n\n需要实现的模型假设：\n- 状态空间由标准遗传密码下的所有有义密码子组成（排除终止密码子）。\n- 仅当密码子 $i$ 和 $j$ 相差一个核苷酸时，瞬时速率 $q_{ij}$ 才非零。核苷酸突变偏好由转换与颠换比率参数 $\\kappa$ 控制。对于单核苷酸变化，如果该变化是转换，则使用与 $\\kappa$ 成正比的基础突变率；如果是颠换，则使用与 $1$ 成正比的基础突变率。如果变化是非同义的，则将此基础速率乘以 $\\omega$；如果是同义的，则乘以 $1$。设置 $q_{ii}$ 以使每行之和为零。\n- 对有义密码子使用均匀的平稳频率，$\\pi_i = 1/N$，其中 $N$ 是有义密码子的数量。\n- 缩放 $Q$ 以使在分布 $\\pi$ 下的平均替换速率为每个时间单位 1，即 $-\\sum_i \\pi_i q_{ii} = 1$。通过此缩放，分支长度 $t$ 以每个密码子的期望替换数来衡量。\n\n系统发育树与似然：\n- 使用一个具有三个叶节点和相等分支长度的星状系统发育树。对于每个位点，三个叶节点上观察到的密码子表示为 $(x_1, x_2, x_3)$。对于给定的 $\\omega$，在分支长度为 $t$ 的情况下，位点似然为\n$$\n\\mathcal{L}(\\omega) \\;=\\; \\sum_{a} \\pi_a \\prod_{\\ell=1}^{3} P_{a,x_\\ell}(t),\n$$\n其中 $P(t) = \\exp(Qt)$ 是转移概率矩阵。位点特异性最大似然估计 $\\widehat{\\omega}$ 是在指定网格上使 $\\mathcal{L}(\\omega)$ 最大化的 $\\omega$ 值。\n- 使用固定的转换/颠换偏好 $\\kappa = 3.0$（无量纲）和分支长度 $t = 0.5$（以每个密码子的期望替换数计）。\n\n抗原漂移与解释：\n- HA 的抗原区受到免疫压力，并预计在正选择下表现出升高的 $\\omega$。您将计算一组抗原位点上 $\\widehat{\\omega}$ 的均值和一组非抗原位点上 $\\widehat{\\omega}$ 的均值，然后报告其差值。\n\n计算任务：\n1. 根据标准遗传密码，通过排除终止密码子来构建大小为 $N$ 的密码子字母表。\n2. 对于一个 $\\omega$ 值的网格 $\\Omega = \\{0.05, 0.1, 0.2, 0.5, 0.8, 1.0, 1.2, 1.5, 2.0, 3.0, 5.0\\}$，按上述方式构建 $Q(\\omega)$，将其缩放至单位平均速率，并对给定的 $t$ 计算 $P_\\omega(t) = \\exp(Q(\\omega) t)$。\n3. 对于每个位点和每个数据集，通过对所有祖先密码子状态求和并对三个叶节点进行乘积来计算位点似然 $\\mathcal{L}(\\omega)$。选择使该位点的 $\\mathcal{L}(\\omega)$ 最大化的网格值作为 $\\widehat{\\omega}$。\n4. 对于每个数据集，计算抗原位点上 $\\widehat{\\omega}$ 的均值和非抗原位点上的均值，然后计算差值 $\\Delta = \\overline{\\omega}_{\\text{antigenic}} - \\overline{\\omega}_{\\text{non-antigenic}}$。\n\n输入数据在程序中是固定的；不需要用户输入。\n\n使用以下三个数据集（每个数据集有三个标记为 $A$、$B$、$C$ 的序列和六个密码子位置）。密码子由集合 $\\{A,C,G,T\\}$ 中的核苷酸写成：\n\n- 数据集 1（抗原位点主要为同义替换或保守）：\n  - 抗原位点索引：$\\{2,5\\}$（基于 1 的索引）。\n  - $A$: [GCT, GAA, TTT, ATG, CTA, CGT]\n  - $B$: [GCT, GAG, TTC, ATG, TTA, CGC]\n  - $C$: [GCT, GAA, TTT, ATA, CTA, AGT]\n\n- 数据集 2（抗原位点具有多个非同义差异）：\n  - 抗原位点索引：$\\{2,5\\}$。\n  - $A$: [GCT, GAA, TTT, ATG, CTA, CGT]\n  - $B$: [GCT, AAA, TTC, ATG, GTA, CGC]\n  - $C$: [GCT, GCA, TTT, ATG, TCA, CGT]\n\n- 数据集 3（信号模糊，混合了同义和非同义变化）：\n  - 抗原位点索引：$\\{2,5\\}$。\n  - $A$: [GCT, GAA, TTT, ATG, CTA, CGT]\n  - $B$: [GCT, GAG, TTC, ATA, CTT, CGT]\n  - $C$: [GCT, AAA, TTT, ATG, CTA, CGC]\n\n角度单位不适用。不涉及物理单位。所有结果均为无量纲。\n\n测试套件与要求输出：\n- 使用 $\\kappa = 3.0$，$t = 0.5$ 和指定的 $\\Omega$ 对上述三个数据集实施计算。\n- 对于每个数据集，计算定义的 $\\Delta$。您的程序应生成单行输出，其中包含三个数据集的结果，形式为一个由三个浮点数组成的逗号分隔列表，四舍五入到三位小数，并用方括号括起来，顺序为数据集 1、数据集 2、数据集 3（例如，“[0.123,0.456,-0.789]”）。", "solution": "该问题被认为是有效的，因为它科学地基于分子进化原理，提法得当且指令清晰完整，表述客观。任务是实现一个位点特异性密码子替换模型，以推断非同义与同义替换速率比 $\\omega$，并确定流感血凝素 (HA) 蛋白中的抗原位点是否显示出正选择的证据。\n\n解决方案主要分为四个阶段进行：\n1.  密码子模型和状态空间的定义。\n2.  瞬时速率矩阵 $Q$ 的构建。\n3.  在星状系统发育树上位点似然的计算。\n4.  每个位点 $\\omega$ 的最大似然估计及结果分析。\n\n**1. 密码子模型状态空间**\n\n该模型作用于密码子，即核苷酸三联体。标准遗传密码将 64 个可能的密码子映射到 20 种氨基酸和 3 个终止信号。我们的连续时间马尔可夫链的状态空间仅限于 $N=61$ 个有义密码子，排除了三个终止密码子（`TAA`、`TAG`、`TGA`）。我们建立这 61 个密码子的明确列表，并为矩阵运算创建一个从每个密码子字符串到 0 到 60 唯一整数索引的映射。假设平稳分布 $\\pi$ 在此状态空间上是均匀的，因此任何有义密码子 $i$ 的频率为 $\\pi_i = 1/N = 1/61$。\n\n**2. 瞬时速率矩阵, $Q(\\omega, \\kappa)$**\n\n从密码子 $i$ 到密码子 $j$ 的瞬时替换速率（对于 $i \\neq j$ 记为 $q_{ij}$）是基于核苷酸突变和选择的机理模型来定义的。矩阵 $Q$ 的大小为 $N \\times N$，即 $61 \\times 61$。\n\n仅当密码子 $i$ 和 $j$ 相差一个核苷酸时，速率 $q_{ij}$ 才非零。对于这样的密码子对，速率由以下公式给出：\n$$\nq_{ij} =\n\\begin{cases}\n    \\kappa              \\text{如果是同义转换} \\\\\n    1                   \\text{如果是同义颠换} \\\\\n    \\omega \\cdot \\kappa   \\text{如果是非同义转换} \\\\\n    \\omega \\cdot 1        \\text{如果是非同义颠换}\n\\end{cases}\n$$\n- **转换**是嘌呤之间 (A $\\leftrightarrow$ G) 或嘧啶之间 (C $\\leftrightarrow$ T) 的替换。**颠换**是任何其他替换（嘌呤 $\\leftrightarrow$ 嘧啶）。转换/颠换速率比固定为 $\\kappa = 3.0$。\n- 如果替换不改变密码子编码的氨基酸，则为**同义**替换。此类变化的速率乘以因子 1。\n- 如果替换导致不同的氨基酸，则为**非同义**替换。此类变化的速率乘以参数 $\\omega = dN/dS$，该参数代表选择压力。\n\n速率矩阵的对角线元素被定义为确保行和为零：\n$$\nq_{ii} = - \\sum_{j \\neq i} q_{ij}\n$$\n最后，整个矩阵 $Q$ 被缩放以确保平均替换速率为每个时间单位 1。在均匀平稳分布 $\\pi_i = 1/N$ 的情况下，此条件为 $-\\sum_{i=0}^{N-1} \\pi_i q_{ii} = 1$，可简化为：\n$$\nS = -\\frac{1}{N} \\sum_{i=0}^{N-1} q_{ii} = 1\n$$\n因此，先构建一个未缩放的矩阵，然后将每个元素除以缩放因子 $S = -\\frac{1}{N} \\sum_i q_{ii}^{\\text{unscaled}}$。对于指定网格 $\\Omega = \\{0.05, 0.1, 0.2, 0.5, 0.8, 1.0, 1.2, 1.5, 2.0, 3.0, 5.0\\}$ 中的每个 $\\omega$ 值，都构建一个单独的速率矩阵。\n\n**3. 系统发育似然计算**\n\n问题指定了一个具有三个叶尖（序列 A、B、C）和一个共同祖先的星状系统发育树。从祖先到叶尖的所有三个分支长度相等，均为 $t = 0.5$（以每个密码子的期望替换数衡量）。\n\n在长度为 $t$ 的分支上，密码子 $i$ 变为密码子 $j$ 的概率由转移概率矩阵 $P(t) = \\exp(Q t)$ 给出，其中 $Q$ 是缩放后的速率矩阵。对每个 $Q(\\omega)$ 矩阵计算此矩阵指数。\n\n对于比对中的单个位点，设三个叶尖上观察到的密码子为 $(x_1, x_2, x_3)$。在给定 $\\omega$ 值的情况下，观察到此数据的似然是通过对所有可能的祖先密码子 $a$ 进行边缘化来计算的：\n$$\n\\mathcal{L}(\\omega) = \\sum_{a=0}^{N-1} \\pi_a \\prod_{\\ell=1}^{3} P_{a,x_\\ell}(t)\n$$\n根据我们对均匀平稳频率的假设 $\\pi_a = 1/N$，公式变为：\n$$\n\\mathcal{L}(\\omega) = \\frac{1}{N} \\sum_{a=0}^{N-1} P_{a,x_1}(t) \\cdot P_{a,x_2}(t) \\cdot P_{a,x_3}(t)\n$$\n对每个位点和网格 $\\Omega$ 中的每个 $\\omega$ 计算此似然。\n\n**4. 估计与分析**\n\n对于每个位点，omega 的最大似然估计 $\\widehat{\\omega}$ 是通过在网格 $\\Omega$ 中找到使位点似然 $\\mathcal{L}(\\omega)$ 最大化的值来确定的。\n\n在计算完一个数据集中所有六个位点的 $\\widehat{\\omega}$ 后，根据提供的索引（位点 2 和 5 为抗原位点），将这些位点分为抗原和非抗原两组。计算每组的平均 $\\widehat{\\omega}$：\n$$\n\\overline{\\omega}_{\\text{antigenic}} = \\frac{1}{2}\\sum_{i \\in \\{2,5\\}} \\widehat{\\omega}_i \\quad \\text{和} \\quad \\overline{\\omega}_{\\text{non-antigenic}} = \\frac{1}{4}\\sum_{i \\in \\{1,3,4,6\\}} \\widehat{\\omega}_i\n$$\n每个数据集的最终结果是这些均值之间的差值，$\\Delta = \\overline{\\omega}_{\\text{antigenic}} - \\overline{\\omega}_{\\text{non-antigenic}}$。正的 $\\Delta$ 表明，平均而言，抗原位点比非抗原位点受到更强的正选择，这与抗原漂移理论一致。对所有三个提供的数据集重复此整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Implements a codon substitution model to infer site-wise dN/dS ratios (omega)\n    and analyze differences between antigenic and non-antigenic sites for influenza HA.\n    \"\"\"\n    \n    # --- 1. Model and Problem Constants ---\n\n    KAPPA = 3.0  # Transition/transversion rate ratio\n    T = 0.5  # Branch length\n    OMEGA_GRID = [0.05, 0.1, 0.2, 0.5, 0.8, 1.0, 1.2, 1.5, 2.0, 3.0, 5.0]\n\n    GENETIC_CODE = {\n        'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAT': 'N',\n        'ACA': 'T', 'ACC': 'T', 'ACG': 'T', 'ACT': 'T',\n        'AGA': 'R', 'AGC': 'S', 'AGG': 'R', 'AGT': 'S',\n        'ATA': 'I', 'ATC': 'I', 'ATG': 'M', 'ATT': 'I',\n        'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAT': 'H',\n        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCT': 'P',\n        'CGA': 'R', 'CGC': 'R', 'CGG': 'R', 'CGT': 'R',\n        'CTA': 'L', 'CTC': 'L', 'CTG': 'L', 'CTT': 'L',\n        'GAA': 'E', 'GAC': 'D', 'GAG': 'E', 'GAT': 'D',\n        'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCT': 'A',\n        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGT': 'G',\n        'GTA': 'V', 'GTC': 'V', 'GTG': 'V', 'GTT': 'V',\n        'TAA': '*', 'TAC': 'Y', 'TAG': '*', 'TAT': 'Y',\n        'TCA': 'S', 'TCC': 'S', 'TCG': 'S', 'TCT': 'S',\n        'TGA': '*', 'TGC': 'C', 'TGG': 'W', 'TGT': 'C',\n        'TTA': 'L', 'TTC': 'F', 'TTG': 'L', 'TTT': 'F',\n    }\n\n    # --- 2. Helper Functions ---\n\n    def get_codons_and_maps(genetic_code):\n        \"\"\"Generates the list of sense codons and their index mappings.\"\"\"\n        codons = sorted([c for c, aa in genetic_code.items() if aa != '*'])\n        codon_to_idx = {c: i for i, c in enumerate(codons)}\n        n_codons = len(codons)\n        return codons, codon_to_idx, n_codons\n\n    def is_transition(n1, n2):\n        \"\"\"Checks if a nucleotide change is a transition.\"\"\"\n        purines = 'AG'\n        pyrimidines = 'CT'\n        return (n1 in purines and n2 in purines) or (n1 in pyrimidines and n2 in pyrimidines)\n\n    def build_q_matrix(omega, kappa, codons, codon_to_idx, n_codons, genetic_code):\n        \"\"\"Builds the unscaled codon substitution rate matrix Q.\"\"\"\n        q = np.zeros((n_codons, n_codons))\n        for i in range(n_codons):\n            for j in range(n_codons):\n                if i == j:\n                    continue\n                \n                codon1, codon2 = codons[i], codons[j]\n                \n                # Check for single nucleotide difference\n                diff_pos = -1\n                diff_count = 0\n                for k in range(3):\n                    if codon1[k] != codon2[k]:\n                        diff_count += 1\n                        diff_pos = k\n                \n                if diff_count == 1:\n                    rate = kappa if is_transition(codon1[diff_pos], codon2[diff_pos]) else 1.0\n                    \n                    is_synonymous = genetic_code[codon1] == genetic_code[codon2]\n                    if not is_synonymous:\n                        rate *= omega\n                    \n                    q[i, j] = rate\n        return q\n\n    def scale_q_matrix(q, n_codons):\n        \"\"\"Sets diagonal elements and scales the Q matrix.\"\"\"\n        row_sums = q.sum(axis=1)\n        np.fill_diagonal(q, -row_sums)\n        \n        # Scaling factor: -sum(pi_i * q_ii) where pi_i = 1/n_codons\n        # This is equivalent to (1/n_codons) * sum of absolute values of diagonal\n        scaling_factor = -np.diag(q).sum() / n_codons\n        if scaling_factor > 0:\n            q /= scaling_factor\n        return q\n\n    def precompute_p_matrices(omega_grid, kappa, t, codons, codon_to_idx, n_codons, genetic_code):\n        \"\"\"Precomputes transition probability matrices P(t) for all omega values.\"\"\"\n        p_matrices = {}\n        for omega in omega_grid:\n            q_unscaled = build_q_matrix(omega, kappa, codons, codon_to_idx, n_codons, genetic_code)\n            q_scaled = scale_q_matrix(q_unscaled, n_codons)\n            p_matrices[omega] = expm(q_scaled * t)\n        return p_matrices\n\n    def calculate_site_omega(site_codons, codon_to_idx, p_matrices, omega_grid, n_codons):\n        \"\"\"Calculates the maximum likelihood estimate of omega for a single site.\"\"\"\n        max_likelihood = -1.0\n        best_omega = -1.0\n        \n        c1, c2, c3 = site_codons\n        idx1, idx2, idx3 = codon_to_idx[c1], codon_to_idx[c2], codon_to_idx[c3]\n\n        for omega in omega_grid:\n            P_t = p_matrices[omega]\n            # Vectorized calculation of likelihood\n            # P_t[:, idx] gives the column vector of probabilities of transitioning to codon `idx` from any ancestor\n            likelihood_vec = P_t[:, idx1] * P_t[:, idx2] * P_t[:, idx3]\n            # Marginalize over all ancestors, with uniform prior pi_a = 1/n_codons\n            site_likelihood = likelihood_vec.sum() / n_codons\n            \n            if site_likelihood > max_likelihood:\n                max_likelihood = site_likelihood\n                best_omega = omega\n        \n        return best_omega\n\n    # --- 3. Main Execution Logic ---\n    \n    codons, codon_to_idx, n_codons = get_codons_and_maps(GENETIC_CODE)\n    p_matrices = precompute_p_matrices(OMEGA_GRID, KAPPA, T, codons, codon_to_idx, n_codons, GENETIC_CODE)\n    \n    ds1_A = [\"GCT\", \"GAA\", \"TTT\", \"ATG\", \"CTA\", \"CGT\"]\n    ds1_B = [\"GCT\", \"GAG\", \"TTC\", \"ATG\", \"TTA\", \"CGC\"]\n    ds1_C = [\"GCT\", \"GAA\", \"TTT\", \"ATA\", \"CTA\", \"AGT\"]\n    \n    ds2_A = [\"GCT\", \"GAA\", \"TTT\", \"ATG\", \"CTA\", \"CGT\"]\n    ds2_B = [\"GCT\", \"AAA\", \"TTC\", \"ATG\", \"GTA\", \"CGC\"]\n    ds2_C = [\"GCT\", \"GCA\", \"TTT\", \"ATG\", \"TCA\", \"CGT\"]\n\n    ds3_A = [\"GCT\", \"GAA\", \"TTT\", \"ATG\", \"CTA\", \"CGT\"]\n    ds3_B = [\"GCT\", \"GAG\", \"TTC\", \"ATA\", \"CTT\", \"CGT\"]\n    ds3_C = [\"GCT\", \"AAA\", \"TTT\", \"ATG\", \"CTA\", \"CGC\"]\n\n    test_cases = [\n        {'seqs': (ds1_A, ds1_B, ds1_C), 'antigenic_sites': {2, 5}},\n        {'seqs': (ds2_A, ds2_B, ds2_C), 'antigenic_sites': {2, 5}},\n        {'seqs': (ds3_A, ds3_B, ds3_C), 'antigenic_sites': {2, 5}},\n    ]\n    \n    final_results = []\n    \n    for case in test_cases:\n        seq_A, seq_B, seq_C = case['seqs']\n        antigenic_sites_1based = case['antigenic_sites']\n        num_sites = len(seq_A)\n        \n        antigenic_omegas = []\n        non_antigenic_omegas = []\n        \n        for i in range(num_sites):\n            site_codons = (seq_A[i], seq_B[i], seq_C[i])\n            site_omega_hat = calculate_site_omega(site_codons, codon_to_idx, p_matrices, OMEGA_GRID, n_codons)\n            \n            if (i + 1) in antigenic_sites_1based:\n                antigenic_omegas.append(site_omega_hat)\n            else:\n                non_antigenic_omegas.append(site_omega_hat)\n        \n        mean_antigenic = np.mean(antigenic_omegas) if antigenic_omegas else 0.0\n        mean_non_antigenic = np.mean(non_antigenic_omegas) if non_antigenic_omegas else 0.0\n        \n        delta = mean_antigenic - mean_non_antigenic\n        final_results.append(f\"{delta:.3f}\")\n\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n\n```", "id": "4657325"}, {"introduction": "流感病毒持续的分子进化在群体水平上产生了深远影响，促成了其季节性动态。这项练习通过使用一个仓室模型，在分子进化与流行病学之间架起了一座桥梁。您将分析一个代表抗原漂变（免疫逃逸）的参数如何能够引起疾病发病率的周期性模式，从而深入了解流感特有的振荡现象 [@problem_id:4657414]。", "problem": "给定一个考虑了抗原漂移的流感传播仓室模型，该模型被构建为一个包含人口周转和免疫逃逸的易感-感染-恢复 (SIR) 模型。易感-感染-恢复 (SIR) 代表了标准的流行病学仓室：易感个体 $S$、感染个体 $I$ 和恢复（免疫）个体 $R$。人口周转由人均出生和死亡率 $\\nu$ 表示，抗原漂移驱动的免疫逃逸由一个速率 $\\mu_a$ 表示，该速率使个体从 $R$ 仓室移回 $S$ 仓室。传播遵循质量作用发病率，速率为 $\\beta$，恢复以速率 $\\gamma$ 发生。总人口规模 $N$ 保持恒定，因为出生和死亡相平衡。该模型为\n$$\n\\frac{dS}{dt} = \\nu N - \\frac{\\beta S I}{N} + \\mu_a R - \\nu S,\\quad\n\\frac{dI}{dt} = \\frac{\\beta S I}{N} - \\gamma I - \\nu I,\\quad\n\\frac{dR}{dt} = \\gamma I - \\mu_a R - \\nu R,\n$$\n其中 $N = S + I + R$ 为常数。\n\n仅从这些定义和模型结构出发，判断地方性平衡点周围的微小扰动是否会引起发病率（即 $I$）的阻尼振荡。当振荡存在时，计算局部线性动力学所蕴含的振荡周期（以年为单位）；当振荡不存在时，将周期定义为 $0.0$ 年。您的方法必须有理有据：在基本再生数 $\\mathcal{R}_0 = \\beta / (\\gamma + \\nu)$ 满足 $\\mathcal{R}_0 > 1$ 的条件下，推导 $I>0$ 的地方性平衡点，然后构建关于 $(S,I)$ 的简化系统的雅可比矩阵，分析其特征值，并在特征值为复数时从虚部提取周期。将最终周期以年为单位表示为一个四舍五入到 $3$ 位小数的实数。\n\n物理单位：所有速率 $\\beta$、$\\gamma$、$\\nu$ 和 $\\mu_a$ 的单位均为每年，输出周期必须以年为单位表示。如果 $\\beta \\le \\gamma + \\nu$（不存在 $I^*>0$ 的地方性平衡点）或线性化只产生实数特征值（无振荡分量），则输出 $0.0$。\n\n您的程序必须评估以下测试套件。每个测试用例是一个元组 $(N,\\beta,\\gamma,\\nu,\\mu_a)$，其中 $N$ 的单位是人，速率的单位是每年。每个测试用例应按照上述规则返回一个浮点数，即以年为单位、四舍五入到 $3$ 位小数的振荡周期：\n\n- 案例 1：$N = 10^6$，$\\beta = 140.0$，$\\gamma = 121.0$，$\\nu = 1/70 \\approx 0.0142857$，$\\mu_a = 0.5$。\n- 案例 2（接近阈值且漂移可忽略，预期为非振荡）：$N = 10^6$，$\\beta = 121.1$，$\\gamma = 121.0$，$\\nu = 1/70 \\approx 0.0142857$，$\\mu_a = 0.0$。\n- 案例 3（更高传播率和显著漂移）：$N = 10^6$，$\\beta = 200.0$，$\\gamma = 121.0$，$\\nu = 1/70 \\approx 0.0142857$，$\\mu_a = 5.0$。\n- 案例 4（较慢恢复情景）：$N = 10^6$，$\\beta = 60.0$，$\\gamma = 52.0$，$\\nu = 1/70 \\approx 0.0142857$，$\\mu_a = 0.5$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是对应测试用例的周期（以年为单位），四舍五入到 $3$ 位小数并以标准十进制表示。", "solution": "用户提供的问题被评估为 **有效**，因为它科学地基于已建立的流行病学建模理论，数学上是适定的，并且其指令是客观且自洽的。任务是确定一个指定的易感-感染-恢复 (SIR) 模型的地方性平衡点周围的阻尼振荡周期。解决方案需要一个基于线性稳定性分析的有理有据的推导。\n\n该模型由以下常微分方程 (ODE) 系统描述：\n$$\n\\frac{dS}{dt} = \\nu N - \\frac{\\beta S I}{N} + \\mu_a R - \\nu S\n$$\n$$\n\\frac{dI}{dt} = \\frac{\\beta S I}{N} - (\\gamma + \\nu) I\n$$\n$$\n\\frac{dR}{dt} = \\gamma I - \\mu_a R - \\nu R\n$$\n总人口 $N = S + I + R$ 是恒定的，因为导数之和为零：$\\frac{d(S+I+R)}{dt} = \\nu N - \\nu(S+I+R) = \\nu N - \\nu N = 0$。这使我们能够通过代入 $R = N - S - I$ 来降低系统的维数。动力学可以完全由一个关于 $S$ 和 $I$ 的二维系统来描述：\n$$\n\\frac{dS}{dt} = \\nu N - \\frac{\\beta S I}{N} + \\mu_a (N - S - I) - \\nu S = (\\nu + \\mu_a)N - (\\nu+\\mu_a)S - \\frac{\\beta S I}{N} - \\mu_a I\n$$\n$$\n\\frac{dI}{dt} = \\frac{\\beta S I}{N} - (\\gamma + \\nu)I\n$$\n\n我们通过将导数设为零来寻找地方性平衡点 $(S^*, I^*)$，条件是 $I^* > 0$。从 $\\frac{dI}{dt} = 0$ 可得：\n$$\n\\left( \\frac{\\beta S^*}{N} - (\\gamma + \\nu) \\right) I^* = 0\n$$\n由于 $I^* > 0$，我们必须有：\n$$\n\\frac{\\beta S^*}{N} - (\\gamma + \\nu) = 0 \\implies S^* = \\frac{N(\\gamma + \\nu)}{\\beta}\n$$\n为了使地方性状态有意义 ($S^* < N$)，我们必须有 $\\beta > \\gamma+\\nu$，这等价于基本再生数 $\\mathcal{R}_0 = \\frac{\\beta}{\\gamma+\\nu} > 1$。这是存在具有正患病率的地方性平衡点的条件。如果 $\\mathcal{R}_0 \\le 1$，则不存在这样的平衡点，周期定义为 $0.0$。\n\n接下来，我们通过设置 $\\frac{dS}{dt} = 0$ 来求解 $I^*$：\n$$\n(\\nu + \\mu_a)N - (\\nu+\\mu_a)S^* - \\frac{\\beta S^* I^*}{N} - \\mu_a I^* = 0\n$$\n代入 $\\frac{\\beta S^*}{N} = \\gamma + \\nu$:\n$$\n(\\nu + \\mu_a)N - (\\nu+\\mu_a)S^* - (\\gamma + \\nu)I^* - \\mu_a I^* = 0\n$$\n$$\n(\\nu + \\mu_a)(N - S^*) = (\\gamma + \\nu + \\mu_a)I^*\n$$\n$$\nI^* = \\frac{(\\nu + \\mu_a)(N - S^*)}{\\gamma + \\nu + \\mu_a} = \\frac{(\\nu + \\mu_a) N \\left(1 - \\frac{\\gamma+\\nu}{\\beta}\\right)}{\\gamma + \\nu + \\mu_a}\n$$\n\n为了分析 $(S^*, I^*)$ 周围的稳定性和振荡行为，我们计算简化系统的雅可比矩阵 $J$：\n$$\nJ = \\begin{pmatrix} \\frac{\\partial}{\\partial S}(\\frac{dS}{dt}) & \\frac{\\partial}{\\partial I}(\\frac{dS}{dt}) \\\\ \\frac{\\partial}{\\partial S}(\\frac{dI}{dt}) & \\frac{\\partial}{\\partial I}(\\frac{dI}{dt}) \\end{pmatrix}_{(S^*, I^*)}\n$$\n偏导数是：\n$$\n\\frac{\\partial}{\\partial S}(\\frac{dS}{dt}) = -(\\nu+\\mu_a) - \\frac{\\beta I}{N}, \\quad \\frac{\\partial}{\\partial I}(\\frac{dS}{dt}) = -\\frac{\\beta S}{N} - \\mu_a\n$$\n$$\n\\frac{\\partial}{\\partial S}(\\frac{dI}{dt}) = \\frac{\\beta I}{N}, \\quad \\frac{\\partial}{\\partial I}(\\frac{dI}{dt}) = \\frac{\\beta S}{N} - (\\gamma+\\nu)\n$$\n在平衡点 $(S^*, I^*)$ 处计算这些值得到：\n$$\nJ = \\begin{pmatrix} -(\\nu+\\mu_a) - \\frac{\\beta I^*}{N} & -(\\gamma+\\nu) - \\mu_a \\\\ \\frac{\\beta I^*}{N} & 0 \\end{pmatrix} = \\begin{pmatrix} -(\\nu+\\mu_a) - \\frac{\\beta I^*}{N} & -(\\gamma+\\nu+\\mu_a) \\\\ \\frac{\\beta I^*}{N} & 0 \\end{pmatrix}\n$$\n$J$ 的特征值 $\\lambda$ 是特征方程 $\\lambda^2 - \\text{Tr}(J)\\lambda + \\det(J) = 0$ 的根，其中：\n$$\n\\text{Tr}(J) = -(\\nu+\\mu_a) - \\frac{\\beta I^*}{N}\n$$\n$$\n\\det(J) = \\left(\\frac{\\beta I^*}{N}\\right) (\\gamma+\\nu+\\mu_a)\n$$\n由于所有参数（$\\nu, \\mu_a, \\beta, \\gamma$）都是非负的且 $I^*>0$，很明显 $\\text{Tr}(J) < 0$。这确保了特征值的实部为负，意味着该平衡点是局部稳定的（扰动是阻尼的）。\n\n如果特征值是共轭复数对，则会发生振荡。这在特征方程的判别式 $\\Delta = \\text{Tr}(J)^2 - 4\\det(J)$ 为负时发生。\n$$\n\\Delta = \\left(-(\\nu+\\mu_a) - \\frac{\\beta I^*}{N}\\right)^2 - 4\\left(\\frac{\\beta I^*}{N}\\right)(\\gamma+\\nu+\\mu_a) < 0\n$$\n如果 $\\Delta \\ge 0$，特征值为实数，没有振荡，周期 $T$ 为 $0.0$。\n如果 $\\Delta < 0$，特征值为 $\\lambda = \\frac{\\text{Tr}(J)}{2} \\pm i\\omega$，其中振荡的角频率 $\\omega$ 是：\n$$\n\\omega = \\frac{\\sqrt{-\\Delta}}{2} = \\frac{\\sqrt{4\\det(J) - \\text{Tr}(J)^2}}{2}\n$$\n振荡周期 $T$ 由 $T = \\frac{2\\pi}{\\omega}$ 给出。\n\n计算算法如下：\n1. 对于每组参数 $(N, \\beta, \\gamma, \\nu, \\mu_a)$，计算 $\\mathcal{R}_0 = \\beta / (\\gamma+\\nu)$。\n2. 如果 $\\mathcal{R}_0 \\le 1$，则周期 $T = 0.0$。\n3. 如果 $\\mathcal{R}_0 > 1$，则继续计算平衡点和稳定性。\n4. 计算 $I^* = \\frac{(\\nu + \\mu_a) N (1 - 1/\\mathcal{R}_0)}{\\gamma + \\nu + \\mu_a}$。\n5. 定义一个辅助变量 $X = \\frac{\\beta I^*}{N}$。\n6. 计算迹 $\\text{Tr}(J) = -(\\nu+\\mu_a) - X$ 和行列式 $\\det(J) = X(\\gamma+\\nu+\\mu_a)$。\n7. 计算判别式 $\\Delta = \\text{Tr}(J)^2 - 4\\det(J)$。\n8. 如果 $\\Delta \\ge 0$，周期 $T=0.0$。\n9. 如果 $\\Delta < 0$，计算角频率 $\\omega = \\frac{\\sqrt{-\\Delta}}{2}$ 和周期 $T = \\frac{2\\pi}{\\omega}$。\n10. 将最终周期 $T$ 四舍五入到 $3$ 位小数。\n\n这个过程是稳健的，并且直接遵循问题陈述。我们注意到了案例 2 的注释“预期为非振荡”，但计算必须严格遵守推导出的数学条件。如果满足振荡条件，将会计算出一个非零周期。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_period(N, beta, gamma, nu, mu_a):\n    \"\"\"\n    Calculates the oscillation period for the given SIR model with immune escape.\n\n    Args:\n        N (float): Total population size.\n        beta (float): Transmission rate (per year).\n        gamma (float): Recovery rate (per year).\n        nu (float): Per capita birth and death rate (per year).\n        mu_a (float): Rate of immune escape (per year).\n\n    Returns:\n        float: The oscillation period in years. Returns 0.0 if no oscillations\n               or if the endemic equilibrium does not exist.\n    \"\"\"\n    # The combination gamma + nu appears frequently.\n    gamma_nu = gamma + nu\n\n    # Check for existence of the endemic equilibrium, which requires R0 > 1.\n    if beta = gamma_nu:\n        return 0.0\n\n    R0 = beta / gamma_nu\n    \n    # Calculate the endemic equilibrium for the number of infectious individuals, I*.\n    # Using the expression derived from the model equations.\n    # N = S + I + R, dI/dt = beta*S*I/N - (gamma+nu)*I = 0 => S* = N*(gamma+nu)/beta\n    # dS/dt = nu*N - beta*S*I/N + mu_a*R - nu*S = 0\n    # I* = (nu + mu_a) * N * (1 - 1/R0) / (gamma + nu + mu_a)\n    I_star_num = (nu + mu_a) * N * (1.0 - 1.0 / R0)\n    I_star_den = gamma + nu + mu_a\n    \n    # It's possible for the denominator to be zero in an unphysical limit, but not for these cases.\n    if I_star_den == 0:\n        return 0.0 # Avoid division by zero\n    \n    I_star = I_star_num / I_star_den\n    \n    # Construct the Jacobian matrix elements at the equilibrium (S*, I*).\n    # The reduced system is in (S, I).\n    # J = [[- (nu + mu_a) - beta*I*/N,   - (gamma + nu + mu_a)],\n    #      [beta*I*/N,                   0                  ]]\n    \n    # For convenience, let X = beta * I* / N\n    X = beta * I_star / N\n\n    # The trace and determinant of the Jacobian matrix.\n    tr_J = - (nu + mu_a) - X\n    det_J = X * (gamma + nu + mu_a)\n    \n    # The eigenvalues are complex (implying oscillations) if the discriminant is negative.\n    discriminant = tr_J**2 - 4.0 * det_J\n    \n    if discriminant >= 0:\n        # Real eigenvalues, no oscillations.\n        return 0.0\n    else:\n        # Complex eigenvalues, oscillations occur.\n        # Eigenvalues are lambda = (tr_J / 2) +/- i * omega\n        # where omega is the angular frequency.\n        omega = np.sqrt(-discriminant) / 2.0\n        \n        # The period of oscillation T = 2*pi / omega.\n        if omega > 0:\n            period = 2.0 * np.pi / omega\n            return period\n        else:\n             # Should not happen if discriminant is negative.\n            return 0.0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (N, beta, gamma, nu, mu_a)\n    test_cases = [\n        (1e6, 140.0, 121.0, 1.0/70.0, 0.5),\n        (1e6, 121.1, 121.0, 1.0/70.0, 0.0),\n        (1e6, 200.0, 121.0, 1.0/70.0, 5.0),\n        (1e6, 60.0, 52.0, 1.0/70.0, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        period = calculate_period(*case)\n        results.append(period)\n\n    # Format the results to 3 decimal places and print in the specified format.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4657414"}]}