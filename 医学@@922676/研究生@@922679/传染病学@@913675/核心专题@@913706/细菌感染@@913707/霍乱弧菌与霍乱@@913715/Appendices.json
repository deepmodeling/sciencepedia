{"hands_on_practices": [{"introduction": "有效管理重症霍乱的关键在于快速而精准的液体复苏。本练习模拟了一个关键的临床情境，指导您将患者的脱水评估和持续液体流失情况，转化为定量的静脉输液速率。掌握这项计算 [@problem_id:4686881] 是在霍乱治疗环境中直接影响患者生存状况的一项基本技能。", "problem": "一名$28$岁的成年人因大量水样腹泻就诊于霍乱治疗中心，其症状与霍乱弧菌（Vibrio cholerae）感染相符。家属报告该患者病前通常体重为$62$公斤。经检查，根据临床体征估计患者有$9\\%$的脱水。在治疗中心观察期间，护士测量到持续的粪便排出量稳定在每小时$400$毫升。该中心的治疗方案目标是在最初的$3$小时内均匀补充全部估计的液体亏损，同时补充持续的腹泻失水量，以恢复总体液。在初期复苏阶段，忽略不显性失水。\n\n使用以下基本依据：\n- 脱水百分比定义为失水量占病前体重的比例。\n- 水的密度约为每升$1$公斤，因此$1$公斤的水分流失相当于$1$升的液体亏损。\n- 根据体液的质量守恒原理，在特定时间窗口内纠正亏损并同时补充持续流失量所需的输液速率，等于亏损补充速率与持续流失速率之和。\n\n计算为达到上述目标所需的初始静脉输液速率。请以毫升/小时（mL/h）为单位表示您的最终答案，并将其四舍五入至三位有效数字。", "solution": "在进行求解之前，对问题进行验证。\n\n### 第1步：提取已知条件\n- 病前体重：$62$ 公斤\n- 估计脱水：$9\\%$\n- 持续粪便排出速率：每小时$400$ 毫升\n- 亏损补充时间窗口：$3$ 小时\n- 复苏方案：在最初$3$小时内均匀补充全部液体亏损，同时补充持续的流失量。\n- 定义：脱水百分比是失水量占病前体重的比例。\n- 等价关系：$1$公斤的水分流失相当于$1$升的液体亏损。\n- 指导原则：所需输液速率 = 亏损补充速率 + 持续流失速率。\n- 要求：以毫升/小时为单位表示最终答案，并四舍五入至三位有效数字。\n\n### 第2步：使用提取的已知条件进行验证\n该问题在科学上基于流体动力学和医学生理学原理，并应用于霍乱等疾病的临床复苏。所提供的数据（患者体重、脱水程度、粪便排出量）对于一例重症病例在临床上是合理的。该问题提法恰当，提供了所有必要的信息、定义和明确的目标。语言客观且无歧义。该问题是将质量守恒原理直接应用于一个真实世界场景，可以进行数学形式化，并能得出一个唯一的解。不存在矛盾，且问题提法并非不当或过于简单。\n\n### 第3步：结论与行动\n问题被判定为**有效**。将进行求解。\n\n解答通过计算所需的总静脉输液速率来确定，该速率是两个部分之和：补充现有液体亏损所需的速率，以及补充持续液体流失所需的速率。\n\n设 $R_{\\text{total}}$ 为总输液速率。根据所提供的原则：\n$$R_{\\text{total}} = R_{\\text{deficit}} + R_{\\text{ongoing}}$$\n其中 $R_{\\text{deficit}}$ 是为纠正亏损的输液速率，而 $R_{\\text{ongoing}}$ 是为补充持续流失的速率。\n\n首先，我们计算总液体亏损量 $V_{\\text{deficit}}$。\n问题陈述，脱水百分比 $D_{\\%}$ 是失水量占病前体重 $W_{\\text{pre}}$ 的比例。\n已知：\n- $W_{\\text{pre}} = 62 \\text{ kg}$\n- $D_{\\%} = 9\\% = 0.09$\n\n损失的水分质量 $M_{\\text{loss}}$ 为：\n$$M_{\\text{loss}} = D_{\\%} \\times W_{\\text{pre}}$$\n$$M_{\\text{loss}} = 0.09 \\times 62 \\text{ kg} = 5.58 \\text{ kg}$$\n\n问题陈述，$1$公斤的水分流失相当于$1$升的液体亏损。因此，液体亏损的体积为：\n$$V_{\\text{deficit}} = 5.58 \\text{ L}$$\n\n接下来，我们计算补充此亏损所需的速率 $R_{\\text{deficit}}$。\n治疗方案要求在时间段 $T_{\\text{replace}}$ 内均匀补充全部亏损量 $V_{\\text{deficit}}$。\n已知：\n- $T_{\\text{replace}} = 3 \\text{ 小时}$\n\n亏损补充速率为：\n$$R_{\\text{deficit}} = \\frac{V_{\\text{deficit}}}{T_{\\text{replace}}}$$\n$$R_{\\text{deficit}} = \\frac{5.58 \\text{ L}}{3 \\text{ h}} = 1.86 \\frac{\\text{L}}{\\text{h}}$$\n\n为保持单位一致，我们将此速率转换为毫升/小时。由于 $1 \\text{ L} = 1000 \\text{ mL}$：\n$$R_{\\text{deficit}} = 1.86 \\frac{\\text{L}}{\\text{h}} \\times 1000 \\frac{\\text{mL}}{\\text{L}} = 1860 \\frac{\\text{mL}}{\\text{h}}$$\n\n补充持续流失的速率 $R_{\\text{ongoing}}$，在问题中已直接给出，即稳定的粪便排出速率：\n$$R_{\\text{ongoing}} = 400 \\frac{\\text{mL}}{\\text{h}}$$\n\n最后，我们通过将两个分速率相加来计算总的初始输液速率 $R_{\\text{total}}$：\n$$R_{\\text{total}} = R_{\\text{deficit}} + R_{\\text{ongoing}}$$\n$$R_{\\text{total}} = 1860 \\frac{\\text{mL}}{\\text{h}} + 400 \\frac{\\text{mL}}{\\text{h}} = 2260 \\frac{\\text{mL}}{\\text{h}}$$\n\n问题要求答案四舍五入至三位有效数字。数字$2260$可以写成科学记数法$2.26 \\times 10^3$。数字$2$、$2$和$6$是有效数字。因此，$2260$已经具有三位有效数字。\n所需的初始静脉输液速率为 $2260 \\text{ mL/h}$。", "answer": "$$\\boxed{2260}$$", "id": "4686881"}, {"introduction": "尽管静脉输液对于严重脱水至关重要，但口服补液盐（ORS）是治疗大多数霍乱病例的基石。本练习超越了简单的容量补充，旨在探索补液疗法背后的生物化学精确性。通过计算粪便中钠和碳酸氢盐的具体流失量，并确定所需的ORS体积 [@problem_id:4686869]，您将更深入地理解溶质守恒原理以及拯救生命的ORS配方设计。", "problem": "一名因霍乱弧菌感染而患有严重水样腹泻的住院成人，在过去 $6$ 小时内使用床旁离子选择性系统对其收集的粪便样本进行了定量和分析。收集物被分装在三个密封袋中，测得的体积和溶质浓度如下：\n- 袋 $1$：体积 $1.4$ 升，粪便钠浓度 $110$ mmol/L，粪便碳酸氢盐（以碳酸氢盐当量衡量）浓度 $30$ mmol/L。\n- 袋 $2$：体积 $1.0$ 升，粪便钠浓度 $95$ mmol/L，粪便碳酸氢盐浓度 $28$ mmol/L。\n- 袋 $3$：体积 $1.2$ 升，粪便钠浓度 $105$ mmol/L，粪便碳酸氢盐浓度 $32$ mmol/L。\n\n现有世界卫生组织 (WHO) 的低渗口服补液盐 (ORS)，其每升含钠 $75$ mmol 和柠檬酸三钠 $10$ mmol。假设每毫摩尔柠檬酸盐在体内代谢可产生一毫摩尔碳酸氢盐当量。同时假设钠-葡萄糖协同转运功能完好，因此在此期间 ORS 的吸收可视为完全有效。\n\n假设在接下来的 $4$ 小时内，粪便的体积和成分将与过去 $6$ 小时内观察到的体积加权平均速率和成分相匹配。忽略所有其他液体获得或丢失（例如，肾脏排泄、不显性失水或静脉输液）。使用溶质质量守恒定律，确定在接下来的 $4$ 小时内必须给予的 ORS 最小体积（以升为单位），以便仅通过 ORS 就能完全补充钠和碳酸氢盐当量的损失。将最终答案四舍五入至三位有效数字，并以升为单位表示最终体积。", "solution": "首先对问题进行验证，以确保其具有科学依据、内容独立完整且提法恰当。该问题描述了一个为霍乱患者计算液体补充量的临床情景，这是一个属于医学微生物学和生理学范畴的课题。所提供的数据，包括粪便体积、电解质浓度以及口服补液盐 (ORS) 的成分，均与已有的医学文献相符。其基本原理，如溶质守恒和柠檬酸盐代谢转化为碳酸氢盐，都具有科学合理性。该问题定义明确，提供了计算出唯一解所需的所有必要信息。因此，该问题被认为是有效的，有必要给出完整解答。\n\n目标是确定在 $4$ 小时内所需的 ORS 最小体积（记为 $V_{ORS}$），以补充钠 ($Na^+$) 和碳酸氢盐当量 ($HCO_3^-$) 的预计损失量。\n\n首先，我们计算在最初的 $6$ 小时观察期内每种溶质的总损失量。观察期为 $T_{obs} = 6 \\text{ h}$。三个收集袋的数据如下：\n- 袋 $1$：$V_1 = 1.4 \\text{ L}$，$[Na^+]_1 = 110 \\text{ mmol/L}$，$[HCO_3^-]_1 = 30 \\text{ mmol/L}$\n- 袋 $2$：$V_2 = 1.0 \\text{ L}$，$[Na^+]_2 = 95 \\text{ mmol/L}$，$[HCO_3^-]_2 = 28 \\text{ mmol/L}$\n- 袋 $3$：$V_3 = 1.2 \\text{ L}$，$[Na^+]_3 = 105 \\text{ mmol/L}$，$[HCO_3^-]_3 = 32 \\text{ mmol/L}$\n\n粪便总损失体积 $V_{total}$ 是三个袋子体积的总和：\n$$V_{total} = V_1 + V_2 + V_3 = 1.4 \\text{ L} + 1.0 \\text{ L} + 1.2 \\text{ L} = 3.6 \\text{ L}$$\n\n钠的总损失量 $M_{Na, total}$ 通过将每个袋子的体积和浓度相乘后再求和来计算：\n$$M_{Na, total} = V_1 [Na^+]_1 + V_2 [Na^+]_2 + V_3 [Na^+]_3$$\n$$M_{Na, total} = (1.4 \\text{ L} \\times 110 \\frac{\\text{mmol}}{\\text{L}}) + (1.0 \\text{ L} \\times 95 \\frac{\\text{mmol}}{\\text{L}}) + (1.2 \\text{ L} \\times 105 \\frac{\\text{mmol}}{\\text{L}})$$\n$$M_{Na, total} = 154 \\text{ mmol} + 95 \\text{ mmol} + 126 \\text{ mmol} = 375 \\text{ mmol}$$\n\n类似地，碳酸氢盐当量的总损失量 $M_{HCO3, total}$ 为：\n$$M_{HCO3, total} = V_1 [HCO_3^-]_1 + V_2 [HCO_3^-]_2 + V_3 [HCO_3^-]_3$$\n$$M_{HCO3, total} = (1.4 \\text{ L} \\times 30 \\frac{\\text{mmol}}{\\text{L}}) + (1.0 \\text{ L} \\times 28 \\frac{\\text{mmol}}{\\text{L}}) + (1.2 \\text{ L} \\times 32 \\frac{\\text{mmol}}{\\text{L}})$$\n$$M_{HCO3, total} = 42 \\text{ mmol} + 28 \\text{ mmol} + 38.4 \\text{ mmol} = 108.4 \\text{ mmol}$$\n\n接下来，我们确定在这 $6$ 小时内的平均损失速率。\n钠的平均损失速率 $R_{Na}$ 为：\n$$R_{Na} = \\frac{M_{Na, total}}{T_{obs}} = \\frac{375 \\text{ mmol}}{6 \\text{ h}} = 62.5 \\frac{\\text{mmol}}{\\text{h}}$$\n碳酸氢盐的平均损失速率 $R_{HCO3}$ 为：\n$$R_{HCO3} = \\frac{M_{HCO3, total}}{T_{obs}} = \\frac{108.4 \\text{ mmol}}{6 \\text{ h}}$$\n\n问题陈述，在接下来的 $4$ 小时（$T_{pred} = 4 \\text{ h}$）内，粪便损失将与这些平均速率相匹配。现在我们可以预测这个未来时期的总损失量。\n预计的钠损失量 $M_{Na, pred}$ 为：\n$$M_{Na, pred} = R_{Na} \\times T_{pred} = 62.5 \\frac{\\text{mmol}}{\\text{h}} \\times 4 \\text{ h} = 250 \\text{ mmol}$$\n预计的碳酸氢盐损失量 $M_{HCO3, pred}$ 为：\n$$M_{HCO3, pred} = R_{HCO3} \\times T_{pred} = \\frac{108.4 \\text{ mmol}}{6 \\text{ h}} \\times 4 \\text{ h} = \\frac{2}{3} \\times 108.4 \\text{ mmol} = \\frac{216.8}{3} \\text{ mmol}$$\n\n现在，我们考虑 WHO 低渗口服补液盐的成分。它提供：\n- 钠浓度：$[Na^+]_{ORS} = 75 \\text{ mmol/L}$\n- 柠檬酸三钠浓度：$[Citrate]_{ORS} = 10 \\text{ mmol/L}$\n\n根据问题描述，每毫摩尔柠檬酸盐代谢为一毫摩尔碳酸氢盐。因此，ORS 的有效碳酸氢盐当量浓度为：\n$$[HCO_3^-]_{ORS} = [Citrate]_{ORS} = 10 \\text{ mmol/L}$$\n\n设 $V_{ORS}$ 为待给予的 ORS 体积。为了完全补充钠的损失，ORS 提供的钠量必须等于预计的损失量：\n$$V_{ORS, Na} \\times [Na^+]_{ORS} = M_{Na, pred}$$\n补充钠所需的 ORS 体积为：\n$$V_{ORS, Na} = \\frac{M_{Na, pred}}{[Na^+]_{ORS}} = \\frac{250 \\text{ mmol}}{75 \\text{ mmol/L}} = \\frac{10}{3} \\text{ L}$$\n\n为了完全补充碳酸氢盐的损失，ORS 提供的碳酸氢盐当量必须等于预计的损失量：\n$$V_{ORS, HCO3} \\times [HCO_3^-]_{ORS} = M_{HCO3, pred}$$\n补充碳酸氢盐所需的 ORS 体积为：\n$$V_{ORS, HCO3} = \\frac{M_{HCO3, pred}}{[HCO_3^-]_{ORS}} = \\frac{(216.8/3) \\text{ mmol}}{10 \\text{ mmol/L}} = \\frac{216.8}{30} \\text{ L} = \\frac{21.68}{3} \\text{ L}$$\n\n我们需要给予单一剂量的 ORS 体积 $V_{ORS}$，该体积要足以补充*两种*溶质。因此，所需的最小体积必须是计算出的两个体积中较大的一个：\n$$V_{ORS, min} = \\max(V_{ORS, Na}, V_{ORS, HCO3})$$\n$$V_{ORS, min} = \\max\\left(\\frac{10}{3} \\text{ L}, \\frac{21.68}{3} \\text{ L}\\right)$$\n从数值上看，$V_{ORS, Na} \\approx 3.333 \\text{ L}$ 且 $V_{ORS, HCO3} \\approx 7.227 \\text{ L}$。\n显然，所需体积由碳酸氢盐的损失量决定。\n$$V_{ORS, min} = \\frac{21.68}{3} \\text{ L} \\approx 7.22666... \\text{ L}$$\n\n问题要求将最终答案四舍五入至三位有效数字。\n$$V_{ORS, min} \\approx 7.23 \\text{ L}$$\n给予这个体积将正好补充碳酸氢盐当量的亏空，同时提供过量的钠，从而满足完全补充两者的条件。", "answer": "$$\n\\boxed{7.23}\n$$", "id": "4686869"}, {"introduction": "将我们的视角从个体患者转向全球大流行，本练习介绍了一种现代微生物流行病学的核心方法：分子钟分析。您将利用基因数据和采样日期来重建霍乱弧菌的传播过程，这项技术被用于实时追踪病原体的演化和传播动态。本练习 [@problem_id:4686932] 提供了亲手实践的机会，通过实施一个简化的系统发育模型，从序列数据中估算突变率、追溯疫情起源时间并识别流行波次。", "problem": "您正在使用简化的星状系统发育假设和严格分子钟来模拟第七次大流行期间霍乱弧菌（Vibrio cholerae）的时间传播。基本依据是分子钟原理：在严格分子钟下，每个位点的预期替换会随着时间的推移，在每个谱系中以恒定速率累积。在一个根植于未知日历年份 $t_r$（根时间）的星状系统发育中，每个在年份 $t_i$ 采样的叶尖 $i$ 都直接从根分化而来，任意两个叶尖 $i$ 和 $j$ 之间的预期单位点分歧等于它们各自的叶尖到根的替换距离（以单位点替换数衡量）之和。对于短时间和一组可变位点，观测到的叶尖 $i$ 和 $j$ 之间的汉明分数 $p_{ij}$ 可用作预期单位点分歧的无偏估计量。\n\n从这些原则出发，设计并实现一个程序，该程序能够：\n- 根据观测到的成对汉明分数 $p_{ij}$ 和采样时间 $t_i$，估计单位点、年突变率 $\\mu$ 和根日历年份 $t_r$。\n- 通过计算以单位点替换数度量的叶尖分支长度 $b_i$ 来重建一个带时间的星状系统发育，其中 $b_i$ 是从根到叶尖 $i$ 的谱系上预期的累积量。\n- 通过使用简单的时间间隙规则对采样时间进行聚类来推断流行病的波数：将采样时间按升序排序后，当连续时间之间的间隙严格大于阈值 $g$ 时，即开始一个新波次。\n\n在数学上，所有计算必须用以下各项表示：\n- 观测到的汉明分数 $p_{ij}$，计算方法为汉明距离除以序列长度 $L$。\n- 采样时间 $t_i$，以日历年为单位（单位：年）。\n- 对与严格分子钟、星状模型一致的线性关系进行最小二乘拟合，以获得 $\\mu$（单位：单位点/年）和 $t_r$（单位：年）。您的推导必须基于上述原理，不得依赖任何提供给您的快捷公式。\n\n您的程序必须实现以下测试套件，涵盖一般情况、边界条件和边缘情况。在所有情况下，序列长度为 $L=50$ 个位点，这些位点选自适合于第七次大流行期间霍乱弧菌短期演化的可变位点组。\n\n测试用例 1（一般情况：多波次）：\n- 序列（每个长度为 50）： \n  - $s_1$：从全为 A 的基线上突变位置索引 $\\{0\\}$。\n  - $s_2$：突变位置索引 $\\{1,2\\}$。\n  - $s_3$：突变位置索引 $\\{3,4,5\\}$。\n  - $s_4$：突变位置索引 $\\{6,7,8,9,10\\}$。\n  - $s_5$：突变位置索引 $\\{11,12,13,14,15,16\\}$。\n  所有突变索引集两两不相交，以确保 $p_{ij}$ 的星状可加性。\n- 采样时间（单位：年）：$[1962.0,1963.0,1964.0,1965.5,1967.0]$。\n- 波次间隙阈值 $g$（单位：年）：$1.2$。\n\n测试用例 2（边界情况：重复的采样时间和与根相同的叶尖）：\n- 序列（每个长度为 50）：\n  - $s_1$：无突变的基线序列。\n  - $s_2$：突变位置索引 $\\{0\\}$。\n  - $s_3$：突变位置索引 $\\{1\\}$。\n- 采样时间（单位：年）：$[1961.5,1962.0,1962.0]$。\n- 波次间隙阈值 $g$（单位：年）：$0.2$。\n\n测试用例 3（边缘情况：大的时间间隙，多个不同的波次）：\n- 序列（每个长度为 50）：\n  - $s_1$：突变位置索引 $\\{0,1\\}$。\n  - $s_2$：突变位置索引 $\\{2,3,4,5\\}$。\n  - $s_3$：突变位置索引 $\\{6,7,8,9\\}$。\n  - $s_4$：突变位置索引 $\\{10,11,12,13,14,15,16,17\\}$。\n  - $s_5$：突变位置索引 $\\{18,19,20,21,22,23,24,25,26,27,28,29,30,31\\}$。\n  所有突变索引集两两不相交。\n- 采样时间（单位：年）：$[1970.0,1976.0,1976.1,1985.5,1998.0]$。\n- 波次间隙阈值 $g$（单位：年）：$5.0$。\n\n实现细节：\n- 对于每个无序对 $(i,j)$，计算 $p_{ij}$，即汉明距离除以 $L$。\n- 使用基于严格分子钟、星状推导的最小二乘法来估计 $\\mu$（单位：单位点/年）和 $t_r$（单位：年）。\n- 计算分支长度 $b_i$（单位：单位点替换数），即在估计的 $\\mu$ 下从 $t_r$ 到 $t_i$ 的预期累积量。\n- 通过对采样时间进行排序并计算严格大于 $g$ 的间隙数量，然后加一来推断波次计数。\n\n要求的输出和单位：\n- 对于每个测试用例，生成一个包含三个元素的列表：估计的突变率 $\\mu$（单位：单位点/年）四舍五入到 6 位小数，估计的根日历年份 $t_r$（单位：年）四舍五入到 1 位小数，以及推断的波次数（整数）。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身也是相同格式的列表。例如，输出应类似于 $[[\\mu_1,t_{r,1},w_1],[\\mu_2,t_{r,2},w_2],[\\mu_3,t_{r,3},w_3]]$，并应用指定的四舍五入和单位。\n\n不允许用户输入；所有数据必须从上述测试套件中硬编码。程序必须仅依赖 Python 标准库和允许的库。时间量以年表示，突变率以单位点/年表示。不使用百分比；所有分数量必须是小数。", "solution": "该问题要求在简化模型下，根据系统发育数据估计单位点年突变率 $\\mu$、根日历年份 $t_r$ 和流行病波数 $w$。该模型假设了严格分子钟和星状系统发育。解决方案从这些第一性原理推导而来，并实现以处理给定的测试用例。\n\n### 步骤 1：线性模型的推导\n\n解决方案的关键在于在观测数据（采样时间 $t_i$ 和汉明分数 $p_{ij}$）与模型参数（$\\mu, t_r$）之间建立线性关系。\n\n1.  **严格分子钟和分支长度**：严格分子钟假说认为，替换以恒定速率 $\\mu$（单位点/年）累积。对于星状系统发育，每个采样序列（叶尖 $i$）从位于根时间 $t_r$ 的共同祖先独立演化而来。在年份 $t_i$ 采样的叶尖 $i$ 的演化时间跨度为 $\\Delta t_i = t_i - t_r$。因此，沿着该谱系的单位点预期替换数（即分支长度 $b_i$）与此时长成正比：\n    $$b_i = \\mu (t_i - t_r)$$\n\n2.  **星状系统发育中的成对分歧**：在星状拓扑中，从叶尖 $i$ 到叶尖 $j$ 的演化路径是从 $i$ 到根，然后再从根到 $j$。叶尖 $i$ 和 $j$ 之间的总预期单位点分歧 $d_{ij}$ 是它们各自从根到叶尖的分支长度之和：\n    $$d_{ij} = b_i + b_j$$\n\n3.  **将分歧与时间关联**：将时钟模型中的 $b_i$ 和 $b_j$ 表达式代入分歧方程，得到：\n    $$d_{ij} = \\mu(t_i - t_r) + \\mu(t_j - t_r)$$\n    $$d_{ij} = \\mu(t_i + t_j) - 2\\mu t_r$$\n\n4.  **可观测量**：问题指出，观测到的序列 $s_i$ 和 $s_j$ 之间的汉明分数 $p_{ij}$ 是预期分歧 $d_{ij}$ 的无偏估计量。汉明分数定义为汉明距离 $H(s_i, s_j)$ 除以序列长度 $L$。因此，我们可以写出：\n    $$p_{ij} \\approx \\mu(t_i + t_j) - 2\\mu t_r$$\n\n该方程具有直线形式 $Y = mX + c$，其中：\n-   因变量是 $Y = p_{ij}$。\n-   自变量是 $X = t_i + t_j$。\n-   斜率是 $m = \\mu$。\n-   y轴截距是 $c = -2\\mu t_r$。\n\n### 步骤 2：使用最小二乘回归进行参数估计\n\n我们可以使用线性最小二乘回归从数据中估计斜率 $m$ 和截距 $c$。回归数据由一组点 $(X_{ij}, Y_{ij})$ 组成，这些点对应所有唯一的样本对 $(i, j)$（其中 $i  j$）。\n\n-   $X_{ij} = t_i + t_j$\n-   $Y_{ij} = p_{ij} = H(s_i, s_j) / L$。问题指明不同序列的突变集是两两不相交的。如果 $m_k$ 是序列 $s_k$ 相对于祖先序列的突变数，则 $s_i$ 和 $s_j$ 之间的汉明距离就是 $H(s_i, s_j) = m_i + m_j$。因此，$Y_{ij} = (m_i + m_j) / L$，其中 $L=50$。\n\n通过对这组 $(X_{ij}, Y_{ij})$ 点进行线性回归，我们得到斜率 $\\hat{m}$ 和截距 $\\hat{c}$ 的估计值。然后，模型参数可恢复如下：\n-   突变率：$\\hat{\\mu} = \\hat{m}$\n-   根时间：从 $\\hat{c} = -2\\hat{\\mu}\\hat{t}_r$，我们求解 $\\hat{t}_r$：\n    $$\\hat{t}_r = -\\frac{\\hat{c}}{2\\hat{\\mu}}$$\n\n此过程应用于每个测试用例。\n\n### 步骤 3：流行病波数的推断\n\n流行病波数是使用一个简单的时间间隙规则推断出来的。步骤如下：\n1.  将采样时间向量 $[t_1, t_2, \\dots, t_n]$ 按升序排序。\n2.  计算连续排序样本之间的时间间隙：$\\Delta t_k = t_{k+1, \\text{sorted}} - t_{k, \\text{sorted}}$。\n3.  计算严格大于给定阈值 $g$ 的间隙数量。设其为 $N_{gaps}$。\n4.  那么，波数 $w$ 即为 $w = N_{gaps} + 1$。每个大的间隙表示波次之间的中断。\n\n### 步骤 4：实现与计算\n\n对于每个测试用例，程序将执行以下逻辑：\n1.  为每个序列定义突变数 $m_i$ 和采样时间 $t_i$。序列长度为 $L=50$。\n2.  生成所有唯一的索引对 $(i, j)$，其中 $i  j$。\n3.  对于每对，计算 $X_{ij} = t_i + t_j$ 和 $Y_{ij} = (m_i + m_j) / L$。\n4.  对收集到的 $(X_{ij}, Y_{ij})$ 对使用次数为 1 的 `numpy.polyfit` 来找到斜率 $\\hat{m}$ 和截距 $\\hat{c}$。\n5.  计算 $\\hat{\\mu} = \\hat{m}$ 和 $\\hat{t}_r = -\\hat{c} / (2\\hat{m})$。\n6.  将波次计数算法应用于采样时间 $t_i$ 和给定的阈值 $g$。\n7.  将每个用例的最终结果格式化为列表 $[\\hat{\\mu}, \\hat{t}_r, w]$，其中 $\\hat{\\mu}$ 四舍五入到 6 位小数，$\\hat{t}_r$ 四舍五入到 1 位小数。最终输出将所有测试用例的结果汇总到一个列表的列表中。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the phylogenetic estimation problem for all test cases.\n    \"\"\"\n    # Test Case 1: General case\n    test_case_1 = {\n        \"mutations\": [1, 2, 3, 5, 6],\n        \"times\": [1962.0, 1963.0, 1964.0, 1965.5, 1967.0],\n        \"g\": 1.2,\n        \"L\": 50\n    }\n\n    # Test Case 2: Boundary case (duplicate times, tip at root)\n    test_case_2 = {\n        \"mutations\": [0, 1, 1],\n        \"times\": [1961.5, 1962.0, 1962.0],\n        \"g\": 0.2,\n        \"L\": 50\n    }\n\n    # Test Case 3: Edge case (large temporal gaps)\n    test_case_3 = {\n        \"mutations\": [2, 4, 4, 8, 14],\n        \"times\": [1970.0, 1976.0, 1976.1, 1985.5, 1998.0],\n        \"g\": 5.0,\n        \"L\": 50\n    }\n\n    test_cases = [test_case_1, test_case_2, test_case_3]\n    all_results = []\n\n    for case in test_cases:\n        result = process_case(\n            case[\"mutations\"],\n            case[\"times\"],\n            case[\"g\"],\n            case[\"L\"]\n        )\n        all_results.append(result)\n    \n    # Format the final output string to match the required format \"[[r1,r2,r3],[...]]\"\n    # This avoids spaces that str(list_of_lists) would introduce.\n    formatted_results = []\n    for mu, tr, w in all_results:\n        formatted_results.append(f\"[{mu:.6f},{tr:.1f},{w}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef process_case(mutations, times, g, L):\n    \"\"\"\n    Processes a single test case to estimate mu, t_r, and wave count.\n\n    Args:\n        mutations (list of int): Number of mutations for each sequence.\n        times (list of float): Sampling times for each sequence.\n        g (float): Wave gap threshold.\n        L (int): Sequence length.\n\n    Returns:\n        list: A list containing [mu, t_r, wave_count].\n    \"\"\"\n    n_samples = len(times)\n    indices = range(n_samples)\n    \n    x_data = [] # Stores t_i + t_j\n    y_data = [] # Stores p_ij = (m_i + m_j) / L\n\n    # Generate all unique pairs of samples (i, j) with i  j\n    for i, j in itertools.combinations(indices, 2):\n        ti, tj = times[i], times[j]\n        mi, mj = mutations[i], mutations[j]\n        \n        # This is X = t_i + t_j in the linear model\n        x_val = ti + tj\n        # This is Y = p_ij in the linear model\n        y_val = (mi + mj) / L\n        \n        x_data.append(x_val)\n        y_data.append(y_val)\n\n    # Perform linear least-squares regression: y = m*x + c\n    # Using numpy.polyfit, which returns [slope, intercept]\n    if len(x_data)  1:\n        # Check for degeneracy: if all x_data points are the same, regression is ill-defined.\n        # This case is not expected with the given problem data but is good practice.\n        if np.all(np.array(x_data) == x_data[0]):\n            mu_est = 0.0 # No temporal signal, slope is zero\n            # In this case t_r cannot be determined from the intercept.\n            # However, the problem's data avoids this.\n            tr_est = 0.0\n        else:\n            m, c = np.polyfit(x_data, y_data, 1)\n            mu_est = m\n            # Handle the case where mu_est might be zero or near-zero\n            if abs(mu_est)  1e-12:\n                tr_est = -c / (2 * mu_est)\n            else:\n                # If slope is zero, root time is indeterminate.\n                # This scenario is not triggered by the test cases.\n                tr_est = 0.0\n    else:\n        # Not enough data points for regression\n        mu_est, tr_est = 0.0, 0.0\n\n    # Infer number of waves\n    sorted_times = sorted(times)\n    gaps = np.diff(sorted_times)\n    large_gaps_count = np.sum(gaps  g)\n    wave_count = int(large_gaps_count + 1)\n    \n    return [mu_est, tr_est, wave_count]\n\nsolve()\n\n```", "id": "4686932"}]}