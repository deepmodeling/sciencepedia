{"hands_on_practices": [{"introduction": "诊断测试的准确性在临床决策和公共卫生监测中至关重要。虽然灵敏度 ($Se$) 和特异度 ($Sp$) 是衡量测试内在性能的指标，但其在特定人群中的实际应用价值取决于阳性预测值 (PPV)——即测试结果为阳性时，个体确实患病的概率。这项练习 [@problem_id:4641480] 将引导您应用 Bayes' 定理，结合患病率 ($p$) 来推导和计算 PPV，这是解读诊断数据的一项基本技能。", "problem": "某个流行地区的一家转诊中心正在验证一种用于检测就诊的急性痢疾成年人中溶组织内阿米巴（Entamoeba histolytica）的粪便抗原酶免疫分析法（EIA）。在这个临床富集队列中，流行病学监测估计侵袭性溶组织内阿米巴感染的时点患病率为 $p=0.15$。与复合参考标准相比，该检测的灵敏度为 $Se=0.92$，特异度为 $Sp=0.95$。仅使用灵敏度、特异度、患病率、全概率定律和贝叶斯定理的核心定义，推导出阳性预测值（PPV）的表达式为 $P(D \\mid T^{+})$，其中 $D$ 表示真实感染，$T^{+}$ 表示抗原检测阳性，然后计算其在此亚群中的数值。将最终答案表示为精确分数。不要使用百分号。无需单位。", "solution": "该问题已经过验证，被认为是临床流行病学中一个有效的、有科学依据且表述清晰的问题。所有必要信息均已提供，目标明确。\n\n任务是推导阳性预测值 $PPV$ 的表达式，并计算其数值。阳性预测值是在检测结果为阳性的情况下，受试者患有该疾病的概率。这由条件概率 $P(D \\mid T^{+})$ 表示，其中 $D$ 代表患有疾病（真实感染）的事件，$T^{+}$ 代表检测结果为阳性的事件。\n\n给定的量是：\n1.  疾病的患病率，$P(D) = p = 0.15$。\n2.  检测的灵敏度，$Se = P(T^{+} \\mid D) = 0.92$。这是在受试者患有疾病的情况下，检测结果为阳性的概率。\n3.  检测的特异度，$Sp = P(T^{-} \\mid D^{c}) = 0.95$。这是在受试者未患有疾病的情况下，检测结果为阴性的概率，其中 $D^{c}$ 是 $D$ 的补集（未患病），$T^{-}$ 是检测结果为阴性的事件。\n\n推导始于贝叶斯定理，它定义了后验概率 $P(D \\mid T^{+})$：\n$$P(D \\mid T^{+}) = \\frac{P(T^{+} \\mid D) P(D)}{P(T^{+})}$$\n在此表达式中，我们已知 $P(T^{+} \\mid D)$（灵敏度，$Se$）和 $P(D)$（患病率，$p$）。分母中的项 $P(T^{+})$ 是人群中检测结果为阳性的总概率。此概率必须使用全概率定律计算。人群可以被划分为两个不相交的集合：患有疾病的受试者 ($D$) 和未患有疾病的受试者 ($D^{c}$)。\n\n根据全概率定律，$P(T^{+})$ 可以表示为：\n$$P(T^{+}) = P(T^{+} \\mid D) P(D) + P(T^{+} \\mid D^{c}) P(D^{c})$$\n我们需要确定右侧的各项。\n- $P(T^{+} \\mid D)$ 是灵敏度，$Se$。\n- $P(D)$ 是患病率，$p$。\n- $P(D^{c})$ 是不患病的概率，即 $1 - P(D) = 1 - p$。\n- $P(T^{+} \\mid D^{c})$ 是未患病受试者检测结果为阳性的概率，也称为假阳性率。这可以从特异度 $Sp$ 推导出来。由于对于未患病的受试者，检测结果只能是阳性 ($T^{+}$) 或阴性 ($T^{-}$)，概率之和为 $1$：\n$$P(T^{+} \\mid D^{c}) + P(T^{-} \\mid D^{c}) = 1$$\n因此，$P(T^{+} \\mid D^{c}) = 1 - P(T^{-} \\mid D^{c}) = 1 - Sp$。\n\n将这些定义代入 $P(T^{+})$ 的表达式中：\n$$P(T^{+}) = (Se \\cdot p) + ((1 - Sp) \\cdot (1 - p))$$\n\n现在我们将 $P(T^{+})$ 的这个展开形式代回 $P(D \\mid T^{+})$ 的贝叶斯定理公式中：\n$$P(D \\mid T^{+}) = \\frac{P(T^{+} \\mid D) P(D)}{(Se \\cdot p) + ((1 - Sp) \\cdot (1 - p))}$$\n使用符号表示，我们得到阳性预测值的最终推导表达式：\n$$PPV = P(D \\mid T^{+}) = \\frac{Se \\cdot p}{Se \\cdot p + (1 - Sp)(1 - p)}$$\n这就完成了所要求的推导。\n\n下一步是使用给定的数据计算数值：$p = 0.15$，$Se = 0.92$，$Sp = 0.95$。\n- $1 - p = 1 - 0.15 = 0.85$\n- $1 - Sp = 1 - 0.95 = 0.05$\n\n将这些值代入推导出的公式中：\n$$P(D \\mid T^{+}) = \\frac{0.92 \\cdot 0.15}{0.92 \\cdot 0.15 + (0.05) \\cdot (0.85)}$$\n计算乘积：\n- 分子：$0.92 \\cdot 0.15 = 0.138$\n- 分母第二项：$0.05 \\cdot 0.85 = 0.0425$\n\n将这些中间结果代回方程中：\n$$P(D \\mid T^{+}) = \\frac{0.138}{0.138 + 0.0425} = \\frac{0.138}{0.1805}$$\n\n为了将此结果表示为精确分数，我们可以通过将分子和分母同时乘以 $10000$ 来去掉小数：\n$$P(D \\mid T^{+}) = \\frac{0.138 \\times 10000}{0.1805 \\times 10000} = \\frac{1380}{1805}$$\n\n现在，我们通过求最大公约数来化简这个分数。两个数都可以被 $5$ 整除：\n$$1380 \\div 5 = 276$$\n$$1805 \\div 5 = 361$$\n所以分数化简为：\n$$P(D \\mid T^{+}) = \\frac{276}{361}$$\n为了检查这个分数是否可以进一步化简，我们可以求出分子和分母的质因数。分母是 $361 = 19^2$。我们检查分子 $276$ 是否能被 $19$ 整除。\n$$276 \\div 19 = 14.526...$$\n由于 $276$ 不能被 $19$ 整除，分数 $\\frac{276}{361}$ 是其最简形式。", "answer": "$$\\boxed{\\frac{276}{361}}$$", "id": "4641480"}, {"introduction": "在评估了单个测试结果的预测价值之后，我们进一步将这些概念应用于群体层面。流行病学家不仅关心个体诊断，更关注真实的疾病发生率 (incidence)，但诊断测试的不完美性，例如溶组织内阿米巴与非致病的 *E. dispar* 之间的交叉反应，会使观测数据产生偏差。这项实践 [@problem_id:4628273] 要求您建立一个数学模型来校正这种偏差，从有偏差的观测阳性率中推导出真实的疾病发生率，这一方法在流行病学监测中具有重要意义。", "problem": "一家乡村诊所使用粪便抗原捕获法对由溶组织内阿米巴（Entamoeba histolytica）引起的阿米巴结肠炎进行监测。显微镜检查无法可靠地区分溶组织内阿米巴（Entamoeba histolytica）和迪斯帕内阿米巴（Entamoeba dispar），而交叉反应可能会在感染了迪斯帕内阿米巴的个体中产生假阳性结果。该抗原捕获法在检测由溶组织内阿米巴引起的真正阿米巴结肠炎方面具有恒定的灵敏度$Se$和特异性$Sp$，这已经通过聚合酶链式反应（PCR）参考标准得到验证。\n\n在一个固定监测区间内接受监测的封闭队列中，每个人在该区间内接受一次检测，并记录下原始的检测阳性比例。设$r_{\\text{obs}}$表示在该区间内观察到的检测呈阳性的比例。设$I_{\\text{true}}$表示在该区间内由溶组织内阿米巴引起的阿米巴结肠炎的真实发病率（即，随机选择的队列成员在该区间内真正患有阿米巴结肠炎的概率，无论检测结果如何）。\n\n仅使用灵敏度、特异性和贝叶斯定理的定义，推导出以$r_{\\text{obs}}$、$Se$和$Sp$表示$I_{\\text{true}}$的闭式表达式。请清楚地说明您所做的任何假设。以单一解析表达式的形式提供最终答案。无需四舍五入。答案应表示为一个无量纲的比例。", "solution": "该问题陈述被评估为有效。它在科学上基于医学流行病学和微生物学的原理，在数学上是适定的，并使用了客观、明确的术语。这是一个可以形式化的问题，可以从所提供的信息中推导出唯一且有意义的解。\n\n目标是推导真实发病率$I_{\\text{true}}$的表达式，该表达式以观察到的阳性检测比例$r_{\\text{obs}}$、检测灵敏度$Se$和检测特异性$Sp$来表示。\n\n设$D$为从队列中随机选择的个体在监测区间内确实患有阿米巴结肠炎的事件。设$T^+$为该个体使用抗原捕获法检测呈阳性的事件。互补事件为$D^c$（无病）和$T^-$（检测阴性）。\n\n根据问题陈述，我们用概率来定义给定的量：\n- 真实发病率是患病的概率：$I_{\\text{true}} = P(D)$。\n- 观察到的阳性比例是检测呈阳性的概率：$r_{\\text{obs}} = P(T^+)$。\n- 灵敏度（$Se$）是在患病条件下检测呈阳性的条件概率：$Se = P(T^+ | D)$。\n- 特异性（$Sp$）是在无病条件下检测呈阴性的条件概率：$Sp = P(T^- | D^c)$。\n\n我们的推导将使用全概率定律，它是贝叶斯定理的一个基本组成部分。一个事件的总概率（在本例中，是阳性检测）可以通过将其在一组互斥且穷尽的事件（在本例中，是患病或不患病）上的条件概率相加来求得。\n\n检测呈阳性的概率$P(T^+)$可以表示为：\n$$P(T^+) = P(T^+ \\cap D) + P(T^+ \\cap D^c)$$\n使用条件概率的定义，$P(A \\cap B) = P(A|B)P(B)$，我们可以将其重写为：\n$$P(T^+) = P(T^+ | D)P(D) + P(T^+ | D^c)P(D^c)$$\n\n现在我们可以将已定义的项代入此方程。我们有$P(T^+) = r_{\\text{obs}}$，$P(D) = I_{\\text{true}}$，和$P(T^+ | D) = Se$。我们还必须使用给定信息来表示$P(D^c)$和$P(T^+ | D^c)$这两项。\n\n不患病的概率是患病概率的补集：\n$$P(D^c) = 1 - P(D) = 1 - I_{\\text{true}}$$\n\n$P(T^+ | D^c)$项是在无病条件下检测呈阳性的概率，即假阳性率。它可以从特异性$Sp$推导出来。由于一个无病的个体检测结果必然是阳性或阴性，因此概率之和必须为1：\n$$P(T^+ | D^c) + P(T^- | D^c) = 1$$\n代入$Sp = P(T^- | D^c)$，我们得到：\n$$P(T^+ | D^c) = 1 - Sp$$\n\n现在，我们将所有这些表达式代回到全概率定律方程中：\n$$r_{\\text{obs}} = (Se)(I_{\\text{true}}) + (1 - Sp)(1 - I_{\\text{true}})$$\n\n这个方程提供了观察量$r_{\\text{obs}}$与目标量$I_{\\text{true}}$之间的关系。下一步是代数求解$I_{\\text{true}}$。\n首先，我们展开方程的右边：\n$$r_{\\text{obs}} = Se \\cdot I_{\\text{true}} + 1 - Sp - (1 - Sp) \\cdot I_{\\text{true}}$$\n\n接下来，我们将所有包含$I_{\\text{true}}$的项收集到方程的一边：\n$$r_{\\text{obs}} - (1 - Sp) = Se \\cdot I_{\\text{true}} - (1 - Sp) \\cdot I_{\\text{true}}$$\n$$r_{\\text{obs}} - 1 + Sp = I_{\\text{true}} (Se - (1 - Sp))$$\n$$r_{\\text{obs}} + Sp - 1 = I_{\\text{true}} (Se + Sp - 1)$$\n\n最后，我们通过除以其系数来分离出$I_{\\text{true}}$：\n$$I_{\\text{true}} = \\frac{r_{\\text{obs}} + Sp - 1}{Se + Sp - 1}$$\n\n这就是所求的真实发病率的闭式表达式。这个公式在流行病学中通常被称为Rogan-Gladen估计量。\n\n要使此表达式有效且有意义，需要的主要假设是分母不为零，即$Se + Sp - 1 \\neq 0$。如果$Se + Sp = 1$，则该检测不提供信息（其阳性似然比为1），意味着其表现不优于随机猜测，因此无法从观察到的检测结果中确定真实发病率。问题的设定意味着这是一个有用的诊断测试，所以这个假设被默认为是满足的。", "answer": "$$\\boxed{\\frac{r_{\\text{obs}} + Sp - 1}{Se + Sp - 1}}$$", "id": "4628273"}, {"introduction": "本章的最后一个实践将视角从流行病学转向实验研究，探讨如何通过统计方法分析病原体的毒力。溶组织内阿米巴的半乳糖/N-乙酰-D-半乳糖胺 (Gal/GalNAc) 凝集素是其关键毒力因子之一，研究人员常通过比较野生型 (WT) 与基因沉默 (LS) 菌株在动物模型中的致病效果来验证其功能，其中生存时间是核心观测指标。这项高级练习 [@problem_id:4628274] 要求您运用 Kaplan-Meier 生存分析和对数秩检验 (log-rank test)，这是分析此类“事件发生时间”数据的标准生物统计学工具，对理解发病机制至关重要。", "problem": "您将获得来自感染了野生型 (WT) 与凝集素沉默 (LS) 溶组织内阿米巴 (Entamoeba histolytica) 菌株的动物队列的右删失生存数据。任务是使用基于第一性原理的非参数生存分析，严格分析两组之间的生存差异。\n\n请使用生存分析中的以下基本原理：\n\n- 生存函数 $S(t)$ 定义为非负的事件发生时间随机变量 $T$ 超过时间 $t$ 的概率，即 $S(t) = \\mathbb{P}(T > t)$。\n- 允许右删失，并假设其为非信息性的：如果一个观测值在时间 $t$ 被删失，它在时间 $t$ 之前都对风险集有贡献，但不会在时间 $t$ 直接确定一个事件的发生。\n- 在生存率相等的零假设下，两组的生存函数满足 $S_1(t) = S_2(t)$ 对所有 $t$ 成立，其中组 1 为 WT，组 2 为 LS。\n\n推导、实现并应用 Kaplan–Meier (KM) 分析来估计每组的生存函数，并计算中位生存时间，即满足估计生存函数 $S(t) \\le 0.5$ 的最小时间 $t$。然后，实现对数秩检验，以评估两组的生存经历是否存在差异，其基础是在 $S_1(t) = S_2(t)$ 对所有 $t$ 成立的零假设下，比较每个不同事件时间点的观测事件数和期望事件数。您必须正确处理并列的事件时间，并在每个事件时间点考虑风险集中的删失情况。如果因为估计的生存函数从未降至 $0.5$ 而导致中位生存时间未定义，则该中位生存时间输出为 $-1$。\n\n所有生存时间必须以天为单位处理，任何报告的时间都应以天为单位表示。对数秩检验统计量及其相关的尾部概率必须是无量纲的。将尾部概率（p值）表示为小数（不带百分号）。\n\n实现一个程序，对于每个测试用例，输出一个包含四个值的列表：对数秩卡方统计量、对数秩p值、WT组的中位生存时间（天）和LS组的中位生存时间（天）。将所有四个值四舍五入到 $4$ 位小数。\n\n您的程序必须使用以下测试套件。每个测试用例包含两个数组：以天为单位的生存时间和相应的事件指示符（事件指示符等于 $1$ 表示死亡，等于 $0$ 表示右删失）。WT 和 LS 的数组仅按组成员关系对齐；两组之间没有配对关系。\n\n- 测试用例 $1$（明显差异：WT 毒性更强，LS 毒性较弱）：\n  - WT 时间：$[3,5,6,7,9,9,12,15]$\n  - WT 事件：$[1,1,1,1,1,0,1,0]$\n  - LS 时间：$[5,10,12,14,16,18,20,25]$\n  - LS 事件：$[1,0,1,1,0,1,1,0]$\n\n- 测试用例 $2$（无差异：生存经历相同）：\n  - WT 时间：$[4,8,10,10,12,14]$\n  - WT 事件：$[1,1,0,1,0,1]$\n  - LS 时间：$[4,8,10,10,12,14]$\n  - LS 事件：$[1,1,0,1,0,1]$\n\n- 测试用例 $3$（边界条件：大量时间平局和显著删失）：\n  - WT 时间：$[2,2,4,4,6,8]$\n  - WT 事件：$[1,0,1,0,1,0]$\n  - LS 时间：$[2,3,4,4,6,8,10]$\n  - LS 事件：$[0,1,0,1,0,1,0]$\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$\\[result_1,result_2,result_3]$）。每个 $result_i$ 本身必须是 $[\\chi^2, p, m_{\\mathrm{WT}}, m_{\\mathrm{LS}}]$ 形式的列表，其中 $\\chi^2$ 是对数秩卡方统计量，$p$ 是相关的p值，$m_{\\mathrm{WT}}$ 是WT组的中位生存时间（天），$m_{\\mathrm{LS}}$ 是LS组的中位生存时间（天）。所有数值必须四舍五入到 $4$ 位小数。除此单个方括号列表外，输出不得包含任何其他文本。", "solution": "该问题要求对野生型 (WT) 与凝集素沉默 (LS) 溶组织内阿米巴 (Entamoeba histolytica) 菌株这两个存在右删失的组别进行生存分析。我们通过两种工具将生物学背景与统计推导联系起来：Kaplan–Meier (KM) 估计量和对数秩检验 (LRT)，二者均从生存分析的第一性原理推导而来。\n\n基本定义：\n- 设 $T$ 是一个表示事件（死亡）发生时间的非负随机变量，$S(t) = \\mathbb{P}(T > t)$ 是生存函数。我们观察的是右删失数据：对于某些受试者，我们只知道他们在时间 $t$ 之前一直存活，但并未在该时间点之前经历事件。\n- 删失被假定为非信息性的：在删失时间之前存活的条件下，被删失受试者中 $T$ 的分布与未被删失受试者中的分布相同。\n\nKaplan–Meier 估计量推导：\n- 考虑在给定组中发生事件的独特、有序的时间点 $\\{t_1, t_2, \\dots, t_J\\}$。设 $n_j$ 为紧邻 $t_j$ 之前的风险集中的个体数，设 $d_j$ 为在时间 $t_j$ 发生的事件数。在考虑了时间 $t_j$ 的事件后，将时间 $t_j$ 的右删失观测值从风险集中移除。\n- Kaplan–Meier (KM) 估计量，也称为乘积极限估计量，由下式给出：\n$$\n\\hat{S}(t) = \\prod_{t_j \\le t} \\left(1 - \\frac{d_j}{n_j}\\right).\n$$\n该估计量源于将生存视为在每个事件时间点上条件失败概率的乘法补集，并假设删失是独立的、非信息性的。\n- 从算法上讲，要随时间计算 $\\hat{S}(t)$：\n  1. 对组内所有观测时间（事件和删失）进行排序。\n  2. 初始化 $\\hat{S}(t_0) = 1$，$n$ 为受试者总数。\n  3. 在每个不同的时间点 $t$：\n     - 计算 $d$ 为时间 $t$ 的事件数，$c$ 为时间 $t$ 的删失数。\n     - 如果 $d > 0$，更新 $\\hat{S}(t) \\leftarrow \\hat{S}(t^{-}) \\cdot \\left(1 - \\frac{d}{n}\\right)$，其中 $t^{-}$ 表示紧邻 $t$ 之前的时刻。\n     - 更新风险集 $n \\leftarrow n - d - c$。\n  4. 中位生存时间 $\\hat{m}$ 是满足 $\\hat{S}(t) \\le 0.5$ 的最小时间 $t$。如果对于所有观测时间都有 $\\hat{S}(t) > 0.5$，则定义 $\\hat{m} = -1$。\n\n对数秩检验推导：\n- 对数秩检验 (LRT) 评估零假设 $H_0: S_1(t) = S_2(t)$ 对所有 $t$ 成立，其备择假设是生存函数在某个 $t$ 上不同。它通过在所有不同的事件时间点上汇总观测事件数与期望事件数之间的偏差，并根据 $H_0$ 下的逆方差进行加权。\n- 在两个组的所有不同合并事件时间点 $t_j$ 上，定义：\n  - $n_{1j}$ 和 $n_{2j}$ 分别为紧邻 $t_j$ 之前组 1 和组 2 中处于风险状态的个体数。\n  - $d_{1j}$ 和 $d_{2j}$ 分别为在时间 $t_j$ 时各组发生的事件数。\n  - 总计 $n_j = n_{1j} + n_{2j}$ 和 $d_j = d_{1j} + d_{2j}$。\n- 在 $H_0$ 下，组 1 在时间 $t_j$ 的期望事件数为\n$$\ne_{1j} = d_j \\cdot \\frac{n_{1j}}{n_j},\n$$\n而差值 $d_{1j} - e_{1j}$ 的方差在超几何抽样模型下为\n$$\nv_{1j} = \\frac{n_{1j} n_{2j} d_j (n_j - d_j)}{n_j^2 (n_j - 1)}.\n$$\n- 对所有事件时间进行汇总：\n$$\nZ = \\sum_{j} (d_{1j} - e_{1j}), \\quad V = \\sum_{j} v_{1j}.\n$$\n- 对数秩卡方统计量为\n$$\n\\chi^2 = \\begin{cases}\n\\frac{Z^2}{V},  V > 0, \\\\\n0,  V = 0,\n\\end{cases}\n$$\n在 $H_0$ 下近似服从自由度为 $1$ 的卡方分布。p 值为 $p = 1 - F_{\\chi^2_1}(\\chi^2)$，其中 $F_{\\chi^2_1}$ 是自由度为 $1$ 的卡方分布的累积分布函数。\n- 实践说明：\n  - 在时间 $t$ 删失的个体在时间 $t$ 处于风险集中（已知他们存活至时间 $t$），但其贡献为 $d_{gj} = 0$；他们在时间 $t$ 之后立即从风险集中移除。\n  - 如果某个时间点 $n_j \\le 1$，则将 $v_{1j}$ 视为 $0$ 以避免除以零；如果汇总后 $V = 0$，则设 $\\chi^2 = 0$ 且 $p = 1$。\n\n算法计划：\n- 对于每个组，计算 KM 阶梯函数并确定中位生存时间 $\\hat{m}$，即满足 $\\hat{S}(t) \\le 0.5$ 的最早时间 $t$，如果未达到则为 $-1$。\n- 对于对数秩检验，合并两组中不同的事件时间，在每个 $t_j$ 计算 $n_{1j}, n_{2j}, d_{1j}, d_{2j}$，汇总 $Z$ 和 $V$，然后计算 $\\chi^2$ 和 $p$。\n- 将上述方法应用于所有测试用例，并以指定的格式输出包含四元组 $[\\chi^2, p, m_{\\mathrm{WT}}, m_{\\mathrm{LS}}]$ 的单行列表，四舍五入到 $4$ 位小数。\n\n所提供测试套件中的边缘情况：\n- 测试用例 $1$ 展示了明显的组间差异（WT 组事件发生更早且更频繁）。\n- 测试用例 $2$ 的两组数据相同，因此 $\\chi^2$ 应接近 $0$，$p$ 接近 $1$，且中位生存时间相等。\n- 测试用例 $3$ 包含许多时间平局和显著删失，考验了对风险集和方差累积的正确处理。\n\n所有中位生存时间的输出都必须以天为单位，并且所有输出都必须按要求四舍五-入到 $4$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef km_median(times, events):\n    \"\"\"\n    Compute the Kaplan–Meier survival step function and return the median survival time.\n    times: list or array of survival times (days)\n    events: list or array of event indicators (1=death, 0=censored)\n    Returns median survival time (days); -1 if survival never drops to 0.5.\n    \"\"\"\n    times = np.array(times, dtype=float)\n    events = np.array(events, dtype=int)\n\n    # Sort unique times (include both events and censors for risk set updates)\n    unique_times = np.unique(times)\n\n    # Precompute counts at each time\n    # d(t): number of events at time t\n    # c(t): number of censors at time t\n    d_counts = {}\n    c_counts = {}\n    for t in unique_times:\n        at_t = (times == t)\n        d_counts[t] = int(np.sum(at_t  (events == 1)))\n        c_counts[t] = int(np.sum(at_t  (events == 0)))\n\n    n = len(times)\n    S = 1.0\n    # Record survival steps only when an event occurs (since censoring does not change S)\n    step_times = []\n    step_surv = []\n\n    for t in unique_times:\n        d = d_counts[t]\n        c = c_counts[t]\n        if n == 0:\n            break\n        if d > 0:\n            S *= (n - d) / n\n            step_times.append(t)\n            step_surv.append(S)\n        # Update risk set after accounting for events and censors at t\n        n -= (d + c)\n\n    # Determine median survival: earliest time where S = 0.5\n    median = -1.0\n    for t, s in zip(step_times, step_surv):\n        if s = 0.5:\n            median = float(t)\n            break\n    return median\n\ndef logrank_test(times1, events1, times2, events2):\n    \"\"\"\n    Compute the log-rank test statistic and p-value comparing two groups.\n    Returns (chi_square_stat, p_value).\n    \"\"\"\n    times1 = np.array(times1, dtype=float)\n    events1 = np.array(events1, dtype=int)\n    times2 = np.array(times2, dtype=float)\n    events2 = np.array(events2, dtype=int)\n\n    # Distinct pooled event times across both groups\n    event_times1 = np.unique(times1[events1 == 1])\n    event_times2 = np.unique(times2[events2 == 1])\n    pooled_event_times = np.unique(np.concatenate([event_times1, event_times2]))\n    pooled_event_times.sort()\n\n    Z = 0.0\n    V = 0.0\n\n    for t in pooled_event_times:\n        # Number at risk just prior to t (include those with time == t)\n        n1 = int(np.sum(times1 >= t))\n        n2 = int(np.sum(times2 >= t))\n        n = n1 + n2\n\n        # Number of events at t\n        d1 = int(np.sum((times1 == t)  (events1 == 1)))\n        d2 = int(np.sum((times2 == t)  (events2 == 1)))\n        d = d1 + d2\n\n        if n == 0 or d == 0:\n            # No risk or no events; skip (pooled_event_times ensures d > 0 typically)\n            continue\n\n        e1 = d * (n1 / n)\n        # Variance under hypergeometric sampling; guard against division by zero\n        if n > 1:\n            v1 = (n1 * n2 * d * (n - d)) / (n**2 * (n - 1))\n        else:\n            v1 = 0.0\n\n        Z += (d1 - e1)\n        V += v1\n\n    if V > 0.0:\n        chi_sq = (Z ** 2) / V\n        p_val = 1.0 - chi2.cdf(chi_sq, df=1)\n    else:\n        chi_sq = 0.0\n        p_val = 1.0\n\n    return chi_sq, p_val\n\ndef format_no_spaces(obj):\n    \"\"\"\n    Convert a Python list or number into a string without spaces, with default repr for numbers.\n    \"\"\"\n    if isinstance(obj, list):\n        return '[' + ','.join(format_no_spaces(x) for x in obj) + ']'\n    elif isinstance(obj, float):\n        # Ensure standard float string without spaces\n        return str(obj)\n    elif isinstance(obj, int):\n        return str(obj)\n    else:\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (WT_times, WT_events, LS_times, LS_events)\n    test_cases = [\n        (\n            [3, 5, 6, 7, 9, 9, 12, 15],\n            [1, 1, 1, 1, 1, 0, 1, 0],\n            [5, 10, 12, 14, 16, 18, 20, 25],\n            [1, 0, 1, 1, 0, 1, 1, 0],\n        ),\n        (\n            [4, 8, 10, 10, 12, 14],\n            [1, 1, 0, 1, 0, 1],\n            [4, 8, 10, 10, 12, 14],\n            [1, 1, 0, 1, 0, 1],\n        ),\n        (\n            [2, 2, 4, 4, 6, 8],\n            [1, 0, 1, 0, 1, 0],\n            [2, 3, 4, 4, 6, 8, 10],\n            [0, 1, 0, 1, 0, 1, 0],\n        ),\n    ]\n\n    results = []\n    for wt_times, wt_events, ls_times, ls_events in test_cases:\n        # Log-rank test\n        chi_sq, p_val = logrank_test(wt_times, wt_events, ls_times, ls_events)\n        # Kaplan–Meier medians\n        m_wt = km_median(wt_times, wt_events)\n        m_ls = km_median(ls_times, ls_events)\n\n        # Round all outputs to 4 decimal places\n        chi_sq_r = round(float(chi_sq), 4)\n        p_val_r = round(float(p_val), 4)\n        m_wt_r = round(float(m_wt), 4)\n        m_ls_r = round(float(m_ls), 4)\n\n        results.append([chi_sq_r, p_val_r, m_wt_r, m_ls_r])\n\n    # Final print statement in the exact required format: single line, bracketed list, no spaces.\n    print(format_no_spaces(results))\n\nsolve()\n```", "id": "4628274"}]}