{"hands_on_practices": [{"introduction": "在生物防御应急响应中，快速准确的诊断筛查是控制疫情蔓延的基石。然而，任何检测方法都存在固有的不确定性，其性能必须在特定流行病学背景下进行评估。本练习将运用 Bayes 定理，从第一性原理出发，推导并计算评估诊断测试性能的关键指标，例如阳性预测值 ($PPV$) 和阴性预测值 ($NPV$)，这对于在真实世界场景中解读测试结果和制定公共卫生决策至关重要。[@problem_id:4630802]", "problem": "在一次可信的气溶胶释放事件后，建立了一个高通量筛查站，用于对疑似暴露于炭疽杆菌（B. anthracis）的人群进行筛查。在分诊处部署了一种检测保护性抗原的快速免疫测定法。在被测试的队列中，真正患病的检验前概率（操作上定义为筛查人群中的时点患病率）为 $p$。在现场条件下，该测定法的灵敏度为 $s$，特异度为 $c$。\n\n从条件概率和贝叶斯定理的基本定义出发，用概率术语定义灵敏度、特异度、阳性预测值（PPV）和阴性预测值（NPV）。然后，使用贝叶斯定理和全概率定律，推导出PPV和NPV作为 $p$、$s$ 和 $c$ 的函数的通用闭式表达式。完成推导后，使用以下科学上合理的操作参数对PPV和NPV进行数值计算：$p = 0.01$，$s = 0.95$，$c = 0.98$。\n\n将最终的PPV和NPV表示为不带百分号的小数形式。将每个值四舍五入到四位有效数字。您的最终答案必须使用 LaTeX 的 $\\texttt{pmatrix}$ 环境，将PPV和NPV按此顺序呈现在单行中。", "solution": "问题陈述已经过验证，被认为是合理、定义明确且有科学依据的。它展示了概率论在医疗诊断和生物防御背景下的一个标准且不简单的应用。所有必要信息均已提供，任务是推导和应用基本公式。\n\n设 $D$ 为被筛查个体患有该疾病（真正感染了*炭疽杆菌*）的事件，设 $D^c$ 为该个体未患病的互补事件。设 $T^+$ 为免疫测定结果为阳性的事件，设 $T^-$ 为结果为阴性的事件。\n\n问题陈述中给出的已知条件是：\n- 疾病的检验前概率，或患病率：$P(D) = p$。\n- 测定法的灵敏度：$s$。\n- 测定法的特异度：$c$。\n\n根据患病率，从该队列中随机选择一个个体未患病的概率为 $P(D^c) = 1 - P(D) = 1 - p$。\n\n首先，我们用条件概率来定义灵敏度、特异度、阳性预测值（PPV）和阴性预测值（NPV）。\n\n灵敏度 $s$ 是在个体患有该疾病的条件下，检验结果为阳性的概率。\n$$ s = P(T^+ | D) $$\n这就是真阳性率。\n\n特异度 $c$ 是在个体未患有该疾病的条件下，检验结果为阴性的概率。\n$$ c = P(T^- | D^c) $$\n这就是真阴性率。\n\n阳性预测值（PPV）是在检验结果为阳性的条件下，个体患有该疾病的检验后概率。\n$$ \\text{PPV} = P(D | T^+) $$\n\n阴性预测值（NPV）是在检验结果为阴性的条件下，个体未患有该疾病的检验后概率。\n$$ \\text{NPV} = P(D^c | T^-) $$\n\n接下来，我们使用贝叶斯定理和全概率定律推导PPV和NPV的闭式表达式。\n\n**PPV的推导：**\n根据贝叶斯定理，PPV可以表示为：\n$$ \\text{PPV} = P(D | T^+) = \\frac{P(T^+ | D) P(D)}{P(T^+)} $$\n分子包含直接给出的项：$P(T^+ | D) = s$ 和 $P(D) = p$。\n分母 $P(T^+)$ 是检验结果为阳性的总概率。我们可以使用全概率定律展开此项：\n$$ P(T^+) = P(T^+ | D) P(D) + P(T^+ | D^c) P(D^c) $$\n我们知道 $P(T^+ | D) = s$ 和 $P(D) = p$。我们还知道 $P(D^c) = 1 - p$。项 $P(T^+ | D^c)$ 是假阳性率。它可以从特异度 $c$ 推导出来。因为对未患病个体的检验结果只能是阳性或阴性，所以我们有 $P(T^+ | D^c) + P(T^- | D^c) = 1$。\n给定 $c = P(T^- | D^c)$，可以得出：\n$$ P(T^+ | D^c) = 1 - P(T^- | D^c) = 1 - c $$\n将所有项代入 $P(T^+)$ 的展开式中：\n$$ P(T^+) = s \\cdot p + (1 - c)(1 - p) $$\n最后，将分子和展开后的分母代回PPV的贝叶斯定理公式，得到通用的闭式表达式：\n$$ \\text{PPV} = \\frac{s \\cdot p}{s \\cdot p + (1 - c)(1 - p)} $$\n\n**NPV的推导：**\n类似地，对于NPV，我们从贝叶斯定理开始：\n$$ \\text{NPV} = P(D^c | T^-) = \\frac{P(T^- | D^c) P(D^c)}{P(T^-)} $$\n分子的项是已知的或可以直接推导得出：$P(T^- | D^c) = c$ 和 $P(D^c) = 1 - p$。\n分母 $P(T^-)$ 是检验结果为阴性的总概率。我们使用全概率定律展开此项：\n$$ P(T^-) = P(T^- | D) P(D) + P(T^- | D^c) P(D^c) $$\n我们知道 $P(T^- | D^c) = c$ 和 $P(D^c) = 1 - p$。项 $P(T^- | D)$ 是假阴性率。它由灵敏度 $s$ 推导得出。因为对患病个体的检验结果只能是阳性或阴性，所以我们有 $P(T^+ | D) + P(T^- | D) = 1$。\n给定 $s = P(T^+ | D)$，可以得出：\n$$ P(T^- | D) = 1 - P(T^+ | D) = 1 - s $$\n将所有项代入 $P(T^-)$ 的展开式中：\n$$ P(T^-) = (1 - s)p + c(1 - p) $$\n将分子和展开后的分母代入NPV的公式，得到通用的闭式表达式：\n$$ \\text{NPV} = \\frac{c(1 - p)}{(1 - s)p + c(1 - p)} $$\n\n现在，我们使用给定的参数进行数值计算：$p = 0.01$，$s = 0.95$，$c = 0.98$。\n\n**PPV的数值计算：**\n$$ \\text{PPV} = \\frac{(0.95)(0.01)}{(0.95)(0.01) + (1 - 0.98)(1 - 0.01)} $$\n$$ \\text{PPV} = \\frac{0.0095}{0.0095 + (0.02)(0.99)} $$\n$$ \\text{PPV} = \\frac{0.0095}{0.0095 + 0.0198} $$\n$$ \\text{PPV} = \\frac{0.0095}{0.0293} \\approx 0.32423208... $$\n四舍五入到四位有效数字，我们得到 $\\text{PPV} = 0.3242$。\n\n**NPV的数值计算：**\n$$ \\text{NPV} = \\frac{(0.98)(1 - 0.01)}{(1 - 0.95)(0.01) + (0.98)(1 - 0.01)} $$\n$$ \\text{NPV} = \\frac{(0.98)(0.99)}{(0.05)(0.01) + (0.98)(0.99)} $$\n$$ \\text{NPV} = \\frac{0.9702}{0.0005 + 0.9702} $$\n$$ \\text{NPV} = \\frac{0.9702}{0.9707} \\approx 0.99948490... $$\n四舍五入到四位有效数字，我们得到 $\\text{NPV} = 0.9995$。\n\n这些结果展示了诊断检验中的一个普遍原则：即使使用灵敏度和特异度都很高的检验方法，当疾病的患病率很低时，PPV也可能很低。相反，在低患病率的情况下，NPV通常非常高。", "answer": "$$\\boxed{\\begin{pmatrix} 0.3242  0.9995 \\end{pmatrix}}$$", "id": "4630802"}, {"introduction": "基本再生数（$R_0$）是流行病学中衡量病原体传播潜力的核心指标，它决定了疫情是会自行消退还是会大规模爆发。本练习旨在通过运用下一代矩阵法，为一个标准的易感-潜伏-感染-移除（SEIR）模型推导出 $R_0$ 的解析表达式。掌握这种严谨的数学方法，对于理解现代传染病动力学模型以及评估非药物干预措施（NPIs）的有效性至关重要。[@problem_id:4630715]", "problem": "在针对高危呼吸道病原体的生物防御风险评估中，规划者需要基本再生数 $R_0$ 来评估为阻止持续传播所需的非药物干预措施的规模。考虑一个大小恒定为 $N$ 的封闭、均匀混合种群，其中传播的病原体遵循易感-暴露-感染-移除 (SEIR) 的自然病程，且潜伏期和感染期呈指数分布。SEIR 模型由以下常微分方程组给出\n$$\n\\frac{dS}{dt} \\;=\\; -\\beta \\,\\frac{S I}{N},\\qquad\n\\frac{dE}{dt} \\;=\\; \\beta \\,\\frac{S I}{N} \\,-\\, \\sigma E,\\qquad\n\\frac{dI}{dt} \\;=\\; \\sigma E \\,-\\, \\gamma I,\\qquad\n\\frac{dR}{dt} \\;=\\; \\gamma I,\n$$\n其中 $S$, $E$, $I$, 和 $R$ 分别表示易感者、暴露者（已感染但尚无传染性）、感染者和移除者的数量。参数 $\\beta$ 是有效接触率（每单位时间），$\\sigma$ 是从暴露态进展为感染态的速率（每单位时间），$\\gamma$ 是恢复或移除率（每单位时间）。假设没有出生、与感染无关的死亡或其他人口流动。使用下一代矩阵法，在由 $S = N$, $E = 0$, $I = 0$, 和 $R = 0$ 给出的无病平衡点下，推导基本再生数 $R_0$ 关于 $\\beta$, $\\sigma$, 和 $\\gamma$ 的闭式解析表达式。请以 $\\beta$, $\\sigma$, 和 $\\gamma$ 的单个符号表达式形式给出最终答案。无需四舍五入，也无需报告 $R_0$ 的单位。", "solution": "基本再生数 $R_0$ 定义为下一代矩阵的谱半径（主特征值），该矩阵通过对感染子系统在无病平衡点附近的线性化来构建。我们考虑感染状态向量 $x = (E, I)^{\\top}$，并将子系统动力学写为\n$$\n\\frac{dx}{dt} \\;=\\; \\mathcal{F}(x) \\,-\\, \\mathcal{V}(x),\n$$\n其中 $\\mathcal{F}(x)$ 汇集了每个感染仓室中新感染出现的速率，而 $\\mathcal{V}(x)$ 汇集了感染仓室之间及之外的其余转移（按照惯例，$\\mathcal{V} = \\mathcal{V}^{-} - \\mathcal{V}^{+}$ 分离了非新感染的流出和流入）。\n\n从 SEIR 系统可知，\n- 新感染项仅出现在暴露仓室中：易感者以速率 $\\beta \\,\\frac{S I}{N}$ 变为暴露者。因此，\n$$\n\\mathcal{F}(E,I) \\;=\\; \\begin{pmatrix} \\beta \\,\\frac{S I}{N} \\\\ 0 \\end{pmatrix}.\n$$\n- 暴露和感染仓室的其他转移由以下几项给出：以速率 $\\sigma E$ 从 $E$ 流出，以速率 $\\sigma E$ 从 $E$ 流入 $I$，以及以速率 $\\gamma I$ 从 $I$ 流出。在 $\\mathcal{V}$ 分解中，这得到\n$$\n\\mathcal{V}(E,I) \\;=\\; \\begin{pmatrix} \\sigma E \\\\ \\gamma I \\,-\\, \\sigma E \\end{pmatrix}.\n$$\n\n我们在无病平衡点 (DFE) $S = N$, $E = 0$, $I = 0$, $R = 0$ 附近进行线性化。$\\mathcal{F}$ 和 $\\mathcal{V}$ 关于 $(E,I)$ 在 DFE 处的雅可比矩阵为\n$$\nF \\;=\\; \\left.\\frac{\\partial \\mathcal{F}}{\\partial (E,I)}\\right|_{\\text{DFE}}\n\\;=\\;\n\\begin{pmatrix}\n0  \\beta \\\\\n0  0\n\\end{pmatrix},\n\\qquad\nV \\;=\\; \\left.\\frac{\\partial \\mathcal{V}}{\\partial (E,I)}\\right|_{\\text{DFE}}\n\\;=\\;\n\\begin{pmatrix}\n\\sigma  0 \\\\\n-\\sigma  \\gamma\n\\end{pmatrix}.\n$$\n\n下一代矩阵是 $K \\,=\\, F V^{-1}$。我们显式计算 $V^{-1}$。$V$ 的行列式是\n$$\n\\det(V) \\;=\\; \\sigma \\gamma \\,-\\, 0 \\cdot (-\\sigma) \\;=\\; \\sigma \\gamma,\n$$\n且 $V$ 的伴随矩阵是\n$$\n\\operatorname{adj}(V) \\;=\\; \\begin{pmatrix} \\gamma  0 \\\\ \\sigma  \\sigma \\end{pmatrix}.\n$$\n因此，\n$$\nV^{-1} \\;=\\; \\frac{1}{\\sigma \\gamma} \\begin{pmatrix} \\gamma  0 \\\\ \\sigma  \\sigma \\end{pmatrix}.\n$$\n将它们相乘，我们得到\n$$\nK \\;=\\; F V^{-1}\n\\;=\\;\n\\begin{pmatrix}\n0  \\beta \\\\\n0  0\n\\end{pmatrix}\n\\cdot\n\\frac{1}{\\sigma \\gamma}\n\\begin{pmatrix}\n\\gamma  0 \\\\\n\\sigma  \\sigma\n\\end{pmatrix}\n\\;=\\;\n\\frac{1}{\\sigma \\gamma}\n\\begin{pmatrix}\n\\beta \\sigma  \\beta \\sigma \\\\\n0  0\n\\end{pmatrix}\n\\;=\\;\n\\begin{pmatrix}\n\\frac{\\beta}{\\gamma}  \\frac{\\beta}{\\gamma} \\\\\n0  0\n\\end{pmatrix}.\n$$\n\n$K$ 的特征值是其特征多项式的根。因为 $K$ 是一个上三角矩阵，其特征值位于对角线上，即 $\\lambda_{1} = \\frac{\\beta}{\\gamma}$ 和 $\\lambda_{2} = 0$。谱半径是特征值模的最大值，所以\n$$\nR_0 \\;=\\; \\rho(K) \\;=\\; \\frac{\\beta}{\\gamma}.\n$$\n值得注意的是，在这个具有指数分布阶段和频率依赖性传播的标准 SEIR 框架中，潜伏期进展率 $\\sigma$ 不影响 $R_0$，因为 $\\sigma$ 只是改变了传染性开始的时间，而没有改变在整个感染期内产生的预期二次感染数。在生物防御的背景下，这表明，在没有其他影响的情况下，仅缩短潜伏期不会改变 $R_0$，而降低有效接触率 $\\beta$ 或提高移除率 $\\gamma$ 会直接降低 $R_0$。", "answer": "$$\\boxed{\\frac{\\beta}{\\gamma}}$$", "id": "4630715"}, {"introduction": "生物防御风险评估模型通常涉及多个具有不确定性的输入参数，识别哪些参数对最终风险评估结果影响最大，是资源优化和决策制定的关键。本练习将通过一个高级的计算实践，介绍全局敏感性分析（Global Sensitivity Analysis）中的 Sobol 指数法。你将编写代码来量化一个多变量风险模型中各输入参数对输出方差的贡献，从而确定在复杂和不确定的现实世界中，哪些因素是风险控制的主要驱动力。[@problem_id:4630783]", "problem": "构建一个完整、可运行的程序，用于为一个多变量生物防御风险模型估计全局方差敏感性度量（Sobol 指数），并在多个场景中识别出最具影响力的单个输入参数。您的程序必须在保持数学严谨性的同时，将以下具有科学依据的模型和约束付诸实践。\n\n从以下基本基础开始，该基础源于生物防御中传染病风险的路径概率观点：一次释放的预期严重性加权影响与成功释放的概率、人群暴露的比例、暴露后感染的概率、发展为严重后果的比例、因缓解措施而减少的比例以及因检测延迟而产生的乘法放大效应成倍数关系。将其形式化，为一个六参数输入向量 $\\mathbf{x} = (x_1, x_2, x_3, x_4, x_5, x_6)$ 定义一个输出风险度量 $Y$：\n$$\nY(\\mathbf{x}) \\;=\\; x_1 \\, x_2 \\, x_3 \\, x_4 \\, (1 - x_5)\\, (1 + x_6),\n$$\n其中：\n- $x_1$ 是操作释放成功概率，\n- $x_2$ 是人群暴露比例，\n- $x_3$ 是暴露后感染的概率，\n- $x_4$ 是发展为严重后果的比例，\n- $x_5$ 是缓解有效性（以分数表示），将风险降低一个因子 $(1 - x_5)$，\n- $x_6$ 是一个非负的检测延迟放大因子，将风险增加一个因子 $(1 + x_6)$。\n\n所有输入在其指定区间上相互独立且均匀分布。您必须为此 $6$ 维模型从基本原理出发计算一阶和全阶 Sobol 指数，使用从方差分解定义派生的一致性蒙特卡罗估计量，而不依赖外部的敏感性分析库。每个测试用例使用单个固定的基础样本数 $N$，为保证可复现性每个测试用例使用固定的随机数生成器种子，并使用与独立输入和平方可积的 $Y$ 的假设相符的估计量。您的算法必须数值稳定，并能产生在 $[0,1]$ 区间内的指数，其总和在蒙特卡罗误差范围内遵循方差分解约束。\n\n然后，您的程序应为每个测试用例识别具有最大全阶 Sobol 指数的输入变量的索引（使用基于 1 的索引）。如果在机器精度内出现精确的数值并列，请选择最小的索引。\n\n此问题不涉及物理单位，因为所有输入都是概率或无量纲因子。不涉及角度。所有分数数量必须在定义的 $[0,\\infty)$ 范围内作为实数处理。每个测试用例的最终答案必须以整数形式返回，指示最具影响力的参数索引。\n\n测试套件。实现以下 $3$ 个测试用例。对于每个用例，使用指定的参数范围、基础样本大小 $N$ 和伪随机种子。对于每个用例，所有六个参数都在其各自的区间上独立均匀分布。\n\n- 测试用例 A（缓解有效性变异性占主导）：\n  - 范围：\n    - $x_1 \\in [\\,0.05,\\, 0.06\\,]$\n    - $x_2 \\in [\\,0.01,\\, 0.02\\,]$\n    - $x_3 \\in [\\,0.50,\\, 0.60\\,]$\n    - $x_4 \\in [\\,0.10,\\, 0.20\\,]$\n    - $x_5 \\in [\\,0.00,\\, 0.95\\,]$\n    - $x_6 \\in [\\,0.30,\\, 0.40\\,]$\n  - 基础样本：$N = 4096$\n  - 种子：$101$\n\n- 测试用例 B（检测延迟放大变异性占主导）：\n  - 范围：\n    - $x_1 \\in [\\,0.05,\\, 0.06\\,]$\n    - $x_2 \\in [\\,0.01,\\, 0.02\\,]$\n    - $x_3 \\in [\\,0.50,\\, 0.60\\,]$\n    - $x_4 \\in [\\,0.10,\\, 0.20\\,]$\n    - $x_5 \\in [\\,0.40,\\, 0.50\\,]$\n    - $x_6 \\in [\\,0.00,\\, 3.00\\,]$\n  - 基础样本：$N = 4096$\n  - 种子：$202$\n\n- 测试用例 C（感染概率变异性占主导）：\n  - 范围：\n    - $x_1 \\in [\\,0.05,\\, 0.06\\,]$\n    - $x_2 \\in [\\,0.005,\\, 0.006\\,]$\n    - $x_3 \\in [\\,0.05,\\, 0.95\\,]$\n    - $x_4 \\in [\\,0.20,\\, 0.25\\,]$\n    - $x_5 \\in [\\,0.40,\\, 0.50\\,]$\n    - $x_6 \\in [\\,0.20,\\, 0.25\\,]$\n  - 基础样本：$N = 4096$\n  - 种子：$303$\n\n算法要求：\n- 在 $[0,1]$ 上生成两个独立的 $N \\times 6$ 基础样本矩阵，通过仿射缩放将它们变换到上述范围，并根据基于方差的全局敏感性分析框架构建用于 Sobol 指数估计的必要混合矩阵。\n- 以在独立性假设下无偏且当 $N \\to \\infty$ 时收敛的方式估计一阶和全阶 Sobol 指数。\n- 为每个测试用例确定最具影响力的参数的索引，即具有最大全阶指数的参数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表包含对应于测试用例 A、B 和 C 的最具影响力参数索引的三个整数。例如，一个有效的输出看起来像“[2,5,3]”，并且必须是这种结构（不需要空格）。", "solution": "该问题已经过验证，并被确定为定量风险评估和敏感性分析领域中一个定义良好、有科学依据的问题。所有必要的数据、模型定义和约束均已提供，不存在矛盾或歧义。\n\n任务是为一个给定的生物防御风险模型执行全局方差敏感性分析，以在三种不同情景中识别出最具影响力的输入参数。所使用的方法是通过蒙特卡罗模拟来估计 Sobol 指数。\n\n风险度量 $Y$ 的模型是六个独立输入参数 $\\mathbf{x} = (x_1, x_2, x_3, x_4, x_5, x_6)$ 的乘法函数：\n$$\nY(\\mathbf{x}) = x_1 \\, x_2 \\, x_3 \\, x_4 \\, (1 - x_5)\\, (1 + x_6)\n$$\n输入 $x_i$（其中 $i \\in \\{1, \\dots, 6\\}$）是独立的，并在指定区间上均匀分布。我们的目标是找出哪个参数 $x_i$ 对输出 $Y$ 的方差影响最大。这通过计算每个参数的全阶 Sobol 指数并找出最大值来实现。\n\n**1. 理论框架：基于方差的敏感性分析**\n\n基于方差的敏感性分析，或称 Sobol 方法，将模型输出的总方差 $V(Y)$ 分解为来自每个输入参数及其交互作用的贡献。\n设 $Y = f(\\mathbf{X})$，其中 $\\mathbf{X} = (X_1, X_2, \\ldots, X_k)$ 是一个由 $k$ 个独立随机输入变量组成的向量。总方差 $V(Y)$ 由下式给出：\n$$\nV(Y) = E[Y^2] - (E[Y])^2\n$$\n一阶敏感性指数 $S_i$ 衡量单个参数 $X_i$ 对总方差的直接贡献，不包括交互作用：\n$$\nS_i = \\frac{V(E[Y|X_i])}{V(Y)}\n$$\n其中 $E[Y|X_i]$ 是对除 $X_i$ 之外的所有参数取期望得到的 $Y$ 的期望值。\n\n全阶敏感性指数 $S_{Ti}$ 捕捉了参数 $X_i$ 的总效应，包括其一阶效应以及与其它参数的所有高阶交互作用：\n$$\nS_{Ti} = \\frac{E[V(Y|X_{\\sim i})]}{V(Y)}\n$$\n其中 $X_{\\sim i}$ 表示除 $X_i$ 以外的所有输入参数的向量。如果一个输入参数的全阶指数 $S_{Ti}$ 很大，则认为它具有影响力。我们将把具有最大 $S_{Ti}$ 的参数识别为最具影响力的参数。\n\n**2. 蒙特卡罗估计策略**\n\nSobol 指数的解析计算仅对简单模型可行。对于给定的模型，我们按规定采用蒙特卡罗估计技术。这需要一个特定的抽样设计。\n\n**抽样设计：**\n1.  生成两个独立的样本矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$，每个矩阵的大小为 $N \\times k$。这里 $k=6$，$N$ 是基础样本的数量。这些矩阵的每个元素都从标准均匀分布 $U(0,1)$ 中抽取。\n2.  然后使用仿射变换将生成的样本进行转换，以匹配每个参数 $x_i$ 的指定均匀分布范围 $[L_i, U_i]$：\n    $$\n    x_i = L_i + (U_i - L_i) \\cdot u_i, \\quad \\text{where } u_i \\sim U(0,1)\n    $$\n3.  对于每个参数 $x_i$，$i \\in \\{1, \\ldots, k\\}$，创建第三个矩阵 $\\mathbf{C}_i$。矩阵 $\\mathbf{C}_i$ 的构成方式是：取矩阵 $\\mathbf{A}$ 的所有列，但第 $i$ 列除外，该列取自矩阵 $\\mathbf{B}$。\n\n**模型评估：**\n对矩阵 $\\mathbf{A}$、$\\mathbf{B}$ 和所有 $k$ 个矩阵 $\\mathbf{C}_i$ 的每一行评估模型函数 $Y(\\mathbf{x})$。这将产生 $k+2$ 个模型输出向量，每个向量的长度为 $N$：\n- $y_A = Y(\\mathbf{A})$\n- $y_B = Y(\\mathbf{B})$\n- $y_{C_i} = Y(\\mathbf{C}_i)$ for $i=1, \\ldots, k$.\n\n**Sobol 指数的估计量：**\n使用这些输出向量，我们可以为所需的方差构建一致性估计量。总成本为 $N(k+2)$ 次模型评估。\n\n- **总方差：**总方差 $V(Y)$ 使用输出向量 $y_A$ 的样本方差来估计。\n  $$\n  \\hat{V}(Y) = \\frac{1}{N}\\sum_{j=1}^{N} (y_{A,j})^2 - \\left(\\frac{1}{N}\\sum_{j=1}^{N} y_{A,j}\\right)^2\n  $$\n- **一阶指数：**$S_i$ 的分子 $V(E[Y|X_i])$，使用所有三组矩阵的输出来估计。一个常见的估计量 (Homma-Saltelli) 是：\n  $$\n  \\hat{V}(E[Y|X_i]) = \\frac{1}{N} \\sum_{j=1}^{N} y_{B,j} (y_{C_i, j} - y_{A,j})\n  $$\n  因此，一阶指数估计量为 $\\hat{S}_i = \\hat{V}(E[Y|X_i]) / \\hat{V}(Y)$。\n- **全阶指数：**$S_{Ti}$ 的分子 $E[V(Y|X_{\\sim i})]$，使用 Jansen (1999) 提出的一个估计量来估计：\n  $$\n  \\hat{E}[V(Y|X_{\\sim i})] = \\frac{1}{2N} \\sum_{j=1}^{N} (y_{A,j} - y_{C_i,j})^2\n  $$\n  那么，全阶指数估计量为 $\\hat{S}_{Ti} = \\hat{E}[V(Y|X_{\\sim i})] / \\hat{V}(Y)$。\n\n**3. 算法实现**\n\n该算法使用 Python 实现，并利用 `numpy` 库进行高效的向量化数值运算。\n\n1.  一个 `solve()` 函数组织三个指定测试用例的流程。\n2.  对于每个测试用例，使用给定的种子初始化一个随机数生成器，以确保可复现性。\n3.  生成两个形状为 $(N, 6)$ 的基础样本矩阵 `A_norm` 和 `B_norm`，其值来自 $U(0,1)$。\n4.  通过逐元素缩放这些矩阵，创建最终的输入矩阵 `A` 和 `B`，其列符合指定的参数范围 $[L_i, U_i]$。\n5.  模型函数 `Y` 被向量化，以一次性高效计算矩阵中所有样本的输出。计算输出 $y_A = Y(\\mathbf{A})$ 和 $y_B = Y(\\mathbf{B})$。\n6.  从 $y_A$ 计算总方差 $\\hat{V}(Y)$。\n7.  一个循环遍历 $k=6$ 个参数中的每一个。在每次迭代 $i$ 中：\n    a. 通过用 `B` 的第 $i$ 列替换 `A` 的第 $i$ 列来构建混合矩阵 $\\mathbf{C}_i$。\n    b. 在 $\\mathbf{C}_i$ 上评估模型以获得 $y_{C_i}$。\n    c. 使用上述公式计算 $\\hat{S}_{Ti}$ 的值。\n8.  循环完成后，在计算出的 $\\hat{S}_{Ti}$ 值数组上使用 `numpy.argmax` 来找到最具影响力参数的索引。\n9.  按照要求将此索引转换为基于 1 的索引并存储。\n10. 最后，收集所有三个测试用例的结果，并以指定格式打印。\n\n此过程为估计 Sobol 指数和识别驱动生物防御风险模型不确定性的最关键参数提供了一种稳健且标准的方法。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Estimates global variance-based sensitivity measures (Sobol indices)\n    for a multivariate biodefense risk model and identifies the single most\n    influential input parameter for each of three test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"ranges\": [\n                (0.05, 0.06), (0.01, 0.02), (0.50, 0.60), (0.10, 0.20),\n                (0.00, 0.95), (0.30, 0.40)\n            ],\n            \"N\": 4096,\n            \"seed\": 101,\n        },\n        {\n            \"name\": \"B\",\n            \"ranges\": [\n                (0.05, 0.06), (0.01, 0.02), (0.50, 0.60), (0.10, 0.20),\n                (0.40, 0.50), (0.00, 3.00)\n            ],\n            \"N\": 4096,\n            \"seed\": 202,\n        },\n        {\n            \"name\": \"C\",\n            \"ranges\": [\n                (0.05, 0.06), (0.005, 0.006), (0.05, 0.95), (0.20, 0.25),\n                (0.40, 0.50), (0.20, 0.25)\n            ],\n            \"N\": 4096,\n            \"seed\": 303,\n        }\n    ]\n\n    results = []\n\n    def model(x):\n        \"\"\"\n        Calculates the risk metric Y based on the input parameter matrix x.\n        Y(x) = x1 * x2 * x3 * x4 * (1 - x5) * (1 + x6)\n        \"\"\"\n        # Ensure x is a 2D array for consistent indexing\n        x = np.atleast_2d(x)\n        return (x[:, 0] * x[:, 1] * x[:, 2] * x[:, 3] * \n                (1 - x[:, 4]) * (1 + x[:, 5]))\n\n    for case in test_cases:\n        N = case[\"N\"]\n        seed = case[\"seed\"]\n        ranges = np.array(case[\"ranges\"])\n        \n        # Number of parameters\n        k = 6\n\n        # Initialize random number generator with the specified seed\n        rng = np.random.default_rng(seed)\n\n        # Generate two independent N x k sample matrices from U(0,1)\n        A_norm = rng.uniform(size=(N, k))\n        B_norm = rng.uniform(size=(N, k))\n\n        # Scale samples to their respective parameter ranges\n        A_scaled = ranges[:, 0] + A_norm * (ranges[:, 1] - ranges[:, 0])\n        B_scaled = ranges[:, 0] + B_norm * (ranges[:, 1] - ranges[:, 0])\n        \n        # Evaluate model for matrices A and B\n        y_A = model(A_scaled)\n        y_B = model(B_scaled) # Needed for first-order estimation\n\n        # Estimate total variance of the output from sample A\n        # Using ddof=0 for population-like variance, consistent with estimators\n        total_variance = np.var(y_A, ddof=0)\n\n        # Initialize arrays to store Sobol indices\n        S_i = np.zeros(k)\n        S_Ti = np.zeros(k)\n        \n        # Loop over each parameter to compute indices\n        for i in range(k):\n            # Create the mixed matrix C_i\n            C_scaled = A_scaled.copy()\n            C_scaled[:, i] = B_scaled[:, i]\n            \n            # Evaluate the model for C_i\n            y_C = model(C_scaled)\n            \n            # Estimate first-order index S_i numerator\n            # (Not required for the final answer, but included for completeness)\n            s_i_numerator = np.mean(y_B * (y_C - y_A))\n            S_i[i] = s_i_numerator / total_variance\n\n            # Estimate total-order index S_Ti numerator\n            s_ti_numerator = 0.5 * np.mean((y_A - y_C)**2)\n            S_Ti[i] = s_ti_numerator / total_variance\n\n        # Find the index of the parameter with the largest total-order index.\n        # np.argmax returns the 0-based index of the maximum value.\n        # If there are ties, it returns the first occurrence (smallest index).\n        most_influential_param_idx = np.argmax(S_Ti)\n        \n        # Convert to 1-based indexing for the final answer\n        results.append(most_influential_param_idx + 1)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "4630783"}]}