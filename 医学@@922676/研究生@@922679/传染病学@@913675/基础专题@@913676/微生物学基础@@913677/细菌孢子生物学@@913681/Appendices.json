{"hands_on_practices": [{"introduction": "芽孢形成是由主调控蛋白 Spo0A 启动的。这个过程并非简单的“开/关”切换，而是由磷酸化 Spo0A 的浓度动态决定的。本练习将运用化学动力学原理，为这一关键决策点建立模型，帮助我们理解细胞如何最终决定进入复杂的发育途径 [@problem_id:4629255]。", "problem": "考虑一个进入营养限制状态的均匀混合的 Bacillus subtilis 细胞种群，其中孢子形成的起始受磷酸化 Spo0A (Spo0A~P) 的浓度控制。设 $S(t)$ 表示在时间 $t$ 时磷酸化 Spo0A 的浓度，设 $S_{tot}$ 表示 Spo0A 的总浓度，在所关注的时间尺度上，由于其合成和降解可以忽略不计，假定 $S_{tot}$ 为常数。磷酸化作用以伪一级反应速率常数 $k_{phos}$ 将未磷酸化的 Spo0A 转化为 Spo0A~P，而去磷酸化作用则以一级反应速率常数 $k_{dephos}$ 将 Spo0A~P 转化回未磷酸化的 Spo0A。假设在一个封闭系统中遵循质量作用动力学，且没有其他汇或源。\n\n从质量平衡和一级反应动力学的核心定义出发，推导在初始条件 $S(0) = S_0$（其中 $0 \\leq S_0 \\leq S_{tot}$）下 $S(t)$ 的时间进程，并确定 $S(t)$ 首次达到孢子形成起始的承诺阈值 $\\theta$ 的时间 $t_{\\theta}$。假设参数满足 $S(t)$ 从 $S_0$ 开始单调增加，并在有限时间内从下方穿过 $\\theta$，且 $0 \\le S_0  \\theta  S_{ss}$，其中 $S_{ss}$ 是稳态浓度。以分钟为单位表示最终时间。你的最终答案必须是关于 $k_{phos}$、$k_{dephos}$、$S_{tot}$、$S_0$ 和 $\\theta$ 的单一闭合形式解析表达式。", "solution": "问题要求推导磷酸化 Spo0A 的浓度（用 $S(t)$ 表示）达到阈值 $\\theta$ 的时间 $t_{\\theta}$。推导必须从质量平衡和反应动力学原理开始。\n\n首先，根据问题陈述定义物种和参数。\n- $S(t)$: 在时间 $t$ 时磷酸化 Spo0A (Spo0A~P) 的浓度。\n- $S_u(t)$: 在时间 $t$ 时未磷酸化 Spo0A 的浓度。\n- $S_{tot}$: Spo0A 的总浓度，为常数。$S_{tot} = S(t) + S_u(t)$。\n- $k_{phos}$: Spo0A 磷酸化为 Spo0A~P 的伪一级反应速率常数。\n- $k_{dephos}$: Spo0A~P 去磷酸化为 Spo0A 的一级反应速率常数。\n- $S(0) = S_0$: Spo0A~P 的初始浓度。\n- $\\theta$: Spo0A~P 的承诺阈值浓度。\n\n反应方案可以写作：\n$$ \\text{Spo0A} \\xrightarrow{k_{phos}} \\text{Spo0A~P} $$\n$$ \\text{Spo0A~P} \\xrightarrow{k_{dephos}} \\text{Spo0A} $$\n\nSpo0A~P 浓度的变化率 $\\frac{dS}{dt}$ 是其生成速率与消耗速率之差。\n\n生成速率是未磷酸化的 Spo0A ($S_u(t)$) 的磷酸化。这是一个关于 $S_u(t)$ 的伪一级反应：\n$$ \\text{Rate}_{\\text{formation}} = k_{phos} S_u(t) $$\n使用质量平衡关系 $S_u(t) = S_{tot} - S(t)$，我们可以用 $S(t)$ 表示生成速率：\n$$ \\text{Rate}_{\\text{formation}} = k_{phos} (S_{tot} - S(t)) $$\n\n消耗速率是 Spo0A~P ($S(t)$) 的去磷酸化。这是一个一级反应：\n$$ \\text{Rate}_{\\text{removal}} = k_{dephos} S(t) $$\n\n结合这些速率，我们构建了控制 $S(t)$ 时间演化的微分方程：\n$$ \\frac{dS}{dt} = \\text{Rate}_{\\text{formation}} - \\text{Rate}_{\\text{removal}} $$\n$$ \\frac{dS}{dt} = k_{phos} (S_{tot} - S(t)) - k_{dephos} S(t) $$\n\n为求解此方程，我们将其整理为线性一阶常微分方程的标准形式。\n$$ \\frac{dS}{dt} = k_{phos} S_{tot} - k_{phos} S(t) - k_{dephos} S(t) $$\n$$ \\frac{dS}{dt} = k_{phos} S_{tot} - (k_{phos} + k_{dephos}) S(t) $$\n$$ \\frac{dS}{dt} + (k_{phos} + k_{dephos}) S(t) = k_{phos} S_{tot} $$\n\n这是一个形式为 $\\frac{dy}{dt} + P(t)y = Q(t)$ 的非齐次线性常微分方程，其中 $y=S(t)$，$P(t) = k_{phos} + k_{dephos}$，$Q(t) = k_{phos} S_{tot}$。$P$ 和 $Q$ 均为常数。\n\n该方程的通解是齐次解与一个特解之和。当 $\\frac{dS}{dt} = 0$ 时，达到稳态浓度 $S_{ss}$。\n$$ 0 = k_{phos} S_{tot} - (k_{phos} + k_{dephos}) S_{ss} $$\n$$ S_{ss} = \\frac{k_{phos} S_{tot}}{k_{phos} + k_{dephos}} $$\n$S(t)$ 的通解可以写成趋近于该稳态的形式：\n$$ S(t) = S_{ss} + C \\exp(-(k_{phos} + k_{dephos})t) $$\n其中 $C$ 是一个积分常数，由初始条件 $S(0) = S_0$ 确定。\n$$ S(0) = S_0 = S_{ss} + C \\exp(0) = S_{ss} + C $$\n$$ C = S_0 - S_{ss} $$\n将 $C$ 代入通解，得到 $S(t)$ 的显式时间进程：\n$$ S(t) = S_{ss} + (S_0 - S_{ss}) \\exp(-(k_{phos} + k_{dephos})t) $$\n这可以改写为：\n$$ S(t) = S_{ss} - (S_{ss} - S_0) \\exp(-(k_{phos} + k_{dephos})t) $$\n\n问题指定我们需要找到时间 $t_{\\theta}$，使得 $S(t_{\\theta}) = \\theta$。我们在推导出的表达式中令 $S(t) = \\theta$ 和 $t = t_{\\theta}$：\n$$ \\theta = S_{ss} - (S_{ss} - S_0) \\exp(-(k_{phos} + k_{dephos})t_{\\theta}) $$\n\n现在，我们必须用代数方法求解 $t_{\\theta}$。\n$$ (S_{ss} - S_0) \\exp(-(k_{phos} + k_{dephos})t_{\\theta}) = S_{ss} - \\theta $$\n$$ \\exp(-(k_{phos} + k_{dephos})t_{\\theta}) = \\frac{S_{ss} - \\theta}{S_{ss} - S_0} $$\n\n对两边取自然对数 ($\\ln$)：\n$$ -(k_{phos} + k_{dephos})t_{\\theta} = \\ln\\left(\\frac{S_{ss} - \\theta}{S_{ss} - S_0}\\right) $$\n利用属性 $\\ln(1/x) = -\\ln(x)$，我们可以反转对数的参数以消去前面的负号：\n$$ t_{\\theta} = \\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{S_{ss} - S_0}{S_{ss} - \\theta}\\right) $$\n\n问题陈述保证了 $S(t)$ 单调增加并从下方穿过 $\\theta$，这意味着 $S_0  \\theta  S_{ss}$。这确保了对数内部分数的分子 ($S_{ss} - S_0$) 和分母 ($S_{ss} - \\theta$) 均为正值，并且由于 $S_0  \\theta$，因此有 $S_{ss} - S_0 > S_{ss} - \\theta$，使得对数的参数大于1。因此，$t_{\\theta}$ 是正的且良定的，这与物理时间的预期相符。\n\n最后，我们代入 $S_{ss}$ 的表达式，以获得用给定参数表示的最终答案：\n$$ t_{\\theta} = \\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{\\frac{k_{phos} S_{tot}}{k_{phos} + k_{dephos}} - S_0}{\\frac{k_{phos} S_{tot}}{k_{phos} + k_{dephos}} - \\theta}\\right) $$\n为简化对数内的表达式，我们为分子和分母找到一个公分母：\n$$ t_{\\theta} = \\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{\\frac{k_{phos} S_{tot} - S_0(k_{phos} + k_{dephos})}{k_{phos} + k_{dephos}}}{\\frac{k_{phos} S_{tot} - \\theta(k_{phos} + k_{dephos})}{k_{phos} + k_{dephos}}}\\right) $$\n$$ t_{\\theta} = \\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{k_{phos} S_{tot} - S_0(k_{phos} + k_{dephos})}{k_{phos} S_{tot} - \\theta(k_{phos} + k_{dephos})}\\right) $$\n\n这就是 $t_{\\theta}$ 的最终闭合形式解析表达式。如果速率常数 $k_{phos}$ 和 $k_{dephos}$ 的单位是 $\\text{min}^{-1}$，那么 $t_{\\theta}$ 的单位将是分钟，这满足了问题的描述要求。", "answer": "$$ \\boxed{ \\frac{1}{k_{phos} + k_{dephos}} \\ln \\left( \\frac{k_{phos} S_{tot} - S_0(k_{phos} + k_{dephos})}{k_{phos} S_{tot} - \\theta(k_{phos} + k_{dephos})} \\right) } $$", "id": "4629255"}, {"introduction": "一旦做出形成芽孢的决定，细胞必须精确地按顺序激活一系列基因。这一过程由一系列级联的 σ 因子调控。本练习将使用布尔网络这一系统生物学工具，来模拟这个级联反应中的逻辑依赖关系，通过构建和测试该模型，您将深入了解复杂的生物学过程是如何被有序且稳健地调控的 [@problem_id:4629277]。", "problem": "您的任务是构建并验证一个最小同步布尔网络，该网络需捕获细菌孢子形成过程中分隔化的σ因子级联反应，从传染病背景下Spo0A的激活开始，重点关注细菌孢子生物学。此问题必须根据调控逻辑的第一性原理解决，使用最少的节点集和单调相互作用，这些相互作用需反映关于孢子形成的公认事实。您的程序应构建一个具体的网络实例，在野生型和突变扰动下进行模拟，并验证其动态行为是否与典型的突变表型一致。\n\n基本原理与建模约束。使用同步布尔网络 (SBN)，其中每个节点是一个布尔变量，其状态在离散时间步长中演化。对于节点$X$，其在时间$t$的状态（表示为$X(t) \\in \\{0,1\\}$）由一个确定性布尔函数使用来自时间$t$的输入进行更新。该网络必须由对应以下生物实体和状态的节点组成：Spo0A（表示为$A$）、σ因子$\\sigma^{\\mathrm{F}}$（表示为$F$）、SpoIIR（表示为$R$）、σ因子$\\sigma^{\\mathrm{E}}$（表示为$E$）、吞噬完成（表示为$G_{\\mathrm{eng}}$）、σ因子$\\sigma^{\\mathrm{G}}$（表示为$G$）、SpoIVB蛋白酶（表示为$B$）和σ因子$\\sigma^{\\mathrm{K}}$（表示为$K$）。您选择的更新规则必须在激活方面是单调的（在激活因子之间仅使用逻辑合取和析取，并可选择性地进行自我维持以保持已激活的状态），并且必须反映以下经过充分验证的生物学事实：\n- Spo0A的激活先于$\\sigma^{\\mathrm{F}}$的激活，并且是其激活的必要条件。\n- $\\sigma^{\\mathrm{F}}$的活性是SpoIIR产生的必要条件。\n- SpoIIR的活性是在母细胞中激活$\\sigma^{\\mathrm{E}}$的必要条件。\n- $\\sigma^{\\mathrm{E}}$的活性驱动吞噬过程，最终达到吞噬完成状态。\n- 在前孢子中激活$\\sigma^{\\mathrm{G}}$需要吞噬完成以及依赖于$\\sigma^{\\mathrm{E}}$的因子。\n- SpoIVB的产生需要$\\sigma^{\\mathrm{G}}$。\n- 在母细胞中激活$\\sigma^{\\mathrm{K}}$需要依赖于$\\sigma^{\\mathrm{E}}$的加工过程以及来自前孢子的SpoIVB信号。\n\n初始条件、更新语义和强制。使用时间$t=0$时的初始状态，其中$A(0)=1$，所有其他节点设置为$0$。对所有节点使用同步更新。为了模拟突变体，您必须允许节点强制：一组节点在所有$t \\ge 0$的时间里保持固定的布尔值，这会覆盖这些节点的任何更新逻辑；例如，$\\sigma^{\\mathrm{F}}$的删除突变体通过在所有$t \\ge 0$的时间里强制$F(t)=0$来建模。\n\n时序目标和验证谓词。您的模型必须在野生型条件下重现有序的级联反应：必须存在严格递增的激活时间 $t_F  t_E  t_G  t_K$，在这些时间点$F$、然后$E$、然后$G$、然后$K$首次变为激活状态（即首次达到值$1$）。在突变体中，您的模型必须重现上述事实所暗示的典型阻断表型。您应该在一个有限的时间范围$T$步内进行模拟，该范围要足够大以允许激活在可能的情况下传播，设置$T$为$12$。\n\n测试套件。实现以下测试用例，每个用例由一组节点强制约束定义；对于每个用例，在同步更新下模拟网络从$t=0$到$t=T$的演化，并评估相应的谓词，得出布尔结果：\n- 用例1（野生型）：无强制。谓词：存在首次激活时间 $t_F, t_E, t_G, t_K \\in \\{0,1,\\dots,T\\}$，满足 $t_F  t_E  t_G  t_K$。\n- 用例2（Spo0A删除）：在所有$t \\ge 0$时强制$A(t)=0$。谓词：$F$、$E$、$G$和$K$在$\\{0,1,\\dots,T\\}$内从未激活。\n- 用例3（$\\sigma^{\\mathrm{F}}$删除）：在所有$t \\ge 0$时强制$F(t)=0$。谓词：$E$、$G$和$K$在$\\{0,1,\\dots,T\\}$内从未激活。\n- 用例4（SpoIIR删除）：在所有$t \\ge 0$时强制$R(t)=0$。谓词：$E$、$G$和$K$在$\\{0,1,\\dots,T\\}$内从未激活。\n- 用例5（吞噬受损）：在所有$t \\ge 0$时强制$G_{\\mathrm{eng}}(t)=0$。谓词：$E$在某个$t \\in \\{0,1,\\dots,T\\}$激活，但$G$和$K$从未激活。\n- 用例6（SpoIVB删除）：在所有$t \\ge 0$时强制$B(t)=0$。谓词：$E$和$G$都在$\\{0,1,\\dots,T\\}$内的某个时间激活，但$K$从未激活。\n\n输出格式。您的程序应生成单行输出，其中包含按用例1到6的顺序排列的结果，形式为用方括号括起来的逗号分隔列表。每个条目必须是一个布尔字面量。例如，六个用例的输出形式为`[b_1,b_2,b_3,b_4,b_5,b_6]`，其中每个$b_i$是True或False。此问题不涉及单位。角度和百分比不适用。您的程序不得读取任何输入。", "solution": "该问题要求构建并验证一个最小同步布尔网络 (SBN)，以模拟细菌孢子形成中的σ因子级联反应。该模型必须根据调控逻辑的第一性原理构建，遵守指定的生物学约束，并根据典型的野生型和突变表型进行测试。\n\n首先，我们对系统进行形式化。网络在任何离散时间步长$t$的状态由一个包含8个布尔变量的向量给出：\n$S(t) = (A(t), F(t), R(t), E(t), G_{\\mathrm{eng}}(t), G(t), B(t), K(t))$，其中每个分量都在$\\{0, 1\\}$中。节点缩写对应于Spo0A ($A$)、$\\sigma^{\\mathrm{F}}$ ($F$)、SpoIIR ($R$)、$\\sigma^{\\mathrm{E}}$ ($E$)、吞噬完成 ($G_{\\mathrm{eng}}$)、$\\sigma^{\\mathrm{G}}$ ($G$)、SpoIVB ($B$) 和 $\\sigma^{\\mathrm{K}}$ ($K$)。系统根据同步更新规则 $S(t+1) = \\mathbf{f}(S(t))$ 演化，其中$\\mathbf{f}$是一个布尔更新函数的向量。\n\n更新函数的构建遵循所提供的生物学事实和建模约束。约束要求使用单调逻辑（仅使用合取和析取），并允许可选的自我维持，以保持已激活的状态。对此进行建模的一个标准方法是$X(t+1) = X(t) \\lor \\text{激活逻辑}(t)$，确保一旦节点变为$1$，它就保持为$1$。这反映了孢子形成过程中发育检查点的不可逆性。“...的必要条件”这一生物学规则在激活逻辑中被转换为合取（$\\land$）。\n\n基于这些原则，我们定义最小更新规则：\n\n1.  **Spo0A ($A$)**：$A$是主调控因子，在开始时即被激活。在这个最小模型中，它不受其他节点调控，因此它会维持自身状态。\n    $$A(t+1) = A(t)$$\n2.  **$\\sigma^{\\mathrm{F}}$ ($F$)**：激活需要Spo0A ($A$) 。\n    $$F(t+1) = F(t) \\lor A(t)$$\n3.  **SpoIIR ($R$)**：产生需要$\\sigma^{\\mathrm{F}}$ ($F$) 。\n    $$R(t+1) = R(t) \\lor F(t)$$\n4.  **$\\sigma^{\\mathrm{E}}$ ($E$)**：激活需要SpoIIR ($R$) 。\n    $$E(t+1) = E(t) \\lor R(t)$$\n5.  **吞噬 ($G_{\\mathrm{eng}}$)**：完成由$\\sigma^{\\mathrm{E}}$ ($E$) 驱动。\n    $$G_{\\mathrm{eng}}(t+1) = G_{\\mathrm{eng}}(t) \\lor E(t)$$\n6.  **$\\sigma^{\\mathrm{G}}$ ($G$)**：激活需要吞噬完成 ($G_{\\mathrm{eng}}$) 和依赖于$\\sigma^{\\mathrm{E}}$的因子 ($E$) 两者。\n    $$G(t+1) = G(t) \\lor (G_{\\mathrm{eng}}(t) \\land E(t))$$\n7.  **SpoIVB ($B$)**：产生需要$\\sigma^{\\mathrm{G}}$ ($G$) 。\n    $$B(t+1) = B(t) \\lor G(t)$$\n8.  **$\\sigma^{\\mathrm{K}}$ ($K$)**：激活需要来自前孢子经由SpoIVB ($B$) 的信号，以及在母细胞中依赖于$\\sigma^{\\mathrm{E}}$ ($E$) 的加工过程。\n    $$K(t+1) = K(t) \\lor (E(t) \\land B(t))$$\n\n模拟从$t=0$时的初始状态开始，此时$A(0)=1$，所有其他节点均为$0$。对于突变体分析，特定节点在所有时间步长$t \\ge 0$中被“强制”为固定值（$0$或$1$），这会覆盖它们的更新规则。模拟在一个$T=12$步长的时间范围内运行。\n\n为实现该解决方案，一个程序将针对六个测试用例中的每一个来模拟网络动态。对于每个用例，程序将：\n1.  初始化一个用于$t \\in \\{0, 1, \\dots, T\\}$的状态历史数组。初始状态$S(0)$被设置为$(1, 0, 0, 0, 0, 0, 0, 0)$。\n2.  应用特定测试用例的任何强制规则，这可能会修改初始状态，并将在随后的每一步中覆盖更新。\n3.  使用上面定义的布尔函数，对$t = 0, \\dots, T-1$迭代计算$S(t+1)$自$S(t)$。计算出新状态后，应用强制规则。\n4.  模拟结束后，分析状态历史以评估该测试用例对应的布尔谓词。\n\n例如，为了评估野生型谓词（用例1），我们找到每个节点$X \\in \\{F, E, G, K\\}$从$0$转换到$1$的第一个时间步长$t_X$。然后我们验证严格不等式$t_F  t_E  t_G  t_K$是否成立。对于突变体用例，谓词涉及检查某些节点是否在模拟过程中的任何时刻被激活，或者始终保持非激活状态。例如，在$A$删除突变体（用例2）中，我们检查状态历史中$F, E, G, K$对应的列是否只包含零。最终输出是六个谓词中每一个的布尔结果列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs, simulates, and validates a Boolean network model of\n    bacterial sporulation sigma factor cascade.\n    \"\"\"\n    \n    # Node mapping to indices in the state vector\n    NODE_MAP = {\n        'A': 0, 'F': 1, 'R': 2, 'E': 3, \n        'G_eng': 4, 'G': 5, 'B': 6, 'K': 7\n    }\n    NUM_NODES = len(NODE_MAP)\n    T = 12  # Simulation horizon\n\n    def get_update_rules(state):\n        \"\"\"\n        Calculates the next state based on the current state.\n        state: np.ndarray of shape (NUM_NODES,)\n        \"\"\"\n        A, F, R, E, G_eng, G, B, K = state\n        \n        next_state = np.zeros_like(state)\n        \n        # Apply the update logic based on the derived Boolean functions\n        next_state[NODE_MAP['A']] = A or A  # Self-maintenance\n        next_state[NODE_MAP['F']] = F or A\n        next_state[NODE_MAP['R']] = R or F\n        next_state[NODE_MAP['E']] = E or R\n        next_state[NODE_MAP['G_eng']] = G_eng or E\n        next_state[NODE_MAP['G']] = G or (G_eng and E)\n        next_state[NODE_MAP['B']] = B or G\n        next_state[NODE_MAP['K']] = K or (E and B)\n        \n        return next_state\n\n    def simulate(forcing_rules: dict):\n        \"\"\"\n        Simulates the Synchronous Boolean Network.\n        forcing_rules: A dictionary mapping node names to their forced values.\n        \"\"\"\n        history = np.zeros((T + 1, NUM_NODES), dtype=bool)\n        \n        # Initial state at t=0\n        history[0, NODE_MAP['A']] = 1\n        \n        # Apply forcing at t=0\n        for node_name, value in forcing_rules.items():\n            history[0, NODE_MAP[node_name]] = value\n            \n        # Synchronous updates for t = 0 to T-1\n        for t in range(T):\n            # Calculate next state based on current state\n            next_state = get_update_rules(history[t])\n            \n            # Apply forcing rules to the new state\n            for node_name, value in forcing_rules.items():\n                next_state[NODE_MAP[node_name]] = value\n            \n            history[t + 1] = next_state\n            \n        return history\n\n    def find_first_activation(history, node_idx):\n        \"\"\"Finds the first time step a node becomes 1.\"\"\"\n        activations = np.where(history[:, node_idx] == 1)[0]\n        return activations[0] if len(activations) > 0 else float('inf')\n\n    # Define test cases with their specific forcing rules\n    test_cases = [\n        {'name': 'Case 1 (wild type)', 'forcing': {}},\n        {'name': 'Case 2 (Spo0A deletion)', 'forcing': {'A': 0}},\n        {'name': 'Case 3 (sigmaF deletion)', 'forcing': {'F': 0}},\n        {'name': 'Case 4 (SpoIIR deletion)', 'forcing': {'R': 0}},\n        {'name': 'Case 5 (engulfment-impaired)', 'forcing': {'G_eng': 0}},\n        {'name': 'Case 6 (SpoIVB deletion)', 'forcing': {'B': 0}},\n    ]\n\n    results = []\n    \n    for i, case in enumerate(test_cases):\n        history = simulate(case['forcing'])\n        \n        if i == 0:  # Case 1 Predicate\n            t_F = find_first_activation(history, NODE_MAP['F'])\n            t_E = find_first_activation(history, NODE_MAP['E'])\n            t_G = find_first_activation(history, NODE_MAP['G'])\n            t_K = find_first_activation(history, NODE_MAP['K'])\n            # Check for activation within horizon and strict ordering\n            predicate_val = (t_F  t_E  t_G  t_K) and (t_K = T)\n            results.append(predicate_val)\n        \n        elif i == 1:  # Case 2 Predicate\n            # Check if F, E, G, K never activate\n            never_active = np.all(history[:, [NODE_MAP['F'], NODE_MAP['E'], NODE_MAP['G'], NODE_MAP['K']]] == 0)\n            results.append(never_active)\n            \n        elif i == 2:  # Case 3 Predicate\n            # Check if E, G, K never activate\n            never_active = np.all(history[:, [NODE_MAP['E'], NODE_MAP['G'], NODE_MAP['K']]] == 0)\n            results.append(never_active)\n\n        elif i == 3:  # Case 4 Predicate\n            # Check if E, G, K never activate\n            never_active = np.all(history[:, [NODE_MAP['E'], NODE_MAP['G'], NODE_MAP['K']]] == 0)\n            results.append(never_active)\n            \n        elif i == 4:  # Case 5 Predicate\n            # E activates, but G and K never activate\n            e_activates = np.any(history[:, NODE_MAP['E']] == 1)\n            g_k_never_active = np.all(history[:, [NODE_MAP['G'], NODE_MAP['K']]] == 0)\n            results.append(e_activates and g_k_never_active)\n            \n        elif i == 5:  # Case 6 Predicate\n            # E and G activate, but K never activates\n            e_activates = np.any(history[:, NODE_MAP['E']] == 1)\n            g_activates = np.any(history[:, NODE_MAP['G']] == 1)\n            k_never_activates = np.all(history[:, NODE_MAP['K']] == 0)\n            results.append(e_activates and g_activates and k_never_activates)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4629277"}, {"introduction": "芽孢形成的最终产物是一种具有极高抗性的细胞，这给医疗和食品安全带来了挑战。本练习将探讨用于设计灭菌流程的定量方法。您将推导并应用 D 值和 z 值的概念，这些是确保有效杀灭传染性芽孢的基础 [@problem_id:4629224]。", "problem": "罐装低酸性食品的加工过程旨在灭活与传染病相关的耐热细菌孢子。假设在等温暴露条件下，孢子的灭活遵循活菌数一级动力学。在温度为 $T$ 时的十进制缩减时间（D值），记为 $D(T)$，定义为在该温度 $T$ 下将活菌数减少10倍所需的暴露时间。$z$值定义为使D值减少10倍所需的温度升高值。\n\n请仅使用这些核心定义和一级灭活动力学假设，从第一性原理推导出 $D(T)$ 的显式表达式，该表达式应使用参考温度 $T_{\\mathrm{ref}}$ 下的参考D值 $D_{\\mathrm{ref}}$、$z$值 $z$ 和目标温度 $T$ 来表示。然后，使用您推导出的关系式，计算当孢子的参考D值 $D_{\\mathrm{ref}} = 0.600\\,\\mathrm{min}$（在参考温度 $T_{\\mathrm{ref}} = 121\\,^{\\circ}\\mathrm{C}$下）、$z$值 $z = 8.5\\,^{\\circ}\\mathrm{C}$，且目标温度为 $T = 115\\,^{\\circ}\\mathrm{C}$ 时的 $D(T)$。\n\n将您的最终数值答案四舍五入至三位有效数字，并以分钟为单位表示时间。您的最终答案必须是一个实数。", "solution": "该问题是有效的，因为它科学地基于热力致死时间动力学原理，这是食品微生物学中用于确保免受产芽孢细菌等传染性病原体危害的一种标准方法。该问题是适定的，提供了推导所需表达式和计算数值结果所需的所有必要定义和数据。\n\n推导过程从所提供的基本原理出发。\n\n首先，我们将“孢子灭活遵循一级动力学”这一陈述形式化。设 $N(t)$ 为在温度 $T$ 下的等温过程中，时间 $t$ 时的活孢子数。灭活速率由以下微分方程给出：\n$$\n-\\frac{dN(t)}{dt} = k(T) N(t)\n$$\n其中 $k(T)$ 是与温度相关的一级速率常数。我们可以通过分离变量法求解该方程，从时间 $t=0$（初始孢子数为 $N(0)=N_0$）积分到稍后的时间 $t$：\n$$\n\\int_{N_0}^{N(t)} \\frac{dN}{N} = -\\int_{0}^{t} k(T) dt'\n$$\n由于温度 $T$ 是恒定的，所以 $k(T)$ 相对于时间也是一个常数。积分得出：\n$$\n\\ln\\left(\\frac{N(t)}{N_0}\\right) = -k(T)t\n$$\n\n接下来，我们使用十进制缩减时间 $D(T)$ 的定义。这是将活菌数减少10倍所需的时间。在 $t = D(T)$ 时，我们有 $N(D(T)) = \\frac{N_0}{10}$。将此条件代入积分速率方程：\n$$\n\\ln\\left(\\frac{N_0/10}{N_0}\\right) = -k(T)D(T)\n$$\n$$\n\\ln\\left(\\frac{1}{10}\\right) = -k(T)D(T)\n$$\n$$\n-\\ln(10) = -k(T)D(T)\n$$\n这给出了D值和速率常数之间的关系：\n$$\nD(T) = \\frac{\\ln(10)}{k(T)}\n$$\n\n现在，我们使用z值的定义。z值是使D值减少10倍所需的温度升高值。该定义意味着 $\\log(D)$ 和 $T$ 之间存在特定的关系。在热处理中，这被建模为D值的常用对数（以10为底）与温度之间的线性关系。也就是说，$\\log_{10}(D(T))$ 相对于 $T$ 的图像是一条直线。\n\n让我们考虑这条直线上的两个点：$(T_1, \\log_{10}(D(T_1)))$ 和 $(T_2, \\log_{10}(D(T_2)))$。这条直线的斜率是：\n$$\nm = \\frac{\\log_{10}(D(T_2)) - \\log_{10}(D(T_1))}{T_2 - T_1}\n$$\n根据z值的定义，如果我们将温度升高 $z$，即 $T_2 - T_1 = z$，则D值将减少10倍，因此 $D(T_2) = \\frac{D(T_1)}{10}$。将此代入斜率方程的分子中：\n$$\n\\log_{10}(D(T_2)) - \\log_{10}(D(T_1)) = \\log_{10}\\left(\\frac{D(T_1)}{10}\\right) - \\log_{10}(D(T_1)) = \\log_{10}\\left(\\frac{1}{10}\\right) = -1\n$$\n因此，该直线的斜率为 $m = \\frac{-1}{z}$。\n\n使用参考点 $(T_{\\mathrm{ref}}, \\log_{10}(D_{\\mathrm{ref}}))$ 和一个通用点 $(T, \\log_{10}(D(T)))$ 的点斜式方程，我们得到：\n$$\n\\log_{10}(D(T)) - \\log_{10}(D_{\\mathrm{ref}}) = m(T - T_{\\mathrm{ref}})\n$$\n代入 $m = -1/z$：\n$$\n\\log_{10}(D(T)) - \\log_{10}(D_{\\mathrm{ref}}) = -\\frac{1}{z}(T - T_{\\mathrm{ref}})\n$$\n$$\n\\log_{10}\\left(\\frac{D(T)}{D_{\\mathrm{ref}}}\\right) = -\\frac{T - T_{\\mathrm{ref}}}{z}\n$$\n为了得到 $D(T)$ 的显式表达式，我们对等式两边取反对数（以10为底）：\n$$\n\\frac{D(T)}{D_{\\mathrm{ref}}} = 10^{-\\frac{T - T_{\\mathrm{ref}}}{z}}\n$$\n这可以重新整理得到所需的 $D(T)$ 表达式：\n$$\nD(T) = D_{\\mathrm{ref}} \\cdot 10^{\\frac{T_{\\mathrm{ref}} - T}{z}}\n$$\n这就是从第一性原理推导出的所需表达式。\n\n现在，我们使用这个关系式来计算给定参数下的 $D(T)$ 值：\n- 参考D值，$D_{\\mathrm{ref}} = 0.600\\,\\mathrm{min}$\n- 参考温度，$T_{\\mathrm{ref}} = 121\\,^{\\circ}\\mathrm{C}$\n- z值，$z = 8.5\\,^{\\circ}\\mathrm{C}$\n- 目标温度，$T = 115\\,^{\\circ}\\mathrm{C}$\n\n将这些值代入推导出的公式中：\n$$\nD(115\\,^{\\circ}\\mathrm{C}) = 0.600 \\cdot 10^{\\frac{121 - 115}{8.5}}\n$$\n指数中的温差为 $T_{\\mathrm{ref}} - T = 121 - 115 = 6\\,^{\\circ}\\mathrm{C}$。\n$$\nD(115\\,^{\\circ}\\mathrm{C}) = 0.600 \\cdot 10^{\\frac{6}{8.5}}\n$$\n我们现在计算数值：\n$$\n\\frac{6}{8.5} \\approx 0.70588235...\n$$\n$$\n10^{6/8.5} \\approx 10^{0.70588235...} \\approx 5.08010...\n$$\n$$\nD(115\\,^{\\circ}\\mathrm{C}) \\approx 0.600 \\times 5.08010... \\approx 3.04806...\n$$\n问题要求将最终答案四舍五入到三位有效数字。计算出的值为 $3.04806...\\,\\mathrm{min}$。四舍五入到三位有效数字得到 $3.05$。单位是分钟。", "answer": "$$\\boxed{3.05}$$", "id": "4629224"}]}