{"hands_on_practices": [{"introduction": "T细胞的活化始于识别细胞表面的肽-MHC复合物，但这些复合物的丰度本身是一个动态过程的结果。本练习要求你构建一个动力学模型，整合蛋白酶体加工、TAP转运、肽段降解和MHC结合等多个步骤，来预测受感染细胞表面特定抗原表位的稳态数量。通过这个计算，你将能够量化地理解抗原呈递通路中各个环节如何共同决定T细胞所能“看到”的抗原景观。", "problem": "细胞毒性T淋巴细胞（CTL）通过扫描细胞表面，识别呈递胞内病原体衍生表位的肽-I类主要组织相容性复合物（MHC I）复合物，从而识别受感染的细胞。考虑一个通过MHC I途径呈递特定病毒表位的单一受感染人体细胞。假设以下具有科学依据的事实为基本前提：\n\n- 蛋白酶体加工在胞质溶胶中以每细胞每秒 $R$ 个肽的速率生成表位肽。\n- 抗原加工相关转运体（TAP）将这些肽的一部分（比例为 $f$）转运到内质网（ER）中。\n- 在内质网中，一个肽经历两个独立的、无记忆（指数）过程：以降解速率 $d$（每秒）降解，以及与一个游离的MHC I分子结合。对于单个肽，其结合风险与游离MHC I分子的数量成正比，比例常数为 $\\alpha$（每秒每游离MHC I分子）。如果有 $M_{\\text{free}}$ 个游离MHC I分子，则一个肽的瞬时结合速率为 $\\lambda_{\\text{bind}} = \\alpha M_{\\text{free}}$。\n- 肽-MHC I复合物一旦形成，会通过两个途径丢失：以速率常数 $k_{\\text{off}}$ 解离，以及以速率常数 $k_{\\text{int}}$ 从质膜内吞。解离速率通过 $k_{\\text{off}} = \\ln(2)/t_{1/2}$ 与测得的复合物半衰期 $t_{1/2}$ 相关。\n\n仅使用这些事实，从第一性原理推导细胞表面上特定表位的肽-MHC I复合物的预期稳态丰度表达式。然后，使用以下适用于人类淋巴细胞的参数值对其进行评估：\n\n- 蛋白酶体表位生成速率：$R = 100$ 肽/秒/细胞。\n- TAP转运效率：$f = 0.30$。\n- 内质网肽降解速率：$d = 0.50$ /秒。\n- 可用于结合此表位的游离MHC I分子：$M_{\\text{free}} = 1.0 \\times 10^{4}$ 分子/细胞。\n- 有效结合比例常数：$\\alpha = 1.0 \\times 10^{-4}$ /秒/游离MHC I分子。\n- 肽-MHC I复合物半衰期：$t_{1/2} = 3600$ 秒。\n- MHC I内吞速率：$k_{\\text{int}} = 1.0 \\times 10^{-4}$ /秒。\n\n假设系统处于稳态，内质网和质膜上空间均匀，指数损失过程相互独立，并且 $M_{\\text{free}}$ 不受此单一表位物种结合的显著影响。报告每个细胞上特定表位的肽-MHC I复合物的最终预期数量，四舍五入至三位有效数字，并以“分子/细胞”为单位表示答案。\n\n此外，简要指出两个可能导致此估计失效的生物学因素或假设。您的指认不改变所要求的最终数值答案。", "solution": "问题陈述具有科学依据、提法明确且客观。它提出了一个标准的抗原呈递动力学模型，提供了推导唯一、有意义解所需的所有参数和假设。因此，该问题被认为是有效的。\n\n该解是通过将系统建模为处于稳态的两阶段动力学过程来推导的。\n\n首先，我们考虑内质网（ER）中表位肽的群体。设 $P_{\\text{ER}}$ 为内质网中这些肽的数量。$P_{\\text{ER}}$ 的变化率由其从胞质溶胶的流入与其因降解或与I类主要组织相容性复合物（MHC I）分子结合而导致的损失之间的平衡决定。\n\n蛋白酶体的表位生成速率为 $R$。一部分比例为 $f$ 的肽被抗原加工相关转运体（TAP）转运到内质网中。因此，肽流入内质网的速率为 $fR$。\n内质网中的肽经历两个独立的一级损失过程：\n1. 降解，速率常数为 $d$。群体 $P_{\\text{ER}}$ 的总降解速率为 $d P_{\\text{ER}}$。\n2. 与游离MHC I分子结合。单个肽的结合风险率（hazard rate）为 $\\lambda_{\\text{bind}} = \\alpha M_{\\text{free}}$，其中 $M_{\\text{free}}$ 是可用的游离MHC I分子的数量，$\\alpha$ 是比例常数。群体 $P_{\\text{ER}}$ 的总结合速率为 $(\\alpha M_{\\text{free}}) P_{\\text{ER}}$。\n\n描述内质网中肽数量的微分方程是：\n$$ \\frac{dP_{\\text{ER}}}{dt} = fR - dP_{\\text{ER}} - (\\alpha M_{\\text{free}})P_{\\text{ER}} = fR - (d + \\alpha M_{\\text{free}})P_{\\text{ER}} $$\n在稳态下，$\\frac{dP_{\\text{ER}}}{dt} = 0$。求解稳态肽群体 $P_{\\text{ER,ss}}$：\n$$ fR = (d + \\alpha M_{\\text{free}})P_{\\text{ER,ss}} $$\n$$ P_{\\text{ER,ss}} = \\frac{fR}{d + \\alpha M_{\\text{free}}} $$\n我们记作 $\\text{Rate}_{\\text{form}}$ 的内质网中新肽-MHC I复合物的形成速率，即为稳态下的总结合速率：\n$$ \\text{Rate}_{\\text{form}} = (\\alpha M_{\\text{free}}) P_{\\text{ER,ss}} = \\frac{fR \\alpha M_{\\text{free}}}{d + \\alpha M_{\\text{free}}} $$\n此表达式代表每秒产生的新复合物数量。\n\n接下来，我们考虑细胞表面上这些特定肽-MHC I复合物的群体，记为 $C_{\\text{surf}}$。我们假设新形成的复合物从内质网到细胞表面的转运是快速的，且非速率限制步骤。因此，复合物到达表面的速率等于其形成速率 $\\text{Rate}_{\\text{form}}$。\n\n这些表面复合物通过两个独立的过程丢失：\n1. 肽的解离，速率常数为 $k_{\\text{off}}$。\n2. 复合物从质膜的内吞，速率常数为 $k_{\\text{int}}$。\n\n由于这些是独立的一级过程，单个复合物的总损失速率常数为 $k_{\\text{loss}} = k_{\\text{off}} + k_{\\text{int}}$。表面群体 $C_{\\text{surf}}$ 的总损失速率为 $(k_{\\text{off}} + k_{\\text{int}})C_{\\text{surf}}$。\n\n表面复合物数量的微分方程为：\n$$ \\frac{dC_{\\text{surf}}}{dt} = \\text{Rate}_{\\text{form}} - (k_{\\text{off}} + k_{\\text{int}})C_{\\text{surf}} $$\n在稳态下，$\\frac{dC_{\\text{surf}}}{dt} = 0$。求解表面复合物的稳态丰度 $C_{\\text{surf,ss}}$：\n$$ \\text{Rate}_{\\text{form}} = (k_{\\text{off}} + k_{\\text{int}})C_{\\text{surf,ss}} $$\n$$ C_{\\text{surf,ss}} = \\frac{\\text{Rate}_{\\text{form}}}{k_{\\text{off}} + k_{\\text{int}}} $$\n代入 $\\text{Rate}_{\\text{form}}$ 的表达式，我们得到最终的解析表达式：\n$$ C_{\\text{surf,ss}} = \\left( \\frac{1}{k_{\\text{off}} + k_{\\text{int}}} \\right) \\left( \\frac{fR \\alpha M_{\\text{free}}}{d + \\alpha M_{\\text{free}}} \\right) $$\n解离速率常数 $k_{\\text{off}}$ 与半衰期 $t_{1/2}$ 的关系为 $k_{\\text{off}} = \\frac{\\ln(2)}{t_{1/2}}$。代入此式得：\n$$ C_{\\text{surf,ss}} = \\left( \\frac{1}{\\frac{\\ln(2)}{t_{1/2}} + k_{\\text{int}}} \\right) \\left( \\frac{fR \\alpha M_{\\text{free}}}{d + \\alpha M_{\\text{free}}} \\right) $$\n\n现在，我们使用给定的参数值来评估此表达式：\n- $R = 100 \\text{ s}^{-1}$\n- $f = 0.30$\n- $d = 0.50 \\text{ s}^{-1}$\n- $M_{\\text{free}} = 1.0 \\times 10^{4}$\n- $\\alpha = 1.0 \\times 10^{-4} \\text{ s}^{-1} \\text{molecule}^{-1}$\n- $t_{1/2} = 3600 \\text{ s}$\n- $k_{\\text{int}} = 1.0 \\times 10^{-4} \\text{ s}^{-1}$\n\n首先，我们计算中间项：\n内质网中肽的结合速率：\n$$ \\alpha M_{\\text{free}} = (1.0 \\times 10^{-4} \\text{ s}^{-1}) \\times (1.0 \\times 10^{4}) = 1.0 \\text{ s}^{-1} $$\n复合物的形成速率：\n$$ \\text{Rate}_{\\text{form}} = \\frac{fR (\\alpha M_{\\text{free}})}{d + \\alpha M_{\\text{free}}} = \\frac{(0.30)(100)(1.0)}{0.50 + 1.0} = \\frac{30}{1.5} = 20 \\text{ s}^{-1} $$\n解离速率常数：\n$$ k_{\\text{off}} = \\frac{\\ln(2)}{t_{1/2}} = \\frac{\\ln(2)}{3600} \\text{ s}^{-1} $$\n表面复合物的总损失速率常数：\n$$ k_{\\text{loss}} = k_{\\text{off}} + k_{\\text{int}} = \\frac{\\ln(2)}{3600} + 1.0 \\times 10^{-4} \\text{ s}^{-1} $$\n最后，我们计算表面复合物的稳态数量：\n$$ C_{\\text{surf,ss}} = \\frac{\\text{Rate}_{\\text{form}}}{k_{\\text{loss}}} = \\frac{20}{\\frac{\\ln(2)}{3600} + 1.0 \\times 10^{-4}} $$\n$$ C_{\\text{surf,ss}} = \\frac{20 \\times 3600}{\\ln(2) + 3600 \\times (1.0 \\times 10^{-4})} = \\frac{72000}{\\ln(2) + 0.36} $$\n使用 $\\ln(2) \\approx 0.693147$ 的值：\n$$ C_{\\text{surf,ss}} \\approx \\frac{72000}{0.693147 + 0.36} = \\frac{72000}{1.053147} \\approx 68369.34 $$\n四舍五入至三位有效数字，每个细胞上特定表位的肽-MHC I复合物的预期数量为 $6.84 \\times 10^4$。\n\n按要求，指出两个可能导致此估计失效的因素或假设：\n1.  **对MHC I分子的竞争：** 该模型假设 $M_{\\text{free}}$ 是恒定的。在受感染的细胞中，数千种源自病毒和宿主蛋白的不同肽种类会竞争有限的MHC I分子池。其他肽的高浓度会耗尽可用的 $M_{\\text{free}}$，从而降低所研究的特定表位的结合概率。这将导致表面丰度低于预测值。\n2.  **胞内转运的动力学：** 该模型隐含地假设新形成的复合物从内质网到细胞表面的转运是瞬时的。实际上，这种通过分泌途径（内质网到高尔基体再到质膜）的运输涉及显著的时间延迟，量级为数十分钟。模型中没有考虑这种延迟和潜在的低效率（例如，运输过程中的降解），包含这些因素将导致预测的表面丰度降低，并在其出现上产生延迟。", "answer": "$$ \\boxed{6.84 \\times 10^4} $$", "id": "4696770"}, {"introduction": "初始CD4+ T细胞在不同细胞因子环境下会分化为具有不同功能的效应亚群，例如促炎的Th17细胞或抑制性的Treg细胞。这一细胞命运的抉择由复杂的基因调控网络控制，而不仅仅是简单的线性通路。本练习将带你进入计算系统生物学的世界，通过编写代码来模拟由转录因子FOXP3和RORγt构成的核心调控回路，并探索在不同信号（TGF-β和IL-6）输入下，该系统如何产生“全或无”的双稳态开关效应。", "problem": "您需要构建并分析一个最小化的、无量纲的基因调控网络，该网络用于描述在转化生长因子-β (TGF-β) 和白细胞介素-6 (IL-6) 存在下，T辅助17细胞与调节性T细胞之间的命运决定过程。两个关键转录因子分别是叉头框蛋白P3 (Forkhead Box P3, FOXP3)（由变量 $x$ 表示）和视黄酸相关孤儿受体γt (Retinoic acid–related orphan receptor gamma t, ROR$\\gamma$t)（由变量 $y$ 表示）。该模型必须源自基因调控的基本原理：其产生过程通过S型激活函数由输入信号控制，通过S型抑制函数实现相互抑制，其清除过程则为一级衰减。\n\n基于以下经过充分检验的基础理论：\n- 分子生物学的中心法则：信号传导控制转录因子的产生，而转录因子会随时间衰减，从而导致其浓度的动态变化。\n- Hill型激活和抑制是描述转录调控中协同结合效应的标准稳态近似方法。\n- 常微分方程将转录因子浓度的变化率表达为产生速率与降解速率之差。\n\n将 $x$ 和 $y$ 的动力学定义如下：\n$$\n\\frac{dx}{dt} = \\left(b_x + a_{T} \\cdot H_{\\text{act}}(S_T;K_S,n_S)\\right)\\cdot H_{\\text{rep}}(y;K_{yx},n_{yx}) - d_x \\, x,\n$$\n$$\n\\frac{dy}{dt} = \\left(b_y + a_{S} \\cdot H_{\\text{act}}(S_L;K_S,n_S)\\cdot H_{\\text{act}}(S_T;K_S,n_S)\\right)\\cdot H_{\\text{rep}}(x;K_{xy},n_{xy}) - d_y \\, y,\n$$\n其中，$S_T$ 是无量纲的TGF-β水平，$S_L$ 是无量纲的IL-6水平，$H_{\\text{act}}$ 是Hill激活函数，$H_{\\text{rep}}$ 是Hill抑制函数，具体形式如下：\n$$\nH_{\\text{act}}(s;K,n) = \\frac{s^n}{K^n + s^n},\n\\quad\nH_{\\text{rep}}(z;K,n) = \\frac{1}{1 + \\left(\\frac{z}{K}\\right)^n}.\n$$\n所有变量和参数均为无量纲。常数 $b_x$ 和 $b_y$ 是基础产生强度，$a_{T}$ 是TGF-β诱导的FOXP3激活幅度，$a_{S}$ 是白细胞介素-6 (IL-6) 和TGF-β对ROR$\\gamma$t的协同激活幅度，$K_S$ 是两种信号的激活半饱和常数，$n_S$ 是信号激活的Hill系数，$K_{xy}$ 和 $K_{yx}$ 是抑制半饱和常数，$n_{xy}$ 和 $n_{yx}$ 是抑制的Hill系数。衰减速率为 $d_x$ 和 $d_y$。\n\n您的程序必须：\n1. 实现上述动力学系统。\n2. 对于测试套件中的每一组参数，通过以下步骤判断系统是否表现出双稳态：\n   - 在指定范围内对初始条件 $(x(0),y(0))$ 进行网格采样。\n   - 对每个初始条件，将动力学系统积分至稳态。\n   - 对不同的渐近终点进行聚类，以计算稳定吸引子的数量；当且仅当存在至少两个不同的、数据点充足的聚类（每个聚类必须至少包含三个终点）时，才报告为双稳态。\n3. 输出一行包含布尔值列表的结果，其中每个布尔值对应一个测试用例，如果系统是双稳态则为true，否则为false。\n\n对所有测试用例使用以下固定参数值：\n- $b_x = 0.02$, $b_y = 0.02$,\n- $a_{T} = 1.0$, $a_{S} = 2.0$,\n- $K_S = 0.5$, $n_S = 2$,\n- $K_{xy} = 0.2$, $K_{yx} = 0.2$,\n- $d_x = 1.0$, $d_y = 1.0$.\n\n将 $S_T$、$S_L$、$n_{xy}$ 和 $n_{yx}$ 视为每个测试用例中指定的变量。\n\n数值计算要求：\n- 初始条件网格：$x(0),y(0)$ 在 $[0,1.5]$ 范围内均匀采样，每个维度11个点。\n- 时间积分：从 $t=0$ 积分到 $t=200$（无量纲时间单位）；如果终点处导数的范数超过 $10^{-6}$，则将积分延长至 $t=600$。\n- 终点聚类：如果两个终点 $(x_1,y_1)$ 和 $(x_2,y_2)$ 满足 $\\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}  0.05$，则它们属于同一个聚类。只统计成员数不少于3个的聚类。\n\n测试套件（每个用例是一个元组 $(S_T,S_L,n_{xy},n_{yx})$）：\n- 用例A（正常路径，Treg细胞优势，单稳态）：$(1.0, 0.01, 4, 4)$。\n- 用例B（正常路径，Th17细胞优势，单稳态）：$(0.5, 1.0, 4, 4)$。\n- 用例C（双稳态候选，中等信号强度，强抑制协同性）：$(0.5, 0.5, 4, 4)$。\n- 用例D（边界情况，信号极弱，接近基础水平的单稳态）：$(0.01, 0.01, 4, 4)$。\n- 用例E（边界条件，中等信号强度，弱抑制协同性）：$(0.5, 0.5, 2, 2)$。\n\n您的程序应生成单行输出，其内容是一个包含在方括号中的、以逗号分隔的列表（例如，\"[true,false,true,false,false]\"）。输出必须是小写的布尔值 \"true\" 或 \"false\"，其中 \"true\" 表示双稳态，\"false\" 表示单稳态。所有量均为无量纲；本问题不涉及任何物理单位或角度。", "solution": "该问题要求分析一个动力学系统模型，该模型描述了T辅助17 (Th17) 细胞和调节性T (Treg) 细胞之间的命运决定过程。系统状态由两个关键转录因子的无量纲浓度描述：$x$ 代表叉头框蛋白P3 (Forkhead Box P3, FOXP3)，指示Treg细胞谱系；$y$ 代表视黄酸相关孤儿受体γt (ROR$\\gamma$t)，指示Th17细胞谱系。问题的核心是确定在给定的参数集下，系统是否表现出双稳态。\n\n首先，该问题经过验证，被认为是可靠的。它在科学上基于系统生物学的原理，使用常微分方程 (ODEs) 和Hill动力学来为基因调控网络建模。该问题是适定的，提供了所有必需的方程、参数和详细的数值计算步骤，确保了结果的唯一性和可验证性。所有术语都是客观且明确定义的。\n\n$x(t)$ 和 $y(t)$ 浓度的控制方程为：\n$$\n\\frac{dx}{dt} = \\left(b_x + a_{T} \\cdot H_{\\text{act}}(S_T;K_S,n_S)\\right)\\cdot H_{\\text{rep}}(y;K_{yx},n_{yx}) - d_x \\, x\n$$\n$$\n\\frac{dy}{dt} = \\left(b_y + a_{S} \\cdot H_{\\text{act}}(S_L;K_S,n_S)\\cdot H_{\\text{act}}(S_T;K_S,n_S)\\right)\\cdot H_{\\text{rep}}(x;K_{xy},n_{xy}) - d_y \\, y\n$$\n这些方程代表了产生过程与一级衰减（速率为 $d_x$ 和 $d_y$）之间的平衡。每个转录因子的产生受外部信号——TGF-β ($S_T$) 和 IL-6 ($S_L$)——以及 $x$ 和 $y$ 之间相互抑制的调控。该调控逻辑由S型的Hill函数捕捉：\n- $H_{\\text{act}}(s;K,n) = \\frac{s^n}{K^n + s^n}$ 模型化了激活过程，其中信号 $s$ 促进产生。\n- $H_{\\text{rep}}(z;K,n) = \\frac{1}{1 + \\left(\\frac{z}{K}\\right)^n}$ 模型化了抑制过程，其中转录因子 $z$ 抑制产生。\n\n当一个系统在同一组参数下能稳定在两个不同的稳态（吸引子）时，即出现双稳态。系统的最终状态取决于其初始条件。为判断系统是否为双稳态，我们遵循以下计算方法：\n\n1.  **状态空间探索**：我们无法解析地求解这个非线性系统。因此，我们从一组有代表性的初始条件出发，模拟其行为。在定义域 $[0, 1.5] \\times [0, 1.5]$ 上均匀采样一个包含 $11 \\times 11 = 121$ 个初始点 $(x(0), y(0))$ 的网格。\n\n2.  **数值积分**：对于每个初始条件，将常微分方程组随时间向前积分，直到达到稳态。我们使用 `scipy.integrate` 库中的一个数值求解器。首先进行积分，直到无量纲时间 $t=200$。\n\n3.  **收敛性验证**：处于稳态的系统其变化率为零。我们通过在模拟的终点计算导数向量的欧几里得范数 $\\sqrt{(\\frac{dx}{dt})^2 + (\\frac{dy}{dt})^2}$ 来验证收敛性。如果此范数超过 $10^{-6}$ 的容差，则意味着系统尚未稳定下来。在这种情况下，将从相同的初始条件开始，进行更长时间的积分（直至 $t=600$），以确保收敛。\n\n4.  **通过聚类识别吸引子**：得到的121个终点坐标代表了系统的吸引子。为了计算不同吸引子的数量，我们对这些点进行聚类。如果两个终点 $(x_1, y_1)$ 和 $(x_2, y_2)$ 之间的欧几里得距离小于0.05的阈值，即 $\\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}  0.05$，则认为它们属于同一个吸引子。这个过程将所有收敛到状态空间同一区域的终点归为一类。这等价于在一个图中寻找连通分量，其中点是图的顶点，任何两个距离小于阈值的顶点之间都存在一条边。\n\n5.  **双稳态评估**：最后一步是计算“数据点充足”的聚类数量，这些聚类被定义为包含至少3个终点的簇。当且仅当存在两个或更多此类数据点充足的聚类时，系统才被归类为双稳态。此条件确保所识别的吸引子是稳健的，而不是由单个孤立轨迹产生的假象。\n\n所提供的Python代码实现了这整个工作流程。对于问题中指定的每个测试用例，它都会执行这些步骤并确定系统是否为双稳态，最终以布尔值列表的形式输出结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Analyzes a gene regulatory network model for T-cell differentiation\n    to determine bistability across several parameter sets.\n    \"\"\"\n    \n    # Define fixed parameters for the model as dimensionless quantities.\n    FIXED_PARAMS = {\n        'b_x': 0.02, 'b_y': 0.02,\n        'a_T': 1.0, 'a_S': 2.0,\n        'K_S': 0.5, 'n_S': 2,\n        'K_xy': 0.2, 'K_yx': 0.2,\n        'd_x': 1.0, 'd_y': 1.0\n    }\n\n    # Define the test cases, each being a tuple of (S_T, S_L, n_xy, n_yx).\n    test_cases = [\n        (1.0, 0.01, 4, 4),  # Case A: Treg favored, monostable\n        (0.5, 1.0, 4, 4),   # Case B: Th17 favored, monostable\n        (0.5, 0.5, 4, 4),   # Case C: Bistability candidate\n        (0.01, 0.01, 4, 4), # Case D: Low signals, monostable basal\n        (0.5, 0.5, 2, 2),   # Case E: Weak repression cooperativity\n    ]\n\n    def h_act(s, k, n):\n        \"\"\"Hill activation function.\"\"\"\n        s_pow_n = s**n\n        return s_pow_n / (k**n + s_pow_n)\n\n    def h_rep(z, k, n):\n        \"\"\"Hill repression function.\"\"\"\n        return 1.0 / (1.0 + (z / k)**n)\n\n    def model_rhs(t, Z, s_t, s_l, n_xy, n_yx, p):\n        \"\"\"Right-hand side of the ODE system for the GRN.\"\"\"\n        x, y = Z\n        \n        # Production term for x (FOXP3)\n        prod_x_signal = p['b_x'] + p['a_T'] * h_act(s_t, p['K_S'], p['n_S'])\n        rep_on_x = h_rep(y, p['K_yx'], n_yx)\n        \n        # Production term for y (RORgt)\n        prod_y_signal = p['b_y'] + p['a_S'] * h_act(s_l, p['K_S'], p['n_S']) * h_act(s_t, p['K_S'], p['n_S'])\n        rep_on_y = h_rep(x, p['K_xy'], n_xy)\n        \n        dxdt = prod_x_signal * rep_on_x - p['d_x'] * x\n        dydt = prod_y_signal * rep_on_y - p['d_y'] * y\n        \n        return [dxdt, dydt]\n\n    def cluster_endpoints(points, threshold):\n        \"\"\"Clusters endpoints based on Euclidean distance.\"\"\"\n        n_points = len(points)\n        if n_points == 0:\n            return []\n        \n        # Build adjacency matrix based on proximity\n        adj = np.zeros((n_points, n_points), dtype=bool)\n        for i in range(n_points):\n            for j in range(i + 1, n_points):\n                dist = np.linalg.norm(points[i] - points[j])\n                if dist  threshold:\n                    adj[i, j] = adj[j, i] = True\n        \n        # Find connected components (clusters) using BFS\n        visited = [False] * n_points\n        clusters = []\n        for i in range(n_points):\n            if not visited[i]:\n                component_indices = []\n                queue = [i]\n                visited[i] = True\n                \n                head = 0\n                while head  len(queue):\n                    u = queue[head]\n                    head += 1\n                    component_indices.append(u)\n                    \n                    for v in range(n_points):\n                        if adj[u, v] and not visited[v]:\n                            visited[v] = True\n                            queue.append(v)\n                clusters.append([points[idx] for idx in component_indices])\n        return clusters\n\n    def check_bistability(params):\n        \"\"\"Performs the full numerical procedure to check for bistability.\"\"\"\n        s_t, s_l, n_xy, n_yx = params\n        \n        # Numerical procedure settings\n        ic_grid_points = 11\n        ic_range = np.linspace(0, 1.5, ic_grid_points)\n        t_span1 = [0, 200]\n        t_span2 = [0, 600]\n        deriv_tol = 1e-6\n        cluster_tol = 0.05\n        min_cluster_size = 3\n        \n        steady_states = []\n        \n        ode_func = lambda t, Z: model_rhs(t, Z, s_t, s_l, n_xy, n_yx, FIXED_PARAMS)\n\n        for x0 in ic_range:\n            for y0 in ic_range:\n                z0 = [x0, y0]\n                \n                # Integrate to t=200\n                sol1 = solve_ivp(ode_func, t_span1, z0, method='RK45', dense_output=True)\n                z_final = sol1.y[:, -1]\n                \n                # Check derivative norm for convergence\n                derivs = ode_func(t_span1[1], z_final)\n                norm_deriv = np.linalg.norm(derivs)\n                \n                # If not converged, re-integrate over a longer time span\n                if norm_deriv > deriv_tol:\n                    sol2 = solve_ivp(ode_func, t_span2, z0, method='RK45', dense_output=True)\n                    z_final = sol2.y[:, -1]\n                \n                steady_states.append(z_final)\n            \n        # Cluster the collected steady-state endpoints\n        clusters = cluster_endpoints(np.array(steady_states), cluster_tol)\n        \n        # Count well-populated clusters\n        well_populated_clusters = sum(1 for c in clusters if len(c) >= min_cluster_size)\n        \n        # Bistability is defined as having at least two well-populated clusters\n        return well_populated_clusters >= 2\n\n    results = []\n    for case in test_cases:\n        is_bistable = check_bistability(case)\n        results.append(str(is_bistable).lower())\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "4696787"}]}