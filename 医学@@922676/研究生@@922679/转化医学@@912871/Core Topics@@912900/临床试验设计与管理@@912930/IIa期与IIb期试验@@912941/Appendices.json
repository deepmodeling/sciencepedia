{"hands_on_practices": [{"introduction": "在设计任何临床试验时，首要步骤之一是确定研究所需的样本量。这个过程不仅仅是简单地套用一个公式，而是需要深刻理解其背后的基本统计学原理，例如中心极限定理、第一类和第二类错误以及统计功效。本练习将引导您从第一性原理出发，推导出用于两组比较的样本量计算公式，旨在加深您对试验设计核心统计权衡的理解，并使您能够在未来更复杂的场景中灵活应用与论证样本量的计算 [@problem_id:5044167]。", "problem": "一项转化性概念验证IIa期研究计划采用随机、平行、双臂设计，比较一种研究药物与安慰剂对一个连续性生物标志物终点的影响，该终点定义为相较于基线的变化。假设每个臂中个体的基线变化值是独立同分布的，具有共同的标准差$\\,\\sigma\\,$，并且待检测的变化均值差异（研究药物减去安慰剂）为一个严格为正的值$\\,\\Delta\\,$。分析将使用双侧假设检验，I类错误率为$\\,\\alpha\\,$，目标效能为$\\,1-\\beta\\,$，双臂样本量相等，并采用大样本正态近似。\n\n仅从以下基本要素出发：\n- 根据中心极限定理，来自独立同分布观测值的样本均值的抽样分布近似为正态分布，其方差等于个体方差除以样本量。\n- 对于两个独立的、每臂样本量相等（均为$\\,n\\,$）且方差相同（均为$\\,\\sigma^{2}\\,$）的臂，样本均值之差的方差是两个样本均值方差之和。\n- 对于一个双侧检验水平为$\\,\\alpha\\,$的z检验，其临界值是标准正态分布的上$\\,1-\\alpha/2\\,$分位数，记为$\\,z_{1-\\alpha/2}\\,$。上$\\,1-\\beta\\,$分位数记为$\\,z_{1-\\beta}\\,$。\n\n推导出所需每臂样本量$\\,n\\,$作为$\\,\\sigma\\,$、$\\,\\Delta\\,$、$\\,\\alpha\\,$和$\\,\\beta\\,$的函数的闭式、并尽可能简化的精确解析表达式，以确保达到指定的双侧I类错误率和检测出均值差异$\\,\\Delta\\,$的效能。请将您的最终答案以单个闭式表达式的形式给出。不要代入数值。不要报告单位。由于答案必须是解析表达式，因此无需四舍五入。", "solution": "该问题陈述已经过验证并被认为是有效的。它具有科学依据，提法得当，客观，并为推导所需的样本量公式提供了一套完整且一致的既定条件和基本原则。该问题是生物统计学和临床试验设计中的一个标准的、基础的练习。\n\n设研究药物的真实基线变化均值为$\\mu_I$，安慰剂的为$\\mu_P$。每臂的样本量为$n$，个体观测值的共同标准差为$\\sigma$。双侧检验的原假设和备择假设为：\n$$H_0: \\mu_I - \\mu_P = 0$$\n$$H_A: \\mu_I - \\mu_P \\neq 0$$\n令$\\bar{X}_I$和$\\bar{X}_P$分别表示研究药物臂和安慰剂臂的基线变化值的样本均值。检验统计量基于这些样本均值的差$\\bar{X}_I - \\bar{X}_P$。\n\n根据第一个基本要素（中心极限定理），样本均值的抽样分布近似为正态分布：\n$$\\bar{X}_I \\sim N\\left(\\mu_I, \\frac{\\sigma^2}{n}\\right)$$\n$$\\bar{X}_P \\sim N\\left(\\mu_P, \\frac{\\sigma^2}{n}\\right)$$\n其中$N(\\mu, \\sigma^2)$表示均值为$\\mu$、方差为$\\sigma^2$的正态分布。\n\n两个臂是独立的。根据第二个基本要素，样本均值之差的方差是它们各自方差之和：\n$$\\text{Var}(\\bar{X}_I - \\bar{X}_P) = \\text{Var}(\\bar{X}_I) + \\text{Var}(\\bar{X}_P) = \\frac{\\sigma^2}{n} + \\frac{\\sigma^2}{n} = \\frac{2\\sigma^2}{n}$$\n差值的标准误是该方差的平方根，$\\text{SE}(\\bar{X}_I - \\bar{X}_P) = \\sqrt{\\frac{2\\sigma^2}{n}} = \\sigma\\sqrt{\\frac{2}{n}}$。\n由于$\\bar{X}_I$和$\\bar{X}_P$近似服从正态分布，它们的差也近似服从正态分布：\n$$\\bar{X}_I - \\bar{X}_P \\sim N\\left(\\mu_I - \\mu_P, \\frac{2\\sigma^2}{n}\\right)$$\n\n在原假设$H_0$下，$\\mu_I - \\mu_P = 0$，所以样本均值差的分布以$0$为中心：\n$$\\bar{X}_I - \\bar{X}_P \\sim N\\left(0, \\frac{2\\sigma^2}{n}\\right)$$\n在$H_0$下的标准化检验统计量为：\n$$Z = \\frac{(\\bar{X}_I - \\bar{X}_P) - 0}{\\sigma\\sqrt{\\frac{2}{n}}} \\sim N(0, 1)$$\n\n对于I类错误水平为$\\alpha$的双侧检验，如果检验统计量落在标准正态分布的极端尾部，我们就拒绝$H_0$。根据第三个基本要素，临界值为$\\pm z_{1-\\alpha/2}$。如果$|Z|  z_{1-\\alpha/2}$，则拒绝原假设，这等价于：\n$$|\\bar{X}_I - \\bar{X}_P|  z_{1-\\alpha/2} \\sigma \\sqrt{\\frac{2}{n}}$$\n设该拒绝域的上界为$C = z_{1-\\alpha/2} \\sigma \\sqrt{\\frac{2}{n}}$。如果$\\bar{X}_I - \\bar{X}_P  C$或$\\bar{X}_I - \\bar{X}_P  -C$，我们就拒绝$H_0$。\n\n接下来，我们施加统计效能的条件。效能是在备择假设为真时正确拒绝$H_0$的概率。问题指定了检测特定均值差异$\\Delta  0$的目标效能为$1-\\beta$。因此，我们考虑特定的备择假设$H_A': \\mu_I - \\mu_P = \\Delta$。\n在$H_A'$下，差值的抽样分布为：\n$$\\bar{X}_I - \\bar{X}_P \\sim N\\left(\\Delta, \\frac{2\\sigma^2}{n}\\right)$$\n效能是当真实差异为$\\Delta$时，观测到的差异落入拒绝域的概率：\n$$\\text{Power} = P\\left(|\\bar{X}_I - \\bar{X}_P|  C \\mid \\mu_I - \\mu_P = \\Delta \\right) = 1-\\beta$$\n这可以写成：\n$$P\\left(\\bar{X}_I - \\bar{X}_P  C \\mid \\mu_I - \\mu_P = \\Delta\\right) + P\\left(\\bar{X}_I - \\bar{X}_P  -C \\mid \\mu_I - \\mu_P = \\Delta\\right) = 1-\\beta$$\n由于$\\Delta  0$且$C  0$，备择假设下分布的均值向右平移。对于典型的效能水平，观测到$\\bar{X}_I - \\bar{X}_P  -C$的概率可以忽略不计，因此效能主要由第一项决定。因此，我们可以将效能近似为：\n$$P\\left(\\bar{X}_I - \\bar{X}_P  C \\mid \\mu_I - \\mu_P = \\Delta\\right) \\approx 1-\\beta$$\n为了计算这个概率，我们使用$H_A'$下的分布对变量$\\bar{X}_I - \\bar{X}_P$进行标准化：\n$$P\\left( \\frac{(\\bar{X}_I - \\bar{X}_P) - \\Delta}{\\sigma\\sqrt{\\frac{2}{n}}}  \\frac{C - \\Delta}{\\sigma\\sqrt{\\frac{2}{n}}} \\right) \\approx 1-\\beta$$\n左边的随机变量是一个标准正态变量，$Z' \\sim N(0,1)$。条件变为$P\\left(Z'  \\frac{C - \\Delta}{\\sigma\\sqrt{\\frac{2}{n}}}\\right) \\approx 1-\\beta$。\n使用第四个基本要素，在标准正态曲线下，其右侧面积为$1-\\beta$的值是$z_{1-\\beta}$。然而，根据正态分布的对称性，其左侧面积为$\\beta$的值是$z_\\beta = -z_{1-\\beta}$。因此，为了使概率为$1-\\beta$，积分下界必须是$-z_{1-\\beta}$。\n$$\\frac{C - \\Delta}{\\sigma\\sqrt{\\frac{2}{n}}} = -z_{1-\\beta}$$\n现在，我们将临界值$C = z_{1-\\alpha/2} \\sigma \\sqrt{\\frac{2}{n}}$的表达式代入此方程：\n$$\\frac{z_{1-\\alpha/2} \\sigma \\sqrt{\\frac{2}{n}} - \\Delta}{\\sigma\\sqrt{\\frac{2}{n}}} = -z_{1-\\beta}$$\n将左侧的项分开，得到：\n$$z_{1-\\alpha/2} - \\frac{\\Delta}{\\sigma\\sqrt{\\frac{2}{n}}} = -z_{1-\\beta}$$\n重新整理以求解包含$n$的项：\n$$z_{1-\\alpha/2} + z_{1-\\beta} = \\frac{\\Delta}{\\sigma\\sqrt{\\frac{2}{n}}} = \\frac{\\Delta \\sqrt{n}}{\\sigma\\sqrt{2}}$$\n现在，我们分离出$\\sqrt{n}$：\n$$\\sqrt{n} = \\frac{\\sigma\\sqrt{2} (z_{1-\\alpha/2} + z_{1-\\beta})}{\\Delta}$$\n最后，我们将两边平方以获得每臂所需样本量$n$的表达式：\n$$n = \\left(\\frac{\\sigma\\sqrt{2} (z_{1-\\alpha/2} + z_{1-\\beta})}{\\Delta}\\right)^2$$\n简化此表达式可得到最终的闭式解：\n$$n = \\frac{2\\sigma^2(z_{1-\\alpha/2} + z_{1-\\beta})^2}{\\Delta^2}$$\n此表达式也可以写成$n = 2 \\left( \\frac{\\sigma}{\\Delta} \\right)^2 (z_{1-\\alpha/2} + z_{1-\\beta})^2$。", "answer": "$$\\boxed{\\frac{2\\sigma^2(z_{1-\\alpha/2} + z_{1-\\beta})^2}{\\Delta^2}}$$", "id": "5044167"}, {"introduction": "在IIa期试验证明了药物的概念有效性后，IIb期试验的核心目标是明确剂量-反应关系。药代动力学-药效动力学（PK/PD）模型，特别是经典的$E_{\\max}$模型，是实现这一目标的关键工具，它为药物剂量、体内暴露水平与最终疗效之间建立了定量的联系。本练习 [@problem_id:5044142] 模拟了新药研发中的一项核心任务：利用已建立的暴露-反应模型，反向计算出达到目标临床疗效所需的具体给药剂量，这项技能对于为关键性的III期临床试验选择最佳剂量至关重要。", "problem": "在一项口服小分子疗法的IIb期（剂量范围探索）试验中，研究者们使用了一个基于受体占有率原理、并加入了基线效应的可饱和最大效应模型来描述暴露-效应关系。在线性药代动力学（PK）条件下，给药间隔内的全身暴露量与经绝对口服生物利用度校正后的口服给药剂量成正比。具体来说，假设以下经过充分检验的组成部分成立：\n- 效应终点被建模为基线反应与一个符合最大效应模型的可饱和增量效应之和：如果暴露指数为 $X$，则效应为 $E=E_{0}+E_{\\max}\\,\\frac{X}{ED_{50}+X}$。\n- 暴露指数与全身可用剂量成正比，并且对于所考虑的给药方案，该比例关系被归一化为 $X=F \\cdot D$，其中 $F$ 是绝对口服生物利用度，$D$ 是口服给药剂量。\n- 半数有效剂量（ED50）参数 $ED_{50}$ 代表了达到最大增量效应一半时所需的暴露指数。\n\n给定以下从来自由模型对IIa期（概念验证）和IIb期（剂量范围探索）数据的拟合得到的估计值：基线效应 $E_{0}=5$（任意效应单位），最大增量效应 $E_{\\max}=30$（相同效应单位），半数有效剂量参数 $ED_{50}=150$（暴露单位与 $X=F \\cdot D$ 一致），以及绝对口服生物利用度 $F=0.4$。临床团队已指定一个高于基线的目增量效应为 $\\theta^{*}=18$（相同效应单位），即 $E=E_{0}+\\theta^{*}$。\n\n仅使用上述定义，从第一性原理出发，推导出达到 $E=E_{0}+\\theta^{*}$ 的口服剂量 $D$ 的显式表达式，然后使用参数值 $E_{0}=5$，$E_{\\max}=30$，$ED_{50}=150$，$F=0.4$ 和 $\\theta^{*}=18$ 计算其数值。以mg为单位表示最终剂量，并将答案四舍五入到四位有效数字。", "solution": "用户提供了一个来自临床药理学领域的问题，具体涉及药代动力学-药效动力学（PK/PD）建模。问题要求推导并计算为达到特定目标治疗效果所需的药物口服剂量。\n\n首先，我将验证问题陈述。\n\n### **问题验证**\n\n**第一步：提取已知条件**\n\n- **效应模型（$E_{\\max}$模型）**：药物效应 $E$ 和全身暴露指数 $X$ 之间的关系由以下公式给出：\n  $E = E_{0} + E_{\\max} \\frac{X}{ED_{50} + X}$\n- **暴露模型**：暴露指数 $X$、口服给药剂量 $D$ 和绝对口服生物利用度 $F$ 之间的关系是：\n  $X = F \\cdot D$\n- **模型参数值**：\n  - 基线效应，$E_{0} = 5$ 单位。\n  - 最大增量效应，$E_{\\max} = 30$ 单位。\n  - 半数有效剂量参数，$ED_{50} = 150$ 暴露单位。\n  - 绝对口服生物利用度，$F = 0.4$。\n- **治疗目标**：\n  - 高于基线的目标增量效应是 $\\theta^{*} = 18$ 单位。\n  - 因此，目标总效应是 $E_{\\text{target}} = E_{0} + \\theta^{*}$。\n\n**第二步：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题使用了标准的S型 $E_{\\max}$ 模型，这是药理学中描述浓度-效应关系的一个基础且被广泛接受的工具。在治疗范围内（线性药代动力学），剂量与暴露之间的线性关系对许多药物来说是一个有效的近似。该问题在科学上是合理的。\n- **适定性**：该问题提供了一个包含一个未知变量 $D$ 的两个代数方程组。所有必要的参数都已定义和量化。其代数结构允许对 $D$ 求解唯一解，并且给定的参数值（$E_{\\max}  \\theta^{*}  0$，$F  0$，$ED_{50}  0$）确保所得剂量将是一个有物理意义的正值。\n- **客观性**：该问题以精确、定量和无偏见的语言陈述，使用了该领域的标准术语。\n\n**第三步：结论与行动**\n该问题具有科学依据、适定、客观且内部一致。判定为**有效**。我将从第一性原理出发推导解答。\n\n### **推导与求解**\n\n目标是求出口服剂量 $D$，使得效应达到目标值 $E_{\\text{target}}$。\n\n目标效应被指定为在基线效应 $E_{0}$ 之上增加一个增量效应 $\\theta^{*}$。\n$$E_{\\text{target}} = E_{0} + \\theta^{*}$$\n\n药物产生的效应由 $E_{\\max}$ 模型描述：\n$$E = E_{0} + E_{\\max}\\,\\frac{X}{ED_{50}+X}$$\n\n为了达到目标效应，我们令 $E = E_{\\text{target}}$：\n$$E_{0} + \\theta^{*} = E_{0} + E_{\\max}\\,\\frac{X}{ED_{50}+X}$$\n\n从等式两边减去基线效应 $E_{0}$，分离出药物引起的效应：\n$$\\theta^{*} = E_{\\max}\\,\\frac{X}{ED_{50}+X}$$\n\n现在，我们必须解此方程以求出产生增量效应 $\\theta^{*}$ 所需的暴露指数 $X$。首先，两边同除以 $E_{\\max}$：\n$$\\frac{\\theta^{*}}{E_{\\max}} = \\frac{X}{ED_{50}+X}$$\n\n为了求解 $X$，我们可以对等式两边取倒数：\n$$\\frac{E_{\\max}}{\\theta^{*}} = \\frac{ED_{50}+X}{X} = \\frac{ED_{50}}{X} + 1$$\n\n重新整理方程以分离出含 $X$ 的项：\n$$\\frac{E_{\\max}}{\\theta^{*}} - 1 = \\frac{ED_{50}}{X}$$\n$$\\frac{E_{\\max} - \\theta^{*}}{\\theta^{*}} = \\frac{ED_{50}}{X}$$\n\n解出 $X$：\n$$X = ED_{50} \\left( \\frac{\\theta^{*}}{E_{\\max} - \\theta^{*}} \\right) = \\frac{\\theta^{*} \\cdot ED_{50}}{E_{\\max} - \\theta^{*}}$$\n\n这个表达式给出了所需的全身暴露指数 $X$。题目通过绝对生物利用度 $F$ 将此暴露指数与口服给药剂量 $D$ 联系起来：\n$$X = F \\cdot D$$\n\n将此关系代入我们关于 $X$ 的表达式中：\n$$F \\cdot D = \\frac{\\theta^{*} \\cdot ED_{50}}{E_{\\max} - \\theta^{*}}$$\n\n最后，我们通过除以 $F$ 来求解剂量 $D$：\n$$D = \\frac{\\theta^{*} \\cdot ED_{50}}{F (E_{\\max} - \\theta^{*})}$$\n\n这就是能够达到目标效应的口服剂量 $D$ 的显式表达式。\n\n现在，我们将给定的数值代入此表达式：\n- $\\theta^{*} = 18$\n- $ED_{50} = 150$\n- $F = 0.4$\n- $E_{\\max} = 30$\n\n$$D = \\frac{18 \\cdot 150}{0.4 (30 - 18)}$$\n$$D = \\frac{2700}{0.4 (12)}$$\n$$D = \\frac{2700}{4.8}$$\n$$D = 562.5$$\n\n题目指明 $ED_{50}$ 的单位与 $X=F \\cdot D$ 一致。由于 $F$ 是无量纲的，$X$ 的单位以及因此 $ED_{50}$ 的单位与剂量 $D$ 的单位相同。题目要求最终答案以毫克（mg）表示，因此我们假设整个计算过程中剂量的隐含单位是mg。\n\n最终的数值结果是 $562.5$。题目要求将答案四舍五入到四位有效数字。数字 $562.5$ 已经有四位有效数字。因此，不需要进一步的四舍五入。\n所需剂量是 $562.5$ mg。", "answer": "$$\\boxed{562.5}$$", "id": "5044142"}, {"introduction": "传统的固定设计临床试验正日益被能够根据累积数据进行学习和优化的现代自适应设计所补充。贝叶斯自适应随机化是一种强大的方法，它根据中期分析结果，动态地将更多受试者分配到表现更优的剂量组。本练习 [@problem_id:5044148] 要求您从零开始，通过编程构建一个基于贝叶斯模型的自适应随机化试验的仿真程序。这项实践将使您对这些复杂设计的运作机制有一个具体而深入的理解，并体会到它们如何通过让更多患者接受有效治疗来提高试验的效率和伦理水平。", "problem": "构建一个程序，该程序使用贝叶斯模型实现II期临床试验剂量分配的自适应随机化（AR）过程，该模型会增加对具有较高后验概率达到预定目标效应的剂量的分配。背景是转化医学，特别是IIa期（概念验证（PoC））和IIb期（剂量范围探索）试验。该问题必须纯粹用数学和逻辑术语来表述，并通过从以下基本依据推导算法来解决。\n\n基本依据：\n- 贝叶斯定理：对于未知参数 $\\theta$ 和观测数据 $D$，后验概率满足 $p(\\theta \\mid D) \\propto p(D \\mid \\theta) p(\\theta)$。\n- 共轭贝塔-二项分布模型：如果剂量 $k$ 的未知疗效概率 $p_k$ 服从先验分布 $\\mathrm{Beta}(\\alpha_k,\\beta_k)$，且二元结果服从伯努利分布，那么在观测到 $s_k$ 次成功和 $f_k$ 次失败后，后验分布为 $\\mathrm{Beta}(\\alpha_k + s_k,\\beta_k + f_k)$。\n- 剂量 $k$ 达到目标阈值 $\\tau$ 的后验概率为 $q_k = \\Pr(p_k \\ge \\tau \\mid D) = 1 - F_{\\mathrm{Beta}}(\\tau; \\alpha_k + s_k, \\beta_k + f_k)$，其中 $F_{\\mathrm{Beta}}(\\cdot; a,b)$ 是参数为 $(a,b)$ 的贝塔分布的累积分布函数。\n\n待构建的算法：\n- 设有 $K$ 个候选剂量，索引为 $k \\in \\{1,\\dots,K\\}$，其疗效概率 $p_k$ 未知。用先验分布 $\\mathrm{Beta}(\\alpha_k,\\beta_k)$ 和观测计数 $s_k = 0$, $f_k = 0$ 初始化每个剂量。\n- 在每个队列步骤 $t \\in \\{1,\\dots,T\\}$（队列大小为 $c$），计算每个剂量的后验分布：$\\mathrm{Beta}(\\alpha_k + s_k,\\beta_k + f_k)$。\n- 计算达到目标效应阈值 $\\tau$ 的后验概率：$q_k = 1 - F_{\\mathrm{Beta}}(\\tau; \\alpha_k + s_k, \\beta_k + f_k)$。\n- 定义分配权重 $\\tilde{w}_k = (q_k + \\delta)^{\\eta}$，其中 $\\eta  0$ 控制自适应的强度，$\\delta  0$ 是一个小的正常数，用于防止权重为零。\n- 进行归一化以获得随机化概率 $r_k = \\tilde{w}_k / \\sum_{j=1}^{K} \\tilde{w}_j$。\n- 使用概率为 $(r_1,\\dots,r_K)$ 的多项式抽样，将队列 $t$ 中的 $c$ 名患者随机分配。为保证可复现性，每个测试用例需使用指定的固定种子的伪随机数生成器。\n- 为测试目的（非真实试验的一部分），假设已知真实疗效概率 $p_k^{\\star}$，并使用概率为 $p_k^{\\star}$ 的伯努利抽样为每个剂量的已分配患者模拟结果。相应地更新 $s_k$ 和 $f_k$，并迭代到下一个队列。\n- 在 $T$ 个队列之后，输出每个剂量的最终总分配数，形式为整数列表 $[n_1,\\dots,n_K]$，其中 $n_k$ 是分配给剂量 $k$ 的患者总数。\n\n角度单位不适用。物理单位不适用。所有比例或概率均以小数表示，不使用百分号。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表，每个测试用例的结果都表示为其自己的方括号列表，且无空格。例如，总体输出必须类似于 $[ [x_1,x_2], [y_1,y_2,y_3], \\dots ]$，但无空格：$[[x_1,x_2],[y_1,y_2,y_3],\\dots]$。\n\n测试套件：\n对于每个测试用例，指定 $(K, \\alpha, \\beta, \\tau, p^{\\star}, T, c, \\eta, \\delta, \\text{seed})$。\n\n- 测试用例A（常规“理想路径”）：$K = 3$, $\\alpha = [1, 1, 1]$, $\\beta = [1, 1, 1]$, $\\tau = 0.3$, $p^{\\star} = [0.2, 0.35, 0.5]$, $T = 5$, $c = 8$, $\\eta = 1.0$, $\\delta = 10^{-6}$, $\\text{seed} = 2021$。预期行为：增加对具有较高 $p_k^{\\star}$ 的剂量的分配，特别是第三个剂量。\n- 测试用例B（平局情况）：$K = 2$, $\\alpha = [10, 10]$, $\\beta = [10, 10]$, $\\tau = 0.5$, $p^{\\star} = [0.5, 0.5]$, $T = 10$, $c = 4$, $\\eta = 2.0$, $\\delta = 10^{-3}$, $\\text{seed} = 2022$。预期行为：由于对称性和相同的性能，分配将接近相等。\n- 测试用例C（信息性但错误指定的先验；探索性保障）：$K = 4$, $\\alpha = [20, 1, 1, 1]$, $\\beta = [5, 1, 1, 1]$, $\\tau = 0.6$, $p^{\\star} = [0.3, 0.65, 0.7, 0.8]$, $T = 12$, $c = 6$, $\\eta = 1.5$, $\\delta = 10^{-2}$, $\\text{seed} = 2023$。预期行为：由于先验，初始分配可能偏向第一个剂量，但随着数据累积，算法应将分配转向由真实 $p_k^{\\star}$ 驱动的具有更高后验 $q_k$ 的剂量。\n- 测试用例D（高阈值的边界情况）：$K = 3$, $\\alpha = [1, 1, 1]$, $\\beta = [1, 1, 1]$, $\\tau = 0.9$, $p^{\\star} = [0.85, 0.88, 0.9]$, $T = 8$, $c = 5$, $\\eta = 1.0$, $\\delta = 10^{-6}$, $\\text{seed} = 2024$。预期行为：初始 $q_k$ 值较低；分配保持相对平衡，直到有足够的证据累积以支持第三个剂量。\n\n最终输出规范：\n- 您的程序必须打印一行，其中包含所有四个测试用例的结果，格式为无空格的、由逗号分隔的方括号列表，严格遵循格式：$[[n_1^{(A)},n_2^{(A)},n_3^{(A)}],[n_1^{(B)},n_2^{(B)}],[n_1^{(C)},n_2^{(C)},n_3^{(C)},n_4^{(C)}],[n_1^{(D)},n_2^{(D)},n_3^{(D)}]]$，其中 $n_k^{(\\cdot)}$ 是您的算法计算出的整数。", "solution": "该问题要求构建一个Python程序，以模拟II期临床试验的自适应随机化（AR）过程。该过程使用贝叶斯框架，根据累积的疗效数据动态调整患者在不同剂量水平上的分配。该问题在算法上定义明确，在科学上合理，并提供了实现所需的所有必要参数。\n\n解决方案是通过将指定的数学和逻辑步骤转化为计算算法来构建的。该算法的核心是一个迭代过程，在每组患者接受治疗后更新对剂量疗效的信念，并随后将新患者分配到显示出更高有效概率的剂量。\n\n**1. 贝叶斯模型基础**\n每个剂量 $k \\in \\{1, \\dots, K\\}$ 的未知疗效概率 $p_k$ 的模型基于贝塔-二项共轭模型。这是对结果为二元（例如，成功/失败，有效/无效）的概率进行建模的标准选择。\n\n- **先验信念**：我们从关于疗效 $p_k$ 的先验信念开始，该信念由贝塔分布建模，$p_k \\sim \\mathrm{Beta}(\\alpha_k, \\beta_k)$。参数 $(\\alpha_k, \\beta_k)$ 可被选择以代表预先存在的知识。一个常见的无信息先验是均匀分布，即 $\\mathrm{Beta}(1, 1)$。\n\n- **似然函数**：每个患者的结果都是一次伯努利试验。对于剂量 $k$ 下的一组 $n$ 名患者，如果我们观察到 $s$ 次成功，给定 $p_k$ 的数据似然与 $p_k^s (1-p_k)^{n-s}$ 成正比。\n\n- **后验信念**：根据贝叶斯定理，后验分布与先验和似然的乘积成正比。由于贝塔分布和二项分布的共轭性，如果我们为剂量 $k$ 累积了总共 $s_k$ 次成功和 $f_k$ 次失败，则 $p_k$ 的后验分布更新为：\n$$p_k \\mid (s_k, f_k) \\sim \\mathrm{Beta}(\\alpha_k', \\beta_k') = \\mathrm{Beta}(\\alpha_k + s_k, \\beta_k + f_k)$$\n这些更新后的分布承载了我们当前关于每个剂量疗效的所有知识。\n\n**2. 自适应分配机制**\n自适应设计的核心是将更多患者分配到“有前景”的剂量。如果一个剂量的后验分布表明其超过预定义疗效阈值 $\\tau$ 的概率很高，则该剂量被认为是有前景的。\n\n- **达到目标的后验概率 ($q_k$)**：对于每个剂量 $k$，我们计算在给定观测数据的情况下，其真实疗效 $p_k$ 至少为 $\\tau$ 的概率。这可以从后验分布中计算得出：\n$$q_k = \\Pr(p_k \\ge \\tau \\mid s_k, f_k) = \\int_{\\tau}^{1} \\frac{x^{\\alpha_k'-1}(1-x)^{\\beta_k'-1}}{B(\\alpha_k', \\beta_k')} dx = 1 - F_{\\mathrm{Beta}}(\\tau; \\alpha_k', \\beta_k')$$\n其中 $F_{\\mathrm{Beta}}(\\cdot; a, b)$ 是参数为 $(a, b)$ 的贝塔分布的累积分布函数（CDF）。这个值 $q_k$ 作为衡量剂量 $k$ “前景”的指标。\n\n- **分配权重和概率**：$q_k$ 值被转换为分配概率。使用幂函数来控制自适应程度：\n$$\\tilde{w}_k = (q_k + \\delta)^{\\eta}$$\n此处，$\\eta  0$ 是一个调整参数；较大的 $\\eta$ 使分配更“贪婪”，即更倾向于 $q_k$ 最高的剂量。较小的 $\\eta$ 则导致更均衡的分配，促进探索。常数 $\\delta  0$ 是一个小的正则化项，以确保即使 $q_k=0$ 的剂量也有非零的（尽管很小）被选择机会，防止其被过早淘汰。然后对权重进行归一化，形成概率分布：\n$$r_k = \\frac{\\tilde{w}_k}{\\sum_{j=1}^{K} \\tilde{w}_j}$$\n这些概率 $(r_1, \\dots, r_K)$ 用于分配下一组患者。\n\n**3. 模拟算法**\n模拟以离散步骤进行，每个步骤对应一组患者。\n\n- **初始化**：\n    - 对于每个剂量 $k=1, \\dots, K$：初始化成功计数 $s_k=0$ 和失败计数 $f_k=0$。\n    - 总分配患者数 $n_k$ 也初始化为 $0$。\n    - 为确保可复现性，对伪随机数生成器（RNG）进行播种。\n\n- **队列迭代**：对于大小为 $c$ 的每个队列 $t=1, \\dots, T$：\n    1. **计算后验**：为所有剂量计算后验贝塔参数 $\\alpha'_k = \\alpha_k + s_k$ 和 $\\beta'_k = \\beta_k + f_k$。\n    2. **计算目标概率**：为所有剂量计算 $q_k = 1 - F_{\\mathrm{Beta}}(\\tau; \\alpha'_k, \\beta'_k)$。此步骤使用 `scipy.stats.beta.cdf` 函数。\n    3. **计算分配概率**：计算权重 $\\tilde{w}_k$ 并进行归一化以得到随机化概率 $r_k$。\n    4. **分配患者**：从具有 $c$ 次试验和概率 $(r_1, \\dots, r_K)$ 的多项分布中抽取当前队列的患者计数向量 $(c_1, \\dots, c_K)$。此操作使用 `numpy.random.multinomial` 执行。更新总分配数：$n_k \\leftarrow n_k + c_k$。\n    5. **模拟结果**：对于每个剂量 $k$，为 $c_k$ 名新分配的患者模拟结果。成功次数从二项分布 $\\mathrm{Bin}(c_k, p_k^{\\star})$ 中抽取，其中 $p_k^{\\star}$ 是真实疗效。此操作使用 `numpy.random.binomial` 执行。更新累积计数：$s_k \\leftarrow s_k + \\text{成功次数}$ 和 $f_k \\leftarrow f_k + (c_k - \\text{成功次数})$。\n\n- **终止**：处理完 $T$ 个队列后，模拟结束。最终输出是每个剂量的总患者分配列表：$[n_1, n_2, \\dots, n_K]$。\n\n这个综合算法在Python中实现，利用 `numpy` 进行高效的基于数组的计算和随机数生成，并利用 `scipy` 获取统计学上的贝塔分布函数。整个过程被封装在一个函数中，并为每个提供的测试用例执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import beta as beta_dist\n\ndef run_simulation(K, alpha, beta_p, tau, p_star, T, c, eta, delta, seed):\n    \"\"\"\n    Implements the Adaptive Randomization (AR) procedure for a single test case.\n\n    Args:\n        K (int): Number of candidate doses.\n        alpha (list): Prior alpha parameters for the Beta distributions.\n        beta_p (list): Prior beta parameters for the Beta distributions.\n        tau (float): Target effect threshold.\n        p_star (list): Ground-truth efficacy probabilities for simulation.\n        T (int): Number of cohorts.\n        c (int): Cohort size.\n        eta (float): Parameter controlling the strength of adaptiveness.\n        delta (float): Small constant to prevent zero weights.\n        seed (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        list: A list of final total patient allocations to each dose.\n    \"\"\"\n    # Initialize the pseudo-random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # Convert lists to NumPy arrays for vectorized operations.\n    alpha0 = np.array(alpha, dtype=float)\n    beta0 = np.array(beta_p, dtype=float)\n    p_star = np.array(p_star, dtype=float)\n\n    # Initialize success counts (s), failure counts (f), and total allocations.\n    s = np.zeros(K, dtype=int)\n    f = np.zeros(K, dtype=int)\n    n_total = np.zeros(K, dtype=int)\n\n    # Iterate through each cohort.\n    for _ in range(T):\n        # 1. Compute posterior parameters for each dose.\n        posterior_alpha = alpha0 + s\n        posterior_beta = beta0 + f\n\n        # 2. Compute the posterior probability of meeting the target threshold.\n        # q_k = Pr(p_k >= tau | Data) = 1 - CDF_Beta(tau; a', b')\n        q = 1 - beta_dist.cdf(tau, posterior_alpha, posterior_beta)\n        \n        # 3. Define allocation weights.\n        weights = (q + delta)**eta\n\n        # 4. Normalize weights to obtain randomization probabilities.\n        sum_weights = np.sum(weights)\n        if sum_weights > 0:\n            r = weights / sum_weights\n        else:\n            # Fallback to equal allocation if all weights are zero (highly unlikely with delta > 0).\n            r = np.ones(K) / K\n\n        # 5. Randomly allocate the cohort of patients using a multinomial draw.\n        allocations_this_cohort = rng.multinomial(c, r)\n        n_total += allocations_this_cohort\n        \n        # 6. Simulate outcomes for the allocated patients based on ground-truth probabilities.\n        successes_this_cohort = rng.binomial(allocations_this_cohort, p_star)\n        failures_this_cohort = allocations_this_cohort - successes_this_cohort\n\n        # Update cumulative success and failure counts.\n        s += successes_this_cohort\n        f += failures_this_cohort\n\n    return n_total.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (K, alpha, beta, tau, p_star, T, c, eta, delta, seed)\n        (3, [1, 1, 1], [1, 1, 1], 0.3, [0.2, 0.35, 0.5], 5, 8, 1.0, 1e-6, 2021),\n        (2, [10, 10], [10, 10], 0.5, [0.5, 0.5], 10, 4, 2.0, 1e-3, 2022),\n        (4, [20, 1, 1, 1], [5, 1, 1, 1], 0.6, [0.3, 0.65, 0.7, 0.8], 12, 6, 1.5, 1e-2, 2023),\n        (3, [1, 1, 1], [1, 1, 1], 0.9, [0.85, 0.88, 0.9], 8, 5, 1.0, 1e-6, 2024),\n    ]\n\n    results = []\n    for params in test_cases:\n        K, alpha, beta_p, tau, p_star, T, c, eta, delta, seed = params\n        result = run_simulation(K, alpha, beta_p, tau, p_star, T, c, eta, delta, seed)\n        results.append(result)\n\n    # The final print statement must produce a single-line string with no spaces.\n    # Example format: [[n1,n2],[n3,n4,n5]]\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "5044148"}]}