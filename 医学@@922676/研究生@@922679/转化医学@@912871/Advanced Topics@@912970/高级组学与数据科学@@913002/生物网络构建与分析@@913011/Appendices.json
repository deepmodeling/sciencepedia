{"hands_on_practices": [{"introduction": "在转化医学研究中，我们常常需要从高通量实验数据（如蛋白质组学或基因组学数据）中构建生物网络。然而，由于同时检验成千上万个潜在的相互作用，我们面临着严重的多重假设检验问题。本练习将指导您应用Benjamini-Hochberg程序来控制伪发现率（$FDR$），这是从充满噪声的实验数据中构建可靠生物网络的关键一步 [@problem_id:5002377]。", "problem": "一项转化肿瘤学研究旨在构建一个由6种磷酸化蛋白 $\\{g_{1}, g_{2}, g_{3}, g_{4}, g_{5}, g_{6}\\}$ 组成的无向、无权重的信号网络。这些蛋白是在靶向治疗前后对配对的肿瘤活检样本进行测量的。对于每个候选的无向边 $(g_{i}, g_{j})$（其中 $i  j$），我们进行了一系列假设检验，获得了以下15个p值：\n-   $(g_{1}, g_{2}): 0.041$, $(g_{1}, g_{3}): 0.003$, $(g_{1}, g_{4}): 0.073$, $(g_{1}, g_{5}): 0.009$, $(g_{1}, g_{6}): 0.14$,\n-   $(g_{2}, g_{3}): 0.021$, $(g_{2}, g_{4}): 0.001$, $(g_{2}, g_{5}): 0.061$, $(g_{2}, g_{6}): 0.081$,\n-   $(g_{3}, g_{4}): 0.052$, $(g_{3}, g_{5}): 0.012$, $(g_{3}, g_{6}): 0.091$,\n-   $(g_{4}, g_{5}): 0.033$, $(g_{4}, g_{6}): 0.007$,\n-   $(g_{5}, g_{6}): 0.018$.\n\n您的任务是应用 Benjamini-Hochberg (BH) 假发现率 (FDR) 控制程序，显著性水平设为 $\\alpha = 0.05$。\n1.  确定保留在最终网络中的边的集合。\n2.  构建最终网络的二元邻接矩阵 $\\mathbf{A} \\in \\{0,1\\}^{6 \\times 6}$。\n3.  从转化医学的角度，论证选择 $\\alpha=0.05$ 的合理性。\n4.  将保留边的总数作为最终答案报告。", "solution": "### 解答\n首要任务是应用 Benjamini-Hochberg (BH) 程序，在 $\\alpha = 0.05$ 的水平上控制假发现率 (FDR)。检验的假设总数为 $m=15$。\n\nBH 程序包括以下步骤：\n1.  将 $m$ 个 $p$ 值从小到大排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。\n2.  找到满足条件 $p_{(k)} \\le \\frac{k}{m}\\alpha$ 的最大整数 $k$，其中 $p_{(k)}$ 是第 $k$ 个排序后的 $p$ 值。\n3.  将与 $p$ 值 $p_{(1)}, p_{(2)}, \\dots, p_{(k)}$ 对应的假设声明为显著（即拒绝原假设）。\n\n我们列出这15个 $p$ 值并按升序排列。第 $i$ 个 p 值的阈值为 $\\frac{i}{15} \\times 0.05 = \\frac{i}{300}$。\n\n-   $p_{(1)} = 0.001$ 对应边 $(g_{2}, g_{4})$。BH 阈值为 $\\frac{1}{15}(0.05) \\approx 0.00333$。因为 $0.001 \\le 0.00333$，所以这条边是显著的。\n-   $p_{(2)} = 0.003$ 对应边 $(g_{1}, g_{3})$。BH 阈值为 $\\frac{2}{15}(0.05) \\approx 0.00667$。因为 $0.003 \\le 0.00667$，所以这条边是显著的。\n-   $p_{(3)} = 0.007$ 对应边 $(g_{4}, g_{6})$。BH 阈值为 $\\frac{3}{15}(0.05) = 0.01$。因为 $0.007 \\le 0.01$，所以这条边是显著的。\n-   $p_{(4)} = 0.009$ 对应边 $(g_{1}, g_{5})$。BH 阈值为 $\\frac{4}{15}(0.05) \\approx 0.01333$。因为 $0.009 \\le 0.01333$，所以这条边是显著的。\n-   $p_{(5)} = 0.012$ 对应边 $(g_{3}, g_{5})$。BH 阈值为 $\\frac{5}{15}(0.05) \\approx 0.01667$。因为 $0.012 \\le 0.01667$，所以这条边是显著的。\n-   $p_{(6)} = 0.018$ 对应边 $(g_{5}, g_{6})$。BH 阈值为 $\\frac{6}{15}(0.05) = 0.02$。因为 $0.018 \\le 0.02$，所以这条边是显著的。\n-   $p_{(7)} = 0.021$ 对应边 $(g_{2}, g_{3})$。BH 阈值为 $\\frac{7}{15}(0.05) \\approx 0.02333$。因为 $0.021 \\le 0.02333$，所以这条边是显著的。\n-   $p_{(8)} = 0.033$ 对应边 $(g_{4}, g_{5})$。BH 阈值为 $\\frac{8}{15}(0.05) \\approx 0.02667$。因为 $0.033 > 0.02667$，所以这条边不显著，我们在此停止。\n\n满足 $p_{(k)} \\le \\frac{k}{m}\\alpha$ 的最大 $k$ 值为 $k=7$。因此，我们保留与7个最小 $p$ 值相对应的7条边。\n\n保留边的集合为：\n$\\{ (g_{1}, g_{3}), (g_{1}, g_{5}), (g_{2}, g_{3}), (g_{2}, g_{4}), (g_{3}, g_{5}), (g_{4}, g_{6}), (g_{5}, g_{6}) \\}$.\n\n保留边的总数为7。\n\n接下来，我们构建蛋白质排序为 $[g_{1}, g_{2}, g_{3}, g_{4}, g_{5}, g_{6}]$ 的网络的二元邻接矩阵 $\\mathbf{A}$。如果边 $(g_{i}, g_{j})$ 被保留，则元素 $A_{ij}$ 和 $A_{ji}$ 为1，否则为0。所有对角线元素 $A_{ii}$ 均为0。\n-   $g_1$ 与 $g_3$ 和 $g_5$ 连接：$A_{13}=A_{31}=1$, $A_{15}=A_{51}=1$。\n-   $g_2$ 与 $g_3$ 和 $g_4$ 连接：$A_{23}=A_{32}=1$, $A_{24}=A_{42}=1$。\n-   $g_3$ 与 $g_1$、$g_2$ 和 $g_5$ 连接：$A_{31}=A_{13}=1$, $A_{32}=A_{23}=1$, $A_{35}=A_{53}=1$。（这些因对称性已被计入）。\n-   $g_4$ 与 $g_2$ 和 $g_6$ 连接：$A_{42}=A_{24}=1$, $A_{46}=A_{64}=1$。\n-   $g_5$ 与 $g_1$、$g_3$ 和 $g_6$ 连接：$A_{51}=A_{15}=1$, $A_{53}=A_{35}=1$, $A_{56}=A_{65}=1$。\n-   $g_6$ 与 $g_4$ 和 $g_5$ 连接：$A_{64}=A_{46}=1$, $A_{65}=A_{56}=1$。\n\n得到的邻接矩阵 $\\mathbf{A}$ 为：\n$$ \\mathbf{A} = \\begin{pmatrix}\n0  0  1  0  1  0 \\\\\n0  0  1  1  0  0 \\\\\n1  1  0  0  1  0 \\\\\n0  1  0  0  0  1 \\\\\n1  0  1  0  0  1 \\\\\n0  0  0  1  1  0\n\\end{pmatrix} $$\n$\\mathbf{A}$ 的严格上三角元素之和为 $A_{13} + A_{15} + A_{23} + A_{24} + A_{35} + A_{46} + A_{56} = 1+1+1+1+1+1+1=7$，这证实了我们对保留边数的计算。\n\n最后，我们从转化医学相关的基本原理出发，论证选择 $\\alpha=0.05$ 的合理性。\n转化医学的目标是弥合基础研究与临床实践之间的鸿沟。在此背景下，构建信号网络是一个探索性的、旨在生成假设的步骤。“发现”即为被保留的边，它们代表了值得进一步研究的假定蛋白质间相互作用或功能关联。\n\n1.  **FDR 的定义**：假发现率 (False Discovery Rate, FDR) 是在所有声明的发现中，假阳性所占的预期比例。将 FDR 控制在 $\\alpha=0.05$ 意味着我们接受，在被保留的边中，平均不超过 $5\\%$ 是伪造的。这与控制家族谬误率 (Family-Wise Error Rate, FWER) 有着根本区别，FWER 是指做出至少一个假发现的概率，对于一个包含许多假设 ($m=15$) 的探索性研究而言，这种控制方法过于保守。控制 FWER 会严重降低统计功效，导致网络过于稀疏，可能错过许多真实的生物学相互作用。\n\n2.  **平衡发现与资源**：转化研究是一个流水线过程。一个阶段的输出（网络推断）成为下一个更具针对性且成本更高的阶段（例如，使用免疫沉淀等技术进行实验验证，或在细胞系中进行功能研究）的输入。设定 $\\alpha=0.05$ 代表了一种务实的权衡。一个过高的 $\\alpha$ 会生成一个包含许多假阳性的密集网络，从而在验证死胡同上浪费宝贵的时间和资源。一个过低的 $\\alpha$ 则会产生太少的候选目标，可能因缺乏假设而导致整个项目停滞。$5\\%$ 的 FDR 通常被认为是一个合理的平衡点，它产生的发现列表富含真实信号，但数量又不过于庞大以至于无法进行后续研究。对于发现的7条边，我们平均预期有 $7 \\times 0.05 = 0.35$ 个假阳性，这对于下游验证工作来说是一个非常有利的结果。\n\n3.  **科学背景**：目标不是要通过这单一数据集绝对确定地证明网络结构，而是要生成一个高质量的模型，用以提出关于该疗法作用机制的、可检验的新假设。$5\\%$ 的 FDR 是一个标准，它允许在发现和验证这个迭代过程中取得有意义的进展，而这正是转化科学的精髓所在。\n\n最终报告的量是保留边的总数。根据计算，这个数字是7。", "answer": "$$ \\boxed{7} $$", "id": "5002377"}, {"introduction": "一个生物网络一旦构建完成，它就不仅仅是节点和边的随机集合，其拓扑结构蕴含着重要的生物学功能信息。我们可以通过计算节点的度中心性（degree centrality）和局部聚类系数（local clustering coefficient）等指标来量化其在网络中的重要性和局部环境。通过这个练习，您将学会如何计算这些核心网络指标，并利用它们来识别网络中的关键节点，例如功能模块的核心成员或连接不同模块的桥梁蛋白 [@problem_id:5002394]。", "problem": "通过整合物理结合数据和条件特异性共表达数据，从一个转化医学队列中构建了一个疾病特异性的蛋白质-蛋白质相互作用（PPI）网络。这个包含 $6$ 个基因产物的无向、无权网络由一个对角线元素为零的对称邻接矩阵 $A \\in \\{0,1\\}^{6 \\times 6}$ 表示：\n$$\nA \\;=\\;\n\\begin{pmatrix}\n0  1  1  0  0  0\\\\\n1  0  1  0  0  0\\\\\n1  1  0  1  0  0\\\\\n0  0  1  0  1  1\\\\\n0  0  0  1  0  1\\\\\n0  0  0  1  1  0\n\\end{pmatrix}.\n$$\n节点由 $i \\in \\{1,2,3,4,5,6\\}$ 索引。使用适用于无向简单图的核心图论定义，执行以下操作：\n- 对每个节点 $i$，根据节点 $i$ 的度 $k_{i}$，计算归一化度中心性 $C_{D}(i)$。归一化时使用一个包含 $n=6$ 个节点的图中的最大可能度。\n- 对每个节点 $i$，计算局部聚类系数 $C_{i}$，其定义为节点 $i$ 的邻居之间实际存在的连接数占所有可能连接数的比例。遵循当 $k_i  2$ 时 $C_{i}=0$ 的惯例。\n- 根据您的计算，从转化网络生物学的角度解释哪些节点可能位于密集的功​​能模块中，哪些节点充当模块间的连接器。其中，高局部聚类系数表明节点属于某个功能复合体或通路，而高​​度节点的较低局部聚类系数可能表明其具有桥接作用。\n\n最后，将局部聚类系数的网络平均值 $\\bar{C} = \\frac{1}{n}\\sum_{i=1}^{n} C_{i}$ 报告为保留4位有效数字的小数。最终报告值无需单位。", "solution": "该问题已经过验证，被认为是有效的。它在科学上以图论及其在生物网络分析中的应用为基础，提法恰当，提供了所有必要信息，并以客观、正式的语言表达。因此，我们可以着手求解。\n\n该问题要求对一个由邻接矩阵 $A$ 表示的给定生物网络进行多步分析。该网络有 $n=6$ 个节点。\n$$\nA \\;=\\;\n\\begin{pmatrix}\n0  1  1  0  0  0\\\\\n1  0  1  0  0  0\\\\\n1  1  0  1  0  0\\\\\n0  0  1  0  1  1\\\\\n0  0  0  1  0  1\\\\\n0  0  0  1  1  0\n\\end{pmatrix}\n$$\n分析过程包括计算节点特异性指标，解释其生物学意义，以及计算一个全局网络属性。\n\n首先，我们计算每个节点 $i$ 的度 $k_i$，即它拥有的连接数。对于一个由对称邻接矩阵 $A$ 表示的无向图，节点 $i$ 的度是第 $i$ 行（或列）元素的总和。\n$k_i = \\sum_{j=1}^{n} A_{ij}$\n- $k_1 = 1+1 = 2$\n- $k_2 = 1+1 = 2$\n- $k_3 = 1+1+1 = 3$\n- $k_4 = 1+1+1 = 3$\n- $k_5 = 1+1 = 2$\n- $k_6 = 1+1 = 2$\n\n接下来，我们计算每个节点的归一化度中心性 $C_D(i)$。它定义为节点的度 $k_i$ 除以一个包含 $n$ 个节点的简单图中的最大可能度，即 $n-1$。这里，$n=6$，所以最大可能度是 $n-1=5$。\n$C_D(i) = \\frac{k_i}{n-1}$\n- $C_D(1) = \\frac{k_1}{5} = \\frac{2}{5} = 0.4$\n- $C_D(2) = \\frac{k_2}{5} = \\frac{2}{5} = 0.4$\n- $C_D(3) = \\frac{k_3}{5} = \\frac{3}{5} = 0.6$\n- $C_D(4) = \\frac{k_4}{5} = \\frac{3}{5} = 0.6$\n- $C_D(5) = \\frac{k_5}{5} = \\frac{2}{5} = 0.4$\n- $C_D(6) = \\frac{k_6}{5} = \\frac{2}{5} = 0.4$\n\n现在，我们计算每个节点的局部聚类系数 $C_i$。该系数衡量一个节点邻居之间的连接密度。它定义为节点 $i$ 的邻居之间存在的边数（记为 $E_i$）除以它们之间可能存在的总边数。对于无向图，这由以下公式给出：\n$C_i = \\frac{2 E_i}{k_i (k_i - 1)}$\n问题指定了当 $k_i  2$ 时 $C_i=0$ 的惯例。由于所有节点的度都至少为2，因此该惯例不适用。\n\n- **节点 1**：$k_1=2$。邻居是 $N(1) = \\{2, 3\\}$。它们之间有 $E_1=1$ 条边（边 $(2,3)$，因为 $A_{23}=1$）。\n$C_1 = \\frac{2 \\times 1}{2 \\times (2 - 1)} = \\frac{2}{2} = 1$\n\n- **节点 2**：$k_2=2$。邻居是 $N(2) = \\{1, 3\\}$。它们之间有 $E_2=1$ 条边（边 $(1,3)$，因为 $A_{13}=1$）。\n$C_2 = \\frac{2 \\times 1}{2 \\times (2 - 1)} = \\frac{2}{2} = 1$\n\n- **节点 3**：$k_3=3$。邻居是 $N(3) = \\{1, 2, 4\\}$。可能的边是 $(1,2)$、$(1,4)$ 和 $(2,4)$。我们检查邻接矩阵：$A_{12}=1$，$A_{14}=0$，$A_{24}=0$。因此，邻居之间只有 $E_3=1$ 条边。\n$C_3 = \\frac{2 \\times 1}{3 \\times (3 - 1)} = \\frac{2}{6} = \\frac{1}{3}$\n\n- **节点 4**：$k_4=3$。邻居是 $N(4) = \\{3, 5, 6\\}$。可能的边是 $(3,5)$、$(3,6)$ 和 $(5,6)$。我们检查邻接矩阵：$A_{35}=0$，$A_{36}=0$，$A_{56}=1$。因此，邻居之间只有 $E_4=1$ 条边。\n$C_4 = \\frac{2 \\times 1}{3 \\times (3 - 1)} = \\frac{2}{6} = \\frac{1}{3}$\n\n- **节点 5**：$k_5=2$。邻居是 $N(5) = \\{4, 6\\}$。它们之间有 $E_5=1$ 条边（边 $(4,6)$，因为 $A_{46}=1$）。\n$C_5 = \\frac{2 \\times 1}{2 \\times (2 - 1)} = \\frac{2}{2} = 1$\n\n- **节点 6**：$k_6=2$。邻居是 $N(6) = \\{4, 5\\}$。它们之间有 $E_6=1$ 条边（边 $(4,5)$，因为 $A_{45}=1$）。\n$C_6 = \\frac{2 \\times 1}{2 \\times (2 - 1)} = \\frac{2}{2} = 1$\n\n基于这些计算，我们可以解释节点的作用。\n- **节点 1、2、5、6**：这些节点的局部聚类系数为 $C_i = 1$。这个最大值表明它们的邻居是完全连接的，形成了一个团。这些节点深深地嵌入在密集的功​​能模块中。具体来说，节点 $\\{1, 2, 3\\}$ 形成一个三角形，节点 $\\{4, 5, 6\\}$ 形成另一个三角形。节点 $1$ 和 $2$ 属于第一个模块，节点 $5$ 和 $6$ 属于第二个模块。\n- **节点 3、4**：这些节点具有网络中最高的度中心性（$C_D(3) = C_D(4) = 0.6$）。然而，它们的局部聚类系数相对较低（$C_3 = C_4 = 1/3$）。这种高​​度和低局部聚类的模式是充当“桥梁”或模块间连接器的节点的特征。节点 $3$ 是第一个功能模块的一部分，但也连接到节点 $4$。类似地，节点 $4$ 是第二个模块的一部分，并连接到节点 $3$。边 $(3,4)$ 是连接两个密集三角形模块的唯一连接，证实了节点 $3$ 和 $4$ 的桥接作用。\n\n最后，我们计算局部聚类系数的网络平均值 $\\bar{C}$。\n$\\bar{C} = \\frac{1}{n}\\sum_{i=1}^{n} C_{i}$\n$\\bar{C} = \\frac{1}{6} (C_1 + C_2 + C_3 + C_4 + C_5 + C_6)$\n$\\bar{C} = \\frac{1}{6} \\left(1 + 1 + \\frac{1}{3} + \\frac{1}{3} + 1 + 1\\right)$\n$\\bar{C} = \\frac{1}{6} \\left(4 + \\frac{2}{3}\\right)$\n$\\bar{C} = \\frac{1}{6} \\left(\\frac{12}{3} + \\frac{2}{3}\\right) = \\frac{1}{6} \\left(\\frac{14}{3}\\right) = \\frac{14}{18} = \\frac{7}{9}$\n\n将该值报告为保留4位有效数字的小数：\n$\\frac{7}{9} \\approx 0.777777...$\n保留4位有效数字得到 $0.7778$。", "answer": "$$\\boxed{0.7778}$$", "id": "5002394"}, {"introduction": "识别新的疾病相关基因是转化医学的核心目标之一，而网络生物学为此提供了强有力的工具。基于“ guilt-by-association ”（罪恶关联）原则，与已知疾病基因在网络中紧密相关的基因也极有可能是新的候选基因。本练习将引导您通过编程实现带重启的随机游走（Random Walk with Restart, RWR）算法，这是一种通过求解其核心的线性方程组来精确量化网络中节点间“关联度”的强大方法，从而实现对候选基因的有效排序 [@problem_id:5002343]。", "problem": "给定您小型的蛋白质-蛋白质相互作用（PPI）网络和疾病种子基因集。构建一种有原则、可复现的带重启的随机游走（RWR）方法，通过稳态概率来对候选基因进行优先级排序。您的程序必须实现以下内容，这些内容源自离散时间马尔可夫链和随机矩阵的基础理论。\n\n定义和基础理论：\n- 一个包含 $n$ 个基因的PPI网络由一个对称的非负邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 表示，其元素满足 $A_{ij} \\ge 0$ 且 $A_{ij} = A_{ji}$。对角线元素可以为零。非零元素表示无向的相互作用强度。\n- 一个列随机矩阵 $W \\in \\mathbb{R}^{n \\times n}$ 满足对于每一列 $j$ 都有 $\\sum_{i=1}^{n} W_{ij} = 1$ 且 $W_{ij} \\ge 0$。这样的矩阵定义了一个马尔可夫链转移算子，它作用于概率向量 $p \\in \\mathbb{R}^{n}$，通过更新 $p^{(t+1)} = W p^{(t)}$，并保持 $\\sum_{i=1}^{n} p^{(t)}_i = 1$ 和 $p^{(t)}_i \\ge 0$。\n- 给定 $A$，通过列归一化构建 $W$：对于列和 $\\sum_{i=1}^{n} A_{ij} > 0$ 的每一列 $j$，设置 $W_{ij} = A_{ij} / \\sum_{k=1}^{n} A_{kj}$。对于任何列和为 $\\sum_{i=1}^{n} A_{ij} = 0$ 的列 $j$（一个孤立节点），设置 $W_{jj} = 1$ 且当 $i \\ne j$ 时 $W_{ij} = 0$；这增加了一个自环，以在孤立节点上保留概率质量，并确保 $W$ 是列随机的。\n- 设种子集为 $S \\subset \\{0,1,\\dots,n-1\\}$。定义种子分布向量 $s \\in \\mathbb{R}^{n}$，其中如果 $i \\in S$，则 $s_i = 1/|S|$，否则 $s_i = 0$，从而满足 $\\sum_{i=1}^{n} s_i = 1$ 且 $s_i \\ge 0$。\n- 考虑网络上的一个马尔可夫过程，其重启参数为 $\\gamma \\in (0,1]$。在每个时间步，游走以概率 $\\gamma$ 根据 $s$ 重启到种子节点，并以概率 $(1 - \\gamma)$ 根据 $W$ 进行一次网络转移。根据带传送（teleportation）的马尔可夫链的平稳分布的基础定义，唯一存在的稳态分布 $p^\\star \\in \\mathbb{R}^{n}$ 满足不动点方程 $p^\\star = (1 - \\gamma) \\, W \\, p^\\star + \\gamma \\, s$。当 $\\gamma \\in (0,1]$ 且 $W$ 是列随机矩阵时，由于 $(1 - \\gamma) \\, W$ 的谱半径严格小于1，因此保证 $p^\\star$ 唯一存在。\n\n程序要求：\n- 对于下面的每个测试用例，按照规定从 $A$ 构建 $W$，从给定的种子集形成 $s$，并通过求解不动点条件所蕴含的线性系统来精确计算唯一的 $p^\\star$，不要使用迭代启发式方法。按 $p^\\star_i$ 的降序对所有非种子节点进行排序；若出现平分，则按索引 $i$ 的升序排序。使用基于零的索引，返回每个用例中排名前 $k$ 的非种子节点索引。\n- 如果所有非种子节点的分数相同（例如，恰好为 $0$），则使用平分决胜规则按升序选择索引。\n- 数值稳定性：如果数值舍入在 $p^\\star$ 中产生微小的负值，通过裁剪将它们视为 $0$，然后重新归一化以确保 $\\sum_{i=1}^{n} p^\\star_i = 1$。\n\n测试套件（请严格使用这些用例）：\n1) 用例1（正常路径，连通，无权重）：\n   - $n = 6$；邻接矩阵 $A \\in \\mathbb{R}^{6 \\times 6}$，其元素为\n     $$A = \\begin{bmatrix}\n     0  1  0  0  0  1 \\\\\n     1  0  1  1  0  0 \\\\\n     0  1  0  1  0  0 \\\\\n     0  1  1  0  1  0 \\\\\n     0  0  0  1  0  1 \\\\\n     1  0  0  0  1  0\n     \\end{bmatrix}.$$\n   - 种子集 $S = \\{0, 3\\}$。\n   - 重启概率 $\\gamma = 0.35$。\n   - 前 $k$ 个：$k = 3$。\n\n2) 用例2（边界情况，孤立的种子）：\n   - $n = 5$；邻接矩阵 $A \\in \\mathbb{R}^{5 \\times 5}$，其元素为\n     $$A = \\begin{bmatrix}\n     0  1  0  0  0 \\\\\n     1  0  1  0  0 \\\\\n     0  1  0  1  0 \\\\\n     0  0  1  0  0 \\\\\n     0  0  0  0  0\n     \\end{bmatrix}.$$\n   - 种子集 $S = \\{4\\}$。\n   - 重启概率 $\\gamma = 0.7$。\n   - 前 $k$ 个：$k = 2$。\n\n3) 用例3（加权网络，强重启）：\n   - $n = 7$；邻接矩阵 $A \\in \\mathbb{R}^{7 \\times 7}$，其元素为\n     $$A = \\begin{bmatrix}\n     0  2.0  1.0  0  0  0  0 \\\\\n     2.0  0  0  1.5  0  0  0 \\\\\n     1.0  0  0  0.5  0  0  1.0 \\\\\n     0  1.5  0.5  0  2.0  0  0 \\\\\n     0  0  0  2.0  0  1.0  0 \\\\\n     0  0  0  0  1.0  0  0.5 \\\\\n     0  0  1.0  0  0  0.5  0\n     \\end{bmatrix}.$$\n   - 种子集 $S = \\{1, 4\\}$。\n   - 重启概率 $\\gamma = 0.9$。\n   - 前 $k$ 个：$k = 3$。\n\n4) 用例4（边界情况，完全重启）：\n   - 使用与用例1中相同的 $A$。\n   - 种子集 $S = \\{0, 3\\}$。\n   - 重启概率 $\\gamma = 1.0$。\n   - 前 $k$ 个：$k = 2$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的前 $k$ 个索引列表。例如：“[$[i_{1,1},i_{1,2},\\dots]$, $[i_{2,1},\\dots]$, $[i_{3,1},\\dots]$, $[i_{4,1},\\dots]$]”。最终输出不得包含任何空格。", "solution": "该问题要求实现带重启的随机游走（RWR）算法，以对蛋白质-蛋白质相互作用（PPI）网络中的候选基因进行优先级排序。该方法利用离散时间马尔可夫链的数学框架，来量化网络节点与一组预定义的、与疾病相关的“种子”基因的邻近度。任务的核心是计算此过程的唯一稳态概率分布，并用它来对非种子基因进行排序。\n\n该模型的基础是代表PPI网络的图上的一个马尔可夫过程。一个包含 $n$ 个基因的网络由一个邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 描述，其中 $A_{ij} \\ge 0$ 表示基因 $i$ 和基因 $j$ 之间相互作用的强度。由于相互作用是无向的，因此 $A$ 是对称的，即 $A_{ij} = A_{ji}$。\n\n首先，我们从 $A$ 构建一个列随机转移矩阵 $W \\in \\mathbb{R}^{n \\times n}$。这个矩阵 $W$ 定义了网络上随机游走的转移概率。位于节点 $j$ 的游走者将以概率 $W_{ij}$ 移动到节点 $i$。为确保从节点 $j$ 移动到任何其他节点的总概率为1， $W$ 的每一列之和必须为1。这通过将 $A$ 的每一列除以其列和来实现：\n$$ W_{ij} = \\frac{A_{ij}}{\\sum_{k=1}^{n} A_{kj}} $$\n此归一化操作对每一列和 $\\sum_{k=1}^{n} A_{kj}$ 大于0的列 $j$ 进行。如果某列 $j$ 的和为0，则它对应一个没有出向连接的孤立节点。为了保持概率，这样的节点被建模为一个带有自环的汇点，即 $W_{jj} = 1$ 且对于 $i \\neq j$ 有 $W_{ij} = 0$。\n\nRWR过程通过引入“重启”机制来修改标准的随机游走。在每一步，游走者有两个选择：\n$1$. 以 $1 - \\gamma$ 的概率，它根据矩阵 $W$ 进行一次转移。\n$2$. 以 $\\gamma$ 的概率，它瞬移回某个种子节点。\n\n重启概率 $\\gamma \\in (0, 1]$ 是一个关键参数。重启的分布由种子向量 $s \\in \\mathbb{R}^n$ 控制。给定一个种子基因集 $S$， $s$ 被定义为在这些基因上的均匀分布：如果基因 $i \\in S$，则 $s_i = 1/|S|$，否则 $s_i = 0$。\n\n设 $p^{(t)} \\in \\mathbb{R}^n$ 为在步骤 $t$ 时所有 $n$ 个基因上的概率分布向量，其中 $p_i^{(t)}$ 是游走者位于节点 $i$ 的概率。下一步的分布 $p^{(t+1)}$ 由以下递归公式给出：\n$$ p^{(t+1)} = (1 - \\gamma) W p^{(t)} + \\gamma s $$\n该过程最终会收敛到一个唯一的稳态分布 $p^\\star$，该分布在后续步骤中不再改变。这个 $p^\\star$ 满足不动点方程：\n$$ p^\\star = (1 - \\gamma) W p^\\star + \\gamma s $$\n该向量的分量 $p^\\star_i$ 表示长期来看在节点 $i$ 找到游走者的概率，并被用作基因优先级排序的分数。分数越高，意味着与种子集的功能相关性越强。\n\n为了按照问题要求精确地找到 $p^\\star$，我们不迭代递推关系式。相反，我们将不动点方程重新整理成一个线性方程组：\n$$ p^\\star - (1 - \\gamma) W p^\\star = \\gamma s $$\n$$ (I - (1 - \\gamma) W) p^\\star = \\gamma s $$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。这是一个标准形式为 $M x = b$ 的线性系统，其中矩阵 $M = I - (1 - \\gamma) W$，未知向量是 $x = p^\\star$，常数向量是 $b = \\gamma s$。根据带传送的马尔可夫链理论，对于任何 $\\gamma \\in (0,1]$，矩阵 $M$ 保证是可逆的，从而确保 $p^\\star$ 有唯一解。这个解可以使用标准的线性代数求解器高效计算。当 $\\gamma = 1$ 的特殊情况下， $p^\\star = s$，因为游走者总是重启而从不遍历网络。\n\n解决该问题的算法如下：\n$1$. 对于给定的邻接矩阵 $A$，通过对 $A$ 的列进行归一化来构建转移矩阵 $W$。对于任何和为0的列，将 $W$ 中对应的对角元素设为1。\n$2$. 对于给定的种子集 $S$，构建在种子节点上具有均匀概率的种子向量 $s$。\n$3$. 构建矩阵 $M = I - (1 - \\gamma) W$ 和向量 $b = \\gamma s$。对于边界情况 $\\gamma=1$，$p^{\\star}$ 就是 $s$。\n$4$. 求解线性系统 $M p^\\star = b$ 以找到稳态向量 $p^\\star$。\n$5$. 为了数值鲁棒性，将计算出的 $p^\\star$ 中由浮点不精确性产生的任何微小负值裁剪为0。然后对向量进行重新归一化，以确保其元素之和为1。\n$6$. 识别所有非种子节点。为每个非种子节点 $i$ 创建一个序对列表 $(p^\\star_i, i)$。\n$7$. 按分数 $p^\\star_i$ 的降序对此列表进行排序。平分情况通过按节点索引 $i$ 的升序来打破。\n$8$. 最终结果是排序后列表中的前 $k$ 个索引。\n\n这种有原则的方法为基因优先级排序提供了一种可复现且数学上严谨的方法，直接解决了所述问题。它正确处理了诸如孤立节点和重启参数 $\\gamma$ 的边界值等边缘情况。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solving of all test cases.\n    \"\"\"\n\n    def _solve_rwr(A, S, gamma, k):\n        \"\"\"\n        Computes the Random Walk with Restart top-k gene ranking.\n\n        Args:\n            A (np.ndarray): The adjacency matrix of the network.\n            S (set): A set of integer indices for the seed nodes.\n            gamma (float): The restart probability.\n            k (int): The number of top non-seed nodes to return.\n\n        Returns:\n            list: A list of the top-k ranked non-seed node indices.\n        \"\"\"\n        n = A.shape[0]\n\n        # Step 1: Construct the column-stochastic transition matrix W\n        W = np.zeros_like(A, dtype=float)\n        col_sums = A.sum(axis=0)\n        \n        non_zero_sum_cols = col_sums > 1e-9 # Use a tolerance for floating point\n        zero_sum_cols = ~non_zero_sum_cols\n\n        # Normalize columns with non-zero sum\n        W[:, non_zero_sum_cols] = A[:, non_zero_sum_cols] / col_sums[non_zero_sum_cols]\n\n        # Handle isolated nodes (columns with zero sum)\n        for j in np.where(zero_sum_cols)[0]:\n            W[j, j] = 1.0\n\n        # Step 2: Construct the seed vector s\n        s = np.zeros(n)\n        if len(S) > 0:\n            s[list(S)] = 1.0 / len(S)\n\n        # Step 3  4: Solve the linear system (I - (1-gamma)W)p* = gamma*s\n        if gamma == 1.0:\n            p_star = s\n        else:\n            M = np.identity(n) - (1 - gamma) * W\n            b = gamma * s\n            p_star = np.linalg.solve(M, b)\n\n        # Step 5: Numerical stability post-processing\n        p_star = np.clip(p_star, a_min=0, a_max=None)\n        p_sum = p_star.sum()\n        if p_sum > 1e-9: # Avoid division by zero\n            p_star /= p_sum\n\n        # Step 6: Rank non-seed nodes\n        non_seed_indices = [i for i in range(n) if i not in S]\n        \n        if not non_seed_indices:\n            return []\n\n        candidates = [(p_star[i], i) for i in non_seed_indices]\n\n        # Step 7: Sort candidates: primary key score (desc), secondary key index (asc)\n        candidates.sort(key=lambda x: (-x[0], x[1]))\n        \n        # Step 8: Extract top-k indices\n        top_k_indices = [idx for score, idx in candidates[:k]]\n        \n        return top_k_indices\n\n    # Test suite definition\n    case1_A = np.array([\n        [0, 1, 0, 0, 0, 1],\n        [1, 0, 1, 1, 0, 0],\n        [0, 1, 0, 1, 0, 0],\n        [0, 1, 1, 0, 1, 0],\n        [0, 0, 0, 1, 0, 1],\n        [1, 0, 0, 0, 1, 0]\n    ], dtype=float)\n    case1_S = {0, 3}\n    case1_gamma = 0.35\n    case1_k = 3\n\n    case2_A = np.array([\n        [0, 1, 0, 0, 0],\n        [1, 0, 1, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0]\n    ], dtype=float)\n    case2_S = {4}\n    case2_gamma = 0.7\n    case2_k = 2\n\n    case3_A = np.array([\n        [0. , 2. , 1. , 0. , 0. , 0. , 0. ],\n        [2. , 0. , 0. , 1.5, 0. , 0. , 0. ],\n        [1. , 0. , 0. , 0.5, 0. , 0. , 1. ],\n        [0. , 1.5, 0.5, 0. , 2. , 0. , 0. ],\n        [0. , 0. , 0. , 2. , 0. , 1. , 0. ],\n        [0. , 0. , 0. , 0. , 1. , 0. , 0.5],\n        [0. , 0. , 1. , 0. , 0. , 0.5, 0. ]\n    ], dtype=float)\n    case3_S = {1, 4}\n    case3_gamma = 0.9\n    case3_k = 3\n\n    case4_A = case1_A.copy()\n    case4_S = {0, 3}\n    case4_gamma = 1.0\n    case4_k = 2\n    \n    test_cases = [\n        (case1_A, case1_S, case1_gamma, case1_k),\n        (case2_A, case2_S, case2_gamma, case2_k),\n        (case3_A, case3_S, case3_gamma, case3_k),\n        (case4_A, case4_S, case4_gamma, case4_k)\n    ]\n    \n    all_results = []\n    for A, S, gamma, k in test_cases:\n        result = _solve_rwr(A, S, gamma, k)\n        all_results.append(result)\n\n    # Format the final output string according to the specification (no spaces)\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[[{','.join(map(str,all_results[0]))}],[{','.join(map(str,all_results[1]))}],[{','.join(map(str,all_results[2]))}],[{','.join(map(str,all_results[3]))}]]\")\n\nsolve()\n```", "id": "5002343"}]}