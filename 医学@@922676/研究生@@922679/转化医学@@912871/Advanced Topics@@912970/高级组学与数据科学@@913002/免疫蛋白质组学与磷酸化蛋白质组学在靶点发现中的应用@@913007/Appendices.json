{"hands_on_practices": [{"introduction": "在开启一项免疫肽组学实验之前，审慎的实验设计是成功的基石。这项实践练习 [@problem_id:5022969] 将指导你完成一项关键的初步计算，即估算所需的最小细胞数量。这有助于你在实验产量和质谱仪检测极限之间建立联系，确保你的样本量足以实现研究目标。", "problem": "在一个旨在发现转化靶点的免疫肽组学工作流程中，从一个肿瘤细胞群中分离出人类白细胞抗原 (HLA) I 类肽，并通过质谱分析进行检测。从 $10^{7}$ 个细胞的输入中获得的总 HLA 肽量的经验产率通常报告在 $1$ 到 $5$ 飞摩尔 (fmol) 的范围内。该仪器对每种肽的检测限为 $50$ 阿摩尔 (amol)。采样效率定义为在单次运行中，高于阈值的肽被随机选择并成功识别的比例，其值为 $0.5$。假设如下：(i) 分离出的总 HLA 肽量均匀分布在所有存在的独特肽中，(ii) 只有当肽的量至少达到仪器检测限时，才认为该肽被检测到，以及 (iii) 采样效率作为一个乘法因子，应用于将被识别的、数量高于阈值的肽的数量。为了最小化所需的输入量，请使用所述范围内的最有利产率。\n\n计算在这些条件下检测到 $2{,}000$ 种独特肽所需的最小细胞数。请将最终答案表示为细胞数量。", "solution": "该问题被确定为有效，因为它在科学上基于蛋白质组学和质谱分析的原理，问题陈述清晰且可从所提供的数据中推导出唯一解，并以客观、正式的语言表述。我们开始求解。\n\n设 $N_{identified}$ 为目标识别的独特肽数量，给定值为 $N_{identified} = 2000$。\n设 $\\eta$ 为采样效率，给定值为 $\\eta = 0.5$。\n设 $LOD$ 为仪器对每种肽的检测限，给定值为 $LOD = 50$ 阿摩尔 (amol)。\n设 $N_{above\\_LOD}$ 为数量大于或等于 $LOD$ 的独特肽的数量。成功识别的肽的数量由以下关系描述：\n$$N_{identified} = \\eta \\times N_{above\\_LOD}$$\n要识别 $2000$ 种肽，高于检测限的肽的数量必须为：\n$$N_{above\\_LOD} = \\frac{N_{identified}}{\\eta} = \\frac{2000}{0.5} = 4000$$\n\n问题陈述了一个假设，即分离出的总 HLA 肽量 $A_{total}$ 均匀分布在所有存在的独特肽中，我们将其数量表示为 $N_{unique}$。这意味着每种肽的量 $A_{peptide}$ 对所有种类都是相同的：$A_{peptide} = \\frac{A_{total}}{N_{unique}}$。为了使任何肽能被检测到，其量必须至少为 $LOD$。由于是均匀分布，如果一种肽的数量高于 $LOD$，那么所有种类的肽都高于 $LOD$。因此，要检测到任何肽，我们需要所有 $N_{unique}$ 种肽的量都至少为 $LOD$。这得出的结论是，样本中所需的独特肽种类数量必须等于高于检测限所需的种类数量：\n$$N_{unique} = N_{above\\_LOD} = 4000$$\n\n所需的最小总肽量 $A_{total, min}$ 在每种独特肽的量恰好等于检测限时达到，即 $A_{peptide} = LOD$。\n$$A_{total, min} = N_{unique} \\times LOD$$\n代入数值：\n$$A_{total, min} = 4000 \\times 50 \\, \\text{amol} = 200000 \\, \\text{amol}$$\n为了与问题中提供的产率单位保持一致，我们使用转换因子 $1 \\, \\text{fmol} = 1000 \\, \\text{amol}$ 将此量从阿摩尔转换为飞摩尔 (fmol)。\n$$A_{total, min} = 200000 \\, \\text{amol} \\times \\frac{1 \\, \\text{fmol}}{1000 \\, \\text{amol}} = 200 \\, \\text{fmol}$$\n\n肽的产率以每 $10^7$ 个细胞（参考细胞数 $N_{cells, ref} = 10^7$）产出 $1$ 到 $5$ fmol 的范围给出。设 $Y$ 表示以 fmol 每 $10^7$ 个细胞为单位的产率。从 $N_{cells}$ 个细胞中获得的总肽量 $A_{total}$ 由以下比例关系给出：\n$$A_{total} = \\left(\\frac{Y}{N_{cells, ref}}\\right) \\times N_{cells}$$\n我们可以重新整理这个方程来求解所需的细胞数 $N_{cells}$：\n$$N_{cells} = \\frac{A_{total} \\times N_{cells, ref}}{Y}$$\n问题要求的是所需的最小细胞数。为了在固定的所需肽量（$A_{total, min}$）下最小化 $N_{cells}$，我们必须最大化产率 $Y$。从给定范围 $[1, 5]$ fmol，最大产率为 $Y_{max} = 5$ fmol 每 $10^7$ 个细胞。\n\n最后，我们将 $A_{total, min}$、$N_{cells, ref}$ 和 $Y_{max}$ 的值代入 $N_{cells}$ 的方程中：\n$$N_{cells} = \\frac{A_{total, min} \\times N_{cells, ref}}{Y_{max}} = \\frac{200 \\, \\text{fmol} \\times 10^7 \\, \\text{cells}}{5 \\, \\text{fmol}}$$\nfmol 单位相互抵消，得出细胞数。\n$$N_{cells} = \\frac{200}{5} \\times 10^7 = 40 \\times 10^7 = 4 \\times 10^8$$\n因此，检测到 $2000$ 种独特肽所需的最小细胞数为 $4 \\times 10^8$。", "answer": "$$\\boxed{4 \\times 10^{8}}$$", "id": "5022969"}, {"introduction": "在确定了起始样本的*数量*后，下一步是确定研究需要的样本*规模*，即参与者的数量。一项可靠的转化医学研究必须具备足够的统计功效，以确保能够稳定地检测到真实的生物学差异，避免浪费宝贵资源。本练习 [@problem_id:5022986] 深入探讨了功效分析的核心原理，要求你为一个磷酸化蛋白质组学研究推导并应用样本量计算公式，这是设计具有临床意义实验的一项核心技能。", "problem": "一项转化磷酸化蛋白质组学研究正在计划中，旨在通过比较疾病队列和匹配的对照队列之间的磷酸化位点丰度来发现可行的靶点。定量测量（例如，来自串联质谱法）经过以2为底的对数转换以稳定方差，因此以2为底的对数倍数变化为$1$对应于丰度的加倍。在相同的样本制备和采集条件下进行的一项初步研究，为候选磷酸化位点提供了在以2为底的对数尺度上的合并组内方差估计值$s_{p}^{2} = 0.50$。\n\n您将设计一个每组样本量相等的双臂研究，使用双样本$t$检验框架来检测在以2为底的对数尺度上组间均值的真实差异$\\delta = 1$。假设样本独立，各组方差相等，并且根据中心极限定理，样本均值之差的抽样分布可以很好地用高斯分布来近似。显著性水平为双侧$\\alpha = 0.05$，目标统计功效为$0.80$。\n\n从第一类和第二类错误的定义以及原假设和备择假设下均值差异的抽样分布出发，推导出在指定$\\alpha$水平下达到指定功效所需的高斯近似的每组样本量$n$，而无需调用任何预先记忆的样本量公式。然后，使用初步研究的方差估计值$s_{p}^{2}$作为近似计算中的共同方差，计算$n$的数值。\n\n使用以下四舍五入要求：将任何标准正态分位数四舍五入到四位有效数字，并将最终的每组样本量$n$报告为四位有效数字。不要将$n$四舍五入为整数；将其报告为实数。", "solution": "用户提供了一个问题，要求推导样本量公式并进行后续的数值计算。\n\n### 步骤1：提取已知条件\n-   **研究设计**：双臂研究，疾病组 vs. 对照组。\n-   **数据转换**：以2为底的对数转换。\n-   **统计检验**：双样本$t$检验框架，使用高斯（正态）近似。\n-   **样本量**：每组样本量相等，$n_1 = n_2 = n$。\n-   **假设**：样本独立，方差相等。\n-   **方差估计**：在以2为底的对数尺度上的合并组内方差，$s_{p}^{2} = 0.50$。这将用作共同方差$\\sigma^2$。\n-   **效应大小**：要检测的组间均值真实差异，$\\delta = 1$。\n-   **显著性水平**：双侧$\\alpha = 0.05$。\n-   **统计功效**：目标功效为$1-\\beta = 0.80$。\n-   **四舍五入**：标准正态分位数保留四位有效数字；最终样本量$n$保留四位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学依据**：该问题在生物统计学和实验设计方面有充分的依据。双样本检验的功效分析是一个标准程序。磷酸化蛋白质组学的背景是现实的，质谱数据使用对数转换也是如此。指定的参数（$\\alpha$、功效、$\\delta$、$\\sigma^2$）在此类研究中是典型的。\n-   **适定性**：该问题是适定的。它清楚地定义了目标：从第一性原理推导样本量公式，然后计算其值。所有必要的参数和假设都已提供。存在一个唯一的、有意义的解。\n-   **客观性**：该问题以精确、客观的语言陈述，没有偏见或主观断言。\n\n该问题不违反任何指定的无效性标准。它是科学合理的、可形式化的、完整的、现实的、适定的和非平凡的。\n\n### 步骤3：结论和行动\n该问题是**有效的**。将提供解答。\n\n### 样本量公式的推导\n设$\\mu_1$和$\\mu_2$分别为疾病组和对照组对数转换后磷酸化位点丰度的真实总体均值。设$\\bar{X}_1$和$\\bar{X}_2$为来自大小为$n$的样本的相应样本均值。共同的总体方差为$\\sigma^2$，我们将用$s_p^2$来估计它。要检测的差异是$\\delta = \\mu_1 - \\mu_2$。\n\n双侧检验的原假设和备择假设是：\n$$H_0: \\mu_1 - \\mu_2 = 0$$\n$$H_A: \\mu_1 - \\mu_2 \\neq 0$$\n\n检验统计量基于样本均值之差$\\bar{X}_1 - \\bar{X}_2$。由于样本的独立性和方差相等$\\sigma^2$的假设，该差异的方差为：\n$$\\text{Var}(\\bar{X}_1 - \\bar{X}_2) = \\text{Var}(\\bar{X}_1) + \\text{Var}(\\bar{X}_2) = \\frac{\\sigma^2}{n} + \\frac{\\sigma^2}{n} = \\frac{2\\sigma^2}{n}$$\n差异的标准误是 $SE = \\sqrt{\\frac{2\\sigma^2}{n}}$。\n\n问题指定使用高斯近似。因此，均值差异的抽样分布近似为：\n$$\\bar{X}_1 - \\bar{X}_2 \\sim N\\left(\\mu_1 - \\mu_2, \\frac{2\\sigma^2}{n}\\right)$$\n\n**第一类错误（$\\alpha$）的条件**\n在原假设（$H_0$）下，$\\mu_1 - \\mu_2 = 0$。抽样分布为$\\bar{X}_1 - \\bar{X}_2 \\sim N(0, \\frac{2\\sigma^2}{n})$。当我们拒绝真实的$H_0$时，会发生第一类错误。对于显著性水平为$\\alpha$的双侧检验，如果观察到的差异离$0$足够远，我们就拒绝$H_0$。拒绝域由临界值定义，这些临界值在标准正态分布的每个尾部切掉$\\alpha/2$的面积。设$z_{\\alpha/2}$为标准正态分位数，使得$P(Z > z_{\\alpha/2}) = \\alpha/2$，其中$Z$是标准正态随机变量。\n\n如果$|\\bar{X}_1 - \\bar{X}_2| > C$，我们就拒绝$H_0$，其中$C$是差异的临界值。为了找到$C$，我们进行标准化：\n$$\\frac{C - 0}{\\sqrt{2\\sigma^2/n}} = z_{\\alpha/2}$$\n$$C = z_{\\alpha/2} \\sqrt{\\frac{2\\sigma^2}{n}}$$\n所以，如果$\\bar{X}_1 - \\bar{X}_2 > z_{\\alpha/2} \\sqrt{\\frac{2\\sigma^2}{n}}$或$\\bar{X}_1 - \\bar{X}_2  -z_{\\alpha/2} \\sqrt{\\frac{2\\sigma^2}{n}}$，我们就拒绝$H_0$。\n\n**统计功效（$1-\\beta$）的条件**\n统计功效是在备择假设（$H_A$）为真时正确拒绝$H_0$的概率。我们针对一个特定的备择假设$\\mu_1 - \\mu_2 = \\delta$来评估功效。在此备择假设下，抽样分布为$\\bar{X}_1 - \\bar{X}_2 \\sim N(\\delta, \\frac{2\\sigma^2}{n})$。\n\n对于$\\delta  0$，落入下拒绝域（$\\bar{X}_1 - \\bar{X}_2  -C$）的概率可以忽略不计。因此，可以通过只考虑上拒绝域来近似功效：\n$$\\text{Power} = 1 - \\beta \\approx P\\left(\\bar{X}_1 - \\bar{X}_2  C \\mid \\mu_1 - \\mu_2 = \\delta\\right)$$\n为了计算这个概率，我们相对于$H_A$下的分布对临界值$C$进行标准化：\n$$1 - \\beta = P\\left( \\frac{(\\bar{X}_1 - \\bar{X}_2) - \\delta}{\\sqrt{2\\sigma^2/n}}  \\frac{C - \\delta}{\\sqrt{2\\sigma^2/n}} \\right)$$\n概率内的左边项是一个标准正态变量$Z$。设$z_\\beta$是标准正态分位数，使得$P(Z  z_\\beta) = \\beta$。那么$P(Z  -z_\\beta) = 1-\\beta$。因此，我们必须有：\n$$-z_\\beta = \\frac{C - \\delta}{\\sqrt{2\\sigma^2/n}}$$\n\n现在，我们将第一类错误条件中的$C$的表达式代入：\n$$-z_\\beta = \\frac{z_{\\alpha/2} \\sqrt{\\frac{2\\sigma^2}{n}} - \\delta}{\\sqrt{2\\sigma^2/n}} = z_{\\alpha/2} - \\frac{\\delta}{\\sqrt{\\frac{2\\sigma^2}{n}}}$$\n重新整理以求解包含$n$的项：\n$$\\frac{\\delta}{\\sqrt{\\frac{2\\sigma^2}{n}}} = z_{\\alpha/2} + z_\\beta$$\n两边平方：\n$$\\frac{\\delta^2}{\\frac{2\\sigma^2}{n}} = (z_{\\alpha/2} + z_\\beta)^2$$\n$$\\frac{n\\delta^2}{2\\sigma^2} = (z_{\\alpha/2} + z_\\beta)^2$$\n最后，解出每组的样本量$n$：\n$$n = \\frac{2\\sigma^2(z_{\\alpha/2} + z_\\beta)^2}{\\delta^2}$$\n这是在高斯近似下，从第一性原理推导出的双样本检验中每组样本量的一般公式。\n\n### 数值计算\n我们现在将给定值代入推导出的公式中。\n-   $\\sigma^2 \\approx s_{p}^{2} = 0.50$\n-   $\\delta = 1$\n-   $\\alpha = 0.05 \\implies \\alpha/2 = 0.025$\n-   $1-\\beta = 0.80 \\implies \\beta = 0.20$\n\n我们需要找到标准正态分位数$z_{0.025}$和$z_{0.20}$。问题要求将这些值四舍五入到四位有效数字。\n-   $z_{\\alpha/2} = z_{0.025}$是累积概率为$1-0.025 = 0.975$时的值。从标准正态分布表或计算器中，该值约为$1.95996$。四舍五入到四位有效数字，得到$z_{0.025} = 1.960$。\n-   $z_\\beta = z_{0.20}$是累积概率为$1-0.20 = 0.80$时的值。从标准正态分布表或计算器中，该值约为$0.84162$。四舍五入到四位有效数字，得到$z_{0.20} = 0.8416$。\n\n将这些值代入样本量公式：\n$$n = \\frac{2(0.50)(1.960 + 0.8416)^2}{(1)^2}$$\n$$n = \\frac{1 \\times (2.8016)^2}{1}$$\n$$n = (2.8016)^2$$\n$$n = 7.84896256$$\n\n问题要求将$n$的最终值报告为四位有效数字。\n$$n \\approx 7.849$$\n这表示为达到指定功效所需的非整数的每组样本量。在实际操作中，通常会将其向上取整到下一个整数（即每组8名参与者）。然而，问题明确要求报告实数结果。", "answer": "$$\n\\boxed{7.849}\n$$", "id": "5022986"}, {"introduction": "这项综合性实践将基因组学和蛋白质组学紧密结合在一起，是发现新靶点的关键环节。为了鉴定肿瘤特异性的新抗原或异常的磷酸化信号，我们必须首先根据患者的个体化基因数据构建一个个性化的蛋白质数据库。这个全面的编程练习 [@problem_id:5023010] 模拟了从处理基因变异到生成和分析候选肽段的完整生物信息学工作流程，让你亲手实践蛋白基因组学的核心技术。", "problem": "您需要实现一个独立的计算工作流，该工作流将来自类变体调用格式（VCF）和类基因转移格式（GTF）注释的简化肿瘤变体表示，转换为个性化蛋白质数据库，并量化与免疫蛋白质组学和磷酸化蛋白质组学相关的可观测量。该工作流必须从分子生物学中心法则（脱氧核糖核酸到核糖核酸到蛋白质）、确定性密码子翻译和蛋白酶切割特异性等原理出发，并且必须以纯算法术语表达，不依赖外部文件或网络。\n\n基本依据和定义：\n- 中心法则：编码脱氧核糖核酸（DNA）以连续的三联体（称为密码子）进行解释，以产生氨基酸序列。存在由标准遗传密码指定的、公认的密码子到氨基酸的映射关系。\n- 开放阅读框：翻译从编码脱氧核糖核酸的第一个碱基开始，以密码子为步长进行；终止密码子会终止翻译。对于本任务，所有提供的编码序列都是同框的，并且不包含终止密码子，除非因插入或删除引入了移码。\n- 蛋白酶特异性：胰蛋白酶在赖氨酸和精氨酸残基（分别由氨基酸 $K$ 和 $R$ 表示）之后进行切割，除非下一个残基是脯氨酸（由 $P$ 表示）。形式上，如果蛋白质序列为 $P = p_1 p_2 \\dots p_n$，则当且仅当 $p_i \\in \\{K,R\\}$ 并且 $i = n$ 或 $p_{i+1} \\neq P$ 时，在位置 $i$ 之后发生切割。\n- 肽段长度过滤器：仅保留长度在 $8$ 到 $11$ 个残基之间（含两端）的肽段。\n- 磷酸化位点基序替代物：如果一个肽段包含子字符串 $SP$ 或 $TP$（丝氨酸-脯氨酸或苏氨酸-脯氨酸），则标记该肽段含有潜在的脯氨酸导向的磷酸化基序。\n\n需要建模的变异事件定义：\n- 单核苷酸变异（SNV）：在编码DNA的指定 $0$-based 索引处更改单个碱基。\n- 插入或删除（indel）：在 $0$-based 位置用一个备用子字符串替换指定的参考子字符串（对于删除，备用子字符串可以为空）。所有位置都是编码DNA字符串上的 $0$-based 索引。\n- 基因融合：通过取一个转录本的前缀（直到指定的左断点碱基索引）并将其与第二个转录本的后缀（从指定的右起始碱基索引开始）连接，来构建一个嵌合编码DNA。两个索引都是 $0$-based 并且必须是 $3$ 的倍数以保持阅读框。\n- 可变剪接（外显子跳跃）：通过从转录本的外显子列表中移除指定的外显子（由 $1$-based 索引给出），并按顺序连接剩余的外显子，来生成一个异构体。\n\n参考数据：\n- 转录本的编码DNA序列（连接成连续字符串，全部同框）：\n    - 转录本 $T1$：\n      ATGGCTGTTCTGCAATCTGGTGTTAAATCTGCTCTGGAAACTCAAAATGTTCGTACTCTGGTTCTACTACTGCTGGTCGT\n    - 转录本 $T2$：\n      ATGCTGGCTGAAGAAGTTGTTAAAGCTAATCTGACTGTTTCTGCTCGT\n    - 转录本 $T3$ 外显子（用于外显子跳跃事件）：\n        - 外显子 $1$： ATGGCTCAAGTTGCT\n        - 外显子 $2$： TCTGCTAAAACT\n        - 外显子 $3$： GTTTCTGCTGGTCGT\n      完整的参考 $T3$ 编码DNA是按顺序连接外显子 $1$–$3$ 的结果。\n\n假设与约束：\n- 所有转录本编码DNA均为大写，且仅使用 $\\{A,C,G,T\\}$。\n- 所有为融合提供的断点都是 $3$ 的倍数。\n- 翻译使用标准遗传密码；如果由于移码而出现终止密码子，翻译在第一个终止密码子处停止。\n- 胰蛋白酶切割遵循上述定义规则；在长度过滤之前，丢弃空的肽段片段。\n- 个性化蛋白质数据库是通过对每个测试案例的参考输入应用指定事件而生成的唯一蛋白质序列的集合。参考肽段是从未经修饰的 $T1$、$T2$ 和 $T3$ 蛋白质计算得出的。\n\n您的程序必须实现以下操作：\n- 通过将每个密码子映射到其氨基酸来将编码DNA翻译成蛋白质；如果遇到终止密码子，则停止翻译。\n- 按照定义应用SNV、indel、融合和可变剪接，以产生变异编码DNA，然后翻译成变异蛋白质。\n- 对参考蛋白质和变异蛋白质进行胰蛋白酶消化，然后仅保留长度在 $8$ 到 $11$（含）之间的肽段。\n- 计算每个测试案例的以下内容：\n    $1.$ 个性化数据库中不同变异蛋白质的数量（一个整数）。\n    $2.$ 从个性化数据库中衍生的不同胰蛋白酶肽段（长度 $8$–$11$（含））的数量（一个整数）。\n    $3.$ 新肽的数量，定义为在相应的 $T1$、$T2$ 和 $T3$ 参考肽段中不存在的变异肽段（一个整数）。\n    $4.$ 至少包含一个 $SP$ 或 $TP$ 基序的新肽的数量（一个整数）。\n\n测试套件：\n在以下测试案例上实现该工作流。所有位置对于碱基是 $0$-based，对于外显子索引是 $1$-based。\n\n- 测试案例 $1$（单核苷酸变异）：\n    - 事件：在 $T1$ 的碱基索引 $30$ 处发生单个SNV，将参考碱基 $G$ 更改为备用碱基 $C$。\n\n- 测试案例 $2$（同框删除）：\n    - 事件：在 $T2$ 的碱基索引 $9$ 处发生单个indel，删除子字符串 $GAA$（即，保持框内的三碱基删除）。\n\n- 测试案例 $3$（基因融合）：\n    - 事件：$T1$ 和 $T2$ 之间的融合，由取 $T1$ 直到碱基索引 $36$ 的前缀和 $T2$ 从碱基索引 $9$ 开始的后缀，同框连接而成。\n\n- 测试案例 $4$（可变剪接，外显子跳跃）：\n    - 事件：在 $T3$ 上发生的可变剪接事件，跳过外显子索引 $2$（外显子索引是 $1$-based）。\n\n- 测试案例 $5$（组合事件）：\n    - 事件：联合应用上述所有事件（$T1$ 上的SNV、$T2$ 上的同框删除、$T1$–$T2$ 融合以及 $T3$ 外显子 $2$ 跳跃）。个性化数据库包含由这些事件产生的所有唯一变异蛋白质。\n\n输出规范：\n- 对于上面给出的每个测试案例，按顺序计算列表 $[n_{\\mathrm{var\\_proteins}}, n_{\\mathrm{var\\_peptides}}, n_{\\mathrm{neo}}, n_{\\mathrm{neo\\_motif}}]$，其中所有条目都是如上定义的整数。\n- 您的程序应生成单行输出，其中包含所有测试案例的结果，形式为方括号括起来的逗号分隔列表的列表，例如，`[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],…]`，不插入空格。\n\n角度单位和物理单位不适用。所有输出均为定义的整数。您的程序的正确性将根据其为上述测试套件打印的精确聚合列表进行评估。", "solution": "用户提供了一个计算问题，该问题模拟了用于个性化蛋白质组学的生物信息学工作流。我将首先验证问题陈述，如果有效，则提供一个合理的解决方案和实现。\n\n### 问题验证\n\n**第1步：提取给定信息**\n\n- **参考数据结构：**\n    - 转录本 $T1$ 编码DNA (cDNA)：`ATGGCTGTTCTGCAATCTGGTGTTAAATCTGCTCTGGAAACTCAAAATGTTCGTACTCTGGTTCTACTACTGCTGGTCGT`\n    - 转录本 $T2$ cDNA：`ATGCTGGCTGAAGAAGTTGTTAAAGCTAATCTGACTGTTTCTGCTCGT`\n    - 转录本 $T3$ 外显子：\n        - 外显子 $1$：`ATGGCTCAAGTTGCT`\n        - 外显子 $2$：`TCTGCTAAAACT`\n        - 外显子 $3$：`GTTTCTGCTGGTCGT`\n- **生物学与化学规则：**\n    - **翻译：** 使用标准遗传密码将cDNA密码子翻译成氨基酸。翻译在第一个终止密码子处终止。\n    - **蛋白水解：** 胰蛋白酶在残基 $p_i$ 之后切割蛋白质序列 $P = p_1 p_2 \\dots p_n$，当且仅当 $p_i \\in \\{K,R\\}$（赖氨酸或精氨酸）且（$i = n$ 或 $p_{i+1} \\neq P$（脯氨酸））。\n    - **肽段过滤：** 只考虑长度在 $8$ 到 $11$ 个氨基酸之间（含）的肽段。\n    - **磷酸化位点基序：** 如果肽段包含子字符串 `SP` 或 `TP`，则对其进行标记。\n- **遗传事件定义：**\n    - **SNV（单核苷酸变异）：** 在cDNA的指定 $0$-based 索引处更改单个碱基。\n    - **Indel（插入/删除）：** 在cDNA的 $0$-based 索引处，用一个备用子字符串替换一个子字符串。\n    - **基因融合：** 通过连接一个转录本的前缀和另一个转录本的后缀形成嵌合cDNA。断点是 $0$-based 且为 $3$ 的倍数。\n    - **可变剪接（外显子跳跃）：** 通过从转录本的外显子列表中省略指定的外显子（由 $1$-based 索引给出）来生成一个异构体。\n- **测试套件与输出：**\n    1. **案例1 (SNV)：** 在 $T1$ 的索引 $30$ 处，将参考碱基更改为 `C`。\n    2. **案例2 (Indel)：** 在 $T2$ 的索引 $9$ 处，删除子字符串 `GAA`。\n    3. **案例3 (融合)：** 将 $T1$（直到索引 $36$ 的前缀）与 $T2$（从索引 $9$ 开始的后缀）融合。\n    4. **案例4 (剪接)：** 在 $T3$ 上，跳过外显子 $2$（$1$-based 索引）。\n    5. **案例5 (组合)：** 应用案例1-4中的所有事件。个性化数据库是这些事件产生的所有唯一变异蛋白质的集合。\n- **每个测试案例所需的指标：** 程序必须计算一个包含四个整数的列表：$[n_{\\mathrm{var\\_proteins}}, n_{\\mathrm{var\\_peptides}}, n_{\\mathrm{neo}}, n_{\\mathrm{neo\\_motif}}]$。\n    - $n_{\\mathrm{var\\_proteins}}$：唯一变异蛋白质序列的数量。\n    - $n_{\\mathrm{var\\_peptides}}$：来自变异蛋白质的、经过长度过滤的唯一胰蛋白酶肽段的数量。\n    - $n_{\\mathrm{neo}}$：在未经修饰的 $T1$、$T2$ 和 $T3$ 的参考肽段集合中不存在的变异肽段数量。\n    - $n_{\\mathrm{neo\\_motif}}$：含有 `SP` 或 `TP` 基序的新肽数量。\n\n**第2步：使用提取的给定信息进行验证**\n\n- **科学依据充分：** 该问题是一个基于分子生物学基本原理的、基础扎实的模拟，包括中心法则、密码子翻译和酶促蛋白质消化。虽然经过简化，但并未违反科学事实。它准确地模拟了常见的遗传变异类型。\n- **定义明确：** 该问题是确定性的且定义明确。输入、操作规则和期望输出都以数学和算法的精度进行定义。所有必要的数据都已提供，且约束条件（例如，融合断点是 $3$ 的倍数）确保了操作的明确定义（即，保持阅读框）。\n- **客观性：** 问题陈述是客观的，使用了正式、无歧义的技术语言，没有主观解释的余地。\n\n该问题没有任何无效性缺陷。这是一个可形式化和可解决的计算练习，与免疫蛋白质组学和磷酸化蛋白质组学的指定主题领域直接相关。\n\n**第3步：结论与行动**\n\n- **结论：** 问题是**有效的**。\n- **行动：** 继续进行解决方案。\n\n### 解决方案设计\n\n该计算工作流将通过将其分解为一系列模块化函数来实现，每个函数对应一个核心生物学过程。整体设计遵循基于原理的方法，从参考遗传物质开始，逐步应用问题中定义的转换。\n\n**1. 数据初始化和常量：**\n首先，我们建立模型的常量：转录本 $T1$、$T2$ 和 $T3$ 外显子的参考DNA序列，以及将密码子映射到氨基酸的标准遗传密码。使用特殊字符 `*` 表示终止密码子。\n\n**2. 核心生物学过程函数：**\n- **`translate(dna_seq)`：** 此函数实现中心法则的翻译步骤。它遍历输入的DNA序列，每次取三个碱基（一个密码子）。使用遗传密码字典将每个密码子映射到其对应的氨基酸。如果遇到终止密码子（`*`），则终止翻译，并返回到目前为止合成的蛋白质序列。这正确地模拟了翻译终止的生物学过程。\n- **`digest(protein_seq)`：** 此函数模拟胰蛋白酶的蛋白水解切割。它遍历蛋白质序列并根据规则识别切割位点：在氨基酸 $p_i \\in \\{K, R\\}$ 之后进行切割，除非后续氨基酸 $p_{i+1}$ 是 $P$。如果 $p_i$ 是C端（最后一个）残基，也会发生切割。该函数返回一个包含所得肽段片段的列表。\n- **`filter_peptides(peptides)`：** 这个实用函数应用指定的长度过滤器，仅保留长度在 $8$ 到 $11$ 个残基之间（含）的肽段。\n\n**3. 变异生成与分析工作流：**\n主逻辑协调这些函数以解决每个测试案例。\n- **参考肽段集计算：** 在处理测试案例之前，会生成一个全面的参考肽段集合。将 $T1$、$T2$ 和 $T3$（由其外显子连接而成）的参考cDNA分别进行翻译、消化和过滤。将得到的肽段收集到一个集合 `ref_peptides` 中，该集合作为识别新肽的基线。\n- **事件驱动的变异生成：** 对于每个测试案例，我们处理一个指定的遗传事件列表。设计一个辅助函数 `apply_events` 来解释每种事件类型（SNV、indel、融合、剪接），并对适当的参考DNA序列应用相应的转换，从而产生一个或多个变异DNA序列。将这些序列收集到一个集合中，以处理可能出现的相同DNA序列。\n- **个性化蛋白质组和肽组分析：** 将变异DNA序列集合翻译成一个唯一的变异蛋白质集合，形成“个性化蛋白质数据库”。该集合的基数即为 $n_{\\mathrm{var\\_proteins}}$。然后，对每个唯一的变异蛋白质进行消化和过滤，生成一个“变异肽段”集合。该集合的大小即为 $n_{\\mathrm{var\\_peptides}}$。\n- **新肽和基序的量化：** 通过计算变异肽段集合与参考肽段集合的集合论差集来得到新肽集合。结果集合的大小即为 $n_{\\mathrm{neo}}$。最后，扫描每个新肽中是否存在 `'SP'` 或 `'TP'` 子字符串，以计算 $n_{\\mathrm{neo\\_motif}}$。\n\n**4. 测试案例执行：**\n为问题中定义的五个测试案例中的每一个执行工作流。收集每个案例的四个计算指标（$n_{\\mathrm{var\\_proteins}}, n_{\\mathrm{var\\_peptides}}, n_{\\mathrm{neo}}, n_{\\mathrm{neo\\_motif}}$）。最终输出按照规范格式化为单行的、类似JSON的数组的数组，不含空格。这种结构化的、分步的过程确保了问题陈述中的每个生物学规则和计算要求都得到正确和稳健的实现。", "answer": "```python\n# The final answer must be a single, complete, standalone program.\n# The code must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are permitted.\n\ndef solve():\n    \"\"\"\n    Implements a self-contained computational workflow to simulate a personalized\n    proteogenomics analysis, from variant DNA to immunologically relevant observables.\n    \"\"\"\n    \n    # 1. Define fundamental constants and reference data\n    GENETIC_CODE = {\n        'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAT': 'N',\n        'ACA': 'T', 'ACC': 'T', 'ACG': 'T', 'ACT': 'T',\n        'AGA': 'R', 'AGC': 'S', 'AGG': 'R', 'AGT': 'S',\n        'ATA': 'I', 'ATC': 'I', 'ATG': 'M', 'ATT': 'I',\n        'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAT': 'H',\n        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCT': 'P',\n        'CGA': 'R', 'CGC': 'R', 'CGG': 'R', 'CGT': 'R',\n        'CTA': 'L', 'CTC': 'L', 'CTG': 'L', 'CTT': 'L',\n        'GAA': 'E', 'GAC': 'D', 'GAG': 'E', 'GAT': 'D',\n        'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCT': 'A',\n        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGT': 'G',\n        'GTA': 'V', 'GTC': 'V', 'GTG': 'V', 'GTT': 'V',\n        'TAA': '*', 'TAC': 'Y', 'TAG': '*', 'TAT': 'Y',\n        'TCA': 'S', 'TCC': 'S', 'TCG': 'S', 'TCT': 'S',\n        'TGA': '*', 'TGC': 'C', 'TGG': 'W', 'TGT': 'C',\n        'TTA': 'L', 'TTC': 'F', 'TTG': 'L', 'TTT': 'F'\n    }\n\n    REFS = {\n        'T1': \"ATGGCTGTTCTGCAATCTGGTGTTAAATCTGCTCTGGAAACTCAAAATGTTCGTACTCTGGTTCTACTACTGCTGGTCGT\",\n        'T2': \"ATGCTGGCTGAAGAAGTTGTTAAAGCTAATCTGACTGTTTCTGCTCGT\",\n        'T3_exons': [\n            \"ATGGCTCAAGTTGCT\",\n            \"TCTGCTAAAACT\",\n            \"GTTTCTGCTGGTCGT\",\n        ]\n    }\n    REFS['T3'] = \"\".join(REFS['T3_exons'])\n\n    # 2. Define core biological process functions\n    def translate(dna_seq):\n        \"\"\"Translates a DNA sequence into a protein sequence.\"\"\"\n        protein = []\n        for i in range(0, len(dna_seq) - len(dna_seq) % 3, 3):\n            codon = dna_seq[i:i+3]\n            aa = GENETIC_CODE.get(codon, '')\n            if aa == '*':\n                break\n            protein.append(aa)\n        return \"\".join(protein)\n\n    def digest(protein_seq):\n        \"\"\"Digests a protein with trypsin.\"\"\"\n        peptides = []\n        start = 0\n        for i, aa in enumerate(protein_seq):\n            if aa in ('K', 'R'):\n                if i == len(protein_seq) - 1 or protein_seq[i+1] != 'P':\n                    peptide = protein_seq[start:i+1]\n                    if peptide:\n                        peptides.append(peptide)\n                    start = i + 1\n        \n        if start  len(protein_seq):\n            final_peptide = protein_seq[start:]\n            if final_peptide:\n                peptides.append(final_peptide)\n        return peptides\n\n    def filter_peptides(peptides, min_len=8, max_len=11):\n        \"\"\"Filters peptides by length.\"\"\"\n        return {p for p in peptides if min_len = len(p) = max_len}\n\n    # 3. Pre-calculate the reference peptidome\n    ref_proteins = [translate(REFS[tid]) for tid in ['T1', 'T2', 'T3']]\n    ref_peptides = set()\n    for prot in ref_proteins:\n        peps = digest(prot)\n        ref_peptides.update(filter_peptides(peps))\n\n    # 4. Define variant events for each test case\n    test_cases = [\n        # Case 1: SNV\n        [('snv', 'T1', 30, 'C')],\n        # Case 2: Indel\n        [('indel', 'T2', 9, 'GAA', '')],\n        # Case 3: Fusion\n        [('fusion', 'T1', 36, 'T2', 9)],\n        # Case 4: Splicing\n        [('splice', 'T3', {2})],\n        # Case 5: Combined\n        [\n            ('snv', 'T1', 30, 'C'),\n            ('indel', 'T2', 9, 'GAA', ''),\n            ('fusion', 'T1', 36, 'T2', 9),\n            ('splice', 'T3', {2})\n        ]\n    ]\n\n    # 5. Process each test case\n    final_results = []\n    for events in test_cases:\n        variant_dnas = set()\n        for event in events:\n            etype = event[0]\n            if etype == 'snv':\n                _, t_id, pos, alt = event\n                dna = REFS[t_id]\n                var_dna = dna[:pos] + alt + dna[pos+1:]\n                variant_dnas.add(var_dna)\n            elif etype == 'indel':\n                _, t_id, pos, ref_sub, alt_sub = event\n                dna = REFS[t_id]\n                var_dna = dna[:pos] + alt_sub + dna[pos+len(ref_sub):]\n                variant_dnas.add(var_dna)\n            elif etype == 'fusion':\n                _, t1_id, bp1, t2_id, bp2 = event\n                dna1 = REFS[t1_id]\n                dna2 = REFS[t2_id]\n                var_dna = dna1[:bp1] + dna2[bp2:]\n                variant_dnas.add(var_dna)\n            elif etype == 'splice':\n                _, t_id, skip_indices = event\n                exons = REFS[f\"{t_id}_exons\"]\n                kept_exons = [exon for i, exon in enumerate(exons, 1) if i not in skip_indices]\n                var_dna = \"\".join(kept_exons)\n                variant_dnas.add(var_dna)\n\n        # Generate personalized proteome and peptidome\n        variant_proteins = {translate(dna) for dna in variant_dnas}\n        \n        variant_peptides = set()\n        for prot in variant_proteins:\n            peps = digest(prot)\n            variant_peptides.update(filter_peptides(peps))\n\n        # Compute metrics\n        n_var_proteins = len(variant_proteins)\n        n_var_peptides = len(variant_peptides)\n        \n        neo_peptides = variant_peptides - ref_peptides\n        n_neo = len(neo_peptides)\n        \n        n_neo_motif = sum(1 for p in neo_peptides if 'SP' in p or 'TP' in p)\n        \n        final_results.append([n_var_proteins, n_var_peptides, n_neo, n_neo_motif])\n    \n    # 6. Print the final aggregated output in the required format\n    # The format must be a list of lists, stringified without spaces.\n    results_str = \",\".join([str(res).replace(\" \", \"\") for res in final_results])\n    print(f\"[{results_str}]\")\n\n\nsolve()\n```", "id": "5023010"}]}