{"hands_on_practices": [{"introduction": "在群体基因组学研究中，首要步骤之一是描述群体的遗传构成。哈迪-温伯格平衡（Hardy-Weinberg Equilibrium, HWE）为此提供了一个基础的零假设模型，它描述了在一个不存在演化影响（如非随机交配、自然选择、突变或遗传漂变）的理想群体中，等位基因和基因型频率代代相传的稳定性。这项练习将带你实践如何检验观察到的基因型数据是否偏离HWE，这是基因组数据质量控制和群体遗传分析中的一项基本技能。[@problem_id:5047855]", "problem": "在一项转化医学的精准公共卫生项目中，开展了一项全县范围的药物基因组学筛查，以评估与华法林剂量相关的维生素K环氧化物还原酶复合体$1$（$\\text{VKORC1}$）基因中一个单核苷酸多态性（SNP）的群体水平基因型分布。在一个遗传多样化的城市人口中，随机抽取了$N=1000$名无亲缘关系的成年人作为样本，高质量的基因分型得到了等位基因$A$和$a$的以下观测基因型计数：$AA=400$，$Aa=400$，$aa=200$。假设所有个体均无亲缘关系，且基因分型误差可忽略不计。请运用群体遗传学基础——二倍体群体中的等位基因频率定义以及源于随机交配和孟德尔遗传的哈迪-温伯格平衡（HWE）原理——计算等位基因$A$的频率$p$和等位基因$a$的频率$q$，HWE下的预期基因型计数，以及检验与HWE偏离的皮尔逊卡方拟合优度统计量。将等位基因频率视为从样本中估计得出，因此在检验中使用适当的自由度。报告卡方检验统计量作为您的最终数值答案，四舍五入至四位有效数字。无需单位。", "solution": "问题陈述已经过分析，被认为是有效的。它在科学上基于群体遗传学原理，问题提出得很好，数据充分且一致，陈述客观。药物基因组学和`VKORC1`基因的背景是转化医学中一个标准且恰当的例子。因此，我们可以继续进行求解。\n\n该问题要求计算皮尔逊卡方（$\\chi^2$）拟合优度统计量，以检验特定SNP的观测基因型计数是否符合哈迪-温伯格平衡（HWE）的预期。求解过程包括三个主要步骤：\n1. 根据观测到的基因型计数计算等位基因频率。\n2. 使用这些等位基因频率计算HWE下的预期基因型计数。\n3. 使用观测计数和预期计数计算$\\chi^2$统计量。\n\n从$N=1000$个体的样本中得到的观测基因型计数如下：\n-   基因型为$AA$的个体数：$N_{AA} = 400$\n-   基因型为$Aa$的个体数：$N_{Aa} = 400$\n-   基因型为$aa$的个体数：$N_{aa} = 200$\n\n样本中的个体总数为$N = N_{AA} + N_{Aa} + N_{aa} = 400 + 400 + 200 = 1000$，与问题陈述一致。\n\n**步骤1：计算等位基因频率**\n等位基因$A$和$a$的频率（分别用$p$和$q$表示）是根据观测计数计算的。在一个大小为$N$的二倍体群体中，共有$2N$个等位基因。\n等位基因$A$的总数是$AA$纯合子数量的两倍加上$Aa$杂合子的数量。\n$$ \\text{Count}(A) = (2 \\times N_{AA}) + N_{Aa} = (2 \\times 400) + 400 = 800 + 400 = 1200 $$\n等位基因$a$的总数是$aa$纯合子数量的两倍加上$Aa$杂合子的数量。\n$$ \\text{Count}(a) = (2 \\times N_{aa}) + N_{Aa} = (2 \\times 200) + 400 = 400 + 400 = 800 $$\n样本中等位基因的总数是$2N = 2 \\times 1000 = 2000$。作为检验，$\\text{Count}(A) + \\text{Count}(a) = 1200 + 800 = 2000$，这是正确的。\n\n等位基因$A$的频率$p$是：\n$$ p = \\frac{\\text{Count}(A)}{2N} = \\frac{1200}{2000} = 0.6 $$\n等位基因$a$的频率$q$是：\n$$ q = \\frac{\\text{Count}(a)}{2N} = \\frac{800}{2000} = 0.4 $$\n按要求，等位基因频率之和为$p + q = 0.6 + 0.4 = 1.0$。\n\n**步骤2：计算HWE下的预期基因型计数**\n哈迪-温伯格原理指出，对于一个处于平衡状态的群体，预期的基因型频率由$p^2$（对于$AA$）、$2pq$（对于$Aa$）和$q^2$（对于$aa$）给出。\n预期频率为：\n-   $AA$的预期频率：$f_{exp}(AA) = p^2 = (0.6)^2 = 0.36$\n-   $Aa$的预期频率：$f_{exp}(Aa) = 2pq = 2(0.6)(0.4) = 0.48$\n-   $aa$的预期频率：$f_{exp}(aa) = q^2 = (0.4)^2 = 0.16$\n预期频率之和为$0.36 + 0.48 + 0.16 = 1.0$。\n\n为求得预期计数，我们将这些频率乘以总样本量，$N=1000$：\n-   $AA$的预期计数：$E_{AA} = p^2 N = 0.36 \\times 1000 = 360$\n-   $Aa$的预期计数：$E_{Aa} = 2pq N = 0.48 \\times 1000 = 480$\n-   $aa$的预期计数：$E_{aa} = q^2 N = 0.16 \\times 1000 = 160$\n预期计数之和为$360 + 480 + 160 = 1000$，与样本量相符。\n\n**步骤3：计算皮尔逊卡方统计量**\n$\\chi^2$统计量使用以下公式计算：\n$$ \\chi^2 = \\sum_{i} \\frac{(O_i - E_i)^2}{E_i} $$\n其中$O_i$是观测计数，$E_i$是每个基因型类别$i$的预期计数。\n\n我们有以下观测（$O$）和预期（$E$）计数：\n-   基因型$AA$：$O_{AA} = 400$，$E_{AA} = 360$\n-   基因型$Aa$：$O_{Aa} = 400$，$E_{Aa} = 480$\n-   基因型$aa$：$O_{aa} = 200$，$E_{aa} = 160$\n\n现在，我们计算$\\chi^2$值：\n$$ \\chi^2 = \\frac{(O_{AA} - E_{AA})^2}{E_{AA}} + \\frac{(O_{Aa} - E_{Aa})^2}{E_{Aa}} + \\frac{(O_{aa} - E_{aa})^2}{E_{aa}} $$\n$$ \\chi^2 = \\frac{(400 - 360)^2}{360} + \\frac{(400 - 480)^2}{480} + \\frac{(200 - 160)^2}{160} $$\n$$ \\chi^2 = \\frac{(40)^2}{360} + \\frac{(-80)^2}{480} + \\frac{(40)^2}{160} $$\n$$ \\chi^2 = \\frac{1600}{360} + \\frac{6400}{480} + \\frac{1600}{160} $$\n我们来简化分数：\n$$ \\chi^2 = \\frac{160}{36} + \\frac{640}{48} + 10 $$\n$$ \\chi^2 = \\frac{40}{9} + \\frac{40}{3} + 10 $$\n为了对这些值求和，我们找到一个公分母，即$9$：\n$$ \\chi^2 = \\frac{40}{9} + \\frac{120}{9} + \\frac{90}{9} = \\frac{40 + 120 + 90}{9} = \\frac{250}{9} $$\n将分数转换为小数：\n$$ \\chi^2 = 27.777... $$\n问题要求结果四舍五入至四位有效数字。\n$$ \\chi^2 \\approx 27.78 $$\n该检验的自由度（$df$）由类别数减1，再减去从数据中估计的独立参数个数给出。我们有$3$个基因型类别（$AA$、$Aa$、$aa$）。我们估计了一个参数，即等位基因频率$p$（因为$q=1-p$）。因此，自由度为$df = 3 - 1 - 1 = 1$。计算出的$\\chi^2$值约为$27.78$，自由度为$1$，这表明与哈迪-温伯格平衡存在高度显著的偏离。", "answer": "$$\\boxed{27.78}$$", "id": "5047855"}, {"introduction": "真实世界中的人群通常具有复杂的遗传背景和结构，这可能对基因关联研究等分析造成混淆。主成分分析（Principal Component Analysis, PCA）是一种强大的无监督学习方法，能从高维的基因型数据中提取主要的变异轴，从而可视化人群的遗传祖源差异和识别亚群。本练习将指导你完成执行PCA的关键步骤，从基因型数据的标准化到计算和解释主成分，这是任何处理大规模基因组数据分析的研究者都需掌握的核心计算技能。[@problem_id:5047840]", "problem": "给定一个包含 $N$ 个个体和 $M$ 个双等位基因标记的基因型矩阵，其中每个基因型条目 $X_{i m}$ 是个体 $i$ 在标记 $m$ 处的次要等位基因计数，取值于 $\\{0,1,2\\}$，以及一个对应的每个标记的次要等位基因频率向量 $p_m$。使用二项方差的标准化原理和基于协方差的主成分分析（PCA），构建一个程序，为每个提供的测试用例执行以下操作：\n\n1. 标准化基因型矩阵以生成 $Z \\in \\mathbb{R}^{N \\times M}$，使用以下从基因型二项模型派生的程序：对于每个标记 $m$，设置\n   $$Z_{i m} = \\begin{cases}\n   \\dfrac{X_{i m} - 2 p_m}{\\sqrt{2 p_m (1 - p_m)}}, & \\text{若 } p_m \\in (0,1)， \\\\\n   0, & \\text{若 } p_m \\in \\{0,1\\}，\n   \\end{cases}$$\n   对于所有个体 $i \\in \\{1,\\dots,N\\}$。此标准化利用了这样一个事实：对于一个次要等位基因频率为 $p_m$ 的双等位基因位点，在Hardy-Weinberg平衡假设下，基因型计数 $X_{i m}$ 的期望值为 $2 p_m$，方差为 $2 p_m (1 - p_m)$。\n\n2. 计算个体间的协方差矩阵\n   $$C = \\frac{1}{M} Z Z^\\top \\in \\mathbb{R}^{N \\times N}。$$\n\n3. 如下计算 $C$ 的前两个主成分。设 $C$ 的特征分解为\n   $$C = U \\Lambda U^\\top,$$\n   其中 $U \\in \\mathbb{R}^{N \\times N}$ 具有标准正交列 $u_k$，$\\Lambda = \\mathrm{diag}(\\lambda_1,\\dots,\\lambda_N)$，特征值按降序排列 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_N \\ge 0$。为每个特征向量 $u_k$ 定义一个确定性符号约定：找到第一个索引 $j$ 使得 $|u_{j k}| > 0$，如果 $u_{j k} < 0$，则将 $u_k$ 替换为 $-u_k$；否则保持 $u_k$ 不变。定义个体在成分 $k$ 上的主成分得分为\n   $$s^{(k)} = \\sqrt{\\lambda_k} \\, u_k,$$\n   对于 $k = 1,2$。对于任何 $\\lambda_k = 0$ 的情况，定义 $s^{(k)}$ 为零向量。\n\n4. 对于每个测试用例，输出所有个体的二维主成分得分列表，即列表 $\\big[ [s^{(1)}_1, s^{(2)}_1], \\dots, [s^{(1)}_N, s^{(2)}_N] \\big]$，每个条目四舍五入到 $6$ 位小数。\n\n您的程序必须处理以下参数值的测试套件。在每种情况下，$X$ 以列表的列表形式提供（行是个体），$p$ 以长度为 $M$ 的浮点数列表形式提供：\n- 测试用例 A（具有对称结构的平衡等位基因频率）：\n  - $X = \\begin{bmatrix}\n  0  1  2 \\\\\n  2  1  0 \\\\\n  1  1  1\n  \\end{bmatrix}$，\n  - $p = [0.5, 0.5, 0.5]$。\n- 测试用例 B（包含一个单态标记和相同的个体）：\n  - $X = \\begin{bmatrix}\n  0  0 \\\\\n  0  0\n  \\end{bmatrix}$，\n  - $p = [0.0, 0.3]$。\n- 测试用例 C（四个个体和四个标记，具有不同的等位基因频率，形成两个对立的簇）：\n  - $X = \\begin{bmatrix}\n  0  0  2  2 \\\\\n  0  1  2  1 \\\\\n  2  2  0  0 \\\\\n  2  1  0  1\n  \\end{bmatrix}$，\n  - $p = [0.1, 0.2, 0.8, 0.5]$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是 $N$ 对浮点数的列表，四舍五入到 $6$ 位小数。例如：\n  - \"[$\\text{caseA},\\text{caseB},\\text{caseC}$]\"，其中每个 $\\text{caseX}$ 的格式为 \"[[a,b],[c,d],...]\"。\n- 此处不适用单位。\n- 不使用角度。\n- 所有数值结果必须表示为十进制浮点数。\n\n不应从标准输入读取任何输入，也不应访问任何外部文件。程序必须完全自包含，并仅为上述测试套件生成指定的单行输出。", "solution": "该问题要求对基因型数据实施主成分分析（PCA），这是群体基因组学中一种基础技术，用于推断群体结构和校正遗传关联研究中的混淆因素。该过程涉及标准化基因型矩阵，计算个体间协方差矩阵，然后通过特征分解找到其主成分。\n\n问题陈述的验证过程如下：\n- **步骤 1：提取已知条件**\n    - 基因型矩阵：$X \\in \\mathbb{R}^{N \\times M}$，条目 $X_{i m} \\in \\{0, 1, 2\\}$。\n    - 个体数量：$N$。\n    - 标记数量：$M$。\n    - 等位基因频率向量：$p$，包含每个标记 $m$ 的条目 $p_m$。\n    - 标准化规则：对于 $p_m \\in (0,1)$，$Z_{i m} = \\frac{X_{i m} - 2 p_m}{\\sqrt{2 p_m (1 - p_m)}}$；对于 $p_m \\in \\{0,1\\}$，$Z_{i m} = 0$。\n    - 协方差矩阵：$C = \\frac{1}{M} Z Z^\\top$。\n    - 特征分解：$C = U \\Lambda U^\\top$，其中 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_N \\ge 0$。\n    - 特征向量符号约定：对于每个特征向量 $u_k$，找到第一个索引 $j$ 使得 $u_{j k} \\neq 0$。如果 $u_{j k} < 0$，则将 $u_k$ 替换为 $-u_k$。\n    - 主成分得分计算：$s^{(k)} = \\sqrt{\\lambda_k} u_k$，对于 $k=1,2$。\n    - 测试用例：提供了三个具体的 $(X, p)$ 对。\n    - 输出格式：一个表示结果列表的单行字符串，每个结果是一个包含二维坐标对的列表，四舍五入到 $6$ 位小数。\n\n- **步骤 2：使用提取的已知条件进行验证**\n    - **科学依据**：该方法是群体遗传学中 PCA 的标准且广泛使用的方法。标准化公式在Hardy-Weinberg平衡假设下，通过其期望均值（$2p_m$）和标准差（$\\sqrt{2p_m(1-p_m)}$）正确地归一化了基因型计数。协方差矩阵 $C = \\frac{1}{M}ZZ^\\top$ 是遗传关系矩阵（GRM）的一种形式。其特征向量（主成分）代表了样本中遗传变异的主要轴。该过程在科学上是合理的。\n    - **良态问题**：该问题在数学上是明确定义的。协方差矩阵 $C$ 是对称半正定的，保证了实数、非负的特征值和一套完整的标准正交特征向量。为特征向量提供了确定性的符号约定，确保了唯一的解。\n    - **客观性**：所有指令都是定量的，没有主观或模糊的语言。\n    - 该问题没有其他缺陷；它是完整的、一致的且计算上可行的。存在一个微小的术语不准确之处，即 $p_m$ 被称为“次要等位基因频率”，即使使用了 $0.8$ 这样的值（这使其成为主要等位基因频率），但数学上下文正确且明确地将 $p_m$ 定义为在 $X_{im}$ 中计数的等位基因的频率。这并不使问题无效。\n\n- **步骤 3：结论与行动**\n    - 问题是**有效的**。将构建一个解决方案。\n\n该解决方案通过对每个测试用例遵循规定的步骤来实现。\n\n1.  **基因型矩阵标准化**：对于每个测试用例，给定基因型矩阵 $X$ 和等位基因频率向量 $p$，我们首先构建标准化矩阵 $Z$。对于每个标记 $m$（列），我们检查其对应的等位基因频率 $p_m$ 是否是多态的（$0 < p_m < 1$）。如果是，我们使用提供的公式转换列 $X_{:m}$。如果标记是单态的（$p_m=0$ 或 $p_m=1$），则方差为零，标准化的列 $Z_{:m}$ 被设置为零向量，因为这些标记对群体结构没有贡献信息。\n\n2.  **协方差矩阵计算**：个体间协方差矩阵 $C$ 计算为 $C = \\frac{1}{M} Z Z^\\top$。这个 $N \\times N$ 的矩阵总结了每对个体在所有 $M$ 个标记上的平均遗传相似性。\n\n3.  **特征分解**：主成分由协方差矩阵 $C$ 的特征分解确定。由于 $C$ 是一个实对称矩阵，我们可以使用专门的例程，如 `numpy.linalg.eigh`，它在数值上稳定且高效。该函数返回按升序排列的特征值 $\\lambda_k$ 和一个列为相应标准正交特征向量 $u_k$ 的矩阵 $U$。为了获得顶部的主成分，我们反转特征值及其对应特征向量的顺序。\n\n4.  **符号约定强制执行**：特征向量的方向是任意的（即，如果 $u_k$ 是一个特征向量，那么 $-u_k$ 也是）。为确保确定性的输出，对前两个特征向量 $u_1$ 和 $u_2$ 应用了特定的符号约定。对于每个向量，我们定位其第一个非零元素。如果此元素为负，则通过将其乘以 $-1$ 来翻转整个向量的符号。\n\n5.  **主成分得分计算**：最后，计算每个个体的主成分得分。个体在第 $k$ 个主成分上的得分是第 $k$ 个特征向量乘以相应第 $k$ 个特征值的平方根。我们计算前两个成分的得分，$s^{(1)} = \\sqrt{\\lambda_1} u_1$ 和 $s^{(2)} = \\sqrt{\\lambda_2} u_2$。请注意，如果一个特征值 $\\lambda_k$ 为零或由于数值精度而非常接近零，$\\sqrt{\\lambda_k}$ 也将为零，导致得分向量为零，这是正确的行为。然后将每个个体 $i$ 的得分组合成二维坐标对 $[s^{(1)}_i, s^{(2)}_i]$。\n\n整个过程被封装在一个程序中，该程序处理提供的测试用例，并按规定将输出格式化为单行字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It orchestrates the calculation of principal components for each case\n    and formats the final output string.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            [[0, 1, 2], [2, 1, 0], [1, 1, 1]],\n            [0.5, 0.5, 0.5]\n        ),\n        (\n            [[0, 0], [0, 0]],\n            [0.0, 0.3]\n        ),\n        (\n            [[0, 0, 2, 2], [0, 1, 2, 1], [2, 2, 0, 0], [2, 1, 0, 1]],\n            [0.1, 0.2, 0.8, 0.5]\n        )\n    ]\n\n    all_results = []\n    for x_list, p_list in test_cases:\n        X = np.array(x_list, dtype=float)\n        p = np.array(p_list, dtype=float)\n        \n        # Call the core computation function\n        pc_scores = compute_principal_components(X, p)\n        \n        all_results.append(pc_scores)\n\n    # Format the final output string as specified.\n    case_strings = []\n    for case_result in all_results:\n        # Format each [score1, score2] pair\n        pair_strings = [f\"[{s1:.6f},{s2:.6f}]\" for s1, s2 in case_result]\n        # Join pairs into a case string like \"[[a,b],[c,d]]\"\n        case_str = f\"[{','.join(pair_strings)}]\"\n        case_strings.append(case_str)\n        \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\ndef compute_principal_components(X, p):\n    \"\"\"\n    Calculates the top two principal component scores for a given genotype matrix\n    and allele frequency vector.\n\n    Args:\n        X (np.ndarray): N x M genotype matrix.\n        p (np.ndarray): Vector of M allele frequencies.\n\n    Returns:\n        list: A list of N pairs, where each pair is the [PC1, PC2] score for an individual.\n    \"\"\"\n    N, M = X.shape\n    \n    # 1. Standardize the genotype matrix\n    Z = np.zeros_like(X, dtype=float)\n    for m in range(M):\n        pm = p[m]\n        # The standardization is only defined for polymorphic markers.\n        # For monomorphic markers (p=0 or p=1), variance is 0, so Z remains 0.\n        if 0  pm  1:\n            denominator = np.sqrt(2 * pm * (1 - pm))\n            if denominator > 0:\n                Z[:, m] = (X[:, m] - 2 * pm) / denominator\n\n    # 2. Compute the individual-by-individual covariance matrix C\n    # If M is 0, C should be a zero matrix.\n    if M == 0:\n        C = np.zeros((N, N))\n    else:\n        C = (1 / M) * (Z @ Z.T)\n\n    # 3. Compute the eigendecomposition of C\n    # np.linalg.eigh is used for symmetric matrices and returns eigenvalues\n    # in ascending order.\n    if N > 0:\n        eigenvalues, eigenvectors = np.linalg.eigh(C)\n        \n        # Reverse to get descending order for principal components\n        eigenvalues = eigenvalues[::-1]\n        eigenvectors = eigenvectors[:, ::-1]\n    else: # Handle empty genotype matrix\n        eigenvalues = np.array([])\n        eigenvectors = np.array([[]])\n\n    # Extract top two components, handling cases where N  2\n    lambda_1 = eigenvalues[0] if N > 0 else 0.0\n    lambda_2 = eigenvalues[1] if N > 1 else 0.0\n    \n    u_1 = eigenvectors[:, 0] if N > 0 else np.zeros(N)\n    u_2 = eigenvectors[:, 1] if N > 1 else np.zeros(N)\n\n    # 4. Apply the deterministic sign convention\n    # A small tolerance is used to find the first 'non-zero' element.\n    # The default atol in np.isclose is 1e-08.\n    for u in [u_1, u_2]:\n        if u.size > 0:\n            first_nonzero_idx = -1\n            for i, val in enumerate(u):\n                if not np.isclose(val, 0.0):\n                    first_nonzero_idx = i\n                    break\n            \n            if first_nonzero_idx != -1 and u[first_nonzero_idx]  0:\n                u *= -1\n\n    # 5. Compute the principal component scores\n    # Use max(0, lambda) to prevent sqrt of small negative numbers from FP error\n    s1 = np.sqrt(max(0, lambda_1)) * u_1\n    s2 = np.sqrt(max(0, lambda_2)) * u_2\n    \n    # Combine scores into a list of [PC1, PC2] pairs\n    scores = np.stack((s1, s2), axis=1).tolist()\n    \n    return scores\n\nsolve()\n\n```", "id": "5047840"}, {"introduction": "将基因组学原理应用于公共卫生实践，需要我们能够准确评估筛查项目的有效性。一个诊断测试的性能不仅取决于其固有的技术指标（如灵敏度和特异性），还深刻地受到其应用人群的疾病患病率的影响。这项练习将演示如何运用贝叶斯定理来计算阳性预测值（Positive Predictive Value, PPV），这是一个至关重要的指标，它揭示了当个体收到阳性测试结果时，其确实患病的概率，从而帮助我们评估筛查在现实世界中的临床效用。[@problem_id:5047891]", "problem": "一个转化医学领域的国家精准公共卫生项目正在考虑实施一项针对由致病性变异所定义的罕见单基因疾病的人群基因组筛查。该检测的灵敏度为 $0.95$，特异度为 $0.99$。该疾病在人群中的患病率（先验概率）为 $K = 0.001$。假设该检测的性能在不同亚组间保持稳定，并且每个被筛查个体的结果都是独立的。\n\n从灵敏度和特异度的定义以及条件概率的贝叶斯定理出发，推导该筛查在此人群中的阳性预测值 (PPV; positive predictive value) $P(\\text{Disease} \\mid +)$。然后，利用独立伯努利试验的概率和期望的基本原理，推导在 $100{,}000$ 名被筛查者中预期的真阳性人数。\n\n将阳性预测值以小数形式表示（而非百分比），并四舍五入至四位有效数字，同时将预期的真阳性人数以每 $100{,}000$ 名筛查者中的精确整数给出。按顺序以两个值的形式报告你的最终答案：PPV，预期的真阳性人数。", "solution": "该问题要求推导一项全人群基因筛查的阳性预测值 (PPV) 和预期真阳性人数。问题提法明确且有科学依据，为获得完整解提供了所有必要参数。\n\n设 $D$ 为个体患有该单基因疾病的事件，设 $D^c$ 为个体不患有该疾病的事件。\n设 $+$ 为检测结果为阳性的事件，设 $-$ 为检测结果为阴性的事件。\n\n题目给出的已知条件可转化为概率术语：\n1.  该疾病的人群患病率 $K$ 是患病的先验概率：$P(D) = K = 0.001$。\n2.  该检测的灵敏度是指在个体患病的情况下，检测结果为阳性的概率：$P(+ \\mid D) = 0.95$。\n3.  该检测的特异度是指在个体不患病的情况下，检测结果为阴性的概率：$P(- \\mid D^c) = 0.99$。\n4.  被筛查的总人数为 $N = 100000$。\n\n首先，我们推导阳性预测值 (PPV)，其定义为在检测结果为阳性的条件下患有该疾病的条件概率 $P(D \\mid +)$。\n根据贝叶斯定理：\n$$P(D \\mid +) = \\frac{P(+ \\mid D) P(D)}{P(+)}$$\n为了使用这个公式，我们必须首先使用全概率公式计算检测结果为阳性的总概率 $P(+)$。检测结果为阳性的事件可以分解为两个互斥事件：真阳性（检测为阳性且患有疾病）和假阳性（检测为阳性但不患有疾病）。\n$$P(+) = P(+ \\cap D) + P(+ \\cap D^c)$$\n根据条件概率的定义 $P(A \\cap B) = P(A \\mid B)P(B)$，上式可展开为：\n$$P(+) = P(+ \\mid D) P(D) + P(+ \\mid D^c) P(D^c)$$\n我们已知 $P(+ \\mid D)$ 和 $P(D)$。我们需要确定 $P(D^c)$ 和 $P(+ \\mid D^c)$。\n不患病的概率 $P(D^c)$ 是患病率的补集：\n$$P(D^c) = 1 - P(D) = 1 - 0.001 = 0.999$$\n在未患病个体中检测结果为阳性的概率 $P(+ \\mid D^c)$ 是特异度 $P(- \\mid D^c)$ 的补集。这是因为对于未患病的个体，检测结果只能是阳性或阴性。\n$$P(+ \\mid D^c) = 1 - P(- \\mid D^c) = 1 - 0.99 = 0.01$$\n这个量 $P(+ \\mid D^c)$ 也称为假阳性率。\n\n现在我们可以计算检测结果为阳性的总概率 $P(+)$：\n$$P(+) = (0.95)(0.001) + (0.01)(0.999) = 0.00095 + 0.00999 = 0.01094$$\n计算出 $P(+)$ 后，我们就可以确定 PPV：\n$$P(D \\mid +) = \\frac{P(+ \\mid D) P(D)}{P(+)} = \\frac{(0.95)(0.001)}{0.01094} = \\frac{0.00095}{0.01094}$$\n$$P(D \\mid +) \\approx 0.086837294332724...$$\n题目要求将此值四舍五入到四位有效数字。\n$$PPV = P(D \\mid +) \\approx 0.08684$$\n\n接下来，我们推导在 $N=100000$ 名被筛查者中预期的真阳性人数。\n真阳性 (TP) 是指一个个体既患有疾病 ($D$) 又检测结果为阳性 ($+$) 的事件。随机选择一个个体为真阳性的概率是 $P(TP) = P(D \\cap +)$。\n根据条件概率的定义：\n$$P(TP) = P(D \\cap +) = P(+ \\mid D) P(D)$$\n代入已知值：\n$$P(TP) = (0.95)(0.001) = 0.00095$$\n对 $N$ 个个体中每一个的筛查都是一次独立的伯努利试验，其中“成功”定义为该个体是真阳性。设 $X$ 为 $N$ 个个体样本中真阳性总数的随机变量。$X$ 服从二项分布，$X \\sim B(N, p)$，其中试验次数 $N=100000$，每次试验的成功概率 $p = P(TP) = 0.00095$。\n\n服从二项分布的随机变量的期望值（或均值）由公式 $E[X] = Np$ 给出。\n因此，预期的真阳性人数 $E[X]$ 为：\n$$E[X] = N \\times p = 100000 \\times 0.00095$$\n$$E[X] = 95$$\n这是一个精确的整数值，符合要求。\n\n最终答案按顺序包含两个值：四舍五入到四位有效数字的 PPV 和预期的真阳性人数的精确整数值。", "answer": "$$\\boxed{\\begin{pmatrix} 0.08684  95 \\end{pmatrix}}$$", "id": "5047891"}]}