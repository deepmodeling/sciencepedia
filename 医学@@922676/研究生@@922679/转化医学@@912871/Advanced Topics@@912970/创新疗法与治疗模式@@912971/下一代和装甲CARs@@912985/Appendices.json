{"hands_on_practices": [{"introduction": "CAR-T细胞工程的一个核心目标是确保即使在面对低抗原表达的肿瘤细胞时也能实现有效激活。此练习将让您深入探究这种相互作用的生物物理学第一性原理，推导触发CAR-T细胞反应所需的最小抗原密度[@problem_id:5035133]。掌握这一基本关系对于理解结合亲和力（$K_D$）和信号转导阈值（$\\theta$）等参数如何决定抗肿瘤效力至关重要，而这些参数正是下一代CAR设计中可以进行优化的关键点。", "problem": "一种靶向实体瘤抗原的嵌合抗原受体 (CAR) T细胞被设计为具有新一代特性，包括一种“装甲”设计，该设计可调节下游信号以抵抗抑制性细胞因子。在免疫突触处，受体结合遵循质量作用结合平衡，产生标准受体占据率关系 $r(n) = \\frac{n}{n + K_D}$，其中 $n$ 是突触处的抗原密度（单位为每个细胞的分子数或等效的表面密度单位），$K_D$ 是有效平衡解离常数，其单位与 $n$ 相同。假设CAR信号传导的有效激活要求占据率超过一个由下游网络决定的阈值，因此对于某个 $0  \\theta  1$ 有 $r(n) \\ge \\theta$。\n\n从质量作用结合原理和平衡解离常数的定义出发，除了上述占据率定义 $r(n)$ 外不使用任何捷径，推导激活所需的最小抗原密度 $n_{\\min}$ 作为 $K_D$ 和 $\\theta$ 函数的闭式解析表达式。然后，解释这种依赖关系如何针对典型的实体瘤抗原密度对CAR设计构成约束，使用许多实体瘤的实际参考范围 $n \\in [10^{4}, 10^{6}]$ 分子/细胞，并认识到“装甲”CAR可以通过增强共刺激或使信号传导免受抑制性信号的影响来有效降低 $\\theta$。你的推导过程应明确说明所用的任何假设，并根据所述基本原理解释代数步骤的合理性。\n\n只提供 $n_{\\min}$ 的最终表达式。最终表达式中不包含任何单位。最终答案中不需要进行数值评估；任何定性解释都应包含在你的推理过程中，但不要包含在最终表达式中。", "solution": "首先对问题进行验证。\n\n### 第1步：提取已知条件\n-   受体占据率关系：$r(n) = \\frac{n}{n + K_D}$\n-   $n$：突触处的抗原密度。\n-   $K_D$：有效平衡解离常数。\n-   有效激活的条件：$r(n) \\ge \\theta$。\n-   $\\theta$：激活阈值，其中 $0  \\theta  1$。\n-   目标：推导最小抗原密度 $n_{\\min}$ 的闭式解析表达式。\n-   背景信息：对于许多实体瘤，$n$ 的一个实际参考范围是 $[10^{4}, 10^{6}]$ 分子/细胞。“装甲”CAR可以有效降低 $\\theta$。\n\n### 第2步：使用提取的已知条件进行验证\n根据所提供的标准评估问题的有效性。\n\n-   **科学依据**：该问题利用了标准的质量作用结合模型（通常用Hill-Langmuir方程表示），这是生物化学和药理学中描述受体-配体相互作用的基础。信号阈值（$\\theta$）的概念是细胞生物学的基石。将其应用于嵌合抗原受体 (CAR) T细胞、抗原密度以及“装甲”效应，是现代、现实且与转化医学领域高度相关的。该问题在科学上是合理的。\n-   **适定性**：该问题要求找出满足给定不等式的最小抗原密度 $n_{\\min}$。对于 $n \\ge 0$，$r(n)$ 是 $n$ 的单调递增函数。因此，解不等式 $r(n) \\ge \\theta$ 会得到一个关于 $n$ 的下界，并且存在一个唯一的最小值 $n_{\\min}$。该问题是适定的。\n-   **客观性**：该问题使用精确、标准的科学术语（$K_D$、受体占据率、抗原密度）进行陈述。它不含主观或模棱两可的语言。\n\n### 第3步：结论与行动\n问题被判定为**有效**。它具有科学依据，是适定的，并且是客观的。将推导解答。\n\n### 推导过程\n问题要求推导激活CAR T细胞所需的最小抗原密度 $n_{\\min}$。激活条件以受体占据率 $r(n)$ 的阈值形式给出。\n\n激活条件是：\n$$r(n) \\ge \\theta$$\n\n受体占据率 $r(n)$ 由质量作用结合平衡定义：\n$$r(n) = \\frac{n}{n + K_D}$$\n其中 $n$ 是抗原密度，$K_D$ 是平衡解离常数。\n\n将 $r(n)$ 的定义代入激活条件，得到不等式：\n$$\\frac{n}{n + K_D} \\ge \\theta$$\n\n目标是解这个关于 $n$ 的不等式。我们寻找满足此条件的 $n$ 的最小值，记为 $n_{\\min}$。这个最小值将出现在不等式的边界上，即等式成立的地方。但是，我们首先会普适地解这个不等式，以证明最小值的解释是正确的。\n\n我们可以用分母 $(n + K_D)$ 乘以不等式两边。一个必要的物理假设是抗原密度 $n$ 和解离常数 $K_D$ 都是非负量。具体来说，$n \\ge 0$ 且 $K_D > 0$。因此，它们的和 $(n + K_D)$ 在任何相关的生物学情景中 ($n > 0$) 都是严格为正的。乘以一个正数不会改变不等号的方向：\n$$n \\ge \\theta (n + K_D)$$\n\n将右侧的 $\\theta$ 分配进去，得到：\n$$n \\ge \\theta n + \\theta K_D$$\n\n为了解出 $n$，我们将所有含 $n$ 的项移到不等式的一边：\n$$n - \\theta n \\ge \\theta K_D$$\n\n在左侧提取因子 $n$：\n$$n(1 - \\theta) \\ge \\theta K_D$$\n\n最后一步是通过除以 $(1 - \\theta)$ 来分离出 $n$。问题陈述中说明阈值 $\\theta$ 的约束条件是 $0  \\theta  1$。这意味着 $(1 - \\theta)$ 这一项是严格为正的。因此，除以 $(1 - \\theta)$ 不会改变不等号的方向：\n$$n \\ge \\frac{\\theta K_D}{1 - \\theta}$$\n\n这个不等式指明，要发生激活，抗原密度 $n$ 必须大于或等于右侧的表达式。因此，最小抗原密度 $n_{\\min}$ 正是这个范围下界的值：\n$$n_{\\min} = \\frac{\\theta K_D}{1 - \\theta}$$\n\n这就得到了所需最小抗原密度作为解离常数 $K_D$ 和激活阈值 $\\theta$ 函数的闭式解析表达式。\n\n### 解释\n推导出的表达式 $n_{\\min} = \\frac{\\theta K_D}{1 - \\theta}$ 揭示了CAR设计参数和靶细胞特征如何决定激活敏感性。\n1.  **对 $K_D$ 的依赖性**：$n_{\\min}$ 与 $K_D$ 成正比。较高的 $K_D$ 对应较低的结合亲和力，意味着CAR更容易从抗原上解离。为了补偿较弱的结合，需要更高的抗原密度才能达到激活所需的受体占据率。\n2.  **对 $\\theta$ 的依赖性**：与 $\\theta$ 的关系是非线性的。当 $\\theta \\to 0$ 时，$n_{\\min} \\to 0$，意味着一个非常低的激活阈值只需要非常少的抗原。相反，当 $\\theta \\to 1$ 时，分母 $(1 - \\theta) \\to 0$，导致 $n_{\\min} \\to \\infty$。这表明一个极高的激活阈值（需要接近完全的受体饱和）在实践中是不可能实现的。\n3.  **对“装甲”CAR的启示**：问题中指出“装甲”CAR可以有效降低 $\\theta$。我们的推导表明，降低 $\\theta$ 会直接降低 $n_{\\min}$。这就是“装甲”CAR在对抗低抗原表达肿瘤时功效提高的数学基础。如果一个肿瘤细胞上的抗原密度 $n$ 满足 $n_{\\min, \\text{conventional}} > n$ 但 $n_{\\min, \\text{armored}} \\le n$（由于 $\\theta_{\\text{armored}}  \\theta_{\\text{conventional}}$），那么“装甲”CAR会激活而常规CAR则不会。为了有效对抗抗原密度可能在 $n \\in [10^{4}, 10^{6}]$ 范围内的实体瘤，CAR的设计必须具有足够高的亲和力（低 $K_D$）和/或“装甲”策略（低 $\\theta$），以确保 $n_{\\min}$ 低于靶细胞上可用的抗原密度。", "answer": "$$\\boxed{\\frac{\\theta K_D}{1 - \\theta}}$$", "id": "5035133"}, {"introduction": "尽管CAR-T细胞疗法功能强大，但也伴随着风险，其中之一便是“手足相残”（fratricide）——当CAR-T细胞靶向自身表面也存在的抗原时发生的自我毁灭。这项动手实践将挑战您通过整合受体结合动力学与随机细胞相遇过程，来构建一个手足相残风险的定量模型[@problem_id:5035076]。通过这个练习，您将学会如何从数学上评估基因编辑和抑制性受体等先进工程策略在提高CAR-T细胞产品的安全性和持久性方面的效果。", "problem": "一个转化医学团队正在开发一种新一代的多特异性嵌合抗原受体 (CAR) T 细胞疗法。该 CAR 包含两个单链可变片段 (scFv) 结合域：一个识别肿瘤限制性抗原 ($A_{\\mathrm{tumor}}$；例如 CD19)，另一个识别 T 细胞抗原 ($A_{\\mathrm{T}}$；例如 CD7)。虽然靶向肿瘤的臂介导了所需的细胞毒性，但靶向 $A_{\\mathrm{T}}$ 的臂存在自相残杀（CAR T 细胞间的自我杀伤）的风险。您将对自相残杀风险进行建模，并引入工程策略来降低该风险。\n\n使用以下基本原理：\n- 基于质量作用结合的受体-配体占有率：CAR 结合位点的占有分数遵循 $\\theta = \\frac{L}{L + K_D}$，其中 $L$ 是有效配体水平，$K_D$ 是解离常数。\n- 细胞间的接触在一个时间窗口内可以很好地用泊松过程建模，因此当平均致死事件数为 $\\lambda$ 时，零次致死事件的概率等于 $\\exp(-\\lambda)$。\n\n假设如下：\n1. 工程改造前，CAR T 细胞上 $A_{\\mathrm{T}}$ 的有效抗原密度为 $D_7 = 1.0 \\times 10^{5}$ 个分子/细胞。CAR 的抗 $A_{\\mathrm{T}}$ 臂的有效解离常数为 $K_D' = 7.5 \\times 10^{4}$ 个分子/细胞。\n2. 每个细胞由 $A_{\\mathrm{T}}$ 识别驱动的 T 细胞-T 细胞接触率为 $\\lambda_{\\mathrm{TT}} = 0.50$ 次接触/小时。考虑输注后 $\\tau = 48$ 小时的时间窗口。\n3. 对于由 $A_{\\mathrm{T}}$ 臂介导的完全占用的突触，每次接触的基线细胞毒性事件概率为 $p_0 = 0.40$。\n4. 在由 $A_{\\mathrm{T}}$ 介导的两个 CAR T 细胞之间的对称接触中，指标 CAR T 细胞在该次接触中死亡的概率是每次接触细胞毒性事件概率的一半（即对称因子为 $1/2$）。\n5. 部署了两种工程策略：\n   - 使用 CRISPR (成簇规律间隔短回文重复序列) 技术敲除 CAR T 细胞上的 $A_{\\mathrm{T}}$，效率为 $q = 0.90$，因此 CAR T 细胞上的残余抗原密度为 $(1 - q) D_7$。\n   - 使用一种针对自我标记物的抑制性嵌合抗原受体 (iCAR)，它将由 $A_{\\mathrm{T}}$ 介导的有效每次接触细胞毒性事件概率降低了 $\\eta = 0.80$ 的比例（也就是说，作用于 $p_0$ 的乘法因子为 $\\gamma = 1 - \\eta$）。\n\n仅使用上述经过充分检验的公式和科学上合理的假设，从第一性原理推导在实施两种工程策略后，一个指标 CAR T 细胞在 $\\tau$ 小时窗口内的自相残杀风险 $R$。明确定义工程改造后与自相残杀相关的受体占有率，将其与修正后的每次接触细胞毒性概率和对称因子结合成平均致死事件率，并使用泊松模型计算 $R$。\n\n将最终数值答案四舍五入至四位有效数字。以无单位的小数概率形式表示您的答案。", "solution": "该问题已经过验证，被认为是科学上合理、定义明确、客观且自洽的。提供了一个唯一解所需的所有必要参数和模型，其背景与转化医学和免疫疗法相关。该问题是有效的。\n\n目标是计算一个指标 CAR T 细胞在指定时间窗口内的自相残杀风险 $R$。风险 $R$ 定义为至少发生一次致死事件的概率。它与零次致死事件的概率互补。\n$$R = 1 - P(\\text{零次致死事件})$$\n问题陈述，导致致死事件的细胞间接触可以用泊松过程建模。在给定时间间隔内观察到零次事件的概率由 $P(\\text{零事件}) = \\exp(-\\Lambda_{fatal})$ 给出，其中 $\\Lambda_{fatal}$ 是该间隔内指标细胞预期的平均致死事件数。\n$$R = 1 - \\exp(-\\Lambda_{fatal})$$\n平均致死事件数 $\\Lambda_{fatal}$ 是相关接触总数与每次接触发生致死事件的概率的乘积。\n$$\\Lambda_{fatal} = (\\text{总接触次数}) \\times (\\text{每次接触的致死事件概率})$$\n一个指标细胞在时间窗口 $\\tau$ 内的 T 细胞-T 细胞接触总数是接触率 $\\lambda_{\\mathrm{TT}}$ 与持续时间 $\\tau$ 的乘积。\n$$\\text{总接触次数} = \\lambda_{\\mathrm{TT}} \\tau$$\n每次接触中指标细胞发生致死事件的概率，记为 $P_{fatal\\_per\\_contact}$，由几个受工程策略修正的因素决定。\n\n首先，我们确定介导自相残杀的有效抗原密度。$A_{\\mathrm{T}}$ 的初始抗原密度是 $D_7$。CRISPR 基因敲除以效率 $q$ 降低了该密度。残余抗原密度现在作为有效配体水平 $L'$，为：\n$$L' = (1 - q) D_7$$\n其次，我们计算一个进行接触的 CAR T 细胞上抗 $A_{\\mathrm{T}}$ 结合域的受体占有率 $\\theta'$。根据提供的质量作用结合公式，该占有率取决于有效配体水平 $L'$ 和解离常数 $K_D'$：\n$$\\theta' = \\frac{L'}{L' + K_D'} = \\frac{(1 - q) D_7}{(1 - q) D_7 + K_D'}$$\n第三，我们确定工程改造后每次接触的细胞毒性事件概率。对于完全占用的突触，基线概率是 $p_0$。我们假设实际概率与受体占有率呈线性关系，得到 $p_0 \\theta'$。iCAR 进一步降低了此概率，引入了乘法因子 $\\gamma = (1 - \\eta)$。因此，单次 T-T 接触中发生细胞毒性事件的概率为：\n$$P_{cytotoxic\\_event} = p_0 \\theta' \\gamma = p_0 \\theta' (1 - \\eta)$$\n第四，问题指明在对称接触中，指标细胞死亡的概率是总的每次接触细胞毒性事件概率的一半。\n$$P_{fatal\\_per\\_contact} = \\frac{1}{2} P_{cytotoxic\\_event} = \\frac{1}{2} p_0 \\theta' (1 - \\eta)$$\n现在，我们可以组装出 $\\Lambda_{fatal}$ 的完整表达式：\n$$\\Lambda_{fatal} = (\\lambda_{\\mathrm{TT}} \\tau) \\times P_{fatal\\_per\\_contact} = \\lambda_{\\mathrm{TT}} \\tau \\left[ \\frac{1}{2} p_0 (1 - \\eta) \\theta' \\right]$$\n代入 $\\theta'$ 的表达式：\n$$\\Lambda_{fatal} = \\frac{1}{2} \\lambda_{\\mathrm{TT}} \\tau p_0 (1 - \\eta) \\left( \\frac{(1 - q) D_7}{(1 - q) D_7 + K_D'} \\right)$$\n我们已知以下数值：\n$D_7 = 1.0 \\times 10^{5}$ 分子/细胞\n$K_D' = 7.5 \\times 10^{4}$ 分子/细胞\n$\\lambda_{\\mathrm{TT}} = 0.50 \\, \\mathrm{h}^{-1}$\n$\\tau = 48 \\, \\mathrm{h}$\n$p_0 = 0.40$\n$q = 0.90$\n$\\eta = 0.80$\n\n首先，我们计算工程改造后的配体密度 $L'$：\n$$L' = (1 - 0.90) \\times (1.0 \\times 10^{5}) = 0.10 \\times 1.0 \\times 10^{5} = 1.0 \\times 10^{4} \\, \\text{分子/细胞}$$\n接下来，我们计算受体占有率 $\\theta'$：\n$$\\theta' = \\frac{1.0 \\times 10^{4}}{1.0 \\times 10^{4} + 7.5 \\times 10^{4}} = \\frac{1.0 \\times 10^{4}}{8.5 \\times 10^{4}} = \\frac{1}{8.5}$$\n现在，我们计算平均致死事件数 $\\Lambda_{fatal}$：\n$$\\Lambda_{fatal} = \\frac{1}{2} \\times (0.50 \\times 48) \\times 0.40 \\times (1 - 0.80) \\times \\left( \\frac{1}{8.5} \\right)$$\n$$\\Lambda_{fatal} = \\frac{1}{2} \\times 24 \\times 0.40 \\times 0.20 \\times \\frac{1}{8.5}$$\n$$\\Lambda_{fatal} = 12 \\times 0.08 \\times \\frac{1}{8.5} = \\frac{0.96}{8.5} \\approx 0.112941176$$\n最后，我们计算自相残杀风险 $R$：\n$$R = 1 - \\exp(-\\Lambda_{fatal}) = 1 - \\exp(-0.112941176)$$\n$$R \\approx 1 - 0.89321455 \\approx 0.10678545$$\n将最终答案四舍五入至四位有效数字，我们得到：\n$$R \\approx 0.1068$$\n这表示在一个工程改造的 CAR T 细胞在最初的 $48$ 小时内因自相残杀而被清除的概率为 $10.68\\%$。", "answer": "$$\\boxed{0.1068}$$", "id": "5035076"}, {"introduction": "抗原密度与CAR-T细胞反应之间的关系很少是线性的；它通常表现出一种被称为“协同性”（cooperativity）的“开关式”特征，这是复杂生物系统的标志。这项计算练习让您扮演数据分析师的角色，将一个标准的生物物理模型——希尔方程（Hill equation）——拟合到剂量反应数据上，以量化这种协同性[@problem_id:5035086]。这项实践对于表征新型CAR（特别是为实现超敏激活而设计的“装甲型”CAR）的效价和敏感性至关重要。", "problem": "一个转化医学场景考虑了嵌合抗原受体 (CAR) T细胞的剂量反应行为，包括为增强效应器功能而设计的下一代“武装”CAR T细胞（例如，通过分泌白细胞介素-12 (IL-12)）。CAR T细胞的反应，例如与靶标的结合或细胞毒性杀伤，作为靶抗原密度的函数，表现出由受体-配体相互作用和细胞内信号传导中的协同机制所支配的超敏性。该分析基于第一性原理，使用质量作用定律、受体占据率以及多价结合和信号放大的概念构建。\n\n从以下基本基础出发：\n- 质量作用定律关联了平衡状态下的游离和结合物种，由于可逆结合，部分受体占据率随抗原密度增加而增加。\n- 多价结合和协同信号传导非线性地放大了反应。\n- 有效反应被假定为抗原密度（单位：分子/细胞）的一个单调递增、可饱和的函数，该函数趋近于一个最大反应，并由一个编码协同性的陡度参数来表征。\n\n任务是通过将一个与这些原理一致的协同性剂量反应函数拟合到测量数据，来推断CAR T细胞结合和细胞毒性中的协同性。假设一个饱和反应函数由三个量参数化：最大可及反应 $E_{\\max}$（介于 $0$ 和 $1$ 之间的无量纲分数），一个特征抗原密度 $K$（半数最大效应时的密度，单位：分子/细胞），以及一个陡度参数 $n$（希尔系数，无单位）。利用这些假设，通过最小二乘法拟合从数据中估计 $n$、$K$ 和 $E_{\\max}$。然后对协同性进行分类：如果 $n$ 超过 $1$ 一个实际容差，则返回 $c=1$ 表示正协同性；如果 $n$ 实际上等于 $1$，则返回 $c=0$ 表示无协同性；如果 $n$ 低于 $1$ 一个实际容差，则返回 $c=-1$ 表示负协同性。\n\n您的程序必须实现非线性最小二乘法拟合来推断每个数据集的参数，从数据中选择合理的初始猜测值，并将参数约束在物理上有意义的范围内（例如，$E_{\\max}\\in[0,1.2]$, $K0$, $n0$）。此问题不涉及角度。物理单位：以分子/细胞为单位报告 $K$。量 $n$ 和 $E_{\\max}$ 是无量纲小数。反应是无量纲小数。抗原密度单位是分子/细胞。对于协同性分类，使用 $1$ 周围 $\\pm 0.1$ 的容差。\n\n下面提供了测试套件数据集。每个数据集是一对抗原密度和测量的反应。第一个和第三个数据集反映了结合反应，而第二个数据集反映了武装CAR的细胞毒性。数组如下：\n\n- 数据集A（结合，常规CAR）：\n    - 抗原密度 $x$: $[0,10000,20000,50000,100000,200000,500000,1000000]$ (分子/细胞)\n    - 测量反应 $y$: $[0.000,0.160,0.270,0.478,0.655,0.802,0.892,0.927]$ (分数)\n\n- 数据集B（细胞毒性，武装CAR）：\n    - 抗原密度 $x$: $[0,20000,50000,80000,150000,300000,600000,1000000]$ (分子/细胞)\n    - 测量反应 $y$: $[0.000,0.030,0.238,0.500,0.830,0.965,0.993,0.998]$ (分数)\n\n- 数据集C（结合，负协同性边缘案例）：\n    - 抗原密度 $x$: $[0,10000,25000,50000,100000,200000,500000,1000000]$ (分子/细胞)\n    - 测量反应 $y$: $[0.000,0.150,0.250,0.345,0.450,0.555,0.678,0.750]$ (分数)\n\n您的程序应该将协同反应函数拟合到每个数据集，并为每个数据集返回一个包含四个值的列表：估计的希尔系数 $n$，估计的特征抗原密度 $K$（单位：分子/细胞），估计的最大反应 $E_{\\max}$，以及如上定义的协同性分类整数 $c$。使用如下舍入规则：输出的 $n$ 和 $E_{\\max}$ 四舍五入到 $6$ 位小数，输出的 $K$ 四舍五入到最近的整数。最终输出必须是单行，包含一个逗号分隔的三个数据集结果列表，每个结果本身都是一个方括号括起来的逗号分隔列表，顺序为 $[n,K,E_{\\max},c]$。\n\n例如，最终输出应如下所示：$[[n_A,K_A,E_{\\max,A},c_A],[n_B,K_B,E_{\\max,B},c_B],[n_C,K_C,E_{\\max,C},c_C]]$，所有数值均按指定格式设置。\n\n覆盖性设计：\n- 数据集A是一个在结合中具有轻度正协同性的一般情况。\n- 数据集B测试了反映武装CAR介导的放大的陡峭正协同性。\n- 数据集C测试了一个具有负协同性（亚线性增加）的边缘案例。\n\n您的程序应生成一行输出，其中包含如上所述的、以方括号括起来的逗号分隔列表形式的结果。", "solution": "该问题要求估计一个协同性剂量反应模型的参数，该模型描述了CAR T细胞活性作为靶抗原密度的函数。这是一个经典的生物物理建模问题，可以使用非线性回归来解决。\n\n逻辑步骤如下：\n首先，我们形式化剂量反应关系。问题描述了一个可饱和的协同过程，这通常由希尔-朗缪尔方程（Hill-Langmuir equation）来建模。该方程将反应 $E$ 与配体浓度（在本例中为靶细胞上的抗原密度 $x$）关联起来。该函数由三个参数定义：最大反应 $E_{\\max}$，产生半数最大反应的抗原密度 $K$（也称为 $EC_{50}$），以及量化协同程度的希尔系数 $n$。\n\n希尔方程由下式给出：\n$$\nE(x) = E_{\\max} \\frac{x^n}{K^n + x^n}\n$$\n其中：\n- $E(x)$ 是在抗原密度为 $x$ 时的预测反应。\n- $x$ 是抗原密度，单位为分子/细胞。\n- $E_{\\max}$ 是无量纲的最大可及反应，一个通常介于 $0$ 和 $1$ 之间的分数。\n- $K$ 是半数最大效应浓度（或密度），与 $x$ 的单位相同。它代表反应达到 $E_{\\max}$ 的 $50\\%$ 时的抗原密度。\n- $n$ 是无量纲的希尔系数。如果 $n > 1$，系统表现出正协同性，意味着初始结合事件增加了后续结合事件的亲和力，导致陡峭的、开关样的反应。如果 $n = 1$，系统遵循米氏动力学（Michaelis-Menten kinetics），无协同性。如果 $n  1$，系统显示出负协同性，即初始结合事件降低了后续结合的亲和力，导致反应上升比无协同性情况更慢。\n\n为了为所提供的三个数据集中的每一个求解参数 $n$、$K$ 和 $E_{\\max}$，我们采用非线性最小二乘法。这个迭代优化过程找到使观测反应 ($y_i$) 与模型预测反应 ($E(x_i)$) 之间平方差之和最小化的参数值。我们将使用 `scipy.optimize` 库中的 `curve_fit` 函数，该函数实现了Levenberg-Marquardt算法。\n\n为了数值稳定性，尤其是在处理大的 $x$ 值和可能大的指数 $n$ 时，重写希尔方程是有利的。将分子和分母同除以 $x^n$ 会得到一个等价形式，该形式对于大的 $x$ 值更能抵抗浮点溢出：\n$$\nE(x) = \\frac{E_{\\max}}{1 + (K/x)^n}\n$$\n当 $x \\to \\infty$ 时，此形式正确地评估为 $E_{\\max}$。它需要对 $x=0$ 的数据点进行特殊处理，因为此时它未定义。然而，对于 $n0$，当 $x \\to 0^+$ 时的极限是 $0$。因此，我们可以将函数在 $x=0$ 处定义为 $0$。为了拟合的目的，数据点 $(0,0)$ 通常被排除，因为它不为约束 $n$ 和 $K$ 提供信息，并且可能产生奇异雅可比矩阵，从而干扰优化算法。\n\n拟合过程需要参数的初始猜测值。按照指示，这些值从数据中导出：\n- $E_{\\max}$ 的初始猜测值取为数据集中观测到的最大反应值。\n- $K$ 的初始猜测值是对应于最接近初始 $E_{\\max}$ 猜测值 $50\\%$ 的观测反应的抗原密度 $x$。\n- $n$ 的初始猜测值设为 $1.0$，代表无协同性的基线情况。\n\n在优化过程中应用物理约束作为边界：$n > 0$, $K > 0$ 和 $0 \\le E_{\\max} \\le 1.2$。为 $E_{\\max}$ 设置一个宽松的上限，允许拟合考虑到潜在的实验噪声，这些噪声可能将拟合的最大值推至略高于理论极限 $1.0$。\n\n在为给定数据集找到最优参数 ($n_{opt}, K_{opt}, E_{max, opt}$) 后，根据 $n_{opt}$ 的值并使用指定的 $\\pm 0.1$ 容差对协同性进行分类：\n- 正协同性 ($c=1$)：如果 $n_{opt} > 1.1$。\n- 负协同性 ($c=-1$)：如果 $n_{opt}  0.9$。\n- 无协同性 ($c=0$)：如果 $0.9 \\le n_{opt} \\le 1.1$。\n\n最后，根据指定的舍入规则格式化每个数据集的结果：$n$ 和 $E_{\\max}$ 四舍五入到 $6$ 位小数，$K$ 四舍五入到最近的整数。然后将这些结构化的结果编译成最终的输出格式。这个系统化的过程确保了对所提供的剂量反应数据进行严格、可复现且有科学依据的分析。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Fits a cooperative dose-response (Hill) model to CAR T cell data,\n    estimates parameters, and classifies cooperativity.\n    \"\"\"\n\n    # Define the cooperative dose-response function (Hill equation).\n    # This version is numerically stable for a wide range of x and parameter values.\n    def hill_function(x_data, n, K, E_max):\n        \"\"\"\n        Calculates response based on the Hill equation.\n        E = E_max / (1 + (K/x)^n)\n        \"\"\"\n        x = np.asarray(x_data, dtype=float)\n        response = np.zeros_like(x)\n        \n        # The response is 0 at x=0. For x0, we calculate the response.\n        # This prevents division by zero.\n        positive_x_mask = x  0\n        if np.any(positive_x_mask):\n            x_pos = x[positive_x_mask]\n            \n            # The term (K/x)^n is calculated.\n            # Bounds n0, K0, and x0 prevent math domain errors.\n            k_over_x = K / x_pos\n            response[positive_x_mask] = E_max / (1.0 + k_over_x**n)\n\n        return response\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"x\": np.array([0, 10000, 20000, 50000, 100000, 200000, 500000, 1000000], dtype=float),\n            \"y\": np.array([0.000, 0.160, 0.270, 0.478, 0.655, 0.802, 0.892, 0.927], dtype=float)\n        },\n        {\n            \"x\": np.array([0, 20000, 50000, 80000, 150000, 300000, 600000, 1000000], dtype=float),\n            \"y\": np.array([0.000, 0.030, 0.238, 0.500, 0.830, 0.965, 0.993, 0.998], dtype=float)\n        },\n        {\n            \"x\": np.array([0, 10000, 25000, 50000, 100000, 200000, 500000, 1000000], dtype=float),\n            \"y\": np.array([0.000, 0.150, 0.250, 0.345, 0.450, 0.555, 0.678, 0.750], dtype=float)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        x_data = case[\"x\"]\n        y_data = case[\"y\"]\n\n        # For fitting, exclude the (0,0) point, as it provides no information\n        # for n and K and can cause singularity issues in the optimizer.\n        x_fit = x_data[1:]\n        y_fit = y_data[1:]\n\n        # Generate reasonable initial guesses from the data.\n        # E_max guess: maximum observed response.\n        E_max_guess = np.max(y_fit) if np.max(y_fit)  0 else 1.0\n        # K guess: x-value where response is closest to half-max.\n        half_max_y = E_max_guess / 2.0\n        idx = np.argmin(np.abs(y_fit - half_max_y))\n        K_guess = x_fit[idx]\n        # n guess: starting assumption of no cooperativity.\n        n_guess = 1.0\n        \n        initial_guesses = [n_guess, K_guess, E_max_guess]\n\n        # Define parameter bounds: n  0, K  0, 0 = E_max = 1.2\n        # Use a small positive number for lower bounds of n and K to ensure they are  0.\n        bounds = ([1e-9, 1e-9, 0.0], [np.inf, np.inf, 1.2])\n\n        # Perform nonlinear least-squares fitting.\n        popt, _ = curve_fit(\n            hill_function,\n            x_fit,\n            y_fit,\n            p0=initial_guesses,\n            bounds=bounds,\n            maxfev=5000 # Increase iterations for robust convergence.\n        )\n        \n        n_opt, K_opt, E_max_opt = popt\n        \n        # Classify cooperativity based on the Hill coefficient n.\n        # Tolerance is +/- 0.1 around n=1.\n        if n_opt  1.1:\n            c = 1  # Positive cooperativity\n        elif n_opt  0.9:\n            c = -1 # Negative cooperativity\n        else:\n            c = 0  # No cooperativity\n            \n        # Format the parameters according to the problem's rounding rules.\n        n_final = n_opt\n        K_final = int(round(K_opt))\n        E_max_final = E_max_opt\n        \n        results.append([n_final, K_final, E_max_final, c])\n\n    # Construct the final output string in the exact required format.\n    result_strings = []\n    for res in results:\n        # Format n and E_max to 6 decimal places, K as integer.\n        result_strings.append(f\"[{res[0]:.6f},{res[1]},{res[2]:.6f},{res[3]}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "5035086"}]}