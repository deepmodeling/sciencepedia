{"hands_on_practices": [{"introduction": "真核生物基因的表达调控始于转录因子（TF）与DNA上特定位点的精确结合。为了定量地理解这一过程，我们可以运用统计力学的基本原理来构建模型。这项练习将指导你推导单个转录因子占据其结合位点的概率，并进一步将模型扩展到包含协同效应的场景，即一个TF的结合会影响邻近位点上另一个TF的结合。", "problem": "在一个基于染色质免疫沉淀的真核启动子转录因子占据实验中，您需要为一个转录因子（TF）物种与一个或两个邻近的相同DNA位点的结合进行建模。假设快速平衡、细胞核混合均匀，并且相对于所检测的DNA位点数量，游离TF浓度 $[TF]$ 实际上是恒定的。单个TF结合位点的解离常数 $K_d$ 由平衡关系 $K_d = \\frac{[TF][S]}{[TF{:}S]}$ 定义，其中 $[S]$ 表示游离位点浓度，$[TF{:}S]$ 表示TF结合位点复合物的浓度。对于两个位点，假设每个位点独立结合时具有相同的 $K_d$。为了捕捉两个位点同时被占据时的协同性，引入一个无量纲的协同因子 $\\omega$，其定义为：双占据状态的统计权重相对于独立单一位点权重乘积，再乘以 $\\omega$；$\\omega > 1$ 代表正协同性，$\\omega = 1$ 代表独立结合，$\\omega < 1$ 代表负协同性。利用平衡统计力学和质量作用结合定律，首先推导单个位点的平衡占据概率。然后将推导扩展到两个相同位点，以获得两个位点同时被占据的平衡概率，该概率是 $[TF]$、$K_d$ 和 $\\omega$ 的函数。请提供双占据概率的单个闭合形式解析表达式作为您的最终答案。不需要数值近似或四舍五入，也不需要包含单位。", "solution": "该问题要求推导两个相同、具有协同性的转录因子（TF）结合位点被同时占据的平衡概率。我们将使用平衡统计力学的原理来解决这个问题。\n\n首先，我们验证一下问题陈述。\n**步骤1：提取已知条件**\n- **系统：** 单个转录因子（TF）物种与一个或两个邻近的相同DNA位点结合。\n- **假设：** 快速平衡、细胞核混合均匀，且游离TF浓度（表示为 $[TF]$）是恒定的。\n- **定义1（解离常数）：** 对于单个位点 `S`，解离常数 $K_d$ 由平衡关系 $K_d = \\frac{[TF][S]}{[TF{:}S]}$ 给出，其中 $[S]$ 是游离位点浓度，$[TF{:}S]$ 是TF结合位点复合物的浓度。\n- **定义2（协同因子）：** 对于双位点系统，引入一个无量纲的协同因子 $\\omega$。双占据状态的统计权重是独立单一位点权重乘积的 $\\omega$ 倍。\n- **任务：** 1) 推导单个位点的平衡占据概率。2) 将推导扩展到两个相同位点，求出两个位点同时被占据的平衡概率，表示为 $[TF]$、$K_d$ 和 $\\omega$ 的函数。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，利用了物理化学和分子生物学中常见的生物分子结合标准模型（质量作用定律、统计力学、协同性）。各项术语（$K_d$、$\\omega$）定义明确，相关假设（$[TF]$ 恒定、平衡状态）是简化此类模型的标准做法。问题本身是自洽的、客观的、提法得当的，要求根据所提供的参数求出特定量。没有矛盾、事实错误或含糊之处。\n\n**步骤3：结论与行动**\n问题有效。我们将继续进行解答。\n\n**单个结合位点的推导**\n对于单个结合位点，存在两种可能的状态：未结合（$S$）和已结合（$TF{:}S$）。占据概率 $P_{\\text{occ,1}}$ 是处于结合状态的位点占总位点的比例：\n$$P_{\\text{occ,1}} = \\frac{[TF{:}S]}{[S] + [TF{:}S]}$$\n根据解离常数的定义 $K_d = \\frac{[TF][S]}{[TF{:}S]}$，我们可以用已结合位点 $[TF{:}S]$ 的浓度来表示游离位点 $[S]$ 的浓度：\n$$[S] = K_d \\frac{[TF{:}S]}{[TF]}$$\n将这个 $[S]$ 的表达式代入 $P_{\\text{occ,1}}$ 的方程中：\n$$P_{\\text{occ,1}} = \\frac{[TF{:}S]}{K_d \\frac{[TF{:}S]}{[TF]} + [TF{:}S]}$$\n分子和分母同除以 $[TF{:}S]$（为使问题有意义，该值必须非零）：\n$$P_{\\text{occ,1}} = \\frac{1}{\\frac{K_d}{[TF]} + 1}$$\n简化此表达式可得到单个位点的占据概率，这个结果在形式上被称为Langmuir等温线：\n$$P_{\\text{occ,1}} = \\frac{[TF]}{K_d + [TF]}$$\n这完成了任务的第一部分。\n\n**两个协同结合位点的推导**\n对于具有两个相同位点的系统，我们使用统计力学框架。系统处于特定状态的概率是该状态的统计权重与所有可能状态的统计权重之和（配分函数 $Z$）的比值。\n\n设两个位点为 $S_1$ 和 $S_2$。系统有四种可能的微观状态：\n1.  两个位点都未结合 ($S_1, S_2$)。\n2.  位点1结合，位点2未结合 ($TF{:}S_1, S_2$)。\n3.  位点1未结合，位点2结合 ($S_1, TF{:}S_2$)。\n4.  两个位点都结合 ($TF{:}S_1, TF{:}S_2$)。\n\n我们将完全未结合状态的统计权重定义为1。\n-   状态 ($S_1, S_2$) 的统计权重 $W_{00}$：$W_{00} = 1$。\n\n结合一个TF分子的状态的统计权重与配体浓度 $[TF]$ 成正比，与其解离常数 $K_d$ 成反比。\n-   状态 ($TF{:}S_1, S_2$) 的统计权重 $W_{10}$：$W_{10} = \\frac{[TF]}{K_d}$。\n-   状态 ($S_1, TF{:}S_2$) 的统计权重 $W_{01}$：$W_{01} = \\frac{[TF]}{K_d}$，因为两个位点是相同的。\n\n双占据状态的统计权重考虑了两个结合事件。如果结合事件是独立的（$\\omega=1$），其权重将是单个权重的乘积，即 $(\\frac{[TF]}{K_d}) \\times (\\frac{[TF]}{K_d})$。问题引入了协同因子 $\\omega$，该因子乘以这个独立权重。\n-   状态 ($TF{:}S_1, TF{:}S_2$) 的统计权重 $W_{11}$：$W_{11} = \\omega \\left(\\frac{[TF]}{K_d}\\right)^2 = \\omega \\frac{[TF]^2}{K_d^2}$。\n\n配分函数 $Z$ 是所有可能状态的统计权重之和：\n$$Z = W_{00} + W_{10} + W_{01} + W_{11}$$\n$$Z = 1 + \\frac{[TF]}{K_d} + \\frac{[TF]}{K_d} + \\omega \\frac{[TF]^2}{K_d^2}$$\n$$Z = 1 + 2 \\frac{[TF]}{K_d} + \\omega \\frac{[TF]^2}{K_d^2}$$\n\n问题要求的是两个位点同时被占据的平衡概率。这对应于处于状态 ($TF{:}S_1, TF{:}S_2$) 的概率，我们将其表示为 $P_{11}$。该概率是双占据状态的统计权重 $W_{11}$ 除以配分函数 $Z$。\n$$P_{11} = \\frac{W_{11}}{Z} = \\frac{\\omega \\frac{[TF]^2}{K_d^2}}{1 + 2 \\frac{[TF]}{K_d} + \\omega \\frac{[TF]^2}{K_d^2}}$$\n为了得到一个简化的闭合形式表达式，我们可以将分子和分母同乘以 $K_d^2$：\n$$P_{11} = \\frac{K_d^2 \\left(\\omega \\frac{[TF]^2}{K_d^2}\\right)}{K_d^2 \\left(1 + 2 \\frac{[TF]}{K_d} + \\omega \\frac{[TF]^2}{K_d^2}\\right)}$$\n$$P_{11} = \\frac{\\omega [TF]^2}{K_d^2 + 2 K_d [TF] + \\omega [TF]^2}$$\n这就是双占据概率作为 $[TF]$、$K_d$ 和 $\\omega$ 的函数的最终表达式。", "answer": "$$\\boxed{\\frac{\\omega [TF]^2}{K_d^2 + 2 K_d [TF] + \\omega [TF]^2}}$$", "id": "5167750"}, {"introduction": "理解了转录因子结合的平衡态特性后，下一步是探究其对基因表达速率的动力学影响。本练习模拟了一个在分子诊断中具有重要意义的场景：一个影响TATA结合蛋白（TBP）亲和力的启动子突变，将如何改变转录起始的速率。通过应用化学动力学中的稳态近似和限速步骤等概念，你将建立基因型（DNA突变）与表型（基因表达速率）之间的定量联系。", "problem": "在一个与分子及免疫诊断学相关的真核转录起始情境中，考虑一个含有典型TATA盒的启动子，该启动子招募TATA结合蛋白 (TBP)。分子生物学的中心法则确立了由RNA聚合酶II起始的转录是信使核糖核酸 (mRNA) 合成的前提，而在启动子上形成起始前复合物 (PIC) 是基因表达中的一个关键调控步骤。假设以下机制框架符合质量作用定律和标准的基因调控原理：\n\n- 启动子 $P$ 与TBP $T$ 结合形成TBP结合的复合物 $PT$：$$P + T \\rightleftharpoons PT,$$ 该过程由解离常数 $$K_{d} = \\frac{[P][T]}{[PT]}$$ 表征。$T$ 的核内浓度是恒定的，记为 $[T]$。\n- PIC组装仅从 $PT$ 状态发生，其有效一级速率常数为 $$k_{\\mathrm{PIC}},$$ 即 $$PT \\xrightarrow{k_{\\mathrm{PIC}}} \\mathrm{PIC},$$ 并且后续步骤（启动子清除和转录起始）比PIC形成快得多，因此PIC形成是有效起始的限速步骤。\n- 相对于PIC形成，TBP的结合与解离能迅速达到平衡（预平衡近似），且在每次起始事件后，启动子会循环回到未结合的 $P$ 状态。\n\nTATA盒中的一个点突变降低了TBP的亲和力，使解离常数增加到 $$K_{d}^{\\prime} = f K_{d},$$ 其中 $f > 1$ 是一个无量纲因子。在上述假设下，推导由该突变导致的稳态起始速率的倍数变化，定义为 $$\\frac{R(f)}{R(1)},$$ 其中 $R(f)$ 是解离常数为 $K_{d}^{\\prime} = f K_{d}$ 时的起始速率，$R(1)$ 是原始解离常数为 $K_{d}$ 时的起始速率。请用 $f$、$[T]$ 和 $K_{d}$ 表示您的最终答案，形式为一个闭式符号表达式。不需要进行数值计算，最终方框内的表达式不应包含单位。", "solution": "该问题要求推导因突变改变了TATA结合蛋白 (TBP) 与其启动子结合位点的解离常数而导致的转录起始速率的倍数变化，即 $\\frac{R(f)}{R(1)}$。解答是根据化学动力学和平衡的基本原理推导出来的。\n\n问题陈述，有效转录起始的速率 $R$ 由起始前复合物 (PIC) 的形成速率决定，而后者是限速步骤。此过程被描述为相对于TBP结合的启动子复合物浓度 $[PT]$ 的一级反应。因此，速率定律为：\n$$R = k_{\\mathrm{PIC}} [PT]$$\n其中 $k_{\\mathrm{PIC}}$ 是PIC形成的有效速率常数。\n\n为了求出速率 $R$，我们必须首先确定稳态浓度 $[PT]$。问题陈述，TBP ($T$) 与启动子 ($P$) 的结合是一个快速平衡过程：\n$$P + T \\rightleftharpoons PT$$\n此平衡由解离常数 $K_d$ 表征：\n$$K_{d} = \\frac{[P][T]}{[PT]}$$\n启动子的总浓度 $[P]_{\\text{total}}$ 是守恒的，等于游离启动子浓度 $[P]$ 和TBP结合的启动子浓度 $[PT]$ 之和：\n$$[P]_{\\text{total}} = [P] + [PT]$$\n我们可以利用平衡方程，并注意到TBP浓度 $[T]$ 是恒定的，将 $[P]$ 用 $[PT]$ 表示：\n$$[P] = \\frac{K_{d} [PT]}{[T]}$$\n将这个 $[P]$ 的表达式代入启动子的守恒方程：\n$$[P]_{\\text{total}} = \\frac{K_{d} [PT]}{[T]} + [PT]$$\n我们可以提出 $[PT]$ 因子以求解其浓度：\n$$[P]_{\\text{total}} = [PT] \\left( \\frac{K_{d}}{[T]} + 1 \\right) = [PT] \\left( \\frac{K_{d} + [T]}{[T]} \\right)$$\n解出 $[PT]$ 可得：\n$$[PT] = [P]_{\\text{total}} \\left( \\frac{[T]}{K_{d} + [T]} \\right)$$\n该表达式代表了从中起始转录的复合物的浓度。现在，我们将其代回 $R$ 的速率定律：\n$$R = k_{\\mathrm{PIC}} [P]_{\\text{total}} \\left( \\frac{[T]}{K_{d} + [T]} \\right)$$\n这是在指定假设下转录起始速率的通用表达式。\n\n接下来，我们将此通用公式应用于所描述的两种情况：原始启动子和突变启动子。\n\n情况1：原始启动子（野生型）\n原始启动子的起始速率 $R(1)$ 使用解离常数 $K_d$。\n$$R(1) = k_{\\mathrm{PIC}} [P]_{\\text{total}} \\left( \\frac{[T]}{K_{d} + [T]} \\right)$$\n\n情况2：突变启动子\n突变使解离常数增加到 $K_{d}^{\\prime} = f K_{d}$。突变启动子的起始速率 $R(f)$ 可以通过在通用速率表达式中用 $K_{d}^{\\prime}$ 替换 $K_{d}$ 来得到：\n$$R(f) = k_{\\mathrm{PIC}} [P]_{\\text{total}} \\left( \\frac{[T]}{K_{d}^{\\prime} + [T]} \\right) = k_{\\mathrm{PIC}} [P]_{\\text{total}} \\left( \\frac{[T]}{f K_{d} + [T]} \\right)$$\n\n最后，我们计算所要求的倍数变化，即比率 $\\frac{R(f)}{R(1)}$：\n$$\\frac{R(f)}{R(1)} = \\frac{k_{\\mathrm{PIC}} [P]_{\\text{total}} \\left( \\frac{[T]}{f K_{d} + [T]} \\right)}{k_{\\mathrm{PIC}} [P]_{\\text{total}} \\left( \\frac{[T]}{K_{d} + [T]} \\right)}$$\n常数项 $k_{\\mathrm{PIC}}$、$[P]_{\\text{total}}$ 和 $[T]$ 在分子和分母中被约去：\n$$\\frac{R(f)}{R(1)} = \\frac{\\frac{1}{f K_{d} + [T]}}{\\frac{1}{K_{d} + [T]}}$$\n简化这个复合分数，得到倍数变化的最终表达式：\n$$\\frac{R(f)}{R(1)} = \\frac{K_{d} + [T]}{f K_{d} + [T]}$$\n这就是稳态起始速率倍数变化的闭式符号表达式，用给定的参数 $f$、$[T]$ 和 $K_d$ 表示。由于 $f > 1$，分母大于分子，这正确地表明，削弱TBP结合的突变会导致转录起始速率降低。", "answer": "$$\\boxed{\\frac{K_{d} + [T]}{f K_{d} + [T]}}$$", "id": "5167809"}, {"introduction": "前两个练习集中于单个基因启动子的理论模型，而现代分子生物学研究则是在全基因组尺度上进行的。这项计算实践将带你进入生物信息学的核心工作流程之一：分析染色质免疫共沉淀测序（ChIP-seq）数据，以识别与特定转录因子结合的DNA序列模体（motif）是否显著富集。你将学习如何运用恰当的统计模型（超几何分布或二项分布）进行假设检验，并使用Benjamini-Hochberg方法对多重检验进行校正，这是处理大规模基因组数据的关键技能。", "problem": "您正在分子生物学中心法则的框架内研究真核基因调控中的转录因子结合。该法则指出，脱氧核糖核酸（DNA）转录为核糖核酸（RNA），并翻译成蛋白质。转录因子在特定的短序列基序处与脱氧核糖核酸（DNA）结合以调控基因表达；染色质免疫沉淀测序（ChIP-seq）可识别富含此类结合的基因组区域。在诊断背景下，如果一个基序在ChIP-seq峰集中的频率超过了从一个已定义的基因组背景中所预期的频率，则认为该基序是富集的。\n\n请从第一性原理出发，使用无放回抽样或独立伯努利试验，对峰中相对于背景的基序出现率进行建模。构建一个关于富集的右尾假设检验，其原假设如下：峰集中的基序频率等于背景频率。对于从有限总体中进行的无放回抽样，请使用与超几何分布一致的模型；对于成功概率等于背景比例的独立伯努利试验，请使用与二项分布一致的模型。对每个基序，计算右尾p值 $\\Pr(X \\ge k)$，其中 $X$ 是计数峰集中基序出现次数的随机变量，$k$ 是观测到的计数值。在每个测试用例的所有基序中，使用 Benjamini–Hochberg (BH) 程序进行多重检验校正，并返回 Benjamini–Hochberg 校正后的p值。将FDR控制水平表示为小数（例如，$0.05$），但您不需要输出显著性判定；只需输出校正后的p值。\n\n每个基序的参数定义如下。设 $M$ 表示检查的背景区域总数，$K$ 表示含有该基序的背景区域数，$n$ 表示ChIP-seq峰的数量，$k$ 表示含有该基序的峰的数量。对于二项模型，原假设下的成功概率为 $p_0 = K / M$。\n\n实现一个程序，对于下方的每个测试用例，使用指定的模型计算所有列出基序的右尾p值，对这些p值应用Benjamini–Hochberg程序，并输出Benjamini–Hochberg校正后的p值。将每个校正后的p值四舍五入到 $6$ 位小数。\n\n测试套件（三个不同的测试用例，共同覆盖典型、边界和边缘场景）：\n\n- 测试用例 $1$（无放回抽样；超几何模型）：\n  - 共享参数：$M = 10000$，$n = 500$。\n  - 基序 $\\mathrm{A}$：$K = 800$，$k = 70$。\n  - 基序 $\\mathrm{B}$：$K = 300$，$k = 10$。\n  - 基序 $\\mathrm{C}$：$K = 1500$，$k = 30$。\n\n- 测试用例 $2$（独立伯努利试验；二项模型）：\n  - 共享参数：$M = 20000$，$n = 40$；对于每个基序，原假设下的概率为 $p_0 = K/M$。\n  - 基序 $\\mathrm{D}$：$K = 400$，$k = 0$（测试零成功）。\n  - 基序 $\\mathrm{E}$：$K = 1200$，$k = 40$（测试全部成功）。\n  - 基序 $\\mathrm{F}$：$K = 900$，$k = 3$（中等情况）。\n\n- 测试用例 $3$（边缘条件；超几何模型）：\n  - 共享参数：$M = 1000$，$n = 50$。\n  - 基序 $\\mathrm{G}$：$K = 0$，$k = 0$（不可能成功）。\n  - 基序 $\\mathrm{H}$：$K = 1000$，$k = 50$（所有抽取均为成功）。\n  - 基序 $\\mathrm{I}$：$K = 80$，$k = 2$（接近背景的场景）。\n\n您的程序应产生单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。该列表应为测试用例 $1$ 中按 $\\mathrm{A}, \\mathrm{B}, \\mathrm{C}$ 顺序的 Benjamini–Hochberg 校正p值，然后是测试用例 $2$ 中按 $\\mathrm{D}, \\mathrm{E}, \\mathrm{F}$ 顺序的p值，最后是测试用例 $3$ 中按 $\\mathrm{G}, \\mathrm{H}, \\mathrm{I}$ 顺序的p值的串联。例如，输出格式应为 $[\\text{adjA},\\text{adjB},\\text{adjC},\\text{adjD},\\text{adjE},\\text{adjF},\\text{adjG},\\text{adjH},\\text{adjI}]$，其中每个元素是四舍五入到 $6$ 位小数的浮点数。", "solution": "问题陈述已经过评估，并被确定为有效。它具有科学依据，问题设定良好，客观，并包含推导唯一解所需的所有信息。所述场景——使用超几何或二项模型检验ChIP-seq数据中转录因子基序的富集情况，然后进行多重检验校正——是计算生物学和生物信息学中的一个标准和基本程序。所提供的参数和测试用例，包括边缘条件，适用于验证一个正确的实现。\n\n将按照要求从第一性原理出发构建解决方案。\n\n### 基序富集分析原理\n\n核心任务是确定一个短DNA序列基序在一组感兴趣的基因组区域（ChIP-seq峰）中出现的频率是否比基于其在更大基因组背景中的频率偶然预期的要高。这被构建为一个统计假设检验。\n\n**1. 假设检验框架**\n\n对于每个基序，我们检验一个原假设（$H_0$）对一个备择假设（$H_1$）。\n- **原假设（$H_0$）**：峰集中的基序频率与其在基因组背景中的频率相同。任何观察到的超额都是由随机抽样变异引起的。\n- **备择假设（$H_1$）**：峰集中的基序频率大于其在背景中的频率，表明存在生物学富集。\n\n这是一个**右尾检验**。我们计算一个p值，即在原假设为真的情况下，观察到峰中基序计数至少与实际观察到的计数（$k$）一样极端的概率。一个小的p值表明，在原假设下，该观察结果是不太可能发生的，从而为富集提供了证据。\n\np值的形式为 $\\Pr(X \\ge k)$，其中 $X$ 是表示在原假设模型下在峰集中找到的基序数量的随机变量，$k$ 是观察到的计数。\n\n**2. 原分布的统计模型**\n\n问题指定了两种不同的抽样模型用于基序计数的原分布。\n\n**a) 超几何模型（无放回抽样）**\n\n当峰集被视为从一个有限背景总体中*无放回*抽取的样本时，此模型是合适的。\n\n- 设 $M$ 为基因组背景中的区域总数。\n- 设 $K$ 为那些含有该基序的背景区域的数量。\n- 设 $n$ 为峰集中的区域数量（样本大小）。\n- 设 $X$ 为样本中含有该基序的峰的数量的随机变量。\n\n在原假设下，$X$ 服从超几何分布，$X \\sim \\text{Hypergeometric}(M, K, n)$。其概率质量函数（PMF）由下式给出：\n$$P(X=i) = \\frac{\\binom{K}{i} \\binom{M-K}{n-i}}{\\binom{M}{n}}$$\np值是观察到 $k$ 或更多基序的概率，使用生存函数（SF）计算：\n$$p = \\Pr(X \\ge k) = \\sum_{i=k}^{\\min(n, K)} P(X=i)$$\n\n此模型用于测试用例 $1$ 和测试用例 $3$。\n\n**b) 二项模型（有放回抽样/独立伯努利试验）**\n\n当背景总体 $M$ 相对于样本大小 $n$ 非常大，或者当峰被视为一系列独立试验时，此模型是合适的。\n\n- 设 $n$ 为峰的数量（试验次数）。\n- 设 $p_0$ 为在原假设下单个峰含有该基序的概率。这从背景中估计为 $p_0 = K/M$。\n- 设 $Y$ 为含有该基序的峰的数量的随机变量。\n\n在原假设下，$Y$ 服从二项分布，$Y \\sim \\text{Binomial}(n, p_0)$。其PMF为：\n$$P(Y=i) = \\binom{n}{i} p_0^i (1-p_0)^{n-i}$$\np值是观察到 $k$ 或更多基序的概率：\n$$p = \\Pr(Y \\ge k) = \\sum_{i=k}^{n} P(Y=i)$$\n\n此模型用于测试用例 $2$。\n\n**3. 多重检验校正：Benjamini–Hochberg (BH) 程序**\n\n当同时执行多个假设检验时（例如，每个基序一个），发生至少一次假发现（I型错误）的概率会增加。Benjamini–Hochberg程序是控制假发现率（FDR）的标准方法，FDR是指被拒绝的原假设中实际上为真的那部分所占的期望比例。\n\n为一组 $m$ 个原始p值（$p_1, p_2, \\ldots, p_m$）计算BH校正p值的步骤如下：\n1.  将原始p值按升序排序：$p_{(1)} \\le p_{(2)} \\le \\ldots \\le p_{(m)}$。\n2.  对于每个排序后的p值 $p_{(i)}$，计算一个中间值：$q_{(i)} = \\frac{m}{i} p_{(i)}$。\n3.  为确保校正后的p值随原始p值单调非递减，秩为 $i$ 的最终校正p值计算为从该秩及以上的所有中间值的累积最小值：$p_{adj, (i)} = \\min_{j=i}^{m} \\{q_{(j)}\\}$。\n4.  最后，将任何超过 $1.0$ 的校正p值限制为 $1.0$：$p_{adj, (i)}' = \\min(p_{adj, (i)}, 1.0)$。\n5.  然后将校正后的p值恢复到其原始的、未排序的顺序。\n\n### 计算策略与执行\n\n实现将通过计算每个测试用例中每个基序的原始p值，然后对该组p值应用BH程序来进行。\n\n为了计算原始p值 $\\Pr(X \\ge k)$，我们使用 `scipy.stats` 提供的生存函数（SF）。对于离散分布，`dist.sf(x)` 计算 $\\Pr(X > x)$。因此，要计算 $\\Pr(X \\ge k)$，我们必须评估 `dist.sf(k-1)`。\n\n**测试用例 $1$：超几何模型**\n共享参数：$M = 10000$，$n = 500$。\n- 基序 $\\mathrm{A}$：$K=800, k=70$。期望计数为 $n \\times (K/M) = 500 \\times (800/10000) = 40$。观察到的计数为 $70$，表明存在强富集。\n- 基序 $\\mathrm{B}$：$K=300, k=10$。期望计数为 $500 \\times (300/10000) = 15$。观察到的计数为 $10$，低于预期，表明没有富集。\n- 基序 $\\mathrm{C}$：$K=1500, k=30$。期望计数为 $500 \\times (1500/10000) = 75$。观察到的计数为 $30$，远低于预期。\n使用超几何生存函数计算基序 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$ 的原始p值，然后对这三个p值的集合应用BH程序。\n\n**测试用例 $2$：二项模型**\n共享参数：$M = 20000$，$n = 40$。\n- 基序 $\\mathrm{D}$：$K=400, k=0$。原假设概率为 $p_0 = 400/20000 = 0.02$。观察到 $k=0$ 并不是反对原假设的证据（即不是富集的证据），因此我们预期会得到一个高的p值。$\\Pr(Y \\ge 0) = 1$。\n- 基序 $\\mathrm{E}$：$K=1200, k=40$。原假设概率为 $p_0 = 1200/20000 = 0.06$。在背景概率仅为 $0.06$ 的情况下，在所有 $40$ 个峰中都观察到该基序，这在原假设下是极不可能的，表明存在极强的富集。\n- 基序 $\\mathrm{F}$：$K=900, k=3$。原假设概率为 $p_0 = 900/20000 = 0.045$。期望计数为 $n \\times p_0 = 40 \\times 0.045 = 1.8$。观察到 $3$ 略高于期望。\n使用二项生存函数计算基序 $\\mathrm{D}$、$\\mathrm{E}$ 和 $\\mathrm{F}$ 的原始p值，并应用BH程序。\n\n**测试用例 $3$：超几何边缘条件**\n共享参数：$M=1000, n=50$。\n- 基序 $\\mathrm{G}$：$K=0, k=0$。如果背景中不存在该基序（$K=0$），则不可能在样本中观察到它。唯一可能的结果是 $k=0$，因此 $\\Pr(X=0)=1$ 且 $\\Pr(X \\ge 0) = 1$。预期p值为 $1.0$。\n- 基序 $\\mathrm{H}$：$K=1000, k=50$。如果每个背景区域中都有该基序（$K=M$），那么每个抽样的峰都必须包含它。唯一可能的结果是 $k=n=50$，因此 $\\Pr(X=50)=1$ 且 $\\Pr(X \\ge 50)=1$。预期p值为 $1.0$。\n- 基序 $\\mathrm{I}$：$K=80, k=2$。期望计数为 $50 \\times (80/1000) = 4$。观察到 $2$ 低于预期。\n计算基序 $\\mathrm{G}$、$\\mathrm{H}$ 和 $\\mathrm{I}$ 的原始p值，并应用BH程序。\n\n最终输出是所有 $9$ 个校正后p值的串联，四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Computes motif enrichment p-values, applies Benjamini-Hochberg correction,\n    and returns the adjusted p-values for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"model\": \"hypergeometric\",\n            \"params\": {\"M\": 10000, \"n\": 500},\n            \"motifs\": [\n                {\"name\": \"A\", \"K\": 800, \"k\": 70},\n                {\"name\": \"B\", \"K\": 300, \"k\": 10},\n                {\"name\": \"C\", \"K\": 1500, \"k\": 30},\n            ],\n        },\n        {\n            \"model\": \"binomial\",\n            \"params\": {\"M\": 20000, \"n\": 40},\n            \"motifs\": [\n                {\"name\": \"D\", \"K\": 400, \"k\": 0},\n                {\"name\": \"E\", \"K\": 1200, \"k\": 40},\n                {\"name\": \"F\", \"K\": 900, \"k\": 3},\n            ],\n        },\n        {\n            \"model\": \"hypergeometric\",\n            \"params\": {\"M\": 1000, \"n\": 50},\n            \"motifs\": [\n                {\"name\": \"G\", \"K\": 0, \"k\": 0},\n                {\"name\": \"H\", \"K\": 1000, \"k\": 50},\n                {\"name\": \"I\", \"K\": 80, \"k\": 2},\n            ],\n        },\n    ]\n\n    def benjamini_hochberg(p_values):\n        \"\"\"\n        Applies the Benjamini-Hochberg FDR correction to a list of p-values.\n        \"\"\"\n        p_values = np.asarray(p_values)\n        n_tests = len(p_values)\n        \n        # Original indices to restore order later\n        original_indices = np.arange(n_tests)\n        \n        # Sort p-values and their original indices\n        sorted_indices = np.argsort(p_values)\n        sorted_p_values = p_values[sorted_indices]\n        \n        # Calculate ranks (1-based) for sorted p-values\n        ranks = np.arange(1, n_tests + 1)\n        \n        # Calculate BH adjusted p-values for the sorted list\n        adj_p_values_sorted = (n_tests / ranks) * sorted_p_values\n        \n        # Enforce monotonicity: p_adj(i) = min(p_adj(i), p_adj(i+1), ...)\n        # This is achieved by a cumulative minimum on the reversed array\n        monotonic_adj_p = np.minimum.accumulate(adj_p_values_sorted[::-1])[::-1]\n        \n        # Cap values at 1.0\n        final_adj_p_sorted = np.minimum(monotonic_adj_p, 1.0)\n        \n        # Restore original order\n        # Create an empty array and fill it using the sorted indices\n        restored_adj_p = np.empty(n_tests)\n        restored_adj_p[sorted_indices] = final_adj_p_sorted\n        \n        return restored_adj_p.tolist()\n\n    all_results = []\n    \n    for case in test_cases:\n        raw_p_values = []\n        if case[\"model\"] == \"hypergeometric\":\n            M = case[\"params\"][\"M\"]\n            n = case[\"params\"][\"n\"]\n            for motif in case[\"motifs\"]:\n                K = motif[\"K\"]\n                k = motif[\"k\"]\n                # Pr(X >= k) is the survival function at k-1 for discrete distributions\n                p_val = stats.hypergeom.sf(k - 1, M, K, n)\n                raw_p_values.append(p_val)\n        \n        elif case[\"model\"] == \"binomial\":\n            M = case[\"params\"][\"M\"]\n            n = case[\"params\"][\"n\"]\n            for motif in case[\"motifs\"]:\n                K = motif[\"K\"]\n                k = motif[\"k\"]\n                p0 = K / M\n                # Pr(Y >= k) is the survival function at k-1\n                p_val = stats.binom.sf(k - 1, n, p0)\n                raw_p_values.append(p_val)\n\n        # Apply Benjamini-Hochberg correction\n        adjusted_p_values = benjamini_hochberg(raw_p_values)\n        \n        # Round results to 6 decimal places and add to the final list\n        all_results.extend([round(p, 6) for p in adjusted_p_values])\n\n    # Format the final output as a comma-separated list in brackets\n    # Using .6f ensures trailing zeros for consistent formatting\n    formatted_results = [f\"{res:.6f}\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "5167759"}]}