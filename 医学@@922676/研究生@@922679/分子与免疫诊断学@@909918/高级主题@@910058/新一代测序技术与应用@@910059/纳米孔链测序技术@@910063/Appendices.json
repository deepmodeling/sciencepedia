{"hands_on_practices": [{"introduction": "纳米孔测序的第一步是捕获DNA分子。捕获的方向（即，是由$3'$端还是$5'$端先进入）并非完全随机，而是受到马达蛋白与DNA末端结合和解离的动力学以及捕获起始速率的复杂影响。这项练习 [@problem_id:5138871] 将引导你从第一性原理出发，为这种捕获方向偏好性建立一个量化模型。通过运用连续时间马尔可夫链和竞争性随机过程的知识，你将深入理解影响纳米孔测序数据的关键生物物理因素。", "problem": "在纳米孔链测序中，脱氧核糖核酸 (DNA) 分子在外加电势下穿过单个纳米孔，一个附着在DNA末端的持续性酶（“马达”）调控其跨膜运动。取向偏好（由$3'$末端捕获与$5'$末端捕获）可能源于马达在两端附着和脱离的不对称动力学，以及马达结合后起始速率的差异。考虑单个DNA分子在孔隙附近扩散，其捕获受限于每端是否有结合的马达。\n\n假设对于每个末端 $i \\in \\{3,5\\}$：\n- 末端在两种状态之间切换：马达脱离态和马达附着态。状态转换是一级反应，速率分别为 $k_{\\mathrm{on},i}$（脱离时马达附着）和 $k_{\\mathrm{off},i}$（附着时马达脱离）。\n- 当马达附着时，受控捕获进入孔隙的起始是一个无记忆事件，速率为 $c_i$。当马达脱离时，不发生起始。\n- 在首次捕获发生之前，$3'$ 末端和 $5'$ 末端独立演化。\n\n从基本的随机过程原理（无记忆转换、连续时间马尔可夫链（CTMC）的平稳性，以及独立泊松过程的叠加和竞争）出发，推导首次捕获发生在 $3'$ 末端的概率 $P_{3'}$ 的表达式。\n\n使用以下实验上合理的参数（假设不随时间变化）：\n- $k_{\\mathrm{on},3} = 2.4\\,\\mathrm{s}^{-1}$， $k_{\\mathrm{off},3} = 0.6\\,\\mathrm{s}^{-1}$， $c_3 = 4.0\\,\\mathrm{s}^{-1}$，\n- $k_{\\mathrm{on},5} = 1.2\\,\\mathrm{s}^{-1}$， $k_{\\mathrm{off},5} = 1.4\\,\\mathrm{s}^{-1}$， $c_5 = 3.0\\,\\mathrm{s}^{-1}$。\n\n将 $P_{3'}$ 的最终答案表示为一个无单位小数，并四舍五入到四位有效数字。", "solution": "该问题具有科学依据，是适定的、客观的，并包含足够的信息来推导出唯一解。该模型是分子生物物理学中一个随机过程的标准且物理上合理的粗粒化表示。问题指导解决者使用连续时间马尔可夫链 (CTMC) 平稳性和泊松过程竞争的原理，这为求解提供了清晰有效的路径。因此，该问题被认为是有效的。\n\n问题要求计算 DNA 分子在其 $5'$ 末端之前被其 $3'$ 末端捕获的概率 $P_{3'}$。每个末端 $i \\in \\{3,5\\}$ 的过程是独立的，包括两个步骤：马达酶的附着和随后的捕获起始。\n\n首先，我们对每个末端 $i$ 上马达的状态进行建模。马达可以处于两种状态之一：脱离态 ($S_{i,0}$) 或附着态 ($S_{i,1}$)。这些状态之间的转换是一级动力学过程，可以用连续时间马尔可夫链 (CTMC) 来描述。转换速率为：\n- $S_{i,0} \\to S_{i,1}$，速率为 $k_{\\mathrm{on},i}$\n- $S_{i,1} \\to S_{i,0}$，速率为 $k_{\\mathrm{off},i}$\n\n问题暗示我们应该考虑系统处于平稳状态，这对于此类扩散限制的捕获过程是常见的，并且“CTMC平稳性”的提法也明确地建议了这一点。设 $\\pi_{i,0}$ 和 $\\pi_{i,1}$ 分别为末端 $i$ 处于脱离态和附着态的平稳概率。在稳态下，两种状态之间的概率流必须相等：\n$$ \\pi_{i,0} k_{\\mathrm{on},i} = \\pi_{i,1} k_{\\mathrm{off},i} $$\n此外，概率之和必须为1：\n$$ \\pi_{i,0} + \\pi_{i,1} = 1 $$\n从第一个方程，我们得到 $\\pi_{i,0} = \\pi_{i,1} \\frac{k_{\\mathrm{off},i}}{k_{\\mathrm{on},i}}$。将其代入第二个方程得到：\n$$ \\pi_{i,1} \\frac{k_{\\mathrm{off},i}}{k_{\\mathrm{on},i}} + \\pi_{i,1} = 1 $$\n$$ \\pi_{i,1} \\left( \\frac{k_{\\mathrm{off},i} + k_{\\mathrm{on},i}}{k_{\\mathrm{on},i}} \\right) = 1 $$\n求解 $\\pi_{i,1}$，即马达在末端 $i$ 附着的平稳概率，我们发现：\n$$ \\pi_{i,1} = \\frac{k_{\\mathrm{on},i}}{k_{\\mathrm{on},i} + k_{\\mathrm{off},i}} $$\n\n从末端 $i$ 的捕获起始是一个无记忆事件（泊松过程），仅当马达附着时以速率 $c_i$ 发生。当马达脱离时，捕获速率为 $0$。问题要求计算一端赢得捕获“竞赛”的概率。使用“独立泊松过程的叠加和竞争”的提示引导我们将每个末端复杂的捕获过程近似为一个更简单的有效泊松过程。\n\n末端 $i$ 的有效捕获速率，记为 $R_i$，是时间平均速率。这是在马达附着条件下的捕获速率 $c_i$ 乘以马达附着的概率 $\\pi_{i,1}$：\n$$ R_i = c_i \\pi_{i,1} = c_i \\frac{k_{\\mathrm{on},i}}{k_{\\mathrm{on},i} + k_{\\mathrm{off},i}} $$\n这种近似将附着马达的波动可用性视为对捕获速率的调制，当对时间进行平均时，会得到一个恒定的有效速率。\n\n整体捕获是两个独立过程之间的竞争：以有效速率 $R_3$ 在 $3'$ 末端捕获和以有效速率 $R_5$ 在 $5'$ 末端捕获。对于两个独立的竞争泊松过程，某个特定过程首先发生的概率是其速率与所有速率之和的比值。\n因此，首次捕获事件发生在 $3'$ 末端的概率 $P_{3'}$ 是：\n$$ P_{3'} = \\frac{R_3}{R_3 + R_5} $$\n代入 $R_3$ 和 $R_5$ 的表达式：\n$$ P_{3'} = \\frac{c_3 \\frac{k_{\\mathrm{on},3}}{k_{\\mathrm{on},3} + k_{\\mathrm{off},3}}}{c_3 \\frac{k_{\\mathrm{on},3}}{k_{\\mathrm{on},3} + k_{\\mathrm{off},3}} + c_5 \\frac{k_{\\mathrm{on},5}}{k_{\\mathrm{on},5} + k_{\\mathrm{off},5}}} $$\n\n现在，我们将给定的数值代入这个表达式。\n$3'$ 末端的参数是 $k_{\\mathrm{on},3} = 2.4\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{off},3} = 0.6\\,\\mathrm{s}^{-1}$ 和 $c_3 = 4.0\\,\\mathrm{s}^{-1}$。\n$3'$ 末端的有效速率是：\n$$ R_3 = (4.0\\,\\mathrm{s}^{-1}) \\times \\frac{2.4\\,\\mathrm{s}^{-1}}{2.4\\,\\mathrm{s}^{-1} + 0.6\\,\\mathrm{s}^{-1}} = (4.0) \\times \\frac{2.4}{3.0} = 4.0 \\times 0.8 = 3.2\\,\\mathrm{s}^{-1} $$\n\n$5'$ 末端的参数是 $k_{\\mathrm{on},5} = 1.2\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{off},5} = 1.4\\,\\mathrm{s}^{-1}$ 和 $c_5 = 3.0\\,\\mathrm{s}^{-1}$。\n$5'$ 末端的有效速率是：\n$$ R_5 = (3.0\\,\\mathrm{s}^{-1}) \\times \\frac{1.2\\,\\mathrm{s}^{-1}}{1.2\\,\\mathrm{s}^{-1} + 1.4\\,\\mathrm{s}^{-1}} = (3.0) \\times \\frac{1.2}{2.6} = 3.0 \\times \\frac{6}{13} = \\frac{18}{13}\\,\\mathrm{s}^{-1} $$\n\n现在，我们计算概率 $P_{3'}$：\n$$ P_{3'} = \\frac{R_3}{R_3 + R_5} = \\frac{3.2}{3.2 + \\frac{18}{13}} $$\n为了计算这个，我们可以使用分数：$3.2 = \\frac{32}{10} = \\frac{16}{5}$。\n$$ P_{3'} = \\frac{\\frac{16}{5}}{\\frac{16}{5} + \\frac{18}{13}} = \\frac{\\frac{16}{5}}{\\frac{16 \\times 13 + 18 \\times 5}{5 \\times 13}} = \\frac{16 \\times 13}{16 \\times 13 + 18 \\times 5} $$\n$$ P_{3'} = \\frac{208}{208 + 90} = \\frac{208}{298} = \\frac{104}{149} $$\n作为小数，这是：\n$$ P_{3'} \\approx 0.697986577... $$\n四舍五入到四位有效数字，我们得到 $0.6980$。", "answer": "$$ \\boxed{0.6980} $$", "id": "5138871"}, {"introduction": "单次纳米孔读取本身存在一定的错误率，为了达到临床诊断等应用所需的高精度，必须整合来自多个读数的信息。通过对同一DNA区域进行多次测序（即达到一定的“测序深度”），然后生成一条共有序列（consensus sequence），我们可以显著提高准确性。随着测序深度的增加，共有序列中出现错误的概率会急剧下降，这一关系可以通过二项分布进行精确建模。这项练习 [@problem_id:5138841] 让你能够量化测序深度与共有序列准确性之间的关系，并计算达到行业标准质量（如$Q30$）所需的最小测序深度。这揭示了通过增加数据量来抑制随机错误、从而获得高置信度结果的核心统计学原理。", "problem": "一家分子与免疫诊断实验室使用纳米孔单链测序技术，通过整合独立的单链读数来组装逐碱基共有序列，以检测临床相关位点上的单核苷酸变异。假设覆盖特定碱基的每个独立读数都具有相同且独立的碱基识别性能：它有概率 $a$ 报告正确的碱基，有概率 $1-a$ 报告某个错误的碱基。为抑制错误模式异质性带来的偏差，假设错误在三个错误碱基之间是对称的。该实验室通过对 $N$ 次碱基识别结果进行多数投票，来构建覆盖深度为 $N$（为避免平局，N为奇数）的共有碱基。共有序列识别的 Phred 质量分数 (PQS) 定义为：如果共有序列错误的概率为 $e$，那么共有序列质量为 $Q=-10\\log_{10}(e)$。\n\n从独立性、二项分布和 Phred 质量分数的定义出发，推导共有序列准确度 $A(N)$ 作为覆盖深度 $N$ 和单次读取正确率 $a$ 的函数的解析表达式。然后，在 $a=0.95$ 的特殊情况下，确定使共有序列 Phred 质量至少为 $Q=30$（即共有序列错误概率 $e$ 不大于 $10^{-3}$）所需的最小奇数覆盖深度 $N$。将最小奇数 $N$ 作为你的最终答案。无需四舍五入。", "solution": "该问题经验证具有科学依据、提法明确且客观。它是将二项概率应用于基因测序共有序列简化模型的一个标准应用，这是生物信息学和诊断学中的一个核心概念。所有提供的信息都是自洽的，足以得到唯一解。\n\n设 $a$ 为单个独立读数正确识别一个碱基的概率。那么错误碱基识别的概率为 $1-a$。覆盖深度 $N$ 是覆盖该碱基的独立读数的数量，且已知 $N$ 为一个奇数。\n\n共有序列识别是通过多数投票形成的。设 $k$ 为 $N$ 个总读数中正确识别出真实碱基的读数数量。这 $N$ 次读取是独立的伯努利试验，因此正确读数的数量 $k$ 服从二项分布：\n$$P(k; N, a) = \\binom{N}{k} a^k (1-a)^{N-k}$$\n为使共有序列识别正确，真实碱基的识别次数必须多于任何其他碱基。问题陈述中提到错误是对称的，意味着 $1-a$ 的错误概率均等地分布在其他三个可能的碱基上。如果正确读数的数量 $k$ 大于总读数的一半 $N/2$，那么错误读数的数量 $N-k$ 必定小于 $N/2$。由于这 $N-k$ 个读数分布在三个错误的碱基中，任何一个错误碱基得到的票数都不可能多于 $k$。因此，共有序列识别正确的条件是正确读数的数量 $k$ 构成多数。\n\n由于 $N$ 是奇数，当 $k > N/2$ 时即构成多数。满足此条件的最小整数 $k$ 是 $k = (N+1)/2$。如果 $k$ 是从 $(N+1)/2$ 到 $N$ 的任意整数，则共有序列是正确的。\n\n共有序列准确度 $A(N)$ 是共有序列识别正确的概率。这是所有导致正确共有序列的 $k$ 值的概率之和：\n$$A(N) = P\\left(k \\ge \\frac{N+1}{2}\\right) = \\sum_{k=(N+1)/2}^{N} P(k; N, a)$$\n代入二项概率质量函数，我们得到共有序列准确度作为 $N$ 和 $a$ 函数的解析表达式：\n$$A(N) = \\sum_{k=(N+1)/2}^{N} \\binom{N}{k} a^k (1-a)^{N-k}$$\n这是所要求推导的第一部分。\n\n共有序列错误概率 $e$ 是准确度的补集：$e(N) = 1 - A(N)$。这对应于正确读数数量占少数的情况，即 $k  (N+1)/2$。由于 $k$ 是整数，这等价于 $k \\le (N-1)/2$。\n$$e(N) = P\\left(k \\le \\frac{N-1}{2}\\right) = \\sum_{k=0}^{(N-1)/2} \\binom{N}{k} a^k (1-a)^{N-k}$$\nPhred 质量分数 $Q$ 定义为 $Q = -10\\log_{10}(e)$。问题要求在单次读取准确度 $a=0.95$ 的情况下，找到使 $Q \\ge 30$ 的最小奇数 $N$。\n条件 $Q \\ge 30$ 转化为：\n$$-10\\log_{10}(e) \\ge 30$$\n$$\\log_{10}(e) \\le -3$$\n$$e \\le 10^{-3}$$\n在给定 $a=0.95$ 和 $1-a=0.05$ 的条件下，我们需要找到使 $e(N) \\le 0.001$ 的最小奇数 $N$。我们将逐个测试连续的奇数 $N$ 值。\n\n对于 $N=1$：\n错误条件是 $k \\le (1-1)/2 = 0$，即 $k=0$。\n$e(1) = \\binom{1}{0} a^0 (1-a)^1 = 1-a = 0.05$。\n$0.05 > 0.001$，因此 $N=1$ 不足。\n\n对于 $N=3$：\n错误条件是 $k \\le (3-1)/2 = 1$，即 $k=0$ 或 $k=1$。\n$e(3) = \\sum_{k=0}^{1} \\binom{3}{k} a^k (1-a)^{3-k} = \\binom{3}{0}a^0(1-a)^3 + \\binom{3}{1}a^1(1-a)^2$\n$e(3) = (1-a)^3 + 3a(1-a)^2 = (0.05)^3 + 3(0.95)(0.05)^2$\n$e(3) = 0.000125 + 3(0.95)(0.0025) = 0.000125 + 0.007125 = 0.00725$。\n$0.00725 > 0.001$，因此 $N=3$ 不足。\n\n对于 $N=5$：\n错误条件是 $k \\le (5-1)/2 = 2$，即 $k=0, 1, 2$。\n$e(5) = \\sum_{k=0}^{2} \\binom{5}{k} a^k (1-a)^{5-k} = \\binom{5}{0}(1-a)^5 + \\binom{5}{1}a(1-a)^4 + \\binom{5}{2}a^2(1-a)^3$\n$e(5) = (0.05)^5 + 5(0.95)(0.05)^4 + 10(0.95)^2(0.05)^3$\n$e(5) = 3.125 \\times 10^{-7} + 5(0.95)(6.25 \\times 10^{-6}) + 10(0.9025)(1.25 \\times 10^{-4})$\n$e(5) = 3.125 \\times 10^{-7} + 2.96875 \\times 10^{-5} + 1.128125 \\times 10^{-3}$\n$e(5) = 0.0000003125 + 0.0000296875 + 0.001128125 = 0.001158125$。\n$0.001158125 > 0.001$，因此 $N=5$ 不足。\n\n对于 $N=7$：\n错误条件是 $k \\le (7-1)/2 = 3$，即 $k=0, 1, 2, 3$。\n$e(7) = \\sum_{k=0}^{3} \\binom{7}{k} a^k (1-a)^{7-k}$\n$e(7) = \\binom{7}{0}(1-a)^7 + \\binom{7}{1}a(1-a)^6 + \\binom{7}{2}a^2(1-a)^5 + \\binom{7}{3}a^3(1-a)^4$\n$e(7) = (0.05)^7 + 7(0.95)(0.05)^6 + 21(0.95)^2(0.05)^5 + 35(0.95)^3(0.05)^4$\n$e(7) = (7.8125 \\times 10^{-10}) + 7(0.95)(1.5625 \\times 10^{-8}) + 21(0.9025)(3.125 \\times 10^{-7}) + 35(0.857375)(6.25 \\times 10^{-6})$\n$e(7) = 7.8125 \\times 10^{-10} + 1.0390625 \\times 10^{-7} + 5.9228515625 \\times 10^{-6} + 1.8754296875 \\times 10^{-4}$\n$e(7) = 0.00000000078125 + 0.00000010390625 + 0.0000059228515625 + 0.00018754296875$\n$e(7) \\approx 1.9357 \\times 10^{-4}$。\n$1.9357 \\times 10^{-4} = 0.00019357$，小于 $0.001$。\n因此，$N=7$ 足以达到所需的质量分数。\n\n由于覆盖深度 $N=5$ 不足而 $N=7$ 足够，因此所需的最小奇数覆盖深度为 $N=7$。", "answer": "$$\\boxed{7}$$", "id": "5138906"}, {"introduction": "DNA链被捕获并通过纳米孔后，会产生原始且充满噪声的离子电流信号。碱基识别（basecalling）的核心挑战在于将这个模拟信号准确地翻译成离散的碱基序列。这个问题通常被构建为一个隐马尔可夫模型（Hidden Markov Model, HMM）的解码问题，其中真实的DNA序列是隐藏状态，而离子电流读数是观测到的发射信号。这项练习 [@problem_id:5138906] 要求你实现维特比（Viterbi）算法，这是一种用于从噪声观测中推断最可能隐藏状态序列的动态规划方法。通过解决这个问题，你将掌握纳米孔数据分析的核心，即如何从原始电流信号中提取序列信息。", "problem": "给定一个纳米孔链测序读数的简化模型，其中离子电流被建模为一个隐马尔可夫模型（HMM），隐藏状态代表链的离散步进状态（例如，短的核苷酸上下文），发射是每个步进的带噪声的平均离子电流测量值。物理背景是一个用于分子和免疫诊断的纳米孔系统，其中以皮安（pA）为单位测量的离子电流水平是局部链构象的特征，并且链在马达蛋白的控制下以离散的步进方式前进。您必须基于高斯发射模型构建步进状态的似然，并实现一个维特比解码器，以从带噪声的平均电流轨迹中推断出最可能的步进状态序列。\n\n使用的基本基础和定义：\n- 隐马尔可夫模型（HMM）：一个具有隐藏状态和观测发射的随机模型。设时间索引 $t$ 处的隐藏状态为 $s_t \\in \\{0,1,\\dots,M-1\\}$，状态转移概率为 $A_{ij} = \\mathbb{P}(s_t = j \\mid s_{t-1} = i)$，初始分布为 $\\pi_j = \\mathbb{P}(s_0 = j)$。\n- 发射模型：对于每个状态 $j$，每步的平均离子电流 $\\bar{I}_t$ 被建模为一个高斯（正态）随机变量，其均值为 $\\mu_j$，方差为 $\\sigma^2/K$，即 $\\bar{I}_t \\sim \\mathcal{N}(\\mu_j, \\sigma^2/K)$，其中 $\\sigma$ 是每样本标准差，$K$ 是每步平均的样本数。似然为\n$$\np(\\bar{I}_t \\mid s_t=j) = \\frac{1}{\\sqrt{2\\pi \\sigma^2/K}}\\exp\\left(-\\frac{(\\bar{I}_t - \\mu_j)^2}{2\\sigma^2/K}\\right).\n$$\n- 通过维特比算法进行最大后验解码：通过在对数域中使用自然对数进行动态规划，计算给定观测值 $\\bar{I}_0,\\bar{I}_1,\\dots,\\bar{I}_{T-1}$ 的最可能状态路径 $s_0,s_1,\\dots,s_{T-1}$。\n\n您的任务：\n1. 对于每个测试用例，使用上述高斯模型构建发射对数似然 $\\log p(\\bar{I}_t \\mid s_t=j)$，方差为 $\\sigma^2/K$。然后实现维特比动态规划递推公式：\n$$\n\\delta_t(j) = \\max_i \\left[\\delta_{t-1}(i) + \\log A_{ij}\\right] + \\log p(\\bar{I}_t \\mid s_t=j),\n$$\n初始化为\n$$\n\\delta_0(j) = \\log \\pi_j + \\log p(\\bar{I}_0 \\mid s_0=j),\n$$\n并维护回溯指针以重构最大化路径。所有对数运算均使用自然对数。\n2. 独立地为每个测试用例解码最可能的状态序列。\n3. 将最终解码的序列表示为整数列表（状态索引），输出中不含物理单位。下面提到的所有物理单位仅用于模型规范；输出是无单位的。\n4. 您的程序应产生单行输出，其中包含所有测试用例的解码序列，作为一个用方括号括起来的逗号分隔列表，其中每个解码序列表示为一个整数列表，例如 `[[0,1,2],[1,1,0]]`。\n\n测试套件：\n- 测试用例 1（通用的“理想情况”）：\n  - 状态数：$M = 4$。\n  - 状态均值（皮安）：$\\mu = [64.8, 67.6, 62.9, 70.5]$。\n  - 每样本标准差（皮安）：$\\sigma = 2.0$。\n  - 每步样本数：$K = 5$。\n  - 转移矩阵：\n    $$\n    A = \\begin{bmatrix}\n    0.70  0.25  0.03  0.02 \\\\\n    0.15  0.70  0.13  0.02 \\\\\n    0.02  0.15  0.70  0.13 \\\\\n    0.02  0.03  0.25  0.70\n    \\end{bmatrix}.\n    $$\n  - 初始分布：$\\pi = [0.25, 0.25, 0.25, 0.25]$。\n  - 步数：$T = 8$。\n  - 平均观测值（皮安）：$\\bar{I} = [65.1, 67.3, 67.8, 62.2, 70.3, 69.8, 63.1, 66.9]$。\n\n- 测试用例 2（重叠的状态均值，有挑战性的发射）：\n  - 状态数：$M = 3$。\n  - 状态均值（皮安）：$\\mu = [66.0, 66.6, 66.9]$。\n  - 每样本标准差（皮安）：$\\sigma = 1.2$。\n  - 每步样本数：$K = 10$。\n  - 转移矩阵：\n    $$\n    A = \\begin{bmatrix}\n    0.60  0.35  0.05 \\\\\n    0.20  0.60  0.20 \\\\\n    0.05  0.35  0.60\n    \\end{bmatrix}.\n    $$\n  - 初始分布：$\\pi = [\\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{3}]$。\n  - 步数：$T = 6$。\n  - 平均观测值（皮安）：$\\bar{I} = [65.8, 66.9, 66.6, 66.5, 66.7, 66.1]$。\n\n- 测试用例 3（边界和短序列）：\n  - 状态数：$M = 2$。\n  - 状态均值（皮安）：$\\mu = [63.0, 69.0]$。\n  - 每样本标准差（皮安）：$\\sigma = 3.0$。\n  - 每步样本数：$K = 2$。\n  - 转移矩阵：\n    $$\n    A = \\begin{bmatrix}\n    0.80  0.20 \\\\\n    0.20  0.80\n    \\end{bmatrix}.\n    $$\n  - 初始分布：$\\pi = [0.5, 0.5]$。\n  - 步数：$T = 1$。\n  - 平均观测值（皮安）：$\\bar{I} = [68.2]$。\n\n角度单位不适用。百分比不出现在输出中。模型中使用的离子电流值以皮安（pA）为单位，但您的程序输出必须是无单位的解码状态索引序列。您的程序应产生单行输出，其中包含结果，格式为一个用方括号括起来的逗号分隔列表，例如 `[[0,1,2],[2,1,0],[1]]`。", "solution": "所提出的问题要求从一系列带噪声的观测中解码出最可能的隐藏状态序列，这是序列数据分析中的一个典型任务。该系统被建模为隐马尔可夫模型（HMM），这是一个非常适合描述纳米孔测序底层随机过程的框架，其中生物聚合物（如DNA）穿过纳米孔，产生一系列特征性的离子电流水平。维特比算法通过动态规划为这个解码问题提供了一个精确且计算高效的解决方案。\n\n解决方案首先形式化HMM的组件，然后在数值稳定的对数域中实现维特比算法。\n\n一个隐马尔可夫模型由一组参数 $(\\mathcal{S}, \\mathcal{V}, A, B, \\pi)$ 定义，其中：\n- $\\mathcal{S} = \\{0, 1, \\dots, M-1\\}$ 是 $M$ 个隐藏状态的有限集合，代表局部的链构象。\n- $\\mathcal{V}$ 是可能观测的集合。在此问题中，观测是连续的，代表平均离子电流 $\\bar{I}_t \\in \\mathbb{R}$。\n- $A$ 是状态转移概率矩阵，其中 $A_{ij} = \\mathbb{P}(s_t = j \\mid s_{t-1} = i)$ 是从状态 $i$ 转移到状态 $j$ 的概率。\n- $B$ 代表发射概率，$p(\\bar{I}_t \\mid s_t=j)$，即在系统处于状态 $j$ 时观测到电流 $\\bar{I}_t$ 的概率。\n- $\\pi$ 是初始状态分布，其中 $\\pi_j = \\mathbb{P}(s_0 = j)$。\n\n问题为时间步 $t$ 的平均离子电流 $\\bar{I}_t$ 指定了一个高斯发射模型。给定隐藏状态为 $s_t=j$，观测值 $\\bar{I}_t$ 从一个正态分布 $\\mathcal{N}(\\mu_j, \\sigma_{avg}^2)$ 中抽取，其中 $\\mu_j$ 是状态 $j$ 的平均电流，$\\sigma_{avg}^2 = \\sigma^2/K$ 是平均测量的方差。这里，$\\sigma$ 是每样本标准差，$K$ 是每步平均的样本数。\n\n给定状态 $j$ 时观测值 $\\bar{I}_t$ 的概率密度函数为：\n$$\np(\\bar{I}_t \\mid s_t=j) = \\frac{1}{\\sqrt{2\\pi \\sigma^2/K}}\\exp\\left(-\\frac{(\\bar{I}_t - \\mu_j)^2}{2\\sigma^2/K}\\right)\n$$\n对于长序列，直接将这些概率相乘可能导致数值下溢。因此，所有计算都在自然对数域中进行。一个发射的对数似然是：\n$$\n\\log p(\\bar{I}_t \\mid s_t=j) = -\\frac{1}{2}\\log(2\\pi \\sigma^2/K) - \\frac{(\\bar{I}_t - \\mu_j)^2}{2\\sigma^2/K}\n$$\n这些对数似然是为每个时间步 $t \\in \\{0, \\dots, T-1\\}$ 和每个状态 $j \\in \\{0, \\dots, M-1\\}$ 计算的。\n\n维特比算法通过最大化状态序列和观测的联合对数概率来找到最优状态序列 $S^* = (s_0^*, s_1^*, \\dots, s_{T-1}^*)$。这是通过动态规划实现的。我们定义两个表：\n$1$. $\\delta_t(j)$: 任何长度为 $t+1$、结束于状态 $j$ 且生成观测 $\\bar{I}_0, \\dots, \\bar{I}_t$ 的路径的最大对数概率。\n$2$. $\\psi_t(j)$: 一个回溯指针表，用于存储在时间 $t-1$ 处最大化到达时间 $t$ 状态 $j$ 概率的状态。\n\n该算法分三个阶段进行：\n\n**$1$. 初始化 ($t=0$):**\n对于每个状态 $j \\in \\{0, \\dots, M-1\\}$，初始对数概率是初始概率的对数与第一个观测 $\\bar{I}_0$ 的发射对数概率之和。\n$$\n\\delta_0(j) = \\log \\pi_j + \\log p(\\bar{I}_0 \\mid s_0=j)\n$$\n\n**$2$. 递推 ($t=1, \\dots, T-1$):**\n对于每个后续时间步 $t$，我们从时间 $t-1$ 扩展最优路径。对于每个状态 $j$，我们找到前一个状态 $i$，它最大化了转移到 $j$ 并生成观测 $\\bar{I}_t$ 的概率。\n$$\n\\delta_t(j) = \\max_{i \\in \\{0, \\dots, M-1\\}} \\left[ \\delta_{t-1}(i) + \\log A_{ij} \\right] + \\log p(\\bar{I}_t \\mid s_t=j)\n$$\n在时间 $t$ 状态 $j$ 的回溯指针存储了这个最大化的前一个状态 $i$ 的索引：\n$$\n\\psi_t(j) = \\arg\\max_{i \\in \\{0, \\dots, M-1\\}} \\left[ \\delta_{t-1}(i) + \\log A_{ij} \\right]\n$$\n\n**$3$. 终止和路径重构:**\n在计算完所有状态 $j$ 的 $\\delta_{T-1}(j)$ 后，最可能的最终状态是具有最高对数概率的那个：\n$$\ns^*_{T-1} = \\arg\\max_{j \\in \\{0, \\dots, M-1\\}} \\delta_{T-1}(j)\n$$\n最可能路径的其余部分通过使用存储的回溯指针从这个最终状态回溯找到：\n$$\ns^*_{t-1} = \\psi_t(s^*_t) \\quad \\text{for } t = T-1, \\dots, 1\n$$\n这个过程产生完整的最佳状态序列 $S^*=(s_0^*, s_1^*, \\dots, s_{T-1}^*)$，这是给定测试用例的解。实现将使用此算法独立处理问题陈述中提供的每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef viterbi_decode(M, mu, sigma, K, A, pi, T, I_bar):\n    \"\"\"\n    Decodes the most probable sequence of hidden states in an HMM using the Viterbi algorithm.\n    All calculations are performed in the log domain for numerical stability.\n\n    Args:\n        M (int): Number of hidden states.\n        mu (list or np.ndarray): Mean ionic current for each state.\n        sigma (float): Per-sample standard deviation of the ionic current.\n        K (int): Number of samples averaged per step.\n        A (list of lists or np.ndarray): State transition probability matrix.\n        pi (list or np.ndarray): Initial state probability distribution.\n        T (int): Number of observations (time steps).\n        I_bar (list or np.ndarray): Sequence of averaged ionic current observations.\n\n    Returns:\n        list: The most probable sequence of state indices.\n    \"\"\"\n    num_states = M\n    num_observations = T\n\n    # Convert inputs to numpy arrays for vectorized operations\n    mu = np.array(mu)\n    # Ensure A and pi are numpy arrays for log operations\n    A = np.array(A)\n    pi = np.array(pi)\n    I_bar = np.array(I_bar)\n\n    # 1. Preparation: Compute log probabilities\n    # Use np.errstate to suppress warnings for log(0), which is correctly handled as -np.inf\n    with np.errstate(divide='ignore'):\n        log_A = np.log(A)\n        log_pi = np.log(pi)\n\n    # Compute emission log-likelihoods for all observations and states.\n    # The matrix emission_log_lik will have shape (T, M), where B[t, j] = log p(I_bar[t] | s_t = j).\n    var_avg = (sigma**2) / K\n    std_avg = np.sqrt(var_avg)\n    \n    emission_log_lik = np.zeros((num_observations, num_states))\n    for t in range(num_observations):\n        # norm.logpdf calculates the log probability density for I_bar[t] under\n        # a normal distribution for each state's mean mu[j] and the common scale std_avg.\n        emission_log_lik[t, :] = norm.logpdf(I_bar[t], loc=mu, scale=std_avg)\n\n    # 2. Dynamic Programming tables\n    # delta[t, j]: max log-prob of a path ending in state j at time t\n    delta = np.zeros((num_observations, num_states))\n    # psi[t, j]: backpointer to the previous state on the optimal path to j at t\n    psi = np.zeros((num_observations, num_states), dtype=int)\n\n    # 3. Initialization step (t=0)\n    delta[0, :] = log_pi + emission_log_lik[0, :]\n\n    # 4. Recursion step (t=1 to T-1)\n    if num_observations > 1:\n        for t in range(1, num_observations):\n            for j in range(num_states):\n                # For each current state j, find the best previous state i.\n                # The term inside the max is delta[t-1, i] + log_A[i, j].\n                temp_log_prob = delta[t-1, :] + log_A[:, j]\n                \n                # Find the maximum log probability and the corresponding state index\n                max_log_prob = np.max(temp_log_prob)\n                argmax_index = np.argmax(temp_log_prob)\n                \n                # Update the DP tables\n                delta[t, j] = max_log_prob + emission_log_lik[t, j]\n                psi[t, j] = argmax_index\n\n    # 5. Termination and Path Reconstruction (Backtracking)\n    path = np.zeros(num_observations, dtype=int)\n    \n    # Find the most probable final state\n    path[num_observations - 1] = np.argmax(delta[num_observations - 1, :])\n    \n    # Backtrack to find the rest of the optimal path\n    for t in range(num_observations - 2, -1, -1):\n        path[t] = psi[t + 1, path[t + 1]]\n\n    return path.tolist()\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        (\n            4, # M\n            [64.8, 67.6, 62.9, 70.5], # mu\n            2.0, # sigma\n            5, # K\n            [[0.70, 0.25, 0.03, 0.02],\n             [0.15, 0.70, 0.13, 0.02],\n             [0.02, 0.15, 0.70, 0.13],\n             [0.02, 0.03, 0.25, 0.70]], # A\n            [0.25, 0.25, 0.25, 0.25], # pi\n            8, # T\n            [65.1, 67.3, 67.8, 62.2, 70.3, 69.8, 63.1, 66.9] # I_bar\n        ),\n        # Test Case 2\n        (\n            3, # M\n            [66.0, 66.6, 66.9], # mu\n            1.2, # sigma\n            10, # K\n            [[0.60, 0.35, 0.05],\n             [0.20, 0.60, 0.20],\n             [0.05, 0.35, 0.60]], # A\n            [1/3, 1/3, 1/3], # pi\n            6, # T\n            [65.8, 66.9, 66.6, 66.5, 66.7, 66.1] # I_bar\n        ),\n        # Test Case 3\n        (\n            2, # M\n            [63.0, 69.0], # mu\n            3.0, # sigma\n            2, # K\n            [[0.80, 0.20],\n             [0.20, 0.80]], # A\n            [0.5, 0.5], # pi\n            1, # T\n            [68.2] # I_bar\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        M, mu, sigma, K, A, pi, T, I_bar = case\n        decoded_path = viterbi_decode(M, mu, sigma, K, A, pi, T, I_bar)\n        results.append(decoded_path)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists contains spaces.\n    # The required format is compact, without spaces.\n    print(str(results).replace(' ', ''))\n\nsolve()\n\n```", "id": "5138841"}]}