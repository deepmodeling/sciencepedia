{"hands_on_practices": [{"introduction": "宏基因组鸟枪法测序本质上是一个随机抽样过程，因此，仅仅因为病原体存在于样本中，并不能保证我们一定能检测到其序列。这项练习从第一性原理出发，探讨了检测到零病原体读数的概率，帮助您深入理解测序深度、病原体相对丰度与假阴性风险之间的根本性数学关系。掌握这一概念对于设定可靠的临床报告阈值和解释阴性结果至关重要。[@problem_id:5131994]", "problem": "在用于病原体发现的宏基因组鸟枪法测序中，假设测序读数是独立且均匀地从可测序的核酸分子库中抽取的。设样本中目标病原体的真实相对丰度为 $f$，定义为任何单个读数来源于该病原体的概率；设测序深度为 $D$，定义为产生的总读数数量。在这些条件下，定义随机变量 $X$ 为观测到的源自病原体的读数数量。\n\n从伯努利抽样和独立性的第一性原理出发，推导观测到零个病原体读数的概率。然后，使用给定值 $f = 10^{-6}$ 和 $D = 10^{8}$ 计算此概率。如果参数合理，您可以使用适当的渐近近似，但必须清晰阐述其理由。将最终的数值概率四舍五入至 $3$ 位有效数字，并以小数形式表示。\n\n最后，简要讨论您的结果对宏基因组下一代测序（NGS）临床报告阈值的影响，例如当实验室要求至少 $k$ 个读数才能报告阳性时。您的讨论应围绕抽样方差及其在所述假设下对假阴性贡献的方面展开，不要引用任何未提供的快捷公式或经验法则。", "solution": "问题陈述已经过验证，被确定为是合理的、适定的和有科学依据的。\n\n该问题要求推导和计算在宏基因组鸟枪法测序实验中观测到零个病原体读数的概率，并讨论其结果的意义。\n\n核心假设是测序读数是独立且均匀地从核酸分子库中抽取的。这个过程可以被建模为一系列伯努利试验。\n\n设 $D$ 为测序读数的总数（测序深度），对应于试验次数。设 $f$ 为病原体的真实相对丰度，即任何单个读数来源于该病原体的概率。这对应于单次伯努利试验中“成功”的概率。\n\n随机变量 $X$ 表示在 $D$ 次试验中观测到的源自病原体的读数总数。由于试验是独立的，且每次试验的成功概率 $f$ 是恒定的，所以 $X$ 服从二项分布，记为 $X \\sim B(D, f)$。\n\n二项分布的概率质量函数（PMF）给出了在 $n$ 次试验中观测到恰好 $k$ 次成功的概率：\n$$P(X=k) = \\binom{n}{k} p^k (1-p)^{n-k}$$\n在我们的情境中，$n=D$，$p=f$，我们关心的是 $k=0$ 的情况。将这些值代入PMF，我们推导出观测到零个病原体读数的概率：\n$$P(X=0) = \\binom{D}{0} f^0 (1-f)^{D-0}$$\n根据定义，$\\binom{D}{0} = 1$ 且 $f^0 = 1$。因此，确切的概率是：\n$$P(X=0) = (1-f)^D$$\n\n现在，我们需要用给定的值 $f = 10^{-6}$ 和 $D = 10^{8}$ 来计算这个概率。\n直接计算 $(1 - 10^{-6})^{10^{8}}$ 在计算上很繁琐。问题允许在有理由的情况下使用渐近近似。二项分布的泊松近似条件是试验次数 $D$ 非常大，且成功概率 $f$ 非常小。在我们的例子中，$D = 10^8$ 确实非常大，而 $f = 10^{-6}$ 非常小。因此，使用泊松近似是完全合理的。\n\n二项分布 $B(D, f)$ 可以用参数为 $\\lambda$ 的泊松分布来近似，其中 $\\lambda$ 是期望的成功次数。\n$$\\lambda = E[X] = Df$$\n让我们用给定的值计算 $\\lambda$：\n$$\\lambda = (10^8) \\times (10^{-6}) = 10^{2} = 100$$\n泊松分布的PMF是：\n$$P(X=k) \\approx \\frac{\\lambda^k \\exp(-\\lambda)}{k!}$$\n我们想求观测到零个读数的概率，即 $k=0$。\n$$P(X=0) \\approx \\frac{\\lambda^0 \\exp(-\\lambda)}{0!}$$\n因为 $\\lambda^0 = 1$ 且 $0! = 1$，这可以简化为：\n$$P(X=0) \\approx \\exp(-\\lambda) = \\exp(-Df)$$\n这个近似源于众所周知的指数函数的极限定义：\n$$P(X=0) = (1-f)^D = \\left(1 - \\frac{Df}{D}\\right)^D = \\left(1 - \\frac{\\lambda}{D}\\right)^D$$\n对于大的 $D$，这个表达式收敛于 $\\exp(-\\lambda)$。\n\n现在，我们计算数值：\n$$P(X=0) \\approx \\exp(-100)$$\n计算此值并四舍五入到 $3$ 位有效数字：\n$$\\exp(-100) \\approx 3.7200759... \\times 10^{-44}$$\n四舍五入到 $3$ 位有效数字，概率是 $3.72 \\times 10^{-44}$。\n\n最后，关于其意义的讨论，结果 $P(X=0) \\approx 3.72 \\times 10^{-44}$ 是当病原体以相对丰度 $f = 10^{-6}$ 存在且测序深度为 $D = 10^8$ 时，出现假阴性（完全未能检测到病原体）的概率。病原体读数的期望数量是 $\\lambda = Df = 100$。\n\n$P(X=0)$ 不为零的事实，尽管在这种情况下其值极小，揭示了一个基本原理：测序的随机性引入了抽样方差。即使病原体存在且期望读数数量很高（100），由于偶然性，观测到零个读数的概率仍然是有限的。\n\n如果一个临床实验室设定了一个报告阈值，要求至少有 $k$ 个读数才能报告阳性（例如，$k=3$），那么当观测到的读数数量 $X$ 小于 $k$ 时，就会发生假阴性。此事件的概率 $P(X  k)$ 是概率 $P(X=0), P(X=1), \\dots, P(X=k-1)$ 的总和。我们计算出的值 $P(X=0)$ 代表了对于任何阈值 $k \\ge 1$ 的绝对最小假阴性率。\n\n虽然对于给定的参数，假阴性率极低，但如果乘积 $\\lambda=Df$ 很小，情况就会发生巨大变化。例如，如果对相同的病原体丰度（$f=10^{-6}$）使用较低的测序深度（例如，$D=10^6$），期望读数数量将是 $\\lambda = 1$。那么观测到零个读数的概率将是 $P(X=0) \\approx \\exp(-1) \\approx 0.368$。在这种情况下，将有 $36.8\\%$ 的机会完全错过该病原体，这是一个临床上不可接受的假阴性率。\n\n这表明抽样方差是宏基因组诊断中假阴性的一个关键因素。可靠检测病原体的能力并不仅仅由其存在所保证；它受制于观测读数的概率分布，而该分布又从根本上取决于病原体丰度（$f$）和测序深度（$D$）之间的相互作用。设定报告阈值 $k$ 必须与假阴性的风险相平衡，而这个风险在数学上是由参数 $\\lambda=Df$ 决定的。", "answer": "$$\\boxed{3.72 \\times 10^{-44}}$$", "id": "5131994"}, {"introduction": "在临床诊断中，仅仅检测到病原体的存在往往不够，量化其载量（例如，每毫升样本中的拷贝数）对于评估感染严重程度和监测治疗反应至关重要。本练习将指导您如何使用内部“加标”（spike-in）对照，将相对的测序读数计数转化为绝对的病原体浓度。通过从头推导公式，您将不仅学会计算方法，更将深刻理解该技术背后关键的假设和潜在的偏差来源。[@problem_id:5132005]", "problem": "一份脑脊液样本通过宏基因组鸟枪法测序进行病原体发现分析。在裂解前立即添加一种合成的双链DNA内参（spike-in control），以实现绝对定量。您可以假设以下基本原理：在鸟枪法文库制备和测序过程中，片段是从输入的核酸分子池中无放回抽样的；在均匀且无偏的抽样条件下，分配给任何来源的测序读段（reads）的期望数量与该来源贡献的总输入核苷酸数量成正比；对于单倍体生物，该来源贡献的总核苷酸等于基因组拷贝数乘以单倍体基因组长度。内部对照绝对定量使用内参来校准未知量。\n\n实验得出以下测量和已知量：\n- 处理的输入样本体积：$V_{\\text{in}} = 1.00 \\ \\mathrm{mL}$。\n- 裂解时添加的内参分子：$N_{\\text{spike}} = 5.00 \\times 10^{7}$ 个基因组拷贝，为长度 $L_{\\text{spike}} = 3.000 \\times 10^{3} \\ \\mathrm{bp}$ 的线性化质粒。\n- 测序配置：整个测序过程采用等长的双末端读段（paired-end reads）；在进行物种分类分配之前，已去除重复和低质量的读段。\n- 通过竞争性比对分配的后处理读段计数：\n  - 人类：$2.70 \\times 10^{7}$ 个读段对。\n  - 内参：$6.00 \\times 10^{4}$ 个读段对。\n  - 单一目标细菌病原体（单倍体）：$4.00 \\times 10^{2}$ 个读段对。\n  - 所有其他分类单元的总和：对于本计算可忽略不计。\n- 检测到的细菌病原体的单倍体基因组长度为 $L_{\\text{path}} = 2.000 \\times 10^{6} \\ \\mathrm{bp}$。\n\n使用第一性原理，并仅根据上述基本原理，从头推导一个表达式来估算原始样本中每毫升的细菌病原体基因组拷贝数，并计算其值。您必须在推导过程中明确证明您引入的每个建模步骤的合理性。将最终数值答案四舍五入至三位有效数字。最终浓度以 拷贝/毫升 (copies/mL) 表示。\n\n除了计算之外，请简要说明在此情境下，为使内部标准校准有效所需的核心假设，并从概念层面解释其必要性。不要使用任何预先记忆的快捷公式；相反，仅根据所述的基本原理和定义来构建您的推理。您最终报告的答案必须是一个单一的实数。", "solution": "问题陈述已经过严格验证，被认为是自洽的、有科学依据且定义明确的。为得出唯一且有意义的解，所有必需的数据和基本原理均已提供。因此，我们可以进行推导和计算。\n\n本分析的核心基本原理是，分配给任何来源的测序读段的期望数量与该来源贡献的总输入核苷酸数量成正比。设 $C_i$ 表示分配给来源 $i$ 的测序读段对的数量，设 $T_i$ 为来源 $i$ 在测序前对初始核酸池贡献的总核苷酸数量。这种正比关系可以表示为：\n$$E[C_i] = k \\cdot T_i$$\n其中 $E[C_i]$ 是来源 $i$ 的读段计数的期望值，$k$ 是一个比例常数，它取决于总测序深度和其他系统性因素，但假定对于样本中所有DNA来源都是相同的。\n\n此原理应用于我们感兴趣的两个非宿主来源：细菌病原体（记为 'path'）和内部内参对照（记为 'spike'）。\n对于病原体：\n$$E[C_{\\text{path}}] = k \\cdot T_{\\text{path}}$$\n对于内参：\n$$E[C_{\\text{spike}}] = k \\cdot T_{\\text{spike}}$$\n通过将这两个方程相除，未知的比例常数 $k$ 被消去。这是内部校准的基本原理，因为它通过一个已知的内部参照物（内参）来归一化未知分析物（病原体）的测量。\n$$\\frac{E[C_{\\text{path}}]}{E[C_{\\text{spike}}]} = \\frac{k \\cdot T_{\\text{path}}}{k \\cdot T_{\\text{spike}}} = \\frac{T_{\\text{path}}}{T_{\\text{spike}}}$$\n在实际实验中，我们使用观测到的读段计数作为其期望值的估计值，$C_i \\approx E[C_i]$。对于足够大的读段计数，这种近似是合理的。\n$$\\frac{C_{\\text{path}}}{C_{\\text{spike}}} = \\frac{T_{\\text{path}}}{T_{\\text{spike}}}$$\n第二个基本原理指出，对于单倍体生物，总核苷酸数是基因组拷贝数与单倍体基因组长度的乘积。设 $N_i$ 为基因组拷贝数，$L_i$ 为来源 $i$ 的基因组长度（单位：碱基对 bp）。\n病原体的总核苷酸数为：\n$$T_{\\text{path}} = N_{\\text{path}} \\cdot L_{\\text{path}}$$\n内参的总核苷酸数为：\n$$T_{\\text{spike}} = N_{\\text{spike}} \\cdot L_{\\text{spike}}$$\n此处，$N_{\\text{path}}$ 代表存在于初始样本体积 $V_{\\text{in}}$ 中的病原体基因组总拷贝数。\n\n将这些表达式代回比例方程，得到：\n$$\\frac{C_{\\text{path}}}{C_{\\text{spike}}} = \\frac{N_{\\text{path}} \\cdot L_{\\text{path}}}{N_{\\text{spike}} \\cdot L_{\\text{spike}}}$$\n我们的目标是确定病原体的浓度，这首先需要求解病原体基因组的绝对拷贝数 $N_{\\text{path}}$。重排该方程：\n$$N_{\\text{path}} = N_{\\text{spike}} \\cdot \\frac{C_{\\text{path}}}{C_{\\text{spike}}} \\cdot \\frac{L_{\\text{spike}}}{L_{\\text{path}}}$$\n这个推导出的表达式允许我们通过将观测到的读段计数比率与已知的基因组长度比率关联起来，并以已知的内参对照量进行缩放，来计算处理样本体积中的病原体基因组数量。\n\n问题要求最终答案以每毫升的拷贝数浓度表示。设此浓度为 $\\rho_{\\text{path}}$。它被定义为病原体总拷贝数 $N_{\\text{path}}$ 除以输入样本体积 $V_{\\text{in}}$。\n$$\\rho_{\\text{path}} = \\frac{N_{\\text{path}}}{V_{\\text{in}}}$$\n代入 $N_{\\text{path}}$ 的表达式：\n$$\\rho_{\\text{path}} = \\frac{1}{V_{\\text{in}}} \\left( N_{\\text{spike}} \\cdot \\frac{C_{\\text{path}}}{C_{\\text{spike}}} \\cdot \\frac{L_{\\text{spike}}}{L_{\\text{path}}} \\right)$$\n现在我们将给定的数值代入此表达式。\n已知：\n- 输入体积：$V_{\\text{in}} = 1.00 \\ \\mathrm{mL}$\n- 内参拷贝数：$N_{\\text{spike}} = 5.00 \\times 10^{7}$ 拷贝\n- 内参读段对：$C_{\\text{spike}} = 6.00 \\times 10^{4}$\n- 病原体读段对：$C_{\\text{path}} = 4.00 \\times 10^{2}$\n- 内参长度：$L_{\\text{spike}} = 3.000 \\times 10^{3} \\ \\mathrm{bp}$\n- 病原体长度：$L_{\\text{path}} = 2.000 \\times 10^{6} \\ \\mathrm{bp}$\n\n计算：\n$$\\rho_{\\text{path}} = \\frac{1}{1.00 \\ \\mathrm{mL}} \\left( (5.00 \\times 10^{7}) \\cdot \\frac{4.00 \\times 10^{2}}{6.00 \\times 10^{4}} \\cdot \\frac{3.000 \\times 10^{3}}{2.000 \\times 10^{6}} \\right)$$\n$$\\rho_{\\text{path}} = \\left( 5.00 \\times 10^{7} \\right) \\cdot \\left( \\frac{4.00}{6.00} \\times 10^{2-4} \\right) \\cdot \\left( \\frac{3.000}{2.000} \\times 10^{3-6} \\right) \\ \\text{copies/mL}$$\n$$\\rho_{\\text{path}} = \\left( 5.00 \\times \\frac{2}{3} \\times 1.5 \\right) \\cdot \\left( 10^{7} \\times 10^{-2} \\times 10^{-3} \\right) \\ \\text{copies/mL}$$\n$$\\rho_{\\text{path}} = \\left( 5.00 \\times \\frac{2}{3} \\times \\frac{3}{2} \\right) \\cdot 10^{7-2-3} \\ \\text{copies/mL}$$\n$$\\rho_{\\text{path}} = 5.00 \\cdot 10^{2} \\ \\text{copies/mL}$$\n$$\\rho_{\\text{path}} = 500 \\ \\text{copies/mL}$$\n按要求四舍五入至三位有效数字，其值为 $5.00 \\times 10^2$。\n\n除了计算，我们还需确定使该内部标准校准有效所需的核心假设。\n\n1.  **从裂解开始等效的处理效率**：内参对照是一种合成的裸DNA分子，在样本裂解前添加。基本假设是，病原体的基因组DNA一旦从细胞中释放出来，其行为与内参DNA在所有后续工作流程步骤中都完全相同。这包括DNA提取/纯化、片段化、文库构建（末端修复、A尾添加、接头连接）和PCR扩增。至关重要的是，这要求裂解步骤本身是非偏向性的，并能有效地从病原体中释放核酸。如果病原体具有坚固的细胞壁，能抵抗所用的裂解方法，那么其DNA在初始池中将被低估，导致对其浓度的严重低估。该校准模型隐含地假设裂解效率为100%，或对所有生物体的效率相同，这是一个很强的假设。\n\n2.  **无偏的测序和比对**：该模型基于“均匀和无偏的抽样”。这假设来自病原体和内参的DNA片段被测序的概率相等，与其一级序列无关。诸如极端的GC含量（$(\\text{G}+\\text{C})/(\\text{A}+\\text{T}+\\mathrm{G}+\\text{C})$）等因素会在PCR扩增和测序过程中引入已知的偏好性。此外，生物信息学分析也必须是无偏的。用于竞争性比对的算法必须以同等的准确度和精密度将读段分配给其正确的来源，无论是对病原体序列还是内参序列。如果病原体序列更有可能因模糊或错误比对（例如，由于与人类基因组的同源性）而被丢弃，那么计数 $C_{\\text{path}}$ 将被人为地降低，再次导致对病原体载量的低估。\n\n3.  **对基因组长度的准确了解**：该计算明确依赖于基因组长度 $L_{\\text{path}}$ 和 $L_{\\text{spike}}$。该方法假设所使用的值是准确的。虽然内参的长度通过设计是精确已知的，但病原体的基因组长度是基于参考基因组的估计值。检测到的菌株与参考基因组之间在基因组大小上的显著差异可能会在定量中引入系统误差。此处的假设是，参考基因组的长度足以准确代表样本中病原体的实际基因组长度。", "answer": "$$\n\\boxed{5.00 \\times 10^{2}}\n$$", "id": "5132005"}, {"introduction": "将宏基因组测序产生的定量读数（read count）转化为一个明确的、非黑即白的临床诊断（“阳性”或“阴性”），需要一个经过优化的决策阈值。这项实践练习将引导您构建一个完整的决策模型，通过计算ROC曲线和最小化预期损失函数，来确定最佳的病原体检测阈值。这个过程完美地结合了统计建模、分类器性能评估和决策理论，是连接数据分析与临床应用的桥梁。[@problem_id:5132078]", "problem": "您的任务是编写一个完整、可运行的程序，用于在分子和免疫诊断学领域内，对宏基因组鸟枪法测序中的病原体存在性进行二元检测决策建模。设定如下：测序实验产生每个样本中病原体特异性读段的计数，该计数被建模为在两种条件下源于泊松过程。在背景条件（无病原体）下，该计数被建模为速率为 $\\lambda_0$ 的泊松随机变量。在病原体存在条件下，该计数被建模为速率为 $\\lambda_1$ 的泊松随机变量。速率 $\\lambda_0$ 和 $\\lambda_1$ 表示以百万读段数 (RPM) 为单位的期望计数，而观察到的计数是整数个读段。决策规则由一个整数阈值 $\\tau$ 参数化：当且仅当观察到的计数 $k$ 满足 $k \\ge \\tau$ 时，预测病原体存在。\n\n您的程序必须为每个测试用例计算受试者工作特征 (ROC) 曲线和曲线下面积 (AUC)，然后在一个指定的损失函数下优化阈值。ROC 曲线是当 $\\tau$ 在非负整数上变化时，假阳性率 (FPR) 和真阳性率 (TPR) 的参数图。AUC 是 ROC 曲线从 FPR $1$ 到 FPR $0$ 的积分，由离散的 ROC 点数值计算得出。阈值的优化需要最小化期望损失\n$$\nL(\\tau) = c_{\\text{FP}} \\cdot (1 - \\pi) \\cdot \\text{FPR}(\\tau) + c_{\\text{FN}} \\cdot \\pi \\cdot \\big(1 - \\text{TPR}(\\tau)\\big),\n$$\n其中 $\\pi$ 是患病率（样本含有病原体的先验概率），$c_{\\text{FP}}$ 是假阳性 (FP) 的成本，$c_{\\text{FN}}$ 是假阴性 (FN) 的成本。优化阈值 $\\tau^*$ 定义为任何达到最小期望损失的整数阈值。如果存在多个解，选择达到最小期望损失的最小 $\\tau$。\n\n您的推导应基于以下基础定义和广泛接受的事实，这些是出发点：\n- 在宏基因组鸟枪法测序中，唯一映射到病原体基因组的读段计数可以被建模为计数过程的结果。在固定的实验条件下，以恒定速率独立生成读段会产生计数的泊松模型，其概率质量函数为 $P(K = k \\mid \\lambda) = \\frac{e^{-\\lambda} \\lambda^k}{k!}$，其中整数 $k \\ge 0$ 且速率 $\\lambda > 0$。\n- 受试者工作特征 (ROC) 曲线关联了二元分类器在不同决策阈值下的 $\\text{TPR}$ 和 $\\text{FPR}$。曲线下面积 (AUC) 是一个标量性能摘要，对于完美分离等于 $1$，对于对称排序下无法区分的类别等于 $\\frac{1}{2}$。\n- 决策论风险最小化结合了先验概率和错分成本来选择最小化期望损失的阈值。\n\n您的程序必须为每个测试用例实现以下步骤：\n1. 通过在整数阈值 $\\tau \\in \\{0,1,2,\\dots, T_{\\max}\\}$ 上评估 $\\text{TPR}(\\tau)$ 和 $\\text{FPR}(\\tau)$ 来构建离散的 ROC 曲线，其中 $T_{\\max}$ 是一个足够大的整数，使得在 $T_{\\max}$ 及其之后两个分布的尾部在数值上都可以忽略不计。使用基于由 $\\lambda_0$ 和 $\\lambda_1$ 参数化的泊松分布的上分位数的原则性选择来确定 $T_{\\max}$。\n2. 使用一致的数值积分方法，根据离散的 ROC 点计算数值 AUC，确保 $\\text{AUC} \\in [0,1]$。\n3. 对于给定的患病率 $\\pi$ 和损失权重 $c_{\\text{FP}}$ 和 $c_{\\text{FN}}$，计算每个阈值的期望损失 $L(\\tau)$，并根据上述指定的决胜规则选择最优阈值 $\\tau^*$。\n4. 为每个测试用例报告元组 $[\\tau^*, \\text{AUC}, \\text{FPR}(\\tau^*), \\text{TPR}(\\tau^*), L(\\tau^*)]$，其中浮点数条目四舍五入到 $6$ 位小数，$\\tau^*$ 为整数。\n\n定义、单位和澄清：\n- 速率 $\\lambda_0$ 和 $\\lambda_1$ 是每百万总读段的期望读段计数，以百万读段数 (RPM) 表示，但阈值 $\\tau$ 和观察到的计数是以原始读段数（整数计数）为单位。\n- 假阳性率 (FPR) 是 $P(\\text{声明存在病原体} \\mid \\text{背景})$，真阳性率 (TPR) 是 $P(\\text{声明存在病原体} \\mid \\text{病原体存在})$。\n- 受试者工作特征 (ROC) 代表 Receiver Operating Characteristic (ROC)，曲线下面积 (AUC) 代表 Area Under the Curve (AUC)。\n- 假阳性 (FP) 和假阴性 (FN) 的定义如上文首次出现时所述。\n- 所有概率必须以小数表示，不带百分号。\n\n要实现的测试套件：\n- 情况 1：$\\lambda_0 = 0.5, \\lambda_1 = 5.0, \\pi = 0.05, c_{\\text{FP}} = 1.0, c_{\\text{FN}} = 10.0$。\n- 情况 2 (边界条件)：$\\lambda_0 = 2.0, \\lambda_1 = 2.0, \\pi = 0.5, c_{\\text{FP}} = 1.0, c_{\\text{FN}} = 1.0$。\n- 情况 3 (微弱信号)：$\\lambda_0 = 0.8, \\lambda_1 = 1.2, \\pi = 0.1, c_{\\text{FP}} = 1.0, c_{\\text{FN}} = 3.0$。\n- 情况 4 (高背景，中等分离度)：$\\lambda_0 = 10.0, \\lambda_1 = 20.0, \\pi = 0.2, c_{\\text{FP}} = 2.0, c_{\\text{FN}} = 1.0$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且每个元素本身是一个形式为 $[\\tau^*, \\text{AUC}, \\text{FPR}(\\tau^*), \\text{TPR}(\\tau^*), L(\\tau^*)]$ 的列表。例如：$[[1, 0.900000, 0.100000, 0.950000, 0.600000], [...]]$.", "solution": "用户提供的问题已经过评估，并被确定为有效。它具有科学依据、问题明确、客观且内部一致。因此，我们可以继续提供完整解答。\n\n该问题要求对基于测序读段计数的病原体检测二元分类任务进行决策论分析。问题的核心是对此过程进行建模，使用受试者工作特征 (ROC) 曲线和曲线下面积 (AUC) 评估分类器的性能，最后通过最小化指定的损失函数来选择一个最优决策阈值 $\\tau$。\n\n### 1. 检测问题的数学表述\n\n该问题围绕两个竞争性假设构建：\n-   $H_0$: 样本来自背景条件（无病原体）。观察到的读段计数 $K$ 是一个遵循速率为 $\\lambda_0$ 的泊松分布的随机变量。\n-   $H_1$: 样本含有病原体。观察到的读段计数 $K$ 是一个遵循速率为 $\\lambda_1$ 的泊松分布的随机变量。\n\n对于一个速率参数为 $\\lambda$ 的泊松分布随机变量 $K$，其概率质量函数 (PMF) 为：\n$$\nP(K=k \\mid \\lambda) = \\frac{e^{-\\lambda} \\lambda^k}{k!} \\quad \\text{对于 } k \\in \\{0, 1, 2, \\dots\\}\n$$\n决策规则基于一个整数阈值 $\\tau \\ge 0$ 建立。如果观察到的计数 $k$ 大于或等于 $\\tau$，则声明病原体存在。\n$$\n\\text{决策} = \\begin{cases} \\text{病原体存在 (阳性)}  \\text{如果 } k \\ge \\tau \\\\ \\text{背景 (阴性)}  \\text{如果 } k  \\tau \\end{cases}\n$$\n\n### 2. 真阳性率和假阳性率\n\n该决策规则的性能由真阳性率 (TPR) 和假阳性率 (FPR) 来表征，它们是如下定义的条件概率：\n\n-   **真阳性率 (TPR)**，或灵敏度，是在样本含有病原体时正确识别的概率。它是在状态为 $H_1$ 的条件下，观察到 $K \\ge \\tau$ 的概率。\n    $$\n    \\text{TPR}(\\tau) = P(K \\ge \\tau \\mid H_1) = P(K \\ge \\tau \\mid \\lambda_1) = \\sum_{k=\\tau}^{\\infty} \\frac{e^{-\\lambda_1} \\lambda_1^k}{k!}\n    $$\n    这是速率为 $\\lambda_1$ 的泊松分布的生存函数（或互补累积分布函数，CCDF）。它可以计算为 $\\text{TPR}(\\tau) = 1 - P(K  \\tau \\mid \\lambda_1) = 1 - P(K \\le \\tau - 1 \\mid \\lambda_1) = 1 - F_{\\text{Poisson}(\\lambda_1)}(\\tau-1)$，其中 $F$ 是累积分布函数 (CDF)。\n\n-   **假阳性率 (FPR)**，或 $1 - \\text{特异性}$，是将背景样本错误地识别为含有病原体的概率。它是在状态为 $H_0$ 的条件下，观察到 $K \\ge \\tau$ 的概率。\n    $$\n    \\text{FPR}(\\tau) = P(K \\ge \\tau \\mid H_0) = P(K \\ge \\tau \\mid \\lambda_0) = \\sum_{k=\\tau}^{\\infty} \\frac{e^{-\\lambda_0} \\lambda_0^k}{k!}\n    $$\n    类似地，这是速率为 $\\lambda_0$ 的泊松分布的生存函数，计算为 $\\text{FPR}(\\tau) = 1 - F_{\\text{Poisson}(\\lambda_0)}(\\tau-1)$。\n\n随着阈值 $\\tau$ 从 $0$ 增加到 $\\infty$，$\\text{TPR}(\\tau)$ 和 $\\text{FPR}(\\tau)$ 都是非递增的，范围从 $1$（对于 $\\tau=0$）到 $0$（当 $\\tau \\to \\infty$ 时）。\n\n### 3. ROC 曲线和曲线下面积 (AUC)\n\nROC 曲线是在二维平面中，对于所有可能的阈值 $\\tau$，$(\\text{FPR}(\\tau), \\text{TPR}(\\tau))$ 的参数图。对于我们的离散整数阈值集合 $\\tau \\in \\{0, 1, 2, \\dots, T_{\\max}\\}$，这将生成一组离散点。按照惯例，该曲线包括点 $(0,0)$（对于 $\\tau \\to \\infty$）和 $(1,1)$（对于 $\\tau=0$）。\n\n要计算 ROC 曲线和 AUC：\n1.  选择一个足够大的上阈值 $T_{\\max}$，使得对于 $\\lambda_0$ 和 $\\lambda_1$，泊松概率 $P(K  T_{\\max})$ 都可忽略不计。这可以通过找到速率为 $\\max(\\lambda_0, \\lambda_1)$ 的泊松分布的高分位数来确定。\n2.  为一系列阈值（通常从 $T_{\\max}+1$ 向下到 $0$）计算 ROC 点 $(\\text{FPR}(\\tau), \\text{TPR}(\\tau))$。这将生成一组按 x 坐标 (FPR) 排序的 $(x,y)$ 坐标。\n3.  曲线下面积 (AUC) 是一个总结分类器性能的标量度量，表示其区分两个类别的能力。它是 ROC 曲线从 $\\text{FPR}=0$ 到 $\\text{FPR}=1$ 的积分。对于一组按 $x_i$ 排序的离散 ROC 点 $(x_i, y_i)$，AUC 可以使用梯形法则进行数值计算：\n    $$\n    \\text{AUC} = \\sum_{i=1}^{N} \\frac{y_i + y_{i-1}}{2} (x_i - x_{i-1})\n    $$\n    其中点为 $(x_0, y_0), (x_1, y_1), \\dots, (x_N, y_N)$。AUC 为 $1.0$ 表示一个完美的分类器，而 AUC 为 $0.5$ 表示性能不优于随机猜测。\n\n### 4. 通过损失最小化选择最优阈值\n\n选择最优阈值 $\\tau^*$ 是为了最小化与错分相关的期望损失或风险。损失函数 $L(\\tau)$ 给出如下：\n$$\nL(\\tau) = c_{\\text{FP}} \\cdot (1 - \\pi) \\cdot \\text{FPR}(\\tau) + c_{\\text{FN}} \\cdot \\pi \\cdot \\text{FNR}(\\tau)\n$$\n其中 $\\pi$ 是病原体存在的先验概率（患病率），$c_{\\text{FP}}$ 是假阳性的成本，$c_{\\text{FN}}$ 是假阴性的成本，$\\text{FNR}(\\tau)$ 是假阴性率。\n\n假阴性率是当病原体存在时未能检测到它的概率：\n$$\n\\text{FNR}(\\tau) = P(K  \\tau \\mid H_1) = 1 - P(K \\ge \\tau \\mid H_1) = 1 - \\text{TPR}(\\tau)\n$$\n将此代入损失函数可得：\n$$\nL(\\tau) = c_{\\text{FP}} \\cdot (1 - \\pi) \\cdot \\text{FPR}(\\tau) + c_{\\text{FN}} \\cdot \\pi \\cdot \\big(1 - \\text{TPR}(\\tau)\\big)\n$$\n为了找到最优阈值 $\\tau^*$，我们将：\n1.  对于范围 $[0, T_{\\max}]$ 内的每个整数阈值 $\\tau$，计算 $L(\\tau)$。\n2.  识别该损失函数的最小值 $L_{\\min} = \\min_{\\tau} L(\\tau)$。\n3.  最优阈值 $\\tau^*$ 是使 $L(\\tau) = L_{\\min}$ 成立的最小整数 $\\tau$。\n\n该算法的执行过程是首先计算 $\\tau \\in [0, T_{\\max}]$ 的 $\\text{FPR}(\\tau)$ 和 $\\text{TPR}(\\tau)$ 向量，然后使用这些向量计算 AUC 和损失向量 $L(\\tau)$，并由此确定最优阈值及相关的性能指标。此过程将应用于所提供的每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Solves the pathogen detection problem for a suite of test cases.\n    For each case, it calculates the optimal detection threshold, AUC,\n    and associated performance metrics by modeling read counts with\n    Poisson distributions and minimizing an expected loss function.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda_0, lambda_1, pi, c_fp, c_fn)\n        (0.5, 5.0, 0.05, 1.0, 10.0), # Case 1\n        (2.0, 2.0, 0.5, 1.0, 1.0),   # Case 2 (boundary condition)\n        (0.8, 1.2, 0.1, 1.0, 3.0),   # Case 3 (subtle signal)\n        (10.0, 20.0, 0.2, 2.0, 1.0)  # Case 4 (high background)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lambda0, lambda1, pi, c_fp, c_fn = case\n        \n        # 1. Construct the discrete ROC curve\n        # Choose T_max to ensure tails are negligible.\n        # We use the 1 - 1e-12 quantile of the larger Poisson lambda,\n        # plus a small buffer. We use max(..., 1) to handle small lambdas.\n        t_max = int(poisson.ppf(1 - 1e-12, max(lambda0, lambda1, 1))) + 10\n        \n        # Thresholds to evaluate for optimization\n        taus_opt = np.arange(0, t_max + 1)\n        \n        # Calculate FPR and TPR for each threshold.\n        # P(K >= tau) = 1 - P(K = tau - 1) = 1 - CDF(tau - 1)\n        fprs = 1 - poisson.cdf(taus_opt - 1, lambda0)\n        tprs = 1 - poisson.cdf(taus_opt - 1, lambda1)\n        \n        # 2. Compute the numerical AUC\n        # For AUC calculation, we need ROC points sorted by ascending FPR.\n        # This is achieved by evaluating thresholds from high to low.\n        taus_roc = np.arange(t_max + 1, -1, -1)\n        roc_fpr = 1 - poisson.cdf(taus_roc - 1, lambda0)\n        roc_tpr = 1 - poisson.cdf(taus_roc - 1, lambda1)\n        \n        # Use a consistent numerical integration method (trapezoidal rule).\n        auc = np.trapz(roc_tpr, roc_fpr)\n        \n        # 3. Optimize the threshold under the loss function\n        # L(tau) = c_FP * (1 - pi) * FPR(tau) + c_FN * pi * (1 - TPR(tau))\n        losses = c_fp * (1 - pi) * fprs + c_fn * pi * (1 - tprs)\n        \n        # Find the index of the minimum loss. np.argmin() breaks ties\n        # by choosing the smallest index, which corresponds to the smallest tau.\n        opt_idx = np.argmin(losses)\n        \n        tau_star = taus_opt[opt_idx]\n        min_loss = losses[opt_idx]\n        fpr_at_tau_star = fprs[opt_idx]\n        tpr_at_tau_star = tprs[opt_idx]\n        \n        # 4. Report the tuple of results\n        result_tuple = [\n            int(tau_star),           # tau* as integer\n            auc,                     # AUC\n            fpr_at_tau_star,         # FPR(tau*)\n            tpr_at_tau_star,         # TPR(tau*)\n            min_loss                 # L(tau*)\n        ]\n        results.append(result_tuple)\n\n    # Final print statement in the exact required format.\n    # Floating-point entries are rounded to 6 decimal places.\n    output_parts = []\n    for r in results:\n        formatted_r = (\n            f\"[{r[0]},\"\n            f\"{r[1]:.6f},\"\n            f\"{r[2]:.6f},\"\n            f\"{r[3]:.6f},\"\n            f\"{r[4]:.6f}]\"\n        )\n        output_parts.append(formatted_r)\n    \n    print(f\"[{','.join(output_parts)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "5132078"}]}