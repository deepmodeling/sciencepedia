{"hands_on_practices": [{"introduction": "基于UMI的纠错测序，其核心是从源自同一原始分子的多个测序读数（reads）中生成一条共有序列。本练习将指导您使用多数表决法，从第一性原理出发，推导共有序列出错的概率。通过解决这个问题，您将从数学上理解冗余度如何能够将最终的错误率显著降低到远低于单个读数的水平。[@problem_id:5113757]", "problem": "在用于分子和免疫诊断中罕见变异检测的错误校正测序中，使用独特分子标识符（UMIs）在新一代测序（NGS）中对原始模板分子进行扩增和测序之前的标记。考虑一个源自单一真实模板碱基的UMI家族，并假设该家族的$k$个读段中的每一个都独立且同分布地报告碱基，每个读段的碱基替换错误概率为$p$，且没有其他错误模式起作用。该家族的一致性碱基是通过对$k$个读段进行简单多数投票规则来确定的。假设$k$是奇数，因此不会出现平票情况。在这些假设下，从独立伯努利试验和二项分布的定义出发，推导出一个关于$k$和$p$的函数，表示一致性碱基不正确的概率的解析表达式。\n\n然后，对于UMI家族大小$k=7$和每个读段的错误概率$p=0.01$的情况，评估一致性错误概率。将最终数值答案四舍五入至四位有效数字。最终答案以纯数字形式提供，不带任何单位。", "solution": "首先对用户提供的问题进行严格的验证过程。\n\n### 第一步：提取已知条件\n- 单一UMI家族源自一个真实模板碱基。\n- 该家族中有$k$个读段。\n- 每个读段独立且同分布地报告碱基。\n- 每个读段的碱基替换错误概率为$p$。\n- 没有其他错误模式起作用。\n- 一致性碱基通过简单多数投票确定。\n- $k$是一个奇整数。\n- 需要从第一性原理推导一致性碱基不正确的概率的解析表达式。\n- 推导必须从独立伯努利试验和二项分布的定义开始。\n- 导出的表达式必须针对$k=7$和$p=0.01$进行求值。\n- 最终数值答案必须四舍五入至四位有效数字。\n\n### 第二步：使用提取的已知条件进行验证\n1.  **科学依据**：该问题具有科学依据。所描述的模型是在分子诊断学和生物信息学中用于理解使用独特分子标识符（UMIs）进行错误校正的一个标准和基础的简化模型。使用二项分布来模拟独立错误事件是该领域的核心概念。\n2.  **适定性**：该问题是适定的。所有必要的参数（$k$，$p$）和条件（独立同分布的读段，多数投票）都已明确定义。$k$为奇数的约束至关重要，因为它避免了多数投票中的平票情况，确保总能确定一个唯一的一致性碱基。这导致了一个唯一的、可计算的概率。\n3.  **客观性**：问题以客观、正式的语言陈述，没有主观或含糊的术语。\n4.  **完整性和一致性**：问题是自洽和一致的。它提供了推导解析表达式和计算数值所需的所有信息。所提供的数据中没有矛盾。$k=7$和$p=0.01$的值对于新一代测序应用是现实的。\n\n### 第三步：结论与行动\n问题被判定为**有效**。它在科学上是合理的，是适定的，并且提供了所有必要的信息。现在将进行求解过程。\n\n### 解析表达式的推导\n\n让我们将$k$个读段中每一个的状态建模为一个伯努利试验。对于一个给定的读段，如果它报告的碱基与真实模板碱基不同，则结果为“错误”，否则为“正确”。问题陈述碱基替换错误的概率为$p$。因此，对于单次试验：\n- “错误”的概率是$p$。\n- “正确”的概率是$1-p$。\n\n我们有$k$个这样的读段，规定它们是独立且同分布的。令$X$为随机变量，表示在$k$个读段中错误（不正确读段）的总数。由于这些试验是独立的且具有相同的错误概率，所以$X$遵循参数为$k$（试验次数）和$p$（成功概率，即错误概率）的二项分布。我们将其记为$X \\sim \\text{Binomial}(k, p)$。\n\n二项分布的概率质量函数（PMF）给出了在$k$次试验中观察到恰好$i$个错误的概率：\n$$\nP(X=i) = \\binom{k}{i} p^i (1-p)^{k-i}\n$$\n其中，$\\binom{k}{i} = \\frac{k!}{i!(k-i)!}$是二项式系数，表示从总共$k$个读段中选择$i$个含错误读段的方式数。该公式对$i = 0, 1, 2, \\dots, k$有效。\n\nUMI家族的一致性碱基由简单多数投票决定。如果含错误的读段数多于正确的读段数，则会得出一个不正确的一致性碱基。设$i$为含错误的读段数。那么正确的读段数是$k-i$。不正确一致性碱基的条件是：\n$$\ni > k-i\n$$\n$$\n2i > k\n$$\n$$\ni > \\frac{k}{2}\n$$\n问题指明$k$是一个奇整数。设$k = 2m+1$，其中$m$为非负整数。不正确一致性碱基的条件变为$i > \\frac{2m+1}{2} = m + \\frac{1}{2}$。由于$i$必须是整数，这等价于$i \\ge m+1$。注意到$m = \\frac{k-1}{2}$，因此得出不正确结果所需的最小错误数为$i_{min} = m+1 = \\frac{k-1}{2} + 1 = \\frac{k+1}{2}$。\n\n不正确一致性碱基的概率，记为$P_{\\text{error}}$，是错误数$X$大于$k/2$的概率。这是满足此条件的所有可能错误数的概率之和，即$i = \\frac{k+1}{2}, \\frac{k+1}{2}+1, \\dots, k$。\n因此，一致性错误概率的解析表达式为：\n$$\nP_{\\text{error}}(k, p) = P\\left(X \\ge \\frac{k+1}{2}\\right) = \\sum_{i=\\frac{k+1}{2}}^{k} P(X=i)\n$$\n代入二项PMF，我们得到最终表达式：\n$$\nP_{\\text{error}}(k, p) = \\sum_{i=\\frac{k+1}{2}}^{k} \\binom{k}{i} p^i (1-p)^{k-i}\n$$\n这就完成了从第一性原理的推导。\n\n### 特定参数的求值\n\n我们被要求评估UMI家族大小$k=7$和每个读段错误概率$p=0.01$时的这个概率。\n对于$k=7$，不正确一致性碱基的最小错误数是$\\frac{7+1}{2} = 4$。因此，如果存在$4$、$5$、$6$或$7$个错误，就会出现不正确的一致性碱基。我们必须计算$P(X \\ge 4)$。\n\n该概率由以下和给出：\n$$\nP_{\\text{error}} = P(X=4) + P(X=5) + P(X=6) + P(X=7)\n$$\n使用推导出的公式，其中$k=7$，$p=0.01$，以及$1-p=0.99$：\n$$\nP_{\\text{error}} = \\sum_{i=4}^{7} \\binom{7}{i} (0.01)^i (0.99)^{7-i}\n$$\n我们计算每一项：\n- 对于$i=4$：$\\binom{7}{4} (0.01)^4 (0.99)^3 = \\frac{7!}{4!3!} (10^{-2})^4 (0.99)^3 = 35 \\times 10^{-8} \\times (0.970299) \\approx 3.3960465 \\times 10^{-7}$\n- 对于$i=5$：$\\binom{7}{5} (0.01)^5 (0.99)^2 = \\frac{7!}{5!2!} (10^{-2})^5 (0.99)^2 = 21 \\times 10^{-10} \\times (0.9801) \\approx 2.05821 \\times 10^{-9}$\n- 对于$i=6$：$\\binom{7}{6} (0.01)^6 (0.99)^1 = \\frac{7!}{6!1!} (10^{-2})^6 (0.99)^1 = 7 \\times 10^{-12} \\times (0.99) \\approx 6.93 \\times 10^{-12}$\n- 对于$i=7$：$\\binom{7}{7} (0.01)^7 (0.99)^0 = \\frac{7!}{7!0!} (10^{-2})^7 (1) = 1 \\times 10^{-14}$\n\n将这些项相加：\n$$\nP_{\\text{error}} \\approx 3.3960465 \\times 10^{-7} + 2.05821 \\times 10^{-9} + 6.93 \\times 10^{-12} + 1 \\times 10^{-14}\n$$\n$$\nP_{\\text{error}} \\approx 3.3960465 \\times 10^{-7} + 0.0205821 \\times 10^{-7} + 0.0000693 \\times 10^{-7} + 0.0000001 \\times 10^{-7}\n$$\n$$\nP_{\\text{error}} \\approx 3.4166979 \\times 10^{-7}\n$$\n将结果四舍五入至四位有效数字，我们得到$3.417 \\times 10^{-7}$。", "answer": "$$\\boxed{3.417 \\times 10^{-7}}$$", "id": "5113757"}, {"introduction": "尽管共有序列法能显著抑制错误，但并不能完全消除它们。为了可靠地检出稀有突变，我们必须能够区分真实的生物信号与残留的背景噪音。本练习聚焦于这一挑战的一个基本方面：推导在特定位点上，假阳性读数的期望数量。这个计算为评估观测到的突变读数是否具有统计显著性提供了一个关键基准。[@problem_id:5113749]", "problem": "在用于分子和免疫诊断的循环肿瘤DNA检测中，假设一个基因组位点对于参考碱基确实是纯合的。测序通过一个经过纠错的工作流程进行，该流程将该位点上每次读取的每个碱基的有效替换错误率降低到 $p$。假设一个对称的替换错误模型：当一次读取在该位点上发生替换错误时，它会以相等的概率导致三种非参考核苷酸中的一种，并且插入-缺失错误可以忽略不计。该位点的总读取深度为 $D$，并且在给定真实碱基的情况下，各次读取是独立的。一个变异检出程序评估该位点上对应于一个特定备选碱基的预先指定的单核苷酸变异（SNV），并且当且仅当一次读取报告了该位点上的这个特定备选碱基时，才将其计为支持变异的读取。\n\n从概率和期望的第一性原理出发，推导该位点上假阳性支持变异的读取的期望数量（即，在真实碱基为参考碱基的情况下，仅仅由于测序替换错误而支持预先指定的备选碱基的读取数量）关于 $D$ 和 $p$ 的解析表达式。将您的最终答案表示为关于 $D$ 和 $p$ 的封闭形式表达式。不要对答案进行四舍五入。", "solution": "首先验证问题陈述的科学性和逻辑完整性。\n\n**步骤1：提取已知条件**\n- 基因组位点对于参考碱基确实是纯合的。\n- 每个碱基的有效替换错误率为 $p$。\n- 替换错误模型是对称的：如果发生替换错误，它会以相等的概率导致三种非参考核苷酸中的一种。\n- 插入-缺失错误可以忽略不计。\n- 该位点的总读取深度为 $D$。\n- 在给定真实碱基的情况下，各次读取是独立的。\n- 一个预先指定的单核苷酸变异（SNV）对应于一个特定的备选碱基。\n- 当且仅当一次读取报告了该位点上的这个特定备选碱基时，才将其计为支持变异的读取。\n- 目标是推导假阳性支持变异的读取的期望数量。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它描述了生物信息学和分子诊断学中用于量化测序数据噪声的标准概率模型。参数（$p$，$D$）和错误模型都得到了明确定义。问题要求基于这些参数推导一个可导出的量（期望值）。该问题是自洽的、一致的，不违反任何科学原理，也不包含歧义。这是一个可形式化的问题，与纠错测序直接相关。\n\n**步骤3：结论与行动**\n问题有效。将提供一个合理的解答。\n\n**解答的推导**\n目标是找到在一个真实碱基为参考碱基的位点上，错误地报告了特定备选碱基的读取的期望数量。根据定义，这样的读取是假阳性。\n\n让我们从单次读取开始考虑。我们需要确定这次读取是假阳性支持变异的读取的概率。设这个概率为 $q$。\n\n问题陈述指出，要将一次读取计为支持变异的读取，它必须报告一个*特定*的预先指定的备选碱基。由于该位点的真实碱基是参考碱基，这种情况只有在发生测序错误时才会发生。\n\n对于任何给定的读取，在该位点上发生每个碱基替换错误的总概率为 $p$。\n\n替换错误模型是对称的。这意味着如果发生替换错误，机器将以相等的概率报告三种可能的非参考碱基之一。设碱基集合为 $\\{A, C, G, T\\}$。例如，如果参考碱基是 $A$，那么三种非参考碱基就是 $\\{C, G, T\\}$。我们感兴趣的SNV恰好对应于其中之一，比如 $G$。\n\n因此，要使单次读取成为支持这个特定SNV的假阳性，必须满足两个条件：\n1.  必须发生替换错误。此事件的概率是 $P(\\text{error}) = p$。\n2.  在发生替换错误的情况下，该错误必须是变为我们感兴趣的特定备选碱基。由于有三种可能的非参考碱基，并且在发生错误时每种碱基的可能性相同，因此该事件的条件概率为 $P(\\text{specific alternate} | \\text{error}) = \\frac{1}{3}$。\n\n单次读取是支持特定变异的假阳性的概率 $q$ 是这两个事件的联合概率。由于错误的类型与错误的发生是独立的，我们可以将它们的概率相乘：\n$$q = P(\\text{error} \\cap \\text{specific alternate}) = P(\\text{error}) \\times P(\\text{specific alternate} | \\text{error})$$\n$$q = p \\times \\frac{1}{3} = \\frac{p}{3}$$\n\n现在，我们必须考虑该位点上的总共 $D$ 次独立读取。设 $X_i$ 为第 $i$ 次读取的指示随机变量，其中 $i$ 的范围是从 $1$ 到 $D$。变量 $X_i$ 定义如下：\n$$\nX_i =\n\\begin{cases}\n1  \\text{ if read } i \\text{ is a false positive variant-supporting read} \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n\n$X_i=1$ 的概率是 $q = \\frac{p}{3}$，而 $X_i=0$ 的概率是 $1-q = 1-\\frac{p}{3}$。\n\n在 $D$ 次读取集合中，假阳性支持变异的读取总数是随机变量 $X = \\sum_{i=1}^{D} X_i$。我们被要求求出 $X$ 的期望值，记为 $E[X]$。\n\n期望的一个基本性质是其线性性。随机变量之和的期望等于它们各自期望之和，无论它们是否独立。\n$$E[X] = E\\left[\\sum_{i=1}^{D} X_i\\right] = \\sum_{i=1}^{D} E[X_i]$$\n\n指示随机变量 $X_i$ 的期望就是它所指示事件的概率：\n$$E[X_i] = 1 \\cdot P(X_i=1) + 0 \\cdot P(X_i=0) = P(X_i=1) = q = \\frac{p}{3}$$\n\n由于每次读取都遵循相同的错误过程，因此对于所有的 $i$，其期望是相同的。\n$$E[X_i] = \\frac{p}{3} \\quad \\text{for all } i=1, \\dots, D$$\n\n将此代回求和式中：\n$$E[X] = \\sum_{i=1}^{D} \\frac{p}{3}$$\n\n这是一个包含 $D$ 个相同项的和。因此，假阳性支持变异的读取的期望数量是：\n$$E[X] = D \\times \\frac{p}{3} = \\frac{Dp}{3}$$\n\n这个结果是从第一性原理推导出来的，使用了事件的定义、概率的链式法则以及期望的线性性。", "answer": "$$\\boxed{\\frac{Dp}{3}}$$", "id": "5113749"}, {"introduction": "这个综合性练习将理论与应用相结合，把错误建模的原理应用于一个真实的临床诊断场景。您将开发并实现一个变化点检测算法，用于分析患者的纵向循环肿瘤DNA（ctDNA）数据。通过将复杂的错误模型整合到似然比检验中，您将学会如何就疾病进展做出统计上稳健的决策，从而展示纠错测序在诊断中的最终价值。[@problem_id:5113782]", "problem": "给定来自循环肿瘤DNA（ctDNA）纠错测序的纵向观测数据，该测序使用了唯一分子标识符（UMI）的一致性读数。在由整数 $t \\in \\{1,2,\\dots,T\\}$ 索引的每个时间点，您会观测到覆盖某个基因座的UMI一致性分子总数（表示为 $N_t$）以及其中被分类为突变体的UMI数量（表示为 $x_t$）。在时间点 $t$ 我们感兴趣的未知生物学量是真实的突变等位基因频率 $\\theta_t \\in [0,1]$，其定义为在该基因座携带突变的原始模板分子的比例。\n\n在使用UMI的纠错测序中，每个UMI一致性读数是一个分类结果，可以建模为一个伯努利随机变量，反映该一致性读数被判定为突变型还是野生型。设每个UMI的假阳性率为 $r_{\\mathrm{fp}} \\in [0,1]$（一个真正的野生型UMI被判定为突变型的概率），每个UMI的假阴性率为 $r_{\\mathrm{fn}} \\in [0,1]$（一个真正的突变型UMI被判定为野生型的概率）。假设在给定的时间段内，真实的等位基因频率是恒定的，并且UMI在给定 $\\theta_t$ 的条件下是独立的。\n\n建模基本依据：\n- 在时间点 $t$ 的每个UMI一致性读数有 $\\theta_t$ 的概率来自一个真实的突变分子，有 $1-\\theta_t$ 的概率来自一个真实的野生型分子。\n- 一个真正的突变型UMI以 $1 - r_{\\mathrm{fn}}$ 的概率被观测为突变型。\n- 一个真正的野生型UMI以 $r_{\\mathrm{fp}}$ 的概率被观测为突变型。\n- 给定在时间点 $t$ 的 $N_t$ 个UMI，观测到的突变计数 $x_t$ 被建模为一个二项随机变量，其参数为 $N_t$ 和一个必须由上述要素推导出的成功概率。\n\n变化点模型：\n- 在零模型（无变化）下，真实的等位基因频率在所有时间点上是恒定的，即对于所有 $t$，$\\theta_t = \\theta$。\n- 在备择模型（单一变化）下，存在一个索引 $k \\in \\{1,2,\\dots,T-1\\}$，使得当 $t \\le k$ 时 $\\theta_t = \\theta_1$，当 $t \\ge k+1$ 时 $\\theta_t = \\theta_2$。\n- 对于疾病进展检测，只有当最大似然变化点同时满足以下两个条件时，您才能判定发生了进展：(i) 后一时段的等位基因频率比前一时段的等位基因频率至少增加了指定的最小增量 $\\Delta_{\\min} > 0$，并且 (ii) 超过了指定的对数似然比阈值 $\\Lambda > 0$。\n\n您的任务：\n1. 从上述建模陈述出发，推导在时间点 $t$ 的伯努利成功概率，将其表示为 $\\theta_t$、$r_{\\mathrm{fp}}$ 和 $r_{\\mathrm{fn}}$ 的函数。然后，使用二项似然，建立零模型和单一变化模型的对数似然。\n2. 在每个模型下使用最大似然估计，计算零模型下的最大对数似然，以及对于每个可能的变化点 $k \\in \\{1,\\dots,T-1\\}$，在 $k$ 点发生变化的备择模型下的最大对数似然。参数空间必须遵循由 $\\theta$ 导出的可观测伯努利成功概率被限制在 $[r_{\\mathrm{fp}}, 1 - r_{\\mathrm{fn}}]$ 范围内。\n3. 计算最佳单一变化点的对数似然比，其值为备择模型和零模型最大对数似然之差的 $2$ 倍。令 $\\widehat{k}$ 为使该比率最大化的索引，令 $\\widehat{\\theta}_1$ 和 $\\widehat{\\theta}_2$ 分别为前、后时段对应的最大似然等位基因频率。\n4. 应用进展决策规则：仅当最大对数似然比至少为 $\\Lambda$ 且 $\\widehat{\\theta}_2 - \\widehat{\\theta}_1 \\ge \\Delta_{\\min}$ 时，才宣告进展。如果宣告进展，则输出变化点索引 $\\widehat{k}$（使用基于1的索引，意味着变化发生在时间 $\\widehat{k}$ 和 $\\widehat{k}+1$ 之间）。否则，输出 $-1$。\n\n数值稳定性要求：\n- 在计算任何概率的对数时，将概率限制在闭区间 $\\left[\\varepsilon, 1-\\varepsilon\\right]$ 内，其中 $\\varepsilon = 10^{-12}$，以避免计算 $\\log(0)$。\n\n测试套件和参数：\n- 对所有测试用例使用以下常量：$r_{\\mathrm{fp}} = 10^{-4}$，$r_{\\mathrm{fn}} = 2 \\times 10^{-2}$，$\\Delta_{\\min} = 3 \\times 10^{-4}$，以及 $\\Lambda = 10$。\n- 有四个独立的测试用例。对于每个测试用例 $i \\in \\{1,2,3,4\\}$，给定时间序列长度 $T^{(i)}$、向量 $(N^{(i)}_t)_{t=1}^{T^{(i)}}$ 和 $(x^{(i)}_t)_{t=1}^{T^{(i)}}$：\n\n测试用例 1（明显增加）：\n- $T^{(1)} = 8$\n- $N^{(1)} = (10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000)$\n- $x^{(1)} = (6, 5, 7, 6, 49, 52, 51, 48)$\n\n测试用例 2（无变化；接近背景水平）：\n- $T^{(2)} = 6$\n- $N^{(2)} = (15000, 15000, 15000, 15000, 15000, 15000)$\n- $x^{(2)} = (1, 2, 2, 1, 3, 0)$\n\n测试用例 3（检测极限附近的微小增加）：\n- $T^{(3)} = 10$\n- $N^{(3)} = (8000, 9500, 7000, 12000, 10000, 11000, 9000, 10000, 10000, 12000)$\n- $x^{(3)} = (3, 3, 2, 4, 3, 8, 6, 7, 7, 8)$\n\n测试用例 4（减少；不应称为进展）：\n- $T^{(4)} = 7$\n- $N^{(4)} = (10000, 10000, 10000, 10000, 10000, 10000, 10000)$\n- $x^{(4)} = (85, 79, 82, 80, 12, 10, 9)$\n\n最终输出格式：\n- 您的程序应处理上述四个测试用例，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，如果宣告进展，则输出一个整数：检测到的变化点索引 $\\widehat{k}$（使用基于1的索引）；否则输出 $-1$。例如，一个有效的输出行格式为 $[a,b,c,d]$，其中 $a,b,c,d$ 均为指定的整数。", "solution": "该问题要求为纵向循环肿瘤DNA（ctDNA）测序数据开发一个变化点检测算法。目标是确定真实突变等位基因频率 $\\theta_t$ 是否发生了统计上显著的增加。这涉及到对测序数据进行建模，在零假设和备择假设下执行最大似然估计（MLE），并使用似然比检验结合效应大小约束来做出决策。\n\n首先，我们推导观测到一个突变唯一分子标识符（UMI）一致性读数的概率。设 $p_t$ 为在时间点 $t$ 一个UMI一致性读数被分类为突变体的概率。此事件可以通过两种互斥的方式发生：原始DNA分子是突变型且被正确识别，或者分子是野生型但被错误地识别为突变型（假阳性）。利用全概率法则，我们可以将 $p_t$ 表示为真实突变等位基因频率 $\\theta_t$、每个UMI的假阳性率 $r_{\\mathrm{fp}}$ 和每个UMI的假阴性率 $r_{\\mathrm{fn}}$ 的函数。\n\n$p_t$ 由下式给出：\n$$p_t = P(\\text{observed mutant}) = P(\\text{observed mutant} | \\text{true mutant})P(\\text{true mutant}) + P(\\text{observed mutant} | \\text{true wild-type})P(\\text{true wild-type})$$\n$$p_t = (1 - r_{\\mathrm{fn}})\\theta_t + r_{\\mathrm{fp}}(1 - \\theta_t)$$\n整理这个线性关系得到：\n$$p_t = r_{\\mathrm{fp}} + (1 - r_{\\mathrm{fp}} - r_{\\mathrm{fn}})\\theta_t$$\n问题指明，在给定总UMI计数 $N_t$ 的情况下，时间点 $t$ 观测到的UMI计数 $x_t$ 服从二项分布，$x_t \\sim \\text{Binomial}(N_t, p_t)$。对于单个观测 $(x_t, N_t)$ 的对数似然（省略不影响最大化的常数二项式系数 $\\log\\binom{N_t}{x_t}$）为：\n$$\\mathcal{L}(p_t | x_t, N_t) \\propto x_t \\log(p_t) + (N_t - x_t) \\log(1 - p_t)$$\n\n接下来，我们定义最大似然估计的步骤。对于给定的时间点分段 $S$，其中真实的等位基因频率 $\\theta$ 假定为常数，总对数似然是各个对数似然的总和：\n$$\\mathcal{L}(\\theta; S) = \\sum_{t \\in S} \\left[ x_t \\log(p) + (N_t - x_t) \\log(1 - p) \\right]$$\n其中 $p = r_{\\mathrm{fp}} + (1 - r_{\\mathrm{fp}} - r_{\\mathrm{fn}})\\theta$。这等同于在 $\\sum_{t \\in S} N_t$ 次试验中获得 $\\sum_{t \\in S} x_t$ 次成功的单个二项实验的对数似然。观测概率 $p$ 的最大似然估计是合并频率：\n$$\\widehat{p} = \\frac{\\sum_{t \\in S} x_t}{\\sum_{t \\in S} N_t}$$\n问题指出，可观测概率 $p$ 的参数空间是 $[r_{\\mathrm{fp}}, 1 - r_{\\mathrm{fn}}]$，对应于 $\\theta \\in [0, 1]$。因此，MLE $\\widehat{p}$ 必须被约束在该区间内。设 $\\widehat{p}_{\\text{raw}} = (\\sum x_t) / (\\sum N_t)$。则受约束的MLE为 $\\widehat{p} = \\max(r_{\\mathrm{fp}}, \\min(1 - r_{\\mathrm{fn}}, \\widehat{p}_{\\text{raw}}))$。\n由此，我们通过反转线性关系来找到真实等位基因频率的MLE $\\widehat{\\theta}$：\n$$\\widehat{\\theta} = \\frac{\\widehat{p} - r_{\\mathrm{fp}}}{1 - r_{\\mathrm{fp}} - r_{\\mathrm{fn}}}$$\n这个过程使我们能够通过首先计算 $\\widehat{p}$，然后使用该估计值评估对数似然函数，来找到任何数据段的最大对数似然。为了数值稳定性，我们将任何对数的参数限制在区间 $[\\varepsilon, 1-\\varepsilon]$ 内，其中 $\\varepsilon = 10^{-12}$。\n\n我们现在将此框架应用于零模型和备择模型。\n在零模型（$H_0$）下，等位基因频率在所有时间点上都是恒定的，对于 $t \\in \\{1, \\dots, T\\}$，$\\theta_t = \\theta$。我们通过合并所有数据来计算MLE $\\widehat{p}_{\\text{null}}$：$S = \\{1, \\dots, T\\}$。零模型下的最大对数似然为：\n$$\\mathcal{L}_{\\text{null, max}} = \\mathcal{L}(\\widehat{\\theta}_{\\text{null}}; S=\\{1, \\dots, T\\}) = \\sum_{t=1}^{T} \\left[ x_t \\log(\\widehat{p}_{\\text{null}}) + (N_t - x_t) \\log(1 - \\widehat{p}_{\\text{null}}) \\right]$$\n\n在备择模型（$H_1$）下，存在一个单一变化点 $k \\in \\{1, \\dots, T-1\\}$。对于每个可能的 $k$，数据被分成两个段：$S_1 = \\{1, \\dots, k\\}$ 和 $S_2 = \\{k+1, \\dots, T\\}$。我们假设当 $t \\in S_1$ 时 $\\theta_t = \\theta_1$，当 $t \\in S_2$ 时 $\\theta_t = \\theta_2$。我们对每个段独立执行MLE以找到 $\\widehat{p}_{1,k}$ 和 $\\widehat{p}_{2,k}$。给定 $k$ 的总最大对数似然是两个段最大对数似然之和：\n$$\\mathcal{L}_{\\text{alt, max}}(k) = \\left( \\sum_{t=1}^{k} \\left[x_t \\log(\\widehat{p}_{1,k}) + (N_t - x_t) \\log(1 - \\widehat{p}_{1,k})\\right] \\right) + \\left( \\sum_{t=k+1}^{T} \\left[x_t \\log(\\widehat{p}_{2,k}) + (N_t - x_t) \\log(1 - \\widehat{p}_{2,k})\\right] \\right)$$\n我们通过在所有可能的 $k$ 上最大化此量来找到最佳变化点 $\\widehat{k}$：\n$$\\widehat{k} = \\arg\\max_{k \\in \\{1, \\dots, T-1\\}} \\mathcal{L}_{\\text{alt, max}}(k)$$\n备择模型的总体最大对数似然是 $\\mathcal{L}_{\\text{alt, max}} = \\mathcal{L}_{\\text{alt, max}}(\\widehat{k})$。\n\n对数似然比（LRT）统计量计算如下：\n$$\\text{LRT} = 2 \\times (\\mathcal{L}_{\\text{alt, max}} - \\mathcal{L}_{\\text{null, max}})$$\n该统计量量化了单一变化点模型相对于无变化模型的证据强度。\n\n最后，应用宣告疾病进展的决策规则。当且仅当最佳变化点 $\\widehat{k}$ 满足以下两个条件时，才检测到进展：\n1. LRT超过一个阈值：$\\text{LRT} \\ge \\Lambda$。\n2. 估计的等位基因频率增加量达到一个最小阈值：$\\widehat{\\theta}_2 - \\widehat{\\theta}_1 \\ge \\Delta_{\\min}$，其中 $\\widehat{\\theta}_1$ 和 $\\widehat{\\theta}_2$ 是由 $\\widehat{k}$ 定义的段所对应的MLE。\n如果两个条件都满足，输出是变化点的基于1的索引 $\\widehat{k}$。否则，不宣告进展，输出为 $-1$。第二个条件确保我们只检测等位基因频率的增加，而不检测减少或临床意义上过小的变化。", "answer": "```python\nimport numpy as np\n\n# Constants from the problem statement\nR_FP = 1e-4\nR_FN = 2e-2\nDELTA_MIN = 3e-4\nLAMBDA = 10.0\nEPSILON = 1e-12\n\ndef calculate_mle_and_loglik(x_segment, n_segment, r_fp, r_fn):\n    \"\"\"\n    Calculates the MLEs for p and theta, and the maximum log-likelihood for a data segment.\n    \n    Args:\n        x_segment (np.ndarray): Array of mutant counts.\n        n_segment (np.ndarray): Array of total counts.\n        r_fp (float): False positive rate.\n        r_fn (float): False negative rate.\n\n    Returns:\n        tuple: (theta_hat, max_log_likelihood)\n    \"\"\"\n    if np.sum(n_segment) == 0:\n        return 0.0, -np.inf\n\n    # Calculate raw MLE for the observed probability p by pooling data\n    p_hat_raw = np.sum(x_segment) / np.sum(n_segment)\n\n    # Clamp p_hat to the valid range [r_fp, 1 - r_fn]\n    p_hat_clamped = np.clip(p_hat_raw, r_fp, 1.0 - r_fn)\n\n    # Invert to find the MLE for the true allele fraction theta\n    denominator = 1.0 - r_fp - r_fn\n    theta_hat = (p_hat_clamped - r_fp) / denominator\n\n    # Clamp probability again for numerical stability before taking the logarithm\n    p_log = np.clip(p_hat_clamped, EPSILON, 1.0 - EPSILON)\n    \n    # Calculate the total log-likelihood for the segment\n    loglik = np.sum(\n        x_segment * np.log(p_log) + (n_segment - x_segment) * np.log(1.0 - p_log)\n    )\n\n    return theta_hat, loglik\n\ndef solve_case(N, x, r_fp, r_fn, delta_min, Lambda):\n    \"\"\"\n    Processes a single test case for change-point detection.\n    \n    Returns:\n        int: The 1-based change-point index if progression is detected, otherwise -1.\n    \"\"\"\n    T = len(N)\n    N = np.array(N, dtype=np.float64)\n    x = np.array(x, dtype=np.float64)\n\n    # 1. Null Model (H0: no change)\n    # Calculate the maximum log-likelihood assuming one constant allele fraction\n    _, loglik_null = calculate_mle_and_loglik(x, N, r_fp, r_fn)\n\n    # 2. Alternative Model (H1: one change-point)\n    # Find the best change-point by maximizing the log-likelihood\n    max_loglik_alt = -np.inf\n    best_k = -1\n    best_theta1 = 0.0\n    best_theta2 = 0.0\n\n    # Iterate through all possible change-points k (1-based index).\n    # k represents the last time point of the first segment.\n    for k in range(1, T):\n        # Segment 1: time points 1..k (0-indexed: 0..k-1)\n        x1, n1 = x[:k], N[:k]\n        # Segment 2: time points k+1..T (0-indexed: k..T-1)\n        x2, n2 = x[k:], N[k:]\n\n        theta1, loglik1 = calculate_mle_and_loglik(x1, n1, r_fp, r_fn)\n        theta2, loglik2 = calculate_mle_and_loglik(x2, n2, r_fp, r_fn)\n\n        current_loglik_alt = loglik1 + loglik2\n\n        if current_loglik_alt > max_loglik_alt:\n            max_loglik_alt = current_loglik_alt\n            best_k = k\n            best_theta1 = theta1\n            best_theta2 = theta2\n            \n    # 3. Decision Logic\n    if best_k == -1: # Handles case of T=1, no possible change-point\n        return -1\n        \n    # Calculate the Log-Likelihood Ratio statistic\n    log_likelihood_ratio = 2 * (max_loglik_alt - loglik_null)\n\n    # Check both conditions for progression:\n    # 1. Statistical significance (LRT)\n    # 2. Effect size (magnitude of increase in theta)\n    is_lrt_significant = log_likelihood_ratio >= Lambda\n    is_increase_meaningful = (best_theta2 - best_theta1) >= delta_min\n\n    if is_lrt_significant and is_increase_meaningful:\n        return best_k\n    else:\n        return -1\n        \ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Test cases from the problem statement\n    test_cases = [\n        # Case 1: clear increase\n        (\n            [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000],\n            [6, 5, 7, 6, 49, 52, 51, 48]\n        ),\n        # Case 2: no change; near background\n        (\n            [15000, 15000, 15000, 15000, 15000, 15000],\n            [1, 2, 2, 1, 3, 0]\n        ),\n        # Case 3: subtle increase\n        (\n            [8000, 9500, 7000, 12000, 10000, 11000, 9000, 10000, 10000, 12000],\n            [3, 3, 2, 4, 3, 8, 6, 7, 7, 8]\n        ),\n        # Case 4: decrease\n        (\n            [10000, 10000, 10000, 10000, 10000, 10000, 10000],\n            [85, 79, 82, 80, 12, 10, 9]\n        )\n    ]\n\n    results = []\n    for N, x in test_cases:\n        result = solve_case(N, x, R_FP, R_FN, DELTA_MIN, LAMBDA)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "5113782"}]}