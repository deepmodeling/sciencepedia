{"hands_on_practices": [{"introduction": "任何分子检测方法都有其固有的检测极限，这源于样本中目标分子的离散性。这项实践将引导你应用泊松统计理论，来计算在给定DNA投入量的情况下，能够被可靠检出的最低甲基化比例。通过这个练习，你将深刻理解样本量、基因组拷贝数以及检测灵敏度之间的定量关系，这是设计和解释MSP实验的关键一步。[@problem_id:5132641]", "problem": "一位研究人员计划进行一项甲基化特异性聚合酶链式反应 (MSP; 甲基化特异性PCR) 检测，该检测针对每个单倍体基因组中的一个单拷贝基因座，以在亚硫酸氢钠转化后检测胞嘧啶甲基化。MSP反应的样本输入为 $10\\,\\mathrm{ng}$ 的人类基因组脱氧核糖核酸 (DNA)，其中人类基因组是二倍体，一个单倍体基因组的质量为 $3.3\\,\\mathrm{pg}$。假设亚硫酸氢钠转化是完美的，引物对甲基化序列具有完美的特异性，并且DNA分子被随机取样进入反应，因此进入MSP的甲基化目标分子的数量可以用泊松过程很好地描述。研究人员将检测阈值定义为反应中存在至少一个甲基化目标分子的概率不小于 $0.95$ 的条件。\n\n仅从关于基因组质量、拷贝数、随机分子取样和泊松分布的核心定义和经过充分验证的事实出发，首先确定 $10\\,\\mathrm{ng}$ 输入样本中存在的目标基因座的预期拷贝数。然后，将反应中甲基化目标分子的数量建模为一个均值为 $\\lambda = f N$ 的泊松随机变量，其中 $f$ 是取样DNA中该基因座的甲基化等位基因比例，而 $N$ 是输入样本中存在的目标基因座的总预期拷贝数。使用检测阈值的定义，推导出在此输入质量下满足该阈值所需的最小甲基化等位基因比例 $f_{\\min}$。以无单位的小数形式表示您的最终答案，并将其四舍五入到四位有效数字。", "solution": "该问题要求在给定特定输入量的人类基因组DNA的情况下，确定在甲基化特异性PCR (MSP) 检测中能够以至少 $95\\%$ 的概率检测到的最小甲基化等位基因比例 $f_{\\min}$。解决方案包括两个主要部分：首先，计算样本中目标DNA分子的总数；其次，应用泊松统计来建模检测概率。\n\n首先，我们确定在 $10\\,\\mathrm{ng}$ 的人类基因组DNA输入中存在的目标基因座的预期总拷贝数，记为 $N$。\n给定数据为：\n输入DNA的总质量，$M_{total} = 10\\,\\mathrm{ng}$。\n一个单倍体人类基因组的质量，$M_{haploid} = 3.3\\,\\mathrm{pg}$。\n\n为了计算基因组的数量，质量单位必须一致。我们使用关系式 $1\\,\\mathrm{ng} = 10^3\\,\\mathrm{pg}$ 将纳克 ($\\mathrm{ng}$) 转换为皮克 ($\\mathrm{pg}$)。\n$$M_{total} = 10\\,\\mathrm{ng} \\times \\frac{10^3\\,\\mathrm{pg}}{1\\,\\mathrm{ng}} = 10^4\\,\\mathrm{pg}$$\n样本中的单倍体基因组当量 ($N_{GE}$) 是DNA总质量与单个单倍体基因组质量之比。\n$$N_{GE} = \\frac{M_{total}}{M_{haploid}} = \\frac{10^4\\,\\mathrm{pg}}{3.3\\,\\mathrm{pg}}$$\n问题陈述该目标是每个单倍体基因组中的一个单拷贝基因座。因此，目标基因座的预期总拷贝数 $N$ 等于单倍体基因组当量的数量。\n$$N = \\frac{10^4}{3.3}$$\n\n其次，我们使用泊松分布对检测过程进行建模。随机取样到反应中的甲基化目标分子数 $X$ 被假定服从泊松分布，$X \\sim \\mathrm{Poisson}(\\lambda)$。该分布的均值 $\\lambda$ 是甲基化目标分子的期望数量。它由甲基化等位基因比例 $f$ 和目标分子总数 $N$ 的乘积给出。\n$$\\lambda = f N$$\n泊松分布的概率质量函数由下式给出：\n$$P(X=k) = \\frac{\\lambda^k \\exp(-\\lambda)}{k!}$$\n其中 $k$ 是事件（甲基化分子）的数量，可以为 $0, 1, 2, \\dots$。\n\n检测阈值被定义为反应中至少有一个甲基化目标分子的概率不小于 $0.95$ 的条件。在数学上，这表示为：\n$$P(X \\ge 1) \\ge 0.95$$\n观察到至少一个分子的概率是观察到零个分子的补集，即 $P(X \\ge 1) = 1 - P(X=0)$。将此代入不等式，得到：\n$$1 - P(X=0) \\ge 0.95$$\n观察到零个甲基化分子 ($k=0$) 的概率是：\n$$P(X=0) = \\frac{\\lambda^0 \\exp(-\\lambda)}{0!} = \\exp(-\\lambda)$$\n将此代回不等式：\n$$1 - \\exp(-\\lambda) \\ge 0.95$$\n我们重新整理不等式以求解 $\\lambda$：\n$$\\exp(-\\lambda) \\le 1 - 0.95$$\n$$\\exp(-\\lambda) \\le 0.05$$\n为了分离 $\\lambda$，我们取两边的自然对数：\n$$\\ln(\\exp(-\\lambda)) \\le \\ln(0.05)$$\n$$-\\lambda \\le \\ln(0.05)$$\n乘以 $-1$ 会反转不等式的方向：\n$$\\lambda \\ge -\\ln(0.05)$$\n使用对数性质 $-\\ln(x) = \\ln(1/x)$，我们有：\n$$\\lambda \\ge \\ln\\left(\\frac{1}{0.05}\\right) = \\ln(20)$$\n因此，满足检测阈值所需的最小平均甲基化分子数为 $\\lambda_{\\min} = \\ln(20)$。\n\n最小甲基化等位基因比例 $f_{\\min}$ 对应于 $\\lambda$ 的这个最小值。我们使用关系式 $\\lambda = f N$：\n$$f_{\\min} N = \\lambda_{\\min} = \\ln(20)$$\n求解 $f_{\\min}$：\n$$f_{\\min} = \\frac{\\ln(20)}{N}$$\n现在，我们代入之前推导出的 $N$ 的表达式：\n$$f_{\\min} = \\frac{\\ln(20)}{10^4 / 3.3} = \\frac{3.3 \\times \\ln(20)}{10^4}$$\n为了获得最终的数值答案，我们使用 $\\ln(20) \\approx 2.995732$ 的值：\n$$f_{\\min} \\approx \\frac{3.3 \\times 2.995732}{10000}$$\n$$f_{\\min} \\approx \\frac{9.8859156}{10000}$$\n$$f_{\\min} \\approx 0.00098859156$$\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $9, 8, 8, 5$。$5$ 后面的数字是 $9$，大于或等于 $5$，所以我们将最后一位有效数字进位。\n$$f_{\\min} \\approx 0.0009886$$\n这是在给定条件下满足指定检测阈值所需的最小甲基化等位基因比例。", "answer": "$$\\boxed{0.0009886}$$", "id": "5132641"}, {"introduction": "亚硫酸氢盐处理的不完全性是MSP实验中假阳性结果的主要来源之一，因为它会使得未甲基化的模板意外地被甲基化特异性引物扩增。本练习通过一个基础的概率模型，让你亲手计算在看似高效的转化率下，一个包含多个CpG位点的DNA片段中，仍存在至少一个未转化胞嘧啶的概率。这个计算将直观地揭示不完全转化对实验特异性的潜在威胁，并强调优化转化效率的重要性。[@problem_id:5132654]", "problem": "在基于亚硫酸氢盐的表观遗传学检测中，未甲基化的胞嘧啶残基在亚硫酸氢钠处理过程中以每个位点$p$的转化概率脱氨基形成尿嘧啶，而甲基化的胞嘧啶则保持不变。考虑一个包含$20$个CpG二核苷酸位点的未甲基化基因座。假设不同CpG胞嘧啶的转化事件是独立同分布的，并且下游的聚合酶链式反应（PCR）扩增能精确复制经过亚硫酸氢盐转化的模板（即，在复制过程中不会引入影响胞嘧啶身份的额外序列错误）。甲基化特异性聚合酶链式反应（MSP）的引物特异性依赖于这样一个预期：引物结合区域内所有未甲基化的CpG胞嘧啶都被转化；任何残留的未转化胞嘧啶都可能模拟甲基化并导致错误引发。\n\n从独立化学转化的伯努利试验模型和概率的补集法则出发，推导出一个表达式，用于描述在这$20$个CpG位点中，经过亚硫酸氢盐处理的DNA分子中至少保留一个未转化胞嘧啶的预期比例，该表达式应是关于$p$和位点数的函数。然后，对于给定的$20$个CpG位点的基因座，在$p = 0.99$的条件下计算该表达式的值。将最终数值结果四舍五入至四位有效数字，并以纯小数形式报告（无单位）。计算出数值后，简要解释该比例如何通过在真实未甲基化模板上造成潜在的假阳性引物引发，从而影响MSP引物的特异性。", "solution": "问题要求推导一个表达式，用以描述经亚硫酸氢盐处理的DNA分子中至少保留一个未转化胞嘧啶的预期比例，然后进行数值计算，并就甲基化特异性PCR（MSP）的特异性进行概念性解释。\n\n在$N$个CpG位点中，每个位点的亚硫酸氢盐转化过程可以建模为一系列独立的伯努利试验。设$N$为CpG位点的数量，给定为$N=20$。设$p$为每个位点上未甲基化的胞嘧啶成功转化为尿嘧啶的概率。题目中指出该概率为$p=0.99$。\n\n对于单个未甲基化的CpG位点，其结果是二元的：\n1. 胞嘧啶成功转化为尿嘧啶，概率为$p$。\n2. 胞嘧啶未能转化，仍然是胞嘧啶，概率为$1-p$。\n\n问题要求的是保留*至少一个*未转化胞嘧啶的分子比例。设$A$为DNA分子在$N=20$个位点中至少有一个未转化胞嘧啶的事件。更直接的方法是先计算其补集事件$A^c$的概率，即*没有*胞嘧啶未转化的事件。这等同于所有$N$个胞嘧啶都成功转化为尿嘧啶的事件。\n\n由于假设$N$个位点上各自的转化事件是独立同分布的，所有$N$个位点都被转化的概率是它们各自概率的乘积：\n$$P(A^c) = P(\\text{site 1 converted AND site 2 converted AND ... AND site N converted})$$\n$$P(A^c) = \\prod_{i=1}^{N} P(\\text{site i converted}) = p \\times p \\times \\dots \\times p = p^N$$\n所求概率$P(A)$是$A^c$的补集事件的概率。根据概率的补集法则，我们有：\n$$P(A) = 1 - P(A^c)$$\n代入$P(A^c)$的表达式，我们得到具有至少一个未转化胞嘧啶的分子比例关于$p$和位点数$N$的通用表达式：\n$$P(A) = 1 - p^N$$\n这就是所要求推导的表达式。\n\n接下来，我们必须用给定的数值来计算这个表达式的值：$N=20$个CpG位点，转化概率$p=0.99$。\n$$P(A) = 1 - (0.99)^{20}$$\n计算$(0.99)^{20}$的值：\n$$(0.99)^{20} \\approx 0.817906939...$$\n现在，我们求最终的概率：\n$$P(A) = 1 - 0.817906939... \\approx 0.182093061...$$\n问题要求将此结果四舍五入至四位有效数字。前四位有效数字是$1$、$8$、$2$和$0$。第五位数字是$9$，大于或等于$5$，所以我们将第四位有效数字向上取整。\n$$P(A) \\approx 0.1821$$\n这是来自完全未甲基化基因座的分子中，预计将被不完全转化的比例。\n\n最后，是关于这个比例如何影响MSP引物特异性的解释：\n甲基化特异性PCR（MSP）使用两对引物：一对（M-引物）设计用于退火到CpG胞嘧啶经过甲基化因而在亚硫酸氢盐处理后仍为胞嘧啶的DNA序列上；另一对（U-引物）则设计用于CpG未经甲基化因而被转化为尿嘧啶（随后被聚合酶读取为胸腺嘧啶）的序列。M-引物对的特异性依赖于其与未甲基化模板中已转化（尿嘧啶/胸腺嘧啶）位点的错配，这种错配应能阻止退火和扩增。\n\n计算出的比例，约$0.1821$或$18.21\\%$，代表了源自完全未甲基化基因座的DNA分子中，由于不完全转化而在某个CpG位置保留了至少一个胞嘧啶的比例。这些分子现在拥有了可以被M-引物识别的序列，模拟了真正甲基化的模板。当M-引物退火到这样一个不完全转化的未甲基化模板上时，它会引发扩增，从而在“甲基化”反应中产生PCR产物。这种现象构成了甲基化的假阳性结果，因为它在没有甲基化的地方指示了甲基化的存在。一个$0.1821$的数值表明，未甲基化模板群体中有相当大的一部分可以作为假阳性引物引发的底物，从而显著降低MSP检测的特异性及其准确区分甲基化和未甲基化状态的能力。", "answer": "$$\\boxed{0.1821}$$", "id": "5132654"}, {"introduction": "将理论知识转化为实际应用是科学研究的核心，而计算机模拟为此提供了强大的平台。这项综合性实践将指导你编写一个生物信息学程序，从头开始模拟MSP的整个流程，包括DNA序列的亚硫酸氢盐转化、单核苷酸多态性（SNP）的影响、引物结合以及扩增子的生成。通过构建这个*in silico*（计算机模拟）实验平台，你不仅能巩固对MSP分子逻辑的理解，还能掌握一个用于预测引物特异性和优化实验设计的宝贵工具。[@problem_id:5132634]", "problem": "您的任务是实现一个完整的、自包含的程序，该程序模拟一个计算机模拟（in silico）流程，用于在一个小型合成基因组上进行甲基化特异性聚合酶链式反应（MSP）引物结合特异性的分析。该流程必须考虑亚硫酸氢盐转化的序列，以及产生或消除胞嘧啶-磷酸-鸟嘌呤（CpG）二核苷酸的单核苷酸多态性（SNPs）的影响。\n\n使用的基本碱基和定义：\n- 在脱氧核糖核酸（DNA）的亚硫酸氢钠转化中，未甲基化的胞嘧啶会脱氨基形成尿嘧啶，在聚合酶链式反应（PCR）后被读取为胸腺嘧啶。甲基化的胞嘧啶则保持为胞嘧啶。因此，在正向链上，未甲基化转化会将每个 $C$ 替换为 $T$；而甲基化转化仅在 $C$ 是 $CpG$ 二核苷酸（一个 $C$ 紧跟着一个 $G$）的一部分时才保留 $C$。所有其他的 $C$ 都被替换为 $T$。\n- Watson–Crick 碱基配对：$A$ 与 $T$ 配对，$C$ 与 $G$ 配对。反向引物结合在底链上；等效地，它与自身序列在正向链上的反向互补序列相匹配。\n- MSP 引物结合特异性要求序列互补。对于本问题，正向和反向引物的匹配均允许最多 $d$ 个错配（汉明距离 $\\le d$）。\n- 一个扩增子由正向引物匹配起始位点（$i$）和反向互补引物匹配起始位点（$j$）在正向链上的索引定义，其长度分别为 $l_f$ 和 $l_r$。它必须满足 $j \\ge i + l_f$ 条件，并且扩增子跨度长度 $$L = j + l_r - i$$ 被限制在允许的区间 $[L_{\\min}, L_{\\max}]$ 内。\n\n基因组模型、SNPs 和引物：\n- 合成重叠群（正向链序列）：\n  - $cA$: \"AAAATTTTACGCGTAAAA\"\n  - $cB$: \"AAAATTTTATTTTTAAAA\"\n  - $cC$: \"AAAATTTTACGTGTAAAA\"\n  - $cD$: \"AAAATTTTACGAGTAAAA\"\n- 已知的单核苷酸多态性（SNPs），每个都以元组 $(\\text{contig\\_id}, p, b_{\\text{ref}}, b_{\\text{alt}})$ 的形式指定，其中 $p$ 为从零开始的位置：\n  - $(cA, 9, C, T)$ 消除了 $cA$ 中的一个 CpG。\n  - $(cC, 11, T, C)$ 在 $cC$ 中创建了一个新的 CpG，从而产生 \"ACGCGT\"。\n- 待评估的引物对：\n  - 甲基化特异性正向引物 $P_f^{(m)}$: \"ACGCGT\"\n  - 未甲基化特异性正向引物 $P_f^{(u)}$: \"ATGTGT\"\n  - 反向引物（通用）$P_r$: \"TTTT\" （要搜索的反向互补序列是 \"AAAA\"）\n- 反向互补序列必须通过规范的碱基配对和字符串反转来推导。\n\n等位基因建模和计数规则：\n- 对于每个重叠群，如果考虑 SNPs，则通过在参考碱基与重叠群匹配的已注释 SNP 位点上应用交替 $b_{\\text{alt}}$ 的所有组合（双等位基因，穷举组合），生成所有等位基因序列。如果不考虑 SNPs，则仅使用参考重叠群序列。\n- 对于给定的引物对和转化状态，对每个等位基因序列执行适当的亚硫酸氢盐转化，并扫描所有满足错配阈值和长度约束的引物对扩增子。\n- 通过取所有重叠群-索引对 $(\\text{contig\\_id}, i, j)$ 的并集来汇总所有等位基因序列的结果，其中 $i$ 是正向引物匹配的起始位置，$j$ 是反向互补引物匹配的起始位置。此并集是产生扩增子的不同基因组位点的集合，忽略等位基因的多重性。\n- 一个测试用例的结果是该并集的基数（一个整数）。\n\n算法要求（为通用实现以数学和逻辑方式表达）：\n- 实现函数 $B_{\\text{meth}}(S)$，将字符串 $S$ 映射到其甲基化转化字符串，方法是将任何后面不跟 $G$ 的 $C$ 替换为 $T$，并保留紧跟 $G$ 的 $C$。实现函数 $B_{\\text{unmeth}}(S)$，方法是将每个 $C$ 替换为 $T$。\n- 为 DNA 字符串 $X$（基于 $\\{A, C, G, T\\}$）实现反向互补函数 $RC(X)$。\n- 实现近似匹配：对于字符串 $S$ 和模式 $Q$，找到所有索引 $k$，使得汉明距离 $H(S[k:k+|Q|], Q) \\le d$。\n- 实现扩增子检测：对于匹配 $P_f$ 的索引 $i$ 和匹配 $RC(P_r)$ 的索引 $j$，如果 $j \\ge i + |P_f|$，并且 $L = j + |RC(P_r)| - i \\in [L_{\\min}, L_{\\max}]$，则接受该配对。\n\n测试套件：\n- 每个测试用例由 $(\\text{conversion}, P_f, P_r, d, L_{\\min}, L_{\\max}, \\text{consider\\_snps})$ 指定，其中 $\\text{conversion} \\in \\{\\text{\"methylated\"}, \\text{\"unmethylated\"}\\}$，$d$ 是整数错配容忍度，$L_{\\min}$ 和 $L_{\\max}$ 是整数，$\\text{consider\\_snps}$ 是布尔值。\n- 需要实现的五个测试用例是：\n  1. $(\\text{\"methylated\"}, \\text{\"ACGCGT\"}, \\text{\"TTTT\"}, 0, 8, 12, \\text{True})$\n  2. $(\\text{\"unmethylated\"}, \\text{\"ATGTGT\"}, \\text{\"TTTT\"}, 0, 8, 12, \\text{True})$\n  3. $(\\text{\"methylated\"}, \\text{\"ACGCGT\"}, \\text{\"TTTT\"}, 0, 11, 12, \\text{True})$ (排除长度 $10$ 的边界情况)\n  4. $(\\text{\"methylated\"}, \\text{\"ACGCGT\"}, \\text{\"TTTT\"}, 1, 8, 12, \\text{True})$ (错配容忍情况)\n  5. $(\\text{\"methylated\"}, \\text{\"ACGCGT\"}, \\text{\"TTTT\"}, 0, 8, 12, \\text{False})$ (仅参考序列情况)\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。每个结果必须是对应于相应测试用例的、如上文定义的并集计数的整数。", "solution": "问题陈述具有科学依据，提法明确，且内部一致。它提出了一个清晰但简化的甲基化特异性PCR（MSP）分析模型，这是分子生物学中的一种标准技术。所有提供的数据、定义和约束足以推导出每个测试用例的唯一确定性解决方案。因此，该问题被认为是有效的，下面提供了完整的解决方案。\n\n该解决方案涉及对实验性MSP过程进行多步计算机模拟。任务的核心是为每个给定的测试用例确定能够产生PCR扩增子的不同基因组位点的数量。一个位点由元组 $(\\text{contig\\_id}, i, j)$ 唯一标识，其中 $\\text{contig\\_id}$ 是DNA重叠群的标识符，$i$ 是正向引物匹配的基于0的起始索引，$j$ 是反向互补引物匹配的基于0的起始索引。每个测试用例的最终结果是所有这些有效位点集合的基数。\n\n该流程可分解为以下步骤：\n1.  **等位基因生成**：对于每个参考重叠群，如果测试用例要求，则根据提供的单核苷酸多态性（SNPs）生成所有可能的等位基因序列。\n2.  **亚硫酸氢盐转化**：将指定的亚硫酸氢盐转化逻辑（$B_{\\text{meth}}$ 或 $B_{\\text{unmeth}}$）应用于每个等位基因序列。\n3.  **引物匹配**：在转化的序列中扫描正向引物（$P_f$）和反向引物的反向互补序列（$RC(P_r)$）的所有可能结合位点，并遵循允许的错配容忍度 $d$。\n4.  **扩增子筛选**：对于在索引 $i$ 处的正向引物匹配和索引 $j$ 处的反向互补引物匹配的每一对，通过检查几何约束（$j \\ge i + l_f$）和长度约束（$L = j + l_r - i \\in [L_{\\min}, L_{\\max}]$）来验证其是否形成有效的扩增子。\n5.  **聚合**：将所有有效的 $(\\text{contig\\_id}, i, j)$ 元组收集到一个集合中以求并集，并报告其大小。\n\n我们首先根据问题中的规定定义必要的数据和函数。\n\n**基因组数据：**\n- 重叠群：\n  - $S_{cA}$: \"AAAATTTTACGCGTAAAA\"\n  - $S_{cB}$: \"AAAATTTTATTTTTAAAA\"\n  - $S_{cC}$: \"AAAATTTTACGTGTAAAA\"\n  - $S_{cD}$: \"AAAATTTTACGAGTAAAA\"\n- SNPs：\n  - $SNP_1$: $(cA, 9, C, T)$\n  - $SNP_2$: $(cC, 11, T, C)$\n- 引物：\n  - $P_f^{(m)}$: \"ACGCGT\" (长度 $l_f=6$)\n  - $P_f^{(u)}$: \"ATGTGT\" (长度 $l_f=6$)\n  - $P_r$: \"TTTT\" (长度 $l_r=4$)\n    - 反向互补序列为 $RC(P_r) = \\text{\"AAAA\"}$。\n\n**核心函数：**\n- **亚硫酸氢盐转化：**\n  - $B_{\\text{unmeth}}(S)$：将字符串 $S$ 中每次出现的 'C' 替换为 'T'。\n  - $B_{\\text{meth}}(S)$：将 $S$ 中的每个 'C' 替换为 'T'，除非该 'C' 后面紧跟着一个 'G'。\n- **等位基因生成**：\n  - 如果 `consider_snps` 为 false，则仅使用参考序列。\n  - 如果 `consider_snps` 为 true：\n    - 对于 $S_{cA}$，我们生成参考序列“AAAATTTTACGCGTAAAA”和备选序列“AAAATTTTATGCGTAAAA”。\n    - 对于 $S_{cC}$，我们生成参考序列“AAAATTTTACGTGTAAAA”和备选序列“AAAATTTTACGCGTAAAA”。\n    - $S_{cB}$ 和 $S_{cD}$ 没有相关的 SNPs，因此只使用它们的参考序列。\n\n我们现在开始分析每个测试用例。\n\n**测试用例 1: $(\\text{\"methylated\"}, P_f=\\text{\"ACGCGT\"}, P_r=\\text{\"TTTT\"}, d=0, L_{\\min}=8, L_{\\max}=12, \\text{consider\\_snps}=\\text{True})$**\n\n在这里，我们使用甲基化转化，完美匹配（$d=0$），并考虑 SNPs。$l_f=6$, $l_r=4$, $RC(P_r)=\\text{\"AAAA\"}$。\n\n- **重叠群 $cA$**：\n  - 参考等位基因 $S_{cA,ref}$: \"AAAATTTTACGCGTAAAA\"\n    - $B_{\\text{meth}}(S_{cA,ref})$: 索引9处的`C`和索引11处的`C`都是`CG`二核苷酸的一部分，因此被保留。转化后的序列是`S' = \"AAAATTTTACGCGTAAAA\"`。\n    - 正向引物 $P_f$ 在索引 $i=8$ 处匹配 \"ACGCGT\"。\n    - 反向引物 $RC(P_r)$ 在索引 $j=0$ 和 $j=14$ 处匹配 \"AAAA\"。\n    - 对于 $(i=8, j=14)$: 检查 $j \\ge i + l_f \\Rightarrow 14 \\ge 8 + 6 \\Rightarrow 14 \\ge 14$。此条件成立。\n    - 跨度长度 $L = j + l_r - i = 14 + 4 - 8 = 10$。\n    - 长度约束：$8 \\le 10 \\le 12$。此条件成立。\n    - 找到有效扩增子：$(\\text{'cA'}, 8, 14)$。\n  - 备选等位基因 $S_{cA,alt}$: \"AAAATTTTATGCGTAAAA\"\n    - $B_{\\text{meth}}(S_{cA,alt})$: 索引11处的`C`是`CG`对的一部分，被保留。转化后的序列是`S' = \"AAAATTTTATGCGTAAAA\"`。\n    - $P_f$ 无法完美匹配 \"ACGCGT\"。无扩增子。\n\n- **重叠群 $cB$**: 没有 `C`，因此 $P_f$ 没有匹配项。无扩增子。\n\n- **重叠群 $cC$**：\n  - 参考等位基因 $S_{cC,ref}$: \"AAAATTTTACGTGTAAAA\"\n    - $B_{\\text{meth}}(S_{cC,ref})$: 索引9处的`C`是`CG`的一部分，被保留。`_S'_ = \"AAAATTTTACGTGTAAAA\"`。\n    - `S'[8:14]` 是 \"ACGTGT\"，与 \"ACGCGT\" 不匹配。无扩增子。\n  - 备选等位基因 $S_{cC,alt}$: \"AAAATTTTACGCGTAAAA\" (与 $S_{cA,ref}$ 相同)\n    - 如对 $S_{cA,ref}$ 的计算，该等位基因在 $(\\text{'cC'}, 8, 14)$ 处产生一个有效扩增子。\n\n- **重叠群 $cD$**：\n  - 参考等位基因 $S_{cD,ref}$: \"AAAATTTTACGAGTAAAA\"\n    - $B_{\\textmeth}(S_{cD,ref})$ 保留索引9处的`CG`，得到`S' = \"AAAATTTTACGAGTAAAA\"`。\n    - `S'[8:14]` 是 \"ACGAGT\"，与 \"ACGCGT\" 不匹配。无扩增子。\n\n**结果 1**：唯一的扩增子集合是 $\\{(\\text{'cA'}, 8, 14), (\\text{'cC'}, 8, 14)\\}$。其基数为 $2$。\n\n**测试用例 2: $(\\text{\"unmethylated\"}, P_f=\\text{\"ATGTGT\"}, P_r=\\text{\"TTTT\"}, d=0, L_{\\min}=8, L_{\\max}=12, \\text{consider\\_snps}=\\text{True})$**\n\n在这里，我们使用未甲基化转化。$P_f=\\text{\"ATGTGT\"}$。\n\n- **重叠群 $cA$**：\n  - 参考等位基因和备选等位基因（\"AAAATTTTACGCGTAAAA\" 和 \"AAAATTTTATGCGTAAAA\"）在 $B_{\\text{unmeth}}$ 转化下都变成 \"AAAATTTTATGTGTTAAA\"。\n  - $P_f$ \"ATGTGT\" 在 $i=8$ 处匹配。\n  - $RC(P_r)$ \"AAAA\" 在 $j=0$ 和 $j=14$ 处匹配。\n  - 对于 $(i=8, j=14)$: $14 \\ge 8 + 6 = 14$ (成立)。$L = 14 + 4 - 8 = 10$。$8 \\le 10 \\le 12$ (成立)。\n  - 有效扩增子：$(\\text{'cA'}, 8, 14)$。\n\n- **重叠群 $cB$**: 没有 `C`，因此 $P_f$ 没有匹配项。无扩增子。\n\n- **重叠群 $cC$**：\n  - 参考等位基因 $S_{cC,ref}$: \"AAAATTTTACGTGTAAAA\" $\\xrightarrow{B_{\\text{unmeth}}}$ \"AAAATTTTATGTGTAAAA\"。\n  - $P_f$ \"ATGTGT\" 在 $i=8$ 处匹配。$RC(P_r)$ 在 $j=0, 14$ 处匹配。\n  - 这产生一个有效扩增子 $(\\text{'cC'}, 8, 14)$。\n  - 备选等位基因也产生相同的位点。\n\n- **重叠群 $cD$**：\n  - 参考等位基因 $S_{cD,ref}$: \"AAAATTTTACGAGTAAAA\" $\\xrightarrow{B_{\\text{unmeth}}}$ \"AAAATTTTATGAGTAAAA\"。\n  - $P_f$ \"ATGTGT\" 与 \"ATGAGT\" 在 $d=0$ 的条件下不匹配。无扩增子。\n\n**结果 2**：唯一的扩增子集合是 $\\{(\\text{'cA'}, 8, 14), (\\text{'cC'}, 8, 14)\\}$。其基数为 $2$。\n\n**测试用例 3: $(\\text{\"methylated\"}, P_f=\\text{\"ACGCGT\"}, P_r=\\text{\"TTTT\"}, d=0, L_{\\min}=11, L_{\\max}=12, \\text{consider\\_snps}=\\text{True})$**\n\n这与案例1相同，但扩增子长度 $L$ 必须在 $[11, 12]$ 区间内。\n在案例1中，找到的两个扩增子的长度都为 $L=10$。\n由于 $10$ 不在区间 $[11, 12]$ 内，因此没有有效的扩增子。\n\n**结果 3**：基数为 $0$。\n\n**测试用例 4: $(\\text{\"methylated\"}, P_f=\\text{\"ACGCGT\"}, P_r=\\text{\"TTTT\"}, d=1, L_{\\min}=8, L_{\\max}=12, \\text{consider\\_snps}=\\text{True})$**\n\n这是案例1，但错配容忍度为 $d=1$。\n\n- **重叠群 $cA$**：\n  - 参考等位基因: `S' = \"AAAATTTTACGCGTAAAA\"`。`S'[8:14]`=\"ACGCGT\"，与 $P_f$ 的汉明距离 $H=0 \\le 1$。形成有效扩增子 $(\\text{'cA'}, 8, 14)$。\n  - 备选等位基因: `S' = \"AAAATTTTATGCGTAAAA\"`。`S'[8:14]`=\"ATGCGT\"，与 $P_f$ 的 $H=1 \\le 1$。形成有效扩增子 $(\\text{'cA'}, 8, 14)$。\n- **重叠群 $cB$**: 仍然没有匹配项。\n- **重叠群 $cC$**：\n  - 参考等位基因: `S' = \"AAAATTTTACGTGTAAAA\"`。`S'[8:14]`=\"ACGTGT\"，与 $P_f$ 的 $H=1 \\le 1$。形成有效扩增子 $(\\text{'cC'}, 8, 14)$。\n  - 备选等位基因: `S' = \"AAAATTTTACGCGTAAAA\"`。`S'[8:14]`=\"ACGCGT\"，与 $P_f$ 的 $H=0 \\le 1$。形成有效扩增子 $(\\text{'cC'}, 8, 14)$。\n- **重叠群 $cD$**：\n  - 参考等位基因: `S' = \"AAAATTTTACGAGTAAAA\"`。`S'[8:14]`=\"ACGAGT\"，与 $P_f$ 的 $H=1 \\le 1$。形成有效扩增子 $(\\text{'cD'}, 8, 14)$。\n\n**结果 4**：唯一的扩增子集合是 $\\{(\\text{'cA'}, 8, 14), (\\text{'cC'}, 8, 14), (\\text{'cD'}, 8, 14)\\}$。其基数为 $3$。\n\n**测试用例 5: $(\\text{\"methylated\"}, P_f=\\text{\"ACGCGT\"}, P_r=\\text{\"TTTT\"}, d=0, L_{\\min}=8, L_{\\max}=12, \\text{consider\\_snps}=\\text{False})$**\n\n这是案例1，但忽略SNPs（仅考虑参考等位基因）。\n- **重叠群 $cA$**：参考等位基因产生有效扩增子 $(\\text{'cA'}, 8, 14)$。\n- **重叠群 $cB$**: 无扩增子。\n- **重叠群 $cC$**: 参考等位基因不能与 $P_f$ 完美匹配。无扩增子。\n- **重叠群 $cD$**: 参考等位基因不能与 $P_f$ 完美匹配。无扩增子。\n\n**结果 5**：唯一的扩增子集合是 $\\{(\\text{'cA'}, 8, 14)\\}$。其基数为 $1$。\n\n**最终结果摘要：**\n1.  案例 1: $2$\n2.  案例 2: $2$\n3.  案例 3: $0$\n4.  案例 4: $3$\n5.  案例 5: $1$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to run the in silico MSP simulation for all test cases.\n    \"\"\"\n\n    # --- Define Givens ---\n\n    contigs = {\n        \"cA\": \"AAAATTTTACGCGTAAAA\",\n        \"cB\": \"AAAATTTTATTTTTAAAA\",\n        \"cC\": \"AAAATTTTACGTGTAAAA\",\n        \"cD\": \"AAAATTTTACGAGTAAAA\",\n    }\n\n    # SNPs are (contig_id, position, ref_base, alt_base)\n    # Group SNPs by contig_id for easier processing\n    snps_by_contig = {\n        \"cA\": [(9, 'C', 'T')],\n        \"cC\": [(11, 'T', 'C')]\n    }\n    \n    # --- Core Scientific Functions ---\n\n    COMPLEMENT = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n\n    def reverse_complement(seq: str) - str:\n        \"\"\"Computes the reverse complement of a DNA sequence.\"\"\"\n        return \"\".join(COMPLEMENT.get(base, base) for base in reversed(seq))\n\n    def bisulfite_convert(seq: str, conversion_type: str) - str:\n        \"\"\"\n        Applies bisulfite conversion to a DNA sequence based on its methylation state.\n        \"\"\"\n        if conversion_type == \"unmethylated\":\n            return seq.replace('C', 'T')\n        elif conversion_type == \"methylated\":\n            new_seq = []\n            i = 0\n            while i  len(seq):\n                if seq[i] == 'C':\n                    if i + 1  len(seq) and seq[i+1] == 'G':\n                        new_seq.append('C') # Preserve C in CpG\n                    else:\n                        new_seq.append('T') # Convert C not in CpG\n                else:\n                    new_seq.append(seq[i])\n                i += 1\n            return \"\".join(new_seq)\n        return seq\n\n    def hamming_distance(s1: str, s2: str) - int:\n        \"\"\"Calculates Hamming distance between two equal-length strings.\"\"\"\n        return sum(c1 != c2 for c1, c2 in zip(s1, s2))\n\n    def find_matches(sequence: str, pattern: str, d: int) - list[int]:\n        \"\"\"Finds all start indices of a pattern in a sequence with at most d mismatches.\"\"\"\n        matches = []\n        len_p = len(pattern)\n        len_s = len(sequence)\n        for i in range(len_s - len_p + 1):\n            substring = sequence[i:i+len_p]\n            if hamming_distance(substring, pattern) = d:\n                matches.append(i)\n        return matches\n\n    def generate_alleles(contig_id: str, contig_seq: str, consider_snps: bool) - list[str]:\n        \"\"\"\n        Generates all allele sequences for a contig.\n        \"\"\"\n        if not consider_snps or contig_id not in snps_by_contig:\n            return [contig_seq]\n\n        contig_snps = snps_by_contig[contig_id]\n        \n        # In this problem, each contig has at most 1 SNP, so we handle it simply.\n        # A more general implementation would use itertools.product for all SNP combinations.\n        if not contig_snps:\n             return [contig_seq]\n\n        ref_list = list(contig_seq)\n        p, ref_base, alt_base = contig_snps[0]\n        \n        if ref_list[p] != ref_base:\n            # SNP data is inconsistent with the reference, just return the reference\n            return [contig_seq]\n\n        alt_list = list(contig_seq)\n        alt_list[p] = alt_base\n\n        return [\"\".join(ref_list), \"\".join(alt_list)]\n\n\n    def process_case(case_params) - int:\n        \"\"\"\n        Processes a single test case and returns the number of unique amplicons.\n        \"\"\"\n        conv_type, p_f, p_r, d, l_min, l_max, consider_snps = case_params\n        \n        p_r_rc = reverse_complement(p_r)\n        l_f = len(p_f)\n        l_r = len(p_r_rc)\n        \n        distinct_amplicons = set()\n\n        for contig_id, contig_seq in contigs.items():\n            allele_sequences = generate_alleles(contig_id, contig_seq, consider_snps)\n            \n            for allele_seq in allele_sequences:\n                converted_seq = bisulfite_convert(allele_seq, conv_type)\n                \n                forward_matches = find_matches(converted_seq, p_f, d)\n                reverse_matches = find_matches(converted_seq, p_r_rc, d)\n                \n                for i in forward_matches:\n                    for j in reverse_matches:\n                        # Check geometric constraint\n                        if j >= i + l_f:\n                            # Calculate and check amplicon span length\n                            amplicon_len = j + l_r - i\n                            if l_min = amplicon_len = l_max:\n                                distinct_amplicons.add((contig_id, i, j))\n                                \n        return len(distinct_amplicons)\n\n    # --- Test Suite Execution ---\n\n    test_cases = [\n        (\"methylated\", \"ACGCGT\", \"TTTT\", 0, 8, 12, True),\n        (\"unmethylated\", \"ATGTGT\", \"TTTT\", 0, 8, 12, True),\n        (\"methylated\", \"ACGCGT\", \"TTTT\", 0, 11, 12, True),\n        (\"methylated\", \"ACGCGT\", \"TTTT\", 1, 8, 12, True),\n        (\"methylated\", \"ACGCGT\", \"TTTT\", 0, 8, 12, False),\n    ]\n\n    results = [process_case(case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "5132634"}]}