{"hands_on_practices": [{"introduction": "DNA甲基化分析的基础始于对单个CpG位点的精确定量。亚硫酸氢盐测序等技术为我们提供了每个位点甲基化（C）与未甲基化（T）的读取计数。这个练习将带你实践最核心的步骤：如何从原始读取计数中计算甲基化比例，并使用统计学上更稳健的威尔逊置信区间（Wilson score interval）来量化我们对该比例估计的不确定性 [@problem_id:5109692]。掌握这一基本功是解读所有甲基化数据的前提。", "problem": "为定量结直肠肿瘤活检样本中单个胞嘧啶-磷酸-鸟嘌呤 (CpG) 位点的胞嘧啶甲基化水平，我们进行了一项靶向亚硫酸氢盐测序分析。在亚硫酸氢钠转化过程中，未甲基化的胞嘧啶被脱氨基转化为尿嘧啶（在聚合酶链式反应 (PCR) 和测序后被读取为胸腺嘧啶），而甲基化的胞嘧啶则能抵抗这种转化，并被读取为胞嘧啶。经过严格的质量控制（去除重复读数和碱基质量过滤）后，该位点的测序覆盖度为 $n = 120$ 条读数，其中有 $k = 54$ 条读数被判定为甲基化胞嘧啶。假设在抽样的细胞群体中，对于这个 CpG 位点，每条读数都是一次独立的伯努利试验，其真实甲基化概率为 $p$，并且相对于抽样变异性，未转化和碱基识别错误可以忽略不计。\n\n使用二项抽样模型作为基本依据，并基于标准正态参考分布，在 $0.95$ 的双侧置信水平下，计算：\n1. 甲基化比例 $\\hat{p}$。\n2. 通过反演二项比例的得分检验，得到的 $p$ 在 $0.95$ 水平下的 Wilson 得分置信区间。\n\n按 $(\\hat{p}, L, U)$ 的顺序报告你的三个最终数值，其中 $L$ 和 $U$ 分别是置信下限和上限。将所有三个数值表示为小数（而不是百分比），并四舍五入到四位有效数字。", "solution": "根据实验设计，该测量过程可以映射到一个二项模型：假设在质量控制后系统误差可以忽略不计，那么每条覆盖 CpG 位点的读数都可以看作是一次独立的伯努利试验，观察到甲基化胞嘧啶的概率为 $p$。因此，甲基化读数的计数 $k$ 服从 $k \\sim \\mathrm{Binomial}(n, p)$ 分布，而 $p$ 的标准估计量是样本比例\n$$\n\\hat{p} \\equiv \\frac{k}{n}.\n$$\n对于目标覆盖率为 $0.95$ 的区间估计，一种比朴素的 Wald 区间能更好地控制覆盖率的常用方法是 Wilson 得分区间，它是通过对原假设 $H_{0}: p = p_{0}$ 的得分检验进行反演推导得出的。\n\n从参数为 $p$ 的二项似然出发，得分检验统计量（在 $H_{0}$ 下通过 Fisher 信息进行归一化）为\n$$\nS(p_{0}) \\equiv \\frac{\\hat{p} - p_{0}}{\\sqrt{\\frac{p_{0}(1 - p_{0})}{n}}}.\n$$\n在水平 $\\alpha$ 下的双侧得分检验在 $|S(p_{0})| > z$ 时拒绝 $H_{0}$，其中 $z$ 是标准正态分布的上 $(1-\\alpha/2)$ 分位数。$(1-\\alpha)$ Wilson 得分置信集是所有未被拒绝的 $p_{0}$ 的集合：\n$$\n\\left| \\frac{\\hat{p} - p_{0}}{\\sqrt{\\frac{p_{0}(1 - p_{0})}{n}}} \\right| \\leq z.\n$$\n将两边平方并重新整理，得到一个关于 $p_0$ 的二次不等式：\n$$\n\\frac{(\\hat{p} - p_{0})^{2}}{\\frac{p_{0}(1 - p_{0})}{n}} \\leq z^{2}\n\\;\\;\\Longleftrightarrow\\;\\;\nn(\\hat{p} - p_{0})^{2} \\leq z^{2} p_{0}(1 - p_{0}).\n$$\n展开并合并左边的项：\n$$\nn\\hat{p}^{2} - 2n\\hat{p}p_{0} + np_{0}^{2} - z^{2}p_{0} + z^{2}p_{0}^{2} \\leq 0,\n$$\n我们可以将其写为\n$$\n(n + z^{2})p_{0}^{2} - (2n\\hat{p} + z^{2})p_{0} + n\\hat{p}^{2} \\leq 0.\n$$\n满足此不等式的 $p_{0}$ 集合是二次方程 $(n + z^{2})p_{0}^{2} - (2n\\hat{p} + z^{2})p_{0} + n\\hat{p}^{2} = 0$ 的两个根之间的区间。使用求根公式，这两个根是\n$$\np_{0} \\;=\\; \\frac{(2n\\hat{p} + z^{2}) \\pm \\sqrt{(2n\\hat{p} + z^{2})^{2} - 4(n + z^{2})n\\hat{p}^{2}}}{2(n + z^{2})}.\n$$\n判别式简化如下：\n$$\n\\begin{aligned}\n(2n\\hat{p} + z^{2})^{2} - 4(n + z^{2})n\\hat{p}^{2}\n= 4n^{2}\\hat{p}^{2} + 4n\\hat{p}z^{2} + z^{4} - 4n^{2}\\hat{p}^{2} - 4n z^{2}\\hat{p}^{2} \\\\\n= z^{2}\\!\\left(z^{2} + 4n\\hat{p}(1 - \\hat{p})\\right).\n\\end{aligned}\n$$\n因此，Wilson 得分区间可以写成代数上等价且常用的形式\n$$\n\\left[\\,L, U\\,\\right] \\;=\\; \\frac{\\hat{p} + \\frac{z^{2}}{2n} \\;\\pm\\; z\\sqrt{\\frac{\\hat{p}(1 - \\hat{p})}{n} + \\frac{z^{2}}{4n^{2}}}}{1 + \\frac{z^{2}}{n}}.\n$$\n\n现在我们代入观测值。点估计为\n$$\n\\hat{p} \\;=\\; \\frac{k}{n} \\;=\\; \\frac{54}{120} \\;=\\; 0.45.\n$$\n对于 $0.95$ 的双侧置信水平，我们取 $z \\approx 1.96$ 并计算各个组成部分：\n$$\n\\frac{z^{2}}{n} \\;=\\; \\frac{3.8416}{120} \\;=\\; 0.032013333\\ldots,\\quad\n1 + \\frac{z^{2}}{n} \\;=\\; 1.032013333\\ldots,\n$$\n$$\n\\hat{p} + \\frac{z^{2}}{2n} \\;=\\; 0.45 + \\frac{3.8416}{240} \\;=\\; 0.466006666\\ldots,\n$$\n$$\n\\frac{\\hat{p}(1 - \\hat{p})}{n} + \\frac{z^{2}}{4n^{2}}\n\\;=\\; \\frac{0.45 \\times 0.55}{120} + \\frac{3.8416}{4 \\times 120^{2}}\n\\;=\\; 0.0020625 + 0.000066694444\\ldots\n\\;=\\; 0.002129194444\\ldots,\n$$\n$$\nz\\sqrt{\\frac{\\hat{p}(1 - \\hat{p})}{n} + \\frac{z^{2}}{4n^{2}}}\n\\;=\\; 1.96 \\times \\sqrt{0.002129194444\\ldots}\n\\;=\\; 1.96 \\times 0.046143192\\ldots\n\\;=\\; 0.09043786\\ldots.\n$$\n因此，\n$$\nL \\;=\\; \\frac{0.466006666\\ldots - 0.09043786\\ldots}{1.032013333\\ldots}\n\\;=\\; \\frac{0.375568806\\ldots}{1.032013333\\ldots}\n\\;=\\; 0.363919\\ldots,\n$$\n$$\nU \\;=\\; \\frac{0.466006666\\ldots + 0.09043786\\ldots}{1.032013333\\ldots}\n\\;=\\; \\frac{0.556444526\\ldots}{1.032013333\\ldots}\n\\;=\\; 0.539184\\ldots.\n$$\n\n四舍五入到四位有效数字并表示为小数（而非百分比），所求的三元组 $(\\hat{p}, L, U)$ 是\n$$\n\\hat{p} = 0.4500,\\quad L = 0.3639,\\quad U = 0.5392.\n$$\n在此分子和免疫诊断背景下，这些结果在科学上是合适的，因为二项模型在独立性假设下捕捉了读数级别的甲基化判定，并且对于靶向测序分析中经常遇到的中等覆盖度 $n$，Wilson 区间相比 Wald 区间提供了更好的覆盖特性。", "answer": "$$\\boxed{\\begin{pmatrix}0.4500  0.3639  0.5392\\end{pmatrix}}$$", "id": "5109692"}, {"introduction": "在量化了单个CpG位点的甲基化水平后，我们可以探索多个位点组合形成的模式及其生物学意义。其中，“表观遗传时钟”是一个革命性的应用，它通过一组特定CpG位点的甲基化水平来预测生物学年龄。本练习将让你亲手操作一个简化的表观遗传时钟模型，计算一个样本的表观遗传年龄，并与其生理年龄进行比较，从而得出“年龄加速”这一重要生物标志物 [@problem_id:5109709]。这将帮助你理解高维甲基化数据如何被转化为有临床意义的预测指标。", "problem": "一个用于全血的监督性表观遗传时钟，是使用标准化的胞嘧啶-磷酸-鸟嘌呤（CpG）甲基化分数（Beta值）和一个带有恒等连接的线性回归模型训练得到的。对于一个具有测得的CpG Beta值的给定样本，该模型将表观遗传年龄预测为标准化输入的仿射函数。每个CpG特征的标准化（z-score计算）使用训练队列的均值和标准差。年龄加速在操作上定义为预测的表观遗传年龄与个体生理年龄之差。\n\n现给定一个六-CpG时钟的以下信息。设CpG位点由 $i \\in \\{1,2,3,4,5,6\\}$ 索引。每个CpG的训练队列均值和标准差如下：\n- $\\mu_{1} = 0.74$, $\\sigma_{1} = 0.05$; $\\mu_{2} = 0.36$, $\\sigma_{2} = 0.04$; $\\mu_{3} = 0.81$, $\\sigma_{3} = 0.03$;\n- $\\mu_{4} = 0.42$, $\\sigma_{4} = 0.06$; $\\mu_{5} = 0.55$, $\\sigma_{5} = 0.05$; $\\mu_{6} = 0.18$, $\\sigma_{6} = 0.02$。\n\n对于该样本，测得的CpG Beta值如下：\n- $\\beta_{1} = 0.70$, $\\beta_{2} = 0.40$, $\\beta_{3} = 0.79$, $\\beta_{4} = 0.50$, $\\beta_{5} = 0.60$, $\\beta_{6} = 0.17$。\n\n训练好的模型系数（特征权重）和截距如下：\n- $w_{1} = 8.0$, $w_{2} = -5.5$, $w_{3} = 12.0$, $w_{4} = 4.0$, $w_{5} = 6.5$, $w_{6} = -9.0$, 以及截距 $b_{0} = 52.0$。\n\n该个体的生理年龄为 $50.0$ 岁。\n\n从z-score计算和带有恒等连接的线性回归预测的核心定义出发，计算：\n1. 模型为该样本预测的表观遗传年龄 $\\hat{A}$。\n2. 年龄加速 $\\Delta A$，定义为 $\\hat{A}$ 减去生理年龄。\n\n将两个输出均以年为单位表示，并将最终数值结果四舍五入到四位有效数字。", "solution": "问题陈述经评估为有效。它有科学依据、良定、客观且自洽，为得出唯一解提供了所有必要的数据和定义。使用CpG甲基化Beta值、z-score计算和线性回归的表观遗传时钟这一背景，是生物信息学和分子诊断学中的一种标准且成熟的方法论。所有提供的关于均值、标准差、Beta值和模型系数的数值都是合理的。该问题要求应用已定义的数学步骤，不存在逻辑矛盾、歧义或信息缺失。\n\n解题过程首先计算六个CpG位点各自的标准化输入特征（z-scores），然后使用这些特征在给定的线性回归模型中预测表观遗传年龄。最后，根据其定义计算年龄加速。\n\n问题陈述指出，线性模型的输入特征是标准化的Beta值，即z-scores。第$i$个CpG位点的z-score，记为$z_i$，使用以下公式计算：\n$$z_i = \\frac{\\beta_i - \\mu_i}{\\sigma_i}$$\n其中 $\\beta_i$ 是样本测得的Beta值，$\\mu_i$ 和 $\\sigma_i$ 分别是来自训练队列的均值和标准差。\n\n我们为六个CpG位点（$i \\in \\{1, 2, 3, 4, 5, 6\\}$）中的每一个计算z-score：\n1.  对于CpG位点 $1$：$\\beta_1 = 0.70$, $\\mu_1 = 0.74$, $\\sigma_1 = 0.05$。\n    $$z_1 = \\frac{0.70 - 0.74}{0.05} = \\frac{-0.04}{0.05} = -0.8$$\n2.  对于CpG位点 $2$：$\\beta_2 = 0.40$, $\\mu_2 = 0.36$, $\\sigma_2 = 0.04$。\n    $$z_2 = \\frac{0.40 - 0.36}{0.04} = \\frac{0.04}{0.04} = 1.0$$\n3.  对于CpG位点 $3$：$\\beta_3 = 0.79$, $\\mu_3 = 0.81$, $\\sigma_3 = 0.03$。\n    $$z_3 = \\frac{0.79 - 0.81}{0.03} = \\frac{-0.02}{0.03} = -\\frac{2}{3}$$\n4.  对于CpG位点 $4$：$\\beta_4 = 0.50$, $\\mu_4 = 0.42$, $\\sigma_4 = 0.06$。\n    $$z_4 = \\frac{0.50 - 0.42}{0.06} = \\frac{0.08}{0.06} = \\frac{4}{3}$$\n5.  对于CpG位点 $5$：$\\beta_5 = 0.60$, $\\mu_5 = 0.55$, $\\sigma_5 = 0.05$。\n    $$z_5 = \\frac{0.60 - 0.55}{0.05} = \\frac{0.05}{0.05} = 1.0$$\n6.  对于CpG位点 $6$：$\\beta_6 = 0.17$, $\\mu_6 = 0.18$, $\\sigma_6 = 0.02$。\n    $$z_6 = \\frac{0.17 - 0.18}{0.02} = \\frac{-0.01}{0.02} = -0.5$$\n\n表观遗传年龄 $\\hat{A}$ 通过仿射函数（带有截距的线性回归模型）预测：\n$$\\hat{A} = b_0 + \\sum_{i=1}^{6} w_i z_i$$\n其中 $b_0$ 是截距，$w_i$ 是模型系数。代入给定的系数和计算出的z-scores：\n$$b_0 = 52.0, w_1 = 8.0, w_2 = -5.5, w_3 = 12.0, w_4 = 4.0, w_5 = 6.5, w_6 = -9.0$$\n求和项为：\n$$\\sum_{i=1}^{6} w_i z_i = w_1 z_1 + w_2 z_2 + w_3 z_3 + w_4 z_4 + w_5 z_5 + w_6 z_6$$\n$$\\sum_{i=1}^{6} w_i z_i = (8.0)(-0.8) + (-5.5)(1.0) + (12.0)(-\\frac{2}{3}) + (4.0)(\\frac{4}{3}) + (6.5)(1.0) + (-9.0)(-0.5)$$\n$$\\sum_{i=1}^{6} w_i z_i = -6.4 - 5.5 - 8.0 + \\frac{16}{3} + 6.5 + 4.5$$\n对各项求和，在必要时使用分数以保持精度：\n$$\\sum_{i=1}^{6} w_i z_i = -19.9 + 11.0 + \\frac{16}{3} = -8.9 + \\frac{16}{3} = -\\frac{89}{10} + \\frac{16}{3} = \\frac{-267 + 160}{30} = -\\frac{107}{30}$$\n作为小数，其近似值为 $-3.5666...$。\n\n现在，我们计算预测的表观遗传年龄 $\\hat{A}$：\n$$\\hat{A} = 52.0 + (-\\frac{107}{30}) = \\frac{1560}{30} - \\frac{107}{30} = \\frac{1453}{30} \\approx 48.4333... \\text{ 年}$$\n将此结果四舍五入到四位有效数字，得到：\n$$\\hat{A} \\approx 48.43 \\text{ 年}$$\n\n接下来，我们计算年龄加速 $\\Delta A$，其定义为预测的表观遗传年龄与生理年龄 $A_{chrono}$ 之差：\n$$\\Delta A = \\hat{A} - A_{chrono}$$\n给定生理年龄 $A_{chrono} = 50.0$ 岁，为保证准确性，我们使用未四舍五入的 $\\hat{A}$ 值：\n$$\\Delta A = \\frac{1453}{30} - 50.0 = \\frac{1453}{30} - \\frac{1500}{30} = -\\frac{47}{30} \\approx -1.5666... \\text{ 年}$$\n将此结果四舍五入到四位有效数字，得到：\n$$\\Delta A \\approx -1.567 \\text{ 年}$$\n\n要求的两个值是表观遗传年龄 $\\hat{A}$ 和年龄加速 $\\Delta A$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n48.43  -1.567\n\\end{pmatrix}\n}\n$$", "id": "5109709"}, {"introduction": "在疾病研究中，我们不仅要预测，更要进行推断——例如，检验疾病状态是否与特定位点的甲基化水平相关。然而，年龄、性别、细胞类型异质性或实验批次等混杂因素常常会干扰我们的判断。本练习将引导你使用广义线性模型（Generalized Linear Model, GLM），这是处理此类问题的标准统计工具，对亚硫酸氢盐测序的计数数据进行建模 [@problem_id:5109769]。你将学习如何在一个模型中同时考虑疾病状态、年龄和批次效应，并正确地解释模型系数，将其转化为赔率比（odds ratio）和预测概率差异，从而获得对疾病生物学机制的严谨洞见。", "problem": "给定独立的个体聚合亚硫酸氢盐测序数据，用于测量胞嘧啶-磷酸-鸟嘌呤（CpG）位点的DNA甲基化。对于每个个体 $i$，您会观测到甲基化读取计数 $m_i$ 和总读取计数 $n_i$，以及协变量疾病状态 $D_i$（对照组 $0$，疾病组 $1$）、年龄 $A_i$（以年为单位）和批次 $B_i$（分类变量：A、B 或 C）。假设甲基化比例建模遵循分子和免疫诊断学中的以下基本原则：每个 $m_i$ 在给定 $n_i$ 和甲基化概率 $p_i$ 的情况下，服从一个二项分布随机变量，记为 $m_i \\sim \\mathrm{Binomial}(n_i,p_i)$，其中甲基化比例 $p_i \\in (0,1)$ 以小数形式表示。设协变量对甲基化概率的影响通过一个带有 logit 连接函数的广义线性模型联系起来，定义为 $\\mathrm{logit}(p_i)=\\log\\left(\\frac{p_i}{1-p_i}\\right)=\\mathbf{x}_i^\\top\\boldsymbol{\\beta}$，其中设计向量 $\\mathbf{x}_i$ 包括一个截距、$D_i$、$A_i$ 以及 $B_i$ 的批次指示变量，并将批次 B作为参考类别。使用虚拟变量，使得 $\\mathbf{x}_i=[1,D_i,A_i,\\mathbb{I}(B_i=\\mathrm{A}),\\mathbb{I}(B_i=\\mathrm{C})]$。\n\n您的任务是，对以下三个测试用例，通过最大似然估计来拟合该广义线性模型，并为每个用例计算以下用于解释疾病系数的量：\n- 估计的疾病状态系数 $\\hat{\\beta}_{\\mathrm{disease}}$（浮点数）。\n- 疾病状态的比值比 $\\exp(\\hat{\\beta}_{\\mathrm{disease}})$（浮点数）。\n- 在标准正态近似下，$\\hat{\\beta}_{\\mathrm{disease}}$ 的双边沃尔德检验 $p$ 值（浮点数），以小数形式报告。\n- 一个布尔值，指示疾病是否增加甲基化概率，定义为 $\\exp(\\hat{\\beta}_{\\mathrm{disease}})>1$。\n- 在年龄为 $A^\\ast$、批次为 B 的固定参考协变量配置下，预测甲基化概率的差异，等于 $\\Delta p = \\sigma(\\hat{\\beta}_0+\\hat{\\beta}_A A^\\ast+\\hat{\\beta}_{\\mathrm{disease}})-\\sigma(\\hat{\\beta}_0+\\hat{\\beta}_A A^\\ast)$，其中 $\\sigma(z)=\\frac{1}{1+\\exp(-z)}$，$A^\\ast$ 固定为 $60$，并将 A 和 C 的批次指示变量设为 $0$ 以代表参考批次 B。将 $\\Delta p$ 报告为小数。\n\n遵循以下通用建模说明：\n- 使用二项模型 $m_i \\sim \\mathrm{Binomial}(n_i,p_i)$ 和典范 logit 连接函数 $\\mathrm{logit}(p_i)=\\mathbf{x}_i^\\top\\boldsymbol{\\beta}$。\n- 构建设计矩阵，包含截距和指定的协变量，将批次 B 视为参考类别，使其虚拟变量为 $0$。\n- 通过最大似然法拟合模型，并从解处的观测费雪信息中获得 $\\hat{\\boldsymbol{\\beta}}$ 的渐近方差。\n- 计算疾病系数的沃尔德统计量为 $z=\\hat{\\beta}_{\\mathrm{disease}}/\\mathrm{SE}(\\hat{\\beta}_{\\mathrm{disease}})$，并使用标准正态分布计算双边 $p$ 值。\n\n所有甲基化比例必须以小数形式处理（而不是百分比形式）。此任务中不含角度量。最终程序应生成单行输出，其中包含三个测试用例的结果，形式为一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身应是一个列表，顺序为 $[\\hat{\\beta}_{\\mathrm{disease}},\\exp(\\hat{\\beta}_{\\mathrm{disease}}),p\\text{-value},\\text{boolean},\\Delta p]$。\n\n测试套件：\n\n测试用例1（中等覆盖度，平衡分组）：\n- $m=\\{\\,38,55,39,54,41,88,38,60,45,66,24,56\\,\\}$\n- $n=\\{\\,100,95,110,100,90,120,80,100,85,100,75,95\\,\\}$\n- $D=\\{\\,0,1,0,1,0,1,0,1,0,1,0,1\\,\\}$\n- $A=\\{\\,50,52,60,58,45,65,70,55,62,48,52,68\\,\\}$\n- $B=\\{\\,\\mathrm{B},\\mathrm{B},\\mathrm{A},\\mathrm{A},\\mathrm{C},\\mathrm{C},\\mathrm{B},\\mathrm{B},\\mathrm{C},\\mathrm{C},\\mathrm{A},\\mathrm{A}\\,\\}$\n\n测试用例2（小计数，包括零成功的边界行为）：\n- $m=\\{\\,6,4,1,0,36,30,2,1\\,\\}$\n- $n=\\{\\,20,20,5,2,50,50,10,10\\,\\}$\n- $D=\\{\\,0,1,0,1,0,1,0,1\\,\\}$\n- $A=\\{\\,40,40,30,30,70,70,25,25\\,\\}$\n- $B=\\{\\,\\mathrm{B},\\mathrm{B},\\mathrm{A},\\mathrm{A},\\mathrm{C},\\mathrm{C},\\mathrm{B},\\mathrm{B}\\,\\}$\n\n测试用例3（强疾病效应，高覆盖度，非参考批次变异）：\n- $m=\\{\\,31,67,18,46,44,86,31,63,25,46\\,\\}$\n- $n=\\{\\,100,100,80,80,120,120,90,90,60,60\\,\\}$\n- $D=\\{\\,0,1,0,1,0,1,0,1,0,1\\,\\}$\n- $A=\\{\\,60,60,50,50,55,55,45,45,35,35\\,\\}$\n- $B=\\{\\,\\mathrm{B},\\mathrm{B},\\mathrm{A},\\mathrm{A},\\mathrm{C},\\mathrm{C},\\mathrm{B},\\mathrm{B},\\mathrm{C},\\mathrm{C}\\,\\}$\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\,[r_{11},r_{12},r_{13},r_{14},r_{15}],\\,[r_{21},r_{22},r_{23},r_{24},r_{25}],\\,[r_{31},r_{32},r_{33},r_{34},r_{35}]\\,]$），其中每个 $r_{jk}$ 是测试用例 $j$ 和指标 $k$ 对应的浮点数或布尔值，顺序如上所述。", "solution": "该问题已经过验证，被认为是合理的。这是一个定义明确、有科学依据且计算上可行的任务，其根植于测序数据的标准生物统计学分析。所有必要的数据和定义都已提供，且内部没有矛盾。\n\n该问题要求对亚硫酸氢盐测序数据拟合一个广义线性模型（GLM），以分析DNA甲基化与疾病状态之间的关联，同时对协变量进行调整。该模型的核心假设是，个体 $i$ 的甲基化读取数 $m_i$ 服从二项分布，$m_i \\sim \\mathrm{Binomial}(n_i, p_i)$，其中 $n_i$ 是总读取数，$p_i$ 是特定CpG位点上未知的甲基化概率。\n\n**模型设定**\n甲基化概率 $p_i$ 与一组协变量之间的关系通过一个连接函数来建模。指定的模型是一个带有 logit 连接函数的二项广义线性模型，这是二项分布族的典范连接，并能确保预测概率 $p_i$ 被限制在区间 $(0, 1)$ 内。该模型定义为：\n$$\n\\mathrm{logit}(p_i) = \\log\\left(\\frac{p_i}{1-p_i}\\right) = \\eta_i = \\mathbf{x}_i^\\top \\boldsymbol{\\beta}\n$$\n这里，$\\eta_i$ 是第 $i$ 个观测值的线性预测器。协变量向量 $\\mathbf{x}_i$ 由 $\\mathbf{x}_i = [1, D_i, A_i, \\mathbb{I}(B_i=\\mathrm{A}), \\mathbb{I}(B_i=\\mathrm{C})]^\\top$ 给出，其中 $1$ 代表截距，$D_i$ 是疾病状态（$0$ 或 $1$），$A_i$ 是年龄，$\\mathbb{I}(\\cdot)$ 是批次效应的指示函数，批次 B 作为参考类别。待估计的相应系数向量是 $\\boldsymbol{\\beta} = [\\beta_0, \\beta_{\\mathrm{disease}}, \\beta_A, \\beta_{B=\\mathrm{A}}, \\beta_{B=\\mathrm{C}}]^\\top$。\n\nlogit 连接函数的逆函数是 logistic sigmoid 函数，$\\sigma(z) = \\frac{1}{1 + \\exp(-z)}$，它将线性预测器映射回概率尺度：$p_i = \\sigma(\\eta_i)$。\n\n**最大似然估计（MLE）**\n系数 $\\boldsymbol{\\beta}$ 是通过最大化对数似然函数来估计的。对于 $N$ 个独立观测值，对数似然函数为：\n$$\n\\mathcal{L}(\\boldsymbol{\\beta}) = \\sum_{i=1}^N \\left( \\log\\binom{n_i}{m_i} + m_i \\log(p_i) + (n_i - m_i) \\log(1-p_i) \\right)\n$$\n代入 $p_i = \\sigma(\\mathbf{x}_i^\\top \\boldsymbol{\\beta})$，经过一些代数简化后，关于 $\\boldsymbol{\\beta}$ 的对数似然函数变为：\n$$\n\\mathcal{L}(\\boldsymbol{\\beta}) = \\sum_{i=1}^N \\left( \\log\\binom{n_i}{m_i} + m_i(\\mathbf{x}_i^\\top \\boldsymbol{\\beta}) - n_i \\log(1 + \\exp(\\mathbf{x}_i^\\top \\boldsymbol{\\beta})) \\right)\n$$\n最大似然估计 $\\hat{\\boldsymbol{\\beta}}$ 是使该函数最大化的 $\\boldsymbol{\\beta}$ 值。由于带有典范连接的广义线性模型的对数似然函数是凹的，因此存在唯一的最大值。这种最大化过程通常使用数值方法完成，如牛顿-拉弗森法（Newton-Raphson）或迭代重加权最小二乘法（IRLS）。这些方法需要对数似然函数的梯度（得分向量）和海森矩阵。\n\n梯度由以下公式给出：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\boldsymbol{\\beta}} = \\sum_{i=1}^N (m_i - n_i p_i) \\mathbf{x}_i = \\mathbf{X}^\\top (\\mathbf{m} - n\\mathbf{p})\n$$\n海森矩阵为：\n$$\n\\mathbf{H}(\\boldsymbol{\\beta}) = \\frac{\\partial^2 \\mathcal{L}}{\\partial \\boldsymbol{\\beta} \\partial \\boldsymbol{\\beta}^\\top} = -\\sum_{i=1}^N n_i p_i (1 - p_i) \\mathbf{x}_i \\mathbf{x}_i^\\top = -\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X}\n$$\n其中 $\\mathbf{X}$ 是以 $\\mathbf{x}_i^\\top$ 为行的设计矩阵，$\\mathbf{W}$ 是一个对角矩阵，其对角元素为 $W_{ii} = n_i p_i (1-p_i)$。\n\n**推断与所需量的计算**\n一旦获得最大似然估计 $\\hat{\\boldsymbol{\\beta}}$，我们就可以进行统计推断。估计量的渐近方差-协方差矩阵是观测费雪信息矩阵 $\\mathcal{I}(\\hat{\\boldsymbol{\\beta}})$ 在解处求值的逆矩阵：\n$$\n\\mathrm{Var}(\\hat{\\boldsymbol{\\beta}}) \\approx \\mathcal{I}(\\hat{\\boldsymbol{\\beta}})^{-1} = (-\\mathbf{H}(\\hat{\\boldsymbol{\\beta}}))^{-1} = (\\mathbf{X}^\\top \\mathbf{W}(\\hat{\\boldsymbol{\\beta}}) \\mathbf{X})^{-1}\n$$\n单个系数估计的标准误 $\\mathrm{SE}(\\hat{\\beta}_j)$ 是该方差-协方差矩阵对应对角元素的平方根。\n\n所需的量按以下方式计算：\n1.  **估计的疾病系数（$\\hat{\\beta}_{\\mathrm{disease}}$）**：这是估计向量 $\\hat{\\boldsymbol{\\beta}}$ 的第二个元素。\n2.  **比值比（$\\exp(\\hat{\\beta}_{\\mathrm{disease}})$）**：这表示，在保持所有其他协变量不变的情况下，患病者（$D=1$）与对照组（$D=0$）相比，甲基化比值（odds）变化的因子。\n3.  **沃尔德检验 $p$ 值**：对于原假设 $H_0: \\beta_{\\mathrm{disease}}=0$ 的双边沃尔德检验统计量是 $z = \\hat{\\beta}_{\\mathrm{disease}} / \\mathrm{SE}(\\hat{\\beta}_{\\mathrm{disease}})$。在原假设下，此统计量服从标准正态分布。$p$ 值计算为 $p = 2 \\cdot (1 - \\Phi(|z|))$，其中 $\\Phi$ 是标准正态分布的累积分布函数。\n4.  **效应方向的布尔值**：这仅是判断 $\\exp(\\hat{\\beta}_{\\mathrm{disease}}) > 1$ 是否成立。如果为真，则该疾病与甲基化比值的增加相关。\n5.  **预测甲基化概率的差异（$\\Delta p$）**：这是在固定参考配置下计算的：年龄 $A^\\ast=60$ 且批次为 B。对于此配置，患病者和对照组个体的线性预测器分别为 $\\eta_{1} = \\hat{\\beta}_0 + \\hat{\\beta}_{\\mathrm{disease}} + 60\\hat{\\beta}_A$ 和 $\\eta_{0} = \\hat{\\beta}_0 + 60\\hat{\\beta}_A$。预测概率的差异则为 $\\Delta p = \\sigma(\\eta_{1}) - \\sigma(\\eta_{0})$。\n\n将对每个测试用例应用以下计算过程以得出最终结果。\n\n#### Python 实现\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the DNA methylation GLM problem for three test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (moderate coverage, balanced groups):\n        {\n            \"m\": [38, 55, 39, 54, 41, 88, 38, 60, 45, 66, 24, 56],\n            \"n\": [100, 95, 110, 100, 90, 120, 80, 100, 85, 100, 75, 95],\n            \"D\": [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\n            \"A\": [50, 52, 60, 58, 45, 65, 70, 55, 62, 48, 52, 68],\n            \"B\": ['B', 'B', 'A', 'A', 'C', 'C', 'B', 'B', 'C', 'C', 'A', 'A']\n        },\n        # Test case 2 (small counts, boundary behavior including zero successes):\n        {\n            \"m\": [6, 4, 1, 0, 36, 30, 2, 1],\n            \"n\": [20, 20, 5, 2, 50, 50, 10, 10],\n            \"D\": [0, 1, 0, 1, 0, 1, 0, 1],\n            \"A\": [40, 40, 30, 30, 70, 70, 25, 25],\n            \"B\": ['B', 'B', 'A', 'A', 'C', 'C', 'B', 'B']\n        },\n        # Test case 3 (strong disease effect, high coverage, non-reference batch variation):\n        {\n            \"m\": [31, 67, 18, 46, 44, 86, 31, 63, 25, 46],\n            \"n\": [100, 100, 80, 80, 120, 120, 90, 90, 60, 60],\n            \"D\": [0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\n            \"A\": [60, 60, 50, 50, 55, 55, 45, 45, 35, 35],\n            \"B\": ['B', 'B', 'A', 'A', 'C', 'C', 'B', 'B', 'C', 'C']\n        }\n    ]\n\n    results = []\n    for case_data in test_cases:\n        m_vec = np.array(case_data[\"m\"])\n        n_vec = np.array(case_data[\"n\"])\n        D_vec = np.array(case_data[\"D\"])\n        A_vec = np.array(case_data[\"A\"])\n        B_cat = case_data[\"B\"]\n\n        # 1. Construct the design matrix X\n        num_obs = len(m_vec)\n        X = np.zeros((num_obs, 5))\n        X[:, 0] = 1  # Intercept\n        X[:, 1] = D_vec  # Disease status\n        X[:, 2] = A_vec  # Age\n        X[:, 3] = np.array([1 if b == 'A' else 0 for b in B_cat])  # Batch A\n        X[:, 4] = np.array([1 if b == 'C' else 0 for b in B_cat])  # Batch C\n\n        # 2. Define objective function (negative log-likelihood), gradient, and Hessian\n        def neg_log_likelihood(beta, X, m, n):\n            eta = X @ beta\n            # Use logaddexp for numerical stability: log(1 + exp(eta))\n            log_p_denom = np.logaddexp(0, eta)\n            log_lik = m * eta - n * log_p_denom\n            return -np.sum(log_lik)\n\n        def gradient(beta, X, m, n):\n            eta = X @ beta\n            p = 1 / (1 + np.exp(-eta))\n            # grad is sum over i of (n_i * p_i - m_i) * x_i\n            grad = (n * p - m) @ X\n            return grad\n\n        def hessian(beta, X, m, n):\n            eta = X @ beta\n            p = 1 / (1 + np.exp(-eta))\n            w = n * p * (1 - p)\n            W = np.diag(w)\n            hess = X.T @ W @ X\n            return hess\n\n        # 3. Perform optimization to find MLE for beta\n        initial_beta = np.zeros(X.shape[1])\n        opt_res = minimize(\n            fun=neg_log_likelihood,\n            x0=initial_beta,\n            args=(X, m_vec, n_vec),\n            method='Newton-CG',\n            jac=gradient,\n            hess=hessian,\n            options={'xtol': 1e-8, 'disp': False}\n        )\n        beta_hat = opt_res.x\n\n        # 4. Calculate the required quantities\n        # Estimated disease coefficient\n        beta_disease = beta_hat[1]\n\n        # Asymptotic covariance matrix\n        fisher_info_matrix = hessian(beta_hat, X, m_vec, n_vec)\n        cov_matrix = np.linalg.inv(fisher_info_matrix)\n        \n        # Standard error for the disease coefficient\n        se_beta_disease = np.sqrt(cov_matrix[1, 1])\n        \n        # Two-sided Wald test\n        wald_z_statistic = beta_disease / se_beta_disease\n        p_value = 2 * norm.sf(np.abs(wald_z_statistic))\n        \n        # Odds ratio\n        odds_ratio = np.exp(beta_disease)\n        \n        # Boolean indicating if methylation increases with disease\n        increases_methylation = odds_ratio > 1\n\n        # Difference in predicted methylation probability\n        def sigmoid(z):\n            return 1 / (1 + np.exp(-z))\n        \n        age_star = 60.0\n        # Linear predictors for a reference individual (Batch B, Age=60)\n        # beta_hat[0] is intercept, [1] is disease, [2] is age\n        eta_control = beta_hat[0] + beta_hat[2] * age_star\n        eta_disease = beta_hat[0] + beta_hat[1] + beta_hat[2] * age_star\n        \n        p_control = sigmoid(eta_control)\n        p_disease = sigmoid(eta_disease)\n        delta_p = p_disease - p_control\n        \n        case_result = [\n            float(beta_disease),\n            float(odds_ratio),\n            float(p_value),\n            bool(increases_methylation),\n            float(delta_p)\n        ]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# The function call is commented out as we are only providing the code.\n# solve()\n```", "answer": "[[0.812285108480376, 2.252980164627473, 0.04692025700257125, True, 0.16688126780077977], [-0.8039700053912634, 0.4475530669288126, 0.4900446340004509, False, -0.09137025828773998], [1.252300438435741, 3.498413645398273, 0.0003750032599602436, True, 0.2820803451000836]]", "id": "5109769"}]}