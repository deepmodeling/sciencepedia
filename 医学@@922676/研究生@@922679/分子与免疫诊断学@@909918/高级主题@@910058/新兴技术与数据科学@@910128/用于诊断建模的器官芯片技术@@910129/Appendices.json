{"hands_on_practices": [{"introduction": "在我们能够解读来自芯片上器官（OOC）的诊断数据之前，我们必须首先理解控制生物标志物浓度的基本物理和生化过程。本练习通过模拟一个常见场景——物质的持续分泌、流经过和降解——为此奠定基础。通过推导浓度随时间变化的曲线，学生们将亲身体会到流速、体积和生物标志物稳定性等系统参数如何相互作用，共同产生我们所测量的信号。[@problem_id:5145123]", "problem": "一个器官芯片（OOC）微流控设备被用于模拟在连续灌注下，活体组织隔室产生的诊断性生物标志物的分泌和转归。该设备有一个充分混合的有效灌注液体积 $V$，新鲜培养基（入口处生物标志物浓度为 $0$）以恒定的体积流率 $Q$ 流过该体积。组织以恒定的摩尔生产速率 $R$（单位为 $\\text{mol}\\,\\text{s}^{-1}$）将生物标志物分泌到灌注液中。由于蛋白水解和基质成分的吸附，该生物标志物在灌注液中会发生一级降解，其半衰期为 $t_{1/2}$。假设在 $V$ 中混合完美，相对于整体一级降解，壁吸附可忽略不计，并且测得的出口浓度等于充分混合室内的浓度。\n\n从质量守恒声明“累积量等于流入量减去流出量加上生成量减去降解量”出发，并使用一级衰变的定义和半衰期概念 $C(t_{1/2}) = C(0)/2$，推导出出口浓度 $C_{\\text{out}}(t)$ 作为 $t$、$t_{1/2}$、$Q$、$V$ 和 $R$ 的函数解析表达式，给定初始条件 $C_{\\text{out}}(0) = 0$ 且在 $t=0$ 时分泌开始呈阶跃式发生。\n\n请用 $\\text{mol}\\,\\text{m}^{-3}$ 表示 $C_{\\text{out}}(t)$ 的最终解析表达式，其中时间 $t$ 的单位为 $\\text{s}$，所有参数均使用一致的国际单位制（SI）单位。不需要进行数值计算。", "solution": "该问题具有科学依据，提法明确，并提供了一套完整且一致的信息来推导所要求的解析表达式。所描述的模型是一个带有一级衰变项的标准连续搅拌釜反应器（CSTR）模型，这是化学工程和生物输运现象中的一个基本概念。推导过程是通过将所给的质量平衡声明形式化为一个可解的常微分方程来进行的。\n\n设 $C(t)$ 为在时间 $t$ 时，充分混合体积 $V$ 中生物标志物的浓度。问题陈述出口浓度等于腔室浓度，因此 $C_{\\text{out}}(t) = C(t)$。体积中生物标志物的摩尔数为 $n(t) = V C(t)$。质量守恒原理表述为：累积速率 = 流入速率 - 流出速率 + 生成速率 - 降解速率。我们将对生物标志物摩尔数的每一项进行公式化。\n\n1.  **累积速率**：这是体积 $V$ 中摩尔数的变化速率。由于 $V$ 是常数，累积速率为 $\\frac{dn}{dt} = \\frac{d(VC)}{dt} = V\\frac{dC}{dt}$。\n\n2.  **流入速率**：体积流率为 $Q$，流入液中生物标志物的浓度为 $0$。摩尔流入速率为 $Q \\times C_{\\text{in}} = Q \\times 0 = 0$。\n\n3.  **流出速率**：灌注液以流率 $Q$ 和腔室浓度 $C(t)$ 流出。摩尔流出速率为 $Q C(t)$。\n\n4.  **生成速率**：组织以恒定速率 $R$ 分泌生物标志物，单位为 $\\text{mol}\\,\\text{s}^{-1}$。\n\n5.  **降解速率**：降解是一个一级过程，意味着其速率与存在的摩尔数 $n(t)$ 成正比。降解速率为 $k n(t) = k V C(t)$，其中 $k$ 是一级速率常数，单位为 $\\text{s}^{-1}$。问题提供了半衰期 $t_{1/2}$。对于一级过程，速率常数 $k$ 与半衰期 $t_{1/2}$ 之间的关系可以从衰变方程 $C(t) = C(0)\\exp(-kt)$ 推导出来。根据定义，在 $t=t_{1/2}$ 时，$C(t_{1/2}) = C(0)/2$。代入此式得到 $\\frac{C(0)}{2} = C(0)\\exp(-kt_{1/2})$，简化为 $\\frac{1}{2} = \\exp(-kt_{1/2})$。对两边取自然对数，得到 $\\ln(\\frac{1}{2}) = -kt_{1/2}$，即 $-\\ln(2) = -kt_{1/2}$。因此，速率常数为 $k = \\frac{\\ln(2)}{t_{1/2}}$。所以降解速率为 $\\frac{\\ln(2)}{t_{1/2}} V C(t)$。\n\n将这些项组合成质量平衡方程：\n$$V\\frac{dC}{dt} = 0 - Q C(t) + R - \\frac{\\ln(2)}{t_{1/2}} V C(t)$$\n这是一个一阶线性常微分方程。我们可以将其重新排列成标准形式 $\\frac{dy}{dx} + P(x)y = Q(x)$。\n$$V\\frac{dC}{dt} + Q C(t) + \\frac{\\ln(2)}{t_{1/2}} V C(t) = R$$\n$$\\frac{dC}{dt} + \\left(\\frac{Q}{V} + \\frac{\\ln(2)}{t_{1/2}}\\right) C(t) = \\frac{R}{V}$$\n我们定义一个常数 $\\lambda = \\frac{Q}{V} + \\frac{\\ln(2)}{t_{1/2}}$。常微分方程简化为：\n$$\\frac{dC}{dt} + \\lambda C(t) = \\frac{R}{V}$$\n这个方程可以使用积分因子 $I(t) = \\exp\\left(\\int \\lambda dt\\right) = \\exp(\\lambda t)$ 来求解。将常微分方程两边乘以 $I(t)$ 得到：\n$$\\exp(\\lambda t) \\frac{dC}{dt} + \\lambda \\exp(\\lambda t) C(t) = \\frac{R}{V} \\exp(\\lambda t)$$\n左边是乘积 $C(t) I(t)$ 的导数：\n$$\\frac{d}{dt}\\left(C(t)\\exp(\\lambda t)\\right) = \\frac{R}{V} \\exp(\\lambda t)$$\n对两边关于 $t$ 积分：\n$$\\int \\frac{d}{dt}\\left(C(t)\\exp(\\lambda t)\\right) dt = \\int \\frac{R}{V} \\exp(\\lambda t) dt$$\n$$C(t)\\exp(\\lambda t) = \\frac{R}{V\\lambda} \\exp(\\lambda t) + K$$\n其中 $K$ 是积分常数。解出 $C(t)$ 得到通解：\n$$C(t) = \\frac{R}{V\\lambda} + K \\exp(-\\lambda t)$$\n为了求出 $K$，我们应用初始条件 $C(0) = 0$。\n$$C(0) = 0 = \\frac{R}{V\\lambda} + K \\exp(0)$$\n$$0 = \\frac{R}{V\\lambda} + K \\implies K = -\\frac{R}{V\\lambda}$$\n将 $K$ 代回通解，得到特解：\n$$C(t) = \\frac{R}{V\\lambda} - \\frac{R}{V\\lambda} \\exp(-\\lambda t) = \\frac{R}{V\\lambda} \\left(1 - \\exp(-\\lambda t)\\right)$$\n最后，我们将 $\\lambda$ 的表达式代回解中：\n$$C(t) = \\frac{R}{V\\left(\\frac{Q}{V} + \\frac{\\ln(2)}{t_{1/2}}\\right)} \\left(1 - \\exp\\left(-\\left(\\frac{Q}{V} + \\frac{\\ln(2)}{t_{1/2}}\\right)t\\right)\\right)$$\n简化前置因子的分母：\n$$C(t) = \\frac{R}{Q + V\\frac{\\ln(2)}{t_{1/2}}} \\left(1 - \\exp\\left(-\\left(\\frac{Q}{V} + \\frac{\\ln(2)}{t_{1/2}}\\right)t\\right)\\right)$$\n由于问题指定出口浓度 $C_{\\text{out}}(t)$ 等于腔室浓度 $C(t)$，因此该表达式即为最终答案。", "answer": "$$\\boxed{\\frac{R}{Q + V \\frac{\\ln(2)}{t_{1/2}}} \\left(1 - \\exp\\left(-\\left(\\frac{Q}{V} + \\frac{\\ln(2)}{t_{1/2}}\\right)t\\right)\\right)}$$", "id": "5145123"}, {"introduction": "在理解了单个芯片的物理原理之后，一个关键的现实挑战是确保结果的一致性和可比性，尤其是在使用不同批次制造的芯片时。本实践介绍了一种强大的统计方法——正交回归，用于在新的芯片批次与经过验证的参考批次之间建立校准联系。这项技能对于开发能够广泛部署的、可靠的诊断模型至关重要。[@problem_id:5145035]", "problem": "一个实验室联盟使用器官芯片（OoC）系统来量化细胞因子释放，其诊断建模要求在不同批次的微流控免疫分析芯片之间进行一致的校准。考虑两个批次：一个参考批次，已经过验证，能够读取浓度而无系统偏差；一个新批次，必须根据参考批次进行校准。转移校准通过一条直线 $y = a + m x$ 进行建模，其中 $x$ 表示来自参考批次的测量值，$y$ 表示来自新批次的测量值。由于 $x$ 和 $y$ 都带有测量不确定度，校准使用正交回归（Deming回归）进行，其误差方差比 $\\lambda = \\sigma_{y}^{2} / \\sigma_{x}^{2}$ 是从重复加标质控品中确定的。\n\n您获得了从跨越临床相关动态范围的 $n$ 对匹配校准品 $\\{(x_{i}, y_{i})\\}_{i=1}^{n}$ 计算出的汇总统计量：\n- 样本均值：$\\bar{x} = 1.20\\,\\mathrm{ng}\\,\\mathrm{mL}^{-1}$，$\\bar{y} = 1.26\\,\\mathrm{ng}\\,\\mathrm{mL}^{-1}$。\n- 中心二阶矩：$S_{xx} = 0.040\\,(\\mathrm{ng}\\,\\mathrm{mL}^{-1})^{2}$，$S_{yy} = 0.052\\,(\\mathrm{ng}\\,\\mathrm{mL}^{-1})^{2}$，$S_{xy} = 0.047\\,(\\mathrm{ng}\\,\\mathrm{mL}^{-1})^{2}$，其中 $S_{xx} = \\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\bar{x})^{2}$，$S_{yy} = \\frac{1}{n}\\sum_{i=1}^{n}(y_{i} - \\bar{y})^{2}$，以及 $S_{xy} = \\frac{1}{n}\\sum_{i=1}^{n}(x_{i} - \\bar{x})(y_{i} - \\bar{y})$。\n- 误差方差比：$\\lambda = 1.20$。\n\n在参考批次上验证的临床决策阈值为 $x_{\\mathrm{th}} = 1.50\\,\\mathrm{ng}\\,\\mathrm{mL}^{-1}$。如果一个接收实验室在没有进行校准转移的情况下，错误地将相同的数值阈值应用于新批次（即，使用 $y_{\\mathrm{used}} = x_{\\mathrm{th}}$ 而不是正确的转移阈值 $y_{\\mathrm{correct}} = a + m x_{\\mathrm{th}}$），那么在新批次上应用的诊断阈值的偏差定义为 $b = y_{\\mathrm{used}} - y_{\\mathrm{correct}}$。\n\n从测量误差模型假设和比率为 $\\lambda$ 的正交回归的定义出发，推导出从所提供的汇总统计量中获得正交回归斜率 $m$ 和截距 $a$ 所需的表达式，计算 $m$ 和 $a$，然后计算在 $x_{\\mathrm{th}}$ 处的偏差 $b$。最终偏差 $b$ 以 $\\mathrm{ng}\\,\\mathrm{mL}^{-1}$ 为单位表示，并将您的答案四舍五入到三位有效数字。", "solution": "该问题是有效的。它是一个科学上合理、表述清晰且客观的应用统计学问题，具体涉及使用Deming回归进行方法比较和校准转移，这适用于所述的器官芯片诊断背景。所有必要的数据和定义都已提供，并且它们内部一致且符合实际。\n\n任务是确定在没有进行适当校准转移的情况下使用新的诊断批次时，临床决策阈值产生的偏差。参考批次测量值 $x$ 与新批次测量值 $y$ 之间的校准关系由线性模型 $y = a + m x$ 给出。由于两个测量系统都存在固有的不确定性，参数 $m$（斜率）和 $a$（截距）必须使用Deming回归来估计，这是一种变量含误差模型，它最小化 $x$ 和 $y$ 两个维度上残差的加权平方和。该回归需要一个已知的误差方差比 $\\lambda = \\sigma_{y}^{2} / \\sigma_{x}^{2}$。\n\nDeming回归线保证通过数据的质心 $(\\bar{x}, \\bar{y})$。这使得截距 $a$ 可以直接通过斜率 $m$ 和样本均值计算得出：\n$$a = \\bar{y} - m\\bar{x}$$\n\n斜率 $m$ 是通过最小化与加权正交距离相关的目标函数来确定的。Deming回归斜率的标准公式，是从这个最小化过程中推导出来的，并用所提供的汇总统计量（$S_{xx}$，$S_{yy}$，$S_{xy}$）和误差方差比（$\\lambda$）表示为：\n$$m = \\frac{(S_{yy} - \\lambda S_{xx}) + \\sqrt{(S_{yy} - \\lambda S_{xx})^2 + 4 \\lambda S_{xy}^2}}{2 S_{xy}}$$\n平方根的符号选择与样本协方差 $S_{xy}$ 的符号相匹配。由于在本问题中 $S_{xy}  0$，我们使用正根。\n\n我们已知以下汇总统计量：\n- 样本均值：$\\bar{x} = 1.20\\,\\mathrm{ng}\\,\\mathrm{mL}^{-1}$，$\\bar{y} = 1.26\\,\\mathrm{ng}\\,\\mathrm{mL}^{-1}$。\n- 中心二阶矩：$S_{xx} = 0.040\\,(\\mathrm{ng}\\,\\mathrm{mL}^{-1})^{2}$，$S_{yy} = 0.052\\,(\\mathrm{ng}\\,\\mathrm{mL}^{-1})^{2}$，$S_{xy} = 0.047\\,(\\mathrm{ng}\\,\\mathrm{mL}^{-1})^{2}$。\n- 误差方差比：$\\lambda = 1.20$。\n\n首先，我们计算斜率 $m$。\n我们来计算斜率公式的各个组成部分。\n$S_{yy} - \\lambda S_{xx}$ 项为：\n$$S_{yy} - \\lambda S_{xx} = 0.052 - (1.20)(0.040) = 0.052 - 0.048 = 0.004$$\n平方根下的项（判别式）为：\n$$(S_{yy} - \\lambda S_{xx})^2 + 4 \\lambda S_{xy}^2 = (0.004)^2 + 4(1.20)(0.047)^2$$\n$$= 0.000016 + 4.8 \\times 0.002209 = 0.000016 + 0.0106032 = 0.0106192$$\n取平方根：\n$$\\sqrt{0.0106192} \\approx 0.1030495$$\n分母为 $2 S_{xy}$：\n$$2 S_{xy} = 2(0.047) = 0.094$$\n现在，我们可以组合出斜率 $m$：\n$$m = \\frac{0.004 + 0.1030495}{0.094} = \\frac{0.1070495}{0.094} \\approx 1.1388245$$\n\n接下来，我们使用公式 $a = \\bar{y} - m\\bar{x}$ 计算截距 $a$：\n$$a = 1.26 - (1.1388245)(1.20) = 1.26 - 1.3665894 \\approx -0.1065894$$\n因此，校准转移函数近似为 $y = -0.1065894 + 1.1388245 x$。\n\n问题定义了由于未能将此校准应用于临床阈值而产生的偏差 $b$。参考阈值为 $x_{\\mathrm{th}} = 1.50\\,\\mathrm{ng}\\,\\mathrm{mL}^{-1}$。如果在新批次上错误地使用了这个值，那么 $y_{\\mathrm{used}} = x_{\\mathrm{th}} = 1.50\\,\\mathrm{ng}\\,\\mathrm{mL}^{-1}$。\n新批次上的正确阈值 $y_{\\mathrm{correct}}$ 通过应用校准转移函数得到：\n$$y_{\\mathrm{correct}} = a + m x_{\\mathrm{th}}$$\n代入我们求得的 $a$、$m$ 和给定的 $x_{\\mathrm{th}}$ 的值：\n$$y_{\\mathrm{correct}} = (-0.1065894) + (1.1388245)(1.50)$$\n$$y_{\\mathrm{correct}} = -0.1065894 + 1.70823675 \\approx 1.60164735\\,\\mathrm{ng}\\,\\mathrm{mL}^{-1}$$\n\n偏差 $b$ 定义为错误使用的阈值与正确阈值之间的差值：\n$$b = y_{\\mathrm{used}} - y_{\\mathrm{correct}}$$\n$$b = 1.50 - 1.60164735 = -0.10164735\\,\\mathrm{ng}\\,\\mathrm{mL}^{-1}$$\n\n问题要求最终答案四舍五入到三位有效数字。$b$ 的第一位有效数字是十分位上的 $1$。第三位有效数字是千分位上的 $1$。随后的数字是 $6$，大于或等于 $5$，所以我们将第三位有效数字向上取整。\n$$b \\approx -0.102\\,\\mathrm{ng}\\,\\mathrm{mL}^{-1}$$\n这个负偏差表明，在新批次上使用未经校准的 $1.50\\,\\mathrm{ng}\\,\\mathrm{mL}^{-1}$ 阈值，是对正确的诊断阈值（约为 $1.60\\,\\mathrm{ng}\\,\\mathrm{mL}^{-1}$）的低估。", "answer": "$$\\boxed{-0.102}$$", "id": "5145035"}, {"introduction": "建立一个预测模型，例如我们第一个练习中的转运模型，需要从实验数据中估计其参数。这些估计的质量在很大程度上取决于我们选择在*何时*进行测量。这项高级实践介绍了D-最优实验设计的概念，这是一种强大的技术，用于选择能提供最多统计信息的测量时间点，从而确保我们的建模工作建立在最坚实的基础之上。[@problem_id:5145058]", "problem": "一个微流控芯片器官(OoC)屏障分析被建模为一个线性双室系统，其中一个已知初始浓度的供体室中的物质通过一级传输穿过一层膜进入一个同样经历一级清除的受体室。设供体室浓度为 $C_d(t)$，受体室浓度为 $C_r(t)$，并假设初始条件为 $C_d(0) = C_0$ 和 $C_r(0) = 0$。从供体室到受体室的膜传输速率常数为 $k_m$ (单位为 $\\mathrm{s}^{-1}$)，受体室的清除速率常数为 $k_c$ (单位为 $\\mathrm{s}^{-1}$)。在时间 $t_i$ 对受体室浓度的测量值受到独立同分布的加性高斯噪声的干扰，该噪声均值为零，方差为 $\\sigma^2$ (单位为 $(\\mathrm{concentration})^2$）。\n\n基本原理：\n- 质量守恒和一级动力学意味着存在耦合线性常微分方程 $dC_d/dt = -k_m C_d$ 和 $dC_r/dt = k_m C_d - k_c C_r$。\n- 求解具有常系数的线性常微分方程可得到 $C_r(t)$ 的闭式解。\n- 在方差为 $\\sigma^2$ 的高斯噪声下，参数 $\\theta = (k_m, k_c)$ 的费雪信息矩阵 (FIM) 等于均值模型相对于参数的灵敏度（梯度）的外积之和，并按 $1/\\sigma^2$进行缩放。\n\n将期望（无噪声）的测量模型 $m(t; \\theta)$ 定义为 $C_r(t)$。对于一组 $n$ 个测量时间 $\\{t_1, \\dots, t_n\\}$，费雪信息矩阵为\n$$\n\\mathcal{I}(\\theta; t_1,\\dots,t_n) = \\frac{1}{\\sigma^2} \\sum_{i=1}^{n} \\nabla_{\\theta} m(t_i; \\theta) \\, \\nabla_{\\theta} m(t_i; \\theta)^{\\top},\n$$\n其中 $\\nabla_{\\theta} m(t;\\theta)$ 是 $m$ 相对于 $(k_m,k_c)$ 的梯度。D-最优设计通过选择测量时间来最大化 $\\det\\big(\\mathcal{I}(\\theta; t_1,\\dots,t_n)\\big)$。\n\n你的任务是编写一个程序，为每个指定的测试用例，从一个离散网格中选择一组测量时间，以最大化费雪信息矩阵的行列式（D-最优性），并遵循以下约束：\n- 测量时间必须为严格正数，并从给定下限 $t_{\\min}$ 和上限 $t_{\\max}$（含边界）之间的均匀网格中选取，步长为指定的 $\\Delta t$。\n- 测量时间必须严格递增（无重复值）。\n- 如果多个时间集在数值公差范围内达到相同的最大行列式值，则选择字典序最小的递增时间序列（即最早的时间优先）。\n\n双室一级模型的期望受体室浓度可以从基本方程推导出来。使用该模型及其参数灵敏度来构建费雪信息矩阵，并为候选时间集评估其行列式。程序必须搜索网格中所有 $n$ 个不同时间的组合，并返回 D-最优集。\n\n单位和输出要求：\n- 时间必须以秒为单位表示，并以整数形式报告。\n- 程序的最终输出必须为单行，其中包含所有测试用例的结果。结果是一个用方括号括起来的逗号分隔列表，其中每个项目本身是按升序排列的所选测量时间的列表（例如，`[[t_1,t_2,…],[…],…]`）。\n- 角度单位在此不适用。\n- 百分比在此不适用。\n\n测试套件：\n对于下面的每个测试用例，假设噪声方差 $\\sigma^2$ 和初始供体室浓度 $C_0$ 是已知的常数。根据上述规则，以秒为单位提供 D-最优的时间集（整数形式）。\n\n- 用例 A (常规操作范围):\n  - 参数：$k_m = 10^{-3}\\ \\mathrm{s}^{-1}$，$k_c = 4\\times 10^{-4}\\ \\mathrm{s}^{-1}$，$C_0 = 1.0$ (任意浓度单位)，$\\sigma = 10^{-4}$ (相同浓度单位)。\n  - 网格：$t_{\\min} = 600\\ \\mathrm{s}$，$t_{\\max} = 3600\\ \\mathrm{s}$，$\\Delta t = 600\\ \\mathrm{s}$。\n  - 测量次数：$n = 4$。\n\n- 用例 B (速率接近简并，具有挑战性的灵敏度行为):\n  - 参数：$k_m = 5\\times 10^{-4}\\ \\mathrm{s}^{-1}$，$k_c = 4.9\\times 10^{-4}\\ \\mathrm{s}^{-1}$，$C_0 = 1.0$，$\\sigma = 10^{-4}$。\n  - 网格：$t_{\\min} = 600\\ \\mathrm{s}$，$t_{\\max} = 3600\\ \\mathrm{s}$，$\\Delta t = 600\\ \\mathrm{s}$。\n  - 测量次数：$n = 4$。\n\n- 用例 C (快速传输和清除，侧重于早期时间):\n  - 参数：$k_m = 3\\times 10^{-3}\\ \\mathrm{s}^{-1}$，$k_c = 10^{-3}\\ \\mathrm{s}^{-1}$，$C_0 = 1.0$，$\\sigma = 5\\times 10^{-4}$。\n  - 网格：$t_{\\min} = 60\\ \\mathrm{s}$，$t_{\\max} = 600\\ \\mathrm{s}$，$\\Delta t = 60\\ \\mathrm{s}$。\n  - 测量次数：$n = 3$。\n\n你的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个用方括号括起来的逗号分隔列表，每个结果是对应测试用例的所选时间列表，按 A、B、C 的顺序排列。例如，输出格式为 `[[t_{A,1},t_{A,2},t_{A,3},t_{A,4}],[t_{B,1},t_{B,2},t_{B,3},t_{B,4}],[t_{C,1},t_{C,2},t_{C,3}]]`。", "solution": "首先将对问题进行严格验证。将对其有效性做出裁决，只有在被认定为有效时，才会推导并给出完整的解决方案。\n\n### 问题验证\n\n#### 第1步：提取已知信息\n问题陈述提供了以下信息：\n- **系统模型**：一个线性双室系统。\n- **状态变量**：供体室浓度 $C_d(t)$，受体室浓度 $C_r(t)$。\n- **初始条件**：$C_d(0) = C_0$ 和 $C_r(0) = 0$。\n- **速率常数**：从供体室到受体室的膜传输速率 $k_m$ (单位为 $\\mathrm{s}^{-1}$)，受体室清除速率 $k_c$ (单位为 $\\mathrm{s}^{-1}$)。\n- **控制方程**：$dC_d/dt = -k_m C_d$ 和 $dC_r/dt = k_m C_d - k_c C_r$。\n- **噪声模型**：测量值受到独立同分布 (i.i.d.) 的加性高斯噪声的干扰，该噪声均值为零，方差为 $\\sigma^2$。\n- **测量模型**：$m(t; \\theta) = C_r(t)$，其中 $\\theta = (k_m, k_c)$。\n- **费雪信息矩阵 (FIM)**：$\\mathcal{I}(\\theta; t_1,\\dots,t_n) = \\frac{1}{\\sigma^2} \\sum_{i=1}^{n} \\nabla_{\\theta} m(t_i; \\theta) \\, \\nabla_{\\theta} m(t_i; \\theta)^{\\top}$。\n- **目标**：通过选择 $n$ 个测量时间 $\\{t_1, \\dots, t_n\\}$ 来最大化 $\\det\\big(\\mathcal{I}(\\theta; t_1,\\dots,t_n)\\big)$ (D-最优性)。\n- **测量时间的约束**：\n    - 时间必须为严格正数。\n    - 从一个均匀网格中选择：$[t_{\\min}, t_{\\max}]$，步长为 $\\Delta t$。\n    - 时间必须严格递增。\n- **平局决胜规则**：如果多个时间集产生相同的最大行列式值，则选择字典序最小的序列。\n- **测试用例**：\n    - **用例 A**：$k_m = 10^{-3}\\ \\mathrm{s}^{-1}$，$k_c = 4\\times 10^{-4}\\ \\mathrm{s}^{-1}$，$C_0 = 1.0$，$\\sigma = 10^{-4}$。网格：$t_{\\min} = 600\\ \\mathrm{s}$，$t_{\\max} = 3600\\ \\mathrm{s}$，$\\Delta t = 600\\ \\mathrm{s}$。测量次数：$n = 4$。\n    - **用例 B**：$k_m = 5\\times 10^{-4}\\ \\mathrm{s}^{-1}$，$k_c = 4.9\\times 10^{-4}\\ \\mathrm{s}^{-1}$，$C_0 = 1.0$，$\\sigma = 10^{-4}$。网格：$t_{\\min} = 600\\ \\mathrm{s}$，$t_{\\max} = 3600\\ \\mathrm{s}$，$\\Delta t = 600\\ \\mathrm{s}$。测量次数：$n = 4$。\n    - **用例 C**：$k_m = 3\\times 10^{-3}\\ \\mathrm{s}^{-1}$，$k_c = 10^{-3}\\ \\mathrm{s}^{-1}$，$C_0 = 1.0$，$\\sigma = 5\\times 10^{-4}$。网格：$t_{\\min} = 60\\ \\mathrm{s}$，$t_{\\max} = 600\\ \\mathrm{s}$，$\\Delta t = 60\\ \\mathrm{s}$。测量次数：$n = 3$。\n\n#### 第2步：使用提取的已知信息进行验证\n根据验证标准对问题进行评估：\n- **科学依据**：该问题基于药代动力学（房室模型）、线性常微分方程和统计实验设计（特别是D-最优性和费雪信息）的标准原理。这些都是工程学和应用统计学中成熟的概念。该模型是传输分析的常见表示。\n- **良态的 (Well-Posed)**：目标明确（最大化 FIM 行列式）。搜索空间（离散时间点的组合）是有限的。约束是精确的。平局决胜规则保证了唯一解的存在。\n- **客观性**：问题使用精确的数学语言和定量数据定义。没有主观或含糊的陈述。\n\n该问题不存在任何指定的缺陷：\n1.  **科学上不健全**：物理和数学原理是合理的。\n2.  **无法形式化**：问题已经数学形式化。\n3.  **不完整/矛盾**：每个用例都提供了所有必要的参数（$k_m$, $k_c$, $C_0$, $\\sigma$, 网格参数, $n$）。设置是自洽的。\n4.  **不切实际/不可行**：参数值对于微流控传输现象是物理上合理的。\n5.  **病态的 (Ill-Posed)**：如上所述，问题是良态的。\n6.  **伪深刻/琐碎**：该问题需要对微积分、线性代数和组合优化进行非平凡的应用。包含一个接近简并的用例（用例 B）表明需要仔细的数值实现，这是一个有意义的挑战。\n7.  **超出科学可验证性范围**：解决方案可以通过算法计算和验证。\n\n#### 第3步：裁决与行动\n问题是**有效的**。将提供完整的解决方案。\n\n### 解决方案推导\n\n任务是找到一组 $n$ 个测量时间 $\\{t_1, \\dots, t_n\\}$，使得参数 $\\theta = (k_m, k_c)$ 的费雪信息矩阵的行列式最大化。这是一个D-最优设计问题。\n\n**1. 受体室浓度的解析模型**\n\n耦合常微分方程组为：\n$$ \\frac{dC_d}{dt} = -k_m C_d $$\n$$ \\frac{dC_r}{dt} = k_m C_d - k_c C_r $$\n初始条件为 $C_d(0) = C_0$ 和 $C_r(0) = 0$。\n\n第一个方程是可分离的。其解为：\n$C_d(t) = C_0 e^{-k_m t}$。\n\n将其代入第二个方程，得到一个关于 $C_r(t)$ 的一阶线性常微分方程：\n$$ \\frac{dC_r}{dt} + k_c C_r = k_m C_0 e^{-k_m t} $$\n\n此方程可以使用积分因子求解。解取决于 $k_m = k_c$ 是否成立。\n\n情况1：$k_m \\neq k_c$\n受体室浓度的解，我们将其表示为测量模型 $m(t; \\theta)$，是：\n$$ m(t; k_m, k_c) = C_r(t) = C_0 \\frac{k_m}{k_c - k_m} (e^{-k_m t} - e^{-k_c t}) $$\n\n情况2：$k_m = k_c = k$\n在这种特殊情况下，解为：\n$$ m(t; k, k) = C_r(t) = C_0 k t e^{-k t} $$\n这可以通过在第一种情况下对 $k_c \\to k_m$ 应用洛必达法则来证实。\n\n**2. 灵敏度分析**\n\n费雪信息矩阵需要模型 $m(t; \\theta)$ 对参数 $\\theta = (k_m, k_c)$ 的灵敏度。这些是偏导数 $\\frac{\\partial m}{\\partial k_m}$ 和 $\\frac{\\partial m}{\\partial k_c}$。对情况1中 $m(t; k_m, k_c)$ 的表达式进行微分，得到：\n$$ \\frac{\\partial m}{\\partial k_m} = C_0 \\frac{k_c}{(k_c-k_m)^2}(e^{-k_m t} - e^{-k_c t}) - C_0 \\frac{k_m}{k_c - k_m} t e^{-k_m t} $$\n$$ \\frac{\\partial m}{\\partial k_c} = -C_0 \\frac{k_m}{(k_c-k_m)^2}(e^{-k_m t} - e^{-k_c t}) + C_0 \\frac{k_m}{k_c - k_m} t e^{-k_c t} $$\n\n**3. 数值稳定公式**\n\n推导出的模型及其灵敏度的表达式涉及 $(k_c - k_m)^{-1}$ 和 $(k_c - k_m)^{-2}$ 等项。当 $k_m$ 接近 $k_c$ 时（如测试用例 B），这些表达式会遭受灾难性抵消和精度损失。需要一个数值上鲁棒的公式。\n\n令 $x = (k_m - k_c)t$。我们可以将模型重写为：\n$$ m(t; k_m, k_c) = C_0 k_m e^{-k_m t} \\frac{e^{(k_m-k_c)t} - 1}{k_m-k_c} = C_0 k_m t e^{-k_m t} \\left(\\frac{e^x - 1}{x}\\right) $$\n令 $g(x) = \\frac{e^x - 1}{x}$。对于小的 $x$，$g(x) \\approx 1$。在实现中，我们对 $x \\neq 0$ 使用 `(numpy.expm1(x)) / x`，并令 $g(0)=1$。\n\n灵敏度也必须重新表述。通过对 $m(t)$ 的稳定形式对 $k_m$ 和 $k_c$ 求导，我们得到：\n$$ \\frac{\\partial m}{\\partial k_m} = C_0 t e^{-k_m t} \\left[ (1 - k_m t) g(x) + k_m t \\cdot h(x) \\right] $$\n$$ \\frac{\\partial m}{\\partial k_c} = -C_0 k_m t^2 e^{-k_m t} h(x) $$\n其中 $h(x) = g'(x) = \\frac{x e^x - (e^x - 1)}{x^2} = \\frac{e^x(x-1)+1}{x^2}$。\n当 $x \\to 0$ 时，$h(x) \\to 1/2$。在实现中，对 $x \\neq 0$ 可以使用 `(numpy.exp(x)*(x-1) + 1) / x**2` 的形式，其极限值为 $h(0) = 0.5$。表达式 `(numpy.expm1(x)*(x-1) + x) / x**2` 对于小的 $x$ 提供了更优的数值稳定性。\n\n**4. 费雪信息矩阵与 D-最优性**\n\n在时间点 $\\{t_1, \\dots, t_n\\}$ 进行 $n$ 次测量的费雪信息矩阵为：\n$$ \\mathcal{I} = \\frac{1}{\\sigma^2} \\sum_{i=1}^{n} \\nabla_{\\theta} m(t_i) \\, \\nabla_{\\theta} m(t_i)^{\\top} $$\n其中梯度向量（灵敏度）为 $\\nabla_{\\theta} m(t) = \\begin{pmatrix} \\partial m/\\partial k_m \\\\ \\partial m/\\partial k_c \\end{pmatrix}$。外积是一个 $2 \\times 2$ 矩阵。\nD-最优性准则旨在最大化 $\\det(\\mathcal{I})$。由于 $\\sigma^2$ 对于每个用例都是一个常数标量，最大化 $\\det(\\mathcal{I})$ 等价于最大化外积之和矩阵 $\\mathcal{I}_{\\text{sum}}$ 的行列式：\n$$ \\mathcal{I}_{\\text{sum}} = \\sum_{i=1}^{n} \\begin{pmatrix} (\\frac{\\partial m}{\\partial k_m})^2  \\frac{\\partial m}{\\partial k_m}\\frac{\\partial m}{\\partial k_c} \\\\ \\frac{\\partial m}{\\partial k_m}\\frac{\\partial m}{\\partial k_c}  (\\frac{\\partial m}{\\partial k_c})^2 \\end{pmatrix}_{t=t_i} $$\n要最大化的行列式是 $\\det(\\mathcal{I}_{\\text{sum}}) = \\left(\\sum_i (\\frac{\\partial m}{\\partial k_m})^2\\right) \\left(\\sum_i (\\frac{\\partial m}{\\partial k_c})^2\\right) - \\left(\\sum_i \\frac{\\partial m}{\\partial k_m}\\frac{\\partial m}{\\partial k_c}\\right)^2$。\n\n**5. 最优时间选择算法**\n\n最优测量时间集通过对可能时间的离散网格进行组合搜索来找到。\n1. 对于每个测试用例，定义参数 ($k_m, k_c, C_0$) 和搜索网格 ($t_{\\min}, t_{\\max}, \\Delta t, n$)。\n2. 从时间网格中生成所有 $n$ 个时间的唯一组合。组合数量足够小，可以进行穷举搜索。\n3. 对于每个时间组合 $\\{t_1, \\dots, t_n\\}$：\n    a. 初始化一个 $2 \\times 2$ 的零矩阵 $\\mathcal{I}_{\\text{sum}}$。\n    b. 对于组合中的每个时间 $t_i$，使用数值稳定的公式计算灵敏度向量 $\\nabla m(t_i)$。\n    c. 计算外积 $\\nabla m(t_i) \\nabla m(t_i)^{\\top}$ 并将其加到 $\\mathcal{I}_{\\text{sum}}$。\n    d. 在对所有 $t_i$ 求和后，计算 $\\det(\\mathcal{I}_{\\text{sum}})$。\n4. 记录产生最大行列式的时间组合。Python 的 `itertools.combinations` 函数按字典序生成元组，因此第一个达到最大值的组合将是字典序最小的，从而满足平局决胜规则。\n\n对指定的三个测试用例分别执行此过程。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Finds the D-optimal set of measurement times for a two-compartment model\n    by searching over a discrete time grid.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"km\": 1e-3, \"kc\": 4e-4, \"C0\": 1.0, \"sigma\": 1e-4,\n            \"t_min\": 600, \"t_max\": 3600, \"dt\": 600, \"n\": 4\n        },\n        {\n            \"km\": 5e-4, \"kc\": 4.9e-4, \"C0\": 1.0, \"sigma\": 1e-4,\n            \"t_min\": 600, \"t_max\": 3600, \"dt\": 600, \"n\": 4\n        },\n        {\n            \"km\": 3e-3, \"kc\": 1e-3, \"C0\": 1.0, \"sigma\": 5e-4,\n            \"t_min\": 60, \"t_max\": 600, \"dt\": 60, \"n\": 3\n        }\n    ]\n\n    def get_sensitivities(t, km, kc, C0):\n        \"\"\"\n        Calculates the sensitivities of the receiver concentration with respect to\n        km and kc using a numerically stable formulation.\n        \n        Args:\n            t (float): Time point.\n            km (float): Membrane transport rate constant.\n            kc (float): Clearance rate constant.\n            C0 (float): Initial donor concentration.\n\n        Returns:\n            numpy.ndarray: A 2-element array [dC_r/dkm, dC_r/dkc].\n        \"\"\"\n        x = (km - kc) * t\n        \n        # Numerically stable function for g(x) = (e^x - 1) / x\n        if np.isclose(x, 0.0):\n            g_val = 1.0\n        else:\n            g_val = np.expm1(x) / x\n\n        # Numerically stable function for h(x) = (e^x(x-1) + 1) / x^2\n        # Using the form (expm1(x)*(x-1) + x) / x**2 is better for small x\n        if np.isclose(x, 0.0):\n            h_val = 0.5\n        else:\n            # This form avoids cancellation in the numerator for x near 0\n            numerator = np.expm1(x) * (x - 1) + x\n            h_val = numerator / (x * x)\n\n        exp_km_t = np.exp(-km * t)\n        \n        # Sensitivity with respect to km\n        term1_m = (1 - km * t) * g_val\n        term2_m = km * t * h_val\n        sens_km = C0 * t * exp_km_t * (term1_m + term2_m)\n\n        # Sensitivity with respect to kc\n        sens_kc = -C0 * km * t**2 * exp_km_t * h_val\n\n        return np.array([sens_km, sens_kc])\n\n    all_results = []\n    for case in test_cases:\n        km, kc, C0 = case[\"km\"], case[\"kc\"], case[\"C0\"]\n        t_min, t_max, dt, n = case[\"t_min\"], case[\"t_max\"], case[\"dt\"], case[\"n\"]\n\n        time_grid = np.arange(t_min, t_max + 1, dt)\n        time_combinations = itertools.combinations(time_grid, n)\n\n        max_determinant = -1.0\n        optimal_times = None\n\n        for times in time_combinations:\n            fim_sum = np.zeros((2, 2))\n            for t_point in times:\n                # Get the sensitivity vector [dC_r/dkm, dC_r/dkc]\n                sensitivities = get_sensitivities(float(t_point), km, kc, C0)\n                # Add the outer product to the FIM sum matrix\n                fim_sum += np.outer(sensitivities, sensitivities)\n            \n            # The objective is to maximize det(FIM). Since FIM = (1/sigma^2) * fim_sum,\n            # maximizing det(fim_sum) is equivalent.\n            determinant = np.linalg.det(fim_sum)\n\n            if determinant  max_determinant:\n                max_determinant = determinant\n                optimal_times = times\n\n        all_results.append([int(t) for t in optimal_times])\n    \n    # Format the output as specified: [[t1,t2,...],[...],...]\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[[{','.join(formatted_results)}]]\")\n\nsolve()\n```", "id": "5145058"}]}