{"hands_on_practices": [{"introduction": "在寻找协变量之前，评估基础模型中个体参数估计的质量至关重要。本练习将介绍“收缩”（shrinkage）的概念，这是一个关键的诊断指标，用于量化个体数据与群体先验分布相比，在多大程度上为参数估计提供了信息。理解和计算收缩率有助于判断数据的信息量是否足以支持可靠的协变量关系筛选。[@problem_id:4543399]", "problem": "一个单参数的群体药代动力学/药效动力学 (PK/PD) 层级模型被用来描述清除率的个体间变异。受试者 $i$ 的个体清除率在对数尺度上建模为 $ \\mathrm{CL}_{i} = \\mathrm{CL}_{\\mathrm{pop}} \\times \\exp\\!\\left(\\eta_{\\mathrm{CL},i}\\right) $，其中随机效应 $ \\eta_{\\mathrm{CL},i} $ 代表受试者 $i$ 在对数尺度上偏离群体均值的程度。其先验（受试者间）分布为 $ \\eta_{\\mathrm{CL},i} \\sim \\mathcal{N}(0, \\Omega_{\\mathrm{CL}}) $，其中 $ \\Omega_{\\mathrm{CL}} $ 是 $ \\eta_{\\mathrm{CL}} $ 的群体水平方差。\n\n使用非线性混合效应方法将模型与受试者水平数据 $ y_i $ 进行拟合后，得到条件（后验）分布 $ p\\!\\left(\\eta_{\\mathrm{CL},i} \\mid y_i\\right) $。令 $ \\operatorname{Var}\\!\\left(\\eta_{\\mathrm{CL},i} \\mid y_i\\right) $ 表示受试者 $i$ 随机效应的后验方差。\n\n在协变量分析中，一个广泛使用的诊断指标用于量化数据相对于先验群体不确定性，在多大程度上减少了受试者随机效应的不确定性。将此诊断指标定义为 $ \\eta_{\\mathrm{CL},i} $ 从先验到后验的方差比例缩减，并为一位 $ \\Omega_{\\mathrm{CL}} = 0.36 $ 且 $ \\operatorname{Var}\\!\\left(\\eta_{\\mathrm{CL},i} \\mid y_i\\right) = 0.12 $ 的受试者计算该值。\n\n使用该诊断指标的实用阈值 $ 0.30 $（当诊断值高于此阈值时，基于经验贝叶斯估计的协变量筛选可能变得不可靠），将计算出的诊断指标超出此阈值的部分作为最终答案报告，以无量纲小数表示。将最终答案四舍五入至四位有效数字。", "solution": "用户提供了一个来自群体药代动力学/药效动力学 (PK/PD) 领域的问题陈述，该问题需要进行验证，如果有效，则需要提供解答。\n\n### 第 1 部分：问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n#### 第 1 步：提取已知条件\n-   受试者 $i$ 的个体清除率建模为：$ \\mathrm{CL}_{i} = \\mathrm{CL}_{\\mathrm{pop}} \\times \\exp\\!\\left(\\eta_{\\mathrm{CL},i}\\right) $。\n-   随机效应 $ \\eta_{\\mathrm{CL},i} $ 具有先验（受试者间）分布：$ \\eta_{\\mathrm{CL},i} \\sim \\mathcal{N}(0, \\Omega_{\\mathrm{CL}}) $。\n-   随机效应的先验方差为 $ \\operatorname{Var}(\\eta_{\\mathrm{CL},i}) = \\Omega_{\\mathrm{CL}} $。\n-   观察数据 $ y_i $ 后随机效应的后验方差表示为 $ \\operatorname{Var}\\!\\left(\\eta_{\\mathrm{CL},i} \\mid y_i\\right) $。\n-   该诊断指标定义为“$ \\eta_{\\mathrm{CL},i} $ 从先验到后验的方差比例缩减”。这通常被称为 eta-shrinkage (eta 收缩)。\n-   先验方差的值给定为 $ \\Omega_{\\mathrm{CL}} = 0.36 $。\n-   一位受试者的后验方差值给定为 $ \\operatorname{Var}\\!\\left(\\eta_{\\mathrm{CL},i} \\mid y_i\\right) = 0.12 $。\n-   该诊断指标的实用阈值给定为 $ 0.30 $。\n-   任务是计算所计算的诊断指标超出此阈值的部分。\n-   最终答案必须四舍五入至四位有效数字。\n\n#### 第 2 步：使用提取的已知条件进行验证\n对问题的有效性进行评估：\n\n1.  **科学依据**：该问题设置在非线性混合效应模型的既定框架内，这是现代药理计量学的基石。用于个体间变异的对数正态模型、对随机效应使用先验和后验分布，以及将 eta-shrinkage (eta 收缩) 概念作为诊断指标，都是该领域内标准、有据可查且科学合理的原则。所提供的方差数值是合理的。\n2.  **适定性**：问题定义清晰。它要求基于精确的定义和给定的数值计算一个特定的量。存在唯一解。\n3.  **客观性**：问题以精确、定量和无偏见的语言陈述。\n4.  **完整性与一致性**：问题是自洽的。所有必要的数据（$ \\Omega_{\\mathrm{CL}} $，$ \\operatorname{Var}\\!\\left(\\eta_{\\mathrm{CL},i} \\mid y_i\\right) $）和定义都已提供，并且没有内部矛盾。\n5.  **现实性**：在典型的群体 PK 研究背景下，该场景和数据值是现实的。\n\n该问题没有表现出任何诸如科学不合理、含糊不清或信息缺失等缺陷。\n\n#### 第 3 步：结论与行动\n该问题是**有效的**。我将继续提供完整的解答。\n\n### 第 2 部分：解答\n\n该问题要求我们计算一个诊断指标，该指标定义为在数据上进行条件化后，随机效应 $ \\eta_{\\mathrm{CL},i} $ 的方差比例缩减。\n\n令 $S$ 代表该诊断指标。给出的定义是“从先验到后验的方差比例缩减”。让我们将其形式化。\n\n先验方差是随机效应群体分布的方差，给定为 $ \\Omega_{\\mathrm{CL}} $。\n$$ \\operatorname{Var}_{\\text{prior}} = \\operatorname{Var}(\\eta_{\\mathrm{CL},i}) = \\Omega_{\\mathrm{CL}} $$\n\n后验方差是给定特定个体数据 $ y_i $ 后，该个体随机效应的条件分布的方差。这被给定为 $ \\operatorname{Var}(\\eta_{\\mathrm{CL},i} \\mid y_i) $。\n$$ \\operatorname{Var}_{\\text{post}} = \\operatorname{Var}(\\eta_{\\mathrm{CL},i} \\mid y_i) $$\n\n方差的绝对减少量是先验方差和后验方差之间的差值：\n$$ \\text{Reduction} = \\operatorname{Var}_{\\text{prior}} - \\operatorname{Var}_{\\text{post}} = \\Omega_{\\mathrm{CL}} - \\operatorname{Var}(\\eta_{\\mathrm{CL},i} \\mid y_i) $$\n\n方差的比例缩减是这个绝对减少量除以原始（先验）方差：\n$$ S = \\frac{\\operatorname{Var}_{\\text{prior}} - \\operatorname{Var}_{\\text{post}}}{\\operatorname{Var}_{\\text{prior}}} $$\n代入符号表示：\n$$ S = \\frac{\\Omega_{\\mathrm{CL}} - \\operatorname{Var}(\\eta_{\\mathrm{CL},i} \\mid y_i)}{\\Omega_{\\mathrm{CL}}} $$\n该表达式可以简化为：\n$$ S = 1 - \\frac{\\operatorname{Var}(\\eta_{\\mathrm{CL},i} \\mid y_i)}{\\Omega_{\\mathrm{CL}}} $$\n在药理计量学软件和文献中，这个量通常被称为 eta-shrinkage (eta 收缩)。\n\n现在，我们代入问题陈述中提供的数值：$ \\Omega_{\\mathrm{CL}} = 0.36 $ 和 $ \\operatorname{Var}(\\eta_{\\mathrm{CL},i} \\mid y_i) = 0.12 $。\n$$ S = 1 - \\frac{0.12}{0.36} $$\n分数简化为：\n$$ S = 1 - \\frac{1}{3} = \\frac{2}{3} $$\n诊断指标的值恰好是 $ \\frac{2}{3} $。\n\n问题接着要求计算该诊断指标超出指定阈值的部分。\n设阈值为 $ T $。问题陈述 $ T = 0.30 $。\n超出部分，我们可以表示为 $E$，是诊断值 $S$ 与阈值 $T$ 之间的差：\n$$ E = S - T $$\n代入数值：\n$$ E = \\frac{2}{3} - 0.30 $$\n为了计算这个值，我们可以将两项都表示为分数或小数。\n$$ E = \\frac{2}{3} - \\frac{3}{10} $$\n使用公分母 $30$：\n$$ E = \\frac{2 \\times 10}{3 \\times 10} - \\frac{3 \\times 3}{10 \\times 3} = \\frac{20}{30} - \\frac{9}{30} = \\frac{11}{30} $$\n为了以四舍五入到四位有效数字的小数形式提供答案，我们将分数 $ \\frac{11}{30} $ 转换为其小数表示：\n$$ E = \\frac{11}{30} \\approx 0.366666... $$\n前四位有效数字是 $3$、$6$、$6$ 和 $6$。第五位数字是 $6$，大于或等于 $5$，因此我们将第四位有效数字向上取整。\n$$ E \\approx 0.3667 $$\n这是计算出的诊断指标超出给定阈值的部分，四舍五入至四位有效数字。", "answer": "$$\\boxed{0.3667}$$", "id": "4543399"}, {"introduction": "添加协变量的一个主要目标是解释在个体间或场合间观察到的变异性。本练习演示了如何通过计算预期的方差减少量来从理论上量化协变量的影响。通过应用全方差定律，您将学会在拟合模型之前就估算出一个候选协变量的解释能力，从而对协变量建模的工作原理获得基础性的理解。[@problem_id:4543411]", "problem": "一种口服制剂使用群体药代动力学和药效动力学 (PK/PD) 进行建模，其中口服生物利用度具有对数正态随机效应。生物利用度的场合间变异 (IOV) 在对数尺度上表示。基础模型（不含协变量）对场合水平的对数生物利用度使用以下结构表示：\n$$\n\\ln(F_{i,k}) = \\ln(F_{\\text{pop}}) + \\eta_{F,i} + \\kappa_{F,i,k},\n$$\n其中 $F_{i,k}$ 是个体 $i$ 在场合 $k$ 的生物利用度，$F_{\\text{pop}}$ 是生物利用度的典型值，$\\eta_{F,i} \\sim \\mathcal{N}(0,\\omega_{F}^{2})$ 是个体间随机效应，而 $\\kappa_{F,i,k} \\sim \\mathcal{N}(0,\\pi_{0}^{2})$ 是场合间随机效应。估计的基础模型中对数尺度上的场合间标准差为 $0.30$，即 $\\pi_{0} = 0.30$。\n\n在场合水平上考虑了一个进食/禁食二元协变量 $\\text{FED}_{i,k} \\in \\{0,1\\}$，其中 $\\text{FED}_{i,k}=1$ 表示进食状态，$\\text{FED}_{i,k}=0$ 表示禁食状态。估计的效应大小表明，相对于禁食状态，进食状态使生物利用度乘以 $0.75$。在对数尺度上，这相当于在进食时 $\\ln(F_{i,k})$ 发生一个 $\\beta = \\ln(0.75)$ 的加性偏移。进食场合的比例为 $p = 0.60$，禁食场合以 $1-p$ 的概率发生。\n\n假设协变量指示符 $\\text{FED}_{i,k}$ 与随机效应无关，并且添加协变量会使场合水平对数生物利用度的均值发生偏移，而不改变 $\\kappa_{F,i,k}$ 的残差高斯结构。在这些假设下，仅使用基本的方差分解原理，计算将进食/禁食协变量添加到生物利用度模型中后，对数尺度上场合间方差的预期绝对减少量。以无量纲量的形式报告您的答案。将答案四舍五入至四位有效数字。\n\n此外，简要指出用于评估是否纳入该协变量的适当模型比较指标，并描述应如何解释这些指标的变化，但不要在最终的数值答案中包含任何解释性文本。", "solution": "该问题已经过验证，被认为是科学上合理、提法明确且客观的。这是在药学计量建模背景下对方差分解原理的标准应用。\n\n主要任务是计算当一个二元协变量被添加到模型中时，对数生物利用度场合间方差的预期绝对减少量。这个减少量即为协变量所能解释的变异量。该问题可以通过应用全方差定律来解决。\n\n设 $Y_{i,k}$ 为个体 $i$ 在场合 $k$ 的对数生物利用度的场合水平分量。在基础模型中，这整个分量由单个随机效应项 $\\kappa_{F,i,k}$ 描述，该项假定均值为 $0$，方差为 $\\pi_0^2$。这个方差 $\\pi_0^2$ 代表了在考虑任何协变量之前的总场合间方差。\n根据问题陈述，标准差为 $\\pi_0 = 0.30$，因此基础模型中的总场合间方差为 $\\pi_0^2 = (0.30)^2 = 0.09$。\n\n在协变量模型中，场合水平分量 $Y_{i,k}$ 被建模为由协变量引起的固定效应和残差随机效应之和：\n$$\nY_{i,k} = \\beta \\cdot \\text{FED}_{i,k} + \\kappa'_{F,i,k}\n$$\n这里，$\\beta = \\ln(0.75)$ 是进食状态的效应，$\\text{FED}_{i,k}$ 是二元协变量（$1$ 代表进食，$0$ 代表禁食），$\\kappa'_{F,i,k}$ 是协变量模型中的残差场合间随机效应，其方差为 $\\text{Var}(\\kappa'_{F,i,k}) = \\pi_1^2$。基础模型中的随机效应 $\\kappa_{F,i,k}$（方差为 $\\pi_0^2$）可以看作是捕获了中心化后 $Y_{i,k}$ 的总变异。\n\n全方差定律指出，对于两个随机变量 $Y$ 和 $X$，$Y$ 的方差可以分解为：\n$$\n\\text{Var}(Y) = E[\\text{Var}(Y|X)] + \\text{Var}(E[Y|X])\n$$\n在我们的情境中，$Y$ 是场合水平分量，$X$ 是协变量 $\\text{FED}_{i,k}$。\n- $\\text{Var}(Y)$ 是场合水平分量的总方差，即基础模型中的场合间方差 $\\pi_0^2$。\n- $E[\\text{Var}(Y|X)]$ 是在考虑协变量 $X$ 后的预期残差（未解释）方差。这对应于协变量模型中的场合间方差 $\\pi_1^2$。\n- $\\text{Var}(E[Y|X])$ 是由协变量 $X$ 解释的方差。\n\n添加协变量后方差的减少量是总方差与残差方差之差，这等于被解释的方差：\n$$\n\\text{方差减少量} = \\pi_0^2 - \\pi_1^2 = \\text{Var}(E[Y_{i,k}|\\text{FED}_{i,k}])\n$$\n我们需要计算 $\\text{Var}(E[Y_{i,k}|\\text{FED}_{i,k}])$。首先，我们求在给定 $\\text{FED}_{i,k}$ 值的情况下 $Y_{i,k}$ 的条件期望。随机效应 $\\kappa'_{F,i,k}$ 假定均值为 $0$ 且与协变量无关。\n对于进食状态（$\\text{FED}_{i,k}=1$）：\n$$\nE[Y_{i,k}|\\text{FED}_{i,k}=1] = E[\\beta \\cdot 1 + \\kappa'_{F,i,k}] = \\beta + E[\\kappa'_{F,i,k}] = \\beta\n$$\n对于禁食状态（$\\text{FED}_{i,k}=0$）：\n$$\nE[Y_{i,k}|\\text{FED}_{i,k}=0] = E[\\beta \\cdot 0 + \\kappa'_{F,i,k}] = 0 + E[\\kappa'_{F,i,k}] = 0\n$$\n因此，$E[Y_{i,k}|\\text{FED}_{i,k}]$ 是一个新的随机变量，它以概率 $p = P(\\text{FED}_{i,k}=1) = 0.60$ 取值 $\\beta$，并以概率 $1-p = 0.40$ 取值 $0$。这是一个缩放的伯努利随机变量。\n\n这个随机变量的方差 $\\text{Var}(E[Y_{i,k}|\\text{FED}_{i,k}])$ 的计算如下。\n首先，计算其期望：\n$$\nE[E[Y_{i,k}|\\text{FED}_{i,k}]] = \\beta \\cdot p + 0 \\cdot (1-p) = \\beta p\n$$\n其次，计算其方差：\n$$\n\\text{Var}(E[Y_{i,k}|\\text{FED}_{i,k}]) = E[(E[Y_{i,k}|\\text{FED}_{i,k}])^2] - (E[E[Y_{i,k}|\\text{FED}_{i,k}]])^2\n$$\n$$\nE[(E[Y_{i,k}|\\text{FED}_{i,k}])^2] = \\beta^2 \\cdot p + 0^2 \\cdot (1-p) = \\beta^2 p\n$$\n将此代入方差公式中：\n$$\n\\text{Var}(E[Y_{i,k}|\\text{FED}_{i,k}]) = \\beta^2 p - (\\beta p)^2 = \\beta^2 p - \\beta^2 p^2 = \\beta^2 p(1-p)\n$$\n这个量就是场合间方差的绝对减少量。\n\n现在我们代入给定值：\n- $\\beta = \\ln(0.75)$\n- $p = 0.60$\n\n方差减少量 $= (\\ln(0.75))^2 \\cdot (0.60) \\cdot (1-0.60)$\n$$\n\\text{方差减少量} = (\\ln(0.75))^2 \\cdot (0.60) \\cdot (0.40) = (\\ln(0.75))^2 \\cdot 0.24\n$$\n数值计算：\n$\\ln(0.75) \\approx -0.28768$\n$(\\ln(0.75))^2 \\approx 0.0827608$\n方差减少量 $\\approx 0.0827608 \\times 0.24 \\approx 0.01986259$\n\n四舍五入到四位有效数字，方差的绝对减少量是 $0.01986$。\n\n关于问题的第二部分，有几个指标适合用于评估在群体PK/PD模型中是否应纳入某个协变量：\n1.  **似然比检验 (LRT):** 该检验比较嵌套的基础模型和协变量模型之间的目标函数值 (OFV)，通常是 $-2 \\times \\text{对数似然}$。OFV 的统计显著下降（例如，对于增加一个参数，在显著性水平 $\\alpha=0.05$ 时，下降超过 $3.84$）支持纳入该协变量。\n2.  **信息准则 (AIC/BIC):** 可以使用赤池信息准则 (AIC) 或贝叶斯信息准则 (BIC)。这些准则在模型拟合度 (OFV) 和模型简约性（参数数量）之间进行权衡。AIC 或 BIC 值较低的模型更优。\n3.  **未解释变异的减少：** 随机效应参数（在此例中为场合间方差 $\\pi^2$）的方差在临床上或统计上有意义的减少，表明该协变量解释了相当一部分的变异。\n4.  **参数精度：** 如果协变量的效应大小（此处为 $\\beta$）估计具有足够的精度（通常通过较低的相对标准误差 (RSE) 来评估），则支持纳入该协变量。\n5.  **拟合优度 (GOF) 图：** 使用可视化诊断，如残差图或随机效应的经验贝叶斯估计值与协变量的散点图，来评估协变量模型是否成功地解释了基础模型中存在的趋势。", "answer": "$$\n\\boxed{0.01986}\n$$", "id": "4543411"}, {"introduction": "选择正确的协变量具有挑战性，因为自动化流程可能对特定数据集很敏感。这项高级练习要求您实施一项基于自助法（bootstrap）的分析，以评估协变量选择过程的稳定性和可靠性。通过重复重采样数据并执行模型选择，您将学会评估哪些协变量关系是稳健的，哪些可能是虚假的发现，这是现代严谨药理计量学实践的基石。[@problem_id:4543456]", "problem": "您的任务是，在一个简化的群体药代动力学/药效动力学 (PK/PD) 协变量建模问题中，对基于 bootstrap 的协变量选择稳定性分析进行形式化、实现和评估。工作将在一个线性高斯框架内进行，该框架抽象了群体模型中常用的“参数对数对协变量”的公式。\n\n假设一个个体层面的结构模型，其中受试者 $i$ 的响应 $y_i$（可解释为对数转换后的 PK 参数，如清除率）满足\n$$\ny_i \\;=\\; \\beta_0 \\;+\\; \\sum_{j=1}^{p} \\beta_j x_{ij} \\;+\\; \\varepsilon_i, \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2), \\quad i=1,\\dots,n,\n$$\n其中有 $p=4$ 个候选协变量。为具体起见，设 $x_{i1}$ 和 $x_{i2}$ 为连续协变量，联合服从均值为零、相关系数为 $\\rho$、单位方差的二元正态分布；设 $x_{i3}$ 和 $x_{i4}$ 为独立的二元协变量，分别从概率为 $\\pi_3$ 和 $\\pi_4$ 的伯努利分布中抽取。截距项总是包含在模型中。协变量集合为 $\\{x_{1},x_{2},x_{3},x_{4}\\}$，索引为 1 到 4。\n\n在每次 bootstrap 重采样中，使用源自高斯对数似然的赤池信息准则 (AIC) 进行前向模型选择。令 $k$ 表示模型中当前自由回归参数的数量（包括截距），$n$ 表示重采样中的样本量，$\\widehat{\\sigma}^2$ 表示在系数的最大似然估计下的残差方差估计。使用高斯对数似然，候选模型 $\\mathcal{M}$ 的 AIC 可以写为\n$$\n\\mathrm{AIC}(\\mathcal{M}) \\;=\\; 2k \\;-\\; 2\\,\\ell(\\hat{\\theta}\\,|\\,\\text{data}) \\;=\\; n \\,\\log\\!\\left(\\frac{\\mathrm{RSS}}{n}\\right) \\;+\\; 2k \\;+\\; C,\n$$\n其中 $\\mathrm{RSS}$ 是模型 $\\mathcal{M}$ 下的残差平方和，而 $C$ 是一个常数，对于固定的数据集，它不影响模型之间的比较。使用 AIC 差异来比较模型，从仅含截距的模型（无协变量）开始，在每一步贪婪地添加能使 AIC 实现最大严格减小的单个协变量；当没有协变量的加入能带来 AIC 减小时停止。\n\n使用重采样大小等于 $n$ 的非参数 bootstrap 来量化协变量选择的稳定性。在 $B$ 次重采样中，为每个协变量 $j \\in \\{1,2,3,4\\}$ 计算：\n- 选择频率 $f_j$，定义为在所有重采样中，协变量 $j$ 被包含在所选模型中的比例（实数 $\\mathbb{R}$）。\n- 符号一致性 $s_j$，定义为（在协变量 $j$ 被选中的那些重采样中）估计系数 $\\hat{\\beta}_j$ 的符号与这些选择中的多数符号一致的次数所占的比例（实数 $\\mathbb{R}$）。具体来说，如果在协变量 $j$ 被选中的样本中，其系数估计值严格为正和严格为负的计数分别为 $N_j^+$ 和 $N_j^-$，那么当 $N_j^+ + N_j^- > 0$ 时，$s_j = \\max(N_j^+,N_j^-)/(N_j^+ + N_j^-)$，否则 $s_j = 0$。\n\n提出并实现以下保留准则：如果 $f_j \\ge p^\\star$ 且 $s_j \\ge s^\\star$，则保留协变量 $j$，其中 $p^\\star$ 和 $s^\\star$ 是用户指定的阈值（实数 $\\mathbb{R}$）。每个测试用例的最终答案是保留下来的协变量的 1-based 索引的排序列表（升序）。\n\n您的实现应仅基于上述定义和以下基本要素：高斯线性模型、高斯误差下的最大似然估计、源于 Kullback–Leibler 散度最小化的用于模型比较的赤池信息准则，以及非参数 bootstrap。\n\n测试集。为保证可复现性，请使用指定的伪随机种子为每个案例生成数据。对于每个案例，使用提供的参数模拟一次数据集 $(X,y)$，然后运行所述的 bootstrap 工作流程。使用以下四个测试用例，每个用例由一个参数元组 $(\\text{seed},n,\\beta,\\rho,\\pi_3,\\pi_4,\\sigma,B,p^\\star,s^\\star)$ 指定，其中 $\\beta$ 是向量 $(\\beta_0,\\beta_1,\\beta_2,\\beta_3,\\beta_4)$：\n- 案例 1：$(20231101,\\;200,\\;(\\,0.0,\\,0.5,\\,0.0,\\,0.8,\\,0.0\\,),\\;0.5,\\;0.5,\\;0.5,\\;1.0,\\;200,\\;0.7,\\;0.9)$。\n- 案例 2：$(20231102,\\;80,\\;(\\,0.0,\\,0.6,\\,0.0,\\,0.0,\\,0.0\\,),\\;0.9,\\;0.5,\\;0.5,\\;1.0,\\;200,\\;0.8,\\;0.9)$。\n- 案例 3：$(20231103,\\;300,\\;(\\,0.0,\\,0.0,\\,0.7,\\,0.0,\\,0.9\\,),\\;0.2,\\;0.3,\\;0.4,\\;0.5,\\;200,\\;0.7,\\;0.9)$。\n- 案例 4：$(20231104,\\;120,\\;(\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,),\\;0.2,\\;0.5,\\;0.5,\\;1.0,\\;200,\\;0.6,\\;0.8)$。\n\n实现要求：\n- 使用指定的种子进行随机数生成，以确保确定性输出。\n- 对于每个测试用例，生成均值为零、单位方差、相关系数为 $\\rho$ 的二元正态分布的 $(x_{i1},x_{i2})$，概率为 $\\pi_3$ 和 $\\pi_4$ 的独立伯努利分布的 $(x_{i3},x_{i4})$，以及 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$。\n- 通过普通最小二乘法（高斯误差下的最大似然估计）拟合模型，并使用公式 $n \\log(\\mathrm{RSS}/n) + 2k$ 计算 AIC 进行模型比较（忽略常数项）。\n- 在每次 bootstrap 重采样中，使用基于 AIC 严格减小的贪婪前向选择，从仅含截距的模型开始，当没有候选协变量的加入能降低 AIC 时停止。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的保留协变量索引的排序列表。使用 1-based 索引。例如，对于三个案例，一个语法正确的输出可能看起来像 $[[1,3],[],[2,4]]$（这只是一个示例；您必须输出指定的四个案例的结果）。", "solution": "用户提供了一个定义明确的计算统计学问题，要求在线性模型框架下实现一个基于 bootstrap 的协变量选择稳定性分析。该问题在科学上是合理的，内部一致，并且提供了足够的细节以获得唯一且可复现的解决方案。\n\n### 分步解决方案推导\n\n**1. 问题形式化与数据生成**\n\n问题的核心是线性模型：\n$$\ny_i \\;=\\; \\beta_0 \\;+\\; \\sum_{j=1}^{4} \\beta_j x_{ij} \\;+\\; \\varepsilon_i, \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)\n$$\n对于每个测试用例，我们必须首先根据指定的参数 $(\\text{seed},n,\\beta,\\rho,\\pi_3,\\pi_4,\\sigma)$ 模拟一个大小为 $n$ 的单个数据集。\n- 使用给定的 `seed` 为 `numpy` 伪随机数生成器设定种子。\n- 连续协变量 $(x_{i1}, x_{i2})$ 从均值为 $\\boldsymbol{\\mu} = [0, 0]$、协方差矩阵为 $\\Sigma = \\begin{pmatrix} 1  \\rho \\\\ \\rho  1 \\end{pmatrix}$ 的二元正态分布中抽取。这可以使用 `numpy.random.multivariate_normal` 来实现。\n- 二元协变量 $(x_{i3}, x_{i4})$ 分别从成功概率为 $\\pi_3$ 和 $\\pi_4$ 的独立伯努利分布中抽取。这可以使用 `numpy.random.binomial(1, p, size=n)` 来实现。\n- 将四个协变量组合成一个 $n \\times 4$ 的设计矩阵 $X$。\n- 误差项 $\\varepsilon$ 是一个从正态分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽取的 $n \\times 1$ 向量，通过 `numpy.random.normal(0, sigma, size=n)` 实现。\n- 响应向量 $y$ 计算为 $y = \\beta_0 + X \\cdot (\\beta_1, \\beta_2, \\beta_3, \\beta_4)^T + \\varepsilon$。\n\n**2. Bootstrap 过程**\n\n执行一个具有 $B$ 次重采样的非参数 bootstrap 过程。对于 $B$ 次迭代中的每一次：\n- 通过从 $\\{0, 1, \\dots, n-1\\}$ 中有放回地抽取 $n$ 个索引来创建一个大小为 $n$ 的 bootstrap 样本。\n- 使用这些索引从原始模拟数据集 $(X,y)$ 中形成一个新的数据集 $(X_{boot}, y_{boot})$。\n\n**3. 使用 AIC 的前向选择**\n\n在每次 bootstrap 迭代中，应用贪婪前向选择算法来选择协变量。\n- 过程从一个只包含截距 $\\beta_0$ 的空模型开始。\n- 使用赤池信息准则 (AIC) 进行模型比较。指定的公式为 $\\mathrm{AIC} = n \\log(\\mathrm{RSS}/n) + 2k$，其中 $n$ 是样本量，$\\mathrm{RSS}$ 是残差平方和，$k$ 是估计的回归参数数量，包括截距。我们可以使用普通最小二乘法 (OLS) 来计算任何候选模型的 RSS 和系数，对于高斯误差模型，这等同于最大似然估计。`numpy.linalg.lstsq` 适合此任务。\n- 在前向选择的每一步，我们考虑将当前未选择的每个协变量添加到模型中。\n- 将那个其加入能导致 AIC *严格减小*幅度最大的协变量添加到模型中。\n- 当没有单个协变量的加入能够降低当前模型的 AIC 时，过程终止。\n- 记录 bootstrap 重采样中最终模型的所选协变量集及其估计系数。\n\n**4. 稳定性指标计算**\n\n完成所有 $B$ 次 bootstrap 迭代后，我们汇总结果，为 $p=4$ 个协变量中的每一个计算两个稳定性指标。\n- **选择频率 ($f_j$)：** 对于每个协变量 $j \\in \\{1, 2, 3, 4\\}$，这是它在 $B$ 次 bootstrap 重采样中被包含在最终模型中的次数，除以 $B$。\n$$\nf_j = \\frac{\\text{Count}(\\text{协变量 } j \\text{ 被选中})}{B}\n$$\n- **符号一致性 ($s_j$)：** 这衡量了在协变量被选中的条件下，其估计系数 $\\hat{\\beta}_j$ 符号的一致性。设 $N_j^+$ 为在协变量 $j$ 被选中的重采样中，其估计值严格为正的次数， $N_j^-$ 为严格为负的次数。符号一致性为：\n$$\ns_j = \\begin{cases} \\frac{\\max(N_j^+, N_j^-)}{N_j^+ + N_j^-}  \\text{若 } N_j^+ + N_j^- > 0 \\\\ 0  \\text{否则} \\end{cases}\n$$\n$N_j^+ + N_j^- = 0$ 的情况涵盖了协变量从未被选中以及（不太可能的）其估计系数在被选中时总是恰好为零的场景。\n\n**5. 保留准则**\n\n最后，根据预定义的阈值 $p^\\star$ 和 $s^\\star$ 来决定保留或丢弃每个协变量。当且仅当同时满足以下两个条件时，协变量 $j$ 被保留：\n- $f_j \\ge p^\\star$\n- $s_j \\ge s^\\star$\n\n一个测试用例的最终输出是满足此保留准则的协变量的 1-based 索引的排序列表。\n\n**6. 实现策略**\n\n整体逻辑将封装在一个处理单个测试用例的函数中。一个顶层函数将遍历四个测试用例，为每个用例调用处理函数，并按要求将最终结果格式化为单个字符串。\n\n核心计算步骤包括：\n- 一个数据生成函数。\n- 一个协调 bootstrap 循环的主分析函数。\n- 一个前向选择函数，它接受一个数据集 $(X,y)$ 并返回所选的协变量及其系数。该函数内部将使用 OLS 求解器 (`np.linalg.lstsq`) 和指定的 AIC 公式。一个接受 `(n, RSS, k)` 作为参数来计算 AIC 的辅助函数会很有用。\n- 仔细管理索引（计算使用 0-based，最终输出使用 1-based）和用于存储 bootstrap 结果的数据结构（例如，用于存储所选系数的列表的列表）对于确保正确性至关重要。\n\n这种结构化方法确保了问题的所有要求都以逻辑和可验证的方式得到满足。为每个案例使用固定的种子保证了整个模拟和分析流程的可复现性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the bootstrap stability analysis for all specified test cases.\n    \"\"\"\n    test_cases = [\n        # (seed, n, beta, rho, pi_3, pi_4, sigma, B, p_star, s_star)\n        (20231101, 200, (0.0, 0.5, 0.0, 0.8, 0.0), 0.5, 0.5, 0.5, 1.0, 200, 0.7, 0.9),\n        (20231102, 80, (0.0, 0.6, 0.0, 0.0, 0.0), 0.9, 0.5, 0.5, 1.0, 200, 0.8, 0.9),\n        (20231103, 300, (0.0, 0.0, 0.7, 0.0, 0.9), 0.2, 0.3, 0.4, 0.5, 200, 0.7, 0.9),\n        (20231104, 120, (0.0, 0.0, 0.0, 0.0, 0.0), 0.2, 0.5, 0.5, 1.0, 200, 0.6, 0.8),\n    ]\n\n    results = []\n    for params in test_cases:\n        retained_indices = run_analysis_for_case(params)\n        results.append(retained_indices)\n    \n    # Format the final output string to remove spaces for exact match.\n    final_output_str = str(results).replace(\" \", \"\")\n    print(final_output_str)\n\ndef calculate_aic(n, rss, k):\n    \"\"\"Calculates AIC using the specified formula.\"\"\"\n    if rss = 1e-9:  # Treat near-zero RSS as a perfect fit, avoid log(0)\n        return -np.inf\n    return n * np.log(rss / n) + 2 * k\n\ndef forward_selection(X_boot, y_boot, n_covariates):\n    \"\"\"\n    Performs greedy forward selection based on AIC.\n    Returns a dictionary of {selected_cov_index: coefficient}.\n    \"\"\"\n    n_samples = len(y_boot)\n    selected_indices = []\n\n    # Intercept-only model\n    X_design_intercept = np.ones((n_samples, 1))\n    _, rss_val, _, _ = np.linalg.lstsq(X_design_intercept, y_boot, rcond=None)\n    rss_intercept = rss_val[0] if len(rss_val) > 0 else 0.0\n    k_intercept = 1\n    best_aic = calculate_aic(n_samples, rss_intercept, k_intercept)\n\n    while True:\n        aic_this_step = best_aic\n        best_new_covariate = -1\n        \n        potential_covariates = [i for i in range(n_covariates) if i not in selected_indices]\n        if not potential_covariates:\n            break\n            \n        for cov_idx in potential_covariates:\n            current_testing_indices = selected_indices + [cov_idx]\n            \n            X_cols = X_boot[:, current_testing_indices]\n            X_design = np.column_stack([np.ones(n_samples), X_cols])\n            k = X_design.shape[1]\n            \n            _, rss_val, _, _ = np.linalg.lstsq(X_design, y_boot, rcond=None)\n            rss = rss_val[0] if len(rss_val) > 0 else 0.0\n\n            current_aic = calculate_aic(n_samples, rss, k)\n            \n            if current_aic  aic_this_step:\n                aic_this_step = current_aic\n                best_new_covariate = cov_idx\n\n        if best_new_covariate != -1:\n            selected_indices.append(best_new_covariate)\n            best_aic = aic_this_step\n        else:\n            break\n            \n    if not selected_indices:\n        return {}\n\n    # Refit final model to get coefficients\n    # Sorting ensures consistent mapping of coefficients\n    final_indices_sorted = sorted(selected_indices)\n    X_cols = X_boot[:, final_indices_sorted]\n    X_design = np.column_stack([np.ones(n_samples), X_cols])\n    \n    coeffs, _, _, _ = np.linalg.lstsq(X_design, y_boot, rcond=None)\n    \n    # Map coefficients back to their original covariate indices (coeffs[0] is the intercept)\n    final_coeffs = {idx: coeff for idx, coeff in zip(final_indices_sorted, coeffs[1:])}\n    \n    return final_coeffs\n\ndef run_analysis_for_case(params):\n    \"\"\"\n    Runs the full simulation and bootstrap analysis for a single test case.\n    \"\"\"\n    seed, n, beta, rho, pi_3, pi_4, sigma, B, p_star, s_star = params\n    n_covariates = 4\n\n    # 1. Generate Data\n    rng = np.random.default_rng(seed)\n    \n    # Continuous covariates\n    cov_matrix = np.array([[1.0, rho], [rho, 1.0]])\n    X_cont = rng.multivariate_normal(mean=[0, 0], cov=cov_matrix, size=n)\n    \n    # Binary covariates\n    X_bin1 = rng.binomial(1, pi_3, size=n)\n    X_bin2 = rng.binomial(1, pi_4, size=n)\n    X_full = np.column_stack([X_cont, X_bin1, X_bin2])\n    \n    # Response\n    beta_vec = np.array(beta)\n    errors = rng.normal(0, sigma, size=n)\n    y = beta_vec[0] + X_full @ beta_vec[1:] + errors\n\n    # 2. Bootstrap Procedure\n    selection_counts = np.zeros(n_covariates)\n    coeff_values = [[] for _ in range(n_covariates)]\n    \n    for _ in range(B):\n        # Create bootstrap sample\n        indices = rng.choice(n, size=n, replace=True)\n        X_boot, y_boot = X_full[indices], y[indices]\n        \n        # Perform forward selection\n        selected_model = forward_selection(X_boot, y_boot, n_covariates)\n        \n        # Store results\n        for idx, coeff in selected_model.items():\n            selection_counts[idx] += 1\n            coeff_values[idx].append(coeff)\n\n    # 3. Calculate Stability Metrics and Apply Retention Criterion\n    retained_indices = []\n    for j in range(n_covariates):\n        # Selection frequency\n        f_j = selection_counts[j] / B\n        \n        # Sign consistency\n        s_j = 0.0\n        if selection_counts[j] > 0:\n            coeffs_j = np.array(coeff_values[j])\n            n_plus = np.sum(coeffs_j > 0)\n            n_minus = np.sum(coeffs_j  0)\n            \n            if (n_plus + n_minus) > 0:\n                s_j = max(n_plus, n_minus) / (n_plus + n_minus)\n\n        # Retention criterion\n        if f_j >= p_star and s_j >= s_star:\n            retained_indices.append(j + 1) # Use 1-based indexing\n            \n    return sorted(retained_indices)\n\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "4543456"}]}