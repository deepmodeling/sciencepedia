{"hands_on_practices": [{"introduction": "在脆弱模型中，我们使用方差参数（如 $ \\sigma^2 $）来量化聚类间的异质性，但这个参数本身缺乏直观的临床解释。为了解决这个问题，我们可以将其转换为一个更有意义的度量——中位风险比（Median Hazard Ratio, MHR）。这个练习将指导你推导并解释MHR，从而在抽象的统计参数与具有临床意义的异质性度量之间架起一座桥梁，这对于有效沟通模型结果至关重要。[@problem_id:4963269]", "problem": "一项多中心临床研究调查了在 $J$ 家医院中，急诊入院后的院内死亡时间。为了解释未测量的医院间异质性，研究人员在医院层面拟合了一个共享对数正态脆弱性 Cox 模型。对于医院 $j$ 中协变量为 $x_{ij}$ 的患者 $i$，其风险函数建模为\n$$\nh_{ij}(t \\mid u_j) \\;=\\; h_0(t)\\,\\exp\\!\\big(x_{ij}^{\\top}\\beta + u_j\\big),\n$$\n其中 $u_j \\sim \\mathcal{N}(0,\\sigma^2)$ 在各医院间独立，而 $h_0(t)$ 是一个未指定的基线风险函数。\n\n定义中位风险比 (MHR) 如下：考虑来自两个随机选择的不同医院的 2 名其他方面完全相同的患者（具有相同的 $x_{ij}$ 和相同的时间 $t$），其脆弱性分别为 $u_{j_1}$ 和 $u_{j_2}$。通过将具有较大脆弱性的医院置于分子中来构建风险比，以使该比率至少为 $1$。MHR 是这个随机风险比关于 $(u_{j_1},u_{j_2})$ 联合分布的中位数。\n\n仅从上述模型定义、正态分布的性质以及随机变量中位数的定义出发，推导 MHR 作为 $\\sigma^2$ 函数的解析表达式。然后，在 $\\sigma^2 = 0.4$ 处计算其值。报告最终数值，四舍五入至 $4$ 位有效数字。无需单位。\n\n最后，用一句话在临床背景下（其中聚类是医院）解释所计算的 MHR 的大小，说明对于其他方面完全相同的患者，由于未测量的医院层面因素，两个随机选择的医院之间的风险差异有多大。您的解释将不作为最终答案数值的一部分。", "solution": "我们从共享对数正态脆弱性模型开始\n$$\nh_{ij}(t \\mid u_j) \\;=\\; h_0(t)\\,\\exp\\!\\big(x_{ij}^{\\top}\\beta + u_j\\big),\n$$\n其中 $u_j \\sim \\mathcal{N}(0,\\sigma^2)$ 在各医院间独立。考虑两个脆弱性分别为 $u_{j_1}$ 和 $u_{j_2}$ 的医院，以及两名其他方面完全相同的患者（具有相同的 $x_{ij}$ 和相同的时间 $t$）。比较高风险医院与低风险医院的风险比为\n$$\n\\text{HR} \\;=\\; \\frac{h_0(t)\\exp(x^{\\top}\\beta + \\max\\{u_{j_1},u_{j_2}\\})}{h_0(t)\\exp(x^{\\top}\\beta + \\min\\{u_{j_1},u_{j_2}\\})}\n\\;=\\; \\exp\\!\\big(\\max\\{u_{j_1},u_{j_2}\\}-\\min\\{u_{j_1},u_{j_2}\\}\\big)\n\\;=\\; \\exp\\!\\big(|u_{j_1}-u_{j_2}|\\big).\n$$\n\n令 $\\Delta u \\equiv u_{j_1} - u_{j_2}$。由于 $u_{j_1}$ 和 $u_{j_2}$ 是独立同分布于 $\\mathcal{N}(0,\\sigma^2)$，差值 $\\Delta u$ 服从均值为 $0$、方差为 $2\\sigma^2$ 的正态分布，即\n$$\n\\Delta u \\sim \\mathcal{N}\\!\\big(0,\\,2\\sigma^2\\big).\n$$\n因此，\n$$\n\\text{HR} \\;=\\; \\exp\\!\\big(|\\Delta u|\\big),\n$$\n而 MHR 是 $\\exp(|\\Delta u|)$ 的中位数。因为指数函数是严格递增的，所以 $\\exp(|\\Delta u|)$ 的中位数等于 $|\\Delta u|$ 中位数的 $\\exp$ 值。因此，\n$$\n\\mathrm{MHR} \\;=\\; \\exp\\!\\big(\\mathrm{median}(|\\Delta u|)\\big).\n$$\n\n我们现在从基本定义出发确定 $\\mathrm{median}(|\\Delta u|)$。令 $\\tau \\equiv \\sqrt{2}\\,\\sigma$，则 $\\Delta u \\sim \\mathcal{N}(0,\\tau^2)$。随机变量 $|\\Delta u|$ 服从折叠正态分布。$|\\Delta u|$ 的中位数 $m$ 满足\n$$\n\\mathbb{P}\\big(|\\Delta u| \\le m\\big) \\;=\\; \\tfrac{1}{2}.\n$$\n根据正态分布的对称性，\n$$\n\\mathbb{P}\\big(|\\Delta u| \\le m\\big) \\;=\\; \\mathbb{P}\\big(-m \\le \\Delta u \\le m\\big) \\;=\\; \\Phi\\!\\Big(\\frac{m}{\\tau}\\Big) - \\Phi\\!\\Big(-\\frac{m}{\\tau}\\Big) \\;=\\; 2\\,\\Phi\\!\\Big(\\frac{m}{\\tau}\\Big) - 1,\n$$\n其中 $\\Phi(\\cdot)$ 表示标准正态分布的累积分布函数。令其等于 $\\tfrac{1}{2}$ 可得\n$$\n2\\,\\Phi\\!\\Big(\\frac{m}{\\tau}\\Big) - 1 \\;=\\; \\tfrac{1}{2}\n\\;\\;\\Longrightarrow\\;\\;\n\\Phi\\!\\Big(\\frac{m}{\\tau}\\Big) \\;=\\; \\tfrac{3}{4}.\n$$\n因此，\n$$\n\\frac{m}{\\tau} \\;=\\; \\Phi^{-1}\\!\\Big(\\tfrac{3}{4}\\Big)\n\\;\\;\\Longrightarrow\\;\\;\nm \\;=\\; \\tau\\,\\Phi^{-1}\\!\\Big(\\tfrac{3}{4}\\Big) \\;=\\; \\sqrt{2}\\,\\sigma \\,\\Phi^{-1}\\!\\Big(\\tfrac{3}{4}\\Big).\n$$\n因此，中位风险比为\n$$\n\\mathrm{MHR} \\;=\\; \\exp\\!\\Big(\\sqrt{2}\\,\\sigma \\,\\Phi^{-1}\\!\\big(\\tfrac{3}{4}\\big)\\Big)\n\\;=\\;\n\\exp\\!\\Big(\\sqrt{2\\sigma^{2}}\\,\\Phi^{-1}\\!\\big(\\tfrac{3}{4}\\big)\\Big).\n$$\n\n我们现在在 $\\sigma^{2} = 0.4$ 处计算此表达式的值。首先计算\n$$\n\\sqrt{2\\sigma^{2}} \\;=\\; \\sqrt{2 \\times 0.4} \\;=\\; \\sqrt{0.8}.\n$$\n使用众所周知的分位数 $\\Phi^{-1}\\!\\big(0.75\\big) \\approx 0.6744897501960817$，我们有\n$$\n\\sqrt{0.8}\\times \\Phi^{-1}\\!\\big(0.75\\big) \\;\\approx\\; 0.8944271909999159 \\times 0.6744897501960817 \\;\\approx\\; 0.603022689.\n$$\n取指数，\n$$\n\\mathrm{MHR} \\;\\approx\\; \\exp(0.603022689) \\;\\approx\\; 1.82764.\n$$\n四舍五入至 $4$ 位有效数字，数值为 $1.828$。\n\n临床背景下的解释：约等于 $1.828$ 的 $\\mathrm{MHR}$ 意味着，对于在两个随机选择的医院接受治疗的、其他方面完全相同的患者，仅由未测量的医院层面因素导致的其事件瞬时风险的中位数乘法差异约为 $1.828$ 倍，其中风险较高医院的患者经历着更大的风险。", "answer": "$$\\boxed{1.828}$$", "id": "4963269"}, {"introduction": "理解了脆弱模型参数的含义之后，下一个自然的问题是如何从数据中估计这些参数。由于脆弱性是未观测到的潜在变量，直接最大化似然函数通常是不可行的。期望最大化（Expectation-Maximization, EM）算法是在存在潜在变量时寻找最大似然估计的强大迭代方法，它通过交替执行“E步”（计算完整数据对数似然的期望）和“M步”（最大化该期望以更新参数）来工作。这个练习将引导你完成Gamma-Weibull脆弱模型的单次完整EM迭代，从而揭开模型拟合“黑箱”的神秘面纱。[@problem_id:4963310]", "problem": "在一个聚类右删失数据集中，根据下述建模假设和定义，实现一个共享脆弱生存模型的单次期望最大化（EM）迭代，并报告指定测试用例的更新后参数。\n\n建模假设与核心定义：\n- 考虑一个共享脆弱模型，其中聚类由 $i \\in \\{1,\\dots, N\\}$ 索引，聚类内的个体由 $j$ 索引。\n- 每个观测时间为 $t_{ij} \\in \\mathbb{R}_{+}$，并带有一个事件指示器 $\\delta_{ij} \\in \\{0,1\\}$，其中 $\\delta_{ij} = 1$ 表示事件发生，$\\delta_{ij} = 0$ 表示右删失。\n- 在给定一个非负共享脆弱项 $Z_i$ 的条件下，个体的生存时间是独立的，其风险函数为 $h(t \\mid Z_i) = Z_i h_0(t)$。其中基线风险为 Weibull 分布：$h_0(t) = \\kappa \\lambda t^{\\kappa-1}$，对应的累积风险为 $H_0(t) = \\lambda t^{\\kappa}$，其中形状参数 $\\kappa > 0$，尺度参数 $\\lambda > 0$。\n- 聚类脆弱项 $Z_i$ 服从均值为 $1$、方差为 $\\theta > 0$ 的 Gamma 分布，等价于 $Z_i \\sim \\mathrm{Gamma}(\\alpha, \\beta)$，其中形状参数 $\\alpha = 1/\\theta$，率参数 $\\beta = 1/\\theta$。这是一个标准选择，可以确保基线风险的可识别性。\n- 对于每个聚类 $i$，完全数据对数似然（忽略不依赖于参数的加性常数）可以使用充分统计量 $d_i = \\sum_j \\delta_{ij}$ 和 $A_i = \\sum_j H_0(t_{ij}) = \\sum_j \\lambda t_{ij}^{\\kappa}$ 来表示。\n\n期望最大化（EM）迭代要求：\n- 期望步（E步）：利用 $Z_i$ 的 Gamma 先验的共轭性以及 $d_i$ 关于暴露量 $A_i$ 的类泊松似然结构，计算条件期望 $\\mathbb{E}[Z_i \\mid \\text{data}, \\theta^{(0)}, \\lambda^{(0)}, \\kappa^{(0)}]$ 和 $\\mathbb{E}[\\log Z_i \\mid \\text{data}, \\theta^{(0)}, \\lambda^{(0)}, \\kappa^{(0)}]$。此处的 $A_i$ 是根据当前基线参数计算的，即 $A_i = \\sum_j \\lambda^{(0)} \\, t_{ij}^{\\kappa^{(0)}}$，而 $d_i = \\sum_j \\delta_{ij}$。\n- 最大化步（M步）：\n  - 通过最大化关于 $\\theta$ 的期望完全数据对数似然来更新脆弱项方差参数 $\\theta$。引入 $\\alpha = 1/\\theta$，并对 $\\alpha$ 使用数值求根方法求解一阶最优性条件。\n  - 通过最大化关于 $(\\lambda, \\kappa)$ 的期望完全数据对数似然来更新 Weibull 基线参数，其中潜变量 $Z_i$ 被其在 E 步中求得的条件期望所替代。这会导出一个关于 $\\kappa$ 的一维求根问题，以及一个在给定 $\\kappa$ 时对 $\\lambda$ 的闭式剖面更新。如果整个数据集中没有事件，为保持数值稳定性，保持 $(\\lambda, \\kappa)$ 不变。\n\n计算与算法约束：\n- 假设无协变量且为独立右删失。\n- 在 M 步中使用鲁棒的一维数值求根求解器，确保所有参数的正性约束都得到满足。如有必要，将根限定在区间 $[10^{-6}, 10^{2}]$ 内，并在有适当保障措施的情况下回退到牛顿更新法。\n- 所有计算必须使用浮点运算。除抽象时间外，不涉及任何物理单位；结果以无量纲浮点数报告。\n\n测试套件：\n对于每个测试用例，从指定的初始参数和数据集开始，执行恰好一次 EM 迭代，并返回更新后的参数三元组 $[\\theta^{(1)}, \\lambda^{(1)}, \\kappa^{(1)}]$，四舍五入至 $6$ 位小数。\n\n- 测试用例 1（标准路径；与示例计算的 $A_i$ 匹配）：\n  - 初始参数：$\\theta^{(0)} = 0.5$, $\\lambda^{(0)} = 0.5$, $\\kappa^{(0)} = 1.0$。\n  - 一个聚类（$N = 1$），包含两个个体（$n_1 = 2$）：\n    - 时间 $t_{11} = 3.0$, $t_{12} = 4.0$。\n    - 事件指示器 $\\delta_{11} = 1$, $\\delta_{12} = 1$。\n  - 注意：使用给定的初始基线参数，$A_1 = \\sum_j \\lambda^{(0)} t_{1j}^{\\kappa^{(0)}} = 0.5 \\times (3.0 + 4.0) = 3.5$，且 $d_1 = 2$。\n\n- 测试用例 2（边界条件：零事件）：\n  - 初始参数：$\\theta^{(0)} = 0.5$, $\\lambda^{(0)} = 0.5$, $\\kappa^{(0)} = 1.0$。\n  - 一个聚类（$N = 1$），包含两个个体：\n    - 时间 $t_{11} = 2.0$, $t_{12} = 5.0$。\n    - 事件指示器 $\\delta_{11} = 0$, $\\delta_{12} = 0$。\n  - 注意：使用给定的初始基线参数，$A_1 = 0.5 \\times (2.0 + 5.0) = 3.5$，且 $d_1 = 0$。\n\n- 测试用例 3（多聚类；事件与删失混合）：\n  - 初始参数：$\\theta^{(0)} = 0.5$, $\\lambda^{(0)} = 0.8$, $\\kappa^{(0)} = 1.2$。\n  - 两个聚类（$N = 2$）：\n    - 聚类 1：$t_{11} = 1.0$, $t_{12} = 2.0$，其中 $\\delta_{11} = 1$, $\\delta_{12} = 0$。\n    - 聚类 2：$t_{21} = 0.5$, $t_{22} = 1.5$, $t_{23} = 3.0$，其中 $\\delta_{21} = 1$, $\\delta_{22} = 1$, $\\delta_{23} = 0$。\n\n要求的输出格式：\n- 你的程序必须生成单行输出，其中包含一个含三个列表的列表，每个内部列表对应一个测试用例，格式为 $[\\theta^{(1)}, \\lambda^{(1)}, \\kappa^{(1)}]$，四舍五入至 $6$ 位小数。\n- 例如，输出必须形如 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]$，除标准列表格式外，无其他文本或空白要求。\n\n你的任务：\n- 严格按照描述实现 EM 迭代，计算每个测试用例的更新后参数，并以上述单行格式打印结果。", "solution": "该问题要求在一个具有 Weibull 基线风险的共享 Gamma 脆弱模型中，为聚类右删失生存时间数据集实现单次期望最大化（EM）迭代以进行参数估计。在给出计算解法之前，有必要对问题陈述进行严格的验证。\n\n### 问题验证\n\n**第 1 步：提取的已知条件**\n- **模型**：共享脆弱生存模型。聚类 $i \\in \\{1,\\dots,N\\}$，聚类 $i$ 中的个体 $j$。\n- **数据**：时间 $t_{ij} \\in \\mathbb{R}_{+}$，事件指示器 $\\delta_{ij} \\in \\{0,1\\}$。\n- **条件风险**：$h(t \\mid Z_i) = Z_i h_0(t)$。\n- **基线风险**：Weibull 分布，$h_0(t) = \\kappa \\lambda t^{\\kappa-1}$，其中形状参数 $\\kappa > 0$，尺度参数 $\\lambda > 0$。\n- **累积基线风险**：$H_0(t) = \\lambda t^{\\kappa}$。\n- **脆弱项分布**：$Z_i \\sim \\mathrm{Gamma}(\\alpha, \\beta)$，其中形状参数 $\\alpha = 1/\\theta$，率参数 $\\beta = 1/\\theta$，方差 $\\theta > 0$。\n- **充分统计量**：对于聚类 $i$，$d_i = \\sum_j \\delta_{ij}$ 和 $A_i = \\lambda \\sum_j t_{ij}^{\\kappa}$。\n- **E步要求**：使用当前参数 $\\Theta^{(0)} = (\\theta^{(0)}, \\lambda^{(0)}, \\kappa^{(0)})$ 计算 $\\mathbb{E}[Z_i \\mid \\text{data}, \\Theta^{(0)}]$ 和 $\\mathbb{E}[\\log Z_i \\mid \\text{data}, \\Theta^{(0)}]$。\n- **M步要求**：通过求解一个关于 $\\alpha=1/\\theta$ 的一维求根问题来更新 $\\theta$。通过求解一个关于 $\\kappa$ 的一维求根问题并使用 $\\lambda$ 的闭式更新来更新 $(\\lambda, \\kappa)$。如果总事件数为零，则 $(\\lambda, \\kappa)$ 保持不变。\n- **数值求解器约束**：使用鲁棒的一维求根方法，建议的根区间为 $[10^{-6}, 10^{2}]$。\n- **测试用例**：提供了三个测试用例，包含指定的初始参数和数据。\n\n**第 2 步：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估：\n- **科学依据**：具有 Weibull 基线风险的 Gamma 脆弱模型是用于聚类数据的多元生存分析的基石。EM 算法的表述是标准的，源于似然理论和贝叶斯推断的基本原理。所有组成部分都具有科学合理性。\n- **适定性**：问题以数学上精确的方式给出。它提供了所有必要组成部分：模型、算法、初始条件和数据。任务是执行一个确定性的计算过程，这保证了唯一解的存在。\n- **客观性**：问题以正式、无歧义的语言陈述，不含主观元素。\n- **完整性与一致性**：问题是自洽的。提供的参数和数据是一致的，这一点通过对测试用例 1 中 `note` 的检查得到验证：$A_1 = \\lambda^{(0)} \\sum_j t_{1j}^{\\kappa^{(0)}} = 0.5 \\times (3.0^{1.0} + 4.0^{1.0}) = 3.5$。\n- **现实性与可行性**：数据值、参数和计算要求对于此类统计问题是现实的。\n\n**第 3 步：结论与行动**\n此问题是**有效**的。它在计算统计学中是一个定义明确的标准问题。我现在将着手提供详细的解法。\n\n### EM 迭代的推导\n\nEM 算法是一种迭代方法，用于在统计模型中寻找参数的最大似然估计，其中模型依赖于未观测到的潜变量。在此背景下，脆弱项 $Z_i$ 是潜变量。一次迭代包括一个期望（E）步和一个最大化（M）步。\n\n设当前参数估计为 $\\Theta^{(k)} = (\\theta^{(k)}, \\lambda^{(k)}, \\kappa^{(k)})$。\n\n#### E步：计算条件期望\nE步涉及计算完全数据对数似然的期望，该期望是基于观测数据和当前参数估计 $\\Theta^{(k)}$ 的条件期望。这需要潜变量 $Z_i$ 的后验分布。\n\n在给定脆弱项 $Z_i$ 的条件下，聚类 $i$ 中观测数据 $(t_{ij}, \\delta_{ij})_{j}$ 的似然函数为\n$$ L_i(\\text{data}_i \\mid Z_i; \\lambda, \\kappa) = \\prod_j [h(t_{ij} | Z_i)]^{\\delta_{ij}} S(t_{ij} | Z_i) = \\prod_j [Z_i h_0(t_{ij})]^{\\delta_{ij}} \\exp[-Z_i H_0(t_{ij})] $$\n$$ L_i(\\text{data}_i \\mid Z_i; \\lambda, \\kappa) = \\left( \\prod_j [h_0(t_{ij})]^{\\delta_{ij}} \\right) Z_i^{\\sum_j \\delta_{ij}} \\exp\\left[-Z_i \\sum_j H_0(t_{ij})\\right] $$\n使用充分统计量 $d_i = \\sum_j \\delta_{ij}$ 和 $A_i = \\lambda^{(k)} \\sum_j t_{ij}^{\\kappa^{(k)}}$，似然函数正比于 $Z_i^{d_i} e^{-Z_i A_i}$。\n\n$Z_i$ 的先验分布为 $\\mathrm{Gamma}(\\alpha, \\beta)$，其中 $\\alpha = \\beta = 1/\\theta^{(k)}$。其概率密度函数为 $p(Z_i) \\propto Z_i^{\\alpha-1} e^{-\\beta Z_i}$。\n\n根据贝叶斯定理，$Z_i$ 的后验分布为\n$$ p(Z_i \\mid \\text{data}_i, \\Theta^{(k)}) \\propto L_i(\\text{data}_i \\mid Z_i) p(Z_i) \\propto (Z_i^{d_i} e^{-Z_i A_i}) (Z_i^{\\alpha-1} e^{-\\beta Z_i}) = Z_i^{d_i+\\alpha-1} e^{-(A_i+\\beta)Z_i} $$\n这是一个 Gamma 分布的核。因此，后验分布为\n$$ Z_i \\mid \\text{data}_i, \\Theta^{(k)} \\sim \\mathrm{Gamma}(d_i + \\alpha, A_i + \\beta) = \\mathrm{Gamma}\\left(d_i + \\frac{1}{\\theta^{(k)}}, A_i + \\frac{1}{\\theta^{(k)}}\\right) $$\n所需的条件期望是该后验 Gamma 分布的性质。对于 $X \\sim \\mathrm{Gamma}(a, b)$，我们有 $\\mathbb{E}[X] = a/b$ 和 $\\mathbb{E}[\\log X] = \\psi(a) - \\log(b)$，其中 $\\psi$ 是双伽玛函数。\n\n因此，对于每个聚类 $i$：\n$$ E_{Z_i} := \\mathbb{E}[Z_i \\mid \\text{data}_i, \\Theta^{(k)}] = \\frac{d_i + 1/\\theta^{(k)}}{A_i + 1/\\theta^{(k)}} $$\n$$ E_{\\log Z_i} := \\mathbb{E}[\\log Z_i \\mid \\text{data}_i, \\Theta^{(k)}] = \\psi\\left(d_i + \\frac{1}{\\theta^{(k)}}\\right) - \\log\\left(A_i + \\frac{1}{\\theta^{(k)}}\\right) $$\n这些值是为所有聚类 $i=1, \\dots, N$ 计算的。\n\n#### M步：最大化期望对数似然\nM步相对于参数 $\\Theta = (\\theta, \\lambda, \\kappa)$ 来最大化期望完全数据对数似然 $Q(\\Theta \\mid \\Theta^{(k)})$。函数 $Q$ 可以分解为依赖于 $\\theta$ 的部分和依赖于 $(\\lambda, \\kappa)$ 的部分。\n\n**1. 脆弱项方差 $\\theta$ 的更新**\n$Q$ 中依赖于 $\\theta$（或 $\\alpha = 1/\\theta$）的部分是：\n$$ Q_{\\theta}(\\alpha) = \\sum_{i=1}^N \\mathbb{E}[\\log p(Z_i; \\alpha)] = \\sum_{i=1}^N \\mathbb{E}[\\alpha \\log \\alpha - \\log \\Gamma(\\alpha) + (\\alpha-1)\\log Z_i - \\alpha Z_i] $$\n$$ Q_{\\theta}(\\alpha) = N(\\alpha \\log \\alpha - \\log \\Gamma(\\alpha)) + (\\alpha-1)\\sum_{i=1}^N E_{\\log Z_i} - \\alpha \\sum_{i=1}^N E_{Z_i} $$\n为最大化 $Q_{\\theta}(\\alpha)$，我们将其关于 $\\alpha$ 的导数设为零：\n$$ \\frac{\\partial Q_{\\theta}}{\\partial \\alpha} = N(\\log \\alpha + 1 - \\psi(\\alpha)) + \\sum_{i=1}^N E_{\\log Z_i} - \\sum_{i=1}^N E_{Z_i} = 0 $$\n$$ N(\\log \\alpha - \\psi(\\alpha)) + N + \\sum_{i=1}^N E_{\\log Z_i} - \\sum_{i=1}^N E_{Z_i} = 0 $$\n这个关于 $\\alpha$ 的非线性方程必须通过数值方法求解。令 $K = N + \\sum_i E_{\\log Z_i} - \\sum_i E_{Z_i}$。我们求解 $N(\\log \\alpha - \\psi(\\alpha)) + K = 0$。如果 $K/N \\ge 0$，则左侧恒为正，意味着最大值在 $\\alpha \\to \\infty$ 时出现，即 $\\theta \\to 0$。在这种情况下，我们将 $\\alpha$ 的值限制在一个较大的数值上。否则，存在一个唯一的根 $\\alpha^{(k+1)}$，可以使用像 Brent-Dekker 方法这样的数值求解器找到。更新后的脆弱项方差为 $\\theta^{(k+1)} = 1/\\alpha^{(k+1)}$。\n\n**2. 基线风险参数 $(\\lambda, \\kappa)$ 的更新**\n$Q$ 中依赖于 $(\\lambda, \\kappa)$ 的部分是：\n$$ Q_{\\lambda, \\kappa}(\\lambda, \\kappa) = \\sum_{i=1}^N \\mathbb{E} \\left[ \\sum_j \\delta_{ij} \\log(Z_i h_0(t_{ij})) - \\sum_j Z_i H_0(t_{ij}) \\right] $$\n代入 $h_0(t) = \\kappa \\lambda t^{\\kappa-1}$ 和 $H_0(t) = \\lambda t^\\kappa$，并对 $Z_i$ 取期望：\n$$ Q_{\\lambda, \\kappa} = \\sum_{i,j} \\delta_{ij}(\\log(\\kappa\\lambda) + (\\kappa-1)\\log t_{ij}) - \\lambda \\sum_{i,j} E_{Z_i} t_{ij}^{\\kappa} + \\text{const} $$\n令 $D = \\sum_{i,j} \\delta_{ij}$ 为总事件数。\n$$ Q_{\\lambda, \\kappa} = D \\log\\lambda + D \\log\\kappa + (\\kappa-1)\\sum_{i,j} \\delta_{ij}\\log t_{ij} - \\lambda \\sum_{i,j} E_{Z_i} t_{ij}^{\\kappa} $$\n如果 $D=0$，该函数在 $\\lambda \\to 0$ 时最大化，这没有意义。根据题目要求，如果 $D=0$，我们设置 $(\\lambda^{(k+1)}, \\kappa^{(k+1)}) = (\\lambda^{(k)}, \\kappa^{(k)})$。\n\n如果 $D > 0$，我们可以为 $\\kappa$ 找到一个剖面似然。对 $\\lambda$ 求导并令其为零，可以得到给定 $\\kappa$ 时的最优 $\\lambda$：\n$$ \\frac{\\partial Q_{\\lambda, \\kappa}}{\\partial \\lambda} = \\frac{D}{\\lambda} - \\sum_{i,j} E_{Z_i} t_{ij}^\\kappa = 0 \\implies \\lambda(\\kappa) = \\frac{D}{\\sum_{i,j} E_{Z_i} t_{ij}^{\\kappa}} $$\n将此结果代回 $Q_{\\lambda, \\kappa}$，可以得到一个关于 $\\kappa$ 的剖面目标函数。将其关于 $\\kappa$ 的导数设为零，得到以下关于 $\\kappa$ 的方程：\n$$ \\frac{D}{\\kappa} + \\sum_{i,j} \\delta_{ij} \\log t_{ij} - \\frac{D \\sum_{i,j} E_{Z_i} t_{ij}^\\kappa \\log t_{ij}}{\\sum_{i,j} E_{Z_i} t_{ij}^\\kappa} = 0 $$\n两边同除以 $D$，我们得到需要为 $\\kappa^{(k+1)}$ 进行数值求解的方程：\n$$ \\frac{1}{\\kappa} + \\frac{1}{D}\\sum_{i,j} \\delta_{ij} \\log t_{ij} - \\frac{\\sum_{i,j} E_{Z_i} t_{ij}^\\kappa \\log t_{ij}}{\\sum_{i,j} E_{Z_i} t_{ij}^\\kappa} = 0 $$\n这是一个一维求根问题。一旦找到 $\\kappa^{(k+1)}$，就可以从其剖面表达式计算出 $\\lambda$ 的更新值：\n$$ \\lambda^{(k+1)} = \\frac{D}{\\sum_{i,j} E_{Z_i} t_{ij}^{\\kappa^{(k+1)}}} $$\n\n### 算法摘要\n对于每个具有初始参数 $(\\theta^{(0)}, \\lambda^{(0)}, \\kappa^{(0)})$ 和数据 $\\{(t_{ij}, \\delta_{ij})\\}$ 的测试用例：\n1.  **E步**：\n    a. 对于每个聚类 $i=1,\\dots,N$，计算事件数 $d_i = \\sum_j \\delta_{ij}$ 和累积基线风险总和 $A_i = \\lambda^{(0)} \\sum_j t_{ij}^{\\kappa^{(0)}}$。\n    b. 使用上述推导的公式和当前迭代的数值，计算后验期望 $E_{Z_i}$ 和 $E_{\\log Z_i}$。\n2.  **M步**：\n    a. **更新 $\\theta$**：使用 `scipy.optimize.brentq` 求解方程 $N(\\log \\alpha - \\psi(\\alpha)) + N + \\sum_i E_{\\log Z_i} - \\sum_i E_{Z_i} = 0$ 的根 $\\alpha^{(1)}$。如果在指定区间内未找到根（表示 $\\alpha \\to \\infty$），则将 $\\alpha$ 限制在一个较大的值。新的估计值为 $\\theta^{(1)}=1/\\alpha^{(1)}$。\n    b. **更新 $(\\lambda, \\kappa)$**：\n        i. 计算总事件数 $D = \\sum_i d_i$。\n        ii. 如果 $D=0$，设置 $(\\lambda^{(1)}, \\kappa^{(1)}) = (\\lambda^{(0)}, \\kappa^{(0)})$。\n        iii. 如果 $D>0$，使用 `scipy.optimize.brentq` 求解关于 $\\kappa$ 的非线性方程的根 $\\kappa^{(1)}$。\n        iv. 使用 $\\kappa=\\kappa^{(1)}$ 时的剖面似然估计量计算 $\\lambda^{(1)}$。\n3.  **输出**：报告更新后的参数 $[\\theta^{(1)}, \\lambda^{(1)}, \\kappa^{(1)}]$，四舍五入至 6 位小数。```python\nimport numpy as np\nfrom scipy.special import digamma\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to run the EM iteration for all test cases and print results.\n    \"\"\"\n\n    # Test cases defined as (initial_params, data) tuples.\n    # initial_params: (theta, lambda, kappa)\n    # data: list of clusters, where each cluster is a list of (time, delta) tuples.\n    test_cases = [\n        (\n            (0.5, 0.5, 1.0),\n            [\n                [(3.0, 1), (4.0, 1)]\n            ]\n        ),\n        (\n            (0.5, 0.5, 1.0),\n            [\n                [(2.0, 0), (5.0, 0)]\n            ]\n        ),\n        (\n            (0.5, 0.8, 1.2),\n            [\n                [(1.0, 1), (2.0, 0)],\n                [(0.5, 1), (1.5, 1), (3.0, 0)]\n            ]\n        )\n    ]\n\n    results = []\n    for params, data in test_cases:\n        theta1, lambda1, kappa1 = run_one_em_iteration(params[0], params[1], params[2], data)\n        results.append([round(p, 6) for p in [theta1, lambda1, kappa1]])\n\n    # Format and print the final output as a single line.\n    # e.g., [[a1,b1,c1],[a2,b2,c2],[a3,b3,c3]]\n    result_str = \",\".join([f\"[{','.join(map(str, r))}]\" for r in results])\n    print(f\"[{result_str}]\")\n\ndef run_one_em_iteration(theta0, lambda0, kappa0, data):\n    \"\"\"\n    Performs a single EM iteration for the shared frailty model.\n    \"\"\"\n    \n    # --- E-Step ---\n    N = len(data)\n    d_i_list = []\n    A_i_list = []\n    EZ_i_list = []\n    ElogZ_i_list = []\n\n    theta0_inv = 1.0 / theta0\n\n    for cluster_data in data:\n        times = np.array([obs[0] for obs in cluster_data])\n        deltas = np.array([obs[1] for obs in cluster_data])\n        \n        d_i = np.sum(deltas)\n        A_i = lambda0 * np.sum(times**kappa0)\n        \n        d_i_list.append(d_i)\n        A_i_list.append(A_i)\n\n        posterior_alpha = d_i + theta0_inv\n        posterior_beta = A_i + theta0_inv\n\n        EZ_i = posterior_alpha / posterior_beta\n        ElogZ_i = digamma(posterior_alpha) - np.log(posterior_beta)\n\n        EZ_i_list.append(EZ_i)\n        ElogZ_i_list.append(ElogZ_i)\n\n    EZ_i = np.array(EZ_i_list)\n    ElogZ_i = np.array(ElogZ_i_list)\n\n    # --- M-Step ---\n\n    # 1. Update theta (via alpha = 1/theta)\n    \n    def g_alpha(alpha, sum_EZ, sum_ElogZ, n_clusters):\n        if alpha == 0: return np.inf\n        # Target function for root finding for alpha\n        # N(log(alpha) - digamma(alpha)) + N + sum(ElogZ) - sum(EZ) = 0\n        return n_clusters * (np.log(alpha) - digamma(alpha)) + n_clusters + sum_ElogZ - sum_EZ\n\n    sum_EZ = np.sum(EZ_i)\n    sum_ElogZ = np.sum(ElogZ_i)\n    \n    # Bracket for alpha corresponds to theta in [1e-6, 1e2]\n    alpha_min, alpha_max = 1e-2, 1e6 \n    \n    try:\n        # Check if a root exists in the interval\n        val_min = g_alpha(alpha_min, sum_EZ, sum_ElogZ, N)\n        val_max = g_alpha(alpha_max, sum_EZ, sum_ElogZ, N)\n        if val_min * val_max  0:\n            alpha1 = brentq(g_alpha, alpha_min, alpha_max, args=(sum_EZ, sum_ElogZ, N))\n        else:\n            # If function values at endpoints have the same sign, it implies\n            # the maximum is at alpha -> infinity (since the function is decreasing).\n            # This corresponds to theta -> 0. We cap alpha at the max of our range.\n            alpha1 = alpha_max\n        theta1 = 1.0 / alpha1\n    except ValueError:\n        # Failsafe: if brentq fails for other reasons, handle it.\n        # Here we assume the case where derivative is always positive, so alpha -> inf\n        alpha1 = alpha_max\n        theta1 = 1.0 / alpha1\n\n\n    # 2. Update lambda and kappa\n    all_times = np.array([obs[0] for cluster in data for obs in cluster])\n    all_deltas = np.array([obs[1] for cluster in data for obs in cluster])\n    \n    total_events = np.sum(all_deltas)\n    \n    if total_events == 0:\n        return theta1, lambda0, kappa0\n\n    EZ_flat = np.array([EZ for EZ, cluster in zip(EZ_i, data) for _ in cluster])\n    \n    avg_log_t_event = np.sum(all_deltas * np.log(all_times)) / total_events\n\n    def h_kappa(kappa, ez_flat, t_flat, avg_log_t):\n        if kappa == 0: return np.inf\n        # Scaled target function for root finding for kappa\n        # 1/kappa + (1/D)*sum(delta*log(t)) - sum(EZ*t^k*log(t))/sum(EZ*t^k) = 0\n        t_k = t_flat**kappa\n        \n        numerator = np.sum(ez_flat * t_k * np.log(t_flat))\n        denominator = np.sum(ez_flat * t_k)\n        \n        if denominator == 0: return np.inf\n        \n        return 1.0/kappa + avg_log_t - numerator / denominator\n\n    kappa_min, kappa_max = 1e-6, 1e2\n    \n    try:\n        kappa1 = brentq(h_kappa, kappa_min, kappa_max, args=(EZ_flat, all_times, avg_log_t_event))\n    except ValueError:\n        # Fallback if bracketing fails, though test cases should be well-behaved\n        kappa1 = kappa0 \n\n    lambda1_denominator = np.sum(EZ_flat * all_times**kappa1)\n    lambda1 = total_events / lambda1_denominator\n    \n    return theta1, lambda1, kappa1\n\nif __name__ == '__main__':\n    solve()\n\n```", "answer": "[[0.380165,0.380952,1.041531],[0.333333,0.5,1.0],[0.552486,0.785368,1.157835]]", "id": "4963310"}, {"introduction": "在应用脆弱模型时，一个基本问题是数据中观测到的聚类效应是否具有统计显著性，这可以转化为检验脆弱性方差为零的原假设（$H_0: \\theta = 0$）。然而，由于方差 $ \\theta $ 不能为负，其参数空间为 $ [0, \\infty) $，导致原假设的值位于参数空间的边界上。这个练习探讨了检验脆弱效应时的理论难点，通过它，你将理解为何似然比检验统计量的零分布不再是标准的 $ \\chi^2 $ 分布，而是一个混合分布（具体为 $ \\frac{1}{2}\\chi^2_0 + \\frac{1}{2}\\chi^2_1 $）。[@problem_id:4963252]", "problem": "考虑一项聚类生存时间研究，其中聚类由 $i \\in \\{1,\\dots,m\\}$ 索引，聚类 $i$ 内的个体由 $j \\in \\{1,\\dots,n_i\\}$ 索引。假设在给定协变量 $x_{ij}$ 和一个未观测到的共享脆弱性 $u_i$ 的条件下，聚类 $i$ 中个体 $j$ 在时间 $t$ 的条件风险率为\n$$\nh_{ij}(t \\mid x_{ij}, u_i) \\;=\\; u_i \\, h_0(t)\\, \\exp\\!\\big(x_{ij}^\\top \\beta\\big),\n$$\n其中 $h_0(t)$ 是基准风险率，$\\beta$ 是一个回归参数向量。假设共享脆弱性服从均值为 $1$、方差为 $\\theta$ 的伽马分布，即 $u_i \\sim \\text{Gamma}(k, s)$，其形状参数 $k = 1/\\theta$，尺度参数 $s = \\theta$，因此 $\\mathbb{E}(u_i) = 1$ 且 $\\mathrm{Var}(u_i) = \\theta$。考虑通过以下方式检验由脆弱性引起的异质性的存在\n$$\nH_0: \\theta = 0 \\quad \\text{versus} \\quad H_1: \\theta  0.\n$$\n您的任务是从第一性原理出发，论述在 $H_0$ 下的参数空间、模型退化以及大样本检验行为。\n\n下列哪些陈述是正确的？\n\nA. 在 $H_0$ 下，参数 $\\theta$ 位于其参数空间的边界上，因为 $\\theta$ 是一个方差，必须满足 $\\theta \\ge 0$；在这种情况下，用于检验 $H_0$ 与 $H_1$ 的似然比检验（LRT）统计量的极限零分布是一个混合分布，以 $\\tfrac{1}{2}$ 的概率取值为 $0$，以 $\\tfrac{1}{2}$ 的概率服从 $\\chi^2_1$ 分布。\n\nB. 在 $H_0$ 下，虽然 $\\theta = 0$，但脆弱性仍然是随机的，只是方差任意小，因此通常用于LRT的 $\\chi^2_1$ 零参考分布完全成立。\n\nC. 原假设 $H_0:\\theta=0$ 等价于 $u_i \\equiv 1$ 几乎必然成立，即在 $1$ 处的退化伽马分布，这会从模型中移除随机效应；这产生了一个不规则的检验问题，其中讨厌参数仅在 $H_1$ 下存在。\n\nD. 一个基于以 $\\theta=0$ 为中心的渐近正态近似、用于检验 $\\theta$ 的双边沃尔德检验是有效的，且具有名义水平，因为 $\\theta=0$ 是参数空间的一个内点。\n\nE. 因为 $\\theta \\ge 0$，一个用于检验 $H_0:\\theta=0$ 与 $H_1:\\theta0$ 的单边得分检验，当一个适当标准化的得分取较大的正值时拒绝原假设；其极限零分布与在这种边界情况下LRT出现的 $\\tfrac{1}{2}\\chi^2_0 + \\tfrac{1}{2}\\chi^2_1$ 混合分布一致。\n\n选择所有适用的选项。", "solution": "我们从生存分析的核心定义和伽马分布的基本性质开始。风险函数 $h_{ij}(t \\mid x_{ij}, u_i)$ 指定了在给定协变量和脆弱性下的瞬时事件发生率。根据共享脆弱性模型的构造，脆弱性 $u_i$ 以乘法方式缩放聚类 $i$ 中所有个体的风险率。形状参数为 $k=1/\\theta$、尺度参数为 $s=\\theta$ 的伽马分布，其均值为 $k s = 1$，方差为 $k s^2 = \\theta$，因此 $\\theta$ 是 $u_i$ 的方差，必须满足 $\\theta \\ge 0$。\n\n在 $H_0:\\theta=0$ 下，脆弱性的方差收缩至 $0$。对于一个由均值 $1$ 和方差 $\\theta$ 参数化的伽马分布族，当 $\\theta \\to 0$ 时，其极限分布是在 $1$ 处的退化分布。因此，在 $H_0$ 下，$u_i \\equiv 1$ 几乎必然成立，模型简化为一个不含随机效应的标准比例风险模型。这立即表明 $H_0$ 将 $\\theta$ 置于其参数空间 $[0,\\infty)$ 的边界上。\n\n接下来，考虑大样本检验行为。在规则的内点问题中，对数似然函数在真实参数周围允许进行二次展开，并通过无约束最大化，得出众所周知的 Wilks 结果，即似然比检验（LRT）统计量具有渐近 $\\chi^2$ 分布，其自由度等于被检验参数的数量。然而，当真实参数位于参数空间的边界上时，最大化过程受到约束，渐近性质也随之改变。关于边界上参数的渐近理论中一个公认的结果（例如，Self and Liang 关于非标准条件的理论）表明，对于在 $0$ 处检验单个非负参数与单边备择假设，LRT统计量在分布上收敛于随机变量\n$$\n\\bigl(\\max\\{0, Z\\}\\bigr)^2,\n$$\n其中 $Z \\sim N(0,1)$。这个分布是一个混合分布，以 $\\tfrac{1}{2}$ 的概率在 $0$ 处（即一个 $\\chi^2_0$ 分量），并以 $\\tfrac{1}{2}$ 的概率服从一个 $\\chi^2_1$ 分布。另一种等价的理解方式是通过对数似然函数 $\\,\\ell(\\theta)\\,$ 在 $\\theta=0$ 处的局部二次展开。令 $U(0)$ 表示在 $\\theta=0$ 处的得分，$I(0)$ 表示费雪信息。在 $H_0$ 下，$U(0) \\overset{d}{\\to} N(0, I(0))$。约束极大似然估计量满足以下渐近特征\n$$\n\\hat{\\theta} \\approx \\max\\!\\left\\{0, \\frac{U(0)}{I(0)}\\right\\},\n$$\n从而得到近似的LRT统计量\n$$\n2\\bigl\\{\\ell(\\hat{\\theta}) - \\ell(0)\\bigr\\} \\;\\approx\\; I(0)\\,\\hat{\\theta}^2 \\;=\\; \\left(\\max\\!\\left\\{0, \\frac{U(0)}{\\sqrt{I(0)}}\\right\\}\\right)^2 \\;\\Rightarrow\\; \\bigl(\\max\\{0,Z\\}\\bigr)^2,\n$$\n这便得到了 $\\tfrac{1}{2}\\chi^2_0 + \\tfrac{1}{2}\\chi^2_1$ 混合分布。\n\n同样的边界行为也影响得分检验和沃尔德检验。双边沃尔德检验假定参数是一个内点，并且在 $\\theta=0$ 周围有一个对称的正态近似，但这在这里不成立，因为 $\\theta$ 不能为负，且估计量在 $0$ 处受到约束。相比之下，一个当大的正标准化得分出现时拒绝原假设的单边得分检验，与边界约束的几何结构相符，并且在 $H_0$ 下，其极限混合分布与LRT相同：因为 $U(0)/\\sqrt{I(0)} \\Rightarrow N(0,1)$，自然的单边统计量是 $\\bigl(\\max\\{0, U(0)/\\sqrt{I(0)}\\}\\bigr)^2$，它服从 $\\tfrac{1}{2}\\chi^2_0 + \\tfrac{1}{2}\\chi^2_1$ 分布。\n\n我们现在评估每个选项：\n\nA. 正确。因为 $\\theta$ 是一个方差，其参数空间是 $[0,\\infty)$。在 $H_0:\\theta=0$ 下，该参数位于边界上。在单参数边界情况下，LRT统计量的渐近零分布是 $\\tfrac{1}{2}\\chi^2_0 + \\tfrac{1}{2}\\chi^2_1$ 混合分布。\n\nB. 错误。在 $H_0$ 下，脆弱性并非保持为具有小方差的随机变量；它退化到 $1$。此外，即使非正式地考虑一个很小但为正的方差，在 $H_0$ 下，确切的 $\\chi^2_1$ 参考分布也是无效的。LRT的正确渐近零分布是边界混合分布，而不是 $\\chi^2_1$。\n\nC. 正确。在均值固定为 $1$ 的情况下，$\\theta=0$ 意味着伽马分布退化到 $1$，即 $u_i \\equiv 1$ 几乎必然成立，这消除了随机效应，并产生了一个不规则的检验情况，因为作为随机效应的潜在变量 $u_i$ 仅在 $H_1$ 下存在。\n\nD. 错误。双边沃尔德检验假定参数是一个内点，并且估计量在 $\\theta=0$ 周围服从正态分布，但这一假设不成立，因为 $\\theta \\ge 0$，且在 $H_0$ 下估计量在 $0$ 处受到约束。因此，无法保证名义水平，该程序是不合适的。\n\nE. 正确。当标准化得分为大的正值时拒绝原假设的单边得分检验，与边界约束相匹配，并且在 $H_0$ 下，其极限零分布与此情况下LRT的 $\\tfrac{1}{2}\\chi^2_0 + \\tfrac{1}{2}\\chi^2_1$ 混合分布相同。\n\n因此，正确的选项是 A、C 和 E。", "answer": "$$\\boxed{ACE}$$", "id": "4963252"}]}