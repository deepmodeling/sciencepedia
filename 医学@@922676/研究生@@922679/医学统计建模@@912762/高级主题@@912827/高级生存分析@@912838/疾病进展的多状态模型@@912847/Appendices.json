{"hands_on_practices": [{"introduction": "理论学习的最终目的是应用于实践。在多状态模型中，最基础也是最核心的技能之一，便是直接从观察数据中估计状态转移概率。本练习将指导您从零开始实现 Aalen-Johansen (AJE) 估计器，这是一种强大的非参数方法，用于处理存在删失和竞争风险的事件历史数据。\n\n通过这个实践，您将深入理解计数过程、风险集和乘积积分等核心概念，为分析真实世界的纵向数据打下坚实的基础。[@problem_id:4975726]", "problem": "考虑一个用于疾病进展的连续时间多状态模型，该模型包含三个状态：$0$ (健康)，$1$ (患病) 和 $2$ (死亡)。状态 $2$ 是吸收态。所有个体在时间 $0$ 时均从状态 $0$ 开始。假设我们有面板数据，其中包含精确的转移时间，数据可能存在右删失。此连续时间多状态过程被假定为非爆炸性的，并由允许的转移（$0 \\to 1$、$0 \\to 2$ 和 $1 \\to 2$）之间的转移强度决定。\n\n从基础的计数过程框架出发，为每个允许的转移 $r \\to s$ 定义计数过程 $N_{rs}(t)$，它记录了截至时间 $t$ 观察到的从状态 $r$ 到状态 $s$ 的转移次数；以及风险过程 $Y_r(t)$，它记录了在时间 $t$ 之前瞬间处于状态 $r$ 且仍在观察中的个体数量。累积转移强度矩阵的非参数估计量是通过事件发生时刻的增量来定义的，该增量为观察到的转移次数与相应源状态中风险人群数量之比。Aalen–Johansen 估计量 (AJE) 定义为单位矩阵加上估计的强度增量的乘积积分，从而得出从时间 $0$ 到时间 $t$ 的转移概率矩阵的估计值。\n\n你的任务是实现一个程序，仅使用这些核心定义，通过 Aalen–Johansen 估计量计算从状态 $0$ 开始到时间 $t$ 的累积死亡发生率。该值是估计的从时间 $0$ 到时间 $t$ 的转移概率矩阵的 $(0,2)$ 项。时间以天为单位，你必须将最终结果表示为十进制数（而不是百分比）。你可以假设在任何给定时间，一个个体最多只能经历一次转移，并且转移时间被精确记录（不同个体之间可能存在时间点重合）。删失时间是精确的，意味着一个个体在删失时间之后便不再被观察；但在删失时间的前一刻，他们仍被视为在观察中。\n\n每个案例中使用的数据集的表示规则：\n- 每个个体由一个转移列表、每个转移表示为 $(\\text{time}, \\text{new\\_state})$（其中 $\\text{time} \\ge 0$ 且 $\\text{new\\_state} \\in \\{0,1,2\\}$）和一个可选的删失时间 $c \\ge 0$ 或 $\\text{None}$ 来表示。所有个体在时间 $0$ 时从状态 $0$ 开始。转移列表在时间上是严格递增的，并且在任何给定时间每个个体最多包含一次转移。如果给定了删失时间 $c$，则该个体在时间 $c$（含）之前都在观察中，在 $c$ 之后则严格不再被观察。\n\n测试套件：\n- 案例 1 (一般混合转移和删失):\n  - 个体:\n    - 个体 $1$: 转移 $\\{(1.5, 1), (4.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 $2$: 转移 $\\{(3.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 $3$: 转移 $\\{(2.0, 1)\\}$，删失 $5.0$。\n    - 个体 $4$: 转移 $\\{\\}$，删失 $6.0$。\n    - 个体 $5$: 转移 $\\{(5.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 $6$: 转移 $\\{(1.0, 1), (3.5, 2)\\}$，删失 $\\text{None}$。\n  - 评估时间: $t_{\\text{end}} = 5.0$ 天。\n- 案例 2 (边界情况：评估时间前无死亡):\n  - 个体:\n    - 个体 $1$: 转移 $\\{(1.0, 1)\\}$，删失 $4.0$。\n    - 个体 $2$: 转移 $\\{(3.0, 1)\\}$，删失 $3.5$。\n    - 个体 $3$: 转移 $\\{\\}$，删失 $2.0$。\n    - 个体 $4$: 转移 $\\{\\}$，删失 $4.0$。\n  - 评估时间: $t_{\\text{end}} = 4.0$ 天。\n- 案例 3 (边缘情况：同时发生直接死亡):\n  - 个体:\n    - 个体 $1$: 转移 $\\{(2.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 $2$: 转移 $\\{(2.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 $3$: 转移 $\\{(2.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 $4$: 转移 $\\{(2.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 $5$: 转移 $\\{\\}$，删失 $3.0$。\n    - 个体 $6$: 转移 $\\{\\}$，删失 $1.0$。\n  - 评估时间: $t_{\\text{end}} = 2.0$ 天。\n- 案例 4 (时间点重合与混合路径):\n  - 个体:\n    - 个体 $1$: 转移 $\\{(1.0, 1), (2.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 $2$: 转移 $\\{(1.0, 1)\\}$，删失 $1.5$。\n    - 个体 $3$: 转移 $\\{(1.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 $4$: 转移 $\\{\\}$，删失 $3.0$。\n    - 个体 $5$: 转移 $\\{\\}$，删失 $\\text{None}$。\n    - 个体 $6$: 转移 $\\{(1.0, 1)\\}$，删失 $\\text{None}$。\n  - 评估时间: $t_{\\text{end}} = 2.0$ 天。\n\n算法要求：\n- 从所有个体的转移时间中，构建截至 $t_{\\text{end}}$ 的不同事件时间的集合。\n- 对于每个事件时间 $t$：\n  - 计算 $r \\in \\{0,1,2\\}$ 的 $Y_r(t)$，即在时间 $t$ 之前瞬间处于状态 $r$ 且仍在观察中的个体数量。\n  - 对于每个允许的配对 $(r,s)$（其中 $r \\ne s$），计算在时间 $t$ 发生的转移次数 $dN_{rs}(t)$。\n  - 构建 $3 \\times 3$ 的增量矩阵 $d\\hat{\\mathbf A}(t)$，其非对角线项为 $d\\hat A_{rs}(t) = dN_{rs}(t) / Y_r(t)$（若 $Y_r(t) > 0$）否则为 $0$，对角线项为 $d\\hat A_{rr}(t) = - \\sum_{s \\ne r} d\\hat A_{rs}(t)$。\n  - 通过乘积积分 $\\hat{\\mathbf P}(0,t) = \\hat{\\mathbf P}(0,t^{-}) \\cdot \\left(\\mathbf I + d\\hat{\\mathbf A}(t)\\right)$ 更新估计的转移概率矩阵，初始值为 $\\hat{\\mathbf P}(0,0) = \\mathbf I$。\n- 处理完截至 $t_{\\text{end}}$ 的所有事件时间后，提取 $\\hat{\\mathbf P}(0,t_{\\text{end}})$ 的 $(0,2)$ 项作为累积死亡发生率。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含四个案例的结果，格式为方括号内的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是对应案例在特定 $t_{\\text{end}}$（以天为单位）下的累积死亡发生率的十进制估计值。\n\n所有时间都必须以天为单位处理，所有输出都必须是十进制数（不是分数或百分比）。请确保科学的真实性，完全按照规定正确处理风险人群、时间点重合和右删失。", "solution": "该问题陈述经评估是有效的。它在科学上基于多状态模型和事件史分析的既定统计理论。问题设定良好，提供了明确的目标、所有必要的数据，以及一套基于 Aalen–Johansen 估计量 (AJE) 的完整定义和算法要求。其表述客观、数学上严谨，且没有歧义或矛盾。\n\n任务是为一组从“健康”状态开始的个体，计算到特定时间 $t_{\\text{end}}$ 的累积死亡发生率。这对应于在一个代表“健康”、“患病”和“死亡”的三状态模型 $\\{0, 1, 2\\}$ 中，估计转移概率 $P_{02}(0, t_{\\text{end}})$。Aalen-Johansen 估计量提供了整个转移概率矩阵 $\\mathbf{P}(s, t)$ 的非参数估计，该矩阵包含概率 $P_{ij}(s, t) = \\mathbb{P}(\\text{在时间 } t \\text{ 状态为 } j \\mid \\text{在时间 } s \\text{ 状态为 } i)$。\n\n该估计量被构建为累积转移强度矩阵 $\\mathbf{\\Lambda}(t)$ 的乘积积分。对于具有离散事件时间的面板数据，此乘积积分变为在观察到的事件时间上的有限乘积。从时间 $0$ 到时间 $t$ 的估计转移概率矩阵，记作 $\\hat{\\mathbf{P}}(0, t)$，是迭代计算的。从 $\\hat{\\mathbf{P}}(0, 0) = \\mathbf{I}$（单位矩阵）开始，对于每个不同的事件时间 $\\tau_j > 0$，矩阵更新如下：\n$$\n\\hat{\\mathbf{P}}(0, \\tau_j) = \\hat{\\mathbf{P}}(0, \\tau_{j-1}) \\cdot (\\mathbf{I} + d\\hat{\\mathbf{A}}(\\tau_j))\n$$\n其中 $\\tau_0 = 0$ 且 $\\hat{\\mathbf{P}}(0, \\tau_0) = \\mathbf{I}$。矩阵 $d\\hat{\\mathbf{A}}(\\tau_j)$ 表示在时间 $\\tau_j$ 累积转移强度矩阵的估计变化量。\n\n$3 \\times 3$ 矩阵 $d\\hat{\\mathbf{A}}(\\tau_j)$ 的项是基于计数过程定义的。对于从状态 $r$ 到状态 $s$（$r \\neq s$）的每种可能转移，非对角线项为：\n$$\nd\\hat{A}_{rs}(\\tau_j) = \\frac{dN_{rs}(\\tau_j)}{Y_r(\\tau_j)}\n$$\n此处，$dN_{rs}(\\tau_j)$ 是在时间 $\\tau_j$ 观察到从状态 $r$ 转移到状态 $s$ 的个体数量。$Y_r(\\tau_j)$ 是在时间 $\\tau_j$ 之前瞬间处于状态 $r$ 且在观察中（即未被删失）的个体数量。如果风险人群 $Y_r(\\tau_j)$ 为零，则 $d\\hat{A}_{rs}(\\tau_j)$ 定义为 $0$。\n\n对角线项的定义是为了确保矩阵 $(\\mathbf{I} + d\\hat{\\mathbf{A}}(\\tau_j))$ 的列和为 $1$，这保证了 $\\hat{\\mathbf{P}}$ 保持为一个随机矩阵（行和为 $1$）。这是通过设置以下项实现的：\n$$\nd\\hat{A}_{rr}(\\tau_j) = - \\sum_{s \\neq r} d\\hat{A}_{rs}(\\tau_j)\n$$\n对于吸收态 $2$，所有源于它的转移强度都为零，因此 $d\\hat{\\mathbf{A}}(\\tau_j)$ 的第三行始终是零向量。\n\n解决该问题的算法如下：\n1.  **识别事件时间**：从所有个体提供的数据中，汇编所有小于或等于指定评估时间 $t_{\\text{end}}$ 的唯一转移时间的集合。按升序对这些时间进行排序：$\\tau_1  \\tau_2  \\dots  \\tau_K$。\n2.  **初始化**：将初始转移概率矩阵设置为 $3 \\times 3$ 的单位矩阵，$\\hat{\\mathbf{P}}(0, 0) = \\mathbf{I}$。\n3.  **遍历事件时间**：对于已排序列表中的每个事件时间 $\\tau_j$：\n    a. **确定风险集**：对于每个非吸收态 $r \\in \\{0, 1\\}$，确定风险计数 $Y_r(\\tau_j)$。这包括遍历所有个体，根据他们的转移历史确定其在 $\\tau_j$ 之前的状态，并检查他们的观察期（未因删失而终止）是否延伸到 $\\tau_j$。\n    b. **计数转移**：对于每种允许的转移类型（$0 \\to 1$、$0 \\to 2$、$1 \\to 2$），计算在时间 $\\tau_j$ 精确发生特定转移 $r \\to s$ 的个体数量 $dN_{rs}(\\tau_j)$。\n    c. **构建增量矩阵**：使用 $d\\hat{A}_{rs}(\\tau_j)$ 和 $d\\hat{A}_{rr}(\\tau_j)$ 的公式构建矩阵 $d\\hat{\\mathbf{A}}(\\tau_j)$。\n    d. **更新概率矩阵**：计算更新矩阵 $\\mathbf{M}_j = \\mathbf{I} + d\\hat{\\mathbf{A}}(\\tau_j)$。然后，通过矩阵乘法更新估计值：$\\hat{\\mathbf{P}}(0, \\tau_j) = \\hat{\\mathbf{P}}(0, \\tau_{j-1}) \\cdot \\mathbf{M}_j$。\n4.  **提取最终结果**：在遍历完截至 $\\tau_K$ 的所有事件时间后，得到的矩阵 $\\hat{\\mathbf{P}}(0, \\tau_K)$ 就是估计值 $\\hat{\\mathbf{P}}(0, t_{\\text{end}})$。累积死亡发生率是该矩阵的 $(0, 2)$ 项（使用从 0 开始的索引），即 $\\hat{P}_{02}(0, t_{\\text{end}})$。\n\n此过程正确处理了时间点重合的事件（通过在一步中计算所有同时发生的转移）和右删失（通过在个体删失时间之后将其从风险集中排除）。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n\n    # Representation of test cases:\n    # Each case is a tuple: (individuals, t_end)\n    # Each individual is a tuple: (transitions, censoring_time)\n    # transitions is a list of tuples: (time, new_state)\n    # censoring_time is a float or None.\n    test_cases = [\n        # Case 1\n        (\n            [\n                ([(1.5, 1), (4.0, 2)], None),\n                ([(3.0, 2)], None),\n                ([(2.0, 1)], 5.0),\n                ([], 6.0),\n                ([(5.0, 2)], None),\n                ([(1.0, 1), (3.5, 2)], None),\n            ],\n            5.0\n        ),\n        # Case 2\n        (\n            [\n                ([(1.0, 1)], 4.0),\n                ([(3.0, 1)], 3.5),\n                ([], 2.0),\n                ([], 4.0),\n            ],\n            4.0\n        ),\n        # Case 3\n        (\n            [\n                ([(2.0, 2)], None),\n                ([(2.0, 2)], None),\n                ([(2.0, 2)], None),\n                ([(2.0, 2)], None),\n                ([], 3.0),\n                ([], 1.0),\n            ],\n            2.0\n        ),\n        # Case 4\n        (\n            [\n                ([(1.0, 1), (2.0, 2)], None),\n                ([(1.0, 1)], 1.5),\n                ([(1.0, 2)], None),\n                ([], 3.0),\n                ([], None),\n                ([(1.0, 1)], None),\n            ],\n            2.0\n        ),\n    ]\n\n    results = []\n    for individuals, t_end in test_cases:\n        result = compute_cumulative_incidence(individuals, t_end)\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.12f}'.rstrip('0').rstrip('.') if '.' in f'{r:.12f}' else str(r) for r in results)}]\")\n\ndef compute_cumulative_incidence(individuals_raw, t_end):\n    \"\"\"\n    Computes the cumulative incidence to death by t_end using the Aalen-Johansen estimator.\n\n    Args:\n        individuals_raw: A list of individuals, where each is a tuple of\n                         (list of transitions, censoring time).\n        t_end: The evaluation time.\n\n    Returns:\n        The estimated cumulative incidence to death (P_02) as a float.\n    \"\"\"\n    # Pre-process data for easier access\n    individuals = []\n    all_transition_times = set()\n    for transitions, censoring_time in individuals_raw:\n        # Convert list of transitions to a dictionary for faster lookups\n        trans_dict = {t: s for t, s in transitions}\n        # Use infinity for non-censored individuals\n        c_time = censoring_time if censoring_time is not None else float('inf')\n        individuals.append({'transitions': trans_dict, 'censoring_time': c_time})\n        for t in trans_dict.keys():\n            all_transition_times.add(t)\n\n    # Get unique, sorted event times up to t_end\n    event_times = sorted([t for t in all_transition_times if t = t_end])\n\n    # Initialize the transition probability matrix P(0, t)\n    p_hat = np.identity(3)\n\n    for t_event in event_times:\n        # At-risk counts Y_r(t) for r in {0, 1}\n        y = {0: 0, 1: 0}\n        # Transition counts dN_rs(t)\n        dn = {(0, 1): 0, (0, 2): 0, (1, 2): 0}\n\n        for p_idx, p_data in enumerate(individuals):\n            # An individual is under observation if the event time is not strictly after their censoring time.\n            if t_event  p_data['censoring_time']:\n                continue\n\n            # Determine the individual's state just prior to t_event\n            current_state = 0\n            # Get transition times before the current event time\n            trans_before = [t for t in p_data['transitions'] if t  t_event]\n            if trans_before:\n                last_trans_time = max(trans_before)\n                current_state = p_data['transitions'][last_trans_time]\n\n            # If in an absorbing state, they are no longer at risk for transitions\n            if current_state == 2:\n                continue\n\n            # Add to at-risk set\n            y[current_state] += 1\n            \n            # Check for a transition at t_event\n            if t_event in p_data['transitions']:\n                new_state = p_data['transitions'][t_event]\n                transition = (current_state, new_state)\n                if transition in dn:\n                    dn[transition] += 1\n\n        # Construct the increment matrix d_A_hat\n        d_a_hat = np.zeros((3, 3))\n        \n        if y[0]  0:\n            d_a_hat[0, 1] = dn[(0, 1)] / y[0]\n            d_a_hat[0, 2] = dn[(0, 2)] / y[0]\n        \n        if y[1]  0:\n            d_a_hat[1, 2] = dn[(1, 2)] / y[1]\n\n        # Set diagonal elements\n        d_a_hat[0, 0] = -(d_a_hat[0, 1] + d_a_hat[0, 2])\n        d_a_hat[1, 1] = -d_a_hat[1, 2]\n        # State 2 is absorbing, so d_a_hat[2,:] is all zeros.\n\n        # Update P_hat via product integral step\n        update_matrix = np.identity(3) + d_a_hat\n        p_hat = p_hat @ update_matrix\n\n    # The result is the (0, 2) entry of the final P_hat matrix\n    return p_hat[0, 2]\n\nsolve()\n```", "id": "4975726"}, {"introduction": "在估计出模型后，一个关键的应用是进行动态预测，即根据患者最新的健康信息更新其未来的疾病轨迹预测。现实世界中，患者的协变量（如生物标志物）是随时间变化的，一个有效的模型必须能整合这些时变信息。本练习将带您使用一个已知的时变协变量路径和基线风险，通过求解其前向动态方程来计算未来的状态概率。\n\n[@problem_id:4975749] 这个过程模拟了临床中提供个性化、实时预后的核心任务，让您掌握将复杂模型转化为实用预测工具的计算方法。", "problem": "考虑一个用于疾病进展的连续时间多状态模型，该模型包含三个状态：$1$（健康）、$2$（患病）和$3$（死亡）。假设这是一个时间非齐次连续时间马尔可夫链（CTMC），在时间 $t$、协变量值为 $X(t)$ 时，从状态 $i$ 到状态 $j$ 的转移强度由对数线性模型 $ \\lambda_{ij}(t) = \\lambda_{ij,0}(t) \\exp\\big(\\beta_{ij} X(t)\\big) $ 给出（其中 $i \\neq j$），且 $ \\lambda_{ii}(t) \\equiv 0 $。协变量 $X(t)$ 是一个标量、分段常数的时间函数。基线风险 $ \\lambda_{ij,0}(t) $ 是分段常数的时间函数，具体规定如下。生成元矩阵 $Q(t)$ 的非对角线元素为 $ q_{ij}(t) = \\lambda_{ij}(t) $，对角线元素为 $ q_{ii}(t) = -\\sum_{j \\neq i} \\lambda_{ij}(t) $。状态 $3$ 是吸收态，因此 $ q_{33}(t) = 0 $ 且对于所有 $j \\neq 3$，有 $ q_{3j}(t) = 0 $。\n\n时间以月为单位，强度以“月”的倒数为单位。你的任务是，在下文给出的假设和数据下，通过求解由生成元 $Q(\\cdot)$ 所蕴含的前向动力学，计算从时间 $t$ 的指定状态分布 $ \\pi(t) $ 出发，在未来时间点 $t+h$ 处于各个状态的动态预测概率。所有报告的概率必须表示为小数，并四舍五入到 $6$ 位小数。计算中不涉及角度。计算必须通过适当处理由分段常数基线风险和分段常数协变量路径引起的时间依赖性来执行。\n\n对于允许的转移 $1 \\to 2$、$1 \\to 3$ 和 $2 \\to 3$，基线风险函数 $ \\lambda_{ij,0}(t) $（单位：月的倒数）使用在 $t \\in \\{0,2,5\\}$ 月的断点定义如下：\n- 对于 $ t \\in [0,2) $：\n  - $ \\lambda_{12,0}(t) = 0.03 $\n  - $ \\lambda_{13,0}(t) = 0.00 $\n  - $ \\lambda_{23,0}(t) = 0.04 $\n- 对于 $ t \\in [2,5) $：\n  - $ \\lambda_{12,0}(t) = 0.05 $\n  - $ \\lambda_{13,0}(t) = 0.02 $\n  - $ \\lambda_{23,0}(t) = 0.06 $\n- 对于 $ t \\ge 5 $：\n  - $ \\lambda_{12,0}(t) = 0.08 $\n  - $ \\lambda_{13,0}(t) = 0.04 $\n  - $ \\lambda_{23,0}(t) = 0.09 $\n\n用于协变量效应的回归系数 $ \\beta_{ij} $ 如下：\n- $ \\beta_{12} = 0.7 $\n- $ \\beta_{13} = 1.0 $\n- $ \\beta_{23} = 0.5 $\n\n协变量路径 $ X(t) $ 是分段常数，并将在下文的每个测试案例中具体指定。\n\n通过求解从时间 $t$ 到时间 $t+h$ 的前向动力学，计算每个测试案例的状态占据概率向量 $ \\pi(t+h) $，同时考虑协变量路径和基线风险分段的变化。你必须确保解尊重状态 $3$ 的吸收性质，并与模型定义一致。时间以月表示，强度以月的倒数表示。将 $ \\pi(t+h) $ 的每个分量四舍五入到 $6$ 位小数。\n\n测试套件（每个案例提供 $t$、$h$、$ \\pi(t) $ 以及作为由断点和值定义的分段常数函数的协变量路径 $X(t)$）：\n- 案例 1：\n  - $ t = 3 $\n  - $ h = 2 $\n  - $ \\pi(t) = [1.0, 0.0, 0.0] $\n  - 协变量路径：断点 $ [0.0, 4.0] $，值 $ [0.0, 1.0] $，表示当 $ t \\in [0,4) $ 时 $ X(t) = 0 $，当 $ t \\ge 4 $ 时 $ X(t) = 1 $。\n- 案例 2（边界条件）：\n  - $ t = 5 $\n  - $ h = 0 $\n  - $ \\pi(t) = [0.0, 1.0, 0.0] $\n  - 协变量路径：断点 $ [0.0, 4.0] $，值 $ [0.0, 1.0] $。\n- 案例 3（非退化的初始分布）：\n  - $ t = 6 $\n  - $ h = 3 $\n  - $ \\pi(t) = [0.6, 0.4, 0.0] $\n  - 协变量路径：断点 $ [0.0] $，值 $ [1.0] $，表示 $ X(t) \\equiv 1 $。\n- 案例 4（边缘案例，初始时 $1 \\to 3$ 的基线风险为零）：\n  - $ t = 1 $\n  - $ h = 1.5 $\n  - $ \\pi(t) = [1.0, 0.0, 0.0] $\n  - 协变量路径：断点 $ [0.0] $，值 $ [0.0] $，表示 $ X(t) \\equiv 0 $。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试案例的结果是一个包含三个四舍五入小数的列表，代表状态 $[1,2,3]$ 的 $ \\pi(t+h) $。例如，输出格式为 $ [[p_{1,1},p_{1,2},p_{1,3}],[p_{2,1},p_{2,2},p_{2,3}],\\ldots] $，其中每个 $p_{k,i}$ 都四舍五入到 $6$ 位小数。", "solution": "用户提供的问题已经过严格验证，并被确定为是合理的。这是一个在医学数据统计建模领域中提法明确、有科学依据的问题。该问题要求计算一个时间非齐次连续时间马尔可夫链（CTMC）中的未来状态概率，这是使用多状态模型进行动态预测的一项标准任务。\n\n该解决方案的理论基础是 Kolmogorov 前向方程，它控制着状态占据概率向量 $\\pi(t)$ 随时间的演化：\n$$\n\\frac{d}{dt}\\pi(t) = \\pi(t) Q(t)\n$$\n在此，$\\pi(t) = [\\pi_1(t), \\pi_2(t), \\pi_3(t)]$ 是一个行向量，表示在时间 $t$ 处于各个状态的概率，而 $Q(t)$ 是时间 $t$ 的转移强度矩阵，或称生成元矩阵。\n\n从时间 $s$ 到未来时间 $u$ 的预测解由下式给出：\n$$\n\\pi(u) = \\pi(s) P(s, u)\n$$\n其中 $P(s, u)$ 是转移概率矩阵。其元素 $P_{ij}(s,u)$ 是指在时间 $s$ 处于状态 $i$ 的条件下，在时间 $u$ 处于状态 $j$ 的概率。\n\n问题指出，基线风险 $\\lambda_{ij,0}(t)$ 和协变量路径 $X(t)$ 都是分段常数。因此，转移强度 $\\lambda_{ij}(t) = \\lambda_{ij,0}(t) \\exp(\\beta_{ij} X(t))$ 也是分段常数，这意味着生成元矩阵 $Q(t)$ 是分段常数的。\n\n设我们关心的时间区间为 $[t, t+h]$。我们必须识别出此区间内所有使生成元矩阵 $Q(\\cdot)$ 值发生变化的时间点。这些断点源于分段常数基线风险的定义（在时间 $2$ 和 $5$）以及分段常数协变量路径的定义（具体取决于每个测试案例）。让我们将起始时间 $t$、结束时间 $t+h$ 以及其间任何断点组成的已排序、唯一的系列时间点表示为 $\\tau_0, \\tau_1, \\dots, \\tau_K$，其中 $\\tau_0 = t$ 且 $\\tau_K = t+h$。\n\n在任何子区间 $[\\tau_k, \\tau_{k+1})$ 内，生成元矩阵是恒定的。我们用 $Q_k$ 表示这个常数矩阵。对于这样一个具有恒定生成元 $Q_k$ 且时长为 $\\Delta\\tau_k = \\tau_{k+1} - \\tau_k$ 的子区间，其转移概率矩阵由矩阵指数给出：\n$$\nP(\\tau_k, \\tau_{k+1}) = \\exp(\\Delta\\tau_k \\cdot Q_k)\n$$\n其中矩阵指数 $\\exp(A)$ 由其泰勒级数 $\\sum_{n=0}^{\\infty} \\frac{A^n}{n!}$ 定义。\n\n在整个时间范围 $[t, t+h]$ 上的总转移概率矩阵，可以通过利用 Chapman-Kolmogorov 属性，按时间顺序将每个子区间的矩阵相乘得到：\n$$\nP(t, t+h) = P(\\tau_0, \\tau_1) \\cdot P(\\tau_1, \\tau_2) \\cdot \\ldots \\cdot P(\\tau_{K-1}, \\tau_K) = \\prod_{k=0}^{K-1} \\exp\\big((\\tau_{k+1} - \\tau_k) Q_k\\big)\n$$\n\n最终的状态概率向量则通过将初始概率向量 $\\pi(t)$ 与此总转移矩阵相乘计算得出：\n$$\n\\pi(t+h) = \\pi(t) \\cdot P(t, t+h)\n$$\n\n每个测试案例的步骤如下：\n1.  定义预测区间 $[t, t+h]$。\n2.  汇总所有位于 $(t, t+h)$ 内的来自基线风险函数和给定协变量路径的断点。创建一个从 $t$ 开始到 $t+h$ 结束的已排序时间点序列 $\\tau_0, \\tau_1, \\dots, \\tau_K$。\n3.  将总转移矩阵 $P_{total}$ 初始化为 $3 \\times 3$ 的单位矩阵 $I$。\n4.  对 $k=0, \\dots, K-1$ 遍历子区间 $[\\tau_k, \\tau_{k+1})$：\n    a.  在子区间内选择一个代表性时间点，例如中点 $\\bar{\\tau} = (\\tau_k + \\tau_{k+1})/2$。\n    b.  确定此区间内 $\\lambda_{ij,0}(\\bar{\\tau})$ 和 $X(\\bar{\\tau})$ 的常数值。\n    c.  构建生成元矩阵 $Q_k$。允许的转移是 $1 \\to 2$、$1 \\to 3$ 和 $2 \\to 3$。状态 $3$ 是吸收态。该矩阵的形式如下：\n        $$\n        Q_k = \\begin{pmatrix} -\\big(\\lambda_{12}(\\bar{\\tau}) + \\lambda_{13}(\\bar{\\tau})\\big)  \\lambda_{12}(\\bar{\\tau})  \\lambda_{13}(\\bar{\\tau}) \\\\ 0  -\\lambda_{23}(\\bar{\\tau})  \\lambda_{23}(\\bar{\\tau}) \\\\ 0  0  0 \\end{pmatrix}\n        $$\n    d.  使用数值库中的矩阵指数函数，计算子区间的转移矩阵 $P_k = \\exp\\big((\\tau_{k+1}-\\tau_k) \\cdot Q_k\\big)$。\n    e.  更新总转移矩阵：$P_{total} = P_{total} \\cdot P_k$。注意矩阵乘法不满足交换律。在 Python 中使用 NumPy，这表示为 `P_total = P_total @ P_k`。\n5.  遍历完所有子区间后，计算最终的概率向量：$\\pi(t+h) = \\pi(t) \\cdot P_{total}$。\n6.  按要求将结果向量的每个元素四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves for the state occupancy probabilities in a continuous-time multi-state\n    disease progression model.\n    \"\"\"\n    \n    # Model parameters\n    BETA_COEFFICIENTS = {\n        '12': 0.7,\n        '13': 1.0,\n        '23': 0.5\n    }\n\n    # Baseline hazard piecewise definition\n    # Structure: (end_time, {transition: hazard_value})\n    BASELINE_HAZARDS_DEF = [\n        (2.0, {'12': 0.03, '13': 0.00, '23': 0.04}),\n        (5.0, {'12': 0.05, '13': 0.02, '23': 0.06}),\n    ]\n    # Hazard for t >= 5.0\n    BASELINE_HAZARDS_FINAL = {'12': 0.08, '13': 0.04, '23': 0.09}\n    \n    # Define test cases from the problem statement\n    test_cases = [\n        {'t': 3, 'h': 2, 'pi_t': [1.0, 0.0, 0.0], 'x_path': ([0.0, 4.0], [0.0, 1.0])},\n        {'t': 5, 'h': 0, 'pi_t': [0.0, 1.0, 0.0], 'x_path': ([0.0, 4.0], [0.0, 1.0])},\n        {'t': 6, 'h': 3, 'pi_t': [0.6, 0.4, 0.0], 'x_path': ([0.0], [1.0])},\n        {'t': 1, 'h': 1.5, 'pi_t': [1.0, 0.0, 0.0], 'x_path': ([0.0], [0.0])},\n    ]\n\n    def get_baseline_hazards(time_point):\n        \"\"\"Returns baseline hazards (lambda_12,0, lambda_13,0, lambda_23,0) for a given time.\"\"\"\n        for t_end, hazards in BASELINE_HAZARDS_DEF:\n            if time_point  t_end:\n                return hazards['12'], hazards['13'], hazards['23']\n        return BASELINE_HAZARDS_FINAL['12'], BASELINE_HAZARDS_FINAL['13'], BASELINE_HAZARDS_FINAL['23']\n\n    def get_covariate_value(time_point, x_path):\n        \"\"\"Returns the covariate value X(t) for a given time and piecewise path.\"\"\"\n        breakpoints, values = x_path\n        # np.searchsorted finds the index where an element should be inserted to maintain order.\n        # 'right' side ensures that at a breakpoint, we take the value of the new interval.\n        idx = np.searchsorted(breakpoints, time_point, side='right') - 1\n        return values[idx]\n\n    def construct_q_matrix(time_point, x_path):\n        \"\"\"Constructs the generator matrix Q for a given time and covariate path.\"\"\"\n        l12_0, l13_0, l23_0 = get_baseline_hazards(time_point)\n        x_val = get_covariate_value(time_point, x_path)\n        \n        # Calculate transition intensities lambda_ij(t)\n        l12 = l12_0 * np.exp(BETA_COEFFICIENTS['12'] * x_val)\n        l13 = l13_0 * np.exp(BETA_COEFFICIENTS['13'] * x_val)\n        l23 = l23_0 * np.exp(BETA_COEFFICIENTS['23'] * x_val)\n        \n        # Construct the 3x3 generator matrix Q\n        Q = np.array([\n            [-(l12 + l13), l12, l13],\n            [0, -l23, l23],\n            [0, 0, 0]\n        ])\n        return Q\n\n    def compute_final_probabilities(t, h, pi_t, x_path):\n        \"\"\"\n        Computes the state probability vector pi(t+h) by solving the forward dynamics.\n        \"\"\"\n        if h == 0:\n            return np.round(pi_t, 6).tolist()\n            \n        t_start = t\n        t_end = t + h\n        \n        # Collect all unique breakpoints within the prediction interval (t, t+h)\n        baseline_breakpoints = [bp for bp, _ in BASELINE_HAZARDS_DEF]\n        covariate_breakpoints = x_path[0]\n        \n        all_breakpoints = sorted(list(set(\n            [bp for bp in baseline_breakpoints if t_start  bp  t_end] +\n            [bp for bp in covariate_breakpoints if t_start  bp  t_end]\n        )))\n        \n        time_points = [t_start] + all_breakpoints + [t_end]\n        \n        # Initialize total transition probability matrix to identity\n        P_total = np.identity(3)\n        \n        # Iterate over sub-intervals where Q is constant\n        for i in range(len(time_points) - 1):\n            tau_start = time_points[i]\n            tau_end = time_points[i+1]\n            delta_tau = tau_end - tau_start\n            \n            # Use midpoint of interval to determine constant Q\n            tau_mid = (tau_start + tau_end) / 2\n            \n            Q = construct_q_matrix(tau_mid, x_path)\n            \n            # Compute transition matrix for the sub-interval\n            P_interval = expm(delta_tau * Q)\n            \n            # Update total transition matrix\n            P_total = P_total @ P_interval\n            \n        # Compute final probability vector\n        pi_t_h = np.array(pi_t) @ P_total\n        \n        return np.round(pi_t_h, 6).tolist()\n\n    results = []\n    for case in test_cases:\n        result = compute_final_probabilities(case['t'], case['h'], case['pi_t'], case['x_path'])\n        results.append(result)\n\n    # Format the output string as per requirements\n    # e.g., [[p1,p2,p3],[q1,q2,q3],...]\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "4975749"}, {"introduction": "前面的练习展示了如何从数据估计模型以及如何使用模型进行预测。但模型参数（如回归系数 $\\beta$）的估计过程本身也充满挑战，尤其是在处理来自观察性研究的复杂数据结构时。本练习将深入探讨似然函数这一统计推断的基石，要求您为一个带有左截断数据的个体推导出其完整的似然贡献。\n\n[@problem_id:5214770] 通过解决这个问题，您将掌握处理不完整观测数据的理论工具，深刻理解在真实世界研究中构建正确统计模型的严谨性与关键性。", "problem": "考虑一个用于描述疾病-死亡进展的三态连续时间马尔可夫链 (CTMC)，其状态为 $0$ (诊断后、并发症前)、$1$ (并发症后) 和 $2$ (死亡，吸收态)。该过程在临床诊断时刻（在“自诊断后时间”尺度上为时间 $0$）从状态 $0$ 开始。只允许发生 $0 \\to 1$、$0 \\to 2$ 和 $1 \\to 2$ 的转移。假设转移强度是时齐的：从 $i \\to j$ 的瞬时风险为 $\\lambda_{ij}  0$，且没有其他可能的转移。设 $\\lambda_{01}$、$\\lambda_{02}$ 和 $\\lambda_{12}$ 为常数。\n\n一项队列研究在固定年龄 $a_{e}$ 招募个体，对每个个体而言，这对应于诊断后 $u  0$ 年（自诊断后时间为 $u$）。招募在数据对 $(\\text{年龄}=a_{e}, \\text{自诊断后时间}=u)$ 处是左截断的，其合格性定义为在 $u$ 时刻存活（等价地，在 $u$ 时刻处于状态 $0$ 或状态 $1$）。在入组时，会观测其当前状态。对于所研究的个体，观测到的数据为：在自诊断后时间 $u$ 入组，入组时状态为 $1$（$0 \\to 1$ 的转移在入组前的一个未观测到的时间发生），并且在入组后 $y  0$ 时刻发生了一次 $1 \\to 2$ 的转移（死亡），且无删失。\n\n从转移强度和马尔可夫性质的定义出发，并考虑到在 $(a_{e}, u)$ 处的左截断，推导该个体的完整似然贡献，结果应为一个关于 $\\lambda_{01}$、$\\lambda_{02}$、$\\lambda_{12}$、$u$ 和 $y$ 的闭式解析表达式。在推导过程中，首先构建从诊断开始的无条件路径概率，然后通过以 $u$ 时刻的合格性和入组时观测到的状态为条件来对左截断进行调整，从而确定入组时的正确初始状态分布。解释左截断如何改变入组后 $0 \\to 1$ 和 $1 \\to 2$ 转移的风险指示符（风险集）。假设 $\\lambda_{01} + \\lambda_{02} \\ne \\lambda_{12}$，以使瞬时状态概率具有初等闭式解。将最终的似然报告为单个简化的解析表达式。无需进行数值舍入。", "solution": "用户希望我扮演一位严谨的STEM教授，解决一个关于连续时间马尔可夫模型的问题。我必须首先验证该问题的有效性，然后提供详细的解答。\n\n### 步骤1：提取已知条件\n- **模型**：一个三态连续时间马尔可夫链 (CTMC)。\n- **状态**：$S = \\{0, 1, 2\\}$，其中状态 $0$ 为“诊断后、并发症前”，状态 $1$ 为“并发症后”，状态 $2$ 为“死亡”（吸收态）。\n- **初始条件**：过程在时间 $t=0$（诊断时间）从状态 $0$ 开始。$P(X(0)=0)=1$。\n- **转移**：只允许 $0 \\to 1$、$0 \\to 2$ 和 $1 \\to 2$ 的转移。\n- **转移强度**：时齐、恒定、为正的强度 $\\lambda_{01}$、$\\lambda_{02}$、$\\lambda_{12}$。该过程的生成元矩阵 $Q$（状态按 $(0, 1, 2)$ 排序）为：\n$$\nQ = \\begin{pmatrix} -(\\lambda_{01}+\\lambda_{02})  \\lambda_{01}  \\lambda_{02} \\\\ 0  -\\lambda_{12}  \\lambda_{12} \\\\ 0  0  0 \\end{pmatrix}\n$$\n- **研究设计**：\n    - **左截断**：个体在自诊断后时间为 $u  0$ 时入组。\n    - **合格性**：个体在时间 $u$ 时如果存活（处于状态 $0$ 或 $1$），则有资格入组。\n- **单个个体的观测数据**：\n    - 在时间 $u$ 进入研究。\n    - 入组时观测到的状态为 $1$。\n    - 在入组后 $y  0$ 时刻（即绝对时间 $u+y$）观测到一次 $1 \\to 2$ 的转移（死亡）。\n    - 无删失。\n- **约束条件**：$\\lambda_{01} + \\lambda_{02} \\ne \\lambda_{12}$。\n- **目标**：推导该个体的完整似然贡献的闭式表达式。解释左截断对风险指示符的影响。\n\n### 步骤2：使用提取的已知条件进行验证\n对问题进行有效性验证：\n- **科学依据**：该问题描述了一个经典的疾病-死亡模型，这是CTMC在生物统计学和流行病学中的标准应用。左截断和似然构建的概念是生存分析和事件史分析的基础。该设置在科学上是合理的。\n- **良态性**：该问题定义明确。它指明了模型、数据和参数。目标是推导似然贡献，这是一项标准的统计任务。约束条件 $\\lambda_{01} + \\lambda_{02} \\ne \\lambda_{12}$ 确保了生成元矩阵瞬时部分的特征值是不同的，这将转移概率的计算简化为标准的闭式形式，避免了更复杂的情况。存在唯一且有意义的解。\n- **客观性**：该问题以精确的数学和统计语言陈述，没有主观性或歧义。\n- **完整性与一致性**：所提供的信息（模型、参数、观测方案、结果）足以推导出似然。没有矛盾之处。\n- **可行性与现实性**：该场景非常现实。左截断是观察性研究的一个共同特征，在这些研究中，随访并非从过程的自然时间起点开始。\n- **平凡性/同义反复**：该问题并非无足轻重。它要求在非标准抽样方案（截断）下，仔细应用随机过程理论和似然构建方法。\n\n### 步骤3：结论与行动\n问题是**有效的**。我将继续推导解答。\n\n### 似然贡献的推导\n\n对于一个受左截断影响的个体，其似然贡献是其观测历史的条件概率密度，条件是他们满足了被纳入研究的标准。\n\n设 $E$ 表示该个体的观测历史：在时间 $u$ 以状态 $1$ 入组，并在时间 $u+y$ 转移到状态 $2$ (死亡)。这意味着该个体的状态过程 $X(t)$ 满足：$X(u)=1$，$X(t)=1$ 对于 $t \\in [u, u+y)$，并且在 $u+y$ 发生一次到状态 $2$ 的跳跃。为了发生这种情况，从状态 $0 \\to 1$ 的转移必须在某个未观测到的时间 $s \\in (0, u)$ 发生过。\n\n设 $A$ 为个体在时间 $u$ 有资格参与研究的事件。问题陈述合格性定义为在时间 $u$ 存活，因此 $A = \\{X(u) \\in \\{0, 1\\}\\}$。\n\n完整的似然贡献 $L$ 由条件概率密度给出：\n$$L = f(E | A) = \\frac{f(E \\cap A)}{P(A)}$$\n事件 $E$（在时间 $u$ 处于状态 $1$）是事件 $A$（在时间 $u$ 处于状态 $0$ 或 $1$）的子集。因此，$E \\cap A = E$。似然为：\n$$L = \\frac{f(E)}{P(A)}$$\n我们必须计算分子 $f(E)$ 的概率密度和分母 $P(A)$ 的概率。\n\n**1. 状态概率的推导**\n\n我们首先需要转移概率 $P_{0j}(t) = P(X(t)=j | X(0)=0)$。这些可以通过求解柯尔莫哥洛夫向前方程 $\\frac{d\\mathbf{P}(t)}{dt} = \\mathbf{P}(t)Q$ 得到，初始条件为 $\\mathbf{P}(0) = (1, 0, 0)$。\n\n对于状态 $0$：\n$\\frac{d P_{00}(t)}{dt} = -(\\lambda_{01}+\\lambda_{02})P_{00}(t)$，其中 $P_{00}(0)=1$。\n其解为 $P_{00}(t) = \\exp(-(\\lambda_{01}+\\lambda_{02})t)$。\n\n对于状态 $1$：\n$\\frac{d P_{01}(t)}{dt} = \\lambda_{01}P_{00}(t) - \\lambda_{12}P_{01}(t)$，其中 $P_{01}(0)=0$。\n这是一个一阶线性常微分方程：\n$\\frac{d P_{01}(t)}{dt} + \\lambda_{12}P_{01}(t) = \\lambda_{01}\\exp(-(\\lambda_{01}+\\lambda_{02})t)$。\n使用积分因子 $\\exp(\\lambda_{12}t)$，我们求解：\n$$P_{01}(t) = \\exp(-\\lambda_{12}t) \\int_0^t \\lambda_{01}\\exp(-(\\lambda_{01}+\\lambda_{02})\\tau)\\exp(\\lambda_{12}\\tau) d\\tau$$\n$$P_{01}(t) = \\lambda_{01}\\exp(-\\lambda_{12}t) \\int_0^t \\exp((\\lambda_{12} - \\lambda_{01} - \\lambda_{02})\\tau) d\\tau$$\n设 $\\Delta = \\lambda_{12} - \\lambda_{01} - \\lambda_{02}$。根据问题的约束，$\\Delta \\ne 0$。\n$$P_{01}(t) = \\lambda_{01}\\exp(-\\lambda_{12}t) \\left[ \\frac{\\exp(\\Delta\\tau)}{\\Delta} \\right]_0^t = \\frac{\\lambda_{01}}{\\Delta} \\exp(-\\lambda_{12}t) (\\exp(\\Delta t) - 1)$$\n$$P_{01}(t) = \\frac{\\lambda_{01}}{\\lambda_{12} - \\lambda_{01} - \\lambda_{02}} \\left( \\exp(-(\\lambda_{01}+\\lambda_{02})t) - \\exp(-\\lambda_{12}t) \\right)$$\n\n**2. 分母 $P(A)$ 的计算**\n\n分母是在时间 $u$ 存活的概率：\n$P(A) = P(X(u) \\in \\{0, 1\\}) = P_{00}(u) + P_{01}(u)$。\n代入上面推导出的表达式：\n$$P(A) = \\exp(-(\\lambda_{01}+\\lambda_{02})u) + \\frac{\\lambda_{01}}{\\lambda_{12} - \\lambda_{01} - \\lambda_{02}} \\left( \\exp(-(\\lambda_{01}+\\lambda_{02})u) - \\exp(-\\lambda_{12}u) \\right)$$\n合并含有 $\\exp(-(\\lambda_{01}+\\lambda_{02})u)$ 的项：\n$$P(A) = \\left( 1 + \\frac{\\lambda_{01}}{\\lambda_{12} - \\lambda_{01} - \\lambda_{02}} \\right) \\exp(-(\\lambda_{01}+\\lambda_{02})u) - \\frac{\\lambda_{01}}{\\lambda_{12} - \\lambda_{01} - \\lambda_{02}} \\exp(-\\lambda_{12}u)$$\n$$P(A) = \\left( \\frac{\\lambda_{12} - \\lambda_{02}}{\\lambda_{12} - \\lambda_{01} - \\lambda_{02}} \\right) \\exp(-(\\lambda_{01}+\\lambda_{02})u) - \\frac{\\lambda_{01}}{\\lambda_{12} - \\lambda_{01} - \\lambda_{02}} \\exp(-\\lambda_{12}u)$$\n\n**3. 分子 $f(E)$ 的计算**\n\n分子是在时间 $u$ 处于状态 $1$ 并且在时间 $u+y$ 死亡的联合概率密度。这需要对 $0 \\to 1$ 转移所有可能的（未观测到的）时间 $s$ 进行积分，其中 $0  s  u$。\n该路径的密度构建如下：\n- 在状态 $0$ 中存活到时间 $s$：概率密度为 $\\exp(-(\\lambda_{01}+\\lambda_{02})s)$。\n- 在 $[s, s+ds]$ 内发生 $0 \\to 1$ 转移：风险为 $\\lambda_{01}$，概率为 $\\lambda_{01}ds$。\n- 从 $s$ 到 $u+y$ 在状态 $1$ 中存活：持续时间为 $(u+y-s)$，概率为 $\\exp(-\\lambda_{12}(u+y-s))$。\n- 在时间 $u+y$ 发生 $1 \\to 2$ 转移：风险为 $\\lambda_{12}$。\n\n联合密度 $f(E)$ 是在 $s \\in (0, u)$ 上的积分：\n$$f(E) = \\int_0^u \\left( \\exp(-(\\lambda_{01}+\\lambda_{02})s) \\lambda_{01} \\right) \\left( \\exp(-\\lambda_{12}(u+y-s)) \\lambda_{12} \\right) ds$$\n$$f(E) = \\lambda_{01}\\lambda_{12} \\exp(-\\lambda_{12}(u+y)) \\int_0^u \\exp(-(\\lambda_{01}+\\lambda_{02})s + \\lambda_{12}s) ds$$\n$$f(E) = \\lambda_{01}\\lambda_{12} \\exp(-\\lambda_{12}(u+y)) \\int_0^u \\exp(\\Delta s) ds$$\n$$f(E) = \\lambda_{01}\\lambda_{12} \\exp(-\\lambda_{12}(u+y)) \\left[ \\frac{\\exp(\\Delta s)}{\\Delta} \\right]_0^u = \\frac{\\lambda_{01}\\lambda_{12}}{\\Delta} \\exp(-\\lambda_{12}(u+y)) (\\exp(\\Delta u) - 1)$$\n$$f(E) = \\frac{\\lambda_{01}\\lambda_{12}}{\\lambda_{12} - \\lambda_{01} - \\lambda_{02}} \\left( \\exp(-\\lambda_{12}(u+y) + (\\lambda_{12} - \\lambda_{01} - \\lambda_{02})u) - \\exp(-\\lambda_{12}(u+y)) \\right)$$\n$$f(E) = \\frac{\\lambda_{01}\\lambda_{12}}{\\lambda_{12} - \\lambda_{01} - \\lambda_{02}} \\left( \\exp(-(\\lambda_{01}+\\lambda_{02})u - \\lambda_{12}y) - \\exp(-\\lambda_{12}(u+y)) \\right)$$\n\n**4. 组合似然贡献 $L$**\n\n现在我们构造比率 $L = f(E) / P(A)$。项 $1/(\\lambda_{12} - \\lambda_{01} - \\lambda_{02})$ 从分子和分母中消去。\n$$L = \\frac{\\lambda_{01}\\lambda_{12} \\left( \\exp(-(\\lambda_{01}+\\lambda_{02})u - \\lambda_{12}y) - \\exp(-\\lambda_{12}(u+y)) \\right)}{(\\lambda_{12} - \\lambda_{02}) \\exp(-(\\lambda_{01}+\\lambda_{02})u) - \\lambda_{01} \\exp(-\\lambda_{12}u)}$$\n我们可以从分子括号中提出因子 $\\exp(-\\lambda_{12}y)$，并从同一括号中提出 $\\exp(-\\lambda_{12}u)$：\n$$L = \\frac{\\lambda_{01}\\lambda_{12} \\exp(-\\lambda_{12}y) \\left( \\exp(-(\\lambda_{01}+\\lambda_{02})u) - \\exp(-\\lambda_{12}u) \\right)}{(\\lambda_{12} - \\lambda_{02}) \\exp(-(\\lambda_{01}+\\lambda_{02})u) - \\lambda_{01} \\exp(-\\lambda_{12}u)}$$\n这是似然贡献的最终简化表达式。\n\n### 左截断对风险指示符的影响\n\n从状态 $i$ 转移的风险指示符，记为 $Y_i(t)$，如果一个个体在时间 $t$ 处于状态 $i$，则为 $1$，否则为 $0$。$i \\to j$ 转移的风险集是所有满足 $Y_i(t)=1$ 的个体的集合。\n\n时间 $u$ 的左截断从根本上改变了对于任何时间 $t \\ge u$ 风险集的构建方式。如果没有截断，个体的从 $t=0$ 开始的整个历史都是已知的，并且他们对风险集的贡献是在所有 $t \\ge 0$ 上定义的。\n\n对于本问题中的特定个体，观测从 $t=u$ 开始，此时处于状态 $1$。\n- **$0 \\to 1$ 转移的风险**：由于该个体在入组时间 $u$ 时已经处于状态 $1$，对于所有观测时间 $t \\ge u$，其指示符 $Y_0(t)$ 均为 $0$。因此，该个体在入组研究后**永远不会**对 $0 \\to 1$ 转移的风险集做出贡献。他们未被观测到的入组前历史涉及对此转移的风险，但此信息不属于入组后风险集的一部分。\n- **$1 \\to 2$ 转移的风险**：该个体以状态 $1$ 入组，并保持该状态直到在时间 $u+y$ 死亡。因此，其风险指示符 $Y_1(t)$ 在整个区间 $t \\in [u, u+y)$ 内为 $1$。他们在这个观测期间一直对 $1 \\to 2$ 转移的风险集做出贡献。\n\n总之，左截断意味着个体仅从其入组时间 $u$ 开始对风险集做出贡献。一个个体以状态 $i$ 入组，对于 $t \\ge u$，只能对源于状态 $i$ 及其可能进入的任何后续状态的转移风险集做出贡献。他们不能对入组前已经离开的状态的转移风险集做出贡献。这种信息划分被推导出的条件似然正确地处理了。", "answer": "$$\n\\boxed{\\frac{\\lambda_{01}\\lambda_{12} \\exp(-\\lambda_{12}y) \\left( \\exp(-(\\lambda_{01}+\\lambda_{02})u) - \\exp(-\\lambda_{12}u) \\right)}{(\\lambda_{12} - \\lambda_{02}) \\exp(-(\\lambda_{01}+\\lambda_{02})u) - \\lambda_{01} \\exp(-\\lambda_{12}u)}}\n$$", "id": "5214770"}]}