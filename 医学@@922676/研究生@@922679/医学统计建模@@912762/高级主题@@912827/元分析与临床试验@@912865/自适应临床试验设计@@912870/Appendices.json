{"hands_on_practices": [{"introduction": "在临床试验中，分阶段分析数据并结合结果是一项核心挑战，尤其是在需要严格控制第一类错误率的自适应设计中。逆正态组合方法是频率派自适应设计中的一个基石，它提供了一种基于信息量对各阶段结果进行加权合并的优雅框架。本练习 ([@problem_id:4950399]) 将引导你从基本统计原理（如有效分数和Fisher信息）出发，推导出这种组合检验统计量，从而加深对自adaptive设计背后理论的理解，并将其应用于具体计算中。", "problem": "考虑一个两阶段自适应临床试验，该试验使用预先计划的组合检验框架，以在阶段间进行数据依赖性调整的情况下控制I类错误。设阶段性标准化有效得分统计量为 $z_1$ 和 $z_2$，它们分别根据第 1 阶段和第 2 阶段的独立患者队列计算得出。在无治疗效果的原假设下，假设广义线性模型满足标准渐近性质：有效得分 $U$ 满足 $U \\approx \\mathcal{N}(0, I)$，其中 $I$ 是 Fisher 信息，并且 Fisher 信息在独立阶段间具有可加性。具体而言，设 $U_j$ 为第 $j$ 阶段的有效得分，其方差为 $I_j$，并将阶段性标准化统计量定义为 $z_j = U_j / \\sqrt{I_j}$，在原假设下，它们是独立同分布于 $\\mathcal{N}(0,1)$ 的。设总 Fisher 信息为 $I = I_1 + I_2$，信息分数分别为 $w_1 = I_1 / I$ 和 $w_2 = I_2 / I$。\n\n仅使用这些原则——独立抽样下有效得分和 Fisher 信息的可加性，以及通过 Fisher 信息的平方根进行标准化——推导出 $z_1$ 和 $z_2$ 的线性组合 $Z_{\\text{comb}}$，该组合在原假设下标准化为 $\\mathcal{N}(0,1)$，并遵循基于信息的加权。然后，对于 $w_1 = 0.4$, $w_2 = 0.6$, $z_1 = 1.0$, 和 $z_2 = 2.1$，计算 $Z_{\\text{comb}}$ 的数值以及为检验优效性而定义的单边 $p$ 值 $p = \\Pr(Z \\geq Z_{\\text{comb}})$（其中 $Z \\sim \\mathcal{N}(0,1)$）。将 $p$ 值表示为小数。将 $Z_{\\text{comb}}$ 和 $p$ 的值均四舍五入到四位有效数字。", "solution": "第一步是推导组合检验统计量 $Z_{\\text{comb}}$ 的表达式。问题要求该统计量是阶段性标准化统计量 $z_1$ 和 $z_2$ 的线性组合，在原假设下标准化为标准正态分布 $\\mathcal{N}(0,1)$，并且遵循基于信息的加权。\n\n我们从陈述的基本原则开始：有效得分 $U$ 和 Fisher 信息 $I$ 的可加性。对于一个具有独立队列的两阶段试验，总有效得分是各阶段得分之和，总 Fisher 信息是各阶段信息量之和。\n$$U_{\\text{total}} = U_1 + U_2$$\n$$I_{\\text{total}} = I_1 + I_2$$\n如果将完整数据集作为一步进行分析，其总体标准化检验统计量定义为总有效得分除以总 Fisher 信息的平方根。我们称这个统计量为 $Z$。\n$$Z = \\frac{U_{\\text{total}}}{\\sqrt{I_{\\text{total}}}} = \\frac{U_1 + U_2}{\\sqrt{I_1 + I_2}}$$\n在原假设和适当的正则性条件下，这个总体统计量 $Z$ 渐近服从 $\\mathcal{N}(0,1)$ 分布。\n\n问题将阶段性标准化统计量定义为 $z_j = U_j / \\sqrt{I_j}$（$j=1, 2$）。我们可以重新整理这个定义，用标准化统计量来表示阶段性有效得分：\n$$U_1 = z_1 \\sqrt{I_1}$$\n$$U_2 = z_2 \\sqrt{I_2}$$\n现在，我们将这些表达式代入总体统计量 $Z$ 的公式中。这将得到我们期望的组合统计量 $Z_{\\text{comb}}$。\n$$Z_{\\text{comb}} = \\frac{z_1 \\sqrt{I_1} + z_2 \\sqrt{I_2}}{\\sqrt{I_1 + I_2}}$$\n为了用信息分数 $w_1 = I_1 / I_{\\text{total}}$ 和 $w_2 = I_2 / I_{\\text{total}}$ 来表示，我们可以将表达式重写为：\n$$Z_{\\text{comb}} = \\frac{\\sqrt{I_1}}{\\sqrt{I_1 + I_2}} z_1 + \\frac{\\sqrt{I_2}}{\\sqrt{I_1 + I_2}} z_2$$\n认识到 $\\sqrt{w_1} = \\sqrt{I_1 / (I_1+I_2)} = \\sqrt{I_1} / \\sqrt{I_1+I_2}$，对于 $w_2$ 也类似，我们得到信息加权组合统计量的最终形式：\n$$Z_{\\text{comb}} = \\sqrt{w_1} z_1 + \\sqrt{w_2} z_2$$\n这个推导成功地利用了信息可加性原理，从阶段性分量构建了一个组合统计量。作为验证，我们可以检验其分布。鉴于 $z_1, z_2 \\sim \\mathcal{N}(0,1)$ 且相互独立，$Z_{\\text{comb}}$ 的均值为 $E[Z_{\\text{comb}}] = \\sqrt{w_1} E[z_1] + \\sqrt{w_2} E[z_2] = \\sqrt{w_1}(0) + \\sqrt{w_2}(0) = 0$。方差为 $Var(Z_{\\text{comb}}) = Var(\\sqrt{w_1} z_1 + \\sqrt{w_2} z_2) = (\\sqrt{w_1})^2 Var(z_1) + (\\sqrt{w_2})^2 Var(z_2) = w_1(1) + w_2(1) = w_1 + w_2$。根据定义，$w_1 + w_2 = (I_1/I_{\\text{total}}) + (I_2/I_{\\text{total}}) = (I_1+I_2)/I_{\\text{total}} = 1$。因此，$Var(Z_{\\text{comb}}) = 1$。由于 $Z_{\\text{comb}}$ 是独立正态变量的线性组合，它也服从正态分布。因此，$Z_{\\text{comb}} \\sim \\mathcal{N}(0,1)$，符合要求。\n\n接下来，我们使用给定的数据计算 $Z_{\\text{comb}}$ 的数值：$w_1 = 0.4$, $w_2 = 0.6$, $z_1 = 1.0$, 和 $z_2 = 2.1$。\n$$Z_{\\text{comb}} = \\sqrt{0.4} (1.0) + \\sqrt{0.6} (2.1)$$\n$$Z_{\\text{comb}} \\approx (0.63245553) (1.0) + (0.77459667) (2.1)$$\n$$Z_{\\text{comb}} \\approx 0.63245553 + 1.62665290$$\n$$Z_{\\text{comb}} \\approx 2.25910843$$\n四舍五入到四位有效数字，我们得到 $Z_{\\text{comb}} = 2.259$。\n\n最后，我们计算单边 $p$ 值，其定义为 $p = \\Pr(Z \\geq Z_{\\text{comb}})$，其中 $Z \\sim \\mathcal{N}(0,1)$ 是一个标准正态随机变量。这可以计算为 $1 - \\Phi(Z_{\\text{comb}})$，其中 $\\Phi$ 是标准正态分布的累积分布函数 (CDF)。为保证精度，我们使用未四舍五入的 $Z_{\\text{comb}}$ 值：\n$$p = \\Pr(Z \\geq 2.25910843)$$\n$$p = 1 - \\Phi(2.25910843)$$\n使用标准正态分布表或计算软件，我们找到该值。\n$$p \\approx 1 - 0.98806392 = 0.01193608$$\n将此值四舍五入到四位有效数字，得到 $p = 0.01194$。", "answer": "$$\\boxed{\\begin{pmatrix} 2.259 & 0.01194 \\end{pmatrix}}$$", "id": "4950399"}, {"introduction": "自适应设计最实际的应用之一是在试验中期修正关于滋扰参数（如方差）的初始假设，以确保试验有足够把握检测到真实的治疗效果。本练习 ([@problem_id:4772912]) 演示了如何执行“盲态样本量重估”。这项技术允许研究者在不揭盲治疗效果数据、不损害试验完整性的前提下，根据期中观测到的数据方差来调整总样本量，它将核心的把握度计算公式与真实的自适应策略紧密联系起来。", "problem": "计划进行一项双臂、均等分配、平行组的优效性试验，其主要终点为连续变量，采用由中心极限定理（CLT）支持的正态理论框架。设每个臂中的个体结果独立同分布，方差为 $\\sigma^{2}$，并假设治疗效应定义为均值差 $\\delta = \\mu_{1} - \\mu_{2}$。该检验为单侧检验，I类错误率为 $\\alpha = 0.025$，目标功效为 $1 - \\beta = 0.9$，以检测 $\\delta = 0.3$。初始计划假设 $\\sigma^{2} = 1$。该设计在期中信息时间 $t = 0.5$ 时，基于信息函数使用盲法样本量重估，其中合并的盲法方差估计值为 $\\hat{\\sigma}^{2} = 1.44$。\n\n从第一性原理出发——即零假设和备择假设下样本均值差的抽样分布、I类错误和功效的定义，以及单侧$z$检验的行为——推导当盲法期中估计值 $\\hat{\\sigma}^{2}$ 替代计划值 $\\sigma^{2}$ 时，两臂重新估计的总样本量的连续目标值 $N_{\\text{new}}$。假设均等分配、无其他调整，并保留原计划的临界值。忽略整数约束；报告四位有效数字的实数值 $N_{\\text{new}}$。", "solution": "该问题要求基于期中盲法方差估计，为一个双臂优效性临床试验推导重新估计的总样本量 $N_{\\text{new}}$。我们将从第一性原理开始，即双样本均值$z$检验的 statistical 框架。\n\n设 $X_{1j}$ 和 $X_{2j}$ 分别为治疗组（第1组）和对照组（第2组）中第 $j$ 个受试者的连续结果。假设结果独立且（近似）服从正态分布，$X_{ij} \\sim N(\\mu_i, \\sigma^2)$，$i \\in \\{1, 2\\}$，具有共同方差 $\\sigma^2$。这由中心极限定理所支持。治疗效应是均值之差，$\\delta = \\mu_1 - \\mu_2$。\n\n该试验采用均等分配，因此每组的样本量为 $n_1 = n_2 = N/2$，其中 $N$ 是总样本量。治疗效应的估计量是样本均值之差，$\\hat{\\delta} = \\bar{X}_1 - \\bar{X}_2$。\n\n$\\hat{\\delta}$ 的抽样分布为正态分布，其均值为 $E[\\hat{\\delta}] = \\mu_1 - \\mu_2 = \\delta$，方差为 $\\text{Var}(\\hat{\\delta}) = \\text{Var}(\\bar{X}_1) + \\text{Var}(\\bar{X}_2) = \\frac{\\sigma^2}{n_1} + \\frac{\\sigma^2}{n_2} = \\frac{\\sigma^2}{N/2} + \\frac{\\sigma^2}{N/2} = \\frac{4\\sigma^2}{N}$。因此，$\\hat{\\delta} \\sim N(\\delta, \\frac{4\\sigma^2}{N})$。\n\n该试验旨在检验单侧零假设 $H_0: \\delta \\le 0$ 与备择假设 $H_1: \\delta > 0$。为了构建检验，我们考虑边界情况 $H_0: \\delta = 0$。标准化检验统计量为：\n$$ Z = \\frac{\\hat{\\delta} - 0}{\\sqrt{\\text{Var}(\\hat{\\delta})}} = \\frac{\\bar{X}_1 - \\bar{X}_2}{\\sqrt{4\\sigma^2/N}} $$\n在 $H_0$ 下，$Z$ 服从标准正态分布，$Z \\sim N(0, 1)$。\n\n单侧I类错误率指定为 $\\alpha = 0.025$。如果检验统计量 $Z$ 超过临界值 $c$，则拒绝零假设。该临界值由 $P(Z > c | H_0) = \\alpha$ 确定。对于标准正态变量，这意味着 $c = z_{1-\\alpha}$，即标准正态分布的 $(1-\\alpha)$ 分位数。给定 $\\alpha = 0.025$，临界值为 $c = z_{1-0.025} = z_{0.975}$。\n\n功效是在特定备择假设为真时正确拒绝 $H_0$ 的概率。该试验的功效设置为在检测到治疗效应 $\\delta_A = 0.3$ 时达到 $1 - \\beta = 0.9$。\n$$ 1 - \\beta = P\\left(Z > z_{1-\\alpha} \\mid \\delta = \\delta_A\\right) $$\n代入 $Z$ 的定义：\n$$ 1 - \\beta = P\\left(\\frac{\\bar{X}_1 - \\bar{X}_2}{\\sqrt{4\\sigma^2/N}} > z_{1-\\alpha} \\mid \\delta = \\delta_A\\right) $$\n为了在备择假设下（其中 $E[\\bar{X}_1 - \\bar{X}_2] = \\delta_A$）评估此概率，我们以不同方式对表达式进行标准化：\n$$ 1 - \\beta = P\\left(\\frac{(\\bar{X}_1 - \\bar{X}_2) - \\delta_A}{\\sqrt{4\\sigma^2/N}} > z_{1-\\alpha} - \\frac{\\delta_A}{\\sqrt{4\\sigma^2/N}}\\right) $$\n概率内左侧的表达式是一个标准正态变量。设 $Z' \\sim N(0,1)$。则：\n$$ P\\left(Z' > z_{1-\\alpha} - \\frac{\\delta_A \\sqrt{N}}{2\\sigma}\\right) = 1 - \\beta $$\n这意味着概率的参数必须是标准正态分布的 $\\beta$ 分位数 $z_{\\beta}$，它等于 $-z_{1-\\beta}$。\n$$ z_{1-\\alpha} - \\frac{\\delta_A \\sqrt{N}}{2\\sigma} = -z_{1-\\beta} $$\n求解总样本量 $N$ 得到通用公式：\n$$ z_{1-\\alpha} + z_{1-\\beta} = \\frac{\\delta_A \\sqrt{N}}{2\\sigma} $$\n$$ \\sqrt{N} = \\frac{2\\sigma (z_{1-\\alpha} + z_{1-\\beta})}{\\delta_A} $$\n$$ N = \\frac{4\\sigma^2 (z_{1-\\alpha} + z_{1-\\beta})^2}{\\delta_A^2} $$\n问题描述了一个盲法样本量重估程序。这涉及使用方差的期中估计值 $\\hat{\\sigma}^2 = 1.44$ 来重新计算达到目标功效所需的样本量。重估保留了原计划的临界值 ($z_{1-\\alpha}$)、目标功效 ($1-\\beta$) 和感兴趣的效应大小 ($\\delta_A$)。因此，我们可以使用推导出的样本量公式，将计划方差 $\\sigma^2 = 1$ 替换为期中估计值 $\\hat{\\sigma}^2 = 1.44$。所有其他参数保持不变。\n\n重新估计的总样本量 $N_{\\text{new}}$ 由以下公式给出：\n$$ N_{\\text{new}} = \\frac{4\\hat{\\sigma}^2 (z_{1-\\alpha} + z_{1-\\beta})^2}{\\delta_A^2} $$\n我们代入给定值：\n$\\hat{\\sigma}^2 = 1.44$\n$\\delta_A = 0.3$\n$\\alpha = 0.025 \\implies z_{1-\\alpha} = z_{0.975}$\n$1-\\beta = 0.9 \\implies z_{1-\\beta} = z_{0.9}$\n\n所需的标准正态分布分位数为 $z_{0.975} \\approx 1.959964$ 和 $z_{0.9} \\approx 1.281552$。\n将这些值代入 $N_{\\text{new}}$ 的方程中：\n$$ N_{\\text{new}} = \\frac{4(1.44) (z_{0.975} + z_{0.9})^2}{(0.3)^2} $$\n$$ N_{\\text{new}} = \\frac{5.76}{0.09} (1.959964 + 1.281552)^2 $$\n$$ N_{\\text{new}} = 64 \\times (3.241516)^2 $$\n$$ N_{\\text{new}} = 64 \\times 10.507427... $$\n$$ N_{\\text{new}} = 672.4753... $$\n问题要求将结果四舍五入到四位有效数字。\n$$ N_{\\text{new}} \\approx 672.5 $$\n该值表示在观测到的期中方差下，为达到 $90\\%$ 功效，两臂所需的总样本量的连续目标值。", "answer": "$$\n\\boxed{672.5}\n$$", "id": "4772912"}, {"introduction": "将视角转向贝叶斯范式和经典的“探索-利用”困境，多臂老虎机（Multi-Armed Bandit, MAB）框架为反应自适应随机化（Response-Adaptive Randomization, RAR）提供了一个强大的模型。本计算练习 ([@problem_id:4950423]) 要求你通过编程实现一个算法来计算Gittins指数，这是经典MAB问题的最优解。通过这个练习，你将亲手实践一种复杂的贝叶斯自适应策略，深入理解如何在积累数据和最大化患者受益之间取得理论上的最优平衡。", "problem": "考虑一个双臂贝叶斯自适应临床试验，每个患者的结果为二元，该试验被建模为一个多臂老虎机（MAB）。每个臂对应一种治疗方法，其成功概率未知，并用 Beta 先验进行建模。设臂 $i$ 的先验为 $\\mathrm{Beta}(a_i,b_i)$，结果建模为 $\\mathrm{Bernoulli}(p_i)$，其中 $p_i$ 未知。每次将患者分配到臂 $i$ 后，根据贝叶斯-伯努利模型的贝叶斯共轭性，若成功则 $a_i$ 加 $1$，若失败则 $b_i$ 加 $1$，从而更新后验分布。未来的奖励以因子 $\\gamma \\in (0,1)$ 进行几何折扣，成功时获得 $1$ 的奖励，失败时获得 $0$ 的奖励。\n\n臂状态 $(a,b)$ 在几何折扣因子 $\\gamma$ 下的 Gittins 指数（GI）是通过一个等效的单臂马尔可夫决策过程（MDP）来定义的。在该 MDP 中，如果决策是停止对该臂进行抽样，则每期可获得一个恒定的补贴 $c$。令 $V_c(a,b)$ 表示从状态 $(a,b)$ 开始的最优折扣价值，其中停止行动会产生每期 $c$ 的即时和永久性奖励，从而得到停止价值 $c/(1-\\gamma)$。对于状态 $(a,b)$ 的继续行动，期望的即时奖励是后验均值 $a/(a+b)$，下一状态以概率 $a/(a+b)$ 变为 $(a+1,b)$，以概率 $b/(a+b)$ 变为 $(a,b+1)$。因此，对于固定的补贴 $c$，贝尔曼最优性方程为\n$$\nV_c(a,b) \\;=\\; \\max\\left\\{\\frac{c}{1-\\gamma},\\; \\frac{a}{a+b} + \\gamma\\left[\\frac{a}{a+b}V_c(a+1,b) + \\frac{b}{a+b}V_c(a,b+1)\\right]\\right\\}。\n$$\nGittins 指数 $\\mathrm{GI}(a,b)$ 是使得在状态 $(a,b)$ 时，停止与继续两种选择达到无差异最优的唯一补贴 $c^*$，即停止变为最优的阈值补贴：\n$$\n\\mathrm{GI}(a,b) \\;=\\; \\inf\\left\\{c \\;:\\; \\frac{c}{1-\\gamma} \\;\\ge\\; \\frac{a}{a+b} + \\gamma\\left[\\frac{a}{a+b}V_c(a+1,b) + \\frac{b}{a+b}V_c(a,b+1)\\right]\\right\\}。\n$$\n该指数能够为下一步的臂分配提供最优策略：在每个决策点，将下一个患者分配给 Gittins 指数较大的臂。\n\n您的任务是实现一个数值算法，通过动态规划和对 $c$ 进行二分查找来近似计算 Beta-伯努利臂的 $\\mathrm{GI}(a,b)$。为了使计算易于处理，对每个臂的未来样本数量使用一个有限的截断深度 $N_{\\max}$，并施加边界条件 $V_c(a',b')=\\frac{c}{1-\\gamma}$，适用于所有满足 $(a'-a)+(b'-b)\\ge N_{\\max}$ 的状态 $(a',b')$。在此截断下，折扣价值的最大误差上限为 $\\gamma^{N_{\\max}}/(1-\\gamma)$，因为每期的奖励最多为 $1$。\n\n算法要求：\n- 实现一个函数，通过在截断的状态空间上进行反向归纳来计算 $V_c(a,b)$，在深度 $N_{\\max}$ 处使用边界条件 $V_c(a',b')=\\frac{c}{1-\\gamma}$。\n- 实现一个在 $c\\in[0,1]$ 上的二分查找，以在代码中指定的容差 $\\varepsilon$ 内找到近似的 Gittins 指数 $\\mathrm{GI}(a,b)$。在每个二分中点，重新计算 $V_c$，并通过比较停止价值 $\\frac{c}{1-\\gamma}$ 和继续价值来确定在 $(a,b)$ 处继续是否为最优。\n- 对于两个臂，计算它们的指数，并选择指数较大的臂进行下一次分配。如果根据舍入规格相等，则选择臂 1 来打破平局。\n\n使用以下参数值测试套件来评估您的实现：\n1. 臂 1：$\\mathrm{Beta}(10,6)$，臂 2：$\\mathrm{Beta}(8,8)$，折扣 $\\gamma=0.95$，截断 $N_{\\max}=200$。\n2. 臂 1：$\\mathrm{Beta}(1,1)$，臂 2：$\\mathrm{Beta}(1,1)$，折扣 $\\gamma=0.95$，截断 $N_{\\max}=200$。\n3. 臂 1：$\\mathrm{Beta}(100,1)$，臂 2：$\\mathrm{Beta}(10,20)$，折扣 $\\gamma=0.95$，截断 $N_{\\max}=200$。\n4. 臂 1：$\\mathrm{Beta}(20,20)$，臂 2：$\\mathrm{Beta}(3,1)$，折扣 $\\gamma=0.90$，截断 $N_{\\max}=200$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔的结果列表。每个测试用例的结果必须是一个包含三项的列表：臂 1 的 Gittins 指数，臂 2 的 Gittins 指数，以及所选臂的编号（$1$ 或 $2$）。指数表示为浮点数，四舍五入到六位小数，所选臂表示为整数。例如，输出格式必须是\n$$\n[\\,[\\text{GI}_1,\\text{GI}_2,\\text{arm}],\\,[\\text{GI}_1,\\text{GI}_2,\\text{arm}],\\,\\dots]\n$$\n其中每个 $\\text{GI}_i$ 都四舍五入到六位小数。除了构成有效列表所必需的结构外，不应打印任何额外的文本或空格。", "solution": "该问题要求为具有 Beta-伯努利后验分布的双臂贝叶斯老虎机计算 Gittins 指数，以决定接下来抽样哪个臂。这是最优序贯决策领域的一个经典问题，Gittins 指数为最大化总折扣期望奖励提供了一个最优策略。\n\n问题的核心是为一个后验成功概率由 $\\mathrm{Beta}(a,b)$ 分布描述的臂计算 Gittins 指数 $\\mathrm{GI}(a,b)$。Gittins 指数是通过一个辅助的单臂马尔可夫决策过程（MDP）来定义的。在这个 MDP 中，每一步我们都可以选择“继续”从该臂抽样，或者永久“停止”。\n\n这个 MDP 的状态由 Beta 分布的参数 $(a,b)$ 给出。\n行动包括：\n1.  **继续**：再次对该臂进行抽样。此行动产生的即时期望奖励等于成功概率的后验均值，即 $\\frac{a}{a+b}$。在观察到结果（成功或失败）后，状态以概率 $\\frac{a}{a+b}$ 转移到 $(a+1,b)$，或以概率 $\\frac{b}{a+b}$ 转移到 $(a,b+1)$。未来的奖励以因子 $\\gamma$ 进行折扣。\n2.  **停止**：停止从此臂抽样。此行动为所有后续时间段提供一个恒定的“补贴”奖励 $c$。此永久性奖励流的总折扣价值为 $\\frac{c}{1-\\gamma}$。\n\n设 $V_c(a,b)$ 为在给定补贴 $c$ 的情况下，从状态 $(a,b)$ 开始的最大总折扣期望奖励。价值函数 $V_c(a,b)$ 必须满足贝尔曼最优性方程，该方程平衡了停止的价值与继续的价值：\n$$\nV_c(a,b) \\;=\\; \\max\\left\\{\\underbrace{\\frac{c}{1-\\gamma}}_{\\text{停止的价值}},\\; \\underbrace{\\frac{a}{a+b} + \\gamma\\left[\\frac{a}{a+b}V_c(a+1,b) + \\frac{b}{a+b}V_c(a,b+1)\\right]}_{\\text{继续的价值}}\\right\\}\n$$\n\nGittins 指数 $\\mathrm{GI}(a,b)$ 被定义为在状态 $(a,b)$ 时，使停止和继续的价值相等的特定补贴值 $c$。它是继续抽样选项的“公平价格”。在数学上，它是满足以下条件的 $c^*$ 值：\n$$\n\\frac{c^*}{1-\\gamma} \\;=\\; \\frac{a}{a+b} + \\gamma\\left[\\frac{a}{a+b}V_{c^*}(a+1,b) + \\frac{b}{a+b}V_{c^*}(a,b+1)\\right]\n$$\n\n为了数值求解此问题，我们采用指定的两部分算法：动态规划和二分查找。\n\n**1. 状态空间截断与动态规划**\n\n状态空间 $(a,b)$ 是无限的。为了使计算易于处理，我们对其进行截断。设臂的初始状态为 $(a_0, b_0)$。我们考虑一个包含 $N_{\\max}$ 个未来样本的有限视界。任何在 $N_{\\max}$ 次或更多次抽样后达到的状态 $(a',b')$，即满足 $(a'-a_0) + (b'-b_0) \\ge N_{\\max}$ 的状态，都被视为终止状态。在这些边界状态下，问题规定了边界条件 $V_c(a',b') = \\frac{c}{1-\\gamma}$。这意味着在视界尽头，我们被迫采取停止行动。\n\n对于一个固定的补贴 $c$，我们可以使用动态规划（特别是反向归纳）来计算这个截断视界内任何状态 $(a,b)$ 的 $V_c(a,b)$。设状态 $(a_0+i, b_0+j)$ 的“深度”为 $n = i+j$。我们先计算深度为 $n=N_{\\max}-1$ 的所有状态的价值 $V_c$，然后是 $n=N_{\\max}-2$，依此类推，直到 $n=0$（初始状态 $(a_0,b_0)$）。\n\n计算深度为 $n$ 的状态 $(a,b)$ 需要深度为 $n+1$ 的状态 $V_c(a+1,b)$ 和 $V_c(a,b+1)$ 的值。反向归纳确保这些值可以从归纳的上一步获得。迭代过程如下：\n- 我们使用一个二维数组 `V_table[i][j]` 来存储价值 $V_c(a_0+i, b_0+j)$。\n- 我们将 $n$ 从 $N_{\\max}-1$ 迭代到 $0$。\n- 对于每个 $n$，我们遍历所有满足 $i+j=n$ 的有效状态 $(a_0+i, b_0+j)$。\n- 对于每个这样的状态，我们使用深度为 $n+1$ 的状态的已知值（来自 `V_table` 或边界值 $\\frac{c}{1-\\gamma}$）来计算其继续价值，然后应用贝尔曼方程中的 `max` 算子来找到 `V_table[i][j]`。\n\n**2. 用于 Gittins 指数的二分查找**\n\nGittins 指数是使得在根状态 $(a_0, b_0)$ 时，停止和继续变得无差异的 $c$ 值。我们可以使用二分查找在区间 $[0,1]$ 上找到这个值。\n让我们定义一个关于 $c$ 的函数：\n$$\nf(c) = \\left( \\frac{a_0}{a_0+b_0} + \\gamma\\left[\\frac{a_0}{a_0+b_0}V_c(a_0+1,b_0) + \\frac{b_0}{a_0+b_0}V_c(a_0,b_0+1)\\right] \\right) - \\frac{c}{1-\\gamma}\n$$\n我们正在寻找使 $f(c^*) = 0$ 的根 $c^*$。可以证明函数 $f(c)$ 关于 $c$ 是单调递减的，这使得二分法成为一个合适的方法。\n\n二分查找算法如下：\n- 初始化 $c$ 的搜索区间，例如 $[c_{low}, c_{high}] = [0,1]$。\n- 重复此过程，直到区间宽度 $(c_{high}-c_{low})$ 小于指定的容差 $\\varepsilon$：\n    a. 选择中点 $c_{mid} = (c_{low} + c_{high})/2$。\n    b. 使用上述动态规划方法计算价值函数 $V_{c_{mid}}$ 的必要值。\n    c. 使用 $V_{c_{mid}}$ 评估根状态 $(a_0, b_0)$ 的继续价值。设其为 $\\text{cont\\_val}$。\n    d. 将 $\\text{cont\\_val}$ 与停止价值 $\\text{stop\\_val} = c_{mid}/(1-\\gamma)$ 进行比较。\n    e. 如果 $\\text{cont\\_val} > \\text{stop\\_val}$，意味着补贴 $c_{mid}$ 太低，不足以使停止具有吸引力。真正的 Gittins 指数必须更高。我们更新 $c_{low} = c_{mid}$。\n    f. 否则，如果 $\\text{cont\\_val} \\le \\text{stop\\_val}$，则补贴足够高（或恰好合适）。真正的 Gittins 指数必须在下半部分。我们更新 $c_{high} = c_{mid}$。\n- Gittins 指数的近似值是搜索区间的最终中点。\n\n以下是实现该算法的 Python 代码：\n\n```python\nimport numpy as np\n\ndef compute_gittins_index(a0, b0, gamma, N_max, epsilon):\n    \"\"\"\n    Computes the Gittins index for a Beta-Bernoulli arm using dynamic programming\n    and bisection search.\n\n    Args:\n        a0 (float): Initial alpha parameter of the Beta prior.\n        b0 (float): Initial beta parameter of the Beta prior.\n        gamma (float): Discount factor.\n        N_max (int): Truncation depth for the state space.\n        epsilon (float): Tolerance for the bisection search.\n\n    Returns:\n        float: The approximated Gittins index.\n    \"\"\"\n    if a0 = 0 or b0 = 0:\n        raise ValueError(\"Beta parameters a and b must be positive.\")\n\n    c_low, c_high = 0.0, 1.0\n\n    # V_table[i][j] will store V_c(a0+i, b0+j)\n    # The maximum index required is N_max, so size is N_max+1.\n    V_table = np.zeros((N_max + 1, N_max + 1))\n\n    while c_high - c_low > epsilon:\n        c_mid = (c_low + c_high) / 2.0\n        stop_val = c_mid / (1.0 - gamma)\n\n        # Backward induction using dynamic programming to compute V_c_mid\n        # n is the number of future samples, from N_max-1 down to 0\n        for n in range(N_max - 1, -1, -1):\n            # i is the number of future successes\n            for i in range(n + 1):\n                j = n - i  # j is the number of future failures\n                \n                a = a0 + i\n                b = b0 + j\n\n                # Get V for next states (at depth n+1)\n                # Success state: a0+(i+1), b0+j\n                # Failure state: a0+i, b0+(j+1)\n                \n                # Check if the next states are on or past the boundary depth N_max\n                if (i + 1) + j >= N_max:\n                    V_succ = stop_val\n                else:\n                    # Value was computed in the (n+1) iteration of the outer loop\n                    V_succ = V_table[i + 1, j]\n                \n                if i + (j + 1) >= N_max:\n                    V_fail = stop_val\n                else:\n                    # Value was computed in the (n+1) iteration of the outer loop\n                    V_fail = V_table[i, j + 1]\n\n                p = a / (a + b)\n                \n                continuation_value = p + gamma * (p * V_succ + (1.0 - p) * V_fail)\n                \n                V_table[i, j] = max(stop_val, continuation_value)\n        \n        # After filling the V_table for c_mid, check the condition at the root state (a0, b0)\n        p0 = a0 / (a0 + b0)\n\n        # Get values for next states from root\n        if 1 >= N_max:\n            V_succ_root = stop_val\n            V_fail_root = stop_val\n        else:\n            V_succ_root = V_table[1, 0]\n            V_fail_root = V_table[0, 1]\n            \n        root_continuation_value = p0 + gamma * (p0 * V_succ_root + (1.0 - p0) * V_fail_root)\n\n        if root_continuation_value > stop_val:\n            c_low = c_mid\n        else:\n            c_high = c_mid\n            \n    return (c_low + c_high) / 2.0\n```", "answer": "$$\n\\boxed{\\text{[[0.630043, 0.518607, 1], [0.655959, 0.655959, 1], [0.990099, 0.334185, 1], [0.500000, 0.771970, 2]]}}\n$$", "id": "4950423"}]}