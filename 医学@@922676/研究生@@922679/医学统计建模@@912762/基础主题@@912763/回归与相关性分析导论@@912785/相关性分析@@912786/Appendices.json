{"hands_on_practices": [{"introduction": "医学数据往往不完全满足线性或正态分布的假设，例如我们可能遇到序数等级量表或偏态分布的生物标志物。Spearman秩相关系数提供了一种稳健的非参数方法来衡量单调关联，使其成为一个至关重要的工具。本练习将指导您手动计算Spearman相关系数 $\\rho_s$，包括处理数据中常见“结”（tied ranks）的关键步骤，以巩固您对这一基本技术的理解。[@problem_id:4957615]", "problem": "一个风湿病学研究团队进行了一项试点研究，旨在评估血清C反应蛋白（CRP，单位：毫克/升）与临床医生评定的疾病活动评分（DAS）之间的单调关联。CRP是一种炎症生物标志物，DAS是衡量疾病严重程度的序数指标。样本包含 $n=12$ 名患者，其观测数据对为 $(x_i, y_i)$，其中 $x_i$ 是CRP值，$y_i$ 是DAS值：\n- 患者 $1$：$(x_1, y_1) = (4.2, 2)$\n- 患者 $2$：$(x_2, y_2) = (7.8, 3)$\n- 患者 $3$：$(x_3, y_3) = (4.2, 2)$\n- 患者 $4$：$(x_4, y_4) = (12.5, 5)$\n- 患者 $5$：$(x_5, y_5) = (9.0, 5)$\n- 患者 $6$：$(x_6, y_6) = (7.8, 3)$\n- 患者 $7$：$(x_7, y_7) = (20.0, 7)$\n- 患者 $8$：$(x_8, y_8) = (3.1, 1)$\n- 患者 $9$：$(x_9, y_9) = (15.4, 6)$\n- 患者 $10$：$(x_{10}, y_{10}) = (20.0, 7)$\n- 患者 $11$：$(x_{11}, y_{11}) = (9.0, 4)$\n- 患者 $12$：$(x_{12}, y_{12}) = (11.2, 4)$\n\n使用Spearman等级相关的非参数定义，计算这12名患者的CRP和DAS之间的Spearman等级相关系数，并通过赋予平均秩次来处理相同值。将最终答案四舍五入至四位有效数字。最终答案是无量纲的，并且必须以小数形式表示。", "solution": "该问题要求对一个给定的包含 $n=12$ 对观测值的数据集，计算其Spearman等级相关系数，记为 $\\rho_s$。Spearman相关是一种单调关联的非参数度量，其定义为基于数据秩次计算的Pearson相关系数。对于两个变量 $X$ 和 $Y$，其对应的秩次为 $R(X)$ 和 $R(Y)$，$\\rho_s$ 的计算公式为：\n$$ \\rho_s = \\frac{\\sum_{i=1}^{n} (R(x_i) - \\bar{R}_x)(R(y_i) - \\bar{R}_y)}{\\sqrt{\\sum_{i=1}^{n} (R(x_i) - \\bar{R}_x)^2 \\sum_{i=1}^{n} (R(y_i) - \\bar{R}_y)^2}} $$\n其中，$R(x_i)$ 和 $R(y_i)$ 分别是第 $i$ 个观测值 $x_i$ 和 $y_i$ 的秩次，而 $\\bar{R}_x$ 和 $\\bar{R}_y$ 是平均秩次。问题指明，应通过赋予平均秩次来处理相同值。\n\n第一步是为两个变量，即C反应蛋白（CRP），$x$，和疾病活动评分（DAS），$y$，的数据进行排序。\n\n**步骤1：对CRP数据 ($x_i$) 进行排序**\n观测到的CRP值为：\n$4.2, 7.8, 4.2, 12.5, 9.0, 7.8, 20.0, 3.1, 15.4, 20.0, 9.0, 11.2$。\n将这些值按升序排列：\n$3.1, 4.2, 4.2, 7.8, 7.8, 9.0, 9.0, 11.2, 12.5, 15.4, 20.0, 20.0$。\n我们分配秩次，对相同的值使用平均秩次（midrank）：\n- $3.1$：秩次为 $1$\n- $4.2$ (2个值)：秩次为 $2, 3$。平均秩次为 $\\frac{2+3}{2} = 2.5$。\n- $7.8$ (2个值)：秩次为 $4, 5$。平均秩次为 $\\frac{4+5}{2} = 4.5$。\n- $9.0$ (2个值)：秩次为 $6, 7$。平均秩次为 $\\frac{6+7}{2} = 6.5$。\n- $11.2$：秩次为 $8$\n- $12.5$：秩次为 $9$\n- $15.4$：秩次为 $10$\n- $20.0$ (2个值)：秩次为 $11, 12$。平均秩次为 $\\frac{11+12}{2} = 11.5$。\n\n**步骤2：对DAS数据 ($y_i$) 进行排序**\n观测到的DAS值为：\n$2, 3, 2, 5, 5, 3, 7, 1, 6, 7, 4, 4$。\n将这些值按升序排列：\n$1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 7$。\n我们为相同的值分配平均秩次：\n- $1$：秩次为 $1$\n- $2$ (2个值)：秩次为 $2, 3$。平均秩次为 $\\frac{2+3}{2} = 2.5$。\n- $3$ (2个值)：秩次为 $4, 5$。平均秩次为 $\\frac{4+5}{2} = 4.5$。\n- $4$ (2个值)：秩次为 $6, 7$。平均秩次为 $\\frac{6+7}{2} = 6.5$。\n- $5$ (2个值)：秩次为 $8, 9$。平均秩次为 $\\frac{8+9}{2} = 8.5$。\n- $6$：秩次为 $10$\n- $7$ (2个值)：秩次为 $11, 12$。平均秩次为 $\\frac{11+12}{2} = 11.5$。\n\n**步骤3：为相关公式计算总和**\n对于样本量为 $n=12$ 的情况，从 $1$ 到 $12$ 的秩次总和为 $\\frac{12(12+1)}{2} = 78$。两个变量的平均秩次均为 $\\bar{R}_x = \\bar{R}_y = \\frac{78}{12} = 6.5$。\n\n我们现在构建一个表格，以计算与平均秩次偏差的平方和与交叉乘积和。令 $S_{xx} = \\sum_{i=1}^{n} (R(x_i) - \\bar{R}_x)^2$, $S_{yy} = \\sum_{i=1}^{n} (R(y_i) - \\bar{R}_y)^2$, 及 $S_{xy} = \\sum_{i=1}^{n} (R(x_i) - \\bar{R}_x)(R(y_i) - \\bar{R}_y)$。下表详细列出了这些计算。\n\n| 患者 $i$ | $x_i$ | $y_i$ | $R(x_i)$ | $R(y_i)$ | $R(x_i) - 6.5$ | $R(y_i) - 6.5$ | $(R(x_i) - 6.5)(R(y_i) - 6.5)$ | $(R(x_i) - 6.5)^2$ | $(R(y_i) - 6.5)^2$ |\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n| $1$ | $4.2$ | $2$ | $2.5$ | $2.5$ | $-4.0$ | $-4.0$ | $16.00$ | $16.00$ | $16.00$ |\n| $2$ | $7.8$ | $3$ | $4.5$ | $4.5$ | $-2.0$ | $-2.0$ | $4.00$ | $4.00$ | $4.00$ |\n| $3$ | $4.2$ | $2$ | $2.5$ | $2.5$ | $-4.0$ | $-4.0$ | $16.00$ | $16.00$ | $16.00$ |\n| $4$ | $12.5$ | $5$ | $9.0$ | $8.5$ | $2.5$ | $2.0$ | $5.00$ | $6.25$ | $4.00$ |\n| $5$ | $9.0$ | $5$ | $6.5$ | $8.5$ | $0.0$ | $2.0$ | $0.00$ | $0.00$ | $4.00$ |\n| $6$ | $7.8$ | $3$ | $4.5$ | $4.5$ | $-2.0$ | $-2.0$ | $4.00$ | $4.00$ | $4.00$ |\n| $7$ | $20.0$ | $7$ | $11.5$ | $11.5$ | $5.0$ | $5.0$ | $25.00$ | $25.00$ | $25.00$ |\n| $8$ | $3.1$ | $1$ | $1.0$ | $1.0$ | $-5.5$ | $-5.5$ | $30.25$ | $30.25$ | $30.25$ |\n| $9$ | $15.4$ | $6$ | $10.0$ | $10.0$ | $3.5$ | $3.5$ | $12.25$ | $12.25$ | $12.25$ |\n| $10$| $20.0$ | $7$ | $11.5$ | $11.5$ | $5.0$ | $5.0$ | $25.00$ | $25.00$ | $25.00$ |\n| $11$| $9.0$ | $4$ | $6.5$ | $6.5$ | $0.0$ | $0.0$ | $0.00$ | $0.00$ | $0.00$ |\n| $12$| $11.2$ | $4$ | $8.0$ | $6.5$ | $1.5$ | $0.0$ | $0.00$ | $2.25$ | $0.00$ |\n| **总和** | | | | | $0.0$ | $0.0$ | $\\mathbf{137.50}$ | $\\mathbf{141.00}$ | $\\mathbf{140.50}$ |\n\n从表格中，我们得到所需的总和：\n$S_{xy} = 137.5$\n$S_{xx} = 141.0$\n$S_{yy} = 140.5$\n\n**步骤4：最终计算**\n将这些值代入 $\\rho_s$ 的公式中：\n$$ \\rho_s = \\frac{S_{xy}}{\\sqrt{S_{xx} S_{yy}}} = \\frac{137.5}{\\sqrt{141.0 \\times 140.5}} $$\n现在，我们计算分母中的乘积：\n$$ 141.0 \\times 140.5 = 19810.5 $$\n然后，我们求平方根：\n$$ \\sqrt{19810.5} \\approx 140.749778 $$\n最后，我们计算该系数：\n$$ \\rho_s = \\frac{137.5}{140.749778} \\approx 0.976915 $$\n问题要求将答案四舍五入到四位有效数字。\n$$ \\rho_s \\approx 0.9769 $$\n这个高的正值表明，在该患者样本中，血清CRP水平与临床医生评定的疾病活动评分之间存在非常强的正向单调关联。", "answer": "$$\\boxed{0.9769}$$", "id": "4957615"}, {"introduction": "在医学研究中，两个变量之间的相关性很少是孤立存在的。由于其他因素（即“混杂因素”）的影响，我们观测到的关联可能具有误导性。本练习旨在探讨边际相关（总体关联）与条件相关（在控制混杂因素后的关联）之间的关键区别。通过推导和模拟这种关系，您将深刻地、定量地理解混杂如何能产生虚假关联，甚至逆转真实效应的方向——这一现象与辛普森悖论（Simpson's paradox）密切相关。[@problem_id:4957630]", "problem": "考虑一个常用于医学统计建模中研究混杂因素的程式化线性高斯因果模型。令 $X$ 表示一个连续暴露变量（例如，某生物标志物水平），$Y$ 表示一个连续结局变量（例如，临床风险评分），$Z$ 表示一个连续混杂因素（例如，疾病严重程度）。数据生成机制由以下结构方程指定：\n$$\nX \\;=\\; a\\,Z \\;+\\; \\varepsilon_x,\\qquad Y \\;=\\; b\\,X \\;+\\; c\\,Z \\;+\\; \\varepsilon_y,\n$$\n其中 $Z \\sim \\mathcal{N}(0,\\sigma_Z^2)$、$\\varepsilon_x \\sim \\mathcal{N}(0,\\sigma_x^2)$ 和 $\\varepsilon_y \\sim \\mathcal{N}(0,\\sigma_y^2)$ 是相互独立的随机变量。所有参数 $a$、$b$、$c$、$\\sigma_Z$、$\\sigma_x$ 和 $\\sigma_y$ 均为实值，且 $\\sigma_Z>0$、$\\sigma_x>0$ 和 $\\sigma_y>0$。任务是对比 $X$ 和 $Y$ 之间的边际相关性与给定 $Z$ 时 $X$ 和 $Y$ 之间的条件相关性，并识别由混杂引起的符号不一致情况。\n\n仅从核心概率定义出发，推导计算以下总体量所需的表达式：\n- 边际协方差 $\\mathrm{Cov}(X,Y)$ 和边际方差 $\\mathrm{Var}(X)$、$\\mathrm{Var}(Y)$，根据期望和独立性的法则，其中 $\\mathrm{Cov}(U,V) = \\mathbb{E}\\!\\left[(U-\\mathbb{E}[U])(V-\\mathbb{E}[V])\\right]$ 且 $\\mathrm{Var}(U)=\\mathrm{Cov}(U,U)$。\n- 边际相关系数 $\\rho_{XY} = \\dfrac{\\mathrm{Cov}(X,Y)}{\\sqrt{\\mathrm{Var}(X)\\,\\mathrm{Var}(Y)}}$。\n- 条件期望 $\\mathbb{E}[X\\mid Z]$ 和 $\\mathbb{E}[Y\\mid Z]$ 以及相应的残差 $R_X = X - \\mathbb{E}[X\\mid Z]$ 和 $R_Y = Y - \\mathbb{E}[Y\\mid Z]$。\n- 条件相关系数 $\\rho_{XY\\mid Z}$，定义为残差之间的相关系数，即 $\\rho_{XY\\mid Z} = \\dfrac{\\mathrm{Cov}(R_X,R_Y)}{\\sqrt{\\mathrm{Var}(R_X)\\,\\mathrm{Var}(R_Y)}}$。\n\n您不得调用或引用除上述核心定义之外的任何预封装“快捷”公式，并且必须仅使用期望的线性性质、噪声项的独立性以及正态性假设进行代数简化。最终公式应仅用参数 $a$、$b$、$c$、$\\sigma_Z$、$\\sigma_x$ 和 $\\sigma_y$ 表示，并且不得依赖于任何样本大小。\n\n您的程序必须精确实现这些推导出的公式，并为以下测试套件中的每组参数计算三个输出：边际相关系数 $\\rho_{XY}$、条件相关系数 $\\rho_{XY\\mid Z}$ 以及一个表示符号不一致的布尔指示符 $D$，其定义为：\n$$\nD \\;=\\; \\big(\\mathrm{sign}(\\rho_{XY}) \\neq \\mathrm{sign}(\\rho_{XY\\mid Z})\\big),\n$$\n其中 $\\mathrm{sign}(u) \\in \\{-1,0,+1\\}$ 是标准符号函数。为保证数值稳定性，在应用符号函数时，将任何满足 $|u| < 10^{-12}$ 的实数 $u$ 视为 $0$。\n\n测试套件参数集（每组指定 $(a,b,c,\\sigma_Z,\\sigma_x,\\sigma_y)$）：\n1. 中度混杂的标准情形：$a=0.8$，$b=0.6$，$c=0.3$，$\\sigma_Z=1.5$，$\\sigma_x=1.2$，$\\sigma_y=0.9$。\n2. 无混杂基线：$a=0$，$b=0.5$，$c=0$，$\\sigma_Z=2.0$，$\\sigma_x=1.0$，$\\sigma_y=1.0$。\n3. 纯粹混杂造成的伪关联：$a=1.0$，$b=0$，$c=0.8$，$\\sigma_Z=1.0$，$\\sigma_x=1.0$，$\\sigma_y=1.0$。\n4. 混杂导致的符号反转（辛普森式行为）：$a=2.0$，$b=0.2$，$c=-1.5$，$\\sigma_Z=2.0$，$\\sigma_x=0.7$，$\\sigma_y=0.5$。\n5. 直接效应与混杂效应方向相反：$a=1.0$，$b=-0.4$，$c=1.0$，$\\sigma_Z=1.5$，$\\sigma_x=0.8$，$\\sigma_y=0.8$。\n\n要求的输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。\n- 每个测试用例的结果必须是一个三元列表 $[\\rho_{XY},\\rho_{XY\\mid Z},D]$，其中前两个元素是四舍五入到六位小数的实数（以小数形式，而非百分比）。\n- 因此，最终输出应如下所示：\n$$\n\\big[ [r_{1},q_{1},d_{1}], [r_{2},q_{2},d_{2}], [r_{3},q_{3},d_{3}], [r_{4},q_{4},d_{4}], [r_{5},q_{5},d_{5}] \\big],\n$$\n不含任何额外文本。\n\n您的解决方案必须如上所述普遍适用，且不得依赖任何外部数据或输入。本问题不涉及任何物理单位或角度单位。重点完全在于由指定的线性高斯模型所蕴含的总体层面的相关性。", "solution": "该问题具有科学依据、定义明确且客观。它提出了一个统计建模和因果推断中的标准任务，并提供了所有必要的参数和定义。该问题是有效的。\n\n我们将根据给定的结构方程和概率假设，逐步推导所需的量。\n\n结构方程为：\n$$\nX \\;=\\; a\\,Z \\;+\\; \\varepsilon_x\n$$\n$$\nY \\;=\\; b\\,X \\;+\\; c\\,Z \\;+\\; \\varepsilon_y\n$$\n外生变量相互独立，其分布为 $Z \\sim \\mathcal{N}(0,\\sigma_Z^2)$、$\\varepsilon_x \\sim \\mathcal{N}(0,\\sigma_x^2)$ 和 $\\varepsilon_y \\sim \\mathcal{N}(0,\\sigma_y^2)$。\n\n**1. 边际矩和相关性的推导**\n\n首先，我们确定 $X$ 和 $Y$ 的期望。利用期望的线性性质以及 $\\mathbb{E}[Z]=0$、$\\mathbb{E}[\\varepsilon_x]=0$ 和 $\\mathbb{E}[\\varepsilon_y]=0$ 的事实：\n$$\n\\mathbb{E}[X] \\;=\\; \\mathbb{E}[a\\,Z + \\varepsilon_x] \\;=\\; a\\,\\mathbb{E}[Z] + \\mathbb{E}[\\varepsilon_x] \\;=\\; a(0) + 0 \\;=\\; 0\n$$\n为求 $\\mathbb{E}[Y]$，我们首先将 $X$ 的表达式代入 $Y$ 的方程中：\n$$\nY \\;=\\; b(a\\,Z + \\varepsilon_x) + c\\,Z + \\varepsilon_y \\;=\\; (ab+c)Z + b\\varepsilon_x + \\varepsilon_y\n$$\n现在，我们求期望：\n$$\n\\mathbb{E}[Y] \\;=\\; \\mathbb{E}[(ab+c)Z + b\\varepsilon_x + \\varepsilon_y] \\;=\\; (ab+c)\\mathbb{E}[Z] + b\\mathbb{E}[\\varepsilon_x] + \\mathbb{E}[\\varepsilon_y] \\;=\\; 0\n$$\n由于两个均值都为 $0$，方差为 $\\mathrm{Var}(U) = \\mathbb{E}[U^2]$，协方差为 $\\mathrm{Cov}(U,V) = \\mathbb{E}[UV]$。\n\n接下来，我们推导方差。对于 $\\mathrm{Var}(X)$，我们使用独立变量 $U_1, U_2$ 的性质 $\\mathrm{Var}(k_1 U_1 + k_2 U_2) = k_1^2 \\mathrm{Var}(U_1) + k_2^2 \\mathrm{Var}(U_2)$。由于 $Z$ 和 $\\varepsilon_x$ 是独立的：\n$$\n\\mathrm{Var}(X) \\;=\\; \\mathrm{Var}(a\\,Z + \\varepsilon_x) \\;=\\; a^2\\mathrm{Var}(Z) + \\mathrm{Var}(\\varepsilon_x) \\;=\\; a^2\\sigma_Z^2 + \\sigma_x^2\n$$\n类似地，对于 $\\mathrm{Var}(Y)$，使用表达式 $Y = (ab+c)Z + b\\varepsilon_x + \\varepsilon_y$ 以及 $Z, \\varepsilon_x, \\varepsilon_y$ 的相互独立性：\n$$\n\\mathrm{Var}(Y) \\;=\\; \\mathrm{Var}((ab+c)Z + b\\varepsilon_x + \\varepsilon_y) \\;=\\; (ab+c)^2\\mathrm{Var}(Z) + b^2\\mathrm{Var}(\\varepsilon_x) + \\mathrm{Var}(\\varepsilon_y)\n$$\n$$\n\\mathrm{Var}(Y) \\;=\\; (ab+c)^2\\sigma_Z^2 + b^2\\sigma_x^2 + \\sigma_y^2\n$$\n现在，我们推导协方差 $\\mathrm{Cov}(X,Y)$。由于 $\\mathbb{E}[X]=0$ 和 $\\mathbb{E}[Y]=0$：\n$$\n\\mathrm{Cov}(X,Y) \\;=\\; \\mathbb{E}[(X-\\mathbb{E}[X])(Y-\\mathbb{E}[Y])] \\;=\\; \\mathbb{E}[XY]\n$$\n代入 $X$ 和 $Y$ 的表达式：\n$$\n\\mathrm{Cov}(X,Y) \\;=\\; \\mathbb{E}[(aZ + \\varepsilon_x)((ab+c)Z + b\\varepsilon_x + \\varepsilon_y)]\n$$\n展开乘积：\n$$\n\\mathrm{Cov}(X,Y) \\;=\\; \\mathbb{E}[a(ab+c)Z^2 + abZ\\varepsilon_x + aZ\\varepsilon_y + (ab+c)\\varepsilon_x Z + b\\varepsilon_x^2 + \\varepsilon_x\\varepsilon_y]\n$$\n根据期望的线性性质和相互独立性，所有交叉乘积项的期望均为 $0$（例如，$\\mathbb{E}[Z\\varepsilon_x] = \\mathbb{E}[Z]\\mathbb{E}[\\varepsilon_x] = 0$）。剩下的项为：\n$$\n\\mathrm{Cov}(X,Y) \\;=\\; a(ab+c)\\mathbb{E}[Z^2] + b\\mathbb{E}[\\varepsilon_x^2]\n$$\n由于 $\\mathbb{E}[Z^2]=\\mathrm{Var}(Z)=\\sigma_Z^2$ 且 $\\mathbb{E}[\\varepsilon_x^2]=\\mathrm{Var}(\\varepsilon_x)=\\sigma_x^2$：\n$$\n\\mathrm{Cov}(X,Y) \\;=\\; a(ab+c)\\sigma_Z^2 + b\\sigma_x^2 \\;=\\; (a^2b + ac)\\sigma_Z^2 + b\\sigma_x^2\n$$\n边际相关系数 $\\rho_{XY}$ 则由下式给出：\n$$\n\\rho_{XY} = \\frac{\\mathrm{Cov}(X,Y)}{\\sqrt{\\mathrm{Var}(X)\\,\\mathrm{Var}(Y)}} = \\frac{(a^2b + ac)\\sigma_Z^2 + b\\sigma_x^2}{\\sqrt{(a^2\\sigma_Z^2 + \\sigma_x^2)((ab+c)^2\\sigma_Z^2 + b^2\\sigma_x^2 + \\sigma_y^2)}}\n$$\n\n**2. 条件矩和相关性的推导**\n\n我们首先求条件期望 $\\mathbb{E}[X|Z]$ 和 $\\mathbb{E}[Y|Z]$。\n$$\n\\mathbb{E}[X \\mid Z=z] \\;=\\; \\mathbb{E}[aZ + \\varepsilon_x \\mid Z=z] \\;=\\; \\mathbb{E}[az + \\varepsilon_x]\n$$\n因为 $\\varepsilon_x$ 与 $Z$ 独立，所以 $\\mathbb{E}[\\varepsilon_x \\mid Z=z] = \\mathbb{E}[\\varepsilon_x] = 0$。\n$$\n\\mathbb{E}[X \\mid Z=z] \\;=\\; az + \\mathbb{E}[\\varepsilon_x] \\;=\\; az\n$$\n因此，作为随机变量，$\\mathbb{E}[X \\mid Z] = aZ$。\n\n对于 $Y$，我们使用全期望定律：\n$$\n\\mathbb{E}[Y \\mid Z=z] \\;=\\; \\mathbb{E}[bX+cZ+\\varepsilon_y \\mid Z=z] \\;=\\; b\\mathbb{E}[X \\mid Z=z] + c\\mathbb{E}[Z \\mid Z=z] + \\mathbb{E}[\\varepsilon_y \\mid Z=z]\n$$\n使用 $\\mathbb{E}[X \\mid Z=z]=az$、$\\mathbb{E}[Z \\mid Z=z]=z$ 和 $\\mathbb{E}[\\varepsilon_y \\mid Z=z]=\\mathbb{E}[\\varepsilon_y]=0$（根据独立性）：\n$$\n\\mathbb{E}[Y \\mid Z=z] \\;=\\; b(az) + cz + 0 \\;=\\; (ab+c)z\n$$\n作为随机变量，$\\mathbb{E}[Y \\mid Z] = (ab+c)Z$。\n\n接下来，我们定义残差 $R_X = X - \\mathbb{E}[X\\mid Z]$ 和 $R_Y = Y - \\mathbb{E}[Y\\mid Z]$。\n$$\nR_X \\;=\\; (aZ + \\varepsilon_x) - aZ \\;=\\; \\varepsilon_x\n$$\n为求 $R_Y$，我们使用 $Y$ 的代入形式：\n$$\nR_Y \\;=\\; ((ab+c)Z + b\\varepsilon_x + \\varepsilon_y) - (ab+c)Z \\;=\\; b\\varepsilon_x + \\varepsilon_y\n$$\n条件相关系数 $\\rho_{XY\\mid Z}$ 是这些残差之间的相关系数。我们计算它们的矩。由于 $\\mathbb{E}[\\varepsilon_x]=0$ 和 $\\mathbb{E}[\\varepsilon_y]=0$，我们有 $\\mathbb{E}[R_X]=0$ 和 $\\mathbb{E}[R_Y]=0$。\n方差为：\n$$\n\\mathrm{Var}(R_X) \\;=\\; \\mathrm{Var}(\\varepsilon_x) \\;=\\; \\sigma_x^2\n$$\n$$\n\\mathrm{Var}(R_Y) \\;=\\; \\mathrm{Var}(b\\varepsilon_x + \\varepsilon_y) \\;=\\; b^2\\mathrm{Var}(\\varepsilon_x) + \\mathrm{Var}(\\varepsilon_y) \\;=\\; b^2\\sigma_x^2 + \\sigma_y^2\n$$\n协方差为：\n$$\n\\mathrm{Cov}(R_X, R_Y) \\;=\\; \\mathbb{E}[R_X R_Y] \\;=\\; \\mathbb{E}[\\varepsilon_x(b\\varepsilon_x + \\varepsilon_y)] \\;=\\; \\mathbb{E}[b\\varepsilon_x^2 + \\varepsilon_x\\varepsilon_y]\n$$\n$$\n\\mathrm{Cov}(R_X, R_Y) \\;=\\; b\\mathbb{E}[\\varepsilon_x^2] + \\mathbb{E}[\\varepsilon_x\\varepsilon_y] \\;=\\; b\\sigma_x^2 + 0 \\;=\\; b\\sigma_x^2\n$$\n最后，条件相关系数 $\\rho_{XY\\mid Z}$ 为：\n$$\n\\rho_{XY\\mid Z} = \\frac{\\mathrm{Cov}(R_X,R_Y)}{\\sqrt{\\mathrm{Var}(R_X)\\,\\mathrm{Var}(R_Y)}} = \\frac{b\\sigma_x^2}{\\sqrt{\\sigma_x^2 (b^2\\sigma_x^2 + \\sigma_y^2)}}\n$$\n可简化为：\n$$\n\\rho_{XY\\mid Z} = \\frac{b\\sigma_x}{\\sqrt{b^2\\sigma_x^2 + \\sigma_y^2}}\n$$\n此表达式捕捉了不受 $Z$ 调节的 $X$ 和 $Y$ 之间的关联。它的符号完全由 $b$ 的符号决定，因为所有其他参数都为正。相比之下，$\\rho_{XY}$ 的符号取决于项 $(a^2b + ac)\\sigma_Z^2 + b\\sigma_x^2 = ac\\sigma_Z^2 + b(a^2\\sigma_Z^2 + \\sigma_x^2)$，其中 $ac\\sigma_Z^2$ 项代表混杂路径。当这个混杂项足够大且与直接效应项的符号相反时，就会发生符号不一致。\n\n**用于实现的公式摘要：**\n- $\\rho_{XY} = \\frac{(a^2b + ac)\\sigma_Z^2 + b\\sigma_x^2}{\\sqrt{(a^2\\sigma_Z^2 + \\sigma_x^2)((ab+c)^2\\sigma_Z^2 + b^2\\sigma_x^2 + \\sigma_y^2)}}$\n- $\\rho_{XY\\mid Z} = \\frac{b\\sigma_x}{\\sqrt{b^2\\sigma_x^2 + \\sigma_y^2}}}$\n- $D = (\\mathrm{sign}(\\rho_{XY}) \\neq \\mathrm{sign}(\\rho_{XY\\mid Z}))$, 其中对于 $|u| < 10^{-12}$，$\\mathrm{sign}(u)=0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed for this problem.\n\ndef solve():\n    \"\"\"\n    Derives and computes marginal and conditional correlations for a linear-Gaussian\n    causal model to identify confounding-induced sign disagreements.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of\n    # (a, b, c, sigma_Z, sigma_x, sigma_y).\n    test_cases = [\n        # 1. Happy path with moderate confounding\n        (0.8, 0.6, 0.3, 1.5, 1.2, 0.9),\n        # 2. No confounding baseline\n        (0.0, 0.5, 0.0, 2.0, 1.0, 1.0),\n        # 3. Pure confounding creating spurious association\n        (1.0, 0.0, 0.8, 1.0, 1.0, 1.0),\n        # 4. Confounding-induced sign reversal (Simpson-type behavior)\n        (2.0, 0.2, -1.5, 2.0, 0.7, 0.5),\n        # 5. Opposing direct effect and confounding\n        (1.0, -0.4, 1.0, 1.5, 0.8, 0.8),\n    ]\n\n    results = []\n    \n    def custom_sign(u, tol=1e-12):\n        \"\"\"\n        Custom sign function with a tolerance for zero.\n        Returns -1, 0, or 1.\n        \"\"\"\n        if abs(u)  tol:\n            return 0\n        return np.sign(u)\n\n    for case in test_cases:\n        a, b, c, sigma_z, sigma_x, sigma_y = case\n        \n        # Variances are squared standard deviations\n        var_z = sigma_z**2\n        var_x_noise = sigma_x**2\n        var_y_noise = sigma_y**2\n        \n        # --- Marginal Correlation Calculation ---\n        \n        # Calculate Var(X)\n        var_x = a**2 * var_z + var_x_noise\n        \n        # Calculate Var(Y)\n        var_y = (a * b + c)**2 * var_z + b**2 * var_x_noise + var_y_noise\n        \n        # Calculate Cov(X,Y)\n        cov_xy = (a**2 * b + a * c) * var_z + b * var_x_noise\n        \n        # Calculate marginal correlation rho_XY\n        # Denominator is guaranteed to be positive as variances are sums of squares\n        # and sigma_z, sigma_x, sigma_y are all > 0.\n        rho_xy = cov_xy / np.sqrt(var_x * var_y)\n        \n        # --- Conditional Correlation Calculation ---\n        \n        # Calculate conditional correlation rho_XY|Z\n        # Numerator is b * Var(residual_X) = b * sigma_x^2\n        # Denominator is sqrt(Var(residual_X) * Var(residual_Y))\n        # Var(residual_X) = sigma_x^2\n        # Var(residual_Y) = b^2 * sigma_x^2 + sigma_y^2\n        # Simplified formula: (b * sigma_x) / sqrt(b^2 * sigma_x^2 + sigma_y^2)\n        # Note: if b=0, rho_xy_cond_z is 0 as it should be.\n        # The denominator cannot be zero because sigma_y > 0.\n        denominator_cond = np.sqrt(b**2 * var_x_noise + var_y_noise)\n        if denominator_cond == 0:\n             # This case is avoided by problem constraints (sigma_y > 0)\n             # but is good practice to handle.\n             rho_xy_cond_z = 0.0\n        else:\n             rho_xy_cond_z = (b * sigma_x) / np.sqrt(b**2 * var_x_noise + var_y_noise)\n\n        # --- Sign Disagreement Check ---\n        \n        # Get signs using the custom sign function\n        sign_rho_xy = custom_sign(rho_xy)\n        sign_rho_xy_cond_z = custom_sign(rho_xy_cond_z)\n        \n        # Determine if signs disagree\n        disagreement = sign_rho_xy != sign_rho_xy_cond_z\n        \n        results.append([rho_xy, rho_xy_cond_z, disagreement])\n\n    # --- Format and Print Output ---\n    \n    # Format each result set to the specified format\n    formatted_results = []\n    for r_xy, r_xy_z, d in results:\n        # Round the correlation values to 6 decimal places.\n        # Booleans are automatically converted to 'True' or 'False'.\n        formatted_results.append(f\"[{r_xy:.6f},{r_xy_z:.6f},{d}]\")\n    \n    # Join all formatted results into a single string\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "4957630"}, {"introduction": "除了混杂之外，医学研究中的另一个挑战是测量工具并非完美无缺。测量过程中的随机噪声会扭曲我们希望研究的变量间的真实关系。本练习将深入探讨经典测量误差模型，揭示随机误差通常如何削弱或“衰减”（attenuates）变量间的真实相关性。您将推导出这种衰减效应的数学原理，并探索如何对其进行校正，从而掌握评估测量信度对统计结果影响的工具。[@problem_id:4957614]", "problem": "一项临床研究调查了人群中两种连续生物标志物之间的关联，这两种标志物在测量时都受到仪器噪声的影响。设潜在真实变量为 $X$ 和 $Y$，其方差有限；设观测变量为 $X^{\\ast}$ 和 $Y^{\\ast}$，由经典测量误差模型 $X^{\\ast} = X + \\varepsilon_{X}$ 和 $Y^{\\ast} = Y + \\varepsilon_{Y}$ 定义，其中 $\\varepsilon_{X}$ 和 $\\varepsilon_{Y}$ 是均值为零的测量误差。假设以下基本事实：(i) 协方差定义为 $\\operatorname{Cov}(U,V) = \\mathbb{E}\\big[(U - \\mathbb{E}[U])(V - \\mathbb{E}[V])\\big]$，(ii) 方差定义为 $\\operatorname{Var}(U) = \\operatorname{Cov}(U,U)$，以及 (iii) 皮尔逊相关性定义为 $r_{U,V} = \\operatorname{Cov}(U,V)\\big/\\big(\\sqrt{\\operatorname{Var}(U)}\\sqrt{\\operatorname{Var}(V)}\\big)$。其医学背景是流行病学中的标准情景：测量误差独立于真实变量，并且可能相互独立，也可能表现出共同漂移，此时 $\\operatorname{Cov}(\\varepsilon_{X},\\varepsilon_{Y})$ 可以非零。\n\n仅从这些核心定义和独立性假设出发，从第一性原理推导观测相关性 $r_{X^{\\ast},Y^{\\ast}}$ 与真实相关性 $r_{X,Y}$ 之间的关系，并明确描述当 $\\operatorname{Cov}(\\varepsilon_{X},\\varepsilon_{Y}) = 0$ 时，测量误差如何衰减相关性，以及当 $\\operatorname{Cov}(\\varepsilon_{X},\\varepsilon_{Y}) \\neq 0$ 时，共同的误差漂移如何导致超越纯粹衰减的相关性失真。然后，设计一个算法，在给定参数值 $\\operatorname{Var}(X)$、$\\operatorname{Var}(Y)$、$r_{X,Y}$、$\\operatorname{Var}(\\varepsilon_{X})$、$\\operatorname{Var}(\\varepsilon_{Y})$ 和 $\\operatorname{Cov}(\\varepsilon_{X},\\varepsilon_{Y})$ 的情况下，为每种情况计算以下四个量：\n- 观测相关性 $r_{X^{\\ast},Y^{\\ast}}$。\n- 在误差独立假设下，通过将 $\\operatorname{Cov}(\\varepsilon_{X},\\varepsilon_{Y})$ 设置为 $0$ 同时保持所有其他参数不变而获得的仅含衰减的观测相关性。\n- 使用已知 $\\operatorname{Cov}(\\varepsilon_{X},\\varepsilon_{Y})$ 的通用模型，对真实相关性进行去衰减估计。\n- 使用经典的 Spearman 校正（其假设 $\\operatorname{Cov}(\\varepsilon_{X},\\varepsilon_{Y}) = 0$），从信度因子计算出的去衰减估计。\n\n程序必须实现你推导出的关系，不得依赖任何预先提供的快捷公式，并且必须适用于任何现代编程语言。所有输出必须是无单位的小数（无百分号），且不涉及角度。为了符合医学现实，将 $\\operatorname{Var}(X)$ 和 $\\operatorname{Var}(Y)$ 解释为具有临床意义的连续生物标志物（例如血压或实验室值）的方差，将误差项解释为仪器噪声的方差和协方差；但是，你只需计算无量纲的相关性，因此输出中不会出现物理单位。\n\n测试套件：\n提供以下测试用例，形式为有序的 $6$ 元组 $(\\operatorname{Var}(X), \\operatorname{Var}(Y), r_{X,Y}, \\operatorname{Var}(\\varepsilon_{X}), \\operatorname{Var}(\\varepsilon_{Y}), \\operatorname{Cov}(\\varepsilon_{X},\\varepsilon_{Y}))$。这些值在医学上是合理的，涵盖了正常路径、边界情况和边缘情况：\n- 情况 1：$(225, 324, 0.35, 100, 64, 0)$。\n- 情况 2：$(81, 49, 0.60, 0, 0, 0)$。\n- 情况 3：$(64, 16, 0.30, 576, 0, 0)$。\n- 情况 4：$(100, 100, 0.20, 25, 25, 15)$。\n- 情况 5：$(196, 121, 0.50, 49, 64, -20)$。\n\n答案规范：\n对于每种情况，按上述指定顺序计算并返回一个包含四个浮点数的列表，保留 $6$ 位小数。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的 $4$ 元组列表（例如，$\\big[\\,[r_{1,1},r_{1,2},r_{1,3},r_{1,4}],\\,[r_{2,1},r_{2,2},r_{2,3},r_{2,4}],\\,\\ldots\\,\\big]$）。不应打印任何其他文本。", "solution": "问题在于推导两个潜在变量的真实相关性与其受噪声污染的测量值之间的观测相关性之间的关系。我们将从第一性原理推导此关系，分析测量误差的失真效应，然后构建一个算法，根据给定的参数计算几个与相关性相关的量。\n\n基础模型由方程 $X^{\\ast} = X + \\varepsilon_{X}$ 和 $Y^{\\ast} = Y + \\varepsilon_{Y}$ 给出，其中 $X$ 和 $Y$ 是真实潜在变量，$X^{\\ast}$ 和 $Y^{\\ast}$ 是观测变量，$\\varepsilon_{X}$ 和 $\\varepsilon_{Y}$ 是均值为零的测量误差。假设误差独立于真实变量，这意味着 $\\operatorname{Cov}(X, \\varepsilon_{X}) = 0$、$\\operatorname{Cov}(X, \\varepsilon_{Y}) = 0$、$\\operatorname{Cov}(Y, \\varepsilon_{X}) = 0$ 和 $\\operatorname{Cov}(Y, \\varepsilon_{Y}) = 0$。核心定义是 $\\operatorname{Cov}(U,V) = \\mathbb{E}\\big[(U - \\mathbb{E}[U])(V - \\mathbb{E}[V])\\big]$、$\\operatorname{Var}(U) = \\operatorname{Cov}(U,U)$ 以及皮尔逊相关性 $r_{U,V} = \\operatorname{Cov}(U,V)\\big/\\big(\\sqrt{\\operatorname{Var}(U)}\\sqrt{\\operatorname{Var}(V)}\\big)$。\n\n首先，我们推导观测相关性 $r_{X^{\\ast},Y^{\\ast}}$ 的公式。这需要协方差 $\\operatorname{Cov}(X^{\\ast}, Y^{\\ast})$ 以及方差 $\\operatorname{Var}(X^{\\ast})$ 和 $\\operatorname{Var}(Y^{\\ast})$ 的表达式。\n\n观测变量 $X^{\\ast}$ 的方差是利用“两个变量之和的方差等于它们各自方差之和加上其协方差的两倍”这一性质推导出来的。\n$$ \\operatorname{Var}(X^{\\ast}) = \\operatorname{Var}(X + \\varepsilon_{X}) = \\operatorname{Var}(X) + \\operatorname{Var}(\\varepsilon_{X}) + 2\\operatorname{Cov}(X, \\varepsilon_{X}) $$\n鉴于真实变量 $X$ 与其测量误差 $\\varepsilon_{X}$ 相互独立，它们的协方差为零，即 $\\operatorname{Cov}(X, \\varepsilon_{X}) = 0$。因此，观测变量的方差是真实方差与误差方差之和：\n$$ \\operatorname{Var}(X^{\\ast}) = \\operatorname{Var}(X) + \\operatorname{Var}(\\varepsilon_{X}) $$\n通过相同的论证，观测变量 $Y^{\\ast}$ 的方差为：\n$$ \\operatorname{Var}(Y^{\\ast}) = \\operatorname{Var}(Y) + \\operatorname{Var}(\\varepsilon_{Y}) $$\n\n接下来，我们利用协方差算子的双线性性质推导两个观测变量之间的协方差 $\\operatorname{Cov}(X^{\\ast}, Y^{\\ast})$：\n$$ \\operatorname{Cov}(X^{\\ast}, Y^{\\ast}) = \\operatorname{Cov}(X + \\varepsilon_{X}, Y + \\varepsilon_{Y}) $$\n$$ = \\operatorname{Cov}(X, Y) + \\operatorname{Cov}(X, \\varepsilon_{Y}) + \\operatorname{Cov}(\\varepsilon_{X}, Y) + \\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y}) $$\n测量误差独立于真实变量的假设意味着交叉协方差项为零：$\\operatorname{Cov}(X, \\varepsilon_{Y}) = 0$ 和 $\\operatorname{Cov}(\\varepsilon_{X}, Y) = 0$。观测协方差的表达式简化为：\n$$ \\operatorname{Cov}(X^{\\ast}, Y^{\\ast}) = \\operatorname{Cov}(X, Y) + \\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y}) $$\n这表明观测协方差是真实协方差与测量误差协方差之和。\n\n现在，我们可以根据其定义来组合出观测相关性 $r_{X^{\\ast},Y^{\\ast}}$ 的公式：\n$$ r_{X^{\\ast},Y^{\\ast}} = \\frac{\\operatorname{Cov}(X^{\\ast}, Y^{\\ast})}{\\sqrt{\\operatorname{Var}(X^{\\ast})}\\sqrt{\\operatorname{Var}(Y^{\\ast})}} $$\n代入我们推导出的方差和协方差项的表达式，我们得到一般关系式：\n$$ r_{X^{\\ast},Y^{\\ast}} = \\frac{\\operatorname{Cov}(X, Y) + \\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y})}{\\sqrt{\\operatorname{Var}(X) + \\operatorname{Var}(\\varepsilon_{X})}\\sqrt{\\operatorname{Var}(Y) + \\operatorname{Var}(\\varepsilon_{Y})}} $$\n回顾 $\\operatorname{Cov}(X, Y) = r_{X,Y}\\sqrt{\\operatorname{Var}(X)}\\sqrt{\\operatorname{Var}(Y)}$，我们可以将公式完全用相关性和方差来表示：\n$$ r_{X^{\\ast},Y^{\\ast}} = \\frac{r_{X,Y}\\sqrt{\\operatorname{Var}(X)}\\sqrt{\\operatorname{Var}(Y)} + \\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y})}{\\sqrt{\\operatorname{Var}(X) + \\operatorname{Var}(\\varepsilon_{X})}\\sqrt{\\operatorname{Var}(Y) + \\operatorname{Var}(\\varepsilon_{Y})}} $$\n\n我们现在来描述测量误差如何影响相关性。\n情况1：独立的测量误差，$\\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y}) = 0$。\n在这种常见情况下，公式简化为：\n$$ r_{X^{\\ast},Y^{\\ast}} = \\frac{r_{X,Y}\\sqrt{\\operatorname{Var}(X)}\\sqrt{\\operatorname{Var(Y)}}}{\\sqrt{\\operatorname{Var}(X) + \\operatorname{Var}(\\varepsilon_{X})}\\sqrt{\\operatorname{Var}(Y) + \\operatorname{Var}(\\varepsilon_{Y})}} $$\n这可以重新排列为：\n$$ r_{X^{\\ast},Y^{\\ast}} = r_{X,Y} \\left( \\sqrt{\\frac{\\operatorname{Var}(X)}{\\operatorname{Var}(X) + \\operatorname{Var}(\\varepsilon_{X})}} \\right) \\left( \\sqrt{\\frac{\\operatorname{Var}(Y)}{\\operatorname{Var}(Y) + \\operatorname{Var}(\\varepsilon_{Y})}} \\right) $$\n括号中的项是信度比的平方根，记作 $\\sqrt{\\rho_{XX^{\\ast}}}$ 和 $\\sqrt{\\rho_{YY^{\\ast}}}$。由于方差是非负的，这些比率介于 $0$ 和 $1$ 之间。因此，有 $|r_{X^{\\ast},Y^{\\ast}}| \\le |r_{X,Y}|$。独立测量误差的存在总是会衰减相关性，使其向零偏倚。衰减的幅度取决于测量的信度，即真实方差与观测方差之比。\n\n情况2：相关的测量误差，$\\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y}) \\neq 0$。\n完整的公式适用。分子中的项 $\\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y})$ 增加了另一层失真。如果 $\\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y})$ 与真实协方差 $\\operatorname{Cov}(X,Y)$ 的符号相同，它可以抵消分母带来的衰减，甚至可能放大相关性，使得 $|r_{X^{\\ast},Y^{\\ast}}|  |r_{X,Y}|$。相反，如果它的符号相反，则会加剧衰减。值得注意的是，即使真实变量不相关（$r_{X,Y}=0$），也可能观测到非零相关性（$r_{X^{\\ast},Y^{\\ast}} \\neq 0$），这种现象称为伪相关，前提是 $\\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y}) \\neq 0$。\n\n接下来，我们推导去衰减的公式，这是一个从观测值估计真实相关性 $r_{X,Y}$ 的过程。\n一般的去衰减公式是通过求解一般关系式中关于 $r_{X,Y}$ 的方程得到的。从 $\\operatorname{Cov}(X^{\\ast}, Y^{\\ast}) = \\operatorname{Cov}(X, Y) + \\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y})$ 出发，我们分离出 $\\operatorname{Cov}(X,Y)$：\n$$ \\operatorname{Cov}(X, Y) = \\operatorname{Cov}(X^{\\ast}, Y^{\\ast}) - \\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y}) $$\n然后，我们通过除以真实标准差的乘积来求得真实相关性 $r_{X,Y}$：\n$$ r_{X,Y} = \\frac{\\operatorname{Cov}(X^{\\ast}, Y^{\\ast}) - \\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y})}{\\sqrt{\\operatorname{Var}(X)}\\sqrt{\\operatorname{Var}(Y)}} $$\n其中 $\\operatorname{Cov}(X^{\\ast}, Y^{\\ast}) = r_{X^{\\ast},Y^{\\ast}}\\sqrt{\\operatorname{Var}(X^{\\ast})}\\sqrt{\\operatorname{Var}(Y^{\\ast})}$。如果误差过程的所有方差和协方差参数都已知，那么真实相关性可以被完美地恢复。\n\n经典的 Spearman 衰减校正是该方法的一个特例，它假设误差是独立的，即 $\\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y}) = 0$。在此假设下，$r_{X^{\\ast},Y^{\\ast}} = r_{X,Y} \\sqrt{\\rho_{XX^{\\ast}}}\\sqrt{\\rho_{YY^{\\ast}}}$。求解 $r_{X,Y}$ 可得：\n$$ r_{X,Y}^{\\text{Spearman}} = \\frac{r_{X^{\\ast},Y^{\\ast}}}{\\sqrt{\\rho_{XX^{\\ast}}}\\sqrt{\\rho_{YY^{\\ast}}}} = r_{X^{\\ast},Y^{\\ast}} \\sqrt{\\frac{\\operatorname{Var}(X^{\\ast})}{\\operatorname{Var}(X)}} \\sqrt{\\frac{\\operatorname{Var}(Y^{\\ast})}{\\operatorname{Var}(Y)}} $$\n这种校正仅在误差确实不相关时才有效。如果将其应用于误差相关的数据，它将产生对真实相关性的有偏估计。\n\n最后，我们设计算法来计算所需的四个量。\n给定：$\\operatorname{Var}(X)$、$\\operatorname{Var}(Y)$、$r_{X,Y}$、$\\operatorname{Var}(\\varepsilon_{X})$、$\\operatorname{Var}(\\varepsilon_{Y})$ 和 $\\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y})$。\n\n1.  **计算中间值**：\n    -   真实协方差：$\\operatorname{Cov}(X,Y) = r_{X,Y} \\sqrt{\\operatorname{Var}(X)\\operatorname{Var}(Y)}$\n    -   $X^{\\ast}$ 的观测方差：$\\operatorname{Var}(X^{\\ast}) = \\operatorname{Var}(X) + \\operatorname{Var}(\\varepsilon_{X})$\n    -   $Y^{\\ast}$ 的观测方差：$\\operatorname{Var}(Y^{\\ast}) = \\operatorname{Var}(Y) + \\operatorname{Var}(\\varepsilon_{Y})$\n\n2.  **计算量1：观测相关性 $r_{X^{\\ast},Y^{\\ast}}$**：\n    -   观测协方差：$\\operatorname{Cov}(X^{\\ast},Y^{\\ast}) = \\operatorname{Cov}(X,Y) + \\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y})$\n    -   $r_{X^{\\ast},Y^{\\ast}} = \\frac{\\operatorname{Cov}(X^{\\ast},Y^{\\ast})}{\\sqrt{\\operatorname{Var}(X^{\\ast})\\operatorname{Var}(Y^{\\ast})}}$\n\n3.  **计算量2：仅衰减相关性**：\n    -   这是在误差独立情况下的假设观测相关性。使用步骤2中 $r_{X^{\\ast},Y^{\\ast}}$ 的公式，但将 $\\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y})$ 设为 $0$。\n    -   $r_{\\text{atten}} = \\frac{\\operatorname{Cov}(X,Y)}{\\sqrt{\\operatorname{Var}(X^{\\ast})\\operatorname{Var}(Y^{\\ast})}}$\n\n4.  **计算量3：去衰减估计（通用模型）**：\n    -   此计算逆转了步骤2的过程以恢复原始的 $r_{X,Y}$。如推导所示，这将返回输入的 $r_{X,Y}$ 值。\n    -   $r_{X,Y}^{\\text{disatt, gen}} = \\frac{r_{X^{\\ast},Y^{\\ast}} \\sqrt{\\operatorname{Var}(X^{\\ast})\\operatorname{Var}(Y^{\\ast})} - \\operatorname{Cov}(\\varepsilon_{X}, \\varepsilon_{Y})}{\\sqrt{\\operatorname{Var}(X)}\\sqrt{\\operatorname{Var}(Y)}}$\n\n5.  **计算量4：去衰减估计（Spearman 校正）**：\n    -   将 Spearman 公式应用于量1中得到的观测相关性。这模拟了研究人员错误地假设误差独立的情景。\n    -   $r_{X,Y}^{\\text{disatt, spec}} = r_{X^{\\ast},Y^{\\ast}} \\sqrt{\\frac{\\operatorname{Var}(X^{\\ast})}{\\operatorname{Var}(X)}} \\sqrt{\\frac{\\operatorname{Var}(Y^{\\ast})}{\\operatorname{Var}(Y)}}$\n\n这个结构化过程在提供的 Python 代码中得以实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes observed correlations and disattenuated estimates based on a measurement error model.\n    \"\"\"\n    \n    # Test cases as 6-tuples:\n    # (Var(X), Var(Y), r(X,Y), Var(eps_X), Var(eps_Y), Cov(eps_X, eps_Y))\n    test_cases = [\n        (225.0, 324.0, 0.35, 100.0, 64.0, 0.0),\n        (81.0, 49.0, 0.60, 0.0, 0.0, 0.0),\n        (64.0, 16.0, 0.30, 576.0, 0.0, 0.0),\n        (100.0, 100.0, 0.20, 25.0, 25.0, 15.0),\n        (196.0, 121.0, 0.50, 49.0, 64.0, -20.0),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        var_x, var_y, r_xy, var_ex, var_ey, cov_exy = case\n        \n        # Calculate intermediate values based on first principles\n        cov_xy = r_xy * np.sqrt(var_x * var_y)\n        var_x_obs = var_x + var_ex\n        var_y_obs = var_y + var_ey\n\n        # Handle potential division by zero if observed variances are zero, although not expected with given test cases.\n        if var_x_obs == 0 or var_y_obs == 0:\n            # Correlation is undefined if any variable has zero variance.\n            # Set results to NaN to indicate this.\n            results_for_case = [np.nan] * 4\n            all_results.append(results_for_case)\n            continue\n        \n        # --- Quantity 1: Observed correlation r_X*,Y* ---\n        cov_x_obs_y_obs = cov_xy + cov_exy\n        r_x_obs_y_obs = cov_x_obs_y_obs / np.sqrt(var_x_obs * var_y_obs)\n\n        # --- Quantity 2: Attenuation-only observed correlation ---\n        # This is the observed correlation under the assumption that Cov(eps_X, eps_Y) = 0.\n        r_atten_only = cov_xy / np.sqrt(var_x_obs * var_y_obs)\n\n        # --- Quantity 3: Disattenuated estimate (general model) ---\n        # This should exactly recover the true r_xy, serving as a check of the derivation.\n        # It's computationally equivalent to `r_xy` if var_x/var_y are not zero.\n        if var_x == 0 or var_y == 0:\n            r_disatt_gen = np.nan\n        else:\n            recovered_cov_xy = (r_x_obs_y_obs * np.sqrt(var_x_obs * var_y_obs)) - cov_exy\n            r_disatt_gen = recovered_cov_xy / np.sqrt(var_x * var_y)\n        \n        # --- Quantity 4: Disattenuated estimate (Spearman's correction) ---\n        # This correction is applied to the observed correlation from Quantity 1,\n        # but assumes independent errors (Cov(eps_X, eps_Y) = 0).\n        if var_x == 0 or var_y == 0:\n            r_disatt_spec = np.nan\n        else:\n            r_disatt_spec = r_x_obs_y_obs * np.sqrt(var_x_obs / var_x) * np.sqrt(var_y_obs / var_y)\n            \n        results_for_case = [\n            round(r_x_obs_y_obs, 6),\n            round(r_atten_only, 6),\n            round(r_disatt_gen, 6),\n            round(r_disatt_spec, 6),\n        ]\n        \n        all_results.append(results_for_case)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[val1,val2,...],[val1,val2,...]]\n    inner_lists_str = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    output_str = f\"[{','.join(inner_lists_str)}]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "4957614"}]}