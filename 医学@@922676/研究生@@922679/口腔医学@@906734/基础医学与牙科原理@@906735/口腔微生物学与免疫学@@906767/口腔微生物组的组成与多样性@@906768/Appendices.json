{"hands_on_practices": [{"introduction": "对微生物多样性进行量化是微生物组分析的基础步骤。我们使用 alpha 多样性指数来概括单个群落的复杂性。本练习将指导您如何从原始的分类单元计数数据出发，计算两个最重要的多样性指数——香农多样性（Shannon diversity）和辛普森多样性指数（Simpson diversity index，以希尔数（Hill number）形式表示）[@problem_id:4743979]。掌握这一实践将巩固您对这些指数如何将丰度数据转化为有意义的生态学指标的理解，以及它们在对优势物种的敏感性方面有何不同。", "problem": "在高等口腔医学中，对口腔微生物组组成和多样性的定量评估依赖于将观测到的分类单元计数转换为相对丰度，然后应用基于信息论和概率论中经过充分检验的原理的多样性度量方法。考虑一个唾液样本，其分析包含四个分类单元，计数分别为 $\\text{A}:5$、$\\text{B}:5$、$\\text{C}:40$ 和 $\\text{D}:50$。\n\n从核心定义出发，按以下步骤进行：\n1. 将计数归一化，得到每个分类单元的相对丰度 $p_i$。$p_i$ 等于分类单元 $i$ 的计数除以总计数。\n2. 使用信息论中 Shannon 熵的基本定义，推导该分布的 Shannon 多样性（Shannon 熵）$H$ 的表达式（以自然对数单位“奈特”表示），并计算其样本值。\n3. 使用多样性的 Hill 数框架，推导 2 阶多样性（记为 ${}^{2}D$）的表达式，它对应于 Simpson 集中度指数的倒数，并计算其样本值。\n4. 根据每个指数对相对丰度 $p_i$ 的数学依赖关系，解释哪个指数更侧重于优势分类单元，并说明原因，此解释不依赖于具体数值。\n\n将两个数值结果四舍五入至四位有效数字。Shannon 多样性以奈特为单位，2 阶 Hill 数为无量纲量。将最终数值结果以单行矩阵 $\\big(H \\text{ (in nats)}\\;\\; {}^{2}D\\big)$ 的形式报告。", "solution": "该问题提法清晰，具有科学依据，并为完整解答提供了所有必要信息。我们按要求的四个部分进行。\n\n四个分类单元的计数分别为 $n_A = 5$、$n_B = 5$、$n_C = 40$ 和 $n_D = 50$。\n\n1.  **计数归一化为相对丰度**\n\n第一步是计算样本中所有分类单元的总计数，记为 $N$。\n$$N = n_A + n_B + n_C + n_D = 5 + 5 + 40 + 50 = 100$$\n每个分类单元 $i$ 的相对丰度 $p_i$ 是其计数 $n_i$ 除以总计数 $N$。\n$$p_i = \\frac{n_i}{N}$$\n将此定义应用于我们的数据：\n$$p_A = \\frac{5}{100} = 0.05$$\n$$p_B = \\frac{5}{100} = 0.05$$\n$$p_C = \\frac{40}{100} = 0.40$$\n$$p_D = \\frac{50}{100} = 0.50$$\n作为验证，所有相对丰度之和必须等于 $1$。\n$$\\sum_{i \\in \\{A,B,C,D\\}} p_i = 0.05 + 0.05 + 0.40 + 0.50 = 1.00$$\n\n2.  **Shannon 多样性（Shannon 熵），$H$**\n\n对于一个具有 $S$ 个状态（分类单元）和相应概率（相对丰度）$p_i$ 的概率分布，Shannon 熵 $H$ 的基本定义为：\n$$H = - \\sum_{i=1}^{S} p_i \\ln(p_i)$$\n按要求，使用自然对数 $\\ln$ 计算，得到的熵单位为奈特 (nats)。对于给定的具有 $S=4$ 个分类单元的样本，$H$ 的表达式为：\n$$H = - \\left( p_A \\ln(p_A) + p_B \\ln(p_B) + p_C \\ln(p_C) + p_D \\ln(p_D) \\right)$$\n将计算出的相对丰度代入：\n$$H = - \\left( 0.05 \\ln(0.05) + 0.05 \\ln(0.05) + 0.40 \\ln(0.40) + 0.50 \\ln(0.50) \\right)$$\n这可以简化为：\n$$H = - \\left( 2 \\times 0.05 \\ln(0.05) + 0.40 \\ln(0.40) + 0.50 \\ln(0.50) \\right)$$\n我们现在计算其数值：\n$$H \\approx - \\left( 0.1 \\times (-2.99573) + 0.40 \\times (-0.91629) + 0.50 \\times (-0.69315) \\right)$$\n$$H \\approx - \\left( -0.299573 - 0.366516 - 0.346575 \\right)$$\n$$H \\approx - ( -1.012664 )$$\n$$H \\approx 1.012664$$\n四舍五入至四位有效数字，Shannon 多样性为 $H \\approx 1.013$ 奈特。\n\n3.  **2 阶 Hill 数，${}^{2}D$ (逆辛普森多样性指数)**\n\n阶数为 $q$ 的多样性 Hill 数的通用公式为：\n$${}^{q}D = \\left( \\sum_{i=1}^{S} p_i^q \\right)^{\\frac{1}{1-q}}$$\n该公式定义于 $q \\ge 0$ 且 $q \\neq 1$。对于阶数 $q=2$ 的多样性，表达式变为：\n$${}^{2}D = \\left( \\sum_{i=1}^{S} p_i^2 \\right)^{\\frac{1}{1-2}} = \\left( \\sum_{i=1}^{S} p_i^2 \\right)^{-1} = \\frac{1}{\\sum_{i=1}^{S} p_i^2}$$\n分母中的项 $\\sum_{i=1}^{S} p_i^2$ 是 Simpson 集中度指数，通常记为 $\\lambda$。因此，${}^{2}D$ 是 Simpson 集中度指数的倒数。我们首先计算 $\\lambda$：\n$$\\lambda = p_A^2 + p_B^2 + p_C^2 + p_D^2$$\n将相对丰度代入：\n$$\\lambda = (0.05)^2 + (0.05)^2 + (0.40)^2 + (0.50)^2$$\n$$\\lambda = 0.0025 + 0.0025 + 0.1600 + 0.2500 = 0.4150$$\n现在，我们计算 ${}^{2}D$：\n$${}^{2}D = \\frac{1}{\\lambda} = \\frac{1}{0.4150} \\approx 2.40963855$$\n四舍五入至四位有效数字，2 阶 Hill 数为 ${}^{2}D \\approx 2.410$。该值为无量纲量。\n\n4.  **对优势分类单元权重的比较**\n\n为确定哪个指数更侧重于优势分类单元，我们必须检查它们所源自的求和项的数学形式，而不参考具体的数值结果。\n\n2 阶多样性 ${}^{2}D$ 是 Simpson 集中度指数 $\\lambda = \\sum_{i=1}^{S} p_i^2$ 的倒数。每个分类单元对该总和的贡献与其相对丰度 $p_i$ 的平方成正比。平方运算不成比例地给予了较大的 $p_i$ 值更大的权重。例如，一个丰度为 $p_1$ 的分类单元，其丰度是另一个丰度为 $p_2$ 的分类单元的两倍（即 $p_1 = 2p_2$），它对总和 $\\lambda$ 的贡献将是后者的四倍（即 $p_1^2 = 4p_2^2$）。这种对高丰度分类单元贡献的放大效应意味着 $\\lambda$ 及其倒数 ${}^{2}D$ 严重受到群落中最优势成员的影响。\n\nShannon 多样性 $H = - \\sum_{i=1}^{S} p_i \\ln(p_i)$ 是形如 $f(p_i) = -p_i \\ln(p_i)$ 的各项之和。这个函数由 $p_i$ 加权，但对数项 $\\ln(p_i)$ 的增长速度远慢于 $p_i$ 本身。对于一个优势分类单元，其 $p_i$ 值很大（接近 1），$\\ln(p_i)$ 是一个绝对值很小的负数（接近 0），这会缓和该分类单元的贡献。相反，对于一个稀有分类单元，其 $p_i$ 值很小（接近 0），$\\ln(p_i)$ 是一个绝对值很大的负数，这会相对于其丰度增加该项的贡献。这种函数形式给予所有物种更公平的权重，使得 $H$ 对丰富度（分类单元数量）和均匀度都敏感，而不是由最丰富的分类单元主导。\n\n因此，由于其计算涉及相对丰度的平方，与 Shannon 多样性 $H$ 相比，2 阶 Hill 数 ${}^{2}D$ 更侧重于优势分类单元。", "answer": "$$ \\boxed{ \\begin{pmatrix} 1.013  2.410 \\end{pmatrix} } $$", "id": "4743979"}, {"introduction": "在评估完单个样本后，我们常常需要比较不同的微生物群落，例如口腔内不同部位的样本。Beta 多样性指标正是用于量化这种不相似性。本练习要求您从基本原理出发，推导出广泛使用的 Bray-Curtis 不相似性指数，该指数与两个群落之间共享和非共享的丰度有关[@problem_id:4743987]。通过推导而非仅仅应用公式，您将对 beta 多样性的真实度量获得更深刻的直觉，这对于解释比较性微生物组研究至关重要。", "problem": "在口腔医学中，比较不同口腔部位微生物群落的组成和多样性，需要一种有原则的方法来量化两种丰度分布的相似或不相似程度。考虑代表四种细菌分类单元的两个群落计数向量，一个来自舌背，另一个来自颊粘膜。设舌背的丰度向量为 $\\mathbf{x}=(10,0,5,20)$，颊粘膜的丰度向量为 $\\mathbf{y}=(5,5,10,10)$，其中每个条目代表单个样本中某个分类单元的观测计数。\n\n从以下基于群落生态学的基本定义和要求出发：\n\n1. 这对样本的总丰度为 $T=\\sum_{i} x_{i}+\\sum_{i} y_{i}$。\n2. 这对样本的共享丰度，反映了两个样本中都存在的分类单元所贡献的计数部分，为 $S=\\sum_{i} \\min(x_{i},y_{i})$。\n3. 相异性度量 $D(\\mathbf{x},\\mathbf{y})$ 应满足：参数对称性，$D(\\mathbf{x},\\mathbf{y})=D(\\mathbf{y},\\mathbf{x})$；共同标度下的不变性，$D(c\\mathbf{x},c\\mathbf{y})=D(\\mathbf{x},\\mathbf{y})$ 对于任何 $c>0$；有界性 $0\\leq D\\leq 1$；当 $\\mathbf{x}=\\mathbf{y}$ 时 $D=0$；以及当没有共享丰度时（即 $S=0$ 时）$D=1$。\n4. 该度量应反映两个样本之间未共享的丰度所占的比例。\n\n使用上述定义，推导 $D(\\mathbf{x},\\mathbf{y})$ 的闭式表达式，然后计算给定舌背和颊粘膜向量的 $D$ 值。最终答案以精确数表示，不进行近似，且不带单位。", "solution": "目标是基于一组基本定义和要求，推导相异性度量 $D(\\mathbf{x},\\mathbf{y})$ 的闭式表达式，然后计算两个给定丰度向量的 $D$ 值。\n\n问题指定了两个丰度向量：\n- 舌背：$\\mathbf{x}=(10,0,5,20)$\n- 颊粘膜：$\\mathbf{y}=(5,5,10,10)$\n\n推导过程遵循以下定义和要求：\n1.  总丰度: $T = \\sum_{i} x_i + \\sum_{i} y_i$\n2.  共享丰度: $S = \\sum_{i} \\min(x_i, y_i)$\n3.  相异性度量 $D(\\mathbf{x},\\mathbf{y})$ 的性质：对称性、标度不变性、有界性 ($0 \\le D \\le 1$)、同一性 (当 $\\mathbf{x}=\\mathbf{y}$ 时 $D=0$)，以及最大相异性 (当 $S=0$ 时 $D=1$)。\n4.  概念基础: $D(\\mathbf{x},\\mathbf{y})$ 应表示两个样本之间未共享的丰度比例。\n\n让我们将要求4中的概念基础形式化。两个样本组合系统中的总丰度由 $T = \\sum_{i} (x_i + y_i)$ 给出。这部分丰度中共享的部分由每个分类单元的最小计数决定。对于单个分类单元 $i$，共享个体的数量是 $\\min(x_i, y_i)$。这些共享个体对应于来自样本 $\\mathbf{x}$ 的 $\\min(x_i, y_i)$ 个计数和来自样本 $\\mathbf{y}$ 的 $\\min(x_i, y_i)$ 个计数。因此，两个样本中由共享个体贡献的总丰度是 $2 \\sum_{i} \\min(x_i, y_i) = 2S$。\n\n*未*共享的总丰度是总丰度与总共享丰度之间的差值。设其为 $U$。\n$$U = T - 2S = \\left(\\sum_i x_i + \\sum_i y_i\\right) - 2 \\sum_i \\min(x_i, y_i)$$\n相异性度量 $D$ 定义为未共享丰度占总丰度的比例。这是未共享丰度 $U$ 与总丰度 $T$ 的比率。\n$$D(\\mathbf{x},\\mathbf{y}) = \\frac{U}{T} = \\frac{T - 2S}{T} = 1 - \\frac{2S}{T}$$\n代入 $T$ 和 $S$ 的定义：\n$$D(\\mathbf{x},\\mathbf{y}) = \\frac{\\left(\\sum_i x_i + \\sum_i y_i\\right) - 2 \\sum_i \\min(x_i, y_i)}{\\sum_i x_i + \\sum_i y_i}$$\n这个表达式可以被简化。对于任意两个非负数 $a$ 和 $b$，恒等式 $a+b = 2\\min(a,b) + |a-b|$ 成立。将此应用于每对分类单元丰度 $(x_i, y_i)$ 并对所有分类单元 $i$ 求和：\n$$\\sum_i (x_i + y_i) = \\sum_i (2\\min(x_i, y_i) + |x_i - y_i|) = 2 \\sum_i \\min(x_i, y_i) + \\sum_i |x_i - y_i|$$\n用 $T$ 和 $S$ 表示，即 $T = 2S + \\sum_i |x_i - y_i|$。\n由此，未共享丰度 $U = T - 2S$ 正好等于 $\\sum_i |x_i - y_i|$。\n因此，相异性度量可以写成等价形式：\n$$D(\\mathbf{x},\\mathbf{y}) = \\frac{\\sum_i |x_i - y_i|}{\\sum_i (x_i + y_i)}$$\n这就是著名的 Bray-Curtis 相异性指数，我们已经从问题的第一性原理推导出了它。我们可以验证它满足要求3中的性质，这一点在从要求4的推导中已经隐含地完成了，因为要求4内嵌了这些性质。\n\n现在，我们为给定的向量 $\\mathbf{x}=(10,0,5,20)$ 和 $\\mathbf{y}=(5,5,10,10)$ 计算 $D(\\mathbf{x},\\mathbf{y})$ 的值。\n\n首先，计算每个向量的丰度之和：\n$$ \\sum_i x_i = 10 + 0 + 5 + 20 = 35 $$\n$$ \\sum_i y_i = 5 + 5 + 10 + 10 = 30 $$\n\n接着，计算总丰度 $T$：\n$$ T = \\sum_i x_i + \\sum_i y_i = 35 + 30 = 65 $$\n\n然后，计算共享丰度 $S$：\n$$ S = \\sum_i \\min(x_i, y_i) = \\min(10,5) + \\min(0,5) + \\min(5,10) + \\min(20,10) $$\n$$ S = 5 + 0 + 5 + 10 = 20 $$\n\n使用推导出的公式 $D = \\frac{T-2S}{T}$：\n$$ D(\\mathbf{x},\\mathbf{y}) = \\frac{65 - 2(20)}{65} = \\frac{65 - 40}{65} = \\frac{25}{65} $$\n\n最后，我们简化分数：\n$$ D(\\mathbf{x},\\mathbf{y}) = \\frac{25}{65} = \\frac{5 \\times 5}{5 \\times 13} = \\frac{5}{13} $$\n\n或者，使用带有绝对差的形式：\n绝对差之和为：\n$$ \\sum_i |x_i - y_i| = |10-5| + |0-5| + |5-10| + |20-10| $$\n$$ \\sum_i |x_i - y_i| = 5 + 5 + 5 + 10 = 25 $$\n总丰度之和为 $T=65$。\n$$ D(\\mathbf{x},\\mathbf{y}) = \\frac{\\sum_i |x_i - y_i|}{\\sum_i (x_i + y_i)} = \\frac{25}{65} = \\frac{5}{13} $$\n两种方法都得出相同的结果。推导出的表达式为 $D(\\mathbf{x},\\mathbf{y}) = \\frac{\\sum_i |x_i - y_i|}{\\sum_i (x_i + y_i)}$，对于给定数据，其值为 $\\frac{5}{13}$。", "answer": "$$\\boxed{\\frac{5}{13}}$$", "id": "4743987"}, {"introduction": "口腔微生物群落是能够响应饮食等环境变化的动态系统。理解其稳定性——无论是表现出弹性恢复还是路径依赖的变化（即迟滞现象）——是临床和生态学研究的一个关键目标。这项高级计算练习将要求您实现一个广义 Lotka-Volterra 模型，以模拟群落如何响应暂时的饮食限制[@problem_id:4744038]。您将使用复杂的分析工具来对系统的动态行为进行分类，这项动手实践将生态学理论与实用的计算技能联系起来，使您能够探索在临床环境中难以直接观察到的复杂群落动态。", "problem": "您的任务是，以符合高等研究生水平口腔科学的方式，实现并分析一个广义 Lotka–Volterra (gLV) 模型，以研究在饮食糖分短暂变化下口腔微生物组的组成和多样性。目标是，当糖分供应受限一周后恢复时，利用组成空间中返回路径的形状作为判定标准，确定模拟群落表现出弹性还是迟滞现象。\n\n从以下基本基础开始：\n- 在影响人均增长率的环境驱动力 $s(t)$ 下，物种丰度 $x_i(t)$（其中 $i \\in \\{1,\\dots,S\\}$）的广义 Lotka–Volterra (gLV) 动态为\n$$\n\\frac{dx_i}{dt} \\;=\\; x_i(t)\\left[r_i \\;+\\; \\sum_{j=1}^{S} A_{ij} x_j(t) \\;+\\; b_i\\,s(t)\\right],\n$$\n其中 $r_i$ 是内在人均增长率，$A_{ij}$ 是相互作用系数，$b_i$ 是糖敏感性系数。\n- 此处的生态弹性操作性地定义为：沿一条与相同条件下扰动前轨迹没有显著偏离的路径，恢复到扰动前的组成。迟滞现象操作性地定义为一种路径依赖的返回，其返回轨迹与扰动前轨迹有显著偏离，和/或在相同环境条件下，恢复后的最终组成与限制前的组成有实质性差异。\n\n数学和算法要求：\n1.  使用定步长四阶显式 Runge–Kutta 方法 (RK4) 模拟 $S$ 个物种的 gLV 系统，步长为 $\\Delta t = 0.02$ 天，以确保光滑向量场的数值稳定性。\n2.  糖分计划 $s(t)$ 必须在三个连续阶段内为分段常数：\n    -   基线糖分：持续 $7$ 天，其中 $s(t)=1$。\n    -   限制：持续 $7$ 天，其中 $s(t)=0$。\n    -   返回基线：持续 $7$ 天，其中 $s(t)=1$。\n    因此，完整的模拟时间范围为 $21$ 天。\n3.  为确保生物学上的合理性，在每个 RK4 步骤后强制执行非负性：如果任何 $x_i(t)$ 因数值误差变为负数，则在下一步之前将其设置为一个小的下限值 $10^{-9}$。\n4.  以每日间隔记录群落组成，形式为相对丰度（即归一化向量）\n$$\np(t_k) \\;=\\; \\frac{x(t_k)}{\\sum_{i=1}^{S} x_i(t_k)},\n$$\n其中 $t_k$ 为整数天数。\n5.  令 $C_{\\mathrm{forward}}$ 表示第一个 $7$ 天基线阶段的每日组成序列，令 $C_{\\mathrm{return}}$ 表示最后一个 $7$ 天返回基线阶段的序列。\n6.  使用以下递推关系定义两个组成序列 $P=\\{p_0,\\dots,p_m\\}$ 和 $Q=\\{q_0,\\dots,q_n\\}$ 之间的离散 Fréchet 距离：\n$$\n\\begin{aligned}\n(a,b) \\;=\\; \\left\\|a-b\\right\\|_2, \\\\\n(0,0) \\;=\\; d(p_0,q_0), \\\\\n(i,0) \\;=\\; \\max\\big(c(i-1,0),\\,d(p_i,q_0)\\big), \\\\\n(0,j) \\;=\\; \\max\\big(c(0,j-1),\\,d(p_0,q_j)\\big), \\\\\n(i,j) \\;=\\; \\max\\Big(\\min\\big(c(i-1,j),\\,c(i-1,j-1),\\,c(i,j-1)\\big),\\,d(p_i,q_j)\\Big),\n\\end{aligned}\n$$\n离散 Fréchet 距离由 $c(m,n)$ 给出。\n7.  计算两个指标：\n    -   组成空间中的路径分离度 $D_{\\mathrm{path}} \\equiv \\mathrm{Fr\\acute{e}chet}(C_{\\mathrm{forward}},C_{\\mathrm{return}})$。\n    -   组成空间中的终点分离度 $D_{\\mathrm{end}} \\equiv \\left\\|p(7)-p(21)\\right\\|_2$。\n8.  根据以下规则对每个参数集的结果进行分类：\n    -   弹性：如果 $D_{\\mathrm{end}} \\le 0.02$ 且 $D_{\\mathrm{path}} \\le 0.05$，则输出整数 $1$。\n    -   迟滞：如果 $D_{\\mathrm{end}} \\ge 0.10$ 或 $D_{\\mathrm{path}} \\ge 0.12$，则输出整数 $2$。\n    -   不确定：其他情况输出整数 $0$。\n\n测试套件规范：\n为以下三个参数集（每个包含 $S=3$ 个物种）实现模拟和分类，并提供 $r$、$A$、$b$ 以及初始丰度向量 $x(0)$ 的明确值。这些参数集旨在探究一个典型的弹性场景、一个强路径依赖的迟滞场景，以及一个具有缓慢竞争漂移的边界案例。\n\n-   案例 $\\mathrm{A}$（共存且糖敏感性适中；预期为弹性行为）：\n    -   $r = (0.50,\\,0.45,\\,0.40)$,\n    -   $A = \\begin{bmatrix}\n        -1.00  -0.10  -0.10 \\\\\n        -0.10  -1.10  -0.10 \\\\\n        -0.10  -0.10  -0.90\n      \\end{bmatrix}$,\n    -   $b = (0.20,\\,-0.05,\\,0.00)$,\n    -   $x(0)$ 等于基线糖分下的内部平衡点，即 $x(0) = -A^{-1}\\big(r + b\\cdot 1\\big)$。\n-   案例 $\\mathrm{B}$（强烈的种间竞争，产酸物种具有高糖敏感性；预期为迟滞行为）：\n    -   $r = (0.30,\\,0.30,\\,0.05)$,\n    -   $A = \\begin{bmatrix}\n        -1.00  -1.40  -0.05 \\\\\n        -1.40  -1.00  -0.05 \\\\\n        -0.05  -0.05  -1.00\n      \\end{bmatrix}$,\n    -   $b = (1.00,\\,-0.15,\\,0.00)$,\n    -   $x(0) = (1.30,\\,0.01,\\,0.02)$。\n-   案例 $\\mathrm{C}$（近中性的竞争性相互作用，糖敏感性弱；预期为不确定行为）：\n    -   $r = (0.06,\\,0.06,\\,0.06)$,\n    -   $A = \\begin{bmatrix}\n        -0.20  -0.19  -0.19 \\\\\n        -0.19  -0.20  -0.19 \\\\\n        -0.19  -0.19  -0.20\n      \\end{bmatrix}$,\n    -   $b = (0.05,\\,0.00,\\,0.00)$,\n    -   $x(0) = (0.10,\\,0.10,\\,0.10)$。\n\n数值和输出要求：\n-   使用固定的 RK4 步长 $\\Delta t = 0.02$ 天。\n-   在整数天 $t \\in \\{0,1,2,\\dots,21\\}$ 记录每日组成，并使用这些数据构建第 $0$ 天至第 $7$ 天的 $C_{\\mathrm{forward}}$ 和第 $14$ 天至第 $21$ 天的 $C_{\\mathrm{return}}$。\n-   您的程序应生成一行输出，其中包含案例 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$ 的分类结果，按此顺序排列，形式为方括号括起来的逗号分隔列表（例如，$\\big[$result$_A$,result$_B$,result$_C\\big]$）。\n-   最终输出为无单位的整数。", "solution": "用户提供的问题已经过严格验证，并被确定为计算系统生物学中一个适定、有科学依据且客观的挑战。该问题没有矛盾、歧义或故作高深的论述。任务是模拟一个口腔微生物组的广义 Lotka-Volterra (gLV) 模型，分析其对饮食扰动的响应，并根据精确定义的量化指标将结果分类为弹性、迟滞或不确定。\n\n解决方案首先实现必要的计算组件，包括 gLV 模型动力学、一个数值积分器和指定的分析指标。然后将此框架应用于提供的三个不同参数集。\n\n### 1. 建模与数值积分\n\n问题的核心是描述 $S$ 个物种丰度 $x_i(t)$ 的广义 Lotka-Volterra 动态的常微分方程 (ODE) 系统：\n$$\n\\frac{dx_i}{dt} \\;=\\; f_i(x, t) \\;=\\; x_i(t)\\left[r_i \\;+\\; \\sum_{j=1}^{S} A_{ij} x_j(t) \\;+\\; b_i s(t)\\right]\n$$\n这里，$r_i$ 表示物种 $i$ 的内在增长率，$A_{ij}$ 是相互作用矩阵，其中 $A_{ii}$ 表示种内竞争，$A_{ij}$ ($i \\neq j$) 表示种间相互作用，$b_i$ 量化物种 $i$ 对外部因素 $s(t)$ 的敏感性，在此情境中即饮食糖分的可利用性。\n\n糖分可利用性 $s(t)$ 在一个 $21$ 天的周期内遵循一个分段常数计划：\n$$\ns(t) = \\begin{cases} \n1  \\text{若 } 0 \\le t \\le 7 \\quad \\text{(基线)} \\\\\n0  \\text{若 } 7 < t \\le 14 \\quad \\text{(限制)} \\\\\n1  \\text{若 } 14 < t \\le 21 \\quad \\text{(恢复)}\n\\end{cases}\n$$\n为求解此初值问题，我们采用指定的四阶 Runge-Kutta (RK4) 方法。对于光滑向量场，该方法因其准确性和稳定性而成为一种稳健的数值方案。单个 RK4 步骤通过以下方式从时间 $t$ 的状态计算时间 $t+\\Delta t$ 的状态：\n$$\n\\begin{align*}\nk_1 = f(x(t), t) \\\\\nk_2 = f(x(t) + \\frac{\\Delta t}{2} k_1, t + \\frac{\\Delta t}{2}) \\\\\nk_3 = f(x(t) + \\frac{\\Delta t}{2} k_2, t + \\frac{\\Delta t}{2}) \\\\\nk_4 = f(x(t) + \\Delta t k_3, t + \\Delta t) \\\\\nx(t+\\Delta t) = x(t) + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\n此过程以 $\\Delta t=0.02$ 天的固定步长执行。每步之后，通过将任何小于 0 的丰度 $x_i$ 设置为一个小的下限值 $10^{-9}$ 来强制执行非负性约束。此步骤可防止数值伪影将种群数量推向无物理意义的负值。\n\n### 2. 轨迹分析与指标\n\n模拟运行 $21$ 天。在每个整数天 $t_k \\in \\{0, 1, \\dots, 21\\}$，我们记录系统的组成，定义为相对丰度向量：\n$$\np(t_k) = \\frac{x(t_k)}{\\sum_{i=1}^{S} x_i(t_k)}\n$$\n在这个组成空间中，我们关注两条特定的轨迹：\n- $C_{\\mathrm{forward}}$：从第 $0$ 天到第 $7$ 天的组成序列，即 $\\{p(0), p(1), \\dots, p(7)\\}$。\n- $C_{\\mathrm{return}}$：从第 $14$ 天到第 $21$ 天的组成序列，即 $\\{p(14), p(15), \\dots, p(21)\\}$。\n\n为了对系统行为进行分类，计算了两个指标：\n1.  **终点分离度 ($D_{\\mathrm{end}}$)**：该指标量化系统状态是否返回其扰动前的构型。它是基线阶段结束时的组成与恢复阶段结束时组成之间的欧几里得距离：\n    $$\n    D_{\\mathrm{end}} = \\|p(7) - p(21)\\|_2\n    $$\n2.  **路径分离度 ($D_{\\mathrm{path}}$)**：该指标通过测量基线轨迹和返回轨迹的形状相似性来评估路径依赖性。它使用离散 Fréchet 距离计算，概念上讲，这等于连接两个沿着各自路径行走的实体所需的最短牵引绳长度。我们实现所提供的递推关系（一种标准的动态规划算法）来计算 $D_{\\mathrm{path}} = \\mathrm{Fr\\acute{e}chet}(C_{\\mathrm{forward}}, C_{\\mathrm{return}})$。\n\n### 3. 分类\n\n计算出的指标用于根据一组确定性规则对生态结果进行分类：\n- **弹性 (1)**：如果最终状态和返回路径都接近其基线对应物，则系统被分类为弹性。这要求 $D_{\\mathrm{end}} \\le 0.02$ **且** $D_{\\mathrm{path}} \\le 0.05$。\n- **迟滞 (2)**：如果最终状态远离基线平衡点，或返回路径显著偏离基线轨迹，则系统被分类为迟滞。这发生在 $D_{\\mathrm{end}} \\ge 0.10$ **或** $D_{\\mathrm{path}} \\ge 0.12$ 的情况下。\n- **不确定 (0)**：任何不符合弹性和迟滞严格标准的其他结果都归于此类。\n\n### 4. 测试用例的实现\n\n将所述算法系统地应用于三个指定的测试用例。对于案例 A，初始条件 $x(0)$ 未直接给出，而是定义为基线条件 ($s(t)=1$) 下的平衡状态。该状态通过求解线性系统 $A x = -(r + b)$ 找到。对于案例 B 和 C，初始条件 $x(0)$ 是明确提供的。对每个案例执行模拟和分类逻辑以生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Specified in execution environment, but not strictly required for this implementation.\n# from scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"r\": np.array([0.50, 0.45, 0.40]),\n            \"A\": np.array([\n                [-1.00, -0.10, -0.10],\n                [-0.10, -1.10, -0.10],\n                [-0.10, -0.10, -0.90]\n            ]),\n            \"b\": np.array([0.20, -0.05, 0.00]),\n            \"x0\": \"equilibrium\"\n        },\n        {\n            \"name\": \"B\",\n            \"r\": np.array([0.30, 0.30, 0.05]),\n            \"A\": np.array([\n                [-1.00, -1.40, -0.05],\n                [-1.40, -1.00, -0.05],\n                [-0.05, -0.05, -1.00]\n            ]),\n            \"b\": np.array([1.00, -0.15, 0.00]),\n            \"x0\": np.array([1.30, 0.01, 0.02])\n        },\n        {\n            \"name\": \"C\",\n            \"r\": np.array([0.06, 0.06, 0.06]),\n            \"A\": np.array([\n                [-0.20, -0.19, -0.19],\n                [-0.19, -0.20, -0.19],\n                [-0.19, -0.19, -0.20]\n            ]),\n            \"b\": np.array([0.05, 0.00, 0.00]),\n            \"x0\": np.array([0.10, 0.10, 0.10])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation_and_classify(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_s(t):\n    \"\"\"\n    Returns the value of the sugar forcing term s(t) based on time.\n    \"\"\"\n    if t > 14.0:\n        return 1.0\n    elif t > 7.0:\n        return 0.0\n    else:\n        return 1.0\n\ndef glv_rhs(x, t, r, A, b):\n    \"\"\"\n    Computes the right-hand side of the gLV ODE system.\n    dx/dt = x_i * (r_i + sum(A_ij * x_j) + b_i * s(t))\n    \"\"\"\n    s_val = get_s(t)\n    return x * (r + A @ x + b * s_val)\n\ndef rk4_step(func, x, t, dt, r, A, b):\n    \"\"\"\n    Performs a single step of the RK4 method.\n    \"\"\"\n    k1 = func(x, t, r, A, b)\n    k2 = func(x + 0.5 * dt * k1, t + 0.5 * dt, r, A, b)\n    k3 = func(x + 0.5 * dt * k2, t + 0.5 * dt, r, A, b)\n    k4 = func(x + dt * k3, t + dt, r, A, b)\n    x_next = x + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n    return x_next\n\ndef frechet_distance(P, Q):\n    \"\"\"\n    Computes the discrete Fréchet distance between two trajectories P and Q.\n    P and Q are numpy arrays of shape (n_points, n_dims).\n    \"\"\"\n    n = P.shape[0]\n    m = Q.shape[0]\n    # Memoization cache for the coupling measure c(i, j)\n    ca = np.full((n, m), -1.0)\n\n    def dist(i, j):\n        return np.linalg.norm(P[i] - Q[j])\n\n    # Recursive function with memoization to compute c(i, j)\n    def c(i, j):\n        if ca[i, j] > -1.0:\n            return ca[i, j]\n        \n        d_ij = dist(i, j)\n        if i == 0 and j == 0:\n            ca[i, j] = d_ij\n        elif i > 0 and j == 0:\n            ca[i, j] = max(c(i - 1, 0), d_ij)\n        elif i == 0 and j > 0:\n            ca[i, j] = max(c(0, j - 1), d_ij)\n        elif i > 0 and j > 0:\n            ca[i, j] = max(min(c(i - 1, j), c(i - 1, j - 1), c(i, j - 1)), d_ij)\n        else:\n            # This case should not be reached\n            ca[i, j] = float(\"inf\")\n        \n        return ca[i, j]\n\n    return c(n - 1, m - 1)\n\ndef run_simulation_and_classify(case_params):\n    \"\"\"\n    Runs the full gLV simulation for one case, computes metrics, and classifies the outcome.\n    \"\"\"\n    r, A, b = case_params[\"r\"], case_params[\"A\"], case_params[\"b\"]\n    \n    if isinstance(case_params[\"x0\"], str) and case_params[\"x0\"] == \"equilibrium\":\n        # Solve A * x = -(r + b * 1) for equilibrium initial condition\n        x0 = np.linalg.solve(A, -(r + b))\n    else:\n        x0 = case_params[\"x0\"].copy()\n\n    dt = 0.02\n    t_total = 21.0\n    n_steps = int(t_total / dt)\n    steps_per_day = int(1.0 / dt)\n    floor_val = 1e-9\n\n    x = x0\n    t = 0.0\n    \n    daily_compositions = []\n    \n    # Store initial composition at t=0\n    daily_compositions.append(x / x.sum())\n\n    for i in range(n_steps):\n        x = rk4_step(glv_rhs, x, t, dt, r, A, b)\n        \n        # Enforce non-negativity\n        x[x < 0] = floor_val\n        \n        t += dt\n        \n        # Record composition at integer days\n        if (i + 1) % steps_per_day == 0:\n            if np.sum(x) > 0:\n                daily_compositions.append(x / x.sum())\n            else: # Handle case of total extinction\n                daily_compositions.append(np.zeros_like(x))\n\n    # Convert to numpy array for easier slicing\n    daily_compositions = np.array(daily_compositions)\n\n    # Extract trajectories\n    # C_forward: days 0 to 7 (8 points)\n    C_forward = daily_compositions[0:8]\n    # C_return: days 14 to 21 (8 points)\n    C_return = daily_compositions[14:22]\n\n    # Compute metrics\n    # End-point separation: ||p(7) - p(21)||\n    p_7 = daily_compositions[7]\n    p_21 = daily_compositions[21]\n    D_end = np.linalg.norm(p_7 - p_21)\n\n    # Path separation: Fréchet(C_forward, C_return)\n    D_path = frechet_distance(C_forward, C_return)\n    \n    # Classify the outcome\n    if D_end <= 0.02 and D_path <= 0.05:\n        return 1  # Resilient\n    elif D_end >= 0.10 or D_path >= 0.12:\n        return 2  # Hysteretic\n    else:\n        return 0  # Indeterminate\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "4744038"}]}