{"hands_on_practices": [{"introduction": "多变量方差分析（MANOVA）虽然能有效进行整体组间比较，但研究者通常关心更具体的问题。我们可以通过对组均值进行线性对比，并结合响应变量的线性组合，来检验精确且有针对性的假设。这项练习 [@problem_id:4931274] 将教你如何将一个具体的科学问题转化为MANOVA的数学语言，这是在实际研究中应用统计学的关键一步。", "problem": "一项随机生物统计学研究比较了三个组：对照组（$C$）、处理组 $A$（$T_A$）和处理组 $B$（$T_B$）。对于每位参与者，测量了三种炎症生物标志物：白细胞介素-6（$\\mathrm{IL}\\text{-}6$）、C-反应蛋白（$\\mathrm{CRP}$）和肿瘤坏死因子-α（$\\mathrm{TNF}\\text{-}\\alpha$）。假设设计具有相等的组大小，每组有 $n$ 个重复，多元方差分析（MANOVA）的单元格均值模型成立，且组内协方差结构在各组间是共同的。\n\n根据经验，观察到的组均值向量（单位任意）如下：\n$$\n\\bar{\\mathbf{y}}_{C} = \\begin{pmatrix} 2.1 \\\\ 3.5 \\\\ 1.8 \\end{pmatrix}, \\quad\n\\bar{\\mathbf{y}}_{T_A} = \\begin{pmatrix} 2.8 \\\\ 4.0 \\\\ 2.2 \\end{pmatrix}, \\quad\n\\bar{\\mathbf{y}}_{T_B} = \\begin{pmatrix} 2.5 \\\\ 3.8 \\\\ 2.0 \\end{pmatrix},\n$$\n其中每组 $n = 12$。合并的组内协方差矩阵为\n$$\n\\mathbf{S} = \\begin{pmatrix}\n0.16  & 0.10  & 0.08 \\\\\n0.10  & 0.25  & 0.12 \\\\\n0.08  & 0.12  & 0.20\n\\end{pmatrix}.\n$$\n\n研究人员提出了一个科学问题：“在一个对 $\\mathrm{IL}\\text{-}6$ 加权的综合炎症评分上，处理组 $A$ 和 $B$ 的平均值是否高于对照组？”将此科学问题编码为一个跨组的对比和一个响应权重矩阵，然后计算相关的假设平方和与叉積（SSCP）量以及该标量效应对应的单变量 $F$ 型检验统计量。\n\n具体而言：\n- 将组对比编码为一个作用于单元格均值 $\\mathbf{B} \\in \\mathbb{R}^{3 \\times 3}$ 的行向量 $\\mathbf{L} \\in \\mathbb{R}^{1 \\times 3}$，使得 $\\mathbf{L}\\mathbf{B}$ 表示“$T_A$ 和 $T_B$ 的平均值减去 $C$”。\n- 使用具有以下权重的响应权重矩阵 $\\mathbf{M} \\in \\mathbb{R}^{3 \\times 1}$ 来编码综合炎症评分：\n$$\n\\mathbf{M} = \\begin{pmatrix} 0.5 \\\\ 0.3 \\\\ 0.2 \\end{pmatrix}.\n$$\n\n假设为单向平衡单元格均值设计，其中 $\\mathbf{X}^{\\top}\\mathbf{X} = n\\,\\mathbf{I}_{3}$。使用这些编码，计算与 $(\\mathbf{L}, \\mathbf{M})$ 对应的标量假设 SSCP $H$，然后计算此效应的单变量 $F$ 型检验统计量，其计算方法是用 $H$ 除以加权响应的适当误差均方。仅报告最终的 $F$ 型检验统计量值。将您的答案四舍五入到四位有效数字。", "solution": "用户想要验证并解决一个涉及单向多元方差分析（MANOVA）的生物统计学问题。\n\n### 第一步：提取已知条件\n-   **组**：对照组（$C$）、处理组 $A$（$T_A$）、处理组 $B$（$T_B$）。组数 $k=3$。\n-   **生物标志物**：白细胞介素-6（$\\mathrm{IL}\\text{-}6$）、C-反应蛋白（$\\mathrm{CRP}$）和肿瘤坏死因子-α（$\\mathrm{TNF}\\text{-}\\alpha$）。因变量数 $p=3$。\n-   **样本量**：组大小相等，每组有 $n = 12$ 个重复。总样本量 $N = nk = 36$。\n-   **模型**：单向平衡单元格均值MANOVA模型，共同的组内协方差结构。\n-   **组均值向量**：\n    $$ \\bar{\\mathbf{y}}_{C} = \\begin{pmatrix} 2.1 \\\\ 3.5 \\\\ 1.8 \\end{pmatrix}, \\quad \\bar{\\mathbf{y}}_{T_A} = \\begin{pmatrix} 2.8 \\\\ 4.0 \\\\ 2.2 \\end{pmatrix}, \\quad \\bar{\\mathbf{y}}_{T_B} = \\begin{pmatrix} 2.5 \\\\ 3.8 \\\\ 2.0 \\end{pmatrix} $$\n-   **合并的组内协方差矩阵**：\n    $$ \\mathbf{S} = \\begin{pmatrix} 0.16  & 0.10  & 0.08 \\\\ 0.10  & 0.25  & 0.12 \\\\ 0.08  & 0.12  & 0.20 \\end{pmatrix} $$\n-   **组对比向量**：$\\mathbf{L} \\in \\mathbb{R}^{1 \\times 3}$，表示“$T_A$ 和 $T_B$ 的平均值减去 $C$”。\n-   **响应权重矩阵**：\n    $$ \\mathbf{M} = \\begin{pmatrix} 0.5 \\\\ 0.3 \\\\ 0.2 \\end{pmatrix} $$\n-   **设计矩阵属性**：$\\mathbf{X}^{\\top}\\mathbf{X} = n\\,\\mathbf{I}_{3} = 12\\,\\mathbf{I}_{3}$。\n\n### 第二步：使用提取的已知条件进行验证\n-   **科学依据**：该问题是MANOVA在生物统计学中的一个标准应用。实验设计（随机研究）、变量（炎症生物标志物）和统计模型都是常见且科学合理的。\n-   **适定性**：问题定义明确。它提供了计算特定检验统计量的所有必要数值和清晰指令。合并的协方差矩阵 $\\mathbf{S}$ 是对称的，并且可以验证为正定矩阵，因此是一个有效的协方差矩阵。\n-   **客观性**：问题以精确、客观的数学和统计术语陈述。\n\n该问题不包含科学上的不合理之处、缺失信息、矛盾或歧义。这是一个形式化的、可解的生物统计学问题。\n\n### 第三步：结论与行动\n该问题有效。将提供一个完整的、有理有据的解决方案。\n\n### 解\n\n该问题要求在MANOVA框架内计算一个特定假设的单变量 $F$ 型检验统计量。该假设涉及跨组的对比和响应变量的线性组合。这是一个双重单变量假设的检验。\n\nMANOVA的一般线性模型由 $\\mathbf{Y} = \\mathbf{X}\\mathbf{B} + \\mathbf{E}$ 给出，其中 $\\mathbf{B}$ 是真实单元格均值的矩阵。$\\mathbf{B}$ 的估计是 $\\hat{\\mathbf{B}}$，它是一个 $k \\times p$ 矩阵，其行是组均值向量。将各组按（$C$，$T_A$，$T_B$）排序，我们有：\n$$ \\hat{\\mathbf{B}} = \\begin{pmatrix} \\bar{\\mathbf{y}}_{C}^{\\top} \\\\ \\bar{\\mathbf{y}}_{T_A}^{\\top} \\\\ \\bar{\\mathbf{y}}_{T_B}^{\\top} \\end{pmatrix} = \\begin{pmatrix} 2.1  & 3.5  & 1.8 \\\\ 2.8  & 4.0  & 2.2 \\\\ 2.5  & 3.8  & 2.0 \\end{pmatrix} $$\n假设的形式为 $\\mathbf{LBM} = \\mathbf{0}$。\n\n科学问题“处理组 $A$ 和 $B$ 的平均值是否高于对照组”对应于对比 $\\frac{1}{2}\\mu_{T_A} + \\frac{1}{2}\\mu_{T_B} - \\mu_{C}$。对比向量 $\\mathbf{L}$ 作用于 $\\hat{\\mathbf{B}}$ 的行，为：\n$$ \\mathbf{L} = \\begin{pmatrix} -1  & 0.5  & 0.5 \\end{pmatrix} $$\n综合炎症评分是生物标志物的线性组合，其权重由响应权重矩阵 $\\mathbf{M}$ 给出：\n$$ \\mathbf{M} = \\begin{pmatrix} 0.5 \\\\ 0.3 \\\\ 0.2 \\end{pmatrix} $$\n此特定效应的单变量 $F$ 型检验统计量是转换后变量的假设均方（$MS_H$）与误差均方（$MS_E$）之比。\n$$ F = \\frac{MS_H}{MS_E} $$\n该假设有 $df_H = \\text{rank}(\\mathbf{L}) = 1$ 的自由度。因此，$MS_H = H / df_H = H$，其中 $H$ 是标量假设平方和。\n\n首先，我们计算假设平方和 $H$。它由以下公式给出：\n$$ H = \\left( \\mathbf{L}\\hat{\\mathbf{B}}\\mathbf{M} \\right)^{\\top} \\left( \\mathbf{L}(\\mathbf{X}^{\\top}\\mathbf{X})^{-1}\\mathbf{L}^{\\top} \\right)^{-1} \\left( \\mathbf{L}\\hat{\\mathbf{B}}\\mathbf{M} \\right) $$\n令 $\\hat{\\psi} = \\mathbf{L}\\hat{\\mathbf{B}}\\mathbf{M}$ 为效应的标量估计。\n$$ \\mathbf{L}\\hat{\\mathbf{B}} = \\begin{pmatrix} -1  & 0.5  & 0.5 \\end{pmatrix} \\begin{pmatrix} 2.1  & 3.5  & 1.8 \\\\ 2.8  & 4.0  & 2.2 \\\\ 2.5  & 3.8  & 2.0 \\end{pmatrix} $$\n$$ \\mathbf{L}\\hat{\\mathbf{B}} = \\begin{pmatrix} (-1)(2.1) + (0.5)(2.8) + (0.5)(2.5)  & (-1)(3.5) + (0.5)(4.0) + (0.5)(3.8)  & (-1)(1.8) + (0.5)(2.2) + (0.5)(2.0) \\end{pmatrix} $$\n$$ \\mathbf{L}\\hat{\\mathbf{B}} = \\begin{pmatrix} -2.1 + 1.4 + 1.25  & -3.5 + 2.0 + 1.9  & -1.8 + 1.1 + 1.0 \\end{pmatrix} $$\n$$ \\mathbf{L}\\hat{\\mathbf{B}} = \\begin{pmatrix} 0.55  & 0.4  & 0.3 \\end{pmatrix} $$\n现在，我们计算 $\\hat{\\psi}$：\n$$ \\hat{\\psi} = (\\mathbf{L}\\hat{\\mathbf{B}})\\mathbf{M} = \\begin{pmatrix} 0.55  & 0.4  & 0.3 \\end{pmatrix} \\begin{pmatrix} 0.5 \\\\ 0.3 \\\\ 0.2 \\end{pmatrix} $$\n$$ \\hat{\\psi} = (0.55)(0.5) + (0.4)(0.3) + (0.3)(0.2) = 0.275 + 0.120 + 0.060 = 0.455 $$\n接下来，我们计算涉及设计矩阵的标量项：\n$$ \\mathbf{L}(\\mathbf{X}^{\\top}\\mathbf{X})^{-1}\\mathbf{L}^{\\top} = \\mathbf{L} \\left(\\frac{1}{n}\\mathbf{I}_{3}\\right) \\mathbf{L}^{\\top} = \\frac{1}{12} \\mathbf{L}\\mathbf{L}^{\\top} $$\n$$ \\mathbf{L}\\mathbf{L}^{\\top} = \\begin{pmatrix} -1  & 0.5  & 0.5 \\end{pmatrix} \\begin{pmatrix} -1 \\\\ 0.5 \\\\ 0.5 \\end{pmatrix} = (-1)^2 + (0.5)^2 + (0.5)^2 = 1 + 0.25 + 0.25 = 1.5 $$\n$$ \\mathbf{L}(\\mathbf{X}^{\\top}\\mathbf{X})^{-1}\\mathbf{L}^{\\top} = \\frac{1.5}{12} = \\frac{3/2}{12} = \\frac{3}{24} = \\frac{1}{8} $$\n其逆为 $(\\frac{1}{8})^{-1} = 8$。\n现在，我们可以计算 $H$：\n$$ H = (\\hat{\\psi})^2 \\cdot 8 = (0.455)^2 \\cdot 8 = 0.207025 \\cdot 8 = 1.6562 $$\n这是假设平方和。由于 $df_H = 1$，所以 $MS_H = 1.6562$。\n\n其次，我们计算综合炎症评分的误差均方 $MS_E$。这是转换后变量 $U = \\mathbf{Y}^\\top \\mathbf{M}$ 的合并组内方差，由以下公式给出：\n$$ MS_E = \\mathbf{M}^{\\top}\\mathbf{S}\\mathbf{M} $$\n我们有：\n$$ \\mathbf{S} = \\begin{pmatrix} 0.16  & 0.10  & 0.08 \\\\ 0.10  & 0.25  & 0.12 \\\\ 0.08  & 0.12  & 0.20 \\end{pmatrix}, \\quad \\mathbf{M} = \\begin{pmatrix} 0.5 \\\\ 0.3 \\\\ 0.2 \\end{pmatrix} $$\n首先，计算 $\\mathbf{S}\\mathbf{M}$：\n$$ \\mathbf{S}\\mathbf{M} = \\begin{pmatrix} (0.16)(0.5) + (0.10)(0.3) + (0.08)(0.2) \\\\ (0.10)(0.5) + (0.25)(0.3) + (0.12)(0.2) \\\\ (0.08)(0.5) + (0.12)(0.3) + (0.20)(0.2) \\end{pmatrix} = \\begin{pmatrix} 0.08 + 0.03 + 0.016 \\\\ 0.05 + 0.075 + 0.024 \\\\ 0.04 + 0.036 + 0.04 \\end{pmatrix} = \\begin{pmatrix} 0.126 \\\\ 0.149 \\\\ 0.116 \\end{pmatrix} $$\n然后，计算 $MS_E = \\mathbf{M}^{\\top}(\\mathbf{S}\\mathbf{M})$：\n$$ MS_E = \\begin{pmatrix} 0.5  & 0.3  & 0.2 \\end{pmatrix} \\begin{pmatrix} 0.126 \\\\ 0.149 \\\\ 0.116 \\end{pmatrix} $$\n$$ MS_E = (0.5)(0.126) + (0.3)(0.149) + (0.2)(0.116) = 0.063 + 0.0447 + 0.0232 = 0.1309 $$\n最后，我们计算 $F$ 统计量：\n$$ F = \\frac{MS_H}{MS_E} = \\frac{1.6562}{0.1309} \\approx 12.652406417... $$\n将结果四舍五入到四位有效数字，我们得到 $12.65$。", "answer": "$$\\boxed{12.65}$$", "id": "4931274"}, {"introduction": "MANOVA结果的有效性取决于关键的假设和数据质量，其中异常值是一个主要威胁。马氏距离（Mahalanobis distance）通过测量观测值与其所在组中心的距离（同时考虑变量间的相关结构），为检测多维异常值提供了有力工具。通过这个编程练习 [@problem_id:4931275]，你将亲手实现一个重要的数据诊断流程，并直接观察异常值对MANOVA检验统计量的影响，从而理解数据审查的重要性。", "problem": "给定一个单因素多变量方差分析 (MANOVA) 的设定，其包含多变量响应和分类组。从线性模型和多变量协方差结构的核心定义出发，实现一个基于残差的 Mahalanobis 距离的诊断方法，以识别多变量异常值，并量化它们对误差平方和与叉积 (SSCP) 矩阵以及标准 MANOVA 检验统计量的影响。\n\n基本原理和定义：\n- 在单因素 MANOVA 模型下，每个观测向量表示为 $Y_{ij} \\in \\mathbb{R}^p$，其中 $j \\in \\{1,\\dots,g\\}$ 为组的索引，$i \\in \\{1,\\dots,n_j\\}$ 为组 $j$ 内观测值的索引。总样本量为 $N = \\sum_{j=1}^g n_j$，响应维度为 $p$。\n- 设组均值向量为 $\\mu_j \\in \\mathbb{R}^p$，总均值向量为 $\\bar{\\mu} \\in \\mathbb{R}^p$。残差定义为 $R_{ij} = Y_{ij} - \\mu_j$。\n- 合并误差 SSCP 矩阵 $E \\in \\mathbb{R}^{p \\times p}$ 由残差构建，假设 SSCP 矩阵 $H \\in \\mathbb{R}^{p \\times p}$ 由组均值相对于总均值的差异构建。\n- 合并残差协方差矩阵定义为 $S_e = E / (N - g)$。\n- 残差 $R_{ij}$ 相对于合并残差协方差的平方 Mahalanobis 距离为 $D^2_{ij}$，该距离用于检测异常值，其阈值源自自由度为 $p$ 的卡方分布。\n\n任务：\n1. 对于每个测试用例，使用组样本均值计算残差 $R_{ij}$，计算合并误差 SSCP 矩阵 $E$ 和假设 SSCP 矩阵 $H$。\n2. 使用合并残差协方差矩阵 $S_e$，计算所有观测值的平方 Mahalanobis 距离 $D^2_{ij}$。如果观测值的 $D^2_{ij}$ 超过了显著性水平为 $(1-\\alpha)$、自由度为 $p$ 的卡方分布上分位数，则将其标记为异常值。\n3. 使用从当前数据集构建的 $E$ 和 $H$ 矩阵，在移除标记的异常值前后，计算以下标准 MANOVA 检验统计量：\n   - Wilks 统计量 (也称为 Wilks' Lambda)。\n   - Pillai 迹。\n   - Hotelling–Lawley 迹。\n   - Roy 最大根。\n4. 对于每个测试用例，输出标记的异常值数量以及移除异常值后上述四种检验统计量的变化，变化量计算为移除后的值减去移除前的值。\n\n科学真实性要求：\n- 所有计算必须基于线性模型结构和多变量协方差定义，不得依赖问题陈述中的简化公式。\n\n测试套件：\n使用以下三个测试用例。每个测试用例将响应矩阵 $Y$ 指定为一个向量的有序列表，并将相应的组标签指定为一个整数的有序列表。提供了用于异常值阈值化的显著性水平 $\\alpha$。\n\n- 测试用例 1 (理想路径，$p=2$，三个组，预计无异常值，$\\alpha=0.01$)：\n  - $Y$ 包含 $N=15$ 个在 $\\mathbb{R}^2$ 中的观测值，按组排序如下：\n    - 第 $0$ 组 ($n_0=5$)：\n      - $(0.1, -0.2)$, $(-0.3, 0.2)$, $(0.2, 0.1)$, $(-0.1, -0.1)$, $(0.05, 0.0)$\n    - 第 $1$ 组 ($n_1=5$)：\n      - $(2.1, 1.0)$, $(1.9, 1.1)$, $(2.2, 0.9)$, $(2.0, 1.2)$, $(2.05, 1.05)$\n    - 第 $2$ 组 ($n_2=5$)：\n      - $(-1.1, 2.9)$, $(-0.9, 3.1)$, $(-1.2, 3.0)$, $(-0.8, 3.2)$, $(-1.0, 2.8)$\n  - 组标签 (按与 $Y$ 对齐的顺序排列)：`[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2]`\n  - $\\alpha = 0.01$\n\n- 测试用例 2 (存在异常值，$p=2$，三个组，$\\alpha=0.01$)：\n  - $Y$ 包含 $N=16$ 个在 $\\mathbb{R}^2$ 中的观测值，按组排序如下：\n    - 第 $0$ 组 ($n_0=5$)：\n      - $(0.1, -0.2)$, $(-0.3, 0.2)$, $(0.2, 0.1)$, $(-0.1, -0.1)$, $(0.05, 0.0)$\n    - 第 $1$ 组 ($n_1=6$)：前五个与测试用例1相同，外加一个异常值\n      - $(2.1, 1.0)$, $(1.9, 1.1)$, $(2.2, 0.9)$, $(2.0, 1.2)$, $(2.05, 1.05)$, $(6.0, -3.0)$\n    - 第 $2$ 组 ($n_2=5$)：\n      - $(-1.1, 2.9)$, $(-0.9, 3.1)$, $(-1.2, 3.0)$, $(-0.8, 3.2)$, $(-1.0, 2.8)$\n  - 组标签 (按与 $Y$ 对齐的顺序排列)：`[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2]`\n  - $\\alpha = 0.01$\n\n- 测试用例 3 (不同维度，$p=3$，两个组，预计无异常值，$\\alpha=0.05$)：\n  - $Y$ 包含 $N=11$ 个在 $\\mathbb{R}^3$ 中的观测值，按组排序如下：\n    - 第 $0$ 组 ($n_0=6$)：\n      - $(0.2, -0.1, 0.05)$, $(-0.2, 0.1, -0.1)$, $(0.1, 0.0, 0.2)$, $(0.0, -0.2, 0.1)$, $(0.15, 0.05, -0.05)$, $(-0.1, 0.2, 0.0)$\n    - 第 $1$ 组 ($n_1=5$)：\n      - $(1.1, 0.9, -1.1)$, $(0.9, 1.2, -0.8)$, $(1.2, 1.0, -1.2)$, $(1.0, 1.1, -1.0)$, $(1.05, 0.95, -1.05)$\n  - 组标签 (按与 $Y$ 对齐的顺序排列)：`[0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]`\n  - $\\alpha = 0.05$\n\n要求的最终输出格式：\n- 对于每个测试用例，计算：\n  - 标记的异常值的整数数量，\n  - 四个浮点数值，分别为 Wilks 统计量、Pillai 迹、Hotelling–Lawley 迹和 Roy 最大根的差值，计算方式为移除标记的异常值后的值减去移除前的值。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且本身也是一个列表，顺序为 $[\\text{count}, \\Delta\\text{Wilks}, \\Delta\\text{Pillai}, \\Delta\\text{HL}, \\Delta\\text{Roy}]$。例如：`[[c_1, d_1,1, d_1,2, d_1,3, d_1,4], [c_2, d_2,1, d_2,2, d_2,3, d_2,4], [c_3, d_3,1, d_3,2, d_3,3, d_3,4]]`。", "solution": "该问题要求为单因素多变量方差分析 (MANOVA) 模型实现一个异常值检测诊断方法。这包括计算残差的 Mahalanobis 距离，基于卡方分布阈值识别异常值，并量化它们对标准 MANOVA 检验统计量的影响。解决方案将从线性模型和协方差结构的基本定义出发进行开发。\n\n首先，我们建立单因素 MANOVA 的数学框架。\n设 $Y_{ij} \\in \\mathbb{R}^p$ 为第 $j$ 组中第 $i$ 个受试者的 $p$ 维响应向量，其中 $i \\in \\{1, \\dots, n_j\\}$，$j \\in \\{1, \\dots, g\\}$。总观测数为 $N = \\sum_{j=1}^g n_j$。\n\n该模型假设 $Y_{ij} = \\mu_j + \\epsilon_{ij}$，其中 $\\mu_j$ 是第 $j$ 组的均值向量，$\\epsilon_{ij}$ 是独立的随机误差向量，其均值为 $0$，并具有一个共同的协方差矩阵 $\\Sigma$。在实践中，真实均值 $\\mu_j$ 和总均值 $\\bar{\\mu}$ 是未知的，需要从数据中估计。\n\n样本估计量为：\n- 组均值向量：$\\bar{Y}_j = \\frac{1}{n_j} \\sum_{i=1}^{n_j} Y_{ij}$\n- 总均值向量：$\\bar{Y} = \\frac{1}{N} \\sum_{j=1}^g \\sum_{i=1}^{n_j} Y_{ij} = \\frac{1}{N} \\sum_{j=1}^g n_j \\bar{Y}_j$\n\n基于这些估计量，我们构建两个基本矩阵，即平方和与叉积 (SSCP) 矩阵：\n1.  **假设 SSCP 矩阵 ($H$)** 用于量化组间变异：\n    $$H = \\sum_{j=1}^g n_j (\\bar{Y}_j - \\bar{Y})(\\bar{Y}_j - \\bar{Y})^T$$\n2.  **误差 SSCP 矩阵 ($E$)** 用于量化组内变异：\n    $$E = \\sum_{j=1}^g \\sum_{i=1}^{n_j} (Y_{ij} - \\bar{Y}_j)(Y_{ij} - \\bar{Y}_j)^T$$\n$E$ 矩阵是 $(N-g)\\Sigma$ 的一个估计量。总变异由总 SSCP 矩阵 $T = H + E$ 捕获。\n\n为了检测异常值，我们分析残差 $R_{ij} = Y_{ij} - \\bar{Y}_j$。公共误差协方差矩阵 $\\Sigma$ 的一个无偏估计是合并残差协方差矩阵 $S_e$：\n$$S_e = \\frac{E}{N-g}$$\n残差 $R_{ij}$ 的平方 Mahalanobis 距离衡量了其与中心（均值为 0 的残差）的距离，并根据协方差结构进行了调整：\n$$D^2_{ij} = (Y_{ij} - \\bar{Y}_j)^T S_e^{-1} (Y_{ij} - \\bar{Y}_j)$$\n在误差服从多变量正态分布的假设下，$D^2_{ij}$ 近似服从自由度为 $p$ 的卡方分布。如果观测值 $Y_{ij}$ 对应的 $D^2_{ij}$ 异常大，则将其标记为潜在的异常值。我们使用 $\\chi^2_p$ 分布的上 $(1-\\alpha)$ 分位数作为阈值：\n$$\\text{若 } D^2_{ij} > \\chi^2_{p, 1-\\alpha} \\text{ 则为异常值}$$\n\n标准 MANOVA 检验统计量用于检验原假设 $H_0: \\mu_1 = \\mu_2 = \\dots = \\mu_g$。这些统计量是矩阵 $E^{-1}H$ 的特征值的函数。设非零特征值为 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_s$，其中 $s = \\min(p, g-1)$。这四种统计量是：\n1.  **Wilks' Lambda**: $\\Lambda = \\det(E) / \\det(E+H) = \\prod_{k=1}^s \\frac{1}{1+\\lambda_k}$。它表示未被组间差异解释的总方差比例。值越接近 $0$ 表示组间差异越显著。\n2.  **Pillai 迹**: $V = \\text{tr}((E+H)^{-1}H) = \\sum_{k=1}^s \\frac{\\lambda_k}{1+\\lambda_k}$。它表示被解释的方差比例。值越接近 $s$ 表示组间差异越显著。\n3.  **Hotelling-Lawley 迹**: $T_{HL} = \\text{tr}(E^{-1}H) = \\sum_{k=1}^s \\lambda_k$。它是特征值的总和。\n4.  **Roy 最大根**: $\\Theta = \\lambda_1$。它是最大的特征值，关注于单一维度上的最大组间差异。\n\n解决该问题的算法对每个测试用例分为两个主要阶段进行：\n\n**阶段 1：对完整数据集进行分析**\n1.  给定数据矩阵 $Y$ 和组标签，计算每个组的 $p$、$g$、$N$ 和 $n_j$。\n2.  计算样本组均值 $\\bar{Y}_j$ 和总样本均值 $\\bar{Y}$。\n3.  使用其定义构建 SSCP 矩阵 $H$ 和 $E$。\n4.  计算 $E^{-1}H$ 的特征值，并计算四种 MANOVA 检验统计量 (Wilks, Pillai, Hotelling-Lawley, Roy)。这些是“移除前”的值。\n5.  计算合并协方差矩阵 $S_e = E / (N-g)$ 及其逆矩阵 $S_e^{-1}$。\n6.  对于每个观测值 $Y_{ij}$，计算平方 Mahalanobis 距离 $D^2_{ij} = (Y_{ij} - \\bar{Y}_j)^T S_e^{-1} (Y_{ij} - \\bar{Y}_j)$。\n7.  将每个 $D^2_{ij}$ 与临界值 $\\chi^2_{p, 1-\\alpha}$ 进行比较，以识别和计数异常值。\n\n**阶段 2：对简化数据集进行分析和比较**\n1.  如果在阶段 1 中没有标记任何异常值，则统计量的变化为 $0$。\n2.  如果找到异常值，则通过移除所有标记的观测值来创建一个新的数据集。\n3.  为此简化数据集重新计算所有量：新的样本量 ($N'$, $n_j'$), 新的均值 ($\\bar{Y}_j'$, $\\bar{Y}'$) 和新的 SSCP 矩阵 ($H'$, $E'$)。\n4.  使用新矩阵再次计算四种 MANOVA 检验统计量。这些是“移除后”的值。\n5.  对于四种统计量中的每一种，计算其变化量，即 (移除后的值) - (移除前的值)。\n\n此过程提供了异常值的数量及其对 MANOVA 检验结果影响的定量度量，从而满足了问题的所有要求。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to solve the MANOVA outlier diagnostic problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"Y\": np.array([\n                [0.1, -0.2], [-0.3, 0.2], [0.2, 0.1], [-0.1, -0.1], [0.05, 0.0],\n                [2.1, 1.0], [1.9, 1.1], [2.2, 0.9], [2.0, 1.2], [2.05, 1.05],\n                [-1.1, 2.9], [-0.9, 3.1], [-1.2, 3.0], [-0.8, 3.2], [-1.0, 2.8]\n            ]),\n            \"labels\": np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2]),\n            \"alpha\": 0.01\n        },\n        {\n            \"Y\": np.array([\n                [0.1, -0.2], [-0.3, 0.2], [0.2, 0.1], [-0.1, -0.1], [0.05, 0.0],\n                [2.1, 1.0], [1.9, 1.1], [2.2, 0.9], [2.0, 1.2], [2.05, 1.05], [6.0, -3.0],\n                [-1.1, 2.9], [-0.9, 3.1], [-1.2, 3.0], [-0.8, 3.2], [-1.0, 2.8]\n            ]),\n            \"labels\": np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2]),\n            \"alpha\": 0.01\n        },\n        {\n            \"Y\": np.array([\n                [0.2, -0.1, 0.05], [-0.2, 0.1, -0.1], [0.1, 0.0, 0.2], [0.0, -0.2, 0.1],\n                [0.15, 0.05, -0.05], [-0.1, 0.2, 0.0],\n                [1.1, 0.9, -1.1], [0.9, 1.2, -0.8], [1.2, 1.0, -1.2], [1.0, 1.1, -1.0],\n                [1.05, 0.95, -1.05]\n            ]),\n            \"labels\": np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]),\n            \"alpha\": 0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        Y_data, labels, alpha = case[\"Y\"], case[\"labels\"], case[\"alpha\"]\n        p = Y_data.shape[1]\n\n        # --- Stage 1: Analysis on Full Dataset ---\n        metrics_before = _calculate_manova_metrics(Y_data, labels)\n        stats_before = [\n            metrics_before['wilks'], metrics_before['pillai'],\n            metrics_before['hl'], metrics_before['roy']\n        ]\n        \n        N, g = metrics_before['N'], metrics_before['g']\n        E = metrics_before['E']\n        \n        # Outlier Detection\n        outlier_indices = []\n        if N - g > p:\n            S_e = E / (N - g)\n            try:\n                S_e_inv = np.linalg.inv(S_e)\n                threshold = chi2.ppf(1 - alpha, df=p)\n                \n                for i in range(N):\n                    obs = Y_data[i, :]\n                    group_label = labels[i]\n                    group_mean = metrics_before['group_means'][group_label]\n                    residual = obs - group_mean\n                    d_squared = residual.T @ S_e_inv @ residual\n                    if d_squared > threshold:\n                        outlier_indices.append(i)\n            except np.linalg.LinAlgError:\n                # S_e is singular, cannot perform outlier detection.\n                pass\n\n        num_outliers = len(outlier_indices)\n\n        # --- Stage 2: Analysis on Reduced Dataset ---\n        if num_outliers > 0:\n            Y_after = np.delete(Y_data, outlier_indices, axis=0)\n            labels_after = np.delete(labels, outlier_indices, axis=0)\n            metrics_after = _calculate_manova_metrics(Y_after, labels_after)\n            stats_after = [\n                metrics_after['wilks'], metrics_after['pillai'],\n                metrics_after['hl'], metrics_after['roy']\n            ]\n        else:\n            stats_after = stats_before\n\n        delta_stats = [s_after - s_before for s_before, s_after in zip(stats_before, stats_after)]\n        \n        results.append([num_outliers] + delta_stats)\n\n    # Format the final output string without spaces within lists\n    inner_parts = []\n    for res_list in results:\n        inner_str = '[' + ','.join(f\"{x:.10f}\" if isinstance(x, float) else str(x) for x in res_list) + ']'\n        inner_parts.append(inner_str)\n    final_str = '[' + ','.join(inner_parts) + ']'\n    print(final_str)\n\ndef _calculate_manova_metrics(Y, labels):\n    \"\"\"\n    Helper function to calculate MANOVA metrics for a given dataset.\n    \"\"\"\n    if Y.shape[0] == 0:\n        p = Y.shape[1] if Y.ndim > 1 else 0\n        return {'wilks': 0.0, 'pillai': 0.0, 'hl': 0.0, 'roy': 0.0,\n                'E': np.zeros((p, p)), 'group_means': {}, 'N': 0, 'g': 0}\n\n    p = Y.shape[1]\n    N = Y.shape[0]\n    unique_labels = sorted(list(np.unique(labels)))\n    g = len(unique_labels)\n    \n    group_means = {label: Y[labels == label].mean(axis=0) for label in unique_labels}\n    \n    # Error SSCP matrix E\n    E = np.zeros((p, p))\n    for label in unique_labels:\n        group_data = Y[labels == label]\n        if group_data.shape[0] > 0:\n            residuals = group_data - group_means[label]\n            E += residuals.T @ residuals\n\n    # If N-g  p, E is singular, cannot compute test statistics meaningfully.\n    # Return E for Mahalanobis dist calculation but stats as NaN/default.\n    if N - g  p or g == 1:\n        stats = {'wilks': 1.0, 'pillai': 0.0, 'hl': 0.0, 'roy': 0.0}\n        return {**stats, 'E': E, 'group_means': group_means, 'N': N, 'g': g}\n\n    # Hypothesis SSCP matrix H\n    overall_mean = Y.mean(axis=0)\n    H = np.zeros((p, p))\n    for label in unique_labels:\n        n_j = np.sum(labels == label)\n        mean_diff = group_means[label] - overall_mean\n        H += n_j * np.outer(mean_diff, mean_diff)\n    \n    try:\n        E_inv_H = np.linalg.inv(E) @ H\n        eigenvalues = np.linalg.eigvals(E_inv_H)\n    except np.linalg.LinAlgError:\n        stats = {'wilks': np.nan, 'pillai': np.nan, 'hl': np.nan, 'roy': np.nan}\n        return {**stats, 'E': E, 'group_means': group_means, 'N': N, 'g': g}\n\n    eigenvalues = np.sort(np.real(eigenvalues))[::-1]\n    eigenvalues[eigenvalues  0] = 0.0\n    \n    s = min(p, g - 1)\n    # Use only the s largest eigenvalues\n    eigvals = eigenvalues[:s]\n    \n    stats = {\n        'wilks': np.prod(1 / (1 + eigvals)),\n        'pillai': np.sum(eigvals / (1 + eigvals)),\n        'hl': np.sum(eigvals),\n        'roy': eigvals[0] if len(eigvals) > 0 else 0.0\n    }\n    \n    return {**stats, 'E': E, 'group_means': group_means, 'N': N, 'g': g}\n\n\nsolve()\n```", "id": "4931275"}, {"introduction": "经典的MANOVA检验依赖于数据服从多元正态分布的假设，但在实际应用中这一假设常常难以满足。置换检验（Permutation test）通过对数据标签进行反复重排来经验性地构建原假设下的精确零分布，提供了一种稳健的非参数替代方法。这项高级练习 [@problem_id:4931288] 将指导你从头开始实现一个置换检验，这不仅能加深你对假设检验核心逻辑的理解，也为你分析不满足标准假设的数据提供了强大的工具。", "problem": "给定一个具有 $g$ 个组和 $p$ 维结果变量的单因素多元方差分析 (MANOVA) 设定。在所有组均值向量相等的原假设下，并假设误差独立同分布且具有一个公共协方差矩阵，请为单因素 MANOVA 构建一个针对 Pillai 的 $V$ 统计量的置换检验。您的任务是实现一个程序，对所提供套件中的每个测试用例，通过穷举所有保持组样本量不变的不同重新标记方式，计算精确的置换 $p$ 值。\n\n您的程序必须使用以下原则来定义该检验：\n- 可交换性群：在原假设下，观测标签是可交换的。在单因素设计中，可交换性群是对组标签进行操作的 $n$ 个观测索引的所有置换的集合，其限制条件是重新标记必须保持观测到的组样本量不变。等价地，这是将 $n$ 个标签分配到 $g$ 个组中，且各组计数等于观测到的组计数的所有不同分配方式的集合。\n- 检验统计量：使用根据数据和标签计算的单因素 MANOVA 的 Pillai $V$ 统计量。您必须仅使用组样本均值、组内平方和与交叉乘积以及组间平方和与交叉乘积从数据中精确计算 Pillai 的 $V$。您的方法必须是数值稳定的，并且可以使用任何不依赖于对病态矩阵求逆的数学上等价的计算方法。\n- 置换检验：计算观测到的 Pillai $V$ 值，然后穷举所有与观测到的组大小一致的不同标记方式。对于每种标记方式，重新计算 Pillai 的 $V$。精确置换 $p$ 值是置换后的统计量大于或等于观测统计量的置换所占的比例。使用包含上尾部。\n\n测试套件：\n对于下述每个案例，程序必须计算一个单一的精确置换 $p$ 值。不涉及物理单位。\n\n- 案例 1（两组，平衡，$p=2$）：\n  - 数据矩阵 $Y$，$n=8$ 行：\n    - A 组：$(2.0,1.0)$, $(2.2,0.9)$, $(1.8,1.1)$, $(2.1,1.2)$\n    - B 组：$(0.0,-0.1)$, $(-0.2,0.1)$, $(0.1,0.2)$, $(-0.1,0.0)$\n  - 标签向量 $\\ell$：$[0,0,0,0,1,1,1,1]$\n\n- 案例 2（三组，不平衡，$p=3$）：\n  - 数据矩阵 $Y$，$n=10$ 行：\n    - 第 1 组：$(0.0,0.1,-0.1)$, $(0.2,-0.1,0.0)$, $(-0.1,0.0,0.1)$\n    - 第 2 组：$(0.05,0.0,0.0)$, $(0.1,-0.05,0.05)$, $(0.0,0.1,-0.1)$, $(-0.05,0.0,0.0)$\n    - 第 3 组：$(0.0,-0.1,0.1)$, $(-0.1,0.1,0.0)$, $(0.1,0.0,-0.05)$\n  - 标签向量 $\\ell$：$[0,0,0,1,1,1,1,2,2,2]$\n\n- 案例 3（三组，平衡，清晰分离，$p=2$）：\n  - 数据矩阵 $Y$，$n=9$ 行：\n    - 第 1 组：$(3.0,0.0)$, $(3.2,-0.1)$, $(2.8,0.2)$\n    - 第 2 组：$(0.0,0.1)$, $(-0.2,0.0)$, $(0.1,-0.1)$\n    - 第 3 组：$(-3.0,0.0)$, $(-2.9,0.1)$, $(-3.1,-0.1)$\n  - 标签向量 $\\ell$：$[0,0,0,1,1,1,2,2,2]$\n\n程序要求：\n- 通过穷举所有保持组计数不变的不同重新标记方式，为每个案例计算精确的置换 $p$ 值。\n- 对于每种标记方式，使用组均值、组内平方和与交叉乘积矩阵以及组间平方和与交叉乘积矩阵，从基本原理出发重新计算 Pillai 的 $V$。\n- 使用包含上尾部的定义计算 $p$ 值：检验统计量大于或等于观测统计量的置换所占的比例。\n- 数值细节：\n  - 如果总平方和与交叉乘积矩阵是奇异或接近奇异的，您必须避免不稳定的显式矩阵求逆，而应使用数值稳定的方法，例如对称广义特征值计算或线性求解。\n  - 所有计算均为实值计算。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个 $p$ 值的结果，以逗号分隔列表的形式呈现，四舍五入到六位小数，并用方括号括起来。例如：$[0.123456,0.500000,0.004000]$。", "solution": "该问题要求在单因素多元方差分析 (MANOVA) 的设定下，计算 Pillai's 迹统计量的精确置换 $p$ 值。该过程涉及验证问题的完整性、定义统计框架，然后开发一个计算算法。\n\n### 问题验证\n问题陈述已经过评估，并被确定为 **有效**。它在科学上是合理的，提法得当，并为获得一个唯一且可验证的解提供了所有必要的数据和定义。对于给定的测试用例，涉及穷举置换的计算任务是可行的。\n\n-   **案例 1**：$g=2$ 个组，各有 $n_1=4, n_2=4$ 个观测值。不同重新标记方式的数量为 $\\binom{8}{4} = 70$。\n-   **案例 2**：$g=3$ 个组，各有 $n_1=3, n_2=4, n_3=3$ 个观测值。不同重新标记方式的数量为 $\\binom{10}{3,4,3} = \\frac{10!}{3!4!3!} = 4200$。\n-   **案例 3**：$g=3$ 个组，各有 $n_1=3, n_2=3, n_3=3$ 个观测值。不同重新标记方式的数量为 $\\binom{9}{3,3,3} = \\frac{9!}{3!3!3!} = 1680$。\n\n这些数值完全在现代计算能力对于穷举的可行性范围之内。\n\n### 统计框架\n\n**1. 单因素 MANOVA 模型**\n\n单因素 MANOVA 模型用于分析 $g$ 个组在 $p$ 个响应变量上的均值向量差异。设 $Y$ 为 $n \\times p$ 的数据矩阵，其中 $n = \\sum_{j=1}^g n_j$ 是总观测数，$n_j$ 是第 $j$ 组的样本量。对于一个观测向量 $y_{ij}$（第 $j$ 组的第 $i$ 个受试者），其模型为：\n$$ y_{ij} = \\mu_j + \\epsilon_{ij} $$\n其中 $\\mu_j$ 是第 $j$ 组的 $p \\times 1$ 均值向量，$\\epsilon_{ij}$ 是独立同分布的误差向量，其均值为 $0$，并具有一个公共协方差矩阵 $\\Sigma$。\n\n原假设 ($H_0$) 指出组均值向量之间没有差异：\n$$ H_0: \\mu_1 = \\mu_2 = \\dots = \\mu_g $$\n在 $H_0$ 下，组标签是可交换的；只要保持组大小不变，任何将观测值分配到各组的方式都是等可能的。这是支持使用置换检验的基本原理。\n\n**2. 平方和与交叉乘积 (SSCP) 矩阵**\n\nMANOVA 使用 SSCP 矩阵将数据中的总变异分解为可归因于组间差异和组内变异的分量。\n\n-   **总 SSCP 矩阵** $T$ 衡量围绕总均值向量 $\\bar{y}$ 的总变异：\n    $$ T = \\sum_{j=1}^g \\sum_{i=1}^{n_j} (y_{ij} - \\bar{y})(y_{ij} - \\bar{y})^T $$\n-   **组间（或假设）SSCP 矩阵** $B$ 衡量各组均值 $\\bar{y}_j$ 围绕总均值 $\\bar{y}$ 的变异：\n    $$ B = \\sum_{j=1}^g n_j (\\bar{y}_j - \\bar{y})(\\bar{y}_j - \\bar{y})^T $$\n-   **组内（或误差）SSCP 矩阵** $W$ 衡量观测值围绕其各自组均值的合并变异：\n    $$ W = \\sum_{j=1}^g \\sum_{i=1}^{n_j} (y_{ij} - \\bar{y}_j)(y_{ij} - \\bar{y}_j)^T $$\n\n这些矩阵通过 MANOVA 的基本恒等式相关联：$T = B + W$。\n\n**3. Pillai's 迹统计量 ($V$)**\n\nPillai's 迹是 MANOVA 中四种常用检验统计量之一。其定义为：\n$$ V = \\mathrm{tr}(B(B+W)^{-1}) = \\mathrm{tr}(B T^{-1}) $$\n一种计算 $V$ 的数值稳定且首选的方法是避免直接对可能病态或奇异的 $W$ 或 $T$ 求逆。取而代之，我们使用矩阵乘积 $W^{-1}B$ 的特征值。设 $\\lambda_1, \\dots, \\lambda_s$ 是 $W^{-1}B$ 的非零特征值，其中 $s = \\min(p, g-1)$ 是 $B$ 的秩。Pillai's 迹可以表示为：\n$$ V = \\sum_{k=1}^s \\frac{\\lambda_k}{1+\\lambda_k} $$\n特征值 $\\lambda_k$ 是广义特征值问题 $Bv = \\lambda Wv$ 的解。这个问题可以使用数值线性代数库可靠地求解，因为它不需要显式矩阵求逆，并且即使在 $W$ 接近奇异时也保持稳定。条件 $n-g \\geq p$ 通常确保对于非退化数据，$W$ 是正定的，这对于所有提供的测试用例都成立。\n\n### 置换检验算法\n\n精确置换检验按以下步骤进行：\n\n1.  **计算观测统计量**：给定数据矩阵 $Y$ 和原始组标签 $\\ell_0$，计算矩阵 $B_{obs}$ 和 $W_{obs}$。求解广义特征值问题 $B_{obs}v = \\lambda W_{obs}v$ 以找到特征值，并计算观测到的 Pillai's 迹 $V_{obs}$。\n\n2.  **穷举置换**：生成所有保持组大小 $(n_1, n_2, \\dots, n_g)$ 不变的观测标签的不同置换。这个置换集合 $\\mathcal{P}$ 构成了原假设下的参考分布。该集合的大小由多项式系数给出：$|\\mathcal{P}| = \\frac{n!}{n_1! n_2! \\dots n_g!}$。这种穷举可以通过使用组合迭代器来系统地实现。例如，对于 $g$ 个组，可以从 $\\{1, \\dots, n\\}$ 中为第一个组选择 $n_1$ 个索引，然后从剩余的索引中为第二个组选择 $n_2$ 个索引，以此类推。\n\n3.  **计算置换分布**：对于每个生成的标签置换 $\\ell' \\in \\mathcal{P}$：\n    a. 将新标签 $\\ell'$ 应用于固定的数据矩阵 $Y$。\n    b. 为这个新的分组重新计算 $B$ 和 $W$ 矩阵。\n    c. 计算相应的 Pillai's 迹统计量 $V_{\\ell'}$。\n\n4.  **计算 $p$ 值**：精确的 $p$ 值是检验统计量大于或等于观测统计量的置换（包括原始排列）所占的比例。这对应于一个包含上尾部的检验。\n    $$ p = \\frac{1}{|\\mathcal{P}|} \\sum_{\\ell' \\in \\mathcal{P}} \\mathbb{I}(V_{\\ell'} \\ge V_{obs}) $$\n    其中 $\\mathbb{I}(\\cdot)$ 是指示函数，当条件为真时为 $1$，否则为 $0$。在比较 $V_{\\ell'} \\ge V_{obs}$ 时，使用一个小的数值容差来考虑潜在的浮点数不精确性。\n\n这个过程提供了一个对原假设的非参数、精确检验，仅依赖于 $H_0$ 下的可交换性假设，而该假设在此实验设计中是满足的。以下程序为指定的测试套件实现了该算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigvals\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to run the permutation tests for all specified cases and print the results.\n    \"\"\"\n\n    def calculate_pillai_v(Y, labels):\n        \"\"\"\n        Calculates Pillai's trace statistic for a given dataset and group labels.\n\n        Args:\n            Y (np.ndarray): The n x p data matrix.\n            labels (np.ndarray): The n-element vector of group labels.\n\n        Returns:\n            float: The computed Pillai's V statistic.\n        \"\"\"\n        n, p = Y.shape\n        unique_labels, group_counts = np.unique(labels, return_counts=True)\n        g = len(unique_labels)\n\n        if g == 1:\n            return 0.0\n\n        overall_mean = np.mean(Y, axis=0).reshape(p, 1)\n\n        B = np.zeros((p, p))\n        W = np.zeros((p, p))\n\n        for i, label in enumerate(unique_labels):\n            group_mask = (labels == label)\n            Y_j = Y[group_mask, :]\n            n_j = group_counts[i]\n\n            group_mean = np.mean(Y_j, axis=0).reshape(p, 1)\n\n            mean_diff = group_mean - overall_mean\n            B += n_j * (mean_diff @ mean_diff.T)\n\n            data_diff = Y_j - group_mean.T\n            W += data_diff.T @ data_diff\n\n        # The rank of B is at most min(g-1, p).\n        # We solve the generalized eigenvalue problem Bv = lambda Wv.\n        # This is a numerically stable way to get eigenvalues of W^-1 * B.\n        # W is invertible for the given test cases since n-g >= p.\n        try:\n            lambda_vals = eigvals(B, W)\n        except np.linalg.LinAlgError:\n            # This case should not be reached with the problem data\n            # but is good practice for robustness.\n            # Fallback to using T=B+W if W is singular.\n            T = B + W\n            try:\n                lambda_vals_T = eigvals(B, T)\n                lambda_vals_T = np.real_if_close(lambda_vals_T)\n                # Convert eigenvalues of B*T^-1 to eigenvalues of B*W^-1\n                lambda_vals = lambda_vals_T / (1.0 - lambda_vals_T)\n            except np.linalg.LinAlgError:\n                 return 0.0 # Indeterminate case\n\n        lambda_vals = np.real_if_close(lambda_vals)\n        lambda_vals = lambda_vals[lambda_vals > 1e-10] # Filter for positive eigenvalues\n\n        V = np.sum(lambda_vals / (1.0 + lambda_vals))\n        return V\n\n    def generate_partitions(indices, group_sizes):\n        \"\"\"\n        Recursively generates all unique partitions of indices into groups of specified sizes.\n\n        Args:\n            indices (list): The list of indices to partition.\n            group_sizes (tuple): A tuple of group sizes.\n\n        Yields:\n            list: A partition, which is a list of lists of indices.\n        \"\"\"\n        if not group_sizes:\n            yield []\n            return\n\n        current_size = group_sizes[0]\n        remaining_sizes = group_sizes[1:]\n\n        if len(indices)  sum(group_sizes):\n            return\n\n        for group_indices in combinations(indices, current_size):\n            remaining_indices = [i for i in indices if i not in group_indices]\n            for rest_of_partition in generate_partitions(remaining_indices, remaining_sizes):\n                yield [list(group_indices)] + rest_of_partition\n\n    def run_permutation_test(Y, labels):\n        \"\"\"\n        Performs an exact permutation test for Pillai's trace.\n\n        Args:\n            Y (np.ndarray): The n x p data matrix.\n            labels (np.ndarray): The initial n-element vector of group labels.\n\n        Returns:\n            float: The exact permutation p-value.\n        \"\"\"\n        n = Y.shape[0]\n        unique_labels, group_sizes = np.unique(labels, return_counts=True)\n\n        observed_v = calculate_pillai_v(Y, labels)\n\n        perm_count = 0\n        ge_count = 0  # Count of permutations with V >= V_obs\n\n        indices = list(range(n))\n\n        for partition in generate_partitions(indices, tuple(group_sizes)):\n            perm_labels = np.zeros(n, dtype=int)\n            for group_idx, group_indices in enumerate(partition):\n                perm_labels[group_indices] = unique_labels[group_idx]\n\n            perm_v = calculate_pillai_v(Y, perm_labels)\n\n            perm_count += 1\n            if perm_v >= observed_v - 1e-12:  # Use tolerance for float comparison\n                ge_count += 1\n        \n        if perm_count == 0:\n            return 1.0\n        \n        return ge_count / perm_count\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (two groups, balanced, p=2)\n        (\n            np.array([\n                [2.0, 1.0], [2.2, 0.9], [1.8, 1.1], [2.1, 1.2],\n                [0.0, -0.1], [-0.2, 0.1], [0.1, 0.2], [-0.1, 0.0]\n            ]),\n            np.array([0, 0, 0, 0, 1, 1, 1, 1])\n        ),\n        # Case 2 (three groups, unbalanced, p=3)\n        (\n            np.array([\n                [0.0, 0.1, -0.1], [0.2, -0.1, 0.0], [-0.1, 0.0, 0.1],\n                [0.05, 0.0, 0.0], [0.1, -0.05, 0.05], [0.0, 0.1, -0.1], [-0.05, 0.0, 0.0],\n                [0.0, -0.1, 0.1], [-0.1, 0.1, 0.0], [0.1, 0.0, -0.05]\n            ]),\n            np.array([0, 0, 0, 1, 1, 1, 1, 2, 2, 2])\n        ),\n        # Case 3 (three groups, balanced, clear separation, p=2)\n        (\n            np.array([\n                [3.0, 0.0], [3.2, -0.1], [2.8, 0.2],\n                [0.0, 0.1], [-0.2, 0.0], [0.1, -0.1],\n                [-3.0, 0.0], [-2.9, 0.1], [-3.1, -0.1]\n            ]),\n            np.array([0, 0, 0, 1, 1, 1, 2, 2, 2])\n        )\n    ]\n\n    p_values = []\n    for Y, labels in test_cases:\n        p_val = run_permutation_test(Y, labels)\n        p_values.append(p_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{p:.6f}' for p in p_values)}]\")\n\nsolve()\n```", "id": "4931288"}]}