{"hands_on_practices": [{"introduction": "现实世界中的生物学数据往往很复杂，可能包含会扭曲算术平均值等标准汇总指标的极端值或异常值。本练习将介绍一种稳健的替代方法——截尾均值 (trimmed mean)，它通过系统地忽略一小部分最极端的数据点，来提供更可靠的中心趋势估计。通过这个练习，你将学会计算截尾均值，并体会其在为受污染数据集生成更具代表性的汇总统计量方面的价值。[@problem_id:4955542]", "problem": "一项临床实验室研究记录了一组 $n=20$ 名成年参与者的丙氨酸氨基转移酶 (ALT) 水平，单位为单位/升 (U/L)。由于现实世界的数据收集，样本中包含一些极端离群值。观测到的 ALT 值为：\n12, 18, 22, 25, 27, 29, 31, 33, 35, 36, 38, 40, 42, 45, 47, 50, 52, 55, 310, 420.\n根据以顺序统计量定义的 $\\alpha$-截尾均值，计算该样本的 $20\\%$-截尾均值。然后，在存在污染数据的情况下，从偏差-方差权衡的角度，将其与普通样本均值 $\\bar{X}_n$ 在总结集中趋势方面的表现进行概念性比较。将您计算出的 $20\\%$-截尾均值四舍五入到四位有效数字，并以 $\\text{U/L}$ 为单位表示。最终报告的答案必须是 $20\\%$-截尾均值的单个数值。", "solution": "该问题被认为是有效的，因为它在生物统计学方面有科学依据，问题提出得当且提供了所有必要数据，并且其表述是客观的。它提出了一个计算稳健的集中趋势度量，并将其与经典估计量进行概念性比较的标准任务。\n\n该问题要求计算给定丙氨酸氨基转移酶 (ALT) 水平样本的 $20\\%$-截尾均值。样本量为 $n=20$，截尾比例为 $\\alpha = 0.20$。\n\n提供的数据为：\n$$12,\\ 18,\\ 22,\\ 25,\\ 27,\\ 29,\\ 31,\\ 33,\\ 35,\\ 36,\\ 38,\\ 40,\\ 42,\\ 45,\\ 47,\\ 50,\\ 52,\\ 55,\\ 310,\\ 420.$$\n这些值已经按非递减顺序排序，因此它们代表顺序统计量 $X_{(1)}, X_{(2)}, \\ldots, X_{(20)}$。\n\n$\\alpha$-截尾均值（记为 $\\bar{X}_{\\alpha}$）的定义是：从排序后的样本的低端和高端分别移除比例为 $\\alpha$ 的观测值，然后计算剩余数据的算术平均值。从两端各需截去的观测值数量 $k$ 由 $k = \\lfloor n\\alpha \\rfloor$ 给出，其中 $\\lfloor \\cdot \\rfloor$ 是向下取整函数。\n\n对于本问题，我们有：\n- 样本量, $n = 20$\n- 截尾比例, $\\alpha = 0.20$\n\n从两端各需截去的观测值数量是：\n$$ k = \\lfloor n\\alpha \\rfloor = \\lfloor 20 \\times 0.20 \\rfloor = \\lfloor 4 \\rfloor = 4 $$\n这意味着我们必须从样本中移除 4 个最小值和 4 个最大值。\n\n顺序统计量为 $X_{(1)}, X_{(2)}, \\ldots, X_{(20)}$。我们从低端截去 $X_{(1)}, \\ldots, X_{(4)}$，从高端截去 $X_{(17)}, \\ldots, X_{(20)}$。\n被截去的观测值是：\n- 低端: $X_{(1)}=12,\\ X_{(2)}=18,\\ X_{(3)}=22,\\ X_{(4)}=25$\n- 高端: $X_{(17)}=52,\\ X_{(18)}=55,\\ X_{(19)}=310,\\ X_{(20)}=420$\n\n$\\alpha$-截尾均值的公式是：\n$$ \\bar{X}_{\\alpha} = \\frac{1}{n - 2k} \\sum_{i=k+1}^{n-k} X_{(i)} $$\n在我们的例子中，这变为：\n$$ \\bar{X}_{0.20} = \\frac{1}{20 - 2(4)} \\sum_{i=4+1}^{20-4} X_{(i)} = \\frac{1}{12} \\sum_{i=5}^{16} X_{(i)} $$\n\n需要求平均值的剩余观测值是：\n$$ X_{(5)}=27,\\ X_{(6)}=29,\\ X_{(7)}=31,\\ X_{(8)}=33,\\ X_{(9)}=35,\\ X_{(10)}=36,\\ X_{(11)}=38,\\ X_{(12)}=40,\\ X_{(13)}=42,\\ X_{(14)}=45,\\ X_{(15)}=47,\\ X_{(16)}=50 $$\n这些观测值的总和是：\n$$ \\sum_{i=5}^{16} X_{(i)} = 27 + 29 + 31 + 33 + 35 + 36 + 38 + 40 + 42 + 45 + 47 + 50 = 453 $$\n这个总和中的观测值数量是 $n - 2k = 20 - 8 = 12$。\n\n现在，我们计算 $20\\%$-截尾均值：\n$$ \\bar{X}_{0.20} = \\frac{453}{12} = 37.75 $$\n问题要求四舍五入到四位有效数字。数值 $37.75$ 已经有四位有效数字。因此，$20\\%$-截尾均值为 $37.75 \\text{ U/L}$。\n\n为了进行概念性比较，我们首先计算普通样本均值 $\\bar{X}_n$：\n$$ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i = \\frac{1}{20} \\sum_{i=1}^{20} X_{(i)} $$\n所有观测值的总和是：\n$$ \\sum_{i=1}^{20} X_{(i)} = (12+18+22+25) + 453 + (52+55+310+420) = 77 + 453 + 837 = 1367 $$\n$$ \\bar{X}_{20} = \\frac{1367}{20} = 68.35 $$\n普通样本均值为 $68.35 \\text{ U/L}$。这个值受到两个极端离群值（$310$ 和 $420$）的严重影响，并且除了这两个值之外比所有其他值都大，这使其成为该数据集集中趋势的一个很差的度量。\n\n偏差-方差权衡的比较如下：\n- **样本均值 ($\\bar{X}_n$)**: 对于正态分布的均值，该估计量是一致最小方差无偏估计量 (UMVUE)。在这个理想假设下，它具有最高的统计效率（最低的方差）。然而，其崩溃点为 $0$，意味着单个任意大的离群值就可以将估计值破坏到任意程度。在存在污染数据的情况下，如本问题所示，样本均值可能会变得高度有偏，并且其抽样方差会急剧膨胀。它不是一个稳健的估计量。\n- **截尾均值 ($\\bar{X}_{\\alpha}$)**: 这是一个稳健的估计量。通过丢弃一小部分极端值，它保护了估计值免受离群值的影响。\n    - **偏差**: 如果底层的真实分布是对称的，截尾均值是对称中心的无偏估计量。如果分布是偏态的，截尾均值将是有偏的，但这种偏差通常小于少数极端离群值在样本均值中引起的偏差。它为分布主体部分的集中趋势提供了一个更好的估计。\n    - **方差**: 对于来自完美正态分布的数据，截尾均值的方差略高于样本均值，这代表了效率的损失。这是稳健性的“代价”。然而，对于来自重尾分布的数据，或者像本例中这样被离群值污染的分布，截尾均值的方差远低于样本均值。\n总而言之，截尾均值在理想条件下牺牲了一些效率，以在更现实的受污染或非正态数据的情况下获得显著的稳健性（更低的偏差和更低的方差）。对于给定的 ALT 数据，截尾均值 $37.75 \\text{ U/L}$ 是比样本均值 $68.35 \\text{ U/L}$ 更具代表性的中心值摘要。\n\n最终要求的答案是 $20\\%$-截尾均值的数值。\n$$ \\bar{X}_{0.20} = 37.75 $$", "answer": "$$\\boxed{37.75}$$", "id": "4955542"}, {"introduction": "并非所有数据都具有可加性；一些生物学过程，如生物标志物水平的倍数变化，本质上是乘性的。在这种情况下，算术平均值可能会误导我们对中心趋势的理解。本练习将从第一性原理出发，探讨适用于乘性数据的几何平均数，并将其与算术平均值进行对比，以突显选择与数据内在结构相匹配的汇总统计量的重要性。[@problem_id:4955574]", "problem": "一个实验室测定了 $n$ 名患者干预后相对于基线的血清生物标志物的倍数变化，其中每次的倍数变化 $X_i$ 均为严格正值。在一个针对倍数变化的生物学上合理的乘性误差模型下，每个观测值满足 $X_i = \\theta \\cdot U_i$ 且 $U_i > 0$，其自然对数满足 $\\mathbb{E}[\\ln(U_i)] = 0$。仅使用平均值和变换的核心定义与性质，从第一性原理推导出一个适用于乘性效应的、针对 $\\{X_i\\}_{i=1}^{n}$ 的集中趋势的单一数值概括，并用以下数据计算该值，同时计算 $\\{X_i\\}_{i=1}^{n}$ 的算术平均值。最后，报告以下观测到的倍数变化的算术平均值与该乘性概括值的比值：\n0.62, 0.75, 0.88, 1.04, 1.22, 1.35, 1.60, 1.90, 2.10, 2.50.\n将最终报告的比值四舍五入到四位有效数字。将最终答案表示为无单位的小数。", "solution": "该问题要求推导一个适用于服从乘性误差模型的数据的集中趋势摘要，为给定数据集计算其值，为同一数据集计算算术平均值，最后计算这两个摘要统计量的比值。\n\n**步骤1：乘性摘要统计量的推导**\n\n目标是从给定模型 $X_i = \\theta \\cdot U_i$ 中找到参数 $\\theta$ 的一个合适估计量。模型的结构涉及乘法，这提示我们使用对数变换。对模型方程两边取自然对数，得到：\n$$\n\\ln(X_i) = \\ln(\\theta \\cdot U_i) = \\ln(\\theta) + \\ln(U_i)\n$$\n这个变换将乘性关系转换为加性关系。为了清晰起见，我们定义新变量：$Y_i = \\ln(X_i)$，$\\mu = \\ln(\\theta)$ 和 $\\epsilon_i = \\ln(U_i)$。用这些新变量表示的模型变为：\n$$\nY_i = \\mu + \\epsilon_i\n$$\n这是一个标准的加性误差模型。问题陈述中说明 $\\mathbb{E}[\\ln(U_i)] = \\mathbb{E}[\\epsilon_i] = 0$。我们现在可以求对数变换后数据 $Y_i$ 的期望值：\n$$\n\\mathbb{E}[Y_i] = \\mathbb{E}[\\mu + \\epsilon_i] = \\mathbb{E}[\\mu] + \\mathbb{E}[\\epsilon_i]\n$$\n由于 $\\mu$ 是一个常数，$\\mathbb{E}[\\mu] = \\mu$。因此，\n$$\n\\mathbb{E}[Y_i] = \\mu + 0 = \\mu\n$$\n这表明 $\\mu = \\ln(\\theta)$ 是对数变换后观测值的总体均值。对于总体均值，一个自然的无偏估计量是样本均值。因此，$\\mu$ 的一个估计量，记作 $\\hat{\\mu}$，是观测到的 $Y_i$ 值的平均值：\n$$\n\\hat{\\mu} = \\frac{1}{n} \\sum_{i=1}^{n} Y_i = \\frac{1}{n} \\sum_{i=1}^{n} \\ln(X_i)\n$$\n我们的目标是估计 $\\theta$，而不是 $\\mu$。由于 $\\mu = \\ln(\\theta)$，我们可以通过取指数来恢复 $\\theta$：$\\theta = \\exp(\\mu)$。将此逆变换应用于我们的估计量 $\\hat{\\mu}$，我们得到 $\\theta$ 的估计量，记作 $\\hat{\\theta}$：\n$$\n\\hat{\\theta} = \\exp(\\hat{\\mu}) = \\exp\\left(\\frac{1}{n} \\sum_{i=1}^{n} \\ln(X_i)\\right)\n$$\n使用对数的性质，其中 $\\sum \\ln(a_i) = \\ln(\\prod a_i)$ 和 $c \\ln(a) = \\ln(a^c)$，我们可以重写该表达式：\n$$\n\\hat{\\theta} = \\exp\\left( \\frac{1}{n} \\ln\\left(\\prod_{i=1}^{n} X_i\\right) \\right) = \\exp\\left( \\ln\\left[ \\left(\\prod_{i=1}^{n} X_i\\right)^{1/n} \\right] \\right)\n$$\n由于指数函数和自然对数是互为反函数，这可以简化为：\n$$\n\\hat{\\theta} = \\left(\\prod_{i=1}^{n} X_i\\right)^{1/n}\n$$\n这就是几何平均值的定义。因此，几何平均值是该乘性模型适用的集中趋势的单一数值概括。我们将其表示为 $G$。\n\n**步骤2：几何平均值和算术平均值的计算**\n\n提供的数据集是 $\\{0.62, 0.75, 0.88, 1.04, 1.22, 1.35, 1.60, 1.90, 2.10, 2.50\\}$。观测数量为 $n=10$。\n\n首先，我们计算几何平均值 $G$。为了数值稳定性，最好使用对数形式：\n$$\n\\ln(G) = \\frac{1}{10} \\sum_{i=1}^{10} \\ln(X_i)\n$$\n数据的自然对数之和为：\n$$\n\\sum_{i=1}^{10} \\ln(X_i) = \\ln(0.62) + \\ln(0.75) + \\ln(0.88) + \\ln(1.04) + \\ln(1.22) + \\ln(1.35) + \\ln(1.60) + \\ln(1.90) + \\ln(2.10) + \\ln(2.50)\n$$\n$$\n\\sum_{i=1}^{10} \\ln(X_i) \\approx -0.478036 - 0.287682 - 0.127833 + 0.039221 + 0.198851 + 0.300105 + 0.470004 + 0.641854 + 0.741937 + 0.916291 \\approx 2.414712\n$$\n$$\n\\ln(G) \\approx \\frac{2.414712}{10} = 0.2414712\n$$\n现在，我们通过取指数来找到 $G$：\n$$\nG = \\exp(\\ln(G)) \\approx \\exp(0.2414712) \\approx 1.273087\n$$\n接下来，我们计算算术平均值 $A$：\n$$\nA = \\frac{1}{n} \\sum_{i=1}^{n} X_i = \\frac{1}{10} \\sum_{i=1}^{10} X_i\n$$\n数据之和为：\n$$\n\\sum_{i=1}^{10} X_i = 0.62 + 0.75 + 0.88 + 1.04 + 1.22 + 1.35 + 1.60 + 1.90 + 2.10 + 2.50 = 13.96\n$$\n$$\nA = \\frac{13.96}{10} = 1.396\n$$\n\n**步骤3：比值的计算**\n\n问题要求计算算术平均值与乘性概括值（即几何平均值）的比值。设此比值为 $R$。\n$$\nR = \\frac{A}{G}\n$$\n代入计算出的值：\n$$\nR = \\frac{1.396}{1.273087} \\approx 1.096545\n$$\n问题要求将此比值四舍五入到四位有效数字。前四位有效数字是 $1$、$0$、$9$、$6$。第五位数字是 $5$，所以我们将第四位数字向上取整。\n$$\nR \\approx 1.097\n$$\n作为检验，算术-几何平均值不等式指出，一组非负实数的算术平均值大于或等于它们的几何平均值。由于我们的数据点不完全相等，我们预期 $A > G$，这意味着 $R > 1$。我们的结果 $R \\approx 1.097$ 与此原则一致。", "answer": "$$\\boxed{1.097}$$", "id": "4955574"}, {"introduction": "计算像中位数这样的汇总统计量可以为我们提供一个点估计，但这个估计的精确度如何？非参数自助法 (nonparametric bootstrap) 是一种强大的计算技术，它使我们能够在不对数据分布做强假设的情况下，估计任何统计量的不确定性（例如标准误）。在这个动手编程练习中，你将通过实施自助法程序来量化样本中位数的精度，这是现代生物统计分析中的一项基本技能。[@problem_id:4955521]", "problem": "考虑来自未知分布 $F$ 的独立同分布观测值 $X_1,\\ldots,X_n$。经验累积分布函数 (ECDF) 定义为 $\\hat F_n(x) = \\frac{1}{n}\\sum_{i=1}^n \\mathbf{1}\\{X_i \\le x\\}$。对于一个汇总统计量 $T(\\hat F_n)$，非参数自助法通过 $T(\\hat F_n^\\ast)$ 的条件分布来近似 $T(\\hat F_n)$ 的抽样分布，其中 $\\hat F_n^\\ast$ 是从 $\\{X_1,\\ldots,X_n\\}$ 中有放回抽取的自助样本 $X_1^\\ast,\\ldots,X_n^\\ast$ 的经验累积分布函数。自助标准误是指根据 $B$ 个独立重抽样的自助数据集计算得出的自助复制值 $T^{\\ast (1)},\\ldots,T^{\\ast (B)}$ 的标准差。\n\n您的任务是：\n- 通过从 $\\hat F_n$ 构建自助样本并计算自助复制值 $T^{\\ast (b)}$（其中 $b=1,\\ldots,B$），为通用统计量 $T(\\hat F_n)$ 定义非参数自助法。\n- 将 $T(\\hat F_n)$ 具体化为样本中位数。对于偶数样本量 $n$，将样本中位数定义为两个中心顺序统计量的平均值。对于奇数 $n$，将其定义为中心顺序统计量。\n- 将样本中位数的自助标准误计算为 $B$ 个自助中位数的无偏样本标准差，即：\n$$\n\\widehat{\\operatorname{se}}_{\\text{boot}}(T) \\;=\\; \\sqrt{\\frac{1}{B-1}\\sum_{b=1}^B \\left(T^{\\ast (b)} - \\overline{T^\\ast}\\right)^2},\n$$\n其中 $\\overline{T^\\ast} = \\frac{1}{B}\\sum_{b=1}^B T^{\\ast (b)}$。\n\n实现要求：\n- 对每个测试用例使用 $B = 8000$ 次自助重抽样。\n- 使用 NumPy 的伪随机数生成器，配合 PCG64 位生成器，并为每个测试用例指定一个种子以确保可复现性。具体来说，使用以给定整数种子初始化的生成器 $\\texttt{numpy.random.Generator}(\\texttt{numpy.random.PCG64}(\\text{seed}))$。\n- 对每个测试用例，按上述定义计算样本中位数的自助标准误，并将结果四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n- 案例 1：数据 $\\{5.4,\\,5.1,\\,4.8,\\,5.9,\\,5.2,\\,6.0,\\,5.5,\\,5.7,\\,5.3,\\,4.9\\}$，种子 $314159$。\n- 案例 2：数据 $\\{2.0,\\,3.5,\\,3.5,\\,4.0,\\,5.0,\\,6.5\\}$，种子 $271828$。\n- 案例 3：数据 $\\{7.0,\\,7.0,\\,7.0\\}$，种子 $42$。\n- 案例 4：数据 $\\{0.1,\\,0.2,\\,0.15,\\,100.0,\\,0.18,\\,0.22,\\,0.12\\}$，种子 $202311$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的自助标准误。这些值应按上述案例顺序排列，以逗号分隔，并用方括号括起来，每个值都四舍五入到 $6$ 位小数。例如，输出必须是 $[r_1,r_2,r_3,r_4]$ 的形式，其中每个 $r_i$ 是一个四舍五入到 $6$ 位的小数，且不打印任何额外文本。", "solution": "该问题是有效的。它提出了一个计算统计学中清晰、明确定义的任务，该任务在科学上是合理的，并且在计算上是可验证的。\n\n目标是为四个给定的数据集计算样本中位数的非参数自助标准误。非参数自助法是一种强大的重抽样技术，用于在不对潜在总体分布做出强假设的情况下估计统计量的抽样分布。\n\n非参数自助法的基本原理是使用观测到的样本作为整个总体的近似。经验累积分布函数 (ECDF)，表示为 $\\hat{F}_n(x) = \\frac{1}{n} \\sum_{i=1}^n \\mathbf{1}\\{X_i \\le x\\}$，通过为每个观测数据点 $X_i$ 分配 $\\frac{1}{n}$ 的概率来形式化这一点。从原始样本 $\\{X_1, \\ldots, X_n\\}$ 中进行有放回重抽样，等同于从由 $\\hat{F}_n$ 定义的分布中抽取独立同分布的样本。\n\n估计统计量 $T$（本例中为样本中位数）的标准误的步骤如下：\n\n1.  **给定数据**：我们从一个大小为 $n$ 的原始样本开始，表示为 $\\{X_1, \\ldots, X_n\\}$。\n\n2.  **自助重抽样**：我们生成大量的（$B$ 个）自助样本。对于此问题，$B = 8000$。每个自助样本，表示为 $\\{X_1^{*(b)}, \\ldots, X_n^{*(b)}\\}$（其中 $b = 1, \\ldots, B$），是通过从原始样本 $\\{X_1, \\ldots, X_n\\}$ 中*有放回地*抽取 $n$ 个数据点创建的。\n\n3.  **计算自助复制值**：对于 $B$ 个自助样本中的每一个，我们计算感兴趣的统计量，即样本中位数。这将产生一组 $B$ 个自助复制值 $\\{ T^{*(1)}, T^{*(2)}, \\ldots, T^{*(B)} \\}$。样本中位数的定义如下：\n    - 如果样本量 $n$ 是奇数，则中位数是排序后样本的中心值。\n    - 如果样本量 $n$ 是偶数，则中位数是排序后样本的两个中心值的平均值。\n\n4.  **计算自助标准误**：自助标准误 $\\widehat{\\operatorname{se}}_{\\text{boot}}(T)$ 是对 $T$ 的抽样分布标准差的估计。它被计算为 $B$ 个自助复制值的样本标准差。问题指定使用无偏样本标准差公式：\n    $$ \\widehat{\\operatorname{se}}_{\\text{boot}}(T) = \\sqrt{\\frac{1}{B-1}\\sum_{b=1}^B \\left(T^{\\ast (b)} - \\overline{T^\\ast}\\right)^2} $$\n    其中 $\\overline{T^\\ast}$ 是自助复制值的均值：\n    $$ \\overline{T^\\ast} = \\frac{1}{B}\\sum_{b=1}^B T^{\\ast (b)} $$\n\n为确保可复现性，该过程必须使用指定的伪随机数生成器 `numpy.random.Generator(numpy.random.PCG64(seed))`，并为每个测试用例提供相应的种子。\n\n每个测试用例的实现将按以下步骤进行：\n- 使用给定的 `seed` 初始化随机数生成器。\n- 使用生成器的 `choice` 方法（设置 `replace=True`）从原始数据中生成 $B=8000$ 个大小为 $n$ 的自助样本。\n- 对于每个自助样本，使用 `numpy.median` 计算其中位数，该函数能正确实现对偶数和奇数样本量的定义。\n- 收集这 $8000$ 个中位数。\n- 使用 `numpy.std`（参数 `ddof=1`，即自由度差量）计算这些中位数的标准差。设置 `ddof=1` 可确保平方差之和除以 $B-1$，这与无偏样本标准差所需的公式相匹配。\n- 最后，将结果四舍五入到 $6$ 位小数。\n\n此过程将应用于问题陈述中指定的四个测试用例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the bootstrap standard error of the sample median for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ({'data': [5.4, 5.1, 4.8, 5.9, 5.2, 6.0, 5.5, 5.7, 5.3, 4.9], 'seed': 314159}),\n        ({'data': [2.0, 3.5, 3.5, 4.0, 5.0, 6.5], 'seed': 271828}),\n        ({'data': [7.0, 7.0, 7.0], 'seed': 42}),\n        ({'data': [0.1, 0.2, 0.15, 100.0, 0.18, 0.22, 0.12], 'seed': 202311})\n    ]\n\n    B = 8000\n    results = []\n\n    for case in test_cases:\n        data = np.array(case['data'])\n        seed = case['seed']\n        n = len(data)\n\n        # Initialize the random number generator with the specified seed and generator type.\n        rng = np.random.Generator(np.random.PCG64(seed))\n\n        # Store the medians of the bootstrap samples.\n        bootstrap_medians = np.empty(B)\n\n        # Generate B bootstrap samples and compute their medians.\n        for b in range(B):\n            # A bootstrap sample is drawn with replacement from the original data.\n            bootstrap_sample = rng.choice(data, size=n, replace=True)\n            \n            # Compute the median of the bootstrap sample.\n            # np.median correctly handles both even and odd sample sizes.\n            bootstrap_medians[b] = np.median(bootstrap_sample)\n\n        # Compute the bootstrap standard error, which is the sample standard deviation\n        # of the bootstrap medians. The ddof=1 argument specifies division by (B-1),\n        # yielding the unbiased sample standard deviation.\n        se_boot = np.std(bootstrap_medians, ddof=1)\n\n        # Round the result to 6 decimal places.\n        rounded_result = round(se_boot, 6)\n        results.append(rounded_result)\n\n    # Final print statement in the exact required format.\n    # The map to str is necessary to handle the case of 0.0 becoming '0.0'.\n    # A custom formatter could also ensure trailing zeros, but str() is sufficient here.\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4955521"}]}