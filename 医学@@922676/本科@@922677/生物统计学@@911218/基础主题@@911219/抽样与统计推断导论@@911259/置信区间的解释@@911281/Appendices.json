{"hands_on_practices": [{"introduction": "本章的第一个实践是构建置信区间的基石。当我们处理来自正态分布的小样本，并且总体的标准差 $\\sigma$ 未知时，我们必须考虑估计它所带来的额外不确定性。这个练习将指导你使用学生t分布来为总体均值 $\\mu$ 构建一个精确的置信区间，并探索样本量如何通过自由度影响我们推断的精度。[@problem_id:4918389]", "problem": "一位生物统计学家从一个假定服从正态分布 $\\mathcal{N}(\\mu,\\sigma^{2})$ 的总体中抽取一个大小为 $n=12$ 的简单随机样本，其中 $\\sigma^{2}$ 未知。该样本的均值为 $\\bar{x}=5.1$，样本标准差为 $s=1.9$。请仅使用关于抽样分布和枢轴量的基本原理，基于学生t分布构建均值 $\\mu$ 的双侧 $95\\%$ 置信区间，并从第一性原理简要解释自由度 $n-1$ 如何以及为何影响区间的宽度。为了评分，请报告误差范围（即 $95\\%$ 置信区间的半宽度）作为你的最终数值答案。将你的最终数值答案四舍五入到四位有效数字。", "solution": "问题提出得很好，科学上是合理的，包含了构建置信区间和分析其性质所需的所有信息。\n\n给定一个来自假定服从正态分布 $\\mathcal{N}(\\mu, \\sigma^2)$ 的总体的简单随机样本，样本大小为 $n=12$，总体均值 $\\mu$ 和方差 $\\sigma^2$ 未知。样本均值为 $\\bar{x}=5.1$，样本标准差为 $s=1.9$。我们的任务是为 $\\mu$ 构建一个双侧 $95\\%$ 置信区间。\n\n构建此区间的基本原理是使用枢轴量，枢轴量是样本数据和目标参数的函数，其抽样分布已知且不依赖于任何未知参数。\n\n由于总体方差 $\\sigma^2$ 未知，我们不能使用标准正态（$Z$）统计量。我们改用样本标准差 $s$ 作为 $\\sigma$ 的估计。由此产生的枢轴量是t统计量，定义为：\n$$\nT = \\frac{\\bar{X} - \\mu}{S/\\sqrt{n}}\n$$\n其中 $\\bar{X}$ 是样本均值随机变量，$S$ 是样本标准差随机变量。根据统计学的一个基本定理（最初由 W.S. Gosset 提出），这个量 $T$ 服从自由度为 $\\nu = n-1$ 的学生t分布。\n\n对于双侧 $95\\%$ 置信区间，显著性水平为 $\\alpha = 1 - 0.95 = 0.05$。我们需要从自由度为 $\\nu = n-1$ 的t分布中找到临界值 $\\pm t_{\\alpha/2, \\nu}$，这些临界值界定了概率质量的中心 $1-\\alpha=0.95$ 部分。这表示为：\n$$\nP(-t_{\\alpha/2, \\nu} \\le T \\le t_{\\alpha/2, \\nu}) = 1-\\alpha\n$$\n代入 $T$ 的表达式，我们得到：\n$$\nP\\left(-t_{\\alpha/2, \\nu} \\le \\frac{\\bar{X} - \\mu}{S/\\sqrt{n}} \\le t_{\\alpha/2, \\nu}\\right) = 1-\\alpha\n$$\n为了找到 $\\mu$ 的区间，我们整理不等式：\n$$\n-t_{\\alpha/2, \\nu} \\frac{S}{\\sqrt{n}} \\le \\bar{X} - \\mu \\le t_{\\alpha/2, \\nu} \\frac{S}{\\sqrt{n}}\n$$\n$$\n-\\bar{X} - t_{\\alpha/2, \\nu} \\frac{S}{\\sqrt{n}} \\le -\\mu \\le -\\bar{X} + t_{\\alpha/2, \\nu} \\frac{S}{\\sqrt{n}}\n$$\n乘以 $-1$ 会反转不等式：\n$$\n\\bar{X} - t_{\\alpha/2, \\nu} \\frac{S}{\\sqrt{n}} \\le \\mu \\le \\bar{X} + t_{\\alpha/2, \\nu} \\frac{S}{\\sqrt{n}}\n$$\n因此，置信区间由 $\\bar{x} \\pm E$ 给出，其中 $E$ 是误差范围。误差范围定义为：\n$$\nE = t_{\\alpha/2, \\nu} \\frac{s}{\\sqrt{n}}\n$$\n现在，我们代入给定的值：\n样本大小 $n=12$。\n样本标准差 $s=1.9$。\n自由度 $\\nu = n-1 = 12-1 = 11$。\n显著性水平 $\\alpha = 0.05$，所以 $\\alpha/2 = 0.025$。\n\n我们需要从自由度为 $11$ 的学生t分布中找到临界值 $t_{0.025, 11}$。这个值是使得上尾面积为 $0.025$ 的点。查阅t分布表或使用统计软件，我们发现：\n$$\nt_{0.025, 11} \\approx 2.201\n$$\n接下来，我们计算均值标准误（SEM）：\n$$\n\\text{SEM} = \\frac{s}{\\sqrt{n}} = \\frac{1.9}{\\sqrt{12}}\n$$\n那么，误差范围是：\n$$\nE = t_{0.025, 11} \\cdot \\frac{s}{\\sqrt{n}} \\approx 2.201 \\times \\frac{1.9}{\\sqrt{12}}\n$$\n$$\nE \\approx 2.201 \\times \\frac{1.9}{3.46410} \\approx 2.201 \\times 0.54856 \\approx 1.20736\n$$\n四舍五入到四位有效数字，误差范围为 $1.207$。\n\n问题的第二部分要求解释自由度（$df = n-1$）如何以及为何影响区间的宽度。置信区间的宽度为 $2E = 2 \\cdot t_{\\alpha/2, n-1} \\cdot \\frac{s}{\\sqrt{n}}$。自由度 $\\nu = n-1$ 主要通过临界值 $t_{\\alpha/2, \\nu}$ 影响宽度。\n\n从第一性原理出发，使用学生t分布而不是正态分布，是为了解释用样本标准差 $s$ 估计未知总体标准差 $\\sigma$ 所引入的额外不确定性。t分布的形状取决于自由度 $\\nu$。对于较小的 $\\nu$ 值（即小样本量），t分布比标准正态分布具有更重的尾部。这意味着尾部有更多的概率，反映了估计值 $s$ 中更大的不确定性。\n\n随着自由度 $\\nu=n-1$ 的增加，样本标准差 $s$ 成为 $\\sigma$ 更可靠的估计。因此，t分布的形状收敛于标准正态分布 $\\mathcal{N}(0,1)$。对于一个固定的置信水平 $1-\\alpha$，临界值 $t_{\\alpha/2, \\nu}$ 是 $\\nu$ 的严格递减函数。更大的 $\\nu$ 对应于更小的临界值 $t_{\\alpha/2, \\nu}$，该值更接近于来自正态分布的相应 $z_{\\alpha/2}$ 值。\n更小的临界值直接导致更小的误差范围 $E$，从而得到更窄的置信区间。总之，增加自由度减少了因估计 $\\sigma$ 而带来的“惩罚”，导致临界值更小，从而得到对均值 $\\mu$ 更精确（更窄）的置信区间。", "answer": "$$\\boxed{1.207}$$", "id": "4918389"}, {"introduction": "从均值转向比例的推断带来了新的挑战，尤其是在事件稀少时。这个练习将对比两种为二项分布比例 $p$ 构建置信区间的方法：简单直观的Wald方法和理论上更稳健的Wilson得分方法。通过处理一个接近参数边界的真实场景，你将亲身体会到不同统计程序在覆盖率和可靠性上的显著差异。[@problem_id:4918349]", "problem": "一个公共卫生实验室筛选了 $n=100$ 个随机样本，用于检测一种病原体，并观察到 $x=2$ 个阳性结果。令 $X \\sim \\mathrm{Bin}(n,p)$ 表示在成功概率为 $p$ 的独立同分布伯努利试验中阳性结果的数量，并令 $\\hat{p}=x/n$ 为样本比例。仅使用基本原理（包括独立同分布伯努利变量的中心极限定理（CLT）和检验反演逻辑），为 $p$ 构建 $95\\%$ 的 Wald 置信区间和 $95\\%$ 的 Wilson 得分置信区间。然后，计算 Wilson 区间长度与 Wald 区间长度之比，明确地将 Wald 区间视为未截断的（因此其下限可能在 $[0,1]$ 之外）。将您的比率四舍五入到四位有效数字，并以小数形式表示。最后，从第一性原理出发，解释为什么 Wald 区间在参数边界附近会出现覆盖率问题，以及 Wilson 区间如何解决这些问题。最终的数值答案必须是区间长度之比，四舍五入到四位有效数字。", "solution": "该问题要求构建和比较两种用于二项分布比例 $p$ 的置信区间。给定样本量 $n=100$ 和观察到的阳性样本数 $x=2$。置信水平指定为 $95\\%$。\n\n首先，我们确定基本量。样本比例为 $\\hat{p} = \\frac{x}{n} = \\frac{2}{100} = 0.02$。对于 $95\\%$ 的置信水平，显著性水平为 $\\alpha = 1 - 0.95 = 0.05$。来自标准正态分布的临界值为 $z_{\\alpha/2} = z_{0.025}$。从标准正态分布的累积分布函数可知，$\\Phi(z_{0.025}) = 1 - 0.025 = 0.975$，这得出 $z_{0.025} \\approx 1.95996$。我们将使用常见的近似值 $z_{0.025} = 1.96$。\n\n两种区间的构建都基于检验反演原理，从一个近似于标准正态分布的检验统计量开始。根据应用于独立同分布伯努利随机变量之和的中心极限定理，对于大的 $n$，样本比例 $\\hat{p}$ 近似服从正态分布：\n$$ \\hat{p} \\approx_d \\mathcal{N}\\left(p, \\frac{p(1-p)}{n}\\right) $$\n其中 $\\mathcal{N}(\\mu, \\sigma^2)$ 表示均值为 $\\mu$、方差为 $\\sigma^2$ 的正态分布。这导出了标准化的枢轴量：\n$$ Z = \\frac{\\hat{p} - p}{\\sqrt{\\frac{p(1-p)}{n}}} \\approx_d \\mathcal{N}(0,1) $$\n\n**1. Wald 置信区间**\n\nWald 区间是通过反演 Wald 检验得出的。该方法通过在标准误差项中用样本估计值 $\\hat{p}$ 替代未知参数 $p$ 来简化枢轴量。估计的标准误差为 $\\widehat{\\mathrm{SE}} = \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}}$。假设检验统计量\n$$ Z_W = \\frac{\\hat{p} - p}{\\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}}} $$\n近似服从标准正态分布。$(1-\\alpha)$ 置信区间是所有 $p$ 值的集合，对于这些 $p$ 值，我们在显著性水平 $\\alpha$ 下不会拒绝原假设 $H_0: \\text{proportion} = p$。这对应于不等式 $|Z_W| \\le z_{\\alpha/2}$，即：\n$$ -z_{\\alpha/2} \\le \\frac{\\hat{p} - p}{\\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}}} \\le z_{\\alpha/2} $$\n解这个关于 $p$ 的不等式，得到 Wald 区间：\n$$ \\mathrm{CI}_W = \\hat{p} \\pm z_{\\alpha/2} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}} $$\n使用给定值：\n$\\hat{p} = 0.02$，$n=100$ 和 $z_{0.025}=1.96$。\n误差范围是：\n$$ E_W = 1.96 \\times \\sqrt{\\frac{0.02(1-0.02)}{100}} = 1.96 \\times \\sqrt{\\frac{0.0196}{100}} = 1.96 \\times \\frac{0.14}{10} = 1.96 \\times 0.014 = 0.02744 $$\n区间界限是：\n下限：$p_{W, \\text{lower}} = 0.02 - 0.02744 = -0.00744$。\n上限：$p_{W, \\text{upper}} = 0.02 + 0.02744 = 0.04744$。\n根据问题陈述，我们使用未截断的区间。Wald 区间的长度是 $L_W = p_{W, \\text{upper}} - p_{W, \\text{lower}} = 2 \\times E_W = 2 \\times 0.02744 = 0.05488$。\n\n**2. Wilson 得分置信区间**\n\nWilson 得分区间是通过反演得分检验得出的。关键在于，它不将 $\\hat{p}$ 代入枢轴量中的标准误差项。相反，它求解满足以下条件的 $p$ 值：\n$$ -z_{\\alpha/2} \\le \\frac{\\hat{p} - p}{\\sqrt{\\frac{p(1-p)}{n}}} \\le z_{\\alpha/2} $$\n这等价于解二次不等式：\n$$ (\\hat{p} - p)^2 \\le z_{\\alpha/2}^2 \\left( \\frac{p(1-p)}{n} \\right) $$\n将其重排为标准二次形式 $Ap^2+Bp+C=0$ 即可得到区间的端点：\n$$ n(\\hat{p}-p)^2 - z_{\\alpha/2}^2 p(1-p) = 0 $$\n$$ n(\\hat{p}^2 - 2\\hat{p}p + p^2) - z_{\\alpha/2}^2(p - p^2) = 0 $$\n$$ (n+z_{\\alpha/2}^2)p^2 - (2n\\hat{p} + z_{\\alpha/2}^2)p + n\\hat{p}^2 = 0 $$\n这个二次方程的根可以使用求根公式 $p = \\frac{-B \\pm \\sqrt{B^2-4AC}}{2A}$ 求得，从而给出区间的端点：\n$$ \\mathrm{CI}_S = \\frac{2n\\hat{p} + z_{\\alpha/2}^2 \\pm z_{\\alpha/2}\\sqrt{4n\\hat{p}(1-\\hat{p}) + z_{\\alpha/2}^2}}{2(n+z_{\\alpha/2}^2)} $$\n让我们代入数值：$n=100$，$\\hat{p}=0.02$ 和 $z_{0.025}=1.96$。令 $z=1.96$，则 $z^2 = 3.8416$。\n公分母为 $2(n+z^2) = 2(100+3.8416) = 207.6832$。\n分子中的第一项是 $2n\\hat{p} + z^2 = 2(100)(0.02) + 3.8416 = 4 + 3.8416 = 7.8416$。\n分子中平方根下的项是 $4n\\hat{p}(1-\\hat{p}) + z^2 = 4(100)(0.02)(0.98) + 3.8416 = 7.84 + 3.8416 = 11.6816$。\n分子中的第二项是 $z\\sqrt{11.6816} = 1.96 \\times \\sqrt{11.6816} \\approx 1.96 \\times 3.4178356 \\approx 6.7009578$。\n因此，区间为：\n$$ p_S = \\frac{7.8416 \\pm 6.7009578}{207.6832} $$\n下限：$p_{S, \\text{lower}} = \\frac{7.8416 - 6.7009578}{207.6832} = \\frac{1.1406422}{207.6832} \\approx 0.0054921$。\n上限：$p_{S, \\text{upper}} = \\frac{7.8416 + 6.7009578}{207.6832} = \\frac{14.5425578}{207.6832} \\approx 0.0700223$。\nWilson 得分区间的长度为 $L_S = p_{S, \\text{upper}} - p_{S, \\text{lower}} \\approx 0.0700223 - 0.0054921 = 0.0645302$。\n\n**3. 区间长度之比**\n\nWilson 区间长度与 Wald 区间长度之比为：\n$$ R = \\frac{L_S}{L_W} = \\frac{0.0645302}{0.05488} \\approx 1.1758418 $$\n四舍五入到四位有效数字，该比率为 $1.176$。\n\n**4. 覆盖率问题的解释**\n\n区间长度和界限的显著差异，特别是 Wald 区间的负下限，突显了根本的理论差异。\n\n**Wald 区间**的主要缺陷在于它依赖于使用点估计值 $\\hat{p}$ 来估计标准误差 $\\mathrm{SE} = \\sqrt{p(1-p)/n}$。伯努利试验的方差 $p(1-p)$ 在 $p=0.5$ 时达到最大值，当 $p$ 接近参数空间的边界 $p=0$ 或 $p=1$ 时，方差趋近于零。当真实的 $p$ 很小（如本问题中），观测到的 $\\hat{p}$ 也可能很小。这导致对真实标准误差的系统性低估。被低估的标准误差会产生一个过窄的区间，导致其实际覆盖概率低于名义水平（例如，低于 $95\\%$）。在 $x=0$ 或 $x=n$ 的极端情况下，我们有 $\\hat{p}=0$ 或 $\\hat{p}=1$，导致估计的标准误差为零，从而得到一个零宽度的区间。这样的区间覆盖任何真实参数 $p \\in (0,1)$ 的概率为 $0\\%$。此外，Wald 区间关于 $\\hat{p}$ 是对称的，当 $p$ 接近 $0$ 或 $1$ 时，这对于 $\\hat{p}$ 的高度偏态抽样分布来说是一个很差的近似。它会产生无意义的界限（如 $p  0$）这一事实，是这些理论缺陷的直接症状。\n\n**Wilson 得分区间**通过不将点估计值代入标准误差来纠正这些问题。通过求解方差项中包含真实参数 $p$ 的二次不等式，它考虑了方差对 $p$ 的依赖性。这种方法有几个好处：\n1.  **避免标准误差低估：**它不使用可能很小的 $\\hat{p}$ 来估计方差，从而得到更合适的区间宽度和更好的覆盖属性，尤其是在边界附近。\n2.  **非对称性：**该区间不围绕 $\\hat{p}$ 对称。其中心 $\\frac{n\\hat{p} + z_{\\alpha/2}^2/2}{n + z_{\\alpha/2}^2}$ 是 $\\hat{p}$ 和 $0.5$ 的加权平均值。这个中心被拉向 $0.5$，当 $\\hat{p}$ 接近 $0$ 或 $1$ 时尤其有效，创建了一个非对称的区间，更好地反映了底层抽样分布的偏度。对于我们的数据，这个中心大约是 $0.038$，高于 $\\hat{p}=0.02$。\n3.  **边界完整性：**Wilson 区间保证位于 $(0,1)$ 参数空间内，除非在 $x=0$ 或 $x=n$ 时，其端点为平凡的 $0$ 或 $1$。对于观测比例为 $0$ 或 $1$ 的情况，它从不坍缩为零宽度区间，因此在整个参数空间内保持了合理的性能。其平均覆盖概率始终比 Wald 区间更接近名义水平。\n\n在这个具体问题中，由于 $np=2$，正态近似的合理性值得怀疑。Wald 区间明显过窄且位置不当，其负下限就是证明。相比之下，Wilson 区间更宽，并向右移动，为真实比例 $p$ 提供了一个更合理、理论上更健全的范围。", "answer": "$$\\boxed{1.176}$$", "id": "4918349"}, {"introduction": "现实世界的数据往往不是完美的正态分布，因此对中位数的推断至关重要。本练习将引导你进入非参数和计算统计的前沿，使用两种截然不同的方法为生存时间中位数构建置信区间。你将通过编程实践，比较基于精确二项检验的经典方法的保守性与 bootstrap 百分位方法的计算密集型近似，从而深入理解它们各自的优缺点。[@problem_id:4918314]", "problem": "您将获得 $3$ 个独立同分布的样本，这些样本是严格为正的生存时间，单位为月。对于每个样本，您必须使用两种方法计算总体中位生存时间的双侧置信区间，置信水平为 $1-\\alpha = 0.95$：bootstrap百分位数法和通过反转二项检验得到的精确符号检验法。然后，您必须通过报告区间宽度和简单的包含关系来比较这两个区间。所有生存时间量都应以月为单位；所有输出都应表示为实数，不附加单位。\n\n基本原理和约束条件：\n- 设 $X_{1},\\dots,X_{n}$ 是来自一个连续分布的独立同分布样本，其累积分布函数为 $F$。总体中位数 $m$ 是满足 $F(m)=0.5$ 的点。\n- 如果 $m$ 是总体中位数且分布是连续的，则计数 $S = \\sum_{i=1}^{n} \\mathbf{1}\\{X_{i} \\le m\\}$ 服从参数为 $(n, 0.5)$ 的二项分布。这个事实是精确、免分布的基于符号检验的 $m$ 置信区间的基础，该置信区间可以用次序统计量 $X_{(1)} \\le \\dots \\le X_{(n)}$ 来表示。\n- bootstrap百分位数法通过从观测数据中有放回地重抽样来近似估计量的抽样分布，然后取该估计量的bootstrap分布的经验分位数来构建置信区间。\n\n程序要求：\n- 使用置信水平 $1-\\alpha = 0.95$，其中 $\\alpha = 0.05$。\n- 对每个样本使用 $B = 20000$ 次bootstrap重复，并设置固定的随机种子以确保可复现性。\n- 对每个样本，按顺序计算以下内容：\n  1. 样本中位数 $\\hat{m}$。\n  2. bootstrap百分位置信区间 $[L_{b}, U_{b}]$，由样本中位数的bootstrap分布在水平 $\\alpha/2$ 和 $1-\\alpha/2$ 处的经验分位数构成。\n  3. 基于精确符号检验的区间 $[L_{s}, U_{s}]$，该区间通过在连续分布假设下反转中位数的二项检验得到，并用次序统计量 $[X_{(L)}, X_{(U)}]$ 表示。其中整数索引 $L$ 和 $U$ 的选择要使得对于 $S \\sim \\text{Binomial}(n, 0.5)$，双侧尾部概率均不大于 $\\alpha/2$。\n  4. 区间宽度 $W_{b} = U_{b} - L_{b}$ 和 $W_{s} = U_{s} - L_{s}$。\n  5. 布尔指示符 $\\mathbf{1}\\{\\hat{m} \\in [L_{b}, U_{b}]\\}$、$\\mathbf{1}\\{\\hat{m} \\in [L_{s}, U_{s}]\\}$ 和 $\\mathbf{1}\\{[L_{b}, U_{b}] \\subseteq [L_{s}, U_{s}]\\}$。\n\n测试套件：\n- 使用以下 $3$ 个生存时间样本（单位：月）。将这些数值视为精确的实数：\n  - 样本 $1$ (中度对称, $n=12$): $[12.1, 10.5, 9.7, 11.2, 13.4, 10.9, 12.6, 9.9, 11.5, 12.0, 10.8, 11.1]$。\n  - 样本 $2$ (右偏, $n=14$): $[3.2, 5.1, 4.0, 6.7, 8.5, 12.3, 7.1, 4.8, 15.6, 9.4, 10.2, 5.5, 6.0, 20.0]$。\n  - 样本 $3$ (中间附近有重复值, $n=12$): $[6.0, 6.0, 6.0, 7.0, 8.0, 9.0, 10.0, 10.0, 11.0, 12.0, 12.0, 13.0]$。\n\n最终输出格式：\n- 对于每个样本，按 $[\\hat{m}, L_{b}, U_{b}, L_{s}, U_{s}, W_{b}, W_{s}, \\mathbf{1}\\{\\hat{m} \\in [L_{b}, U_{b}]\\}, \\mathbf{1}\\{\\hat{m} \\in [L_{s}, U_{s}]\\}, \\mathbf{1}\\{[L_{b}, U_{b}] \\subseteq [L_{s}, U_{s}]\\}]$ 的确切顺序返回一个列表。\n- 将 $3$ 个样本的结果汇总到一个包含 $3$ 个列表的单一列表中。\n- 您的程序应生成单行输出，其中包含此汇总结果，格式为用方括号括起来的逗号分隔列表，不含空格（例如，$[r_{1},r_{2},r_{3}]$，其中每个 $r_{i}$ 本身都是一个按指定顺序排列的列表）。\n\n关于解释的说明：\n- 所有与时间相关的结果均以月为单位表示为实数，不附加单位。\n- 任何比例都必须表示为小数，而不是百分号。\n- 基于精确符号检验的区间在连续性假设下是有限样本和免分布的，而bootstrap百分位置信区间是基于观测样本的渐近近似；比较宽度和包含关系可以为了解有限样本中潜在的保守性或覆盖不足提供见解。", "solution": "我们首先将目标和证明两种区间合理性的基本事实形式化。\n\n设 $X_{1},\\dots,X_{n}$ 是从一个具有累积分布函数 $F$ 的连续分布中抽取的独立同分布生存时间。总体中位数 $m$ 是 $0.5$ 分位数，即满足 $F(m)=0.5$ 的唯一值。样本中位数 $\\hat{m}$ 是经验 $0.5$ 分位数，可以用次序统计量 $X_{(1)} \\le \\dots \\le X_{(n)}$ 来表示。\n\n基于精确符号检验的区间的推导。在真实中位数 $m$ 处连续的假设下，指示变量 $\\mathbf{1}\\{X_{i} \\le m\\}$ 是独立的伯努利随机变量，成功概率为 $0.5$。因此，和 $S=\\sum_{i=1}^{n} \\mathbf{1}\\{X_{i} \\le m\\}$ 服从参数为 $(n,0.5)$ 的二项分布。考虑一个 $m$ 的双侧置信集，它由在水平 $\\alpha$ 下不被双侧符号检验拒绝的 $m$ 值集合定义，这产生了一个通过次序统计量表示的精确、有限样本、免分布的置信区间。具体来说，选择一个尽可能大的整数 $k \\in \\{-1,0,1,\\dots\\}$，使得 $\\mathbb{P}(S \\le k) \\le \\alpha/2$，其中 $S \\sim \\text{Binomial}(n, 0.5)$。根据对称性，$\\mathbb{P}(S \\ge n-k) \\le \\alpha/2$。相应的次序统计量索引为 $L = k+1$ 和 $U = n-k$。那么，基于精确符号检验的 $m$ 的置信区间为\n$$\n[L_{s}, U_{s}] = [X_{(L)}, X_{(U)}].\n$$\n该区间满足 $\\mathbb{P}(m  X_{(L)}) \\le \\alpha/2$ 和 $\\mathbb{P}(m > X_{(U)}) \\le \\alpha/2$，因此覆盖率至少为 $1-\\alpha$。对于小样本 $n$ 和严格的 $\\alpha$，该区间可能偏于保守，因为二项累积概率是离散的。在实现中，我们计算二项累积分布函数 $F_{S}(k)=\\mathbb{P}(S \\le k)$ 并相应地选择 $k$；在 $k=-1$ 的边缘情况下，索引将意味着无界端点，实际上可以将其截断为样本中观测到的最小值和最大值，不过我们的测试样本量避免了这种退化情况。\n\nbootstrap百分位置信区间的推导。设 $\\hat{m}=\\hat{m}(X_{1},\\dots,X_{n})$ 表示样本中位数。非参数bootstrap方法通过从经验分布 $\\hat{F}_{n}$（该分布在每个 $X_{i}$ 处赋予 $1/n$ 的质量）中有放回地重抽样来近似 $\\hat{m}$ 的抽样分布。生成 $B$ 个大小为 $n$ 的重抽样样本，计算bootstrap中位数 $\\hat{m}^{*(1)},\\dots,\\hat{m}^{*(B)}$，并用这些 $\\hat{m}^{*}$ 的经验分布来近似 $\\hat{m}$ 的分布。百分位法将双侧 $(1-\\alpha)$ 置信区间定义为\n$$\n[L_{b}, U_{b}] = \\left[ Q_{\\hat{m}^{*}}(\\alpha/2), \\; Q_{\\hat{m}^{*}}(1-\\alpha/2) \\right],\n$$\n其中 $Q_{\\hat{m}^{*}}(p)$ 是bootstrap中位数的经验 $p$-分位数。该方法在正则性条件下是渐近有效的，并且具有变换不变性，但对于小样本、严重偏斜或强离散性/重复值的情况，其表现可能不佳。\n\n每个样本的算法步骤：\n- 计算样本中位数 $\\hat{m}$。\n- 计算bootstrap百分位置信区间：\n  - 固定一个可复现的随机种子。\n  - 通过从 $\\{1,\\dots,n\\}$ 中有放回地均匀抽取索引来生成 $B$ 个bootstrap重抽样样本，并为每个重抽样样本计算中位数，得到 $b=1,\\dots,B$ 的 $\\hat{m}^{*(b)}$。\n  - 计算水平为 $\\alpha/2$ 和 $1-\\alpha/2$ 的经验分位数，以获得 $L_{b}$ 和 $U_{b}$。\n- 计算基于符号检验的区间：\n  - 设 $F_{S}(k)=\\mathbb{P}(S \\le k)$，其中 $S \\sim \\text{Binomial}(n, 0.5)$。找到满足 $F_{S}(k) \\le \\alpha/2$ 的最大整数 $k$。\n  - 设置 $L=k+1$ 和 $U=n-k$。对样本进行排序，并取 $L_{s}=X_{(L)}$ 和 $U_{s}=X_{(U)}$。\n- 计算宽度 $W_{b}=U_{b}-L_{b}$ 和 $W_{s}=U_{s}-L_{s}$，以及布尔值 $\\mathbf{1}\\{L_b \\le \\hat{m} \\le U_b\\}$、$\\mathbf{1}\\{L_s \\le \\hat{m} \\le U_s\\}$ 和 $\\mathbf{1}\\{L_b \\ge L_s \\text{ and } U_b \\le U_s\\}$。\n\n相对于基于精确符号检验的区间的解释：\n- 基于符号检验的区间 $[L_{s}, U_{s}]$ 在有限样本中是精确的，并且在 $F$ 在中位数处连续的假设下是免分布的，但它通常是保守的，因为它基于离散的二项分布尾部概率。这通常会导致更大的 $W_{s}$。\n- bootstrap百分位置信区间 $[L_{b}, U_{b}]$ 是一个近似区间，它使用观测数据作为总体的替代。它可能更窄（$W_{b}  W_{s}$），这在精度方面可能是有益的，但在小样本或偏斜样本中可能存在覆盖不足的风险。\n- 当 $[L_{b}, U_{b}] \\subseteq [L_{s}, U_{s}]$ 时，bootstrap区间与精确的非参数界限一致且更紧凑，表明小样本失真有限。如果 $[L_{b}, U_{b}]$ 超出了 $[L_{s}, U_{s}]$ 的范围，这反映了bootstrap的近似误差或偏斜/重复值的影响。\n- 在所提供的测试样本中，当 $\\alpha=0.05$ 且 $B=20000$ 时，由于保守性，我们预计基于符号检验的区间至少会和bootstrap区间一样宽，特别是对于中等大小的 $n$。包含指示符和宽度量化了每个数据集（以月为单位）的这种关系。\n\n实现细节：\n- 我们使用 $B=20000$ 和一个固定的种子来稳定bootstrap分位数。\n- 使用概率为 $0.5$ 的二项模型精确评估二项累积分布函数 $F_{S}(k)$，以确定索引 $L$ 和 $U$。\n- 所有结果均以月为单位报告为实数，不附加单位，最终输出为包含按指定顺序和格式排列的 $3$ 个列表的单行列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import binom\nimport json\n\ndef bootstrap_percentile_ci(data, alpha=0.05, B=20000, rng=None):\n    \"\"\"\n    Bootstrap percentile CI for the sample median.\n    data: 1D numpy array\n    alpha: significance level\n    B: number of bootstrap replicates\n    rng: numpy random Generator\n    Returns (L_b, U_b)\n    \"\"\"\n    n = data.size\n    if rng is None:\n        rng = np.random.default_rng()\n    # Sample bootstrap indices and compute medians\n    idx = rng.integers(0, n, size=(B, n))\n    samples = data[idx]\n    boot_medians = np.median(samples, axis=1)\n    # Percentile method: empirical quantiles at alpha/2 and 1-alpha/2\n    lower = np.quantile(boot_medians, alpha/2, method=\"linear\")\n    upper = np.quantile(boot_medians, 1 - alpha/2, method=\"linear\")\n    return float(lower), float(upper)\n\ndef sign_test_exact_ci(data, alpha=0.05):\n    \"\"\"\n    Exact sign-test-based CI for the population median using order statistics.\n    data: 1D numpy array\n    alpha: significance level\n    Returns (L_s, U_s)\n    \"\"\"\n    x = np.sort(np.asarray(data, dtype=float))\n    n = x.size\n    # Find largest k such that P(S = k) = alpha/2, S ~ Bin(n, 0.5)\n    # Start from k = 0 upwards until CDF exceeds alpha/2\n    half_alpha = alpha / 2.0\n    k = -1\n    # We increment j and track cdf; when cdf > half_alpha, k is j-1\n    j = 0\n    while True:\n        cdf = binom.cdf(j, n, 0.5)\n        if cdf = half_alpha:\n            k = j\n            j += 1\n            if j > n:\n                break\n        else:\n            break\n    # If k == -1, the interval would be unbounded; truncate to observed min/max.\n    L_index_1based = k + 1  # order statistic index L\n    U_index_1based = n - k  # order statistic index U\n    # Convert to 0-based indices and clip to [0, n-1]\n    lower_idx = max(L_index_1based - 1, 0)\n    upper_idx = min(U_index_1based - 1, n - 1)\n    return float(x[lower_idx]), float(x[upper_idx])\n\ndef analyze_sample(data, alpha=0.05, B=20000, rng=None, round_decimals=4):\n    data = np.asarray(data, dtype=float)\n    sample_median = float(np.median(data))\n    Lb, Ub = bootstrap_percentile_ci(data, alpha=alpha, B=B, rng=rng)\n    Ls, Us = sign_test_exact_ci(data, alpha=alpha)\n    Wb = Ub - Lb\n    Ws = Us - Ls\n    median_in_boot = (Lb = sample_median = Ub)\n    median_in_sign = (Ls = sample_median = Us)\n    boot_within_sign = (Lb >= Ls) and (Ub = Us)\n    # Round floats for stable, clean output\n    def r(x):\n        return float(np.round(x, round_decimals))\n    return [\n        r(sample_median),\n        r(Lb),\n        r(Ub),\n        r(Ls),\n        r(Us),\n        r(Wb),\n        r(Ws),\n        bool(median_in_boot),\n        bool(median_in_sign),\n        bool(boot_within_sign),\n    ]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # All times are in months.\n    sample1 = [12.1, 10.5, 9.7, 11.2, 13.4, 10.9, 12.6, 9.9, 11.5, 12.0, 10.8, 11.1]\n    sample2 = [3.2, 5.1, 4.0, 6.7, 8.5, 12.3, 7.1, 4.8, 15.6, 9.4, 10.2, 5.5, 6.0, 20.0]\n    sample3 = [6.0, 6.0, 6.0, 7.0, 8.0, 9.0, 10.0, 10.0, 11.0, 12.0, 12.0, 13.0]\n\n    alpha = 0.05\n    B = 20000\n    rng = np.random.default_rng(20251111)\n\n    test_cases = [\n        sample1,\n        sample2,\n        sample3,\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_sample(case, alpha=alpha, B=B, rng=rng, round_decimals=4)\n        results.append(result)\n\n    # Final print statement in the exact required format: single line, no spaces.\n    print(json.dumps(results, separators=(\",\", \":\")))\n\nsolve()\n```", "id": "4918314"}]}