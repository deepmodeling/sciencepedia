{"hands_on_practices": [{"introduction": "在任何严谨的科学研究开始之前，一个基本问题是：“我需要多少样本？” 这个问题不仅仅是后勤问题，它处于统计功效和资源效率的核心。本练习将指导您完成一项关键的生物统计学任务：为一项临床试验计算所需的样本量 [@problem_id:4941871]。通过从第一性原理推导，您将亲身体验第一类错误率 ($\\alpha$)、统计功效 ($1-\\beta$) 和临床上认为有意义的效应大小 ($\\Delta$) 如何共同决定研究的规模，从而确保研究既有能力检测到真实效应，又不会浪费宝贵的资源。", "problem": "一项随机、平行组临床试验将比较一种新的抗高血压药物与安慰剂在收缩压平均降低值上的差异。令 $\\mu_{1}$ 和 $\\mu_{2}$ 分别表示药物组和安慰剂组的真实平均降低值，并假设组内标准差在各组间是共同的且等于 $\\sigma$。研究者计划采用均等分配，每组 $n$ 名参与者，并将在显著性水平 $\\alpha = 0.05$ 下检验原假设 $H_{0}: \\mu_{1} - \\mu_{2} = 0$ 与双侧备择假设 $H_{1}: \\mu_{1} - \\mu_{2} \\neq 0$。在规划阶段，他们设定了一个具有临床意义的标准化均值差目标 $\\Delta = (\\mu_{1} - \\mu_{2})/\\sigma$，其大小为 $\\Delta = 0.40$，并要求在此备择假设下的检验效能为 $1 - \\beta = 0.90$。假设根据中心极限定理和稳定的方差规划，基于样本均值的双样本 $z$ 统计量在 $H_{0}$ 下近似服从标准正态分布，在 $H_{1}$ 下近似服从一个非零均值的正态分布。令 $z_{p}$ 表示标准正态分布的 $p$-分位数，定义为 $\\Phi(z_{p}) = p$，其中 $\\Phi(\\cdot)$ 是标准正态累积分布函数。\n\n请从 I 型错误 $\\alpha$、II 型错误 $\\beta$ 和检验效能 $1 - \\beta$ 的定义出发，并利用在 $H_{0}$ 和 $H_{1}$ 下双样本标准化均值差的近似分布，确定为达到设计规范所需的最小每组样本量 $n$。报告满足检验效能要求的最小整数 $n$。最终答案必须是一个无单位的数字。", "solution": "用户希望确定一项比较新药与安慰剂的随机临床试验中每组的最小样本量 $n$。\n\n### 步骤 1：问题陈述的验证\n用户提供了以下信息：\n- **分组**：两个平行组（药物组和安慰剂组），每组样本量相等，为 $n$。\n- **参数**：真实平均降低值 $\\mu_{1}$（药物组）和 $\\mu_{2}$（安慰剂组），以及共同的组内标准差 $\\sigma$。\n- **假设**：原假设 $H_{0}: \\mu_{1} - \\mu_{2} = 0$ 与双侧备择假设 $H_{1}: \\mu_{1} - \\mu_{2} \\neq 0$。\n- **显著性水平**：I 型错误率 $\\alpha = 0.05$。\n- **效应量**：目标标准化均值差 $\\Delta = (\\mu_{1} - \\mu_{2})/\\sigma = 0.40$。\n- **检验效能**：期望的检验效能为 $1 - \\beta = 0.90$，这意味着 II 型错误率为 $\\beta = 0.10$。\n- **假设**：使用双样本 $z$ 统计量，该统计量在 $H_{0}$ 下近似服从标准正态分布，在 $H_{1}$ 下近似服从非零均值的正态分布。\n- **符号**：$z_{p}$ 是标准正态分布 $\\Phi(\\cdot)$ 的 $p$-分位数。\n\n该问题具有科学依据，提法明确且客观。这是一个生物统计学中标准样本量计算问题，所有必要的参数和假设都已提供。该问题有效。\n\n### 步骤 2：样本量公式的推导\n令 $\\bar{X}_1$ 和 $\\bar{X}_2$ 分别为药物组和安慰剂组收缩压降低的样本均值。每组的样本量为 $n$。总体均值差的估计量为 $\\bar{X}_1 - \\bar{X}_2$。\n\n假设组间独立且方差共同为 $\\sigma^2$，该估计量的方差为：\n$$ \\text{Var}(\\bar{X}_1 - \\bar{X}_2) = \\text{Var}(\\bar{X}_1) + \\text{Var}(\\bar{X}_2) = \\frac{\\sigma^2}{n} + \\frac{\\sigma^2}{n} = \\frac{2\\sigma^2}{n} $$\n均值差的标准误 (SE) 为：\n$$ \\text{SE} = \\sqrt{\\frac{2\\sigma^2}{n}} = \\sigma\\sqrt{\\frac{2}{n}} $$\n双样本 $z$ 统计量的定义如下：\n$$ Z_{\\text{obs}} = \\frac{\\bar{X}_1 - \\bar{X}_2}{\\text{SE}} = \\frac{\\bar{X}_1 - \\bar{X}_2}{\\sigma\\sqrt{2/n}} $$\n在原假设 $H_{0}: \\mu_{1} - \\mu_{2} = 0$ 下，估计量的期望值为 $E[\\bar{X}_1 - \\bar{X}_2] = 0$。根据中心极限定理，检验统计量的分布近似为标准正态分布：\n$$ Z_{\\text{obs}} \\mid H_0 \\sim N(0, 1) $$\n对于显著性水平为 $\\alpha$ 的双侧检验，如果观测到的统计量的绝对值超过临界值 $c$，我们就拒绝 $H_{0}$。这个临界值是标准正态分布的 $1-\\alpha/2$ 分位数。\n$$ \\text{拒绝域: } |Z_{\\text{obs}}| > z_{1-\\alpha/2} $$\n给定 $\\alpha = 0.05$，我们有 $\\alpha/2 = 0.025$，临界值为 $z_{1-0.025} = z_{0.975}$。\n\n接下来，我们考虑在规划所需的特定备择假设 $H_1: (\\mu_1 - \\mu_2)/\\sigma = \\Delta$（这意味着 $\\mu_1 - \\mu_2 = \\Delta\\sigma$）下检验统计量的分布。在此备择假设下，估计量的期望值为 $E[\\bar{X}_1 - \\bar{X}_2] = \\Delta\\sigma$。\n在此 $H_1$ 下，检验统计量 $Z_{\\text{obs}}$ 的期望值为：\n$$ E[Z_{\\text{obs}} \\mid H_1] = \\frac{E[\\bar{X}_1 - \\bar{X}_2]}{\\sigma\\sqrt{2/n}} = \\frac{\\Delta\\sigma}{\\sigma\\sqrt{2/n}} = \\Delta\\sqrt{\\frac{n}{2}} $$\n$Z_{\\text{obs}}$ 的方差保持为 $1$。因此，在此备择假设下，其分布为：\n$$ Z_{\\text{obs}} \\mid H_1 \\sim N\\left(\\Delta\\sqrt{\\frac{n}{2}}, 1\\right) $$\n检验效能 $1-\\beta$ 是当 $H_1$ 为真时正确拒绝 $H_0$ 的概率。\n$$ 1 - \\beta = P\\left(|Z_{\\text{obs}}| > z_{1-\\alpha/2} \\mid H_1\\right) $$\n这是双侧尾部拒绝概率之和：\n$$ 1 - \\beta = P\\left(Z_{\\text{obs}} > z_{1-\\alpha/2} \\mid H_1\\right) + P\\left(Z_{\\text{obs}}  -z_{1-\\alpha/2} \\mid H_1\\right) $$\n由于 $\\Delta = 0.40$ 为正，在 $H_1$ 下 $Z_{\\text{obs}}$ 的均值为正。对于任何合理的样本量，$Z_{\\text{obs}}$ 的分布将向右移动，而项 $P(Z_{\\text{obs}}  -z_{1-\\alpha/2} \\mid H_1)$ 将可以忽略不计。因此，检验效能主要由上尾的拒绝概率决定。我们可以将检验效能近似为：\n$$ 1 - \\beta \\approx P\\left(Z_{\\text{obs}} > z_{1-\\alpha/2} \\mid H_1\\right) $$\n为了计算这个概率，我们使用 $Z_{\\text{obs}}$ 在 $H_1$ 下的分布对其进行标准化。令 $Z'$ 为一个标准正态随机变量。\n$$ 1 - \\beta \\approx P\\left( \\frac{Z_{\\text{obs}} - \\Delta\\sqrt{n/2}}{1} > z_{1-\\alpha/2} - \\Delta\\sqrt{\\frac{n}{2}} \\right) $$\n$$ 1 - \\beta \\approx P\\left( Z' > z_{1-\\alpha/2} - \\Delta\\sqrt{\\frac{n}{2}} \\right) $$\n利用标准正态累积分布函数 $\\Phi(\\cdot)$ 的性质 $P(Z' > x) = 1 - \\Phi(x) = \\Phi(-x)$：\n$$ 1 - \\beta \\approx \\Phi\\left( -\\left(z_{1-\\alpha/2} - \\Delta\\sqrt{\\frac{n}{2}}\\right) \\right) = \\Phi\\left( \\Delta\\sqrt{\\frac{n}{2}} - z_{1-\\alpha/2} \\right) $$\n我们已知要求的检验效能为 $1-\\beta$。根据定义，$1-\\beta = \\Phi(z_{1-\\beta})$。令 $\\Phi(\\cdot)$ 的参数相等：\n$$ z_{1-\\beta} = \\Delta\\sqrt{\\frac{n}{2}} - z_{1-\\alpha/2} $$\n现在，我们求解 $n$：\n$$ z_{1-\\alpha/2} + z_{1-\\beta} = \\Delta\\sqrt{\\frac{n}{2}} $$\n$$ \\left(z_{1-\\alpha/2} + z_{1-\\beta}\\right)^2 = \\Delta^2 \\left(\\frac{n}{2}\\right) $$\n$$ n = \\frac{2\\left(z_{1-\\alpha/2} + z_{1-\\beta}\\right)^2}{\\Delta^2} $$\n\n### 步骤 3：样本量的计算\n我们将给定值代入推导出的公式。\n- 显著性水平 $\\alpha = 0.05 \\implies z_{1-\\alpha/2} = z_{0.975} \\approx 1.95996$。\n- 检验效能 $1-\\beta = 0.90 \\implies z_{1-\\beta} = z_{0.90} \\approx 1.28155$。\n- 标准化效应量 $\\Delta = 0.40$。\n\n$$ n = \\frac{2(1.95996 + 1.28155)^2}{(0.40)^2} $$\n$$ n = \\frac{2(3.24151)^2}{0.16} $$\n$$ n = \\frac{2(10.50739)}{0.16} $$\n$$ n = \\frac{21.01478}{0.16} $$\n$$ n \\approx 131.342 $$\n由于样本量 $n$ 必须是整数，并且必须满足检验效能要求，我们必须将此值向上取整到下一个整数。\n$$ n = 132 $$\n因此，所需的最小每组样本量为 $132$ 名参与者。", "answer": "$$\\boxed{132}$$", "id": "4941871"}, {"introduction": "许多生物医学研究涉及成对观察，例如在治疗前后测量同一患者的指标。在这种情况下，数据点不是独立的，需要专门的分析方法。本练习 [@problem_id:4941841] 探讨了 McNemar 检验，这是一种用于分析成对二元结果的经典工具。您将通过关注“不一致”的配对（即结果发生变化的配对）来推导该检验，这一过程巧妙地展示了如何通过条件化策略消除讨厌的参数，从而构建一个精确且稳健的检验。", "problem": "一项配对临床研究评估了一种二元生物标志物状态（存在/缺失）的变化，该变化是在对相同的$50$名患者在开始新疗法前后进行测量的。对于每位患者，将配对结果定义为 $(Y_{\\text{pre}}, Y_{\\text{post}})$，其中 $Y \\in \\{0,1\\}$ 分别表示生物标志物的缺失或存在。观测到的配对结果的 $2 \\times 2$ 表如下：$a$ 名患者为 $(1,1)$，$b$ 名为 $(1,0)$，$c$ 名为 $(0,1)$，$d$ 名为 $(0,0)$，其中 $a=18$，$b=17$，$c=7$，$d=8$。\n\n从生物标志物存在的边际概率的原假设 $H_0: p_{\\text{pre}} = p_{\\text{post}}$ 的定义出发，并基于假设检验和独立配对的伯努利模型的基本原理，通过以下步骤推导用于配对二元结果的 McNemar 精确检验：\n- 阐明用于消除与总体不一致率相关的讨厌参数的条件化策略的合理性。\n- 在原假设 $H_0$ 下，给定不一致配对总数 $D=b+c$ 的情况下，指定 $(1,0)$ 不一致配对数量 $B$ 的分布。\n\n然后，使用您推导出的精确检验，计算观测数据的精确双边 $p$ 值。将您的最终数值答案四舍五入到四位有效数字。", "solution": "该问题要求推导用于配对二元结果的 McNemar 精确检验，并将其应用于给定的数据集以计算双边 $p$ 值。\n\n首先，让我们将模型形式化。我们有 $N$ 个独立的配对样本。对于每一对 $i \\in \\{1, \\dots, N\\}$，其结果为 $(Y_{i, \\text{pre}}, Y_{i, \\text{post}})$，其中每个 $Y$ 可以取值为 $0$（生物标志物缺失）或 $1$（生物标志物存在）。每一对有四种可能的结果：$(1,1)$、$(1,0)$、$(0,1)$ 和 $(0,0)$。设这些结果的概率分别为 $p_{11}$、$p_{10}$、$p_{01}$ 和 $p_{00}$，使得 $p_{11} + p_{10} + p_{01} + p_{00} = 1$。\n\n治疗前生物标志物存在的边际概率为 $p_{\\text{pre}} = P(Y_{\\text{pre}}=1)$。如果患者的结果是 $(1,1)$ 或 $(1,0)$，则其 $Y_{\\text{pre}}=1$。因此，$p_{\\text{pre}} = p_{11} + p_{10}$。\n类似地，治疗后生物标志物存在的边际概率为 $p_{\\text{post}} = P(Y_{\\text{post}}=1)$。如果患者的结果是 $(1,1)$ 或 $(0,1)$，则其 $Y_{\\text{post}}=1$。因此，$p_{\\text{post}} = p_{11} + p_{01}$。\n\n原假设 $H_0$ 是边际概率相等：$H_0: p_{\\text{pre}} = p_{\\text{post}}$。代入以联合概率表示的表达式，我们得到：\n$$H_0: p_{11} + p_{10} = p_{11} + p_{01}$$\n从两边减去 $p_{11}$，原假设简化为：\n$$H_0: p_{10} = p_{01}$$\n这意味着原假设等价于陈述从存在变为缺失的概率与从缺失变为存在的概率相同。状态未发生变化的配对，即所谓的一致配对（结果为 $(1,1)$ 和 $(0,0)$），对评估此特定原假设没有贡献，因为它们的基础概率 $p_{11}$ 和 $p_{00}$ 不涉及简化的 $H_0$。\n\n观测数据由四种结果的计数组成：$a$ 为 $(1,1)$，$b$ 为 $(1,0)$，$c$ 为 $(0,1)$，$d$ 为 $(0,0)$。对于总共 $N=a+b+c+d$ 对，观测到这些计数的似然遵循多项分布：\n$$L(p_{11}, p_{10}, p_{01}, p_{00} | a, b, c, d) \\propto p_{11}^a p_{10}^b p_{01}^c p_{00}^d$$\n在 $H_0$ 下，其中 $p_{10} = p_{01} = p_{\\text{discord}}$，似然函数变为：\n$$L \\propto p_{11}^a (p_{\\text{discord}})^b (p_{\\text{discord}})^c p_{00}^d = p_{11}^a p_{\\text{discord}}^{b+c} p_{00}^d$$\n该似然函数依赖于讨厌参数，具体来说是 $p_{11}$ 和 $p_{\\text{discord}}$（或等价地，$p_{11}$ 和 $p_{00}$，因为概率之和必须为 $1$）。为了构建一个独立于这些讨厌参数的检验，我们使用条件化论证。我们对数据中对于讨厌参数而言是充分统计量的方面进行条件化，从而使条件分布仅依赖于我们感兴趣的参数。\n\n关键的见解是只关注不一致的配对，即结果为 $(1,0)$ 和 $(0,1)$ 的配对。不一致配对的总数为 $D = b+c$。让我们考虑一个配对是 $(1,0)$ 类型的条件概率，*假定*它是不一致的。设这个条件概率为 $\\pi$。\n$$\\pi = P(\\text{outcome is } (1,0) | \\text{outcome is discordant}) = \\frac{P(\\text{outcome is } (1,0))}{P(\\text{outcome is discordant})} = \\frac{p_{10}}{p_{10} + p_{01}}$$\n在原假设 $H_0: p_{10} = p_{01}$ 下，这个条件概率变为：\n$$\\pi_0 = \\frac{p_{10}}{p_{10} + p_{10}} = \\frac{p_{10}}{2p_{10}} = \\frac{1}{2}$$\n这种条件化策略非常有效，因为它产生了一个无参数的原分布。鉴于我们观测到总共 $D = b+c$ 个不一致配对，这些配对中的每一个都可以被视为一次独立的伯努利试验。在 $H_0$ 下，“成功”（观测到一个 $(1,0)$ 配对）的概率是 $1/2$。因此，在给定不一致配对总数 $D$ 的条件下，表示为随机变量 $B$ 的 $(1,0)$ 配对的数量，遵循二项分布。\n\n具体来说，在 $H_0$ 下，给定 $D=b+c$ 时 $B$ 的分布是：\n$$B | D=b+c \\sim \\text{Binomial}\\left(n = b+c, p = \\frac{1}{2}\\right)$$\n其概率质量函数由下式给出：\n$$P(B=k | D=n) = \\binom{n}{k} \\left(\\frac{1}{2}\\right)^k \\left(1-\\frac{1}{2}\\right)^{n-k} = \\binom{n}{k} \\left(\\frac{1}{2}\\right)^n$$\n这是 McNemar 精确检验的基础。\n\n现在，我们将此检验应用于所提供的数据：\n- $a = 18$\n- $b = 17$ (这些是 $(1,0)$ 类型的配对)\n- $c = 7$ (这些是 $(0,1)$ 类型的配对)\n- $d = 8$\n患者总数为 $N = 18+17+7+8 = 50$。\n\n不一致配对的数量为 $n = b+c = 17+7=24$。\n我们的检验统计量的观测值为 $b_{obs} = 17$。\n此检验的原分布为 $\\text{Binomial}(n=24, p=1/2)$。\n\n我们需要计算双边 $p$ 值。这是观测到与 $b_{obs}=17$ 一样极端或更极端的结果的概率。对于像 $\\text{Binomial}(n, 1/2)$ 这样的对称分布，期望值为 $E[B] = n \\times p = 24 \\times 1/2 = 12$。\n观测值 $17$ 与均值相差 $17-12=5$ 个单位。在下尾部同样极端的值是 $12-5=7$。因此，“一样或更极端”对应于观测到 $B \\ge 17$ 或 $B \\le 7$。\n\n双边 $p$ 值为 $P(B \\ge 17) + P(B \\le 7)$。\n$$p\\text{-value} = \\sum_{k=17}^{24} P(B=k) + \\sum_{k=0}^{7} P(B=k)$$\n$$p\\text{-value} = \\sum_{k=17}^{24} \\binom{24}{k} \\left(\\frac{1}{2}\\right)^{24} + \\sum_{k=0}^{7} \\binom{24}{k} \\left(\\frac{1}{2}\\right)^{24}$$\n由于二项式系数的对称性，$\\binom{n}{k} = \\binom{n}{n-k}$。在我们的例子中，$\\binom{24}{17} = \\binom{24}{7}$，$\\binom{24}{18} = \\binom{24}{6}$，依此类推。因此，这两个和是相等的。\n$$p\\text{-value} = 2 \\times \\sum_{k=17}^{24} \\binom{24}{k} \\left(\\frac{1}{2}\\right)^{24}$$\n我们计算二项式系数的和：\n$\\binom{24}{17} = 346104$\n$\\binom{24}{18} = 134596$\n$\\binom{24}{19} = 42504$\n$\\binom{24}{20} = 10626$\n$\\binom{24}{21} = 2024$\n$\\binom{24}{22} = 276$\n$\\binom{24}{23} = 24$\n$\\binom{24}{24} = 1$\n和为 $346104 + 134596 + 42504 + 10626 + 2024 + 276 + 24 + 1 = 536155$。\n归一化因子为 $(1/2)^{24} = 1/16777216$。\n\n$p$ 值为：\n$$p\\text{-value} = 2 \\times \\frac{536155}{16777216} = \\frac{1072310}{16777216}$$\n$$p\\text{-value} \\approx 0.06391404$$\n四舍五入到四位有效数字，我们得到 $0.06391$。", "answer": "$$\\boxed{0.06391}$$", "id": "4941841"}, {"introduction": "假设检验的基本逻辑源于随机化本身：如果一项治疗完全没有效果，那么我们观察到的结果仅仅是由于受试者被随机分配到不同组别的偶然结果。本练习 [@problem_id:4941799] 将此核心思想转化为一个具体的计算实践：构建一个分层置换检验。您将编写代码，通过在每个分层内重复模拟随机分配的过程，来为您的检验统计量生成一个零分布，从而在不依赖参数假设的情况下计算 p 值。这个动手实践不仅加深了对 p 值基本含义的理解，还展示了如何处理分层等复杂的研究设计。", "problem": "您需要为一项具有连续性结果、采用分层随机化的双臂随机对照试验（Randomized Controlled Trial, RCT）构建一个置换检验。该任务要求您形式化定义原假设，定义一个使用分层的、科学上合理的检验统计量，指定一个合适的置换方案，并实现一个程序来为多个测试用例计算基于随机化的双侧 p 值。该程序必须遵守以下设计原则和输出要求。\n\n此推导的基础是通过随机化推断进行假设检验的定义：在无处理效应的原假设下，观测到的结果对于处理分配是不变的，并且任何检验统计量在原假设下的分布都可以通过根据随机化方案置换处理标签来获得。具体来说，在分层随机化下，处理分配在每个层内是可交换的，条件是该层内分配给处理组和控制组的数量不变。\n\n将原假设定义为 $H_0$：处理对任何参与者的结果都没有影响，因此两臂之间的任何结果差异都可归因于随机分配。将备择假设定义为 $H_1$：处理组和控制组之间的平均结果存在非零差异。\n\n您必须指定一个既能捕捉平均处理效应又尊重分层结构的检验统计量。从概念上讲，该检验统计量应为各层臂均值的聚合对比，其中每个层的贡献与其规模成正比，从而确保无论参与者在哪一层，其贡献都是均等的。换言之，在每个层内计算处理组的平均结果与控制组的平均结果之间的差异，然后使用与层规模成比例的权重聚合这些特定于层的差异，形成一个单一的对比值。\n\n对于置换方案，仅在每个层内部置换处理标签，同时保持该层内观测到的处理组和控制组参与者的数量不变。这尊重了原始的分层随机化设计，并确保了在 $H_0$ 下的可交换性。\n\n对于双侧 p 值，使用所选检验统计量在分层置换方案下的随机化分布，并计算其检验统计量绝对值至少与观测到的检验统计量绝对值一样极端的置换所占的比例，即，计算满足 $|T_{\\text{perm}}| \\ge |T_{\\text{obs}}|$ 的置换数量，然后除以所考虑的置换总数。将 p 值表示为小数。\n\n当分层置换的总数不是太大时，精确枚举是可行的。设 $n_h$ 表示层 $h$ 的大小，设 $n_{1h}$ 表示层 $h$ 中接受处理的人数。分层置换的总数是各层 ${n_h \\choose n_{1h}}$ 的乘积。如果此乘积小于或等于 100000，您的程序必须执行精确枚举。如果该乘积超过 100000，则使用 $M=100000$ 个均匀抽样的分层置换进行蒙特卡洛 (MC) 近似。为保证可复现性，请对蒙特卡洛随机数生成器使用固定的种子 42。\n\n输入嵌入在程序中；不要读取外部输入。对于每个测试用例，您将获得：\n- $y$：连续结果的列表，\n- $z$：二元处理标签的列表，1 代表处理，0 代表控制，\n- $s$：整数分层标签的列表。\n\n按照描述为每个测试用例计算双侧分层置换 p 值。将每个 p 值四舍五入到 6 位小数。您的程序应生成单行输出，其中包含所有测试用例的 p 值，格式为方括号内以逗号分隔的列表。\n\n要实现的测试套件：\n- 案例 1（两个层，均衡，精确枚举）：\n  - $y = [5.2, 4.8, 3.9, 4.1, 6.1, 5.2, 6.3, 5.0, 6.0, 5.1]$\n  - $z = [1, 1, 0, 0, 1, 0, 1, 0, 1, 0]$\n  - $s = [0, 0, 0, 0, 1, 1, 1, 1, 1, 1]$\n- 案例 2（单个层，精确枚举）：\n  - $y = [10.2, 10.5, 9.4, 9.6, 10.1, 9.5]$\n  - $z = [1, 1, 0, 0, 1, 0]$\n  - $s = [0, 0, 0, 0, 0, 0]$\n- 案例 3（三个层，规模不等，效应接近于零，精确枚举）：\n  - $y = [7.0, 7.1, 6.9, 5.0, 5.1, 5.2, 5.1, 8.0, 7.9, 8.1, 8.0, 8.0]$\n  - $z = [1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0]$\n  - $s = [0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2]$\n- 案例 4（三个层，规模较大，蒙特卡洛近似）：\n  - $y = [11.0, 10.8, 11.2, 11.1, 10.3, 10.4, 10.2, 10.5, 9.5, 9.7, 9.0, 8.9, 9.1, 9.6, 9.0, 8.8, 9.4, 7.9, 7.5, 8.0, 7.6, 7.8, 7.4, 7.9, 7.5, 8.1, 7.6]$\n  - $z = [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]$\n  - $s = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]$\n\n最终输出格式：\n- 一行包含四个 p 值的、以逗号分隔的列表，用方括号括起来，例如 $[p_1,p_2,p_3,p_4]$，其中每个 $p_i$ 是一个四舍五入到 6 位的小数。", "solution": "问题陈述已经过严格验证，被认为是有效的。它以用于对照试验的、基于随机化的推断原则为科学基础，问题定义良好，目标明确，数据充分，并使用客观、正式的语言。因此，我们可以着手提供解决方案。\n\n该问题要求为双臂随机对照试验（RCT）实现一个分层置换检验。解决方案涉及形式化定义原假设和检验统计量，定义尊重分层设计的置换过程，并计算双侧 p 值，根据可能的置换总数在精确枚举和蒙特卡洛近似之间切换。\n\n设参与者总数为 $N$。每个参与者 $i \\in \\{1, ..., N\\}$ 均由一个连续性结果 $y_i$、一个二元处理分配 $z_i \\in \\{0, 1\\}$（1 代表处理，0 代表控制）和一个分层标签 $s_i$ 来表征。设 $H$ 为唯一层的集合。对于每个层 $h \\in H$，设 $I_h = \\{i | s_i = h\\}$ 为该层中参与者的索引集合。层 $h$ 的大小为 $n_h = |I_h|$。层 $h$ 中接受处理和控制的参与者数量分别为 $n_{1h} = \\sum_{i \\in I_h} z_i$ 和 $n_{0h} = n_h - n_{1h}$。总样本量为 $N = \\sum_{h \\in H} n_h$。\n\n尖锐原假设 $H_0$ 假定，处理对任何参与者的结果都没有影响。这意味着每个参与者的结果 $y_i$ 是一个固定的特征，与其处理分配 $z_i$ 无关。在 $H_0$ 下，即使处理分配不同，观测到的结果也会是相同的。备择假设 $H_1$ 是存在非零的平均处理效应。\n\n检验统计量必须是一个单一值，该值在考虑分层设计的同时，总结了处理臂之间的差异。问题指定了一个检验统计量，它是按层大小加权的、特定于层的对比的聚合。这确保了较大的层对整体统计量的贡献更大。让我们将其形式化。\n\n在每个层 $h \\in H$ 内，处理组的平均结果是：\n$$ \\bar{y}_{1h} = \\frac{\\sum_{i \\in I_h} y_i z_i}{n_{1h}} $$\n对于控制组：\n$$ \\bar{y}_{0h} = \\frac{\\sum_{i \\in I_h} y_i (1 - z_i)}{n_{0h}} $$\n特定于层的均值差异是 $\\Delta_h = \\bar{y}_{1h} - \\bar{y}_{0h}$。总体检验统计量 $T$ 是这些差异的加权平均值，权重与层大小 $n_h$ 成正比：\n$$ T = \\sum_{h \\in H} w_h \\Delta_h = \\sum_{h \\in H} \\frac{n_h}{N} (\\bar{y}_{1h} - \\bar{y}_{0h}) $$\n这是一个标准的、科学上合理的选择，通常被称为分层均值差。问题中“从而确保无论参与者在哪一层，其贡献都是均等的”这句话应在这种加权平均结构的背景下解释，这是聚合层级效应以估计总体平均效应的标准方法，而不是指每个 $y_i$ 都有字面意义上相等的系数。\n\n在 $H_0$ 下，处理分配 $z_i$ 在每个层内是可交换的，条件是计数 $n_{1h}$ 和 $n_{0h}$ 不变。这意味着在层内对处理标签的任何置换都与观测到的分配同样可能。与分层设计一致的可能处理分配总数是每个层内选择被处理个体的方式数量的乘积：\n$$ K = \\prod_{h \\in H} \\binom{n_h}{n_{1h}} $$\n\n置换检验按以下步骤进行：\n1.  计算观测数据的检验统计量，记为 $T_{\\text{obs}}$。\n2.  在 $H_0$ 下为检验统计量生成一个参考分布。这是通过创建一组置换后的处理分配 $z_{\\text{perm}}$ 来完成的。对于每个 $z_{\\text{perm}}$，都会计算一个相应的检验统计量 $T_{\\text{perm}}$。\n3.  生成置换集的方法取决于总计数 $K$：\n    a.  **精确枚举**：如果 $K \\le 100000$，我们生成所有 $K$ 种可能的有效分层分配。对于每个层 $h$，我们考虑所有 $\\binom{n_h}{n_{1h}}$ 种将 $n_{1h}$ 个个体分配到处理组的方式。完整的分配集是所有层这些可能性的笛卡尔积。\n    b.  **蒙特卡洛近似**：如果 $K > 100000$，我们生成大量的随机置换，数量为 $M=100000$。每个随机置换的构建方式是：在每个层 $h$ 内随机选择 $n_{1h}$ 名参与者进入处理组，各层之间独立进行。此抽样为不放回抽样。\n4.  双侧 p 值是其检验统计量的绝对值大于或等于观测到的检验统计量绝对值的置换（来自精确集或蒙特卡洛样本）所占的比例：\n$$ p = \\frac{\\sum_{j=1}^{N_{\\text{total}}} \\mathbb{I}(|T_{j}| \\ge |T_{\\text{obs}}|)}{N_{\\text{total}}} $$\n此处，$N_{\\text{total}}$ 对于精确检验是 $K$，对于蒙特卡洛检验是 $M$，$T_j$ 是第 $j$ 次置换的检验统计量，而 $\\mathbb{I}(\\cdot)$ 是指示函数。观测到的数据配置是可能的置换之一，并包含在此计算中。\n\n此过程提供了一种对尖锐原假设的非参数、无假设检验，它正确地遵循了研究设计中使用的随机化方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\nimport itertools\n\ndef calculate_p_value(y, z, s):\n    \"\"\"\n    Computes the two-sided stratified permutation p-value for a given dataset.\n\n    Args:\n        y (list): Continuous outcomes.\n        z (list): Binary treatment labels (1=treatment, 0=control).\n        s (list): Integer stratum labels.\n\n    Returns:\n        float: The calculated p-value, rounded to 6 decimal places.\n    \"\"\"\n    # Convert inputs to numpy arrays for efficient computation.\n    y = np.array(y)\n    z = np.array(z)\n    s = np.array(s)\n    N = len(y)\n\n    strata_labels = np.unique(s)\n    strata_info = {}\n    for stratum_label in strata_labels:\n        indices = np.where(s == stratum_label)[0]\n        n_h = len(indices)\n        n_1h = np.sum(z[indices])\n        strata_info[stratum_label] = {\n            'indices': indices,\n            'n_h': n_h,\n            'n_1h': int(n_1h)\n        }\n\n    def compute_statistic(z_vec):\n        \"\"\"Calculates the stratified difference in means test statistic.\"\"\"\n        stat_val = 0.0\n        for stratum_label, info in strata_info.items():\n            indices = info['indices']\n            n_h = info['n_h']\n            \n            y_h = y[indices]\n            z_h = z_vec[indices]\n            \n            n_1h = np.sum(z_h)\n            n_0h = n_h - n_1h\n\n            # If a stratum has all treated or all control, its contribution is 0.\n            if n_1h == 0 or n_0h == 0:\n                continue\n\n            mean_1h = np.sum(y_h[z_h == 1]) / n_1h\n            mean_0h = np.sum(y_h[z_h == 0]) / n_0h\n            \n            delta_h = mean_1h - mean_0h\n            stat_val += (n_h / N) * delta_h\n            \n        return stat_val\n\n    # Calculate the observed test statistic.\n    T_obs = compute_statistic(z)\n    abs_T_obs = abs(T_obs)\n\n    # Calculate the total number of possible permutations.\n    total_permutations = 1\n    for info in strata_info.values():\n        total_permutations *= comb(info['n_h'], info['n_1h'], exact=True)\n\n    if total_permutations = 100000:\n        # Perform exact enumeration.\n        \n        # Generate combinations of treated indices for each stratum.\n        stratum_combinations = []\n        for stratum_label in strata_labels:\n            info = strata_info[stratum_label]\n            indices_h = info['indices']\n            n_1h = info['n_1h']\n            stratum_combinations.append(list(itertools.combinations(indices_h, n_1h)))\n        \n        count_extreme = 0\n        \n        # Iterate through the Cartesian product of all stratum-level combinations.\n        for permuted_treated_indices_tuple in itertools.product(*stratum_combinations):\n            z_perm = np.zeros(N, dtype=int)\n            for treated_indices_for_stratum in permuted_treated_indices_tuple:\n                z_perm[list(treated_indices_for_stratum)] = 1\n            \n            T_perm = compute_statistic(z_perm)\n            \n            if abs(T_perm) >= abs_T_obs:\n                count_extreme += 1\n                \n        p_value = count_extreme / total_permutations\n    \n    else:\n        # Perform Monte Carlo approximation.\n        M = 100000\n        rng = np.random.default_rng(seed=42)\n        count_extreme = 0\n        \n        for _ in range(M):\n            z_perm = np.zeros(N, dtype=int)\n            for info in strata_info.values():\n                indices_h = info['indices']\n                n_1h = info['n_1h']\n                \n                # Randomly choose which subjects are treated within the stratum.\n                permuted_treated_indices = rng.choice(indices_h, size=n_1h, replace=False)\n                z_perm[permuted_treated_indices] = 1\n            \n            T_perm = compute_statistic(z_perm)\n            \n            if abs(T_perm) >= abs_T_obs:\n                count_extreme += 1\n                \n        p_value = count_extreme / M\n\n    return round(p_value, 6)\n    \ndef solve():\n    \"\"\"\n    Main function to define test cases and compute p-values.\n    \"\"\"\n    test_cases = [\n        # Case 1 (two strata, balanced, exact enumeration)\n        {\n            \"y\": [5.2, 4.8, 3.9, 4.1, 6.1, 5.2, 6.3, 5.0, 6.0, 5.1],\n            \"z\": [1, 1, 0, 0, 1, 0, 1, 0, 1, 0],\n            \"s\": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1]\n        },\n        # Case 2 (single stratum, exact enumeration)\n        {\n            \"y\": [10.2, 10.5, 9.4, 9.6, 10.1, 9.5],\n            \"z\": [1, 1, 0, 0, 1, 0],\n            \"s\": [0, 0, 0, 0, 0, 0]\n        },\n        # Case 3 (three strata, unequal sizes, near-zero effect, exact enumeration)\n        {\n            \"y\": [7.0, 7.1, 6.9, 5.0, 5.1, 5.2, 5.1, 8.0, 7.9, 8.1, 8.0, 8.0],\n            \"z\": [1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0],\n            \"s\": [0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2]\n        },\n        # Case 4 (three strata, larger sizes, Monte Carlo approximation)\n        {\n            \"y\": [11.0, 10.8, 11.2, 11.1, 10.3, 10.4, 10.2, 10.5, 9.5, 9.7, 9.0, 8.9, 9.1, 9.6, 9.0, 8.8, 9.4, 7.9, 7.5, 8.0, 7.6, 7.8, 7.4, 7.9, 7.5, 8.1, 7.6],\n            \"z\": [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],\n            \"s\": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p_val = calculate_p_value(case[\"y\"], case[\"z\"], case[\"s\"])\n        results.append(p_val)\n    \n    # Format the results into the required string format.\n    # The f-string formatting ensures each number has 6 decimal places.\n    output_str = f\"[{','.join([f'{p:.6f}' for p in results])}]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "4941799"}]}