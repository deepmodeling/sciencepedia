{"hands_on_practices": [{"introduction": "在估计总体比例时，存在多种不同的“近似”置信区间方法。我们应该如何选择最优的方法呢？本练习将指导你使用蒙特卡洛模拟——生物统计学家工具箱中的一个强大工具——来凭经验评估三种常用方法（Wald、Wilson 和 Agresti-Coull）的性能。通过评估它们的实际覆盖率和期望长度，你将理解为什么最简单的方法有时会产生误导，以及为何其他方法在实践中表现更佳。[@problem_id:4911278]", "problem": "单个总体比率可用二项分布建模。设 $X$ 为 $n$ 次独立伯努利试验中观测到的成功次数，其成功概率为 $p$，因此 $X \\sim \\mathrm{Binomial}(n,p)$，样本比率为 $\\hat{p} = X/n$。$p$ 的置信区间可以通过将此模型与大样本近似和检验反演相结合来导出。您的任务是导出、实现并比较三种区间：Wald 区间、Wilson 得分区间和 Agresti–Coull 区间。\n\n从二项模型以及得分检验和 Wald 检验的定义出发，仅使用基本原理推导每种区间：\n- 从二项似然函数以及得分检验和 Wald 检验的定义开始。\n- 在适当的情况下，通过（适用于独立同分布伯努利变量的）中心极限定理，证明对于大样本量 $n$ 时 $\\hat{p}$ 的正态近似的合理性。\n- 通过反演基于二项模型的 $p$ 的得分检验，得到 Wilson 得分区间。\n- 通过在调整后的样本比率上应用受 Wilson 得分区间启发的 add-$z^2$ 方法和 Wald 型形式，得到 Agresti–Coull 区间。\n\n所有区间都必须截断到 $p$ 的有效参数范围 $[0,1]$ 内。\n\n对于固定的名义置信水平 $1-\\alpha$，将区间程序的覆盖概率定义为：在数据生成的 $p$ 下，真实的 $p$ 落在基于 $X$ 计算出的区间内的概率。将区间的期望长度定义为：在数据生成的 $p$ 下，区间长度的期望值。在此任务中，通过蒙特卡洛模拟对这两个量进行经验性近似。\n\n实现要求：\n- 对于每个测试用例，模拟 $R$ 个独立的实现 $X_r \\sim \\mathrm{Binomial}(n,p)$，$r=1,\\dots,R$，根据 $X_r$ 计算三种区间，并将覆盖率估计为区间包含真实 $p$ 值的模拟所占的比例。将期望长度估计为 $R$ 次模拟中区间长度的平均值。\n- 使用从标准正态分布中获得的与双边水平 $\\alpha$ 对应的标准正态分位数 $z$。\n- 为了可复现性，使用固定的随机数生成器种子，其值为 $20231111$。\n- 所有覆盖概率必须以小数形式表示（不带百分号）。\n- 输出必须将所有测试用例的结果汇总为单行。每个测试用例贡献六个数字，顺序如下：Wald 覆盖率、Wald 期望长度、Wilson 覆盖率、Wilson 期望长度、Agresti–Coull 覆盖率、Agresti–Coull 期望长度。每个数字必须四舍五入到四位小数。\n\n测试套件：\n- 置信水平：$1-\\alpha = 0.95$，即 $\\alpha = 0.05$（小数形式）。\n- 对于中等样本量和一系列成功概率（包括内部值和边界邻近值），使用以下用例（其中 $R$ 表示每个用例的蒙特卡洛抽样次数）：\n  1. $(n,p,\\alpha,R) = (40, 0.10, 0.05, 100000)$，\n  2. $(n,p,\\alpha,R) = (80, 0.50, 0.05, 100000)$，\n  3. $(n,p,\\alpha,R) = (60, 0.90, 0.05, 100000)$，\n  4. $(n,p,\\alpha,R) = (50, 0.02, 0.05, 100000)$，\n  5. $(n,p,\\alpha,R) = (50, 0.98, 0.05, 100000)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的 Python 列表的列表形式的结果，每个内部列表对应一个测试用例，并严格按照上述顺序排列。例如，输出行必须如下所示：\n$[\\,[c_{1,\\mathrm{Wald}},\\ell_{1,\\mathrm{Wald}},c_{1,\\mathrm{Wilson}},\\ell_{1,\\mathrm{Wilson}},c_{1,\\mathrm{AC}},\\ell_{1,\\mathrm{AC}}],\\dots,[c_{5,\\mathrm{Wald}},\\ell_{5,\\mathrm{Wald}},c_{5,\\mathrm{Wilson}},\\ell_{5,\\mathrm{Wilson}},c_{5,\\mathrm{AC}},\\ell_{5,\\mathrm{AC}}]\\,]$,\n其中每个 $c$ 是十进制形式的覆盖概率，每个 $\\ell$ 是十进制形式的期望长度，所有数值均四舍五入至四位小数。", "solution": "该问题要求对单个二项比率 $p$ 的三种常用近似置信区间进行推导、实现和经验比较。统计模型假设，在大小为 $n$ 的样本中，观测到的成功次数 $X$ 服从二项分布，即 $X \\sim \\mathrm{Binomial}(n,p)$。样本比率 $\\hat{p} = X/n$ 作为 $p$ 的点估计量。\n\n这些大样本近似区间的基础是中心极限定理 (CLT)。由于 $X$ 是 $n$ 个独立同分布的 $\\mathrm{Bernoulli}(p)$ 随机变量之和，CLT 保证了对于足够大的样本量 $n$，$\\hat{p}$ 的抽样分布近似为正态分布：\n$$\n\\hat{p} \\approx \\mathcal{N}\\left(p, \\frac{p(1-p)}{n}\\right)\n$$\n这意味着标准化随机变量 $Z = \\frac{\\hat{p}-p}{\\sqrt{p(1-p)/n}}$ 依分布收敛于标准正态分布 $\\mathcal{N}(0,1)$。这三种区间都是通过反演原假设为 $H_0: p = p_0$ 的统计检验来构建的，但它们在处理标准误项 $\\sqrt{p(1-p)/n}$ 上的方式有所不同，因为该项依赖于未知参数 $p$。对于名义置信水平 $1-\\alpha$，我们使用临界值 $z_{\\alpha/2}$，即标准正态分布的上 $\\alpha/2$ 分位数。\n\n**Wald 区间**\n\nWald 区间是通过反演 Wald 检验得出的。在 Wald 检验统计量中，标准误项中的未知参数 $p$ 被其最大似然估计量 $\\hat{p}$ 替代。因此，对于 $H_0: p = p_0$ 的检验统计量为 $Z = \\frac{\\hat{p}-p_0}{\\sqrt{\\hat{p}(1-\\hat{p})/n}}$。$p$ 的 $100(1-\\alpha)\\%$ 置信区间被定义为所有使得该检验在显著性水平 $\\alpha$ 下不拒绝原假设的 $p_0$ 值的集合。这对应于不等式：\n$$\n\\left| \\frac{\\hat{p}-p}{\\sqrt{\\hat{p}(1-\\hat{p})/n}} \\right| \\le z_{\\alpha/2}\n$$\n对该不等式求解 $p$ 可得对称的 Wald 区间：\n$$\n\\hat{p} \\pm z_{\\alpha/2} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}}\n$$\n虽然简单，但该区间的性能较差，尤其是在 $n$ 较小或 $p$ 接近边界 $0$ 或 $1$ 时。其实际覆盖概率常常低于名义水平。当 $\\hat{p}=0$ 或 $\\hat{p}=1$ 时，会出现一个严重缺陷，此时标准误为 $0$，导致一个荒谬的零宽度区间。根据问题要求，所得区间必须被截断，以确保其位于有效的参数空间 $[0,1]$ 内。\n\n**Wilson 得分区间**\n\nWilson 得分区间是通过反演得分检验得出的。得分检验在标准误项中保留了参数的原假设值 $p$。置信区间是满足以下不等式的所有 $p$ 值的集合：\n$$\n\\left| \\frac{\\hat{p}-p}{\\sqrt{p(1-p)/n}} \\right| \\le z_{\\alpha/2}\n$$\n令 $z = z_{\\alpha/2}$，两边平方得到 $(\\hat{p}-p)^2 \\le z^2 \\frac{p(1-p)}{n}$。整理此表达式会得到一个关于 $p$ 的二次不等式。区间的端点是相应二次方程的根：\n$$\n(n+z^2)p^2 - (2n\\hat{p} + z^2)p + n\\hat{p}^2 = 0\n$$\n应用二次公式，定义区间的两个 $p$ 的根为：\n$$\n\\frac{n\\hat{p} + z^2/2}{n+z^2} \\pm \\frac{z}{n+z^2} \\sqrt{n\\hat{p}(1-\\hat{p}) + z^2/4}\n$$\nWilson 区间的性能远优于 Wald 区间。它通常是非对称的（除非 $\\hat{p}=0.5$），并且即使对于较小的样本量和接近边界的比率，其覆盖概率也更接近名义的 $1-\\alpha$ 水平。它本身就包含在 $[0,1]$ 内部，因此不需要显式截断。\n\n**Agresti-Coull 区间**\n\nAgresti-Coull (AC) 区间是一种备受推崇的调整方法，它将 Wilson 区间的优越性能特点与 Wald 区间的简单结构相结合。其推导受到 Wilson 区间中心点 $\\frac{X + z^2/2}{n+z^2}$ 的启发。该表达式可以看作是基于调整后的样本量 $\\tilde{n} = n+z^2$ 和调整后的成功次数 $\\tilde{X} = X + z^2/2$ 的新样本比率。AC 区间就是一个使用这些调整后数值计算的 Wald 型区间。\n令 $z = z_{\\alpha/2}$。首先，我们定义调整后的样本比率：\n$$\n\\tilde{p} = \\frac{X + z^2/2}{n + z^2}\n$$\n然后，AC 区间构造如下：\n$$\n\\tilde{p} \\pm z \\sqrt{\\frac{\\tilde{p}(1-\\tilde{p})}{\\tilde{n}}} \\quad \\text{其中 } \\tilde{n} = n+z^2\n$$\n对于 $95\\%$ 的置信水平，$z \\approx 1.96$ 且 $z^2 \\approx 3.84$，通常简化为 $z^2 \\approx 4$。这就引出了著名的“加 2 次成功和 2 次失败”规则。我们将使用包含 $z^2$ 精确值的更通用形式。AC 区间也必须截断到 $[0,1]$ 范围内。\n\n**蒙特卡洛评估方法**\n\n为了对这三种区间的性质进行经验性评估和比较，我们采用蒙特卡洛模拟。对于测试套件中指定的每个参数组合 $(n, p, \\alpha, R)$，我们执行以下步骤：\n1.  从二项分布中生成 $R$ 个独立的随机变量：$X_r \\sim \\mathrm{Binomial}(n,p)$，其中 $r = 1, \\dots, R$。\n2.  对于每次实现 $X_r$，计算样本比率 $\\hat{p}_r = X_r/n$，然后计算三种置信区间（Wald、Wilson、Agresti-Coull）的下界和上界。\n3.  每种区间类型的经验覆盖概率计算为在 $R$ 次模拟中，真实参数值 $p$ 被包含在计算出的区间内的比例：\n    $$\n    \\text{覆盖率} = \\frac{1}{R} \\sum_{r=1}^R \\mathbb{I}(p \\in [L_r, U_r])\n    $$\n    其中 $[L_r, U_r]$ 是第 $r$ 次模拟的区间，$\\mathbb{I}(\\cdot)$ 是指示函数。\n4.  每个区间的期望长度通过对 $R$ 个计算出的区间长度取平均值来估计：\n    $$\n    \\text{期望长度} = \\frac{1}{R} \\sum_{r=1}^R (U_r - L_r)\n    $$\n一个更优的区间应能达到接近名义 $1-\\alpha$ 水平的覆盖概率，同时具有最小的期望长度。为确保可复现性，模拟使用固定的随机种子 $20231111$ 进行。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Derives, implements, and compares Wald, Wilson score, and Agresti-Coull \n    confidence intervals for a binomial proportion via Monte Carlo simulation.\n    \"\"\"\n    # Define test cases: (n, p, alpha, R)\n    test_cases = [\n        (40, 0.10, 0.05, 100000),\n        (80, 0.50, 0.05, 100000),\n        (60, 0.90, 0.05, 100000),\n        (50, 0.02, 0.05, 100000),\n        (50, 0.98, 0.05, 100000),\n    ]\n\n    # Set random seed for reproducibility\n    seed = 20231111\n    rng = np.random.default_rng(seed)\n\n    all_results = []\n\n    for n, p_true, alpha, R in test_cases:\n        # Calculate the standard normal quantile z_{alpha/2}\n        z = norm.ppf(1 - alpha / 2)\n        z_sq = z**2\n\n        # Generate R binomial random variates\n        X = rng.binomial(n, p_true, size=R)\n        phat = X / n\n\n        # --- 1. Wald Interval ---\n        # Standard error for Wald interval\n        se_wald = np.sqrt(phat * (1 - phat) / n)\n        \n        # Calculate interval bounds\n        lower_wald = phat - z * se_wald\n        upper_wald = phat + z * se_wald\n        \n        # Truncate interval to [0, 1]\n        lower_wald = np.maximum(0, lower_wald)\n        upper_wald = np.minimum(1, upper_wald)\n        \n        # Calculate coverage and expected length\n        coverage_wald = np.mean((lower_wald = p_true)  (upper_wald = p_true))\n        length_wald = np.mean(upper_wald - lower_wald)\n        \n        # --- 2. Wilson Score Interval ---\n        center_wilson = (phat + z_sq / (2 * n)) / (1 + z_sq / n)\n        width_term_wilson = (z / (1 + z_sq / n)) * np.sqrt(phat * (1 - phat) / n + z_sq / (4 * n**2))\n        \n        lower_wilson = center_wilson - width_term_wilson\n        upper_wilson = center_wilson + width_term_wilson\n        \n        # Wilson interval is naturally within [0,1], but clipping for numerical stability\n        lower_wilson = np.maximum(0, lower_wilson)\n        upper_wilson = np.minimum(1, upper_wilson)\n\n        # Calculate coverage and expected length\n        coverage_wilson = np.mean((lower_wilson = p_true)  (upper_wilson = p_true))\n        length_wilson = np.mean(upper_wilson - lower_wilson)\n\n        # --- 3. Agresti-Coull Interval ---\n        n_tilde = n + z_sq\n        p_tilde = (X + z_sq / 2) / n_tilde\n\n        se_ac = np.sqrt(p_tilde * (1 - p_tilde) / n_tilde)\n        \n        lower_ac = p_tilde - z * se_ac\n        upper_ac = p_tilde + z * se_ac\n\n        # Truncate interval to [0, 1]\n        lower_ac = np.maximum(0, lower_ac)\n        upper_ac = np.minimum(1, upper_ac)\n        \n        # Calculate coverage and expected length\n        coverage_ac = np.mean((lower_ac = p_true)  (upper_ac = p_true))\n        length_ac = np.mean(upper_ac - lower_ac)\n\n        # Store results for the current test case\n        case_results = [\n            coverage_wald, length_wald,\n            coverage_wilson, length_wilson,\n            coverage_ac, length_ac\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists with 4-decimal rounding\n    formatted_results = []\n    for res_list in all_results:\n        # Format each number to 4 decimal places\n        formatted_list = [f\"{val:.4f}\" for val in res_list]\n        # Create the string representation of the inner list\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    # Create the final string representation of the list of lists\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "4911278"}, {"introduction": "除了常见的近似区间，还有一种更通用且功能强大的似然比（Likelihood Ratio, LR）方法。本练习将挑战你计算通常没有简单封闭解的 LR 区间。你将需要实现一个数值求根算法（牛顿-拉夫逊法）来求解偏差方程，从而获得现代统计推断中基础计算技术的实践经验。[@problem_id:4911332]", "problem": "考虑一个单次二项式抽样场景，其中在$\\;n\\;$次独立试验中观测到的“成功”次数为$\\;x\\;$，该观测值由一个成功概率为$\\;p\\in(0,1)\\;$的二项随机变量建模。目标是从第一性原理出发，不使用预封装的公式，为$\\;p\\;$计算精确的似然比置信区间和近似的威尔逊得分置信区间。\n\n推导的基本依据：\n- 二项模型：概率质量函数为$\\;P(X=x\\mid p)=\\binom{n}{x}p^x(1-p)^{n-x}\\;$，对数似然为$\\;\\ell(p)=x\\log p+(n-x)\\log(1-p)+\\text{constant}\\;$，其中加法常数不依赖于$\\;p\\;$。\n- 最大似然估计量为$\\;\\hat p=x/n\\;$。\n- 用于比较固定$\\;p\\;$与$\\;\\hat p\\;$的似然比检验统计量（也称为偏差）定义为两倍对数似然之差。单参数的威尔克斯定理表明，对于大样本，似然比统计量近似服从自由度为1的卡方分布。\n- 二项模型的得分检验基于固定$\\;p\\;$下的标准化得分，对得分检验不等式进行反演可得到威尔逊得分置信区间。\n\n您的任务：\n1. 使用二项模型和似然比统计量的定义（两倍对数似然之差），推导出一个关于$\\;p\\;$的标量非线性方程，该方程的根定义了$(1-\\alpha)$似然比置信区间的端点，即偏差等于自由度为1的卡方分布的上$(1-\\alpha)$分位数的$\\;p\\;$的集合。对此偏差方程实现一个稳健的牛顿-拉夫逊求根器来计算端点。您的求解器必须强制$\\;p\\in(0,1)\\;$，并通过分别在$\\;0\\;$或$\\;1\\;$处正确返回一个区间端点来处理边界情况$\\;x=0\\;$和$\\;x=n\\;$。\n2. 从二项得分函数及其在模型下的方差出发，反演双边得分检验不等式以获得威尔逊得分置信区间。直接根据推导出的不等式实现其计算，确保输出在单位区间内。\n3. 对每个测试用例，计算并返回以下五个值，形式为十进制浮点数，保留六位小数：最大似然估计$\\;\\hat p\\;$、似然比区间的下端点和上端点，以及威尔逊得分区间的下端点和上端点。所有概率值必须以小数形式报告（而非百分比）。\n\n测试套件：\n- 用例 A：$n=50$， $x=10$， $\\alpha=0.05$。\n- 用例 B：$n=50$， $x=0$， $\\alpha=0.05$（边界在0）。\n- 用例 C：$n=50$， $x=50$， $\\alpha=0.05$（边界在1）。\n- 用例 D：$n=50$， $x=1$， $\\alpha=0.05$（成功次数稀少的近边界情况）。\n- 用例 E：$n=200$， $x=100$， $\\alpha=0.01$（更大样本，中心比例，更严格的$\\alpha$）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是一个五元列表，顺序为$[\\hat p,\\text{LR}_{\\text{lower}},\\text{LR}_{\\text{upper}},\\text{Wilson}_{\\text{lower}},\\text{Wilson}_{\\text{upper}}]$，每个条目保留六位小数。例如，一个有效的格式是$[[0.200000,0.106000,0.324000,0.116000,0.322000],[\\dots],\\dots]$。", "solution": "用户提供的问题已经过验证，被确定为是合理的。它是一个生物统计学中根据既定的似然推断原则提出的适定问题。所有提供的信息都是完整、一致且科学有效的。该问题要求推导和实现二项比例的两种置信区间，这是该领域的标准且重要的任务。\n\n解决方案将按要求分为三部分进行开发：\n1.  似然比（LR）置信区间的推导与实现。\n2.  威尔逊得分置信区间的推导与实现。\n3.  将这些实现应用于提供的测试用例并格式化输出。\n\n### 1. 似然比（LR）置信区间\n\n给定在$n$次试验中有$x$次成功，二项比例$p$的对数似然由$\\ell(p) = x\\log(p) + (n-x)\\log(1-p)$给出，忽略不依赖于$p$的常数。最大似然估计量（MLE）是$\\hat{p} = x/n$。\n\n用于检验零假设$H_0: p=p_0$的似然比检验统计量（或称偏差）为：\n$$ D(p_0) = 2 \\left( \\ell(\\hat{p}) - \\ell(p_0) \\right) $$\n代入对数似然表达式，我们得到：\n$$ D(p_0) = 2 \\left( \\left[ x\\log(\\hat{p}) + (n-x)\\log(1-\\hat{p}) \\right] - \\left[ x\\log(p_0) + (n-x)\\log(1-p_0) \\right] \\right) $$\n$$ D(p_0) = 2 \\left( x\\log\\left(\\frac{\\hat{p}}{p_0}\\right) + (n-x)\\log\\left(\\frac{1-\\hat{p}}{1-p_0}\\right) \\right) $$\n根据威尔克斯定理，$D(p_0)$近似服从自由度为1的卡方分布，即$\\chi^2_1$。一个$(1-\\alpha)$置信区间由在$\\alpha$水平上未被检验拒绝的所有$p_0$值集合构成。这对应于满足$D(p) \\le c_\\alpha$的$p$的集合，其中$c_\\alpha = \\chi^2_{1, 1-\\alpha}$是$\\chi^2_1$分布的上$(1-\\alpha)$分位数。该区间的端点是非线性方程的根：\n$$ f(p) = 2 \\left( x\\log\\left(\\frac{\\hat{p}}{p}\\right) + (n-x)\\log\\left(\\frac{1-\\hat{p}}{1-p}\\right) \\right) - c_\\alpha = 0 $$\n为求解此方程，我们使用牛顿-拉夫逊方法，这需要$f(p)$的导数：\n$$ f'(p) = \\frac{d}{dp} D(p) = 2 \\left( -\\frac{x}{p} + \\frac{n-x}{1-p} \\right) = 2 \\frac{np-x}{p(1-p)} $$\n迭代更新规则为$p_{k+1} = p_k - f(p_k)/f'(p_k)$。一个稳健的实现需要处理数值稳定性问题，并确保解保持在$(0,1)$的有效范围内。将使用一种混合的牛顿-二分法，即当牛顿步长超出搜索边界时，则采用二分步长。\n\n**边界情况：**\n-   如果$x=0$，则$\\hat{p}=0$。对数似然$\\ell(\\hat{p}) = \\ell(0) = 0$。偏差简化为$D(p) = -2n\\log(1-p)$。区间的下界是$0$。上界通过求解$-2n\\log(1-p) = c_\\alpha$得到，即$p_U = 1 - \\exp(-c_\\alpha / (2n))$。\n-   如果$x=n$，则$\\hat{p}=1$。对数似然$\\ell(\\hat{p}) = \\ell(1) = 0$。偏差简化为$D(p) = -2n\\log(p)$。上界是$1$。下界通过求解$-2n\\log(p) = c_\\alpha$得到，即$p_L = \\exp(-c_\\alpha / (2n))$。\n\n### 2. 威尔逊得分置信区间\n\n得分函数是对数似然的一阶导数：\n$$ U(p) = \\frac{\\partial \\ell}{\\partial p} = \\frac{x-np}{p(1-p)} $$\n得分的方差是费雪信息，$I(p) = n/(p(1-p))$。标准化得分检验统计量为$Z(p) = U(p)/\\sqrt{I(p)}$，可简化为：\n$$ Z(p) = \\frac{\\hat{p}-p}{\\sqrt{p(1-p)/n}} $$\n对于大样本$n$，$Z(p)$近似服从标准正态分布。$(1-\\alpha)$置信区间是使得得分检验不被拒绝的$p$的集合，即$|Z(p)| \\le z_{\\alpha/2}$，其中$z_{\\alpha/2}$是标准正态分布的上$\\alpha/2$分位数。这等价于$Z(p)^2 \\le z_{\\alpha/2}^2$：\n$$ \\frac{(\\hat{p}-p)^2}{p(1-p)/n} \\le z_{\\alpha/2}^2 $$\n整理此不等式可得到一个关于$p$的二次方程：\n$$ \\left(1 + \\frac{z_{\\alpha/2}^2}{n}\\right)p^2 - \\left(2\\hat{p} + \\frac{z_{\\alpha/2}^2}{n}\\right)p + \\hat{p}^2 \\le 0 $$\n相应二次方程$Ap^2+Bp+C=0$的根即为区间的端点。使用二次公式，端点为：\n$$ p = \\frac{\\left(\\hat{p} + \\frac{z_{\\alpha/2}^2}{2n}\\right) \\pm z_{\\alpha/2}\\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n} + \\frac{z_{\\alpha/2}^2}{4n^2}}}{1 + \\frac{z_{\\alpha/2}^2}{n}} $$\n此公式被直接实现。\n\n### 3. 实现与最终输出\n\n以下 Python 代码实现了这些推导。创建了一个稳健的牛顿-拉夫逊求解器来查找一般情况下的 LR 区间根，而边界情况则使用特定公式。威尔逊区间使用其闭式解计算。每个测试用例的结果被收集并按要求格式化为单个字符串。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2, norm\n\ndef _robust_newton_solver(f, f_prime, bounds, tol=1e-9, max_iter=100):\n    \"\"\"\n    A robust Newton-Raphson solver that falls back to bisection if a\n    step goes out of the specified bounds. This is suitable for finding\n    the roots of the well-behaved deviance function.\n    \"\"\"\n    low, high = bounds\n    p = (low + high) / 2.0  # Start with a bisection step\n\n    f_low = f(low)\n    \n    for _ in range(max_iter):\n        fp = f(p)\n        if abs(high - low)  tol or abs(fp)  tol:\n            return p\n\n        # Update bracket for bisection fallback\n        if f_low * fp  0:\n            high = p\n        else:\n            low = p\n            f_low = fp\n\n        f_prime_p = f_prime(p)\n        if abs(f_prime_p)  1e-12: # Avoid division by zero\n            p_next = (low + high) / 2.0\n        else:\n            p_next = p - fp / f_prime_p\n\n        # If Newton step is out of bounds, fall back to bisection\n        if not (low = p_next = high):\n            p_next = (low + high) / 2.0\n        \n        p = p_next\n\n    return p\n\ndef get_lr_interval(n, x, alpha):\n    \"\"\"\n    Computes the Likelihood Ratio (LR) confidence interval for a binomial proportion.\n    \"\"\"\n    p_hat = x / n\n    crit_val = chi2.ppf(1 - alpha, df=1)\n\n    # Handle boundary cases with derived closed-form solutions\n    if x == 0:\n        lower = 0.0\n        upper = 1 - np.exp(-crit_val / (2 * n))\n        return lower, upper\n\n    if x == n:\n        lower = np.exp(-crit_val / (2 * n))\n        upper = 1.0\n        return lower, upper\n    \n    # Deviance function to find roots for: D(p) - crit_val = 0\n    def f(p):\n        if p = 0 or p = 1:\n            return np.inf\n        term1 = x * np.log(p_hat / p)\n        term2 = (n - x) * np.log((1 - p_hat) / (1 - p))\n        return 2 * (term1 + term2) - crit_val\n\n    # Derivative of the deviance function\n    def f_prime(p):\n        if p = 0 or p = 1:\n            return np.inf\n        return 2 * (n * p - x) / (p * (1 - p))\n\n    # Find lower root\n    lower_bound_search = (1e-12, p_hat)\n    lower = _robust_newton_solver(f, f_prime, lower_bound_search)\n    \n    # Find upper root\n    upper_bound_search = (p_hat, 1 - 1e-12)\n    upper = _robust_newton_solver(f, f_prime, upper_bound_search)\n\n    return lower, upper\n\ndef get_wilson_interval(n, x, alpha):\n    \"\"\"\n    Computes the Wilson score confidence interval for a binomial proportion.\n    \"\"\"\n    p_hat = x / n\n    z = norm.ppf(1 - alpha / 2)\n    z_sq = z**2\n    \n    denominator = 1 + z_sq / n\n    center_adj = p_hat + z_sq / (2 * n)\n    spread = z * np.sqrt((p_hat * (1 - p_hat) / n) + (z_sq / (4 * n**2)))\n    \n    lower = (center_adj - spread) / denominator\n    upper = (center_adj + spread) / denominator\n    \n    return lower, upper\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and generate the final output.\n    \"\"\"\n    test_cases = [\n        (50, 10, 0.05), # Case A\n        (50, 0, 0.05),  # Case B\n        (50, 50, 0.05), # Case C\n        (50, 1, 0.05),  # Case D\n        (200, 100, 0.01),# Case E\n    ]\n\n    all_results = []\n    for n, x, alpha in test_cases:\n        p_hat = x / n\n        \n        lr_lower, lr_upper = get_lr_interval(n, x, alpha)\n        wilson_lower, wilson_upper = get_wilson_interval(n, x, alpha)\n        \n        case_results = [\n            p_hat, \n            lr_lower, \n            lr_upper, \n            wilson_lower, \n            wilson_upper\n        ]\n        all_results.append(case_results)\n\n    # Format the output string exactly as specified.\n    result_strings = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places.\n        res_list_str = [f\"{v:.6f}\" for v in res_list]\n        result_strings.append(f\"[{','.join(res_list_str)}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "4911332"}, {"introduction": "尽管近似方法很实用，但频率派推断中的“黄金标准”是“精确”区间，它能保证覆盖率不低于名义水平。本练习将带你回到第一性原理，推导著名的 Clopper-Pearson 区间。通过分析观测到零次成功这一特殊情况，你将对如何通过反演精确二项检验来构建这些区间获得深刻、基础的理解。[@problem_id:4911376]", "problem": "一项临床检测通过进行$n$次独立试验来验证，每次试验产生一个指示生物标志物存在与否的二元结果。设$X$表示在参数为$p$的二项分布模型下生物标志物阳性结果的数量，因此$X \\sim \\mathrm{Binomial}(n,p)$。考虑通过反演相应的精确二项检验来构建$p$在显著性水平$\\alpha$下的双侧等尾Clopper–Pearson (CP)置信区间。具体来说，将上限$p_{U}$定义为$p$的值，使得$H_{0}: p=p_{U}$对$H_{1}: p  p_{U}$的检验的p值等于$\\alpha/2$。\n\n您的任务是针对特殊情况$X=0$来解决$p_{U}$。在这种情况下，p值简化为$\\Pr_{p=p_{U}}(X \\le 0) = \\Pr_{p=p_{U}}(X=0)$。使用二项概率质量函数，建立关于$p_U$的方程，并求解它。最终答案应表示为$n$和$\\alpha$的函数。", "solution": "我们从二项分布模型$X \\sim \\mathrm{Binomial}(n,p)$开始，其概率质量函数为\n$$\n\\Pr_{p}(X=k)=\\binom{n}{k} p^{k} (1-p)^{n-k}, \\quad k \\in \\{0,1,\\dots,n\\}.\n$$\n双侧等尾Clopper–Pearson (Clopper–Pearson)区间是通过反演精确二项检验得到的。根据反演原理，对于观测到的计数$x$，上端点$p_{U}$定义为满足单侧下尾条件\n$$\n\\Pr_{p}(X \\le x)=\\frac{\\alpha}{2},\n$$\n的$p$的解，因为这是$H_{0}: p=p_{U}$对$H_{1}: p  p_{U}$的检验的p值。\n\n在观测到零次成功（$x=0$）的特殊情况下，这个条件变为\n$$\n\\Pr_{p_{U}}(X \\le 0)=\\frac{\\alpha}{2}.\n$$\n因为在二项分布中不可能有负成功次数，所以$\\Pr(X \\le 0)$等于$\\Pr(X=0)$。因此，我们必须求解方程\n$$\n\\Pr_{p_{U}}(X=0)=\\frac{\\alpha}{2}.\n$$\n将二项概率质量函数代入$k=0$，我们得到\n$$\n\\binom{n}{0} p_{U}^{0} (1-p_{U})^{n-0} = 1 \\cdot 1 \\cdot (1-p_{U})^{n} = (1-p_{U})^{n}.\n$$\n因此，我们要求解的方程是\n$$\n(1-p_{U})^{n} = \\frac{\\alpha}{2}.\n$$\n为了求解$p_U$，我们取两边的$n$次方根：\n$$\n1-p_{U} = \\left(\\frac{\\alpha}{2}\\right)^{1/n}.\n$$\n最后，整理得到$p_U$：\n$$\np_{U} = 1-\\left(\\frac{\\alpha}{2}\\right)^{1/n}.\n$$\n这是在观测到零次成功时，Clopper–Pearson区间的上界。", "answer": "$$\\boxed{1-\\left(\\frac{\\alpha}{2}\\right)^{1/n}}$$", "id": "4911376"}]}