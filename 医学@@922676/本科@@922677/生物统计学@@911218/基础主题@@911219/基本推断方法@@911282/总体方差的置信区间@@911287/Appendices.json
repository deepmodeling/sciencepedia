{"hands_on_practices": [{"introduction": "本练习将方差置信区间的基本概念扩展到线性回归这一常见且实用的场景中。它演示了如何量化模型误差项（$\\sigma^2$）的不确定性，这对于评估模型拟合度和预测可靠性至关重要。通过利用残差平方和（$\\text{RSS}$），本练习将巩固您对卡方分布在方差估计中应用的理解 [@problem_id:4903186]。", "problem": "一个生物医学工程团队正在校准一种新传感器，该传感器使用线性模型根据测量的协变量来估计一个连续的生物标志物。他们对 $n=40$ 个独立观测值拟合了一个具有 $p=5$ 个未知系数（包括截距）的正态线性回归模型，其中误差项代表传感器的测量噪声。报告的残差平方和为 $\\text{RSS}=78$，单位为该生物标志物的平方单位。假设为经典正态线性模型，其误差是均值为 $0$、方差为 $\\sigma^{2}$ 的独立同分布高斯误差。\n\n从正态线性模型下残差平方和的基本分布性质出发，为误差方差 $\\sigma^{2}$ 构建一个双侧 $95\\%$ 置信区间，然后使用适当的分位数计算其数值端点。最后，解释此区间，说明其描述了底层数据生成过程中传感器测量误差方差的合理值范围。\n\n将您的区间端点四舍五入至三位有效数字，并以生物标志物响应变量的平方单位表示。", "solution": "该问题提法恰当且科学合理，基于正态线性模型统计推断的基本原理。我们可以着手求解。\n\n该问题要求为正态线性回归模型的误差方差 $\\sigma^2$ 构建一个双侧 $95\\%$ 置信区间。该模型拟合了 $n=40$ 个独立观测值，并有 $p=5$ 个未知系数。给定的残差平方和为 $\\text{RSS}=78$。\n\n这个问题的理论基础是线性模型理论中的一个关键结果。对于一个经典的正态线性模型 $Y = X\\beta + \\epsilon$，其中误差 $\\epsilon_i$ 是独立同分布的 $\\mathcal{N}(0, \\sigma^2)$，量 $\\frac{\\text{RSS}}{\\sigma^2}$ 服从卡方分布。该分布的自由度为 $df = n - p$，其中 $n$ 是观测值的数量，$p$ 是估计的回归系数的数量（包括截距）。\n\n首先，我们确定给定的参数：\n- 观测值数量，$n = 40$。\n- 回归系数数量，$p = 5$。\n- 残差平方和，$\\text{RSS} = 78$。\n- 置信水平为 $95\\%$，对应的显著性水平为 $\\alpha = 1 - 0.95 = 0.05$。\n\n卡方分布的自由度计算如下：\n$$ df = n - p = 40 - 5 = 35 $$\n因此，枢轴量 $\\frac{\\text{RSS}}{\\sigma^2}$ 服从自由度为 $35$ 的卡方分布：\n$$ \\frac{\\text{RSS}}{\\sigma^2} \\sim \\chi^2_{35} $$\n为了构建 $\\sigma^2$ 的一个双侧 $100(1-\\alpha)\\%$ 置信区间，我们找到 $\\chi^2_{35}$ 分布的两个分位数 $\\chi^2_{1-\\alpha/2, df}$ 和 $\\chi^2_{\\alpha/2, df}$，使得：\n$$ P\\left( \\chi^2_{\\alpha/2, df}  \\frac{\\text{RSS}}{\\sigma^2}  \\chi^2_{1-\\alpha/2, df} \\right) = 1 - \\alpha $$\n这里，$\\chi^2_{q, df}$ 表示在其左侧的 $\\chi^2_{df}$ 概率密度函数下的面积为 $q$ 的值。\n\n当 $\\alpha = 0.05$ 时，我们需要对应于尾部概率 $\\alpha/2 = 0.025$ 和 $1 - \\alpha/2 = 0.975$ 的分位数。\n下临界值为 $\\chi^2_{0.025, 35}$。\n上临界值为 $\\chi^2_{0.975, 35}$。\n\n使用统计表或软件查询自由度为 $df=35$ 的 $\\chi^2$ 分布：\n- 下临界值为 $\\chi^2_{0.025, 35} \\approx 20.569$。\n- 上临界值为 $\\chi^2_{0.975, 35} \\approx 53.203$。\n\n现在，我们重排概率表达式中的不等式以分离出 $\\sigma^2$：\n$$ \\chi^2_{0.025, 35}  \\frac{\\text{RSS}}{\\sigma^2}  \\chi^2_{0.975, 35} $$\n取倒数并乘以 $\\text{RSS}$，我们得到 $\\sigma^2$ 的 $95\\%$ 置信区间：\n$$ \\left( \\frac{\\text{RSS}}{\\chi^2_{0.975, 35}}, \\frac{\\text{RSS}}{\\chi^2_{0.025, 35}} \\right) $$\n代入数值：\n- 下界：$\\frac{78}{53.203} \\approx 1.46608$\n- 上界：$\\frac{78}{20.569} \\approx 3.79211$\n\n题目要求将区间端点四舍五入至三位有效数字。\n- 下界四舍五入至三位有效数字为 $1.47$。\n- 上界四舍五入至三位有效数字为 $3.79$。\n\n因此，误差方差 $\\sigma^2$ 的 $95\\%$ 置信区间为 $(1.47, 3.79)$，单位为该生物标志物的平方单位。\n\n最后，我们解释这个区间。我们有 $95\\%$ 的信心认为，传感器测量误差的真实未知方差 $\\sigma^2$ 位于 $1.47$ 和 $3.79$ 生物标志物平方单位之间。该区间为与实验观测数据一致的总体误差方差提供了一个合理值的范围。它量化了我们对传感器精度估计的不确定性。", "answer": "$$\n\\boxed{\\begin{pmatrix} 1.47  3.79 \\end{pmatrix}}\n$$", "id": "4903186"}, {"introduction": "经典的方差置信区间对正态性假设高度敏感。本练习通过一个思想实验探讨了当数据呈现出比正态分布更“重”的尾部时会发生什么，并比较了两种自助法（bootstrap）策略。通过这个问题，您将深入了解统计方法的稳健性，并理解为何在分布假设存疑时，非参数化自助法是一个强大的替代方案 [@problem_id:4903185]。", "problem": "一个生物统计学团队研究了一种在 $n=60$ 名独立患者身上测量的生物标志物。观察到的直方图大致对称，样本偏度约等于 $0$，样本超额峰度 $g_2$ 约等于 $1.0$，这表明相对于高斯基线，数据呈现轻微的重尾分布。目标是为总体方差 $\\sigma^2$ 构建一个 $95\\%$ 的置信区间。正在考虑两种自助法（bootstrap）策略：(i) 参数自助法，它假设数据服从高斯分布，并从一个使用样本估计参数的正态模型中进行重抽样；(ii) 非参数自助法，它从观测数据中进行有放回的重抽样。\n\n根据方差定义、有限四阶矩以及抽样分布和自助法程序行为的基本原理，在这些轻微重尾的条件下，哪个陈述最能描述这两种为 $\\sigma^2$ 构建的自助法区间的预期表现？\n\nA. 在轻微重尾的情况下，为 $\\sigma^2$ 构建的参数自助法区间倾向于过窄，对真实 $\\sigma^2$ 的覆盖不足（尤其是在上侧），而非参数自助法区间则倾向于更宽，且更接近名义 $95\\%$ 的覆盖率。\n\nB. 在轻微重尾的情况下，由于中心极限定理平滑了尾部，为 $\\sigma^2$ 构建的参数自助法区间倾向于更宽，对真实 $\\sigma^2$ 的覆盖过度，而非参数自助法区间则倾向于过窄和覆盖不足。\n\nC. 对于中等大小的 $n$，无论尾部行为如何，为 $\\sigma^2$ 构建的参数和非参数自助法区间都将具有基本相同的宽度和接近精确的名义 $95\\%$ 覆盖率，因为自助法保证了名义覆盖率。\n\nD. 非参数自助法对估计方差无效，并且会通过有放回的重抽样破坏数据结构，从而严重高估 $\\sigma^2$，因此即使在轻微重尾的条件下，参数自助法也更可取。", "solution": "此问题旨在比较在数据呈现重尾分布（非正态）时，参数自助法和非参数自助法在构建方差置信区间时的表现。\n\n**核心原理分析**\n\n1.  **样本方差的抽样分布**：样本方差 $S^2$ 本身是一个随机变量，其抽样分布的方差（即 $S^2$ 的不稳定性）与总体分布的峰度（kurtosis）密切相关。对于一个具有有限四阶矩的分布，样本方差 $S^2$ 的方差近似为：\n    $$\n    \\text{Var}(S^2) \\approx \\frac{\\sigma^4}{n} (\\kappa - 1)\n    $$\n    其中，$n$ 是样本量，$\\sigma^4$ 是总体方差的平方，$\\kappa$ 是总体的峰度。超额峰度 $\\gamma_2 = \\kappa - 3$。\n\n2.  **重尾分布的影响**：问题中给出样本超额峰度 $g_2 \\approx 1.0$，这意味着总体超额峰度 $\\gamma_2$ 可能为正。因此，总体的峰度 $\\kappa = \\gamma_2 + 3 \\approx 4.0$。这高于正态分布的峰度 $\\kappa_{\\text{normal}} = 3$。根据上述公式，这意味着 $S^2$ 的**真实**抽样分布比在正态假设下预期的要更分散（方差更大）。\n\n**两种自助法策略的评估**\n\n*   **(i) 参数自助法 (Parametric Bootstrap)**：此方法假设数据来自正态分布。它会从一个参数由样本估计出的正态分布 $\\mathcal{N}(\\bar{x}, s^2)$ 中生成自助样本。因此，它生成的 $S^2$ 的自助分布将反映正态总体的性质，其方差与 $\\kappa=3$ 相对应。由于这个假设的分布比真实的重尾分布更“窄”（变异性更小），所以基于这种方法的置信区间会**过窄**。一个过窄的区间将无法以预期的 $95\\%$ 的频率捕获真实的总体方差 $\\sigma^2$，从而导致**覆盖不足**（under-coverage）。\n\n*   **(ii) 非参数自助法 (Non-parametric Bootstrap)**：此方法直接从原始样本数据中有放回地重抽样。这个过程忠实地保留了原始数据的所有特征，包括其重尾特性（即更高的峰度）。因此，它生成的 $S^2$ 的自助分布将能正确地反映出 $S^2$ 真实抽样分布的更大变异性。这将产生一个**更宽**的置信区间，这个区间能更准确地量化不确定性，其经验覆盖率将更接近名义的 $95\\%$ 水平。\n\n**选项分析**\n\n*   **A**: 描述了参数自助法区间过窄、覆盖不足，而非参数自助法区间更宽、覆盖率更接近名义值。这与我们的分析完全一致。\n*   **B**: 逻辑完全相反，且错误地引用中心极限定理（中心极限定理适用于均值，不直接适用于方差的抽样分布）。\n*   **C**: 声称两种方法表现相同且覆盖率精确，这在非正态数据下是错误的。\n*   **D**: 错误地声称非参数自助法无效。实际上，非参数自助法正是为了应对此类分布假设不满足的情况而设计的强大工具。\n\n因此，选项A是唯一正确的描述。", "answer": "$$\\boxed{A}$$", "id": "4903185"}, {"introduction": "除了正态性，观测独立性是许多标准统计方法的另一个基石假设。这个基于模拟的练习揭示了当我们将标准方差置信区间应用于聚类（相关）数据时，会发生严重的覆盖率不足问题 [@problem_id:4903180]。它引入了聚类自助法作为一种稳健的、基于设计的方法，该方法能正确处理数据中的依赖结构，这在生物统计学和其他领域都是一个常见的挑战。", "problem": "您需要编写一个完整且可运行的程序，使用蒙特卡洛模拟来比较在聚类（组内相关）抽样下，两种不同的人口方差置信区间构造方法的经验覆盖率。这两种方法是：(i) 基于独立性的置信区间，通过在独立同分布正态数据下，反演样本方差的已知抽样分布得到；(ii) 基于设计的置信区间，通过聚类自助法重抽样构建。您的任务是量化在组内相关性显著时，覆盖不足的风险。\n\n从以下基本原理出发：\n- 在独立同分布正态抽样下，样本方差的抽样分布具有一个确切的形式，可以进行区间反演。\n- 在多阶段或聚类抽样下，初级抽样单元（PSU）可用于基于设计的重抽样，这种方法能保留聚类内部的依赖结构。\n- 在一个两水平高斯随机效应模型中，组内相关性可以通过将一个共享的聚类水平效应添加到独立的聚类内误差中来生成。\n\n每个数据集的数据生成机制如下。对于给定的聚类数 $C$ 和聚类大小 $m$，从以下模型生成观测值 $\\{Y_{ij} : i = 1,\\dots,C,\\ j = 1,\\dots,m\\}$：\n$$\nY_{ij} \\;=\\; \\mu \\;+\\; U_i \\;+\\; \\varepsilon_{ij},\n$$\n其中 $U_i \\sim \\mathcal{N}(0,\\sigma_b^2)$，$\\varepsilon_{ij} \\sim \\mathcal{N}(0,\\sigma_w^2)$，所有变量相互独立，总边际方差为 $\\sigma^2 = \\sigma_b^2 + \\sigma_w^2$，组内相关系数为 $\\rho = \\sigma_b^2/\\sigma^2$。不失一般性地，设 $\\mu = 0$。对于每个模拟的数据集，计算通常的无偏样本方差\n$$\nS^2 \\;=\\; \\frac{1}{n-1}\\sum_{i=1}^C \\sum_{j=1}^m \\big(Y_{ij} - \\overline{Y}\\big)^2, \\quad \\text{其中 } n = C m \\text{ 且 } \\overline{Y} \\text{ 是总样本均值。}\n$$\n\n对于每个数据集，为人口方差 $\\sigma^2$ 构建两个名义水平为 $1-\\alpha$ 的双侧置信区间：\n1. 基于独立性的区间：在独立同分布正态观测值的假设下（将 $n$ 个观测值视为独立的），反演 $S^2$ 的确切抽样分布。\n2. 基于设计的区间：执行聚类自助法重抽样，通过有放回地重抽样 $C$ 个聚类，并保持任何被重抽样聚类中的所有 $m$ 个观测值不变。对于每个自助法重抽样样本，从合并的重抽样观测值中重新计算 $S^2$。使用 $S^2$ 的自助法经验分布的百分位数法来形成一个双侧置信区间。\n\n将一种方法的经验覆盖率定义为：在所有模拟的数据集中，其置信区间包含真实 $\\sigma^2$ 的比例。将覆盖不足风险定义为名义覆盖率与经验覆盖率之间的非负差值：\n$$\n\\text{覆盖不足} \\;=\\; \\max\\{(1-\\alpha) - \\widehat{\\text{覆盖率}},\\ 0\\}。\n$$\n\n使用以下参数值测试套件，该套件涵盖了显著的组内相关性和一个边界条件：\n- 案例A：$C = 20$, $m = 10$, $\\sigma^2 = 1.0$, $\\rho = 0.3$。\n- 案例B：$C = 8$, $m = 20$, $\\sigma^2 = 1.5$, $\\rho = 0.6$。\n- 案例C：$C = 50$, $m = 5$, $\\sigma^2 = 2.0$, $\\rho = 0.4$。\n- 案例D（边界条件，无聚类）：$C = 20$, $m = 10$, $\\sigma^2 = 1.0$, $\\rho = 0.0$。\n\n为所有案例实施以下模拟设置：\n- 名义水平：$\\alpha = 0.05$。\n- 每个案例的蒙特卡洛重复次数：$R = 400$。\n- 基于设计的方法中每个数据集的自助法重抽样次数：$B = 200$。\n- 随机种子：设置为 $12345$ 以保证可复现性。\n\n您的程序必须：\n- 对于每个案例，使用指定的 $C$、$m$、$\\sigma^2$ 和 $\\rho$，根据上述模型生成 $R$ 个数据集。\n- 对于每个数据集，计算两个置信区间，并记录真实的 $\\sigma^2$ 是否落在每个区间内。\n- 对于每个案例，按以下顺序报告四个量：基于设计的区间的经验覆盖率、基于独立性的区间的经验覆盖率、基于设计的区间的覆盖不足风险、基于独立性的区间的覆盖不足风险。每个量都必须表示为浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个长度为 4 的列表，每个元素是对应一个案例（按A、B、C、D的顺序）的四个浮点数列表。例如：\n$[\\,[\\text{cov\\_design\\_A},\\text{cov\\_indep\\_A},\\text{under\\_design\\_A},\\text{under\\_indep\\_A}],\\dots]$。\n- 将报告的每个浮点数四舍五入到三位小数。", "solution": "所述问题是有效的。它在统计理论上具有科学依据，问题阐述清晰，提供了所有必要的参数和定义，并以客观、正式的方式呈现。它提出了在旨在凸显两种标准统计方法不同理论基础的条件下，对它们进行非平凡的比较。因此，我们可以着手提供一个解决方案。\n\n目标是进行一次蒙特卡洛模拟，以评估和比较两种不同的人口方差 $\\sigma^2$ 置信区间估计量的经验覆盖属性。此比较在聚类数据条件下进行，这种情况会引入组内相关性，而组内相关性是已知会违反经典统计方法假设的一个特征。这两种估计量是：($i$) 一个基于卡方分布的参数区间，它假设数据是独立同分布（IID）的正态数据；以及 ($ii$) 一个非参数的、基于设计的区间，该区间使用考虑了数据依赖结构的聚类自助法程序构建。\n\n**数据生成过程**\n\n对于每次模拟，我们生成一个包含 $n=Cm$ 个观测值的数据集，这些观测值被组织成 $C$ 个大小为 $m$ 的聚类。数据由一个两水平高斯随机效应模型生成：\n$$\nY_{ij} = \\mu + U_i + \\varepsilon_{ij}\n$$\n对于聚类 $i \\in \\{1, \\dots, C\\}$ 和观测值 $j \\in \\{1, \\dots, m\\}$。参数定义如下：\n- $\\mu$：总体均值，由于样本方差具有位置不变性，不失一般性地可以将其设为 $0$。\n- $U_i$：一个聚类特定的随机效应，从正态分布 $U_i \\sim \\mathcal{N}(0, \\sigma_b^2)$ 中抽取。这些效应在不同聚类间是独立的。\n- $\\varepsilon_{ij}$：一个个体水平的随机误差，从正态分布 $\\varepsilon_{ij} \\sim \\mathcal{N}(0, \\sigma_w^2)$ 中抽取。这些误差相互独立，并且独立于 $U_i$。\n\n任何观测值 $Y_{ij}$ 的总边际方差是目标参数 $\\sigma^2$，由方差分量的和给出：$\\sigma^2 = \\sigma_b^2 + \\sigma_w^2$。\n组内相关系数（ICC），$\\rho$，衡量同一聚类内两个不同观测值之间的相关性。其定义为：\n$$\n\\rho = \\text{Corr}(Y_{ij}, Y_{ik}) = \\frac{\\text{Cov}(U_i+\\varepsilon_{ij}, U_i+\\varepsilon_{ik})}{\\sigma^2} = \\frac{\\text{Var}(U_i)}{\\sigma^2} = \\frac{\\sigma_b^2}{\\sigma^2} \\quad \\text{对于 } j \\neq k.\n$$\n给定模拟参数 $\\sigma^2$ 和 $\\rho$，方差分量由 $\\sigma_b^2 = \\rho \\sigma^2$ 和 $\\sigma_w^2 = (1-\\rho)\\sigma^2$ 确定。\n\n对于每个生成的数据集，无偏样本方差计算如下：\n$$\nS^2 = \\frac{1}{n-1} \\sum_{i=1}^C \\sum_{j=1}^m \\left(Y_{ij} - \\overline{Y}\\right)^2\n$$\n其中 $n=Cm$ 是观测总数，$\\overline{Y} = \\frac{1}{n}\\sum_{i=1}^C \\sum_{j=1}^m Y_{ij}$ 是总样本均值。\n\n**置信区间方法论**\n\n我们在名义置信水平 $1-\\alpha$ 下，为 $\\sigma^2$ 构建两种类型的双侧置信区间。\n\n1.  **基于独立性（卡方）的区间：**\n    该方法错误地假设 $n=Cm$ 个观测值是从 $\\mathcal{N}(\\mu, \\sigma^2)$ 分布中抽取的独立同分布样本。在此假设下，枢轴量 $\\frac{(n-1)S^2}{\\sigma^2}$ 服从自由度为 $n-1$ 的卡方分布，记为 $\\chi^2_{n-1}$。\n    通过反演概率陈述 $P\\left(\\chi^2_{n-1, \\alpha/2} \\le \\frac{(n-1)S^2}{\\sigma^2} \\le \\chi^2_{n-1, 1-\\alpha/2}\\right) = 1-\\alpha$，其中 $\\chi^2_{df, q}$ 是 $\\chi^2_{df}$ 分布的第 $q$ 个分位数，我们得到 $\\sigma^2$ 的 $(1-\\alpha)$ 置信区间：\n    $$\n    CI_{\\text{indep}} = \\left[ \\frac{(n-1)S^2}{\\chi^2_{n-1, 1-\\alpha/2}}, \\frac{(n-1)S^2}{\\chi^2_{n-1, \\alpha/2}} \\right]\n    $$\n    当 $\\rho > 0$ 时，独立同分布的假设被违反，预计该区间将表现出较差的覆盖性能，通常会低于真实的 $\\sigma^2$，因为数据所包含的信息量少于 $n$ 个独立观测值所能提供的信息量。\n\n2.  **基于设计（聚类自助法）的区间：**\n    此方法旨在对聚类内的依赖结构具有稳健性。它将聚类（初级抽样单元，或PSU）视为重抽样的观测单位。步骤如下：\n    a.  从原始的 $C$ 个聚类集合 $\\{ (Y_{11}, \\dots, Y_{1m}), \\dots, (Y_{C1}, \\dots, Y_{Cm}) \\}$ 中，有放回地抽取一个包含 $C$ 个聚类的样本。\n    b.  将这些重抽样聚类中的观测值合并，形成一个自助法数据集。\n    c.  从此自助法数据集中计算样本方差 $S^2_*$。\n    d.  重复步骤 a-c 共 $B$ 次，以获得自助法方差估计的集合 $\\{S^2_{*b}\\}_{b=1}^B$。\n    e.  $(1-\\alpha)$ 百分位数自助法置信区间由自助法分布的经验 $\\alpha/2$ 和 $1-\\alpha/2$ 分位数构成：\n    $$\n    CI_{\\text{design}} = \\left[ Q_{\\alpha/2}(S^2_{*}), Q_{1-\\alpha/2}(S^2_{*}) \\right]\n    $$\n    预计此方法提供的覆盖率会更接近名义水平 $1-\\alpha$，因为其重抽样方案保留了原始数据生成过程的相关性结构。\n\n**模拟执行与分析**\n\n将对四个指定案例（A, B, C, D）中的每一个案例运行模拟，使用 $R=400$ 次蒙特卡洛重复。对于每次重复，构建两种置信区间并检验其是否覆盖真实的 $\\sigma^2$。一种方法的经验覆盖率是 $R$ 个区间中包含 $\\sigma^2$ 的比例。覆盖不足风险计算为 $\\max\\{(1-\\alpha) - \\widehat{\\text{coverage}}, 0\\}$。对于指定的 $\\alpha=0.05$，名义覆盖率为 $0.95$。为保证可复现性，随机种子固定为 $12345$。最后，报告所有四个案例中两种方法的结果——经验覆盖率和覆盖不足风险，并四舍五入到三位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef run_simulation_case(C, m, sigma2, rho, alpha, R, B, rng):\n    \"\"\"\n    Runs a Monte Carlo simulation for a single parameter case.\n\n    Args:\n        C (int): Number of clusters.\n        m (int): Size of each cluster.\n        sigma2 (float): True population variance.\n        rho (float): Intracluster correlation.\n        alpha (float): Significance level for confidence intervals.\n        R (int): Number of Monte Carlo replicates.\n        B (int): Number of bootstrap resamples.\n        rng (np.random.Generator): A NumPy random number generator instance.\n\n    Returns:\n        tuple: A tuple containing four floats:\n               (empirical_coverage_design, empirical_coverage_indep,\n                undercoverage_risk_design, undercoverage_risk_indep).\n    \"\"\"\n    n = C * m\n    df = n - 1\n    nominal_coverage = 1.0 - alpha\n\n    # Derived variance components\n    sigma_b2 = rho * sigma2\n    sigma_w2 = (1.0 - rho) * sigma2\n    sigma_b = np.sqrt(sigma_b2) if sigma_b2 > 0 else 0\n    sigma_w = np.sqrt(sigma_w2) if sigma_w2 > 0 else 0\n\n    # Chi-squared quantiles for the independence-based interval\n    # These are constant for a given case\n    chi2_q_upper = chi2.ppf(1 - alpha / 2, df)\n    chi2_q_lower = chi2.ppf(alpha / 2, df)\n\n    coverage_indep_count = 0\n    coverage_design_count = 0\n\n    for _ in range(R):\n        # 1. Generate data from the random effects model\n        # Cluster effects U_i ~ N(0, sigma_b^2)\n        U = rng.normal(loc=0.0, scale=sigma_b, size=C)\n        # Individual errors e_ij ~ N(0, sigma_w^2)\n        epsilon = rng.normal(loc=0.0, scale=sigma_w, size=(C, m))\n        # Form observations Y_ij = U_i + e_ij\n        Y = U[:, np.newaxis] + epsilon\n\n        # 2. Compute the overall sample variance S^2\n        y_flat = Y.flatten()\n        S2 = np.var(y_flat, ddof=1)\n\n        # 3. Construct and check independence-based CI\n        ci_indep_low = (df * S2) / chi2_q_upper\n        ci_indep_high = (df * S2) / chi2_q_lower\n        if ci_indep_low = sigma2 = ci_indep_high:\n            coverage_indep_count += 1\n\n        # 4. Construct and check design-based (cluster bootstrap) CI\n        bootstrap_S2_values = []\n        for _ in range(B):\n            # Resample clusters with replacement\n            cluster_indices = rng.choice(C, size=C, replace=True)\n            Y_bootstrap = Y[cluster_indices, :]\n            \n            # Compute variance for the bootstrap sample\n            S2_bootstrap = np.var(Y_bootstrap.flatten(), ddof=1)\n            bootstrap_S2_values.append(S2_bootstrap)\n        \n        # Percentile method\n        ci_design_low = np.percentile(bootstrap_S2_values, 100 * (alpha / 2))\n        ci_design_high = np.percentile(bootstrap_S2_values, 100 * (1 - alpha / 2))\n        \n        if ci_design_low = sigma2 = ci_design_high:\n            coverage_design_count += 1\n            \n    # 5. Calculate empirical coverages\n    emp_cov_design = coverage_design_count / R\n    emp_cov_indep = coverage_indep_count / R\n\n    # 6. Calculate undercoverage risks\n    under_risk_design = max(nominal_coverage - emp_cov_design, 0)\n    under_risk_indep = max(nominal_coverage - emp_cov_indep, 0)\n\n    # 7. Round results to three decimal places\n    return (\n        round(emp_cov_design, 3),\n        round(emp_cov_indep, 3),\n        round(under_risk_design, 3),\n        round(under_risk_indep, 3)\n    )\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Define problem parameters\n    alpha = 0.05\n    R = 400\n    B = 200\n    seed = 12345\n\n    # Initialize the random number generator\n    rng = np.random.default_rng(seed)\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case A\n        {'C': 20, 'm': 10, 'sigma2': 1.0, 'rho': 0.3},\n        # Case B\n        {'C': 8, 'm': 20, 'sigma2': 1.5, 'rho': 0.6},\n        # Case C\n        {'C': 50, 'm': 5, 'sigma2': 2.0, 'rho': 0.4},\n        # Case D (boundary, no clustering)\n        {'C': 20, 'm': 10, 'sigma2': 1.0, 'rho': 0.0},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = run_simulation_case(\n            case['C'], case['m'], case['sigma2'], case['rho'],\n            alpha, R, B, rng\n        )\n        all_results.append(list(case_results))\n\n    # Format the output as specified\n    print(all_results)\n\nsolve()\n```", "id": "4903180"}]}