{"hands_on_practices": [{"introduction": "要真正掌握一种统计方法，最好的方式之一就是从其基本原理出发，亲手构建它。这个练习将指导你完成这一过程，不依赖任何现成的统计软件函数，从原始数据开始，一步步计算单因素方差分析（ANOVA）表中的所有核心要素：组均值、平方和、均方以及最终的 $F$ 统计量。通过这个实践[@problem_id:4965592]，你将深刻理解总变异是如何被分解为有意义的组间和组内部分的。", "problem": "您需要编写一个完整的程序，根据方差分解的基本原理，从原始数据构建单因素方差分析（ANOVA）表，然后仅报告为每个提供的数据集计算出的 $F$ 统计量。您的实现不得调用任何内置的 ANOVA 程序；它必须根据平均值和离差平方和的核心定义来计算所有量值。请从以下基本基础开始：样本均值和离差平方和的定义，总变异可加性地分解为组内和组间分量的恒等式，以及单因素 ANOVA 模型的独立性和方差齐性假设（在该模型下，$F$ 统计量服从 $F$ 分布）。具体来说，仅使用以下原则作为出发点：\n- 对于任何有限的实值观测数据集 $\\{y\\}$，样本均值为 $\\bar{y} = \\frac{1}{n}\\sum_{j=1}^{n} y_{j}$，总离差平方和为 $\\sum_{j=1}^{n} (y_{j} - \\bar{y})^{2}$。\n- 在具有 $k$ 个组和组大小为 $n_{i}$ 的单因素分组中，总平方和可分解为 $SS_{T} = SS_{W} + SS_{B}$，其中 $SS_{W}$ 是根据与组均值的偏差计算的组内平方和，$SS_{B}$ 是根据组均值与总均值的偏差（按组大小加权）计算的组间平方和。\n- 在误差独立、呈正态分布且各组方差相等的单因素 ANOVA 模型下，根据所有组均值相等的原假设，均方比 $F = MS_{B}/MS_{W}$ 服从分子自由度为 $k-1$、分母自由度为 $N - k$ 的 $F$ 分布，其中 $N = \\sum_{i=1}^{k} n_{i}$。\n\n您的程序必须为每个数据集执行以下操作：\n1. 计算每个组的均值 $\\bar{y}_{i}$、总均值 $\\bar{y}$、组内平方和 $SS_{W} = \\sum_{i=1}^{k}\\sum_{j=1}^{n_{i}}(y_{ij} - \\bar{y}_{i})^{2}$、总平方和 $SS_{T} = \\sum_{i=1}^{k}\\sum_{j=1}^{n_{i}}(y_{ij} - \\bar{y})^{2}$，以及组间平方和 $SS_{B} = SS_{T} - SS_{W}$（从而验证方差分解恒等式）。\n2. 计算自由度 $df_{B} = k - 1$ 和 $df_{W} = N - k$，均方 $MS_{B} = SS_{B}/df_{B}$ 和 $MS_{W} = SS_{W}/df_{W}$，以及 $F$ 统计量 $F = MS_{B}/MS_{W}$。\n3. 为保证数值稳健性，如果 $MS_{W} = 0$，则当 $SS_{B} > 0$ 时将 $F$ 定义为 $+\\infty$，当 $SS_{B} = 0$ 时将 $F$ 定义为 $\\mathrm{nan}$。\n\n测试套件：\n请精确使用以下四个数据集，每个数据集表示为一个组列表，其中每个组是一个实数列表。\n\n- 测试用例 A（平衡，组间分离明显）：$k = 3$，组数据\n  - 组 $1$：$[4.1, 4.3, 4.2, 4.0]$\n  - 组 $2$：$[5.0, 5.1, 4.9, 5.2]$\n  - 组 $3$：$[6.0, 5.8, 6.2, 5.9]$\n- 测试用例 B（无组间变异；所有组均值完全相等）：$k = 3$，组数据\n  - 组 $1$：$[10.0, 12.0, 8.0]$\n  - 组 $2$：$[9.0, 10.0, 11.0]$\n  - 组 $3$：$[7.0, 10.0, 13.0]$\n- 测试用例 C（样本量小且不相等）：$k = 2$，组数据\n  - 组 $1$：$[2.0, 2.1]$\n  - 组 $2$：$[2.5, 2.4, 2.6]$\n- 测试用例 D（组大小不相等，其中一组有偏移）：$k = 4$，组数据\n  - 组 $1$：$[15.0, 16.0, 14.0]$\n  - 组 $2$：$[15.0, 15.5]$\n  - 组 $3$：$[14.8, 15.2, 15.0, 15.1]$\n  - 组 $4$：$[18.0, 17.5, 18.2]$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个测试用例，仅按 A、B、C、D 的顺序输出 $F$ 统计量，格式为浮点数并四舍五入到 $6$ 位小数。例如，最终输出必须类似于\n$[\\text{FA},\\text{FB},\\text{FC},\\text{FD}]$\n除了分隔数字所必需的逗号外，不含任何其他文本或空格。\n\n此问题不涉及任何物理单位，因此不要报告任何单位。不要读取任何输入；程序必须完全自包含，并可按上述规定复现。", "solution": "该问题要求从基本原理出发，实现单因素方差分析（ANOVA），以计算多个数据集的 $F$ 统计量。该解决方案通过系统地应用指定的方差分量定义而得出。\n\n单因素 ANOVA 的核心原理是将数据集中的总变异分解为组间变异和组内变异。假设数据由 $k$ 个组构成。第 $i$ 个组（其中 $i \\in \\{1, 2, \\dots, k\\}$）包含 $n_i$ 个观测值，记为 $y_{ij}$，其中 $j \\in \\{1, 2, \\dots, n_i\\}$。数据集中的总观测数为 $N = \\sum_{i=1}^{k} n_i$。\n\n为给定数据集计算 $F$ 统计量的算法过程如下：\n\n1.  **均值计算**：\n    首先，我们计算必要的样本均值。\n    -   每个组 $i$ 的均值，记为 $\\bar{y}_i$，计算公式如下：\n        $$ \\bar{y}_i = \\frac{1}{n_i} \\sum_{j=1}^{n_i} y_{ij} $$\n    -   所有观测值的总均值，记为 $\\bar{y}$，计算公式如下：\n        $$ \\bar{y} = \\frac{1}{N} \\sum_{i=1}^{k} \\sum_{j=1}^{n_i} y_{ij} $$\n\n2.  **平方和（SS）计算**：\n    方差分解通过计算离差平方和来执行。\n    -   **总平方和** ($SS_T$) 衡量所有数据点围绕总均值的总变异。其定义如下：\n        $$ SS_T = \\sum_{i=1}^{k} \\sum_{j=1}^{n_i} (y_{ij} - \\bar{y})^2 $$\n    -   **组内平方和** ($SS_W$)，也称为误差平方和，衡量数据点围绕各自组均值的变异。其计算方法是：先计算每个组内的离差平方和，然后将所有组的结果相加：\n        $$ SS_W = \\sum_{i=1}^{k} \\sum_{j=1}^{n_i} (y_{ij} - \\bar{y}_i)^2 $$\n    -   **组间平方和** ($SS_B$) 衡量组均值围绕总均值的变异，并按组大小加权。根据问题的指示，此量使用 ANOVA 的基本分解恒等式计算：\n        $$ SS_B = SS_T - SS_W $$\n        这个恒等式 $SS_T = SS_B + SS_W$ 是 ANOVA 的基石，它表明总变异是组间变异与组内变异之和。\n\n3.  **自由度（df）计算**：\n    每个平方和项都关联一个自由度数值。\n    -   $SS_B$ 的自由度为 $df_B = k - 1$，对应于 $k$ 个组均值减去 $1$ 个约束（总均值）。\n    -   $SS_W$ 的自由度为 $df_W = N - k$，对应于 $N$ 个总观测值减去从中计算出的 $k$ 个组均值。\n\n4.  **均方（MS）计算**：\n    均方是平方和除以其各自的自由度，代表平均变异。\n    -   **组间均方**为：\n        $$ MS_B = \\frac{SS_B}{df_B} $$\n    -   **组内均方**为：\n        $$ MS_W = \\frac{SS_W}{df_W} $$\n    $MS_B$ 代表组间方差，而 $MS_W$ 代表组内合并方差。\n\n5.  **F-统计量计算**：\n    $F$ 统计量是组间方差与组内方差之比。\n    $$ F = \\frac{MS_B}{MS_W} $$\n    一个大的 $F$ 值表明组间变异显著大于组内变异，从而提供了反对所有组均值相等的原假设的证据。\n\n6.  **特殊情况处理**：\n    问题规定了当分母 $MS_W$ 为零时的稳健性规则。这种情况当且仅当 $SS_W=0$ 时发生，即每个组内的所有观测值都相同时。\n    -   如果 $MS_W = 0$（即 $SS_W = 0$）且 $SS_B > 0$，则组间变异非零而组内变异为零。这意味着存在无限强的证据表明存在差异，因此 $F$ 被定义为 $+\\infty$。\n    -   如果 $MS_W = 0$（即 $SS_W = 0$）且 $SS_B = 0$，则整个数据集中的所有观测值都相同。在这种情况下，$F$ 统计量是不确定的，被定义为非数值（$\\mathrm{nan}$）。\n\n实现过程将这些步骤转换成一个函数，该函数处理每个数据集，计算所有中间量（$N$、$k$、均值、$SS_T$、$SS_W$、$SS_B$、$df_B$、$df_W$、$MS_B$、$MS_W$），并返回最终的 $F$ 统计量，包括对特殊情况的指定处理。然后为每个测试用例调用该函数，并按要求格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef compute_f_statistic(data: list[list[float]]) -> float:\n    \"\"\"\n    Computes the F-statistic for a one-way ANOVA from first principles.\n\n    Args:\n        data: A list of lists, where each inner list represents a group's data.\n\n    Returns:\n        The calculated F-statistic as a float.\n    \"\"\"\n    # 1. Compute counts and consolidate data into a single array.\n    k = len(data)\n    if k = 1:\n        # F-statistic is not well-defined for a single group or no groups.\n        return math.nan\n\n    all_obs_list = [obs for group in data for obs in group]\n    N = len(all_obs_list)\n    \n    if N = k:\n        # This implies at least one group is empty or all groups have 1 obs,\n        # leading to df_w = 0.\n        if N == k and all(len(g)==1 for g in data):\n             # SS_W will be 0. Need to check SSB\n             ss_b_check = np.var(all_obs_list) * N\n             if ss_b_check > 0: return float('inf')\n             else: return float('nan')\n        return math.nan\n\n    all_obs_np = np.array(all_obs_list, dtype=np.float64)\n\n    # 2. Compute the group means and the overall mean.\n    overall_mean = np.mean(all_obs_np)\n    group_means = [np.mean(np.array(g, dtype=np.float64)) for g in data]\n\n    # 3. Compute the Sums of Squares (SS).\n    # SS_T: Total Sum of Squares\n    ss_t = np.sum((all_obs_np - overall_mean)**2)\n\n    # SS_W: Within-Groups Sum of Squares\n    ss_w = 0.0\n    for i in range(k):\n        group_data = np.array(data[i], dtype=np.float64)\n        ss_w += np.sum((group_data - group_means[i])**2)\n    \n    # SS_B: Between-Groups Sum of Squares, derived from the partitioning identity.\n    ss_b = ss_t - ss_w\n    \n    # Numpy's float precision can sometimes make a very small positive number\n    # slightly negative. We correct this for ss_b, which must be non-negative.\n    if ss_b  0 and np.isclose(ss_b, 0):\n        ss_b = 0.0\n\n    # 4. Compute degrees of freedom.\n    df_b = k - 1\n    df_w = N - k\n\n    # 5. Handle special cases as per problem description (based on SS_W).\n    # MS_W = 0 if and only if SS_W = 0.\n    if np.isclose(ss_w, 0):\n        ss_w = 0.0\n\n    if ss_w == 0:\n        if ss_b > 0:\n            return float('inf')\n        else: # ss_b is also 0\n            return float('nan')\n\n    # 6. Compute Mean Squares (MS) and the F-statistic.\n    ms_b = ss_b / df_b\n    ms_w = ss_w / df_w\n    \n    f_statistic = ms_b / ms_w\n    \n    return f_statistic\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A\n        [[4.1, 4.3, 4.2, 4.0], [5.0, 5.1, 4.9, 5.2], [6.0, 5.8, 6.2, 5.9]],\n        # Test case B\n        [[10.0, 12.0, 8.0], [9.0, 10.0, 11.0], [7.0, 10.0, 13.0]],\n        # Test case C\n        [[2.0, 2.1], [2.5, 2.4, 2.6]],\n        # Test case D\n        [[15.0, 16.0, 14.0], [15.0, 15.5], [14.8, 15.2, 15.0, 15.1], [18.0, 17.5, 18.2]]\n    ]\n\n    results = []\n    for case in test_cases:\n        f_value = compute_f_statistic(case)\n        results.append(f_value)\n\n    # Final print statement in the exact required format.\n    # The format specifier {:.6f} correctly handles regular floats, 'inf', and 'nan'.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4965592"}, {"introduction": "在掌握了方差分析的基本计算之后，我们可以探索一个更深层次的概念：实验设计的正交性。本练习将运用线性代数的几何语言——向量空间中的投影——来直观地揭示方差分析的工作原理。通过编程检验设计矩阵的正交性[@problem_id:4965573]，你将理解为何平衡设计（balanced design）在统计分析中备受青睐，以及方差分量的统计独立性是如何与实验设计的几何结构紧密相连的。", "problem": "给定一个线性模型情境，其中一个响应向量由两个设计因子的加性效应建模。目标是通过计算中心化列的逐对内积来检验设计因子的正交性，并将正交性与平方和分量的独立性及其Fisher-Snedecor $F$分布（定义为两个缩放卡方变量之比）联系起来。完全基于线性模型和欧几里得空间投影的基本原理进行操作，不使用任何预设的方差分析公式。\n\n用作基础的定义和假设：\n- 设响应向量为 $y \\in \\mathbb{R}^n$。设 $X_A \\in \\mathbb{R}^{n \\times p_A}$ 和 $X_B \\in \\mathbb{R}^{n \\times p_B}$ 是设计矩阵，它们使用任意满秩对比编码对两个分类因子 $A$ 和 $B$ 的主效应进行编码。设 $\\mathbf{1} \\in \\mathbb{R}^n$ 是截距列（全为1）。\n- 可通过减去列均值来对列进行中心化，以在内积检验中移除截距方向。\n- 使用到列空间 $S$ 上的正交投影，其定义为到 $S$ 上的欧几里得投影。将投影算子视为 $\\mathbb{R}^n$ 上的对称幂等线性映射。\n- 使用设计矩阵的秩来计算效应和误差的自由度。\n- 在具有独立同分布高斯误差的标准线性模型下，由到相互正交子空间上的正交投影所诱导的二次型是独立的。当除以其自由度后，效应平方和与误差均方之比服从Fisher-Snedecor $F$分布。\n\n您的程序必须：\n- 对每个测试用例，为因子 $A$ 和 $B$ 构建效应编码的设计矩阵，分别有 $L_A - 1$ 和 $L_B - 1$ 列，其中 $L_A$ 和 $L_B$ 是水平数。使用一种确定性效应编码方案，对于 $L-1$ 列，属于每个非参考水平的条目为 $+1$，属于参考水平的条目为 $-1$，否则为 $0$。然后通过减去其均值来中心化每一列。\n- 计算 $X_A$ 的每个中心化列与 $X_B$ 的每个中心化列之间的逐对内积。同时计算所有对的最大绝对归一化内积（绝对相关系数）。如果此最大绝对归一化内积小于容差 $\\tau$，则声明正交性检验为真。\n- 使用Moore-Penrose伪逆构建到 $\\mathrm{span}(\\mathbf{1})$ 上的截距投影算子，以及到 $\\mathrm{span}([\\mathbf{1}, X_A])$ 和 $\\mathrm{span}([\\mathbf{1}, X_B])$ 上的投影算子，并形成 $Q_A$ 和 $Q_B$ 作为移除截距后 $A$ 和 $B$ 的唯一效应投影算子（嵌套投影算子之差）。使用到完整模型 $\\mathrm{span}([\\mathbf{1}, X_A, X_B])$ 上的投影算子计算 $SSE$。\n- 使用嵌套设计矩阵的秩计算自由度 $df_A$、$df_B$ 和 $df_e$。\n- 计算每个因子的 $F$ 统计量，即其均方与误差均方之比，以及其在Fisher-Snedecor $F$ 分布下的尾概率。当且仅当唯一效应投影算子 $Q_A$ 和 $Q_B$ 是正交的（在容差 $\\tau$ 下，它们的乘积在数值上接近零算子），则声明独立性条件为真。\n- 对所有正交性检查使用严格容差 $\\tau = 10^{-10}$。\n\n测试套件：\n为以下三种情况实现上述要求。对于所有情况，设确定性残差为 $r_i = 0.1 \\times ((i \\bmod 3) - 1)$，其中索引 $i$ 从 $0$ 开始。均值和主效应分别为：因子 $A$ 水平的 $\\mu = 10$，$\\alpha = [-2, 0, 2]$；因子 $B$ 水平的 $\\beta = [-1, 1]$。响应定义为 $y_i = \\mu + \\alpha[A_i] + \\beta[B_i] + r_i$。\n\n- 情况1（平衡的3x2设计，每个单元格有两个重复；总n=12）：\n  - $A = [\\,0,0,1,1,2,2,0,0,1,1,2,2\\,]$\n  - $B = [\\,0,1,0,1,0,1,0,1,0,1,0,1\\,]$\n\n- 情况2（非平衡交叉；总n=11）：\n  - $A = [\\,0,0,0,1,1,2,2,2,2,2,1\\,]$\n  - $B = [\\,0,1,0,0,1,0,1,0,1,0,1\\,]$\n\n- 情况3（嵌套/重叠因子；B是A的二元折叠，其中如果A=2则B=1，否则B=0；平衡的n=12）：\n  - $A = [\\,0,0,1,1,2,2,0,0,1,1,2,2\\,]$\n  - $B = [\\,0,0,0,0,1,1,0,0,0,0,1,1\\,]$\n\n对于每个情况，按顺序输出以下内容：\n$[$\n- 中心化列的正交性检查（布尔值），\n- 唯一效应投影算子 $Q_A$ 和 $Q_B$ 的独立性条件检查（布尔值），\n- 因子列间的最大绝对归一化内积（浮点数），\n- 因子 $A$ 的 $F$ 统计量（浮点数），\n- 因子 $A$ 在Fisher-Snedecor $F$ 分布下的尾概率（浮点数），\n- 因子 $B$ 的 $F$ 统计量（浮点数），\n- 因子 $B$ 在Fisher-Snedecor $F$ 分布下的尾概率（浮点数）\n$]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个项目是按上述确切顺序排列的单个用例的列表。例如，输出应如下所示：$[ \\text{case1\\_list}, \\text{case2\\_list}, \\text{case3\\_list} ]$。", "solution": "该问题是有效的，因为它在科学上基于线性统计模型的理论，在数学上是适定的，并且所有术语和程序都得到了客观和完整的定义。我现在将着手解决该问题。\n\n该问题要求从基本原理出发，利用线性回归在向量投影方面的几何解释，对一个双因子线性模型进行分析。我们将构建必要的矩阵和算子，以分割响应向量 $y$ 的方差，并检验两个因子 $A$ 和 $B$ 的显著性。\n\n**1. 线性模型与向量空间表述**\n\n给定的线性模型是 $y_i = \\mu + \\alpha[A_i] + \\beta[B_i] + r_i$。以向量形式，可以写成 $y = X\\theta + \\epsilon$，其中 $y \\in \\mathbb{R}^n$ 是响应向量，$\\epsilon$ 是误差向量。设计矩阵 $X$ 和参数向量 $\\theta$ 封装了模型结构。具体来说，我们可以将模型表示为：\n$$\ny = \\mathbf{1}\\mu + X_A\\alpha^* + X_B\\beta^* + \\epsilon\n$$\n其中 $\\mathbf{1}$ 是用于截距 $\\mu$ 的 $n \\times 1$ 全1向量，$X_A \\in \\mathbb{R}^{n \\times (L_A-1)}$ 和 $X_B \\in \\mathbb{R}^{n \\times (L_B-1)}$ 是因子 $A$（有 $L_A$ 个水平）和因子 $B$（有 $L_B$ 个水平）主效应的设计矩阵，$\\alpha^*$ 和 $\\beta^*$ 是效应系数向量。\n\n**2. 投影算子与平方和**\n\n此分析的核心是将响应向量 $y$ 正交投影到 $\\mathbb{R}^n$ 的不同子空间上。到矩阵 $Z$ 的列空间 $\\mathcal{C}(Z)$ 的投影由投影算子 $P_Z$ 执行。如果 $Z$ 是满列秩的，则 $P_Z = Z(Z^T Z)^{-1}Z^T$。更一般地，使用Moore-Penrose伪逆 $Z^\\dagger$，投影算子为 $P_Z = Z Z^\\dagger$。投影算子是对称的（$P_Z^T = P_Z$）和幂等的（$P_Z^2 = P_Z$）。\n\n与一组预测变量 $Z$ 相关联的平方和 ($SS$) 是 $y$ 在 $\\mathcal{C}(Z)$ 上投影的欧几里得范数的平方：\n$$\nSS(Z) = \\|P_Z y\\|^2 = y^T P_Z^T P_Z y = y^T P_Z y\n$$\n\n该问题要求我们计算特定的平方和。我们定义以下子空间及其投影算子：\n- 仅截距：子空间 $S_1 = \\mathrm{span}(\\mathbf{1})$，投影算子 $P_1$。\n- 截距与因子A：子空间 $S_{1,A} = \\mathrm{span}([\\mathbf{1}, X_A])$，投影算子 $P_{1,A}$。\n- 截距与因子B：子空间 $S_{1,B} = \\mathrm{span}([\\mathbf{1}, X_B])$，投影算子 $P_{1,B}$。\n- 完整模型 (A+B)：子空间 $S_{1,A,B} = \\mathrm{span}([\\mathbf{1}, X_A, X_B])$，投影算子 $P_{1,A,B}$。\n\n一个因子的唯一贡献通过其解释的额外方差来评估。问题将因子 $A$ 的唯一效应投影算子定义为 $Q_A = P_{1,A} - P_1$，因子 $B$ 的定义为 $Q_B = P_{1,B} - P_1$。它们也是投影算子。$Q_A$ 投影到 $\\mathcal{C}([\\mathbf{1}, X_A])$ 中与 $\\mathcal{C}(\\mathbf{1})$ 正交的子空间上。这个子空间恰好是中心化设计矩阵的列空间，即 $\\mathcal{C}(\\tilde{X}_A)$，其中 $\\tilde{X}_A = (I - P_1)X_A$。\n\n因此，因子和误差的平方和为：\n- A的平方和（给定截距）：$SS_A = \\|Q_A y\\|^2 = y^T Q_A y$。\n- B的平方和（给定截距）：$SS_B = \\|Q_B y\\|^2 = y^T Q_B y$。\n- 误差平方和：$SSE = \\|y - P_{1,A,B} y\\|^2 = \\|(I - P_{1,A,B})y\\|^2 = y^T (I - P_{1,A,B}) y$。\n\n**3. 自由度与F统计量**\n\n任何平方和项 $y^T P y$ 的自由度 ($df$) 是投影矩阵 $P$ 的秩，也等于其迹，即 $df_P = \\mathrm{rank}(P) = \\mathrm{tr}(P)$。\n- $df_A = \\mathrm{rank}(Q_A) = \\mathrm{rank}(P_{1,A}) - \\mathrm{rank}(P_1) = L_A - 1$。\n- $df_B = \\mathrm{rank}(Q_B) = \\mathrm{rank}(P_{1,B}) - \\mathrm{rank}(P_1) = L_B - 1$。\n- $df_e = \\mathrm{rank}(I - P_{1,A,B}) = n - \\mathrm{rank}([\\mathbf{1}, X_A, X_B])$。\n\n均方 ($MS$) 是平方和除以其自由度，$MS = SS/df$。用于检验因子显著性的F统计量是其均方与误差均方 ($MSE$)之比：\n- $F_A = \\frac{MS_A}{MSE} = \\frac{SS_A / df_A}{SSE / df_e}$\n- $F_B = \\frac{MS_B}{MSE} = \\frac{SS_B / df_B}{SSE / df_e}$\n\n在因子无效应的原假设下，并假设误差是独立同分布的高斯分布，该统计量服从Fisher-Snedecor F分布，$F \\sim F(df_{effect}, df_e)$。\n\n**4. 正交性与独立性**\n\n测试了两种正交性概念：\n- **设计正交性**：如果因子 $A$ 和 $B$ 的中心化设计矩阵是正交的，即 $\\tilde{X}_A^T \\tilde{X}_B = \\mathbf{0}$，则称它们是正交的。这意味着 $\\tilde{X}_A$ 的每一列都与 $\\tilde{X}_B$ 的每一列正交。这通过计算所有逐对内积并检查它们是否在数值上为零来检验。平衡设计（每个单元格中观测数相等）保证了此属性。\n- **投影算子正交性（SS的独立性）**：如果对应的投影矩阵是正交的，即 $Q_A Q_B = \\mathbf{0}$，则平方和 $SS_A$ 和 $SS_B$ 在统计上是独立的。如前所述，$Q_A$ 是到 $\\mathcal{C}(\\tilde{X}_A)$ 上的投影算子，$Q_B$ 是到 $\\mathcal{C}(\\tilde{X}_B)$ 上的投影算子。条件 $Q_A Q_B = \\mathbf{0}$ 等价于这两个子空间的正交性，而这又等价于 $\\tilde{X}_A^T \\tilde{X}_B = \\mathbf{0}$。\n\n因此，对中心化列的逐对内积的检查与对投影算子 $Q_A$ 和 $Q_B$ 正交性的检查在数学上是等价的。我们期望它们在所有情况下产生相同的布尔结果。\n\n**5. 实现步骤**\n\n对于每个测试用例，我们执行以下计算：\n1.  使用给定的模型参数和残差函数生成长度为 $n$ 的响应向量 $y$。\n2.  构建效应编码的设计矩阵 $X_A$（大小为 $n \\times (L_A-1)$）和 $X_B$（大小为 $n \\times (L_B-1)$）。我们使用一种效应编码方案，其中最后一个水平为参考水平。\n3.  通过减去列均值来中心化 $X_A$ 和 $X_B$，得到 $\\tilde{X}_A$ 和 $\\tilde{X}_B$。\n4.  计算 $\\tilde{X}_A$ 和 $\\tilde{X}_B$ 的列之间的所有逐对内积。将它们归一化以获得相关系数，并找到最大绝对值。检查此值是否小于容差 $\\tau=10^{-10}$ 以测试设计正交性。\n5.  使用伪逆方法构建投影矩阵 $P_1$、$P_{1,A}$、$P_{1,B}$ 和 $P_{1,A,B}$。\n6.  计算唯一效应投影算子 $Q_A = P_{1,A} - P_1$ 和 $Q_B = P_{1,B} - P_1$。\n7.  通过计算其乘积的Frobenius范数 $\\|Q_A Q_B\\|_F$ 并与 $\\tau$ 进行比较来检查投影算子的正交性。\n8.  使用投影算子和 $y$ 计算 $SS_A$、$SS_B$ 和 $SSE$。\n9.  根据矩阵的秩计算自由度 $df_A$、$df_B$ 和 $df_e$。\n10. 计算 $F_A$、$F_B$ 及其对应的尾概率（p值），使用 `scipy.stats` 的F分布。\n11. 按规定格式收集和格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import f\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the validation and analysis for all test cases.\n    \"\"\"\n    \n    # Define parameters common to all test cases\n    mu = 10.0\n    alpha = np.array([-2.0, 0.0, 2.0])\n    beta = np.array([-1.0, 1.0])\n    r_func = lambda i: 0.1 * ((i % 3) - 1)\n    tau = 1e-10\n\n    # Define the test cases\n    test_cases = [\n        # Case 1: Balanced 3x2 design, n=12\n        {'A': np.array([0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2]),\n         'B': np.array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1])},\n        \n        # Case 2: Unbalanced crossing, n=11\n        {'A': np.array([0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 1]),\n         'B': np.array([0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1])},\n        \n        # Case 3: Nested/overlapping factors, n=12\n        {'A': np.array([0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2]),\n         'B': np.array([0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1])}\n    ]\n\n    all_results = []\n    for case_data in test_cases:\n        A_levels = case_data['A']\n        B_levels = case_data['B']\n        \n        # Generate response vector y\n        n = len(A_levels)\n        residuals = np.array([r_func(i) for i in range(n)])\n        y = mu + alpha[A_levels] + beta[B_levels] + residuals\n        \n        # --- Start Analysis ---\n\n        def build_design_matrix(levels, num_levels):\n            \"\"\"Builds an effect-coded design matrix.\"\"\"\n            n_obs = len(levels)\n            ref_level = num_levels - 1\n            X = np.zeros((n_obs, num_levels - 1))\n            for i in range(n_obs):\n                level = levels[i]\n                if level == ref_level:\n                    X[i, :] = -1.0\n                else:\n                    X[i, level] = 1.0\n            return X\n\n        LA = len(np.unique(A_levels))\n        LB = len(np.unique(B_levels))\n        \n        XA = build_design_matrix(A_levels, LA)\n        XB = build_design_matrix(B_levels, LB)\n\n        # 1. Orthogonality check of centered columns\n        XA_c = XA - XA.mean(axis=0)\n        XB_c = XB - XB.mean(axis=0)\n        \n        max_abs_corr = 0.0\n        if XA_c.shape[1] > 0 and XB_c.shape[1] > 0:\n            for i in range(XA_c.shape[1]):\n                col_A = XA_c[:, i]\n                norm_A = np.linalg.norm(col_A)\n                if norm_A  tau: continue\n                for j in range(XB_c.shape[1]):\n                    col_B = XB_c[:, j]\n                    norm_B = np.linalg.norm(col_B)\n                    if norm_B  tau: continue\n                    \n                    inner_product = np.dot(col_A, col_B)\n                    correlation = inner_product / (norm_A * norm_B)\n                    max_abs_corr = max(max_abs_corr, abs(correlation))\n\n        orthogonality_check = max_abs_corr  tau\n\n        # 2. Construct projectors and check independence\n        def make_projector(Z):\n            return Z @ np.linalg.pinv(Z)\n\n        one = np.ones((n, 1))\n        X_1 = one\n        X_1A = np.hstack([one, XA])\n        X_1B = np.hstack([one, XB])\n        \n        # Handle potential linear dependencies in full model for Case 3\n        # For rank calculation, we must be careful with stacking.\n        # If B is a function of A, hstack([1, X_A, X_B]) will be rank-deficient.\n        # np.linalg.matrix_rank will handle this.\n        X_1AB = np.hstack([one, XA, XB])\n\n        P_1 = make_projector(X_1)\n        P_1A = make_projector(X_1A)\n        P_1B = make_projector(X_1B)\n        P_1AB = make_projector(X_1AB)\n        \n        QA = P_1A - P_1\n        QB = P_1B - P_1\n        \n        independence_check = np.linalg.norm(QA @ QB, 'fro')  tau\n\n        # 3. Compute DFs, SS, and F-statistics\n        df_A = XA.shape[1]\n        df_B = XB.shape[1]\n        df_e = n - np.linalg.matrix_rank(X_1AB)\n\n        SSA = y.T @ QA @ y\n        SSB = y.T @ QB @ y\n        SSE = y.T @ (np.identity(n) - P_1AB) @ y\n        \n        MSA = SSA / df_A if df_A > 0 else 0\n        MSB = SSB / df_B if df_B > 0 else 0\n        MSE = SSE / df_e if df_e > 0 else np.nan\n\n        if MSE > 0 and MSA >= 0 and df_A > 0:\n            F_A = MSA / MSE\n            p_A = f.sf(F_A, df_A, df_e)\n        else:\n            F_A = np.nan\n            p_A = np.nan\n\n        if MSE > 0 and MSB >= 0 and df_B > 0:\n            F_B = MSB / MSE\n            p_B = f.sf(F_B, df_B, df_e)\n        else:\n            F_B = np.nan\n            p_B = np.nan\n            \n        case_results = [\n            orthogonality_check,\n            independence_check,\n            float(max_abs_corr),\n            float(F_A),\n            float(p_A),\n            float(F_B),\n            float(p_B)\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The format required is a string representation of a list of lists.\n    # str(list) in Python produces '[item1, item2]', so joining str(r) for each result list r works.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "4965573"}, {"introduction": "在学会如何分析现有数据后，一个自然而然的问题是如何规划未来的研究。本练习将我们的关注点从数据分析转向实验设计，演示如何为方差分析进行功效分析（power analysis）。通过利用非中心$F$分布[@problem_id:4965568]，你将学习如何计算所需的最小样本量，以确保实验有足够的能力在给定的置信水平下检测到具有科学意义的效应，从而设计出既高效又可靠的研究。", "problem": "您的任务是构建一个程序，为均衡单因素固定效应方差分析 (ANOVA) 执行功效分析。该程序必须在假定正态性和组内方差共同的情况下，确定为达到正确拒绝原假设的指定概率所需的每组最小整数样本量。该方法必须明确地将一个中心临界阈值与来自非中心F分布的逆生存分位数进行比较。\n\n其基本设置为一个具有 $k$ 个组、每组样本量为 $n$、总样本量为 $N = k n$ 的均衡单因素固定效应 ANOVA 模型。第 $i$ 组的总体均值为 $\\mu_i$，所有组共享一个共同的误差方差 $\\sigma^2$。假设检验的目标是检验所有组均值相等的原假设 $H_0$ 与并非所有 $\\mu_i$ 都相等的固定效应备择假设。错误概率阈值是显著性水平 $\\alpha \\in (0,1)$，在固定效应备择假设下拒绝 $H_0$ 的期望概率是功效水平 $1 - \\beta \\in (0,1)$。\n\n您的程序必须：\n- 假定为均衡设计，即所有组的 $n$ 相等。\n- 对于给定的组均值和共同的组内方差，计算能达到至少指定功效水平的每组最小整数样本量 $n \\geq 2$。如果指定的均值意味着没有差异（即，在模型要求的意义上所有组均值相等），则程序必须对该测试用例输出 $-1$，以表示在任何有限样本量下都无法达到目标功效。\n- 使用中心F分布确定自由度为 $df_1 = k - 1$ 和 $df_2 = N - k$ 时尾部概率为 $\\alpha$ 的临界阈值，并使用在固定效应备择假设下具有适当非中心性参数的、在指定功效下的非中心F逆生存分位数来评估是否满足功效要求。\n- 确保计算出的每组样本量是满足要求的最小整数。\n\n程序必须实现一个关于 $n$ 的单调搜索策略（例如，先进行区间限定再进行二分搜索），并且其决策逻辑必须基于中心F临界阈值与目标功效下的非中心F逆生存分位数之间的比较。\n\n此计算不涉及物理单位。所有输出都必须是整数。如果对于提供的参数，目标功效无法达到（当所有组均值相等时会发生这种情况），则输出 $-1$。\n\n测试套件：\n请在以下四种情况下评估您的程序。在每种情况下，输入都是组均值列表、共同的组内方差、显著性水平和期望功效。\n\n- 情况1：均值 $[0.0, 0.5, 1.0]$，方差 $\\sigma^2 = 1.0$，显著性 $\\alpha = 0.05$，期望功效 $1 - \\beta = 0.8$。\n- 情况2：均值 $[0.0, 0.2]$，方差 $\\sigma^2 = 1.0$，显著性 $\\alpha = 0.05$，期望功效 $1 - \\beta = 0.9$。\n- 情况3：均值 $[1.0, 1.0, 1.0, 1.0]$，方差 $\\sigma^2 = 1.0$，显著性 $\\alpha = 0.05$，期望功效 $1 - \\beta = 0.8$。\n- 情况4：均值 $[-1.0, -0.5, 0.0, 0.5, 1.0]$，方差 $\\sigma^2 = 0.5$，显著性 $\\alpha = 0.01$，期望功效 $1 - \\beta = 0.95$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个情况的整数结果，以逗号分隔的列表形式，并用方括号括起来，顺序与上述情况相同。例如，输出格式必须类似于 $[n_1,n_2,n_3,n_4]$，其中每个 $n_i$ 是为情况 $i$ 计算出的最小每组样本量，如果无法达到则为 $-1$。", "solution": "用户提供的问题已经过严格验证，并被确定为 **有效** 问题。这是一个在生物统计功效分析领域中定义明确、科学上合理的的问题。所有必需的参数都已指定，术语精确，目标清晰。该问题要求实现一个标准但并非无足轻重的统计程序。\n\n本文提供了一个完整且论证充分的解决方案。\n\n### 单因素 ANOVA 功效分析的理论基础\n\n该问题置于单因素固定效应方差分析 (ANOVA) 的背景下。对于来自组 $i \\in \\{1, \\dots, k\\}$ 和受试者 $j \\in \\{1, \\dots, n\\}$ 的一个观测值 $Y_{ij}$，其统计模型为：\n$$\nY_{ij} = \\mu_i + \\epsilon_{ij}\n$$\n其中 $\\mu_i$ 是第 $i$ 组的真实均值，误差项 $\\epsilon_{ij}$ 被假定为独立同分布的正态随机变量，$\\epsilon_{ij} \\sim \\mathcal{N}(0, \\sigma^2)$，所有 $k$ 个组具有共同方差 $\\sigma^2$。设计是均衡的，意味着每组都有相同的样本量 $n$。总样本量为 $N = kn$。\n\nANOVA 的假设检验如下：\n-   原假设 $H_0$：所有组均值相等，即 $\\mu_1 = \\mu_2 = \\dots = \\mu_k$。\n-   备择假设 $H_1$：至少有一个组均值与其他组不同。\n\n检验统计量是组间均方 ($MSB$) 与组内均方 ($MSW$) 的比值：\n$$\nF = \\frac{MSB}{MSW} = \\frac{SSB / (k-1)}{SSW / (N-k)}\n$$\n在原假设和备择假设下，此 F-统计量的分布是功效分析的核心：\n1.  在 $H_0$ 下，统计量 $F$ 服从自由度为 $df_1 = k-1$ 和 $df_2 = N-k$ 的 **中心F分布**。我们将其表示为 $F \\sim F(df_1, df_2)$。\n2.  在 $H_1$ 下，统计量 $F$ 服从具有相同自由度和非中心性参数 (NCP) $\\lambda$ 的 **非中心F分布**。我们将其表示为 $F \\sim F(df_1, df_2, \\lambda)$。\n\n非中心性参数 $\\lambda$ 量化了原假设为假的程度。对于均衡单因素 ANOVA，其定义为：\n$$\n\\lambda = \\frac{n \\sum_{i=1}^{k} (\\mu_i - \\bar{\\mu})^2}{\\sigma^2}\n$$\n其中 $\\bar{\\mu} = \\frac{1}{k} \\sum_{i=1}^{k} \\mu_i$ 是总体均值的总平均值。\n\n### 功效计算与计算策略\n\n统计功效 ($1-\\beta$) 是正确拒绝一个错误的原假设的概率。如果观测到的 F-统计量 $F_{obs}$ 超过一个临界值 $F_{crit}$，我们就拒绝 $H_0$。这个临界值由显著性水平 $\\alpha$ 决定。具体来说，$F_{crit}$ 是这样一个值：在 $H_0$ 下，观测到大于它的 F-统计量的概率恰好为 $\\alpha$。这对应于中心 F 分布的上 $\\alpha$-分位数：\n$$\nF_{crit} = F_{\\text{isf}}(\\alpha; df_1, df_2)\n$$\n其中 $F_{\\text{isf}}$ 是中心 F 分布的逆生存函数（或上尾的分位数点函数）。\n\n功效即为当 $H_1$ 为真时，此拒绝事件发生的概率：\n$$\n\\text{Power} = P(F  F_{crit} | H_1)\n$$\n由于在 $H_1$ 下 F-统计量服从非中心 F 分布，因此功效是使用此分布的生存函数 (SF) 来计算的：\n$$\n\\text{Power} = \\text{SF}_{ncf}(F_{crit}; df_1, df_2, \\lambda)\n$$\n目标是找到满足以下条件的每组最小整数样本量 $n \\geq 2$：\n$$\n\\text{Power} \\geq 1-\\beta\n$$\n其中 $1-\\beta$ 是期望的功效水平。\n\n该问题为此检查指定了一种特定方法，该方法涉及将中心临界阈值与来自非中心 F 分布的逆生存分位数进行比较。这是对功效条件的一种优雅的重构。条件 $\\text{SF}_{ncf}(F_{crit}; df_1, df_2, \\lambda) \\geq 1-\\beta$ 等价于：\n$$\nF_{crit} \\leq F_{ncf, \\text{isf}}(1-\\beta; df_1, df_2, \\lambda)\n$$\n这种等价性成立，因为生存函数是一个单调递减函数，因此对其逆函数（逆生存函数）应用于不等式两侧会反转不等号。此不等式的右侧恰好是所要求的“在指定功效下的非中心 F 分布的逆生存分位数”。\n\n### 最小样本量 $n$ 的搜索算法\n\n问题的核心是找到满足上述不等式的最小整数 $n \\geq 2$。关键在于，不等式的两边都依赖于 $n$：\n-   $df_2(n) = k(n-1)$\n-   $\\lambda(n) = n \\cdot C$，其中常数 $C = \\frac{\\sum (\\mu_i - \\bar{\\mu})^2}{\\sigma^2}$ 仅依赖于给定的问题参数。\n\n对不等式与 $n$ 的依赖关系进行分析，揭示了其单调性：\n-   左侧，$F_{crit}(n) = F_{\\text{isf}}(\\alpha; k-1, k(n-1))$，是 $n$ 的一个 **递减** 函数，因为增加分母自由度 $df_2$ 会使中心 F 分布的离散程度降低。\n-   右侧，$F_{ncf, \\text{isf}}(1-\\beta; k-1, k(n-1), \\lambda(n))$，是 $n$ 的一个 **递增** 函数。这是因为 $df_2$ 的增加和 NCP $\\lambda$ 的线性增加都会使非中心 F 分布向右移动，从而增加其分位数。\n\n由于一个递减函数与一个递增函数进行比较，当 $n$ 高于某个阈值时，该条件将对所有这些 $n$ 成立。这种结构使得该问题适合于高效搜索。\n\n算法流程如下：\n1.  **初始化**：从均值列表中计算出 $k$。计算均值的离差平方和 $\\sum_{i=1}^{k} (\\mu_i - \\bar{\\mu})^2$。如果该和为零（或在数值上与零无法区分），则意味着对所有 $n$ 而言 $\\lambda=0$。在这种情况下，功效始终等于显著性水平 $\\alpha$。如果 $\\alpha$ 小于目标功效 $1-\\beta$，则目标无法达到。程序必须按规定返回 $-1$。\n2.  **搜索 $n$**：我们寻找满足功效条件的最小整数 $n \\geq 2$。\n    -   一种稳健的方法是首先建立一个搜索范围 $[n_{low}, n_{high}]$，其中条件在 $n_{low}$ 处不满足，而在 $n_{high}$ 处满足。这可以通过从一个较低的值（例如，$n_{low}=2$）开始，并以指数方式增加测试值，直到满足功效要求，该测试值即成为 $n_{high}$。\n    -   一旦这个区间被确定，就在范围 $[n_{low}, n_{high}]$ 内执行 **二分搜索**，以高效地精确定位使功效条件成立的最小整数 $n$。由于已确立的单调性，该策略是高效的，并保证能找到最小整数解。\n\n最终的 Python 实现将使用 `numpy` 进行数值计算，并使用 `scipy.stats.f.isf` 和 `scipy.stats.ncf.isf` 来计算所需的统计分位数，直接体现了所述逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import f, ncf\n\ndef compute_min_n_power_anova(\n    means: list[float], variance: float, alpha: float, power: float\n) - int:\n    \"\"\"\n    Computes the minimal integer per-group sample size for a one-way ANOVA.\n\n    Args:\n        means: A list of population group means.\n        variance: The common within-group variance (sigma^2).\n        alpha: The significance level (Type I error probability).\n        power: The desired statistical power (1 - beta).\n\n    Returns:\n        The minimal integer sample size n per group (n = 2), or -1 if\n        the target power is unattainable (i.e., all group means are equal).\n    \"\"\"\n\n    k = len(means)\n    if k  2:\n        # ANOVA requires at least 2 groups.\n        # This case is not in the test suite but is a logical check.\n        return -1\n\n    # Calculate the sum of squared deviations of group means from the grand mean\n    mu_array = np.array(means)\n    grand_mean = np.mean(mu_array)\n    sum_sq_dev = np.sum((mu_array - grand_mean) ** 2)\n\n    # If all means are equal, the noncentrality parameter is always 0.\n    # Power will be equal to alpha, so target power is unattainable.\n    if np.isclose(sum_sq_dev, 0.0):\n        return -1\n\n    effect_size_term = sum_sq_dev / variance\n\n    def is_power_sufficient(n: int) - bool:\n        \"\"\"\n        Checks if a given sample size n achieves the target power.\n        The check is based on the problem's specified comparison.\n        \"\"\"\n        if n  2:\n            return False\n\n        df1 = k - 1\n        df2 = k * (n - 1)\n        \n        # Noncentrality parameter lambda\n        ncp = n * effect_size_term\n\n        # Central F critical threshold for significance level alpha\n        f_crit = f.isf(alpha, df1, df2)\n\n        # Inverse survival quantile from the noncentral F distribution at the target power\n        f_power_quantile = ncf.isf(1 - power, df1, df2, ncp)\n        \n        # The condition Power >= target_power is equivalent to F_crit = F_power_quantile\n        return f_crit = f_power_quantile\n\n    # Initial check at the lower bound n=2\n    if is_power_sufficient(2):\n        return 2\n\n    # --- Bracketing phase to find a search range [n_low, n_high] ---\n    n_low = 2\n    n_high = 4\n    # Set a practical limit to prevent potential infinite loops with extreme parameters\n    MAX_N_BRACKET = 1000000  \n    while not is_power_sufficient(n_high):\n        n_low = n_high\n        n_high *= 2\n        if n_high > MAX_N_BRACKET:\n            # Power goal is practically unattainable\n            return -1\n\n    # --- Binary search phase to find the minimal integer n ---\n    min_n = n_high\n    while n_low = n_high:\n        n_mid = n_low + (n_high - n_low) // 2\n        if n_mid  2:  # Ensure sample size is at least 2\n            n_low = n_mid + 1\n            continue\n\n        if is_power_sufficient(n_mid):\n            min_n = n_mid      # n_mid is a potential answer, try for smaller n\n            n_high = n_mid - 1\n        else:\n            n_low = n_mid + 1  # n_mid is too small, need larger n\n            \n    return min_n\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # format: (means, variance, alpha, power)\n    test_cases = [\n        ([0.0, 0.5, 1.0], 1.0, 0.05, 0.8),\n        ([0.0, 0.2], 1.0, 0.05, 0.9),\n        ([1.0, 1.0, 1.0, 1.0], 1.0, 0.05, 0.8),\n        ([-1.0, -0.5, 0.0, 0.5, 1.0], 0.5, 0.01, 0.95),\n    ]\n\n    results = []\n    for case in test_cases:\n        means, variance, alpha, power = case\n        result = compute_min_n_power_anova(means, variance, alpha, power)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4965568"}]}