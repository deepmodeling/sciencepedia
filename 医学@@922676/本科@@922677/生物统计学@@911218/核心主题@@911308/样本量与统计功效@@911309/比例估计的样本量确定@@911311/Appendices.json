{"hands_on_practices": [{"introduction": "任何样本量估算的核心都是一个基本公式，它将期望的精度、置信水平和总体变异性联系在一起。与其仅仅记住这个公式，不如从第一性原理推导它，这能让您对影响研究设计的各个因素有更深刻的理解。这项练习将指导您使用正态近似方法，从头开始构建用于估计比例的样本量公式，为您后续更复杂的应用打下坚实的理论基础。[@problem_id:4950548]", "problem": "一家公共卫生实验室计划进行一项横断面研究，以估计未知的感染率与一个基准值之间的差异。设 $p$ 表示目标人群中受感染的真实总体比例，设 $p_{0}$ 表示前一个监测年度的固定基准比例。关注的待估量是风险差 $d = p - p_{0}$。一名研究者将从目标人群中收集一个大小为 $n$ 的独立同分布样本，并计算样本比例 $\\hat{p}$，以构建插入式估计量 $\\hat{d} = \\hat{p} - p_{0}$。设计要求是，基于大样本正态近似的 $d$ 的双侧 $(1-\\alpha)$ 置信区间的半宽不大于一个预设的边际 $m  0$。\n\n从伯努利结果抽样的第一性原理出发，推导在所述正态近似下，保证满足边际要求的最小所需样本量 $n$ 关于 $p$、$\\alpha$ 和 $m$ 的精确解析表达式。然后，定性解释在该近似下，所需样本量 $n$ 如何依赖于 $p$，并确定哪些 $p$ 值会使 $n$ 最大化。你最终报告的答案必须是 $n$ 的闭式符号表达式；不要代入数值或报告不等式。", "solution": "经评估，问题陈述有效。这是一个在生物统计学中提法得当、有科学依据、没有矛盾或歧义的问题。因此，我们可以进行推导。\n\n设个体受试者的结果为一个随机变量 $X$，如果受试者被感染，则 $X=1$，否则 $X=0$。给定抽样来自一个大总体，其中受感染个体的真实比例为 $p$。因此，$X$ 服从参数为 $p$ 的伯努利分布，记为 $X \\sim \\text{Bernoulli}(p)$。$X$ 的期望值是 $E[X] = p$，其方差是 $\\text{Var}(X) = p(1-p)$。\n\n抽取一个大小为 $n$ 的独立同分布样本，得到结果 $X_1, X_2, \\ldots, X_n$。样本比例 $\\hat{p}$ 是这些结果的样本均值：\n$$ \\hat{p} = \\frac{1}{n} \\sum_{i=1}^{n} X_i $$\n根据期望的线性性，样本比例的期望值为：\n$$ E[\\hat{p}] = E\\left[\\frac{1}{n} \\sum_{i=1}^{n} X_i\\right] = \\frac{1}{n} \\sum_{i=1}^{n} E[X_i] = \\frac{1}{n} \\sum_{i=1}^{n} p = \\frac{np}{n} = p $$\n由于观测值是独立的，样本比例的方差为：\n$$ \\text{Var}(\\hat{p}) = \\text{Var}\\left(\\frac{1}{n} \\sum_{i=1}^{n} X_i\\right) = \\frac{1}{n^2} \\sum_{i=1}^{n} \\text{Var}(X_i) = \\frac{1}{n^2} \\sum_{i=1}^{n} p(1-p) = \\frac{n p(1-p)}{n^2} = \\frac{p(1-p)}{n} $$\n关注的待估量是风险差 $d = p - p_0$，其中 $p_0$ 是一个固定的已知常数。$d$ 的估计量为 $\\hat{d} = \\hat{p} - p_0$。$\\hat{d}$ 的期望值是 $E[\\hat{d}] = E[\\hat{p} - p_0] = E[\\hat{p}] - p_0 = p - p_0 = d$。这证实了 $\\hat{d}$ 是 $d$ 的一个无偏估计量。$\\hat{d}$ 的方差是：\n$$ \\text{Var}(\\hat{d}) = \\text{Var}(\\hat{p} - p_0) = \\text{Var}(\\hat{p}) = \\frac{p(1-p)}{n} $$\n因为 $p_0$ 是一个常数，对总方差没有贡献。估计量 $\\hat{d}$ 的标准误是其方差的平方根：\n$$ SE(\\hat{d}) = \\sqrt{\\frac{p(1-p)}{n}} $$\n问题陈述指出，需要基于大样本正态近似构建 $d$ 的双侧 $(1-\\alpha)$ 置信区间。根据中心极限定理，对于足够大的样本量 $n$，$\\hat{d}$ 的抽样分布近似为均值为 $d$、方差为 $\\frac{p(1-p)}{n}$ 的正态分布。$d$ 的一个通用双侧 $(1-\\alpha)$ 置信区间由下式给出：\n$$ \\hat{d} \\pm z_{1-\\alpha/2} \\times SE(\\hat{d}) $$\n其中 $z_{1-\\alpha/2}$ 是标准正态分布的分位数，其右侧尾部概率为 $\\alpha/2$（即 $\\Phi(z_{1-\\alpha/2}) = 1-\\alpha/2$，其中 $\\Phi$ 是标准正态累积分布函数）。\n\n该置信区间的半宽，我们可以记为 $HW$，是乘以 $z$ 值的量：\n$$ HW = z_{1-\\alpha/2} \\times SE(\\hat{d}) = z_{1-\\alpha/2} \\sqrt{\\frac{p(1-p)}{n}} $$\n设计要求是该半宽不得大于预设的边际 $m  0$。为了找到保证此条件的最小样本量 $n$，我们将半宽设为等于 $m$：\n$$ m = z_{1-\\alpha/2} \\sqrt{\\frac{p(1-p)}{n}} $$\n现在我们求解这个方程以得到 $n$。两边平方得：\n$$ m^2 = \\left(z_{1-\\alpha/2}\\right)^2 \\left(\\frac{p(1-p)}{n}\\right) $$\n两边乘以 $n$ 得：\n$$ n m^2 = z_{1-\\alpha/2}^{2} p(1-p) $$\n最后，除以 $m^2$ 分离出 $n$，得到最小所需样本量的精确解析表达式：\n$$ n = \\frac{z_{1-\\alpha/2}^{2} p(1-p)}{m^2} $$\n该表达式给出了 $n$ 关于真实比例 $p$、显著性水平 $\\alpha$（它决定了 $z_{1-\\alpha/2}$）和期望的误差界限 $m$ 的关系。\n\n为了定性解释所需样本量 $n$ 如何依赖于 $p$，我们考察推导出的公式。对于固定的置信水平 $(1-\\alpha)$ 和边际 $m$，项 $z_{1-\\alpha/2}^2$ 和 $m^2$ 是正常数。因此，$n$ 与乘积 $p(1-p)$ 成正比：\n$$ n \\propto p(1-p) $$\n项 $p(1-p)$ 表示单次伯努利试验的方差。因此，达到特定精度所需的样本量由总体的基础方差决定。函数 $f(p) = p(1-p) = p-p^2$ 是一个关于 $p$ 的二次函数，定义在区间 $p \\in [0, 1]$ 上。为了找到使该函数最大化，从而使所需样本量 $n$ 最大化的 $p$ 值，我们可以使用微积分。对 $p$ 求一阶导数并令其为零：\n$$ \\frac{df}{dp} = \\frac{d}{dp}(p-p^2) = 1 - 2p = 0 $$\n求解 $p$ 得 $p = \\frac{1}{2} = 0.5$。二阶导数是 $\\frac{d^2f}{dp^2} = -2$，为负值，证实了 $p=0.5$ 对应一个最大值。\n\n因此，当真实总体比例 $p$ 为 $0.5$ 时，所需样本量 $n$ 达到最大值。这是“最坏情况”或最保守的情景，因为它对应于总体中可能的最大异质性（方差）。当总体在感染和未感染个体之间均等分配时，不确定性达到峰值，需要最大的样本量才能以给定的精度水平估计该比例。当 $p$ 趋近于 $0$ 或 $1$ 时，总体变得更加同质，方差 $p(1-p)$ 减小，因此需要的样本量也更小。", "answer": "$$\\boxed{\\frac{z_{1-\\alpha/2}^{2} p(1-p)}{m^2}}$$", "id": "4950548"}, {"introduction": "在公共卫生和药物安全监测等领域，我们经常关注发生率极低的罕见事件。在这种情况下，传统的基于正态近似的样本量公式可能不再适用，我们需要一种更合适的工具。这项练习介绍泊松近似法，它是在大样本和低概率事件场景下的一个强大分析武器。您将学习如何在这种特殊情况下推导置信区间，并为一个旨在证明事件发生率低于某个安全阈值的研究确定所需样本量。[@problem_id:4950477]", "problem": "一项安全性监测研究将招募 $n$ 名独立的受试者，每名受试者的二元不良事件结果被建模为事件概率为 $p$ 的独立同分布的伯努利随机变量。令 $X$ 表示这 $n$ 名受试者中不良事件的总数，因此 $X$ 服从参数为 $n$ 和 $p$ 的二项分布。在罕见事件的情况下，即 $p$ 很小且 $n$ 很大，但乘积 $np$ 保持中等大小，请仔细论证用均值参数为 $\\lambda = np$ 的泊松分布来近似 $X$ 的二项分布的合理性。从基本定义出发，在 $p \\to 0$、$n \\to \\infty$ 且 $np \\to \\lambda$ 的条件下，建立二项概率质量函数的极限形式，并解释指数极限在此推导中的作用。\n\n使用此泊松近似，基于观测到的计数 $X$，并以泊松模型下最大似然估计 (MLE) 的大样本性质以及 MLE 在平滑变换下的不变性为出发点，推导事件概率 $p$ 的一个近似双侧 $(1-\\alpha)$ 置信区间 (CI)。同时，通过反转精确的泊松尾部概率，推导在观测计数为 $X=0$ 的特殊情况下 $p$ 的 $(1-\\alpha)$ 单侧置信上界。\n\n规划问题：一项设备安全性研究旨在证明，如果观测到零个不良事件，则 $p$ 的单侧 95% 置信上界严格低于一个预先设定的安全性阈值 $p^{\\star} = 1.5 \\times 10^{-4}$。对于单侧界，取 $\\alpha = 0.05$。使用上文推导的泊松近似结果，确定所需的最小整数样本量 $n$，使得当 $X=0$ 时，$p$ 的 $(1-\\alpha)$ 上界小于 $p^{\\star}$。将最终数值答案表示为单个整数 $n$。无需按有效数字进行四舍五入；报告满足条件的最小整数。", "solution": "在 $n$ 次事件概率为 $p$ 的独立伯努利试验中，不良事件的总数 $X$ 服从二项分布，其概率质量函数为\n$$\n\\Pr(X=x) = \\binom{n}{x} p^{x} (1-p)^{n-x}, \\quad x=0,1,2,\\dots,n.\n$$\n我们寻求当 $p$ 很小且 $n$ 很大，而乘积 $np$ 保持中等数量级时的极限近似。设 $\\lambda = np$ 并考虑极限 $n \\to \\infty$，$p \\to 0$，使得 $np \\to \\lambda$。一种标准方法是代入 $p = \\lambda/n$ 并考察其极限形式：\n$$\n\\Pr(X=x) = \\binom{n}{x} \\left(\\frac{\\lambda}{n}\\right)^{x} \\left(1 - \\frac{\\lambda}{n}\\right)^{n-x}.\n$$\n重写二项式系数并分离各项：\n$$\n\\binom{n}{x} \\left(\\frac{\\lambda}{n}\\right)^{x} = \\frac{n(n-1)\\cdots(n-x+1)}{x!} \\cdot \\frac{\\lambda^{x}}{n^{x}}.\n$$\n当 $n \\to \\infty$ 且 $x$ 固定时，我们有\n$$\n\\frac{n(n-1)\\cdots(n-x+1)}{n^{x}} \\to 1,\n$$\n因此第一项收敛于 $\\lambda^{x}/x!$。对于剩余的项，使用熟知的指数极限\n$$\n\\lim_{n \\to \\infty} \\left(1 - \\frac{\\lambda}{n}\\right)^{n} = \\exp(-\\lambda).\n$$\n此外，\n$$\n\\left(1 - \\frac{\\lambda}{n}\\right)^{-x} \\to 1 \\quad \\text{as} \\quad n \\to \\infty \\quad \\text{for fixed } x.\n$$\n结合这些极限可得\n$$\n\\Pr(X=x) \\to \\frac{\\lambda^{x}}{x!} \\exp(-\\lambda),\n$$\n这正是均值为 $\\lambda$ 的泊松随机变量的概率质量函数。因此，在 $p \\to 0$、$n \\to \\infty$ 且 $np \\to \\lambda$ 的条件下，我们有近似 $X \\sim \\text{Poisson}(\\lambda)$，其中 $\\lambda = np$。\n\n接下来，我们通过泊松近似来推导 $p$ 的近似置信区间。在 $X \\sim \\text{Poisson}(\\lambda)$ 的条件下，$\\lambda$ 的最大似然估计 (MLE) 是 $\\hat{\\lambda} = X$。单个泊松观测值关于 $\\lambda$ 的费雪信息量为 $I(\\lambda) = 1/\\lambda$，根据标准渐近理论，MLE 近似服从正态分布：\n$$\n\\hat{\\lambda} \\approx \\text{Normal}(\\lambda, \\lambda),\n$$\n或等价地，\n$$\n\\frac{\\hat{\\lambda} - \\lambda}{\\sqrt{\\lambda}} \\approx \\text{Normal}(0,1).\n$$\n在标准误中用 $\\hat{\\lambda}$ 替换 $\\lambda$，得到我们熟知的 $\\lambda$ 的大样本双侧 $(1-\\alpha)$ 置信区间：\n$$\n\\hat{\\lambda} \\pm z_{1-\\alpha/2} \\sqrt{\\hat{\\lambda}},\n$$\n其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$ 分位数。由于 $p = \\lambda/n$，$p$ 的 MLE 是 $\\hat{p} = \\hat{\\lambda}/n = X/n$。根据 MLE 在平滑变换下的不变性以及 Delta 方法，$p$ 的近似双侧 $(1-\\alpha)$ 置信区间为\n$$\n\\hat{p} \\pm z_{1-\\alpha/2} \\frac{\\sqrt{\\hat{\\lambda}}}{n} \\;=\\; \\frac{X}{n} \\pm z_{1-\\alpha/2} \\frac{\\sqrt{X}}{n}.\n$$\n这个区间利用了在事件罕见时对方差的泊松近似。\n\n我们现在通过反转精确的泊松尾部概率来推导当 $X=0$ 时 $p$ 的单侧置信上界。对于 $X \\sim \\text{Poisson}(\\lambda)$，观测到零个事件的概率是\n$$\n\\Pr(X=0) = \\exp(-\\lambda).\n$$\n在给定 $X=0$ 的条件下，$\\lambda$ 的一个单侧 $(1-\\alpha)$ 置信上界 $\\lambda_U$ 满足\n$$\n\\Pr_{\\lambda_U}(X=0) = \\alpha \\quad \\Rightarrow \\quad \\exp(-\\lambda_U) = \\alpha \\quad \\Rightarrow \\quad \\lambda_U = -\\ln(\\alpha).\n$$\n通过 $p = \\lambda/n$ 转换回 $p$，得到相应的上界\n$$\np_U = \\frac{\\lambda_U}{n} = \\frac{-\\ln(\\alpha)}{n}.\n$$\n\n我们将此应用于规划问题。该研究旨在确保，如果 $X=0$，在置信水平为 $(1-\\alpha)$ (其中 $\\alpha = 0.05$) 时，$p$ 的单侧上界严格低于 $p^{\\star} = 1.5 \\times 10^{-4}$。该要求是\n$$\np_U = \\frac{-\\ln(\\alpha)}{n}  p^{\\star}.\n$$\n解出 $n$ 可得\n$$\nn > \\frac{-\\ln(\\alpha)}{p^{\\star}}.\n$$\n为保证该上界严格小于 $p^{\\star}$，我们选择满足该不等式的最小整数 $n$：\n$$\nn_{\\min} = \\left\\lceil \\frac{-\\ln(\\alpha)}{p^{\\star}} \\right\\rceil.\n$$\n代入 $\\alpha = 0.05$ 和 $p^{\\star} = 1.5 \\times 10^{-4}$，\n$$\n-\\ln(0.05) \\approx 2.99573227355,\n$$\n所以\n$$\n\\frac{-\\ln(0.05)}{1.5 \\times 10^{-4}} \\approx \\frac{2.99573227355}{0.00015} \\approx 19971.54849.\n$$\n因此，最小整数样本量为\n$$\nn_{\\min} = 19972.\n$$\n这个 $n$ 确保了在观测到零个事件的情况下，$p$ 的单侧 95% 上界严格低于 $1.5 \\times 10^{-4}$，符合要求。", "answer": "$$\\boxed{19972}$$", "id": "4950477"}, {"introduction": "我们依赖的许多统计公式，包括样本量公式，都是基于“大样本”假设的渐近结果。但在有限的样本量下，这些公式的实际表现如何？这项计算练习将带您深入探究理论与现实之间的差距。您将通过编程来计算常用沃尔德（Wald）置信区间的实际覆盖概率，并亲自验证它在特定条件下可能远低于名义置信水平（例如 $0.95$）。这个过程不仅能揭示渐近理论的局限性，还将教您如何通过调整样本量来补偿这种覆盖不足，确保研究结果的可靠性。[@problem_id:4950528]", "problem": "您的任务是编写一个程序，该程序针对成功概率 $p$ 未知的伯努利过程，评估单个比例的瓦尔德（Wald）置信区间的有限样本覆盖率，然后确定一个调整后的样本量，以在指定的容差下补偿覆盖不足的情况。\n\n背景与定义：\n- 假设 $X_1, X_2, \\ldots, X_n$ 是独立同分布的伯努利随机变量，其成功概率为 $p \\in (0,1)$，因此 $S_n = \\sum_{i=1}^n X_i \\sim \\mathrm{Binomial}(n,p)$，样本比例为 $\\hat{p} = S_n / n$。\n- 对于给定的名义双侧置信水平 $1 - \\alpha$（其中 $\\alpha \\in (0,1)$），瓦尔德置信区间（未截断到 $[0,1]$ 区间）定义为\n$$\n\\left[\\, \\hat{p} - z_{1-\\alpha/2} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}},\\ \\hat{p} + z_{1-\\alpha/2} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}} \\,\\right],\n$$\n其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$ 分位数。\n- 对于给定的 $(n,p,\\alpha)$，实际覆盖概率是指，在 $S_n$ 服从 $\\mathrm{Binomial}(n,p)$ 分布的情况下，由观测到的 $\\hat{p}$ 构建的区间包含真实参数 $p$ 的概率。\n\n您的任务：\n1. 对于每个给定的测试用例 $(n,p,\\alpha,\\tau)$，计算实际覆盖概率 $C(n,p,\\alpha)$，其公式为\n$$\nC(n,p,\\alpha) \\equiv \\sum_{k=0}^{n} \\mathbf{1}\\!\\left\\{\\, p \\in \\left[\\, \\frac{k}{n} - z_{1-\\alpha/2} \\sqrt{\\frac{\\frac{k}{n}\\left(1-\\frac{k}{n}\\right)}{n}},\\ \\frac{k}{n} + z_{1-\\alpha/2} \\sqrt{\\frac{\\frac{k}{n}\\left(1-\\frac{k}{n}\\right)}{n}} \\,\\right] \\right\\} \\cdot \\Pr\\{S_n = k\\},\n$$\n其中 $\\Pr\\{S_n = k\\}$ 是在 $k$ 处求值的 $\\mathrm{Binomial}(n,p)$ 概率质量函数。请注意，当 $k \\in \\{0,n\\}$ 时，标准误项为 $0$，区间缩减为单点，因此只有当 $p$ 等于该端点时，覆盖指示函数才贡献 $1$。\n2. 对于每个测试用例，确定调整后的样本量 $n_{\\text{adj}}$，其定义为满足以下条件的最小整数 $n' \\ge n$：\n$$\nC(n',p,\\alpha) \\ge (1-\\alpha) - \\tau,\n$$\n其中 $\\tau \\in (0,1)$ 是为覆盖不足指定的一个非负容差。由于覆盖率作为 $n$ 的函数不一定是单调的，因此必须通过从给定的 $n$ 开始，对连续整数 $n', n'+1, \\ldots$ 进行搜索来获得 $n_{\\text{adj}}$，直到首次满足该不等式为止。\n\n要求：\n- 所有概率和比例必须以小数表示（例如，使用 $0.95$ 而不是 $95\\%$）。\n- 不涉及角度，因此不需要角度单位。\n- 程序必须精确实现上述定义，对 $S_n$ 使用 $\\mathrm{Binomial}(n,p)$ 分布，对 $z_{1-\\alpha/2}$ 使用标准正态分位数。\n- 对于每个测试用例，程序必须输出一个数对 $[c, n_{\\text{adj}}]$，其中 $c$ 是在给定 $n$ 下的实际覆盖率 $C(n,p,\\alpha)$（四舍五入到恰好 $6$ 位小数），$n_{\\text{adj}}$ 是一个整数。\n- 您的程序应生成单行输出，其中包含结果，格式为方括号括起来的、由逗号分隔的数对列表，例如 $[[c_1,n_{\\text{adj},1}],[c_2,n_{\\text{adj},2}],\\ldots]$。\n\n测试套件：\n使用以下五个测试用例，每个用例指定为一个元组 $(n,p,\\alpha,\\tau)$：\n- $(20, 0.5, 0.05, 0.01)$\n- $(30, 0.5, 0.05, 0.005)$\n- $(40, 0.05, 0.05, 0.005)$\n- $(100, 0.01, 0.05, 0.005)$\n- $(60, 0.3, 0.05, 0.0025)$", "solution": "问题陈述经评估有效。它在科学上基于既定的统计理论，定义和参数完整一致，问题提法得当，并以客观、正式的语言表述。这些任务在计算上是可行的，并且直接针对置信区间覆盖率和样本量调整的核心概念。\n\n对于每个给定的测试用例 $(n, p, \\alpha, \\tau)$，解决方案分为两个主要的计算任务：\n1.  计算二项比例的瓦尔德置信区间的实际覆盖概率 $C(n,p,\\alpha)$。\n2.  确定满足指定覆盖容差的调整后样本量 $n_{\\text{adj}}$。\n\n### 第 1 部分：计算实际覆盖概率 $C(n,p,\\alpha)$\n\n置信区间的实际覆盖概率是指随机区间包含其旨在估计的真实、固定参数的概率。对于二项过程，在大小为 $n$ 的样本中，成功次数 $S_n$ 服从二项分布，$S_n \\sim \\mathrm{Binomial}(n,p)$，其中 $p$ 是真实的成功概率。样本比例为 $\\hat{p} = S_n/n$。\n\n名义 $1-\\alpha$ 双侧瓦尔德置信区间由下式给出：\n$$ \\text{CI} = \\left[\\, \\hat{p} - z_{1-\\alpha/2} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}},\\ \\hat{p} + z_{1-\\alpha/2} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}} \\,\\right] $$\n其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$ 分位数。\n\n由于 $\\hat{p}$ 是一个离散随机变量（它只能取 $k/n$ 的值，其中 $k \\in \\{0, 1, \\ldots, n\\}$），覆盖概率不是一个连续函数，并且可能不等于名义水平 $1-\\alpha$。实际覆盖概率 $C(n,p,\\alpha)$ 是所有可能结果 $k$ 的概率之和，对于这些结果，所生成的置信区间包含了真实参数 $p$。\n\n在数学上，这表示为：\n$$ C(n,p,\\alpha) = \\sum_{k=0}^{n} \\Pr(S_n = k) \\cdot \\mathbf{1}\\{p \\in \\text{CI}_k\\} $$\n其中 $\\text{CI}_k$ 是假设 $S_n=k$（即 $\\hat{p}=k/n$）时构建的置信区间，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。概率质量函数（PMF）为 $\\Pr(S_n = k) = \\binom{n}{k} p^k (1-p)^{n-k}$。\n\n指示函数的条件 $p \\in \\text{CI}_k$ 可以写成不等式：\n$$ \\left| \\frac{k}{n} - p \\right| \\le z_{1-\\alpha/2} \\sqrt{\\frac{\\frac{k}{n}\\left(1-\\frac{k}{n}\\right)}{n}} $$\n对于从 $0$ 到 $n$ 的每个可能的成功次数 $k$，我们评估这个不等式。如果不等式成立，我们将概率 $\\Pr(S_n = k)$ 加到一个运行总和中。最终的和就是实际覆盖率 $C(n,p,\\alpha)$。\n\n当 $k=0$ 或 $k=n$ 时会出现一种特殊情况。在这些情况下，样本比例 $\\hat{p}$ 分别为 $0$ 或 $1$。$\\hat{p}(1-\\hat{p})$ 项变为 $0$，导致置信区间宽度为零：如果 $k=0$ 则为 $[0,0]$，如果 $k=n$ 则为 $[1,1]$。由于问题指定 $p \\in (0,1)$，真实比例 $p$ 不能等于 $0$ 或 $1$。因此，对于 $k=0$ 和 $k=n$，指示函数 $\\mathbf{1}\\{p \\in \\text{CI}_k\\}$ 总是 $0$，这些结果对覆盖概率没有贡献。\n\n### 第 2 部分：确定调整后的样本量 $n_{\\text{adj}}$\n\n瓦尔德区间的实际覆盖率通常低于名义水平，特别是当 $n$ 较小或 $p$ 接近 $0$ 或 $1$ 时。第二个任务是找到一个能减轻这种覆盖不足的样本量。\n\n给定一个容差 $\\tau \\ge 0$。目标是找到调整后的样本量 $n_{\\text{adj}}$，定义为最小的整数 $n' \\ge n$，使得在 $n'$ 处的实际覆盖率达到或超过一个略低于名义水平的目标值：\n$$ C(n', p, \\alpha) \\ge (1-\\alpha) - \\tau $$\n\n为了找到 $n_{\\text{adj}}$，我们采用顺序搜索算法：\n1.  将一个搜索变量（我们称之为 $n_{\\text{current}}$）初始化为测试用例中提供的初始样本量 $n$。\n2.  进入一个循环，直到满足条件为止。\n3.  在循环内部，使用第 1 部分中描述的方法计算实际覆盖概率 $C(n_{\\text{current}}, p, \\alpha)$。\n4.  检查是否 $C(n_{\\text{current}}, p, \\alpha) \\ge (1-\\alpha) - \\tau$。\n5.  如果条件满足，搜索完成。$n_{\\text{adj}}$ 的值就是 $n_{\\text{current}}$ 的当前值。\n6.  如果条件不满足，则将 $n_{\\text{current}}$ 增加 1，并从步骤 3 开始重复该过程。\n\n这个过程保证能找到在初始 $n$ 或之后满足所需覆盖容差的*第一个*整数样本量。这样一个 $n_{\\text{adj}}$ 的存在是由瓦尔德区间的渐近性质保证的，其覆盖率在 $n \\to \\infty$ 时收敛于 $1-\\alpha$。\n\n### 算法摘要\n对于每个测试用例元组 $(n, p, \\alpha, \\tau)$：\n1.  计算标准正态分位数 $z_{1-\\alpha/2}$。\n2.  通过对所有结果 $k \\in \\{0, \\dots, n\\}$（其中相应的瓦尔德区间包含 $p$）的二项概率求和，计算初始覆盖率 $c = C(n, p, \\alpha)$。\n3.  设置目标覆盖水平 $C_{\\text{target}} = (1-\\alpha) - \\tau$。\n4.  初始化 $n_{\\text{current}} = n$。\n5.  对于 $n_{\\text{current}} = n, n+1, n+2, \\ldots$，迭代计算 $C(n_{\\text{current}}, p, \\alpha)$，直到 $C(n_{\\text{current}}, p, \\alpha) \\ge C_{\\text{target}}$。满足此条件的第一个 $n_{\\text{current}}$ 值即为 $n_{\\text{adj}}$。\n6.  存储数对 $[c, n_{\\text{adj}}]$，其中 $c$ 四舍五入到 6 位小数。\n7.  处理完所有测试用例后，将收集到的结果格式化为指定的输出字符串。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm, binom\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating Wald interval coverage and adjusted sample size.\n    \"\"\"\n    \n    # Test cases defined as tuples (n, p, alpha, tau).\n    test_cases = [\n        (20, 0.5, 0.05, 0.01),\n        (30, 0.5, 0.05, 0.005),\n        (40, 0.05, 0.05, 0.005),\n        (100, 0.01, 0.05, 0.005),\n        (60, 0.3, 0.05, 0.0025)\n    ]\n\n    results = []\n\n    def calculate_coverage(n, p, alpha):\n        \"\"\"\n        Calculates the actual coverage probability C(n, p, alpha).\n\n        Args:\n            n (int): The sample size.\n            p (float): The true success probability.\n            alpha (float): The significance level.\n\n        Returns:\n            float: The actual coverage probability.\n        \"\"\"\n        # Calculate the (1 - alpha/2) quantile of the standard normal distribution\n        z = norm.ppf(1 - alpha / 2.0)\n        \n        # Possible number of successes k\n        k_vals = np.arange(n + 1)\n        \n        # Sample proportions for each k\n        p_hats = k_vals / n\n        \n        # Binomial probabilities for each k\n        pmf_vals = binom.pmf(k_vals, n, p)\n\n        # Standard error term for each p_hat.\n        # np.sqrt handles division by zero at n=0 gracefully if it were to occur,\n        # but k_vals/n with n>=1 is safe.\n        # The product p_hats * (1 - p_hats) is 0 for k=0 and k=n, resulting in a 0 margin of error.\n        with np.errstate(divide='ignore'):\n            # Suppress \"division by zero\" warning for n in denominator inside sqrt.\n            # This is safe because if n=0, k_vals is just [0], p_hats is nan,\n            # and sqrt(nan) is nan, but n>=1 in all valid cases.\n            standard_error = np.sqrt(p_hats * (1 - p_hats) / n)\n        \n        # Margin of error\n        margin_of_error = z * standard_error\n        \n        # Lower and upper bounds of the confidence intervals for each k\n        lower_bounds = p_hats - margin_of_error\n        upper_bounds = p_hats + margin_of_error\n        \n        # Indicator function: 1 if true p is in the interval, 0 otherwise\n        indicators = (p >= lower_bounds)  (p = upper_bounds)\n        \n        # Actual coverage is the sum of probabilities for which the interval covers p\n        coverage = np.sum(indicators * pmf_vals)\n        \n        return coverage\n\n    for n_initial, p, alpha, tau in test_cases:\n        # Task 1: Compute the actual coverage C(n, p, alpha)\n        initial_coverage = calculate_coverage(n_initial, p, alpha)\n\n        # Task 2: Determine the adjusted sample size n_adj\n        target_coverage = (1 - alpha) - tau\n        n_current = n_initial\n        \n        # Check if the initial n already meets the condition\n        if calculate_coverage(n_current, p, alpha) >= target_coverage:\n            n_adj = n_current\n        else:\n            # If not, search for the smallest n' >= n that does\n            while True:\n                n_current += 1\n                current_coverage = calculate_coverage(n_current, p, alpha)\n                if current_coverage >= target_coverage:\n                    n_adj = n_current\n                    break\n        \n        # Format the result for this test case\n        # Round the initial coverage to exactly 6 decimal places\n        result_pair = [round(initial_coverage, 6), n_adj]\n        results.append(result_pair)\n\n    # Format the final output string as per requirements\n    # e.g., [[c1,n_adj1],[c2,n_adj2],...]\n    final_output = f\"[{','.join(map(str, results))}]\"\n    print(final_output)\n\nsolve()\n```", "id": "4950528"}]}