{"hands_on_practices": [{"introduction": "卡方检验依赖于大样本近似，但如果我们的样本量很小，会发生什么呢？Fisher精确检验为我们提供了一种“精确”的$p$值计算方法，它基于超几何分布，不依赖于渐近理论。通过这个练习[@problem_id:4899807]，您将从第一性原理出发，深入理解列联表假设检验背后的组合逻辑，这对于卡方检验不适用的情况至关重要。", "problem": "一项随机生物统计学研究旨在调查抗病毒治疗与血清转化的发生是否独立。该研究将 $n_{T}=10$ 名参与者分配到治疗组，将 $n_{C}=6$ 名参与者分配到安慰剂组，总计 $N=16$ 名参与者。观察到的 $2 \\times 2$ 表显示，治疗组有 $a_{\\text{obs}}=5$ 例血清转化，安慰剂组有 $b_{\\text{obs}}=2$ 例血清转化，因此观察到的血清转化总数为 $K=a_{\\text{obs}}+b_{\\text{obs}}=7$，未发生血清转化的总数为 $N-K=9$。假设独立性（同质性）的原假设成立，即两个组的血清转化概率 $p$ 相同。\n\n从基本定义出发，以固定的行总计 $n_{T}$ 和 $n_{C}$ 以及固定的列总计 $K$ 和 $N-K$ 为条件。推导在给定边缘总计的情况下，治疗组血清转化数 $A$ 的条件分布，并为所有可行的 $a \\in \\{\\max(0, K-n_{C}), \\ldots, \\min(n_{T}, K)\\}$ 枚举其概率值。使用此枚举计算双边费舍尔精确检验（Fisher's Exact Test, FET）的 $p$ 值，其定义为所有条件概率小于或等于观察表的条件概率的表的概率之和，即 $\\sum_{a: \\mathbb{P}(A=a \\mid \\text{margins}) \\le \\mathbb{P}(A=a_{\\text{obs}} \\mid \\text{margins})} \\mathbb{P}(A=a \\mid \\text{margins})$。将最终的 $p$ 值表示为小数，并四舍五入到四位有效数字。", "solution": "设 $A$ 为代表治疗组血清转化数的随机变量，$B$ 为代表安慰剂组血清转化数的随机变量。各自的样本量为 $n_{T}=10$ 和 $n_{C}=6$，总共有 $N = n_{T} + n_{C} = 16$ 名参与者。\n\n在同质性的原假设（$H_0$）下，血清转化的概率（记为 $p$）在两个组中被假定为相同。因此，每个组中的血清转化数服从二项分布，因为每个参与者的结果是独立的试验。\n$$ A \\sim \\text{Binomial}(n_{T}, p) \\implies \\mathbb{P}(A=a) = \\binom{n_{T}}{a} p^{a} (1-p)^{n_{T}-a} $$\n$$ B \\sim \\text{Binomial}(n_{C}, p) \\implies \\mathbb{P}(B=b) = \\binom{n_{C}}{b} p^{b} (1-p)^{n_{C}-b} $$\n两个组是独立的，因此观察到治疗组中有 $a$ 个事件、安慰剂组中有 $b$ 个事件的联合概率是 $\\mathbb{P}(A=a, B=b) = \\mathbb{P}(A=a)\\mathbb{P}(B=b)$。\n\n费舍尔精确检验（FET）基于在列联表的边缘总计固定的条件下 $A$ 的分布。行总计（$n_{T}=10, n_{C}=6$）由研究设计固定。对于 FET，我们也以列总计为条件。观察数据为治疗组有 $a_{\\text{obs}}=5$ 个成功案例（血清转化），安慰剂组有 $b_{\\text{obs}}=2$ 个，导致总共有 $K = a_{\\text{obs}} + b_{\\text{obs}} = 5+2=7$ 个血清转化和 $N-K = 16-7=9$ 个非血清转化。\n\n我们推导条件概率 $\\mathbb{P}(A=a \\mid A+B=K)$。根据条件概率的定义：\n$$ \\mathbb{P}(A=a \\mid A+B=K) = \\frac{\\mathbb{P}(A=a \\text{ and } A+B=K)}{\\mathbb{P}(A+B=K)} $$\n分子中的事件等价于 $\\{A=a \\text{ and } B=K-a\\}$。由于独立性，其概率为：\n$$ \\mathbb{P}(A=a, B=K-a) = \\mathbb{P}(A=a)\\mathbb{P}(B=K-a) = \\left[ \\binom{n_{T}}{a}p^{a}(1-p)^{n_{T}-a} \\right] \\left[ \\binom{n_{C}}{K-a}p^{K-a}(1-p)^{n_{C}-(K-a)} \\right] $$\n$$ = \\binom{n_{T}}{a}\\binom{n_{C}}{K-a} p^{a+K-a} (1-p)^{n_{T}-a+n_{C}-K+a} = \\binom{n_{T}}{a}\\binom{n_{C}}{K-a} p^{K} (1-p)^{N-K} $$\n代表成功总数的随机变量 $A+B$ 服从二项分布 $\\text{Binomial}(N, p)$，所以条件事件的概率是：\n$$ \\mathbb{P}(A+B=K) = \\binom{N}{K} p^{K} (1-p)^{N-K} $$\n将这些代入条件概率公式，得到：\n$$ \\mathbb{P}(A=a \\mid A+B=K) = \\frac{\\binom{n_{T}}{a}\\binom{n_{C}}{K-a} p^{K} (1-p)^{N-K}}{\\binom{N}{K} p^{K} (1-p)^{N-K}} = \\frac{\\binom{n_{T}}{a}\\binom{n_{C}}{K-a}}{\\binom{N}{K}} $$\n这是超几何分布的概率质量函数。未知参数 $p$ 已被消去，这是允许进行“精确”检验的关键特性。\n\n接下来，我们使用给定数据 $n_{T}=10$，$n_{C}=6$，$N=16$ 和 $K=7$ 来枚举所有可行 $a$ 值的概率。$a$ 的可能值由二项式系数的约束决定，这要求所有参数都为非负数：\n$a \\ge 0$, $n_{T}-a \\ge 0 \\implies a \\le n_{T}=10$。\n$K-a \\ge 0 \\implies a \\le K=7$。\n$n_{C}-(K-a) \\ge 0 \\implies a \\ge K-n_{C} = 7-6=1$。\n因此，$a$ 的支撑集是 $\\{1, 2, 3, 4, 5, 6, 7\\}$，这与指定的范围 $[\\max(0, K-n_C), \\min(n_T, K)]$ 相匹配。\n\n概率质量函数的分母是从 $N=16$ 名参与者中选择 $K=7$ 名血清转化者的总方式数：\n$$ \\binom{N}{K} = \\binom{16}{7} = \\frac{16!}{7!9!} = 11440 $$\n我们现在计算每个可行的 $a$ 值的概率：\n$$ \\mathbb{P}(A=a) = \\frac{\\binom{10}{a}\\binom{6}{7-a}}{11440} $$\n对于 $a=1$：$\\mathbb{P}(A=1) = \\frac{\\binom{10}{1}\\binom{6}{6}}{11440} = \\frac{10 \\times 1}{11440} = \\frac{10}{11440}$\n对于 $a=2$：$\\mathbb{P}(A=2) = \\frac{\\binom{10}{2}\\binom{6}{5}}{11440} = \\frac{45 \\times 6}{11440} = \\frac{270}{11440}$\n对于 $a=3$：$\\mathbb{P}(A=3) = \\frac{\\binom{10}{3}\\binom{6}{4}}{11440} = \\frac{120 \\times 15}{11440} = \\frac{1800}{11440}$\n对于 $a=4$：$\\mathbb{P}(A=4) = \\frac{\\binom{10}{4}\\binom{6}{3}}{11440} = \\frac{210 \\times 20}{11440} = \\frac{4200}{11440}$\n对于 $a=5$：$\\mathbb{P}(A=5) = \\frac{\\binom{10}{5}\\binom{6}{2}}{11440} = \\frac{252 \\times 15}{11440} = \\frac{3780}{11440}$\n对于 $a=6$：$\\mathbb{P}(A=6) = \\frac{\\binom{10}{6}\\binom{6}{1}}{11440} = \\frac{210 \\times 6}{11440} = \\frac{1260}{11440}$\n对于 $a=7$：$\\mathbb{P}(A=7) = \\frac{\\binom{10}{7}\\binom{6}{0}}{11440} = \\frac{120 \\times 1}{11440} = \\frac{120}{11440}$\n\n最后，我们计算双边 FET 的 $p$ 值。观察值为 $a_{\\text{obs}}=5$。此观察值的概率为 $\\mathbb{P}(A=5) = \\frac{3780}{11440}$。$p$ 值定义为所有条件概率小于或等于观察表的条件概率的表的概率之和。\n$$ p\\text{-value} = \\sum_{a: \\mathbb{P}(A=a) \\le \\mathbb{P}(A=a_{\\text{obs}})} \\mathbb{P}(A=a) $$\n我们将每个概率与 $\\mathbb{P}(A=5) = \\frac{3780}{11440}$进行比较。\n$\\mathbb{P}(A=1) = \\frac{10}{11440} \\le \\frac{3780}{11440}$ (真)\n$\\mathbb{P}(A=2) = \\frac{270}{11440} \\le \\frac{3780}{11440}$ (真)\n$\\mathbb{P}(A=3) = \\frac{1800}{11440} \\le \\frac{3780}{11440}$ (真)\n$\\mathbb{P}(A=4) = \\frac{4200}{11440}  \\frac{3780}{11440}$ (假)\n$\\mathbb{P}(A=5) = \\frac{3780}{11440} \\le \\frac{3780}{11440}$ (真)\n$\\mathbb{P}(A=6) = \\frac{1260}{11440} \\le \\frac{3780}{11440}$ (真)\n$\\mathbb{P}(A=7) = \\frac{120}{11440} \\le \\frac{3780}{11440}$ (真)\np值是 $a \\in \\{1, 2, 3, 5, 6, 7\\}$ 的概率之和：\n$$ p\\text{-value} = \\mathbb{P}(A=1) + \\mathbb{P}(A=2) + \\mathbb{P}(A=3) + \\mathbb{P}(A=5) + \\mathbb{P}(A=6) + \\mathbb{P}(A=7) $$\n$$ p\\text{-value} = \\frac{10+270+1800+3780+1260+120}{11440} = \\frac{7240}{11440} $$\n将此分数转换为小数：\n$$ p\\text{-value} = \\frac{7240}{11440} \\approx 0.63286713... $$\n四舍五入到四位有效数字，我们得到 $0.6329$。", "answer": "$$\n\\boxed{0.6329}\n$$", "id": "4899807"}, {"introduction": "真实世界的数据收集常常受到各种限制，导致列联表中出现“结构性零点”，即某些单元格的计数在理论上就不可能发生。在这种情况下，标准的独立性模型不再适用，我们需要引入“拟独立”的概念，并使用迭代比例拟合（IPF）算法来分析其余单元格中的关联性。这项实践[@problem_id:4899809]将教您如何处理这种常见而重要的数据复杂性，从教科书式的理想案例迈向更符合现实的分析场景。", "problem": "一项生物统计学研究考察了疾病状态与暴露类别之间的关联。该研究采用了一项设计的观察性方案，禁止将已患病个体纳入最高暴露类别。这种设计导致列联表中对应于患病和最高暴露的单元格出现一个结构性零点。研究人员记录了如下的观测计数、行总计和列总计的表格：疾病状态行 $i \\in \\{1,2\\}$ 分别为患病 ($i=1$) 和未患病 ($i=2$)，暴露列 $j \\in \\{1,2,3\\}$ 分别为低 ($j=1$)、中 ($j=2$) 和高 ($j=3$)，在单元格 $(i,j)=(1,3)$ 处有一个结构性零点：\n$$\nO=\\begin{pmatrix}\n12  18  0 \\\\\n28  22  20\n\\end{pmatrix},\\quad\n\\text{row totals } R=\\begin{pmatrix}30 \\\\ 70\\end{pmatrix},\\quad\n\\text{column totals } C=\\begin{pmatrix}40 \\\\ 40 \\\\ 20\\end{pmatrix},\\quad\nN=100.\n$$\n假设在容许支持集（除结构性零点外的所有单元格）上服从拟独立模型，并将计数视为在固定边际的多项抽样方案下产生。从第一性原理出发，使用独立对数线性结构和最大似然法来证明二维表的迭代比例拟合 (IPF) 程序的合理性，并解释如何纳入结构性零点约束，以使单元格 $(1,3)$ 在每次更新中都保持为零。IPF 以所有容许单元格的初始期望计数 $m_{ij}^{(0)}=1$ 和结构性零点的初始期望计数 $m_{13}^{(0)}=0$ 开始，然后执行一个完整的行缩放步骤，再执行一个完整的列缩放步骤，并明确展示结构性约束是如何被保持的。接下来，通过求解在固定边际和结构性零点约束下容许单元格的乘法系统，推导IPF迭代的解析极限，并给出所有单元格的拟合期望计数。最后，计算拟独立的皮尔逊卡方统计量，\n$$\nX^{2}=\\sum_{\\text{admissible }(i,j)}\\frac{\\left(O_{ij}-E_{ij}\\right)^{2}}{E_{ij}},\n$$\n其中 $E_{ij}$ 是您获得的拟合期望计数，求和不包括结构性零点单元格。将您的最终数值答案四舍五入到四位有效数字。", "solution": "**迭代比例拟合 (IPF) 程序的合理性证明**\n\n设 $m_{ij}$ 为单元格 $(i,j)$ 中的期望计数。拟独立模型指出，对于容许单元格集合 $S$（除在 $(1,3)$ 处的结构性零点外的所有单元格），期望计数遵循独立模型的结构。这可以以乘法形式表示为 $m_{ij} = \\alpha_i \\beta_j$ 对于 $(i,j) \\in S$，或等价的对数线性形式：\n$$ \\log(m_{ij}) = \\lambda + \\lambda_i^R + \\lambda_j^C \\quad \\text{for } (i,j) \\in S $$\n其中 $\\lambda$ 是总体效应，$\\lambda_i^R$ 是行 $i$ 的效应，$\\lambda_j^C$ 是列 $j$ 的效应。对于结构性零点，我们有约束 $m_{13}=0$。\n\n在多项抽样假设下，观测计数 $O_{ij}$ 的对数似然函数（忽略常数）为：\n$$ \\ell(\\{m_{ij}\\}) = \\sum_{(i,j) \\in S} O_{ij} \\log(m_{ij}) $$\n在对数线性模型结构和由固定边际（它们是模型参数的充分统计量）施加的约束条件下最大化此对数似然函数，会得到一组似然方程。这些方程表明，期望的边际总计必须等于观测的边际总计：\n$$ \\sum_{j} \\hat{m}_{ij} = \\sum_{j} O_{ij} = R_i \\quad \\text{for } i=1,2 $$\n$$ \\sum_{i} \\hat{m}_{ij} = \\sum_{i} O_{ij} = C_j \\quad \\text{for } j=1,2,3 $$\n其中 $\\hat{m}_{ij}$ 是期望计数的最大似然估计 (MLEs)，并且我们强制 $\\hat{m}_{13}=0$。\n\nIPF 程序是用于找到这些最大似然估计 $\\hat{m}_{ij}$ 的一种算法。它不直接求解 $\\lambda$ 参数，而是找到满足模型乘法形式和边际约束的单元格计数。从符合模型的初始估计集 $m_{ij}^{(0)}$（例如，对于容许单元格 $m_{ij}^{(0)}=1$）开始，IPF 迭代地调整计数以匹配行和列的边际。一个完整的迭代包括一个行缩放步骤和一个列缩放步骤：\n$$ m_{ij}^{(k+1/2)} = m_{ij}^{(k)} \\frac{R_i}{\\sum_{l} m_{il}^{(k)}} $$\n$$ m_{ij}^{(k+1)} = m_{ij}^{(k+1/2)} \\frac{C_j}{\\sum_{k} m_{kj}^{(k+1/2)}} $$\n此过程保证收敛到唯一的最大似然估计 $\\hat{m}_{ij}$。\n\n**纳入结构性零点约束**\n\n结构性零点约束 $m_{13}=0$ 在整个IPF程序中都得以保持，方法是将其初始值设为零，即 $m_{13}^{(0)}=0$。更新步骤是乘法性的。\n在行 $i=1$ 的行缩放步骤中：\n$$ m_{13}^{(k+1/2)} = m_{13}^{(k)} \\frac{R_1}{\\sum_{l} m_{1l}^{(k)}} = 0 \\times (\\text{scaling factor}) = 0 $$\n在列 $j=3$ 的列缩放步骤中：\n$$ m_{13}^{(k+1)} = m_{13}^{(k+1/2)} \\frac{C_3}{\\sum_{k} m_{k3}^{(k+1/2)}} = 0 \\times (\\text{scaling factor}) = 0 $$\n因此，一旦一个单元格计数被设为零，它在所有后续迭代中都保持为零。分母中的求和是对给定行或列中的所有单元格进行的，但值为零的单元格对求和没有贡献。\n\n**一次完整的IPF迭代**\n\n初始计数为所有 $(i,j) \\in S$ 的 $m_{ij}^{(0)}=1$ 和 $m_{13}^{(0)}=0$。\n初始计数矩阵为 $M^{(0)} = \\begin{pmatrix} 1  1  0 \\\\ 1  1  1 \\end{pmatrix}$。\n观测边际为 $R=\\begin{pmatrix} 30 \\\\ 70 \\end{pmatrix}$ 和 $C=\\begin{pmatrix} 40 \\\\ 40 \\\\ 20 \\end{pmatrix}$。\n\n**1. 行缩放步骤：**\n初始行总计为 $R_1^{(0)} = 1+1+0=2$ 和 $R_2^{(0)}=1+1+1=3$。\n缩放因子为 $\\frac{R_1}{R_1^{(0)}} = \\frac{30}{2} = 15$ 和 $\\frac{R_2}{R_2^{(0)}} = \\frac{70}{3}$。\n将这些因子应用于 $M^{(0)}$ 的行：\n$m_{11}^{(0.5)} = 1 \\times 15 = 15$, $m_{12}^{(0.5)} = 1 \\times 15 = 15$, $m_{13}^{(0.5)} = 0 \\times 15 = 0$。\n$m_{21}^{(0.5)} = 1 \\times \\frac{70}{3} = \\frac{70}{3}$, $m_{22}^{(0.5)} = 1 \\times \\frac{70}{3} = \\frac{70}{3}$, $m_{23}^{(0.5)} = 1 \\times \\frac{70}{3} = \\frac{70}{3}$。\n行缩放后的矩阵为 $M^{(0.5)} = \\begin{pmatrix} 15  15  0 \\\\ \\frac{70}{3}  \\frac{70}{3}  \\frac{70}{3} \\end{pmatrix}$。\n\n**2. 列缩放步骤：**\n$M^{(0.5)}$ 的列总计为：\n$C_1^{(0.5)} = 15 + \\frac{70}{3} = \\frac{45+70}{3} = \\frac{115}{3}$。\n$C_2^{(0.5)} = 15 + \\frac{70}{3} = \\frac{115}{3}$。\n$C_3^{(0.5)} = 0 + \\frac{70}{3} = \\frac{70}{3}$。\n缩放因子为 $\\frac{C_1}{C_1^{(0.5)}} = \\frac{40}{115/3} = \\frac{120}{115} = \\frac{24}{23}$，$\\frac{C_2}{C_2^{(0.5)}} = \\frac{40}{115/3} = \\frac{24}{23}$，以及 $\\frac{C_3}{C_3^{(0.5)}} = \\frac{20}{70/3} = \\frac{60}{70} = \\frac{6}{7}$。\n将这些因子应用于 $M^{(0.5)}$ 的列：\n$m_{11}^{(1)} = 15 \\times \\frac{24}{23} = \\frac{360}{23}$。\n$m_{21}^{(1)} = \\frac{70}{3} \\times \\frac{24}{23} = 70 \\times \\frac{8}{23} = \\frac{560}{23}$。\n$m_{12}^{(1)} = 15 \\times \\frac{24}{23} = \\frac{360}{23}$。\n$m_{22}^{(1)} = \\frac{70}{3} \\times \\frac{24}{23} = \\frac{560}{23}$。\n$m_{13}^{(1)} = 0 \\times \\frac{6}{7} = 0$。\n$m_{23}^{(1)} = \\frac{70}{3} \\times \\frac{6}{7} = \\frac{10 \\times 6}{3} = 20$。\n一次完整迭代后的矩阵为 $M^{(1)} = \\begin{pmatrix} \\frac{360}{23}  \\frac{360}{23}  0 \\\\ \\frac{560}{23}  \\frac{560}{23}  20 \\end{pmatrix}$。\n\n**IPF的解析极限（拟合期望计数）**\n\n设 $E_{ij}$ 为拟合期望计数（IPF程序的极限）。它们必须满足边际约束和拟独立条件。\n边际约束是：\n1.  $E_{11} + E_{12} + E_{13} = 30$。因为 $E_{13}=0$，所以 $E_{11} + E_{12} = 30$。\n2.  $E_{21} + E_{22} + E_{23} = 70$。\n3.  $E_{11} + E_{21} = 40$。\n4.  $E_{12} + E_{22} = 40$。\n5.  $E_{13} + E_{23} = 20$。因为 $E_{13}=0$，所以 $E_{23}=20$。\n\n拟独立条件适用于容许单元格的任何 $2 \\times 2$ 子表。唯一这样的子表是由行1,2和列1,2形成的。这意味着比值比为1：\n$$ \\frac{E_{11} E_{22}}{E_{12} E_{21}} = 1 \\implies E_{11} E_{22} = E_{12} E_{21} $$\n我们现在求解这个方程组。\n从(5)式，我们有 $E_{23}=20$。代入(2)式得到 $E_{21} + E_{22} = 50$。\n让我们用 $E_{11}$ 表示 $E_{12}$、$E_{21}$ 和 $E_{22}$：\n从(1)式：$E_{12} = 30 - E_{11}$。\n从(3)式：$E_{21} = 40 - E_{11}$。\n从 $E_{21} + E_{22} = 50$：$E_{22} = 50 - E_{21} = 50 - (40 - E_{11}) = 10 + E_{11}$。\n现在将这些代入拟独立方程：\n$$ E_{11} (10 + E_{11}) = (30 - E_{11})(40 - E_{11}) $$\n$$ 10 E_{11} + E_{11}^2 = 1200 - 40 E_{11} - 30 E_{11} + E_{11}^2 $$\n$$ 10 E_{11} = 1200 - 70 E_{11} $$\n$$ 80 E_{11} = 1200 $$\n$$ E_{11} = \\frac{1200}{80} = 15 $$\n现在我们求出剩余的值：\n$E_{12} = 30 - 15 = 15$。\n$E_{21} = 40 - 15 = 25$。\n$E_{22} = 10 + 15 = 25$。\n拟合期望计数为：\n$$ E = \\begin{pmatrix} 15  15  0 \\\\ 25  25  20 \\end{pmatrix} $$\n\n**拟独立的皮尔逊卡方统计量**\n\n该统计量是通过对所有容许单元格的观测计数与期望计数之差的平方除以期望计数进行求和来计算的。\n$$ X^{2}=\\sum_{(i,j) \\in S}\\frac{\\left(O_{ij}-E_{ij}\\right)^{2}}{E_{ij}} $$\n观测计数为 $O=\\begin{pmatrix} 12  18  0 \\\\ 28  22  20 \\end{pmatrix}$。\n容许单元格为 $(1,1), (1,2), (2,1), (2,2), (2,3)$。\n$$ X^2 = \\frac{(O_{11}-E_{11})^2}{E_{11}} + \\frac{(O_{12}-E_{12})^2}{E_{12}} + \\frac{(O_{21}-E_{21})^2}{E_{21}} + \\frac{(O_{22}-E_{22})^2}{E_{22}} + \\frac{(O_{23}-E_{23})^2}{E_{23}} $$\n$$ X^2 = \\frac{(12-15)^2}{15} + \\frac{(18-15)^2}{15} + \\frac{(28-25)^2}{25} + \\frac{(22-25)^2}{25} + \\frac{(20-20)^2}{20} $$\n$$ X^2 = \\frac{(-3)^2}{15} + \\frac{3^2}{15} + \\frac{3^2}{25} + \\frac{(-3)^2}{25} + \\frac{0^2}{20} $$\n$$ X^2 = \\frac{9}{15} + \\frac{9}{15} + \\frac{9}{25} + \\frac{9}{25} + 0 $$\n$$ X^2 = \\frac{18}{15} + \\frac{18}{25} $$\n$$ X^2 = \\frac{6}{5} + \\frac{18}{25} = 1.2 + 0.72 = 1.92 $$\n四舍五入到四位有效数字，值为 $1.920$。", "answer": "$$\\boxed{1.920}$$", "id": "4899809"}, {"introduction": "在开展一项研究之前，确定计划的样本量是否足以检测到一个有意义的效应是至关重要的，这被称为统计功效分析。我们可以通过在特定备择假设下模拟大量数据集，并观察我们的统计检验能多大比例地正确拒绝原假设，从而来估计统计功效。这个计算练习[@problem_id:4899810]将为您装备一项现代研究设计的关键技能，让您能够通过预估研究的成功概率来规划更有效的实验方案。", "problem": "一个生物统计学实验室正计划进行一项研究，使用基于 Pearson 卡方统计量的标准独立性检验来检测两个分类变量之间的关联。研究人员将通过模拟在指定的备择假设下估计统计功效，以此来规划样本量。你必须设计一个程序，该程序使用多项式抽样在给定的备择假设下模拟功效，并总结蒙特卡洛误差。\n\n使用的基本事实：\n- 对于一个 $r \\times c$ 列联表，在独立性原假设下，根据观测单元格计数和最大似然期望计数计算出的 Pearson 卡方统计量，在正则性条件和大样本量下，近似服从自由度为 $(r-1)(c-1)$ 的卡方分布。当计算出的 p 值小于 $\\alpha$ 时，一个在水平 $\\alpha$ 下的检验会拒绝原假设。\n- 在一个固定的备择分布下，其单元格概率 $p_{ij}$ 不能分解为行边际概率和列边际概率的乘积，大小为 $N$ 的独立同分布样本会生成一个随机的 $r \\times c$ 计数表，该表服从参数为 $N$ 和单元格概率为 $\\{p_{ij}\\}$ 的多项式分布。\n- 功效的蒙特卡洛估计量 $\\hat{\\pi}$ 是来自 $R$ 次独立模拟重复的拒绝指示变量的经验均值。根据独立伯努利随机变量的基本性质和中心极限定理，$\\mathbb{E}[\\hat{\\pi}] = \\pi$ 且 $\\mathrm{Var}(\\hat{\\pi}) = \\pi(1-\\pi)/R$，因此蒙特卡洛标准误的一个保守估计是 $\\sqrt{\\hat{\\pi}(1-\\hat{\\pi})/R}$，一个近似的双侧 $95\\%$ 置信区间半宽是 $z_{0.975}\\sqrt{\\hat{\\pi}(1-\\hat{\\pi})/R}$，其中 $z_{0.975}$ 是标准正态分位数。\n\n你的任务：\n- 对于下面的每个测试用例，从一个多项式分布中模拟 $R$ 个大小为 $N$ 的独立列联表，该分布使用指定的 $r \\times c$ 备择单元格概率矩阵 $\\{p_{ij}\\}$。\n- 对每个模拟的表，使用自由度为 $(r-1)(c-1)$ 的渐近卡方分布计算 p 值，从而进行标准的 Pearson 独立性卡方检验，以检验独立性原假设。\n- 将功效估计为 $\\hat{\\pi}$，即 p 值小于 $\\alpha$ 的模拟所占的比例。\n- 计算蒙特卡洛标准误 $\\sqrt{\\hat{\\pi}(1-\\hat{\\pi})/R}$ 和近似 $95\\%$ 置信区间半宽 $1.96 \\times \\sqrt{\\hat{\\pi}(1-\\hat{\\pi})/R}$。\n- 为了可复现性，使用固定的随机数生成器种子 $123456789$。如果每个用例需要不同的种子，你可以使用该种子的确定性偏移量（例如，加上用例索引）。\n- 在计算过程中稳健地处理任何零期望计数，使得期望计数为零的项对卡方统计量的贡献为 $0$。\n- 将每个报告的数值结果四舍五入到 $6$ 位小数。\n\n测试套件：\n- 用例 1（正常路径）：$r=3$，$c=3$，$\\alpha=0.05$，$N=400$，$R=20000$，且\n  \n$$\n  \\{p_{ij}\\}=\n  \\begin{bmatrix}\n  0.18  0.07  0.05\\\\\n  0.06  0.20  0.04\\\\\n  0.05  0.05  0.30\n  \\end{bmatrix}.\n  $$\n\n- 用例 2（小样本边界）：$r=2$，$c=3$，$\\alpha=0.05$，$N=50$，$R=15000$，且\n  \n$$\n  \\{p_{ij}\\}=\n  \\begin{bmatrix}\n  0.10  0.05  0.15\\\\\n  0.20  0.10  0.40\n  \\end{bmatrix}.\n  $$\n\n- 用例 3（边际不平衡的边缘情况）：$r=4$，$c=2$，$\\alpha=0.05$，$N=300$，$R=20000$，且\n  \n$$\n  \\{p_{ij}\\}=\n  \\begin{bmatrix}\n  0.08  0.02\\\\\n  0.03  0.17\\\\\n  0.15  0.05\\\\\n  0.40  0.10\n  \\end{bmatrix}.\n  $$\n\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含用例 1、用例 2、用例 3 的结果：估计的功效 $\\hat{\\pi}$、蒙特卡洛标准误和 $95\\%$ 置信区间半宽。因此，输出将有 9 个四舍五入到 6 位小数的浮点数，顺序为 $[\\hat{\\pi}_1,\\mathrm{se}_1,\\mathrm{hw}_1,\\hat{\\pi}_2,\\mathrm{se}_2,\\mathrm{hw}_2,\\hat{\\pi}_3,\\mathrm{se}_3,\\mathrm{hw}_3]$。", "solution": "### 基于原理的解决方案设计\n\n目标是通过蒙特卡洛模拟，为指定的备择假设估计 Pearson 独立性卡方检验的统计功效。功效是在某个特定的备择假设为真时，正确拒绝原假设的概率。\n\n#### 1. 理论框架：Pearson 卡方检验\n\nPearson 卡方检验用于评估两个分类变量之间是否存在统计上显著的关联。数据被总结在一个 $r \\times c$ 的列联表中，其中 $r$ 是行变量的类别数，$c$ 是列变量的类别数。\n\n- **假设**：原假设 $H_0$ 指出两个变量是独立的。这意味着观测值落入单元格 $(i, j)$ 的联合概率 $p_{ij}$ 是边际概率的乘积：$p_{ij} = p_{i \\cdot} \\times p_{\\cdot j}$，其中 $p_{i \\cdot} = \\sum_j p_{ij}$ 且 $p_{\\cdot j} = \\sum_i p_{ij}$。备择假设 $H_1$ 是变量不独立。\n\n- **检验统计量**：检验统计量是根据观测计数 $O_{ij}$ 和原假设下的期望计数 $E_{ij}$ 计算得出的。该统计量由下式给出：\n$$\n\\chi^2 = \\sum_{i=1}^{r} \\sum_{j=1}^{c} \\frac{(O_{ij} - E_{ij})^2}{E_{ij}}\n$$\n期望计数 $E_{ij}$ 是通过将行和列的边际总和相乘后除以总样本量 $N$ 来从数据中估计的：\n$$\nE_{ij} = \\frac{(\\sum_{k=1}^{c} O_{ik}) (\\sum_{l=1}^{r} O_{lj})}{N}\n$$\n如果期望计数 $E_{ij}$ 为零，则其在总和中对应的项为 $0$。\n\n- **零分布和决策规则**：在 $H_0$ 下，对于足够大的样本量 $N$，$\\chi^2$ 统计量近似服从自由度为 $(r-1)(c-1)$ 的卡方分布。p 值的计算方式为：假设 $H_0$ 为真，观测到一个与已计算出的检验统计量一样极端或更极端的检验统计量的概率。如果在显著性水平 $\\alpha$ 下，p 值小于 $\\alpha$，则拒绝原假设。\n\n#### 2. 用于功效估计的蒙特卡洛模拟\n\n由于在特定备择分布 $\\{p_{ij}\\}$ 下对功效进行解析计算是复杂的，我们使用蒙特卡洛模拟。功效 $\\pi$ 定义为 $\\pi = P(\\text{拒绝 } H_0 | H_1 \\text{ 为真})$。\n\n模拟过程分三个阶段展开：\n\n**阶段 1：数据生成**\n我们给定一个特定的备择假设，由单元格概率矩阵 $\\{p_{ij}\\}$ 定义，其中 $\\sum_{i,j} p_{ij} = 1$。我们模拟大量的（$R$ 次）独立实验。在每次实验中，我们通过从参数为 $N$ 和扁平化概率向量 $\\{p_{ij}\\}$ 的多项式分布中抽样，来生成一个大小为 $N$ 的随机列联表。\n\n**阶段 2：假设检验**\n每个模拟的列联表都被视为一个观测数据集。对于 $R$ 个表中的每一个，我们都如上所述执行 Pearson 独立性卡方检验。这包括基于渐近 $\\chi^2_{(r-1)(c-1)}$ 分布计算检验统计量及其对应的 p 值。\n\n**阶段 3：功效估计**\n统计功效被估计为原假设被拒绝的模拟重复所占的比例。设 $I_k$ 是一个指示变量，如果第 $k$ 个模拟表的 p 值小于 $\\alpha$，则 $I_k=1$，否则为 $0$。功效的蒙特卡洛估计量 $\\hat{\\pi}$ 是这些指示变量的均值：\n$$\n\\hat{\\pi} = \\frac{1}{R} \\sum_{k=1}^{R} I_k\n$$\n\n#### 3. 量化蒙特卡洛误差\n\n估计量 $\\hat{\\pi}$ 本身是一个随机量，其精度取决于重复次数 $R$。每次重复都是一次成功概率为 $\\pi$ 的伯努利试验。在 $R$ 次试验中拒绝的总次数服从二项分布 $\\text{Bin}(R, \\pi)$。\n\n- **标准误**：功效估计量的方差为 $\\mathrm{Var}(\\hat{\\pi}) = \\frac{\\pi(1-\\pi)}{R}$。蒙特卡洛标准误（MCSE）是该估计量的标准差，我们通过用 $\\hat{\\pi}$ 替代 $\\pi$ 来估计它：\n$$\n\\text{MCSE}(\\hat{\\pi}) = \\sqrt{\\frac{\\hat{\\pi}(1-\\hat{\\pi})}{R}}\n$$\n这个量度量了我们蒙特卡洛估计的典型误差。\n\n- **置信区间**：根据中心极限定理，对于大的 $R$，$\\hat{\\pi}$ 的分布近似为正态分布。真实功效 $\\pi$ 的一个近似双侧 $95\\%$ 置信区间由下式给出：\n$$\n\\hat{\\pi} \\pm z_{0.975} \\times \\text{MCSE}(\\hat{\\pi})\n$$\n其中 $z_{0.975} \\approx 1.96$ 是标准正态分布的 $0.975$ 分位数。该区间的半宽 $1.96 \\times \\text{MCSE}(\\hat{\\pi})$ 为我们的功效估计提供了不确定性的度量。\n\n#### 4. 实现细节\n```python\nimport numpy as np\nfrom scipy.stats import chi2_contingency\n\ndef solve():\n    \"\"\"\n    Simulates the power of the Pearson's chi-squared test of independence\n    for several test cases and reports the estimated power, Monte Carlo\n    standard error, and 95% confidence interval half-width.\n    \"\"\"\n    test_cases = [\n        {\n            \"r\": 3, \"c\": 3, \"alpha\": 0.05, \"N\": 400, \"R\": 20000,\n            \"p_matrix\": np.array([\n                [0.18, 0.07, 0.05],\n                [0.06, 0.20, 0.04],\n                [0.05, 0.05, 0.30]\n            ]),\n            \"case_index\": 0\n        },\n        {\n            \"r\": 2, \"c\": 3, \"alpha\": 0.05, \"N\": 50, \"R\": 15000,\n            \"p_matrix\": np.array([\n                [0.10, 0.05, 0.15],\n                [0.20, 0.10, 0.40]\n            ]),\n            \"case_index\": 1\n        },\n        {\n            \"r\": 4, \"c\": 2, \"alpha\": 0.05, \"N\": 300, \"R\": 20000,\n            \"p_matrix\": np.array([\n                [0.08, 0.02],\n                [0.03, 0.17],\n                [0.15, 0.05],\n                [0.40, 0.10]\n            ]),\n            \"case_index\": 2\n        }\n    ]\n\n    base_seed = 123456789\n    all_results = []\n    z_975 = 1.96\n\n    for case in test_cases:\n        r = case[\"r\"]\n        c = case[\"c\"]\n        alpha = case[\"alpha\"]\n        N = case[\"N\"]\n        R = case[\"R\"]\n        p_matrix = case[\"p_matrix\"]\n        case_index = case[\"case_index\"]\n\n        # Use a deterministic seed for each case for reproducibility\n        rng = np.random.default_rng(base_seed + case_index)\n        \n        # Flatten the probability matrix for multinomial sampling\n        p_flat = p_matrix.flatten()\n\n        # Generate R samples from the multinomial distribution.\n        # Each row of the output is a flattened contingency table.\n        simulated_counts = rng.multinomial(n=N, pvals=p_flat, size=R)\n        \n        rejection_count = 0\n        for i in range(R):\n            # Reshape the flattened counts into an r x c table\n            observed_table = simulated_counts[i].reshape((r, c))\n            \n            # chi2_contingency handles tables with zero-sum rows/columns robustly.\n            # A ValueError can be raised for degenerate tables, which we can safely ignore\n            # as they would not lead to a rejection of the null hypothesis.\n            try:\n                # Perform a Pearson's chi-squared test of independence (correction=False)\n                _, p_value, _, _ = chi2_contingency(observed_table, correction=False)\n\n                if p_value  alpha:\n                    rejection_count += 1\n            except ValueError:\n                # This may occur for degenerate tables (e.g., all but one row/col sum to 0)\n                # scipy.stats.chi2_contingency handles most cases, but this is a safeguard.\n                # Such tables provide no evidence against independence.\n                pass\n        \n        # Estimate power\n        power_hat = rejection_count / R\n        \n        # Compute Monte Carlo standard error\n        # The variance is pi*(1-pi)/R. We plug in the estimate power_hat for pi.\n        mcse = np.sqrt(power_hat * (1 - power_hat) / R)\n        \n        # Compute 95% CI half-width\n        half_width = z_975 * mcse\n        \n        all_results.extend([\n            round(power_hat, 6), \n            round(mcse, 6), \n            round(half_width, 6)\n        ])\n    \n    # Return a string in the specified format, to be placed in the answer tag.\n    return f\"[{','.join(map(str, all_results))}]\"\n\n# The final answer is generated by this script.\n# print(solve())\n```\n该 Python 脚本实现了蒙特卡洛模拟来估计功效。运行此脚本会生成最终答案。", "answer": "[1.0,0.0,0.0,0.177067,0.00311,0.006096,0.9997,0.000122,0.000239]", "id": "4899810"}]}