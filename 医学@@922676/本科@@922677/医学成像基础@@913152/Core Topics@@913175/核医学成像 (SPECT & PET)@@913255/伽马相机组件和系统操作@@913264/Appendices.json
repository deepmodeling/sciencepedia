{"hands_on_practices": [{"introduction": "伽玛相机的核心功能之一是能量甄别，这依赖于它精确测量每个入射伽玛光子能量的能力。这种能量测量过程始于闪烁晶体，终于光电倍增管输出的电信号，其中每一步都伴随着固有的统计涨落。本练习将引导您从基本物理原理出发，计算探测器记录到的光电子数量，并进一步预测其能量分辨率，从而揭示决定伽玛相机区分散射线能力的关键因素。[@problem_id:4888105]", "problem": "一台基于铊激活碘化钠闪烁体 (NaI(Tl)) 和光电倍增管 (PMT) 的伽马相机，通过将闪烁光转换为电信号来测量入射伽马射线的能量。考虑一次能量为 $140\\ \\mathrm{keV}$ 的伽马射线相互作用，在晶体中产生了 $N_{ph}=5320$ 个闪烁光子。每个光子以 $0.80$ 的收集效率被传输到 PMT，如果它到达光电阴极，则有 $0.25$ 的量子效率产生一个光电子。PMT 的倍增过程会引入增益涨落，其特征是过剩噪声因子 $F=1.2$。\n\n从 (i) 将量子效率和收集效率定义为光子探测概率，(ii) 光电子计数的泊松统计，以及 (iii) 将能量分辨率定义为高斯响应的半峰全宽 (FWHM) 与均值之比出发，推导此次事件中探测到的光电子的期望数 $N_{pe}$ 和预测的相对能量分辨率 $R_E$。将 $R_E$ 表示为一个无量纲小数，并四舍五入到四位有效数字。以有序对 $\\left(N_{pe}, R_E\\right)$ 的形式给出最终答案。", "solution": "该问题要求推导在闪烁探测器中一次伽马射线相互作用后探测到的光电子的期望数 $\\bar{N}_{pe}$ 和相对能量分辨率 $R_E$。\n\n首先，我们确定光电子的期望数 $\\bar{N}_{pe}$。\n该过程始于一次伽马射线相互作用，产生了平均数量为 $\\bar{N}_{ph} = 5320$ 的闪烁光子。这些光子传播到光电倍增管 (PMT) 的光电阴极。问题指出，收集效率 $\\eta_c = 0.80$ 可以解释为给定光子到达光电阴极的概率。到达光电阴极后，每个光子有由量子效率 $\\eta_q = 0.25$ 给出的概率产生一个光电子。\n\n因此，单个闪烁光子成功产生一个光电子的总概率 $p$ 是这些独立概率的乘积：\n$$p = \\eta_c \\times \\eta_q$$\n由初始的 $\\bar{N}_{ph}$ 个光子产生的期望光电子数 $\\bar{N}_{pe}$ 由光子数与每个光子的转换概率的乘积给出：\n$$\\bar{N}_{pe} = \\bar{N}_{ph} \\times p = \\bar{N}_{ph} \\eta_c \\eta_q$$\n代入给定值：\n$$\\bar{N}_{pe} = 5320 \\times 0.80 \\times 0.25$$\n$$\\bar{N}_{pe} = 5320 \\times 0.20$$\n$$\\bar{N}_{pe} = 1064$$\n这是在光电阴极上产生的光电子的期望数。\n\n接下来，我们推导相对能量分辨率 $R_E$。\n能量分辨率定义为探测到的能量峰的半峰全宽 (FWHM) 与平均能量 $\\bar{E}$（或等效地，平均信号 $\\bar{S}$）之比：\n$$R_E = \\frac{\\text{FWHM}}{\\bar{S}}$$\n问题指明探测器响应是高斯分布。对于高斯分布，FWHM 与分布的标准差 $\\sigma_S$ 的关系为：\n$$\\text{FWHM} = 2\\sqrt{2\\ln 2} \\ \\sigma_S$$\n将此代入 $R_E$ 的定义中：\n$$R_E = 2\\sqrt{2\\ln 2} \\frac{\\sigma_S}{\\bar{S}}$$\n量 $\\frac{\\sigma_S}{\\bar{S}}$ 是输出信号的相对标准差。我们的任务是将其与探测器中的统计涨落联系起来。\n\n信号生成涉及两个主要的统计过程：光电子的产生及其在 PMT 中的后续倍增。\n1.  **光电子统计**：按照指示，我们将光电子的生成建模为泊松过程。对于平均光电子数 $\\bar{N}_{pe}$，方差为 $\\sigma_{N_{pe}}^2 = \\bar{N}_{pe}$。光电子的信噪比平方为 $(\\text{S/N})^2_{\\text{in}} = \\frac{\\bar{N}_{pe}^2}{\\sigma_{N_{pe}}^2} = \\frac{\\bar{N}_{pe}^2}{\\bar{N}_{pe}} = \\bar{N}_{pe}$。\n\n2.  **PMT 倍增**：PMT 中的倍增过程也是统计性的，并会引入额外的噪声。过剩噪声因子 $F$ 量化了这种信噪比的劣化。它定义为输入端（光电阴极）的信噪比平方与输出端（阳极）的信噪比平方之比：\n$$F = \\frac{(\\text{S/N})^2_{\\text{in}}}{(\\text{S/N})^2_{\\text{out}}}$$\n输出端的信噪比平方为 $(\\text{S/N})^2_{\\text{out}} = \\frac{\\bar{S}^2}{\\sigma_S^2}$。\n\n通过将输入和输出信噪比平方的表达式代入 $F$ 的定义，我们可以解出输出信号的相对方差：\n$$F = \\frac{\\bar{N}_{pe}}{\\bar{S}^2 / \\sigma_S^2} = \\bar{N}_{pe} \\left(\\frac{\\sigma_S}{\\bar{S}}\\right)^2$$\n重新整理这个方程得到：\n$$\\left(\\frac{\\sigma_S}{\\bar{S}}\\right)^2 = \\frac{F}{\\bar{N}_{pe}}$$\n因此，相对标准差为：\n$$\\frac{\\sigma_S}{\\bar{S}} = \\sqrt{\\frac{F}{\\bar{N}_{pe}}}$$\n现在，我们将此结果代回能量分辨率 $R_E$ 的表达式中：\n$$R_E = 2\\sqrt{2\\ln 2} \\sqrt{\\frac{F}{\\bar{N}_{pe}}}$$\n使用计算出的值 $\\bar{N}_{pe} = 1064$ 和给定的值 $F = 1.2$：\n$$R_E = 2\\sqrt{2\\ln 2} \\sqrt{\\frac{1.2}{1064}}$$\n$$R_E \\approx 2.35482 \\sqrt{0.0011278195...}$$\n$$R_E \\approx 2.35482 \\times 0.03358302...$$\n$$R_E \\approx 0.0790803...$$\n问题要求结果四舍五入到四位有效数字。\n$$R_E \\approx 0.07908$$\n\n最终答案是有序对 $(\\bar{N}_{pe}, R_E)$。\n计算出的值为 $\\bar{N}_{pe} = 1064$ 和 $R_E = 0.07908$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1064 & 0.07908\n\\end{pmatrix}\n}\n$$", "id": "4888105"}, {"introduction": "伽玛相机图像的清晰度直接取决于其空间分辨率，即区分两个邻近点源的能力。系统的总空间分辨率并非由单一因素决定，而是由探测器固有的分辨率和准直器几何分辨率共同作用的结果。本练习通过一个典型的场景，让您亲手实践如何将这两个独立的模糊分量进行正交合并，从而计算出最终的系统点扩散函数，加深对图像模糊来源的理解。[@problem_id:4888042]", "problem": "一台配备了平行孔准直器的伽玛相机，用于对距离准直器 $z=10\\ \\text{cm}$ 处的一个点源进行成像。该相机测得的固有单点扩散函数（PSF）可以很好地用一个标准差为 $\\sigma_{int}=1.5\\ \\text{mm}$ 的高斯函数来近似。在 $z=10\\ \\text{cm}$ 处测得的准直器模糊的半峰全宽（FWHM）为 $R_{col}=8\\ \\text{mm}$。假设系统是线性移不变的，并且固有模糊和准直器模糊是独立的且均为高斯分布，请从第一性原理出发，推导出在 $z=10\\ \\text{cm}$ 处预期的系统PSF宽度（以半峰全宽表示）。请用毫米作单位，并将最终答案四舍五入至四位有效数字。", "solution": "首先，我们将对问题陈述的科学合理性、完整性和客观性进行验证。\n\n**第一步：提取已知条件**\n- 成像系统：带有平行孔准直器的伽玛相机。\n- 源到准直器的距离：$z=10\\ \\text{cm}$。\n- 固有单点扩散函数（PSF）标准差：$\\sigma_{int}=1.5\\ \\text{mm}$。\n- 在指定距离 $z$ 处的准直器模糊半峰全宽（FWHM）：$R_{col}=8\\ \\text{mm}$。\n- 系统假设：\n    1. 系统是线性移不变（LSI）的。\n    2. 固有模糊和准直器模糊是独立过程。\n    3. 固有PSF和准直器PSF均为高斯形状。\n- 要求输出：系统PSF宽度，以毫米为单位的半峰全宽（FWHM）表示，并四舍五入至四位有效数字。\n\n**第二步：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估。\n- **科学依据：** 该问题牢固地植根于医学成像物理学的基本原理，特别是伽玛相机的分辨率理论。固有分辨率、准直器分辨率、单点扩散函数（PSF）、半峰全宽（FWHM）以及LSI系统模型等概念在该领域都是标准内容。假设高斯模糊分量是一种常见且有效的近似方法。\n- **适定性：** 该问题是适定的。它提供了确定唯一解所需的所有必要信息。给定的条件（$\\sigma_{int}$，$R_{col}$）足以计算系统分辨率（$FWHM_{sys}$）。距离 $z=10\\ \\text{cm}$ 正确地为给定的准直器模糊 $R_{col}$ 提供了背景，因为准直器分辨率是与距离相关的。通过提供在该特定距离下的 $R_{col}$，问题避免了根据准直器几何结构计算它的需要，从而使其自成体系。\n- **客观性：** 该问题以精确、客观的语言陈述。数据是定量的，假设是明确的。\n- **一致性与可行性：** 给定值对于临床伽玛相机而言在物理上是现实的。在10厘米距离处，固有标准差为$1.5\\ \\text{mm}$和准直器FWHM为$8\\ \\text{mm}$是典型值。不存在内部矛盾。\n\n**第三步：结论与行动**\n该问题被判定为**有效**，因为它科学合理、适定，且其所有组成部分都一致且定义清晰。现在将推导解答。\n\n**求解过程**\n对于一个LSI系统，其基本原理是整体系统响应是其独立分量响应的卷积。在这种情况下，系统单点扩散函数 $PSF_{sys}$ 是固有PSF $PSF_{int}$ 和准直器PSF $PSF_{col}$ 的卷积。\n$$PSF_{sys} = PSF_{int} * PSF_{col}$$\n其中 $*$ 表示卷积算子。\n\n问题陈述指出，$PSF_{int}$ 和 $PSF_{col}$ 都是高斯函数。高斯函数的一个关键性质是，两个高斯函数的卷积结果是另一个高斯函数。如果分量高斯函数的方差分别为 $\\sigma_1^2$ 和 $\\sigma_2^2$，那么卷积后得到的高斯函数的方差 $\\sigma_{sys}^2$ 将是各分量方差之和。\n$$\\sigma_{sys}^2 = \\sigma_{int}^2 + \\sigma_{col}^2$$\n这个关系是求解的基石。我们的目标是找到系统PSF的半峰全宽 $FWHM_{sys}$。为此，我们必须首先建立高斯分布的标准差 $\\sigma$ 与FWHM之间的关系。\n\n一个以原点为中心的一维高斯函数可以写成：\n$$G(x) = A \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)$$\n其中 $A$ 是最大振幅。FWHM是函数值为其最大值一半时两点 $x$ 之间的距离，即 $G(x) = A/2$。\n$$\\frac{A}{2} = A \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)$$\n两边同除以 $A$ 并取自然对数：\n$$\\ln\\left(\\frac{1}{2}\\right) = -\\frac{x^2}{2\\sigma^2}$$\n$$-\\ln(2) = -\\frac{x^2}{2\\sigma^2}$$\n$$x^2 = 2\\sigma^2\\ln(2)$$\n$$x = \\pm \\sigma \\sqrt{2\\ln(2)}$$\n这两个点是 $x_1 = -\\sigma\\sqrt{2\\ln(2)}$ 和 $x_2 = +\\sigma\\sqrt{2\\ln(2)}$。FWHM是这两点之差：\n$$FWHM = x_2 - x_1 = 2\\sigma\\sqrt{2\\ln(2)} = \\sigma\\sqrt{8\\ln(2)}$$\n这就给出了 $\\sigma$ 和 FWHM 之间的转换因子。将此关系式平方得到：\n$$FWHM^2 = \\sigma^2(8\\ln(2))$$\n这意味着 $\\sigma^2 = \\frac{FWHM^2}{8\\ln(2)}$。\n\n我们可以将此应用于我们的方差相加公式：\n$$\\sigma_{sys}^2 = \\sigma_{int}^2 + \\sigma_{col}^2$$\n将基于FWHM的表达式代入每个方差项：\n$$\\frac{FWHM_{sys}^2}{8\\ln(2)} = \\frac{FWHM_{int}^2}{8\\ln(2)} + \\frac{FWHM_{col}^2}{8\\ln(2)}$$\n将整个方程乘以 $8\\ln(2)$，得到一个组合高斯分量FWHM的简化关系式：\n$$FWHM_{sys}^2 = FWHM_{int}^2 + FWHM_{col}^2$$\n这表明，独立高斯模糊分量的FWHM以平方和的形式相加，得到系统FWHM的平方。\n\n现在，我们使用给定的值来计算 $FWHM_{sys}$。\n已知：\n- 准直器FWHM，$FWHM_{col} = R_{col} = 8\\ \\text{mm}$。\n- 固有标准差，$\\sigma_{int} = 1.5\\ \\text{mm}$。\n\n首先，我们必须根据其标准差计算固有FWHM，$FWHM_{int}$：\n$$FWHM_{int} = \\sigma_{int}\\sqrt{8\\ln(2)} = 1.5\\sqrt{8\\ln(2)}\\ \\text{mm}$$\n\n现在我们将已知的FWHM值代入平方和求和方程：\n$$FWHM_{sys}^2 = (1.5\\sqrt{8\\ln(2)})^2 + (8)^2$$\n$$FWHM_{sys}^2 = (1.5^2 \\cdot 8\\ln(2)) + 64$$\n$$FWHM_{sys}^2 = (2.25 \\cdot 8\\ln(2)) + 64$$\n$$FWHM_{sys}^2 = 18\\ln(2) + 64$$\n系统FWHM是该值的平方根：\n$$FWHM_{sys} = \\sqrt{18\\ln(2) + 64}$$\n为了得到数值结果，我们使用2的自然对数值，$\\ln(2) \\approx 0.693147$。\n$$FWHM_{sys} \\approx \\sqrt{18(0.693147) + 64}$$\n$$FWHM_{sys} \\approx \\sqrt{12.476646 + 64}$$\n$$FWHM_{sys} \\approx \\sqrt{76.476646}$$\n$$FWHM_{sys} \\approx 8.745092\\ \\text{mm}$$\n题目要求答案四舍五入到四位有效数字。\n$$FWHM_{sys} \\approx 8.745\\ \\text{mm}$$", "answer": "$$\\boxed{8.745}$$", "id": "4888042"}, {"introduction": "为了获得无伪影的诊断图像，伽玛相机必须在其整个有效视野内表现出高度一致的响应特性，即均匀性。通过分析在均匀辐射下采集的“泛场”图像，我们可以量化探测器的性能，这是日常质量控制的关键步骤。本练习将指导您计算两个核心的均匀性指标——积分均匀性和微分均匀性，以评估探测器的空间响应一致性，并理解其对单光子发射计算机断层成像（SPECT）图像质量的重要性。[@problem_id:4888122]", "problem": "伽马相机泛滥图像可以表示为一个非负测量计数的二维数组，记为 $I(i,j)$，其中 $i$ 为行索引，$j$ 为列索引。该图像是在近乎均匀的辐射下采集的，因此任何空间变化主要反映了系统的非均匀性。考虑有用视野（UFOV），在本问题中，它被定义为通过从原始图像的每个边缘沿两个轴排除 $m$ 个像素的边距而获得的中心子数组。设窗口长度为整数 $w \\geq 1$。任务是从第一性原理出发，计算两个无量纲的非均匀性度量：UFOV上的积分均匀性和使用滑动窗口极值计算的UFOV上的微分均匀性。然后，解释这些度量对于单光子发射计算机断层扫描（SPECT）的重要性。\n\n从均匀性度量必须是无量纲、有界且由测量计数的极值构建以量化最大分数偏差的正式定义出发，设计并实现一个算法，该算法：\n\n- 通过裁剪原始图像以从每个边界移除 $m$ 个像素来提取UFOV，生成子数组 $I_{\\mathrm{UFOV}}(i,j)$。\n- 仅使用UFOV内的全局最小值和最大值，计算积分均匀性作为最坏情况下的分数非均匀性。\n- 计算微分均匀性，作为在UFOV内水平和垂直方向上所有长度为 $w$ 的连续段上观察到的最坏情况下的分数非均匀性，其中每个段的度量由该段内的最小和最大计数构建，最终结果是所有这些段中的最大值。\n\n所有输出必须表示为小数（例如，$0.0175$），四舍五入到六位小数。不允许使用百分号。\n\n构建以下确定性测试套件。对于每个测试用例，给定整数 $N$，定义了图像尺寸 $N \\times N$、边距 $m$ 和窗口长度 $w$。图像条目由以下明确公式定义，以确保可复现的值。在每种情况下，UFOV都是通过从图像的所有侧面裁剪 $m$ 个像素获得的。\n\n- 测试用例1（边界条件：完全均匀场）：$N=10$, $m=1$, $w=5$，且对于所有 $0 \\le i,j  10$，有 $I(i,j) = 1000$。\n- 测试用例2（具有平滑空间变化的近均匀场）：$N=16$, $m=2$, $w=5$，且\n$$\nI(i,j) = 1000 + 20\\sin\\!\\left(\\frac{2\\pi i}{16}\\right) + 15\\cos\\!\\left(\\frac{2\\pi j}{16}\\right)\n$$\n对于所有 $0 \\le i,j  16$。\n- 测试用例3（UFOV内的单个热像素点）：$N=12$, $m=1$, $w=5$，且\n$$\nI(i,j) =\n\\begin{cases}\n1100,  \\text{if } i=6 \\text{ and } j=6,\\\\\n800,  \\text{otherwise},\n\\end{cases}\n$$\n对于所有 $0 \\le i,j  12$。\n- 测试用例4（UFOV恰好等于窗口大小，定向斜坡）：$N=7$, $m=1$, $w=5$，且\n$$\nI(i,j) = 1000 + 10j\n$$\n对于所有 $0 \\le i,j  7$。\n\n对于每个测试用例，计算两个浮点数：UFOV上的积分均匀性和UFOV上的微分均匀性，两者都表示为四舍五入到六位小数的小数。\n\n您的程序应生成单行输出，其中包含四个测试用例的结果，形式为逗号分隔的配对列表，并用方括号括起来。具体来说，输出格式必须是\n`[ [iu_1,du_1],[iu_2,du_2],[iu_3,du_3],[iu_4,du_4] ]`\n其中 $iu_k$ 和 $du_k$ 分别是测试用例 $k$ 的积分均匀性和微分均匀性，每个都四舍五入到六位小数，并表示为不带任何百分号的小数。", "solution": "该问题是有效的，因为它具有科学依据、定义明确且客观。它使用既定定义和确定性设置，解决了医学成像中的一个标准质量控制程序——特别是伽马相机均匀性的评估。\n\n**在SPECT中的重要性**\n\n在单光子发射计算机断层扫描（SPECT）中，伽马相机系统必须对均匀的伽马射线通量表现出高度均匀的响应。探测器灵敏度的任何非均匀性都可能在重建的断层图像中引入显著的伪影，例如同心环或“牛眼”图案。这些伪影可能会掩盖或模仿病理特征，从而损害研究的诊断准确性。积分均匀性和微分均匀性这两个度量标准为探测器性能提供了定量测量，确保其符合临床标准。积分均匀性评估大规模、缓慢变化的性能，而微分均匀性对突发的局部变化敏感，这些变化通常指示特定组件的故障（例如，光电倍增管故障）。\n\n**数学公式和算法设计**\n\n该问题要求精确实现有用视野（UFOV）、积分均匀性和微分均匀性的定义。\n\n**1. 有用视野 (UFOV)**\n\n原始图像是给定的一个 $N \\times N$ 计数矩阵 $I$。UFOV 是通过从所有四个边排除 $m$ 个像素的边距而获得的中心子数组 $I_{\\mathrm{UFOV}}$。如果 $I$ 的索引为 $(i,j)$，其中 $0 \\leq i, j  N$，那么 $I_{\\mathrm{UFOV}}$ 的索引对应于范围 $m \\leq i, j \\leq N-1-m$。得到的UFOV是一个 $(N-2m) \\times (N-2m)$ 的矩阵。\n\n**2. 积分均匀性 (IU)**\n\n积分均匀性量化了整个UFOV上计数的全局最坏情况偏差。它是一个无量纲度量，由UFOV内的全局最大值（$I_{\\max}$）和最小值（$I_{\\min}$）计数构建。满足问题形式化要求的标准公式是：\n\n$$\nIU = \\frac{I_{\\max} - I_{\\min}}{I_{\\max} + I_{\\min}}\n\\quad \\text{其中} \\quad\nI_{\\max} = \\max(I_{\\mathrm{UFOV}}) \\text{ 且 } I_{\\min} = \\min(I_{\\mathrm{UFOV}})\n$$\n\n如果所有计数均为零，则分母为零，均匀性定义为 $0$。由于计数是非负的，这是分母为零的唯一情况。\n\n**3. 微分均匀性 (DU)**\n\n微分均匀性测量最坏情况下的局部计数变化。它通过计算所有指定长度为 $w$ 的连续线性段上的均匀性，并取这些值的最大值来确定。扫描在UFOV的所有行和所有列上执行。\n\n设 $S$ 是从 $I_{\\mathrm{UFOV}}$ 的一行或一列中取出的任意一个长度为 $w$ 的段。该段的均匀性 $U_S$ 的计算方式与积分均匀性类似：\n\n$$\nU_S = \\frac{\\max(S) - \\min(S)}{\\max(S) + \\min(S)}\n$$\n\n微分均匀性 $DU$ 是在UFOV内所有可能的水平和垂直段中找到的 $U_S$ 的最大值：\n\n$$\nDU = \\max_{S \\in \\{\\text{all segments}\\}} U_S\n$$\n\n算法流程如下：\n1.  根据给定测试用例的指定公式，生成 $N \\times N$ 图像矩阵 $I$。\n2.  通过对原始矩阵 $I$ 进行切片，提取子矩阵 $I_{\\mathrm{UFOV}}$。这对应于 `I[m:N-m, m:N-m]`。\n3.  通过找到 $I_{\\mathrm{UFOV}}$ 的全局最大值和最小值并应用公式来计算 $IU$。\n4.  计算 $DU$：\n    a. 初始化一个变量 `max_local_uniformity` 为 $0$。\n    b. 遍历 $I_{\\mathrm{UFOV}}$ 的每一行。对于每一行，使用大小为 $w$ 的滑动窗口来提取所有水平段。对于每个段，计算其均匀性 $U_S$ 并更新 `max_local_uniformity = max(max_local_uniformity, U_S)`。\n    c. 遍历 $I_{\\mathrm{UFOV}}$ 的每一列。对于每一列，使用大小为 $w$ 的滑动窗口来提取所有垂直段。对于每个段，计算其均匀性 $U_S$ 并相应地更新 `max_local_uniformity`。\n5.  `max_local_uniformity` 的最终值就是微分均匀性 $DU$。\n6.  结果 $IU$ 和 $DU$ 四舍五入到六位小数。对所有测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the gamma camera uniformity problem for all test cases.\n    \"\"\"\n\n    def calculate_uniformity_metrics(I, m, w):\n        \"\"\"\n        Calculates integral and differential uniformity for a given image array.\n\n        Args:\n            I (np.ndarray): The N x N image of counts.\n            m (int): The margin in pixels to exclude for the UFOV.\n            w (int): The window length for differential uniformity.\n\n        Returns:\n            tuple: A tuple containing (integral_uniformity, differential_uniformity).\n        \"\"\"\n        N = I.shape[0]\n        ufov_dim = N - 2 * m\n        \n        # If the UFOV has a non-positive dimension, uniformity is undefined or trivial (0).\n        if ufov_dim = 0:\n            return 0.0, 0.0\n        \n        # 1. Extract the Useful Field of View (UFOV)\n        I_ufov = I[m : N - m, m : N - m]\n        \n        # 2. Compute Integral Uniformity (IU)\n        max_ufov = np.max(I_ufov)\n        min_ufov = np.min(I_ufov)\n        \n        denominator_iu = max_ufov + min_ufov\n        integral_uniformity = (max_ufov - min_ufov) / denominator_iu if denominator_iu > 0 else 0.0\n\n        # 3. Compute Differential Uniformity (DU)\n        max_local_uniformity = 0.0\n        \n        # The window length must not exceed the UFOV dimension.\n        if ufov_dim >= w:\n            # Horizontal sliding windows\n            for i in range(ufov_dim):\n                for j in range(ufov_dim - w + 1):\n                    segment = I_ufov[i, j : j + w]\n                    max_seg, min_seg = np.max(segment), np.min(segment)\n                    denominator_du = max_seg + min_seg\n                    if denominator_du > 0:\n                        local_uniformity = (max_seg - min_seg) / denominator_du\n                        if local_uniformity > max_local_uniformity:\n                            max_local_uniformity = local_uniformity\n\n            # Vertical sliding windows\n            for j in range(ufov_dim):\n                for i in range(ufov_dim - w + 1):\n                    segment = I_ufov[i : i + w, j]\n                    max_seg, min_seg = np.max(segment), np.min(segment)\n                    denominator_du = max_seg + min_seg\n                    if denominator_du > 0:\n                        local_uniformity = (max_seg - min_seg) / denominator_du\n                        if local_uniformity > max_local_uniformity:\n                            max_local_uniformity = local_uniformity\n        \n        differential_uniformity = max_local_uniformity\n        \n        return integral_uniformity, differential_uniformity\n\n    # Define test cases\n    test_cases_defs = [\n        {'N': 10, 'm': 1, 'w': 5},\n        {'N': 16, 'm': 2, 'w': 5},\n        {'N': 12, 'm': 1, 'w': 5},\n        {'N': 7, 'm': 1, 'w': 5}\n    ]\n\n    results = []\n    \n    # Test Case 1\n    case = test_cases_defs[0]\n    N = case['N']\n    image1 = np.full((N, N), 1000.0)\n    iu, du = calculate_uniformity_metrics(image1, case['m'], case['w'])\n    results.append([round(iu, 6), round(du, 6)])\n\n    # Test Case 2\n    case = test_cases_defs[1]\n    N = case['N']\n    i_indices = np.arange(N).reshape(N, 1)\n    j_indices = np.arange(N).reshape(1, N)\n    image2 = 1000 + 20 * np.sin(2 * np.pi * i_indices / N) + 15 * np.cos(2 * np.pi * j_indices / N)\n    iu, du = calculate_uniformity_metrics(image2, case['m'], case['w'])\n    results.append([round(iu, 6), round(du, 6)])\n\n    # Test Case 3\n    case = test_cases_defs[2]\n    N = case['N']\n    image3 = np.full((N, N), 800.0)\n    image3[6, 6] = 1100.0\n    iu, du = calculate_uniformity_metrics(image3, case['m'], case['w'])\n    results.append([round(iu, 6), round(du, 6)])\n\n    # Test Case 4\n    case = test_cases_defs[3]\n    N = case['N']\n    j_indices = np.arange(N).reshape(1, N)\n    image4 = 1000.0 + 10.0 * j_indices\n    # Broadcast to create a full N x N image where each row is identical.\n    image4 = np.broadcast_to(image4, (N, N))\n    iu, du = calculate_uniformity_metrics(image4, case['m'], case['w'])\n    results.append([round(iu, 6), round(du, 6)])\n\n    # Final print statement in the exact required format.\n    # The standard string representation of a list of lists in Python matches the output format.\n    print(str(results).replace(\"'\", '\"'))\n\nsolve()\n```", "id": "4888122"}]}