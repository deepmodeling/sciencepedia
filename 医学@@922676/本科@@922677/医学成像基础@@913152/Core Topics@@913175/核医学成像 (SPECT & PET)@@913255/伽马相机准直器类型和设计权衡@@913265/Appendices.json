{"hands_on_practices": [{"introduction": "本练习从系统性能分析中的一个基本问题入手 [@problem_id:4887750]。通过计算准直器的几何模糊等于探测器固有模糊的特定距离，您将具体理解这两个部分如何共同影响整体系统分辨率。这个练习对于领会为何在临床成像中最小化源与准直器间距是一项关键原则至关重要。", "problem": "一台配备了平行孔准直器的伽马相机被用于对一个位于准直器表面上方距离 $z$ 处的点状源进行成像。该准直器的孔直径为 $d$，长度为 $L$。假设探测器具有以内在分辨率 $R_i$（半峰全宽）为特征的内在模糊，并且由准直器产生的几何模糊与探测器的内在模糊是相互独立的，并以平方和的形式叠加。利用穿过平行孔准直器的射线几何学的基本原理以及独立模糊的平方和叠加方法，确定当几何模糊等于内在模糊时，源到准直器的距离 $z$。使用 $d=1.5$ 毫米，$L=25$ 毫米，以及 $R_i=3.5$ 毫米。以毫米为单位表示您的最终答案。不要四舍五入；提供精确值。", "solution": "对于平行孔准直器，几何模糊源于有限的孔直径以及射线在准直器出口与源平面之间的扩散。位于准直器上方距离 $z$ 处的点源会产生一个半影斑，其宽度按相似三角形比例缩放：孔出口平面与源平面之间的放大率是孔出口到源的距离与孔长度之比。当孔长度为 $L$ 时，从孔出口到源的距离是 $L+z$，因此几何模糊由下式给出：\n$$\nR_{g}(z)=d\\frac{L+z}{L}.\n$$\n当模糊是独立的且近似高斯分布时，系统分辨率 $R_{s}$ 以平方和的形式叠加，\n$$\nR_{s}^{2}(z)=R_{g}^{2}(z)+R_{i}^{2},\n$$\n但我们感兴趣的条件是几何模糊与内在模糊的贡献相等，\n$$\nR_{g}(z)=R_{i}.\n$$\n代入几何模糊的表达式并求解 $z$，\n$$\nd\\frac{L+z}{L}=R_{i}\\quad\\Longrightarrow\\quad L+z=\\frac{L R_{i}}{d}\\quad\\Longrightarrow\\quad z=\\frac{L R_{i}}{d}-L.\n$$\n使用给定值 $d=1.5$ 毫米，$L=25$ 毫米，以及 $R_{i}=3.5$ 毫米，\n$$\nz=\\frac{25\\times 3.5}{1.5}-25=\\frac{87.5}{1.5}-25=\\frac{175}{3}-25=\\frac{175-75}{3}=\\frac{100}{3}\\ \\text{mm}.\n$$\n因此，当几何模糊等于内在模糊时，源到准直器的精确距离为 $\\frac{100}{3}$ 毫米。", "answer": "$$\\boxed{\\frac{100}{3}}$$", "id": "4887750"}, {"introduction": "在准直器设计的概念基础上，本题探讨了分辨率与灵敏度之间直接的临床权衡 [@problem_id:4887718]。通过计算更换准直器后为保持图像质量所需的采集时间调整，您将学习到设计选择如何影响实际的成像方案。这个练习模拟了核医学科室中的一个常见情景，强调了理解准直器规格对于确保一致的诊断质量的重要性。", "problem": "一项平面伽马相机方案正在被修改，用一个中能通用 (MEGP) 准直器替换一个低能高分辨率 (LEHR) 准直器。在相同的源分布、能量窗和探测器设置下，使用 LEHR 准直器测得的系统灵敏度为 $88.0$ 计数/秒/兆贝克勒尔 (cps/MBq)，而使用 MEGP 准直器测得的系统灵敏度为 $57.0$ cps/MBq。当前方案使用 LEHR 准直器时，每个视图的采集时间为 $7.50$ 分钟。\n\n假设以下基本条件成立：\n- 探测到的光子计数遵循泊松过程。\n- 像素中计数的变异系数（定义为标准差除以平均值）由 $1/\\sqrt{N}$ 给出，其中 $N$ 是对该像素有贡献的预期探测计数值。\n- 死时间损失可忽略不计，且除准直器灵敏度外的所有其他因素保持不变。\n- 对于固定的活度分布，预期探测计数值与灵敏度和采集时间均成正比。\n\n仅使用这些前提条件，确定使用 MEGP 准直器所需的每个视图的采集时间，以在重建图像中获得与使用 LEHR 准直器时相同的变异系数。以分钟为单位表示您的最终答案，并将结果四舍五入至三位有效数字。", "solution": "该问题已经过验证，被确定为医学成像物理学中一个提法明确、有科学依据的问题。所有给定条件一致且足以得出一个唯一解。\n\n目标是确定中能通用 (MEGP) 准直器所需的每个视图的采集时间，记为 $T_{MEGP}$，使得最终的图像质量（以变异系数衡量）与使用低能高分辨率 (LEHR) 准直器所获得的相同。\n\n设 LEHR 准直器的变量用下标 $LEHR$ 表示，MEGP 准直器的变量用下标 $MEGP$ 表示。提供的已知数据点如下：\n- LEHR 准直器的系统灵敏度：$S_{LEHR} = 88.0$ 计数/秒/兆贝克勒尔 (cps/MBq)。\n- MEGP 准直器的系统灵敏度：$S_{MEGP} = 57.0$ cps/MBq。\n- LEHR 准直器的采集时间：$T_{LEHR} = 7.50$ 分钟。\n\n基本前提是：\n1. 探测到的光子计数 $N$ 服从泊松过程。对于泊松分布，方差等于均值，$\\sigma^2 = \\mu$。因此标准差为 $\\sigma = \\sqrt{\\mu}$。\n2. 变异系数 $CV$ 定义为标准差与均值的比值：$CV = \\frac{\\sigma}{\\mu}$。鉴于预期计数值为 $N$，我们有 $\\mu = N$ 和 $\\sigma = \\sqrt{N}$。因此，变异系数可以正确地表示为 $CV = \\frac{\\sqrt{N}}{N} = \\frac{1}{\\sqrt{N}}$。\n3. 预期计数值 $N$ 与系统灵敏度 $S$ 和采集时间 $T$ 成正比。我们可以将此关系表示为 $N = k \\cdot A \\cdot S \\cdot T$，其中 $A$ 是源分布的活度，$k$ 是一个比例常数，包含所有其他因素（例如，几何效率、探测器固有效率）。问题陈述源分布和所有其他因素都相同，因此乘积 $k \\cdot A$ 对两次测量都是一个常数。\n\n要求是两种方案的变异系数相同：\n$$CV_{LEHR} = CV_{MEGP}$$\n\n代入变异系数的表达式，我们得到：\n$$\\frac{1}{\\sqrt{N_{LEHR}}} = \\frac{1}{\\sqrt{N_{MEGP}}}$$\n\n两边平方并取倒数，得到核心条件：两次采集的总探测计数值必须相等。\n$$N_{LEHR} = N_{MEGP}$$\n\n现在我们使用计数与灵敏度和时间的正比关系。设比例常数为 $C = k \\cdot A$。\n$$N_{LEHR} = C \\cdot S_{LEHR} \\cdot T'_{LEHR}$$\n$$N_{MEGP} = C \\cdot S_{MEGP} \\cdot T'_{MEGP}$$\n此处，$T'$ 必须是以秒为单位的时间，以匹配灵敏度的单位 (cps)。然而，由于我们将构成一个比率，只要单位一致，时间单位就会相互抵消。我们可以继续使用分钟作为时间单位，因为转换因子会被抵消。设 $T$ 是以分钟为单位的时间。\n$$N_{LEHR} \\propto S_{LEHR} \\cdot T_{LEHR}$$\n$$N_{MEGP} \\propto S_{MEGP} \\cdot T_{MEGP}$$\n\n令计数相等，可得：\n$$S_{LEHR} \\cdot T_{LEHR} = S_{MEGP} \\cdot T_{MEGP}$$\n\n题目要求我们求出 $T_{MEGP}$。重新整理方程以求解 $T_{MEGP}$：\n$$T_{MEGP} = T_{LEHR} \\left( \\frac{S_{LEHR}}{S_{MEGP}} \\right)$$\n\n现在，我们代入给定的数值：\n$$T_{MEGP} = (7.50 \\text{ min}) \\left( \\frac{88.0 \\text{ cps/MBq}}{57.0 \\text{ cps/MBq}} \\right)$$\n灵敏度的单位 (cps/MBq) 相互抵消，结果的单位为分钟。\n$$T_{MEGP} = 7.50 \\times \\frac{88.0}{57.0} \\text{ min}$$\n$$T_{MEGP} \\approx 7.50 \\times 1.5438596... \\text{ min}$$\n$$T_{MEGP} \\approx 11.578947... \\text{ min}$$\n\n问题要求最终答案四舍五入至三位有效数字。前三位有效数字是 $1$、$1$ 和 $5$。第四位数字是 $7$，大于或等于 $5$，因此我们将第三位数字向上取整。\n$$T_{MEGP} \\approx 11.6 \\text{ min}$$\n这个结果在物理上是符合预期的。MEGP 准直器的灵敏度 ($57.0$) 低于 LEHR 准直器 ($88.0$)。为了收集相同数量的光子，从而达到相同的统计质量（噪声水平），必须增加采集时间。", "answer": "$$\\boxed{11.6}$$", "id": "4887718"}, {"introduction": "这项高级练习将理论与实验数据分析联系起来，这是任何成像科学家的一项核心技能 [@problem_id:4887703]。您将处理模拟的测量数据（边缘扩展函数），以提取系统的几何分辨率，并根据理论模型对其进行验证。这个动手编程练习展示了如 [@problem_id:4887750] 中探讨的抽象几何公式如何在实践中得到证实，并让您深入了解质量保证和系统表征的过程。", "problem": "带有平行孔准直器的伽玛相机会产生空间模糊，该模糊随着与准直器表面距离的增加而增大。考虑一维边缘扩散函数 (ESF)，其定义为跨越一个尖锐活动边缘所探测到的计数轮廓；以及相应的线扩散函数 (LSF)，其定义为 ESF 的空间导数。距离 $z$ 处的几何分辨率，记为 $R_g(z)$，在此操作性地定义为 LSF 的半高全宽 (FWHM)。此问题的基础是准直器孔的几何投影以及连接 ESF、LSF 和 FWHM 的一维信号分析。你的任务是根据测量的 ESF 推断出 $R_g(z)$，拟合一个线性模型 $R_g(z) = a z + b$，并验证由几何模型预测的线性依赖关系是否与物理准直器参数一致。\n\n给定三个测试用例。对于每个测试用例，准直器具有指定的有效孔径 $d$（单位为 $\\mathrm{mm}$）和孔长度 $L$（单位为 $\\mathrm{mm}$）。对于每个测试用例，在多个源到准直器距离 $z$（单位为 $\\mathrm{mm}$）处测量 ESF。ESF 通过对以下形式的光滑函数进行采样来近似：\n$$\nE_z(x) = \\frac{1}{2}\\left(1 + \\operatorname{erf}\\left(\\frac{x}{\\sqrt{2}\\,\\sigma(z)}\\right)\\right),\n$$\n其中 $x$ 是横向坐标（单位为 $\\mathrm{mm}$），$\\sigma(z)$ 是高斯 LSF 的标准差，该 LSF 通过经过充分检验的关系式得到 FWHM $R_g(z)$：\n$$\n\\text{FWHM} = 2\\sqrt{2\\ln 2}\\,\\sigma.\n$$\n在 ESF 测量中存在一个小的加性零均值噪声，其标准差为 $0.01$（无量纲计数）。对于每个测试用例，都提供了用于合成所测 ESF 的 $x$ 采样和 FWHM 值。你的程序必须：\n\n1. 对于测试用例中的每个 $z$，通过数值计算 LSF $L_z(x) = \\frac{dE_z}{dx}$，然后在 LSF 的一半最大值处的样本之间使用线性插值找到其 FWHM，从而估计 $R_g(z)$（单位为 $\\mathrm{mm}$）。\n2. 对所提供的 $z$ 值拟合一个最小二乘线性模型 $R_g(z) = a z + b$。\n3. 如下验证几何线性依赖关系：\n   - 计算拟合的决定系数 $R^2$；要求 $R^2 \\geq 0.98$。\n   - 使用准直器参数 $d$ 和 $L$，通过几何推理计算预测的斜率和截距。\n   - 计算拟合斜率 $a$ 和截距 $b$ 相对于几何预测值的相对误差；要求斜率相对误差 $\\leq 0.10$（小数形式）和截距相对误差 $\\leq 0.15$（小数形式）。\n4. 为每个测试用例返回一个布尔值，指示是否满足所有验证标准。\n\n测试套件：\n\n- 测试用例 $1$（平行孔，低能高分辨率）：\n  - $d = 1.5\\,\\mathrm{mm}$，$L = 25\\,\\mathrm{mm}$。\n  - 距离：$z \\in \\{0, 10, 20, 30\\}\\,\\mathrm{mm}$。\n  - 横向采样：$x$ 从 $-20\\,\\mathrm{mm}$ 到 $20\\,\\mathrm{mm}$，步长为 $0.2\\,\\mathrm{mm}$。\n  - ESF 合成 FWHM 值（用于生成 $E_z(x)$）：$[1.5, 2.1, 2.7, 3.3]\\,\\mathrm{mm}$。\n\n- 测试用例 $2$（平行孔，低能通用型）：\n  - $d = 2.4\\,\\mathrm{mm}$，$L = 15\\,\\mathrm{mm}$。\n  - 距离：$z \\in \\{0, 5, 10, 20\\}\\,\\mathrm{mm}$。\n  - 横向采样：$x$ 从 $-20\\,\\mathrm{mm}$ 到 $20\\,\\mathrm{mm}$，步长为 $0.2\\,\\mathrm{mm}$。\n  - ESF 合成 FWHM 值：$[2.4, 3.2, 4.0, 5.6]\\,\\mathrm{mm}$。\n\n- 测试用例 $3$（由于额外展宽导致远距离行为不理想的平行孔）：\n  - $d = 1.2\\,\\mathrm{mm}$，$L = 20\\,\\mathrm{mm}$。\n  - 距离：$z \\in \\{0, 30, 60, 90\\}\\,\\mathrm{mm}$。\n  - 横向采样：$x$ 从 $-40\\,\\mathrm{mm}$ 到 $40\\,\\mathrm{mm}$，步长为 $0.5\\,\\mathrm{mm}$。\n  - ESF 合成 FWHM 值：$[1.2, 3.9, 8.4, 14.7]\\,\\mathrm{mm}$。\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含三个测试用例的验证结果，格式为方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是一个布尔值。不应打印任何其他文本。", "solution": "该问题陈述已经过严格审查，并被确定为有效。它在科学上基于医学影像物理学的原理，特别是伽玛相机空间分辨率的表征。该问题定义明确、客观，并提供了一套独立完整的、尽管具有挑战性的分析任务。问题的核心在于将实验数据（模拟的含噪声边缘扩散函数）与准直器性能的理论模型联系起来。\n\n解决方案的科学基础是平行孔准直器的几何模型。几何分辨率 $R_g$，即线扩散函数（LSF）的半高全宽（FWHM），表现出对与准直器表面距离 $z$ 的线性依赖关系。这个关系可以通过使用相似三角形，考虑单个准直器孔的视场来推导。对于直径为 $d$、长度为 $L$ 的孔，位于距离 $z$ 处的点源会在探测器上投射一个辐射圆。这个圆的直径，被视为几何分辨率 $R_g(z)$，由下式给出：\n$$\nR_g(z) = d \\frac{L+z}{L} = \\left(\\frac{d}{L}\\right)z + d\n$$\n这是一个形如 $R_g(z) = a z + b$ 的线性方程，其中理论上预测的斜率为 $a_{geo} = d/L$，y轴截距为 $b_{geo} = d$。截距 $R_g(0) = d$ 表示在准直器表面的内在分辨率，即孔的直径。\n\n解决每个测试用例的步骤如下：\n\n1.  **数据合成与FWHM估计**：对于测试用例中提供的每个距离 $z$，我们首先合成测量的边缘扩散函数（ESF）。问题陈述指出ESF被建模为误差函数，即高斯函数的积分。因此，作为ESF导数的线扩散函数（LSF）是一个高斯函数。对于高斯函数，FWHM与标准差 $\\sigma$ 之间的关系由 $\\text{FWHM} = 2\\sqrt{2\\ln 2}\\,\\sigma$ 给出。\n    -   使用提供的合成FWHM值，我们计算出相应的 $\\sigma(z)$。\n    -   ESF，$E_z(x) = \\frac{1}{2}\\left(1 + \\operatorname{erf}\\left(\\frac{x}{\\sqrt{2}\\,\\sigma(z)}\\right)\\right)$，在给定的横向范围 $x$ 上被采样。\n    -   向纯净的ESF中添加标准差为0.01的零均值高斯噪声，以模拟真实的测量。\n    -   然后通过对含噪ESF关于 $x$ 进行数值微分来计算LSF。我们使用二阶精确中心差分法，通过 `numpy.gradient` 实现。\n    -   估计所得数值LSF的FWHM。这包括找到LSF的最大值，计算半最大值，然后使用LSF离散样本间的线性插值来找到函数穿过此半最大值阈值的两个 $x$ 坐标。这两个坐标之差即为估计的 $R_g(z)$。\n\n2.  **线性模型拟合**：将一组估计的FWHM值 $(\\text{estimated } R_g(z_i))$ 与相应的距离 $(z_i)$ 进行线性模型拟合，$R_g(z) = az + b$。这通过对数据进行1次多项式的最小二乘拟合来实现。拟合得出经验斜率 $a$ 和截距 $b$。\n\n3.  **验证**：将拟合结果与几何模型和统计标准进行验证。\n    -   **拟合优度**：计算线性拟合的决定系数 $R^2$。它衡量了估计的FWHM中可由距离 $z$ 预测的方差比例。拟合必须满足 $R^2 \\geq 0.98$。\n    -   **模型参数一致性**：将拟合参数 $a$ 和 $b$ 与几何模型的理论预测值进行比较：$a_{geo} = d/L$ 和 $b_{geo} = d$。计算相对误差：\n        $$\n        \\epsilon_a = \\frac{|a - a_{geo}|}{|a_{geo}|}\n        $$\n        $$\n        \\epsilon_b = \\frac{|b - b_{geo}|}{|b_{geo}|}\n        $$\n    -   验证要求这些误差在指定的容差范围内：$\\epsilon_a \\leq 0.10$ 和 $\\epsilon_b \\leq 0.15$。\n    \n只有当所有三个验证标准（$R^2$ 阈值、斜率误差阈值和截距误差阈值）都满足时，一个测试用例才被认为是有效的（评估为 `True`）。否则，它是无效的（评估为 `False`）。这个综合性的步骤将应用于所有三个测试用例。", "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\n\ndef calculate_fwhm(y, x):\n    \"\"\"\n    Calculates the Full Width at Half Maximum (FWHM) of a 1D signal.\n    \n    Args:\n        y (np.ndarray): The signal amplitude values.\n        x (np.ndarray): The corresponding coordinate values.\n        \n    Returns:\n        float: The calculated FWHM.\n    \"\"\"\n    max_val = np.max(y)\n    half_max = max_val / 2.0\n    \n    # Find indices where the signal is above half maximum\n    above_half_max_indices = np.where(y > half_max)[0]\n    \n    if len(above_half_max_indices)  2:\n        return 0.0 # Peak is too narrow or not present\n\n    # Left crossing point (interpolation)\n    left_idx1 = above_half_max_indices[0] - 1\n    left_idx2 = above_half_max_indices[0]\n    \n    y1, y2 = y[left_idx1], y[left_idx2]\n    x1, x2 = x[left_idx1], x[left_idx2]\n    x_left = x1 + (x2 - x1) * (half_max - y1) / (y2 - y1)\n\n    # Right crossing point (interpolation)\n    right_idx1 = above_half_max_indices[-1]\n    right_idx2 = above_half_max_indices[-1] + 1\n\n    if right_idx2 >= len(y): # Handle edge case\n        return 0.0\n        \n    y1, y2 = y[right_idx1], y[right_idx2]\n    x1, x2 = x[right_idx1], x[right_idx2]\n    x_right = x1 + (x2 - x1) * (half_max - y1) / (y2 - y1)\n    \n    return x_right - x_left\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and validate collimator performance.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: LEHR\n        {\n            \"d\": 1.5, \"L\": 25,\n            \"z_values\": np.array([0, 10, 20, 30]),\n            \"x_range\": (-20, 20, 0.2),\n            \"fwhm_synthesis\": [1.5, 2.1, 2.7, 3.3]\n        },\n        # Test Case 2: LEGP\n        {\n            \"d\": 2.4, \"L\": 15,\n            \"z_values\": np.array([0, 5, 10, 20]),\n            \"x_range\": (-20, 20, 0.2),\n            \"fwhm_synthesis\": [2.4, 3.2, 4.0, 5.6]\n        },\n        # Test Case 3: Non-ideal behavior\n        {\n            \"d\": 1.2, \"L\": 20,\n            \"z_values\": np.array([0, 30, 60, 90]),\n            \"x_range\": (-40, 40, 0.5),\n            \"fwhm_synthesis\": [1.2, 3.9, 8.4, 14.7]\n        }\n    ]\n    \n    results = []\n    \n    FWHM_TO_SIGMA = 1 / (2 * np.sqrt(2 * np.log(2)))\n    NOISE_STD = 0.01\n\n    # For reproducibility of noise, uncomment the line below\n    # np.random.seed(0)\n\n    for case in test_cases:\n        d = case[\"d\"]\n        L = case[\"L\"]\n        z_values = case[\"z_values\"]\n        x_min, x_max, x_step = case[\"x_range\"]\n        x = np.arange(x_min, x_max + x_step, x_step)\n        \n        estimated_fwhms = []\n        \n        for i, z in enumerate(z_values):\n            # 1. Synthesize ESF data\n            fwhm_true = case[\"fwhm_synthesis\"][i]\n            sigma = fwhm_true * FWHM_TO_SIGMA\n            \n            esf_clean = 0.5 * (1 + erf(x / (np.sqrt(2) * sigma)))\n            noise = np.random.normal(0, NOISE_STD, size=esf_clean.shape)\n            esf_noisy = esf_clean + noise\n            \n            # 2. Estimate Rg(z) by computing LSF and its FWHM\n            lsf = np.gradient(esf_noisy, x)\n            fwhm_est = calculate_fwhm(lsf, x)\n            estimated_fwhms.append(fwhm_est)\n            \n        estimated_fwhms = np.array(estimated_fwhms)\n        \n        # 3. Fit linear model Rg(z) = a*z + b\n        a_fit, b_fit = np.polyfit(z_values, estimated_fwhms, 1)\n\n        # 4. Validate the fit\n        # 4a. Compute R^2\n        y_pred = a_fit * z_values + b_fit\n        ss_res = np.sum((estimated_fwhms - y_pred)**2)\n        ss_tot = np.sum((estimated_fwhms - np.mean(estimated_fwhms))**2)\n        r_squared = 1 - (ss_res / ss_tot) if ss_tot > 0 else 0\n        \n        # 4b. Compute geometric predictions\n        a_geo = d / L\n        b_geo = d\n        \n        # 4c. Compute relative errors\n        err_a = np.abs(a_fit - a_geo) / np.abs(a_geo)\n        err_b = np.abs(b_fit - b_geo) / np.abs(b_geo)\n        \n        # 4d. Check all validation criteria\n        is_valid = (r_squared >= 0.98) and (err_a = 0.10) and (err_b = 0.15)\n        results.append(is_valid)\n\n    # Format the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4887703"}]}