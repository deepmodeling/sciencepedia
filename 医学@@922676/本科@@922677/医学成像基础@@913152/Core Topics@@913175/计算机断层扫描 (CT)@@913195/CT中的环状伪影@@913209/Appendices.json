{"hands_on_practices": [{"introduction": "理解图像伪影与其在原始数据中的来源之间的关系，是医学成像中的一项核心技能。本练习将通过一个理想化的平行束CT几何模型，引导您从第一性原理出发，推导单个探测器偏差如何转变为重建图像中的环状伪影。通过这个实践，您将掌握伪影形成的基本几何原理，即将弦图（sinogram）中的一条直线特征映射为图像域中一个特定半径的圆环 [@problem_id:4533126]。", "problem": "考虑理想平行束几何下的二维计算机断层扫描（CT），其旋转中心位于原点，且在角度 $\\theta \\in [0,\\pi)$ 范围内进行了密集、均匀采样的视图集。设 $f(x,y)$ 表示被成像的物体，$p(\\theta,s)$ 表示其拉东变换，其中 $s$ 是积分线到原点的有符号距离，$\\theta$ 是该线法线的方向。在滤波反投影重建中，估计值 $\\hat{f}(x,y)$ 的形成过程是：首先将每个投影 $p(\\theta,\\cdot)$ 沿 $s$ 方向与一个滤波器 $h(s)$ 进行卷积，该滤波器的关于 $s$ 的傅里叶变换等于 $|\\omega|$；然后将滤波后的投影沿 $\\theta$ 方向进行反投影。假设采样是理想连续的，并且使用的是精确的斜坡滤波器。\n\n现在考虑一个常见的采集伪影：一个位于固定坐标 $s_0$ 处的探测器单元在所有角度 $\\theta$ 上都有一个恒定的加性偏置 $\\delta$。将这个有偏置的探测器单元建模为在 $s=s_0$ 处的一个无穷窄的单元，它在所有角度 $\\theta$ 下，且仅在 $s=s_0$ 处，为测量的投影 $p(\\theta,s)$ 增加了一个 $\\delta$ 项。因此，测量到的正弦图为 $p_{\\mathrm{m}}(\\theta,s)=p(\\theta,s) + \\delta\\,b(s)$，其中 $b(s)$ 是一个在 $s=s_0$ 处有支撑的函数，用于捕捉单个单元的贡献，并且在极限情况下可以理想化为在 $s_0$ 处的狄拉克 $\\delta$ 分布。\n\n使用上述定义，并从通过滤波反投影实现的拉东逆变换出发，推导伪影在重建图像 $\\hat{f}(x,y)$ 中表现为环状的半径 $r^{\\ast}$（从原点测量，并以与 $s$ 相同的物理单位表示）。你的推导应从正式的滤波反投影表达式开始，通过分析有偏置的探测器单元对 $\\hat{f}(x,y)$ 的贡献来进行，并使用 $x=r\\cos\\varphi$ 和 $y=r\\sin\\varphi$ 来揭示其径向依赖性。将 $r^{\\ast}$ 确定为环状伪影的中心线半径，其定义为因滤波器的奇异行为导致伪影重建强度达到最大值时的 $r$ 值。明确说明 $r^{\\ast}$ 如何（或是否）依赖于 $\\delta$。\n\n将你的最终答案表示为关于 $s_0$ 和必要基本常数的封闭形式解析表达式。不需要进行数值计算。", "solution": "问题要求计算在计算机断层扫描（CT）重建中，由单个具有恒定加性偏置的探测器单元引起的环状伪影的半径 $r^{\\ast}$。重建过程使用理想的滤波反投影（FBP）算法。\n\n从物体的拉东变换（正弦图）$p(\\theta,s)$ 出发，其滤波反投影重建 $\\hat{f}(x,y)$ 由以下公式给出：\n$$ \\hat{f}(x,y) = \\int_{0}^{\\pi} p_f(\\theta, x\\cos\\theta + y\\sin\\theta) \\, d\\theta $$\n其中 $p_f(\\theta, s)$ 是滤波后的投影。滤波步骤是投影 $p(\\theta, \\cdot)$ 与滤波器核 $h(s)$ 的卷积：\n$$ p_f(\\theta, s) = (p(\\theta, \\cdot) * h)(s) = \\int_{-\\infty}^{\\infty} p(\\theta, s') h(s - s') \\, ds' $$\n问题指出，滤波器 $h(s)$ 对应于理想的斜坡滤波器，其关于 $s$ 的傅里叶变换（记为 $\\mathcal{F}\\{h\\}(\\omega)$）是 $|\\omega|$。在空间域中，这个理想滤波器由一个奇异函数的主值给出。它可以正式地写为 $|\\omega|$ 的傅里叶逆变换：\n$$ h(s) = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} |\\omega| e^{i\\omega s} \\, d\\omega $$\n这个表达式不是一个常规函数，而是一个分布，其在 $s \\neq 0$ 处的主要行为与 $1/s^2$ 成正比。更正式地， $h(s) = -\\frac{1}{2\\pi^2} \\text{p.v.} \\frac{1}{s^2}$。对于这个问题，关键属性是 $s=0$ 处的奇异性。\n\n测量到的正弦图 $p_{\\mathrm{m}}(\\theta,s)$ 包含真实的正弦图 $p(\\theta,s)$ 和一个伪影项。该伪影是由于在坐标 $s=s_0$ 处的单个探测器单元在所有视角 $\\theta \\in [0, \\pi)$ 下都具有一个恒定的加性偏置 $\\delta$。将探测器单元理想化为无穷窄，我们可以将此伪影贡献建模为空间域 $s$ 中的狄拉克 $\\delta$ 分布：\n$$ p_{\\text{artifact}}(\\theta, s) = \\delta \\cdot \\delta_{\\text{Dirac}}(s - s_0) $$\n测量到的总正弦图为 $p_{\\mathrm{m}}(\\theta,s) = p(\\theta,s) + p_{\\text{artifact}}(\\theta,s)$。由于 FBP 算法的线性特性，重建图像将是真实图像重建与伪影重建之和：\n$$ \\hat{f}_{\\mathrm{m}}(x,y) = \\hat{f}_{\\text{true}}(x,y) + \\hat{f}_{\\text{artifact}}(x,y) $$\n我们的任务是找出环状伪影的半径，这对应于分析 $\\hat{f}_{\\text{artifact}}(x,y)$。\n\n首先，我们确定滤波后的伪影投影 $p_{f, \\text{artifact}}(\\theta,s)$：\n$$ p_{f, \\text{artifact}}(\\theta, s) = (p_{\\text{artifact}}(\\theta, \\cdot) * h)(s) = \\int_{-\\infty}^{\\infty} \\delta \\cdot \\delta_{\\text{Dirac}}(s' - s_0) h(s - s') \\, ds' $$\n利用狄拉克 $\\delta$ 函数的筛选性质，该卷积简化为：\n$$ p_{f, \\text{artifact}}(\\theta, s) = \\delta \\cdot h(s - s_0) $$\n注意，滤波后的伪影投影与角度 $\\theta$ 无关。\n\n接下来，我们对 $p_{f, \\text{artifact}}$ 执行反投影步骤，以获得伪影图像 $\\hat{f}_{\\text{artifact}}(x,y)$：\n$$ \\hat{f}_{\\text{artifact}}(x,y) = \\int_{0}^{\\pi} p_{f, \\text{artifact}}(\\theta, x\\cos\\theta + y\\sin\\theta) \\, d\\theta $$\n代入 $p_{f, \\text{artifact}}$ 的表达式：\n$$ \\hat{f}_{\\text{artifact}}(x,y) = \\int_{0}^{\\pi} \\delta \\cdot h(x\\cos\\theta + y\\sin\\theta - s_0) \\, d\\theta $$\n为了分析径向依赖性，我们将图像坐标 $(x,y)$ 转换为极坐标 $(r, \\varphi)$，其中 $x=r\\cos\\varphi$ 且 $y=r\\sin\\varphi$。表达式变为：\n$$ \\hat{f}_{\\text{artifact}}(r,\\varphi) = \\delta \\int_{0}^{\\pi} h(r\\cos\\varphi\\cos\\theta + r\\sin\\varphi\\sin\\theta - s_0) \\, d\\theta $$\n$$ \\hat{f}_{\\text{artifact}}(r,\\varphi) = \\delta \\int_{0}^{\\pi} h(r\\cos(\\theta - \\varphi) - s_0) \\, d\\theta $$\n通过变量代换 $u = \\theta - \\varphi$，积分变为 $\\int_{-\\varphi}^{\\pi-\\varphi} h(r\\cos(u) - s_0) \\, du$。由于积分区间长度为 $\\pi$，并且已知仅依赖于 $s$ 的函数的反投影是圆对称的，因此结果与 $\\varphi$ 无关。为简化分析，我们可以在不失一般性的情况下设置 $\\varphi=0$。伪影图像的强度仅是半径 $r$ 的函数，我们将其表示为 $A(r)$：\n$$ A(r) = \\hat{f}_{\\text{artifact}}(r) = \\delta \\int_{0}^{\\pi} h(r\\cos\\theta - s_0) \\, d\\theta $$\n\n问题要求找出伪影强度因滤波器的奇异行为而达到最大值时的半径 $r^{\\ast}$。滤波器 $h(u)$ 在 $u=0$ 处是奇异的。因此，积分 $A(r)$ 将主要由那些使得 $h$ 的参数 $g(r, \\theta) = r\\cos\\theta - s_0$ 接近于零的角度 $\\theta$ 的贡献所主导。我们通过考虑 $g(r, \\theta) = 0$ 的根来分析此积分的行为。\n\n情况1：$r  |s_0|$。在这种情况下， $|r\\cos\\theta| \\le r  |s_0|$，所以对于任何 $\\theta$，$r\\cos\\theta - s_0$ 永远不为零。被积函数 $h(r\\cos\\theta - s_0)$ 在整个积分区间上是一个光滑、良态的函数。得到的积分 $A(r)$ 是有限且连续的。\n\n情况2：$r  |s_0|$。在这种情况下，方程 $r\\cos\\theta = s_0$ 对 $\\theta$ 有解。具体来说，$\\cos\\theta = s_0/r$ 在 $[0, 2\\pi)$ 中有两个解，在 $[0, \\pi)$ 中通常有一或两个解，具体取决于 $s_0$ 的符号。设 $\\theta_0$ 是一个解。参数关于 $\\theta$ 在该点的导数是 $\\frac{d}{d\\theta}(r\\cos\\theta - s_0)|_{\\theta_0} = -r\\sin\\theta_0 = \\mp\\sqrt{r^2 - s_0^2} \\neq 0$。这意味着 $\\theta_0$ 是一个单根。在单根附近，被积函数的行为类似于 $h(c(\\theta-\\theta_0)) \\propto 1/(\\theta-\\theta_0)^2$，其中 $c$ 是一个非零常数。虽然是奇异的，但这种类型的积分在主值意义下是可处理的，并产生一个有限但较大的值。\n\n情况3：$r = |s_0|$。不失一般性地，我们假设 $s_0  0$，所以 $r=s_0$。求根的方程变为 $s_0\\cos\\theta = s_0$，得到 $\\cos\\theta=1$，所以 $\\theta=0$。在这一点， $h$ 的参数为零。我们再来考察它的导数：$\\frac{d}{d\\theta}(s_0\\cos\\theta - s_0)|_{\\theta=0} = -s_0\\sin(0) = 0$。由于函数及其一阶导数都为零，所以 $\\theta=0$ 是一个二重根。在 $\\theta=0$ 附近，我们使用余弦的泰勒展开：$\\cos\\theta \\approx 1 - \\theta^2/2$。$h$ 的参数变为：\n$$ s_0\\cos\\theta - s_0 \\approx s_0(1 - \\frac{\\theta^2}{2}) - s_0 = -\\frac{s_0\\theta^2}{2} $$\n在 $\\theta=0$ 附近，被积函数的行为类似于 $h(-\\frac{s_0\\theta^2}{2}) \\propto \\frac{1}{(-\\frac{s_0\\theta^2}{2})^2} \\propto \\frac{1}{\\theta^4}$。积分 $\\int \\frac{d\\theta}{\\theta^4}$ 相比于单根情况，具有更强、不可积的奇异性。这种“相切”条件，即反投影正弦曲线 $s=r\\cos\\theta$ 恰好与伪影线 $s=s_0$ 相切，在理想极限下会造成一个数学上的灾难。在具有非理想滤波器和有限探测器尺寸的物理系统中，这种发散会转化为一个尖锐的、有限的强度峰值。\n\n因此，伪影的最大强度位于发生这种相切情况的半径 $r$ 处。这个条件是 $r = |s_0|$。因此，环状伪影的半径是 $r^{\\ast} = |s_0|$。\n\n问题还问到 $r^{\\ast}$ 对偏置值 $\\delta$ 的依赖关系。值 $\\delta$ 在伪影重建强度分布 $A(r)$ 的表达式中表现为一个线性比例因子。虽然 $\\delta$ 决定了伪影强度的量值（和符号）（即环的明暗程度），但它不改变其峰值的几何位置。位置 $r^{\\ast}$ 完全由几何参数 $s_0$ 决定。因此，$r^{\\ast}$ 与 $\\delta$ 无关。\n\n环状伪影的半径 $r^{\\ast}$ 的最终答案是。\n$$ r^{\\ast} = |s_0| $$\n这按照要求，用给定的坐标 $s_0$ 表示。", "answer": "$$ \\boxed{|s_0|} $$", "id": "4533126"}, {"introduction": "将理论知识转化为自动化工具是工程和科学实践的关键一步。在本综合练习中，您将设计并实现一个完整的算法，用于自动检测CT弦图中存在偏差的探测器通道。您需要利用中位数和中位数绝对偏差（Median Absolute Deviation）等稳健统计量来处理噪声和异常值，从而开发一个能够精确识别伪影来源的实用工具，并从理论上推导其误报率 [@problem_id:4920456]。", "problem": "您将获得一个计算机断层扫描（CT）正弦图中环状伪影形成的简化数学模型。考虑一个均匀的圆柱体模体，对于每个旋转角度 $\\phi$（以弧度为单位）和探测器通道索引 $j$，测量的线积分的自然对数产生一个正弦图样本，其模型为\n$$\nS(\\phi,j) = A(\\phi) + B_j + \\varepsilon(\\phi,j),\n$$\n其中，$A(\\phi)$ 是由于均匀模体几何结构而在所有通道间共享的、与角度相关的公共项，$B_j$ 是通道 $j$ 的一个恒定偏移，用于捕捉偏差或校准误差，而 $\\varepsilon(\\phi,j)$ 是均值为零、标准差为 $\\sigma$ 的独立同分布高斯噪声样本。在理想的均匀模体扫描下，无偏情况具有对所有 $j$ 都有 $B_j = 0$。\n\n您的任务是：\n\n1. 算法设计：通过对每个正弦图列应用跨 $\\phi$ 的鲁棒统计学，开发一个鲁棒的偏置通道探测器。该算法应：\n   - 在每个角度 $\\phi$ 上，使用跨通道的样本中位数鲁棒地估计 $A(\\phi)$，得到 $\\widehat{A}(\\phi)$。\n   - 形成残差 $R(\\phi,j) = S(\\phi,j) - \\widehat{A}(\\phi)$。\n   - 对于每个通道 $j$，计算 $R(\\phi,j)$ 在 $\\phi$ 上的样本中位数 $M_j$ 和中位数绝对偏差 $D_j = \\operatorname{median}_{\\phi}(|R(\\phi,j) - M_j|)$。\n   - 计算一个鲁棒得分 $T_j = |M_j|/D_j$，如果对于给定的阈值 $\\tau$ 有 $T_j \\ge \\tau$，则声明通道 $j$ 存在偏置。\n\n2. 假阳性率推导：在均匀模体扫描下（对所有 $j$ 都有 $B_j = 0$），假设在移除了公共项 $A(\\phi)$ 后，$R(\\phi,j)$ 是独立同分布的，服从 $\\mathcal{N}(0,\\sigma^2)$ 分布，并且通道数量足够多，以至于 $\\widehat{A}(\\phi)$ 的估计误差可以忽略不计。利用样本中位数的顺序统计量的标准渐近性质和高斯噪声下中位数绝对偏差的正态近似，推导出探测器的预期假阳性率（FPR）$\\mathrm{FPR}(n_\\phi,\\tau)$，作为角度数 $n_\\phi$ 和阈值 $\\tau$ 的函数。用标准正态累积分布函数 $\\Phi(\\cdot)$ 以及依赖于 $\\sigma$ 和 $n_\\phi$ 的常数来表示您最终的 FPR。您的程序应实现这个推导出的公式。\n\n3. 仿真与评估：对于每个测试用例，使用以下模型生成一个合成正弦图\n$$\nS_k(j) = A(\\phi_k) + B_j + \\varepsilon_{k,j}, \\quad \\phi_k = \\frac{2\\pi k}{n_\\phi}, \\quad k \\in \\{0,1,\\dots,n_\\phi-1\\},\n$$\n其中\n$$\nA(\\phi) = a_1 \\sin(2\\phi) + a_2 \\cos(3\\phi),\n$$\n和已知的常数 $a_1$ 和 $a_2$。使用探测器对注入了偏差 $B_j$ 的正弦图计算声明为偏置的总通道数。此外，通过生成具有相同参数但所有 $j$ 的 $B_j=0$ 的第二个正弦图，并测量被标记为偏置的通道比例，来计算经验假阳性率。角度 $\\phi$ 必须以弧度为单位。所有表示比率的输出都必须以小数形式表示。\n\n测试套件：\n- 案例 1：$n_\\phi = 720$，$m = 512$，$\\sigma = 0.003$，$\\tau = 4.0$，$a_1 = 0.05$，$a_2 = 0.02$，$B_j$ 在 $j \\in \\{50,120,300,450\\}$ 处非零，其值为 $B_j = 0.02$，其他地方 $B_j = 0$。\n- 案例 2：$n_\\phi = 32$，$m = 256$，$\\sigma = 0.003$，$\\tau = 3.0$，$a_1 = 0.05$，$a_2 = 0.02$，$B_j$ 在 $j \\in \\{10,200\\}$ 处非零，其值为 $B_j = 0.02$，其他地方 $B_j = 0$。\n- 案例 3：$n_\\phi = 180$，$m = 128$，$\\sigma = 0.0$，$\\tau = 2.0$，$a_1 = 0.05$，$a_2 = 0.02$，$B_j$ 在 $j \\in \\{5,64,100\\}$ 处非零，其值为 $B_j = 0.015$，其他地方 $B_j = 0$。\n- 案例 4：$n_\\phi = 1000$，$m = 256$，$\\sigma = 0.004$，$\\tau = 10.0$，$a_1 = 0.05$，$a_2 = 0.02$，所有通道的 $B_j = 0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个形如 $[N_\\text{det}, \\mathrm{FPR}_\\text{theory}, \\mathrm{FPR}_\\text{sim}]$ 的列表，其中 $N_\\text{det}$ 是在有偏正弦图中检测到的偏置通道的整数计数，而 $\\mathrm{FPR}_\\text{theory}$ 和 $\\mathrm{FPR}_\\text{sim}$ 以小数值浮点数形式给出。例如，打印的输出应如下所示\n$$\n[[N_1, F_1, E_1], [N_2, F_2, E_2], [N_3, F_3, E_3], [N_4, F_4, E_4]].\n$$", "solution": "该问题旨在解决计算机断层扫描（CT）正弦图中的环状伪影检测问题。这些伪影在重建图像中表现为同心圆环，通常源于探测器通道的失校或漂移。所提供的正弦图样本数学模型 $S(\\phi,j) = A(\\phi) + B_j + \\varepsilon(\\phi,j)$，有效地将这些伪影的来源隔离为一个依赖于通道的偏差项 $B_j$。对于特定通道 $j$，一个非零的 $B_j$ 会在该通道位置上、跨越所有投影角度 $\\phi$ 引入一条持久的线状特征，这条特征在反投影过程中会转变为一个环。\n\n任务是开发并分析一种鲁棒的统计探测器，用于识别具有非零偏差 $B_j$ 的通道。问题的核心在于推导该探测器的理论性能，并通过仿真进行验证。我们将首先推导假阳性率（FPR）的表达式，然后详细说明用于仿真的算法实现。\n\n### 假阳性率（FPR）推导\n\n假阳性率是指在通道实际上没有偏置的情况下，声明其为有偏置的概率。这对应于在原假设 $H_0$（即通道无偏，$B_j = 0$）下，检验统计量 $T_j$ 超过阈值 $\\tau$ 的概率。\n\n1.  **原假设与残差**：在 $H_0$ 下，正弦图模型为 $S(\\phi,j) = A(\\phi) + \\varepsilon(\\phi,j)$。该算法使用跨通道的中位数来估计公共项 $A(\\phi)$：$\\widehat{A}(\\phi) = \\operatorname{median}_{j} S(\\phi,j)$。然后残差为 $R(\\phi,j) = S(\\phi,j) - \\widehat{A}(\\phi)$。假设探测器通道数 $m$ 很大，样本中位数 $\\widehat{A}(\\phi)$ 是 $A(\\phi)$ 的一个鲁棒且准确的估计量，因为中位数对小部分偏置通道（离群值）不敏感。对于为计算 FPR 而考虑的无偏通道，估计误差 $\\widehat{A}(\\phi) - A(\\phi) = \\operatorname{median}_j(\\varepsilon(\\phi, j))$ 变得可以忽略不计。因此，我们可以将固定通道 $j$ 的残差近似为一组直接从噪声分布中抽取的 $n_\\phi$ 个独立同分布样本：$R(\\phi_k, j) \\approx \\varepsilon(\\phi_k, j) \\sim \\mathcal{N}(0, \\sigma^2)$。\n\n2.  **样本中位数 $M_j$ 的分布**：统计量 $M_j = \\operatorname{median}_{\\phi}(R(\\phi,j))$ 是从 $\\mathcal{N}(0, \\sigma^2)$ 分布中抽取的 $n_\\phi$ 个样本的样本中位数。对于大的角度数 $n_\\phi$，顺序统计量的中心极限定理指出，样本中位数是渐近正态分布的。其期望值是真实中位数（即 $0$），其方差由 $\\sigma_{M_j}^2 \\approx \\frac{1}{4n_\\phi [f(0)]^2}$ 给出，其中 $f(x)$ 是基础分布的概率密度函数（PDF）。对于 $\\mathcal{N}(0, \\sigma^2)$，PDF 为 $f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left(\\frac{-x^2}{2\\sigma^2}\\right)$，所以 $f(0) = \\frac{1}{\\sigma\\sqrt{2\\pi}}$。因此 $M_j$ 的方差为：\n    $$ \\sigma_{M_j}^2 \\approx \\frac{1}{4n_\\phi \\left(\\frac{1}{\\sigma\\sqrt{2\\pi}}\\right)^2} = \\frac{2\\pi\\sigma^2}{4n_\\phi} = \\frac{\\pi\\sigma^2}{2n_\\phi} $$\n    所以，$M_j \\sim \\mathcal{N}\\left(0, \\frac{\\pi\\sigma^2}{2n_\\phi}\\right)$。\n\n3.  **中位数绝对偏差 (MAD) $D_j$ 的近似**：统计量 $D_j = \\operatorname{median}_{\\phi}(|R(\\phi,j) - M_j|)$ 是残差的 MAD。对于大的 $n_\\phi$，$M_j$ 接近真实中位数（$0$），所以 $D_j \\approx \\operatorname{median}_{\\phi}(|R(\\phi,j)|)$。根据大数定律，样本 MAD 依概率收敛于总体 MAD。对于正态分布 $\\mathcal{N}(0, \\sigma^2)$，MAD 与标准差 $\\sigma$ 成正比。折叠正态分布 $|R|$ 的中位数是 $q$，使得 $P(|R| \\le q) = 1/2$，这得出 $q = \\sigma \\Phi^{-1}(3/4)$，其中 $\\Phi(\\cdot)$ 是标准正态 CDF。在考虑比率 $T_j$ 时，我们将用这个恒定的渐近值来近似 $D_j$，这一步由 Slutsky 定理证明是合理的。\n    $$ D_j \\approx \\sigma \\Phi^{-1}(3/4) $$\n\n4.  **检验统计量 $T_j$ 的分布**：检验统计量是 $T_j = |M_j|/D_j$。使用第 2 步和第 3 步的结果：\n    $$ T_j \\approx \\frac{|M_j|}{\\sigma \\Phi^{-1}(3/4)} $$\n    由于 $M_j \\sim \\mathcal{N}\\left(0, \\frac{\\pi\\sigma^2}{2n_\\phi}\\right)$，变量 $Z_T = \\frac{M_j}{\\sigma \\Phi^{-1}(3/4)}$ 服从均值为 $0$ 且方差如下的正态分布：\n    $$ \\operatorname{Var}(Z_T) = \\frac{1}{(\\sigma \\Phi^{-1}(3/4))^2} \\operatorname{Var}(M_j) = \\frac{1}{\\sigma^2 (\\Phi^{-1}(3/4))^2} \\left(\\frac{\\pi\\sigma^2}{2n_\\phi}\\right) = \\frac{\\pi}{2n_\\phi (\\Phi^{-1}(3/4))^2} $$\n    令 $\\sigma_T^2 = \\operatorname{Var}(Z_T)$。那么 $T_j \\approx |Z_T|$，其中 $Z_T \\sim \\mathcal{N}(0, \\sigma_T^2)$。\n\n5.  **假阳性率公式**：FPR 是 $P(T_j \\ge \\tau)$。\n    $$ \\mathrm{FPR} = P(|Z_T| \\ge \\tau) = P(Z_T \\ge \\tau) + P(Z_T \\le -\\tau) = 2 P(Z_T \\ge \\tau) $$\n    令 $Z \\sim \\mathcal{N}(0,1)$。那么 $Z_T = Z \\cdot \\sigma_T$。\n    $$ \\mathrm{FPR} = 2 P(Z \\cdot \\sigma_T \\ge \\tau) = 2 P(Z \\ge \\tau/\\sigma_T) = 2 \\left(1 - \\Phi\\left(\\frac{\\tau}{\\sigma_T}\\right)\\right) $$\n    代入 $\\sigma_T$ 的表达式：\n    $$ \\frac{\\tau}{\\sigma_T} = \\tau \\sqrt{\\frac{2n_\\phi (\\Phi^{-1}(3/4))^2}{\\pi}} = \\tau \\Phi^{-1}(3/4) \\sqrt{\\frac{2n_\\phi}{\\pi}} $$\n    因此，理论 FPR 的最终表达式为：\n    $$ \\mathrm{FPR}(n_\\phi, \\tau) = 2 \\left(1 - \\Phi\\left(\\tau \\Phi^{-1}(3/4) \\sqrt{\\frac{2n_\\phi}{\\pi}}\\right)\\right) $$\n    该公式在 $\\sigma  0$ 时有效。对于 $\\sigma=0$ 的特殊情况，噪声项消失。在原假设下（$B_j=0$），残差完全为零，导致 $M_j=0$ 和 $D_j=0$。检验统计量 $T_j$ 被视为 $0$，因此不会出现假阳性。所以，当 $\\sigma=0$ 时，$\\mathrm{FPR}=0$。\n\n### 算法设计与仿真\n\n根据问题陈述中指定的算法被实现来处理合成正弦图。仿真框架在提供的测试用例上评估此算法。\n\n1.  **正弦图生成**：对于每个测试用例，基于模型 $S_k(j) = A(\\phi_k) + B_j + \\varepsilon_{k,j}$ 生成两个正弦图。\n    *   一个使用指定的非零 $B_j$ 值的“有偏”正弦图。\n    *   一个用于计算经验 FPR 的“无偏”正弦图，其中对所有 $j$ 都有 $B_j=0$。\n    公共项是 $A(\\phi_k) = a_1 \\sin(2\\phi_k) + a_2 \\cos(3\\phi_k)$，其中 $\\phi_k = 2\\pi k / n_\\phi$。噪声 $\\varepsilon_{k,j}$ 从 $\\mathcal{N}(0, \\sigma^2)$ 中抽取。\n\n2.  **检测算法**：核心检测逻辑应用于给定的正弦图 $S$ 和阈值 $\\tau$：\n    *   估计每个角度的公共分量：$\\widehat{A}_k = \\operatorname{median}_j S_k(j)$。\n    *   计算残差矩阵：$R_{k,j} = S_{k,j} - \\widehat{A}_k$。\n    *   对于每个通道 $j$，计算其残差的中位数：$M_j = \\operatorname{median}_k R_{k,j}$。\n    *   对于每个通道 $j$，计算其残差的 MAD：$D_j = \\operatorname{median}_k |R_{k,j} - M_j|$。\n    *   计算鲁棒得分 $T_j = |M_j|/D_j$。需要特殊处理 $D_j=0$ 的情况：如果 $M_j \\neq 0$，则 $T_j$ 被视为无穷大；如果 $M_j=0$，则 $T_j=0$。\n    *   计算 $T_j \\ge \\tau$ 的通道数量。\n\n3.  **评估**：\n    *   $N_\\text{det}$：从有偏正弦图中检测到的通道数。\n    *   $\\mathrm{FPR}_\\text{theory}$：使用推导公式计算的理论 FPR。\n    *   $\\mathrm{FPR}_\\text{sim}$：经验 FPR，计算为在无偏正弦图中被检测为有偏的通道的比例，即 $N_{fp}/m$。\n\n该实现封装了此逻辑，遍历所有测试用例，并按规定格式化结果。为了仿真的可复现性，使用了一个固定的随机种子。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    def calculate_theoretical_fpr(n_phi, tau, sigma):\n        \"\"\"Calculates the theoretical False Positive Rate using the derived formula.\"\"\"\n        if sigma == 0.0:\n            # In the noiseless case, residuals for unbiased channels are exactly zero.\n            # Thus, M_j = 0, D_j = 0, and T_j = 0, resulting in zero false positives.\n            return 0.0\n        \n        # For any meaningful threshold tau > 0.\n        if tau == 0:\n            return 1.0\n        \n        # Constant c = Phi^-1(0.75)\n        c_factor = norm.ppf(0.75)\n        \n        # Argument for the standard normal CDF\n        arg = tau * c_factor * np.sqrt(2 * n_phi / np.pi)\n        \n        # FPR = 2 * (1 - Phi(arg)) = 2 * SF(arg)\n        fpr = 2 * norm.sf(arg)  # sf is the survival function (1 - cdf)\n        return fpr\n\n    def count_detected_channels(S, tau):\n        \"\"\"\n        Applies the robust detection algorithm to a sinogram S and returns the\n        count of channels declared as biased.\n        \n        Args:\n            S (np.ndarray): The input sinogram of shape (n_phi, m).\n            tau (float): The detection threshold.\n            \n        Returns:\n            int: The number of detected biased channels.\n        \"\"\"\n        # Step 1: Estimate A(phi) robustly using the sample median across channels.\n        A_hat = np.median(S, axis=1, keepdims=True)\n        \n        # Step 2: Form residuals R(phi, j).\n        R = S - A_hat\n        \n        # Step 3: For each channel j, compute the sample median M_j and MAD D_j.\n        M = np.median(R, axis=0)\n        D = np.median(np.abs(R - M), axis=0) # Broadcasting of M is automatic\n        \n        # Step 4: Compute robust score T_j, handling D_j = 0.\n        T = np.zeros_like(M, dtype=float)\n        \n        # Case 1: D_j is not zero. Standard calculation.\n        nonzero_D_mask = D != 0\n        T[nonzero_D_mask] = np.abs(M[nonzero_D_mask]) / D[nonzero_D_mask]\n        \n        # Case 2: D_j is zero, but M_j is not. This is a clear artifact, score is infinite.\n        inf_mask = (D == 0)  (M != 0)\n        T[inf_mask] = np.inf\n        \n        # Case 3: D_j is zero and M_j is zero. Score is zero. (Handled by initialization)\n        \n        # Step 5: Declare channel j biased if T_j >= tau.\n        detected_count = np.sum(T >= tau)\n        \n        return int(detected_count)\n\n    def run_simulation(n_phi, m, sigma, tau, a1, a2, B_spec):\n        \"\"\"\n        Runs a single test case scenario, including simulation and theoretical calculation.\n        \n        Returns:\n            list: A list containing [N_det, FPR_theory, FPR_sim].\n        \"\"\"\n        # 1. Calculate theoretical FPR\n        fpr_theory = calculate_theoretical_fpr(n_phi, tau, sigma)\n        \n        # Common simulation setup\n        phi = (2 * np.pi / n_phi) * np.arange(n_phi)\n        A = a1 * np.sin(2 * phi) + a2 * np.cos(3 * phi)\n        A = A[:, np.newaxis] # Reshape for broadcasting: (n_phi, 1)\n\n        # 2. Simulation with injected biases to find N_det\n        B_biased = np.zeros(m)\n        for j, val in B_spec.items():\n            B_biased[j] = val\n        \n        noise_biased = np.random.normal(0, sigma, (n_phi, m))\n        S_biased = A + B_biased + noise_biased\n        \n        N_det = count_detected_channels(S_biased, tau)\n        \n        # 3. Simulation for empirical FPR (no bias)\n        B_unbiased = np.zeros(m)\n        noise_unbiased = np.random.normal(0, sigma, (n_phi, m))\n        S_unbiased = A + B_unbiased + noise_unbiased\n        \n        N_fp = count_detected_channels(S_unbiased, tau)\n        fpr_sim = N_fp / m\n        \n        return [N_det, fpr_theory, fpr_sim]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: n_phi, m, sigma, tau, a1, a2, B_spec\n        (720, 512, 0.003, 4.0, 0.05, 0.02, {50: 0.02, 120: 0.02, 300: 0.02, 450: 0.02}),\n        # Case 2\n        (32, 256, 0.003, 3.0, 0.05, 0.02, {10: 0.02, 200: 0.02}),\n        # Case 3\n        (180, 128, 0.0, 2.0, 0.05, 0.02, {5: 0.015, 64: 0.015, 100: 0.015}),\n        # Case 4\n        (1000, 256, 0.004, 10.0, 0.05, 0.02, {})\n    ]\n\n    # Use a fixed random seed for reproducible results, as is good practice\n    # in scientific simulations.\n    np.random.seed(42)\n\n    all_results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        all_results.append(result)\n\n    # Format the final output string to be compact and match the required structure.\n    # e.g., [[N1,F1,E1],[N2,F2,E2],...]\n    string_reps = [f'[{r[0]},{r[1]},{r[2]}]' for r in all_results]\n    final_output = f'[{\",\".join(string_reps)}]'\n\n    print(final_output)\n\nsolve()\n```", "id": "4920456"}]}