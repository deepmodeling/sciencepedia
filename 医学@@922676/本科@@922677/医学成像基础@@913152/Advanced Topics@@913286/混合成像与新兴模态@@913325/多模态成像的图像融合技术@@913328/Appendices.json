{"hands_on_practices": [{"introduction": "不同的成像模态，例如PET和MRI，其图像的强度标度（intensity scale）差异巨大且通常是任意的。在进行有意义的融合之前，必须对它们的强度进行归一化处理。本实践将引导你推导一个基于图像统计特性的仿射变换，以确保融合过程不会不公平地偏向任何一种模态，从而为多模态图像的定量分析打下坚实基础。[@problem_id:4891123]", "problem": "一家医院的研究实验室旨在通过凸组合融合方法，融合一幅正电子发射断层扫描 (PET) 图像和一幅磁共振 (MR) 幅度图像，以共同可视化新陈代谢和解剖结构。设 PET 图像由逐体素的标准化摄取值 (SUV) 表示，记为 $S$，MR 图像的强度由 $M$ 表示。融合使用模型 $F = w M + (1 - w) g(S)$，其中 $w \\in [0,1]$，$g$ 是一个确定性映射，它将 PET SUV 重新缩放到与 MR 兼容的强度尺度。\n\n为了在不同组织间实现科学上可解释的融合，实验室要求融合不应偏向任何组织的对比度。在操作上，“不偏向组织对比度”意味着，在背景组织水平附近，当 $w = \\frac{1}{2}$ 时，任一模态中相等的标准化变化（一个标准差）会在融合图像中产生等量的变化，并且融合后的背景水平与 MR 的背景水平相匹配。假设对于均匀感兴趣区域内的图像强度，以下经过充分检验的统计事实成立：平均强度 $\\mu$ 和标准差 $\\sigma$ 表征了典型的背景水平和波动尺度，且线性映射能保持排序，并以可控的方式缩放均值和方差。\n\n实验室测量了感兴趣区域的统计数据，发现：\n- MR 均值 $\\mu_{\\mathrm{MR}} = 600$（MR 任意单位）和 MR 标准差 $\\sigma_{\\mathrm{MR}} = 80$，\n- PET 均值 $\\mu_{\\mathrm{PET}} = 2.0$ (SUV) 和 PET 标准差 $\\sigma_{\\mathrm{PET}} = 0.5$ (SUV)。\n\n从均值、方差和凸组合的核心定义出发，并强制执行上述两个约束条件，推导出一个明确的仿射缩放定律 $g(S)$，该定律将 PET SUV 映射到适用于凸组合融合且不偏向组织对比度的 MR 兼容尺度。请将最终的 $g(S)$ 表示为关于 $S$ 的闭式解析表达式，单位为 MR 任意单位。无需四舍五入。", "solution": "用户希望推导一个仿射缩放定律 $g(S)$，用于将 PET 图像强度与 MR 图像强度进行融合。\n\n### 步骤 1：提取已知条件\n- PET 图像体素值 (SUV): $S$\n- MR 图像体素值 (强度): $M$\n- 融合模型: $F = w M + (1 - w) g(S)$\n- 权重因子: $w \\in [0,1]$\n- PET 缩放函数: $g(S)$，一个仿射缩放定律\n- MR 背景统计数据: 均值 $\\mu_{\\mathrm{MR}} = 600$，标准差 $\\sigma_{\\mathrm{MR}} = 80$\n- PET 背景统计数据: 均值 $\\mu_{\\mathrm{PET}} = 2.0$，标准差 $\\sigma_{\\mathrm{PET}} = 0.5$\n- 约束条件 1: 在背景组织水平附近，当 $w = \\frac{1}{2}$ 时，任一模态中相等的标准化变化（一个标准差）会在融合图像中产生等量的变化。\n- 约束条件 2: 融合后的背景水平与 MR 的背景水平相匹配。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，因为 PET-MR 融合是一项标准的医学成像技术。凸组合和仿射缩放的使用是公认的方法。这些约束是客观且可数学形式化的，旨在确保有意义的融合。该问题是适定的，提供了两个约束条件来确定仿射函数的两个参数。所提供的数值是合理的。未检测到任何缺陷。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 仿射缩放定律的推导\n\n问题要求推导一个明确的仿射缩放定律，其通用形式为 $g(S) = aS + b$，其中 $a$ 和 $b$ 是待定常数。我们将利用给定的两个约束条件来建立一个关于 $a$ 和 $b$ 的二元线性方程组。\n\n**约束条件 2 分析：匹配背景水平**\n\n该约束条件指出“融合后的背景水平与 MR 的背景水平相匹配”。背景水平由平均强度来量化。设 $\\mu_F$、$\\mu_{\\mathrm{MR}}$ 和 $\\mu_{g(S)}$ 分别表示融合图像、MR 图像和缩放后 PET 图像的均值。\n\n缩放后 PET 图像的均值 $\\mu_{g(S)}$ 可通过应用期望算子求得：\n$$\n\\mu_{g(S)} = E[g(S)] = E[aS + b]\n$$\n利用期望的线性性质，$E[X+Y] = E[X] + E[Y]$ 和 $E[cX] = cE[X]$：\n$$\n\\mu_{g(S)} = a E[S] + b = a\\mu_{\\mathrm{PET}} + b\n$$\n融合图像的均值 $\\mu_F$ 由下式给出：\n$$\n\\mu_F = E[F] = E[w M + (1 - w) g(S)]\n$$\n假设一个体素的 MR 强度和 PET SUV 是由独立过程生成的，则和的期望等于期望的和：\n$$\n\\mu_F = w E[M] + (1 - w) E[g(S)] = w\\mu_{\\mathrm{MR}} + (1-w)\\mu_{g(S)}\n$$\n约束条件为 $\\mu_F = \\mu_{\\mathrm{MR}}$。将此代入 $\\mu_F$ 的方程中：\n$$\n\\mu_{\\mathrm{MR}} = w\\mu_{\\mathrm{MR}} + (1-w)\\mu_{g(S)}\n$$\n$$\n(1-w)\\mu_{\\mathrm{MR}} = (1-w)\\mu_{g(S)}\n$$\n为使此关系对任意 $w \\in [0, 1)$（即对于任何非平凡的融合）都成立，缩放后的 PET 图像的均值必须等于 MR 图像的均值：\n$$\n\\mu_{g(S)} = \\mu_{\\mathrm{MR}}\n$$\n代入 $\\mu_{g(S)}$ 的表达式，我们得到关于 $a$ 和 $b$ 的第一个方程：\n$$\na\\mu_{\\mathrm{PET}} + b = \\mu_{\\mathrm{MR}} \\quad \\quad (1)\n$$\n\n**约束条件 1 分析：对标准化变化的等敏感性**\n\n该约束条件指出“当 $w = \\frac{1}{2}$ 时，任一模态中相等的标准化变化（一个标准差）会在融合图像中产生等量的变化”。我们可以使用偏导数来形式化表示融合图像 $F$ 相对于输入图像 $M$ 和 $S$ 变化的改变量。\n\n融合图像是两个变量的函数，$F(M, S) = wM + (1-w)g(S)$。$F$ 对 $M$ 微小变化的敏感度为 $\\frac{\\partial F}{\\partial M}$，$F$ 对 $S$ 微小变化的敏感度为 $\\frac{\\partial F}{\\partial S}$。\n$$\n\\frac{\\partial F}{\\partial M} = w\n$$\n$$\n\\frac{\\partial F}{\\partial S} = (1-w) \\frac{d g(S)}{d S} = (1-w)a\n$$\n$M$ 中的一个“标准化变化”被指定为一个标准差，即 $\\sigma_{\\mathrm{MR}}$。由此在 $F$ 中产生的变化记为 $\\Delta F_M$：\n$$\n\\Delta F_M = \\frac{\\partial F}{\\partial M} \\sigma_{\\mathrm{MR}} = w\\sigma_{\\mathrm{MR}}\n$$\n类似地，$S$ 中的一个标准化变化为 $\\sigma_{\\mathrm{PET}}$，由此在 $F$ 中产生的变化记为 $\\Delta F_S$：\n$$\n\\Delta F_S = \\frac{\\partial F}{\\partialS} \\sigma_{\\mathrm{PET}} = (1-w) a \\sigma_{\\mathrm{PET}}\n$$\n约束条件要求当 $w = \\frac{1}{2}$ 时，这些变化的量值相等：\n$$\n|\\Delta F_M| = |\\Delta F_S| \\quad \\text{at } w = \\frac{1}{2}\n$$\n$$\n\\left| \\frac{1}{2} \\sigma_{\\mathrm{MR}} \\right| = \\left| \\left(1 - \\frac{1}{2}\\right) a \\sigma_{\\mathrm{PET}} \\right|\n$$\n由于标准差是非负的，这可以简化为：\n$$\n\\frac{1}{2} \\sigma_{\\mathrm{MR}} = \\frac{1}{2} |a| \\sigma_{\\mathrm{PET}}\n$$\n$$\n\\sigma_{\\mathrm{MR}} = |a| \\sigma_{\\mathrm{PET}}\n$$\n为了使缩放具有科学可解释性，更高的 PET SUV（表示更强的代谢活动）应映射到更高的强度值，这意味着 $a > 0$。因此，我们可以去掉绝对值符号：\n$$\na \\sigma_{\\mathrm{PET}} = \\sigma_{\\mathrm{MR}} \\quad \\quad (2)\n$$\n\n**求解 $a$ 和 $b$**\n\n我们现在有一个包含两个未知数 $a$ 和 $b$ 的二元线性方程组：\n1. $a\\mu_{\\mathrm{PET}} + b = \\mu_{\\mathrm{MR}}$\n2. $a\\sigma_{\\mathrm{PET}} = \\sigma_{\\mathrm{MR}}$\n\n从方程 (2) 中，我们解出 $a$：\n$$\na = \\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}}\n$$\n将 $a$ 的这个表达式代入方程 (1) 来解出 $b$：\n$$\n\\left(\\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}}\\right) \\mu_{\\mathrm{PET}} + b = \\mu_{\\mathrm{MR}}\n$$\n$$\nb = \\mu_{\\mathrm{MR}} - \\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}} \\mu_{\\mathrm{PET}}\n$$\n完整的仿射缩放定律是 $g(S) = aS + b$。代入 $a$ 和 $b$ 的表达式：\n$$\ng(S) = \\left(\\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}}\\right) S + \\left(\\mu_{\\mathrm{MR}} - \\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}} \\mu_{\\mathrm{PET}}\\right)\n$$\n这个表达式可以重新整理成一个更具洞察力的形式：\n$$\ng(S) = \\mu_{\\mathrm{MR}} + \\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}} (S - \\mu_{\\mathrm{PET}})\n$$\n这种形式表明，PET SUV 值 $S$ 首先通过减去其均值 $\\mu_{\\mathrm{PET}}$ 来进行中心化，然后按标准差之比 $\\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}}$ 进行缩放，最后进行平移以匹配 MR 均值 $\\mu_{\\mathrm{MR}}$。\n\n**数值计算**\n\n现在我们代入给定的数值：\n$\\mu_{\\mathrm{MR}} = 600$, $\\sigma_{\\mathrm{MR}} = 80$, $\\mu_{\\mathrm{PET}} = 2.0$, and $\\sigma_{\\mathrm{PET}} = 0.5$。\n\n首先，计算 $a$：\n$$\na = \\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}} = \\frac{80}{0.5} = 160\n$$\n接下来，计算 $b$：\n$$\nb = \\mu_{\\mathrm{MR}} - a \\mu_{\\mathrm{PET}} = 600 - (160)(2.0) = 600 - 320 = 280\n$$\n因此，明确的仿射缩放定律是：\n$$\ng(S) = 160S + 280\n$$\n$g(S)$ 的单位是 MR 任意单位，符合要求。", "answer": "$$\n\\boxed{g(S) = 160S + 280}\n$$", "id": "4891123"}, {"introduction": "在解决了强度对齐问题后，我们还需面对成像物理过程带来的挑战，特别是在PET成像中常见的“部分容积效应”（Partial Volume Effect, PVE）。该效应源于扫描仪有限的空间分辨率，会导致小尺寸或低活性病灶的信号被模糊和低估。本实践是一个编程练习，你将通过实现几何传输矩阵（Geometric Transfer Matrix, GTM）方法来模拟并校正部分容积效应，这是实现精确定量融合的关键预处理步骤。[@problem_id:4891216]", "problem": "给定一个简化的二维多模态成像场景，其中包含合成的病灶模型。“正电子发射断层扫描（PET）”通道被建模为一个具有高斯点扩散函数（PSF）的线性移不变成像系统，“磁共振（MR）”通道提供高分辨率的区域结构分割。测得的 PET 图像被建模为真实活度分布与高斯 PSF 的卷积。目标是使用几何传输矩阵法进行基于区域的部分容积校正，生成校正前后的融合图像，并量化每个病灶的恢复系数。\n\n基本原理：\n- 成像线性系统理论：测得的 PET 图像被建模为真实活度分布与系统 PSF 的卷积，即 $I_{\\mathrm{meas}} = I_{\\mathrm{true}} \\ast h$，其中 $h$ 是归一化的高斯 PSF，$\\ast$ 表示卷积。\n- 基于区域的活度模型：假设真实分布在 $K$ 个具有已知掩模 $\\{M_j\\}_{j=1}^{K}$ 的不相交区域上是分段常数，因此 $I_{\\mathrm{true}}(\\mathbf{r}) = \\sum_{j=1}^{K} C_j M_j(\\mathbf{r})$，其中 $C_j$ 是区域活度（常数）。\n- 几何传输矩阵法：将测得的 PET 图像在感兴趣区域的均值定义为 $m_i = \\frac{1}{|R_i|}\\int_{R_i} I_{\\mathrm{meas}}(\\mathbf{r}) \\, d\\mathbf{r}$，对于掩模为 $M_i$ 的区域 $R_i$，并定义 $G_{ij} = \\frac{1}{|R_i|}\\int_{R_i} (M_j \\ast h)(\\mathbf{r}) \\, d\\mathbf{r}$。那么，测得的区域均值向量 $\\mathbf{m}$ 满足 $\\mathbf{m} = G \\mathbf{C}$，而 $\\mathbf{C}$ 的估计值可通过求解线性系统 $\\hat{\\mathbf{C}} = G^{-1} \\mathbf{m}$ 获得，假设 $G$ 是非奇异的。\n- 病灶 $j$ 的恢复系数：$\\mathrm{RC}_j = \\frac{\\bar{I}_{\\mathrm{region},j}}{C^{\\mathrm{true}}_j}$，其中 $\\bar{I}_{\\mathrm{region},j}$ 是病灶区域 $j$ 内的平均强度，$C^{\\mathrm{true}}_j$ 是真实的区域活度。\n\n您必须为每个测试用例实现以下步骤：\n1. 构建一个像素大小为 $p$（单位 $\\mathrm{mm}$）的 $N \\times N$ 网格，并生成两个圆形病灶掩模和一个背景掩模。真实活度图像为 $I_{\\mathrm{true}}(\\mathbf{r}) = C_1 M_1(\\mathbf{r}) + C_2 M_2(\\mathbf{r}) + C_{\\mathrm{bg}} M_{\\mathrm{bg}}(\\mathbf{r})$，其中 $M_{\\mathrm{bg}} = 1 - M_1 - M_2$。\n2. 通过将 $I_{\\mathrm{true}}$ 与标准差为 $\\sigma$（单位 $\\mathrm{mm}$）的归一化高斯 PSF 进行卷积，生成测得的 PET 图像。PSF 的标准差（以像素为单位）为 $\\sigma_{\\mathrm{px}} = \\sigma / p$。\n3. 在 $M_1$、$M_2$ 和 $M_{\\mathrm{bg}}$ 上计算测得的 PET 图像的区域均值 $m_i$。\n4. 构建几何传输矩阵 $G$，其元素 $G_{ij}$ 通过将每个掩模 $M_j$ 与 PSF 卷积，然后在区域 $i$ 上对结果进行平均来计算。\n5. 使用线性系统 $G \\hat{\\mathbf{C}} = \\mathbf{m}$ 求解经部分容积校正的区域活度 $\\hat{\\mathbf{C}} = [\\hat{C}_1,\\hat{C}_2,\\hat{C}_{\\mathrm{bg}}]^\\top$。构建校正后的 PET 图像 $I_{\\mathrm{corr}}(\\mathbf{r}) = \\hat{C}_1 M_1(\\mathbf{r}) + \\hat{C}_2 M_2(\\mathbf{r}) + \\hat{C}_{\\mathrm{bg}} M_{\\mathrm{bg}}(\\mathbf{r})$。\n6. 计算病灶 $1$ 和 $2$ 在校正前的恢复系数 $\\mathrm{RC}^{\\mathrm{before}}_j = \\frac{\\bar{I}_{\\mathrm{meas},j}}{C^{\\mathrm{true}}_j}$ 和校正后的恢复系数 $\\mathrm{RC}^{\\mathrm{after}}_j = \\frac{\\bar{I}_{\\mathrm{corr},j}}{C^{\\mathrm{true}}_j}$，其中 $\\bar{I}_{\\mathrm{meas},j}$ 和 $\\bar{I}_{\\mathrm{corr},j}$ 分别是病灶 $j$ 内 $I_{\\mathrm{meas}}$ 和 $I_{\\mathrm{corr}}$ 的平均强度。这些值是无单位的。\n7. 使用与结构图像进行简单强度混合的方法，创建校正前后的融合图像。定义一个结构图像 $S$，为病灶分配高强度值，为背景分配较低的值，例如 $S = s_{\\ell}(M_1 + M_2) + s_{\\mathrm{bg}} M_{\\mathrm{bg}}$，其中 $s_{\\ell} = 0.8$ 且 $s_{\\mathrm{bg}} = 0.2$。通过最小-最大归一化将 $S$ 和 PET 图像均归一化到 $[0,1]$，并计算 $F_{\\mathrm{before}} = \\alpha S_{\\mathrm{norm}} + (1-\\alpha) I_{\\mathrm{meas,norm}}$ 和 $F_{\\mathrm{after}} = \\alpha S_{\\mathrm{norm}} + (1-\\alpha) I_{\\mathrm{corr,norm}}$，其中 $\\alpha = 0.5$。您无需输出融合图像，但必须计算它们。\n\n所有图像均为二维数组。强度单位为任意单位。长度尺度必须以 $\\mathrm{mm}$ 处理，并按规定进行像素尺寸转换。不使用角度。恢复系数必须以无单位的小数形式报告。\n\n测试套件：\n- 所有测试用例通用参数：图像大小 $N = 128$ 像素，像素大小 $p = 1.0 \\ \\mathrm{mm}$/像素，融合混合参数 $\\alpha = 0.5$，结构图像强度 $s_{\\ell} = 0.8$，$s_{\\mathrm{bg}} = 0.2$。\n- 用例 $1$：\n  - 病灶直径：$d_1 = 12.0 \\ \\mathrm{mm}$，$d_2 = 6.0 \\ \\mathrm{mm}$。\n  - 病灶中心（以像素为单位）：$(x_1,y_1) = (48,64)$，$(x_2,y_2) = (80,64)$。\n  - 真实活度：$C_1 = 5.0$，$C_2 = 3.5$，$C_{\\mathrm{bg}} = 1.0$。\n  - PSF 标准差：$\\sigma = 2.5 \\ \\mathrm{mm}$。\n- 用例 $2$：\n  - 病灶直径：$d_1 = 4.0 \\ \\mathrm{mm}$，$d_2 = 8.0 \\ \\mathrm{mm}$。\n  - 病灶中心（以像素为单位）：$(x_1,y_1) = (40,64)$，$(x_2,y_2) = (92,64)$。\n  - 真实活度：$C_1 = 6.0$，$C_2 = 4.0$，$C_{\\mathrm{bg}} = 1.0$。\n  - PSF 标准差：$\\sigma = 3.0 \\ \\mathrm{mm}$。\n- 用例 $3$：\n  - 病灶直径：$d_1 = 10.0 \\ \\mathrm{mm}$，$d_2 = 10.0 \\ \\mathrm{mm}$。\n  - 病灶中心（以像素为单位）：$(x_1,y_1) = (60,64)$，$(x_2,y_2) = (74,64)$。\n  - 真实活度：$C_1 = 5.0$，$C_2 = 2.0$，$C_{\\mathrm{bg}} = 1.2$。\n  - PSF 标准差：$\\sigma = 3.5 \\ \\mathrm{mm}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 对于每个测试用例，按顺序附加：$\\mathrm{RC}^{\\mathrm{before}}_1$、$\\mathrm{RC}^{\\mathrm{before}}_2$、$\\mathrm{RC}^{\\mathrm{after}}_1$、$\\mathrm{RC}^{\\mathrm{after}}_2$，每个值都四舍五入到 $4$ 位小数。\n- 因此，最终输出将是一个包含 $12$ 个浮点数的扁平列表，按顺序对应于用例 $1$、$2$ 和 $3$，总共有 $12$ 个条目。\n\n您的程序必须为提供的测试套件严格实现上述步骤，并按指定格式打印结果。不允许用户输入或使用外部文件。输出为无单位小数，四舍五入到 $4$ 位小数。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于应用于医学成像，特别是正电子发射断层扫描（PET）的线性系统理论原理。该问题是适定的（well-posed），提供了所有必要的参数和清晰、客观的计算所需量的程序。指定的方法，即用于部分容积校正的几何传输矩阵（GTM）法，是该领域中一种标准且公认的技术。为合成模型提供的参数对于模拟研究是切合实际的。\n\n解决方案通过实现问题陈述中概述的步骤来进行。问题的核心是校正部分容积效应，这是由于扫描仪空间分辨率有限而导致的 PET 成像定量准确性下降的现象。这种效应导致在小区域内测得的活度是其真实活度与其周围环境活度的混合。GTM 方法通过对预定义区域之间的信号“溢出”进行建模来校正此问题。\n\n成像过程的基本模型是一个线性移不变系统，由卷积方程描述：\n$$\nI_{\\mathrm{meas}}(\\mathbf{r}) = (I_{\\mathrm{true}} \\ast h)(\\mathbf{r}) = \\int I_{\\mathrm{true}}(\\mathbf{r}') h(\\mathbf{r} - \\mathbf{r}') \\, d\\mathbf{r}'\n$$\n其中 $I_{\\mathrm{true}}(\\mathbf{r})$ 是放射性示踪剂活度的真实空间分布，$h(\\mathbf{r})$ 是系统的点扩散函数（PSF），而 $I_{\\mathrm{meas}}(\\mathbf{r})$ 是最终测得的图像。对于此问题，PSF 是一个标准差为 $\\sigma$ 的归一化二维高斯函数。\n\n真实活度分布被定义为在 $K=3$ 个不相交区域（两个病灶和一个背景）上是分段常数：\n$$\nI_{\\mathrm{true}}(\\mathbf{r}) = C_1 M_1(\\mathbf{r}) + C_2 M_2(\\mathbf{r}) + C_{\\mathrm{bg}} M_{\\mathrm{bg}}(\\mathbf{r})\n$$\n此处，$C_j$ 是每个区域内真实的、未知的恒定活度，$M_j(\\mathbf{r})$ 是相应的二值掩模（区域内为 $1$，区域外为 $0$），这些掩模被假定从像 MR 这样的高分辨率模态中已知。\n\nGTM 方法将真实活度向量 $\\mathbf{C} = [C_1, C_2, C_{\\mathrm{bg}}]^\\top$ 与测得的平均活度向量 $\\mathbf{m} = [m_1, m_2, m_{\\mathrm{bg}}]^\\top$ 相关联，其中 $m_i$ 是区域 $i$ 上 $I_{\\mathrm{meas}}$ 的平均值。这种关系是线性系统 $\\mathbf{m} = G\\mathbf{C}$。几何传输矩阵 $G$ 的元素 $G_{ij}$ 代表从区域 $j$ “溢出”到区域 $i$ 测量中的信号分数。\n\n算法流程如下：\n\n1.  **模型生成**：对于每个测试用例，我们构建一个离散的 $N \\times N$ 网格，其中 $N=128$。像素大小为 $p=1.0 \\ \\mathrm{mm}$。在此网格上，我们生成二值掩模 $M_1$、$M_2$ 和 $M_{\\mathrm{bg}}$。$M_1$ 和 $M_2$ 是由其中心 $(x_j, y_j)$ 和直径 $d_j$ 定义的圆形掩模。背景掩模是 $M_{\\mathrm{bg}} = 1 - M_1 - M_2$。使用真实活度 $C_1, C_2, C_{\\mathrm{bg}}$，合成真实活度图像 $I_{\\mathrm{true}}$。\n\n2.  **图像模糊**：通过将真实图像 $I_{\\mathrm{true}}$ 与归一化的高斯 PSF $h$ 进行卷积，来模拟测得的 PET 图像 $I_{\\mathrm{meas}}$。PSF 的标准差以 $\\mathrm{mm}$ 为单位给出，即 $\\sigma$，并转换为像素单位 $\\sigma_{\\mathrm{px}} = \\sigma/p$。此卷积可使用数字高斯滤波器高效实现。\n    $$\n    I_{\\mathrm{meas}} = I_{\\mathrm{true}} \\ast h\n    $$\n\n3.  **测量均值计算**：对于每个区域 $i \\in \\{1, 2, \\mathrm{bg}\\}$，通过对掩模 $M_i$ 内 $I_{\\mathrm{meas}}$ 的像素值进行平均来计算测量的平均活度 $m_i$。在离散形式下，对于区域 $i$：\n    $$\n    m_i = \\frac{\\sum_{\\mathbf{p}} (I_{\\mathrm{meas}})_{\\mathbf{p}} (M_i)_{\\mathbf{p}}}{\\sum_{\\mathbf{p}} (M_i)_{\\mathbf{p}}}\n    $$\n    其中，求和遍及网格中的所有像素 $\\mathbf{p}$。\n\n4.  **几何传输矩阵构建**：构建 $3 \\times 3$ 矩阵 $G$。每个元素 $G_{ij}$ 的计算方法是：首先将源区域的掩模 $M_j$ 与 PSF $h$ 卷积，然后将得到的模糊掩模在“目标”区域 $M_i$ 上进行平均。\n    $$\n    G_{ij} = \\frac{\\sum_{\\mathbf{p}} ((M_j \\ast h)_{\\mathbf{p}} (M_i)_{\\mathbf{p}})}{\\sum_{\\mathbf{p}} (M_i)_{\\mathbf{p}}}\n    $$\n    该矩阵量化了所有区域对之间的空间串扰。\n\n5.  **部分容积校正**：利用测量的均值向量 $\\mathbf{m}$ 和矩阵 $G$，我们求解线性方程组 $G\\hat{\\mathbf{C}} = \\mathbf{m}$，以找到估计的或经部分容积校正的活度 $\\hat{\\mathbf{C}} = [\\hat{C}_1, \\hat{C}_2, \\hat{C}_{\\mathrm{bg}}]^\\top$。\n    $$\n    \\hat{\\mathbf{C}} = G^{-1}\\mathbf{m}\n    $$\n    这可通过标准的线性代数求解器实现。然后，使用这些估计的活度合成校正后的图像 $I_{\\mathrm{corr}}$：$I_{\\mathrm{corr}} = \\hat{C}_1 M_1 + \\hat{C}_2 M_2 + \\hat{C}_{\\mathrm{bg}} M_{\\mathrm{bg}}$。\n\n6.  **恢复系数定量**：为评估校正性能，我们为每个病灶计算恢复系数（RC）。RC 是测量或估计的平均活度与真实活度的比率。\n    校正前，对于病灶 $j \\in \\{1, 2\\}$：\n    $$\n    \\mathrm{RC}^{\\mathrm{before}}_j = \\frac{m_j}{C^{\\mathrm{true}}_j}\n    $$\n    校正后，根据构造，校正图像 $I_{\\mathrm{corr}}$ 在区域 $j$ 的平均活度恰好是 $\\hat{C}_j$。因此，校正后的 RC 为：\n    $$\n    \\mathrm{RC}^{\\mathrm{after}}_j = \\frac{\\hat{C}_j}{C^{\\mathrm{true}}_j}\n    $$\n    RC 为 $1.0$ 表示完美恢复了真实活度。\n\n7.  **图像融合**：虽然不是最终数值输出的一部分，但仍需生成融合图像。创建一个结构图像 $S = s_{\\ell}(M_1+M_2) + s_{\\mathrm{bg}}M_{\\mathrm{bg}}$。将 PET 图像（$I_{\\mathrm{meas}}$, $I_{\\mathrm{corr}}$）和结构图像 $S$ 归一化到 $[0, 1]$ 范围。然后通过加权和创建融合图像，例如 $F_{\\mathrm{before}} = \\alpha S_{\\mathrm{norm}} + (1-\\alpha) I_{\\mathrm{meas,norm}}$，其中 $\\alpha=0.5$。\n\n将此完整流程应用于三个测试用例中的每一个，并计算和报告每个用例的四个恢复系数（$\\mathrm{RC}^{\\mathrm{before}}_1, \\mathrm{RC}^{\\mathrm{before}}_2, \\mathrm{RC}^{\\mathrm{after}}_1, \\mathrm{RC}^{\\mathrm{after}}_2$）。", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import gaussian_filter\n\ndef solve():\n    \"\"\"\n    Solves the partial volume correction problem for the given test suite.\n    \"\"\"\n    \n    # Common parameters for all test cases\n    N = 128\n    p = 1.0  # mm/pixel\n    alpha = 0.5\n    s_l = 0.8\n    s_bg = 0.2\n\n    test_cases = [\n        # Case 1\n        {'d': (12.0, 6.0), 'center': ((48, 64), (80, 64)), 'C_true': (5.0, 3.5, 1.0), 'sigma': 2.5},\n        # Case 2\n        {'d': (4.0, 8.0), 'center': ((40, 64), (92, 64)), 'C_true': (6.0, 4.0, 1.0), 'sigma': 3.0},\n        # Case 3\n        {'d': (10.0, 10.0), 'center': ((60, 64), (74, 64)), 'C_true': (5.0, 2.0, 1.2), 'sigma': 3.5},\n    ]\n\n    all_results = []\n    \n    # Create coordinate grid for mask generation\n    # yy corresponds to rows (y-coordinate), xx to columns (x-coordinate)\n    yy, xx = np.mgrid[:N, :N]\n\n    for case in test_cases:\n        # Step 1: Construct true image and masks\n        radii_mm = (case['d'][0] / 2.0, case['d'][1] / 2.0)\n        radii_px = [r / p for r in radii_mm]\n        centers_px = case['center'] # (x, y) = (col, row)\n        \n        dist_sq_1 = (xx - centers_px[0][0])**2 + (yy - centers_px[0][1])**2\n        dist_sq_2 = (xx - centers_px[1][0])**2 + (yy - centers_px[1][1])**2\n        \n        M1 = (dist_sq_1 = radii_px[0]**2).astype(float)\n        M2 = (dist_sq_2 = radii_px[1]**2).astype(float)\n        M_bg = 1.0 - M1 - M2\n        \n        masks = [M1, M2, M_bg]\n        region_pixels = [np.sum(m) for m in masks]\n\n        C_true_vec = np.array(case['C_true'])\n        I_true = C_true_vec[0] * M1 + C_true_vec[1] * M2 + C_true_vec[2] * M_bg\n        \n        # Step 2: Generate the measured PET image by convolution\n        sigma_px = case['sigma'] / p\n        I_meas = gaussian_filter(I_true, sigma=sigma_px, mode='reflect')\n\n        # Step 3: Compute the region-wise means of the measured image\n        m_measured = np.array([np.sum(I_meas * M) / num_pix if num_pix > 0 else 0 \n                               for M, num_pix in zip(masks, region_pixels)])\n\n        # Step 4: Form the geometric transfer matrix G\n        G = np.zeros((3, 3))\n        for j in range(3):  # For each source region mask M_j\n            M_j_blurred = gaussian_filter(masks[j], sigma=sigma_px, mode='reflect')\n            for i in range(3):  # For each target region of interest M_i\n                if region_pixels[i] > 0:\n                    G[i, j] = np.sum(M_j_blurred * masks[i]) / region_pixels[i]\n                else:\n                    G[i, j] = 0\n\n        # Step 5: Solve for corrected activities and create corrected image\n        try:\n            C_hat = np.linalg.solve(G, m_measured)\n        except np.linalg.LinAlgError:\n            # In case of a singular matrix, use pseudo-inverse\n            C_hat = np.linalg.pinv(G) @ m_measured\n        \n        I_corr = C_hat[0] * M1 + C_hat[1] * M2 + C_hat[2] * M_bg\n\n        # Step 6: Compute recovery coefficients\n        RC_before_1 = m_measured[0] / C_true_vec[0]\n        RC_before_2 = m_measured[1] / C_true_vec[1]\n        \n        # Mean of corrected image in region j is C_hat_j by construction\n        RC_after_1 = C_hat[0] / C_true_vec[0]\n        RC_after_2 = C_hat[1] / C_true_vec[1]\n        \n        # Step 7: Create fused images (as required by problem, though not directly output)\n        S = s_l * (M1 + M2) + s_bg * M_bg\n        \n        def normalize(img):\n            min_val = np.min(img)\n            max_val = np.max(img)\n            if max_val == min_val:\n                return np.zeros_like(img) \n            return (img - min_val) / (max_val - min_val)\n\n        S_norm = normalize(S)\n        I_meas_norm = normalize(I_meas)\n        I_corr_norm = normalize(I_corr)\n        \n        F_before = alpha * S_norm + (1 - alpha) * I_meas_norm\n        F_after = alpha * S_norm + (1 - alpha) * I_corr_norm\n        \n        # Append results for the current case to the main list\n        case_results = [RC_before_1, RC_before_2, RC_after_1, RC_after_2]\n        all_results.extend(case_results)\n\n    # Format the final output string\n    final_output_str = [f\"{r:.4f}\" for r in all_results]\n    print(f\"[{','.join(final_output_str)}]\")\n\nsolve()\n```", "id": "4891216"}, {"introduction": "掌握了预处理技术后，我们将探索超越简单加权平均的现代融合框架。本节介绍一种先进的变分方法，通过求解一个优化问题来寻找“最佳”的融合图像。你将动手实现一种前沿的近端梯度算法，在小波域中融合图像，并利用稀疏性正则化项智能地结合两种模态的特征，这代表了当前医学图像融合领域的研究前沿。[@problem_id:4891205]", "problem": "给定两个大小为 $N \\times N$（其中 $N$ 为偶数）的无单位模态图像 $y^{(1)}$ 和 $y^{(2)}$，以及一个作用于 $\\mathbb{R}^{N \\times N}$ 的单层、正交二维Haar小波变换 $W$。融合变量是小波域系数张量 $c \\in \\mathbb{R}^{4 \\times \\frac{N}{2} \\times \\frac{N}{2}}$，它堆叠了四个子带 $(\\mathrm{LL}, \\mathrm{LH}, \\mathrm{HL}, \\mathrm{HH})$。设保真度权重为 $\\alpha_1, \\alpha_2  0$ 并定义凸目标函数\n$$\nF(c) = \\frac{1}{2} \\sum_{m=1}^{2} \\alpha_m \\left\\| c - W y^{(m)} \\right\\|_2^2 + \\lambda \\sum_{i=1}^{\\frac{N}{2}} \\sum_{j=1}^{\\frac{N}{2}} \\left\\| \\begin{bmatrix} c_{\\mathrm{LH}}[i,j] \\\\ c_{\\mathrm{HL}}[i,j] \\\\ c_{\\mathrm{HH}}[i,j] \\end{bmatrix} \\right\\|_2,\n$$\n其中第二项是混合范数，它对每个空间位置 $(i,j)$ 处的高频系数三元组应用 $\\ell_2$-范数，然后将所得的模相加（即 $\\ell_{2,1}$ 范数）。低频系数 $c_{\\mathrm{LL}}$ 不受惩罚。此处的离散小波变换（DWT）指的是正交单层二维Haar变换，而近端梯度法（PGM）指的是一种迭代方法，它交替执行对光滑部分的梯度下降步骤和对非光滑部分的近端操作。\n\n从以下基本点出发：\n- 二次保真度项的梯度是Lipschitz连续的，其常数为 $L  0$，\n- 可分离范数和的近端算子在每个 $(i,j)$ 位置上按组作用，\n推导 $c$ 的近端梯度迭代，其步长为常数，等于梯度Lipschitz常数的倒数，并实现该迭代。您还必须推导并实现作用于每个空间位置 $(i,j)$ 处三元组 $\\left(c_{\\mathrm{LH}}[i,j], c_{\\mathrm{HL}}[i,j], c_{\\mathrm{HH}}[i,j]\\right)$ 的混合范数的近端算子。\n\n在优化 $c$ 之后，重建融合图像 $x^\\star = W^\\top c^\\star$ 并计算下面每个测试用例的最终目标值 $F(c^\\star)$。所有输出均为无单位实数。\n\n实现细节和要求：\n- 使用单层正交Haar DWT $W$ 及其逆变换 $W^\\top$，为 $N \\times N$（$N$为偶数）的图像进行显式实现。\n- 使用等于保真度项梯度之Lipschitz常数倒数的恒定步长。\n- 精确运行 $K$ 次迭代，其中 $K$ 在测试套件中指定。\n\n测试套件（每个用例定义 $y^{(1)}$、$y^{(2)}$、$\\alpha_1$、$\\alpha_2$、$\\lambda$、$K$）：\n- 用例1（正常路径）：\n  - $N = 4$\n  - $y^{(1)} = \\begin{bmatrix} 0  1  0  1 \\\\ 1  0  1  0 \\\\ 0  1  0  1 \\\\ 1  0  1  0 \\end{bmatrix}$\n  - $y^{(2)} = \\begin{bmatrix} 1  1  1  1 \\\\ 1  2  2  1 \\\\ 1  2  2  1 \\\\ 1  1  1  1 \\end{bmatrix}$\n  - $\\alpha_1 = 1.0$, $\\alpha_2 = 1.0$, $\\lambda = 0.2$, $K = 200$\n- 用例2（边界情况，无正则化）：\n  - $N = 4$\n  - $y^{(1)} = \\begin{bmatrix} 0  1  0  1 \\\\ 1  0  1  0 \\\\ 0  1  0  1 \\\\ 1  0  1  0 \\end{bmatrix}$\n  - $y^{(2)} = \\begin{bmatrix} 1  1  1  1 \\\\ 1  2  2  1 \\\\ 1  2  2  1 \\\\ 1  1  1  1 \\end{bmatrix}$\n  - $\\alpha_1 = 1.0$, $\\alpha_2 = 1.0$, $\\lambda = 0.0$, $K = 200$\n- 用例3（边缘情况，模态相同）：\n  - $N = 4$\n  - $y^{(1)} = \\begin{bmatrix} 2  2  2  2 \\\\ 2  2  2  2 \\\\ 2  2  2  2 \\\\ 2  2  2  2 \\end{bmatrix}$\n  - $y^{(2)} = \\begin{bmatrix} 2  2  2  2 \\\\ 2  2  2  2 \\\\ 2  2  2  2 \\\\ 2  2  2  2 \\end{bmatrix}$\n  - $\\alpha_1 = 1.0$, $\\alpha_2 = 1.0$, $\\lambda = 0.5$, $K = 200$\n- 用例4（不同模态权重）：\n  - $N = 4$\n  - $y^{(1)} = \\begin{bmatrix} 0  1  0  1 \\\\ 1  0  1  0 \\\\ 0  1  0  1 \\\\ 1  0  1  0 \\end{bmatrix}$\n  - $y^{(2)} = \\begin{bmatrix} 0  0  0  0 \\\\ 0  3  3  0 \\\\ 0  3  3  0 \\\\ 0  0  0  0 \\end{bmatrix}$\n  - $\\alpha_1 = 3.0$, $\\alpha_2 = 0.5$, $\\lambda = 0.1$, $K = 200$\n\n您的程序应生成单行输出，其中包含四个用例的最终目标值 $F(c^\\star)$，以逗号分隔的列表形式封装在方括号中，并按上述用例顺序排列（例如，`[0.123,0.456,0.789,1.234]`）。输出为无单位实数。", "solution": "用户希望使用近端梯度法（PGM）解决一个用于图像融合的凸优化问题。我将首先验证问题陈述，然后推导必要的数学组件，最后构建解决方案。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n- **模态图像**：两个大小为 $N \\times N$（$N$为偶数）的无单位图像 $y^{(1)}, y^{(2)}$。\n- **小波变换**：一个单层、正交二维Haar小波变换 $W: \\mathbb{R}^{N \\times N} \\to \\mathbb{R}^{4 \\times \\frac{N}{2} \\times \\frac{N}{2}}$。其伴随（逆）变换为 $W^\\top$。\n- **优化变量**：小波系数张量 $c \\in \\mathbb{R}^{4 \\times \\frac{N}{2} \\times \\frac{N}{2}}$，由四个子带 $\\{c_{\\mathrm{LL}}, c_{\\mathrm{LH}}, c_{\\mathrm{HL}}, c_{\\mathrm{HH}}\\}$ 组成。\n- **目标函数**：\n$$\nF(c) = \\frac{1}{2} \\sum_{m=1}^{2} \\alpha_m \\left\\| c - W y^{(m)} \\right\\|_2^2 + \\lambda \\sum_{i=1}^{\\frac{N}{2}} \\sum_{j=1}^{\\frac{N}{2}} \\left\\| \\begin{bmatrix} c_{\\mathrm{LH}}[i,j] \\\\ c_{\\mathrm{HL}}[i,j] \\\\ c_{\\mathrm{HH}}[i,j] \\end{bmatrix} \\right\\|_2\n$$\n- **参数**：保真度权重 $\\alpha_1, \\alpha_2  0$；正则化参数 $\\lambda \\ge 0$。\n- **算法**：近端梯度法（PGM），使用恒定步长 $\\tau=1/L$，其中 $L$ 是 $F(c)$ 光滑部分的梯度之Lipschitz常数。\n- **迭代次数**：精确 $K$ 次迭代。\n- **最终输出**：$K$ 次迭代后的系数张量 $c^\\star$ 所对应的目标函数值 $F(c^\\star)$。\n- **测试套件**：四个测试用例，指定了 $N, y^{(1)}, y^{(2)}, \\alpha_1, \\alpha_2, \\lambda, K$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n- **科学性**：该问题描述了一个用于多模态图像融合的标准且成熟的变分模型。目标函数由一个二次数据保真度项和一个混合范数正则化项（$\\ell_{2,1}$-范数）组成，这是促进小波系数群稀疏性的常见选择。使用PGM是解决此类非光滑凸优化问题的先进方法。Haar小波变换是信号处理中的一个基本工具。该公式在科学和数学上都是合理的。\n- **适定性**：目标函数 $F(c)$ 是一个严格凸的二次函数（对于 $\\alpha_1, \\alpha_2  0$）与一个凸的非光滑函数之和。因此，该和是严格凸的，保证了唯一最小化子的存在。该问题是适定的。\n- **客观性**：问题陈述使用了精确的数学符号和客观语言，没有歧义或主观论断。\n- **完整性与一致性**：问题提供了完整解决方案所需的所有数据和参数。提供的测试用例是完整的，没有内部矛盾。\n- **现实性**：该设置是计算成像中的一个标准模型，在此背景下完全现实。\n- **结构**：问题结构清晰。要求运行 K 次迭代，尽管特定的步长选择会导致一步收敛，但这应被视为一个必须遵循的指令，而非使其无效的缺陷。该算法的行为是问题有效的数学结构的直接结果。\n\n**步骤3：结论与行动**\n\n此问题是**有效的**。将继续进行求解过程。\n\n### 近端梯度法迭代的推导\n\n目标函数 $F(c)$ 可以分解为一个光滑可微部分 $g(c)$ 和一个非光滑凸部分 $h(c)$。\n$$ F(c) = g(c) + h(c) $$\n其中\n$$ g(c) = \\frac{1}{2} \\sum_{m=1}^{2} \\alpha_m \\left\\| c - W y^{(m)} \\right\\|_2^2 $$\n$$ h(c) = \\lambda \\sum_{i=1}^{\\frac{N}{2}} \\sum_{j=1}^{\\frac{N}{2}} \\left\\| \\begin{bmatrix} c_{\\mathrm{LH}}[i,j] \\\\ c_{\\mathrm{HL}}[i,j] \\\\ c_{\\mathrm{HH}}[i,j] \\end{bmatrix} \\right\\|_2 $$\n为简化符号，令 $c_m = W y^{(m)}$。对于张量 $A$，平方$\\ell_2$-范数 $\\|A\\|_2^2$ 被解释为Frobenius范数的平方，即其所有元素平方和。\n\n**1. 光滑部分的梯度，$\\nabla g(c)$**\n\n函数 $g(c)$ 是 $c$ 的二次函数。其梯度通过对 $c$ 求导得到：\n$$ \\nabla g(c) = \\sum_{m=1}^{2} \\alpha_m (c - c_m) = (\\alpha_1 + \\alpha_2)c - (\\alpha_1 c_1 + \\alpha_2 c_2) $$\n\n**2. 梯度的Lipschitz常数，$L$**\n\n$\\nabla g(c)$ 的Lipschitz常数 $L$ 是其Hessian矩阵的谱范数。$g(c)$ 的Hessian矩阵为：\n$$ \\nabla^2 g(c) = (\\alpha_1 + \\alpha_2) I $$\n其中 $I$ 是单位算子。Lipschitz常数是Hessian矩阵的最大特征值（的绝对值），显然为：\n$$ L = \\alpha_1 + \\alpha_2 $$\n问题指定了恒定步长 $\\tau = 1/L$。\n$$ \\tau = \\frac{1}{\\alpha_1 + \\alpha_2} $$\n\n**3. 近端梯度法迭代**\n\nPGM的更新规则由下式给出：\n$$ c^{(k+1)} = \\mathrm{prox}_{\\tau h}\\left(c^{(k)} - \\tau \\nabla g(c^{(k)})\\right) $$\n让我们分析近端算子的参数：\n$$ c^{(k)} - \\tau \\nabla g(c^{(k)}) = c^{(k)} - \\frac{1}{\\alpha_1 + \\alpha_2} \\left( (\\alpha_1 + \\alpha_2)c^{(k)} - (\\alpha_1 c_1 + \\alpha_2 c_2) \\right) $$\n$$ = c^{(k)} - c^{(k)} + \\frac{\\alpha_1 c_1 + \\alpha_2 c_2}{\\alpha_1 + \\alpha_2} $$\n$$ = \\frac{\\alpha_1 W y^{(1)} + \\alpha_2 W y^{(2)}}{\\alpha_1 + \\alpha_2} $$\n让我们将这个常数张量表示为 $\\bar{c}$：\n$$ \\bar{c} = \\frac{\\alpha_1 W y^{(1)} + \\alpha_2 W y^{(2)}}{\\alpha_1 + \\alpha_2} $$\n近端算子的参数与迭代次数 $k$ 无关。更新规则简化为：\n$$ c^{(k+1)} = \\mathrm{prox}_{\\tau h}(\\bar{c}) $$\n这意味着迭代序列 $c^{(k)}$ 在一步之内就收敛到解 $c^\\star = \\mathrm{prox}_{\\tau h}(\\bar{c})$。尽管如此，我们将按照要求实现 $K$ 次迭代的循环。\n\n**4. 非光滑部分的近端算子，$\\mathrm{prox}_{\\tau h}(z)$**\n\n非光滑项 $h(c)$ 是系数不相交组的范数之和。这种可分离性使得近端算子可以按组计算。\n正则化不适用于低频子带 $c_{\\mathrm{LL}}$，因此对于这些系数，$h(c)$ 为零。所以，近端算子对于该子带是恒等映射：\n$$ (\\mathrm{prox}_{\\tau h}(z))_{\\mathrm{LL}} = z_{\\mathrm{LL}} $$\n对于高频（细节）子带，在每个空间位置 $(i,j)$，我们必须求解：\n$$ \\arg\\min_{v \\in \\mathbb{R}^3} \\left( \\frac{1}{2} \\| v - u \\|_2^2 + \\tau \\lambda \\|v\\|_2 \\right) $$\n其中 $u = \\begin{bmatrix} z_{\\mathrm{LH}}[i,j] \\\\ z_{\\mathrm{HL}}[i,j] \\\\ z_{\\mathrm{HH}}[i,j] \\end{bmatrix}$ 是输入张量 $z$ 在该位置的系数向量。这是缩放$\\ell_2$-范数的近端算子，也称为向量软阈值或组软阈值。解为：\n$$ \\mathrm{prox}_{\\tau\\lambda \\|\\cdot\\|_2}(u) = \\left( 1 - \\frac{\\tau \\lambda}{\\|u\\|_2} \\right)_+ u = \\max\\left(0, 1 - \\frac{\\tau \\lambda}{\\|u\\|_2}\\right) u $$\n其中 $(\\cdot)_+ = \\max(0, \\cdot)$。\n在实践中，对于每个 $(i,j)$：\n1. 提取向量 $u = (z_{\\mathrm{LH}}[i,j], z_{\\mathrm{HL}}[i,j], z_{\\mathrm{HH}}[i,j])$。\n2. 计算其 $\\ell_2$-范数，$n = \\|u\\|_2$。\n3. 如果 $n  \\tau \\lambda$，更新后的向量是 $\\left(1 - \\frac{\\tau \\lambda}{n}\\right) u$。\n4. 如果 $n \\le \\tau \\lambda$，更新后的向量是 $(0, 0, 0)$。\n\n### 最终算法总结\n1.  对于每个输入图像 $y^{(m)}$，计算其小波变换 $c_m = W y^{(m)}$。\n2.  计算Lipschitz常数 $L = \\alpha_1 + \\alpha_2$ 和步长 $\\tau = 1/L$。\n3.  初始化系数张量 $c^{(0)}$（例如，全零）。\n4.  对于 $k = 0, \\dots, K-1$：\n    a. 计算梯度下降更新的参数：$z = c^{(k)} - \\tau \\nabla g(c^{(k)})$。如前所推导，这简化为常数 $\\bar{c} = (\\alpha_1 c_1 + \\alpha_2 c_2)/L$。\n    b. 应用近端算子得到 $c^{(k+1)} = \\mathrm{prox}_{\\tau h}(z)$。\n        i.  LL子带直接通过：$(c^{(k+1)})_{\\mathrm{LL}} = z_{\\mathrm{LL}}$。\n        ii. 对于 $\\frac{N}{2} \\times \\frac{N}{2}$ 子带中的每个空间索引 $(i,j)$，对细节系数三元组 $(z_{\\mathrm{LH}}[i,j], z_{\\mathrm{HL}}[i,j], z_{\\mathrm{HH}}[i,j])$ 应用向量软阈值，阈值为 $\\tau\\lambda$。\n5.  $K$ 次迭代后，结果为 $c^\\star = c^{(K)}$。\n6.  计算最终目标值 $F(c^\\star)$：\n    $F(c^\\star) = \\frac{1}{2} \\alpha_1 \\| c^\\star - c_1 \\|_2^2 + \\frac{1}{2} \\alpha_2 \\| c^\\star - c_2 \\|_2^2 + \\lambda \\sum_{i,j} \\|(c^\\star_{\\mathrm{LH}}[i,j], c^\\star_{\\mathrm{HL}}[i,j], c^\\star_{\\mathrm{HH}}[i,j])\\|_2$。\n\n这个完整且合理的程序将被实现，以解决给定测试用例的问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the image fusion problem for all test cases.\n    \"\"\"\n    \n    # Test suite from the problem statement\n    test_cases = [\n        {\n            \"N\": 4,\n            \"y1\": np.array([[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]),\n            \"y2\": np.array([[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1]]),\n            \"alpha1\": 1.0, \"alpha2\": 1.0, \"lam\": 0.2, \"K\": 200\n        },\n        {\n            \"N\": 4,\n            \"y1\": np.array([[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]),\n            \"y2\": np.array([[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1]]),\n            \"alpha1\": 1.0, \"alpha2\": 1.0, \"lam\": 0.0, \"K\": 200\n        },\n        {\n            \"N\": 4,\n            \"y1\": np.array([[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]),\n            \"y2\": np.array([[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]),\n            \"alpha1\": 1.0, \"alpha2\": 1.0, \"lam\": 0.5, \"K\": 200\n        },\n        {\n            \"N\": 4,\n            \"y1\": np.array([[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]),\n            \"y2\": np.array([[0, 0, 0, 0], [0, 3, 3, 0], [0, 3, 3, 0], [0, 0, 0, 0]]),\n            \"alpha1\": 3.0, \"alpha2\": 0.5, \"lam\": 0.1, \"K\": 200\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_single_case(params)\n        results.append(result)\n        \n    # Format the final output string\n    output_str = f\"[{','.join(f'{r:.7f}' for r in results)}]\"\n    print(output_str)\n\ndef _haar_1d(v):\n    \"\"\"Computes the 1D orthonormal Haar wavelet transform.\"\"\"\n    N = len(v)\n    if N  2: return v\n    N_half = N // 2\n    v_even = v[::2]\n    v_odd = v[1::2]\n    sqrt2_inv = 1 / np.sqrt(2.0)\n    averages = (v_even + v_odd) * sqrt2_inv\n    details = (v_even - v_odd) * sqrt2_inv\n    return np.concatenate((averages, details))\n\ndef _dwt2(image):\n    \"\"\"Computes the 2D orthonormal single-level Haar wavelet transform.\"\"\"\n    N = image.shape[0]\n    N_half = N // 2\n    \n    # 1. Apply 1D Haar to each row\n    temp = np.apply_along_axis(_haar_1d, 1, image)\n    \n    # 2. Apply 1D Haar to each column of the result\n    coeffs_matrix = np.apply_along_axis(_haar_1d, 0, temp)\n    \n    # 3. Separate into 4 subbands and stack them\n    c_ll = coeffs_matrix[:N_half, :N_half]\n    c_hl = coeffs_matrix[N_half:, :N_half]\n    c_lh = coeffs_matrix[:N_half, N_half:]\n    c_hh = coeffs_matrix[N_half:, N_half:]\n    \n    return np.stack([c_ll, c_lh, c_hl, c_hh], axis=0)\n\ndef _solve_single_case(params):\n    \"\"\"Implements the PGM for a single test case.\"\"\"\n    N = params[\"N\"]\n    y1 = params[\"y1\"].astype(float)\n    y2 = params[\"y2\"].astype(float)\n    alpha1 = params[\"alpha1\"]\n    alpha2 = params[\"alpha2\"]\n    lam = params[\"lam\"]\n    K = params[\"K\"]\n\n    N_half = N // 2\n\n    # Step 1: Compute wavelet transforms of input images\n    c1 = _dwt2(y1)\n    c2 = _dwt2(y2)\n\n    # Step 2: Compute algorithm parameters\n    L = alpha1 + alpha2\n    tau = 1.0 / L\n\n    # Step 3: Initialize coefficient tensor\n    c_k = np.zeros_like(c1)\n\n    # Pre-compute the argument to the prox operator, as it's constant\n    z = (alpha1 * c1 + alpha2 * c2) / L\n    \n    # Step 4: PGM Iteration\n    for _ in range(K):\n        # Proximal step\n        c_k_plus_1 = np.zeros_like(z)\n        \n        # LL subband (no regularization)\n        c_k_plus_1[0, :, :] = z[0, :, :]\n        \n        # Detail subbands (LH, HL, HH)\n        threshold = tau * lam\n        \n        if threshold > 0:\n            # Extract detail coefficient vectors for all spatial locations\n            # Shape: (N_half*N_half, 3)\n            detail_vectors = np.stack([\n                z[1, :, :].ravel(),  # LH\n                z[2, :, :].ravel(),  # HL\n                z[3, :, :].ravel()   # HH\n            ], axis=1)\n\n            # Compute norms for all vectors at once\n            norms = np.linalg.norm(detail_vectors, axis=1) # Shape: (N_half*N_half,)\n            \n            # Compute scaling factors\n            scale = np.maximum(0.0, 1.0 - threshold / np.where(norms > 1e-12, norms, 1e-12))\n            \n            # Apply scaling\n            prox_vectors = detail_vectors * scale[:, np.newaxis]\n            \n            # Reshape and place back into c_k_plus_1\n            c_k_plus_1[1, :, :] = prox_vectors[:, 0].reshape(N_half, N_half)\n            c_k_plus_1[2, :, :] = prox_vectors[:, 1].reshape(N_half, N_half)\n            c_k_plus_1[3, :, :] = prox_vectors[:, 2].reshape(N_half, N_half)\n        else: # No regularization, just copy details\n            c_k_plus_1[1:4, :, :] = z[1:4, :, :]\n            \n        c_k = c_k_plus_1\n        \n    c_star = c_k\n\n    # Step 6: Compute the final objective function value F(c*)\n    fidelity_term1 = 0.5 * alpha1 * np.sum((c_star - c1) ** 2)\n    fidelity_term2 = 0.5 * alpha2 * np.sum((c_star - c2) ** 2)\n    \n    regularization_term = 0.0\n    if lam > 0:\n        detail_vectors_star = np.stack([\n            c_star[1, :, :].ravel(),\n            c_star[2, :, :].ravel(),\n            c_star[3, :, :].ravel()\n        ], axis=1)\n        norms_star = np.linalg.norm(detail_vectors_star, axis=1)\n        regularization_term = lam * np.sum(norms_star)\n        \n    final_objective_value = fidelity_term1 + fidelity_term2 + regularization_term\n    \n    return final_objective_value\n\nsolve()\n```", "id": "4891205"}]}