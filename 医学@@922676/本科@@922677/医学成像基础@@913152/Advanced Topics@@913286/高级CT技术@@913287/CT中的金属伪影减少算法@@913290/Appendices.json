{"hands_on_practices": [{"introduction": "几乎所有金属伪影去除（MAR）算法的第一步都是精确定位或“分割”图像数据中的金属。此练习 [@problem_id:4900160] 介绍了一种使用贝叶斯分类器创建概率性金属掩模的强大方法，这比简单的阈值处理更为复杂和稳健。通过这项实践，您将了解如何结合多种特征（如强度和梯度）来做出可靠的决策。", "problem": "您正在设计一个概率性金属掩模，作为计算机断层扫描（CT）中金属伪影减少（MAR）流程的一部分。使用贝叶斯分类器，您需要根据一个特征向量将每个体素分类为金属或非金属。该特征向量由亨氏单位（HU）表示的强度、以 HU/毫米表示的图像梯度幅值，以及与已知高衰减结构（例如，牙科填充物、髋关节假体）的接近度（以毫米为单位）组成。您必须使用贝叶斯定理来形式化该分类，并计算一个体素包含金属的后验概率。\n\n假设如下：\n\n- 类别：金属（用标签 $M$ 表示）和非金属（用标签 $N$ 表示）。\n- 先验概率：$\\mathbb{P}(M)=0.03$ 和 $\\mathbb{P}(N)=0.97$。\n- 似然模型：给定类别，三个特征是条件独立的，并且每个特征都遵循具有指定类别相关均值和标准差的正态分布（高斯分布）。\n- 特征定义和单位：\n  1. 强度 $I$，单位为亨氏单位（HU）。\n  2. 梯度幅值 $G$，单位为 HU/毫米。\n  3. 接近度 $D$，单位为毫米。\n\n每个特征的类别条件高斯参数（均值和标准差）如下：\n- 对于 $M$（金属）：\n  - $I \\sim \\mathcal{N}(\\mu_{I|M}=3500,\\ \\sigma_{I|M}=400)$，\n  - $G \\sim \\mathcal{N}(\\mu_{G|M}=1200,\\ \\sigma_{G|M}=400)$，\n  - $D \\sim \\mathcal{N}(\\mu_{D|M}=0.5,\\ \\sigma_{D|M}=0.5)$。\n- 对于 $N$（非金属）：\n  - $I \\sim \\mathcal{N}(\\mu_{I|N}=300,\\ \\sigma_{I|N}=600)$，\n  - $G \\sim \\mathcal{N}(\\mu_{G|N}=100,\\ \\sigma_{G|N}=100)$，\n  - $D \\sim \\mathcal{N}(\\mu_{D|N}=12,\\ \\sigma_{D|N}=6)$。\n\n您的任务是：\n- 从贝叶斯定理和所述的建模假设出发，推导具有特征 $(I,G,D)$ 的体素的后验概率 $\\mathbb{P}(M \\mid I,G,D)$。\n- 实现一个程序，对每个指定的测试用例评估 $\\mathbb{P}(M \\mid I,G,D)$，并返回一个关于是否存在金属痕迹的二元检测决策。如果 $\\mathbb{P}(M \\mid I,G,D) \\ge 0.5$，则决策为 $1$；否则为 $0$。\n- 所有数值答案必须表示为浮点数。后验概率必须四舍五入到 $6$ 位小数。检测决策必须是 $\\{0,1\\}$ 中的整数。\n\n使用以下带有单位的特征向量 $(I,G,D)$ 测试套件：\n- 案例 $1$：$(4200,\\ 1800,\\ 0.2)$。\n- 案例 $2$：$(30,\\ 20,\\ 25)$。\n- 案例 $3$：$(1200,\\ 200,\\ 18)$。\n- 案例 $4$：$(900,\\ 700,\\ 2.0)$。\n- 案例 $5$：$(3500,\\ 0,\\ 5)$。\n- 案例 $6$：$(500,\\ 150,\\ 0.1)$。\n\n计算：\n- 六个案例的后验概率 $\\mathbb{P}(M \\mid I,G,D)$，作为四舍五入到 $6$ 位小数的浮点数。\n- 使用上述阈值规则得出的检测决策，作为 $\\{0,1\\}$ 中的整数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表包含两个子列表：第一个子列表按顺序包含六个后验概率，第二个子列表按顺序包含六个检测决策。例如，要求的输出格式为 $[[p_1,p_2,p_3,p_4,p_5,p_6],[d_1,d_2,d_3,d_4,d_5,d_6]]$，其中每个 $p_i$ 是一个四舍五入到 $6$ 位小数的浮点数，每个 $d_i$ 是一个等于 $0$ 或 $1$ 的整数。", "solution": "问题已经过审查并被认为是有效的。这是一个适定的贝叶斯分类问题，其基础是医学图像分析和统计模式识别的既定原则。所有必要的数据，包括先验概率和类别条件似然模型，都已提供，目标也已明确定义。\n\n任务是，在给定代表强度、梯度幅值和接近度的特征向量 $(I,G,D)$ 的情况下，计算一个体素包含金属的后验概率 $\\mathbb{P}(M \\mid I,G,D)$。该分类使用朴素贝叶斯分类器执行。\n\n根据贝叶斯定理，给定证据 $(I,G,D)$ 时，类别 $M$（金属）的后验概率为：\n$$\n\\mathbb{P}(M \\mid I,G,D) = \\frac{\\mathbb{P}(I,G,D \\mid M) \\mathbb{P}(M)}{\\mathbb{P}(I,G,D)}\n$$\n分母中的项 $\\mathbb{P}(I,G,D)$ 是观测到该证据的边缘概率，可以使用全概率定律在两个类别 $M$（金属）和 $N$（非金属）上将其展开：\n$$\n\\mathbb{P}(I,G,D) = \\mathbb{P}(I,G,D \\mid M) \\mathbb{P}(M) + \\mathbb{P}(I,G,D \\mid N) \\mathbb{P}(N)\n$$\n将此代入贝叶斯公式可得：\n$$\n\\mathbb{P}(M \\mid I,G,D) = \\frac{\\mathbb{P}(I,G,D \\mid M) \\mathbb{P}(M)}{\\mathbb{P}(I,G,D \\mid M) \\mathbb{P}(M) + \\mathbb{P}(I,G,D \\mid N) \\mathbb{P}(N)}\n$$\n问题陈述，给定类别，特征 $I$、$G$ 和 $D$ 是条件独立的。这是朴素贝叶斯分类器中的“朴素”假设。这使我们能够将联合类别条件似然表示为各个特征似然的乘积：\n$$\n\\mathbb{P}(I,G,D \\mid C) = \\mathbb{P}(I \\mid C) \\cdot \\mathbb{P}(G \\mid C) \\cdot \\mathbb{P}(D \\mid C) \\quad \\text{for } C \\in \\{M, N\\}\n$$\n每个特征的似然 $\\mathbb{P}(x \\mid C)$ 由正态（高斯）分布 $\\mathcal{N}(\\mu_{x|C}, \\sigma_{x|C})$ 建模。正态分布的概率密度函数（PDF）为：\n$$\nf(x; \\mu, \\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)\n$$\n直接计算后验概率容易出现数值下溢，因为在浮点运算中，小的似然值的乘积可能会变为零。一种更稳定的方法是使用对数概率。我们为每个类别定义一个分数 $S_C$，即类别和证据的联合概率的对数：\n$$\nS_C = \\log\\left( \\mathbb{P}(I,G,D \\mid C) \\mathbb{P}(C) \\right) = \\log\\mathbb{P}(I,G,D \\mid C) + \\log\\mathbb{P}(C)\n$$\n使用条件独立性假设，这可以展开为：\n$$\nS_C = \\sum_{x \\in \\{I,G,D\\}} \\log\\mathbb{P}(x \\mid C) + \\log\\mathbb{P}(C)\n$$\n高斯 PDF 的对数为：\n$$\n\\log f(x; \\mu, \\sigma) = -\\log(\\sigma) - \\frac{1}{2}\\log(2\\pi) - \\frac{(x - \\mu)^2}{2\\sigma^2}\n$$\n后验概率 $\\mathbb{P}(M \\mid I,G,D)$ 可以用分数 $S_M$ 和 $S_N$ 表示：\n$$\n\\mathbb{P}(M \\mid I,G,D) = \\frac{e^{S_M}}{e^{S_M} + e^{S_N}}\n$$\n为了进一步提高数值稳定性，可以将其重新排列为：\n$$\n\\mathbb{P}(M \\mid I,G,D) = \\frac{1}{1 + \\frac{e^{S_N}}{e^{S_M}}} = \\frac{1}{1 + e^{S_N - S_M}}\n$$\n这是应用于分数差的逻辑 S 型函数（logistic sigmoid function），它对下溢和上溢都具有鲁棒性。\n\n检测决策基于 $0.5$ 的阈值。如果 $\\mathbb{P}(M \\mid I,G,D) \\ge 0.5$，则体素被分类为金属。此条件等效于：\n$$\n\\frac{1}{1 + e^{S_N - S_M}} \\ge 0.5 \\implies 1 \\ge 0.5(1 + e^{S_N - S_M}) \\implies 2 \\ge 1 + e^{S_N - S_M} \\implies 1 \\ge e^{S_N - S_M}\n$$\n对两边取自然对数，我们得到：\n$$\n\\log(1) \\ge S_N - S_M \\implies 0 \\ge S_N - S_M \\implies S_M \\ge S_N\n$$\n这就是最大后验（MAP）决策规则：我们选择分数较高的类别。\n\n实现将按以下步骤进行：\n1.  定义给定两个类别（$M$ 和 $N$）的均值、标准差和先验概率。\n2.  创建一个函数，用于为给定值 $x$、均值 $\\mu$ 和标准差 $\\sigma$ 计算高斯分布的对数概率密度函数（log-PDF）。\n3.  对于每个测试用例向量 $(I,G,D)$：\n    a. 使用金属类别的参数，将 $I$、$G$ 和 $D$ 的对数概率密度函数（log-PDF）相加，并加上先验概率 $\\mathbb{P}(M)$ 的对数，以计算分数 $S_M$。\n    b. 类似地，计算非金属类别的分数 $S_N$。\n    c. 使用公式 $1 / (1 + e^{S_N - S_M})$ 计算后验概率 $\\mathbb{P}(M \\mid I,G,D)$。\n    d. 将后验概率四舍五入到 $6$ 位小数。\n    e. 确定检测决策：如果后验概率 $\\ge 0.5$，则为 $1$；否则为 $0$。\n4.  将计算出的概率和决策收集到两个单独的列表中。\n5.  将最终输出格式化为表示这两个列表的列表的字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the posterior probability of a voxel being metal and makes a binary\n    detection decision using a Naive Bayes classifier.\n    \"\"\"\n\n    # Class-conditional parameters and priors from the problem statement\n    params = {\n        'M': {  # Metal\n            'prior': 0.03,\n            'I': {'mu': 3500, 'sigma': 400},\n            'G': {'mu': 1200, 'sigma': 400},\n            'D': {'mu': 0.5, 'sigma': 0.5}\n        },\n        'N': {  # Non-metal\n            'prior': 0.97,\n            'I': {'mu': 300, 'sigma': 600},\n            'G': {'mu': 100, 'sigma': 100},\n            'D': {'mu': 12, 'sigma': 6}\n        }\n    }\n\n    # Test cases: (I, G, D)\n    test_cases = [\n        (4200.0, 1800.0, 0.2),\n        (30.0, 20.0, 25.0),\n        (1200.0, 200.0, 18.0),\n        (900.0, 700.0, 2.0),\n        (3500.0, 0.0, 5.0),\n        (500.0, 150.0, 0.1)\n    ]\n\n    features = ['I', 'G', 'D']\n    \n    def log_gaussian_pdf(x, mu, sigma):\n        \"\"\"\n        Calculates the logarithm of the Gaussian Probability Density Function.\n        \"\"\"\n        # Ensure sigma is not zero to avoid division errors\n        if sigma == 0:\n            return -np.inf\n        log_pdf = -np.log(sigma * np.sqrt(2 * np.pi)) - 0.5 * ((x - mu) / sigma) ** 2\n        return log_pdf\n\n    posterior_probabilities = []\n    detection_decisions = []\n\n    for case_values in test_cases:\n        case_dict = dict(zip(features, case_values))\n        \n        # Calculate scores S_M and S_N\n        log_prob_m = np.log(params['M']['prior'])\n        log_prob_n = np.log(params['N']['prior'])\n\n        for feat in features:\n            val = case_dict[feat]\n            \n            # Add log-likelihood for Metal class\n            mu_m = params['M'][feat]['mu']\n            sigma_m = params['M'][feat]['sigma']\n            log_prob_m += log_gaussian_pdf(val, mu_m, sigma_m)\n            \n            # Add log-likelihood for Non-metal class\n            mu_n = params['N'][feat]['mu']\n            sigma_n = params['N'][feat]['sigma']\n            log_prob_n += log_gaussian_pdf(val, mu_n, sigma_n)\n\n        # Calculate posterior probability for Metal class using the numerically stable formula\n        # P(M|x) = 1 / (1 + exp(S_N - S_M))\n        score_diff = log_prob_n - log_prob_m\n        if score_diff > 700: # Avoid overflow in np.exp\n            posterior_m = 0.0\n        else:\n            posterior_m = 1.0 / (1.0 + np.exp(score_diff))\n        \n        # Round the posterior probability to 6 decimal places\n        rounded_posterior = round(posterior_m, 6)\n        \n        # Apply threshold for detection decision\n        decision = 1 if rounded_posterior >= 0.5 else 0\n        \n        posterior_probabilities.append(rounded_posterior)\n        detection_decisions.append(decision)\n\n    # Format the final output string exactly as required\n    prob_str = ','.join([f\"{p:.6f}\" for p in posterior_probabilities])\n    dec_str = ','.join(map(str, detection_decisions))\n    \n    print(f\"[[{prob_str}],[{dec_str}]]\")\n\nsolve()\n```", "id": "4900160"}, {"introduction": "在正弦图中识别出被金属损坏的数据后，下一步是用合理的估计值替换这些不可靠的数值——这个过程称为“修复”（inpainting）。本练习 [@problem_id:4900085] 展示了一种经典而有效的技术：方向性插值。通过最小化一个平滑泛函，我们可以根据周围可靠数据的结构智能地填补空白，这是图像恢复中的一个关键原则。", "problem": "一个平行束计算机断层扫描（CT）系统通过 Radon 变换采集线性衰减系数的线积分，生成一个由投影角 $\\theta$ 和探测器坐标 $t$ 索引的二维正弦图。在固定位置 $(\\theta_{1}, t_{1})$ 周围的一小块正弦图区域受到高衰减金属的破坏，使得中心样本 $s(\\theta_{1}, t_{1})$ 未知，而其四个轴对齐的邻近样本 $s(\\theta_{1}, t_{1}\\pm \\Delta t)$ 和 $s(\\theta_{1}\\pm \\Delta \\theta, t_{1})$ 仍然可靠。为减少金属伪影，考虑一种方向性插值方法，该方法通过最小化一个由正弦图梯度构建的局部各向异性平滑泛函来进行插值。\n\n使用以下基础：\n\n- 正弦图编码了线积分：$s(\\theta, t) = \\int \\mu(x, y) \\,\\mathrm{d}\\ell$，其中 $\\mu$ 是线性衰减系数，$\\mathrm{d}\\ell$ 沿由 $(\\theta, t)$ 定义的射线进行积分。\n- 局部平滑性可以通过惩罚沿 $(\\theta, t)$ 轴的方向差分的平方来实现，其权重由从可靠邻近数据估计的局部正弦图梯度确定。\n\n设未知中心值为 $x := s(\\theta_{1}, t_{1})$。仅使用可靠样本，定义在 $(\\theta_{1}, t_{1})$ 处的局部正弦图梯度的离散中心差分估计：\n$$\ng_{t} \\approx \\frac{s(\\theta_{1}, t_{1}+\\Delta t) - s(\\theta_{1}, t_{1}-\\Delta t)}{2\\,\\Delta t},\\quad\ng_{\\theta} \\approx \\frac{s(\\theta_{1}+\\Delta \\theta, t_{1}) - s(\\theta_{1}-\\Delta \\theta, t_{1})}{2\\,\\Delta \\theta}.\n$$\n为单个未知数 $x$ 构建一个各向异性平滑泛函，\n$$\n\\mathcal{J}(x) = w_{t}\\Big[(x - s(\\theta_{1}, t_{1}-\\Delta t))^{2} + (s(\\theta_{1}, t_{1}+\\Delta t) - x)^{2}\\Big] + w_{\\theta}\\Big[(x - s(\\theta_{1}-\\Delta \\theta, t_{1}))^{2} + (s(\\theta_{1}+\\Delta \\theta, t_{1}) - x)^{2}\\Big],\n$$\n其中权重由梯度幅值定义如下\n$$\nw_{t} = \\frac{1}{1 + \\left(\\frac{|g_{t}|}{g_{0t}}\\right)^{2}},\\quad\nw_{\\theta} = \\frac{1}{1 + \\left(\\frac{|g_{\\theta}|}{g_{0\\theta}}\\right)^{2}},\n$$\n其中对比度参数为 $g_{0t} > 0$ 和 $g_{0\\theta} > 0$。\n\n假设以下为可靠的邻近数据和采样步长：\n- $s(\\theta_{1}, t_{1}-\\Delta t) = 0.51$, $s(\\theta_{1}, t_{1}+\\Delta t) = 0.63$, $s(\\theta_{1}-\\Delta \\theta, t_{1}) = 0.52$, $s(\\theta_{1}+\\Delta \\theta, t_{1}) = 0.54$。\n- $\\Delta t = 1$, $\\Delta \\theta = 0.02$ (弧度)。\n- $g_{0t} = 0.05$, $g_{0\\theta} = 0.50$。\n\n从上述基础定义和平滑泛函出发，推导最小化器 $x^{\\star}$ 的表达式，该最小化器通过在可靠邻近点提供的边界约束下最小化 $\\mathcal{J}(x)$ 来插值缺失的正弦图值。然后根据给定数据数值计算 $x^{\\star}$。将最终数值答案四舍五入至四位有效数字。", "solution": "首先对问题进行验证，以确保其科学基础可靠、适定、客观和完整。\n\n### 步骤 1：提取已知信息\n已知信息如下：\n- 一个未知的正弦图值 $x := s(\\theta_{1}, t_{1})$。\n- 可靠的邻近数据：\n  - $s(\\theta_{1}, t_{1}-\\Delta t) = 0.51$\n  - $s(\\theta_{1}, t_{1}+\\Delta t) = 0.63$\n  - $s(\\theta_{1}-\\Delta \\theta, t_{1}) = 0.52$\n  - $s(\\theta_{1}+\\Delta \\theta, t_{1}) = 0.54$\n- 采样间隔：\n  - $\\Delta t = 1$\n  - $\\Delta \\theta = 0.02$\n- 中心差分的梯度定义：\n  - $g_{t} \\approx \\frac{s(\\theta_{1}, t_{1}+\\Delta t) - s(\\theta_{1}, t_{1}-\\Delta t)}{2\\,\\Delta t}$\n  - $g_{\\theta} \\approx \\frac{s(\\theta_{1}+\\Delta \\theta, t_{1}) - s(\\theta_{1}-\\Delta \\theta, t_{1})}{2\\,\\Delta \\theta}$\n- 待最小化的各向异性平滑泛函：\n  - $\\mathcal{J}(x) = w_{t}\\Big[(x - s(\\theta_{1}, t_{1}-\\Delta t))^{2} + (s(\\theta_{1}, t_{1}+\\Delta t) - x)^{2}\\Big] + w_{\\theta}\\Big[(x - s(\\theta_{1}-\\Delta \\theta, t_{1}))^{2} + (s(\\theta_{1}+\\Delta \\theta, t_{1}) - x)^{2}\\Big]$\n- 权重定义：\n  - $w_{t} = \\frac{1}{1 + \\left(\\frac{|g_{t}|}{g_{0t}}\\right)^{2}}$\n  - $w_{\\theta} = \\frac{1}{1 + \\left(\\frac{|g_{\\theta}|}{g_{0\\theta}}\\right)^{2}}$\n- 对比度参数：\n  - $g_{0t} = 0.05$\n  - $g_{0\\theta} = 0.50$\n- 最终的插值结果应四舍五入至四位有效数字。\n\n### 步骤 2：使用提取的已知信息进行验证\n该问题描述了一个使用加权平均插值方案的正弦图修复任务，其中权重源自一个各向异性平滑泛函。这种方法是图像处理和医学成像领域的标准技术，通常与各向异性扩散相关。泛函 $\\mathcal{J}(x)$ 是关于未知数 $x$ 的二次函数。权重 $w_{t}$ 和 $w_{\\theta}$ 由梯度幅值导出，且恒为正。因此，$\\mathcal{J}(x)$ 是一个开口向上的凸抛物线，这保证了唯一最小值的存在。该问题是自洽的，提供了所有必需的数据和定义。没有科学或逻辑上的矛盾。对正弦图值要求单位为 $\\mathrm{cm}^{-1}$（它是一个线积分 $\\int \\mu \\, \\mathrm{d}\\ell$，因此其单位应为 $\\text{length}^{-1} \\times \\text{length} = \\text{无量纲}$）是一个微小的术语模糊，但不影响优化问题本身的数学有效性。该问题被认为是有效的。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n目标是找到使泛函 $\\mathcal{J}(x)$ 最小化的 $x$ 值。这个值记为 $x^{\\star}$，可以通过对 $\\mathcal{J}(x)$ 关于 $x$ 求导并令其为零来找到。\n\n我们简化邻近值的记法：\n- $s_{t-} = s(\\theta_{1}, t_{1}-\\Delta t)$\n- $s_{t+} = s(\\theta_{1}, t_{1}+\\Delta t)$\n- $s_{\\theta-} = s(\\theta_{1}-\\Delta \\theta, t_{1})$\n- $s_{\\theta+} = s(\\theta_{1}+\\Delta \\theta, t_{1})$\n\n泛函为：\n$$\n\\mathcal{J}(x) = w_{t}\\Big[(x - s_{t-})^{2} + (s_{t+} - x)^{2}\\Big] + w_{\\theta}\\Big[(x - s_{\\theta-})^{2} + (s_{\\theta+} - x)^{2}\\Big]\n$$\n为求最小值，我们计算导数 $\\frac{\\mathrm{d}\\mathcal{J}}{\\mathrm{d}x}$：\n$$\n\\frac{\\mathrm{d}\\mathcal{J}}{\\mathrm{d}x} = w_{t}\\Big[2(x - s_{t-})(1) + 2(s_{t+} - x)(-1)\\Big] + w_{\\theta}\\Big[2(x - s_{\\theta-})(1) + 2(s_{\\theta+} - x)(-1)\\Big]\n$$\n$$\n\\frac{\\mathrm{d}\\mathcal{J}}{\\mathrm{d}x} = 2w_{t}(x - s_{t-} - s_{t+} + x) + 2w_{\\theta}(x - s_{\\theta-} - s_{\\theta+} + x)\n$$\n$$\n\\frac{\\mathrm{d}\\mathcal{J}}{\\mathrm{d}x} = 2w_{t}\\Big(2x - (s_{t-} + s_{t+})\\Big) + 2w_{\\theta}\\Big(2x - (s_{\\theta-} + s_{\\theta+})\\Big)\n$$\n令导数为零以求临界点 $x^{\\star}$：\n$$\n2w_{t}\\Big(2x^{\\star} - (s_{t-} + s_{t+})\\Big) + 2w_{\\theta}\\Big(2x^{\\star} - (s_{\\theta-} + s_{\\theta+})\\Big) = 0\n$$\n两边除以 $2$：\n$$\nw_{t}\\Big(2x^{\\star} - (s_{t-} + s_{t+})\\Big) + w_{\\theta}\\Big(2x^{\\star} - (s_{\\theta-} + s_{\\theta+})\\Big) = 0\n$$\n现在，我们求解 $x^{\\star}$：\n$$\n2x^{\\star}w_{t} - w_{t}(s_{t-} + s_{t+}) + 2x^{\\star}w_{\\theta} - w_{\\theta}(s_{\\theta-} + s_{\\theta+}) = 0\n$$\n$$\n2x^{\\star}(w_{t} + w_{\\theta}) = w_{t}(s_{t-} + s_{t+}) + w_{\\theta}(s_{\\theta-} + s_{\\theta+})\n$$\n$$\nx^{\\star} = \\frac{w_{t}(s_{t-} + s_{t+}) + w_{\\theta}(s_{\\theta-} + s_{\\theta+})}{2(w_{t} + w_{\\theta})}\n$$\n该表达式给出了最优插值 $x^{\\star}$。它可以被解释为沿每个轴的邻近点均值的加权平均。\n\n现在，我们使用给定数据计算 $x^{\\star}$ 的数值。\n\n首先，计算局部梯度 $g_{t}$ 和 $g_{\\theta}$：\n$$\ng_{t} = \\frac{s_{t+} - s_{t-}}{2\\Delta t} = \\frac{0.63 - 0.51}{2(1)} = \\frac{0.12}{2} = 0.06\n$$\n$$\ng_{\\theta} = \\frac{s_{\\theta+} - s_{\\theta-}}{2\\Delta \\theta} = \\frac{0.54 - 0.52}{2(0.02)} = \\frac{0.02}{0.04} = 0.5\n$$\n接下来，计算权重 $w_{t}$ 和 $w_{\\theta}$：\n$$\nw_{t} = \\frac{1}{1 + \\left(\\frac{|g_{t}|}{g_{0t}}\\right)^{2}} = \\frac{1}{1 + \\left(\\frac{0.06}{0.05}\\right)^{2}} = \\frac{1}{1 + (1.2)^{2}} = \\frac{1}{1 + 1.44} = \\frac{1}{2.44}\n$$\n$$\nw_{\\theta} = \\frac{1}{1 + \\left(\\frac{|g_{\\theta}|}{g_{0\\theta}}\\right)^{2}} = \\frac{1}{1 + \\left(\\frac{0.5}{0.50}\\right)^{2}} = \\frac{1}{1 + 1^{2}} = \\frac{1}{2}\n$$\n现在，将权重和邻近值代入 $x^{\\star}$ 的表达式中：\n- 沿 $t$ 轴的邻近值之和：$s_{t-} + s_{t+} = 0.51 + 0.63 = 1.14$\n- 沿 $\\theta$ 轴的邻近值之和：$s_{\\theta-} + s_{\\theta+} = 0.52 + 0.54 = 1.06$\n\n$$\nx^{\\star} = \\frac{w_{t}(1.14) + w_{\\theta}(1.06)}{2(w_{t} + w_{\\theta})}\n$$\n代入权重的值：\n$$\nx^{\\star} = \\frac{(\\frac{1}{2.44})(1.14) + (\\frac{1}{2})(1.06)}{2(\\frac{1}{2.44} + \\frac{1}{2})}\n$$\n计算分子：\n$$\n\\text{Numerator} = \\frac{1.14}{2.44} + \\frac{1.06}{2} = \\frac{1.14}{2.44} + 0.53\n$$\n计算分母：\n$$\n\\text{Denominator} = 2\\left(\\frac{1}{2.44} + \\frac{1}{2}\\right) = 2\\left(\\frac{1 + 1.22}{2.44}\\right) = 2\\left(\\frac{2.22}{2.44}\\right) = \\frac{4.44}{2.44}\n$$\n因此，我们有：\n$$\nx^{\\star} = \\frac{\\frac{1.14}{2.44} + 0.53}{\\frac{4.44}{2.44}} = \\frac{1.14 + 0.53(2.44)}{4.44} = \\frac{1.14 + 1.2932}{4.44} = \\frac{2.4332}{4.44}\n$$\n$$\nx^{\\star} \\approx 0.547995495...\n$$\n问题要求将最终答案四舍五入到四位有效数字。\n$$\nx^{\\star} \\approx 0.5480\n$$\n虽然问题要求插值的单位以 $\\mathrm{cm}^{-1}$ 表示，但计算是基于无量纲的数值输入。最终结果是一个无量纲数。根据输出格式规则，带框的答案中不包含单位。该数值代表了插值后的正弦图数据点，其物理意义与线性衰减系数的线积分相关。", "answer": "$$\\boxed{0.5480}$$", "id": "4900085"}, {"introduction": "在之前概念的基础上，这最后一个练习 [@problem_id:4900122] 将物理建模与机器学习相结合，构建一个完整的归一化金属伪影去除（NMAR）流程。您将基于比尔-朗伯定律生成训练数据，然后训练一个简单的修复预测模型。这个综合性练习展示了现代 MAR 方法的开发和评估过程，包括测试其在成像条件（如 X 射线能谱）变化下的鲁棒性。", "problem": "你的任务是实现一个计算流程，该流程将计算机断层扫描（CT）中的归一化金属伪影校正（NMAR）形式化为一个基于 Beer–Lambert 定律的有原则的逆问题。目标是通过生成归一化正弦图来计算训练目标，设计一个简单的修复预测器，并评估在 X 射线能谱 $S(E)$ 发生域偏移情况下的性能。最终输出必须是数值，并且从第一性原理推导得出。\n\n基本原理：\n- 对于多色 X 射线束，Beer–Lambert 定律指出，沿一条射线测量的强度 $I$ 为\n$$\nI = \\int_{E_{\\min}}^{E_{\\max}} S(E) \\exp\\left(-\\int \\mu(x,E)\\,dx\\right)\\,dE,\n$$\n其中 $S(E)$ 是能量相关的源谱，$\\mu(x,E)$ 是在位置 $x$ 和能量 $E$ 处的线性衰减系数。空气强度为\n$$\nI_0 = \\int_{E_{\\min}}^{E_{\\max}} S(E)\\,dE.\n$$\n投影值为\n$$\np = -\\log\\left(\\frac{I}{I_0}\\right).\n$$\n- 对于一条穿过无金属的均匀水等效路径长度 $t$ 的射线，其正向模型为\n$$\nI_{\\text{water}}(t) = \\int_{E_{\\min}}^{E_{\\max}} S(E)\\,\\exp\\left(-\\mu_w(E)\\,t\\right)\\,dE,\n$$\n其对应的投影为 $p_{\\text{water}}(t) = -\\log\\left(\\frac{I_{\\text{water}}(t)}{I_0}\\right)$。\n\n归一化正弦图定义：\n- 给定从一条穿过未知材料成分物体的射线得到的任意测量投影 $p$，通过求解以下标量方程来定义水等效厚度 $t$\n$$\np_{\\text{water}}(t) = p,\n$$\n该方程是适定的，因为 $p_{\\text{water}}(t)$ 是关于 $t$ 的严格递增函数。归一化正弦图是所有射线对应的这些水等效厚度 $t$ 构成的数组。\n\n模型与几何结构：\n- 考虑一个平行束 CT 几何结构，它扫描一个半径为 $R_w$（单位：毫米）且以原点为中心的圆柱形水模体。一个半径为 $R_m$（单位：毫米）的圆形金属植入物被植入模体内部，其中心位于 $(x_m,y_m)$（单位：毫米）。对于一条由角度 $\\theta$（单位：弧度）和带符号的探测器坐标 $s$（单位：毫米）指定的投影射线，其穿过一个半径为 $R$、中心位于 $(x_c,y_c)$ 的圆的相交弦长为\n$$\n\\ell_{\\text{circle}} = \n\\begin{cases}\n2\\sqrt{R^2 - d^2}, & |d| \\le R,\\\\\n0, & |d| > R,\n\\end{cases}\n$$\n其中 $d = |x_c\\cos\\theta + y_c\\sin\\theta - s|$。\n- 对每条射线，定义 $L_w^{\\text{full}}$ 为穿过水圆柱的弦长，$L_m$ 为穿过金属盘的弦长。在金属盘替代了水的假设下，存在金属时的水体弦长为 $L_w = \\max(L_w^{\\text{full}} - L_m, 0)$。\n\n材料模型：\n- 使用能量相关的衰减模型\n$$\n\\mu_w(E) = b_w + \\frac{a_w}{E^3},\\quad\n\\mu_m(E) = b_m + \\frac{a_m}{E^3},\n$$\n其中 $E$ 的单位是千电子伏特 (keV)，$\\mu_w,\\mu_m$ 的单位是逆毫米 (mm$^{-1}$)。\n\n能谱与域偏移：\n- 使用参数化的源谱\n$$\nS(E) \\propto E^\\gamma \\exp\\left(-\\frac{E}{E_0}\\right),\n$$\n适用于 $E \\in [E_{\\min}, E_{\\max}]$，其中 $\\gamma$ 为给定的形状参数，$E_0$ 为尺度参数。对 $S(E)$ 进行归一化，使得在数值上 $\\int S(E)\\,dE = 1$。\n- 域偏移是通过在训练和测试之间改变 $E_0$ 来引入的，同时保持所有其他参数不变。\n\n训练目标与预测器：\n- 计算存在金属时每条射线的测量强度，\n$$\nI_{\\text{meas}} = \\int S(E)\\,\\exp\\big(-\\mu_w(E)\\,L_w - \\mu_m(E)\\,L_m\\big)\\,dE,\n$$\n并通过反解 $p_{\\text{water}}(t_{\\text{meas}}) = -\\log(I_{\\text{meas}}/I_0)$ 得到其归一化厚度 $t_{\\text{meas}}$。\n- 通过将金属替换为水来定义用于修复的目标强度，\n$$\nI_{\\text{targ}} = \\int S(E)\\,\\exp\\big(-\\mu_w(E)\\,L_w^{\\text{full}}\\big)\\,dE,\n$$\n并通过 $p_{\\text{water}}(t_{\\text{targ}}) = -\\log(I_{\\text{targ}}/I_0)$ 得到其归一化厚度 $t_{\\text{targ}}$。\n- 设计一个沿着探测器维度的一维卷积修复预测器，其核半宽为 $K$。对于一个被掩蔽的中心索引 $j$，定义输入向量为\n$$\n\\mathbf{x}_j = [t_{\\text{meas}}(j-K),\\dots,t_{\\text{meas}}(j-1),t_{\\text{meas}}(j+1),\\dots,t_{\\text{meas}}(j+K),1]^\\top \\in \\mathbb{R}^{2K+1},\n$$\n其中最后一个分量是偏置项，预测结果为\n$$\n\\hat{t}(j) = \\mathbf{w}^\\top \\mathbf{x}_j.\n$$\n通过在具有有效（未被掩蔽）邻居的训练窗口上最小化一个正则化的最小二乘目标函数来估计权重 $\\mathbf{w}$：\n$$\n\\min_{\\mathbf{w}} \\|\\mathbf{X}\\mathbf{w} - \\mathbf{y}\\|_2^2 + \\lambda \\|\\mathbf{w}\\|_2^2,\n$$\n其中 $\\mathbf{X}$ 的行是具有有效邻居的被掩蔽中心 $j$ 的邻居向量 $\\mathbf{x}_j$，而 $\\mathbf{y}$ 是对应的 $t_{\\text{targ}}(j)$。\n\n噪声模型：\n- 可选地，在计算 $p$ 之前，向测量强度 $I_{\\text{meas}}$ 添加相对振幅为 $\\sigma$ 的零均值高斯噪声；将强度裁剪到一个小的正值以保持物理真实性。\n\n性能指标：\n- 在具有有效邻居的测试掩蔽射线上，评估 $\\hat{t}(j)$ 和 $t_{\\text{targ}}(j)$ 之间的平均绝对误差 (MAE) 和均方根误差 (RMSE)。两个指标都必须以毫米 (mm) 为单位表示，并以浮点数形式打印。如果不存在被掩蔽的射线或有效的窗口，则两个指标均返回 $0.0$。\n\n角度必须以弧度处理。所有长度单位为毫米。能量单位为千电子伏特。\n\n你的程序必须实现上述流程，并生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，其顺序由下面的测试套件指定。将每个浮点数四舍五入到六位小数。\n\n测试套件：\n- 案例 1 (正常路径):\n    - $R_w = 60$ mm, $R_m = 12$ mm, $(x_m,y_m) = (20,0)$ mm, $K = 3$, $\\lambda = 10^{-3}$, $\\gamma = 2$, $E_{\\min} = 20$ keV, $E_{\\max} = 120$ keV, $E_0^{\\text{train}} = 30$ keV, $E_0^{\\text{test}} = 40$ keV, 噪声水平 $\\sigma = 0.0$, 角度数量 $N_\\theta = 48$, 探测器样本数量 $N_s = 96$。\n- 案例 2 (边界情况, 无金属):\n    - 与案例 1 相同，但 $R_m = 0$ mm 且 $(x_m,y_m) = (0,0)$ mm；使用 $E_0^{\\text{train}} = 30$ keV 和 $E_0^{\\text{test}} = 35$ keV；$\\sigma = 0.0$。\n- 案例 3 (边缘情况, 强域偏移和噪声):\n    - $R_w = 60$ mm, $R_m = 25$ mm, $(x_m,y_m) = (0,10)$ mm, $K = 3$, $\\lambda = 10^{-3}$, $\\gamma = 2$, $E_{\\min} = 20$ keV, $E_{\\max} = 120$ keV, $E_0^{\\text{train}} = 25$ keV, $E_0^{\\text{test}} = 50$ keV, 噪声水平 $\\sigma = 0.02$, $N_\\theta = 48$, $N_s = 96$。\n\n材料参数 (所有案例通用):\n- 水: $a_w = 20$ mm$^{-1}\\cdot$keV$^3$, $b_w = 0.0015$ mm$^{-1}$。\n- 金属: $a_m = 150$ mm$^{-1}\\cdot$keV$^3$, $b_m = 0.010$ mm$^{-1}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含六个浮点数\n$$\n[\\text{MAE}_1,\\text{RMSE}_1,\\text{MAE}_2,\\text{RMSE}_2,\\text{MAE}_3,\\text{RMSE}_3],\n$$\n四舍五入到六位小数，其中下标表示案例编号。", "solution": "该问题提出了一个全面且具有坚实科学基础的任务，即为计算机断层扫描（CT）中的归一化金属伪影校正（NMAR）实现一个计算流程。该模型基于第一性原理，包括多色 Beer–Lambert 定律，并涉及生成模拟的训练和测试数据、设计一个简单的机器学习预测器以及评估其在域偏移下的性能。该问题是自洽的，所有必要的物理模型、参数和评估指标都已明确定义。其数学和物理形式是合理的，计算步骤逻辑结构清晰。因此，该问题被认为是有效的，下面提供了一个完整的解决方案。\n\n该解决方案通过一系列有原则的步骤来展开：\n\n1.  **物理建模**：模拟的核心是针对多色 X 射线源的 Beer–Lambert 定律。射线穿过介质后的强度 $I$ 由源谱 $S(E)$ 经材料能量相关的线性衰减系数 $\\mu(x, E)$ 衰减后的积分给出：\n    $$\n    I = \\int_{E_{\\min}}^{E_{\\max}} S(E) \\exp\\left(-\\int_{\\text{ray}} \\mu(x,E)\\,dx\\right)\\,dE\n    $$\n    问题指定了源谱 $S(E) \\propto E^\\gamma \\exp(-E/E_0)$ 以及水 $\\mu_w(E)$ 和金属 $\\mu_m(E)$ 的特定材料衰减模型，它们都是能量 $E$ 的函数。这些积分通过数值计算得出。源谱 $S(E)$ 首先被归一化，使其在能量范围 $[E_{\\min}, E_{\\max}]$ 上的积分为 1。通过这种归一化，空气扫描强度为 $I_0 = \\int S(E)\\,dE = 1$。\n\n2.  **几何路径长度计算**：该模拟采用平行束几何结构。对于由角度 $\\theta$ 和探测器坐标 $s$ 定义的每条射线，其穿过圆柱形水模体 ($L_w^{\\text{full}}$) 和嵌入的圆形金属植入物 ($L_m$) 的路径长度使用解析几何计算。穿过半径为 $R$、中心位于 $(x_c, y_c)$ 的圆的弦长 $\\ell$ 为 $\\ell=2\\sqrt{R^2-d^2}$（当 $|d|\\le R$ 时），否则为 0，其中 $d = |x_c\\cos\\theta + y_c\\sin\\theta - s|$ 是从射线到圆心的垂直距离。由于金属植入物替代了水，实际的水路径长度为 $L_w = L_w^{\\text{full}} - L_m$。\n\n3.  **正弦图生成**：生成两种类型的正弦图。首先是“测量”正弦图，它模拟了存在金属植入物时的扫描。每条射线的强度为：\n    $$\n    I_{\\text{meas}} = \\int_{E_{\\min}}^{E_{\\max}} S(E)\\,\\exp\\big(-\\mu_w(E)\\,L_w - \\mu_m(E)\\,L_m\\big)\\,dE\n    $$\n    其次是“目标”正弦图，它代表了金属被水替代后的理想、无伪影的扫描。其强度为：\n    $$\n    I_{\\text{targ}} = \\int_{E_{\\min}}^{E_{\\max}} S(E)\\,\\exp\\big(-\\mu_w(E)\\,L_w^{\\text{full}}\\big)\\,dE\n    $$\n    对于有噪声的情况，在后续处理之前，将相对振幅为 $\\sigma$ 的零均值高斯噪声添加到 $I_{\\text{meas}}$ 中，并将结果裁剪到一个小的正值，以防止出现非物理的负强度或零强度。\n\n4.  **正弦图归一化**：原始投影值 $p = -\\log(I/I_0)$ 会受到非线性的束流硬化效应影响。NMAR 方法通过将投影转换为水等效厚度 $t$ 来线性化数据。这是通过反演均匀水路径的正向模型来实现的：$p_{\\text{water}}(t) = -\\log\\left(\\int S(E)\\exp(-\\mu_w(E)t)dE / I_0\\right)$。由于 $p_{\\text{water}}(t)$ 是关于 $t$ 的严格单调函数，因此对于任何有效的投影值 $p$ 都存在唯一的逆。为了高效地执行此反演，我们预先计算一个在合理厚度范围内的 $(t, p_{\\text{water}}(t))$ 对的查找表 (LUT)，并使用线性插值来找到与任意给定投影 $p$ 对应的水等效厚度 $t$。这个过程产生归一化正弦图 $t_{\\text{meas}}$ 和 $t_{\\text{targ}}$。\n\n5.  **修复预测器的设计与训练**：目标是利用测量正弦图 $t_{\\text{meas}}$ 中周围未损坏区域的信息，来预测被金属伪影损坏区域的真实值 $t_{\\text{targ}}$。我们设计了一个简单的线性预测器。对于每条损坏的射线（即穿过金属的射线），从其沿探测器维度的 $2K$ 个最近的未损坏邻居构建一个特征向量 $\\mathbf{x}$，并增广一个偏置项。预测值为 $\\hat{t} = \\mathbf{w}^\\top \\mathbf{x}$。权重向量 $\\mathbf{w}$ 通过求解一个正则化最小二乘问题来学习：\n    $$\n    \\mathbf{w}^* = \\arg\\min_{\\mathbf{w}} \\|\\mathbf{X}\\mathbf{w} - \\mathbf{y}\\|_2^2 + \\lambda \\|\\mathbf{w}\\|_2^2\n    $$\n    其中矩阵 $\\mathbf{X}$ 的行由来自有效训练窗口（一条被未损坏邻居包围的损坏射线）的特征向量组成，而 $\\mathbf{y}$ 包含来自 $t_{\\text{targ}}$ 的相应真实值。训练使用训练能谱 $S(E; E_0^{\\text{train}})$ 生成的数据进行。其闭式解为 $\\mathbf{w} = (\\mathbf{X}^\\top\\mathbf{X} + \\lambda \\mathbf{I})^{-1}\\mathbf{X}^\\top\\mathbf{y}$。\n\n6.  **域偏移下的性能评估**：通过将 X 射线能谱更改为 $S(E; E_0^{\\text{test}})$ 来模拟域偏移，以测试已训练预测器的鲁棒性。使用这个新能谱生成一组新的测试正弦图（$t_{\\text{meas}}^{\\text{test}}$, $t_{\\text{targ}}^{\\text{test}}$）。然后使用先前学习到的权重 $\\mathbf{w}$ 来预测测试集中损坏射线的 $\\hat{t}$。通过计算所有来自有效窗口的测试样本的预测值 $\\hat{t}$ 与真实值 $t_{\\text{targ}}^{\\text{test}}$ 之间的平均绝对误差 (MAE) 和均方根误差 (RMSE) 来量化性能。\n\n7.  **边缘情况管理**：问题为边缘情况定义了特定行为。如果没有金属存在（$R_m=0$），则没有射线被损坏，导致没有训练或测试样本。类似地，如果一个大的金属物体使得无法找到任何具有完全未损坏邻域的损坏射线，训练集或测试集也可能为空。在任何测试射线有效窗口集合为空的情况下，MAE 和 RMSE 都定义为 $0.0$，这一点由实现来处理。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Main function to run the NMAR simulation for all test cases and print results.\n    \"\"\"\n    \n    # Material parameters (fixed across cases)\n    material_params = {\n        'a_w': 20.0, 'b_w': 0.0015,\n        'a_m': 150.0, 'b_m': 0.010\n    }\n\n    # Test suite\n    test_cases = [\n        # Case 1 (happy path)\n        {'R_w': 60.0, 'R_m': 12.0, 'x_m': 20.0, 'y_m': 0.0, 'K': 3, 'lambda': 1e-3, \n         'gamma': 2.0, 'E_min': 20.0, 'E_max': 120.0, 'E0_train': 30.0, 'E0_test': 40.0, \n         'sigma': 0.0, 'N_theta': 48, 'N_s': 96},\n        # Case 2 (boundary, no metal)\n        {'R_w': 60.0, 'R_m': 0.0, 'x_m': 0.0, 'y_m': 0.0, 'K': 3, 'lambda': 1e-3, \n         'gamma': 2.0, 'E_min': 20.0, 'E_max': 120.0, 'E0_train': 30.0, 'E0_test': 35.0, \n         'sigma': 0.0, 'N_theta': 48, 'N_s': 96},\n        # Case 3 (edge case, strong domain shift and noise)\n        {'R_w': 60.0, 'R_m': 25.0, 'x_m': 0.0, 'y_m': 10.0, 'K': 3, 'lambda': 1e-3, \n         'gamma': 2.0, 'E_min': 20.0, 'E_max': 120.0, 'E0_train': 25.0, 'E0_test': 50.0, \n         'sigma': 0.02, 'N_theta': 48, 'N_s': 96}\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        params = {**case_params, **material_params}\n        mae, rmse = process_case(params)\n        all_results.extend([mae, rmse])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in all_results)}]\")\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case from training to evaluation.\n    \"\"\"\n    # Unpack parameters\n    K = params['K']\n    lambda_reg = params['lambda']\n\n    # --- Training Phase ---\n    train_data = generate_sinograms(params, params['E0_train'], 0.0)\n    X_train, y_train = build_dataset(train_data['t_meas'], train_data['t_targ'], train_data['mask'], K)\n\n    if X_train.shape[0] == 0:\n        w = np.zeros(2 * K + 1)\n    else:\n        # Solve regularized least squares: (X'X + lambda*I)w = X'y\n        A = X_train.T @ X_train + lambda_reg * np.identity(2 * K + 1)\n        b = X_train.T @ y_train\n        w = np.linalg.solve(A, b)\n        \n    # --- Testing Phase ---\n    test_data = generate_sinograms(params, params['E0_test'], params['sigma'])\n    X_test, y_test = build_dataset(test_data['t_meas'], test_data['t_targ'], test_data['mask'], K)\n\n    if X_test.shape[0] == 0:\n        return 0.0, 0.0\n\n    # Predict on test data\n    y_pred = X_test @ w\n\n    # Calculate metrics\n    mae = np.mean(np.abs(y_pred - y_test))\n    rmse = np.sqrt(np.mean((y_pred - y_test)**2))\n\n    return mae, rmse\n\n\ndef generate_sinograms(params, E0, sigma):\n    \"\"\"\n    Generates measured and target sinograms based on the provided parameters.\n    \"\"\"\n    # Unpack parameters\n    R_w, R_m = params['R_w'], params['R_m']\n    x_m, y_m = params['x_m'], params['y_m']\n    a_w, b_w = params['a_w'], params['b_w']\n    a_m, b_m = params['a_m'], params['b_m']\n    gamma, E_min, E_max = params['gamma'], params['E_min'], params['E_max']\n    N_theta, N_s = params['N_theta'], params['N_s']\n\n    # Define sinogram grid\n    thetas = np.linspace(0, np.pi, N_theta, endpoint=False)\n    s_coords = np.linspace(-R_w, R_w, N_s)\n\n    # Energy grid for integration\n    Es = np.linspace(E_min, E_max, 200)\n\n    # Material models\n    mu_w = lambda E: b_w + a_w / E**3\n    mu_m = lambda E: b_m + a_m / E**3\n    \n    # Create normalized spectrum function\n    unnormalized_S_integrand = lambda E: E**gamma * np.exp(-E / E0)\n    norm_const, _ = integrate.quad(unnormalized_S_integrand, E_min, E_max)\n    S = lambda E: unnormalized_S_integrand(E) / norm_const\n\n    # Pre-calculate p_water to t inversion LUT\n    t_lut_vals = np.linspace(0, 2 * R_w, 2048)\n    p_lut_vals = np.zeros_like(t_lut_vals)\n    for i, t in enumerate(t_lut_vals):\n        integrand = lambda E: S(E) * np.exp(-mu_w(E) * t)\n        I_water_t, _ = integrate.quad(integrand, E_min, E_max)\n        # I0 is 1 due to normalization\n        p_lut_vals[i] = -np.log(I_water_t) if I_water_t > 0 else np.inf\n    \n    invert_p_water = interp1d(p_lut_vals, t_lut_vals, bounds_error=False, \n                              fill_value=(t_lut_vals[0], t_lut_vals[-1]))\n\n    # Initialize sinograms\n    t_meas = np.zeros((N_theta, N_s))\n    t_targ = np.zeros((N_theta, N_s))\n    mask = np.zeros((N_theta, N_s), dtype=int)\n    \n    rng = np.random.default_rng(seed=42) # for reproducible noise\n\n    for i, theta in enumerate(thetas):\n        c, s = np.cos(theta), np.sin(theta)\n        for j, s_val in enumerate(s_coords):\n            # Calculate chord lengths\n            # Water phantom (centered at origin)\n            d_w = np.abs(-s_val)\n            L_w_full = 2 * np.sqrt(R_w**2 - d_w**2) if d_w = R_w else 0.0\n\n            # Metal implant\n            d_m = np.abs(x_m * c + y_m * s - s_val)\n            L_m = 2 * np.sqrt(R_m**2 - d_m**2) if (R_m > 0 and d_m = R_m) else 0.0\n\n            L_w = L_w_full - L_m\n            \n            if L_m > 1e-9: # Ray passes through metal\n                mask[i, j] = 1\n\n            # Calculate intensities\n            integrand_meas = lambda E: S(E) * np.exp(-mu_w(E) * L_w - mu_m(E) * L_m)\n            integrand_targ = lambda E: S(E) * np.exp(-mu_w(E) * L_w_full)\n\n            I_meas, _ = integrate.quad(integrand_meas, E_min, E_max)\n            I_targ, _ = integrate.quad(integrand_targ, E_min, E_max)\n\n            # Add noise if specified\n            if sigma > 0:\n                I_meas += rng.normal(0, sigma * I_meas)\n                I_meas = np.maximum(I_meas, 1e-10)\n\n            # Calculate projections (I0=1)\n            p_meas = -np.log(I_meas) if I_meas > 0 else np.inf\n            p_targ = -np.log(I_targ) if I_targ > 0 else np.inf\n\n            # Normalize to water-equivalent thickness\n            t_meas[i, j] = invert_p_water(p_meas)\n            t_targ[i, j] = invert_p_water(p_targ)\n            \n    return {'t_meas': t_meas, 't_targ': t_targ, 'mask': mask}\n\n\ndef build_dataset(t_meas, t_targ, mask, K):\n    \"\"\"\n    Constructs the design matrix X and target vector y for training or evaluation.\n    \"\"\"\n    N_theta, N_s = t_meas.shape\n    X_list, y_list = [], []\n\n    for i in range(N_theta):\n        for j in range(K, N_s - K):\n            if mask[i, j] == 1: # Center pixel is masked\n                # Get indices of neighbors\n                neighbor_indices = list(range(j - K, j)) + list(range(j + 1, j + K + 1))\n                \n                # Check if all neighbors are unmasked\n                if np.any(mask[i, neighbor_indices] == 1):\n                    continue\n\n                # Valid window found, create feature vector\n                neighbors_t = t_meas[i, neighbor_indices]\n                x_vec = np.concatenate((neighbors_t, [1.0]))\n                \n                X_list.append(x_vec)\n                y_list.append(t_targ[i, j])\n\n    if not X_list:\n        return np.empty((0, 2*K + 1)), np.empty((0,))\n        \n    return np.array(X_list), np.array(y_list)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "4900122"}]}