{"hands_on_practices": [{"introduction": "超快平面波成像是实现高帧率和超分辨率定位的关键技术。然而，使用线性探头阵列进行波束偏转会引入被称为栅瓣 ($ \\text{grating lobes} $) 的伪影，这会严重降低图像质量。本练习将引导你从相干叠加的基本原理出发，推导栅瓣出现的位置，并计算为避免这些伪影所允许的最大阵元间距，这对理解和设计超快成像序列至关重要 ([@problem_id:4939171])。", "problem": "一个沿 $x$ 轴排列的理想化一维线性超声阵列，在声速为 $c$ 的均匀介质中，使用均匀幅度激励和线性相位递进，发射平面波，以将发射波前相对于阵列法线（$z$ 轴）偏转一个角度 $\\theta_{0}$。设阵元间距（中心到中心的距离）为 $d$，工作波长为 $\\lambda$，波数为 $k = 2 \\pi / \\lambda$。考虑由所有阵元的单色贡献相干叠加形成的远场响应。\n\n仅从以下基本原理出发：\n- 相干波的复指数叠加。\n- 从位置 $x_{n} = n d$ 的阵元朝向相对于阵列法线的观测角 $\\theta$ 的远场相位为 $k x_{n} \\sin \\theta$。\n- 线性发射偏转相位递进在相邻阵元之间产生恒定的相位增量 $\\psi$。\n- 当相邻阵元贡献之间的相位增量等于 $2 \\pi m$（对于某个整数 $m$）时，发生相长干涉。\n\n完成以下步骤。\n\n1) 推导所有主极大值（包括主瓣和任何栅瓣）的角度位置 $\\theta$ 作为 $\\theta_{0}$、$d$ 和 $\\lambda$ 的函数。\n\n2) 根据你的结果，得出一个关于 $d / \\lambda$ 的闭式不等式，该不等式保证对于满足 $|\\theta_{0}| \\leq \\theta_{\\max}$ 的任何偏转角，都没有可见的栅瓣（即除了主瓣之外没有其他极大值）。其中，如果角度极大值的正弦参数的绝对值 $\\leq 1$，则认为该极大值是可见的。将此简化为关于最大允许间距 $d_{\\max}$ 的单个闭式表达式，用 $\\lambda$ 和 $\\theta_{\\max}$ 表示。\n\n3) 使用你的表达式，计算用于超快平面波超声成像的 $d_{\\max}$，其中心频率 $f_{0} = 7.5$ MHz，声速 $c = 1540$ m/s，对称偏转范围为 $|\\theta_{0}| \\leq \\theta_{\\max} = 20$ 度。你的最终数值答案以毫米（mm）表示，并四舍五入到四位有效数字。在进行数值计算时，所有三角函数中的角度均使用度。\n\n你的最终回答应该是一个数字：$d_{\\max}$ 的值，以 mm 为单位，并四舍五入到四位有效数字。", "solution": "该问题经验证具有科学依据、良定、客观且完整。所有给出的原理和数据在波物理学和医学成像领域都是标准的。推导过程按要求分三步进行。\n\n### 第1部分：主极大值角度位置的推导\n\n该问题要求从基本原理出发，推导远场极大值的位置。设一维线性阵列沿 $x$ 轴排列。位于位置 $x_n = n d$ 的阵元以相位 $\\phi_{\\text{steer}}(n)$ 被激励，其中 $n$ 是索引阵元的整数，$d$ 是阵元间距。问题陈述了线性相位递进，因此相邻阵元之间的相位增量 $\\psi$ 是恒定的。因此，第 $n$ 个阵元的相位是 $\\phi_{\\text{steer}}(n) = n\\psi$。\n\n波束需要被偏转到角度 $\\theta_0$。这意味着在方向 $\\theta_0$ 上，来自所有阵元的波必须发生相长干涉。由于从位置 $x_n$ 的阵元到角度 $\\theta$ 处的观察者的路径长度，其远场相位贡献为 $\\phi_{\\text{geom}}(n, \\theta) = k x_n \\sin\\theta = k n d \\sin\\theta$，其中 $k = 2\\pi/\\lambda$ 是波数。\n\n为了在 $\\theta_0$ 处形成主波束，该方向上相邻阵元之间的总相位差必须为零。总相位差是施加的电子相位差和几何相位差之和。\n$$ \\Delta\\Phi(\\theta_0) = \\psi + \\Delta\\phi_{\\text{geom}}(\\theta_0) = 0 $$\n相邻阵元之间的几何相位差是 $\\Delta\\phi_{\\text{geom}}(\\theta_0) = k(x_{n+1} - x_n)\\sin\\theta_0 = k d \\sin\\theta_0$。\n因此，为了将波束偏转到 $\\theta_0$，施加的相位增量必须是：\n$$ \\psi = -k d \\sin\\theta_0 $$\n现在，考虑在任意观测方向 $\\theta$ 上来自阵元 $n$ 的总相位。它是偏转相位和几何相位之和：\n$$ \\Phi_n(\\theta) = \\phi_{\\text{steer}}(n) + \\phi_{\\text{geom}}(n, \\theta) = n\\psi + k n d \\sin\\theta $$\n代入 $\\psi$ 的表达式：\n$$ \\Phi_n(\\theta) = n(-k d \\sin\\theta_0) + k n d \\sin\\theta = n k d (\\sin\\theta - \\sin\\theta_0) $$\n在方向 $\\theta$ 上相邻阵元之间的相位差是：\n$$ \\Delta\\Phi(\\theta) = \\Phi_{n+1}(\\theta) - \\Phi_n(\\theta) = (n+1) k d (\\sin\\theta - \\sin\\theta_0) - n k d (\\sin\\theta - \\sin\\theta_0) = k d (\\sin\\theta - \\sin\\theta_0) $$\n根据相长干涉原理，当此相位差是 $2\\pi$ 的整数倍时，出现主极大值（主瓣和栅瓣）。\n$$ \\Delta\\Phi(\\theta) = 2\\pi m, \\quad \\text{对于整数 } m $$\n代入 $\\Delta\\Phi(\\theta)$ 和 $k=2\\pi/\\lambda$ 的表达式：\n$$ \\frac{2\\pi}{\\lambda} d (\\sin\\theta - \\sin\\theta_0) = 2\\pi m $$\n除以 $2\\pi$ 并重新整理，得到主极大值的位置：\n$$ \\sin\\theta - \\sin\\theta_0 = m \\frac{\\lambda}{d} $$\n$$ \\sin\\theta = \\sin\\theta_0 + m \\frac{\\lambda}{d} $$\n整数 $m=0$ 对应于 $\\theta = \\theta_0$ 处的主瓣。整数 $m \\neq 0$ 对应于栅瓣。\n\n### 第2部分：最大允许间距 $d_{\\max}$ 的推导\n\n如果栅瓣的角度位置 $\\theta$ 是实数，即满足条件 $|\\sin\\theta| \\leq 1$，则该栅瓣是“可见的”。为了保证没有可见的栅瓣，我们必须确保对于所有非零整数 $m$，都有 $|\\sin\\theta| > 1$。\n$$ \\left| \\sin\\theta_0 + m \\frac{\\lambda}{d} \\right| > 1, \\quad \\text{对于 } m = \\pm 1, \\pm 2, \\dots $$\n最靠近主瓣的栅瓣出现在 $m=1$ 和 $m=-1$ 处。如果我们能使这些栅瓣不可见，那么所有其他 $|m|>1$ 的栅瓣也将不可见。\n\n该条件必须对范围 $|\\theta_0| \\leq \\theta_{\\max}$ 内的任何偏转角都成立，这意味着 $\\sin\\theta_0$ 在范围 $[-\\sin\\theta_{\\max}, \\sin\\theta_{\\max}]$ 内。我们必须找到最可能产生可见栅瓣的“最坏情况”，并加以防止。\n\n对于 $m=1$：我们需要 $\\sin\\theta_0 + \\frac{\\lambda}{d} > 1$。\n这必须对所有 $\\theta_0 \\in [-\\theta_{\\max}, \\theta_{\\max}]$ 成立。当 $\\sin\\theta_0$ 处于其最小值，即 $-\\sin\\theta_{\\max}$ 时，左侧最小。因此，我们必须满足：\n$$ -\\sin\\theta_{\\max} + \\frac{\\lambda}{d} > 1 \\implies \\frac{\\lambda}{d} > 1 + \\sin\\theta_{\\max} $$\n对于 $m=-1$：我们需要 $\\sin\\theta_0 - \\frac{\\lambda}{d}  -1$。\n这必须对所有 $\\theta_0 \\in [-\\theta_{\\max}, \\theta_{\\max}]$ 成立。当 $\\sin\\theta_0$ 处于其最大值，即 $\\sin\\theta_{\\max}$ 时，左侧最大。因此，我们必须满足：\n$$ \\sin\\theta_{\\max} - \\frac{\\lambda}{d}  -1 \\implies \\frac{\\lambda}{d} > 1 + \\sin\\theta_{\\max} $$\n两种情况得出相同的条件。因此，为避免在任何高达 $\\theta_{\\max}$ 的偏转角下出现可见栅瓣，间距 $d$ 必须满足：\n$$ \\frac{\\lambda}{d} > 1 + \\sin\\theta_{\\max} $$\n将此式反转，得到关于 $d/\\lambda$ 的不等式：\n$$ \\frac{d}{\\lambda}  \\frac{1}{1 + \\sin\\theta_{\\max}} $$\n最大允许间距 $d_{\\max}$ 是使此式成为等式的值。任何大于此值的间距都将违反该条件。\n$$ d_{\\max} = \\frac{\\lambda}{1 + \\sin\\theta_{\\max}} $$\n\n### 第3部分：$d_{\\max}$ 的计算\n\n我们得到以下参数：\n- 中心频率, $f_0 = 7.5 \\, \\text{MHz} = 7.5 \\times 10^6 \\, \\text{Hz}$。\n- 介质中的声速, $c = 1540 \\, \\text{m/s}$。\n- 最大偏转角, $\\theta_{\\max} = 20^{\\circ}$。\n\n首先，我们使用关系式 $c = f_0 \\lambda$ 计算波长 $\\lambda$：\n$$ \\lambda = \\frac{c}{f_0} = \\frac{1540 \\, \\text{m/s}}{7.5 \\times 10^6 \\, \\text{s}^{-1}} \\approx 2.05333 \\times 10^{-4} \\, \\text{m} $$\n接下来，我们计算 $\\sin\\theta_{\\max}$：\n$$ \\sin\\theta_{\\max} = \\sin(20^{\\circ}) \\approx 0.342020 $$\n现在，我们将这些值代入 $d_{\\max}$ 的表达式中：\n$$ d_{\\max} = \\frac{\\lambda}{1 + \\sin\\theta_{\\max}} \\approx \\frac{2.05333 \\times 10^{-4} \\, \\text{m}}{1 + 0.342020} \\approx \\frac{2.05333 \\times 10^{-4} \\, \\text{m}}{1.342020} $$\n$$ d_{\\max} \\approx 1.53002 \\times 10^{-4} \\, \\text{m} $$\n问题要求答案以毫米（mm）为单位。由于 $1 \\, \\text{m} = 1000 \\, \\text{mm}$，我们有：\n$$ d_{\\max} \\approx 1.53002 \\times 10^{-4} \\times 10^3 \\, \\text{mm} \\approx 0.153002 \\, \\text{mm} $$\n四舍五入到四位有效数字，我们得到：\n$$ d_{\\max} \\approx 0.1530 \\, \\text{mm} $$", "answer": "$$\n\\boxed{0.1530}\n$$", "id": "4939171"}, {"introduction": "在超分辨率定位显微术中，一个核心挑战是如何将微弱、瞬态的微泡信号从强烈、缓慢变化的组织背景回波中分离出来。一种有效的方法是利用它们在频域上的不同特征进行滤波。通过这个实践，你将基于组织和微泡信号的随机过程模型，推导它们的功率谱密度 ($ \\text{Power Spectral Density, PSD} $)，并设计一个高通滤波器来完成这一关键的分离任务，从而将理论模型与信号处理实践紧密结合 ([@problem_id:4939195])。", "problem": "给定一个用于微泡造影剂超快超声成像的简化时间模型，旨在实现超分辨率定位。目标是通过设计一个时间高通滤波器并计算一个合适的截止频率，来抑制缓慢变化的组织回波，同时保留随机的微泡事件。该截止频率能够区分组织和微泡的主要频谱内容。\n\n假设在连续时间下有以下信号模型。组织回波被建模为一个平稳高斯过程，其指数自相关函数为 $$R_{t}(\\tau) = \\sigma_{t}^{2} e^{-|\\tau|/\\tau_{t}},$$ 其中 $\\sigma_{t}$ 是组织振幅标准差，$\\tau_{t}$ 是组织相关时间。随机微泡序列被建模为一个泊松散粒噪声过程，其速率为 $\\lambda$，确定性脉冲形状为 $$h(t) = A_{b} e^{-t/\\tau_{b}} u(t),$$ 其中 $A_{b}$ 是微泡脉冲振幅，$\\tau_{b}$ 是微泡衰减时间，$u(t)$ 是单位阶跃函数。\n\n使用自相关与功率谱密度 (PSD) 之间以及散粒噪声与 PSD 之间的标准关系，推导出组织和微泡分量的 PSD 表达式，作为以赫兹为单位的时间频率 $f$ 的函数。设采样频率为 $f_{s}$（单位为Hz），因此奈奎斯特频率为 $f_{N} = f_{s}/2$。定义谱密度比 $$\\mathrm{SDR}(f) = \\frac{S_{b}(f)}{S_{t}(f)},$$ 其中 $S_{b}(f)$ 和 $S_{t}(f)$ 分别是微泡和组织的 PSD。\n\n设计一个时间高通滤波器，其截止频率 $f_{c}$（单位为Hz）按以下标准选择：\n- 找到最小的 $f$（其中 $0 \\le f \\le f_{N}$），使得 $\\mathrm{SDR}(f) \\ge \\gamma$，其中 $\\gamma$ 是一个指定的正阈值。\n- 如果在 $f = 0$ 时，$\\mathrm{SDR}(f)$ 已满足 $\\ge \\gamma$，则设 $f_{c} = 0$。\n- 如果在 $[0, f_{N}]$ 区间内 $\\mathrm{SDR}(f)$ 始终未能达到 $\\gamma$，则设 $f_{c} = f_{N}$。\n\n然后，利用这个 $f_{c}$，可以选择任何稳定、因果的、截止频率为 $f_{c}$ 的高通滤波器（例如四阶 Butterworth 滤波器）用于实际实现；然而，对于本任务，您只需要计算以 Hz 为单位的 $f_{c}$。\n\n实现一个程序，为每个测试用例根据上述标准计算 $f_{c}$，并打印出截止频率。每个截止频率以 Hz 为单位表示，四舍五入到三位小数。\n\n使用以下测试套件，其中每个元组为 $(f_{s}, \\sigma_{t}, \\tau_{t}, A_{b}, \\tau_{b}, \\lambda, \\gamma)$：\n- 案例A（典型的“理想路径”）：$(2000, 1.0, 0.05, 1.0, 0.001, 200.0, 2.0)$\n- 案例B（阈值在零频率时已满足）：$(2000, 1.0, 0.05, 1.0, 0.001, 200.0, 0.001)$\n- 案例C（在频带内无法达到阈值）：$(2000, 1.0, 0.05, 1.0, 0.001, 200.0, 10.0)$\n- 案例D（不同的参数体系）：$(5000, 0.5, 0.08, 0.8, 0.0008, 150.0, 8.0)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[$f_{c}^{(A)},$ $f_{c}^{(B)},$ $f_{c}^{(C)},$ $f_{c}^{(D)}]$”），其中每个条目都是以 Hz 为单位并四舍五入到三位小数的值。", "solution": "该问题被认为是有效的，因为它具有科学依据、是适定且客观的。它基于信号处理和医学成像领域的标准（尽管是简化的）模型，其参数定义清晰，从而导出一个唯一且有意义的解。因此，我们可以进行推导和计算。\n\n目标是计算时间高通滤波器的截止频率 $f_c$。该频率由期望的微泡信号的功率谱密度 (PSD) $S_b(f)$ 足够超过不期望的组织信号的 PSD $S_t(f)$ 的点确定。该标准基于它们的比率 $\\mathrm{SDR}(f) = S_b(f) / S_t(f)$。\n\n首先，我们必须推导组织和微泡分量 PSD 的解析表达式。频率变量用 $f$ 表示，单位为赫兹 (Hz)。\n\n1. 组织功率谱密度，$S_t(f)$\n\n组织信号被建模为一个平稳高斯过程，其指数自相关函数为：\n$$R_t(\\tau) = \\sigma_t^2 e^{-|\\tau|/\\tau_t}$$\n其中 $\\sigma_t$ 是振幅标准差，$\\tau_t$ 是相关时间。\n根据 Wiener-Khinchin 定理，PSD $S_t(f)$ 是自相关函数 $R_t(\\tau)$ 的傅里叶变换。我们使用标准傅里叶变换对：\n$$\\mathcal{F}\\{e^{-a|\\tau|}\\}(f) = \\frac{2a}{a^2 + (2\\pi f)^2}$$\n通过设置参数 $a = 1/\\tau_t$，我们得到组织分量的 PSD：\n$$S_t(f) = \\sigma_t^2 \\mathcal{F}\\{e^{-|\\tau|/\\tau_t}\\}(f) = \\sigma_t^2 \\frac{2/\\tau_t}{(1/\\tau_t)^2 + (2\\pi f)^2}$$\n将分子和分母同乘以 $\\tau_t^2$ 可将其简化为：\n$$S_t(f) = \\frac{2\\sigma_t^2\\tau_t}{1 + (2\\pi f \\tau_t)^2}$$\n这是一个洛伦兹函数，是指数相关噪声的特征，其最大功率在 $f=0$ 处，并随着 $f$ 的增加而衰减，这与低通特性一致。\n\n2. 微泡功率谱密度，$S_b(f)$\n\n微泡信号被建模为一个泊松散粒噪声过程。根据随机过程理论中的一个标准结果（与 Campbell 定理和 Carson 定理相关），这种过程的 PSD 由下式给出：\n$$S_b(f) = \\lambda |H(f)|^2$$\n其中 $\\lambda$ 是事件发生的平均速率（泊松速率），$H(f)$ 是单个脉冲形状 $h(t)$ 的傅里叶变换。脉冲形状由一个衰减指数函数给出：\n$$h(t) = A_b e^{-t/\\tau_b} u(t)$$\n其中 $A_b$ 是脉冲振幅，$\\tau_b$ 是衰减时间，$u(t)$ 是亥维赛单位阶跃函数。我们计算其傅里叶变换 $H(f) = \\mathcal{F}\\{h(t)\\}$：\n$$H(f) = \\int_{-\\infty}^{\\infty} A_b e^{-t/\\tau_b} u(t) e^{-i 2\\pi f t} dt = A_b \\int_{0}^{\\infty} e^{-t(1/\\tau_b + i 2\\pi f)} dt$$\n$$H(f) = A_b \\left[ \\frac{e^{-t(1/\\tau_b + i 2\\pi f)}}{-(1/\\tau_b + i 2\\pi f)} \\right]_{0}^{\\infty} = \\frac{A_b}{1/\\tau_b + i 2\\pi f} = \\frac{A_b \\tau_b}{1 + i 2\\pi f \\tau_b}$$\n幅度的平方 $|H(f)|^2$ 为：\n$$|H(f)|^2 = H(f)H^*(f) = \\left(\\frac{A_b \\tau_b}{1 + i 2\\pi f \\tau_b}\\right) \\left(\\frac{A_b \\tau_b}{1 - i 2\\pi f \\tau_b}\\right) = \\frac{A_b^2 \\tau_b^2}{1 + (2\\pi f \\tau_b)^2}$$\n将此代入散粒噪声 PSD 公式，得到：\n$$S_b(f) = \\frac{\\lambda A_b^2 \\tau_b^2}{1 + (2\\pi f \\tau_b)^2}$$\n这个 PSD 也具有低通特性，但由于我们预期 $\\tau_b \\ll \\tau_t$，其频谱内容会延伸到比组织信号内容高得多的频率。\n\n3. 谱密度比 $\\mathrm{SDR}(f)$ 与截止频率 $f_c$\n\n谱密度比定义为：\n$$\\mathrm{SDR}(f) = \\frac{S_b(f)}{S_t(f)} = \\frac{\\frac{\\lambda A_b^2 \\tau_b^2}{1 + (2\\pi f \\tau_b)^2}}{\\frac{2\\sigma_t^2\\tau_t}{1 + (2\\pi f \\tau_t)^2}} = \\left( \\frac{\\lambda A_b^2 \\tau_b^2}{2\\sigma_t^2\\tau_t} \\right) \\frac{1 + (2\\pi f \\tau_t)^2}{1 + (2\\pi f \\tau_b)^2}$$\n让我们定义一个常数 $K = \\frac{\\lambda A_b^2 \\tau_b^2}{2\\sigma_t^2\\tau_t}$。那么 $\\mathrm{SDR}(f) = K \\frac{1 + (2\\pi f \\tau_t)^2}{1 + (2\\pi f \\tau_b)^2}$。\n在物理上，组织回波是慢现象（$\\tau_t$ 较大），而微泡是快事件（$\\tau_b$ 较小），所以我们预期 $\\tau_t > \\tau_b$。在此条件下，频率相关项的分子随 $f$ 的增长速度快于分母，这意味着对于 $f \\ge 0$，$\\mathrm{SDR}(f)$ 是一个单调递增函数。\n\n我们必须在 $[0, f_N]$ 范围内（其中 $f_N = f_s/2$ 是奈奎斯特频率）找到最小的频率 $f_c$，使得 $\\mathrm{SDR}(f_c) \\ge \\gamma$。\n算法如下：\n-   首先，计算 $f=0$ 时的 $\\mathrm{SDR}(f)$。$\\mathrm{SDR}(0) = K$。如果 $K \\ge \\gamma$，则条件在最低可能频率处得到满足，我们设 $f_c = 0$。\n-   接下来，计算频率范围上界 $f=f_N$ 处的 $\\mathrm{SDR}(f)$。如果 $\\mathrm{SDR}(f_N)  \\gamma$，则在允许的频带内条件永远不会满足。在这种情况下，我们设 $f_c = f_N$。\n-   否则，如果 $K  \\gamma$ 且 $\\mathrm{SDR}(f_N) \\ge \\gamma$，$\\mathrm{SDR}(f)$ 的单调性保证在 $(0, f_N)$ 区间内存在一个唯一的解 $f_c$ 使得等式成立。我们求解 $\\mathrm{SDR}(f_c) = \\gamma$：\n    $$K \\frac{1 + (2\\pi f_c \\tau_t)^2}{1 + (2\\pi f_c \\tau_b)^2} = \\gamma$$\n    $$K(1 + (2\\pi f_c)^2 \\tau_t^2) = \\gamma(1 + (2\\pi f_c)^2 \\tau_b^2)$$\n    $$K + K(2\\pi f_c)^2 \\tau_t^2 = \\gamma + \\gamma(2\\pi f_c)^2 \\tau_b^2$$\n    $$(2\\pi f_c)^2 (K \\tau_t^2 - \\gamma \\tau_b^2) = \\gamma - K$$\n    $$(2\\pi f_c)^2 = \\frac{\\gamma - K}{K \\tau_t^2 - \\gamma \\tau_b^2}$$\n    求解 $f_c$：\n    $$f_c = \\frac{1}{2\\pi} \\sqrt{\\frac{\\gamma - K}{K \\tau_t^2 - \\gamma \\tau_b^2}}$$\n该公式用于计算解严格位于 $0$ 和 $f_N$ 之间的情形下的截止频率。所提供的 Python 代码为每个测试用例实现了这一逻辑，计算了数值，并按要求格式化了它们。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_fc(fs, sigma_t, tau_t, A_b, tau_b, lam, gamma):\n    \"\"\"\n    Computes the cutoff frequency f_c based on the derived model.\n    \"\"\"\n    f_nyquist = fs / 2.0\n\n    # Calculate the frequency-independent constant K\n    K = (lam * A_b**2 * tau_b**2) / (2 * sigma_t**2 * tau_t)\n\n    # Case 1: Threshold is met at f = 0\n    # SDR(0) = K\n    if K >= gamma:\n        return 0.0\n\n    # Calculate SDR at the Nyquist frequency\n    term_t_nyquist = (2 * np.pi * f_nyquist * tau_t)**2\n    term_b_nyquist = (2 * np.pi * f_nyquist * tau_b)**2\n    sdr_nyquist = K * (1 + term_t_nyquist) / (1 + term_b_nyquist)\n\n    # Case 2: Threshold is never met within the frequency band\n    if sdr_nyquist  gamma:\n        return f_nyquist\n\n    # Case 3: Threshold is met within (0, f_N), solve for f_c\n    # (2*pi*f_c)^2 = (gamma - K) / (K * tau_t^2 - gamma * tau_b^2)\n    numerator = gamma - K\n    denominator = K * tau_t**2 - gamma * tau_b**2\n\n    # As derived in the theory, for a solution to exist in (0, f_N)\n    # when SDR is monotonic increasing, the denominator must be positive.\n    # This is a safe calculation under the problem's premises.\n    if denominator = 0:\n        # This branch should not be reached if the SDR is monotonic increasing\n        # and SDR(0)  gamma = SDR(f_N). It would imply a mathematical\n        # contradiction or a different regime (e.g. tau_t  tau_b).\n        # We return f_N as the most robust fallback.\n        return f_nyquist\n\n    fc_squared = (1 / (4 * np.pi**2)) * (numerator / denominator)\n    fc = np.sqrt(fc_squared)\n\n    return fc\n\ndef solve():\n    \"\"\"\n    Defines test cases, computes the cutoff frequency for each,\n    and prints the results in the specified format.\n    \"\"\"\n    # Test cases defined as tuples of:\n    # (f_s, sigma_t, tau_t, A_b, tau_b, lambda, gamma)\n    test_cases = [\n        (2000, 1.0, 0.05, 1.0, 0.001, 200.0, 2.0),     # Case A\n        (2000, 1.0, 0.05, 1.0, 0.001, 200.0, 0.001),    # Case B\n        (2000, 1.0, 0.05, 1.0, 0.001, 200.0, 10.0),    # Case C\n        (5000, 0.5, 0.08, 0.8, 0.0008, 150.0, 8.0)     # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        fs, st, tt, Ab, tb, l, g = case\n        fc = calculate_fc(fs, st, tt, Ab, tb, l, g)\n        results.append(f\"{fc:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "4939195"}, {"introduction": "在成功定位出微泡后，我们如何定量地评估定位结果的准确性？这是验证超分辨率成像系统性能的最后也是至关重要的一步。本练习要求你运用统计学基本概念，如偏差 ($ \\text{bias} $) 和均方根误差 ($ \\text{Root Mean Square Error, RMSE} $)，来量化定位精度。你将通过处理一组模拟的测量数据，亲手计算这些关键的性能指标，从而将抽象的理论定义转化为具体的评估能力 ([@problem_id:4939224])。", "problem": "考虑在超快超声成像中量化定位精度以实现点目标（如微泡）的超分辨率定位的任务。位于成像平面内真实空间位置 $\\mathbf{r}_0 = [x_0, z_0]^\\top$ 的点目标，在 $N$ 个超快帧中被重复定位，得到测量位置 $\\mathbf{r}_i = [x_i, z_i]^\\top$，其中 $i = 1, 2, \\dots, N$。测量模型定义为 $\\mathbf{r}_i = \\mathbf{r}_0 + \\mathbf{b} + \\boldsymbol{\\varepsilon}_i$，其中 $\\mathbf{b}$ 是一个未知的固定偏差向量，而 $\\boldsymbol{\\varepsilon}_i$ 是由系统的点扩散函数 (PSF)、采样和噪声引入的独立同分布的随机误差。基本基础包括以下定义：\n- 期望算子 $\\mathbb{E}[\\cdot]$ 和对 $N$ 次实现的样本平均。\n- $\\mathbb{R}^2$ 上的欧几里得范数 $\\lVert \\cdot \\rVert_2$。\n- 偏差定义为估计量与真实参数之间的期望误差向量。\n- 均方根误差 (RMSE) 定义为期望误差幅值平方的平方根。\n\n根据这些定义，推导横向 ($x$) 和轴向 ($z$) 方向上偏差分量的可计算估计量，以及沿每个轴和径向的均方根误差 (RMSE) 的可计算估计量。在一个程序中实现这些估计量，该程序接收所提供的重复测量和真实位置的测试套件，并为每种情况计算以下内容：\n- 沿 $x$ 和 $z$ 方向的估计偏差分量（以微米为单位）：$b_x$ 和 $b_z$。\n- 沿 $x$ 和 $z$ 方向的估计 RMSE（以微米为单位）：$\\mathrm{RMSE}_x$ 和 $\\mathrm{RMSE}_z$。\n- 估计的径向 RMSE（以微米为单位）：$\\mathrm{RMSE}_{\\mathrm{rad}}$，由二维误差向量计算得出。\n\n所有输出均以微米表示，并将每个报告值四舍五入到三位小数。本问题不涉及角度。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例按 $[b_x, b_z, \\mathrm{RMSE}_x, \\mathrm{RMSE}_z, \\mathrm{RMSE}_{\\mathrm{rad}}]$ 的顺序贡献一个列表。\n\n使用以下测试套件。每个案例都指定了 $\\mathbf{r}_0$ 和测量位置列表 $\\{\\mathbf{r}_i\\}_{i=1}^N$，所有单位均为微米：\n\n案例 1（理想路径，近无偏，各向同性小噪声）：\n- $\\mathbf{r}_0 = [\\,0,\\,0\\,]$\n- 测量值：\n  $[\\,1.2,\\,-0.8\\,]$, $[\\,-0.5,\\,0.3\\,]$, $[\\,0.9,\\,-0.2\\,]$, $[\\,-1.1,\\,0.7\\,]$, $[\\,0.0,\\,0.0\\,]$, $[\\,0.4,\\,-0.5\\,]$, $[\\,-0.8,\\,0.6\\,]$, $[\\,0.3,\\,-0.1\\,]$, $[\\,-0.2,\\,0.2\\,]$, $[\\,0.1,\\,-0.3\\,]$\n\n案例 2（各向异性噪声，横向扩散大于轴向扩散）：\n- $\\mathbf{r}_0 = [\\,0,\\,0\\,]$\n- 测量值：\n  $[\\,8.0,\\,1.5\\,]$, $[\\,-9.5,\\,-1.0\\,]$, $[\\,10.2,\\,2.0\\,]$, $[\\,-7.8,\\,-1.8\\,]$, $[\\,0.5,\\,0.2\\,]$, $[\\,5.5,\\,-0.7\\,]$, $[\\,-6.3,\\,1.1\\,]$, $[\\,9.1,\\,-2.2\\,]$, $[\\,-8.9,\\,0.9\\,]$, $[\\,7.7,\\,-0.4\\,]$\n\n案例 3（由校准引起的系统偏差；非零真实位置）：\n- $\\mathbf{r}_0 = [\\,50,\\,-30\\,]$\n- 测量值：\n  $[\\,55.8,\\,-33.2\\,]$, $[\\,54.1,\\,-32.5\\,]$, $[\\,55.0,\\,-33.1\\,]$, $[\\,56.3,\\,-33.4\\,]$, $[\\,55.5,\\,-33.0\\,]$, $[\\,54.7,\\,-32.8\\,]$, $[\\,55.9,\\,-33.6\\,]$, $[\\,55.2,\\,-33.3\\,]$, $[\\,54.9,\\,-32.7\\,]$, $[\\,56.1,\\,-33.5\\,]$\n\n案例 4（边界情况：单次测量）：\n- $\\mathbf{r}_0 = [\\,-20,\\,40\\,]$\n- 测量值：\n  $[\\,-18,\\,35\\,]$\n\n案例 5（边缘情况：零噪声）：\n- $\\mathbf{r}_0 = [\\,100,\\,100\\,]$\n- 测量值：\n  $[\\,100,\\,100\\,]$, $[\\,100,\\,100\\,]$, $[\\,100,\\,100\\,]$, $[\\,100,\\,100\\,]$, $[\\,100,\\,100\\,]$\n\n您的程序必须为每个案例计算所请求的度量指标，并按以下格式输出单行结果：\n$[\\,[b_{x,1},b_{z,1},\\mathrm{RMSE}_{x,1},\\mathrm{RMSE}_{z,1},\\mathrm{RMSE}_{\\mathrm{rad},1}],\\,[b_{x,2},b_{z,2},\\mathrm{RMSE}_{x,2},\\mathrm{RMSE}_{z,2},\\mathrm{RMSE}_{\\mathrm{rad},2}],\\,\\dots\\,]$\n其中每个数值条目均以微米表示，并四舍五入到三位小数。", "solution": "该问题在科学和数学上是合理的、自洽的且适定的。所有必要的信息和定义都已提供，足以推导出所请求统计量的估计量，并计算给定测试用例的这些值。我们开始进行求解。\n\n问题的核心是从 $N$ 个测量的有限集合中推导出偏差和均方根误差 (RMSE) 的可计算估计量。设点目标的真实位置为向量 $\\mathbf{r}_0 = [x_0, z_0]^\\top$。第 $i$ 次测量位置为 $\\mathbf{r}_i = [x_i, z_i]^\\top$，其中 $i = 1, 2, \\dots, N$。\n\n第 $i$ 次测量的总误差是测量位置与真实位置之间的向量差：\n$$ \\mathbf{e}_i = \\mathbf{r}_i - \\mathbf{r}_0 = [x_i - x_0, z_i - z_0]^\\top = [e_{x,i}, e_{z,i}]^\\top $$\n问题定义了一个测量模型 $\\mathbf{r}_i = \\mathbf{r}_0 + \\mathbf{b} + \\boldsymbol{\\varepsilon}_i$，其中 $\\mathbf{b}$ 是一个固定偏差，$\\boldsymbol{\\varepsilon}_i$ 是期望值为零的独立同分布随机误差，即 $\\mathbb{E}[\\boldsymbol{\\varepsilon}_i] = \\mathbf{0}$。因此，期望误差为 $\\mathbb{E}[\\mathbf{e}_i] = \\mathbb{E}[\\mathbf{r}_i - \\mathbf{r}_0] = \\mathbb{E}[\\mathbf{b} + \\boldsymbol{\\varepsilon}_i] = \\mathbf{b} + \\mathbb{E}[\\boldsymbol{\\varepsilon}_i] = \\mathbf{b}$。\n\n### 偏差估计\n\n问题将偏差定义为期望误差向量。对于一个包含无限次测量的总体，偏差向量 $\\mathbf{b} = [b_x, b_z]^\\top$ 由误差向量的期望给出：\n$$ \\mathbf{b} = \\mathbb{E}[\\mathbf{e}_i] $$\n偏差的分量为 $b_x = \\mathbb{E}[e_{x,i}]$ 和 $b_z = \\mathbb{E}[e_{z,i}]$。为了从 $N$ 次测量的有限样本中估计这些总体参数，我们使用样本均值作为期望的估计量。偏差向量的估计量（我们记作 $\\hat{\\mathbf{b}}$）是观测误差向量的平均值：\n$$ \\hat{\\mathbf{b}} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{e}_i = \\frac{1}{N} \\sum_{i=1}^N (\\mathbf{r}_i - \\mathbf{r}_0) $$\n因此，偏差分量 $b_x$ 和 $b_z$ 的估计量为：\n$$ \\hat{b}_x = \\frac{1}{N} \\sum_{i=1}^N (x_i - x_0) $$\n$$ \\hat{b}_z = \\frac{1}{N} \\sum_{i=1}^N (z_i - z_0) $$\n\n### 均方根误差 (RMSE) 估计\n\n问题将 RMSE 定义为期望误差幅值平方的平方根。我们将推导沿每个轴的 RMSE ($\\mathrm{RMSE}_x$, $\\mathrm{RMSE}_z$) 和总径向误差 ($\\mathrm{RMSE}_{\\mathrm{rad}}$) 的估计量。\n\n沿 $x$ 轴的均方误差 (MSE) 是误差分量平方 $e_{x,i}$ 的期望值：\n$$ \\mathrm{MSE}_x = \\mathbb{E}[e_{x,i}^2] = \\mathbb{E}[(x_i - x_0)^2] $$\n$\\mathrm{RMSE}_x$ 是 $\\mathrm{MSE}_x$ 的平方根。从样本中得到的 $\\mathrm{MSE}_x$ 的估计量是误差平方的样本均值：\n$$ \\widehat{\\mathrm{MSE}}_x = \\frac{1}{N} \\sum_{i=1}^N (x_i - x_0)^2 $$\n因此，$\\mathrm{RMSE}_x$ 的估计量为：\n$$ \\widehat{\\mathrm{RMSE}}_x = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (x_i - x_0)^2} $$\n完全类似地，$\\mathrm{RMSE}_z$ 的估计量为：\n$$ \\widehat{\\mathrm{RMSE}}_z = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (z_i - z_0)^2} $$\n对于径向 RMSE，我们考虑二维误差向量 $\\mathbf{e}_i$ 的幅值平方，即 $\\lVert \\mathbf{e}_i \\rVert_2^2 = e_{x,i}^2 + e_{z,i}^2$。径向 MSE 是该量的期望：\n$$ \\mathrm{MSE}_{\\mathrm{rad}} = \\mathbb{E}[\\lVert \\mathbf{e}_i \\rVert_2^2] = \\mathbb{E}[e_{x,i}^2 + e_{z,i}^2] = \\mathbb{E}[e_{x,i}^2] + \\mathbb{E}[e_{z,i}^2] = \\mathrm{MSE}_x + \\mathrm{MSE}_z $$\n$\\mathrm{MSE}_{\\mathrm{rad}}$ 的估计量是误差幅值平方的样本平均值：\n$$ \\widehat{\\mathrm{MSE}}_{\\mathrm{rad}} = \\frac{1}{N} \\sum_{i=1}^N \\lVert \\mathbf{e}_i \\rVert_2^2 = \\frac{1}{N} \\sum_{i=1}^N \\left( (x_i - x_0)^2 + (z_i-z_0)^2 \\right) $$\n这可以分解为：\n$$ \\widehat{\\mathrm{MSE}}_{\\mathrm{rad}} = \\frac{1}{N} \\sum_{i=1}^N (x_i - x_0)^2 + \\frac{1}{N} \\sum_{i=1}^N (z_i-z_0)^2 = \\widehat{\\mathrm{MSE}}_x + \\widehat{\\mathrm{MSE}}_z = (\\widehat{\\mathrm{RMSE}}_x)^2 + (\\widehat{\\mathrm{RMSE}}_z)^2 $$\n径向 RMSE 的估计量是径向 MSE 估计量的平方根：\n$$ \\widehat{\\mathrm{RMSE}}_{\\mathrm{rad}} = \\sqrt{\\widehat{\\mathrm{MSE}}_{\\mathrm{rad}}} = \\sqrt{(\\widehat{\\mathrm{RMSE}}_x)^2 + (\\widehat{\\mathrm{RMSE}}_z)^2} $$\n这些推导出的估计量——$\\hat{b}_x$, $\\hat{b}_z$, $\\widehat{\\mathrm{RMSE}}_x$, $\\widehat{\\mathrm{RMSE}}_z$, 和 $\\widehat{\\mathrm{RMSE}}_{\\mathrm{rad}}$——提供了处理测试用例所需的完整公式集。实现将为每个案例计算这五个量，将它们四舍五入到三位小数，并格式化最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"r0\": [0.0, 0.0],\n            \"measurements\": [\n                [1.2, -0.8], [-0.5, 0.3], [0.9, -0.2], [-1.1, 0.7], [0.0, 0.0],\n                [0.4, -0.5], [-0.8, 0.6], [0.3, -0.1], [-0.2, 0.2], [0.1, -0.3]\n            ]\n        },\n        {\n            \"r0\": [0.0, 0.0],\n            \"measurements\": [\n                [8.0, 1.5], [-9.5, -1.0], [10.2, 2.0], [-7.8, -1.8], [0.5, 0.2],\n                [5.5, -0.7], [-6.3, 1.1], [9.1, -2.2], [-8.9, 0.9], [7.7, -0.4]\n            ]\n        },\n        {\n            \"r0\": [50.0, -30.0],\n            \"measurements\": [\n                [55.8, -33.2], [54.1, -32.5], [55.0, -33.1], [56.3, -33.4], [55.5, -33.0],\n                [54.7, -32.8], [55.9, -33.6], [55.2, -33.3], [54.9, -32.7], [56.1, -33.5]\n            ]\n        },\n        {\n            \"r0\": [-20.0, 40.0],\n            \"measurements\": [\n                [-18.0, 35.0]\n            ]\n        },\n        {\n            \"r0\": [100.0, 100.0],\n            \"measurements\": [\n                [100.0, 100.0], [100.0, 100.0], [100.0, 100.0], [100.0, 100.0], [100.0, 100.0]\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = calculate_metrics(case[\"r0\"], case[\"measurements\"])\n        all_results.append(result)\n\n    # Format the final output string exactly as required.\n    # Convert each numeric result to a string with 3 decimal places.\n    # Join these into comma-separated strings for each case.\n    # Enclose each case's results in square brackets.\n    # Join all case strings with a comma.\n    # Enclose the final string in square brackets.\n    case_strings = []\n    for result_list in all_results:\n        formatted_list = [f\"{x:.3f}\" for x in result_list]\n        case_strings.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\ndef calculate_metrics(r0_list, measurements_list):\n    \"\"\"\n    Calculates bias and RMSE metrics for a single test case.\n\n    Args:\n        r0_list (list): The true position [x0, z0].\n        measurements_list (list of lists): The list of measured positions [[x1, z1], ...].\n\n    Returns:\n        list: A list of 5 floats [b_x, b_z, RMSE_x, RMSE_z, RMSE_rad].\n    \"\"\"\n    # Convert inputs to NumPy arrays for vectorized operations.\n    r0 = np.array(r0_list, dtype=float)\n    measurements = np.array(measurements_list, dtype=float)\n\n    # Number of measurements (N)\n    N = measurements.shape[0]\n\n    # Calculate the error vectors: e_i = r_i - r_0 for all i.\n    # This results in a (N, 2) array of errors.\n    errors = measurements - r0\n\n    # 1. Estimate bias components (b_x, b_z)\n    # The estimator for bias is the sample mean of the error vectors.\n    # np.mean(errors, axis=0) computes the mean of the x-components and z-components.\n    b_x, b_z = np.mean(errors, axis=0)\n\n    # 2. Estimate RMSE components (RMSE_x, RMSE_z)\n    # The estimator for MSE is the sample mean of the squared errors.\n    # The estimator for RMSE is the square root of the MSE estimator.\n    squared_errors = errors ** 2\n    mse_components = np.mean(squared_errors, axis=0)\n    rmse_x, rmse_z = np.sqrt(mse_components)\n\n    # 3. Estimate radial RMSE (RMSE_rad)\n    # The radial RMSE is sqrt(RMSE_x^2 + RMSE_z^2).\n    rmse_rad = np.sqrt(rmse_x**2 + rmse_z**2)\n    # Alternative calculation for validation:\n    # rmse_rad_alt = np.sqrt(np.mean(np.sum(errors**2, axis=1)))\n    # assert np.isclose(rmse_rad, rmse_rad_alt)\n    \n    # Return the metrics. Rounding is handled during final print formatting.\n    return [b_x, b_z, rmse_x, rmse_z, rmse_rad]\n\nsolve()\n```", "id": "4939224"}]}