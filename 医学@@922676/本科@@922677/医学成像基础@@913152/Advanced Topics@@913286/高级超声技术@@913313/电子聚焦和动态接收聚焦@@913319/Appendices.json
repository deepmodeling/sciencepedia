{"hands_on_practices": [{"introduction": "电子聚焦的精髓在于无需物理移动换能器即可操控超声波束。这项基础技能依赖于精确计算并施加在阵列中每个阵元上的时间延迟。本练习将引导您从第一性原理出发，推导这些延迟的计算方法，从而将波动理论与实际的波束形成器实现联系起来。[@problem_id:4882907]", "problem": "一个均匀线性超声阵列沿 $x$ 轴放置，阵元间距为 $p = 0.3\\ \\text{mm}$。介质是均匀的软组织，声速为 $c = 1540\\ \\text{m/s}$。考虑将中心频率为 $f = 5\\ \\text{MHz}$ 的窄带发射波束电子偏转到相对于阵列法线（$z$ 轴）成 $\\theta = 20^{\\circ}$ 的角度。利用平面波传播和时谐场相位的第一性原理推导，导出将平面波偏转到角度 $\\theta$ 所需的相邻阵元时间延迟增量 $\\Delta t$，以及在窄带（相移）近似下的相应相邻阵元相位差 $\\phi$。然后，根据推导出的 $\\phi$，判断是否需要进行相位缠绕（即 $\\phi \\geq 2\\pi$ 是否成立）。\n\n您的推导必须从时谐平面波的表示 $p(\\mathbf{r},t) \\propto \\exp\\!\\big(i(\\mathbf{k}\\cdot \\mathbf{r} - \\omega t)\\big)$、关系式 $\\omega = 2\\pi f$ 和 $\\lVert \\mathbf{k} \\rVert = k = \\omega/c$ 开始。不要假设任何聚焦定律；相反，应使用平面波偏转的基本几何原理来获得所需的阵元间延迟定律。\n\n使用上述参数计算 $\\Delta t$ 和 $\\phi$ 的数值。将您的数值答案四舍五入到四位有效数字。将 $\\Delta t$ 以纳秒为单位表示，将 $\\phi$ 以弧度为单位表示。以双元素行向量 $\\big[\\Delta t,\\ \\phi\\big]$ 的形式提供您的最终答案。并在您的推导过程中说明是否需要相位缠绕。", "solution": "该问题具有科学依据，提法得当，客观，并包含了推导唯一解所需的所有必要信息。这是医学成像和声学领域的标准问题。因此，该问题是有效的。\n\n我们从第一性原理开始推导。超声阵列是一个均匀的线性阵列，沿 $x$ 轴放置，阵元间距为 $p$。我们希望形成一个相对于阵列法线（即 $z$ 轴）以角度 $\\theta$ 传播的平面波。\n\n设阵元由整数 $n$ 索引，其中 $n=0$ 的阵元位于原点 $(x,z)=(0,0)$。第 $n$ 个阵元的位置由向量 $\\mathbf{r}_n = (np, 0, 0)$ 给出。\n\n平面波的特征是其波前，即等相位面。为了使平面波相对于 $z$ 轴偏转一个角度 $\\theta$，波前必须是平面的，并且垂直于传播方向。\n\n考虑一个在时间 $t=0$ 时通过原点 $(0,0)$ 的平面波前。为了使该波前以角度 $\\theta$ 传播，不同阵元发射的信号必须有适当的时间安排。我们来分析几何路径长度差。位于 $x=p$ 的阵元（即 $n=1$）与位于 $x=0$ 的阵元位置不同。对于一个在半空间 $z>0$ 中相对于 $z$ 轴以角度 $\\theta$ 传播的波前，从位于 $x=p$ 的阵元到波前的路径长度比从位于 $x=0$ 的阵元到波前的路径长度短一个量 $\\Delta L$。这个路径长度差由几何关系给出：\n$$ \\Delta L = p \\sin(\\theta) $$\n这是从原点阵元发出的波要到达与从 $x=p$ 处阵元发出的波相同的波前所必须传播的额外距离。为确保来自这两个阵元的信号对同​​一波前产生相长干涉，来自 $x=p$ 处阵元的信号必须相对于来自 $x=0$ 处阵元的信号进行时间延迟。这个时间延迟，我们表示为相邻阵元时间延迟增量 $\\Delta t$，必须恰好补偿传播路径差 $\\Delta L$ 所需的时间。\n因此，时间延迟为：\n$$ \\Delta t = \\frac{\\Delta L}{c} $$\n其中 $c$ 是介质中的声速。代入 $\\Delta L$ 的表达式，我们得到相邻阵元之间所需的时间延迟增量公式：\n$$ \\Delta t = \\frac{p \\sin(\\theta)}{c} $$\n对于位置在 $x_n = np$ 的第 $n$ 个阵元，相对于原点阵元的总延迟为 $t_n = n \\Delta t$。\n\n在窄带近似下，发射信号是时谐波，可以用复数形式表示为与 $\\exp(-i\\omega t)$ 成正比，其中 $\\omega$ 是角频率。时间延迟 $\\Delta t$ 对应于相位偏移 $\\phi$。延迟了 $\\Delta t$ 的信号表示为 $\\exp(-i\\omega(t-\\Delta t)) = \\exp(-i\\omega t)\\exp(i\\omega \\Delta t)$。项 $\\exp(i\\omega \\Delta t)$ 代表相位偏移 $\\phi$。\n因此，相邻阵元的相位差 $\\phi$ 为：\n$$ \\phi = \\omega \\Delta t $$\n角频率 $\\omega$ 与中心频率 $f$ 的关系为 $\\omega = 2\\pi f$。代入此关系和 $\\Delta t$ 的表达式：\n$$ \\phi = (2\\pi f) \\left( \\frac{p \\sin(\\theta)}{c} \\right) = \\frac{2\\pi f p \\sin(\\theta)}{c} $$\n我们也可以用波数 $k = \\omega/c = 2\\pi f / c = 2\\pi/\\lambda$ 来表示，其中 $\\lambda$ 是波长。\n$$ \\phi = k p \\sin(\\theta) $$\n这样就完成了所需公式的推导。\n\n现在，我们使用给定的参数计算数值：\n- 阵元间距: $p = 0.3\\ \\text{mm} = 0.3 \\times 10^{-3}\\ \\text{m}$\n- 声速: $c = 1540\\ \\text{m/s}$\n- 中心频率: $f = 5\\ \\text{MHz} = 5 \\times 10^6\\ \\text{Hz}$\n- 偏转角: $\\theta = 20^{\\circ}$\n\n首先，我们计算相邻阵元的时间延迟增量 $\\Delta t$：\n$$ \\Delta t = \\frac{(0.3 \\times 10^{-3}\\ \\text{m}) \\sin(20^{\\circ})}{1540\\ \\text{m/s}} $$\n使用 $\\sin(20^{\\circ}) \\approx 0.34202$：\n$$ \\Delta t \\approx \\frac{(0.3 \\times 10^{-3}) \\times 0.34202}{1540}\\ \\text{s} \\approx 6.6627 \\times 10^{-8}\\ \\text{s} $$\n题目要求答案以纳秒为单位（$1\\ \\text{ns} = 10^{-9}\\ \\text{s}$）。\n$$ \\Delta t \\approx 66.627\\ \\text{ns} $$\n四舍五入到四位有效数字，我们得到 $\\Delta t = 66.63\\ \\text{ns}$。\n\n接下来，我们计算相应的相邻阵元相位差 $\\phi$：\n$$ \\phi = \\omega \\Delta t = 2\\pi f \\Delta t $$\n$$ \\phi = 2\\pi (5 \\times 10^6\\ \\text{Hz}) (6.6627 \\times 10^{-8}\\ \\text{s}) $$\n$$ \\phi = 10\\pi \\times 10^6 \\times 6.6627 \\times 10^{-8}\\ \\text{rad} = 0.66627\\pi\\ \\text{rad} \\approx 2.0931\\ \\text{rad} $$\n四舍五入到四位有效数字，我们得到 $\\phi = 2.093\\ \\text{rad}$。\n\n最后，我们必须确定是否需要相位缠绕。当计算出的相位偏移 $\\phi$ 大于或等于 $2\\pi$ 时，需要进行相位缠绕，因为移相器可以施加的相移范围在 $[0, 2\\pi)$ 或 $(-\\pi, \\pi]$。\n我们将计算出的相位偏移 $\\phi$ 与 $2\\pi$进行比较：\n$$ \\phi \\approx 2.093\\ \\text{rad} $$\n$$ 2\\pi \\approx 2 \\times 3.14159 = 6.283\\ \\text{rad} $$\n因为 $2.093  6.283$，所以我们有 $\\phi  2\\pi$。因此，对于这个偏转角和这组参数，不需要进行相位缠绕。", "answer": "$$\\boxed{\\begin{pmatrix} 66.63  2.093 \\end{pmatrix}}$$", "id": "4882907"}, {"introduction": "在不同深度保持一致的图像质量是超声成像的一个主要挑战。动态接收聚焦通过连续调整焦点来解决此问题，而其中的一个关键组成部分是管理有效接收孔径的大小。在此练习中，您将设计一个“孔径增长律”，以维持恒定的$F$数，这是确保横向分辨率一致性的一个关键参数。[@problem_id:4882934]", "problem": "一个超声成像系统使用一个一维线性阵列，该阵列共有 $128$ 个相同的元件，中心间距（pitch）为 $p = 0.3\\ \\text{mm}$。在动态接收聚焦中，有效接收孔径随成像深度 $z$ 的增加而增大，旨在深度范围从 $z = 10\\ \\text{mm}$ 到 $z = 60\\ \\text{mm}$ 内保持一个近似恒定的 $F$ 数 $F \\approx 1.5$。假设以下具有物理依据的基础：\n- $F$ 数定义为 $F = z/D$，其中 $z$ 是焦深（成像深度），$D$ 是有效接收孔径宽度。\n- 对于一个均匀加权、中心对称的子孔径，该子孔径位于一个均匀线性阵列上，其切缝（kerf）可忽略不计，且元件宽度与间距相当，有效孔径宽度可近似为 $D \\approx N p$，其中 $N$ 是活动元件的数量，$p$ 是间距。\n- 子孔径必须使用整数个元件，并且不能超过整个阵列的大小，即 $N \\leq 128$。\n\n从这些基础出发，推导出一个动态接收孔径增长规律 $N(z)$，该规律根据深度 $z$ 选择活动元件的数量，以在指定范围内保持 $F \\approx 1.5$，同时满足整数和最大尺寸的约束。您的规律应使用最接近于由 $F = z/D$ 推导出的理想连续值的整数 $N$，并且在需要时应在达到全孔径极限时饱和。将 $z$ 视为以毫米为单位表示。\n\n请以仅包含 $z$ 的单一闭式表达式 $N(z)$ 的形式提供您的最终结果，并将所有常数进行数值简化。请以 $N(z)$ 的解析表达式形式给出您的答案；最终表达式中不应包含物理单位。", "solution": "该问题要求推导一个动态接收孔径增长规律，用函数 $N(z)$ 表示，该函数指定了活动元件数 $N$ 作为成像深度 $z$ 的函数。推导过程必须满足几个条件：保持近似恒定的 $F$ 数，尊重换能器元件的离散特性，并遵守阵列的物理尺寸限制。\n\n首先，对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- 元件总数：$128$\n- 中心间距：$p = 0.3\\ \\text{mm}$\n- 目标 $F$ 数：$F \\approx 1.5$\n- 成像深度范围：$z = 10\\ \\text{mm}$ 到 $z = 60\\ \\text{mm}$\n- $F$ 数的定义：$F = z/D$，其中 $D$ 是有效接收孔径宽度。\n- 孔径宽度的近似值：$D \\approx N p$，其中 $N$ 是活动元件的数量。\n- 对 $N$ 的约束：$N$ 必须是整数。\n- 对最大孔径的约束：$N \\le 128$。\n- 离散化规则：$N$ 应选择为最接近理想连续值的整数。\n- 饱和条件：该规律必须在达到全孔径极限时饱和。\n\n**第2步：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它基于超声波束形成的基本原理，包括 $F$ 数和孔径尺寸的定义，这些都是医学成像物理学的核心内容。所有给定的值和参数对于临床超声探头都是物理上现实的。该问题是适定的；它提供了足够的信息和清晰、一致的约束来推导出一个唯一的函数 $N(z)$。语言客观而精确。该问题不违反任何无效性标准。\n\n**第3步：结论与行动**\n问题有效。将提供一个合理的解答。\n\n**解答推导**\n\n问题的核心是保持一个恒定的 $F$ 数。$F$ 数 $F$、成像深度 $z$ 和孔径宽度 $D$ 之间的关系由下式给出：\n$$F = \\frac{z}{D}$$\n\n有效孔径宽度 $D$ 与活动元件数 $N$ 和间距 $p$ 之间的关系可通过以下近似式表示：\n$$D \\approx N p$$\n\n为了找到一个能够完美保持目标 $F$ 数的理想连续元件数 $N_{\\text{ideal}}$，我们可以结合这两个方程。将 $D$ 的表达式代入 $F$ 数方程，得到：\n$$F \\approx \\frac{z}{N p}$$\n\n求解 $N$，得到理想元件数作为深度 $z$ 的函数：\n$$N_{\\text{ideal}}(z) = \\frac{z}{F p}$$\n\n现在，我们代入给定的 $F$ 和 $p$ 的数值。目标 $F$ 数为 $F = 1.5$，间距为 $p = 0.3\\ \\text{mm}$。输入的 $z$ 被理解为以毫米为单位。\n$$N_{\\text{ideal}}(z) = \\frac{z}{1.5 \\times 0.3} = \\frac{z}{0.45}$$\n\n为了将常数表示为有理数，我们可以写成：\n$$N_{\\text{ideal}}(z) = \\frac{1}{0.45}z = \\frac{100}{45}z = \\frac{20}{9}z$$\n\n这个表达式给出了理想的元件数，它是一个连续的实数。然而，物理系统有两个约束必须被纳入 $N(z)$ 的最终规律中：\n1.  元件数 $N$ 必须是整数。问题指定使用“最接近的整数选择”。这在数学上等同于一个四舍五入函数。将一个非负数 $x$ 四舍五入到最近整数的标准实现是 $\\lfloor x + 0.5 \\rfloor$。\n2.  元件数 $N$ 不能超过阵列中可用的元件总数，即 $128$。这对 $N$ 施加了一个上限，即饱和。\n\n我们依次应用这两个约束。首先，我们将最接近整数的规则应用于 $N_{\\text{ideal}}(z)$：\n$$N_{\\text{rounded}}(z) = \\left\\lfloor N_{\\text{ideal}}(z) + \\frac{1}{2} \\right\\rfloor = \\left\\lfloor \\frac{20}{9}z + \\frac{1}{2} \\right\\rfloor$$\n\n接下来，我们应用饱和约束。活动元件的数量不能超过 $128$。这意味着如果计算出的四舍五入后的元件数超过 $128$，它必须被限制在 $128$。这可以用最小值函数表示：\n$$N(z) = \\min\\left(N_{\\text{rounded}}(z), 128\\right)$$\n\n代入 $N_{\\text{rounded}}(z)$ 的表达式，我们得到动态接收孔径增长规律的最终闭式表达式：\n$$N(z) = \\min\\left(\\left\\lfloor \\frac{20}{9}z + \\frac{1}{2} \\right\\rfloor, 128\\right)$$\n\n这个 $N(z)$ 的表达式为任何给定的深度 $z$（单位为毫米）提供了活动元件的数量，满足了问题陈述中指定的所有条件。元件数量随深度线性增长（以阶梯状整数方式），直到孔径在达到 $128$ 个元件的全阵列尺寸时饱和。", "answer": "$$\\boxed{\\min\\left(\\left\\lfloor \\frac{20}{9}z + \\frac{1}{2} \\right\\rfloor, 128\\right)}$$", "id": "4882934"}, {"introduction": "高级波束形成技术的最终目标是生成更清晰、伪影更少的图像。本练习将从解析公式转向完整的系统仿真，让您能够将作为图像质量关键指标的点扩散函数（PSF）可视化。您将实现并比较标准成像序列与先进的相干复合方法，以量化后者在抑制旁瓣伪影方面的强大效果。[@problem_id:4882937]", "problem": "考虑一个一维线性超声阵列，在均匀介质中执行电子发射偏转和动态接收聚焦。使用以下经过充分检验的物理定律和定义作为唯一的建模基础：(i) 对于距离 $r$ 和声速 $c$，传播时间为 $t = r/c$；(ii) 中心频率为 $f_0$ 的窄带正弦波在传播延迟 $t$ 后的基带响应为 $\\exp(-j 2 \\pi f_0 t)$；以及 (iii) 动态接收聚焦是通过使用到每个波束形成点的假设传播时间进行匹配滤波（相位共轭）来实现的。一个单位振幅的点散射体位于 $(x_s, z_s) = (0, z_0)$，其中 $z_0  0$。换能器沿 $x$ 轴位于 $z = 0$ 处。$N$ 个阵元以原点为中心，间距为 $p$ 均匀分布，因此对于整数 $m \\in \\{0,1,\\dots,N-1\\}$，阵元 $m$ 的横向坐标为 $x_m = \\left(m - \\frac{N-1}{2}\\right) p$。在 $t=0$ 时，从阵列平面发射两次平面波，偏转角为 $\\theta = \\pm 10^\\circ$（度）。一个以角度 $\\theta$ 偏转的平面波到达空间位置 $(x,z)$ 的时间，与 $(x,z)$ 在平面波传播方向上的投影成正比，即，使用传播时间模型 $t_{\\mathrm{tx}}^{(\\theta)}(x,z) = \\left(x \\sin \\theta + z \\cos \\theta\\right)/c$，不计一个无关紧要的加法常数。从 $(x,z)$ 到阵元 $m$ 的接收时间是 $t_{\\mathrm{rx}}(x,z;x_m) = \\sqrt{(x_m - x)^2 + z^2}/c$。假设衰减和角度灵敏度可忽略不计，且所有阵元具有相同的灵敏度。对于给定的发射角 $\\theta$，由位于 $(0,z_0)$ 的实际散射体引起的阵元 $m$ 处的复基带信号为 $s_m^{(\\theta)} = \\exp\\left(-j 2 \\pi f_0 \\left[t_{\\mathrm{tx}}^{(\\theta)}(0,z_0) + t_{\\mathrm{rx}}(0,z_0;x_m)\\right]\\right)$。为了在横向测试位置 $x$（深度为 $z_0$）处形成动态聚焦的波束形成输出，应用与相同发射角 $\\theta$ 下到 $(x,z_0)$ 的假设传播时间相对应的匹配滤波延迟，得到 $b^{(\\theta)}(x) = \\sum_{m=0}^{N-1} s_m^{(\\theta)} \\exp\\left(+j 2 \\pi f_0 \\left[t_{\\mathrm{tx}}^{(\\theta)}(x,z_0) + t_{\\mathrm{rx}}(x,z_0;x_m)\\right]\\right)$。将双角度相干复合输出定义为 $b^{\\mathrm{comp}}(x) = \\sum_{\\theta \\in \\{-10^\\circ,+10^\\circ\\}} b^{(\\theta)}(x)$。点扩散函数 (PSF) 是在固定深度 $z_0$ 下，作为横向位置 $x$ 的函数的波束形成输出的幅度 $|b(x)|$。将每个 PSF 通过其在评估的 $x$ 范围内的最大值进行归一化。将峰值周围的主瓣区域定义为归一化 PSF 幅度的全局最大值左右两侧第一个局部最小值之间的区间。将峰值旁瓣电平 (PSL) 定义为主瓣区域外归一化 PSF 幅度的最大值。为与单角度聚焦进行比较，仅使用 $\\theta = +10^\\circ$ 作为单角度情况。\n\n任务：编写一个程序，计算 $\\theta = +10^\\circ$ 时的归一化单角度 PSF，以及 $\\theta \\in \\{-10^\\circ,+10^\\circ\\}$ 时的归一化相干复合 PSF，然后通过计算单角度 PSL 和复合 PSL 之间的分贝差来量化由复合引起的旁瓣降低，即 $20 \\log_{10}(\\mathrm{PSL}_{\\mathrm{single}}) - 20 \\log_{10}(\\mathrm{PSL}_{\\mathrm{comp}})$。在输出中以分贝为单位，用浮点数表示最终答案。在发射模型中，角度必须以度为单位进行解释，物理量必须使用国际单位制：$x$ 和 $z$ 以 $\\mathrm{m}$ 为单位，$c$ 以 $\\mathrm{m/s}$ 为单位，$f_0$ 以 $\\mathrm{Hz}$ 为单位，$p$ 以 $\\mathrm{m}$ 为单位。横向评估网格必须在指定范围内均匀分布。程序应实现上述定义，不得引入任何替代的波束图样公式或近似。\n\n测试套件：您的程序必须按此顺序执行以下三个参数集，并为每个参数集输出旁瓣降低值：\n\n- 案例 $1$（典型孔径和深度）：$N = 128$，$p = 0.0003\\,\\mathrm{m}$，$f_0 = 5.0 \\times 10^6\\,\\mathrm{Hz}$，$c = 1540\\,\\mathrm{m/s}$，$z_0 = 0.040\\,\\mathrm{m}$，横向网格 $x \\in [-0.015\\,\\mathrm{m}, 0.015\\,\\mathrm{m}]$，步长 $\\Delta x = 0.00005\\,\\mathrm{m}$。\n- 案例 $2$（较小孔径，较浅目标）：$N = 64$，$p = 0.0003\\,\\mathrm{m}$，$f_0 = 5.0 \\times 10^6\\,\\mathrm{Hz}$，$c = 1540\\,\\mathrm{m/s}$，$z_0 = 0.020\\,\\mathrm{m}$，横向网格 $x \\in [-0.015\\,\\mathrm{m}, 0.015\\,\\mathrm{m}]$，步长 $\\Delta x = 0.00005\\,\\mathrm{m}$。\n- 案例 $3$（更密间距，更高频率，更深目标）：$N = 128$，$p = 0.0002\\,\\mathrm{m}$，$f_0 = 7.5 \\times 10^6\\,\\mathrm{Hz}$，$c = 1540\\,\\mathrm{m/s}$，$z_0 = 0.050\\,\\mathrm{m}$，横向网格 $x \\in [-0.010\\,\\mathrm{m}, 0.010\\,\\mathrm{m}]$，步长 $\\Delta x = 0.00005\\,\\mathrm{m}$。\n\n输出规格：您的程序应生成单行输出，其中包含三个案例的旁瓣降低值，以分贝为单位，四舍五入到三位小数，形式为用方括号括起来的逗号分隔列表，例如 $[a_1,a_2,a_3]$，其中每个 $a_k$ 都是一个浮点数。不应打印任何其他文本。", "solution": "用户提供的问题被评估为科学上合理、内容完整且定义明确。所有物理模型、数学定义和数值参数都得到了明确提供，并与医学超声成像领域的既定原则一致。任务是基于这些第一性原理实现直接模拟。\n\n解决方案首先构建波束形成信号的数学模型，然后定义计算点扩散函数 (PSF) 和峰值旁瓣电平 (PSL) 的程序，最后将此程序应用于指定的测试案例。\n\n首先，我们确定几何和物理参数。该系统由一个包含 $N$ 个换能器阵元的线性阵列组成。对于 $m \\in \\{0, 1, \\dots, N-1\\}$，第 $m$ 个阵元的位置由 $x_m = \\left(m - \\frac{N-1}{2}\\right) p$ 给出，其中 $p$ 是阵元间距。一个单点散射体位于 $(x_s, z_s) = (0, z_0)$。介质的声速恒定为 $c$。换能器的工作中心频率为 $f_0$。为方便起见，定义声波数 $k = \\frac{2\\pi f_0}{c}$。\n\n成像过程包括两个阶段：发射和接收。\n1.  **发射阶段**：一个平面波被电子偏转，与 $z$ 轴形成角度 $\\theta$。该波前从阵列平面（$z=0$）传播到点 $(x, z)$ 所需的时间由 $t_{\\mathrm{tx}}^{(\\theta)}(x,z) = (x \\sin\\theta + z \\cos\\theta)/c$ 给出。对于位于 $(0, z_0)$ 的散射体，发射传播时间为 $t_{\\mathrm{tx}}^{(\\theta)}(0, z_0) = (z_0 \\cos\\theta)/c$。\n\n2.  **接收阶段**：散射后，超声波从位于 $(0, z_0)$ 的散射体传播到位于 $(x_m, 0)$ 的每个阵元 $m$。这是一个球面波，到阵元 $m$ 的传播时间由欧几里得距离确定：$t_{\\mathrm{rx}}(0, z_0; x_m) = \\frac{\\sqrt{(x_m - 0)^2 + (0 - z_0)^2}}{c} = \\frac{\\sqrt{x_m^2 + z_0^2}}{c}$。\n\n对于给定的发射角 $\\theta$，从发射到在阵元 $m$ 处接收的总传播时间是发射和接收时间之和：$T_m^{(\\theta)} = t_{\\mathrm{tx}}^{(\\theta)}(0, z_0) + t_{\\mathrm{rx}}(0, z_0; x_m)$。在阵元 $m$ 处接收到的复基带信号被建模为与此总延迟相对应的相位旋转：\n$$s_m^{(\\theta)} = \\exp(-j 2\\pi f_0 T_m^{(\\theta)}) = \\exp\\left(-j k \\left[z_0 \\cos\\theta + \\sqrt{x_m^2 + z_0^2}\\right]\\right)$$\n\n为了重建图像，使用一种称为动态接收聚焦的技术对接收到的信号进行相干求和。这个过程等效于匹配滤波，它对来自每个阵元的信号应用一个共轭相移，该相移对应于从焦点 $(x, z_0)$ 到该阵元的*假设*传播时间。对于给定的发射角 $\\theta$，从发射到焦点 $(x, z_0)$ 再到阵元 $m$ 的总假设传播时间为 $T_{m,\\text{focus}}^{(\\theta)}(x, z_0) = t_{\\mathrm{tx}}^{(\\theta)}(x, z_0) + t_{\\mathrm{rx}}(x, z_0; x_m)$。\n阵元 $m$ 的聚焦相移为 $\\exp(+j 2\\pi f_0 T_{m,\\text{focus}}^{(\\theta)}(x, z_0))$。\n\n对于发射角 $\\theta$ 的波束形成输出是所有阵元的相干和，在已知深度 $z_0$ 的横向测试位置 $x$ 处进行评估：\n$$b^{(\\theta)}(x) = \\sum_{m=0}^{N-1} s_m^{(\\theta)} \\exp\\left(+j 2\\pi f_0 \\left[t_{\\mathrm{tx}}^{(\\theta)}(x, z_0) + t_{\\mathrm{rx}}(x, z_0; x_m)\\right]\\right)$$\n代入信号和聚焦延迟的表达式，以及传播时间的定义：\n$$b^{(\\theta)}(x) = \\sum_{m=0}^{N-1} \\exp\\left(-j k \\left[z_0 \\cos\\theta + \\sqrt{x_m^2 + z_0^2}\\right]\\right) \\exp\\left(+j k \\left[x \\sin\\theta + z_0 \\cos\\theta + \\sqrt{(x_m - x)^2 + z_0^2}\\right]\\right)$$\n项 $j k z_0 \\cos\\theta$ 被消去，表达式简化为：\n$$b^{(\\theta)}(x) = \\sum_{m=0}^{N-1} \\exp\\left(j k \\left[x \\sin\\theta + \\sqrt{(x_m - x)^2 + z_0^2} - \\sqrt{x_m^2 + z_0^2}\\right]\\right)$$\n这是需要实现的基本方程。\n\n问题要求在单角度情况和相干复合情况之间进行比较。\n-   单角度波束形成输出使用 $\\theta = +10^\\circ$：$b^{\\mathrm{single}}(x) = b^{(+10^\\circ)}(x)$。\n-   相干复合输出将 $\\theta = +10^\\circ$ 和 $\\theta = -10^\\circ$ 的结果相加：$b^{\\mathrm{comp}}(x) = b^{(+10^\\circ)}(x) + b^{(-10^\\circ)}(x)$。\n\n点扩散函数 (PSF) 是复数波束形成输出的幅度，并对其最大值进行归一化。对于单角度情况：\n$$\\mathrm{PSF}_{\\mathrm{single}}(x) = \\frac{|b^{\\mathrm{single}}(x)|}{\\max_x |b^{\\mathrm{single}}(x)|}$$\n对于复合情况也类似：\n$$\\mathrm{PSF}_{\\mathrm{comp}}(x) = \\frac{|b^{\\mathrm{comp}}(x)|}{\\max_x |b^{\\mathrm{comp}}(x)|}$$\n\n峰值旁瓣电平 (PSL) 是主瓣外归一化 PSF 的最大值。主瓣被定义为全局最大值左右两侧第一个局部最小值之间的区域。找到 PSL 的算法如下：\n1.  在指定的横向网格 $x$ 上计算归一化 PSF。\n2.  定位全局最大值的索引（主瓣的峰值）。\n3.  识别 PSF 的所有局部最小值。这可以通过找到负 PSF 的峰值来实现。\n4.  找到全局最大值左右两侧第一个局部最小值的索引。这些索引定义了主瓣的边界。\n5.  旁瓣区域由该主瓣区间外的所有点组成。\n6.  PSL 是旁瓣区域中 PSF 的最大值。\n\n最后，由复合引起的旁瓣降低被量化为 PSL 值在分贝 (dB) 标度上的差异：\n$$\\Delta_{\\mathrm{PSL}} [\\text{dB}] = 20 \\log_{10}(\\mathrm{PSL}_{\\mathrm{single}}) - 20 \\log_{10}(\\mathrm{PSL}_{\\mathrm{comp}})$$\n\n此程序应用于问题陈述中提供的三个测试案例中的每一个。实现将使用 `numpy` 进行高效的数组计算，并使用 `scipy.signal.find_peaks` 来识别 PSF 的局部最小值。以度为单位给出的角度必须转换为弧度，才能在三角函数中使用。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the Point Spread Functions (PSFs) for single-angle and \n    coherently compounded plane-wave imaging, calculates the Peak Sidelobe Level (PSL) \n    for each, and determines the sidelobe reduction in decibels.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"N\": 128, \"p\": 0.0003, \"f0\": 5.0e6, \"c\": 1540, \"z0\": 0.040,\n            \"x_range\": [-0.015, 0.015], \"dx\": 0.00005\n        },\n        {\n            \"N\": 64, \"p\": 0.0003, \"f0\": 5.0e6, \"c\": 1540, \"z0\": 0.020,\n            \"x_range\": [-0.015, 0.015], \"dx\": 0.00005\n        },\n        {\n            \"N\": 128, \"p\": 0.0002, \"f0\": 7.5e6, \"c\": 1540, \"z0\": 0.050,\n            \"x_range\": [-0.010, 0.010], \"dx\": 0.00005\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        p = case[\"p\"]\n        f0 = case[\"f0\"]\n        c = case[\"c\"]\n        z0 = case[\"z0\"]\n        x_min, x_max = case[\"x_range\"]\n        dx = case[\"dx\"]\n\n        # 1. Define Geometry and Grid\n        k = 2 * np.pi * f0 / c\n        thetas_deg = [-10.0, 10.0]\n        thetas_rad = np.deg2rad(thetas_deg)\n        x_m = (np.arange(N) - (N - 1) / 2) * p\n        x_grid = np.arange(x_min, x_max + dx, dx)\n\n        # 2. Calculate Beamformed Outputs\n        \n        # Reshape for broadcasting\n        # x_m: (N,) - (N, 1)\n        # x_grid: (M,) - (1, M) where M is number of grid points\n        x_m_bc = x_m[:, np.newaxis]\n        x_grid_bc = x_grid[np.newaxis, :]\n\n        # Term for actual scatterer at (0, z0)\n        rx_dist_scatterer = np.sqrt(x_m_bc**2 + z0**2)\n        \n        # Term for hypothesized scatterer at (x, z0)\n        rx_dist_focus = np.sqrt((x_m_bc - x_grid_bc)**2 + z0**2)\n        \n        # Calculate b_theta for each steering angle\n        b_thetas = []\n        for theta in thetas_rad:\n            phase = k * (x_grid_bc * np.sin(theta) + rx_dist_focus - rx_dist_scatterer)\n            b_theta = np.sum(np.exp(1j * phase), axis=0)\n            b_thetas.append(b_theta)\n\n        # 3. Form Single-Angle and Compounded Outputs\n        b_single = b_thetas[1]  # Using theta = +10 degrees\n        b_comp = b_thetas[0] + b_thetas[1]\n\n        # 4. Calculate Normalized PSFs\n        psf_single = np.abs(b_single)\n        psf_single_norm = psf_single / np.max(psf_single)\n\n        psf_comp = np.abs(b_comp)\n        psf_comp_norm = psf_comp / np.max(psf_comp)\n\n        # 5. Calculate PSL for each PSF\n        def find_psl(psf):\n            \"\"\"\n            Calculates the Peak Sidelobe Level (PSL) for a given normalized PSF.\n            \"\"\"\n            # Find the mainlobe peak\n            peak_idx = np.argmax(psf)\n            \n            # Find all local minima by finding peaks of the inverted PSF\n            minima_indices, _ = signal.find_peaks(-psf)\n            \n            # Find the first minima to the left and right of the main peak\n            left_minima = minima_indices[minima_indices  peak_idx]\n            right_minima = minima_indices[minima_indices  peak_idx]\n            \n            if left_minima.size == 0 or right_minima.size == 0:\n                # Fallback if no minima found on one side, which is unlikely for these PSFs.\n                # In this case, we cannot define the sidelobe region properly as per the problem.\n                # Returning NaN would indicate an issue with the PSF shape or grid extent.\n                return np.nan\n\n            first_left_min_idx = np.max(left_minima)\n            first_right_min_idx = np.min(right_minima)\n            \n            # The sidelobe regions are everything outside the mainlobe,\n            # including the minima themselves.\n            sidelobe_values = np.concatenate((psf[:first_left_min_idx + 1], psf[first_right_min_idx:]))\n            \n            if sidelobe_values.size == 0:\n                return 0.0 # No sidelobes present\n            \n            return np.max(sidelobe_values)\n\n        psl_single = find_psl(psf_single_norm)\n        psl_comp = find_psl(psf_comp_norm)\n        \n        # 6. Calculate Sidelobe Reduction in dB\n        # Ensure PSL values are  0 to avoid log(0) issues.\n        # Given the nature of diffraction, PSL will be  0.\n        db_diff = 20 * np.log10(psl_single) - 20 * np.log10(psl_comp)\n        results.append(db_diff)\n\n    # Final print statement in the exact required format.\n    # The problem asks for rounding to three decimal places.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "4882937"}]}