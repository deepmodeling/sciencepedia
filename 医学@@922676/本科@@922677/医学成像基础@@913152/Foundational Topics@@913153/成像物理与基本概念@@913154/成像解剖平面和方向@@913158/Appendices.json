{"hands_on_practices": [{"introduction": "将患者的医学影像与标准化的解剖图谱对齐，是进行跨个体比较和群体分析的关键步骤。这项实践旨在通过对齐关键解剖标志点，来确定一个将患者坐标系映射到图谱坐标系的刚性变换（旋转和平移）。通过这个练习 [@problem_id:4894133]，你将掌握定义和关联三维坐标系的基本技能，这是图像配准中的核心概念。", "problem": "一个脑部磁共振成像 (MRI) 容积数据将与一个标准图谱坐标系进行刚性对齐，该坐标系由前联合 (AC)、后联合 (PC) 和一个上中矢状点定义。该图谱坐标系的构建方式如下：AC 为原点，AC–PC 连线定义 $y$ 轴正方向，上中矢状点定义 $z$ 轴正方向，最终形成的坐标系为右手坐标系。在这个标准图谱坐标系中，标志点的位置由下式给出\n$\\mathbf{a}_{\\mathrm{AC}} = (0, 0, 0)$ mm, $\\mathbf{a}_{\\mathrm{PC}} = (0, 25, 0)$ mm, and $\\mathbf{a}_{\\mathrm{MS}} = (0, 0, 30)$ mm.\n在患者的 MRI 图像中，测得的相应标志点位置为\n$\\mathbf{p}_{\\mathrm{AC}} = (10, -5, 2)$ mm, $\\mathbf{p}_{\\mathrm{PC}} = (35, -5, 2)$ mm, and $\\mathbf{p}_{\\mathrm{MS}} = (10, 25, 2)$ mm.\n假设图谱和患者的标志点非共线，并根据标准的神经解剖学方向，通过标志点的直线连接来定义各自的局部坐标轴：AC–PC 向量定义 $y$ 轴，AC–MS 向量定义 $z$ 轴，并通过向量叉积选择 $x$ 轴以构成一个右手标准正交三元组。仅使用这些定义以及旋转和平移的刚性约束，推导将患者标志点映射到图谱标志点的唯一刚性变换 $(\\mathbf{R}, \\mathbf{t})$，其中 $\\mathbf{R}$ 是一个 $3 \\times 3$ 的旋转矩阵，$\\mathbf{t}$ 是一个 $3 \\times 1$ 的平移向量，并且 $\\mathbf{R}\\mathbf{p} + \\mathbf{t}$ 将患者坐标 $\\mathbf{p}$ 映射到图谱坐标系中。\n\n为了进行质量控制，在图谱中识别了第四个解剖点，其位置为 $\\mathbf{a}_{4} = (12, 8, 15)$ mm。对应的患者测量值为 $\\mathbf{p}_{4} = (18.6, 9.6, 14.3)$ mm。将推导出的刚性变换应用于所有四个患者点后，计算这四个标志点对应关系的均方根 (RMS) 残差，\n$$E_{\\mathrm{RMS}} = \\left( \\frac{\\sum_{i=1}^{4} \\|\\mathbf{R}\\mathbf{p}_{i} + \\mathbf{t} - \\mathbf{a}_{i}\\|^{2}}{4} \\right)^{1/2},$$\n其中 $\\|\\cdot\\|$ 表示欧几里得范数，$(\\mathbf{p}_{i}, \\mathbf{a}_{i})$ 表示 AC、PC、MS 和第四个点的患者-图谱标志点对。将您计算出的 $E_{\\mathrm{RMS}}$ 最终数值结果四舍五入至四位有效数字，并以毫米为单位表示。", "solution": "该问题是有效的，因为它具有科学依据、问题适定且客观。它描述了医学成像中一个标准的基于标志点的刚性配准任务。\n\n目标是找到一个刚性变换 $(\\mathbf{R}, \\mathbf{t})$，它将患者坐标系中的点 $\\mathbf{p}$ 映射到图谱坐标系中的点 $\\mathbf{a}$，使得 $\\mathbf{a} = \\mathbf{R}\\mathbf{p} + \\mathbf{t}$。该变换通过对齐两个坐标系来确定：一个由患者标志点定义，另一个由图谱标志点定义。\n\n首先，我们为图谱坐标系（表示为 $A$）构建标准正交基。原点为 $\\mathbf{O}_A = \\mathbf{a}_{\\mathrm{AC}} = (0, 0, 0)$。基向量 $(\\mathbf{u}_{xA}, \\mathbf{u}_{yA}, \\mathbf{u}_{zA})$ 的构建如下：\n$y$ 轴由从 $\\mathbf{a}_{\\mathrm{AC}}$ 到 $\\mathbf{a}_{\\mathrm{PC}}$ 的向量定义。\n$$ \\mathbf{v}_{yA} = \\mathbf{a}_{\\mathrm{PC}} - \\mathbf{a}_{\\mathrm{AC}} = \\begin{pmatrix} 0 \\\\ 25 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 25 \\\\ 0 \\end{pmatrix} $$\n单位向量为 $\\mathbf{u}_{yA} = \\frac{\\mathbf{v}_{yA}}{\\|\\mathbf{v}_{yA}\\|} = \\frac{1}{25}\\begin{pmatrix} 0 \\\\ 25 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}$。\n$z$ 轴由从 $\\mathbf{a}_{\\mathrm{AC}}$ 到 $\\mathbf{a}_{\\mathrm{MS}}$ 的向量定义。\n$$ \\mathbf{v}_{zA} = \\mathbf{a}_{\\mathrm{MS}} - \\mathbf{a}_{\\mathrm{AC}} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 30 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 30 \\end{pmatrix} $$\n单位向量为 $\\mathbf{u}_{zA} = \\frac{\\mathbf{v}_{zA}}{\\|\\mathbf{v}_{zA}\\|} = \\frac{1}{30}\\begin{pmatrix} 0 \\\\ 0 \\\\ 30 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$。\n$x$ 轴构成右手标准正交系：\n$$ \\mathbf{u}_{xA} = \\mathbf{u}_{yA} \\times \\mathbf{u}_{zA} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} \\times \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n图谱坐标系的基矩阵 $\\mathbf{M}_A = [\\mathbf{u}_{xA} \\ \\mathbf{u}_{yA} \\ \\mathbf{u}_{zA}]$ 是单位矩阵 $\\mathbf{I}$。\n$$ \\mathbf{M}_A = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} $$\n\n接下来，我们为患者坐标系（表示为 $P$）构建标准正交基。原点为 $\\mathbf{O}_P = \\mathbf{p}_{\\mathrm{AC}} = (10, -5, 2)$。根据问题描述构建基向量 $(\\mathbf{u}_{xP}, \\mathbf{u}_{yP}, \\mathbf{u}_{zP})$。\n$y$ 轴由从 $\\mathbf{p}_{\\mathrm{AC}}$ 到 $\\mathbf{p}_{\\mathrm{PC}}$ 的向量定义。\n$$ \\mathbf{v}_{yP} = \\mathbf{p}_{\\mathrm{PC}} - \\mathbf{p}_{\\mathrm{AC}} = \\begin{pmatrix} 35 \\\\ -5 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 10 \\\\ -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 25 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n单位向量为 $\\mathbf{u}_{yP} = \\frac{\\mathbf{v}_{yP}}{\\|\\mathbf{v}_{yP}\\|} = \\frac{1}{25}\\begin{pmatrix} 25 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n$z$ 轴的初始向量是从 $\\mathbf{p}_{\\mathrm{AC}}$ 到 $\\mathbf{p}_{\\mathrm{MS}}$。\n$$ \\mathbf{v}_{zP} = \\mathbf{p}_{\\mathrm{MS}} - \\mathbf{p}_{\\mathrm{AC}} = \\begin{pmatrix} 10 \\\\ 25 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 10 \\\\ -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 30 \\\\ 0 \\end{pmatrix} $$\n我们检查 $\\mathbf{v}_{yP}$ 和 $\\mathbf{v}_{zP}$ 之间的正交性：$\\mathbf{v}_{yP} \\cdot \\mathbf{v}_{zP} = (25)(0) + (0)(30) + (0)(0) = 0$。这两个向量已经正交，因此不需要进行格拉姆-施密特正交化。我们只需将 $\\mathbf{v}_{zP}$ 单位化。\n$$ \\mathbf{u}_{zP} = \\frac{\\mathbf{v}_{zP}}{\\|\\mathbf{v}_{zP}\\|} = \\frac{1}{30}\\begin{pmatrix} 0 \\\\ 30 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} $$\n$x$ 轴构成右手标准正交系：\n$$ \\mathbf{u}_{xP} = \\mathbf{u}_{yP} \\times \\mathbf{u}_{zP} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\times \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\n患者坐标系的基矩阵为 $\\mathbf{M}_P = [\\mathbf{u}_{xP} \\ \\mathbf{u}_{yP} \\ \\mathbf{u}_{zP}]$。\n$$ \\mathbf{M}_P = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 1  0  0 \\end{pmatrix} $$\n\n刚性变换 $(\\mathbf{R}, \\mathbf{t})$ 关联了患者和图谱的坐标系。一个点 $\\mathbf{p}$ 是相对于其坐标系的原点和基来表示的。该变换对齐了这些基和原点。旋转矩阵 $\\mathbf{R}$ 将患者基映射到图谱基上：$\\mathbf{R}\\mathbf{M}_P = \\mathbf{M}_A$。因此，$\\mathbf{R} = \\mathbf{M}_A \\mathbf{M}_P^{-1} = \\mathbf{M}_A \\mathbf{M}_P^T$。\n因为 $\\mathbf{M}_A = \\mathbf{I}$，我们有 $\\mathbf{R} = \\mathbf{M}_P^T$。\n$$ \\mathbf{R} = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 1  0  0 \\end{pmatrix}^T = \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix} $$\n平移向量 $\\mathbf{t}$ 在旋转后对齐原点：$\\mathbf{R}\\mathbf{O}_P + \\mathbf{t} = \\mathbf{O}_A$。\n$$ \\mathbf{t} = \\mathbf{O}_A - \\mathbf{R}\\mathbf{O}_P = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix} \\begin{pmatrix} 10 \\\\ -5 \\\\ 2 \\end{pmatrix} = - \\begin{pmatrix} 2 \\\\ 10 \\\\ -5 \\end{pmatrix} = \\begin{pmatrix} -2 \\\\ -10 \\\\ 5 \\end{pmatrix} $$\n\n现在我们计算均方根 (RMS) 误差。公式为：\n$$ E_{\\mathrm{RMS}} = \\left( \\frac{\\sum_{i=1}^{4} \\|\\mathbf{R}\\mathbf{p}_{i} + \\mathbf{t} - \\mathbf{a}_{i}\\|^{2}}{4} \\right)^{1/2} $$\n对于前三个标志点（$i=1,2,3$ 分别对应 AC、PC、MS），根据变换的构造，误差为零。\n$\\|\\mathbf{R}\\mathbf{p}_1 + \\mathbf{t} - \\mathbf{a}_1\\|^2 = \\|\\mathbf{R}\\mathbf{p}_{\\mathrm{AC}} + \\mathbf{t} - \\mathbf{a}_{\\mathrm{AC}}\\|^2 = 0$。\n$\\|\\mathbf{R}\\mathbf{p}_2 + \\mathbf{t} - \\mathbf{a}_2\\|^2 = \\|\\mathbf{R}\\mathbf{p}_{\\mathrm{PC}} + \\mathbf{t} - \\mathbf{a}_{\\mathrm{PC}}\\|^2 = 0$。\n$\\|\\mathbf{R}\\mathbf{p}_3 + \\mathbf{t} - \\mathbf{a}_3\\|^2 = \\|\\mathbf{R}\\mathbf{p}_{\\mathrm{MS}} + \\mathbf{t} - \\mathbf{a}_{\\mathrm{MS}}\\|^2 = 0$。\n求和式简化为仅包含第四个点的项，其中 $\\mathbf{p}_4 = (18.6, 9.6, 14.3)$ 且 $\\mathbf{a}_4 = (12, 8, 15)$。\n首先，变换 $\\mathbf{p}_4$：\n$$ \\mathbf{a}'_4 = \\mathbf{R}\\mathbf{p}_4 + \\mathbf{t} = \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix} \\begin{pmatrix} 18.6 \\\\ 9.6 \\\\ 14.3 \\end{pmatrix} + \\begin{pmatrix} -2 \\\\ -10 \\\\ 5 \\end{pmatrix} $$\n$$ \\mathbf{a}'_4 = \\begin{pmatrix} 14.3 \\\\ 18.6 \\\\ 9.6 \\end{pmatrix} + \\begin{pmatrix} -2 \\\\ -10 \\\\ 5 \\end{pmatrix} = \\begin{pmatrix} 12.3 \\\\ 8.6 \\\\ 14.6 \\end{pmatrix} $$\n第四个点的残差平方为 $\\|\\mathbf{a}'_4 - \\mathbf{a}_4\\|^2$。\n$$ \\mathbf{a}'_4 - \\mathbf{a}_4 = \\begin{pmatrix} 12.3 \\\\ 8.6 \\\\ 14.6 \\end{pmatrix} - \\begin{pmatrix} 12 \\\\ 8 \\\\ 15 \\end{pmatrix} = \\begin{pmatrix} 0.3 \\\\ 0.6 \\\\ -0.4 \\end{pmatrix} $$\n$$ \\|\\mathbf{a}'_4 - \\mathbf{a}_4\\|^2 = (0.3)^2 + (0.6)^2 + (-0.4)^2 = 0.09 + 0.36 + 0.16 = 0.61 $$\n现在我们计算 RMS 误差：\n$$ E_{\\mathrm{RMS}} = \\left( \\frac{0 + 0 + 0 + 0.61}{4} \\right)^{1/2} = \\left( \\frac{0.61}{4} \\right)^{1/2} = \\sqrt{0.1525} $$\n$$ E_{\\mathrm{RMS}} \\approx 0.39051248... $$\n四舍五入到四位有效数字，我们得到 $0.3905$。", "answer": "$$\\boxed{0.3905}$$", "id": "4894133"}, {"introduction": "掌握了静态图像的对齐后，我们将进一步分析整个图像序列的采集几何。在实际操作中，理想的扫描条件并非总能实现，可能会出现如机架倾斜等采集伪影。这项实践 [@problem_id:4894114] 将演示一种实用的方法，通过分析连续切片之间的位移来检测这种倾斜，并计算一个剪切校正后的方位矩阵，这是确保精确三维重建的关键一步。", "problem": "您需要实现一个完整、可运行的程序，该程序使用医学数字成像与通信 (DICOM) 元数据来检测计算机断层扫描 (CT) 中的机架倾斜，并计算一个剪切校正后的方向矩阵，以确保重建的体数据具有正交的切片。该程序必须为预定义的测试套件生成结果，无需任何外部输入。\n\n使用的基本依据和定义：\n- 医学数字成像与通信 (DICOM) 为每个切片提供元数据，包括图像方向（患者）和图像位置（患者）。\n- 设图像方向（患者）由两个单位向量给出：行方向向量 $r \\in \\mathbb{R}^3$ 和列方向向量 $c \\in \\mathbb{R}^3$。切片法向量为 $n = r \\times c$，其中 $\\times$ 表示向量叉积。\n- 设第 $k$ 个切片的图像位置（患者）为 $p_k \\in \\mathbb{R}^3$，并定义连续切片间的平移向量 $\\Delta p_k = p_{k+1} - p_k$。\n- 像素间距由两个正实数给出：$\\Delta_r$（行间距，单位 mm）和 $\\Delta_c$（列间距，单位 mm）。所有几何量均以毫米 (mm) 为单位。\n- $r$ 和 $c$ 的标准正交性意味着 $r \\cdot r = 1$, $c \\cdot c = 1$ 和 $r \\cdot c = 0$，其中 $\\cdot$ 表示点积。\n\n科学原理：\n- 在没有机架倾斜的情况下，切片间平移向量 $\\Delta p_k$ 没有沿 $r$ 或 $c$ 的平面内分量，纯粹沿着 $n$ 方向，因此 $\\Delta p_k \\approx s_k n$，其中 $s_k \\in \\mathbb{R}$ 为某个标量。当存在机架倾斜时，$\\Delta p_k$ 会获得平面内分量，即它可以分解为 $\\Delta p_k = a_k r + b_k c + s_k n$，其中 $a_k$ 和 $b_k$ 非零。\n- 倾斜角 $\\theta$ 可以通过平面内运动幅值与穿层运动幅值之比来量化。定义 $a_k = \\Delta p_k \\cdot r$，$b_k = \\Delta p_k \\cdot c$ 和 $s_k = \\Delta p_k \\cdot n$。通过计算所有切片的 $\\{a_k\\}$、$\\{b_k\\}$ 和 $\\{s_k\\}$ 的中位数，得到鲁棒的汇总值 $a$、$b$ 和 $s$。平面内幅值为 $m = \\sqrt{a^2 + b^2}$，倾斜角为 $\\theta = \\arctan2(m, |s|)$。\n- 剪切校正后的方向矩阵必须保留平面内几何形状，并将切片轴设置为法线方向，间距等于穿层分量的幅值。$3 \\times 3$ 的方向矩阵 $M$（列向量）为 $M = [R \\; C \\; Z]$，其中 $R = r \\, \\Delta_r$，$C = c \\, \\Delta_c$，$Z = n \\, |s|$。\n\n任务要求：\n1. 实现一个函数，给定 $r$、$c$、一个切片位置列表 $\\{p_k\\}$ 和像素间距 $(\\Delta_r, \\Delta_c)$：\n   - 计算 $n = r \\times c$。\n   - 为所有连续切片计算 $\\Delta p_k = p_{k+1} - p_k$。\n   - 计算 $a_k = \\Delta p_k \\cdot r$，$b_k = \\Delta p_k \\cdot c$ 和 $s_k = \\Delta p_k \\cdot n$。\n   - 使用所有切片的中位数 $a$、$b$ 和 $s$。\n   - 计算倾斜角 $\\theta = \\arctan2(\\sqrt{a^2 + b^2}, |s|)$，单位为度。\n   - 如果 $\\theta \\ge \\theta_{\\text{thr}}$，则检测到倾斜，阈值 $\\theta_{\\text{thr}} = 0.5$ 度。\n   - 计算剪切校正后的方向矩阵 $M = [r \\, \\Delta_r,\\; c \\, \\Delta_c,\\; n \\, |s|]$。\n2. 角度必须以度表示。距离必须以毫米 (mm) 为单位。输出中的倾斜角必须四舍五入到六位小数。\n\n测试套件：\n请将以下测试用例直接在您的程序中提供。对于每个用例，程序必须使用指定的 $r$、$c$、$n$、初始位置 $p_0$、沿 $n$ 方向的切片间距 $s$ 以及任何模拟倾斜的平面内分量来构造切片位置列表 $\\{p_k\\}$。使用 $N$ 个切片，索引为 $k = 0, 1, \\dots, N-1$，其位置为\n$$\np_k = p_0 + k \\, (s \\, n + t_r \\, r + t_c \\, c),\n$$\n其中 $t_r$ 和 $t_c$ 是沿 $r$ 和 $c$ 方向的每切片平面内位移（单位 mm）。如果用例没有倾斜，则 $t_r = 0$ 和 $t_c = 0$。如果用例指定了绕某个平面内轴的倾斜角 $\\theta$，则沿该轴设置相应的平面内位移为 $t = s \\, \\tan(\\theta)$。\n\n- 用例 1（理想情况，无倾斜）：\n  - $r = [1, 0, 0]$，$c = [0, 1, 0]$，$\\Delta_r = 0.8$ mm，$\\Delta_c = 0.8$ mm，$s = 1.5$ mm，$p_0 = [0, 0, 0]$，$N = 5$，$t_r = 0$，$t_c = 0$。\n- 用例 2（沿 $c$ 方向的机架倾斜）：\n  - $r = [1, 0, 0]$，$c = [0, 1, 0]$，$\\Delta_r = 0.7$ mm，$\\Delta_c = 0.7$ mm，$s = 1.2$ mm，$\\theta = 15$ 度，$p_0 = [0, 0, 0]$，$N = 5$，$t_r = 0$，$t_c = s \\, \\tan(\\theta)$。\n- 用例 3（沿 $r$ 方向的机架倾斜）：\n  - $r = [1, 0, 0]$，$c = [0, 1, 0]$，$\\Delta_r = 0.5$ mm，$\\Delta_c = 0.5$ mm，$s = 1.0$ mm，$\\theta = 10$ 度，$p_0 = [0, 0, 0]$，$N = 6$，$t_r = s \\, \\tan(\\theta)$，$t_c = 0$。\n- 用例 4（极小倾斜，低于检测阈值）：\n  - $r = [1, 0, 0]$，$c = [0, 1, 0]$，$\\Delta_r = 0.9$ mm，$\\Delta_c = 0.9$ mm，$s = 2.0$ mm，$\\theta = 0.2$ 度，$p_0 = [0, 0, 0]$，$N = 5$，$t_r = 0$，$t_c = s \\, \\tan(\\theta)$。\n- 用例 5（斜向方位，无机架倾斜）：\n  - $r = [1/\\sqrt{2}, 1/\\sqrt{2}, 0]$，$c = [0, 0, 1]$，$\\Delta_r = 1.0$ mm，$\\Delta_c = 1.0$ mm，$s = 1.0$ mm，$p_0 = [10, 20, 30]$，$N = 4$，$t_r = 0$，$t_c = 0$。\n\n输出规格：\n- 对于每个测试用例，输出一个包含三个元素的列表：$[\\text{tilt\\_detected}, \\theta, \\text{flattened\\_matrix}]$，其中 $\\text{tilt\\_detected}$ 是一个布尔值，$\\theta$ 是以度为单位、四舍五入到六位小数的倾斜角，$\\text{flattened\\_matrix}$ 是剪切校正后的 $3 \\times 3$ 方向矩阵 $M$ 按列主序展平为一个包含9个浮点数的列表，每个浮点数四舍五入到六位小数。\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来，例如：\n$[[$\\text{case1\\_result}$],[$\\text{case2\\_result}$],\\dots]$。\n\n角度单位要求：\n- 角度必须以度为单位进行计算和打印。\n\n距离单位要求：\n- 所有长度和间距均以毫米 (mm) 为单位。\n\n设计约束：\n- 仅使用线性代数定义（点积、叉积）、归一化和向量分解；除已定义的公式外，不要使用任何快捷公式。\n- 通过对 $r$ 和 $c$ 进行归一化，必要时对 $c$ 相对于 $r$ 进行重新正交化，并对 $n$ 进行归一化来确保数值鲁棒性。", "solution": "用户提供的问题已经过严格验证，被确定为一个有效且定义明确的科学编程任务。它在科学上基于医学成像和线性代数的原理，包含一个完整且一致的设定，并定义了一个清晰、可验证的目标。\n\n### 基于原理的解决方案设计\n\n该解决方案涉及开发一种算法，用于检测计算机断层扫描 (CT) 数据中的机架倾斜，并计算相应的剪切校正方向矩阵。该方法基于向量代数和坐标变换的基本原理，并应用于 DICOM（医学数字成像与通信）标准。\n\n#### 1. 坐标系定义与归一化\n\nCT 图像切片在三维患者坐标系中由 DICOM 元数据提供的一组向量定义。这些向量是行方向向量 $r \\in \\mathbb{R}^3$ 和列方向向量 $c \\in \\mathbb{R}^3$。对于有效的切片几何，这些向量必须是标准正交的，即它们是单位向量并且相互垂直 ($r \\cdot c = 0$)。\n\n第三个基向量，即切片法向量 $n \\in \\mathbb{R}^3$，使用向量叉积计算得出：\n$$n = r \\times c$$\n如果 $r$ 和 $c$ 是标准正交的，$n$ 也将是单位向量，并且集合 $\\{r, c, n\\}$ 构成一个右手标准正交基。\n\n为了保证数值鲁棒性，实现时将明确强制执行这些属性。输入的向量 $r$ 和 $c$ 将被归一化。随后，$c$ 将使用 Gram-Schmidt 过程相对于 $r$ 进行重新正交化，然后再次归一化。这确保了用于所有后续计算的基是完全标准正交的，从而防止潜在的浮点数不精确性。\n$$r_{\\text{norm}} = \\frac{r}{\\|r\\|}$$\n$$c_{\\text{ortho}} = c - (c \\cdot r_{\\text{norm}}) r_{\\text{norm}}$$\n$$c_{\\text{norm}} = \\frac{c_{\\text{ortho}}}{\\|c_{\\text{ortho}}\\|}$$\n$$n = r_{\\text{norm}} \\times c_{\\text{norm}}$$\n\n#### 2. 切片间运动分析\n\n每个切片在患者坐标系中的位置由图像位置（患者）标签给出，我们将其表示为第 $k$ 个切片的向量 $p_k \\in \\mathbb{R}^3$。连续切片之间的几何关系由切片间平移向量 $\\Delta p_k$ 描述：\n$$\\Delta p_k = p_{k+1} - p_k$$\n在没有机架倾斜的理想采集中，扫描仪的移动完全垂直于切片平面。因此，平移向量 $\\Delta p_k$ 应平行于切片法向量 $n$：\n$$\\Delta p_k \\approx s_k n$$\n其中 $s_k$ 是移动的距离，即切片厚度或间距。\n\n当存在机架倾斜时，切片之间的平移包含切片平面内的分量（平面内运动）。向量 $\\Delta p_k$可以分解为其沿基向量 $r$、$c$ 和 $n$ 的分量：\n$$\\Delta p_k = a_k r + b_k c + s_k n$$\n标量分量通过将 $\\Delta p_k$ 投影到每个基向量上（使用点积）得到：\n$$a_k = \\Delta p_k \\cdot r \\quad (\\text{沿行方向的平面内分量})$$\n$$b_k = \\Delta p_k \\cdot c \\quad (\\text{沿列方向的平面内分量})$$\n$$s_k = \\Delta p_k \\cdot n \\quad (\\text{穿层分量})$$\n$a_k$ 或 $b_k$ 的非零值表示存在机架倾斜。\n\n#### 3. 鲁棒的倾斜量化\n\n在真实世界的数据中，切片位置可能会有微小变化。为了获得整个序列的单一、鲁棒的倾斜度量，问题指定使用所有切片分量值的中位数。设 $a$、$b$ 和 $s$ 分别为集合 $\\{a_k\\}$、$\\{b_k\\}$ 和 $\\{s_k\\}$ 的中位数。\n\n平均平面内位移的幅值 $m$ 由下式给出：\n$$m = \\sqrt{a^2 + b^2}$$\n倾斜角 $\\theta$ 是实际切片间运动向量与切片法向量之间的夹角。它可以根据平面内运动幅值与穿层运动幅值之比计算得出：\n$$\\theta = \\arctan2(m, |s|)$$\n结果从弧度转换为度。如果此角度超过指定阈值 $\\theta_{\\text{thr}} = 0.5^\\circ$，则正式检测到倾斜。\n\n#### 4. 剪切校正的方向矩阵\n\n为确保重建的三维体数据具有正交切片，需要计算一个新的方向矩阵 $M$。该矩阵定义了体素的几何形状。该矩阵由三个列向量 $R$、$C$ 和 $Z$ 构成，它们分别表示沿图像网格各轴移动一个体素时在患者坐标系中的位移。\n\n遵循问题的定义，这与 DICOM 约定一致：\n- $R = r \\cdot \\Delta_r$：第一列将行向量 $r$乘以行像素间距 $\\Delta_r$。\n- $C = c \\cdot \\Delta_c$：第二列将列向量 $c$乘以列像素间距 $\\Delta_c$。\n- $Z = n \\cdot |s|$：第三列代表“切片轴”，将法向量 $n$乘以中位穿层间距的幅值 $|s|$。这有效地从采集几何中移除了剪切分量。\n\n最终的剪切校正方向矩阵 $M$ 是：\n$$M = \\begin{bmatrix} |  |  | \\\\ R  C  Z \\\\ |  |  | \\end{bmatrix} = \\begin{bmatrix} r_x \\Delta_r  c_x \\Delta_c  n_x |s| \\\\ r_y \\Delta_r  c_y \\Delta_c  n_y |s| \\\\ r_z \\Delta_r  c_z \\Delta_c  n_z |s| \\end{bmatrix}$$\n程序将把这个 $3 \\times 3$ 矩阵按列主序展平成一个包含 9 个元素的列表，作为最终输出。\n\n#### 5. 测试用例模拟\n\n测试套件是程序化生成的。对于每个用例，使用以下公式创建一系列 $N$ 个切片位置 $\\{p_k\\}_{k=0}^{N-1}$：\n$$p_k = p_0 + k \\, (s_{\\text{spacing}} \\, n + t_r \\, r + t_c \\, c)$$\n其中 $p_0$ 是初始位置，$s_{\\text{spacing}}$ 是名义上的切片间距，$t_r$ 和 $t_c$ 是用户指定的用于模拟机架倾斜的平面内位移。如果测试用例指定了倾斜角 $\\theta_{\\text{in}}$，则相应的平面内位移计算为 $t = s_{\\text{spacing}} \\cdot \\tan(\\theta_{\\text{in}})$。该模型确保了在一个测试用例中，所有切片的切片间向量 $\\Delta p_k$ 是恒定的，为验证算法的正确性提供了一个清晰的场景。\n\n实现将把这整个逻辑封装到一个 Python 程序中，使用 `numpy` 库进行高效准确的向量和矩阵运算，并完全按照指定格式输出结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analyze_ct_series(r, c, slice_positions, delta_r, delta_c, theta_thr):\n    \"\"\"\n    Analyzes a series of CT slices to detect gantry tilt and compute a\n    shear-corrected orientation matrix.\n\n    Args:\n        r (np.ndarray): The row direction vector (3,).\n        c (np.ndarray): The column direction vector (3,).\n        slice_positions (list[np.ndarray]): A list of slice position vectors.\n        delta_r (float): The row pixel spacing.\n        delta_c (float): The column pixel spacing.\n        theta_thr (float): The tilt detection threshold in degrees.\n\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if tilt is detected, False otherwise.\n            - float: The computed tilt angle in degrees.\n            - np.ndarray: The 3x3 shear-corrected orientation matrix.\n    \"\"\"\n    # 1. Ensure orthonormal basis {r, c, n} for robustness.\n    # Normalize r\n    r = r / np.linalg.norm(r)\n    # Re-orthogonalize c with respect to r (Gram-Schmidt) and normalize\n    c = c - np.dot(c, r) * r\n    c = c / np.linalg.norm(c)\n    # Compute the normal vector n\n    n = np.cross(r, c)\n    # n should be a unit vector, but normalize for safety\n    n = n / np.linalg.norm(n)\n\n    # 2. Compute inter-slice translation vectors\n    if len(slice_positions)  2:\n        # Not enough slices to compute motion, assume no tilt.\n        s_median = np.sqrt(delta_r**2 + delta_c**2) # A reasonable default\n        return False, 0.0, np.stack([r * delta_r, c * delta_c, n * s_median], axis=-1)\n\n    delta_p_list = [slice_positions[k + 1] - slice_positions[k] for k in range(len(slice_positions) - 1)]\n\n    # 3. Decompose inter-slice vectors into in-plane and through-plane components\n    a_k = [np.dot(dp, r) for dp in delta_p_list]\n    b_k = [np.dot(dp, c) for dp in delta_p_list]\n    s_k = [np.dot(dp, n) for dp in delta_p_list]\n\n    # 4. Use medians for robust estimation\n    a_median = np.median(a_k)\n    b_median = np.median(b_k)\n    s_median = np.median(s_k)\n\n    # 5. Compute tilt angle\n    in_plane_magnitude = np.sqrt(a_median**2 + b_median**2)\n    # arctan2(y, x) where y is in-plane and x is through-plane component\n    tilt_angle_rad = np.arctan2(in_plane_magnitude, np.abs(s_median))\n    tilt_angle_deg = np.rad2deg(tilt_angle_rad)\n\n    # 6. Detect tilt\n    is_tilted = tilt_angle_deg >= theta_thr\n\n    # 7. Compute the shear-corrected orientation matrix M = [R, C, Z]\n    # R = r * delta_r, C = c * delta_c, Z = n * |s_median|\n    R_col = r * delta_r\n    C_col = c * delta_c\n    Z_col = n * np.abs(s_median)\n    M = np.stack([R_col, C_col, Z_col], axis=-1)\n\n    return is_tilted, tilt_angle_deg, M\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Tilt detection threshold\n    theta_thr = 0.5  # degrees\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, no tilt)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.8, 'delta_c': 0.8, 's': 1.5, 'p0': [0, 0, 0], 'N': 5, 'tilt_deg': 0.0, 'tilt_axis': None},\n        # Case 2 (gantry tilt along c)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.7, 'delta_c': 0.7, 's': 1.2, 'p0': [0, 0, 0], 'N': 5, 'tilt_deg': 15.0, 'tilt_axis': 'c'},\n        # Case 3 (gantry tilt along r)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.5, 'delta_c': 0.5, 's': 1.0, 'p0': [0, 0, 0], 'N': 6, 'tilt_deg': 10.0, 'tilt_axis': 'r'},\n        # Case 4 (very small tilt below detection threshold)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.9, 'delta_c': 0.9, 's': 2.0, 'p0': [0, 0, 0], 'N': 5, 'tilt_deg': 0.2, 'tilt_axis': 'c'},\n        # Case 5 (oblique orientation, no gantry tilt)\n        {'r': [1/np.sqrt(2), 1/np.sqrt(2), 0], 'c': [0, 0, 1], 'delta_r': 1.0, 'delta_c': 1.0, 's': 1.0, 'p0': [10, 20, 30], 'N': 4, 'tilt_deg': 0.0, 'tilt_axis': None},\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        # Prepare inputs for this test case\n        r_vec = np.array(case['r'], dtype=float)\n        c_vec = np.array(case['c'], dtype=float)\n        p0 = np.array(case['p0'], dtype=float)\n        s_spacing = case['s']\n        N = case['N']\n        delta_r = case['delta_r']\n        delta_c = case['delta_c']\n\n        # Normalize basis vectors for generating slice positions\n        r_norm = r_vec / np.linalg.norm(r_vec)\n        c_ortho = c_vec - np.dot(c_vec, r_norm) * r_norm\n        c_norm = c_ortho / np.linalg.norm(c_ortho)\n        n_norm = np.cross(r_norm, c_norm)\n\n        # Calculate in-plane shifts based on tilt angle\n        t_r, t_c = 0.0, 0.0\n        if case['tilt_axis']:\n            tilt_rad = np.deg2rad(case['tilt_deg'])\n            shift = s_spacing * np.tan(tilt_rad)\n            if case['tilt_axis'] == 'r':\n                t_r = shift\n            elif case['tilt_axis'] == 'c':\n                t_c = shift\n        \n        # Generate the list of slice positions\n        # p_k = p_0 + k * (s * n + t_r * r + t_c * c)\n        inter_slice_vec = s_spacing * n_norm + t_r * r_norm + t_c * c_norm\n        slice_positions = [p0 + k * inter_slice_vec for k in range(N)]\n\n        # Analyze the generated slice data\n        is_tilted, angle_deg, matrix = analyze_ct_series(\n            r_vec, c_vec, slice_positions, delta_r, delta_c, theta_thr\n        )\n        \n        # Format the results for this case\n        is_tilted_str = str(is_tilted).lower()\n        angle_str = f\"{angle_deg:.6f}\"\n        matrix_flat_col_major = matrix.flatten('F')\n        matrix_str = \"[\" + \",\".join(f\"{val:.6f}\" for val in matrix_flat_col_major) + \"]\"\n        case_result_str = f\"[{is_tilted_str},{angle_str},{matrix_str}]\"\n        \n        all_results_str.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "4894114"}, {"introduction": "最后，我们进入一个更高级别的质量控制，它融合了解剖学知识。即使经过几何处理，诸如左右翻转之类的严重错误仍可能存在。这项练习 [@problem_id:4894102] 展示了一种强大的技术，它利用已知的大脑结构不对称性，通过统计检验来验证最终的图像方向，从而确保解剖标签与底层数据正确对应。", "problem": "给定来自一个已知非对称组织的脑结构——planum temporale——在单个三维图像体积中的图像空间样本坐标和标量特征测量值。目标是实现一个统计检验，用于检测由图像方向仿射引起的左右翻转。该检验必须从右-前-上 (RAS) 空间中的坐标变换和半球分配的基本原理出发，然后使用分布比较来判断观测到的不对称性是与已知的解剖学不对称性一致还是发生了翻转。\n\n使用以下基本依据和定义：\n\n- 设图像方向仿射为一个矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$，它通过 $$\\tilde{\\mathbf{r}} = A \\tilde{\\mathbf{x}}$$ 将齐次图像坐标 $\\tilde{\\mathbf{x}} = (x, y, z, 1)^\\top$ 映射到右-前-上空间中的齐次世界坐标 $\\tilde{\\mathbf{r}} = (r_x, r_y, r_z, 1)^\\top$。世界坐标 $\\mathbf{r} = (r_x, r_y, r_z)$ 是通过丢弃齐次分量得到的。\n- 在 RAS 空间中，半球分配使用世界坐标的右轴：$r_x  0$ 的样本属于观测到的左半球，$r_x  0$ 的样本属于观测到的右半球。$r_x = 0$ 的样本将被丢弃。\n- planum temporale 具有有充分记载的左偏不对称性：在正确方向下，标量特征的左半球分布在随机意义上大于右半球分布。您必须构建一个检验，通过在应用 $A$ 并根据 $r_x$ 的符号重新分配半球后，比较观测到的左、右分布来检测翻转。\n\n检验的设计要求：\n\n- 通过使用 $A$ 变换每个样本坐标并根据 $r_x$ 的符号进行划分，计算观测左组 $\\mathcal{L}$ 和观测右组 $\\mathcal{R}$。\n- 计算一个双样本统计量来量化不对称性的方向，例如样本均值之差 $$T = \\bar{f}_{\\mathcal{R}} - \\bar{f}_{\\mathcal{L}},$$ 其中 $\\bar{f}_{\\mathcal{L}}$ 和 $\\bar{f}_{\\mathcal{R}}$ 分别是观测左组和右组中特征值的样本均值。\n- 执行一个双样本假设检验来比较观测到的左、右分布（例如，Welch's $t$-检验）。使用显著性阈值 $\\alpha = 0.01$（一个无量纲小数）。当且仅当 $T  0$ 且双边 $p$ 值严格小于 $\\alpha$ 时，判定检测到左右翻转。\n- 所有计算都是无单位的。不涉及角度，也不需要物理单位转换。\n\n测试套件：\n\n实现您的程序来评估以下测试用例。每个用例提供一个包含 $N$ 个图像空间样本坐标的列表、相应的标量特征值以及一个方向仿射 $A$。坐标是图像体素坐标（无单位）。在每个用例中，应用 $A$ 后根据 $r_x$ 的符号进行划分，计算 $T$ 和相应的双样本检验 $p$ 值，然后输出一个布尔值，指示是否检测到翻转。\n\n- 用例 $1$（顺利路径，正确方向）：具有左偏不对称性的单位仿射 $A$。\n  - 仿射 $A_1$：\n    $$A_1 = \\begin{bmatrix}\n    1  0  0  0 \\\\\n    0  1  0  0 \\\\\n    0  0  1  0 \\\\\n    0  0  0  1\n    \\end{bmatrix}.$$\n  - 坐标（16 个样本的有序列表）：\n    $\\{(-40.0, 5.0, 0.0), (-42.0, -3.0, 1.0), (-38.0, 2.0, -1.0), (-45.0, -6.0, 0.5), (-39.0, 4.0, -0.5), (-41.0, -2.0, 1.5), (-37.0, 3.0, -1.5), (-43.0, -4.0, 2.0), (40.0, -5.0, 0.0), (42.0, 3.0, -1.0), (38.0, -2.0, 1.0), (45.0, 6.0, -0.5), (39.0, -4.0, 0.5), (41.0, 2.0, -1.5), (37.0, -3.0, 1.5), (43.0, 4.0, -2.0)\\}.$\n  - 特征（与坐标顺序相同）：\n    $\\{1.40, 1.35, 1.37, 1.42, 1.33, 1.38, 1.41, 1.36, 0.85, 0.90, 0.88, 0.83, 0.92, 0.87, 0.89, 0.84\\}.$\n\n- 用例 $2$（存在翻转）：沿世界坐标的右轴进行左右翻转，坐标和特征与用例 1 相同。\n  - 仿射 $A_2$：\n    $$A_2 = \\begin{bmatrix}\n    -1  0  0  0 \\\\\n    0  1  0  0 \\\\\n    0  0  1  0 \\\\\n    0  0  0  1\n    \\end{bmatrix}.$$\n  - 坐标：与用例 1 相同。\n  - 特征：与用例 1 相同。\n\n- 用例 $3$（边缘情况，对称分布）：左右翻转仿射，具有对称的特征值，坐标与用例 1 相同。\n  - 仿射 $A_3$：\n    $$A_3 = \\begin{bmatrix}\n    -1  0  0  0 \\\\\n    0  1  0  0 \\\\\n    0  0  1  0 \\\\\n    0  0  0  1\n    \\end{bmatrix}.$$\n  - 坐标：与用例 1 相同。\n  - 特征（与坐标顺序相同）：\n    $\\{1.00, 1.02, 0.98, 1.01, 1.03, 0.97, 1.00, 1.02, 1.01, 0.99, 1.00, 0.98, 1.02, 1.03, 0.97, 1.01\\}.$\n\n程序输出规范：\n\n- 对于每个测试用例，根据上述规则计算布尔决策。将这三个布尔值按用例 1、用例 2、用例 3 的顺序聚合到一个列表中。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$\\texttt{[result1,result2,result3]}$）。列表元素必须是 Python 布尔值。", "solution": "该问题已经过验证，被认为是合理、适定且有科学依据的。\n\n目标是实现一个统计检验，用于检测三维医学图像体积中的左右方向翻转。该检验利用了 planum temporale 的已知解剖学不对称性，这是一个大脑结构，其标量特征在左半球随机性地大于右半球。所提供的数据包括图像空间样本坐标、相应的特征值以及一个图像方向仿射矩阵 $A$。该检验必须将坐标变换到右-前-上 (RAS) 世界空间，将数据划分为观测到的左、右半球组，然后执行假设检验，以确定观测到的不对称性是与已知解剖结构一致还是发生了翻转。\n\n系统化的步骤如下：\n\n1.  **坐标变换**：每个图像空间坐标 $\\mathbf{x} = (x, y, z)^\\top$ 首先表示为齐次形式 $\\tilde{\\mathbf{x}} = (x, y, z, 1)^\\top$。然后，通过给定的 $4 \\times 4$ 仿射矩阵 $A$ 进行矩阵乘法，将此齐次坐标变换到 RAS 世界空间：\n    $$\n    \\tilde{\\mathbf{r}} = A \\tilde{\\mathbf{x}}\n    $$\n    生成的齐次世界坐标为 $\\tilde{\\mathbf{r}} = (r_x, r_y, r_z, 1)^\\top$。三维世界坐标 $\\mathbf{r}$ 是通过丢弃第四个分量得到的。\n\n2.  **半球划分**：根据世界坐标第一个分量 $r_x$ 的符号，将样本划分为观测左半球组 $\\mathcal{L}$ 和观测右半球组 $\\mathcal{R}$。该分量对应于 RAS 空间中的右-左轴。\n    -   如果 $r_x  0$，样本属于观测左半球组 $\\mathcal{L}$。\n    -   如果 $r_x > 0$，样本属于观测右半球组 $\\mathcal{R}$。\n    -   $r_x = 0$ 的样本将被丢弃，尽管在提供的测试用例中没有这样的样本。\n    特征值根据其对应坐标的半球分配进行划分。设 $F_{\\mathcal{L}}$ 和 $F_{\\mathcal{R}}$ 分别为 $\\mathcal{L}$ 组和 $\\mathcal{R}$ 组中样本的特征值集合。\n\n3.  **不对称性统计量的计算**：计算一个检验统计量 $T$ 来量化观测到的不对称性的方向和大小。它被定义为观测右组和左组中特征值的样本均值之差：\n    $$\n    T = \\bar{f}_{\\mathcal{R}} - \\bar{f}_{\\mathcal{L}}\n    $$\n    其中 $\\bar{f}_{\\mathcal{R}} = \\frac{1}{|\\mathcal{R}|} \\sum_{f \\in F_{\\mathcal{R}}} f$ 和 $\\bar{f}_{\\mathcal{L}} = \\frac{1}{|\\mathcal{L}|} \\sum_{f \\in F_{\\mathcal{L}}} f$ 分别是各自的样本均值。已知的解剖学基准真相是，该特征在左半球随机性地更大。因此，在正确方向下，我们期望 $\\bar{f}_{\\mathcal{L}} > \\bar{f}_{\\mathcal{R}}$，这意味着 $T  0$。左右翻转会交换标签，导致观测到 $\\bar{f}_{\\mathcal{R}} > \\bar{f}_{\\mathcal{L}}$，因此 $T > 0$。\n\n4.  **假设检验**：为了评估观测到的不对称性的统计显著性，执行了双样本 Welch's $t$ 检验。该检验适用于比较可能具有不等方差的两个独立样本的均值。原假设 $H_0$ 是，观测到的左、右样本所来自的潜在分布的真实均值相等（$\\mu_{\\mathcal{L}} = \\mu_{\\mathcal{R}}$）。备择假设 $H_1$ 是它们不相等（$\\mu_{\\mathcal{L}} \\neq \\mu_{\\mathcal{R}}$）。该检验产生一个 $p$ 值，表示在原假设为真的前提下，观测到等于或比计算出的样本均值差异更极端的差异的概率。\n\n5.  **决策规则**：当且仅当同时满足以下两个条件时，检测到左右翻转：\n    a. 观测到的不对称性方向相反：$T > 0$。\n    b. 观测到的差异在统计上是显著的：来自 Welch's $t$ 检验的双边 $p$ 值严格小于显著性水平 $\\alpha = 0.01$。\n\n此过程应用于每个测试用例。\n\n**用例 1：单位仿射（正确方向）**\n-   $A_1$ 是单位矩阵。世界坐标与图像坐标相同：$\\mathbf{r} = \\mathbf{x}$。\n-   前 8 个样本的 $x  0$，构成 $\\mathcal{L}$ 组。其余 8 个样本的 $x > 0$，构成 $\\mathcal{R}$ 组。\n-   $\\mathcal{L}$ 组的特征为 $\\{1.40, 1.35, 1.37, 1.42, 1.33, 1.38, 1.41, 1.36\\}$。均值为 $\\bar{f}_{\\mathcal{L}} \\approx 1.3775$。\n-   $\\mathcal{R}$ 组的特征为 $\\{0.85, 0.90, 0.88, 0.83, 0.92, 0.87, 0.89, 0.84\\}$。均值为 $\\bar{f}_{\\mathcal{R}} = 0.885$。\n-   检验统计量为 $T = 0.885 - 1.3775 = -0.4925$。\n-   由于 $T  0$，不满足检测翻转的第一个条件。该方向与已知的左偏不对称性一致。\n-   决策：未检测到翻转 (False)。\n\n**用例 2：左右翻转仿射（翻转方向）**\n-   $A_2$ 对第一个坐标取反：$r_x = -x$。\n-   在用例 1 中属于 $\\mathcal{L}$ 组的样本（$x  0$）现在变为 $r_x > 0$，因此被分入观测右组 $\\mathcal{R}$。\n-   在用例 1 中属于 $\\mathcal{R}$ 组的样本（$x > 0$）现在变为 $r_x  0$，因此被分入观测左组 $\\mathcal{L}$。\n-   观测左组的特征现在是 $\\{0.85, \\dots, 0.84\\}$，均值为 $\\bar{f}_{\\mathcal{L}} = 0.885$。\n-   观测右组的特征现在是 $\\{1.40, \\dots, 1.36\\}$，均值为 $\\bar{f}_{\\mathcal{R}} \\approx 1.3775$。\n-   检验统计量为 $T = 1.3775 - 0.885 = 0.4925$。\n-   由于 $T > 0$，满足第一个条件。\n-   对这两组特征进行 Welch's $t$ 检验，得出的 $p$ 值约为 $1.57 \\times 10^{-12}$。\n-   这个 $p$ 值远小于 $\\alpha = 0.01$。第二个条件也得到满足。\n-   决策：检测到翻转 (True)。\n\n**用例 3：左右翻转及对称数据**\n-   $A_3$ 与用例 2 中的翻转矩阵相同。半球分配与用例 2 中一样被翻转。\n-   现在两个解剖组之间的特征值几乎是对称的。\n-   原始左侧特征：$\\{1.00, 1.02, 0.98, 1.01, 1.03, 0.97, 1.00, 1.02\\}$。均值 $\\approx 1.00375$。\n-   原始右侧特征：$\\{1.01, 0.99, 1.00, 0.98, 1.02, 1.03, 0.97, 1.01\\}$。均值 $\\approx 1.00125$。\n-   翻转后，观测左组特征的均值为 $\\bar{f}_{\\mathcal{L}} \\approx 1.00125$，观测右组特征的均值为 $\\bar{f}_{\\mathcal{R}} \\approx 1.00375$。\n-   检验统计量为 $T = 1.00375 - 1.00125 = 0.0025$。\n-   由于 $T > 0.0$，满足第一个条件。\n-   执行 Welch's $t$ 检验。由于两个分布高度相似，得到的 $p$ 值约为 $0.826$。\n-   这个 $p$ 值远大于 $\\alpha = 0.01$。第二个条件不满足。观测到的差异在统计上不显著。\n-   决策：未检测到翻转 (False)。此用例正确地证明了该检验需要不对称性发生统计上显著的翻转，而不仅仅是方向上的翻转（$T>0$）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import ttest_ind\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting left-right image reversal by analyzing\n    the asymmetry of the planum temporale.\n    \"\"\"\n\n    SIGNIFICANCE_ALPHA = 0.01\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"A\": np.array([\n                [1, 0, 0, 0],\n                [0, 1, 0, 0],\n                [0, 0, 1, 0],\n                [0, 0, 0, 1]\n            ]),\n            \"coords\": np.array([\n                [-40.0, 5.0, 0.0], [-42.0, -3.0, 1.0], [-38.0, 2.0, -1.0], [-45.0, -6.0, 0.5],\n                [-39.0, 4.0, -0.5], [-41.0, -2.0, 1.5], [-37.0, 3.0, -1.5], [-43.0, -4.0, 2.0],\n                [40.0, -5.0, 0.0], [42.0, 3.0, -1.0], [38.0, -2.0, 1.0], [45.0, 6.0, -0.5],\n                [39.0, -4.0, 0.5], [41.0, 2.0, -1.5], [37.0, -3.0, 1.5], [43.0, 4.0, -2.0]\n            ]),\n            \"features\": np.array([\n                1.40, 1.35, 1.37, 1.42, 1.33, 1.38, 1.41, 1.36,\n                0.85, 0.90, 0.88, 0.83, 0.92, 0.87, 0.89, 0.84\n            ])\n        },\n        {\n            \"name\": \"Case 2\",\n            \"A\": np.array([\n                [-1, 0, 0, 0],\n                [0, 1, 0, 0],\n                [0, 0, 1, 0],\n                [0, 0, 0, 1]\n            ]),\n            \"coords\": np.array([\n                [-40.0, 5.0, 0.0], [-42.0, -3.0, 1.0], [-38.0, 2.0, -1.0], [-45.0, -6.0, 0.5],\n                [-39.0, 4.0, -0.5], [-41.0, -2.0, 1.5], [-37.0, 3.0, -1.5], [-43.0, -4.0, 2.0],\n                [40.0, -5.0, 0.0], [42.0, 3.0, -1.0], [38.0, -2.0, 1.0], [45.0, 6.0, -0.5],\n                [39.0, -4.0, 0.5], [41.0, 2.0, -1.5], [37.0, -3.0, 1.5], [43.0, 4.0, -2.0]\n            ]),\n            \"features\": np.array([\n                1.40, 1.35, 1.37, 1.42, 1.33, 1.38, 1.41, 1.36,\n                0.85, 0.90, 0.88, 0.83, 0.92, 0.87, 0.89, 0.84\n            ])\n        },\n        {\n            \"name\": \"Case 3\",\n            \"A\": np.array([\n                [-1, 0, 0, 0],\n                [0, 1, 0, 0],\n                [0, 0, 1, 0],\n                [0, 0, 0, 1]\n            ]),\n            \"coords\": np.array([\n                [-40.0, 5.0, 0.0], [-42.0, -3.0, 1.0], [-38.0, 2.0, -1.0], [-45.0, -6.0, 0.5],\n                [-39.0, 4.0, -0.5], [-41.0, -2.0, 1.5], [-37.0, 3.0, -1.5], [-43.0, -4.0, 2.0],\n                [40.0, -5.0, 0.0], [42.0, 3.0, -1.0], [38.0, -2.0, 1.0], [45.0, 6.0, -0.5],\n                [39.0, -4.0, 0.5], [41.0, 2.0, -1.5], [37.0, -3.0, 1.5], [43.0, 4.0, -2.0]\n            ]),\n            \"features\": np.array([\n                1.00, 1.02, 0.98, 1.01, 1.03, 0.97, 1.00, 1.02,\n                1.01, 0.99, 1.00, 0.98, 1.02, 1.03, 0.97, 1.01\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        coords = case[\"coords\"]\n        features = case[\"features\"]\n\n        # Step 1: Coordinate Transformation\n        # Convert to homogeneous coordinates by adding a fourth component of 1\n        num_samples = coords.shape[0]\n        homogeneous_coords = np.hstack([coords, np.ones((num_samples, 1))])\n\n        # Apply the affine transformation A to get homogeneous world coordinates\n        # (A @ homogeneous_coords.T).T gives a matrix of shape (num_samples, 4)\n        world_coords_homogeneous = (A @ homogeneous_coords.T).T\n\n        # Extract the r_x component (the first column)\n        r_x = world_coords_homogeneous[:, 0]\n\n        # Step 2: Hemisphere Partitioning\n        # Create boolean masks for left and right hemispheres based on the sign of r_x\n        # Sample with r_x = 0 are discarded as per the problem statement\n        left_mask = r_x  0\n        right_mask = r_x > 0\n\n        # Partition the feature values using the masks\n        features_L = features[left_mask]\n        features_R = features[right_mask]\n\n        # If either partition is empty, the test is not meaningful.\n        if features_L.size == 0 or features_R.size == 0:\n            results.append(False) # Cannot detect reversal if one side is missing\n            continue\n\n        # Step 3: Calculation of the Asymmetry Statistic\n        mean_L = np.mean(features_L)\n        mean_R = np.mean(features_R)\n        T_statistic_diff_means = mean_R - mean_L\n\n        # Step 4: Hypothesis Testing\n        # Perform a two-sample Welch's t-test\n        # scipy.stats.ttest_ind with equal_var=False performs Welch's t-test\n        # We compare observed right vs observed left\n        _, p_value = ttest_ind(features_R, features_L, equal_var=False, nan_policy='raise')\n\n        # Step 5: Decision Rule\n        # Reversal is detected if T > 0 AND p-value  alpha\n        is_reversed = (T_statistic_diff_means > 0) and (p_value  SIGNIFICANCE_ALPHA)\n        \n        results.append(is_reversed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4894102"}]}