{"hands_on_practices": [{"introduction": "在比较不同图像或扫描数据时，将它们的强度值标准化到统一尺度上是至关重要的一步。本练习将介绍Z-score标准化，这是一种调整图像区域强度分布，使其均值为零、方差为一的基础技术。通过推导此变换，您将加深对线性变换如何控制直方图基本统计特性（如中心位置和分布尺度）的理解([@problem_id:4891654])。", "problem": "在一幅放射影像中，选择一个感兴趣区域 (Region of Interest, ROI) 来研究其强度分布，具体方法是通过一个近似像素强度潜在概率密度的经验直方图。设ROI内的像素强度被建模为一个实值随机变量 $X$，其均值 $ \\mu $ 有限，标准差 $ \\sigma $ 为正，即 $ \\sigma  0 $。考虑通过对 $X$ 进行仿射变换来构建一个标准化的强度 $Z$，使得标准化后的直方图被中心化和缩放，以便于跨主体或跨扫描的比较，同时不扭曲分布的内在形状特征。\n\n从期望 $E[\\cdot]$ 和方差 $\\mathrm{Var}(\\cdot)$ 的定义出发，并仅使用随机变量的仿射变换性质及其如何作用于概率密度和直方图，推导仿射映射 $Z = a X + b$ 产生零均值和单位方差的标准化强度的条件。然后，论证这种重新缩放如何影响直方图的中心、分布范围以及如偏度和峰度之类的形状描述符，并论证ROI中像素强度的相对顺序是否被保留。假设直方图是分布的忠实经验表示，并且重新缩放被统一应用于所有ROI像素。最后，选择正确陈述了推导过程及其对直方图影响的选项。\n\n哪个选项是正确的？\n\nA. 在 $Z = a X + b$ 中选择 $a$ 和 $b$ 使得 $E[Z] = 0$ 和 $\\mathrm{Var}(Z) = 1$，得到 $a = 1/\\sigma$ 和 $b = -\\mu/\\sigma$。该变换是严格递增的，因此保留了ROI强度的相对顺序。标准化后的直方图被平移至中心为 $0$ 的位置，并按因子 $1/\\sigma$ 进行水平缩放。诸如偏度和峰度之类的形状描述符在这种仿射标准化下保持不变。\n\nB. 在 $Z = a X + b$ 中选择 $a$ 和 $b$ 使得 $E[Z] = 0$ 和 $\\mathrm{Var}(Z) = 1$，得到 $a = \\sigma$ 和 $b = -\\mu$。该变换将强度分布范围压缩了因子 $\\sigma$，并且当 $X$ 是高斯分布时，使标准化直方图在某个区间上变为均匀分布。\n\nC. 映射 $Z = (X - \\mu)/\\sigma$ 确保直方图的组边界和计数与 $X$ 的相同，只是重新标记了x轴。ROI的均值和方差在这种归一化下保持不变。\n\nD. 映射 $Z = (X - \\mu)/\\sigma$ 将直方图的中心置于 $0$，并将其方差设为 $1$，但它会改变形状，即改变偏度和峰度，除非 $X$ 是高斯分布。\n\nE. 当应用于计算机断层扫描（CT）图像中的感兴趣区域（ROI）时，z-score归一化取决于像素的空间排列，并且可能破坏强度顺序，因为该变换对于 $X$ 是非线性的。", "solution": "用户希望我扮演一名STEM教授，解决一个关于直方图标准化的问题。我将验证问题，然后推导解决方案并评估各个选项。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 在一幅放射影像中选择了一个感兴趣区域（ROI）。\n- ROI中的像素强度被建模为一个实值随机变量 $X$。\n- $X$ 的均值 $\\mu$ 有限。\n- $X$ 的标准差 $\\sigma  0$ 为正。\n- 通过一个仿射变换构建一个标准化强度 $Z$：$Z = aX + b$。\n- 目的是创建一个标准化的直方图用于比较，而不扭曲其内在形状特征。\n- 对 $Z$ 的期望属性是零均值（$E[Z] = 0$）和单位方差（$\\mathrm{Var}(Z) = 1$）。\n- 推导必须从期望 $E[\\cdot]$ 和方差 $\\mathrm{Var}(\\cdot)$ 的定义出发，并使用仿射变换的性质。\n- 假设直方图是分布的忠实经验表示。\n- 重新缩放被统一应用于所有ROI像素。\n- 任务是推导对 $a$ 和 $b$ 的条件，并分析其对直方图中心、分布范围、形状（偏度、峰度）和强度排序的影响。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学上合理：** 该问题牢固地植根于基础统计学及其在医学图像分析中的应用。标准化一个随机变量（创建z-score）的概念是一种标准、有效且广泛使用的技术。所有术语（$\\mu, \\sigma, E[\\cdot], \\mathrm{Var}(\\cdot)$、仿射变换、偏度、峰度）在统计学中都有明确的定义。\n- **问题定义良好：** 问题提出了一个明确的目标：找到仿射映射 $Z=aX+b$ 的参数 $a$ 和 $b$，以产生一个具有指定均值和方差的变量 $Z$。这是一个可解问题，对 $a$（符号除外）和 $b$ 有唯一解。所需的假设（有限的 $\\mu$，正的 $\\sigma$）已明确说明。\n- **客观性：** 问题以精确、客观的数学和科学语言陈述。没有歧义或主观论断。\n\n**缺陷清单检查：**\n1.  **科学或事实不健全：** 无。前提是合理的。\n2.  **非形式化或不相关：** 无。问题是直接可形式化的，并且是图像强度归一化这一主题的核心。\n3.  **不完整或矛盾的设置：** 无。所有必要信息都已提供。条件 $\\sigma  0$ 避免了除以零。\n4.  **不切实际或不可行：** 无。这是图像处理中一个常见、实际的操作。\n5.  **不适定或结构不良：** 无。存在唯一且稳定的解。\n6.  **伪深刻、琐碎或同义反复：** 无。虽然是标准推导，但它正确地测试了对基本统计性质及其含义的理解。\n7.  **超出科学可验证性：** 无。该推导在数学上是可验证的。\n\n**步骤3：结论和行动**\n问题陈述是 **有效的**。我现在将进行推导和选项评估。\n\n### 推导与求解\n\n问题要求找到仿射变换 $Z = aX + b$ 的参数 $a$ 和 $b$，使得得到的随机变量 $Z$ 的均值为 $0$，方差为 $1$。我们已知 $X$ 的均值为 $E[X] = \\mu$，方差为 $\\mathrm{Var}(X) = \\sigma^2$，且 $\\sigma  0$。\n\n**1. 关于均值的条件：**\n我们要求 $E[Z] = 0$。使用期望算子的线性性质：\n$$E[Z] = E[aX + b] = aE[X] + b$$\n代入 $E[X] = \\mu$：\n$$E[Z] = a\\mu + b$$\n将其设为 $0$ 得到我们的第一个方程：\n$$a\\mu + b = 0 \\implies b = -a\\mu$$\n\n**2. 关于方差的条件：**\n我们要求 $\\mathrm{Var}(Z) = 1$。使用方差在仿射变换下的性质：\n$$\\mathrm{Var}(Z) = \\mathrm{Var}(aX + b) = a^2 \\mathrm{Var}(X)$$\n代入 $\\mathrm{Var}(X) = \\sigma^2$：\n$$\\mathrm{Var}(Z) = a^2 \\sigma^2$$\n将其设为 $1$ 得到我们的第二个方程：\n$$a^2 \\sigma^2 = 1$$\n解出 $a$，因为给定 $\\sigma  0$：\n$$a^2 = \\frac{1}{\\sigma^2} \\implies a = \\pm \\frac{1}{\\sigma}$$\n按照惯例，为了标准化，我们选择正根 $a = 1/\\sigma$ 来保持分布的方向（即，大于均值的值在标准化后仍然为正）。\n\n**3. 确定参数：**\n当 $a = 1/\\sigma$ 时，我们可以从第一个方程中求出 $b$：\n$$b = -a\\mu = -\\left(\\frac{1}{\\sigma}\\right)\\mu = -\\frac{\\mu}{\\sigma}$$\n因此，所需的仿射变换是：\n$$Z = \\left(\\frac{1}{\\sigma}\\right)X - \\frac{\\mu}{\\sigma} = \\frac{X - \\mu}{\\sigma}$$\n这个变换被称为标准分数或z-score。\n\n**4. 影响分析：**\n- **中心和分布范围：** 根据构造，$Z$ 的均值为 $0$，方差为 $1$。标准差为 $\\sqrt{1} = 1$。就直方图而言，这意味着分布被平移，使其质心位于 $0$。水平轴按因子 $a = 1/\\sigma$ 进行缩放。如果 $\\sigma  1$，这是一个压缩；如果 $0  \\sigma  1$，这是一个拉伸。\n\n- **强度的相对顺序：** 该变换是一个仿射映射 $f(x) = (1/\\sigma)x - \\mu/\\sigma$。其导数为 $f'(x) = 1/\\sigma$。由于给定 $\\sigma  0$，所以对所有 $x$ 都有 $f'(x)  0$。这意味着该变换是严格递增的。因此，如果两个像素强度为 $x_1$ 和 $x_2$ 且 $x_1  x_2$，它们变换后的值 $z_1$ 和 $z_2$ 将满足 $z_1  z_2$。所有像素强度的相对顺序得以保留。\n\n- **形状描述符（偏度和峰度）：** 这些描述符是基于标准化的中心矩定义的。\n    - 一个均值为 $\\mu_Y$ 的随机变量 $Y$ 的 $n$ 阶中心矩是 $\\mu_n(Y) = E[(Y - \\mu_Y)^n]$。\n    - $Z$ 的 $n$ 阶中心矩是 $\\mu_n(Z) = E[(Z - E[Z])^n] = E[(Z-0)^n] = E[Z^n]$。\n    - 让我们用 $X$ 来表示它：\n    $$\\mu_n(Z) = E\\left[\\left(\\frac{X-\\mu}{\\sigma}\\right)^n\\right] = \\frac{1}{\\sigma^n} E[(X-\\mu)^n] = \\frac{\\mu_n(X)}{\\sigma^n}$$\n    - **偏度**是第三标准化矩：$\\gamma_1(Y) = \\mu_3(Y) / (\\mathrm{std}(Y))^3$。\n    对于 $Z$，其标准差为 $1$，所以其偏度为：\n    $$\\gamma_1(Z) = \\frac{\\mu_3(Z)}{1^3} = \\mu_3(Z) = \\frac{\\mu_3(X)}{\\sigma^3}$$\n    这正是 $X$ 的偏度 $\\gamma_1(X)$ 的定义。因此，$\\gamma_1(Z) = \\gamma_1(X)$。偏度是不变的。\n    - **峰度**是第四标准化矩：$\\beta_2(Y) = \\mu_4(Y) / (\\mathrm{std}(Y))^4$。\n    对于 $Z$，其标准差为 $1$，所以其峰度为：\n    $$\\beta_2(Z) = \\frac{\\mu_4(Z)}{1^4} = \\mu_4(Z) = \\frac{\\mu_4(X)}{\\sigma^4}$$\n    这正是 $X$ 的峰度 $\\beta_2(X)$ 的定义。因此，$\\beta_2(Z) = \\beta_2(X)$。峰度是不变的。\n    由于偏度和峰度都不变，分布的内在形状得以保留。\n\n### 逐项分析\n\n**A. 在 $Z = a X + b$ 中选择 $a$ 和 $b$ 使得 $E[Z] = 0$ 和 $\\mathrm{Var}(Z) = 1$，得到 $a = 1/\\sigma$ 和 $b = -\\mu/\\sigma$。该变换是严格递增的，因此保留了ROI强度的相对顺序。标准化后的直方图被平移至中心为 $0$ 的位置，并按因子 $1/\\sigma$ 进行水平缩放。诸如偏度和峰度之类的形状描述符在这种仿射标准化下保持不变。**\n- $a = 1/\\sigma$ 和 $b = -\\mu/\\sigma$ 的推导是正确的。\n- 关于变换是严格递增的（因为 $a = 1/\\sigma  0$）并保留顺序的陈述是正确的。\n- 关于直方图中心在 $0$ 并按 $1/\\sigma$ 缩放的描述是正确的。\n- 关于偏度和峰度不变的陈述是正确的。\n- **结论：正确**。此陈述的每个部分都是准确的，并且遵循了推导。\n\n**B. 在 $Z = a X + b$ 中选择 $a$ 和 $b$ 使得 $E[Z] = 0$ 和 $\\mathrm{Var}(Z) = 1$，得到 $a = \\sigma$ 和 $b = -\\mu$。该变换将强度分布范围压缩了因子 $\\sigma$，并且当 $X$ 是高斯分布时，使标准化直方图在某个区间上变为均匀分布。**\n- $a$ 和 $b$ 的值不正确。如推导所示，$a = 1/\\sigma$ 和 $b = -\\mu/\\sigma$。若 $a=\\sigma$ 且 $b=-\\mu$，则 $E[Z] = \\sigma \\mu - \\mu$ 且 $\\mathrm{Var}(Z) = \\sigma^4$，通常情况下，它们都不是所期望的 $0$ 和 $1$。\n- 标准化高斯分布会变成均匀分布的说法是错误的。高斯变量的仿射变换结果是另一个高斯变量。具体来说，对于高斯分布 $X \\sim N(\\mu, \\sigma^2)$，$Z = (X-\\mu)/\\sigma$ 会得到 $Z \\sim N(0, 1)$，即标准正态分布，它不是均匀分布。\n- **结论：不正确**。\n\n**C. 映射 $Z = (X - \\mu)/\\sigma$ 确保直方图的组边界和计数与 $X$ 的相同，只是重新标记了x轴。ROI的均值和方差在这种归一化下保持不变。**\n- 均值和方差保持不变的说法是错误的。该变换的目的和结果就是将均值从 $\\mu$ 变为 $0$，将方差从 $\\sigma^2$ 变为 $1$。\n- 关于组边界相同的说法是错误的。一个位于值 $x$ 的组边界会被映射到新值 $(x-\\mu)/\\sigma$。组的位置和宽度都被缩放和移动了。\n- **结论：不正确**。\n\n**D. 映射 $Z = (X - \\mu)/\\sigma$ 将直方图的中心置于 $0$，并将其方差设为 $1$，但它会改变形状，即改变偏度和峰度，除非 $X$ 是高斯分布。**\n- 第一部分是正确的：该映射将直方图中心置于 $0$ 并将其方差设为 $1$。\n- 第二部分是错误的。如上所述，对于任何具有有限矩的分布，偏度和峰度在该仿射变换下都是不变的，而不仅仅是高斯分布。该变换保留了形状。\n- **结论：不正确**。\n\n**E. 当应用于计算机断层扫描（CT）图像中的感兴趣区域（ROI）时，z-score归一化取决于像素的空间排列，并且可能破坏强度顺序，因为该变换对于 $X$ 是非线性的。**\n- 变换 $Z = aX+b$ 是仿射（如果 $b=0$ 则是线性）变换的定义。它对 $X$ 而言不是非线性的。\n- 因为该变换是一个严格递增的线性函数（因为 $a = 1/\\sigma  0$），它保留了强度顺序，而不是破坏它。\n- 计算ROI的全局统计量 $\\mu$ 和 $\\sigma$ 涉及对所有像素求和，而不管它们的空间排列。然后将变换 $z_i = (x_i - \\mu)/\\sigma$ 应用于每个像素的强度值 $x_i$，这与其位置无关。因此，变换本身不依赖于像素的空间排列。\n- **结论：不正确**。该陈述包含多个错误的主张。", "answer": "$$\\boxed{A}$$", "id": "4891654"}, {"introduction": "现实世界的医学成像常常受到各种伪影（artifacts）的影响，例如探测器饱和。本练习构建了一个数学模型，用以量化饱和现象如何破坏图像直方图，并对均值和方差等统计量产生偏差。通过解决这个问题([@problem_id:4891605])，您将学会如何分析和预测这些非理想条件对定量图像分析的影响，从而更好地理解和处理实际数据中的挑战。", "problem": "一个数字医学成像系统在闭区间 $\\left[0,1\\right]$ 的归一化尺度上记录像素强度，其中最大码值 $1$ 对应于饱和。考虑一次采集，其中由于探测器削波，比例为 $p$ 的像素在最大码值处饱和，而剩余比例为 $1-p$ 的像素在没有饱和的情况下，会遵循一个在 $\\left[0,1\\right]$ 上的均匀基线强度分布。图像直方图用于计算视场内所有像素的经验均值和方差。许多简单的全局阈值分割启发式方法选择一个形式为 $T=\\mu+k\\sigma$ 的阈值 $T$，其中 $\\mu$ 是经验均值，$\\sigma$ 是经验标准差，且 $k0$ 是一个用户选择的常数。\n\n仅使用期望、方差和混合分布的基本定义：\n- 在由概率为 $p$ 的位于 $1$ 处的点质量和概率为 $1-p$ 的在 $\\left[0,1\\right]$ 上的均匀分布组成的混合模型下，推导经验均值 $\\mu(p)$ 和经验方差 $\\sigma^{2}(p)$ 作为饱和比例 $p$ 的函数的闭式表达式。\n- 令 $T_{\\text{true}}(k)$ 表示在 $p=0$ 的理想情况下计算出的阈值，令 $T_{\\text{obs}}(p,k)$ 表示在饱和混合模型下计算出的阈值。推导阈值偏差 $\\Delta T(p,k)=T_{\\text{obs}}(p,k)-T_{\\text{true}}(k)$ 的闭式表达式。\n\n最后，通过计算在 $p=0.18$ 和 $k=1.2$ 时 $\\Delta T(p,k)$ 的值，来量化给定饱和比例下的阈值偏差。将最终数值答案四舍五入到四位有效数字。将答案表示为无单位数。", "solution": "在尝试求解之前，根据指定标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n- 像素强度在闭区间 $\\left[0,1\\right]$ 内。\n- 最大码值为 $1$，对应饱和。\n- 比例为 $p$ 的像素在最大码值 $1$ 处饱和。\n- 剩余比例为 $1-p$ 的像素遵循一个在 $\\left[0,1\\right]$ 上的均匀基线强度分布。\n- 整体模型是一个混合分布：概率为 $p$ 的位于 $1$ 处的点质量和概率为 $1-p$ 的在 $\\left[0,1\\right]$ 上的均匀分布。\n- 阈值 $T$ 定义为 $T=\\mu+k\\sigma$，其中 $\\mu$ 是经验均值，$\\sigma$ 是经验标准差，且 $k0$ 是一个常数。\n- 第一个任务：推导经验均值 $\\mu(p)$ 和经验方差 $\\sigma^{2}(p)$ 作为 $p$ 的函数的闭式表达式。\n- 第二个任务：推导阈值偏差 $\\Delta T(p,k)=T_{\\text{obs}}(p,k)-T_{\\text{true}}(k)$ 的闭式表达式，其中 $T_{\\text{true}}(k)$ 是 $p=0$ 时的阈值，而 $T_{\\text{obs}}(p,k)$ 是饱和混合模型下的阈值。\n- 第三个任务：计算在 $p=0.18$ 和 $k=1.2$ 时 $\\Delta T(p,k)$ 的值，并将答案四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据充分**：该问题在概率论和统计学（混合分布、期望、方差）方面有坚实的基础，并将这些概念应用于数字图像处理领域一个常见且现实的问题，特别是医学成像（探测器饱和及其对图像统计量的影响）。该模型是一个有效的简化。\n- **提法明确**：该问题提供了推导所需表达式和计算最终数值所需的全部信息和清晰定义。问题是自洽的，其结构可以导向唯一的解。\n- **客观性**：该问题使用精确、客观的数学和科学语言进行陈述，没有歧义或主观论断。\n\n该问题没有表现出任何列出的缺陷（例如，科学上不合理、不完整、矛盾、模糊）。均匀分布和点质量之间的混合数学模型定义明确，适合所要求的分析。\n\n### 步骤 3：结论和行动\n该问题是**有效的**。将提供完整解答。\n\n设 $I$ 为表示像素强度的随机变量。根据问题陈述，$I$ 的分布是两种分布的混合：\n$1$. 在区间 $\\left[0,1\\right]$ 上的均匀分布，我们称此分量为 $I_U \\sim U(0,1)$。此分量以概率 $1-p$ 被选中。\n$2$. 一个恒定值 $1$（一个点质量），我们称此分量为 $I_S$。此分量以概率 $p$ 被选中。\n\n期望值（均值） $\\mu(p) = \\mathbb{E}[I]$ 和二阶矩 $\\mathbb{E}[I^2]$ 可以通过以强度值是从混合分布的哪个分量中抽取的为条件，使用全期望定律来计算。\n$\\mathbb{E}[I^m] = (1-p)\\mathbb{E}[I_U^m] + p\\mathbb{E}[I_S^m]$.\n\n首先，我们求出每个分量的矩。\n对于均匀分量 $I_U \\sim U(0,1)$，其概率密度函数为当 $x \\in \\left[0,1\\right]$ 时 $f_U(x)=1$，否则为 $0$。\n一阶矩为 $\\mathbb{E}[I_U] = \\int_0^1 x \\cdot 1 \\, dx = \\left[\\frac{x^2}{2}\\right]_0^1 = \\frac{1}{2}$。\n二阶矩为 $\\mathbb{E}[I_U^2] = \\int_0^1 x^2 \\cdot 1 \\, dx = \\left[\\frac{x^3}{3}\\right]_0^1 = \\frac{1}{3}$。\n\n对于饱和分量 $I_S=1$，其矩为：\n$\\mathbb{E}[I_S] = \\mathbb{E}[1] = 1$。\n$\\mathbb{E}[I_S^2] = \\mathbb{E}[1^2] = 1$。\n\n现在，我们可以计算混合分布的均值 $\\mu(p)$ 和方差 $\\sigma^2(p)$。\n均值为 $\\mu(p) = \\mathbb{E}[I] = (1-p)\\mathbb{E}[I_U] + p\\mathbb{E}[I_S]$。\n$\\mu(p) = (1-p) \\cdot \\frac{1}{2} + p \\cdot 1 = \\frac{1-p}{2} + p = \\frac{1-p+2p}{2} = \\frac{1+p}{2}$。\n\n方差为 $\\sigma^2(p) = \\mathbb{E}[I^2] - (\\mathbb{E}[I])^2 = \\mathbb{E}[I^2] - (\\mu(p))^2$。我们首先需要混合分布的二阶矩 $\\mathbb{E}[I^2]$。\n$\\mathbb{E}[I^2] = (1-p)\\mathbb{E}[I_U^2] + p\\mathbb{E}[I_S^2]$。\n$\\mathbb{E}[I^2] = (1-p)\\cdot\\frac{1}{3} + p \\cdot 1 = \\frac{1-p}{3} + p = \\frac{1-p+3p}{3} = \\frac{1+2p}{3}$。\n\n现在我们可以求出方差 $\\sigma^2(p)$：\n$\\sigma^2(p) = \\frac{1+2p}{3} - \\left(\\frac{1+p}{2}\\right)^2 = \\frac{1+2p}{3} - \\frac{1+2p+p^2}{4}$。\n为了合并这些项，我们使用公分母 $12$：\n$\\sigma^2(p) = \\frac{4(1+2p) - 3(1+2p+p^2)}{12} = \\frac{4+8p - 3-6p-3p^2}{12}$。\n$\\sigma^2(p) = \\frac{1+2p-3p^2}{12}$。\n均值和方差的表达式为：\n$\\mu(p) = \\frac{1+p}{2}$\n$\\sigma^2(p) = \\frac{1+2p-3p^2}{12}$\n\n接下来，我们推导阈值偏差 $\\Delta T(p,k) = T_{\\text{obs}}(p,k) - T_{\\text{true}}(k)$。\n阈值定义为 $T = \\mu + k\\sigma = \\mu + k\\sqrt{\\sigma^2}$。\n\n首先，我们求出在 $p=0$ 的理想情况下的“真实”阈值 $T_{\\text{true}}(k)$。\n$\\mu(0) = \\frac{1+0}{2} = \\frac{1}{2}$。\n$\\sigma^2(0) = \\frac{1+2(0)-3(0)^2}{12} = \\frac{1}{12}$。\n标准差为 $\\sigma(0) = \\sqrt{\\frac{1}{12}} = \\frac{1}{\\sqrt{12}} = \\frac{1}{2\\sqrt{3}}$。\n因此，$T_{\\text{true}}(k) = \\mu(0) + k\\sigma(0) = \\frac{1}{2} + \\frac{k}{2\\sqrt{3}}$。\n\n接下来，我们求出饱和混合模型下的“观测”阈值 $T_{\\text{obs}}(p,k)$。\n$\\mu(p) = \\frac{1+p}{2}$。\n$\\sigma(p) = \\sqrt{\\sigma^2(p)} = \\sqrt{\\frac{1+2p-3p^2}{12}} = \\frac{\\sqrt{1+2p-3p^2}}{2\\sqrt{3}}$。\n平方根内的项可以因式分解：$1+2p-3p^2 = (1-p)(1+3p)$。\n因此，$\\sigma(p) = \\frac{\\sqrt{(1-p)(1+3p)}}{2\\sqrt{3}}$。\n从而，$T_{\\text{obs}}(p,k) = \\mu(p) + k\\sigma(p) = \\frac{1+p}{2} + k\\frac{\\sqrt{(1-p)(1+3p)}}{2\\sqrt{3}}$。\n\n阈值偏差 $\\Delta T(p,k)$ 是两者之差：\n$\\Delta T(p,k) = T_{\\text{obs}}(p,k) - T_{\\text{true}}(k) = \\left(\\frac{1+p}{2} + k\\frac{\\sqrt{(1-p)(1+3p)}}{2\\sqrt{3}}\\right) - \\left(\\frac{1}{2} + \\frac{k}{2\\sqrt{3}}\\right)$。\n$\\Delta T(p,k) = \\left(\\frac{1+p}{2} - \\frac{1}{2}\\right) + \\left(k\\frac{\\sqrt{(1-p)(1+3p)}}{2\\sqrt{3}} - \\frac{k}{2\\sqrt{3}}\\right)$。\n$\\Delta T(p,k) = \\frac{p}{2} + \\frac{k}{2\\sqrt{3}}\\left(\\sqrt{(1-p)(1+3p)} - 1\\right)$。\n\n最后，我们计算该表达式在 $p=0.18$ 和 $k=1.2$ 时的值。\n$\\Delta T(0.18, 1.2) = \\frac{0.18}{2} + \\frac{1.2}{2\\sqrt{3}}\\left(\\sqrt{(1-0.18)(1+3 \\cdot 0.18)} - 1\\right)$。\n$\\Delta T(0.18, 1.2) = 0.09 + \\frac{0.6}{\\sqrt{3}}\\left(\\sqrt{(0.82)(1+0.54)} - 1\\right)$。\n$\\Delta T(0.18, 1.2) = 0.09 + \\frac{0.6}{\\sqrt{3}}\\left(\\sqrt{0.82 \\times 1.54} - 1\\right)$。\n$\\Delta T(0.18, 1.2) = 0.09 + \\frac{0.6}{\\sqrt{3}}\\left(\\sqrt{1.2628} - 1\\right)$。\n现在我们计算数值：\n$\\sqrt{1.2628} \\approx 1.1237437$。\n$\\frac{0.6}{\\sqrt{3}} \\approx 0.3464102$。\n$\\Delta T(0.18, 1.2) \\approx 0.09 + 0.3464102 \\times (1.1237437 - 1)$。\n$\\Delta T(0.18, 1.2) \\approx 0.09 + 0.3464102 \\times 0.1237437$。\n$\\Delta T(0.18, 1.2) \\approx 0.09 + 0.0428610$。\n$\\Delta T(0.18, 1.2) \\approx 0.132861$。\n\n四舍五入到四位有效数字，我们得到 $0.1329$。", "answer": "$$\\boxed{0.1329}$$", "id": "4891605"}, {"introduction": "直方图不仅是分析工具，更是强大的图像增强手段。本练习([@problem_id:3224674])提供了一个动手实践的编程挑战：实现直方图均衡化，这是一种有效提升图像对比度的经典算法。此练习将展示如何利用累积直方图（即累积分布函数 CDF）来重新映射像素的强度值，使其更均匀地分布在整个动态范围内，从而凸显图像细节。", "problem": "设计并实现一个程序，该程序使用计数排序的核心机制对一幅 $8$ 位灰度图像执行直方图均衡化。目标是通过将频繁出现的强度值分布到整个可用范围内，来重映射像素强度以增强对比度。您的方案必须仅基于以下基本定义和经过充分检验的事实：(i) 对于有界整数键，计数排序通过计算每个可能键值的频率数组，然后计算前缀和（累积计数）来得出其位置或排名；(ii) 直方图均衡化使用图像直方图的累积分布函数（CDF）来重映射每个强度值，以拉伸动态范围。请勿使用任何其他算法捷径或特定领域的图像处理函数。您的实现必须从这两个基础推导而来。\n\n定义与约束：\n- 图像域包含 $L = 256$ 个可能的强度级别，由集合 $\\{0, 1, 2, \\dots, 255\\}$ 中的整数索引。\n- 令 $T$ 表示图像中的像素总数。\n- 令 $h[v]$ 表示强度 $v$ 的频率，其中 $v \\in \\{0, 1, \\dots, 255\\}$。\n- 令 $H[v]$ 表示前缀和 $H[v] = \\sum_{u=0}^{v} h[u]$，这是以计数单位表示的累积分布函数（CDF）。\n- 令 $H_{\\min}$ 表示 $\\{H[v] : h[v]  0\\}$ 中的最小正值。\n\n您的程序必须：\n- 通过对像素进行单次遍历来构建 $h[\\cdot]$，与计数排序的计数阶段完全相同。\n- 通过对 $h[\\cdot]$ 进行一次从左到右的前缀和计算来构建 $H[\\cdot]$，与计数排序的前缀和阶段完全相同。\n- 通过单调缩放累积计数，将每个观察到的强度 $v$ 重映射到 $\\{0, 1, \\dots, 255\\}$ 中的一个新值，使得第一个观察到的强度（其CDF为 $H_{\\min}$）映射到 $0$，而最大CDF值 $T$ 映射到 $255$。使用不大于该值的最大整数操作（向下取整）来离散化缩放后的值。对于未观察到的强度，只要映射是非递减的，并且对于观察到的强度满足所述约束，就可以任意赋值。处理退化情况 $T = H_{\\min}$（所有像素共享单一强度），将每个像素映射为 $0$。\n- 将生成的映射应用于图像。\n\n您的实现必须在 $T + L$ 上严格线性，不计常数因子。\n\n测试套件（所有图像都很小，并表示为整数矩阵；将它们视为二维数组，并在展平时使用行主序）：\n- 测试用例1（一个 $4 \\times 4$ 图像）：\n  - $\\begin{bmatrix}\n  52  55  61  59 \\\\\n  79  61  76  61 \\\\\n  85  64  59  55 \\\\\n  52  61  59  79\n  \\end{bmatrix}$\n- 测试用例2（一个 $3 \\times 3$ 图像；恒定强度）：\n  - $\\begin{bmatrix}\n  128  128  128 \\\\\n  128  128  128 \\\\\n  128  128  128\n  \\end{bmatrix}$\n- 测试用例3（一个 $2 \\times 4$ 图像；均匀递增的小范围）：\n  - $\\begin{bmatrix}\n  0  1  2  3 \\\\\n  4  5  6  7\n  \\end{bmatrix}$\n- 测试用例4（一个 $2 \\times 3$ 图像；极端双峰）：\n  - $\\begin{bmatrix}\n  0  0  0 \\\\\n  255  255  255\n  \\end{bmatrix}$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含 $4$ 个测试用例的结果，形式为方括号括起来的逗号分隔列表。每个结果本身必须是行主序展平后的均衡化图像，表示为一个整数列表。具体来说，输出必须是 $[\\text{case1},\\text{case2},\\text{case3},\\text{case4}]$ 形式的单行，其中每个 $\\text{case}i$ 是一个包含 $T_i$ 个在整数区间 $\\{0,\\dots,255\\}$ 内的整数的列表。\n\n不应从标准输入读取任何输入，也不得使用任何外部文件。您的程序必须是自包含且可复现的。", "solution": "问题陈述已经过严格审查，并被认定为有效。它具有科学依据，定义明确，客观且内部一致。它提出了一个基于计数排序和图像处理中直方图均衡化既定原则的形式化且可解决的算法挑战。因此，我们可以着手提供解决方案。\n\n任务是通过重映射像素强度来对一幅 $8$ 位灰度图像执行直方图均衡化。此过程通过将强度值更均匀地分布在可用的动态范围内来增强对比度。该方法必须从计数排序的核心机制推导而来。对于 $8$ 位图像，强度级别在整数集合 $\\{0, 1, \\dots, 255\\}$ 中。我们将可用级别的总数表示为 $L = 256$。\n\n**第一步：频率分析（构建直方图）**\n\n基础步骤是确定图像中每个强度级别的频率，这与计数排序的第一阶段相呼應。我们构建一个频率数组，即直方图，用 $h$ 表示。该数组的大小为 $L=256$，其中每个索引 $v \\in \\{0, 1, \\dots, 255\\}$ 对应一个强度级别。\n\n设输入图像表示为具有强度值的像素集合。我们将直方图数组 $h$ 初始化为全零。然后，我们对图像的所有 $T$ 个像素进行单次遍历。对于每个强度为 $v$ 的像素，我们在直方图中增加相应的计数器：\n$$h[v] \\leftarrow h[v] + 1$$\n遍历所有像素后，$h[v]$ 将保存强度为 $v$ 的像素总数。此操作的时间复杂度为 $O(T)$。\n\n**第二步：构建累积分布函数（CDF）**\n\n第二步是计算累积直方图 $H$，这类似于计数排序的前缀和阶段。该数组表示像素强度的累积分布函数（CDF），尽管尚未归一化。对于每个强度级别 $v$，$H[v]$ 存储强度小于或等于 $v$ 的像素总数。\n\n数组 $H$ 的大小同样为 $L=256$，通过对直方图 $h$ 进行单次遍历来构建：\n$$H[v] = \\sum_{u=0}^{v} h[u]$$\n这可以使用前缀和高效地计算：\n$$H[0] = h[0]$$\n$$H[v] = H[v-1] + h[v] \\quad \\text{for } v = 1, 2, \\dots, L-1$$\n像素总数 $T$ 由累积直方图的最后一个值给出，$T = H[L-1]$。此阶段的时间复杂度为 $O(L)$。\n\n**第三步：推导重映射变换**\n\n直方图均衡化的核心是定义一个映射函数 $f(v)$，它将原始强度 $v$ 转换为新的强度 $v'$。问题规定了对累积计数的特定单调缩放。目标是将观察到的累积计数范围映射到完整的输出强度范围 $\\{0, 1, \\dots, 255\\}$。\n\n首先，我们确定与观察到的强度值对应的最小累积计数。这被定义为 $H_{\\min}$：\n$$H_{\\min} = \\min \\{ H[v] \\mid v \\in \\{0, \\dots, 255\\}, h[v]  0 \\}$$\n对于观察到的像素，$H[v]$ 的值范围从 $H_{\\min}$到 $T$。问题要求将此源区间 $[H_{\\min}, T]$ 缩放到目标强度区间 $[0, L-1]$。\n\n当图像中所有像素具有相同强度时，会出现一种特殊情况。在这种情况下，只有一个 $h[v]$ 非零，且其值等于 $T$。因此，$H_{\\min}$ 将等于 $T$。问题明确指出，在这种退化情况下，即 $T = H_{\\min}$ 时，所有像素都应映射到强度值 $0$。\n\n对于非退化情况 ($T  H_{\\min}$)，我们应用线性变换。强度级别 $v$ 的重映射函数 $f(v)$ 由以下公式给出：\n$$f(v) = \\left\\lfloor (L-1) \\cdot \\frac{H[v] - H_{\\min}}{T - H_{\\min}} \\right\\rfloor$$\n此处，$(L-1)$ 为 $255$。项 $\\frac{H[v] - H_{\\min}}{T - H_{\\min}}$ 将累积计数缩放到归一化范围 $[0, 1]$。乘以 $(L-1)$ 将其缩放到 $[0, 255]$。向下取整函数 $\\lfloor \\cdot \\rfloor$ 按要求将结果离散化为不大于该值的整数。对所有可能的强度值 $v \\in \\{0, \\dots, 255\\}$ 计算此重映射函数，并将其存储在查找表中。构建此表需要 $O(L)$ 时间。\n\n**第四步：应用映射**\n\n有了从 $f(v)$ 推导出的重映射查找表，最后一步是创建均衡化后的图像。我们再次遍历原始图像的 $T$ 个像素。每个原始强度为 $v$ 的像素都被赋予查找表中的新强度 $f(v)$。此步骤的时间复杂度为 $O(T)$。\n\n**复杂度分析**\n\n算法的总时间复杂度是各步骤复杂度之和：\n1.  构建直方图：$O(T)$\n2.  构建CDF：$O(L)$\n3.  构建重映射表：$O(L)$\n4.  图像重映射：$O(T)$\n\n总复杂度为 $O(T) + O(L) + O(L) + O(T) = O(T+L)$。这满足问题陈述中指定的线性时间复杂度要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef equalize_histogram(image_matrix: np.ndarray) - list[int]:\n    \"\"\"\n    Performs histogram equalization on an 8-bit grayscale image matrix.\n\n    This implementation follows the principles of counting sort as specified:\n    1.  Computes a frequency histogram (h).\n    2.  Computes the cumulative distribution function (H).\n    3.  Derives a remapping function based on scaling the CDF.\n    4.  Applies the remapping to the image pixels.\n\n    Args:\n        image_matrix: A 2D numpy array of integers representing the image.\n\n    Returns:\n        A flattened list of integers representing the equalized image.\n    \"\"\"\n    L = 256  # Number of intensity levels for an 8-bit image\n\n    # Flatten the image into a 1D array of pixel intensities.\n    pixels = image_matrix.flatten()\n    T = pixels.size  # Total number of pixels\n\n    if T == 0:\n        return []\n\n    # Step 1: Construct the frequency array h (Histogram).\n    # This corresponds to counting sort's counting phase.\n    # np.bincount is a highly efficient way to compute a histogram.\n    h = np.bincount(pixels, minlength=L)\n\n    # Step 2: Construct the cumulative frequency array H (CDF).\n    # This corresponds to counting sort's prefix-sum phase.\n    H = np.cumsum(h).astype(np.int64)\n\n    # Step 3: Determine the remapping function.\n    \n    # Find H_min, the smallest cumulative count for an observed intensity.\n    # First, get indices where the histogram is non-zero.\n    observed_intensity_indices = np.where(h  0)[0]\n    \n    # H is monotonically non-decreasing, so the minimum H for an observed\n    # intensity corresponds to the first observed intensity.\n    H_min = H[observed_intensity_indices[0]]\n\n    # Handle the degenerate case where T = H_min.\n    # This occurs if all pixels have the same intensity.\n    if T == H_min:\n        return [0] * T\n\n    # For the general case, derive the remapping lookup table.\n    # The formula scales the range [H_min, T] to [0, L-1].\n    # Using floating-point arithmetic for the division is crucial.\n    scale_factor = (L - 1) / (T - H_min)\n    \n    # Apply the formula f(v) = floor((L-1) * (H[v] - H_min) / (T - H_min))\n    # This is done for all possible intensity values v from 0 to 255.\n    remap_table = np.floor(scale_factor * (H - H_min))\n    \n    # Clip values to ensure they are within the [0, 255] range and cast to an integer type.\n    # While the formula should not produce out-of-bounds values, clipping is a safeguard.\n    remap_table = np.clip(remap_table, 0, L - 1).astype(np.uint8)\n\n    # Step 4: Apply the mapping.\n    # Use the remap_table as a lookup table to transform the original pixel values.\n    # This is a fast, vectorized operation in numpy.\n    equalized_pixels = remap_table[pixels]\n\n    return equalized_pixels.tolist()\n\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the histogram equalization algorithm on each,\n    and prints the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [52, 55, 61, 59],\n            [79, 61, 76, 61],\n            [85, 64, 59, 55],\n            [52, 61, 59, 79]\n        ], dtype=np.uint8),\n        np.array([\n            [128, 128, 128],\n            [128, 128, 128],\n            [128, 128, 128]\n        ], dtype=np.uint8),\n        np.array([\n            [0, 1, 2, 3],\n            [4, 5, 6, 7]\n        ], dtype=np.uint8),\n        np.array([\n            [0, 0, 0],\n            [255, 255, 255]\n        ], dtype=np.uint8)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = equalize_histogram(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each result is a list of integers, which is converted to its string\n    # representation without spaces, and then joined by commas.\n    string_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(string_results)}]\")\n\nsolve()\n\n```", "id": "3224674"}]}