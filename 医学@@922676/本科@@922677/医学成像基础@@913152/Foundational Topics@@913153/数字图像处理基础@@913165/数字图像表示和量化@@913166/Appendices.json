{"hands_on_practices": [{"introduction": "降低位深度是一种常见的数据压缩方法，但这会牺牲图像质量。本练习将引导你量化这种牺牲，具体来说，就是计算位深度降低对信噪比（SNR）的影响，这是一个衡量信号质量的通用指标。通过这个练习[@problem_id:4536956]，你将能够从第一性原理推导出“每比特约$6$ dB”这一著名法则，并理解其在图像处理中的重要意义。", "problem": "一个三维医学图像体由体素强度表示，这些强度构成一个均值为零、方差为 $\\sigma_{s}^{2}$ 的宽平稳信号。该图像最初使用一个 $16$ 位均匀量化器在宽度为 $R$ 的固定动态范围内进行存储（即，当位深度改变时，可表示的最小和最大强度保持不变）。随后，该图像被重新量化为在相同动态范围内的 $12$ 位均匀量化器。假设高分辨率量化噪声模型成立，其量化误差独立于信号，在单个量化步长内均匀分布，且均值为零。\n\n从位深度、量化步长和信噪比（SNR）的基本定义出发，推导由 $16$ 位到 $12$ 位的重新量化所引入的SNR变化。将SNR变化表示为一个以分贝（dB）为单位的标量值，并四舍五入至三位有效数字。\n\n然后，运用第一性原理，论述这种位深度降低对基于 $N$ 个体素的强度直方图计算出的一阶放射组学统计量的影响，包括样本均值、样本方差、能量（强度平方和）、离散直方图的香农熵、偏度和峰度。在所述的量化噪声假设下，将你的论述重点放在偏差和可变性上。\n\n仅提供SNR的变化作为你的最终数值答案，四舍五入至三位有效数字，并以分贝（dB）表示。", "solution": "该问题陈述经评估具有科学依据、提法恰当、客观且内部一致。它基于数字信号处理和医学图像分析的标准原理。所提供的信息足以推导出所需的量并支持合理的分析。因此，该问题被认为是有效的。\n\n按照要求，解答分为两部分：首先，推导信噪比（SNR）的变化；其次，论述对一阶放射组学统计量的影响。\n\n**第一部分：SNR变化的推导**\n\n信噪比（SNR）定义为信号功率与噪声功率之比。以分贝（dB）为单位，其表达式为：\n$$\nSNR_{dB} = 10 \\log_{10}\\left(\\frac{P_{signal}}{P_{noise}}\\right)\n$$\n问题陈述指出，代表体素强度的信号是一个均值为零、方差为 $\\sigma_{s}^{2}$ 的宽平稳过程。对于零均值信号，信号功率 $P_{signal}$ 等于其方差。\n$$\nP_{signal} = E[s^2] = \\text{Var}(s) + (E[s])^2 = \\sigma_{s}^{2} + 0^2 = \\sigma_{s}^{2}\n$$\n此信号功率与量化过程无关。\n\n噪声是由均匀量化过程引入的。对于一个在宽度为 $R$ 的动态范围内、位深度为 $B$ 位的均匀量化器，其量化级别数为 $L = 2^B$。量化步长 $\\Delta$ 是相邻量化级别之间的距离：\n$$\n\\Delta = \\frac{R}{L} = \\frac{R}{2^B}\n$$\n问题指定了一个高分辨率量化模型，其中量化误差 $q_e$ 是一个在区间 $[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}]$ 上均匀分布的随机变量。误差的概率密度函数（PDF）为：\n$$\nf(q_e) = \\begin{cases} \\frac{1}{\\Delta}  \\text{if } -\\frac{\\Delta}{2} \\le q_e \\le \\frac{\\Delta}{2} \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n假设噪声均值为零，这与该对称分布一致。噪声功率 $P_{noise}$ 是量化误差的方差 $\\sigma_q^2$，对于零均值误差，它等于均方误差。\n$$\nP_{noise} = \\sigma_q^2 = E[q_e^2] = \\int_{-\\infty}^{\\infty} q_e^2 f(q_e) dq_e = \\int_{-\\Delta/2}^{\\Delta/2} q_e^2 \\frac{1}{\\Delta} dq_e\n$$\n$$\nP_{noise} = \\frac{1}{\\Delta} \\left[ \\frac{q_e^3}{3} \\right]_{-\\Delta/2}^{\\Delta/2} = \\frac{1}{3\\Delta} \\left( \\left(\\frac{\\Delta}{2}\\right)^3 - \\left(-\\frac{\\Delta}{2}\\right)^3 \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{8} + \\frac{\\Delta^3}{8} \\right) = \\frac{\\Delta^2}{12}\n$$\n现在，我们可以将SNR表示为位深度 $B$ 的函数：\n$$\nSNR(B) = \\frac{P_{signal}}{P_{noise}} = \\frac{\\sigma_{s}^{2}}{\\Delta^2/12} = \\frac{12\\sigma_{s}^{2}}{(R/2^B)^2} = \\frac{12\\sigma_{s}^{2} (2^B)^2}{R^2} = \\frac{12\\sigma_{s}^{2}}{R^2} 2^{2B}\n$$\n我们需要计算从初始位深度 $B_1 = 16$ 变为最终位深度 $B_2 = 12$ 时SNR的变化量（以dB为单位）。该变化量 $\\Delta SNR_{dB}$ 为：\n$$\n\\Delta SNR_{dB} = SNR_{dB}(B_2) - SNR_{dB}(B_1) = 10 \\log_{10}(SNR(B_2)) - 10 \\log_{10}(SNR(B_1))\n$$\n$$\n\\Delta SNR_{dB} = 10 \\log_{10}\\left(\\frac{SNR(B_2)}{SNR(B_1)}\\right)\n$$\nSNR的比值为：\n$$\n\\frac{SNR(B_2)}{SNR(B_1)} = \\frac{\\frac{12\\sigma_{s}^{2}}{R^2} 2^{2B_2}}{\\frac{12\\sigma_{s}^{2}}{R^2} 2^{2B_1}} = \\frac{2^{2B_2}}{2^{2B_1}} = 2^{2(B_2 - B_1)}\n$$\n代入 $B_1 = 16$ 和 $B_2 = 12$：\n$$\n\\frac{SNR(12)}{SNR(16)} = 2^{2(12 - 16)} = 2^{2(-4)} = 2^{-8}\n$$\n因此，SNR的变化量（以dB为单位）为：\n$$\n\\Delta SNR_{dB} = 10 \\log_{10}(2^{-8}) = -80 \\log_{10}(2)\n$$\n使用 $\\log_{10}(2) \\approx 0.30103$ 的值：\n$$\n\\Delta SNR_{dB} \\approx -80 \\times 0.30103 = -24.0824\n$$\n四舍五入至三位有效数字，SNR的变化为 $-24.1$ dB。\n\n**第二部分：对一阶放射组学统计量的影响**\n\n设真实的连续体素强度为 $X$，量化后的强度为 $Y$。根据问题陈述，我们可以将量化信号建模为 $Y = X + \\epsilon$，其中 $\\epsilon$ 是量化误差。假设误差 $\\epsilon$ 独立于 $X$，且 $E[\\epsilon]=0$ 及 $\\text{Var}(\\epsilon) = \\sigma_q^2 = \\Delta^2/12$。从 $B_1=16$ 位到 $B_2=12$ 位的重新量化意味着量化步长显著增加（$\\Delta_2 = 2^{16-12}\\Delta_1 = 16\\Delta_1$），从而导致噪声功率大幅增加（$\\sigma_{q2}^2 = (16)^2 \\sigma_{q1}^2 = 256\\sigma_{q1}^2$）。我们分析这对从 $N$ 个体素样本计算出的一阶统计量的影响。\n\n1.  **样本均值 ($\\bar{Y}$)**：量化信号的样本均值为 $\\bar{Y} = \\frac{1}{N}\\sum(X_i + \\epsilon_i) = \\bar{X} + \\bar{\\epsilon}$。\n    *   **偏差**：期望值为 $E[\\bar{Y}] = E[\\bar{X}] + E[\\bar{\\epsilon}] = \\mu_X$。由于对所有 $i$ 都有 $E[\\epsilon_i]=0$，样本均值仍然是真实信号均值的无偏估计量。位深度降低不会在样本均值中引入偏差。\n    *   **可变性**：样本均值的方差为 $\\text{Var}(\\bar{Y}) = \\text{Var}(\\bar{X}) + \\text{Var}(\\bar{\\epsilon}) = \\frac{\\sigma_s^2}{N} + \\frac{\\sigma_q^2}{N}$。由于 $\\sigma_{q2}^2 > \\sigma_{q1}^2$，$12$ 位图像的样本均值方差更高。其估计值稳定性较差。\n\n2.  **样本方差 ($s_Y^2$)**：由于独立性，量化信号的方差为 $\\sigma_Y^2 = \\text{Var}(X+\\epsilon) = \\text{Var}(X) + \\text{Var}(\\epsilon) = \\sigma_s^2 + \\sigma_q^2$。\n    *   **偏差**：样本方差 $s_Y^2$ 是 $\\sigma_Y^2$ 的无偏估计量，而不是 $\\sigma_s^2$ 的。其期望为 $E[s_Y^2] = \\sigma_s^2 + \\sigma_q^2$。因此，它是真实信号方差的有偏估计量，具有 $\\sigma_q^2$ 的正偏差。对于 $12$ 位图像（$\\sigma_{q2}^2$），此偏差远大于 $16$ 位图像（$\\sigma_{q1}^2$）。\n    *   **可变性**：$s_Y^2$ 估计量的可变性取决于 $Y$ 的高阶矩。随着位深度降低，$Y$ 的方差增大，其样本方差估计的可变性也预期会增加。\n\n3.  **能量 ($\\sum Y^2$)**：能量是体素强度的平方和。\n    *   **偏差**：能量的期望为 $E[\\sum Y_i^2] = \\sum E[(X_i+\\epsilon_i)^2] = \\sum(E[X_i^2] + 2E[X_i]E[\\epsilon_i] + E[\\epsilon_i^2])$。在 $E[X_i]=0$ 和 $E[\\epsilon_i]=0$ 的情况下，该式简化为 $\\sum(\\sigma_s^2 + \\sigma_q^2) = N(\\sigma_s^2 + \\sigma_q^2)$。能量存在一个 $N\\sigma_q^2$ 的正向偏差。对于 $12$ 位图像，这个正偏差要大得多。\n\n4.  **香农熵 ($H$)**：熵是根据离散体素强度直方图计算的，$H = -\\sum p_k \\log p_k$。\n    *   **偏差**：将位深度从 $16$ 位减少到 $12$ 位，会将可能存在的强度级别数从 $2^{16}$ 减少到 $2^{12}$。这会使强度直方图变得更粗糙，将多个较细的区间（bin）映射到单个较粗的区间中。这个过程是一种数据处理，根据数据处理不等式，它会减少信息量。非空区间的数量减少，其概率 $p_k$ 趋于增加。这几乎总是导致计算出的熵值降低。熵估计存在负向偏差，并且对于位深度较低的 $12$ 位表示，这种偏差更为显著。\n    *   **可变性**：尽管偏差更大，但从更粗糙的直方图（区间更少，每个区间的计数更多）得出的熵估计通常对采样噪声更具鲁棒性，这意味着其可变性可能更低。这体现了经典的偏差-方差权衡。\n\n5.  **偏度**：偏度衡量分布的不对称性。$Y$ 的偏度为 $\\gamma_1(Y) = E[((Y-\\mu_Y)/\\sigma_Y)^3]$。\n    *   **偏差**：因为量化误差 $\\epsilon$ 具有对称分布（$E[\\epsilon^3]=0$）且独立于信号 $X$，所以三阶中心矩得以保留：$E[(Y-\\mu_Y)^3] = E[(X-\\mu_X)^3]$。然而，方差增大了：$\\sigma_Y^2 = \\sigma_s^2 + \\sigma_q^2$。因此，量化信号的偏度为 $\\gamma_1(Y) = \\gamma_1(X) (\\frac{\\sigma_s^2}{\\sigma_s^2+\\sigma_q^2})^{3/2}$。测量到的偏度向零产生偏差，这意味着分布看起来更对称。由于在 $12$ 位情况下 $\\sigma_q^2$ 大得多，这种偏度的衰减要严重得多。\n\n6.  **峰度**：峰度衡量分布的“尾部特性”。\n    *   **偏差**：量化误差 $\\epsilon$ 的均匀分布是低阔峰态的（其超额峰度为 $-1.2$）。将信号的分布与该误差分布进行卷积，会使所得分布的峰度趋向于均匀噪声的峰度。$Y$ 的四阶中心矩为 $E[(Y-\\mu_Y)^4] = E[(X-\\mu_X)^4] + 6\\sigma_s^2\\sigma_q^2 + E[\\epsilon^4]$。$Y$ 的峰度成为信号峰度和噪声峰度的复杂混合。其效果是在测量的峰度中产生偏差，由于 $12$ 位图像的 $\\sigma_q^2$ 大得多，这种偏差也更强。$12$ 位图像的峰度将更严重地受到量化噪声的低阔峰态特性的影响。", "answer": "$$\n\\boxed{-24.1}\n$$", "id": "4536956"}, {"introduction": "在医学图像中，原始的数字值通常需要被映射到具有物理意义的单位上，例如CT图像中的亨斯菲尔德单位（Hounsfield Units）。本练习[@problem_id:4878156]模拟了一个常见的现实世界任务：为了提高计算效率，将图像重新量化到较低的位深度，同时在一个特定的临床关注窗口内保持与物理单位的精确映射。这个过程突显了工程师和科学家在平衡数据存储与临床应用需求时所面临的实际权衡。", "problem": "一个计算机断层扫描（CT）系统将原始像素强度以$12$位量化的整数代码形式存储，因此数字代码$I_{12}$的取值范围为$\\{0,1,\\dots,4095\\}$。医学数字成像与通信（DICOM）标准定义了一个从存储代码到亨氏单位（HU）的线性物理校准映射，其公式为$HU = s\\,I_{12} + b$，其中重标斜率$s$和重标截距$b$对每个序列是固定的。在此场景中，假设$s = 1.00$ $\\mathrm{HU}$/级，以及$b = -1024$ $\\mathrm{HU}$。\n\n对于一个下游的基于图形处理器（GPU）的肿瘤学分割流程，您计划将图像重新量化为$10$位整数代码$I_{10} \\in \\{0,1,\\dots,1023\\}$，以实现高效的纹理存储，同时保留像素值的亨氏单位物理可解释性。您将通过定义一个新的线性校准$HU = s'\\,I_{10} + b'$来实现这一点，该校准将一个临床相关的HU窗口$[L,U] = [-1000,3000]$精确地映射到可用的$10$位代码范围上，其中$I_{10} = 0$对应于$HU = L$，而$I_{10} = 1023$对应于$HU = U$。\n\n从均匀量化和线性校准的基本定义出发，确定在对$[-1000,3000]$ HU窗口进行$10$位重新量化时，能够保持单位不变的新重标斜率$s'$（即每级步长的HU值）。将您的答案四舍五入到四位有效数字。以亨氏单位每级（HU per level）表示最终值。", "solution": "用户提交了一个问题以供验证和求解。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n-   原始量化位深：$12$位\n-   原始整数代码：$I_{12} \\in \\{0, 1, \\dots, 4095\\}$\n-   原始校准方程：$HU = s \\cdot I_{12} + b$\n-   原始重标斜率：$s = 1.00$ HU/级\n-   原始重标截距：$b = -1024$ HU\n-   新量化位深：$10$位\n-   新整数代码：$I_{10} \\in \\{0, 1, \\dots, 1023\\}$\n-   新校准方程：$HU = s' \\cdot I_{10} + b'$\n-   临床相关HU窗口下界：$L = -1000$ HU\n-   临床相关HU窗口上界：$U = 3000$ HU\n-   映射条件1：$I_{10} = 0$ 对应于 $HU = L = -1000$ HU\n-   映射条件2：$I_{10} = 1023$ 对应于 $HU = U = 3000$ HU\n-   目标：确定新的重标斜率$s'$。\n-   要求精度：四舍五入到四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估：\n-   **科学性**：该问题基于成熟的医学成像DICOM标准。亨氏单位（HU）、位深、量化、重标斜率和重标截距等概念是计算机断层扫描（CT）中基本且表述准确的概念。所提供的原始校准数值（$s=1$, $b=-1024$）是标准值，感兴趣的HU窗口（$[-1000, 3000]$）在临床上对于涵盖从空气到致密骨的组织是现实的。为特定处理流程（如基于GPU的分割）重新量化数据的做法是医学图像分析中的常见任务。该问题在科学上是合理的。\n-   **适定性**：该问题要求计算新线性变换的斜率（$s'$）。它提供了直线上的两个不同点：$(I_{10}, HU) = (0, -1000)$ 和 $(1023, 3000)$。两点唯一确定一条直线，因此其参数（$s'$ 和 $b'$）可以被唯一确定。该问题是适定的，并且有唯一且有意义的解。\n-   **客观性**：该问题以精确、定量和技术性的语言陈述。它没有歧义、主观性或基于观点的论断。\n\n**步骤3：结论与行动**\n问题有效。它具有科学性、适定性和客观性。没有可识别的缺陷。现在开始求解过程。\n\n**问题求解**\n\n重新量化的过程涉及在$10$位整数代码$I_{10}$与亨氏单位（HU）表示的物理值之间定义一个新的线性关系。该关系由以下方程给出：\n$$HU = s' \\cdot I_{10} + b'$$\n其中$s'$是新的重标斜率，$b'$是新的重标截距。\n\n问题规定，临床相关的HU值范围$[L, U]$必须精确地映射到新的$10$位整数代码的整个范围$\\{0, 1, \\dots, 1023\\}$。这为校准方程所定义的直线提供了两个特定的点：\n1.  最小整数代码$I_{10,min} = 0$映射到HU窗口的下界$L = -1000$ HU。\n2.  最大整数代码$I_{10,max} = 1023$映射到HU窗口的上界$U = 3000$ HU。\n\n我们可以将这两个条件表示为一个二元一次方程组：\n1.  对于点 $(I_{10}, HU) = (0, -1000)$:\n    $$-1000 = s' \\cdot 0 + b'$$\n2.  对于点 $(I_{10}, HU) = (1023, 3000)$:\n    $$3000 = s' \\cdot 1023 + b'$$\n\n从第一个方程，我们可以立即确定新的重标截距$b' = -1000$ HU。\n\n重标斜率$s'$表示整数代码$I_{10}$每增加一个单位时HU的变化量。根据定义，它就是直线的斜率。经过两点$(x_1, y_1)$和$(x_2, y_2)$的直线的斜率由公式$m = \\frac{y_2 - y_1}{x_2 - x_1}$给出。在我们的情境中，$y$对应于$HU$，$x$对应于$I_{10}$。\n\n使用两个指定的映射点$(I_{10,min}, L)$和$(I_{10,max}, U)$，我们可以计算$s'$：\n$$s' = \\frac{\\Delta HU}{\\Delta I_{10}} = \\frac{U - L}{I_{10,max} - I_{10,min}}$$\n\n代入给定值：\n$$L = -1000 \\, \\mathrm{HU}$$\n$$U = 3000 \\, \\mathrm{HU}$$\n$$I_{10,min} = 0$$\n$$I_{10,max} = 1023$$\n\n$s'$的计算如下：\n$$s' = \\frac{3000 - (-1000)}{1023 - 0} = \\frac{3000 + 1000}{1023} = \\frac{4000}{1023}$$\n\n问题要求最终数值答案四舍五入到四位有效数字。我们进行除法运算：\n$$s' = \\frac{4000}{1023} \\approx 3.910068426...$$\n\n为了将此值四舍五入到四位有效数字，我们检查前四个非零数字，即$3$、$9$、$1$和$0$。第五位有效数字是$0$。因此，我们不对第四位有效数字进行进位。结果值为$3.910$。\n\n斜率的单位是纵轴单位（HU）除以横轴单位（级或整数代码增量），因此单位是HU/级。\n\n因此，新的重标斜率是$s' \\approx 3.910$ HU/级。", "answer": "$$\n\\boxed{3.910}\n$$", "id": "4878156"}, {"introduction": "本练习将带你深入到图像数据的比特层面，这是一种比简单量化更精细的视角。通过一个编程挑战[@problem_id:4878152]，你将实现移除最低有效位平面的过程，这本质上是一种粗量化。通过计算对比噪声比（CNR），你将能够量化地探索一幅图像在诊断效用受到显著影响之前可以被压缩到何种程度，从而直观地理解数据精度与诊断价值之间的平衡。", "problem": "您将处理一个精确的公式化任务，该任务基于医学成像基础中使用的数字图像表示和量化的基本原理。考虑一个采用 $8$ 位均匀标量量化的灰度图像，因此每个像素强度 $I(x,y)$ 是 $\\{0,\\dots,255\\}$ 中的一个整数。位平面分解将 $I(x,y)$ 表示为加权位 $b_j(x,y) \\in \\{0,1\\}$（其中 $j \\in \\{0,\\dots,7\\}$）的总和，权重为 $2^j$。仅保留 $k$ 个最高有效位平面（即，保留位平面 $j \\in \\{8-k,\\dots,7\\}$ 并将其余较低位平面设置为零），会得到一个重建图像 $\\tilde{I}_k$，这等效于通过截断应用步长为 $\\Delta_k = 2^{8-k}$ 的均匀量化器：\n$$\n\\tilde{I}_k(x,y) = \\left\\lfloor \\frac{I(x,y)}{2^{8-k}} \\right\\rfloor \\cdot 2^{8-k}.\n$$\n对于指定的一对不相交的感兴趣区域 (ROIs)——一个背景区域 $\\mathcal{R}_\\mathrm{B}$ 和一个病变区域 $\\mathcal{R}_\\mathrm{L}$——对于任何图像 $J$，将背景均值 $\\mu_\\mathrm{B}(J)$ 和病变均值 $\\mu_\\mathrm{L}(J)$ 分别定义为 $J$ 在 $\\mathcal{R}_\\mathrm{B}$ 和 $\\mathcal{R}_\\mathrm{L}$ 上的算术平均值。使用分母 $n-1$ 在每个区域内定义无偏样本标准差 $s_\\mathrm{B}(J)$ 和 $s_\\mathrm{L}(J)$。为了反映实际检测受到固有纹理和仪器基线噪声的限制，将诊断对比度噪声比 (CNR) 定义为\n$$\n\\mathrm{CNR}(J) = \\frac{\\left|\\mu_\\mathrm{L}(J) - \\mu_\\mathrm{B}(J)\\right|}{\\sqrt{s_\\mathrm{L}(J)^2 + s_\\mathrm{B}(J)^2 + 2\\delta^2}},\n$$\n其中 $\\delta$ 是以灰度级为单位的固定基线噪声。在本问题中，取 $\\delta = 0.5$。\n\n对于给定的原始图像 $I$ 和阈值 $f \\in (0,1]$，将 $k^\\star$ 定义为满足以下条件的最小整数 $k \\in \\{1,\\dots,8\\}$：\n$$\n\\frac{\\mathrm{CNR}(\\tilde{I}_k)}{\\mathrm{CNR}(I)} \\ge f.\n$$\n您的任务是编写一个程序，为以下每个测试用例计算 $k^\\star$。\n\n使用以下三个测试用例。在每个测试用例中，图像 $I$ 的大小为 $4 \\times 4$，背景掩码 $M_\\mathrm{B}$ 选择前两行（条目等于 $1$ 表示成员关系），病变掩码 $M_\\mathrm{L}$ 选择后两行。图像和掩码如下。\n\n- 测试用例 $1$：\n  - 图像 $I^{(1)}$：\n    $\n    \\begin{bmatrix}\n    129  131  133  135 \\\\\n    130  132  134  136 \\\\\n    149  151  153  155 \\\\\n    150  152  154  152\n    \\end{bmatrix}\n    $\n  - 背景掩码 $M_\\mathrm{B}^{(1)}$：\n    $\n    \\begin{bmatrix}\n    1  1  1  1 \\\\\n    1  1  1  1 \\\\\n    0  0  0  0 \\\\\n    0  0  0  0\n    \\end{bmatrix}\n    $\n  - 病变掩码 $M_\\mathrm{L}^{(1)}$：\n    $\n    \\begin{bmatrix}\n    0  0  0  0 \\\\\n    0  0  0  0 \\\\\n    1  1  1  1 \\\\\n    1  1  1  1\n    \\end{bmatrix}\n    $\n  - 阈值 $f^{(1)} = 0.70$。\n\n- 测试用例 $2$：\n  - 图像 $I^{(2)}$：\n    $\n    \\begin{bmatrix}\n    170  171  173  174 \\\\\n    172  173  175  171 \\\\\n    190  191  193  194 \\\\\n    192  193  195  191\n    \\end{bmatrix}\n    $\n  - 背景掩码 $M_\\mathrm{B}^{(2)}$：\n    $\n    \\begin{bmatrix}\n    1  1  1  1 \\\\\n    1  1  1  1 \\\\\n    0  0  0  0 \\\\\n    0  0  0  0\n    \\end{bmatrix}\n    $\n  - 病变掩码 $M_\\mathrm{L}^{(2)}$：\n    $\n    \\begin{bmatrix}\n    0  0  0  0 \\\\\n    0  0  0  0 \\\\\n    1  1  1  1 \\\\\n    1  1  1  1\n    \\end{bmatrix}\n    $\n  - 阈值 $f^{(2)} = 1.00$。\n\n- 测试用例 $3$：\n  - 图像 $I^{(3)}$：\n    $\n    \\begin{bmatrix}\n    92  95  98  101 \\\\\n    94  97  100  103 \\\\\n    220  225  230  235 \\\\\n    222  228  232  238\n    \\end{bmatrix}\n    $\n  - 背景掩码 $M_\\mathrm{B}^{(3)}$：\n    $\n    \\begin{bmatrix}\n    1  1  1  1 \\\\\n    1  1  1  1 \\\\\n    0  0  0  0 \\\\\n    0  0  0  0\n    \\end{bmatrix}\n    $\n  - 病变掩码 $M_\\mathrm{L}^{(3)}$：\n    $\n    \\begin{bmatrix}\n    0  0  0  0 \\\\\n    0  0  0  0 \\\\\n    1  1  1  1 \\\\\n    1  1  1  1\n    \\end{bmatrix}\n    $\n  - 阈值 $f^{(3)} = 0.70$。\n\n要求：\n- 使用 $\\delta = 0.5$。\n- 在每个 ROI 内使用分母为 $n-1$ 的无偏样本标准差。\n- 评估 $k$ 从 $1$ 到 $8$ 的值，并选择满足不等式的最小 $k$。\n- 您的程序应生成单行输出，其中包含三个结果整数，格式为用方括号括起来的逗号分隔列表，例如 $[a,b,c]$，其中 $a$、$b$ 和 $c$ 分别是测试用例 1、2 和 3 的答案。\n\n您的程序必须是自包含的，且不得读取任何外部输入。唯一允许的输出是上述指定格式的单行列表。", "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n- **图像表示**：采用 $8$ 位均匀标量量化的灰度图像。像素强度 $I(x,y)$ 是 $\\{0, \\dots, 255\\}$ 中的一个整数。\n- **位平面分解**：$I(x,y)$ 是加权位 $b_j(x,y) \\in \\{0,1\\}$（其中 $j \\in \\{0, \\dots, 7\\}$）的总和，权重为 $2^j$。\n- **重建图像 $\\tilde{I}_k$**：通过保留 $k$ 个最高有效位平面（$j \\in \\{8-k, \\dots, 7\\}$）重建的图像。这等效于通过截断应用步长为 $\\Delta_k = 2^{8-k}$ 的均匀量化。\n- **量化公式**：\n$$\n\\tilde{I}_k(x,y) = \\left\\lfloor \\frac{I(x,y)}{2^{8-k}} \\right\\rfloor \\cdot 2^{8-k}\n$$\n- **感兴趣区域 (ROIs)**：一个背景区域 $\\mathcal{R}_\\mathrm{B}$ 和一个病变区域 $\\mathcal{R}_\\mathrm{L}$，它们是不相交的。\n- **ROI 统计量**：\n    - 背景均值 $\\mu_\\mathrm{B}(J)$：图像 $J$ 在 $\\mathcal{R}_\\mathrm{B}$ 上的算术平均值。\n    - 病变均值 $\\mu_\\mathrm{L}(J)$：图像 $J$ 在 $\\mathcal{R}_\\mathrm{L}$ 上的算术平均值。\n    - 无偏样本标准差 $s_\\mathrm{B}(J)$ 和 $s_\\mathrm{L}(J)$，在每个区域内使用分母 $n-1$ 计算。\n- **对比度噪声比 (CNR)**：\n$$\n\\mathrm{CNR}(J) = \\frac{\\left|\\mu_\\mathrm{L}(J) - \\mu_\\mathrm{B}(J)\\right|}{\\sqrt{s_\\mathrm{L}(J)^2 + s_\\mathrm{B}(J)^2 + 2\\delta^2}}\n$$\n- **基线噪声**：$\\delta = 0.5$。\n- **目标值 $k^\\star$**：对于给定的阈值 $f \\in (0, 1]$，满足以下条件的最小整数 $k \\in \\{1, \\dots, 8\\}$：\n$$\n\\frac{\\mathrm{CNR}(\\tilde{I}_k)}{\\mathrm{CNR}(I)} \\ge f\n$$\n- **测试用例**：提供了三个测试用例，每个用例都包含一个 $4 \\times 4$ 的图像 $I$、一个背景掩码 $M_\\mathrm{B}$（前两行）、一个病变掩码 $M_\\mathrm{L}$（后两行）和一个阈值 $f$。\n    - **测试用例 1**：$I^{(1)}$、$M_\\mathrm{B}^{(1)}$、$M_\\mathrm{L}^{(1)}$、$f^{(1)} = 0.70$。\n    - **测试用例 2**：$I^{(2)}$、$M_\\mathrm{B}^{(2)}$、$M_\\mathrm{L}^{(2)}$、$f^{(2)} = 1.00$。\n    - **测试用例 3**：$I^{(3)}$、$M_\\mathrm{B}^{(3)}$、$M_\\mathrm{L}^{(3)}$、$f^{(3)} = 0.70$。\n    - 图像和掩码的具体矩阵在问题陈述中已提供。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学性**：该问题在数字图像处理和医学物理学的基本原理方面有充分的依据。位平面分解、量化、均值、标准差和对比度噪声比 (CNR) 等概念都是标准的且公式正确。在 CNR 分母中包含基线噪声项 $\\delta$ 是一个符合物理现实的改进。\n2.  **适定性**：该问题在数学上是精确且自包含的。所有函数、变量和常量都已明确定义。任务是在有限集合 $\\{1, \\dots, 8\\}$ 中找到满足一个明确定义的不等式的最小整数 $k$。这种结构确保了每个测试用例都存在唯一且有意义的解。\n3.  **客观性**：问题陈述使用了客观、正式的语言。输入是数值数组和参数，要求的输出是根据无歧义的计算得出的数值结果。没有主观或基于意见的元素。\n4.  **缺陷检查清单**：\n    - **科学或事实不准确**：无。公式和概念都是标准的。\n    - **无法形式化或不相关**：无。该问题是一个关于医学图像分析的形式化练习。\n    - **不完整或矛盾的设置**：无。所有必要的数据，包括图像、掩码和参数，都已提供。ROI 掩码按要求是不相交的。\n    - **不切实际或不可行**：无。图像值在指定的 $8$ 位范围内，计算在计算上是可行的。\n    - **不适定或结构不良**：无。逻辑是直接的，寻找最小整数解是一个定义明确的过程。\n    - **伪深刻、琐碎或同义反复**：无。该问题需要一个多步骤的计算，这展示了对量化效应对图像统计量影响的理解，这是一个不平凡的概念。\n    - **超出科学可验证性**：无。整个计算是确定性的，可以独立验证。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。这是一个清晰、自包含且科学上合理的定量图像分析练习。我将继续提供完整的解决方案。\n\n## 解题思路\n\n解决方案要求实现一个程序来为三个测试用例中的每一个计算整数 $k^\\star$。这涉及系统地应用所提供的定义。每个测试用例的总体算法如下：\n\n1.  **定义一个计算 CNR 的函数。** 这个函数，我们称之为 `calculate_cnr`，将以一个图像 $J$、一个背景掩码 $M_\\mathrm{B}$、一个病变掩码 $M_\\mathrm{L}$ 和基线噪声 $\\delta$ 作为输入。\n    - 它首先使用掩码提取背景区域 $\\mathcal{R}_\\mathrm{B}$ 和病变区域 $\\mathcal{R}_\\mathrm{L}$ 的像素值。\n    - 然后，它计算每个区域的算术平均值（$\\mu_\\mathrm{B}(J)$、$\\mu_\\mathrm{L}(J)$）和无偏样本标准差（$s_\\mathrm{B}(J)$、$s_\\mathrm{L}(J)$，分母为 $n-1$）。\n    - 最后，它使用给定公式计算 CNR：$\\mathrm{CNR}(J) = \\frac{|\\mu_\\mathrm{L}(J) - \\mu_\\mathrm{B}(J)|}{\\sqrt{s_\\mathrm{L}(J)^2 + s_\\mathrm{B}(J)^2 + 2\\delta^2}}$。项 $2\\delta^2 = 2(0.5)^2 = 0.5$ 是一个正常数，这可以防止在两个区域方差均为零的情况下出现除以零的错误。\n\n2.  **计算原始图像的参考 CNR。** 对于每个测试用例，将 `calculate_cnr` 函数应用于原始图像 $I$，以获得参考值 $\\mathrm{CNR}(I)$。\n\n3.  **遍历 $k$ 以找到 $k^\\star$。** 对于每个测试用例，从 $1$ 到 $8$ 遍历整数值 $k$。在每次迭代中：\n    - **重建图像。** 使用公式 $\\tilde{I}_k = \\lfloor I / 2^{8-k} \\rfloor \\cdot 2^{8-k}$ 从原始图像 $I$ 生成量化图像 $\\tilde{I}_k$。项 $\\Delta_k = 2^{8-k}$ 是量化步长。这个操作可以通过在图像数组上使用整数除法来高效执行。\n    - **计算重建图像的 CNR。** 将 `calculate_cnr` 函数应用于 $\\tilde{I}_k$ 以得到 $\\mathrm{CNR}(\\tilde{I}_k)$。\n    - **检查条件。** 评估不等式 $\\frac{\\mathrm{CNR}(\\tilde{I}_k)}{\\mathrm{CNR}(I)} \\ge f$。如果 $\\mathrm{CNR}(I)$ 非零，这是一个简单的除法。如果 $\\mathrm{CNR}(I)$ 为零，则该比率将是未定义的或无穷大，但对于给定的测试数据，区域均值是不同的，因此 $\\mathrm{CNR}(I)$ 是正数。\n    - **确定 $k^\\star$。** 第一个满足不等式的 $k$ 值（从 $k=1$ 开始）就是该测试用例的解 $k^\\star$。一旦找到，我们记录此值并继续下一个测试用例。\n\n4.  **整合并格式化结果。** 收集所有三个测试用例的 $k^\\star$ 值，并将它们格式化为所需的输出字符串。\n\n整个过程将封装在一个 Python 脚本中，使用 NumPy 库进行高效的数值和数组操作。`numpy.mean` 和 `numpy.std(ddof=1)` 是计算所需统计量的合适函数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the medical imaging quantization problem for the three given test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"image\": np.array([\n                [129, 131, 133, 135],\n                [130, 132, 134, 136],\n                [149, 151, 153, 155],\n                [150, 152, 154, 152]\n            ], dtype=np.int32),\n            \"mask_b\": np.array([\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [0, 0, 0, 0],\n                [0, 0, 0, 0]\n            ], dtype=np.int32),\n            \"mask_l\": np.array([\n                [0, 0, 0, 0],\n                [0, 0, 0, 0],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1]\n            ], dtype=np.int32),\n            \"f\": 0.70\n        },\n        {\n            \"image\": np.array([\n                [170, 171, 173, 174],\n                [172, 173, 175, 171],\n                [190, 191, 193, 194],\n                [192, 193, 195, 191]\n            ], dtype=np.int32),\n            \"mask_b\": np.array([\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [0, 0, 0, 0],\n                [0, 0, 0, 0]\n            ], dtype=np.int32),\n            \"mask_l\": np.array([\n                [0, 0, 0, 0],\n                [0, 0, 0, 0],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1]\n            ], dtype=np.int32),\n            \"f\": 1.00\n        },\n        {\n            \"image\": np.array([\n                [92, 95, 98, 101],\n                [94, 97, 100, 103],\n                [220, 225, 230, 235],\n                [222, 228, 232, 238]\n            ], dtype=np.int32),\n            \"mask_b\": np.array([\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [0, 0, 0, 0],\n                [0, 0, 0, 0]\n            ], dtype=np.int32),\n            \"mask_l\": np.array([\n                [0, 0, 0, 0],\n                [0, 0, 0, 0],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1]\n            ], dtype=np.int32),\n            \"f\": 0.70\n        }\n    ]\n\n    delta = 0.5\n    results = []\n\n    def calculate_cnr(image, mask_b, mask_l, delta_noise):\n        \"\"\"Calculates the CNR for a given image and ROIs.\"\"\"\n        # Convert 0/1 masks to boolean masks for indexing\n        bool_mask_b = mask_b.astype(bool)\n        bool_mask_l = mask_l.astype(bool)\n\n        pixels_b = image[bool_mask_b]\n        pixels_l = image[bool_mask_l]\n\n        # Calculate means\n        mu_b = np.mean(pixels_b)\n        mu_l = np.mean(pixels_l)\n\n        # Calculate unbiased sample standard deviations (ddof=1)\n        # If all pixels in a region are the same, std will be 0, which is correct.\n        s_b = np.std(pixels_b, ddof=1)\n        s_l = np.std(pixels_l, ddof=1)\n        \n        # Calculate CNR\n        numerator = np.abs(mu_l - mu_b)\n        denominator = np.sqrt(s_l**2 + s_b**2 + 2 * delta_noise**2)\n        \n        # Denominator is guaranteed to be non-zero since delta is non-zero\n        return numerator / denominator\n\n    for case in test_cases:\n        I = case[\"image\"]\n        M_B = case[\"mask_b\"]\n        M_L = case[\"mask_l\"]\n        f = case[\"f\"]\n        \n        cnr_original = calculate_cnr(I, M_B, M_L, delta)\n\n        k_star = -1 # Should be replaced in the loop\n\n        if cnr_original == 0 and f > 0:\n            # If original CNR is 0, any non-zero reconstructed CNR would yield\n            # an infinite ratio. Or if reconstructed CNR is also 0, ratio could be 1.\n            # We must carefully check this. For the given problems, cnr_original is not 0.\n            # However, for completeness, we search for the first k that gives non-zero CNR.\n            for k in range(1, 9):\n                delta_k = 2**(8 - k)\n                I_k = (I // delta_k) * delta_k\n                cnr_k = calculate_cnr(I_k, M_B, M_L, delta)\n                if cnr_k > 0:\n                    k_star = k\n                    break\n        else:\n            for k in range(1, 9):\n                # Calculate the quantization step size\n                delta_k = 2**(8 - k)\n                \n                # Apply the quantization by truncation\n                I_k = (I // delta_k) * delta_k\n                \n                # Calculate CNR of the reconstructed image\n                cnr_k = calculate_cnr(I_k, M_B, M_L, delta)\n                \n                # Check the condition\n                ratio = cnr_k / cnr_original\n                if ratio >= f:\n                    k_star = k\n                    break\n        \n        results.append(k_star)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "4878152"}]}