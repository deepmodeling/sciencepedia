{"hands_on_practices": [{"introduction": "“时钟-波前”模型不仅是一个概念框架，更是一个强大的预测工具。该练习让你能够亲手应用模型的核心原理，即通过振荡周期 $T$ 和波前速度 $u$ 来计算新生体节的长度 $S$ [@problem_id:4939470]。更重要的是，它引导你思考理论预测与真实组织学测量值之间的差异，让你体会到在科学研究中考虑生物学过程（如生长）和实验伪影（如固定收缩）的重要性。", "problem": "在体节发生的时钟-波阵面模型中，前体节中胚层（PSM）表现出称为分节时钟的振荡性基因表达，其周期为 $T$，同时，一个停滞前沿（决定波阵面）以速度 $u$ 沿胚胎前后轴向前移动。根据活体鸟类胚胎的延时成像构建的动态图谱，提供了测得的停滞前沿速度 $u$ 和分节时钟的振荡周期 $T$。从第一性原理出发，使用核心定义，将停滞前沿在一次振荡期间前进的距离与新生体节的前后长度 $S$ 联系起来。接下来，认识到在分节之后，体节的前后长度在进行组织学固定之前会增加一个分数增长 $\\gamma$，并且固定和处理过程会导致由分数损失 $s$ 表示的各向同性收缩。\n\n给定以下实验测定值：\n- 从动态图谱测得的停滞前沿速度 $u = 1.6\\ \\text{µm}\\ \\text{min}^{-1}$。\n- 分节时钟周期 $T = 90\\ \\text{min}$。\n- 固定前沿前后维度的分数增长 $\\gamma = 0.05$。\n- 固定后组织学测量的体节宽度 $S_{\\text{hist}} = 130\\ \\text{µm}$。\n\n仅使用分节时钟和波阵面的核心定义，首先根据实时动态图谱测量值计算预测的新生体节长度 $S$（单位为微米）。然后，推导并计算收缩分数 $s$，该分数能使预测的活体体节长度（包括固定前指定的生长率 $\\gamma$）与固定组织的组织学测量值 $S_{\\text{hist}}$ 相吻合。\n\n将最终答案以小数形式报告为收缩分数 $s$。将最终答案四舍五入至三位有效数字。最终答案中不包含任何单位。", "solution": "问题陈述被评估为有效。它在科学上基于已确立的脊椎动物体节发生的时钟-波阵面模型，问题提法良好，数据充分且一致，并且表述客观。所提供的参数，如分节时钟周期和波阵面速度，在鸟类胚胎的生理现实范围内。该问题要求逻辑地应用核心定义来推导一个具有物理意义的量。\n\n解题过程按要求分两个阶段进行。首先，根据动态图谱的测量值计算新生体节的长度 $S$。其次，将此值与分节后生长和组织学测量值一同使用，以确定收缩分数 $s$。\n\n时钟-波阵面模型的核心原理是，在分节时钟的每个周期 $T$ 内形成一个体节。这个新生体节的前后长度 $S$ 由决定波阵面在此时间间隔内沿前体节中胚层行进的距离决定。鉴于波阵面以恒定速度 $u$ 移动，长度 $S$ 由速度和时间的乘积给出：\n$$S = uT$$\n使用实验测定值 $u = 1.6 \\text{ µm min}^{-1}$ 和 $T = 90 \\text{ min}$：\n$$S = (1.6 \\text{ µm min}^{-1}) \\times (90 \\text{ min}) = 144 \\text{ µm}$$\n这是体节从前体节中胚层形成后，预测的即时前后长度。\n\n接下来，我们考虑在最终组织学测量之前改变此长度的生物学和技术过程。问题陈述指出，体节经历生长，其前后长度增加了一个分数 $\\gamma = 0.05$。生长后的长度，我们记为 $S_{\\text{grown}}$，是：\n$$S_{\\text{grown}} = S + \\gamma S = S(1 + \\gamma)$$\n代入计算出的 $S$ 值：\n$$S_{\\text{grown}} = 144 \\text{ µm} \\times (1 + 0.05) = 144 \\text{ µm} \\times 1.05 = 151.2 \\text{ µm}$$\n\n在此生长之后，组织被固定并进行组织学处理，这导致了各向同性收缩。这种收缩表示为从生长后长度 $S_{\\text{grown}}$ 中损失的一个分数 $s$。因此，组织学切片上最终测量的长度 $S_{\\text{hist}}$ 与 $S_{\\text{grown}}$ 的关系如下：\n$$S_{\\text{hist}} = S_{\\text{grown}} - s S_{\\text{grown}} = S_{\\text{grown}}(1 - s)$$\n我们被要求求解收缩分数 $s$。我们可以重排此方程来解出 $s$：\n$$1 - s = \\frac{S_{\\text{hist}}}{S_{\\text{grown}}}$$\n$$s = 1 - \\frac{S_{\\text{hist}}}{S_{\\text{grown}}}$$\n现在，我们可以代入 $S_{\\text{grown}}$ 和 $S$ 的表达式，以获得一个用主要给定值表示 $s$ 的单一公式：\n$$s = 1 - \\frac{S_{\\text{hist}}}{S(1 + \\gamma)} = 1 - \\frac{S_{\\text{hist}}}{uT(1 + \\gamma)}$$\n使用给定值 $S_{\\text{hist}} = 130 \\text{ µm}$ 和先前计算出的值 $S_{\\text{grown}} = 151.2 \\text{ µm}$：\n$$s = 1 - \\frac{130 \\text{ µm}}{151.2 \\text{ µm}}$$\n$$s = 1 - 0.859788...$$\n$$s \\approx 0.140211...$$\n问题要求将最终答案四舍五入至三位有效数字。\n$$s \\approx 0.140$$", "answer": "$$\\boxed{0.140}$$", "id": "4939470"}, {"introduction": "生物振荡器，如分割时钟，必须在多变的环境条件下稳定运行，以确保发育的精确性。本练习引入了一个关键的生物物理学概念——温度系数 $Q_{10}$，用于量化分割时钟的速率对温度的敏感性 [@problem_id:4939459]。通过计算 $Q_{10}$ 值，你可以评估该时钟是否具有“温度补偿”特性，这是生物节律鲁棒性的一个核心特征。", "problem": "在脊椎动物的体节发生过程中，分节时钟是体节前中胚层中的一个组织水平的振荡过程，它周期性地触发体节的形成。该时钟的周期用 $P$ 表示，是连续振荡峰值之间的时间，相应的分节速率为 $k$，根据定义 $k = \\frac{1}{P}$。生物速率过程中温度敏感性的一个广泛使用的描述符是温度系数 $Q_{10}$，其定义为速率随温度变化的规律遵循 $k(T) = k(T_{0})\\,Q_{10}^{\\frac{T - T_{0}}{10}}$，其中 $T$ 和 $T_{0}$ 是以摄氏度为单位的温度，$Q_{10}$ 是无量纲的。\n\n将来自鸡胚的体节前中胚层外植体在两个受控温度下进行培养。在 $T_{1} = 37.5^{\\circ}\\mathrm{C}$ 时，测得的分节时钟平均周期为 $P_{1} = 90\\,\\mathrm{min}$。在 $T_{2} = 41.0^{\\circ}\\mathrm{C}$ 时，测得的平均周期为 $P_{2} = 84\\,\\mathrm{min}$。\n\n使用以上定义，推导一个用 $k_{1}$、$k_{2}$、$T_{1}$ 和 $T_{2}$ 表示 $Q_{10}$ 的表达式，然后根据这些数据计算 $Q_{10}$ 的数值。根据计算出的 $Q_{10}$ 值，简要说明分节时钟在此温度范围内是否表现出温度补偿（完全补偿对应于 $Q_{10}$ 非常接近 $1$）。\n\n报告最终的 $Q_{10}$ 值，该值为无量纲数，并四舍五入至三位有效数字。", "solution": "首先将对问题进行验证，以确保其科学上可靠、提法恰当且客观。\n\n### 步骤1：问题验证\n\n从问题陈述中逐字提取已知条件：\n-   分节时钟的周期用 $P$ 表示。\n-   分节速率为 $k$，其中 $k = \\frac{1}{P}$。\n-   温度系数 $Q_{10}$ 由关系式 $k(T) = k(T_{0})\\,Q_{10}^{\\frac{T - T_{0}}{10}}$ 定义。\n-   实验条件1：温度 $T_{1} = 37.5^{\\circ}\\mathrm{C}$，周期 $P_{1} = 90\\,\\mathrm{min}$。\n-   实验条件2：温度 $T_{2} = 41.0^{\\circ}\\mathrm{C}$，周期 $P_{2} = 84\\,\\mathrm{min}$。\n-   任务要求：\n    1.  一个用 $k_{1}$、$k_{2}$、$T_{1}$ 和 $T_{2}$ 表示 $Q_{10}$ 的表达式。\n    2.  根据这些数据计算 $Q_{10}$ 的数值，并四舍五入至三位有效数字。\n    3.  关于温度补偿的简要说明，其中完全补偿意味着 $Q_{10}$ 非常接近 $1$。\n\n### 步骤2：使用提取的已知条件进行验证\n\n根据验证标准对问题进行评估。\n-   **科学依据充分：**该问题设置在脊椎动物体节发生的背景下，这是发育生物学中一个成熟的领域。分节时钟是一个真实存在且被广泛研究的生物振荡器。$Q_{10}$ 温度系数是生理学和生物物理学中用于描述速率过程温度依赖性的标准、广泛使用的度量。所提供的温度值和周期时长对于鸡胚实验是符合实际的。温度补偿的概念是研究生物节律的核心。因此，该问题在科学上是合理的。\n-   **提法恰当：**该问题为 $Q_{10}$ 提供了一个定义方程和两个数据点 $(T_1, P_1)$ 和 $(T_2, P_2)$。这构成了一套完整的信息，足以确定唯一的未知参数 $Q_{10}$。问题是精确的，并能导出一个唯一、稳定且有意义的解。\n-   **客观性：**该问题使用精确的定量语言和既定的科学定义进行陈述。它没有主观论断或模糊不清之处。\n\n该问题不存在科学上不合理、信息缺失或逻辑矛盾等任何缺陷。\n\n### 步骤3：结论与行动\n\n该问题有效。将提供一个完整、有理有据的解答。\n\n### 求解推导\n\n分析始于温度系数 $Q_{10}$ 的定义：\n$$k(T) = k(T_{0})\\,Q_{10}^{\\frac{T - T_{0}}{10}}$$\n该方程将一个过程在温度 $T$ 下的速率 $k$ 与其在参考温度 $T_{0}$ 下的速率关联起来。我们有两个数据点 $(T_1, P_1)$ 和 $(T_2, P_2)$。首先，我们必须使用给定的定义 $k = \\frac{1}{P}$ 将周期 $P$ 转换为速率 $k$。\n在温度 $T_1$ 下的速率为 $k_1 = \\frac{1}{P_1}$。\n在温度 $T_2$ 下的速率为 $k_2 = \\frac{1}{P_2}$。\n\n我们可以用这两个数据点来建立一个关系。让我们将第一个实验条件设为参考状态，即 $T_0 = T_1$ 和 $k(T_0) = k_1$。然后，对于第二个条件，我们有 $T = T_2$ 和 $k(T) = k_2$。将这些代入定义方程得到：\n$$k_2 = k_1\\,Q_{10}^{\\frac{T_2 - T_1}{10}}$$\n我们的第一个目标是推导一个用 $k_1$、$k_2$、$T_1$ 和 $T_2$ 表示 $Q_{10}$ 的表达式。为此，我们重新排列方程以分离出 $Q_{10}$。\n首先，两边同除以 $k_1$：\n$$\\frac{k_2}{k_1} = Q_{10}^{\\frac{T_2 - T_1}{10}}$$\n为了解出 $Q_{10}$，我们将方程两边同时取指数的倒数次幂，即 $\\frac{10}{T_2 - T_1}$ 次幂：\n$$Q_{10} = \\left(\\frac{k_2}{k_1}\\right)^{\\frac{10}{T_2 - T_1}}$$\n这就是所要求的用速率和温度表示 $Q_{10}$ 的表达式。\n\n任务的第二部分是计算 $Q_{10}$ 的数值。我们已知的是周期 $P_1$ 和 $P_2$，而不是速率。我们可以将速率的定义代入我们的 $Q_{10}$ 表达式中。\n速率之比为：\n$$\\frac{k_2}{k_1} = \\frac{1/P_2}{1/P_1} = \\frac{P_1}{P_2}$$\n将此代入 $Q_{10}$ 的表达式中得到：\n$$Q_{10} = \\left(\\frac{P_1}{P_2}\\right)^{\\frac{10}{T_2 - T_1}}$$\n现在，我们可以代入给定的数值：\n-   $P_1 = 90\\,\\mathrm{min}$\n-   $P_2 = 84\\,\\mathrm{min}$\n-   $T_1 = 37.5^{\\circ}\\mathrm{C}$\n-   $T_2 = 41.0^{\\circ}\\mathrm{C}$\n\n温差为 $\\Delta T = T_2 - T_1 = 41.0 - 37.5 = 3.5^{\\circ}\\mathrm{C}$。\n周期之比为 $\\frac{P_1}{P_2} = \\frac{90}{84}$。\n\n将这些值代入 $Q_{10}$ 的方程中：\n$$Q_{10} = \\left(\\frac{90}{84}\\right)^{\\frac{10}{3.5}}$$\n现在，我们计算数值。分数 $\\frac{90}{84}$ 可化简为 $\\frac{15}{14}$。指数为 $\\frac{10}{3.5} = \\frac{100}{35} = \\frac{20}{7}$。\n$$Q_{10} = \\left(\\frac{15}{14}\\right)^{\\frac{20}{7}}$$\n计算该值：\n$$Q_{10} \\approx (1.07142857)^{\\frac{20}{7}} \\approx (1.07142857)^{2.85714285} \\approx 1.218554$$\n问题要求答案四舍五入到三位有效数字。前三位有效数字是 $1.21$。第四位数字是 $8$，所以我们将第三位数字向上取整。\n$$Q_{10} \\approx 1.22$$\n\n任务的最后一部分是评论温度补偿。温度补偿是指使生物过程对温度变化相对不敏感的机制。完全补偿对应于 $Q_{10}$ 值恰好为 $1$，意味着速率不随温度变化。计算出的值为 $Q_{10} \\approx 1.22$，这表明温度每升高 $10^{\\circ}\\mathrm{C}$，分节时钟的速率大约增加 $1.22$ 倍。由于这个值不接近 $1$，因此分节时钟在这个温度范围内没有表现出强的温度补偿。它显示出中等程度的温度敏感性，这在许多没有被特别补偿的生物过程中是很常见的。", "answer": "$$\\boxed{1.22}$$", "id": "4939459"}, {"introduction": "为了真正理解分割时钟的起源，我们需要从静态计算深入到动态模拟。分割时钟源于细胞内复杂的基因调控网络，其中延迟负反馈是其核心驱动机制。本练习将指导你构建一个基因振荡器的计算模型，让你能够亲眼观察并“操控”一个虚拟的分割时钟 [@problem_id:4939387]。通过调整时间延迟 $\\tau$ 或蛋白质降解率 $\\delta$ 等参数，你将直观地感受到这些因素如何决定振荡的产生、消失及其周期，从而对该系统的动态行为建立深刻的理解。", "problem": "您的任务是设计并实现一个数值实验，以研究延迟负反馈基因调控回路如何产生构成体节发生中分节时钟基础的振荡，以及降解速率或延迟时间的变化如何影响这些振荡的存在与特性。请使用一个与生物学动机一致的、最小化的延迟微分方程模型，该模型需符合分子生物学的中心法则（转录产生信使核糖核酸（mRNA），翻译产生蛋白质），并与得到充分支持的观察结果一致，即 hairy 和 enhancer of split (HES) 家族基因通过延迟负反馈抑制自身的转录。\n\n出发点与定义：\n- 令 $M(t)$ 表示 mRNA 水平，$P(t)$ 表示蛋白质水平。\n- 转录过程受到蛋白质的抑制，延迟为 $t - \\tau$，这代表了诸如转录、剪接、翻译、转运和翻译后修饰等累积过程。\n- 延迟负反馈抑制由一个指数为 $n$ 的希尔函数（Hill function）描述。\n- 降解是一级反应，mRNA 和蛋白质的降解速率常数分别为 $\\delta_m$ 和 $\\delta$。\n- 从 mRNA 到蛋白质的翻译以速率常数 $k$ 进行，最大 mRNA 转录速率为 $\\alpha$。\n\n模型方程：\n$$\\frac{dM}{dt} = \\frac{\\alpha}{1 + \\left[P(t - \\tau)\\right]^n} - \\delta_m M(t),$$\n$$\\frac{dP}{dt} = k\\,M(t) - \\delta\\,P(t).$$\n\n要求：\n1. 实现一个能够处理延迟项 $P(t - \\tau)$ 的数值积分方案，无需使用外部文件或用户输入。您可以使用离散环形缓冲区或等效方法来近似延迟。使用固定的时间步长 $dt$，并通过选择相对于存在的最快速率而言足够小的 $dt$ 来确保数值稳定性。\n2. 设计一种振荡检测方法，该方法在给定指定分析窗口内的模拟蛋白质时间序列后，返回：\n   - 一个布尔值，指示是否存在持续振荡，以及\n   - 一个浮点数，给出振荡的平均周期（以秒为单位）；如果存在振荡，则返回周期值，否则返回 $0.0$。\n   持续振荡应通过在瞬态过程后检测到多个峰值，并要求振幅（最大值减去最小值）超过一个小的正阈值来确定。周期应计算为分析窗口内峰间间隔的平均值（以秒为单位）。\n3. 对延迟 $\\tau$ 进行参数扫描，通过找出能够检测到持续振荡的最小测试 $\\tau$ 值来估计振荡的起始点（一个实际的分岔点）。如果所有测试的延迟都未产生振荡，则分岔点估计值返回 $0.0$。\n4. 在调节蛋白质降解速率 $\\delta$ 或延迟 $\\tau$ 的类实验扰动下，验证振荡特性。\n\n物理与数值单位：\n- 时间单位必须是秒。周期和延迟必须以秒为单位，作为浮点数报告。\n- 所有布尔值输出必须是字面量 $True$ 或 $False$。\n\n数值方法约束：\n- 积分使用固定时间步长 $dt = 1.0$ 秒。\n- 模拟总时长为 $T_{\\text{total}} = 20000.0$ 秒。\n- 丢弃最初的 $5000.0$ 秒作为瞬态；在剩余的窗口中分析振荡。\n- 将 $M(0)$ 和 $P(0)$ 初始化为小的正值，并在 $t \\in [-\\tau, 0)$ 上对 $P(t)$ 使用恒定的历史前值。\n\n测试套件：\n使用以下参数集，每个都以 $\\left(\\alpha, \\delta_m, k, \\delta, n, \\tau\\right)$ 的形式定义，时间单位为秒，速率单位为秒的倒数：\n- 测试 $1$ (基准振荡状态): $\\alpha = 0.01$, $\\delta_m = 0.001$, $k = 0.0001$, $\\delta = 0.000577$, $n = 4$, $\\tau = 1200.0$。以浮点数形式输出平均振荡周期（秒）。\n- 测试 $2$ (边界，无延迟): 与测试 $1$ 相同，但 $\\tau = 0.0$。输出一个布尔值，指示是否检测到持续振荡。\n- 测试 $3$ (扰动，更快降解): 与测试 $1$ 相同，但 $\\delta = 2 \\times 0.000577$。以浮点数形式输出平均振荡周期（秒）；如果不振荡，则输出 $0.0$。\n- 测试 $4$ (通过延迟扫描估算分岔点): 固定 $\\alpha = 0.01$, $\\delta_m = 0.001$, $k = 0.0001$, $\\delta = 0.000577$, $n = 4$，并在列表 $\\left[0.0, 300.0, 600.0, 900.0, 1200.0, 1500.0, 1800.0\\right]$ 上扫描 $\\tau$。从此列表中输出能产生持续振荡的最小 $\\tau$ 值（秒）；如果均未产生，则输出 $0.0$。\n- 测试 $5$ (扰动，更慢降解): 与测试 $1$ 相同，但 $\\delta = 0.5 \\times 0.000577$。以浮点数形式输出平均振荡周期（秒）；如果不振荡，则输出 $0.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试 1 到 5 的顺序包含结果。该列表必须包含与上述规定输出相对应的 $\\left[\\text{float}, \\text{boolean}, \\text{float}, \\text{float}, \\text{float}\\right]$ 类型的值。例如，一个有效的输出格式为 $\\left[1800.0,False,1500.0,900.0,2100.0\\right]$。", "solution": "问题陈述已经过验证，并被确定为计算系统生物学领域一个适定且有科学依据的任务。它要求对一个用于遗传振荡子的标准延迟微分方程（DDE）模型进行数值模拟和分析，这与发育生物学中分节时钟的研究相关。其参数、约束和目标定义清晰，且在计算上是可行的。\n\n### 模型：延迟负反馈回路\n\n问题的核心是一个双变量模型，描述了信使 RNA (mRNA) 浓度（表示为 $M(t)$）和蛋白质浓度（$P(t)$）的动力学。该模型是一个耦合延迟微分方程组：\n\n$$\n\\frac{dM}{dt} = \\frac{\\alpha}{1 + \\left[P(t - \\tau)\\right]^n} - \\delta_m M(t)\n$$\n$$\n\\frac{dP}{dt} = k\\,M(t) - \\delta\\,P(t)\n$$\n\n这些方程概括了分子生物学的基本原理：\n1.  **转录**：$\\frac{dM}{dt}$ 方程中的第一项模拟了 mRNA 的产生。产生速率由蛋白质 $P$ 调控。最大转录速率为 $\\alpha$。\n2.  **抑制**：蛋白质 $P$ 抑制其自身基因的转录。这种负反馈由希尔函数 $\\frac{1}{1 + [P]^n}$ 描述，其中 $n$ 是希尔系数，决定了抑制的陡峭程度。更高的 $n$ 值意味着更接近开关式的响应。\n3.  **时间延迟**：抑制不是瞬时发生的。项 $P(t - \\tau)$ 表示在时间 $t$ 的转录速率是由过去某个时间 $t - \\tau$ 的蛋白质浓度决定的。这个延迟 $\\tau$ 包含了转录、翻译和分子转运所需的时间。它是能够诱发振荡的关键因素。\n4.  **降解**：mRNA 和蛋白质都会降解，这被建模为一级过程，速率常数分别为 $\\delta_m$ 和 $\\delta$。项 $-\\delta_m M(t)$ 和 $-\\delta P(t)$ 代表了这一清除过程。\n5.  **翻译**：$\\frac{dP}{dt}$ 方程中的项 $k\\,M(t)$ 模拟了从 mRNA 模板合成蛋白质的过程，其发生速率与 mRNA 浓度成正比，速率常数为 $k$。\n\n### 数值解法策略\n\n为求解该 DDE 系统，我们采用一种固定时间步长的数值积分方案。\n\n**离散化与积分**\n我们使用前向欧拉法，这是一种直接且显式的时间步进格式。对于一个很小的时间步长 $dt$，系统在时间 $t+dt$ 的状态是根据其在时间 $t$ 的状态来近似的。给定时间步长 $dt = 1.0$ 秒，离散更新规则如下：\n$$\nM(t_i + dt) = M(t_i) + dt \\cdot \\left( \\frac{\\alpha}{1 + \\left[P(t_i - \\tau)\\right]^n} - \\delta_m M(t_i) \\right)\n$$\n$$\nP(t_i + dt) = P(t_i) + dt \\cdot (k\\,M(t_i) - \\delta\\,P(t_i))\n$$\n其中 $t_i = i \\cdot dt$，$i = 0, 1, 2, \\dots$。所选的时间步长 $dt=1.0$ 远小于系统的特征时间尺度（例如，$1/\\delta_m = 1000$ 秒），从而确保了给定参数下的数值稳定性。\n\n**处理时间延迟**\n项 $P(t_i - \\tau)$ 需要访问蛋白质浓度的历史数据。我们将把 $M(t)$ 和 $P(t)$ 的完整时间序列存储在数组中。在对应于时间 $t_i$ 的每一步 $i$ 中，延迟的蛋白质浓度是在过去的某个时间 $t_i - \\tau$ 找到的。对应的数组索引是 $j = i - \\tau/dt$。由于所提供的 $\\tau$ 值是 $dt$ 的整数倍，因此该索引 $j$ 将是一个整数。对于 $t_i - \\tau  0$ 的时间点，我们必须查阅系统的历史前值。\n\n**初始与历史条件**\n系统在 $t=0$ 时以小的正浓度进行初始化，以防止除以零并表示一个基底状态。我们设置 $M(0) = 1.0$ 和 $P(0) = 1.0$。对于历史前值，即 $t  0$ 的情况，问题指定了 $P(t)$ 为一个恒定值。我们将对所有 $t \\in [-\\tau, 0)$ 使用 $P(t) = P(0) = 1.0$ 的历史值。这是通过在延迟查找索引 $j$ 为负时使用 $P(0)$ 的值来实现的。\n\n### 振荡分析\n\n为确定系统是否表现出持续振荡，我们在一个指定的窗口内分析蛋白质时间序列 $P(t)$，并丢弃初始的瞬态过程。\n\n1.  **分析窗口**：模拟总时长为 $T_{\\text{total}} = 20000.0$ 秒。我们丢弃最初的 $5000.0$ 秒，让系统稳定到其长期行为（稳定的稳态或极限环），并在时间区间 $[5000.0, 20000.0]$ 上进行分析。\n\n2.  **振荡检测逻辑**：\n    *   **振幅阈值**：振荡的一个主要指标是浓度的显著变化。我们计算峰谷振幅 $A = \\max(P_{\\text{window}}) - \\min(P_{\\text{window}})$。为区分真实振荡与数值噪声或阻尼振荡，我们要求此振幅超过一个阈值。相对于预期的稳态浓度，选择 $A > 0.1$ 的阈值是一个合理的小的正值。\n    *   **峰值识别**：我们使用一个寻峰算法，特别是 `scipy.signal.find_peaks`，来识别蛋白质时间序列中的局部最大值。一个关键参数是 `prominence`（突出度），它衡量一个峰值从其周围基线中突出的程度。为滤除微小的噪声峰，我们将要求的突出度设置为至少为总振幅 $A$ 的 $10\\%$。\n    *   **持续振荡标准**：为使振荡被认为是“持续的”，我们要求在分析窗口内检测到至少 3 个显著的峰值。这确保我们至少有两个完整的周期，从而可以计算出有意义的平均周期。\n\n3.  **周期计算**：如果满足持续振荡的标准，振荡周期将计算为连续检测到的峰值之间的平均时间差。如果未检测到振荡，则周期报告为 $0.0$。\n\n### 测试用例的执行\n已建立的数值和分析框架被应用于问题中定义的五个测试用例中的每一个。一个主函数负责协调每个参数集的模拟和分析，收集所需的特定输出：平均周期、指示振荡是否存在的布尔值，或来自参数扫描的分岔点。然后将结果格式化为指定的列表结构作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and analysis for all test cases.\n    \"\"\"\n\n    def detect_oscillations(time_series, dt, analysis_start_time):\n        \"\"\"\n        Detects sustained oscillations in a time series and calculates their period.\n\n        Args:\n            time_series (np.ndarray): The data to analyze (e.g., protein concentration).\n            dt (float): The time step of the simulation.\n            analysis_start_time (float): Time to start the analysis from (to discard transients).\n\n        Returns:\n            tuple: A tuple containing:\n                - bool: True if sustained oscillations are detected, False otherwise.\n                - float: The mean oscillation period in seconds, or 0.0 if not oscillating.\n        \"\"\"\n        analysis_start_idx = int(analysis_start_time / dt)\n        analysis_window = time_series[analysis_start_idx:]\n\n        if len(analysis_window)  3:\n            return False, 0.0\n\n        amplitude = np.max(analysis_window) - np.min(analysis_window)\n        \n        # Amplitude threshold for meaningful oscillation\n        amplitude_threshold = 0.1\n        if amplitude  amplitude_threshold:\n            return False, 0.0\n\n        # Find peaks with a prominence relative to the signal amplitude\n        # A minimal distance helps avoid detecting multiple peaks on a noisy crest.\n        # A distance of 100 steps (100 seconds) is safe.\n        prominence_threshold = 0.1 * amplitude\n        peaks, _ = signal.find_peaks(analysis_window, \n                                     prominence=prominence_threshold,\n                                     distance=int(100/dt))\n\n        # Require at least 3 peaks for a \"sustained\" oscillation and robust period calculation\n        if len(peaks)  3:\n            return False, 0.0\n\n        # Calculate mean period from inter-peak intervals\n        peak_intervals = np.diff(peaks) * dt\n        mean_period = np.mean(peak_intervals)\n\n        return True, mean_period\n\n    def run_simulation(alpha, delta_m, k, delta, n, tau, T_total, dt, analysis_start_time):\n        \"\"\"\n        Runs a single simulation of the DDE model.\n\n        Args:\n            (alpha, delta_m, k, delta, n, tau): Model parameters.\n            T_total (float): Total simulation time.\n            dt (float): Time step.\n            analysis_start_time (float): Start time for analysis.\n\n        Returns:\n            tuple: (is_oscillatory, mean_period) from detect_oscillations.\n        \"\"\"\n        num_steps = int(T_total / dt)\n        M = np.zeros(num_steps + 1)\n        P = np.zeros(num_steps + 1)\n\n        # Initial conditions: small positive values\n        M[0] = 1.0\n        P[0] = 1.0\n        P_history_val = 1.0 # Constant pre-history\n\n        delay_steps = int(tau / dt)\n\n        # Main integration loop (Forward Euler)\n        for i in range(num_steps):\n            delay_idx = i - delay_steps\n            P_delayed = P[delay_idx] if delay_idx = 0 else P_history_val\n\n            dM_dt = alpha / (1.0 + P_delayed**n) - delta_m * M[i]\n            dP_dt = k * M[i] - delta * P[i]\n\n            M[i + 1] = M[i] + dt * dM_dt\n            P[i + 1] = P[i] + dt * dP_dt\n\n        is_oscillatory, mean_period = detect_oscillations(P, dt, analysis_start_time)\n        return is_oscillatory, mean_period\n\n    # Numerical settings from the problem\n    DT = 1.0\n    T_TOTAL = 20000.0\n    ANALYSIS_START = 5000.0\n\n    # Baseline parameters\n    base_params = {\n        'alpha': 0.01,\n        'delta_m': 0.001,\n        'k': 0.0001,\n        'delta': 0.000577,\n        'n': 4,\n        'tau': 1200.0\n    }\n\n    results = []\n\n    # --- Test 1: Baseline oscillatory regime ---\n    params1 = base_params.copy()\n    _, period1 = run_simulation(**params1, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n    results.append(period1)\n\n    # --- Test 2: Boundary, no delay ---\n    params2 = base_params.copy()\n    params2['tau'] = 0.0\n    is_oscillatory2, _ = run_simulation(**params2, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n    results.append(is_oscillatory2)\n    \n    # --- Test 3: Perturbation, faster degradation ---\n    params3 = base_params.copy()\n    params3['delta'] *= 2.0\n    _, period3 = run_simulation(**params3, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n    results.append(period3)\n\n    # --- Test 4: Bifurcation estimate via delay sweep ---\n    params4_base = base_params.copy()\n    tau_sweep = [0.0, 300.0, 600.0, 900.0, 1200.0, 1500.0, 1800.0]\n    bifurcation_tau = 0.0\n    for tau_val in tau_sweep:\n        params4 = params4_base.copy()\n        params4['tau'] = tau_val\n        is_oscillatory, _ = run_simulation(**params4, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n        if is_oscillatory:\n            bifurcation_tau = tau_val\n            break\n    results.append(bifurcation_tau)\n\n    # --- Test 5: Perturbation, slower degradation ---\n    params5 = base_params.copy()\n    params5['delta'] *= 0.5\n    _, period5 = run_simulation(**params5, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n    results.append(period5)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "4939387"}]}