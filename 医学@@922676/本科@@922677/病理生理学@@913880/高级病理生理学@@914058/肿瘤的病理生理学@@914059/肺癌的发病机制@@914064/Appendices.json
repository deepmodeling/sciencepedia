{"hands_on_practices": [{"introduction": "本练习旨在探讨细胞衰老这一基本概念及其与癌症的联系。正常细胞拥有一个内在的“时钟”——端粒，它会随着每次细胞分裂而缩短。这项练习要求你建立一个简单的数学模型，来计算细胞在此过程中的最大复制寿命。通过这个推导，你将对“端粒危机”有一个定量的理解，这是癌前细胞为实现永生化（癌症的一大特征）所必须跨越的关键障碍。[@problem_id:4819299]", "problem": "在肺癌的发病机制中，一个关键的早期事件是，当端粒酶逆转录酶 (TERT) 尚未重新激活时，增殖中的肺上皮克隆会发生端粒侵蚀。根据分子生物学中心法则和公认的线性染色体末端复制问题，每次细胞分裂都无法完全复制染色体末端，导致端粒逐渐缩短。在没有代偿性端粒延长的情况下，极短的端粒会触发DNA损伤反应 (DDR)，激活肿瘤抑制通路（例如p53蛋白），从而强制细胞衰老或凋亡，限制克隆扩增。考虑肺中的一个肺泡上皮克隆，其端粒酶处于非活性状态。由于末端复制和相关的氧化应激，每个染色体臂的平均端粒长度在每次分裂后确定性地减少一个恒定量 $\\,\\Delta\\,$，其初始平均端粒长度为 $\\,L_0\\,$。设 $\\,L_c\\,$ 表示能可靠地发生DDR介导的细胞周期停滞时的最小平均端粒长度。假设没有端粒延长机制被激活（没有TERT，没有端粒替代性延长），并通过将平均端粒长度建模为每次分裂后的线性减少来忽略随机波动。\n\n仅使用这些基本事实和定义，推导该克隆在达到 $\\,L_c\\,$ 之前可以经历的最大有丝分裂次数 $\\,L\\,$ 的闭式表达式。以 $\\,L_0\\,$, $\\,L_c\\,$ 和 $\\,\\Delta\\,$ 的单个符号表达式形式提供您的答案。不要代入数值。将最终的 $\\,L\\,$ 表示为无量纲的分裂次数，不要包含单位。", "solution": "分子生物学中心法则确立了DNA在细胞周期中进行复制，而真核生物线性染色体的末端复制问题导致每次分裂时端粒末端的合成不完整。在没有端粒酶逆转录酶 (TERT) 或端粒替代性延长的情况下，这会导致每次分裂后端粒的持续缩短。设经过 $\\,n\\,$ 次分裂后的平均端粒长度表示为 $\\,T(n)\\,$。假设规定了初始平均端粒长度 $\\,T(0) = L_0\\,$，每次分裂的确定性减少量 $\\,\\Delta > 0\\,$，以及DNA损伤反应 (DDR) 激活p53依赖性衰老或凋亡的临界阈值 $\\,L_c\\,$。在线性损耗模型下，平均端粒长度随离散分裂次数变化的动力学为\n$$\nT(n) \\;=\\; L_0 - n\\,\\Delta .\n$$\n复制寿命 $\\,L\\,$ 被定义为在 $\\,T(n)\\,$ 达到临界阈值 $\\,L_c\\,$ 之前可以发生的最大分裂次数。阈值条件由下式给出\n$$\nT(L) \\;=\\; L_0 - L\\,\\Delta \\;=\\; L_c .\n$$\n求解这个关于 $\\,L\\,$ 的线性关系式可得\n$$\nL \\;=\\; \\frac{L_0 - L_c}{\\Delta} .\n$$\n这个结果直接源于线性减少模型和DDR激活临界长度的定义。在实践中，$\\,L\\,$ 代表分裂的次数，因此是离散的；可以考虑对此值取底（向下取整）以强制其为整数。然而，由于问题要求在确定性线性模型下，给出预期最大分裂次数的闭式符号表达式，因此解析表达式\n$$\n\\frac{L_0 - L_c}{\\Delta}\n$$\n是最终的适当形式。", "answer": "$$\\boxed{\\frac{L_0 - L_c}{\\Delta}}$$", "id": "4819299"}, {"introduction": "从细胞层面转向群体层面，我们知道环境和生活方式因素是导致癌症初始损伤的驱动力。本练习将使用一个在流行病学中广泛应用的工具——逻辑回归，来量化吸烟和慢性病等肺癌主要风险因素的影响。你将计算调整后的比值比，从而学习如何解读统计模型，以理解不同风险因素是如何共同影响肺癌发病可能性的。[@problem_id:4819281]", "problem": "一项关于肺癌发生的队列研究评估了累积烟草暴露和慢性气道炎症如何影响罹患肺癌的概率。与烟草致癌物所致的DNA损伤和气道中持续性炎症信号传导之间的机理联系一致，该研究将肺癌概率建模为累积吸烟暴露量（以包年为单位）和是否存在慢性阻塞性肺疾病（COPD；Chronic Obstructive Pulmonary Disease）的函数。\n\n假设该研究使用带有logit链接函数的逻辑斯谛回归，其中肺癌的对数比值被建模为预测变量的线性组合。令二元指示变量 $C$ 表示COPD状态，其中若存在COPD则 $C=1$，否则 $C=0$。令 $X$ 表示以包年为单位的累积暴露量。拟合的模型为\n$$\\ln\\!\\left(\\frac{P(\\text{cancer}\\,|\\,X,C)}{1-P(\\text{cancer}\\,|\\,X,C)}\\right)=\\alpha+\\beta_{p}\\,X+\\beta_{c}\\,C+\\beta_{pc}\\,(X\\cdot C),$$\n从队列中估计出的系数为 $\\alpha=-6.00$，$\\beta_{p}=0.045$（每包年），$\\beta_{c}=0.900$，以及 $\\beta_{pc}=0.010$（每包年的交互作用）。\n\n仅使用公认的比值、比值比和逻辑斯谛链接函数定义，计算一个 $X=30$ 包年且 $C=1$ 的个体与一个 $X=0$ 且 $C=0$ 的参照个体相比，其罹患肺癌的调整后比值比。将您的答案四舍五入到 $4$ 位有效数字。以无量纲比率的形式表示您的答案；不要包含任何单位或百分号。", "solution": "该问题要求计算一个具有特定风险特征的个体与一个参照个体相比，其罹患肺癌的调整后比值比。预测变量与结果之间的关系由一个逻辑斯谛回归模型定义。\n\n令 $P$ 表示一个个体在给定其累积吸烟暴露量 $X$（以包年为单位）和其COPD状态 $C$（$C=1$ 表示存在，$C=0$ 表示不存在）的情况下罹患肺癌的概率。罹患肺癌的比值（Odds）定义为事件发生的概率与事件不发生的概率之比：\n$$ \\text{Odds} = \\frac{P(\\text{cancer}\\,|\\,X,C)}{1-P(\\text{cancer}\\,|\\,X,C)} $$\n所提供的逻辑斯谛回归模型将比值的自然对数（对数比值或logit）指定为预测变量的线性函数：\n$$ \\ln(\\text{Odds}) = \\alpha+\\beta_{p}\\,X+\\beta_{c}\\,C+\\beta_{pc}\\,(X\\cdot C) $$\n模型的估计系数为 $\\alpha = -6.00$，$\\beta_{p} = 0.045$，$\\beta_{c} = 0.900$，以及 $\\beta_{pc} = 0.010$。\n\n我们需要计算比较两个个体的比值比（OR）：\n1.  一个病例个体，其 $X_{1} = 30$ 包年且患有COPD，因此 $C_{1} = 1$。\n2.  一个参照个体，其 $X_{2} = 0$ 包年且没有COPD，因此 $C_{2} = 0$。\n\n比值比是病例个体的比值（$\\text{Odds}_{1}$）与参照个体的比值（$\\text{Odds}_{2}$）之比：\n$$ \\text{OR} = \\frac{\\text{Odds}_{1}}{\\text{Odds}_{2}} $$\n从逻辑斯谛模型计算比值比的一个更直接的方法是处理对数比值。比值比的自然对数是两个个体对数比值之差：\n$$ \\ln(\\text{OR}) = \\ln\\left(\\frac{\\text{Odds}_{1}}{\\text{Odds}_{2}}\\right) = \\ln(\\text{Odds}_{1}) - \\ln(\\text{Odds}_{2}) $$\n使用模型方程，我们可以写出每个个体的对数比值：\n$$ \\ln(\\text{Odds}_{1}) = \\alpha + \\beta_{p}X_{1} + \\beta_{c}C_{1} + \\beta_{pc}(X_{1}C_{1}) $$\n$$ \\ln(\\text{Odds}_{2}) = \\alpha + \\beta_{p}X_{2} + \\beta_{c}C_{2} + \\beta_{pc}(X_{2}C_{2}) $$\n将这些表达式代入 $\\ln(\\text{OR})$ 的方程中，得到：\n$$ \\ln(\\text{OR}) = \\left(\\alpha + \\beta_{p}X_{1} + \\beta_{c}C_{1} + \\beta_{pc}(X_{1}C_{1})\\right) - \\left(\\alpha + \\beta_{p}X_{2} + \\beta_{c}C_{2} + \\beta_{pc}(X_{2}C_{2})\\right) $$\n截距项 $\\alpha$ 消去，我们可以按系数对剩余项进行分组：\n$$ \\ln(\\text{OR}) = \\beta_{p}(X_{1} - X_{2}) + \\beta_{c}(C_{1} - C_{2}) + \\beta_{pc}(X_{1}C_{1} - X_{2}C_{2}) $$\n现在，我们代入病例个体和参照个体的值：$X_{1}=30$，$C_{1}=1$，$X_{2}=0$ 和 $C_{2}=0$。\n$$ \\ln(\\text{OR}) = \\beta_{p}(30 - 0) + \\beta_{c}(1 - 0) + \\beta_{pc}((30 \\cdot 1) - (0 \\cdot 0)) $$\n$$ \\ln(\\text{OR}) = 30\\beta_{p} + \\beta_{c} + 30\\beta_{pc} $$\n接下来，我们代入系数的数值：$\\beta_{p}=0.045$，$\\beta_{c}=0.900$，以及 $\\beta_{pc}=0.010$。\n$$ \\ln(\\text{OR}) = 30(0.045) + 0.900 + 30(0.010) $$\n我们计算每一项：\n$$ 30 \\times 0.045 = 1.35 $$\n$$ 30 \\times 0.010 = 0.30 $$\n将这些值相加得到对数比值比：\n$$ \\ln(\\text{OR}) = 1.35 + 0.900 + 0.30 = 2.55 $$\n为了得到比值比，我们必须对对数比值比取指数：\n$$ \\text{OR} = \\exp(\\ln(\\text{OR})) = \\exp(2.55) $$\n计算该表达式得出：\n$$ \\text{OR} \\approx 12.80706048 $$\n问题要求答案四舍五入到 $4$ 位有效数字。前四位有效数字是 $1$、$2$、$8$ 和 $0$。第五位数字是 $7$，大于或等于 $5$，所以我们将第四位数字向上取整。\n$$ \\text{OR} \\approx 12.81 $$\n这是一个吸烟30包年且患有COPD的人与一个不吸烟且没有COPD的人相比，其罹患肺癌的调整后比值比。", "answer": "$$\\boxed{12.81}$$", "id": "4819281"}, {"introduction": "每个癌症的基因组都记录着一个用突变语言书写的故事。不同的致癌因素，如烟草烟雾或内源性细胞过程，会在DNA上留下独特的突变模式，即“突变印记”。这项高级计算练习将指导你完成突变印记分析，这是现代癌症基因组学的基石。通过编程实现一个算法来解析肿瘤的突变目录，你将学会如何识别塑造其演化历程的根本性突变过程。[@problem_id:4819271]", "problem": "肺肿瘤基因组可以通过三核苷酸背景下的单碱基替换计数来概括，形成一个$96$通道向量$x \\in \\mathbb{R}^{96}$，其条目为非负整数。在肺癌的发病机制中，不同的突变过程会留下特征模式，称为突变印记，可以表示为列向量$s_j \\in \\mathbb{R}^{96}$，其条目非负且总和为$1$。参考印记矩阵是$S \\in \\mathbb{R}^{96 \\times m}$，其列为$s_1, s_2, \\dots, s_m$。混合模型假设期望计数向量是一个非负线性组合$S w$，其中$w \\in \\mathbb{R}^{m}$具有非负条目（暴露度），而实际计数$x$则围绕此期望产生。\n\n基础生物学依据：突变过程在复制和修复过程中作用于脱氧核糖核酸（DNA）（中心法则），产生特征性替换模式。在肺癌中，烟草烟雾暴露会产生大分子加合物，有利于胞嘧啶到腺嘌呤的替换；而5-甲基胞嘧啶的内源性脱氨在CpG位点产生胞嘧啶到胸腺嘧啶的替换；胞苷脱氨酶，如Apolipoprotein B messenger ribonucleic acid Editing Catalytic Polypeptide-like (APOBEC)酶，在胸腺嘧啶-胞嘧啶（TpC）背景下产生替换簇。这些过程在大型队列研究中被可靠地观察到，并被编码为突变印记。\n\n对于非零向量$u, v \\in \\mathbb{R}^n$，余弦相似度定义为$c(u,v) = \\dfrac{u \\cdot v}{\\|u\\|_2 \\, \\|v\\|_2}$，其中$u \\cdot v$是点积，$\\|\\cdot\\|_2$是欧几里得范数。如果任一向量为零向量，为本题目的，定义$c(u,v) = 0$。从$x$和$S$估计$w$可以被看作是非负最小二乘问题：找到$w \\ge 0$以最小化$\\|x - S w\\|_2$。\n\n实现一个程序，给定$S$的一个确定性构建方法和一组观测计数向量$x$的测试套件，对每个测试用例执行以下操作：\n- 计算$x$与$S$的每个印记列向量$s_j$之间的余弦相似度。\n- 求解非负最小二乘问题以估计$w$，然后在$\\sum_{j=1}^{m} w_j > 0$时计算比例贡献$p = \\dfrac{w}{\\sum_{j=1}^{m} w_j}$，否则$p$为零向量。\n- 计算$x$与重构向量$\\hat{x} = S w$之间的余弦相似度。\n\n你的程序必须构建参考印记矩阵$S$，其中包含$m=4$个印记，分布在$96$个有序通道上，使用以下确定性的、有科学动机的规则集。使用映射\n$$\n\\mathrm{idx}(g,\\ell,r) = g \\cdot 16 + \\ell \\cdot 4 + r,\n$$\n通过三元组$(g, \\ell, r)$来索引这$96$个通道，其中$g \\in \\{0,1,2,3,4,5\\}$表示替换组，顺序为$[C>A, C>G, C>T, T>A, T>C, T>G]$，而$\\ell, r \\in \\{0,1,2,3\\}$则编码左右相邻的碱基，顺序为$[A, C, G, T]$。对于每个印记，首先在所有$96$个通道上设置基线权重$0.001$，然后按如下方式覆写选定通道，最后归一化每个印记，使其条目总和为$1$：\n- 印记$s_1$（衰老样，CpG位点上的胞嘧啶到胸腺嘧啶）：对于所有$\\ell \\in \\{0,1,2,3\\}$，设置$s_1[\\mathrm{idx}(2,\\ell,2)] = 0.02$（胞嘧啶到胸腺嘧啶，右侧相邻鸟嘌呤），对于其余的胞嘧啶到胸腺嘧啶通道（组$g=2$，其中$r \\in \\{0,1,3\\}$），设置$s_1[\\mathrm{idx}(2,\\ell,r)] = 0.005$。\n- 印记$s_2$（APOBEC样，TpC背景下的胞嘧啶到胸腺嘧啶）：对于组$g=2$且左侧相邻胸腺嘧啶$\\ell = 3$，为$r \\in \\{0,1,3\\}$设置$s_2[\\mathrm{idx}(2,3,r)] = 0.03$，并设置$s_2[\\mathrm{idx}(2,3,2)] = 0.01$。\n- 印记$s_3$（APOBEC样，TpC背景下的胞嘧啶到鸟嘌呤）：对于组$g=1$且左侧相邻胸腺嘧啶$\\ell = 3$，为$r \\in \\{0,1,3\\}$设置$s_3[\\mathrm{idx}(1,3,r)] = 0.03$，并设置$s_3[\\mathrm{idx}(1,3,2)] = 0.01$。\n- 印记$s_4$（烟草样，胞嘧啶到腺嘌呤）：对于组$g=0$，为所有$\\ell, r$设置$s_4[\\mathrm{idx}(0,\\ell,r)] = 0.02$，并额外强调$s_4[\\mathrm{idx}(0,2,0)] = 0.04$和$s_4[\\mathrm{idx}(0,2,3)] = 0.04$。\n\n通过确定性地混合印记并四舍五入到最近的整数来定义包含三个观测计数向量的测试套件：\n- 测试用例1：总负荷$N_1 = 1000$，混合比例$p^{(1)} = [0.55, 0.10, 0.05, 0.30]$。令$x^{(1)} = \\mathrm{round}\\!\\left( N_1 \\cdot S \\, p^{(1)} \\right)$。\n- 测试用例2：总负荷$N_2 = 500$，混合比例$p^{(2)} = [0.00, 1.00, 0.00, 0.00]$。令$x^{(2)} = \\mathrm{round}\\!\\left( N_2 \\cdot S \\, p^{(2)} \\right)$。\n- 测试用例3：总负荷$N_3 = 20$，混合比例$p^{(3)} = [0.00, 0.50, 0.50, 0.00]$。令$x^{(3)} = \\mathrm{round}\\!\\left( N_3 \\cdot S \\, p^{(3)} \\right)$。\n\n对于每个测试用例$i \\in \\{1,2,3\\}$，你的程序必须按以下顺序输出一个包含$9$个浮点数的列表：\n$$\n\\left[p_1^{(i)}, p_2^{(i)}, p_3^{(i)}, p_4^{(i)}, \\; c\\!\\left(x^{(i)}, \\hat{x}^{(i)}\\right), \\; c\\!\\left(x^{(i)}, s_1\\right), \\; c\\!\\left(x^{(i)}, s_2\\right), \\; c\\!\\left(x^{(i)}, s_3\\right), \\; c\\!\\left(x^{(i)}, s_4\\right)\\right],\n$$\n其中$p_j^{(i)}$是通过非负最小二乘法估计的比例贡献，$\\hat{x}^{(i)} = S w^{(i)}$是使用估计的暴露度$w^{(i)}$得到的重构向量。\n\n最终输出格式：你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素是对应于一个测试用例的$9$个浮点数的列表。例如，结构必须看起来像$[[\\dots],[\\dots],[\\dots]]$。角度不适用，也不涉及物理单位。所有数值输出必须表示为标准十进制表示法的浮点数。", "solution": "解决方案首先根据提供的规则构建必要的数据结构，然后应用标准的数值算法来解决核心估计问题。整个过程可以分为四个主要阶段：\n\n**1. 突变印记矩阵（$S$）的构建**\n\n问题要求构建一个参考印记矩阵$S \\in \\mathbb{R}^{96 \\times 4}$。该矩阵代表四种不同的突变过程，其中每一列$s_j$是关于$96$种可能的三核苷酸替换类型的概率分布。构建过程遵循一套确定性规则，反映了每种印记的生物学基础。\n\n这$96$个通道由一个三元组$(g, \\ell, r)$索引，分别代表替换组、左侧翼碱基和右侧翼碱基。到线性索引$k \\in \\{0, 1, \\dots, 95\\}$的映射由以下公式给出：\n$$\nk = \\mathrm{idx}(g,\\ell,r) = g \\cdot 16 + \\ell \\cdot 4 + r\n$$\n其中$g \\in \\{0,\\dots,5\\}$代表替换组$[C>A, C>G, C>T, T>A, T>C, T>G]$，而$\\ell, r \\in \\{0,\\dots,3\\}$代表碱基$[A, C, G, T]$。\n\n每个印记向量$s_j$的构建始于一个基线向量，其中所有$96$个条目都被初始化为一个小的权重$0.001$。然后根据模拟每个突变过程已知偏好的规则覆写特定通道。\n\n-   **印记$s_1$（衰老样）：** 此印记模拟了5-甲基胞嘧啶的自发脱氨，该过程主要发生在CpG二核苷酸处，导致胞嘧啶到胸腺嘧啶（$C>T$）的替换。规则通过增加$C>T$替换（组$g=2$）中右侧相邻碱基为鸟嘌呤（$r=2$）的权重来反映这一点。我们为所有左侧相邻碱基$\\ell$设置$s_1[\\mathrm{idx}(2,\\ell,2)] = 0.02$，并为其他$C>T$替换设置一个较小的权重$s_1[\\mathrm{idx}(2,\\ell,r)] = 0.005$。\n\n-   **印记$s_2$和$s_3$（APOBEC样）：** 这些印记模拟了APOBEC酶的活性，该酶优先在胸腺嘧啶-胞嘧啶（TpC）背景下使胞嘧啶脱氨。这导致$C>T$（组$g=2$）和$C>G$（组$g=1$）的替换。$s_2$和$s_3$的规则分别增加了组$g=2$和$g=1$中替换的权重，特别是在左侧相邻碱基为胸腺嘧啶（$\\ell=3$）的情况下。对于非CpG背景，权重设置为$0.03$，对于TpCpG背景，则设置为较低的$0.01$。\n\n-   **印记$s_4$（烟草样）：** 此印记捕获了烟草烟雾中诱变剂的影响，这些诱变剂导致大分子DNA加合物，从而引起高频率的$C>A$替换（组$g=0$）。规则通过为$C>A$组中的所有通道分配一个高权重$0.02$来模拟这一点，并进一步强调特定背景$\\mathrm{idx}(0,2,0)$和$\\mathrm{idx}(0,2,3)$（权重为$0.04$），分别对应于$G \\underline{C} A \\to G \\underline{A} A$和$G \\underline{C} T \\to G \\underline{A} T$的替换。\n\n最后，每个列向量$s_j$通过将其各项除以它们的总和来进行归一化，以确保它是一个有效的概率分布，其中$\\sum_{k=0}^{95} (s_j)_k = 1$。\n\n**2. 观测计数向量（$x^{(i)}$）的生成**\n\n生成了三个关于观测突变计数的合成测试用例$x^{(i)}$。这些用例通过取参考印记的线性组合，然后四舍五入到最近的整数来模拟离散的突变计数，从而模仿真实的肿瘤基因组。第$i$个观测向量生成如下：\n$$\nx^{(i)} = \\mathrm{round}\\!\\left( N_i \\cdot S \\, p^{(i)}_{\\text{true}} \\right)\n$$\n在这里，$N_i$是总突变负荷，$p^{(i)}_{\\text{true}}$是为测试用例$i$预定义好的各印记的比例贡献向量。这个生成过程提供了一个真实基准，可以用来对估计结果进行隐式比较。\n\n**3. 对每个观测向量的分析**\n\n对于每个生成的计数向量$x^{(i)}$，执行一系列计算步骤来解构其组成。\n\n-   **非负最小二乘（NNLS）：** 分析的核心是估计能够最佳解释观测计数$x^{(i)}$的暴露度向量$w^{(i)}$。这被表述为一个约束优化问题：找到$w \\ge 0$，以最小化欧几里得距离$\\|x^{(i)} - S w\\|_2$。这就是非负最小二乘（NNLS）问题。我们使用`scipy.optimize.nnls`函数，这是Lawson-Hanson算法的一个稳健实现，来找到最优暴露度向量$w^{(i)} \\in \\mathbb{R}^4$。非负性约束（$w_j \\ge 0$）至关重要，因为一个突变过程不能有负贡献。\n\n-   **比例贡献（$p^{(i)}$）：** $w^{(i)}$中的原始暴露度值与归因于每个印记的突变数量成正比。为了获得相对贡献，我们将$w^{(i)}$归一化，使其总和为$1$。估计的比例贡献向量$p^{(i)}$计算为$p^{(i)} = \\frac{w^{(i)}}{\\sum_{j=1}^{4} w_j^{(i)}}$。如果暴露度总和为零（即$w^{(i)}$是零向量，这在$x^{(i)}$是零向量时可能发生），则$p^{(i)}$被定义为零向量。\n\n-   **重构与相似度计算：**\n    -   重构计数向量计算为$\\hat{x}^{(i)} = S w^{(i)}$。该向量代表模型对观测数据$x^{(i)}$的最佳拟合。\n    -   余弦相似度$c(u,v) = \\frac{u \\cdot v}{\\|u\\|_2 \\, \\|v\\|_2}$用于衡量向量之间的相似性。我们计算观测数据与其重构向量之间的相似度$c(x^{(i)}, \\hat{x}^{(i)})$，这量化了拟合优度。我们还计算观测数据与每个单个印记之间的相似度$c(x^{(i)}, s_j)$，这提供了一个原始的、未经混合的度量，用以判断可能存在哪些印记。如果任一向量为零，则应用定义$c(u,v)=0$。\n\n**4. 输出格式**\n\n对于三个测试用例中的每一个，结果被汇编成一个包含$9$个浮点数的列表，顺序为：来自$p^{(i)}$的$4$个估计比例贡献，重构向量的余弦相似度，以及与$4$个单个参考印记的余弦相似度。最终输出是表示这三个结果列表的列表的单个字符串。\n\n整个过程在一个独立的Python脚本中实现，该脚本利用`numpy`进行线性代数运算，利用`scipy`进行NNLS优化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Main function to construct signatures, generate test data,\n    run analysis, and print results.\n    \"\"\"\n\n    # Helper function for channel indexing\n    def idx(g, ell, r):\n        return g * 16 + ell * 4 + r\n\n    # Helper function for cosine similarity\n    def cosine_similarity(u, v):\n        norm_u = np.linalg.norm(u)\n        norm_v = np.linalg.norm(v)\n        if norm_u == 0.0 or norm_v == 0.0:\n            return 0.0\n        return np.dot(u, v) / (norm_u * norm_v)\n\n    # 1. Construct the reference signature matrix S\n    \n    n_channels = 96\n    m_signatures = 4\n    S_unnormalized = np.full((n_channels, m_signatures), 0.001)\n\n    # Signature s1 (aging-like)\n    g = 2  # C>T\n    for l in range(4):\n        # C>T at _pCpG\n        S_unnormalized[idx(g, l, 2), 0] = 0.02\n        # C>T at other contexts\n        for r in [0, 1, 3]:\n            S_unnormalized[idx(g, l, r), 0] = 0.005\n\n    # Signature s2 (APOBEC-like, C>T)\n    g, l = 2, 3  # C>T at TpC_\n    for r in [0, 1, 3]:\n        S_unnormalized[idx(g, l, r), 1] = 0.03\n    S_unnormalized[idx(g, l, 2), 1] = 0.01\n\n    # Signature s3 (APOBEC-like, C>G)\n    g, l = 1, 3  # C>G at TpC_\n    for r in [0, 1, 3]:\n        S_unnormalized[idx(g, l, r), 2] = 0.03\n    S_unnormalized[idx(g, l, 2), 2] = 0.01\n\n    # Signature s4 (tobacco-like)\n    g = 0  # C>A\n    for l in range(4):\n        for r in range(4):\n            S_unnormalized[idx(g, l, r), 3] = 0.02\n    S_unnormalized[idx(g, 2, 0), 3] = 0.04\n    S_unnormalized[idx(g, 2, 3), 3] = 0.04\n    \n    # Normalize S to create the final signature matrix\n    S = S_unnormalized / S_unnormalized.sum(axis=0)\n\n    # 2. Define and generate test cases\n    \n    test_params = [\n        (1000, np.array([0.55, 0.10, 0.05, 0.30])),\n        (500, np.array([0.00, 1.00, 0.00, 0.00])),\n        (20, np.array([0.00, 0.50, 0.50, 0.00]))\n    ]\n\n    test_vectors_x = []\n    for N, p_true in test_params:\n        expected_counts = N * (S @ p_true)\n        x = np.round(expected_counts)\n        test_vectors_x.append(x)\n\n    # 3. Process each test case and collect results\n    \n    all_results = []\n    for x in test_vectors_x:\n        # Solve nonnegative least squares\n        w, _ = nnls(S, x)\n\n        # Compute fractional contributions p\n        sum_w = np.sum(w)\n        if sum_w > 0:\n            p = w / sum_w\n        else:\n            p = np.zeros(m_signatures)\n        \n        # Compute reconstruction x_hat\n        x_hat = S @ w\n        \n        # Compute cosine similarities\n        c_x_xhat = cosine_similarity(x, x_hat)\n        c_x_s1 = cosine_similarity(x, S[:, 0])\n        c_x_s2 = cosine_similarity(x, S[:, 1])\n        c_x_s3 = cosine_similarity(x, S[:, 2])\n        c_x_s4 = cosine_similarity(x, S[:, 3])\n        \n        # Assemble the 9-float list for the current case\n        case_result = [\n            p[0], p[1], p[2], p[3],\n            c_x_xhat,\n            c_x_s1, c_x_s2, c_x_s3, c_x_s4\n        ]\n        all_results.append(case_result)\n\n    # 4. Print the final output in the required format\n    # The format is a string representation of a list of lists.\n    # map(str, ...) will convert each inner list to its string representation.\n    # ','.join(...) will join these string representations with a comma.\n    # The outer f-string adds the enclosing square brackets.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "4819271"}]}