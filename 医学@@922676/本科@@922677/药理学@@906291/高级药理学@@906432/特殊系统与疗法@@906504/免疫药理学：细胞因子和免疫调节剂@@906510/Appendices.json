{"hands_on_practices": [{"introduction": "将理论知识应用于实践是掌握免疫药理学的关键。药物在血浆中的浓度固然重要，但其最终疗效取决于在靶组织中与靶点结合的程度。本练习将引导你通过一个基于质量守恒和结合动力学原理的模型，计算一种单克隆抗体在组织间隙的浓度，并由此推算出其与靶细胞因子白介素-6（IL-6）的结合分数，即靶点占有率[@problem_id:4957438]。这个过程能帮助你深刻理解药物从血液循环到实现组织层面药效的关键步骤。", "problem": "一种针对白细胞介素-6 (IL-6) 的中和性单克隆抗体被长期给药，使得其血浆浓度达到一个不随时间变化的稳态。考虑一个双室生理模型，其中血浆和靶组织间质通过通透性限制性转运交换抗体。假设如下：\n\n- 间质是充分混合的，并且就抗体转运而言处于稳态。\n- 血浆与间质之间的转运由通透性-表面积乘积描述，该通透性-表面积乘积 (PS) 等于 $0.015 \\, \\mathrm{L \\cdot h^{-1}}$。\n- 从间质流出的淋巴由清除率 $CL_{L}$ 描述，其等于 $0.025 \\, \\mathrm{L \\cdot h^{-1}}$。\n- 抗体的稳态血浆浓度为 $C_{p} = 24.0 \\, \\mathrm{mg \\cdot L^{-1}}$。\n- 抗体的分子量为 $MW = 150{,}000 \\, \\mathrm{g \\cdot mol^{-1}}$。\n- 间质中抗体与IL-6的结合是快速且可逆的，解离常数 $K_{d} = 3.0 \\, \\mathrm{nM}$，并且IL-6的浓度足够低，以至于因结合而导致的抗体消耗可忽略不计（将游离抗体浓度视为等于间质中的总抗体浓度）。\n- IL-6对该抗体有一个单一结合位点。\n\n从室间转运的稳态质量守恒和平衡结合的质量作用定律出发，推导间质抗体浓度，然后推导间质中被抗体结合的IL-6的比例。使用摩尔浓度进行结合计算；利用给定的分子量从质量浓度进行转换。将最终被结合的IL-6的比例（靶点结合率）表示为无单位的小数，并将您的答案四舍五入到四位有效数字。", "solution": "该问题描述了药代动力学和药效动力学中的一个有效情景。所有参数均已提供，且对于一个简化模型而言，这些假设在科学上是合理的。我们可以开始求解。\n\n首先，我们确定间质中抗体的稳态浓度，记为 $C_{i}$。这可以通过对间质室应用质量守恒原理来实现。在稳态下，抗体质量流入间质的速率必须等于抗体质量流出间质的速率。\n\n从血浆到间质的抗体净转运速率由通透性-表面积乘积 $PS$ 以及血浆 ($C_p$) 和间质 ($C_i$) 之间的浓度梯度描述。\n$$\n\\text{流入速率} = PS \\cdot (C_{p} - C_{i})\n$$\n抗体从间质的流出通过淋巴引流发生，这被建模为一个清除过程。流出速率是淋巴清除率 $CL_{L}$ 和间质浓度 $C_i$ 的乘积。\n$$\n\\text{流出速率} = CL_{L} \\cdot C_{i}\n$$\n在稳态下，流入速率等于流出速率：\n$$\nPS \\cdot (C_{p} - C_{i}) = CL_{L} \\cdot C_i\n$$\n我们重排此方程以求解 $C_i$：\n$$\nPS \\cdot C_p - PS \\cdot C_i = CL_{L} \\cdot C_i\n$$\n$$\nPS \\cdot C_p = (PS + CL_{L}) \\cdot C_i\n$$\n$$\nC_i = \\frac{PS}{PS + CL_{L}} \\cdot C_p\n$$\n现在，我们代入给定值：$PS = 0.015 \\, \\mathrm{L \\cdot h^{-1}}$，$CL_{L} = 0.025 \\, \\mathrm{L \\cdot h^{-1}}$，以及 $C_p = 24.0 \\, \\mathrm{mg \\cdot L^{-1}}$。\n$$\nC_i = \\frac{0.015}{0.015 + 0.025} \\cdot 24.0 = \\frac{0.015}{0.040} \\cdot 24.0 = 0.375 \\cdot 24.0 = 9.0 \\, \\mathrm{mg \\cdot L^{-1}}\n$$\n接下来，我们必须将这个质量浓度转换为摩尔浓度，以分析结合平衡。令 $[Ab]_i$ 表示间质中抗体的摩尔浓度。给定的分子量为 $MW = 150{,}000 \\, \\mathrm{g \\cdot mol^{-1}}$。\n$$\nC_i = 9.0 \\, \\mathrm{mg \\cdot L^{-1}} = 9.0 \\times 10^{-3} \\, \\mathrm{g \\cdot L^{-1}}\n$$\n$$\n[Ab]_i = \\frac{C_i}{MW} = \\frac{9.0 \\times 10^{-3} \\, \\mathrm{g \\cdot L^{-1}}}{150{,}000 \\, \\mathrm{g \\cdot mol^{-1}}} = \\frac{9.0 \\times 10^{-3}}{1.5 \\times 10^{5}} \\, \\mathrm{mol \\cdot L^{-1}} = 6.0 \\times 10^{-8} \\, \\mathrm{mol \\cdot L^{-1}}\n$$\n因此，间质中抗体的摩尔浓度为 $[Ab]_i = 6.0 \\times 10^{-8}$ M。\n\n问题的第二部分是确定被抗体结合的IL-6的比例。结合反应为 $Ab + IL6 \\rightleftharpoons Ab \\cdot IL6$。解离常数 $K_d$ 由平衡时的质量作用定律定义：\n$$\nK_d = \\frac{[Ab]_{\\text{free}} [IL6]_{\\text{free}}}{[Ab \\cdot IL6]}\n$$\n被结合的IL-6的比例，我们记为 $f_b$，是结合复合物的浓度与总IL-6浓度的比值。\n$$\nf_b = \\frac{[Ab \\cdot IL6]}{[IL6]_{\\text{total}}} = \\frac{[Ab \\cdot IL6]}{[IL6]_{\\text{free}} + [Ab \\cdot IL6]}\n$$\n根据 $K_d$ 的表达式，我们可以将 $[IL6]_{\\text{free}}$ 表示为 $K_d \\frac{[Ab \\cdot IL6]}{[Ab]_{\\text{free}}}$。将此代入 $f_b$ 的方程：\n$$\nf_b = \\frac{[Ab \\cdot IL6]}{K_d \\frac{[Ab \\cdot IL6]}{[Ab]_{\\text{free}}} + [Ab \\cdot IL6]}\n$$\n通过将分子和分母同时除以 $[Ab \\cdot IL6]$，我们简化该表达式：\n$$\nf_b = \\frac{1}{\\frac{K_d}{[Ab]_{\\text{free}}} + 1} = \\frac{[Ab]_{\\text{free}}}{K_d + [Ab]_{\\text{free}}}\n$$\n问题陈述“因结合而导致的抗体消耗可忽略不计”。这是一个关键假设，意味着游离抗体浓度 $[Ab]_{\\text{free}}$ 实际上等于总间质抗体浓度 $[Ab]_i$。因此：\n$$\nf_b \\approx \\frac{[Ab]_i}{K_d + [Ab]_i}\n$$\n为了进行最终计算，我们必须使用一致的单位。给定的解离常数为 $K_d = 3.0 \\, \\mathrm{nM}$。我们将计算出的间质抗体浓度转换为nM：\n$$\n[Ab]_i = 6.0 \\times 10^{-8} \\, \\mathrm{M} = 60 \\times 10^{-9} \\, \\mathrm{M} = 60 \\, \\mathrm{nM}\n$$\n现在我们将 $[Ab]_i$ 和 $K_d$ 的值代入 $f_b$ 的方程中：\n$$\nf_b = \\frac{60 \\, \\mathrm{nM}}{3.0 \\, \\mathrm{nM} + 60 \\, \\mathrm{nM}} = \\frac{60}{63}\n$$\n数值为：\n$$\nf_b = \\frac{60}{63} = \\frac{20}{21} \\approx 0.95238095...\n$$\n按要求将结果四舍五入到四位有效数字，得到最终答案。", "answer": "$$\n\\boxed{0.9524}\n$$", "id": "4957438"}, {"introduction": "生物药（如单克隆抗体）的一大挑战是其可能引发的免疫原性，即机体产生抗药物抗体（ADA）。这些抗体能够中和药物或加速其清除，从而影响治疗效果。在本计算练习中，你将通过构建一个常微分方程（ODE）系统来模拟这一动态过程，探索不同特征的ADA（如亲和力、产生速率）如何影响药物在多次给药后的有效浓度[@problem_id:4957487]。这有助于你理解和预测免疫原性对临床结果的潜在影响。", "problem": "一种生物免疫调节剂可以诱发抗药抗体（Anti-Drug Antibody, ADA），这些抗体与药物结合并改变其药代动力学。考虑一个单一、充分混合的房室，其中包含游离药物浓度 $D(t)$、游离抗体浓度 $A(t)$ 和药物-抗体复合物浓度 $C(t)$，每个浓度均以任意浓度单位 (a.u.) 计量。结合遵循质量作用动力学，所有消除均为一级反应。基本出发点是质量作用定律和一级衰减，应用于可逆结合反应 $D + A \\rightleftharpoons C$，其正向速率常数为 $k_{\\mathrm{on}}$，逆向速率常数为 $k_{\\mathrm{off}}$，以及游离药物、游离抗体和复合物的独立一级消除。\n\n根据这些原理，可得常微分方程组 (ODEs) 如下：\n$$\n\\frac{dD}{dt} = -k_{\\mathrm{el}}\\,D - k_{\\mathrm{on}}\\,D\\,A + k_{\\mathrm{off}}\\,C,\n$$\n$$\n\\frac{dA}{dt} = p - d\\,A - k_{\\mathrm{on}}\\,D\\,A + k_{\\mathrm{off}}\\,C,\n$$\n$$\n\\frac{dC}{dt} = k_{\\mathrm{on}}\\,D\\,A - k_{\\mathrm{off}}\\,C - k_{\\mathrm{clearC}}\\,C,\n$$\n其中 $k_{\\mathrm{el}}$ 是游离药物的一级消除速率（单位为 $\\mathrm{hr}^{-1}$），$k_{\\mathrm{on}}$ 是结合速率常数（单位为 $\\mathrm{(a.u.)}^{-1}\\mathrm{hr}^{-1}$），$k_{\\mathrm{off}}$ 是解离速率（单位为 $\\mathrm{hr}^{-1}$），$k_{\\mathrm{clearC}}$ 是复合物的消除速率（单位为 $\\mathrm{hr}^{-1}$），$p$ 是恒定的抗体生成速率（单位为 $\\mathrm{a.u./hr}$），$d$ 是抗体的一级消除速率（单位为 $\\mathrm{hr}^{-1}$）。给药被建模为在指定时间对 $D$ 的瞬时推注增加。时间 $t=0$ 时的初始条件为 $D(0)=0$，$A(0)=A_0$，$C(0)=0$，随即立即进行一次初始推注。\n\n一个四剂量方案在时间 $t \\in \\{0, 168, 336, 504\\}$ 小时给药，每次给药瞬时为 $D$ 增加 $\\Delta D$ a.u.。目标是计算在不同 ADA 情景下，$T=672$ 小时（即最后一次给药后 $168$ 小时）的谷底游离药物浓度 $D(T)$，单位为 a.u.。在两次推注之间对 ODEs 进行数值积分；在每个推注时间点，将 $D$ 增加 $\\Delta D$ 并继续积分。\n\n您的程序必须实现这个模型，并为下面测试套件中的每个参数集生成谷底浓度 $D(T)$。以 a.u. 为单位表示最终结果，四舍五入到三位小数。不涉及角度，也没有百分比。\n\n测试套件参数集以有序元组的形式指定：\n$(\\Delta D,\\; k_{\\mathrm{el}},\\; k_{\\mathrm{on}},\\; k_{\\mathrm{off}},\\; k_{\\mathrm{clearC}},\\; p,\\; d,\\; A_0)$\n所有量的定义如上。请使用以下测试套件：\n- 案例 1 (无ADA)：$(20,\\; 0.03,\\; 0,\\; 0,\\; 0.02,\\; 0,\\; 0,\\; 0)$。\n- 案例 2 (中度ADA)：$(20,\\; 0.03,\\; 0.03,\\; 0.01,\\; 0.02,\\; 0.005,\\; 0.01,\\; 0)$。\n- 案例 3 (高亲和力、高产量ADA)：$(20,\\; 0.03,\\; 0.10,\\; 0.005,\\; 0.05,\\; 0.02,\\; 0.02,\\; 0)$。\n- 案例 4 (复合物清除缓慢)：$(20,\\; 0.03,\\; 0.03,\\; 0.02,\\; 0.005,\\; 0.005,\\; 0.01,\\; 0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[x_1,x_2,x_3,x_4]$），其中 $x_i$ 是上述四种情况下，以 a.u. 为单位的谷值 $D(672)$，每个值都四舍五入到三位小数。", "solution": "用户提供了一个问题，需要通过求解一个常微分方程组（ODEs）的数值解，来模拟一种生物药物在存在抗药抗体（ADA）时的药代动力学。\n\n### 问题验证\n\n首先，根据强制性标准对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n-   **状态变量**：游离药物浓度 $D(t)$、游离抗体浓度 $A(t)$ 和药物-抗体复合物浓度 $C(t)$。所有浓度均以任意浓度单位 (a.u.) 计量。\n-   **常微分方程组 (ODEs)**：\n    $$\n    \\frac{dD}{dt} = -k_{\\mathrm{el}}\\,D - k_{\\mathrm{on}}\\,D\\,A + k_{\\mathrm{off}}\\,C\n    $$\n    $$\n    \\frac{dA}{dt} = p - d\\,A - k_{\\mathrm{on}}\\,D\\,A + k_{\\mathrm{off}}\\,C\n    $$\n    $$\n    \\frac{dC}{dt} = k_{\\mathrm{on}}\\,D\\,A - k_{\\mathrm{off}}\\,C - k_{\\mathrm{clearC}}\\,C\n    $$\n-   **参数**：$k_{\\mathrm{el}}$ ($\\mathrm{hr}^{-1}$)，$k_{\\mathrm{on}}$ ($\\mathrm{(a.u.)}^{-1}\\mathrm{hr}^{-1}$)，$k_{\\mathrm{off}}$ ($\\mathrm{hr}^{-1}$)，$k_{\\mathrm{clearC}}$ ($\\mathrm{hr}^{-1}$)，$p$ ($\\mathrm{a.u./hr}$)，$d$ ($\\mathrm{hr}^{-1}$)。\n-   **$t=0$ 时的初始条件**：$D(0)=0$, $A(0)=A_0$, $C(0)=0$。\n-   **给药方案**：在时间 $t \\in \\{0, 168, 336, 504\\}$ 小时，向 $D(t)$ 添加瞬时推注剂量 $\\Delta D$ (a.u.)。\n-   **目标**：计算在 $T=672$ 小时时的谷底游离药物浓度 $D(T)$。\n-   **测试套件**：包含四个参数集的列表 $(\\Delta D,\\; k_{\\mathrm{el}},\\; k_{\\mathrm{on}},\\; k_{\\mathrm{off}},\\; k_{\\mathrm{clearC}},\\; p,\\; d,\\; A_0)$:\n    1.  $(20,\\; 0.03,\\; 0,\\; 0,\\; 0.02,\\; 0,\\; 0,\\; 0)$\n    2.  $(20,\\; 0.03,\\; 0.03,\\; 0.01,\\; 0.02,\\; 0.005,\\; 0.01,\\; 0)$\n    3.  $(20,\\; 0.03,\\; 0.10,\\; 0.005,\\; 0.05,\\; 0.02,\\; 0.02,\\; 0)$\n    4.  $(20, 0.03,\\; 0.03,\\; 0.02,\\; 0.005,\\; 0.005,\\; 0.01,\\; 0)$\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题基于质量作用定律和一级衰减，这些是化学动力学和药理学中的基本原理。该模型是靶介导的药物处置（TMDD）的标准表示，这是一个成熟的概念。\n-   **良态问题**：该问题指定了一个具有明确定义初始条件和分段驱动事件（剂量）的常微分方程组。这构成了每个给药间隔内的良态初值问题，保证了唯一的数值解。\n-   **客观性**：该问题使用精确的数学术语陈述，没有主观或模棱两可的语言。任务是纯粹的计算性任务。\n-   **完整性和一致性**：问题是自洽的。所有必要的参数、初始条件和给药计划都已提供。单位内部一致。\n-   **合理性**：参数值在此类生物过程的合理范围内。\n\n**步骤 3：结论与行动**\n该问题在科学上合理、数学上是良态问题、客观且自洽。因此，它被判定为**有效**。将提供一个解决方案。\n\n### 解决方案\n\n该问题需要求解一个由三个耦合的非线性常微分方程组成的系统，这些方程描述了药物 $D(t)$、抗药抗体 $A(t)$ 以及药物-抗体复合物 $C(t)$ 的浓度。该系统受多剂量给药方案的影响，这会在药物浓度中引入不连续性。\n\n控制方程为：\n$$\n\\frac{dD}{dt} = -k_{\\mathrm{el}}\\,D - k_{\\mathrm{on}}\\,D\\,A + k_{\\mathrm{off}}\\,C\n$$\n$$\n\\frac{dA}{dt} = p - d\\,A - k_{\\mathrm{on}}\\,D\\,A + k_{\\mathrm{off}}\\,C\n$$\n$$\n\\frac{dC}{dt} = k_{\\mathrm{on}}\\,D\\,A - (k_{\\mathrm{off}} + k_{\\mathrm{clearC}})\\,C\n$$\n系统的状态由浓度向量 $y(t) = [D(t), A(t), C(t)]^T$ 描述。在 $t=0$ 时的初始状态为 $y(0) = [0, A_0, 0]^T$。\n\n给药方案包括在时间 $t \\in \\{0, 168, 336, 504\\}$ 小时进行的四次剂量为 $\\Delta D$ 的推注。这些注射被建模为药物浓度的瞬时增加。问题的这种分段性质需要进行分段模拟。总模拟时间从 $t=0$ 到 $T=672$ 小时，分为四个时间间隔：\n1.  $t \\in [0, 168]$\n2.  $t \\in [168, 336]$\n3.  $t \\in [336, 504]$\n4.  $t \\in [504, 672]$\n\n对于每个参数集，通过以下步骤找到解：\n1.  在 $t=0$ 时将状态向量初始化为 $y_{current} = [0, A_0, 0]$。\n2.  遍历四个时间间隔。设当前间隔为 $[t_{start}, t_{end}]$。\n3.  在每个间隔的开始时间 $t_{start}$，通过更新药物浓度来应用推注剂量：$D(t_{start}) \\leftarrow D(t_{start}) + \\Delta D$。这对 $t_{start} \\in \\{0, 168, 336, 504\\}$ 执行。\n4.  使用 $t_{start}$ 时的状态（如果适用，则为给药后的状态）作为初始条件，在区间 $[t_{start}, t_{end}]$ 上对 ODE 系统进行数值求解。为此，我们采用高质量的数值积分器。使用 `scipy.integrate.solve_ivp` 函数及 `Radau` 方法，这是一种隐式龙格-库塔法，非常适合处理药代动力学中经常遇到的潜在刚性系统。为确保准确性，使用了严格的绝对和相对误差容限（例如，分别为 $10^{-12}$ 和 $10^{-9}$）。\n5.  区间结束时的状态向量 $y(t_{end})$ 成为下一个区间的起始状态。\n6.  重复此过程，直到达到最终时间 $T=672$ 小时。游离药物浓度 $D(672)$ 就是所求的谷值。\n7.  按要求将每个案例的最终结果四舍五入到三位小数。\n8.  对四个测试案例中的每一个都执行此程序，并将结果汇总到一个格式化的输出字符串中。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to solve the pharmacokinetic model for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (no ADA)\n        # (delta_D, k_el, k_on, k_off, k_clearC, p, d, A0)\n        (20.0, 0.03, 0.0, 0.0, 0.02, 0.0, 0.0, 0.0),\n        # Case 2 (moderate ADA)\n        (20.0, 0.03, 0.03, 0.01, 0.02, 0.005, 0.01, 0.0),\n        # Case 3 (high-affinity, high-production ADA)\n        (20.0, 0.03, 0.10, 0.005, 0.05, 0.02, 0.02, 0.0),\n        # Case 4 (slow complex clearance)\n        (20.0, 0.03, 0.03, 0.02, 0.005, 0.005, 0.01, 0.0),\n    ]\n\n    def odes(t, y, k_el, k_on, k_off, k_clearC, p, d):\n        \"\"\"\n        Defines the system of ordinary differential equations for the TMDD model.\n        \n        Args:\n            t (float): Time.\n            y (np.ndarray): State vector [D, A, C].\n            k_el, k_on, ...: Model parameters.\n\n        Returns:\n            list: The derivatives [dD/dt, dA/dt, dC/dt].\n        \"\"\"\n        D, A, C = y\n        \n        # Rate of change for the free drug concentration D\n        dD_dt = -k_el * D - k_on * D * A + k_off * C\n        \n        # Rate of change for the free antibody concentration A\n        dA_dt = p - d * A - k_on * D * A + k_off * C\n        \n        # Rate of change for the drug-antibody complex concentration C\n        dC_dt = k_on * D * A - k_off * C - k_clearC * C\n        \n        return [dD_dt, dA_dt, dC_dt]\n\n    def solve_one_case(params):\n        \"\"\"\n        Solves the ODE system for a single set of parameters and dosing regimen.\n        \n        Args:\n            params (tuple): A tuple of model parameters.\n            \n        Returns:\n            float: The trough drug concentration D at T=672 hours.\n        \"\"\"\n        delta_D, k_el, k_on, k_off, k_clearC, p, d, A0 = params\n        \n        # Arguments for the ODE function\n        ode_args = (k_el, k_on, k_off, k_clearC, p, d)\n        \n        # Initial state at t=0\n        current_y = np.array([0.0, A0, 0.0])\n        \n        # Simulation time points and dose schedule\n        time_points = [0, 168, 336, 504, 672]\n        dose_times = {0, 168, 336, 504}\n        \n        for i in range(len(time_points) - 1):\n            t_start = time_points[i]\n            t_end = time_points[i+1]\n            \n            # Apply bolus dose at the start of the interval if it's a dose time\n            if t_start in dose_times:\n                current_y[0] += delta_D\n            \n            # Numerically integrate the ODEs over the interval\n            sol = solve_ivp(\n                fun=odes,\n                t_span=[t_start, t_end],\n                y0=current_y,\n                args=ode_args,\n                method='Radau',  # An implicit solver suitable for stiff problems\n                dense_output=False,\n                atol=1e-12,     # Strict tolerances for high accuracy\n                rtol=1e-9\n            )\n            \n            # Check if the integration was successful\n            if not sol.success:\n                raise RuntimeError(f\"ODE integration failed for params: {params}\")\n            \n            # Update state vector for the next interval\n            current_y = sol.y[:, -1]\n            \n        final_D = current_y[0]\n        return final_D\n\n    results = []\n    for case in test_cases:\n        result_D = solve_one_case(case)\n        results.append(result_D)\n    \n    # Format the results to three decimal places and print\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4957487"}, {"introduction": "成功的药物治疗依赖于科学合理的给药方案设计，以确保药物浓度维持在既有效又安全的治疗窗内。本练习将药代动力学原理付诸实践，要求你基于经典的单室吸收模型，设计一个算法来筛选最佳给药间隔[@problem_id:4957507]。通过计算不同给药间隔下的稳态血药浓度峰值 ($C_{\\max, \\mathrm{ss}}$) 和谷值 ($C_{\\min, \\mathrm{ss}}$)，你将学会如何为免疫调节剂制定一个既能达到最小有效浓度 ($MEC$) 又不超过最大耐受浓度 ($MTC$) 的给药方案。", "problem": "经血管外途径给药的细胞因子或免疫调节剂通常可以使用具有一级吸收和一级消除的单室药代动力学系统进行建模。假设生物利用度是恒定的，等于一个已知的分数，并且在固定的给药间隔重复给药。在这些假设下，浓度-时间曲线由线性微分方程和叠加原理决定。对于线性动力学下的稳态，任何两次给药之间的浓度以给药间隔为周期。免疫调节效应的治疗窗可以由最低有效浓度和最高耐受浓度来定义。一个实用的给药间隔应使整个稳态浓度-时间曲线保持在该窗口内。\n\n从以下基本依据出发：\n- 具有一级吸收和一级消除的单室模型，其中吸收部位的药物量与当前量成比例减少，中央室的消除与其药物量成比例，以及\n- 清除率的定义为 $Cl = k_{e} \\cdot V_{d}$ 以及重复给药的线性叠加，\n\n设计一个算法，对于每个候选给药间隔，构建一个给药间隔内的稳态浓度-时间函数，并检查其是否完全保持在指定的治疗窗内。您的算法必须：\n- 使用上述假设，为一组给定的参数正确构建稳态浓度-时间曲线，而不依赖任何外部数据，\n- 对于每个候选间隔 $\\tau$，计算在区间 $[0,\\tau)$ 内的最高和最低稳态浓度，\n- 从提供的候选方案中选择满足 $C_{\\min,\\mathrm{ss}} \\geq \\mathrm{MEC}$ 和 $C_{\\max,\\mathrm{ss}} \\leq \\mathrm{MTC}$ 的最大给药间隔（以小时为单位），其中 $\\mathrm{MEC}$ 是最低有效浓度，$\\mathrm{MTC}$ 是最高耐受浓度，\n- 如果没有候选间隔满足这些约束，则返回 $-1$。\n\n所有浓度单位必须为 $\\mathrm{mg}/\\mathrm{L}$，剂量单位为 $\\mathrm{mg}$，体积单位为 $\\mathrm{L}$，速率单位为 $\\mathrm{h}^{-1}$。您的程序必须以小时为单位表示最终选择的给药间隔。当某个案例不可行时，返回整数 $-1$。时间变量的单位是 $\\mathrm{h}$。您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[12,24,-1]$），每个条目按顺序对应一个测试案例。\n\n测试套件。对于下面的每个测试案例，参数以元组形式给出：\n$(D, F, V_{d}, k_{a}, k_{e}, \\mathrm{MEC}, \\mathrm{MTC}, \\text{candidates})$，其中：\n- $D$ 是剂量，单位为 $\\mathrm{mg}$，\n- $F$ 是绝对生物利用度（无单位），\n- $V_{d}$ 是表观分布容积，单位为 $\\mathrm{L}$，\n- $k_{a}$ 是一级吸收速率常数，单位为 $\\mathrm{h}^{-1}$，\n- $k_{e}$ 是一级消除速率常数，单位为 $\\mathrm{h}^{-1}$，\n- $\\mathrm{MEC}$ 是最低有效浓度，单位为 $\\mathrm{mg}/\\mathrm{L}$，\n- $\\mathrm{MTC}$ 是最高耐受浓度，单位为 $\\mathrm{mg}/\\mathrm{L}$，\n- $\\text{candidates}$ 是候选给药间隔列表，单位为小时。\n\n使用以下测试案例：\n- 案例 1（短半衰期细胞因子激动剂）：$(D=100, F=0.9, V_{d}=10, k_{a}=1.5, k_{e}=0.2, \\mathrm{MEC}=2, \\mathrm{MTC}=10, \\text{candidates}=[6, 8, 12, 24])$。\n- 案例 2（I型干扰素类似物）：$(D=50, F=0.9, V_{d}=20, k_{a}=1.0, k_{e}=0.05, \\mathrm{MEC}=1, \\mathrm{MTC}=8, \\text{candidates}=[12, 24, 48])$。\n- 案例 3（吸收缓慢的皮下注射单克隆抗体）：$(D=240, F=0.7, V_{d}=5, k_{a}=0.02, k_{e}=0.0015, \\mathrm{MEC}=20, \\mathrm{MTC}=200, \\text{candidates}=[168, 336, 504, 672])$。\n- 案例 4（低剂量白细胞介素-2类似物；不可行窗口）：$(D=5, F=0.5, V_{d}=15, k_{a}=2.0, k_{e}=0.3, \\mathrm{MEC}=1, \\mathrm{MTC}=5, \\text{candidates}=[6, 8, 12])$。\n\n最终输出格式：您的程序应生成一行，其中包含一个Python风格的列表，按顺序列出四个案例所选的给药间隔（以小时为单位），例如 $[\\tau_{1},\\tau_{2},\\tau_{3},\\tau_{4}]$，其中每个 $\\tau_{i}$ 是一个以小时为单位的数字或整数 $-1$。", "solution": "用户希望我扮演一位严谨的STEM教授。我必须验证该问题，如果问题有效，则提供一个解决方案。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n*   **模型：** 具有一级吸收和一级消除的单室药代动力学系统。\n*   **给药方式：** 血管外途径。\n*   **给药方案：** 在固定给药间隔（$\\tau$，单位h）重复给药（$D$，单位mg）。\n*   **参数：**\n    *   $D$：剂量，单位mg。\n    *   $F$：绝对生物利用度（无单位）。\n    *   $V_d$：表观分布容积，单位L。\n    *   $k_a$：一级吸收速率常数，单位h⁻¹。\n    *   $k_e$：一级消除速率常数，单位h⁻¹。\n    *   $\\mathrm{MEC}$：最低有效浓度，单位mg/L。\n    *   $\\mathrm{MTC}$：最高耐受浓度，单位mg/L。\n    *   `candidates`：候选给药间隔列表，单位小时。\n*   **原理：**\n    *   该系统由线性微分方程决定。\n    *   叠加原理适用于重复给药。\n    *   清除率定义为 $Cl = k_e \\cdot V_d$。\n*   **目标：**\n    1.  设计一个算法来构建稳态浓度-时间函数 $C_{\\mathrm{ss}}(t)$，覆盖一个给药间隔 $[0, \\tau)$。\n    2.  对于每个候选间隔 $\\tau$，计算最低（$C_{\\min,\\mathrm{ss}}$）和最高（$C_{\\max,\\mathrm{ss}}$）稳态浓度。\n    3.  从 `candidates` 列表中选择满足 $C_{\\min,\\mathrm{ss}} \\geq \\mathrm{MEC}$ 和 $C_{\\max,\\mathrm{ss}} \\leq \\mathrm{MTC}$ 的最大给药间隔。\n    4.  如果没有候选间隔满足标准，则返回 $-1$。\n*   **测试案例：**\n    *   案例 1: $(D=100, F=0.9, V_d=10, k_a=1.5, k_e=0.2, \\mathrm{MEC}=2, \\mathrm{MTC}=10, \\text{candidates}=[6, 8, 12, 24])$。\n    *   案例 2: $(D=50, F=0.9, V_d=20, k_a=1.0, k_e=0.05, \\mathrm{MEC}=1, \\mathrm{MTC}=8, \\text{candidates}=[12, 24, 48])$。\n    *   案例 3: $(D=240, F=0.7, V_d=5, k_a=0.02, k_e=0.0015, \\mathrm{MEC}=20, \\mathrm{MTC}=200, \\text{candidates}=[168, 336, 504, 672])$。\n    *   案例 4: $(D=5, F=0.5, V_d=15, k_a=2.0, k_e=0.3, \\mathrm{MEC}=1, \\mathrm{MTC}=5, \\text{candidates}=[6, 8, 12])$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n*   **科学依据：** 该问题基于标准的、普遍接受的具有一级吸收和消除的单室模型。该模型是药理学和药代动力学中的一个基本概念。所有提及的原理（线性动力学、叠加、稳态）都是该领域的基石。\n*   **良态问题：** 问题明确。对于每个测试案例，都提供了所有必要的参数。目标是从一个有限的、明确给出的候选集合中找到满足一对明确定义的不等式的最大值。这样的值（或其不存在，导致返回值为-1）的存在性和唯一性是有保证的。\n*   **客观性：** 问题使用精确、客观和技术性的语言陈述。成功的标准是定量且无歧义的。\n*   **缺陷清单：**\n    1.  *科学/事实不准确：* 无此问题。模型是合理的。\n    2.  *不可形式化/不相关：* 该问题是在药理学中应用数学模型的经典示例，可直接形式化。主题是免疫药理学，这是药理学的一个子领域，此类模型被广泛用于生物制剂。\n    3.  *不完整/矛盾：* 问题是自洽的。所有必要的数据都已提供。不存在矛盾。一个重要的边缘情况，$k_a = k_e$，需要一个不同的数学公式，但在所有测试案例中均未出现。\n    4.  *不切实际/不可行：* 测试案例中提供的参数对于所描述的药物类型在药代动力学上是合理的（例如，单克隆抗体的速率非常慢）。\n    5.  *病态/结构不良：* 问题结构良好，每个测试案例都有唯一解。\n    6.  *伪深刻/琐碎：* 该问题需要药代动力学建模和微积分的实质性知识来推导和应用正确的公式。这是一个标准的、非琐碎的学术问题。\n    7.  *超出科学可验证性范围：* 计算是确定性的，可以独立验证。\n\n**步骤3：结论与行动**\n\n问题是**有效的**。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n该算法设计植根于对重复血管外给药后一级吸收和一级消除的单室药代动力学模型的数学描述。\n\n**1. 单次给药药代动力学**\n\n设 $A_a(t)$ 为血管外吸收部位的药物量，$A_c(t)$ 为中央室在时间 $t$ 的药物量。该系统由一对线性一阶常微分方程描述：\n$$\n\\frac{dA_a}{dt} = -k_a A_a(t)\n$$\n$$\n\\frac{dA_c}{dt} = k_a A_a(t) - k_e A_c(t)\n$$\n对于在 $t=0$ 时给予的单次剂量 $D$，生物利用度为 $F$，初始条件为 $A_a(0) = F \\cdot D$ 和 $A_c(0) = 0$。求解此系统可得中央室中的药物量：\n$$\nA_c(t) = \\frac{F D k_a}{k_a - k_e} (e^{-k_e t} - e^{-k_a t})\n$$\n中央室的浓度 $C(t)$ 是 $A_c(t)$ 除以分布容积 $V_d$：\n$$\nC(t) = \\frac{A_c(t)}{V_d} = \\frac{F D k_a}{V_d (k_a - k_e)} (e^{-k_e t} - e^{-k_a t})\n$$\n该方程在 $k_a \\neq k_e$ 时有效，所有测试案例均满足此条件。\n\n**2. 重复给药的稳态药代动力学**\n\n当每隔 $\\tau$ 小时重复给药时，通过应用叠加原理，可以找到任何给药间隔内（例如 $t \\in [0, \\tau)$）时间 $t$ 的稳态浓度 $C_{\\mathrm{ss}}(t)$。这涉及对过去无限系列剂量的贡献求和：\n$$\nC_{\\mathrm{ss}}(t) = \\sum_{n=0}^{\\infty} C(t + n\\tau)\n$$\n代入 $C(t)$ 的表达式并计算所得的几何级数，可得出稳态浓度的封闭解：\n$$\nC_{\\mathrm{ss}}(t) = \\frac{F D k_a}{V_d (k_a - k_e)} \\left[ \\left(\\sum_{n=0}^{\\infty} e^{-k_e(t+n\\tau)}\\right) - \\left(\\sum_{n=0}^{\\infty} e^{-k_a(t+n\\tau)}\\right) \\right]\n$$\n$$\nC_{\\mathrm{ss}}(t) = \\frac{F D k_a}{V_d (k_a - k_e)} \\left[ \\frac{e^{-k_e t}}{1 - e^{-k_e \\tau}} - \\frac{e^{-k_a t}}{1 - e^{-k_a \\tau}} \\right]\n$$\n该函数描述了稳态下两次给药之间的周期性浓度曲线。\n\n**3. 稳态浓度曲线的极值**\n\n为确保给药方案安全有效，整个给药间隔内的浓度曲线 $[C_{\\mathrm{ss}}(t)]_{t \\in [0, \\tau)}$ 必须位于治疗窗 $[\\mathrm{MEC}, \\mathrm{MTC}]$ 内。这需要找到稳态下的最低和最高浓度，$C_{\\min,\\mathrm{ss}}$ 和 $C_{\\max,\\mathrm{ss}}$。\n\n*   **最低浓度 ($C_{\\min,\\mathrm{ss}}$):**\n    浓度在下一次给药前达到最低点。这对应于时间 $t=0$（或等效地，前一个间隔的 $t=\\tau$）。\n    $$\n    C_{\\min,\\mathrm{ss}} = C_{\\mathrm{ss}}(0) = \\frac{F D k_a}{V_d (k_a - k_e)} \\left[ \\frac{1}{1 - e^{-k_e \\tau}} - \\frac{1}{1 - e^{-k_a \\tau}} \\right]\n    $$\n*   **最高浓度 ($C_{\\max,\\mathrm{ss}}$):**\n    最高浓度出现在导数 $\\frac{dC_{\\mathrm{ss}}}{dt}$ 为零的时间 $t_{\\max,\\mathrm{ss}}$。对 $C_{\\mathrm{ss}}(t)$ 求导并令结果为零可得：\n    $$\n    \\frac{dC_{\\mathrm{ss}}}{dt} = \\frac{F D k_a}{V_d (k_a - k_e)} \\left[ \\frac{-k_e e^{-k_e t}}{1 - e^{-k_e \\tau}} - \\frac{-k_a e^{-k_a t}}{1 - e^{-k_a \\tau}} \\right] = 0\n    $$\n    解出 $t = t_{\\max,\\mathrm{ss}}$ 可得：\n    $$\n    t_{\\max,\\mathrm{ss}} = \\frac{1}{k_a - k_e} \\ln\\left[ \\frac{k_a}{k_e} \\frac{1 - e^{-k_e \\tau}}{1 - e^{-k_a \\tau}} \\right]\n    $$\n    然后将此时间代回稳态方程，即可找到最高浓度：\n    $$\n    C_{\\max,\\mathrm{ss}} = C_{\\mathrm{ss}}(t_{\\max,\\mathrm{ss}})\n    $$\n    在 $t=0$ 时的浓度导数始终为正（对于 $k_a \\neq k_e$），这证实了浓度从间隔开始时的最小值上升到间隔内的峰值，然后下降。\n\n**4. 算法实现**\n\n最终的算法遍历每个测试案例，并对每个案例遍历每个候选给药间隔 $\\tau$。\n\n1.  对于列表中的给定候选间隔 $\\tau$，使用其公式计算 $C_{\\min,\\mathrm{ss}}$。\n2.  计算达峰时间 $t_{\\max,\\mathrm{ss}}$。\n3.  通过在 $t=t_{\\max,\\mathrm{ss}}$ 处计算 $C_{\\mathrm{ss}}(t)$ 来计算 $C_{\\max,\\mathrm{ss}}$。\n4.  检查是否满足治疗窗条件：$C_{\\min,\\mathrm{ss}} \\geq \\mathrm{MEC}$ 和 $C_{\\max,\\mathrm{ss}} \\leq \\mathrm{MTC}$。\n5.  如果满足条件，则间隔 $\\tau$ 被认为是有效的。\n6.  在测试给定药物的所有候选间隔后，识别所有有效的间隔。\n7.  如果有效间隔的集合为空，则该案例的结果为 $-1$。\n8.  否则，结果为有效间隔集合中的最大值，正如问题所要求。\n\n此过程系统地应用于所有测试案例以生成最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pharmacokinetic dosing interval problem for a series of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (short half-life cytokine agonist)\n        {'D': 100, 'F': 0.9, 'Vd': 10, 'ka': 1.5, 'ke': 0.2, 'MEC': 2, 'MTC': 10, 'candidates': [6, 8, 12, 24]},\n        # Case 2 (type I interferon analog)\n        {'D': 50, 'F': 0.9, 'Vd': 20, 'ka': 1.0, 'ke': 0.05, 'MEC': 1, 'MTC': 8, 'candidates': [12, 24, 48]},\n        # Case 3 (subcutaneous monoclonal antibody with slow absorption)\n        {'D': 240, 'F': 0.7, 'Vd': 5, 'ka': 0.02, 'ke': 0.0015, 'MEC': 20, 'MTC': 200, 'candidates': [168, 336, 504, 672]},\n        # Case 4 (low-dose interleukin-2 analog; infeasible window)\n        {'D': 5, 'F': 0.5, 'Vd': 15, 'ka': 2.0, 'ke': 0.3, 'MEC': 1, 'MTC': 5, 'candidates': [6, 8, 12]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = find_best_interval(\n            case['D'], case['F'], case['Vd'], case['ka'], case['ke'],\n            case['MEC'], case['MTC'], case['candidates']\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_best_interval(D, F, Vd, ka, ke, MEC, MTC, candidates):\n    \"\"\"\n    Finds the largest dosing interval from a list of candidates that keeps\n    steady-state concentrations within the therapeutic window.\n    \n    Args:\n        D (float): Dose (mg)\n        F (float): Bioavailability\n        Vd (float): Volume of distribution (L)\n        ka (float): Absorption rate constant (h^-1)\n        ke (float): Elimination rate constant (h^-1)\n        MEC (float): Minimum effective concentration (mg/L)\n        MTC (float): Maximum tolerated concentration (mg/L)\n        candidates (list): List of candidate dosing intervals (h)\n        \n    Returns:\n        int: The largest valid dosing interval, or -1 if none are valid.\n    \"\"\"\n    valid_intervals = []\n    \n    # Pre-calculate the constant part of the concentration equation\n    # This assumes ka is not equal to ke, which is true for all test cases.\n    if ka == ke:\n        # This case requires a different formula not implemented here as it's not needed.\n        # All test cases have ka != ke.\n        pass\n\n    prefactor = (F * D * ka) / (Vd * (ka - ke))\n\n    for tau in candidates:\n        # Calculate C_min_ss, which is C_ss(t=0)\n        # Using the formula: C_min_ss = Prefactor * [1/(1-exp(-ke*tau)) - 1/(1-exp(-ka*tau))]\n        term_e_min = 1.0 / (1.0 - np.exp(-ke * tau))\n        term_a_min = 1.0 / (1.0 - np.exp(-ka * tau))\n        C_min_ss = prefactor * (term_e_min - term_a_min)\n\n        # Calculate t_max_ss, the time of maximum concentration at steady state\n        # Using the formula: t_max_ss = (1/(ka-ke)) * ln[(ka/ke) * (1-exp(-ke*tau))/(1-exp(-ka*tau))]\n        log_arg = (ka / ke) * ((1.0 - np.exp(-ke * tau)) / (1.0 - np.exp(-ka * tau)))\n        t_max_ss = (1.0 / (ka - ke)) * np.log(log_arg)\n        \n        # Calculate C_max_ss, which is C_ss(t_max_ss)\n        # Using the formula: C_max_ss = Prefactor * [exp(-ke*t_max)/(1-exp(-ke*tau)) - exp(-ka*t_max)/(1-exp(-ka*tau))]\n        term_e_max = np.exp(-ke * t_max_ss) / (1.0 - np.exp(-ke * tau))\n        term_a_max = np.exp(-ka * t_max_ss) / (1.0 - np.exp(-ka * tau))\n        C_max_ss = prefactor * (term_e_max - term_a_max)\n\n        # Check if the calculated concentrations are within the therapeutic window\n        if C_min_ss >= MEC and C_max_ss = MTC:\n            valid_intervals.append(tau)\n            \n    if not valid_intervals:\n        return -1\n    else:\n        return max(valid_intervals)\n\nsolve()\n```", "id": "4957507"}]}