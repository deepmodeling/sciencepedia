{"hands_on_practices": [{"introduction": "在理论上，药物剂量越大，反应越强。然而，在实际实验中，由于样本的随机变异性，观测到的反应率可能不会严格遵循这种单调递增的趋势。本练习将向您介绍一种处理此类数据的强大非参数方法——保序回归，特别是使用“池邻近违规者算法”(Pool-Adjacent-Violators Algorithm, PAVA) [@problem_id:4984813]。通过这个实践，您将学会如何校正数据中的非单调性，从而得到一组符合药理学预期的、单调的剂量-反应关系估计值。", "problem": "在定性剂量-反应分析中，对于给定的剂量水平，每个受试者要么表现出药理效应，要么不表现出。假设有 $J$ 个有序剂量水平 $\\{d_1, d_2, \\dots, d_J\\}$，在剂量 $d_j$ 下测试了 $n_j$ 名受试者，其中有 $r_j$ 名为反应者，产生的经验比例为 $\\hat{p}_j = r_j / n_j$。对于单调的剂量-反应关系，科学上的预期是真实反应概率 $p(d_j)$ 随 $d_j$ 非递减。然而，抽样变异性可能导致经验比例 $\\{\\hat{p}_j\\}$ 变为非单调。\n\n从定性结果的二项模型出发，其中在每个剂量 $d_j$ 下，反应者数量 $r_j$ 来自一个二项分布 Binomial$(n_j, p(d_j))$，在单调性约束 $p(d_1) \\le p(d_2) \\le \\cdots \\le p(d_J)$ 下的非参数最大似然估计量可以通过保序回归获得。产生此估计量的一种构造性算法是池邻近违规者算法 (PAVA)，该算法通过将违反顺序约束的相邻剂量水平组合成块，并为该块指定一个单一的估计值来强制执行单调性。\n\n考虑以下包含 $J = 5$ 个剂量水平的数据集：\n- 剂量水平：$d_1, d_2, d_3, d_4, d_5$。\n- 样本量：$n_1 = 10$, $n_2 = 15$, $n_3 = 20$, $n_4 = 25$, $n_5 = 30$。\n- 反应者：$r_1 = 1$, $r_2 = 5$, $r_3 = 6$, $r_4 = 14$, $r_5 = 16$。\n\n经验比例为 $\\hat{p}_1 = 1/10$, $\\hat{p}_2 = 5/15$, $\\hat{p}_3 = 6/20$, $\\hat{p}_4 = 14/25$, $\\hat{p}_5 = 16/30$。\n\n哪个选项最佳地解释了使用池邻近违规者算法 (PAVA) 进行保序回归以估计单调的 $p(d_j)$，准确地描述了它如何处理非单调的经验比例，并给出了该数据集的正确最终单调估计值？\n\nA. PAVA 按剂量顺序进行，每当发现违反非递减约束的相邻经验比例时，它就将这些相邻剂量合并成一个单一的块。块估计是合并后的经验比例的加权平均值，权重等于相应的样本量 $\\{n_j\\}$；等价地，对于一个块 $\\mathcal{B}$，它将块值设为 $\\sum_{j \\in \\mathcal{B}} r_j \\big/ \\sum_{j \\in \\mathcal{B}} n_j$。它重复合并过程，直到没有相邻的违规情况为止。对于给定的数据，$d_2$ 与 $d_3$ 之间以及 $d_4$ 与 $d_5$ 之间的违规导致形成块 $\\{d_2, d_3\\}$（估计值为 $11/35$）和块 $\\{d_4, d_5\\}$（估计值为 $30/55 = 6/11$），最终得到单调估计值 $p(d_1) = 1/10$, $p(d_2) = p(d_3) = 11/35$, $p(d_4) = p(d_5) = 6/11$。\n\nB. PAVA 合并任何相邻的违规者，但使用合并块中经验比例的简单非加权平均值；对于本数据，这将得到 $p(d_2) = p(d_3) = \\big((5/15) + (6/20)\\big)/2$ 和 $p(d_4) = p(d_5) = \\big((14/25) + (16/30)\\big)/2$，其他剂量保持不变。\n\nC. 为强制执行单调性，PAVA 将任何违规的经验比例替换为前一个剂量的比例（设限），而不进行合并或平均；因此，对于本数据，它将设置 $p(d_3) = 5/15$ 和 $p(d_5) = 14/25$，其他剂量保持不变。\n\nD. PAVA 首先按升序对经验比例进行排序，然后将排序后的值直接赋给原始的剂量顺序以实现单调性，而不进行合并。\n\nE. PAVA 通过最大似然法拟合一条参数逻辑斯蒂曲线 $p(d) = 1/\\big(1 + \\exp(-(\\alpha + \\beta d))\\big)$，并使用其拟合值自动强制执行单调性，从而避免了任何相邻剂量水平的合并。", "solution": "在尝试解答之前，将对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 背景是定性剂量-反应分析。\n- 有 $J$ 个有序剂量水平 $\\{d_1, d_2, \\dots, d_J\\}$。\n- 在每个剂量 $d_j$ 下，测试了 $n_j$ 名受试者，有 $r_j$ 名受试者产生反应。\n- 在剂量 $d_j$ 下的经验反应比例为 $\\hat{p}_j = r_j / n_j$。\n- 假设真实反应概率 $p(d_j)$ 是非递减的：$p(d_1) \\le p(d_2) \\le \\cdots \\le p(d_J)$。\n- 在剂量 $d_j$ 下的反应者数量 $r_j$ 服从二项分布：$r_j \\sim \\text{Binomial}(n_j, p(d_j))$。\n- 在单调性约束下的非参数最大似然估计量是通过保序回归获得的，使用的是池邻近违规者算法 (PAVA)。\n- PAVA 通过合并违反顺序约束的相邻剂量水平来强制执行单调性。\n- 提供的数据集：\n  - 剂量水平数量：$J = 5$。\n  - 剂量水平：$d_1, d_2, d_3, d_4, d_5$。\n  - 样本量：$n_1 = 10$, $n_2 = 15$, $n_3 = 20$, $n_4 = 25$, $n_5 = 30$。\n  - 反应者数量：$r_1 = 1$, $r_2 = 5$, $r_3 = 6$, $r_4 = 14$, $r_5 = 16$。\n- 给出的经验比例为 $\\hat{p}_1 = 1/10$, $\\hat{p}_2 = 5/15$, $\\hat{p}_3 = 6/20$, $\\hat{p}_4 = 14/25$, $\\hat{p}_5 = 16/30$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题在剂量-反应分析和非参数估计的统计理论中有充分的依据。定性结果的二项模型是标准模型。通过 PAVA 进行保序回归是寻找单调二项概率序列的非参数最大似然估计的正确且成熟的方法。该问题在科学上是合理的。\n2.  **适定性**：该问题是适定的。给定一组经验比例及其对应的样本量，PAVA 提供了一组唯一的单调估计值。问题要求对算法及其在特定数据集上的应用进行正确描述，这是一个有唯一解的可解问题。\n3.  **客观性**：问题陈述使用了来自统计学和药理学的清晰、客观和标准的术语。没有主观或含糊不清的语言。\n4.  **一致性和完整性**：所提供的数据是完整且一致的。经验比例是根据给定的反应者数量和样本量正确计算得出的：\n    - $\\hat{p}_1 = r_1 / n_1 = 1 / 10 = 0.1$\n    - $\\hat{p}_2 = r_2 / n_2 = 5 / 15 = 1/3 \\approx 0.333$\n    - $\\hat{p}_3 = r_3 / n_3 = 6 / 20 = 3/10 = 0.3$\n    - $\\hat{p}_4 = r_4 / n_4 = 14 / 25 = 0.56$\n    - $\\hat{p}_5 = r_5 / n_5 = 16 / 30 = 8/15 \\approx 0.533$\n    问题提供了应用 PAVA 算法所需的所有信息。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。它在科学上合理，适定，并包含所有必要的信息。我将继续推导解决方案。\n\n### 解题推导\n目标是在非递减约束 $p^*(d_1) \\le p^*(d_2) \\le p^*(d_3) \\le p^*(d_4) \\le p^*(d_5)$ 下，为经验比例序列 $\\{\\hat{p}_j\\}$ 找到保序回归估计值 $\\{p^*(d_j)\\}$。这通过使用池邻近违规者算法 (PAVA) 来实现。\n\n初始经验比例为：\n$\\hat{\\mathbf{p}} = (\\hat{p}_1, \\hat{p}_2, \\hat{p}_3, \\hat{p}_4, \\hat{p}_5) = (1/10, 5/15, 6/20, 14/25, 16/30)$。\n以小数形式表示，约为 $(0.1, 0.333, 0.3, 0.56, 0.533)$。\n\n我们可以识别出两个违反非递减顺序的地方：\n1.  $\\hat{p}_2 = 5/15 \\approx 0.333 > \\hat{p}_3 = 6/20 = 0.3$。\n2.  $\\hat{p}_4 = 14/25 = 0.56 > \\hat{p}_5 = 16/30 \\approx 0.533$。\n\nPAVA 通过识别和解决这些违规来进行。PAVA 的一种常见实现方式是扫描序列并合并相邻的违规者。\n\n设初始保序估计为经验比例：$p^*_j = \\hat{p}_j$。\n$p^* = (1/10, 5/15, 6/20, 14/25, 16/30)$。\n\n1.  比较 $p^*_1$ 和 $p_2^*$：$1/10 = 0.1 \\le 5/15 \\approx 0.333$。顺序正确。当前解为 $(1/10, 5/15, 6/20, 14/25, 16/30)$。\n\n2.  比较 $p^*_2$ 和 $p_3^*$：$5/15 > 6/20$。这是一个违规。我们合并相邻的块 $\\{2, 3\\}$。这个块的新估计值是比例的加权平均值，权重由样本量 $n_2=15$ 和 $n_3=20$ 给出。这等同于将反应者数量相加后除以受试者总数。\n$$p^*_{\\{2,3\\}} = \\frac{r_2 + r_3}{n_2 + n_3} = \\frac{5 + 6}{15 + 20} = \\frac{11}{35}$$\n数值上，$11/35 \\approx 0.3143$。现在通过用这个新值替换 $p^*_2$ 和 $p^*_3$ 来更新估计序列：$(1/10, 11/35, 11/35, 14/25, 16/30)$。\n我们必须从新块向后检查。$p^*_1 \\le p^*_{\\{2,3\\}}$ 是否成立？$1/10 = 0.1 \\le 11/35 \\approx 0.3143$。顺序得以保持。\n\n3.  从新块继续扫描。比较 $p^*_{\\{2,3\\}}$ 和 $p^*_4$：$11/35 \\approx 0.3143 \\le 14/25 = 0.56$。顺序正确。当前解为 $(1/10, 11/35, 11/35, 14/25, 16/30)$。\n\n4.  比较 $p^*_4$ 和 $p^*_5$：$14/25 = 0.56 > 16/30 \\approx 0.533$。这是一个违规。我们合并相邻的块 $\\{4, 5\\}$。新的估计值为：\n$$p^*_{\\{4,5\\}} = \\frac{r_4 + r_5}{n_4 + n_5} = \\frac{14 + 16}{25 + 30} = \\frac{30}{55} = \\frac{6}{11}$$\n数值上，$6/11 \\approx 0.5454$。估计序列更新为 $(1/10, 11/35, 11/35, 6/11, 6/11)$。\n我们必须向后检查。$p^*_{\\{2,3\\}} \\le p^*_{\\{4,5\\}}$ 是否成立？$11/35 \\approx 0.3143 \\le 6/11 \\approx 0.5454$。顺序得以保持。不需要进一步的合并。\n\n最终的保序估计序列为 $(1/10, 11/35, 11/35, 6/11, 6/11)$。\n该序列是非递减的：\n$1/10 = 0.1$\n$11/35 \\approx 0.314$\n$6/11 \\approx 0.545$\n序列 $0.1 \\le 0.314 = 0.314 \\le 0.545 = 0.545$ 是单调的。\n\n最终估计值为：\n$p^*(d_1) = 1/10$\n$p^*(d_2) = 11/35$\n$p^*(d_3) = 11/35$\n$p^*(d_4) = 6/11$\n$p^*(d_5) = 6/11$\n\n### 逐项分析选项\n\n**A. PAVA 按剂量顺序进行，每当发现违反非递减约束的相邻经验比例时，它就将这些相邻剂量合并成一个单一的块。块估计是合并后的经验比例的加权平均值，权重等于相应的样本量 $\\{n_j\\}$；等价地，对于一个块 $\\mathcal{B}$，它将块值设为 $\\sum_{j \\in \\mathcal{B}} r_j \\big/ \\sum_{j \\in \\mathcal{B}} n_j$。它重复合并过程，直到没有相邻的违规情况为止。对于给定的数据，$d_2$ 与 $d_3$ 之间以及 $d_4$ 与 $d_5$ 之间的违规导致形成块 $\\{d_2, d_3\\}$（估计值为 $11/35$）和块 $\\{d_4, d_5\\}$（估计值为 $30/55 = 6/11$），最终得到单调估计值 $p(d_1) = 1/10$, $p(d_2) = p(d_3) = 11/35$, $p(d_4) = p(d_5) = 6/11$。**\n- 对 PAVA 的描述是正确的。对于二项比例，PAVA 正是使用样本量作为权重来寻找加权平均值的过程，这与合并计数 ($r_j$) 和样本量 ($n_j$) 是相同的。\n- 对数据的应用也是正确的。在 $\\{d_2, d_3\\}$ 和 $\\{d_4, d_5\\}$ 处的违规被正确识别。块估计被正确计算为 $11/35$ 和 $30/55 = 6/11$。最终的单调估计集与上面推导出的结果相符。\n- 结论：**正确**。\n\n**B. PAVA 合并任何相邻的违规者，但使用合并块中经验比例的简单非加权平均值；对于本数据，这将得到 $p(d_2) = p(d_3) = \\big((5/15) + (6/20)\\big)/2$ 和 $p(d_4) = p(d_5) = \\big((14/25) + (16/30)\\big)/2$，其他剂量保持不变。**\n- 这种对平均过程的描述是不正确的。PAVA 产生的是最大似然估计，这需要一个*加权*平均，其中权重是样本量 $n_j$。非加权平均对来自不同样本量的比例给予同等重要性，这在统计上是低效的，并且不对应于最大似然估计 (MLE)。\n- 结论：**不正确**。\n\n**C. 为强制执行单调性，PAVA 将任何违规的经验比例替换为前一个剂量的比例（设限），而不进行合并或平均；因此，对于本数据，它将设置 $p(d_3) = 5/15$ 和 $p(d_5) = 14/25$，其他剂量保持不变。**\n- 这描述了一种不同的、临时的施加单调性的过程。它不是 PAVA 算法，PAVA 算法是由最小化加权平方误差和（或在此背景下最大化似然）的合并-平均过程定义的。\n- 结论：**不正确**。\n\n**D. PAVA 首先按升序对经验比例进行排序，然后将排序后的值直接赋给原始的剂量顺序以实现单调性，而不进行合并。**\n- 这是对 PAVA 的根本性误解。对值进行排序并重新分配会破坏剂量水平和观察到的比例之间的对应关系。PAVA 是在原始位置上调整比例的*值*以满足单调性，而不是重新排序它们。\n- 结论：**不正确**。\n\n**E. PAVA 通过最大似然法拟合一条参数逻辑斯蒂曲线 $p(d) = 1/\\big(1 + \\exp(-(\\alpha + \\beta d))\\big)$，并使用其拟合值自动强制执行单调性，从而避免了任何相邻剂量水平的合并。**\n- 这描述了一种参数化方法（逻辑斯蒂回归），它与 PAVA 执行的非参数保序回归是不同的。问题陈述明确指定了一种非参数方法。除了单调性之外，PAVA 对剂量-反应关系函数形式不做任何假设，而逻辑斯蒂回归则假设了一个特定的 S 形曲线形状。\n- 结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "4984813"}, {"introduction": "传统的剂量-反应分析通常给出一个参数的点估计值，例如单个 $ED_{50}$ 值，但这忽略了其固有的不确定性。现代药理学统计越来越多地采用贝叶斯方法来量化这种不确定性。本项高级练习将向您展示如何利用贝叶斯后验样本进行分析 [@problem_id:4984880]。您将学习一个核心概念：如何将模型参数（如 $\\alpha$ 和 $\\beta$）的后验分布，通过转换，得到我们真正关心的衍生量（如 $ED_p$）的后验分布，从而能够计算可信区间，更全面地理解药物的效力。", "problem": "您的任务是实现一个程序，该程序为一个量效剂量反应模型构建目标反应概率下的有效剂量 $ED_{p}$ 的后验分布。您需要使用斜率和截距参数的后验样本变换来构建该分布，然后用最高后验密度（HPD）区间对其进行总结。该模型设定在药理学中，是用于二元结局的对数剂量逻辑斯谛模型。\n\n从以下基本原理开始。在标准的量效剂量反应模型中，剂量为 $d$ 的每个个体都有一个二元结局 $Y \\in \\{0,1\\}$，该结局被建模为一个伯努利随机变量，其成功概率 $P(Y=1 \\mid d)$ 取决于剂量。在对数剂量逻辑斯谛链接下，该关系由 $ \\operatorname{logit}(P(Y=1 \\mid d)) = \\alpha + \\beta \\ln(d) $ 给出，其中 $ \\operatorname{logit}(x) = \\ln\\!\\left(\\frac{x}{1-x}\\right) $，$ \\alpha $ 是截距参数，$ \\beta $ 是斜率参数，$ d $ 是以 $\\mathrm{mg/kg}$ 为单位的剂量。有效剂量 $ ED_{p} $ 被定义为能使反应概率等于一个指定目标 $ p $ 的剂量 $ d $，其中 $ p \\in (0,1) $。\n\n您的程序必须：\n- 使用后验样本的变换原理：如果 $(\\alpha, \\beta)$ 的后验由独立抽样表示，那么 $ ED_{p} $ 的后验样本是通过将模型定义所蕴含的确定性变换应用于每个 $(\\alpha,\\beta)$ 抽样来获得的。\n- 通过丢弃任何 $ \\beta \\le 0 $ 的后验样本来强制执行与药理学现实性一致的单调性。只有保留的样本才应被变换为 $ ED_{p} $。\n- 计算得到的 $ ED_{p} $ 后验样本的样本中位数。\n- 计算 $ ED_{p} $ 后验样本的 $q$ 质量最高后验密度（HPD）区间，其定义为包含比例为 $ q $ 的样本的最短区间 $[L, U]$。对于从已排序样本 $ \\{x_{(1)}, \\dots, x_{(n)}\\} $ 进行的实际计算，当 $ k = \\lfloor q n \\rfloor $ 时，HPD 区间是在所有有效的 $ i $ 上最小化 $ x_{(i+k)} - x_{(i)} $ 的配对 $[x_{(i)}, x_{(i+k)}]$。\n\n物理单位与答案规范：\n- 所有剂量 $ d $ 和有效剂量 $ ED_{p} $ 的单位均为 $\\mathrm{mg/kg}$。\n- 必须提供可信质量 $ q $，并将其视为小数（例如 $ 0.95 $），而不是使用百分号。\n\n测试套件与参数化：\n对于每个测试用例，您将从一个具有指定均值向量和协方差矩阵的二元正态分布中生成 $(\\alpha,\\beta)$ 的后验样本，然后丢弃 $ \\beta \\le 0 $ 的样本，并变换剩余的样本以获得 $ ED_{p} $ 样本。使用以下包含三个用例的测试套件，每个用例都由一个随机种子、期望的保留样本数量 $ N $、一个均值向量 $ (\\mu_{\\alpha}, \\mu_{\\beta}) $、一个协方差矩阵 $ \\Sigma $、目标概率 $ p $ 和可信质量 $ q $ 指定。\n\n- Case A:\n  - 种子 $ 17 $。\n  - 期望保留样本量 $ N = 4000 $。\n  - 均值向量 $ (\\mu_{\\alpha}, \\mu_{\\beta}) = (-1.2, 1.0) $。\n  - 协方差矩阵 $ \\Sigma = \\begin{pmatrix} 0.15^{2} & -0.015 \\\\ -0.015 & 0.12^{2} \\end{pmatrix} $。\n  - 目标概率 $ p = 0.5 $。\n  - 可信质量 $ q = 0.95 $。\n\n- Case B:\n  - 种子 $ 123 $。\n  - 期望保留样本量 $ N = 2500 $。\n  - 均值向量 $ (\\mu_{\\alpha}, \\mu_{\\beta}) = (0.4, 0.6) $。\n  - 协方差矩阵 $ \\Sigma = \\begin{pmatrix} 0.25^{2} & -0.02 \\\\ -0.02 & 0.18^{2} \\end{pmatrix} $。\n  - 目标概率 $ p = 0.9 $。\n  - 可信质量 $ q = 0.90 $。\n\n- Case C:\n  - 种子 $ 7 $。\n  - 期望保留样本量 $ N = 5000 $。\n  - 均值向量 $ (\\mu_{\\alpha}, \\mu_{\\beta}) = (-2.0, 0.8) $。\n  - 协方差矩阵 $ \\Sigma = \\begin{pmatrix} 0.2^{2} & -0.03 \\\\ -0.03 & 0.15^{2} \\end{pmatrix} $。\n  - 目标概率 $ p = 0.1 $。\n  - 可信质量 $ q = 0.95 $。\n\n实现约束：\n- 对于每个用例，使用给定的种子从指定的二元正态分布中抽取 $(\\alpha,\\beta)$。为确保在丢弃 $ \\beta \\le 0 $ 的抽样后，保留的样本数量等于 $ N $，您可以分批次进行超额采样，直到获得 $ N $ 个有效的抽样。\n- 对于每个用例，计算 $ ED_{p} $ 后验的样本中位数和如上定义的 $ q $ 质量 HPD 区间 $[L,U]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个结果，每个结果本身是包含三个浮点数 $[m, L, U]$ 的列表，分别表示 $ ED_{p} $ 的中位数 $ m $、HPD 下界 $ L $ 和 HPD 上界 $ U $（单位为 $\\mathrm{mg/kg}$）。该行必须具有以下精确格式：\n  - $ [[m_{A},L_{A},U_{A}],[m_{B},L_{B},U_{B}],[m_{C},L_{C},U_{C}]] $。", "solution": "问题陈述被评估为有效。它在科学上基于药理学剂量反应建模和贝叶斯统计的既定原则，在数学和计算上是适定的，并以客观、明确的语言进行规定。所有为获得唯一、可复现解所必需的参数和数据均已提供。用例 C 的协方差矩阵是奇异的，这意味着参数之间存在完全相关性，这代表了一个有效（尽管是退化的）且计算上可行的二元正态分布。\n\n基于统计建模和后验分析的基本原则，解决方案按以下步骤进行。\n\n**1. 对数剂量逻辑斯谛模型的理论框架**\n\n问题指定了一个由对数剂量逻辑斯谛模型控制的量效剂量反应关系。在给定剂量 $d > 0$ 下产生反应的概率 $P$ 被建模为：\n$$\n\\operatorname{logit}(P(Y=1 \\mid d)) = \\alpha + \\beta \\ln(d)\n$$\n其中 $\\operatorname{logit}(p) = \\ln\\left(\\frac{p}{1-p}\\right)$ 是 logit 函数。参数 $\\alpha$ 和 $\\beta$ 分别代表对数剂量尺度上的截距和斜率。正斜率 $\\beta > 0$ 在药理学上是现实的，表示反应概率随剂量增加而增加。\n\n有效剂量 $ED_p$ 被定义为能以特定目标概率 $p \\in (0,1)$ 引起反应的剂量。为了推导 $ED_p$ 的表达式，我们令 $P(Y=1 \\mid d) = p$ 并解出 $d$：\n$$\n\\operatorname{logit}(p) = \\alpha + \\beta \\ln(ED_p)\n$$\n重新整理各项以求解 $\\ln(ED_p)$：\n$$\n\\beta \\ln(ED_p) = \\operatorname{logit}(p) - \\alpha\n$$\n在 $\\beta \\neq 0$ 的条件下，我们可以写出：\n$$\n\\ln(ED_p) = \\frac{\\operatorname{logit}(p) - \\alpha}{\\beta}\n$$\n对两边取指数，得到从模型参数 $(\\alpha, \\beta)$ 到有效剂量 $ED_p$ 的确定性变换：\n$$\nED_p = \\exp\\left(\\frac{\\operatorname{logit}(p) - \\alpha}{\\beta}\\right)\n$$\n这一变换是解决方案的核心。问题中关于丢弃 $\\beta \\le 0$ 的后验样本的约束确保了分母为严格正数，从而得到一个良定义的、为正的 $ED_p$。\n\n**2. 通过样本变换进行贝叶斯后验分析**\n\n该问题采用贝叶斯框架，其中参数 $(\\alpha, \\beta)$ 的不确定性由一个后验概率分布来捕捉。我们被告知，该后验分布的样本将从一个指定的二元正态分布 $(\\alpha, \\beta) \\sim N(\\boldsymbol{\\mu}, \\Sigma)$ 中生成。\n\n该方法的核心是后验样本的变换原理。如果我们有一组从参数后验分布中抽取的 $N$ 个随机样本 $\\{(\\alpha_i, \\beta_i)\\}_{i=1}^N$，我们可以通过对每个样本应用派生出的变换，来获得一组从派生量 $ED_p$ 的后验分布中抽取的 $N$ 个样本 $\\{ED_{p,i}\\}_{i=1}^N$：\n$$\nED_{p,i} = \\exp\\left(\\frac{\\operatorname{logit}(p) - \\alpha_i}{\\beta_i}\\right)\n$$\n这个过程产生了 $ED_p$ 后验分布的一个经验表示，然后可以对其进行总结。\n\n**3. 生成有效的后验样本**\n\n对于每个测试用例，我们需要生成特定数量 $N$ 的有效后验样本。过程如下：\n1. 使用给定的种子初始化一个随机数生成器以保证可复现性。\n2. 从指定的二元正态分布 $N((\\mu_\\alpha, \\mu_\\beta), \\Sigma)$ 中抽取 $(\\alpha, \\beta)$ 样本。\n3. 应用药理学约束，只保留那些 $\\beta > 0$ 的样本。\n4. 重复此采样和筛选过程，可能分批进行，直到收集到恰好 $N$ 个有效样本。\n\n**4. 总结 $ED_p$ 后验分布**\n\n一旦生成了 $N$ 个 $ED_p$ 样本，我们计算两个汇总统计量：\n\n**a. 样本中位数：**\n中位数是集中趋势的一种度量。对于已排序的有效剂量后验样本，记为 $edp_{(1)}, edp_{(2)}, \\dots, edp_{(N)}$，样本中位数是将分布的下半部分与上半部分分开的值。它被计算为样本的第50百分位数。\n\n**b. 最高后验密度（HPD）区间：**\nHPD 区间是一种可信区间，根据定义，对于给定的可信质量 $q$，它是可能的最短区间。对于由样本表示的后验分布，其 $q$ 质量 HPD 区间按以下算法计算：\n1. 将 $N$ 个 $ED_p$ 后验样本按升序排序：$edp_{(1)} \\le edp_{(2)} \\le \\dots \\le edp_{(N)}$。\n2. 确定区间内要包含的样本数量：$k = \\lfloor qN \\rfloor$。\n3. 对于 $i = 1, 2, \\dots, N-k$，考虑所有形式为 $[edp_{(i)}, edp_{(i+k)}]$ 的可能区间。\n4. 计算每个区间的宽度 $w_i = edp_{(i+k)} - edp_{(i)}$。\n5. HPD 区间是使宽度 $w_j$ 最小化的特定区间 $[L, U] = [edp_{(j)}, edp_{(j+k)}]$。该区间代表了包含后验质量比例为 $q$ 的最高概率密度区域。\n\n将此完整流程应用于指定的三个测试用例中的每一个，使用它们各自的参数，以生成最终结果。", "answer": "```python\nimport numpy as np\nfrom scipy.special import logit\n\ndef solve():\n    \"\"\"\n    Solves the quantal dose-response problem for three test cases.\n\n    For each case, it generates posterior samples for (alpha, beta),\n    filters them based on beta > 0, transforms them to EDp samples,\n    and then computes the median and Highest Posterior Density (HPD) interval.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"seed\": 17,\n            \"N\": 4000,\n            \"mean_vec\": np.array([-1.2, 1.0]),\n            \"cov_mat\": np.array([[0.15**2, -0.015], [-0.015, 0.12**2]]),\n            \"p\": 0.5,\n            \"q\": 0.95\n        },\n        {\n            \"name\": \"Case B\",\n            \"seed\": 123,\n            \"N\": 2500,\n            \"mean_vec\": np.array([0.4, 0.6]),\n            \"cov_mat\": np.array([[0.25**2, -0.02], [-0.02, 0.18**2]]),\n            \"p\": 0.9,\n            \"q\": 0.90\n        },\n        {\n            \"name\": \"Case C\",\n            \"seed\": 7,\n            \"N\": 5000,\n            \"mean_vec\": np.array([-2.0, 0.8]),\n            \"cov_mat\": np.array([[0.2**2, -0.03], [-0.03, 0.15**2]]),\n            \"p\": 0.1,\n            \"q\": 0.95\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        seed = case[\"seed\"]\n        N = case[\"N\"]\n        mean_vec = case[\"mean_vec\"]\n        cov_mat = case[\"cov_mat\"]\n        p = case[\"p\"]\n        q = case[\"q\"]\n\n        # 1. Generate N valid posterior samples for (alpha, beta)\n        rng = np.random.default_rng(seed)\n        valid_samples = np.empty((0, 2))\n        \n        while valid_samples.shape[0]  N:\n            num_needed = N - valid_samples.shape[0]\n            # Oversample to efficiently gather the required number of valid samples.\n            # A factor of 1.2 should be sufficient as P(beta=0) is low.\n            # Add a small constant to avoid very small batch sizes.\n            batch_size = int(num_needed * 1.2) + 50\n            \n            draws = rng.multivariate_normal(mean_vec, cov_mat, size=batch_size, check_valid='warn')\n            \n            # Filter samples to enforce the pharmacological constraint beta > 0\n            retained_draws = draws[draws[:, 1] > 0]\n            \n            if valid_samples.shape[0] == 0:\n                valid_samples = retained_draws\n            else:\n                valid_samples = np.vstack([valid_samples, retained_draws])\n\n        # Truncate to exactly N samples\n        alpha_beta_samples = valid_samples[:N, :]\n\n        # 2. Transform samples to the EDp scale\n        logit_p = logit(p)\n        alphas = alpha_beta_samples[:, 0]\n        betas = alpha_beta_samples[:, 1]\n        edp_samples = np.exp((logit_p - alphas) / betas)\n\n        # 3. Compute the sample median\n        median_edp = np.median(edp_samples)\n\n        # 4. Compute the q-mass Highest Posterior Density (HPD) interval\n        sorted_edp = np.sort(edp_samples)\n        \n        # Number of samples in the interval\n        k = int(np.floor(q * N))\n        \n        # There are N - k possible intervals of the form [x_i, x_{i+k}]\n        # We want to find the one with the minimum width.\n        num_intervals = N - k\n        \n        # Calculate widths of all possible intervals in a vectorized way\n        widths = sorted_edp[k:] - sorted_edp[:num_intervals]\n        \n        # Find the index of the interval with the minimum width\n        min_width_idx = np.argmin(widths)\n        \n        # The HPD interval is the one starting at this index\n        hpd_lower = sorted_edp[min_width_idx]\n        hpd_upper = sorted_edp[min_width_idx + k]\n\n        all_results.append([median_edp, hpd_lower, hpd_upper])\n\n    # Format the final output string as specified\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "4984880"}]}