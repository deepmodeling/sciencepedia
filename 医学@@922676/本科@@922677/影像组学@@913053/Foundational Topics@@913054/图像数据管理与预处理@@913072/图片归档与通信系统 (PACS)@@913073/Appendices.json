{"hands_on_practices": [{"introduction": "放射组学分析的核心在于将图像中的信息与人体的解剖结构精确对应。要实现这一点，我们必须能够将图像的像素（或体素）坐标转换为患者身体内的物理坐标。本练习将指导您利用关键的 DICOM 属性，从第一性原理出发，推导出完成此空间映射所需的仿射变换矩阵，这是任何定量图像分析的基础技能。[@problem_id:4555353]", "problem": "在医学影像存档与通信系统 (PACS; Picture Archiving and Communication Systems) 的存档中，一个放射组学工作流必须使用医学数字成像和通信 (DICOM; Digital Imaging and Communications in Medicine) 属性，将三维计算机断层扫描 (CT; Computed Tomography) 容积的体素索引映射到患者坐标。在 DICOM 患者坐标系中，坐标轴定义为左-后-上 (LPS)，即 $x$ 轴指向患者左侧，$y$ 轴指向患者后方，$z$ 轴指向患者上方。该 CT 序列对于一个代表性切片具有以下 DICOM 属性：\n- 像素间距 $(0028,0030)$ 为 $[0.80,\\,0.80]$ 毫米，其中第一个值是沿行方向的间距，第二个值是沿列方向的间距。\n- 切片厚度 $(0018,0050)$ 为 $1.5$ 毫米。\n- 图像方向 (患者) $(0020,0037)$ 为 $\\left[\\frac{\\sqrt{3}}{2},\\,\\frac{1}{2},\\,0,\\,-\\frac{1}{2},\\,\\frac{\\sqrt{3}}{2},\\,0\\right]$，它分别给出了图像平面行轴和列轴的方向余弦。\n- 对于第一个切片 $(k=0)$，图像位置 (患者) $(0020,0032)$ 为 $\\left[-120,\\,-90,\\,-50\\right]$ 毫米，给出了从零开始的索引 $(i,j,k)=(0,0,0)$ 处体素中心的患者空间坐标。\n\n假设图像平面坐标轴在 LPS 患者坐标系中构成一个标准正交基，并且切片间的方向由行和列方向向量通过右手定则得到的法向量给出。使用从零开始的体素索引 $(i,j,k)$，其中 $i$ 沿图像列方向递增，$j$ 沿图像行方向递增，$k$ 随采集顺序的切片编号递增。从第一性原理（坐标基、方向余弦和 $\\mathbb{R}^{3}$ 中的线性映射）出发，推导将齐次体素索引映射到齐次患者坐标的仿射变换，即求 $4\\times 4$ 矩阵 $A$，使得\n$$\n\\begin{pmatrix}\nx \\\\\ny \\\\\nz \\\\\n1\n\\end{pmatrix}\n=\nA\n\\begin{pmatrix}\ni \\\\\nj \\\\\nk \\\\\n1\n\\end{pmatrix}.\n$$\n以毫米为单位，将 $A$ 的元素按行主序报告为单个行向量。使用精确的解析值，不要四舍五入。距离以毫米表示，如果在中间推理中出现角度，则酌情以弧度或度表示；最终报告的变换条目必须以毫米为单位。最终答案必须是完全按照指示呈现的单个解析表达式（矩阵元素的行向量）。", "solution": "用户希望求解仿射变换矩阵 A，该矩阵将齐次体素索引 (i, j, k) 映射到齐次患者坐标 (x, y, z)。我的方法如下：\n\n1.  **问题验证：**\n    *   **第一步：提取已知条件：**\n        *   患者坐标系：左-后-上 (LPS)。\n        *   体素索引：$(i, j, k)$，从零开始。$i$ 沿列递增，$j$ 沿行递增，$k$ 沿切片递增。\n        *   像素间距 (0028,0030)：$[\\Delta j, \\Delta i] = [0.80, 0.80]$ 毫米。因此，行间距 $\\Delta j = 0.80$ 毫米，列间距 $\\Delta i = 0.80$ 毫米。\n        *   切片厚度 (0018,0050)：$\\Delta k = 1.5$ 毫米。\n        *   图像方向 (患者) (0020,0037)：$[\\frac{\\sqrt{3}}{2}, \\frac{1}{2}, 0, -\\frac{1}{2}, \\frac{\\sqrt{3}}{2}, 0]$。这定义了行方向向量 $\\vec{F} = (\\frac{\\sqrt{3}}{2}, \\frac{1}{2}, 0)$ 和列方向向量 $\\vec{G} = (-\\frac{1}{2}, \\frac{\\sqrt{3}}{2}, 0)$。\n        *   图像位置 (患者) (0020,0032)：对于体素 $(i, j, k) = (0, 0, 0)$，坐标为 $\\vec{P}_{000} = [-120, -90, -50]$ 毫米。\n        *   任务：在方程 $\\begin{pmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{pmatrix} = A \\begin{pmatrix} i \\\\ j \\\\ k \\\\ 1 \\end{pmatrix}$ 中求出 $4 \\times 4$ 矩阵 $A$。\n    *   **第二步：使用提取的已知条件进行验证：**\n        *   该问题在科学上基于医学成像的 DICOM 标准和线性代数。所提供的值和概念在放射学和医学物理学中是标准的。\n        *   该问题是适定 (well-posed) 的。构建变换矩阵所需的所有信息都已提供，并且目标已明确说明。\n        *   该问题是客观的，使用了来自 DICOM 规范的精确、标准化的术语。\n        *   数据是一致的。例如，给定的方向向量 $\\vec{F}$ 和 $\\vec{G}$ 是单位向量并且相互正交，这符合图像平面标准正交基的要求。\n    *   **第三步：结论和行动：** 该问题有效。我将继续进行求解。\n\n2.  **解题推导：**\n\n该问题要求推导一个 $4 \\times 4$ 的仿射变换矩阵 $A$，该矩阵将体素索引 $(i, j, k)$ 的齐次坐标映射到其在患者坐标系中位置 $(x, y, z)$ 的齐次坐标。该变换定义为：\n$$\n\\begin{pmatrix}\nx \\\\\ny \\\\\nz \\\\\n1\n\\end{pmatrix}\n=\nA\n\\begin{pmatrix}\ni \\\\\nj \\\\\nk \\\\\n1\n\\end{pmatrix}\n$$\n矩阵 $A$ 的一般形式为：\n$$\nA =\n\\begin{pmatrix}\nM_{11}  M_{12}  M_{13}  T_x \\\\\nM_{21}  M_{22}  M_{23}  T_y \\\\\nM_{31}  M_{32}  M_{33}  T_z \\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n其中，$3 \\times 3$ 子矩阵 $M$ 代表变换的缩放和旋转部分，向量 $\\vec{T} = (T_x, T_y, T_z)$ 代表平移部分。\n\n具有索引 $(i, j, k)$ 的体素中心的位置 $\\vec{P}(i, j, k) = (x, y, z)$ 可以表示为按索引缩放的基向量的线性组合，再加上一个对应于原点体素位置的偏移量。\n$$\n\\vec{P}(i,j,k) = \\vec{P}(0,0,0) + i \\cdot \\vec{d_i} + j \\cdot \\vec{d_j} + k \\cdot \\vec{d_k}\n$$\n这可以写成矩阵形式：\n$$\n\\begin{pmatrix}\nx \\\\\ny \\\\\nz\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n|  |  | \\\\\n\\vec{d_i}  \\vec{d_j}  \\vec{d_k} \\\\\n|  |  |\n\\end{pmatrix}\n\\begin{pmatrix}\ni \\\\\nj \\\\\nk\n\\end{pmatrix}\n+\n\\begin{pmatrix}\nP_{000,x} \\\\\nP_{000,y} \\\\\nP_{000,z}\n\\end{pmatrix}\n$$\n向量 $\\vec{d_i}$、$\\vec{d_j}$ 和 $\\vec{d_k}$ 分别是在患者坐标中对应于体素索引 $i$、$j$ 和 $k$ 单位增量的位移向量。这些向量构成了矩阵 $A$ 的前三列。平移向量 $\\vec{T}$ 是原点体素 $\\vec{P}(0,0,0)$ 的坐标，构成了 $A$ 矩阵第四列的前三个元素。\n\n我们现在将根据所提供的 DICOM 属性确定这些向量。\n\n**1. 方向向量：**\nDICOM 属性“图像方向 (患者)” $(0020,0037)$ 提供了行轴和列轴的方向余弦。\n行方向向量 $\\vec{F}$ 对应于 $j$ 索引的增量。\n$$ \\vec{F} = \\begin{pmatrix} \\frac{\\sqrt{3}}{2} \\\\ \\frac{1}{2} \\\\ 0 \\end{pmatrix} $$\n列方向向量 $\\vec{G}$ 对应于 $i$ 索引的增量。\n$$ \\vec{G} = \\begin{pmatrix} -\\frac{1}{2} \\\\ \\frac{\\sqrt{3}}{2} \\\\ 0 \\end{pmatrix} $$\n切片前进方向 $\\vec{H}$ 由行向量和列向量的叉积给出，即 $\\vec{H} = \\vec{F} \\times \\vec{G}$。\n$$ \\vec{H} = \\begin{pmatrix} \\frac{\\sqrt{3}}{2} \\\\ \\frac{1}{2} \\\\ 0 \\end{pmatrix} \\times \\begin{pmatrix} -\\frac{1}{2} \\\\ \\frac{\\sqrt{3}}{2} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} (\\frac{1}{2})(0) - (0)(\\frac{\\sqrt{3}}{2}) \\\\ (0)(-\\frac{1}{2}) - (\\frac{\\sqrt{3}}{2})(0) \\\\ (\\frac{\\sqrt{3}}{2})(\\frac{\\sqrt{3}}{2}) - (\\frac{1}{2})(-\\frac{1}{2}) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{3}{4} + \\frac{1}{4} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\n\n**2. 间距和缩放后的方向向量：**\n这些单位向量必须按每个方向上体素之间的间距进行缩放。\n- $i$ 索引（列）的间距是像素间距的第二个值，$\\Delta i = 0.80 \\, \\text{mm} = \\frac{4}{5} \\, \\text{mm}$。\n- $j$ 索引（行）的间距是像素间距的第一个值，$\\Delta j = 0.80 \\, \\text{mm} = \\frac{4}{5} \\, \\text{mm}$。\n- $k$ 索引（切片）的间距是切片厚度，$\\Delta k = 1.5 \\, \\text{mm} = \\frac{3}{2} \\, \\text{mm}$。\n\n构成矩阵 $M$ 各列的缩放后向量是：\n- 对于索引 $i$：$\\vec{d_i} = \\Delta i \\cdot \\vec{G} = \\frac{4}{5} \\begin{pmatrix} -\\frac{1}{2} \\\\ \\frac{\\sqrt{3}}{2} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -\\frac{2}{5} \\\\ \\frac{2\\sqrt{3}}{5} \\\\ 0 \\end{pmatrix}$。这是 $M$ 的第一列。\n- 对于索引 $j$：$\\vec{d_j} = \\Delta j \\cdot \\vec{F} = \\frac{4}{5} \\begin{pmatrix} \\frac{\\sqrt{3}}{2} \\\\ \\frac{1}{2} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\frac{2\\sqrt{3}}{5} \\\\ \\frac{2}{5} \\\\ 0 \\end{pmatrix}$。这是 $M$ 的第二列。\n- 对于索引 $k$：$\\vec{d_k} = \\Delta k \\cdot \\vec{H} = \\frac{3}{2} \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{3}{2} \\end{pmatrix}$。这是 $M$ 的第三列。\n\n**3. 平移向量：**\n平移向量 $\\vec{T}$ 由“图像位置 (患者)”属性 $(0020,0032)$ 给出，该属性指定了体素 $(i,j,k)=(0,0,0)$ 中心的坐标。\n$$ \\vec{T} = \\vec{P}(0,0,0) = \\begin{pmatrix} -120 \\\\ -90 \\\\ -50 \\end{pmatrix} $$\n\n**4. 组装仿射矩阵 A：**\n我们现在使用向量 $\\vec{d_i}$、$\\vec{d_j}$、$\\vec{d_k}$ 作为前三列，使用 $\\vec{T}$ 作为第四列的平移部分，来组装 $4 \\times 4$ 矩阵 $A$。最后一行是 $[0, 0, 0, 1]$ 以完成齐次变换。\n$$\nA = \\begin{pmatrix}\n\\vec{d_i}  \\vec{d_j}  \\vec{d_k}  \\vec{T} \\\\\n0  0  0  1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\frac{2}{5}  \\frac{2\\sqrt{3}}{5}  0  -120 \\\\\n\\frac{2\\sqrt{3}}{5}  \\frac{2}{5}  0  -90 \\\\\n0  0  \\frac{3}{2}  -50 \\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n题目要求按行主序给出该矩阵的 16 个元素。\n元素如下：\n第 1 行：$[-\\frac{2}{5}, \\frac{2\\sqrt{3}}{5}, 0, -120]$\n第 2 行：$[\\frac{2\\sqrt{3}}{5}, \\frac{2}{5}, 0, -90]$\n第 3 行：$[0, 0, \\frac{3}{2}, -50]$\n第 4 行：$[0, 0, 0, 1]$\n将这些元素连接成一个单一的行向量，即构成最终答案。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-\\frac{2}{5}  \\frac{2\\sqrt{3}}{5}  0  -120  \\frac{2\\sqrt{3}}{5}  \\frac{2}{5}  0  -90  0  0  \\frac{3}{2}  -50  0  0  0  1\n\\end{pmatrix}\n}\n$$", "id": "4555353"}, {"introduction": "在处理一个图像序列（例如一次 CT 扫描的所有切片）之前，确保数据质量至关重要。如果一个序列中的不同切片具有不一致的几何参数（如不同的像素间距或扫描方向），那么提取的放射组学特征将是不可靠的。本练习是一个动手编程挑战，要求您基于 DICOM 几何属性，实现一个“预检”一致性检查器，以自动识别并标记那些内部不一致的图像序列。[@problem_id:4555330]", "problem": "您正在放射组学（radiomics）领域从事图像存档与通信系统（PACS）和医学数字成像与通信（DICOM）标准相关的工作。在特征提取之前，必须验证序列层面的几何一致性，以避免混合具有不兼容空间描述符的切片。一个序列是一组切片的集合。每个切片提供三个元数据元素：像素间距（Pixel Spacing）（两个值，分别表示行和列的间距，单位为毫米），切片厚度（Slice Thickness）（单位为毫米），以及图像方向（患者）（Image Orientation (Patient)），由六个实数组成，代表两个方向余弦向量，即行方向向量和列方向向量。\n\n基本原理：\n- 在 DICOM 中，像素间距（Pixel Spacing）定义为图像平面上行和列方向上相邻像素中心之间的物理距离，单位为毫米。设切片 $i$ 的像素间距向量为 $\\mathbf{p}_i = \\left(p^{\\text{row}}_i, p^{\\text{col}}_i\\right)$，单位为毫米。\n- 切片厚度（Slice Thickness）是名义上的切片宽度，单位为毫米，对于切片 $i$ 表示为 $t_i$。\n- 图像方向（患者）（Image Orientation (Patient)）存储了两个方向余弦：单位向量 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 和 $\\mathbf{c}_i \\in \\mathbb{R}^3$，分别代表图像的行和列在患者坐标系中的方向。根据定义，$\\mathbf{r}_i$ 和 $\\mathbf{c}_i$ 应该是标准正交的，即 $\\lVert \\mathbf{r}_i \\rVert = 1$，$\\lVert \\mathbf{c}_i \\rVert = 1$，且 $\\mathbf{r}_i \\cdot \\mathbf{c}_i = 0$。\n\n设计并实现一个序列的预检一致性检查器，如果违反以下任何条件，则标记为不一致：\n1. 跨切片的像素间距一致性：对于一个以毫米为单位的容差 $\\tau_{\\text{ps}}$，要求对于所有切片 $i$，满足 $\\lVert \\mathbf{p}_i - \\mathbf{p}_0 \\rVert_{\\infty} \\le \\tau_{\\text{ps}}$，其中 $\\lVert \\cdot \\rVert_{\\infty}$ 是最大范数，切片 $0$ 是参考切片。\n2. 跨切片的切片厚度一致性：对于一个以毫米为单位的容差 $\\tau_{\\text{thick}}$，要求对于所有切片 $i$，满足 $\\lvert t_i - t_0 \\rvert \\le \\tau_{\\text{thick}}$。\n3. 每个切片的图像方向（患者）标准正交性：对于一个无量纲的容差 $\\tau_{\\text{ortho}}$，要求对于所有切片 $i$，满足 $\\lvert \\lVert \\mathbf{r}_i \\rVert - 1 \\rvert \\le \\tau_{\\text{ortho}}$，$\\lvert \\lVert \\mathbf{c}_i \\rVert - 1 \\rvert \\le \\tau_{\\text{ortho}}$，以及 $\\lvert \\mathbf{r}_i \\cdot \\mathbf{c}_i \\rvert \\le \\tau_{\\text{ortho}}$。\n4. 跨切片的图像方向（患者）一致性：对于一个无量纲的容差 $\\tau_{\\text{ori}}$，要求对于所有切片 $i$，满足以下两个条件之一：\n   $\\max\\left(\\lVert \\mathbf{r}_i - \\mathbf{r}_0 \\rVert_{\\infty}, \\lVert \\mathbf{c}_i - \\mathbf{c}_0 \\rVert_{\\infty}\\right) \\le \\tau_{\\text{ori}}$\n   或\n   $\\max\\left(\\lVert \\mathbf{r}_i + \\mathbf{r}_0 \\rVert_{\\infty}, \\lVert \\mathbf{c}_i + \\mathbf{c}_0 \\rVert_{\\infty}\\right) \\le \\tau_{\\text{ori}}$，\n   这允许 $\\mathbf{r}$ 和 $\\mathbf{c}$ 同时发生符号翻转而不改变图像平面的方向。\n\n如果任何检查失败，该序列必须被标记为不一致，否则为一致。将空序列视为不一致。\n\n使用以下容差：\n- $\\tau_{\\text{ps}} = 0.001$ 毫米，\n- $\\tau_{\\text{thick}} = 0.001$ 毫米，\n- $\\tau_{\\text{ortho}} = 0.001$，\n- $\\tau_{\\text{ori}} = 0.001$。\n\n测试套件：\n提供七个序列。每个切片由一个元组 $(\\mathbf{p}_i, t_i, \\mathbf{r}_i, \\mathbf{c}_i)$ 表示，其中 $\\mathbf{p}_i$ 是 $(p^{\\text{row}}_i, p^{\\text{col}}_i)$，单位为毫米；$t_i$ 的单位为毫米；$\\mathbf{r}_i$ 和 $\\mathbf{c}_i$ 是 $(x,y,z)$ 方向余弦。\n\n序列 $1$ (一致，微小噪声在容差范围内):\n- 切片 $1$: $\\mathbf{p}_1 = (0.7, 0.7)$, $t_1 = 2.5$, $\\mathbf{r}_1 = (1, 0, 0)$, $\\mathbf{c}_1 = (0, 1, 0)$。\n- 切片 $2$: $\\mathbf{p}_2 = (0.7000004, 0.7)$, $t_2 = 2.5000003$, $\\mathbf{r}_2 = (1, 0, 0)$, $\\mathbf{c}_2 = (0, 1, 0)$。\n- 切片 $3$: $\\mathbf{p}_3 = (0.7, 0.6999995)$, $t_3 = 2.5$, $\\mathbf{r}_3 = (1, 0, 0)$, $\\mathbf{c}_3 = (0, 1, 0)$。\n\n序列 $2$ (像素间距不一致，一个切片超出容差):\n- 切片 $1$: $\\mathbf{p}_1 = (0.7, 0.7)$, $t_1 = 2.5$, $\\mathbf{r}_1 = (1, 0, 0)$, $\\mathbf{c}_1 = (0, 1, 0)$。\n- 切片 $2$: $\\mathbf{p}_2 = (0.7009, 0.7)$, $t_2 = 2.5$, $\\mathbf{r}_2 = (1, 0, 0)$, $\\mathbf{c}_2 = (0, 1, 0)$。\n- 切片 $3$: $\\mathbf{p}_3 = (0.7, 0.702)$, $t_3 = 2.5$, $\\mathbf{r}_3 = (1, 0, 0)$, $\\mathbf{c}_3 = (0, 1, 0)$。\n\n序列 $3$ (切片厚度不一致):\n- 切片 $1$: $\\mathbf{p}_1 = (1.0, 1.0)$, $t_1 = 1.0$, $\\mathbf{r}_1 = (0, 1, 0)$, $\\mathbf{c}_1 = (1, 0, 0)$。\n- 切片 $2$: $\\mathbf{p}_2 = (1.0, 1.0)$, $t_2 = 1.001$, $\\mathbf{r}_2 = (0, 1, 0)$, $\\mathbf{c}_2 = (1, 0, 0)$。\n- 切片 $3$: $\\mathbf{p}_3 = (1.0, 1.0)$, $t_3 = 1.002$, $\\mathbf{r}_3 = (0, 1, 0)$, $\\mathbf{c}_3 = (1, 0, 0)$。\n\n序列 $4$ (跨切片方向不一致):\n- 切片 $1$: $\\mathbf{p}_1 = (0.9, 0.9)$, $t_1 = 3.0$, $\\mathbf{r}_1 = (1, 0, 0)$, $\\mathbf{c}_1 = (0, 1, 0)$。\n- 切片 $2$: $\\mathbf{p}_2 = (0.9, 0.9)$, $t_2 = 3.0$, $\\mathbf{r}_2 = (1, 0, 0)$, $\\mathbf{c}_2 = (0, 1, 0)$。\n- 切片 $3$: $\\mathbf{p}_3 = (0.9, 0.9)$, $t_3 = 3.0$, $\\mathbf{r}_3 = (1, 0, 0)$, $\\mathbf{c}_3 = (0, 0.999, 0.04472)$。\n\n序列 $5$ (通过同时符号翻转实现方向一致):\n- 切片 $1$: $\\mathbf{p}_1 = (0.8, 0.8)$, $t_1 = 4.0$, $\\mathbf{r}_1 = (1, 0, 0)$, $\\mathbf{c}_1 = (0, 1, 0)$。\n- 切片 $2$: $\\mathbf{p}_2 = (0.8, 0.8)$, $t_2 = 4.0$, $\\mathbf{r}_2 = (-1, 0, 0)$, $\\mathbf{c}_2 = (0, -1, 0)$。\n- 切片 $3$: $\\mathbf{p}_3 = (0.8, 0.8)$, $t_3 = 4.0$, $\\mathbf{r}_3 = (-1, 0, 0)$, $\\mathbf{c}_3 = (0, -1, 0)$。\n\n序列 $6$ (单个切片，方向标准正交，根据定义跨切片一致):\n- 切片 $1$: $\\mathbf{p}_1 = (0.6, 0.6)$, $t_1 = 5.0$, $\\mathbf{r}_1 = (0.70710678, 0.70710678, 0)$, $\\mathbf{c}_1 = (-0.70710678, 0.70710678, 0)$。\n\n序列 $7$ (边界情况：像素间距差异恰好等于容差):\n- 切片 $1$: $\\mathbf{p}_1 = (0.8, 0.8)$, $t_1 = 5.0$, $\\mathbf{r}_1 = (1, 0, 0)$, $\\mathbf{c}_1 = (0, 1, 0)$。\n- 切片 $2$: $\\mathbf{p}_2 = (0.801, 0.8)$, $t_2 = 5.0$, $\\mathbf{r}_2 = (1, 0, 0)$, $\\mathbf{c}_2 = (0, 1, 0)$。\n- 切片 $3$: $\\mathbf{p}_3 = (0.8, 0.799)$, $t_3 = 5.0$, $\\mathbf{r}_3 = (1, 0, 0)$, $\\mathbf{c}_3 = (0, 1, 0)$。\n\n程序行为要求：\n- 使用给定的容差实现上述四个检查。\n- 对于每个序列，输出一个布尔值：如果序列不一致（被标记），则为 $True$；如果一致，则为 $False$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$\\left[\\text{True},\\text{False},\\dots\\right]$）。由于布尔值是无量纲的，输出中不包含任何物理单位。\n\n您的程序不得读取任何输入，并且必须使用上面提供的、嵌入在代码中的测试套件值。程序必须确定性地运行，并以上述指定格式为七个序列生成布尔值。", "solution": "该问题要求设计并实现一个用于一系列医学图像的预检一致性检查器，特别是在放射组学中使用的 DICOM 标准背景下。一个序列只有当其所有组成切片都满足一组严格的几何标准（包括单个切片内部的标准以及切片之间的相对标准）时，才被视为一致。不一致的序列会被标记出来，以防止其用于后续分析，因为这些分析要求高质量和同质性的数据。\n\n验证基于四个特定的检查，任何一个检查的失败都会导致整个序列被标记为不一致。该算法被设计为系统地应用这些检查。\n\n首先，我们处理空序列的边缘情况。这样的序列不包含任何信息，因此根据公理定义为不一致。对于非空序列，第一个切片（索引为 $i=0$）被指定为参考切片，所有其他切片都将与之比较以检查切片间的一致性。算法会遍历序列中的每个切片，执行必要的检查。\n\n四个一致性检查的详细说明如下：\n\n1.  **图像方向（患者）标准正交性（切片内）**：这是最基本的检查，确保每个切片坐标系的几何完整性。对于每个切片 $i$，其行方向余弦向量 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 和列方向余弦向量 $\\mathbf{c}_i \\in \\mathbb{R}^3$ 必须是标准正交的。此属性通过使用指定的容差 $\\tau_{\\text{ortho}}$ 的三个条件进行验证：\n    - 行向量必须是单位向量：$\\lvert \\lVert \\mathbf{r}_i \\rVert_2 - 1 \\rvert \\le \\tau_{\\text{ortho}}$，其中 $\\lVert \\cdot \\rVert_2$ 是欧几里得范数。\n    - 列向量必须是单位向量：$\\lvert \\lVert \\mathbf{c}_i \\rVert_2 - 1 \\rvert \\le \\tau_{\\text{ortho}}$。\n    - 行向量和列向量必须正交：$\\lvert \\mathbf{r}_i \\cdot \\mathbf{c}_i \\rvert \\le \\tau_{\\text{ortho}}$。\n    此检查对每个切片（包括参考切片）执行。任何一个切片的失败都会立即导致整个序列无效。\n\n2.  **像素间距一致性（切片间）**：此检查确保平面内分辨率在整个序列中是统一的。对于每个切片 $i$（其中 $i>0$），其像素间距向量 $\\mathbf{p}_i = (p^{\\text{row}}_i, p^{\\text{col}}_i)$ 与参考切片 $\\mathbf{p}_0$ 的像素间距向量进行比较。差异使用无穷范数（或最大范数）进行量化，$\\lVert \\mathbf{d} \\rVert_{\\infty} = \\max(\\lvert d_1 \\rvert, \\lvert d_2 \\rvert, \\dots)$。一致性条件是：\n    $$ \\lVert \\mathbf{p}_i - \\mathbf{p}_0 \\rVert_{\\infty} \\le \\tau_{\\text{ps}} $$\n    其中 $\\tau_{\\text{ps}}$ 是像素间距容差。\n\n3.  **切片厚度一致性（切片间）**：这确保了整个序列中切片的厚度是恒定的。对于每个切片 $i$（其中 $i>0$），其厚度 $t_i$ 与参考厚度 $t_0$ 进行比较。条件是：\n    $$ \\lvert t_i - t_0 \\rvert \\le \\tau_{\\text{thick}} $$\n    其中 $\\tau_{\\text{thick}}$ 是切片厚度容差。\n\n4.  **图像方向（患者）一致性（切片间）**：此检查验证所有切片在空间上是否对齐在同一平面内。任何切片 $i$（其中 $i>0$）的方向必须与参考切片 $0$ 的方向匹配。允许一种特殊情况，即方向向量 $(\\mathbf{r}_i, \\mathbf{c}_i)$ 相对于参考向量 $(\\mathbf{r}_0, \\mathbf{c}_0)$ 同时翻转，即 $(\\mathbf{r}_i, \\mathbf{c}_i) \\approx (-\\mathbf{r}_0, -\\mathbf{c}_0)$，因为这代表相同的成像平面。该检查被表述为一个析取：如果一个切片的方向与参考方向几乎相同，或与翻转后的参考方向几乎相同，则该切片是一致的。使用无穷范数进行向量比较，并使用容差 $\\tau_{\\text{ori}}$，条件是：\n    $$ \\max\\left(\\lVert \\mathbf{r}_i - \\mathbf{r}_0 \\rVert_{\\infty}, \\lVert \\mathbf{c}_i - \\mathbf{c}_0 \\rVert_{\\infty}\\right) \\le \\tau_{\\text{ori}} \\quad \\lor \\quad \\max\\left(\\lVert \\mathbf{r}_i + \\mathbf{r}_0 \\rVert_{\\infty}, \\lVert \\mathbf{c}_i + \\mathbf{c}_0 \\rVert_{\\infty}\\right) \\le \\tau_{\\text{ori}} $$\n    如果这两个条件都不满足，则该切片未通过此检查。\n\n实现过程会遍历整个序列。对于第一个切片（$i=0$），仅执行标准正交性检查。对于所有后续切片（$i>0$），执行所有四个检查。如果在任何点有任何检查失败，则过程终止，并将序列标记为不一致（返回 `True`）。如果循环完成且没有任何失败，则序列被视为一致（返回 `False`）。单切片序列如果通过了标准正交性检查，则是一致的，因为切片间的比较不适用。\n\n以下是该逻辑的 Python 实现：\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_series_consistency(series):\n    \"\"\"\n    Validates a DICOM series for geometric consistency.\n\n    Args:\n        series: A list of slices. Each slice is a tuple containing:\n                - p (np.array): Pixel spacing (row, col) in mm.\n                - t (float): Slice thickness in mm.\n                - r (np.array): Row direction cosine vector (x, y, z).\n                - c (np.array): Column direction cosine vector (x, y, z).\n\n    Returns:\n        bool: True if the series is inconsistent, False otherwise.\n    \"\"\"\n    # Define tolerances as per the problem statement\n    tau_ps = 0.001\n    tau_thick = 0.001\n    tau_ortho = 0.001\n    tau_ori = 0.001\n\n    # An empty series is inconsistent.\n    if not series:\n        return True\n\n    # Establish the first slice as the reference for inter-slice comparisons.\n    p0, t0, r0, c0 = series[0]\n\n    # Iterate through all slices to perform checks.\n    for i in range(len(series)):\n        pi, ti, ri, ci = series[i]\n\n        # Check 3: Image Orientation (Patient) orthonormality (for every slice).\n        # This check must pass for all slices, including the reference.\n        norm_r = np.linalg.norm(ri)\n        norm_c = np.linalg.norm(ci)\n        dot_rc = np.dot(ri, ci)\n\n        if (abs(norm_r - 1) > tau_ortho or\n            abs(norm_c - 1) > tau_ortho or\n            abs(dot_rc) > tau_ortho):\n            return True  # Inconsistent due to non-orthonormality.\n\n        # Inter-slice checks are only performed for slices after the reference slice (i > 0).\n        if i == 0:\n            continue\n\n        # Check 1: Pixel Spacing consistency\n        if np.linalg.norm(pi - p0, ord=np.inf) > tau_ps:\n            return True  # Inconsistent pixel spacing.\n\n        # Check 2: Slice Thickness consistency\n        if abs(ti - t0) > tau_thick:\n            return True  # Inconsistent slice thickness.\n\n        # Check 4: Image Orientation (Patient) consistency\n        # Check for same orientation\n        err_same = max(np.linalg.norm(ri - r0, ord=np.inf),\n                       np.linalg.norm(ci - c0, ord=np.inf))\n        \n        # Check for flipped orientation\n        err_flipped = max(np.linalg.norm(ri + r0, ord=np.inf),\n                          np.linalg.norm(ci + c0, ord=np.inf))\n        \n        # A slice is inconsistent if its orientation is neither same nor flipped.\n        if err_same > tau_ori and err_flipped > tau_ori:\n            return True  # Inconsistent orientation across slices.\n\n    # If all checks pass for all slices, the series is consistent.\n    return False\n\ndef solve():\n    \"\"\"\n    Defines the test suite and runs the consistency checker on each series.\n    \"\"\"\n    # Define the 7 test series from the problem statement.\n    # Each slice is a tuple: (pixel_spacing, slice_thickness, row_vector, col_vector)\n    test_cases = [\n        # Series 1 (consistent, small noise within tolerance)\n        [\n            (np.array([0.7, 0.7]), 2.5, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.7000004, 0.7]), 2.5000003, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.7, 0.6999995]), 2.5, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n        ],\n        # Series 2 (inconsistent pixel spacing)\n        [\n            (np.array([0.7, 0.7]), 2.5, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.7009, 0.7]), 2.5, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.7, 0.702]), 2.5, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n        ],\n        # Series 3 (inconsistent slice thickness)\n        [\n            (np.array([1.0, 1.0]), 1.0, np.array([0.0, 1.0, 0.0]), np.array([1.0, 0.0, 0.0])),\n            (np.array([1.0, 1.0]), 1.001, np.array([0.0, 1.0, 0.0]), np.array([1.0, 0.0, 0.0])),\n            (np.array([1.0, 1.0]), 1.002, np.array([0.0, 1.0, 0.0]), np.array([1.0, 0.0, 0.0])),\n        ],\n        # Series 4 (inconsistent orientation across slices)\n        [\n            (np.array([0.9, 0.9]), 3.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.9, 0.9]), 3.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.9, 0.9]), 3.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 0.999, 0.04472])),\n        ],\n        # Series 5 (consistent orientation via simultaneous sign flip)\n        [\n            (np.array([0.8, 0.8]), 4.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.8, 0.8]), 4.0, np.array([-1.0, 0.0, 0.0]), np.array([0.0, -1.0, 0.0])),\n            (np.array([0.8, 0.8]), 4.0, np.array([-1.0, 0.0, 0.0]), np.array([0.0, -1.0, 0.0])),\n        ],\n        # Series 6 (single slice, consistent by definition)\n        [\n            (np.array([0.6, 0.6]), 5.0, np.array([0.70710678, 0.70710678, 0.0]), np.array([-0.70710678, 0.70710678, 0.0])),\n        ],\n        # Series 7 (boundary case, consistent)\n        [\n            (np.array([0.8, 0.8]), 5.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.801, 0.8]), 5.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.8, 0.799]), 5.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n        ],\n    ]\n\n    # Calculate results for each test case.\n    results = [check_series_consistency(series) for series in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "answer": "$$ \\boxed{[False, True, True, True, False, False, False]} $$", "id": "4555330"}, {"introduction": "放射组学研究的威力常常来自于汇集多家医院的大型数据集，但这也带来了巨大的数据管理挑战。本练习模拟了一个真实的多中心研究场景，您会发现临床中常用的标识符（如检查号）在统一数据时并不可靠。通过这个思想实验，您将学会如何辨析不同 DICOM 标识符的优劣，并设计出一种稳健的策略来确保每项研究都被唯一且正确地识别，这是可重复性研究的基石。[@problem_id:4555309]", "problem": "一个放射组学联盟正在将来自 $3$ 家医院的计算机断层扫描研究数据汇总到一个单一的图像存档和通信系统 (PACS) 中。每个站点导出的医学数字成像和通信 (DICOM) 数据集具有以下特征。\n\n基本背景。在 DICOM 中，研究实例唯一标识符 (StudyInstanceUID) 是一个唯一标识符 (UID)，旨在每个研究全局唯一。而检查号 (Accession Number) 是由放射学信息系统 (RIS) 发出的影像检查申请的标识符，它可能在不同时间或机构间重复使用，并可能因值表示 (Value Representation) 的限制而被截断。去标识化流程可以保留、确定性地重映射或非确定性地重新生成 UID。\n\n站点概况。站点 $A$ 分配的检查号 (Accession Number) 每年都会重复使用；DICOM 的检查号签发者序列 (Issuer of Accession Number Sequence) 通常为空；去标识化会保留 `StudyInstanceUID`。站点 $B$ 使用长的字母数字检查号字符串；当写入 DICOM 时，它们会被截断到短字符串 (Short String) 的长度限制，从而导致冲突；去标识化会确定性地重映射 `StudyInstanceUID`，并且在多次导出中保持一致。站点 $C$ 对产生多个研究（具有不同的 `StudyInstanceUID`）的、持续 $2$ 到 $3$ 天的多日方案使用单一的检查号 (Accession Number)；对于同一基础研究，每次导出事件的去标识化都会重新生成新的、非确定性的 `StudyInstanceUID`。在这 $3$ 个站点中，由于是可选填充，一些对象的检查号 (Accession Number) 字段为空。数据分两个批次到达，相隔数月；该联盟必须在批次内和批次间进行去重，并将标识符整合为一个适用于放射组学的稳定队列密钥。\n\n仅根据上述定义和现实的 DICOM/PACS 行为，哪种策略是在不过度合并无关研究或拆分同一研究，同时仍允许质量控制的情况下，识别和整合跨机构和跨导出的唯一研究的最安全策略？\n\nA. 在规范化大小写并去除标点符号后，使用检查号 (Accession Number)作为全局研究密钥，并通过与机构名称 (Institution Name) 拼接来消除歧义。这种方法偏向于临床申请的概念，并将统一相关的研究，同时避免因规范化引起的冲突。\n\nB. 在所有站点中，使用 `StudyInstanceUID` 作为全局研究密钥。对于站点 $C$ 这种重映射因导出而异的情况，回退到使用 `PatientID` 来连接跨导出的同一研究的副本，因为患者在去标识化后是唯一且持久的。\n\nC. 使用复合键 $(\\text{source\\_site}, \\text{StudyInstanceUID})$ 作为批次内每个研究的主要标识符。维护一个按站点划分的映射表，以便当同一站点（如站点 $C$）重新导出并更改 `StudyInstanceUID` 时，可以通过一个内容衍生的指纹 $H$ 来连接跨导出的研究。该指纹 $H$ 是通过对每个实例的内容哈希值 $h$ 的多重集进行计算得出的，其中 $h$ 包括非个人健康信息的采集不变量和像素校验和（例如，将 `Rows`、`Columns`、`Modality`、`Image Orientation` 的值与每个实例的 `Pixel Data` 的加密哈希值拼接起来），并在哈希前进行排序。仅将检查号 (Accession Number) 用作辅助的质量控制属性，并在存在时考虑检查号签发者序列 (Issuer of Accession Number Sequence)；绝不单纯依据检查号进行合并。\n\nD. 由于重映射的可变性，丢弃 UID，并通过对检查号 (Accession Number) 和研究日期 (Study Date)（规范化为本地时间）进行聚类来识别研究，以便多日方案按日期边界拆分，同时在多次导出中保持同一临床申请的所有序列在一起；这避免了与 UID 相关的不一致性。\n\n选择唯一的最佳选项。", "solution": "### 问题验证\n\n本节对问题陈述进行验证，作为提供解决方案的强制性先决条件。\n\n#### 步骤 1：提取已知信息\n\n问题提供了以下信息：\n\n*   **目标：**为一个放射组学联盟，将来自 $3$ 家医院的计算机断层扫描 (CT) 研究数据汇总到一个单一的图像存档和通信系统 (PACS) 中。\n*   **机构：**站点 $A$、站点 $B$、站点 $C$。\n*   **数据交付：**数据分两个批次到达，相隔数月。\n*   **核心任务：**在批次内和批次间对研究进行去重，并将标识符整合为一个适用于放射组学的稳定队列密钥。\n*   **约束：**解决方案必须避免过度合并无关研究和拆分同一研究。它还必须允许进行质量控制。\n*   **DICOM 背景：**\n    *   `StudyInstanceUID`：旨在作为每个研究的全局唯一标识符 (UID)。\n    *   `Accession Number`：放射学信息系统 (RIS) 发出的影像检查申请的标识符。它可能在不同时间或机构间重复使用，并可能被截断。\n    *   `去标识化`：可以保留、确定性地重映射或非确定性地重新生成 UID。\n*   **特定站点概况：**\n    *   **站点 $A$：**\n        *   `Accession Number` 每年重复使用。\n        *   `Issuer of Accession Number Sequence` 通常为空。\n        *   去标识化会保留 `StudyInstanceUID`。\n    *   **站点 $B$：**\n        *   长的字母数字 `Accession Number` 字符串被截断，导致冲突。\n        *   去标识化会确定性地重映射 `StudyInstanceUID`，并且在多次导出中保持一致。\n    *   **站点 $C$：**\n        *   对于持续 $2$ 到 $3$ 天、产生多个不同研究（每个都有唯一的 `StudyInstanceUID`）的多日方案，使用单一的 `Accession Number`。\n        *   对于同一基础研究，每次导出的去标识化都会重新生成新的、非确定性的 `StudyInstanceUID`。\n*   **通用情况：**在所有 $3$ 个站点中，一些 DICOM 对象的 `Accession Number` 字段为空。\n\n#### 步骤 2：使用提取的已知信息进行验证\n\n*   **科学依据：**该问题牢固地植根于医学信息学和数据工程领域。所描述的 DICOM 属性（`StudyInstanceUID`、`Accession Number`）、PACS 和去标识化流程的行为都非常现实，代表了多中心研究中常见的、有据可查的挑战。\n*   **良构性：**该问题是良构的。它提出了一个明确的目标（创建一个稳定的研究密钥），提供了具体的约束条件（不进行过度合并/拆分），并详细说明了可用标识符的复杂行为。问题要求找出“最安全”的策略，其定义是遵守给定的约束。可以从可用选项中确定唯一的最佳实践。\n*   **客观性：**该问题使用医学影像信息学领域常见的精确、客观和技术性语言进行陈述。没有主观或基于意见的主张。\n*   **完整性和一致性：**该问题提供了足够的细节来系统地评估所提出的策略。每个站点的特征都是独特的，共同构成了一系列复杂但逻辑上一致的挑战，一个稳健的解决方案必须能够应对。设置中没有矛盾。例如，`StudyInstanceUID` 在不同站点间的不同行为（保留、确定性重映射、非确定性重新生成）是现实的场景。\n*   **现实性：**该场景不仅现实，而且是研究联盟面临的数据协调问题的典型代表。像 `Accession Number` 这样的标识符的不可靠性以及去标识化引入的复杂性都是标准的关注点。\n\n#### 步骤 3：结论与行动\n\n问题陈述是**有效的**。这是一个科学上和技术上都合理的问题，具有良构性、客观性和现实性。我现在将着手解决该问题。\n\n### 最优策略的推导\n\n目标是为所有站点和两个数据批次中的每个研究建立一个稳定、唯一的标识符。让我们分析主要可用标识符的适用性。\n\n1.  **对 `Accession Number` 的分析：**\n    *   在站点 $A$，它每年都会被重用。单独使用 `Accession Number`，或者即使与机构标识符结合使用 `($\\text{Site A}$, $\\text{Accession Number})$`，也会导致冲突和不同年份研究的错误合并。\n    *   在站点 $B$，它被截断，导致不同的原始检查号映射到相同的截断值，从而发生冲突。这将导致无关研究的错误合并。\n    *   在站点 $C$，一个单一的 `Accession Number` 与多个不同的研究相关联。将其用作密钥会导致严重的过度合并，将不同的研究混为一谈。\n    *   此外，该字段可能为空，使其无法用作主键。\n    *   **结论：** 在该联盟中，`Accession Number` 作为唯一研究标识的主键是根本不可靠的。它的使用必须被限制在辅助性的、非决定性的角色上，例如用于质量控制或人工审查。\n\n2.  **对 `StudyInstanceUID` 的分析：**\n    *   根据 DICOM 的定义，这是预期的研究唯一标识符。\n    *   在站点 $A$，它被保留，使其成为来自该站点的研究的完美、稳定的密钥。\n    *   在站点 $B$，它被确定性地重映射。这意味着对于一个给定的原始研究，重映射后的 `StudyInstanceUID` 在不同的导出（批次 $1$ 和批次 $2$）中总是一样的。因此，在聚合数据集中，它对于站点 $B$ 的研究是一个稳定且唯一的标识符。\n    *   在站点 $C$，它在每次导出时都会被非确定性地重新生成。这是一个关键的失败点。来自站点 $C$ 的一个研究在批次 $1$ 中的 `StudyInstanceUID` 将与完全相同的研究在批次 $2$ 中重新导出时的 `StudyInstanceUID` 不同。单靠 `StudyInstanceUID` 无法将这些跨批次的相同研究关联起来。\n    *   **结论：** 对于站点 $A$ 和 $B$ 而言，`StudyInstanceUID` 是一个高度可靠的标识符，但对于站点 $C$ 的跨批次整合则会失败。一个全局策略不能仅仅依赖于它。\n\n3.  **综合一个稳健的策略：**\n    *   一个稳健的密钥必须能处理所有站点和批次。由于 `StudyInstanceUID` 在很大程度上是可靠的，策略应基于它，并采用特定机制来处理站点 $C$ 的失败情况。\n    *   为防止任何潜在的（尽管理论上不太可能）跨站点 UID 冲突，最安全的方法是使用一个复合键，例如 $(\\text{source\\_site}, \\text{StudyInstanceUID})$，作为初步标识符。\n    *   对于站点 $C$，要识别出批次 $2$ 中的一个研究与批次 $1$ 中的研究相同（尽管它们的 `StudyInstanceUID` 不同），必须检查数据的*内容*。这需要为研究创建一个“指纹”或“内容哈希”，该指纹或哈希对于像 UID 重新生成这样的元数据变化是不变的。\n    *   一个研究的内容由其包含的图像（实例）集合定义。一个稳健的研究指纹（我们称之为 $H$）可以通过首先为每个实例生成一个哈希值 $h$，然后组合这些实例哈希值来计算得出。\n    *   实例哈希值 $h$ 应基于在给定的去标识化规则下保持不变的数据。这包括像素数据本身（可以使用像 SHA-$256$ 这样的加密函数进行哈希）和不属于个人健康信息 (PHI) 的基本采集参数（例如 `Modality`、`Rows`、`Columns`、`Image Orientation`）。\n    *   为了使研究级别的哈希值 $H$ 具有确定性，实例哈希值的集合 $\\{h_1, h_2, ..., h_n\\}$ 必须按固定顺序组合。一种标准方法是在哈希整个序列之前对实例哈希值进行排序：$H = \\text{hash}(\\text{sort}(\\{h_1, h_2, ..., h_n\\}))$。\n    *   最终策略将包括：\n        a. 对每个传入的研究，计算其内容哈希 $H$。\n        b. 维护一个映射表，将 $(\\text{source\\_site}, H)$ 链接到联盟的一个规范的、持久的研究标识符。\n        c. 对于站点 $A$ 和 $B$，`StudyInstanceUID` 是稳定的，可以用作主要识别手段，内容哈希 $H$ 则作为一个强大的验证工具。\n        d. 对于站点 $C$，内容哈希 $H$ 是在两个批次之间链接相同研究的*唯一*可靠方法。\n        e. `Accession Number` 应作为元数据存储以供人工审查，但绝不能用于自动合并逻辑。\n\n这个推导出的策略是在不过度合并或拆分研究的情况下处理指定条件的最安全、最稳健的方法。\n\n### 选项评估\n\n**A. 在规范化大小写并去除标点符号后，使用检查号 (Accession Number)作为全局研究密钥，并通过与机构名称 (Institution Name) 拼接来消除歧义。这种方法偏向于临床申请的概念，并将统一相关的研究，同时避免因规范化引起的冲突。**\n\n这个选项有根本性的缺陷。它依赖于 `Accession Number`，而问题陈述明确指出其不可靠：在站点 $A$ 会重复使用，在站点 $B$ 会因截断而导致冲突，在站点 $C$ 会代表多个研究。规范化无法解决截断、重用或一对多的关系。这种策略将导致大规模的过度合并和错误的数据链接。\n\n**结论：** 错误。\n\n**B. 在所有站点中，使用 StudyInstanceUID 作为全局研究密钥。对于站点 $C$ 这种重映射因导出而异的情况，回退到使用 PatientID 来连接跨导出的同一研究的副本，因为患者在去标识化后是唯一且持久的。**\n\n这个选项失败有两个主要原因。首先，假设 `PatientID` 在去标识化后是持久且唯一的，这是不安全的，在多中心研究环境中通常也是错误的；患者标识符通常会被假名化，并且映射可能不稳定或不一致。其次，更关键的是，一个患者可以有多个不同的研究。使用 `PatientID` 来链接研究会错误地将属于同一患者的所有研究合并，这违背了识别唯一*研究*的目标。例如，如果重新导出，患者的头部 CT 和腹部 CT 将被视为彼此的副本。\n\n**结论：** 错误。\n\n**C. 使用复合键 $(\\text{source\\_site}, \\text{StudyInstanceUID})$ 作为批次内每个研究的主要标识符。维护一个按站点划分的映射表，以便当同一站点（如站点 $C$）重新导出并更改 `StudyInstanceUID` 时，可以通过一个内容衍生的指纹 $H$ 来连接跨导出的研究。该指纹 $H$ 是通过对每个实例的内容哈希值 $h$ 的多重集进行计算得出的，其中 $h$ 包括非个人健康信息的采集不变量和像素校验和（例如，将 `Rows`、`Columns`、`Modality`、`Image Orientation` 的值与每个实例的 `Pixel Data` 的加密哈希值拼接起来），并在哈希前进行排序。仅将检查号 (Accession Number) 用作辅助的质量控制属性，并在存在时考虑检查号签发者序列 (Issuer of Accession Number Sequence)；绝不单纯依据检查号进行合并。**\n\n这个选项与从第一性原理推导出的稳健策略完全一致。它正确地识别了 `StudyInstanceUID` 和 `Accession Number` 的优缺点。它提议使用一个带有命名空间的 UID，这是一个很好的实践。最重要的是，它通过使用内容衍生的指纹 ($H$)，为问题中最困难的部分——整合站点 $C$ 跨批次的数据——提供了正确且技术上合理的解决方案。它还正确地将 `Accession Number` 降级为次要的、非合并的角色。这个策略是最安全的，因为它对所描述的标识符相关问题具有最强的弹性。\n\n**结论：** 正确。\n\n**D. 由于重映射的可变性，丢弃 UIDs，并通过对检查号 (Accession Number) 和研究日期 (Study Date)（规范化为本地时间）进行聚类来识别研究，以便多日方案按日期边界拆分，同时在多次导出中保持同一临床申请的所有序列在一起；这避免了与 UID 相关的不一致性。**\n\n这个选项很差。丢弃 `StudyInstanceUID` 是一个错误，因为它们对于站点 $A$ 和站点 $B$ 来说是完美的标识符。依赖 `Accession Number` 和 `Study Date` 是有问题的，因为在站点 $B$ 会发生截断，在站点 $C$ 存在一对多的问题。对于站点 $C$，“将同一临床申请的所有序列保持在一起”的目标与所需目标完全相反，因为它会合并不同的研究。按日期边界拆分是一种脆弱的启发式方法，很容易失败（例如，研究跨越午夜边界）。这种方法丢弃了可靠的信息，并用不可靠的启发式方法取而代之。\n\n**结论：** 错误。", "answer": "$$\\boxed{C}$$", "id": "4555309"}]}