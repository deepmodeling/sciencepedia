{"hands_on_practices": [{"introduction": "评估分类模型的第一步，是将其原始预测结果转化为有意义的性能指标。本练习侧重于从混淆矩阵的基本计数中计算精确率（Precision）、召回率（Recall）和 $F_1$ 分数。通过有意省略真阴性（True Negative）的数量，这个问题 [@problem_id:4551730] 旨在引导您深入思考，在医学诊断中常见的数据不平衡场景下，哪些指标对于评估目标类别（通常是少数类）的性能最具有信息价值。", "problem": "一个放射组学系统被开发用于根据从磁共振成像（MRI）中提取的特征将病灶分类为恶性（$+$）或良性（$-$）。在一个独立的多中心留出队列上，该系统产生了以下混淆事件：真阳性（TP）$TP=40$，假阳性（FP）$FP=20$，以及假阴性（FN）$FN=10$。真阴性（TN）的数量未被报告，因为不同机构在良性病例的抽样策略上存在差异。从二元分类中事件率的核心定义出发，推导精确率、召回率和 F₁分数的表达式，并计算它们在该队列上的值。然后，使用基本原理，解释在一个典型的放射组学类别不平衡筛查场景中，当良性病例占主导地位且 $TN$ 远大于 $TP+FN$ 时，应如何相对于准确率来解释 F₁分数。将计算出的三个指标值表示为精确分数。无需四舍五入。按以下顺序提供这三个数字：精确率、召回率、F₁分数。", "solution": "首先验证问题，以确保其具有科学依据、问题定义良好且客观。\n\n**步骤1：提取已知条件**\n- 分类任务：将病灶分为恶性（$+$）或良性（$-$）。\n- 真阳性（$TP$）：$TP=40$。\n- 假阳性（$FP$）：$FP=20$。\n- 假阴性（$FN$）：$FN=10$。\n- 真阴性（$TN$）：未报告。\n- 任务a：推导精确率、召回率和 F₁分数的表达式。\n- 任务b：计算这些指标的值。\n- 任务c：在一个类别不平衡且 $TN$ 远大于 $TP+FN$ 的场景中，解释 F₁分数相对于准确率的解读。\n- 任务d：将计算出的指标表示为精确分数。\n- 任务e：按精确率、召回率、F₁分数的顺序提供最终值。\n\n**步骤2：使用提取的已知条件进行验证**\n问题是有效的。它提出了一个来自放射组学领域的标准二元分类场景，该领域是医学影像分析的一个子领域。所提供的数据（$TP$、$FP$、$FN$）足以计算所要求的指标（精确率、召回率、F₁分数），因为这些指标独立于真阴性计数（$TN$）。明确提及 $TN$ 未报告是一个刻意且现实的约束，而不是一个缺陷。关于在不平衡场景下 F₁分数与准确率的比较这一概念性问题，是机器学习评估中一个基础且重要的话题。该问题是自洽的、科学上合理的且定义明确的。\n\n**步骤3：结论与行动**\n问题有效。将提供完整的解决方案。\n\n**指标的推导与计算**\n\n我们首先定义基本的分类事件：\n- **真阳性（$TP$）**：一个恶性病灶被正确分类为恶性。\n- **假阳性（$FP$）**：一个良性病灶被错误分类为恶性（第一类错误）。\n- **真阴性（$TN$）**：一个良性病灶被正确分类为良性。\n- **假阴性（$FN$）**：一个恶性病灶被错误分类为良性（第二类错误）。\n\n实际阳性（恶性）实例的总数是 $P_{actual} = TP + FN$。\n实际阴性（良性）实例的总数是 $N_{actual} = TN + FP$。\n预测为阳性的实例总数是 $P_{predicted} = TP + FP$。\n预测为阴性的实例总数是 $N_{predicted} = TN + FN$。\n\n**1. 精确率（$P$）**\n精确率，或称阳性预测值（PPV），衡量的是被预测为阳性的病例中，实际为阳性的比例。它回答了这样一个问题：“在所有被系统标记为恶性的病灶中，实际上有多少比例是恶性的？”\n从其定义出发：\n$$P = \\frac{\\text{Number of True Positives}}{\\text{Number of Predicted Positives}}$$\n用混淆事件来表示，即：\n$$P = \\frac{TP}{TP + FP}$$\n使用给定值 $TP=40$ 和 $FP=20$：\n$$P = \\frac{40}{40 + 20} = \\frac{40}{60} = \\frac{2}{3}$$\n\n**2. 召回率（$R$）**\n召回率，也称为灵敏度（Sensitivity）或真阳性率（TPR），衡量的是实际为阳性的病例中，被正确识别出的比例。它回答了这样一个问题：“在所有真实存在的恶性病灶中，系统正确识别了多少比例？”\n从其定义出发：\n$$R = \\frac{\\text{Number of True Positives}}{\\text{Number of Actual Positives}}$$\n用混淆事件来表示，即：\n$$R = \\frac{TP}{TP + FN}$$\n使用给定值 $TP=40$ 和 $FN=10$：\n$$R = \\frac{40}{40 + 10} = \\frac{40}{50} = \\frac{4}{5}$$\n\n**3. F₁分数**\nF₁分数是精确率和召回率的调和平均数。它被用作一个单一指标，来平衡精确率和召回率这两个方面。选择调和平均数是因为它比算术平均数更能惩罚极端值。一个高的 F₁分数要求精确率和召回率都高。\n两个数 $a$ 和 $b$ 的调和平均数的通用公式是 $2 \\frac{ab}{a+b}$。因此，对于精确率 $P$ 和召回率 $R$：\n$$F_1 = 2 \\frac{P \\cdot R}{P + R}$$\n我们可以通过代入 $P$ 和 $R$ 的表达式，直接用 $TP$、$FP$ 和 $FN$ 来推导 F₁分数的表达式：\n$$F_1 = 2 \\frac{\\left(\\frac{TP}{TP + FP}\\right) \\cdot \\left(\\frac{TP}{TP + FN}\\right)}{\\left(\\frac{TP}{TP + FP}\\right) + \\left(\\frac{TP}{TP + FN}\\right)}$$\n$$F_1 = 2 \\frac{\\frac{TP^2}{(TP + FP)(TP + FN)}}{\\frac{TP(TP + FN) + TP(TP + FP)}{(TP + FP)(TP + FN)}}$$\n$$F_1 = \\frac{2 \\cdot TP^2}{TP(TP + FN) + TP(TP + FP)}$$\n从分母中提取公因式 $TP$：\n$$F_1 = \\frac{2 \\cdot TP}{(TP + FN) + (TP + FP)} = \\frac{2 \\cdot TP}{2 \\cdot TP + FP + FN}$$\n这个最终表达式通常更便于直接计算。使用给定值 $TP=40$，$FP=20$ 和 $FN=10$：\n$$F_1 = \\frac{2 \\cdot 40}{2 \\cdot 40 + 20 + 10} = \\frac{80}{80 + 20 + 10} = \\frac{80}{110} = \\frac{8}{11}$$\n\n计算出的值为：精确率 $P = \\frac{2}{3}$，召回率 $R = \\frac{4}{5}$，以及 F₁分数 $F_1 = \\frac{8}{11}$。\n\n**在不平衡场景下对 F₁分数与准确率的解读**\n\n首先，我们必须定义准确率（$ACC$）。准确率是所有预测中正确预测的比例。\n$$ACC = \\frac{\\text{Number of Correct Predictions}}{\\text{Total Number of Predictions}} = \\frac{TP + TN}{TP + TN + FP + FN}$$\n问题指出，在一个典型的放射组学筛查场景中，良性病例占主导地位，这意味着真阴性（$TN$）的数量远大于与阳性（恶性）类别相关的病例数。用数学方式表示为 $TN \\gg (TP + FN)$。\n\n让我们分析在这种条件下准确率的行为。当 $TN$ 相对于其他项（$TP$、$FP$、$FN$）变得非常大时，准确率公式的分子和分母都由 $TN$ 主导：\n$$ACC = \\frac{TP + TN}{TP + TN + FP + FN} \\approx \\frac{TN}{TN + FP}$$\n此外，由于模型不是完全随机的，$FP$ 通常远小于 $TN$。因此，当 $TN \\to \\infty$ 时，该比率趋近于 $1$：\n$$\\lim_{TN \\to \\infty} \\left( \\frac{TP + TN}{TP + TN + FP + FN} \\right) = 1$$\n这揭示了准确率在类别不平衡场景下的一个严重缺陷。一个总是预测多数类（良性）的平凡分类器将有 $TP=0$ 和 $FP=0$。其准确率将为 $ACC = \\frac{TN}{TN + FN}$。如果每999个良性病例中有1个恶性病例（$FN=1, TN=999$），这个平凡分类器将达到 $\\frac{999}{1000} = 99.9\\%$ 的准确率，这会给人一种性能很高的危险误导性印象，而实际上它未能识别出任何它本应发现的恶性病例。\n\n相比之下，F₁分数及其组成部分精确率和召回率，都与 $TN$ 无关：\n$$P = \\frac{TP}{TP+FP}, \\quad R = \\frac{TP}{TP+FN}, \\quad F_1 = \\frac{2 \\cdot TP}{2 \\cdot TP + FP + FN}$$\n这些指标专门评估模型在阳性类别上的性能。\n- **精确率**关注阳性预测的可靠性，直接对应于假警报（$FP$）的成本。\n- **召回率**关注模型找出所有阳性病例的能力，直接对应于漏诊病例（$FN$）的成本。\n一个平凡的“永远预测良性”的分类器会有 $TP=0$，导致 $P=0$、$R=0$ 和 $F_1=0$，这正确地反映了它在检测恶性类别方面完全没有用处。\n\nF₁分数将精确率和召回率之间的权衡综合成一个单一的数值。在医学筛查中，两者都至关重要：低召回率（高 $FN$）意味着漏掉癌症，这是一个严重的失败。低精确率（高 $FP$）意味着让许多健康个体接受不必要、昂贵且有压力的后续检查。在这种不平衡的设置中，F₁分数比准确率更能提供一个稳健且相关的模型实用性度量，因为它不会因为大量被正确识别的多数类病例（$TN$）而被夸大。它恰当地将评估重点放在与少数、高风险的感兴趣类别相关的性能上。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{2}{3} & \\frac{4}{5} & \\frac{8}{11}\n\\end{pmatrix}\n}\n$$", "id": "4551730"}, {"introduction": "一个模型的性能并非其固有的恒定属性，而是与其部署应用的群体特征紧密相关。本练习 [@problem_id:4551711] 探讨了疾病流行率（prevalence）对分类器预测能力，特别是对其阳性预测值（PPV，即精确率）的决定性影响。通过应用贝叶斯定理，您将定量地分析一个模型从均衡的病例对照研究环境转移到低流行率的群体筛查场景时，其实际效用会如何发生巨大变化。", "problem": "为了检测早期肺部恶性肿瘤，我们评估了一个基于胸部计算机断层扫描（CT）图像的纹理和形状特征衍生的影像组学分类器。在一项病例对照研究中，该分类器实现了灵敏度 $0.85$ 和特异度 $0.95$，研究中的患病率为 $0.10$。预期的部署环境是一个人群筛查项目，其目标患病率为 $0.02$。\n\n请仅使用基础的概率定义和成熟的原理，即贝叶斯定理和全概率定律，从灵敏度 $P(T^{+}\\,|\\,D)$、特异度 $P(T^{-}\\,|\\,\\bar{D})$ 和患病率 $P(D)$ 的定义出发，其中 $D$ 表示事件“存在恶性肿瘤”，$\\bar{D}$ 为其补集，$T^{+}$/$T^{-}$ 表示分类器的阳性和阴性输出。以此为基础，推导阳性预测值（PPV；也称为精确率）$P(D\\,|\\,T^{+})$ 和阴性预测值（NPV）$P(\\bar{D}\\,|\\,T^{-})$ 作为灵敏度、特异度和患病率的函数表达式。计算在研究患病率 $0.10$ 和目标患病率 $0.02$ 下的PPV和NPV的数值，所有概率均以小数表示。\n\n最后，将以下比率作为您的唯一数值答案：\n$$\n\\rho \\;=\\; \\frac{\\text{目标患病率下的PPV}}{\\text{研究患病率下的PPV}},\n$$\n四舍五入到四位有效数字。无需单位。在您的推导过程中，请简要解释患病率的变化对PPV（精确率）、NPV、召回率（灵敏度）和F$_1$分数的影响，特别是在将影像组学模型从病例对照研究部署到筛查人群的背景下。", "solution": "该问题具有科学依据，提问清晰且客观。所有必要数据均已提供，任务是基于概率论的基本原理，对不同患病率下的诊断测试性能进行标准分析。我们开始进行推导和求解。\n\n设 $D$ 为存在恶性肿瘤的事件，$\\bar{D}$ 为其补集（不存在恶性肿瘤）。设 $T^{+}$ 和 $T^{-}$ 分别为分类器结果为阳性和阴性的事件。所提供的量为：\n- 灵敏度 ($S_e$)：给定患病条件下测试结果为阳性的概率， $S_e = P(T^{+}|D) = 0.85$。\n- 特异度 ($S_p$)：给定未患病条件下测试结果为阴性的概率， $S_p = P(T^{-}|\\bar{D}) = 0.95$。\n- 患病率 ($p$)：疾病的先验概率， $p = P(D)$。我们有两个给定值：$p_{study} = 0.10$ 和 $p_{target} = 0.02$。\n\n我们的目标是推导阳性预测值（PPV或精确率）$P(D|T^{+})$ 和阴性预测值（NPV）$P(\\bar{D}|T^{-})$ 的表达式，然后计算它们在两种给定患病率下的值。\n\n首先，我们推导PPV的表达式 $P(D|T^{+})$。使用贝叶斯定理：\n$$P(D|T^{+}) = \\frac{P(T^{+}|D) P(D)}{P(T^{+})}$$\n分子包含灵敏度 $P(T^{+}|D) = S_e$ 和患病率 $P(D) = p$。分母 $P(T^{+})$ 是测试结果为阳性的总概率。我们使用全概率定律将其展开：\n$$P(T^{+}) = P(T^{+}|D)P(D) + P(T^{+}|\\bar{D})P(\\bar{D})$$\n我们可以使用给定的定义来表示此展开式中的各项：\n- $P(T^{+}|D) = S_e$\n- $P(D) = p$\n- $P(\\bar{D}) = 1 - P(D) = 1 - p$\n- $P(T^{+}|\\bar{D})$ 是假阳性率，即 $1 - P(T^{-}|\\bar{D}) = 1 - S_p$。\n\n将这些代入 $P(T^{+})$ 的展开式中：\n$$P(T^{+}) = S_e \\cdot p + (1 - S_p)(1 - p)$$\n现在，将此代回PPV的贝叶斯定理表达式，得到其作为 $S_e$、$S_p$ 和 $p$ 函数的一般形式：\n$$\\text{PPV} = P(D|T^{+}) = \\frac{S_e \\cdot p}{S_e \\cdot p + (1 - S_p)(1 - p)}$$\n\n接下来，我们推导NPV的表达式 $P(\\bar{D}|T^{-})$。同样，根据贝叶斯定理：\n$$P(\\bar{D}|T^{-}) = \\frac{P(T^{-}|\\bar{D}) P(\\bar{D})}{P(T^{-})}$$\n分子包含特异度 $P(T^{-}|\\bar{D}) = S_p$ 和无病的概率 $P(\\bar{D}) = 1 - p$。分母 $P(T^{-})$ 是测试结果为阴性的总概率，使用全概率定律展开：\n$$P(T^{-}) = P(T^{-}|D)P(D) + P(T^{-}|\\bar{D})P(\\bar{D})$$\n我们确定各项：\n- $P(T^{-}|D)$ 是假阴性率，即 $1 - P(T^{+}|D) = 1 - S_e$。\n- $P(D) = p$\n- $P(T^{-}|\\bar{D}) = S_p$\n- $P(\\bar{D}) = 1 - p$\n\n将这些代入 $P(T^{-})$ 的展开式中：\n$$P(T^{-}) = (1 - S_e) \\cdot p + S_p(1 - p)$$\n并将其代回NPV的表达式中：\n$$\\text{NPV} = P(\\bar{D}|T^{-}) = \\frac{S_p (1 - p)}{(1 - S_e) \\cdot p + S_p(1 - p)}$$\n\n现在，我们计算两种情况下的数值。\n给定值为 $S_e = 0.85$ 和 $S_p = 0.95$。\n\n情况1：研究患病率，$p_{study} = 0.10$。\n$$\\text{PPV}_{study} = \\frac{0.85 \\cdot 0.10}{0.85 \\cdot 0.10 + (1 - 0.95)(1 - 0.10)} = \\frac{0.085}{0.085 + (0.05)(0.90)} = \\frac{0.085}{0.085 + 0.045} = \\frac{0.085}{0.130} = \\frac{17}{26} \\approx 0.6538$$\n$$\\text{NPV}_{study} = \\frac{0.95 \\cdot (1 - 0.10)}{(1 - 0.85) \\cdot 0.10 + 0.95 \\cdot (1 - 0.10)} = \\frac{0.95 \\cdot 0.90}{0.15 \\cdot 0.10 + 0.95 \\cdot 0.90} = \\frac{0.855}{0.015 + 0.855} = \\frac{0.855}{0.870} = \\frac{57}{58} \\approx 0.9828$$\n\n情况2：目标筛查患病率，$p_{target} = 0.02$。\n$$\\text{PPV}_{target} = \\frac{0.85 \\cdot 0.02}{0.85 \\cdot 0.02 + (1 - 0.95)(1 - 0.02)} = \\frac{0.017}{0.017 + (0.05)(0.98)} = \\frac{0.017}{0.017 + 0.049} = \\frac{0.017}{0.066} = \\frac{17}{66} \\approx 0.2576$$\n$$\\text{NPV}_{target} = \\frac{0.95 \\cdot (1 - 0.02)}{(1 - 0.85) \\cdot 0.02 + 0.95 \\cdot (1 - 0.02)} = \\frac{0.95 \\cdot 0.98}{0.15 \\cdot 0.02 + 0.95 \\cdot 0.98} = \\frac{0.931}{0.003 + 0.931} = \\frac{0.931}{0.934} \\approx 0.9968$$\n\n患病率从病例对照研究环境（$p=0.10$）转变为人群筛查环境（$p=0.02$），这对分类器的性能指标产生了深远的影响：\n- **PPV（精确率）**：PPV从约 $0.65$ 急剧下降到约 $0.26$。这是一个关键的观察结果。在低患病率环境中，阳性测试结果更有可能是假阳性。其临床意义是，大多数被分类器标记为阳性的个体实际上并未患病，这会导致不必要的后续检查、成本和患者焦虑。这种高假阳性负担是筛查项目的一个决定性挑战。\n- **NPV**：NPV略有增加，从约 $0.983$ 增加到约 $0.997$。在低患病率环境中，阴性结果在排除疾病方面变得更加可靠。这是因为未患病的先验概率本身已经非常高。\n- **召回率（灵敏度）**：召回率，定义为 $P(T^{+}|D)$，是分类器的一个内在属性，关系到其在疾病存在时检测出疾病的能力。它以真实状态 $D$ 为条件，因此独立于人群中的疾病患病率 $p$。它保持恒定在 $0.85$。\n- **F₁分数**：F₁分数是精确率（PPV）和召回率的调和平均数：$F_1 = 2 \\cdot \\frac{\\text{精确率} \\cdot \\text{召回率}}{\\text{精确率} + \\text{召回率}}$。由于召回率是恒定的，而精确率高度依赖于患病率，因此F₁分数也高度依赖于患病率。精确率的急剧下降导致F₁分数同样急剧下降，这表明当分类器转移到筛查环境时，其性能的整体平衡性会大幅降低。\n\n最后，我们计算所需的比率 $\\rho$：\n$$\\rho \\;=\\; \\frac{\\text{目标患病率下的PPV}}{\\text{研究患病率下的PPV}} = \\frac{\\text{PPV}_{target}}{\\text{PPV}_{study}} = \\frac{17/66}{17/26} = \\frac{17}{66} \\cdot \\frac{26}{17} = \\frac{26}{66} = \\frac{13}{33}$$\n作为小数，$\\rho \\approx 0.393939...$。四舍五入到四位有效数字得到 $0.3939$。", "answer": "$$\n\\boxed{0.3939}\n$$", "id": "4551711"}, {"introduction": "理论指标只有在用于指导现实约束下的具体决策时，才能体现其真正价值。最后的这个练习 [@problem_id:4551721] 将带您从计算转向优化，要求您为一个概率分类器选择最佳的决策阈值。您需要权衡相互竞争的目标——在满足严格的随访能力上限和最低召回率要求的同时，最大化模型的精确率，这正是在临床实践中部署诊断AI时面临的典型挑战。", "problem": "给定一个来自放射组学的二元分类场景，其中一个概率分类器为每个病例分配一个在闭区间 $[0,1]$ 内的恶性肿瘤评分。每周，诊所最多可以执行 $C$ 次随访操作，并且会为每个预测为阳性的病例触发一次随访。每周的放射科医生团队要求一个最低的灵敏度水平，表示为最低召回率要求 $r_{\\min} \\in [0,1]$，以确保有足够比例的实际恶性病例被标记以进行随访。您的任务是选择一个决策阈值 $\\tau \\in [0,1]$，使得一个病例当且仅当其评分至少为 $\\tau$ 时被预测为阳性。\n\n您的程序必须确定一个能够最大化精确率同时满足每周随访容量和最低召回率要求的 $\\tau$。形式上，对于每个候选阈值 $\\tau$，根据标准定义计算混淆矩阵的条目：真阳性 (TP)、假阳性 (FP)、真阴性 (TN) 和假阴性 (FN)。设 $N$ 为病例总数，$P$ 为实际阳性病例总数。性能指标定义如下，均以小数表示：\n- 准确率: $\\mathrm{Acc} = \\dfrac{\\mathrm{TP} + \\mathrm{TN}}{N}$。\n- 精确率: $\\mathrm{Prec} = \\dfrac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}$，约定当 $\\mathrm{TP} + \\mathrm{FP} = 0$ 时，$\\mathrm{Prec} = 0$。\n- 召回率: $\\mathrm{Rec} = \\dfrac{\\mathrm{TP}}{P}$，约定当 $P = 0$ 时，$\\mathrm{Rec} = 0$。\n- F$_1$分数: $\\mathrm{F}_1 = \\dfrac{2 \\cdot \\mathrm{Prec} \\cdot \\mathrm{Rec}}{\\mathrm{Prec} + \\mathrm{Rec}}$，约定当 $\\mathrm{Prec} + \\mathrm{Rec} = 0$ 时，$\\mathrm{F}_1 = 0$。\n\n一个阈值 $\\tau$ 是可行的，当且仅当同时满足以下两个条件：\n- 预测为阳性的数量最多为每周容量 $C$，即 $\\mathrm{TP} + \\mathrm{FP} \\le C$。\n- 召回率满足最低要求，即 $\\mathrm{Rec} \\ge r_{\\min}$。\n\n在所有可行的阈值中，选择使 $\\mathrm{Prec}$ 最大化的那个。如果精确率出现平局，则通过选择具有最高 F$_1$分数的阈值来打破平局。如果仍然存在平局，则选择最大的阈值 $\\tau$。如果没有阈值同时满足两个可行性条件，则返回 $\\tau = -1$ 并将所有四个指标设置为 $0$。\n\n请使用以下测试套件。在所有情况下，一个病例当且仅当其评分至少为 $\\tau$ 时被预测为阳性。所有数值答案必须以小数（而非百分比）表示。您的程序必须仅在每个数据集中观察到的唯一分数集合上评估阈值。\n\n测试套件：\n- 案例 $1$：每周容量 $C = 20$，最低召回率 $r_{\\min} = 0.7$。$N = 30$ 个放射组学病例的分数和标签（每对为 $(\\text{分数}, \\text{标签})$）：\n  $\\{(0.95,1),(0.92,1),(0.90,1),(0.88,0),(0.86,1),(0.84,1),(0.82,0),(0.80,1),(0.78,0),(0.76,1),(0.74,1),(0.72,0),(0.70,1),(0.68,0),(0.66,1),(0.64,0),(0.62,0),(0.60,1),(0.58,0),(0.56,0),(0.54,1),(0.52,0),(0.50,0),(0.48,1),(0.46,0),(0.44,0),(0.42,0),(0.40,1),(0.38,0),(0.36,0)\\}$.\n- 案例 $2$：每周容量 $C = 5$，最低召回率 $r_{\\min} = 0.9$。$N = 20$ 个放射组学病例的分数和标签：\n  $\\{(0.99,1),(0.95,1),(0.93,1),(0.85,1),(0.80,1),(0.70,1),(0.60,0),(0.58,0),(0.55,0),(0.52,0),(0.50,0),(0.48,0),(0.46,0),(0.44,0),(0.42,0),(0.40,0),(0.38,0),(0.36,0),(0.34,0),(0.30,0)\\}$.\n- 案例 $3$：每周容量 $C = 3$，最低召回率 $r_{\\min} = 0.5$。$N = 12$ 个放射组学病例的分数和标签：\n  $\\{(0.96,1),(0.90,0),(0.88,1),(0.85,0),(0.80,1),(0.78,0),(0.60,1),(0.55,0),(0.52,0),(0.50,0),(0.40,0),(0.30,0)\\}$.\n\n最终输出格式：\n- 对于每个案例，输出一个列表 $[\\tau, \\mathrm{Acc}, \\mathrm{Prec}, \\mathrm{Rec}, \\mathrm{F}_1]$，其中每个值都四舍五入到恰好 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含所有案例的结果，形式为一个逗号分隔的列表的列表，并用方括号括起来，例如 $[[\\cdot],[\\cdot],[\\cdot]]$。", "solution": "经评估，用户提供的问题是有效的。这是一个基于二元分类模型评估标准原则的、定义明确的优化问题。问题陈述是自洽的、客观的且科学上合理的。所有必要的数据、约束和定义都已提供，并且没有内部矛盾。\n\n该问题要求为在放射组学背景下使用的概率性二元分类器确定一个最优决策阈值 $\\tau$。目标是在满足两个操作约束（每周随访容量 $C$ 和表示为召回率 ($\\mathrm{Rec}$) 值的最低要求灵敏度水平 $r_{\\min}$）的前提下，最大化分类器的精确率 ($\\mathrm{Prec}$)。\n\n求解方法以结构化、分步骤的方式进行。\n\n1.  **问题形式化**\n    该任务是一个约束优化问题。我们必须找到一个阈值 $\\tau \\in [0,1]$ 来解决：\n    $$\n    \\underset{\\tau}{\\text{maximize}} \\quad \\mathrm{Prec}(\\tau)\n    $$\n    约束条件：\n    1.  容量约束：$\\mathrm{TP}(\\tau) + \\mathrm{FP}(\\tau) \\le C$\n    2.  召回率约束：$\\mathrm{Rec}(\\tau) \\ge r_{\\min}$\n\n    在多个阈值产生相同最大精确率的情况下，将执行一个打破平局的层级结构：\n    1.  选择具有最高 $\\mathrm{F}_1$分数的阈值。\n    2.  如果仍然存在平局，选择最大的阈值 $\\tau$。\n\n    $\\tau$ 的搜索空间明确限定为数据集中存在的唯一放射组学评分的集合。\n\n2.  **候选阈值的系统性评估**\n    该方法的核心是对允许的候选阈值集合进行穷举搜索。对于数据中观察到的每个唯一分数，我们将其视为一个潜在的阈值 $\\tau$。\n\n    对于每个候选阈值 $\\tau$，我们首先对所有 $N$ 个病例进行分类。如果一个病例的分数大于或等于 $\\tau$，则预测为阳性，否则为阴性。这使我们能够通过将预测与真实标签进行比较来构建一个混淆矩阵。该矩阵的元素为：\n    -   $\\mathrm{TP}(\\tau)$: 真阳性 (分数 $\\ge \\tau$ 且真实标签为 $1$)\n    -   $\\mathrm{FP}(\\tau)$: 假阳性 (分数 $\\ge \\tau$ 且真实标签为 $0$)\n    -   $\\mathrm{TN}(\\tau)$: 真阴性 (分数 $ \\tau$ 且真实标签为 $0$)\n    -   $\\mathrm{FN}(\\tau)$: 假阴性 (分数 $ \\tau$ 且真实标签为 $1$)\n\n3.  **性能指标计算**\n    使用混淆矩阵的值，我们为每个 $\\tau$ 计算所需的性能指标。设 $P = \\mathrm{TP} + \\mathrm{FN}$ 为数据集中实际阳性病例的总数。\n    -   **准确率**: $\\mathrm{Acc} = \\dfrac{\\mathrm{TP} + \\mathrm{TN}}{N}$\n    -   **精确率**: $\\mathrm{Prec} = \\dfrac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}$。按照约定，如果分母 $\\mathrm{TP} + \\mathrm{FP} = 0$，则 $\\mathrm{Prec} = 0$。\n    -   **召回率**: $\\mathrm{Rec} = \\dfrac{\\mathrm{TP}}{P}$。按照约定，如果 $P=0$，则 $\\mathrm{Rec}=0$。\n    -   **F$_1$分数**: $\\mathrm{F}_1 = \\dfrac{2 \\cdot \\mathrm{Prec} \\cdot \\mathrm{Rec}}{\\mathrm{Prec} + \\mathrm{Rec}}$。按照约定，如果分母 $\\mathrm{Prec} + \\mathrm{Rec} = 0$，则 $\\mathrm{F}_1 = 0$。\n\n4.  **可行性分析**\n    每个候选阈值 $\\tau$ 及其对应的指标都将根据给定的两个约束进行可行性测试：\n    -   $\\mathrm{TP}(\\tau) + \\mathrm{FP}(\\tau) \\le C$\n    -   $\\mathrm{Rec}(\\tau) \\ge r_{\\min}$\n\n    一个阈值仅在同时满足这两个条件时才被视为一个有效解。所有这样的可行解都会被收集起来用于最终的选择步骤。\n\n5.  **最优解选择**\n    如果在评估所有候选阈值后，可行解集合为空，则可以得出结论，不存在满足临床要求的解决方案。在这种情况下，输出为 $\\tau = -1$，并且所有性能指标都设置为 $0$。\n\n    如果存在一个或多个可行解，则通过应用指定的分层标准来确定最优解。一种有效的实现方法是对可行解集合进行排序。每个解决方案由一个包含其指标的元组或结构表示，例如 $(\\mathrm{Prec}, \\mathrm{F}_1, \\tau)$。排序按 $\\mathrm{Prec}$ 的降序，然后按 $\\mathrm{F}_1$ 的降序，最后按 $\\tau$ 的降序进行。根据问题的规则，排序后列表中的第一个元素即为唯一的最优解决方案。\n\n    每个测试案例的最终输出是一个包含最优阈值及其相关指标的列表：$[\\tau, \\mathrm{Acc}, \\mathrm{Prec}, \\mathrm{Rec}, \\mathrm{F}_1]$，每个值都按要求进行了数值格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the threshold optimization problem for a series of test cases.\n    \"\"\"\n    test_cases = [\n        (\n            20, 0.7, \n            [\n                (0.95, 1), (0.92, 1), (0.90, 1), (0.88, 0), (0.86, 1), (0.84, 1), \n                (0.82, 0), (0.80, 1), (0.78, 0), (0.76, 1), (0.74, 1), (0.72, 0), \n                (0.70, 1), (0.68, 0), (0.66, 1), (0.64, 0), (0.62, 0), (0.60, 1), \n                (0.58, 0), (0.56, 0), (0.54, 1), (0.52, 0), (0.50, 0), (0.48, 1), \n                (0.46, 0), (0.44, 0), (0.42, 0), (0.40, 1), (0.38, 0), (0.36, 0)\n            ]\n        ),\n        (\n            5, 0.9, \n            [\n                (0.99, 1), (0.95, 1), (0.93, 1), (0.85, 1), (0.80, 1), (0.70, 1), \n                (0.60, 0), (0.58, 0), (0.55, 0), (0.52, 0), (0.50, 0), (0.48, 0), \n                (0.46, 0), (0.44, 0), (0.42, 0), (0.40, 0), (0.38, 0), (0.36, 0), \n                (0.34, 0), (0.30, 0)\n            ]\n        ),\n        (\n            3, 0.5, \n            [\n                (0.96, 1), (0.90, 0), (0.88, 1), (0.85, 0), (0.80, 1), (0.78, 0), \n                (0.60, 1), (0.55, 0), (0.52, 0), (0.50, 0), (0.40, 0), (0.30, 0)\n            ]\n        )\n    ]\n\n    all_results = []\n    for C, r_min, data in test_cases:\n        scores = np.array([d[0] for d in data])\n        labels = np.array([d[1] for d in data])\n        \n        N = len(labels)\n        P = np.sum(labels)\n        \n        # Per problem statement, evaluate only at unique score values.\n        unique_scores = np.unique(scores)\n        \n        feasible_solutions = []\n        \n        for tau in unique_scores:\n            predictions = (scores = tau).astype(int)\n            TP = np.sum((predictions == 1)  (labels == 1))\n            FP = np.sum((predictions == 1)  (labels == 0))\n            \n            predicted_positives = TP + FP\n\n            if P == 0:\n                rec = 0.0\n            else:\n                rec = TP / P\n\n            # Check feasibility first.\n            is_feasible = (predicted_positives = C) and (rec = r_min)\n\n            if is_feasible:\n                # Calculate remaining metrics only for feasible thresholds.\n                TN = np.sum((predictions == 0)  (labels == 0))\n                \n                if predicted_positives == 0:\n                    prec = 0.0\n                else:\n                    prec = TP / predicted_positives\n                \n                if (prec + rec) == 0:\n                    f1 = 0.0\n                else:\n                    f1 = 2 * prec * rec / (prec + rec)\n\n                acc = (TP + TN) / N\n                \n                # Store all metrics for this feasible solution.\n                feasible_solutions.append({\n                    'prec': prec, \n                    'f1': f1, \n                    'tau': tau, \n                    'acc': acc, \n                    'rec': rec\n                })\n        \n        if not feasible_solutions:\n            result = [-1.0, 0.0, 0.0, 0.0, 0.0]\n        else:\n            # Sort using a key that implements the hierarchical tie-breaking rules:\n            # 1. Maximize precision (sort by -prec)\n            # 2. Maximize F1-score (sort by -f1)\n            # 3. Maximize threshold tau (sort by -tau)\n            best_solution = sorted(feasible_solutions, key=lambda x: (-x['prec'], -x['f1'], -x['tau']))[0]\n            \n            result = [\n                best_solution['tau'],\n                best_solution['acc'],\n                best_solution['prec'],\n                best_solution['rec'],\n                best_solution['f1']\n            ]\n        \n        # Format the result list into the required string format with 6 decimal places.\n        formatted_result = f\"[{','.join([f'{v:.6f}' for v in result])}]\"\n        all_results.append(formatted_result)\n\n    # Print a single line with all results, as specified.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "4551721"}]}