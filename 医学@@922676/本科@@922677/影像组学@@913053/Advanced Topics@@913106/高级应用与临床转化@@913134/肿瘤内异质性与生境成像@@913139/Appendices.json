{"hands_on_practices": [{"introduction": "量化肿瘤内异质性的第一步是分析感兴趣区域内体素强度的统计分布。本练习旨在介绍两种不依赖于空间排布的一阶统计量：变异系数（$CV$）和香农熵（$H$）。通过为一组给定的肿瘤体素手动计算这些值 [@problem_id:4547773]，您将对这些指标如何捕捉影像学特征的离散程度和无序性建立具体理解，而这些正是生物异质性的关键指标。", "problem": "一个放射组学工作流被应用于实体瘤的单次扫描、多参数磁共振成像（MRI）。栖息地成像已根据归一化的信号强度将肿瘤划分为缺氧核心和增殖边缘。强度值已经过最小-最大归一化至单位区间，因此每个体素的强度值都是在 $[0,1]$ 范围内的无量纲数。现给出连续肿瘤区域（包含两种栖息地）内 $20$ 个体素的强度值如下：缺氧核心体素 $0.90, 0.85, 0.92, 0.88, 0.81, 0.95, 0.78, 0.83, 0.89, 0.87$ 和增殖边缘体素 $0.45, 0.52, 0.40, 0.55, 0.47, 0.58, 0.50, 0.60, 0.43, 0.48$。请使用统计学和信息论中的核心定义，按以下步骤进行。\n\n1. 将给定的 $20$ 个体素集合视为一个有限总体。计算总体均值 $\\mu$ 和总体标准差 $\\sigma$（定义为 $\\sigma=\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}(x_i-\\mu)^{2}}$，其中 $N=20$，$x_i$ 是给定的体素强度值）。然后计算变异系数，其概念上定义为离散程度与中心趋势的比值，$\\mathrm{CV}=\\sigma/\\mu$。将 $\\mathrm{CV}$ 表示为无量纲量。\n\n2. 为了量化分布异质性，通过将体素强度值分箱到四个不重叠的区间来构建直方图：$\\mathcal{B}_1=[0.35,0.50)$，$\\mathcal{B}_2=[0.50,0.65)$，$\\mathcal{B}_3=[0.65,0.80)$ 和 $\\mathcal{B}_4=[0.80,1.00]$。设 $p_i$ 是区间 $\\mathcal{B}_i$ 的经验概率，由 $\\mathcal{B}_i$ 中的计数除以 $N$ 得到。使用信息论中基于自然对数的定义，计算香农熵 $H=-\\sum_{i=1}^{4}p_i\\,\\ln(p_i)$。将 $H$ 以自然信息单位（奈特）表示。\n\n3. 运用关于离散度和不确定性的第一性原理，简要解释计算出的 $\\mathrm{CV}$ 和 $H$ 对于跨越两种栖息地的肿瘤内异质性意味着什么。\n\n将两个数值结果四舍五入到四位有效数字。报告 $\\mathrm{CV}$ 为无量纲量，$H$ 的单位为奈特。对于最终答案，只提供数对 $(\\mathrm{CV}, H)$。", "solution": "问题陈述已经过验证，并被确定为是合理的。它在科学上基于放射组学、统计学和信息论的既定原则，问题设置良好，包含了所有必要的数据和定义，并以客观、正式的语言表述。它提出了一个可解的、有意义的问题。\n\n该问题要求对一组给定的来自肿瘤的 $N=20$ 个体素强度值进行三部分分析，这些体素被划分为缺氧核心和增殖边缘。\n\n首先，完整的 $N=20$ 个体素强度值集合 $x_i$ 如下：\n$$ \\{0.90, 0.85, 0.92, 0.88, 0.81, 0.95, 0.78, 0.83, 0.89, 0.87, 0.45, 0.52, 0.40, 0.55, 0.47, 0.58, 0.50, 0.60, 0.43, 0.48\\} $$\n\n**第1部分：计算 $\\mu$、$\\sigma$ 和 $\\mathrm{CV}$**\n\n总体均值 $\\mu$ 是 $N$ 个强度值的算术平均值。\n强度值的总和是：\n$$ \\sum_{i=1}^{20} x_i = (0.90+0.85+0.92+0.88+0.81+0.95+0.78+0.83+0.89+0.87) + (0.45+0.52+0.40+0.55+0.47+0.58+0.50+0.60+0.43+0.48) $$\n$$ \\sum_{i=1}^{20} x_i = 8.68 + 4.98 = 13.66 $$\n总体均值是：\n$$ \\mu = \\frac{1}{N} \\sum_{i=1}^{N} x_i = \\frac{13.66}{20} = 0.683 $$\n接下来，我们计算总体标准差 $\\sigma$。我们首先使用公式 $\\sigma^2 = \\left(\\frac{1}{N}\\sum_{i=1}^{N} x_i^2\\right) - \\mu^2$ 计算总体方差 $\\sigma^2$。\n强度值的平方和是：\n$$ \\sum_{i=1}^{20} x_i^2 = (0.90^2 + \\dots + 0.87^2) + (0.45^2 + \\dots + 0.48^2) $$\n$$ \\sum_{i=1}^{20} x_i^2 = (0.81 + 0.7225 + 0.8464 + 0.7744 + 0.6561 + 0.9025 + 0.6084 + 0.6889 + 0.7921 + 0.7569) + (0.2025 + 0.2704 + 0.16 + 0.3025 + 0.2209 + 0.3364 + 0.25 + 0.36 + 0.1849 + 0.2304) $$\n$$ \\sum_{i=1}^{20} x_i^2 = 7.5582 + 2.5180 = 10.0762 $$\n方差是：\n$$ \\sigma^2 = \\frac{10.0762}{20} - (0.683)^2 = 0.50381 - 0.466489 = 0.037321 $$\n标准差是方差的平方根：\n$$ \\sigma = \\sqrt{0.037321} \\approx 0.1931864 $$\n变异系数 $\\mathrm{CV}$ 是标准差与均值的比值：\n$$ \\mathrm{CV} = \\frac{\\sigma}{\\mu} = \\frac{0.1931864}{0.683} \\approx 0.282850 $$\n四舍五入到四位有效数字，$\\mathrm{CV} \\approx 0.2829$。\n\n**第2部分：计算香农熵 $H$**\n\n我们首先将 $N=20$ 个体素强度值分类到四个指定的区间中，并确定其计数。\n区间为 $\\mathcal{B}_1=[0.35,0.50)$，$\\mathcal{B}_2=[0.50,0.65)$，$\\mathcal{B}_3=[0.65,0.80)$ 和 $\\mathcal{B}_4=[0.80,1.00]$。\n- $\\mathcal{B}_1$ 的计数：体素强度值 $\\{0.45, 0.40, 0.47, 0.43, 0.48\\}$。计数为 $c_1=5$。\n- $\\mathcal{B}_2$ 的计数：体素强度值 $\\{0.52, 0.55, 0.58, 0.50, 0.60\\}$。计数为 $c_2=5$。\n- $\\mathcal{B}_3$ 的计数：体素强度值 $\\{0.78\\}$。计数为 $c_3=1$。\n- $\\mathcal{B}_4$ 的计数：体素强度值 $\\{0.90, 0.85, 0.92, 0.88, 0.81, 0.95, 0.83, 0.89, 0.87\\}$。计数为 $c_4=9$。\n总计数为 $c_1+c_2+c_3+c_4 = 5+5+1+9=20$，与 $N$ 相符。\n经验概率 $p_i = c_i/N$ 如下：\n$$ p_1 = \\frac{5}{20} = 0.25 $$\n$$ p_2 = \\frac{5}{20} = 0.25 $$\n$$ p_3 = \\frac{1}{20} = 0.05 $$\n$$ p_4 = \\frac{9}{20} = 0.45 $$\n香农熵 $H$ 使用公式 $H=-\\sum_{i=1}^{4}p_i\\,\\ln(p_i)$ 计算。\n$$ H = -[p_1\\ln(p_1) + p_2\\ln(p_2) + p_3\\ln(p_3) + p_4\\ln(p_4)] $$\n$$ H = -[0.25\\ln(0.25) + 0.25\\ln(0.25) + 0.05\\ln(0.05) + 0.45\\ln(0.45)] $$\n代入自然对数的值：\n$$ H \\approx -[0.25(-1.38629) + 0.25(-1.38629) + 0.05(-2.99573) + 0.45(-0.79851)] $$\n$$ H \\approx -[-0.34657 - 0.34657 - 0.14979 - 0.35933] $$\n$$ H \\approx -[-1.20226] \\approx 1.20226 \\text{ nats} $$\n四舍五入到四位有效数字，$H \\approx 1.202$ 奈特。\n\n**第3部分：解释**\n\n计算出的度量指标 $\\mathrm{CV}$ 和 $H$ 量化了肿瘤内异质性的不同方面。\n- 变异系数 $\\mathrm{CV} \\approx 0.2829$ 衡量了体素强度的相对离散度。从第一性原理来看，它是离散程度（$\\sigma$）与中心趋势（$\\mu$）的比值。$28.3\\%$ 的值表明变异性水平中等偏高。这表示体素强度值并非紧密聚集在均值周围，而是显著分散。这种分散是合并两个具有明显不同平均强度水平的体素群体（缺氧核心和增殖边缘）的直接且预期的结果。\n- 香农熵 $H \\approx 1.202$ 奈特，衡量了体素强度在预定义区间分布中的不确定性或无序性。对于四个区间，可能的最大熵为 $H_{\\text{max}} = \\ln(4) \\approx 1.386$ 奈特，这在所有区间均等填充时发生。计算出的值很高，约为最大值的 $87\\%$。从第一性原理来看，熵量化了在特定强度区间中观察到一个体素的不可预测性。高 $H$ 值意味着体素强度分布在多个区间中，而不是集中在一个区间，反映了复杂的强度分布。这种缺乏单一主导强度状态是异质性的一个标志，此处是由两种不同肿瘤栖息地的共存引起的。\n\n总之，高 $\\mathrm{CV}$ 和高 $H$ 值均表明存在显著的肿瘤内异质性。$\\mathrm{CV}$ 捕捉了强度变化的幅度，而 $H$ 则捕捉了强度分布形态的复杂性和不可预测性。", "answer": "$$ \\boxed{\\begin{pmatrix} 0.2829  1.202 \\end{pmatrix}} $$", "id": "4547773"}, {"introduction": "一阶统计量描述了强度分布的“内容”，但忽略了“位置”。为了捕捉定义肿瘤微环境的纹理和空间模式，我们需转向二阶统计量。本练习 [@problem_id:4547797] 将引导您完成从一个小型影像片构建灰度共生矩阵（GLCM）并计算关键纹理特征（如对比度和熵）的基础过程，从而更深入地洞察局部像素排布如何量化复杂的异质性。", "problem": "一幅磁共振成像 (MRI) 切片中的肿瘤感兴趣区域 (ROI) 经过预处理，并被量化为$4$个灰度级，标记为$0,1,2,3$，以反映不同的肿瘤内生境，例如坏死、缺氧和灌注良好的亚区。考虑以下$4 \\times 4$的图像块（行从上到下列出），其中每个条目是一个量化后的灰度级：\n$$\nI \\;=\\;\n\\begin{bmatrix}\n0  0  1  1 \\\\\n0  2  2  1 \\\\\n3  2  2  1 \\\\\n3  3  2  1\n\\end{bmatrix}.\n$$\n使用灰度共生矩阵 (GLCM) 框架，按如下步骤进行：\n- 使用图像块内向右的单像素水平邻接关系构建共生计数矩阵$N(i,j)$（即，对每一行，考虑形式为$\\big(I(r,c), I(r,c+1)\\big)$的有序对）。\n- 形成对称计数矩阵$N_{\\text{sym}}(i,j) = N(i,j) + N(j,i)$以捕捉无向邻接关系。\n- 将$N_{\\text{sym}}$的每个条目除以$N_{\\text{sym}}$中所有条目的总和，从而将其归一化为概率质量函数$P(i,j)$。\n\n仅使用二阶统计量和信息论的基本定义（不使用快捷公式），计算：\n1. 此图像块的GLCM对比度，理解为在$P(i,j)$下水平相邻像素之间灰度级差的平方期望值。\n2. $P(i,j)$的GLCM熵，使用自然对数，并以奈特 (nats) 为单位表示结果。\n\n简要解释您获得的数值如何在生境成像的背景下反映局部异质性与均匀性。将对比度和熵都四舍五入到四位有效数字。将您的最终答案以行向量$\\big(\\text{对比度},\\ \\text{熵}\\big)$的形式报告，其中熵以奈特为单位，并且最终方框内的值不包含单位。", "solution": "首先验证问题，以确保其科学性、适定性和客观性。\n\n### 步骤1：提取已知条件\n- 图像块 $I$:\n$$ I = \\begin{bmatrix} 0  0  1  1 \\\\ 0  2  2  1 \\\\ 3  2  2  1 \\\\ 3  3  2  1 \\end{bmatrix} $$\n- 灰度级: $\\{0, 1, 2, 3\\}$。\n- 共生规则：向右的单像素水平邻接，即形式为$(I(r,c), I(r,c+1))$的像素对。\n- 共生计数矩阵: $N(i,j)$。\n- 对称计数矩阵: $N_{\\text{sym}}(i,j) = N(i,j) + N(j,i)$。\n- 归一化概率矩阵：通过归一化$N_{\\text{sym}}$得到$P(i,j)$，使其所有条目之和为$1$。\n- GLCM对比度：定义为在概率分布$P(i,j)$下，灰度级差平方的期望值$E[(i-j)^2]$。\n- GLCM熵：使用自然对数定义，$H = - \\sum_{i,j} P(i,j) \\ln(P(i,j))$。\n- 输出要求：一个行向量$(\\text{对比度}, \\text{熵})$，两个值都四舍五入到四位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学性**：该问题使用了放射组学和纹理分析领域的标准定义和程序。灰度共生矩阵（GLCM）、对比度和熵是该领域的基本概念。将MRI数据量化以表示肿瘤生境的情景是一个常见的应用。\n- **适定性**：该问题提供了所有必要的数据（图像块）、构建矩阵（$N$, $N_{\\text{sym}}$, $P$）的清晰明确的指令，以及待计算量（对比度、熵）的精确定义。存在唯一解。\n- **客观性**：该问题以精确的数学语言陈述，没有任何主观或模棱两可的术语。\n\n### 步骤3：结论与行动\n问题有效。现在开始执行求解过程。\n\n### 求解推导\n\n**第1部分：构建GLCM**\n\n首先，我们通过统计指定的水平像素对来构建非对称共生计数矩阵$N(i,j)$。该图像块为$4 \\times 4$，因此有$4$行，每行有$3$对像素，总共有$4 \\times 3 = 12$对。\n像素对$(I(r,c), I(r,c+1))$如下：\n- 第1行: $(0,0), (0,1), (1,1)$\n- 第2行: $(0,2), (2,2), (2,1)$\n- 第3行: $(3,2), (2,2), (2,1)$\n- 第4行: $(3,3), (3,2), (2,1)$\n\n统计这些像素对，得到$N(i,j)$的计数值，其中$i$是像素对中的第一个灰度级，$j$是第二个。\n- $N(0,0)=1$\n- $N(0,1)=1$\n- $N(0,2)=1$\n- $N(1,1)=1$\n- $N(2,1)=3$\n- $N(2,2)=2$\n- $N(3,2)=2$\n- $N(3,3)=1$\n所有其他条目均为$0$。矩阵$N(i,j)$为：\n$$ N(i,j) = \\begin{bmatrix} 1  1  1  0 \\\\ 0  1  0  0 \\\\ 0  3  2  0 \\\\ 0  0  2  1 \\end{bmatrix} $$\n$N$中所有条目的总和为$1+1+1+1+3+2+2+1 = 12$，与像素对的总数相符。\n\n接下来，我们形成对称计数矩阵$N_{\\text{sym}}(i,j) = N(i,j) + N(j,i) = N + N^T$。\n$$ N_{\\text{sym}}(i,j) = \\begin{bmatrix} 1  1  1  0 \\\\ 0  1  0  0 \\\\ 0  3  2  0 \\\\ 0  0  2  1 \\end{bmatrix} + \\begin{bmatrix} 1  0  0  0 \\\\ 1  1  3  0 \\\\ 1  0  2  2 \\\\ 0  0  0  1 \\end{bmatrix} = \\begin{bmatrix} 2  1  1  0 \\\\ 1  2  3  0 \\\\ 1  3  4  2 \\\\ 0  0  2  2 \\end{bmatrix} $$\n$N_{\\text{sym}}$中的总计数是其所有条目之和，即$24$。\n\n最后，我们将$N_{\\text{sym}}$的每个条目除以$24$，归一化得到概率质量函数$P(i,j)$。\n$$ P(i,j) = \\frac{1}{24} N_{\\text{sym}}(i,j) = \\frac{1}{24} \\begin{bmatrix} 2  1  1  0 \\\\ 1  2  3  0 \\\\ 1  3  4  2 \\\\ 0  0  2  2 \\end{bmatrix} = \\begin{bmatrix} 2/24  1/24  1/24  0 \\\\ 1/24  2/24  3/24  0 \\\\ 1/24  3/24  4/24  2/24 \\\\ 0  0  2/24  2/24 \\end{bmatrix} $$\n\n**第2部分：计算GLCM对比度**\n\nGLCM对比度定义为灰度级差平方的期望值：\n$$ C = \\sum_{i=0}^{3} \\sum_{j=0}^{3} (i-j)^2 P(i,j) $$\n我们可以通过将非零概率乘以对应的$(i-j)^2$值来计算这个和。\n- 对于$P(0,0)=\\frac{2}{24}$，$(i-j)^2 = (0-0)^2 = 0$。\n- 对于$P(0,1)=\\frac{1}{24}$，$(i-j)^2 = (0-1)^2 = 1$。\n- 对于$P(0,2)=\\frac{1}{24}$，$(i-j)^2 = (0-2)^2 = 4$。\n- 对于$P(1,0)=\\frac{1}{24}$，$(i-j)^2 = (1-0)^2 = 1$。\n- 对于$P(1,1)=\\frac{2}{24}$，$(i-j)^2 = (1-1)^2 = 0$。\n- 对于$P(1,2)=\\frac{3}{24}$，$(i-j)^2 = (1-2)^2 = 1$。\n- 对于$P(2,0)=\\frac{1}{24}$，$(i-j)^2 = (2-0)^2 = 4$。\n- 对于$P(2,1)=\\frac{3}{24}$，$(i-j)^2 = (2-1)^2 = 1$。\n- 对于$P(2,2)=\\frac{4}{24}$，$(i-j)^2 = (2-2)^2 = 0$。\n- 对于$P(2,3)=\\frac{2}{24}$，$(i-j)^2 = (2-3)^2 = 1$。\n- 对于$P(3,2)=\\frac{2}{24}$，$(i-j)^2 = (3-2)^2 = 1$。\n- 对于$P(3,3)=\\frac{2}{24}$，$(i-j)^2 = (3-3)^2 = 0$。\n\n将乘积求和：\n$$ C = \\frac{1}{24} \\left[ 2(0) + 1(1) + 1(4) + 1(1) + 2(0) + 3(1) + 1(4) + 3(1) + 4(0) + 2(1) + 2(1) + 2(0) \\right] $$\n$$ C = \\frac{1}{24} \\left[ 0 + 1 + 4 + 1 + 0 + 3 + 4 + 3 + 0 + 2 + 2 + 0 \\right] $$\n$$ C = \\frac{20}{24} = \\frac{5}{6} $$\n数值上，$C \\approx 0.833333...$。四舍五入到四位有效数字，对比度为$0.8333$。\n\n**第3部分：计算GLCM熵**\n\nGLCM熵定义为：\n$$ H = - \\sum_{i=0}^{3} \\sum_{j=0}^{3} P(i,j) \\ln(P(i,j)) $$\n求和遍及所有非零的$P(i,j)$。我们按相同的概率值对各项进行分组。$N_{\\text{sym}}$中的非零条目为$1$、$2$、$3$和$4$。\n- $N_{\\text{sym}}$中有$4$个值为$1$的条目。概率为$p_1 = \\frac{1}{24}$。\n- $N_{\\text{sym}}$中有$5$个值为$2$的条目。概率为$p_2 = \\frac{2}{24} = \\frac{1}{12}$。\n- $N_{\\text{sym}}$中有$2$个值为$3$的条目。概率为$p_3 = \\frac{3}{24} = \\frac{1}{8}$。\n- $N_{\\text{sym}}$中有$1$个值为$4$的条目。概率为$p_4 = \\frac{4}{24} = \\frac{1}{6}$。\n\n熵的计算如下：\n$$ H = - \\left[ 4 \\left( \\frac{1}{24} \\ln\\frac{1}{24} \\right) + 5 \\left( \\frac{2}{24} \\ln\\frac{2}{24} \\right) + 2 \\left( \\frac{3}{24} \\ln\\frac{3}{24} \\right) + 1 \\left( \\frac{4}{24} \\ln\\frac{4}{24} \\right) \\right] $$\n$$ H = - \\frac{1}{24} \\left[ 4(\\ln 1 - \\ln 24) + 10(\\ln 2 - \\ln 24) + 6(\\ln 3 - \\ln 24) + 4(\\ln 4 - \\ln 24) \\right] $$\n$$ H = - \\frac{1}{24} \\left[ 4(0) + 10\\ln 2 + 6\\ln 3 + 4\\ln(2^2) - (4+10+6+4)\\ln 24 \\right] $$\n$$ H = - \\frac{1}{24} \\left[ 10\\ln 2 + 6\\ln 3 + 8\\ln 2 - 24\\ln 24 \\right] $$\n$$ H = - \\frac{1}{24} \\left[ 18\\ln 2 + 6\\ln 3 - 24\\ln 24 \\right] $$\n$$ H = \\ln 24 - \\frac{18}{24}\\ln 2 - \\frac{6}{24}\\ln 3 = \\ln 24 - \\frac{3}{4}\\ln 2 - \\frac{1}{4}\\ln 3 $$\n由于$\\ln 24 = \\ln(2^3 \\cdot 3) = 3\\ln 2 + \\ln 3$，我们可以代入：\n$$ H = (3\\ln 2 + \\ln 3) - \\frac{3}{4}\\ln 2 - \\frac{1}{4}\\ln 3 $$\n$$ H = \\left(3 - \\frac{3}{4}\\right)\\ln 2 + \\left(1 - \\frac{1}{4}\\right)\\ln 3 = \\frac{9}{4}\\ln 2 + \\frac{3}{4}\\ln 3 $$\n$$ H = \\frac{3}{4}(3\\ln 2 + \\ln 3) = \\frac{3}{4}(\\ln 2^3 + \\ln 3) = \\frac{3}{4}\\ln(8 \\cdot 3) = \\frac{3}{4}\\ln(24) $$\n数值上，$\\ln(24) \\approx 3.1780538...$。\n$$ H \\approx \\frac{3}{4} \\times 3.1780538 \\approx 2.3835404... $$\n四舍五入到四位有效数字，熵为$2.384$奈特。\n\n### 结果解读\n\n- **对比度 ($C \\approx 0.8333$)：** 该值量化了局部强度的变化。由于$C>0$，该图像块不是均匀的。该值适中，反映了不同灰度级（生境）之间存在边界，但缺乏极端变化（例如，$0$和$3$之间没有直接邻接）。这表明纹理是异质的，具有可辨别但非急剧定义的亚区。\n\n- **熵 ($H \\approx 2.384$ 奈特)：** 该值衡量了纹理的无序性或复杂性。对于一个具有$12$个可能的非零状态的系统（如我们的$P(i,j)$矩阵），如果所有状态都等可能，则会出现最大熵，即$H_{\\text{max}} = -\\sum_{k=1}^{12} \\frac{1}{12} \\ln(\\frac{1}{12}) = \\ln(12) \\approx 2.485$ 奈特。我们计算出的熵值$2.384$奈特非常接近这个最大值。这表明灰度级的空间排列高度复杂和无序。在生境成像的背景下，这种高熵意味着显著的肿瘤内异质性，即不同的功能性生境高度混合，而不是被分割成大而均匀的区域。", "answer": "$$ \\boxed{ \\begin{pmatrix} 0.8333  2.384 \\end{pmatrix} } $$", "id": "4547797"}, {"introduction": "微环境成像的最终目标不仅是分析预定义区域，更是自动发现和勾画这些生物学亚区。这通常通过将机器学习算法应用于多参数影像数据来实现。在这一高级实践中 [@problem_id:4547809]，您将实施 k-均值聚类算法，根据来自 MRI 和 PET 扫描的特征将肿瘤体素划分为不同的微环境，从而模拟从原始数据到可解释生物学见解的完整放射组学工作流程。", "problem": "给定来自磁共振成像（MRI）和正电子发射断层扫描（PET）的肿瘤内部体素的多参数成像特征向量。每个体素具有三个特征：表观扩散系数（ADC，单位为 $\\mathrm{mm^2/s}$）、归一化 T2 加权强度（无量纲）和标准化摄取值（SUV，无量纲）。在放射组学中，可以通过对此类多参数特征向量进行聚类，将肿瘤内异质性建模为不同的“生境”（habitats）。您的任务是在标准化的特征空间中实现一个确定性的 $k$-均值聚类（$k=3$），然后根据每个聚类在原始单位下的特征分布将其解释为一种生境。\n\n使用以下基础知识：\n- 在 $k$-均值聚类中，目标是最小化簇内平方和。给定数据集 $\\{x_i\\}_{i=1}^n$（其中 $x_i \\in \\mathbb{R}^d$）和 $k$ 个聚类中心 $\\{\\mu_j\\}_{j=1}^k$，目标函数为\n$$\n\\min_{\\{\\mu_j\\},\\{c_i\\}} \\sum_{i=1}^n \\left\\| x_i - \\mu_{c_i} \\right\\|_2^2,\n$$\n其中 $c_i \\in \\{0,1,\\dots,k-1\\}$ 表示点 $i$ 的聚类分配。\n- 通过 $z$-score 进行标准化：对于每个特征维度 $f$，原始值 $x_{i,f}$ 转换为\n$$\nz_{i,f} = \\frac{x_{i,f} - \\bar{x}_f}{s_f},\n$$\n其中 $\\bar{x}_f$ 是均值，$s_f$ 是特征 $f$ 在所有点上的样本标准差。如果 $s_f=0$，则设置 $s_f=1$ 以避免除以零（这使得该特征下所有 $i$ 的 $z_{i,f}=0$，与无变异的情况一致）。\n\n算法要求：\n- 在标准化空间中进行聚类。\n- 质心初始化必须是确定性的：按 SUV 递增排序；若 SUV 相同，则按 ADC 递增排序；若仍然相同，则按 T2 递增排序。选择此排序顺序中的第一个、中位数和最后一个点作为 $k=3$ 的初始质心。\n- 分配步骤：在标准化空间中，根据欧氏距离将每个点分配给最近的质心。如果一个点到多个质心的距离完全相等，则选择其质心向量在标准化空间中具有较小欧氏范数的质心；如果范数也相等，则选择索引较小的质心。\n- 更新步骤：将每个质心移动到当前分配给它的所有点在标准化空间中的均值位置。如果在任何迭代中某个质心没有分配到任何点，则该次迭代中其位置保持不变。\n- 停止准则：当连续两次迭代之间的分配结果不再变化，或达到 $100$ 次迭代时停止，以先到者为准。\n\n聚类后计算：\n- 计算原始单位下的聚类质心（ADC 单位为 $\\mathrm{mm^2/s}$，T2 和 SUV 无量纲），方法是对分配给每个聚类的点的原始特征进行平均。如果收敛时某个聚类没有分配到任何点，则将其质心设置为所有原始特征的全局均值向量。\n- 使用原始单位和在所有点上计算的全局中位数进行生境解释规则：\n    - 计算所有点的 ADC 中位数 $\\tilde{m}_{\\mathrm{ADC}}$ 和 SUV 中位数 $\\tilde{m}_{\\mathrm{SUV}}$。\n    - 对于每个原始单位下的聚类质心 $(\\bar{\\mathrm{ADC}}, \\bar{\\mathrm{T2}}, \\bar{\\mathrm{SUV}})$，按如下方式分配一个生境代码：\n        - 代码 $1$（侵袭性/增殖样）：如果 $\\bar{\\mathrm{SUV}} > \\tilde{m}_{\\mathrm{SUV}}$ 且 $\\bar{\\mathrm{ADC}}  \\tilde{m}_{\\mathrm{ADC}}$。\n        - 代码 $2$（坏死/水肿样）：如果 $\\bar{\\mathrm{SUV}} \\le \\tilde{m}_{\\mathrm{SUV}}$ 且 $\\bar{\\mathrm{ADC}} \\ge \\tilde{m}_{\\mathrm{ADC}}$。\n        - 代码 $3$（中间/存活样）：其他情况。\n    - 将每个点的聚类分配映射到其聚类的生境代码，以得出每个点的生境标签。\n\n单位和输出：\n- ADC 必须以 $\\mathrm{mm^2/s}$ 为单位处理，在输出质心中以该单位的浮点数表示。T2 和 SUV 是无量纲的，也表示为浮点数。\n- 最终输出必须是单行，包含所有测试用例的结果列表，每个测试用例的结果是一个包含三个元素的列表：\n    $[C,A,H]$，其中\n    - $C$：一个扁平化列表，包含按聚类索引 $0,1,2$ 排序的原始单位质心值，每个质心内部按 $[\\mathrm{ADC}, \\mathrm{T2}, \\mathrm{SUV}]$ 排序，每个值四舍五入到 $6$ 位小数，\n    - $A$：每个点的聚类分配列表（整数 $0,1,2$），\n    - $H$：每个点的生境代码列表（整数 $1,2,3$）。\n- 您的程序应生成单行输出，其中包含一个方括号括起来的、以逗号分隔的结果列表，嵌套列表的格式也类似（例如，$[[C_1,A_1,H_1],[C_2,A_2,H_2],\\dots]$）。\n\n测试套件：\n- 案例 $1$（清晰的三个生境）：$9$ 个点\n    - $[0.00080, 0.30, 12.0]$, $[0.00085, 0.25, 11.0]$, $[0.00090, 0.35, 13.0]$,\n    - $[0.00170, 0.75, 3.0]$, $[0.00160, 0.70, 2.5]$, $[0.00180, 0.80, 4.0]$,\n    - $[0.00120, 0.50, 7.0]$, $[0.00125, 0.55, 6.5]$, $[0.00110, 0.45, 6.8]$.\n- 案例 $2$（退化的相同点）：$6$ 个点\n    - $[0.00120, 0.50, 6.0]$ 重复 $6$ 次。\n- 案例 $3$（近乎一致的聚类趋势）：$4$ 个点\n    - $[0.00100, 0.40, 8.0]$, $[0.00101, 0.41, 8.1]$, $[0.00099, 0.39, 7.9]$, $[0.00100, 0.40, 8.0]$.\n- 案例 $4$（对称变化下的平局行为）：$4$ 个点\n    - $[0.00120, 0.50, 6.0]$, $[0.00130, 0.50, 6.0]$, $[0.00110, 0.50, 6.0]$, $[0.00120, 0.50, 6.0]$.\n\n请完全按照描述实现指定的确定性 $k$-均值算法、生境解释和输出格式。不需要外部输入。程序必须能直接运行并打印出所要求的单行输出。", "solution": "该问题要求实现一种确定性的 $k$-均值聚类算法，用于根据多参数成像数据将肿瘤体素分割为不同的生境。该过程涉及特征标准化、一个指定的迭代聚类程序以及对所得聚类进行基于规则的解释。解决方案将以分步解析所需方法论的形式呈现。\n\n每个体素的输入数据是一个三维特征向量，包括表观扩散系数（ADC，单位为 $\\mathrm{mm^2/s}$）、归一化 T2 加权强度（无量纲）和标准化摄取值（SUV，无量纲）。聚类的数量固定为 $k=3$。\n\n第一步是标准化原始特征向量。聚类在此标准化空间中进行，以确保不同尺度和单位的特征对距离计算的贡献相等。对于每个特征维度 $f$，点 $i$ 的原始值 $x_{i,f}$ 通过以下公式转换为 $z$-score $z_{i,f}$：\n$$\nz_{i,f} = \\frac{x_{i,f} - \\bar{x}_f}{s_f}\n$$\n其中 $\\bar{x}_f$ 是均值，$s_f$ 是特征 $f$ 在所有 $n$ 个数据点上的样本标准差。问题规定了处理特征无方差情况的特定规则：如果 $s_f=0$，则在进行除法前将 $s_f$ 的值设为 $1$。这能正确地导致该恒定特征维度下所有点的 $z_{i,f}=0$。\n\n接下来，对标准化后的数据点 $\\{z_i\\}_{i=1}^n$ 应用确定性的 $k$-均值算法。该算法旨在最小化簇内平方欧氏距离之和，即 $\\sum_{i=1}^n \\left\\| z_i - \\mu_{c_i} \\right\\|_2^2$，其中 $\\mu_j$ 是聚类 $j$ 的质心，$c_i$ 是点 $i$ 的聚类分配。算法流程如下：\n\n1.  **质心初始化**：初始质心通过确定性方式选择，以确保结果的可复现性。首先，对所有数据点进行排序。主排序键是 SUV，按升序排列。若出现平局，则按 ADC 升序打破；若仍有平局，则按 T2 加权强度升序打破。对于 $n$ 个点，初始的三个质心被设置为此排序列表中位于第一个（索引 $0$）、中位数（索引 $\\lfloor(n-1)/2\\rfloor$）和最后一个（索引 $n-1$）位置的点的标准化特征向量。\n\n2.  **迭代优化**：算法随后迭代执行分配和更新两个步骤，直到满足停止条件。\n    *   **分配步骤**：每个数据点 $z_i$ 被分配给欧氏距离最近的质心 $\\mu_j$ 所属的聚类 $j$。为处理平局情况，如果一个点到多个质心的距离相等，它将被分配给其质心向量 $\\|\\mu_j\\|_2$ 欧氏范数最小的那个聚类。如果范数仍然相同，则分配给索引 $j \\in \\{0, 1, 2\\}$ 最小的聚类。\n    *   **更新步骤**：在所有点都被分配后，更新质心。对于每个聚类 $j$，新的质心 $\\mu_j$ 计算为当前分配给它的所有标准化数据点的分量均值。如果某个聚类变为空（即分配给它的点数为零），则在该次迭代中其质心不更新。\n\n3.  **终止**：当所有点的聚类分配在连续两次迭代中不再改变，或达到最大迭代次数 100 次时，迭代过程停止。\n\n聚类过程收敛后，进行后处理，以便在肿瘤生物学的背景下解释结果。\n\n1.  **质心转换**：将处于标准化空间中的最终聚类质心转换回原始特征空间。对于每个聚类 $j$，其在原始单位下的质心 $(\\bar{\\mathrm{ADC}}_j, \\bar{\\mathrm{T2}}_j, \\bar{\\mathrm{SUV}}_j)$ 通过计算分配给该聚类的所有点的原始特征向量的均值得到。如果某个聚类在收敛时为空，其质心定义为所有原始特征向量的全局均值向量。\n\n2.  **生境解释**：根据每个聚类在原始特征空间中的属性，将其分类为三种生境类型之一。此分类使用在所有输入数据点上计算的全局中位数 ADC（$\\tilde{m}_{\\mathrm{ADC}}$）和全局中位数 SUV（$\\tilde{m}_{\\mathrm{SUV}}$）。规则如下：\n    *   **代码 $1$（侵袭性/增殖样）**：如果聚类的平均 SUV 高于中位数 SUV，且其平均 ADC 低于中位数 ADC（$\\bar{\\mathrm{SUV}} > \\tilde{m}_{\\mathrm{SUV}}$ 且 $\\bar{\\mathrm{ADC}}  \\tilde{m}_{\\mathrm{ADC}}$），则分配此代码。这对应于高代谢活性和高细胞密度。\n    *   **代码 $2$（坏死/水肿样）**：如果聚类的平均 SUV 小于或等于中位数 SUV，且其平均 ADC 大于或等于中位数 ADC（$\\bar{\\mathrm{SUV}} \\le \\tilde{m}_{\\mathrm{SUV}}$ 且 $\\bar{\\mathrm{ADC}} \\ge \\tilde{m}_{\\mathrm{ADC}}$），则分配此代码。这对应于低代谢活性和低细胞密度/高含水量。\n    *   **代码 $3$（中间/存活样）**：如果不满足上述任何条件，则分配此代码。\n\n最后，将每个测试用例的结果编译成特定的输出格式。对于每个用例，输出是一个列表 $[C, A, H]$，其中 $C$ 是三个原始空间质心向量的扁平化列表（按聚类索引 $0, 1, 2$ 和特征 ADC、T2、SUV 排序），值四舍五入到 6 位小数；$A$ 是每个点的最终聚类分配（$0, 1, 2$）列表；$H$ 是每个点对应的生境代码（$1, 2, 3$）列表。最终的程序输出是包含所有测试用例结果的单行列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a deterministic k-means clustering for radiomics habitat analysis.\n    The function processes a suite of test cases, applying standardization,\n    a custom k-means algorithm, and a rule-based habitat interpretation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (clear three habitats): 9 points\n        [\n            [0.00080, 0.30, 12.0], [0.00085, 0.25, 11.0], [0.00090, 0.35, 13.0],\n            [0.00170, 0.75, 3.0], [0.00160, 0.70, 2.5], [0.00180, 0.80, 4.0],\n            [0.00120, 0.50, 7.0], [0.00125, 0.55, 6.5], [0.00110, 0.45, 6.8]\n        ],\n        # Case 2 (degenerate identical points): 6 points\n        [\n            [0.00120, 0.50, 6.0], [0.00120, 0.50, 6.0], [0.00120, 0.50, 6.0],\n            [0.00120, 0.50, 6.0], [0.00120, 0.50, 6.0], [0.00120, 0.50, 6.0]\n        ],\n        # Case 3 (near-uniform cluster tendency): 4 points\n        [\n            [0.00100, 0.40, 8.0], [0.00101, 0.41, 8.1],\n            [0.00099, 0.39, 7.9], [0.00100, 0.40, 8.0]\n        ],\n        # Case 4 (tie behavior with symmetric variation): 4 points\n        [\n            [0.00120, 0.50, 6.0], [0.00130, 0.50, 6.0],\n            [0.00110, 0.50, 6.0], [0.00120, 0.50, 6.0]\n        ]\n    ]\n\n    all_results = []\n    _K = 3\n    _MAX_ITER = 100\n\n    for data in test_cases:\n        X_orig = np.array(data, dtype=float)\n        n_points, n_features = X_orig.shape\n\n        # Step 1: Standardization\n        mean_orig = np.mean(X_orig, axis=0)\n        std_orig = np.std(X_orig, axis=0, ddof=1)\n        std_orig[std_orig == 0] = 1.0  # Handle zero variance as per problem spec\n        X_std = (X_orig - mean_orig) / std_orig\n\n        # Step 2: Deterministic Centroid Initialization\n        # Sort indices by SUV (col 2), then ADC (col 0), then T2 (col 1)\n        # np.lexsort keys are in reverse order of sorting priority\n        sort_indices = np.lexsort((X_orig[:, 1], X_orig[:, 0], X_orig[:, 2]))\n        \n        median_idx_pos = (n_points - 1) // 2\n        centroid_indices = [\n            sort_indices[0],\n            sort_indices[median_idx_pos],\n            sort_indices[n_points - 1]\n        ]\n        centroids_std = X_std[centroid_indices]\n\n        # Step 3: k-means Iterations\n        assignments = np.full(n_points, -1, dtype=int)\n        for _ in range(_MAX_ITER):\n            old_assignments = np.copy(assignments)\n\n            # Assignment Step\n            sq_dists = np.sum((X_std[:, np.newaxis, :] - centroids_std[np.newaxis, :, :])**2, axis=2)\n\n            for i in range(n_points):\n                min_sq_dist = np.min(sq_dists[i])\n                tied_indices = np.where(sq_dists[i] == min_sq_dist)[0]\n                \n                if len(tied_indices) == 1:\n                    assignments[i] = tied_indices[0]\n                else:\n                    # Tie-breaking 1: Centroid norm\n                    tied_centroids = centroids_std[tied_indices]\n                    sq_norms = np.sum(tied_centroids**2, axis=1)\n                    min_sq_norm = np.min(sq_norms)\n                    \n                    # Indices within tied_indices that have the minimum norm\n                    norm_tied_indices = np.where(sq_norms == min_sq_norm)[0]\n                    \n                    # Tie-breaking 2: Smallest original centroid index\n                    final_candidate_indices = tied_indices[norm_tied_indices]\n                    assignments[i] = np.min(final_candidate_indices)\n\n            # Update Step\n            new_centroids_std = np.copy(centroids_std)\n            for j in range(_K):\n                points_in_cluster = X_std[assignments == j]\n                if len(points_in_cluster) > 0:\n                    new_centroids_std[j] = np.mean(points_in_cluster, axis=0)\n                # Else: centroid remains unchanged if cluster is empty\n            centroids_std = new_centroids_std\n            \n            # Convergence Check\n            if np.array_equal(assignments, old_assignments):\n                break\n\n        # Step 4: Post-processing\n        # C: Centroids in original units\n        centroids_orig = []\n        global_mean_orig = np.mean(X_orig, axis=0)\n        for j in range(_K):\n            cluster_points_orig = X_orig[assignments == j]\n            if len(cluster_points_orig) > 0:\n                centroids_orig.append(np.mean(cluster_points_orig, axis=0))\n            else:\n                centroids_orig.append(global_mean_orig)\n        \n        C_flat = np.array(centroids_orig).flatten().tolist()\n        C = [round(val, 6) for val in C_flat]\n\n        # A: Final assignments\n        A = assignments.tolist()\n\n        # H: Habitat codes\n        median_adc = np.median(X_orig[:, 0])\n        median_suv = np.median(X_orig[:, 2])\n\n        cluster_habitat_codes = {}\n        for j in range(_K):\n            adc_bar, _, suv_bar = centroids_orig[j]\n            if suv_bar > median_suv and adc_bar  median_adc:\n                code = 1\n            elif suv_bar = median_suv and adc_bar >= median_adc:\n                code = 2\n            else:\n                code = 3\n            cluster_habitat_codes[j] = code\n        \n        H = [cluster_habitat_codes[assign] for assign in A]\n\n        all_results.append([C, A, H])\n\n    # Final print statement in the exact required format.\n    # str().replace() is used to produce the compact, no-space list representation.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "4547809"}]}