{"hands_on_practices": [{"introduction": "为了真正掌握一致性指数（C-index），最好的方法是从基本定义出发，亲手进行一次完整的计算。本练习将引导你完成这一过程 [@problem_id:5189334]。通过处理一个包含右删失数据的小型、清晰的样本集，你将学会如何识别“可比较对”，并判断每一对是“一致”还是“不一致”，从而直接应用C-index的定义，为更复杂的应用打下坚实的基础。", "problem": "训练一个深度神经生存（DeepSurv）模型，用于估计医学队列中右删失生存数据的个体化风险评分。设生存时间为非负随机变量 $T$，删失时间为 $C$，观测时间为 $Y = \\min\\{T, C\\}$，事件指示符为 $\\Delta = \\mathbf{1}\\{T \\leq C\\}$。该模型输出一个标量风险评分 $r(\\mathbf{x})$，使得风险函数 $h(t \\mid \\mathbf{x})$ 在 $r(\\mathbf{x})$ 上单调递增，这与比例风险模型一致，其中 $h(t \\mid \\mathbf{x}) \\propto \\exp(r(\\mathbf{x}))$。一致性指数（C-index）定义为：对于一个随机抽取的、其中较短观测时间对应一个事件的可纳对（admissible pair），具有较短观测事件时间的个体其预测风险评分也较高的概率。\n\n给定三名患者，其预测风险评分为 $\\mathbf{r} = [0.2, 1.1, -0.4]$，观测时间为 $\\mathbf{Y} = [3, 2, 5]$，事件指示符为 $\\boldsymbol{\\Delta} = [1, 1, 0]$。仅使用上述基本定义和右删失数据的可纳对逻辑，通过明确确定哪些配对是可纳的，以及在风险评分所隐含的排序下它们是一致的还是不一致的，来计算该队列的 C-index。假设风险评分或观测时间中没有出现并列情况；如果在可纳对内的风险评分中出现并列，它将对一致性贡献二分之一。\n\n此外，请基于 $T$、$C$、$Y$、$\\Delta$ 和基于风险的风险排序的定义，对不一致对在生存预测中对模型校准与区分度的影响提供一个有原则的解释。\n\n将最终的 C-index 表示为单个实数。如果您的计算结果为有理数，请保留其精确分数形式，不要四舍五入。", "solution": "目标是根据第一性原理，为一个深度神经生存（DeepSurv）风险模型下的右删失生存数据计算一致性指数（C-index）。我们从生存分析的核心定义以及预测风险评分与风险之间的单调关系入手。\n\n设 $T$ 为真实生存时间，$C$ 为删失时间。观测时间为 $Y = \\min\\{T, C\\}$，事件指示符为 $\\Delta = \\mathbf{1}\\{T \\leq C\\}$。预测的风险评分 $r(\\mathbf{x})$ 用于产生风险排序，其中较高的 $r(\\mathbf{x})$ 意味着较高的风险 $h(t \\mid \\mathbf{x})$，因此有事件时间更短的趋势。一致性指数是对于可纳对，风险评分的排序与观测事件时间的排序相符的概率。在右删失下，一个可纳对 $(i, j)$ 由以下逻辑定义：如果较短的观测时间对应一个事件，即当 $Y_i  Y_j$ 且 $\\Delta_i = 1$ 时，或者当 $Y_j  Y_i$ 且 $\\Delta_j = 1$ 时，该配对被包括在内。最小观测时间被删失的配对不是可纳的，因为在这种情况下，真实的事件时间顺序是未知的。\n\n如果具有较短观测事件时间的个体具有较高的风险评分，则该配对是一致的。如果具有较短观测事件时间的个体具有较低的风险评分，则该配对是不一致的。可纳对内风险评分的并列情况对一致性贡献二分之一，但此处没有出现并列。\n\n给定三名受试者：\n- 受试者 $1$：$r_1 = 0.2$, $Y_1 = 3$, $\\Delta_1 = 1$。\n- 受试者 $2$：$r_2 = 1.1$, $Y_2 = 2$, $\\Delta_2 = 1$。\n- 受试者 $3$：$r_3 = -0.4$, $Y_3 = 5$, $\\Delta_3 = 0$。\n\n我们枚举所有无序对 $\\{(1,2), (1,3), (2,3)\\}$ 并测试其可纳性和一致性。\n\n1. 对 (1, 2)：比较观测时间 $Y_1 = 3$ 和 $Y_2 = 2$。较短的时间是 $Y_2 = 2$，且 $\\Delta_2 = 1$，因此该对是可纳的。一致性要求事件时间较短的个体（受试者2）具有较高的风险评分。我们检查 $r_2$ 与 $r_1$：$r_2 = 1.1$ 且 $r_1 = 0.2$，因此 $r_2 > r_1$。该配对是一致的。\n\n2. 对 (1, 3)：比较 $Y_1 = 3$ 和 $Y_3 = 5$。较短的时间是 $Y_1 = 3$，且 $\\Delta_1 = 1$，因此该对是可纳的。一致性要求受试者1的风险评分高于受试者3。我们检查 $r_1$ 与 $r_3$：$r_1 = 0.2$ 且 $r_3 = -0.4$，因此 $r_1 > r_3$。该配对是一致的。\n\n3. 对 (2, 3)：比较 $Y_2 = 2$ 和 $Y_3 = 5$。较短的时间是 $Y_2 = 2$，且 $\\Delta_2 = 1$，因此该对是可纳的。一致性要求受试者2的风险评分高于受试者3。我们检查 $r_2$ 与 $r_3$：$r_2 = 1.1$ 且 $r_3 = -0.4$，因此 $r_2 > r_3$。该配对是一致的。\n\n所有三个可纳对都是一致的。因此，C-index 是一致的可纳对所占的比例：\n$$\n\\text{C-指数} \\;=\\; \\frac{\\text{一致的可纳对数量}}{\\text{可纳对总数}} \\;=\\; \\frac{3}{3} \\;=\\; 1.\n$$\n\n关于不一致对与校准度和区分度关系的解释：当具有较短观测事件时间的个体具有较低的预测风险评分时，即对于一个可纳对，模型的风险排序与观测到的事件时间排序不一致时，就会出现不一致对。这种不一致直接表明了区分度上的错误，因为区分度衡量的是模型根据事件时间正确排序风险的能力（当较短观测时间发生事件时，即 $\\Delta = 1$，较大的 $r(\\mathbf{x})$ 应对应较小的 $T$）。相比之下，校准度关注的是预测的绝对风险或风险水平与随时间观测到的结果频率之间的一致性；它要求预测的数值尺度与观测到的概率或率相匹配。一个模型可以具有良好的校准度但区分度差（许多不一致对），或者校准度差但保持良好的区分度（很少不一致对）。在这个数据集中，没有不一致对意味着对这些受试者有完美的区分度，但这本身并不保证绝对风险尺度的完美校准。\n\n因此，计算出的 C-index 为 $1$。", "answer": "$$\\boxed{1}$$", "id": "5189334"}, {"introduction": "在处理真实世界的生存数据时，我们经常会遇到生存时间或模型预测的风险评分完全相同的情况，这被称为“结”（ties）。本练习将介绍处理这些“结”的标准方法，展示了即使数据点不唯一，我们也能进行严谨的模型评估 [@problem_id:4562877]。掌握这项技能对于将C-index稳健地应用于临床或实验数据集至关重要，因为它确保了评估结果的准确性和可信度。", "problem": "一个研究团队正在评估一个基于放射组学的生存模型，该模型为每位患者 $i$ 输出一个连续的风险评分 $r_i$，其中较大的 $r_i$ 表示较高的风险，因此有更早发生事件的趋势。对于一个包含六名患者的队列，其观测生存数据如下，其中 $t_i$ 是观测时间，$\\delta_i$ 是事件指示符（$\\delta_i=1$ 表示观测到事件，$\\delta_i=0$ 表示右删失），$r_i$ 是预测的风险评分：\n- 患者 A：$t_{\\mathrm{A}}=6$，$\\delta_{\\mathrm{A}}=1$，$r_{\\mathrm{A}}=0.80$\n- 患者 B：$t_{\\mathrm{B}}=6$，$\\delta_{\\mathrm{B}}=1$，$r_{\\mathrm{B}}=0.50$\n- 患者 C：$t_{\\mathrm{C}}=9$，$\\delta_{\\mathrm{C}}=0$，$r_{\\mathrm{C}}=0.70$\n- 患者 D：$t_{\\mathrm{D}}=11$，$\\delta_{\\mathrm{D}}=1$，$r_{\\mathrm{D}}=0.60$\n- 患者 E：$t_{\\mathrm{E}}=14$，$\\delta_{\\mathrm{E}}=0$，$r_{\\mathrm{E}}=0.60$\n- 患者 F：$t_{\\mathrm{F}}=13$，$\\delta_{\\mathrm{F}}=1$，$r_{\\mathrm{F}}=0.80$\n\n使用一致性指数（C-index）的基本定义，通过比较所有无序患者对来评估该模型的区分度，并遵循以下科学标准的平局处理协议：\n- 如果一对患者 $\\{i,j\\}$ 中 $\\min\\{t_i,t_j\\}$ 严格小于另一个时间，并且对应一个观测到的事件（即，两个观测时间中较早的那个是事件时间），则该对被认为是可比较的。观测时间相等的对是不可比较的。\n- 对于一个可比较的对，如果事件时间较早的患者比另一位患者有更高的风险评分，则该对被记为一致 (concordant)。如果事件时间较早的患者比另一位患者有更低的风险评分，则记为不一致 (discordant)。\n- 对于风险评分相同的可比较对，给予 0.5 分。\n- 如果较早的观测时间是删失的，则该对是不可比较的。\n\n根据这些规则计算该数据集的一致性指数（C-index）。将最终答案表示为单个最简分数。", "solution": "该问题要求计算给定生存数据集的一致性指数（C-index）。C-index通过测量可比较的患者对中，模型正确预测生存事件顺序的比例，来量化模型的区分能力。较高的风险评分应对应于较早的事件时间。\n\n首先，我们重述这六名患者的数据，索引为 $i \\in \\{\\mathrm{A}, \\mathrm{B}, \\mathrm{C}, \\mathrm{D}, \\mathrm{E}, \\mathrm{F}\\}$。对于每位患者 $i$，我们有观测时间 $t_i$、事件指示符 $\\delta_i$（其中 $\\delta_i=1$ 表示事件，$\\delta_i=0$ 表示右删失）和预测的风险评分 $r_i$。\n\n- 患者 $\\mathrm{A}$：$t_{\\mathrm{A}}=6$，$\\delta_{\\mathrm{A}}=1$，$r_{\\mathrm{A}}=0.80$\n- 患者 $\\mathrm{B}$：$t_{\\mathrm{B}}=6$，$\\delta_{\\mathrm{B}}=1$，$r_{\\mathrm{B}}=0.50$\n- 患者 $\\mathrm{C}$：$t_{\\mathrm{C}}=9$，$\\delta_{\\mathrm{C}}=0$，$r_{\\mathrm{C}}=0.70$\n- 患者 $\\mathrm{D}$：$t_{\\mathrm{D}}=11$，$\\delta_{\\mathrm{D}}=1$，$r_{\\mathrm{D}}=0.60$\n- 患者 $\\mathrm{F}$：$t_{\\mathrm{F}}=13$，$\\delta_{\\mathrm{F}}=1$，$r_{\\mathrm{F}}=0.80$\n- 患者 $\\mathrm{E}$：$t_{\\mathrm{E}}=14$，$\\delta_{\\mathrm{E}}=0$，$r_{\\mathrm{E}}=0.60$\n注意，为了程序的清晰性，患者已按其观测时间 $t_i$ 重新排序。\n\nC-index 的定义如下：\n$$ C = \\frac{ \\text{一致对的数量} + (0.5 \\times \\text{风险评分相同对的数量}) }{ \\text{可比较对的总数} } $$\n我们必须系统地评估所有 $\\binom{6}{2} = \\frac{6 \\times 5}{2} = 15$ 个唯一的无序患者对，以确定哪些是可比较的，以及在这些可比较的对中，哪些是一致的、不一致的或风险评分相同的。\n\n根据提供的规则：\n1.  如果一对患者 $\\{i, j\\}$ 的观测时间不同，且时间较早的患者发生了事件，则该对是**可比较的**。也就是说，如果我们假设 $t_i  t_j$，那么当且仅当 $\\delta_i=1$ 时，该对是可比较的。\n2.  观测时间相等的对（$t_i = t_j$）是不可比较的。\n3.  对于一个可比较的对，其中 $t_i  t_j$ 且 $\\delta_i = 1$：\n    - 如果事件时间较早的患者有更高的风险评分（$r_i > r_j$），则该对是**一致的**。这对分子贡献 $1$。\n    - 如果 $r_i  r_j$，则该对是**不一致的**。这对分子贡献 $0$。\n    - 如果 $r_i = r_j$，则该对存在**风险评分平局**。这对分子贡献 $0.5$。\n\n我们依次考虑每个发生了事件的患者 $i$（$\\delta_i=1$），并将其与所有观测时间更晚的患者 $j$（$t_j > t_i$）进行比较。\n\n**1. 患者 A ($t_{\\mathrm{A}}=6, \\delta_{\\mathrm{A}}=1, r_{\\mathrm{A}}=0.80$):**\n患者 $\\mathrm{A}$ 与所有 $t_j > 6$ 的患者进行比较：$\\mathrm{C}$、$\\mathrm{D}$、$\\mathrm{F}$、$\\mathrm{E}$。（患者 $\\mathrm{B}$ 的 $t_{\\mathrm{B}}=6$，因此与 $\\mathrm{A}$ 不可比较）。\n-   对 $\\{\\mathrm{A}, \\mathrm{C}\\}$ ($t_{\\mathrm{A}}=6  t_{\\mathrm{C}}=9$): 可比较。$r_{\\mathrm{A}}=0.80 > r_{\\mathrm{C}}=0.70$。**一致** (得分: $1$)。\n-   对 $\\{\\mathrm{A}, \\mathrm{D}\\}$ ($t_{\\mathrm{A}}=6  t_{\\mathrm{D}}=11$): 可比较。$r_{\\mathrm{A}}=0.80 > r_{\\mathrm{D}}=0.60$。**一致** (得分: $1$)。\n-   对 $\\{\\mathrm{A}, \\mathrm{F}\\}$ ($t_{\\mathrm{A}}=6  t_{\\mathrm{F}}=13$): 可比较。$r_{\\mathrm{A}}=0.80 = r_{\\mathrm{F}}=0.80$。**平局** (得分: $0.5$)。\n-   对 $\\{\\mathrm{A}, \\mathrm{E}\\}$ ($t_{\\mathrm{A}}=6  t_{\\mathrm{E}}=14$): 可比较。$r_{\\mathrm{A}}=0.80 > r_{\\mathrm{E}}=0.60$。**一致** (得分: $1$)。\n来自患者 $\\mathrm{A}$，我们得到 $4$ 个可比较对。得分总和为 $1 + 1 + 0.5 + 1 = 3.5$。\n\n**2. 患者 B ($t_{\\mathrm{B}}=6, \\delta_{\\mathrm{B}}=1, r_{\\mathrm{B}}=0.50$):**\n患者 $\\mathrm{B}$ 与所有 $t_j > 6$ 的患者进行比较：$\\mathrm{C}$、$\\mathrm{D}$、$\\mathrm{F}$、$\\mathrm{E}$。\n-   对 $\\{\\mathrm{B}, \\mathrm{C}\\}$ ($t_{\\mathrm{B}}=6  t_{\\mathrm{C}}=9$): 可比较。$r_{\\mathrm{B}}=0.50  r_{\\mathrm{C}}=0.70$。**不一致** (得分: $0$)。\n-   对 $\\{\\mathrm{B}, \\mathrm{D}\\}$ ($t_{\\mathrm{B}}=6  t_{\\mathrm{D}}=11$): 可比较。$r_{\\mathrm{B}}=0.50  r_{\\mathrm{D}}=0.60$。**不一致** (得分: $0$)。\n-   对 $\\{\\mathrm{B}, \\mathrm{F}\\}$ ($t_{\\mathrm{B}}=6  t_{\\mathrm{F}}=13$): 可比较。$r_{\\mathrm{B}}=0.50  r_{\\mathrm{F}}=0.80$。**不一致** (得分: $0$)。\n-   对 $\\{\\mathrm{B}, \\mathrm{E}\\}$ ($t_{\\mathrm{B}}=6  t_{\\mathrm{E}}=14$): 可比较。$r_{\\mathrm{B}}=0.50  r_{\\mathrm{E}}=0.60$。**不一致** (得分: $0$)。\n来自患者 $\\mathrm{B}$，我们得到 $4$ 个可比较对。得分总和为 $0 + 0 + 0 + 0 = 0$。\n\n**3. 患者 C ($t_{\\mathrm{C}}=9, \\delta_{\\mathrm{C}}=0$):**\n患者 $\\mathrm{C}$ 是删失数据，因此没有以 $\\mathrm{C}$ 作为时间较早者的可比较对。\n\n**4. 患者 D ($t_{\\mathrm{D}}=11, \\delta_{\\mathrm{D}}=1, r_{\\mathrm{D}}=0.60$):**\n患者 $\\mathrm{D}$ 与所有 $t_j > 11$ 的患者进行比较：$\\mathrm{F}$、$\\mathrm{E}$。\n-   对 $\\{\\mathrm{D}, \\mathrm{F}\\}$ ($t_{\\mathrm{D}}=11  t_{\\mathrm{F}}=13$): 可比较。$r_{\\mathrm{D}}=0.60  r_{\\mathrm{F}}=0.80$。**不一致** (得分: $0$)。\n-   对 $\\{\\mathrm{D}, \\mathrm{E}\\}$ ($t_{\\mathrm{D}}=11  t_{\\mathrm{E}}=14$): 可比较。$r_{\\mathrm{D}}=0.60 = r_{\\mathrm{E}}=0.60$。**平局** (得分: $0.5$)。\n来自患者 $\\mathrm{D}$，我们得到 $2$ 个可比较对。得分总和为 $0 + 0.5 = 0.5$。\n\n**5. 患者 F ($t_{\\mathrm{F}}=13, \\delta_{\\mathrm{F}}=1, r_{\\mathrm{F}}=0.80$):**\n患者 $\\mathrm{F}$ 与所有 $t_j > 13$ 的患者进行比较：$\\mathrm{E}$。\n-   对 $\\{\\mathrm{F}, \\mathrm{E}\\}$ ($t_{\\mathrm{F}}=13  t_{\\mathrm{E}}=14$): 可比较。$r_{\\mathrm{F}}=0.80 > r_{\\mathrm{E}}=0.60$。**一致** (得分: $1$)。\n来自患者 $\\mathrm{F}$，我们得到 $1$ 个可比较对。得分总和为 $1$。\n\n**6. 患者 E ($t_{\\mathrm{E}}=14, \\delta_{\\mathrm{E}}=0$):**\n患者 $\\mathrm{E}$ 是删失数据，并且是最后的观测，因此没有形成可比较对。\n\n现在，我们汇总结果：\n-   可比较对的总数 ($N_{comp}$): $4$ (来自 A) + $4$ (来自 B) + $2$ (来自 D) + $1$ (来自 F) = $11$。\n-   分子的总得分: $3.5$ (来自 A) + $0$ (来自 B) + $0.5$ (来自 D) + $1$ (来自 F) = $5.0$。\n\n最后，我们计算 C-index：\n$$ C = \\frac{\\text{总得分}}{N_{comp}} = \\frac{5.0}{11} = \\frac{5}{11} $$\n结果已经是最简分数。", "answer": "$$\\boxed{\\frac{5}{11}}$$", "id": "4562877"}, {"introduction": "理解了C-index的计算原理后，下一步是将其应用于实际的机器学习工作流中。本练习将从手动计算转向实际应用，要求你通过编写代码实现交叉验证来优化模型的超参数 [@problem_id:4562915]。通过这个过程，你将看到C-index如何作为关键性能指标，指导我们选择和改进预测生存模型，从而将理论知识转化为解决实际问题的能力。", "problem": "您将获得三个受放射组学启发的微型生存数据集，其中每个患者都有一个从基于图像的量化描述符派生出的定长特征向量、一个观测生存时间以及一个事件指示符。您的任务是实现超参数调优，以优化一个简单线性风险评分模型的一致性指数 (C-index)。生存时间应以月为单位进行解释；无需进行单位转换，所有输出必须是无单位的数字。\n\n从基本定义出发，采用以下建模和评估基础：\n- 对于 $n$ 名患者，放射组学特征矩阵表示为 $X \\in \\mathbb{R}^{n \\times p}$，其中每一行 $x_i \\in \\mathbb{R}^p$ 是一个标准化的描述符向量。观测生存时间为 $T \\in \\mathbb{R}^n$（严格为正，以月为单位），事件指示符为 $E \\in \\{0,1\\}^n$，其中 $E_i = 1$ 表示事件（例如死亡或疾病进展）已被观测到，而 $E_i = 0$ 表示右删失。\n- 患者 $i$ 的线性风险评分定义为 $s_i = -\\hat{y}_i$，其中 $\\hat{y}_i = x_i^\\top \\beta$ 且 $\\beta \\in \\mathbb{R}^p$ 是通过在训练折上仅使用未删失患者进行岭回归学习得到的。具体来说，如果 $U = \\{i \\in \\{1,\\dots,n\\} : E_i = 1\\}$ 是训练折中未删失患者的索引集合，则对于 $i \\in U$，设置 $y_i = \\log(T_i)$，并通过在训练折上最小化带有 $\\ell_2$ 正则化强度 $\\lambda  0$ 的平方误差来学习 $\\beta$，此过程在利用训练折统计数据进行特征标准化之后进行。在拟合 $\\beta$ 时仅使用 $i \\in U$。如果一个训练折不包含任何未删失的患者（$|U| = 0$），则按惯例定义 $\\beta = 0 \\in \\mathbb{R}^p$。\n- 一致性指数 (C-index) 是使用可比较对之间的成对排序来定义的。如果两个患者 $i$ 和 $j$ 中，较短的观测时间对应于一个未删失事件，则它们构成一个可比较对。具体而言，如果 $E_i = 1$ 且 $T_i  T_j$，或者 $E_j = 1$ 且 $T_j  T_i$，则 $i$ 和 $j$ 是可比较的。$T_i = T_j$ 的配对不可比较。如果观测事件时间较短的患者具有较高的风险评分，则该可比较对是一致的。如果在一个可比较对上两个风险评分相等，则该配对算作半个一致对。$C$ 指数是所有可比较对中一致对的比例。如果没有可比较对，则定义 $C$ 指数为 $0.5$。\n\n实施 $K$ 折交叉验证 (CV)，对患者索引进行连续、确定性的划分，以从给定的网格中选择能够最大化平均验证折 $C$ 指数的正则化超参数 $\\lambda$。通过选择最小的 $\\lambda$ 来打破平局。\n\n对于下面的每个数据集，执行以下步骤：\n1. 使用训练折中每个特征的均值和标准差来标准化特征。如果某个特征在训练折上的标准差为零，则为了数值稳定性，将其标准差替换为 $1$。\n2. 仅使用未删失的患者和给定的 $\\lambda$，在训练折上拟合 $\\beta$，并将岭惩罚应用于所有系数。在此拟合中使用训练折的标准化。\n3. 使用相同的训练标准化计算验证折的风险评分 $s_i = -x_i^\\top \\beta$，并使用上述定义评估验证折的 $C$ 指数。\n4. 对每个 $\\lambda$，计算所有 $K$ 个折的验证折 $C$ 指数的平均值。\n5. 选择使平均验证 $C$ 指数最大化的 $\\lambda$，通过选择最小的 $\\lambda$ 来打破平局。\n6. 对每个数据集，报告所选的 $\\lambda$ 和相应的平均交叉验证 $C$ 指数。\n\n数据集和超参数网格：\n- 测试用例 $1$ (理想路径，混合删失)：\n  - $X \\in \\mathbb{R}^{12 \\times 3}$:\n    $$\n    X = \\begin{bmatrix}\n    0.8  1.2  0.5 \\\\\n    1.0  0.9  0.7 \\\\\n    0.3  1.5  0.2 \\\\\n    1.1  1.1  0.4 \\\\\n    0.7  0.8  0.6 \\\\\n    1.3  1.0  0.5 \\\\\n    0.2  0.4  0.1 \\\\\n    1.0  1.4  0.3 \\\\\n    0.6  0.7  0.8 \\\\\n    1.2  1.0  0.9 \\\\\n    0.5  0.9  0.2 \\\\\n    0.9  1.3  0.4\n    \\end{bmatrix}\n    $$\n  - $T = [12,10,20,9,14,8,30,11,15,7,25,13]$ 月\n  - $E = [1,1,0,1,1,1,0,1,0,1,0,1]$\n  - $\\Lambda = [0.01, 0.1, 1.0, 10.0]$, $K = 3$\n- 测试用例 $2$ (边界情况，全部删失)：\n  - $X \\in \\mathbb{R}^{8 \\times 2}$:\n    $$\n    X = \\begin{bmatrix}\n    0.2  0.1 \\\\\n    0.5  0.4 \\\\\n    0.3  0.2 \\\\\n    0.7  0.6 \\\\\n    0.9  0.8 \\\\\n    0.4  0.3 \\\\\n    0.6  0.5 \\\\\n    0.1  0.2\n    \\end{bmatrix}\n    $$\n  - $T = [10,12,9,11,13,8,14,15]$ 月\n  - $E = [0,0,0,0,0,0,0,0]$\n  - $\\Lambda = [0.1, 1.0]$, $K = 4$\n- 测试用例 $3$ (特征和时间存在相等情况)：\n  - $X \\in \\mathbb{R}^{10 \\times 2}$:\n    $$\n    X = \\begin{bmatrix}\n    1.0  1.0 \\\\\n    1.0  1.0 \\\\\n    0.5  0.5 \\\\\n    0.5  0.5 \\\\\n    1.5  1.0 \\\\\n    0.7  0.9 \\\\\n    1.2  0.8 \\\\\n    0.8  1.1 \\\\\n    1.0  0.9 \\\\\n    1.1  1.0\n    \\end{bmatrix}\n    $$\n  - $T = [10,10,20,20,8,15,9,16,12,11]$ 月\n  - $E = [1,1,0,1,1,1,1,0,1,1]$\n  - $\\Lambda = [0.001, 0.1, 5.0]$, $K = 5$\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个双元素列表 $[\\lambda^\\ast, \\bar{C}]$，其中 $\\lambda^\\ast$ 是所选的正则化值，$\\bar{C}$ 是该 $\\lambda^\\ast$ 对应的平均交叉验证 $C$ 指数。例如，包含三个测试用例的输出应类似于 $[[\\lambda_1, c_1],[\\lambda_2, c_2],[\\lambda_3, c_3]]$，使用小数值。将每个报告的数字四舍五入到 $6$ 位小数。", "solution": "该问题陈述被评估为有效，因为它具有科学依据、提法恰当且客观。它为生存分析中的一项标准（尽管简化了）的机器学习任务提供了一套完整且一致的定义、数据和程序。该问题是可形式化的，并且需要实现一个涉及交叉验证、岭回归和一致性指数的确定性算法。\n\n解决方案通过实施指定的 $K$ 折交叉验证程序，为线性风险评分模型选择最优的正则化超参数 $\\lambda$。对于提供的三个数据集中的每一个，过程如下：\n\n首先，一个外层循环遍历提供的网格 $\\Lambda$ 中的每个 $\\lambda$ 值。对于每个 $\\lambda$，执行一次 $K$ 折交叉验证。患者索引 $\\{0, 1, \\dots, n-1\\}$ 被确定性地划分为 $K$ 个连续、不重叠的折。在 $K$ 次迭代中的每一次，一个折被指定为验证集，其余 $K-1$ 个折构成训练集。\n\n在每次交叉验证迭代中，执行以下步骤：\n1.  **数据标准化**：对训练数据 $X_{train}$ 的特征进行标准化。对于每个特征列 $j \\in \\{1, \\dots, p\\}$，从训练数据中计算均值 $\\mu_j$ 和标准差 $\\sigma_j$。应用稳定性校正：如果 $\\sigma_j = 0$，则将其设置为 $\\sigma_j = 1$。然后使用这些相同的统计数据对训练特征 $X_{train}$ 和验证特征 $X_{val}$ 进行标准化：$x'_{i,j} = (x_{i,j} - \\mu_j) / \\sigma_j$。\n\n2.  **模型拟合**：仅使用训练集中的未删失患者来训练线性模型。设 $U_{train}$ 为事件已被观测到（即 $E_i = 1$）的训练患者的索引集。如果该集合为空（$|U_{train}| = 0$），则系数向量按惯例定义为零向量 $\\beta = 0 \\in \\mathbb{R}^p$。否则，对于每个患者 $i \\in U_{train}$，回归目标定义为 $y_i = \\log(T_i)$。然后通过解决岭回归问题来估计系数向量 $\\beta$，该问题最小化目标函数 $L(\\beta) = \\sum_{i \\in U_{train}} (y_i - x'_i{}^\\top \\beta)^2 + \\lambda ||\\beta||_2^2$，其中 $x'_i$ 是患者 $i$ 的标准化特征向量。$\\beta$ 的闭式解由以下公式给出：\n    $$\n    \\beta = (X'_{U_{train}}{}^\\top X'_{U_{train}} + \\lambda I)^{-1} X'_{U_{train}}{}^\\top y_{U_{train}}\n    $$\n    其中 $X'_{U_{train}}$ 是未删失训练患者的标准化特征矩阵，$y_{U_{train}}$ 是他们对数转换后的生存时间向量，$I$ 是 $p \\times p$ 的单位矩阵。\n\n3.  **风险预测**：使用学习到的系数向量 $\\beta$ 计算验证集中每个患者 $i$ 的风险评分。风险评分 $s_i$ 定义为预测的对数生存时间的负数：\n    $$\n    s_i = -x'_{i,val}{}^\\top \\beta\n    $$\n    其中 $x'_{i,val}$ 是验证集患者 $i$ 的标准化特征向量。\n\n4.  **性能评估**：使用一致性指数 (C-index) 来量化模型在验证折上的性能。C-index 衡量了模型能正确预测生存结果顺序的可比较患者对的比例。\n    - 来自验证集的一对患者 $(i, j)$ 是**可比较的**，如果观测时间较短的患者经历了事件。即，如果 $(T_i  T_j \\text{ and } E_i=1)$ 或 $(T_j  T_i \\text{ and } E_j=1)$。生存时间相等 ($T_i = T_j$) 的配对不被视为可比较。\n    - 一个可比较对是**一致的**，如果生存时间较短的患者具有较高的预测风险评分。对于一个可比较对 $(i, j)$，其中 $T_i  T_j$ 且 $E_i=1$，一致性要求 $s_i > s_j$。如果风险评分相等 ($s_i = s_j$)，该配对对一致对的数量贡献 $0.5$。\n    - 该折的 C-index 计算如下：\n    $$\n    C = \\frac{\\text{一致对的数量}}{\\text{可比较对的数量}}\n    $$\n    如果可比较对的数量为零，则 C-index 定义为 $0.5$。\n\n遍历所有 $K$ 个折后，计算当前 $\\lambda$ 值对应的 $K$ 个验证 C-index 的平均值。对超参数网格 $\\Lambda$ 中的所有值重复此过程。\n\n最后，选择产生最高平均交叉验证 C-index 的最优超参数 $\\lambda^\\ast$。任何平局都通过选择最小的 $\\lambda$ 值来打破。每个数据集的结果是配对 $[\\lambda^\\ast, \\bar{C}_{\\lambda^\\ast}]$，其中 $\\bar{C}_{\\lambda^\\ast}$ 是对应于所选 $\\lambda^\\ast$ 的平均 C-index。此过程独立应用于指定的三个测试用例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements hyperparameter tuning for a simple radiomics survival model \n    using K-fold cross-validation to optimize the C-index.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([\n                [0.8, 1.2, 0.5], [1.0, 0.9, 0.7], [0.3, 1.5, 0.2],\n                [1.1, 1.1, 0.4], [0.7, 0.8, 0.6], [1.3, 1.0, 0.5],\n                [0.2, 0.4, 0.1], [1.0, 1.4, 0.3], [0.6, 0.7, 0.8],\n                [1.2, 1.0, 0.9], [0.5, 0.9, 0.2], [0.9, 1.3, 0.4]\n            ]),\n            np.array([12, 10, 20, 9, 14, 8, 30, 11, 15, 7, 25, 13]),\n            np.array([1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1]),\n            3,\n            [0.01, 0.1, 1.0, 10.0]\n        ),\n        (\n            np.array([\n                [0.2, 0.1], [0.5, 0.4], [0.3, 0.2], [0.7, 0.6],\n                [0.9, 0.8], [0.4, 0.3], [0.6, 0.5], [0.1, 0.2]\n            ]),\n            np.array([10, 12, 9, 11, 13, 8, 14, 15]),\n            np.array([0, 0, 0, 0, 0, 0, 0, 0]),\n            4,\n            [0.1, 1.0]\n        ),\n        (\n            np.array([\n                [1.0, 1.0], [1.0, 1.0], [0.5, 0.5], [0.5, 0.5],\n                [1.5, 1.0], [0.7, 0.9], [1.2, 0.8], [0.8, 1.1],\n                [1.0, 0.9], [1.1, 1.0]\n            ]),\n            np.array([10, 10, 20, 20, 8, 15, 9, 16, 12, 11]),\n            np.array([1, 1, 0, 1, 1, 1, 1, 0, 1, 1]),\n            5,\n            [0.001, 0.1, 5.0]\n        )\n    ]\n\n    final_results = []\n    \n    for X, T, E, K, Lambda_grid in test_cases:\n        n_patients, n_features = X.shape\n        \n        cv_results = {}\n\n        for lambda_val in Lambda_grid:\n            fold_c_indices = []\n            \n            # Deterministic, contiguous splits for K-fold CV\n            indices = np.arange(n_patients)\n            fold_indices = np.array_split(indices, K)\n\n            for k in range(K):\n                val_idx = fold_indices[k]\n                train_idx = np.concatenate([fold_indices[j] for j in range(K) if j != k])\n\n                X_train, T_train, E_train = X[train_idx], T[train_idx], E[train_idx]\n                X_val, T_val, E_val = X[val_idx], T[val_idx], E[val_idx]\n\n                # 1. Standardize features using training fold statistics\n                train_mean = np.mean(X_train, axis=0)\n                train_std = np.std(X_train, axis=0)\n                train_std[train_std == 0] = 1.0  # Replace zero std with 1\n\n                X_train_std = (X_train - train_mean) / train_std\n                X_val_std = (X_val - train_mean) / train_std\n\n                # 2. Fit beta on uncensored training patients\n                uncensored_mask_train = E_train == 1\n                \n                if np.sum(uncensored_mask_train) == 0:\n                    beta = np.zeros(n_features)\n                else:\n                    X_uncensored = X_train_std[uncensored_mask_train]\n                    T_uncensored = T_train[uncensored_mask_train]\n                    y_uncensored = np.log(T_uncensored)\n                    \n                    # Solve for beta using ridge regression formula\n                    # (X^T X + lambda I) beta = X^T y\n                    A = X_uncensored.T @ X_uncensored + lambda_val * np.identity(n_features)\n                    b = X_uncensored.T @ y_uncensored\n                    beta = np.linalg.solve(A, b)\n\n                # 3. Compute validation fold risk scores\n                risk_scores_val = - (X_val_std @ beta)\n                \n                # 4. Evaluate validation-fold C-index\n                concordant_pairs = 0\n                comparable_pairs = 0\n                \n                for i in range(len(val_idx)):\n                    for j in range(i + 1, len(val_idx)):\n                        # Check for comparability, excluding pairs with tied times\n                        if T_val[i]  T_val[j] and E_val[i] == 1:\n                            comparable_pairs += 1\n                            if risk_scores_val[i] > risk_scores_val[j]:\n                                concordant_pairs += 1\n                            elif risk_scores_val[i] == risk_scores_val[j]:\n                                concordant_pairs += 0.5\n                        elif T_val[j]  T_val[i] and E_val[j] == 1:\n                            comparable_pairs += 1\n                            if risk_scores_val[j] > risk_scores_val[i]:\n                                concordant_pairs += 1\n                            elif risk_scores_val[j] == risk_scores_val[i]:\n                                concordant_pairs += 0.5\n                \n                if comparable_pairs == 0:\n                    c_index = 0.5\n                else:\n                    c_index = concordant_pairs / comparable_pairs\n                \n                fold_c_indices.append(c_index)\n            \n            # 5. Average C-index across folds for the current lambda\n            cv_results[lambda_val] = np.mean(fold_c_indices)\n        \n        # 6. Select the best lambda\n        best_lambda = -1\n        max_c_index = -1.0\n        \n        # Iterate through grid to handle tie-breaking correctly (smallest lambda)\n        for lambda_val in sorted(cv_results.keys()):\n            if cv_results[lambda_val] > max_c_index:\n                max_c_index = cv_results[lambda_val]\n                best_lambda = lambda_val\n\n        final_results.append([round(best_lambda, 6), round(max_c_index, 6)])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{res[0]},{res[1]}]\" for res in final_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "4562915"}]}