{"hands_on_practices": [{"introduction": "Laws 纹理滤波器的设计初衷是捕捉局部变化，同时忽略均匀区域。本练习将深入探讨实现这一目标的基本原理：高通掩模的“零和”特性。通过编写一个数值验证程序 [@problem_id:4565057]，你将亲手验证这些滤波器在常量图像上会产生接近零的响应，从而具体理解它们的工作方式，并掌握一种检测基本实现错误的方法。", "problem": "在放射组学纹理分析中，Laws 纹理能量测度依赖于将图像与从一维 Laws 向量派生出的可分离高通掩模进行卷积，然后计算能量汇总统计量。高通掩模的一个基本性质是所有掩模系数的总和为零。因此，当这种掩模与一个恒定图像进行卷积时，除了边界处的响应外，其他所有地方的响应都应接近于零，而边界效应可以通过使用有效卷积区域来消除。该性质可用于数值上检测预处理错误，例如不正确的归一化或意外的偏移。\n\n从以下基本依据出发：\n- 离散图像 $I$ 和离散滤波器 $H$ 之间的二维 (2D) 离散卷积的定义，\n$$\n(I * H)[i,j] \\;=\\; \\sum_{p}\\sum_{q} I[i - p, j - q]\\, H[p, q],\n$$\n其中求和是在 $H$ 的有限支撑域上进行的。\n- 标准的长度为 $5$ 的一维 (1D) Laws 向量，由下式给出\n$$\nL_5 = [\\,1,\\,4,\\,6,\\,4,\\,1\\,],\\quad\nE_5 = [\\,-1,\\,-2,\\,0,\\,2,\\,1\\,],\\quad\nS_5 = [\\,-1,\\,0,\\,2,\\,0,\\,-1\\,],\n$$\n$$\nW_5 = [\\,-1,\\,2,\\,0,\\,-2,\\,1\\,],\\quad\nR_5 = [\\,1,\\,-4,\\,6,\\,-4,\\,1\\,],\n$$\n以及通过两个一维向量的外积构建二维可分离掩模，\n$$\nH \\;=\\; u\\, v^{\\top},\n$$\n其中 $u \\in \\{L_5, E_5, S_5, W_5, R_5\\}$ 且 $v \\in \\{L_5, E_5, S_5, W_5, R_5\\}$。\n\n您的任务是实现一个程序，对于给定的包含此类掩模和恒定图像的小型测试套件，为每个测试用例数值上验证以下两个标准：\n- 零和性质：所有掩模系数的绝对值总和小于或等于指定的容差 $\\tau_s$。\n- 在恒定图像上的近零响应：当使用有效卷积将恒定图像 $I[i,j] = c$ 与掩模进行卷积时，定义为平均绝对响应的纹理能量，\n$$\nTE(I,H) \\;=\\; \\frac{1}{M} \\sum_{(i,j)\\in \\Omega_{\\text{valid}}} \\big| (I * H)[i,j] \\big|,\n$$\n小于或等于指定的容差 $\\tau_e$，其中 $\\Omega_{\\text{valid}}$ 表示有效卷积区域，而 $M$ 是其基数。\n\n对于每个测试用例，输出一个布尔值，当且仅当上述两个标准都满足时，该值为真。程序必须通过指定的外积构建指定的二维掩模 $H$，可选地通过一个标量因子对其进行缩放，并可选地通过一个小的加性值扰动单个系数以模拟预处理错误。然后，它必须将 $H$ 与指定大小和恒定水平 $c$ 的恒定图像进行卷积，计算有效区域上的 $TE(I,H)$，并评估这两个标准。\n\n实现以下测试套件。每个测试用例指定：\n- 从 $\\{L_5, E_5, S_5, W_5, R_5\\}$ 中选择的行向量 $u$ 和列向量 $v$，\n- 一个用于乘以掩模的缩放因子 $s$，\n- 一个可选的扰动三元组 $(i_p, j_p, \\delta)$，表示在缩放后应将 $\\delta$ 添加到行索引 $i_p$ 和列索引 $j_p$（从零开始的索引）处的单个掩模条目中，\n- 一个 $N \\times N$ 恒定图像的图像大小 $N$，\n- 图像的恒定水平 $c$，\n- 容差 $\\tau_s$ 和 $\\tau_e$。\n\n使用以下六个测试用例：\n1. $u = E_5$, $v = L_5$, $s = 1.0$, 无扰动, $N = 64$, $c = 7.0$, $\\tau_s = 10^{-12}$, $\\tau_e = 10^{-12}$。\n2. $u = L_5$, $v = L_5$, $s = 1.0$, 无扰动, $N = 32$, $c = 2.0$, $\\tau_s = 10^{-12}$, $\\tau_e = 10^{-12}$。\n3. $u = W_5$, $v = S_5$, $s = 3.0$, 无扰动, $N = 48$, $c = 5.0$, $\\tau_s = 10^{-12}$, $\\tau_e = 10^{-12}$。\n4. $u = E_5$, $v = S_5$, $s = 1.0$, 扰动 $(i_p, j_p, \\delta) = (2, 2, 10^{-6})$, $N = 40$, $c = 1.0$, $\\tau_s = 10^{-8}$, $\\tau_e = 10^{-8}$。\n5. $u = R_5$, $v = R_5$, $s = 1.0$, 无扰动, $N = 5$, $c = 10.0$, $\\tau_s = 10^{-12}$, $\\tau_e = 10^{-12}$。\n6. $u = L_5$, $v = E_5$, $s = 1.0$, 无扰动, $N = 64$, $c = 3.0$, $\\tau_s = 10^{-12}$, $\\tau_e = 10^{-12}$。\n\n实现细节：\n- 构建 $H = s \\cdot (u\\, v^{\\top})$，然后如果指定了扰动，则应用该扰动。\n- 使用有效卷积执行二维卷积以避免边界效应；只有有效部分对 $TE(I,H)$ 有贡献。\n- 所有计算都是无量纲的；不需要物理单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,\\dots,result_6]$），其中每个 $result_k$ 是按顺序对应于测试用例 $k$ 的布尔值。", "solution": "该问题要求对 Laws 纹理掩模的基本性质进行数值验证，特别是它们在应用于恒定图像时的行为。解决方案涉及基于数字信号处理和线性代数原理实现一个算法。\n\nLaws 方法的基础在于一组长度为 5 的一维 (1D) 向量。问题提供了标准集合：\n$$L_5 = [\\,1,\\,4,\\,6,\\,4,\\,1\\,]$$\n$$E_5 = [\\,-1,\\,-2,\\,0,\\,2,\\,1\\,]$$\n$$S_5 = [\\,-1,\\,0,\\,2,\\,0,\\,-1\\,]$$\n$$W_5 = [\\,-1,\\,2,\\,0,\\,-2,\\,1\\,]$$\n$$R_5 = [\\,1,\\,-4,\\,6,\\,-4,\\,1\\,]$$\n\n这些向量可以根据其滤波特性进行分类。向量 $L_5$ (Level) 是一个低通平均滤波器。其他四个向量——$E_5$ (Edge)、$S_5$ (Spot)、$W_5$ (Wave) 和 $R_5$ (Ripple)——是高通或带通滤波器，旨在检测特定的纹理基元。这些高通滤波器的一个决定性特征是其系数之和为零。这可以通过直接求和来验证：\n$\\sum E_5 = -1 - 2 + 0 + 2 + 1 = 0$\n$\\sum S_5 = -1 + 0 + 2 + 0 - 1 = 0$\n$\\sum W_5 = -1 + 2 + 0 - 2 + 1 = 0$\n$\\sum R_5 = 1 - 4 + 6 - 4 + 1 = 0$\n相比之下，低通滤波器 $L_5$ 不具备此性质： $\\sum L_5 = 1 + 4 + 6 + 4 + 1 = 16$。\n\n二维 (2D) 可分离掩模 $H$ 是通过两个一维向量 $u$ 和 $v$ 的外积构建的：\n$$H = u v^\\top$$\n得到的二维掩模 $H$ 中所有系数的总和可以表示为：\n$$\\sum_{i,j} H[i, j] = \\sum_{i,j} u[i] v[j] = \\left(\\sum_i u[i]\\right) \\left(\\sum_j v[j]\\right)$$\n该恒等式表明，如果构成二维掩模 $H$ 的一维向量 $u$ 或 $v$ 中至少有一个是零和的，那么 $H$ 就是一个零和掩模。因此，任何由至少一个来自 $\\{E_5, S_5, W_5, R_5\\}$ 的向量构建的掩模都将是零和掩模。唯一导致非零和掩模的组合是 $L_5 L_5^\\top$。\n\n需要验证的核心原理是这些掩模对恒定输入的响应。考虑一个处处恒定的离散图像 $I$，即对于某个常数 $c$，有 $I[i,j] = c$。$I$ 与掩模 $H$ 的二维卷积由下式给出：\n$$(I * H)[i,j] = \\sum_{p}\\sum_{q} I[i - p, j - q] H[p, q]$$\n由于 $I$ 是恒定的，对于所有的 $p, q$，$I[i - p, j - q] = c$。因此，表达式简化为：\n$$(I * H)[i,j] = \\sum_{p}\\sum_{q} c \\, H[p, q] = c \\left(\\sum_{p,q} H[p, q]\\right)$$\n如果 $H$ 是一个零和掩模，那么 $\\sum_{p,q} H[p, q] = 0$，卷积的结果是 $(I * H)[i, j] = c \\cdot 0 = 0$ 对所有输出像素 $(i,j)$ 都成立。这对于‘有效’卷积区域是成立的，在该区域中，核 $H$ 完全包含在图像内部，从而避免了任何边界效应。\n\n该问题要求对此性质进行数值验证，这需要进行两项检查，以考虑浮点计算的不精确性和可能引入的误差。\n\n**标准 1：掩模的零和性质。**\n此检查直接验证构建的掩模 $H$ 是否在给定数值容差 $\\tau_s$ 内是零和的。掩模可能会被扰动，例如通过向其一个系数添加一个小的数值 $\\delta$。检查公式为：\n$$\\left| \\sum_{i,j} H[i, j] \\right| \\le \\tau_s$$\n如果一个掩模由至少一个零和向量构成且未被扰动，在理想算术中其总和将精确为 $0$。在浮点计算中，这个总和应该非常接近 $0$。一个非零和掩模（如 $L_5 L_5^\\top$）或一个被扰动的零和掩模，如果其结果总和超过容差，则很可能无法通过此检查。\n\n**标准 2：在恒定图像上的近零响应。**\n此检查验证零和性质的最终结果。纹理能量 $TE(I,H)$ 定义为有效卷积区域 $\\Omega_{\\text{valid}}$ 内的平均绝对响应：\n$$TE(I,H) = \\frac{1}{M} \\sum_{(i,j)\\in \\Omega_{\\text{valid}}} \\big| (I * H)[i,j] \\big| \\le \\tau_e$$\n其中 $M$ 是 $\\Omega_{\\text{valid}}$ 中的像素数。如果标准 1 成立且掩模总和（接近）为零，则卷积输出 $(I * H)[i,j]$ 也应处处（接近）为零。因此，纹理能量 $TE$ 应该非常小并满足此条件。\n\n每个测试用例的总体算法如下：\n1.  选择指定的一维向量 $u$ 和 $v$。\n2.  通过缩放外积构建二维掩模 $H$：$H = s \\cdot (u v^\\top)$。\n3.  如果指定了扰动 $(i_p, j_p, \\delta)$，则修改掩模：$H[i_p, j_p] \\leftarrow H[i_p, j_p] + \\delta$。\n4.  计算掩模系数的绝对值总和，并检查其是否在容差 $\\tau_s$ 之内。\n5.  生成值为 $c$ 的 $N \\times N$ 恒定图像。\n6.  对图像和掩模进行二维卷积，只保留输出的‘有效’部分。\n7.  通过取有效卷积输出的绝对值的平均值来计算纹理能量 $TE$。\n8.  检查纹理能量是否在容差 $\\tau_e$ 之内。\n9.  当且仅当两个检查（来自步骤 4 和 8）都通过时，该测试用例的结果为 `True`。\n\n例如，在测试用例 2 ($u=L_5, v=L_5$) 中，掩模系数的总和为 $s \\cdot (\\sum L_5) \\cdot (\\sum L_5) = 1.0 \\cdot 16 \\cdot 16 = 256$。由于 $|256|$ 不小于或等于 $\\tau_s=10^{-12}$，该用例未通过标准 1，最终结果为 `False`。相反，对于测试用例 1 ($u=E_5, v=L_5$)，系数总和为 $s \\cdot (\\sum E_5) \\cdot (\\sum L_5) = 1.0 \\cdot 0 \\cdot 16 = 0$。这通过了标准 1。随后与恒定图像的卷积产生近零响应，通过了标准 2。因此，结果是 `True`。测试用例 4 引入了 $\\delta=10^{-6}$ 的扰动，导致掩模总和变为 $10^{-6}$，这大于容差 $\\tau_s=10^{-8}$，因此它未通过标准 1。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef solve():\n    \"\"\"\n    Validates Laws' texture masks against zero-sum and near-zero response properties.\n    \"\"\"\n    laws_vectors = {\n        'L5': np.array([1, 4, 6, 4, 1], dtype=np.float64),\n        'E5': np.array([-1, -2, 0, 2, 1], dtype=np.float64),\n        'S5': np.array([-1, 0, 2, 0, -1], dtype=np.float64),\n        'W5': np.array([-1, 2, 0, -2, 1], dtype=np.float64),\n        'R5': np.array([1, -4, 6, -4, 1], dtype=np.float64),\n    }\n\n    test_cases = [\n        {'u': 'E5', 'v': 'L5', 's': 1.0, 'pert': None, 'N': 64, 'c': 7.0, 'tau_s': 1e-12, 'tau_e': 1e-12},\n        {'u': 'L5', 'v': 'L5', 's': 1.0, 'pert': None, 'N': 32, 'c': 2.0, 'tau_s': 1e-12, 'tau_e': 1e-12},\n        {'u': 'W5', 'v': 'S5', 's': 3.0, 'pert': None, 'N': 48, 'c': 5.0, 'tau_s': 1e-12, 'tau_e': 1e-12},\n        {'u': 'E5', 'v': 'S5', 's': 1.0, 'pert': (2, 2, 1e-6), 'N': 40, 'c': 1.0, 'tau_s': 1e-8, 'tau_e': 1e-8},\n        {'u': 'R5', 'v': 'R5', 's': 1.0, 'pert': None, 'N': 5, 'c': 10.0, 'tau_s': 1e-12, 'tau_e': 1e-12},\n        {'u': 'L5', 'v': 'E5', 's': 1.0, 'pert': None, 'N': 64, 'c': 3.0, 'tau_s': 1e-12, 'tau_e': 1e-12},\n    ]\n\n    results = []\n    for case in test_cases:\n        u_vec = laws_vectors[case['u']]\n        v_vec = laws_vectors[case['v']]\n\n        # 1. Construct the 2D mask = s * (u v^T)\n        H = case['s'] * np.outer(u_vec, v_vec)\n\n        # 2. Apply optional perturbation\n        if case['pert']:\n            i_p, j_p, delta = case['pert']\n            H[i_p, j_p] += delta\n\n        # 3. Criterion 1: Verify the zero-sum property of the mask\n        mask_sum_abs = np.abs(np.sum(H))\n        criterion1_passed = mask_sum_abs = case['tau_s']\n\n        # 4. Create the constant image\n        image = np.full((case['N'], case['N']), case['c'], dtype=np.float64)\n\n        # 5. Perform 2D convolution with 'valid' mode\n        conv_output = convolve2d(image, H, mode='valid')\n\n        # 6. Criterion 2: Verify near-zero response\n        texture_energy = 0.0\n        if conv_output.size > 0:\n            texture_energy = np.mean(np.abs(conv_output))\n        \n        criterion2_passed = texture_energy = case['tau_e']\n\n        # The final result is true if and only if both criteria are satisfied.\n        results.append(criterion1_passed and criterion2_passed)\n\n    # Format the final output as a comma-separated list of booleans in a string\n    # Python's `str(bool)` converts True to \"True\" and False to \"False\"\n    # The problem asks for lowercase \"true\" and \"false\", so we adjust.\n    output_str = f\"[{','.join(str(r).lower() for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "4565057"}, {"introduction": "验证了滤波器在常量图像上的行为后，下一步自然是测试其对不同纹理的响应。本练习运用了线性系统理论中的一个强大概念：滤波器对简单正弦波的响应可以通过其频率响应精确预测。你将创建一个包含单一正弦波模式的合成图像，并将滤波器的实际输出与理论预测值进行比较 [@problem_id:4565096]，从而深入理解空间滤波与频率分析之间的联系。", "problem": "您的任务是为 Laws 滤波器实现设计一个正确性验证测试，该测试基于线性移不变 (LSI) 系统的数学行为。在放射组学 (Radiomics) 的纹理分析中，Laws 纹理能量度量 (TEM) 使用由一维核构建的小型、可分离的二维滤波器来突显特定的纹理模式。您的测试必须在包含单个正弦分量的合成数据上验证，滤波后输出的振幅与滤波器在该正弦波空间频率处的频率响应幅值相匹配。验证必须在循环卷积下进行以避免边界伪影，并且比较必须以数值方式表示。\n\n从以下基本定义开始：\n- 一个脉冲响应为 $h[n]$ 的线性移不变 (LSI) 系统通过将输入信号 $x[n]$ 与 $h[n]$ 进行离散卷积来产生输出。\n- 对于长度为 $M$ 的掩模，有限脉冲响应 $h[n]$ 的离散时间傅里叶变换 (DTFT) 定义为 $H(\\omega) = \\sum_{n=0}^{M-1} h[n] e^{-j \\omega n}$，其中 $\\omega$ 是以弧度为单位的角频率。\n- 对于一个二维可分离掩模 $C = a b^{\\top}$，其中 $a$ 是沿 $y$ 轴应用的垂直分量，$b$ 是沿 $x$ 轴应用的水平分量，二维卷积等效于沿 $y$ 轴和 $x$ 轴的连续一维卷积。\n- 在线性移不变 (LSI) 系统下，单位振幅的单频正弦输入在滤波后仍保持相同频率的正弦波形式，其振幅按系统在该频率下的频率响应幅值进行缩放。相位可能会改变，但不会影响均方根 (RMS) 振幅。\n\n使用长度为 $5$ 的典型一维 Laws 向量：\n- $L5 = [1,4,6,4,1]$,\n- $E5 = [-1,-2,0,2,1]$,\n- $S5 = [-1,0,2,0,-1]$,\n- $W5 = [-1,2,0,-2,1]$,\n- $R5 = [1,-4,6,-4,1]$.\n\n从这些向量构建二维掩模 $C = a b^{\\top}$。处理一个大小为 $128 \\times 128$ 的合成图像 $I[x,y]$，其坐标为 $x \\in \\{0,1,\\dots,127\\}$ 和 $y \\in \\{0,1,\\dots,127\\}$。该图像应包含一个单位振幅的单一正弦波：\n$$\nI[x,y] = \\sin\\left(2\\pi\\left(\\frac{k_x}{128} x + \\frac{k_y}{128} y\\right) + \\phi\\right),\n$$\n其中 $k_x$ 和 $k_y$ 是以每个图像维度的周期数表示的整数空间频率，$\\phi$ 是一个相位偏移。请使用弧度作为 $\\phi$ 的单位。\n\n对于每个测试用例，按以下步骤操作：\n- 使用二维循环卷积将 $I[x,y]$ 与 $C$ 进行卷积，生成一个相同大小的输出 $O[x,y]$。\n- 通过均方根 (RMS) 计算 $O[x,y]$ 的测量振幅：首先计算 $R = \\sqrt{\\frac{1}{128^2}\\sum_{x=0}^{127}\\sum_{y=0}^{127} O[x,y]^2}$，然后通过 $A_{\\text{meas}} = \\sqrt{2}\\,R$ 转换为正弦振幅。\n- 从第一性原理推导可分离掩模的预测振幅 $A_{\\text{pred}}$，从一维核的离散时间傅里叶变换 (DTFT) 以及二维频率响应的可分离性出发。使用在角频率 $\\omega_x = 2\\pi \\frac{k_x}{128}$ 和 $\\omega_y = 2\\pi \\frac{k_y}{128}$ 处的复频率响应的幅值。不要假设任何预先推导的快捷公式；从 DTFT 定义以及可分离卷积和 LSI 系统的性质来证明其构建过程。\n- 将每个用例的相对误差报告为浮点数：\n$$\ne = \\frac{\\left|A_{\\text{meas}} - A_{\\text{pred}}\\right|}{\\max\\left(10^{-12}, A_{\\text{pred}}\\right)}.\n$$\n\n设计包含以下六个测试用例的测试套件，这些用例共同探测了低空间频率和高空间频率、方向选择性、可分离性和近奈奎斯特行为。在每个元组中，第一个元素是垂直核 $a$，第二个是水平核 $b$，然后是 $(k_x,k_y,\\phi)$：\n1. $(E5, L5, 8, 0, 0.0)$,\n2. $(L5, E5, 0, 8, 1.0)$,\n3. $(S5, S5, 32, 0, 0.5)$,\n4. $(R5, R5, 60, 60, 0.0)$,\n5. $(W5, L5, 1, 0, 0.0)$,\n6. $(E5, E5, 16, 16, 0.25)$.\n\n您的程序必须为六个测试用例中的每一个计算相对误差 $e$，并以确切的格式在单行中打印结果：\n- 一个由方括号括起来的、包含六个浮点数的、以逗号分隔的 Python 列表，例如 $[e_1,e_2,e_3,e_4,e_5,e_6]$。\n\n不允许使用外部输入或文件，所有角度必须以弧度为单位。程序必须使用二维循环卷积（边界环绕）并且只返回指定的单行输出。", "solution": "该问题是有效的，因为它提出了一个定义明确、科学合理的任务，该任务基于数字信号处理的基本原理。其目标是通过比较对正弦输入的经验测量响应与从滤波器频率特性推导出的理论预测响应，来验证 Laws 纹理滤波器的实现。\n\n核心原理是，一个线性移不变 (LSI) 系统在受到正弦输入时，会产生一个相同频率的正弦输出。输出正弦波的振幅是输入振幅与系统在输入频率处评估的频率响应幅值的乘积。\n\n输入信号是一个单位振幅的二维正弦波：\n$$\nI[x,y] = \\sin\\left(2\\pi\\left(\\frac{k_x}{N} x + \\frac{k_y}{N} y\\right) + \\phi\\right)\n$$\n其中 $N=128$ 是图像维度。输入振幅为 $A_{\\text{in}} = 1$。角空间频率为 $\\omega_x = 2\\pi k_x/N$ 和 $\\omega_y = 2\\pi k_y/N$。\n\n滤波器是一个 $5 \\times 5$ 的可分离掩模 $C = a b^{\\top}$，其中 $a$ 是垂直核（沿 $y$ 轴应用），$b$ 是水平核（沿 $x$ 轴应用）。输出图像为 $O = I \\circledast C$，其中 $\\circledast$ 表示二维循环卷积。\n\n**1. 预测振幅 ($A_{\\text{pred}}$) 的推导**\n\n根据 LSI 系统理论，输出信号的振幅 $A_{\\text{out}}$ 由下式给出：\n$$\nA_{\\text{out}} = A_{\\textin} \\cdot |H_C(\\omega_x, \\omega_y)|\n$$\n其中 $H_C(\\omega_x, \\omega_y)$ 是滤波器 $C$ 的二维频率响应。由于输入振幅 $A_{\\text{in}}$ 为 $1$，预测的输出振幅就是 $A_{\\text{pred}} = |H_C(\\omega_x, \\omega_y)|$。\n\n可分离滤波器的一个关键特性是，它们的二维频率响应是构成它的一维核的频率响应的乘积。核 $a$ 沿垂直方向（$y$ 轴）应用，核 $b$ 沿水平方向（$x$ 轴）应用。因此，二维频率响应为：\n$$\nH_C(\\omega_x, \\omega_y) = H_b(\\omega_x) \\cdot H_a(\\omega_y)\n$$\n其中 $H_b(\\omega_x)$ 是核 $b$ 在频率 $\\omega_x$ 处的频率响应，而 $H_a(\\omega_y)$ 是核 $a$ 在频率 $\\omega_y$ 处的频率响应。\n\n因此，预测振幅为：\n$$\nA_{\\text{pred}} = |H_b(\\omega_x) \\cdot H_a(\\omega_y)| = |H_b(\\omega_x)| \\cdot |H_a(\\omega_y)|\n$$\n对于一个给定长度为 $M=5$ 的核 $h$，其一维频率响应 $H_h(\\omega)$ 使用问题中定义的离散时间傅里叶变换 (DTFT) 计算：\n$$\nH_h(\\omega) = \\sum_{n=0}^{M-1} h[n] e^{-j \\omega n}\n$$\n在这里，$h[n]$ 是 Laws 向量的元素，索引从 $n=0$ 到 $n=4$。幅值 $|H_h(\\omega)|$ 通过取这个复数和的绝对值来计算。\n\n**2. 测量振幅 ($A_{\\text{meas}}$) 的步骤**\n\n测量振幅是通过卷积输出凭经验确定的。\n首先，为每个测试用例生成 $128 \\times 128$ 的输入图像 $I[x,y]$。\n其次，将 $5 \\times 5$ 的滤波器核 $C$ 构建为垂直核 $a$ 和水平核 $b$ 的外积，即 $C = ab^{\\top}$。\n第三，通过对输入图像 $I$ 和核 $C$ 执行二维循环卷积来计算输出图像 $O[x,y]$。\n\n输出信号 $O[x,y]$ 将是 $A_{\\text{meas}} \\sin(\\omega_x x + \\omega_y y + \\phi')$ 形式的正弦波。这样一个信号的均方根 (RMS) 值为 $R = A_{\\text{meas}}/\\sqrt{2}$。问题提供了计算离散输出图像均方根 (RMS) 的公式：\n$$\nR = \\sqrt{\\frac{1}{N^2}\\sum_{x=0}^{N-1}\\sum_{y=0}^{N-1} O[x,y]^2}\n$$\n其中 $N=128$。通过重新整理均方根 (RMS) 和振幅之间的关系，我们可以计算出测量振幅为：\n$$\nA_{\\text{meas}} = \\sqrt{2} \\cdot R\n$$\n\n**3. 误差计算**\n\n使用相对误差 $e$ 对理论预测和经验测量进行比较：\n$$\ne = \\frac{\\left|A_{\\text{meas}} - A_{\\text{pred}}\\right|}{\\max\\left(10^{-12}, A_{\\text{pred}}\\right)}\n$$\n分母中的项 $\\max(10^{-12}, A_{\\text{pred}})$ 是为了防止在滤波器预期完全抵消输入正弦波（即 $A_{\\text{pred}} = 0$）的情况下出现除以零的错误。\n\n以下程序为六个指定的测试用例实现了这整个过程。它根据 DTFT 公式计算 $A_{\\text{pred}}$，通过循环卷积和 RMS 计算 $A_{\\text{meas}}$，并最终计算每个用例的相对误差。", "answer": "```python\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef solve():\n    \"\"\"\n    Solves the Laws' filter proof-of-correctness test.\n    \"\"\"\n    \n    # Define canonical one-dimensional Laws' vectors of length 5\n    LAWS_KERNELS = {\n        'L5': np.array([1, 4, 6, 4, 1], dtype=np.float64),\n        'E5': np.array([-1, -2, 0, 2, 1], dtype=np.float64),\n        'S5': np.array([-1, 0, 2, 0, -1], dtype=np.float64),\n        'W5': np.array([-1, 2, 0, -2, 1], dtype=np.float64),\n        'R5': np.array([1, -4, 6, -4, 1], dtype=np.float64),\n    }\n\n    # Define the test suite\n    test_cases = [\n        # (vertical_kernel, horizontal_kernel, (kx, ky, phi))\n        ('E5', 'L5', (8, 0, 0.0)),\n        ('L5', 'E5', (0, 8, 1.0)),\n        ('S5', 'S5', (32, 0, 0.5)),\n        ('R5', 'R5', (60, 60, 0.0)),\n        ('W5', 'L5', (1, 0, 0.0)),\n        ('E5', 'E5', (16, 16, 0.25)),\n    ]\n\n    def calc_freq_resp_mag(kernel, omega):\n        \"\"\"\n        Calculates the magnitude of the frequency response for a 1D kernel at a\n        given angular frequency, using the DTFT definition.\n        H(omega) = sum_{n=0}^{M-1} h[n] * exp(-j * omega * n)\n        \"\"\"\n        n_indices = np.arange(len(kernel))\n        complex_exponentials = np.exp(-1j * omega * n_indices)\n        H = np.sum(kernel * complex_exponentials)\n        return np.abs(H)\n\n    results = []\n    N = 128\n    x_coords = np.arange(N)\n    y_coords = np.arange(N)\n    xx, yy = np.meshgrid(x_coords, y_coords)\n\n    for case in test_cases:\n        a_name, b_name, params = case\n        kx, ky, phi = params\n        \n        a_kernel = LAWS_KERNELS[a_name]\n        b_kernel = LAWS_KERNELS[b_name]\n\n        # 1. Derive the predicted amplitude (A_pred) from first principles\n        omega_x = 2 * np.pi * kx / N\n        omega_y = 2 * np.pi * ky / N\n        \n        # Frequency response of vertical kernel 'a' at frequency 'omega_y'\n        pred_amp_a = calc_freq_resp_mag(a_kernel, omega_y)\n        # Frequency response of horizontal kernel 'b' at frequency 'omega_x'\n        pred_amp_b = calc_freq_resp_mag(b_kernel, omega_x)\n        \n        # A_pred for the separable 2D filter is the product of 1D responses\n        A_pred = pred_amp_a * pred_amp_b\n\n        # 2. Compute the measured amplitude (A_meas)\n        # Generate the synthetic image with a single sinusoidal component\n        I = np.sin(2 * np.pi * (kx * xx / N + ky * yy / N) + phi)\n\n        # Construct the 2D separable mask C = a * b^T\n        C_2D_kernel = np.outer(a_kernel, b_kernel)\n\n        # Perform 2D circular convolution to get the output image O\n        O = convolve2d(I, C_2D_kernel, boundary='wrap', mode='same')\n\n        # Compute RMS of the output, then convert to sinusoidal amplitude\n        R = np.sqrt(np.mean(np.square(O)))\n        A_meas = np.sqrt(2) * R\n\n        # 3. Report the relative error\n        error = np.abs(A_meas - A_pred) / np.maximum(1e-12, A_pred)\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.14f}' for r in results)}]\")\n\nsolve()\n```", "id": "4565096"}, {"introduction": "在实际的放射组学应用中，由于需要为每张图像计算大量纹理特征，计算效率至关重要。本练习着重于 Laws 能量测度的计算优化，利用其“可分离”特性。你将设计并分析一种缓存一维卷积中间结果的方法，以避免重复计算 [@problem_id:4565070]，从而亲身体验算法优化如何显著提升特征提取流程的性能。", "problem": "您需要设计并分析一种计算策略，用于在放射组学的背景下，使用可分离的一维滤波器计算 Laws 纹理能量测度。出发的基础是可分离卷积的定义和一个简单的、基于操作的成本模型。一个 Laws 二维掩膜是由两个一维核的外积形成的，可以通过两个连续的一维卷积来实现：一个沿水平方向，一个沿垂直方向。假设给定的五抽头 Laws 一维核为\n$$\\mathrm{L5} = [\\,1,\\,4,\\,6,\\,4,\\,1\\,],\\quad \\mathrm{E5} = [\\,-1,\\,-2,\\,0,\\,2,\\,1\\,],\\quad \\mathrm{S5} = [\\,-1,\\,0,\\,2,\\,0,\\,-1\\,],$$\n$$\\mathrm{R5} = [\\,1,\\,-4,\\,6,\\,4,\\,1\\,],\\quad \\mathrm{W5} = [\\,-1,\\,2,\\,0,\\,-2,\\,1\\,].$$\n可分离卷积意味着，将一幅图像与由核 $a$ 和 $b$ 的外积形成的二维掩膜进行卷积，等同于首先用核 $a$ 沿水平方向进行一维卷积，然后再用核 $b$ 沿垂直方向进行一维卷积。假设图像尺寸为 $H \\times W$。\n\n采用以下经过充分检验的一维卷积遍（pass）成本模型：对于长度为 $k$ 的核，每个输出元素需要 $k$ 次乘法和 $k-1$ 次加法。请以此为基础出发点，推导您的方法并量化计算加速效果。\n\n您的任务是：\n- 提出并实现一种方法，该方法缓存中间的一维滤波图像，以避免在生成共享相同第一阶段核（即第一次水平遍）的多个掩膜时重复计算。实现两种方法：一种是基线方法，即对每个掩膜重新计算两个遍；另一种是缓存方法，即对每个独特的第一阶段核重用水平遍的结果。\n- 对于每个掩膜，将滤波后图像绝对值的全局平均值作为其 Laws 纹理能量。在边界处使用对称反射，以使输出尺寸保持为 $H \\times W$。\n- 使用上述成本模型，为每个测试用例推导并计算缓存方法相对于基线方法的理论加速因子。加速因子应表示为浮点数，严格根据一维卷积遍的次数和核长度 $k$ 定义，并且不得依赖于实际运行时间（wall-clock timing）。\n\n设计一个包含四个用例的测试套件，以检验问题的不同方面：\n1. 一个通用用例，使用一个尺寸为 $64 \\times 64$ 的随机图像（确定性种子）和共享相同第一阶段核的掩膜：$(\\mathrm{L5}, \\mathrm{E5})$, $(\\mathrm{L5}, \\mathrm{S5})$, $(\\mathrm{L5}, \\mathrm{W5})$。\n2. 一个边界尺寸用例，使用一个尺寸为 $5 \\times 5$ 的恒定强度图像，掩膜为 $(\\mathrm{E5}, \\mathrm{L5})$, $(\\mathrm{E5}, \\mathrm{E5})$, $(\\mathrm{E5}, \\mathrm{S5})$, $(\\mathrm{E5}, \\mathrm{R5})$。\n3. 一个各向异性图像用例，使用一个尺寸为 $32 \\times 48$、由水平条纹组成的图像，掩膜为 $(\\mathrm{E5}, \\mathrm{L5})$, $(\\mathrm{E5}, \\mathrm{E5})$, $(\\mathrm{E5}, \\mathrm{S5})$, $(\\mathrm{S5}, \\mathrm{E5})$。\n4. 一个小图像用例，使用一个尺寸为 $5 \\times 7$、具有简单梯度的图像，掩膜为 $(\\mathrm{L5}, \\mathrm{L5})$, $(\\mathrm{L5}, \\mathrm{E5})$, $(\\mathrm{L5}, \\mathrm{S5})$, $(\\mathrm{L5}, \\mathrm{R5})$, $(\\mathrm{L5}, \\mathrm{W5})$。\n\n对于每个测试用例，您的程序必须：\n- 使用基线方法和缓存方法计算纹理能量，并验证它们在合理容差范围内数值相等。\n- 使用成本模型和该测试用例特定的掩膜集，计算并返回缓存方法相对于基线方法的理论加速因子。\n\n您的程序应生成一行输出，其中包含四个测试用例的结果，格式为一个用方括号括起来的逗号分隔列表（例如 $[s_1,s_2,s_3,s_4]$，其中每个 $s_i$ 是浮点数形式的加速因子）。不涉及物理单位。不使用角度。不得出现百分比；所有量均以纯小数表示。最终输出行必须严格符合指定格式。", "solution": "该问题定义明确，有科学依据，并且可通过计算验证。它探讨了一种标准优化技术——在可分离卷积中缓存中间结果——并将其应用于 Laws 纹理能量测度这一成熟领域。问题提供了所有必要的定义、常数和一个清晰的成本模型，以便进行形式化的推导和实现。\n\n### 1. 可分离卷积原理\n\n一个尺寸为 $m \\times n$ 的二维（$2$D）滤波器核 $K$ 如果可以表示为两个一维（$1$D）向量的外积，即一个尺寸为 $m \\times 1$ 的列向量 $a$ 和一个尺寸为 $1 \\times n$ 的行向量 $b$，则称其为可分离的。\n$$K = a \\cdot b^T$$\n根据卷积的结合律，一幅图像 $I$ 与一个可分离核 $K$ 的卷积（表示为 $I * K$）可以分解为两个连续的 $1$D 卷积：\n$$I * K = I * (a \\cdot b^T) = (I * a) * b^T$$\n这里，$I * a$ 表示图像 $I$ 与垂直核 $a$ 的卷积（应用于每一列），而 $(...) * b^T$ 表示将得到的中间图像与水平核 $b$ 进行卷积（应用于每一行）。操作顺序可以交换。对于本问题，我们将第一遍定义为水平卷积，第二遍定义为垂直卷积。给定一个由核 $k_1$ 和 $k_2$ 的外积形成的 $2$D 掩膜，滤波后的图像 $I_{filtered}$ 计算如下：\n$$I_{intermediate} = I * k_1^T \\quad (\\text{沿每行进行 1D 卷积})$$\n$$I_{filtered} = I_{intermediate} * k_2 \\quad (\\text{沿每列进行 1D 卷积})$$\n\n### 2. 计算成本模型与加速推导\n\n问题指定了单个 $1$D 卷积遍的成本模型。对于一个尺寸为 $N_{in}$ 的输入和一个长度为 $k$ 的核，生成一个尺寸为 $N_{out}$ 的输出，其中每个输出元素需要 $k$ 次乘法和 $k-1$ 次加法，总操作数为 $N_{out} \\times (k + (k-1)) = N_{out} \\times (2k-1)$。\n\n设图像尺寸为 $H \\times W$。边界处理模式为对称反射，因此输出尺寸保持为 $H \\times W$。\n\n- **水平 1D 卷积遍的成本 ($C_{horiz}$):** 此操作应用于 $H$ 行。每行卷积产生 $W$ 个输出元素。\n$$C_{horiz} = H \\times W \\times (2k - 1)$$\n- **垂直 1D 卷积遍的成本 ($C_{vert}$):** 此操作应用于中间图像的 $W$ 列。每列卷积产生 $H$ 个输出元素。\n$$C_{vert} = W \\times H \\times (2k - 1)$$\n两种成本是相同的：$C_{horiz} = C_{vert}$。使用可分离卷积生成一张滤波图像的总成本为 $C_{2D} = C_{horiz} + C_{vert} = 2HW(2k-1)$。\n\n现在我们分析一组包含 $N$ 个掩膜 $\\{(k_{1,i}, k_{2,i})\\}_{i=1}^N$ 的成本。设 $U$ 为该集合中独特的第一阶段（水平）核的数量。所有核的长度均为 $k=5$。\n\n**基线方法成本 ($Cost_{baseline}$):**\n基线方法为 $N$ 个掩膜中的每一个都重新计算水平和垂直两个遍。\n$$Cost_{baseline} = \\sum_{i=1}^{N} (C_{horiz} + C_{vert}) = N \\times (C_{horiz} + C_{vert})$$\n$$Cost_{baseline} = N \\times [HW(2k-1) + HW(2k-1)] = 2N \\cdot HW(2k-1)$$\n\n**缓存方法成本 ($Cost_{cached}$):**\n缓存方法对每个独特的水平核只计算一次水平遍。这样的独特核有 $U$ 个。此后，它为总共 $N$ 个掩膜中的每一个执行一次垂直遍。\n- 所有独特水平遍的成本: $U \\times C_{horiz} = U \\cdot HW(2k-1)$。\n- 所有垂直遍的成本: $N \\times C_{vert} = N \\cdot HW(2k-1)$。\n$$Cost_{cached} = (U \\cdot C_{horiz}) + (N \\cdot C_{vert}) = (U+N) \\cdot HW(2k-1)$$\n\n**理论加速因子 ($S$):**\n加速比是基线成本与缓存成本的比率。\n$$S = \\frac{Cost_{baseline}}{Cost_{cached}} = \\frac{2N \\cdot HW(2k-1)}{(U+N) \\cdot HW(2k-1)}$$\n$HW(2k-1)$ 项被消去，得到一个仅依赖于掩膜数量和独特第一阶段核数量的通用加速公式：\n$$S = \\frac{2N}{U+N}$$\n\n### 3. 应用于测试用例\n\n提供的 Laws 核长度均为 $k=5$。加速因子 $S$ 与 $k$、$H$ 和 $W$ 无关。\n\n**用例 1:**\n- 掩膜: $(\\mathrm{L5}, \\mathrm{E5})$, $(\\mathrm{L5}, \\mathrm{S5})$, $(\\mathrm{L5}, \\mathrm{W5})$\n- 总掩膜数 $N=3$。\n- 独特的第一阶段核: $\\{\\mathrm{L5}\\}$。因此，$U=1$。\n- 加速 $S_1 = \\frac{2 \\times 3}{1+3} = \\frac{6}{4} = 1.5$。\n\n**用例 2:**\n- 掩膜: $(\\mathrm{E5}, \\mathrm{L5})$, $(\\mathrm{E5}, \\mathrm{E5})$, $(\\mathrm{E5}, \\mathrm{S5})$, $(\\mathrm{E5}, \\mathrm{R5})$\n- 总掩膜数 $N=4$。\n- 独特的第一阶段核: $\\{\\mathrm{E5}\\}$。因此，$U=1$。\n- 加速 $S_2 = \\frac{2 \\times 4}{1+4} = \\frac{8}{5} = 1.6$。\n\n**用例 3:**\n- 掩膜: $(\\mathrm{E5}, \\mathrm{L5})$, $(\\mathrm{E5}, \\mathrm{E5})$, $(\\mathrm{E5}, \\mathrm{S5})$, $(\\mathrm{S5}, \\mathrm{E5})$\n- 总掩膜数 $N=4$。\n- 独特的第一阶段核: $\\{\\mathrm{E5}, \\mathrm{S5}\\}$。因此，$U=2$。\n- 加速 $S_3 = \\frac{2 \\times 4}{2+4} = \\frac{8}{6} = \\frac{4}{3} \\approx 1.333...$。\n\n**用例 4:**\n- 掩膜: $(\\mathrm{L5}, \\mathrm{L5})$, $(\\mathrm{L5}, \\mathrm{E5})$, $(\\mathrm{L5}, \\mathrm{S5})$, $(\\mathrm{L5}, \\mathrm{R5})$, $(\\mathrm{L5}, \\mathrm{W5})$\n- 总掩膜数 $N=5$。\n- 独特的第一阶段核: $\\{\\mathrm{L5}\\}$。因此，$U=1$。\n- 加速 $S_4 = \\frac{2 \\times 5}{1+5} = \\frac{10}{6} = \\frac{5}{3} \\approx 1.666...$。\n\n### 4. 实现策略\n\n实现将包含两个主要函数，`baseline_method` 和 `cached_method`，它们为给定的掩膜集和输入图像计算 Laws 纹理能量。\n\n- **卷积：** $1$D 卷积使用 `scipy.ndimage.convolve1d` 执行。水平遍由 `axis=1` 指定，垂直遍由 `axis=0` 指定。边界条件是 `mode='reflect'`，对应于对称反射，这确保了滤波后的图像与输入具有相同的尺寸。\n- **基线方法：** 此方法遍历 $N$ 个掩膜的列表。对于每个掩膜，它依次执行一次水平卷积和一次垂直卷积，计算能量并存储它。\n- **缓存方法：** 此方法维护一个字典来存储独特的水平卷积的结果。它遍历 $N$ 个掩膜的列表。对于每个掩膜，它检查所需水平卷积的结果是否已在缓存中。如果不在，它会计算该结果并存入缓存。然后，它从缓存中检索（可能是新计算的）中间图像，并执行一次垂直卷积以获得最终的滤波图像。\n- **纹理能量：** 对于每个滤波图像，单个标量纹理能量值被计算为其像素绝对值的全局平均值，即 $E = \\frac{1}{HW} \\sum_{i=1}^{H} \\sum_{j=1}^{W} |I_{filtered}(i,j)|$。\n- **验证：** 通过断言缓存实现产生的能量列表与基线方法产生的列表在元素级别上使用小容差近似相等，来验证其数值正确性。\n- **最终结果：** 对于每个测试用例，计算并报告理论推导的加速比 $S = \\frac{2N}{U+N}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import convolve1d\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing Laws' texture energy and theoretical speedup.\n    \"\"\"\n    \n    # Define the 5-tap Laws' kernels\n    kernels = {\n        'L5': np.array([1, 4, 6, 4, 1], dtype=np.float64),\n        'E5': np.array([-1, -2, 0, 2, 1], dtype=np.float64),\n        'S5': np.array([-1, 0, 2, 0, -1], dtype=np.float64),\n        'R5': np.array([1, -4, 6, -4, 1], dtype=np.float64),\n        'W5': np.array([-1, 2, 0, -2, 1], dtype=np.float64),\n    }\n\n    # Normalize kernels to have a sum of zero, except for the smoothing kernel L5\n    for name, kernel in kernels.items():\n        if name != 'L5':\n            kernels[name] = kernel - np.mean(kernel)\n    kernels['L5'] = kernels['L5'] / np.sum(kernels['L5'])\n\n\n    def compute_energy(image):\n        \"\"\"Computes a single texture energy value for a filtered image.\"\"\"\n        return np.mean(np.abs(image))\n\n    def baseline_method(image, masks, kernels_map):\n        \"\"\"Computes energies by recomputing both passes for each mask.\"\"\"\n        energies = []\n        for k1_name, k2_name in masks:\n            k1 = kernels_map[k1_name]\n            k2 = kernels_map[k2_name]\n            \n            # Horizontal pass (on each row)\n            intermediate = convolve1d(image, k1, axis=1, mode='reflect')\n            \n            # Vertical pass (on each column)\n            filtered = convolve1d(intermediate, k2, axis=0, mode='reflect')\n            \n            energies.append(compute_energy(filtered))\n        return energies\n\n    def cached_method(image, masks, kernels_map):\n        \"\"\"Computes energies by caching results of the horizontal pass.\"\"\"\n        energies = []\n        intermediate_cache = {}\n        \n        for k1_name, k2_name in masks:\n            # Horizontal pass (with caching)\n            if k1_name not in intermediate_cache:\n                k1 = kernels_map[k1_name]\n                intermediate_cache[k1_name] = convolve1d(image, k1, axis=1, mode='reflect')\n            \n            intermediate = intermediate_cache[k1_name]\n            \n            # Vertical pass\n            k2 = kernels_map[k2_name]\n            filtered = convolve1d(intermediate, k2, axis=0, mode='reflect')\n            \n            energies.append(compute_energy(filtered))\n        return energies\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"image_gen\": lambda: np.random.default_rng(seed=42).random((64, 64)),\n            \"masks\": [('L5', 'E5'), ('L5', 'S5'), ('L5', 'W5')]\n        },\n        {\n            \"image_gen\": lambda: np.full((5, 5), 100.0, dtype=np.float64),\n            \"masks\": [('E5', 'L5'), ('E5', 'E5'), ('E5', 'S5'), ('E5', 'R5')]\n        },\n        {\n            \"image_gen\": lambda: (np.arange(32)[:, np.newaxis] % 2).astype(np.float64) * np.ones((32, 48)),\n            \"masks\": [('E5', 'L5'), ('E5', 'E5'), ('E5', 'S5'), ('S5', 'E5')]\n        },\n        {\n            \"image_gen\": lambda: np.arange(5 * 7, dtype=np.float64).reshape((5, 7)),\n            \"masks\": [('L5', 'L5'), ('L5', 'E5'), ('L5', 'S5'), ('L5', 'R5'), ('L5', 'W5')]\n        },\n    ]\n\n    speedup_results = []\n    for case in test_cases:\n        image = case[\"image_gen\"]()\n        masks = case[\"masks\"]\n\n        # Calculate N and U for the theoretical speedup formula\n        N = len(masks)\n        first_stage_kernels = [m[0] for m in masks]\n        U = len(set(first_stage_kernels))\n\n        # Compute the theoretical speedup factor\n        speedup = (2 * N) / (U + N)\n        speedup_results.append(speedup)\n\n        # Verification step: ensure both methods produce the same results\n        baseline_energies = baseline_method(image, masks, kernels)\n        cached_energies = cached_method(image, masks, kernels)\n        np.testing.assert_allclose(baseline_energies, cached_energies, rtol=1e-9, atol=1e-9)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, speedup_results))}]\")\n\nsolve()\n```", "id": "4565070"}]}