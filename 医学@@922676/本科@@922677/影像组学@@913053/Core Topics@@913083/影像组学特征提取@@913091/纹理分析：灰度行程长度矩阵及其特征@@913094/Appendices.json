{"hands_on_practices": [{"introduction": "要真正理解灰度游程矩阵 (GLRLM) 的特征，第一步是亲手计算它们。本练习提供了一个小型的、具体的 GLRLM，旨在帮助你熟练运用包括短游程强调 (SRE) 和长游程强调 (LRE) 在内的关键特征的计算公式。通过这个基础计算，你不仅能掌握公式，还能初步建立起特征数值与其所代表的纹理模式（例如，细密或粗糙纹理）之间的直观联系。", "problem": "一张二维医学图像已被离散化为 $N_{g}=3$ 个灰度级，并沿着单个固定方向进行分析，以形成灰度游程矩阵 (GLRLM)，这是一个计数矩阵 $p(i,j)$，其中 $i \\in \\{1,2,3\\}$ 是灰度级的索引，$j \\in \\{1,2,3\\}$ 是游程长度的索引。GLRLM 编码了在灰度级 $i$ 上出现长度恰好为 $j$ 的连续像素游程的次数。考虑以下示例 GLRLM（所有条目均为非负整数）：\n$$\np(1,1)=6,\\quad p(1,2)=1,\\quad p(1,3)=0;\\\\\np(2,1)=2,\\quad p(2,2)=0,\\quad p(2,3)=0;\\\\\np(3,1)=0,\\quad p(3,2)=0,\\quad p(3,3)=0.\n$$\n使用 GLRLM 的基本定义及其在放射组学纹理分析中的作用，计算该矩阵的短游程强调 (SRE)、长游程强调 (LRE)、低灰度级游程强调 (LGRE) 和高灰度级游程强调 (HGRE)。采用常规索引，$i=1,2,3$ 表示灰度级，$j=1,2,3$ 表示游程长度，并使用矩阵所蕴含的总游程数来归一化任何必要的量。将这四个特征值均表示为精确数（例如，有理数），不进行四舍五入，并以有序四元组 $\\big(\\mathrm{SRE},\\mathrm{LRE},\\mathrm{LGRE},\\mathrm{HGRE}\\big)$ 的形式报告最终答案。然后，简要地定性解释此 GLRLM 代表哪种纹理类型（例如，它是由短游程还是长游程主导，以及它强调的是低灰度级还是高灰度级）。无需单位。", "solution": "问题陈述经过严格评估，被认为是有效的。它在放射组学纹理分析这一成熟领域具有科学依据，问题提出得当，为获得唯一解提供了所有必要信息，并且其语言和定义是客观的。该问题是从给定的灰度游程矩阵（GLRLM）计算纹理特征的标准计算。\n\n给定的灰度游程矩阵 $p(i,j)$ 量化了在给定灰度级 $i$ 下长度为 $j$ 的游程数量。灰度级数为 $N_g=3$，考虑的最大游程长度也为 $3$。矩阵的条目为：\n$$\np(1,1)=6, \\quad p(1,2)=1, \\quad p(1,3)=0 \\\\\np(2,1)=2, \\quad p(2,2)=0, \\quad p(2,3)=0 \\\\\np(3,1)=0, \\quad p(3,2)=0, \\quad p(3,3)=0\n$$\n我们可以将此 GLRLM 表示为矩阵形式，其中行对应灰度级索引 $i$，列对应游程长度索引 $j$：\n$$\nP = \\begin{pmatrix} p(1,1) & p(1,2) & p(1,3) \\\\ p(2,1) & p(2,2) & p(2,3) \\\\ p(3,1) & p(3,2) & p(3,3) \\end{pmatrix} = \\begin{pmatrix} 6 & 1 & 0 \\\\ 2 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\n第一步是计算图像中的总游程数 $N_r$，即矩阵 $P$ 中所有元素的总和。该值用于归一化。\n$$\nN_r = \\sum_{i=1}^{3} \\sum_{j=1}^{3} p(i,j) = 6 + 1 + 0 + 2 + 0 + 0 + 0 + 0 + 0 = 9\n$$\n现在，我们使用它们的标准定义来计算所要求的四个纹理特征。\n\n1.  **短游程强调 (SRE)**：该特征强调短游程，每个游程的权重与其长度的平方成反比。\n    $$\n    \\mathrm{SRE} = \\frac{1}{N_r} \\sum_{i=1}^{3} \\sum_{j=1}^{3} \\frac{p(i,j)}{j^2}\n    $$\n    代入给定值：\n    $$\n    \\mathrm{SRE} = \\frac{1}{9} \\left( \\frac{p(1,1)}{1^2} + \\frac{p(1,2)}{2^2} + \\frac{p(2,1)}{1^2} \\right) = \\frac{1}{9} \\left( \\frac{6}{1} + \\frac{1}{4} + \\frac{2}{1} \\right)\n    $$\n    $$\n    \\mathrm{SRE} = \\frac{1}{9} \\left( 8 + \\frac{1}{4} \\right) = \\frac{1}{9} \\left( \\frac{32+1}{4} \\right) = \\frac{1}{9} \\left( \\frac{33}{4} \\right) = \\frac{33}{36} = \\frac{11}{12}\n    $$\n\n2.  **长游程强调 (LRE)**：该特征强调长游程，每个游程的权重与其长度的平方成正比。\n    $$\n    \\mathrm{LRE} = \\frac{1}{N_r} \\sum_{i=1}^{3} \\sum_{j=1}^{3} p(i,j) \\cdot j^2\n    $$\n    代入给定值：\n    $$\n    \\mathrm{LRE} = \\frac{1}{9} \\left( p(1,1) \\cdot 1^2 + p(1,2) \\cdot 2^2 + p(2,1) \\cdot 1^2 \\right) = \\frac{1}{9} \\left( 6 \\cdot 1 + 1 \\cdot 4 + 2 \\cdot 1 \\right)\n    $$\n    $$\n    \\mathrm{LRE} = \\frac{1}{9} (6 + 4 + 2) = \\frac{12}{9} = \\frac{4}{3}\n    $$\n\n3.  **低灰度级游程强调 (LGRE)**：该特征强调低灰度值的游程，权重与灰度级的平方成反比。\n    $$\n    \\mathrm{LGRE} = \\frac{1}{N_r} \\sum_{i=1}^{3} \\sum_{j=1}^{3} \\frac{p(i,j)}{i^2}\n    $$\n    代入给定值：\n    $$\n    \\mathrm{LGRE} = \\frac{1}{9} \\left( \\frac{p(1,1)}{1^2} + \\frac{p(1,2)}{1^2} + \\frac{p(2,1)}{2^2} \\right) = \\frac{1}{9} \\left( \\frac{6}{1} + \\frac{1}{1} + \\frac{2}{4} \\right)\n    $$\n    $$\n    \\mathrm{LGRE} = \\frac{1}{9} \\left( 7 + \\frac{1}{2} \\right) = \\frac{1}{9} \\left( \\frac{14+1}{2} \\right) = \\frac{15}{18} = \\frac{5}{6}\n    $$\n\n4.  **高灰度级游程强调 (HGRE)**：该特征强调高灰度值的游程，权重与灰度级的平方成正比。\n    $$\n    \\mathrm{HGRE} = \\frac{1}{N_r} \\sum_{i=1}^{3} \\sum_{j=1}^{3} p(i,j) \\cdot i^2\n    $$\n    代入给定值：\n    $$\n    \\mathrm{HGRE} = \\frac{1}{9} \\left( (p(1,1)+p(1,2)) \\cdot 1^2 + p(2,1) \\cdot 2^2 \\right) = \\frac{1}{9} \\left( (6+1) \\cdot 1 + 2 \\cdot 4 \\right)\n    $$\n    $$\n    \\mathrm{HGRE} = \\frac{1}{9} (7 + 8) = \\frac{15}{9} = \\frac{5}{3}\n    $$\n\n四个特征值为 $(\\mathrm{SRE}, \\mathrm{LRE}, \\mathrm{LGRE}, \\mathrm{HGRE}) = (\\frac{11}{12}, \\frac{4}{3}, \\frac{5}{6}, \\frac{5}{3})$。\n\n定性地看，较高的 SRE 值 $(\\frac{11}{12} \\approx 0.92)$ 接近其最大可能值 $1$，表明短游程占绝对优势。这与 GLRLM 一致，其中 $9$ 个游程中有 $8$ 个的长度为 $j=1$。这表明纹理是细粒度或带有噪声的。类似地，较高的 LGRE 值 $(\\frac{5}{6} \\approx 0.83)$ 相对于 HGRE 值 $(\\frac{5}{3} \\approx 1.67)$ 表明游程集中在较低的灰度级。一个纯灰度级 1 的纹理将得到 $\\mathrm{LGRE}=1$ 和 $\\mathrm{HGRE}=1$，而一个纯灰度级 2 的纹理将得到 $\\mathrm{LGRE}=1/4$ 和 $\\mathrm{HGRE}=4$。我们的计算值证实了低灰度级的显著存在。总之，该 GLRLM 代表了一种由主要出现在低灰度值的短游程主导的细粒度纹理（即一种“暗”的、精细的纹理）。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{11}{12} & \\frac{4}{3} & \\frac{5}{6} & \\frac{5}{3} \\end{pmatrix}}\n$$", "id": "4564433"}, {"introduction": "在掌握了基本计算之后，下一个挑战是探索纹理特征在概念层面上的行为。本练习将场景简化为一个仅包含单一灰度级的图像区域，这使我们能够推导出特征的通用表达式，而不是计算具体的数值。通过分析这种同质纹理，你将更深刻地理解各个特征的内在含义，并明晰它们是如何对游程长度的分布做出响应的，这对于解释真实世界图像中的复杂纹理至关重要。", "problem": "考虑一个用于放射组学中的图像区域，称为感兴趣区域（Region of Interest, ROI）。纹理分析使用灰度游程矩阵（Gray-Level Run-Length Matrix, GLRLM）进行，该矩阵计算沿特定方向上具有相同离散化灰度级的连续共线像素。假设ROI已被离散化为多个灰度级，并且只包含一个有像素占据的灰度级区间。对于一个固定的方向，设游程长度的分布由整数计数 $n_{j}$ 描述，其中游程长度 $j \\in \\{1,2,\\dots,J_{\\max}\\}$ 且 $n_{j} \\ge 0$。设总游程数为 $N_{r} = \\sum_{j=1}^{J_{\\max}} n_{j}$，ROI中的总像素数（在该方向的线性化表示中）为 $N_{p} = \\sum_{j=1}^{J_{\\max}} j\\,n_{j}$。GLRLM $R(i,j)$ 只有一个非零的灰度级行，即 $i=1$。\n\n仅从“游程”和作为计数矩阵的GLRLM的基本定义出发，并将特征解释为关于适当归一化的GLRLM的期望值，推导以下特征关于 $\\{n_{j}\\}$、$N_{r}$ 和 $N_{p}$ 的解析表达式：短游程强调（Short Run Emphasis, SRE）、长游程强调（Long Run Emphasis, LRE）、灰度级不均匀性（Gray-Level Non-Uniformity, GLNU）、游程长度不均匀性（Run Length Non-Uniformity, RLNU）、游程百分比（Run Percentage, RP）、低灰度级游程强调（Low Gray-Level Run Emphasis, LGRE）、高灰度级游程强调（High Gray-Level Run Emphasis, HGRE）、短游程低灰度级强调（Short Run Low Gray-Level Emphasis, SRLGE）、短游程高灰度级强调（Short Run High Gray-Level Emphasis, SRHGE）、长游程低灰度级强调（Long Run Low Gray-Level Emphasis, LRLGE）、长游程高灰度级强调（Long Run High Gray-Level Emphasis, LRHGE）、游程熵（Run Entropy, RE）、游程长度均值（Run Length Mean, RLM）、游程长度方差（Run Length Variance, RLV）、灰度级均值（Gray-Level Mean, GLM）和灰度级方差（Gray-Level Variance, GLV）。\n\n在您的推导中，请指明如果没有明确规定GLRLM的归一化和灰度级离散化约定，哪些特征会是未定义的或模糊不清的，并提出一致的约定来解决这些模糊性。然后，在您提出的约定下，提供这些特征的闭式表达式的有序向量\n$$\n\\big(\\mathrm{SRE},\\,\\mathrm{LRE},\\,\\mathrm{GLNU},\\,\\mathrm{RLNU},\\,\\mathrm{RP},\\,\\mathrm{LGRE},\\,\\mathrm{HGRE},\\,\\mathrm{SRLGE},\\,\\mathrm{SRHGE},\\,\\mathrm{LRLGE},\\,\\mathrm{LRHGE},\\,\\mathrm{RE},\\,\\mathrm{RLM},\\,\\mathrm{RLV},\\,\\mathrm{GLM},\\,\\mathrm{GLV}\\big).\n$$\n无需进行数值计算；请以符号形式表示您的最终答案。无需四舍五入，并且这些特征根据其构造是无量纲的。", "solution": "问题陈述经过严格验证，确认有效。这是一个在放射组学和纹理分析领域内定义明确、具有科学依据的问题。它提出了一个简化但连贯的场景（单一灰度级），并要求从第一性原理出发推导标准的灰度游程矩阵（GLRLM）特征。该问题正确地预见到了与归一化和灰度值约定相关的模糊性，并明确要求解答者解决这些问题。这种结构使问题超越了简单的公式应用。\n\n推导过程如下。首先，我们在给定条件下形式化GLRLM的结构。其次，我们为矩阵归一化和灰度值建立一致的约定，以解决固有的模糊性。第三，我们解析地推导十六个指定特征中的每一个。\n\n设GLRLM表示为 $R(i, j)$，其中 $i$ 是灰度级索引，$j$ 是游程长度索引。问题陈述中指出，只有一个被占据的灰度级区间，其在GLRLM中对应的行被指定为 $i=1$。在这个灰度级上，每个长度 $j \\in \\{1, 2, \\dots, J_{\\max}\\}$ 的游程计数由 $n_j$ 给出。因此，GLRLM仅在第一行非零：\n$$\nR(i, j) = n_j \\delta_{i1}\n$$\n其中 $\\delta_{i1}$ 是克罗内克δ函数，当 $i=1$ 时为1，否则为0。\n\n总游程数 $N_r$ 是矩阵中所有项的总和：\n$$\nN_r = \\sum_{i=1}^{N_g} \\sum_{j=1}^{J_{\\max}} R(i, j) = \\sum_{j=1}^{J_{\\max}} R(1, j) = \\sum_{j=1}^{J_{\\max}} n_j\n$$\n这与提供的定义相符。总像素数 $N_p$ 也与之相符：\n$$\nN_p = \\sum_{j=1}^{J_{\\max}} j \\cdot (\\text{number of runs of length } j) = \\sum_{j=1}^{J_{\\max}} j \\left(\\sum_{i=1}^{N_g} R(i,j)\\right) = \\sum_{j=1}^{J_{\\max}} j \\cdot n_j\n$$\n\n问题要求将特征解释为相对于一个适当归一化的GLRLM的期望值。这引出了第一个关键约定。\n**约定1：归一化。**\n为了从计数矩阵 $R(i, j)$ 形成概率分布 $p(i, j)$，我们必须用所有元素的总和，即总游程数 $N_r$ 来进行归一化。\n$$\np(i, j) = \\frac{R(i, j)}{N_r}\n$$\n根据这个约定，$\\sum_{i,j} p(i, j) = 1$，并且 $p(i,j)$ 代表一个随机选择的游程具有灰度级 $i$ 和长度 $j$ 的联合概率。对于本问题，$p(i, j) = \\frac{n_j}{N_r} \\delta_{i1}$。没有这个约定，大多数被定义为该分布的矩或属性的特征都将是模糊不清的。\n\n第二个模糊性涉及那些依赖于实际灰度值而不仅仅是其索引的特征。这些特征是LGRE、HGRE、四个灰度级强调的SR/LR特征、GLM和GLV。\n**约定2：灰度值。**\n问题陈述中指出，被占据的区间对应于行 $i=1$。我们采用一个常见的约定，即灰度级索引直接对应其值。因此，这一个被占据的灰度级的值为 $g=1$。这解决了所有依赖于灰度级的特征的模糊性。否则，这些特征将需要用一个通用的灰度值 $g_0$ 来表示。\n\n有了这些约定，我们来推导每个特征。\n\n1.  **短游程强调 (SRE):** 衡量短游程的普遍性。\n    SRE $= \\sum_{i,j} \\frac{p(i,j)}{j^2} = \\sum_{j=1}^{J_{\\max}} \\frac{p(1,j)}{j^2} = \\sum_{j=1}^{J_{\\max}} \\frac{n_j/N_r}{j^2} = \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} \\frac{n_j}{j^2}$。\n\n2.  **长游程强调 (LRE):** 衡量长游程的普遍性。\n    LRE $= \\sum_{i,j} p(i,j) j^2 = \\sum_{j=1}^{J_{\\max}} p(1,j) j^2 = \\sum_{j=1}^{J_{\\max}} \\frac{n_j}{N_r} j^2 = \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} n_j j^2$。\n\n3.  **灰度级不均匀性 (GLNU):** 衡量游程在灰度级上的不均匀性。总和 $\\sum_j R(i,j)$ 给出灰度级 $i$ 的总游程数。\n    GLNU $= \\frac{1}{N_r} \\sum_{i=1}^{N_g} \\left( \\sum_{j=1}^{J_{\\max}} R(i,j) \\right)^2$。\n    对于 $i=1$，$\\sum_j R(1,j) = \\sum_j n_j = N_r$。对于 $i>1$，总和为 $0$。\n    GLNU $= \\frac{1}{N_r} \\left( (N_r)^2 + \\sum_{i=2}^{N_g} (0)^2 \\right) = \\frac{N_r^2}{N_r} = N_r$。\n\n4.  **游程长度不均匀性 (RLNU):** 衡量游程在游程长度上的不均匀性。总和 $\\sum_i R(i,j)$ 给出长度 $j$ 的总游程数。\n    RLNU $= \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} \\left( \\sum_{i=1}^{N_g} R(i,j) \\right)^2$。\n    对于任何 $j$，$\\sum_i R(i,j) = R(1,j) = n_j$。\n    RLNU $= \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} (n_j)^2$。\n\n5.  **游程百分比 (RP):** 游程数与像素数之比。\n    RP $= \\frac{N_r}{N_p}$。这由定义给出。\n\n6.  **低灰度级游程强调 (LGRE):** 强调低灰度值的游程。使用约定2（对于 $i=1$，$g=1$）。\n    LGRE $= \\sum_{i,j} \\frac{p(i,j)}{i^2} = \\sum_{j=1}^{J_{\\max}} \\frac{p(1,j)}{1^2} = \\sum_{j=1}^{J_{\\max}} p(1,j) = \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} n_j = \\frac{N_r}{N_r} = 1$。\n\n7.  **高灰度级游程强调 (HGRE):** 强调高灰度值的游程。\n    HGRE $= \\sum_{i,j} p(i,j) i^2 = \\sum_{j=1}^{J_{\\max}} p(1,j) 1^2 = \\sum_{j=1}^{J_{\\max}} p(1,j) = 1$。\n\n8.  **短游程低灰度级强调 (SRLGE):**\n    SRLGE $= \\sum_{i,j} \\frac{p(i,j)}{i^2 j^2} = \\sum_{j=1}^{J_{\\max}} \\frac{p(1,j)}{1^2 j^2} = \\sum_{j=1}^{J_{\\max}} \\frac{p(1,j)}{j^2} = \\text{SRE} = \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} \\frac{n_j}{j^2}$。\n\n9.  **短游程高灰度级强调 (SRHGE):**\n    SRHGE $= \\sum_{i,j} \\frac{p(i,j) i^2}{j^2} = \\sum_{j=1}^{J_{\\max}} \\frac{p(1,j) 1^2}{j^2} = \\sum_{j=1}^{J_{\\max}} \\frac{p(1,j)}{j^2} = \\text{SRE} = \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} \\frac{n_j}{j^2}$。\n\n10. **长游程低灰度级强调 (LRLGE):**\n    LRLGE $= \\sum_{i,j} \\frac{p(i,j) j^2}{i^2} = \\sum_{j=1}^{J_{\\max}} \\frac{p(1,j) j^2}{1^2} = \\sum_{j=1}^{J_{\\max}} p(1,j) j^2 = \\text{LRE} = \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} n_j j^2$。\n\n11. **长游程高灰度级强调 (LRHGE):**\n    LRHGE $= \\sum_{i,j} p(i,j) i^2 j^2 = \\sum_{j=1}^{J_{\\max}} p(1,j) 1^2 j^2 = \\sum_{j=1}^{J_{\\max}} p(1,j) j^2 = \\text{LRE} = \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} n_j j^2$。\n\n12. **游程熵 (RE):** 衡量游程分布的随机性。使用自然对数和约定 $0\\ln(0)=0$。\n    RE $= - \\sum_{i,j} p(i,j) \\ln(p(i,j)) = - \\sum_{j \\text{ s.t. } n_j>0} p(1,j) \\ln(p(1,j)) = - \\sum_{j, n_j>0} \\frac{n_j}{N_r} \\ln\\left(\\frac{n_j}{N_r}\\right)$。\n    RE $= - \\frac{1}{N_r} \\sum_{j, n_j>0} n_j (\\ln(n_j) - \\ln(N_r)) = - \\frac{1}{N_r} \\left( \\sum_{j, n_j>0} n_j \\ln(n_j) - \\ln(N_r)\\sum_{j, n_j>0} n_j \\right)$。\n    RE $= - \\frac{1}{N_r} \\left( \\sum_{j=1}^{J_{\\max}} n_j \\ln(n_j) - N_r \\ln(N_r) \\right) = \\ln(N_r) - \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} n_j \\ln(n_j)$。\n\n13. **游程长度均值 (RLM):** 平均游程长度。这是边际游程长度概率分布 $p_j(j) = \\sum_i p(i,j) = n_j/N_r$ 的一阶矩。\n    RLM $= \\sum_{j=1}^{J_{\\max}} j \\cdot p_j(j) = \\sum_{j=1}^{J_{\\max}} j \\frac{n_j}{N_r} = \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} j n_j = \\frac{N_p}{N_r}$。\n\n14. **游程长度方差 (RLV):** 游程长度的方差。\n    RLV $= \\sum_{j=1}^{J_{\\max}} (j - \\text{RLM})^2 p_j(j) = E[j^2] - (E[j])^2$。\n    $E[j] = \\text{RLM}$。\n    $E[j^2] = \\sum_{j=1}^{J_{\\max}} j^2 p_j(j) = \\sum_{j=1}^{J_{\\max}} j^2 \\frac{n_j}{N_r} = \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} j^2 n_j$，这与LRE相同。\n    RLV $= \\left(\\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} j^2 n_j \\right) - \\left(\\frac{N_p}{N_r}\\right)^2$。\n\n15. **灰度级均值 (GLM):** 平均灰度级。这是边际灰度级概率分布 $p_i(i) = \\sum_j p(i,j)$ 的一阶矩。\n    对于 $i=1$，$p_i(1) = \\sum_j p(1,j) = 1$。对于 $i>1$，$p_i(i)=0$。\n    GLM $= \\sum_{i=1}^{N_g} i \\cdot p_i(i) = 1 \\cdot p_i(1) + \\sum_{i>1} i \\cdot 0 = 1$。\n\n16. **灰度级方差 (GLV):** 灰度级的方差。\n    GLV $= \\sum_{i=1}^{N_g} (i - \\text{GLM})^2 p_i(i) = (1 - 1)^2 p_i(1) + \\sum_{i>1} (i-1)^2 \\cdot 0 = 0$。这是预料之中的，因为灰度级没有变化。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} \\frac{n_j}{j^2} \\\\\n\\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} n_j j^2 \\\\\nN_r \\\\\n\\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} n_j^2 \\\\\n\\frac{N_r}{N_p} \\\\\n1 \\\\\n1 \\\\\n\\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} \\frac{n_j}{j^2} \\\\\n\\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} \\frac{n_j}{j^2} \\\\\n\\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} n_j j^2 \\\\\n\\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} n_j j^2 \\\\\n\\ln(N_r) - \\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} n_j \\ln(n_j) \\\\\n\\frac{N_p}{N_r} \\\\\n\\left(\\frac{1}{N_r} \\sum_{j=1}^{J_{\\max}} j^2 n_j \\right) - \\left(\\frac{N_p}{N_r}\\right)^2 \\\\\n1 \\\\\n0\n\\end{pmatrix}\n}\n$$", "id": "4564388"}, {"introduction": "理论知识的最终检验在于实践应用。这个压轴练习要求你从零开始，设计并实现一个从图像数据直接构建灰度游程矩阵 (GLRLM) 的高效算法。你将通过处理二维和三维图像数据，学习如何系统性地识别和计算沿特定方向的像素“游程”，并将此过程扩展到多方向的聚合分析。完成此练习不仅能让你彻底掌握 GLRLM 的生成过程，还能培养你在解决实际影像分析问题时所需的算法思维和计算效率分析能力。", "problem": "在放射组学纹理分析的背景下，您的任务是构建灰度游程矩阵（GLRLM）。考虑一个量化的图像体、一个感兴趣区域（ROI）以及一组有限的方向向量。灰度游程矩阵 $P(i,j)$ 是对方向集 $\\mathcal{D}$ 进行聚合的结果，它统计了沿每个方向 $\\vec{d}\\in\\mathcal{D}$ 遍历ROI时，灰度级为 $i$ 且游程长度为 $j$ 的游程数量。一个游程是指沿方向 $\\vec{d}$ 移动时，具有恒定灰度级的最大连续体素序列。令ROI中的体素数量为 $N_v$，灰度级数量为 $N_g$，观察到的最大游程长度为 $N_r$。\n\n仅从序列、游程、数组索引和离散结构求和的基本定义出发，设计一个算法，通过对每个 $\\vec{d}\\in\\mathcal{D}$ 沿线流式处理来构建 $P(i,j)$，使得总工作量与访问的体素数量成线性关系。该算法必须：\n- 为每个方向 $\\vec{d}$ 识别线的起始体素，这些体素是ROI中其沿 $-\\vec{d}$ 方向的前驱体素位于体积边界之外或ROI之外的体素。\n- 沿正向 $\\vec{d}$ 遍历每条线，检测灰度级变化，并为每个最大恒定段精确地输出一个游程。\n- 将计数累加到 $P(i,j)$ 中，该矩阵聚合了所有 $\\vec{d}\\in\\mathcal{D}$ 的结果。\n\n根据第一性原理，提供关于 $N_v$、$N_g$、$N_r$ 和 $\\lvert\\mathcal{D}\\rvert$ 的清晰的时间和内存复杂度分析。\n\n然后，实现一个程序，将您的算法应用于以下测试套件。在所有情况下，ROI均为整个图像体，灰度级被标记为从1开始的连续整数。\n\n测试用例 $\\mathbf{A}$ （$2$维）：\n- 体积 $V\\in\\mathbb{Z}^{3\\times 5}$ 为\n$$\nV=\\begin{bmatrix}\n1 & 1 & 2 & 2 & 2\\\\\n1 & 3 & 3 & 3 & 2\\\\\n1 & 1 & 1 & 2 & 2\n\\end{bmatrix}.\n$$\n- 灰度级数 $N_g = 3$。\n- 方向集 $\\mathcal{D}=\\{(1,0)\\}$，其中 $(1,0)$ 表示沿列方向移动一步。\n\n测试用例 $\\mathbf{B}$ （$2$维）：\n- 体积 $W\\in\\mathbb{Z}^{4\\times 4}$ 为\n$$\nW=\\begin{bmatrix}\n1 & 2 & 1 & 2\\\\\n1 & 2 & 1 & 2\\\\\n1 & 2 & 1 & 2\\\\\n1 & 2 & 1 & 2\n\\end{bmatrix}.\n$$\n- 灰度级数 $N_g = 2$。\n- 方向集 $\\mathcal{D}=\\{(1,0),(0,1)\\}$。\n\n测试用例 $\\mathbf{C}$ （$3$维）：\n- 体积 $X\\in\\mathbb{Z}^{2\\times 2\\times 3}$ 由沿第一个轴的两个切片给出（列出了 $z=0$ 和 $z=1$ 的情况）：\n$$\nX[z=0]=\\begin{bmatrix}\n1 & 1 & 1\\\\\n2 & 2 & 2\n\\end{bmatrix},\\quad\nX[z=1]=\\begin{bmatrix}\n1 & 2 & 2\\\\\n1 & 1 & 2\n\\end{bmatrix}.\n$$\n- 灰度级数 $N_g = 2$。\n- 方向集 $\\mathcal{D}=\\{(1,0,0),(0,1,0),(0,0,1)\\}$，分别对应沿数组的最后一个、中间和第一个轴的步进。\n\n从对 $\\mathcal{D}$ 中所有方向进行聚合构建的GLRLM $P(i,j)$ 中，为每个测试用例计算以下量：\n- 总游程数 $R=\\sum_{i=1}^{N_g}\\sum_{j=1}^{N_r} P(i,j)$。\n- 短游程强调 (SRE)。\n- 长游程强调 (LRE)。\n- 灰度级不均匀性 (GLNU)。\n- 游程长度不均匀性 (RLNU)。\n- 游程百分比 (RP)，定义为总游程数与ROI中体素数量的比值。\n\n您的程序必须实现上述线性时间流式算法来构建 $P(i,j)$，然后仅使用它们的定义直接从 $P(i,j)$ 计算所列出的量，最后将三个测试用例的结果以列表的列表形式单行输出：\n- 对于每个测试用例，输出列表 $[R,\\mathrm{SRE},\\mathrm{LRE},\\mathrm{GLNU},\\mathrm{RLNU},\\mathrm{RP}]$。\n- 全局输出必须是包含三个用例列表的单行，例如 $[[\\cdot],[\\cdot],[\\cdot]]$。\n- 将所有实数值四舍五入到恰好 $6$ 位小数。将 $R$ 作为整数打印。输出行中不得有任何空格。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个用例的结果本身也是用方括号括起来的逗号分隔列表，并且所有浮点值都四舍五入到恰好 $6$ 位小数，例如\n$$\n[[R_A,\\mathrm{SRE}_A,\\mathrm{LRE}_A,\\mathrm{GLNU}_A,\\mathrm{RLNU}_A,\\mathrm{RP}_A],[R_B,\\mathrm{SRE}_B,\\mathrm{LRE}_B,\\mathrm{GLNU}_B,\\mathrm{RLNU}_B,\\mathrm{RP}_B],[R_C,\\mathrm{SRE}_C,\\mathrm{LRE}_C,\\mathrm{GLNU}_C,\\mathrm{RLNU}_C,\\mathrm{RP}_C]].\n$$", "solution": "用户的要求是开发并实现一个算法，用于构建灰度游程矩阵（GLRLM）并从中计算几个放射组学特征。该问题定义明确，科学上合理，并提供了用于验证的具体测试用例。\n\n### 基于原理的算法设计\n\n核心任务是计算GLRLM，$P(i,j)$，这是一个矩阵，其中每个元素统计灰度级为 $i$、长度为 $j$ 的游程数量。这项任务必须针对给定的图像体、感兴趣区域（ROI）和一组方向 $\\mathcal{D}$ 来完成。问题指定了一种算法方法，该方法必须在访问的体素数量上是线性的。这表明需要一种高效的流式或遍历方法，以避免冗余计算。\n\n指导该算法的基本原理是：\n1.  **按方向分解**：总GLRLM是为每个单独方向 $\\vec{d} \\in \\mathcal{D}$ 计算的GLRLM的总和。\n    $$\n    P(i,j) = \\sum_{\\vec{d} \\in \\mathcal{D}} P_{\\vec{d}}(i,j)\n    $$\n2.  **逐行遍历**：对于一个固定的方向 $\\vec{d}$，图像体可以被划分为一组平行线。为确保每个体素在每个方向上只被访问一次，我们可以为这些线确定一个唯一的“起始体素”集合，并从头到尾遍历每条线。\n3.  **起始体素识别**：根据问题描述，方向 $\\vec{d}$ 的起始体素是ROI内的一个体素，其前驱体素（位于 $-\\vec{d}$ 位置）在图像边界之外或ROI之外。对于给定的测试用例，其中ROI是整个体积且方向是轴向的（例如，沿x轴），这个条件得以简化。例如，对于沿正x轴的方向，起始体素是平面 $x=0$ 上的所有体素。\n4.  **通过流式处理检测游程**：遍历一条线时，“游程”是具有相同灰度级的连续体素序列。通过沿线进行流式处理，我们可以检测到灰度级的变化。每当遇到灰度级变化或到达线的末端时，就记录下已完成的游程（由其灰度级和长度定义）。\n\n基于这些原理，算法如下：\n\n1.  **初始化**：\n    - 设图像体积为 $V$，形状为 $(S_0, S_1, ..., S_{N-1})$。体素数量为 $N_v = \\prod S_k$。\n    - 初始化一个整数值的GLRLM，$P$，大小为 $(N_g+1) \\times (L_{\\max}+1)$，所有元素为零。其中 $N_g$ 是灰度级数，$L_{\\max} = \\max(S_0, ..., S_{N-1})$ 是可能的最大游程长度。我们对灰度级和游程长度使用基于1的索引。\n\n2.  **方向聚合循环**：\n    - 对于每个方向向量 $\\vec{d} \\in \\mathcal{D}$：\n        a. **识别遍历轴**：对于给定的轴向方向，确定将要进行遍历的轴 $k$。对于向量 $\\vec{d}$，这是其唯一非零分量的索引。\n        b. **识别起始体素**：起始体素集合形成一个超平面，其中轴 $k$ 上的坐标为 $0$。遍历除 $k$ 轴以外所有轴的索引的所有先验组合。\n        c. **线路遍历**：对于每个起始体素 $\\vec{p}_{\\text{start}}$：\n            i.   设置当前位置 $\\vec{p} = \\vec{p}_{\\text{start}}$。\n            ii.  当 $\\vec{p}$ 在体积边界内时：\n                 - 一个新的游程从 $\\vec{p}$ 开始。读取其灰度级 $i = V[\\vec{p}]$。\n                 - 初始化其长度 $j=0$。\n                 - 只要位置仍在界内且灰度级保持不变，就沿线推进 $\\vec{p}$，并递增 $j$。\n                 - 一旦游程终止（由于边界或灰度级变化），则在矩阵中增加相应的计数器：$P(i, j) \\leftarrow P(i, j) + 1$。\n                 - 外部 `while` 循环从新位置 $\\vec{p}$ 继续，开始检测同一条线上的下一个游程。\n\n3.  **特征计算**：\n    - 处理完所有方向后，$P$ 持有最终的聚合计数。\n    - 令 $R = \\sum_{i,j} P(i,j)$ 为总游程数。如果 $R=0$，则所有特征均为 $0$。\n    - 这些特征根据其标准定义计算：\n      - 短游程强调 (SRE): $\\text{SRE} = \\frac{1}{R} \\sum_{i=1}^{N_g} \\sum_{j=1}^{N_r} \\frac{P(i,j)}{j^2}$\n      - 长游程强调 (LRE): $\\text{LRE} = \\frac{1}{R} \\sum_{i=1}^{N_g} \\sum_{j=1}^{N_r} P(i,j) \\cdot j^2$\n      - 灰度级不均匀性 (GLNU): $\\text{GLNU} = \\frac{1}{R} \\sum_{i=1}^{N_g} \\left( \\sum_{j=1}^{N_r} P(i,j) \\right)^2$\n      - 游程长度不均匀性 (RLNU): $\\text{RLNU} = \\frac{1}{R} \\sum_{j=1}^{N_r} \\left( \\sum_{i=1}^{N_g} P(i,j) \\right)^2$\n      - 游程百分比 (RP): $\\text{RP} = R / N_v$\n\n### 复杂度分析\n\n- **时间复杂度**：该算法遍历 $|\\mathcal{D}|$ 个方向。对于每个方向，它将体积划分为从一个超平面开始的若干条线。体积中的每个体素都恰好是这样一条线的一部分，并且在该方向的遍历过程中恰好被访问一次。因此，一个方向的工作量与体素数量成正比，即 $O(N_v)$。构建GLRLM的总时间复杂度为 $O(|\\mathcal{D}| \\cdot N_v)$。随后从矩阵 $P$ 计算特征需要 $O(N_g \\cdot N_r)$ 的时间，其中 $N_r$ 是观察到的最大游程长度。由于在典型情况下 $N_g \\cdot N_r \\ll |\\mathcal{D}| \\cdot N_v$，因此整体时间复杂度由GLRLM的构建主导，满足了对访问体素数量的线性依赖要求。\n\n- **内存复杂度**：该算法需要存储输入体积，为 $O(N_v)$，以及GLRLM，为 $O(N_g \\cdot N_r)$。$N_r$ 受限于体积的最大维度 $L_{\\max}$。因此，内存复杂度为 $O(N_v + N_g \\cdot L_{\\max})$。每个方向不需要与体积大小相当的辅助数据结构，这使得内存使用效率很高。\n\n此设计提供了一个正确且高效的解决方案，满足了问题陈述的所有约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef compute_glrlm_and_features(volume, n_g, directions):\n    \"\"\"\n    Computes the GLRLM and derived features for a single test case.\n\n    This function implements the linear-time streaming algorithm described\n    in the problem statement. It iterates through each specified direction,\n    identifies starting voxels for lines parallel to that direction,\n    and traverses each line to count runs of constant gray level.\n    The run counts are aggregated into the Gray-Level Run-Length Matrix (GLRLM).\n    Finally, it computes the six specified texture features from the GLRLM.\n\n    Args:\n        volume (np.ndarray): The input image volume.\n        n_g (int): The number of gray levels.\n        directions (list of tuples): The set of direction vectors.\n\n    Returns:\n        list: A list containing the calculated features:\n              [Total Runs, SRE, LRE, GLNU, RLNU, RP].\n    \"\"\"\n    shape = volume.shape\n    n_dim = volume.ndim\n    max_run_length = 0 if not shape else max(shape)\n    \n    # Initialize GLRLM with 1-based indexing for gray levels and run lengths.\n    P = np.zeros((n_g + 1, max_run_length + 1), dtype=np.int64)\n    \n    for d in directions:\n        # For the given axial directions, find the single axis of traversal.\n        try:\n            axis = next(i for i, val in enumerate(d) if val != 0)\n        except StopIteration:\n            continue # Skip zero vector if present\n\n        # Define the starting hyperplane by creating iteration ranges for all other axes.\n        start_coord_ranges = []\n        for i in range(n_dim):\n            if i == axis:\n                start_coord_ranges.append([0])\n            else:\n                start_coord_ranges.append(range(shape[i]))\n        \n        # Iterate over all starting voxels on the hyperplane.\n        for start_coord_tuple in itertools.product(*start_coord_ranges):\n            current_coord = list(start_coord_tuple)\n            \n            # Traverse the line starting from this voxel.\n            while current_coord[axis]  shape[axis]:\n                run_gray_level = volume[tuple(current_coord)]\n                run_length = 0\n                \n                # Stream along the line to find the length of the current run.\n                while current_coord[axis]  shape[axis] and \\\n                      volume[tuple(current_coord)] == run_gray_level:\n                    run_length += 1\n                    current_coord[axis] += 1\n                \n                # Record the completed run.\n                P[run_gray_level, run_length] += 1\n\n    # Find the maximum observed run length to trim the matrix.\n    n_r_observed = 0\n    if np.any(P):\n        n_r_observed = int(np.max(np.where(P.sum(axis=0) > 0)[0]))\n\n    if n_r_observed == 0:\n        return [0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        \n    # For calculation, use a 0-indexed matrix for convenience (p_matrix).\n    p_matrix = P[1 : n_g + 1, 1 : n_r_observed + 1]\n\n    R = p_matrix.sum()\n    if R == 0:\n        return [0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        \n    N_v = volume.size\n    \n    j_vector = np.arange(1, n_r_observed + 1, dtype=np.float64)\n    \n    # Short Run Emphasis (SRE)\n    sre_val = np.sum(p_matrix / (j_vector**2)) / R\n    \n    # Long Run Emphasis (LRE)\n    lre_val = np.sum(p_matrix * (j_vector**2)) / R\n    \n    # Gray-Level Non-Uniformity (GLNU)\n    runs_per_gray = p_matrix.sum(axis=1)\n    gln_val = np.sum(runs_per_gray**2) / R\n    \n    # Run Length Non-Uniformity (RLNU)\n    runs_per_length = p_matrix.sum(axis=0)\n    rln_val = np.sum(runs_per_length**2) / R\n    \n    # Run Percentage (RP)\n    rp_val = R / N_v\n    \n    return [int(R), sre_val, lre_val, gln_val, rln_val, rp_val]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final answer.\n    \"\"\"\n    test_cases = [\n        {\n            \"volume\": np.array([\n                [1, 1, 2, 2, 2],\n                [1, 3, 3, 3, 2],\n                [1, 1, 1, 2, 2]\n            ]),\n            \"n_g\": 3,\n            \"directions\": [(0, 1)] # (d_row, d_col), changed (1,0) to (0,1) for numpy row,col logic\n        },\n        {\n            \"volume\": np.array([\n                [1, 2, 1, 2],\n                [1, 2, 1, 2],\n                [1, 2, 1, 2],\n                [1, 2, 1, 2]\n            ]),\n            \"n_g\": 2,\n            \"directions\": [(1, 0), (0, 1)]\n        },\n        {\n            \"volume\": np.array([\n                [[1, 1, 1], [2, 2, 2]],\n                [[1, 2, 2], [1, 1, 2]]\n            ]),\n            \"n_g\": 2,\n            \"directions\": [(0, 0, 1), (0, 1, 0), (1, 0, 0)] # (d_z, d_y, d_x), changed to numpy z,y,x logic\n        }\n    ]\n    # Correcting directions for numpy (row, col) or (z, y, x) indexing\n    # The problem description's \"(1,0) means沿列... (0,1,0) 沿中间轴\" is ambiguous.\n    # Assuming standard matrix indexing (row, col) or (z, y, x):\n    # (1,0) = move 1 step in row dir (axis 0). So it's along columns.\n    # (0,1) = move 1 step in col dir (axis 1). So it's along rows.\n    # For Test A, \"沿列方向移动一步\" (move along columns) corresponds to (1,0) in numpy.\n    # For Test B, we need both.\n    # For Test C, \"最后一个、中间和第一个轴\" for (1,0,0),(0,1,0),(0,0,1) is ambiguous.\n    # Numpy X is (z,y,x), shape=(2,2,3).\n    # d=(1,0,0) -> axis 0 (z), along depth.\n    # d=(0,1,0) -> axis 1 (y), along rows.\n    # d=(0,0,1) -> axis 2 (x), along columns.\n    # The problem says \"(1,0,0) ... 最后一个 ... 轴\", which is axis 2 (x), but d=(1,0,0) is axis 0.\n    # I'll trust the problem's textual description of axes over the vector notation.\n    # \"最后一个\" = axis 2 (x) -> d=(0,0,1)\n    # \"中间\" = axis 1 (y) -> d=(0,1,0)\n    # \"第一个\" = axis 0 (z) -> d=(1,0,0)\n    # So the vectors in problem C need to be re-interpreted: (1,0,0) means axis 2, (0,1,0) means axis 1, (0,0,1) means axis 0.\n    # This is a mess. I'll stick to a standard interpretation: (1,0) is axis 0, (0,1) is axis 1, etc.\n    # Test A: \"沿列方向移动\" (along columns) -> numpy axis 0 -> d=(1,0)\n    test_cases[0]['directions'] = [(1,0)]\n    # Test C: \"最后一个(x), 中间(y), 第一个(z)轴\" -> d=(0,0,1), d=(0,1,0), d=(1,0,0)\n    test_cases[2]['directions'] = [(0,0,1), (0,1,0), (1,0,0)]\n\n    all_results = []\n    for case in test_cases:\n        result = compute_glrlm_and_features(case[\"volume\"], case[\"n_g\"], case[\"directions\"])\n        all_results.append(result)\n\n    # Format the output string exactly as specified.\n    result_strings = []\n    for res in all_results:\n        r_str = str(res[0])\n        float_strs = [f\"{x:.6f}\" for x in res[1:]]\n        result_strings.append(f\"[{r_str},{','.join(float_strs)}]\")\n            \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "4564440"}]}