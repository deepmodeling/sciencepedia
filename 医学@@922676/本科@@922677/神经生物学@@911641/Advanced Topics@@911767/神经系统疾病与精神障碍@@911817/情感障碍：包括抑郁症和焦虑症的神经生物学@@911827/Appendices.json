{"hands_on_practices": [{"introduction": "情感障碍的神经生物学基础错综复杂，其中一个核心环节是环境（如长期压力）与基因表达之间的相互作用。本练习将探讨表观遗传学修饰（如DNA甲基化）如何调节与压力反应至关重要的基因。通过一个简化的模型，我们将量化糖皮质激素受体基因（$NR3C1$）启动子区域的甲基化程度如何直接影响其转录输出，从而揭示压力易感性的一个关键分子机制[@problem_id:4996539]。这个实践旨在帮助你理解分子层面的变化如何导致系统功能的失调，例如下丘脑-垂体-肾上腺（HPA）轴的负反馈受损。", "problem": "神经生物学中的一个基本观察是，基因表达受到表观遗传标记的调控，例如在胞嘧啶-磷酸-鸟嘌呤（CpG）二核苷酸处的胞嘧啶甲基化。在包括抑郁症和焦虑症在内的情感障碍中，糖皮质激素受体基因（核受体亚家族3C组成员1，NR3C1）启动子处的甲基化与下丘脑-垂体-肾上腺（HPA）轴功能改变有关。考虑一个粗粒度模型，其中 NR3C1 启动子由许多结合位点组成。定义甲基化分数 $m$ 为启动子位点中被甲基化从而使转录因子无法结合的部分。假设以下基本前提：\n- 启动子位点要么是可及的（未甲基化的），要么是不可及的（甲基化的），并且甲基化会阻碍转录激活因子的有效结合。\n- 转录的起始速率与可及的启动子位点的比例成正比。\n- 当 $m=0$（所有位点均可及）时，达到最大转录产出 $T_{\\max}$。\n\n在稳态条件和转录机制饱和可用的情况下，基于这些假设，推导出预期转录产出 $T$ 作为 $m$ 和 $T_{\\max}$ 的函数。然后，对于一个在 NR3C1 启动子处甲基化分数为 $m=0.37$、观察到的最大转录能力为 $T_{\\max}=2.4 \\times 10^{4}$ 信使核糖核酸（mRNA）分子/细胞/天的细胞，计算预期的转录产出 $T$ 并陈述其值。将您的数值答案四舍五入到四位有效数字，并以 mRNA 分子/细胞/天为单位表示。最后，简要解释您的结果在情感障碍背景下对 HPA 轴负反馈的影响，重点关注变化的方向而非定量预测。您最终报告的值必须是一个实数（在方框答案中无量纲，单位在文本中指定）。", "solution": "该问题要求基于给定的生物物理模型推导转录产出方程，进行后续的数值计算，并对结果的生物学意义进行定性解释。该问题在科学上是合理的、自洽的、且表述清晰，因此可以按所述方式解决。\n\n问题的核心在于将描述性的生物学假设转化为数学框架。设 $m$ 为启动子位点的甲基化分数，定义为被甲基化从而使转录因子无法结合的位点所占的比例。$m$ 的取值范围为 $0 \\le m \\le 1$。\n\n第一个假设指出启动子位点是二元的：要么是可及的（未甲基化的），要么是不可及的（甲基化的）。位点的总比例必须为1。如果我们用 $A$ 表示可及位点的比例，那么可及和不可及位点比例之和必须为 $1$：\n$$ A + m = 1 $$\n由此，我们可以将可及位点的比例表示为甲基化分数的函数：\n$$ A = 1 - m $$\n第二个假设指出，转录产出（我们用 $T$ 表示）与可及启动子位点的比例 $A$ 成正比。这可以写成一个比例关系：\n$$ T \\propto A $$\n引入一个比例常数 $k$，我们可以将这个关系写成一个方程：\n$$ T = k \\cdot A $$\n将上面得到的 $A$ 的表达式代入，我们得到：\n$$ T = k(1 - m) $$\n常数 $k$ 代表在下游机制饱和的条件下，如果所有位点都可及并与转录激活因子结合时可能发生的最大转录速率。第三个假设提供了确定此常数的方法。它指出，当甲基化分数 $m$ 为零时，达到最大转录产出 $T_{\\max}$。将此边界条件应用于我们的方程：\n$$ T_{\\max} = k(1 - 0) $$\n$$ T_{\\max} = k $$\n这个结果表明，比例常数 $k$ 与最大转录产出 $T_{\\max}$ 相同。现在我们可以将 $T_{\\max}$ 代替 $k$ 放入我们的通用方程中，得到转录产出 $T$ 作为 $m$ 和 $T_{\\max}$ 的函数的最终推导表达式：\n$$ T = T_{\\max}(1 - m) $$\n该表达式将初始假设形式化，显示出随着甲基化分数的增加，转录产出呈线性下降。\n\n接下来，问题要求在给定具体值 $m = 0.37$ 和 $T_{\\max} = 2.4 \\times 10^{4}$ mRNA 分子/细胞/天的情况下，对 $T$ 进行数值计算。我们将这些值代入推导出的方程中：\n$$ T = (2.4 \\times 10^{4}) \\times (1 - 0.37) $$\n$$ T = (2.4 \\times 10^{4}) \\times (0.63) $$\n$$ T = 1.512 \\times 10^{4} $$\n问题要求答案保留四位有效数字。计算出的值 $1.512 \\times 10^{4}$ 已经有四位有效数字。因此，预期的转录产出为 $1.512 \\times 10^{4}$ mRNA 分子/细胞/天。\n\n最后，我们必须讨论其对下丘脑-垂体-肾上腺（HPA）轴负反馈的影响。被建模的基因 NR3C1 编码糖皮质激素受体（GR）。糖皮质激素受体对于介导终止应激反应的负反馈信号至关重要。在这个反馈回路中，从肾上腺释放的皮质醇（一种糖皮质激素）与位于海马体和下丘脑的 GR 结合。这一结合事件会触发一个抑制 HPA 轴进一步活动的过程。\n\n我们的计算表明，NR3C1 启动子处 $m = 0.37$ 的甲基化分数将该基因的转录产出降低到其最大潜力的 $63\\%$。较低的转录速率导致糖皮质激素受体的合成减少。关键脑区中较低的 GR 密度会损害负反馈机制的效力，因为系统对循环中的皮质醇信号变得不那么敏感。因此，HPA 轴无法被有效关闭，这可能导致慢性过度活跃和皮质醇水平升高的状态。这种以*HPA轴负反馈受损*为特征的功能失调，是在重度抑郁症和其他与应激相关的情感障碍患者中被充分记录的生物学发现。因此，NR3C1 启动子甲基化水平的增加是导致这一病理生理学关键方面的直接机制联系。", "answer": "$$\\boxed{1.512 \\times 10^{4}}$$", "id": "4996539"}, {"introduction": "在理解了基因表达层面的调控之后，我们将转向神经元结构的可塑性，这是大脑适应与学习的基础，也与情感障碍的病理生理学密切相关。抑郁症通常与大脑关键区域（如前额叶皮层）的突触连接丢失有关。此练习 [@problem_id:4996486] 建立了一个动力学模型，用于模拟树突棘密度的动态平衡，并探究像氯胺酮这样的快速抗抑郁药如何通过促进突触生成来逆转压力引起的突触丢失。通过这个练习，你可以具体地看到药物作用如何转化为神经结构的实际变化。", "problem": "在与重度抑郁症相关的皮质边缘回路中，第五层锥体神经元上的树突棘密度是通过树突棘形成（由雷帕霉素靶蛋白(mTOR)等蛋白质合成通路驱动）与树突棘消除（修剪）之间的平衡来动态维持的，后者可近似为一级损失动力学。考虑一个固定长度树突节段上稳态树突棘密度的简化动力学模型，其中树突棘密度 $N(t)$（单位：棘/微米）的时间演化由常微分方程 $\\,\\frac{dN}{dt} = k_{m} - k_{d}\\,N\\,$ 描述，其中形成速率 $k_{m}$（单位：棘/微米/天）为常数，一级损失速率常数 $k_{d}$（单位：天$^{-1}$）。在稳态时，净通量为零。\n\n一种慢性应激小鼠模型表现出mTOR激活减少和修剪增加。在此基线状态下，假设 $k_{m}^{\\text{base}} = 0.080$ 棘/微米/天，$k_{d}^{\\text{base}} = 0.10$ 天$^{-1}$。已知单次亚麻醉剂量的氯胺酮（ketamine）暴露可增强mTOR依赖性蛋白质合成并减少过度修剪。将其建模为形成速率增加 $50$％，损失速率减少 $20$％，因此治疗后 $k_{m}^{\\text{post}} = (1+0.50)\\,k_{m}^{\\text{base}}$ 且 $k_{d}^{\\text{post}} = (1-0.20)\\,k_{d}^{\\text{base}}$。\n\n仅使用上述动力学平衡和基于此模型的稳态推理，计算该树突节段稳态树突棘密度的绝对变化量 $\\Delta N = N_{\\text{post}} - N_{\\text{base}}$。将您的答案四舍五入至三位有效数字。以棘/微米 (spines/$\\mu$m) 为单位表示最终的树突棘密度变化。", "solution": "其基本原理是质量作用式的动力学平衡，即在固定长度的树突上树突棘的形成与损失之间的平衡。根据假设，相对于 $N$，树突棘形成是零级反应，速率为 $k_{m}$（单位：棘 $\\mu\\text{m}^{-1}\\,\\text{天}^{-1}$），而树突棘损失是相对于 $N$ 的一级反应，速率常数为 $k_{d}$（单位：$\\text{天}^{-1}$）。控制方程为\n$$\n\\frac{dN}{dt} = k_{m} - k_{d}\\,N.\n$$\n根据定义，在稳态时 $\\frac{dN}{dt} = 0$，因此稳态树突棘密度 $N_{\\text{ss}}$ 满足\n$$\n0 = k_{m} - k_{d}\\,N_{\\text{ss}} \\quad\\Rightarrow\\quad N_{\\text{ss}} = \\frac{k_{m}}{k_{d}}.\n$$\n我们首先计算基线稳态密度。当 $k_{m}^{\\text{base}} = 0.080$ 棘 $\\mu\\text{m}^{-1}\\,\\text{天}^{-1}$ 且 $k_{d}^{\\text{base}} = 0.10$ $\\text{天}^{-1}$ 时，\n$$\nN_{\\text{base}} = \\frac{k_{m}^{\\text{base}}}{k_{d}^{\\text{base}}} = \\frac{0.080}{0.10} = 0.80 \\text{ 棘 } \\mu\\text{m}^{-1}.\n$$\n使用氯胺酮后，形成速率增加 $50$％，损失速率减少 $20$％。因此，\n$$\nk_{m}^{\\text{post}} = (1+0.50)\\,k_{m}^{\\text{base}} = 1.50 \\times 0.080 = 0.120 \\text{ 棘 } \\mu\\text{m}^{-1}\\,\\text{天}^{-1},\n$$\n$$\nk_{d}^{\\text{post}} = (1-0.20)\\,k_{d}^{\\text{base}} = 0.80 \\times 0.10 = 0.080 \\text{ 天}^{-1}.\n$$\n治疗后的稳态树突棘密度则为\n$$\nN_{\\text{post}} = \\frac{k_{m}^{\\text{post}}}{k_{d}^{\\text{post}}} = \\frac{0.120}{0.080} = 1.50 \\text{ 棘 } \\mu\\text{m}^{-1}.\n$$\n因此，稳态树突棘密度的绝对变化量为\n$$\n\\Delta N = N_{\\text{post}} - N_{\\text{base}} = 1.50 - 0.80 = 0.70 \\text{ 棘 } \\mu\\text{m}^{-1}.\n$$\n四舍五入至三位有效数字，$\\Delta N = 0.700$ 棘 $\\mu\\text{m}^{-1}$。\n\n为了完整起见，在进行数值代入之前，同样的结果可以象征性地表示出来。设 $\\alpha$ 表示形成速率的分数增加量，$\\beta$ 表示损失速率的分数减少量。则\n$$\nN_{\\text{base}} = \\frac{k_{m}^{\\text{base}}}{k_{d}^{\\text{base}}}, \\quad\nN_{\\text{post}} = \\frac{(1+\\alpha)\\,k_{m}^{\\text{base}}}{(1-\\beta)\\,k_{d}^{\\text{base}}}\n= \\frac{1+\\alpha}{1-\\beta}\\,N_{\\text{base}},\n$$\n所以\n$$\n\\Delta N = N_{\\text{base}}\\!\\left(\\frac{1+\\alpha}{1-\\beta} - 1\\right).\n$$\n当 $\\alpha = 0.50$ 且 $\\beta = 0.20$ 时，可得\n$$\n\\Delta N = 0.80\\!\\left(\\frac{1.50}{0.80} - 1\\right) = 0.80\\,(1.875 - 1) = 0.80 \\times 0.875 = 0.700,\n$$\n如上所述，单位为棘/微米。", "answer": "$$\\boxed{0.700}$$", "id": "4996486"}, {"introduction": "情感障碍不仅改变我们的生物学状态，也深刻影响我们的认知和决策过程。为了在更高层次上理解这些变化，我们可以借助计算模型来形式化描述行为背后的神经计算原理。本练习 [@problem_id:4996329] 引入了一个基于强化学习的框架，将焦虑建模为对不确定性或风险的过度规避。通过分析和编程，你将探索风险敏感性参数如何影响在不同选项间的抉择，从而将一个复杂的临床症状（焦虑）与一个可量化的计算变量联系起来，体验计算精神病学这一前沿领域的研究方法。", "problem": "考虑一个基于神经生物学的最小化情感决策计算模型，其中处于焦虑状态的生物体会权衡期望奖励与结果的可变性。使用以下基础：随机奖励的期望值和方差，以及强化学习（RL）中使用的 softmax 动作选择映射。具体来说，假设一个双臂老虎机问题，其中每个臂在每次试验中提供的奖励是独立同分布的，且具有臂特定的高斯奖励分布。设臂的索引为 $i \\in \\{s,v\\}$，其中 $s$ 代表低方差的“安全”臂，$v$ 代表高方差的“波动”臂。臂 $i$ 的奖励是一个随机变量 $r_i \\sim \\mathcal{N}(\\mu_i, \\sigma_i^2)$，其中 $\\mu_i$ 是期望奖励，$\\sigma_i^2$ 是捕捉环境波动性的奖励方差。\n\n用风险敏感效用对一个焦虑的智能体进行建模，其效用定义为 $U_i = \\mathbb{E}[r_i] - \\lambda \\mathrm{Var}(r_i) = \\mu_i - \\lambda \\sigma_i^2$，其中 $\\lambda \\geq 0$ 量化了对可变性的厌恶程度，这与焦虑状态下不确定性敏感性增强相一致。该智能体使用逆温度 $\\beta \\geq 0$ 的 softmax 策略选择动作，因此选择臂 $i$ 的概率由下式给出：\n$$\nP(i) = \\frac{\\exp\\left(\\beta U_i\\right)}{\\exp\\left(\\beta U_s\\right) + \\exp\\left(\\beta U_v\\right)}.\n$$\n在操作上将探索倾向定义为选择波动臂 $v$ 的概率，记为 $P(v)$。\n\n任务：\n1. 从 $\\mathbb{E}[r_i]$、$\\mathrm{Var}(r_i)$ 和 softmax 映射的定义出发，推导出用 $\\mu_s$、$\\mu_v$、$\\sigma_s^2$、$\\sigma_v^2$、$\\lambda$ 和 $\\beta$ 表示的 $P(v)$ 表达式。然后，解析地证明在 $\\sigma_v^2 > \\sigma_s^2$ 的波动环境中，增加 $\\lambda$ 会单调地减少 $P(v)$。\n2. 实现一个程序，为以下每个测试用例计算 $P(v)$。所有奖励都是无量纲的；以小数形式报告概率。\n\n测试套件参数集 $(\\mu_s, \\sigma_s^2, \\mu_v, \\sigma_v^2, \\beta, \\lambda)：$\n- 用例 $1$ (一般“顺利路径”)：$(1.0, 0.1, 1.0, 1.0, 2.0, 0.5)$。\n- 用例 $2$ (边界条件 $\\lambda = 0$)：$(1.0, 0.1, 1.0, 1.0, 2.0, 0.0)$。\n- 用例 $3$ (高 $\\lambda$)：$(1.0, 0.1, 1.0, 1.0, 2.0, 5.0)$。\n- 用例 $4$ (方差相等)：$(0.8, 0.5, 1.0, 0.5, 2.0, 0.5)$。\n- 用例 $5$ (极端波动性)：$(1.0, 0.1, 1.0, 10.0, 2.0, 0.5)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$），其中每个 $result_k$ 是对应案例计算出的 $P(v)$ 的小数值。确保科学上现实的行为：对于 $\\sigma_v^2 > \\sigma_s^2$ 和 $\\mu_v = \\mu_s$ 的情况，输出必须满足 $P(v)$ 随着 $\\lambda$ 的增加而减小。", "solution": "问题陈述已经过评估，并被确定为有效。它在科学上基于已建立的计算建模原则（强化学习，均值-方差效用），定义和目标清晰，问题阐述良好，没有矛盾或含糊之处。\n\n按照要求，解决方案分两部分进行。首先，提供解析推导和证明。其次，详细说明计算实现的逻辑。\n\n### 第 1 部分：解析推导与证明\n\n#### $P(v)$ 表达式的推导\n我们的任务是根据给定参数推导出选择波动臂的概率 $P(v)$ 的表达式，这些参数包括：平均奖励 $\\mu_s$ 和 $\\mu_v$，奖励方差 $\\sigma_s^2$ 和 $\\sigma_v^2$，风险厌恶参数 $\\lambda$，以及逆温度 $\\beta$。\n\n起点是双选择场景下 softmax 策略的定义：\n$$\nP(v) = \\frac{\\exp\\left(\\beta U_v\\right)}{\\exp\\left(\\beta U_s\\right) + \\exp\\left(\\beta U_v\\right)}\n$$\n其中 $U_s$ 和 $U_v$ 分别是安全臂和波动臂的效用。\n\n臂 $i$ 的效用定义为 $U_i = \\mu_i - \\lambda \\sigma_i^2$。将此定义代入安全臂 ($s$) 和波动臂 ($v$)，我们得到：\n$$\nU_s = \\mu_s - \\lambda \\sigma_s^2\n$$\n$$\nU_v = \\mu_v - \\lambda \\sigma_v^2\n$$\n为了简化 $P(v)$ 的表达式，我们可以将分子和分母同时除以 $\\exp(\\beta U_v)$：\n$$\nP(v) = \\frac{\\frac{\\exp(\\beta U_v)}{\\exp(\\beta U_v)}}{\\frac{\\exp(\\beta U_s)}{\\exp(\\beta U_v)} + \\frac{\\exp(\\beta U_v)}{\\exp(\\beta U_v)}} = \\frac{1}{\\exp(\\beta U_s - \\beta U_v) + 1} = \\frac{1}{1 + \\exp(\\beta(U_s - U_v))}\n$$\n这种形式等价于 logistic sigmoid 函数，通常表示为 $\\sigma(x) = (1+e^{-x})^{-1}$，在此处 $x = \\beta(U_v - U_s)$。\n\n接下来，我们将 $U_s$ 和 $U_v$ 的表达式代入差值项 $(U_s - U_v)$：\n$$\nU_s - U_v = (\\mu_s - \\lambda \\sigma_s^2) - (\\mu_v - \\lambda \\sigma_v^2)\n$$\n重新排列各项，按 $\\mu$ 和 $\\lambda$ 分组：\n$$\nU_s - U_v = (\\mu_s - \\mu_v) - \\lambda\\sigma_s^2 + \\lambda\\sigma_v^2 = (\\mu_s - \\mu_v) + \\lambda(\\sigma_v^2 - \\sigma_s^2)\n$$\n将这个差值代回 $P(v)$ 的表达式，我们得到最终的推导公式：\n$$\nP(v) = \\frac{1}{1 + \\exp\\left(\\beta\\left[(\\mu_s - \\mu_v) + \\lambda(\\sigma_v^2 - \\sigma_s^2)\\right]\\right)}\n$$\n\n#### 单调性的解析证明\n我们现在必须证明，在 $\\sigma_v^2 > \\sigma_s^2$ 的波动环境中，增加风险厌恶参数 $\\lambda$ 会单调地减少 $P(v)$。这需要证明 $P(v)$ 对 $\\lambda$ 的偏导数为负，即 $\\frac{\\partial P(v)}{\\partial \\lambda} < 0$。\n\n设指数函数的参数记为 $X(\\lambda)$：\n$$\nX(\\lambda) = \\beta\\left[(\\mu_s - \\mu_v) + \\lambda(\\sigma_v^2 - \\sigma_s^2)\\right]\n$$\n因此，$P(v) = (1 + \\exp(X(\\lambda)))^{-1}$。我们使用链式法则计算导数：\n$$\n\\frac{\\partial P(v)}{\\partial \\lambda} = -\\left(1 + \\exp(X(\\lambda))\\right)^{-2} \\cdot \\frac{\\partial}{\\partial \\lambda}\\left(\\exp(X(\\lambda))\\right)\n$$\n$$\n\\frac{\\partial P(v)}{\\partial \\lambda} = -\\left(1 + \\exp(X(\\lambda))\\right)^{-2} \\cdot \\exp(X(\\lambda)) \\cdot \\frac{\\partial X(\\lambda)}{\\partial \\lambda}\n$$\n必须考虑前两项，即 $-\\left(1 + \\exp(X(\\lambda))\\right)^{-2}$ 和 $\\exp(X(\\lambda))$。由于指数函数对于实数参数总是正的，并且分母中的平方项也总是正的，所以整个前置因子 $-\\left(1 + \\exp(X(\\lambda))\\right)^{-2} \\cdot \\exp(X(\\lambda))$ 是严格为负的。\n\n现在我们分析最后一项 $\\frac{\\partial X(\\lambda)}{\\partial \\lambda}$ 的符号：\n$$\n\\frac{\\partial X(\\lambda)}{\\partial \\lambda} = \\frac{\\partial}{\\partial \\lambda}\\left( \\beta(\\mu_s - \\mu_v) + \\beta\\lambda(\\sigma_v^2 - \\sigma_s^2) \\right)\n$$\n项 $\\beta(\\mu_s - \\mu_v)$ 相对于 $\\lambda$ 是常数，因此其导数为 $0$。\n$$\n\\frac{\\partial X(\\lambda)}{\\partial \\lambda} = \\beta(\\sigma_v^2 - \\sigma_s^2)\n$$\n问题指明了我们必须证明单调性的条件：\n1.  $\\sigma_v^2 > \\sigma_s^2$，这意味着 $(\\sigma_v^2 - \\sigma_s^2) > 0$。\n2.  $\\beta \\geq 0$。对于一个非平凡的 softmax 策略（即非纯随机选择），我们必须有 $\\beta > 0$。\n\n在这些条件下，乘积 $\\beta(\\sigma_v^2 - \\sigma_s^2)$ 严格为正。\n\n因此，完整的导数是一个负项和一个正项的乘积：\n$$\n\\frac{\\partial P(v)}{\\partial \\lambda} = \\underbrace{\\left( - \\frac{\\exp(X(\\lambda))}{(1 + \\exp(X(\\lambda)))^2} \\right)}_{\\text{负}} \\cdot \\underbrace{\\left( \\beta(\\sigma_v^2 - \\sigma_s^2) \\right)}_{\\text{正}}\n$$\n由于一个负数和一个正数的乘积是负数，我们得到 $\\frac{\\partial P(v)}{\\partial \\lambda} < 0$。这证实了当 $\\sigma_v^2 > \\sigma_s^2$ 且 $\\beta > 0$ 时，$P(v)$ 是 $\\lambda$ 的单调递减函数。证毕 (Q.E.D.)。\n\n### 第 2 部分：计算实现\n\n程序将为五个指定的测试用例计算 $P(v)$。实现的核心是将推导出的公式直接转换为代码。\n\n一个函数，例如 `calculate_p_v`，将接受六个参数 $(\\mu_s, \\sigma_s^2, \\mu_v, \\sigma_v^2, \\beta, \\lambda)$。在该函数内部，它将计算指数的值：\n$$\n\\text{exponent} = \\beta \\cdot [(\\mu_s - \\mu_v) + \\lambda \\cdot (\\sigma_v^2 - \\sigma_s^2)]\n$$\n然后，它将使用以下公式计算 $P(v)$：\n$$\nP(v) = \\frac{1}{1 + \\exp(\\text{exponent})}\n$$\n将使用 `numpy.exp()` 函数来保证数值稳定性和正确性。\n\n程序的主体部分将定义一个元组列表，其中每个元组包含一个测试用例的参数集。然后，它将遍历此列表，为每个用例调用 `calculate_p_v` 函数，并将返回的概率存储在一个结果列表中。最后，它将此结果列表格式化为所需的字符串格式 `[result_1,result_2,...]` 并将其打印到标准输出。\n\n用例 1、2 和 3 的程序化结果应展示解析证明的原理：在 $\\mu_s = \\mu_v$ 和 $\\sigma_v^2 > \\sigma_s^2$ 的条件下，随着 $\\lambda$ 从 $0.0$ 增加到 $0.5$ 再到 $5.0$，计算出的 $P(v)$ 值应严格减小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the probability of choosing the volatile arm in a two-armed bandit\n    problem for a series of test cases based on a risk-sensitive utility model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (mu_s, sigma_s_sq, mu_v, sigma_v_sq, beta, lambda_val)\n    test_cases = [\n        # Case 1 (general \"happy path\"): (1.0, 0.1, 1.0, 1.0, 2.0, 0.5)\n        (1.0, 0.1, 1.0, 1.0, 2.0, 0.5),\n        # Case 2 (boundary condition lambda = 0): (1.0, 0.1, 1.0, 1.0, 2.0, 0.0)\n        (1.0, 0.1, 1.0, 1.0, 2.0, 0.0),\n        # Case 3 (high lambda): (1.0, 0.1, 1.0, 1.0, 2.0, 5.0)\n        (1.0, 0.1, 1.0, 1.0, 2.0, 5.0),\n        # Case 4 (equal variances): (0.8, 0.5, 1.0, 0.5, 2.0, 0.5)\n        (0.8, 0.5, 1.0, 0.5, 2.0, 0.5),\n        # Case 5 (extreme volatility): (1.0, 0.1, 1.0, 10.0, 2.0, 0.5)\n        (1.0, 0.1, 1.0, 10.0, 2.0, 0.5),\n    ]\n\n    results = []\n    \n    def calculate_p_v(mu_s, sigma_s_sq, mu_v, sigma_v_sq, beta, lambda_val):\n        \"\"\"\n        Calculates the probability of choosing the volatile arm, P(v).\n\n        Args:\n            mu_s (float): Mean reward of the safe arm.\n            sigma_s_sq (float): Variance of the safe arm.\n            mu_v (float): Mean reward of the volatile arm.\n            sigma_v_sq (float): Variance of the volatile arm.\n            beta (float): Inverse temperature for softmax.\n            lambda_val (float): Risk-aversion parameter.\n\n        Returns:\n            float: The probability P(v).\n        \"\"\"\n        # Derived formula: P(v) = 1 / (1 + exp(beta * [(mu_s - mu_v) + lambda * (sigma_v^2 - sigma_s^2)]))\n        \n        # Calculate the difference in utilities, U_s - U_v\n        utility_diff = (mu_s - mu_v) + lambda_val * (sigma_v_sq - sigma_s_sq)\n        \n        # Calculate the argument of the exponential function\n        exponent = beta * utility_diff\n        \n        # Calculate P(v) using the logistic sigmoid function form\n        p_v = 1.0 / (1.0 + np.exp(exponent))\n        \n        return p_v\n\n\n    for case in test_cases:\n        mu_s, sigma_s_sq, mu_v, sigma_v_sq, beta, lambda_val = case\n        result = calculate_p_v(mu_s, sigma_s_sq, mu_v, sigma_v_sq, beta, lambda_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) is used to convert each float result to its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4996329"}]}