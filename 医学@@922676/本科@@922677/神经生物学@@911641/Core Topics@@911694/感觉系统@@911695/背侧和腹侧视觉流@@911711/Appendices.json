{"hands_on_practices": [{"introduction": "视觉信息处理的速度对于及时作出行为反应至关重要。这个练习将背侧和腹侧视觉通路的不同解剖学特性（如轴突传导速度和突触数量）模型化。通过计算并比较运动敏感的MT区（背侧通路）和形状敏感的V4区（腹侧通路）的预期信号起始时间，您将深入理解这些通路的物理结构如何影响其功能[@problem_id:5013693]。", "problem": "一次短暂的高对比度视觉闪光会诱发前馈活动，该活动从视网膜沿着部分分离的通路传播到更高级的视觉皮层区域。考虑两条这样的通路：通往中颞区（MT）的背侧通路和通往V4区的腹侧通路。将每条通路的总起始延迟建模为轴突传导时间与一系列串行中继的突触延迟之和。使用以下基本依据：(i) 轴突传导延迟等于路径长度除以传导速度，(ii) 串行中继的突触延迟相加，以及 (iii) 对于独立阶段，总延迟是各组成部分延迟的总和。\n\n假设以下生物物理上合理的属性。\n- MT的有效轴突路径长度为 $L_{\\mathrm{MT}} = 0.10\\,\\mathrm{m}$，V4的有效轴突路径长度为 $L_{\\mathrm{V4}} = 0.080\\,\\mathrm{m}$。\n- MT的有效传导速度是一个随机变量 $V_{\\mathrm{MT}}$，其分布近似为正态分布，均值为 $\\mu_{\\mathrm{MT}} = 2.5\\,\\mathrm{m/s}$，标准差为 $\\sigma_{\\mathrm{MT}} = 0.50\\,\\mathrm{m/s}$。对于V4， $V_{\\mathrm{V4}}$ 近似为正态分布，均值为 $\\mu_{\\mathrm{V4}} = 1.8\\,\\mathrm{m/s}$，标准差为 $\\sigma_{\\mathrm{V4}} = 0.36\\,\\mathrm{m/s}$。变异系数足够小，因此在均值附近的二阶泰勒展开可以为速度的光滑函数的期望提供精确的近似。\n- 每个中继的突触延迟是一个独立的服从正态分布的随机变量，均值为 $\\mu_{s} = 1.2\\,\\mathrm{ms}$，标准差为 $\\sigma_{s} = 0.25\\,\\mathrm{ms}$。MT的串行突触数量为 $n_{\\mathrm{MT}} = 4$，V4的串行突触数量为 $n_{\\mathrm{V4}} = 5$。\n- 所有随机分量相互独立。\n\n任务：\n1. 从上述定义和假设出发，推导每条通路总起始延迟的期望值和方差的近似表达式，用 $L$, $\\mu$, $\\sigma$, $n$, $\\mu_{s}$ 和 $\\sigma_{s}$ 表示。说明每条通路得到的近似延迟分布。\n2. 使用提供的数值参数，计算MT和V4的预测起始时间（期望延迟），然后计算差值 $\\Delta t = \\mathbb{E}[T_{\\mathrm{V4}}] - \\mathbb{E}[T_{\\mathrm{MT}}]$。将最终数值答案四舍五入到三位有效数字。以毫秒（ms）为单位表示最终结果。最终答案必须是一个实数值。", "solution": "该问题被评估为有效，因为它在神经生物学上具有科学依据，目标明确且包含所有必要参数，属于适定问题，并使用了标准的数学建模和近似技术。\n\n给定视觉通路的总起始延迟 $T$ 被建模为轴突传导延迟 $T_{\\mathrm{axon}}$ 和总突触延迟 $T_{\\mathrm{synapse}}$ 的和。\n$$\nT = T_{\\mathrm{axon}} + T_{\\mathrm{synapse}}\n$$\n轴突传导延迟是有效路径长度 $L$ 与有效传导速度 $V$ 的比值。\n$$\nT_{\\mathrm{axon}} = \\frac{L}{V}\n$$\n总突触延迟是 $n$ 个串行中继处延迟的总和。每个突触延迟 $D_i$ 是一个独立的随机变量。\n$$\nT_{\\mathrm{synapse}} = \\sum_{i=1}^{n} D_i\n$$\n问题陈述所有随机分量都是相互独立的。这意味着速度 $V$ 和所有突触延迟 $D_i$ 都是相互独立的。因此， $T_{\\mathrm{axon}}$ 和 $T_{\\mathrm{synapse}}$ 是独立的随机变量。\n\n### 任务1：延迟的期望、方差和分布的推导\n\n首先，我们分析总突触延迟 $T_{\\mathrm{synapse}}$。突触延迟 $D_i$ 是独立同分布 (i.i.d.) 的正态随机变量，均值为 $\\mu_s$，方差为 $\\sigma_s^2$，即 $D_i \\sim \\mathcal{N}(\\mu_s, \\sigma_s^2)$。\n\n随机变量之和的期望值等于它们各自期望值的和：\n$$\n\\mathbb{E}[T_{\\mathrm{synapse}}] = \\mathbb{E}\\left[\\sum_{i=1}^{n} D_i\\right] = \\sum_{i=1}^{n} \\mathbb{E}[D_i] = n \\mu_s\n$$\n由于突触延迟是独立的，它们之和的方差等于它们各自方差的和：\n$$\n\\mathrm{Var}(T_{\\mathrm{synapse}}) = \\mathrm{Var}\\left(\\sum_{i=1}^{n} D_i\\right) = \\sum_{i=1}^{n} \\mathrm{Var}(D_i) = n \\sigma_s^2\n$$\n独立正态随机变量的和本身也是一个正态随机变量。因此，总突触延迟的分布为：\n$$\nT_{\\mathrm{synapse}} \\sim \\mathcal{N}(n\\mu_s, n\\sigma_s^2)\n$$\n\n接下来，我们分析轴突传导延迟 $T_{\\mathrm{axon}} = L/V$。速度 $V$ 是一个随机变量，因此 $T_{\\mathrm{axon}}$ 也是一个随机变量。根据指示，我们使用函数 $f(V) = L/V$ 在均值速度 $\\mu = \\mathbb{E}[V]$ 附近的二阶泰勒级数展开，以求其期望的近似值。\n该函数及其关于 $V$ 的前两个导数是：\n$$\nf(V) = \\frac{L}{V}, \\quad f'(V) = -\\frac{L}{V^2}, \\quad f''(V) = \\frac{2L}{V^3}\n$$\n$f(V)$ 在 $\\mu$ 附近的二阶泰勒展开为：\n$$\nf(V) \\approx f(\\mu) + f'(\\mu)(V-\\mu) + \\frac{1}{2}f''(\\mu)(V-\\mu)^2\n$$\n代入在 $\\mu$ 处求得的导数：\n$$\nT_{\\mathrm{axon}} = \\frac{L}{V} \\approx \\frac{L}{\\mu} - \\frac{L}{\\mu^2}(V-\\mu) + \\frac{1}{2}\\left(\\frac{2L}{\\mu^3}\\right)(V-\\mu)^2 = \\frac{L}{\\mu} - \\frac{L}{\\mu^2}(V-\\mu) + \\frac{L}{\\mu^3}(V-\\mu)^2\n$$\n对此表达式取期望：\n$$\n\\mathbb{E}[T_{\\mathrm{axon}}] \\approx \\mathbb{E}\\left[\\frac{L}{\\mu} - \\frac{L}{\\mu^2}(V-\\mu) + \\frac{L}{\\mu^3}(V-\\mu)^2\\right] = \\frac{L}{\\mu} - \\frac{L}{\\mu^2}\\mathbb{E}[V-\\mu] + \\frac{L}{\\mu^3}\\mathbb{E}[(V-\\mu)^2]\n$$\n根据定义，$\\mathbb{E}[V-\\mu] = \\mathbb{E}[V] - \\mu = \\mu - \\mu = 0$，且 $\\mathbb{E}[(V-\\mu)^2] = \\mathrm{Var}(V) = \\sigma^2$。代入这些可得到近似的期望轴突延迟：\n$$\n\\mathbb{E}[T_{\\mathrm{axon}}] \\approx \\frac{L}{\\mu} + \\frac{L\\sigma^2}{\\mu^3} = \\frac{L}{\\mu}\\left(1 + \\frac{\\sigma^2}{\\mu^2}\\right)\n$$\n对于轴突延迟的方差，我们使用一阶近似（delta方法），这在变异系数较小时是标准做法：\n$$\n\\mathrm{Var}(T_{\\mathrm{axon}}) = \\mathrm{Var}(f(V)) \\approx |f'(\\mu)|^2 \\mathrm{Var}(V)\n$$\n$$\n\\mathrm{Var}(T_{\\mathrm{axon}}) \\approx \\left(-\\frac{L}{\\mu^2}\\right)^2 \\sigma^2 = \\frac{L^2 \\sigma^2}{\\mu^4}\n$$\n现在我们结合总延迟 $T = T_{\\mathrm{axon}} + T_{\\mathrm{synapse}}$ 的结果。由于各分量的独立性，总延迟的期望值和方差分别是各部分之和。\n\n期望总延迟：\n$$\n\\mathbb{E}[T] = \\mathbb{E}[T_{\\mathrm{axon}}] + \\mathbb{E}[T_{\\mathrm{synapse}}] \\approx \\frac{L}{\\mu}\\left(1 + \\frac{\\sigma^2}{\\mu^2}\\right) + n \\mu_s\n$$\n总延迟的方差：\n$$\n\\mathrm{Var}(T) = \\mathrm{Var}(T_{\\mathrm{axon}}) + \\mathrm{Var}(T_{\\mathrm{synapse}}) \\approx \\frac{L^2 \\sigma^2}{\\mu^4} + n \\sigma_s^2\n$$\n总延迟 $T$ 是一个正态分布变量 ($T_{\\mathrm{synapse}}$) 与另一个随机变量 ($T_{\\mathrm{axon}}$) 之和，后者是一个近似正态变量的函数。在这种情况下，一个常见且合理的近似是将总延迟本身建模为一个正态随机变量。\n因此，每条通路的近似延迟分布为：\n$$\nT \\sim \\mathcal{N}\\left(\\frac{L}{\\mu}\\left(1 + \\frac{\\sigma^2}{\\mu^2}\\right) + n \\mu_s, \\frac{L^2 \\sigma^2}{\\mu^4} + n \\sigma_s^2\\right)\n$$\n\n### 任务2：数值计算\n\n我们得到以下参数，并确保单位一致（时间单位为秒，长度单位为米）。\n对于MT通路：\n$L_{\\mathrm{MT}} = 0.10\\,\\mathrm{m}$\n$\\mu_{\\mathrm{MT}} = 2.5\\,\\mathrm{m/s}$\n$\\sigma_{\\mathrm{MT}} = 0.50\\,\\mathrm{m/s}$\n$n_{\\mathrm{MT}} = 4$\n\n对于V4通路：\n$L_{\\mathrm{V4}} = 0.080\\,\\mathrm{m}$\n$\\mu_{\\mathrm{V4}} = 1.8\\,\\mathrm{m/s}$\n$\\sigma_{\\mathrm{V4}} = 0.36\\,\\mathrm{m/s}$\n$n_{\\mathrm{V4}} = 5$\n\n对于突触延迟（两条通路通用）：\n$\\mu_s = 1.2\\,\\mathrm{ms} = 1.2 \\times 10^{-3}\\,\\mathrm{s}$\n$\\sigma_s = 0.25\\,\\mathrm{ms} = 0.25 \\times 10^{-3}\\,\\mathrm{s}$\n\n我们现在使用推导出的 $\\mathbb{E}[T]$ 公式，计算每条通路的预测起始时间（期望延迟）。\n\n对于MT通路：\n$$\n\\mathbb{E}[T_{\\mathrm{MT}}] \\approx \\frac{L_{\\mathrm{MT}}}{\\mu_{\\mathrm{MT}}}\\left(1 + \\frac{\\sigma_{\\mathrm{MT}}^2}{\\mu_{\\mathrm{MT}}^2}\\right) + n_{\\mathrm{MT}} \\mu_s\n$$\n$$\n\\mathbb{E}[T_{\\mathrm{MT}}] \\approx \\frac{0.10}{2.5}\\left(1 + \\frac{(0.50)^2}{(2.5)^2}\\right) + 4 \\times (1.2 \\times 10^{-3})\n$$\n$$\n\\mathbb{E}[T_{\\mathrm{MT}}] \\approx 0.04\\left(1 + \\left(\\frac{0.50}{2.5}\\right)^2\\right) + 0.0048 = 0.04(1 + (0.2)^2) + 0.0048\n$$\n$$\n\\mathbb{E}[T_{\\mathrm{MT}}] \\approx 0.04(1 + 0.04) + 0.0048 = 0.04(1.04) + 0.0048 = 0.0416 + 0.0048 = 0.0464\\,\\mathrm{s}\n$$\n\n对于V4通路：\n$$\n\\mathbb{E}[T_{\\mathrm{V4}}] \\approx \\frac{L_{\\mathrm{V4}}}{\\mu_{\\mathrm{V4}}}\\left(1 + \\frac{\\sigma_{\\mathrm{V4}}^2}{\\mu_{\\mathrm{V4}}^2}\\right) + n_{\\mathrm{V4}} \\mu_s\n$$\n$$\n\\mathbb{E}[T_{\\mathrm{V4}}] \\approx \\frac{0.080}{1.8}\\left(1 + \\frac{(0.36)^2}{(1.8)^2}\\right) + 5 \\times (1.2 \\times 10^{-3})\n$$\n$$\n\\mathbb{E}[T_{\\mathrm{V4}}] \\approx \\frac{2}{45}\\left(1 + \\left(\\frac{0.36}{1.8}\\right)^2\\right) + 0.0060 = \\frac{2}{45}(1 + (0.2)^2) + 0.0060\n$$\n$$\n\\mathbb{E}[T_{\\mathrm{V4}}] \\approx \\frac{2}{45}(1 + 0.04) + 0.0060 = \\frac{2}{45}(1.04) + 0.0060 = \\frac{2.08}{45} + 0.0060\n$$\n$$\n\\mathbb{E}[T_{\\mathrm{V4}}] \\approx 0.046222... + 0.0060 = 0.052222...\\,\\mathrm{s}\n$$\nMT的预测起始时间为 $\\mathbb{E}[T_{\\mathrm{MT}}] = 46.4\\,\\mathrm{ms}$，V4的预测起始时间为 $\\mathbb{E}[T_{\\mathrm{V4}}] \\approx 52.2\\,\\mathrm{ms}$。\n\n最后，我们计算差值 $\\Delta t = \\mathbb{E}[T_{\\mathrm{V4}}] - \\mathbb{E}[T_{\\mathrm{MT}}]$。\n$$\n\\Delta t \\approx 0.052222... - 0.0464 = 0.0058222...\\,\\mathrm{s}\n$$\n将此结果转换为毫秒：\n$$\n\\Delta t \\approx 0.0058222...\\,\\mathrm{s} \\times \\frac{1000\\,\\mathrm{ms}}{1\\,\\mathrm{s}} \\approx 5.8222...\\,\\mathrm{ms}\n$$\n四舍五入到三位有效数字，我们得到 $5.82\\,\\mathrm{ms}$。", "answer": "$$\n\\boxed{5.82}\n$$", "id": "5013693"}, {"introduction": "我们对世界的感知是一个连贯的整体，尽管不同的特征（如运动和形状）是在不同的大脑通路中处理的。这个练习应用了贝叶斯推断，这是一个强大的计算框架，用于描述最优观察者如何根据不同信息源的可靠性来整合它们。您将模拟大脑如何权衡来自背侧通路的运动线索和来自腹侧通路的形状线索，以形成单一、统一的知觉，这揭示了计算神经科学的一个核心原则[@problem_id:5013729]。", "problem": "在灵长类动物的视觉系统中，背侧视觉通路主要处理运动衍生信息，而腹侧视觉通路则主要处理形状衍生信息。考虑一个关于单个潜在朝向角 $\\theta$（单位：度）的感知决策，该朝向角是相对于正前方，在短暂呈现一个移动的带纹理物体时产生的。假设如下：\n\n- 背侧运动线索产生一个测量值 $\\theta_{m}$，其高斯似然 $p(\\theta_{m} \\mid \\theta)$ 的均值为 $\\theta$，方差为 $\\sigma_{m}^{2}$。在一次特定试验中，运动测量值等于 $\\theta_{m} = 10$，背侧运动方差等于 $\\sigma_{m}^{2} = 4$。\n- 腹侧形状线索产生一个测量值 $\\theta_{s}$，其高斯似然 $p(\\theta_{s} \\mid \\theta)$ 的均值为 $\\theta$，方差为 $\\sigma_{s}^{2}$。在同一次试验中，形状测量值等于 $\\theta_{s} = -2$，腹侧形状方差等于 $\\sigma_{s}^{2} = 16$。\n- 观察者对朝向角有一个高斯先验 $p(\\theta)$，其均值为 $\\mu_{p} = 0$，方差为 $\\sigma_{p}^{2} = 64$。\n- 假设在给定 $\\theta$ 的条件下，这些线索是条件独立的。\n\n使用贝叶斯定理和上述假设，推导朝向角 $\\theta$ 的后验分布 $p(\\theta \\mid \\theta_{m}, \\theta_{s})$，并通过确定最大后验 (MAP) 估计来解释在线索冲突情况下的预测行为。量化背侧运动和腹侧形状线索的特定通路权重，该权重定义为在高斯假设下，每个线索的可靠性（方差的倒数）对最大后验估计的归一化贡献。\n\n仅报告朝向角的 MAP 估计作为您的最终答案，以度为单位表示。将最终答案四舍五入到四位有效数字。", "solution": "该问题要求基于两个带噪声的感官线索和一个先验信念，计算潜在朝向角 $\\theta$ 的最大后验 (MAP) 估计。这是一个贝叶斯推断问题，具体来说是线索整合问题。\n\n该问题已经过验证并被认为是有效的。它在计算神经科学方面有科学依据，问题陈述清晰，提供了所有必要的信息，并且其表述是客观的。\n\n根据贝叶斯定理，给定运动测量值 $\\theta_{m}$ 和形状测量值 $\\theta_{s}$ 时，角度 $\\theta$ 的后验概率分布与似然和先验的乘积成正比：\n$$p(\\theta \\mid \\theta_{m}, \\theta_{s}) \\propto p(\\theta_{m}, \\theta_{s} \\mid \\theta) p(\\theta)$$\n问题陈述，在给定真实朝向角 $\\theta$ 的条件下，两个线索是条件独立的。因此，联合似然可以分解为各个似然的乘积：\n$$p(\\theta_{m}, \\theta_{s} \\mid \\theta) = p(\\theta_{m} \\mid \\theta) p(\\theta_{s} \\mid \\theta)$$\n将此代入第一个方程，我们得到后验的表达式：\n$$p(\\theta \\mid \\theta_{m}, \\theta_{s}) \\propto p(\\theta_{m} \\mid \\theta) p(\\theta_{s} \\mid \\theta) p(\\theta)$$\n我们已知右侧的所有三个分布都是高斯分布：\n1.  背侧运动线索的似然：$p(\\theta_{m} \\mid \\theta) = \\mathcal{N}(\\theta, \\sigma_{m}^{2})$，其中测量值为 $\\theta_{m} = 10$，方差为 $\\sigma_{m}^{2} = 4$。\n2.  腹侧形状线索的似然：$p(\\theta_{s} \\mid \\theta) = \\mathcal{N}(\\theta, \\sigma_{s}^{2})$，其中测量值为 $\\theta_{s} = -2$，方差为 $\\sigma_{s}^{2} = 16$。\n3.  先验分布：$p(\\theta) = \\mathcal{N}(\\mu_{p}, \\sigma_{p}^{2})$，其中均值为 $\\mu_{p} = 0$，方差为 $\\sigma_{p}^{2} = 64$。\n\n高斯分布 $\\mathcal{N}(\\mu, \\sigma^2)$ 的概率密度函数与 $\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)$ 成正比。因此，后验分布为：\n$$p(\\theta \\mid \\theta_{m}, \\theta_{s}) \\propto \\exp\\left(-\\frac{(\\theta_{m}-\\theta)^2}{2\\sigma_{m}^{2}}\\right) \\exp\\left(-\\frac{(\\theta_{s}-\\theta)^2}{2\\sigma_{s}^{2}}\\right) \\exp\\left(-\\frac{(\\theta-\\mu_{p})^2}{2\\sigma_{p}^{2}}\\right)$$\n合并指数项：\n$$p(\\theta \\mid \\theta_{m}, \\theta_{s}) \\propto \\exp\\left( -\\frac{(\\theta-\\theta_{m})^2}{2\\sigma_{m}^{2}} -\\frac{(\\theta-\\theta_{s})^2}{2\\sigma_{s}^{2}} -\\frac{(\\theta-\\mu_{p})^2}{2\\sigma_{p}^{2}} \\right)$$\nMAP 估计 $\\theta_{\\text{MAP}}$ 是使该后验概率最大化的 $\\theta$ 值。最大化后验等价于最小化其负对数。设 $J(\\theta)$ 为指数中的项（也称为负对数后验，忽略常数项）：\n$$J(\\theta) = \\frac{(\\theta-\\theta_{m})^2}{2\\sigma_{m}^{2}} + \\frac{(\\theta-\\theta_{s})^2}{2\\sigma_{s}^{2}} + \\frac{(\\theta-\\mu_{p})^2}{2\\sigma_{p}^{2}}$$\n为了找到 $J(\\theta)$ 的最小值，我们对其关于 $\\theta$ 求导并令其为 $0$：\n$$\\frac{dJ}{d\\theta} = \\frac{2(\\theta-\\theta_{m})}{2\\sigma_{m}^{2}} + \\frac{2(\\theta-\\theta_{s})}{2\\sigma_{s}^{2}} + \\frac{2(\\theta-\\mu_{p})}{2\\sigma_{p}^{2}} = 0$$\n$$\\frac{\\theta-\\theta_{m}}{\\sigma_{m}^{2}} + \\frac{\\theta-\\theta_{s}}{\\sigma_{s}^{2}} + \\frac{\\theta-\\mu_{p}}{\\sigma_{p}^{2}} = 0$$\n我们可以分离出包含 $\\theta$ 的项：\n$$\\theta\\left(\\frac{1}{\\sigma_{m}^{2}} + \\frac{1}{\\sigma_{s}^{2}} + \\frac{1}{\\sigma_{p}^{2}}\\right) = \\frac{\\theta_{m}}{\\sigma_{m}^{2}} + \\frac{\\theta_{s}}{\\sigma_{s}^{2}} + \\frac{\\mu_{p}}{\\sigma_{p}^{2}}$$\n求解 $\\theta$ 得到 MAP 估计 $\\theta_{\\text{MAP}}$：\n$$\\theta_{\\text{MAP}} = \\frac{\\frac{\\theta_{m}}{\\sigma_{m}^{2}} + \\frac{\\theta_{s}}{\\sigma_{s}^{2}} + \\frac{\\mu_{p}}{\\sigma_{p}^{2}}}{\\frac{1}{\\sigma_{m}^{2}} + \\frac{1}{\\sigma_{s}^{2}} + \\frac{1}{\\sigma_{p}^{2}}}$$\n这个方程表明，MAP 估计是测量值和先验均值的加权平均，其中权重是每个信息源的可靠性（方差的倒数）。设可靠性为 $r_{i} = 1/\\sigma_{i}^{2}$。\n$$r_{m} = \\frac{1}{\\sigma_{m}^{2}} = \\frac{1}{4}$$\n$$r_{s} = \\frac{1}{\\sigma_{s}^{2}} = \\frac{1}{16}$$\n$$r_{p} = \\frac{1}{\\sigma_{p}^{2}} = \\frac{1}{64}$$\nMAP 估计方程变为：\n$$\\theta_{\\text{MAP}} = \\frac{r_{m}\\theta_{m} + r_{s}\\theta_{s} + r_{p}\\mu_{p}}{r_{m} + r_{s} + r_{p}}$$\n代入给定的数值：\n$\\theta_{\\text{MAP}} = \\frac{(\\frac{1}{4})(10) + (\\frac{1}{16})(-2) + (\\frac{1}{64})(0)}{\\frac{1}{4} + \\frac{1}{16} + \\frac{1}{64}}$\n首先，我们计算分子：\n$$\\text{Numerator} = \\frac{10}{4} - \\frac{2}{16} + 0 = 2.5 - 0.125 = 2.375$$\n以分数形式表示：$\\frac{160}{64} - \\frac{8}{64} = \\frac{152}{64}$。\n接下来，我们计算分母：\n$$\\text{Denominator} = \\frac{1}{4} + \\frac{1}{16} + \\frac{1}{64} = \\frac{16}{64} + \\frac{4}{64} + \\frac{1}{64} = \\frac{21}{64}$$\n现在，我们计算 $\\theta_{\\text{MAP}}$ 的最终值：\n$$\\theta_{\\text{MAP}} = \\frac{\\frac{152}{64}}{\\frac{21}{64}} = \\frac{152}{21}$$\n其小数值约为 $7.2380952...$\n\n每个线索的归一化权重是其可靠性除以总可靠性。\n总可靠性：$r_{\\text{total}} = r_{m} + r_{s} + r_{p} = \\frac{21}{64}$。\n背侧运动线索的权重：$w_{m} = \\frac{r_{m}}{r_{\\text{total}}} = \\frac{1/4}{21/64} = \\frac{16}{21} \\approx 0.762$。\n腹侧形状线索的权重：$w_{s} = \\frac{r_{s}}{r_{\\text{total}}} = \\frac{1/16}{21/64} = \\frac{4}{21} \\approx 0.190$。\n背侧运动线索的高可靠性 ($\\sigma_{m}^{2} = 4$) 使其具有较大的权重，将 MAP 估计值 $\\approx 7.24$ 度拉得更接近其测量值 $\\theta_{m}=10$，而不是相互冲突的腹侧形状线索测量值 $\\theta_{s}=-2$ 或先验均值 $\\mu_{p}=0$。\n\n问题要求朝向角的 MAP 估计，四舍五入到四位有效数字。\n$\\theta_{\\text{MAP}} = \\frac{152}{21} \\approx 7.2380952...$\n四舍五入到四位有效数字得到 $7.238$。", "answer": "$$\n\\boxed{7.238}\n$$", "id": "5013729"}, {"introduction": "神经科学的一个关键目标是理解神经元群体如何表征信息，并将这些表征与计算模型进行比较。这个练习介绍了表征相似性分析（Representational Similarity Analysis, RSA），这是一种强大的方法，用于比较不同系统（例如，模型与大脑区域）的“表征几何”。通过实现一个交叉验证的RSA流程，您将学习一种前沿技术，用于量化评估模型的特征与背侧通路（MT）和腹侧通路（IT）中神经活动的匹配程度，从而在理论模型和实证数据之间架起桥梁[@problem_id:5013737]。", "problem": "为您提供了模拟的响应矩阵，这些矩阵反映了一个计算模型对一组共享刺激的响应，以及来自与视觉背侧流和腹侧流相关的两个经典视觉区域的相应神经群体响应。具体来说，背侧流由中颞区（MT; Middle Temporal）代表，腹侧流由下颞叶皮层（IT; Inferior Temporal）代表。您的任务是使用表征相似性分析（representational similarity analysis）及交叉验证相关性，来量化模型与神经表征几何之间的一致性。\n\n使用的基本原理和定义：\n- 表征非相似性矩阵由响应矩阵定义而来：首先计算每对刺激在所有单元上的皮尔逊相关系数，然后通过 $d_{ij} = 1 - \\rho_{ij}$ 转换为非相似性。对于一个响应矩阵 $X \\in \\mathbb{R}^{n \\times p}$（其中 $n$ 是刺激数量，$p$ 是单元数量），定义表征非相似性矩阵 $D \\in \\mathbb{R}^{n \\times n}$ 为 $D_{ij} = 1 - \\mathrm{corr}(X_{i,\\cdot}, X_{j,\\cdot})$，且 $D_{ii} = 0$。\n- 以一致的顺序将 $D$ 的上三角部分（不包括对角线）向量化为一个向量 $v \\in \\mathbb{R}^{n(n-1)/2}$。\n- 给定模型的两个独立分割 $(M^{A}, M^{B})$ 和神经数据的两个独立分割 $(N^{1}, N^{2})$，构建四个表征非相似性向量 $v(M^{A}), v(M^{B}), v(N^{1}), v(N^{2})$。通过计算 $r_{1} = \\mathrm{corr}(v(M^{A}), v(N^{2}))$ 和 $r_{2} = \\mathrm{corr}(v(M^{B}), v(N^{1}))$ 来定义交叉验证的皮尔逊相关性。使用费雪z变换（Fisher $z$-transform）$z(r) = \\tfrac{1}{2}\\ln\\left(\\tfrac{1+r}{1-r}\\right)$ 合并 $r_1$ 和 $r_2$，在 $z$ 空间中取平均值，然后用 $\\tanh$ 进行逆变换，得到最终估计值 $r_{\\mathrm{cv}} = \\tanh\\left(\\tfrac{z(r_{1}) + z(r_{2})}{2}\\right)$。\n\n算法要求：\n- 在非相似性构建和最终的向量间相关性计算中，均使用皮尔逊相关性。\n- 在应用费雪z变换时，通过以原则性方式处理 $r = \\pm 1$ 的边界情况，确保数值稳定性。\n- 所有计算必须是确定性的，并且只能使用所提供的矩阵和定义。\n\n测试套件：\n您必须为四个独立的场景计算 $r_{\\mathrm{cv}}$。对于每个场景，五个刺激的案例中刺激顺序固定为 $(s_{1}, s_{2}, s_{3}, s_{4}, s_{5})$，四个刺激的案例中刺激顺序固定为 $(t_{1}, t_{2}, t_{3}, t_{4})$。\n\n场景 1（模型运动特征 vs MT；$5 \\times 4$ 响应）：\n- 模型运动分割 A，$M_{\\mathrm{motion}}^{A} \\in \\mathbb{R}^{5 \\times 4}$：\n$$\n\\begin{bmatrix}\n2.0  2.0  0.1  0.0 \\\\\n1.9  2.1  0.0  0.2 \\\\\n0.2  0.0  2.1  2.0 \\\\\n0.0  0.1  1.9  2.2 \\\\\n0.1  0.2  2.0  2.1\n\\end{bmatrix}\n$$\n- 模型运动分割 B，$M_{\\mathrm{motion}}^{B} \\in \\mathbb{R}^{5 \\times 4}$：\n$$\n\\begin{bmatrix}\n2.1  1.9  0.0  0.1 \\\\\n2.0  2.0  0.1  0.1 \\\\\n0.1  0.0  2.0  2.2 \\\\\n0.0  0.2  2.2  1.9 \\\\\n0.2  0.1  2.1  2.0\n\\end{bmatrix}\n$$\n- 神经 MT 分割 1，$N_{\\mathrm{MT}}^{1} \\in \\mathbb{R}^{5 \\times 4}$：\n$$\n\\begin{bmatrix}\n2.2  2.1  0.0  0.1 \\\\\n1.8  2.0  0.1  0.1 \\\\\n0.0  0.1  2.2  2.1 \\\\\n0.1  0.0  1.8  2.0 \\\\\n0.1  0.2  2.1  2.2\n\\end{bmatrix}\n$$\n- 神经 MT 分割 2，$N_{\\mathrm{MT}}^{2} \\in \\mathbb{R}^{5 \\times 4}$：\n$$\n\\begin{bmatrix}\n2.0  2.2  0.1  0.0 \\\\\n2.1  1.9  0.0  0.2 \\\\\n0.2  0.0  2.0  2.1 \\\\\n0.0  0.1  2.2  1.8 \\\\\n0.1  0.2  2.0  2.3\n\\end{bmatrix}\n$$\n\n场景 2（模型形状特征 vs IT；$5 \\times 4$ 响应）：\n- 模型形状分割 A，$M_{\\mathrm{form}}^{A} \\in \\mathbb{R}^{5 \\times 4}$：\n$$\n\\begin{bmatrix}\n2.0  2.0  0.1  0.0 \\\\\n0.1  0.0  2.0  2.0 \\\\\n2.1  1.9  0.0  0.1 \\\\\n0.0  0.1  2.1  1.9 \\\\\n1.0  1.1  0.9  1.0\n\\end{bmatrix}\n$$\n- 模型形状分割 B，$M_{\\mathrm{form}}^{B} \\in \\mathbb{R}^{5 \\times 4}$：\n$$\n\\begin{bmatrix}\n2.1  1.9  0.0  0.1 \\\\\n0.0  0.1  2.1  1.9 \\\\\n1.9  2.1  0.1  0.0 \\\\\n0.1  0.0  1.9  2.1 \\\\\n1.1  1.0  1.0  0.9\n\\end{bmatrix}\n$$\n- 神经 IT 分割 1，$N_{\\mathrm{IT}}^{1} \\in \\mathbb{R}^{5 \\times 4}$：\n$$\n\\begin{bmatrix}\n2.2  2.1  0.0  0.1 \\\\\n0.0  0.1  2.0  2.1 \\\\\n1.8  2.0  0.1  0.0 \\\\\n0.1  0.0  1.9  2.0 \\\\\n1.1  1.0  0.9  1.0\n\\end{bmatrix}\n$$\n- 神经 IT 分割 2，$N_{\\mathrm{IT}}^{2} \\in \\mathbb{R}^{5 \\times 4}$：\n$$\n\\begin{bmatrix}\n2.0  2.2  0.1  0.0 \\\\\n0.1  0.0  2.2  1.8 \\\\\n2.1  1.9  0.0  0.2 \\\\\n0.0  0.2  1.8  2.2 \\\\\n0.9  1.0  1.1  1.0\n\\end{bmatrix}\n$$\n\n场景 3（跨流不匹配控制：模型运动特征 vs IT；$5 \\times 4$ 响应）：\n- 使用场景 1 中的 $M_{\\mathrm{motion}}^{A}$ 和 $M_{\\mathrm{motion}}^{B}$。\n- 使用场景 2 中的 $N_{\\mathrm{IT}}^{1}$ 和 $N_{\\mathrm{IT}}^{2}$。\n\n场景 4（跨分割的表征几何相同的边界情况；$4 \\times 3$ 响应）：\n- 令公共响应矩阵 $R \\in \\mathbb{R}^{4 \\times 3}$ 为\n$$\n\\begin{bmatrix}\n0.0  1.0  2.0 \\\\\n0.5  1.0  1.5 \\\\\n2.0  1.0  0.0 \\\\\n1.5  1.0  0.5\n\\end{bmatrix}\n$$\n- 设置 $M^{A} = R$, $M^{B} = R$, $N^{1} = R$, $N^{2} = R$。\n\n要求输出：\n- 对每个场景，计算上文定义的交叉验证相关性 $r_{\\mathrm{cv}}$。\n- 最终程序输出必须是单行文本，包含四个结果，以逗号分隔并用方括号括起，顺序为场景 1、2、3、4。\n- 每个值必须是浮点数，并四舍五入到 6 位小数。\n\n您的程序必须以“[result1,result2,result3,result4]”的格式精确输出一行。不涉及物理单位。不涉及角度。所有百分比（如有）必须以小数形式表示，但此处无此要求。程序必须是自包含的，不接受任何输入，且仅使用提供的定义和矩阵。计算必须使用支持执行环境中指定的线性代数运算的现代编程语言来执行。", "solution": "该问题要求计算一个交叉验证的相关系数，记为 $r_{\\mathrm{cv}}$，用以量化计算模型和神经数据的表征几何之间的相似性。这项任务属于表征相似性分析（Representational Similarity Analysis, RSA）的范畴，这是计算神经科学中的一种常用技术。该分析需要针对 4 个不同的场景进行。\n\n解决方案通过遵循一系列明确定义的数学步骤来实现。首先，构建一个函数，将响应矩阵转换为其对应的表征非相似性矩阵（Representational Dissimilarity Matrix, RDM），然后将其向量化。其次，另一个函数使用此转换，根据每个场景提供的四个输入响应矩阵计算最终的交叉验证相关性 $r_{\\mathrm{cv}}$。\n\n**步骤 1：计算表征非相似性向量**\n\n第一个核心过程是将一个响应矩阵 $X \\in \\mathbb{R}^{n \\times p}$（其中 $n$ 是刺激数量，$p$ 是测量单元数量，例如神经元或模型单元）转换为一个向量化的 RDM。这包括三个子步骤：\n\n1.  **逐对相关性计算：** 对于索引为 $i$ 和 $j$ 的每一对刺激，我们考虑它们对应的响应向量，即矩阵 $X$ 的行 $X_{i, \\cdot}$ 和 $X_{j, \\cdot}$。计算所有行对的皮尔逊相关系数 $\\rho_{ij} = \\mathrm{corr}(X_{i,\\cdot}, X_{j,\\cdot})$。这将产生一个对称的 $n \\times n$ 相关矩阵 $P$，其中 $P_{ij} = \\rho_{ij}$，且对角线元素均为 $1$。\n\n2.  **非相似性转换：** 使用公式 $D_{ij} = 1 - \\rho_{ij}$ 将相关矩阵 $P$ 转换为表征非相似性矩阵（RDM）$D$。此转换将高正相关（高相似性）映射到低的非相似性值（接近 $0$），将高负相关（高反相似性）映射到高的非相似性值（接近 $2$）。对角线元素 $D_{ii}$ 被明确设置为 $0$，因为一个刺激表征与自身的非相似性为零。\n\n3.  **向量化：** RDM $D$ 是一个对称矩阵。所有相关信息都包含在其上三角（或下三角）中。我们将 $D$ 的严格上三角部分（即所有 $i  j$ 的元素 $D_{ij}$）向量化为单个向量 $v$。对于一个 $n \\times n$ 矩阵，该向量的长度为 $n(n-1)/2$。为确保后续比较的有效性，所有矩阵的向量化必须遵循一致的顺序。\n\n**步骤 2：计算交叉验证相关性 ($r_{\\mathrm{cv}}$)**\n\n第二个核心过程使用模型响应的两个独立分割 $(M^{A}, M^{B})$ 和神经响应的两个独立分割 $(N^{1}, N^{2})$ 来计算最终的摘要统计量 $r_{\\mathrm{cv}}$。这种交叉验证方案可以防止因使用相同数据进行拟合和评估，或因单个数据集内的噪声相关性而可能产生的统计膨胀。\n\n1.  **生成 RDM 向量：** 使用步骤 1 中的过程，我们计算四个 RDM 向量：$v(M^{A})$、$v(M^{B})$、$v(N^{1})$ 和 $v(N^{2})$。\n\n2.  **计算交叉相关性：** 在独立分割之间计算两个皮尔逊相关性。“分割-半”逻辑要求将一个模型分割与*另一个*神经分割相关联：\n    *   $r_{1} = \\mathrm{corr}(v(M^{A}), v(N^{2}))$\n    *   $r_{2} = \\mathrm{corr}(v(M^{B}), v(N^{1}))$\n\n3.  **通过费雪z变换平均相关性：** 相关系数不具有可加性。为了正确地对它们进行平均，必须首先将它们转换到一个近似正态分布且方差稳定的空间中。费雪z变换（Fisher $z$-transform）正是用于此目的：\n    $$z(r) = \\frac{1}{2}\\ln\\left(\\frac{1+r}{1-r}\\right) = \\mathrm{arctanh}(r)$$\n    我们计算 $z(r_1)$ 和 $z(r_2)$，以及它们的算术平均值 $\\bar{z} = \\frac{z(r_1) + z(r_2)}{2}$。问题要求处理 $r = \\pm 1$ 的边界情况。$\\mathrm{arctanh}$ 函数能正确地将 $r=1$ 映射到 $\\infty$，将 $r=-1$ 映射到 $-\\infty$。随后的平均和逆变换能正确处理这些无穷大值。\n\n4.  **逆变换：** 使用费雪z变换的逆变换，即双曲正切函数，将平均值 $\\bar{z}$ 转换回相关空间：\n    $$r_{\\mathrm{cv}} = \\tanh(\\bar{z})$$\n    这个最终值 $r_{\\mathrm{cv}}$ 就是模型与神经表征几何之间的交叉验证相似性得分。\n\n**应用于各场景**\n\n将上述过程应用于问题中定义的四个场景。\n\n*   **场景 1：** 模型运动 vs. MT。输入为 $M_{\\mathrm{motion}}^{A}$、$M_{\\mathrm{motion}}^{B}$、$N_{\\mathrm{MT}}^{1}$ 和 $N_{\\mathrm{MT}}^{2}$。所有矩阵均为 $5 \\times 4$。每个 RDM 向量将有 $5(4)/2 = 10$ 个元素。计算得出 $r_{\\mathrm{cv}} \\approx 0.999690$。\n\n*   **场景 2：** 模型形状 vs. IT。输入为 $M_{\\mathrm{form}}^{A}$、$M_{\\mathrm{form}}^{B}$、$N_{\\mathrm{IT}}^{1}$ 和 $N_{\\mathrm{IT}}^{2}$。所有矩阵均为 $5 \\times 4$。每个 RDM 向量将有 10 个元素。计算得出 $r_{\\mathrm{cv}} \\approx 0.992225$。\n\n*   **场景 3：** 跨流不匹配控制（模型运动 vs. IT）。此场景作为一个特异性控制，测试运动处理模型与运动相关脑区（MT）的一致性是否优于与形状相关脑区（IT）的一致性。输入为场景 1 的 $M_{\\mathrm{motion}}^{A}$、$M_{\\mathrm{motion}}^{B}$ 和场景 2 的 $N_{\\mathrm{IT}}^{1}$、$N_{\\mathrm{IT}}^{2}$。计算得出 $r_{\\mathrm{cv}} \\approx 0.088383$。正如预期的那样，这种不匹配的相关性远低于场景 1 和 2 中的匹配相关性。\n\n*   **场景 4：** 边界情况。此处，所有四个输入矩阵均相同：$M^{A} = M^{B} = N^{1} = N^{2} = R$。$R$ 是一个 $4 \\times 3$ 矩阵。\n    *   由于所有输入矩阵都相同，所有四个 RDM 向量也将相同：$v(M^A) = v(M^B) = v(N^1) = v(N^2) = v(R)$。\n    *   交叉相关性将为 $r_1 = \\mathrm{corr}(v(R), v(R)) = 1$ 和 $r_2 = \\mathrm{corr}(v(R), v(R)) = 1$，前提是向量 $v(R)$ 不是常数（对于给定的矩阵 $R$，它不是常数）。\n    *   $r=1$ 的费雪z变换为 $z(1) = \\mathrm{arctanh}(1) = \\infty$。\n    *   平均值为 $\\bar{z} = (\\infty + \\infty)/2 = \\infty$。\n    *   最终结果是 $r_{\\mathrm{cv}} = \\tanh(\\infty) = 1$。\n    此计算证实了边界条件逻辑的正确性，并为实现提供了一致性检查。结果恰好是 $1.0$。\n\n该实现将系统地将这些步骤应用于所提供的数据矩阵，以计算最终的四个值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_rdm_vector(response_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the vectorized upper-triangular of the Representational Dissimilarity Matrix (RDM).\n\n    Args:\n        response_matrix: An n x p numpy array where n is the number of stimuli\n                         and p is the number of units.\n\n    Returns:\n        A 1D numpy array of length n(n-1)/2 representing the vectorized RDM.\n    \"\"\"\n    # Step 1: Compute the n x n matrix of Pearson correlations between rows.\n    # np.corrcoef with default rowvar=True computes correlation between rows.\n    # If a row is constant, its std dev is 0, leading to NaNs in corrcoef.\n    # The problem data avoids this.\n    corr_matrix = np.corrcoef(response_matrix)\n\n    # Step 2: Convert to a dissimilarity matrix (RDM)\n    dissimilarity_matrix = 1.0 - corr_matrix\n\n    # Step 3: Vectorize the upper-triangular part (excluding the diagonal, k=1)\n    n = response_matrix.shape[0]\n    upper_triangle_indices = np.triu_indices(n, k=1)\n    rdm_vector = dissimilarity_matrix[upper_triangle_indices]\n\n    return rdm_vector\n\ndef compute_r_cv(M_A: np.ndarray, M_B: np.ndarray, N_1: np.ndarray, N_2: np.ndarray) -> float:\n    \"\"\"\n    Computes the cross-validated Pearson correlation between model and neural RDMs.\n\n    Args:\n        M_A: Model response matrix, split A.\n        M_B: Model response matrix, split B.\n        N_1: Neural response matrix, split 1.\n        N_2: Neural response matrix, split 2.\n\n    Returns:\n        The cross-validated correlation coefficient, r_cv.\n    \"\"\"\n    # Step 1: Compute the four RDM vectors\n    v_M_A = compute_rdm_vector(M_A)\n    v_M_B = compute_rdm_vector(M_B)\n    v_N_1 = compute_rdm_vector(N_1)\n    v_N_2 = compute_rdm_vector(N_2)\n\n    # Step 2: Compute the two cross-correlations\n    # np.corrcoef returns a 2x2 matrix, the value is at [0, 1] or [1, 0]\n    r1 = np.corrcoef(v_M_A, v_N_2)[0, 1]\n    r2 = np.corrcoef(v_M_B, v_N_1)[0, 1]\n\n    # Step 3: Average correlations using Fisher z-transform\n    # numpy.arctanh is the Fisher z-transform. It handles r = +/- 1 by returning +/- inf.\n    z1 = np.arctanh(r1)\n    z2 = np.arctanh(r2)\n    avg_z = (z1 + z2) / 2.0\n\n    # Step 4: Inverse transform to get the final r_cv\n    # numpy.tanh is the inverse of the Fisher z-transform.\n    r_cv = np.tanh(avg_z)\n    \n    return r_cv\n\ndef solve():\n    \"\"\"\n    Main function to run all scenarios and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Scenario 1 Data\n    M_motion_A = np.array([\n        [2.0, 2.0, 0.1, 0.0],\n        [1.9, 2.1, 0.0, 0.2],\n        [0.2, 0.0, 2.1, 2.0],\n        [0.0, 0.1, 1.9, 2.2],\n        [0.1, 0.2, 2.0, 2.1]\n    ])\n    M_motion_B = np.array([\n        [2.1, 1.9, 0.0, 0.1],\n        [2.0, 2.0, 0.1, 0.1],\n        [0.1, 0.0, 2.0, 2.2],\n        [0.0, 0.2, 2.2, 1.9],\n        [0.2, 0.1, 2.1, 2.0]\n    ])\n    N_MT_1 = np.array([\n        [2.2, 2.1, 0.0, 0.1],\n        [1.8, 2.0, 0.1, 0.1],\n        [0.0, 0.1, 2.2, 2.1],\n        [0.1, 0.0, 1.8, 2.0],\n        [0.1, 0.2, 2.1, 2.2]\n    ])\n    N_MT_2 = np.array([\n        [2.0, 2.2, 0.1, 0.0],\n        [2.1, 1.9, 0.0, 0.2],\n        [0.2, 0.0, 2.0, 2.1],\n        [0.0, 0.1, 2.2, 1.8],\n        [0.1, 0.2, 2.0, 2.3]\n    ])\n\n    # Scenario 2 Data\n    M_form_A = np.array([\n        [2.0, 2.0, 0.1, 0.0],\n        [0.1, 0.0, 2.0, 2.0],\n        [2.1, 1.9, 0.0, 0.1],\n        [0.0, 0.1, 2.1, 1.9],\n        [1.0, 1.1, 0.9, 1.0]\n    ])\n    M_form_B = np.array([\n        [2.1, 1.9, 0.0, 0.1],\n        [0.0, 0.1, 2.1, 1.9],\n        [1.9, 2.1, 0.1, 0.0],\n        [0.1, 0.0, 1.9, 2.1],\n        [1.1, 1.0, 1.0, 0.9]\n    ])\n    N_IT_1 = np.array([\n        [2.2, 2.1, 0.0, 0.1],\n        [0.0, 0.1, 2.0, 2.1],\n        [1.8, 2.0, 0.1, 0.0],\n        [0.1, 0.0, 1.9, 2.0],\n        [1.1, 1.0, 0.9, 1.0]\n    ])\n    N_IT_2 = np.array([\n        [2.0, 2.2, 0.1, 0.0],\n        [0.1, 0.0, 2.2, 1.8],\n        [2.1, 1.9, 0.0, 0.2],\n        [0.0, 0.2, 1.8, 2.2],\n        [0.9, 1.0, 1.1, 1.0]\n    ])\n\n    # Scenario 4 Data\n    R = np.array([\n        [0.0, 1.0, 2.0],\n        [0.5, 1.0, 1.5],\n        [2.0, 1.0, 0.0],\n        [1.5, 1.0, 0.5]\n    ])\n\n    # Execute all scenarios\n    r_cv1 = compute_r_cv(M_motion_A, M_motion_B, N_MT_1, N_MT_2)\n    r_cv2 = compute_r_cv(M_form_A, M_form_B, N_IT_1, N_IT_2)\n    r_cv3 = compute_r_cv(M_motion_A, M_motion_B, N_IT_1, N_IT_2)\n    r_cv4 = compute_r_cv(R, R, R, R)\n\n    results = [r_cv1, r_cv2, r_cv3, r_cv4]\n\n    # Format and print the final output as specified.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "5013737"}]}