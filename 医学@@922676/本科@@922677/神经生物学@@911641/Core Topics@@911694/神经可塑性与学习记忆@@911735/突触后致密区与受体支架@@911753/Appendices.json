{"hands_on_practices": [{"introduction": "在我们深入研究突触后致密区（PSD）复杂机器的工作原理之前，首先了解其尺度是很有帮助的。第一个练习提供了一个切实的入口：它将引导你估算在PSD的微小体积内，关键蛋白分子的数量。通过运用化学和几何学的基本原理，你将能够连接宏观浓度与微观的单个分子世界 [@problem_id:5075270]。", "problem": "一个树突棘的突触后致密区（PSD）可以理想化为一个均匀的平板，其几何形状由诸如突触后致密区蛋白95（PSD-95）和SH3及多个锚蛋白重复结构域蛋白（SHANK）等支架受体复合物所决定。钙/钙调蛋白依赖性蛋白激酶II（CaMKII）全酶由于与支架组分和肌动蛋白结合，而在这个平板内高度富集。假设CaMKII在PSD内均匀分布，其摩尔浓度为 $c$（单位为 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$）。该平板的面积为 $A$，厚度为 $t$，体积为 $V$。\n\n从摩尔浓度 $c$（单位体积的摩尔数）的核心定义、由阿伏伽德罗常数 $N_{A}$ 给出的分子数 $N$ 和摩尔数 $n$ 之间的关系，以及面积、厚度和体积之间的几何关系出发，推导一个用 $A$、$t$、$c$ 和 $N_{A}$ 表示PSD中CaMKII全酶近似数量 $N$ 的表达式。然后使用以下实验上合理的参数计算 $N$ 的值：\n- $A = 0.085 \\ \\mu\\mathrm{m}^{2}$\n- $t = 38 \\ \\mathrm{nm}$\n- $c = 130 \\ \\mu\\mathrm{M}$\n- $N_{A} = 6.022 \\times 10^{23} \\ \\mathrm{mol}^{-1}$\n\n将您的最终答案表示为一个无单位的计数，并四舍五入到四位有效数字。", "solution": "对问题陈述进行有效性评估。\n\n### 步骤1：提取已知条件\n- 突触后致密区（PSD）被建模为一个均匀的平板。\n- 平板面积：$A$\n- 平板厚度：$t$\n- 平板体积：$V$\n- CaMKII在PSD内均匀分布。\n- CaMKII的摩尔浓度：$c$\n- CaMKII的摩尔数：$n$\n- CaMKII全酶数量：$N$\n- 阿伏伽德罗常数：$N_{A}$\n- 提供的核心定义：\n  - 摩尔浓度：$c = \\frac{n}{V}$\n  - 摩尔数与分子数的关系：$N = n N_{A}$\n  - 几何关系：$V = A \\times t$\n- 用于计算的数值参数：\n  - $A = 0.085 \\ \\mu\\mathrm{m}^{2}$\n  - $t = 38 \\ \\mathrm{nm}$\n  - $c = 130 \\ \\mu\\mathrm{M}$\n  - $N_{A} = 6.022 \\times 10^{23} \\ \\mathrm{mol}^{-1}$\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于化学（摩尔浓度、阿伏伽德罗常数）和几何学的基本原理。将PSD建模为简单的几何平板是定量细胞生物学和生物物理学中用于数量级估算的常规简化方法。所提供的PSD尺寸和CaMKII浓度的数值是实验上合理的，并与神经生物学文献中报道的值一致。\n- **适定性**：该问题是适定的。它要求从一组给定的定义中推导出一个表达式，然后使用提供的参数进行数值计算。信息充分且一致，能够得出一个唯一的解。\n- **客观性**：问题以清晰、客观的语言陈述，没有歧义或主观论断。\n\n该问题没有表现出任何诸如科学上不成立、信息缺失或逻辑矛盾等缺陷。所给参数的单位在量纲上是一致的，尽管计算时需要仔细进行单位转换。\n\n### 步骤3：结论与行动\n该问题有效。将提供一个完整的解。\n\n任务是首先推导出CaMKII分子数量 $N$ 的通用符号表达式，然后使用提供的参数计算其数值。\n\n**第1部分：符号表达式的推导**\n\n我们从问题陈述中提供的核心定义开始。\n1. 摩尔浓度 $c$ 的定义是单位体积 $V$ 内的摩尔数 $n$：\n$$c = \\frac{n}{V}$$\n根据这个定义，我们可以用浓度和体积表示摩尔数 $n$：\n$$n = cV$$\n\n2. 分子数 $N$ 通过阿伏伽德罗常数 $N_{A}$ 与摩尔数 $n$ 相关联：\n$$N = n N_{A}$$\n\n3. 将第一步中 $n$ 的表达式代入第二个方程，得到用 $c$、$V$ 和 $N_{A}$ 表示 $N$ 的表达式：\n$$N = (cV) N_{A}$$\n\n4. PSD被建模为面积为 $A$、厚度为 $t$ 的平板。这样一个平板的体积 $V$ 由以下公式给出：\n$$V = At$$\n\n5. 最后，我们将这个体积 $V$ 的几何关系代入我们关于 $N$ 的表达式中：\n$$N = c(At)N_{A}$$\n这就是所要求的PSD中CaMKII全酶数量 $N$ 的符号表达式。\n\n**第2部分：数值计算**\n\n为了计算 $N$，我们必须对所有参数使用一组一致的单位。我们将所有量都转换为国际单位制（SI）基本单位（米、摩尔）。\n\n给定的参数是：\n- $A = 0.085 \\ \\mu\\mathrm{m}^{2}$\n- $t = 38 \\ \\mathrm{nm}$\n- $c = 130 \\ \\mu\\mathrm{M}$\n- $N_{A} = 6.022 \\times 10^{23} \\ \\mathrm{mol}^{-1}$\n\n首先，我们将面积 $A$ 从平方微米（$\\mu\\mathrm{m}^2$）转换为平方米（$\\mathrm{m}^2$）。因为 $1 \\ \\mu\\mathrm{m} = 10^{-6} \\ \\mathrm{m}$：\n$$A = 0.085 \\ (\\mu\\mathrm{m})^{2} = 0.085 \\times (10^{-6} \\ \\mathrm{m})^{2} = 0.085 \\times 10^{-12} \\ \\mathrm{m}^{2}$$\n\n接着，我们将厚度 $t$ 从纳米（$\\mathrm{nm}$）转换为米（$\\mathrm{m}$）。因为 $1 \\ \\mathrm{nm} = 10^{-9} \\ \\mathrm{m}$：\n$$t = 38 \\ \\mathrm{nm} = 38 \\times 10^{-9} \\ \\mathrm{m}$$\n\n现在，我们将浓度 $c$ 从微摩尔（$\\mu\\mathrm{M}$）转换为摩尔每立方米（$\\mathrm{mol} \\cdot \\mathrm{m}^{-3}$）。摩尔浓度单位是摩尔每升（$\\mathrm{mol} \\cdot \\mathrm{L}^{-1}$）。首先，$1 \\ \\mu\\mathrm{M} = 10^{-6} \\ \\mathrm{M} = 10^{-6} \\ \\mathrm{mol} \\cdot \\mathrm{L}^{-1}$。其次，我们使用转换因子 $1 \\ \\mathrm{L} = 10^{-3} \\ \\mathrm{m}^3$。\n$$c = 130 \\ \\mu\\mathrm{M} = 130 \\times 10^{-6} \\ \\frac{\\mathrm{mol}}{\\mathrm{L}}$$\n$$c = 130 \\times 10^{-6} \\ \\frac{\\mathrm{mol}}{\\mathrm{L}} \\times \\frac{1 \\ \\mathrm{L}}{10^{-3} \\ \\mathrm{m}^{3}} = 130 \\times 10^{-3} \\ \\mathrm{mol} \\cdot \\mathrm{m}^{-3}$$\n\n将所有参数都使用SI单位后，我们可以将它们代入我们推导出的公式 $N = c A t N_{A}$ 中：\n$$N = (130 \\times 10^{-3} \\ \\mathrm{mol} \\cdot \\mathrm{m}^{-3}) \\times (0.085 \\times 10^{-12} \\ \\mathrm{m}^{2}) \\times (38 \\times 10^{-9} \\ \\mathrm{m}) \\times (6.022 \\times 10^{23} \\ \\mathrm{mol}^{-1})$$\n\n单位按预期抵消：$(\\mathrm{mol} \\cdot \\mathrm{m}^{-3}) \\cdot \\mathrm{m}^{2} \\cdot \\mathrm{m} \\cdot \\mathrm{mol}^{-1} = 1$，得到 $N$ 的一个无量纲计数。\n\n现在我们计算数值：\n$$N = (130)(0.085)(38)(6.022) \\times 10^{(-3 - 12 - 9 + 23)}$$\n$$N = (130 \\times 0.085 \\times 38 \\times 6.022) \\times 10^{-1}$$\n系数的乘积是：\n$$130 \\times 0.085 \\times 38 \\times 6.022 \\approx 2528.5578$$\n因此：\n$$N \\approx 2528.5578 \\times 10^{-1} = 252.85578$$\n题目要求最终答案四舍五入到四位有效数字。\n$$N \\approx 252.9$$\n因此，理想化的PSD中CaMKII全酶的近似数量为 $252.9$。", "answer": "$$\\boxed{252.9}$$", "id": "5075270"}, {"introduction": "了解了“玩家”的数量之后，下一步是理解它们之间相互作用的规则。PSD的功能依赖于支架蛋白和受体之间特异而动态的结合。本练习深入探讨了生化平衡的核心原理，要求你推导结合位点的占据分数，并进一步模拟一个更真实的情景——不同分子竞争同一个支架蛋白 [@problem_id:5075271]。这项技能对于预测在不同条件下哪些信号通路将被激活至关重要。", "problem": "在树突棘中，突触后致密区（PSD）通过诸如突触后致密区蛋白95（PSD-95）之类的脚手架蛋白来组织谷氨酸受体。PSD-95 包含 PDZ 结构域（以 PSD-95、Discs large、Zonula occludens-1 命名），这些结构域与膜蛋白和辅助亚基的短 C-末端基序结合，以稳定突触处的受体复合物。将 PSD-95 的第一个 PDZ 结构域（PDZ1）视为一个单一的结合口袋，一次只能被一个配体占据。\n\n从质量作用定律和解离常数的定义出发，推导在稳态下单个配体 $L$ 对 PDZ1 的分数占据率。然后，将您的推导推广到两种不同配体 $L_{1}$ 和 $L_{2}$ 竞争同一 PDZ1 位点的情况，它们的解离常数分别为 $K_{d1}$ 和 $K_{d2}$，游离配体浓度分别为 $[L_{1}]$ 和 $[L_{2}]$。假设受体为单一位点，$L_{1}$ 和 $L_{2}$ 的结合是相互排斥的，达到快速平衡，并且没有协同效应。\n\n最后，根据以下反映突触后致密区附近胞质浓度的生理学合理参数，评估竞争性占据情况：$K_{d1} = 2\\,\\mu\\mathrm{M}$，$K_{d2} = 10\\,\\mu\\mathrm{M}$，$ [L_{1}] = 5\\,\\mu\\mathrm{M}$，以及 $[L_{2}] = 20\\,\\mu\\mathrm{M}$。报告配体 $L_{1}$ 和 $L_{2}$ 的分数占据率的数值，分别表示为 $\\,\\theta_{1}\\,$ 和 $\\,\\theta_{2}\\,$。\n\n将您的数值答案四舍五入到 $4$ 位有效数字。将最终的分数占据率表示为无单位的小数（最终报告的数字中不含单位）。", "solution": "该问题被评估为具有科学依据、问题明确且客观。它基于化学动力学和受体理论的基本原理，提供了一套完整且一致的信息。因此，有必要给出完整解答。\n\n推导过程分三部分进行：首先，单个配体的分数占据率；其次，推广到两种竞争性配体的情况；第三，数值计算。\n\n第一部分：单个配体的分数占据率\n\n设 $P$ 代表游离的 PDZ1 结合位点，$L$ 为配体。配体与位点的结合是一个达到平衡的可逆反应：\n$$ P + L \\rightleftharpoons PL $$\n其中 $PL$ 是配体-结合复合物。\n\n质量作用定律指出，在平衡状态下，产物浓度乘积与反应物浓度乘积之比为一个常数。对于复合物 $PL$ 的解离，这个常数就是解离常数 $K_d$：\n$$ K_d = \\frac{[P][L]}{[PL]} $$\n其中 $[P]$、$ [L]$ 和 $[PL]$ 分别是平衡时游离结合位点、游离配体和复合物的摩尔浓度。\n\n分数占据率 $\\theta$ 定义为被配体占据的结合位点占总结合位点的比例。总结合位点浓度 $[P]_{total}$ 是游离位点和被占据位点之和：\n$$ [P]_{total} = [P] + [PL] $$\n那么分数占据率为：\n$$ \\theta = \\frac{[PL]}{[P]_{total}} = \\frac{[PL]}{[P] + [PL]} $$\n为了用游离配体浓度 $[L]$ 和解离常数 $K_d$ 来表示 $\\theta$，我们首先重排 $K_d$ 的表达式以求解 $[P]$：\n$$ [P] = K_d \\frac{[PL]}{[L]} $$\n将这个 $[P]$ 的表达式代入 $\\theta$ 的方程中：\n$$ \\theta = \\frac{[PL]}{K_d \\frac{[PL]}{[L]} + [PL]} $$\n我们可以从分母中提出公因子 $[PL]$：\n$$ \\theta = \\frac{[PL]}{[PL] \\left( \\frac{K_d}{[L]} + 1 \\right)} = \\frac{1}{\\frac{K_d}{[L]} + 1} $$\n分子和分母同乘以 $[L]$，得到单个配体分数占据率的最终表达式：\n$$ \\theta = \\frac{[L]}{K_d + [L]} $$\n\n第二部分：推广到两种竞争性配体\n\n现在，考虑两种不同的配体 $L_1$ 和 $L_2$ 竞争同一个结合位点 $P$。它们的结合是相互排斥的。我们有两个同步的平衡：\n$$ P + L_1 \\rightleftharpoons PL_1 \\quad \\text{解离常数为} \\quad K_{d1} = \\frac{[P][L_1]}{[PL_1]} $$\n$$ P + L_2 \\rightleftharpoons PL_2 \\quad \\text{解离常数为} \\quad K_{d2} = \\frac{[P][L_2]}{[PL_2]} $$\n现在总结合位点浓度包括了被任一配体结合的位点：\n$$ [P]_{total} = [P] + [PL_1] + [PL_2] $$\n每种配体的分数占据率 $\\theta_1$ 和 $\\theta_2$ 定义为：\n$$ \\theta_1 = \\frac{[PL_1]}{[P]_{total}} \\quad \\text{和} \\quad \\theta_2 = \\frac{[PL_2]}{[P]_{total}} $$\n我们将复合物的浓度 $[PL_1]$ 和 $[PL_2]$ 用游离受体浓度 $[P]$ 和各自的配体浓度表示：\n$$ [PL_1] = \\frac{[P][L_1]}{K_{d1}} $$\n$$ [PL_2] = \\frac{[P][L_2]}{K_{d2}} $$\n将这些代入 $[P]_{total}$ 的方程中：\n$$ [P]_{total} = [P] + \\frac{[P][L_1]}{K_{d1}} + \\frac{[P][L_2]}{K_{d2}} $$\n提出公因子 $[P]$：\n$$ [P]_{total} = [P] \\left( 1 + \\frac{[L_1]}{K_{d1}} + \\frac{[L_2]}{K_{d2}} \\right) $$\n现在，我们可以推导 $\\theta_1$ 的表达式：\n$$ \\theta_1 = \\frac{[PL_1]}{[P]_{total}} = \\frac{\\frac{[P][L_1]}{K_{d1}}}{[P] \\left( 1 + \\frac{[L_1]}{K_{d1}} + \\frac{[L_2]}{K_{d2}} \\right)} = \\frac{\\frac{[L_1]}{K_{d1}}}{1 + \\frac{[L_1]}{K_{d1}} + \\frac{[L_2]}{K_{d2}}} $$\n同理，对于 $\\theta_2$：\n$$ \\theta_2 = \\frac{[PL_2]}{[P]_{total}} = \\frac{\\frac{[P][L_2]}{K_{d2}}}{[P] \\left( 1 + \\frac{[L_1]}{K_{d1}} + \\frac{[L_2]}{K_{d2}} \\right)} = \\frac{\\frac{[L_2]}{K_{d2}}}{1 + \\frac{[L_1]}{K_{d1}} + \\frac{[L_2]}{K_{d2}}} $$\n这些是在单一位点上竞争性结合的一般方程。\n\n第三部分：数值计算\n\n问题提供了以下参数：\n$K_{d1} = 2\\,\\mu\\mathrm{M}$\n$K_{d2} = 10\\,\\mu\\mathrm{M}$\n$[L_1] = 5\\,\\mu\\mathrm{M}$\n$[L_2] = 20\\,\\mu\\mathrm{M}$\n\n首先，我们计算浓度与解离常数的无量纲比率：\n$$ \\frac{[L_1]}{K_{d1}} = \\frac{5\\,\\mu\\mathrm{M}}{2\\,\\mu\\mathrm{M}} = 2.5 $$\n$$ \\frac{[L_2]}{K_{d2}} = \\frac{20\\,\\mu\\mathrm{M}}{10\\,\\mu\\mathrm{M}} = 2 $$\n接下来，我们计算从 $\\theta_1$ 和 $\\theta_2$ 的推导表达式中得到的公分母项 $D$：\n$$ D = 1 + \\frac{[L_1]}{K_{d1}} + \\frac{[L_2]}{K_{d2}} = 1 + 2.5 + 2 = 5.5 $$\n现在，我们可以计算分数占据率 $\\theta_1$ 和 $\\theta_2$：\n$$ \\theta_1 = \\frac{\\frac{[L_1]}{K_{d1}}}{D} = \\frac{2.5}{5.5} = \\frac{25}{55} = \\frac{5}{11} \\approx 0.454545... $$\n$$ \\theta_2 = \\frac{\\frac{[L_2]}{K_{d2}}}{D} = \\frac{2}{5.5} = \\frac{20}{55} = \\frac{4}{11} \\approx 0.363636... $$\n根据要求将这些值四舍五入到 4 位有效数字：\n$$ \\theta_1 \\approx 0.4545 $$\n$$ \\theta_2 \\approx 0.3636 $$\n这些值分别表示在给定条件下，被配体 $L_1$ 和 $L_2$ 占据的 PDZ1 结构域的比例。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4545  0.3636\n\\end{pmatrix}\n}\n$$", "id": "5075271"}, {"introduction": "最后，我们从单个的相互作用转向整个系统的行为。PSD不仅仅是蛋白质的随机集合，它是一个高度组织化的网络，其相互作用产生了新的功能特性。最后一个练习将挑战你构建一个PSD相互作用网络的计算模型，利用图论原理来量化分子缺陷（如疾病中）如何能被治疗策略所补偿 [@problem_id:5075231]。这个练习展示了定量建模如何为理解突触健康与疾病提供强有力的见解。", "problem": "您需要形式化并计算一个有原则的拯救方案，其中Homer支架蛋白的过表达可以补偿突触后致密区（PSD）内Shank的缺陷，并预测网络中心性的恢复和功能结果。突触后致密区（PSD）被建模为一个小型蛋白质相互作用网络，包含以下节点：PSD95、Shank、Homer、代谢型谷氨酸受体（mGluR）、α-氨基-3-羟基-5-甲基-4-异恶唑丙酸受体（AMPAR）和N-甲基-D-天冬氨酸受体（NMDAR）。您的任务是实现一个程序，为健康、缺陷和拯救三种状态构建加权邻接矩阵，并基于平衡结合和图论中心性计算量化的恢复指标。\n\n从以下基本原理开始：\n\n- 平衡结合占有率：如果两种蛋白质 $A$ 和 $B$ 以有效解离常数 $K_d$ 相互作用，且它们的归一化丰度分别为 $[A]$ 和 $[B]$，则被占据结合位点的分数（有效相互作用权重的前体）可建模为\n$$\nf_{AB} = \\frac{[A]\\,[B]}{[A]\\,[B] + K_d}.\n$$\n这个饱和函数随 $[A]\\,[B]$ 的增加而增加，随 $K_d$ 的增加而减少，这与在质量作用平衡和有限结合位点可用性条件下经过充分验证的结合模型一致。\n\n- 加权邻接：对于相互作用 $A$–$B$，定义边权重\n$$\nw_{AB} = \\alpha_{AB}\\, f_{AB},\n$$\n其中 $\\alpha_{AB} \\in (0,1]$ 量化了在完全占有情况下的最大有效相互作用强度。使用以下常数：\n$ \\alpha_{\\text{PSD95,Shank}} = 0.8$, $ \\alpha_{\\text{Shank,Homer}} = 0.7$, $ \\alpha_{\\text{Homer,mGluR}} = 0.6$, $ \\alpha_{\\text{PSD95,AMPAR}} = 0.9$, $ \\alpha_{\\text{PSD95,NMDAR}} = 0.85$。\n假设除Shank和Homer外的所有节点在所有状态下都具有固定的归一化丰度 $[X] = 1.0$。在缺陷状态下，Shank丰度 $[{\\text{Shank}}]$ 降低至健康状态的一部分 $s$（$s \\in [0,1]$）；在拯救状态下，Homer丰度 $[{\\text{Homer}}]$ 相对于健康状态增加一个过表达因子 $r_H$（$r_H \\ge 1$）。在健康状态下，$[ {\\text{Shank}} ] = 1.0$ 且 $[ {\\text{Homer}} ] = 1.0$。\n\n- 图表示：在节点顺序 $\\{\\text{PSD95}, \\text{Shank}, \\text{Homer}, \\text{mGluR}, \\text{AMPAR}, \\text{NMDAR}\\}$ 上构建一个对称加权邻接矩阵 $\\mathbf{A} \\in \\mathbb{R}^{6 \\times 6}$，其中以下配对具有非零无向边：PSD95–Shank、Shank–Homer、Homer–mGluR、PSD95–AMPAR、PSD95–NMDAR。所有其他边均为零。\n\n- 网络中心性：将特征向量中心性定义为 $\\mathbf{A}$ 的归一化主特征向量。如果 $\\lambda_{\\max}$ 是 $\\mathbf{A}$ 的最大特征值，$\\mathbf{v}$ 是对应的特征向量，则将 $\\mathbf{v}$ 归一化，使其 $\\ell_1$ 范数等于 $1$，即 $\\sum_i |v_i| = 1$。这为每个节点提供了一个无量纲的中心性度量。\n\n- 功能结果指标：将AMPAR锚定指数定义为\n$$\nI_{\\text{AMPAR}} = w_{\\text{PSD95,AMPAR}} \\cdot v_{\\text{PSD95}},\n$$\n其中 $v_{\\text{PSD95}}$ 是PSD95的中心性。\n\n对于每个测试用例，执行以下步骤：\n1. 使用 $[{\\text{Shank}}] = 1.0$ 和 $[{\\text{Homer}}] = 1.0$ 以及提供的 $K_d$ 值构建健康状态的邻接矩阵 $\\mathbf{A}_{\\text{healthy}}$。\n2. 使用 $[{\\text{Shank}}] = s$ 和 $[{\\text{Homer}}] = 1.0$ 以及相同的 $K_d$ 值构建缺陷状态的邻接矩阵 $\\mathbf{A}_{\\text{deficit}}$。\n3. 使用 $[{\\text{Shank}}] = s$ 和 $[{\\text{Homer}}] = r_H$ 以及相同的 $K_d$ 值构建拯救状态的邻接矩阵 $\\mathbf{A}_{\\text{rescue}}$。\n4. 计算健康和拯救状态的特征向量中心性，并提取两种状态下的 $v_{\\text{mGluR}}$ 和 $v_{\\text{PSD95}}$。\n5. 计算恢复指标：\n   - mGluR的网络中心性恢复：\n   $$\n   R_{\\text{mGluR}} = \\frac{v_{\\text{mGluR, rescue}}}{v_{\\text{mGluR, healthy}}}.\n   $$\n   - 功能结果恢复（AMPAR锚定）：\n   $$\n   R_{\\text{AMPAR}} = \\frac{I_{\\text{AMPAR, rescue}}}{I_{\\text{AMPAR, healthy}}}\n   = \\frac{w_{\\text{PSD95,AMPAR, rescue}} \\cdot v_{\\text{PSD95, rescue}}}{w_{\\text{PSD95,AMPAR, healthy}} \\cdot v_{\\text{PSD95, healthy}}}.\n   $$\n两个指标都是无量纲的，并且必须以浮点数形式报告。\n\n使用以下参数集测试套件 $(s, r_H, K_{d,\\text{Shank,Homer}}, K_{d,\\text{PSD95,Shank}}, K_{d,\\text{Homer,mGluR}}, K_{d,\\text{PSD95,AMPAR}}, K_{d,\\text{PSD95,NMDAR}})$：\n- 情况 $1$ (理想情况): $(0.5, 2.5, 0.2, 0.3, 0.4, 0.15, 0.2)$。\n- 情况 $2$ (严重缺陷): $(0.1, 3.0, 0.2, 0.3, 0.4, 0.15, 0.2)$。\n- 情况 $3$ (边界情况，Shank为零): $(0.0, 5.0, 0.2, 0.3, 0.4, 0.15, 0.2)$。\n- 情况 $4$ (Shank–Homer亲和力弱): $(0.5, 3.0, 5.0, 0.3, 0.4, 0.15, 0.2)$。\n- 情况 $5$ (Homer–mGluR亲和力强): $(0.3, 4.0, 0.2, 0.3, 0.01, 0.15, 0.2)$。\n\n答案要求：\n- 所有输出均为无量纲浮点数。\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。其中每个测试用例贡献一个双元素列表 $[R_{\\text{mGluR}}, R_{\\text{AMPAR}}]$，每个值四舍五入到六位小数。例如，您的输出必须看起来像\n$[[0.123456,0.234567],[0.345678,0.456789],\\dots]$\n不带任何附加文本。", "solution": "问题陈述已经过严格审查并被确定为有效。其科学基础植根于神经生物学和网络科学的既定原则，在数学上是适定的，并且陈述客观且无歧义。所有必要的参数和定义都已提供，以构建一个唯一的、确定性的解决方案。该模型虽然是对突触后致密区（PSD）生物学现实的简化，但代表了用于计算研究的标准且适当的形式化方法。\n\n解决方案如下。我们将PSD建模为一个蛋白质相互作用网络，由一个加权无向图表示。图的节点是六种指定的蛋白质，边代表直接的物理相互作用。\n\n节点按指定顺序索引：\n$0$: PSD95\n$1$: Shank\n$2$: Homer\n$3$: mGluR (代谢型谷氨酸受体)\n$4$: AMPAR (α-氨基-3-羟基-5-甲基-4-异恶唑丙酸受体)\n$5$: NMDAR (N-甲基-D-天冬氨酸受体)\n\n网络模型由一个 $6 \\times 6$ 的对称加权邻接矩阵 $\\mathbf{A}$ 表示，其中条目 $A_{ij} = w_{ij}$ 是节点 $i$ 和节点 $j$ 之间边的权重。边权重仅对指定的相互作用对非零：PSD95–Shank ($w_{01}$)、Shank–Homer ($w_{12}$)、Homer–mGluR ($w_{23}$)、PSD95–AMPAR ($w_{04}$) 和 PSD95–NMDAR ($w_{05}$)。所有其他权重均为零。\n\n两种蛋白质 $A$ 和 $B$ 之间的边权重 $w_{AB}$ 基于平衡结合原理计算。它是一个最大相互作用强度 $\\alpha_{AB}$ 和一个分数占有率项 $f_{AB}$ 的乘积：\n$$\nw_{AB} = \\alpha_{AB} \\, f_{AB}\n$$\n分数占有率 $f_{AB}$ 使用一个饱和函数建模，该函数依赖于相互作用蛋白质的归一化丰度 $[A]$ 和 $[B]$，以及它们的有效解离常数 $K_d$：\n$$\nf_{AB} = \\frac{[A]\\,[B]}{[A]\\,[B] + K_d}\n$$\n对于每个测试用例，我们必须为两种状态构建邻接矩阵：“健康”和“拯救”。每种状态的丰度 $[X]$ 定义如下：\n- 健康状态：$[\\text{Shank}] = 1.0$, $[\\text{Homer}] = 1.0$。\n- 拯救状态：$[\\text{Shank}] = s$, $[\\text{Homer}] = r_H$，其中 $s$ 和 $r_H$ 是给定参数。\n- 对于所有其他蛋白质（PSD95、mGluR、AMPAR、NMDAR），在所有状态下丰度固定为 $[X] = 1.0$。\n\n分析的核心是计算网络中每个节点的特征向量中心性。对于给定的邻接矩阵 $\\mathbf{A}$，我们找到其最大特征值 $\\lambda_{\\max}$ 和相应的特征向量 $\\mathbf{v}$（主特征向量）。根据佩伦-弗罗贝尼乌斯定理（Perron-Frobenius theorem），对于我们这个具有非负权重的连通网络，可以选择该特征向量使其所有条目均为非负。然后将其归一化，使其 $\\ell_1$ 范数为 $1$：\n$$\n\\mathbf{v}_{\\text{centrality}} = \\frac{|\\mathbf{v}|}{\\sum_i |v_i|}\n$$\n该向量提供了每个节点在网络中影响力的相对度量。设 $\\mathbf{v}_{\\text{healthy}}$ 和 $\\mathbf{v}_{\\text{rescue}}$ 分别为健康状态和拯救状态的中心性向量。\n\n然后我们计算两个恢复指标：\n1.  **mGluR中心性恢复 ($R_{\\text{mGluR}}$)**：该指标量化了Homer过表达对mGluR节点中心性的恢复程度。它是拯救状态下mGluR的中心性与健康状态下其中心性的比率。鉴于mGluR是节点 $3$：\n$$\nR_{\\text{mGluR}} = \\frac{v_{\\text{mGluR, rescue}}}{v_{\\text{mGluR, healthy}}} = \\frac{(\\mathbf{v}_{\\text{rescue}})_3}{(\\mathbf{v}_{\\text{healthy}})_3}\n$$\n\n2.  **AMPAR锚定恢复 ($R_{\\text{AMPAR}}$)**：该指标作为一个关键突触功能（即AMPA受体在突触处的稳定）的代表指标。它通过AMPAR锚定指数 $I_{\\text{AMPAR}} = w_{\\text{PSD95,AMPAR}} \\cdot v_{\\text{PSD95}}$ 定义。恢复率是该指数在拯救状态与健康状态下的比率。鉴于PSD95是节点 $0$：\n$$\nR_{\\text{AMPAR}} = \\frac{I_{\\text{AMPAR, rescue}}}{I_{\\text{AMPAR, healthy}}} = \\frac{w_{\\text{PSD95,AMPAR, rescue}} \\cdot v_{\\text{PSD95, rescue}}}{w_{\\text{PSD95,AMPAR, healthy}} \\cdot v_{\\text{PSD95, healthy}}}\n$$\n值得注意的是，PSD95和AMPAR的丰度在所有状态下都是恒定的（$[A]=1.0$, $[B]=1.0$）。因此，对于任何给定的测试用例，权重项 $w_{\\text{PSD95,AMPAR}}$ 在健康和拯救状态下是相同的。公式简化为：\n$$\nR_{\\text{AMPAR}} = \\frac{v_{\\text{PSD95, rescue}}}{v_{\\text{PSD95, healthy}}} = \\frac{(\\mathbf{v}_{\\text{rescue}})_0}{(\\mathbf{v}_{\\text{healthy}})_0}\n$$\n虽然这种简化是有效的，但为了最大程度地保证忠实度，实现将遵循问题的明确定义。\n\n每个测试用例的总体算法是：\n1.  为健康状态定义蛋白质丰度。计算所有非零权重并构建 $\\mathbf{A}_{\\text{healthy}}$。计算中心性向量 $\\mathbf{v}_{\\text{healthy}}$。\n2.  使用给定的 $s$ 和 $r_H$ 为拯救状态定义蛋白质丰度。计算所有非零权重并构建 $\\mathbf{A}_{\\text{rescue}}$。计算中心性向量 $\\mathbf{v}_{\\text{rescue}}$。\n3.  使用中心性向量和相关权重计算 $R_{\\text{mGluR}}$ 和 $R_{\\text{AMPAR}}$。\n4.  将结果格式化为四舍五入到六位小数的双元素列表。\n\n此过程被系统地应用于所有提供的测试用例，以生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes restoration metrics for a neurobiological model of the Postsynaptic Density (PSD).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Format: (s, r_H, Kd_Shank_Homer, Kd_PSD95_Shank, Kd_Homer_mGluR, Kd_PSD95_AMPAR, Kd_PSD95_NMDAR)\n    test_cases = [\n        (0.5, 2.5, 0.2, 0.3, 0.4, 0.15, 0.2),   # Case 1\n        (0.1, 3.0, 0.2, 0.3, 0.4, 0.15, 0.2),   # Case 2\n        (0.0, 5.0, 0.2, 0.3, 0.4, 0.15, 0.2),   # Case 3\n        (0.5, 3.0, 5.0, 0.3, 0.4, 0.15, 0.2),   # Case 4\n        (0.3, 4.0, 0.2, 0.3, 0.01, 0.15, 0.2),  # Case 5\n    ]\n\n    # Constants and network structure\n    node_map = {'PSD95': 0, 'Shank': 1, 'Homer': 2, 'mGluR': 3, 'AMPAR': 4, 'NMDAR': 5}\n    alphas = {\n        ('PSD95', 'Shank'): 0.8,\n        ('Shank', 'Homer'): 0.7,\n        ('Homer', 'mGluR'): 0.6,\n        ('PSD95', 'AMPAR'): 0.9,\n        ('PSD95', 'NMDAR'): 0.85,\n    }\n\n    def calculate_weight(conc_A, conc_B, kd, alpha):\n        \"\"\"Calculates the edge weight based on protein concentrations and binding constants.\"\"\"\n        if kd  0:\n            raise ValueError(\"Kd must be non-negative.\")\n        product = conc_A * conc_B\n        f_ab = product / (product + kd)\n        return alpha * f_ab\n\n    def get_centrality_vector(abundances, kds, alphas, node_map):\n        \"\"\"Constructs the adjacency matrix and computes the eigenvector centrality vector.\"\"\"\n        num_nodes = len(node_map)\n        adj_matrix = np.zeros((num_nodes, num_nodes))\n\n        # Unpack parameters\n        kd_ps, kd_sh, kd_hm, kd_pa, kd_pn = kds['PSD95_Shank'], kds['Shank_Homer'], kds['Homer_mGluR'], kds['PSD95_AMPAR'], kds['PSD95_NMDAR']\n\n        # Calculate weights and populate the adjacency matrix\n        weights = {}\n        weights['w_ps'] = calculate_weight(abundances['PSD95'], abundances['Shank'], kd_ps, alphas[('PSD95', 'Shank')])\n        weights['w_sh'] = calculate_weight(abundances['Shank'], abundances['Homer'], kd_sh, alphas[('Shank', 'Homer')])\n        weights['w_hm'] = calculate_weight(abundances['Homer'], abundances['mGluR'], kd_hm, alphas[('Homer', 'mGluR')])\n        weights['w_pa'] = calculate_weight(abundances['PSD95'], abundances['AMPAR'], kd_pa, alphas[('PSD95', 'AMPAR')])\n        weights['w_pn'] = calculate_weight(abundances['PSD95'], abundances['NMDAR'], kd_pn, alphas[('PSD95', 'NMDAR')])\n\n        # Indices from node_map\n        i_p, i_s, i_h, i_m, i_a, i_n = node_map['PSD95'], node_map['Shank'], node_map['Homer'], node_map['mGluR'], node_map['AMPAR'], node_map['NMDAR']\n        \n        # Populate symmetric matrix\n        adj_matrix[i_p, i_s] = adj_matrix[i_s, i_p] = weights['w_ps']\n        adj_matrix[i_s, i_h] = adj_matrix[i_h, i_s] = weights['w_sh']\n        adj_matrix[i_h, i_m] = adj_matrix[i_m, i_h] = weights['w_hm']\n        adj_matrix[i_p, i_a] = adj_matrix[i_a, i_p] = weights['w_pa']\n        adj_matrix[i_p, i_n] = adj_matrix[i_n, i_p] = weights['w_pn']\n        \n        # Compute eigenvector centrality\n        eigenvalues, eigenvectors = np.linalg.eig(adj_matrix)\n        # Eigenvalues of a real symmetric matrix are real, but numpy might return complex type.\n        eigenvalues = np.real(eigenvalues)\n        \n        # Find principal eigenvector (corresponding to the largest eigenvalue)\n        max_eig_idx = np.argmax(eigenvalues)\n        principal_ev = eigenvectors[:, max_eig_idx]\n        principal_ev = np.real(principal_ev)\n\n        # Normalize with L1 norm (sum of absolute values)\n        # The principal eigenvector of a non-negative matrix can be chosen to be non-negative.\n        principal_ev_abs = np.abs(principal_ev)\n        l1_norm = np.sum(principal_ev_abs)\n\n        if l1_norm == 0:\n            return np.zeros(num_nodes), 0.0 # Avoid division by zero for a zero matrix\n            \n        centrality = principal_ev_abs / l1_norm\n        return centrality, weights['w_pa']\n\n    results = []\n    for case in test_cases:\n        s, r_h, kd_sh, kd_ps, kd_hm, kd_pa, kd_pn = case\n        \n        kds = {\n            'Shank_Homer': kd_sh, 'PSD95_Shank': kd_ps, 'Homer_mGluR': kd_hm,\n            'PSD95_AMPAR': kd_pa, 'PSD95_NMDAR': kd_pn\n        }\n\n        # Healthy state\n        healthy_abundances = {\n            'PSD95': 1.0, 'Shank': 1.0, 'Homer': 1.0, 'mGluR': 1.0, 'AMPAR': 1.0, 'NMDAR': 1.0\n        }\n        v_healthy, w_pa_healthy = get_centrality_vector(healthy_abundances, kds, alphas, node_map)\n\n        # Rescue state\n        rescue_abundances = {\n            'PSD95': 1.0, 'Shank': s, 'Homer': r_h, 'mGluR': 1.0, 'AMPAR': 1.0, 'NMDAR': 1.0\n        }\n        v_rescue, w_pa_rescue = get_centrality_vector(rescue_abundances, kds, alphas, node_map)\n\n        # Calculate metrics\n        v_mglur_healthy = v_healthy[node_map['mGluR']]\n        v_mglur_rescue = v_rescue[node_map['mGluR']]\n        # Avoid division by zero if healthy centrality is zero\n        R_mGluR = v_mglur_rescue / v_mglur_healthy if v_mglur_healthy > 0 else 0.0\n\n        I_ampar_healthy = w_pa_healthy * v_healthy[node_map['PSD95']]\n        I_ampar_rescue = w_pa_rescue * v_rescue[node_map['PSD95']]\n        # Avoid division by zero if healthy index is zero\n        R_AMPAR = I_ampar_rescue / I_ampar_healthy if I_ampar_healthy > 0 else 0.0\n        \n        results.append(f\"[{R_mGluR:.6f},{R_AMPAR:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[[{','.join(results)}]]\")\n\nsolve()\n```", "id": "5075231"}]}