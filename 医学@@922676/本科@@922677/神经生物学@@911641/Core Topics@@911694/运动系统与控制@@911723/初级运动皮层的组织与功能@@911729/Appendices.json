{"hands_on_practices": [{"introduction": "初级运动皮层（M1）的功能始于其基本计算单元——神经元。本练习将一个关键的 M1 输出神经元，即 Betz 细胞，建模为一个简单的电阻-电容（$RC$）电路，以探索它如何整合输入电流。通过这个模型，你将计算神经元在接收到恒定刺激后达到发放动作电位阈值所需的时间，从而深入理解神经元积分和发放的基本机制。[@problem_id:5049102]", "problem": "贝茨细胞（Betz cell）是初级运动皮层（M1）中一个大型的第五层皮层脊髓神经元，其胞体膜可以近似为一个电阻-电容元件。考虑一个贝茨细胞，其相对于静息电位的膜电位 $V(t)$ 在从 $t=0$ 开始的恒定细胞内阶跃电流 $I$ 的作用下，根据电容器上的电荷守恒和欧姆定律演变：$C \\frac{dV}{dt} + \\frac{V}{R} = I$，对于 $t \\ge 0$，初始条件为 $V(0)=0$。这里 $C$ 是膜电容，$R$ 是输入电阻，$I$ 是注入电流。高于静息电位的发放阈值为 $V_{\\text{th}}$。\n\n仅使用这些基本关系，推导膜电位首次达到阈值的时间 $t_{\\text{th}}$ 的表达式，该时间由 $V(t_{\\text{th}})=V_{\\text{th}}$ 定义。然后，对于一个贝茨细胞，其参数为 $I = 1.0 \\times 10^{-9}\\,\\text{A}$，$R = 50 \\times 10^{6}\\,\\Omega$，$C = 5.0 \\times 10^{-10}\\,\\text{F}$，以及 $V_{\\text{th}} = 15 \\times 10^{-3}\\,\\text{V}$，计算 $t_{\\text{th}}$ 的数值。假设 $I R > V_{\\text{th}}$，以便能够达到阈值。以毫秒为单位表示你的最终时间，并将数值结果四舍五入到四位有效数字。最后，利用你推导的表达式，定性解释增加 $C$ 如何影响这类神经元发放起始的时间精度。", "solution": "问题陈述经评估是有效的。它在科学上基于电路理论原理，并应用于一个标准的、简化的神经元模型（漏放电积分模型）。问题是适定的，包含一个带初始条件的一阶线性常微分方程，这保证了唯一解的存在。所有参数都已定义，所提供的数值对于一个大型神经元来说在物理上是现实的。条件 $I R > V_{\\text{th}}$ 确保了阈值是可以达到的，从而使问题可解。\n\n任务是推导达到阈值的时间 $t_{\\text{th}}$，计算一个特定情况下的数值，并解释电容 $C$ 在发放时间精度中的作用。\n\n首先，我们求解膜电位 $V(t)$。控制方程是一个一阶线性常微分方程：\n$$\nC \\frac{dV}{dt} + \\frac{V}{R} = I\n$$\n我们可以将其重新排列成标准形式 $\\frac{dy}{dx} + P(x)y = Q(x)$：\n$$\n\\frac{dV}{dt} + \\frac{1}{RC}V = \\frac{I}{C}\n$$\n设膜时间常数为 $\\tau_m = RC$。方程变为：\n$$\n\\frac{dV}{dt} + \\frac{1}{\\tau_m}V = \\frac{I}{C}\n$$\n通解是齐次解 $V_h(t)$ 和特解 $V_p(t)$ 的和。\n齐次方程是 $\\frac{dV_h}{dt} + \\frac{1}{\\tau_m}V_h = 0$，其解为 $V_h(t) = A \\exp(-t/\\tau_m)$，其中 $A$ 是一个积分常数。\n对于特解，由于驱动项 $I/C$ 是一个常数，我们假设一个常数解 $V_p(t) = K$。将其代入完整的常微分方程得到：\n$$\n0 + \\frac{K}{\\tau_m} = \\frac{I}{C} \\implies K = \\frac{I\\tau_m}{C} = \\frac{I(RC)}{C} = IR\n$$\n所以，特解是 $V_p(t) = IR$。\n膜电位的通解是齐次解和特解的和：\n$$\nV(t) = V_h(t) + V_p(t) = A \\exp(-t/\\tau_m) + IR\n$$\n我们使用初始条件 $V(0)=0$ 来确定常数 $A$：\n$$\nV(0) = A \\exp(0) + IR = A + IR = 0 \\implies A = -IR\n$$\n将 $A$ 代回通解，得到膜电位随时间变化的特解：\n$$\nV(t) = IR - IR \\exp(-t/\\tau_m) = IR \\left(1 - \\exp\\left(-\\frac{t}{RC}\\right)\\right)\n$$\n这个方程描述了膜电容向稳态电压 $IR$ 充电的过程。\n\n接下来，我们推导达到阈值的时间 $t_{\\text{th}}$ 的表达式。这是 $V(t)$ 首次达到阈值电位 $V_{\\text{th}}$ 的时间。我们设 $V(t_{\\text{th}}) = V_{\\text{th}}$ 并求解 $t_{\\text{th}}$：\n$$\nV_{\\text{th}} = IR \\left(1 - \\exp\\left(-\\frac{t_{\\text{th}}}{RC}\\right)\\right)\n$$\n问题陈述中提到 $IR > V_{\\text{th}}$，这确保了 $0  V_{\\text{th}}/(IR)  1$，从而保证 $t_{\\text{th}}$ 有一个实数正解。\n我们重新整理方程以求解 $t_{\\text{th}}$：\n$$\n\\frac{V_{\\text{th}}}{IR} = 1 - \\exp\\left(-\\frac{t_{\\text{th}}}{RC}\\right)\n$$\n$$\n\\exp\\left(-\\frac{t_{\\text{th}}}{RC}\\right) = 1 - \\frac{V_{\\text{th}}}{IR}\n$$\n对两边取自然对数：\n$$\n-\\frac{t_{\\text{th}}}{RC} = \\ln\\left(1 - \\frac{V_{\\text{th}}}{IR}\\right)\n$$\n最后，求解 $t_{\\text{th}}$ 得到符号表达式：\n$$\nt_{\\text{th}} = -RC \\ln\\left(1 - \\frac{V_{\\text{th}}}{IR}\\right)\n$$\n现在，我们使用给定的参数计算 $t_{\\text{th}}$ 的数值：\n$I = 1.0 \\times 10^{-9}\\,\\text{A}$\n$R = 50 \\times 10^{6}\\,\\Omega$\n$C = 5.0 \\times 10^{-10}\\,\\text{F}$\n$V_{\\text{th}} = 15 \\times 10^{-3}\\,\\text{V}$\n\n首先，我们用国际单位制计算乘积项：\n时间常数 $\\tau_m = RC$：\n$$\n\\tau_m = (50 \\times 10^{6}\\,\\Omega) \\times (5.0 \\times 10^{-10}\\,\\text{F}) = 250 \\times 10^{-4}\\,\\text{s} = 0.025\\,\\text{s}\n$$\n稳态电压 $V_{\\infty} = IR$：\n$$\nV_{\\infty} = (1.0 \\times 10^{-9}\\,\\text{A}) \\times (50 \\times 10^{6}\\,\\Omega) = 50 \\times 10^{-3}\\,\\text{V} = 0.050\\,\\text{V}\n$$\n无量纲比值 $V_{\\text{th}}/(IR)$：\n$$\n\\frac{V_{\\text{th}}}{IR} = \\frac{15 \\times 10^{-3}\\,\\text{V}}{50 \\times 10^{-3}\\,\\text{V}} = 0.3\n$$\n现在，我们将这些值代入 $t_{\\text{th}}$ 的表达式中：\n$$\nt_{\\text{th}} = -(0.025\\,\\text{s}) \\ln(1 - 0.3) = -(0.025\\,\\text{s}) \\ln(0.7)\n$$\n使用值 $\\ln(0.7) \\approx -0.3566749$：\n$$\nt_{\\text{th}} \\approx -(0.025\\,\\text{s}) \\times (-0.3566749) \\approx 0.00891687\\,\\text{s}\n$$\n问题要求答案以毫秒为单位，并四舍五入到四位有效数字：\n$$\nt_{\\text{th}} \\approx 8.917 \\times 10^{-3}\\,\\text{s} = 8.917\\,\\text{ms}\n$$\n\n最后，我们定性地解释增加 $C$ 如何影响发放起始的时间精度。时间精度指的是在存在噪声的情况下发放时间的可靠性。较低的精度意味着在给定噪声水平下，发放时间的方差更大。\n我们推导的表达式 $t_{\\text{th}} = -RC \\ln(1 - V_{\\text{th}}/IR)$ 表明 $t_{\\text{th}}$ 与 $C$ 成正比。因此，增加电容会增加达到阈值所需的时间。神经元成为其输入电流的“更慢”的积分器。\n\n要理解时间精度，我们必须考虑当膜电位接近阈值 $V_{\\text{th}}$ 时，其变化率 $\\frac{dV}{dt}$。更陡的斜率（$\\frac{dV}{dt}$ 很大）意味着电压的微小波动（由电流噪声引起）只会导致穿越阈值时间的微小变化。相反，更缓的斜率（$\\frac{dV}{dt}$ 很小）意味着同样微小的电压波动会导致发放时间的更大变化，从而降低时间精度。\n电压的变化率通过重新整理原始的常微分方程得到：\n$$\n\\frac{dV}{dt} = \\frac{1}{C}\\left(I - \\frac{V}{R}\\right) = \\frac{IR - V}{RC}\n$$\n当电位达到阈值 $V=V_{\\text{th}}$ 时，轨迹在该点的斜率为：\n$$\n\\frac{dV}{dt}\\Bigg|_{t=t_{\\text{th}}} = \\frac{IR - V_{\\text{th}}}{RC}\n$$\n从这个表达式可以看出，阈值处的电压轨迹斜率与电容 $C$ 成反比。因此，增加 $C$ 会减小斜率，使电压上升到阈值的过程更平缓。这种更平缓的轨迹意味着膜电位中的任何噪声都会在穿越阈值的确切时间 $t_{\\text{th}}$ 上引起更大的抖动或不确定性。\n总之，增加膜电容 $C$ 会使神经元通过在更长的时间窗口内平滑高频输入波动而成为一个更好的积分器，但这是以降低发放起始的时间精度为代价的。神经元的功能从“重合检测器”（低 $C$，高精度）转变为“积分器”（高 $C$，低精度）。", "answer": "$$\n\\boxed{\\begin{pmatrix} -RC \\ln\\left(1 - \\frac{V_{\\text{th}}}{IR}\\right)  8.917 \\end{pmatrix}}\n$$", "id": "5049102"}, {"introduction": "当一个 M1 神经元发放动作电位后，其信号必须沿着下降通路传递到脊髓中的运动神经元。信号传递的总时间（即潜伏期）取决于信号传播的距离和所经过的突触数量。本练习通过推导和比较单突触与双突触通路的潜伏期，让你亲身体会神经回路结构如何直接影响运动指令的传递速度。[@problem_id:5049085]", "problem": "一个始于初级运动皮层（M1）第五层皮质脊髓神经元的脉冲沿其轴突传播至脊髓，最终在α-运动神经元中引起一个兴奋性突触后电位（EPSP）。考虑两条解剖学上可能的通路：一条是单突触通路，其中皮质脊髓轴突直接与运动神经元形成突触；另一条是双突触通路，其中皮质脊髓轴突先与一个脊髓中间神经元形成突触，该中间神经元再与运动神经元形成突触。请假设以下经过充分检验的基本原理：轴突传导时间等于路径长度除以传导速度，且每个化学突触都会带来一个突触延迟。具体来说，设从M1脉冲起始点沿下行通路到运动神经元的总轴突路径长度为$L$，所有相关轴突的传导速度恒定为$v$，每个突触的突触延迟相同且等于$\\delta$。假设双突触通路中的各段轴突路径长度之和为$L$，且运动神经元内的树突传导时间与$\\delta$相比可以忽略不计。请仅使用这些基本原理，推导单突触和双突触通路的总下行延迟（从M1脉冲到运动神经元EPSP起始的时间）的表达式，然后计算双突触延迟与单突触延迟的比率$R$，并将其表示为$L$、$v$和$\\delta$的闭式函数。请将$R$的最终答案表示为解析表达式。不需要数值，最终方框内的表达式不应包含单位。", "solution": "经评估，问题陈述是有效的。它在科学上基于神经生理学原理，特别是关于神经传导和突触传递的原理。该问题提法恰当，提供了推导唯一、有意义解所需的所有变量和假设。其语言客观且精确，所用模型虽然经过简化，但却是神经通路的标准且有用的表示。陈述中没有矛盾、歧义或事实不准确之处。\n\n总下行延迟，我们记为$T$，是指从初级运动皮层（M1）神经元脉冲的起始到脊髓α-运动神经元兴奋性突触后电位（EPSP）起始所经过的时间。根据问题陈述，该延迟是两个部分的总和：总轴突传导时间（$t_{cond}$）和总突触延迟（$t_{syn}$）。\n\n轴突传导时间由公式$t_{cond} = \\frac{\\text{路径长度}}{\\text{传导速度}}$给出。总突触延迟是通路中的突触数量$N_{syn}$乘以每个突触的延迟$\\delta$。因此，延迟的一般表达式为：\n$$ T = t_{cond} + N_{syn} \\cdot \\delta $$\n\n现在我们将此通用公式应用于两种指定的通路：单突触通路和双突触通路。\n\n首先，我们分析单突触通路。\n在此通路中，皮质脊髓轴突直接与α-运动神经元形成突触。\n突触数量为$N_{syn, mono} = 1$。\n给定的总轴突路径长度为$L$。\n给定的轴突传导速度为$v$。\n因此，单突触通路的传导时间为$t_{cond, mono} = \\frac{L}{v}$。\n总突触延迟为$N_{syn, mono} \\cdot \\delta = 1 \\cdot \\delta = \\delta$。\n单突触通路的总延迟，我们记为$T_{mono}$，是这两个部分的总和：\n$$ T_{mono} = \\frac{L}{v} + \\delta $$\n\n接下来，我们分析双突触通路。\n在此通路中，皮质脊髓轴突首先与一个脊髓中间神经元形成突触，该中间神经元再与α-运动神经元形成突触。\n此通路涉及两个串联的突触。因此，突触数量为$N_{syn, di} = 2$。\n总突触延迟为$N_{syn, di} \\cdot \\delta = 2 \\cdot \\delta = 2\\delta$。\n问题陈述指出，双突触通路中的各段轴突路径长度之和为$L$。这意味着动作电位沿轴突传播的总距离是$L$。\n所有相关轴突的传导速度$v$是恒定的。\n因此，双突触通路的总传导时间为$t_{cond, di} = \\frac{L}{v}$。\n双突触通路的总延迟，我们记为$T_{di}$，是其传导时间和总突触延迟的总和：\n$$ T_{di} = \\frac{L}{v} + 2\\delta $$\n\n最后，问题要求计算双突触延迟与单突触延迟的比率$R$。\n$$ R = \\frac{T_{di}}{T_{mono}} $$\n代入推导出的$T_{di}$和$T_{mono}$的表达式：\n$$ R = \\frac{\\frac{L}{v} + 2\\delta}{\\frac{L}{v} + \\delta} $$\n此表达式即为所要求的关于$L$、$v$和$\\delta$的闭式解析函数。在没有更多信息的情况下，无法进一步简化。", "answer": "$$ \\boxed{\\frac{\\frac{L}{v} + 2\\delta}{\\frac{L}{v} + \\delta}} $$", "id": "5049085"}, {"introduction": "从单个神经元的活动扩展到群体水平，一个核心问题是 M1 神经元群体编码了何种信息：是运动的几何属性（运动学，如速度），还是产生运动所需的力（动力学，如肌肉力）？本练习让你扮演计算神经科学家的角色，通过编写代码来分析模拟的神经活动数据。你将使用一种名为“跨条件泛化”的强大回归技术，来判断在不同外部负载条件下，哪种编码模型能更好地解释神经元的活动变化。[@problem_id:5049049]", "problem": "您将执行一项基于神经生物学的计算任务，以判断在两种外部负载条件下，初级运动皮层（M1）神经元中观察到的调谐漂移是由运动学编码还是动力学编码更好地解释。人们广泛观察到，初级运动皮层（M1）表现出方向调谐性发放，这种发放可以局部地通过与手部运动学（例如速度）或动力学（例如力或力矩）的线性关系来近似。对于小范围内的线性编码模型，将发放率近似为运动相关变量的线性函数是合理的。您的程序必须通过跨条件回归泛化来实现模型比较。\n\n数学设定：\n- 令 $r^{(c)}(t)$ 表示在条件 $c \\in \\{1,2\\}$ 下，单个神经元在时间索引 $t$ 的发放率（单位：spikes/s）。\n- 令 $\\mathbf{v}^{(c)}(t) \\in \\mathbb{R}^2$ 表示平面手部速度向量（单位：cm/s）。\n- 令 $\\mathbf{F}^{(c)}(t) \\in \\mathbb{R}^2$ 表示平面手部力向量（单位：牛顿），其模型为 $\\mathbf{F}^{(c)}(t) = \\alpha \\mathbf{v}^{(c)}(t) + \\mathbf{L}^{(c)}$，其中 $\\alpha$ 是一个单位为 N/(cm/s) 的常数，$\\mathbf{L}^{(c)}$ 是条件 $c$ 下的恒定外部负载向量（单位：牛顿）。\n- 运动学模型（速度编码）：\n$$\nr^{(c)}(t) = \\beta_0^{(c)} + \\boldsymbol{\\beta}^{(c)} \\cdot \\mathbf{v}^{(c)}(t) + \\epsilon^{(c)}(t),\n$$\n其中 $\\beta_0^{(c)} \\in \\mathbb{R}$，$\\boldsymbol{\\beta}^{(c)} \\in \\mathbb{R}^2$，$\\epsilon^{(c)}(t)$ 是零均值噪声。\n- 动力学模型（力编码）：\n$$\nr^{(c)}(t) = \\gamma_0^{(c)} + \\boldsymbol{\\gamma}^{(c)} \\cdot \\mathbf{F}^{(c)}(t) + \\epsilon^{(c)}(t),\n$$\n其中 $\\gamma_0^{(c)} \\in \\mathbb{R}$，$\\boldsymbol{\\gamma}^{(c)} \\in \\mathbb{R}^2$，$\\epsilon^{(c)}(t)$ 是零均值噪声。\n\n基于回归的比较：\n- 对于给定的模型 $m \\in \\{\\text{kinematic}, \\text{kinetic}\\}$，分别为条件 1 和 2 构建设计矩阵 $\\mathbf{X}_1^{(m)}$ 和 $\\mathbf{X}_2^{(m)}$，每个矩阵包含三列：一个截距项（全为1）以及相关回归量（运动学模型为 $\\mathbf{v}$，动力学模型为 $\\mathbf{F}$）的两个分量。\n- 对于每个模型 $m$，通过在一个条件下拟合普通最小二乘法并在另一个条件下评估均方误差来计算跨条件泛化误差，并对称地取平均值：\n$$\n\\hat{\\mathbf{w}}_1^{(m)} = \\arg\\min_{\\mathbf{w}} \\lVert \\mathbf{X}_1^{(m)} \\mathbf{w} - \\mathbf{y}_1 \\rVert_2^2, \\quad \n\\hat{\\mathbf{w}}_2^{(m)} = \\arg\\min_{\\mathbf{w}} \\lVert \\mathbf{X}_2^{(m)} \\mathbf{w} - \\mathbf{y}_2 \\rVert_2^2,\n$$\n$$\n\\mathrm{MSE}_{1\\rightarrow 2}^{(m)} = \\frac{1}{n} \\lVert \\mathbf{y}_2 - \\mathbf{X}_2^{(m)} \\hat{\\mathbf{w}}_1^{(m)} \\rVert_2^2, \\quad\n\\mathrm{MSE}_{2\\rightarrow 1}^{(m)} = \\frac{1}{n} \\lVert \\mathbf{y}_1 - \\mathbf{X}_1^{(m)} \\hat{\\mathbf{w}}_2^{(m)} \\rVert_2^2,\n$$\n$$\nE_m = \\frac{1}{2} \\left( \\mathrm{MSE}_{1\\rightarrow 2}^{(m)} + \\mathrm{MSE}_{2\\rightarrow 1}^{(m)} \\right),\n$$\n其中 $\\mathbf{y}_c$ 将 $r^{(c)}(t)$ 在 $t = 1,\\dots,n$ 上堆叠起来，而 $n$ 是每个条件的样本数。\n\n决策规则：\n- 如果 $E_{\\text{kinematic}} \\leq E_{\\text{kinetic}}$，则宣布运动学模型是更好的解释；否则宣布动力学模型是更好的解释。输出一个布尔值，其中 $\\text{True}$ 表示运动学模型更优，$\\text{False}$ 表示动力学模型更优。如果出现完全相等的情况，选择运动学模型（即 $\\text{True}$）。\n\n单位和角度约定：\n- 速度必须以 cm/s 表示。\n- 力必须以牛顿表示。\n- 发放率必须以 spikes/s 表示。\n- 用于调谐计算的任何内部角度都应以弧度为单位。最终输出不包含任何角度。\n\n测试套件规范：\n您必须实现以下三种情况。在所有情况下，都有 $n=8$ 个运动方向，其方向角为\n$$\n\\theta_i \\in \\{0, \\frac{\\pi}{4}, \\frac{\\pi}{2}, \\frac{3\\pi}{4}, \\pi, \\frac{5\\pi}{4}, \\frac{3\\pi}{2}, \\frac{7\\pi}{4}\\},\n$$\n恒定速率 $s = 10$ cm/s，以及 $\\mathbf{v}(t) = s[\\cos\\theta_t, \\sin\\theta_t]$。使用确定性噪声向量\n$$\n\\boldsymbol{\\epsilon}^{(1)} = [0.05, -0.03, 0.02, -0.01, 0.04, -0.02, 0.03, -0.04],\n$$\n$$\n\\boldsymbol{\\epsilon}^{(2)} = [0.01, -0.02, 0.03, -0.01, 0.02, -0.03, 0.01, -0.02],\n$$\n分别逐样本应用于条件 1 和 2。\n\n- 情况 1（理想路径：主要为运动学编码）：\n    - $\\alpha = 0.5$ N/(cm/s)。\n    - $\\mathbf{L}^{(1)} = [0, 0]$ N, $\\mathbf{L}^{(2)} = [5, 0]$ N。\n    - 运动学系数：$\\beta_0 = 5$ spikes/s, $\\boldsymbol{\\beta} = [0.8, 0.2]$ spikes/(cm/s)。\n    - 按 $r^{(c)}(t) = \\beta_0 + \\boldsymbol{\\beta} \\cdot \\mathbf{v}^{(c)}(t) + \\epsilon^{(c)}(t)$ 生成发放率。\n\n- 情况 2（相反路径：主要为动力学编码）：\n    - $\\alpha = 0.5$ N/(cm/s)。\n    - $\\mathbf{L}^{(1)} = [0, 0]$ N, $\\mathbf{L}^{(2)} = [5, 0]$ N。\n    - 动力学系数：$\\gamma_0 = 6$ spikes/s, $\\boldsymbol{\\gamma} = [0.5, -0.3]$ spikes/N。\n    - 按 $r^{(c)}(t) = \\gamma_0 + \\boldsymbol{\\gamma} \\cdot \\mathbf{F}^{(c)}(t) + \\epsilon^{(c)}(t)$（其中 $\\mathbf{F}^{(c)}(t) = \\alpha \\mathbf{v}^{(c)}(t) + \\mathbf{L}^{(c)}$）生成发放率。\n\n- 情况 3（边界情况：混合编码，可能出现平局）：\n    - $\\alpha = 0.5$ N/(cm/s)。\n    - $\\mathbf{L}^{(1)} = [0, 0]$ N, $\\mathbf{L}^{(2)} = [2, -2]$ N。\n    - 运动学系数：$\\beta_0 = 4$ spikes/s, $\\boldsymbol{\\beta} = [0.6, 0.6]$ spikes/(cm/s)。\n    - 动力学系数：$\\gamma_0 = 4$ spikes/s, $\\boldsymbol{\\gamma} = [0.4, 0.1]$ spikes/N。\n    - 混合权重：$w_k = 0.5$, $w_f = 0.5$。\n    - 按 $r^{(c)}(t) = w_k(\\beta_0 + \\boldsymbol{\\beta} \\cdot \\mathbf{v}^{(c)}(t)) + w_f(\\gamma_0 + \\boldsymbol{\\gamma} \\cdot \\mathbf{F}^{(c)}(t)) + \\epsilon^{(c)}(t)$（其中 $\\mathbf{F}^{(c)}(t) = \\alpha \\mathbf{v}^{(c)}(t) + \\mathbf{L}^{(c)}$）生成发放率。\n\n您的程序必须：\n- 按照上述规范为每种情况构建数据集。\n- 对于每种情况，使用所述的回归程序计算跨条件泛化误差 $E_{\\text{kinematic}}$ 和 $E_{\\text{kinetic}}$。\n- 根据上述决策规则，为每种情况生成一个布尔结果，指示运动学编码是否通过回归比较更好地解释了观察到的调谐漂移。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\text{result1},\\text{result2},\\text{result3}]$），每个结果都是一个布尔值（$\\text{True}$ 表示运动学更优；$\\text{False}$ 表示动力学更优）。不应打印任何其他文本。", "solution": "该问题要求我们实现一个模型比较程序，以确定运动学编码模型或动力学编码模型中哪一个能更好地解释在两种不同外部负载条件下模拟的初级运动皮层（M1）神经发放数据。比较方法是跨条件回归泛化，这是计算神经科学中用于在神经功能竞争模型之间进行裁决的标准技术。\n\n其核心原则是，一个好的神经编码模型，其参数对于模型已明确考虑到的外部条件变化应保持不变。例如，如果一个神经元真正编码的是力，那么即使外部负载发生变化，其力调谐参数（$\\gamma_0$, $\\boldsymbol{\\gamma}$）也应保持恒定。拥有这种不变参数的模型，在一种条件下训练并在另一种条件下测试时，会表现出良好的泛化能力。相反，一个未能捕捉到真实潜在变量的模型，其参数会随条件变化而改变，因此泛化能力会很差。\n\n我们将分析三种不同的情况，每种情况都代表了神经编码的一种不同的“真实情况”（ground truth）。对于每种情况，我们将：\n1.  为两种条件 $c \\in \\{1, 2\\}$，在 $n=8$ 个时间点（对应8个运动方向）上，生成运动学变量（速度 $\\mathbf{v}^{(c)}(t)$）、动力学变量（力 $\\mathbf{F}^{(c)}(t)$）和神经响应（发放率 $r^{(c)}(t)$）。\n2.  为运动学和动力学模型构建设计矩阵。\n3.  使用普通最小二乘（OLS）回归分别对每个条件的数据拟合各模型的参数。\n4.  通过计算使用从一个条件拟合的参数预测另一个条件数据时的均方误差（MSE）来评估每个模型的泛化性能。\n5.  将两个跨条件 MSE 平均，得到每个模型 $m$ 的对称误差分数 $E_m$。\n6.  应用决策规则：如果 $E_{\\text{kinematic}} \\leq E_{\\text{kinetic}}$，则认为运动学模型更优。\n\n让我们为任意给定情况形式化这些步骤。首先，我们生成运动学数据。速率是恒定的 $s=10$ cm/s，方向由 $\\theta_t \\in \\{0, \\frac{\\pi}{4}, \\frac{\\pi}{2}, \\frac{3\\pi}{4}, \\pi, \\frac{5\\pi}{4}, \\frac{3\\pi}{2}, \\frac{7\\pi}{4}\\}$ 给出，其中 $t=1, \\dots, 8$。时间 $t$ 的速度向量是 $\\mathbf{v}(t) = [v_x(t), v_y(t)]^T = s[\\cos\\theta_t, \\sin\\theta_t]^T$。速度与负载条件无关，因此 $\\mathbf{v}^{(1)}(t) = \\mathbf{v}^{(2)}(t) = \\mathbf{v}(t)$。\n\n力向量的模型为 $\\mathbf{F}^{(c)}(t) = \\alpha \\mathbf{v}(t) + \\mathbf{L}^{(c)}$，其中 $\\alpha$ 是一个类粘性系数，$\\mathbf{L}^{(c)}$ 是条件 $c$ 的外部负载向量。\n\n发放率 $y_c = [r^{(c)}(1), \\dots, r^{(c)}(8)]^T$ 根据每种情况的具体规则生成。\n\n对于每个模型 $m \\in \\{\\text{kinematic}, \\text{kinetic}\\}$，我们建立一个线性回归问题。一般形式为 $\\mathbf{y}_c = \\mathbf{X}_c^{(m)} \\mathbf{w}_c^{(m)} + \\boldsymbol{\\epsilon}_c$。\n- 对于运动学模型，回归量是速度分量。设计矩阵 $\\mathbf{X}_{\\text{kin}}$ 对两种条件都相同，因为速度是相同的。它是一个 $n \\times 3$ 的矩阵，其中第 $t$ 行是 $[1, v_x(t), v_y(t)]$。\n- 对于动力学模型，回归量是力分量。设计矩阵 $\\mathbf{X}_{\\text{kinet}}^{(c)}$ 对每个条件都不同，因为力取决于负载 $\\mathbf{L}^{(c)}$。$\\mathbf{X}_{\\text{kinet}}^{(c)}$ 的第 $t$ 行是 $[1, F_x^{(c)}(t), F_y^{(c)}(t)]$。\n\n权重向量 $\\mathbf{w}$ 的 OLS 解由 $\\hat{\\mathbf{w}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}$ 给出。我们计算四个这样的权重向量：$\\hat{\\mathbf{w}}_1^{(\\text{kin})}$、$\\hat{\\mathbf{w}}_2^{(\\text{kin})}$、$\\hat{\\mathbf{w}}_1^{(\\text{kinet})}$ 和 $\\hat{\\mathbf{w}}_2^{(\\text{kinet})}$。\n\n跨条件 MSE 计算如下：\n$\\mathrm{MSE}_{1\\rightarrow 2}^{(m)} = \\frac{1}{n} \\lVert \\mathbf{y}_2 - \\mathbf{X}_2^{(m)} \\hat{\\mathbf{w}}_1^{(m)} \\rVert_2^2$\n$\\mathrm{MSE}_{2\\rightarrow 1}^{(m)} = \\frac{1}{n} \\lVert \\mathbf{y}_1 - \\mathbf{X}_1^{(m)} \\hat{\\mathbf{w}}_2^{(m)} \\rVert_2^2$\n模型 $m$ 的总误差是 $E_m = \\frac{1}{2} (\\mathrm{MSE}_{1\\rightarrow 2}^{(m)} + \\mathrm{MSE}_{2\\rightarrow 1}^{(m)})$。\n\n我们现在将此程序应用于三种情况中的每一种。\n\n**情况 1：主要为运动学编码**\n- 参数：$\\alpha = 0.5$ N/(cm/s), $\\mathbf{L}^{(1)} = [0, 0]$ N, $\\mathbf{L}^{(2)} = [5, 0]$ N。\n- 发放率生成：$r^{(c)}(t) = \\beta_0 + \\boldsymbol{\\beta} \\cdot \\mathbf{v}(t) + \\epsilon^{(c)}(t)$，其中 $\\beta_0 = 5$ 且 $\\boldsymbol{\\beta} = [0.8, 0.2]$。\n- 发放率是由一个其参数（$\\beta_0, \\boldsymbol{\\beta}$）在不同条件下相对于速度保持稳定的过程生成的。因此，运动学模型应该能很好地拟合数据，更重要的是，能很好地泛化。系数 $\\hat{\\mathbf{w}}_1^{(\\text{kin})}$ 和 $\\hat{\\mathbf{w}}_2^{(\\text{kin})}$ 应该彼此非常相似，并且与真实参数 $[\\beta_0, \\beta_x, \\beta_y]^T = [5, 0.8, 0.2]^T$ 非常接近。因此，预计 $E_{\\text{kinematic}}$ 会很小，主要由噪声项 $\\boldsymbol{\\epsilon}^{(c)}$ 决定。\n- 相比之下，发放率与力之间的关系是不稳定的。$r^{(c)}(t) = \\beta_0 + \\boldsymbol{\\beta} \\cdot \\frac{1}{\\alpha}(\\mathbf{F}^{(c)}(t) - \\mathbf{L}^{(c)}) + \\epsilon^{(c)}(t) = (\\beta_0 - \\frac{1}{\\alpha}\\boldsymbol{\\beta}\\cdot\\mathbf{L}^{(c)}) + (\\frac{1}{\\alpha}\\boldsymbol{\\beta}) \\cdot \\mathbf{F}^{(c)}(t) + \\epsilon^{(c)}(t)$。截距项 $(\\beta_0 - \\frac{1}{\\alpha}\\boldsymbol{\\beta}\\cdot\\mathbf{L}^{(c)})$ 会随负载 $\\mathbf{L}^{(c)}$ 而变化。在条件 1 上拟合的动力学模型对于条件 2 将有错误的截距，导致泛化能力差和较大的 $E_{\\text{kinetic}}$。\n- 预期：$E_{\\text{kinematic}}  E_{\\text{kinetic}}$，结果为 `True` 输出。\n\n**情况 2：主要为动力学编码**\n- 参数：$\\alpha = 0.5$ N/(cm/s), $\\mathbf{L}^{(1)} = [0, 0]$ N, $\\mathbf{L}^{(2)} = [5, 0]$ N。\n- 发放率生成：$r^{(c)}(t) = \\gamma_0 + \\boldsymbol{\\gamma} \\cdot \\mathbf{F}^{(c)}(t) + \\epsilon^{(c)}(t)$，其中 $\\gamma_0 = 6$ 且 $\\boldsymbol{\\gamma} = [0.5, -0.3]$。\n- 这与情况 1 相反。数据由一个稳定的动力学模型生成。动力学模型的参数在不同条件下是不变的。因此，我们期望 $\\hat{\\mathbf{w}}_1^{(\\text{kinet})}$ 和 $\\hat{\\mathbf{w}}_2^{(\\text{kinet})}$ 与 $[\\gamma_0, \\gamma_x, \\gamma_y]^T = [6, 0.5, -0.3]^T$ 相似，且 $E_{\\text{kinetic}}$ 应该很小。\n- 与速度的关系，$r^{(c)}(t) = \\gamma_0 + \\boldsymbol{\\gamma} \\cdot (\\alpha \\mathbf{v}(t) + \\mathbf{L}^{(c)}) + \\epsilon^{(c)}(t) = (\\gamma_0 + \\boldsymbol{\\gamma}\\cdot\\mathbf{L}^{(c)}) + (\\alpha\\boldsymbol{\\gamma}) \\cdot \\mathbf{v}(t) + \\epsilon^{(c)}(t)$，有一个依赖于条件的截距 $(\\gamma_0 + \\boldsymbol{\\gamma}\\cdot\\mathbf{L}^{(c)})$。运动学模型将无法泛化。\n- 预期：$E_{\\text{kinetic}}  E_{\\text{kinematic}}$，结果为 `False` 输出。\n\n**情况 3：混合编码**\n- 参数：$\\alpha = 0.5$ N/(cm/s), $\\mathbf{L}^{(1)} = [0, 0]$ N, $\\mathbf{L}^{(2)} = [2, -2]$ N。\n- 发放率生成：$r^{(c)}(t) = w_k(\\beta_0 + \\boldsymbol{\\beta} \\cdot \\mathbf{v}(t)) + w_f(\\gamma_0 + \\boldsymbol{\\gamma} \\cdot \\mathbf{F}^{(c)}(t)) + \\epsilon^{(c)}(t)$，其中 $w_k=w_f=0.5$, $\\beta_0=4, \\boldsymbol{\\beta}=[0.6, 0.6]$, $\\gamma_0=4, \\boldsymbol{\\gamma}=[0.4, 0.1]$。\n- 发放率是运动学和动力学项的线性组合。我们可以通过将其完全用一个变量来表示，从而分析其结构。\n- 运动学表示：$r^{(c)}(t) = (\\dots) + (\\dots)\\cdot\\mathbf{v}(t)$。如情况 2 所示，代入 $\\mathbf{F}^{(c)}(t) = \\alpha \\mathbf{v}(t) + \\mathbf{L}^{(c)}$ 会导致一个依赖于 $\\mathbf{L}^{(c)}$ 的有效截距。\n- 动力学表示：我们代入 $\\mathbf{v}(t) = \\frac{1}{\\alpha}(\\mathbf{F}^{(c)}(t) - \\mathbf{L}^{(c)})$。\n$r^{(c)} = w_k(\\beta_0 + \\frac{1}{\\alpha}\\boldsymbol{\\beta}\\cdot(\\mathbf{F}^{(c)} - \\mathbf{L}^{(c)})) + w_f(\\gamma_0 + \\boldsymbol{\\gamma}\\cdot\\mathbf{F}^{(c)}) + \\epsilon^{(c)}$\n$r^{(c)} = (w_k\\beta_0 + w_f\\gamma_0 - \\frac{w_k}{\\alpha}\\boldsymbol{\\beta}\\cdot\\mathbf{L}^{(c)}) + (\\frac{w_k}{\\alpha}\\boldsymbol{\\beta} + w_f\\boldsymbol{\\gamma})\\cdot\\mathbf{F}^{(c)} + \\epsilon^{(c)}$\n- 让我们检查有效截距：$\\gamma_{0, \\text{eff}}^{(c)} = w_k\\beta_0 + w_f\\gamma_0 - \\frac{w_k}{\\alpha}\\boldsymbol{\\beta}\\cdot\\mathbf{L}^{(c)}$。\n代入数值：$\\alpha=0.5, w_k=0.5, \\beta_0=4, \\gamma_0=4, \\boldsymbol{\\beta}=[0.6, 0.6]$。\n$\\gamma_{0, \\text{eff}}^{(c)} = 0.5(4) + 0.5(4) - \\frac{0.5}{0.5}([0.6, 0.6]\\cdot\\mathbf{L}^{(c)}) = 4 - [0.6, 0.6]\\cdot\\mathbf{L}^{(c)}$。\n对于条件 1：$\\mathbf{L}^{(1)} = [0, 0]$，所以 $\\gamma_{0, \\text{eff}}^{(1)} = 4$。\n对于条件 2：$\\mathbf{L}^{(2)} = [2, -2]$，所以 $[0.6, 0.6]\\cdot[2, -2] = 0.6(2) + 0.6(-2) = 1.2 - 1.2 = 0$。因此，$\\gamma_{0, \\text{eff}}^{(2)} = 4$。\n- 值得注意的是，对于这种特定的参数选择，有效的动力学截距在不同条件下是稳定的。有效的动力学斜率 $(\\frac{w_k}{\\alpha}\\boldsymbol{\\beta} + w_f\\boldsymbol{\\gamma})$ 也是稳定的。这意味着该混合模型可以被一个单一、不变的动力学模型完美地表示。\n- 因为动力学表示是稳定的而运动学表示不是，所以动力学模型将具有好得多的泛化能力。\n- 预期：$E_{\\text{kinetic}}  E_{\\text{kinematic}}$，结果为 `False` 输出。\n\n计算实现将精确地遵循此逻辑，以得出每种情况的最终布尔结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the three test cases for M1 encoding model comparison.\n    \"\"\"\n\n    def run_case(case_params: dict) - bool:\n        \"\"\"\n        Runs a single case for model comparison.\n\n        Args:\n            case_params: A dictionary containing parameters for the case.\n\n        Returns:\n            A boolean, True if kinematic model is better or equal, False otherwise.\n        \"\"\"\n        # Common parameters\n        n_samples = 8\n        speed = 10.0\n        thetas = np.linspace(0, 2 * np.pi, n_samples, endpoint=False)\n        eps1 = np.array([0.05, -0.03, 0.02, -0.01, 0.04, -0.02, 0.03, -0.04])\n        eps2 = np.array([0.01, -0.02, 0.03, -0.01, 0.02, -0.03, 0.01, -0.02])\n\n        # Generate velocity data (same for both conditions)\n        v_data = speed * np.array([np.cos(thetas), np.sin(thetas)]).T\n\n        # Unpack case-specific parameters\n        alpha = case_params['alpha']\n        L1 = np.array(case_params['L1'])\n        L2 = np.array(case_params['L2'])\n\n        # Generate force data\n        F1_data = alpha * v_data + L1\n        F2_data = alpha * v_data + L2\n\n        # Generate firing rate data (response vectors y1, y2)\n        if case_params['type'] == 'kinematic':\n            beta0 = case_params['beta0']\n            beta_vec = np.array(case_params['beta'])\n            y1 = beta0 + v_data @ beta_vec + eps1\n            y2 = beta0 + v_data @ beta_vec + eps2\n        elif case_params['type'] == 'kinetic':\n            gamma0 = case_params['gamma0']\n            gamma_vec = np.array(case_params['gamma'])\n            y1 = gamma0 + F1_data @ gamma_vec + eps1\n            y2 = gamma0 + F2_data @ gamma_vec + eps2\n        elif case_params['type'] == 'mixed':\n            wk, wf = case_params['weights']\n            beta0, beta_vec = case_params['beta0'], np.array(case_params['beta'])\n            gamma0, gamma_vec = case_params['gamma0'], np.array(case_params['gamma'])\n            kin_term1 = wk * (beta0 + v_data @ beta_vec)\n            kin_term2 = wk * (beta0 + v_data @ beta_vec) \n            kinet_term1 = wf * (gamma0 + F1_data @ gamma_vec)\n            kinet_term2 = wf * (gamma0 + F2_data @ gamma_vec)\n            y1 = kin_term1 + kinet_term1 + eps1\n            y2 = kin_term2 + kinet_term2 + eps2\n        else:\n            raise ValueError(\"Unknown case type\")\n\n        # --- Model Comparison ---\n        \n        # 1. Kinematic Model\n        X_kin = np.c_[np.ones(n_samples), v_data]\n        \n        # Fit on condition 1, test on 2\n        w1_kin = np.linalg.lstsq(X_kin, y1, rcond=None)[0]\n        y2_pred_kin_from_1 = X_kin @ w1_kin\n        mse_1_2_kin = np.mean((y2 - y2_pred_kin_from_1)**2)\n        \n        # Fit on condition 2, test on 1\n        w2_kin = np.linalg.lstsq(X_kin, y2, rcond=None)[0]\n        y1_pred_kin_from_2 = X_kin @ w2_kin\n        mse_2_1_kin = np.mean((y1 - y1_pred_kin_from_2)**2)\n        \n        E_kinematic = 0.5 * (mse_1_2_kin + mse_2_1_kin)\n\n        # 2. Kinetic Model\n        X_kinet_1 = np.c_[np.ones(n_samples), F1_data]\n        X_kinet_2 = np.c_[np.ones(n_samples), F2_data]\n\n        # Fit on condition 1, test on 2\n        w1_kinet = np.linalg.lstsq(X_kinet_1, y1, rcond=None)[0]\n        y2_pred_kinet_from_1 = X_kinet_2 @ w1_kinet\n        mse_1_2_kinet = np.mean((y2 - y2_pred_kinet_from_1)**2)\n\n        # Fit on condition 2, test on 1\n        w2_kinet = np.linalg.lstsq(X_kinet_2, y2, rcond=None)[0]\n        y1_pred_kinet_from_2 = X_kinet_1 @ w2_kinet\n        mse_2_1_kinet = np.mean((y1 - y1_pred_kinet_from_2)**2)\n\n        E_kinetic = 0.5 * (mse_1_2_kinet + mse_2_1_kinet)\n\n        # Decision rule\n        return E_kinematic = E_kinetic\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            'type': 'kinematic',\n            'alpha': 0.5,\n            'L1': [0.0, 0.0], 'L2': [5.0, 0.0],\n            'beta0': 5.0, 'beta': [0.8, 0.2]\n        },\n        {\n            'type': 'kinetic',\n            'alpha': 0.5,\n            'L1': [0.0, 0.0], 'L2': [5.0, 0.0],\n            'gamma0': 6.0, 'gamma': [0.5, -0.3]\n        },\n        {\n            'type': 'mixed',\n            'alpha': 0.5,\n            'L1': [0.0, 0.0], 'L2': [2.0, -2.0],\n            'beta0': 4.0, 'beta': [0.6, 0.6],\n            'gamma0': 4.0, 'gamma': [0.4, 0.1],\n            'weights': (0.5, 0.5)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "5049049"}]}