{"hands_on_practices": [{"introduction": "在评估任何群体健康干预措施时，首要任务是量化其效果。本练习将带您使用流行病学中的基本工具——风险比（$RR$）、比值比（$OR$）和风险差（$RD$）——来评估一项结直肠癌筛查项目的影响。通过计算和解读这些指标，您将学会如何从原始数据中提炼出关于干预措施有效性的关键见解，并理解它们在资源分配决策中的不同应用场景。[@problem_id:4389588]", "problem": "一个卫生系统科学团队正在评估一项人群健康管理策略：在一个特定队列中实施的有组织的结直肠癌筛查项目。对两个具有可比性的人群进行了一年的随访：被邀请参加筛查的人群（干预组）和未被邀请的人群（对照组）。感兴趣的结局是在一年内被诊断为晚期结直肠癌。\n\n干预组有 $12{,}000$ 人，其中有 $180$ 例晚期诊断。对照组有 $8{,}000$ 人，其中有 $240$ 例晚期诊断。仅使用概率（风险）和比值的基本原理定义，计算干预组相对于对照组的晚期诊断风险比（RR）、比值比（OR）和风险差（RD）。对于比率度量，“相对于”应解释为干预组的度量除以对照组的度量；对于差异度量，则解释为干预组的度量减去对照组的度量。将每个数值结果四舍五入至四位有效数字，并以小数形式表示，不带百分号。\n\n最后，从基本原理出发，解释在何种情况下，每种度量（RR、OR、RD）最适合用于人群健康管理决策，需考虑研究设计、可解释性和资源分配决策。", "solution": "首先对问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n- 干预组规模：$12{,}000$ 人。\n- 干预组晚期诊断数：$180$ 例。\n- 对照组规模：$8{,}000$ 人。\n- 对照组晚期诊断数：$240$ 例。\n- 结局：一年内诊断为晚期结直肠癌。\n- 要求计算：风险比（RR）、比值比（OR）和风险差（RD）。\n- RR 的定义：干预组的风险除以对照组的风险。\n- OR 的定义：干预组的比值除以对照组的比值。\n- RD 的定义：干预组的风险减去对照组的风险。\n- 要求精度：将每个结果四舍五入至四位有效数字，以小数形式表示。\n- 要求解释：在何种情况下 RR、OR 和 RD 最适合用于人群健康管理决策。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据。它呈现了一个标准的流行病学情景（一项队列研究），并要求计算关联性的基本度量（RR、OR、RD）。风险、比值及其各自的比率和差异的概念是流行病学和卫生系统科学的基石。该问题提法明确，因为计算所需的所有数据均已提供，并且所需度量的定义也已明确说明。语言客观、精确。该问题是自洽的，不违反任何科学或数学原理。数据值对于大规模人群健康研究是合理的。\n\n### 第 3 步：结论与行动\n该问题有效。将提供完整解答。\n\n### 解答\n我们为两个队列定义变量。\n对于干预组（下标 `int`）：\n- 总人数：$N_{int} = 12000$\n- 晚期诊断人数（事件数）：$D_{int} = 180$\n- 未被晚期诊断人数（非事件数）：$H_{int} = N_{int} - D_{int} = 12000 - 180 = 11820$\n\n对于对照组（下标 `comp`）：\n- 总人数：$N_{comp} = 8000$\n- 晚期诊断人数（事件数）：$D_{comp} = 240$\n- 未被晚期诊断人数（非事件数）：$H_{comp} = N_{comp} - D_{comp} = 8000 - 240 = 7760$\n\n根据基本原理，风险是事件在人群中发生的概率。\n干预组的风险：\n$$R_{int} = P(\\text{Diagnosis} | \\text{Intervention}) = \\frac{D_{int}}{N_{int}} = \\frac{180}{12000} = 0.015$$\n对照组的风险：\n$$R_{comp} = P(\\text{Diagnosis} | \\text{Comparison}) = \\frac{D_{comp}}{N_{comp}} = \\frac{240}{8000} = 0.03$$\n\n根据基本原理，比值是事件发生的概率与事件不发生的概率之比。\n干预组的比值：\n$$O_{int} = \\frac{P(\\text{Diagnosis} | \\text{Intervention})}{1 - P(\\text{Diagnosis} | \\text{Intervention})} = \\frac{R_{int}}{1 - R_{int}} = \\frac{D_{int}}{H_{int}} = \\frac{180}{11820}$$\n对照组的比值：\n$$O_{comp} = \\frac{P(\\text{Diagnosis} | \\text{Comparison})}{1 - P(\\text{Diagnosis} | \\text{Comparison})} = \\frac{R_{comp}}{1 - R_{comp}} = \\frac{D_{comp}}{H_{comp}} = \\frac{240}{7760}$$\n\n现在，我们计算所需的度量：风险比（RR）、比值比（OR）和风险差（RD）。\n\n**1. 风险比 (RR)**\n风险比是干预组的风险与对照组的风险之比。\n$$RR = \\frac{R_{int}}{R_{comp}} = \\frac{0.015}{0.03} = 0.5$$\n四舍五入到四位有效数字得到 $0.5000$。\n\n**2. 比值比 (OR)**\n比值比是干预组的比值与对照组的比值之比。\n$$OR = \\frac{O_{int}}{O_{comp}} = \\frac{D_{int} / H_{int}}{D_{comp} / H_{comp}} = \\frac{180 / 11820}{240 / 7760} = \\frac{180 \\times 7760}{11820 \\times 240} = \\frac{1396800}{2836800} \\approx 0.4923857...$$\n四舍五入到四位有效数字得到 $0.4924$。\n\n**3. 风险差 (RD)**\n风险差是干预组和对照组之间风险的绝对差值。\n$$RD = R_{int} - R_{comp} = 0.015 - 0.03 = -0.015$$\n四舍五入到四位有效数字得到 $-0.01500$。\n\n### 各度量的适用性\nRR、OR 和 RD 之间的选择取决于研究设计、期望的解释以及人群健康管理中要解决的具体问题。\n\n**风险比 (RR)**\n- **适用情境：** RR 最适用于队列研究和随机对照试验（RCTs），在这些研究中，可以在暴露组（干预组）和非暴露组（对照组）中直接测量结局的发生率。\n- **可解释性：** RR 非常直观且易于沟通。$RR = 0.5000$ 意味着“参加筛查项目的人群患晚期诊断的风险是未参加项目人群的一半”。它量化了干预对风险的乘法效应。在向患者或公众解释干预的相对有效性时，通常首选此度量。\n- **人群健康决策：** RR 可用于评估关联强度。与 $RR=1$ 的较大偏离表明干预具有强效果，这可以使其在实施中获得优先考虑，前提是它也具有成本效益。\n\n**比值比 (OR)**\n- **适用情境：** OR 是病例-对照研究中主要的关联度量，在这类研究中，研究人员根据疾病状态进行抽样，因此无法直接计算发生率或风险。它也是逻辑回归模型的自然输出，逻辑回归是流行病学中用于调整混杂变量的无处不在的工具。在像本例这样的队列研究中，它是一个有效的度量，但通常因为在疾病罕见时它能近似 RR 而被使用。此处，风险（$1.5\\%$ 和 $3\\%$）较低，因此 OR（$0.4924$）是 RR（$0.5000$）的良好近似。\n- **可解释性：** OR 不如 RR 直观。$OR = 0.4924$ 解释为“筛查组中晚期诊断的比值约是未筛查组中比值的 $49\\%$”。对于许多非统计学专业人士来说，“比值”的概念不如“风险”清晰。\n- **人群健康决策：** 其主要价值在于其数学特性，这对于统计建模是有利的。对于决策者来说，当审查来自高级统计分析或病例-对照研究（常用于研究罕见疾病）的结果时，它最为相关。\n\n**风险差 (RD)**\n- **适用情境：** 与 RR 一样，RD 用于队列研究和 RCTs。它是一种绝对效应度量，与 RR 和 OR 的相对性质形成对比。\n- **可解释性：** RD 提供了干预措施对公共卫生影响的直接度量。$RD = -0.01500$ 意味着筛查项目使晚期诊断的绝对风险降低了 $1.5$ 个百分点。这可以转化为，每邀请 $1000$ 人参加筛查，就可以预防 $15$ 例晚期诊断。这引出了“需治数”（或在此情况下为“需筛查数”）的概念，即预防一例不良事件所需治疗的人数，其计算公式为 $1/|RD| = 1/0.015 \\approx 67$。每邀请 $67$ 人参加筛查项目，就可预防一例晚期诊断。\n- **人群健康决策：** RD 可谓是资源分配和政策制定最关键的度量。虽然一个大的 RR 可能看起来很引人注目，但如果基线风险非常低，预防的绝对病例数（即 RD）可能太小，不足以证明一个昂贵的大规模项目是合理的。卫生系统规划者使用 RD 来权衡干预的绝对收益与其成本和危害，使其成为预算和资源分配决策的基础。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.5000  0.4924  -0.01500 \\end{pmatrix}}\n$$", "id": "4389588"}, {"introduction": "一项干预措施即便有效，也未必具有成本效益。本练习将引导您进入卫生经济学评估的核心，通过计算质量调整生命年（$QALY$）和增量成本效果比（$ICER$），来量化一项戒烟项目的“性价比”。这个实践将帮助您理解如何在决策中权衡成本与健康收益，这是群体健康管理中制定资源优先顺序的关键技能。[@problem_id:4389597]", "problem": "一个卫生系统正在评估一项人群层面的戒烟策略，作为其人群健康管理的一部分。使用以死亡为 $0$、完全健康为 $1$ 为锚定点的健康相关生命质量框架，简要陈述质量调整生命年 (QALY) 的正式定义。然后，运用期望值和贴现的基本原理，推导并计算新方案相对于常规护理的增量成本效果比。\n\n假设一个成年吸烟者队列被随访 $3$ 年。在此期间，死亡率差异可忽略不计，因此所有个体在所有 $3$ 年中的生存率均为 $1$。健康状态效用在每一年内保持不变，当前吸烟者的效用为 $u_{S} = 0.78$，持续戒烟者的效用为 $u_{E} = 0.85$。所有个体在第 1 年均为吸烟者；戒烟状态在第 2 年初确定。\n\n戒烟与复吸动态：\n- 在常规护理下：在第 2 年初成为持续戒烟者的概率为 $p_{0} = 0.10$。从第 2 年到第 3 年保持戒烟状态的概率为 $k_{0} = 0.80$。\n- 在新方案下：在第 2 年初成为持续戒烟者的概率为 $p_{1} = 0.25$。从第 2 年到第 3 年保持戒烟状态的概率为 $k_{1} = 0.85$。\n\n每位参与者的成本（均以美元计）在每年年初产生：\n- 常规护理：第 1 年成本 $= 50$，第 2 年成本 $= 50$，第 3 年成本 $= 50$。\n- 新方案：第 1 年成本 $= 200$，第 2 年成本 $= 60$，第 3 年成本 $= 60$。\n\n使用 $r = 0.03$ 的恒定年贴现率，并在基线（第 1 年初）评估现值。采用以下时间约定：第 $t$ 年的成本和年度 QALY 流量均在该年年初（时间 $t-1$）发生，因此第 1、2、3 年的流量分别按因子 $(1+r)^{0}$、$(1+r)^{1}$ 和 $(1+r)^{2}$ 进行贴现。计算新方案相对于常规护理的增量成本效果比，即每获得一个增量 QALY 所需的增量成本。最终结果以美元/质量调整生命年表示，并四舍五入至四位有效数字。任何地方都不要使用百分号；所有概率都用小数或分数表示。", "solution": "问题陈述已经过验证，被认为是具有科学依据、适定且客观的。它包含一套完整且一致的数据和约束，可以推导出唯一且有意义的解。\n\n质量调整生命年 (QALY) 是一个将生命数量和质量综合为单一数值指数的指标。它在卫生经济学中用于量化健康结局的价值。一个 QALY 代表在完全健康状态下生活一年，该状态的效用值为 $1$。被认为不完美的健康状态被赋予一个介于 $0$（等同于死亡的状态）和 $1$ 之间的效用值 $u$。对于给定的时间段，获得的 QALYs 是该时间段的长度与该时期健康状态效用的乘积。为分析目的，未来的 QALYs 和成本会被贴现为其现值，以反映时间偏好。\n\n增量成本效果比 (ICER) 是一个用于总结卫生保健干预措施成本效果的统计量。它定义为两种竞争策略的成本差异与健康效果差异的比率。在这里，健康效果以 QALYs 衡量。设策略 $0$ 表示常规护理，策略 $1$ 表示新方案。ICER 由下式给出：\n$$\nICER = \\frac{\\Delta C}{\\Delta Q} = \\frac{C_1 - C_0}{Q_1 - Q_0}\n$$\n其中 $C_i$ 和 $Q_i$ 分别是策略 $i$ 的总期望贴现成本和总期望贴现 QALYs。\n\n我们首先推导给定策略 $i \\in \\{0, 1\\}$ 的总期望贴现成本 $C_i$ 的表达式。成本在每年年初产生。根据指定的时间约定，第 $t \\in \\{1, 2, 3\\}$ 年的成本在时间 $j = t-1$ 产生，并以 $(1+r)^{-(t-1)}$ 的因子进行贴现。\n总贴现成本为：\n$$\nC_i = \\frac{C_{i,1}}{(1+r)^0} + \\frac{C_{i,2}}{(1+r)^1} + \\frac{C_{i,3}}{(1+r)^2}\n$$\n对于常规护理（策略 $0$），成本为 $C_{0,1} = 50$、$C_{0,2} = 50$ 和 $C_{0,3} = 50$ 美元。贴现率为 $r=0.03$。\n$$\nC_0 = 50 + \\frac{50}{1+0.03} + \\frac{50}{(1+0.03)^2} = 50 \\left( 1 + \\frac{1}{1.03} + \\frac{1}{1.03^2} \\right)\n$$\n对于新方案（策略 $1$），成本为 $C_{1,1} = 200$、$C_{1,2} = 60$ 和 $C_{1,3} = 60$ 美元。\n$$\nC_1 = 200 + \\frac{60}{1+0.03} + \\frac{60}{(1+0.03)^2} = 200 + 60 \\left( \\frac{1}{1.03} + \\frac{1}{1.03^2} \\right)\n$$\n因此，增量成本 $\\Delta C = C_1 - C_0$ 为：\n$$\n\\Delta C = (200-50) + (60-50)\\left(\\frac{1}{1.03}\\right) + (60-50)\\left(\\frac{1}{1.03^2}\\right)\n$$\n$$\n\\Delta C = 150 + \\frac{10}{1.03} + \\frac{10}{1.0609}\n$$\n数值上，$\\Delta C \\approx 150 + 9.708738 + 9.425959 = 169.134697$ 美元。\n\n接下来，我们推导总期望贴现 QALYs $Q_i$ 的表达式。第 $t$ 年的年度 QALY 流量也发生在年初（时间 $t-1$），因此也按相同的因子进行贴现。总期望贴现 QALYs 为：\n$$\nQ_i = \\frac{E[u_{i,1}]}{(1+r)^0} + \\frac{E[u_{i,2}]}{(1+r)^1} + \\frac{E[u_{i,3}]}{(1+r)^2}\n$$\n其中 $E[u_{i,t}]$ 是策略 $i$ 下第 $t$ 年的期望效用。健康状态为当前吸烟者 (S)，效用为 $u_S = 0.78$，以及持续戒烟者 (E)，效用为 $u_E = 0.85$。\n\n第 1 年：所有个体均为吸烟者。\n对于两种策略，$E[u_{i,1}] = 1 \\cdot u_S + 0 \\cdot u_E = u_S = 0.78$。\n\n第 2 年：戒烟状态在第 2 年初确定。成为戒烟者的概率为 $p_i$。\n处于状态 E 的概率为 $p_i$。\n处于状态 S 的概率为 $1-p_i$。\n$E[u_{i,2}] = p_i u_E + (1-p_i) u_S$。\n\n第 3 年：在第 2 年初是戒烟者的个体，有 $k_i$ 的概率保持戒烟状态。在第 2 年初是吸烟者的个体，则仍然是吸烟者。\n处于状态 E 的概率是在第 2 年是戒烟者并且在第 3 年保持戒烟状态的概率：$P(\\text{E in year 3}) = p_i k_i$。\n处于状态 S 的概率是 $P(\\text{S in year 3}) = 1 - p_i k_i$。\n$E[u_{i,3}] = (p_i k_i) u_E + (1-p_i k_i) u_S$。\n\n现在可以计算增量 QALYs $\\Delta Q = Q_1 - Q_0$。由于 $E[u_{1,1}] = E[u_{0,1}]$，第 1 年的项相互抵消。\n$$\n\\Delta Q = \\frac{E[u_{1,2}] - E[u_{0,2}]}{1+r} + \\frac{E[u_{1,3}] - E[u_{0,3}]}{(1+r)^2}\n$$\n第 2 年的期望效用差为：\n$E[u_{1,2}] - E[u_{0,2}] = [p_1 u_E + (1-p_1) u_S] - [p_0 u_E + (1-p_0) u_S] = (p_1-p_0)u_E - (p_1-p_0)u_S = (p_1-p_0)(u_E-u_S)$。\n\n第 3 年的期望效用差为：\n$E[u_{1,3}] - E[u_{0,3}] = [(p_1 k_1) u_E + (1-p_1 k_1) u_S] - [(p_0 k_0) u_E + (1-p_0 k_0) u_S] = (p_1k_1-p_0k_0)(u_E-u_S)$。\n\n将这些代入 $\\Delta Q$ 的表达式中：\n$$\n\\Delta Q = (u_E - u_S) \\left[ \\frac{p_1 - p_0}{1+r} + \\frac{p_1k_1 - p_0k_0}{(1+r)^2} \\right]\n$$\n给定：$u_E = 0.85$, $u_S = 0.78$; $p_0 = 0.10$, $k_0 = 0.80$; $p_1 = 0.25$, $k_1 = 0.85$; $r = 0.03$。\n$u_E - u_S = 0.85 - 0.78 = 0.07$。\n$p_1 - p_0 = 0.25 - 0.10 = 0.15$。\n$p_1k_1 - p_0k_0 = (0.25)(0.85) - (0.10)(0.80) = 0.2125 - 0.08 = 0.1325$。\n$$\n\\Delta Q = 0.07 \\left[ \\frac{0.15}{1.03} + \\frac{0.1325}{1.03^2} \\right] = 0.07 \\left[ \\frac{0.15}{1.03} + \\frac{0.1325}{1.0609} \\right]\n$$\n数值上，$\\Delta Q \\approx 0.07 [0.145631 + 0.124894] = 0.07 [0.270525] = 0.01893675$。\n\n最后，我们计算 ICER：\n$$\nICER = \\frac{\\Delta C}{\\Delta Q} \\approx \\frac{169.134697}{0.01893675} \\approx 8931.528\n$$\n题目要求将结果四舍五入至四位有效数字。\n$ICER \\approx 8932$ 美元/质量调整生命年。", "answer": "$$\n\\boxed{8932}\n$$", "id": "4389597"}, {"introduction": "群体健康管理不仅是评估现有策略，更要主动设计和优化复杂的卫生服务系统。本练习将向您介绍一种强大的“虚拟实验室”工具——离散事件模拟，用以分析和改善诊所的工作流程。您将亲手构建一个模型来模拟患者的到达、就诊和失约行为，并评估一个预约提醒系统对诊所日接诊量的系统性影响。[@problem_id:4389599]", "problem": "要求您设计并实现一个离散事件模拟，以研究作为一种人口健康管理策略的诊所流程，重点关注预约提醒系统对吞吐量的影响。该模拟必须包含到达、服务时间和未就诊（no-show）情况，并且必须估计当提醒系统降低了未就诊概率时吞吐量的变化。吞吐量定义为每天完成的就诊次数。您必须为指定的测试套件生成结果，并且程序必须将所有测试用例的结果以列表形式单行输出。\n\n使用的基本定义：\n- 诊所流程被建模为一个多服务器队列，采用先入先出（FIFO）规则，其中有 $c$ 个并行的相同服务器和一个无限大小的等候室。当有服务器可用且患者已到达时，服务开始。\n- 患者在诊所日内按固定的预约时间段进行确定性排期。对于在时间 $t_i$ 的第 $i$ 个预约，实际到达时间为 $a_i = t_i + L_i$，其中 $L_i$ 是迟到时间。迟到时间 $L_i$ 是一个非负随机变量。\n- 患者可能以概率 $p$ 未就诊，此事件在患者之间独立。如果患者未就诊，他们将永远不会进入系统。如果他们就诊，他们的迟到时间和服务时间将被实现。\n- 服务时间是独立同分布的非负随机变量。\n- 该模拟遵循无加班政策：只有当患者的服务能在诊所日结束前完成时，他们才能开始接受服务。具体来说，如果患者的服务将在时间 $s_i$ 开始，持续时间为 $X_i$，则当且仅当 $s_i + X_i \\le T$ 时，该患者才被接诊，其中 $T$ 是诊所日长度。\n- 提醒系统的效果被建模为未就诊概率从基线值 $p_b$ 降低到提醒值 $p_r$，其他所有条件保持不变。\n- 使用通用随机数（CRN）方法来减少比较基线和提醒情景时的方差。对于每次重复实验中的每个预约索引 $i$，对两种策略使用相同的基础随机数来确定迟到时间 $L_i$ 和服务时间 $X_i$，并使用相同的均匀分布随机变量 $U_i$ 以不同的阈值 $1 - p_b$ 和 $1 - p_r$ 来决定是否就诊。\n\n构建所依据的科学基础：\n- 先入先出（FIFO）排队规则和并行服务器操作是卫生系统科学中用于分析诊所流程的核心抽象概念。\n- 到达、服务时间和未就诊事件的独立性是基于排队论的离散事件模拟中的一个标准建模假设。\n- 大数定律证明了，通过多次独立重复实验得出的样本均值可以近似预期的吞吐量。\n\n模拟的数学规范：\n- 设诊所日长度为 $T$（单位：分钟）。\n- 设预约时间段长度为 $s$（单位：分钟）。排期时间为 $t_i = i \\cdot s$，其中 $i = 0, 1, \\dots, n-1$，$n = \\lfloor T / s \\rfloor$。\n- 对于每个排期索引 $i$，迟到时间 $L_i$ 从均值为 $\\bar{\\ell}$ 分钟的指数分布中抽取，服务时间 $X_i$ 从均值为 $\\bar{x}$ 分钟的指数分布中抽取。\n- 对于基线情景，如果 $U_i  1 - p_b$，则患者就诊；对于提醒情景，如果 $U_i  1 - p_r$，则患者就诊，其中 $U_i \\sim \\text{Uniform}(0,1)$。\n- 对于每种策略，为就诊的患者构建到达列表 $\\{(a_i, X_i)\\}$，其中 $a_i = t_i + L_i$。按 $a_i$ 升序排序。设服务器可用时间向量初始化为 $\\mathbf{v} = (0, 0, \\dots, 0) \\in \\mathbb{R}^c$。\n- 按顺序处理到达：对于每个到达的 $(a_i, X_i)$，找到索引为 $j^\\star = \\arg \\min_j v_j$ 的最早可用服务器。开始时间为 $s_i = \\max(a_i, v_{j^\\star})$，完成时间为 $c_i = s_i + X_i$。如果 $c_i \\le T$，则设置 $v_{j^\\star} = c_i$ 并增加吞吐量；否则，根据无加班政策拒绝该患者。\n\n估计目标：\n- 对于每个测试用例，运行 $R$ 次独立重复实验（使用提供的种子和确定性的重置种子规则），计算基线情景下的平均吞吐量、提醒情景下的平均吞吐量，以及对吞吐量的影响，定义为 $\\Delta = \\mathbb{E}[\\text{throughput}_{\\text{reminder}}] - \\mathbb{E}[\\text{throughput}_{\\text{baseline}}]$。报告 $\\Delta$。\n\n实现要求：\n- 您必须完全按照规范，通过服务器可用时间使用下一事件更新方法来实现模拟，并遵守无加班政策。\n- 迟到时间和服务时间分布必须均为指数分布，其均值分别为 $\\bar{\\ell}$ 和 $\\bar{x}$。如果 $\\bar{\\ell} = 0$，则将迟到时间解释为恒等于零。\n- 重复实验必须使用给定的整数种子 $z$ 作为基础种子，并确定性地派生特定于重复实验的种子为 $z + r$，其中 $r \\in \\{0,1,\\dots,R-1\\}$。在每次重复实验中，如上所述，在两种策略间使用通用随机数。\n\n单位和输出：\n- 所有时间输入单位均为分钟。\n- 吞吐量必须表示为每天完成的就诊次数（单位：患者/天），并以浮点数形式报告。\n- 概率必须以小数形式表示（例如，百分之二十表示为 $0.2$）。\n\n测试套件：\n对于下面的每一行，参数以 $(T, s, c, \\bar{x}, p_b, p_r, \\bar{\\ell}, R, z)$ 的形式给出。\n- 案例 A（理想路径）：$(480, 15, 3, 20, 0.25, 0.10, 5, 2000, 202311)$\n- 案例 B（边界情况，无未就诊）：$(480, 20, 2, 20, 0.0, 0.0, 2, 1500, 555)$\n- 案例 C（高未就诊率经提醒改善）：$(240, 10, 2, 12, 0.50, 0.20, 1, 3000, 777)$\n- 案例 D（拥挤的诊所，中度改善）：$(300, 10, 1, 11, 0.15, 0.05, 4, 2500, 9999)$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按上述测试套件的顺序为每个测试用例包含一个浮点数。每个浮点数必须是估计的 $\\Delta$ 值，四舍五入到三位小数。例如，一个包含四个案例的输出必须类似于 $[\\text{d}_A,\\text{d}_B,\\text{d}_C,\\text{d}_D]$，其中每个 $\\text{d}_\\cdot$ 的格式都精确到小数点后三位。", "solution": "该问题是有效的。它在科学上基于排队论和离散事件模拟，这些是卫生系统科学中分析诊所流程的标准方法论。该问题是适定的，为模拟模型、参数和估计目标提供了完整且一致的规范。所有术语都得到了客观和正式的定义。没有矛盾、歧义或信息缺失。给定的参数在临床环境中是现实的，并且计算任务虽然不简单但可行。\n\n解决方案将是一个用 Python 实现的离散事件模拟，严格遵守所提供的数学和程序规范。该模拟的目标是估计因预约提醒系统导致患者未就诊概率降低而引起的每日患者吞吐量的变化，定义为 $\\Delta = \\mathbb{E}[\\text{throughput}_{\\text{reminder}}] - \\mathbb{E}[\\text{throughput}_{\\text{baseline}}]$。\n\n解决方案的核心对每个测试用例涉及以下步骤：\n1.  **重复循环**：我们执行 $R$ 次独立的模拟重复实验来收集统计数据。为确保可复现性和受控的随机性，对于重复实验 $r \\in \\{0, 1, \\dots, R-1\\}$，其种子被确定性地设置为 $z + r$，其中 $z$ 是基础种子。\n\n2.  **通用随机数（CRN）**：在每次重复实验中，我们应用 CRN 方差缩减技术。这意味着我们为每个已排期的预约时间段预先生成一套用于所有潜在事件（未就诊决策、迟到、服务时间）的随机数。这套随机数随后用于基线情景（未就诊概率 $p_b$）和提醒情景（未就诊概率 $p_r$）。这确保了两种策略之间的比较是在相同的随机条件下进行的，从而分离出未就诊概率变化的影响，并减少估计差异 $\\Delta$ 的方差。\n\n3.  **患者生成与到达**：对于一个持续时间为 $T$、预约时间段长度为 $s$ 的诊所日，有 $n = \\lfloor T/s \\rfloor$ 个排期预约。对于每个预约索引 $i \\in \\{0, \\dots, n-1\\}$：\n    - 一个均匀分布的随机变量 $U_i \\sim \\text{Uniform}(0,1)$ 决定患者是否就诊。对于基线情景，如果 $U_i  1-p_b$，患者就诊；对于提醒情景，如果 $U_i  1-p_r$，患者就诊。\n    - 对于每个潜在患者 $i$，我们从均值为 $\\bar{\\ell}$ 的指数分布中生成一个迟到值 $L_i$，并从均值为 $\\bar{x}$ 的指数分布中生成一个服务时间 $X_i$。\n    - 如果患者就诊，他们的到达时间为 $a_i = t_i + L_i$，其中 $t_i = i \\cdot s$ 是排期时间。\n\n4.  **队列处理**：对于每种策略（基线和提醒），我们获得一个到达患者的列表，每个患者由一个元组 $(a_i, X_i)$ 来表征。此列表按到达时间 $a_i$ 排序。然后我们使用以下逻辑处理此队列：\n    - 我们为 $c$ 个并行服务器维护一个可用时间的数组，并初始化为 $0$。\n    - 对于已排序的到达列表中的每个患者，我们找到最早可用的服务器。\n    - 患者的服务可以在时间 $s_i = \\max(a_i, v_{j^\\star})$ 开始，其中 $a_i$ 是他们的到达时间，$v_{j^\\star}$ 是最早的服务器空闲时间。\n    - 服务将在 $c_i = s_i + X_i$ 完成。\n    - **无加班政策**被强制执行：只有当 $c_i \\le T$ 时，患者才被接诊。\n    - 如果被接诊，吞吐量计数器增加，并且该服务器的可用时间更新为 $v_{j^\\star} = c_i$。否则，患者被拒绝。\n\n5.  **估计**：在运行单次重复实验后，我们计算吞吐量的差异，$\\delta_r = \\text{throughput}_{\\text{reminder}, r} - \\text{throughput}_{\\text{baseline}, r}$。在所有 $R$ 次重复实验完成后，影响的最终估计值通过样本均值 $\\hat{\\Delta} = \\frac{1}{R} \\sum_{r=0}^{R-1} \\delta_r$ 计算得出。大数定律确保了该样本均值是真实期望差异 $\\Delta$ 的一致估计量。\n\n这种结构化的方法保证了模拟能准确反映指定的模型，并且使用 CRN 能为干预措施的影响提供统计上有效的估计。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Parameters are given as (T, s, c, x_bar, p_b, p_r, l_bar, R, z).\n    # T: clinic day length (minutes)\n    # s: appointment slot length (minutes)\n    # c: number of servers\n    # x_bar: mean service time (minutes)\n    # p_b: baseline no-show probability\n    # p_r: reminder no-show probability\n    # l_bar: mean lateness (minutes)\n    # R: number of replications\n    # z: base seed\n    test_cases = [\n        # Case A (happy path)\n        (480, 15, 3, 20, 0.25, 0.10, 5, 2000, 202311),\n        # Case B (boundary, zero no-shows)\n        (480, 20, 2, 20, 0.0, 0.0, 2, 1500, 555),\n        # Case C (high no-shows improved by reminders)\n        (240, 10, 2, 12, 0.50, 0.20, 1, 3000, 777),\n        # Case D (congested clinic, moderate improvement)\n        (300, 10, 1, 11, 0.15, 0.05, 4, 2500, 9999),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        # Unpack parameters and run the simulation for one case\n        T, s, c, x_bar, p_b, p_r, l_bar, R, z = case_params\n        delta = _estimate_throughput_impact(T, s, c, x_bar, p_b, p_r, l_bar, R, z)\n        results.append(delta)\n\n    # Format the final results to three decimal places and print in the required format.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _estimate_throughput_impact(T, s, c, x_bar, p_b, p_r, l_bar, R, z):\n    \"\"\"\n    Estimates the change in throughput for a single test case by running R replications.\n    \"\"\"\n    replication_deltas = []\n    for r in range(R):\n        # Each replication uses a deterministic seed derived from the base seed.\n        replication_seed = z + r\n        delta = _run_single_replication(T, s, c, x_bar, p_b, p_r, l_bar, replication_seed)\n        replication_deltas.append(delta)\n    \n    # The final estimate is the average of the deltas from all replications,\n    # justified by the Law of Large Numbers.\n    estimated_delta = np.mean(replication_deltas)\n    return estimated_delta\n\ndef _run_single_replication(T, s, c, x_bar, p_b, p_r, l_bar, seed):\n    \"\"\"\n    Performs one full replication (baseline and reminder) using Common Random Numbers (CRN).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Determine the number of scheduled appointment slots.\n    num_appointments = int(T // s)\n    if num_appointments == 0:\n        return 0.0\n\n    # Generate all random variates for the replication using CRN.\n    # These will be shared between the baseline and reminder scenarios.\n    show_no_show_variates = rng.uniform(size=num_appointments)\n    lateness_variates = rng.exponential(scale=l_bar, size=num_appointments) if l_bar > 0 else np.zeros(num_appointments)\n    service_time_variates = rng.exponential(scale=x_bar, size=num_appointments)\n    scheduled_times = np.arange(num_appointments) * s\n\n    # --- Baseline Scenario ---\n    arrivals_baseline = []\n    for i in range(num_appointments):\n        # A patient shows up if their random variate is less than the show probability (1 - p).\n        if show_no_show_variates[i]  (1.0 - p_b):\n            arrival_time = scheduled_times[i] + lateness_variates[i]\n            service_time = service_time_variates[i]\n            arrivals_baseline.append((arrival_time, service_time))\n    throughput_baseline = _process_queue(arrivals_baseline, c, T)\n\n    # --- Reminder Scenario ---\n    arrivals_reminder = []\n    for i in range(num_appointments):\n        # The same logic and CRN are applied, but with the reminder no-show probability.\n        if show_no_show_variates[i]  (1.0 - p_r):\n            arrival_time = scheduled_times[i] + lateness_variates[i]\n            service_time = service_time_variates[i]\n            arrivals_reminder.append((arrival_time, service_time))\n    throughput_reminder = _process_queue(arrivals_reminder, c, T)\n    \n    # The result for this replication is the difference in throughput.\n    return throughput_reminder - throughput_baseline\n\ndef _process_queue(arrivals, num_servers, clinic_duration):\n    \"\"\"\n    Simulates the queueing process for a given list of arrivals and system parameters.\n    Implements the multi-server FIFO queue with a no-overtime policy.\n    \"\"\"\n    if not arrivals:\n        return 0\n\n    # Patients are processed in the order they arrive (First In First Out based on arrival time).\n    sorted_arrivals = sorted(arrivals, key=lambda x: x[0])\n    \n    # Initialize server availability times. All servers are free at time 0.\n    server_availability_times = np.zeros(num_servers)\n    completed_visits = 0\n\n    for arrival_time, service_time in sorted_arrivals:\n        # Find the server that becomes free the earliest.\n        earliest_server_idx = np.argmin(server_availability_times)\n        earliest_free_time = server_availability_times[earliest_server_idx]\n        \n        # Service can only start after the patient has arrived AND a server is free.\n        start_time = max(arrival_time, earliest_free_time)\n        completion_time = start_time + service_time\n        \n        # Apply the no-overtime policy: service must finish by clinic closing time.\n        if completion_time = clinic_duration:\n            completed_visits += 1\n            # Update the availability time of the server that took this patient.\n            server_availability_times[earliest_server_idx] = completion_time\n        # Else, the patient is rejected and does not contribute to throughput.\n            \n    return completed_visits\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "4389599"}]}