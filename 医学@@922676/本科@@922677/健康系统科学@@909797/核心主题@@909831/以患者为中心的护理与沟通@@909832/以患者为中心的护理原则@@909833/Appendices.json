{"hands_on_practices": [{"introduction": "我们无法改善我们无法衡量的东西。患者体验调查是评估以患者为中心的护理的关键工具，但只有当调查本身可靠时，其数据才有用。本练习将向您介绍心理测量学中的一个基本概念——克朗巴赫系数（Cronbach's $\\alpha$），用于评估调查量表的内部一致性，以确保其真正衡量的是“以患者为中心”这一预期构念。[@problem_id:4385617]", "problem": "一个卫生系统部署了一项患者体验调查，以评估以患者为中心的护理原则，包括尊重患者偏好、清晰沟通、共同决策、对需求的响应、护理协调和情感支持。该调查使用一个包含$k$个项目的多项目量表，每个项目均在1到5的李克特量表上评分，量表总分定义为所有项目分数的未加权总和。假设经典测试理论（CTT）成立，且该量表旨在捕捉“以患者为中心的护理”这单一潜在构念。\n\n考虑一个假设的包含$k = 6$个项目的量表，其从一个大样本中凭经验估计出的属性如下：\n- 每个项目的方差为$\\sigma_{i}^{2} = 0.64$（所有项目相同）。\n- 对于$i \\neq j$，所有非对角线上的项目协方差均等于$\\operatorname{Cov}(X_{i}, X_{j}) = 0.256$。\n- 量表总分为$T = \\sum_{i=1}^{k} X_{i}$。\n\n运用经典测试理论中关于方差、协方差和内部一致性的基本定义，计算该量表的克隆巴赫alpha系数，并根据您的计算值，解释其内部一致性信度是否足以用于比较不同临床单位之间的患者体验。将您的数值答案四舍五入至四位有效数字。最终数值无需单位。", "solution": "该问题陈述经过仔细审查，被认为是有效的。它在科学上基于经典测试理论，问题设定良好，数据充分且一致，陈述客观。\n\n目标是计算一个包含$k$个项目的量表的克隆巴赫alpha系数（$\\alpha$）并解释其值。克隆巴赫alpha系数是内部一致性的一个度量，用于估计心理测量测试的信度。它被定义为总分方差中可归因于真实分数方差的比例。\n\n克隆巴赫alpha系数的标准公式是：\n$$\n\\alpha = \\frac{k}{k-1} \\left( 1 - \\frac{\\sum_{i=1}^{k} \\sigma_{i}^{2}}{\\sigma_{T}^{2}} \\right)\n$$\n其中，$k$是项目数，$\\sigma_{i}^{2}$是项目$i$得分的方差，$\\sigma_{T}^{2}$是总分$T$的方差。\n\n从问题陈述中，我们得到以下信息：\n- 项目数：$k = 6$\n- 每个项目的方差：对于所有$i = 1, \\dots, 6$，$\\sigma_{i}^{2} = 0.64$\n- 任意两个不同项目之间的协方差：对于所有$i \\neq j$，$\\operatorname{Cov}(X_{i}, X_{j}) = 0.256$\n\n首先，我们计算项目方差的总和。由于所有项目方差都相同：\n$$\n\\sum_{i=1}^{k} \\sigma_{i}^{2} = k \\times \\sigma_{i}^{2} = 6 \\times 0.64 = 3.84\n$$\n\n接下来，我们必须计算总分的方差$\\sigma_{T}^{2}$。总分$T$是各个项目得分的总和，$T = \\sum_{i=1}^{k} X_{i}$。随机变量之和的方差是其协方差矩阵中所有元素的总和：\n$$\n\\sigma_{T}^{2} = \\operatorname{Var}(T) = \\operatorname{Var}\\left(\\sum_{i=1}^{k} X_{i}\\right) = \\sum_{i=1}^{k} \\operatorname{Var}(X_{i}) + \\sum_{i \\neq j} \\operatorname{Cov}(X_{i}, X_{j})\n$$\n第一项是协方差矩阵对角线上方差的总和。我们已经计算出其值为$3.84$。\n第二项是所有非对角线协方差的总和。一个$k \\times k$协方差矩阵中非对角线元素的数量是$k(k-1)$。对于$k=6$，有$6(6-1) = 30$个这样的项。\n由于所有非对角线协方差都等于$0.256$，其总和为：\n$$\n\\sum_{i \\neq j} \\operatorname{Cov}(X_{i}, X_{j}) = k(k-1) \\times \\operatorname{Cov}(X_{i}, X_{j}) = 30 \\times 0.256 = 7.68\n$$\n现在，我们可以计算总分方差：\n$$\n\\sigma_{T}^{2} = 3.84 + 7.68 = 11.52\n$$\n\n所有组成部分都计算出来后，我们将它们代入克隆巴赫alpha系数的公式中：\n$$\n\\alpha = \\frac{k}{k-1} \\left( 1 - \\frac{\\sum_{i=1}^{k} \\sigma_{i}^{2}}{\\sigma_{T}^{2}} \\right) = \\frac{6}{6-1} \\left( 1 - \\frac{3.84}{11.52} \\right)\n$$\n我们简化括号内的分数：\n$$\n\\frac{3.84}{11.52} = \\frac{1}{3}\n$$\n将此结果代回$\\alpha$的方程中：\n$$\n\\alpha = \\frac{6}{5} \\left( 1 - \\frac{1}{3} \\right) = \\frac{6}{5} \\left( \\frac{2}{3} \\right) = \\frac{12}{15} = \\frac{4}{5} = 0.8\n$$\n克隆巴赫alpha系数的计算值恰好为$0.8$。\n\n或者，由于项目方差和项目间协方差是恒定的，我们可以使用标准化公式（用平均协方差和平均方差表示）：\n$$\n\\alpha = \\frac{k \\bar{c}}{\\bar{v} + (k-1) \\bar{c}}\n$$\n其中$\\bar{v}$是平均项目方差，$\\bar{c}$是平均非对角线协方差。\n已知$\\bar{v} = \\sigma_{i}^{2} = 0.64$且$\\bar{c} = \\operatorname{Cov}(X_{i}, X_{j}) = 0.256$：\n$$\n\\alpha = \\frac{6 \\times 0.256}{0.64 + (6-1) \\times 0.256} = \\frac{1.536}{0.64 + 5 \\times 0.256} = \\frac{1.536}{0.64 + 1.28} = \\frac{1.536}{1.92} = 0.8\n$$\n两种方法得出相同的结果。\n\n问题要求将数值答案四舍五入到四位有效数字。计算值为$0.8000$。\n\n在解释方面，克隆巴赫alpha系数为$0.8$表示总分方差的$80\\%$可归因于“以患者为中心的护理”这一真实潜在构念，而$20\\%$是由于随机测量误差。一般的心理测量学指南将信度系数分类如下：$\\ge 0.9$（优秀），$0.8 - 0.9$（良好），$0.7 - 0.8$（可接受），$0.6 - 0.7$（有问题的），以及$0.6$（差/不可接受）。为了比较不同群体（如临床单位）的总分，通常认为信度系数达到$0.8$或更高是必要的，以确保观察到的差异不主要是由测量误差造成的假象。因此，克隆巴赫alpha系数为$0.8$表明内部一致性良好，该量表被认为足以满足其预期目的，即比较不同临床单位之间的患者体验。\n\n最终数值答案，四舍五入到四位有效数字，是$0.8000$。", "answer": "$$\n\\boxed{0.8000}\n$$", "id": "4385617"}, {"introduction": "以患者为中心的护理常常需要在尊重患者自主权与临床医生促进其福祉的责任之间取得平衡。本练习提供了一个结构化框架，用于分析最经典的伦理挑战之一：家长式作风（paternalism）。通过根据患者的决策能力区分“软性”和“硬性”家长式作风，您将培养在伦理复杂情境中识别临床行为并为其辩护的分析技能。[@problem_id:4385675]", "problem": "以患者为中心的护理的一个核心目标是，在尊重自主、行善、不伤害和公正等伦理原则的同时，使临床行动与患者的价值观和偏好保持一致。在临床伦理学中，知情同意要求具备四种能力——理解、领会、推理和表达选择——以及自愿性。令 $U$ 代表理解，$A_p$ 代表领会，$R$ 代表推理，$Ch$ 代表表达选择，$V$ 代表自愿性。将决策能力定义为二元变量 $C \\in \\{0,1\\}$，使得\n$$\nC = 1 \\text{ 当且仅当 } U=1 \\land A_p=1 \\land R=1 \\land Ch=1 \\land V=1,\n$$\n否则 $C=0$。家长式临床干预 $I$ 是一种限制或推翻患者即时偏好 $P$ 的行为，其目的是促进患者的福祉 $W$。\n\n在此框架下：\n- 软家长主义指的是仅在 $C=0$ 或患者的选择并非完全知情或自愿（例如 $U=0$ 或 $V=0$）时采取的干预 $I$，其目标是恢复知情、自愿的决策能力，然后遵从患者的偏好 $P$。\n- 硬家长主义指的是尽管 $C=1$ 且 $V=1$，但当患者知情、自愿的选择与临床医生对患者福祉 $W$ 的评估相冲突时，推翻患者偏好 $P$ 的干预 $I$。\n\n请思考以下思想实验及相关的分类主张和实践中可验证的标志。选择所有正确对场景进行分类（软家长主义与硬家长主义），并指明能为该分类在实践中提供依据的适当、可验证的标志的选项。\n\nA. 一名 $54$ 岁的转移性癌症患者再三拒绝化疗。在多次会面中，临床医生使用回授法确认 $U=1$，记录了 $A_p=1$，引出了一致的 $Ch=1$，并评估了 $R=1$；没有胁迫的证据，因此 $V=1$，故而 $C=1$。然而，医疗团队仍以“为他好”为由，对患者施以镇静并进行化疗。他们将此行为归类为硬家长主义，并引用的标志包括：完成的回授法显示患者理解风险效益、结构化的能力评估，以及在知情拒绝后进行强迫治疗的记录。\n\nB. 一名 $68$ 岁的患者因误读数字风险信息（他认为自己的中风风险是 $1\\%$，而根据其情况，年风险约为 $10\\%$）而拒绝为心房颤动进行抗凝治疗。临床医生推迟了决定，使用回授法纠正了患者的理解 $U$（患者能准确复述 $10\\%$ 与 $1\\%$ 的区别），探讨了价值观，并重新评估了其能力，之后患者自愿选择了抗凝治疗。医疗团队将最初的干预归类为软家长主义，并引用的标志包括：初次回授失败（$U=0$）、随后的回授成功（$U=1$）、计算能力提高的记录，以及没有胁迫（$V=1$），并且在继续下一步前恢复了决策能力 $C$。\n\nC. 一名 $36$ 岁的患者有明确记录的决策能力（$C=1$），他拒绝他汀类药物治疗。临床医生威胁说，除非患者接受治疗，否则将不再为他看诊，并以患者的心血管风险“极高”为由，将此立场辩解为软家长主义，引用的标志包括伤害的严重程度和临床医生防止伤害的责任。\n\nD. 一名 $62$ 岁的患者因创伤送达时已失去意识。在没有代理人立即可联络且不知有无预立医疗指示的情况下，医疗团队根据默示同意启动了挽救生命的输血。他们将此行为归类为硬家长主义，并引用的标志包括缺乏正式同意和高死亡风险。\n\n选择所有正确选项。", "solution": "题目陈述提供了一个正式的逻辑框架，用于根据患者的决策能力 $C$ 将临床干预分为软家长主义或硬家长主义。我们必须根据这个框架来验证每个选项。\n\n所提供的定义如下：\n1.  **决策能力 ($C$)**：一个二元变量 $C \\in \\{0, 1\\}$。当且仅当所有五个条件都满足时，即具备决策能力，$C=1$：理解 ($U=1$)、领会 ($A_p=1$)、推理 ($R=1$)、表达选择 ($Ch=1$) 和自愿性 ($V=1$)。形式上：\n    $$C = 1 \\iff (U=1 \\land A_p=1 \\land R=1 \\land Ch=1 \\land V=1)$$\n    如果这些条件中有任何一个不满足，则 $C=0$。\n\n2.  **软家长主义**：在 $C=0$ 时采取的、推翻患者偏好的干预。其目标是恢复患者做出知情、自愿决定的能力（即恢复 $C=1$ 的条件），然后尊重患者的偏好。\n\n3.  **硬家长主义**：在患者具有完全决策能力（即 $C=1$）的情况下，仍然推翻其偏好的干预。\n\n现在我们将把这些定义应用于所述场景，以评估每个选项。\n\n**选项A分析**\n\n*   **场景**：一名 $54$ 岁的癌症患者拒绝化疗。临床团队违背患者意愿继续进行治疗。\n*   **能力评估**：题目陈述临床医生已确认 $U=1$（通过回授法确认理解）、$A_p=1$（记录了领会）、$R=1$（评估了推理）、$Ch=1$（表达了一致的选择）和 $V=1$（无胁迫）。\n*   **应用 $C$ 的定义**：由于 $U=1$, $A_p=1$, $R=1$, $Ch=1$, 和 $V=1$，所有决策能力的条件都已满足。因此，$C=1$。\n*   **干预与分类**：尽管患者具有完全的决策能力（$C=1$），团队仍然推翻了患者表达的偏好（拒绝化疗）。根据所提供的框架，推翻一个具有 $C=1$ 的患者偏好的干预，根据定义是**硬家长主义**。该选项正确地将此行为如此分类。\n*   **可验证的标志**：该选项引用了“完成的回授法显示患者理解风险效益、结构化的能力评估，以及在知情拒绝后进行强迫治疗的记录”。这些标志正是确定患者当时具有 $C=1$（通过各种评估）以及患者的知情、自愿选择随后被推翻所需的证据。这些标志正确地为该分类提供了依据。\n*   **结论**：根据题目的定义，该分类是正确的，并且所引用的标志是适当且足以支持该分类的。**正确**。\n\n**选项B分析**\n\n*   **场景**：一名 $68$ 岁的患者最初因对风险的误解而拒绝抗凝治疗。\n*   **初始能力评估**：患者“误读了数字风险信息”，认为自己的中风风险是 $1\\%$，而实际上大约是 $10\\%$。这构成了理解上的失败，因此最初 $U=0$。\n*   **应用 $C$ 的定义**：由于 $U=0$，至少有一个 $C=1$ 的条件未被满足。因此，在最初拒绝时，患者的决策能力受损，即 $C=0$。\n*   **干预与分类**：临床医生的干预包括推迟决定并使用回授法来纠正患者的理解 ($U$)。其目标是恢复患者做出知情决定的能力。此行为完全符合**软家长主义**的定义：在 $C=0$ 时为恢复能力而采取的干预。干预后，患者在 $U=1$ 且恢复了决策能力的情况下，做出了自愿的选择。该选项正确地将此干预归类为软家长主义。\n*   **可验证的标志**：该选项引用了“初次回授失败（$U=0$）、随后的回授成功（$U=1$）、计算能力提高的记录，以及没有胁迫（$V=1$），并且在继续下一步前恢复了决策能力 $C$”。这些标志可验证地记录了初始状态（因 $U=0$ 导致 $C=0$）、干预的恢复性性质，以及在具备决策能力条件下做出决定的最终状态。这些标志正确地为该分类提供了依据。\n*   **结论**：分类正确，标志适当。**正确**。\n\n**选项C分析**\n\n*   **场景**：一名 $36$ 岁的有记录决策能力的患者拒绝他汀类药物治疗。临床医生威胁患者以迫使其接受治疗。\n*   **能力评估**：题目明确指出患者“有记录的决策能力（$C=1$）”。\n*   **干预与分类**：临床医生将威胁辩解为“软家长主义”。然而，软家长主义的定义要求干预是在 $C=0$ 时进行的。既然已知 $C=1$，这个分类是根本错误的。试图推翻一个有能力患者的决定对应的是硬家长主义，而非软家长主义。临床医生的分类与所给定义相矛盾。\n*   **可验证的标志**：临床医生引用“伤害的严重程度和临床医生防止伤害的责任”作为标志。这些是临床医生采取家长式作风的*动机*的理由（基于行善原则），但它们不是用来区分软家长主义和硬家长主义的标志。这种区分完全取决于患者的能力状态（$C=0$ vs. $C=1$），而不是临床风险的大小。所引用的标志与所声称的分类无关。\n*   **结论**：将此行为归类为软家长主义是错误的，因为患者的能力为 $C=1$。所引用的标志也不适合为该分类提供依据。**错误**。\n\n**选项D分析**\n\n*   **场景**：一名 $62$ 岁的患者送达时已失去意识，在默示同意下接受了挽救生命的治疗。\n*   **能力评估**：一个失去意识的人无法执行决策能力所需的任何功能：他们无法理解（$U=0$）、领会（$A_p=0$）、推理（$R=0$）或表达选择（$Ch=0$）。\n*   **应用 $C$ 的定义**：由于多个条件不满足，患者的决策能力为 $C=0$。\n*   **干预与分类**：团队将他们的行为归类为“硬家长主义”。这是错误的。硬家长主义的定义要求患者具有决策能力，即 $C=1$。由于患者失去意识且 $C=0$，不满足硬家长主义的条件。从伦理上讲，这种情况通常由知情同意的紧急例外情况（默示同意）来处理，但如果要在给定的家长主义框架内进行分类，它应该属于软家长主义，因为干预发生在 $C=0$ 的时候。\n*   **可验证的标志**：引用的标志是“缺乏正式同意和高死亡风险”。缺乏同意是 $C=0$ 的直接后果，而高死亡风险为紧急行动提供了理由。然而，这些标志并不支持硬家长主义的分类；事实上，失去意识的证据证明了患者不具备能力（$C=0$），这直接与硬家长主义的定义相矛盾。\n*   **结论**：将此行为归类为硬家长主义是错误的。**错误**。\n\n根据分析，选项A和B正确地应用了所提供的伦理框架，并指出了适当的可验证标志。", "answer": "$$\\boxed{AB}$$", "id": "4385675"}, {"introduction": "超越个体诊疗，卫生系统科学旨在构建本质上以患者为中心的流程。本实践挑战您创建一个分诊算法，在选择沟通方式时平衡临床安全性、患者偏好和系统资源。通过将这些权衡形式化为一个损失函数，您将学习如何设计和评估一个既高效又符合伦理的临床工作流程。[@problem_id:4385628]", "problem": "您的任务是形式化一个分诊决策规则，并计算在一个以患者为中心的护理场景中，为分配同步与异步通信模式的性能指标。您必须严格遵循以患者为中心的护理的基本原则来设计算法，即同时履行最小化伤害和尊重患者偏好的义务，同时确保可行性和效率。您的实现必须基于一个量化的决策框架，而不依赖于任何预先指定的决策规则。程序必须为提供的测试套件生成输出，且最终输出格式必须符合本问题末尾的规范。\n\n基本和核心定义：\n- 以患者为中心的护理要求系统为每位患者平衡安全性和偏好尊重。让一位患者由一个三元组 $(a_i, p_i, l_i)$ 表示，其中 $a_i \\in [0,1]$ 是临床紧急程度（值越高表示越紧急），$p_i \\in [0,1]$ 是对同步通信的偏好强度（值接近 $1$ 表示强烈偏好同步；值接近 $0$ 表示强烈偏好异步），$l_i \\in [0,1]$ 是数字素养可行性（值越高表示使用异步工具的能力越强）。\n- 存在两种模式：同步 ($S$) 和异步 ($A$)。\n- 系统使用一个源自以患者为中心的护理原则的加权损失框架。损失分量定义如下：\n  - 如果对高紧急度情况使用异步模式，安全损失会更高。这由一个应用于异步模式下紧急程度的权重 $k_s$ 和一个用于同步模式的较小残余风险 $r_s$ 来参数化。\n  - 当所选模式偏离患者偏好时，偏好不匹配损失会更高。这由一个应用于不匹配程度的权重 $k_p$ 来参数化。\n  - 对于异步模式，当数字素养较低时，可行性损失会增加。这由一个应用于与完全素养差距的权重 $k_l$ 来参数化。\n  - 系统资源强度由同步模式的固定成本 $c_s$ 和异步模式的固定成本 $c_a$ 表示。\n- 基于以上定义，仅使用已定义的分量和权重，为每种模式 $m \\in \\{S, A\\}$ 构建一个患者层面的期望损失函数 $L_i(m)$。您必须推导并为每位患者选择最小化期望损失的模式。\n\n在所有计算中使用的常量：\n- $k_p = 1.0$, $k_s = 3.0$, $k_l = 1.0$, $c_s = 0.5$, $c_a = 0.1$, $r_s = 0.2$.\n- 高紧急度阈值 $\\tau = 0.7$。\n- 用于一致性评估的偏好分类：如果 $p_i \\geq 0.5$，则认为患者偏好同步；否则，患者偏好异步。\n\n每个数据集需要计算的性能指标：\n1. 偏好一致率：分配的模式与上述离散偏好分类相匹配的患者比例（以小数表示）。\n2. 高紧急度安全性灵敏度：$a_i \\geq \\tau$ 的患者中被分配为同步模式的比例（以小数表示）。如果数据集中没有高紧急度患者，则按惯例将此指标定义为 $1.0$。\n3. 同步容量溢出：给定一个数据集级别的同步容量 $C_S$（一个整数），计算超出容量的同步决策分配数量，即 $\\max(0, N_S - C_S)$，其中 $N_S$ 是同步分配的总数。以整数形式报告。\n4. 每位患者的平均损失：在分配模式后，计算所选的每位患者损失的算术平均值。\n5. 素养公平差距：计算高素养组（定义为 $l_i \\geq 0.7$）和低素养组（定义为 $l_i  0.7$）的偏好一致率之间的绝对差异（以小数表示）。如果任一组没有患者，则将此差距定义为 $0.0$。\n\n所有小数值指标必须四舍五入到三位小数。不涉及物理单位。\n\n测试套件：\n每个测试用例由一个同步容量 $C_S$ 和一个患者列表 $(a_i, p_i, l_i)$ 指定。\n\n- 数据集 $1$（理想路径，混合紧急度和偏好，中等容量）：\n  - $C_S = 3$\n  - 患者：\n    - $(a_1, p_1, l_1) = (0.2, 0.3, 0.9)$\n    - $(a_2, p_2, l_2) = (0.8, 0.7, 0.6)$\n    - $(a_3, p_3, l_3) = (0.6, 0.2, 0.4)$\n    - $(a_4, p_4, l_4) = (0.95, 0.4, 0.7)$\n    - $(a_5, p_5, l_5) = (0.5, 0.9, 0.8)$\n    - $(a_6, p_6, l_6) = (0.1, 0.5, 0.5)$\n- 数据集 $2$（边界情况，全部为高紧急度，容量有限）：\n  - $C_S = 2$\n  - 患者：\n    - $(a_1, p_1, l_1) = (0.75, 0.1, 0.9)$\n    - $(a_2, p_2, l_2) = (0.85, 0.6, 0.7)$\n    - $(a_3, p_3, l_3) = (0.95, 0.9, 0.9)$\n    - $(a_4, p_4, l_4) = (0.8, 0.2, 0.6)$\n    - $(a_5, p_5, l_5) = (0.7, 0.4, 0.8)$\n- 数据集 $3$（低紧急度，高素养，主要偏好异步）：\n  - $C_S = 5$\n  - 患者：\n    - $(a_1, p_1, l_1) = (0.2, 0.1, 0.9)$\n    - $(a_2, p_2, l_2) = (0.3, 0.2, 0.95)$\n    - $(a_3, p_3, l_3) = (0.15, 0.3, 0.8)$\n    - $(a_4, p_4, l_4) = (0.1, 0.4, 0.85)$\n    - $(a_5, p_5, l_5) = (0.25, 0.2, 0.9)$\n    - $(a_6, p_6, l_6) = (0.35, 0.3, 0.8)$\n- 数据集 $4$（极端情况，同步容量为零，混合紧急度和素养）：\n  - $C_S = 0$\n  - 患者：\n    - $(a_1, p_1, l_1) = (0.9, 0.9, 0.2)$\n    - $(a_2, p_2, l_2) = (0.4, 0.6, 0.6)$\n    - $(a_3, p_3, l_3) = (0.8, 0.4, 0.9)$\n    - $(a_4, p_4, l_4) = (0.7, 0.6, 0.5)$\n\n要求的最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔的结果列表。每个数据集的指标必须按以下顺序报告为一个列表：[concordance, safety_sensitivity, capacity_overflow, average_loss, equity_gap]。因此，总输出必须是这些每个数据集列表的列表，例如：[[d1_m1,d1_m2,d1_m3,d1_m4,d1_m5],[d2_m1,d2_m2,d2_m3,d2_m4,d2_m5],...]。所有小数必须四舍五入到三位小数，整数必须是精确值。", "solution": "该问题陈述经确认为具有科学依据、定义明确且客观。它提出了一个量化建模的挑战，该挑战是自洽的、逻辑一致的，并且没有科学或事实上的不健全之处。任务是从基本原则出发，形式化一个决策规则，实施它，并计算指定的性能指标。\n\n问题的核心是为每种模式 $m \\in \\{S, A\\}$（同步，异步）构建并最小化一个患者层面的期望损失函数 $L_i(m)$，该函数基于以患者为中心的护理原则。损失函数的构建必须源自所提供的定义。\n\n**1. 损失函数的推导**\n\n对于由三元组 $(a_i, p_i, l_i)$ 代表的每位患者 $i$，我们定义分配同步护理的损失 $L_i(S)$ 和异步护理的损失 $L_i(A)$。这些函数是代表安全性、偏好不匹配、可行性和资源成本的加权组成部分的总和。\n\n**同步模式 ($S$) 的损失函数**\n将模式 $S$ 分配给患者 $i$ 的总损失为 $L_i(S)$。它由以下部分组成：\n- **安全损失：** 问题陈述指明同步护理存在“一个较小的残余风险 $r_s$”。此风险与临床紧急程度 $a_i$ 成正比。因此，安全损失为 $r_s a_i$。\n- **偏好不匹配损失：** 患者对同步护理的偏好强度为 $p_i$。对异步护理的偏好可建模为 $1-p_i$。分配同步护理会与对异步的偏好产生不匹配。这种不匹配的程度是 $1-p_i$。乘以权重 $k_p$，此损失为 $k_p(1-p_i)$。\n- **可行性损失：** 问题明确指出此损失仅适用于异步护理。因此，同步护理的可行性损失为 $0$。\n- **资源强度成本：** 一个固定成本 $c_s$ 与同步护理相关联。\n\n将这些分量相加，同步模式的总损失为：\n$$L_i(S) = r_s a_i + k_p (1-p_i) + c_s$$\n\n**异步模式 ($A$) 的损失函数**\n将模式 $A$ 分配给患者 $i$ 的总损失为 $L_i(A)$。它由以下部分组成：\n- **安全损失：** 对于异步护理，安全损失被明确定义为通过一个权重 $k_s$ 应用于紧急程度来参数化，从而得到项 $k_s a_i$。\n- **偏好不匹配损失：** 分配异步护理会与对同步的偏好 $p_i$ 产生不匹配。乘以权重 $k_p$，此损失为 $k_p p_i$。\n- **可行性损失：** 此损失随着数字素养 $l_i$ 的降低而增加。它被定义为一个权重 $k_l$ 应用于“与完全素养的差距”，即 $(1-l_i)$。因此，损失为 $k_l(1-l_i)$。\n- **资源强度成本：** 一个固定成本 $c_a$ 与异步护理相关联。\n\n将这些分量相加，异步模式的总损失为：\n$$L_i(A) = k_s a_i + k_p p_i + k_l (1-l_i) + c_a$$\n\n**2. 分诊决策规则**\n\n每位患者的最优模式是最小化总期望损失的那一个。决策规则是：\n$$ \\text{分配模式 } m_i^* = \\begin{cases} S  \\text{如果 } L_i(S) \\leq L_i(A) \\\\ A  \\text{如果 } L_i(S)  L_i(A) \\end{cases} $$\n在相等的情况下（$L_i(S) = L_i(A)$），我们选择同步模式 ($S$) 作为决胜规则，这反映了一种保守偏向，即倾向于模型中固有安全风险较低的模式（$r_s  k_s$）。为患者 $i$ 选择的损失是 $L_i(m_i^*)$。\n\n**3. 性能指标计算**\n\n对于一个给定的包含 $N$ 位患者的数据集和一个同步容量 $C_S$，在对所有患者应用决策规则后，计算以下指标。\n\n**指标 1：偏好一致率 ($M_1$)**\n如果 $p_i \\geq 0.5$，患者的偏好被分类为同步；如果 $p_i  0.5$，则为异步。一致的分配集合是 $C = \\{i \\mid (m_i^*=S \\land p_i \\geq 0.5) \\lor (m_i^*=A \\land p_i  0.5)\\}$。该比率为：\n$$M_1 = \\frac{|C|}{N}$$\n\n**指标 2：高紧急度安全性灵敏度 ($M_2$)**\n设 $H = \\{i \\mid a_i \\geq \\tau\\}$ 为高紧急度患者集合，其中 $\\tau = 0.7$。设 $H_S = \\{i \\in H \\mid m_i^*=S\\}$ 为被分配到同步护理的高紧急度患者子集。灵敏度为：\n$$M_2 = \\begin{cases} 1.0  \\text{如果 } |H| = 0 \\\\ \\frac{|H_S|}{|H|}  \\text{如果 } |H|  0 \\end{cases}$$\n\n**指标 3：同步容量溢出 ($M_3$)**\n设 $N_S$ 为被分配到同步模式的患者总数，$N_S = |\\{i \\mid m_i^*=S\\}|$。溢出量为：\n$$M_3 = \\max(0, N_S - C_S)$$\n\n**指标 4：每位患者的平均损失 ($M_4$)**\n这是数据集中所有患者的最小损失的算术平均值：\n$$M_4 = \\frac{1}{N} \\sum_{i=1}^{N} L_i(m_i^*)$$\n\n**指标 5：素养公平差距 ($M_5$)**\n患者被划分为高素养组 $G_{high} = \\{i \\mid l_i \\geq 0.7\\}$ 和低素养组 $G_{low} = \\{i \\mid l_i  0.7\\}$。设 $M_{1,high}$ 和 $M_{1,low}$ 分别是专门为这两个组计算的偏好一致率。差距为：\n$$M_5 = \\begin{cases} 0.0  \\text{如果 } |G_{high}|=0 \\text{ 或 } |G_{low}|=0 \\\\ |M_{1,high} - M_{1,low}|  \\text{其他情况} \\end{cases}$$\n\n所有小数值结果（$M_1, M_2, M_4, M_5$）都要求四舍五入到三位小数。该实现将系统地将这些计算应用于每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and generate the final output.\n    \"\"\"\n\n    # Define constants from the problem statement.\n    CONSTANTS = {\n        'k_p': 1.0, 'k_s': 3.0, 'k_l': 1.0,\n        'c_s': 0.5, 'c_a': 0.1, 'r_s': 0.2\n    }\n    HIGH_ACUITY_THRESHOLD = 0.7\n    PREFERENCE_THRESHOLD = 0.5\n    LITERACY_THRESHOLD = 0.7\n\n    # Define the test suite.\n    test_suite = [\n        {\n            \"C_S\": 3,\n            \"patients\": [\n                (0.2, 0.3, 0.9), (0.8, 0.7, 0.6), (0.6, 0.2, 0.4),\n                (0.95, 0.4, 0.7), (0.5, 0.9, 0.8), (0.1, 0.5, 0.5)\n            ]\n        },\n        {\n            \"C_S\": 2,\n            \"patients\": [\n                (0.75, 0.1, 0.9), (0.85, 0.6, 0.7), (0.95, 0.9, 0.9),\n                (0.8, 0.2, 0.6), (0.7, 0.4, 0.8)\n            ]\n        },\n        {\n            \"C_S\": 5,\n            \"patients\": [\n                (0.2, 0.1, 0.9), (0.3, 0.2, 0.95), (0.15, 0.3, 0.8),\n                (0.1, 0.4, 0.85), (0.25, 0.2, 0.9), (0.35, 0.3, 0.8)\n            ]\n        },\n        {\n            \"C_S\": 0,\n            \"patients\": [\n                (0.9, 0.9, 0.2), (0.4, 0.6, 0.6),\n                (0.8, 0.4, 0.9), (0.7, 0.6, 0.5)\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_suite:\n        C_S = case[\"C_S\"]\n        patients = np.array(case[\"patients\"])\n        metrics = process_dataset(patients, C_S, CONSTANTS, HIGH_ACUITY_THRESHOLD, PREFERENCE_THRESHOLD, LITERACY_THRESHOLD)\n        all_results.append(metrics)\n\n    # Format the final output string.\n    output_str = \"[\" + \",\".join([f\"[{m1:.3f},{m2:.3f},{m3},{m4:.3f},{m5:.3f}]\" for m1, m2, m3, m4, m5 in all_results]) + \"]\"\n    print(output_str)\n\ndef process_dataset(patients, C_S, const, tau, pref_thresh, lit_thresh):\n    \"\"\"\n    Processes a single dataset to compute all five performance metrics.\n    \"\"\"\n    num_patients = len(patients)\n    if num_patients == 0:\n        return [0.0, 1.0, 0, 0.0, 0.0]\n\n    assignments = []\n    chosen_losses = []\n    \n    # Unpack constants\n    k_p, k_s, k_l = const['k_p'], const['k_s'], const['k_l']\n    c_s, c_a, r_s = const['c_s'], const['c_a'], const['r_s']\n\n    for a_i, p_i, l_i in patients:\n        # Calculate loss for each modality\n        loss_S = r_s * a_i + k_p * (1 - p_i) + c_s\n        loss_A = k_s * a_i + k_p * p_i + k_l * (1 - l_i) + c_a\n        \n        # Apply decision rule (S on tie)\n        if loss_S = loss_A:\n            assignments.append('S')\n            chosen_losses.append(loss_S)\n        else:\n            assignments.append('A')\n            chosen_losses.append(loss_A)\n    \n    # METRIC 1: Preference Concordance Rate\n    concordant_count = 0\n    for i, (a_i, p_i, l_i) in enumerate(patients):\n        prefers_S = (p_i >= pref_thresh)\n        assigned_S = (assignments[i] == 'S')\n        if (prefers_S and assigned_S) or (not prefers_S and not assigned_S):\n            concordant_count += 1\n    m1_concordance = concordant_count / num_patients if num_patients > 0 else 0.0\n\n    # METRIC 2: Safety Sensitivity for High Acuity\n    high_acuity_patients_indices = [i for i, p in enumerate(patients) if p[0] >= tau]\n    if not high_acuity_patients_indices:\n        m2_safety_sensitivity = 1.0\n    else:\n        high_acuity_assigned_S = sum(1 for i in high_acuity_patients_indices if assignments[i] == 'S')\n        m2_safety_sensitivity = high_acuity_assigned_S / len(high_acuity_patients_indices)\n\n    # METRIC 3: Synchronous Capacity Overflow\n    N_S = assignments.count('S')\n    m3_overflow = max(0, N_S - C_S)\n\n    # METRIC 4: Average Loss per Patient\n    m4_avg_loss = np.mean(chosen_losses) if chosen_losses else 0.0\n\n    # METRIC 5: Literacy Equity Gap\n    high_lit_indices = [i for i, p in enumerate(patients) if p[2] >= lit_thresh]\n    low_lit_indices = [i for i, p in enumerate(patients) if p[2]  lit_thresh]\n    \n    if not high_lit_indices or not low_lit_indices:\n        m5_equity_gap = 0.0\n    else:\n        # Concordance for high literacy group\n        high_lit_concordant = sum(1 for i in high_lit_indices if ((patients[i][1] >= pref_thresh and assignments[i] == 'S') or (patients[i][1]  pref_thresh and assignments[i] == 'A')))\n        concordance_high = high_lit_concordant / len(high_lit_indices)\n        \n        # Concordance for low literacy group\n        low_lit_concordant = sum(1 for i in low_lit_indices if ((patients[i][1] >= pref_thresh and assignments[i] == 'S') or (patients[i][1]  pref_thresh and assignments[i] == 'A')))\n        concordance_low = low_lit_concordant / len(low_lit_indices)\n        \n        m5_equity_gap = abs(concordance_high - concordance_low)\n\n    return [m1_concordance, m2_safety_sensitivity, m3_overflow, m4_avg_loss, m5_equity_gap]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "4385628"}]}