{"hands_on_practices": [{"introduction": "在分析基因组数据之前，我们必须评估其质量。最基本的质量指标是测序覆盖度，它告诉我们基因组中的每个碱基平均被测序了多少次。本练习探讨了经典的 Lander-Waterman 模型，该模型使用泊松分布来描述覆盖深度，使我们能够理解测序投入与最终基因组序列完整性之间的关系。[@problem_id:4688546]", "problem": "一个公共卫生实验室为监测目的，对一种细菌病原体进行全基因组测序（WGS）。基因组长度为 $G=5\\times 10^{6}$ 个碱基对。一次 Illumina 测序运行产生 $N=10^{7}$ 个独立的双末端簇，但为简化起见，您可以将它们视为 $N$ 个独立的单端读段，每个读段长度为 $L=150$ 个碱基对。假设读段的起始位置在所有允许的起始位点上均匀分布，且各读段之间相互独立，并假设基因组不具重复性，因此每个读段都能唯一比对。由于 $G \\gg L$，可以忽略边缘效应，并将允许的起始位点集合近似为 $G$ 个位置。将给定碱基的覆盖深度定义为，其比对跨度包含该碱基的读段数量。\n\n从概率论的核心定义和关于独立抽样的成熟理论出发，在 $N$ 很大、$L/G$ 很小且 $N L / G$ 为有限值的假设下，推导出固定碱基的覆盖深度分布。然后，计算一个固定碱基未被覆盖的概率。\n\n请以两个封闭形式的解析表达式给出最终结果：概率质量函数 $P(K=k)$（作为非负整数 $k$ 的函数）和零覆盖概率 $P(K=0)$，两者均使用给定的数值表示。不要进行近似或四舍五入；最终表达式中无需单位。", "solution": "该问题要求根据全基因组测序实验的一组参数，求出基因组上一个固定碱基的覆盖深度的概率分布。我们还必须计算一个碱基具有零覆盖的概率。\n\n**步骤一：问题形式化与单读段概率**\n\n设 $G$ 为基因组长度，$N$ 为独立读段的数量，$L$ 为每个读段的长度。给定值为 $G = 5 \\times 10^6$，$N = 10^7$，$L = 150$。\n\n考虑基因组上任意位置的一个固定碱基。我们需要确定一个随机放置的读段覆盖此碱基的概率。一个读段是一个长度为 $L$ 的序列，起始于某个位置 $s$。该读段的跨度覆盖基因组区间 $[s, s+L-1]$。一个位于位置 $x$ 的固定碱基被此读段覆盖，当且仅当其起始位置 $s$ 满足条件 $s \\leq x \\leq s+L-1$。对 $s$ 重新排列此不等式，可得 $x-L+1 \\leq s \\leq x$。\n\n题目说明读段的起始位置在所有允许的起始位点上均匀分布，这些位点可近似为 $G$ 个可能的位置。在区间 $[x-L+1, x]$ 内的整数起始位置 $s$ 的数量为 $x - (x-L+1) + 1 = L$。这对任何不离基因组末端太近的碱基位置 $x$ 都成立。题目陈述明确允许我们忽略这些边缘效应，因为 $G \\gg L$。\n\n因此，对于单个读段，能覆盖该固定碱基的有利起始位置有 $L$ 个。可能的起始位置总数为 $G$。单个随机选择的读段覆盖该固定碱基的概率 $p$ 为：\n$$p = \\frac{\\text{有利起始位点数}}{\\text{总起始位点数}} = \\frac{L}{G}$$\n\n**步骤二：覆盖深度的精确分布**\n\n设 $K$ 是表示固定碱基处覆盖深度的随机变量，即覆盖该碱基的读段总数。我们有 $N$ 个读段，每个读段的放置都是一个独立事件。对于每个读段，我们进行一次伯努利试验：它要么覆盖该碱基（“成功”，概率为 $p$），要么不覆盖（“失败”，概率为 $1-p$）。\n\n在 $N$ 次独立的伯努利试验中，成功的总次数 $K$ 服从二项分布，记为 $K \\sim \\text{Binomial}(N, p)$。二项分布的概率质量函数（PMF）由下式给出：\n$$P(K=k) = \\binom{N}{k} p^k (1-p)^{N-k}$$\n其中 $k$ 是成功次数（覆盖深度），$\\binom{N}{k} = \\frac{N!}{k!(N-k)!}$ 是二项式系数。\n\n**步骤三：泊松近似**\n\n题目明确要求我们在 $N$ 很大、$p = L/G$ 很小，且乘积 $\\lambda = Np = NL/G$ 为有限常数的假设下推导该分布。这是一组经典条件，在此条件下，二项分布可以精确地用泊松分布来近似。\n\n我们定义平均覆盖深度 $\\lambda$：\n$$\\lambda = Np = \\frac{NL}{G}$$\n\n我们用给定的数值数据计算 $\\lambda$ 的值：\n$$N = 10^7, \\quad L = 150, \\quad G = 5 \\times 10^6$$\n$$\\lambda = \\frac{(10^7) \\times 150}{5 \\times 10^6} = \\frac{1.5 \\times 10^9}{5 \\times 10^6} = 0.3 \\times 10^3 = 300$$\n\n条件成立：\n- $N = 10^7$ 是一个大数。\n- $p = \\frac{L}{G} = \\frac{150}{5 \\times 10^6} = 3 \\times 10^{-5}$ 是一个小编号。\n- $\\lambda = 300$ 是一个有限的、适中的值。\n\n在这些条件下，二项分布的概率质量函数收敛于泊松分布的概率质量函数。因此，覆盖深度 $K$ 的分布是参数为 $\\lambda = 300$ 的泊松分布。\n$$K \\sim \\text{Poisson}(\\lambda)$$\n\n泊松分布的概率质量函数为：\n$$P(K=k) = \\frac{\\lambda^k \\exp(-\\lambda)}{k!}$$\n其中 $k$ 为非负整数，即 $k = 0, 1, 2, \\dots$。\n\n代入计算出的值 $\\lambda=300$，覆盖深度的概率质量函数为：\n$$P(K=k) = \\frac{300^k \\exp(-300)}{k!}$$\n\n该表达式给出了一个固定碱基被恰好 $k$ 个读段覆盖的概率。\n\n**步骤四：零覆盖概率**\n\n任务的第二部分是计算一个固定碱基未被覆盖的概率。这对应于 $k=0$ 的覆盖深度。我们可以通过在泊松概率质量函数中设 $k=0$ 来求得此概率：\n$$P(K=0) = \\frac{\\lambda^0 \\exp(-\\lambda)}{0!}$$\n根据定义，$\\lambda^0 = 1$ 且 $0! = 1$。因此，零覆盖的概率为：\n$$P(K=0) = \\exp(-\\lambda)$$\n\n代入 $\\lambda=300$ 的值，我们得到：\n$$P(K=0) = \\exp(-300)$$\n\n这就是基因组中一个特定的、预先选定的碱基对未被测序的概率。\n\n**最终答案形式**\n\n题目要求以两个封闭形式的解析表达式给出结果：概率质量函数 $P(K=k)$ 和零覆盖概率 $P(K=0)$，并代入数值。\n\n1.  概率质量函数 $P(K=k)$：\n    $$P(K=k) = \\frac{300^k \\exp(-300)}{k!}$$\n2.  零覆盖概率 $P(K=0)$：\n    $$P(K=0) = \\exp(-300)$$\n\n这些即为最终要呈现的表达式。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{300^k \\exp(-300)}{k!}  \\exp(-300) \\end{pmatrix}}$$", "id": "4688546"}, {"introduction": "在拼接出基因组序列并识别出不同菌株间的差异（单核苷酸多态性，即 $SNP$）之后，一个关键问题是：这些病原体在多久之前拥有共同的祖先？本练习将深入探讨分子钟假说，它将突变的累积过程建模为一个泊松过程。通过解决这个问题，你将学会如何将可观察到的遗传距离转化为估算的进化时间线，这是重建传播链的一项关键技能。[@problem_id:4688541]", "problem": "在用于病原体监测的全基因组测序（WGS；Whole-Genome Sequencing）中，通过观察到的成对单核苷酸多态性（SNP）距离来比较两个分离株。假设每个位点的点突变根据一个泊松过程独立发生，每个位点的恒定速率为 $\\mu$（每个位点每年）。在一个包含 $L$ 个独立进化位点的基因组中，沿一个谱系的总突变过程被假定为 $L$ 个独立泊松过程的叠加。在这些假设下，两个分离株自其最近共同祖先分化后，差异会沿着两个谱系累积，到最近共同祖先的时间（TMRCA）用 $t$（单位为年）表示。\n\n从这些基本假设和泊松过程的性质出发，推导一个以观察到的成对SNP计数 $d$、每个位点的突变率 $\\mu$ 和基因组长度 $L$ 表示的到共同祖先的期望时间的表达式。然后使用 $\\mu = 1.0 \\times 10^{-6}$，$L = 5.0 \\times 10^{6}$ 以及观察到的成对SNP距离 $d = 24$ 来评估您的表达式。最终答案以年为单位表示，并将您的数值结果四舍五入到三位有效数字。", "solution": "问题要求基于关于分子进化过程的一系列假设，推导出到最近共同祖先的期望时间（$t$）的表达式，然后对该表达式进行数值计算。\n\n首先，我们必须验证问题陈述的有效性。\n已知条件是：\n1.  单个位点的点突变以泊松过程的形式发生，其恒定速率为 $\\mu$（每个位点每年）。\n2.  基因组由 $L$ 个独立进化的位点组成。\n3.  总突变过程是 $L$ 个独立泊松过程的叠加。\n4.  两个分离株在 $t$ 年前从一个共同祖先分化而来（TMRCA）。\n5.  观察到的成对单核苷酸多态性（SNP）计数为 $d$。\n6.  用于计算的数值为：$\\mu = 1.0 \\times 10^{-6}$，$L = 5.0 \\times 10^{6}$，$d = 24$。\n\n该问题具有科学依据，因为它使用泊松过程来模拟突变，这是分子钟理论和系统发育学中的一个标准和基本假设。问题提取得当，提供了推导 $t$ 的表达式并随后计算数值所需的所有信息（$d, \\mu, L$）。语言客观而精确。所提供的参数对于微生物基因组学是现实的。因此，该问题被认为是有效的。\n\n我们现在开始推导。\n\n基本假设是，沿着一个谱系在单个位点上发生的突变数量遵循泊松分布。该过程的速率给定为 $\\mu$ 个突变/位点/年。\n\n被比较的两个分离株在过去的时间 $t$ 从它们最近的共同祖先分化。连接这两个分离株的进化路径包括从这个共同祖先分出的两个独立谱系，每个谱系的长度为 $t$。因此，突变累积以在两个分离株之间产生差异的总时间是这两个谱系长度之和，即 $t + t = 2t$ 年。\n\n对于基因组中的单个位点（比如位点 $i$），在总分化时间 $2t$ 内发生的突变数量 $N_i$ 遵循泊松分布。泊松分布的参数，通常表示为 $\\lambda$，是速率和时间间隔的乘积。在这种情况下，速率是 $\\mu$，总时间间隔是 $2t$。因此，单个位点的参数是 $\\lambda_{\\text{site}} = \\mu \\times (2t) = 2\\mu t$。\n所以，对于任何位点 $i$，突变数量 $N_i$ 是一个由以下公式描述的随机变量：\n$$N_i \\sim \\text{Poisson}(2\\mu t)$$\n\n问题陈述基因组由 $L$ 个这样的位点组成，并且它们独立进化。在两个基因组之间观察到的SNP总数，我们用随机变量 $D$ 表示，是 $L$ 个位点上突变的总和：\n$$D = \\sum_{i=1}^{L} N_i$$\n\n泊松分布的一个关键性质是，独立泊松分布随机变量的和也是一个服从泊松分布的随机变量。所得分布的参数是各个分布参数之和。由于 $L$ 个位点中的每一个都具有相同的参数 $\\lambda_{\\text{site}} = 2\\mu t$，因此SNP总数的参数 $\\lambda_{\\text{total}}$ 是：\n$$\\lambda_{\\text{total}} = \\sum_{i=1}^{L} (2\\mu t) = L \\times (2\\mu t) = 2\\mu L t$$\n\n因此，SNP总数 $D$ 是一个遵循以下分布的随机变量：\n$$D \\sim \\text{Poisson}(2\\mu L t)$$\n\n一个服从泊松分布的随机变量的期望值 $E[D]$ 等于其参数 $\\lambda$。因此，两个分离株之间的期望SNP数量是：\n$$E[D] = 2\\mu L t$$\n\n问题提供了*观察到的*成对SNP计数 $d$。在参数估计的背景下，观察到的计数 $d$ 作为期望值 $E[D]$ 的典型估计。这既是矩估计法的基础，也是泊松过程速率的最大似然估计的基础。因此，我们将观察到的计数值设为等于期望值，以求得时间参数 $t$ 的估计值：\n$$d \\approx E[D] = 2\\mu L t$$\n\n重新整理这个方程以求解 $t$，我们得到了到最近共同祖先时间的所需表达式：\n$$t = \\frac{d}{2\\mu L}$$\n\n这是从给定假设推导出的通用表达式。我们现在使用提供的数值来评估这个表达式：\n- 观察到的SNP计数, $d = 24$\n- 每个位点的突变率, $\\mu = 1.0 \\times 10^{-6} \\text{ 年}^{-1}$\n- 基因组长度, $L = 5.0 \\times 10^{6} \\text{ 个位点}$\n\n将这些值代入我们推导出的 $t$ 的公式中：\n$$t = \\frac{24}{2 \\times (1.0 \\times 10^{-6}) \\times (5.0 \\times 10^{6})}$$\n\n首先，我们计算分母的值：\n$$2 \\times (1.0 \\times 10^{-6}) \\times (5.0 \\times 10^{6}) = 2 \\times 1.0 \\times 5.0 \\times 10^{-6} \\times 10^{6} = 10.0 \\times 10^{0} = 10.0$$\n分母的单位是 年$^{-1}$。\n\n现在，我们可以计算 $t$：\n$$t = \\frac{24}{10.0} = 2.4 \\text{ years}$$\n\n问题要求最终的数值答案四舍五入到三位有效数字。计算出的值 $2.4$ 有两位有效数字。为了用三位有效数字表示，我们写作 $2.40$。", "answer": "$$\\boxed{2.40}$$", "id": "4688541"}, {"introduction": "病原体监测的最终目标是识别和追踪疫情集群，以指导公共卫生干预。这项计算练习通过将成对的 $SNP$ 距离转化为网络图来精确模拟这一过程。你将实现一个算法来识别代表潜在传播集群的连通分量，并分析随着时间推移新增病例，这些集群是如何演变的。[@problem_id:4688569]", "problem": "一组病原体分离株已使用全基因组测序 (WGS) 进行了测序，生成了一个两两配对的单核苷酸多态性 (SNP) 距离矩阵。在固定的传播合理性阈值下，两两配对 SNP 距离小于或等于该阈值的分离株被认为是关联的。这产生了一个无向图，其连通分量在操作上定义了监测聚类。随着时间的推移，新采样的分离株会扩展该图，可能会改变聚类成员关系。任务是计算在指定累积时间快照下的聚类大小，以及一个有原则的稳定性得分，用于衡量已观察分离株的聚类成员关系在连续快照之间的变化。\n\n给定以下基于医学微生物学和图论的定义：\n- 单核苷酸多态性 (SNP) 计数近似于与分子生物学中心法则一致的遗传差异，其中核苷酸水平的差异在复制过程中累积。分离株 $i$ 和 $j$ 之间的两两配对 SNP 距离表示为 $D_{ij}$，其中 $D_{ij} \\in \\mathbb{N}_0$ 且 $D_{ij} = D_{ji}$，$D_{ii} = 0$。\n- 对于选定的阈值 $\\tau \\in \\mathbb{N}_0$，构建一个无向简单图 $G = (V,E)$，其顶点集为 $V = \\{0,1,\\dots,n-1\\}$，边集为 $E = \\{ \\{i,j\\} : D_{ij} \\le \\tau, i \\neq j \\}$。连通分量是 $V$ 的一个最大子集，其中任意两个顶点都由一条路径连接。\n- 分离株在整数时间点 $t_i \\in \\mathbb{Z}$ (例如，天) 进行采样。对于一个非递减的快照时间列表 $T_1, T_2, \\dots, T_K$ (其中 $T_k \\in \\mathbb{Z}$)，将快照 $k$ 处的累积活动集定义为 $S_k = \\{ i \\in V : t_i \\le T_k \\}$。\n- 对于每个快照 $k$，计算由 $S_k$ 导出的图的连通分量，并将分量大小的多重集记录为一个按非递增顺序排序的整数列表。\n- 定义连续快照 $k$ 和 $k+1$ 之间的稳定性得分，以量化先前已见分离株的聚类成员关系如何变化。设 $\\mathcal{P}_k$ 是 $S_k$ 在快照 $k$ 时划分为连通分量的划分，$\\mathcal{P}_{k+1}$ 是 $S_{k+1}$ 的划分。考虑来自较早快照的无序分离株对：$U_k = \\{ \\{i,j\\} : i,j \\in S_k, i  j \\}$。定义指示符 $I_k(i,j) = 1$ (如果 $i$ 和 $j$ 在 $\\mathcal{P}_k$ 的同一区块中)，以及 $I_{k+1}(i,j) = 1$ (如果 $i$ 和 $j$ 在 $\\mathcal{P}_{k+1}$ 的同一区块中，限制于 $S_k \\subseteq S_{k+1}$)。稳定性得分为\n$$\ns_k = \\frac{1}{|U_k|} \\sum_{\\{i,j\\} \\in U_k} \\mathbf{1}\\big( I_k(i,j) = I_{k+1}(i,j) \\big),\n$$\n这是一个在 $[0,1]$ 范围内的小数。\n\n实现一个程序，为每个测试用例计算：\n- 对于每个快照 $k \\in \\{1,\\dots,K\\}$，在 $S_k$ 上导出的图的已排序的连通分量大小列表。\n- 对于每对连续的快照 $(k,k+1)$，稳定性得分 $s_k$，四舍五入到三位小数。\n\n所有时间都是整数天；无需进行物理单位转换。不涉及角度。所有稳定性得分均表示为四舍五入到三位小数的小数。\n\n使用以下测试套件，其中每个测试用例指定 $n$、矩阵 $D$、时间戳列表 $t$、快照列表 $T$ 和阈值 $\\tau$：\n\n- 测试用例 1 (随时间由桥接驱动的合并):\n    - $n = 6$,\n    $$\n    D^{(1)} = \\begin{pmatrix}\n    0  1  4  2  6  6 \\\\\n    1  0  4  2  6  6 \\\\\n    4  4  0  1  6  6 \\\\\n    2  2  1  0  6  6 \\\\\n    6  6  6  6  0  1 \\\\\n    6  6  6  6  1  0\n    \\end{pmatrix},\n    $$\n    $t^{(1)} = [1,2,3,4,5,6]$, $T^{(1)} = [3,5,6]$, $\\tau^{(1)} = 2$.\n- 测试用例 2 (所有分离株都不同的零阈值边界):\n    - $n = 5$,\n    $$\n    D^{(2)} = \\begin{pmatrix}\n    0  3  3  3  3 \\\\\n    3  0  3  3  3 \\\\\n    3  3  0  3  3 \\\\\n    3  3  3  0  3 \\\\\n    3  3  3  3  0\n    \\end{pmatrix},\n    $$\n    $t^{(2)} = [1,2,3,4,5]$, $T^{(2)} = [2,4,5]$, $\\tau^{(2)} = 0$.\n- 测试用例 3 (高阈值全连接增长):\n    - $n = 4$,\n    $$\n    D^{(3)} = \\begin{pmatrix}\n    0  2  1  2 \\\\\n    2  0  2  1 \\\\\n    1  2  0  2 \\\\\n    2  1  2  0\n    \\end{pmatrix},\n    $$\n    $t^{(3)} = [1,2,3,4]$, $T^{(3)} = [2,3,4]$, $\\tau^{(3)} = 3$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。此顶级列表的每个元素对应一个测试用例，并且必须是一个包含两项的列表：\n- 第一项是一个整数列表的列表，其中第 $k$ 个内层列表包含快照 $k$ 处的已排序的连通分量大小。\n- 第二项是一个浮点数列表，保留三位小数，包含每对连续快照的稳定性得分 $s_k$。\n\n例如，输出格式为 $[ \\text{result}_1, \\text{result}_2, \\text{result}_3 ]$，其中每个 $\\text{result}_m$ 的结构为 $[ \\text{SIZES}_m, \\text{STABILITIES}_m ]$。", "solution": "`.\n\n问题验证过程是严格的，并有明确的步骤：\n1.  **提取给定信息**：逐字列出所有提供的数据。\n2.  **使用提取的给定信息进行验证**：检查科学依据、良构性、客观性及其他潜在缺陷。\n3.  **结论与行动**：如果无效，解释原因并输出特定的格式化字符串。如果有效，则继续解决。\n\n解决方案必须以分步、基于原则的方式呈现。\n最终答案必须是一个遵循特定环境约束（`python 3.12`, `numpy 1.23.5`, `scipy 1.11.4`）的独立 Python 脚本。输出格式有明确规定。\n\n让我们从验证过程开始。\n\n### 步骤 1：提取给定信息\n\n- **主题**：使用全基因组测序进行病原体监测。\n- **输入数据**：一个两两配对的单核苷酸多态性 (SNP) 距离矩阵 $D$。\n- **定义**：\n    - SNP 距离 $D_{ij} \\in \\mathbb{N}_0$，满足 $D_{ij} = D_{ji}$，$D_{ii} = 0$。\n    - 传播合理性阈值 $\\tau \\in \\mathbb{N}_0$。\n    - 无向简单图 $G = (V, E)$，其中 $V = \\{0, 1, \\dots, n-1\\}$，$E = \\{ \\{i,j\\} : D_{ij} \\le \\tau, i \\neq j \\}$。\n    - 该图的连通分量是监测聚类。\n    - 分离株具有整数采样时间 $t_i \\in \\mathbb{Z}$。\n    - 非递减的快照时间列表 $T_1, T_2, \\dots, T_K$。\n    - 快照 $k$ 处的累积活动集：$S_k = \\{ i \\in V : t_i \\le T_k \\}$。\n    - 在每个快照 $k$，我们计算由 $S_k$ 导出的图的连通分量。\n    - 分量的输出是分量大小的多重集，按非递增顺序排序。\n    - 快照 $k$ 和 $k+1$ 之间的稳定性得分 $s_k$：\n        - $\\mathcal{P}_k$：$S_k$ 到连通分量的划分。\n        - $\\mathcal{P}_{k+1}$：$S_{k+1}$ 到连通分量的划分。\n        - $U_k = \\{ \\{i,j\\} : i,j \\in S_k, i  j \\}$。\n        - 如果 $i, j$ 在 $\\mathcal{P}_k$ 的同一区块中，则 $I_k(i,j) = 1$，否则为 $0$。\n        - 如果 $i, j$ 在 $\\mathcal{P}_{k+1}$ 的同一区块中，则 $I_{k+1}(i,j) = 1$，否则为 $0$。\n        - 公式：$s_k = \\frac{1}{|U_k|} \\sum_{\\{i,j\\} \\in U_k} \\mathbf{1}\\big( I_k(i,j) = I_{k+1}(i,j) \\big)$。\n        - 这是一个在 $[0,1]$ 范围内的小数。\n- **任务**：\n    1. 对于每个快照 $k \\in \\{1,\\dots,K\\}$，计算在 $S_k$ 上导出的图的已排序的连通分量大小列表。\n    2. 对于每对连续的快照 $(k,k+1)$，计算稳定性得分 $s_k$，四舍五入到三位小数。\n- **测试用例**：\n    - **测试用例 1**：\n        - $n=6$\n        - $D^{(1)} = \\begin{pmatrix} 0  1  4  2  6  6 \\\\ 1  0  4  2  6  6 \\\\ 4  4  0  1  6  6 \\\\ 2  2  1  0  6  6 \\\\ 6  6  6  6  0  1 \\\\ 6  6  6  6  1  0 \\end{pmatrix}$\n        - $t^{(1)} = [1,2,3,4,5,6]$\n        - $T^{(1)} = [3,5,6]$\n        - $\\tau^{(1)} = 2$\n    - **测试用例 2**：\n        - $n=5$\n        - $D^{(2)} = \\begin{pmatrix} 0  3  3  3  3 \\\\ 3  0  3  3  3 \\\\ 3  3  0  3  3 \\\\ 3  3  3  0  3 \\\\ 3  3  3  3  0 \\end{pmatrix}$\n        - $t^{(2)} = [1,2,3,4,5]$\n        - $T^{(2)} = [2,4,5]$\n        - $\\tau^{(2)} = 0$\n    - **测试用例 3**：\n        - $n=4$\n        - $D^{(3)} = \\begin{pmatrix} 0  2  1  2 \\\\ 2  0  2  1 \\\\ 1  2  0  2 \\\\ 2  1  2  0 \\end{pmatrix}$\n        - $t^{(3)} = [1,2,3,4]$\n        - $T^{(3)} = [2,3,4]$\n        - $\\tau^{(3)} = 3$\n- **输出格式**：\n    - 单行：`[result1, result2, result3]`\n    - `result_m = [SIZES_m, STABILITIES_m]`\n    - `SIZES_m` 是一个整数列表的列表。\n    - `STABILITIES_m` 是一个浮点数列表（四舍五入到3位小数）。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n1.  **科学或事实上的不健全性**：该问题基于微生物基因组学和流行病学，特别是使用 WGS 进行病原体监测。使用 SNP 距离推断相关性并定义聚类是一种标准、被广泛接受的做法。使用 SNP 阈值来定义传播聚类是公共卫生中的一种常见操作定义。数学表述（图论）适用于此应用。模板中提到的物理/化学约束（单位转换、角度）被明确说明不相关，这是正确的。该问题在科学和事实上是健全的。\n\n2.  **非形式化或不相关**：该问题是高度形式化的。它将监测聚类的生物学/流行病学概念转化为一个精确的图论问题（连通分量）。定义是严谨的。主题恰好是*医学微生物学*中的*使用全基因组测序进行病原体监测*。\n\n3.  **不完整或矛盾的设置**：该问题是明确的。对于每个测试用例，它提供了所有必要的输入：分离株数量 ($n$)、完整的 SNP 距离矩阵 ($D$)、每个分离株的采样时间 ($t$)、快照时间 ($T$) 和 SNP 阈值 ($\\tau$)。构建图、定义快照和计算输出（分量大小和稳定性得分）的定义是完整且明确的。没有矛盾。距离矩阵的属性（$D_{ij} = D_{ji}$, $D_{ii}=0$）被正确陈述，并且对测试用例成立。\n\n4.  **不切实际或不可行**：SNP 距离是非负整数，这是现实的。采样时间是整数，是有效的离散化。问题规模较小，使其在计算上是可行的。给定数据在维度上是一致的（例如，矩阵大小与 $n$ 匹配）。问题是现实且可行的。\n\n5.  **病态或结构不良**：该问题是良构的。对于给定的图，连通分量是唯一确定的。稳定性得分的计算也是唯一确定的。问题结构清晰，导致唯一的解决方案。术语定义精确（例如，`S_k`、`I_k(i,j)`）。\n\n6.  **伪深刻、微不足道或同义反复**：该问题并非微不足道。它需要实现图遍历算法（如 BFS 或 DFS，或使用并查集数据结构）并仔细管理不同时间点的节点子集。稳定性得分的计算是一个非平凡的聚合，需要仔细实现。这是一个反映现实世界分析任务的真实计算问题。\n\n7.  **超出科学可验证性**：该问题是完全可验证的。计算是确定性的，对于任何给定的输入，输出都可以被独立计算和验证。\n\n### 步骤 3：结论与行动\n\n问题是**有效的**。我将继续进行解答。\n\n### 算法解决方案\n\n该问题要求在离散的时间快照下分析病原体聚类的结构，并量化这些聚类在快照之间的稳定性。解决方案自然分为两个主要部分：首先，确定每个快照下的聚类结构；其次，计算连续快照之间的稳定性得分。\n\n**1. 建模和聚类识别**\n\n问题的核心在于将生物场景转化为正式的数学模型。这是通过图论实现的：\n- 每个病原体分离株表示为图中的一个顶点，$V = \\{0, 1, \\dots, n-1\\}$。\n- 如果两个分离株 $i$ 和 $j$ 的 SNP 距离 $D_{ij}$ 不超过指定的阈值 $\\tau$，则它们之间建立了一条遗传联系。这定义了一条边 $\\{i,j\\}$。\n- 最终得到的无向图 $G = (V, E)$，其中 $E = \\{ \\{i,j\\} : D_{ij} \\le \\tau, i \\neq j \\}$，囊括了所有潜在的传播联系。\n- 在任何给定时间，只有一部分分离株被采样。时间 $T_k$ 的快照考虑了累积的分离株集合 $S_k = \\{ i \\in V : t_i \\le T_k \\}$。\n- 快照 $k$ 处的监测聚类被定义为由顶点集 $S_k$ 诱导的 $G$ 的子图的连通分量。\n\n为了计算每个快照的这些连通分量，不相交集联合 (DSU) 或并查集数据结构是一个高效的选择。单个快照 $k$ 的算法如下：\n1. 识别活动分离株集合 $S_k$。如果 $S_k$ 为空，则没有分量。\n2. 初始化一个包含 $|S_k|$ 个元素的 DSU 结构，每个元素对应 $S_k$ 中的一个分离株。每个分离株最初都在自己的集合中。\n3. 遍历 $S_k$ 内所有唯一的分离株对 $\\{i, j\\}$。\n4. 如果 SNP 距离 $D_{ij} \\le \\tau$，则使用 DSU 的 `union` 操作合并包含 $i$ 和 $j$ 的集合。\n5. 在检查完所有对之后，DSU 结构中的最终集合代表了连通分量（聚类）。\n6. 每个分量的大小是它包含的分离株数量。收集这些大小并按非递增顺序排序。\n7. 为了计算稳定性，存储 $S_k$ 的划分 $\\mathcal{P}_k$。一个实用的表示是一个字典，将每个分离株的 ID 映射到其分量的代表（根）。\n\n**2. 稳定性得分计算**\n\n稳定性得分 $s_k$ 衡量了在前一个快照中已存在的分离株的聚类分配的一致性。它是为每对连续的快照 $(k, k+1)$ 计算的。\n- 设 $\\mathcal{P}_k$ 和 $\\mathcal{P}_{k+1}$ 分别是 $S_k$ 和 $S_{k+1}$ 到聚类的划分。\n- 关注的集合是 $S_k$，即在较早快照中存在的分离株。要评估的对集合是 $U_k = \\{ \\{i,j\\} : i,j \\in S_k, i  j \\}$。\n- 对于每个对 $\\{i,j\\} \\in U_k$，我们比较它们在两个快照中的共聚类状态。\n  - 如果 $i$ 和 $j$ 在 $\\mathcal{P}_k$ 的同一聚类中，则 $I_k(i,j)=1$；否则为 $0$。\n  - 如果 $i$ 和 $j$ 在 $\\mathcal{P}_{k+1}$ 的同一聚类中，则 $I_{k+1}(i,j)=1$；否则为 $0$。注意，由于 $S_k \\subseteq S_{k+1}$，分离株 $i,j$ 在快照 $k+1$ 的图中是存在的。\n- 得分是状态保持不变的对所占的比例：\n  $$s_k = \\frac{1}{|U_k|} \\sum_{\\{i,j\\} \\in U_k} \\mathbf{1}\\big( I_k(i,j) = I_{k+1}(i,j) \\big)$$\n- 求和项计算了在两个快照中要么都聚在一起、要么都分开的对 $\\{i,j\\}$ 的数量。\n- 当 $|S_k|  2$ 时会出现特殊情况。此时，对集合 $U_k$ 为空，分母 $|U_k|$ 为零。按照惯例，在这种空真（vacuous truth）的情况下（不存在可以不同意的对），稳定性是最大的，即 $s_k = 1.0$。\n\n整体实现将通过首先计算所有快照的聚类划分，然后计算连续划分之间的稳定性得分来处理每个测试用例。最终结果将按规定格式聚合和格式化。", "answer": "```python\nimport numpy as np\n\nclass UnionFind:\n    \"\"\"\n    A class for the Disjoint Set Union (DSU) or Union-Find data structure.\n    Implements union by size and path compression for efficiency.\n    \"\"\"\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.set_size = [1] * size\n\n    def find(self, i):\n        \"\"\"Finds the representative of the set containing element i with path compression.\"\"\"\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        \"\"\"Merges the sets containing elements i and j using union by size.\"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            # Union by size: attach smaller tree under root of larger tree\n            if self.set_size[root_i]  self.set_size[root_j]:\n                root_i, root_j = root_j, root_i\n            self.parent[root_j] = root_i\n            self.set_size[root_i] += self.set_size[root_j]\n            return True\n        return False\n\ndef process_case(n, D, t, T, tau):\n    \"\"\"\n    Processes a single test case to compute cluster sizes and stability scores.\n    \"\"\"\n    snapshot_partitions = {}\n    snapshot_sizes = []\n\n    for k, T_k in enumerate(T):\n        snapshot_idx = k + 1\n        \n        active_isolates = sorted([i for i, time in enumerate(t) if time = T_k])\n        \n        if not active_isolates:\n            snapshot_sizes.append([])\n            snapshot_partitions[snapshot_idx] = {}\n            continue\n\n        num_active = len(active_isolates)\n        isolate_to_uf_idx = {iso: i for i, iso in enumerate(active_isolates)}\n        \n        uf = UnionFind(num_active)\n        \n        for i in range(num_active):\n            for j in range(i + 1, num_active):\n                iso1 = active_isolates[i]\n                iso2 = active_isolates[j]\n                if D[iso1, iso2] = tau:\n                    uf.union(isolate_to_uf_idx[iso1], isolate_to_uf_idx[iso2])\n\n        # Store partition for stability calculation\n        partition = {iso: uf.find(isolate_to_uf_idx[iso]) for iso in active_isolates}\n        snapshot_partitions[snapshot_idx] = partition\n\n        # Calculate component sizes\n        component_members = {}\n        for iso in active_isolates:\n            root = partition[iso]\n            component_members.setdefault(root, []).append(iso)\n        \n        sizes = sorted([len(v) for v in component_members.values()], reverse=True)\n        snapshot_sizes.append(sizes)\n\n    stability_scores = []\n    for k in range(len(T) - 1):\n        snapshot_idx_k = k + 1\n        snapshot_idx_k1 = k + 2\n        \n        partition_k = snapshot_partitions[snapshot_idx_k]\n        partition_k1 = snapshot_partitions[snapshot_idx_k1]\n        \n        isolates_k = sorted(list(partition_k.keys()))\n        num_isolates_k = len(isolates_k)\n\n        if num_isolates_k  2:\n            score = 1.0\n        else:\n            num_pairs = num_isolates_k * (num_isolates_k - 1) // 2\n            agreement_count = 0\n            for i in range(num_isolates_k):\n                for j in range(i + 1, num_isolates_k):\n                    iso1 = isolates_k[i]\n                    iso2 = isolates_k[j]\n                    \n                    same_k = (partition_k[iso1] == partition_k[iso2])\n                    same_k1 = (partition_k1[iso1] == partition_k1[iso2])\n                    \n                    if same_k == same_k1:\n                        agreement_count += 1\n            \n            score = agreement_count / num_pairs\n\n        stability_scores.append(round(score, 3))\n        \n    return [snapshot_sizes, stability_scores]\n\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    test_cases = [\n        (\n            6,\n            np.array([\n                [0, 1, 4, 2, 6, 6], [1, 0, 4, 2, 6, 6], [4, 4, 0, 1, 6, 6],\n                [2, 2, 1, 0, 6, 6], [6, 6, 6, 6, 0, 1], [6, 6, 6, 6, 1, 0]\n            ]),\n            [1, 2, 3, 4, 5, 6],\n            [3, 5, 6],\n            2\n        ),\n        (\n            5,\n            np.array([\n                [0, 3, 3, 3, 3], [3, 0, 3, 3, 3], [3, 3, 0, 3, 3],\n                [3, 3, 3, 0, 3], [3, 3, 3, 3, 0]\n            ]),\n            [1, 2, 3, 4, 5],\n            [2, 4, 5],\n            0\n        ),\n        (\n            4,\n            np.array([\n                [0, 2, 1, 2], [2, 0, 2, 1], [1, 2, 0, 2], [2, 1, 2, 0]\n            ]),\n            [1, 2, 3, 4],\n            [2, 3, 4],\n            3\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        n, D, t, T, tau = case\n        result = process_case(n, D, t, T, tau)\n        results.append(result)\n\n    # Format the final output string according to the problem specification.\n    # The default str() representation for lists includes spaces, which is not desired.\n    # We build the string manually.\n    final_output_str = \"[\" + \", \".join([str(r).replace(\"'\", '\"').replace(\" \", \"\") for r in results]) + \"]\"\n    # Python's str() on a list adds spaces. The desired output in problem 3 has no spaces.\n    # Re-creating the manual trace from problem 3 shows: [[2, 1], [4, 1], [4, 2]], [0.333, 1.0].\n    # The code produces: [[[2, 1], [4, 1], [4, 2]], [0.333, 1.0]].\n    # My python implementation must match the output format.\n    # Let me re-read the format. `[ result_1, result_2, result_3 ]`\n    # The example output string in the problem description is `[ result_1, result_2, result_3 ]`\n    # Python `str(list_of_lists)` adds spaces. E.g., `str([[1,2], [3,4]])` is `'[[1, 2], [3, 4]]'`.\n    # Let's adjust the output formatting to be more robust.\n    # The prompt says: \"Your program should generate single-line output, where...The example format is [ result_1, result_2, result_3 ]\"\n    # It does not explicitly forbid spaces. The default python str() should be fine.\n    \n    print(str(results).replace(\"'\", '\"'))\n\nsolve()\n```", "id": "4688569"}]}