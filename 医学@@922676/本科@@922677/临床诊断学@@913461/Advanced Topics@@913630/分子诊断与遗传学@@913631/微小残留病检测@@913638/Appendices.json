{"hands_on_practices": [{"introduction": "实时定量PCR（qPCR）是 MRD 检测中的一项核心技术。为了获得可靠的定量结果，我们必须首先建立一个标准曲线。本练习将引导你使用已知浓度的标准品进行系列稀释后获得的数据，来计算 PCR 的扩增效率（$E$），这是确保准确定量的关键质量控制参数。这个实践练习将帮助你理解 PCR 扩增的指数特性如何通过数学转换与我们执行的线性数据分析联系起来。[@problem_id:5231553]", "problem": "在微小残留病（MRD）的实验室诊断中，实时定量聚合酶链式反应（qPCR）通过将患者样本的循环阈值与由已知标准品构建的校准曲线进行比较，来推断样本中初始靶标的拷贝数。假设以下基本事实：在qPCR中，靶标扩增子群体每个循环以一个恒定因子倍增，荧光阈值在不同运行中是固定的，而循环阈值 $C_t$ 是累积的扩增子首次超过此固定阈值的循环数。对一个每反应含已知初始靶标拷贝数 $N_0$ 的标准品进行十倍系列稀释，并进行三次重复实验，得到了以下平均校准数据（本练习中每个稀释度只给出一个值）：\n\n- $N_0$：$1.00 \\times 10^5$、$1.00 \\times 10^4$、$1.00 \\times 10^3$、$1.00 \\times 10^2$、$1.00 \\times 10^1$\n- $C_t$：$16.50$、$19.95$、$23.40$、$26.85$、$30.30$\n\n从指数扩增模型和固定荧光阈值下 $C_t$ 的定义出发，推导 $C_t$ 与 $\\log_{10}(N_0)$ 之间的线性关系，并用每循环效率 $E$ 来表示斜率 $m$。然后，使用给定的校准数据，通过最小二乘线性回归计算 $C_t$ 相对于 $\\log_{10}(N_0)$ 的最佳拟合斜率 $m$，利用你推导出的关系式计算 qPCR 效率 $E$，并将最终的 $E$ 值四舍五入到四位有效数字。将最终效率表示为小数形式（不要使用百分号）。", "solution": "该问题基于实时定量PCR（qPCR）的科学原理，提法得当，有足够的数据得出唯一解，并以客观、正式的语言表述，因此是有效的。我们可以开始解题。\n\n第一步是推导循环阈值 $C_t$ 和初始靶标分子数 $N_0$ 之间的理论关系。qPCR中靶标DNA的扩增遵循指数模型。设 $N_c$ 为 $c$ 个循环后靶标分子的数量。如果 $N_0$ 是初始分子数，而 $E$ 是每循环的扩增效率（其中 $0 \\le E \\le 1$），则 $c$ 个循环后的分子数由下式给出：\n$$N_c = N_0 (1+E)^c$$\n在此方程中，效率 $E=1$ 对应于产物在每个循环中的完美倍增。\n\n循环阈值 $C_t$ 定义为荧光信号（与扩增的DNA量成正比）穿过一个固定阈值时的分数循环数。设 $N_T$ 为达到此荧光阈值所需的DNA分子数。在循环阈值处，即 $c=C_t$ 时，我们有 $N_{C_t} = N_T$。将此代入扩增方程：\n$$N_T = N_0 (1+E)^{C_t}$$\n为了建立 $C_t$ 和 $N_0$ 之间的关系，我们重新整理这个方程。首先，我们分离出包含 $C_t$ 的项：\n$$\\frac{N_T}{N_0} = (1+E)^{C_t}$$\n接下来，我们对等式两边取以10为底的对数，因为题目要求与 $\\log_{10}(N_0)$ 的关系：\n$$\\log_{10}\\left(\\frac{N_T}{N_0}\\right) = \\log_{10}\\left((1+E)^{C_t}\\right)$$\n利用对数的性质 $\\log(a/b) = \\log(a) - \\log(b)$ 和 $\\log(a^b) = b\\log(a)$，我们得到：\n$$\\log_{10}(N_T) - \\log_{10}(N_0) = C_t \\log_{10}(1+E)$$\n现在，我们求解 $C_t$：\n$$C_t = \\frac{\\log_{10}(N_T) - \\log_{10}(N_0)}{\\log_{10}(1+E)}$$\n这可以写成线性方程 $y = mx + b$ 的形式，其中 $y = C_t$，$x = \\log_{10}(N_0)$：\n$$C_t = \\left(-\\frac{1}{\\log_{10}(1+E)}\\right) \\log_{10}(N_0) + \\left(\\frac{\\log_{10}(N_T)}{\\log_{10}(1+E)}\\right)$$\n从这个推导出的形式中，我们可以确定 $C_t$ 相对于 $\\log_{10}(N_0)$ 的直线斜率 $m$：\n$$m = -\\frac{1}{\\log_{10}(1+E)}$$\n这就完成了问题的第一部分。\n\n第二部分是使用提供的实验数据计算最佳拟合斜率 $m$。我们将使用最小二乘线性回归直线的斜率公式。设我们的数据点为 $(x_i, y_i)$，其中 $x_i = \\log_{10}(N_{0,i})$，$y_i = C_{t,i}$。数据点的数量为 $n=5$。\n\n数据如下：\n- $N_0$：$1.00 \\times 10^5, 1.00 \\times 10^4, 1.00 \\times 10^3, 1.00 \\times 10^2, 1.00 \\times 10^1$\n- $x = \\log_{10}(N_0)$: $5, 4, 3, 2, 1$\n- $y = C_t$: $16.50, 19.95, 23.40, 26.85, 30.30$\n\n斜率 $m$ 的公式是：\n$$m = \\frac{n(\\sum_{i=1}^{n} x_i y_i) - (\\sum_{i=1}^{n} x_i)(\\sum_{i=1}^{n} y_i)}{n(\\sum_{i=1}^{n} x_i^2) - (\\sum_{i=1}^{n} x_i)^2}$$\n我们计算必要的各项总和：\n$$ \\sum_{i=1}^{5} x_i = 5 + 4 + 3 + 2 + 1 = 15 $$\n$$ \\sum_{i=1}^{5} y_i = 16.50 + 19.95 + 23.40 + 26.85 + 30.30 = 117.00 $$\n$$ \\sum_{i=1}^{5} x_i^2 = 5^2 + 4^2 + 3^2 + 2^2 + 1^2 = 25 + 16 + 9 + 4 + 1 = 55 $$\n$$ \\sum_{i=1}^{5} x_i y_i = (5)(16.50) + (4)(19.95) + (3)(23.40) + (2)(26.85) + (1)(30.30) $$\n$$ \\sum_{i=1}^{5} x_i y_i = 82.50 + 79.80 + 70.20 + 53.70 + 30.30 = 316.50 $$\n现在，我们将这些总和代入 $m$ 的公式：\n$$ m = \\frac{5(316.50) - (15)(117.00)}{5(55) - (15)^2} = \\frac{1582.5 - 1755}{275 - 225} = \\frac{-172.5}{50} = -3.45 $$\n校准曲线的最佳拟合斜率是 $m = -3.45$。\n\n最后，我们使用推导出的 $m$ 和 $E$ 之间的关系来计算 qPCR 效率。\n$$ m = -3.45 = -\\frac{1}{\\log_{10}(1+E)} $$\n求解 $\\log_{10}(1+E)$:\n$$ \\log_{10}(1+E) = \\frac{-1}{m} = \\frac{-1}{-3.45} = \\frac{1}{3.45} $$\n为了求出 $E$，我们首先取反对数（10的幂）：\n$$ 1+E = 10^{(1/3.45)} $$\n然后，我们求解 $E$：\n$$ E = 10^{(1/3.45)} - 1 $$\n现在我们计算其数值：\n$$ \\frac{1}{3.45} \\approx 0.28985507 $$\n$$ 1+E \\approx 10^{0.28985507} \\approx 1.94916005 $$\n$$ E \\approx 1.94916005 - 1 = 0.94916005 $$\n题目要求将最终的 $E$ 值四舍五入到四位有效数字。\n$$ E \\approx 0.9492 $$\nqPCR 效率约为 $0.9492$，即 $94.92\\%$。", "answer": "$$\\boxed{0.9492}$$", "id": "5231553"}, {"introduction": "一个“阳性”的检测结果并非总是最终的诊断。它的真正临床意义取决于检测方法本身的准确性（即灵敏度和特异性）以及疾病在特定人群中的患病率。本练习将运用贝叶斯定理来推导阳性预测值（PPV），这是一个关键指标，它量化了检测结果为阳性的患者真正存在残留病灶的概率。通过这个练习，你将能更深刻地理解如何解读 MRD 检测报告。[@problem_id:5231437]", "problem": "一个实验室开发了一种通过数字聚合酶链式反应（PCR）定量的循环肿瘤DNA（ctDNA）来检测微小残留病灶（MRD）的检测方法。在一个给定的临床队列中，疾病状态是未知的，并且对每个个体都观察到一个MRD检测结果。设 $D$ 表示事件“真实残留病灶存在”，$\\neg D$ 表示“真实残留病灶不存在”。设 $T$ 表示事件“MRD检测阳性”，$\\neg T$ 表示“MRD检测阴性”。该队列的疾病患病率为 $\\pi$，理解为概率 $P(D)$，并以小数形式表示。该检测方法的灵敏度为 $s$，特异度为 $c$，它们是根据 $D$ 和 $\\neg D$ 的条件概率来定义的。\n\n仅使用条件概率的基本定义、全概率定律和贝叶斯定理，完成以下任务：\n- 用事件 $D$、$\\neg D$、$T$ 和 $\\neg T$ 的概率 $P(\\cdot)$ 来定义此MRD检测方法的灵敏度、特异度、阳性预测值（PPV）和阴性预测值（NPV）。\n- 推导PPV，$P(D \\mid T)$，作为 $\\pi$、$s$ 和 $c$ 的函数的解析表达式。\n\n将最终的PPV严格表示为关于 $\\pi$、$s$ 和 $c$ 的闭式解析表达式。任何地方都不要使用百分号；将所有概率（包括 $\\pi$）都视为小数。不需要四舍五入。", "solution": "该问题是有效的，因为它在科学上基于生物统计学和医学诊断的原理，问题提出得很好，目标明确，信息充分，且表述客观。我们可以进行形式化推导。\n\n该问题要求我们首先定义一个诊断测试的几个关键指标，然后推导出阳性预测值（PPV）的表达式。\n\n设 $D$ 为真实残留病灶存在的事件，$\\neg D$ 为其不存在的事件。设 $T$ 为检测结果阳性的事件，$\\neg T$ 为检测结果阴性的事件。设疾病患病率为 $\\pi = P(D)$。\n\n灵敏度、特异度、阳性预测值（PPV）和阴性预测值（NPV）的定义是基于涉及这些事件的条件概率。\n\n1.  **灵敏度 ($s$)**：灵敏度是检测正确识别出患有该疾病的个体的概率。它是在疾病存在（$D$）的条件下，检测结果为阳性（$T$）的概率。\n    $$s = P(T \\mid D)$$\n\n2.  **特异度 ($c$)**：特异度是检测正确识别出未患有该疾病的个体的概率。它是在疾病不存在（$\\neg D$）的条件下，检测结果为阴性（$\\neg T$）的概率。\n    $$c = P(\\neg T \\mid \\neg D)$$\n\n3.  **阳性预测值 (PPV)**：PPV是在检测结果为阳性的个体中，确实患有该疾病的概率。它是在检测结果为阳性（$T$）的条件下，疾病存在（$D$）的概率。\n    $$\\text{PPV} = P(D \\mid T)$$\n\n4.  **阴性预测值 (NPV)**：NPV是在检测结果为阴性的个体中，确实未患有该疾病的概率。它是在检测结果为阴性（$\\neg T$）的条件下，疾病不存在（$\\neg D$）的概率。\n    $$\\text{NPV} = P(\\neg D \\mid \\neg T)$$\n\n接下来，我们推导PPV，$P(D \\mid T)$，作为患病率 $\\pi$、灵敏度 $s$ 和特异度 $c$ 的函数的解析表达式。\n\n推导从条件概率的定义开始，该定义可以重排为贝叶斯定理的形式。PPV是 $P(D \\mid T)$，根据贝叶斯定理，它表示为：\n$$P(D \\mid T) = \\frac{P(T \\mid D) P(D)}{P(T)}$$\n\n我们可以根据题目的给定条件和我们的定义来确定分子中的各项：\n-   $P(T \\mid D)$ 是灵敏度 $s$。\n-   $P(D)$ 是患病率 $\\pi$。\n\n所以，分子是 $s \\pi$。\n\n分母 $P(T)$ 是队列中检测结果为阳性的总概率。为了用给定的参数来表示它，我们使用全概率定律。样本空间被事件 $D$ 和 $\\neg D$ 划分。因此，事件 $T$ 的概率可以写成：\n$$P(T) = P(T \\cap D) + P(T \\cap \\neg D)$$\n\n使用条件概率的定义 $P(A \\cap B) = P(A \\mid B) P(B)$，我们可以将其重写为：\n$$P(T) = P(T \\mid D) P(D) + P(T \\mid \\neg D) P(\\neg D)$$\n\n让我们评估这个 $P(T)$ 表达式中的每一项：\n-   $P(T \\mid D) = s$，灵敏度。\n-   $P(D) = \\pi$，患病率。\n-   $P(\\neg D)$ 是未患病的概率，即 $1 - P(D) = 1 - \\pi$。\n-   $P(T \\mid \\neg D)$ 是在没有疾病的情况下检测结果为阳性的概率。这是假阳性率。它可以从特异度 $c$ 推导出来。因为对于一个没有疾病的个体，检测结果只能是阳性或阴性，所以我们有 $P(T \\mid \\neg D) + P(\\neg T \\mid \\neg D) = 1$。特异度是 $c = P(\\neg T \\mid \\neg D)$。因此，$P(T \\mid \\neg D) = 1 - c$。\n\n将这些部分代回 $P(T)$ 的表达式中：\n$$P(T) = (s)(\\pi) + (1 - c)(1 - \\pi)$$\n$$P(T) = s\\pi + (1 - c)(1 - \\pi)$$\n\n现在我们有了PPV的贝叶斯定理公式中分子和分母的表达式。将它们代回，我们得到PPV，$P(D \\mid T)$ 的最终表达式：\n$$P(D \\mid T) = \\frac{s \\pi}{s\\pi + (1 - c)(1 - \\pi)}$$\n\n这就是阳性预测值作为患病率（$\\pi$）、灵敏度（$s$）和特异度（$c$）的函数的解析表达式。", "answer": "$$\\boxed{\\frac{s \\pi}{s \\pi + (1 - c)(1 - \\pi)}}$$", "id": "5231437"}, {"introduction": "当用于纵向监测时，MRD 检测的威力才能得到最大程度的发挥。这个更高级的实践模拟了一个真实的临床情景：通过对数线性模型来追踪 MRD 水平随时间的变化。通过将指数衰减模型拟合到患者数据，我们可以估算癌细胞的清除速率，并利用该模型来预测未来的复发风险，这正是 MRD 监测的核心临床应用之一。[@problem_id:5231541]", "problem": "在实验室诊断中，给定一个关于微小残留病（MRD）的测量模型。微小残留病（MRD）是指治疗后残留的恶性细胞的比例，在有效治疗下，其通常被建模为随时间呈指数衰减。假设真实的潜在MRD比例遵循指数衰减，并且测量值在自然对数尺度上受到独立的加性高斯噪声的影响。形式上，对于以天为单位的观测时间 $t_i$ 和测得的MRD比例 $y_i$（无量纲小数），模型为\n$$\n\\ln(y_i) = a - k t_i + \\varepsilon_i,\n$$\n其中 $a = \\ln(y_0)$ 是初始MRD比例的对数， $k$ 是衰减率，单位为 $\\text{day}^{-1}$（如果MRD增加，则 $k$ 可能为负），$\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ 是独立同分布的高斯误差。\n\n从高斯似然和指数衰减模型的核心定义出发，在 $\\ln(y_i)$ 上存在独立高斯噪声的假设下，推导 $a$、$k$ 和 $\\sigma^2$ 的最大似然估计量。然后，使用这些估计量计算在未来时间 $t_{\\mathrm{future}}$ 的复发风险，该风险定义为下一次观测到的MRD测量值超过临床阈值 $y_{\\mathrm{thr}}$ 的概率，即\n$$\n\\text{risk} = \\mathbb{P} \\left( \\ln(Y_{\\mathrm{future}}) > \\ln(y_{\\mathrm{thr}}) \\right),\n$$\n其中 $Y_{\\mathrm{future}}$ 表示在未来时间 $t_{\\mathrm{future}}$ 观测到的MRD。在高斯噪声假设下，$\\ln(Y_{\\mathrm{future}})$ 的预测分布是正态分布，其均值为 $\\hat{\\mu} = \\hat{a} - \\hat{k} \\, t_{\\mathrm{future}}$，方差为 $\\hat{\\sigma}^2$，因此请使用标准正态分布的累积分布函数来表示该风险。在构建预测分布时，假设误差独立，并忽略参数估计的不确定性。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n- 根据数据 $\\{(t_i,y_i)\\}_{i=1}^n$ 实现 $a$、$k$ 和 $\\sigma^2$ 的最大似然估计。\n- 使用关于 $\\ln(Y_{\\mathrm{future}})$ 的预测正态模型，计算在给定阈值 $y_{\\mathrm{thr}}$ 下，于 $t_{\\mathrm{future}}$ 时的复发风险。\n- 处理 $\\hat{\\sigma} = 0$ 的边界情况，返回一个确定性风险：如果 $\\hat{\\mu} > \\ln(y_{\\mathrm{thr}})$ 则为 $1$，否则为 $0$。\n\n物理单位和数值要求：\n- 时间 $t_i$ 和 $t_{\\mathrm{future}}$ 必须以天为单位处理。\n- MRD比例 $y_i$ 和 $y_{\\mathrm{thr}}$ 必须作为无量纲小数处理（而不是百分比）。\n- 程序必须以浮点小数形式输出复发风险值，并四舍五入到六位小数。\n\n测试套件：\n使用以下四个测试用例，每个用例都是一个元组 $(\\text{时间}, \\text{观测到的MRD比例}, t_{\\mathrm{future}}, y_{\\mathrm{thr}})$：\n1. 用例A（一般衰减，中等噪声）：时间 $[0,30,60,90]$，MRD比例 $[0.0105,0.0060,0.0028,0.0017]$，$t_{\\mathrm{future}}=120$，$y_{\\mathrm{thr}}=0.0010$。\n2. 用例B（两个点产生的边界情况，接近确定性拟合）：时间 $[0,60]$，MRD比例 $[0.0010,0.0009]$，$t_{\\mathrm{future}}=30$，$y_{\\mathrm{thr}}=0.0008$。\n3. 用例C（MRD上升，指示潜在复发）：时间 $[0,30,60,90]$，MRD比例 $[0.0008,0.0010,0.0014,0.0022]$，$t_{\\mathrm{future}}=120$，$y_{\\mathrm{thr}}=0.0015$。\n4. 用例D（接近检测限，高噪声）：时间 $[0,90,180]$，MRD比例 $[0.000010,0.000012,0.000009]$，$t_{\\mathrm{future}}=270$，$y_{\\mathrm{thr}}=0.000010$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”）。每个结果必须是相应测试用例的复发风险，并四舍五入到六位小数。", "solution": "该问题要求推导一个指数衰减模型的参数的最大似然估计量（MLEs），该模型在测量数量的对数上具有加性高斯噪声，并随后应用这些估计量来计算复发风险概率。\n\n在时间 $t_i$ 测得的微小残留病（MRD）比例 $y_i$ 的模型由下式给出\n$$\n\\ln(y_i) = a - k t_i + \\varepsilon_i\n$$\n其中 $a = \\ln(y_0)$ 是初始MRD比例的对数，$k$ 是衰减率，$\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$ 是独立同分布（i.i.d.）的高斯误差。\n\n为简化符号，令 $z_i = \\ln(y_i)$。该模型可以表示为 $z_i$ 对 $t_i$ 的简单线性回归：\n$$\nz_i = a - k t_i + \\varepsilon_i\n$$\n待估计的参数是截距 $a$、速率 $k$ 和误差方差 $\\sigma^2$。\n\n**1. $a$ 和 $k$ 的最大似然估计**\n\n给定参数时，单个观测值 $z_i$ 的概率密度函数（PDF）是一个均值为 $\\mu_i = a - k t_i$、方差为 $\\sigma^2$ 的正态分布：\n$$\nf(z_i | a, k, \\sigma^2) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left( -\\frac{(z_i - (a - k t_i))^2}{2\\sigma^2} \\right)\n$$\n假设 $n$ 个观测值是独立的，整个数据集 $\\{ (t_i, z_i) \\}_{i=1}^n$ 的似然函数 $L$ 是各个PDF的乘积：\n$$\nL(a, k, \\sigma^2) = \\prod_{i=1}^{n} f(z_i | a, k, \\sigma^2) = \\left( \\frac{1}{2\\pi\\sigma^2} \\right)^{n/2} \\exp\\left( -\\frac{1}{2\\sigma^2} \\sum_{i=1}^{n} (z_i - a + k t_i)^2 \\right)\n$$\n最大化似然函数等同于最大化其自然对数，即对数似然函数 $\\ell = \\ln(L)$：\n$$\n\\ell(a, k, \\sigma^2) = -\\frac{n}{2} \\ln(2\\pi) - \\frac{n}{2} \\ln(\\sigma^2) - \\frac{1}{2\\sigma^2} \\sum_{i=1}^{n} (z_i - a + k t_i)^2\n$$\n为了找到 $a$ 和 $k$ 的最大似然估计量，我们求 $\\ell$ 对 $a$ 和 $k$ 的偏导数并令其为零。这等价于最小化误差平方和（或残差平方和），$S(a, k) = \\sum_{i=1}^{n} (z_i - a + k t_i)^2$。\n$$\n\\frac{\\partial S}{\\partial a} = \\sum_{i=1}^{n} 2(z_i - a + k t_i)(-1) = -2\\left(\\sum_{i=1}^{n} z_i - na + k\\sum_{i=1}^{n} t_i\\right) = 0\n$$\n$$\n\\frac{\\partial S}{\\partial k} = \\sum_{i=1}^{n} 2(z_i - a + k t_i)(t_i) = 2\\left(\\sum_{i=1}^{n} z_i t_i - a\\sum_{i=1}^{n} t_i + k\\sum_{i=1}^{n} t_i^2\\right) = 0\n$$\n由此可得估计量 $\\hat{a}$ 和 $\\hat{k}$ 的正规方程组：\n$$\n\\sum z_i - n\\hat{a} + \\hat{k}\\sum t_i = 0\n$$\n$$\n\\sum z_i t_i - \\hat{a}\\sum t_i + \\hat{k}\\sum t_i^2 = 0\n$$\n根据第一个方程，定义样本均值 $\\bar{t} = \\frac{1}{n}\\sum t_i$ 和 $\\bar{z} = \\frac{1}{n}\\sum z_i$：\n$$\nn\\bar{z} - n\\hat{a} + n\\hat{k}\\bar{t} = 0 \\implies \\hat{a} = \\bar{z} + \\hat{k}\\bar{t}\n$$\n将 $\\hat{a}$ 的这个表达式代入第二个正规方程，可得 $\\hat{k}$ 的解：\n$$\n\\sum z_i t_i - (\\bar{z} + \\hat{k}\\bar{t})\\sum t_i + \\hat{k}\\sum t_i^2 = 0\n$$\n$$\n\\hat{k}\\left(\\sum t_i^2 - \\bar{t}\\sum t_i\\right) = \\sum z_i t_i - \\bar{z}\\sum t_i\n$$\n注意到 $\\sum t_i^2 - \\bar{t}\\sum t_i = \\sum (t_i - \\bar{t})^2$ 以及 $\\sum z_i t_i - \\bar{z}\\sum t_i = \\sum (z_i - \\bar{z})(t_i-\\bar{t})$，我们得到：\n$$\n\\hat{k} = \\frac{\\sum (z_i - \\bar{z})(t_i - \\bar{t})}{\\sum (t_i - \\bar{t})^2}\n$$\n注意，在常规线性模型 $z_i = \\beta_0 + \\beta_1 t_i$ 中，斜率为 $\\beta_1$。这里，$t_i$ 的系数是 $-k$，所以 $\\beta_1 = -k$。斜率的标准普通最小二乘（OLS）估计量是 $\\hat{\\beta}_1 = \\frac{\\sum (t_i - \\bar{t})(z_i - \\bar{z})}{\\sum (t_i - \\bar{t})^2}$。因此，$k$ 的最大似然估计量是：\n$$\n\\hat{k} = - \\frac{\\sum_{i=1}^{n} (t_i - \\bar{t})(z_i - \\bar{z})}{\\sum_{i=1}^{n} (t_i - \\bar{t})^2}\n$$\n而 $a$ 的最大似然估计量是：\n$$\n\\hat{a} = \\bar{z} - (-\\hat{k})\\bar{t} = \\bar{z} + \\hat{k}\\bar{t}\n$$\n\n**2. $\\sigma^2$ 的最大似然估计**\n\n为了找到 $\\sigma^2$ 的最大似然估计量，我们将对数似然函数 $\\ell$ 对 $\\sigma^2$ 求导并令其为零，同时代入最大似然估计量 $\\hat{a}$ 和 $\\hat{k}$：\n$$\n\\frac{\\partial \\ell}{\\partial(\\sigma^2)} = -\\frac{n}{2\\sigma^2} + \\frac{1}{2(\\sigma^2)^2} \\sum_{i=1}^{n} (z_i - a + k t_i)^2 = 0\n$$\n$$\n-\\frac{n}{2\\hat{\\sigma}^2} + \\frac{1}{2(\\hat{\\sigma}^2)^2} \\sum_{i=1}^{n} (z_i - \\hat{a} + \\hat{k} t_i)^2 = 0\n$$\n求解 $\\hat{\\sigma}^2$：\n$$\n\\hat{\\sigma}^2 = \\frac{1}{n} \\sum_{i=1}^{n} (z_i - (\\hat{a} - \\hat{k} t_i))^2\n$$\n这是残差平方的均值。\n\n**3. 复发风险计算**\n\n在未来时间 $t_{\\mathrm{future}}$ 的复发风险定义为未来测量值 $Y_{\\mathrm{future}}$ 超过阈值 $y_{\\mathrm{thr}}$ 的概率：\n$$\n\\text{risk} = \\mathbb{P} \\left( \\ln(Y_{\\mathrm{future}}) > \\ln(y_{\\mathrm{thr}}) \\right)\n$$\n问题陈述指出，$\\ln(Y_{\\mathrm{future}})$ 的预测分布是正态分布，其均值由回归线给出，方差由估计的误差方差给出（忽略参数不确定性）：\n$$\n\\ln(Y_{\\mathrm{future}}) \\sim \\mathcal{N}(\\hat{\\mu}, \\hat{\\sigma}^2)\n$$\n其中 $\\hat{\\mu} = \\hat{a} - \\hat{k} t_{\\mathrm{future}}$ 且 $\\hat{\\sigma}^2$ 是上面推导出的最大似然估计量。令 $Z_{\\mathrm{future}} = \\ln(Y_{\\mathrm{future}})$ 和 $z_{\\mathrm{thr}} = \\ln(y_{\\mathrm{thr}})$。我们需要计算 $\\mathbb{P}(Z_{\\mathrm{future}} > z_{\\mathrm{thr}})$。\n\n为计算此概率，我们对随机变量 $Z_{\\mathrm{future}}$ 进行标准化。令 $W = (Z_{\\mathrm{future}} - \\hat{\\mu})/\\hat{\\sigma}$，它服从标准正态分布 $\\mathcal{N}(0,1)$。该概率变为：\n$$\n\\text{risk} = \\mathbb{P}\\left( \\frac{Z_{\\mathrm{future}} - \\hat{\\mu}}{\\hat{\\sigma}} > \\frac{z_{\\mathrm{thr}} - \\hat{\\mu}}{\\hat{\\sigma}} \\right) = \\mathbb{P}\\left( W > \\frac{z_{\\mathrm{thr}} - \\hat{\\mu}}{\\hat{\\sigma}} \\right)\n$$\n令 $\\Phi(\\cdot)$ 为标准正态分布的累积分布函数（CDF）。那么 $\\mathbb{P}(W > x) = 1 - \\mathbb{P}(W \\le x) = 1 - \\Phi(x)$。因此，风险为：\n$$\n\\text{risk} = 1 - \\Phi\\left( \\frac{\\ln(y_{\\mathrm{thr}}) - (\\hat{a} - \\hat{k} t_{\\mathrm{future}})}{\\hat{\\sigma}} \\right)\n$$\n在 $\\hat{\\sigma} = 0$ 的特殊情况下，预测分布是在 $\\hat{\\mu}$ 处的一个点质量。概率是确定性的：如果 $\\hat{\\mu} > \\ln(y_{\\mathrm{thr}})$，风险为 $1$；否则为 $0$。这种情况发生在数据点完全落在一条直线上时，例如，当有 $n=2$ 个观测值时。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Implements the full solution pipeline for MRD relapse risk calculation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (times, observed MRD fractions, t_future, y_thr)\n    test_cases = [\n        # Case A (general decay, moderate noise)\n        (\n            [0, 30, 60, 90],\n            [0.0105, 0.0060, 0.0028, 0.0017],\n            120,\n            0.0010,\n        ),\n        # Case B (boundary with two points yielding near-deterministic fit)\n        (\n            [0, 60],\n            [0.0010, 0.0009],\n            30,\n            0.0008,\n        ),\n        # Case C (rising MRD indicating potential relapse)\n        (\n            [0, 30, 60, 90],\n            [0.0008, 0.0010, 0.0014, 0.0022],\n            120,\n            0.0015,\n        ),\n        # Case D (near detection limit, high noise)\n        (\n            [0, 90, 180],\n            [0.000010, 0.000012, 0.000009],\n            270,\n            0.000010,\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        times, mrd_fractions, t_future, y_thr = case\n\n        # Convert to numpy arrays for vectorized calculations\n        t = np.array(times, dtype=np.float64)\n        y = np.array(mrd_fractions, dtype=np.float64)\n        \n        # Transform the model to a linear form: z = a - k*t\n        # where z = ln(y)\n        z = np.log(y)\n        n = len(t)\n        \n        # Calculate maximum likelihood estimators for a, k, and sigma^2\n        # These are equivalent to ordinary least squares (OLS) estimators\n        \n        # Calculate sample means\n        t_mean = np.mean(t)\n        z_mean = np.mean(z)\n        \n        # Calculate k_hat\n        # Using the covariance/variance formula for the slope of the regression of z on t\n        # The slope is -k.\n        # Handle the case where var_t is zero to avoid division by zero,\n        # although this won't happen for the given test cases.\n        var_t = np.sum((t - t_mean)**2)\n        if np.isclose(var_t, 0):\n             # When all time points are the same, k is undefined.\n             # This scenario is not physically meaningful for this problem.\n             # We can set k to 0 and proceed, as there's no trend.\n            k_hat = 0.0\n        else:\n            cov_tz = np.sum((t - t_mean) * (z - z_mean))\n            k_hat = -cov_tz / var_t\n\n        # Calculate a_hat\n        a_hat = z_mean + k_hat * t_mean\n        \n        # Calculate the predicted z values and residuals\n        z_predicted = a_hat - k_hat * t\n        residuals = z - z_predicted\n        \n        # Calculate sigma_hat (MLE for standard deviation)\n        # The MLE for variance is the mean of squared residuals.\n        sigma_sq_hat = np.mean(residuals**2)\n        sigma_hat = np.sqrt(sigma_sq_hat)\n        \n        # Calculate the relapse risk\n        \n        # Predicted mean for ln(Y_future)\n        mu_hat_future = a_hat - k_hat * t_future\n        \n        # Log of the clinical threshold\n        z_thr = np.log(y_thr)\n        \n        # Handle edge case where sigma_hat is zero (perfect fit)\n        if np.isclose(sigma_hat, 0):\n            risk = 1.0 if mu_hat_future > z_thr else 0.0\n        else:\n            # Standardize the variable to use the standard normal CDF\n            arg = (z_thr - mu_hat_future) / sigma_hat\n            # The risk is P(Z > z_thr) = 1 - P(Z = z_thr)\n            # which is the survival function (sf) of the normal distribution.\n            risk = norm.sf(arg)\n\n        results.append(f\"{risk:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "5231541"}]}