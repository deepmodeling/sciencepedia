{"hands_on_practices": [{"introduction": "在进行任何复杂的多组学整合分析之前，我们必须确保数据的质量。本练习将介绍常见组学数据类型——RNA测序（RNA-seq）和蛋白质组学——的基本质量控制（QC）指标，并利用稳健的统计方法来识别可能影响下游分析结果的低质量样本。通过这项实践，您将掌握多组学分析流程中至关重要的第一步，即数据清理与评估。[@problem_id:5062582]", "problem": "给定 $n$ 个样本的核糖核酸测序（RNA-seq）和蛋白质组学数据。RNA-seq 数据汇总为一个元基因体覆盖矩阵 $X \\in \\mathbb{N}^{n \\times p}$，其中每一行对应一个样本，每一列 $j \\in \\{1,\\dots,p\\}$ 对应于从 $5'$ 端到 $3'$ 端沿聚合基因体映射到第 $j$ 个区间的读段（reads）计数。蛋白质组学数据以强度矩阵 $Y \\in \\mathbb{R}^{n \\times q}$ 的形式提供，其中每一行对应一个样本，每一列对应一个肽段强度，严格为正的值表示肽段已被鉴定。您的任务是计算每个样本的质量指标，并使用稳健统计学方法建立阈值以标记异常值。\n\n定义：\n- 样本 $i$ 的 RNA-seq 文库大小为 $LS_i = \\sum_{j=1}^{p} X_{i,j}$。\n- 对于比例 $\\alpha \\in (0,1)$，样本 $i$ 的 $5'$ 偏好为 $B_i = \\dfrac{\\sum_{j=1}^{k} X_{i,j}}{\\sum_{j=1}^{p} X_{i,j}}$，其中 $k = \\lfloor \\alpha p \\rfloor$。如果 $\\sum_{j=1}^{p} X_{i,j} = 0$，按惯例定义 $B_i = 0$。将 $B_i$ 表示为小数。\n- 样本 $i$ 的已鉴定肽段数量为 $P_i = \\#\\{j \\in \\{1,\\dots,q\\} : Y_{i,j} > 0\\}$。\n\n用于异常值检测的稳健阈值：\n- 对于跨样本的度量向量 $v \\in \\mathbb{R}^{n}$（例如，$v = (LS_1,\\dots,LS_n)$，$v = (B_1,\\dots,B_n)$，或 $v = (P_1,\\dots,P_n)$），计算中位数 $m = \\mathrm{median}(v)$ 和中位数绝对偏差 (MAD)，定义为 $\\mathrm{MAD} = \\mathrm{median}(|v - m|)$。使用正态一致性常数 $c = 1.4826$ 形成一个稳健尺度 $s = c \\cdot \\mathrm{MAD}$。如果 $s = 0$，则退而使用由四分位数 $Q_1$ 和 $Q_3$ 定义的四分位距 (IQR)，即 $\\mathrm{IQR} = Q_3 - Q_1$，并设置 $s = \\mathrm{IQR}/1.349$。如果 $s$ 仍然为 $0$，则设置 $s = 0$。\n- 使用用户指定的稳健乘数 $z > 0$，定义下阈值和上阈值为 $T_{\\mathrm{low}} = m - z s$ 和 $T_{\\mathrm{high}} = m + z s$。\n- 当 $LS_i  T_{\\mathrm{low}}$ 和 $P_i  T_{\\mathrm{low}}$ 时，分别标记文库大小和已鉴定肽段数量的低异常值。\n- 当 $B_i > T_{\\mathrm{high}}$ 时，标记 $5'$ 偏好的高异常值。\n\n基本原理：\n- 测序和蛋白质组学测量产生的是对独立事件进行聚合的计数和强度数据，其中计数的总和及比率提供了有意义的样本级别指标。使用中位数和中位数绝对偏差 (MAD) 的稳健统计学方法，在存在异常值和非高斯噪声的情况下能提供稳定的阈值设定，而四分位距 (IQR) 则在 MAD 为零时提供了一个备用尺度。\n\n实现一个程序，为每个样本计算 $LS_i$、$B_i$ 和 $P_i$，根据上述规则为每个指标推导出 $T_{\\mathrm{low}}$ 和 $T_{\\mathrm{high}}$，并为每个样本返回以下布尔标志：\n- RNA-seq 文库大小过低，\n- $5'$ 偏好过高，\n- 已鉴定肽段数量过低。\n\n请使用以下测试套件。对于每种情况，$n$、$p$ 和 $q$ 由 $X$ 和 $Y$ 的维度隐式给出。\n\n情况 1：参数 $\\alpha = 0.2$，$z = 2$，数据如下\n- $X^{(1)}$ 行：\n  - 样本 1：$[100,95,90,85,80,75,70,65,60,55]$\n  - 样本 2：$[300,300,10,10,10,10,10,10,10,10]$\n  - 样本 3：$[5,5,5,5,5,5,5,5,5,5]$\n- $Y^{(1)}$ 行：\n  - 样本 1：$[12000,9000,8000,5000,3000,2000,1000,500]$\n  - 样本 2：$[100,50,25,10,5,1,0.5,0]$\n  - 样本 3：$[0,0,0,0,0,0,0,0]$\n\n情况 2：参数 $\\alpha = 0.2$，$z = 3$，数据如下\n- $X^{(2)}$ 行：\n  - 样本 1：$[50,50,50,50,50,50,50,50,50,50]$\n  - 样本 2：$[50,50,50,50,50,50,50,50,50,50]$\n  - 样本 3：$[50,50,50,50,50,50,50,50,50,50]$\n- $Y^{(2)}$ 行：\n  - 样本 1：$[1,1,1,1,0,0]$\n  - 样本 2：$[1,1,1,1,0,0]$\n  - 样本 3：$[1,1,1,1,0,0]$\n\n情况 3：参数 $\\alpha = 0.2$，$z = 0.5$，数据如下\n- $X^{(3)}$ 行：\n  - 样本 1：$[40,38,36,34,32,30,28,26,24,22]$\n  - 样本 2：$[0,0,0,0,0,0,0,0,0,0]$\n  - 样本 3：$[10,10,10,10,10,10,10,10,10,10]$\n- $Y^{(3)}$ 行：\n  - 样本 1：$[10,9,0,0,0]$\n  - 样本 2：$[0,0,0,0,0]$\n  - 样本 3：$[5,4,3,2,1]$\n\n角度单位不适用。不存在物理单位。诸如 $B_i$ 之类的比例必须表示为小数。您的程序应生成单行输出，其中包含每个案例的三个布尔列表，顺序为 $[$文库大小过低标志, $5'$ 偏好过高标志, 肽段数量过低标志$]$。这三个案例的结果聚合为一个由逗号分隔的列表，并用方括号括起来，例如 $[[[b_{1},\\dots],[b_{1},\\dots],[b_{1},\\dots]],[[...]],[[...]]]$，其中每个 $b_{i}$ 为 $\\mathrm{True}$ 或 $\\mathrm{False}$。", "solution": "该问题已经过验证，被认为是可靠的。它在科学上基于标准的生物信息学质量控制流程，在数学上定义清晰、约束明确，表述客观。所有测试用例所需的数据和参数均已提供。\n\n任务是根据多组学数据（RNA-seq 和蛋白质组学），为 $n$ 个样本中的每一个计算三个质量控制指标，为这些指标建立稳健的统计阈值，并标记出作为异常值的样本。\n\n每个测试用例的解决方案分三个主要阶段进行：\n1.  计算每个样本的指标：文库大小（$LS_i$）、$5'$ 偏好（$B_i$）和肽段数量（$P_i$）。\n2.  为每个指标向量推导稳健的异常值阈值（$T_{\\mathrm{low}}$，$T_{\\mathrm{high}}$）。\n3.  应用阈值标记异常样本。\n\n每个样本 $i \\in \\{1, \\dots, n\\}$ 的输入数据包括一个 RNA-seq 读段计数行向量 $X_{i,:} \\in \\mathbb{N}^{p}$ 和一个肽段强度行向量 $Y_{i,:} \\in \\mathbb{R}^{q}$。\n\n**1. 每样本指标计算**\n\n对于每个样本 $i$，我们根据给定的定义计算以下指标：\n- **RNA-seq 文库大小 ($LS_i$)**：样本 RNA-seq 图谱中的总读段数。\n$$LS_i = \\sum_{j=1}^{p} X_{i,j}$$\n- **$5'$ 偏好 ($B_i$)**：落入聚合基因体初始区间的读段比例，这可能表明存在降解或不完全的反转录。给定一个比例 $\\alpha \\in (0,1)$，我们首先确定区间数 $k = \\lfloor \\alpha p \\rfloor$。\n$$B_i = \\begin{cases} \\frac{\\sum_{j=1}^{k} X_{i,j}}{\\sum_{j=1}^{p} X_{i,j}}  \\text{if } \\sum_{j=1}^{p} X_{i,j}  0 \\\\ 0  \\text{if } \\sum_{j=1}^{p} X_{i,j} = 0 \\end{cases}$$\n- **已鉴定肽段数量 ($P_i$)**：具有正强度信号的肽段计数，反映了蛋白质组学测量的深度。\n$$P_i = \\#\\{j \\in \\{1, \\dots, q\\} : Y_{i,j}  0\\}$$\n\n**2. 稳健阈值推导**\n\n对于三个指标向量中的每一个，$v = (LS_1, \\dots, LS_n)$、$v = (B_1, \\dots, B_n)$ 和 $v = (P_1, \\dots, P_n)$，我们计算异常值阈值。此方法使用稳健统计学，与基于均值和标准差的经典方法相比，它对异常值的存在不那么敏感。\n\n-   首先，我们计算指标向量 $v$ 的中位数 $m$：\n    $$m = \\mathrm{median}(v)$$\n-   接下来，我们计算中位数绝对偏差 (MAD)，即与中位数偏差的绝对值的中位数：\n    $$\\mathrm{MAD} = \\mathrm{median}(|v - m|) = \\mathrm{median}(|v_1 - m|, |v_2 - m|, \\dots, |v_n - m|)$$\n-   然后计算一个稳健的尺度估计值 $s$。主要方法是使用 MAD，通过一个常数 $c = 1.4826$ 进行缩放，使其与正态分布数据的标准差具有可比性。\n    $$s = c \\cdot \\mathrm{MAD}$$\n-   为 $\\mathrm{MAD} = 0$ 的情况定义了一个备用机制，这种情况发生在至少一半的数据点相同时。在这种情况下，使用四分位距 (IQR)。\n    $$Q_1 = v \\text{ 的第 } 25 \\text{ 百分位数}$$\n    $$Q_3 = v \\text{ 的第 } 75 \\text{ 百分位数}$$\n    $$\\mathrm{IQR} = Q_3 - Q_1$$\n    然后将尺度设置为 $s = \\mathrm{IQR} / 1.349$。除数 $1.349$ 将 IQR 与正态分布的标准差联系起来。如果此计算结果仍然为 $s=0$，则将尺度设置为 $s=0$。\n-   最后，利用稳健尺度 $s$ 和用户指定的乘数 $z  0$，定义下阈值和上阈值如下：\n    $$T_{\\mathrm{low}} = m - z s$$\n    $$T_{\\mathrm{high}} = m + z s$$\n\n**3. 异常值标记**\n\n根据这些阈值标记样本：\n-   **文库大小过低**：如果 $LS_i  T_{\\mathrm{low}, LS}$，则标记样本 $i$。\n-   **$5'$ 偏好过高**：如果 $B_i > T_{\\mathrm{high}, B}$，则标记样本 $i$。\n-   **肽段数量过低**：如果 $P_i  T_{\\mathrm{low}, P}$，则标记样本 $i$。\n\n---\n\n**测试用例执行**\n\n**情况 1：$\\alpha = 0.2, z = 2$**\n-   $n=3, p=10, q=8$。$k = \\lfloor 0.2 \\times 10 \\rfloor = 2$。\n-   **指标**：\n    -   $LS = [\\sum X_{1,j}, \\sum X_{2,j}, \\sum X_{3,j}] = [775, 680, 50]$。\n    -   $B = [195/775, 600/680, 10/50] \\approx [0.2516, 0.8824, 0.2]$。\n    -   $P = [8, 7, 0]$。\n-   **阈值和标志**：\n    -   对于 $v=LS$：$m=680$，$\\mathrm{MAD}=95$，$s = 1.4826 \\times 95 \\approx 140.85$。$T_{\\mathrm{low}} = 680 - 2 \\times 140.85 = 398.3$。$LS_3=50  398.3$。标志：`[False, False, True]`。\n    -   对于 $v=B$：$m \\approx 0.2516$，$\\mathrm{MAD} \\approx |0.2 - 0.2516| = 0.0516$。$s = 1.4826 \\times 0.0516 \\approx 0.0765$。$T_{\\mathrm{high}} = 0.2516 + 2 \\times 0.0765 \\approx 0.4046$。$B_2 \\approx 0.8824 > 0.4046$。标志：`[False, True, False]`。\n    -   对于 $v=P$：$m=7$，$\\mathrm{MAD}=1$，$s = 1.4826 \\times 1 = 1.4826$。$T_{\\mathrm{low}} = 7 - 2 \\times 1.4826 = 4.0348$。$P_3=0  4.0348$。标志：`[False, False, True]`。\n-   **结果**：`[[False, False, True], [False, True, False], [False, False, True]]`\n\n**情况 2：$\\alpha = 0.2, z = 3$**\n-   $n=3, p=10, q=6$。$k = \\lfloor 0.2 \\times 10 \\rfloor = 2$。所有样本都相同。\n-   **指标**：\n    -   $LS = [500, 500, 500]$。\n    -   $B = [0.2, 0.2, 0.2]$。\n    -   $P = [4, 4, 4]$。\n-   **阈值和标志**：\n    -   对于所有三个指标，数值向量 $v$ 的所有元素都相同。这导致 $\\mathrm{MAD}=0$ 和 $\\mathrm{IQR}=0$。因此，尺度 $s=0$。\n    -   $T_{\\mathrm{low}} = m - z \\cdot 0 = m$ 且 $T_{\\mathrm{high}} = m + z \\cdot 0 = m$。\n    -   由于所有 $v_i=m$，异常值条件 $v_i  m$ 和 $v_i > m$ 永远不会满足。\n    -   所有标志均为 `False`。\n-   **结果**：`[[False, False, False], [False, False, False], [False, False, False]]`\n\n**情况 3：$\\alpha = 0.2, z = 0.5$**\n-   $n=3, p=10, q=5$。$k = \\lfloor 0.2 \\times 10 \\rfloor = 2$。\n-   **指标**：\n    -   $LS = [310, 0, 100]$。\n    -   $B = [78/310, 0, 20/100] \\approx [0.2516, 0.0, 0.2]$。\n    -   $P = [2, 0, 5]$。\n-   **阈值和标志**：\n    -   对于 $v=LS$：$m=100$，$\\mathrm{MAD}=100$，$s = 1.4826 \\times 100 = 148.26$。$T_{\\mathrm{low}} = 100 - 0.5 \\times 148.26 = 25.87$。$LS_2=0  25.87$。标志：`[False, True, False]`。\n    -   对于 $v=B$：$m=0.2$，$\\mathrm{MAD} = |0.2516-0.2| \\approx 0.0516$。$s = 1.4826 \\times 0.0516 \\approx 0.0765$。$T_{\\mathrm{high}} = 0.2 + 0.5 \\times 0.0765 \\approx 0.2383$。$B_1 \\approx 0.2516 > 0.2383$。标志：`[True, False, False]`。\n    -   对于 $v=P$：$m=2$，$\\mathrm{MAD}=2$，$s = 1.4826 \\times 2 = 2.9652$。$T_{\\mathrm{low}} = 2 - 0.5 \\times 2.9652 = 0.5174$。$P_2=0  0.5174$。标志：`[False, True, False]`。\n-   **结果**：`[[False, True, False], [True, False, False], [False, True, False]]`\n\n最终的实现将以编程方式执行这些计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"matrices\": {\n                \"X\": np.array([\n                    [100, 95, 90, 85, 80, 75, 70, 65, 60, 55],\n                    [300, 300, 10, 10, 10, 10, 10, 10, 10, 10],\n                    [5, 5, 5, 5, 5, 5, 5, 5, 5, 5]\n                ], dtype=np.int64),\n                \"Y\": np.array([\n                    [12000, 9000, 8000, 5000, 3000, 2000, 1000, 500],\n                    [100, 50, 25, 10, 5, 1, 0.5, 0],\n                    [0, 0, 0, 0, 0, 0, 0, 0]\n                ], dtype=np.float64)\n            },\n            \"params\": {\"alpha\": 0.2, \"z\": 2.0}\n        },\n        {\n            \"matrices\": {\n                \"X\": np.array([\n                    [50, 50, 50, 50, 50, 50, 50, 50, 50, 50],\n                    [50, 50, 50, 50, 50, 50, 50, 50, 50, 50],\n                    [50, 50, 50, 50, 50, 50, 50, 50, 50, 50]\n                ], dtype=np.int64),\n                \"Y\": np.array([\n                    [1, 1, 1, 1, 0, 0],\n                    [1, 1, 1, 1, 0, 0],\n                    [1, 1, 1, 1, 0, 0]\n                ], dtype=np.float64)\n            },\n            \"params\": {\"alpha\": 0.2, \"z\": 3.0}\n        },\n        {\n            \"matrices\": {\n                \"X\": np.array([\n                    [40, 38, 36, 34, 32, 30, 28, 26, 24, 22],\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                    [10, 10, 10, 10, 10, 10, 10, 10, 10, 10]\n                ], dtype=np.int64),\n                \"Y\": np.array([\n                    [10, 9, 0, 0, 0],\n                    [0, 0, 0, 0, 0],\n                    [5, 4, 3, 2, 1]\n                ], dtype=np.float64)\n            },\n            \"params\": {\"alpha\": 0.2, \"z\": 0.5}\n        }\n    ]\n\n    all_case_results = []\n    for case in test_cases:\n        X = case[\"matrices\"][\"X\"]\n        Y = case[\"matrices\"][\"Y\"]\n        alpha = case[\"params\"][\"alpha\"]\n        z = case[\"params\"][\"z\"]\n        \n        case_result = analyze_multi_omics(X, Y, alpha, z)\n        all_case_results.append(case_result)\n    \n    # Format the final output string as specified\n    case_strings = [f\"[{','.join(map(str, res))}]\" for res in all_case_results]\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string.replace(\"'\", \"\").replace(\" \", \"\"))\n\n\ndef get_robust_thresholds(v, z):\n    \"\"\"\n    Computes robust lower and upper thresholds for a given metric vector.\n    \"\"\"\n    if v.size == 0:\n        return 0.0, 0.0\n        \n    m = np.median(v)\n    \n    # Calculate MAD and the robust scale s\n    c = 1.4826\n    mad = np.median(np.abs(v - m))\n    s = c * mad\n    \n    # Fallback to IQR if MAD-based scale is zero\n    if s == 0:\n        q1 = np.quantile(v, 0.25)\n        q3 = np.quantile(v, 0.75)\n        iqr = q3 - q1\n        s = iqr / 1.349\n    \n    # Final thresholds\n    t_low = m - z * s\n    t_high = m + z * s\n    \n    return t_low, t_high\n\ndef analyze_multi_omics(X, Y, alpha, z):\n    \"\"\"\n    Performs the full quality control analysis for one case.\n    \"\"\"\n    n, p = X.shape\n    q = Y.shape[1]\n\n    # 1. Calculate per-sample metrics\n    \n    # RNA-seq Library Size (LS)\n    ls_vec = np.sum(X, axis=1)\n\n    # RNA-seq 5' Bias (B)\n    k = int(np.floor(alpha * p))\n    b_vec = np.zeros(n, dtype=np.float64)\n    for i in range(n):\n        if ls_vec[i] > 0:\n            b_vec[i] = np.sum(X[i, :k]) / ls_vec[i]\n        else:\n            b_vec[i] = 0.0\n            \n    # Number of Identified Peptides (P)\n    p_vec = np.sum(Y > 0, axis=1)\n\n    # 2. Derive thresholds and flag outliers\n    \n    # For Library Size (LS) - flag low outliers\n    t_low_ls, _ = get_robust_thresholds(ls_vec, z)\n    ls_flags = (ls_vec  t_low_ls).tolist()\n\n    # For 5' Bias (B) - flag high outliers\n    _, t_high_b = get_robust_thresholds(b_vec, z)\n    b_flags = (b_vec > t_high_b).tolist()\n    \n    # For Peptide Count (P) - flag low outliers\n    t_low_p, _ = get_robust_thresholds(p_vec, z)\n    p_flags = (p_vec  t_low_p).tolist()\n\n    return [ls_flags, b_flags, p_flags]\n\nsolve()\n```", "id": "5062582"}, {"introduction": "在确保数据质量之后，一个核心任务是确定与疾病相关的遗传变异是否也调控基因表达，从而揭示其潜在的作用机制。本练习将引导您实现一个贝叶斯共定位分析模型，这是一种强大的统计方法，用于计算在特定基因座上的全基因组关联研究（GWAS）信号和表达数量性状基因座（eQTL）信号是否由同一个因果变异驱动。这项实践将帮助您理解如何整合不同来源的遗传学证据，以推断功能性的关联。[@problem_id:5062585]", "problem": "您将获得一个简化的、有原则的框架，用于在单个基因组位点上使用全基因组关联研究 (GWAS) 和表达数量性状位点 (eQTL) 信号进行统计共定位，并量化其对贝叶斯先验选择和连锁不平衡 (LD) 参考面板差异的敏感性。基本出发点是：包括贝叶斯定理在内的概率法则、标准化回归统计量的高斯似然，以及连锁不平衡作为单核苷酸多态性 (SNPs) 之间相关性结构的定义。您必须从这些原则中推导出一个可实现的算法，并计算两种性状共享同一因果变异的后验概率。\n\n从以下基本原则和定义开始：\n- 假设一个基因座内有 $M$ 个 SNPs，索引为 $j \\in \\{1,\\dots,M\\}$。对于每种性状，边际 $z$-分数的向量，记为 $\\mathbf{z}_{\\mathrm{marg}} \\in \\mathbb{R}^{M}$，是通过将性状分别对每个 SNP 进行线性回归得到的，其中基因型已标准化为单位方差。在单因果变异近似和标准化基因型下，边际 $z$-分数向量的期望值满足 $\\mathbb{E}[\\mathbf{z}_{\\mathrm{marg}}] = \\mathbf{R}\\,\\mathbf{z}_{\\mathrm{causal}}$，其中 $\\mathbf{R} \\in \\mathbb{R}^{M \\times M}$ 是 LD 相关矩阵，$\\mathbf{z}_{\\mathrm{causal}} \\in \\mathbb{R}^{M}$ 是一个稀疏向量，其非零项对应于因果 SNP。\n- 根据多元正态回归和线性代数的性质，可以通过求解线性系统 $\\mathbf{R}\\,\\widehat{\\mathbf{z}}_{\\mathrm{causal}} = \\mathbf{z}_{\\mathrm{marg}}$ 来获得假定因果 $z$-分数向量的估计量，即当 $\\mathbf{R}$ 可逆时，$\\widehat{\\mathbf{z}}_{\\mathrm{causal}} = \\mathbf{R}^{-1}\\,\\mathbf{z}_{\\mathrm{marg}}$。此步骤考虑了 LD 结构，并将取决于所选的 LD 参考面板。\n- 对于每个 SNP $j$，假设在备择假设下，真实标准化效应大小 $\\beta_{j} \\sim \\mathcal{N}(0, W)$ 服从高斯先验，在零假设下则为位于 $0$ 处的点质量。在给定 $\\beta_{j}$ 的条件下，对于观测到的标准化效应（等同于 $z$-分数）使用高斯似然，比较备择假设与零假设的单位点贝叶斯因子是 Wakefield 近似贝叶斯因子：\n$$\n\\mathrm{ABF}(z_{j}; W) \\;=\\; \\sqrt{\\frac{1}{1 + W}} \\;\\exp\\!\\left(\\frac{1}{2}\\,\\frac{W}{1+W}\\,z_{j}^{2}\\right),\n$$\n其中 $z_{j}$ 是标准化效应（此处，我们使用解卷积后的估计值 $z_{j} = \\widehat{z}_{\\mathrm{causal},j}$），而 $W$ 是备择假设下标准化效应大小的先验方差。\n- 为两种性状（性状1为GWAS，性状2为eQTL）定义以下假设：$H_{0}$（两种性状均无关联），$H_{1}$（仅在性状1中有关联），$H_{2}$（仅在性状2中有关联），$H_{3}$（两种性状的关联由不同的因果变异驱动），以及 $H_{4}$（两种性状的关联由相同的因果变异驱动）。假设在同一 SNP 上，仅性状1具有因果性的单位点先验概率为 $p_{1}$，仅性状2具有因果性的为 $p_{2}$，共享因果性的为 $p_{12}$。在稀有因果性近似下，每个假设的未归一化后验权重为：\n$$\nw_{0} \\;=\\; 1,\n$$\n$$\nw_{1} \\;=\\; \\sum_{j=1}^{M} p_{1}\\,\\mathrm{ABF}_{1,j},\n\\quad\nw_{2} \\;=\\; \\sum_{j=1}^{M} p_{2}\\,\\mathrm{ABF}_{2,j},\n$$\n$$\nw_{3} \\;=\\; \\sum_{\\substack{j=1\\\\k=1\\\\j\\neq k}}^{M} p_{1}\\,p_{2}\\,\\mathrm{ABF}_{1,j}\\,\\mathrm{ABF}_{2,k},\n\\quad\nw_{4} \\;=\\; \\sum_{j=1}^{M} p_{12}\\,\\mathrm{ABF}_{1,j}\\,\\mathrm{ABF}_{2,j},\n$$\n其中 $\\mathrm{ABF}_{1,j}$ 和 $\\mathrm{ABF}_{2,j}$ 分别是性状1和性状2的单位点贝叶斯因子，根据相应的解卷积 $z$-分数计算得出。$H_{4}$ 的后验概率则为\n$$\n\\mathrm{PP}_{4} \\;=\\; \\frac{w_{4}}{w_{0} + w_{1} + w_{2} + w_{3} + w_{4}}.\n$$\n\n您的任务是完全按照规定实现上述模型，并在一小组改变了先验选择和LD参考面板的测试套件上计算 $\\mathrm{PP}_{4}$。\n\n使用以下数值上指定且科学上合理的测试输入。\n\n- SNP数量：$M = 5$。\n\n- LD参考面板A（矩阵 $\\mathbf{R}_{A}$）：\n$$\n\\begin{bmatrix}\n1  0.2  0.1  0  0 \\\\\n0.2  1  0.3  0.1  0 \\\\\n0.1  0.3  1  0.25  0.05 \\\\\n0  0.1  0.25  1  0.2 \\\\\n0  0  0.05  0.2  1\n\\end{bmatrix}\n$$\n\n- LD参考面板B（矩阵 $\\mathbf{R}_{B}$）：\n$$\n\\begin{bmatrix}\n1  0.15  0.05  0  0 \\\\\n0.15  1  0.25  0.05  0 \\\\\n0.05  0.25  1  0.2  0.1 \\\\\n0  0.05  0.2  1  0.25 \\\\\n0  0  0.1  0.25  1\n\\end{bmatrix}\n$$\n\n- 标准化效应的先验方差（两种性状相同）：$W = 0.2$。\n\n- 先验集A：$p_{1} = 1 \\times 10^{-4}$，$p_{2} = 1 \\times 10^{-4}$，$p_{12} = 1 \\times 10^{-5}$。\n\n- 先验集B：$p_{1} = 1 \\times 10^{-4}$，$p_{2} = 1 \\times 10^{-4}$，$p_{12} = 5 \\times 10^{-5}$。\n\n- 测试位点和观测到的边际 $z$-分数（性状1为GWAS，性状2为eQTL）。每个向量按SNP索引 $j \\in \\{1,2,3,4,5\\}$ 排序。\n    - 位点1（强共享信号）：\n        - $\\mathbf{z}^{(1)}_{\\mathrm{GWAS}} = [\\,0.6,\\,1.8,\\,6.0,\\,1.5,\\,0.3\\,]$\n        - $\\mathbf{z}^{(1)}_{\\mathrm{eQTL}} = [\\,0.5,\\,1.5,\\,5.0,\\,1.25,\\,0.25\\,]$\n    - 位点2（两种性状间信号不同）：\n        - $\\mathbf{z}^{(2)}_{\\mathrm{GWAS}} = [\\,1.0,\\,5.0,\\,1.5,\\,0.5,\\,0.0\\,]$\n        - $\\mathbf{z}^{(2)}_{\\mathrm{eQTL}} = [\\,0.0,\\,0.5,\\,1.25,\\,5.0,\\,1.0\\,]$\n    - 位点3（有GWAS信号但无eQTL支持）：\n        - $\\mathbf{z}^{(3)}_{\\mathrm{GWAS}} = [\\,0.6,\\,1.8,\\,6.0,\\,1.5,\\,0.3\\,]$\n        - $\\mathbf{z}^{(3)}_{\\mathrm{eQTL}} = [\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,]$\n\n计算要求：\n- 对于每个位点、每个LD参考面板（$\\mathbf{R}_{A}$ 和 $\\mathbf{R}_{B}$）以及每个先验集（A和B），通过以下步骤计算 $\\mathrm{PP}_{4}$：\n    $1)$ 使用所选的 $\\mathbf{R}$ 对两种性状的边际 $z$-分数进行解卷积，以获得每种性状的 $\\widehat{\\mathbf{z}}_{\\mathrm{causal}}$，\n    $2)$ 使用给定的 $W$ 计算单位点近似贝叶斯因子，\n    $3)$ 使用指定的单位点先验形成未归一化的权重 $w_{0},\\dots,w_{4}$，以及\n    $4)$ 进行归一化以获得 $\\mathrm{PP}_{4}$。\n\n测试套件和输出规范：\n- 按以下固定顺序评估 $12$ 项计算：\n    $1)$ 位点 $1$，$\\mathbf{R}_{A}$，先验A；\n    $2)$ 位点 $1$，$\\mathbf{R}_{A}$，先验B；\n    $3)$ 位点 $1$，$\\mathbf{R}_{B}$，先验A；\n    $4)$ 位点 $1$，$\\mathbf{R}_{B}$，先验B；\n    $5)$ 位点 $2$，$\\mathbf{R}_{A}$，先验A；\n    $6)$ 位点 $2$，$\\mathbf{R}_{A}$，先验B；\n    $7)$ 位点 $2$，$\\mathbf{R}_{B}$，先验A；\n    $8)$ 位点 $2$，$\\mathbf{R}_{B}$，先验B；\n    $9)$ 位点 $3$，$\\mathbf{R}_{A}$，先验A；\n    $10)$ 位点 $3$，$\\mathbf{R}_{A}$，先验B；\n    $11)$ 位点 $3$，$\\mathbf{R}_{B}$，先验A；\n    $12)$ 位点 $3$，$\\mathbf{R}_{B}$，先验B。\n- 程序必须生成单行输出，其中包含 $12$ 个 $\\mathrm{PP}_{4}$ 值，格式为方括号内的逗号分隔列表，例如 $[x_{1},x_{2},\\dots,x_{12}]$，其中每个 $x_{i}$ 是一个十进制形式的浮点数。不允许使用百分比；所有量都必须是 $[0,1]$ 范围内的十进制数。\n\n您的实现必须是一个完整的、可运行的程序，不读取任何输入，并严格按照指定的顺序和格式输出一行结果。", "solution": "用户提供了一个问题，要求实现一个统计共定位模型，以计算全基因组关联研究 (GWAS) 信号和表达数量性状位点 (eQTL) 信号共享一个因果变异 ($H_4$) 的后验概率。\n\n### 第1步：问题验证\n\n首先对问题的有效性进行严格评估。\n\n#### 已知条件提取\n从问题陈述中逐字提取已知条件：\n- **模型参数**：SNP数量 $M=5$。标准化效应大小的先验方差 $W=0.2$。\n- **LD 矩阵**：$\\mathbf{R}_A$ 和 $\\mathbf{R}_B$，均为 $5 \\times 5$ 矩阵，表示连锁不平衡相关结构。\n- **先验集**：\n    -   先验A：$p_1 = 1 \\times 10^{-4}$，$p_2 = 1 \\times 10^{-4}$，$p_{12} = 1 \\times 10^{-5}$。\n    -   先验B：$p_1 = 1 \\times 10^{-4}$，$p_2 = 1 \\times 10^{-4}$，$p_{12} = 5 \\times 10^{-5}$。\n- **观测数据（边际z分数）**：\n    -   位点1：$\\mathbf{z}^{(1)}_{\\mathrm{GWAS}} = [0.6, 1.8, 6.0, 1.5, 0.3]$，$\\mathbf{z}^{(1)}_{\\mathrm{eQTL}} = [0.5, 1.5, 5.0, 1.25, 0.25]$。\n    -   位点2：$\\mathbf{z}^{(2)}_{\\mathrm{GWAS}} = [1.0, 5.0, 1.5, 0.5, 0.0]$，$\\mathbf{z}^{(2)}_{\\mathrm{eQTL}} = [0.0, 0.5, 1.25, 5.0, 1.0]$。\n    -   位点3：$\\mathbf{z}^{(3)}_{\\mathrm{GWAS}} = [0.6, 1.8, 6.0, 1.5, 0.3]$，$\\mathbf{z}^{(3)}_{\\mathrm{eQTL}} = [0.0, 0.0, 0.0, 0.0, 0.0]$。\n- **核心方程**：\n    1.  因果z分数估计：$\\widehat{\\mathbf{z}}_{\\mathrm{causal}} = \\mathbf{R}^{-1}\\,\\mathbf{z}_{\\mathrm{marg}}$。\n    2.  近似贝叶斯因子：$\\mathrm{ABF}(z_j; W) = \\sqrt{\\frac{1}{1+W}}\\,\\exp(\\frac{1}{2}\\,\\frac{W}{1+W}\\,z_j^2)$，其中 $z_j = \\widehat{z}_{\\mathrm{causal},j}$。\n    3.  未归一化的后验权重：$w_0, w_1, w_2, w_3, w_4$ 的表达式。\n    4.  $H_4$ 的后验概率：$\\mathrm{PP}_4 = w_4 / \\sum_{i=0}^4 w_i$。\n- **计算任务**：为12个指定的位点、LD面板和先验集的组合计算 $\\mathrm{PP}_4$。\n\n#### 验证结论\n-   **科学依据**：该问题描述了 `coloc` 统计框架的一个简化版本，这是一种在统计遗传学中用于整合 GWAS 和 eQTL 数据的标准且被广泛接受的方法。其基本原理——贝叶斯定理、用于回归系数的多元正态理论以及近似贝叶斯因子 (ABF) 的使用——都是该领域的标准方法。\n-   **适定性**：所有必需的数据、方程和常数均已提供。LD 矩阵 $\\mathbf{R}_A$ 和 $\\mathbf{R}_B$ 是对称正定的（它们的行列式分别约为 $0.741$ 和 $0.823$），这确保了它们是可逆的，并且 $\\widehat{\\mathbf{z}}_{\\mathrm{causal}}$ 存在唯一解。指令明确，对于每个指定情况都能得出唯一的数值结果。\n-   **客观性**：问题以精确的数学语言陈述，没有主观性或模糊性。\n\n该问题被认为是**有效的**，因为它是自洽的、科学合理的且适定的。\n\n### 第2步：解法推导与实现\n解决方案涉及对 12 个测试用例系统地应用所提供的公式。对每个用例，算法按以下步骤进行。\n\n1.  **选择输入**：对于每个用例，选择特定的边际 z 分数向量 ($\\mathbf{z}_{\\mathrm{GWAS}}, \\mathbf{z}_{\\mathrm{eQTL}}$)、LD 矩阵 ($\\mathbf{R}$) 和先验概率 ($p_1, p_2, p_{12}$)。\n\n2.  **解卷积z分数以估计因果效应**：LD 结构掩盖了真实的因果信号。为了解释这一点，通过对 LD 矩阵求逆来“解卷积”边际 z 分数。这是一种统计精细定位的形式。\n    $$ \\widehat{\\mathbf{z}}_{\\mathrm{causal},1} = \\mathbf{R}^{-1}\\mathbf{z}_{\\mathrm{GWAS}} $$\n    $$ \\widehat{\\mathbf{z}}_{\\mathrm{causal},2} = \\mathbf{R}^{-1}\\mathbf{z}_{\\mathrm{eQTL}} $$\n    此处，$\\widehat{\\mathbf{z}}_{\\mathrm{causal},1}$ 和 $\\widehat{\\mathbf{z}}_{\\mathrm{causal},2}$ 分别是性状1 (GWAS) 和性状2 (eQTL) 的估计因果 z 分数向量。\n\n3.  **计算近似贝叶斯因子 (ABF)**：对于每个 SNP $j \\in \\{1, \\dots, M\\}$ 和每种性状，计算一个 ABF。ABF 量化了该 SNP 存在非零效应的证据。计算使用估计的因果 z 分数向量的分量。\n    令 $c_1 = \\sqrt{\\frac{1}{1+W}}$ 且 $c_2 = \\frac{1}{2}\\frac{W}{1+W}$。每种性状的 ABF 按元素计算：\n    $$ \\mathrm{ABF}_{1,j} = c_1 \\exp(c_2 (\\widehat{z}_{\\mathrm{causal},1,j})^2) $$\n    $$ \\mathrm{ABF}_{2,j} = c_1 \\exp(c_2 (\\widehat{z}_{\\mathrm{causal},2,j})^2) $$\n\n4.  **计算聚合统计量和未归一化的后验权重**：将单位点 ABF 进行聚合，形成计算假设权重所需的总和。\n    $$ S_1 = \\sum_{j=1}^{M} \\mathrm{ABF}_{1,j} $$\n    $$ S_2 = \\sum_{j=1}^{M} \\mathrm{ABF}_{2,j} $$\n    $$ S_{12} = \\sum_{j=1}^{M} \\mathrm{ABF}_{1,j} \\mathrm{ABF}_{2,j} $$\n    然后使用这些总和来计算五个假设中每个假设的未归一化后验权重，如问题陈述中所定义：\n    $$ w_0 = 1 $$\n    $$ w_1 = p_1 S_1 $$\n    $$ w_2 = p_2 S_2 $$\n    $$ w_3 = p_1 p_2 (S_1 S_2 - S_{12}) $$\n    $$ w_4 = p_{12} S_{12} $$\n\n5.  **计算 $H_4$ 的后验概率**：通过将权重除以其总和进行归一化，得到后验概率。所需量 $\\mathrm{PP}_4$ 是假设 $H_4$ 的归一化权重。\n    $$ \\mathrm{PP}_4 = \\frac{w_4}{w_0 + w_1 + w_2 + w_3 + w_4} $$\n\n此过程被实现并对 12 个指定的测试用例进行循环，然后收集生成的 $\\mathrm{PP}_4$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the specified statistical colocalization model and computes the posterior probability of a shared causal variant (PP4) for a suite of 12 test cases.\n    \"\"\"\n    \n    # ------------------ Define Givens from Problem Statement ------------------\n    \n    # Number of SNPs\n    M = 5\n    \n    # Prior variance for standardized effects\n    W = 0.2\n    \n    # LD reference panels\n    R_A = np.array([\n        [1.0, 0.2, 0.1, 0.0, 0.0],\n        [0.2, 1.0, 0.3, 0.1, 0.0],\n        [0.1, 0.3, 1.0, 0.25, 0.05],\n        [0.0, 0.1, 0.25, 1.0, 0.2],\n        [0.0, 0.0, 0.05, 0.2, 1.0]\n    ])\n    \n    R_B = np.array([\n        [1.0, 0.15, 0.05, 0.0, 0.0],\n        [0.15, 1.0, 0.25, 0.05, 0.0],\n        [0.05, 0.25, 1.0, 0.2, 0.1],\n        [0.0, 0.05, 0.2, 1.0, 0.25],\n        [0.0, 0.0, 0.1, 0.25, 1.0]\n    ])\n    \n    # Prior sets\n    priors_A = {'p1': 1e-4, 'p2': 1e-4, 'p12': 1e-5}\n    priors_B = {'p1': 1e-4, 'p2': 1e-4, 'p12': 5e-5}\n    \n    # Test loci and observed marginal z-scores\n    locus1_z_gwas = np.array([0.6, 1.8, 6.0, 1.5, 0.3])\n    locus1_z_eqtl = np.array([0.5, 1.5, 5.0, 1.25, 0.25])\n    \n    locus2_z_gwas = np.array([1.0, 5.0, 1.5, 0.5, 0.0])\n    locus2_z_eqtl = np.array([0.0, 0.5, 1.25, 5.0, 1.0])\n    \n    locus3_z_gwas = np.array([0.6, 1.8, 6.0, 1.5, 0.3])\n    locus3_z_eqtl = np.array([0.0, 0.0, 0.0, 0.0, 0.0])\n\n    # ------------------ Setup Test Suite ------------------\n    \n    test_cases = [\n        # Locus 1\n        (locus1_z_gwas, locus1_z_eqtl, R_A, priors_A),\n        (locus1_z_gwas, locus1_z_eqtl, R_A, priors_B),\n        (locus1_z_gwas, locus1_z_eqtl, R_B, priors_A),\n        (locus1_z_gwas, locus1_z_eqtl, R_B, priors_B),\n        # Locus 2\n        (locus2_z_gwas, locus2_z_eqtl, R_A, priors_A),\n        (locus2_z_gwas, locus2_z_eqtl, R_A, priors_B),\n        (locus2_z_gwas, locus2_z_eqtl, R_B, priors_A),\n        (locus2_z_gwas, locus2_z_eqtl, R_B, priors_B),\n        # Locus 3\n        (locus3_z_gwas, locus3_z_eqtl, R_A, priors_A),\n        (locus3_z_gwas, locus3_z_eqtl, R_A, priors_B),\n        (locus3_z_gwas, locus3_z_eqtl, R_B, priors_A),\n        (locus3_z_gwas, locus3_z_eqtl, R_B, priors_B),\n    ]\n\n    results = []\n    \n    # Pre-calculate ABF constants\n    c1 = np.sqrt(1 / (1 + W))\n    c2 = 0.5 * W / (1 + W)\n    \n    # Pre-calculate matrix inverses\n    inv_R_A = np.linalg.inv(R_A)\n    inv_R_B = np.linalg.inv(R_B)\n    \n    # Map LD matrices to their pre-computed inverses\n    inv_R_map = {id(R_A): inv_R_A, id(R_B): inv_R_B}\n\n    for z_gwas, z_eqtl, R, priors in test_cases:\n        \n        # Step 1: Deconvolve z-scores\n        inv_R = inv_R_map[id(R)]\n        z_causal_gwas = inv_R @ z_gwas\n        z_causal_eqtl = inv_R @ z_eqtl\n        \n        # Step 2: Compute Approximate Bayes Factors (ABF)\n        abf1 = c1 * np.exp(c2 * z_causal_gwas**2)\n        abf2 = c1 * np.exp(c2 * z_causal_eqtl**2)\n        \n        # Step 3: Compute aggregate statistics and unnormalized posterior weights\n        S1 = np.sum(abf1)\n        S2 = np.sum(abf2)\n        S12 = np.sum(abf1 * abf2)\n        \n        p1 = priors['p1']\n        p2 = priors['p2']\n        p12 = priors['p12']\n        \n        w0 = 1.0\n        w1 = p1 * S1\n        w2 = p2 * S2\n        w3 = p1 * p2 * (S1 * S2 - S12)\n        w4 = p12 * S12\n        \n        # Step 4: Calculate the Posterior Probability for H4\n        total_w = w0 + w1 + w2 + w3 + w4\n        pp4 = w4 / total_w if total_w > 0 else 0.0\n        \n        results.append(pp4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "5062585"}, {"introduction": "利用多组学数据构建疾病预测模型是该领域的一个主要目标，但这样的模型在面对现实世界的噪声和测量误差时有多可靠？本练习将探讨模型稳健性这一关键概念。您将通过解析计算，分析一个分类器的性能（以ROC曲线下面积$AUC$衡量）如何随着噪声水平的增加而下降，并最终确定模型性能的“容忍阈值”。[@problem_id:5062537]", "problem": "给定一个通过整合信使核糖核酸（mRNA）转录组学、DNA甲基化表观基因组学和蛋白质组学等多种模态构建的多组学疾病风险评分的简化数学模型。对于一个给定的患者，令 $d$ 维特征向量为 $x \\in \\mathbb{R}^d$，类别标签为 $y \\in \\{0,1\\}$，以及综合线性评分为 $s = w^\\top x$，其中 $w \\in \\mathbb{R}^d$ 是从一个训练好的模型中得出的固定权重。假设一个二元分类场景，其中类别条件下的特征分布是具有相同协方差的多元正态分布，即对于 $k \\in \\{0,1\\}$，$x \\mid y=k \\sim \\mathcal{N}(\\mu_k, \\Sigma)$，其中 $\\Sigma$ 是对称正定矩阵，并且对于两个类别是相同的。定义类别均值差向量 $\\Delta \\mu = \\mu_1 - \\mu_0$。考虑在水平 $\\alpha \\ge 0$ 下进行受控、独立、按模态的高斯噪声注入：具体来说，将加性噪声 $n \\sim \\mathcal{N}(0, \\alpha^2 \\operatorname{diag}(\\nu \\odot \\nu))$ 应用于 $x$，其中 $\\nu \\in \\mathbb{R}^d$ 是一个非负振幅向量，$\\odot$ 表示逐元素乘法。噪声注入后，有效协方差变为 $\\Sigma(\\alpha) = \\Sigma + \\alpha^2 \\operatorname{diag}(\\nu \\odot \\nu)$，而类别均值保持不变。令综合评分为 $s(\\alpha) = w^\\top (x + n)$。\n\n从第一性原理出发，推导一个数学上可靠的方法，以计算作为噪声水平 $\\alpha$ 函数的受试者工作特征曲线下面积（ROC AUC）的性能下降曲线，并确定一个容忍度阈值，该阈值定义为闭区间 $[0, \\alpha_{\\max}]$ 中使得 ROC AUC 保持在目标水平 $t \\in (0,1)$ 以上的最大 $\\alpha$ 值。必须使用以下约束：\n- 假设噪声注入后，两个类别的特征共享相同的协方差矩阵，因此评分分布 $s(\\alpha) \\mid y=0$ 和 $s(\\alpha) \\mid y=1$ 是具有相同方差的单变量正态分布。\n- 仅使用基本概率结果和正态分布的性质来表示 ROC AUC；不要假设任何未从这些原理推导出的简化公式。\n- 证明在所述假设下，ROC AUC 是 $\\alpha$ 的单调非增函数。\n\n您的程序必须实现所推导的方法，并为下面的测试套件中的每个参数集计算容忍度阈值。在开发过程中，应在 $\\alpha$ 值的网格 $[0.0, 0.5, 1.0, 1.5, 2.0, 3.0]$ 上评估内部性能下降曲线以供检查，但只应打印容忍度阈值。每个容忍度阈值必须计算为满足 ROC AUC$(\\alpha) \\ge t$ 的 $\\alpha \\in [0, \\alpha_{\\max}]$ 的上确界，需使用与单调性一致的求根方法。如果 ROC AUC$(0)  t$，则阈值为 $0$。如果 ROC AUC$(\\alpha_{\\max}) \\ge t$，则阈值为 $\\alpha_{\\max}$。否则，返回唯一的 $\\alpha^\\star \\in (0, \\alpha_{\\max})$，使得 ROC AUC$(\\alpha^\\star) = t$。\n\n所有特征都已标准化为无量纲的 $z$-分数，因此不涉及物理单位。所有角度（如有）均不相关。所有数值输出均表示为四舍五入到六位小数的小数。\n\n测试套件（每个案例使用 $d=3$ 种模态：转录组学、甲基化、蛋白质组学）：\n- 案例1（常规多组学整合，中等信号和相关性）：\n  - $w = [0.5, 0.3, 0.2]$\n  - $\\Delta \\mu = [0.8, 0.4, 0.5]$\n  - $\\Sigma = \\begin{bmatrix} 1.0  0.1  0.2 \\\\ 0.1  0.8  0.15 \\\\ 0.2  0.15  1.2 \\end{bmatrix}$\n  - $\\nu = [0.5, 0.3, 0.7]$\n  - $\\alpha_{\\max} = 3.0$\n  - $t = 0.75$\n- 案例2（信号弱而分散，具有较强的跨模态协方差）：\n  - $w = [0.33, 0.33, 0.34]$\n  - $\\Delta \\mu = [0.2, 0.2, 0.2]$\n  - $\\Sigma = \\begin{bmatrix} 1.2  0.4  0.3 \\\\ 0.4  1.0  0.2 \\\\ 0.3  0.2  1.1 \\end{bmatrix}$\n  - $\\nu = [0.6, 0.6, 0.6]$\n  - $\\alpha_{\\max} = 2.0$\n  - $t = 0.60$\n- 案例3（在中等附加噪声下，蛋白质组学信号占主导地位）：\n  - $w = [0.1, 0.2, 0.7]$\n  - $\\Delta \\mu = [0.1, 0.1, 1.0]$\n  - $\\Sigma = \\begin{bmatrix} 0.9  0.2  0.25 \\\\ 0.2  0.7  0.3 \\\\ 0.25  0.3  1.5 \\end{bmatrix}$\n  - $\\nu = [0.4, 0.4, 0.5]$\n  - $\\alpha_{\\max} = 5.0$\n  - $t = 0.85$\n- 案例4（边缘情况：无真实信号）：\n  - $w = [0.4, 0.3, 0.3]$\n  - $\\Delta \\mu = [0.0, 0.0, 0.0]$\n  - $\\Sigma = \\begin{bmatrix} 1.0  0.0  0.0 \\\\ 0.0  1.0  0.0 \\\\ 0.0  0.0  1.0 \\end{bmatrix}$\n  - $\\nu = [0.5, 0.5, 0.5]$\n  - $\\alpha_{\\max} = 5.0$\n  - $t = 0.55$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个案例的容忍度阈值，格式为方括号内以逗号分隔的列表（例如，`\"[0.123456,0.654321,0.500000,0.000000]\"`），每个值都四舍五入到六位小数。", "solution": "用户提供了一个在统计建模领域中明确定义的问题。我将首先验证问题陈述，然后进行完整解答。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n-   特征向量：$x \\in \\mathbb{R}^d$。\n-   类别标签：$y \\in \\{0, 1\\}$。\n-   权重向量：$w \\in \\mathbb{R}^d$。\n-   类别条件分布：对于 $k \\in \\{0,1\\}$，$x \\mid y=k \\sim \\mathcal{N}(\\mu_k, \\Sigma)$，其中 $\\Sigma$ 是对称正定矩阵。\n-   类别均值差：$\\Delta \\mu = \\mu_1 - \\mu_0$。\n-   加性噪声：对于噪声水平 $\\alpha \\ge 0$ 和非负振幅向量 $\\nu \\in \\mathbb{R}^d$，$n \\sim \\mathcal{N}(0, \\alpha^2 \\operatorname{diag}(\\nu \\odot \\nu))$。\n-   含噪评分：$s(\\alpha) = w^\\top(x+n)$。\n-   有效协方差：$\\Sigma(\\alpha) = \\Sigma + \\alpha^2 \\operatorname{diag}(\\nu \\odot \\nu)$。\n-   假设：评分分布 $s(\\alpha) \\mid y=k$ 是具有相同方差的单变量正态分布。\n-   目标：推导一个计算 ROC AUC 作为 $\\alpha$ 函数的方法，证明其非增性质，并为目标水平 $t \\in (0,1)$ 找到容忍度阈值 $\\alpha^\\star = \\sup\\{\\alpha \\in [0, \\alpha_{\\max}] \\mid \\text{ROC AUC}(\\alpha) \\ge t\\}$。\n-   阈值的边界条件：\n    -   如果 $\\text{ROC AUC}(0)  t$，阈值为 $0$。\n    -   如果 $\\text{ROC AUC}(\\alpha_{\\max}) \\ge t$，阈值为 $\\alpha_{\\max}$。\n-   测试案例：提供了四组参数 $(w, \\Delta\\mu, \\Sigma, \\nu, \\alpha_{\\max}, t)$。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题基于统计决策理论和多元统计学的基本原理。使用高斯分布对特征和噪声进行建模以及使用线性分类器是标准技术。ROC AUC 是分类器评估的基石。该问题是一个有充分依据的鲁棒性分析练习。\n-   **适定性**：所有变量和约束都已明确定义。多元正态分布和正定协方差矩阵（我已通过检查特征值对所有测试案例进行了验证）等假设确保了评分的分布是明确定义的。目标明确，确定阈值的规则涵盖了所有可能性，确保了唯一解的存在。\n-   **目标**：问题使用形式化的数学语言陈述，没有主观性或歧义。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**。这是一个自洽、科学上可靠且适定的问题。我现在将按要求从第一性原理出发推导解决方案。\n\n### 推导与求解\n\n**1. 综合评分的分布**\n\n对于来自类别 $k \\in \\{0, 1\\}$ 的患者，噪声注入后的特征向量为 $x' = x + n$。由于 $x \\mid y=k$ 和 $n$ 是独立的多元正态变量，它们的和 $x'$ 也是一个多元正态变量。\n$x'$ 的均值为 $E[x' \\mid y=k] = E[x \\mid y=k] + E[n] = \\mu_k + 0 = \\mu_k$。\n$x'$ 的协方差为 $\\operatorname{Cov}(x' \\mid y=k) = \\operatorname{Cov}(x \\mid y=k) + \\operatorname{Cov}(n) = \\Sigma + \\alpha^2 \\operatorname{diag}(\\nu \\odot \\nu) = \\Sigma(\\alpha)$。两个类别的协方差是相同的。\n\n综合评分 $s(\\alpha) = w^\\top x'$ 是多元正态向量 $x'$ 的线性变换。因此，对于每个类别 $k$，$s(\\alpha)$ 服从单变量正态分布：$s(\\alpha) \\mid y=k \\sim \\mathcal{N}(\\mu_{s,k}(\\alpha), \\sigma_s^2(\\alpha))$。\n\n类别 $k$ 的评分分布均值为：\n$$ \\mu_{s,k}(\\alpha) = E[w^\\top x' \\mid y=k] = w^\\top E[x' \\mid y=k] = w^\\top \\mu_k $$\n评分的均值与噪声水平 $\\alpha$ 无关。\n\n根据规定，两个类别的评分分布方差相同：\n$$ \\sigma_s^2(\\alpha) = \\operatorname{Var}(w^\\top x' \\mid y=k) = w^\\top \\operatorname{Cov}(x' \\mid y=k) w = w^\\top \\Sigma(\\alpha) w $$\n代入 $\\Sigma(\\alpha)$ 的定义：\n$$ \\sigma_s^2(\\alpha) = w^\\top (\\Sigma + \\alpha^2 \\operatorname{diag}(\\nu \\odot \\nu)) w = w^\\top \\Sigma w + \\alpha^2 w^\\top \\operatorname{diag}(\\nu \\odot \\nu) w $$\n令 $\\sigma_{s,0}^2 = w^\\top \\Sigma w$ 为基线评分方差，$\\sigma_{s,n}^2 = w^\\top \\operatorname{diag}(\\nu \\odot \\nu) w = \\sum_{i=1}^d (w_i \\nu_i)^2$。则方差为：\n$$ \\sigma_s^2(\\alpha) = \\sigma_{s,0}^2 + \\alpha^2 \\sigma_{s,n}^2 $$\n\n**2. ROC AUC 公式推导**\n\nROC AUC 是指从正类别（$y=1$）中随机选择的样本评分高于从负类别（$y=0$）中随机选择的样本评分的概率。令 $S_1 = s(\\alpha) \\mid y=1$ 且 $S_0 = s(\\alpha) \\mid y=0$。我们有：\n$$ S_1 \\sim \\mathcal{N}(w^\\top \\mu_1, \\sigma_s^2(\\alpha)) \\quad \\text{和} \\quad S_0 \\sim \\mathcal{N}(w^\\top \\mu_0, \\sigma_s^2(\\alpha)) $$\nROC AUC 由 $\\text{AUC} = P(S_1 > S_0)$ 给出。考虑差值随机变量 $D = S_1 - S_0$。由于 $S_1$ 和 $S_0$ 是独立的普通变量，$D$ 也服从正态分布。\n$D$ 的均值为 $E[D] = E[S_1] - E[S_0] = w^\\top\\mu_1 - w^\\top\\mu_0 = w^\\top(\\mu_1 - \\mu_0) = w^\\top \\Delta\\mu$。\n$D$ 的方差为 $\\operatorname{Var}(D) = \\operatorname{Var}(S_1) + \\operatorname{Var}(S_0) = \\sigma_s^2(\\alpha) + \\sigma_s^2(\\alpha) = 2\\sigma_s^2(\\alpha)$。\n因此，$D \\sim \\mathcal{N}(w^\\top \\Delta\\mu, 2\\sigma_s^2(\\alpha))$。\n\nAUC 是 $P(D > 0)$。对变量 $D$ 进行标准化：\n$$ \\text{AUC} = P\\left( \\frac{D - E[D]}{\\sqrt{\\operatorname{Var}(D)}} > \\frac{0 - E[D]}{\\sqrt{\\operatorname{Var}(D)}} \\right) $$\n令 $Z \\sim \\mathcal{N}(0,1)$ 为标准正态变量。\n$$ \\text{AUC} = P\\left( Z > \\frac{-w^\\top \\Delta\\mu}{\\sqrt{2\\sigma_s^2(\\alpha)}} \\right) = 1 - \\Phi\\left( \\frac{-w^\\top \\Delta\\mu}{\\sqrt{2\\sigma_s^2(\\alpha)}} \\right) $$\n其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数（CDF）。利用对称性 $\\Phi(-z) = 1 - \\Phi(z)$，我们得到 ROC AUC 作为 $\\alpha$ 函数的最终表达式：\n$$ \\text{AUC}(\\alpha) = \\Phi\\left( \\frac{w^\\top \\Delta\\mu}{\\sqrt{2\\sigma_s^2(\\alpha)}} \\right) = \\Phi\\left( \\frac{w^\\top \\Delta\\mu}{\\sqrt{2(w^\\top \\Sigma w + \\alpha^2 \\sum_{i=1}^d (w_i \\nu_i)^2)}} \\right) $$\n\n**3. 单调性证明**\n\n为了证明对于 $\\alpha \\ge 0$，$\\text{AUC}(\\alpha)$ 是 $\\alpha$ 的单调非增函数，我们分析其参数。CDF $\\Phi(z)$ 是其参数 $z$ 的严格递增函数。因此，$\\text{AUC}(\\alpha)$ 的单调性由其参数的单调性决定：\n$$ g(\\alpha) = \\frac{w^\\top \\Delta\\mu}{\\sqrt{2(\\sigma_{s,0}^2 + \\alpha^2 \\sigma_{s,n}^2)}} $$\n我们来分析各项。一个有意义的分类器应具有权重 $w$，使得类别均值评分之间的分离度为正，即 $\\Delta\\mu_s = w^\\top \\Delta\\mu \\ge 0$。所有测试案例都满足这一点。分母包含项 $V(\\alpha) = \\sigma_{s,0}^2 + \\alpha^2 \\sigma_{s,n}^2$。\n-   由于 $\\Sigma$ 是正定的且 $w \\neq 0$，所以 $\\sigma_{s,0}^2 = w^\\top \\Sigma w > 0$。\n-   由于 $\\nu$ 是一个非负向量，所以 $\\sigma_{s,n}^2 = \\sum_i (w_i \\nu_i)^2 \\ge 0$。\n-   对于 $\\alpha \\ge 0$，$\\alpha^2$ 项是单调非减的。\n\n分母 $\\sqrt{2V(\\alpha)}$ 是 $\\alpha$ 的单调非减函数。\n-   如果 $\\sigma_{s,n}^2 > 0$，则对于 $\\alpha > 0$，分母是严格递增的。\n-   如果 $\\Delta\\mu_s > 0$，那么 $g(\\alpha)$ 是一个正常数除以一个严格递增函数，因此对于 $\\alpha > 0$ 是严格递减的。\n-   如果 $\\Delta\\mu_s = 0$（如案例4），则对于所有 $\\alpha$，$g(\\alpha) = 0$，且 $\\text{AUC}(\\alpha) = \\Phi(0) = 0.5$，这是一个常数（因此是单调非增的）。\n-   如果 $\\sigma_{s,n}^2=0$，噪声不影响评分方差，因此 $g(\\alpha)$ 和 $\\text{AUC}(\\alpha)$ 是常数。\n\n在所有相关场景中，$\\text{AUC}(\\alpha)$ 都是 $\\alpha \\ge 0$ 的单调非增函数。证明完毕。\n\n**4. 计算容忍度阈值的方法**\n\n我们需要找到 $\\alpha^\\star = \\sup\\{\\alpha \\in [0, \\alpha_{\\max}] \\mid \\text{AUC}(\\alpha) \\ge t\\}$。基于已证明的单调性，我们可以建立一个清晰的流程。\n\n首先，评估在零噪声下的性能，$\\text{AUC}(0)$。\n$$ \\text{AUC}(0) = \\Phi\\left( \\frac{w^\\top \\Delta\\mu}{\\sqrt{2 w^\\top \\Sigma w}} \\right) $$\n如果 $\\text{AUC}(0)  t$，即使在最佳情况下也不满足条件。由于 $\\text{AUC}(\\alpha)$ 是非增的，对于任何 $\\alpha > 0$ 都不满足条件。因此，阈值为 $\\alpha^\\star = 0$。\n\n如果 $\\text{AUC}(0) \\ge t$，可能存在一个非零阈值。我们接着检查在最大噪声水平 $\\alpha_{\\max}$ 下的性能。\n$$ \\text{AUC}(\\alpha_{\\max}) = \\Phi\\left( \\frac{w^\\top \\Delta\\mu}{\\sqrt{2(w^\\top \\Sigma w + \\alpha_{\\max}^2 \\sigma_{s,n}^2)}} \\right) $$\n如果 $\\text{AUC}(\\alpha_{\\max}) \\ge t$，则性能在整个区间 $[0, \\alpha_{\\max}]$ 上都是足够的。在此区间内满足条件的最大 $\\alpha$ 值为 $\\alpha_{\\max}$。因此，$\\alpha^\\star = \\alpha_{\\max}$。\n\n如果 $\\text{AUC}(0) \\ge t$ 且 $\\text{AUC}(\\alpha_{\\max})  t$，那么根据连续性和单调性，必然存在一个唯一的 $\\alpha^\\star \\in (0, \\alpha_{\\max})$ 使得 $\\text{AUC}(\\alpha^\\star) = t$。我们可以通过解方程找到这个值。与其使用迭代数值求根法，我们可以获得一个精确的解析解。\n$$ \\Phi\\left( \\frac{w^\\top \\Delta\\mu}{\\sqrt{2(\\sigma_{s,0}^2 + (\\alpha^\\star)^2 \\sigma_{s,n}^2)}} \\right) = t $$\n应用逆正态累积分布函数 $\\Phi^{-1}$（也称为概率单位函数），我们得到：\n$$ \\frac{w^\\top \\Delta\\mu}{\\sqrt{2(\\sigma_{s,0}^2 + (\\alpha^\\star)^2 \\sigma_{s,n}^2)}} = \\Phi^{-1}(t) $$\n令 $z_t = \\Phi^{-1}(t)$。对于 $t \\in (0.5, 1)$，我们有 $z_t > 0$。对 $(\\alpha^\\star)^2$ 进行平方和整理：\n$$ \\frac{(w^\\top \\Delta\\mu)^2}{2 z_t^2} = \\sigma_{s,0}^2 + (\\alpha^\\star)^2 \\sigma_{s,n}^2 $$\n$$ (\\alpha^\\star)^2 \\sigma_{s,n}^2 = \\frac{(w^\\top \\Delta\\mu)^2}{2 z_t^2} - \\sigma_{s,0}^2 $$\n$$ (\\alpha^\\star)^2 = \\frac{1}{\\sigma_{s,n}^2} \\left( \\frac{(w^\\top \\Delta\\mu)^2}{2 z_t^2} - \\sigma_{s,0}^2 \\right) $$\n这给出了阈值的解：\n$$ \\alpha^\\star = \\sqrt{\\frac{1}{\\sum_{i=1}^d (w_i \\nu_i)^2} \\left( \\frac{(w^\\top \\Delta\\mu)^2}{2 (\\Phi^{-1}(t))^2} - w^\\top \\Sigma w \\right)} $$\n此解析解在平方根下的项为非负时有效，这由条件 $\\text{AUC}(0) \\ge t$ 保证。它还要求 $\\sigma_{s,n}^2 > 0$；如果 $\\sigma_{s,n}^2 = 0$，则 AUC 是常数，阈值为 $\\alpha_{\\max}$，这已在初始检查中处理。这种直接计算是最精确的方法。\n\n实现将对每个测试案例遵循此逻辑。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the results.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"w\": np.array([0.5, 0.3, 0.2]),\n            \"delta_mu\": np.array([0.8, 0.4, 0.5]),\n            \"Sigma\": np.array([[1.0, 0.1, 0.2], [0.1, 0.8, 0.15], [0.2, 0.15, 1.2]]),\n            \"nu\": np.array([0.5, 0.3, 0.7]),\n            \"alpha_max\": 3.0,\n            \"t\": 0.75\n        },\n        {\n            \"w\": np.array([0.33, 0.33, 0.34]),\n            \"delta_mu\": np.array([0.2, 0.2, 0.2]),\n            \"Sigma\": np.array([[1.2, 0.4, 0.3], [0.4, 1.0, 0.2], [0.3, 0.2, 1.1]]),\n            \"nu\": np.array([0.6, 0.6, 0.6]),\n            \"alpha_max\": 2.0,\n            \"t\": 0.60\n        },\n        {\n            \"w\": np.array([0.1, 0.2, 0.7]),\n            \"delta_mu\": np.array([0.1, 0.1, 1.0]),\n            \"Sigma\": np.array([[0.9, 0.2, 0.25], [0.2, 0.7, 0.3], [0.25, 0.3, 1.5]]),\n            \"nu\": np.array([0.4, 0.4, 0.5]),\n            \"alpha_max\": 5.0,\n            \"t\": 0.85\n        },\n        {\n            \"w\": np.array([0.4, 0.3, 0.3]),\n            \"delta_mu\": np.array([0.0, 0.0, 0.0]),\n            \"Sigma\": np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"nu\": np.array([0.5, 0.5, 0.5]),\n            \"alpha_max\": 5.0,\n            \"t\": 0.55\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        threshold = compute_tolerance_threshold(\n            case[\"w\"], case[\"delta_mu\"], case[\"Sigma\"], case[\"nu\"], case[\"alpha_max\"], case[\"t\"]\n        )\n        results.append(threshold)\n\n    # Format the final output string as specified.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\ndef compute_tolerance_threshold(w, delta_mu, Sigma, nu, alpha_max, t):\n    \"\"\"\n    Computes the noise tolerance threshold for a given set of parameters.\n\n    Args:\n        w (np.ndarray): Weight vector.\n        delta_mu (np.ndarray): Class mean difference vector.\n        Sigma (np.ndarray): Base covariance matrix.\n        nu (np.ndarray): Noise amplitude vector.\n        alpha_max (float): Maximum noise level to consider.\n        t (float): Target ROC AUC level.\n\n    Returns:\n        float: The computed tolerance threshold alpha_star.\n    \"\"\"\n    \n    # Calculate terms from the derived formulas\n    delta_mu_s = w.T @ delta_mu\n    sigma_s0_sq = w.T @ Sigma @ w\n    sigma_sn_sq = np.sum((w * nu)**2)\n\n    # Handle case where model has no separation signal\n    if delta_mu_s  0: # Not a sane classifier\n        return 0.0\n    if np.isclose(delta_mu_s, 0.0): # AUC is always 0.5\n        return alpha_max if t = 0.5 else 0.0\n\n    # 1. Check the boundary condition at alpha = 0.\n    if sigma_s0_sq = 0:\n        return alpha_max # Infinite signal, always above threshold\n    \n    auc_0_arg = delta_mu_s / np.sqrt(2 * sigma_s0_sq)\n    auc_0 = norm.cdf(auc_0_arg)\n\n    if auc_0  t:\n        return 0.0\n\n    # 2. Handle the case where noise has no effect on the score.\n    if np.isclose(sigma_sn_sq, 0.0):\n        return alpha_max\n\n    # 3. Check the boundary condition at alpha = alpha_max.\n    variance_at_max = sigma_s0_sq + alpha_max**2 * sigma_sn_sq\n    auc_alphamax_arg = delta_mu_s / np.sqrt(2 * variance_at_max)\n    auc_alphamax = norm.cdf(auc_alphamax_arg)\n\n    if auc_alphamax >= t:\n        return alpha_max\n\n    # 4. Solve for the internal threshold alpha_star.\n    z_t = norm.ppf(t)\n\n    # Handle t=0.5 case, where z_t=0. AUC is always >= 0.5 for a sane model.\n    if np.isclose(z_t, 0.0):\n        return alpha_max\n    \n    # Use the derived analytical solution for alpha_star\n    alpha_sq_numerator = (delta_mu_s**2 / (2 * z_t**2)) - sigma_s0_sq\n    \n    if alpha_sq_numerator  0:\n        return 0.0 # Should not be reached due to auc_0 check, but for safety.\n        \n    alpha_sq = alpha_sq_numerator / sigma_sn_sq\n    alpha_star = np.sqrt(alpha_sq)\n\n    return alpha_star\n\nsolve()\n```", "id": "5062537"}]}