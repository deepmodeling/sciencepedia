{"hands_on_practices": [{"introduction": "CPOE 的一个核心功能是提供临床决策支持警报，但并非所有警报都有益。这个练习将探讨临床警报背后的统计学现实，利用灵敏度 $sensitivity$ 和特异性 $specificity$ 等概念来计算警报可能出错的频率。理解这一点是设计出能够赢得临床医生信任并被有效使用的系统的第一步。[@problem_id:4830580]", "problem": "一家大型学术医院使用计算机化医嘱录入系统 (CPOE)，在临床医生下达药物医嘱时生成实时的药物禁忌警报。考虑一个特定的警报规则，当存在真正的禁忌时该规则会触发。假设该警报的工作特性如下：灵敏度为 $0.9$，特异度为 $0.95$。在该规则适用的医嘱群体中，真实禁忌的发生率为 $0.02$。将“虚假警报率”定义为：在警报触发的情况下，实际上并不存在真实禁忌的概率。仅使用灵敏度、特异度、发生率和贝叶斯定理的定义，计算在此条件下该警报规则的虚假警报率。将结果表示为 $0$ 和 $1$ 之间的小数，并四舍五入至 $4$ 位有效数字。然后，基于用户如何响应频繁虚假警报的基本原理，简要解释该值的大小与 CPOE 中警报疲劳的关系。", "solution": "所述问题具有科学依据，提法恰当且客观。它展示了贝叶斯概率在评估临床决策支持系统性能方面的标准应用，这是医学信息学中的一项常见任务。所有必要的参数——灵敏度、特异度和发生率——均已提供，“虚假警报率”一词也得到了明确的定义。因此，该问题是有效的，我们可以着手求解。\n\n让我们定义以下事件：\n- $C$：对于给定的药物医嘱，存在真实禁忌的事件。\n- $\\neg C$：不存在真实禁忌的事件。\n- $A$：CPOE 系统对该医嘱发出警报的事件。\n- $\\neg A$：系统未发出警报的事件。\n\n根据问题陈述，我们可以提取以下概率：\n1.  真实禁忌的发生率为 $P(C) = 0.02$。这是禁忌的先验概率。\n2.  因此，不存在禁忌的概率为 $P(\\neg C) = 1 - P(C) = 1 - 0.02 = 0.98$。\n3.  警报的灵敏度是指在存在真实禁忌的情况下警报触发的概率。这是真阳性率：$P(A|C) = 0.9$。\n4.  警报的特异度是指在不存在真实禁忌的情况下警报不触发的概率。这是真阴性率：$P(\\neg A|\\neg C) = 0.95$。\n\n从特异度中，我们可以推导出假阳性率，即在没有真实禁忌的情况下警报触发的概率：\n$P(A|\\neg C) = 1 - P(\\neg A|\\neg C) = 1 - 0.95 = 0.05$。\n\n问题要求计算“虚假警报率”，其定义为“在警报触发的情况下，实际上并不存在真实禁忌的概率”。这对应于条件概率 $P(\\neg C|A)$。\n\n为计算此值，我们应用贝叶斯定理：\n$$P(\\neg C|A) = \\frac{P(A|\\neg C) P(\\neg C)}{P(A)}$$\n\n分母 $P(A)$ 是对于任何给定医嘱，警报触发的总概率。它可以使用全概率定律计算，该定律通过对禁忌状态进行边缘化来求得：\n$$P(A) = P(A|C)P(C) + P(A|\\neg C)P(\\neg C)$$\n\n让我们计算 $P(A)$ 表达式中的两项：\n- 真阳性警报（警报触发且存在禁忌）的概率为 $P(A \\cap C) = P(A|C)P(C) = (0.9) \\times (0.02) = 0.018$。\n- 假阳性警报（警报触发但不存在禁忌）的概率为 $P(A \\cap \\neg C) = P(A|\\neg C)P(\\neg C) = (0.05) \\times (0.98) = 0.049$。\n\n警报的总概率是这两个互斥事件的和：\n$$P(A) = 0.018 + 0.049 = 0.067$$\n\n现在我们可以将这些值代回到贝叶斯定理公式中，以计算虚假警报率 $P(\\neg C|A)$：\n$$P(\\neg C|A) = \\frac{P(A|\\neg C) P(\\neg C)}{P(A)} = \\frac{0.049}{0.067}$$\n\n进行除法运算得出：\n$$P(\\neg C|A) \\approx 0.73134328...$$\n\n按照要求，将结果四舍五入至 $4$ 位有效数字，得到 $0.7313$。\n\n**结果解读：**\n计算出的虚假警报率约为 $0.7313$。这表明，当临床医生从该 CPOE 系统收到警报时，该警报有 $73.13\\%$ 的可能性是虚假的，即实际上不存在真正的禁忌。在触发的警报中，这是一个非常高的假阳性率。\n\n从人机交互和心理学的基本原理来看，这种高虚假警报率是**警报疲劳**的主要原因。当用户（在此案例中为临床医生）频繁地接触到被证明是无关紧要或不正确的警告时，他们会变得麻木。评估每个警报的认知成本很高，如果大多数评估都得出警报可忽略的结论，用户将会通过形成一种启发式方法来适应，即以最少的调查来忽略警报。这种习得性行为是一个重大的患者安全风险，因为它增加了真实的、关键的警报与虚假警报的“噪音”一起被无意中忽略的可能性。在这个具体场景中，临床医生很可能会得出结论，即每四个警报中几乎有三个是虚假的，这将严重削弱他们对系统的信任，并助长了常规性忽略警报的危险做法。这种现象说明了优化警报系统的特异度和阳性预测值的关键重要性，尤其是在目标状况发生率较低的环境中。", "answer": "$$\\boxed{0.7313}$$", "id": "4830580"}, {"introduction": "在理解了有效警报的重要性之后，本练习将深入探讨一个自动临床决策支持的具体案例。你将模拟一个 CPOE 系统如何利用患者数据和标准临床公式来推荐安全的药物剂量，包括对数据时效性的检查。这个练习展示了 CPOE 如何将复杂的临床策略转化为对医疗服务提供者的自动化、实时指导。[@problem_id:4830618]", "problem": "一家医院已经实施了带有临床决策支持的计算机化医嘱录入系统（CPOE），用于氨基糖苷类药物的初始给药。该决策支持系统要求使用非过期的血清肌酐值，并使用Cockcroft–Gault方程估算的肌酐清除率来选择给药间隔。为安全起见，CPOE策略规定，如果血清肌酐测量值是在医嘱录入前$24$小时以上抽取的，则该值为过期值。只有非过期的数值才能用于评估初始给药时的肾功能。然后，CPOE在应用下面的间隔映射规则之前，会将估算的肌酐清除率四舍五入到两位有效数字。\n\nCPOE使用的间隔映射规则：\n- 如果四舍五入后的肌酐清除率 $\\ge 60\\,\\mathrm{mL/min}$，给药间隔为每$24$小时。\n- 如果 $40 \\le$ 四舍五入后的肌酐清除率 $ 60\\,\\mathrm{mL/min}$，给药间隔为每$36$小时。\n- 如果 $20 \\le$ 四舍五入后的肌酐清除率 $ 40\\,\\mathrm{mL/min}$，给药间隔为每$48$小时。\n- 如果四舍五入后的肌酐清除率 $ 20\\,\\mathrm{mL/min}$，给药间隔为每$72$小时。\n\n一名$68$岁的男性患者即将开始使用庆大霉素。他的身高为$1.75$ $\\mathrm{m}$，实际体重为$72$ $\\mathrm{kg}$；假设该患者的实际体重适用于Cockcroft–Gault方程。电子健康记录中有两个血清肌酐结果：\n- 血清肌酐$1.2$ $\\mathrm{mg/dL}$，于$50$小时前抽取。\n- 血清肌酐$1.6$ $\\mathrm{mg/dL}$，于$6$小时前抽取。\n\n在医嘱录入时，CPOE必须使用上述策略选择合适的间隔。\n\n仅根据所述CPOE策略使用非过期的实验室数据，计算该患者的Cockcroft–Gault估算肌酐清除率，将该估算值四舍五入到两位有效数字，然后应用间隔映射规则选择给药间隔。以小时为单位，用单个数值表示最终的给药间隔。如果任何中间量需要四舍五入，请将其四舍五入到两位有效数字。仅提供以小时为单位的最终给药间隔。最终答案必须是答案框中的一个不带单位的数字。", "solution": "将遵循计算机化医嘱录入（CPOE）系统策略规定的操作顺序来解决此问题。\n\n首先，我们必须验证问题陈述。\n问题提供了一个清晰、独立的场景，其基础是医学信息学和临床实践。所有必要的数据都已提供：\n- 患者年龄：$68$岁\n- 患者性别：男\n- 患者实际体重：$72$ $\\mathrm{kg}$\n- 血清肌酐 1：$1.2$ $\\mathrm{mg/dL}$，于$50$小时前抽取\n- 血清肌酐 2：$1.6$ $\\mathrm{mg/dL}$，于$6$小时前抽取\n- CPOE 过期数据策略：如果血清肌酐是在医嘱录入前$24$小时以上抽取的，则为过期数据。只能使用非过期的数值。\n- CPOE 四舍五入规则：估算的肌酐清除率四舍五入到两位有效数字。\n- 给药间隔映射规则：\n    - 如果四舍五入后的肌酐清除率 $\\ge 60\\,\\mathrm{mL/min}$，间隔为$24$小时。\n    - 如果 $40 \\le$ 四舍五入后的肌酐清除率 $ 60\\,\\mathrm{mL/min}$，间隔为$36$小时。\n    - 如果 $20 \\le$ 四舍五入后的肌酐清除率 $ 40\\,\\mathrm{mL/min}$，间隔为$48$小时。\n    - 如果四舍五入后的肌酐清除率 $ 20\\,\\mathrm{mL/min}$，间隔为$72$小时。\n问题使用了Cockcroft–Gault方程，这是一种标准的临床估算工具。该场景在科学上是合理的，问题表述清晰，有明确的路径可获得唯一解。语言客观而精确。因此，该问题被认为是有效的，并将推导出解决方案。\n\n第一步是根据CPOE策略选择合适的血清肌酐值。\n该策略规定，如果血清肌酐测量值是在$24$小时前抽取的，则该值为过期值。\n- 第一个结果，$1.2$ $\\mathrm{mg/dL}$，是在$50$小时前抽取的。由于$50 \\text{ hours} > 24 \\text{ hours}$，该值为过期值，必须丢弃。\n- 第二个结果，$1.6$ $\\mathrm{mg/dL}$，是在$6$小时前抽取的。由于$6 \\text{ hours} \\leq 24 \\text{ hours}$，该值为非过期值，将被CPOE系统使用。\n因此，要使用的血清肌酐水平为 $\\text{SCr} = 1.6$ $\\mathrm{mg/dL}$。\n\n第二步是使用Cockcroft–Gault方程计算估算的肌酐清除率（$CrCl_{est}$）。对于男性患者，方程为：\n$$CrCl_{est} = \\frac{(140 - \\text{Age}) \\times \\text{Mass}}{72 \\times \\text{SCr}}$$\n其中年龄（Age）以年为单位，体重（Mass）以$\\mathrm{kg}$为单位，血清肌酐（SCr）以$\\mathrm{mg/dL}$为单位。\n\n问题提供了以下数值：\n- 年龄 = $68$\n- 体重 = $72$\n- SCr = $1.6$\n\n将这些值代入方程：\n$$CrCl_{est} = \\frac{(140 - 68) \\times 72}{72 \\times 1.6}$$\n\n现在，我们进行计算：\n$$CrCl_{est} = \\frac{72 \\times 72}{72 \\times 1.6}$$\n分子和分母中的$72$可以消掉：\n$$CrCl_{est} = \\frac{72}{1.6}$$\n$$CrCl_{est} = 45$$\n估算的肌酐清除率为$45$ $\\mathrm{mL/min}$。\n\n第三步是应用CPOE的四舍五入规则。该规则要求将估算的肌酐清除率四舍五入到两位有效数字。计算出的值$45$已经恰好有两位有效数字。因此，四舍五入后的肌酐清除率为$45$ $\\mathrm{mL/min}$。\n\n最后一步是使用这个四舍五入后的肌酐清除率值，根据CPOE的间隔映射规则来确定给药间隔。\n四舍五入后的肌酐清除率为$45$ $\\mathrm{mL/min}$。我们根据规则的条件检查该值：\n- $45 \\ge 60$ 吗？否。\n- $40 \\le 45  60$ 吗？是。此条件满足。\n- 相应的给药间隔是$36$小时。\n\nCPOE系统将选择$36$小时的给药间隔。", "answer": "$$\\boxed{36}$$", "id": "4830618"}, {"introduction": "本练习将超越简单的规则应用，挑战你从头开始设计一个更复杂的 CPOE 模块。你将开发一种算法来检测重复的化验医嘱，这是一个导致资源浪费和患者风险的常见问题。这包括定义临床等效性、为潜在的重复项评分，并使用统计方法来寻找在捕获真实重复项和避免错误警报之间的最佳平衡点。[@problem_id:4830556]", "problem": "在计算机化医嘱录入 (Computerized Provider Order Entry, CPOE) 中，重复的检验医嘱会浪费资源，并可能使患者接受不必要的操作。逻辑观察标识符名称和代码 (Logical Observation Identifiers Names and Codes, LOINC) 为实验室检验提供了标准化的标识符；然而，临床上等效的检验可能具有不同的 LOINC 代码。您的任务是，使用临床等效的 LOINC 代码和重叠的时间窗口，来形式化检验医嘱的重复医嘱检测，并从基本原则出发设计一个平衡灵敏度和特异度的匹配算法。\n\n假设以下基本前提：\n- 一个检验医嘱表示为一个元组 $(c, s, e)$，其中 $c$ 是一个 LOINC 代码字符串，$s$ 是开始时间（以分钟为单位），$e$ 是结束时间（以分钟为单位），且 $e \\ge s$。\n- 如果两个 LOINC 代码位于一个无向等价图的同一连通分量中，则它们在临床上是等效的。该图的顶点是代码，边表示临床等价性。根据图的连通性，等价关系是可传递的。\n- 两个时间窗口 $[s_i, e_i]$ 和 $[s_j, e_j]$ 之间的重叠由交集长度定义\n$$I(i,j) = \\max\\!\\big(0, \\min(e_i, e_j) - \\max(s_i, s_j)\\big),$$\n以及重叠系数\n$$\\omega(i,j) = \\begin{cases}\n\\frac{I(i,j)}{\\min(e_i - s_i, e_j - s_j)},  \\min(e_i - s_i, e_j - s_j) > 0,\\\\\n0,  \\text{otherwise.}\n\\end{cases}$$\n- 设 $w(i,j)$ 是一个代码等价权重，定义为：如果 $c_i = c_j$，则 $w(i,j) = 1$；如果 $c_i \\ne c_j$ 但 $c_i$ 和 $c_j$ 通过图在临床上等效，则 $w(i,j) = \\lambda$；这里 $\\lambda \\in (0,1)$ 是测试用例给定的一个参数。\n- 对于具有临床等效代码的候选对 $(i,j)$，其重复分数定义为\n$$\\sigma(i,j) = w(i,j)\\cdot \\omega(i,j)。$$\n- 使用阈值 $\\theta \\in [0,1]$ 的决策规则，如果 $\\sigma(i,j) \\ge \\theta$，则将一对声明为预测的重复项。\n- 对于候选对中一组给定的真实重复对（ground-truth），以常规方式定义真阳性（$TP$）、假阳性（$FP$）、真阴性（$TN$）和假阴性（$FN$），这些定义仅限于候选对的范畴（即其代码根据给定图是临床等效的配对）。\n- 灵敏度和特异度定义为\n$$\\mathrm{Se} = \\frac{TP}{TP + FN}, \\quad \\mathrm{Sp} = \\frac{TN}{TN + FP}。$$\n- 为平衡灵敏度和特异度，在一系列阈值 $\\theta \\in \\{0.00, 0.01, \\dots, 1.00\\}$ 上评估决策规则，并选择能最大化约登指数 $J$（Youden’s $J$ statistic）的 $\\theta^\\star$\n$$J(\\theta) = \\mathrm{Se}(\\theta) + \\mathrm{Sp}(\\theta) - 1,$$\n若存在多个 $\\theta$ 得到相同的最大 $J$ 值，则选择其中最小的 $\\theta$ 作为决胜条件。\n\n您的任务：\n- 实现一个算法，该算法接收医嘱、临床等价图、参数 $\\lambda$ 和真实重复对作为输入，通过在指定网格上最大化 $J(\\theta)$ 来计算 $\\theta^\\star$，并返回相应的 $\\mathrm{Se}(\\theta^\\star)$ 和 $\\mathrm{Sp}(\\theta^\\star)$。\n- 时间值以分钟为单位；所有计算都必须使用这些单位执行。\n- 最终输出结果表示为四舍五入到 $3$ 位小数的数值。\n\n测试套件：\n- 测试用例 $1$ (正常路径):\n  - 医嘱 (时间以分钟为单位): \n    - $(\\text{12345-6}, 0, 60)$, $(\\text{12345-6}, 30, 90)$, $(\\text{78901-2}, 200, 260)$, $(\\text{78901-3}, 210, 240)$, $(\\text{11111-1}, 300, 330)$, $(\\text{11111-1}, 330, 360)$, $(\\text{22222-2}, 400, 480)$, $(\\text{22222-2}, 450, 480)$, $(\\text{33333-3}, 500, 520)$, $(\\text{33333-4}, 521, 540)$.\n  - 等价边: $(\\text{78901-2}, \\text{78901-3})$, $(\\text{33333-3}, \\text{33333-4})$.\n  - $\\lambda = 0.8$.\n  - 真实重复对 (按从1开始的医嘱位置索引): $(1,2)$, $(3,4)$, $(7,8)$.\n- 测试用例 $2$ (边界重叠):\n  - 医嘱: \n    - $(\\text{55555-5}, 0, 60)$, $(\\text{55555-5}, 60, 120)$, $(\\text{66666-6}, 10, 40)$, $(\\text{66666-6}, 20, 50)$, $(\\text{77777-7}, 100, 130)$, $(\\text{77777-8}, 110, 125)$, $(\\text{88888-1}, 200, 260)$, $(\\text{88888-2}, 259, 300)$.\n  - 等价边: $(\\text{77777-7}, \\text{77777-8})$, $(\\text{88888-1}, \\text{88888-2})$.\n  - $\\lambda = 0.5$.\n  - 真实重复对: $(3,4)$, $(5,6)$.\n- 测试用例 $3$ (传递性代码等价):\n  - 医嘱:\n    - $(\\text{90101-1}, 0, 100)$, $(\\text{90101-2}, 10, 90)$, $(\\text{90101-3}, 5, 95)$, $(\\text{90101-4}, 200, 240)$, $(\\text{90101-1}, 300, 330)$.\n  - 等价边: $(\\text{90101-1}, \\text{90101-2})$, $(\\text{90101-2}, \\text{90101-3})$.\n  - $\\lambda = 0.6$.\n  - 真实重复对: $(1,2)$, $(1,3)$, $(2,3)$.\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个由三元素列表组成的逗号分隔列表，每个列表按顺序对应一个测试用例。每个内部列表的形式必须为 $[\\theta^\\star, \\mathrm{Se}(\\theta^\\star), \\mathrm{Sp}(\\theta^\\star)]$，其中每个值都四舍五入到 $3$ 位小数。例如，输出行应类似于 `[[0.123,0.987,0.654],[\\dots],[\\dots]]`。", "solution": "该问题是有效的。它在医学信息学领域有科学依据，特别是在检验医嘱管理中使用了标准化的 LOINC 代码。问题陈述清晰，提供了一套完整且一致的定义、数据和约束。目标明确：实现一个特定的重复医嘱检测算法，使用标准统计量（约登指数 J）优化决策阈值，并报告性能指标。所有术语都经过了正式定义，输入足以产生唯一、可验证的解决方案。\n\n解决此问题的算法方法包括四个主要阶段：\n\n1.  **临床等价类识别**：\n    临床等价的概念被定义为属于一个无向图的同一连通分量。第一步是处理所提供的等价边来构建这个图。图的顶点是唯一的 LOINC 代码，边代表直接等价。由于等价是可传递的，我们必须识别该图的连通分量。每个连通分量形成一个等价类。可以使用图遍历算法（如广度优先搜索 (BFS) 或深度优先搜索 (DFS)）或使用不相交集并 (DSU) 数据结构，高效地构建一个将每个 LOINC 代码映射到唯一分量标识符的字典。\n\n2.  **候选对生成与评分**：\n    分析仅限于“候选对”，即其 LOINC 代码 $c_i$ 和 $c_j$ 临床等效（即属于同一连通分量）的医嘱对 $(i,j)$。我们遍历所有满足 $i  j$ 的唯一医嘱对 $(i,j)$。对于每一对，我们使用上一步得到的分量映射来检查它们的编码是否等效。\n    如果等效，我们计算重复分数 $\\sigma(i,j)$。该计算过程如下：\n    a.  **重叠系数 $\\omega(i,j)$**：时间区间为 $[s_i, e_i]$ 和 $[s_j, e_j]$。交集长度计算为 $I(i,j) = \\max(0, \\min(e_i, e_j) - \\max(s_i, s_j))$。持续时间为 $d_i = e_i - s_i$ 和 $d_j = e_j - s_j$。如果 $\\min(d_i, d_j) > 0$，则重叠系数为 $\\omega(i,j) = I(i,j) / \\min(d_i, d_j)$，否则为 0。\n    b.  **代码等价权重 $w(i,j)$**：如果代码相同（$c_i = c_j$），该权重为 $1$；如果代码不同但临床等效（$c_i \\ne c_j$），则为 $\\lambda$。\n    c.  **重复分数 $\\sigma(i,j)$**：最终分数为乘积 $\\sigma(i,j) = w(i,j) \\cdot \\omega(i,j)$。\n    对于每个候选对，我们存储其计算出的分数及其真实状态（如果已知为重复，则为 True，否则为 False）。\n\n3.  **最优阈值搜索**：\n    通过在一个离散的阈值网格 $\\theta \\in \\{0.00, 0.01, \\dots, 1.00\\}$ 上最大化约登指数 J，来找到最优决策阈值 $\\theta^\\star$。对于此网格中的每个 $\\theta$：\n    a.  **分类**：如果分数 $\\sigma(i,j) \\ge \\theta$，则每个候选对 $(i,j)$ 被分类为“预测重复”，否则分类为“预测非重复”。\n    b.  **性能指标**：通过将这些预测与所有候选对的真实情况进行比较，我们统计真阳性（$TP$）、假阳性（$FP$）、真阴性（$TN$）和假阴性（$FN$）的数量。\n    c.  在候选集内，实际阳性总数（$P = TP + FN$）和实际阴性总数（$N = TN + FP$）对于给定的测试用例是恒定的。灵敏度为 $\\mathrm{Se}(\\theta) = TP/P$（如果 $P>0$，否则为 $1$），特异度为 $\\mathrm{Sp}(\\theta) = TN/N$（如果 $N>0$，否则为 $1$）。\n    d.  **约登指数 J**：我们计算 $J(\\theta) = \\mathrm{Se}(\\theta) + \\mathrm{Sp}(\\theta) - 1$。\n\n4.  **结果选择与报告**：\n    在计算了网格中所有阈值的 $J(\\theta)$ 后，我们确定最大值 $J_{max}$。根据决胜规则，我们从网格中选择产生 $J(\\theta^\\star) = J_{max}$ 的最小阈值 $\\theta^\\star$。测试用例的最终结果是三元组 $[\\theta^\\star, \\mathrm{Se}(\\theta^\\star), \\mathrm{Sp}(\\theta^\\star)]$，每个值都四舍五入到小数点后三位。对测试套件中提供的每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"orders\": [\n                (\"12345-6\", 0, 60), (\"12345-6\", 30, 90), (\"78901-2\", 200, 260),\n                (\"78901-3\", 210, 240), (\"11111-1\", 300, 330), (\"11111-1\", 330, 360),\n                (\"22222-2\", 400, 480), (\"22222-2\", 450, 480), (\"33333-3\", 500, 520),\n                (\"33333-4\", 521, 540)\n            ],\n            \"equiv_edges\": [(\"78901-2\", \"78901-3\"), (\"33333-3\", \"33333-4\")],\n            \"lambda_val\": 0.8,\n            \"gt_duplicates\": {(1, 2), (3, 4), (7, 8)}\n        },\n        {\n            \"orders\": [\n                (\"55555-5\", 0, 60), (\"55555-5\", 60, 120), (\"66666-6\", 10, 40),\n                (\"66666-6\", 20, 50), (\"77777-7\", 100, 130), (\"77777-8\", 110, 125),\n                (\"88888-1\", 200, 260), (\"88888-2\", 259, 300)\n            ],\n            \"equiv_edges\": [(\"77777-7\", \"77777-8\"), (\"88888-1\", \"88888-2\")],\n            \"lambda_val\": 0.5,\n            \"gt_duplicates\": {(3, 4), (5, 6)}\n        },\n        {\n            \"orders\": [\n                (\"90101-1\", 0, 100), (\"90101-2\", 10, 90), (\"90101-3\", 5, 95),\n                (\"90101-4\", 200, 240), (\"90101-1\", 300, 330)\n            ],\n            \"equiv_edges\": [(\"90101-1\", \"90101-2\"), (\"90101-2\", \"90101-3\")],\n            \"lambda_val\": 0.6,\n            \"gt_duplicates\": {(1, 2), (1, 3), (2, 3)}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = find_optimal_params(\n            case[\"orders\"],\n            case[\"equiv_edges\"],\n            case[\"lambda_val\"],\n            case[\"gt_duplicates\"]\n        )\n        all_results.append(result)\n    \n    # Format the final output string\n    formatted_results = [\n        f\"[{res[0]:.3f},{res[1]:.3f},{res[2]:.3f}]\" for res in all_results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef find_optimal_params(orders, equiv_edges, lambda_val, gt_duplicates_1based):\n    \"\"\"\n    Solves for one test case: finds optimal theta and corresponding Se, Sp.\n    \"\"\"\n    # 1. Build equivalence graph and find connected components\n    adj = defaultdict(list)\n    all_codes = {o[0] for o in orders}\n    for u, v in equiv_edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        all_codes.add(u)\n        all_codes.add(v)\n\n    visited = set()\n    component_map = {}\n    component_id = 0\n    for code in all_codes:\n        if code not in visited:\n            q = [code]\n            visited.add(code)\n            component_map[code] = component_id\n            head = 0\n            while head  len(q):\n                curr = q[head]\n                head += 1\n                for neighbor in adj[curr]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        component_map[neighbor] = component_id\n                        q.append(neighbor)\n            component_id += 1\n\n    # Convert 1-based ground truth pairs to 0-based, sorted tuples\n    gt_duplicates_0based = {tuple(sorted((i - 1, j - 1))) for i, j in gt_duplicates_1based}\n\n    # 2. Generate candidate pairs and calculate scores\n    candidate_pairs = []\n    num_orders = len(orders)\n    for i in range(num_orders):\n        for j in range(i + 1, num_orders):\n            c_i, s_i, e_i = orders[i]\n            c_j, s_j, e_j = orders[j]\n\n            # Check if codes are clinically equivalent\n            if component_map.get(c_i) != component_map.get(c_j):\n                continue\n\n            # Calculate overlap coefficient omega(i, j)\n            intersection = max(0, min(e_i, e_j) - max(s_i, s_j))\n            duration_i = e_i - s_i\n            duration_j = e_j - s_j\n            min_duration = min(duration_i, duration_j)\n            \n            omega = 0\n            if min_duration > 0:\n                omega = intersection / min_duration\n\n            # Determine code-equivalence weight w(i, j)\n            w = 1.0 if c_i == c_j else lambda_val\n\n            # Calculate score sigma(i, j)\n            score = w * omega\n            \n            is_gt_duplicate = (i, j) in gt_duplicates_0based\n            candidate_pairs.append({'score': score, 'gt': is_gt_duplicate})\n\n    # 3. Find optimal threshold theta*\n    thresholds = np.linspace(0.0, 1.0, 101)\n    best_j = -2.0  # J is in [-1, 1], so -2 is a safe initial value\n    best_theta = -1.0\n    best_se = -1.0\n    best_sp = -1.0\n\n    # Total positives (P) and negatives (N) among candidate pairs\n    P = sum(1 for p in candidate_pairs if p['gt'])\n    N = len(candidate_pairs) - P\n\n    for theta in thresholds:\n        TP, FP, FN, TN = 0, 0, 0, 0\n        for pair in candidate_pairs:\n            is_predicted_positive = pair['score'] >= theta\n            if is_predicted_positive:\n                if pair['gt']:\n                    TP += 1\n                else:\n                    FP += 1\n            else:\n                if pair['gt']:\n                    FN += 1\n                else:\n                    TN += 1\n        \n        Se = TP / P if P > 0 else 1.0\n        Sp = TN / N if N > 0 else 1.0\n        J = Se + Sp - 1\n\n        if J > best_j:\n            best_j = J\n            best_theta = theta\n            best_se = Se\n            best_sp = Sp\n        # Tie-breaker: smallest theta for the same max J is implicitly handled\n        # by iterating theta in increasing order and only updating on J > best_j.\n\n    return [best_theta, best_se, best_sp]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "4830556"}]}