{"hands_on_practices": [{"introduction": "在真实的医疗环境中，患者的数据访问偏好可能被记录在多个、有时相互冲突的同意策略中。这个动手实践将指导你实现一个决策引擎，它使用基础的访问控制原则来解决这些冲突。通过应用受 FHIR 标准启发的规则特异性和“拒绝优先”等概念，你将学习构建一个逻辑系统，以确保患者数据得到安全、可预测的处理 [@problem_id:4830907]。", "problem": "您将获得一个用于决定是否应允许数据访问请求的简化和形式化的模型，该模型基于快速医疗保健互操作性资源 (Fast Healthcare Interoperability Resources, FHIR) 的同意条款 (Consent provisions)。每个条款（下文称为“策略”）是一条规则，其效果为“允许” (permit) 或“拒绝” (deny)，并带有一组属性约束，这些约束可以是具体值或通配符。一个请求携带了属性值。您的任务是基于应用于此模型的基本访问控制原则，为每个请求计算有效的决策。\n\n基本原则与核心定义：\n- 最小权限原则 (Principle of least privilege)：在没有明确允许的情况下，不授予访问权限。换言之，默认决策是拒绝。\n- 拒绝优先合并 (Deny-overrides combining)：当同等权威的规则发生冲突时，为避免意外泄露，拒绝优先于允许。\n- 规则特异性 (Rule specificity)：更具体的规则（具有更具体的约束）应优先于不太具体的规则。特异性将在下文进行度量。\n\n模型：\n- 属性包括：使用目的 (purpose of use)、资源类型 (resource type)、行动者角色 (actor role) 和时间 (time)。将属性集表示为 $\\mathcal{A} = \\{\\text{purpose}, \\text{resource}, \\text{actor}, \\text{time}\\}$。\n- 一个策略 $p$ 具有：\n  - 一个效果 $e(p) \\in \\{\\text{permit}, \\text{deny}\\}$。\n  - 约束 $c_{\\text{purpose}}(p)$、$c_{\\text{resource}}(p)$、$c_{\\text{actor}}(p)$ 以及一个时间窗口 $[c_{\\text{start}}(p), c_{\\text{end}}(p)]$。\n  - 一个用于解决新近度平局的更新时间戳 $u(p)$。\n- 对于非时间属性，约束是一个具体值（例如，“research”）或一个通配符“*”。对于时间，约束是一个自 Unix 纪元以来的秒数表示的闭区间 $[c_{\\text{start}}(p), c_{\\text{end}}(p)]$，其中特殊的无约束情况由两个端点均未定义来表示（概念上视为 $-\\infty$ 和 $+\\infty$）。输入中的所有实际时间都以秒（$s$）为单位给出。\n- 一个请求 $r$ 具有使用目的、资源、行动者的具体值以及一个以秒（$s$）为单位的时间 $t(r)$。\n\n匹配：\n- 定义一个匹配谓词 $M(p, r)$，它当且仅当以下条件成立时为真：\n  - 对于每个非时间属性 $a \\in \\{\\text{purpose}, \\text{resource}, \\text{actor}\\}$，要么 $c_{a}(p) = *$，要么 $c_{a}(p)$ 等于请求中 $a$ 的值。\n  - 对于时间，如果一个策略的时间是无约束的，它将匹配任何 $t(r)$。否则，$t(r)$ 必须满足 $c_{\\text{start}}(p) \\le t(r) \\le c_{\\text{end}}(p)$，所有边界都以秒（$s$）为单位。\n\n特异性：\n- 对于一个匹配的策略 $p$，定义其相对于 $r$ 的特异性分数为：\n  $$s(p, r) = \\mathbf{1}[c_{\\text{purpose}}(p) \\ne *] + \\mathbf{1}[c_{\\text{resource}}(p) \\ne *] + \\mathbf{1}[c_{\\text{actor}}(p) \\ne *] + \\mathbf{1}[\\text{time is constrained in } p],$$\n  其中 $\\mathbf{1}[\\cdot]$ 是指示函数，当谓词为真时等于 $1$，否则等于 $0$。如果 $c_{\\text{start}}(p)$ 或 $c_{\\text{end}}(p)$ 中至少有一个被定义，则时间被认为是受约束的。\n\n需要实现的决策过程：\n- 给定一个有限的策略集 $\\mathcal{P}$ 和一个请求 $r$：\n  1. 计算匹配策略集 $\\mathcal{P}_m = \\{p \\in \\mathcal{P} \\mid M(p, r)\\}$。\n  2. 如果 $\\mathcal{P}_m$ 为空，则返回拒绝。\n  3. 计算 $s_{\\max} = \\max_{p \\in \\mathcal{P}_m} s(p, r)$ 并将范围限制在最大特异性集合 $\\mathcal{T} = \\{p \\in \\mathcal{P}_m \\mid s(p, r) = s_{\\max}\\}$。\n  4. 如果 $\\mathcal{T}$ 同时包含允许和拒绝，则返回拒绝（在同等特异性下拒绝优先）。\n  5. 否则，$\\mathcal{T}$ 中的所有效果都相同；返回该效果。如果需要，为了在具有相同效果和特异性的多个策略之间确定性地打破平局，您可以选择具有最大更新时间戳 $u(p)$ 的策略，但请注意这不会改变效果。\n\n测试套件：\n对于每个测试用例，您都会得到一个策略集和一个请求。时间和时间戳是以秒（$s$）为单位的整数。通配符用字符串“*”表示。效果为“permit”或“deny”。您的程序必须评估每个测试用例并输出一个布尔值列表，其中 True 对应于允许，False 对应于拒绝。\n\n- 测试用例 1（更具体的允许策略胜过不太具体的拒绝策略）：\n  - 策略：\n    - $p_1$：效果 permit；目的 \"research\"；资源 \"lab\"；行动者 \"*\"；时间无约束；更新于 $1700000000$。\n    - $p_2$：效果 deny；目的 \"*\"；资源 \"lab\"；行动者 \"*\"；时间无约束；更新于 $1600000000$。\n  - 请求：\n    - 目的 \"research\"；资源 \"lab\"；行动者 \"clinician\"；时间 $1705000000$。\n  - 预期决策：True。\n\n- 测试用例 2（同等特异性下拒绝优先）：\n  - 策略：\n    - $p_1$：效果 permit；目的 \"research\"；资源 \"lab\"；行动者 \"*\"；时间无约束；更新于 $1700000000$。\n    - $p_2$：效果 deny；目的 \"research\"；资源 \"lab\"；行动者 \"*\"；时间无约束；更新于 $1699000000$。\n  - 请求：\n    - 目的 \"research\"；资源 \"lab\"；行动者 \"nurse\"；时间 $1701000000$。\n  - 预期决策：False。\n\n- 测试用例 3（无策略匹配时默认拒绝）：\n  - 策略：\n    - $p_1$：效果 permit；目的 \"treatment\"；资源 \"imaging\"；行动者 \"*\"；时间无约束；更新于 $1700000000$。\n  - 请求：\n    - 目的 \"research\"；资源 \"lab\"；行动者 \"clinician\"；时间 $1700000100$。\n  - 预期决策：False。\n\n- 测试用例 4（效果和特异性相同导致平局，新近度不改变效果）：\n  - 策略：\n    - $p_1$：效果 permit；目的 \"research\"；资源 \"lab\"；行动者 \"clinician\"；时间无约束；更新于 $1600000000$。\n    - $p_2$：效果 permit；目的 \"research\"；资源 \"lab\"；行动者 \"clinician\"；时间无约束；更新于 $1800000000$。\n  - 请求：\n    - 目的 \"research\"；资源 \"lab\"；行动者 \"clinician\"；时间 $1790000000$。\n  - 预期决策：True。\n\n- 测试用例 5（时间约束增加特异性并决定结果）：\n  - 策略：\n    - $p_1$：效果 permit；目的 \"research\"；资源 \"lab\"；行动者 \"*\"；时间窗口 $[1700000000, 1710000000]$；更新于 $1700000000$。\n    - $p_2$：效果 deny；目的 \"research\"；资源 \"lab\"；行动者 \"*\"；时间无约束；更新于 $1600000000$。\n  - 请求：\n    - 目的 \"research\"；资源 \"lab\"；行动者 \"clinician\"；时间 $1708000000$。\n  - 预期决策：True。\n\n- 测试用例 6（时间在窗口之外排除了更具体的允许策略）：\n  - 策略：\n    - $p_1$：效果 permit；目的 \"research\"；资源 \"lab\"；行动者 \"*\"；时间窗口 $[1700000000, 1710000000]$；更新于 $1700000000$。\n    - $p_2$：效果 deny；目的 \"research\"；资源 \"lab\"；行动者 \"*\"；时间无约束；更新于 $1600000000$。\n  - 请求：\n    - 目的 \"research\"；资源 \"lab\"；行动者 \"clinician\"；时间 $1720000000$。\n  - 预期决策：False。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[True,False,True,False,True,False]”）。必须按测试用例 1 到 6 的顺序，恰好有 $6$ 个布尔值。", "solution": "该问题要求为一个形式化的访问控制模型实现一个决策算法，该模型基于医学信息学原理，特别是快速医疗保健互操作性资源 (FHIR) 的同意条款。解决方案涉及应用一系列规则，以根据一组给定的策略来确定一个数据访问请求应被允许还是拒绝。\n\n指导决策逻辑的核心原则是**最小权限原则**（默认拒绝）、用于冲突解决的**拒绝优先**原则，以及**特异性原则**（更具体的规则优先于更通用的规则）。问题提供了一个严谨的、分步骤的程序来实现此逻辑。\n\n让我们对组件进行形式化。所有策略集合 $\\mathcal{P}$ 中的一个策略 $p$ 由其效果 $e(p)$、对属性集 $\\mathcal{A} = \\{\\text{purpose}, \\text{resource}, \\text{actor}, \\text{time}\\}$ 中属性的约束以及其更新时间戳 $u(p)$ 来定义。一个请求 $r$ 由这些相同属性的一组具体值来定义。\n\n决策过程如下：\n\n**第 1 步：识别匹配的策略**\n\n首先，对于一个给定的请求 $r$，我们必须识别适用于它的策略子集 $\\mathcal{P}_m \\subseteq \\mathcal{P}$。如果一个策略 $p$ 的所有约束都被请求的属性所满足，则该策略被视为匹配。匹配谓词 $M(p, r)$ 当且仅当以下条件成立时为真：\n- 对于每个非时间属性 $a \\in \\{\\text{purpose}, \\text{resource}, \\text{actor}\\}$，策略的约束 $c_a(p)$ 要么是通配符（`*`），要么与请求的属性值 $v_a(r)$ 完全相同。\n- 对于时间属性，请求的时间 $t(r)$ 必须落在策略定义的时间区间 $[c_{\\text{start}}(p), c_{\\text{end}}(p)]$ 内。策略中无约束的时间区间，概念上表示为 $[-\\infty, +\\infty]$，可以匹配任何请求时间。\n\n如果匹配策略集 $\\mathcal{P}_m = \\{p \\in \\mathcal{P} \\mid M(p, r)\\}$ 为空，最小权限原则规定访问被拒绝。\n\n**第 2 步：计算特异性**\n\n接下来，我们评估每个匹配策略的特异性。特异性原则确保更有针对性的规则会覆盖更宽泛的规则。对于一个匹配的策略 $p$，其特异性分数 $s(p, r)$ 被定义为其非通配符约束的数量。公式如下：\n$$s(p, r) = \\mathbf{1}[c_{\\text{purpose}}(p) \\ne *] + \\mathbf{1}[c_{\\text{resource}}(p) \\ne *] + \\mathbf{1}[c_{\\text{actor}}(p) \\ne *] + \\mathbf{1}[\\text{time is constrained in } p]$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数。如果策略的时间窗口不是 $[-\\infty, +\\infty]$，则时间约束被计数。该分数范围可以从 $0$（所有都是通配符）到 $4$（所有约束都是具体的）。\n\n**第 3 步：分离出最大特异性的策略**\n\n我们在所有匹配策略中找到最大特异性分数 $s_{\\max}$：\n$$s_{\\max} = \\max_{p \\in \\mathcal{P}_m} s(p, r)$$\n然后我们构建一个新集合 $\\mathcal{T}$，其中仅包含 $\\mathcal{P}_m$ 中达到此最大特异性的那些策略：\n$$\\mathcal{T} = \\{p \\in \\mathcal{P}_m \\mid s(p, r) = s_{\\max}\\}$$\n这一步有效地将适用的规则筛选为仅剩下最相关的规则。\n\n**第 4 步：应用冲突解决并最终确定决策**\n\n最终决策源自最大特异性集合 $\\mathcal{T}$ 中策略的效果。\n- 如果 $\\mathcal{T}$ 包含具有冲突效果的策略（即，至少一个 `permit` 和至少一个 `deny`），则应用拒绝优先原则。为防止意外的数据泄露，结果为 `deny`。\n- 如果 $\\mathcal{T}$ 中的所有策略都具有相同的效果，那么该效果就成为最终决策。例如，如果 $\\mathcal{T}$ 中的所有策略都是 `permit`，则请求被批准。\n\n问题还提到了用于打破平局的更新时间戳 $u(p)$。然而，它正确地指出，对于此决策逻辑，这个平局决胜规则不会改变最终效果，因为最终候选集 $\\mathcal{T}$ 中的所有策略要么具有相同的效果，要么无论哪个策略更新，都会触发 `deny-overrides` 规则。\n\n通过系统地将这四个步骤应用于每个测试用例，我们可以确定正确的布尔结果（`True` 表示允许，`False` 表示拒绝）。例如，在测试用例 1 中，一个特异性为 $2$ 的 `permit` 策略覆盖了一个特异性为 $1$ 的 `deny` 策略。在测试用例 2 中，一个 `permit` 和一个 `deny` 策略都具有最大特异性 $2$，因此 `deny-overrides` 规则导致结果为 `deny`。在测试用例 3 中，没有策略与请求匹配，导致默认的 `deny`。这种结构化评估确保了所有原则都得到正确和一致的应用。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the FHIR consent policy evaluation problem for the given test suite.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each policy is a dict. Unconstrained time is represented by start/end keys being None.\n    # Each request is a dict.\n    test_cases = [\n        # Test case 1\n        (\n            [\n                {\"effect\": \"permit\", \"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"*\", \"time_start\": None, \"time_end\": None, \"updated\": 1700000000},\n                {\"effect\": \"deny\", \"purpose\": \"*\", \"resource\": \"lab\", \"actor\": \"*\", \"time_start\": None, \"time_end\": None, \"updated\": 1600000000},\n            ],\n            {\"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"clinician\", \"time\": 1705000000},\n        ),\n        # Test case 2\n        (\n            [\n                {\"effect\": \"permit\", \"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"*\", \"time_start\": None, \"time_end\": None, \"updated\": 1700000000},\n                {\"effect\": \"deny\", \"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"*\", \"time_start\": None, \"time_end\": None, \"updated\": 1699000000},\n            ],\n            {\"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"nurse\", \"time\": 1701000000},\n        ),\n        # Test case 3\n        (\n            [\n                {\"effect\": \"permit\", \"purpose\": \"treatment\", \"resource\": \"imaging\", \"actor\": \"*\", \"time_start\": None, \"time_end\": None, \"updated\": 1700000000},\n            ],\n            {\"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"clinician\", \"time\": 1700000100},\n        ),\n        # Test case 4\n        (\n            [\n                {\"effect\": \"permit\", \"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"clinician\", \"time_start\": None, \"time_end\": None, \"updated\": 1600000000},\n                {\"effect\": \"permit\", \"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"clinician\", \"time_start\": None, \"time_end\": None, \"updated\": 1800000000},\n            ],\n            {\"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"clinician\", \"time\": 1790000000},\n        ),\n        # Test case 5\n        (\n            [\n                {\"effect\": \"permit\", \"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"*\", \"time_start\": 1700000000, \"time_end\": 1710000000, \"updated\": 1700000000},\n                {\"effect\": \"deny\", \"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"*\", \"time_start\": None, \"time_end\": None, \"updated\": 1600000000},\n            ],\n            {\"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"clinician\", \"time\": 1708000000},\n        ),\n        # Test case 6\n        (\n            [\n                {\"effect\": \"permit\", \"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"*\", \"time_start\": 1700000000, \"time_end\": 1710000000, \"updated\": 1700000000},\n                {\"effect\": \"deny\", \"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"*\", \"time_start\": None, \"time_end\": None, \"updated\": 1600000000},\n            ],\n            {\"purpose\": \"research\", \"resource\": \"lab\", \"actor\": \"clinician\", \"time\": 1720000000},\n        ),\n    ]\n\n    results = []\n    for policies, request in test_cases:\n        # Step 1: Compute the set of matching policies\n        matching_policies = []\n        for p in policies:\n            # Check non-time attributes\n            purpose_match = (p[\"purpose\"] == \"*\" or p[\"purpose\"] == request[\"purpose\"])\n            resource_match = (p[\"resource\"] == \"*\" or p[\"resource\"] == request[\"resource\"])\n            actor_match = (p[\"actor\"] == \"*\" or p[\"actor\"] == request[\"actor\"])\n            \n            # Check time attribute\n            time_constrained = p[\"time_start\"] is not None or p[\"time_end\"] is not None\n            start = p[\"time_start\"] if p[\"time_start\"] is not None else float('-inf')\n            end = p[\"time_end\"] if p[\"time_end\"] is not None else float('inf')\n            time_match = start = request[\"time\"] = end\n            \n            if purpose_match and resource_match and actor_match and time_match:\n                matching_policies.append(p)\n\n        # Step 2: If no policies match, return deny (False)\n        if not matching_policies:\n            results.append(False)\n            continue\n            \n        # Calculate specificity for each matching policy\n        scored_policies = []\n        for p in matching_policies:\n            score = (\n                (1 if p[\"purpose\"] != \"*\" else 0) +\n                (1 if p[\"resource\"] != \"*\" else 0) +\n                (1 if p[\"actor\"] != \"*\" else 0) +\n                (1 if (p[\"time_start\"] is not None or p[\"time_end\"] is not None) else 0)\n            )\n            scored_policies.append({\"policy\": p, \"score\": score})\n            \n        # Step 3: Compute max specificity and restrict to the maximally specific set\n        max_specificity = -1\n        for sp in scored_policies:\n            if sp[\"score\"] > max_specificity:\n                max_specificity = sp[\"score\"]\n\n        maximally_specific_set = [sp[\"policy\"] for sp in scored_policies if sp[\"score\"] == max_specificity]\n        \n        # Step 4: Apply deny-overrides combining logic\n        effects = {p[\"effect\"] for p in maximally_specific_set}\n        \n        if \"deny\" in effects:\n            # Deny-overrides at equal specificity\n            results.append(False)\n        else:\n            # All effects are 'permit'\n            results.append(True)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4830907"}, {"introduction": "在策略评估的基础原则之上，本练习引入了一个更正式、表现力更强的框架，该框架仿照 XACML 标准。你将构建一个策略决策点 (PDP)，根据包含特定目标和条件的规则来评估请求，并学习处理超出简单“允许”/“拒绝”范围的决策结果，例如针对范围外请求的“不适用”和针对信息缺失请求的“不确定”。这个实践阐明了企业级系统如何精确而稳健地管理访问控制 [@problem_id:4830982]。", "problem": "给定一个医疗信息学中关于医疗保健同意管理的场景。目标是指定并评估一个符合可扩展访问控制标记语言（eXtensible Access Control Markup Language, XACML）的访问控制策略，以强制执行基于同意的目的限制。您必须实现一个程序化的策略决策点（Policy Decision Point, PDP），该决策点根据一个形式化策略评估请求，并为一组固定的测试套件生成决策。\n\n基本假设和定义：\n- 基于属性的访问控制（Attribute-Based Access Control, ABAC）通过对附加到主体、资源、操作和环境上下文的属性应用逻辑谓词来评估访问。设一个请求为一个从符号属性名称到值的有限映射 $r$。评估使用公认的命题逻辑运算符 $\\land$（逻辑与）、$\\lor$（逻辑或）、$\\lnot$（逻辑非）、等号 $=$、不等号 $\\neq$、集合成员关系 $\\in$ 和集合子集关系 $\\subseteq$ 来执行。\n- 基于同意的目的限制原则要求，只有在获得特定使用目的的明确同意、在已同意的数据类别范围内、并在同意有效期内，才允许处理临床数据。\n- XACML 评估模型包括目标（target）、规则（rule）和组合算法（combining algorithm）。策略的目标谓词 $T(r)$ 决定该策略是否适用。一个规则具有一个效果（Permit 或 Deny）和一个条件谓词 $C_i(r)$。此处使用的组合算法是 permit-overrides 的简化形式：任何适用的 Permit 决策将覆盖 Deny 和 NotApplicable；当未解析的属性评估影响规则条件时，将导致 Indeterminate。\n\n策略规范：\n- 策略目标谓词：\n  $$T(r) := r[\\text{resource\\_type}] = \\text{\"clinical\"}.$$\n  如果 $T(r)$ 为假，则总体决策为 NotApplicable。如果 $r[\\text{resource\\_type}]$ 缺失，则决策为 Indeterminate。\n\n- 规则 $\\mathcal{R}_1$（基于明确同意的许可，具有目的限制和范围）：\n  效果：Permit。\n  条件 $C_1(r)$ 要求以下所有项同时成立：\n  $$r[\\text{consent\\_status}] = \\text{True},$$\n  $$r[\\text{purpose\\_of\\_use}] \\in r[\\text{consent\\_purposes}],$$\n  $$r[\\text{requester\\_role}] \\in r[\\text{consent\\_roles}],$$\n  $$r[\\text{data\\_category}] \\in r[\\text{consent\\_data\\_categories}],$$\n  $$r[\\text{now}] \\le r[\\text{consent\\_expiry\\_time}].$$\n  如果 $C_1(r)$ 中的任何属性缺失，$C_1(r)$ 的评估结果为 Indeterminate。\n\n- 规则 $\\mathcal{R}_2$（在紧急破窗情况下为治疗目的的许可）：\n  效果：Permit。\n  条件 $C_2(r)$:\n  $$r[\\text{emergency}] = \\text{True} \\land r[\\text{allow\\_emergency\\_override}] = \\text{True} \\land r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"} \\land r[\\text{requester\\_role}] \\in \\{\\text{\"physician\"}, \\text{\"nurse\"}\\}.$$\n  如果 $C_2(r)$ 中的任何属性缺失，$C_2(r)$ 的评估结果为 Indeterminate。\n\n- 规则 $\\mathcal{R}_3$（当同意中排除时，拒绝针对敏感类别数据的研究）：\n  效果：Deny。\n  条件 $C_3(r)$:\n  $$r[\\text{data\\_category}] \\in \\{\\text{\"genetic\"}, \\text{\"mental\\_health\"}\\} \\land r[\\text{purpose\\_of\\_use}] = \\text{\"research\"} \\land r[\\text{exclude\\_sensitive}] = \\text{True}.$$\n  如果 $C_3(r)$ 中的任何属性缺失，$C_3(r)$ 的评估结果为 Indeterminate。\n\n- 规则 $\\mathcal{R}_4$（当策略目标适用且无许可规则适用时的默认拒绝）：\n  效果：Deny。\n  条件 $C_4(r)$ 是重言式（始终为真），但仅在目标 $T(r)$ 为真且没有其他规则产生 Permit、Deny 或 Indeterminate 的情况下才被考虑。这在目标域内编码了故障安全默认（默认拒绝）原则。\n\n组合算法（简化的 permit-overrides）：\n给定在目标 $T(r)$ 下的规则结果多重集 $\\{R_i\\}$，\n1. 如果 $T(r)$ 为假，返回 NotApplicable。\n2. 如果由于 $r[\\text{resource\\_type}]$ 缺失导致 $T(r)$ 为 Indeterminate，返回 Indeterminate。\n3. 评估每个 $C_i(r)$:\n   - 如果任何 $R_i$ 是 Permit，返回 Permit。\n   - 否则，如果任何 $R_i$ 是 Indeterminate，返回 Indeterminate。\n   - 否则，如果任何 $R_i$ 是 Deny，返回 Deny。\n   - 否则（无规则适用），通过应用 $\\mathcal{R}_4$ 返回 Deny。\n这与一种保守的解释相一致：未解析的属性引用产生 Indeterminate，目标域内缺乏积极授权则产生 Deny。\n\n决策编码：\n- Permit $\\rightarrow$ $1$,\n- Deny $\\rightarrow$ $0$,\n- NotApplicable $\\rightarrow$ $-1$,\n- Indeterminate $\\rightarrow$ $2$.\n\n单位：\n- 所有时间属性 $r[\\text{now}]$ 和 $r[\\text{consent\\_expiry\\_time}]$ 均以自 Unix 纪元以来的秒数表示，所有比较必须以秒为单位进行。\n\n测试套件：\n对以下 $8$ 个请求评估策略。每个请求 $r$ 以属性名称到值的映射形式给出。\n\n- 测试用例 $1$（正常路径，具有有效的治疗同意）：\n  $r[\\text{resource\\_type}] = \\text{\"clinical\"}$,\n  $r[\\text{consent\\_status}] = \\text{True}$,\n  $r[\\text{consent\\_purposes}] = [\\text{\"treatment\"}]$,\n  $r[\\text{consent\\_roles}] = [\\text{\"physician\"}, \\text{\"nurse\"}]$,\n  $r[\\text{consent\\_data\\_categories}] = [\\text{\"lab\\_results\"}, \\text{\"imaging\"}]$,\n  $r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"}$,\n  $r[\\text{requester\\_role}] = \\text{\"physician\"}$,\n  $r[\\text{data\\_category}] = \\text{\"lab\\_results\"}$,\n  $r[\\text{now}] = 1700000000$,\n  $r[\\text{consent\\_expiry\\_time}] = 1800000000$,\n  $r[\\text{emergency}] = \\text{False}$,\n  $r[\\text{allow\\_emergency\\_override}] = \\text{True}$,\n  $r[\\text{exclude\\_sensitive}] = \\text{True}$.\n\n- 测试用例 $2$（请求研究，但同意仅限于治疗）：\n  与用例 $1$ 相同，除了 $r[\\text{purpose\\_of\\_use}] = \\text{\"research\"}$。\n\n- 测试用例 $3$（同意已过期）：\n  与用例 $1$ 相同，除了 $r[\\text{now}] = 1900000000$ 和 $r[\\text{consent\\_expiry\\_time}] = 1800000000$。\n\n- 测试用例 $4$（护士在无同意情况下为治疗目的进行紧急破窗操作）：\n  $r[\\text{resource\\_type}] = \\text{\"clinical\"}$,\n  $r[\\text{consent\\_status}] = \\text{False}$,\n  $r[\\text{consent\\_purposes}] = [\\text{\"treatment\"}]$,\n  $r[\\text{consent\\_roles}] = [\\text{\"physician\"}, \\text{\"nurse\"}]$,\n  $r[\\text{consent\\_data\\_categories}] = [\\text{\"lab\\_results\"}]$,\n  $r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"}$,\n  $r[\\text{requester\\_role}] = \\text{\"nurse\"}$,\n  $r[\\text{data\\_category}] = \\text{\"lab\\_results\"}$,\n  $r[\\text{now}] = 1700000100$,\n  $r[\\text{consent\\_expiry\\_time}] = 1800000000$,\n  $r[\\text{emergency}] = \\text{True}$,\n  $r[\\text{allow\\_emergency\\_override}] = \\text{True}$,\n  $r[\\text{exclude\\_sensitive}] = \\text{True}$.\n\n- 测试用例 $5$（对敏感数据的研究被同意范围排除）：\n  $r[\\text{resource\\_type}] = \\text{\"clinical\"}$,\n  $r[\\text{consent\\_status}] = \\text{True}$,\n  $r[\\text{consent\\_purposes}] = [\\text{\"research\"}]$,\n  $r[\\text{consent\\_roles}] = [\\text{\"researcher\"}]$,\n  $r[\\text{consent\\_data\\_categories}] = [\\text{\"lab\\_results\"}]$,\n  $r[\\text{purpose\\_of\\_use}] = \\text{\"research\"}$,\n  $r[\\text{requester\\_role}] = \\text{\"researcher\"}$,\n  $r[\\text{data\\_category}] = \\text{\"genetic\"}$,\n  $r[\\text{now}] = 1700000000$,\n  $r[\\text{consent\\_expiry\\_time}] = 1800000000$,\n  $r[\\text{emergency}] = \\text{False}$,\n  $r[\\text{allow\\_emergency\\_override}] = \\text{True}$,\n  $r[\\text{exclude\\_sensitive}] = \\text{True}$.\n\n- 测试用例 $6$（由于非临床资源而不适用）：\n  $r[\\text{resource\\_type}] = \\text{\"financial\"}$,\n  $r[\\text{consent\\_status}] = \\text{True}$,\n  $r[\\text{consent\\_purposes}] = [\\text{\"treatment\"}]$,\n  $r[\\text{consent\\_roles}] = [\\text{\"physician\"}]$,\n  $r[\\text{consent\\_data\\_categories}] = [\\text{\"lab\\_results\"}]$,\n  $r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"}$,\n  $r[\\text{requester\\_role}] = \\text{\"physician\"}$,\n  $r[\\text{data\\_category}] = \\text{\"lab\\_results\"}$,\n  $r[\\text{now}] = 1700000000$,\n  $r[\\text{consent\\_expiry\\_time}] = 1800000000$,\n  $r[\\text{emergency}] = \\text{False}$,\n  $r[\\text{allow\\_emergency\\_override}] = \\text{True}$,\n  $r[\\text{exclude\\_sensitive}] = \\text{True}$.\n\n- 测试用例 $7$（在目标适用时因缺少同意目的而导致不确定）：\n  $r[\\text{resource\\_type}] = \\text{\"clinical\"}$,\n  $r[\\text{consent\\_status}] = \\text{True}$,\n  $r[\\text{consent\\_purposes}]$ 缺失,\n  $r[\\text{consent\\_roles}] = [\\text{\"physician\"}]$,\n  $r[\\text{consent\\_data\\_categories}] = [\\text{\"lab\\_results\"}]$,\n  $r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"}$,\n  $r[\\text{requester\\_role}] = \\text{\"physician\"}$,\n  $r[\\text{data\\_category}] = \\text{\"lab\\_results\"}$,\n  $r[\\text{now}] = 1700000000$,\n  $r[\\text{consent\\_expiry\\_time}] = 1800000000$,\n  $r[\\text{emergency}] = \\text{False}$,\n  $r[\\text{allow\\_emergency\\_override}] = \\text{True}$,\n  $r[\\text{exclude\\_sensitive}] = \\text{True}$.\n\n- 测试用例 $8$（角色未在同意中授权）：\n  $r[\\text{resource\\_type}] = \\text{\"clinical\"}$,\n  $r[\\text{consent\\_status}] = \\text{True}$,\n  $r[\\text{consent\\_purposes}] = [\\text{\"treatment\"}]$,\n  $r[\\text{consent\\_roles}] = [\\text{\"physician\"}, \\text{\"nurse\"}]$,\n  $r[\\text{consent\\_data\\_categories}] = [\\text{\"lab\\_results\"}]$,\n  $r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"}$,\n  $r[\\text{requester\\_role}] = \\text{\"admin\"}$,\n  $r[\\text{data\\_category}] = \\text{\"lab\\_results\"}$,\n  $r[\\text{now}] = 1700000000$,\n  $r[\\text{consent\\_expiry\\_time}] = 1800000000$,\n  $r[\\text{emergency}] = \\text{False}$,\n  $r[\\text{allow\\_emergency\\_override}] = \\text{True}$,\n  $r[\\text{exclude\\_sensitive}] = \\text{True}$.\n\n您的任务：\n- 实现一个程序，该程序对 $i \\in \\{1,2,3\\}$ 编码 $T(r)$ 和 $C_i(r)$，应用上述组合算法，并计算每个测试用例的决策编码。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$\\text{\"[1,0,-1]\"}$）。", "solution": "该问题要求实现一个基于属性的访问控制（ABAC）系统的策略决策点（PDP），其规范方式类似于 XACML。PDP 必须根据为医疗保健同意管理设计的形式化策略来评估访问请求。解决方案涉及将给定的逻辑谓词和组合算法系统地转换为一个过程化的评估流程。\n\n解决方案的核心是一个处理单个访问请求的函数，该请求表示为从属性名称到值的映射 $r$。此函数必须产生四种可能的决策之一：Permit（编码为 $1$）、Deny（编码为 $0$）、NotApplicable（编码为 $-1$）或 Indeterminate（编码为 $2$）。\n\n评估过程严格遵循问题陈述中定义的层次结构。首先，评估策略的目标谓词 $T(r)$。\n$$T(r) := r[\\text{resource\\_type}] = \\text{\"clinical\"}$$\n如果请求中缺少属性 $r[\\text{resource\\_type}]$，则 $T(r)$ 的评估结果不明确，导致总体决策为 Indeterminate ($2$)。如果该属性存在但其值不是 \"clinical\"，则该策略不适用，决策为 NotApplicable ($-1$)。当且仅当 $T(r)$ 为真时，评估才会继续进行规则评估。\n\n一旦满足目标，PDP 会评估一组规则，每个规则都有一个条件谓词 $C_i(r)$ 和一个效果（Permit 或 Deny）。一个关键方面是在条件评估期间处理缺失的属性。如果谓词 $C_i(r)$ 所需的任何属性缺失，则 $C_i(r)$ 的评估结果为 Indeterminate。因此，规则 $\\mathcal{R}_i$ 的结果确定如下：\n- 如果 $C_i(r)$ 为真，则结果为规则的效果（Permit 或 Deny）。\n- 如果 $C_i(r)$ 为假，则该规则不适用。\n- 如果 $C_i(r)$ 是 Indeterminate，则规则的结果是 Indeterminate。\n\n四个指定的规则是：\n1.  $\\mathcal{R}_1$ (Permit): 条件 $C_1(r) := (r[\\text{consent\\_status}] = \\text{True}) \\land (r[\\text{purpose\\_of\\_use}] \\in r[\\text{consent\\_purposes}]) \\land (r[\\text{requester\\_role}] \\in r[\\text{consent\\_roles}]) \\land (r[\\text{data\\_category}] \\in r[\\text{consent\\_data\\_categories}]) \\land (r[\\text{now}] \\le r[\\text{consent\\_expiry\\_time}])$。该规则强制执行核心的同意要求。\n2.  $\\mathcal{R}_2$ (Permit): 条件 $C_2(r) := (r[\\text{emergency}] = \\text{True}) \\land (r[\\text{allow\\_emergency\\_override}] = \\text{True}) \\land (r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"}) \\land (r[\\text{requester\\_role}] \\in \\{\\text{\"physician\"}, \\text{\"nurse\"}\\})$。该规则提供了紧急破窗机制。\n3.  $\\mathcal{R}_3$ (Deny): 条件 $C_3(r) := (r[\\text{data\\_category}] \\in \\{\\text{\"genetic\"}, \\text{\"mental\\_health\"}\\}) \\land (r[\\text{purpose\\_of\\_use}] = \\text{\"research\"}) \\land (r[\\text{exclude\\_sensitive}] = \\text{True})$。该规则强制执行对敏感数据的特定排除。\n4.  $\\mathcal{R}_4$ (Deny): 这是一个默认拒绝规则，仅在目标满足且没有其他规则产生 Permit、Deny 或 Indeterminate 时适用。\n\n在评估完单个规则 $\\mathcal{R}_1$、$\\mathcal{R}_2$ 和 $\\mathcal{R}_3$ 之后，它们的结果将使用指定的“简化 permit-overrides”算法进行组合。该算法建立了一个明确的优先级：\n1.  如果任何规则产生 Permit，则最终决策为 Permit ($1$)。\n2.  否则，如果任何规则产生 Indeterminate，则最终决策为 Indeterminate ($2$)。\n3.  否则，如果任何规则产生 Deny，则最终决策为 Deny ($0$)。\n4.  否则（意味着所有规则都不适用），触发默认拒绝规则 $\\mathcal{R}_4$，最终决策为 Deny ($0$)。\n\n为了说明，考虑测试用例 1（正常路径）：\n- $T(r)$ 为真，因为 $r[\\text{resource\\_type}] = \\text{\"clinical\"}$。\n- 对于 $\\mathcal{R}_1$，$C_1(r)$ 的所有五个子条件都满足：同意是有效的，目的匹配，角色匹配，数据类别匹配，并且请求在有效期内。因此，$C_1(r)$ 为真，$\\mathcal{R}_1$ 产生 Permit。\n- 组合算法找到一个 Permit 结果，并立即返回最终决策 Permit ($1$)。\n\n相反，考虑测试用例 7（缺少属性）：\n- $T(r)$ 为真。\n- 在评估 $C_1(r)$ 时，检查 $r[\\text{purpose\\_of\\_use}] \\in r[\\text{consent\\_purposes}]$ 需要属性 $r[\\text{consent\\_purposes}]$。由于它缺失，$C_1(r)$ 的评估结果为 Indeterminate。因此，规则 $\\mathcal{R}_1$ 的结果是 Indeterminate。\n- $\\mathcal{R}_2$ 和 $\\mathcal{R}_3$ 的条件评估为假。\n- 组合算法没有找到 Permit 结果。然后它从 $\\mathcal{R}_1$ 找到一个 Indeterminate 结果，并返回最终决策 Indeterminate ($2$)。\n\n实现将包括一个主评估函数来协调这些步骤。辅助函数将用于评估每个条件谓词，通过传播 Indeterminate 状态来仔细处理可能缺失的属性。最终程序将遍历提供的测试套件，对每个用例应用此评估逻辑，并将生成的决策代码格式化为指定的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, evaluate them against the policy,\n    and print the results.\n    \"\"\"\n\n    # --- Decision and Logic Constants ---\n    class Decision:\n        PERMIT = 1\n        DENY = 0\n        NOT_APPLICABLE = -1\n        INDETERMINATE = 2\n\n    class RuleResult:\n        PERMIT = \"Permit\"\n        DENY = \"Deny\"\n        NOT_APPLICABLE = \"NotApplicable\"\n        INDETERMINATE = \"Indeterminate\"\n\n    class MissingAttributeError(Exception):\n        \"\"\"Custom exception for handling missing attributes in requests.\"\"\"\n        pass\n\n    def get_attribute(request, key):\n        \"\"\"Safely retrieves an attribute, raising an error if it's missing.\"\"\"\n        if key not in request:\n            raise MissingAttributeError(f\"Attribute '{key}' is missing.\")\n        return request[key]\n\n    # --- Rule Condition Predicate Evaluators ---\n    def evaluate_C1(r):\n        try:\n            return (\n                get_attribute(r, 'consent_status') is True and\n                get_attribute(r, 'purpose_of_use') in get_attribute(r, 'consent_purposes') and\n                get_attribute(r, 'requester_role') in get_attribute(r, 'consent_roles') and\n                get_attribute(r, 'data_category') in get_attribute(r, 'consent_data_categories') and\n                get_attribute(r, 'now') = get_attribute(r, 'consent_expiry_time')\n            )\n        except MissingAttributeError:\n            return RuleResult.INDETERMINATE\n\n    def evaluate_C2(r):\n        try:\n            return (\n                get_attribute(r, 'emergency') is True and\n                get_attribute(r, 'allow_emergency_override') is True and\n                get_attribute(r, 'purpose_of_use') == \"treatment\" and\n                get_attribute(r, 'requester_role') in {\"physician\", \"nurse\"}\n            )\n        except MissingAttributeError:\n            return RuleResult.INDETERMINATE\n\n    def evaluate_C3(r):\n        try:\n            return (\n                get_attribute(r, 'data_category') in {\"genetic\", \"mental_health\"} and\n                get_attribute(r, 'purpose_of_use') == \"research\" and\n                get_attribute(r, 'exclude_sensitive') is True\n            )\n        except MissingAttributeError:\n            return RuleResult.INDETERMINATE\n\n    def evaluate_request(r):\n        \"\"\"\n        Evaluates a single access request against the defined policy.\n        \"\"\"\n        # 1. Target Evaluation\n        try:\n            if get_attribute(r, 'resource_type') != \"clinical\":\n                return Decision.NOT_APPLICABLE\n        except MissingAttributeError:\n            return Decision.INDETERMINATE\n\n        # 2. Evaluate Rule Conditions\n        condition_outcomes = {\n            'C1': evaluate_C1(r),\n            'C2': evaluate_C2(r),\n            'C3': evaluate_C3(r),\n        }\n\n        # 3. Determine Rule Results based on Effects\n        rule_results = []\n        # Rule R1 (Permit)\n        if condition_outcomes['C1'] is True:\n            rule_results.append(RuleResult.PERMIT)\n        elif condition_outcomes['C1'] is False:\n            rule_results.append(RuleResult.NOT_APPLICABLE)\n        else: # Indeterminate\n            rule_results.append(RuleResult.INDETERMINATE)\n\n        # Rule R2 (Permit)\n        if condition_outcomes['C2'] is True:\n            rule_results.append(RuleResult.PERMIT)\n        elif condition_outcomes['C2'] is False:\n            rule_results.append(RuleResult.NOT_APPLICABLE)\n        else: # Indeterminate\n            rule_results.append(RuleResult.INDETERMINATE)\n            \n        # Rule R3 (Deny)\n        if condition_outcomes['C3'] is True:\n            rule_results.append(RuleResult.DENY)\n        elif condition_outcomes['C3'] is False:\n            rule_results.append(RuleResult.NOT_APPLICABLE)\n        else: # Indeterminate\n            rule_results.append(RuleResult.INDETERMINATE)\n\n        # 4. Apply Combining Algorithm (Simplified Permit-Overrides)\n        if RuleResult.PERMIT in rule_results:\n            return Decision.PERMIT\n        \n        if RuleResult.INDETERMINATE in rule_results:\n            return Decision.INDETERMINATE\n        \n        if RuleResult.DENY in rule_results:\n            return Decision.DENY\n            \n        # All rules are NotApplicable, so apply default deny (R4)\n        return Decision.DENY\n\n    # --- Test Suite Definition ---\n    case1 = {\n        \"resource_type\": \"clinical\", \"consent_status\": True,\n        \"consent_purposes\": [\"treatment\"], \"consent_roles\": [\"physician\", \"nurse\"],\n        \"consent_data_categories\": [\"lab_results\", \"imaging\"],\n        \"purpose_of_use\": \"treatment\", \"requester_role\": \"physician\",\n        \"data_category\": \"lab_results\", \"now\": 1700000000,\n        \"consent_expiry_time\": 1800000000, \"emergency\": False,\n        \"allow_emergency_override\": True, \"exclude_sensitive\": True\n    }\n    case2 = case1.copy(); case2[\"purpose_of_use\"] = \"research\"\n    case3 = case1.copy(); case3[\"now\"] = 1900000000\n    case4 = {\n        \"resource_type\": \"clinical\", \"consent_status\": False,\n        \"consent_purposes\": [\"treatment\"], \"consent_roles\": [\"physician\", \"nurse\"],\n        \"consent_data_categories\": [\"lab_results\"],\n        \"purpose_of_use\": \"treatment\", \"requester_role\": \"nurse\",\n        \"data_category\": \"lab_results\", \"now\": 1700000100,\n        \"consent_expiry_time\": 1800000000, \"emergency\": True,\n        \"allow_emergency_override\": True, \"exclude_sensitive\": True\n    }\n    case5 = {\n        \"resource_type\": \"clinical\", \"consent_status\": True,\n        \"consent_purposes\": [\"research\"], \"consent_roles\": [\"researcher\"],\n        \"consent_data_categories\": [\"lab_results\"],\n        \"purpose_of_use\": \"research\", \"requester_role\": \"researcher\",\n        \"data_category\": \"genetic\", \"now\": 1700000000,\n        \"consent_expiry_time\": 1800000000, \"emergency\": False,\n        \"allow_emergency_override\": True, \"exclude_sensitive\": True\n    }\n    case6 = case1.copy(); case6[\"resource_type\"] = \"financial\"\n    case7 = {\n        \"resource_type\": \"clinical\", \"consent_status\": True,\n        # \"consent_purposes\" is missing\n        \"consent_roles\": [\"physician\"], \"consent_data_categories\": [\"lab_results\"],\n        \"purpose_of_use\": \"treatment\", \"requester_role\": \"physician\",\n        \"data_category\": \"lab_results\", \"now\": 1700000000,\n        \"consent_expiry_time\": 1800000000, \"emergency\": False,\n        \"allow_emergency_override\": True, \"exclude_sensitive\": True\n    }\n    case8 = case1.copy(); case8[\"requester_role\"] = \"admin\"\n\n    test_cases = [case1, case2, case3, case4, case5, case6, case7, case8]\n\n    # --- Execution and Output ---\n    results = [evaluate_request(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4830982"}, {"introduction": "访问控制系统的有效性取决于其配置是否正确。最后一个实践探讨了“策略遮蔽”这一现实世界中的挑战，即一个宽泛的“拒绝”规则错误地覆盖了一个特定的“允许”规则，从而导致访问失败。你将扮演安全分析师的角色，评估一个用于检测此类配置错误的工具的性能，并使用 F1 分数等标准性能指标来评估其准确性，从而学习一项在同意管理系统的质量保证和验证中至关重要的技能 [@problem_id:4830976]。", "problem": "一个医院级的电子健康记录 (EHR) 系统强制执行基于角色的访问控制 (RBAC) 和患者同意策略。预期的组合语义是“最具体的允许覆盖宽泛的拒绝”，但一个错误的配置部署了“宽泛的拒绝覆盖”评估机制，并附带一个高优先级的宽泛拒绝规则。这会导致遮蔽 (shadowing)：本应授权访问的具体允许规则被一个更通用的拒绝规则所隐藏。考虑以下合规性所要求的同意和访问控制规则：\n\n- 具体允许规则 $P_{\\text{cardio}}$：如果 `subject.role` $=$ `Cardiologist`，`resource.type` $=$ `cardiology_notes`，`purpose` $=$ `treatment`，则允许，无论主体隶属关系（内部与外部）如何，前提是患者已同意治疗。\n- 具体允许规则 $P_{\\text{er}}$：如果 `subject.dept` $=$ `Emergency`，`resource.type` $=$ `allergies`，`purpose` $=$ `emergency`，则允许。\n- 宽泛拒绝规则 $D_{\\text{ext}}$：如果 `subject.affiliation` $\\neq$ `Hospital_H1`（一个“外部”提供者），则拒绝。在已部署的引擎中，此拒绝规则被错误配置为比具体允许规则具有更高的评估优先级。\n- 宽泛拒绝规则 $D_{\\text{research}}$：如果 `purpose` $=$ `research` 且 `patient.research_opt_out` $=$ `true`，则拒绝。\n\n一位安全分析师正在评估一个遮蔽-错误配置检测器。如果在一个访问请求的策略路径中，由于引擎的错误配置优先级，一个具体的允许规则被一个更宽泛的拒绝规则所覆盖，该检测器就会将该请求标记为“被遮蔽的允许”。该分析师执行了以下 $12$ 个测试用例 $T_{1}$ 到 $T_{12}$，每个用例都标注了其在合规语义（最具体的允许覆盖）下的预期决策、在错误配置（宽泛的拒绝覆盖）下的实际引擎决策，以及检测器是否对其进行了标记。\n\n- $T_{1}$：`subject.affiliation` $=$ `external`；`subject.role` $=$ `Cardiologist`；`resource.type` $=$ `cardiology_notes`；`purpose` $=$ `treatment`；`patient.research_opt_out` $=$ `false`；`emergency` $=$ `false`。预期：允许；实际：拒绝；检测器：已标记。\n- $T_{2}$：`subject.affiliation` $=$ `internal`；`subject.role` $=$ `Cardiologist`；`resource.type` $=$ `cardiology_notes`；`purpose` $=$ `treatment`；`patient.research_opt_out` $=$ `false`；`emergency` $=$ `false`。预期：允许；实际：允许；检测器：未标记。\n- $T_{3}$：`subject.affiliation` $=$ `external`；`subject.dept` $=$ `Emergency`；`resource.type` $=$ `allergies`；`purpose` $=$ `emergency`；`patient.research_opt_out` $=$ `false`。预期：允许；实际：拒绝；检测器：已标记。\n- $T_{4}$：`subject.affiliation` $=$ `external`；`subject.role` $=$ `Cardiologist`；`resource.type` $=$ `radiology_report`；`purpose` $=$ `treatment`；`patient.research_opt_out` $=$ `false`。预期：拒绝；实际：拒绝；检测器：已标记。\n- $T_{5}$：`subject.affiliation` $=$ `internal`；`subject.dept` $=$ `Emergency`；`resource.type` $=$ `allergies`；`purpose` $=$ `emergency`；`patient.research_opt_out` $=$ `false`。预期：允许；实际：允许；检测器：未标记。\n- $T_{6}$：`subject.affiliation` $=$ `external`；`subject.role` $=$ `Nurse`；`resource.type` $=$ `cardiology_notes`；`purpose` $=$ `treatment`；`patient.research_opt_out` $=$ `false`。预期：拒绝；实际：拒绝；检测器：未标记。\n- $T_{7}$：`subject.affiliation` $=$ `external`；`subject.role` $=$ `Cardiologist`；`resource.type` $=$ `cardiology_notes`；`purpose` $=$ `research`；`patient.research_opt_out` $=$ `false`。预期：拒绝；实际：拒绝；检测器：已标记。\n- $T_{8}$：`subject.affiliation` $=$ `internal`；`subject.role` $=$ `Researcher`；`resource.type` $=$ `lab_results`；`purpose` $=$ `research`；`patient.research_opt_out` $=$ `true`。预期：拒绝；实际：拒绝；检测器：未标记。\n- $T_{9}$：`subject.affiliation` $=$ `external`；`subject.role` $=$ `Cardiologist`；`resource.type` $=$ `cardiology_notes`；`purpose` $=$ `treatment`；`emergency` $=$ `true`；`patient.research_opt_out` $=$ `false`。预期：允许；实际：拒绝；检测器：未标记。\n- $T_{10}$：`subject.affiliation` $=$ `external`；`subject.dept` $=$ `Emergency`；`resource.type` $=$ `allergies`；`purpose` $=$ `treatment`；`patient.research_opt_out` $=$ `false`。预期：拒绝；实际：拒绝；检测器：未标记。\n- $T_{11}$：`subject.affiliation` $=$ `internal`；`subject.role` $=$ `Cardiologist`；`resource.type` $=$ `cardiology_notes`；`purpose` $=$ `treatment`；`patient.research_opt_out` $=$ `false`。预期：允许；实际：允许；检测器：未标记。\n- $T_{12}$：`subject.affiliation` $=$ `external`；`subject.role` $=$ `Cardiologist`；`resource.type` $=$ `cardiology_notes`；`purpose` $=$ `treatment`；`patient.research_opt_out` $=$ `false`；`eConsent_override` $=$ `true`。预期：允许；实际：拒绝；检测器：已标记。\n\n将“阳性”测试定义为在预期语义（允许）下，一个具体的允许规则本应适用，但由于宽泛的拒绝规则而被已部署的引擎拒绝的测试，即一个被遮蔽的允许。仅使用上述数据，计算该检测器在此测试套件上的 $F_{1}$-score，并将检测到的情况视为“阳性”预测。将您的答案四舍五入到四位有效数字。以纯数字形式表示最终值，不带百分号。", "solution": "用户提供的问题首先经过严格的验证过程。\n\n### 步骤 1：提取已知信息\n问题提供了一组访问控制规则、两种不同策略评估语义的描述，以及一套包含 $12$ 个测试用例及其结果的测试套件。\n\n**访问控制规则：**\n- $P_{\\text{cardio}}$：如果 `subject.role` $=$ `Cardiologist`，`resource.type` $=$ `cardiology_notes`，`purpose` $=$ `treatment`，则允许。\n- $P_{\\text{er}}$：如果 `subject.dept` $=$ `Emergency`，`resource.type` $=$ `allergies`，`purpose` $=$ `emergency`，则允许。\n- $D_{\\text{ext}}$：如果 `subject.affiliation` $\\neq$ `Hospital_H1`，则拒绝。此规则被错误配置为高优先级。\n- $D_{\\text{research}}$：如果 `purpose` $=$ `research` 且 `patient.research_opt_out` $=$ `true`，则拒绝。\n\n**策略语义：**\n- 预期语义：“最具体的允许覆盖宽泛的拒绝”。\n- 实际（错误配置）语义：“宽泛的拒绝覆盖”。\n\n**检测器定义：**\n- 如果一个具体的允许规则处于活动状态但被一个更宽泛的拒绝规则所覆盖，检测器会将请求标记为“被遮蔽的允许”。\n\n**评估的基准真相定义：**\n- “阳性”测试用例定义为代表一个被遮蔽的允许的用例，它对应于一个 `Intended` (预期) 决策为 `Permit` (允许) 且 `Actual` (实际) 引擎决策为 `Deny` (拒绝) 的访问请求。\n\n**评估的预测定义：**\n- “阳性”预测是指检测器 `Flagged` (标记了) 该请求的用例。\n\n**测试用例 ($T_1$ 到 $T_{12}$):**\n- $T_{1}$：预期：允许；实际：拒绝；检测器：已标记。\n- $T_{2}$：预期：允许；实际：允许；检测器：未标记。\n- $T_{3}$：预期：允许；实际：拒绝；检测器：已标记。\n- $T_{4}$：预期：拒绝；实际：拒绝；检测器：已标记。\n- $T_{5}$：预期：允许；实际：允许；检测器：未标记。\n- $T_{6}$：预期：拒绝；实际：拒绝；检测器：未标记。\n- $T_{7}$：预期：拒绝；实际：拒绝；检测器：已标记。\n- $T_{8}$：预期：拒绝；实际：拒绝；检测器：未标记。\n- $T_{9}$：预期：允许；实际：拒绝；检测器：未标记。\n- $T_{10}$：预期：拒绝；实际：拒绝；检测器：未标记。\n- $T_{11}$：预期：允许；实际：允许；检测器：未标记。\n- $T_{12}$：预期：允许；实际：拒绝；检测器：已标记。\n\n### 步骤 2：使用提取的已知信息进行验证\n该问题在计算机安全和医学信息学领域具有科学依据，使用了诸如基于角色的访问控制 (RBAC)、策略评估和遮蔽 (shadowing) 等标准术语。这是一个提法恰当的问题，因为它提供了一个完整的、自包含的数据集和一个明确的目标：计算 $F_{1}$-score，这是衡量二元分类准确性的一个标准度量。其语言客观而精确。所提供的数据，包括测试用例的结果（`Intended`、`Actual`、`Detector`），为计算提供了一致的基础，即使检测器本身存在缺陷（而这正是评估的重点）。该问题没有违反任何基本原则，没有说明不足之处，也不包含针对任务的相互矛盾的约束。\n\n### 步骤 3：结论与行动\n该问题被认为是**有效的**。将提供完整的解决方案。\n\n### 解决方案推导\n目标是根据遮蔽-错误配置检测器在所提供的 $12$ 个测试用例上的表现来计算其 $F_{1}$-score。$F_{1}$-score 是精确率和召回率的调和平均数。\n\n首先，我们必须确定基准真相和检测器的预测，以构建一个混淆矩阵。\n- **实际阳性** (Condition Positive) 用例（一个真实的遮蔽实例）被问题定义为 `Intended` (预期) 决策为 `Permit` (允许) 且 `Actual` (实际) 决策为 `Deny` (拒绝) 的测试。\n- **实际阴性** (Condition Negative) 用例是任何其他组合。\n- **预测阳性** (Prediction Positive) 是检测器 `Flagged` (标记了) 的测试用例。\n- **预测阴性** (Prediction Negative) 是检测器 `Not Flagged` (未标记) 的测试用例。\n\n现在我们可以对这 12 个测试用例中的每一个进行分类：\n\n- $T_1$：预期 `Permit`，实际 `Deny`。这是一个**实际阳性**。检测器 `Flagged` 了它，这是一个**预测阳性**。因此，$T_1$ 是一个真阳性 ($TP$)。\n- $T_2$：预期 `Permit`，实际 `Permit`。这是一个**实际阴性**。检测器 `Not Flagged` 了它，这是一个**预测阴性**。因此，$T_2$ 是一个真阴性 ($TN$)。\n- $T_3$：预期 `Permit`，实际 `Deny`。这是一个**实际阳性**。检测器 `Flagged` 了它，这是一个**预测阳性**。因此，$T_3$ 是一个真阳性 ($TP$)。\n- $T_4$：预期 `Deny`，实际 `Deny`。这是一个**实际阴性**。检测器 `Flagged` 了它，这是一个**预测阳性**。因此，$T_4$ 是一个假阳性 ($FP$)。\n- $T_5$：预期 `Permit`，实际 `Permit`。这是一个**实际阴性**。检测器 `Not Flagged` 了它，这是一个**预测阴性**。因此，$T_5$ 是一个真阴性 ($TN$)。\n- $T_6$：预期 `Deny`，实际 `Deny`。这是一个**实际阴性**。检测器 `Not Flagged` 了它，这是一个**预测阴性**。因此，$T_6$ 是一个真阴性 ($TN$)。\n- $T_7$：预期 `Deny`，实际 `Deny`。这是一个**实际阴性**。检测器 `Flagged` 了它，这是一个**预测阳性**。因此，$T_7$ 是一个假阳性 ($FP$)。\n- $T_8$：预期 `Deny`，实际 `Deny`。这是一个**实际阴性**。检测器 `Not Flagged` 了它，这是一个**预测阴性**。因此，$T_8$ 是一个真阴性 ($TN$)。\n- $T_9$：预期 `Permit`，实际 `Deny`。这是一个**实际阳性**。检测器 `Not Flagged` 了它，这是一个**预测阴性**。因此，$T_9$ 是一个假阴性 ($FN$)。\n- $T_{10}$：预期 `Deny`，实际 `Deny`。这是一个**实际阴性**。检测器 `Not Flagged` 了它，这是一个**预测阴性**。因此，$T_{10}$ 是一个真阴性 ($TN$)。\n- $T_{11}$：预期 `Permit`，实际 `Permit`。这是一个**实际阴性**。检测器 `Not Flagged` 了它，这是一个**预测阴性**。这与 $T_2$ 相同，是一个真阴性 ($TN$)。\n- $T_{12}$：预期 `Permit`，实际 `Deny`。这是一个**实际阳性**。检测器 `Flagged` 了它，这是一个**预测阳性**。因此，$T_{12}$ 是一个真阳性 ($TP$)。\n\n总结这 12 个测试的计数：\n- 真阳性 ($TP$)：$3$ 个 ($T_1, T_3, T_{12}$)\n- 假阳性 ($FP$)：$2$ 个 ($T_4, T_7$)\n- 真阴性 ($TN$)：$6$ 个 ($T_2, T_5, T_6, T_8, T_{10}, T_{11}$)\n- 假阴性 ($FN$)：$1$ 个 ($T_9$)\n\n测试总数为 $3 + 2 + 6 + 1 = 12$，这是正确的。\n\n接下来，我们计算精确率 (Precision) 和召回率 (Recall)。\n精确率是正确预测的阳性观察值与总预测阳性观察值的比率。\n$$ \\text{Precision} = \\frac{TP}{TP + FP} $$\n代入数值：\n$$ \\text{Precision} = \\frac{3}{3 + 2} = \\frac{3}{5} = 0.6 $$\n\n召回率（或灵敏度）是正确预测的阳性观察值与实际类别中所有观察值的比率。\n$$ \\text{Recall} = \\frac{TP}{TP + FN} $$\n代入数值：\n$$ \\text{Recall} = \\frac{3}{3 + 1} = \\frac{3}{4} = 0.75 $$\n\n最后，$F_{1}$-score 计算为精确率和召回率的调和平均数。\n$$ F_1 = 2 \\times \\frac{\\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}} $$\n代入计算出的精确率和召回率的值：\n$$ F_1 = 2 \\times \\frac{0.6 \\times 0.75}{0.6 + 0.75} = 2 \\times \\frac{0.45}{1.35} $$\n为了简化分数：\n$$ F_1 = 2 \\times \\frac{45}{135} = 2 \\times \\frac{1}{3} = \\frac{2}{3} $$\n以小数形式表示，$F_1 = 0.666666...$。问题要求四舍五入到四位有效数字。\n$$ F_1 \\approx 0.6667 $$", "answer": "$$ \\boxed{0.6667} $$", "id": "4830976"}]}