{"hands_on_practices": [{"introduction": "临床决策支持 (CDS) 系统有望提高效率和安全性，但我们如何衡量其具体影响？第一个实践将挑战你超越定性描述，构建一个定量模型。通过计算结构化医嘱系统所节省的预期时间，你将学习如何将“五个正确”原则转化为工作流程效率和净效用等具体、可衡量的结果，这是评估和论证健康信息技术干预措施合理性的关键技能。[@problem_id:4860705]", "problem": "一家医院正在评估从自由文本医嘱向由临床决策支持（CDS）系统提供的结构化医嘱集的转变。临床决策支持（CDS）旨在在工作流程中的正确时间点，通过正确的渠道，以正确的干预格式，将正确的信息传递给正确的人。请考虑以下情景，并在“五正确”框架下，为每份医嘱节省的预期时间以及干预格式的净效用进行建模。\n\n假设医生目前输入自由文本医嘱，平均长度为 $L_{\\mathrm{t}} = 160$ 个字符，平均打字速度为 $v = 220$ 字符/分钟。自由文本医嘱的错误概率为 $p_{\\mathrm{t}} = 0.10$，检测到的错误平均需要 $d_{\\mathrm{t}} = 0.60$ 分钟进行纠正。\n\n在使用结构化医嘱集的情况下，医生每份医嘱需要输入 $L_{\\mathrm{s}} = 40$ 个字符并进行 $c = 14$ 次点击。每次点击耗时 $t_{\\mathrm{click}} = 0.25$ 秒。结构化医嘱的错误概率为 $p_{\\mathrm{s}} = 0.04$，平均纠正时间为 $d_{\\mathrm{s}} = 0.40$ 分钟。如果CDS干预未能满足“五正确”，则会因工作流程中断而产生 $t_{\\mathrm{interrupt}} = 0.12$ 分钟的中断成本。\n\n结构化干预的“五正确”满足概率如下：\n- 正确的信息：$p_{\\mathrm{RI}} = 0.93$，\n- 正确的人：$p_{\\mathrm{RP}} = 0.97$，\n- 正确的干预格式：$p_{\\mathrm{RF}} = 0.90$，\n- 正确的渠道：$p_{\\mathrm{RC}} = 0.95$，\n- 正确的工作流程时间点：$p_{\\mathrm{RW}} = 0.88$。\n\n假设“五正确”之间相互独立，且时间分量线性相加。根据预期时间是各分量时间（打字、导航、纠错）的期望和这一定义，首先计算用结构化医嘱集替代自由文本时每份医嘱节省的基础预期时间 $S_{\\mathrm{base}}$。然后计算该格式的净效用，即在满足所有“五正确”时的预期实现节省减去未满足时的预期中断成本，也就是每份医嘱的预期净节省时间：\n- 仅当所有“五正确”都满足时，才能实现节省，\n- 否则将产生中断成本。\n\n将最终答案四舍五入至四位有效数字，并以分钟为单位。", "solution": "本题旨在通过建模比较自由文本医嘱与结构化医嘱集在时间效率上的差异，并结合“五个正确”框架计算净效用。\n\n#### 1. 计算自由文本医嘱的预期时间 ($E[T_{\\text{t}}]$)\n预期时间是打字时间与预期纠错时间的总和。\n$$E[T_{\\text{t}}] = \\frac{\\text{字符数}}{\\text{打字速度}} + (\\text{错误概率} \\times \\text{纠错时间})$$\n$$E[T_{\\text{t}}] = \\frac{L_{\\mathrm{t}}}{v} + p_{\\mathrm{t}}d_{\\mathrm{t}} = \\frac{160}{220} + (0.10 \\times 0.60) \\approx 0.72727 + 0.06 = 0.78727 \\text{ 分钟}$$\n\n#### 2. 计算结构化医嘱的预期时间 ($E[T_{\\text{s}}]$)\n预期时间是打字时间、点击时间与预期纠错时间之和。\n首先，将点击时间单位从秒转换为分钟：$t_{\\mathrm{click}} = 0.25 \\, \\text{s} \\times \\frac{1 \\, \\text{min}}{60 \\, \\text{s}} = \\frac{0.25}{60} \\, \\text{min}$。\n$$E[T_{\\text{s}}] = \\frac{L_{\\mathrm{s}}}{v} + c \\cdot t_{\\mathrm{click}} + p_{\\mathrm{s}}d_{\\mathrm{s}} = \\frac{40}{220} + 14 \\times \\frac{0.25}{60} + (0.04 \\times 0.40)$$\n$$E[T_{\\text{s}}] \\approx 0.18182 + 0.05833 + 0.016 = 0.25615 \\text{ 分钟}$$\n\n#### 3. 计算基础预期节省时间 ($S_{\\text{base}}$)\n基础节省时间是两种方式预期时间之差。\n$$S_{\\text{base}} = E[T_{\\text{t}}] - E[T_{\\text{s}}] \\approx 0.78727 - 0.25615 = 0.53112 \\text{ 分钟}$$\n\n#### 4. 计算净效用 (预期净节省时间 $U$)\n净效用是在“五个正确”全部满足时实现的预期节省，减去未满足时产生的预期中断成本。\n首先，计算“五个正确”全部满足的概率 $P(A)$：\n$$P(A) = p_{\\mathrm{RI}} \\times p_{\\mathrm{RP}} \\times p_{\\mathrm{RF}} \\times p_{\\mathrm{RC}} \\times p_{\\mathrm{RW}}$$\n$$P(A) = 0.93 \\times 0.97 \\times 0.90 \\times 0.95 \\times 0.88 = 0.67874004$$\n那么，至少有一个“正确”未满足的概率为 $P(A^c) = 1 - P(A) = 1 - 0.67874004 = 0.32125996$。\n净效用 $U$ 的计算公式为：\n$$U = S_{\\text{base}} \\times P(A) - t_{\\mathrm{interrupt}} \\times P(A^c)$$\n$$U \\approx (0.53112 \\times 0.67874004) - (0.12 \\times 0.32125996)$$\n$$U \\approx 0.36049 - 0.03855 = 0.32194 \\text{ 分钟}$$\n\n#### 5. 最终答案\n将结果四舍五入至四位有效数字，得到 $0.3219$ 分钟。", "answer": "$$\\boxed{0.3219}$$", "id": "4860705"}, {"introduction": "设计有效的 CDS 通常需要权衡取舍，优化“五个正确”中的某一个有时可能会损害另一个，这是复杂系统设计中的常见挑战。本练习将呈现一个真实场景：改善警报的“正确时机”反而降低了将其传递给“正确人员”的准确性。通过计算对用户依从性的净影响，你将在分析和应对真实世界中 CDS 实施时的关键权衡方面获得实践经验。[@problem_id:4860710]", "problem": "一家医院实施了临床决策支持 (CDS)，这是一种在诊疗现场向临床医生提供针对特定患者的评估或建议的软件，以维护五个正确原则：正确的信息、正确的人员、正确的干预格式、正确的渠道以及正确的时间/地点。考虑一个用于开具高风险抗生素的过敏检查警报。CDS 团队考虑将警报在药物开立工作流程中提前，以改善“正确的时间/地点”原则，但这样做会触发一个路由限制：在较早的时间点，开单医生的身份尚不明确，因此警报会以概率方式被路由到一个为分诊护士准备的池中，而不是直接发送给开单医生。\n\n使用以下科学上合理的参数。在较晚的时间点（医嘱签署后），身份解析很强，警报以 $0.95$ 的概率被路由给开单医生，而以 $0.05$ 的概率被路由到分诊护士池。在较早的时间点（医嘱录入开始时），由于该步骤身份解析不完整，警报以 $0.30$ 的概率被路由给开单医生，以 $0.70$ 的概率被路由到分诊护士池。\n\n设依从性为接收者执行推荐操作（例如，解决过敏冲突）的概率。在较晚的时间点，当开单医生收到警报时，依从性概率为 $0.48$；当分诊护士收到警报时，依从性概率为 $0.15$。在较早的时间点，当开单医生收到警报时，依从性概率增加到 $0.62$；当分诊护士收到警报时，依从性概率增加到 $0.25$，这反映了在医嘱最终确定前采取行动的时机更佳。所有概率均为经验性估计，并且在不同医嘱之间是独立的。\n\n从概率和条件概率的核心定义出发，通过适当组合路由概率和条件依从性概率，计算在较晚时间和较早时间的期望依从性。然后计算对依从性的净效应，定义为 $\\Delta A = A_{\\text{early}} - A_{\\text{late}}$，其中 $A_{\\text{early}}$ 和 $A_{\\text{late}}$ 分别是较早和较晚时间点下的期望依从性概率。\n\n将净效应 $\\Delta A$ 表示为一个无单位小数。将您的答案四舍五入到四位有效数字。不要使用百分号。", "solution": "本题要求我们计算两种不同警报时机下的总期望依从性，并比较其差异，以评估改变警报时机对依从性的净效应。我们将使用全概率定律来解决这个问题。\n\n#### 1. 定义事件与已知概率\n\n*   $T_L$: 警报在较晚时间触发。\n*   $T_E$: 警报在较早时间触发。\n*   $R_P$: 警报被路由给开单医生。\n*   $R_N$: 警报被路由给分诊护士。\n*   $A$: 接收者依从推荐。\n\n根据题意，我们有以下条件概率：\n*   较晚时间点的路由概率：$P(R_P | T_L) = 0.95$, $P(R_N | T_L) = 0.05$\n*   较晚时间点的条件依从性：$P(A | R_P \\cap T_L) = 0.48$, $P(A | R_N \\cap T_L) = 0.15$\n*   较早时间点的路由概率：$P(R_P | T_E) = 0.30$, $P(R_N | T_E) = 0.70$\n*   较早时间点的条件依从性：$P(A | R_P \\cap T_E) = 0.62$, $P(A | R_N \\cap T_E) = 0.25$\n\n#### 2. 计算较晚时间的期望依从性 ($A_{\\text{late}}$)\n\n根据全概率定律，总依从性是警报路由给医生并被依从的概率，与警报路由给护士并被依从的概率之和。\n$$A_{\\text{late}} = P(A | T_L) = P(A | R_P \\cap T_L) P(R_P | T_L) + P(A | R_N \\cap T_L) P(R_N | T_L)$$\n代入数值：\n$$A_{\\text{late}} = (0.48)(0.95) + (0.15)(0.05)$$\n$$A_{\\text{late}} = 0.456 + 0.0075 = 0.4635$$\n\n#### 3. 计算较早时间的期望依从性 ($A_{\\text{early}}$)\n\n使用同样的方法计算较早时间点的期望依从性：\n$$A_{\\text{early}} = P(A | T_E) = P(A | R_P \\cap T_E) P(R_P | T_E) + P(A | R_N \\cap T_E) P(R_N | T_E)$$\n代入数值：\n$$A_{\\text{early}} = (0.62)(0.30) + (0.25)(0.70)$$\n$$A_{\\text{early}} = 0.186 + 0.175 = 0.361$$\n\n#### 4. 计算对依从性的净效应 ($\\Delta A$)\n\n净效应是两种依从性概率的差值：\n$$\\Delta A = A_{\\text{early}} - A_{\\text{late}}$$\n$$\\Delta A = 0.361 - 0.4635 = -0.1025$$\n\n#### 5. 最终答案\n计算出的净效应为 $-0.1025$，它已经有四位有效数字，符合题目要求。", "answer": "$$\\boxed{-0.1025}$$", "id": "4860710"}, {"introduction": "在对 CDS 的效益和权衡进行建模之后，是时候构建一个核心组件了。电子健康记录系统如何能自动确定显示警报的“正确时机”？这最后一个实践将让你扮演 EHR 开发者的角色，任务是设计一种算法，从原始事件日志流中推断临床医生的工作流程状态。这个练习弥合了抽象概念与具体实施之间的鸿沟，展示了如何将情境感知能力工程化地融入临床软件中。[@problem_id:4860764]", "problem": "您将处理一个序列建模任务，该任务基于临床决策支持（CDS）的“五个正确”原则，即CDS干预应“在工作流程中的正确时间，通过正确的渠道，以正确的干预格式，将正确的信息提供给正确的人”。从电子健康记录（EHR）事件分析的角度来看，“工作流程中的正确时间”这一维度要求检测临床医生是否正积极从事药物开立活动，以便能够显示干预措施而不会中断不相关的工作。形式上，您必须使用基于第一性原理的确定性且可复现的算法，从EHR事件日志中推断出二元的药物开立状态，然后通过计算精确率和召回率，根据带标注的真实数据验证此推断。\n\n基本原理：\n- 临床决策支持（CDS）的“五个正确”原则被视为基本约束：CDS干预必须在“工作流程中的正确时间”向“正确的人”展示。在计算术语中，这意味着状态推断应限定在正确的用户和患者上下文中，并且只应在药物开立任务期间激活。\n- 确定性有限状态自动机（DFA）：一个基于离散事件的DFA可以对工作流上下文进行建模。DFA由有限的状态集合和基于事件的确定性转换组成。这在计算机科学中被广泛接受用于对交互序列进行建模。\n- 信息检索指标：精确率和召回率定义在预测正例和实际正例的集合上。设 $\\mathrm{TP}$ 表示真阳性，$\\mathrm{FP}$ 表示假阳性，$\\mathrm{FN}$ 表示假阴性。则精确率为 $\\mathrm{precision} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}$，召回率为 $\\mathrm{recall} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}$。如果分母为 $0$，按照惯例将相应的指标定义为 $1$，以避免出现未定义的值，同时保持相对于错误的单调行为。\n\n任务：\n1. 构建一个确定性的上下文检测算法，该算法为每个事件标记药物开立上下文在那个时刻对于元组 $(\\text{user}, \\text{patient})$ 是否处于活动状态。使用一个DFA，其状态包括一个基准的非活动状态和至少一个表示药物医嘱组合的活动状态。该DFA必须：\n   - 为每个 $(\\text{user}, \\text{patient})$ 对维护独立的上下文，以满足“正确的人”约束。\n   - 在确定性地指示进入医嘱组合的事件上激活（例如，打开医嘱编辑器）。\n   - 在涉及医嘱录入步骤的事件上保持活动状态（例如，输入剂量或途径，添加到购物车）。\n   - 在确定性地终止组合的事件上停用（例如，签署医嘱，取消，关闭医嘱编辑器）。\n   - 在某个用户切换患者的事件发生时，立即清除该用户的所有活动上下文。\n   - 当且仅当其 $(\\text{user}, \\text{patient})$ 的医嘱上下文在处理事件转换后立即处于活动状态时，将每个事件标记为阳性（活动）。特殊情况是：终止组合的事件当且仅当上下文在终止前立即处于活动状态时，才被标记为阳性。\n\n2. 计算您的预测标签相对于每个测试用例的真实标注的 $\\mathrm{precision}$ 和 $\\mathrm{recall}$。将每个指标作为 $[0,1]$ 范围内的十进制数返回，四舍五入到 $3$ 位小数。\n\n事件：\n每个事件是一个元组 $(t, u, p, e)$，其中 $t$ 是一个整数时间戳， $u$ 是一个字符串用户标识符， $p$ 是一个字符串患者标识符， $e$ 是一个字符串事件类型。事件空间至少包括以下标记：$\\texttt{open\\_patient\\_chart}$、$\\texttt{search\\_medication}$、$\\texttt{open\\_order\\_composer}$、$\\texttt{enter\\_dose}$、$\\texttt{enter\\_route}$、$\\texttt{add\\_to\\_cart}$、$\\texttt{view\\_lab}$、$\\texttt{sign\\_orders}$、$\\texttt{cancel}$、$\\texttt{close\\_order\\_composer}$、$\\texttt{switch\\_patient}$、$\\texttt{view\\_note}$。您可以假设在每个测试用例中，事件已经按 $t$ 的升序排列。\n\n测试套件：\n为以下用例提供结果。对于每个用例，第二项是与事件位置对应的真实二元标签序列。标签 $1$ 表示开立上下文处于活动状态；标签 $0$ 表示非活动状态。\n\n- 用例 $1$（理想路径，单个用户和患者）：\n  事件：\n  $(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart})$,\n  $(2,\\texttt{U1},\\texttt{P1},\\texttt{search\\_medication})$,\n  $(3,\\texttt{U1},\\texttt{P1},\\texttt{open\\_order\\_composer})$,\n  $(4,\\texttt{U1},\\texttt{P1},\\texttt{enter\\_dose})$,\n  $(5,\\texttt{U1},\\texttt{P1},\\texttt{enter\\_route})$,\n  $(6,\\texttt{U1},\\texttt{P1},\\texttt{add\\_to\\_cart})$,\n  $(7,\\texttt{U1},\\texttt{P1},\\texttt{view\\_lab})$,\n  $(8,\\texttt{U1},\\texttt{P1},\\texttt{sign\\_orders})$,\n  $(9,\\texttt{U1},\\texttt{P1},\\texttt{view\\_lab})$.\n  真实数据：$[0,0,1,1,1,1,1,1,0]$。\n\n- 用例 $2$（无开立活动，仅噪声）：\n  事件：\n  $(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart})$,\n  $(2,\\texttt{U1},\\texttt{P1},\\texttt{view\\_lab})$,\n  $(3,\\texttt{U1},\\texttt{P1},\\texttt{view\\_note})$.\n  真实数据：$[0,0,0]$。\n\n- 用例 $3$（放弃编辑器和切换患者）：\n  事件：\n  $(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart})$,\n  $(2,\\texttt{U1},\\texttt{P1},\\texttt{open\\_order\\_composer})$,\n  $(3,\\texttt{U1},\\texttt{P1},\\texttt{enter\\_dose})$,\n  $(4,\\texttt{U1},\\texttt{P1},\\texttt{close\\_order\\_composer})$,\n  $(5,\\texttt{U1},\\texttt{P1},\\texttt{search\\_medication})$,\n  $(6,\\texttt{U1},\\texttt{P2},\\texttt{switch\\_patient})$,\n  $(7,\\texttt{U1},\\texttt{P2},\\texttt{open\\_order\\_composer})$,\n  $(8,\\texttt{U1},\\texttt{P2},\\texttt{enter\\_route})$,\n  $(9,\\texttt{U1},\\texttt{P2},\\texttt{cancel})$.\n  真实数据：$[0,1,1,1,0,0,1,1,1]$。\n\n- 用例 $4$（跨用户的交叉活动，同一患者）：\n  事件：\n  $(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_order\\_composer})$,\n  $(2,\\texttt{U2},\\texttt{P1},\\texttt{open\\_patient\\_chart})$,\n  $(3,\\texttt{U1},\\texttt{P1},\\texttt{enter\\_dose})$,\n  $(4,\\texttt{U2},\\texttt{P1},\\texttt{search\\_medication})$,\n  $(5,\\texttt{U2},\\texttt{P1},\\texttt{open\\_order\\_composer})$,\n  $(6,\\texttt{U1},\\texttt{P1},\\texttt{sign\\_orders})$,\n  $(7,\\texttt{U2},\\texttt{P1},\\texttt{enter\\_route})$,\n  $(8,\\texttt{U2},\\texttt{P1},\\texttt{sign\\_orders})$.\n  真实数据：$[1,0,1,0,1,1,1,1]$。\n\n- 用例 $5$（缺少编辑器打开事件，人工标注的开立活动）：\n  事件：\n  $(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart})$,\n  $(2,\\texttt{U1},\\texttt{P1},\\texttt{search\\_medication})$,\n  $(3,\\texttt{U1},\\texttt{P1},\\texttt{enter\\_dose})$,\n  $(4,\\texttt{U1},\\texttt{P1},\\texttt{enter\\_route})$,\n  $(5,\\texttt{U1},\\texttt{P1},\\texttt{add\\_to\\_cart})$,\n  $(6,\\texttt{U1},\\texttt{P1},\\texttt{sign\\_orders})$.\n  真实数据：$[0,0,1,1,1,1]$。\n\n- 用例 $6$（虚假的编辑器打开事件，立即取消）：\n  事件：\n  $(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart})$,\n  $(2,\\texttt{U1},\\texttt{P1},\\texttt{open\\_order\\_composer})$,\n  $(3,\\texttt{U1},\\texttt{P1},\\texttt{cancel})$.\n  真实数据：$[0,0,0]$。\n\n输出规范：\n- 对于每个用例，计算 $\\mathrm{precision}$ 和 $\\mathrm{recall}$，作为 $[0,1]$ 范围内的十进制数，四舍五入到 $3$ 位小数。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为：$[\\text{precision}_{1},\\text{recall}_{1},\\text{precision}_{2},\\text{recall}_{2},\\ldots]$，适用于所有用例。", "solution": "此任务要求我们实现一个确定性有限状态自动机（DFA）来推断药物开立的工作流状态，并根据真实数据评估其性能。\n\n### 算法设计\n\n我们设计一个DFA，为每个 $(\\text{user}, \\text{patient})$ 上下文维护一个独立的状态（`INACTIVE` 或 `ACTIVE`）。\n*   **状态**：用一个字典 `contexts` 存储，键为 `(user, patient)`，值为状态 `0` (INACTIVE) 或 `1` (ACTIVE)。\n*   **状态转换规则**:\n    *   **激活事件**: $E_{\\text{activate}} = \\{\\texttt{open\\_order\\_composer}\\}$。当此类事件发生时，状态变为 `ACTIVE`。\n    *   **终止事件**: $E_{\\text{terminate}} = \\{\\texttt{sign\\_orders}, \\texttt{cancel}, \\texttt{close\\_order\\_composer}\\}$。当此类事件发生时，状态变为 `INACTIVE`。\n    *   **上下文重置**: 事件 `switch_patient` 会将该用户的所有上下文重置为 `INACTIVE`。\n    *   **中性事件**: 其他事件不改变状态。\n*   **标签预测规则**:\n    *   对于终止事件，其标签是事件发生*前*的状态。\n    *   对于所有其他事件，其标签是事件发生*后*的状态。\n\n### 性能评估\n\n根据预测标签和真实标签，我们计算真阳性（TP）、假阳性（FP）和假阴性（FN）的数量，然后使用以下公式计算精确率（Precision）和召回率（Recall）：\n*   $\\text{Precision} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}$\n*   $\\text{Recall} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}$\n*   如果分母为0，则指标按惯例设为1.0。\n\n### 算法实现与评估\n我们按照上述逻辑，为每个测试用例逐步推导预测标签，并计算其性能指标。以下是实现该算法的Python代码，用于生成最终结果。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a DFA-based context detection algorithm for medication ordering,\n    evaluates it against ground truth, and computes precision and recall.\n    \"\"\"\n    test_cases = [\n        {\n            \"events\": [\n                (1, 'U1', 'P1', 'open_patient_chart'),\n                (2, 'U1', 'P1', 'search_medication'),\n                (3, 'U1', 'P1', 'open_order_composer'),\n                (4, 'U1', 'P1', 'enter_dose'),\n                (5, 'U1', 'P1', 'enter_route'),\n                (6, 'U1', 'P1', 'add_to_cart'),\n                (7, 'U1', 'P1', 'view_lab'),\n                (8, 'U1', 'P1', 'sign_orders'),\n                (9, 'U1', 'P1', 'view_lab'),\n            ],\n            \"ground_truth\": [0, 0, 1, 1, 1, 1, 1, 1, 0]\n        },\n        {\n            \"events\": [\n                (1, 'U1', 'P1', 'open_patient_chart'),\n                (2, 'U1', 'P1', 'view_lab'),\n                (3, 'U1', 'P1', 'view_note'),\n            ],\n            \"ground_truth\": [0, 0, 0]\n        },\n        {\n            \"events\": [\n                (1, 'U1', 'P1', 'open_patient_chart'),\n                (2, 'U1', 'P1', 'open_order_composer'),\n                (3, 'U1', 'P1', 'enter_dose'),\n                (4, 'U1', 'P1', 'close_order_composer'),\n                (5, 'U1', 'P1', 'search_medication'),\n                (6, 'U1', 'P2', 'switch_patient'),\n                (7, 'U1', 'P2', 'open_order_composer'),\n                (8, 'U1', 'P2', 'enter_route'),\n                (9, 'U1', 'P2', 'cancel'),\n            ],\n            \"ground_truth\": [0, 1, 1, 1, 0, 0, 1, 1, 1]\n        },\n        {\n            \"events\": [\n                (1, 'U1', 'P1', 'open_order_composer'),\n                (2, 'U2', 'P1', 'open_patient_chart'),\n                (3, 'U1', 'P1', 'enter_dose'),\n                (4, 'U2', 'P1', 'search_medication'),\n                (5, 'U2', 'P1', 'open_order_composer'),\n                (6, 'U1', 'P1', 'sign_orders'),\n                (7, 'U2', 'P1', 'enter_route'),\n                (8, 'U2', 'P1', 'sign_orders'),\n            ],\n            \"ground_truth\": [1, 0, 1, 0, 1, 1, 1, 1]\n        },\n        {\n            \"events\": [\n                (1, 'U1', 'P1', 'open_patient_chart'),\n                (2, 'U1', 'P1', 'search_medication'),\n                (3, 'U1', 'P1', 'enter_dose'),\n                (4, 'U1', 'P1', 'enter_route'),\n                (5, 'U1', 'P1', 'add_to_cart'),\n                (6, 'U1', 'P1', 'sign_orders'),\n            ],\n            \"ground_truth\": [0, 0, 1, 1, 1, 1]\n        },\n        {\n            \"events\": [\n                (1, 'U1', 'P1', 'open_patient_chart'),\n                (2, 'U1', 'P1', 'open_order_composer'),\n                (3, 'U1', 'P1', 'cancel'),\n            ],\n            \"ground_truth\": [0, 0, 0]\n        }\n    ]\n\n    all_results = []\n    \n    ACTIVATION_EVENTS = {'open_order_composer'}\n    TERMINATION_EVENTS = {'sign_orders', 'cancel', 'close_order_composer'}\n    INACTIVE, ACTIVE = 0, 1\n\n    for case in test_cases:\n        events = case[\"events\"]\n        ground_truth = case[\"ground_truth\"]\n        \n        contexts = {}  # (user, patient) -> state\n        predicted_labels = []\n\n        for _, user, patient, event_type in events:\n            context_key = (user, patient)\n            state_before = contexts.get(context_key, INACTIVE)\n            \n            # Special rule for switch_patient\n            if event_type == 'switch_patient':\n                # Invalidate all of the user's sessions\n                for key in list(contexts.keys()):\n                    if key[0] == user:\n                        contexts[key] = INACTIVE\n            \n            # Determine state transition\n            if event_type in ACTIVATION_EVENTS:\n                state_after = ACTIVE\n            elif event_type in TERMINATION_EVENTS:\n                state_after = INACTIVE\n            else:\n                state_after = state_before\n\n            # Determine label based on problem rules\n            if event_type in TERMINATION_EVENTS:\n                label = state_before\n            else:\n                label = state_after\n            \n            predicted_labels.append(label)\n            \n            # Update context state\n            contexts[context_key] = state_after\n\n        # Calculate metrics\n        tp = sum(1 for p, g in zip(predicted_labels, ground_truth) if p == 1 and g == 1)\n        fp = sum(1 for p, g in zip(predicted_labels, ground_truth) if p == 1 and g == 0)\n        fn = sum(1 for p, g in zip(predicted_labels, ground_truth) if p == 0 and g == 1)\n\n        # Calculate precision\n        if (tp + fp) == 0:\n            precision = 1.0\n        else:\n            precision = tp / (tp + fp)\n\n        # Calculate recall\n        if (tp + fn) == 0:\n            recall = 1.0\n        else:\n            recall = tp / (tp + fn)\n        \n        # Round and append results\n        all_results.append(round(precision, 3))\n        all_results.append(round(recall, 3))\n\n    # Format output as a single string\n    formatted_results = [f\"{r:.3f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n```", "answer": "[1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,0.000,0.000,1.000]", "id": "4860764"}]}