{"hands_on_practices": [{"introduction": "在临床信息学中，设计安全的工具至关重要，尤其是在化疗等高风险领域。失效模式与影响分析 (FMEA) 是一种系统化的前瞻性方法，用于在潜在风险对患者造成伤害之前识别并缓解这些风险。本练习 [@problem_id:4850352] 将引导您应用 FMEA 框架，通过计算风险优先数 ($RPN$) 来量化和优先处理化疗医嘱集中的潜在故障点，这正是临床信息学家确保患者安全的核心技能之一。", "problem": "一家医院正在一个疾病特异性临床路径中，通过计算机化医嘱录入系统（CPOE）在电子健康记录（EHR）内部署标准化的化疗医嘱集。为了主动识别和减轻风险，信息学团队进行了一次失效模式与效应分析（FMEA）。在 FMEA 中，严重性（Severity, $S$）、发生率（Occurrence, $O$）和可探测性（Detection, $D$）均按从 $1$（最佳）到 $10$（最差）的顺序量表进行评级，其中较高的 $S$ 表示更严重的临床危害，较高的 $O$ 表示更频繁的发生，较高的 $D$ 表示较低的可探测性。风险优先级数（RPN）将使用 FMEA 的标准方法来确定。\n\n考虑在化疗医嘱集和路径中识别出的以下六种失效模式：\n\n- 失效模式 $1$ (FM$1$)：因缺少身高信息导致体表面积（BSA）计算错误。评级：$S=9$, $O=4$, $D=6$。\n- 失效模式 $2$ (FM$2$)：同一周期内出现重复的化疗医嘱。评级：$S=8$, $O=5$, $D=5$。\n- 失效模式 $3$ (FM$3$)：高致吐性化疗方案中遗漏了止吐预防用药。评级：$S=7$, $O=6$, $D=4$。\n- 失效模式 $4$ (FM$4$)：当估算肾小球滤过率（eGFR）较低时，未应用肾脏剂量调整。评级：$S=9$, $O=3$, $D=7$。\n- 失效模式 $5$ (FM$5$)：给药说明中的输液速率配置错误。评级：$S=8$, $O=3$, $D=6$。\n- 失效模式 $6$ (FM$6$)：单克隆抗体输注前遗漏了超敏反应预处理用药。评级：$S=6$, $O=5$, $D=5$。\n\n任务：\n\n$1.$ 使用失效模式与效应分析框架，计算每种失效模式的风险优先级数，并根据 RPN 识别出排名最高的三种失效模式。\n\n$2.$ 团队针对排名最高的三种失效模式实施了信息学缓解措施，其可量化效果定义如下：\n- 对于 FM$1$：医嘱集中的一个强制功能要求在计算和提交剂量前必须输入身高和体重；这将发生率评级降低 $2$ 分，并将可探测性评级降低 $3$ 分。\n- 对于 FM$2$：一个硬停止的临床决策支持（CDS）规则可防止在同一周期内提交重复的化疗医嘱；这将发生率评级降低 $3$ 分，并将可探测性评级降低 $4$ 分。\n- 对于 FM$4$：路径中与实时 eGFR 更新相关联的自动肾脏剂量调整提示；这将发生率评级降低 $1$ 分，并将可探测性评级降低 $3$ 分。\n\n假设缓解措施不改变严重性（$S$ 保持不变），并且更新后的评级使用公式 $O_{\\text{new}}=\\max(1, O-\\Delta O)$ 和 $D_{\\text{new}}=\\max(1, D-\\Delta D)$，以 $1$ 为下限。为已采取缓解措施的失效模式重新计算新的 RPN。\n\n$3.$ 在对 FM$1$、FM$2$ 和 FM$4$ 应用这些缓解措施，同时保持 FM$3$、FM$5$ 和 FM$6$ 不变后，确定所有六种失效模式的总风险优先级数降低值，其定义为初始 RPN 总和减去缓解后 RPN 总和。\n\n请以单个整数的形式提供最终答案（无单位）。除精确整数运算外，无需进行四舍五- 入。", "solution": "该问题要求系统地应用失效模式与效应分析（FMEA）方法，以评估和比较与化疗医嘱集相关的风险。该过程涉及计算风险优先级数（RPN）、识别高风险失效模式、在采取缓解措施后重新评估 RPN，以及量化总风险降低值。\n\n首先，必须验证问题的有效性。\n\n**步骤 1：提取已知条件**\n- FMEA 方法学：严重性 ($S$)、发生率 ($O$) 和可探测性 ($D$) 按从 $1$ 到 $10$ 的量表进行评级。\n- 风险优先级数（RPN）将使用标准方法确定。标准公式为 RPN $= S \\times O \\times D$。\n- 失效模式 $1$ (FM$1$)：初始评级 $S_1=9$, $O_1=4$, $D_1=6$。\n- 失效模式 $2$ (FM$2$)：初始评级 $S_2=8$, $O_2=5$, $D_2=5$。\n- 失效模式 $3$ (FM$3$)：初始评级 $S_3=7$, $O_3=6$, $D_3=4$。\n- 失效模式 $4$ (FM$4$)：初始评级 $S_4=9$, $O_4=3$, $D_4=7$。\n- 失效模式 $5$ (FM$5$)：初始评级 $S_5=8$, $O_5=3$, $D_5=6$。\n- 失效模式 $6$ (FM$6$)：初始评级 $S_6=6$, $O_6=5$, $D_6=5$。\n- 缓解后变化：\n  - 对于 FM$1$：$\\Delta O = 2$, $\\Delta D = 3$。\n  - 对于 FM$2$：$\\Delta O = 3$, $\\Delta D = 4$。\n  - 对于 FM$4$：$\\Delta O = 1$, $\\Delta D = 3$。\n- 假设：所有失效模式的严重性 ($S$) 保持不变。\n- 新评级规则：$O_{\\text{new}}=\\max(1, O-\\Delta O)$ 和 $D_{\\text{new}}=\\max(1, D-\\Delta D)$。\n- 目标：计算总 RPN 降低值，定义为 $\\sum \\text{RPN}_{\\text{initial}} - \\sum \\text{RPN}_{\\text{post-mitigation}}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题陈述具有科学依据、定义明确且客观。\n- **科学依据**：该问题在真实的医疗信息学背景下使用了标准的 FMEA 方法学（RPN $= S \\times O \\times D$）。所描述的失效模式是化疗给药中可能存在的真实风险。\n- **定义明确**：该问题提供了执行所需计算的所有必要数据和定义。任务规定清晰，评级更新规则明确，可得出唯一解。\n- **客观性**：问题以精确、定量的术语陈述，没有主观性语言。\n\n**步骤 3：结论与行动**\n该问题有效。将提供完整解答。\n\n**任务 1：初始 RPN 计算与排名**\n每种失效模式的 RPN 计算为其严重性、发生率和可探测性评级的乘积：RPN $= S \\times O \\times D$。\n\n对于 FM$1$：\n$\\text{RPN}_1 = S_1 \\times O_1 \\times D_1 = 9 \\times 4 \\times 6 = 216$\n\n对于 FM$2$：\n$\\text{RPN}_2 = S_2 \\times O_2 \\times D_2 = 8 \\times 5 \\times 5 = 200$\n\n对于 FM$3$：\n$\\text{RPN}_3 = S_3 \\times O_3 \\times D_3 = 7 \\times 6 \\times 4 = 168$\n\n对于 FM$4$：\n$\\text{RPN}_4 = S_4 \\times O_4 \\times D_4 = 9 \\times 3 \\times 7 = 189$\n\n对于 FM$5$：\n$\\text{RPN}_5 = S_5 \\times O_5 \\times D_5 = 8 \\times 3 \\times 6 = 144$\n\n对于 FM$6$：\n$\\text{RPN}_6 = S_6 \\times O_6 \\times D_6 = 6 \\times 5 \\times 5 = 150$\n\n按初始 RPN 从高到低对失效模式进行排名：\n$1$. FM$1$: $\\text{RPN}_1 = 216$\n$2$. FM$2$: $\\text{RPN}_2 = 200$\n$3$. FM$4$: $\\text{RPN}_4 = 189$\n$4$. FM$3$: $\\text{RPN}_3 = 168$\n$5$. FM$6$: $\\text{RPN}_6 = 150$\n$6$. FM$5$: $\\text{RPN}_5 = 144$\n\n排名最高的三种失效模式是 FM$1$、FM$2$ 和 FM$4$。\n\n**任务 2：缓解后 RPN 计算**\n对 FM$1$、FM$2$ 和 FM$4$ 采取了缓解措施。我们计算这些模式的新评级和 RPN。FM$3$、FM$5$ 和 FM$6$ 的评级保持不变。所有模式的严重性 ($S$) 均保持不变。\n\n对于 FM$1$（已缓解）：\n- 初始评级：$S_1 = 9$, $O_1 = 4$, $D_1 = 6$。\n- 变化：$\\Delta O = 2$, $\\Delta D = 3$。\n- 新评级：\n  $O_{1, \\text{new}} = \\max(1, O_1 - \\Delta O) = \\max(1, 4 - 2) = 2$\n  $D_{1, \\text{new}} = \\max(1, D_1 - \\Delta D) = \\max(1, 6 - 3) = 3$\n- 新 RPN：$\\text{RPN}_{1, \\text{new}} = S_1 \\times O_{1, \\text{new}} \\times D_{1, \\text{new}} = 9 \\times 2 \\times 3 = 54$\n\n对于 FM$2$（已缓解）：\n- 初始评级：$S_2 = 8$, $O_2 = 5$, $D_2 = 5$。\n- 变化：$\\Delta O = 3$, $\\Delta D = 4$。\n- 新评级：\n  $O_{2, \\text{new}} = \\max(1, O_2 - \\Delta O) = \\max(1, 5 - 3) = 2$\n  $D_{2, \\text{new}} = \\max(1, D_2 - \\Delta D) = \\max(1, 5 - 4) = 1$\n- 新 RPN：$\\text{RPN}_{2, \\text{new}} = S_2 \\times O_{2, \\text{new}} \\times D_{2, \\text{new}} = 8 \\times 2 \\times 1 = 16$\n\n对于 FM$4$（已缓解）：\n- 初始评级：$S_4 = 9$, $O_4 = 3$, $D_4 = 7$。\n- 变化：$\\Delta O = 1$, $\\Delta D = 3$。\n- 新评级：\n  $O_{4, \\text{new}} = \\max(1, O_4 - \\Delta O) = \\max(1, 3 - 1) = 2$\n  $D_{4, \\text{new}} = \\max(1, D_4 - \\Delta D) = \\max(1, 7 - 3) = 4$\n- 新 RPN：$\\text{RPN}_{4, \\text{new}} = S_4 \\times O_{4, \\text{new}} \\times D_{4, \\text{new}} = 9 \\times 2 \\times 4 = 72$\n\n未采取缓解措施的失效模式的新 RPN 与其初始值相同：\n$\\text{RPN}_{3, \\text{new}} = \\text{RPN}_3 = 168$\n$\\text{RPN}_{5, \\text{new}} = \\text{RPN}_5 = 144$\n$\\text{RPN}_{6, \\text{new}} = \\text{RPN}_6 = 150$\n\n**任务 3：总 RPN 降低值**\n总 RPN 降低值是初始 RPN 总和与缓解后 RPN 总和之间的差值。\n\n初始 RPN 总和：\n$$ \\sum \\text{RPN}_{\\text{initial}} = \\text{RPN}_1 + \\text{RPN}_2 + \\text{RPN}_3 + \\text{RPN}_4 + \\text{RPN}_5 + \\text{RPN}_6 $$\n$$ \\sum \\text{RPN}_{\\text{initial}} = 216 + 200 + 168 + 189 + 144 + 150 = 1067 $$\n\n缓解后 RPN 总和：\n$$ \\sum \\text{RPN}_{\\text{new}} = \\text{RPN}_{1, \\text{new}} + \\text{RPN}_{2, \\text{new}} + \\text{RPN}_{3, \\text{new}} + \\text{RPN}_{4, \\text{new}} + \\text{RPN}_{5, \\text{new}} + \\text{RPN}_{6, \\text{new}} $$\n$$ \\sum \\text{RPN}_{\\text{new}} = 54 + 16 + 168 + 72 + 144 + 150 = 604 $$\n\n总 RPN 降低值：\n$$ \\Delta \\text{RPN}_{\\text{total}} = \\sum \\text{RPN}_{\\text{initial}} - \\sum \\text{RPN}_{\\text{new}} $$\n$$ \\Delta \\text{RPN}_{\\text{total}} = 1067 - 604 = 463 $$\n\n所有六种失效模式的风险优先级数总降低值为 $463$。", "answer": "$$\n\\boxed{463}\n$$", "id": "4850352"}, {"introduction": "为了使临床路径在电子健康记录 (EHR) 系统中真正发挥作用，其内在的决策逻辑必须被精确地转化为计算机可执行的格式。HL7 FHIR 和临床质量语言 (CQL) 正是实现这一目标的关键标准，它们能够将复杂的临床指南形式化。本练习 [@problem_id:4850346] 的核心挑战在于确保编码逻辑完美保留原始临床意图——即实现“语义保持映射”，您将通过编写程序来验证一系列临床场景下的逻辑一致性。", "problem": "您的任务是形式化并验证一个从脓毒症复苏临床路径到可执行逻辑的语义保持映射，该逻辑基于 Health Level Seven Fast Healthcare Interoperability Resources (HL7 FHIR) 的 PlanDefinition 和 ActivityDefinition，其决策逻辑由 Clinical Quality Language (CQL) 表示。核心路径包括必须编码为有向无环图的决策节点和活动节点，并映射为对动态值集进行的布尔条件和集合成员资格检查。您将实现一个程序，针对一个小型测试套件，比较原生路径语义与其 CQL 映射的对应部分。\n\n基本基础：\n- 临床路径和医嘱集可表示为有向无环图 (DAG)，其中决策节点评估关于患者状态的谓词，活动节点表示可开具医嘱的操作。节点评估在数学意义上是一个从结构化输入到布尔输出的函数，用于确定是否指示该操作。\n- 布尔代数运算（$\\land$、$\\lor$、$\\lnot$）、集合成员资格（$\\in$）和关系运算符（$$、$\\le$、$\\ge$、$=$）为决策节点提供了评估语义。\n- 语义保持的映射要求，对于任何患者状态，原生决策评估和映射后的 CQL 评估为每个活动节点产生相同的布尔输出。\n\n临床路径规范（简化和形式化）：\n- 变量：\n  - $MAP$ 是平均动脉压，单位为毫米汞柱 (mmHg)。\n  - $L_{0}$ 是初始乳酸值，单位为毫摩尔/升 (mmol/L)。\n  - $I$ 是一个布尔值，指示是否疑似感染。\n  - $\\Delta t_{hypo}$ 是自低血压发作以来的时间，单位为分钟。\n  - $O_{abx}$ 是一个先前下达的抗生素医嘱的有限元组列表 $(code, \\Delta t)$，其中 $code$ 是一个字符串，$\\Delta t$ 是自医嘱下达以来的分钟数。\n  - $O_{labs}$ 是一个先前下达的检验医嘱的有限元组列表 $(code, \\Delta t)$，其中 $code$ 是一个字符串，$\\Delta t$ 是自医嘱下达以来的分钟数。\n  - $VS_{abx}$ 是已识别的抗生素医嘱代码的动态值集。\n  - $VS_{crys}$ 是已识别的晶体液医嘱代码的动态值集（用于选择，而非决策）。\n  - $VS_{labs}$ 是已识别的乳酸检验医嘱代码的动态值集。\n- 操作与原生决策语义：\n  - 操作 $A_{fluid}$ (开始晶体液推注)：适用条件为 $MAP  65 \\lor L_{0} \\ge 4$。\n  - 操作 $A_{abx}$ (开具广谱抗生素医嘱)：适用条件为 $I = \\text{true} \\land \\Delta t_{hypo} \\ge 0 \\land \\lnot (\\exists (code, \\Delta t) \\in O_{abx} \\text{ s.t. } code \\in VS_{abx} \\land \\Delta t \\le 180)$。\n  - 操作 $A_{lactate}$ (重新测量乳酸)：适用条件为 $L_{0} \\ge 2 \\land \\lnot (\\exists (code, \\Delta t) \\in O_{labs} \\text{ s.t. } code \\in VS_{labs} \\land \\Delta t \\le 120)$。\n- 单位与阈值：\n  - $MAP$ 以 mmHg 表示，$L_{0}$ 以 mmol/L 表示，所有时间以分钟表示。阈值对于 $L_{0} \\ge 4$ 和 $L_{0} \\ge 2$ 是包含性的，对于 $MAP  65$ 是严格小于，在测试近期医嘱是否存在时对于 $\\Delta t \\le 180$ 和 $\\Delta t \\le 120$ 是包含性的。\n\nCQL 映射的决策语义（概念性，使用相同的基本基础）：\n- CQL 映射使用布尔合取和析取、比较以及对动态值集的集合成员资格来镜像原生语义。例如，$A_{abx}$ 映射到条件 $I \\land (\\Delta t_{hypo} \\ge 0) \\land \\lnot \\text{Exists}\\big(\\text{Order} \\in O_{abx} : (\\text{Order}.code \\in VS_{abx}) \\land (\\text{Order}.\\Delta t \\le 180)\\big)$，对于 $A_{fluid}$ 和 $A_{lactate}$ 也有类似的形式。\n\n您的任务是实现一个程序，对于每个测试用例，使用原生语义和映射后的 CQL 语义评估这三个决策，并返回一个布尔值，指示在该用例中每个操作的结果是否相同（语义保持）。最终输出必须是单行，包含一个方括号括起来的、逗号分隔的布尔值列表，对应每个测试用例。\n\n测试套件：\n提供以下患者参数集和动态值集。对于每个用例，计算两种语义下每个操作的布尔值，并为每个用例返回一个等于各操作等价性合取的单一布尔值。\n\n- 用例 $1$ (理想路径，所有操作均被指示)：\n  - $MAP = 58$ mmHg, $L_{0} = 4.6$ mmol/L, $I = \\text{true}$, $\\Delta t_{hypo} = 30$ 分钟。\n  - $O_{abx} = [\\,]$, $O_{labs} = [\\,]$。\n  - $VS_{abx} = \\{\\text{\"ABX\\_A\"}, \\text{\"ABX\\_B\"}\\}$, $VS_{crys} = \\{\\text{\"CRYS\\_1\"}, \\text{\"CRYS\\_2\"}\\}$, $VS_{labs} = \\{\\text{\"LACTATE\\_REMEASURE\"}\\}$。\n- 用例 $2$ (边界 $MAP$，阈值内的先前抗生素，乳酸边界)：\n  - $MAP = 65$ mmHg, $L_{0} = 2.0$ mmol/L, $I = \\text{true}$, $\\Delta t_{hypo} = 45$ 分钟。\n  - $O_{abx} = [(\\text{\"ABX\\_B\"}, 120)]$, $O_{labs} = [\\,]$。\n  - $VS_{abx} = \\{\\text{\"ABX\\_A\"}, \\text{\"ABX\\_B\"}\\}$, $VS_{crys} = \\{\\text{\"CRYS\\_1\"}\\}$, $VS_{labs} = \\{\\text{\"LACTATE\\_REMEASURE\"}\\}$。\n- 用例 $3$ (无指示，值集中包含新的抗生素代码)：\n  - $MAP = 72$ mmHg, $L_{0} = 1.8$ mmol/L, $I = \\text{false}$, $\\Delta t_{hypo} = 0$ 分钟。\n  - $O_{abx} = [(\\text{\"ABX\\_C\"}, 200)]$, $O_{labs} = [(\\text{\"LACTATE\\_REMEASURE\"}, 300)]$.\n  - $VS_{abx} = \\{\\text{\"ABX\\_A\"}, \\text{\"ABX\\_B\"}, \\text{\"ABX\\_C\"}\\}$, $VS_{crys} = \\{\\text{\"CRYS\\_2\"}\\}$, $VS_{labs} = \\{\\text{\"LACTATE\\_REMEASURE\"}\\}$。\n- 用例 $4$ (先前抗生素的动态值集不匹配，指示补液)：\n  - $MAP = 60$ mmHg, $L_{0} = 2.5$ mmol/L, $I = \\text{true}$, $\\Delta t_{hypo} = 15$ 分钟。\n  - $O_{abx} = [(\\text{\"ABX\\_X\"}, 60)]$, $O_{labs} = [\\,]$。\n  - $VS_{abx} = \\{\\text{\"ABX\\_A\"}\\}$, $VS_{crys} = \\{\\text{\"CRYS\\_1\"}\\}$, $VS_{labs} = \\{\\text{\"LACTATE\\_REMEASURE\"}\\}$。\n- 用例 $5$ (因近期检验而抑制乳酸复测)：\n  - $MAP = 66$ mmHg, $L_{0} = 2.0$ mmol/L, $I = \\text{true}$, $\\Delta t_{hypo} = 10$ 分钟。\n  - $O_{abx} = [\\,]$, $O_{labs} = [(\\text{\"LACTATE\\_REMEASURE\"}, 100)]$.\n  - $VS_{abx} = \\{\\text{\"ABX\\_A\"}, \\text{\"ABX\\_B\"}\\}$, $VS_{crys} = \\{\\text{\"CRYS\\_3\"}\\}$, $VS_{labs} = \\{\\text{\"LACTATE\\_REMEASURE\"}\\}$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个方括号括起来的、逗号分隔的结果列表（例如，$[result1,result2,result3]$）。每个元素必须是一个布尔值，指示在该用例中，原生评估和 CQL 映射评估对于所有三个操作是否相同。不应打印任何其他文本。", "solution": "我们从适用于医学信息学中临床路径的基本原则开始。临床路径可以表示为一个有向无环图，其中决策节点根据患者状态评估谓词，活动节点表示医嘱。评估语义源于经典的布尔代数和集合论。我们将决策节点形式化为函数 $f : \\mathcal{S} \\to \\{\\text{true}, \\text{false}\\}$，其中 $\\mathcal{S}$ 是结构化的患者和环境状态。决策通过 $\\land$、$\\lor$ 和 $\\lnot$ 组合原子比较和集合成员资格。\n\n我们用其原生决策语义编码三个操作：\n- 如果 $MAP  65 \\lor L_{0} \\ge 4$，则指示 $A_{fluid}$。这是关系运算符和逻辑析取的直接应用。\n- 如果 $I = \\text{true} \\land \\Delta t_{hypo} \\ge 0 \\land \\lnot (\\exists (code, \\Delta t) \\in O_{abx} \\text{ s.t. } code \\in VS_{abx} \\land \\Delta t \\le 180)$，则指示 $A_{abx}$。这使用了逻辑合取和受集合成员资格及时间阈值约束的否定存在量词。\n- 如果 $L_{0} \\ge 2 \\land \\lnot (\\exists (code, \\Delta t) \\in O_{labs} \\text{ s.t. } code \\in VS_{labs} \\land \\Delta t \\le 120)$，则指示 $A_{lactate}$。\n\nClinical Quality Language (CQL) 映射依赖于相同的原语。例如，抗生素标准映射到 $I \\land (\\Delta t_{hypo} \\ge 0) \\land \\lnot \\text{Exists}\\big(\\text{Order} \\in O_{abx} : (\\text{Order}.code \\in VS_{abx}) \\land (\\text{Order}.\\Delta t \\le 180)\\big)$。补液标准映射到 $(MAP  65) \\lor (L_{0} \\ge 4)$。乳酸复测标准映射到 $(L_{0} \\ge 2) \\land \\lnot \\text{Exists}\\big(\\text{Order} \\in O_{labs} : (\\text{Order}.code \\in VS_{labs}) \\land (\\text{Order}.\\Delta t \\le 120)\\big)$。因为这些映射使用相同的基础布尔和关系逻辑以及集合成员资格，只要动态值集 $VS_{abx}$ 和 $VS_{labs}$ 被一致应用，它们在理论上是语义保持的。\n\n算法设计：\n1. 将每个患者病例表示为一个结构化记录，包含 $MAP$、$L_{0}$、$I$、$\\Delta t_{hypo}$、$O_{abx}$、$O_{labs}$ 以及动态值集 $VS_{abx}$、$VS_{crys}$ 和 $VS_{labs}$。\n2. 实现原生决策评估器：\n   - $native\\_fluid(MAP, L_{0}) = (MAP  65) \\lor (L_{0} \\ge 4)$。\n   - $native\\_abx(I, \\Delta t_{hypo}, O_{abx}, VS_{abx}) = I \\land (\\Delta t_{hypo} \\ge 0) \\land \\lnot \\exists (code, \\Delta t) \\in O_{abx} : (code \\in VS_{abx}) \\land (\\Delta t \\le 180)$。\n   - $native\\_lactate(L_{0}, O_{labs}, VS_{labs}) = (L_{0} \\ge 2) \\land \\lnot \\exists (code, \\Delta t) \\in O_{labs} : (code \\in VS_{labs}) \\land (\\Delta t \\le 120)$。\n3. 实现 CQL 映射的评估器，使用相同的逻辑，但在概念上构建为 CQL 语义：\n   - $cql\\_fluid(MAP, L_{0})$ 与原生逻辑相同。\n   - $cql\\_abx(I, \\Delta t_{hypo}, O_{abx}, VS_{abx})$ 与原生逻辑相同，解释为对按 $code \\in VS_{abx}$ 和 $\\Delta t \\le 180$ 筛选的医嘱进行否定存在判断。\n   - $cql\\_lactate(L_{0}, O_{labs}, VS_{labs})$ 与原生逻辑相同，解释为对按 $code \\in VS_{labs}$ 和 $\\Delta t \\le 120$ 筛选的检验进行否定存在判断。\n4. 对每个用例，在两种语义下评估所有三个操作，比较每个操作的布尔值，并返回等价性的合取。这测试了对于所提供的输入和动态值集，映射是否是语义保持的。\n\n正确性论证：\n- 鉴于原生和 CQL 映射的评估器都在相同的域 $\\mathcal{S}$ 上定义，并使用由相同基本操作构成的相同谓词，对于任何固定的 $VS_{abx}$ 和 $VS_{labs}$，两种评估为相应的操作产生相同的真值。这是因为映射是结构性的：每个原生谓词都转换为相同的布尔公式，仅在表示法上有所不同（数学与 CQL）。因此，结果的相等性得到保证，程序通过包含理想路径、边界条件（$MAP = 65$, $L_{0} = 2$）、动态值集成员资格变化（例如，包含 $\\text{\"ABX\\_C\"}$）以及值集外不匹配代码（例如，$\\text{\"ABX\\_X\"}$）的用例来展示这一点，以突显动态值集在语义保持中的重要性。\n\n边界情况论证：\n- 用例 $2$ 验证了 $MAP  65$ 的严格不等式（因为 $MAP = 65$ 不指示补液）以及乳酸复测的包含性边界 $L_{0} \\ge 2$。\n- 用例 $3$ 验证了即使在 $VS_{abx}$ 中引入了新代码 $\\text{\"ABX\\_C\"}$，由于缺乏疑似感染 $I = \\text{false}$，抗生素的使用也被抑制。\n- 用例 $4$ 显示，先前使用未识别代码 $\\text{\"ABX\\_X\"}$ 的抗生素不会抑制抗生素操作，因为 $code \\notin VS_{abx}$。\n- 用例 $5$ 演示了由于 $120$ 分钟内有近期的检验医嘱，乳酸复测被抑制。\n\n复杂度：\n- 对于每个用例，对 $O_{abx}$ 和 $O_{labs}$ 的存在性检查以 $O(n)$ 时间运行，其中 $n$ 是相应列表的大小。对于一个小型固定测试套件，总时间可以忽略不计。内存使用量为 $O(n)$，用于存储医嘱和值集。\n\n程序将组装指定的测试用例，评估原生和 CQL 映射的决策，并打印一行带有方括号、逗号分隔的布尔值列表，按要求指示每个用例的语义保持性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef native_fluid(MAP_mmHg: float, lactate_mmol_per_L: float) - bool:\n    # A_fluid: MAP  65 OR lactate >= 4\n    return (MAP_mmHg  65.0) or (lactate_mmol_per_L >= 4.0)\n\ndef native_abx(infection_suspected: bool,\n               minutes_since_hypotension_onset: float,\n               abx_orders: list,\n               vs_abx: set) - bool:\n    # A_abx: infection_suspected AND time_since_hypotension_onset >= 0\n    #        AND NOT exists recognized antibiotic order within 180 minutes\n    def exists_recent_recognized(order_list, value_set, max_minutes):\n        for code, minutes in order_list:\n            if (code in value_set) and (minutes = max_minutes):\n                return True\n        return False\n\n    return (infection_suspected\n            and (minutes_since_hypotension_onset >= 0.0)\n            and (not exists_recent_recognized(abx_orders, vs_abx, 180.0)))\n\ndef native_lactate(lactate_initial: float,\n                   lab_orders: list,\n                   vs_labs: set) - bool:\n    # A_lactate: lactate_initial >= 2 AND NOT exists recognized lactate lab within 120 minutes\n    def exists_recent_recognized(order_list, value_set, max_minutes):\n        for code, minutes in order_list:\n            if (code in value_set) and (minutes = max_minutes):\n                return True\n        return False\n\n    return (lactate_initial >= 2.0) and (not exists_recent_recognized(lab_orders, vs_labs, 120.0))\n\n# For CQL-mapped versions, we implement the same logic to reflect the CQL semantics.\ndef cql_fluid(MAP_mmHg: float, lactate_mmol_per_L: float) - bool:\n    # CQL: (MAP  65) OR (L0 >= 4)\n    return (MAP_mmHg  65.0) or (lactate_mmol_per_L >= 4.0)\n\ndef cql_abx(infection_suspected: bool,\n            minutes_since_hypotension_onset: float,\n            abx_orders: list,\n            vs_abx: set) - bool:\n    # CQL: I AND (Δt_hypo >= 0) AND NOT Exists(Order in O_abx: Order.code in VS_abx AND Order.Δt = 180)\n    recognized_recent = any(((code in vs_abx) and (minutes = 180.0))\n                            for code, minutes in abx_orders)\n    return infection_suspected and (minutes_since_hypotension_onset >= 0.0) and (not recognized_recent)\n\ndef cql_lactate(lactate_initial: float,\n                lab_orders: list,\n                vs_labs: set) - bool:\n    # CQL: (L0 >= 2) AND NOT Exists(Order in O_labs: Order.code in VS_labs AND Order.Δt = 120)\n    recognized_recent = any(((code in vs_labs) and (minutes = 120.0))\n                            for code, minutes in lab_orders)\n    return (lactate_initial >= 2.0) and (not recognized_recent)\n\ndef evaluate_case(case):\n    MAP = case[\"MAP\"]\n    L0 = case[\"L0\"]\n    I = case[\"I\"]\n    dt_hypo = case[\"dt_hypo\"]\n    O_abx = case[\"O_abx\"]\n    O_labs = case[\"O_labs\"]\n    VS_abx = case[\"VS_abx\"]\n    VS_crys = case[\"VS_crys\"]  # Not used in decision logic; included to reflect dynamic set availability\n    VS_labs = case[\"VS_labs\"]\n\n    # Native evaluations\n    n_fluid = native_fluid(MAP, L0)\n    n_abx = native_abx(I, dt_hypo, O_abx, VS_abx)\n    n_lact = native_lactate(L0, O_labs, VS_labs)\n\n    # CQL-mapped evaluations\n    c_fluid = cql_fluid(MAP, L0)\n    c_abx = cql_abx(I, dt_hypo, O_abx, VS_abx)\n    c_lact = cql_lactate(L0, O_labs, VS_labs)\n\n    # Compare per-action equality and return conjunction for the case\n    return (n_fluid == c_fluid) and (n_abx == c_abx) and (n_lact == c_lact)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"MAP\": 58.0,\n            \"L0\": 4.6,\n            \"I\": True,\n            \"dt_hypo\": 30.0,\n            \"O_abx\": [],\n            \"O_labs\": [],\n            \"VS_abx\": {\"ABX_A\", \"ABX_B\"},\n            \"VS_crys\": {\"CRYS_1\", \"CRYS_2\"},\n            \"VS_labs\": {\"LACTATE_REMEASURE\"},\n        },\n        # Case 2\n        {\n            \"MAP\": 65.0,\n            \"L0\": 2.0,\n            \"I\": True,\n            \"dt_hypo\": 45.0,\n            \"O_abx\": [(\"ABX_B\", 120.0)],\n            \"O_labs\": [],\n            \"VS_abx\": {\"ABX_A\", \"ABX_B\"},\n            \"VS_crys\": {\"CRYS_1\"},\n            \"VS_labs\": {\"LACTATE_REMEASURE\"},\n        },\n        # Case 3\n        {\n            \"MAP\": 72.0,\n            \"L0\": 1.8,\n            \"I\": False,\n            \"dt_hypo\": 0.0,\n            \"O_abx\": [(\"ABX_C\", 200.0)],\n            \"O_labs\": [(\"LACTATE_REMEASURE\", 300.0)],\n            \"VS_abx\": {\"ABX_A\", \"ABX_B\", \"ABX_C\"},\n            \"VS_crys\": {\"CRYS_2\"},\n            \"VS_labs\": {\"LACTATE_REMEASURE\"},\n        },\n        # Case 4\n        {\n            \"MAP\": 60.0,\n            \"L0\": 2.5,\n            \"I\": True,\n            \"dt_hypo\": 15.0,\n            \"O_abx\": [(\"ABX_X\", 60.0)],\n            \"O_labs\": [],\n            \"VS_abx\": {\"ABX_A\"},\n            \"VS_crys\": {\"CRYS_1\"},\n            \"VS_labs\": {\"LACTATE_REMEASURE\"},\n        },\n        # Case 5\n        {\n            \"MAP\": 66.0,\n            \"L0\": 2.0,\n            \"I\": True,\n            \"dt_hypo\": 10.0,\n            \"O_abx\": [],\n            \"O_labs\": [(\"LACTATE_REMEASURE\", 100.0)],\n            \"VS_abx\": {\"ABX_A\", \"ABX_B\"},\n            \"VS_crys\": {\"CRYS_3\"},\n            \"VS_labs\": {\"LACTATE_REMEASURE\"},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = evaluate_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "4850346"}, {"introduction": "一个智能的医嘱集不仅能简化工作流程，更关键的是能主动防范错误，例如自动检查危险的药物组合。临床本体论（Ontology）为这种智能提供了结构化的知识骨干，它以层级化的方式定义了医学概念及其关系。在这个实践 [@problem_id:4850365] 中，您将构建一个冲突检测引擎，它利用本体论知识来识别药物-药物相互作用和药物-诊断禁忌，并探索一个在现实世界中至关重要但又非常微妙的问题：规则粒度与假阳性警报之间的权衡。", "problem": "您的任务是实现一个独立的程序，该程序基于药物-药物相互作用和诊断禁忌症来检测临床医嘱集中的矛盾，同时量化由概念粒度不匹配导致的假阳性。背景设定为包含医嘱集和临床路径的医学信息学领域，该程序必须在一个简化的本体模型上运行。该问题使用适合高等本科学习的集合论和图论基础来构建。\n\n定义与基础：\n- 一个本体由一个表示药物的有根树和一个表示诊断的有根树来代表。每个概念都有一个唯一的父节点，直到唯一的根节点。设药物本体为一棵树，其节点集为 $D$，父节点函数为 $p_D:D\\rightarrow D\\cup\\{\\varnothing\\}$；诊断本体为一棵树，其节点集为 $X$，父节点函数为 $p_X:X\\rightarrow X\\cup\\{\\varnothing\\}$。根节点是父节点为 $\\varnothing$ 的概念。\n- 对于任一树中的任意概念 $c$，定义其祖先集 $A(c)$ 为包含 $c$ 及其所有祖先直至根节点的集合。形式上，如果 $p(c)$ 表示相应本体的父节点函数，则 $A(c)=\\{c, p(c), p(p(c)),\\dots\\}$，在根节点处终止，其中 $p(r)=\\varnothing$。\n- 定义一个医嘱集为一个有限的药物叶节点概念集 $M\\subset D$ 和一个有限的诊断叶节点概念集 $Y\\subset X$。\n- 定义药物-药物相互作用规则在本体层面为一个集合 $R\\subseteq D\\times D$，其中一对 $(u,v)$ 表示任何祖先包含 $u$ 和 $v$ 的药物对都应被视为相互作用。这些相互作用是对称的，因此 $(u,v)\\in R$ 意味着 $(v,u)\\in R$。\n- 定义诊断不相容规则为一个集合 $Q\\subseteq D\\times X$，其中一对 $(u,w)$ 表示祖先集包含 $u$ 的药物与祖先集包含 $w$ 的诊断不相容。\n- 定义事件级检测如下：\n  - 一个药物-药物矛盾事件是一个无序对 $\\{m_i,m_j\\}$，其中 $m_i,m_j\\in M$，$m_i\\neq m_j$。如果存在 $a\\in A(m_i)$ 和 $b\\in A(m_j)$ 使得 $(a,b)\\in R$，则该事件被标记。\n  - 一个诊断-药物矛盾事件是一个有序对 $(m_i,y_k)$，其中 $m_i\\in M$，$y_k\\in Y$。如果存在 $a\\in A(m_i)$ 和 $b\\in A(y_k)$ 使得 $(a,b)\\in Q$，则该事件被标记。\n- 所有被标记事件（药物-药物和诊断-药物）的并集是特定规则集检测到的矛盾集合。一个规则集的矛盾计数是该并集的基数（大小）。\n- 概念粒度不匹配通过代表不同粒度的两个规则集来建模：\n  - 一个在更具体概念层级上表达的细粒度规则集 $(R_{\\mathrm{fine}},Q_{\\mathrm{fine}})$。\n  - 一个在更通用概念层级上表达的粗粒度规则集 $(R_{\\mathrm{coarse}},Q_{\\mathrm{coarse}})$。\n- 对于给定的医嘱集，因粒度不匹配导致的假阳性被定义为被粗粒度规则集标记但未被细粒度规则集标记的事件。假阳性率是比率 $\\rho=\\dfrac{|E_{\\mathrm{coarse}}\\setminus E_{\\mathrm{fine}}|}{|E_{\\mathrm{coarse}}|}$，其中 $|E_{\\mathrm{coarse}}|=0$，则定义 $\\rho=0$。\n\n您的任务：\n- 实现一个程序，该程序为每个测试用例构建祖先集，应用细粒度和粗粒度规则来检测矛盾，并计算总矛盾数和因粒度不匹配导致的假阳性。\n- 该程序必须是纯逻辑和确定性的。不使用任何概率性假设。\n- 每个测试用例的最终结果必须是一个包含三个值的列表：在粗粒度规则下检测到的总矛盾数，在细粒度规则下检测到的总矛盾数，以及表示为小数并四舍五入到三位小数的假阳性率 $\\rho$。\n\n要使用的本体和规则：\n- 药物本体 $D$ 及其父节点映射 $p_D$：\n  - $p_D(\\text{Drugs})=\\varnothing$.\n  - $p_D(\\text{Analgesics})=\\text{Drugs}$.\n  - $p_D(\\text{Nonsteroidal anti-inflammatory drugs})=\\text{Analgesics}$.\n  - $p_D(\\text{Ibuprofen})=\\text{Nonsteroidal anti-inflammatory drugs}$.\n  - $p_D(\\text{Naproxen})=\\text{Nonsteroidal anti-inflammatory drugs}$.\n  - $p_D(\\text{Acetaminophen})=\\text{Analgesics}$.\n  - $p_D(\\text{Antihypertensives})=\\text{Drugs}$.\n  - $p_D(\\text{Angiotensin-converting enzyme inhibitors})=\\text{Antihypertensives}$.\n  - $p_D(\\text{Lisinopril})=\\text{Angiotensin-converting enzyme inhibitors}$.\n  - $p_D(\\text{Enalapril})=\\text{Angiotensin-converting enzyme inhibitors}$.\n  - $p_D(\\text{Angiotensin receptor blockers})=\\text{Antihypertensives}$.\n  - $p_D(\\text{Losartan})=\\text{Angiotensin receptor blockers}$.\n  - $p_D(\\text{Potassium-sparing diuretics})=\\text{Antihypertensives}$.\n  - $p_D(\\text{Spironolactone})=\\text{Potassium-sparing diuretics}$.\n- 诊断本体 $X$ 及其父节点映射 $p_X$：\n  - $p_X(\\text{Conditions})=\\varnothing$.\n  - $p_X(\\text{Gastrointestinal disorders})=\\text{Conditions}$.\n  - $p_X(\\text{Peptic ulcer disease})=\\text{Gastrointestinal disorders}$.\n  - $p_X(\\text{Renal disorders})=\\text{Conditions}$.\n  - $p_X(\\text{Chronic kidney disease})=\\text{Renal disorders}$.\n  - $p_X(\\text{Pregnancy})=\\text{Conditions}$.\n- 细粒度药物-药物相互作用 $R_{\\mathrm{fine}}$：\n  - $(\\text{Nonsteroidal anti-inflammatory drugs},\\text{Angiotensin-converting enzyme inhibitors})$.\n  - $(\\text{Angiotensin-converting enzyme inhibitors},\\text{Potassium-sparing diuretics})$.\n- 粗粒度药物-药物相互作用 $R_{\\mathrm{coarse}}$：\n  - $(\\text{Analgesics},\\text{Angiotensin-converting enzyme inhibitors})$.\n  - $(\\text{Antihypertensives},\\text{Potassium-sparing diuretics})$.\n- 细粒度诊断不相容性 $Q_{\\mathrm{fine}}$：\n  - $(\\text{Nonsteroidal anti-inflammatory drugs},\\text{Peptic ulcer disease})$.\n  - $(\\text{Angiotensin-converting enzyme inhibitors},\\text{Pregnancy})$.\n- 粗粒度诊断不相容性 $Q_{\\mathrm{coarse}}$：\n  - $(\\text{Analgesics},\\text{Gastrointestinal disorders})$.\n  - $(\\text{Antihypertensives},\\text{Pregnancy})$.\n\n测试套件：\n- 案例1（正常路径，既有真实冲突，也有因粗粒度导致的假阳性）：\n  - 药物 $M=\\{\\text{Lisinopril},\\text{Spironolactone},\\text{Acetaminophen}\\}$。\n  - 诊断 $Y=\\{\\text{Chronic kidney disease}\\}$。\n- 案例2（边界情况，没有真实冲突，但粗粒度规则过度标记）：\n  - 药物 $M=\\{\\text{Acetaminophen}\\}$。\n  - 诊断 $Y=\\{\\text{Peptic ulcer disease}\\}$。\n- 案例3（边缘案例，同一类别中有多种药物且存在诊断不匹配）：\n  - 药物 $M=\\{\\text{Enalapril},\\text{Losartan},\\text{Ibuprofen}\\}$。\n  - 诊断 $Y=\\{\\text{Pregnancy}\\}$。\n\n算法要求：\n- 使用父节点映射为测试用例中所需的所有概念构建 $A(c)$。\n- 对于每个测试用例，分别使用 $R_{\\mathrm{coarse}},Q_{\\mathrm{coarse}}$ 和 $R_{\\mathrm{fine}},Q_{\\mathrm{fine}}$，遵循上面定义的检测规则来计算集合 $E_{\\mathrm{coarse}}$ 和 $E_{\\mathrm{fine}}$。药物-药物事件是无序对 $\\{m_i,m_j\\}$，诊断-药物事件是有序对 $(m_i,y_k)$。\n- 计算计数 $|E_{\\mathrm{coarse}}|$ 和 $|E_{\\mathrm{fine}}|$ 以及假阳性率 $\\rho$，约定当 $|E_{\\mathrm{coarse}}|=0$ 时 $\\rho=0$。\n- 将 $\\rho$ 四舍五入到三位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按顺序排列的三个测试用例的结果列表。每个结果必须是 $[\\text{coarse\\_count},\\text{fine\\_count},\\rho]$ 形式的列表。完整输出必须是这三个列表组成的单个列表，并严格按照逗号分隔、方括号括起来的格式打印，例如 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]$。", "solution": "用户提供的问题是医学信息学领域一个定义明确的任务，它基于集合论和图论原理。该任务要求实现一个确定性算法，以在一个简化的本体模型上检测临床医嘱集中的矛盾。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n-   **本体**：两个有根树由父节点映射定义，一个用于药物（$D$，$p_D$），一个用于诊断（$X$，$p_X$）。\n-   **祖先集 $A(c)$**：对于任意概念 $c$，$A(c)$ 是包含 $c$ 及其所有祖先直至根节点的集合。\n-   **医嘱集**：一个元组 $(M, Y)$，其中 $M$ 是药物叶节点概念的集合，$Y$ 是诊断叶节点概念的集合。\n-   **药物-药物规则 ($R$)**：一个对称关系 $R \\subseteq D \\times D$。如果对于某些 $a \\in A(m_i)$ 和 $b \\in A(m_j)$，有 $(a, b) \\in R$，则标记一个矛盾 $\\{m_i, m_j\\}$。\n-   **诊断-药物规则 ($Q$)**：一个关系 $Q \\subseteq D \\times X$。如果对于某些 $a \\in A(m_i)$ 和 $b \\in A(y_k)$，有 $(a, b) \\in Q$，则标记一个矛盾 $(m_i, y_k)$。\n-   **规则粒度**：提供了两套规则：细粒度 $(R_{\\mathrm{fine}}, Q_{\\mathrm{fine}})$ 和粗粒度 $(R_{\\mathrm{coarse}}, Q_{\\mathrm{coarse}})$。\n-   **假阳性率 ($\\rho$)**：定义为 $\\rho = \\frac{|E_{\\mathrm{coarse}} \\setminus E_{\\mathrm{fine}}|}{|E_{\\mathrm{coarse}}|}$，其中当 $|E_{\\mathrm{coarse}}| = 0$ 时，$\\rho = 0$。$E$ 是检测到的矛盾事件的集合。\n-   **本体定义**：$D$ 和 $X$ 中所有概念的完整父子关系。\n-   **规则定义**：$R_{\\mathrm{fine}}$、$Q_{\\mathrm{fine}}$、$R_{\\mathrm{coarse}}$ 和 $Q_{\\mathrm{coarse}}$ 的完整对列表。\n-   **测试套件**：三个具有指定药物集 $M$ 和诊断集 $Y$ 的测试用例。\n-   **输出格式**：对于每个案例，输出 $[|E_{\\mathrm{coarse}}|, |E_{\\mathrm{fine}}|, \\rho]$，其中 $\\rho$ 四舍五入到三位小数。最终输出是这些结果组成的列表。\n\n**步骤2：使用提取的已知条件进行验证**\n\n-   **科学性**：该问题使用了对现实世界临床决策支持系统的简化但有效的抽象，这些系统依赖于本体（如 SNOMED CT、RxNorm）和基于规则的系统来检测潜在问题，如药物-药物相互作用和禁忌症。该模型在其定义范围内逻辑上是合理的，事实上是可信的。\n-   **良构性**：问题定义精确。所有术语都有正式定义（$A(c)$、事件检测），所有必要的数据（本体、规则、测试用例）都已提供，计算目标明确。这种结构保证了每个测试用例都有一个唯一的、确定性的解。\n-   **客观性**：问题陈述是客观的，没有任何主观断言。规则和本体作为给定事实呈现，用于本次练习。\n\n该问题没有任何科学上的不健全、模糊性或不完整性。它是一个结构良好且可形式化的问题。\n\n**步骤3：结论与行动**\n\n问题是**有效的**。将开发一个解决方案。\n\n### 算法设计与实现\n\n解决方案将首先使用合适的 Python 数据结构来表示本体和规则，然后开发一系列函数来执行所需的逻辑步骤。\n\n1.  **数据表示**：\n    -   药物和诊断本体将存储为字典，将每个概念（一个字符串）映射到其父概念。根节点的父节点由 `None` 表示。\n    -   规则集（$R$ 和 $Q$）将存储为元组的集合。对于对称的药物-药物规则（$R$），对于问题描述中的每一对 $(u,v)$，$(u,v)$ 和 $(v,u)$ 都将被添加到集合中，以简化查找。\n    -   矛盾事件将存储在一个集合中，以自动处理重复项。无序的药物-药物对 $\\{m_i, m_j\\}$ 将由 `frozenset({m_i, m_j})` 表示，使其可哈希；而有序的诊断-药物对 $(m_i, y_k)$ 将由标准元组 `(m_i, y_k)` 表示。\n\n2.  **祖先集计算**：\n    -   将实现一个辅助函数 `get_ancestors(concept, parent_map, cache)`。\n    -   该函数从一个给定的概念开始追溯父节点直到根节点，并收集路径上的所有概念。\n    -   为优化性能，结果将被记忆化存储在一个缓存（一个字典）中，因为在分析一个医嘱集时，相同的祖先集会被多次请求。\n\n3.  **矛盾检测**：\n    -   一个核心函数 `detect_contradictions(M, Y, R, Q, ...)` 将实现问题陈述中指定的逻辑。\n    -   对于药物-药物矛盾，它将遍历 $M$ 中所有唯一的无序药物对（使用 `itertools.combinations`）。对于每一对，它检查其各自祖先的任意组合是否存在于规则集 $R$ 中。\n    -   对于诊断-药物矛盾，它将遍历 $M$ 中的药物和 $Y$ 中的诊断的笛卡尔积（使用 `itertools.product`）。对于每个 $(m, y)$ 对，它检查其祖先的任意组合是否存在于规则集 $Q$ 中。\n    -   该函数返回一个包含所有检测到的矛盾事件的集合。\n\n4.  **主执行循环**：\n    -   主程序将处理提供的三个测试用例中的每一个。\n    -   对于每个案例，它将调用 `detect_contradictions` 函数两次：一次使用粗粒度规则 $(R_{\\mathrm{coarse}}, Q_{\\mathrm{coarse}})$ 来计算 $E_{\\mathrm{coarse}}$，另一次使用细粒度规则 $(R_{\\mathrm{fine}}, Q_{\\mathrm{fine}})$ 来计算 $E_{\\mathrm{fine}}$。\n    -   然后确定基数 $|E_{\\mathrm{coarse}}|$ 和 $|E_{\\mathrm{fine}}|$。\n    -   假阳性的数量计算为 $|E_{\\mathrm{coarse}} \\setminus E_{\\mathrm{fine}}|$。\n    -   假阳性率 $\\rho$ 根据公式 $\\rho = |E_{\\mathrm{coarse}} \\setminus E_{\\mathrm{fine}}| / |E_{\\mathrm{coarse}}|$ 计算，并处理 $|E_{\\mathrm{coarse}}| = 0$ 的特殊情况。\n    -   $\\rho$ 的值被四舍五入并格式化为三位小数。\n    -   每个案例的结果 `[|E_coarse|, |E_fine|, rho]` 被收集起来。\n    -   最后，收集到的结果被格式化为最终输出所需的精确字符串格式。\n\n这种系统化的方法确保了问题的所有条件都能被正确且高效地满足。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations, product\n\ndef solve():\n    \"\"\"\n    Solves the clinical order set contradiction detection problem.\n    \"\"\"\n    # 1. Define Ontologies and Rules\n    p_D = {\n        'Analgesics': 'Drugs',\n        'Nonsteroidal anti-inflammatory drugs': 'Analgesics',\n        'Ibuprofen': 'Nonsteroidal anti-inflammatory drugs',\n        'Naproxen': 'Nonsteroidal anti-inflammatory drugs',\n        'Acetaminophen': 'Analgesics',\n        'Antihypertensives': 'Drugs',\n        'Angiotensin-converting enzyme inhibitors': 'Antihypertensives',\n        'Lisinopril': 'Angiotensin-converting enzyme inhibitors',\n        'Enalapril': 'Angiotensin-converting enzyme inhibitors',\n        'Angiotensin receptor blockers': 'Antihypertensives',\n        'Losartan': 'Angiotensin receptor blockers',\n        'Potassium-sparing diuretics': 'Antihypertensives',\n        'Spironolactone': 'Potassium-sparing diuretics',\n        'Drugs': None\n    }\n\n    p_X = {\n        'Gastrointestinal disorders': 'Conditions',\n        'Peptic ulcer disease': 'Gastrointestinal disorders',\n        'Renal disorders': 'Conditions',\n        'Chronic kidney disease': 'Renal disorders',\n        'Pregnancy': 'Conditions',\n        'Conditions': None\n    }\n\n    # Raw rule definitions from the problem statement\n    R_fine_raw = {\n        ('Nonsteroidal anti-inflammatory drugs', 'Angiotensin-converting enzyme inhibitors'),\n        ('Angiotensin-converting enzyme inhibitors', 'Potassium-sparing diuretics')\n    }\n    R_coarse_raw = {\n        ('Analgesics', 'Angiotensin-converting enzyme inhibitors'),\n        ('Antihypertensives', 'Potassium-sparing diuretics')\n    }\n    Q_fine = {\n        ('Nonsteroidal anti-inflammatory drugs', 'Peptic ulcer disease'),\n        ('Angiotensin-converting enzyme inhibitors', 'Pregnancy')\n    }\n    Q_coarse = {\n        ('Analgesics', 'Gastrointestinal disorders'),\n        ('Antihypertensives', 'Pregnancy')\n    }\n\n    # Create symmetric rule sets for drug-drug interactions (R)\n    def make_symmetric(rule_set):\n        symmetric_set = set()\n        for u, v in rule_set:\n            symmetric_set.add((u, v))\n            symmetric_set.add((v, u))\n        return symmetric_set\n\n    R_fine = make_symmetric(R_fine_raw)\n    R_coarse = make_symmetric(R_coarse_raw)\n\n    # 2. Helper function for ancestor calculation with memoization\n    def get_ancestors(concept, parent_map, cache):\n        if concept in cache:\n            return cache[concept]\n        \n        ancestors = set()\n        curr = concept\n        while curr is not None:\n            ancestors.add(curr)\n            curr = parent_map.get(curr)\n        \n        cache[concept] = ancestors\n        return ancestors\n\n    # 3. Core function for contradiction detection\n    def detect_contradictions(M, Y, R, Q, p_D, p_X, cache_D, cache_X):\n        events = set()\n\n        # Pre-compute all required ancestor sets for this order set\n        for drug in M:\n            get_ancestors(drug, p_D, cache_D)\n        for diagnosis in Y:\n            get_ancestors(diagnosis, p_X, cache_X)\n            \n        # Drug-drug contradictions\n        if len(M) >= 2:\n            for m_i, m_j in combinations(M, 2):\n                ancestors_i = cache_D[m_i]\n                ancestors_j = cache_D[m_j]\n                # Check for an interaction between any ancestor pair\n                if any((a_i, a_j) in R for a_i in ancestors_i for a_j in ancestors_j):\n                    events.add(frozenset({m_i, m_j}))\n\n        # Diagnosis-drug contradictions\n        for m_i, y_k in product(M, Y):\n            ancestors_m = cache_D[m_i]\n            ancestors_y = cache_X[y_k]\n            # Check for an incompatibility between any ancestor pair\n            if any((a_m, a_y) in Q for a_m in ancestors_m for a_y in ancestors_y):\n                events.add((m_i, y_k))\n        \n        return events\n\n    # 4. Define Test Cases and Process\n    test_cases = [\n        (  # Case 1\n            {'Lisinopril', 'Spironolactone', 'Acetaminophen'},\n            {'Chronic kidney disease'}\n        ),\n        (  # Case 2\n            {'Acetaminophen'},\n            {'Peptic ulcer disease'}\n        ),\n        (  # Case 3\n            {'Enalapril', 'Losartan', 'Ibuprofen'},\n            {'Pregnancy'}\n        )\n    ]\n\n    all_results = []\n    \n    for M_set, Y_set in test_cases:\n        ancestor_cache_d = {}\n        ancestor_cache_x = {}\n\n        # Detect contradictions for coarse rules\n        E_coarse = detect_contradictions(M_set, Y_set, R_coarse, Q_coarse, p_D, p_X, ancestor_cache_d, ancestor_cache_x)\n        count_coarse = len(E_coarse)\n\n        # Detect contradictions for fine rules\n        E_fine = detect_contradictions(M_set, Y_set, R_fine, Q_fine, p_D, p_X, ancestor_cache_d, ancestor_cache_x)\n        count_fine = len(E_fine)\n        \n        # Calculate false positive rate rho\n        if count_coarse == 0:\n            rho = 0.0\n        else:\n            false_positives = len(E_coarse.difference(E_fine))\n            rho = false_positives / count_coarse\n            \n        all_results.append([count_coarse, count_fine, round(rho, 3)])\n\n    # 5. Format and print the final output\n    # Convert float to string with required precision, avoiding scientific notation\n    final_output = []\n    for coarse_count, fine_count, rho_val in all_results:\n        final_output.append(f\"[{coarse_count},{fine_count},{rho_val:.3f}]\")\n    \n    print(f\"[{','.join(final_output)}]\")\n\nsolve()\n```", "id": "4850365"}]}