{"hands_on_practices": [{"introduction": "有效的临床警报至关重要，但许多警报在实践中因产生过多假阳性而失败，导致“警报疲劳”。本练习揭示了这一现象背后的一个主要统计学原因。通过在一个假设场景中计算阳性预测值（Positive Predictive Value, PPV），您将亲身体验一个看似准确的警报为何在大多数情况下可能是错误的，并理解这是临床决策支持系统设计中的核心挑战之一。[@problem_id:4822027]", "problem": "一家医院在其电子健康记录（EHR）系统中部署了一个临床决策支持（CDS）警报，用于通知临床医生存在一种可能需要采取措施的病症，记为 $D$。在筛查人群中，$D$ 的基础率（患病率）为 $P(D)=0.05$。该警报的灵敏度为 $0.9$，特异度为 $0.8$，其中灵敏度定义为在患者确实患有 $D$ 的情况下警报触发的概率，特异度定义为在患者未患有 $D$ 的情况下警报不触发的概率。使用基本概率定义和贝叶斯定理，计算阳性预测值（PPV），其定义为在警报触发的情况下患者确实患有 $D$ 的概率。将 PPV 表示为四舍五入到四位有效数字的小数。计算 PPV 后，根据第一性原理，用文字解释该值对临床实践中警报的感知可靠性及潜在的警报疲劳意味着什么。你的最终数值答案必须仅为 PPV（无单位）。", "solution": "该问题要求计算临床决策支持（CDS）警报的阳性预测值（PPV），并解释其含义。该问题陈述清晰，具有概率论和医学信息学的科学依据，并包含了获得唯一解所需的所有信息。\n\n首先，我们必须使用标准概率符号来形式化给定的信息。设 $D$ 为患者患有该病症的事件，设 $A$ 为 CDS 警报触发的事件。其互补事件为 $D^c$（患者未患该病症）和 $A^c$（警报未触发）。\n\n给定条件如下：\n1.  该病症的基础率或患病率：$P(D) = 0.05$。\n2.  警报的灵敏度，即在患者患有该病症的情况下警报触发的概率：$P(A|D) = 0.9$。\n3.  警报的特异度，即在患者未患该病症的情况下警报不触发的概率：$P(A^c|D^c) = 0.8$。\n\n根据这些给定条件，我们可以推导出计算所需的另外两个概率。\n患者未患该病症的概率是患病率的补集：\n$$P(D^c) = 1 - P(D) = 1 - 0.05 = 0.95$$\n在患者未患该病症的情况下警报触发的概率（假阳性率）是特异度的补集：\n$$P(A|D^c) = 1 - P(A^c|D^c) = 1 - 0.8 = 0.2$$\n\n问题要求我们计算阳性预测值（PPV），其定义为在警报 $A$ 触发的情况下，患者确实患有病症 $D$ 的概率。用概率术语来说，我们需要计算 $P(D|A)$。\n\n我们将使用贝叶斯定理来求这个条件概率：\n$$P(D|A) = \\frac{P(A|D) P(D)}{P(A)}$$\n\n分母 $P(A)$ 代表警报触发的总概率。它可以根据全概率定律计算，即对患有该病症的患者（真阳性）和未患该病症的患者（假阳性）警报触发的概率求和：\n$$P(A) = P(A \\cap D) + P(A \\cap D^c)$$\n使用条件概率的定义 $P(X \\cap Y) = P(X|Y)P(Y)$，我们可以将其展开为：\n$$P(A) = P(A|D)P(D) + P(A|D^c)P(D^c)$$\n\n将此展开式代回贝叶斯定理，得到 PPV 的完整公式：\n$$P(D|A) = \\frac{P(A|D) P(D)}{P(A|D)P(D) + P(A|D^c)P(D^c)}$$\n\n现在，我们可以将数值代入此公式。\n分子是真阳性事件（患者患有该病症且警报触发）的概率：\n$$\\text{Numerator} = P(A|D)P(D) = (0.9) \\times (0.05) = 0.045$$\n分母中的第一项与分子相同：\n$$P(A|D)P(D) = 0.045$$\n分母中的第二项是假阳性事件（患者未患该病症但警报触发）的概率：\n$$P(A|D^c)P(D^c) = (0.2) \\times (0.95) = 0.190$$\n警报触发的总概率是这两项之和：\n$$P(A) = 0.045 + 0.190 = 0.235$$\n最后，我们可以计算 PPV：\n$$P(D|A) = \\frac{0.045}{0.235} \\approx 0.19148936...$$\n\n问题要求结果四舍五入到四位有效数字。\n$$PPV \\approx 0.1915$$\n\n计算出的阳性预测值为 $0.1915$。这个值意味着，当临床医生看到这个特定警报时，患者实际患有病症 $D$ 的概率仅为 $19.15\\%$。反过来说，这意味着 $1 - 0.1915 = 0.8085$，即 $80.85\\%$ 的情况下，警报触发是假警报（即患者并未患有病症 $D$）。\n\n这个极低的 PPV 对临床实践具有重要影响。\n在感知到的警报可靠性方面，临床医生很可能会认为该警报非常不可靠。一个在 $5$ 次中有超过 $4$ 次是错误的工具，不会激发人们的信心。这会侵蚀临床医生对 CDS 系统的信任。\n\n这种低可靠性是导致警报疲劳的直接原因。警报疲劳是指临床医生在接触大量临床上不相关或错误的警报后，对安全警报和通知变得不敏感的现象。频繁经历低价值的中断会分散对患者护理的注意力，并导致临床医生养成不加思索地忽略或条件反射式地否决警报的习惯。这种行为虽然是对过多“噪音”的理性反应，但却很危险，因为它可能导致对罕见但至关重要的真阳性警报的忽略，从而破坏 CDS 的主要安全目标。在这种情况下，PPV 低的根本原因在于相对较低的特异度（$0.8$，导致了 $0.2$ 的高假阳性率）和疾病的低患病率（$0.05$）的结合。即使灵敏度很高，大量健康个体接受一个特异度不完美的测试，也会产生大量的假阳性，其数量会超过来自较小的患病人群的真阳性。", "answer": "$$\n\\boxed{0.1915}\n$$", "id": "4822027"}, {"introduction": "理解了警报疲劳的根源后，我们转向如何构建一个功能性的警报。本练习将引导您使用现代医疗保健标准HL7 FHIR，为一个特定的临床状况（高钾血症）定义一个精确的警报。您将学习如何将临床需求转化为FHIR订阅（Subscription）资源的正式标准，这是医疗信息学专业人员的一项基本技能。[@problem_id:4821956]", "problem": "您正在第七级健康水平标准 (HL7) 快速医疗保健互操作性资源 (FHIR) 中设计一个警报机制，当实验室观察 (Observation) 指示血清钾高于临床显著阈值时，该机制会通知下游系统。请使用以下基础定义作为您推导和算法规范的基础：\n\n- HL7 FHIR R4 订阅 (Subscription) 使用应用于资源类型的搜索条件字符串，遵循 FHIR 搜索语义。观察 (Observation) 代码是一个令牌（token）搜索参数，它在代码体系和代码的组合上进行精确匹配。标准的 LOINC（逻辑观察标识符名称和代码）体系由统一资源标识符 (URI) \"http://loinc.org\" 表示。\n- FHIR 中用于值的数量（quantity）搜索参数，在 Observation 上名为 \"value-quantity\"，使用一个比较符前缀和一个数量三元组 \"值|体系|代码\"。统一计量单位代码 (UCUM) 体系由 URI \"http://unitsofmeasure.org\" 表示，而毫摩尔/升的代码是 \"mmol/L\"。对于比较符前缀 `gt`，其语义是严格大于。因此，`gt5.5` 表示 “$>5.5$”。\n- 使用 \"value-quantity=[比较符][数值]|[体系]|[代码]\" 形式的 FHIR 数量搜索匹配要求单位体系和单位代码完全相等才能被视为可比较；不执行单位转换。如果体系或代码任一不完全匹配，则该数量不匹配。\n\n任务要求：\n\n1. 精确指定 HL7 FHIR R4 订阅 (Subscription) 的搜索条件字符串，该字符串用于监控 LOINC 代码为 \"2823-3\" 且数值严格大于 $5.5$ 毫摩尔/升的血清或血浆钾的观察 (Observation) 资源。请使用上述语义进行精确的体系和代码匹配。然后，指定一个通道配置，该配置使用通过安全超文本传输协议 (HTTPS) 传递的、带有 JavaScript 对象表示法 (JSON) 负载的表征状态转移 (REST) 钩子。您必须定义通道类型、端点和负载内容类型。\n2. 实现一个程序，用于评估以下每个伪观察 (pseudo-Observation) 输入是否会根据第 1 部分推导出的订阅 (Subscription) 触发提送。每个输入是一个包含五个字段的元组：(code_system, code, value, unit_system, unit_code)。一个案例当且仅当以下所有条件都为真时才会触发：\n   - code_system 等于 \"http://loinc.org\" 且 code 等于 \"2823-3\"，\n   - value 是一个严格大于 $5.5$ 的实数，\n   - unit_system 等于 \"http://unitsofmeasure.org\" 且 unit_code 等于 \"mmol/L\"。\n   如果任何字段缺失或不满足条件，则该案例不触发。\n\n使用以下测试案例集：\n- 案例 A: (\"http://loinc.org\", \"2823-3\", $6.2$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- 案例 B: (\"http://loinc.org\", \"2823-3\", $5.5$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- 案例 C: (\"http://loinc.org\", \"2823-3\", $4.7$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- 案例 D: (\"http://loinc.org\", \"2951-2\", $6.0$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- 案例 E: (\"http://loinc.org\", \"2823-3\", $6.0$, \"http://unitsofmeasure.org\", \"meq/L\")\n- 案例 F: (\"http://loinc.org\", \"2823-3\", null, \"http://unitsofmeasure.org\", \"mmol/L\") 其中 null 表示不存在数值，\n- 案例 G: (\"http://example.org/loinc\", \"2823-3\", $7.1$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- 案例 H: (\"http://loinc.org\", \"2823-3\", $-1.0$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- 案例 I: (\"http://loinc.org\", \"2823-3\", $5.5000001$, \"http://unitsofmeasure.org\", \"mmol/L\")\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[true,false,true]\"）。布尔值应使用标准的 Python 大小写 \"True\" 和 \"False\" 进行打印。", "solution": "该问题是有效的，因为它在医学信息学和 HL7 FHIR 标准领域有科学依据，其问题陈述清晰明确，要求毫不含糊，并且表述客观。所有必要的定义、常量和条件都已提供，以推导出唯一且可验证的解决方案。\n\n该问题按规定分为两部分解决。\n\n第 1 部分：HL7 FHIR 订阅规范\n\n目标是创建一个针对特定类型 `Observation` 资源的触发订阅。这需要定义一组精确选择目标资源的搜索条件。HL7 FHIR R4 搜索框架使用参数-值对的组合，通过与号字符（&）连接，并附加到资源类型之后。\n\n所需的订阅必须监控 `Observation` 资源，因此条件字符串将以 `Observation?` 开头。\n\n标准 1：观察代码\n第一个条件是观察代码，它必须是血清或血浆钾的 LOINC 代码 `“2823-3”`。问题指出，`code` 搜索参数是 `token` 类型，并且同时匹配代码体系和代码值。指定的令牌搜索语法是 `[参数]=[体系]|[代码]`。\n\n-   参数名称：`code`\n-   代码体系 URI：`http://loinc.org`\n-   代码值：`2823-3`\n\n根据指定格式组合这些元素，得到搜索字符串的第一部分：\n`code=http://loinc.org|2823-3`\n\n标准 2：观察值\n第二个条件是观察值，它必须严格大于 $5.5$ 毫摩尔/升。这需要使用 `value-quantity` 搜索参数。问题指定了数量搜索的格式为 `[参数]=[比较符][数值]|[体系]|[代码]`。它还强制要求搜索是严格的，不进行单位转换，需要单位体系和单位代码完全匹配。\n\n-   参数名称：`value-quantity`\n-   “严格大于”的比较符：`gt`\n-   数值：$5.5$\n-   单位体系 URI (UCUM)：`http://unitsofmeasure.org`\n-   单位代码：`mmol/L`\n\n组合这些元素，得到搜索字符串的第二部分：\n`value-quantity=gt5.5|http://unitsofmeasure.org|mmol/L`\n\n最终搜索条件字符串\n用于 `Subscription` 资源的完整 `criteria` 字符串是通过将资源类型与两个标准串联而成，并用与号（&）连接。\n\n`Observation?code=http://loinc.org|2823-3&value-quantity=gt5.5|http://unitsofmeasure.org|mmol/L`\n\n通道配置\n问题进一步要求指定通知的传递通道。这在 `Subscription` 资源的 `channel` 元素中配置。要求是 REST 钩子、JSON 负载和 HTTPS 端点。\n\n-   `channel.type`：根据规定，对于 REST 钩子，其值为 `rest-hook`。\n-   `channel.endpoint`：这必须是一个安全 URL，通知将被发送到该地址。将使用一个代表性的占位符，例如 `https://downstream-system.example.com/fhir/receive`。\n-   `channel.payload`：对于代表 FHIR 资源的 JSON 负载，标准的 MIME 类型是 `application/fhir+json`。\n\n这三项规范定义了订阅的传递机制。\n\n第 2 部分：伪观察输入的算法评估\n\n任务是创建一个程序，实现由订阅条件定义的逻辑。一个伪观察当且仅当所有指定条件都满足时才会触发通知。每个案例的输入是一个元组：`(code_system, code, value, unit_system, unit_code)`。\n\n触发的逻辑是五个条件的逻辑与（合取）：\n1.  `code_system` 必须严格等于字符串 `“http://loinc.org”`。\n2.  `code` 必须严格等于字符串 `“2823-3”`。\n3.  `value` 必须是数值类型，并且必须严格大于 $5.5$。`null` 值或非数值将导致此条件失败。\n4.  `unit_system` 必须严格等于字符串 `“http://unitsofmeasure.org”`。\n5.  `unit_code` 必须严格等于字符串 `“mmol/L”`。\n\n此逻辑应用于每个测试案例：\n\n-   案例 A: `(\"http://loinc.org\", \"2823-3\", 6.2, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   所有条件均满足。`code_system`、`code`、`unit_system` 和 `unit_code` 匹配。值 $6.2$ 是数值型且 $6.2 > 5.5$。\n    -   结果：`True`。\n\n-   案例 B: `(\"http://loinc.org\", \"2823-3\", 5.5, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   值条件不满足。$5.5$ 并不严格大于 $5.5$。\n    -   结果：`False`。\n\n-   案例 C: `(\"http://loinc.org\", \"2823-3\", 4.7, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   值条件不满足。$4.7$ 不大于 $5.5$。\n    -   结果：`False`。\n\n-   案例 D: `(\"http://loinc.org\", \"2951-2\", 6.0, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   `code` 条件不满足。`“2951-2”` 不等于 `“2823-3”`。\n    -   结果：`False`。\n\n-   案例 E: `(\"http://loinc.org\", \"2823-3\", 6.0, \"http://unitsofmeasure.org\", \"meq/L\")`\n    -   `unit_code` 条件不满足。`“meq/L”` 不等于 `“mmol/L”`。\n    -   结果：`False`。\n\n-   案例 F: `(\"http://loinc.org\", \"2823-3\", null, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   值条件不满足。`null` 值不是数值型，无法进行比较。\n    -   结果：`False`。\n\n-   案例 G: `(\"http://example.org/loinc\", \"2823-3\", 7.1, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   `code_system` 条件不满足。`“http://example.org/loinc”` 不等于 `“http://loinc.org”`。\n    -   结果：`False`。\n\n-   案例 H: `(\"http://loinc.org\", \"2823-3\", -1.0, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   值条件不满足。虽然是数值，但 $-1.0$ 不大于 $5.5$。负浓度的物理不可能性与逻辑评估无关。\n    -   结果：`False`。\n\n-   案例 I: `(\"http://loinc.org\", \"2823-3\", 5.5000001, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   所有条件均满足。值 $5.5000001$ 严格大于 $5.5$。\n    -   结果：`True`。\n\n下面的程序将直接实现此评估逻辑，并生成指定的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Evaluates a series of pseudo-Observation inputs against HL7 FHIR\n    subscription criteria for hyperkalemia alerts.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (code_system, code, value, unit_system, unit_code)\n    # The 'null' value from the problem is represented as Python's None.\n    test_cases = [\n        (\"http://loinc.org\", \"2823-3\", 6.2, \"http://unitsofmeasure.org\", \"mmol/L\"),  # Case A\n        (\"http://loinc.org\", \"2823-3\", 5.5, \"http://unitsofmeasure.org\", \"mmol/L\"),  # Case B\n        (\"http://loinc.org\", \"2823-3\", 4.7, \"http://unitsofmeasure.org\", \"mmol/L\"),  # Case C\n        (\"http://loinc.org\", \"2951-2\", 6.0, \"http://unitsofmeasure.org\", \"mmol/L\"),  # Case D\n        (\"http://loinc.org\", \"2823-3\", 6.0, \"http://unitsofmeasure.org\", \"meq/L\"),   # Case E\n        (\"http://loinc.org\", \"2823-3\", None, \"http://unitsofmeasure.org\", \"mmol/L\"), # Case F\n        (\"http://example.org/loinc\", \"2823-3\", 7.1, \"http://unitsofmeasure.org\", \"mmol/L\"), # Case G\n        (\"http://loinc.org\", \"2823-3\", -1.0, \"http://unitsofmeasure.org\", \"mmol/L\"), # Case H\n        (\"http://loinc.org\", \"2823-3\", 5.5000001, \"http://unitsofmeasure.org\", \"mmol/L\") # Case I\n    ]\n\n    # Define the target values based on the subscription criteria.\n    TARGET_CODE_SYSTEM = \"http://loinc.org\"\n    TARGET_CODE = \"2823-3\"\n    VALUE_THRESHOLD = 5.5\n    TARGET_UNIT_SYSTEM = \"http://unitsofmeasure.org\"\n    TARGET_UNIT_CODE = \"mmol/L\"\n\n    results = []\n    for case in test_cases:\n        code_system, code, value, unit_system, unit_code = case\n\n        # A case triggers if and only if all conditions are met.\n        # This is a direct implementation of the logical AND of all checks.\n\n        # 1. Check if a numeric value is present and if it's strictly greater than the threshold.\n        #    Python's isinstance handles both int and float.\n        #    A None value will cause the first part of this AND to be false.\n        value_is_valid = isinstance(value, (int, float)) and value > VALUE_THRESHOLD\n\n        # 2. Check for exact matches on code system, code, unit system, and unit code.\n        code_system_matches = (code_system == TARGET_CODE_SYSTEM)\n        code_matches = (code == TARGET_CODE)\n        unit_system_matches = (unit_system == TARGET_UNIT_SYSTEM)\n        unit_code_matches = (unit_code == TARGET_UNIT_CODE)\n\n        # 3. The final result is the logical conjunction of all conditions.\n        trigger = (\n            code_system_matches and\n            code_matches and\n            value_is_valid and\n            unit_system_matches and\n            unit_code_matches\n        )\n        results.append(trigger)\n\n    # Final print statement in the exact required format.\n    # The default string representation of Python's boolean is \"True\" and \"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4821956"}, {"introduction": "现实世界的临床数据往往是不完整的，警报逻辑必须足够稳健以处理缺失值。本练习介绍了一种形式化方法——三值逻辑，用于明确地管理“未知”状态，从而解决这一难题。通过应用这种逻辑，您将学习设计出更具弹性、行为更可预测的警报系统，该系统能够区分阴性结果与信息缺失。[@problem_id:4822035]", "problem": "一份电子健康记录 (EHR) 警报必须在存在缺失数据的情况下评估实验室触发器。该系统必须区分三种状态：阳性 (positive)、阴性 (negative) 和未知 (unknown)。为一个结合了多个实验室条件的触发器形式化一种三值逻辑，并计算该逻辑在两种策略下如何影响警报的触发。\n\n使用的基本基础：\n- 三值语义域，其值为：阳性 (positive)、阴性 (negative)、未知 (unknown)，分别用 $P$、$N$ 和 $U$ 表示。\n- 对于单个实验室值 $x$ 和阈值 $t$，在关系 $\\ge$ 或 $\\le$ 下的确定性阈值评估定义为：如果 $x$ 存在，则通过比较 $x$ 和 $t$ 来决定 $P$ 或 $N$；如果 $x$ 缺失，则返回 $U$。\n- 作用于 $\\{P,N,U\\}$ 的连接词的强三值逻辑 (Kleene 语义)：\n  - 否定：$\\lnot P = N$, $\\lnot N = P$, $\\lnot U = U$。\n  - 合取：$P \\land P = P$，对于任何 $v \\in \\{P,N,U\\}$，$N \\land v = N$，$v \\land N = N$，$P \\land U = U$，$U \\land P = U$，$U \\land U = U$。\n  - 析取：对于任何 $v \\in \\{P,N,U\\}$，$P \\lor v = P$，$v \\lor P = P$，$N \\lor N = N$，$N \\lor U = U$，$U \\lor N = U$，$U \\lor U = U$。\n\n待评估的警报表达式：\n- 基于阈值化的实验室值定义三个原子触发器 $A$、$B$ 和 $C$：\n  - $A$ 是在关系 $\\ge$ 下检验 $x_A$ 与阈值 $t_A$ 的三值结果。\n  - $B$ 是在关系 $\\ge$ 下检验 $x_B$ 与阈值 $t_B$ 的三值结果。\n  - $C$ 是在关系 $\\le$ 下检验 $x_C$ 与阈值 $t_C$ 的三值结果。\n- 复合触发器为 $E = A \\lor (B \\land C)$，使用强三值逻辑进行评估。\n\n警报触发策略：\n- 严格策略 $S$：当且仅当 $E = P$ 时触发。\n- 谨慎策略 $C$：当 $E = P$ 或 $E = U$ 时触发。\n\n输出的整数编码：\n- 使用映射 $m(P) = 1$, $m(N) = 0$, $m(U) = -1$。\n\n你的程序必须：\n1. 为 $A$、$B$ 和 $C$ 实现三值阈值评估，并为 $\\lnot$、$\\land$ 和 $\\lor$ 实现强三值逻辑。\n2. 为每个测试用例计算 $E$，然后计算严格触发决策 $S$ 和谨慎触发决策 $C$。\n3. 生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身是形式为 $[m(E), S, C]$ 的列表。\n\n阈值：\n- $t_A = 5.5$, $t_B = 1.5$, $t_C = 60$。\n\n测试套件（每个测试用例提供元组 $(x_A, x_B, x_C)$，其中缺失值由单词“None”表示）：\n- 用例 1：$(5.0, 1.2, 70)$。\n- 用例 2：$(5.6, 1.0, 90)$。\n- 用例 3：$(4.0, 2.0, 40)$。\n- 用例 4：$(4.0, 2.2, 80)$。\n- 用例 5：$(\\text{None}, 2.0, 40)$。\n- 用例 6：$(\\text{None}, \\text{None}, \\text{None})$。\n- 用例 7：$(5.5, 1.5, 60)$。\n- 用例 8：$(4.5, \\text{None}, 50)$。\n\n最终输出格式：\n- 单行：一个由方括号括起来的逗号分隔列表，其中每个元素是对应测试用例的列表 $[m(E), S, C]$，例如 $[[1,True,True],[0,False,False],\\dots]$。", "solution": "该问题要求形式化并应用一个三值逻辑系统，以在存在缺失实验室数据的情况下评估医疗警报触发器。解决方案涉及定义逻辑框架，为多个测试用例评估一个复合逻辑表达式，并基于两种不同的策略确定警报触发决策。\n\n首先，我们建立该系统的数学基础。语义域包含三个逻辑值：阳性 ($P$)、阴性 ($N$) 和未知 ($U$)。这些值使用强三值逻辑进行操作，也称为 Kleene 的 $K_3$ 逻辑。合取 ($\\land$) 和析取 ($\\lor$) 运算符的行为由以下真值表定义：\n\n**合取 ($v_1 \\land v_2$)**\n$$\n\\begin{array}{c|ccc}\n\\land & P & N & U \\\\\n\\hline\nP & P & N & U \\\\\nN & N & N & N \\\\\nU & U & N & U\n\\end{array}\n$$\n\n**析取 ($v_1 \\lor v_2$)**\n$$\n\\begin{array}{c|ccc}\n\\lor & P & N & U \\\\\n\\hline\nP & P & P & P \\\\\nN & P & N & U \\\\\nU & P & U & U\n\\end{array}\n$$\n\n该逻辑的一个重要特性是 $N$ 在合取运算中和 $P$ 在析取运算中的行为。单个 $N$ 操作数足以使合取结果为 $N$（$N$ 对于 $\\land$ 是“支配性的”或“吸收性的”）。类似地，单个 $P$ 操作数足以使析取结果为 $P$（$P$ 对于 $\\lor$ 是支配性的）。当无法从可用的非未知值中确定结果时，会出现值 $U$。\n\n问题基于实验室值 $x_A$、$x_B$、$x_C$ 及其各自的阈值 $t_A$、$t_B$、$t_C$ 定义了三个原子触发器 $A$、$B$ 和 $C$。\n-   $t_A = 5.5$\n-   $t_B = 1.5$\n-   $t_C = 60$\n\n每个原子触发器的评估如下：\n1.  如果 $x_A \\ge 5.5$，触发器 $A$ 评估为 $P$；如果 $x_A  5.5$，评估为 $N$；如果 $x_A$ 缺失，则评估为 $U$。\n2.  如果 $x_B \\ge 1.5$，触发器 $B$ 评估为 $P$；如果 $x_B  1.5$，评估为 $N$；如果 $x_B$ 缺失，则评估为 $U$。\n3.  如果 $x_C \\le 60$，触发器 $C$ 评估为 $P$；如果 $x_C  60$，评估为 $N$；如果 $x_C$ 缺失，则评估为 $U$。\n\n这些原子触发器被组合成一个单一的复合表达式 $E$：\n$$\nE = A \\lor (B \\land C)\n$$\n该表达式的评估遵循运算顺序，首先评估括号内的合取。\n\n最后，根据 $E$ 的结果值定义了两种警报触发策略：\n-   **严格策略 ($S$)**：当且仅当 $E = P$ 时，警报触发。\n-   **谨慎策略 ($C$)**：当 $E = P$ 或 $E = U$ 时，警报触发。\n\n每个用例的最终输出需要将 $E$ 的逻辑值映射到一个整数代码：$m(P) = 1$, $m(N) = 0$, $m(U) = -1$。严格策略 ($S$) 和谨慎策略 ($C$) 的决策表示为布尔值 `True` 或 `False`。\n\n让我们用两个代表性的测试用例来演示评估过程。\n\n**用例 4：输入 $(x_A, x_B, x_C) = (4.0, 2.2, 80)$**\n此用例没有缺失数据。\n\n1.  **评估原子触发器**：\n    -   $A$：$x_A = 4.0$。条件是 $4.0 \\ge 5.5$，为假。因此，$A = N$。\n    -   $B$：$x_B = 2.2$。条件是 $2.2 \\ge 1.5$，为真。因此，$B = P$。\n    -   $C$：$x_C = 80$。条件是 $80 \\le 60$，为假。因此，$C = N$。\n\n2.  **评估子表达式 $(B \\land C)$**：\n    -   我们计算 $P \\land N$。根据合取表，$P \\land N = N$。\n\n3.  **评估完整表达式 $E = A \\lor (B \\land C)$**：\n    -   我们计算 $N \\lor N$。根据析取表，$N \\lor N = N$。所以，$E=N$。\n\n4.  **确定策略和最终输出**：\n    -   $m(E) = m(N) = 0$。\n    -   严格策略 ($S$)：$E = P$吗？否 ($N \\neq P$)。所以，$S = \\text{False}$。\n    -   谨慎策略 ($C$)：$E = P$ 或 $E = U$ 吗？否 ($N \\neq P$ 且 $N \\neq U$)。所以，$C = \\text{False}$。\n    -   结果向量为 [0, False, False]。\n\n**用例 8：输入 $(x_A, x_B, x_C) = (4.5, \\text{None}, 50)$**\n此用例包含一个缺失值，演示了 $U$ 状态的作用。\n\n1.  **评估原子触发器**：\n    -   $A$：$x_A = 4.5$。条件是 $4.5 \\ge 5.5$，为假。因此，$A = N$。\n    -   $B$：$x_B = \\text{None}$。该值缺失。因此，$B = U$。\n    -   $C$：$x_C = 50$。条件是 $50 \\le 60$，为真。因此，$C = P$。\n\n2.  **评估子表达式 $(B \\land C)$**：\n    -   我们计算 $U \\land P$。根据合取表，$U \\land P = U$。\n\n3.  **评估完整表达式 $E = A \\lor (B \\land C)$**：\n    -   我们计算 $N \\lor U$。根据析取表，$N \\lor U = U$。所以，$E=U$。\n\n4.  **确定策略和最终输出**：\n    -   $m(E) = m(U) = -1$。\n    -   严格策略 ($S$)：$E = P$吗？否 ($U \\neq P$)。所以，$S = \\text{False}$。\n    -   谨慎策略 ($C$)：$E = P$ 或 $E = U$ 吗？是 ($U = U$)。所以，$C = \\text{True}$。\n    -   结果向量为 [-1, False, True]。\n\n通过将此过程应用于所有八个测试用例，我们得到以下结果：\n-   用例 1：$(5.0, 1.2, 70) \\implies A=N, B=N, C=N \\implies E = N \\lor (N \\land N) = N$。结果：[0, False, False]。\n-   用例 2：$(5.6, 1.0, 90) \\implies A=P, B=N, C=N \\implies E = P \\lor (N \\land N) = P$。结果：[1, True, True]。\n-   用例 3：$(4.0, 2.0, 40) \\implies A=N, B=P, C=P \\implies E = N \\lor (P \\land P) = P$。结果：[1, True, True]。\n-   用例 4：$(4.0, 2.2, 80) \\implies A=N, B=P, C=N \\implies E = N \\lor (P \\land N) = N$。结果：[0, False, False]。\n-   用例 5：$(\\text{None}, 2.0, 40) \\implies A=U, B=P, C=P \\implies E = U \\lor (P \\land P) = P$。结果：[1, True, True]。\n-   用例 6：$(\\text{None}, \\text{None}, \\text{None}) \\implies A=U, B=U, C=U \\implies E = U \\lor (U \\land U) = U$。结果：[-1, False, True]。\n-   用例 7：$(5.5, 1.5, 60) \\implies A=P, B=P, C=P \\implies E = P \\lor (P \\land P) = P$。结果：[1, True, True]。\n-   用例 8：$(4.5, \\text{None}, 50) \\implies A=N, B=U, C=P \\implies E = N \\lor (U \\land P) = U$。结果：[-1, False, True]。\n\n这些结果由下一节中的实现系统地生成。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport operator\n\n# No other libraries are imported.\n\ndef solve():\n    \"\"\"\n    Solves the three-valued logic problem for medical alerts.\n    \"\"\"\n    \n    # Define the three logic states. Using strings for clarity.\n    P, N, U = \"P\", \"N\", \"U\"\n\n    # Define the integer mapping for the output.\n    MAPPING = {P: 1, N: 0, U: -1}\n\n    def evaluate_atomic_trigger(value, threshold, op):\n        \"\"\"\n        Evaluates a single lab value against a threshold.\n        'op' is a comparison operator from the operator module.\n        \"\"\"\n        if value is None:\n            return U\n        if op(value, threshold):\n            return P\n        else:\n            return N\n\n    def kleene_and(v1, v2):\n        \"\"\"Implements strong Kleene three-valued conjunction (AND).\"\"\"\n        if v1 == N or v2 == N:\n            return N\n        if v1 == P and v2 == P:\n            return P\n        return U\n\n    def kleene_or(v1, v2):\n        \"\"\"Implements strong Kleene three-valued disjunction (OR).\"\"\"\n        if v1 == P or v2 == P:\n            return P\n        if v1 == N and v2 == N:\n            return N\n        return U\n\n    # Thresholds for the atomic triggers A, B, and C.\n    t_A = 5.5\n    t_B = 1.5\n    t_C = 60\n\n    # Test suite: tuples of (x_A, x_B, x_C), with None for missing values.\n    test_cases = [\n        (5.0, 1.2, 70),       # Case 1\n        (5.6, 1.0, 90),       # Case 2\n        (4.0, 2.0, 40),       # Case 3\n        (4.0, 2.2, 80),       # Case 4\n        (None, 2.0, 40),      # Case 5\n        (None, None, None),   # Case 6\n        (5.5, 1.5, 60),       # Case 7\n        (4.5, None, 50),      # Case 8\n    ]\n\n    results = []\n    for case in test_cases:\n        x_A, x_B, x_C = case\n\n        # Step 1: Evaluate atomic triggers A, B, and C.\n        A = evaluate_atomic_trigger(x_A, t_A, operator.ge) # A is x_A = t_A\n        B = evaluate_atomic_trigger(x_B, t_B, operator.ge) # B is x_B = t_B\n        C = evaluate_atomic_trigger(x_C, t_C, operator.le) # C is x_C = t_C\n\n        # Step 2: Evaluate the composite expression E = A or (B and C).\n        # The inner conjunction (B and C) is evaluated first.\n        B_and_C = kleene_and(B, C)\n        \n        # Then the outer disjunction.\n        E = kleene_or(A, B_and_C)\n\n        # Step 3: Apply firing policies and map E to its integer representation.\n        m_E = MAPPING[E]\n        \n        # Strict policy (S): fire if and only if E is Positive.\n        S = (E == P)\n        \n        # Cautious policy (C_policy): fire if E is Positive or Unknown.\n        C_policy = (E == P or E == U)\n\n        # Collect the results for this case in the specified format [m(E), S, C].\n        results.append([m_E, S, C_policy])\n\n    # Final print statement must produce a single line in the exact specified format.\n    # The str() function on a list correctly formats it with capitalized Booleans.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4822035"}]}