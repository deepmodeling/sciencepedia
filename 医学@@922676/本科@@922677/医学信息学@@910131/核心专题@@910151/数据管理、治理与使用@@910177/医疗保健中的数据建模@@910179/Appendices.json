{"hands_on_practices": [{"introduction": "医疗数据建模的基石是关系数据库的规范化设计。这个练习模拟了一个常见场景：将一个庞大、冗余的电子健康记录（EHR）表分解为一组结构良好、无冗余的表。通过这个实践，你将掌握如何应用函数依赖和范式理论来消除数据异常，确保数据的完整性和查询效率，这是医疗信息学专家的核心技能之一 [@problem_id:4833282]。", "problem": "一家医院的电子健康记录（EHR）系统有一个非规范化的表，包含以下列：patient_id, patient_name, dob, encounter_id, provider_id, observation_id, loinc_code, value。代码 loinc_code 指的是逻辑观察标识符名称和代码（Logical Observation Identifiers Names and Codes, LOINC）。假设以下领域和数据建模事实基于关系模型和医疗工作流程：\n\n- 每次观察是在护理过程中记录的单个临床测量或发现，并且恰好属于一次就诊。\n- 每次就诊恰好属于一名患者。\n- 每次观察可归因于恰好一位提供者。\n- 每次观察都用一个LOINC代码进行注释，以表明其临床意义。\n- 每位患者可以有多次就诊，每次就诊可以有多次观察，每位提供者可以负责多次观察，每个LOINC代码可以标记多次观察。\n- 标识符 patient_id, provider_id, encounter_id, observation_id 和 loinc_code 在其各自的领域内是唯一的。\n- 在非规范化表中，patient_name 和 dob 是由 patient_id 决定的患者属性。\n\n仅使用关系模型的基本原则，包括关系、属性、主键、外键和函数依赖的定义，推导出一个适用于EHR中临床数据的完全规范化的关系模式。您的规范化应消除由给定依赖关系所暗示的更新异常，并与所述的医疗数据语义保持一致。\n\n然后，根据结构化查询语言（SQL）中参照完整性的标准定义，计算确保在您的规范化表中没有任何记录引用不存在的父记录所必需的最少不同外键约束的数量。只计算强制执行上述领域事实所隐含关系所需的非冗余约束，不要引入这些事实所不需要的可选或派生引用。\n\n仅提供最少外键约束集的整数计数作为最终答案。无需四舍五入，也无需单位。以单个数字形式表示最终答案。", "solution": "该问题要求从单个非规范化表推导出完全规范化的关系模式，并随后计算强制执行参照完整性所需的最少外键约束数量。此过程必须基于关系模型的基本原则。\n\n首先，我们通过识别属性集和由给定陈述所隐含的函数依赖（FDs）来形式化问题。\n\n全域关系，我们称之为 $R$，包含以下属性：\n$R(\\mathit{patient\\_id}, \\mathit{patient\\_name}, \\mathit{dob}, \\mathit{encounter\\_id}, \\mathit{provider\\_id}, \\mathit{observation\\_id}, \\mathit{loinc\\_code}, \\mathit{value})$\n\n从问题描述中，我们可以提取出以下函数依赖：\n1.  “在非规范化表中，`patient_name` 和 `dob` 是由 `patient_id` 决定的患者属性。” 这可以转化为函数依赖：\n    $$FD_1: \\{\\mathit{patient\\_id}\\} \\rightarrow \\{\\mathit{patient\\_name}, \\mathit{dob}\\}$$\n2.  “每次就诊恰好属于一名患者。” 这意味着就诊的标识符决定了患者的标识符。这可以转化为函数依赖：\n    $$FD_2: \\{\\mathit{encounter\\_id}\\} \\rightarrow \\{\\mathit{patient\\_id}\\}$$\n3.  “每次观察是单个临床测量……恰好属于一次就诊……可归因于恰好一位提供者……用一个LOINC代码进行注释。” 这确定了观察的标识符 $\\mathit{observation\\_id}$ 唯一地决定了它所属的就诊、负责的提供者、描述它的代码及其测量值。这可以转化为函数依赖：\n    $$FD_3: \\{\\mathit{observation\\_id}\\} \\rightarrow \\{\\mathit{encounter\\_id}, \\mathit{provider\\_id}, \\mathit{loinc\\_code}, \\mathit{value}\\}$$\n属性 $\\mathit{observation\\_id}$ 作为观察这一粒度事件的主键。初始的非规范化表存在冗余，并且容易出现更新异常。例如，患者的出生日期（$\\mathit{dob}$）可能会被多次存储，每次都与该患者的某次观察相关联，从而导致潜在的不一致性。这些问题源于传递依赖。具体来说，从 $FD_3$ 和 $FD_2$，我们有 $\\{\\mathit{observation\\_id}\\} \\rightarrow \\{\\mathit{encounter\\_id}\\}$ 和 $\\{\\mathit{encounter\\_id}\\} \\rightarrow \\{\\mathit{patient\\_id}\\}$，这意味着存在传递依赖 $\\{\\mathit{observation\\_id}\\} \\rightarrow \\{\\mathit{patient\\_id}\\}$。将此与 $FD_1$ 结合，我们得到另一个传递依赖：$\\{\\mathit{observation\\_id}\\} \\rightarrow \\{\\mathit{patient\\_name}, \\mathit{dob}\\}$。\n\n为了创建一个完全规范化的模式（通常至少达到第三范式，$3$NF，或Boyce-Codd范式，BCNF），我们将全域关系 $R$ 分解为更小的关系，使得在每个最终的关系中，每个非键属性都完全函数依赖于主键。\n\n分解过程如下：\n1.  **患者表 (Patients Table):** 为了解决涉及患者属性的传递依赖，我们基于 $FD_1$ 创建一个患者关系。\n    $$\\text{Patients}(\\underline{\\mathit{patient\\_id}}, \\mathit{patient\\_name}, \\mathit{dob})$$\n    主键是 $\\mathit{patient\\_id}$。\n\n2.  **就诊表 (Encounters Table):** 为了解决涉及患者链接的传递依赖，我们基于 $FD_2$ 创建一个就诊关系。该表将每次就诊链接到一个特定的患者。\n    $$\\text{Encounters}(\\underline{\\mathit{encounter\\_id}}, \\mathit{patient\\_id})$$\n    主键是 $\\mathit{encounter\\_id}$。属性 $\\mathit{patient\\_id}$ 将作为外键。\n\n3.  **参考表（维度表）:** 问题指出 $\\mathit{provider\\_id}$ 和 $\\mathit{loinc\\_code}$ 分别是其各自领域的唯一标识符。为了实现参照完整性，这些领域必须由关系（表）来表示。尽管没有为提供者或LOINC代码指定其他属性，我们必须定义这些实体。\n    $$\\text{Providers}(\\underline{\\mathit{provider\\_id}}, \\dots)$$\n    $$\\text{LOINCCodes}(\\underline{\\mathit{loinc\\_code}}, \\dots)$$\n    主键分别是 $\\mathit{provider\\_id}$ 和 $\\mathit{loinc\\_code}$。\n\n4.  **观察表（事实表）:** 来自 $FD_3$ 的剩余属性构成了中心表，即事实表。这个关系记录了核心的观察事件，并链接到其他实体。\n    $$\\text{Observations}(\\underline{\\mathit{observation\\_id}}, \\mathit{encounter\\_id}, \\mathit{provider\\_id}, \\mathit{loinc\\_code}, \\mathit{value})$$\n    主键是 $\\mathit{observation\\_id}$。属性 $\\mathit{encounter\\_id}$、$\\mathit{provider\\_id}$ 和 $\\mathit{loinc\\_code}$ 将作为外键。\n\n最终得到的规范化模式包含 $5$ 个关系：`Patients`、`Providers`、`LOINCCodes`、`Encounters` 和 `Observations`。现在，我们必须确定为强制执行问题中定义的关系所需的最少外键（FK）约束集。外键约束确保引用表中的一个值（或一组值）在被引用表的主键中有一个匹配的值。\n\n让我们列举这个模式的非冗余外键约束：\n1.  **从 `Encounters` 到 `Patients`：** “每次就诊恰好属于一名患者”这一关系由 `Encounters` 表中的属性 $\\mathit{patient\\_id}$ 建模。为确保每次就诊都与一个有效的、存在的患者相关联，我们需要一个约束。\n    - FK$1$：`Encounters.patient_id` 必须引用 `Patients.patient_id`。\n\n2.  **从 `Observations` 到其他表：** `Observations` 表是连接各个实体的中心。\n    - 为强制执行“每次观察……恰好属于一次就诊”：\n        - FK$2$：`Observations.encounter_id` 必须引用 `Encounters.encounter_id`。\n    - 为强制执行“每次观察可归因于恰好一位提供者”：\n        - FK$3$：`Observations.provider_id` 必须引用 `Providers.provider_id`。\n    - 为强制执行“每次观察都用一个LOINC代码进行注释”：\n        - FK$4$：`Observations.loinc_code` 必须引用 `LOINCCodes.loinc_code`。\n\n这 $4$ 个约束是最小且非冗余的。从一次观察到一个患者的完整性链条通过两个约束传递地被强制执行：FK$2$（观察 $\\rightarrow$ 就诊）和 FK$1$（就诊 $\\rightarrow$ 患者）。如果从 `Observations` 表直接添加一个到 `Patients` 表的外键，首先需要在 `Observations` 表中添加一个 `patient_id` 列。这将违反规范化原则，因为 `patient_id` 将通过 `encounter_id` 传递依赖于主键 `observation_id`，从而重新引入我们试图消除的冗余。因此，这样的约束不属于规范化模式的最小集合。\n\n最少不同外键约束的数量是已识别约束的总和：\n- 来自 `Encounters` 表的 $1$ 个约束。\n- 来自 `Observations` 表的 $3$ 个约束。\n\n最少约束总数 = $1 + 3 = 4$。", "answer": "$$\\boxed{4}$$", "id": "4833282"}, {"introduction": "在真实世界的医疗分析中，数据往往来自不同单位标准的多个来源。本练习探讨了一个关键的数据质量问题：单位不一致性，并量化了它对分析结果（如平均血糖水平）可能造成的偏差。通过从基本原理推导单位换算并计算错误所带来的影响，你将深刻理解在数据整合管道中进行语义标准化的重要性 [@problem_id:4833263]。", "problem": "一家医院的数据仓库将来自两个实验室的血糖测量数据整合到电子健康记录（EHR）分析流程中。一个实验室以毫克/分升（mg/dL）报告血浆葡萄糖，而另一个实验室以毫摩尔/升（mmol/L）报告。您正在使用葡萄糖的分子量将单位标准化为毫摩尔/升（mmol/L）。使用物质的量的定义，其中摩尔数 $n$ 等于质量 $m$ 除以分子量 $M$，即 $n = m/M$，以及 $1\\,\\text{dL} = 0.1\\,\\text{L}$ 和 $1\\,\\text{mg} = 10^{-3}\\,\\text{g}$ 这两个事实，推导出从 mg/dL 到 mmol/L 的转换关系。葡萄糖的分子量为 $M = 180.16\\,\\text{g/mol}$。\n\n考虑一个由10名患者组成的队列，他们在同一天有以下血糖测量值：\n- 实验室A（以 mg/dL 报告）：$75$、$90$、$95$、$110$、$130$、$160$、$180$、$200$。\n- 实验室B（以 mmol/L 报告）：$7.2$、$9.5$。\n\n假设正确的聚合方法是在计算所有患者的算术平均值之前，将所有值标准化为 mmol/L。\n\n然而，由于在提取-转换-加载（extract-transform-load）步骤中单位标志丢失，一个错误的流程将每个数值都当作以 mg/dL 为单位处理，并对每个值（包括最初以 mmol/L 为单位的值）都应用了 mg/dL 到 mmol/L 的转换。\n\n使用从 $n = m/M$ 推导出的单位转换第一性原理和算术平均值的定义，通过一个合并的计算回答以下问题：\n- 计算由于单位错位导致的正确队列平均值（mmol/L）与错误队列平均值（mmol/L）之间的绝对偏差（差值的绝对值）。\n\n以毫摩尔/升（mmol/L）表示最终量，并将您的答案四舍五入到四位有效数字。", "solution": "该问题要求计算正确计算的平均血糖水平与错误计算的平均血糖水平之间的绝对偏差。这包括首先从第一性原理推导单位转换因子，然后构建正确和错误平均值的表达式，最后计算它们的绝对差。\n\n首先，我们从问题陈述中确定必要的常数和数据。\n葡萄糖的分子量给定为 $M = 180.16\\,\\text{g/mol}$。\n该队列由 $N=10$ 名患者组成。\n来自实验室A的数据，以毫克/分升（mg/dL）报告，是一组 $N_A = 8$ 个值：$X_A = \\{75, 90, 95, 110, 130, 160, 180, 200\\}$。\n来自实验室B的数据，以毫摩尔/升（mmol/L）报告，是一组 $N_B = 2$ 个值：$X_B = \\{7.2, 9.5\\}$。\n\n第一步是基于给定的基本关系 $n = m/M$ 推导从 mg/dL 到 mmol/L 的转换因子，其中 $n$ 是物质的量（单位为摩尔），$m$ 是质量，$M$ 是分子量。我们还使用定义 $1\\,\\text{dL} = 0.1\\,\\text{L}$ 和 $1\\,\\text{mg} = 10^{-3}\\,\\text{g}$。\n\n设 $C_{mg/dL}$ 是一个以 mg/dL 为单位的浓度值。\n要将其转换为克/升（g/L），我们应用单位转换：\n$$ C \\left[ \\frac{\\text{mg}}{\\text{dL}} \\right] = C \\frac{1\\,\\text{mg}}{1\\,\\text{dL}} = C \\frac{10^{-3}\\,\\text{g}}{0.1\\,\\text{L}} = C \\cdot 10^{-2} \\left[ \\frac{\\text{g}}{\\text{L}} \\right] $$\n这就得到了质量浓度。为了求出摩尔浓度（mol/L），我们将质量浓度除以分子量 $M$：\n$$ C \\left[ \\frac{\\text{mol}}{\\text{L}} \\right] = \\frac{C \\cdot 10^{-2} \\left[ \\frac{\\text{g}}{\\text{L}} \\right]}{M \\left[ \\frac{\\text{g}}{\\text{mol}} \\right]} = \\frac{C \\cdot 10^{-2}}{M} \\left[ \\frac{\\text{mol}}{\\text{L}} \\right] $$\n最后，要从 mol/L 转换为 mmol/L，我们利用 $1\\,\\text{mol} = 1000\\,\\text{mmol} = 10^3\\,\\text{mmol}$ 这一事实：\n$$ C \\left[ \\frac{\\text{mmol}}{\\text{L}} \\right] = \\frac{C \\cdot 10^{-2}}{M} \\left[ \\frac{\\text{mol}}{\\text{L}} \\right] \\times 10^3 \\left[ \\frac{\\text{mmol}}{\\text{mol}} \\right] = C \\cdot \\frac{10}{M} \\left[ \\frac{\\text{mmol}}{\\text{L}} \\right] $$\n设 $f$ 为转换因子，使得一个以 mg/dL 为单位的值 $x_{mg/dL}$ 通过 $x_{mmol/L} = f \\cdot x_{mg/dL}$ 转换为 $x_{mmol/L}$。根据我们的推导：\n$$ f = \\frac{10}{M} = \\frac{10}{180.16} = \\frac{1}{18.016} $$\n\n接下来，我们定义正确的队列平均值 $\\mu_{\\text{correct}}$。它的计算方法是，首先将所有测量值转换为 mmol/L 的标准单位，然后计算算术平均值。设 $A_i$ 为来自实验室A的第 $i$ 个值，$B_j$ 为来自实验室B的第 $j$ 个值。\n来自实验室A的值必须进行转换：$f \\cdot A_i$。来自实验室B的值已经是正确的单位。\n$$ \\mu_{\\text{correct}} = \\frac{1}{N} \\left( \\sum_{i=1}^{N_A} (f \\cdot A_i) + \\sum_{j=1}^{N_B} B_j \\right) = \\frac{1}{N} \\left( f \\sum_{i=1}^{N_A} A_i + \\sum_{j=1}^{N_B} B_j \\right) $$\n\n现在，我们定义错误的队列平均值 $\\mu_{\\text{erroneous}}$。它的计算方法是，错误地将所有数值都当作以 mg/dL 为单位，并在求平均值之前对所有值应用转换因子 $f$。\n$$ \\mu_{\\text{erroneous}} = \\frac{1}{N} \\left( \\sum_{i=1}^{N_A} (f \\cdot A_i) + \\sum_{j=1}^{N_B} (f \\cdot B_j) \\right) = \\frac{f}{N} \\left( \\sum_{i=1}^{N_A} A_i + \\sum_{j=1}^{N_B} B_j \\right) $$\n\n绝对偏差 $\\Delta_{\\mu}$ 是正确平均值和错误平均值之差的绝对值。\n$$ \\Delta_{\\mu} = |\\mu_{\\text{correct}} - \\mu_{\\text{erroneous}}| $$\n$$ \\Delta_{\\mu} = \\left| \\frac{1}{N} \\left( f \\sum A_i + \\sum B_j \\right) - \\frac{f}{N} \\left( \\sum A_i + \\sum B_j \\right) \\right| $$\n展开绝对值内的各项：\n$$ \\Delta_{\\mu} = \\left| \\frac{f}{N}\\sum A_i + \\frac{1}{N}\\sum B_j - \\frac{f}{N}\\sum A_i - \\frac{f}{N}\\sum B_j \\right| $$\n涉及 $\\sum A_i$ 的项相互抵消：\n$$ \\Delta_{\\mu} = \\left| \\frac{1}{N}\\sum B_j - \\frac{f}{N}\\sum B_j \\right| = \\left| \\frac{1}{N} \\left( \\sum B_j \\right) (1-f) \\right| $$\n由于 $f = 1/18.016$ 介于0和1之间，所以项 $(1-f)$ 是正的。葡萄糖值之和 $\\sum B_j$ 也是正的。因此，不需要绝对值。\n$$ \\Delta_{\\mu} = \\frac{1}{N} \\left( \\sum_{j=1}^{N_B} B_j \\right) (1-f) $$\n这个合并的表达式表明，偏差仅取决于被错误转换的数据、总样本量和转换因子。\n\n现在我们将数值代入这个表达式。\n患者总数为 $N = N_A + N_B = 8 + 2 = 10$。\n来自实验室B的值的总和是 $\\sum B_j = 7.2 + 9.5 = 16.7$。\n转换因子是 $f = 1/18.016$。\n$$ \\Delta_{\\mu} = \\frac{1}{10} (16.7) \\left(1 - \\frac{1}{18.016}\\right) $$\n$$ \\Delta_{\\mu} = 1.67 \\left(\\frac{18.016 - 1}{18.016}\\right) $$\n$$ \\Delta_{\\mu} = 1.67 \\left(\\frac{17.016}{18.016}\\right) $$\n进行计算：\n$$ \\Delta_{\\mu} \\approx 1.67 \\times 0.94449378... = 1.577304618... $$\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $1$、$5$、$7$ 和 $7$。第五位有效数字是 $3$，所以我们向下舍入。\n$$ \\Delta_{\\mu} \\approx 1.577 $$\n绝对偏差约为 $1.577\\,\\text{mmol/L}$。", "answer": "$$\\boxed{1.577}$$", "id": "4833263"}, {"introduction": "为了实现不同医疗系统间的无缝数据交换，行业需要像 FHIR (Fast Healthcare Interoperability Resources) 这样的现代互操作性标准。这个练习让你亲身体验如何根据 FHIR 规范来验证数据。你将实现一个验证规则，用以检查临床观察数据（Observation）是否符合预定义的 LOINC 术语集，这是开发和维护合规的互联健康应用所必需的一项关键实践 [@problem_id:4833269]。", "problem": "您正在一个程序化验证框架内对一个源自快速医疗互操作性资源 (FHIR) 的约束进行建模。在 FHIR 中，`Observation.code` 是一个 `CodeableConcept`（可编码概念），它可以包含多个编码（coding），每个编码都是一个系统统一资源标识符 (URI) 和一个代码字符串的配对。您将创建一个 FHIR 配置（profile）的抽象表示，该配置将 `Observation.code` 限制为一个逻辑观察标识符名称和代码 (LOINC) 值集，并实现强制执行“必需”绑定的验证规则。最终程序必须计算一组测试实例的验证结果，包括实例使用了值集扩展之外的代码的情况。\n\n基本原理：\n- 集合论和一阶逻辑：给定一个允许的代码集合 $E$ 和一个固定的系统 $S$，一个包含 $n$ 个编码 $[(s_1,k_1),\\dots,(s_n,k_n)]$ 的 `CodeableConcept` $C$ 在“必需”绑定下是有效的，当且仅当存在一个索引 $i$（$1 \\le i \\le n$），使得 $s_i = S$ 且 $k_i \\in E$。\n- FHIR 语义：与一个值集的“必需”绑定断言，被编码的元素必须从该值集的扩展中选取。对于 `CodeableConcept`，如果其任意一个编码符合该绑定，则其有效性得到满足；否则，该元素无效。\n\n任务：\n1. 将 LOINC 系统定义为规范 URI 字符串 $S = \\text{\"http://loinc.org\"}$。\n2. 将值集扩展 $E$ 定义为允许的 LOINC 代码字符串集合。使用以下扩展：$E = \\{\\text{\"55284-4\"}, \\text{\"1234-5\"}, \\text{\"7890-1\"}\\}$。将这些视为精确的字符串匹配。\n3. 定义一个验证函数，该函数给定一个表示为编码列表 $[(s_1,k_1),\\dots,(s_n,k_n)]$ 的 `CodeableConcept` $C$，返回一个布尔值，指示其是否符合“必需”绑定。该谓词是：\n$$\\mathrm{valid}(C,E,S) \\iff \\exists i \\in \\{1,\\dots,n\\}: (s_i = S) \\land (k_i \\in E).$$\n如果 $n = 0$，则该谓词为假。\n4. 实现一个完整、可运行的程序，将此验证应用于下面的测试套件，并打印一行包含指定格式的布尔结果列表。\n\n测试套件：\n- 案例 $1$ (一般的“理想路径”)：$C = [(\\text{\"http://loinc.org\"}, \\text{\"55284-4\"})]$。\n- 案例 $2$ (在扩展之外)：$C = [(\\text{\"http://loinc.org\"}, \\text{\"99999-9\"})]$。\n- 案例 $3$ (系统不匹配)：$C = [(\\text{\"http://snomed.info/sct\"}, \\text{\"55284-4\"})]$，其中医学系统命名法—临床术语 (SNOMED CT) 是一个不同的系统。\n- 案例 $4$ (多个编码，一个有效)：$C = [(\\text{\"http://loinc.org\"}, \\text{\"55284-4\"}), (\\text{\"http://snomed.info/sct\"}, \\text{\"123456\"})]$。\n- 案例 $5$ (边界情况，空编码列表)：$C = []$。\n- 案例 $6$ (多个 LOINC 编码，一个有效，一个无效)：$C = [(\\text{\"http://loinc.org\"}, \\text{\"1234-5\"}), (\\text{\"http://loinc.org\"}, \\text{\"99999-9\"})]$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result1},\\text{result2},\\dots]$）。\n- 每个结果必须是一个布尔值（$\\text{True}$ 或 $\\text{False}$），按上述顺序对应于相应测试用例的有效性。\n\n角度单位、物理单位和百分比格式不适用于此问题，因此无需考虑。", "solution": "问题陈述已经过验证，被认为是自洽的、科学上基于集合论和既定的医疗信息学标准 (FHIR)，并且是良构的。解决方案所需的所有组件都已提供且逻辑上一致。\n\n任务是构建一个验证函数，用于确定一个快速医疗互操作性资源 (FHIR) 的 `CodeableConcept` 数据结构是否符合与指定值集的“必需”绑定。此问题是一个将一阶逻辑应用于数据结构验证的练习。\n\n该问题的基本组成部分是：\n1. 一个目标编码系统，定义为规范 URI 字符串 $S = \\text{\"http://loinc.org\"}$。这代表逻辑观察标识符名称和代码 (LOINC) 系统。\n2. 一个值集扩展，即目标系统内允许的代码集合。该集合给定为 $E = \\{\\text{\"55284-4\"}, \\text{\"1234-5\"}, \\text{\"7890-1\"}\\}$。\n3. 一个 `CodeableConcept` 实例 $C$，表示为一个编码列表。每个编码是一个元组 $(s_i, k_i)$，其中 $s_i$ 是一个系统 URI 字符串，$k_i$ 是一个代码字符串。设 $C$ 中的编码数量为 $n$。\n\n验证规则由以下逻辑谓词正式定义：\n$$ \\mathrm{valid}(C, E, S) \\iff \\exists i \\in \\{1,\\dots,n\\}: (s_i = S) \\land (k_i \\in E) $$\n该谓词断言，一个 `CodeableConcept` $C$ 是有效的，当且仅当其列表中存在至少一个编码 $(s_i, k_i)$，使得其系统 $s_i$ 与要求的系统 $S$ 匹配，并且其代码 $k_i$ 是所允许的值集扩展 $E$ 的成员。如果编码列表为空 ($n=0$)，那么对空索引集的存在量化为假，因此该 `CodeableConcept` 无效。\n\n为实现此验证，我们将设计一个函数，它以 `CodeableConcept` $C$ 作为输入。在此函数内部，我们将遍历输入列表 $C$ 中的每个编码 $(s_i, k_i)$。对于每个编码，我们执行两次比较：\n1. 系统字符串 $s_i$ 是否与目标系统字符串 $S$ 完全相同？\n2. 代码字符串 $k_i$ 是否存在于值集扩展 $E$ 中？\n\n如果任何一个编码同时满足这两个条件，那么存在条件 $\\exists i$ 就得到满足。函数可以立即终止并返回 `True`。如果函数遍历完 $C$ 中的所有编码都没有找到满足这两个条件的编码，这意味着不存在这样的编码。在这种情况下，函数应在循环完成后返回 `False`。这种方法正确处理了列表为空的情况 ($n=0$)，因为循环不会执行，函数将继续执行最后的 return 语句，从而得出 `False`。\n\n为实现高效，值集扩展 $E$ 应存储在提供快速成员资格测试的数据结构中。哈希集（在 Python 中为 `set`）是理想选择，其查找的平均时间复杂度为 $O(1)$。\n\n让我们将此逻辑应用于所提供的测试套件：\n- **案例 1**：$C = [(\\text{\"http://loinc.org\"}, \\text{\"55284-4\"})]$。这里，$n=1$。单个编码的 $s_1 = S$ 且 $k_1 \\in E$。谓词得到满足。结果：`True`。\n- **案例 2**：$C = [(\\text{\"http://loinc.org\"}, \\text{\"99999-9\"})]$。这里，$n=1$。该编码的 $s_1 = S$，但 $k_1 = \\text{\"99999-9\"} \\notin E$。谓词未得到满足。结果：`False`。\n- **案例 3**：$C = [(\\text{\"http://snomed.info/sct\"}, \\text{\"55284-4\"})]$。这里，$n=1$。该编码的 $k_1 \\in E$，但 $s_1 = \\text{\"http://snomed.info/sct\"} \\neq S$。谓词未得到满足。结果：`False`。\n- **案例 4**：$C = [(\\text{\"http://loinc.org\"}, \\text{\"55284-4\"}), (\\text{\"http://snomed.info/sct\"}, \\text{\"123456\"})]$。这里，$n=2$。第一个编码 $(s_1, k_1)$ 具有 $s_1 = S$ 和 $k_1 \\in E$。由于我们已找到一个有效编码，存在条件已满足，我们无需检查列表的其余部分。结果：`True`。\n- **案例 5**：$C = []$。这里，$n=0$。编码集合为空。根据定义，谓词为假。结果：`False`。\n- **案例 6**：$C = [(\\text{\"http://loinc.org\"}, \\text{\"1234-5\"}), (\\text{\"http://loinc.org\"}, \\text{\"99999-9\"})]$。这里，$n=2$。第一个编码具有 $s_1 = S$ 和 $k_1 = \\text{\"1234-5\"} \\in E$。条件得到满足。第二个编码无效的事实无关紧要。结果：`True`。\n\n程序将实现这一逻辑并将其应用于每个测试用例，将布尔结果收集到一个列表中，以便进行最终的格式化打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Implements and runs the FHIR CodeableConcept validation logic\n    for a \"required\" binding against a set of test cases.\n    \"\"\"\n    \n    # Task 1: Define the LOINC system as the canonical URI string S.\n    # $S = \\text{\"http://loinc.org\"}$\n    LOINC_SYSTEM = \"http://loinc.org\"\n\n    # Task 2: Define a value set expansion E.\n    # $E = \\{\\text{\"55284-4\"}, \\text{\"1234-5\"}, \\text{\"7890-1\"}\\}$\n    # A set is used for efficient O(1) average time complexity for lookups.\n    VALUE_SET_EXPANSION = {\"55284-4\", \"1234-5\", \"7890-1\"}\n\n    # The test suite as defined in the problem statement.\n    # Each element is a CodeableConcept C represented as a list of codings.\n    # A coding is a tuple of (system, code).\n    test_cases = [\n        # Case 1: General \"happy path\"\n        [(\"http://loinc.org\", \"55284-4\")],\n        # Case 2: Outside expansion\n        [(\"http://loinc.org\", \"99999-9\")],\n        # Case 3: System mismatch\n        [(\"http://snomed.info/sct\", \"55284-4\")],\n        # Case 4: Multiple codings, one valid\n        [(\"http://loinc.org\", \"55284-4\"), (\"http://snomed.info/sct\", \"123456\")],\n        # Case 5: Boundary, empty coding list\n        [],\n        # Case 6: Multiple LOINC codings, one valid and one invalid\n        [(\"http://loinc.org\", \"1234-5\"), (\"http://loinc.org\", \"99999-9\")],\n    ]\n\n    def is_valid_codeable_concept(concept, system, value_set):\n        \"\"\"\n        Validates a CodeableConcept against a required binding to a value set.\n        \n        The predicate is:\n        valid(C, E, S) = exists i in {1,...,n}: (s_i = S) and (k_i in E)\n\n        Args:\n            concept (list): The CodeableConcept, a list of (system, code) tuples.\n            system (str): The required system URI ($S$).\n            value_set (set): The set of allowed codes ($E$).\n\n        Returns:\n            bool: True if the concept is valid, False otherwise.\n        \"\"\"\n        # Iterate through each coding in the CodeableConcept\n        for s_i, k_i in concept:\n            # Check if the coding's system and code match the requirements.\n            # (s_i = S) AND (k_i in E)\n            if s_i == system and k_i in value_set:\n                # If a valid coding is found, the existential condition is met.\n                return True\n        \n        # If the loop completes without finding a valid coding, it fails validation.\n        # This also handles the case of an empty concept list.\n        return False\n\n    results = []\n    for case in test_cases:\n        # Apply the validation function to each test case.\n        result = is_valid_codeable_concept(case, LOINC_SYSTEM, VALUE_SET_EXPANSION)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Example: [True,False,False,True,False,True]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4833269"}]}