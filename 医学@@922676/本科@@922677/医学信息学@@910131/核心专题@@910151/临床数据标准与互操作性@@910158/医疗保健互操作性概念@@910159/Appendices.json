{"hands_on_practices": [{"introduction": "真正的互操作性始于数据层面。本练习旨在解决一个常见而关键的挑战：协调来自不同系统、使用不同单位的实验室结果。通过将测量值转换为标准单位，并根据参考范围进行归一化，您将实践一项核心的数据分析技能，从而实现有意义的比较和自动化的临床决策支持。该练习 [@problem_id:4859949] 展示了语义互操作性的精髓。", "problem": "一家医院的健康信息交换（HIE）系统整合了来自多个来源的实验室数据，这些数据使用逻辑观察标识符命名和编码（LOINC）进行编码，并遵循统一计量单位编码（UCUM）以异构单位报告。为了实现可互操作的分析，流程管道必须统一单位并根据标准化参考区间对值进行归一化。考虑一名空腹成年男性的三种分析物，每种分析物都带有以下测量值和用于分析的目标标准单位：血浆葡萄糖报告为 $95$ mg/dL（目标单位：mmol/L），血清肌酐报告为 $1.3$ mg/dL（目标单位：$\\mu\\text{mol/L}$），以及丙氨酸转氨酶（ALT）报告为 $58$ U/L（目标单位：U/L）。用于归一化步骤的相应标准化参考区间为：葡萄糖 $[3.9, 5.5]$ mmol/L，肌酐 $[60, 110]$ $\\mu\\text{mol/L}$，以及ALT $[10, 40]$ U/L。对于质量到物质的量的转换，使用葡萄糖的摩尔质量 $M_{\\text{glucose}} = 180.15588$ g/mol 和肌酐的摩尔质量 $M_{\\text{creatinine}} = 113.12$ g/mol。\n\n假设对于每种分析物，其群体分布近似为正态分布，并且所提供的参考区间代表了分布的中心 $95\\%$。通过将每个分析物的测量值转换为目标标准单位，然后计算其相对于参考区间的标准化分数，来对每个分析物进行归一化。如果一个分析物的归一化分数的绝对值超过 $2$，则将其定义为异常值。\n\n计算在单位统一和归一化后被标记为异常值的分析物的比例。将最终比例表示为小数，并将您的答案四舍五入到四位有效数字。该比例是无单位的。", "solution": "用户希望我扮演一个严谨细致的STEM教授来解决这个问题。我必须首先验证问题的陈述。\n\n### 步骤 1：提取给定信息\n- **分析物 1（血浆葡萄糖）：**\n  - 测量值：$95$ mg/dL\n  - 目标单位：mmol/L\n  - 摩尔质量（$M_{\\text{glucose}}$）：$180.15588$ g/mol\n  - 参考区间：$[3.9, 5.5]$ mmol/L\n- **分析物 2（血清肌酐）：**\n  - 测量值：$1.3$ mg/dL\n  - 目标单位：$\\mu\\text{mol/L}$\n  - 摩尔质量（$M_{\\text{creatinine}}$）：$113.12$ g/mol\n  - 参考区间：$[60, 110]$ $\\mu\\text{mol/L}$\n- **分析物 3（丙氨酸转氨酶，ALT）：**\n  - 测量值：$58$ U/L\n  - 目标单位：U/L\n  - 参考区间：$[10, 40]$ U/L\n- **归一化假设：** 参考区间代表了近似正态分布的中心 $95\\%$。\n- **异常值定义：** 如果一个分析物的归一化分数的绝对值超过 $2$，则为异常值。\n- **目标：** 计算被标记为异常值的分析物的比例，表示为四舍五入到四位有效数字的小数。\n\n### 步骤 2：使用提取的给定信息进行验证\n- **科学依据：** 该问题基于标准的临床实验室实践。它使用了正确的术语（LOINC, UCUM, HIE），真实的分析物（葡萄糖，肌酐，ALT），标准单位和正确的摩尔质量。单位统一和根据参考区间进行归一化的过程是医学信息学和临床数据分析中的一项基本任务。将 $95\\%$ 参考区间与正态分布联系起来的统计假设是一种常见且有效的简化方法。\n- **良态问题：** 所有必要的数据（测量值、目标单位、摩尔质量、参考区间）和定义（异常值标准）都已提供。目标明确陈述，且通往唯一解的路径定义清晰。\n- **客观性：** 问题陈述是定量的，没有主观或模糊的语言。\n\n### 步骤 3：结论和行动\n该问题科学上合理、定义明确且内部一致。判定为**有效**。我将继续进行完整解答。\n\n任务是计算被标记为异常值的分析物的比例。对 $3$ 种分析物中的每一种进行处理，包括两个主要步骤：单位统一和数值归一化。如果一个分析物的归一化分数的绝对值超过 $2$，则将其分类为异常值。\n\n归一化的前提是，表示为 $[L, U]$ 的参考区间对应于均值为 $\\mu$、标准差为 $\\sigma$ 的正态分布的中心 $95\\%$。对于正态分布，包含中心 $95\\%$ 数据的区间由 $\\mu \\pm 1.96\\sigma$ 给出。因此，我们可以设定 $L = \\mu - 1.96\\sigma$ 和 $U = \\mu + 1.96\\sigma$。这些关系使我们能够估计分布的参数：\n均值 $\\mu$ 是区间的中点：\n$$ \\mu = \\frac{L + U}{2} $$\n标准差 $\\sigma$ 从区间的宽度导出：\n$$ U - L = (\\mu + 1.96\\sigma) - (\\mu - 1.96\\sigma) = 3.92\\sigma \\implies \\sigma = \\frac{U - L}{3.92} $$\n对于一个（已统一单位的）测量值 $X$，其归一化分数，或称Z分数，为：\n$$ Z = \\frac{X - \\mu}{\\sigma} $$\n异常值的条件是 $|Z| > 2$。\n\n我们将此程序应用于每种分析物。\n\n**1. 血浆葡萄糖**\n- 测量值：$95$ mg/dL。\n- 目标单位：mmol/L。\n- 摩尔质量：$M_{\\text{glucose}} = 180.15588$ g/mol。\n- 参考区间：$[L_1, U_1] = [3.9, 5.5]$ mmol/L。\n\n首先，我们进行单位转换。我们使用换算因子 $1$ dL = $0.1$ L, $1$ g = $1000$ mg, 以及 $1$ mol = $1000$ mmol。\n目标单位下的值 $X_1$ 为：\n$$ X_1 = 95 \\frac{\\text{mg}}{\\text{dL}} \\times \\frac{1 \\text{ dL}}{0.1 \\text{ L}} \\times \\frac{1 \\text{ g}}{1000 \\text{ mg}} \\times \\frac{1 \\text{ mol}}{180.15588 \\text{ g}} \\times \\frac{1000 \\text{ mmol}}{1 \\text{ mol}} $$\n$$ X_1 = \\frac{950}{180.15588} \\frac{\\text{mmol}}{\\text{L}} \\approx 5.2731 \\frac{\\text{mmol}}{\\text{L}} $$\n接下来，我们计算归一化参数和Z分数。\n$$ \\mu_1 = \\frac{3.9 + 5.5}{2} = 4.7 \\text{ mmol/L} $$\n$$ \\sigma_1 = \\frac{5.5 - 3.9}{3.92} = \\frac{1.6}{3.92} \\text{ mmol/L} $$\n葡萄糖的Z分数为：\n$$ Z_1 = \\frac{X_1 - \\mu_1}{\\sigma_1} = \\frac{\\frac{950}{180.15588} - 4.7}{\\frac{1.6}{3.92}} \\approx \\frac{5.2731 - 4.7}{0.40816} \\approx 1.4041 $$\n我们检查异常值条件：$|Z_1| \\approx 1.4041$。由于 $|Z_1| \\le 2$，葡萄糖**不是异常值**。\n\n**2. 血清肌酐**\n- 测量值：$1.3$ mg/dL。\n- 目标单位：$\\mu\\text{mol/L}$。\n- 摩尔质量：$M_{\\text{creatinine}} = 113.12$ g/mol。\n- 参考区间：$[L_2, U_2] = [60, 110]$ $\\mu\\text{mol/L}$。\n\n首先，进行单位转换。我们使用 $1$ dL = $0.1$ L, $1$ g = $1000$ mg, 以及 $1$ mol = $10^6$ $\\mu$mol。\n目标单位下的值 $X_2$ 为：\n$$ X_2 = 1.3 \\frac{\\text{mg}}{\\text{dL}} \\times \\frac{1 \\text{ dL}}{0.1 \\text{ L}} \\times \\frac{1 \\text{ g}}{1000 \\text{ mg}} \\times \\frac{1 \\text{ mol}}{113.12 \\text{ g}} \\times \\frac{10^6 \\mu\\text{mol}}{1 \\text{ mol}} $$\n$$ X_2 = \\frac{13000}{113.12} \\frac{\\mu\\text{mol}}{\\text{L}} \\approx 114.922 \\frac{\\mu\\text{mol}}{\\text{L}} $$\n接下来，我们计算Z分数。\n$$ \\mu_2 = \\frac{60 + 110}{2} = 85 \\text{ }\\mu\\text{mol/L} $$\n$$ \\sigma_2 = \\frac{110 - 60}{3.92} = \\frac{50}{3.92} \\text{ }\\mu\\text{mol/L} $$\n肌酐的Z分数为：\n$$ Z_2 = \\frac{X_2 - \\mu_2}{\\sigma_2} = \\frac{\\frac{13000}{113.12} - 85}{\\frac{50}{3.92}} \\approx \\frac{114.922 - 85}{12.7551} \\approx 2.3459 $$\n我们检查异常值条件：$|Z_2| \\approx 2.3459$。由于 $|Z_2| > 2$，肌酐是**一个异常值**。\n\n**3. 丙氨酸转氨酶 (ALT)**\n- 测量值：$58$ U/L。\n- 目标单位：U/L。\n- 参考区间：$[L_3, U_3] = [10, 40]$ U/L。\n\n测量值已经使用了目标单位，因此 $X_3 = 58$ U/L。无需进行单位转换。\n我们计算归一化参数和Z分数。\n$$ \\mu_3 = \\frac{10 + 40}{2} = 25 \\text{ U/L} $$\n$$ \\sigma_3 = \\frac{40 - 10}{3.92} = \\frac{30}{3.92} \\text{ U/L} $$\nALT的Z分数为：\n$$ Z_3 = \\frac{X_3 - \\mu_3}{\\sigma_3} = \\frac{58 - 25}{\\frac{30}{3.92}} = \\frac{33 \\times 3.92}{30} = 1.1 \\times 3.92 = 4.312 $$\n我们检查异常值条件：$|Z_3| = 4.312$。由于 $|Z_3| > 2$，ALT是**一个异常值**。\n\n**最终计算**\n在分析的 $3$ 种分析物中，有 $2$ 种被标记为异常值（肌酐和ALT）。作为异常值的分析物比例是：\n$$ \\text{异常值比例} = \\frac{\\text{异常值数量}}{\\text{分析物总数}} = \\frac{2}{3} $$\n问题要求答案以小数形式表示，并四舍五入到四位有效数字。\n$$ \\frac{2}{3} \\approx 0.666666... $$\n四舍五入到四位有效数字得到 $0.6667$。", "answer": "$$\n\\boxed{0.6667}\n$$", "id": "4859949"}, {"introduction": "在临床实践中，各项事件是相互关联的。创建患者记录、记录一次就诊和录入一项观察结果并非孤立的操作。本练习 [@problem_id:4859896] 要求您在一个 FHIR 事务包（transaction bundle）中管理这些依赖关系，确保相关资源能以正确的顺序被创建。通过将问题建模为有向图并应用拓扑排序算法，您将深入理解系统如何以原子方式可靠地处理复杂、多部分的临床数据更新。", "problem": "您需要编写一个完整的程序，构建并分析快速医疗互操作性资源 (Fast Healthcare Interoperability Resources, FHIR) 事务包，以演示相关临床资源的原子性创建，并在一个简化的、与实现无关的模型下确定一个确定性的服务器处理顺序，该模型与医疗互操作性中原子事务的思想一致。\n\n基本原则和假设：\n- 原子性、一致性、隔离性、持久性 (ACID) 事务：一个原子事务要么提交所有包含的操作，要么不做任何操作。在此观点下，服务器必须评估整个请求操作集，然后要么全部应用，要么全部回滚。在本问题中，原子性被建模为存在一个执行顺序，该顺序满足事务包内所有的资源间引用。\n- 图依赖解析：给定一个有向图 $G = (V, E)$，其中有 $|V| = n$ 个条目和 $|E| = m$ 条有向边，每条边 $(u, v) \\in E$ 表示条目 $u$ 必须在条目 $v$ 之前处理。一个有效的处理顺序存在，当且仅当 $G$ 是一个有向无环图 (DAG)。拓扑排序可以在 $\\mathcal{O}(n + m)$ 时间内找到。\n\n您的程序必须：\n- 将下面测试套件中定义的四个 FHIR 事务包构建为内存中的结构。\n- 对于每个事务包，通过统一资源名称 (URN) `fullUrl` 确定一个尊重包内引用的处理顺序。顺序确定过程建模如下：\n  - 构建一个有向图 $G$，其中每个条目是一个节点。对于任何条目 $i$，如果它包含一个 FHIR 引用，指向同一事务包中条目 $j$ 对应的 `fullUrl`，则添加一条有向边 $j \\to i$。这表示 $j$ 必须在 $i$ 之前处理。\n  - 使用 Kahn 算法计算拓扑排序，并采用确定性的平局决胜规则：在入度为 $0$ 的节点中，总是优先选择原始条目索引最小的那个。持续此过程，直到没有节点剩下或无法再进行下去。\n  - 如果所有节点都已排序，则返回包含从零开始的索引的结果列表。如果检测到环（即，仍有入度 $> 0$ 的节点），则返回一个空列表，表示该事务在此模型下无法进行拓扑排序。\n- 引用提取：将任何名为 \"reference\" 且其值为字符串的字典字段视为候选 FHIR 引用。仅当一个引用的字符串值与同一事务包中某个条目的 `fullUrl` 完全匹配时，该引用才被视为包内依赖。递归遍历资源，以便可以在任何深度找到引用，包括像 `derivedFrom` 这样的数组中。\n- 不使用外部输入；事务包必须在程序中构建。\n\n需要建模的事务语义：\n- 所有请求都使用超文本传输协议 (HTTP) POST 来创建资源。条件创建约束 (`ifNoneExist`) 在这个简化模型中不改变依赖规则；只有通过 `fullUrl` 的显式包内引用会影响排序。\n\n覆盖典型和边缘场景的测试套件：\n- 案例 A（理想路径，包含多个依赖和乱序条目）：\n  - 索引为 $0, 1, 2, 3$ 的条目分别代表一个引用了某个患者（Patient）的就诊（Encounter）、一个同时引用了该就诊和患者的观察（Observation）、该患者本身，以及另一个引用了该患者的观察。就诊和观察出现在患者之前，以测试算法能否正确地对它们进行重新排序。\n- 案例 B（边界情况：单个条目无引用）：\n  - 一个没有任何引用的观察。\n- 案例 C（边缘情况：环）：\n  - 两个观察通过 `derivedFrom` 互相引用，形成一个有向环。\n- 案例 D（混合情况：条件创建、多个依赖和一个不相关的设备）：\n  - 一个观察引用了一个患者、一个就诊和一个设备，但它在这些资源之前列出。该就诊引用了该患者。另一个观察只引用了该患者。该设备没有任何引用。该患者使用了一个条件创建 (`ifNoneExist`) 约束；在本模型中，这不改变依赖边。\n\n每个测试案例的所需输出：\n- 对于每个事务包，生成以下任一输出：\n  - 一个从零开始的索引列表，表示满足所有包内引用的有效确定性处理顺序，或\n  - 一个空列表，如果不存在这样的顺序。\n- 将四个测试案例的输出聚合到一行中。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，\"[rA,rB,rC,rD]\"）。在本问题中，每个元素要么是一个整数列表，要么是一个空列表，代表一个测试案例的结果。打印的行必须与此单行格式完全匹配，不得包含任何额外文本。\n\n四个事务包定义如下。每个包都有 \"type\": \"transaction\" 和一个 \"entry\" 数组。索引指的是在 entry 数组中从零开始的位置。\n\n- 案例 A 条目（索引 $0$ 到 $3$）：\n  - 索引 $0$：就诊（Encounter），`fullUrl` 为 \"urn:uuid:enc1\"，`resource.subject.reference` 为 \"urn:uuid:pat1\"。\n  - 索引 $1$：观察（Observation），`fullUrl` 为 \"urn:uuid:obs1\"，并引用了 \"urn:uuid:pat1\" (subject) 和 \"urn:uuid:enc1\" (encounter)。\n  - 索引 $2$：患者（Patient），`fullUrl` 为 \"urn:uuid:pat1\"。\n  - 索引 $3$：观察（Observation），`fullUrl` 为 \"urn:uuid:obs2\"，引用 \"urn:uuid:pat1\" (subject)。\n- 案例 B 条目（索引 $0$）：\n  - 索引 $0$：观察（Observation），`fullUrl` 为 \"urn:uuid:obsX\"，无引用。\n- 案例 C 条目（索引 $0$ 到 $1$）：\n  - 索引 $0$：观察（Observation），`fullUrl` 为 \"urn:uuid:obsA\"，`derivedFrom` 为 [{\"reference\": \"urn:uuid:obsB\"}]。\n  - 索引 $1$：观察（Observation），`fullUrl` 为 \"urn:uuid:obsB\"，`derivedFrom` 为 [{\"reference\": \"urn:uuid:obsA\"}]。\n- 案例 D 条目（索引 $0$ 到 $4$）：\n  - 索引 $0$：观察（Observation），`fullUrl` 为 \"urn:uuid:obs3\"，并引用了 \"urn:uuid:pat2\" (subject)、\"urn:uuid:enc2\" (encounter) 和 \"urn:uuid:dev1\" (device)。\n  - 索引 $1$：患者（Patient），`fullUrl` 为 \"urn:uuid:pat2\"，并有一个条件创建请求（存在 `ifNoneExist`）。\n  - 索引 $2$：就诊（Encounter），`fullUrl` 为 \"urn:uuid:enc2\"，`resource.subject.reference` 为 \"urn:uuid:pat2\"。\n  - 索引 $3$：观察（Observation），`fullUrl` 为 \"urn:uuid:obs4\"，引用 \"urn:uuid:pat2\" (subject)。\n  - 索引 $4$：设备（Device），`fullUrl` 为 \"urn:uuid:dev1\"，无引用。\n\n您的任务是实现上述算法，将其应用于这四个事务包，并按规定打印单行聚合结果。", "solution": "该问题要求为快速医疗互操作性资源 (FHIR) 事务包中的条目确定一个有效的、确定性的处理顺序。这通过将资源间的依赖关系建模为有向图并寻找拓扑排序来实现。整个过程基于图论和算法的原理。\n\n### 原则：通过拓扑排序进行依赖解析\n\n一个 FHIR 事务包代表一组必须原子性执行的操作。也就是说，要么所有操作都成功，要么都不成功。成功的一个先决条件是所有包内引用必须是可解析的。对于一组 `CREATE` 操作，这意味着如果资源 $A$ 引用了资源 $B$，那么资源 $B$ 必须在资源 $A$ 之前创建。这就建立了一种依赖关系。\n\n这个依赖关系系统可以被形式化地建模为一个有向图 $G = (V, E)$，其中：\n- 顶点集合 $V$ 代表 FHIR 事务包中的条目。设 $n = |V|$ 为条目数。\n- 有向边集合 $E$ 代表依赖关系。如果条目 $i$ 中的资源包含对条目 $j$ 中资源的引用，则向 $E$ 中添加一条从顶点 $j$ 到顶点 $i$ 的有向边，记为 $j \\to i$。这条边表示条目 $j$ 必须在条目 $i$ 之前处理。\n\n所有条目的有效处理顺序存在，当且仅当依赖图 $G$ 是一个有向无环图 (DAG)。如果图中包含一个环（例如，条目 $A$ 依赖于 $B$，而条目 $B$ 又依赖于 $A$），则没有线性顺序可以满足所有依赖关系，该事务是无效的。\n\n寻找有效线性排序的任务被称为拓扑排序。一个有向无环图的拓扑排序是其顶点的一个线性排序，使得对于每个从顶点 $u$ 到顶点 $v$ 的有向边， $u$ 在排序中都出现在 $v$ 之前。如果图不是有向无环图，则不存在拓扑排序。\n\n### 算法：用于拓扑排序的 Kahn 算法\n\n为了找到拓扑排序，我们将采用 Kahn 算法。该算法特别适用，因为它也能检测环。该算法的时间复杂度为 $\\mathcal{O}(n + m)$，其中 $n$ 是顶点（事务包条目）的数量， $m$ 是边（依赖关系）的数量，这非常高效。\n\n问题指定了一个确定性的平局决胜规则：当多个条目准备好被处理时（即它们的所有依赖都已满足），必须优先选择在事务包 `entry` 数组中原始索引最小的那个。这确保了对于任何给定的事务包都有一个唯一的输出。我们可以通过使用一个最小优先队列（最小堆）来存储准备处理的节点，并按其原始索引排序，从而实现这个平局决胜规则。\n\n算法流程如下：\n\n1.  **图的构建**：\n    - 遍历事务包中的每个条目 $i \\in \\{0, 1, \\dots, n-1\\}$。\n    - 递归扫描条目 $i$ 的 `resource` 载荷，寻找任何键为 `\"reference\"` 的字段。\n    - 对于找到的每个引用，如果其值与同一事务包中另一个条目 $j$ 的 `fullUrl` 相对应，则建立一个依赖关系 $j \\to i$。\n    - 创建一个邻接表 `adj`，其中 `adj[j]` 存储所有依赖于 $j$ 的条目 $i$ 的列表。\n    - 计算一个大小为 $n$ 的数组 `in_degree`，其中 `in_degree[i]` 存储顶点 $i$ 的入度（传入边的数量）。\n\n2.  **初始化**：\n    - 创建一个最小优先队列 $S$。\n    - 对于所有顶点 $i \\in V$，如果 `in_degree[i]` 为 $0$，则将 $i$ 加入 $S$。这些是没有依赖关系的初始条目。\n    - 初始化一个空列表 $L$，它将存储最终排序后的索引顺序。\n\n3.  **处理循环**：\n    - 当 $S$ 不为空时：\n        a. 从 $S$ 中提取值最小的顶点 $u$（即原始索引最小的顶点）。\n        b. 将 $u$ 追加到列表 $L$ 中。\n        c. 对于 $u$ 的每个邻居 $v$（即 `adj[u]` 中的每个 $v$）：\n            i. 将 `in_degree[v]` 减 $1$。\n            ii. 如果 `in_degree[v]` 变为 $0$，意味着它的所有依赖都已满足。将 $v$ 加入优先队列 $S$。\n\n4.  **环检测与完成**：\n    - 循环终止后，如果 $L$ 中的条目数量等于 $n$，则 $L$ 包含一个有效的拓扑排序。算法返回 $L$。\n    - 如果 $L$ 中的条目数量小于 $n$，则意味着至少有一个顶点的入度从未达到零。这只可能在图中存在环时发生。在这种情况下，有效的处理顺序是不可能的，算法返回一个空列表。\n\n### 应用于测试案例\n\n- **案例 A (理想路径)**：一个患者被一个就诊和两个观察所引用。其中一个观察还引用了那个就诊。算法正确地将患者（索引 $2$）识别为没有依赖项，首先处理它，然后相继解析其他条目的依赖关系，得出顺序 $[2, 0, 1, 3]$。\n- **案例 B (边界情况)**：一个没有任何引用的观察，其入度为 $0$。它被立即处理，得到顺序 $[0]$。\n- **案例 C (环)**：两个观察相互引用。这创建了一个环 $0 \\to 1 \\to 0$。两个条目的入度都不为 $0$，因此算法的优先队列始终为空。它正确地检测到环并返回一个空列表 `[]`。\n- **案例 D (混合情况)**：一组复杂的依赖关系，涉及一个患者、就诊、观察和一个独立的设备。患者（索引 $1$）和设备（索引 $4$）没有初始依赖项。平局决胜规则确保患者（索引 $1$）被首先处理。之后，算法按照指定的确定性顺序解析剩余的依赖关系，产生 $[1, 2, 3, 4, 0]$。根据问题陈述，`ifNoneExist` 参数在依赖分析中被正确忽略。", "answer": "```python\nimport heapq\nimport numpy as np  # Included to meet problem specification, but not used.\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the topological sort algorithm,\n    and print the results in the required format.\n    \"\"\"\n    \n    # Test Suite: FHIR-like transaction bundles\n    test_cases = [\n        # Case A: Happy path with multiple dependencies\n        {\n            \"type\": \"transaction\",\n            \"entry\": [\n                {\n                    \"fullUrl\": \"urn:uuid:enc1\",\n                    \"resource\": {\"resourceType\": \"Encounter\", \"subject\": {\"reference\": \"urn:uuid:pat1\"}},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:obs1\",\n                    \"resource\": {\"resourceType\": \"Observation\", \"subject\": {\"reference\": \"urn:uuid:pat1\"}, \"encounter\": {\"reference\": \"urn:uuid:enc1\"}},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:pat1\",\n                    \"resource\": {\"resourceType\": \"Patient\"},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:obs2\",\n                    \"resource\": {\"resourceType\": \"Observation\", \"subject\": {\"reference\": \"urn:uuid:pat1\"}},\n                },\n            ],\n        },\n        # Case B: Boundary case with a single entry and no references\n        {\n            \"type\": \"transaction\",\n            \"entry\": [\n                {\n                    \"fullUrl\": \"urn:uuid:obsX\",\n                    \"resource\": {\"resourceType\": \"Observation\"},\n                }\n            ],\n        },\n        # Case C: Edge case with a cycle\n        {\n            \"type\": \"transaction\",\n            \"entry\": [\n                {\n                    \"fullUrl\": \"urn:uuid:obsA\",\n                    \"resource\": {\"resourceType\": \"Observation\", \"derivedFrom\": [{\"reference\": \"urn:uuid:obsB\"}]},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:obsB\",\n                    \"resource\": {\"resourceType\": \"Observation\", \"derivedFrom\": [{\"reference\": \"urn:uuid:obsA\"}]},\n                },\n            ],\n        },\n        # Case D: Mixed case with multiple dependencies and conditional create\n        {\n            \"type\": \"transaction\",\n            \"entry\": [\n                {\n                    \"fullUrl\": \"urn:uuid:obs3\",\n                    \"resource\": {\n                        \"resourceType\": \"Observation\",\n                        \"subject\": {\"reference\": \"urn:uuid:pat2\"},\n                        \"encounter\": {\"reference\": \"urn:uuid:enc2\"},\n                        \"device\": {\"reference\": \"urn:uuid:dev1\"},\n                    },\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:pat2\",\n                    \"resource\": {\"resourceType\": \"Patient\"},\n                    \"request\": {\"method\": \"POST\", \"url\": \"Patient\", \"ifNoneExist\": \"identifier=123\"},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:enc2\",\n                    \"resource\": {\"resourceType\": \"Encounter\", \"subject\": {\"reference\": \"urn:uuid:pat2\"}},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:obs4\",\n                    \"resource\": {\"resourceType\": \"Observation\", \"subject\": {\"reference\": \"urn:uuid:pat2\"}},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:dev1\",\n                    \"resource\": {\"resourceType\": \"Device\"},\n                },\n            ],\n        },\n    ]\n\n    results = []\n    for bundle in test_cases:\n        order = find_processing_order(bundle)\n        results.append(order)\n\n    # Format the final output string exactly as required.\n    # str(list) in Python produces a string with spaces, which is standard.\n    # Joining these string representations gives the desired format.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\n\ndef find_references_recursive(data):\n    \"\"\"\n    Recursively traverses a nested Python dictionary/list structure and yields\n    all string values associated with the key \"reference\".\n    \"\"\"\n    if isinstance(data, dict):\n        for key, value in data.items():\n            if key == \"reference\" and isinstance(value, str):\n                yield value\n            else:\n                yield from find_references_recursive(value)\n    elif isinstance(data, list):\n        for item in data:\n            yield from find_references_recursive(item)\n\n\ndef find_processing_order(bundle):\n    \"\"\"\n    Determines a valid processing order for a FHIR bundle using Kahn's algorithm\n    with deterministic tie-breaking.\n\n    Args:\n        bundle (dict): A FHIR-like bundle structure.\n\n    Returns:\n        list: A list of indices representing the processing order, or an empty\n              list if a cycle is detected.\n    \"\"\"\n    entries = bundle.get(\"entry\", [])\n    num_nodes = len(entries)\n    if num_nodes == 0:\n        return []\n\n    url_to_index = {entry.get(\"fullUrl\"): i for i, entry in enumerate(entries) if entry.get(\"fullUrl\")}\n    \n    adj = {i: [] for i in range(num_nodes)}\n    in_degree = {i: 0 for i in range(num_nodes)}\n\n    # Build the dependency graph\n    for i, entry in enumerate(entries):\n        resource = entry.get(\"resource\", {})\n        for ref_url in find_references_recursive(resource):\n            if ref_url in url_to_index:\n                # Dependency found: j must be processed before i\n                j = url_to_index[ref_url]\n                if j != i: # Self-references don't affect topological sort order\n                    adj[j].append(i)\n                    in_degree[i] += 1\n\n    # Kahn's algorithm with a min-heap for deterministic tie-breaking\n    # The min-heap will always provide the node with the smallest index\n    priority_queue = [i for i in range(num_nodes) if in_degree[i] == 0]\n    heapq.heapify(priority_queue)\n    \n    sorted_order = []\n    \n    while priority_queue:\n        u = heapq.heappop(priority_queue)\n        sorted_order.append(u)\n        \n        # Sort neighbors for deterministic testing, though not required for correctness\n        # as the heap handles the \"which node to process next\" logic.\n        # The order of decrementing in-degrees doesn't affect the final result.\n        for v in sorted(adj[u]): \n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                heapq.heappush(priority_queue, v)\n\n    if len(sorted_order) == num_nodes:\n        return sorted_order\n    else:\n        # A cycle was detected\n        return []\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "4859896"}, {"introduction": "在医疗数据交换中，信任至关重要。我们如何能确定一条数据来自何处，并且未经篡改？这个高级练习 [@problem_id:4859894] 将指导您构建一个 FHIR Provenance 资源，它相当于临床数据的数字审计追踪记录。您将学习如何将一项观察结果与其来源（操作者、设备）相关联，并生成密码学签名以确保其完整性，这是构建可信互操作系统的基石。", "problem": "您被要求编写一个完整的、可运行的程序，该程序通过构建一个简化的“快速医疗保健互操作性资源”（FHIR）Provenance 资源来模拟医疗保健领域的核心互操作性工作流。该 Provenance 资源将一个临床 Observation（观察）与其来源信息（设备、操作员和软件版本）相关联，并为确保完整性计算数字签名元数据。目标是利用数据完整性和资源链接的基本原则来形式化构建和验证规则，以测试所构建的 Provenance 是否满足指定的约束条件。您的程序必须严格遵守以下规则，然后将其应用于提供的测试套件，并最终在单行中输出所有测试用例的验证结果。\n\n使用的基本原理：\n- 互操作性要求来自不同系统的数据在结构化、语义一致和可验证性方面得到保证。在“第七级健康信息标准”（HL7）的“快速医疗保健互操作性资源”（FHIR）模型中，Provenance 记录了资源的生产者、内容、时间以及生成方式。数据完整性可以通过使用密钥散列（基于散列的消息认证码，HMAC）来实现，这是一种经过充分测试的加密原语。\n- 对于一个字节长度为 $n$ 的消息，使用 256 位安全散列算法（SHA-256）的基于散列的消息认证码（HMAC）会生成一个 $32$ 字节的摘要。标准的 Base64 编码将 $3$ 个字节映射为 $4$ 个字符。因此，一个 $32$ 字节摘要的 Base64 编码长度 $L$ 满足 $L = 4 \\cdot \\lceil 32/3 \\rceil = 44$。此长度属性被用作签名的结构完整性检查。\n\n定义和构建规则：\n1. 每个测试用例的输入均为字符串：Observation 标识符 $o$、Device 标识符 $d$、操作员 (Practitioner) 标识符 $p$、软件版本 $v$、发生时间 $t_o$（ISO $8601$ 格式，以 $Z$ 结尾表示协调世界时 UTC）、记录时间 $t_r$（ISO $8601$ 格式，以 $Z$ 结尾）、签名算法 $a$ 以及一个密钥 $k$（用于计算基于散列的消息认证码 HMAC）。\n2. 您必须构建一个简化的 FHIR Provenance 资源（建模为嵌套的键值结构），至少包含以下字段：\n   - target: Observation 参考字符串 \"Observation/\" 与 $o$ 拼接而成。\n   - agent: 一个列表，包含两个条目：\n     - 操作员代理，其角色为 \"author\"，引用为 \"Practitioner/\" 与 $p$ 拼接而成。\n     - 设备代理，其角色为 \"assembler\"，引用为 \"Device/\" 与 $d$ 拼接而成。\n   - software: 软件版本字符串 $v$。\n   - occurred: 时间 $t_o$。\n   - recorded: 时间 $t_r$。\n   - signature: 一个对象，包含以下字段：\n     - type: \"application/fhir+json\"。\n     - alg: 算法 $a$。\n     - who: 字符串 \"Practitioner/\" 与 $p$ 拼接而成。\n     - when: 时间 $t_r$。\n     - data: 如果且仅当算法 $a$ 等于字面量 \"HMAC-SHA256\" 时，此字段为对规范化字符串使用密钥 $k$ 和算法 $a$ 计算出的基于散列的消息认证码（HMAC）的 Base64 编码；否则，将 data 设置为空字符串。\n3. 待签名的规范化字符串，记为 $\\mathcal{C}$，必须严格按照以下七行内容构建，每行之间以换行符 `\\n` 连接：\n   - \"target=Observation/\" 后跟 $o$\n   - \"device=Device/\" 后跟 $d$\n   - \"operator=Practitioner/\" 后跟 $p$\n   - \"software=\" 后跟 $v$\n   - \"occurred=\" 后跟 $t_o$\n   - \"recorded=\" 后跟 $t_r$\n   - \"alg=\" 后跟 $a$\n   因此，如果我们将字符串拼接表示为 $\\Vert$，则消息为\n   $$\\mathcal{C} = s_1 \\Vert s_2 \\Vert s_3 \\Vert s_4 \\Vert s_5 \\Vert s_6 \\Vert s_7,$$\n   其中每个 $s_i$ 对应上面相应的一行。\n4. 您必须按如下方式计算签名数据：\n   - 如果 $a$ 等于 \"HMAC-SHA256\"，则使用 $k$ 作为密钥，SHA-256 作为散列函数，计算 $\\mathcal{C}$ 的基于散列的消息认证码（HMAC），然后对生成的 $32$ 字节摘要进行 Base64 编码，以产生一个 $44$ 个字符的字符串（包括任何填充）。将此字符串放入 signature.data。\n   - 否则，将空字符串放入 signature.data。\n\n验证规则：\n为确定所构建的 Provenance 资源是否有效，必须满足以下所有条件：\n- 标识符格式：$o$、$d$ 和 $p$ 必须为非空，并匹配简单 FHIR 标识符的正则表达式：即只允许大写和小写字母、数字、连字符和句点的模式，也就是由正则表达式 `^[A-Za-z0-9.-]+$` 描述。\n- 版本格式：$v$ 必须匹配带有前导 \"v\" 的语义化版本格式：模式为 `^v(\\d+)\\.(\\d+)\\.(\\d+)`，表示一个字面量 \"v\" 后跟三个由点分隔的非负整数。\n- 时间顺序：将 $t_o$ 和 $t_r$ 解析为协调世界时（UTC）时间戳（ISO $8601$ 格式，以 $Z$ 结尾），并要求 $t_r \\ge t_o$。\n- Target 和 who 链接：target 等于 \"Observation/\" 与 $o$ 拼接的结果，signature.who 等于 \"Practitioner/\" 与 $p$ 拼接的结果。\n- Agent 角色：agent 列表必须恰好包含一个角色为 \"author\" 的操作员，其引用为 \"Practitioner/\" 与 $p$ 拼接而成；以及恰好一个角色为 \"assembler\" 的设备，其引用为 \"Device/\" 与 $d$ 拼接而成。\n- 签名算法和长度：$a$ 必须是字面量 \"HMAC-SHA256\"。此外，signature.data 必须是一个长度恰好为 $44$ 的非空 Base64 字符串，这与一个 Base64 编码的 $32$ 字节摘要相符。这利用了 $L = 4 \\cdot \\lceil 32/3 \\rceil = 44$。\n\n程序要求：\n- 根据上述规则实现 Provenance 资源的构建和验证。\n- 将构建和验证过程应用于以下参数集的测试套件。每个测试用例是一个元组 $(o, d, p, v, t_o, t_r, a, k)$，其中所有元素都是字符串。\n\n测试套件：\n- 测试用例 $1$ (正常路径)：$o=$ \"obs-001\", $d=$ \"dev-Alpha\", $p=$ \"prac-777\", $v=$ \"v1.2.3\", $t_o=$ \"2024-06-01T12:00:00Z\", $t_r=$ \"2024-06-01T12:00:05Z\", $a=$ \"HMAC-SHA256\", $k=$ \"s3cr3t-key-01\"。\n- 测试用例 $2$ (无效的操作员标识符)：$o=$ \"obs-002\", $d=$ \"dev-Alpha\", $p=$ \"prac 777\" (注意空格), $v=$ \"v1.2.3\", $t_o=$ \"2024-06-01T12:00:00Z\", $t_r=$ \"2024-06-01T12:00:05Z\", $a=$ \"HMAC-SHA256\", $k=$ \"s3cr3t-key-01\"。\n- 测试用例 $3$ (记录时间早于发生时间)：$o=$ \"obs-003\", $d=$ \"dev-Beta\", $p=$ \"prac-555\", $v=$ \"v2.0.0\", $t_o=$ \"2024-06-01T12:00:05Z\", $t_r=$ \"2024-06-01T12:00:00Z\", $a=$ \"HMAC-SHA256\", $k=$ \"another-key\"。\n- 测试用例 $4$ (无效的算法和版本格式)：$o=$ \"obs-004\", $d=$ \"dev-Gamma\", $p=$ \"prac-101\", $v=$ \"v3.1\" (缺少补丁版本号), $t_o=$ \"2024-06-01T12:00:00Z\", $t_r=$ \"2024-06-01T12:00:10Z\", $a=$ \"HMAC-SHA1\" (不支持), $k=$ \"k\"。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个结果是按顺序对应的测试用例的布尔有效性。例如，一个有效的输出可能看起来像“[True,False,True,False]”，具体取决于您的计算验证结果。您的程序不得读取任何输入，并且除了这一行之外，不得打印任何其他内容。\n\n注意：\n- 所有字符串解析和比较都区分大小写。\n- 所有时间均为协调世界时（UTC）；使用标准的 ISO $8601$ 格式，并以 \"Z\" 结尾。\n- 不允许访问外部文件或网络。", "solution": "本问题要求构建和验证一个简化的快速医疗保健互操作性资源（FHIR）Provenance 资源。该过程受一系列关于数据结构、内容和加密完整性的严格规则所约束。解决方案必须实现为一个程序，该程序根据这些规则评估一系列测试用例。\n\n该问题被判定为有效，因为它科学地基于既定标准（FHIR）和加密方法（HMAC-SHA256），其规则明确、定义良好，并包含生成唯一、可验证结果所需的所有信息。问题的核心在于对详细规范的一丝不苟的实现，这是工程学和信息学的核心任务。\n\n我的方法是开发一个封装所有指定规则的单一验证函数。该函数将接收给定测试用例的八个输入参数——$o$（Observation ID）、$d$（Device ID）、$p$（Practitioner ID）、$v$（软件版本）、$t_o$（发生时间）、$t_r$（记录时间）、$a$（算法）和 $k$（密钥）——并返回一个布尔值以指示其有效性。该函数将按逻辑顺序检查每个验证规则，在遇到第一个失败时返回 `False`。这种快速失败策略既高效又符合逻辑。\n\n验证过程的结构如下：\n\n1.  **输入格式验证**：初始步骤是验证主要输入的格式。这是测试用例必须通过的第一个关卡。\n    *   **标识符格式**：标识符 $o$、$d$ 和 $p$ 必须是符合指定简单 FHIR 标识符正则表达式的非空字符串。问题描述提供了一个正式模式 `` `^[A-Za-z0-9.-]+$` ``，该模式规定标识符由一个或多个大写或小写字母、数字、连字符或句点组成。\n    *   **版本格式**：软件版本字符串 $v$ 必须遵守简化的语义化版本方案，特别是要匹配正则表达式 `` `^v(\\d+)\\.(\\d+)\\.(\\d+)$` ``。这对应于一个字面量 'v' 后跟三个由点分隔的整数部分。\n    *   **时间顺序**：以带 UTC 标志符 'Z' 的 ISO $8601$ 格式提供的时间戳 $t_o$ 和 $t_r$ 必须在逻辑上一致。`recorded` 时间 $t_r$ 必须大于或等于 `occurred` 时间 $t_o$，即 $t_r \\ge t_o$。这是对时间合理性的基本检查。\n\n2.  **算法和签名先决条件验证**：验证规则对签名施加了严格的约束。一个关键的先决条件是算法的选择。\n    *   **算法规范**：算法标识符 $a$ 必须是精确的字面量字符串 \"HMAC-SHA256\"。根据验证规则，不允许使用其他任何算法。如果不满足此条件，则资源无效。此检查会预先执行，因为它决定了是否应该计算签名。\n\n3.  **规范化字符串构建和签名生成**：对于通过初始检查的测试用例，将计算签名数据。这包括两个步骤。\n    *   **规范化**：构建一个记为 $\\mathcal{C}$ 的规范化字符串。该字符串是七个特定的键值对的拼接，由换行符 (`\\n`) 分隔。$\\mathcal{C}$ 的精确、有序和格式化的特性对于确保签名的可复现性和明确性至关重要。字符串的构成如下：\n        $\\mathcal{C} = (\\text{\"target=Observation/\"} \\Vert o) \\Vert \\text{'\\n'} \\Vert (\\text{\"device=Device/\"} \\Vert d) \\Vert \\text{'\\n'} \\Vert \\dots \\Vert (\\text{\"alg=\"} \\Vert a)$\n    *   **HMAC 计算和编码**：签名数据是密钥散列消息认证码的 Base64 编码。具体来说，HMAC 是使用 SHA-256 散列函数计算的，以 UTF-8 编码的规范化字符串 $\\mathcal{C}$ 作为消息，以 UTF-8 编码的密钥 $k$ 作为密钥。然后使用标准 Base64 对生成的 $32$ 字节摘要进行编码。\n\n4.  **最终签名验证**：最后的验证规则涉及生成的签名数据本身。\n    *   **签名数据长度**：问题指出，来自 SHA-256 的 Base64 编码的 $32$ 字节摘要会产生一个长度为 $L = 4 \\cdot \\lceil 32/3 \\rceil = 44$ 的字符串。一个关键的验证规则是，`signature.data` 字段必须是一个长度恰好为 $44$ 的非空字符串。此检查同时验证了所用加密原语的正确性（它必须生成 $32$ 字节）和编码过程。由于构建规则指定，如果 $a$ 不是 \"HMAC-SHA256\"，`signature.data` 就是一个空字符串，因此这个长度检查也隐式地强制执行了算法要求。一个具有无效算法的用例将生成一个空的 `data` 字符串，其长度为 $0$，从而无法通过长度为 $44$ 的检查。\n\n一个测试用例当且仅当满足所有这些验证规则时才被视为有效。程序将遍历提供的测试套件，对每个用例应用这种全面的验证逻辑，并汇总布尔结果以供最终输出。与构建的资源内部结构相关的规则（例如 `target` 和 `agent` 字段）如果构建逻辑忠实地按照规范实现，则在程序上可以保证是正确的；因此，它们的验证内在于正确的实现之中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport re\nfrom datetime import datetime\nimport hmac\nimport hashlib\nimport base64\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path)\n        (\"obs-001\", \"dev-Alpha\", \"prac-777\", \"v1.2.3\", \"2024-06-01T12:00:00Z\", \"2024-06-01T12:00:05Z\", \"HMAC-SHA256\", \"s3cr3t-key-01\"),\n        # Test case 2 (invalid operator identifier with a space)\n        (\"obs-002\", \"dev-Alpha\", \"prac 777\", \"v1.2.3\", \"2024-06-01T12:00:00Z\", \"2024-06-01T12:00:05Z\", \"HMAC-SHA256\", \"s3cr3t-key-01\"),\n        # Test case 3 (recorded time before occurred time)\n        (\"obs-003\", \"dev-Beta\", \"prac-555\", \"v2.0.0\", \"2024-06-01T12:00:05Z\", \"2024-06-01T12:00:00Z\", \"HMAC-SHA256\", \"another-key\"),\n        # Test case 4 (invalid algorithm and version format)\n        (\"obs-004\", \"dev-Gamma\", \"prac-101\", \"v3.1\", \"2024-06-01T12:00:00Z\", \"2024-06-01T12:00:10Z\", \"HMAC-SHA1\", \"k\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        is_valid = validate_provenance(*case)\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef validate_provenance(o, d, p, v, t_o, t_r, a, k):\n    \"\"\"\n    Validates a single provenance case based on the problem's rules.\n\n    Args:\n        o (str): Observation identifier.\n        d (str): Device identifier.\n        p (str): Practitioner identifier.\n        v (str): Software version.\n        t_o (str): Occurred time (ISO 8601).\n        t_r (str): Recorded time (ISO 8601).\n        a (str): Signature algorithm.\n        k (str): Secret key for HMAC.\n\n    Returns:\n        bool: True if the case is valid, False otherwise.\n    \"\"\"\n    # Validation Rule 1: Identifier format\n    # The pattern must match from start to end (re.fullmatch).\n    # The '+' in the regex ensures ids are non-empty.\n    id_pattern = r'[A-Za-z0-9.-]+'\n    if not (re.fullmatch(id_pattern, o) and\n            re.fullmatch(id_pattern, d) and\n            re.fullmatch(id_pattern, p)):\n        return False\n\n    # Validation Rule 2: Version format\n    version_pattern = r'v(\\d+)\\.(\\d+)\\.(\\d+)'\n    if not re.fullmatch(version_pattern, v):\n        return False\n\n    # Validation Rule 3: Time ordering\n    try:\n        # Python's fromisoformat handles the trailing 'Z' correctly since 3.11\n        # For compatibility with slightly older pythons, one can replace 'Z' with '+00:00'\n        # As per spec, env is 3.12, so this is fine.\n        dt_o = datetime.fromisoformat(t_o)\n        dt_r = datetime.fromisoformat(t_r)\n        if dt_r  dt_o:\n            return False\n    except ValueError:\n        # If timestamp parsing fails, it's invalid.\n        return False\n\n    # Validation Rule 6 (part 1): Signature algorithm\n    # The algorithm must be exactly \"HMAC-SHA256\".\n    if a != \"HMAC-SHA256\":\n        return False\n\n    # Construction of canonical string for signing\n    canonical_string = \"\\n\".join([\n        f\"target=Observation/{o}\",\n        f\"device=Device/{d}\",\n        f\"operator=Practitioner/{p}\",\n        f\"software={v}\",\n        f\"occurred={t_o}\",\n        f\"recorded={t_r}\",\n        f\"alg={a}\"\n    ])\n\n    # Compute signature data according to construction rule\n    signature_data = \"\"\n    # The check `a == \"HMAC-SHA256\"` is redundant due to the prior check,\n    # but included for clarity of implementation of construction rule.\n    if a == \"HMAC-SHA256\":\n        key_bytes = k.encode('utf-8')\n        msg_bytes = canonical_string.encode('utf-8')\n        digest = hmac.new(key_bytes, msg_bytes, hashlib.sha256).digest()\n        signature_data = base64.b64encode(digest).decode('ascii')\n\n    # Validation Rule 6 (part 2): Signature data length\n    # Must be non-empty and exactly 44 characters long.\n    if len(signature_data) != 44:\n        return False\n        \n    # Validation Rules 4 (Target/who links) and 5 (Agent roles) are implicitly\n    # satisfied by a correct implementation of the construction rules. The logic\n    # here correctly follows those rules, so no explicit self-check is needed.\n\n    # If all checks pass, the provenance is valid.\n    return True\n\nsolve()\n```", "id": "4859894"}]}