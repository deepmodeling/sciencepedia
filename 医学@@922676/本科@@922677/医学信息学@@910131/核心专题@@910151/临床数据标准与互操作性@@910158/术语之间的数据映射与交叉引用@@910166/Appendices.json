{"hands_on_practices": [{"introduction": "在术语映射中，一个基础任务是基于词汇相似性从目标术语表中为源术语识别出潜在的候选匹配项。本练习将带您亲手实践几种核心的字符串相似度度量方法，包括 Jaccard 指数、余弦相似度和编辑距离。通过完成这些计算，您将对自动化映射工具如何进行初步候选筛选建立起直观的理解，并学会使用如平均倒数排名 (Mean Reciprocal Rank, MRR) 等指标来评估不同相似度算法的性能 [@problem_id:4832998]。", "problem": "一个临床数据集成团队正在验证 Systematized Nomenclature of Medicine — Clinical Terms (SNOMED CT) 与 Logical Observation Identifiers Names and Codes (LOINC) 之间的一个基于字符串的交叉索引。对于每个 SNOMED CT 查询词 $Q_i$，都有两个候选的 LOINC 词语 $C_i^{(1)}$ 和 $C_i^{(2)}$。预处理流程将所有词语转换为小写，移除标点符号和连字符，并根据空格进行分词，以生成词元集。该团队将在词元级别上评估三种相似度度量，为每个查询的候选词进行排序：Jaccard 指数、使用二元词元出现率的余弦相似度，以及根据词级 Levenshtein 距离（替换、插入、删除的单位成本均为1）计算并通过较长词元序列长度进行归一化的归一化编辑相似度。\n\n给定以下查询和候选词，以及每个查询的基准真相正确候选词：\n\n- 查询 $Q_1$：“Hemoglobin A1c test”\n  - 候选词 $C_1^{(1)}$ (正确)：“Hemoglobin A1c level”\n  - 候选词 $C_1^{(2)}$：“Hepatic function panel”\n- 查询 $Q_2$：“Basic metabolic panel”\n  - 候选词 $C_2^{(1)}$ (正确)：“Basic metabolic panel”\n  - 候选词 $C_2^{(2)}$：“Complete blood count”\n- 查询 $Q_3$：“Urinalysis microscopy”\n  - 候选词 $C_3^{(1)}$ (正确)：“Urinalysis microscopic”\n  - 候选词 $C_3^{(2)}$：“Urine culture”\n\n使用所述的分词方法，计算每个查询-候选词对的 Jaccard 指数、余弦相似度（二元出现率），以及归一化编辑相似度（定义为 $1$ 减去词级 Levenshtein 距离除以较长的词元序列长度）。对每种度量独立地，将每个查询的两个候选词按相似度降序排序。然后，对每种度量，计算这 $3$ 个查询的平均倒数排名（Mean Reciprocal Rank），其中，如果正确候选词在该度量对该查询的排名中位于第 $k$ 位，则该查询的倒数排名为 $1/k$。\n\n报告这三种度量中实现的最大平均倒数排名。将您的最终答案四舍五入到四位有效数字。", "solution": "我们从医学信息学中用于基于字符串的术语相似度和排名的标准且经过充分检验的定义开始。\n\n设一个查询词生成一个词元集 $A$，一个候选词生成一个词元集 $B$。\n\n- Jaccard 指数定义为\n$$\nJ(A,B) \\;=\\; \\frac{|A \\cap B|}{|A \\cup B|}.\n$$\n\n- 对于二元词元出现率（在每个集合中存在或不存在）的余弦相似度为\n$$\n\\cos(A,B) \\;=\\; \\frac{|A \\cap B|}{\\sqrt{|A|\\,|B|}}.\n$$\n\n- 词元级别的归一化编辑相似度基于词级 Levenshtein 距离 $d(A,B)$，其中替换、插入和删除的单位成本为1。设 $m=|A|$ 且 $n=|B|$。归一化编辑相似度为\n$$\nS_{\\text{edit}}(A,B) \\;=\\; 1 - \\frac{d(A,B)}{\\max(m,n)}.\n$$\n\n我们现在应用指定的预处理步骤：转换为小写，移除标点符号和连字符，并按空格分词。\n\n分词：\n\n- $Q_1$：“Hemoglobin A1c test” $\\rightarrow$ $A_1=\\{\\text{hemoglobin}, \\text{a1c}, \\text{test}\\}$ 所以 $|A_1|=3$。\n  - $C_1^{(1)}$：“Hemoglobin A1c level” $\\rightarrow$ $B_1^{(1)}=\\{\\text{hemoglobin}, \\text{a1c}, \\text{level}\\}$ 所以 $|B_1^{(1)}|=3$。\n  - $C_1^{(2)}$：“Hepatic function panel” $\\rightarrow$ $B_1^{(2)}=\\{\\text{hepatic}, \\text{function}, \\text{panel}\\}$ 所以 $|B_1^{(2)}|=3$。\n\n- $Q_2$：“Basic metabolic panel” $\\rightarrow$ $A_2=\\{\\text{basic}, \\text{metabolic}, \\text{panel}\\}$ 所以 $|A_2|=3$。\n  - $C_2^{(1)}$：“Basic metabolic panel” $\\rightarrow$ $B_2^{(1)}=\\{\\text{basic}, \\text{metabolic}, \\text{panel}\\}$ 所以 $|B_2^{(1)}|=3$。\n  - $C_2^{(2)}$：“Complete blood count” $\\rightarrow$ $B_2^{(2)}=\\{\\text{complete}, \\text{blood}, \\text{count}\\}$ 所以 $|B_2^{(2)}|=3$。\n\n- $Q_3$：“Urinalysis microscopy” $\\rightarrow$ $A_3=\\{\\text{urinalysis}, \\text{microscopy}\\}$ 所以 $|A_3|=2$。\n  - $C_3^{(1)}$：“Urinalysis microscopic” $\\rightarrow$ $B_3^{(1)}=\\{\\text{urinalysis}, \\text{microscopic}\\}$ 所以 $|B_3^{(1)}|=2$。\n  - $C_3^{(2)}$：“Urine culture” $\\rightarrow$ $B_3^{(2)}=\\{\\text{urine}, \\text{culture}\\}$ 所以 $|B_3^{(2)}|=2$。\n\n计算 Jaccard 指数 $J$：\n\n- $Q_1$:\n  - $A_1 \\cap B_1^{(1)}=\\{\\text{hemoglobin}, \\text{a1c}\\}$ 所以 $|A_1 \\cap B_1^{(1)}|=2$ 且 $A_1 \\cup B_1^{(1)}=\\{\\text{hemoglobin}, \\text{a1c}, \\text{test}, \\text{level}\\}$ 所以 $|A_1 \\cup B_1^{(1)}|=4$。因此\n  $$\n  J(A_1,B_1^{(1)}) = \\frac{2}{4} = \\frac{1}{2}.\n  $$\n  - $A_1 \\cap B_1^{(2)}=\\varnothing$ 所以 $|A_1 \\cap B_1^{(2)}|=0$ 且 $|A_1 \\cup B_1^{(2)}|=6$。因此\n  $$\n  J(A_1,B_1^{(2)}) = \\frac{0}{6} = 0.\n  $$\n\n- $Q_2$:\n  - $A_2=B_2^{(1)}$ 所以 $|A_2 \\cap B_2^{(1)}|=3$，$|A_2 \\cup B_2^{(1)}|=3$，且\n  $$\n  J(A_2,B_2^{(1)}) = \\frac{3}{3} = 1.\n  $$\n  - $A_2 \\cap B_2^{(2)}=\\varnothing$ 且 $|A_2 \\cup B_2^{(2)}|=6$，因此\n  $$\n  J(A_2,B_2^{(2)}) = \\frac{0}{6} = 0.\n  $$\n\n- $Q_3$:\n  - $A_3 \\cap B_3^{(1)}=\\{\\text{urinalysis}\\}$ 所以 $|A_3 \\cap B_3^{(1)}|=1$，且 $A_3 \\cup B_3^{(1)}=\\{\\text{urinalysis}, \\text{microscopy}, \\text{microscopic}\\}$ 所以 $|A_3 \\cup B_3^{(1)}|=3$。因此\n  $$\n  J(A_3,B_3^{(1)}) = \\frac{1}{3}.\n  $$\n  - $A_3 \\cap B_3^{(2)}=\\varnothing$ 且 $|A_3 \\cup B_3^{(2)}|=4$，因此\n  $$\n  J(A_3,B_3^{(2)}) = \\frac{0}{4} = 0.\n  $$\n\n计算二元出现率的余弦相似度 $\\cos$：\n\n- $Q_1$:\n  - $|A_1 \\cap B_1^{(1)}|=2$, $|A_1|=3$, $|B_1^{(1)}|=3$ 所以\n  $$\n  \\cos(A_1,B_1^{(1)}) = \\frac{2}{\\sqrt{3\\cdot 3}} = \\frac{2}{3}.\n  $$\n  - $|A_1 \\cap B_1^{(2)}|=0$ 所以\n  $$\n  \\cos(A_1,B_1^{(2)}) = 0.\n  $$\n\n- $Q_2$:\n  - $A_2=B_2^{(1)}$ 所以 $|A_2 \\cap B_2^{(1)}|=3$, $|A_2|=3$, $|B_2^{(1)}|=3$ 且\n  $$\n  \\cos(A_2,B_2^{(1)}) = \\frac{3}{\\sqrt{3\\cdot 3}} = 1.\n  $$\n  - $|A_2 \\cap B_2^{(2)}|=0$ 所以\n  $$\n  \\cos(A_2,B_2^{(2)}) = 0.\n  $$\n\n- $Q_3$:\n  - $|A_3 \\cap B_3^{(1)}|=1$, $|A_3|=2$, $|B_3^{(1)}|=2$ 所以\n  $$\n  \\cos(A_3,B_3^{(1)}) = \\frac{1}{\\sqrt{2\\cdot 2}} = \\frac{1}{2}.\n  $$\n  - $|A_3 \\cap B_3^{(2)}|=0$ 所以\n  $$\n  \\cos(A_3,B_3^{(2)}) = 0.\n  $$\n\n计算词元级别的归一化编辑相似度 $S_{\\text{edit}}$。对于词级 Levenshtein 距离 $d$，我们计算单位成本的替换、插入和删除次数。\n\n- $Q_1$:\n  - $A_1=[\\text{hemoglobin}, \\text{a1c}, \\text{test}]$, $B_1^{(1)}=[\\text{hemoglobin}, \\text{a1c}, \\text{level}]$。将 $A_1$ 转换为 $B_1^{(1)}$ 需要 1 次替换（“test” $\\rightarrow$ “level”），所以 $d(A_1,B_1^{(1)})=1$。当 $m=|A_1|=3$，$n=|B_1^{(1)}|=3$ 时，我们有\n  $$\n  S_{\\text{edit}}(A_1,B_1^{(1)}) = 1 - \\frac{1}{\\max(3,3)} = 1 - \\frac{1}{3} = \\frac{2}{3}.\n  $$\n  - $B_1^{(2)}=[\\text{hepatic}, \\text{function}, \\text{panel}]$。将 $A_1$ 转换为 $B_1^{(2)}$ 需要 3 次替换，所以 $d(A_1,B_1^{(2)})=3$ 且\n  $$\n  S_{\\text{edit}}(A_1,B_1^{(2)}) = 1 - \\frac{3}{\\max(3,3)} = 0.\n  $$\n\n- $Q_2$:\n  - $A_2=B_2^{(1)}$，所以 $d(A_2,B_2^{(1)})=0$ 且\n  $$\n  S_{\\text{edit}}(A_2,B_2^{(1)}) = 1 - \\frac{0}{\\max(3,3)} = 1.\n  $$\n  - $B_2^{(2)}=[\\text{complete}, \\text{blood}, \\text{count}]$。将 $A_2$ 转换为 $B_2^{(2)}$ 需要 3 次替换，所以 $d(A_2,B_2^{(2)})=3$ 且\n  $$\n  S_{\\text{edit}}(A_2,B_2^{(2)}) = 1 - \\frac{3}{\\max(3,3)} = 0.\n  $$\n\n- $Q_3$:\n  - $A_3=[\\text{urinalysis}, \\text{microscopy}]$, $B_3^{(1)}=[\\text{urinalysis}, \\text{microscopic}]$。将 $A_3$ 转换为 $B_3^{(1)}$ 需要 1 次替换（“microscopy” $\\rightarrow$ “microscopic”），所以 $d(A_3,B_3^{(1)})=1$。当 $m=|A_3|=2$，$n=|B_3^{(1)}|=2$ 时，我们有\n  $$\n  S_{\\text{edit}}(A_3,B_3^{(1)}) = 1 - \\frac{1}{\\max(2,2)} = 1 - \\frac{1}{2} = \\frac{1}{2}.\n  $$\n  - $B_3^{(2)}=[\\text{urine}, \\text{culture}]$。将 $A_3$ 转换为 $B_3^{(2)}$ 需要 2 次替换，所以 $d(A_3,B_3^{(2)})=2$ 且\n  $$\n  S_{\\text{edit}}(A_3,B_3^{(2)}) = 1 - \\frac{2}{\\max(2,2)} = 0.\n  $$\n\n每个查询按各度量的排名（按相似度降序）：\n\n- Jaccard 指数:\n  - $Q_1$: $C_1^{(1)}$ 的分数为 $\\frac{1}{2}$，$C_1^{(2)}$ 的分数为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_1^{(1)}$。\n  - $Q_2$: $C_2^{(1)}$ 的分数为 $1$，$C_2^{(2)}$ 的分数为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_2^{(1)}$。\n  - $Q_3$: $C_3^{(1)}$ 的分数为 $\\frac{1}{3}$，$C_3^{(2)}$ 的分数为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_3^{(1)}$。\n\n- 余弦相似度:\n  - $Q_1$: $C_1^{(1)}$ 的分数为 $\\frac{2}{3}$，$C_1^{(2)}$ 的分数为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_1^{(1)}$。\n  - $Q_2$: $C_2^{(1)}$ 的分数为 $1$，$C_2^{(2)}$ 的分数为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_2^{(1)}$。\n  - $Q_3$: $C_3^{(1)}$ 的分数为 $\\frac{1}{2}$，$C_3^{(2)}$ 的分数为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_3^{(1)}$。\n\n- 归一化编辑相似度:\n  - $Q_1$: $C_1^{(1)}$ 的分数为 $\\frac{2}{3}$，$C_1^{(2)}$ 的分数为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_1^{(1)}$。\n  - $Q_2$: $C_2^{(1)}$ 的分数为 $1$，$C_2^{(2)}$ 的分数为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_2^{(1)}$。\n  - $Q_3$: $C_3^{(1)}$ 的分数为 $\\frac{1}{2}$，$C_3^{(2)}$ 的分数为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_3^{(1)}$。\n\n对于每种度量，每个查询中正确候选词的倒数排名都是 $1$（因为正确候选词排在第 1 位）。因此，对于每种度量，这 3 个查询的平均倒数排名 (MRR) 是\n$$\n\\text{MRR} \\;=\\; \\frac{1 + 1 + 1}{3} \\;=\\; 1.\n$$\n\n因此，这三种度量中实现的最大平均倒数排名为 $1$。四舍五入到四位有效数字，结果仍为 $1.000$。", "answer": "$$\\boxed{1.000}$$", "id": "4832998"}, {"introduction": "识别出候选术语后，关键的下一步是确定源概念与目标概念之间真正的语义关系。本练习将引导您超越简单的字符串匹配，深入到概念定义的本体论分析层面。您需要基于每个概念的内在属性（如临时性、解剖部位、严重性）来评估映射的类型（例如，精确匹配、广于、窄于或部分重叠），这对于创建能够准确保留临床意图的高质量、可靠的术语交叉表至关重要 [@problem_id:4832986]。", "problem": "在医学信息学中，临床术语之间的概念映射遵循与定义属性（例如，疾病轴与发现轴、时间性、侧向性、严重程度和上下文）相关的原则性标准。让每个概念表示一个满足其所有定义性约束的真实世界临床实例的集合。对于一个源概念 $S$ 和一个目标概念 $T$，使用其外延 $\\mathrm{den}(S)$ 和 $\\mathrm{den}(T)$ 之间的集合论关系定义以下源到目标的匹配类型：精确匹配（exact），如果 $\\mathrm{den}(S)=\\mathrm{den}(T)$；窄于（narrower-than），如果 $\\mathrm{den}(S)\\subset \\mathrm{den}(T)$；宽于（broader-than），如果 $\\mathrm{den}(S)\\supset \\mathrm{den}(T)$；部分重叠（partial-overlap），如果 $\\mathrm{den}(S)\\cap \\mathrm{den}(T)\\neq \\emptyset$ 但两者均不为对方的子集；以及无映射（no-map），如果由于定义轴不兼容导致 $\\mathrm{den}(S)\\cap \\mathrm{den}(T)=\\emptyset$。请使用这些原则性标准为以下 $4$ 个源-目标对分配匹配类型，并通过分析约束每个外延的定义属性来阐明您的分配理由：\n\n- 对 $1$：源为 Systematized Nomenclature of Medicine Clinical Terms (SNOMED CT) 概念 $44054006$ “2型糖尿病（疾病）”。目标为 International Classification of Diseases, Tenth Revision, Clinical Modification (ICD-10-CM) 代码 $E11.9$ “2型糖尿病无并发症”。\n- 对 $2$：源为本地实验室检验代码“血清钾”，表示仅对血清进行测量。目标为 Logical Observation Identifiers Names and Codes (LOINC) $2823-3$ “血清或血浆中的钾[摩尔/体积]”。\n- 对 $3$：源为 SNOMED CT “左侧中耳炎（疾病）”（侧向性约束为左耳，时间性未指定）。目标为 ICD-10-CM “急性中耳炎，耳部未特指”（时间性约束为急性，侧向性未指定）。\n- 对 $4$：源为 SNOMED CT “心肌梗死病史（情况）”（上下文轴表明是过去事件）。目标为 ICD-10-CM $I21.9$ “急性心肌梗死，未特指”（当前的急性事件）。\n\n哪个选项为所有 $4$ 个配对正确地分配了源到目标的匹配类型？\n\nA. 对 $1$：宽于；对 $2$：窄于；对 $3$：部分重叠；对 $4$：无映射\n\nB. 对 $1$：精确匹配；对 $2$：窄于；对 $3$：窄于；对 $4$：部分重叠\n\nC. 对 $1$：窄于；对 $2$：宽于；对 $3$：精确匹配；对 $4$：无映射\n\nD. 对 $1$：宽于；对 $2$：精确匹配；对 $3$：部分重叠；对 $4$：部分重叠", "solution": "问题陈述经过验证，被认为是有效的。它在科学上基于医学信息学和形式本体论的原则，提法得当，定义和约束清晰，表述客观。该问题提供了一个合理的逻辑框架和足够的信息来推导出唯一的解决方案。\n\n该问题根据源概念 $S$ 和目标概念 $T$ 的外延之间的集合论关系，定义了五种源到目标的映射类型。外延 $\\mathrm{den}(X)$ 是满足概念 $X$ 的定义性约束的所有真实世界实例的集合。定义如下：\n- **精确匹配 (Exact):** $\\mathrm{den}(S) = \\mathrm{den}(T)$\n- **窄于 (Narrower-than):** $\\mathrm{den}(S) \\subset \\mathrm{den}(T)$\n- **宽于 (Broader-than):** $\\mathrm{den}(S) \\supset \\mathrm{den}(T)$\n- **部分重叠 (Partial-overlap):** $\\mathrm{den}(S) \\cap \\mathrm{den}(T) \\neq \\emptyset$, $\\mathrm{den}(S) \\not\\subset \\mathrm{den}(T)$, 并且 $\\mathrm{den}(T) \\not\\subset \\mathrm{den}(S)$\n- **无映射 (No-map):** $\\mathrm{den}(S) \\cap \\mathrm{den}(T) = \\emptyset$\n\n我们现在将分析这 $4$ 个源-目标对。\n\n**对 $1$ 分析：**\n- 源 ($S_1$): SNOMED CT $44054006$ “2型糖尿病（疾病）”。这是一个关于该疾病的一般概念。其定义未指明是否存在并发症。因此，$\\mathrm{den}(S_1)$ 包括所有2型糖尿病的实例，无论有无并发症。\n- 目标 ($T_1$): ICD-10-CM $E11.9$ “2型糖尿病无并发症”。该概念的定义明确限制为不存在并发症的2型糖尿病实例。因此，$\\mathrm{den}(T_1)$ 是无并发症的2型糖尿病实例的集合。\n- 关系：$\\mathrm{den}(T_1)$ 中的临床实例集合是 $\\mathrm{den}(S_1)$ 中实例的真子集，因为 $\\mathrm{den}(S_1)$ 还包含*有*并发症的2型糖尿病实例。形式上，$\\mathrm{den}(T_1) \\subset \\mathrm{den}(S_1)$，这等价于 $\\mathrm{den}(S_1) \\supset \\mathrm{den}(T_1)$。\n- 结论：源到目标的匹配类型是**宽于 (broader-than)**。\n\n**对 $2$ 分析：**\n- 源 ($S_2$): 本地实验室检验代码“血清钾”。样本类型的定义属性仅限于“血清”。因此，$\\mathrm{den}(S_2)$ 是在血清上进行的所有钾测量值的集合。\n- 目标 ($T_2$): LOINC $2823-3$ “血清或血浆中的钾[摩尔/体积]”。样本类型的定义属性允许“血清”或“血浆”。因此，$\\mathrm{den}(T_2)$ 是在血清或血浆上进行的所有钾测量值的集合。\n- 关系：在血清上进行的测量值集合 $\\mathrm{den}(S_2)$ 是在血清或血浆上进行的测量值集合 $\\mathrm{den}(T_2)$ 的真子集。$\\mathrm{den}(S_2)$ 中的每个实例也都在 $\\mathrm{den}(T_2)$ 中，但 $\\mathrm{den}(T_2)$ 还包含不在 $\\mathrm{den}(S_2)$ 中的实例（在血浆上的测量值）。形式上，$\\mathrm{den}(S_2) \\subset \\mathrm{den}(T_2)$。\n- 结论：源到目标的匹配类型是**窄于 (narrower-than)**。\n\n**对 $3$ 分析：**\n- 源 ($S_3$): SNOMED CT “左侧中耳炎（疾病）”。定义属性为侧向性='左侧'和时间性='未指定'。$\\mathrm{den}(S_3)$ 包含左耳中耳炎的所有实例，无论是急性的、慢性的、复发性的等。\n- 目标 ($T_3$): ICD-10-CM “急性中耳炎，耳部未特指”。定义属性为时间性='急性'和侧向性='未指定'。$\\mathrm{den}(T_3)$ 包含急性中耳炎的所有实例，无论是左耳、右耳还是双侧。\n- 关系：\n    - 我们测试子集关系。$\\mathrm{den}(S_3) \\subset \\mathrm{den}(T_3)$ 成立吗？不成立，因为“慢性左侧中耳炎”的实例在 $\\mathrm{den}(S_3)$ 中，但不在 $\\mathrm{den}(T_3)$ 中（因为 $T_3$ 仅为'急性'）。\n    - $\\mathrm{den}(T_3) \\subset \\mathrm{den}(S_3)$ 成立吗？不成立，因为“急性右侧中耳炎”的实例在 $\\mathrm{den}(T_3)$ 中，但不在 $\\mathrm{den}(S_3)$ 中（因为 $S_3$ 仅为'左侧'）。\n    - 我们测试交集。$\\mathrm{den}(S_3) \\cap \\mathrm{den}(T_3) = \\emptyset$ 成立吗？不成立，因为“急性左侧中耳炎”的实例满足两个概念的约束，因此在交集中。\n- 结论：由于两个集合有非空交集，但彼此都不是对方的子集，因此源到目标的匹配类型是**部分重叠 (partial-overlap)**。\n\n**对 $4$ 分析：**\n- 源 ($S_4$): SNOMED CT “心肌梗死病史（情况）”。“上下文”定义轴指定这是一个过去的事件。患者当前没有发生心肌梗死（MI）；他们有心肌梗死病史。$\\mathrm{den}(S_4)$ 是表示过去已缓解的MI的临床状态集合。\n- 目标 ($T_4$): ICD-10-CM $I21.9$ “急性心肌梗死，未特指”。“上下文”轴指定这是一个当前的急性事件。患者正在积极经历MI。$\\mathrm{den}(T_4)$ 是当前急性MI的临床事件集合。\n- 关系：上下文的定义轴（过去 vs. 当前）是相互排斥的。一个临床状态不能同时是“过去的MI病史”和“当前的急性MI”。这两个实例集合是不相交的。形式上，$\\mathrm{den}(S_4) \\cap \\mathrm{den}(T_4) = \\emptyset$。\n- 结论：源到目标的匹配类型是**无映射 (no-map)**。\n\n推导出的匹配总结：\n- 对 $1$: **宽于 (broader-than)**\n- 对 $2$: **窄于 (narrower-than)**\n- 对 $3$: **部分重叠 (partial-overlap)**\n- 对 $4$: **无映射 (no-map)**\n\n我们现在评估给出的选项：\n\n**A. 对 $1$：宽于；对 $2$：窄于；对 $3$：部分重叠；对 $4$：无映射**\n该选项的分配与我们对所有 $4$ 个配对的推导分析相符。\n- 对 $1$：宽于。正确。\n- 对 $2$：窄于。正确。\n- 对 $3$：部分重叠。正确。\n- 对 $4$：无映射。正确。\n此选项**正确**。\n\n**B. 对 $1$：精确匹配；对 $2$：窄于；对 $3$：窄于；对 $4$：部分重叠**\n- 对 $1$ 是宽于，不是精确匹配。错误。\n- 对 $3$ 是部分重叠，不是窄于。错误。\n- 对 $4$ 是无映射，不是部分重叠。错误。\n此选项**错误**。\n\n**C. 对 $1$：窄于；对 $2$：宽于；对 $3$：精确匹配；对 $4$：无映射**\n- 对 $1$ 是宽于，不是窄于。错误。\n- 对 $2$ 是窄于，不是宽于。错误。\n- 对 $3$ 是部分重叠，不是精确匹配。错误。\n此选项**错误**。\n\n**D. 对 $1$：宽于；对 $2$：精确匹配；对 $3$：部分重叠；对 $4$：部分重叠**\n- 对 $2$ 是窄于，不是精确匹配。错误。\n- 对 $4$ 是无映射，不是部分重叠。错误。\n此选项**错误**。\n\n根据所提供的原则性标准，只有选项 A 为所有四个配对正确地分配了匹配类型。", "answer": "$$\\boxed{A}$$", "id": "4832986"}, {"introduction": "在实际应用中，数据映射必须采用标准化的、机器可读的格式来实现系统间的互操作性。本练习将挑战您使用健康级别第七层快速医疗保健互操作性资源 (HL7 FHIR) 的 `ConceptMap` 标准来实现一个条件化映射。通过构建并评估一个能够处理特定条件（如身体部位的“左右侧”）的 `ConceptMap` 实例，您将在为真实世界场景建模复杂映射逻辑方面获得宝贵的实践经验 [@problem_id:4833007]。", "problem": "要求您编写一个完整且可运行的程序，该程序构建一个“第七级健康水平快速医疗互操作性资源 (HL7 FHIR)”的 ConceptMap 实例，用于将单个本地问题列表概念映射到“国际疾病分类第十版临床修订本 (ICD-10-CM)”代码，其中使用类型为“narrower”（更窄）的等效性，并带有一个关于侧向性的 dependsOn 约束。然后，通过运行一个确定性测试套件来评估所构建 ConceptMap 的正确性。您的程序不得读取任何输入，并且必须按末尾指定的方式产生单行输出。\n\n基本原理与约束：\n- 使用术语集之间映射的核心定义，即一个二元关系 $R \\subseteq S \\times T$，其中 $S$ 是源概念集合，$T$ 是目标概念集合。条件映射将其细化为一个三元关系 $R_{c} \\subseteq S \\times T \\times C$，其中 $C$ 是一组条件（例如，侧向性）。对于给定的条件值 $c \\in C$，条件映射的解析会选择那些具有匹配 $c$ 的 $(s,t,c)$。\n- 使用资源建模中经过充分测试的不变式：一个 HL7 FHIR ConceptMap 按源和目标代码系统对映射进行分组，包含从一个源代码到一个或多个目标代码的逐元素映射，并且可以指定等效性限定符和 dependsOn 条件。将等效性“narrower”视为表示在蕴含意义上，目标概念比源概念更具体。\n\n程序要求：\n- 构建恰好一个 ConceptMap 实例（在您的语言中作为原生数据结构），具有以下属性：\n  - 源代码系统是一个本地系统，由统一资源名称 (Uniform Resource Name) “urn:oid:1.2.3.4.5.6.7.8.9” 标识。要映射的单个源代码是字符串 “LPL-001”（代表一个关于膝盖疼痛的通用本地问题列表概念）。\n  - 目标代码系统是 “http://hl7.org/fhir/sid/icd-10-cm”。\n  - 必须至少有两个不同的目标映射（两个目标代码），每个映射具有：\n    - 等效性设置为字面量字符串 “narrower”。\n    - 一个 dependsOn 条件，其 property URI 等于字面量字符串 “http://hl7.org/fhir/StructureDefinition/laterality”，其 system 等于字面量字符串 “http://hl7.org/fhir/CodeSystem/bodysite-laterality”，其 value 等于字面量 “left” 或 “right” 之一。这用于编码侧向性。\n  - 使用 ICD-10-CM 代码 “M25.561” 表示右膝疼痛，“M25.562” 表示左膝疼痛作为目标。\n\n- 定义一个解析函数 $f$，它接受源概念代码 $s$ 和侧向性标记 $\\ell$ 作为输入，并通过如下方式评估 dependsOn 来返回适用的目标代码列表：\n  - 仅考虑源代码 $s = \\text{\"LPL-001\"}$ 的映射。\n  - 如果 $\\ell$ 等于字面量 “left”，则返回一个列表，其中仅包含其 dependsOn 的 value 等于 “left” 的那个目标代码。\n  - 如果 $\\ell$ 等于字面量 “right”，则返回一个列表，其中仅包含其 dependsOn 的 value 等于 “right” 的那个目标代码。\n  - 如果 $\\ell$ 等于字面量 “bilateral”，则返回 “left” 和 “right” 的两个目标代码（通过集合包含关系来证明此逻辑：“bilateral” 意味着两个侧向性条件都成立）。\n  - 对于任何其他 $\\ell$，返回空列表。\n\n- 实现一个验证器 $V$，它返回一个布尔值，指示 ConceptMap 实例是否满足以下所有结构性约束：\n  - resourceType 等于字面量 “ConceptMap”。\n  - group.source 等于字面量 “urn:oid:1.2.3.4.5.6.7.8.9”，且 group.target 等于字面量 “http://hl7.org/fhir/sid/icd-10-cm”。\n  - 对于源代码 “LPL-001”，有且仅有一个 group.element。\n  - 该元素的所有目标映射的 equivalence 都等于字面量 “narrower”。\n  - 该元素的所有目标映射都有一个 dependsOn 数组，其中至少有一个对象的 property 等于字面量 “http://hl7.org/fhir/StructureDefinition/laterality”，其 system 等于字面量 “http://hl7.org/fhir/CodeSystem/bodysite-laterality”，且其 value 是字面量 “left” 或 “right” 之一。\n\n测试套件：\n- 使用您构建的 ConceptMap 和解析函数 $f$，评估以下用例，并为每个用例计算一个布尔值，该值是结构验证器 $V$ 的结果与解析出的代码和预期列表相等性判断的逻辑合取：\n  - 用例 A (正常路径)：$\\ell = \\text{\"left\"}$，预期代码 [\"M25.562\"]。\n  - 用例 B (正常路径)：$\\ell = \\text{\"right\"}$，预期代码 [\"M25.561\"]。\n  - 用例 C (边缘案例，双侧)：$\\ell = \\text{\"bilateral\"}$，预期代码 [\"M25.561\",\"M25.562\"]，按字典升序排列。\n  - 用例 D (边缘案例，未知)：$\\ell = \\text{\"unknown\"}$，预期代码 [] (空列表)。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [Case A, Case B, Case C, Case D]。例如，一个有效的输出形式是“[true,false,true,true]”，前提是您语言的布尔字面量是小写的；请确保大小写完全匹配，并且除了您语言默认字符串化可能产生的逗号外，没有多余的空格。不得打印任何其他文本。", "solution": "该问题是有效的。它是在医学信息学领域内一个定义明确、有科学依据且形式化指定的任务。它要求实现一个数据结构和相应的算法来建模和评估条件性术语映射，并遵循 HL7 FHIR 标准的原则。\n\n解决方案将通过以下四个连续步骤进行开发：\n1.  构建一个代表 HL7 FHIR `ConceptMap` 的数据结构。\n2.  实现一个验证器函数 $V$，以验证 `ConceptMap` 的结构完整性。\n3.  实现一个解析函数 $f$，以执行条件映射。\n4.  执行一个确定性测试套件，以评估整个实现的正确性。\n\n**概念框架**\n\n问题将映射定义为一个二元关系 $R \\subseteq S \\times T$，其中 $S$ 是源概念集合，$T$ 是目标概念集合。对于此问题，映射是条件性的，建模为一个三元关系 $R_c \\subseteq S \\times T \\times C$，其中 $C$ 代表一组条件。具体的集合是：\n- 源概念集合：$S = \\{\\text{\"LPL-001\"}\\}$。\n- 目标概念集合：$T = \\{\\text{\"M25.561\"}, \\text{\"M25.562\"}\\}$。\n- 条件集 $C$：条件基于侧向性属性。我们可以将一个条件表示为一个元组 $(p, v)$，其中 $p$ 是属性，$v$ 是值。相关条件是 $(\\text{\"laterality\"}, \\text{\"left\"})$ 和 $(\\text{\"laterality\"}, \\text{\"right\"})$。\n\nFHIR 中的 `ConceptMap` 资源旨在表示此类关系。一个 `group` 元素定义了源 ($S$) 和目标 ($T$) 代码系统。在一个 `group` 内部，`element` 结构将一个特定的源代码 $s \\in S$ 链接到一个或多个 `target` 映射。每个 `target` 包含一个目标代码 $t \\in T$，并可以使用 `dependsOn` 元素来指定映射有效的条件，该元素实例化了条件集 $C$。\n\n**第 1 步：`ConceptMap` 数据结构构建**\n\n将使用 Python 字典来建模 `ConceptMap` 资源。该结构将严格遵循指定的约束。它将有一个 `resourceType` 为 `\"ConceptMap\"`。它将包含一个 `group`，指定 `source` 系统 URI 为 `\"urn:oid:1.2.3.4.5.6.7.8.9\"`，`target` 系统 URI 为 `\"http://hl7.org/fhir/sid/icd-10-cm\"`。这个 `group` 将为源代码 `\"LPL-001\"` 包含一个 `element`。这个 `element` 将相应地包含两个 `target` 映射。\n\n每个 `target` 映射的 `equivalence` 都将是 `\"narrower\"`，表示目标 ICD-10-CM 代码比通用的源代码更具体。条件性被编码在 `dependsOn` 列表中。\n- 第一个目标映射到代码 `\"M25.561\"`（右膝疼痛），并有一个 `dependsOn` 条件，其中 `property` 是 `\"http://hl7.org/fhir/StructureDefinition/laterality\"`，`system` 是 `\"http://hl7.org/fhir/CodeSystem/bodysite-laterality\"`，`value` 是 `\"right\"`。\n- 第二个目标映射到代码 `\"M25.562\"`（左膝疼痛），其 `dependsOn` 条件的 `value` 为 `\"left\"`。\n\n**第 2 步：验证器函数 ($V$) 实现**\n\n验证器函数 $V$ 将接受 `ConceptMap` 字典并返回一个布尔值。它将系统地检查所有必需结构元素的存在性和正确性。检查项如下：\n1. 顶层的 `resourceType` 必须是 `\"ConceptMap\"`。\n2. 结构必须包含一个 `group` 列表，且该列表恰好有一个元素。\n3. 此 `group` 元素的 `source` 属性必须是 `\"urn:oid:1.2.3.4.5.6.7.8.9\"`，其 `target` 必须是 `\"http://hl7.org/fhir/sid/icd-10-cm\"`。\n4. `group` 必须包含一个 `element` 列表，且该列表恰好有一个元素。\n5. 此 `element` 的 `code` 必须是 `\"LPL-001\"`。\n6. 此 `element` 必须包含一个 `target` 列表，且该列表至少有两个元素。\n7. 对于此列表中的每个 `target`：\n   a. `equivalence` 必须是 `\"narrower\"`。\n   b. 它必须有一个 `dependsOn` 列表，且该列表至少有一个元素。\n   c. `dependsOn` 中至少有一个元素的 `property` 必须等于 `\"http://hl7.org/fhir/StructureDefinition/laterality\"`，`system` 必须等于 `\"http://hl7.org/fhir/CodeSystem/bodysite-laterality\"`，并且 `value` 必须是 `\"left\"` 或 `\"right\"` 之一。\n\n一个健壮的实现将使用安全的字典访问（例如，`.get()` 方法）来防止因键缺失而导致的错误，并在这种情况下返回 `False`。\n\n**第 3 步：解析函数 ($f$) 实现**\n\n解析函数 $f(s, \\ell)$ 将接受源代码 $s$ 和侧向性标记 $\\ell$ 作为输入。\n1. 该函数将首先在 `ConceptMap` 中定位与源代码 $s = \\text{\"LPL-001\"}$ 对应的 `element`。如果不存在这样的元素，则返回一个空列表。\n2. 然后它处理侧向性标记 $\\ell$：\n   - 如果 $\\ell$ 是 `\"left\"` 或 `\"right\"`，函数会遍历 `target` 映射。对于每个 `target`，它会检查其 `dependsOn` 元素的 `value`。如果 `value` 与 $\\ell$ 匹配，则将相应的 `target.code` 添加到结果列表中。\n   - 如果 $\\ell$ 是 `\"bilateral\"`，这被解释为请求所有满足 `\"left\"` 或 `\"right\"` 条件的代码。该函数会收集这两个代码。此逻辑与双侧条件蕴含两个单侧条件的概念相符。\n   - 对于任何其他值的 $\\ell$（例如，`\"unknown\"`），没有条件匹配，函数返回一个空列表。\n3. 函数返回收集到的目标代码列表。\n\n**第 4 步：测试套件执行与最终输出**\n\n程序的最后一部分协调执行四个指定的测试用例。对于每个用例（A、B、C、D）：\n- 首先通过调用验证器函数 $V$ 来验证所构建的 `ConceptMap`。\n- 使用源代码 `\"LPL-001\"` 和该用例的侧向性标记来调用解析函数 $f$。\n- 对于用例 C（`\"bilateral\"`），由 $f$ 返回的代码列表按字典序排序，以确保与预期的已排序列表 `[\"M25.561\", \"M25.562\"]` 进行确定性比较。\n- 该用例的最终布尔结果是验证器结果与函数输出同预期代码列表相等性的逻辑合取。\n- 四个布尔结果被收集到一个列表中。然后，此列表被转换为所需的字符串格式 `[true,true,true,true]`，确保布尔字面量是小写的，并作为唯一的输出打印出来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Constructs, validates, and tests an HL7 FHIR ConceptMap for conditional mapping.\n    \"\"\"\n\n    # Step 1: Construct the ConceptMap data structure as a Python dictionary.\n    concept_map = {\n        \"resourceType\": \"ConceptMap\",\n        \"group\": [\n            {\n                \"source\": \"urn:oid:1.2.3.4.5.6.7.8.9\",\n                \"target\": \"http://hl7.org/fhir/sid/icd-10-cm\",\n                \"element\": [\n                    {\n                        \"code\": \"LPL-001\",\n                        \"target\": [\n                            {\n                                \"code\": \"M25.561\",\n                                \"equivalence\": \"narrower\",\n                                \"dependsOn\": [\n                                    {\n                                        \"property\": \"http://hl7.org/fhir/StructureDefinition/laterality\",\n                                        \"system\": \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\",\n                                        \"value\": \"right\"\n                                    }\n                                ]\n                            },\n                            {\n                                \"code\": \"M25.562\",\n                                \"equivalence\": \"narrower\",\n                                \"dependsOn\": [\n                                    {\n                                        \"property\": \"http://hl7.org/fhir/StructureDefinition/laterality\",\n                                        \"system\": \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\",\n                                        \"value\": \"left\"\n                                    }\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            }\n        ]\n    }\n\n    def validator(cm):\n        \"\"\"\n        Step 2: Implement the validator function V.\n        Validates the structural integrity of the ConceptMap instance.\n        \"\"\"\n        try:\n            # Check resourceType\n            if cm.get(\"resourceType\") != \"ConceptMap\":\n                return False\n\n            # Check group structure\n            groups = cm.get(\"group\", [])\n            if len(groups) != 1:\n                return False\n            group = groups[0]\n\n            if group.get(\"source\") != \"urn:oid:1.2.3.4.5.6.7.8.9\":\n                return False\n            if group.get(\"target\") != \"http://hl7.org/fhir/sid/icd-10-cm\":\n                return False\n\n            # Check element structure\n            elements = group.get(\"element\", [])\n            if len(elements) != 1:\n                return False\n            element = elements[0]\n\n            if element.get(\"code\") != \"LPL-001\":\n                return False\n            \n            targets = element.get(\"target\", [])\n            if len(targets)  2:  # at least two distinct target mappings\n                return False\n\n            # Check each target mapping\n            for target in targets:\n                if target.get(\"equivalence\") != \"narrower\":\n                    return False\n                \n                depends_on_list = target.get(\"dependsOn\", [])\n                if not depends_on_list:\n                    return False\n\n                valid_dependency_found = False\n                for dep in depends_on_list:\n                    prop = dep.get(\"property\") == \"http://hl7.org/fhir/StructureDefinition/laterality\"\n                    sys = dep.get(\"system\") == \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\"\n                    val = dep.get(\"value\") in [\"left\", \"right\"]\n                    if prop and sys and val:\n                        valid_dependency_found = True\n                        break\n                if not valid_dependency_found:\n                    return False\n\n        except (TypeError, KeyError, IndexError):\n            return False # Malformed structure\n\n        return True\n\n    def resolution_function(cm, source_code, laterality_token):\n        \"\"\"\n        Step 3: Implement the resolution function f.\n        Resolves target codes based on source code and a laterality condition.\n        \"\"\"\n        if source_code != \"LPL-001\":\n            return []\n\n        resolved_codes = []\n        try:\n            element = next((el for el in cm[\"group\"][0][\"element\"] if el[\"code\"] == source_code), None)\n            if not element:\n                return []\n            \n            targets_to_check = []\n            if laterality_token == \"left\":\n                targets_to_check = [\"left\"]\n            elif laterality_token == \"right\":\n                targets_to_check = [\"right\"]\n            elif laterality_token == \"bilateral\":\n                targets_to_check = [\"left\", \"right\"]\n            \n            for target in element[\"target\"]:\n                for dep in target[\"dependsOn\"]:\n                    if dep.get(\"value\") in targets_to_check:\n                        resolved_codes.append(target[\"code\"])\n                        break\n        except (KeyError, IndexError, TypeError):\n            return []\n            \n        return resolved_codes\n\n    # Step 4: Define and run the test suite.\n    test_cases = [\n        # Case A (happy path)\n        {\"laterality\": \"left\", \"expected\": [\"M25.562\"]},\n        # Case B (happy path)\n        {\"laterality\": \"right\", \"expected\": [\"M25.561\"]},\n        # Case C (edge case, bilateral)\n        {\"laterality\": \"bilateral\", \"expected\": [\"M25.561\", \"M25.562\"]},\n        # Case D (edge case, unknown)\n        {\"laterality\": \"unknown\", \"expected\": []},\n    ]\n\n    results = []\n    \n    # Run validator once, as it's static for all cases.\n    is_valid = validator(concept_map)\n\n    for case in test_cases:\n        laterality = case[\"laterality\"]\n        expected = case[\"expected\"]\n\n        # Call resolution function\n        resolved_codes = resolution_function(concept_map, \"LPL-001\", laterality)\n        \n        # Sort results for deterministic comparison, especially for 'bilateral'\n        resolved_codes.sort()\n        expected.sort()\n\n        # Compare results\n        resolution_correct = (resolved_codes == expected)\n        \n        # Final result for the case is the conjunction of validity and correct resolution\n        case_result = is_valid and resolution_correct\n        results.append(str(case_result).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "4833007"}]}