{"hands_on_practices": [{"introduction": "临床检验结果是医疗数据中最常见也最重要的一部分。为了让不同系统间的检验结果能够被准确无误地理解和交换，我们需要一个像 LOINC 这样的标准化“语言”。这个练习将让你扮演一名信息学家的角色，运用 LOINC 的六轴模型来为一个常见的“血清葡萄糖”检验构建一个精确的标识符，从而亲身体验如何将一个临床概念分解为其最基本的语义构件。[@problem_id:4828090]", "problem": "一个临床检验信息系统需要使用逻辑观察标识符名称和代码 (Logical Observation Identifiers Names and Codes, LOINC) 的六轴组合模型来表示血清葡萄糖的单时间点定量测量。六个 LOINC 轴定义如下：组分 (Component, 即分析物或观察项目)、属性 (Property, 即测量的特性)、时间 (Time, 即测量的时间维度)、系统 (System, 即标本或系统)、标度 (Scale, 即测量标度类型) 以及方法 (Method, 即分析技术)。该系统接收到一个典型的化学检验结果，该结果是针对在单一时间点采集的血清标本，以毫克/分升为单位报告，且未指定具体方法。基于这些定义，确定观察项目“血清葡萄糖”的适当轴分配。根据 LOINC 模型的基本原则和定量检验结果的语义，论证每个轴的选择。\n\n为了生成用于下游处理的单一内部数字控制码，该机构使用以下组合编码规则，该规则将每个选定的轴术语映射到一个整数，并将它们相乘：\n- 组分 (Component):\n  - 葡萄糖 (Glucose): $c_{\\mathrm{Glucose}} = 19$\n- 属性 (Property):\n  - 质量浓度 (LOINC 属性代码 “MCnc”): $p_{\\mathrm{MCnc}} = 23$\n  - 物质的量浓度 (LOINC 属性代码 “SCnc”): $p_{\\mathrm{SCnc}} = 17$\n- 时间 (Time):\n  - 时间点 (Point in time): $t_{\\mathrm{Pt}} = 29$\n- 系统 (System):\n  - 血清 (Serum): $s_{\\mathrm{Ser}} = 31$\n- 标度 (Scale):\n  - 定量 (Quantitative): $q_{\\mathrm{Qn}} = 37$\n- 方法 (Method):\n  - 未指定 (None specified): $m_{\\mathrm{None}} = 41$\n\n根据您论证的轴分配，计算组合内部码\n$$E = c \\times p \\times t \\times s \\times q \\times m.$$\n将 E 的最终值报告为单个整数。无需四舍五入，最终数值结果中不应包含任何单位。", "solution": "任务是为观察项目“血清葡萄糖”分配六个 LOINC 轴，然后通过将每个轴选择所映射的整数相乘来计算一个组合内部数字码。我们从 LOINC 模型的核心定义出发。\n\n轴选择的基本原则：\n1. 组分轴定义：组分轴代表被测量的分析物或现象。对于“血清葡萄糖”，分析物是葡萄糖。因此，组分是“Glucose”，映射为 $c_{\\mathrm{Glucose}} = 19$。\n\n2. 属性轴定义：属性轴指示测量的特性（例如，质量浓度、物质的量浓度、存在与否、比率）。血清葡萄糖的临床化学检验结果通常以毫克/分升报告，这反映了单位体积的质量。在 LOINC 中，质量浓度用“MCnc”表示。相比之下，“SCnc”表示物质（物质的量）浓度，通常以毫摩尔/升报告。因为检验结果是以毫克/分升提供的，所以适当的属性是质量浓度。因此，属性是“MCnc”，映射为 $p_{\\mathrm{MCnc}} = 23$（我们不使用 $p_{\\mathrm{SCnc}} = 17$）。\n\n3. 时间轴定义：时间轴捕捉测量的时间维度（例如，单一时间点、时间区间或一段时间内的采集）。该观察项目被明确描述为单时间点测量；在 LOINC 中，这表示为“Pt”（时间点）。因此，时间是“Pt”，映射为 $t_{\\mathrm{Pt}} = 29$。\n\n4. 系统轴定义：系统轴指定标本或系统。观察项目“血清葡萄糖”明确指明血清为标本。因此，系统是“Ser”，映射为 $s_{\\mathrm{Ser}} = 31$。\n\n5. 标度轴定义：标度轴指示用于报告结果的标度类型，如定量、定序、定名或叙述性。葡萄糖的数字检验值是定量测量。LOINC 将其表示为“Qn”。因此，标度是“Qn”，映射为 $q_{\\mathrm{Qn}} = 37$。\n\n6. 方法轴定义：方法轴可选地捕捉分析技术（例如，酶法、电位法）。问题陈述中未指定方法。在 LOINC 中，当技术未指定或对结果解释不重要时，省略方法是标准做法。因此，方法是“None”，映射为 $m_{\\mathrm{None}} = 41$。\n\n有了这些经过论证的轴分配，我们使用提供的乘法规则计算组合内部码：\n$$\nE = c \\times p \\times t \\times s \\times q \\times m\n= 19 \\times 23 \\times 29 \\times 31 \\times 37 \\times 41.\n$$\n\n我们分步进行乘法运算：\n- 首先，$19 \\times 23 = 437$。\n- 接着，$437 \\times 29 = 12673$。\n- 然后，$12673 \\times 31 = 392863$。\n- 接着，$392863 \\times 37 = 14535931$。\n- 最后，$14535931 \\times 41 = 595973171$。\n\n因此，组合内部码是\n$$\nE = 595973171.\n$$\n\n这个数值结果反映了在该机构的编码方案下，“血清葡萄糖”的合理六轴 LOINC 表示 (Glucose/MCnc/Pt/Ser/Qn/None)。", "answer": "$$\\boxed{595973171}$$", "id": "4828090"}, {"introduction": "处理完检验数据，我们再来应对另一个复杂领域：药品信息。在现实世界中，同一种药物可能以不同的商品名、包装和厂家代码（NDC）出现，这给数据整合带来了巨大挑战。本练习将带你使用 RxNorm 这一药品术语标准，体验将混乱的本地药品记录“归一化”为标准临床概念（SCD）的过程，并学习如何用精确的量化指标（如 $F_1$ 分数）来评估你所构建的数据处理流程的性能。[@problem_id:4828018]", "problem": "您正在构建一个互操作性管道，该管道将本地用药记录规范化为 RxNorm 临床层次结构。请使用以下定义作为基础：国家药品代码 (National Drug Code, NDC) 在美国唯一标识包装级别的药品，由标签商、产品和包装段组成；在 RxNorm 中，语义临床药物 (Semantic Clinical Drug, SCD) 概念类型由临床药物的规范化成分、强度和剂型（例如，“成分 强度 剂型”）定义，并与语义品牌药物 (Semantic Branded Drug, SBD) 相区别，后者还编码了品牌信息。RxNorm 标准将剂型术语（例如，“Oral Tablet”）和强度（例如，“MG”）进行规范化处理，从本地 NDC 的规范化路径通常是通过验证 NDC，通过当前的 NDC-到-RxCUI 交叉引用表直接映射到 RxNorm 概念，如果初始映射落在 SBD 上，则通过去除品牌属性同时保留成分、强度和剂型，将其投射到临床等效的 SCD 上。\n\n任务 A（概念构建）：根据 RxNorm 对 SCD 的命名约定，为临床概念“Metformin $500$ mg oral tablet”构建规范化的 RxNorm SCD 表示。您的构建必须以上述标准 SCD 词法形式表示。\n\n任务 B（规范化定量评估）：您有一个包含 $12$ 条产品记录的本地数据集，这些记录包含 NDC 和结构化字段（成分、强度、剂型、给药途径）。这些本地记录中真实的底层临床产品是：\n- $6$ 条记录：Metformin $500$ mg immediate-release oral tablets（这些是预期的目标 SCD）。在这 $6$ 条记录中，恰好有 $1$ 条使用了一个已停用的 NDC，该 NDC 不再能通过当前的 NDC-到-RxCUI 交叉引用表进行映射。\n- $3$ 条记录：Metformin $500$ mg extended-release oral tablets。\n- $2$ 条记录：Metformin $1000$ mg immediate-release oral tablets。\n- $1$ 条记录：Metformin $500$ mg oral solution。\n\n您的管道的规范化步骤是：(i) 验证 NDC 并丢弃那些无法通过交叉引用表查找的记录；(ii) 将有效的 NDC 映射到 RxNorm；如果映射到语义品牌药物 (SBD)，则将其简化为其临床等效的语义临床药物 (SCD)；(iii) 使用本地结构化字段，要求剂型为“tablet”且给药途径为“oral”；(iv) 将成分和强度分词并规范化为 RxNorm 规范形式；(v) 忽略释放特性（即，您当前的管道不区分缓释与速释）。如果规范化后的元组为（ingredient = Metformin, strength = $500$ MG, dose form = Oral Tablet），则决策规则将目标概念声明为“预测阳性”。\n\n仅使用以上信息以及精确率、召回率和调和平均数的标准定义，计算您的管道在此数据集上识别目标 SCD “Metformin $500$ MG Oral Tablet” 的 $F_1$ 分数。将 $F_1$ 分数表示为无单位的小数，并四舍五入到四位有效数字。", "solution": "此问题被评估为有效。它在科学上基于医学信息学和临床数据规范化的原则，特别是关于 RxNorm 标准。问题提取得当，提供了一套自洽、完整且一致的定义、数据和程序规则，从而可以推导出一个唯一、明确的解决方案。它以客观、正式的语言表述，没有推测或主观性陈述。\n\n该问题由两部分组成。A 部分要求概念性地构建一个语义临床药物 (SCD) 名称。B 部分要求使用标准性能指标对规范化管道进行定量评估。\n\n**A 部分：SCD 的概念构建**\n\n问题将 RxNorm 中的语义临床药物 (SCD) 定义为其规范化的成分、强度和剂型，遵循词法模式“成分 强度 剂型”。我们被要求为临床概念“Metformin $500$ mg oral tablet”构建 SCD。\n\n1.  **成分**：成分明确给出为 \"Metformin\"。在 RxNorm 中，成分是规范化的，\"Metformin\" 是标准名称。\n2.  **强度**：强度给出为“$500$ mg”。问题指出 RxNorm 会规范化强度，并以“MG”为例。因此，规范化后的强度是 \"$500$ MG\"。\n3.  **剂型**：剂型给出为“oral tablet”。问题指出 RxNorm 会规范化剂型术语，并以“Oral Tablet”为例。因此，规范化后的剂型是 \"Oral Tablet\"。\n\n根据指定的 SCD 词法形式“成分 强度 剂型”组合这些部分，得到：\nMetformin $500$ MG Oral Tablet。\n\n**B 部分：规范化的定量评估**\n\n为了计算 $F_1$ 分数，我们必须首先确定管道针对给定数据集产生的真正例 ($\\text{TP}$)、假正例 ($\\text{FP}$) 和假反例 ($\\text{FN}$) 的数量。$F_1$ 分数是精确率和召回率的调和平均数。\n\n相关公式为：\n$$ \\text{Precision} = \\frac{\\text{TP}}{\\text{TP} + \\text{FP}} $$\n$$ \\text{Recall} = \\frac{\\text{TP}}{\\text{TP} + \\text{FN}} $$\n$$ F_1 = 2 \\times \\frac{\\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}} = \\frac{2 \\times \\text{TP}}{2 \\times \\text{TP} + \\text{FP} + \\text{FN}} $$\n\n首先，我们从 $12$ 条记录的数据集中确定基本事实。\n目标概念是“Metformin $500$ MG Oral Tablet”的 SCD。问题指明，那 $6$ 条“Metformin $500$ mg immediate-release oral tablets”的记录是预期目标。\n-   **实际正例 ($P$)**：真实代表目标概念的记录数量。$P = 6$。\n-   **实际反例 ($N$)**：不代表目标概念的记录数量。这包括另外 $3+2+1=6$ 条记录。$N = 6$。\n\n接下来，我们模拟管道在每组记录上的执行，以确定管道的预测结果。如果记录的规范化元组为（ingredient = Metformin, strength = $500$ MG, dose form = Oral Tablet），管道的决策规则会将其分类为“预测阳性”。\n\n1.  **对 $6$ 条实际正例记录（Metformin $500$ mg immediate-release oral tablets）的分析：**\n    -   问题指出，这 $6$ 条记录中有 $1$ 条的 NDC 已停用，无法通过 NDC-到-RxCUI 交叉引用表进行查找。\n    -   根据管道步骤 (i)，该记录被丢弃。它是一个实际正例，但未被管道预测为阳性。这构成一个**假反例 ($\\text{FN}$)**。因此，$\\text{FN} = 1$。\n    -   剩下的 $5$ 条记录具有有效的 NDC，并通过了步骤 (i)。它们的成分、强度和剂型都是正确的。它们将通过所有后续管道步骤并匹配决策规则。这些是实际正例，并被正确预测为阳性。这构成一个**真正例 ($\\text{TP}$)**。因此，$\\text{TP} = 5$。\n\n2.  **对 $6$ 条实际反例记录的分析：**\n    -   **$3$ 条记录：Metformin $500$ mg extended-release oral tablets。**\n        -   这些记录是“oral tablets”，成分为“Metformin”，强度为“$500$ MG”。\n        -   管道步骤 (v) 指出，管道“忽略释放特性”。因此，“extended-release”属性在规范化过程中被丢弃。\n        -   最终的规范化元组将是 (Metformin, $500$ MG, Oral Tablet)，这与决策规则匹配。\n        -   这些记录是实际反例，但被预测为阳性。这构成一个**假正例 ($\\text{FP}$)**。因此，这 $3$ 条记录对 $\\text{FP}$ 计数贡献了 $3$。\n    -   **$2$ 条记录：Metformin $1000$ mg immediate-release oral tablets。**\n        -   在强度规范化后（步骤 iv），强度将为“$1000$ MG”。\n        -   这与决策规则中的强度“$500$ MG”不匹配。\n        -   这些记录被预测为反例。它们是实际反例，并被预测为反例，因此它们是真反例 ($\\text{TN}$)。\n    -   **$1$ 条记录：Metformin $500$ mg oral solution。**\n        -   管道步骤 (iii) 要求剂型为“tablet”。\n        -   该记录的剂型是“oral solution”，将无法通过此过滤器。\n        -   该记录被预测为反例。它是实际反例，并被预测为反例，因此它是真反例 ($\\text{TN}$)。\n\n计数总结：\n-   真正例 ($\\text{TP}$) = $5$\n-   假正例 ($\\text{FP}$) = $3$\n-   假反例 ($\\text{FN}$) = $1$\n-   真反例 ($\\text{TN}$) = $2 + 1 = 3$\n\n总记录检查：$\\text{TP} + \\text{FP} + \\text{FN} + \\text{TN} = 5 + 3 + 1 + 3 = 12$。计数一致。\n\n现在，我们计算精确率、召回率和 $F_1$ 分数。\n$$ \\text{Precision} = \\frac{\\text{TP}}{\\text{TP} + \\text{FP}} = \\frac{5}{5 + 3} = \\frac{5}{8} $$\n$$ \\text{Recall} = \\frac{\\text{TP}}{\\text{TP} + \\text{FN}} = \\frac{5}{5 + 1} = \\frac{5}{6} $$\n$$ F_1 = 2 \\times \\frac{\\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}} = 2 \\times \\frac{\\frac{5}{8} \\times \\frac{5}{6}}{\\frac{5}{8} + \\frac{5}{6}} $$\n为简化分母：\n$$ \\frac{5}{8} + \\frac{5}{6} = \\frac{5 \\times 3}{24} + \\frac{5 \\times 4}{24} = \\frac{15 + 20}{24} = \\frac{35}{24} $$\n代入 $F_1$ 公式：\n$$ F_1 = 2 \\times \\frac{\\frac{25}{48}}{\\frac{35}{24}} = 2 \\times \\frac{25}{48} \\times \\frac{24}{35} = 2 \\times \\frac{25}{2 \\times 35} = \\frac{25}{35} = \\frac{5}{7} $$\n最后，我们将分数转换为小数，并按要求四舍五入到四位有效数字。\n$$ F_1 = \\frac{5}{7} \\approx 0.7142857... $$\n四舍五入到四位有效数字得到 $0.7143$。", "answer": "$$\n\\boxed{0.7143}\n$$", "id": "4828018"}, {"introduction": "我们已经学习了如何解构和归一化临床数据，现在是时候见证临床术语系统最强大的能力了：逻辑推理。SNOMED CT 不仅仅是一个庞大的词典，更是一个基于描述逻辑构建的知识库，这使得计算机可以理解概念间的复杂关系。在这个高级练习中，你将通过编写代码，利用 SNOMED CT 的层级关系和属性来“意向性地”定义一个患者群体（例如“服用 β 受体阻滞剂的患者”），并动态查询出所有符合条件的具体药物，直观感受术语系统如何驱动高级临床决策支持和科研队列发现。[@problem_id:4827973]", "problem": "您将获得一个临床术语系统的简化、自包含子集，该子集旨在模仿医学系统命名法临床术语（Systematized Nomenclature of Medicine Clinical Terms, SNOMED CT）的核心行为。每个概念由一个整数概念标识符、一个人类可读的显示名称、一个活动状态以及一组关系和属性来标识。该本体被建模为一个有向无环图，其中包含用于分类层级的 $\\text{is\\_a}$ 父关系，以及用于临床药物的 $\\text{has\\_active\\_ingredient}$ 属性，该属性指向其活性成分物质。您将使用这个微型本体为“Beta受体阻滞剂”定义一个内涵值集（intensional ValueSet），并实现一个带筛选器的扩展函数 $expand$。\n\n使用的基本基础和规则：\n1. 如果存在一条从概念 $x$ 到概念 $y$ 的路径（长度可能为0），该路径遵循零个或多个 $\\text{is\\_a}$ 边，则概念 $x$ 是概念 $y$ 的后代或自身。形式上，如果 $x=y$ 或者存在一个 $p$ 使得 $\\text{is\\_a}(x,p)$ 且 $descOrSelf(p,y)$ 成立，则 $descOrSelf(x,y)$ 成立。\n2. 一个“临床药物”概念 $c$ 具有一个指向某个“物质”概念 $s$ 的 $\\text{has\\_active\\_ingredient}$ 属性。如果一个概念缺少 $\\text{has\\_active\\_ingredient}$ 属性，则在本数据集中它不是临床药物。\n3. 内涵值集（intensional ValueSet）由一个关于概念的逻辑谓词定义。其扩展是在评估时满足该谓词的所有概念的集合（定义中没有固定的、枚举的列表）。\n\n微型术语表（概念标识符、显示名称、活动状态、关系/属性）：\n- 物质：\n  - $100000$: “物质 (substance)”，活动状态 $\\mathrm{True}$；父级：无。\n  - $111000$: “Beta肾上腺素能受体拮抗剂 (substance)”，活动状态 $\\mathrm{True}$；父级：$\\{100000\\}$。\n  - $111100$: “Atenolol (substance)”，活动状态 $\\mathrm{True}$；父级：$\\{111000\\}$。\n  - $111200$: “Metoprolol (substance)”，活动状态 $\\mathrm{True}$；父级：$\\{111000\\}$。\n  - $111300$: “Propranolol (substance)”，活动状态 $\\mathrm{True}$；父级：$\\{111000\\}$。\n  - $111400$: “Carvedilol (substance)”，活动状态 $\\mathrm{True}$；父级：$\\{111000\\}$。\n  - $112000$: “Amlodipine (substance)”，活动状态 $\\mathrm{True}$；父级：$\\{100000\\}$。\n\n- 临床药物（每个都有 $\\text{has\\_active\\_ingredient}$ 和一个剂型）：\n  - $201100$: “Atenolol 50 mg oral tablet”，活动状态 $\\mathrm{True}$；父级：$\\varnothing$；$\\text{has\\_active\\_ingredient}=111100$；$\\text{dose\\_form}=\\text{\"tablet\"}$。\n  - $201101$: “Atenolol 25 mg oral tablet”，活动状态 $\\mathrm{True}$；父级：$\\varnothing$；$\\text{has\\_active\\_ingredient}=111100$；$\\text{dose\\_form}=\\text{\"tablet\"}$。\n  - $201150$: “Atenolol 10 mg/mL injection”，活动状态 $\\mathrm{False}$；父级：$\\varnothing$；$\\text{has\\_active\\_ingredient}=111100$；$\\text{dose\\_form}=\\text{\"injection\"}$。\n  - $202100$: “Metoprolol 50 mg oral tablet”，活动状态 $\\mathrm{True}$；父级：$\\varnothing$；$\\text{has\\_active\\_ingredient}=111200$；$\\text{dose\\_form}=\\text{\"tablet\"}$。\n  - $202110$: “Metoprolol 5 mg/mL injection”，活动状态 $\\mathrm{True}$；父级：$\\varnothing$；$\\text{has\\_active\\_ingredient}=111200$；$\\text{dose\\_form}=\\text{\"injection\"}$。\n  - $203100$: “Propranolol 10 mg oral tablet”，活动状态 $\\mathrm{True}$；父级：$\\varnothing$；$\\text{has\\_active\\_ingredient}=111300$；$\\text{dose\\_form}=\\text{\"tablet\"}$。\n  - $203200$: “Propranolol 40 mg oral tablet”，活动状态 $\\mathrm{True}$；父级：$\\varnothing$；$\\text{has\\_active\\_ingredient}=111300$；$\\text{dose\\_form}=\\text{\"tablet\"}$。\n  - $204100$: “Carvedilol 6.25 mg oral tablet”，活动状态 $\\mathrm{True}$；父级：$\\varnothing$；$\\text{has\\_active\\_ingredient}=111400$；$\\text{dose\\_form}=\\text{\"tablet\"}$。\n  - $204200$: “Carvedilol 3.125 mg oral tablet”，活动状态 $\\mathrm{True}$；父级：$\\varnothing$；$\\text{has\\_active\\_ingredient}=111400$；$\\text{dose\\_form}=\\text{\"tablet\"}$。\n  - $205100$: “Amlodipine 5 mg oral tablet”，活动状态 $\\mathrm{True}$；父级：$\\varnothing$；$\\text{has\\_active\\_ingredient}=112000$；$\\text{dose\\_form}=\\text{\"tablet\"}$。\n\n“Beta受体阻滞剂”的内涵值集定义：\n令 $B=111000$ 表示“Beta肾上腺素能受体拮抗剂 (substance)”概念。将值集 $V$ 定义为所有满足以下条件的临床药物 $c$：存在一个物质 $s$，使得 $\\text{has\\_active\\_ingredient}(c)=s$ 且 $descOrSelf(s,B)$ 成立。形式上，\n$$\nV \\;=\\; \\{\\, c \\mid \\exists s\\;(\\text{has\\_active\\_ingredient}(c)=s \\land descOrSelf(s,B)) \\,\\}.\n$$\n\n带筛选器的扩展函数 $expand$ 的行为：\n给定筛选器 $(a,t,d)$，其中 $a\\in\\{0,1\\}$ 是一个“仅限活动”标志，$t$ 是一个（可能为空的）字符串，用于对显示名称进行不区分大小写的子字符串匹配，$d$ 是一个（可能为空的）字符串，用于对 $\\text{dose\\_form}$ 进行精确匹配，定义如下\n$$\nexpand(V,a,t,d) \\;=\\; \\mathrm{sort}_{\\uparrow}\\Big(\\{\\, \\mathrm{id}(c) \\in V \\;\\mid\\; (a=0 \\lor \\mathrm{active}(c)=\\mathrm{True}) \\land (\\lvert t\\rvert=0 \\lor t \\text{ occurs in display}(c)) \\land (\\lvert d\\rvert=0 \\lor \\text{dose\\_form}(c)=d) \\,\\}\\Big),\n$$\n其中 $\\mathrm{sort}_{\\uparrow}$ 按概念标识符的升序数值顺序排序，“$t$ occurs in display$(c)$” 是一个不区分大小写的子字符串测试。\n\n任务：\n- 实现一个程序，使用上述本体构建集合 $V$，并为下面的每个测试用例计算 $expand(V,a,t,d)$。所有对 $t$ 的字符串比较必须不区分大小写。排序必须严格按照概念标识符的升序数值顺序进行。\n\n测试套件（每个测试用例是一个三元组 $(a,t,d)$）：\n1. $(0,\\text{\"\"},\\text{\"\"})$\n2. $(1,\\text{\"\"},\\text{\"\"})$\n3. $(1,\\text{\"tablet\"},\\text{\"\"})$\n4. $(1,\\text{\"\"},\\text{\"injection\"})$\n5. $(1,\\text{\"metoprolol\"},\\text{\"\"})$\n6. $(1,\\text{\"\"},\\text{\"capsule\"})$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的 $expand(V,a,t,d)$ 的列表结果。例如：$[\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$。结果必须是代表概念标识符的整数列表，按升序排列，不含额外文本。本任务不涉及物理单位或角度，也不需要百分比。", "solution": "该问题已经过验证，被认为是可靠、定义明确且客观的。它提供了一个自包含的数据集和一套清晰、形式化的计算规则。所有必要信息都已提供，没有矛盾之处。我们可以开始进行解答。\n\n任务是在一个简化的临床术语系统中，为一个内涵定义的值集（ValueSet）实现一个扩展函数。这需要几个步骤：表示术语，实现层级关系逻辑，构建初始值集，然后对每个测试用例应用一系列筛选器。\n\n**步骤1：数据表示**\n\n首先，我们必须将提供的术语数据结构化以便高效访问。概念及其属性可以存储在一个字典中，将每个概念标识符（整数）映射到一个对象或字典，其中包含其属性：`display`（字符串）、`active`（布尔值）、`parents`（整数集合）、`has_active_ingredient`（整数，如适用）和 `dose_form`（字符串，如适用）。\n\n由 `parents` 属性定义的 `is_a` 关系构成一个有向无环图。我们可以将其显式地表示为一个子节点到父节点的映射，这将用于遍历层级结构。例如，对于一个 `parents: {p1, p2}` 的概念 `c`，我们有 `is_a(c, p1)` 和 `is_a(c, p2)`。\n\n**步骤2：实现 `descOrSelf` 函数**\n\n`descOrSelf(x, y)` 谓词是定义值集的核心。如果概念 $x$ 是概念 $y$ 的后代或是 $y$ 本身，则该谓词成立。这等同于检查在 `is_a` 层级图中是否存在从 $x$ 到 $y$ 的路径。所提供的形式化定义，$descOrSelf(x,y)$ 在 $x=y$ 或存在一个 $p$ 使得 $\\text{is\\_a}(x,p)$ 且 $descOrSelf(p,y)$ 成立时为真，这自然地导向一个递归算法。\n\n我们将实现一个函数 `is_descendant_or_self(x, y, parent_map)`，它从概念 $x$ 开始通过其父节点向上遍历。\n1.  基本情况1：如果 $x = y$，条件满足，返回 `True`。\n2.  基本情况2：如果 $x$ 没有父节点，它不可能是任何其他概念的后代，因此返回 `False`。\n3.  递归步骤：对于 $x$ 的每个父节点 $p$，递归调用 `is_descendant_or_self(p, y, parent_map)`。如果其中任何一个调用返回 `True`，则 $x$ 是 $y$ 的后代，我们返回 `True`。\n4.  如果对所有父节点的递归都完成而没有找到 $y$，则返回 `False`。\n\n为避免在图中重复计算路径，我们可以使用记忆化（memoization），存储 `(x, y)` 对的结果。\n\n**步骤3：构建内涵值集 `V`**\n\n值集 $V$ 定义为：\n$$\nV \\;=\\; \\{\\, c \\mid \\exists s\\;(\\text{has\\_active\\_ingredient}(c)=s \\land descOrSelf(s,B)) \\,\\}\n$$\n其中 $B = 111000$ 对应于“Beta肾上腺素能受体拮抗剂 (substance)”。\n\n为了计算 $V$ 的成员，我们遍历数据集中的所有概念：\n1.  识别出“临床药物”概念。根据问题描述，这些是具有 `has_active_ingredient` 属性的概念。\n2.  对于每个临床药物 $c$，获取其活性成分物质 $s$，其中 $\\text{has\\_active\\_ingredient}(c) = s$。\n3.  使用步骤2中的函数评估谓词 $descOrSelf(s, B)$。\n4.  如果谓词为真，则将 $c$ 的概念标识符添加到 $V$ 的成员集合中。\n\n让我们根据我们的数据来追踪这个过程：\n- 目标祖先是 $B = 111000$。\n- 作为 $B$ 的后代或自身的物质是 $111100$ (Atenolol)、$111200$ (Metoprolol)、$111300$ (Propranolol) 和 $111400$ (Carvedilol)。物质 $112000$ (Amlodipine) 不是 $B$ 的后代。\n- 我们找出所有 `has_active_ingredient` 是这四种物质之一的临床药物。\n- 这包括从 $201100$ 到 $204200$ 的所有药物概念。药物概念 $205100$ (Amlodipine tablet) 被排除在外。\n- 为 $V$ 生成的概念标识符集合是 $\\{201100, 201101, 201150, 202100, 202110, 203100, 203200, 204100, 204200\\}$。\n\n**步骤4：实现 `expand` 函数**\n\n扩展函数 $expand(V, a, t, d)$ 根据一组标准筛选 $V$ 中的概念，并返回其标识符的排序列表。\n\n对于给定的筛选器集合 $(a, t, d)$，过程如下：\n1.  从标识符在 $V$ 中的完整概念集合开始。\n2.  **活动状态筛选器**：如果标志 $a=1$，则筛选集合，只保留 `active(c)` 为 `True` 的概念 $c$。如果 $a=0$，则跳过此筛选器。\n3.  **显示名称筛选器**：如果筛选字符串 $t$ 不为空，则筛选当前集合。对于每个概念 $c$，仅当 $t$ 作为不区分大小写的子字符串出现在其显示名称 `display(c)` 中时，才保留它。\n4.  **剂型筛选器**：如果筛选字符串 $d$ 不为空，则筛选当前集合。仅当概念 $c$ 的 `dose_form(c)` 属性与 $d$ 精确匹配时才保留它。\n5.  应用所有筛选器后，收集剩余概念的概念标识符。\n6.  按照 $\\mathrm{sort}_{\\uparrow}$ 的要求，将这些标识符按升序数值顺序排序。\n\n**步骤5：执行测试套件**\n\n我们将 `expand` 函数应用于集合 $V$ 的每个测试用例 $(a,t,d)$。\n\n1.  **测试用例 $(0, \\text{\"\"}, \\text{\"\"})$**：不应用任何筛选器（$a=0$，$t$ 和 $d$ 为空）。结果是 $V$ 中所有概念标识符的排序列表。\n    - 结果：$[201100, 201101, 201150, 202100, 202110, 203100, 203200, 204100, 204200]$\n\n2.  **测试用例 $(1, \\text{\"\"}, \\text{\"\"})$**：仅筛选活动概念（$a=1$）。这将移除 `active=False` 的概念 $201150$。\n    - 结果：$[201100, 201101, 202100, 202110, 203100, 203200, 204100, 204200]$\n\n3.  **测试用例 $(1, \\text{\"tablet\"}, \\text{\"\"})$**：筛选活动概念和显示名称中包含 \"tablet\" 的概念。从用例2的结果开始，我们移除显示名称中不含 \"tablet\" 的概念。这将移除 $202110$ (\"Metoprolol 5 mg/mL injection\")。\n    - 结果：$[201100, 201101, 202100, 203100, 203200, 204100, 204200]$\n\n4.  **测试用例 $(1, \\text{\"\"}, \\text{\"injection\"})$**：筛选 `dose_form` 等于 \"injection\" 的活动概念。从用例2的结果开始，只有 $202110$ 匹配 `dose_form` 筛选器。\n    - 结果：$[202110]$\n\n5.  **测试用例 $(1, \\text{\"metoprolol\"}, \\text{\"\"})$**：筛选显示名称中包含 \"metoprolol\" 的活动概念。从用例2的结果开始，只有概念 $202100$ 和 $202110$ 匹配显示名称筛选器。\n    - 结果：$[202100, 202110]$\n\n6.  **测试用例 $(1, \\text{\"\"}, \\text{\"capsule\"})$**：筛选 `dose_form` 等于 \"capsule\" 的活动概念。$V$ 中没有概念具有此 `dose_form`。\n    - 结果：$[]$\n\n这些步骤提供了一个解决该问题的完整算法，该算法将在最终程序中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the clinical terminology expansion problem.\n    \"\"\"\n    \n    # Define the miniature terminology dataset\n    concepts_data = [\n        # Substances\n        (100000, \"Substance (substance)\", True, [], {}),\n        (111000, \"Beta adrenergic receptor antagonist (substance)\", True, [100000], {}),\n        (111100, \"Atenolol (substance)\", True, [111000], {}),\n        (111200, \"Metoprolol (substance)\", True, [111000], {}),\n        (111300, \"Propranolol (substance)\", True, [111000], {}),\n        (111400, \"Carvedilol (substance)\", True, [111000], {}),\n        (112000, \"Amlodipine (substance)\", True, [100000], {}),\n        # Clinical drugs\n        (201100, \"Atenolol 50 mg oral tablet\", True, [], {\"has_active_ingredient\": 111100, \"dose_form\": \"tablet\"}),\n        (201101, \"Atenolol 25 mg oral tablet\", True, [], {\"has_active_ingredient\": 111100, \"dose_form\": \"tablet\"}),\n        (201150, \"Atenolol 10 mg/mL injection\", False, [], {\"has_active_ingredient\": 111100, \"dose_form\": \"injection\"}),\n        (202100, \"Metoprolol 50 mg oral tablet\", True, [], {\"has_active_ingredient\": 111200, \"dose_form\": \"tablet\"}),\n        (202110, \"Metoprolol 5 mg/mL injection\", True, [], {\"has_active_ingredient\": 111200, \"dose_form\": \"injection\"}),\n        (203100, \"Propranolol 10 mg oral tablet\", True, [], {\"has_active_ingredient\": 111300, \"dose_form\": \"tablet\"}),\n        (203200, \"Propranolol 40 mg oral tablet\", True, [], {\"has_active_ingredient\": 111300, \"dose_form\": \"tablet\"}),\n        (204100, \"Carvedilol 6.25 mg oral tablet\", True, [], {\"has_active_ingredient\": 111400, \"dose_form\": \"tablet\"}),\n        (204200, \"Carvedilol 3.125 mg oral tablet\", True, [], {\"has_active_ingredient\": 111400, \"dose_form\": \"tablet\"}),\n        (205100, \"Amlodipine 5 mg oral tablet\", True, [], {\"has_active_ingredient\": 112000, \"dose_form\": \"tablet\"}),\n    ]\n\n    # Process data into a more usable format\n    concepts = {}\n    parents_map = {}\n    for cid, display, active, parents, props in concepts_data:\n        concepts[cid] = {\n            \"id\": cid,\n            \"display\": display,\n            \"active\": active,\n            **props\n        }\n        parents_map[cid] = set(parents)\n\n    memo_desc = {}\n    def is_descendant_or_self(x, y):\n        \"\"\"\n        Checks if concept x is a descendant of or is concept y using recursion with memoization.\n        \"\"\"\n        if (x, y) in memo_desc:\n            return memo_desc[(x, y)]\n        \n        if x == y:\n            memo_desc[(x, y)] = True\n            return True\n        \n        if not parents_map.get(x):\n            memo_desc[(x, y)] = False\n            return False\n\n        # Recurse on parents\n        result = any(is_descendant_or_self(p, y) for p in parents_map[x])\n        memo_desc[(x, y)] = result\n        return result\n\n    # --- Step 1: Construct the ValueSet V ---\n    B = 111000  # \"Beta adrenergic receptor antagonist (substance)\"\n    V = set()\n    for cid, concept in concepts.items():\n        if \"has_active_ingredient\" in concept:\n            s = concept[\"has_active_ingredient\"]\n            if is_descendant_or_self(s, B):\n                V.add(cid)\n\n    # --- Step 2: Define and apply the expansion function ---\n    def expand(value_set_ids, a, t, d):\n        \"\"\"\n        Expands the value set with the given filters.\n        \"\"\"\n        candidate_concepts = [concepts[cid] for cid in value_set_ids]\n        \n        # Filter 1: Active status\n        if a == 1:\n            candidate_concepts = [c for c in candidate_concepts if c[\"active\"]]\n        \n        # Filter 2: Display name substring\n        if t:\n            t_lower = t.lower()\n            candidate_concepts = [c for c in candidate_concepts if t_lower in c[\"display\"].lower()]\n\n        # Filter 3: Dose form exact match\n        if d:\n            candidate_concepts = [c for c in candidate_concepts if c.get(\"dose_form\") == d]\n            \n        # Extract IDs and sort\n        result_ids = [c[\"id\"] for c in candidate_concepts]\n        result_ids.sort()\n        \n        return result_ids\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, \"\", \"\"),\n        (1, \"\", \"\"),\n        (1, \"tablet\", \"\"),\n        (1, \"\", \"injection\"),\n        (1, \"metoprolol\", \"\"),\n        (1, \"\", \"capsule\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, t, d = case\n        result = expand(V, a, t, d)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a Python list (e.g., '[1, 2]') is used for each sub-list.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4827973"}]}