{"hands_on_practices": [{"introduction": "精确的数据表示是实现互操作性的基石。本练习将侧重于 FHIR 的 `Quantity` 数据类型，并探讨一个关键挑战：单位换算，特别是在从 `mg/dL` 转换为 `mmol/L` 时，如何通过计算确保不会丢失具有临床意义的精度。这个实践将帮助你理解在设计 FHIR 数据交换时，对数值精度的严格控制为何至关重要 ([@problem_id:4839897])。", "problem": "一家医院实验室以整数形式生成血糖结果，单位为毫克/分升，使用统一计量单位代码 (Unified Code for Units of Measure, UCUM) 写作 $\\mathrm{mg/dL}$。这些结果通过快速医疗保健互操作性资源 (Fast Healthcare Interoperability Resources, FHIR) 标准进行交换，具体形式为一个 Quantity 对象，其基本字段包括一个十进制数值、一个人类可读的单位字符串、一个 UCUM 系统标识符和一个 UCUM 单位代码。一些 FHIR 客户端请求以毫摩尔/升（写作 $\\mathrm{mmol/L}$）为单位的血糖值，服务器会执行双向转换。\n\n假设以下具有科学依据的事实：\n1. D-葡萄糖的分子量为 $M = 180.15588$ $\\mathrm{g/mol}$。\n2. 从 $\\mathrm{mg/dL}$ 到 $\\mathrm{mmol/L}$ 的精确单位转换由基本定义推导得出：$\\mathrm{mg/dL}$ 表示毫克/分升，$\\mathrm{mmol/L}$ 表示毫摩尔/升。设 $x$ 表示以 $\\mathrm{mg/dL}$ 为单位的真实血糖浓度，设 $y$ 表示以 $\\mathrm{mmol/L}$ 为单位的相应真实浓度。使用基本单位变换和 $M$ 从 $x$ 推导出 $y$。\n3. 成人典型血糖值范围为 $x \\in [40, 400]$ $\\mathrm{mg/dL}$。\n\n为避免序列化数据中出现具有临床意义的精度损失，系统强制执行此验证规则：对于任意整数 $x \\in [40, 400]$，当将 $x$（单位 $\\mathrm{mg/dL}$）转换为 $y$（单位 $\\mathrm{mmol/L}$），然后为序列化目的将 $y$ 四舍五入到 $n$ 位有效数字，再转换回 $\\mathrm{mg/dL}$ 并四舍五入到最近的整数，最终的整数必须等于原始的 $x$。假设到 $n$ 位有效数字的舍入是通过“四舍五入到最近值”的方式进行的，并且在 $\\mathrm{mmol/L}$ 域中的舍入误差界限为由 $y$ 的量级和 $n$ 决定的量化步长的 $\\pm \\frac{1}{2}$。同时假设在 $\\mathrm{mg/dL}$ 中的整数舍入也是“四舍五入到最近值”，并且如果反转换后的绝对 $\\mathrm{mg/dL}$ 误差严格小于 $0.5$，则保证能够保留原始整数 $x$。\n\n请通过概念上命名必要的字段及其 UCUM 绑定来设计 Quantity 表示，然后使用 $M$ 从第一性原理推导 $\\mathrm{mg/dL}$ 和 $\\mathrm{mmol/L}$ 之间的转换关系。利用此关系，并考虑整个范围 $x \\in [40, 400]$，确定使得上述验证规则对该范围内的所有 $x$ 都成立的最小整数 $n$。你的最终答案必须是单个整数 $n$。", "solution": "问题要求计算表示血糖值所需的最小有效数字位数 $n$（以整数计），当单位为 $\\mathrm{mmol/L}$ 时，使得从一个整数 $\\mathrm{mg/dL}$ 值 $x$ 进行往返转换后能够得到原始整数。这必须对范围 $[40, 400]$ 内的所有整数值 $x$ 都成立。\n\n首先，根据问题中设计 `Quantity` 表示的要求，一个表示血糖值为 $x \\ \\mathrm{mg/dL}$ 的快速医疗保健互操作性资源 (FHIR) `Quantity` 对象通常会包含以下字段：\n- `value`：数值，例如输入为 $100$ 时，值为 $100.0$。\n- `unit`：人类可读的字符串，例如 \"milligrams per deciliter\"。\n- `system`：代码系统的 URI，对于 UCUM，它是 `\"http://unitsofmeasure.org\"`。\n- `code`：区分大小写的 UCUM 代码 `mg/dL`。\n\n对于转换为 $\\mathrm{mmol/L}$ 的值：\n- `value`：转换后的小数值。\n- `unit`：\"millimoles per liter\"。\n- `system`：`\"http://unitsofmeasure.org\"`。\n- `code`：`mmol/L`。\n\n问题的核心是确定这个转换后值的必要精度 $n$。\n\n设 $x$ 为以 $\\mathrm{mg/dL}$ 为单位的血糖浓度，$y$ 为以 $\\mathrm{mmol/L}$ 为单位的浓度。我们首先从第一性原理推导转换因子。D-葡萄糖的分子量给定为 $M = 180.15588 \\ \\mathrm{g/mol}$。\n\n为了将 $\\mathrm{mg/dL}$ 转换为 $\\mathrm{mmol/L}$，我们进行单位转换：\n$1 \\ \\mathrm{mg} = 10^{-3} \\ \\mathrm{g}$\n$1 \\ \\mathrm{g}$ 葡萄糖中的摩尔数为 $\\frac{1}{M} \\ \\mathrm{mol}$。\n所以，$1 \\ \\mathrm{mg}$ 的葡萄糖相当于 $10^{-3} \\times \\frac{1}{M} \\ \\mathrm{mol} = \\frac{10^{-3}}{M} \\ \\mathrm{mol}$。\n因为 $1 \\ \\mathrm{mol} = 10^3 \\ \\mathrm{mmol}$，我们得到 $1 \\ \\mathrm{mg} = \\frac{10^{-3}}{M} \\times 10^3 \\ \\mathrm{mmol} = \\frac{1}{M} \\ \\mathrm{mmol}$。\n\n体积单位的换算是 $1 \\ \\mathrm{dL} = 10^{-1} \\ \\mathrm{L}$。\n\n结合以上，我们建立 $y$ 和 $x$ 之间的关系：\n$$y \\ \\left[\\frac{\\mathrm{mmol}}{\\mathrm{L}}\\right] = x \\ \\left[\\frac{\\mathrm{mg}}{\\mathrm{dL}}\\right] = x \\times \\frac{\\frac{1}{M} \\ \\mathrm{mmol}}{10^{-1} \\ \\mathrm{L}} = x \\times \\frac{10}{M} \\ \\frac{\\mathrm{mmol}}{\\mathrm{L}}$$\n令转换因子为 $k = \\frac{10}{M}$。转换关系为 $y = kx$。\n\n往返转换过程如下：\n1. 从一个整数血糖值 $x_0$ 开始，其中 $x_0 \\in [40, 400]$。\n2. 转换为 $\\mathrm{mmol/L}$：$y_0 = kx_0$。\n3. 将 $y_0$ 四舍五入到 $n$ 位有效数字，得到 $y'$。设舍入误差为 $\\Delta y = y' - y_0$。\n4. 将 $y'$ 转换回 $\\mathrm{mg/dL}$：$x' = y'/k$。\n5. 将 $x'$ 四舍五入到最近的整数，得到 $x''$。\n\n验证规则要求 $x'' = x_0$。如果反转换值的绝对误差严格小于 $0.5$，即 $|x' - x_0|  0.5$，则可以保证这一点。\n让我们用舍入误差 $\\Delta y$ 来表示这个误差：\n$$|x' - x_0| = \\left|\\frac{y'}{k} - \\frac{y_0}{k}\\right| = \\frac{|y' - y_0|}{k} = \\frac{|\\Delta y|}{k}$$\n成功往返转换的条件是 $\\frac{|\\Delta y|}{k}  0.5$，等价于 $|\\Delta y|  0.5k$。\n\n接下来，我们分析舍入误差 $|\\Delta y|$。将一个数四舍五入到 $n$ 位有效数字涉及量化。量化步长 $s$ 取决于被舍入数的量级。对于一个数 $y_0$，令 $p = \\lfloor \\log_{10}(y_0) \\rfloor$。最高有效位的位值为 $10^p$。第 $n$ 位有效数字的位值为 $10^{p - (n-1)}$。这定义了步长：\n$$s = 10^{p-n+1} = 10^{\\lfloor \\log_{10}(y_0) \\rfloor - n + 1}$$\n当四舍五入到最近值时，绝对误差 $|\\Delta y|$ 的界限为步长的一半：$|\\Delta y| \\le \\frac{s}{2}$。\n\n为了满足严格不等式 $|\\Delta y|  0.5k$，误差的上限必须小于阈值：\n$$\\frac{s}{2}  0.5k \\implies s  k$$\n代入 $s$ 的表达式：\n$$10^{\\lfloor \\log_{10}(y_0) \\rfloor - n + 1}  k$$\n为了求解 $n$，我们对两边取以 10 为底的对数：\n$$\\lfloor \\log_{10}(y_0) \\rfloor - n + 1  \\log_{10}(k)$$\n$$n  \\lfloor \\log_{10}(y_0) \\rfloor + 1 - \\log_{10}(k)$$\n这个关于 $n$ 的不等式必须对 $[40, 400]$ 范围内的任何整数 $x_0$ 都成立。$\\log_{10}(k)$ 项是一个常数。我们必须找到不等式右边的最大值，它取决于 $\\lfloor \\log_{10}(y_0) \\rfloor$ 的值。由于向下取整函数是非递减的，我们必须在指定的 $x_0$ 范围内找到 $\\lfloor \\log_{10}(y_0) \\rfloor$ 的最大值。\n\n$y_0$ 的范围由 $x_0$ 的范围决定：\n$y_0 = kx_0 = \\frac{10}{M}x_0 = \\frac{10}{180.15588}x_0$。\n对于最小的 $x_0 = 40$：\n$y_{min} = \\frac{400}{180.15588} \\approx 2.22029$\n$\\log_{10}(y_{min}) \\approx 0.3464$，所以 $\\lfloor \\log_{10}(y_{min}) \\rfloor = 0$。\n\n对于最大的 $x_0 = 400$：\n$y_{max} = \\frac{4000}{180.15588} \\approx 22.2029$\n$\\log_{10}(y_{max}) \\approx 1.3464$，所以 $\\lfloor \\log_{10}(y_{max}) \\rfloor = 1$。\n\n$\\lfloor \\log_{10}(y_0) \\rfloor$ 的值在整个范围内不是恒定的。当 $y_0  10$ 时，它为 $0$；当 $y_0 \\ge 10$ 时，它为 $1$。阈值 $y_0=10$ 对应于 $x_0 = 10/k = M = 180.15588$。\n对于整数 $x_0 \\le 180$，$y_0  10$ 且 $\\lfloor \\log_{10}(y_0) \\rfloor = 0$。\n对于整数 $x_0 \\ge 181$，$y_0  10$ 且 $\\lfloor \\log_{10}(y_0) \\rfloor = 1$。\n\n为了确保不等式在整个范围内都成立，我们必须根据最坏情况来选择 $n$，即对 $n$ 施加最大下界的情况。这发生在 $\\lfloor \\log_{10}(y_0) \\rfloor$ 取最大值时，即 $\\lfloor \\log_{10}(y_0) \\rfloor = 1$。\n条件变为：\n$$n  1 + 1 - \\log_{10}(k) = 2 - \\log_{10}(k)$$\n现在，我们代入 $k = \\frac{10}{M}$：\n$\\log_{10}(k) = \\log_{10}\\left(\\frac{10}{M}\\right) = \\log_{10}(10) - \\log_{10}(M) = 1 - \\log_{10}(M)$。\n将此代入关于 $n$ 的不等式：\n$$n  2 - (1 - \\log_{10}(M))$$\n$$n  1 + \\log_{10}(M)$$\n使用给定的值 $M = 180.15588$：\n$$n  1 + \\log_{10}(180.15588)$$\n计算对数：\n$\\log_{10}(180.15588) \\approx 2.25565$。\n所以，条件是：\n$$n  1 + 2.25565$$\n$$n  3.25565$$\n由于 $n$ 必须是整数，满足此严格不等式的最小整数 $n$ 是 $4$。\n因此，至少需要 4 位有效数字来表示以 $\\mathrm{mmol/L}$ 为单位的浓度，以确保从整数 $\\mathrm{mg/dL}$ 值进行的往返转换在整个指定范围内是无损的。", "answer": "$$\\boxed{4}$$", "id": "4839897"}, {"introduction": "在能够精确表示数据之后，下一步是学习如何可靠地交换这些数据。本练习将深入探讨 FHIR RESTful API 的交互逻辑，特别是当客户端尝试进行“条件创建”操作而服务器发现重复数据时的场景。你将学习如何根据 FHIR 和 HTTP 规范，推导出正确的服务器响应状态码和结构化的错误报告 `OperationOutcome` ([@problem_id:4839847])。", "problem": "一个客户端向一台快速医疗互操作性资源 (FHIR) 服务器发出了一个超文本传输协议 (HTTP) 条件创建请求。该请求通过向 `Patient` 端点发送一个 `POST` 请求来完成，请求中带有一个 FHIR 定义的前置条件标头 `If-None-Exist`，该标头携带了一个通过标识符唯一标识一名患者的搜索表达式。服务器评估该搜索，发现由于主患者索引中存在数据重复，有 $m = 3$ 个已存在的 `Patient` 资源满足该搜索表达式。客户端的请求体是一个有效的 `Patient` 资源。\n\n您可以假定的基本事实：\n- 根据征求意见稿 (RFC) $9110$ 中关于 HTTP 条件请求的语义，当一个请求包含条件性前置条件，且该前置条件在服务器上评估为假时，正确的响应是一个指示前置条件失败的客户端错误。\n- 根据 FHIR RESTful API 的行为，如果任何现有资源与提供的搜索表达式匹配，使用 `If-None-Exist` 的条件创建请求不得创建新资源。如果恰好存在一个匹配项，服务器可以返回一个现有资源而不是创建新资源；如果存在多个匹配项，则“不存在”的条件未被满足。\n\n服务器对 $4xx$ 响应遵循以下 `OperationOutcome` 策略：\n- 它返回一个 `OperationOutcome`，其中包含一个严重性为“error”的问题，用以总结前置条件失败的原因。\n- 它还为每个匹配的资源返回一个严重性为“information”的问题，每个问题都包含对匹配资源逻辑标识符的引用。\n- 在此场景中，它不返回“warning”或“fatal”问题。\n\n任务：\n1. 使用上述基本事实以及 RFC $9110$ 中的 HTTP 前置条件语义和 FHIR 条件创建行为，推导出此响应的正确 HTTP 状态码 $s$。\n2. 按严重性计算 `OperationOutcome` 问题的数量：“error”问题的数量 $e$，“warning”问题的数量 $w$，以及“information”问题的数量 $i$。\n3. 为了产生单一数值输出，计算标量\n$$S \\;=\\; s \\;+\\; 3\\,e \\;+\\; 1\\,w \\;+\\; 0\\,i.$$\n\n提供 $S$ 的最终值，作为一个单独的数字。无需四舍五入。不要包含任何单位。", "solution": "该问题要求基于从特定的快速医疗互操作性资源 (FHIR) 服务器交互中派生的参数来计算一个标量值 $S$。验证问题陈述是首要的前提步骤。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **交互类型**：一个超文本传输协议 (HTTP) 条件创建请求。\n- **HTTP 方法**：`POST`。\n- **目标端点**：`Patient`。\n- **条件标头**：`If-None-Exist`，带有一个搜索表达式。\n- **服务器状态**：搜索表达式匹配到 $m = 3$ 个已存在的 `Patient` 资源。\n- **请求体**：一个有效的 `Patient` 资源。\n- **基本事实 (RFC 9110)**：如果一个前置条件评估为假，响应是表示前置条件失败的客户端错误。\n- **基本事实 (FHIR)**：使用 `If-None-Exist` 的条件创建在有任何现有资源匹配时不得创建新资源。如果存在多个匹配项，则“不存在”的条件未被满足。\n- **服务器 `OperationOutcome` 策略 (针对 $4xx$ 响应)**：\n    - 返回一个严重性为“error”的问题。\n    - 为每个匹配的资源返回一个严重性为“information”的问题。\n    - 不返回“warning”或“fatal”问题。\n- **任务**：\n    1. 推导 HTTP 状态码 $s$。\n    2. 计算 `OperationOutcome` 问题的数量：$e$ (“error”)、$w$ (“warning”) 和 $i$ (“information”)。\n    3. 计算标量 $S = s + 3e + 1w + 0i$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题基于 HTTP (RFC 9110) 和 FHIR 标准的正式规范。这些是计算机科学和医学信息学中已确立的技术标准，是此背景下的基本原则。该场景在技术上是合理的。\n- **适定性**：该问题提供了所有必要的数据和约束，以逻辑上推导出唯一解。问题明确无歧义，目标清晰。\n- **客观性**：该问题使用精确的技术语言表述，引用了特定的标准和策略。它不含主观或基于观点的陈述。\n- **结论**：该问题是有效的，因为它是自包含、一致且基于已确立的技术标准的。它没有违反任何无效性标准。\n\n### 问题求解\n\n求解过程是首先根据所提供的事实确定 $s$、$e$、$w$ 和 $i$ 的值，然后计算 $S$。\n\n**1. 推导 HTTP 状态码 ($s$)**\n该请求是使用 `If-None-Exist` 标头的条件 `POST` 请求。其条件是，不应存在与所提供的搜索条件匹配的资源。问题陈述服务器找到了 $m = 3$ 个匹配资源。\n\n- 由于匹配数量 $m = 3$ 大于 $0$，因此“不存在”的条件为假。\n- FHIR 规范证实了这一点：“如果存在多个匹配项，则‘不存在’的条件未被满足。”\n- 问题引用了 RFC 9110，该规范管理 HTTP 条件请求。基本事实指出，当前置条件评估为假时，服务器应返回一个客户端错误，指示前置条件失败。\n- 表示前置条件失败的标准 HTTP 状态码是 `412 Precondition Failed`。\n- 因此，HTTP 状态码 $s$ 为 $412$。\n\n$s = 412$\n\n**2. 计算 `OperationOutcome` 问题数量 ($e, w, i$)**\n服务器对 $4xx$ 错误的响应包含一个 `OperationOutcome` 资源。问题明确定义了构建此资源的策略。\n\n- **“error”问题的数量 ($e$)**: 策略规定，服务器“返回一个 `OperationOutcome`，其中包含一个严重性为‘error’的问题”。\n  因此，$e = 1$。\n\n- **“warning”问题的数量 ($w$)**: 策略规定，服务器“在此场景中不返回‘warning’...问题”。\n  因此，$w = 0$。\n\n- **“information”问题的数量 ($i$)**: 策略规定，服务器“为每个匹配的资源返回一个严重性为‘information’的问题”。\n  匹配资源的数量给定为 $m = 3$。\n  因此，$i = m = 3$。\n\n**3. 计算标量 $S$**\n最后一步是使用提供的公式和上面推导出的值来计算标量 $S$。\n公式为：\n$$S = s + 3e + 1w + 0i$$\n代入推导出的值：\n- $s = 412$\n- $e = 1$\n- $w = 0$\n- $i = 3$\n\n计算过程如下：\n$$S = 412 + 3(1) + 1(0) + 0(3)$$\n$$S = 412 + 3 + 0 + 0$$\n$$S = 415$$\n标量 $S$ 的最终值为 $415$。", "answer": "$$\\boxed{415}$$", "id": "4839847"}, {"introduction": "为了在特定场景（如国家级或机构级项目）中有效使用 FHIR，我们必须对其进行定制，这一过程称为“实施指南”（Profiling）。本练习将带你进入 FHIR 一致性（conformance）模块的核心，通过一个 `Patient` 资源的例子来阐释 `StructureDefinition` 的工作原理。你将学习如何从一个基础资源出发，应用一组“差异化”（differential）约束，并根据 FHIR 规范计算出最终“快照”（snapshot）的结构复杂性，从而深入理解切片（slicing）等高级概念 ([@problem_id:4839932])。", "problem": "给定快速医疗互操作性资源 (FHIR) 标准中患者 (Patient) 资源的部分基本配置文件。快速医疗互操作性资源 (FHIR) 定义了 StructureDefinition 的概念，它描述了资源的内容约束，分为两部分：“差量 (differential)”（指定相对于基准的更改）和“快照 (snapshot)”（在将差量应用于基准后，完全展开、合并和排序的所有元素定义的列表）。在 FHIR 中，一个元素可以被“切片 (sliced)”，这为重复元素引入了由切片规则管理的命名子定义（切片），快照中包含基础切片元素的条目，其后是其切片条目及其子元素。\n\n使用以下经过充分检验的事实作为推理的基础：\n- 在快照中，资源树中的每个元素贡献一个 ElementDefinition 条目。基元元素仅贡献其自身的条目；复杂元素贡献其自身的条目及其子元素的条目。\n- 当一个元素被切片时，快照包括基础元素（带有切片元数据），然后每个命名切片一个条目；每个切片的子元素列在该切片条目之下。基础切片元素本身不在快照中列出其子元素；只有切片会列出。\n- 差量约束必须保留不变量，例如基数一致性：切片基数必须与基础元素的基数兼容，切片规则必须与声明的鉴别器保持一致。\n\n对于本问题，仅考虑以下 Patient 元素的子集及其基本基数，并忽略下面未列出的所有其他 Patient 元素。为计数目的，将所列的复杂数据类型视为仅具有指定的子元素。\n\n基本 Patient 子集和结构（基数表示为 $m..n$，其中 $n=\\ast$ 表示无界）：\n- Patient (根元素；为计数目的，隐式基数为 $0..1$）。\n- Patient.identifier，基本基数为 $0..\\ast$，数据类型为 Identifier，在本问题中恰好有两个子元素：Identifier.system ($0..1$) 和 Identifier.value ($0..1$)。\n- Patient.telecom，基本基数为 $0..\\ast$，数据类型为 ContactPoint，在本问题中恰好有两个子元素：ContactPoint.system ($0..1$) 和 ContactPoint.value ($0..1$)。\n- Patient.gender，基本基数为 $0..1$，在本问题中没有子元素。\n- Patient.birthDate，基本基数为 $0..1$，在本问题中没有子元素。\n- Patient.name，基本基数为 $0..\\ast$，数据类型为 HumanName，在本问题中恰好有两个子元素：HumanName.family ($0..1$) 和 HumanName.given ($0..\\ast$)。为计数目的，将 HumanName.given 视为一个没有更深层子元素的子条目。\n\n现在定义一个受约束的 StructureDefinition 差量，应用以下更改，同时保留基本不变量和切片规则：\n- 根据 Identifier.system 值的鉴别器对 Patient.identifier 进行切片，引入恰好两个命名切片：\n  - Patient.identifier:ssn，基数为 $0..1$，将 Identifier.system 固定为表示社会安全号码的特定 URI。Identifier.value 保持为 $0..1$。\n  - Patient.identifier:mrn，基数为 $1..\\ast$，将 Identifier.system 固定为表示医疗记录号的特定 URI。Identifier.value 保持为 $0..1$。\n  切片必须是不相交的，并且与基础 Patient.identifier 的基数 $0..\\ast$ 兼容。\n- 将 Patient.telecom 的最小基数约束为 $1$（结果基数为 $1..\\ast$），但不切片 Patient.telecom。其子元素保持为 ContactPoint.system ($0..1$) 和 ContactPoint.value ($0..1$)。\n- 将 Patient.name 的最小基数约束为 $1$（结果基数为 $1..\\ast$），但不切片 Patient.name。其子元素保持为 HumanName.family ($0..1$) 和 HumanName.given ($0..\\ast$)。\n- 将 Patient.gender 约束为绑定到一个必需的值集；这不会引入子元素或切片。\n- Patient.birthDate 保持不变。\n\n按照所述概念性地构建隐含的差量，并使用所述的 FHIR 快照语义，计算此子集在最终快照中的 ElementDefinition 条目总数 $N$。您的答案必须是一个整数。不要引入超出所列范围的任何元素。不要考虑扩展、修饰符或此处明确指定之外的任何子元素。提供 $N$ 的最终数值答案，不带单位。", "solution": "该问题要求计算快速医疗互操作性资源 (FHIR) `StructureDefinition` 快照中 `ElementDefinition` 条目的总数 $N$。该计算基于指定的 `Patient` 资源配置文件子集和一组差量约束。此过程受所提供的快照生成规则的约束。\n\n首先，我们必须验证问题陈述。\n已知条件如下：\n1.  一组快照生成规则：\n    - 资源树中的每个元素贡献一个 `ElementDefinition` 条目。\n    - 基元元素贡献一个条目。\n    - 复杂元素贡献一个自身的条目以及其子元素的条目。\n    - 一个切片元素贡献一个用于切片基础的条目，每个命名切片一个条目，以及每个切片的子元素的条目（而不是基础元素的子元素）。\n2.  一个具有特定元素及其基数的基本 `Patient` 资源结构子集：\n    - `Patient`：根 ($0..1$)\n    - `Patient.identifier`：$0..\\ast$，复杂类型 (`Identifier`，有 $2$ 个子元素：`.system` $0..1$, `.value` $0..1$)\n    - `Patient.telecom`：$0..\\ast$，复杂类型 (`ContactPoint`，有 $2$ 个子元素：`.system` $0..1$, `.value` $0..1$)\n    - `Patient.gender`：$0..1$，基元类型\n    - `Patient.birthDate`：$0..1$，基元类型\n    - `Patient.name`：$0..\\ast$，复杂类型 (`HumanName`，有 $2$ 个子元素：`.family` $0..1$, `.given` $0..\\ast$)\n3.  一个具有特定约束的差量：\n    - `Patient.identifier` 被切分为两个命名切片：`:ssn`（基数 $0..1$）和 `:mrn`（基数 $1..\\ast$）。\n    - `Patient.telecom` 的基数更改为 $1..\\ast$。\n    - `Patient.name` 的基数更改为 $1..\\ast$。\n    - `Patient.gender` 绑定到一个值集。\n    - `Patient.birthDate` 保持不变。\n\n该问题在科学上基于正式的 FHIR 规范，这是医疗信息学中公认的标准。问题陈述清晰，提供了一套明确、自洽的规则和数据，足以推导出一个唯一的整数解。差量中提供的约束，例如 `Patient.identifier` 切片的基数（`:ssn` 为 `0..1`，`:mrn` 为 $1..\\ast$），在数学上与基础元素 $0..\\ast$ 的基数一致，因为它们范围的并集是基础范围的有效子集。问题使用客观、技术性的语言，没有歧义。因此，该问题被认为是有效的，可以推导出解决方案。\n\n`ElementDefinition` 条目的总数 $N$ 是最终快照结构中每个元素所贡献条目的总和。我们将计算每个顶层元素及其后代元素的贡献。\n\n1.  **Patient 根元素**：资源本身的根始终计为一个条目。\n    - 贡献：$1$ 个条目。\n\n2.  **Patient.identifier**：此元素被切片。根据所述规则：\n    - 基础 `Patient.identifier` 元素贡献一个条目，该条目包含切片元数据但不列出子元素。\n    - 两个命名切片 `Patient.identifier:ssn` 和 `Patient.identifier:mrn` 各贡献一个条目。\n    - 然后列出每个切片的子元素。`Identifier` 数据类型有 $2$ 个指定的子元素（`.system` 和 `.value`）。\n    - 对于 `:ssn` 切片：$1$ 个 `Patient.identifier:ssn` 条目，加上其 $2$ 个子元素（`Patient.identifier:ssn.system`, `Patient.identifier:ssn.value`）的条目。总计 $1+2=3$。\n    - 对于 `:mrn` 切片：$1$ 个 `Patient.identifier:mrn` 条目，加上其 $2$ 个子元素（`Patient.identifier:mrn.system`, `Patient.identifier:mrn.value`）的条目。总计 $1+2=3$。\n    - `Patient.identifier` 组的总贡献：$1$（基础）+ $3$（ssn 切片及其子元素）+ $3$（mrn 切片及其子元素）= $7$ 个条目。\n\n3.  **Patient.telecom**：这是一个未被切片的复杂元素。差量将其基数更改为 $1..\\ast$，但这不影响快照中定义元素的数量。\n    - 它为自身（`Patient.telecom`）贡献一个条目。\n    - 其数据类型 `ContactPoint` 有 $2$ 个指定的子元素（`.system` 和 `.value`）。这两个子元素贡献另外两个条目。\n    - `Patient.telecom` 的总贡献：$1$（自身）+ $2$（子元素）= $3$ 个条目。\n\n4.  **Patient.gender**：这是一个基元元素。其基数为 $0..1$。绑定到值集的约束不改变其结构定义或添加子元素。\n    - 它为自身贡献一个条目。\n    - 总贡献：$1$ 个条目。\n\n5.  **Patient.birthDate**：这是一个基数为 $0..1$ 的基元元素。它未被差量改变。\n    - 它为自身贡献一个条目。\n    - 总贡献：$1$ 个条目。\n\n6.  **Patient.name**：这是一个未被切片的复杂元素。差量将其基数更改为 $1..\\ast$。\n    - 它为自身（`Patient.name`）贡献一个条目。\n    - 其数据类型 `HumanName` 有 $2$ 个指定的子元素（`.family` 和 `.given`），贡献另外两个条目。`.given` 的基数（$0..\\ast$）不影响元素计数，因为它仍然是单个定义。\n    - `Patient.name` 的总贡献：$1$（自身）+ $2$（子元素）= $3$ 个条目。\n\n最后，我们将所有部分的贡献相加，以求得 `ElementDefinition` 条目的总数 $N$。\n$N = (\\text{Patient}) + (\\text{Patient.identifier 组}) + (\\text{Patient.telecom 组}) + (\\text{Patient.gender}) + (\\text{Patient.birthDate}) + (\\text{Patient.name 组})$\n$N = 1 + 7 + 3 + 1 + 1 + 3$\n$N = 16$\n\n因此，最终快照中 `ElementDefinition` 条目的总数为 $16$。", "answer": "$$\n\\boxed{16}\n$$", "id": "4839932"}]}