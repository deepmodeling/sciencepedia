## 引言
在当今的数字医疗时代，信息是提供高质量、高效率医疗服务的命脉。然而，医疗信息系统普遍存在“数据孤岛”现象——不同的电子健康记录（EHR）、实验室和影像系统之间难以有效沟通，这严重阻碍了临床协作、科学研究和患者赋能。为了破解这一困局，一个现代化、基于网络技术、且灵活可扩展的数据交换标准应运而生，它就是 FHIR——快速医疗互操作资源标准。FHIR 凭借其创新的设计理念，正迅速成为全球医疗信息化的基石。

本文将系统性地引导你深入 FHIR 的世界。在第一部分“原则与机制”中，我们将剖析 FHIR 的架构哲学，探索其核心数据模型和交互模式，理解其如何从根本上解决[互操作性](@entry_id:750761)难题。接着，在“应用与跨学科连接”部分，我们将走出理论，考察 FHIR 在临床决策支持、患者应用、基因组学研究等真实场景中的强大威力，展示其如何连接不同的医疗领域。最后，“动手实践”部分将提供一系列精心设计的问题，帮助你将你在理论学习中获得的知识转化为解决实际问题的能力。

通过本次学习，你将不仅掌握 FHIR 的技术细节，更能洞悉其在构建下一代智慧医疗生态系统中的战略价值。让我们首先深入其设计的核心，揭开 FHIR 的原则与机制。

## 原则与机制

在前一章中，我们介绍了快速医疗互操作资源（FHIR）标准产生的背景及其总体目标。本章将深入探讨支撑 FHIR 的核心原则与关键机制。我们将从其根本的架构哲学出发，剖析其数据模型的基础构件，探索其交互模式，并最终审视其确保一致性与可信度的先进机制。理解这些原则与机制，对于有效设计和实现稳健、可扩展的医疗信息系统至关重要。

### FHIR 架构哲学：资源与 REST

现代医疗保健是一个由众多异构系统组成的分布式环境。一家医院可能同时运行着电子健康记录（EHR）、实验室信息系统（LIS）、放射学信息系统（RIS）以及药房管理系统，这些系统通常来自不同厂商，拥有各自独立的数据库和工作流程。在这样的生态系统中，如何实现安全、可靠且有意义的数据交换，是医疗信息学面临的核心挑战。

传统的系统设计常常借鉴[关系型数据库](@entry_id:275066)的理念，通过高度**规范化（Normalization）**的数据表来最小化[数据冗余](@entry_id:187031)。这种模型在单一、强一致性的数据库内部表现出色，因为它依赖于同步连接（synchronous joins）和事务的强一致性。然而，当试图将此模型扩展到跨越组织边界、网络分区不可避免的分布式环境中时，其脆弱性便暴露无遗。我们不能再假设可以随时跨系统执行一个事务性的、同步的连接操作。

FHIR 的设计哲学从根本上拥抱了这种分布式现实。它没有尝试构建一个庞大、统一的全局数据库，而是采用了一种基于**表述性状态转移（Representational State Transfer, REST）**的架构风格。REST 风格的核心思想是将系统中的每一个重要概念都建模为一个可通过网络寻址的**资源（Resource）**。

在 FHIR 中，一个**资源**是医疗保健流程中一个可识别的、独立的、最小化的信息交换单元。例如，一个病人（`Patient`）、一次就诊（`Encounter`）、一项观察结果（`Observation`）或一个药物请求（`MedicationRequest`）都是资源。每个资源都有自己独立的身份标识（URI）、生命周期和版本历史。这种设计被称为**松散耦合（Loose Coupling）**。资源之间通过稳定的引用（references）相互链接，而非依赖于数据库层面的外键约束。

这种架构选择带来了深远的影响。设想一个区域性的健康信息交换（HIE）平台，它连接了多家医院和诊所 [@problem_id:4839875]。当一个实验室系统产生了一份新的血红蛋白观察结果（`Observation`）时，它只需将这份 `Observation` 资源发布出去。一个独立的药物管理服务可以订阅或查询这份资源，并根据其内容创建一份补铁药物的`MedicationRequest`。这两个系统无需知晓对方内部的数据模式或工作流程；它们仅需理解并遵循标准的 FHIR `Observation` 和 `MedicationRequest` 资源定义。

这种以资源为中心、通过 RESTful API 进行交互的方法，天然地适应了[分布式系统](@entry_id:268208)的挑战 [@problem_id:4839933]：
- **互操作性（Interoperability）**：由于每个资源都遵循统一的全球标准，并且通过标准的 HTTP 协议进行交换，任何符合 FHIR 规范的客户端都可以与任何符合规范的服务器进行交互。
- **独立演化（Independent Evolution）**：实验室系统可以升级其内部软件，只要它对外发布的 `Observation` 资源仍然符合 FHIR 标准，药物管理系统就无需任何更改。
- **[容错](@entry_id:142190)性（Fault Tolerance）**：根据 **CAP 定理**（一致性 Consistency、可用性 Availability、分区[容错](@entry_id:142190)性 Partition tolerance），在存在网络分区的分布式系统中，我们无法同时保证强一致性和高可用性。RESTful 架构通常优先选择可用性。即使某个系统暂时离线，其他系统仍然可以继续运行，并处理它们可访问的数据。

然而，这种架构也带来了需要权衡的方面。资源的高度**粒度化（granularity）**虽然灵活，但也意味着构建一个完整的临床视图（如病人摘要）可能需要多次网络请求，这被称为“**话痨（chattiness）**”问题。例如，获取一个包含病人基本信息、最近一次就诊、三项重要观察结果和一份药物请求的摘要，就需要分别请求 $n=6$ 个不同的资源。如果客户端的[网络延迟](@entry_id:752433)为 $\ell = 80\,\text{ms}$，并且每次只能串行请求，总耗时将接近 $n \times \ell = 480\,\text{ms}$。幸运的是，FHIR 提供了多种机制（如并行请求、缓存以及我们稍后将讨论的 `Bundle`）来缓解这一性能开销。

### 基础构件：数据类型与资源结构

理解了 FHIR 的宏观架构后，我们需要深入其内部，审视构成一个资源的具体“积木”——数据类型。FHIR 定义了一套丰富的数据类型，它们是构建所有资源的基础。这些数据类型可分为两大类：**原始类型（Primitive Types）**和**复杂类型（Complex Types）** [@problem_id:4839880]。

**原始类型**代表一个单一、[原子性](@entry_id:746561)的值，例如 `string`（字符串）、`boolean`（布尔值）、`decimal`（十进制数）或 `instant`（时间戳）。它们在序列化时直接表现为其值，并且除了标准的扩展机制外，自身不能再包含命名的子元素。

**复杂类型**则是由一组命名的子元素构成的结构化数据。它们如同一个容器，将多个相关的值捆绑在一起。在临床[数据建模](@entry_id:141456)中，有几对关键的复杂类型其区别至关重要，必须准确理解和使用。

#### Identifier 与 Reference：业务身份与技术指针

在处理跨系统数据时，如何唯一地指代一个实体（如病人）是一个核心问题。FHIR 提供了两种截然不同的机制：`Identifier` 和 `Reference` [@problem_id:4839850]。

- **Identifier（标识符）**：代表一个**业务标识符**。它是由某个权威机构（如医院、政府）分配给一个实体的稳定标签，用于在特定业务上下文中识别该实体。例如，病人的病历号（MRN）、身份证号或社保号码。一个 `Identifier` 数据类型包含两个关键部分：`system`（定义该标识符命名空间的 URI）和 `value`（标识符的值）。它的核心用途是**匹配（matching）**和**查找（lookup）**。

- **Reference（引用）**：代表一个指向另一个 FHIR 资源实例的**技术指针**或“外键”。它可以是一个相对 URL（如 `"Patient/123"`），指向同一服务器上的另一个资源；也可以是一个绝对 URL（如 `"https://alpha.example.org/fhir/Patient/123"`），指向任何可访问的 FHIR 服务器上的资源。它的核心用途是**解引用（dereferencing）**，即通过该指针直接获取目标资源。

这两者的选择取决于系统的耦合程度和交互上下文。设想这样一个场景：一个健康信息交换平台（HIE）需要将外部实验室的检验结果路由给两家独立的医疗机构——阿尔法医院和贝塔诊所。这两家机构都有自己的 FHIR 服务器，并且出于安全和网络策略的考虑，它们之间无法直接访问对方的服务器。

贝塔诊所通过其 MRN “B-9981” 来识别病人。阿尔法医院则通过其内部的 FHIR 资源逻辑 ID “Patient/123” 来识别同一位病人。当 HIE 需要将一份指向该病人的 `Observation` 资源发送给阿尔法医院时，它应该如何填充 `Observation.subject` 字段？

- 如果使用 `Reference` 并将其设置为贝塔诊所的资源地址（如 `"https://beta.example.org/fhir/Patient/B-9981"`），阿尔法医院的服务器将无法处理，因为它无法访问该地址。
- 正确的做法是使用 `Identifier`。HIE 可以在 `Observation.subject.identifier` 中填入 `{ "system": "urn:oid:1.2.3.4", "value": "B-9981" }`，其中 `system` 是贝塔诊所 MRN 的唯一命名空间。当阿尔法医院的系统收到这个 `Observation` 后，它不会尝试去“解引用”这个标识符，而是会在自己的病人数据库中**搜索**拥有相同 `Identifier` 的 `Patient` 资源。一旦找到匹配的本地病人（即 “Patient/123”），就可以将这份检验结果与正确的病人关联起来。

因此，`Identifier` 是在松散耦合、无法保证直接网络访问的跨组织环境中进行实体关联的首选机制。而 `Reference` 则适用于单个服务器内部的资源链接，或者在明确可以跨服务器进行授权访问的紧密集成场景中。

#### code、Coding 与 CodeableConcept：编码概念的层级表达

在医疗领域，准确地表达临床概念（如诊断、药品、检验项目）至关重要。FHIR 为此提供了一套层级递进的数据类型：`code`、`Coding` 和 `CodeableConcept` [@problem_id:4839880]。

- **`code`**：这是一个原始类型，本质上是一个字符串。它的特殊之处在于，其值的含义由其所在的上下文（即它所属的元素）所决定。规范通常会将 `code` 类型的元素**绑定（binding）**到一个预定义的**值集（ValueSet）**。例如，`Observation.status` 的类型是 `code`，它被绑定到一个包含 “final”、“amended”、“preliminary” 等值的值集。发送方只需发送字符串 “final”，接收方根据 `Observation.status` 的定义就能理解其含义。它本身不携带编码体系信息。

- **`Coding`**：这是一个复杂类型，它将一个编码值与其所属的**编码体系（Code System）**捆绑在一起。一个 `Coding` 对象包含 `system`（编码体系的唯一 URI，如 LOINC 的 `http://loinc.org`）、`code`（编码值，如 `15074-8`）、`version`（可选，编码体系的版本）和 `display`（可选，人类可读的描述，如 “Glucose [Moles/volume] in Blood”）。`Coding` 是一个自包含、无歧义的编码表示。

- **`CodeableConcept`**：这是最灵活和最常用的编码表示方式。它也是一个复杂类型，其核心是一个 `coding` 数组（可以包含一个或多个 `Coding` 对象）和一个可选的 `text` 字段。`CodeableConcept` 的设计目的在于：
    1.  允许使用来自不同编码体系的编码来表示同一个概念（例如，同时提供一个 SNOMED CT 码和一个 ICD-10 码）。
    2.  提供一个人类可读的文本描述（`text` 字段），以防接收方无法识别任何一个编码。

FHIR 规范是**强类型**的。如果一个元素的类型被定义为 `CodeableConcept`，那么在实例中就必须使用 `CodeableConcept` 的结构，即使你只想发送一个 `Coding`。例如，`Observation.code`（标识检验项目）和 `Observation.component.code`（标识子检验项目）的类型都是 `CodeableConcept`。即使只用一个 LOINC 码来表示，也必须将其包装在 `CodeableConcept` 结构中，如 `{"coding": [{"system": "http://loinc.org", "code": "15074-8"}]}`。绝不能因为只有一个编码就直接使用 `Coding` 的结构来代替。同样，当观察结果本身是一个分类值时（如病原体鉴定结果），应使用 `valueCodeableConcept` 来承载。

### 交互模式：FHIR RESTful API

定义了资源的结构之后，下一步是规定如何通过网络对这些资源进行操作。FHIR 的 RESTful API 严格遵循 HTTP 协议，将标准的 **CRUD**（创建、读取、更新、删除）操作映射到 HTTP 动词，并利用 HTTP 的特性来支持更复杂的交互模式 [@problem_id:4839895]。

#### CRUD 操作与 HTTP 动词

HTTP 协议对每个方法（动词）的**安全性（Safety）**和**[幂等性](@entry_id:190768)（Idempotency）**有明确定义：
- **安全**的方法不应改变服务器的状态（如 `GET`）。
- **幂等**的方法重复执行多次，其效果与执行一次相同（如 `GET`, `PUT`, `DELETE`）。`POST` 通常不是幂等的。

FHIR 的 CRUD 映射正是基于这些原则：
- **创建（Create）**：使用 `POST` 请求到资源类型的端点（如 `POST /Patient`）。`POST` 不是幂等的，因为连续多次发送同样的 `POST` 请求通常会创建多个新的、独立的资源。
- **读取（Read）**：使用 `GET` 请求到资源的具体实例端点（如 `GET /Patient/123`）或类型端点进行搜索（如 `GET /Patient?name=John`）。`GET` 是安全且幂等的。
- **更新（Update）**：使用 `PUT` 请求到资源的具体实例端点（如 `PUT /Patient/123`）。`PUT` 是幂等的，因为它代表“完全替换”，用请求体中的资源完整地替换服务器上的版本。无论发送一次还是多次，最终结果都是服务器上的资源与请求体一致。
- **删除（Delete）**：使用 `DELETE` 请求到资源的具体实例端点（如 `DELETE /Patient/123`）。`DELETE` 是幂等的，因为第一次删除成功后，后续的删除请求不会再改变服务器的状态。

#### 条件化交互

在分布式系统中，并发操作是常态，这可能导致“丢失更新”或重复创建等问题。FHIR 定义了“条件化”交互来优雅地处理这些情况。

- **条件化创建（Conditional Create）**：假设一个客户端需要创建一个病人记录，但前提是该病人（通过某个唯一标识符判断）尚不存在。如果直接使用 `POST`，在客户端发起请求和服务器完成创建之间，另一个客户端可能已经创建了同一个病人，导致数据重复。
    解决方案是在 `POST` 请求中加入 `If-None-Exist` HTTP 头。该头的值是一个查询字符串，如 `identifier=http://myhospital.com/mrn|12345`。服务器收到请求后会：
    1.  执行该查询。
    2.  如果**没有**匹配的资源，则创建新资源，并返回 `201 Created`。
    3.  如果**恰好**有一个匹配的资源，则不创建，直接返回 `200 OK` 及该现有资源。
    4.  如果**有多个**匹配的资源，说明唯一性前提不满足，服务器将拒绝该请求，返回 `412 Precondition Failed`。

- **条件化更新（Conditional Update）**：这主要解决“丢失更新”问题。想象两个用户同时读取了同一个病人的版本 `1`，用户 A 修改了地址并提交，服务器将其更新为版本 `2`。随后，用户 B 修改了电话并提交（其提交的仍然是基于版本 `1` 的修改）。如果服务器直接接受，用户 A 的地址修改就会被覆盖丢失。
    FHIR 提供了基于 ETag 的版本感知更新来防止这种情况。当客户端读取资源时，服务器会在响应头中返回一个 `ETag`（实体标签），其值通常是资源的 `meta.versionId`。当客户端提交 `PUT` 更新时，必须在请求头中包含 `If-Match`，其值应为它所基于的版本的 `ETag`。
    1.  如果 `If-Match` 头中的 `ETag` 与服务器上资源的当前 `ETag` 匹配，说明没有发生并发修改，服务器接受更新。
    2.  如果不匹配（如此例中，服务器上已经是版本 `2`，而用户 B 的 `If-Match` 仍然是版本 `1`），服务器将拒绝更新，并返回 `412 Precondition Failed`。这迫使客户端重新获取最新版本的资源，在其基础上进行修改，然后再次提交。

此外，FHIR 还支持基于搜索条件的条件化更新。例如，`PUT /Patient?identifier=...`，如果查询恰好匹配一个病人，则更新该病人；如果没有匹配，则根据请求体创建一个新病人。

### 处理复杂性：批量操作与复合视图

正如之前提到的，资源的粒度化可能导致客户端需要发起大量请求来构建一个完整的视图。FHIR 提供了 `Bundle` 资源来应对这一挑战，它是一个可以容纳多个其他资源的容器 [@problem_id:4839846]。`Bundle` 的 `type` 元素决定了服务器应如何处理其中的内容。

- **`searchset`**：当客户端执行搜索操作时，服务器返回的 `Bundle` 类型是 `searchset`。它包含了所有匹配搜索条件的资源。
- **`history`**：当客户端请求一个资源的历史版本时，服务器返回的 `Bundle` 类型是 `history`。

对于向服务器提交多个操作，`batch` 和 `transaction` 是两种最重要的 `Bundle` 类型。

- **`batch`（批处理）**：一个 `batch` 类型的 `Bundle` 包含一组相互独立的 HTTP 交互。服务器会逐个处理 `Bundle` 中的每个条目，就像它们是单独发送的请求一样。其中一个条目的成功或失败，不影响其他条目。这种方式提供了**失败隔离**，适用于需要高效提交大量不相关或弱相关数据的场景。

- **`transaction`（事务）**：一个 `transaction` 类型的 `Bundle` 则要求服务器**原子性（atomically）**地处理所有条目。这意味着 `Bundle` 中的所有操作要么全部成功提交，要么在任何一个操作失败时全部回滚，服务器状态不发生任何改变。这种方式对于维护数据完整性至关重要，特别是当 `Bundle` 内的资源存在相互引用时。例如，一个事务可以同时创建一个 `Patient` 资源和多个引用该新病人的 `Observation` 资源。服务器必须保证，如果 `Patient` 创建失败，那些 `Observation` 也绝不会被创建。

因此，选择 `batch` 还是 `transaction` 取决于业务需求：如果需要保证一组操作的整体性和完整性，则必须使用 `transaction`；如果操作之间相互独立，且希望最大化成功率（即使有部分失败），则应选择 `batch`。

### 确保一致性与扩展性：剖析

FHIR 作为一个全球标准，提供的是一个通用的“80%解决方案”。为了满足特定国家、地区或项目的需求（即剩余的20%），FHIR 提供了一套强大的**剖析（Profiling）**机制 [@problem_id:4839866]。剖析允许实现者在不改变基础规范的前提下，对资源进行约束和扩展。

剖析的核心是 **`StructureDefinition`** 资源，它被用来定义两种关键的符合性构件：

- **`Profile`（剖面）**：一个 `Profile` 是一个 `StructureDefinition`，它对一个现有的基础资源（如 `Patient`）或数据类型施加约束。这些约束可以包括：
    - **修改[基数](@entry_id:754020)（Cardinality）**：例如，将原本可选的 `Patient.gender`（基数 `0..1`）设置为必填项（基数 `1..1`）。
    - **绑定值集（Value Set Binding）**：将一个编码字段（如 `Observation.status`）的允许值范围从标准值集缩小到一个更具体的本地值集。
    - **约束数据类型或值**：例如，规定 `Patient.identifier` 必须是 MRN。

- **`Extension`（扩展）**：一个 `Extension` 也是一个 `StructureDefinition`，但它的作用是定义一个在基础资源中**不存在**的新数据元素。例如，FHIR `Patient` 资源没有“母亲娘家姓”这个字段。通过定义一个 `Extension`，我们就可以标准地表示和交换这个信息。扩展数据被携带在资源实例的 `extension` 数组中。

`StructureDefinition` 资源通过一个名为 **`differential`** 的部分来表达这些变化。`differential` 只包含与基础资源定义**不同**的部分。当验证工具或服务器需要理解一个 `Profile` 的完整定义时，它会将基础资源的定义与 `differential` 中的约束进行合并，生成一个称为 **`snapshot`** 的完整视图。实例的验证是根据这个 `snapshot` 来进行的。

在 `Profile` 中，一个经常被误解的标志是 **`MustSupport`**。将一个元素标记为 `MustSupport = true`，并不意味着该元素在每个资源实例中都必须存在。它是一个对**实现者**（服务器或客户端）的要求，表明任何声称符合该 `Profile` 的系统，都**必须有能力**理解、处理和存储该元素。一个元素是否必填，仅由其基数（`cardinality`）的最小值是否大于0决定。例如，一个 `Profile` 可以将 `Patient.telecom` 标记为 `MustSupport` 但基数仍为 `0..*`，这意味着系统必须支持电话号码，但病人实例可以不提供电话号码。

最后，一个资源实例通过在其 `meta` 元素中声明 `meta.profile` 来宣告它符合某一个或多个 `Profile`。

### 建立信任与可验证性

在医疗保健领域，数据的可信度至关重要。FHIR 提供了多种机制来建立和验证数据的[信任链](@entry_id:747264)。

#### 服务器端[版本控制](@entry_id:264682)与业务修订

每个 FHIR 资源都有一个 `meta` 元素，其中包含由服务器维护的技术[元数据](@entry_id:275500) [@problem_id:4839913]。其中两个关键字段是：
- **`meta.versionId`**：服务器为资源的每个持久化版本分配的唯一标识符。每当资源的持久化内容发生改变时，服务器就会创建一个新版本，并赋予一个新的 `versionId`。
- **`meta.lastUpdated`**：服务器记录的该版本被创建或更新的时间戳。

这两个字段反映的是资源的**技术持久化状态**，它们由服务器严格控制。这必须与**业务修订**区分开来。例如，在药物核对工作流中，药剂师可能只是重新审阅了病人的用药清单，确认无误，但并未对任何药物数据做任何修改。这个“审阅完成”是一个重要的业务事件，但它并未改变任何 `MedicationList` 资源的内容。因此，在这种情况下，不应该创建新的资源版本。这个业务事件应该通过其他方式记录，例如创建一个 `Task` 资源来表示任务完成，或者使用 `Provenance` 资源记录审阅活动。混淆技术版本与业务事件会导致 `versionId` 的无谓增长，并丢失工作流程的真实语义。

#### 使用 Provenance 追踪数据谱系

要真正信任一份数据，我们不仅需要它的当前状态，还需要知道它的来源、经历过哪些处理、由谁负责。FHIR 的 **`Provenance`** 资源正是为此而生 [@problem_id:4839863]。它基于 W3C PROV 数据模型，用于记录数据谱系或血缘关系。

一个 `Provenance` 资源主要描述了：
- **`target`（目标）**：一个或多个该 `Provenance` 记录所描述的资源。
- **`agent`（代理）**：参与创建或修改目标资源的个人、组织或设备。每个 `agent` 都有一个角色，如 `author`（作者）、`enterer`（录入者）或 `verifier`（验证者）。
- **`entity`（实体）**：在活动中被用作输入或来源的数据。

设想一个实验室工作流：分析仪设备在 $t_a$ 时刻测量标本产生原始结果；LIS 系统在 $t_l$ 时刻进行单位换算；病理学家在 $t_p$ 时刻审核并确认结果，最终生成一份 `Observation` 资源。为了记录这个完整的谱系，我们可以创建一个 `Provenance` 资源，其 `target` 指向这份最终的 `Observation`。`agent` 列表将包括：分析仪设备、LIS 系统和那位病理学家，并分别记录下他们的活动时间。标本本身可以被记录为 `entity`。

更进一步，`Provenance` 资源可以包含**[数字签名](@entry_id:269311)**。通过让病理学家对这个 `Provenance` 资源进行签名，就创建了一个不可否认的加密链接，将这位特定专家、在特定时间、基于特定流程的验证行为，与最终的 `Observation` 结果牢固地绑定在一起，从而为数据的可信度提供了最高级别的保证。

#### 使用 CapabilityStatement 发现服务器能力

在与一个 FHIR 服务器进行任何有意义的交互之前，客户端必须首先了解该服务器“能做什么”和“不能做什么”。**`CapabilityStatement`** 资源就是服务器发布的一份机器可读的“能力合同” [@problem_id:4839853]。

客户端通过 `GET [base]/metadata` 来获取这份声明。`CapabilityStatement` 详细说明了：
- **支持的资源类型**：服务器支持哪些 FHIR 资源（如 `Patient`, `Observation`）。
- **支持的交互**：对于每种资源，服务器支持哪些 RESTful 交互（如 `create`, `read`, `update`, `search-type`）。如果 `Observation` 的交互列表中没有 `update`，那么客户端就不应该尝试更新 `Observation`。
- **支持的搜索参数**：对于每种资源，客户端可以使用哪些参数进行搜索。
- **支持的操作（Operations）**：服务器支持哪些自定义的 `$operation`。
- **安全机制**：服务器使用何种认证和授权方案，例如是否支持 **SMART on FHIR**（它基于 OAuth 2.0 流程）。
- **符合性声明**：服务器默认遵循或额外支持哪些 `Profile`。

`CapabilityStatement` 是 FHIR 动态发现和健壮交互的基础。一个行为良好的客户端必须在交互前检查 `CapabilityStatement`，并只执行服务器明确声明支持的操作，从而实现真正的、无需硬编码的互操作性。