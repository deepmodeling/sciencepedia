{"hands_on_practices": [{"introduction": "医学知识表征的基础在于将复杂的临床信息分解为机器可读的原子化陈述。这项练习将指导你完成这个过程，将一个简单的患者场景转化为资源描述框架（RDF）中的基本“主语-谓语-宾语”三元组结构。这是使临床数据变得可计算和可分析的第一步，也是构建任何知识图谱的基石 [@problem_id:4849831]。", "problem": "一个医院知识图谱正在使用资源描述框架 (Resource Description Framework, RDF) 和资源描述框架模式 (Resource Description Framework Schema, RDFS) 来构建，以表示临床数据。在 RDF 中，一个陈述是一个由主语、谓语和宾语组成的三元组，其中主语和谓语是国际化资源标识符 (Internationalized Resource Identifiers, IRIs)，而宾语则是一个 IRI 或一个字面量。在 RDFS 中，类成员关系使用谓语 rdf:type 来断言。\n\n您被要求为一个仅有一个诊断和一个实验室检验结果的患者，对以下事实进行建模：\n- 该患者是 Patient 类的一个实例。\n- 该诊断是 Diagnosis 类的一个实例。\n- 该实验室结果是 LabResult 类的一个实例。\n- 该患者通过对象属性 hasDiagnosis 与诊断相连接。\n- 该患者通过对象属性 hasLabResult 与实验室结果相连接。\n- 该实验室结果带有三个数据属性：value（一个十进制类型的字面量）、unit（一个字符串字面量）和 date（一个词法形式为 \"YYYY-MM-DD\" 的 XML Schema 日期字面量）。\n\n使用本体命名空间 http://med.example.org/ont# 表示类和属性（例如，http://med.example.org/ont#Patient, http://med.example.org/ont#hasDiagnosis），并使用资源命名空间 http://med.example.org/res# 表示个体（例如，http://med.example.org/res#P001）。将实验室值表示为十进制类型的字面量，单位表示为纯字符串字面量（如 \"mmol/L\"），日期表示为规范词法形式 \"YYYY-MM-DD\" 的 XML Schema 日期字面量。除了类成员关系断言之外，不要包含任何模式公理（例如，不要包含 rdfs:domain, rdfs:range, 或 rdfs:label）；仅使用在 RDF 和 RDFS 类型化下编码上述事实所需的最小三元组集合。\n\n从概念上定义必要的三元组，然后确定表示这一个患者、一个诊断和一个实验室结果的上述所有事实所需的最少不同 RDF 三元组数量。设此数量为 $N$。请提供 $N$ 作为您的最终答案。最终答案无需四舍五入，也无需包含单位。", "solution": "我们从核心定义开始：\n- 在资源描述框架 (RDF) 中，每个事实都编码为一个由主语 $s$、谓语 $p$ 和宾语 $o$ 组成的三元组 $\\langle s,p,o\\rangle$，其中 $s$ 和 $p$ 是国际化资源标识符 (IRIs)，而 $o$ 是一个 IRI 或一个字面量。\n- 在资源描述框架模式 (RDFS) 中，类成员关系使用谓语 rdf:type 来断言；也就是说，一个个体 $x$ 是类 $C$ 的一个实例，由三元组 $\\langle x,\\text{rdf:type},C\\rangle$ 表示。\n- 对象属性连接两个 IRI（例如，一个个体患者 IRI 连接到一个个体诊断 IRI），而数据属性连接一个 IRI 和一个字面量（例如，一个实验室结果个体连接到一个数值字面量）。\n\n根据指定的建模约束，我们必须断言以下事实：\n1. 个体患者属于 Patient 类。\n2. 个体诊断属于 Diagnosis 类。\n3. 个体实验室结果属于 LabResult 类。\n4. 患者通过 hasDiagnosis 与诊断相关联。\n5. 患者通过 hasLabResult 与实验室结果相关联。\n6. 实验室结果有一个 value 数据属性，其宾语是一个十进制类型的字面量。\n7. 实验室结果有一个 unit 数据属性，其宾语是一个字符串字面量。\n8. 实验室结果有一个 date 数据属性，其宾语是一个 XML Schema 日期类型的字面量。\n\n根据定义，这些事实中的每一个都需要一个 RDF 三元组；在 RDF 中，没有任何单个三元组可以编码两个独立的事实。因此，最小表示将为上述八个事实中的每一个包含一个三元组。\n\n为了使之具体，使用所提供的命名空间：\n- 使用诸如 http://med.example.org/res#P001 的 IRI 代表患者，http://med.example.org/res#DxA 代表诊断，以及 http://med.example.org/res#LRB 代表实验室结果。\n- 使用本体 IRI http://med.example.org/ont#Patient, http://med.example.org/ont#Diagnosis, http://med.example.org/ont#LabResult 代表类，以及 http://med.example.org/ont#hasDiagnosis, http://med.example.org/ont#hasLabResult, http://med.example.org/ont#value, http://med.example.org/ont#unit, http://med.example.org/ont#date 代表属性。\n\n三元组的概念列表如下：\n- ⟨http://med.example.org/res#P001, rdf:type, http://med.example.org/ont#Patient⟩\n- ⟨http://med.example.org/res#DxA, rdf:type, http://med.example.org/ont#Diagnosis⟩\n- ⟨http://med.example.org/res#LRB, rdf:type, http://med.example.org/ont#LabResult⟩\n- ⟨http://med.example.org/res#P001, http://med.example.org/ont#hasDiagnosis, http://med.example.org/res#DxA⟩\n- ⟨http://med.example.org/res#P001, http://med.example.org/ont#hasLabResult, http://med.example.org/res#LRB⟩\n- ⟨http://med.example.org/res#LRB, http://med.example.org/ont#value, \"v\"^^xsd:decimal⟩\n- ⟨http://med.example.org/res#LRB, http://med.example.org/ont#unit, \"mmol/L\"⟩\n- ⟨http://med.example.org/res#LRB, http://med.example.org/ont#date, \"YYYY-MM-DD\"^^xsd:date⟩\n\n计算这些三元组，不同三元组的总数为 $N = 8$。\n\n为了论证其最小性，请注意：\n- 省略任何 rdf:type 三元组将无法表示所需的类成员关系事实之一（Patient、Diagnosis 或 LabResult）。\n- 省略任何对象属性三元组将无法表示所需的关系之一（hasDiagnosis 或 hasLabResult）。\n- 省略任何数据属性三元组将无法表示所需的属性之一（value、unit 或 date）。\n- 在标准 RDF 中，将这些事实中的任意两个组合成一个三元组是不可能的，因为每个三元组只有一个谓语，不能同时编码两个独立的谓语，也不能同时编码类成员关系和属性断言。\n\n因此，所需的最少三元组数量为 $8$。", "answer": "$$\\boxed{8}$$", "id": "4849831"}, {"introduction": "在掌握了 RDF 的基础之后，我们可以使用网络本体语言（OWL）来定义更复杂的逻辑规则和关系，从而丰富我们的知识模型。本练习探讨如何表示复杂的临床概念，例如通过多个条件组合定义的诊断，并展示自动推理机如何基于这些规则推断出未被明确说明的新知识。理解断言知识与推断知识之间的区别，是发挥本体强大功能的核心 [@problem_id:4849852]。", "problem": "一家医院的知识库使用以下词汇表，其命名空间为 ex:。资源描述框架 (RDF) 和 RDF 模式 (RDFS) 用于基本类型化和子类化，而 Web 本体语言 (OWL) 用于类表达式。给出以下术语：\n- ex:hasDiagnosis 是一个 OWL 对象属性，其 RDFS 域为 ex:Patient，RDFS 值域为 ex:Diagnosis。\n- ex:MyocardialInfarction 是一个 OWL 类，是 ex:Diagnosis 的 RDFS 子类，也是 ex:CardiovascularDisease 的 RDFS 子类。\n- ex:Patient 是一个 OWL 类，是 ex:Person 的 RDFS 子类。\n\n一个个体 ex:p123 被断言为 OWL 类表达式“病人患有某种心肌梗死诊断”的实例，形式上为描述逻辑交集和存在量化限制 $ex{:}Patient \\sqcap \\exists\\,ex{:}hasDiagnosis.ex{:}MyocardialInfarction$。\n\n根据第一性原理：\n- 在描述逻辑中，交集的成员关系分布于每个合取项：对于任何个体 $a$， $a \\in C \\sqcap D$ 意味着 $a \\in C$ 且 $a \\in D$。\n- 存在量化限制 $\\exists\\,R.C$ 表示通过属性 $R$ 与类 $C$ 中至少一个个体相关联的个体集合；它本身并不在 RDF 图中断言或命名任何特定的相关个体。\n- 在 RDFS 下，如果 $C \\sqsubseteq D$，那么 $a \\in C$ 意味着 $a \\in D$。\n\n你的任务有两部分：(i) 根据 OWL 2 RDF 映射，选择一个选项，该选项能正确地将 ex:p123 作为 $ex{:}Patient \\sqcap \\exists\\,ex{:}hasDiagnosis.ex{:}MyocardialInfarction$ 实例的 OWL 类断言编码为 RDF 三元组；以及 (ii) 列出只有那些健全的前向链接物化推理机会在不引入新的命名或空白节点个体来见证存在量化的情况下添加的 rdf:type 断言。\n\n假设以下 TBox 三元组存在，并可用于推理：\n- ex:hasDiagnosis rdf:type owl:ObjectProperty.\n- ex:hasDiagnosis rdfs:domain ex:Patient.\n- ex:hasDiagnosis rdfs:range ex:Diagnosis.\n- ex:MyocardialInfarction rdfs:subClassOf ex:Diagnosis.\n- ex:MyocardialInfarction rdfs:subClassOf ex:CardiovascularDisease.\n- ex:Patient rdfs:subClassOf ex:Person.\n\n哪个选项同时满足 (i) 和 (ii)？\n\nA. RDF 编码：\n- ex:p123 rdf:type _:C.\n- _:C rdf:type owl:Class.\n- _:C owl:intersectionOf _:L.\n- _:L rdf:first ex:Patient.\n- _:L rdf:rest _:L2.\n- _:L2 rdf:first _:R.\n- _:L2 rdf:rest rdf:nil.\n- _:R rdf:type owl:Restriction.\n- _:R owl:onProperty ex:hasDiagnosis.\n- _:R owl:someValuesFrom ex:MyocardialInfarction.\n物化的 rdf:type 断言（不引入新个体）：\n- ex:p123 rdf:type ex:Patient.\n- ex:p123 rdf:type ex:Person.\n\nB. RDF 编码：\n- ex:p123 rdf:type ex:Patient.\n- ex:p123 ex:hasDiagnosis _:d1.\n- _:d1 rdf:type ex:MyocardialInfarction.\n物化的 rdf:type 断言（不引入新个体）：\n- ex:p123 rdf:type ex:Person.\n- _:d1 rdf:type ex:Diagnosis.\n\nC. RDF 编码：\n- ex:p123 rdf:type _:R.\n- _:R rdf:type owl:Restriction.\n- _:R owl:onProperty ex:Diagnosis.\n- _:R owl:someValuesFrom ex:MyocardialInfarction.\n物化的 rdf:type 断言（不引入新个体）：\n- ex:p123 rdf:type ex:CardiovascularDisease.\n\nD. RDF 编码：\n- ex:p123 rdf:type _:C.\n- _:C rdf:type owl:Class.\n- _:C owl:intersectionOf _:L.\n- _:L rdf:first _:R.\n- _:L rdf:rest _:L2.\n- _:L2 rdf:first ex:Patient.\n- _:L2 rdf:rest rdf:nil.\n- _:R rdf:type owl:Restriction.\n- _:R owl:onProperty ex:hasDiagnosis.\n- _:R owl:allValuesFrom ex:MyocardialInfarction.\n物化的 rdf:type 断言（不引入新个体）：\n- ex:p123 rdf:type ex:Patient.\n- ex:p123 rdf:type ex:CardiovascularDisease.", "solution": "用户希望我扮演一位严谨的 STEM 教授，解决一个医学信息学问题。我将首先验证问题陈述，然后进行详细解答。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **词汇表：** 一个命名空间 `ex:`。\n*   **技术：** RDF、RDFS、OWL。\n*   **定义：**\n    *   `$ex{:}hasDiagnosis$` 是一个 `$owl{:}ObjectProperty$`，其 `$rdfs{:}domain$` 为 `$ex{:}Patient$`，`$rdfs{:}range$` 为 `$ex{:}Diagnosis$`。\n    *   `$ex{:}MyocardialInfarction$` 是一个 `$owl{:}Class$`，是 `$ex{:}Diagnosis$` 的 `$rdfs{:}subClassOf$`，也是 `$ex{:}CardiovascularDisease$` 的 `$rdfs{:}subClassOf$`。\n    *   `$ex{:}Patient$` 是一个 `$owl{:}Class$`，是 `$ex{:}Person$` 的 `$rdfs{:}subClassOf$`。\n*   **断言：** 一个个体 `$ex{:}p123$` 是 OWL 类表达式 `$ex{:}Patient \\sqcap \\exists\\,ex{:}hasDiagnosis.ex{:}MyocardialInfarction$` 的一个实例。\n*   **原理：**\n    1.  对于一个个体 $a$，$a \\in C \\sqcap D$ 意味着 $a \\in C$ 且 $a \\in D$。\n    2.  $\\exists\\,R.C$ 表示通过属性 $R$ 与类 $C$ 中至少一个个体相关联的个体集合；它本身并不断言一个特定的相关个体。\n    3.  如果 $C \\sqsubseteq D$，那么 $a \\in C$ 意味着 $a \\in D$。\n*   **任务：** 正确选项必须满足两个条件：\n    *   (i) 它根据 OWL 2 RDF 映射正确地将类断言编码为 RDF。\n    *   (ii) 它只列出健全的前向链接推理机在不引入新个体的情况下会添加的 `$rdf{:}type$` 断言。\n*   **TBox 公理：**\n    *   `$ex{:}hasDiagnosis$ $rdf{:}type$ $owl{:}ObjectProperty$.\n    *   `$ex{:}hasDiagnosis$ $rdfs{:}domain$ $ex{:}Patient$.\n    *   `$ex{:}hasDiagnosis$ $rdfs{:}range$ $ex{:}Diagnosis$.\n    *   `$ex{:}MyocardialInfarction$ $rdfs{:}subClassOf$ $ex{:}Diagnosis$.\n    *   `$ex{:}MyocardialInfarction$ $rdfs{:}subClassOf$ $ex{:}CardiovascularDisease$.\n    *   `$ex{:}Patient$ $rdfs{:}subClassOf$ $ex{:}Person$.\n\n**步骤 2：使用提取的已知条件进行验证**\n\n*   **科学基础：** 该问题基于万维网联盟 (W3C) 的标准——Web 本体语言 (OWL 2)、资源描述框架 (RDF) 和 RDF 模式 (RDFS) 的正式规范。描述逻辑的语法和语义都得到了正确表示。\n*   **适定性：** 该问题是适定的。它要求在给定一组清晰的公理和约束（不生成见证）的情况下，根据标准语义，对一个特定的 OWL 类断言进行正确的 RDF 序列化并推导出后续的逻辑蕴涵。基于这些正式标准，存在一个唯一的、可验证的答案。\n*   **客观性：** 该问题以精确、正式的语言陈述，没有歧义或主观性。\n\n该问题没有任何无效性缺陷。它是知识表示和自动推理领域一个标准的、非平凡的问题。\n\n**步骤 3：结论与行动**\n\n问题陈述是 **有效的**。我将继续进行详细的推导和选项评估。\n\n### 正确解的推导\n\n该问题包含两个必须正确解决的部分：(i) RDF 编码和 (ii) 物化的类型断言。\n\n**第 (i) 部分：正确的 RDF 编码**\n\n该断言指出，个体 `$ex{:}p123$` 是一个复杂的匿名类的实例。该类由两个类表达式的交集定义：命名类 `$ex{:}Patient$` 和存在量化限制 $\\exists\\,ex{:}hasDiagnosis.ex{:}MyocardialInfarction$。\n\n形式化的 DL 表达式为：$ex{:}Patient \\sqcap \\exists\\,ex{:}hasDiagnosis.ex{:}MyocardialInfarction$\n\n根据 OWL 2 基于 RDF 的语义以及从 OWL 2 功能性语法到 RDF 图的映射，这个类断言的编码如下：\n\n1.  个体 `$ex{:}p123$` 被声明为一个匿名类的类型 (`$rdf{:}type$`)，该匿名类通常由一个空白节点（例如 `_:C`）表示。\n    *   `$ex{:}p123$ $rdf{:}type$ _:C$.\n2.  这个空白节点 `_:C` 必须被声明为一个由交集定义的 `$owl{:}Class$`。\n    *   `_:C$ $rdf{:}type$ $owl{:}Class$.\n    *   `_:C$ $owl{:}intersectionOf$ _:L$.\n3.  `$owl{:}intersectionOf$` 属性指向一个 RDF 列表 (`_:L`)，该列表包含被求交集的类表达式。在本例中，有两个：`$ex{:}Patient$` 和存在量化限制。\n4.  存在量化限制 $\\exists R.C$ 由一个类型为 `$owl{:}Restriction$` 的空白节点表示。该限制指定了属性 (`$owl{:}onProperty$`) 以及该属性值的来源类 (`$owl{:}someValuesFrom$`)。\n    *   `_:R$ $rdf{:}type$ $owl{:}Restriction$.\n    *   `_:R$ $owl{:}onProperty$ $ex{:}hasDiagnosis$.\n    *   `_:R$ $owl{:}someValuesFrom$ $ex{:}MyocardialInfarction$.\n\n结合以上几点，并使用 RDF 列表语法 (`$rdf{:}first$`, `$rdf{:}rest$`, `$rdf{:}nil$`)，正确的编码是一组等价于以下内容的三元组：\n```\n$ex{:}p123$ $rdf{:}type$ _:C$.\n_:C$ $rdf{:}type$ $owl{:}Class$.\n_:C$ $owl{:}intersectionOf$ _:L$.\n_:L$ $rdf{:}first$ $ex{:}Patient$.  （列表元素的顺序在语义上不重要）\n_:L$ $rdf{:}rest$ _:L2$.\n_:L2$ $rdf{:}first$ _:R$.\n_:L2$ $rdf{:}rest$ $rdf{:}nil$.\n_:R$ $rdf{:}type$ $owl{:}Restriction$.\n_:R$ $owl{:}onProperty$ $ex{:}hasDiagnosis$.\n_:R$ $owl{:}someValuesFrom$ $ex{:}MyocardialInfarction$.\n```\n\n**第 (ii) 部分：物化的 `rdf:type` 断言**\n\n一个健全的前向链接推理机在给定的 TBox 和 ABox（断言箱）上操作。ABox 包含第 (i) 部分推导出的 RDF 编码。问题明确禁止推理机引入新的个体来见证存在量化限制。\n\n1.  **从交集推断：** 问题给出的原理是，交集的成员关系分布于其合取项。初始断言是 `$ex{:}p123$` 是该交集类的实例：\n    $ex{:}p123 \\in ex{:}Patient \\sqcap \\exists\\,ex{:}hasDiagnosis.ex{:}MyocardialInfarction$。\n    因此，推理机将推断出：\n    *   `$ex{:}p123$ $\\in$ $ex{:}Patient$`，这转换成三元组：`$ex{:}p123$ $rdf{:}type$ $ex{:}Patient$。\n    *   `$ex{:}p123$ $\\in$ $\\exists\\,ex{:}hasDiagnosis.ex{:}MyocardialInfarction$。\n\n2.  **从子类公理推断：** 问题陈述了原理：如果 $C \\sqsubseteq D$ 且 $a \\in C$，那么 $a \\in D$。TBox 包含 `$ex{:}Patient$ $rdfs{:}subClassOf$ $ex{:}Person$`。由于推理机推断出 `$ex{:}p123$ $rdf{:}type$ $ex{:}Patient$`，它还将推断出：\n    *   `$ex{:}p123$ $rdf{:}type$ $ex{:}Person$。\n\n3.  **从存在量化限制推断：** `$ex{:}p123$` 是“患有某种类型为 `MyocardialInfarction` 的诊断”的实体类的一个实例，这一推断本身不会为 `$ex{:}p123$` 生成新的 `$rdf{:}type$` 断言。这是一个关于 `$ex{:}p123$` 关系的陈述，而不是关于其顶层分类的陈述。如果没有额外的公理（例如，为存在量化限制本身设定一个超类，如 $\\exists R.C \\sqsubseteq S$），或者不创建见证个体（这被禁止），就无法从表达式的这一部分物化出 `$ex{:}p123$` 的更多类型。\n\n因此，在不引入新个体的情况下，物化的 `$rdf{:}type$` 断言的完整集合是：\n*   `$ex{:}p123$ $rdf{:}type$ $ex{:}Patient$.\n*   `$ex{:}p123$ $rdf{:}type$ $ex{:}Person$.\n\n### 逐项分析\n\n**A. RDF 编码：... 物化的 rdf:type 断言：...**\n\n*   **第 (i) 部分评估：** 此选项中提供的 RDF 编码是 OWL 交集类的直接且正确的序列化，它使用了空白节点 (`_:C`)、`$owl{:}intersectionOf$`、一个 RDF 列表 (`_:L`, `_:L2`)，以及一个用于存在量化限制的空白节点 (`_:R`)，并带有 `$owl{:}onProperty$` 和 `$owl{:}someValuesFrom$`。这完全符合 OWL 2 RDF 映射标准。\n*   **第 (ii) 部分评估：** 物化的断言 `$ex{:}p123$ $rdf{:}type$ $ex{:}Patient$` 和 `$ex{:}p123$ $rdf{:}type$ $ex{:}Person$`，正是从交集和子类化原理推导出来的，并遵守了不创建见证个体的约束。\n\n**结论：** **正确**。\n\n**B. RDF 编码：... 物化的 rdf:type 断言：...**\n\n*   **第 (i) 部分评估：** RDF 编码 (`$ex{:}p123$ $rdf{:}type$ $ex{:}Patient$. `$ex{:}p123$ $ex{:}hasDiagnosis$ _:d1$. `_:d1$ $rdf{:}type$ $ex{:}MyocardialInfarction$.) 没有编码原始断言，即对一个匿名类的成员关系断言。相反，它断言了一组*满足*该类描述的事实。它创建了一个空白节点 `_:d1` 作为存在量化的见证，这是一种不同类型的断言，并且明确超出了问题中推理部分的范围。对于给定的类断言，这不是正确的 OWL 2 RDF 映射。\n*   **第 (ii) 部分评估：** 由于第 (i) 部分不正确，此分析没有意义。\n\n**结论：** **不正确**。\n\n**C. RDF 编码：... 物化的 rdf:type 断言：...**\n\n*   **第 (i) 部分评估：** RDF 编码存在缺陷。它完全省略了交集中的 `$ex{:}Patient$` 合取项。它还错误地使用一个类 `$ex{:}Diagnosis$` 作为 `$owl{:}onProperty$` 的值，而该值必须是一个属性。正确的属性是 `$ex{:}hasDiagnosis$`。\n*   **第 (ii) 部分评估：** 物化的断言 `$ex{:}p123$ $rdf{:}type$ $ex{:}CardiovascularDisease$` 是一个无效的推断。*诊断* (`$ex{:}MyocardialInfarction$`) 是 `$ex{:}CardiovascularDisease$` 的子类这一事实，并不意味着*病人*也属于该类型。这代表了一个范畴错误。\n\n**结论：** **不正确**。\n\n**D. RDF 编码：... 物化的 rdf:type 断言：...**\n\n*   **第 (i) 部分评估：** RDF 编码使用 `$owl{:}allValuesFrom$` 来定义限制。这对应于全称量化限制 ($\\forall$)，而不是问题陈述中给出的存在量化限制 ($\\exists$) ($... \\exists\\,ex{:}hasDiagnosis...$)。它编码了错误的逻辑表达式，即 `$ex{:}Patient \\sqcap \\forall\\,ex{:}hasDiagnosis.ex{:}MyocardialInfarction$`。\n*   **第 (ii) 部分评估：** 与选项 C 一样，物化的断言 `$ex{:}p123$ $rdf{:}type$ $ex{:}CardiovascularDisease$` 是一个无效的推断。\n\n**结论：** **不正确**。", "answer": "$$\\boxed{A}$$", "id": "4849852"}, {"introduction": "构建了结构化的知识图谱后，我们如何利用它来回答实际的临床问题？本练习将挑战你编写一个 SPARQL 查询，这是查询 RDF 数据的标准语言，用以识别符合特定临床标准的患者群体。通过这个实践，你将把抽象的知识表示理论与临床数据分析的具体应用联系起来，体会到知识图谱在支持临床决策和研究中的巨大潜力 [@problem_id:4849805]。", "problem": "您将获得一个简化的医学实验室数据模型，其灵感来源于资源描述框架（Resource Description Framework, RDF）和简单协议与RDF查询语言（Simple Protocol and RDF Query Language, SPARQL）。该模型将实验室观测表示为 $\\langle s, p, o \\rangle$ 形式的三元组，其中主语 $s$ 是一个观测资源，谓语 $p$ 是一个属性（例如患者引用或测量时间），而宾语 $o$ 是一个患者资源、一个字面量值或其他资源。在SPARQL中，基本图模式（Basic Graph Patterns, BGPs）通过共享变量进行连接以形成绑定；例如，变量 $?o_1$ 和 $?o_2$ 可以在共享变量 $?patient$ 上连接，以断言它们指向同一名患者。您将处理肌钙蛋白实验室观测数据，在临床实践中，肌钙蛋白代表心脏生物标志物。我们假设一次观测具有以下核心属性：类型、患者主语、编码、解读以及一个有效时间（以入院后的小时数作为十进制数测量）。\n\n基本基础：\n- 在RDF中，一次观测由形式为 $\\langle \\text{obs}, \\text{predicate}, \\text{object} \\rangle$ 的三元组表示。\n- 在SPARQL中，一个基本图模式是三元组模式的合取，连接在共享变量上执行，从而产生解映射。\n- 时间窗口约束可以表示为对字面量的算术过滤器，例如要求 $0  t_2 - t_1 \\le 24$，其中 $t_1$ 和 $t_2$ 是表示小时的数字字面量。\n\n任务：\n1. 构建一个SPARQL SELECT查询，该查询返回在24小时窗口内有两次不同异常肌钙蛋白观测 $?o_1$ 和 $?o_2$ 的不同患者 $?patient$。观测必须满足：\n   - 两个观测编码 $?c_1$ 和 $?c_2$ 都是肌钙蛋白编码。\n   - 两次观测的解读都等于“异常”。\n   - 两次观测是不同的，即 $?o_1 \\ne ?o_2$。\n   - 它们的有效时间 $t_1$ 和 $t_2$ 是十进制小时数，并满足 $0  t_2 - t_1 \\le 24$。\n   您必须依赖标准的SPARQL 1.1结构、基本图模式、共享变量上的连接以及对数字字面量（小时）的算术FILTER条件。不要依赖于特定供应商的日期函数。查询必须对观测 $?o_1$、$?o_2$、患者 $?patient$、编码 $?c_1$、$?c_2$ 和有效时间 $?t_1$、$?t_2$ 使用变量绑定，并且必须选择不同的 $?patient$。\n\n2. 实现一个程序，该程序不执行SPARQL，而是通过对观测数组执行等效的逻辑连接和过滤，为提供的合成测试数据集计算出相同的患者集合。每次观测由一条记录表示，包含：患者标识符（整数）、编码（字符串）、时间（小时，浮点数）、值（浮点数）、单位（字符串）和异常标志（布尔值）。肌钙蛋白编码集包含两个编码，如果一次观测的异常标志为真，则认为该观测是异常的。如果存在一对不同的异常肌钙蛋白观测，其时间 $t_1$ 和 $t_2$（以小时为单位测量）满足 $0  t_2 - t_1 \\le 24$ 小时且 $t_2 > t_1$，则该患者符合条件。\n\n单位和约束：\n- 时间必须以小时为单位处理；所有时间比较和差异都应以小时为单位计算。\n- 必须严格执行不等式 $0  t_2 - t_1 \\le 24$；相等的时间戳（$t_2 - t_1 = 0$）不符合条件。\n- 成对条件适用于任何肌钙蛋白编码；两次观测可以有不同的肌钙蛋白编码。\n\n测试套件：\n为以下四个参数集提供一个解决方案，每个参数集都是一个观测列表，表示为元组 $(\\text{patient\\_id}, \\text{code}, t, v, \\text{unit}, \\text{abnormal})$，其中 $t$ 是以小时为单位的时间， $v$ 是测量值，unit 是一个字符串（在这些测试中始终为 \"ng/mL\"），abnormal 是一个布尔值。\n\n- 案例A（一般情况）：\n  - 肌钙蛋白编码: \"LOINC:89579-7\", \"LOINC:67151-1\".\n  - 观测:\n    - $(1, \\text{\"LOINC:89579-7\"}, 1.0, 0.05, \\text{\"ng/mL\"}, \\text{true})$\n    - $(1, \\text{\"LOINC:89579-7\"}, 20.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(2, \\text{\"LOINC:89579-7\"}, 5.0, 0.03, \\text{\"ng/mL\"}, \\text{false})$\n    - $(2, \\text{\"LOINC:89579-7\"}, 15.0, 0.05, \\text{\"ng/mL\"}, \\text{true})$\n    - $(3, \\text{\"LOINC:67151-1\"}, 0.0, 0.07, \\text{\"ng/mL\"}, \\text{true})$\n    - $(3, \\text{\"LOINC:67151-1\"}, 12.0, 0.08, \\text{\"ng/mL\"}, \\text{true})$\n    - $(3, \\text{\"LOINC:67151-1\"}, 36.0, 0.09, \\text{\"ng/mL\"}, \\text{true})$\n    - $(4, \\text{\"LOINC:89579-7\"}, 0.0, 0.10, \\text{\"ng/mL\"}, \\text{true})$\n    - $(4, \\text{\"LOINC:89579-7\"}, 50.0, 0.09, \\text{\"ng/mL\"}, \\text{true})$\n- 案例B（边界和违规情况）：\n  - 观测:\n    - $(5, \\text{\"LOINC:89579-7\"}, 0.0, 0.05, \\text{\"ng/mL\"}, \\text{true})$\n    - $(5, \\text{\"LOINC:89579-7\"}, 24.0, 0.05, \\text{\"ng/mL\"}, \\text{true})$\n    - $(6, \\text{\"LOINC:67151-1\"}, 0.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(6, \\text{\"LOINC:67151-1\"}, 24.1, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(7, \\text{\"LOINC:67151-1\"}, 0.0, 0.07, \\text{\"ng/mL\"}, \\text{true})$\n    - $(7, \\text{\"LOINC:67151-1\"}, 0.0, 0.08, \\text{\"ng/mL\"}, \\text{true})$\n- 案例C（多对和非肌钙蛋白噪声）：\n  - 观测:\n    - $(8, \\text{\"LOINC:89579-7\"}, 10.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(8, \\text{\"LOINC:89579-7\"}, 12.0, 0.07, \\text{\"ng/mL\"}, \\text{true})$\n    - $(8, \\text{\"LOINC:89579-7\"}, 13.0, 0.08, \\text{\"ng/mL\"}, \\text{true})$\n    - $(9, \\text{\"LOINC:89579-7\"}, 0.0, 0.05, \\text{\"ng/mL\"}, \\text{true})$\n    - $(9, \\text{\"LOINC:89579-7\"}, 10.0, 0.03, \\text{\"ng/mL\"}, \\text{false})$\n    - $(9, \\text{\"LOINC:89579-7\"}, 30.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(10, \\text{\"NON-TROPONIN\"}, 5.0, 2.0, \\text{\"ng/mL\"}, \\text{true})$\n- 案例D（混合不同肌钙蛋白编码）：\n  - 观测:\n    - $(11, \\text{\"LOINC:89579-7\"}, 1.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(11, \\text{\"LOINC:67151-1\"}, 20.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(12, \\text{\"LOINC:89579-7\"}, 1.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(12, \\text{\"LOINC:67151-1\"}, 30.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(13, \\text{\"LOINC:67151-1\"}, 5.0, 0.03, \\text{\"ng/mL\"}, \\text{false})$\n    - $(13, \\text{\"LOINC:67151-1\"}, 20.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n\n输出规范：\n您的程序必须生成单行输出，其中包含结果。结果是一个用方括号括起来的逗号分隔列表，每个元素对应一个测试用例，并且本身是一个按升序排列的不同合格患者标识符列表。例如，输出必须看起来像 $[[a_1,a_2],[b_1],[],[c_1,c_2]]$，其中每个 $a_i$、$b_i$、$c_i$ 都是一个整数。\n\n缩略语定义：\n- 资源描述框架 (Resource Description Framework, RDF)。\n- 简单协议与RDF查询语言 (Simple Protocol and RDF Query Language, SPARQL)。\n- Web本体语言 (Web Ontology Language, OWL)。\n\n答案类型：\n- 程序的输出必须是整数列表的列表。不得打印任何物理单位或百分比符号；所有内部时间计算都必须以小时为单位。", "solution": "我们首先展示SPARQL查询，然后推导出一个在算法上等同于该查询基本图模式和FILTER语义的程序。\n\n### 1. SPARQL SELECT 查询\n\n假设RDF数据使用 `ex:` 命名空间来定义谓词，如 `ex:patientSubject`, `ex:code`, `ex:interpretation` 和 `ex:effectiveTime`。时间 `t` 以小时为单位，类型为 `xsd:decimal`。肌钙蛋白编码为字符串字面量。\n\n```sparql\nPREFIX ex: <http://med.example.org/ont#>\nPREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n\nSELECT DISTINCT ?patient\nWHERE {\n  # 为同一患者找到两个不同的观测值\n  ?o1 ex:patientSubject ?patient .\n  ?o2 ex:patientSubject ?patient .\n  FILTER(?o1 != ?o2)\n\n  # 两个观测值的编码都必须是肌钙蛋白编码\n  ?o1 ex:code ?c1 .\n  ?o2 ex:code ?c2 .\n  FILTER(?c1 IN (\"LOINC:89579-7\", \"LOINC:67151-1\"))\n  FILTER(?c2 IN (\"LOINC:89579-7\", \"LOINC:67151-1\"))\n\n  # 两个观测值的解读都必须是“异常”\n  # (假设解读为字符串 \"异常\" 或布尔值 true)\n  ?o1 ex:interpretation \"异常\" .\n  ?o2 ex:interpretation \"异常\" .\n\n  # 获取它们的时间并应用时间窗口过滤器\n  ?o1 ex:effectiveTime ?t1 .\n  ?o2 ex:effectiveTime ?t2 .\n  FILTER(0 < (?t2 - ?t1) && (?t2 - ?t1) <= 24)\n}\n```\n这个查询通过在共享变量 `?patient` 上连接两个观测值 `?o1` 和 `?o2` 来工作。它过滤以确保观测值是不同的，属于指定的肌钙蛋白编码，且都被标记为异常。最后，`FILTER` 子句对观测时间应用了核心的业务逻辑：第二次观测必须严格发生在第一次之后，并且两者的时间差在24小时（含）以内。\n\n### 2. 算法逻辑实现\n\n为了在不使用SPARQL引擎的情况下计算相同的结果，我们执行以下步骤，这在逻辑上等同于SPARQL查询的连接和过滤操作：\n1.  **过滤和分组**：遍历所有观测数据。仅保留那些 `code` 在指定的肌钙蛋白编码集内且 `abnormal` 标志为 `true` 的观测。将这些合格观测的时间（小时）按其 `patient_id` 分组。\n2.  **自我连接和应用条件**：对于每个患者，如果他们有至少两个合格的观测时间点，我们就需要检查这些时间点的所有唯一对 $(t_1, t_2)$。为了避免重复和确保顺序，我们可以先对时间列表进行排序。然后，对于排序后的时间列表中的每一对时间 $(t_i, t_j)$ 且 $j > i$，我们计算时间差 $\\Delta t = t_j - t_i$。\n3.  **最终过滤和选择**：如果时间差 $\\Delta t$ 满足条件 $0  \\Delta t \\le 24$，那么该患者就符合条件。我们将该患者的ID添加到一个集合中，以确保最终结果中的患者ID是唯一的。\n4.  **格式化输出**：最后，将所有符合条件的患者ID集合转换为排序后的列表，并按测试用例进行组织。\n\n根据这个逻辑，我们对每个测试用例进行分析：\n-   **案例A**: 患者1有两个异常肌钙蛋白观测值，时间分别为1.0和20.0小时。时间差为19.0，在 (0, 24] 区间内。患者3有两个异常观测值，时间分别为0.0和12.0小时。时间差为12.0，在 (0, 24] 区间内。患者2和4不符合条件。结果：`[1, 3]`。\n-   **案例B**: 患者5的时间差为 `24.0 - 0.0 = 24.0`，在区间内。患者6的时间差为24.1，超出范围。患者7的两个异常观测在同一时间点，时间差为0，不满足 `> 0` 的条件。结果：`[5]`。\n-   **案例C**: 患者8有多个观测值，例如10.0和12.0小时，时间差为2.0，在区间内。患者9的两个异常观测值时间差为30.0，超出范围。患者10的观测值不是肌钙蛋白。结果：`[8]`。\n-   **案例D**: 患者11有两个不同编码的异常肌钙蛋白观测值，时间差为19.0，在区间内。患者12的时间差为29.0，超出范围。患者13只有一个异常观测值。结果：`[11]`。\n\n综合所有案例，最终结果为 `[[1, 3], [5], [8], [11]]`。", "answer": "```python\n# Python 3.12 compliant solution.\n# Libraries allowed: numpy (1.23.5), scipy (1.11.4) – we only use numpy for potential array handling.\nimport numpy as np\n\ndef qualifying_patients(observations, troponin_codes, window_hours=24.0):\n    \"\"\"\n    Determine patients with at least two distinct abnormal troponin observations\n    within a time window of window_hours, with strict positivity (t2  t1)\n    and inclusive upper bound (t2 - t1 = window_hours).\n    observations: list of dicts with keys:\n        patient_id (int), code (str), time_hours (float), value (float),\n        unit (str), abnormal (bool)\n    troponin_codes: set of strings indicating troponin codes to include.\n    Returns sorted list of distinct qualifying patient_ids.\n    \"\"\"\n    # Group relevant (troponin + abnormal) times by patient.\n    by_patient = {}\n    for obs in observations:\n        code = obs[\"code\"]\n        if code in troponin_codes and obs[\"abnormal\"]:\n            pid = obs[\"patient_id\"]\n            t = float(obs[\"time_hours\"])\n            by_patient.setdefault(pid, []).append(t)\n\n    qualifying = set()\n    for pid, times in by_patient.items():\n        if len(times)  2:\n            continue\n        times_sorted = sorted(times)\n        # Check for any pair within the window with strict positive difference.\n        # Since data is small, use nested loops; for larger data, a two-pointer approach would be efficient.\n        n = len(times_sorted)\n        found = False\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                diff = times_sorted[j] - times_sorted[i]\n                if diff = 0:\n                    continue  # enforce strict positivity\n                if diff = window_hours:\n                    qualifying.add(pid)\n                    found = True\n                    break\n            if found:\n                break\n\n    return sorted(list(qualifying))\n\ndef solve():\n    troponin_codes = {\"LOINC:89579-7\", \"LOINC:67151-1\"}\n\n    # Define test cases from the problem statement.\n    case_A = [\n        {\"patient_id\": 1, \"code\": \"LOINC:89579-7\", \"time_hours\": 1.0, \"value\": 0.05, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 1, \"code\": \"LOINC:89579-7\", \"time_hours\": 20.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 2, \"code\": \"LOINC:89579-7\", \"time_hours\": 5.0, \"value\": 0.03, \"unit\": \"ng/mL\", \"abnormal\": False},\n        {\"patient_id\": 2, \"code\": \"LOINC:89579-7\", \"time_hours\": 15.0, \"value\": 0.05, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 3, \"code\": \"LOINC:67151-1\", \"time_hours\": 0.0, \"value\": 0.07, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 3, \"code\": \"LOINC:67151-1\", \"time_hours\": 12.0, \"value\": 0.08, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 3, \"code\": \"LOINC:67151-1\", \"time_hours\": 36.0, \"value\": 0.09, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 4, \"code\": \"LOINC:89579-7\", \"time_hours\": 0.0, \"value\": 0.10, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 4, \"code\": \"LOINC:89579-7\", \"time_hours\": 50.0, \"value\": 0.09, \"unit\": \"ng/mL\", \"abnormal\": True},\n    ]\n\n    case_B = [\n        {\"patient_id\": 5, \"code\": \"LOINC:89579-7\", \"time_hours\": 0.0, \"value\": 0.05, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 5, \"code\": \"LOINC:89579-7\", \"time_hours\": 24.0, \"value\": 0.05, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 6, \"code\": \"LOINC:67151-1\", \"time_hours\": 0.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 6, \"code\": \"LOINC:67151-1\", \"time_hours\": 24.1, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 7, \"code\": \"LOINC:67151-1\", \"time_hours\": 0.0, \"value\": 0.07, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 7, \"code\": \"LOINC:67151-1\", \"time_hours\": 0.0, \"value\": 0.08, \"unit\": \"ng/mL\", \"abnormal\": True},\n    ]\n\n    case_C = [\n        {\"patient_id\": 8, \"code\": \"LOINC:89579-7\", \"time_hours\": 10.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 8, \"code\": \"LOINC:89579-7\", \"time_hours\": 12.0, \"value\": 0.07, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 8, \"code\": \"LOINC:89579-7\", \"time_hours\": 13.0, \"value\": 0.08, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 9, \"code\": \"LOINC:89579-7\", \"time_hours\": 0.0, \"value\": 0.05, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 9, \"code\": \"LOINC:89579-7\", \"time_hours\": 10.0, \"value\": 0.03, \"unit\": \"ng/mL\", \"abnormal\": False},\n        {\"patient_id\": 9, \"code\": \"LOINC:89579-7\", \"time_hours\": 30.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 10, \"code\": \"NON-TROPONIN\", \"time_hours\": 5.0, \"value\": 2.0, \"unit\": \"ng/mL\", \"abnormal\": True},\n    ]\n\n    case_D = [\n        {\"patient_id\": 11, \"code\": \"LOINC:89579-7\", \"time_hours\": 1.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 11, \"code\": \"LOINC:67151-1\", \"time_hours\": 20.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 12, \"code\": \"LOINC:89579-7\", \"time_hours\": 1.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 12, \"code\": \"LOINC:67151-1\", \"time_hours\": 30.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 13, \"code\": \"LOINC:67151-1\", \"time_hours\": 5.0, \"value\": 0.03, \"unit\": \"ng/mL\", \"abnormal\": False},\n        {\"patient_id\": 13, \"code\": \"LOINC:67151-1\", \"time_hours\": 20.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n    ]\n\n    test_cases = [case_A, case_B, case_C, case_D]\n\n    results = []\n    for obs_list in test_cases:\n        results.append(qualifying_patients(obs_list, troponin_codes, window_hours=24.0))\n\n    # Final print statement in the exact required format: a single line.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4849805"}]}