{"hands_on_practices": [{"introduction": "在将任何新技术（如区块链）集成到医疗保健系统中之前，评估其经济可行性是至关重要的一步。本练习提供了一个基本框架，用于估算许可链（一种在医疗机构联盟中常见的区块链类型）上每笔交易的平均运营成本。通过这个计算，您可以学习如何将基础架构成本分摊到单个操作中，从而更好地理解部署区块链解决方案的财务影响。[@problem_id:4824545]", "problem": "一个医院联合体运营着一个许可链，用于记录跨多个机构的电子健康记录（EHR; Electronic Health Record）访问事件和患者同意书更新。运营商支付固定的每日服务器托管成本 $C_s$ 和固定的每日带宽成本 $C_b$，以维持网络的排序和对等节点以及跨站点数据交换。在足够长的时间范围内，该系统平均每天处理 $N$ 笔链上交易，其中每笔交易对应一个单一的可审计事件（例如，一次同意书更新或一条访问日志条目）。假设系统处于稳态运行，在所考虑的范围内，每日运营成本相对于交易量是固定的，并且与固定的每日成本相比，每笔交易的边际资源消耗可以忽略不计。\n\n从每单位平均（期望）成本定义为每日总运营成本除以每日平均交易量出发，推导用 $C_s$、$C_b$ 和 $N$ 表示的每笔交易单位运营成本 $C$ 的符号表达式。然后，对于 $C_s = 864 \\text{ USD/day}$、$C_b = 136 \\text{ USD/day}$ 和 $N = 150{,}000 \\text{ transactions/day}$ 的特定情况，计算 $C$ 的数值。\n\n将您的最终答案以美元（United States Dollar, USD）/笔交易表示，并四舍五入到四位有效数字。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n-   固定的每日服务器托管成本：$C_s$\n-   固定的每日带宽成本：$C_b$\n-   每日平均链上交易量：$N$\n-   每笔交易的单位运营成本：$C$\n-   单位成本的定义：每日总运营成本除以每日平均交易量。\n-   服务器成本的具体值：$C_s = 864 \\text{ USD/day}$\n-   带宽成本的具体值：$C_b = 136 \\text{ USD/day}$\n-   交易量的具体值：$N = 150{,}000 \\text{ transactions/day}$\n-   任务1：推导用 $C_s$、$C_b$ 和 $N$ 表示的 $C$ 的符号表达式。\n-   任务2：计算给定特定情况下 $C$ 的数值。\n-   任务3：将最终数值答案四舍五入到四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n根据既定标准对问题进行评估。\n-   **科学性**：该问题是成本分析的直接应用，这是经济学和工程管理中的一个基本概念。它使用一个简化但标准的成本模型来模拟一个合理的技术系统（用于医疗保健的许可链）的运营成本。它没有伪科学和事实错误。\n-   **良构性**：这个问题是良构的。它清楚地定义了所有变量，并为推导目标量 $C$ 提供了直接的指令。所提供的数据足以找到唯一解，且数据是一致的。\n-   **客观性**：语言清晰、精确，没有主观或含糊的术语。\n-   **完整性与一致性**：问题是自洽的，提供了所有必要的数据和定义。没有矛盾之处。明确说明了边际成本可忽略不计的假设，这使得模型更加稳固。\n-   **现实性**：对于一个联盟级的IT基础设施来说，所提供的每日成本和交易量的数值是合理的。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**，因为其具有科学性、良构性和客观性。将提供解答。\n\n任务的第一部分是推导每笔交易的单位运营成本 $C$ 的符号表达式。问题将其定义为每日总运营成本除以每日平均交易量。\n\n设每日总运营成本为 $C_{total}$。该成本是固定的每日服务器托管成本 $C_s$ 和固定的每日带宽成本 $C_b$ 的总和。\n$$C_{total} = C_s + C_b$$\n每日平均交易量由 $N$ 给出。\n\n根据问题陈述中提供的定义，每笔交易的单位运营成本 $C$ 由每日总运营成本与每日平均交易量之比给出。\n$$C = \\frac{C_{total}}{N}$$\n将 $C_{total}$ 的表达式代入此方程，得到 $C$ 的符号表达式：\n$$C = \\frac{C_s + C_b}{N}$$\n这就完成了任务的第一部分。\n\n任务的第二部分是计算给定特定情况下 $C$ 的数值。给定的值为：\n-   $C_s = 864 \\text{ USD/day}$\n-   $C_b = 136 \\text{ USD/day}$\n-   $N = 150{,}000 \\text{ transactions/day}$\n\n首先，我们计算每日总运营成本 $C_{total}$：\n$$C_{total} = 864 + 136 = 1000 \\text{ USD/day}$$\n接下来，我们将此总成本和交易量代入 $C$ 的公式中：\n$$C = \\frac{1000 \\text{ USD/day}}{150{,}000 \\text{ transactions/day}}$$\n这可以简化为：\n$$C = \\frac{1000}{150000} = \\frac{10}{1500} = \\frac{1}{150} \\text{ USD/transaction}$$\n为了将其表示为小数，我们进行除法运算：\n$$C = \\frac{1}{150} \\approx 0.0066666... \\text{ USD/transaction}$$\n问题要求答案四舍五入到四位有效数字。第一个有效数字是第一个非零数字，即千分位上的 $6$。从那里数四位得到 $0.006666$。第五个有效数字是 $6$，它大于或等于 $5$，所以我们将第四个有效数字向上取整。\n$$C \\approx 0.006667 \\text{ USD/transaction}$$\n这就是最终的数值答案。", "answer": "$$\\boxed{0.006667}$$", "id": "4824545"}, {"introduction": "除了成本，系统的性能对于其在临床环境中的可用性也至关重要；一个对于关键操作来说过于缓慢的系统是不可行的。本练习探讨了区块链的关键技术参数（如区块大小和出块时间）与其性能指标（吞吐量和延迟）之间的权衡关系。通过分析一个假设的场景，您将学习如何评估一个区块链配置是否满足医院环境中例如医嘱录入等对时间要求严格的工作流程。[@problem_id:4824488]", "problem": "一家区域性医院联盟正在试行一个许可链，以不可篡改地记录跨多家医疗机构的临床事件，包括医生医嘱录入和实验室结果报告。该网络在局域网上的 $n$ 个验证者节点之间使用实用拜占庭容错（PBFT）协议。交易以固定的区块间隔 $\\Delta$ 被分批打包成大小为 $b$ 的区块，每个区块在经过一个持续时间为 $t_c$（对于给定配置，该时间近似恒定）的共识阶段后达到最终性。在高峰时段，所有机构的总交易到达过程可以合理地建模为速率为 $\\lambda$ 的泊松过程，其中医嘱录入事件的到达率为 $\\lambda_o$，实验室结果事件的到达率为 $\\lambda_r$，因此 $\\lambda = \\lambda_o + \\lambda_r$。对于最繁忙的时间窗口，经验测量得出 $\\lambda_o = 12$ 笔交易/秒，$\\lambda_r = 1$ 笔交易/秒。临床工作流程的及时性约束是：(i) 对于电子健康记录（EHR）中的交互式医嘱录入，一笔已提交的交易应在最多 $2$ 秒内得到反映，以避免用户界面中断和重复下单；(ii) 对于常规实验室结果报告，区块链的提交过程不应在分析仪可用时间之外增加超过 $10$ 秒的延迟，以避免对实验室的周转时间产生实质性影响。\n\n仅使用吞吐量和延迟的基本定义，以及泊松到达下单服务器系统的标准、经过充分检验的排队近似，为该许可链定义相关的吞吐量和延迟指标，并确定以下哪些候选配置在高峰时段满足两个及时性约束。假设系统处于稳态运行且稳定。每个配置指定了 $(b, \\Delta, t_c)$:\n\nA. $b = 100$, $\\Delta = 2$ 秒, $t_c = 0.5$ 秒。\n\nB. $b = 50$, $\\Delta = 1$ 秒, $t_c = 1.2$ 秒。\n\nC. $b = 200$, $\\Delta = 5$ 秒, $t_c = 0.7$ 秒。\n\nD. $b = 80$, $\\Delta = 4$ 秒, $t_c = 0.4$ 秒。\n\n选择所有适用项。", "solution": "## 问题验证\n\n### 第1步：提取已知信息\n\n问题提供了以下数据和定义：\n- **系统**：一个使用实用拜占庭容错（PBFT）的许可链。\n- **验证者节点数量**：$n$。\n- **区块大小**：$b$ 笔交易。\n- **区块间隔**：$\\Delta$ 秒。\n- **共识持续时间**：$t_c$ 秒，近似恒定。\n- **交易到达过程**：泊松过程。\n- **总到达率**：$\\lambda = \\lambda_o + \\lambda_r$。\n- **医嘱录入到达率**：$\\lambda_o = 12$ 笔交易/秒。\n- **实验室结果到达率**：$\\lambda_r = 1$ 笔交易/秒。\n- **约束 (i)**：医嘱录入交易的提交时间必须最多为 $2$ 秒。\n- **约束 (ii)**：实验室结果报告的提交过程增加的延迟最多为 $10$ 秒。\n- **方法论**：使用吞吐量和延迟的基本定义，以及泊松到达下单服务器系统的标准、经过充分检验的排队近似。\n- **假设**：稳态运行且稳定。\n- **候选配置 $(b, \\Delta, t_c)$**：\n    - A: $(100, 2 \\text{ 秒}, 0.5 \\text{ 秒})$\n    - B: $(50, 1 \\text{ 秒}, 1.2 \\text{ 秒})$\n    - C: $(200, 5 \\text{ 秒}, 0.7 \\text{ 秒})$\n    - D: $(80, 4 \\text{ 秒}, 0.4 \\text{ 秒})$\n\n### 第2步：使用提取的已知信息进行验证\n\n- **科学依据**：该问题基于计算机系统性能分析这一成熟领域，特别是应用于区块链技术。使用泊松到达、批量处理和排队近似是为此类系统建模的标准方法。对于局域网上的许可链，这些参数和约束在技术上是合理的。\n- **适定性**：该问题是适定的。它为评估每种配置提供了所有必要的数值（$\\lambda_o, \\lambda_r, b, \\Delta, t_c$）和明确的约束。要求使用“标准、经过充分检验的排队近似”为求解提供了一条清晰但略带解释性的路径。这种批处理系统最基本和标准的近似方法是可以确定的。每个选项都可以得到唯一的评估。\n- **客观性**：问题以精确、客观、技术性的语言陈述，没有主观论断。\n\n问题陈述没有违反任何无效标准。它是科学合理的、适定的和客观的。\n\n### 第3步：结论与行动\n\n问题是 **有效的**。现在将进行求解过程。\n\n## 推导与分析\n\n该问题要求根据吞吐量和延迟约束评估候选的区块链配置。\n\n### 1. 定义指标和模型\n\n首先，我们计算总交易到达率 $\\lambda$。\n$$ \\lambda = \\lambda_o + \\lambda_r = 12 \\text{ s}^{-1} + 1 \\text{ s}^{-1} = 13 \\text{ s}^{-1} $$\n\n**吞吐量**：系统的最大可持续处理速率（吞吐量），用 $\\mu$ 表示，由区块大小 $b$ 和区块间隔 $\\Delta$ 决定。系统每 $\\Delta$ 秒可以处理 $b$ 笔交易。\n$$ \\mu = \\frac{b}{\\Delta} \\quad [\\text{笔交易/秒}] $$\n\n**稳定性**：为使系统处于稳定的稳态，到达率必须小于处理速率。如果 $\\lambda \\ge \\mu$，未处理交易的队列将无限增长，延迟将变为无穷大。\n$$ \\lambda  \\mu \\quad \\implies \\quad 13  \\frac{b}{\\Delta} $$\n这个条件必须对每种配置进行验证。\n\n**延迟**：问题指导我们使用基本定义和标准的排队近似。对于一个在随机时间到达一个以固定批次处理的系统的交易，其总延迟（$L$）可以近似为两个组成部分的总和：\n1.  **批处理等待时间 ($W_{batch}$)**：交易在 $\\Delta$ 的时间间隔内被收集到一个区块中。在此间隔内随机时间点到达的交易必须等待当前间隔结束并且区块被创建。对于一个持续时间为 $\\Delta$ 的确定性间隔，根据更新理论（平均剩余寿命），平均等待时间是该间隔的一半。\n    $$ W_{batch} = \\frac{\\Delta}{2} $$\n2.  **共识时间 ($t_c$)**：一旦区块被创建，它会经历一个持续时间为 $t_c$ 的共识阶段以达到最终性。\n\n这个模型假设交易被包含在下一个可用的区块中，对于一个稳定的系统（$\\lambda  \\mu$），这是一个有效的近似。总平均延迟为：\n$$ L = W_{batch} + t_c = \\frac{\\Delta}{2} + t_c $$\n\n### 2. 及时性约束\n\n系统必须满足两个约束：\n- (i) 医嘱录入：$L \\le 2$ 秒。\n- (ii) 实验室结果：$L \\le 10$ 秒。\n\n由于在区块链批处理过程中所有交易都被同等对待，计算出的延迟 $L$ 适用于两种类型的事件。因此，系统必须满足两个约束中更严格的一个，即医嘱录入的约束：\n$$ L \\le 2 \\text{ s} $$\n如果满足此约束，则实验室结果的约束（$L \\le 10 \\text{ s}$）将自动满足。\n\n### 3. 逐项分析\n\n我们现在评估每种配置。到达率是恒定的 $\\lambda = 13 \\text{ s}^{-1}$。\n\n**A. 配置: $b = 100$, $\\Delta = 2$ 秒, $t_c = 0.5$ 秒**\n- **稳定性检查**:\n  吞吐量 $\\mu = \\frac{100}{2} = 50 \\text{ s}^{-1}$。\n  由于 $\\lambda = 13 \\text{ s}^{-1}  50 \\text{ s}^{-1}$，系统是稳定的。\n- **延迟计算**:\n  $L = \\frac{\\Delta}{2} + t_c = \\frac{2}{2} + 0.5 = 1.0 + 0.5 = 1.5 \\text{ s}$。\n- **约束验证**:\n  $1.5 \\text{ s} \\le 2 \\text{ s}$。约束已满足。\n- **结论**: **正确**。\n\n**B. 配置: $b = 50$, $\\Delta = 1$ 秒, $t_c = 1.2$ 秒**\n- **稳定性检查**:\n  吞吐量 $\\mu = \\frac{50}{1} = 50 \\text{ s}^{-1}$。\n  由于 $\\lambda = 13 \\text{ s}^{-1}  50 \\text{ s}^{-1}$，系统是稳定的。\n- **延迟计算**:\n  $L = \\frac{\\Delta}{2} + t_c = \\frac{1}{2} + 1.2 = 0.5 + 1.2 = 1.7 \\text{ s}$。\n- **约束验证**:\n  $1.7 \\text{ s} \\le 2 \\text{ s}$。约束已满足。\n- **结论**: **正确**。\n\n**C. 配置: $b = 200$, $\\Delta = 5$ 秒, $t_c = 0.7$ 秒**\n- **稳定性检查**:\n  吞吐量 $\\mu = \\frac{200}{5} = 40 \\text{ s}^{-1}$。\n  由于 $\\lambda = 13 \\text{ s}^{-1}  40 \\text{ s}^{-1}$，系统是稳定的。\n- **延迟计算**:\n  $L = \\frac{\\Delta}{2} + t_c = \\frac{5}{2} + 0.7 = 2.5 + 0.7 = 3.2 \\text{ s}$。\n- **约束验证**:\n  $3.2 \\text{ s} > 2 \\text{ s}$。医嘱录入的及时性约束被违反。\n- **结论**: **不正确**。\n\n**D. 配置: $b = 80$, $\\Delta = 4$ 秒, $t_c = 0.4$ 秒**\n- **稳定性检查**:\n  吞吐量 $\\mu = \\frac{80}{4} = 20 \\text{ s}^{-1}$。\n  由于 $\\lambda = 13 \\text{ s}^{-1}  20 \\text{ s}^{-1}$，系统是稳定的。\n- **延迟计算**:\n  $L = \\frac{\\Delta}{2} + t_c = \\frac{4}{2} + 0.4 = 2.0 + 0.4 = 2.4 \\text{ s}$。\n- **约束验证**:\n  $2.4 \\text{ s} > 2 \\text{ s}$。医嘱录入的及时性约束被违反。\n- **结论**: **不正确**。", "answer": "$$\\boxed{AB}$$", "id": "4824488"}, {"introduction": "区块链的核心承诺是通过加密哈希来保证数据的完整性和不可篡改性。然而，要使这个承诺在技术上可靠，我们必须确保语义上相同的数据总是产生相同的哈希值。本练习深入探讨了一个在现实世界中至关重要的工程挑战：如何处理像 FHIR 这样复杂的数据结构，以确保其序列化表示是确定性的，从而防止因格式上的微小差异而导致哈希值改变，保证审计追踪的可靠性。[@problem_id:4824515]", "problem": "一个医院联盟正在为一个基于区块链的审计追踪系统部署快速医疗互操作性资源 (FHIR) 包，该包以 JavaScript 对象表示法 (JSON) 表示。他们通过对序列化后的包进行加密哈希，将每个包锚定到账本上。在一次常规的微服务升级后，他们观察到即使临床内容完全相同，未更改的包的哈希值有时也会不同。该联盟希望有一种策略，能够保证语义上等效的 FHIR 包能序列化为唯一的、确定性的字节序列，从而使哈希值保持稳定。\n\n基本事实和定义：\n- 一个加密哈希函数 $H:\\{0,1\\}^*\\rightarrow\\{0,1\\}^n$（例如，安全哈希算法 256 位 (SHA-256)）是确定性的，并且对每个输入位都敏感：如果两个输入 $x$ 和 $y$ 有任何一位不同，则 $H(x)\\neq H(y)$ 的概率是压倒性的。哈希相等要求输入逐字节相等。\n- JavaScript 对象表示法 (JSON) 是一种文本数据格式。JSON 对象是名称/值对的无序集合；不同的实现可能对相同的抽象值输出不同的键顺序、空白符或数字文本形式。数组是有序序列；更改数组元素的顺序会改变抽象值。\n- 快速医疗互操作性资源 (FHIR) 由第七层健康信息标准国际组织 (HL7) 标准化，定义了诸如包条目、标识符、时间戳和元数据等元素的语义。\n\n基于这些基础，分析当相同的临床内容被重新序列化时哈希值不稳定的根本原因，并选择一个能对 FHIR 包 $B$ 产生确定性序列化 $S(B)$ 的最佳策略，使得对于 $B$ 的任何语义上等效的 JSON 编码 $e$ 和 $e'$，$S(e)=S(e')$，这意味着 $H(S(e))=H(S(e'))$。\n\n哪个选项最完整、最正确地指定了一种确定性序列化策略，该策略能在保留 FHIR 语义的同时防止虚假的哈希值变化？\n\nA. 定义一个作用于已解析的 FHIR 包的规范化序列化函数 $S$，该函数：\n   - 以 UTF-8 编码和 Unicode 范式C (NFC) 输出文本。\n   - 在输出前按 Unicode 码点顺序对所有 JSON 对象成员的键进行排序；输出键和值时不带无意义的空白符（使用单一的规范分隔符）。\n   - 完全按照抽象模型中的顺序保留数组元素的顺序（不重新排序）。\n   - 以小写规范形式输出布尔值和 null，以最小十进制形式输出数字，不带前导加号、不必要的先导零或小数点后的尾随零；整数不带小数点输出。\n   - 使用单一的 ISO $8601$ 文本模式并将时间戳规范化为协调世界时 (UTC)，并带有明确的“Z”指示符，以保留瞬时值；不改变具有临床意义的内容，并且只包含语义上定义的元素（不包含特定于实现的格式化产物）。\n   - 将此输出过程确定性地应用于已解析的数据模型，而不是现有的文本字符串。\n\nB. 配置序列化器以一致的缩进和换行符进行格式化打印，但将键的迭代留给运行时的原生字典顺序，并允许使用平台本地时区渲染时间戳；按原样包含所有元数据字段（例如，资源标识符和服务器分配的版本字段）。\n\nC. 通过对包的 gzip 压缩的 JSON 流进行哈希来提高性能；依赖压缩器的默认设置和头部信息，并且不改变键的顺序或时间戳格式，因为压缩应该会平均掉文本上的差异。\n\nD. 通过去除所有空白符和换行符来最小化 JSON，同时保留对象键和数字的原始输出顺序；将数组视为集合，并按资源类型对包条目进行排序，以确保标准化的外观。\n\n选择一个。", "solution": "问题要求确定一种策略，以确保语义上等效的、以 JavaScript 对象表示法 (JSON) 表示的快速医疗互操作性资源 (FHIR) 包，总能序列化为相同的字节序列。这对于在区块链上为审计追踪生成稳定的加密哈希是必要的。问题的核心在于数据的抽象语义表示与其具体的文本序列化之间的差异。加密哈希函数 $H$ 作用于特定的字节序列。因此，对于由可能不同的 JSON 编码 $e_1$ 和 $e_2$ 分别表示的两个语义上等效的包 $B_1$ 和 $B_2$，我们需要一个规范化序列化函数 $S$，使得 $S(e_1) = S(e_2)$，这反过来又保证了 $H(S(e_1)) = H(S(e_2))$。\n\n正如问题陈述中指出的，JSON 序列化中不确定性的来源是：\n1.  **无序的对象键**：JSON 规范 (RFC 8259) 指出“对象是名称/值对的无序集合”。不同的序列化器可以按不同的顺序输出键（例如，`{\"a\": 1, \"b\": 2}` 与 `{\"b\": 2, \"a\": 1}`）。\n2.  **无意义的空白符**：标记之间的空白字符（空格、制表符、换行符）在语义上是无关紧要的，可以添加、删除或更改，而不会改变抽象数据。\n3.  **可变的数字表示**：像 $100$ 这样的数字可以用文本表示为 $100$、$100.0$ 或 $1 \\times 10^2$（例如 `1E2`）。\n4.  **可变的字符串表示**：由于字符编码（例如 UTF-8 与 UTF-16）和 Unicode 范式（例如，预组合字符 'é' 与 'e' 加上一个组合重音符）的不同，文本数据可以有不同的字节表示。\n5.  **领域特定的等效性**：在 FHIR 内部，一个特定的时间瞬间可以使用 ISO $8601$ 标准以多种方式表示（例如，`2023-01-01T12:00:00Z` 在语义上等同于 `2023-01-01T07:00:00-05:00`）。\n\n一个有效的策略必须解决所有这些可变性来源，以产生一个唯一的、规范的字节流。该策略必须作用于已解析的抽象数据模型，以正确处理语义等效性，而不仅仅是作用于预先存在的序列化的原始文本。\n\n### 逐项分析\n\n**A. 定义一个作用于已解析的 FHIR 包的规范化序列化函数 S，该函数...**\n这个选项提出了一个详细的、多步骤的规范化算法。让我们分析其组成部分：\n- **作用于已解析的 FHIR 包**：这是正确的方法。它确保序列化是基于抽象的语义结构，而不是基于一个可能非规范化的输入字符串。\n- **使用 NFC 的 UTF-8**：指定单一的字符编码 (UTF-8) 和单一的 Unicode 范式（范式C）。这解决了字符串表示中的歧义。\n- **按 Unicode 码点顺序对所有 JSON 对象成员的键进行排序**：这是为无序的对象键施加确定性顺序的标准且正确的方法。\n- **输出时不带无意义的空白符**：这消除了格式化和缩进带来的可变性。\n- **保留数组元素顺序**：这一点至关重要。JSON 数组是有序列表，它们的顺序在 FHIR 中具有语义上的重要性（例如，事务包中条目的顺序）。改变这个顺序会改变数据的含义。这条规则正确地保留了语义。\n- **布尔值、null 和数字的规范形式**：这为基本数据类型提供了严格、无歧义的文本表示，消除了另一个可变性来源。\n- **将时间戳规范化为 UTC，并采用特定的 ISO 8601 格式**：这解决了 FHIR 中时间表示的领域特定问题。通过将所有时间戳转换为单一时区 (UTC) 和格式，确保了语义上等效的时间瞬间具有相同的字符串表示。\n- **仅包含语义上定义的元素**：这可以防止特定于实现的或瞬态的元数据影响核心临床内容的哈希值。\n\n这个选项系统地解决了 JSON 序列化中所有已知的不确定性来源，其方式与保留 FHIR 数据模型的语义相一致。所描述的过程是一个稳健且完整的规范化方案，类似于已建立的标准，如 JSON 规范化方案 (JCS, RFC 8785)。\n**结论：正确**\n\n**B. 配置序列化器以一致的缩进和换行符进行格式化打印，但将键的迭代留给运行时的原生字典顺序，并允许使用平台本地时区渲染时间戳；按原样包含所有元数据字段（例如，资源标识符和服务器分配的版本字段）。**\n这个选项包含几个关键缺陷：\n- **“将键的迭代留给运行时的原生字典顺序”**：这是一个主要的失败点。在不同的编程语言实现、版本，甚至同一程序的连续运行中，字典/哈希映射中键的顺序通常不保证稳定。这未能解决键排序问题。\n- **“允许使用平台本地时区渲染时间戳”**：这是另一个重大失败。同一个 UTC 瞬间在不同的本地时区（例如 `America/New_York` vs. `Europe/London`）渲染会产生不同的文本字符串，导致语义相同的数据产生不同的哈希值。\n- **“以一致的缩进进行格式化打印”**：这还不够。虽然它使空白符的某个方面保持一致，但它没有创建一个单一的规范形式，也未能解决更重要的键顺序和数据表示问题。\n**结论：错误**\n\n**C. 通过对包的 gzip 压缩的 JSON 流进行哈希来提高性能；依赖压缩器的默认设置和头部信息，并且不改变键的顺序或时间戳格式，因为压缩应该会平均掉文本上的差异。**\n这个选项基于对加密哈希和数据压缩的根本误解。\n- **“压缩应该会平均掉文本上的差异”**：这是错误的。像 `gzip` 这样的数据压缩算法是确定性的，但它们不会对其输入进行规范化。如果两个输入字节流 $x$ 和 $y$ 不同 ($x \\neq y$)，它们的压缩输出 `gzip(x)` 和 `gzip(y)` 也将不同（除非发生极不可能的压缩碰撞）。压缩不会将不同的输入合并成单一的输出。\n- 该策略明确指出**“不改变键的顺序或时间戳格式”**，这意味着它未能解决非确定性序列化的根本原因。\n- 此外，依赖 `gzip` 的默认设置可能会引入新的不确定性来源，因为头部信息（例如，包含时间戳或文件名）和压缩级别在不同实现之间可能会有所不同。\n**结论：错误**\n\n**D. 通过去除所有空白符和换行符来最小化 JSON，同时保留对象键和数字的原始输出顺序；将数组视为集合，并按资源类型对包条目进行排序，以确保标准化的外观。**\n这个选项有两个致命缺陷：\n- **“保留对象键的原始输出顺序”**：与选项 B 一样，这未能解决键排序问题，而这是不确定性的主要来源之一。\n- **“将数组视为集合，并按资源类型对包条目进行排序”**：这是一个破坏性操作，会损坏数据。FHIR 包是集合，其中 `entry` 数组中条目的顺序具有语义上的重要性（例如，定义事务中的执行顺序）。将有序数组视为无序集合并对其元素重新排序违反了 FHIR 标准并改变了数据的含义。目标是找到一个等效的表示，而不是改变信息内容。\n**结论：错误**\n\n基于此分析，选项 A 是唯一一个为实现 FHIR 包的确定性序列化提供了完整、正确且符合标准的策略的选项。", "answer": "$$\\boxed{A}$$", "id": "4824515"}]}