{"hands_on_practices": [{"introduction": "患者数据常常分散在不同的医院和诊所中。在进行任何有意义的分析之前，我们必须首先解决一个难题：如何将这些零散的记录链接起来，以构建患者历程的统一视图。本实践练习 [@problem_id:4853983] 将指导你设计一个保护隐私的记录链接流程，通过使用哈希和分块等技术，应对计算复杂性和数据安全等现实挑战。", "problem": "您被要求设计并实现一个完整的、保护隐私的实体解析管道，用于使用哈希化的人口统计信息和就诊模式来链接两个机构间的患者记录。该管道必须包含一个有原则的分块策略，通过减少所考虑的候选记录对的数量来控制计算复杂性。该问题必须通过代码解决，为提供的测试套件生成指定的输出。\n\n推导的基本依据是：\n\n- 哈希函数的定义，即从字符串到固定长度位字符串的确定性映射。具体来说，使用安全哈希算法 $256$ (SHA-$256$)，这是一种广泛使用的加密哈希函数，它将输入字符串映射到一个 $256$ 位的摘要。\n- 集合的 Jaccard 相似度定义，对于两个集合 $A$ 和 $B$，其定义为 $J(A,B) = \\frac{|A \\cap B|}{|A \\cup B|}$。\n- 在两个拥有 $|\\mathcal{A}|$ 和 $|\\mathcal{B}|$ 条记录的机构之间进行朴素记录链接的组合复杂性，这需要 $|\\mathcal{A}| \\cdot |\\mathcal{B}|$ 次两两比较，以及使用分块来减少候选对集合。\n\n您必须实现以下精确的管道：\n\n1. 人口统计信息的哈希化：\n   - 对于每条患者记录 $r$，您拥有原始字符串 $\\text{dob}(r)$（ISO格式的出生日期）、$\\text{zip3}(r)$（邮政编码的前三位数字）和 $\\text{sex}(r)$（单字符代码，如 \"F\" 或 \"M\"）。\n   - 将 $H(x)$ 定义为对字符串 $x$ 应用 SHA-$256$ 的结果，通过其十六进制摘要表示为一个 $256$ 位的无符号整数。\n   - 为了进行分块，将分块键 $\\beta(r,b)$ 定义为由 $H(\\text{zip3}(r))$ 的前 $b$ 个最高有效位形成的整数，其中 $b$ 是一个非负整数（分块位长）。形式上，如果 $h(r) = H(\\text{zip3}(r))$ 是一个 $256$ 位整数，则 $$\\beta(r,b) = \\begin{cases} 0, & \\text{if } b = 0 \\\\ \\left\\lfloor \\dfrac{h(r)}{2^{256-b}} \\right\\rfloor, & \\text{if } b \\ge 1 \\end{cases}$$\n\n2. 分块与计算复杂性：\n   - 对于给定的 $b$，仅从两个机构中共享相同分块键 $\\beta$ 的记录中形成候选对。\n   - 设 $C(b)$ 为在 $b$ 下的候选对数量，定义为 $$C(b) = \\sum_{k \\in \\mathcal{K}(b)} |\\mathcal{A}_k(b)| \\cdot |\\mathcal{B}_k(b)|,$$ 其中 $\\mathcal{K}(b)$ 是在 $b$ 下两个机构都存在的分块键集合，而 $\\mathcal{A}_k(b)$ 和 $\\mathcal{B}_k(b)$ 分别是机构 $\\mathcal{A}$ 和 $\\mathcal{B}$ 在分块 $k$ 中的记录子集。\n   - 定义复杂性比率 $$\\rho(b) = \\dfrac{C(b)}{|\\mathcal{A}| \\cdot |\\mathcal{B}|},$$ 约定如果 $|\\mathcal{A}| \\cdot |\\mathcal{B}| = 0$，则 $\\rho(b) = 0$。\n\n3. 就诊模式相似度与链接决策：\n   - 对于每条记录 $r$，给定一个就诊天数列表（非负整数）$E(r)$，其中每个元素是相对于一个固定纪元的日期索引。通过以下方式将此列表映射到周分箱：$$W(r) = \\left\\{ \\left\\lfloor \\dfrac{d}{7} \\right\\rfloor : d \\in E(r) \\right\\}.$$\n   - 对于一个候选对 $(i,j)$，计算 $W(i)$ 和 $W(j)$ 的 Jaccard 相似度，记为 $$J\\big(W(i), W(j)\\big) = \\dfrac{|W(i) \\cap W(j)|}{|W(i) \\cup W(j)|}.$$\n   - 当且仅当两个条件都成立时，一对 $(i,j)$ 才被链接：$H(\\text{sex}(i)) = H(\\text{sex}(j))$ 且 $J\\big(W(i), W(j)\\big) \\ge t$，其中 $t$ 是一个以十进制形式给出的给定阈值。\n\n4. 分块策略推导：\n   - 对于给定的目标比率 $R$ 和搜索范围 $b \\in \\{b_{\\min}, b_{\\min}+1, \\dots, b_{\\max}\\}$，选择满足 $\\rho(b) \\le R$ 的最小 $b$。如果在此范围内不存在这样的 $b$，则选择 $b = b_{\\max}$。\n\n5. 要求输出：\n   - 对于每个测试用例，您的程序必须输出一个列表 $[b^\\star, C(b^\\star), \\text{round}(\\rho(b^\\star),4), L]$，其中 $b^\\star$ 是所选的分块位长，$C(b^\\star)$ 是对应的候选对计数，$\\rho(b^\\star)$ 是对应的复杂性比率，四舍五入到 $4$ 位小数（作为十进制数，而非百分比），$L$ 是根据上述链接决策规则链接的对数。\n   - 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个测试用例的结果本身也格式化为带括号的列表。例如：$[ [b_1,C_1,\\rho_1,L_1], [b_2,C_2,\\rho_2,L_2] ]$。不得有任何额外文本。\n\n测试套件和参数：\n\n- 测试用例 $1$（具有重叠块和多个候选者的一般情况）：\n  - 机构 $\\mathcal{A}$ 记录：\n    - $\\text{id} = \\text{\"A1\"}$，$\\text{dob} = \\text{\"1990-01-01\"}$，$\\text{zip3} = \\text{\"123\"}$，$\\text{sex} = \\text{\"F\"}$，$E = [\\, $10$, $20$, $31$ \\,]$。\n    - $\\text{id} = \\text{\"A2\"}$，$\\text{dob} = \\text{\"1981-05-10\"}$，$\\text{zip3} = \\text{\"123\"}$，$\\text{sex} = \\text{\"M\"}$，$E = [\\, $200$, $210$, $220$ \\,]$。\n    - $\\text{id} = \\text{\"A3\"}$，$\\text{dob} = \\text{\"1975-03-30\"}$，$\\text{zip3} = \\text{\"999\"}$，$\\text{sex} = \\text{\"F\"}$，$E = [\\, $365$ \\,]$。\n  - 机构 $\\mathcal{B}$ 记录：\n    - $\\text{id} = \\text{\"B1\"}$，$\\text{dob} = \\text{\"1990-01-01\"}$，$\\text{zip3} = \\text{\"123\"}$，$\\text{sex} = \\text{\"F\"}$，$E = [\\, $11$, $20$, $28$ \\,]$。\n    - $\\text{id} = \\text{\"B2\"}$，$\\text{dob} = \\text{\"1981-05-10\"}$，$\\text{zip3} = \\text{\"124\"}$，$\\text{sex} = \\text{\"M\"}$，$E = [\\, $210$, $230$ \\,]$。\n    - $\\text{id} = \\text{\"B3\"}$，$\\text{dob} = \\text{\"1975-03-30\"}$，$\\text{zip3} = \\text{\"999\"}$，$\\text{sex} = \\text{\"F\"}$，$E = [\\, $370$ \\,]$。\n  - 阈值 $t = 0.6$，目标比率 $R = 0.4$，搜索范围 $b \\in \\{0,1,\\dots,12\\}$。\n\n- 测试用例 $2$（机构间无重叠块的边界情况）：\n  - 机构 $\\mathcal{A}$ 记录：\n    - $\\text{id} = \\text{\"A4\"}$，$\\text{dob} = \\text{\"1960-07-07\"}$，$\\text{zip3} = \\text{\"555\"}$，$\\text{sex} = \\text{\"F\"}$，$E = [\\, $100$, $110$, $120$ \\,]$。\n    - $\\text{id} = \\text{\"A5\"}$，$\\text{dob} = \\text{\"1961-07-07\"}$，$\\text{zip3} = \\text{\"556\"}$，$\\text{sex} = \\text{\"F\"}$，$E = [\\, $90$, $200$ \\,]$。\n  - 机构 $\\mathcal{B}$ 记录：\n    - $\\text{id} = \\text{\"B4\"}$，$\\text{dob} = \\text{\"1970-08-08\"}$，$\\text{zip3} = \\text{\"777\"}$，$\\text{sex} = \\text{\"M\"}$，$E = [\\, $400$ \\,]$。\n    - $\\text{id} = \\text{\"B5\"}$，$\\text{dob} = \\text{\"1971-08-08\"}$，$\\text{zip3} = \\text{\"778\"}$，$\\text{sex} = \\text{\"F\"}$，$E = [\\, $401$ \\,]$。\n  - 阈值 $t = 0.5$，目标比率 $R = 0.2$，搜索范围 $b \\in \\{0,1,\\dots,12\\}$。\n\n- 测试用例 $3$（强调块内多重性和粗粒度分块目标的边缘情况）：\n  - 机构 $\\mathcal{A}$ 记录：\n    - $\\text{id} = \\text{\"A6\"}$，$\\text{dob} = \\text{\"1988-02-02\"}$，$\\text{zip3} = \\text{\"555\"}$，$\\text{sex} = \\text{\"F\"}$，$E = [\\, $100$, $110$, $120$, $200$ \\,]$。\n    - $\\text{id} = \\text{\"A7\"}$，$\\text{dob} = \\text{\"1992-03-03\"}$，$\\text{zip3} = \\text{\"555\"}$，$\\text{sex} = \\text{\"F\"}$，$E = [\\, $105$, $115$, $125$ \\,]$。\n    - $\\text{id} = \\text{\"A8\"}$，$\\text{dob} = \\text{\"1993-03-03\"}$，$\\text{zip3} = \\text{\"123\"}$，$\\text{sex} = \\text{\"M\"}$，$E = [\\, $300$, $301$ \\,]$。\n  - 机构 $\\mathcal{B}$ 记录：\n    - $\\text{id} = \\text{\"B6\"}$，$\\text{dob} = \\text{\"1988-02-02\"}$，$\\text{zip3} = \\text{\"555\"}$，$\\text{sex} = \\text{\"F\"}$，$E = [\\, $100$, $110$ \\,]$。\n    - $\\text{id} = \\text{\"B7\"}$，$\\text{dob} = \\text{\"1995-04-04\"}$，$\\text{zip3} = \\text{\"555\"}$，$\\text{sex} = \\text{\"F\"}$，$E = [\\, $130$, $140$, $150$ \\,]$。\n    - $\\text{id} = \\text{\"B8\"}$，$\\text{dob} = \\text{\"1993-03-03\"}$，$\\text{zip3} = \\text{\"123\"}$，$\\text{sex} = \\text{\"M\"}$，$E = [\\, $300$, $302$ \\,]$。\n  - 阈值 $t = 0.5$，目标比率 $R = 1.0$，搜索范围 $b \\in \\{0,1,\\dots,12\\}$。\n\n最终输出格式要求：\n\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，其中每个测试用例结果本身都是 $[b^\\star,C(b^\\star),\\rho(b^\\star),L]$ 形式的括号列表。例如：$[[1,3,0.3333,2],[0,0,0.0000,0],[0,9,1.0000,2]]$。", "solution": "该问题要求设计并实现一个保护隐私的实体解析管道，以链接来自两个不同机构 $\\mathcal{A}$ 和 $\\mathcal{B}$ 的患者记录。该解决方案必须基于问题陈述中定义的精确、多步骤的过程来构建。核心原则涉及用于数据保护的加密哈希、用于管理计算复杂性的分块策略，以及基于人口统计信息一致性和就诊模式相似度的、基于规则的链接决策。\n\n已实现的管道系统地遵循以下步骤：\n\n1.  **为保护隐私对准标识符进行哈希处理**：\n    为了保护患者隐私，不直接比较个人可识别信息。相反，我们使用一个单向加密哈希函数 SHA-$256$，记为 $H(x)$。此函数将输入字符串 $x$ 确定性地映射到一个 $256$ 位的整数摘要。此过程确保邮政编码（`zip3`）和性别（`sex`）等原始数据在用于链接之前被转换为不可逆格式。对于任何给定的记录 $r$，我们计算 $H(\\text{zip3}(r))$ 和 $H(\\text{sex}(r))$。\n\n2.  **使用哈希化的地理位置数据进行分块策略**：\n    将机构 $\\mathcal{A}$ 的所有记录与机构 $\\mathcal{B}$ 的所有记录进行朴素比较需要 $|\\mathcal{A}| \\cdot |\\mathcal{B}|$ 次比较，这对于大型数据集在计算上是不可行的。为了缓解这个问题，采用了分块策略。记录根据一个键被划分成块，比较仅限于同一块内的记录对。\n\n    分块键 $\\beta(r,b)$ 是从哈希化的三位数邮政编码 $H(\\text{zip3}(r))$ 派生出来的。具体来说，它被定义为由 $256$ 位哈希值的前 $b$ 个最高有效位所表示的整数。参数 $b$ 是分块位长。其形式化定义是：\n    $$ \\beta(r,b) = \\begin{cases} 0, & \\text{if } b = 0 \\\\ \\left\\lfloor \\dfrac{H(\\text{zip3}(r))}{2^{256-b}} \\right\\rfloor, & \\text{if } b \\ge 1 \\end{cases} $$\n    对于 $b=0$，所有记录都落入一个单独的块中，导致朴素的所有对比较。随着 $b$ 的增加，块的数量增加，每个块的大小减小，从而减少了候选对的数量。\n\n3.  **复杂性分析与最优块大小选择**：\n    分块策略的有效性通过计算工作量的减少来衡量。对于给定的位长 $b$，候选对的数量由 $C(b)$ 给出，它是对两个机构中都存在的所有分块键的块大小乘积之和：\n    $$ C(b) = \\sum_{k \\in \\mathcal{K}(b)} |\\mathcal{A}_k(b)| \\cdot |\\mathcal{B}_k(b)| $$\n    其中 $\\mathcal{K}(b)$ 是机构 $\\mathcal{A}$ 和 $\\mathcal{B}$ 共同拥有的分块键集合，而 $|\\mathcal{A}_k(b)|$ 和 $|\\mathcal{B}_k(b)|$ 分别是每个机构在分块 $k$ 中的记录数。\n\n    复杂性比率 $\\rho(b) = \\dfrac{C(b)}{|\\mathcal{A}| \\cdot |\\mathcal{B}|}$ 对此计数进行归一化，表示被考虑用于链接的总可能对的分数。问题指定了一种选择最优分块位长 $b^\\star$ 的方法。给定一个目标复杂性比率 $R$ 和一个搜索范围 $b \\in \\{b_{\\min}, \\dots, b_{\\max}\\}$，我们必须选择此范围内满足 $\\rho(b) \\le R$ 的最小 $b$。如果找不到这样的 $b$，我们选择 $b^\\star = b_{\\max}$。这种方法寻求满足期望计算约束的最粗粒度的可能分块（最小的 $b$），从而在遵守复杂性预算的同时，最大化找到真实匹配（对完整性）的机会。\n\n4.  **两两相似度与链接决策**：\n    对于由 $b = b^\\star$ 的分块步骤生成的每个候选对 $(i, j)$，应用一个两阶段决策规则来确定它们是否构成一个链接。\n    \n    a.  **人口统计信息一致性**：第一个条件是哈希化的 'sex' 属性完全匹配：$H(\\text{sex}(i)) = H(\\text{sex}(j))$。这作为一个快速、确定性的过滤器。\n\n    b.  **就诊模式相似度**：第二个条件衡量患者医疗就诊历史的重叠程度。对于每条记录 $r$，就诊天数列表 $E(r)$ 通过以下变换转换为一组基于周的时间分箱 $W(r)$：\n    $$ W(r) = \\left\\{ \\left\\lfloor \\dfrac{d}{7} \\right\\rfloor : d \\in E(r) \\right\\} $$\n    然后，使用 Jaccard 相似系数来量化一对 $(i,j)$ 的就诊模式相似度：\n    $$ J\\big(W(i), W(j)\\big) = \\dfrac{|W(i) \\cap W(j)|}{|W(i) \\cup W(j)|} $$\n    如果该值达到或超过给定的阈值 $t$，即 $J\\big(W(i), W(j)\\big) \\ge t$，则认为这对记录的就诊模式相似。\n\n    当且仅当人口统计信息一致性和就诊模式相似度两个条件都满足时，一对 $(i,j)$ 才被声明为“链接”。此类链接的总数用 $L$ 表示。\n\n提供的 Python 代码实现了这整个管道。它遍历每个测试用例，确定最优的分块位长 $b^\\star$，计算相应的候选对计数 $C(b^\\star)$ 和复杂性比率 $\\rho(b^\\star)$，并最终根据指定的规则计算链接对的总数 $L$。然后将结果格式化为所需的输出结构。", "answer": "```python\nimport hashlib\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the entity resolution pipeline for the given test suite.\n    \"\"\"\n    test_cases = [\n        {\n            \"A_records\": [\n                {\"id\": \"A1\", \"dob\": \"1990-01-01\", \"zip3\": \"123\", \"sex\": \"F\", \"E\": [10, 20, 31]},\n                {\"id\": \"A2\", \"dob\": \"1981-05-10\", \"zip3\": \"123\", \"sex\": \"M\", \"E\": [200, 210, 220]},\n                {\"id\": \"A3\", \"dob\": \"1975-03-30\", \"zip3\": \"999\", \"sex\": \"F\", \"E\": [365]},\n            ],\n            \"B_records\": [\n                {\"id\": \"B1\", \"dob\": \"1990-01-01\", \"zip3\": \"123\", \"sex\": \"F\", \"E\": [11, 20, 28]},\n                {\"id\": \"B2\", \"dob\": \"1981-05-10\", \"zip3\": \"124\", \"sex\": \"M\", \"E\": [210, 230]},\n                {\"id\": \"B3\", \"dob\": \"1975-03-30\", \"zip3\": \"999\", \"sex\": \"F\", \"E\": [370]},\n            ],\n            \"t\": 0.6,\n            \"R\": 0.4,\n            \"b_range\": (0, 12),\n        },\n        {\n            \"A_records\": [\n                {\"id\": \"A4\", \"dob\": \"1960-07-07\", \"zip3\": \"555\", \"sex\": \"F\", \"E\": [100, 110, 120]},\n                {\"id\": \"A5\", \"dob\": \"1961-07-07\", \"zip3\": \"556\", \"sex\": \"F\", \"E\": [90, 200]},\n            ],\n            \"B_records\": [\n                {\"id\": \"B4\", \"dob\": \"1970-08-08\", \"zip3\": \"777\", \"sex\": \"M\", \"E\": [400]},\n                {\"id\": \"B5\", \"dob\": \"1971-08-08\", \"zip3\": \"778\", \"sex\": \"F\", \"E\": [401]},\n            ],\n            \"t\": 0.5,\n            \"R\": 0.2,\n            \"b_range\": (0, 12),\n        },\n        {\n            \"A_records\": [\n                {\"id\": \"A6\", \"dob\": \"1988-02-02\", \"zip3\": \"555\", \"sex\": \"F\", \"E\": [100, 110, 120, 200]},\n                {\"id\": \"A7\", \"dob\": \"1992-03-03\", \"zip3\": \"555\", \"sex\": \"F\", \"E\": [105, 115, 125]},\n                {\"id\": \"A8\", \"dob\": \"1993-03-03\", \"zip3\": \"123\", \"sex\": \"M\", \"E\": [300, 301]},\n            ],\n            \"B_records\": [\n                {\"id\": \"B6\", \"dob\": \"1988-02-02\", \"zip3\": \"555\", \"sex\": \"F\", \"E\": [100, 110]},\n                {\"id\": \"B7\", \"dob\": \"1995-04-04\", \"zip3\": \"555\", \"sex\": \"F\", \"E\": [130, 140, 150]},\n                {\"id\": \"B8\", \"dob\": \"1993-03-03\", \"zip3\": \"123\", \"sex\": \"M\", \"E\": [300, 302]},\n            ],\n            \"t\": 0.5,\n            \"R\": 1.0,\n            \"b_range\": (0, 12),\n        },\n    ]\n\n    final_results = []\n    for case in test_cases:\n        final_results.append(process_case(case))\n    \n    # Format the final output string exactly as specified.\n    # The format [v1,v2,v3,v4] is achieved by default `str()` on a list.\n    # The floats will be represented with sufficient precision.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\ndef H(text):\n    \"\"\"Computes the SHA-256 hash of a string and returns it as a 256-bit integer.\"\"\"\n    return int(hashlib.sha256(text.encode('utf-8')).hexdigest(), 16)\n\ndef get_block_key(h_val, b):\n    \"\"\"Computes the block key from a 256-bit hash integer and block bit length b.\"\"\"\n    if b == 0:\n        return 0\n    # Right-shift to get the first b bits is equivalent to floor division.\n    return h_val >> (256 - b)\n\ndef calculate_complexity(A_records, B_records, b, zip3_hashes):\n    \"\"\"Calculates the number of candidate pairs C(b) and ratio rho(b).\"\"\"\n    if not A_records or not B_records:\n        return 0, 0.0\n\n    blocks_A = defaultdict(int)\n    for rec in A_records:\n        h_val = zip3_hashes[rec['id']]\n        key = get_block_key(h_val, b)\n        blocks_A[key] += 1\n\n    blocks_B = defaultdict(int)\n    for rec in B_records:\n        h_val = zip3_hashes[rec['id']]\n        key = get_block_key(h_val, b)\n        blocks_B[key] += 1\n\n    C_b = 0\n    # Iterate over keys present in A and check if they exist in B\n    for key, count_A in blocks_A.items():\n        if key in blocks_B:\n            C_b += count_A * blocks_B[key]\n    \n    total_pairs = len(A_records) * len(B_records)\n    rho_b = C_b / total_pairs if total_pairs > 0 else 0.0\n    \n    return C_b, rho_b\n\ndef calculate_jaccard(E1, E2):\n    \"\"\"Calculates Jaccard similarity of week bins derived from encounter day lists.\"\"\"\n    W1 = {d // 7 for d in E1}\n    W2 = {d // 7 for d in E2}\n    \n    intersection_size = len(W1.intersection(W2))\n    union_size = len(W1.union(W2))\n\n    if union_size == 0:\n        return 1.0  # Convention for two empty sets\n    return intersection_size / union_size\n\ndef process_case(case_data):\n    \"\"\"Processes a single test case through the full pipeline.\"\"\"\n    A_records = case_data[\"A_records\"]\n    B_records = case_data[\"B_records\"]\n    t = case_data[\"t\"]\n    R = case_data[\"R\"]\n    b_min, b_max = case_data[\"b_range\"]\n\n    # Pre-compute all necessary hashes\n    zip3_hashes = {rec['id']: H(rec['zip3']) for rec in A_records + B_records}\n    sex_hashes = {rec['id']: H(rec['sex']) for rec in A_records + B_records}\n    \n    # 1. Find the optimal block bit length b_star\n    b_star = b_max\n    C_b_star = 0\n    rho_b_star = 0.0\n\n    for b in range(b_min, b_max + 1):\n        C_b, rho_b = calculate_complexity(A_records, B_records, b, zip3_hashes)\n        if rho_b = R:\n            b_star = b\n            C_b_star = C_b\n            rho_b_star = rho_b\n            break\n    else: # If loop completed without break\n        C_b_star, rho_b_star = calculate_complexity(A_records, B_records, b_max, zip3_hashes)\n\n    # 2. Count linked pairs L for b_star\n    L = 0\n    if C_b_star > 0:\n        blocks_A = defaultdict(list)\n        for rec in A_records:\n            h_val = zip3_hashes[rec['id']]\n            key = get_block_key(h_val, b_star)\n            blocks_A[key].append(rec)\n        \n        blocks_B = defaultdict(list)\n        for rec in B_records:\n            h_val = zip3_hashes[rec['id']]\n            key = get_block_key(h_val, b_star)\n            blocks_B[key].append(rec)\n\n        common_keys = set(blocks_A.keys()).intersection(blocks_B.keys())\n\n        for key in common_keys:\n            for rec_A in blocks_A[key]:\n                for rec_B in blocks_B[key]:\n                    # Link decision logic\n                    #\n                    # Condition 1: Sex hash match\n                    if sex_hashes[rec_A['id']] != sex_hashes[rec_B['id']]:\n                        continue\n                    \n                    # Condition 2: Jaccard similarity\n                    j_sim = calculate_jaccard(rec_A['E'], rec_B['E'])\n                    if j_sim >= t:\n                        L += 1\n\n    # Using an f-string with .4f ensures the trailing zeros if needed\n    formatted_rho = f\"{rho_b_star:.4f}\"\n\n    return [b_star, C_b_star, float(formatted_rho), L]\n\nsolve()\n```", "id": "4853983"}, {"introduction": "原始的临床数据，例如一长串诊断代码，蕴含着宝贵的信息，但必须将其转化为标准化的、有意义的特征才能用于数据挖掘。本练习 [@problem_id:4854005] 模拟了临床表型分析中的一项核心任务：计算查尔森合并症指数 (Charlson Comorbidity Index)。你将学习如何对电子健康记录 (EHR) 数据应用基于规则的逻辑，处理回顾期等时间限制，甚至学会如何考量数据的不确定性。", "problem": "一个医疗系统希望使用电子健康记录（EHR）中记录的国际疾病分类（ICD）诊断代码，为单名患者在一次指标性就诊（index encounter）时计算基线查尔森合并症指数（CCI）。该基线计算必须遵循医学信息学和医疗数据挖掘中的标准队列对齐原则：合并症应在指标日期之前的一个固定回顾期内确定，指标日期之后记录的代码应从基线中排除，除非为纠正潜在的分类错误而进行显式建模。\n\n使用以下基本依据：\n- 查尔森合并症指数（CCI）定义为各类别权重之和，每个合并症类别最多计算一次。与该患者相关的类别及其标准权重为：心肌梗死（$1$）、充血性心力衰竭（$1$）、外周血管疾病（$1$）、慢性肺部疾病（$1$）、无并发症糖尿病（$1$）、有终末器官损害的糖尿病（$2$）、中度至重度肾病（$2$）以及获得性免疫缺陷综合征/人类免疫缺陷病毒（AIDS/HIV）（$6$）。如果无并发症糖尿病和有终末器官损害的糖尿病同时存在，则仅计算有终末器官损害的糖尿病的较高权重（$2$）。\n- 队列对齐：使用指标日期 $I$ 之前的 $365$ 天固定回顾窗口来定义基线合并症状态。严格在 $I$ 之后记录的代码不用于确定基线，但为了解决指标后记录的慢性病可能存在的分类错误问题，假设一个不确定性模型，其中指标后的代码贡献其权重乘以它反映的是既往病症而非与指标事件相关的新发病症的概率。假设这些指标后分类错误的概率在各类别之间是独立的。\n\n指标日期：\n- $I = 2024$-$07$-$01$\n\n患者的 ICD-10 代码及记录日期：\n- `I25.2` (陈旧性心肌梗死) on $2023$-$08$-$15$\n- `I50.9` (充血性心力衰竭) on $2024$-$06$-$10$\n- `E11.9` (2型糖尿病，无并发症) on $2023$-$12$-$05$\n- `E11.21` (2型糖尿病，伴有糖尿病肾病) on $2024$-$06$-$20$\n- `J44.9` (慢性阻塞性肺疾病) on $2024$-$03$-$10$\n- `I73.9` (外周血管疾病) on $2024$-$05$-$21$\n- `N18.5` (慢性肾病5期) on $2024$-$07$-$10$, 记录于指标日期之后，其反映既往病症的概率为 $p_{r} = 0.65$\n- `B20` (人类免疫缺陷病毒病) on $2024$-$07$-$03$, 记录于指标日期之后，其反映既往病症的概率为 $p_{h} = 0.25$\n- `C18.9` (结肠恶性肿瘤) on $2023$-$01$-$20$\n- `G81.9` (偏瘫，未特指) on $2022$-$12$-$31$\n\n基于数据挖掘原则的任务：\n- 确定严格在 $I$ 之前的 $365$ 天回顾窗口。\n- 识别哪些代码落在回顾窗口内，并使用上述类别规则将其映射到 CCI 类别，确保执行类别内去重和糖尿病严重性优先原则。回顾窗口之外的代码被排除。对于在 $I$ 之后记录的代码，将其从确定性基线状态中排除，但使用提供的分类错误概率以期望值的形式纳入其贡献。\n- 在指标后各类别分类错误独立的假设下，计算在 $I$ 时的预期 CCI，其值为确定性的指标前基线权重之和加上概率加权的指标后贡献。\n\n以无单位小数形式表示最终答案，并将答案四舍五入到四位有效数字。最终答案无需单位。只提供单个数值作为最终答案。", "solution": "用户要求根据电子健康记录（EHR）中的诊断代码，为一名患者计算预期的查尔森合并症指数（CCI）。该过程需要验证问题陈述，应用医学信息学原理构建队列，并执行指定的计算。\n\n### 第 1 步：问题验证\n\n首先，逐字提取问题陈述中给出的信息。\n- **指标日期**：$I = 2024-07-01$。\n- **回顾窗口**：指标日期 $I$ 之前的 $365$ 天。\n- **CCI 类别和权重**：\n  - 心肌梗死：权重 $1$。\n  - 充血性心力衰竭：权重 $1$。\n  - 外周血管疾病：权重 $1$。\n  - 慢性肺部疾病：权重 $1$。\n  - 无并发症糖尿病：权重 $1$。\n  - 有终末器官损害的糖尿病：权重 $2$。\n  - 中度至重度肾病：权重 $2$。\n  - 获得性免疫缺陷综合征/人类免疫缺陷病毒（AIDS/HIV）：权重 $6$。\n- **CCI 计算规则**：\n  - 每个类别最多计算一次。\n  - 如果两种糖尿病类别都存在，只计算较高的权重（$2$）。\n- **指标后不确定性模型**：\n  - 一个指标后的代码贡献其权重乘以它反映既往病症的概率。\n  - 假设这些概率是独立的。\n- **患者数据（ICD-10 代码和日期）**：\n  - `I25.2` (陈旧性心肌梗死) 于 $2023-08-15$\n  - `I50.9` (充血性心力衰竭) 于 $2024-06-10$\n  - `E11.9` (2型糖尿病，无并发症) 于 $2023-12-05$\n  - `E11.21` (2型糖尿病，伴有糖尿病肾病) 于 $2024-06-20$\n  - `J44.9` (慢性阻塞性肺疾病) 于 $2024-03-10$\n  - `I73.9` (外周血管疾病) 于 $2024-05-21$\n  - `N18.5` (慢性肾病5期) 于 $2024-07-10$, 其为既往病症的概率为 $p_{r} = 0.65$。\n  - `B20` (人类免疫缺陷病毒病) 于 $2024-07-03$, 其为既往病症的概率为 $p_{h} = 0.25$。\n  - `C18.9` (结肠恶性肿瘤) 于 $2023-01-20$\n  - `G81.9` (偏瘫，未特指) 于 $2022-12-31$\n- **任务**：计算预期 CCI，并将最终答案四舍五入到四位有效数字。\n\n该问题具有科学依据，使用了医学信息学中的标准概念，如 CCI、ICD 代码和回顾窗口。问题陈述清晰，提供了计算唯一、有意义解所需的所有数据和规则。语言客观精确。该问题不违反任何无效标准。因此，该问题被认定为**有效**。\n\n### 第 2 步：求解推导\n\n求解过程分四个阶段：(1) 确定回顾期，(2) 识别并映射相关的基线代码，(3) 计算 CCI 的确定性部分，以及 (4) 计算指标后代码的期望值以得出总预期 CCI。\n\n**1. 确定回顾窗口**\n指标日期为 $I = 2024-07-01$。回顾窗口涵盖此日期之前的 $365$ 天。$2024$ 年是闰年，包含 2 月 $29$ 日。该期间从 $2023-07-02$ 开始，到 $2024-06-30$ 结束。在此闭区间日期范围 $[2023-07-02, 2024-06-30]$ 内记录的任何诊断代码都将用于基线合并症评估。\n\n**2. 识别和映射基线代码**\n我们检查每个代码的记录日期以确定其是否包含在内。\n- `I25.2` (心肌梗死) 于 $2023-08-15$：**在**窗口内。映射到心肌梗死。\n- `I50.9` (充血性心力衰竭) 于 $2024-06-10$：**在**窗口内。映射到充血性心力衰竭。\n- `E11.9` (无并发症糖尿病) 于 $2023-12-05$：**在**窗口内。映射到无并发症糖尿病。\n- `E11.21` (有并发症糖尿病) 于 $2024-06-20$：**在**窗口内。映射到有终末器官损害的糖尿病。\n- `J44.9` (慢性肺部疾病) 于 $2024-03-10$：**在**窗口内。映射到慢性肺部疾病。\n- `I73.9` (外周血管疾病) 于 $2024-05-21$：**在**窗口内。映射到外周血管疾病。\n- `C18.9` (恶性肿瘤) 于 $2023-01-20$：**在**窗口外（过早）。\n- `G81.9` (偏瘫) 于 $2022-12-31$：**在**窗口外（过早）。\n\n代码 `N18.5` 和 `B20` 记录在指标日期之后，将单独处理。\n\n**3. 计算确定性基线 CCI ($C_{det}$)**\n根据回顾窗口内的代码，我们对相应唯一 CCI 类别的权重求和，并应用指定规则。\n- 心肌梗死：权重 $w_{mi} = 1$。\n- 充血性心力衰竭：权重 $w_{chf} = 1$。\n- 慢性肺部疾病：权重 $w_{cpd} = 1$。\n- 外周血管疾病：权重 $w_{pvd} = 1$。\n- 糖尿病：`无并发症糖尿病`（权重 $1$）和`有终末器官损害的糖尿病`（权重 $2$）同时存在。根据规则，只计算较高的权重。因此，糖尿病的贡献为 $w_{dm} = 2$。\n\n确定性基线分数 $C_{det}$ 是这些权重之和：\n$$C_{det} = w_{mi} + w_{chf} + w_{cpd} + w_{pvd} + w_{dm}$$\n$$C_{det} = 1 + 1 + 1 + 1 + 2 = 6$$\n\n**4. 计算预期 CCI**\n总预期 CCI 是确定性基线分数与指标后代码的预期贡献之和。指标后代码的预期贡献是其权重乘以其反映既往病症的概率。\n\n- 对于 `N18.5` (中度至重度肾病)：\n  - 权重: $w_{r} = 2$。\n  - 概率: $p_{r} = 0.65$。\n  - 预期贡献: $E_{r} = w_{r} \\times p_{r} = 2 \\times 0.65 = 1.3$。\n\n- 对于 `B20` (AIDS/HIV)：\n  - 权重: $w_{h} = 6$。\n  - 概率: $p_{h} = 0.25$。\n  - 预期贡献: $E_{h} = w_{h} \\times p_{h} = 6 \\times 0.25 = 1.5$。\n\n基于独立性假设，来自指标后代码的总预期贡献 $E_{post}$ 是各个预期贡献之和。\n$$E_{post} = E_{r} + E_{h} = 1.3 + 1.5 = 2.8$$\n\n总预期 CCI, $E[CCI]$, 是：\n$$E[CCI] = C_{det} + E_{post}$$\n$$E[CCI] = 6 + 2.8 = 8.8$$\n\n问题要求答案四舍五入到四位有效数字。数值 $8.8$ 表示为 $8.800$ 以满足此要求。", "answer": "$$\\boxed{8.800}$$", "id": "4854005"}, {"introduction": "预测模型的输出仅仅是一个概率值；其真正的价值在于如何指导决策。在医疗领域，错误决策的后果并非等同——漏诊一种疾病的代价可能远高于推荐一次不必要的检查。本实践 [@problem_id:4853996] 深入探讨了将模型概率转化为最优行动的关键步骤，通过引入假阳性 ($C_{FP}$) 和假阴性 ($C_{FN}$) 的现实世界成本，帮助你为特定的临床场景确定最佳决策阈值。", "problem": "一家医院部署了一个经过校准的概率分类器，用于早期检测一种二元状况。校准意味着对于任何具有特征 $X=x$ 的患者，模型得分等于后验概率 $s(x)=\\mathbb{P}(Y=1\\mid X=x)$。基于该模型的临床操作是单阈值决策规则：如果 $s(x)\\ge \\tau$ 则预测为阳性，否则预测为阴性。假阴性的成本为 $C_{FN}0$，假阳性的成本为 $C_{FP}0$，疾病患病率为 $\\pi=\\mathbb{P}(Y=1)\\in(0,1)$。假设正确决策没有成本，并且需要最小化的量是每位患者的期望成本。\n\n仅使用期望成本、条件风险的核心定义，以及真阳性率 $TPR(\\tau)$ 和假阳性率 $FPR(\\tau)$ 作为阈值 $\\tau$ 的函数的定义，从第一性原理出发推导：\n\n1. 在将阈值规则应用于校准得分 $s(x)$ 的情况下，最小化每位患者期望成本的最优阈值 $\\tau^{*}$。\n2. 受试者工作特征 (ROC) 曲线斜率的一个显式表达式，定义为在由 $\\tau^{*}$ 诱导的工作点处计算的 $d\\,TPR/d\\,FPR$，用 $C_{FN}$、$C_{FP}$ 和 $\\pi$ 表示。\n\n将你的最终答案以单行矩阵 $\\begin{pmatrix}\\tau^{*}  m^{*}\\end{pmatrix}$ 的形式报告，其中 $m^{*}$ 表示在对应于 $\\tau^{*}$ 的工作点处 ROC 曲线的斜率。不需要进行数值代入。如果你选择提供任何数值近似，请四舍五入到四位有效数字。答案是无量纲的，应不带任何单位表示。", "solution": "用户提供了一个问题陈述，在尝试解答之前需要对其进行验证。\n\n### 第1步：提取已知信息\n- 使用经过校准的概率分类器来处理一个二元状况 ($Y \\in \\{0, 1\\}$)。\n- 分类器得分 $s(x)$ 等于后验概率：$s(x) = \\mathbb{P}(Y=1 \\mid X=x)$。\n- 应用单阈值决策规则：如果 $s(x) \\ge \\tau$ 则预测为阳性，否则预测为阴性。\n- 假阴性的成本为 $C_{FN}  0$。\n- 假阳性的成本为 $C_{FP}  0$。\n- 正确决策没有成本（成本为 $0$）。\n- 疾病患病率为 $\\pi = \\mathbb{P}(Y=1)$，其中 $\\pi \\in (0, 1)$。\n- 目标是最小化每位患者的期望成本。\n- 任务是推导：\n  1. 最小化期望成本的最优阈值 $\\tau^{*}$。\n  2. 对应于 $\\tau^{*}$ 的工作点处的受试者工作特征 (ROC) 曲线的斜率 $m^{*} = d\\,TPR/d\\,FPR$。\n\n### 第2步：使用提取的已知信息进行验证\n根据验证标准对问题进行评估。\n- **科学依据**：该问题是贝叶斯决策理论在分类器阈值选择中的一个标准应用，这是统计模式识别和医学信息学中的一个基本概念。它在科学上是合理的。\n- **适定性**：该问题定义明确。它提供了所有必要的组成部分（成本、概率、决策规则和一个明确的目标函数——期望成本），以推导出最优阈值和相应 ROC 斜率的唯一解。\n- **客观性**：该问题使用精确、无歧义的数学和统计语言进行陈述。\n\n该问题没有表现出任何已定义的缺陷（例如，科学上不合理、不完整、有歧义）。它是一个基于既定原则的、形式化的、可解的问题。\n\n### 第3步：结论与行动\n该问题被判定为**有效**。将按要求从第一性原理推导解答。\n\n### 推导过程\n\n根据问题陈述的要求，解答分为两部分进行推导。\n\n**第1部分：最优阈值 $\\tau^{*}$ 的推导**\n\n最优决策规则是在任何给定患者的情况下最小化期望成本的规则。我们为具有特征 $x$（其得分为 $s(x)$）的患者，针对两种可能的行动——预测为阳性 ($\\hat{y}=1$) 或预测为阴性 ($\\hat{y}=0$)——构建条件风险（期望成本）。\n\n设 $s(x)$ 为给定患者的得分。由于分类器经过校准，我们有 $s(x) = \\mathbb{P}(Y=1 \\mid X=x)$。因此，该患者为阴性的概率是 $\\mathbb{P}(Y=0 \\mid X=x) = 1 - s(x)$。\n\n预测为阳性的条件风险 $R(\\hat{y}=1 \\mid x)$ 是所有可能结果的成本之和，按其条件概率加权：\n$$R(\\hat{y}=1 \\mid x) = (\\text{若 } Y=1, \\hat{y}=1 \\text{ 的成本}) \\cdot \\mathbb{P}(Y=1 \\mid X=x) + (\\text{若 } Y=0, \\hat{y}=1 \\text{ 的成本}) \\cdot \\mathbb{P}(Y=0 \\mid X=x)$$\n第一项是真阳性，成本为 $0$。第二项是假阳性，成本为 $C_{FP}$。\n$$R(\\hat{y}=1 \\mid x) = 0 \\cdot s(x) + C_{FP} \\cdot (1 - s(x)) = C_{FP}(1 - s(x))$$\n\n预测为阴性的条件风险 $R(\\hat{y}=0 \\mid x)$ 的定义类似：\n$$R(\\hat{y}=0 \\mid x) = (\\text{若 } Y=1, \\hat{y}=0 \\text{ 的成本}) \\cdot \\mathbb{P}(Y=1 \\mid X=x) + (\\text{若 } Y=0, \\hat{y}=0 \\text{ 的成本}) \\cdot \\mathbb{P}(Y=0 \\mid X=x)$$\n第一项是假阴性，成本为 $C_{FN}$。第二项是真阴性，成本为 $0$。\n$$R(\\hat{y}=0 \\mid x) = C_{FN} \\cdot s(x) + 0 \\cdot (1 - s(x)) = C_{FN}s(x)$$\n\n为了最小化期望成本，对于任何给定的 $s(x)$，我们应该选择具有较低条件风险的行动。最优决策是当且仅当 $R(\\hat{y}=1 \\mid x) \\le R(\\hat{y}=0 \\mid x)$ 时预测为阳性 ($\\hat{y}=1$)。等式成立的情况按惯例归为阳性类别。\n$$C_{FP}(1 - s(x)) \\le C_{FN}s(x)$$\n我们解出 $s(x)$:\n$$C_{FP} - C_{FP}s(x) \\le C_{FN}s(x)$$\n$$C_{FP} \\le (C_{FN} + C_{FP})s(x)$$\n$$s(x) \\ge \\frac{C_{FP}}{C_{FN} + C_{FP}}$$\n\n问题陈述指出，决策规则是当 $s(x) \\ge \\tau$ 时预测为阳性。将此与我们推导出的最优规则进行比较，我们确定最优阈值 $\\tau^{*}$ 是满足此条件的值。\n$$\\tau^{*} = \\frac{C_{FP}}{C_{FN} + C_{FP}}$$\n\n**第2部分：在 $\\tau^{*}$ 处的 ROC 斜率 $m^{*}$ 的推导**\n\n受试者工作特征 (ROC) 曲线绘制了在不同阈值 $\\tau$ 下，真阳性率 ($TPR$) 对假阳性率 ($FPR$) 的关系图。ROC 曲线在某一点的斜率由 $m = d\\,TPR / d\\,FPR$ 给出。\n\n设 $f_1(s)$ 为阳性类别 ($Y=1$) 得分 $s(x)$ 的概率密度函数 (PDF)，$f_0(s)$ 为阴性类别 ($Y=0$) 得分的 PDF。$TPR$ 和 $FPR$ 作为阈值 $\\tau$ 的函数为：\n$$TPR(\\tau) = \\mathbb{P}(s(X) \\ge \\tau \\mid Y=1) = \\int_{\\tau}^{1} f_1(s) \\,ds$$\n$$FPR(\\tau) = \\mathbb{P}(s(X) \\ge \\tau \\mid Y=0) = \\int_{\\tau}^{1} f_0(s) \\,ds$$\n\n使用链式法则，斜率 $m(\\tau)$ 为：\n$$m(\\tau) = \\frac{d\\,TPR}{d\\,FPR} = \\frac{d\\,TPR/d\\tau}{d\\,FPR/d\\tau}$$\n应用微积分基本定理：\n$$\\frac{d\\,TPR}{d\\tau} = \\frac{d}{d\\tau} \\int_{\\tau}^{1} f_1(s) \\,ds = -f_1(\\tau)$$\n$$\\frac{d\\,FPR}{d\\tau} = \\frac{d}{d\\tau} \\int_{\\tau}^{1} f_0(s) \\,ds = -f_0(\\tau)$$\n因此，对应于阈值 $\\tau$ 的点的斜率是该得分值处密度函数的比值：\n$$m(\\tau) = \\frac{-f_1(\\tau)}{-f_0(\\tau)} = \\frac{f_1(\\tau)}{f_0(\\tau)}$$\n\n我们现在利用分类器的校准属性 $s = \\mathbb{P}(Y=1 \\mid \\text{score}=s)$，将这个比率与得分值 $\\tau$ 联系起来。对后验概率应用贝叶斯定理：\n$$\\mathbb{P}(Y=1 \\mid \\text{score}=s) = \\frac{\\mathbb{P}(\\text{score}=s \\mid Y=1) \\mathbb{P}(Y=1)}{\\mathbb{P}(\\text{score}=s)}$$\n用 PDF 和患病率 $\\pi$ 表示：\n$$s = \\frac{f_1(s) \\pi}{f_1(s) \\pi + f_0(s) (1-\\pi)}$$\n我们重新整理这个方程以求解比率 $f_1(s)/f_0(s)$：\n$$s(f_1(s) \\pi + f_0(s) (1-\\pi)) = f_1(s) \\pi$$\n$$s f_0(s) (1-\\pi) = f_1(s) \\pi - s f_1(s) \\pi = f_1(s) \\pi (1-s)$$\n$$\\frac{f_1(s)}{f_0(s)} = \\frac{s(1-\\pi)}{\\pi(1-s)}$$\n因此，由阈值 $\\tau$ 定义的工作点处的 ROC 曲线斜率为：\n$$m(\\tau) = \\frac{\\tau(1-\\pi)}{\\pi(1-\\tau)}$$\n\n我们需要在最优阈值 $\\tau^{*}$ 处计算这个斜率。令 $m^{*} = m(\\tau^{*})$：\n$$m^{*} = \\frac{\\tau^{*}(1-\\pi)}{\\pi(1-\\tau^{*})}$$\n我们代入第1部分中 $\\tau^{*}$ 的表达式：\n$$\\tau^{*} = \\frac{C_{FP}}{C_{FN} + C_{FP}}$$\n并代入 $1-\\tau^{*}$ 的表达式：\n$$1 - \\tau^{*} = 1 - \\frac{C_{FP}}{C_{FN} + C_{FP}} = \\frac{C_{FN} + C_{FP} - C_{FP}}{C_{FN} + C_{FP}} = \\frac{C_{FN}}{C_{FN} + C_{FP}}$$\n现在，将这些代入 $m^{*}$ 的方程中：\n$$m^{*} = \\frac{\\left( \\frac{C_{FP}}{C_{FN} + C_{FP}} \\right) (1-\\pi)}{\\pi \\left( \\frac{C_{FN}}{C_{FN} + C_{FP}} \\right)}$$\n分子和分母中的项 $(C_{FN} + C_{FP})$ 可以消掉，得到：\n$$m^{*} = \\frac{C_{FP}(1-\\pi)}{C_{FN}\\pi}$$\n这就是在最优工作点处 ROC 曲线斜率的所需表达式。\n\n最终答案是数对 $(\\tau^{*}, m^{*})$。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{C_{FP}}{C_{FN} + C_{FP}}  \\frac{C_{FP}(1-\\pi)}{C_{FN}\\pi} \\end{pmatrix}}$$", "id": "4853996"}]}