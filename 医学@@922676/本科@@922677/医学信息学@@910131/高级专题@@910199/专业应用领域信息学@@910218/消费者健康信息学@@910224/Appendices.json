{"hands_on_practices": [{"introduction": "一款成功的消费者健康应用不仅需要提供有价值的功能，还必须能够让用户持续使用，从而养成健康习惯。为了量化应用的“粘性”，产品开发者常使用日活跃用户（DAU）与月活跃用户（MAU）的比率这一核心指标。这个练习将指导你计算并解读这一关键的参与度指标，帮助你理解如何评估一个应用在用户日常生活中所扮演的角色。[@problem_id:4831473]", "problem": "一个提供个性化高血压指导流程的大型消费者健康应用程序，使用标准的用户参与度指标来评估用户是否正在养成日常习惯。在一个为期 $30$ 天的日历月内，系统记录的独立月活跃用户（MAU）数量为 $50{,}000$，而在该月的一个典型日子里，独立日活跃用户（DAU）数量为 $20{,}000$。使用消费者健康信息学的核心定义，考虑一个定义为“月活跃用户群组中在典型日子里活跃的用户所占比例”的粘性指标。请仅从这些定义和提供的数据出发，推导该粘性指标的表达式（用所提供的量表示），并计算其值。在此消费者健康信息学背景下，解释该结果对日常习惯养成的影响。将最终数值答案以不带百分号的小数形式表示，并四舍五入到三位有效数字。", "solution": "本题要求针对一个专注于高血压指导的消费者健康应用，推导并计算一个名为“粘性”的用户参与度指标。分析必须完全基于所提供的数据和定义。\n\n首先，我们必须将给定的量和定义形式化。设 $N_{MAU}$ 表示独立月活跃用户的数量， $N_{DAU}$ 表示指定月份内一个典型日子里的独立日活跃用户数量。题目提供了以下数值：\n$$\nN_{MAU} = 50{,}000\n$$\n$$\nN_{DAU} = 20{,}000\n$$\n观察期为期 $30$ 天的一个日历月。\n\n题目将我们用 $S$ 表示的粘性指标定义为“月活跃用户群组中在典型日子里活跃的用户所占比例”。这个定义为构建表达式提供了直接的指导。“月活跃用户群组”是指其规模为 $N_{MAU}$ 的用户集合。该群组中“在典型日子里活跃”的用户数量由 $N_{DAU}$ 给出。因此，该比例就是这两个数量的比值。\n\n粘性指标 $S$ 的数学表达式为：\n$$\nS = \\frac{N_{DAU}}{N_{MAU}}\n$$\n\n接下来，我们将提供的数值代入此表达式以计算 $S$ 的值。\n$$\nS = \\frac{20{,}000}{50{,}000}\n$$\n这个分数可以简化为：\n$$\nS = \\frac{2}{5} = 0.4\n$$\n题目要求最终数值答案以小数形式表示，并四舍五入到三位有效数字。数值 $0.4$ 有一位有效数字。为了将其表示为三位有效数字，我们必须写成 $0.400$。\n$$\nS = 0.400\n$$\n\n最后，我们必须在消费者健康信息学的背景下解释这一结果对日常习惯养成的影响。粘性指标 $S = 0.400$ 意味着，在一个典型日子里，该月至少与应用互动过一次的用户中有 $40\\%$ 是活跃的。\n\n在高血压管理的背景下，养成日常习惯——例如记录血压、服用药物或参与教育内容——通常是改善健康结果的一个主要目标。$40\\%$ 的粘性表明日常参与度达到了中等偏强的水平。这表明有相当一部分核心用户群正在成功地将该应用融入他们的日常生活中，这对于该群体内的习惯养成是一个积极的指标。\n\n然而，该指标也揭示了，在一个典型日子里，大部分月活跃用户（$100\\% - 40\\% = 60\\%$）并不活跃。这表明相当一部分用户群的参与是零星或不频繁的。对于像高血压这样持续每日监测和管理至关重要的病症，这种参与度水平可能不足以让大部分用户群养成获得临床益处所必需的习惯。\n\n总之，尽管该应用在为一小部分重要用户培养日常习惯方面取得了成功，但在改进用户参与策略方面仍有巨大机会，可以将更大比例的月活跃用户群转化为日活跃用户，从而加强习惯的养成，并增强对所服务人群产生积极临床影响的潜力。", "answer": "$$\n\\boxed{0.400}\n$$", "id": "4831473"}, {"introduction": "在处理敏感的个人健康信息时，保护用户隐私是消费者健康信息学的首要伦理和法律责任。$k$-匿名化是一种基本但强大的数据脱敏技术，它通过数据泛化和抑制来确保数据集中的任何个体都无法被轻易识别。通过这个动手实践，你将亲自实现$k$-匿名化过程，从而深刻理解在保护个人隐私和维持数据可用性之间取得平衡的挑战。[@problem_id:4831449]", "problem": "一个消费者健康数据集包含带有准标识符的个人级别记录：邮政编码 (ZIP)、出生日期和性别。其基本基础是 $k$-匿名性的定义：对于给定的 $k \\in \\mathbb{N}$，如果数据集中每个根据准标识符无法区分的记录所组成的等价类的大小至少为 $k$，则该数据集满足 $k$-匿名性。如果在对每个准标识符应用相同的泛化后，所得到的泛化元组是相同的，那么在选定的泛化下，两条记录是无法区分的。抑制操作会移除违反 $k$-匿名性约束的记录，并且此操作会迭代应用，因为移除某些记录可能会改变剩余记录的等价类大小。\n\n你必须编写一个程序，对于固定的 $k=5$，计算在应用指定的泛化参数后，并通过迭代抑制所有大小小于 $k$ 的等价类中的所有记录，直到不存在此类等价类为止所达到的 $k$-匿名性级别（即最小等价类大小）。如果抑制后没有记录剩余，则将达到的级别定义为 $0$。\n\n准标识符的泛化定义如下：\n- 邮政编码泛化参数 $g_{\\text{zip}} \\in \\{0,2,3,5\\}$ 表示：保留 $5$ 位邮政编码的前 $g_{\\text{zip}}$ 位数字，并用星号字符 $\\text{\"*\"}$ 替换剩余的数字。例如，当 $g_{\\text{zip}}=3$ 时，$\\text{\"02139\"} \\mapsto \\text{\"021**\"}$；当 $g_{\\text{zip}}=0$ 时，任何邮政编码都映射到 $\\text{\"*****\"}$；当 $g_{\\text{zip}}=5$ 时，邮政编码保持不变。\n- 出生日期泛化参数 $g_{\\text{date}} \\in \\{\\text{\"day\"},\\text{\"month\"},\\text{\"year\"},\\text{\"decade\"}\\}$ 表示：\n  - $\\text{\"day\"}$: 保留 $\\text{\"YYYY-MM-DD\"}$ 不变。\n  - $\\text{\"month\"}$: 仅保留 $\\text{\"YYYY-MM\"}$。\n  - $\\text{\"year\"}$: 仅保留 $\\text{\"YYYY\"}$。\n  - $\\text{\"decade\"}$: 将年份 $\\text{\"YYYY\"}$ 映射到其年代标签 $\\text{\"YYYYs\"}$，其中 $\\text{\"YYYY\"}$ 被替换为年代的起始年份 $\\left\\lfloor \\frac{\\text{YYYY}}{10} \\right\\rfloor \\times 10$；例如，$\\text{\"1981-07-27\"} \\mapsto \\text{\"1980s\"}$ 且 $\\text{\"1979-12-12\"} \\mapsto \\text{\"1970s\"}$。\n- 性别泛化参数 $g_{\\text{gen}} \\in \\{\\text{\"exact\"},\\text{\"*\"}\\}$ 表示：\n  - $\\text{\"exact\"}$: 保留 $\\text{\"M\"}$ 或 $\\text{\"F\"}$ 不变。\n  - $\\text{\"*\"}$: 将任何性别替换为 $\\text{\"*\"}$。\n\n等价类由相同的泛化值三元组 $(\\text{ZIP}^{\\prime}, \\text{Birth}^{\\prime}, \\text{Gender}^{\\prime})$ 构成。抑制操作迭代应用：在每次迭代中，移除所有属于大小小于 $k$ 的等价类的记录；基于剩余记录重新计算等价类大小；重复此过程，直到没有等价类的大小小于 $k$ 或直到没有记录剩余。\n\n数据集：共有 $30$ 条记录。每条记录是一个三元组 $\\left(\\text{ZIP}, \\text{Birthdate}, \\text{Gender}\\right)$，其中 ZIP 是一个 $5$ 位数字的字符串，Birthdate 是 $\\text{\"YYYY-MM-DD\"}$ 格式，Gender 是 $\\text{\"M\"}$ 或 $\\text{\"F\"}$：\n- $\\left(\\text{\"02139\"},\\ \\text{\"1980-01-15\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02138\"},\\ \\text{\"1980-02-20\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02139\"},\\ \\text{\"1980-03-25\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02140\"},\\ \\text{\"1980-04-05\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02138\"},\\ \\text{\"1980-05-30\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02139\"},\\ \\text{\"1980-06-10\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02139\"},\\ \\text{\"1980-07-12\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"02138\"},\\ \\text{\"1980-08-08\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"02140\"},\\ \\text{\"1980-09-19\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"02139\"},\\ \\text{\"1980-10-21\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"10012\"},\\ \\text{\"1980-02-14\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"10011\"},\\ \\text{\"1980-03-01\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"10013\"},\\ \\text{\"1980-06-18\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"10012\"},\\ \\text{\"1980-07-07\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"10011\"},\\ \\text{\"1980-11-30\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"10013\"},\\ \\text{\"1981-01-09\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"10012\"},\\ \\text{\"1981-03-22\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"10011\"},\\ \\text{\"1981-05-11\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"10012\"},\\ \\text{\"1981-07-27\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"10013\"},\\ \\text{\"1981-09-13\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"30303\"},\\ \\text{\"1979-02-02\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"30310\"},\\ \\text{\"1979-12-12\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"30309\"},\\ \\text{\"1980-01-03\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"30303\"},\\ \\text{\"1980-05-20\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"30310\"},\\ \\text{\"1980-08-28\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"02138\"},\\ \\text{\"1981-02-17\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02139\"},\\ \\text{\"1981-04-26\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02140\"},\\ \\text{\"1981-06-06\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02138\"},\\ \\text{\"1981-08-16\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02139\"},\\ \\text{\"1981-12-01\"},\\ \\text{\"M\"}\\right)$\n\n测试套件：对于每个测试用例，应用指定的泛化参数 $\\left(g_{\\text{zip}}, g_{\\text{date}}, g_{\\text{gen}}\\right)$ 并设 $k=5$，执行迭代抑制，并报告所达到的级别（一个整数），该级别定义为剩余数据集中最小的等价类大小（如果数据集为空，则为 $0$）。测试用例如下：\n- 测试 $1$: $\\left(3,\\ \\text{\"year\"},\\ \\text{\"exact\"}\\right)$\n- 测试 $2$: $\\left(2,\\ \\text{\"decade\"},\\ \\text{\"*\"}\\right)$\n- 测试 $3$: $\\left(5,\\ \\text{\"month\"},\\ \\text{\"exact\"}\\right)$\n- 测试 $4$: $\\left(3,\\ \\text{\"year\"},\\ \\text{\"*\"}\\right)$\n- 测试 $5$: $\\left(0,\\ \\text{\"decade\"},\\ \\text{\"*\"}\\right)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果顺序与测试用例的顺序相同（例如，$\\text{\"[a,b,c,d,e]\"}$，其中 $a,b,c,d,e$ 分别是作为整数表示的所达到的级别）。", "solution": "用户提供的问题是有效的。它在科学上基于数据隐私的原则，特别是 $k$-匿名性。该问题定义明确，具有一套完整且一致的给定条件，包括数据集、固定的参数 $k$、精确的泛化层次结构以及用于迭代抑制的确定性算法。每个测试用例都存在唯一的解。\n\n问题的核心是确定一个数据集在应用特定转换后的隐私级别。这是通过对给定的匿名性参数 $k \\in \\mathbb{N}$（在此设为 $k=5$）实施一个两阶段过程来实现的。这两个阶段是泛化和抑制。\n\n阶段1：泛化\n数据集包含 $N=30$ 条记录，每条记录都是一个准标识符元组：$(\\text{ZIP}, \\text{Birthdate}, \\text{Gender})$。泛化是将这些特定的准标识符转换为更不具体但语义上一致的值的过程。设一条记录为 $r_i = (\\text{QID}_{i,1}, \\text{QID}_{i,2}, \\text{QID}_{i,3})$，其中 $i=1, \\dots, N$。一组泛化函数（每个准标识符对应一个）被应用于每条记录。\n$r_i \\mapsto r_i^{\\prime} = (g_1(\\text{QID}_{i,1}), g_2(\\text{QID}_{i,2}), g_3(\\text{QID}_{i,3}))$\n具体的泛化函数由参数 $(g_{\\text{zip}}, g_{\\text{date}}, g_{\\text{gen}})$ 定义。\n\n- 邮政编码泛化：对于一个 $5$ 位数字的邮政编码字符串和一个参数 $g_{\\text{zip}} \\in \\{0,2,3,5\\}$，该函数保留前 $g_{\\text{zip}}$ 位数字，并将剩余的 $5 - g_{\\text{zip}}$ 位数字替换为星号 '*'。例如，对于 $g_{\\text{zip}}=3$，邮政编码 \"02139\" 被映射为 \"021**\"。\n\n- 出生日期泛化：对于一个日期字符串 \"YYYY-MM-DD\" 和一个参数 $g_{\\text{date}} \\in \\{\\text{\"day\"},\\text{\"month\"},\\text{\"year\"},\\text{\"decade\"}\\}$，转换如下：\n    - $g_{\\text{date}} = \\text{\"day\"}$: 日期保持不变。\n    - $g_{\\text{date}} = \\text{\"month\"}$: 日期被截断为 \"YYYY-MM\"。\n    - $g_{\\text{date}} = \\text{\"year\"}$: 日期被截断为 \"YYYY\"。\n    - $g_{\\text{date}} = \\text{\"decade\"}$: 年份 YYYY 被映射到其年代，表示为 $\\left\\lfloor \\frac{\\text{YYYY}}{10} \\right\\rfloor \\times 10$，并格式化为类似 \"1980s\" 的字符串。\n\n- 性别泛化：对于一个性别字符串和一个参数 $g_{\\textgen} \\in \\{\\text{\"exact\"},\\text{\"*\"}\\}$，转换如下：\n    - $g_{\\text{gen}} = \\text{\"exact\"}$: 性别保持不变。\n    - $g_{\\text{gen}} = \\text{\"*\"}$: 性别被替换为星号 '*'。\n\n在此阶段之后，原始数据集被转换为一个泛化数据集，其中每条记录 $r_i$ 被其泛化版本 $r_i^{\\prime}$ 替换。\n\n阶段2：迭代抑制\n等价类是一组其泛化准标识符元组完全相同的记录集合。设 $E_j$ 为一个等价类。如果对于所有的 $j$，等价类的大小 $|E_j| \\ge k$，则称该数据集满足 $k$-匿名性。\n\n抑制过程是迭代的。在每次迭代中，算法执行以下步骤：\n1.  将当前的（泛化）记录集划分为等价类。\n2.  计算每个等价类的大小 $|E_j|$。\n3.  识别所有大小 $|E_j|  k$ 的等价类。\n4a. 如果不存在这样的类，则过程终止。数据集现在是 $k$-匿名的。\n4b. 如果存在这样的类，则属于这些类的所有记录都将从数据集中移除（被抑制）。\n5.  使用缩减后的数据集从步骤1开始重复该过程。\n\n这个迭代过程保证会终止，因为数据集中的记录数量是有限的，并且在每一步都是非递增的。\n\n最终计算\n一旦迭代抑制完成，就确定“所达到的 $k$-匿名性级别”。\n- 如果最终的数据集为空（所有记录都被抑制），则达到的级别定义为 $0$。\n- 否则，达到的级别是所有剩余等价类中的最小大小。根据构造，这个值将大于或等于 $k=5$。\n\n针对每个测试用例 $(g_{\\text{zip}}, g_{\\text{date}}, g_{\\text{gen}})$ 的算法：\n1.  用原始的 $30$ 条记录初始化一个记录列表 `current_records`。\n2.  通过将由 $(g_{\\text{zip}}, g_{\\text{date}}, g_{\\text{gen}})$ 定义的泛化函数应用于 `current_records` 中的每条记录，创建一个相应的泛化记录列表 `generalized_records`。\n3.  进入一个循环，直到达到不动点为止：\n    a. 如果 `generalized_records` 为空，则中断循环。\n    b. 对 `generalized_records`进行分组，并计算每个等价类的大小。这可以通过使用哈希映射或 `Counter` 对象来完成，将每个唯一的泛化元组映射到其频率。\n    c. 识别出频率小于 $k=5$ 的“无效”泛化元组集合 `tuples_to_suppress`。\n    d. 如果 `tuples_to_suppress` 为空，则中断循环。\n    e. 通过过滤掉其泛化元组在 `tuples_to_suppress` 中的任何记录，创建一个新的 `generalized_records` 列表。\n4.  循环终止后：\n    a. 如果最终的 `generalized_records` 列表为空，则结果为 $0$。\n    b. 否则，计算剩余唯一元组的频率。结果是这些频率的最小值。\n5.  存储此结果。在处理完所有测试用例后，将结果格式化为逗号分隔的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Computes the achieved k-anonymity for a dataset given various generalization\n    and suppression rules.\n    \"\"\"\n    \n    # Define the dataset as a list of tuples.\n    dataset = [\n        (\"02139\", \"1980-01-15\", \"M\"), (\"02138\", \"1980-02-20\", \"M\"),\n        (\"02139\", \"1980-03-25\", \"M\"), (\"02140\", \"1980-04-05\", \"M\"),\n        (\"02138\", \"1980-05-30\", \"M\"), (\"02139\", \"1980-06-10\", \"M\"),\n        (\"02139\", \"1980-07-12\", \"F\"), (\"02138\", \"1980-08-08\", \"F\"),\n        (\"02140\", \"1980-09-19\", \"F\"), (\"02139\", \"1980-10-21\", \"F\"),\n        (\"10012\", \"1980-02-14\", \"M\"), (\"10011\", \"1980-03-01\", \"M\"),\n        (\"10013\", \"1980-06-18\", \"M\"), (\"10012\", \"1980-07-07\", \"M\"),\n        (\"10011\", \"1980-11-30\", \"M\"), (\"10013\", \"1981-01-09\", \"F\"),\n        (\"10012\", \"1981-03-22\", \"F\"), (\"10011\", \"1981-05-11\", \"F\"),\n        (\"10012\", \"1981-07-27\", \"F\"), (\"10013\", \"1981-09-13\", \"F\"),\n        (\"30303\", \"1979-02-02\", \"M\"), (\"30310\", \"1979-12-12\", \"M\"),\n        (\"30309\", \"1980-01-03\", \"F\"), (\"30303\", \"1980-05-20\", \"F\"),\n        (\"30310\", \"1980-08-28\", \"F\"), (\"02138\", \"1981-02-17\", \"M\"),\n        (\"02139\", \"1981-04-26\", \"M\"), (\"02140\", \"1981-06-06\", \"M\"),\n        (\"02138\", \"1981-08-16\", \"M\"), (\"02139\", \"1981-12-01\", \"M\"),\n    ]\n\n    # Define the generalization parameters for the test suite.\n    test_cases = [\n        (3, \"year\", \"exact\"),\n        (2, \"decade\", \"*\"),\n        (5, \"month\", \"exact\"),\n        (3, \"year\", \"*\"),\n        (0, \"decade\", \"*\"),\n    ]\n    \n    k_anonymity_param = 5\n    results = []\n\n    def generalize_zip(zip_code, g_zip):\n        return zip_code[:g_zip] + '*' * (5 - g_zip)\n\n    def generalize_date(birthdate, g_date):\n        if g_date == \"day\":\n            return birthdate\n        if g_date == \"month\":\n            return birthdate[:7]  # YYYY-MM\n        if g_date == \"year\":\n            return birthdate[:4]  # YYYY\n        if g_date == \"decade\":\n            year = int(birthdate[:4])\n            decade_start = (year // 10) * 10\n            return f\"{decade_start}s\"\n        return birthdate\n\n    def generalize_gender(gender, g_gen):\n        return gender if g_gen == \"exact\" else \"*\"\n\n    for g_zip, g_date, g_gen in test_cases:\n        # Phase 1: Generalization\n        generalized_records = []\n        for zip_code, birthdate, gender in dataset:\n            generalized_zip = generalize_zip(zip_code, g_zip)\n            generalized_date = generalize_date(birthdate, g_date)\n            generalized_gender = generalize_gender(gender, g_gen)\n            generalized_records.append(\n                (generalized_zip, generalized_date, generalized_gender)\n            )\n        \n        # Phase 2: Iterative Suppression\n        current_records = list(generalized_records)\n        while True:\n            if not current_records:\n                break\n            \n            class_counts = Counter(current_records)\n            \n            records_to_suppress = {\n                rec for rec, count in class_counts.items() if count  k_anonymity_param\n            }\n            \n            if not records_to_suppress:\n                # Fixed point reached: no classes violate k-anonymity\n                break\n            \n            current_records = [\n                rec for rec in current_records if rec not in records_to_suppress\n            ]\n\n        # Final Calculation\n        if not current_records:\n            achieved_level = 0\n        else:\n            final_counts = Counter(current_records)\n            achieved_level = min(final_counts.values())\n        \n        results.append(achieved_level)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4831449"}, {"introduction": "消费者生成的健康数据，如家庭血压读数，若要被临床医生或医疗系统有效利用，就必须遵循统一的数据标准。HL7 FHIR（快速医疗保健互操作性资源）正是实现这种数据“通用语言”的现代标准。在这个练习中，你将把一个常见的健康数据点转换为结构化的FHIR资源，并学习如何使用LOINC和SNOMED CT等标准术语集来确保其语义互操作性。[@problem_id:4831487]", "problem": "您正在设计一种算法，用于将消费者生成的生命体征数据转换为适合互操作交换的标准化表示。请使用以下基础且广为接受的事实和定义作为您推导和算法设计的基础，并且除了这些事实之外，不假定任何领域特定的捷径。\n\n1. Health Level Seven (HL7) Fast Healthcare Interoperability Resources (FHIR) 定义了 \"Observation\" 资源，用于表示消费者采集的生命体征。Logical Observation Identifiers Names and Codes (LOINC) 为实验室和临床观察（包括血压的组成部分）提供代码，而 Systematized Nomenclature of Medicine—Clinical Terms (SNOMED CT) 提供临床概念。Unified Code for Units of Measure (UCUM) 为计量单位提供规范代码和体系。\n\n2. 对于血压观察，面板的标准 LOINC 代码是 $85354\\text{-}9$ “Blood pressure panel with all children optional”（血压面板，所有子项可选）。收缩压的标准 LOINC 代码是 $8480\\text{-}6$，舒张压的标准 LOINC 代码是 $8462\\text{-}4$。一个常用的血压 SNOMED CT 概念是 $75367002$ “Blood pressure (observable entity)”（血压（可观察实体））。\n\n3. 对于单位，FHIR 推荐使用 UCUM，其体系为 \"http://unitsofmeasure.org\"。毫米汞柱（millimetres of mercury）的规范 UCUM 代码是 \"mm[Hg]\"。如果输入单位是千帕（kilopascal, kPa），请使用经过充分测试的换算因子 $1\\ \\mathrm{kPa} = 7.50061682704\\ \\mathrm{mmHg}$。从千帕换算为毫米汞柱时，将 $\\mathrm{mmHg}$ 值四舍五入到小数点后 1 位。\n\n4. 一个最小的、结构有效的血压 FHIR Observation 必须包含：resourceType \"Observation\"、status \"final\"、category \"vital-signs\"（其 system 为 \"http://terminology.hl7.org/CodeSystem/observation-category\"，code 为 \"vital-signs\"）、包含 LOINC $85354\\text{-}9$ 以及可选的 SNOMED CT $75367002$ 的 code 元素，以及为存在的测量值（收缩压和/或舒张压）设置的 component 元素，每个 component 元素都带有其各自的 LOINC 代码和一个承载 value、unit、system 和 code 的 valueQuantity。根据面板定义（“all children optional”），允许缺少舒张压。\n\n您的任务是编写一个完整的程序，为每个提供的测试用例，根据上述规则构建一个内部 FHIR Observation JSON 表示，然后计算三个验证标志：\n\n- has_required_loinc_codes: 当且仅当 Observation.code 包含 LOINC 面板代码 $85354\\text{-}9$，并且每个存在的 component 都使用了正确的 LOINC 代码（收缩压为 $8480\\text{-}6$，舒张压为 $8462\\text{-}4$）时，该值为 true。\n- has_required_snomed_code: 当且仅当 Observation.code 包含 SNOMED CT 代码 $75367002$ 时，该值为 true。\n- uses_ucum_units: 当且仅当每个存在的 component 的 valueQuantity 都使用了 UCUM 体系 \"http://unitsofmeasure.org\" 和 UCUM 代码 \"mm[Hg]\" 时，该值为 true。\n\n为每个测试用例实现的转换规则：\n- 输入的血压数值可以是毫米汞柱（mmHg）或千帕（kPa）。如果输入单位是 kPa，请使用公式 $v_{\\mathrm{mmHg}} = v_{\\mathrm{kPa}} \\times 7.50061682704$ 将其转换为 mmHg，并四舍五入到小数点后 1 位。在 JSON 中使用四舍五入后的值。\n- 如果输入单位文本可以明确识别为毫米汞柱（不区分大小写的 \"mmHg\" 或等效写法），则将 valueQuantity.system 设置为 \"http://unitsofmeasure.org\"，valueQuantity.code 设置为 \"mm[Hg]\"，valueQuantity.unit 设置为 \"mmHg\"。\n- 如果输入单位文本可以明确识别为千帕（不区分大小写的 \"kPa\"），则按上述方法进行转换，并将 valueQuantity.system 设置为 \"http://unitsofmeasure.org\"，valueQuantity.code 设置为 \"mm[Hg]\"，valueQuantity.unit 设置为 \"mmHg\"。\n- 如果输入单位文本无法识别为毫米汞柱或千帕，则不设置 valueQuantity.system 或 valueQuantity.code（使其缺失），并将原始单位文本复制到 valueQuantity.unit。这种情况应导致 uses_ucum_units 为 false。\n- 如果缺少舒张压值，则仅输出收缩压 component；否则，输出两个 component。\n- Observation.code 必须始终包含 LOINC 血压面板代码 $85354\\text{-}9$；仅当测试用例指示包含 SNOMED 时，才包含 SNOMED CT 代码 $75367002$。\n\n测试套件：\n为以下五个用例提供结果。每个用例的输入元组为 (systolic_value, diastolic_value_or_null, unit_label_string, include_snomed_boolean)：\n\n1. 用例 A：收缩压 $130$，舒张压 $82$，单位 \"mmHg\"，包含 SNOMED 为 true。\n2. 用例 B：收缩压 $118$，舒张压 null，单位 \"mmHg\"，包含 SNOMED 为 true。\n3. 用例 C：收缩压 $16.0$，舒张压 $10.7$，单位 \"kPa\"，包含 SNOMED 为 true。应用到 $\\mathrm{mmHg}$ 的转换并四舍五入到小数点后 1 位。\n4. 用例 D：收缩压 $140$，舒张压 $95$，单位 \"mmHg\"，包含 SNOMED 为 false。\n5. 用例 E：收缩压 $125$，舒张压 $79$，单位 \"unknown\"，包含 SNOMED 为 true。单位无法识别，不得设置 UCUM system 和 code。\n\n输出规范：\n- 对每个用例，计算一个列表 [has_required_loinc_codes, has_required_snomed_code, uses_ucum_units]。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素本身是对应一个用例的三个布尔值的列表，顺序为 A、B、C、D、E。例如：[[true_case_A_loinc, true_case_A_snomed, true_case_A_ucum],...]。\n- 所有布尔值必须以 Python 风格的字面量 True 或 False 打印。\n- 不允许用户输入；须严格按照上述规定对测试用例进行硬编码。\n\n不涉及角度单位。唯一的物理单位换算是千帕和毫米汞柱之间的换算；在 FHIR Observation JSON 中，内部存储值在转换后以毫米汞柱表示，并在适用时四舍五入到 $\\mathrm{mmHg}$ 的小数点后 1 位。", "solution": "该问题是有效的，因为它在科学上基于已建立的健康信息学标准（HL7 FHIR、LOINC、SNOMED CT、UCUM），问题陈述清晰，规则具有确定性，语言客观。它提出了一个明确定义的数据转换和验证任务，代表了消费者健康信息学领域的典型挑战。\n\n解决方案需要设计一个算法，处理消费者生成的血压读数，将其转换为模仿 FHIR Observation 资源的结构化格式，然后根据一组规则验证该结构。每个测试用例的处理过程可分为两个主要阶段：内部数据结构的构建和该结构的验证。\n\n**阶段 1：构建 FHIR Observation 表示**\n\n对于每个输入元组 `(systolic_value, diastolic_value_or_null, unit_label_string, include_snomed_boolean)`，我们构建一个内部字典来表示 FHIR Observation 资源的关键部分。\n\n1.  **观察层面的编码：**\n    `Observation.code` 元素必须包含标识观察面板的编码。\n    -   “Blood pressure panel”（血压面板）的 LOINC 代码 $85354\\text{-}9$ 总是被包含。该编码对象将具有 `system: \"http://loinc.org\"` 和 `code: \"85354-9\"`。\n    -   如果 `include_snomed_boolean` 标志为 true，则 “Blood pressure (observable entity)”（血压（可观察实体））的 SNOMED CT 代码 $75367002$ 也被包含。该编码对象将具有 `system: \"http://snomed.info/sct\"` 和 `code: \"75367002\"`。\n\n2.  **单位和数值处理：**\n    必须根据提供的 `unit_label_string` 处理输入值。目标是将测量值标准化为毫米汞柱（mmHg），并使用 Unified Code for Units of Measure (UCUM) 来表示它们。\n    -   换算因子为 $1\\ \\mathrm{kPa} = 7.50061682704\\ \\mathrm{mmHg}$。\n    -   如果输入单位被识别为千帕（例如，不区分大小写的 \"kPa\"），则使用公式 $v_{\\mathrm{mmHg}} = v_{\\mathrm{kPa}} \\times 7.50061682704$ 将数值转换为 mmHg。结果四舍五入到小数点后 1 位。然后，component 的 `valueQuantity` 将使用 UCUM 标准表示：`system: \"http://unitsofmeasure.org\"`，`code: \"mm[Hg]\"` 和 `unit: \"mmHg\"`。\n    -   如果输入单位被识别为毫米汞柱（例如，不区分大小写的 \"mmHg\"），则无需进行数值转换。`valueQuantity` 将填充与 kPa 情况相同的 UCUM 信息。\n    -   如果单位无法识别，则按原样使用数值，并且创建的 `valueQuantity` 不包含 `system` 和 `code` 字段。原始的 `unit_label_string` 被复制到 `unit` 字段。\n\n3.  **Component 构建：**\n    血压面板由用于收缩压和舒张压测量的 component 组成。\n    -   总是会为收缩压创建一个 component。其 `code` 元素使用 LOINC 代码 $8480\\text{-}6$ 填充。其 `valueQuantity` 使用上一步处理过的值和单位信息填充。\n    -   如果 `diastolic_value_or_null` 不为 null，则也会为舒张压创建一个 component。其 `code` 设置为 LOINC 代码 $8462\\text{-}4$，其 `valueQuantity` 也以类似方式填充。如果舒张压值为 null，则省略此 component，这与面板定义“all children optional”（所有子项可选）一致。\n\n**阶段 2：验证**\n\n为给定测试用例构建内部表示后，通过检查其结构来计算三个布尔标志。\n\n1.  **`has_required_loinc_codes`**: 当且仅当满足以下所有条件时，此标志为 `true`：\n    -   `Observation.code` 包含 LOINC 面板代码 $85354\\text{-}9$。\n    -   收缩压 component 的 `code` 包含 LOINC 代码 $8480\\text{-}6$。\n    -   如果存在舒张压 component，其 `code` 包含 LOINC 代码 $8462\\text{-}4$。\n\n2.  **`has_required_snomed_code`**: 当且仅当 `Observation.code` 包含 SNOMED CT 代码 $75367002$ 时，此标志为 `true`。\n\n3.  **`uses_ucum_units`**: 当且仅当 Observation 中存在的每个 component 都具有一个包含 `system: \"http://unitsofmeasure.org\"` 和 `code: \"mm[Hg]\"` 的 `valueQuantity` 时，此标志为 `true`。如果不存在任何 component，此条件将空泛地为真，但我们的逻辑总是至少生成一个收缩压 component。\n\n该算法将遍历五个指定的测试用例，执行这些构建和验证步骤，并为每个用例收集生成的包含三个布尔值的列表。最终输出将是一个表示这些列表的列表的格式化字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    # Define constants based on the problem statement.\n    KPA_TO_MMHG = 7.50061682704\n    LOINC_SYSTEM = \"http://loinc.org\"\n    SNOMED_SYSTEM = \"http://snomed.info/sct\"\n    UCUM_SYSTEM = \"http://unitsofmeasure.org\"\n    OBS_CATEGORY_SYSTEM = \"http://terminology.hl7.org/CodeSystem/observation-category\"\n\n    LOINC_BP_PANEL = \"85354-9\"\n    LOINC_SYS = \"8480-6\"\n    LOINC_DIA = \"8462-4\"\n    SNOMED_BP = \"75367002\"\n    UCUM_MMHG_CODE = \"mm[Hg]\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (systolic_value, diastolic_value_or_null, unit_label_string, include_snomed_boolean)\n        (130, 82, \"mmHg\", True),    # Case A\n        (118, None, \"mmHg\", True),  # Case B\n        (16.0, 10.7, \"kPa\", True),  # Case C\n        (140, 95, \"mmHg\", False),   # Case D\n        (125, 79, \"unknown\", True), # Case E\n    ]\n\n    def process_case(systolic_val, diastolic_val, unit_str, include_snomed):\n        \"\"\"\n        Constructs a FHIR-like observation and validates it for a single case.\n        \"\"\"\n        \n        # 1. Construct the internal FHIR-like representation\n        observation = {\n            \"resourceType\": \"Observation\",\n            \"status\": \"final\",\n            \"category\": [{\n                \"coding\": [{\n                    \"system\": OBS_CATEGORY_SYSTEM,\n                    \"code\": \"vital-signs\"\n                }]\n            }],\n            \"code\": {\n                \"coding\": [{\n                    \"system\": LOINC_SYSTEM,\n                    \"code\": LOINC_BP_PANEL\n                }]\n            },\n            \"component\": []\n        }\n        \n        # Add SNOMED code if required\n        if include_snomed:\n            observation[\"code\"][\"coding\"].append({\n                \"system\": SNOMED_SYSTEM,\n                \"code\": SNOMED_BP\n            })\n\n        # Process units and values\n        unit_lower = unit_str.lower()\n        value_quantity_system = None\n        value_quantity_code = None\n        value_quantity_unit = unit_str\n\n        processed_sys = systolic_val\n        processed_dia = diastolic_val\n\n        if unit_lower == 'mmhg':\n            value_quantity_system = UCUM_SYSTEM\n            value_quantity_code = UCUM_MMHG_CODE\n            value_quantity_unit = \"mmHg\"\n        elif unit_lower == 'kpa':\n            processed_sys = round(systolic_val * KPA_TO_MMHG, 1)\n            if diastolic_val is not None:\n                processed_dia = round(diastolic_val * KPA_TO_MMHG, 1)\n            value_quantity_system = UCUM_SYSTEM\n            value_quantity_code = UCUM_MMHG_CODE\n            value_quantity_unit = \"mmHg\"\n            \n        # Add systolic component\n        systolic_component = {\n            \"code\": {\"coding\": [{\"system\": LOINC_SYSTEM, \"code\": LOINC_SYS}]},\n            \"valueQuantity\": {\"value\": processed_sys, \"unit\": value_quantity_unit}\n        }\n        if value_quantity_system and value_quantity_code:\n            systolic_component[\"valueQuantity\"][\"system\"] = value_quantity_system\n            systolic_component[\"valueQuantity\"][\"code\"] = value_quantity_code\n        observation[\"component\"].append(systolic_component)\n\n        # Add diastolic component if present\n        if diastolic_val is not None:\n            diastolic_component = {\n                \"code\": {\"coding\": [{\"system\": LOINC_SYSTEM, \"code\": LOINC_DIA}]},\n                \"valueQuantity\": {\"value\": processed_dia, \"unit\": value_quantity_unit}\n            }\n            if value_quantity_system and value_quantity_code:\n                diastolic_component[\"valueQuantity\"][\"system\"] = value_quantity_system\n                diastolic_component[\"valueQuantity\"][\"code\"] = value_quantity_code\n            observation[\"component\"].append(diastolic_component)\n\n        # 2. Perform validation checks\n\n        # Check for required LOINC codes\n        panel_loinc_ok = any(\n            c.get(\"system\") == LOINC_SYSTEM and c.get(\"code\") == LOINC_BP_PANEL\n            for c in observation[\"code\"][\"coding\"]\n        )\n        sys_loinc_ok = any(\n            c.get(\"system\") == LOINC_SYSTEM and c.get(\"code\") == LOINC_SYS\n            for c in observation[\"component\"][0][\"code\"][\"coding\"]\n        )\n        dia_loinc_ok = True\n        if len(observation[\"component\"]) > 1:\n            dia_loinc_ok = any(\n                c.get(\"system\") == LOINC_SYSTEM and c.get(\"code\") == LOINC_DIA\n                for c in observation[\"component\"][1][\"code\"][\"coding\"]\n            )\n        has_required_loinc_codes = panel_loinc_ok and sys_loinc_ok and dia_loinc_ok\n\n        # Check for required SNOMED code\n        has_required_snomed_code = any(\n            c.get(\"system\") == SNOMED_SYSTEM and c.get(\"code\") == SNOMED_BP\n            for c in observation[\"code\"][\"coding\"]\n        )\n\n        # Check for UCUM units\n        uses_ucum_units = all(\n            comp[\"valueQuantity\"].get(\"system\") == UCUM_SYSTEM and\n            comp[\"valueQuantity\"].get(\"code\") == UCUM_MMHG_CODE\n            for comp in observation[\"component\"]\n        )\n\n        return [has_required_loinc_codes, has_required_snomed_code, uses_ucum_units]\n\n    results = []\n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4831487"}]}