{"hands_on_practices": [{"introduction": "在利用电子健康记录（EHR）数据进行研究时，一个基本但至关重要的步骤是数据协调。由于数据可能来自不同的医疗机构、实验室或仪器，像血清肌酐这样的关键实验室测量值可能以不同的单位（如 $mg/dL$ 或 $\\mu mol/L$）记录。本练习将通过一个计算估算肾小球滤过率（eGFR）的真实场景，让您亲身体验单位协调的重要性，并量化忽略单位差异可能导致的巨大计算偏差。[@problem_id:4862785]", "problem": "电子健康记录 (EHR) 数据经常包含在不同时间、地点或仪器上以不同单位记录的实验室测量值。为了生成关于肾功能的真实世界证据，这些测量值必须在应用临床验证的方程之前统一到通用单位。本问题要求您实现单位统一，并使用慢性肾脏病流行病学合作组织 (CKD-EPI) 2021 年基于肌酐的方程计算估算肾小球滤过率 (eGFR)，然后量化单位统一对分布的影响。\n\n基本原理：\n- 质量浓度和物质的量浓度之间的测量单位转换是一条经过充分检验的规则。对于血清肌酐，公认的换算关系是 $1\\ \\mathrm{mg/dL} = 88.4\\ \\mathrm{\\mu mol/L}$，这意味着 $$\\mathrm{mg/dL} = \\frac{\\mathrm{\\mu mol/L}}{88.4}.$$\n- CKD-EPI 方程是一个经过充分检验的临床公式，它将血清肌酐、年龄和性别映射到一个以 $\\mathrm{mL/min/1.73\\,m^2}$ 为单位的 eGFR；使用该公式时，血清肌酐必须以 $\\mathrm{mg/dL}$ 为单位。\n- 两个经验分布之间的柯尔莫哥洛夫-斯米尔诺夫 (Kolmogorov–Smirnov, KS) 距离定义为 $$D = \\sup_x \\left|F_n(x) - G_m(x)\\right|,$$ 其中 $F_n$ 和 $G_m$ 分别是大小为 $n$ 和 $m$ 的样本的经验累积分布函数。\n\n任务：\n- 对于每个数据集，计算两个版本的 eGFR（单位：$\\mathrm{mL/min/1.73\\,m^2}$）：\n    1. 一个“朴素”版本，其中每个记录的肌酐值都被视为以 $\\mathrm{mg/dL}$ 为单位，无论其记录的单位是什么。\n    2. 一个“统一”版本，其中以 $\\mathrm{\\mu mol/L}$ 记录的值在使用 $\\mathrm{mg/dL} = \\mathrm{\\mu mol/L} / 88.4$ 转换为 $\\mathrm{mg/dL}$ 后再计算 eGFR。\n- 使用适用于成人的 CKD-EPI 2021 肌酐方程，不含种族系数。按照该方程的定义，实现标准的性别特异性常数和年龄依赖性。血清肌酐必须以 $\\mathrm{mg/dL}$ 为单位处理。\n- 对于每个数据集，计算以下汇总统计数据以比较“朴素”和“统一”的 eGFR 分布：\n    1. 平均 eGFR 的差异，定义为 $\\overline{eGFR}_{\\text{naive}} - \\overline{eGFR}_{\\text{harmonized}}$（以 $\\mathrm{mL/min/1.73\\,m^2}$ 表示）。\n    2. eGFR 中位数的差异，定义为 $\\operatorname{median}(eGFR_{\\text{naive}}) - \\operatorname{median}(eGFR_{\\text{harmonized}})$（以 $\\mathrm{mL/min/1.73\\,m^2}$ 表示）。\n    3. “朴素”和“统一”eGFR 样本之间的柯尔莫哥洛夫-斯米尔诺夫距离 $D$。\n\n角度单位不适用。所有 eGFR 量均以 $\\mathrm{mL/min/1.73\\,m^2}$ 表示，并将数值输出报告为十进制浮点数。将最终输出中的每个报告浮点数四舍五入到 $4$ 位小数。\n\n输入数据（嵌入程序中；无外部输入）：\n每条记录是一个元组 $(\\text{年龄（岁）}, \\text{性别}, \\text{血清肌酐值}, \\text{单位})$，其中性别为 $\\text{\"F\"}$（女性）或 $\\text{\"M\"}$（男性）。测试套件包含三个数据集：\n\n- 数据集 $1$（单位混合，典型值）：\n    - $(65,\\ \\text{\"F\"},\\ 1.1,\\ \\text{\"mg/dL\"})$\n    - $(50,\\ \\text{\"M\"},\\ 90,\\ \\text{\"\\mu mol/L\"})$\n    - $(80,\\ \\text{\"F\"},\\ 1.8,\\ \\text{\"mg/dL\"})$\n    - $(40,\\ \\text{\"M\"},\\ 75,\\ \\text{\"\\mu mol/L\"})$\n    - $(30,\\ \\text{\"F\"},\\ 0.7,\\ \\text{\"mg/dL\"})$\n    - $(70,\\ \\text{\"M\"},\\ 110,\\ \\text{\"\\mu mol/L\"})$\n    - $(55,\\ \\text{\"F\"},\\ 95,\\ \\text{\"\\mu mol/L\"})$\n    - $(45,\\ \\text{\"M\"},\\ 1.3,\\ \\text{\"mg/dL\"})$\n- 数据集 $2$（所有值单位已为 $\\mathrm{mg/dL}$）：\n    - $(18,\\ \\text{\"M\"},\\ 0.9,\\ \\text{\"mg/dL\"})$\n    - $(22,\\ \\text{\"F\"},\\ 0.6,\\ \\text{\"mg/dL\"})$\n    - $(90,\\ \\text{\"M\"},\\ 2.5,\\ \\text{\"mg/dL\"})$\n    - $(75,\\ \\text{\"F\"},\\ 1.2,\\ \\text{\"mg/dL\"})$\n    - $(65,\\ \\text{\"M\"},\\ 1.0,\\ \\text{\"mg/dL\"})$\n    - $(50,\\ \\text{\"F\"},\\ 0.8,\\ \\text{\"mg/dL\"})$\n- 数据集 $3$（所有值单位均为 $\\mathrm{\\mu mol/L}$）：\n    - $(35,\\ \\text{\"F\"},\\ 80,\\ \\text{\"\\mu mol/L\"})$\n    - $(55,\\ \\text{\"M\"},\\ 120,\\ \\text{\"\\mu mol/L\"})$\n    - $(85,\\ \\text{\"F\"},\\ 200,\\ \\text{\"\\mu mol/L\"})$\n    - $(45,\\ \\text{\"M\"},\\ 70,\\ \\text{\"\\mu mol/L\"})$\n    - $(60,\\ \\text{\"F\"},\\ 100,\\ \\text{\"\\mu mol/L\"})$\n    - $(28,\\ \\text{\"M\"},\\ 60,\\ \\text{\"\\mu mol/L\"})$\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[$数据集 $1$ 的平均值差异，数据集 $1$ 的中位数差异，数据集 $1$ 的 KS 距离，数据集 $2$ 的平均值差异，数据集 $2$ 的中位数差异，数据集 $2$ 的 KS 距离，数据集 $3$ 的平均值差异，数据集 $3$ 的中位数差异，数据集 $3$ 的 KS 距离$]$。\n将每个浮点数四舍五入到 $4$ 位小数。数值代表平均值和中位数差异（单位 $\\mathrm{mL/min/1.73\\,m^2}$）以及 KS 距离 $D$（无单位十进制数）。", "solution": "该问题要求实现一个数据处理流程，以证明在使用电子健康记录 (EHR) 数据进行临床计算时单位统一的重要性。该流程包括三个关键阶段：数据统一、临床模型的应用和统计比较。\n\n首先，我们必须定义用于估算肾小球滤过率 (eGFR) 的计算模型。问题指定使用慢性肾脏病流行病学合作组织 (CKD-EPI) 2021 年基于肌酐的方程，这是评估成人肾功能的现行标准。该方程将血清肌酐 ($S_{Cr}$)、年龄和性别与 eGFR 相关联。一个关键的先决条件是血清肌酐的单位必须是毫克每分升 ($\\mathrm{mg/dL}$)。2021 年的公式，不包括基于种族的系数，表示为：\n$$ eGFR = 142 \\times \\min\\left(\\frac{S_{Cr}}{k}, 1\\right)^\\alpha \\times \\max\\left(\\frac{S_{Cr}}{k}, 1\\right)^{-1.200} \\times 0.9938^{Age} \\times F_{sex} $$\n参数 $k$、$\\alpha$ 和 $F_{sex}$ 与性别相关。对于女性，$k = 0.7$，$\\alpha = -0.241$，性别特异性因子 $F_{sex} = 1.012$。对于男性，$k = 0.9$，$\\alpha = -0.302$，且 $F_{sex} = 1.0$。这个单一、紧凑的公式正确地捕捉了原始 CKD-EPI 定义的分段性质。\n\n其次，我们处理单位统一的核心任务。输入数据可能包含两种不同单位的血清肌酐值：质量浓度 ($\\mathrm{mg/dL}$) 和物质的量浓度 ($\\mathrm{\\mu mol/L}$)。要使用 CKD-EPI 方程，所有值都必须以 $\\mathrm{mg/dL}$ 为单位。问题提供了标准换算因子：$1\\ \\mathrm{mg/dL} = 88.4\\ \\mathrm{\\mu mol/L}$。因此，一个以 $\\mathrm{\\mu mol/L}$ 给出的肌酐值 $S_{Cr, \\mu mol/L}$ 可以使用以下公式转换为以 $\\mathrm{mg/dL}$ 为单位的 $S_{Cr, mg/dL}$：\n$$ S_{Cr, mg/dL} = \\frac{S_{Cr, \\mu mol/L}}{88.4} $$\n问题要求计算两组 eGFR 值。“统一”组是通过首先将此转换应用于任何以 $\\mathrm{\\mu mol/L}$ 记录的肌酐值来计算的，以确保 CKD-EPI 方程的所有输入都是正确的。“朴素”组的计算方式是忽略注明的单位，将所有数值型肌酐值都当作已经是以 $\\mathrm{mg/dL}$ 为单位来处理。这样做的目的是模拟一种常见的数据处理错误并量化其影响。\n\n第三，我们必须量化“朴素”和“统一”eGFR 值分布之间的差异。指定了三种统计度量：\n1.  平均值差异：$\\Delta_{\\text{mean}} = \\overline{eGFR}_{\\text{naive}} - \\overline{eGFR}_{\\text{harmonized}}$。非零值表示由单位错误引起的分布集中趋势的系统性偏移。\n2.  中位数差异：$\\Delta_{\\text{median}} = \\operatorname{median}(eGFR_{\\text{naive}}) - \\operatorname{median}(eGFR_{\\text{harmonized}})$。这提供了一个稳健的集中趋势偏移度量，比平均值对异常值更不敏感。\n3.  柯尔莫哥洛夫-斯米尔诺夫 (KS) 距离：$D = \\sup_x |F_{\\text{naive}}(x) - F_{\\text{harmonized}}(x)|$，其中 $F$ 表示样本的经验累积分布函数 (ECDF)。KS 距离测量两个样本 ECDF 之间的最大绝对差，为它们分布的差异提供了一个全局度量。$D=0$ 的值意味着分布相同，而 $D=1$ 则意味着分布之间没有重叠。\n\n算法通过遍历每个提供的数据集来进行。对于每个数据集，我们遍历每条患者记录。对于每位患者，我们计算两个 eGFR 值：一个使用“朴素”肌酐值，另一个使用“统一”肌酐值。处理完一个数据集中的所有患者后，我们收集得到的两组 eGFR 值。然后，我们使用标准的数值库函数来计算每组的平均值、每组的中位数以及两组之间的 KS 距离。最后，我们计算所需的差异并格式化所有结果以供输出。对于数据集 $2$，其中所有单位都已是 $\\mathrm{mg/dL}$，“朴素”和“统一”的计算是相同的，正确地得出差异和 KS 距离为 $0$。对于数据集 $3$，其中所有单位都是 $\\mathrm{\\mu mol/L}$，“朴素”计算使用的肌酐值大约是正确值的 $88.4$ 倍，导致 eGFR 值极低，不符合生理学常理，并与统一后的结果存在巨大差异，从而导致 KS 距离为 $1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import ks_2samp\n\ndef solve():\n    \"\"\"\n    Solves the eGFR harmonization problem by calculating naive and harmonized eGFR values\n    and comparing their distributions for three datasets.\n    \"\"\"\n\n    # Define the datasets as specified in the problem statement.\n    datasets = [\n        # Dataset 1 (mixed units)\n        [\n            (65, \"F\", 1.1, \"mg/dL\"),\n            (50, \"M\", 90, \"μmol/L\"),\n            (80, \"F\", 1.8, \"mg/dL\"),\n            (40, \"M\", 75, \"μmol/L\"),\n            (30, \"F\", 0.7, \"mg/dL\"),\n            (70, \"M\", 110, \"μmol/L\"),\n            (55, \"F\", 95, \"μmol/L\"),\n            (45, \"M\", 1.3, \"mg/dL\"),\n        ],\n        # Dataset 2 (all mg/dL)\n        [\n            (18, \"M\", 0.9, \"mg/dL\"),\n            (22, \"F\", 0.6, \"mg/dL\"),\n            (90, \"M\", 2.5, \"mg/dL\"),\n            (75, \"F\", 1.2, \"mg/dL\"),\n            (65, \"M\", 1.0, \"mg/dL\"),\n            (50, \"F\", 0.8, \"mg/dL\"),\n        ],\n        # Dataset 3 (all μmol/L)\n        [\n            (35, \"F\", 80, \"μmol/L\"),\n            (55, \"M\", 120, \"μmol/L\"),\n            (85, \"F\", 200, \"μmol/L\"),\n            (45, \"M\", 70, \"μmol/L\"),\n            (60, \"F\", 100, \"μmol/L\"),\n            (28, \"M\", 60, \"μmol/L\"),\n        ],\n    ]\n\n    def ckd_epi_2021(scr_mgdl, age, sex):\n        \"\"\"\n        Calculates eGFR using the CKD-EPI 2021 creatinine equation.\n        \n        Args:\n            scr_mgdl (float): Serum creatinine in mg/dL.\n            age (int): Age in years.\n            sex (str): \"F\" for female, \"M\" for male.\n\n        Returns:\n            float: Estimated GFR in mL/min/1.73m^2.\n        \"\"\"\n        if sex == \"F\":\n            k = 0.7\n            alpha = -0.241\n            sex_factor = 1.012\n        else:  # sex == \"M\"\n            k = 0.9\n            alpha = -0.302\n            sex_factor = 1.0\n\n        scr_over_k = scr_mgdl / k\n        min_term = min(scr_over_k, 1.0)**alpha\n        max_term = max(scr_over_k, 1.0)**(-1.200)\n        age_term = 0.9938**age\n        egfr = 142 * min_term * max_term * age_term * sex_factor\n        return egfr\n\n    final_results = []\n    \n    # Conversion factor from μmol/L to mg/dL is division by 88.4\n    CONVERSION_FACTOR = 88.4\n\n    for dataset in datasets:\n        egfr_naive = []\n        egfr_harmonized = []\n\n        for age, sex, scr_value, unit in dataset:\n            # 1. Naive eGFR calculation\n            # Treats all creatinine values as if they were in mg/dL.\n            naive_egfr_val = ckd_epi_2021(scr_value, age, sex)\n            egfr_naive.append(naive_egfr_val)\n\n            # 2. Harmonized eGFR calculation\n            # Converts μmol/L to mg/dL before calculation.\n            if unit == \"μmol/L\":\n                harmonized_scr = scr_value / CONVERSION_FACTOR\n            else: # unit == \"mg/dL\"\n                harmonized_scr = scr_value\n            \n            harmonized_egfr_val = ckd_epi_2021(harmonized_scr, age, sex)\n            egfr_harmonized.append(harmonized_egfr_val)\n        \n        # Convert lists to NumPy arrays for vectorized operations\n        egfr_naive_arr = np.array(egfr_naive)\n        egfr_harmonized_arr = np.array(egfr_harmonized)\n\n        # 3. Compute summary statistics\n        # Difference in means\n        mean_diff = np.mean(egfr_naive_arr) - np.mean(egfr_harmonized_arr)\n        \n        # Difference in medians\n        median_diff = np.median(egfr_naive_arr) - np.median(egfr_harmonized_arr)\n        \n        # Kolmogorov-Smirnov distance\n        ks_distance = ks_2samp(egfr_naive_arr, egfr_harmonized_arr).statistic\n        \n        final_results.extend([mean_diff, median_diff, ks_distance])\n\n    # Format the final output string as required\n    # Each float must be rounded to 4 decimal places.\n    formatted_results = [f\"{val:.4f}\" for val in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4862785"}, {"introduction": "从观察性EHR数据中得出因果结论充满了挑战，其中最微妙的陷阱之一是“不朽时间偏倚”（immortal time bias）。当错误地处理随时间变化的治疗暴露时，这种偏倚便会产生，常常导致对治疗效果的错误高估。本练习将指导您计算两种不同方法下的风险比（hazard ratio），直观地揭示不朽时间偏倚是如何产生的，以及如何通过正确的时间依赖性分析来避免它，这是生成可靠真实世界证据的核心技能。[@problem_id:4862751]", "problem": "给定一个由电子健康记录 (EHR) 数据代表的队列，其中每个个体都有一个基线时间 $t=0$ 月，一个治疗起始时间 $\\tau_i$（如果个体从未开始治疗，则该值可能为 $\\infty$），一个从基线到事件发生或删失的随访时间 $y_i$（以月为单位），以及一个二元事件指示符 $\\delta_i \\in \\{0,1\\}$，其中 $\\delta_i=1$ 表示在时间 $y_i$ 发生事件，$\\delta_i=0$ 表示在时间 $y_i$ 发生删失。假设在暴露状态为条件的情况下，一个组内的风险在时间上近似恒定，因此任何暴露组 $g \\in \\{0,1\\}$ 的经验风险可通过 $\\hat{h}_g = E_g / T_g$ 来估计，其中 $E_g$ 是在组 $g$ 中观察到的事件总数，$T_g$ 是个体在组 $g$ 期间累积的总人时（以月为单位）。将风险比定义为 $\\widehat{HR} = \\hat{h}_1 / \\hat{h}_0$。你必须计算两次 $\\widehat{HR}$：第一次在时间固定暴露定义下，第二次在时间更新暴露定义下，然后量化在时间固定暴露定义下由“不朽时间”（immortal time）引入的偏倚。\n\n时间固定暴露定义根据个体在随访期间是否曾开始治疗来对其进行分类。具体来说，对于时间固定分析，如果 $\\tau_i  \\infty$，则将个体分配到暴露组 $g=1$；如果 $\\tau_i = \\infty$，则分配到未暴露组 $g=0$。对于此时间固定分析，计算 $T_1^{\\mathrm{fixed}}$ 为所有 $\\tau_i  \\infty$ 的个体的 $y_i$ 之和，计算 $T_0^{\\mathrm{fixed}}$ 为所有 $\\tau_i = \\infty$ 的个体的 $y_i$ 之和。计算 $E_1^{\\mathrm{fixed}}$ 为所有 $\\tau_i  \\infty$ 的个体的 $\\delta_i$ 之和，计算 $E_0^{\\mathrm{fixed}}$ 为所有 $\\tau_i = \\infty$ 的个体的 $\\delta_i$ 之和。那么，时间固定的风险比为 $\\widehat{HR}_{\\mathrm{fixed}} = \\left(E_1^{\\mathrm{fixed}} / T_1^{\\mathrm{fixed}}\\right) \\big/ \\left(E_0^{\\mathrm{fixed}} / T_0^{\\mathrm{fixed}}\\right)$。\n\n时间更新暴露定义将暴露视为一个随时间变化的协变量。对于一个具有有限 $\\tau_i$ 的个体，未暴露人时为区间 $[0, \\min(y_i,\\tau_i))$，如果 $\\tau_i  y_i$，则暴露人时为区间 $[\\tau_i, y_i)$。对于一个 $\\tau_i = \\infty$ 的个体，所有的人时 $[0, y_i)$ 均为未暴露。将事件分配到紧邻 $y_i$ 之前的暴露状态；如果 $\\tau_i = y_i$，则将事件计为未暴露。形式上，通过对所有个体求和上述相应的区间长度（以月为单位）来计算 $T_0^{\\mathrm{upd}}$ 和 $T_1^{\\mathrm{upd}}$，并使用以下规则将事件分配到 $y_i$ 之前激活的状态来计算 $E_0^{\\mathrm{upd}}$ 和 $E_1^{\\mathrm{upd}}$：如果 $\\delta_i=1$ 且 $y_i \\le \\tau_i$，则将 $E_0^{\\mathrm{upd}}$ 增加 $1$；如果 $\\delta_i=1$ 且 $y_i > \\tau_i$，则将 $E_1^{\\mathrm{upd}}$ 增加 $1$；如果 $\\delta_i=0$，则不增加任何 $E_g$。那么，时间更新的风险比为 $\\widehat{HR}_{\\mathrm{upd}} = \\left(E_1^{\\mathrm{upd}} / T_1^{\\mathrm{upd}}\\right) \\big/ \\left(E_0^{\\mathrm{upd}} / T_0^{\\mathrm{upd}}\\right)$。\n\n为量化不朽时间偏倚，计算相对偏倚 $b = \\left(\\widehat{HR}_{\\mathrm{fixed}} - \\widehat{HR}_{\\mathrm{upd}}\\right) / \\widehat{HR}_{\\mathrm{upd}}$，以小数形式表示。所有时间量必须以月为单位处理，风险比和偏倚是无单位的。你的程序必须输出每个风险比（四舍五入到 $3$ 位小数）和每个偏倚（四舍五入到 $3$ 位小数）。\n\n使用以下队列测试套件。每个队列是一个由元组 $(\\tau_i, y_i, \\delta_i)$ 表示的个体列表，其中所有时间单位为月，$\\tau_i = \\infty$ 表示从未接受治疗，$y_i$ 是事件或删失时间，$\\delta_i \\in \\{0,1\\}$ 是事件指示符。\n\n测试用例 $1$（理想路径，混合的起始时间，部分删失）：\n- 患者：$\\left[(2, 10, 1), (5, 12, 0), (\\infty, 8, 1), (0, 9, 1), (\\infty, 7, 0), (3, 6, 1)\\right]$。\n\n测试用例 $2$（治疗起始较晚，产生大量不朽时间，两组均有事件）：\n- 患者：$\\left[(9, 12, 1), (10, 12, 0), (11, 14, 1), (\\infty, 6, 1), (\\infty, 12, 0)\\right]$。\n\n测试用例 $3$（事件恰好发生在起始边界，立即起始者和从未治疗者）：\n- 患者：$\\left[(5, 5, 1), (0, 8, 0), (4, 9, 1), (\\infty, 7, 1), (\\infty, 10, 0)\\right]$。\n\n测试用例 $4$（早期起始者和从未治疗者混合）：\n- 患者：$\\left[(0, 4, 1), (1, 6, 0), (2, 3, 1), (\\infty, 5, 1), (\\infty, 6, 0)\\right]$。\n\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，将 4 个测试用例的三元组 $\\left[\\widehat{HR}_{\\mathrm{fixed}}, \\widehat{HR}_{\\mathrm{upd}}, b\\right]$ 按顺序展开。例如，输出格式必须为 $\\left[\\widehat{HR}_{\\mathrm{fixed}}^{(1)}, \\widehat{HR}_{\\mathrm{upd}}^{(1)}, b^{(1)}, \\widehat{HR}_{\\mathrm{fixed}}^{(2)}, \\widehat{HR}_{\\mathrm{upd}}^{(2)}, b^{(2)}, \\widehat{HR}_{\\mathrm{fixed}}^{(3)}, \\widehat{HR}_{\\mathrm{upd}}^{(3)}, b^{(3)}, \\widehat{HR}_{\\mathrm{fixed}}^{(4)}, \\widehat{HR}_{\\mathrm{upd}}^{(4)}, b^{(4)}\\right]$，所有值均四舍五入到 $3$ 位小数。时间必须以月为单位处理，风险比和偏倚是无单位的浮点数。", "solution": "用户提供了一个在生物统计学和流行病学原理上有科学依据的问题，具体涉及生存分析和一种被称为“不朽时间偏倚”的方法学伪迹。该问题陈述清晰，为所有计算提供了明确的数学定义和完整的数据。没有矛盾、歧义或事实错误。因此，该问题是有效的，将提供一个解决方案。\n\n此问题的核心在于比较两种在治疗起始延迟的队列研究中定义暴露的不同方法。目标是计算每种定义下的风险比（$\\widehat{HR}$）并量化其差异，从而阐释不朽时间偏倚的概念。\n\n**基本概念**\n\n风险率 $h(t)$ 表示在时间 $t$ 之前存活的条件下，在时间 $t$ 发生事件的瞬时风险。在本问题中，我们假设风险在特定的暴露组 $g \\in \\{0, 1\\}$ 内是恒定的，其中 $g=0$ 表示未暴露状态，$g=1$ 表示暴露状态。这个假设允许我们凭经验估计风险为：\n$$\n\\hat{h}_g = \\frac{E_g}{T_g}\n$$\n其中 $E_g$ 是在组 $g$ 中观察到的事件总数，$T_g$ 是个体在组 $g$ 期间累积的总人时（此处为人时-月）。\n\n风险比（$\\widehat{HR}$）是暴露组与未暴露组的风险之比：\n$$\n\\widehat{HR} = \\frac{\\hat{h}_1}{\\hat{h}_0}\n$$\n$\\widehat{HR} > 1$ 表明暴露与事件风险增加相关，$\\widehat{HR}  1$ 表明具有保护性关联，而 $\\widehat{HR} = 1$ 表明没有关联。\n\n**分析1：时间固定暴露定义**\n\n这是一种简单但方法学上有缺陷的方法。个体基于其整个历史被分入暴露组，特别是他们是否*曾经*开始治疗。\n- **暴露组 ($g=1$)**: 具有有限治疗起始时间的个体，$\\tau_i  \\infty$。\n- **未暴露组 ($g=0$)**: 从未开始治疗的个体，$\\tau_i = \\infty$。\n\n对于此分析，我们计算每个组的总事件数和总人时：\n- $E_1^{\\mathrm{fixed}} = \\sum_{i: \\tau_i  \\infty} \\delta_i$\n- $T_1^{\\mathrm{fixed}} = \\sum_{i: \\tau_i  \\infty} y_i$\n- $E_0^{\\mathrm{fixed}} = \\sum_{i: \\tau_i = \\infty} \\delta_i$\n- $T_0^{\\mathrm{fixed}} = \\sum_{i: \\tau_i = \\infty} y_i$\n\n由此产生的时间固定风险比为：\n$$\n\\widehat{HR}_{\\mathrm{fixed}} = \\frac{E_1^{\\mathrm{fixed}} / T_1^{\\mathrm{fixed}}}{E_0^{\\mathrm{fixed}} / T_0^{\\mathrm{fixed}}}\n$$\n\n这里的关键缺陷在于人时的错误归因。对于一个在 $\\tau_i > 0$ 时开始治疗的个体，从基线 $t=0$ 到 $\\tau_i$ 的时间段相对于暴露状态是“不朽时间”。该个体*必须*无事件存活才能达到 $\\tau_i$ 并接受治疗。通过将其整个随访时间 $y_i$ 归类为“暴露”人时，我们包含了在此期间不可能发生暴露事件的一段时间（$[0, \\tau_i)$）。这种做法人为地增大了分母 $T_1^{\\mathrm{fixed}}$，却没有相应增加分子 $E_1^{\\mathrm{fixed}}$ 的可能性，从而使估计的风险 $\\hat{h}_1^{\\mathrm{fixed}}$ 向下偏倚，并将 $\\widehat{HR}_{\\mathrm{fixed}}$ 偏向于无效值 $1$。\n\n**分析2：时间更新暴露定义**\n\n这是正确的方法，将暴露视为一个时变协变量。一个个体可以为未暴露和暴露两种状态贡献人时。\n- 对于个体 $i$，时间区间 $[0, \\min(y_i, \\tau_i))$ 是未暴露人时。\n- 如果 $\\tau_i  y_i$，时间区间 $[\\tau_i, y_i)$ 是暴露人时。\n\n通过将所有个体的这些贡献相加，计算时间更新分析的总人时：\n- $T_0^{\\mathrm{upd}} = \\sum_{i} \\min(y_i, \\tau_i)$\n- $T_1^{\\mathrm{upd}} = \\sum_{i} \\max(0, y_i - \\tau_i)$\n\n事件被分配到个体在事件时间 $y_i$ 之前所处的暴露状态。\n- 如果事件（$\\delta_i=1$）发生在治疗开始或之前（$y_i \\le \\tau_i$），则计入未暴露组（$E_0^{\\mathrm{upd}}$）。\n- 如果事件（$\\delta_i=1$）发生在治疗开始之后（$y_i > \\tau_i$），则计入暴露组（$E_1^{\\mathrm{upd}}$）。\n\n时间更新的风险比是给定模型下的正确估计值：\n$$\n\\widehat{HR}_{\\mathrm{upd}} = \\frac{E_1^{\\mathrm{upd}} / T_1^{\\mathrm{upd}}}{E_0^{\\mathrm{upd}} / T_0^{\\mathrm{upd}}}\n$$\n\n**量化不朽时间偏倚**\n\n通过将错误的时间固定方法的结果与正确的时间更新方法的结果进行比较来量化其引入的偏倚。相对偏倚 $b$ 由下式给出：\n$$\nb = \\frac{\\widehat{HR}_{\\mathrm{fixed}} - \\widehat{HR}_{\\mathrm{upd}}}{\\widehat{HR}_{\\mathrm{upd}}}\n$$\n$b$ 的负值表示时间固定分析低估了风险比，这是不朽时间偏倚的预期方向。\n\n**算法实现**\n\n解决方案将通过一个处理给定患者队列的函数来实现。该函数将执行以下步骤：\n1. 为固定分析和更新分析初始化计数器：$E_0^{\\mathrm{fixed}}$, $T_0^{\\mathrm{fixed}}$, $E_1^{\\mathrm{fixed}}$, $T_1^{\\mathrm{fixed}}$, $E_0^{\\mathrm{upd}}$, $T_0^{\\mathrm{upd}}$, $E_1^{\\mathrm{upd}}$, $T_1^{\\mathrm{upd}}$，全部置为 $0$。\n2. 遍历队列中的每个患者 $(\\tau_i, y_i, \\delta_i)$。\n3. 对于**时间固定分析**，根据 $\\tau_i$ 对患者进行分类。如果 $\\tau_i  \\infty$，则将 $y_i$ 加到 $T_1^{\\mathrm{fixed}}$，将 $\\delta_i$ 加到 $E_1^{\\mathrm{fixed}}$。如果 $\\tau_i = \\infty$，则将 $y_i$ 加到 $T_0^{\\mathrm{fixed}}$，将 $\\delta_i$ 加到 $E_0^{\\mathrm{fixed}}$。\n4. 对于**时间更新分析**，划分患者的人时。将 $\\min(y_i, \\tau_i)$ 加到 $T_0^{\\mathrm{upd}}$，将 $y_i - \\min(y_i, \\tau_i)$ 加到 $T_1^{\\mathrm{upd}}$。如果 $\\delta_i=1$，则分配事件：如果 $y_i \\le \\tau_i$，则 $E_0^{\\mathrm{upd}}$ 增加 $1$；如果 $y_i > \\tau_i$，则 $E_1^{\\mathrm{upd}}$ 增加 $1$。\n5. 遍历完所有患者后，计算四种风险（$\\hat{h}_0^{\\mathrm{fixed}}, \\hat{h}_1^{\\mathrm{fixed}}, \\hat{h}_0^{\\mathrm{upd}}, \\hat{h}_1^{\\mathrm{upd}}$），注意处理人时分母为 $0$ 时可能出现的除以零的情况。\n6. 计算 $\\widehat{HR}_{\\mathrm{fixed}}$ 和 $\\widehat{HR}_{\\mathrm{upd}}$。\n7. 计算相对偏倚 $b$。\n8. 返回三元组 ($\\widehat{HR}_{\\mathrm{fixed}}, \\widehat{HR}_{\\mathrm{upd}}, b$)。\n\n此过程将应用于每个测试用例，结果将被收集并按规定格式化。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes time-fixed and time-updated hazard ratios and the resulting\n    relative bias for several EHR cohorts to demonstrate immortal time bias.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (happy path, mixed initiation times, some censoring)\n        [(2, 10, 1), (5, 12, 0), (np.inf, 8, 1), (0, 9, 1), (np.inf, 7, 0), (3, 6, 1)],\n        \n        # Test Case 2 (late treatment initiation creating substantial immortal time)\n        [(9, 12, 1), (10, 12, 0), (11, 14, 1), (np.inf, 6, 1), (np.inf, 12, 0)],\n        \n        # Test Case 3 (event at initiation boundary, immediate initiators)\n        [(5, 5, 1), (0, 8, 0), (4, 9, 1), (np.inf, 7, 1), (np.inf, 10, 0)],\n        \n        # Test Case 4 (early initiations and never-treated mix)\n        [(0, 4, 1), (1, 6, 0), (2, 3, 1), (np.inf, 5, 1), (np.inf, 6, 0)],\n    ]\n\n    all_results = []\n\n    for cohort in test_cases:\n        # --- Time-Fixed Analysis ---\n        E0_fixed, T0_fixed = 0.0, 0.0\n        E1_fixed, T1_fixed = 0.0, 0.0\n\n        for tau_i, y_i, delta_i in cohort:\n            if tau_i == np.inf:  # Unexposed group (never-treated)\n                T0_fixed += y_i\n                E0_fixed += delta_i\n            else:  # Exposed group (ever-treated)\n                T1_fixed += y_i\n                E1_fixed += delta_i\n\n        h0_fixed = E0_fixed / T0_fixed if T0_fixed > 0 else 0.0\n        h1_fixed = E1_fixed / T1_fixed if T1_fixed > 0 else 0.0\n        \n        hr_fixed = h1_fixed / h0_fixed if h0_fixed > 0 else np.inf\n\n        # --- Time-Updated Analysis ---\n        E0_upd, T0_upd = 0.0, 0.0\n        E1_upd, T1_upd = 0.0, 0.0\n\n        for tau_i, y_i, delta_i in cohort:\n            # Partition person-time\n            unexposed_pt = min(y_i, tau_i)\n            exposed_pt = y_i - unexposed_pt\n            \n            T0_upd += unexposed_pt\n            T1_upd += exposed_pt\n\n            # Allocate events\n            if delta_i == 1:\n                if y_i = tau_i:\n                    E0_upd += 1\n                else:  # y_i > tau_i\n                    E1_upd += 1\n        \n        h0_upd = E0_upd / T0_upd if T0_upd > 0 else 0.0\n        h1_upd = E1_upd / T1_upd if T1_upd > 0 else 0.0\n        \n        hr_upd = h1_upd / h0_upd if h0_upd > 0 else np.inf\n\n        # --- Bias Calculation ---\n        # The problem cases ensure hr_upd is not zero\n        bias = (hr_fixed - hr_upd) / hr_upd if hr_upd != 0 else 0.0\n        \n        all_results.extend([\n            round(hr_fixed, 3),\n            round(hr_upd, 3),\n            round(bias, 3)\n        ])\n\n    # Format the final output string\n    formatted_results = f\"[{','.join(map(str, all_results))}]\"\n    print(formatted_results)\n\nsolve()\n```", "id": "4862751"}, {"introduction": "EHR数据中超过80%的临床信息以非结构化的文本形式存在，例如医生的病程记录和出院小结，这为研究提供了巨大的机遇与挑战。本练习将引导您进入临床自然语言处理（NLP）的世界，通过构建一个基于规则的简单算法，从临床笔记中识别出患有“肺炎”的患者。您不仅将学习如何从文本中提取肯定的诊断信息，还将学习如何使用灵敏度和阳性预测值等标准指标来评估您表型算法的性能。[@problem_id:4862788]", "problem": "您将执行一项基于电子健康记录（EHR）数据的文本处理与评估任务，以生成真实世界证据。任务是实现一个不区分大小写的自然语言处理（NLP）规则，从带日期的临床笔记中提取肯定的肺炎诊断，然后根据病历验证的标签计算提取结果的灵敏度和阳性预测值（PPV）。您的程序必须是一个完整、可运行的程序。该任务需要纯粹以数学和逻辑术语来构建和解决，不依赖任何外部数据源。\n\n基本核心定义：临床文本挖掘可以建模为一个针对患者的二元分类问题，如果存在肯定的提及，则患者被预测为阳性，否则被预测为阴性。使用标准的诊断测试框架，灵敏度和阳性预测值（PPV）通过混淆矩阵中的真阳性、假阴性和假阳性数量来定义。日期用于将提及限制在围绕患者特定索引日期的临床相关观察窗口内。\n\n肯定性提及规则：对于给定的笔记，将笔记分割成句子，其中句子由句号、分号或换行符分隔。如果一个句子包含子字符串“pneumonia”且不包含子字符串“no evidence of”，则该句子肯定了肺炎；这两项检查都必须不区分大小写。如果一个笔记的任何句子肯定了肺炎，则该笔记肯定了肺炎。如果在患者索引日期前后$\\pm W$天的包含性窗口内，有任何日期的笔记根据句子规则包含肯定的提及，则该患者被预测为阳性。\n\n评估指标：对于一组患者，设$TP$为真阳性数量，$FN$为假阴性数量，$FP$为假阳性数量，这些数量通过比较程序的患者级别预测标签与病历验证标签来确定。使用诊断测试评估的标准定义，灵敏度和阳性预测值（PPV）将以小数形式计算。在分母为$0$的边缘情况下（例如，没有病历验证的阳性病例或没有预测的阳性病例），将相应的指标定义为$0.0$。\n\n您的程序必须实现上述规则，并为以下测试套件计算指标。在每个测试用例中，每个患者都有一个索引日期、一个二元病历验证标签和一系列带日期的笔记。日期是ISO格式“YYYY-MM-DD”的字符串。窗口大小$W$按每个测试用例提供，单位为天。\n\n测试套件：\n测试用例$1$，窗口大小$W = 30$：\n- 患者 \"A\"：索引日期 $2021$-$03$-$15$，病历验证标签 $1$。笔记：($2021$-$03$-$10$, \"Patient with pneumonia, started antibiotics.\"), ($2021$-$02$-$01$, \"No evidence of pneumonia.\")\n- 患者 \"B\"：索引日期 $2021$-$03$-$20$，病历验证标签 $0$。笔记：($2021$-$03$-$19$, \"CXR shows no evidence of pneumonia.\"), ($2021$-$03$-$01$, \"Follow-up visit.\")\n- 患者 \"C\"：索引日期 $2021$-$03$-$25$，病历验证标签 $1$。笔记：($2021$-$03$-$26$, \"Pneumonia suspected.\")\n- 患者 \"D\"：索引日期 $2021$-$03$-$05$，病历验证标签 $0$。笔记：($2021$-$04$-$10$, \"No evidence of pneumonia.\"), ($2021$-$03$-$04$, \"No fever.\")\n\n测试用例$2$，窗口大小$W = 14$：\n- 患者 \"E\"：索引日期 $2020$-$11$-$01$，病历验证标签 $1$。笔记：($2020$-$11$-$02$, \"No evidence of pneumonia.\")\n- 患者 \"F\"：索引日期 $2020$-$11$-$01$，病历验证标签 $0$。笔记：($2020$-$11$-$03$, \"No evidence of pneumonia on CT.\")\n- 患者 \"G\"：索引日期 $2020$-$11$-$10$，病历验证标签 $1$。笔记：($2020$-$10$-$01$, \"Pneumonia confirmed.\")\n\n测试用例$3$，窗口大小$W = 7$：\n- 患者 \"H\"：索引日期 $2022$-$01$-$15$，病历验证标签 $1$。笔记：($2022$-$01$-$15$, \"No evidence of pneumonia. However, later that day, pneumonia developed.\")\n- 患者 \"I\"：索引日期 $2022$-$01$-$15$，病历验证标签 $0$。笔记：($2022$-$01$-$16$, \"No evidence of pneumonia; monitoring ongoing.\")\n- 患者 \"J\"：索引日期 $2022$-$01$-$10$，病历验证标签 $1$。笔记：($2022$-$01$-$18$, \"Pneumonia.\")\n\n测试用例$4$，窗口大小$W = 90$：\n- 患者 \"K\"：索引日期 $2019$-$05$-$01$，病历验证标签 $0$。笔记：($2019$-$04$-$01$, \"pNeUmOnIa noted in past.\")\n- 患者 \"L\"：索引日期 $2019$-$05$-$01$，病历验证标签 $1$。笔记：($2019$-$05$-$20$, \"No evidence of severe pneumonia?\"), ($2019$-$05$-$21$, \"possible pneumonia vs bronchitis\")\n- 患者 \"M\"：索引日期 $2019$-$05$-$01$，病历验证标签 $1$。笔记：($2019$-$01$-$01$, \"Pneumonia.\")\n- 患者 \"N\"：索引日期 $2019$-$05$-$01$，病历验证标签 $0$。笔记：($2019$-$05$-$02$, \"No evidence of pneumonia.\")\n\n您的程序必须：\n- 按照规定实现不区分大小写的句子级肯定性提及规则。\n- 对于每个测试用例，根据索引日期指定窗口内的笔记预测患者级别的标签。\n- 为每个测试用例计算灵敏度和PPV（以小数表示），对分母为零的情况应用$0.0$规则。\n- 生成一行输出，包含一个逗号分隔的列表，用方括号括起来，其中结果按测试用例排序，每个测试用例内先是灵敏度后是PPV。将每个指标表示为四舍五入到$4$位小数的小数。例如，如果有$4$个测试用例，输出格式必须是“[sens$_1$,ppv$_1$,sens$_2$,ppv$_2$,sens$_3$,ppv$_3$,sens$_4$,ppv$_4$]”。", "solution": "该问题要求实现并评估一个基于规则的自然语言处理（NLP）系统，用于从临床笔记中检测肯定的肺炎诊断。评估将使用标准的灵敏度和阳性预测值（PPV）指标进行。该问题定义明确，其科学基础植根于临床信息学和诊断测试评估的原则，并为获得唯一、可验证的解决方案提供了所有必要的数据和规则。\n\n解决方案可以通过形式化一系列逻辑运算来构建，我们将对所提供的测试套件中的每个患者应用这些运算。\n\n问题的核心是一个二元分类任务。对于每个患者，我们预测一个标签$y_{pred} \\in \\{0, 1\\}$，其中$y_{pred}=1$表示预测为肺炎诊断，$y_{pred}=0$表示没有。然后将此预测与一个基准真相，即病历验证的标签$y_{true} \\in \\{0, 1\\}$进行比较。\n\n算法解决方案的组成部分如下：\n\n1.  **日期和窗口逻辑**：只有当临床笔记的日期$d_{note}$落在患者索引日期$d_{index}$前后$\\pm W$天的包含性窗口内时，该笔记才被认为是相关的。在数学上，这个条件表示为：\n    $$ |d_{note} - d_{index}| \\le W $$\n    其中日期差异以天为单位测量。日期以“YYYY-MM-DD”格式提供，必须解析为能够进行算术运算的日期对象。\n\n2.  **句子级肯定规则**：一个句子被认为肯定了肺炎，必须同时满足两个条件。设$s$为一个句子，设$s_{lower}$为$s$的小写版本。当且仅当以下条件成立时，该句子肯定了肺炎：\n    $$ (\\text{\"pneumonia\"} \\in s_{lower}) \\land (\\text{\"no evidence of\"} \\notin s_{lower}) $$\n    笔记中的句子由句号（.）、分号（;）或换行符（\\n）分隔。\n\n3.  **笔记级和患者级预测**：如果临床笔记中至少有一个句子肯定了肺炎，则该笔记肯定了肺炎。如果患者的至少一个相关临床笔记（即在指定日期窗口内的笔记）肯定了肺炎，则该患者被预测为阳性（$y_{pred}=1$）。如果没有相关笔记肯定肺炎，则该患者被预测为阴性（$y_{pred}=0$）。\n\n4.  **评估指标**：预测算法的性能通过比较预测标签集$\\{y_{pred}\\}$与真实标签集$\\{y_{true}\\}$来衡量。此比较产生真阳性（$TP$）、假阳性（$FP$）和假阴性（$FN$）的计数。\n    *   $TP$：$y_{true}=1$且$y_{pred}=1$的患者数量。\n    *   $FP$：$y_{true}=0$且$y_{pred}=1$的患者数量。\n    *   $FN$：$y_{true}=1$且$y_{pred}=0$的患者数量。\n\n    根据这些量，计算灵敏度和PPV：\n    $$ \\text{灵敏度} = \\frac{TP}{TP + FN} $$\n    $$ \\text{阳性预测值 (PPV)} = \\frac{TP}{TP + FP} $$\n    根据问题规范，如果任一指标的分母为$0$，则该指标的值定义为$0.0$。\n\n我们现在将此形式化程序应用于每个测试用例。\n\n**测试用例 1：窗口大小$W = 30$天**\n*   患者 A ($y_{true}=1$)：日期为$2021-03-10$的笔记在索引日期$2021-03-15$的$30$天窗口内。笔记“Patient with pneumonia...”肯定了肺炎。因此，$y_{pred}=1$。这是一个真阳性（$TP$）。\n*   患者 B ($y_{true}=0$)：日期为$2021-03-19$的笔记在索引日期$2021-03-20$的窗口内。句子“...no evidence of pneumonia”包含否定短语，不肯定肺炎。因此，$y_{pred}=0$。这是一个真阴性（$TN$）。\n*   患者 C ($y_{true}=1$)：日期为$2021-03-26$的笔记在索引日期$2021-03-25$之后一天，在窗口内。“Pneumonia suspected.”肯定了肺炎。因此，$y_{pred}=1$。这是一个真阳性（$TP$）。\n*   患者 D ($y_{true}=0$)：日期为$2021-04-10$的笔记距离索引日期$2021-03-05$超过$30$天，被忽略。日期为$2021-03-04$的笔记在窗口内，但未提及肺炎。因此，$y_{pred}=0$。这是一个真阴性（$TN$）。\n*   **指标**：$TP=2$, $FP=0$, $FN=0$。总阳性数$TP+FN=2$。预测阳性数$TP+FP=2$。\n    *   灵敏度 = $2 / (2+0) = 1.0$。\n    *   PPV = $2 / (2+0) = 1.0$。\n\n**测试用例 2：窗口大小$W = 14$天**\n*   患者 E ($y_{true}=1$)：日期为$2020-11-02$的笔记在索引日期$2020-11-01$的窗口内。“No evidence of pneumonia.”被否定。因此，$y_{pred}=0$。这是一个假阴性（$FN$）。\n*   患者 F ($y_{true}=0$)：日期为$2020-11-03$的笔记在索引日期$2020-11-01$的窗口内。“No evidence of pneumonia on CT.”被否定。因此，$y_{pred}=0$。这是一个真阴性（$TN$）。\n*   患者 G ($y_{true}=1$)：日期为$2020-10-01$的笔记在索引日期$2020-11-10$的$14$天窗口之外，被忽略。因此，$y_{pred}=0$。这是一个假阴性（$FN$）。\n*   **指标**：$TP=0$, $FP=0$, $FN=2$。总阳性数$TP+FN=2$。预测阳性数$TP+FP=0$。\n    *   灵敏度 = $0 / (0+2) = 0.0$。\n    *   PPV：分母$TP+FP=0$。根据规则，PPV = $0.0$。\n\n**测试用例 3：窗口大小$W = 7$天**\n*   患者 H ($y_{true}=1$)：日期为$2022-01-15$的笔记与索引日期相同。笔记文本为“No evidence of pneumonia. However, later that day, pneumonia developed.”。第一句被否定。第二句，“However, ... pneumonia developed.”，肯定了肺炎。因为有一个句子肯定了，所以该笔记肯定了肺炎。因此，$y_{pred}=1$。这是一个真阳性（$TP$）。\n*   患者 I ($y_{true}=0$)：日期为$2022-01-16$的笔记在索引日期$2022-01-15$的窗口内。文本“No evidence of pneumonia; monitoring ongoing.”包含一个被否定的句子和另一个没有关键词的句子。该笔记不肯定肺炎。因此，$y_{pred}=0$。这是一个真阴性（$TN$）。\n*   患者 J ($y_{true}=1$)：日期为$2022-01-18$的笔记在索引日期$2022-01-10$之后$8$天，超出了$7$天的窗口。该笔记被忽略。因此，$y_{pred}=0$。这是一个假阴性（$FN$）。\n*   **指标**：$TP=1$, $FP=0$, $FN=1$。总阳性数$TP+FN=2$。预测阳性数$TP+FP=1$。\n    *   灵敏度 = $1 / (1+1) = 0.5$。\n    *   PPV = $1 / (1+0) = 1.0$。\n\n**测试用例 4：窗口大小$W = 90$天**\n*   患者 K ($y_{true}=0$)：日期为$2019-04-01$的笔记在索引日期$2019-05-01$的窗口内。文本“pNeUmOnIa noted in past.”肯定了肺炎（不区分大小写检查）。因此，$y_{pred}=1$。这是一个假阳性（$FP$）。\n*   患者 L ($y_{true}=1$)：日期为$2019-05-20$的笔记包含一个被否定的句子。日期为$2019-05-21$的笔记也在窗口内，其文本“possible pneumonia vs bronchitis”肯定了肺炎。因此，$y_{pred}=1$。这是一个真阳性（$TP$）。\n*   患者 M ($y_{true}=1$)：日期为$2019-01-01$的笔记在索引日期$2019-05-01$的$90$天窗口之外，被忽略。因此，$y_{pred}=0$。这是一个假阴性（$FN$）。\n*   患者 N ($y_{true}=0$)：日期为$2019-05-02$的笔记在窗口内。“No evidence of pneumonia.”被否定。因此，$y_{pred}=0$。这是一个真阴性（$TN$）。\n*   **指标**：$TP=1$, $FP=1$, $FN=1$。总阳性数$TP+FN=2$。预测阳性数$TP+FP=2$。\n    *   灵敏度 = $1 / (1+1) = 0.5$。\n    *   PPV = $1 / (1+1) = 0.5$。\n\n最终结果四舍五入到$4$位小数，汇总成最终输出。", "answer": "```python\nimport numpy as np\nimport re\nfrom datetime import datetime, timedelta\n\ndef solve():\n    \"\"\"\n    Solves the pneumonia detection and evaluation task based on the provided rules and test suite.\n    \"\"\"\n    test_suite = [\n        {\n            \"W\": 30,\n            \"patients\": [\n                {\"id\": \"A\", \"index_date\": \"2021-03-15\", \"label\": 1, \"notes\": [(\"2021-03-10\", \"Patient with pneumonia, started antibiotics.\"), (\"2021-02-01\", \"No evidence of pneumonia.\")]},\n                {\"id\": \"B\", \"index_date\": \"2021-03-20\", \"label\": 0, \"notes\": [(\"2021-03-19\", \"CXR shows no evidence of pneumonia.\"), (\"2021-03-01\", \"Follow-up visit.\")]},\n                {\"id\": \"C\", \"index_date\": \"2021-03-25\", \"label\": 1, \"notes\": [(\"2021-03-26\", \"Pneumonia suspected.\")]},\n                {\"id\": \"D\", \"index_date\": \"2021-03-05\", \"label\": 0, \"notes\": [(\"2021-04-10\", \"No evidence of pneumonia.\"), (\"2021-03-04\", \"No fever.\")]}\n            ]\n        },\n        {\n            \"W\": 14,\n            \"patients\": [\n                {\"id\": \"E\", \"index_date\": \"2020-11-01\", \"label\": 1, \"notes\": [(\"2020-11-02\", \"No evidence of pneumonia.\")]},\n                {\"id\": \"F\", \"index_date\": \"2020-11-01\", \"label\": 0, \"notes\": [(\"2020-11-03\", \"No evidence of pneumonia on CT.\")]},\n                {\"id\": \"G\", \"index_date\": \"2020-11-10\", \"label\": 1, \"notes\": [(\"2020-10-01\", \"Pneumonia confirmed.\")]}\n            ]\n        },\n        {\n            \"W\": 7,\n            \"patients\": [\n                {\"id\": \"H\", \"index_date\": \"2022-01-15\", \"label\": 1, \"notes\": [(\"2022-01-15\", \"No evidence of pneumonia. However, later that day, pneumonia developed.\")]},\n                {\"id\": \"I\", \"index_date\": \"2022-01-15\", \"label\": 0, \"notes\": [(\"2022-01-16\", \"No evidence of pneumonia; monitoring ongoing.\")]},\n                {\"id\": \"J\", \"index_date\": \"2022-01-10\", \"label\": 1, \"notes\": [(\"2022-01-18\", \"Pneumonia.\")]}\n            ]\n        },\n        {\n            \"W\": 90,\n            \"patients\": [\n                {\"id\": \"K\", \"index_date\": \"2019-05-01\", \"label\": 0, \"notes\": [(\"2019-04-01\", \"pNeUmOnIa noted in past.\")]},\n                {\"id\": \"L\", \"index_date\": \"2019-05-01\", \"label\": 1, \"notes\": [(\"2019-05-20\", \"No evidence of severe pneumonia?\"), (\"2019-05-21\", \"possible pneumonia vs bronchitis\")]},\n                {\"id\": \"M\", \"index_date\": \"2019-05-01\", \"label\": 1, \"notes\": [(\"2019-01-01\", \"Pneumonia.\")]},\n                {\"id\": \"N\", \"index_date\": \"2019-05-01\", \"label\": 0, \"notes\": [(\"2019-05-02\", \"No evidence of pneumonia.\")]}\n            ]\n        }\n    ]\n\n    final_results = []\n\n    def sentence_affirms_pneumonia(sentence):\n        \"\"\"Checks if a single sentence affirms pneumonia.\"\"\"\n        s_lower = sentence.lower()\n        return \"pneumonia\" in s_lower and \"no evidence of\" not in s_lower\n\n    def note_affirms_pneumonia(note_text):\n        \"\"\"Checks if any sentence in a note affirms pneumonia.\"\"\"\n        sentences = re.split(r'[.;\\n]', note_text)\n        for sentence in sentences:\n            if sentence_affirms_pneumonia(sentence):\n                return True\n        return False\n\n    for test_case in test_suite:\n        W = test_case[\"W\"]\n        patients = test_case[\"patients\"]\n        \n        tp, fp, fn = 0, 0, 0\n\n        for patient in patients:\n            index_date = datetime.strptime(patient[\"index_date\"], \"%Y-%m-%d\")\n            true_label = patient[\"label\"]\n            \n            predicted_positive = False\n            for note_date_str, note_text in patient[\"notes\"]:\n                note_date = datetime.strptime(note_date_str, \"%Y-%m-%d\")\n                \n                # Check if the note is within the inclusive date window\n                if abs((note_date - index_date).days) = W:\n                    if note_affirms_pneumonia(note_text):\n                        predicted_positive = True\n                        break # A single affirming note is sufficient\n            \n            pred_label = 1 if predicted_positive else 0\n\n            if true_label == 1 and pred_label == 1:\n                tp += 1\n            elif true_label == 0 and pred_label == 1:\n                fp += 1\n            elif true_label == 1 and pred_label == 0:\n                fn += 1\n\n        # Calculate metrics for the test case\n        total_positives = tp + fn\n        predicted_positives = tp + fp\n\n        sensitivity = 0.0\n        if total_positives > 0:\n            sensitivity = tp / total_positives\n\n        ppv = 0.0\n        if predicted_positives > 0:\n            ppv = tp / predicted_positives\n            \n        final_results.append(f\"{sensitivity:.4f}\")\n        final_results.append(f\"{ppv:.4f}\")\n\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "4862788"}]}