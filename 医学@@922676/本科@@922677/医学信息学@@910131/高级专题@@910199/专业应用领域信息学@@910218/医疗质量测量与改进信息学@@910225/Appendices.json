{"hands_on_practices": [{"introduction": "在衡量医疗质量之前，我们必须精确地定义衡量的对象人群，这在质量测量中被称为“分母”。本练习将指导您使用管理数据，通过实施基于年龄和持续参保资格的复杂筛选标准，来确定符合条件的分母人群。这是医疗信息学专家必须掌握的一项基本技能，它构成了所有后续质量评估的基础。[@problem_id:4844551]", "problem": "您需要为一项成人预防性保健措施实现分母计算，该计算基于持续在保标准，并允许不超过固定阈值的间断。请采用以下指标日期策略：使用固定的年末日期，因此指标日期为测量年度 $Y$ 的 $t_{\\mathrm{index}} = \\text{12月31日}$。分母由在测量年度对应的测量窗口内，同时满足年龄标准和持续在保标准的成员组成。\n\n需使用的基本定义：\n- 设测量窗口为 $W = [t_{\\mathrm{start}}, t_{\\mathrm{end}}]$，其中 $t_{\\mathrm{start}} = Y\\text{年1月1日}$，$t_{\\mathrm{end}} = Y\\text{年12月31日}$。\n- 设允许的累计间断阈值为 $\\Gamma = 30$天。如果在测量窗口 $W$ 内，成员的总未参保天数不超过 $\\Gamma$，则该成员满足持续在保标准。\n- 成员在指标日期 $t_{\\mathrm{index}}$ 的年龄是自出生日期以来已过的完整年数。这通过日历算术计算，即到 $t_{\\mathrm{index}}$ 为止已经历的完整年份数量。\n- 此预防性保健措施的年龄纳入范围为 $[18, 64]$ 周岁（含边界值），在指标日期 $t_{\\mathrm{index}}$ 进行评估。\n\n数据模型：\n- 每个测试用例指定测量年度 $Y$ 和一个成员列表。\n- 每个成员记录包含一个唯一标识符、一个出生日期和一个在保区间列表。每个在保区间是一个日历日期对 $[\\mathrm{start}, \\mathrm{end}]$（含起止日期），并假定其有效且满足 $\\mathrm{start} \\le \\mathrm{end}$。\n- 在测量窗口 $W$ 之外的区间不计入参保；只有每个区间与 $W$ 的交集部分才被视为有效参保。\n- 如果一个成员有多个在保区间，在计算参保天数之前，必须将 $W$ 内重叠或邻接的区间进行合并。\n\n每个测试用例所需的计算：\n1. 根据上述方法从 $Y$ 计算出 $t_{\\mathrm{index}}$。\n2. 对每个成员，计算其在 $t_{\\mathrm{index}}$ 的周岁年龄，并检查是否满足 $18 \\le \\text{age} \\le 64$。\n3. 将每个在保区间限制在 $W$ 内，合并重叠和邻接部分，然后通过对合并后的区间长度（含起止日期）求和，计算出在 $W$ 内的总参保天数 $C$。\n4. 设 $L$ 为 $W$ 内的总天数（含起止日期；平年 $L=365$，闰年 $L=366$）。计算累计未参保天数 $G = L - C$。\n5. 如果 $G \\le \\Gamma$，则成员满足持续在保标准。\n6. 分母计数是同时满足年龄范围和 $G \\le \\Gamma$ 条件的成员数量。\n\n您的程序必须生成单行输出，其中包含各测试用例的分母计数值，格式为一个用方括号括起来的逗号分隔列表（例如，“[2,3,4]”）。\n\n请使用以下测试套件。日期采用 ISO 格式 “YYYY-MM-DD”。\n\n测试用例 1：\n- $Y = 2023$。\n- 成员：\n  - id: \"A\", dob: \"1990-06-15\", enrollments: [[\"2023-01-01\",\"2023-05-31\"], [\"2023-07-01\",\"2023-12-31\"]].\n  - id: \"B\", dob: \"1959-12-30\", enrollments: [[\"2023-01-01\",\"2023-09-30\"], [\"2023-11-01\",\"2023-12-31\"]].\n  - id: \"C\", dob: \"2006-12-31\", enrollments: [[\"2023-01-01\",\"2023-12-31\"]].\n  - id: \"D\", dob: \"2005-12-31\", enrollments: [[\"2023-01-01\",\"2023-06-30\"], [\"2023-07-30\",\"2023-12-31\"]].\n  - id: \"E\", dob: \"1980-01-01\", enrollments: [].\n\n测试用例 2：\n- $Y = 2020$。\n- 成员：\n  - id: \"F\", dob: \"1980-02-29\", enrollments: [[\"2020-01-01\",\"2020-03-31\"], [\"2020-05-01\",\"2020-12-31\"]].\n  - id: \"G\", dob: \"1956-12-31\", enrollments: [[\"2020-01-01\",\"2020-03-01\"], [\"2020-04-02\",\"2020-12-31\"]].\n  - id: \"H\", dob: \"2002-01-01\", enrollments: [[\"2020-01-01\",\"2020-06-01\"], [\"2020-05-15\",\"2020-12-31\"]].\n  - id: \"I\", dob: \"1970-07-01\", enrollments: [[\"2019-01-01\",\"2019-12-31\"]].\n  - id: \"J\", dob: \"1999-12-31\", enrollments: [[\"2020-01-01\",\"2020-02-28\"], [\"2020-03-31\",\"2020-12-31\"]].\n\n测试用例 3：\n- $Y = 2023$。\n- 成员：\n  - id: \"K\", dob: \"1958-12-31\", enrollments: [[\"2023-01-01\",\"2023-12-31\"]].\n  - id: \"L\", dob: \"2005-01-01\", enrollments: [[\"2023-01-31\",\"2023-12-31\"]].\n  - id: \"M\", dob: \"1990-07-01\", enrollments: [[\"2023-01-01\",\"2023-01-21\"], [\"2023-02-01\",\"2023-11-10\"], [\"2023-12-01\",\"2023-12-31\"]].\n  - id: \"N\", dob: \"1999-12-31\", enrollments: [[\"2023-01-01\",\"2023-06-30\"], [\"2023-08-01\",\"2023-12-31\"]].\n  - id: \"O\", dob: \"1988-06-15\", enrollments: [[\"2023-01-01\",\"2023-12-31\"]].\n\n输出规格：\n- 对于每个测试用例，根据上述规则计算整数分母计数值。\n- 您的程序应精确地生成一行输出，格式为“[d1,d2,d3]”，其中 $d1$、$d2$ 和 $d3$ 分别是测试用例 1、2 和 3 的分母计数值。", "solution": "该问题是有效的。它提出了一个来自医疗质量测量领域（医学信息学的一个分支学科）的明确定义的计算任务。所有术语都得到了足够精确的规定，所提供的数据是一致的，并且所需的计算遵循逻辑和数学原理。未检测到任何科学、逻辑或事实上的缺陷。\n\n任务是计算一项预防性保健质量措施的分母。该分母由在指定的测量年度 $Y$ 内同时满足年龄标准和持续在保标准的成员组成。我们将把这个过程形式化为两个部分：基于年龄确定资格，以及基于持续在保确定资格。\n\n设测量年度表示为 $Y$。测量窗口 $W$ 是从 $Y$ 年 1 月 1 日到 12 月 31 日（含）的日期区间。我们将其定义为 $W = [t_{\\mathrm{start}}, t_{\\mathrm{end}}]$，其中 $t_{\\mathrm{start}} = Y\\text{-01-01}$，$t_{\\mathrm{end}} = Y\\text{-12-31}$。所有计算的指标日期固定为 $t_{\\mathrm{index}} = t_{\\mathrm{end}} = Y\\text{-12-31}$。\n\n**1. 年龄标准**\n\n如果成员在指标日期 $t_{\\mathrm{index}}$ 的年龄落在 $[18, 64]$ 周岁（含）的范围内，则其符合年龄资格。年龄定义为自成员出生日期（DOB）以来已过的完整年数。给定出生日期 DOB $= Y_{\\mathrm{dob}}\\text{-}M_{\\mathrm{dob}}\\text{-}D_{\\mathrm{dob}}$ 和指标日期 $t_{\\mathrm{index}} = Y\\text{-12-31}$，年龄计算如下：\n$$\n\\text{age} = Y - Y_{\\mathrm{dob}}\n$$\n这一简化是有效的，因为指标日期始终是该年的最后一天。因此，对于任何出生日期，成员在 $Y$ 年的生日已经过去，或恰好是指标日期当天，这意味着他们已经完成了 $Y - Y_{\\mathrm{dob}}$ 年的生命。年龄标准满足条件为：\n$$\n18 \\le (Y - Y_{\\mathrm{dob}}) \\le 64\n$$\n\n**2. 持续在保标准**\n\n如果成员在测量窗口 $W$ 内的总未参保天数不超过指定阈值 $\\Gamma = 30$ 天，则该成员满足持续在保标准。计算过程包括三个连续步骤：\n\n**2.1. 在保区间处理**\n\n每个成员都有一段在保历史，以包含起止日期的区间列表 $[s_i, e_i]$ 的形式给出。这些区间必须首先被限制在测量窗口 $W = [t_{\\mathrm{start}}, t_{\\mathrm{end}}]$ 内。一个在保区间 $[s_i, e_i]$ 与 $W$ 的交集产生一个新的区间 $[s'_i, e'_i]$：\n$$\ns'_i = \\max(s_i, t_{\\mathrm{start}})\n$$\n$$\ne'_i = \\min(e_i, t_{\\mathrm{end}})\n$$\n如果 $s'_i > e'_i$，则该在保区间完全位于测量窗口之外，应被忽略。否则，区间 $[s'_i, e'_i]$ 代表在 $Y$ 年内的一段参保期。\n\n**2.2. 参保区间合并**\n\n将一个成员的所有在保区间限制在 $W$ 内之后，必须对得到的有效参保区间集合进行合并，以解决重叠和邻接问题。这将创建一个代表总独立参保期的不相交区间的最小集合。合并算法如下：\n1. 按起始日期 $s'_i$ 对截取后的区间集合 $\\{[s'_i, e'_i]\\}$ 进行排序。\n2. 用第一个排序后的区间初始化一个合并区间列表。\n3. 遍历剩余的已排序区间。对于每个区间，将其与合并列表中的最后一个区间进行比较。如果它与最后一个合并区间重叠或邻接（即其起始日期等于或晚于最后一个合并区间的结束日期一天），则更新最后一个合并区间的结束日期以包含当前区间。\n4. 如果它不重叠也不邻接，则将其作为一个新区间添加到合并区间列表中。\n\n**2.3. 未参保天数计算**\n\n设最终合并后的不相交参保区间集合为 $\\{[\\hat{s}_j, \\hat{e}_j]\\}$。总参保天数 $C$ 是这些区间长度的总和。单个包含起止日期的区间 $[\\hat{s}_j, \\hat{e}_j]$ 的长度为 $(\\hat{e}_j - \\hat{s}_j) + 1\\ \\text{day}$。\n$$\nC = \\sum_j \\left( (\\hat{e}_j - \\hat{s}_j) \\cdot \\text{days} + 1 \\right)\n$$\n设 $L$ 为测量年度 $Y$ 的总天数（平年 $L=365$，闰年 $L=366$）。总未参保天数 $G$ 由下式给出：\n$$\nG = L - C\n$$\n如果 $G \\le \\Gamma$（其中 $\\Gamma = 30$），则满足持续在保标准。\n\n**分母计算**\n\n给定测试用例的最终分母计数值是同时满足年龄标准和持续在保标准的成员总数。算法流程是遍历每个成员，应用这两项检查，如果两者都满足，则将计数器加一。对每个测试用例重复此过程。", "answer": "```python\nimport datetime\n\ndef solve():\n    \"\"\"\n    Computes the denominator for a preventive care measure based on age and continuous enrollment criteria.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"Y\": 2023,\n            \"members\": [\n                {\"id\": \"A\", \"dob\": \"1990-06-15\", \"enrollments\": [[\"2023-01-01\", \"2023-05-31\"], [\"2023-07-01\", \"2023-12-31\"]]},\n                {\"id\": \"B\", \"dob\": \"1959-12-30\", \"enrollments\": [[\"2023-01-01\", \"2023-09-30\"], [\"2023-11-01\", \"2023-12-31\"]]},\n                {\"id\": \"C\", \"dob\": \"2006-12-31\", \"enrollments\": [[\"2023-01-01\", \"2023-12-31\"]]},\n                {\"id\": \"D\", \"dob\": \"2005-12-31\", \"enrollments\": [[\"2023-01-01\", \"2023-06-30\"], [\"2023-07-30\", \"2023-12-31\"]]},\n                {\"id\": \"E\", \"dob\": \"1980-01-01\", \"enrollments\": []},\n            ]\n        },\n        {\n            \"Y\": 2020,\n            \"members\": [\n                {\"id\": \"F\", \"dob\": \"1980-02-29\", \"enrollments\": [[\"2020-01-01\", \"2020-03-31\"], [\"2020-05-01\", \"2020-12-31\"]]},\n                {\"id\": \"G\", \"dob\": \"1956-12-31\", \"enrollments\": [[\"2020-01-01\", \"2020-03-01\"], [\"2020-04-02\", \"2020-12-31\"]]},\n                {\"id\": \"H\", \"dob\": \"2002-01-01\", \"enrollments\": [[\"2020-01-01\", \"2020-06-01\"], [\"2020-05-15\", \"2020-12-31\"]]},\n                {\"id\": \"I\", \"dob\": \"1970-07-01\", \"enrollments\": [[\"2019-01-01\", \"2019-12-31\"]]},\n                {\"id\": \"J\", \"dob\": \"1999-12-31\", \"enrollments\": [[\"2020-01-01\", \"2020-02-28\"], [\"2020-03-31\", \"2020-12-31\"]]},\n            ]\n        },\n        {\n            \"Y\": 2023,\n            \"members\": [\n                {\"id\": \"K\", \"dob\": \"1958-12-31\", \"enrollments\": [[\"2023-01-01\", \"2023-12-31\"]]},\n                {\"id\": \"L\", \"dob\": \"2005-01-01\", \"enrollments\": [[\"2023-01-31\", \"2023-12-31\"]]},\n                {\"id\": \"M\", \"dob\": \"1990-07-01\", \"enrollments\": [[\"2023-01-01\", \"2023-01-21\"], [\"2023-02-01\", \"2023-11-10\"], [\"2023-12-01\", \"2023-12-31\"]]},\n                {\"id\": \"N\", \"dob\": \"1999-12-31\", \"enrollments\": [[\"2023-01-01\", \"2023-06-30\"], [\"2023-08-01\", \"2023-12-31\"]]},\n                {\"id\": \"O\", \"dob\": \"1988-06-15\", \"enrollments\": [[\"2023-01-01\", \"2023-12-31\"]]},\n            ]\n        }\n    ]\n\n    results = []\n    \n    GAMMA = 30\n    AGE_MIN = 18\n    AGE_MAX = 64\n\n    def is_leap(year):\n        return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\n    for case in test_cases:\n        Y = case[\"Y\"]\n        members = case[\"members\"]\n        denominator_count = 0\n\n        # Define measurement window and index date\n        w_start = datetime.date(Y, 1, 1)\n        w_end = datetime.date(Y, 12, 31)\n        \n        # Total days in the measurement year\n        L = 366 if is_leap(Y) else 365\n\n        for member in members:\n            # 1. Age Criterion Check\n            dob = datetime.date.fromisoformat(member[\"dob\"])\n            age = Y - dob.year\n            \n            if not (AGE_MIN = age = AGE_MAX):\n                continue\n            \n            # 2. Continuous Enrollment Criterion Check\n            enroll_intervals = member[\"enrollments\"]\n            \n            # 2a. Intersect enrollment intervals with the measurement window\n            clipped_intervals = []\n            for start_str, end_str in enroll_intervals:\n                start_date = datetime.date.fromisoformat(start_str)\n                end_date = datetime.date.fromisoformat(end_str)\n                \n                intersect_start = max(start_date, w_start)\n                intersect_end = min(end_date, w_end)\n                \n                if intersect_start = intersect_end:\n                    clipped_intervals.append([intersect_start, intersect_end])\n            \n            covered_days = 0\n            if clipped_intervals:\n                # 2b. Merge overlapping and adjacent intervals\n                clipped_intervals.sort(key=lambda x: x[0])\n                \n                merged = [clipped_intervals[0]]\n                for i in range(1, len(clipped_intervals)):\n                    current_start, current_end = clipped_intervals[i]\n                    last_merged_start, last_merged_end = merged[-1]\n                    \n                    # Merge if intervals overlap or are adjacent (end of one is the day before start of next)\n                    if current_start = last_merged_end + datetime.timedelta(days=1):\n                        merged[-1][1] = max(last_merged_end, current_end)\n                    else:\n                        merged.append([current_start, current_end])\n                \n                # 2c. Calculate total covered days from merged intervals\n                for start, end in merged:\n                    covered_days += (end - start).days + 1\n            \n            # 2d. Calculate uncovered days\n            uncovered_days = L - covered_days\n            \n            # 2e. Check against the allowed gap threshold\n            if uncovered_days = GAMMA:\n                denominator_count += 1\n                \n        results.append(denominator_count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4844551"}, {"introduction": "在界定分母之后，下一步是构建一个完整的质量指标，这需要同时定义分母（符合条件的患者）和分子（达到质量目标的患者）。本练习将模拟临床质量语言（CQL）的逻辑，让您从头开始构建一个血压控制率指标。通过这一实践，您将学会如何整合多项临床标准来计算最终的绩效率，从而将零散的数据转化为有意义的质量洞察。[@problem_id:4844528]", "problem": "您将编写一个完整的程序，该程序使用一组固定的快速医疗互操作性资源（Fast Healthcare Interoperability Resources, FHIR）样本资源和临床质量语言（Clinical Quality Language, CQL）语义来评估血压控制质量指标，然后返回多个测量窗口的指标率。任务是从信息学和集合论的核心定义出发，完全按照所述逻辑进行实现，不依赖任何外部 CQL 引擎。本问题是自包含的。\n\n使用的基本原理和定义：\n- 患者在参考日期的年龄（以年为单位）是其出生日期与参考日期之间经过的时间（以年为单位）的向下取整。对于出生日期为 $d_{\\text{birth}}$ 和参考日期为 $d_{\\text{ref}}$ 的情况，年龄定义为 $A = \\left\\lfloor \\frac{d_{\\text{ref}} - d_{\\text{birth}}}{\\text{one year}} \\right\\rfloor$，其中“一年”是通过年份的日历差额计算，然后比较月份和日期。\n- 时间区间是一个日期的闭区间 $[t_{\\min}, t_{\\max}]$。日期为 $t$ 的事件发生在该区间内，如果 $t_{\\min} \\le t \\le t_{\\max}$。\n- 指标分母是由集合成员资格谓词定义的一组患者；指标分子是由进一步的谓词定义的子集；指标率是比率 $R = \\frac{|\\text{Numerator}|}{|\\text{Denominator}|}$，约定当 $|\\text{Denominator}| = 0$ 时，$R = 0.0$。\n- 该逻辑遵循以集合和谓词术语表示的临床质量语言（CQL）语义。您将实现下面描述的谓词。\n\n您的程序需要使用以下提供的数据：\n- 高血压的国际疾病分类第十次修订临床修订版（ICD-10-CM）样本代码：“I10”。\n- 逻辑观察标识符名称和代码（LOINC）样本代码：\n  - 血压组套代码：`85354-9`。\n  - 收缩压部分：`8480-6`。\n  - 舒张压部分：`8462-4`。\n\n您必须将以下固定的 FHIR 类样本资源队列直接嵌入到您的程序中。表示是抽象的；只有陈述的属性是相关的。\n\n- 患者 $P1$：\n  - 出生日期：$1967$-$05$-$20$。\n  - 病情：一个高血压病情（“I10”），发病于 $2010$-$01$-$01$。\n  - 就诊：一次就诊，时期日期为 $2022$-$06$-$01$，若该日期在区间 $[t_{\\min}, t_{\\max}]$ 内。\n  - 观察（血压，代码 “`85354-9`”）：\n    - $2022$-$06$-$01$：收缩压（“`8480-6`”）$138$ mmHg，舒张压（“`8462-4`”）$88$ mmHg。\n    - $2022$-$09$-$01$：收缩压 $142$ mmHg，舒张压 $85$ mmHg。\n- 患者 $P2$：\n  - 出生日期：$1955$-$02$-$10$。\n  - 病情：一个高血压病情（“I10”），发病于 $2015$-$01$-$01$。\n  - 就诊：一次就诊，日期为 $2022$-$11$-$01$。\n  - 观察：\n    - $2022$-$03$-$03$：收缩压 $139$ mmHg，舒张压 $91$ mmHg。\n    - $2022$-$11$-$01$：收缩压 $134$ mmHg，舒张压 $88$ mmHg。\n- 患者 $P3$：\n  - 出生日期：$1977$-$08$-$01$。\n  - 病情：一个高血压病情（“I10”），发病于 $2020$-$06$-$01$。\n  - 就诊：一次就诊，日期为 $2022$-$05$-$10$。\n  - 观察：\n    - $2021$-$12$-$30$：收缩压 $130$ mmHg，舒张压 $80$ mmHg。\n- 患者 $P4$：\n  - 出生日期：$1938$-$01$-$01$。\n  - 病情：一个高血压病情（“I10”），发病于 $2000$-$01$-$01$。\n  - 就诊：一次就诊，日期为 $2022$-$12$-$31$。\n  - 观察：\n    - $2022$-$12$-$31$：收缩压 $140$ mmHg，舒张压 $90$ mmHg。\n- 患者 $P5$：\n  - 出生日期：$1992$-$09$-$15$。\n  - 病情：无。\n  - 就诊：一次就诊，日期为 $2022$-$10$-$10$。\n  - 观察：\n    - $2022$-$10$-$10$：收缩压 $120$ mmHg，舒张压 $70$ mmHg。\n- 患者 $P6$：\n  - 出生日期：$2004$-$12$-$31$。\n  - 病情：一个高血压病情（“I10”），发病于 $2022$-$06$-$01$。\n  - 就诊：一次就诊，日期为 $2022$-$07$-$01$。\n  - 观察：\n    - $2022$-$08$-$01$：收缩压 $138$ mmHg，舒张压 $89$ mmHg。\n\n需从第一性原理精确实现的 CQL 风格谓词：\n- 成人队列：如果在测量期结束日期 $t_{\\max}$ 时，患者的年龄 $A$（以年为单位）满足 $18 \\le A \\le 85$，则该患者符合成人资格。\n- 高血压诊断：如果存在一个代码为“I10”的病情记录，其发病日期 $\\le t_{\\max}$，则该患者患有高血压。\n- 测量期内的就诊：如果存在至少一次就诊，其日期 $t_{\\text{enc}}$ 满足 $t_{\\min} \\le t_{\\text{enc}} \\le t_{\\max}$，则该患者满足就诊要求。\n- 分母成员资格：当且仅当上述所有三个谓词均为真时，患者才属于分母。\n- 血压控制的分子：在患者同时包含收缩压（“`8480-6`”）和舒张压（“`8462-4`”）部分的血压观察记录（代码 “`85354-9`”）中，考虑那些有效日期 $t_{\\text{obs}}$ 满足 $t_{\\min} \\le t_{\\text{obs}} \\le t_{\\max}$ 的记录。如果不存在这样的记录，则患者不属于分子。否则，取最近一次的观察记录，即 $t_{\\text{obs}}$ 最大的记录；当且仅当该次最新观察记录的收缩压 $ 140$ 且舒张压 $ 90$ 时，患者才属于分子。等于 $140$ 的收缩压或等于 $90$ 的舒张压不被视为已控制。\n\n指标率计算：\n- 对于给定的测量期 $[t_{\\min}, t_{\\max}]$，如上定义分母计数 $D$ 和分子计数 $N$。指标率 $R$ 是小数 $R = \\frac{N}{D}$（如果 $D > 0$），否则 $R = 0.0$。报告的 $R$ 值需四舍五入至三位小数，当第四位小数 $\\ge 5$ 时，采用常规的“四舍五入五远离零”规则。\n\n测试套件：\n您的程序必须按所列顺序为以下每个测量期计算 $R$：\n1. 案例 1：$t_{\\min} = 2022$-$01$-$01$，$t_{\\max} = 2022$-$12$-$31$。\n2. 案例 2：$t_{\\min} = 2022$-$09$-$02$，$t_{\\max} = 2022$-$12$-$31$。\n3. 案例 3：$t_{\\min} = 2022$-$01$-$01$，$t_{\\max} = 2022$-$06$-$30$。\n4. 案例 4：$t_{\\min} = 2023$-$01$-$01$，$t_{\\max} = 2023$-$12$-$31$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个小数率的结果，以逗号分隔列表的形式呈现，每个小数率格式化为恰好三位小数，并用方括号括起来，不含空格。例如，一个有效的输出格式为“[$0.123$,$0.456$,$0.000$,$1.000$]”，但其值应为根据本问题数据和规则计算得出的结果。\n\n所有日期均为日历日期。无需外部输入；程序必须嵌入上述数据并严格按照所述逻辑实现。所有血压值单位均为毫米汞柱（mmHg）。所有报告的率必须是 $[0, 1]$ 区间内的小数。", "solution": "该问题要求基于一组预定义的患者数据和受临床质量语言（Clinical Quality Language, CQL）启发的逻辑谓词，实现一个血压控制的临床质量指标。解决方案涉及将集合论和谓词逻辑严谨地、一步步地应用于一个固定数据集，并覆盖多个时间段。\n\n问题的核心是针对给定的测量期，确定两个集合的成员资格：分母集合 $D$ 和分子集合 $N$。全集 $\\mathcal{P}$ 由提供的六名患者组成，即 $\\{P1, P2, P3, P4, P5, P6\\}$。测量期由一个日期的闭区间 $[t_{\\min}, t_{\\max}]$ 定义。\n\n最终的指标率 $R$ 是这两个集合基数的比值：\n$$R = \\begin{cases} \\frac{|N|}{|D|}  \\text{if } |D| > 0 \\\\ 0.0  \\text{if } |D| = 0 \\end{cases}$$\n率 $R$ 必须四舍五入到三位小数，规则是如果第四位小数是 $5$ 或更大，则向上取整。\n\n分母和分子集合的成员资格由一系列逻辑谓词确定。\n\n**1. 分母（$D$）谓词**\n\n当且仅当一名患者 $p \\in \\mathcal{P}$ 同时满足三个条件时，他才是分母集合 $D$ 的成员：\n$p \\in D \\iff \\text{IsAdult}(p, t_{\\max}) \\land \\text{HasHypertension}(p, t_{\\max}) \\land \\text{HadEncounter}(p, [t_{\\min}, t_{\\max}])$\n\n让我们定义每个谓词：\n\n- $\\text{IsAdult}(p, t_{\\max})$：如果患者在测量期结束日期 $t_{\\max}$ 的年龄 $A$ 处于 $[18, 85]$ 范围内，则此谓词为真。年龄计算公式为 $A = \\left\\lfloor \\frac{t_{\\max} - d_{\\text{birth}}}{\\text{one year}} \\right\\rfloor$，其中 $d_{\\text{birth}}$ 是患者的出生日期。计算遵循日历差：首先计算年份差异，如果 $t_{\\max}$ 的月和日先于 $d_{\\text{birth}}$ 的月和日，则减去一年。\n\n- $\\text{HasHypertension}(p, t_{\\max})$：如果患者有一条记录在案的病情，其 ICD-10-CM 代码为`“I10”`，且该病情的发病日期在 $t_{\\max}$ 或之前，则此谓词为真。\n\n- $\\text{HadEncounter}(p, [t_{\\min}, t_{\\max}])$：如果患者至少有一条就诊记录，其日期 $t_{\\text{enc}}$ 发生在测量期内，即 $t_{\\min} \\le t_{\\text{enc}} \\le t_{\\max}$，则此谓词为真。\n\n**2. 分子（$N$）谓词**\n\n分子 $N$ 是分母 $D$ 的一个子集。如果患者 $p \\in D$ 满足血压控制标准，则他是分子集合 $N$ 的成员。\n$p \\in N \\iff p \\in D \\land \\text{IsControlled}(p, [t_{\\min}, t_{\\max}])$\n\n- $\\text{IsControlled}(p, [t_{\\min}, t_{\\max}])$：此谓词的评估涉及几个步骤：\n    1. 识别患者 $p$ 在测量期 $[t_{\\min}, t_{\\max}]$ 内发生的所有血压观察记录。一个观察记录仅在同时具有收缩压（`“8480-6”`）和舒张压（`“8462-4”`）部分时才有效。\n    2. 如果在此期间内不存在此类观察记录，则该谓词为假。\n    3. 如果存在一个或多个此类观察记录，则选择最近的一个（即具有最大观察日期 $t_{\\text{obs}}$ 的记录）。\n    4. 对于这个最近的观察记录，当且仅当其收缩压值小于 $140$ mmHg 且舒张压值小于 $90$ mmHg 时，该谓词为真。注意严格的不等式：等于 $140$ 或 $90$ 的值不被视为已控制。\n\n**3. 算法实现**\n\n解决方案是通过创建一个计算工作流来实现的，该工作流针对四个指定的测试用例（测量期）中的每一个，根据谓词处理每个患者。\n\n首先，将患者数据存储在结构化格式中，例如字典列表，以便于访问诸如 `birthDate`、`conditions`、`encounters` 和 `observations` 等属性。\n\n对于每个测试用例 $[t_{\\min}, t_{\\max}]$：\n1. 初始化分母计数 $D_{count} = 0$ 和分子计数 $N_{count} = 0$。\n2. 遍历每个患者 $p \\in \\mathcal{P}$。\n3. 对于每个患者，评估三个分母谓词：$\\text{IsAdult}$、$\\text{HasHypertension}$ 和 $\\text{HadEncounter}$。\n4. 如果所有三个谓词都为真，则将 $D_{count}$ 增加 1。然后，继续为该患者评估分子谓词 $\\text{IsControlled}$。\n5. 如果 $\\text{IsControlled}$ 也为真，则将 $N_{count}$ 增加 1。\n6. 遍历所有患者后，计算率 $R$。如果 $D_{count} > 0$，则 $R = N_{count} / D_{count}$。否则，$R = 0.0$。\n7. 计算出的率 $R$ 四舍五入到 3 位小数。对于一个非负数 $x$，这可以通过计算 $\\frac{\\lfloor x \\cdot 10^3 + 0.5 \\rfloor}{10^3}$ 来实现。\n8. 为每个率生成最终的格式化字符串，确保始终显示三位小数（例如，$0.5$ 变为 $0.500$）。所有测试用例的结果被编译成所需的列表格式。整个过程是确定性的，并产生一个唯一的、可验证的结果。", "answer": "```python\nimport numpy as np\nfrom datetime import date\n\ndef solve():\n    \"\"\"\n    Evaluates a blood pressure control quality measure for a fixed cohort of patients\n    across multiple measurement windows, based on specified CQL-like semantics.\n    \"\"\"\n    \n    # --- Data Representation ---\n    # The fixed cohort of sample FHIR-like resources, embedded directly.\n    patients = [\n        {\n            \"id\": \"P1\", \"birthDate\": \"1967-05-20\",\n            \"conditions\": [{\"code\": \"I10\", \"onset\": \"2010-01-01\"}],\n            \"encounters\": [{\"date\": \"2022-06-01\"}],\n            \"observations\": [\n                {\"date\": \"2022-06-01\", \"systolic\": 138, \"diastolic\": 88},\n                {\"date\": \"2022-09-01\", \"systolic\": 142, \"diastolic\": 85},\n            ],\n        },\n        {\n            \"id\": \"P2\", \"birthDate\": \"1955-02-10\",\n            \"conditions\": [{\"code\": \"I10\", \"onset\": \"2015-01-01\"}],\n            \"encounters\": [{\"date\": \"2022-11-01\"}],\n            \"observations\": [\n                {\"date\": \"2022-03-03\", \"systolic\": 139, \"diastolic\": 91},\n                {\"date\": \"2022-11-01\", \"systolic\": 134, \"diastolic\": 88},\n            ],\n        },\n        {\n            \"id\": \"P3\", \"birthDate\": \"1977-08-01\",\n            \"conditions\": [{\"code\": \"I10\", \"onset\": \"2020-06-01\"}],\n            \"encounters\": [{\"date\": \"2022-05-10\"}],\n            \"observations\": [\n                {\"date\": \"2021-12-30\", \"systolic\": 130, \"diastolic\": 80},\n            ],\n        },\n        {\n            \"id\": \"P4\", \"birthDate\": \"1938-01-01\",\n            \"conditions\": [{\"code\": \"I10\", \"onset\": \"2000-01-01\"}],\n            \"encounters\": [{\"date\": \"2022-12-31\"}],\n            \"observations\": [\n                {\"date\": \"2022-12-31\", \"systolic\": 140, \"diastolic\": 90},\n            ],\n        },\n        {\n            \"id\": \"P5\", \"birthDate\": \"1992-09-15\",\n            \"conditions\": [],\n            \"encounters\": [{\"date\": \"2022-10-10\"}],\n            \"observations\": [\n                {\"date\": \"2022-10-10\", \"systolic\": 120, \"diastolic\": 70},\n            ],\n        },\n        {\n            \"id\": \"P6\", \"birthDate\": \"2004-12-31\",\n            \"conditions\": [{\"code\": \"I10\", \"onset\": \"2022-06-01\"}],\n            \"encounters\": [{\"date\": \"2022-07-01\"}],\n            \"observations\": [\n                {\"date\": \"2022-08-01\", \"systolic\": 138, \"diastolic\": 89},\n            ],\n        },\n    ]\n\n    # Test cases defined by measurement periods [t_min, t_max].\n    test_cases = [\n        (\"2022-01-01\", \"2022-12-31\"),\n        (\"2022-09-02\", \"2022-12-31\"),\n        (\"2022-01-01\", \"2022-06-30\"),\n        (\"2023-01-01\", \"2023-12-31\"),\n    ]\n\n    # --- Predicate Implementations ---\n\n    def calculate_age(birth_date_obj, ref_date_obj):\n        \"\"\"Calculates age in years based on calendrical difference.\"\"\"\n        age = ref_date_obj.year - birth_date_obj.year\n        if (ref_date_obj.month, ref_date_obj.day)  (birth_date_obj.month, birth_date_obj.day):\n            age -= 1\n        return age\n\n    def is_adult(patient, t_max_obj):\n        \"\"\"Checks if patient is between 18 and 85 years old.\"\"\"\n        birth_date_obj = date.fromisoformat(patient[\"birthDate\"])\n        age = calculate_age(birth_date_obj, t_max_obj)\n        return 18 = age = 85\n\n    def has_hypertension(patient, t_max_obj):\n        \"\"\"Checks for an active hypertension diagnosis.\"\"\"\n        for condition in patient[\"conditions\"]:\n            if condition[\"code\"] == \"I10\":\n                onset_date_obj = date.fromisoformat(condition[\"onset\"])\n                if onset_date_obj = t_max_obj:\n                    return True\n        return False\n\n    def had_encounter_in_period(patient, t_min_obj, t_max_obj):\n        \"\"\"Checks for an encounter within the measurement period.\"\"\"\n        for encounter in patient[\"encounters\"]:\n            encounter_date_obj = date.fromisoformat(encounter[\"date\"])\n            if t_min_obj = encounter_date_obj = t_max_obj:\n                return True\n        return False\n\n    def is_in_numerator(patient, t_min_obj, t_max_obj):\n        \"\"\"Checks if the patient's blood pressure is controlled.\"\"\"\n        valid_obs = []\n        for obs in patient[\"observations\"]:\n            obs_date_obj = date.fromisoformat(obs[\"date\"])\n            if t_min_obj = obs_date_obj = t_max_obj:\n                valid_obs.append(obs)\n        \n        if not valid_obs:\n            return False\n            \n        # Find the most recent observation by sorting\n        most_recent_obs = sorted(valid_obs, key=lambda x: x[\"date\"], reverse=True)[0]\n        \n        return most_recent_obs[\"systolic\"]  140 and most_recent_obs[\"diastolic\"]  90\n\n    # --- Main Calculation Loop ---\n    \n    results = []\n    for t_min_str, t_max_str in test_cases:\n        t_min_obj = date.fromisoformat(t_min_str)\n        t_max_obj = date.fromisoformat(t_max_str)\n        \n        denominator_count = 0\n        numerator_count = 0\n        \n        for p in patients:\n            in_denominator = (\n                is_adult(p, t_max_obj) and\n                has_hypertension(p, t_max_obj) and\n                had_encounter_in_period(p, t_min_obj, t_max_obj)\n            )\n            \n            if in_denominator:\n                denominator_count += 1\n                if is_in_numerator(p, t_min_obj, t_max_obj):\n                    numerator_count += 1\n        \n        if denominator_count == 0:\n            rate = 0.0\n        else:\n            rate = numerator_count / denominator_count\n        \n        # Round to 3 decimal places (half away from zero)\n        # Using np.floor(x * 10**dp + 0.5) / 10**dp for positive numbers achieves this\n        rounded_rate = np.floor(rate * 1000 + 0.5) / 1000\n        results.append(f\"{rounded_rate:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "4844528"}, {"introduction": "质量改进是一个动态过程，而不仅仅是计算静态的比率。本练习将介绍一种强大的统计过程控制工具——累积和（CUSUM）图，它被广泛用于随时间监控绩效并检测有意义的变化。您将实现一个 CUSUM 分析流程，以判断一项质量改进干预措施是否导致了术后并发症发生率的显著且持续的下降。[@problem_id:4844492]", "problem": "您的任务是实现一个单侧累积和 (CUSUM) 程序，以监测术后并发症率，并检测在质量改进 (QI) 干预后是否出现持续改善。监测基于对单个术后病例的二元观察，每个病例都是一个独立的伯努利试验。您的程序必须计算决策区间阈值，使用对数似然比构建 CUSUM，检测 QI 干预后最早的改善信号，并确定改善是否持续。\n\n基本原理：\n\n- 令 $x_i \\in \\{0,1\\}$ 表示病例 $i$ 的结果，其中 $x_i = 1$ 表示发生并发症，$x_i = 0$ 表示无并发症。这些结果被建模为带有参数 $p$ 的独立伯努利随机变量，其中 $p$ 是并发症率。\n- 在无改善的原假设下，$H_0: p = p_0$；在有改善的备择假设下，$H_1: p = p_1$，且 $p_1  p_0$。所有比率必须以小数形式表示（例如，100 例中有 15 例表示为 $0.15$）。\n- 伯努利概率质量函数为 $f(x \\mid p) = p^x (1-p)^{1-x}$。\n- 序贯概率比检验 (SPRT) 使用对数似然比增量 $$w_i = \\log\\left(\\frac{f(x_i \\mid p_1)}{f(x_i \\mid p_0)}\\right) = x_i \\log\\left(\\frac{p_1}{p_0}\\right) + (1-x_i)\\log\\left(\\frac{1-p_1}{1-p_0}\\right)。$$\n- 用于检测改善的 Page's CUSUM 统计量通过以下方式递归定义：$$S_t = \\max\\left(0, S_{t-1} + w_t\\right), \\quad S_0 = 0,$$ 其中递归从 QI 干预指数 $t_{\\mathrm{QI}}$ 开始并向前进行。\n- 源自 SPRT 误差控制的决策区间阈值为 $$h_+ = \\log\\left(\\frac{1-\\beta}{\\alpha}\\right) \\quad \\text{和} \\quad h_- = \\log\\left(\\frac{\\beta}{1-\\alpha}\\right),$$ 其中 $\\alpha$ 是在 $H_0$ 下的第一类错误（假信号概率），$\\beta$ 是在 $H_1$ 下的第二类错误（漏检概率）。对于单侧改善检测，$h_-$ 被用作警报阈值。\n\n检测和持续改善标准：\n\n- 将最早改善信号时间 $t^\\star$ 定义为满足 $S_t \\ge h_+$ 的最小 $t \\ge t_{\\mathrm{QI}}$。如果不存在这样的 $t$，则设置 $t^\\star = -1$。\n- 当且仅当 $t^\\star \\neq -1$，在 $t^\\star$ 之后至少有 $w$ 个观察值，并且接下来 $w$ 个观察值中的经验平均并发症率，$$\\hat{p} = \\frac{1}{w}\\sum_{i=t^\\star+1}^{t^\\star+w} x_i,$$ 满足 $\\hat{p} \\le p_1$ 时，才宣布为持续改善。\n\n实现要求：\n\n- 每个测试用例的输入数据包括 $(p_0, p_1, \\alpha, \\beta, t_{\\mathrm{QI}}, w, \\{x_i\\}_{i=0}^{n-1})$。所有并发症率 $p_0$ 和 $p_1$ 必须是小数。QI 指数 $t_{\\mathrm{QI}}$ 是序列中干预开始处的基于 0 的索引，CUSUM 应从 $t_{\\mathrm{QI}}$ 开始累积。\n- 您的程序应为每个测试用例计算 $h_+$ 和 $h_-$、最早检测索引 $t^\\star$ 以及表示是否持续改善的布尔值。\n- 对于每个测试用例，输出一个形式为 $[t^\\star, \\text{sustained}, h_+, h_-]$ 的列表，其中 $t^\\star$ 是一个整数，sustained 是一个布尔值，$h_+$ 和 $h_-$ 是四舍五入到六位小数的浮点数。\n\n测试套件：\n\n使用以下四个测试用例来检验不同的场景。对于每个案例，序列 $\\{x_i\\}$ 都被明确提供，QI 指数 $t_{\\mathrm{QI}}$ 指示从何处开始 CUSUM 累积。\n\n- 案例 A（理想路径，出现持续改善）：\n    - $p_0 = 0.15$, $p_1 = 0.07$, $\\alpha = 0.20$, $\\beta = 0.20$, $t_{\\mathrm{QI}} = 20$, $w = 15$,\n    - $\\{x_i\\}$ (长度 $60$): $[0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0, 0,0,0,0,0,0,1, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]$。\n- 案例 B（改善太弱，无信号）：\n    - $p_0 = 0.15$, $p_1 = 0.10$, $\\alpha = 0.10$, $\\beta = 0.20$, $t_{\\mathrm{QI}} = 20$, $w = 10$,\n    - $\\{x_i\\}$ (长度 $50$): $[0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0, 0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0]$。\n- 案例 C（QI 后无并发症，出现强劲的持续改善）：\n    - $p_0 = 0.25$, $p_1 = 0.10$, $\\alpha = 0.10$, $\\beta = 0.10$, $t_{\\mathrm{QI}} = 10$, $w = 20$,\n    - $\\{x_i\\}$ (长度 $36$): $[0,1,0,0,1,0,0,0,1,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]$。\n- 案例 D（出现信号但后续观察不足以判断为持续改善）：\n    - $p_0 = 0.20$, $p_1 = 0.05$, $\\alpha = 0.15$, $\\beta = 0.15$, $t_{\\mathrm{QI}} = 30$, $w = 25$,\n    - $\\{x_i\\}$ (长度 $50$): $[0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个列表，按案例 A、案例 B、案例 C、案例 D 的顺序列出每个案例的结果，形式为由方括号括起的逗号分隔列表。每个案例的结果必须是 $[t^\\star, \\text{sustained}, h_+, h_-]$ 形式的列表，其中 $h_+$ 和 $h_-$ 四舍五入到六位小数。例如：$[[t^\\star_A,\\text{sustained}_A,h_{+,A},h_{-,A}], [t^\\star_B,\\text{sustained}_B,h_{+,B},h_{-,B}], [\\dots], [\\dots]]$。", "solution": "问题陈述被认为是有效的。它在科学上基于序贯概率比检验 (SPRT) 和累积和 (CUSUM) 图的既定统计理论，这些是统计过程控制和医疗质量改进中的标准方法。该问题定义明确，为获得唯一解提供了所有必要的定义、数据和明确的标准。参数和场景是现实的。在测试案例 C 的描述性文本中发现了一个小差异，该文本声明数据序列长度为 $45$，而实际提供的序列长度为 $36$。这被解释为一个非致命的排印错误，解决方案将继续使用明确提供的数据序列，因为其结构完整且足以进行分析。\n\n该解决方案通过遵循定义的统计程序来实现。我们分析一系列术后结果 $\\{x_i\\}_{i=0}^{n-1}$，其中每个结果都是一个伯努利试验。结果 $x_i=1$ 表示发生并发症，$x_i=0$ 表示无并发症。历史并发症率为 $p_0$，质量改进 (QI) 干预后的目标率为 $p_1$，且 $p_1  p_0$。QI 干预在病例索引 $t_{\\mathrm{QI}}$ 处启动。\n\nCUSUM 程序的核心是对数似然比，它量化了每个观察结果支持备择假设 $H_1: p=p_1$（有改善）相对于原假设 $H_0: p=p_0$（无改善）的证据。伯努利随机变量的概率质量函数是 $f(x \\mid p) = p^x (1-p)^{1-x}$。单个观察值 $x_i$ 的对数似然比由下式给出：\n$$w_i = \\log\\left(\\frac{f(x_i \\mid p_1)}{f(x_i \\mid p_0)}\\right) = x_i \\log\\left(\\frac{p_1}{p_0}\\right) + (1-x_i)\\log\\left(\\frac{1-p_1}{1-p_0}\\right)$$\n由于 $p_1  p_0$，项 $\\log(p_1/p_0)$ 为负，而 $\\log((1-p_1)/(1-p_0))$ 为正。因此，一次并发症（$x_i=1$）会减少累积和，提供不利于改善的证据；而无并发症（$x_i=0$）则会增加累积和，提供支持改善的证据。\n\nCUSUM 统计量 $S_t$ 在干预开始时或之后（$t \\ge t_{\\mathrm{QI}}$）的每个病例 $t$ 上进行顺序累积。它由以下递归定义：\n$$S_t = \\max(0, S_{t-1} + w_t)$$\nCUSUM 过程以 $S_{t_{\\mathrm{QI}}-1} = 0$ 初始化。$\\max(0, \\cdot)$ 操作确保了如果累积证据趋向于不利于改善，CUSUM 会重置为 0，使其成为一个用于检测改善的单侧检验。\n\n当 CUSUM 统计量 $S_t$ 超过预定义的上决策阈值 $h_+$ 时，触发改善信号。该阈值源于第一类错误率 $\\alpha$（假信号的概率）和第二类错误率 $\\beta$（漏掉真实改善的概率）。双侧 SPRT 的上下阈值为：\n$$h_+ = \\log\\left(\\frac{1-\\beta}{\\alpha}\\right)$$\n$$h_- = \\log\\left(\\frac{\\beta}{1-\\alpha}\\right)$$\n对于这种检测改善的单侧检验，只有当 $S_t \\ge h_+$ 时才会发出信号。问题要求计算 $h_+$ 和 $h_-$ 两者。\n\n每个测试用例的算法流程如下：\n\n1.  **初始化**：给定参数 $(p_0, p_1, \\alpha, \\beta, t_{\\mathrm{QI}}, w, \\{x_i\\}_{i=0}^{n-1})$，首先使用自然对数计算决策阈值 $h_+$ 和 $h_-$ 的常量值。同时，预先计算对数似然增量的两种可能值：$x_i=0$ 时的 $w_0$ 和 $x_i=1$ 时的 $w_1$。\n\n2.  **CUSUM 监测**：初始化 CUSUM 统计量 $S=0$ 和信号时间 $t^\\star = -1$。从索引 $t = t_{\\mathrm{QI}}$ 开始，遍历患者结果直至数据序列末尾 $n-1$。在每一步中：\n    a.  根据结果 $x_t$ 确定对数似然增量 $w_t$。\n    b.  更新 CUSUM 统计量：$S \\leftarrow \\max(0, S + w_t)$。\n    c.  检查改善信号：如果 $S \\ge h_+$ 且 $t^\\star$ 尚未设置（即 $t^\\star = -1$），则将当前索引记录为信号时间：$t^\\star \\leftarrow t$。\n\n3.  **持续改善评估**：在遍历所有可用数据后，评估检测到的改善是否持续。这需要满足三个条件：\n    a.  必须已检测到改善信号，即 $t^\\star \\neq -1$。\n    b.  必须有足够的后续数据。具体来说，分析窗口需要在信号后有 $w$ 个观察值，因此数据必须至少延伸到索引 $t^\\star + w$。此检查形式上为 $t^\\star + w \\le n-1$，其中 $n$ 是观察总数。\n    c.  在紧随信号之后的 $w$ 个病例中，经验并发症率 $\\hat{p}$ 必须不大于目标率 $p_1$。经验率计算如下：\n    $$\\hat{p} = \\frac{1}{w}\\sum_{i=t^\\star+1}^{t^\\star+w} x_i$$\n    如果所有三个条件都为真，则宣布改善是持续的。否则，则不是。\n\n4.  **输出格式化**：将测试用例的结果组合成一个形式为 $[t^\\star, \\text{sustained}, \\text{round}(h_+, 6), \\text{round}(h_-, 6)]$ 的列表，其中 `sustained` 是一个布尔值。对所有提供的测试用例重复此过程。\n\n这种结构化方法确保了 CUSUM 图被正确实现，并且信号检测和持续改善的标准严格按照问题规范应用。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the one-sided CUSUM procedure to monitor postoperative\n    complication rates and detect sustained improvements.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"p0\": 0.15, \"p1\": 0.07, \"alpha\": 0.20, \"beta\": 0.20,\n            \"t_qi\": 20, \"w\": 15,\n            \"x\": [0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0, 0,0,0,0,0,0,1, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        },\n        {\n            \"id\": \"B\",\n            \"p0\": 0.15, \"p1\": 0.10, \"alpha\": 0.10, \"beta\": 0.20,\n            \"t_qi\": 20, \"w\": 10,\n            \"x\": [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0, 0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0]\n        },\n        {\n            \"id\": \"C\",\n            \"p0\": 0.25, \"p1\": 0.10, \"alpha\": 0.10, \"beta\": 0.10,\n            \"t_qi\": 10, \"w\": 20,\n            \"x\": [0,1,0,0,1,0,0,0,1,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        },\n        {\n            \"id\": \"D\",\n            \"p0\": 0.20, \"p1\": 0.05, \"alpha\": 0.15, \"beta\": 0.15,\n            \"t_qi\": 30, \"w\": 25,\n            \"x\": [0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        p0 = case[\"p0\"]\n        p1 = case[\"p1\"]\n        alpha = case[\"alpha\"]\n        beta = case[\"beta\"]\n        t_qi = case[\"t_qi\"]\n        w_sustained = case[\"w\"]\n        x_seq = case[\"x\"]\n        n = len(x_seq)\n\n        # 1. Calculate thresholds and log-likelihood increments\n        h_plus = np.log((1 - beta) / alpha)\n        h_minus = np.log(beta / (1 - alpha))\n\n        w_comp = np.log(p1 / p0) # Increment for x_i = 1\n        w_no_comp = np.log((1 - p1) / (1 - p0)) # Increment for x_i = 0\n        \n        # 2. CUSUM monitoring\n        s_cusum = 0.0\n        t_star = -1\n        \n        for t in range(t_qi, n):\n            if x_seq[t] == 1:\n                w_t = w_comp\n            else:\n                w_t = w_no_comp\n            \n            s_cusum = max(0, s_cusum + w_t)\n            \n            if s_cusum >= h_plus and t_star == -1:\n                t_star = t\n\n        # 3. Sustained improvement assessment\n        sustained = False\n        if t_star != -1:\n            # Check for sufficient follow-up data\n            if t_star + w_sustained  n:\n                # Calculate empirical complication rate in the window\n                window_start = t_star + 1\n                window_end = t_star + w_sustained + 1\n                complications_in_window = sum(x_seq[window_start:window_end])\n                p_hat = complications_in_window / w_sustained\n                \n                # Check if rate is below or equal to target\n                if p_hat = p1:\n                    sustained = True\n\n        # 4. Format output\n        case_result = [\n            t_star,\n            sustained,\n            round(h_plus, 6),\n            round(h_minus, 6)\n        ]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format without spaces\n    per_case_strings = []\n    for res in all_results:\n        s = f\"[{res[0]},{str(res[1]).lower()},{res[2]},{res[3]}]\"\n        per_case_strings.append(s)\n    final_output_string = f\"[{','.join(per_case_strings)}]\"\n    # Python's default str(True) is \"True\", not \"true\". Problem requires boolean, lowercase is conventional.\n    final_output_string = final_output_string.replace('true','True').replace('false','False')\n    # The problem asks for boolean, but the example format is [t_star, sustained, ...], where sustained would be a boolean literal.\n    # Python code produces True/False. I'll make the output string conform to JSON-like boolean literals for consistency in the final string representation, as is common practice.\n    # Re-evaluating: The example output in other problems uses True/False. Let me check the spec again: \"sustained is a boolean value\".\n    # Ok, I will use Python's default `True`/`False`. The previous edits were overly cautious.\n    per_case_strings_final = []\n    for res in all_results:\n        s = f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        per_case_strings_final.append(s)\n    print(f\"[{','.join(per_case_strings_final)}]\")\n\n\nsolve()\n```", "id": "4844492"}]}