{"hands_on_practices": [{"introduction": "在循证医学中，一项核心任务是量化诊断测试结果如何改变我们对患者病情的判断。本练习将引导你使用灵敏度、特异度和患病率等基本指标，计算似然比 ($LR$) 和测试后概率，这些是临床决策支持系统进行贝叶斯推断的基础 [@problem_id:4839022]。掌握这些计算对于准确解读测试结果至关重要。", "problem": "一家医院正在实施一个基于循证医学 (EBM) 的临床决策支持 (CDS) 模块。该模块对二元诊断测试的性能进行编码，并使用贝叶斯定理的优势比-似然比形式，在出现阳性测试结果后更新疾病概率。您的任务是为一个诊断测试配置计算程序，该测试的灵敏度为 $0.90$，特异度为 $0.95$，目标人群中的疾病患病率为 $0.02$。从灵敏度、特异度、验前优势比、似然比以及概率-优势比关系的核心定义出发，推导出阳性似然比 $LR^{+}$、阴性似然比 $LR^{-}$、阳性结果后的验后优势比以及相应的验后概率的一般表达式。然后，根据给定值计算这些量。最后，在 CDS 模块中配置了一个 $0.10$ 的治疗阈值：将临床决策编码为一个指标 $d$，如果阳性结果的验后概率大于或等于 $0.10$，则定义 $d=1$，否则 $d=0$。\n\n请用小数或分数表示概率（不要使用百分号）。尽可能提供精确的分数形式。如果选择报告任何非终止小数的循环小数近似值，请四舍五入到四位有效数字。将您的最终结果以单行矩阵的形式报告，其中的条目按顺序为：$LR^{+}$、$LR^{-}$、阳性结果的验后优势比、阳性结果的验后概率以及决策指标 $d$。", "solution": "该问题要求推导和计算循证医学 (EBM) 中使用的几个关键指标，并将其应用于临床决策支持 (CDS) 的情境中。我们将首先从基本原理出发推导通用公式，然后代入给定值以求得数值结果。\n\n设 $D$ 为患者患有该疾病的事件，$D^c$ 为患者未患该疾病的事件。设 $T^+$ 为测试结果为阳性的事件，$T^-$ 为测试结果为阴性的事件。\n\n给定的量是：\n- 灵敏度 ($Se$): 在患病条件下测试结果为阳性的概率, $Se = P(T^+ | D) = 0.90$。\n- 特异度 ($Sp$): 在未患病条件下测试结果为阴性的概率, $Sp = P(T^- | D^c) = 0.95$。\n- 患病率 (验前概率), $p = P(D) = 0.02$。\n\n由此，我们可以得出其他有用的概率：\n- 假阳性概率为 $P(T^+ | D^c) = 1 - P(T^- | D^c) = 1 - Sp$。\n- 假阴性概率为 $P(T^- | D) = 1 - P(T^+ | D) = 1 - Se$。\n- 未患病的验前概率为 $P(D^c) = 1 - P(D) = 1 - p$。\n\n**1. 通用表达式的推导**\n\n**阳性似然比 ($LR^{+}$)**\n阳性似然比是在患病个体中出现阳性测试结果的概率与在非患病个体中出现阳性测试结果的概率之比。\n$$LR^+ = \\frac{P(T^+ | D)}{P(T^+ | D^c)}$$\n代入灵敏度和特异度的定义，我们得到：\n$$LR^+ = \\frac{Se}{1 - Sp}$$\n\n**阴性似然比 ($LR^{-}$)**\n阴性似然比是在患病个体中出现阴性测试结果的概率与在非患病个体中出现阴性测试结果的概率之比。\n$$LR^- = \\frac{P(T^- | D)}{P(T^- | D^c)}$$\n代入定义，我们得到：\n$$LR^- = \\frac{1 - Se}{Sp}$$\n\n**验前优势比与验后优势比**\n优势比定义为某事件发生的概率与不发生的概率之比。疾病的验前优势比为：\n$$PreTestOdds = \\frac{P(D)}{P(D^c)} = \\frac{p}{1 - p}$$\n贝叶斯定理的优势比-似然比形式表明，验后优势比是验前优势比与相应似然比的乘积。对于阳性测试结果，验后优势比为：\n$$PostTestOdds(+) = PreTestOdds \\times LR^+$$\n代入验前优势比和 $LR^+$ 的表达式：\n$$PostTestOdds(+) = \\left(\\frac{p}{1 - p}\\right) \\times \\left(\\frac{Se}{1 - Sp}\\right)$$\n\n**验后概率**\n概率 $P$ 与其对应的优势比 $O$ 之间的关系由 $P = \\frac{O}{1 + O}$ 给出。因此，阳性测试后的疾病验后概率 $P_{post}(+) = P(D|T^+)$ 为：\n$$P_{post}(+) = \\frac{PostTestOdds(+)}{1 + PostTestOdds(+)}$$\n\n**2. 根据给定值进行计算**\n\n我们已知 $Se = 0.90$，$Sp = 0.95$，$p = 0.02$。\n\n**计算 $LR^{+}$:**\n$$LR^+ = \\frac{Se}{1 - Sp} = \\frac{0.90}{1 - 0.95} = \\frac{0.90}{0.05} = 18$$\n\n**计算 $LR^{-}$:**\n$$LR^- = \\frac{1 - Se}{Sp} = \\frac{1 - 0.90}{0.95} = \\frac{0.10}{0.95} = \\frac{10}{95} = \\frac{2}{19}$$\n\n**计算阳性结果的验后优势比：**\n首先，我们计算验前优势比：\n$$PreTestOdds = \\frac{p}{1 - p} = \\frac{0.02}{1 - 0.02} = \\frac{0.02}{0.98} = \\frac{2}{98} = \\frac{1}{49}$$\n现在我们使用 $LR^+$ 计算验后优势比：\n$$PostTestOdds(+) = PreTestOdds \\times LR^+ = \\frac{1}{49} \\times 18 = \\frac{18}{49}$$\n\n**计算阳性结果的验后概率：**\n利用验后优势比，我们求得验后概率：\n$$P_{post}(+) = \\frac{PostTestOdds(+)}{1 + PostTestOdds(+)} = \\frac{\\frac{18}{49}}{1 + \\frac{18}{49}} = \\frac{\\frac{18}{49}}{\\frac{49}{49} + \\frac{18}{49}} = \\frac{\\frac{18}{49}}{\\frac{67}{49}} = \\frac{18}{67}$$\n\n**3. 确定决策指标 $d$**\n\n决策指标 $d$ 是通过将验后概率 $P_{post}(+)$ 与治疗阈值 $0.10$ 进行比较来确定的。规则是：如果 $P_{post}(+) \\ge 0.10$，则 $d=1$；否则，$d=0$。\n我们必须将我们的结果 $\\frac{18}{67}$ 与阈值 $0.10 = \\frac{1}{10}$ 进行比较。\n为了比较分数 $\\frac{18}{67}$ 和 $\\frac{1}{10}$，我们可以进行交叉相乘：\n$$18 \\times 10 = 180$$\n$$67 \\times 1 = 67$$\n因为 $180 > 67$，所以 $\\frac{18}{67} > \\frac{1}{10}$。\n疾病的验后概率约为 $0.2687$，大于阈值 $0.10$。\n因此，决策指标为 $d=1$。\n\n需要报告的最终结果按顺序为：$LR^{+}$、$LR^{-}$、阳性结果的验后优势比、阳性结果的验后概率以及决策指标 $d$。\n- $LR^{+} = 18$\n- $LR^{-} = \\frac{2}{19}$\n- $PostTestOdds(+) = \\frac{18}{49}$\n- $P_{post}(+) = \\frac{18}{67}$\n- $d = 1$", "answer": "$$\\boxed{\\begin{pmatrix} 18  \\frac{2}{19}  \\frac{18}{49}  \\frac{18}{67}  1 \\end{pmatrix}}$$", "id": "4839022"}, {"introduction": "评估一项干预措施的有效性是循证决策的另一个关键环节。本练习将通过一个假设的队列研究数据，指导你计算风险比 ($RR$)、风险差 ($RD$) 和需治数 ($NNT$) 等关键效果指标 [@problem_id:4839021]。这些指标能帮助临床医生和患者从相对和绝对两个层面理解干预措施的效力，从而支持共同决策。", "problem": "一个学习型健康系统部署了一个临床决策支持（CDS）模块，以根据循证医学（EBM）原则总结队列研究的效应指标。考虑一个假设性的观察性队列研究，该研究比较了暴露（例如，旨在增加有益结局概率的新治疗路径）与无暴露的情况。在暴露组中，有 $2000$ 名个体，在固定的随访期内观察到 $120$ 例有益结局事件。在非暴露组中，有 $3000$ 名个体，在同一时期内观察到 $90$ 例有益结局事件。\n\n从流行病学和循证医学的核心定义出发，且不使用任何预先推导的公式，推导并计算以下效应指标：\n\n1. 比较暴露组与非暴露组的风险比。\n2. 比较暴露组与非暴露组的风险差。\n3. 需治数，根据对风险的绝对效应为有益结局而定义。\n\n仅使用所提供的计数以及风险和效应指标的基本定义来得出数值。将您的答案四舍五入至四位有效数字，并将所有值表示为无量纲的小数（无单位）。用一两句话解释在临床决策支持（CDS）的背景下，这些指标如何能指导临床决策，重点关注暴露是否可能是有益的及其效应的大小。", "solution": "本题要求在循证医学（EBM）和临床决策支持（CDS）系统的背景下，根据一项假设性队列研究，推导并计算三个关键效应指标。本次分析的核心原则是在固定时间段内，群体中风险（也称为累积发病率）的定义。\n\n风险（$R$）定义为在指定时间间隔内，最初未出现结局的群体中发生该结局的个体所占的比例。其计算方法为新发病例数（$A$）除以期初处于风险中的个体数（$N$）。\n$$R = \\frac{A}{N}$$\n\n给定以下两组数据：暴露组和非暴露组。\n暴露组：\n- 个体总数为 $N_E = 2000$。\n- 观察到的有益结局事件数为 $A_E = 120$。\n\n非暴露组：\n- 个体总数为 $N_U = 3000$。\n- 观察到的有益结局事件数为 $A_U = 90$。\n\n首先，我们使用基本定义计算每组中有益结局的风险。\n暴露组的风险 $R_E$ 为：\n$$R_E = \\frac{A_E}{N_E} = \\frac{120}{2000} = 0.06$$\n非暴露组的风险 $R_U$ 为：\n$$R_U = \\frac{A_U}{N_U} = \\frac{90}{3000} = 0.03$$\n这些风险值代表了在固定的随访期内，各组发生有益结局的概率。\n\n有了这些基本量，我们现在可以推导和计算所要求的效应指标。\n\n1.  **风险比（RR）**\n风险比是一种相对效应量度。它量化了暴露组发生结局的可能性是非暴露组的多少倍。它定义为暴露组风险与非暴露组风险之比。\n$$RR = \\frac{R_E}{R_U}$$\n代入计算出的风险值：\n$$RR = \\frac{0.06}{0.03} = 2$$\n提供的数据是精确计数，因此这个结果是精确的。为了按要求用四位有效数字表示该值，我们写作 $2.000$。大于 $1$ 的RR表明暴露组发生该结局的风险增加。由于该结局是有益的，这表明暴露具有积极效应。\n\n2.  **风险差（RD）**\n风险差，也称为绝对风险增加或绝对风险降低，是一种绝对效应量度。它表示两组之间风险的简单差异。\n$$RD = R_E - R_U$$\n代入计算出的风险值：\n$$RD = 0.06 - 0.03 = 0.03$$\n这个值也是精确的。用四位有效数字表示为 $0.03000$。正的 $RD$ 表明暴露组中该结局的绝对风险更高。在本例中，归因于暴露，有益结局的概率增加了 $3$ 个百分点。\n\n3.  **需治数（NNT）**\n需治数是衡量临床工作量的一种指标。它定义为与对照组相比，为使额外一个人经历特定结局而必须接受干预的患者数量。对于旨在增加其发生率的有益结局，NNT是绝对风险增加（当 $RD > 0$ 时，即风险差 $RD$）的倒数。\n$$NNT = \\frac{1}{RD}$$\n使用计算出的风险差：\n$$NNT = \\frac{1}{0.03} = \\frac{100}{3} \\approx 33.333...$$\n将此值四舍五入到四位有效数字得到 $33.33$。这意味着，平均而言，必须有 $33.33$ 名个体接受暴露（新的治疗路径），才能多出现一例有益结局。\n\n在CDS的背景下，这些指标为暴露的效应提供了一个简洁、多方面的总结，以指导临床实践。风险比（$2.000$）显示暴露使获得良好结局的机会增加了一倍，而风险差（$0.03000$）和需治数（$33.33$）则分别将其表述为获益有 $3\\%$ 的绝对增加，以及需要治疗大约 $33$ 名患者才能多获得一个成功结局，从而在干预效应的大小和实际意义方面指导临床医生的决策。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.000  0.03000  33.33\n\\end{pmatrix}\n}\n$$", "id": "4839021"}, {"introduction": "将循证医学原则大规模应用于临床实践，离不开医疗信息学的支持。“可计算表型”就是一种将临床标准转化为算法，用以在电子健康记录中自动识别特定患者群体的关键技术。本练习要求你基于循证标准，为心力衰竭设计一个可计算表型，并用精确率和召回率等指标严格评估其性能，这充分体现了循证医学与医疗信息学的深度融合 [@problem_id:4839044]。", "problem": "您需要设计和评估一个用于心力衰竭的可计算表型，该表型需符合循证医学（EBM）原则，且仅使用结构化数据元素。该表型必须使用临床数据仓库中常规可用的三种独立数据源来操作化一个病例定义：\n- 国际疾病分类第十次修订版 (ICD-10) 诊断代码。\n- 根据指南导向治疗分组的药物分发或给药记录。\n- 通过左心室射血分数 (LVEF) 量化的超声心动图结果。\n\n您必须计算预测标签，并根据病历审查的参考标准对其进行评估。您的程序必须精确且确定性地实现以下组件和评估协议。\n\n定义和表型逻辑：\n- 国际疾病分类第十次修订版 (ICD-10) 心力衰竭代码：任何以 I50 为前缀的代码字符串（例如 I50.1, I50.9）均被视为心力衰竭代码。\n- ICD-10 代码的环境：每次诊断代码的出现都与字符串 \"inpatient\" 或 \"outpatient\" 以及一个表示为整数日索引的日历日相关联。\n- 药物类别：用药事件表示为一个药物类别字符串和一个整数日索引的元组。允许的药物类别为字符串 \"loop_diuretic\"、\"ace_arb_arni\" 和 \"beta_blocker\"。\n- 超声心动图：超声心动图摘要由一个 LVEF 值表示，该值为 $[0,1]$ 范围内的实数，或特殊值 None（无超声心动图）。\n\n可计算表型阳性标签规则：当且仅当以下独立标准中至少有一条得到满足时，为患者分配一个预测为阳性的心力衰竭标签：\n- 标准 A (ICD-10 规则)：至少有一个住院 ICD-10 心力衰竭代码，或在不同日期至少有两个门诊 ICD-10 心力衰竭代码。\n- 标准 B (超声心动图规则)：LVEF 值小于或等于 $0.40$。\n- 标准 C (用药模式规则)：存在至少一对在不同日期发生的用药事件，其中一个事件属于 \"loop_diuretic\" 类，另一个事件属于 \"ace_arb_arni\" 或 \"beta_blocker\" 类，且它们的整数日索引之间的绝对差值小于或等于 $180$。\n\n评估协议和指标：\n- 每位患者都有一个经病历审查的参考标签，其值为 True（存在心力衰竭）或 False（不存在心力衰竭）。\n- 对于一组患者，从基本原理计算以下计数：真阳性、假阳性、真阴性 和 假阴性。\n- 根据这些计数，使用源自混淆矩阵的标准定义计算精确率、召回率以及精确率和召回率的调和平均数 $F_{1}$。当任何指标定义中的分母等于 $0$ 时，将相应指标的值定义为 $0$。\n- 所有计算出的指标值必须报告为实数，并精确四舍五入到小数点后三位。\n\n测试套件和输入数据：\n您的程序必须使用以下三个数据集。每个数据集是一个患者列表，每个患者由一个包含四个组件的元组定义：一个诊断代码元组列表（代码字符串、环境字符串、整数日）、一个用药元组列表（药物类别字符串、整数日）、一个 LVEF 值或 None，以及一个病历审查的布尔值标签。例如，一个在第 $60$ 天有一个住院 I50.9 代码、两次用药事件、LVEF 为 $0.35$ 且病历标签为 True 的患者可以表示为： ([(\"I50.9\",\"inpatient\",60)], [(\"loop_diuretic\",10), (\"beta_blocker\",20)], 0.35, True)。请完全按照规定使用以下数据集。\n\n数据集 $1$ (包含阳性和阴性样本以及边界条件的一般情况)：\n- 患者 $1$：codes [], meds [], LVEF $0.35$, gold True。\n- 患者 $2$：codes [(\"I50.1\",\"outpatient\",5), (\"I50.9\",\"outpatient\",40)], meds [], LVEF None, gold True。\n- 患者 $3$：codes [], meds [(\"loop_diuretic\",0), (\"ace_arb_arni\",180)], LVEF $0.55$, gold False。\n- 患者 $4$：codes [], meds [(\"loop_diuretic\",0), (\"beta_blocker\",400)], LVEF $0.55$, gold False。\n- 患者 $5$：codes [(\"I50.2\",\"inpatient\",60)], meds [], LVEF None, gold True。\n- 患者 $6$：codes [(\"I10\",\"outpatient\",50)], meds [], LVEF $0.45$, gold False。\n- 患者 $7$：codes [], meds [], LVEF $0.40$, gold True。\n- 患者 $8$：codes [(\"I50.9\",\"outpatient\",70), (\"I50.1\",\"outpatient\",70)], meds [], LVEF $0.60$, gold True。\n\n数据集 $2$ (预期没有预测为阳性样本的边缘情况)：\n- 患者 A：codes [(\"I50.9\",\"outpatient\",10)], meds [], LVEF $0.50$, gold True。\n- 患者 B：codes [], meds [(\"loop_diuretic\",0), (\"ace_arb_arni\",400)], LVEF None, gold False。\n- 患者 C：codes [(\"I50.1\",\"outpatient\",20), (\"I50.9\",\"outpatient\",20)], meds [], LVEF None, gold True。\n- 患者 D：codes [(\"J96.0\",\"inpatient\",5)], meds [], LVEF $0.60$, gold False。\n- 患者 E：codes [], meds [], LVEF $0.41$, gold True。\n\n数据集 $3$ (没有金标准为阳性样本的边缘情况)：\n- 患者 X：codes [(\"I50.9\",\"inpatient\",12)], meds [], LVEF None, gold False。\n- 患者 Y：codes [], meds [], LVEF $0.35$, gold False。\n- 患者 Z：codes [], meds [(\"loop_diuretic\",10), (\"beta_blocker\",15)], LVEF $0.60$, gold False。\n\n任务和输出规范：\n- 实现上述表型逻辑和评估协议。\n- 对每个数据集，计算精确率、召回率和 $F_{1}$，并精确到小数点后三位。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：数据集 $1$ 的精确率、召回率、$F_{1}$，然后是数据集 $2$ 的精确率、召回率、$F_{1}$，最后是数据集 $3$ 的精确率、召回率、$F_{1}$。例如：\"[0.123,0.456,0.321,0.000,0.000,0.000,1.000,1.000,1.000]\"。", "solution": "设计和评估可计算表型的问题，是将临床逻辑转化为形式化算法，然后根据参考标准衡量其性能的实践。本解决方案遵循基于原则的设计，首先系统地形式化表型规则，然后实施严格的评估协议。\n\n如果患者满足三个独立标准中的至少一个，则会被分配一个预测为阳性的心力衰竭标签，这些标准通过逻辑或（OR）运算进行组合。因此，最终的预测标签 $Y_{pred}$ 由以下表达式给出：\n$$ Y_{pred} = (\\text{Criterion A}) \\lor (\\text{Criterion B}) \\lor (\\text{Criterion C}) $$\n\n每个标准的设计和实现详述如下。\n\n**表型规则形式化**\n\n1.  **标准 A：ICD-10 诊断规则**\n    该标准基于《国际疾病分类第十次修订版》(ICD-10) 的诊断代码。如果患者有足够数量的心力衰竭特异性代码，则被视为阳性。\n    - **心力衰竭代码定义**：任何以 `I50` 为前缀的 ICD-10 代码字符串。\n    - **条件**：如果以下任一子条件为真，则该标准得到满足：\n        1.  患者在 `'inpatient'` 环境中记录有至少一个 (`$\\ge 1$`) `I50` 代码。\n        2.  患者在 `'outpatient'` 环境中，于不同日历日记录有至少两个 (`$\\ge 2$`) `I50` 代码。\n    - **算法逻辑**：为检查此标准，需扫描患者的诊断代码列表。任何住院 `I50` 代码的存在会立即满足该规则。如果不存在此类代码，算法将收集所有门诊 `I50` 代码，提取其关联的日索引，并计算唯一天数的数量。如果此计数大于或等于 $2$，则该规则得到满足。\n\n2.  **标准 B：超声心动图规则**\n    该标准使用来自心脏成像的关键定量生物标志物——左心室射血分数 ($L_{\\text{VEF}}$)，它衡量心脏的泵血效率。低 $L_{\\text{VEF}}$ 是特定类型心力衰竭的一个标志。\n    - **条件**：患者有记录的 $L_{\\text{VEF}}$ 值，并且该值小于或等于 $0.40$。形式上，条件为 $L_{\\text{VEF}} \\in [0, 0.40]$。没有记录 $L_{\\text{VEF}}$（表示为 `None`）的患者不满足此标准。\n    - **算法逻辑**：实现会检查患者的 $L_{\\text{VEF}}$ 值是否不为 `None`，然后评估不等式 $L_{\\text{VEF}} \\le 0.40$。\n\n3.  **标准 C：用药模式规则**\n    该标准根据提示心力衰竭的治疗模式来识别患者，特别是用于症状管理（利尿剂）和指南导向药物治疗的药物的共同处方。\n    - **条件**：患者有至少一次 `'loop_diuretic'` 和至少一次来自集合 `{'ace_arb_arni', 'beta_blocker'}` 的用药记录。关键是，这两个用药事件必须发生在不同的日期，并且它们日索引之间的绝对时间差不得超过 $180$ 天。\n    - **算法逻辑**：算法首先将患者的用药列表划分为两个集合：一个用于 `'loop_diuretic'` 事件，另一个用于 `'ace_arb_arni'` 或 `'beta_blocker'` 事件。然后，它遍历所有药物对，每对中一个来自一个集合，另一个来自另一个集合。对于每个药物对 $(m_1, m_2)$ 及其对应的日索引 $(d_1, d_2)$，算法检查是否 $d_1 \\neq d_2$ 且 $|d_1 - d_2| \\le 180$。找到的第一个满足条件的药物对即满足该标准。如果检查完所有组合后仍不存在这样的药物对，则该标准未被满足。\n\n**评估协议**\n\n通过将表型的预测 ($Y_{pred}$) 与一个患者队列的预先裁定的、经病历审查的参考标签 ($Y_{gold}$) 进行比较，来量化其准确性。该比较产生四种计数：\n- **真阳性 (TP)**：$Y_{pred} = \\text{True}$ 且 $Y_{gold} = \\text{True}$ 的患者数量。\n- **假阳性 (FP)**：$Y_{pred} = \\text{True}$ 且 $Y_{gold} = \\text{False}$ 的患者数量。\n- **真阴性 (TN)**：$Y_{pred} = \\text{False}$ 且 $Y_{gold} = \\text{False}$ 的患者数量。\n- **假阴性 (FN)**：$Y_{pred} = \\text{False}$ 且 $Y_{gold} = \\text{True}$ 的患者数量。\n\n从这些计数中，派生出三个标准指标：\n- **精确率**：衡量阳性预测的准确性。\n  $$ \\text{精确率} = \\frac{\\text{TP}}{\\text{TP} + \\text{FP}} $$\n- **召回率 (敏感性)**：衡量识别所有实际阳性病例的能力。\n  $$ \\text{召回率} = \\frac{\\text{TP}}{\\text{TP} + \\text{FN}} $$\n- **$F_1$ 分数**：精确率和召回率的调和平均数，提供一个平衡的度量。\n  $$ F_1 = 2 \\cdot \\frac{\\text{精确率} \\cdot \\text{召回率}}{\\text{精确率} + \\text{召回率}} $$\n在分母为零的情况下（例如，如果没有阳性预测，则 $\\text{TP} + \\text{FP} = 0$），相应指标的值定义为 $0.0$。最终指标值在四舍五入到小数点后三位后报告。整个过程独立应用于所提供的三个数据集中的每一个。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define datasets, run the evaluation, and print results.\n    \"\"\"\n    \n    # Dataset 1 (general case with positive and negative examples and boundary conditions)\n    dataset1 = [\n        # Patient 1: Criterion B positive (0.35 = 0.40)\n        ([], [], 0.35, True),\n        # Patient 2: Criterion A positive (2 outpatient on distinct dates)\n        ([(\"I50.1\", \"outpatient\", 5), (\"I50.9\", \"outpatient\", 40)], [], None, True),\n        # Patient 3: Criterion C positive (meds on distinct dates, diff = 180)\n        ([], [(\"loop_diuretic\", 0), (\"ace_arb_arni\", 180)], 0.55, False),\n        # Patient 4: Negative (meds > 180 apart)\n        ([], [(\"loop_diuretic\", 0), (\"beta_blocker\", 400)], 0.55, False),\n        # Patient 5: Criterion A positive (1 inpatient)\n        ([(\"I50.2\", \"inpatient\", 60)], [], None, True),\n        # Patient 6: Negative (wrong code, LVEF > 0.40)\n        ([(\"I10\", \"outpatient\", 50)], [], 0.45, False),\n        # Patient 7: Criterion B positive (LVEF == 0.40)\n        ([], [], 0.40, True),\n        # Patient 8: Negative (outpatient codes on same date)\n        ([(\"I50.9\", \"outpatient\", 70), (\"I50.1\", \"outpatient\", 70)], [], 0.60, True),\n    ]\n\n    # Dataset 2 (edge case with no predicted positives expected)\n    dataset2 = [\n        # Patient A: Negative (only 1 outpatient code)\n        ([(\"I50.9\", \"outpatient\", 10)], [], 0.50, True),\n        # Patient B: Negative (meds > 180 apart)\n        ([], [(\"loop_diuretic\", 0), (\"ace_arb_arni\", 400)], None, False),\n        # Patient C: Negative (outpatient codes on same date)\n        ([(\"I50.1\", \"outpatient\", 20), (\"I50.9\", \"outpatient\", 20)], [], None, True),\n        # Patient D: Negative (wrong code)\n        ([(\"J96.0\", \"inpatient\", 5)], [], 0.60, False),\n        # Patient E: Negative (LVEF > 0.40)\n        ([], [], 0.41, True),\n    ]\n\n    # Dataset 3 (edge case with no gold positives)\n    dataset3 = [\n        # Patient X: Predicted positive (Criterion A)\n        ([(\"I50.9\", \"inpatient\", 12)], [], None, False),\n        # Patient Y: Predicted positive (Criterion B)\n        ([], [], 0.35, False),\n        # Patient Z: Predicted positive (Criterion C)\n        ([], [(\"loop_diuretic\", 10), (\"beta_blocker\", 15)], 0.60, False),\n    ]\n\n    all_datasets = [dataset1, dataset2, dataset3]\n    all_results = []\n    \n    for dataset in all_datasets:\n        metrics = evaluate_phenotype(dataset)\n        all_results.extend(metrics)\n        \n    print(f\"[{','.join(all_results)}]\")\n\n\ndef evaluate_phenotype(dataset):\n    \"\"\"\n    Evaluates the phenotype performance on a given dataset.\n\n    Args:\n        dataset: A list of patient tuples.\n\n    Returns:\n        A list of strings representing precision, recall, and F1 score,\n        each formatted to three decimal places.\n    \"\"\"\n    tp, fp, tn, fn = 0, 0, 0, 0\n\n    for patient in dataset:\n        codes, meds, lvef, gold_label = patient\n        predicted_label = is_positive(codes, meds, lvef)\n\n        if predicted_label and gold_label:\n            tp += 1\n        elif predicted_label and not gold_label:\n            fp += 1\n        elif not predicted_label and not gold_label:\n            tn += 1\n        elif not predicted_label and gold_label:\n            fn += 1\n\n    # Calculate metrics, handling zero denominators\n    prec_denom = tp + fp\n    precision = tp / prec_denom if prec_denom > 0 else 0.0\n\n    rec_denom = tp + fn\n    recall = tp / rec_denom if rec_denom > 0 else 0.0\n\n    f1_denom = precision + recall\n    f1_score = 2 * (precision * recall) / f1_denom if f1_denom > 0 else 0.0\n    \n    return [f\"{precision:.3f}\", f\"{recall:.3f}\", f\"{f1_score:.3f}\"]\n\n\ndef is_positive(codes, meds, lvef):\n    \"\"\"\n    Applies the computable phenotype logic to a single patient.\n\n    Returns:\n        True if the patient is classified as positive, False otherwise.\n    \"\"\"\n    return (\n        check_criterion_a(codes) or\n        check_criterion_b(lvef) or\n        check_criterion_c(meds)\n    )\n\ndef check_criterion_a(codes):\n    \"\"\"Checks for at least 1 inpatient HF code or >=2 outpatient HF codes on distinct dates.\"\"\"\n    hf_codes = [c for c in codes if c[0].startswith(\"I50\")]\n    \n    inpatient_count = sum(1 for c in hf_codes if c[1] == \"inpatient\")\n    if inpatient_count >= 1:\n        return True\n        \n    outpatient_dates = {c[2] for c in hf_codes if c[1] == \"outpatient\"}\n    if len(outpatient_dates) >= 2:\n        return True\n        \n    return False\n\ndef check_criterion_b(lvef):\n    \"\"\"Checks for LVEF = 0.40.\"\"\"\n    return lvef is not None and lvef = 0.40\n\ndef check_criterion_c(meds):\n    \"\"\"Checks for a loop diuretic and another HF med within 180 days on distinct dates.\"\"\"\n    loop_diuretics = [m for m in meds if m[0] == \"loop_diuretic\"]\n    other_hf_meds = [m for m in meds if m[0] in (\"ace_arb_arni\", \"beta_blocker\")]\n\n    if not loop_diuretics or not other_hf_meds:\n        return False\n\n    for ld_med in loop_diuretics:\n        for other_med in other_hf_meds:\n            ld_day = ld_med[1]\n            other_day = other_med[1]\n            if ld_day != other_day and abs(ld_day - other_day) = 180:\n                return True\n                \n    return False\n\nsolve()\n```", "id": "4839044"}]}