{"hands_on_practices": [{"introduction": "要想理解和改进医疗服务体系，我们首先必须能够对其内部的患者流动进行建模和预测。本练习将介绍运筹学中的一个强大工具——排队论，用于分析一个常见场景：一家急诊诊所。通过应用 $M/M/s$ 模型的基本原理，你将学会量化诸如等待时间和资源利用率等关键绩效指标，这些指标对于有效进行容量规划和流程改进至关重要 [@problem_id:4861979]。", "problem": "一个综合医疗网络的急诊诊所配备了 $s=4$ 个分诊台，这些分诊台并行运作，遵循先到先服务（FCFS）的原则。患者以每小时 $\\lambda=12$ 的泊松过程到达，每个分诊台的服务时间服从指数分布，平均服务率为每小时每个分诊台 $\\mu=4$。假设到达间隔时间和服务时间相互独立，等待空间无限，并且系统处于稳态。这个场景是一个经典的 $M/M/s$ 排队模型，模拟了医疗服务体系结构中常见的服务节点。\n\n仅使用生灭过程的基本排队定义和 $M/M/s$ 系统中的稳态平衡，确定以下三个量：\n- 每个服务台的利用率，\n- 一个到达的患者在服务开始前必须等待严格大于零的时间的概率，\n- 以及在队列中的期望等待时间。\n\n所有数值答案均四舍五入至四位有效数字。以分钟为单位表示在队列中的期望等待时间。按上述顺序列出三个数字作为最终答案。", "solution": "在尝试任何解答之前，需要对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 模型：$M/M/s$ 排队\n- 并行服务器（服务台）数量：$s = 4$\n- 到达过程：泊松过程，到达率 $\\lambda = 12$ 人/小时\n- 每个服务台的服务时间分布：指数分布，平均服务率 $\\mu = 4$ 人/小时\n- 排队规则：先到先服务（FCFS）\n- 系统状态：稳态\n- 假设：到达间隔时间和服务时间独立，等待空间无限。\n- 要求解的量：\n    1. 每个服务台的利用率\n    2. 到达的患者必须等待的概率（延迟 $> 0$ 的概率）\n    3. 在队列中的期望等待时间，单位为分钟\n- 计算约束：仅使用生灭过程的基本排队定义和稳态平衡。\n- 舍入：所有数值答案保留四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学性：** 该问题使用 $M/M/s$ 排队模型，这是排队论和运筹学的基石。该模型被广泛使用并经过科学验证，用于分析包括医疗服务在内的各种服务系统。该问题是合理的。\n2.  **良态性：** 问题提供了所有必要的参数（$\\lambda$、$\\mu$、$s$）来确定所要求的性能指标。存在稳态解的一个关键条件是话务强度必须小于 $1$。系统总服务率为 $s\\mu = 4 \\times 4 = 16$ 人/小时。到达率为 $\\lambda = 12$ 人/小时。由于 $\\lambda  s\\mu$（$12  16$），系统是稳定的，存在唯一的稳态解。该问题是良态的。\n3.  **客观性：** 问题以精确、客观的数学语言陈述。诸如“泊松过程”和“指数分布”等术语具有明确的定义。该问题是客观的。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整的解答。\n\n### 解题推导\n该系统被建模为 $M/M/s$ 排队，这是一个连续时间生灭过程。设 $n$ 为系统中的患者人数（正在接受服务或等待中）。状态空间为 $\\{0, 1, 2, ...\\}$。系统参数为到达率 $\\lambda = 12$ 患者/小时，每个服务台的服务率 $\\mu = 4$ 患者/小时，以及服务台数量 $s = 4$。\n\n生率（到达）对所有状态都是恒定的：$\\lambda_n = \\lambda$ 对于 $n \\ge 0$。\n灭率（服务完成）取决于繁忙服务台的数量。如果系统中有 $n  s$ 个患者，则有 $n$ 个服务台繁忙，系统总服务率为 $\\mu_n = n\\mu$。如果系统中有 $n \\ge s$ 个患者，则所有 $s$ 个服务台都繁忙，系统总服务率为 $\\mu_n = s\\mu$。\n\n在稳态下，离开任何状态 $n$ 的速率必须等于进入该状态的速率。对于生灭过程，这可以简化为细致平衡方程：$\\lambda_{n-1}p_{n-1} = \\mu_n p_n$ 对于 $n \\ge 1$，其中 $p_n$ 是系统处于状态 $n$ 的稳态概率。\n\n由此，我们可以用 $p_0$（系统为空的概率）来表示所有的 $p_n$。\n对于 $1 \\le n \\le s$：\n$p_n = \\frac{\\lambda_{n-1}}{\\mu_n} p_{n-1} = \\frac{\\lambda}{n\\mu} p_{n-1} = \\dots = \\frac{\\lambda^n}{n!\\mu^n} p_0 = \\frac{(\\lambda/\\mu)^n}{n!} p_0$。\n对于 $n > s$：\n$p_n = \\frac{\\lambda_{n-1}}{\\mu_n} p_{n-1} = \\frac{\\lambda}{s\\mu} p_{n-1} = \\left(\\frac{\\lambda}{s\\mu}\\right)^{n-s} p_s$。\n代入 $p_s$ 的表达式：\n$p_n = \\left(\\frac{\\lambda}{s\\mu}\\right)^{n-s} \\frac{(\\lambda/\\mu)^s}{s!} p_0$。\n\n我们定义两个关键比率。到达负荷 (offered load) 是 $a = \\frac{\\lambda}{\\mu} = \\frac{12}{4} = 3$。这是一个无量纲的量，单位为爱尔朗（Erlangs）。话务强度，也代表每个服务台的利用率，是 $\\rho = \\frac{\\lambda}{s\\mu} = \\frac{12}{4 \\times 4} = \\frac{12}{16} = 0.75$。\n\n**1. 每个服务台的利用率**\n每个服务台的利用率是指一个普通服务台处于繁忙状态的时间比例。这等同于话务强度 $\\rho$。\n$$\\rho = \\frac{\\lambda}{s\\mu} = 0.75$$\n保留四位有效数字，结果为 $0.7500$。\n\n为了求出其他量，我们必须首先计算 $p_0$。所有概率之和必须为 1：$\\sum_{n=0}^{\\infty} p_n = 1$。\n$$1 = p_0 + \\sum_{n=1}^{s-1} p_n + \\sum_{n=s}^{\\infty} p_n = p_0 \\left( 1 + \\sum_{n=1}^{s-1} \\frac{a^n}{n!} + \\sum_{n=s}^{\\infty} \\frac{a^n}{s!s^{n-s}} \\right)$$\n第二个和是一个几何级数：\n$\\sum_{n=s}^{\\infty} \\frac{a^n}{s!s^{n-s}} = \\frac{a^s}{s!} \\sum_{n=s}^{\\infty} (\\frac{a}{s})^{n-s} = \\frac{a^s}{s!} \\sum_{k=0}^{\\infty} \\rho^k = \\frac{a^s}{s!} \\frac{1}{1-\\rho}$。\n因此，$p_0$ 由以下公式给出：\n$$p_0 = \\left[ \\sum_{n=0}^{s-1} \\frac{a^n}{n!} + \\frac{a^s}{s!(1-\\rho)} \\right]^{-1}$$\n当 $s=4$，$a=3$，且 $\\rho=0.75$ 时：\n$\\sum_{n=0}^{3} \\frac{3^n}{n!} = \\frac{3^0}{0!} + \\frac{3^1}{1!} + \\frac{3^2}{2!} + \\frac{3^3}{3!} = 1 + 3 + \\frac{9}{2} + \\frac{27}{6} = 1 + 3 + 4.5 + 4.5 = 13$。\n$\\frac{a^s}{s!(1-\\rho)} = \\frac{3^4}{4!(1-0.75)} = \\frac{81}{24(0.25)} = \\frac{81}{6} = 13.5$。\n$p_0 = [13 + 13.5]^{-1} = \\frac{1}{26.5} = \\frac{2}{53}$。\n\n**2. 等待概率 ($P_W$)**\n一个到达的患者当且仅当所有 $s$ 个服务器都繁忙时才需要等待。这是系统处于状态 $n \\ge s$ 的概率。根据 PASTA（泊松到达看到时间平均）属性，这等于稳态概率 $P(N \\ge s)$。\n$$P_W = \\sum_{n=s}^{\\infty} p_n = \\sum_{n=s}^{\\infty} p_0 \\frac{a^n}{s!s^{n-s}} = p_0 \\left( \\frac{a^s}{s!(1-\\rho)} \\right)$$\n这就是著名的爱尔朗 C 公式，$C(s, a)$。使用我们的中间计算结果：\n$$P_W = p_0 \\times 13.5 = \\frac{1}{26.5} \\times 13.5 = \\frac{13.5}{26.5} = \\frac{27}{53}$$\n数值上，$P_W \\approx 0.50943396...$。保留四位有效数字，结果为 $0.5094$。\n\n**3. 在队列中的期望等待时间 ($W_q$)**\n我们首先计算队列中的期望患者数，$L_q$。\n$$L_q = \\sum_{n=s}^{\\infty} (n-s) p_n = \\sum_{k=0}^{\\infty} k \\, p_{s+k} = \\sum_{k=0}^{\\infty} k \\left( p_0 \\frac{a^s}{s!} \\rho^k \\right)$$\n$$L_q = p_0 \\frac{a^s}{s!} \\sum_{k=0}^{\\infty} k \\rho^k$$\n这个求和是几何级数的一个标准结果，$\\sum_{k=0}^{\\infty} k \\rho^k = \\frac{\\rho}{(1-\\rho)^2}$。\n$$L_q = p_0 \\frac{a^s}{s!} \\frac{\\rho}{(1-\\rho)^2} = \\left( p_0 \\frac{a^s}{s!(1-\\rho)} \\right) \\frac{\\rho}{1-\\rho} = P_W \\frac{\\rho}{1-\\rho}$$\n代入数值：\n$$L_q = \\frac{27}{53} \\times \\frac{0.75}{1-0.75} = \\frac{27}{53} \\times \\frac{0.75}{0.25} = \\frac{27}{53} \\times 3 = \\frac{81}{53}$$\n根据利特尔法则，队列中的期望人数等于到达率乘以在队列中的期望时间：$L_q = \\lambda W_q$。\n$$W_q = \\frac{L_q}{\\lambda} = \\frac{81/53}{12} = \\frac{81}{53 \\times 12} = \\frac{27}{53 \\times 4} = \\frac{27}{212} \\text{ 小时}$$\n问题要求答案以分钟为单位。\n$$W_q = \\frac{27}{212} \\text{ 小时} \\times 60 \\frac{\\text{分钟}}{\\text{小时}} = \\frac{27 \\times 60}{212} = \\frac{27 \\times 15}{53} = \\frac{405}{53} \\text{ 分钟}$$\n数值上，$W_q \\approx 7.641509...$ 分钟。保留四位有效数字，结果为 $7.642$ 分钟。\n\n结果汇总（保留四位有效数字）：\n- 每个服务台的利用率：$0.7500$\n- 等待概率：$0.5094$\n- 在队列中的期望等待时间：$7.642$ 分钟", "answer": "$$\\boxed{\\begin{pmatrix} 0.7500  0.5094  7.642 \\end{pmatrix}}$$", "id": "4861979"}, {"introduction": "现代医疗体系越来越依赖数据，通过“基于价值的采购”等机制来衡量和激励服务质量。本实践将探讨复合质量评分的构建方法，以及这些评分对于不同绩效维度所赋权重的敏感性。通过亲手计算，你将深刻洞察绩效衡量所面临的挑战，并理解为何此类评分系统的设计是政策制定中的一个关键结构性要素及激烈辩论的主题 [@problem_id:4861983]。", "problem": "一个区域性综合医疗服务网络正在设计一种综合质量评分，以便在医疗服务体系内根据基于价值的采购对医院进行排名。我们收集了每家医院的三个质量维度数据，并在整个区域内进行标准化处理，使其均值为 $0$，标准差为 $1$，从而使这些维度具有可比性：临床结果（$\\mathrm{CO}$，越高越好）、患者体验（$\\mathrm{PX}$，越高越好）以及电子健康记录（EHR）采用率（$\\mathrm{EHR}$，越高越好）。综合评分定义为标准化维度的线性聚合，其使用的非负权重之和为 $1$。\n\n四家医院具有以下标准化值（所有值均为z分数）：\n- 医院 $\\mathrm{P1}$：$\\mathrm{CO}=0.8$，$\\mathrm{PX}=-0.2$，$\\mathrm{EHR}=0.5$。\n- 医院 $\\mathrm{P2}$：$\\mathrm{CO}=0.3$，$\\mathrm{PX}=1.2$，$\\mathrm{EHR}=-0.1$。\n- 医院 $\\mathrm{P3}$：$\\mathrm{CO}=-0.4$，$\\mathrm{PX}=0.1$，$\\mathrm{EHR}=1.3$。\n- 医院 $\\mathrm{P4}$：$\\mathrm{CO}=0.6$，$\\mathrm{PX}=0.4$，$\\mathrm{EHR}=-0.6$。\n\n基线权重向量为 $w=(0.5,\\,0.3,\\,0.2)$，按 $(\\mathrm{CO},\\,\\mathrm{PX},\\,\\mathrm{EHR})$ 的顺序应用。在相同数据下，还考虑了两个备选权重向量：$w^{(1)}=(0.2,\\,0.5,\\,0.3)$ 和 $w^{(2)}=(0.4,\\,0.4,\\,0.2)$。\n\n根据标准化分数无量纲且在线性聚合下可加，以及通过将医院按其综合评分从高到低排序即可产生排名的基本定义，按以下步骤操作：\n1. 计算每家医院在权重 $w$ 下的基线综合评分，并确定由此产生的排名。\n2. 对于每个备选权重 $w^{(1)}$ 和 $w^{(2)}$，计算产生的排名，并通过计算不一致序偶（即在两个排名中相对顺序颠倒的医院对）的数量，将其与基线排名进行比较。\n3. 令 $\\tau^{(1)}$ 和 $\\tau^{(2)}$ 分别表示 $w^{(1)}$ 和 $w^{(2)}$ 的不一致序偶计数。计算总不一致性 $D=\\tau^{(1)}+\\tau^{(2)}$。\n\n将 $D$ 报告为单个实数值。无需四舍五入。最终答案中不要包含任何单位。", "solution": "该问题提法恰当，有科学依据，并包含得出唯一解所需的所有信息。通过标准化变量的加权线性组合创建综合评分的方法是定量分析中的一种标准且有效的技术。\n\n设给定医院 $i$ 的标准化分数为向量 $v_i = (\\mathrm{CO}_i, \\mathrm{PX}_i, \\mathrm{EHR}_i)$。对于给定的权重向量 $w = (w_{\\mathrm{CO}}, w_{\\mathrm{PX}}, w_{\\mathrm{EHR}})$，其综合评分 $S_i$ 计算为点积 $S_i = w \\cdot v_i^{T}$。\n\n四家医院（我们表示为 $P_1, P_2, P_3, P_4$）的数据如下：\n$v_1 = (0.8, -0.2, 0.5)$，对应医院 $P_1$。\n$v_2 = (0.3, 1.2, -0.1)$，对应医院 $P_2$。\n$v_3 = (-0.4, 0.1, 1.3)$，对应医院 $P_3$。\n$v_4 = (0.6, 0.4, -0.6)$，对应医院 $P_4$。\n\n三个权重向量如下：\n基线：$w = (0.5, 0.3, 0.2)$\n备选方案1：$w^{(1)} = (0.2, 0.5, 0.3)$\n备选方案2：$w^{(2)} = (0.4, 0.4, 0.2)$\n\n首先，我们使用基线权重向量 $w$ 计算每家医院的综合评分，并确定由此产生的排名，我们将其表示为 $R$。\n$S_1 = (0.5)(0.8) + (0.3)(-0.2) + (0.2)(0.5) = 0.40 - 0.06 + 0.10 = 0.44$\n$S_2 = (0.5)(0.3) + (0.3)(1.2) + (0.2)(-0.1) = 0.15 + 0.36 - 0.02 = 0.49$\n$S_3 = (0.5)(-0.4) + (0.3)(0.1) + (0.2)(1.3) = -0.20 + 0.03 + 0.26 = 0.09$\n$S_4 = (0.5)(0.6) + (0.3)(0.4) + (0.2)(-0.6) = 0.30 + 0.12 - 0.12 = 0.30$\n将分数从高到低排序得到 $S_2 > S_1 > S_4 > S_3$。\n基线排名为 $R = (P_2, P_1, P_4, P_3)$。\n\n接下来，我们计算第一个备选权重向量 $w^{(1)}$ 的分数和排名，表示为 $R^{(1)}$。\n$S_1^{(1)} = (0.2)(0.8) + (0.5)(-0.2) + (0.3)(0.5) = 0.16 - 0.10 + 0.15 = 0.21$\n$S_2^{(1)} = (0.2)(0.3) + (0.5)(1.2) + (0.3)(-0.1) = 0.06 + 0.60 - 0.03 = 0.63$\n$S_3^{(1)} = (0.2)(-0.4) + (0.5)(0.1) + (0.3)(1.3) = -0.08 + 0.05 + 0.39 = 0.36$\n$S_4^{(1)} = (0.2)(0.6) + (0.5)(0.4) + (0.3)(-0.6) = 0.12 + 0.20 - 0.18 = 0.14$\n将分数从高到低排序得到 $S_2^{(1)} > S_3^{(1)} > S_1^{(1)} > S_4^{(1)}$。\n第一个备选排名为 $R^{(1)} = (P_2, P_3, P_1, P_4)$。\n\n然后，我们计算第二个备选权重向量 $w^{(2)}$ 的分数和排名，表示为 $R^{(2)}$。\n$S_1^{(2)} = (0.4)(0.8) + (0.4)(-0.2) + (0.2)(0.5) = 0.32 - 0.08 + 0.10 = 0.34$\n$S_2^{(2)} = (0.4)(0.3) + (0.4)(1.2) + (0.2)(-0.1) = 0.12 + 0.48 - 0.02 = 0.58$\n$S_3^{(2)} = (0.4)(-0.4) + (0.4)(0.1) + (0.2)(1.3) = -0.16 + 0.04 + 0.26 = 0.14$\n$S_4^{(2)} = (0.4)(0.6) + (0.4)(0.4) + (0.2)(-0.6) = 0.24 + 0.16 - 0.12 = 0.28$\n将分数从高到低排序得到 $S_2^{(2)} > S_1^{(2)} > S_4^{(2)} > S_3^{(2)}$。\n第二个备选排名为 $R^{(2)} = (P_2, P_1, P_4, P_3)$。\n\n下一步是计算基线排名与每个备选排名之间的不一致序偶数量。共有 $\\binom{4}{2} = 6$ 对医院：$(P_1, P_2)$、$(P_1, P_3)$、$(P_1, P_4)$、$(P_2, P_3)$、$(P_2, P_4)$、$(P_3, P_4)$。如果一对医院在两个排名中的相对顺序颠倒，则该序偶为不一致的。\n\n我们首先计算 $\\tau^{(1)}$，即 $R = (P_2, P_1, P_4, P_3)$ 和 $R^{(1)} = (P_2, P_3, P_1, P_4)$ 之间的不一致性。\n- 序偶 $(P_1, P_2)$：在 $R$ 中，$P_2 > P_1$。在 $R^{(1)}$ 中，$P_2 > P_1$。一致。\n- 序偶 $(P_1, P_3)$：在 $R$ 中，$P_1 > P_3$。在 $R^{(1)}$ 中，$P_3 > P_1$。不一致。\n- 序偶 $(P_1, P_4)$：在 $R$ 中，$P_1 > P_4$。在 $R^{(1)}$ 中，$P_1 > P_4$。一致。\n- 序偶 $(P_2, P_3)$：在 $R$ 中，$P_2 > P_3$。在 $R^{(1)}$ 中，$P_2 > P_3$。一致。\n- 序偶 $(P_2, P_4)$：在 $R$ 中，$P_2 > P_4$。在 $R^{(1)}$ 中，$P_2 > P_4$。一致。\n- 序偶 $(P_3, P_4)$：在 $R$ 中，$P_4 > P_3$。在 $R^{(1)}$ 中，$P_3 > P_4$。不一致。\n共有 $2$ 个不一致序偶。因此，$\\tau^{(1)} = 2$。\n\n接下来，我们计算 $\\tau^{(2)}$，即 $R = (P_2, P_1, P_4, P_3)$ 和 $R^{(2)} = (P_2, P_1, P_4, P_3)$ 之间的不一致性。\n这两个排名是相同的。因此，每对医院的相对顺序都保持不变。没有不一致序偶。\n因此，$\\tau^{(2)} = 0$。\n\n最后，总不一致性 $D$ 是 $\\tau^{(1)}$ 和 $\\tau^{(2)}$ 的和。\n$D = \\tau^{(1)} + \\tau^{(2)} = 2 + 0 = 2$。", "answer": "$$\\boxed{2}$$", "id": "4861983"}, {"introduction": "构建医疗服务体系的一个根本挑战是确保人群能够公平、高效地获得医疗服务。本练习将让你扮演一名卫生系统规划者的角色，解决一个经典的设施选址问题。通过实施一个优化模型来决定新诊所的设立地点，你将学习如何运用定量方法来为塑造医疗服务实体基础设施的战略决策提供信息，这些决策直接影响着患者的出行负担和服务可及性 [@problem_id:4861988]。", "problem": "您的任务是为一个医疗服务系统中的社区健康诊所建立一个简化的选址模型，以最小化患者的出行负担。规划区域有 $5$ 个需求节点（社区）和一小组候选诊所位置。每个需求节点 $i$ 都有一个相关的每日需求量 $w_i$（单位：人/天），从需求节点 $i$ 到候选位置 $j$ 的出行距离为 $d_{ij}$（单位：公里）。目标是开设恰好 $p=2$ 个设施，并将每个需求节点分配到其最近的已开设设施，从而使总加权出行距离最小化。\n\n本问题使用的基本原理：\n- 定义由设施 $j$ 服务的需求节点 $i$ 的总出行负效用与出行距离 $d_{ij}$（公里）成正比。\n- 定义每日总出行负担为各需求节点的需求加权距离之和，即对于一个已开设的设施集合 $P \\subseteq \\{0,1,\\dots,M-1\\}$，其中 $|P|=p$，目标是：\n$$\nZ(P) = \\sum_{i=0}^{4} w_i \\cdot \\min_{j \\in P} d_{ij}.\n$$\n该目标遵循标准设施选址原则，即每个需求节点被分配到其最近的已开设设施，以最小化单节点的出行距离。\n- 约束条件：开设恰好 $p=2$ 个设施。\n\n平局决胜规则：\n- 如果有多对设施组合达到了相同的最小目标值 $Z(P)$，则选择索引按升序书写时字典序最小的组合（例如，组合 $[0,2]$ 优于无效的 $[1,1]$，也优于 $[0,3]$）。\n\n所有距离以公里（km）表示。每日需求量 $w_i$ 的单位是人/天。目标值 $Z(P)$ 必须以人·公里/天表示，并报告为四舍五入到三位小数的小数。\n\n您的程序必须解决以下四个独立的测试用例，所有用例均设 $p=2$：\n\n测试用例 1（正常路径覆盖，$M=5$）：\n- 需求权重：\n$$\n\\mathbf{w} = \\begin{bmatrix} 80 \\\\ 50 \\\\ 30 \\\\ 40 \\\\ 60 \\end{bmatrix} \\text{ 人/天}。\n$$\n- 距离矩阵（行为需求节点 $i=0,\\dots,4$；列为候选位置 $j=0,\\dots,4$），单位为公里：\n$$\nD = \\begin{bmatrix}\n2.0  5.5  7.0  3.0  8.0 \\\\\n6.0  2.0  3.5  7.5  4.0 \\\\\n8.5  6.0  2.0  5.0  3.0 \\\\\n3.5  4.5  6.0  2.0  7.0 \\\\\n7.5  3.0  4.0  6.5  2.5\n\\end{bmatrix}.\n$$\n\n测试用例 2（边界情况：存在零需求和相等距离，$M=4$）：\n- 需求权重：\n$$\n\\mathbf{w} = \\begin{bmatrix} 80 \\\\ 0 \\\\ 30 \\\\ 40 \\\\ 60 \\end{bmatrix} \\text{ 人/天}。\n$$\n- 距离矩阵，单位为公里：\n$$\nD = \\begin{bmatrix}\n4.0  5.0  2.5  7.5 \\\\\n3.0  3.0  3.0  3.0 \\\\\n6.0  1.5  5.5  4.0 \\\\\n2.0  2.0  2.0  6.0 \\\\\n7.0  3.5  2.0  2.0\n\\end{bmatrix}.\n$$\n\n测试用例 3（边缘情况：高度倾斜的需求，侧重于单个节点，$M=5$）：\n- 需求权重：\n$$\n\\mathbf{w} = \\begin{bmatrix} 300 \\\\ 50 \\\\ 10 \\\\ 10 \\\\ 10 \\end{bmatrix} \\text{ 人/天}。\n$$\n- 距离矩阵，单位为公里：\n$$\nD = \\begin{bmatrix}\n1.0  5.0  9.0  10.0  8.0 \\\\\n6.0  2.0  3.0  7.0  4.0 \\\\\n6.5  4.5  1.5  5.0  3.5 \\\\\n3.0  5.0  6.0  2.0  7.0 \\\\\n8.0  3.0  4.0  6.5  2.0\n\\end{bmatrix}.\n$$\n\n测试用例 4（边缘情况：对称距离产生多个最优组合，$M=3$）：\n- 需求权重：\n$$\n\\mathbf{w} = \\begin{bmatrix} 20 \\\\ 20 \\\\ 20 \\\\ 20 \\\\ 20 \\end{bmatrix} \\text{ 人/天}。\n$$\n- 距离矩阵，单位为公里：\n$$\nD = \\begin{bmatrix}\n2.0  2.0  5.0 \\\\\n5.0  2.0  2.0 \\\\\n2.0  5.0  2.0 \\\\\n3.0  3.0  3.0 \\\\\n4.0  4.0  4.0\n\\end{bmatrix}.\n$$\n\n您的程序必须：\n- 为每个测试用例枚举所有 $\\binom{M}{2}$ 种索引对。\n- 对于每一对 $P=\\{j_1,j_2\\}$，使用上述公式计算 $Z(P)$。\n- 选择具有最小 $Z(P)$ 的索引对；如果需要，应用平局决胜规则。\n- 输出一行包含所有四个测试用例汇总结果的字符串，格式必须完全如下：\n`[result_case1,result_case2,result_case3,result_case4]`\n其中每个 `result_case$k$` 是一个列表 `[j1,j2,Z]`，$j_1$ 和 $j_2$ 是所选设施的索引（从零开始，按升序排列），$Z$ 是总加权出行距离（单位：人·公里/天），表示为四舍五入到三位小数的十进制数。\n\n所需最终输出结构的示例（值为占位符，并非正确答案）：\n`[[0,3,123.456],[1,2,234.567],[0,4,345.678],[0,1,456.789]]`。", "solution": "已对用户提供的问题进行了分析和验证。\n\n### 步骤 1：提取已知条件\n- **模型**：简化的社区健康诊所布局。\n- **需求节点**：有 $N=5$ 个需求节点（社区），索引为 $i \\in \\{0, 1, 2, 3, 4\\}$。\n- **候选位置**：有 $M$ 个候选诊所位置，索引为 $j \\in \\{0, 1, \\dots, M-1\\}$。\n- **待开设的设施**：恰好开设 $p=2$ 个设施。\n- **需求权重**：每个需求节点 $i$ 的每日需求量为 $w_i$（人/天）。\n- **距离矩阵**：从需求节点 $i$ 到候选位置 $j$ 的出行距离为 $d_{ij}$（公里）。\n- **目标函数**：最小化每日总出行负担，定义为 $Z(P) = \\sum_{i=0}^{4} w_i \\cdot \\min_{j \\in P} d_{ij}$，其中 $P$ 是 $p=2$ 个已开设设施的索引集合。单位是人·公里/天。\n- **平局决胜规则**：如果有多对设施组合产生相同的最小目标值 $Z(P)$，则选择索引字典序最小的组合（例如，$[0,2]$ 优于 $[0,3]$）。\n- **输出精度**：目标值 $Z(P)$ 必须四舍五入到三位小数。\n- **测试用例**：提供了四个不同的测试用例，每个用例都指定了候选位置数量 $M$、需求向量 $\\mathbf{w}$ 和距离矩阵 $D$。\n  - 用例 1：$M=5$，$\\mathbf{w} = [80, 50, 30, 40, 60]^T$，$5 \\times 5$ 的 $D$ 矩阵。\n  - 用例 2：$M=4$，$\\mathbf{w} = [80, 0, 30, 40, 60]^T$，$5 \\times 4$ 的 $D$ 矩阵。\n  - 用例 3：$M=5$，$\\mathbf{w} = [300, 50, 10, 10, 10]^T$，$5 \\times 5$ 的 $D$ 矩阵。\n  - 用例 4：$M=3$，$\\mathbf{w} = [20, 20, 20, 20, 20]^T$，$5 \\times 3$ 的 $D$ 矩阵。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题是一个经典的 p-中位问题，是运筹学、计算几何学和物流学领域一个基础且经过充分研究的模型。其目标函数是在选址分析中用于最小化运输成本或出行负担的标准度量。该模型在科学和数学上是合理的。\n- **适定性**：该问题是适定的。搜索空间由所有可能的设施位置对组成，这是一个有限集。对于任何有限集，连续目标函数都保证存在最小值。明确的平局决胜规则确保了最终解的唯一性。\n- **客观性**：该问题以精确、客观的语言陈述，并带有正式的数学定义。所有数据和约束都已明确给出，没有歧义。\n- **结论**：该问题未违反任何无效性标准。它是一个自洽、一致且可解的科学问题。\n\n### 步骤 3：结论与行动\n问题有效。将提供解决方案。\n\n### 基于原则的设计\n该问题需要从 $M$ 个候选位置中选择一个包含 $p=2$ 个设施位置的子集，以最小化总成本函数。这是一个组合优化问题。对于每个测试用例，候选位置的数量 $M$ 很小（$M \\le 5$）。这允许采用暴力破解方法，即穷举并评估每一种可能的 $p=2$ 个位置的组合。该方法保证能找到全局最优解。\n\n每个测试用例需要检查的总组合数由二项式系数 $\\binom{M}{2}$ 给出：\n- 用例 1 ($M=5$): $\\binom{5}{2} = 10$ 对。\n- 用例 2 ($M=4$): $\\binom{4}{2} = 6$ 对。\n- 用例 3 ($M=5$): $\\binom{5}{2} = 10$ 对。\n- 用例 4 ($M=3$): $\\binom{3}{2} = 3$ 对。\n这种穷举搜索的计算成本可以忽略不计。\n\n解决每个测试用例的算法如下：\n1.  初始化一个用于存储最小目标值的变量 $Z_{min}$ 为正无穷大，以及一个用于存储最佳索引对的空变量 $P_{best}$。\n2.  生成所有唯一的设施索引对 $\\{j_1, j_2\\}$，其中 $0 \\le j_1  j_2  M$。以这种方式生成索引对可确保它们始终按字典序排列。\n3.  对于每个生成的对 $P = \\{j_1, j_2\\}$：\n    a. 计算目标函数值 $Z(P)$。这是通过对 $N=5$ 个需求节点中的每一个，将其加权最小距离求和来完成的：\n    $$Z(P) = \\sum_{i=0}^{4} w_i \\cdot \\min(d_{ij_1}, d_{ij_2})$$\n    b. 将计算出的 $Z(P)$ 与当前最小值 $Z_{min}$ 进行比较。\n    c. 如果 $Z(P)  Z_{min}$，表示找到了一个新的最优解。更新 $Z_{min} = Z(P)$ 和 $P_{best} = \\{j_1, j_2\\}$。\n4.  该过程自然地满足了平局决胜规则。由于索引对是按字典序生成的（例如，$\\{0,1\\}$，然后是 $\\{0,2\\}$ 等），第一个达到最小目标值的对将是字典序最小的。通过仅在找到严格更小的值时（使用 `` 而非 `$\\le$`）进行更新，我们确保了如果后续其他对产生相同的最小值，这个首先找到的最优对仍被保留。\n5.  在评估完所有索引对后，$P_{best}$ 将包含最优设施对的索引，$Z_{min}$ 将是相应的最小总加权出行距离。\n6.  然后按要求将 $Z_{min}$ 的值四舍五入到三位小数。\n\n此过程独立应用于所提供的四个测试用例中的每一个。可以使用向量和矩阵运算（例如，使用 NumPy 库）高效地实现计算。对于给定的索引对 $\\{j_1,j_2\\}$，所有需求节点的最小距离向量可以计算为 $\\mathbf{d_{min}} = \\min(\\mathbf{D}_{:,j_1}, \\mathbf{D}_{:,j_2})$，其中 $\\mathbf{D}_{:,j}$ 是距离矩阵的第 $j$ 列。总成本即为点积 $Z(P) = \\mathbf{w}^T \\mathbf{d_{min}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the facility location problem for four test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"w\": np.array([80, 50, 30, 40, 60]),\n            \"D\": np.array([\n                [2.0, 5.5, 7.0, 3.0, 8.0],\n                [6.0, 2.0, 3.5, 7.5, 4.0],\n                [8.5, 6.0, 2.0, 5.0, 3.0],\n                [3.5, 4.5, 6.0, 2.0, 7.0],\n                [7.5, 3.0, 4.0, 6.5, 2.5]\n            ]),\n            \"p\": 2\n        },\n        # Test case 2\n        {\n            \"w\": np.array([80, 0, 30, 40, 60]),\n            \"D\": np.array([\n                [4.0, 5.0, 2.5, 7.5],\n                [3.0, 3.0, 3.0, 3.0],\n                [6.0, 1.5, 5.5, 4.0],\n                [2.0, 2.0, 2.0, 6.0],\n                [7.0, 3.5, 2.0, 2.0]\n            ]),\n            \"p\": 2\n        },\n        # Test case 3\n        {\n            \"w\": np.array([300, 50, 10, 10, 10]),\n            \"D\": np.array([\n                [1.0, 5.0, 9.0, 10.0, 8.0],\n                [6.0, 2.0, 3.0, 7.0, 4.0],\n                [6.5, 4.5, 1.5, 5.0, 3.5],\n                [3.0, 5.0, 6.0, 2.0, 7.0],\n                [8.0, 3.0, 4.0, 6.5, 2.0]\n            ]),\n            \"p\": 2\n        },\n        # Test case 4\n        {\n            \"w\": np.array([20, 20, 20, 20, 20]),\n            \"D\": np.array([\n                [2.0, 2.0, 5.0],\n                [5.0, 2.0, 2.0],\n                [2.0, 5.0, 2.0],\n                [3.0, 3.0, 3.0],\n                [4.0, 4.0, 4.0]\n            ]),\n            \"p\": 2\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        w = case[\"w\"]\n        D = case[\"D\"]\n        p = case[\"p\"]\n        \n        num_candidates = D.shape[1]\n        candidate_indices = range(num_candidates)\n        \n        best_pair = None\n        min_total_distance = float('inf')\n\n        # Generate all combinations of p facilities\n        # itertools.combinations generates tuples in lexicographical order,\n        # which satisfies the tie-breaking rule.\n        for pair in itertools.combinations(candidate_indices, p):\n            j1, j2 = pair\n            \n            # Extract distance columns for the two selected facilities\n            dist_to_j1 = D[:, j1]\n            dist_to_j2 = D[:, j2]\n            \n            # For each demand node, find the minimum distance to an open facility\n            min_distances = np.minimum(dist_to_j1, dist_to_j2)\n            \n            # Calculate the total weighted distance (objective function Z)\n            current_total_distance = np.dot(w, min_distances)\n            \n            # Check if this pair is a better solution\n            # The strict inequality handles the tie-breaking rule automatically\n            # because pairs are generated in lexicographical order.\n            if current_total_distance  min_total_distance:\n                min_total_distance = current_total_distance\n                best_pair = list(pair)\n\n        # Format the result for the current case\n        j1_res, j2_res = best_pair\n        z_res = round(min_total_distance, 3)\n        \n        # Format the string for the single result\n        result_str = f\"[{j1_res},{j2_res},{z_res:.3f}]\"\n        all_results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "4861988"}]}