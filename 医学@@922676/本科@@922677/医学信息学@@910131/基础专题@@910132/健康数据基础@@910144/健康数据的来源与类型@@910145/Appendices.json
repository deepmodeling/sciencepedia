{"hands_on_practices": [{"introduction": "在任何健康数据分析项目中，数据质量评估都是至关重要的第一步。本练习将介绍两种用于验证原始临床测量数据的基本技术：使用专家定义的规则检查生物学合理性，以及使用稳健的统计方法检测异常值 [@problem_id:4856383]。通过这项实践，你将学会识别和处理错误数据，从而确保后续分析的可靠性。", "problem": "您将收到四个测试用例，每个测试用例包含一个小型结构化临床观察数据的数据集，代表从患者就诊中收集的生命体征。每条记录包含患者年龄（岁）、性别（字符串“M”或“F”）、心率（次/分钟，bpm）、收缩压（毫米汞柱，mmHg）和体温（摄氏度，°C）。所有输入测量值必须被视为带有其指定物理单位的数值量。任务是使用特定年龄和性别的界限计算生物学不合理性率，并通过稳健Z分数实现稳健的离群值检测。输出纯为无单位数值；它必须遵循指定的格式。该场景设定在医学信息学领域，主题为健康数据的来源和类型，重点关注源自临床测量过程的观察性数值数据。\n\n基本原理：\n- 临床观察数据是由测量过程产生的数值测量，会存在误差。观测值需根据随年龄和性别变化的保守参考范围进行生物学合理性评估。\n- 稳健离群值检测使用对极值不那么敏感的统计方法。设 $x_1,\\dots,x_n$ 表示某一生命体征的一组观测值。定义样本中位数为 $m = \\operatorname{median}(x_1,\\dots,x_n)$，中位数绝对偏差 (MAD) 为 $\\operatorname{MAD} = \\operatorname{median}(|x_1 - m|,\\dots,|x_n - m|)$。观测值 $x_i$ 的稳健Z分数为 $z_i = \\dfrac{x_i - m}{c \\cdot \\operatorname{MAD}}$，其中 $c = 1.4826$ 用于缩放 MAD，使其在正态分布模型下成为标准差的一致估计量。一个常用的稳健阈值为 $\\tau = 3.5$，如果 $|z_i| > \\tau$，则将 $x_i$ 分类为离群值。\n\n年龄分组和包含性规则：\n- 使用以下包含性边界定义年龄分组：\n  - 分组 1：$0 \\le a \\le 1$。\n  - 分组 2：$1 < a \\le 5$。\n  - 分组 3：$5 < a \\le 12$。\n  - 分组 4：$12 < a \\le 64$。\n  - 分组 5：$a > 64$。\n- 边界是包含性的：如果一个值位于相应年龄分组和性别的下限和上限（含）之间，则该值被认为是生物学上合理的。\n\n各生命体征、年龄分组和性别的生物学合理范围（根据广泛使用的临床参考文献保守估算）：\n- 心率 (bpm):\n  - 分组 1：“M” 和 “F”：$[70, 190]$。\n  - 分组 2：“M” 和 “F”：$[70, 150]$。\n  - 分组 3：“M” 和 “F”：$[60, 130]$。\n  - 分组 4：“M”：$[50, 110]$，“F”：$[55, 115]$。\n  - 分组 5：“M”：$[50, 120]$，“F”：$[55, 125]$。\n- 收缩压 (mmHg):\n  - 分组 1：“M” 和 “F”：$[50, 100]$。\n  - 分组 2：“M” 和 “F”：$[70, 110]$。\n  - 分组 3：“M” 和 “F”：$[80, 120]$。\n  - 分组 4：“M”：$[90, 140]$，“F”：$[90, 135]$。\n  - 分组 5：“M”：$[100, 160]$，“F”：$[95, 155]$。\n- 体温 (°C):\n  - 分组 1：“M” 和 “F”：$[35.5, 38.5]$。\n  - 分组 2：“M” 和 “F”：$[35.0, 38.2]$。\n  - 分组 3：“M” 和 “F”：$[35.0, 38.0]$。\n  - 分组 4：“M”：$[35.0, 37.8]$，“F”：$[35.0, 37.9]$。\n  - 分组 5：“M” 和 “F”：$[35.0, 37.8]$。\n\n需实现的定义：\n- 对于一个包含 $n$ 条记录的数据集，某个生命体征的不合理性率是分数 $\\dfrac{\\text{值超出特定年龄和性别界限的记录数}}{n}$，四舍五入到四位小数。\n- 对某个生命体征的稳健离群值检测是针对数据集中的所有记录（无论其是否合理）进行的，使用上面定义的稳健Z分数和阈值 $\\tau = 3.5$。计算满足 $|z_i| > \\tau$ 的记录数。如果 $\\operatorname{MAD} = 0$，则将所有 $z_i$ 定义为 0，因此该生命体征的离群值为零。\n\n所需单位和表示：\n- 年龄 $a$ 以年为单位。\n- 心率以次/分钟 (bpm) 为单位。\n- 收缩压以毫米汞柱 (mmHg) 为单位。\n- 体温以摄氏度 (°C) 为单位。\n- 输出值为无量纲数字（不合理性率为浮点数，离群值为整数），程序必须将不合理性率四舍五入到四位小数。\n\n测试套件：\n- 测试用例 1（混合了合理与不合理的值）：\n  - 记录：\n    - $(30,\\ \"M\",\\ 72,\\ 118,\\ 36.8)$。\n    - $(4,\\ \"F\",\\ 140,\\ 95,\\ 37.5)$。\n    - $(75,\\ \"F\",\\ 130,\\ 170,\\ 36.0)$。\n    - $(0.5,\\ \"M\",\\ 200,\\ 45,\\ 39.0)$。\n    - $(12,\\ \"M\",\\ 65,\\ 125,\\ 38.1)$。\n    - $(50,\\ \"F\",\\ 30,\\ 85,\\ 34.5)$。\n    - $(7,\\ \"F\",\\ 95,\\ 100,\\ 37.0)$。\n    - $(68,\\ \"M\",\\ 55,\\ 155,\\ 37.5)$。\n- 测试用例 2（值恰好在边界上）：\n  - 记录：\n    - $(1,\\ \"F\",\\ 70,\\ 100,\\ 38.5)$。\n    - $(5,\\ \"M\",\\ 70,\\ 110,\\ 38.2)$。\n    - $(12,\\ \"F\",\\ 60,\\ 120,\\ 38.0)$。\n    - $(64,\\ \"M\",\\ 110,\\ 140,\\ 37.8)$。\n    - $(65,\\ \"F\",\\ 125,\\ 95,\\ 37.8)$。\n    - $(0.0,\\ \"M\",\\ 190,\\ 50,\\ 35.5)$。\n- 测试用例 3（中位数绝对偏差等于零）：\n  - 记录：\n    - $(30,\\ \"M\",\\ 80,\\ 120,\\ 37.0)$。\n    - $(40,\\ \"F\",\\ 80,\\ 120,\\ 37.0)$。\n    - $(60,\\ \"M\",\\ 80,\\ 120,\\ 37.0)$。\n    - $(20,\\ \"F\",\\ 80,\\ 120,\\ 37.0)$。\n    - $(13,\\ \"M\",\\ 80,\\ 120,\\ 37.0)$。\n- 测试用例 4（所有值均不合理，极端测量值）：\n  - 记录：\n    - $(30,\\ \"M\",\\ 0,\\ 300,\\ 20.0)$。\n    - $(2,\\ \"F\",\\ 10,\\ 200,\\ 45.0)$。\n    - $(80,\\ \"M\",\\ 300,\\ 10,\\ 10.0)$。\n    - $(10,\\ \"F\",\\ 5,\\ 10,\\ 50.0)$。\n\n最终输出规范：\n- 对于每个测试用例，计算一个列表 $[r_{\\text{HR}}, r_{\\text{SBP}}, r_{\\text{TEMP}}, o_{\\text{HR}}, o_{\\text{SBP}}, o_{\\text{TEMP}}]$，其中 $r_{\\cdot}$ 是四舍五入到四位小数的不合理性率，$o_{\\cdot}$ 是整数离群值计数。\n- 您的程序应生成单行输出，其中包含一个 JSON 风格的数组，该数组包含按测试用例顺序排列的各个列表，且不含空格，例如 $[[r_1,r_2,r_3,o_1,o_2,o_3],\\dots]$。\n- 程序必须完全独立，无需外部输入，并遵守所提供的界限和定义。", "solution": "该问题要求为结构化临床观察数据实现两种不同的数据质量评估算法：生物学合理性检查和稳健离群值检测。解决方案涉及处理一组给定的测试用例，每个测试用例包含患者生命体征的记录，并计算指定的指标。\n\n**问题形式化与数据结构**\n每条患者记录是一个包含五个字段的元组：年龄（$a$，单位：年）、性别（$s$，编码为“M”或“F”）、心率（$HR$，单位：bpm）、收缩压（$SBP$，单位：mmHg）和体温（$TEMP$，单位：°C）。问题的核心在于根据这些输入定义和应用规则。\n\n生物学合理性范围以结构化方式提供，取决于年龄和性别。一个适用于这些范围的数据结构是嵌套字典，它将一个生命体征键映射到另一个字典，该字典将一个年龄分组映射到特定性别的下限和上限。例如，`bounds[vital][age_bin][sex]` 将返回一对 `(lower, upper)`。\n\n**1. 生物学合理性评估**\n\n该模块检查观察到的生命体征测量值是否落在生物学上可信的范围内。这些范围取决于患者的年龄和性别。\n\n**1.1. 年龄分组**\n患者年龄（$a$）首先被分类到五个互斥的分组之一，这些分组由包含性边界定义：\n- 分组 1：$0 \\le a \\le 1$\n- 分组 2：$1 < a \\le 5$\n- 分组 3：$5 < a \\le 12$\n- 分组 4：$12 < a \\le 64$\n- 分组 5：$a > 64$\n\n一个输入的年龄被分配到它满足条件的第一个分组。\n\n**1.2. 合理性检查**\n对于每条记录 $(a, s, HR, SBP, TEMP)$，我们确定相应的年龄分组。利用该分组和性别 $s$，我们检索每个生命体征的下限（$L$）和上限（$U$）。如果测量值 $x$ 满足 $L \\le x \\le U$，则认为该值在生物学上是合理的。如果 $x < L$ 或 $x > U$，则将其标记为不合理。\n\n**1.3. 不合理性率计算**\n对于一个包含 $n$ 条记录的数据集和每个生命体征，不合理性率 $r$ 是包含该生命体征不合理值的记录所占的比例。\n$$\nr = \\frac{\\text{不合理记录的数量}}{\\text{记录总数 } n}\n$$\n该比率必须四舍五入到四位小数。例如，值 $0.375$ 将表示为 $0.375$。\n\n**2. 稳健离群值检测**\n\n该模块使用一种能抵抗离群值本身影响的方法，来识别相对于数据集中其余数据而言在统计上极端的观测值。分析是针对一个测试用例中所有记录的每个生命体征的完整测量值集合 $\\{x_1, \\dots, x_n\\}$ 进行的。\n\n**2.1. 稳健Z分数**\n此方法的核心是每个观测值 $x_i$ 的稳健Z分数 $z_i$：\n$$\nz_i = \\frac{x_i - m}{c \\cdot \\text{MAD}}\n$$\n其中：\n- $m = \\operatorname{median}(x_1, \\dots, x_n)$ 是观测值的样本中位数。\n- $\\text{MAD} = \\operatorname{median}(|x_1 - m|, \\dots, |x_n - m|)$ 是中位数绝对偏差，即每个观测值与样本中位数 $m$ 之间绝对差值的中位数。\n- $c = 1.4826$ 是一个缩放常数。该常数使得 MAD 成为正态分布标准差的一致估计量。它源自标准正态累积分布函数的逆函数，具体为 $c = 1 / \\Phi^{-1}(0.75)$。\n\n**2.2. 离群值识别**\n如果观测值 $x_i$ 的稳健Z分数的绝对值超过指定阈值 $\\tau = 3.5$，则将其分类为稳健离群值。\n$$\n|z_i| > 3.5 \\implies x_i \\text{ 是一个离群值}\n$$\n总离群值数量 $o$ 是针对给定生命体征的此类观测值的计数。\n\n针对 $\\text{MAD} = 0$ 的情况定义了一个特殊条件。如果至少一半的数据点与中位数相同，就会发生这种情况。在这种情况下，所有稳健Z分数 $z_i$ 都被定义为 0，从而导致离群值计数 $o=0$。\n\n**3. 算法实现**\n\n对于每个测试用例，总体算法按以下步骤进行：\n1. 为 $HR$、$SBP$ 和 $TEMP$ 初始化不合理性计数器为 $0$。提取每个生命体征的完整值列表。设 $n$ 为记录数。\n2. 遍历每条记录 $(a, s, HR_{val}, SBP_{val}, TEMP_{val})$：\n    a. 确定年龄 $a$ 对应的年龄分组。\n    b. 根据年龄分组和性别 $s$ 检索每个生命体征的合理性界限 $(L, U)$。\n    c. 对每个生命体征，检查其值是否在 $[L, U]$ 之外。如果是，则增加相应的不合理性计数器。\n3. 通过将计数器除以 $n$ 并四舍五入到四位小数，计算不合理性率 $r_{HR}$、$r_{SBP}$、$r_{TEMP}$。\n4. 对于每个生命体征的值列表（例如，所有 $HR$ 值）：\n    a. 计算中位数 $m$ 和 MAD。\n    b. 如果 $\\text{MAD} = 0$，则离群值计数 $o$ 为 $0$。\n    c. 否则，计算每个值 $x_i$ 的稳健Z分数 $z_i$，并计算满足 $|z_i| > 3.5$ 的值的数量。此计数即为 $o$。\n5. 为测试用例组装最终列表：$[r_{HR}, r_{SBP}, r_{TEMP}, o_{HR}, o_{SBP}, o_{TEMP}]$。\n6. 处理完所有测试用例后，将收集到的结果格式化为单个无空格的 JSON 风格数组字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by processing clinical data test cases for biological\n    implausibility and robust outlier detection.\n    \"\"\"\n\n    # Define biological plausibility bounds: vital -> age_bin -> sex -> (lower, upper)\n    bounds = {\n        \"HR\": {\n            1: {\"M\": (70, 190), \"F\": (70, 190)},\n            2: {\"M\": (70, 150), \"F\": (70, 150)},\n            3: {\"M\": (60, 130), \"F\": (60, 130)},\n            4: {\"M\": (50, 110), \"F\": (55, 115)},\n            5: {\"M\": (50, 120), \"F\": (55, 125)},\n        },\n        \"SBP\": {\n            1: {\"M\": (50, 100), \"F\": (50, 100)},\n            2: {\"M\": (70, 110), \"F\": (70, 110)},\n            3: {\"M\": (80, 120), \"F\": (80, 120)},\n            4: {\"M\": (90, 140), \"F\": (90, 135)},\n            5: {\"M\": (100, 160), \"F\": (95, 155)},\n        },\n        \"TEMP\": {\n            1: {\"M\": (35.5, 38.5), \"F\": (35.5, 38.5)},\n            2: {\"M\": (35.0, 38.2), \"F\": (35.0, 38.2)},\n            3: {\"M\": (35.0, 38.0), \"F\": (35.0, 38.0)},\n            4: {\"M\": (35.0, 37.8), \"F\": (35.0, 37.9)},\n            5: {\"M\": (35.0, 37.8), \"F\": (35.0, 37.8)},\n        }\n    }\n\n    test_cases = [\n        # Test Case 1\n        [\n            (30, \"M\", 72, 118, 36.8), (4, \"F\", 140, 95, 37.5),\n            (75, \"F\", 130, 170, 36.0), (0.5, \"M\", 200, 45, 39.0),\n            (12, \"M\", 65, 125, 38.1), (50, \"F\", 30, 85, 34.5),\n            (7, \"F\", 95, 100, 37.0), (68, \"M\", 55, 155, 37.5)\n        ],\n        # Test Case 2\n        [\n            (1, \"F\", 70, 100, 38.5), (5, \"M\", 70, 110, 38.2),\n            (12, \"F\", 60, 120, 38.0), (64, \"M\", 110, 140, 37.8),\n            (65, \"F\", 125, 95, 37.8), (0.0, \"M\", 190, 50, 35.5)\n        ],\n        # Test Case 3\n        [\n            (30, \"M\", 80, 120, 37.0), (40, \"F\", 80, 120, 37.0),\n            (60, \"M\", 80, 120, 37.0), (20, \"F\", 80, 120, 37.0),\n            (13, \"M\", 80, 120, 37.0)\n        ],\n        # Test Case 4\n        [\n            (30, \"M\", 0, 300, 20.0), (2, \"F\", 10, 200, 45.0),\n            (80, \"M\", 300, 10, 10.0), (10, \"F\", 5, 10, 50.0)\n        ]\n    ]\n\n    def get_age_bin(age):\n        if 0 = age = 1: return 1\n        if 1  age = 5: return 2\n        if 5  age = 12: return 3\n        if 12  age = 64: return 4\n        return 5\n\n    def calculate_outliers(data, c=1.4826, tau=3.5):\n        data_arr = np.array(data)\n        median_val = np.median(data_arr)\n        abs_devs = np.abs(data_arr - median_val)\n        mad = np.median(abs_devs)\n\n        if mad == 0:\n            return 0\n        \n        robust_z_scores = abs_devs / (c * mad)\n        outlier_count = np.sum(robust_z_scores > tau)\n        return int(outlier_count)\n\n    all_results = []\n    for case_data in test_cases:\n        n = len(case_data)\n        \n        implausibility_counts = {\"HR\": 0, \"SBP\": 0, \"TEMP\": 0}\n        \n        all_hr = []\n        all_sbp = []\n        all_temp = []\n\n        for record in case_data:\n            age, sex, hr_val, sbp_val, temp_val = record\n            all_hr.append(hr_val)\n            all_sbp.append(sbp_val)\n            all_temp.append(temp_val)\n\n            age_bin = get_age_bin(age)\n            \n            hr_bounds = bounds[\"HR\"][age_bin][sex]\n            if not (hr_bounds[0] = hr_val = hr_bounds[1]):\n                implausibility_counts[\"HR\"] += 1\n\n            sbp_bounds = bounds[\"SBP\"][age_bin][sex]\n            if not (sbp_bounds[0] = sbp_val = sbp_bounds[1]):\n                implausibility_counts[\"SBP\"] += 1\n            \n            temp_bounds = bounds[\"TEMP\"][age_bin][sex]\n            if not (temp_bounds[0] = temp_val = temp_bounds[1]):\n                implausibility_counts[\"TEMP\"] += 1\n\n        r_hr = round(implausibility_counts[\"HR\"] / n, 4)\n        r_sbp = round(implausibility_counts[\"SBP\"] / n, 4)\n        r_temp = round(implausibility_counts[\"TEMP\"] / n, 4)\n\n        o_hr = calculate_outliers(all_hr)\n        o_sbp = calculate_outliers(all_sbp)\n        o_temp = calculate_outliers(all_temp)\n\n        all_results.append([r_hr, r_sbp, r_temp, o_hr, o_sbp, o_temp])\n\n    # Format the final output string as a JSON-style array with no spaces\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "4856383"}, {"introduction": "原始健康数据通常需要经过转换才能用于临床分析。本练习将指导你如何将离散的生命体征测量值（例如血压读数）聚合并标准化，以构建一个纵向的患者轨迹，这是临床研究中分析疾病随时间变化的一项常见任务 [@problem_id:4856328]。这项练习强调了处理真实世界数据复杂性的技能，例如单位转换和处理单次就诊中的多次测量。", "problem": "您将获得一个简化的、关系型视角的电子健康记录 (EHR) 数据，这是医学信息学中结构化健康数据的典型示例。该数据由三个表组成，分别代表不同来源和类型的健康数据：就诊记录 (encounters, 行政/访视记录)、观察记录 (observations, 生命体征和测量值) 和用药记录 (medications, 医嘱)。您的任务是编写一个程序，通过转换和聚合观察记录，计算患者随时间变化的血压轨迹，将其转化为具有临床意义的标量时间序列，并严格遵守单位归一化和处理每次就诊多次测量的既定策略。\n\n基本基础。使用以下基础定义和经过充分检验的事实作为您推导和算法设计的基础：\n- 结构化 EHR 数据表示离散的、编码的字段，如生命体征测量值和时间戳；这些是源自临床就诊的核心健康数据类型。\n- 血压通常记录为收缩压 ($SBP$) 和舒张压 ($DBP$)。脉压定义为 $PP = SBP - DBP$。\n- 平均动脉压 (MAP) 是一种广泛使用的动脉压标量总结，其近似公式为 $MAP = DBP + \\frac{1}{3} \\cdot (SBP - DBP)$。该公式是经过充分检验的临床近似方法。\n- 不同来源的单位可能有所不同；对于血压，常见的单位换算为 $1 \\ \\mathrm{kPa} = 7.500616 \\ \\mathrm{mmHg}$，这是一种线性变换。\n\n模式。考虑以下简化模式：\n- Encounters 表，其行格式为 $(enc\\_id, patient\\_id, start\\_time)$，其中 $start\\_time$ 是一个整数形式的 Unix 纪元时间，单位为秒。\n- Observations 表，其行格式为 $(enc\\_id, patient\\_id, concept, value, unit, obs\\_time)$，其中 $concept \\in \\{\\text{\"SBP\"}, \\text{\"DBP\"}\\}$，$value$ 是数值，$unit \\in \\{\\text{\"mmHg\"}, \\text{\"kPa\"}\\}$，$obs\\_time$ 是整数形式的 Unix 纪元时间，单位为秒。\n- Medications 表，其行格式为 $(enc\\_id, patient\\_id, med\\_code, dose, dose\\_unit)$；包含用药记录是为了反映多个数据源，但计算中不使用。\n\n计算要求和策略。\n1. 单位归一化。将所有观察值转换为 $\\mathrm{mmHg}$。如果 $unit = \\text{\"kPa\"}$，则计算 $value\\_{\\mathrm{mmHg}} = value\\_{\\mathrm{kPa}} \\times c$，其中 $c = 7.500616$。如果 $unit = \\text{\"mmHg\"}$，则保持原值不变。\n2. 每次就诊的多次测量。对于每次就诊，通过中位数汇总所有归一化的 $SBP$ 值，以获得单次就诊的 $SBP$ 总结值；同样地，通过中位数汇总所有归一化的 $DBP$ 值，以获得单次就诊的 $DBP$ 总结值。如果某次就诊缺少 $SBP$ 或 $DBP$ 中的任何一个，则将该次就诊从轨迹中排除，因为无法计算 $MAP$。\n3. 轨迹定义。对于每次同时具有 $SBP$ 和 $DBP$ 的就诊，计算 $MAP = DBP + \\frac{1}{3}(SBP - DBP)$，单位为 $\\mathrm{mmHg}$，并将结果四舍五入到小数点后 $2$ 位。轨迹是这些 $MAP$值的列表，按时间排序。\n4. 时间排序。按 $start\\_time$ 升序排列患者的就诊记录。如果出现时间相同的情况 (即 $start\\_time$ 相同)，则按 $enc\\_id$ 的字典升序来解决。\n5. 最终输出。对于下面的每个测试用例，将患者的 $MAP$ 轨迹输出为一个浮点数列表 (单位为 $\\mathrm{mmHg}$，四舍五入到小数点后 $2$ 位)。程序应生成单行输出，其中包含一个由这些列表组成的、以逗号分隔的列表，并用方括号括起来 (例如，$[\\,[x\\_1,x\\_2],\\,[y\\_1]\\,]$)。不应打印任何其他文本。\n\n角度单位不适用。如果遇到百分比，请将其表示为小数，但本问题不要求处理百分比。\n\n测试套件。您的程序必须为以下四个测试用例计算结果，每个测试用例都明确指定了表的行数据。所有时间均为整数 Unix 纪元秒，所有血压输出必须以 $\\mathrm{mmHg}$ 为单位，并四舍五入到小数点后 $2$ 位。\n\n- 测试用例 1 (理想情况，单位为 $\\mathrm{mmHg}$ 的多次测量)：\n  - Encounters:\n    - $(\"e1\",\"P1\",1000)$\n    - $(\"e2\",\"P1\",2000)$\n  - Observations:\n    - $(\"e1\",\"P1\",\"SBP\",120.0,\"mmHg\",1001)$\n    - $(\"e1\",\"P1\",\"SBP\",124.0,\"mmHg\",1002)$\n    - $(\"e1\",\"P1\",\"DBP\",80.0,\"mmHg\",1001)$\n    - $(\"e1\",\"P1\",\"DBP\",78.0,\"mmHg\",1003)$\n    - $(\"e2\",\"P1\",\"SBP\",130.0,\"mmHg\",2002)$\n    - $(\"e2\",\"P1\",\"SBP\",128.0,\"mmHg\",2003)$\n    - $(\"e2\",\"P1\",\"DBP\",85.0,\"mmHg\",2001)$\n  - Medications: 可能非空，但计算时忽略。\n  - 预期行为：每次就诊的中位数产生有效的 $MAP$ 值，并按 $start\\_time$ 排序。\n\n- 测试用例 2 (混合单位 $\\mathrm{kPa}$ 和 $\\mathrm{mmHg}$，排序敏感性)：\n  - Encounters:\n    - $(\"f2\",\"P2\",1400)$\n    - $(\"f1\",\"P2\",1500)$\n  - Observations:\n    - $(\"f1\",\"P2\",\"SBP\",16.0,\"kPa\",1502)$\n    - $(\"f1\",\"P2\",\"DBP\",10.5,\"kPa\",1501)$\n    - $(\"f2\",\"P2\",\"SBP\",125.0,\"mmHg\",1404)$\n    - $(\"f2\",\"P2\",\"DBP\",82.0,\"mmHg\",1401)$\n  - Medications: 任意行；计算时忽略。\n\n- 测试用例 3 (边界情况：一次就诊中缺少舒张压)：\n  - Encounters:\n    - $(\"g1\",\"P3\",3000)$\n    - $(\"g2\",\"P3\",3100)$\n  - Observations:\n    - $(\"g1\",\"P3\",\"SBP\",110.0,\"mmHg\",3001)$\n    - $(\"g2\",\"P3\",\"SBP\",118.0,\"mmHg\",3103)$\n    - $(\"g2\",\"P3\",\"DBP\",76.0,\"mmHg\",3101)$\n    - $(\"g2\",\"P3\",\"DBP\",78.0,\"mmHg\",3102)$\n  - Medications: 任意行；计算时忽略。\n\n- 测试用例 4 (边界情况：不同就诊记录的 $start\\_time$ 相同，仅有 $\\mathrm{kPa}$ 单位，中位数计算涉及奇数和偶数个数据点)：\n  - Encounters:\n    - $(\"h1\",\"P4\",5000)$\n    - $(\"h2\",\"P4\",5000)$\n  - Observations:\n    - $(\"h1\",\"P4\",\"SBP\",18.0,\"kPa\",5001)$\n    - $(\"h1\",\"P4\",\"SBP\",17.0,\"kPa\",5002)$\n    - $(\"h1\",\"P4\",\"SBP\",19.0,\"kPa\",5003)$\n    - $(\"h1\",\"P4\",\"DBP\",12.0,\"kPa\",5001)$\n    - $(\"h1\",\"P4\",\"DBP\",13.0,\"kPa\",5002)$\n    - $(\"h2\",\"P4\",\"SBP\",17.0,\"kPa\",5004)$\n    - $(\"h2\",\"P4\",\"DBP\",11.0,\"kPa\",5004)$\n  - Medications: 任意行；计算时忽略。\n  - 解决时间冲突：根据 $enc\\_id$ 字典顺序，$\"h1\"$ 排在 $\"h2\"$ 之前。\n\n您的程序必须精确实现上述逻辑，并生成单行输出，其中包含一个包含 $4$ 个元素的列表，每个元素是相应测试用例计算出的 $MAP$ 值列表 (单位为 $\\mathrm{mmHg}$，四舍五入到小数点后 $2$ 位)，并根据所述策略排序。", "solution": "问题陈述已经过验证，被认为是科学可靠、定义明确且完整的。所有必要的数据、公式和处理策略均已提供，足以构建一个唯一且可验证的解决方案。\n\n任务是从结构化的电子健康记录 (EHR) 数据中计算患者随时间变化的血压轨迹。这涉及多个数据转换、聚合和计算步骤，并遵循特定的临床和数据处理策略。整个过程从原始观察数据开始，最终生成一个按时间排序的平均动脉压 ($MAP$) 值序列。\n\n算法流程如下：\n\n1.  **数据结构化与分组：** 第一步是组织原始观察数据。`Observations` 表提供了一个扁平的测量值列表。为了按次就诊进行计算，逻辑上应首先根据相关的就诊标识符 `enc_id` 对这些观察数据进行分组。字典是实现此目的的合适数据结构，其中每个键是 `enc_id`，其值是另一个包含该次就诊的收缩压 ($SBP$) 和舒张压 ($DBP$) 测量值列表的结构。\n\n2.  **单位归一化：** 问题规定，血压值可能使用两种单位之一：毫米汞柱 ($\\mathrm{mmHg}$) 或千帕 ($\\mathrm{kPa}$)。为确保后续计算的一致性，所有测量值必须转换为指定的单一标准单位 $\\mathrm{mmHg}$。给定的换算因子是 $1 \\ \\mathrm{kPa} = 7.500616 \\ \\mathrm{mmHg}$。我们对每个观察值应用此线性变换：\n    $$\n    \\text{value}_{\\mathrm{mmHg}} = \n    \\begin{cases} \n    \\text{value}  \\text{如果 unit} = \\text{\"mmHg\"} \\\\\n    \\text{value} \\times 7.500616  \\text{如果 unit} = \\text{\"kPa\"}\n    \\end{cases}\n    $$\n    此归一化在数据录入和分组时执行，确保后续步骤中使用的所有值都以 $\\mathrm{mmHg}$ 为单位。\n\n3.  **按次就诊的聚合与筛选：** 临床就诊可能包含多次血压测量。策略 #2 要求将这些多次测量值聚合成每次就诊的单个代表性 $SBP$ 和 $DBP$ 值。指定的聚合函数是中位数。对于每次就诊 $i$，我们计算汇总统计量：\n    $$\n    SBP_{\\text{summary}, i} = \\mathrm{median}(\\{ SBP_{i,1}, SBP_{i,2}, \\dots \\})\n    $$\n    $$\n    DBP_{\\text{summary}, i} = \\mathrm{median}(\\{ DBP_{i,1}, DBP_{i,2}, \\dots \\})\n    $$\n    一个关键规则是，如果一次就诊没有至少一个 $SBP$ 测量值 **和** 至少一个 $DBP$ 测量值，则该次就诊对于计算 $MAP$ 无效，必须从最终轨迹中排除。\n\n4.  **平均动脉压 (MAP) 计算：** 对于每个有效的就诊（即同时具有 $SBP$ 和 $DBP$ 总结值的就诊），我们计算 $MAP$。问题提供了标准的临床近似公式：\n    $$\n    MAP = DBP_{\\text{summary}} + \\frac{1}{3} (SBP_{\\text{summary}} - DBP_{\\text{summary}})\n    $$\n    此公式也可以写作 $MAP = \\frac{1}{3} SBP_{\\text{summary}} + \\frac{2}{3} DBP_{\\text{summary}}$。此计算结果以 $\\mathrm{mmHg}$ 为单位，并必须根据策略 #3 四舍五入到小数点后 $2$ 位。\n\n5.  **时间轨迹排序：** 计算出的 $MAP$ 值集合构成了患者的轨迹，但必须按时间顺序排列。策略 #4 指定了一个两级排序程序。主排序键是就诊的 `start_time`，按升序排列。如果出现平局，即两次或多次就诊具有相同的 `start_time`，则通过按 `enc_id` 的字典升序排序来打破平局。这个复合键确保了最终轨迹的确定性和唯一性排序。为实现这一点，我们为所有有效就诊创建一个元组列表，每个元组包含排序键和计算出的 $MAP$ 值，例如 `(start_time, enc_id, MAP_value)`。对此列表进行排序后，我们提取 `MAP_value` 部分，形成最终的有序列表。\n\n通过对每个测试用例执行这些步骤，我们可以生成所需的输出，即一个列表，其中包含为每个患者计算的轨迹。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    \n    # Conversion constant from kPa to mmHg\n    KPA_TO_MMHG = 7.500616\n\n    # Test suite as defined in the problem statement\n    test_cases = [\n        # Test case 1\n        (\n            [(\"e1\", \"P1\", 1000), (\"e2\", \"P1\", 2000)],\n            [\n                (\"e1\", \"P1\", \"SBP\", 120.0, \"mmHg\", 1001),\n                (\"e1\", \"P1\", \"SBP\", 124.0, \"mmHg\", 1002),\n                (\"e1\", \"P1\", \"DBP\", 80.0, \"mmHg\", 1001),\n                (\"e1\", \"P1\", \"DBP\", 78.0, \"mmHg\", 1003),\n                (\"e2\", \"P1\", \"SBP\", 130.0, \"mmHg\", 2002),\n                (\"e2\", \"P1\", \"SBP\", 128.0, \"mmHg\", 2003),\n                (\"e2\", \"P1\", \"DBP\", 85.0, \"mmHg\", 2001),\n            ]\n        ),\n        # Test case 2\n        (\n            [(\"f2\", \"P2\", 1400), (\"f1\", \"P2\", 1500)],\n            [\n                (\"f1\", \"P2\", \"SBP\", 16.0, \"kPa\", 1502),\n                (\"f1\", \"P2\", \"DBP\", 10.5, \"kPa\", 1501),\n                (\"f2\", \"P2\", \"SBP\", 125.0, \"mmHg\", 1404),\n                (\"f2\", \"P2\", \"DBP\", 82.0, \"mmHg\", 1401),\n            ]\n        ),\n        # Test case 3\n        (\n            [(\"g1\", \"P3\", 3000), (\"g2\", \"P3\", 3100)],\n            [\n                (\"g1\", \"P3\", \"SBP\", 110.0, \"mmHg\", 3001),\n                (\"g2\", \"P3\", \"SBP\", 118.0, \"mmHg\", 3103),\n                (\"g2\", \"P3\", \"DBP\", 76.0, \"mmHg\", 3101),\n                (\"g2\", \"P3\", \"DBP\", 78.0, \"mmHg\", 3102),\n            ]\n        ),\n        # Test case 4\n        (\n            [(\"h1\", \"P4\", 5000), (\"h2\", \"P4\", 5000)],\n            [\n                (\"h1\", \"P4\", \"SBP\", 18.0, \"kPa\", 5001),\n                (\"h1\", \"P4\", \"SBP\", 17.0, \"kPa\", 5002),\n                (\"h1\", \"P4\", \"SBP\", 19.0, \"kPa\", 5003),\n                (\"h1\", \"P4\", \"DBP\", 12.0, \"kPa\", 5001),\n                (\"h1\", \"P4\", \"DBP\", 13.0, \"kPa\", 5002),\n                (\"h2\", \"P4\", \"SBP\", 17.0, \"kPa\", 5004),\n                (\"h2\", \"P4\", \"DBP\", 11.0, \"kPa\", 5004),\n            ]\n        )\n    ]\n\n    def process_case(encounters, observations):\n        \"\"\"\n        Processes a single test case to compute the MAP trajectory.\n        \"\"\"\n        \n        # 1. Structure data: map enc_id to start_time and group observations by enc_id\n        enc_info = {enc_id: start_time for enc_id, _, start_time in encounters}\n        \n        obs_by_enc = {}\n        for enc_id, _, concept, value, unit, _ in observations:\n            if enc_id not in obs_by_enc:\n                obs_by_enc[enc_id] = {\"SBP\": [], \"DBP\": []}\n            \n            # 2. Unit normalization to mmHg\n            normalized_value = value\n            if unit == \"kPa\":\n                normalized_value *= KPA_TO_MMHG\n            \n            obs_by_enc[enc_id][concept].append(normalized_value)\n\n        results_to_sort = []\n        for enc_id, pressures in obs_by_enc.items():\n            sbp_values = pressures[\"SBP\"]\n            dbp_values = pressures[\"DBP\"]\n\n            # 3. Filter encounters without both SBP and DBP\n            if not sbp_values or not dbp_values:\n                continue\n\n            # 3. Per-encounter aggregation using median\n            sbp_median = np.median(sbp_values)\n            dbp_median = np.median(dbp_values)\n\n            # 4. MAP Calculation\n            map_val = dbp_median + (sbp_median - dbp_median) / 3.0\n            \n            rounded_map = round(map_val, 2)\n\n            start_time = enc_info[enc_id]\n            results_to_sort.append((start_time, enc_id, rounded_map))\n        \n        # 5. Temporal Ordering\n        # Sort by start_time (primary) and enc_id (secondary)\n        results_to_sort.sort(key=lambda x: (x[0], x[1]))\n        \n        # Extract the sorted MAP values to form the trajectory\n        trajectory = [item[2] for item in results_to_sort]\n        \n        return trajectory\n\n    # Process all test cases\n    final_results = [process_case(enc, obs) for enc, obs in test_cases]\n    \n    # 6. Format final output string as per specifications\n    # e.g., [[93.33,99.67],[96.33,92.51],...]\n    results_as_strings = []\n    for trajectory in final_results:\n        trajectory_str = f\"[{','.join(map(str, trajectory))}]\"\n        results_as_strings.append(trajectory_str)\n        \n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "4856328"}, {"introduction": "医学信息学的一个核心任务是利用现有数据识别具有特定临床状况的患者队列，这通常通过“可计算表型”算法实现。本练习模拟了这一高级过程，你将整合诊断、药物和实验室结果等多种数据源来构建识别2型糖尿病的算法，并使用标准的性能指标（如灵敏度 $S$、阳性预测值 $P$ 和 $F$ 分数）来评估和比较不同算法的性能 [@problem_id:4856368]。这项综合性实践将使你全面体验构建和验证临床算法的过程，这是医学信息学领域的一项核心能力。", "problem": "提供给您一个小型、合成的电子健康记录 (EHR) 数据集，该数据集是根据医学信息学中使用的标准健康数据来源和类型构建的：包括国际疾病分类 (ICD) 诊断代码、抗糖尿病药物处方以及实验室测量值（空腹血糖和糖化血红蛋白 A1c）。您的任务是为 $2$ 型糖尿病实现四种可计算的表型分析算法，并对照病历审查金标准评估每种算法的敏感性和阳性预测值 (PPV)，然后计算 F-score 以支持算法选择。所有计算必须使用集合隶属关系、事件计数和阈值比较，以纯粹的数学和逻辑术语表示。\n\n使用的基本基础：\n- 基于频率概率的混淆矩阵定义：敏感性 (sensitivity) 和阳性预测值 (PPV)。敏感性即召回率 (recall)，PPV 即精确率 (precision)。F-score 是精确率和召回率的调和平均数。\n- 适用于计算的 $2$ 型糖尿病标准临床实验室阈值：糖化血红蛋白阈值 $t_{\\text{A1c}} = 0.065$（A1c 以小数形式表示，不带百分号），以及空腹血糖阈值 $t_{\\text{FPG}} = 126$ mg/dL。\n\n核心定义：\n- 敏感性（召回率）$S = \\dfrac{\\text{TP}}{\\text{TP} + \\text{FN}}$，其中 $\\text{TP}$ 是真阳性，$\\text{FN}$ 是假阴性。\n- 阳性预测值（PPV，精确率）$P = \\dfrac{\\text{TP}}{\\text{TP} + \\text{FP}}$，其中 $\\text{FP}$ 是假阳性。\n- F-score $F = \\dfrac{2 \\cdot P \\cdot S}{P + S}$，当 $P + S  0$ 时，否则 $F = 0$。\n- 边界情况约定：如果 $\\text{TP} + \\text{FN} = 0$，则设敏感性 $S = 0$。如果 $\\text{TP} + \\text{FP} = 0$，则设 PPV $P = 0$。\n\n数据模型和来源类型：\n- 诊断事件：一个由数对 $(c_i, d_i)$ 组成的列表，其中 $c_i$ 是一个 ICD 代码，$d_i$ 是一个日期索引（整数）。$2$ 型糖尿病代码列表为 $\\mathcal{C}_{\\text{T2D}} = \\{\\text{\"E11\"}, \\text{\"E11.9\"}, \\text{\"250.00\"}\\}$。\n- 用药事件：一个由数对 $(m_j, d_j)$ 组成的列表，其中 $m_j$ 是一个药物代码，$d_j$ 是一个日期索引。抗糖尿病药物列表为 $\\mathcal{M}_{\\text{T2D}} = \\{\\text{\"MET\"}, \\text{\"SULF\"}, \\text{\"INS\"}, \\text{\"GLP1\"}\\}$。\n- 实验室测量值：两个列表，A1c 值以数对 $(a_k, d_k)$ 形式表示，$a_k$ 为小数形式；以及空腹血糖值，以数对 $(g_\\ell, d_\\ell)$ 形式表示，$g_\\ell$ 的单位为 mg/dL。\n- 病历审查金标准：每个患者一个布尔标签 $y \\in \\{0,1\\}$，表示患有 ($1$) 或未患有 ($0$) $2$ 型糖尿病。\n\n待实现的表型分析算法：\n- 算法 $\\mathcal{A}$（包含性）：如果满足以下任一条件，则预测为阳性：\n  1. 至少有一次诊断事件的 $c_i \\in \\mathcal{C}_{\\text{T2D}}$。\n  2. 在 $180$ 天内至少有两次抗糖尿病药物事件：存在 $(m_{j_1}, d_{j_1})$ 和 $(m_{j_2}, d_{j_2})$ 满足 $m_{j_1}, m_{j_2} \\in \\mathcal{M}_{\\text{T2D}}$ 且 $|d_{j_2} - d_{j_1}| \\le 180$。\n  3. 任何 A1c 值 $a_k$ 满足 $a_k \\ge t_{\\text{A1c}}$。\n  4. 至少有两个在不同日期的空腹血糖值 $g_{\\ell}$ 满足 $g_{\\ell} \\ge t_{\\text{FPG}}$。\n- 算法 $\\mathcal{B}$（特异性）：如果满足以下任一条件，则预测为阳性：\n  1. 至少有两次在不同日期的诊断事件，其 $c_i \\in \\mathcal{C}_{\\text{T2D}}$。\n  2. 至少有一次抗糖尿病药物事件（$m_j \\in \\mathcal{M}_{\\text{T2D}}$）并且至少满足一项实验室标准阳性：$(\\exists k: a_k \\ge t_{\\text{A1c}})$ 或 $(\\exists \\ell: g_{\\ell} \\ge t_{\\text{FPG}})$。\n  3. 两种实验室检查类型均为阳性：$(\\exists k: a_k \\ge t_{\\text{A1c}})$ 且 $(\\exists \\ell: g_{\\ell} \\ge t_{\\text{FPG}})$。\n- 算法 $\\mathcal{C}$（最小化）：如果存在任何单一信号，则预测为阳性：\n  1. 至少有一次诊断事件的 $c_i \\in \\mathcal{C}_{\\text{T2D}}$。\n  2. 至少有一次抗糖尿病药物事件的 $m_j \\in \\mathcal{M}_{\\text{T2D}}$。\n  3. $(\\exists k: a_k \\ge t_{\\text{A1c}})$。\n  4. $(\\exists \\ell: g_{\\ell} \\ge t_{\\text{FPG}})$。\n- 算法 $\\mathcal{D}$（严格合取）：仅当以下所有条件同时满足时，才预测为阳性：\n  1. 至少有两次在不同日期的诊断事件，其 $c_i \\in \\mathcal{C}_{\\text{T2D}}$。\n  2. 在 $180$ 天内至少有两次抗糖尿病药物事件。\n  3. $(\\exists k: a_k \\ge t_{\\text{A1c}})$。\n  4. 至少有两个在不同日期的空腹血糖值 $g_{\\ell}$ 满足 $g_{\\ell} \\ge t_{\\text{FPG}}$。\n\n测试套件（患者 $1$ 至 $12$）：\n对每位患者，数据以事件和标签的集合形式给出。所有日期索引均为整数；所有 A1c 值为小数；空腹血糖值的单位为 mg/dL。\n\n- 患者 $1$，$y=1$：\n  - 诊断：$(\\text{\"E11\"}, 10)$，$(\\text{\"E11.9\"}, 80)$。\n  - 用药：$(\\text{\"MET\"}, 15)$。\n  - A1c：$(0.072, 12)$。\n  - FPG：$(145, 11)$，$(150, 85)$。\n- 患者 $2$，$y=1$：\n  - 诊断：无。\n  - 用药：$(\\text{\"MET\"}, 5)$，$(\\text{\"MET\"}, 100)$。\n  - A1c：$(0.062, 30)$。\n  - FPG：$(130, 35)$。\n- 患者 $3$，$y=0$：\n  - 诊断：无。\n  - 用药：无。\n  - A1c：$(0.058, 25)$。\n  - FPG：$(110, 27)$。\n- 患者 $4$，$y=1$：\n  - 诊断：无。\n  - 用药：无。\n  - A1c：$(0.068, 44)$。\n  - FPG：$(118, 46)$。\n- 患者 $5$，$y=0$：\n  - 诊断：$(\\text{\"E11\"}, 200)$。\n  - 用药：无。\n  - A1c：$(0.059, 210)$。\n  - FPG：$(115, 212)$。\n- 患者 $6$，$y=1$：\n  - 诊断：无。\n  - 用药：无。\n  - A1c：无。\n  - FPG：$(128, 60)$，$(130, 190)$。\n- 患者 $7$，$y=0$：\n  - 诊断：无。\n  - 用药：$(\\text{\"MET\"}, 300)$。\n  - A1c：$(0.060, 302)$。\n  - FPG：$(100, 303)$。\n- 患者 $8$，$y=1$：\n  - 诊断：$(\\text{\"E11\"}, 120)$。\n  - 用药：无。\n  - A1c：$(0.070, 121)$。\n  - FPG：$(125, 119)$。\n- 患者 $9$，$y=1$：\n  - 诊断：$(\\text{\"E11.9\"}, 50)$。\n  - 用药：$(\\text{\"INS\"}, 51)$，$(\\text{\"MET\"}, 200)$。\n  - A1c：$(0.066, 52)$。\n  - FPG：$(140, 53)$。\n- 患者 $10$，$y=0$：\n  - 诊断：$(\\text{\"E11\"}, 160)$，$(\\text{\"E11.9\"}, 161)$。\n  - 用药：无。\n  - A1c：$(0.061, 162)$。\n  - FPG：$(120, 163)$。\n- 患者 $11$，$y=1$：\n  - 诊断：无。\n  - 用药：$(\\text{\"SULF\"}, 70)$。\n  - A1c：$(0.067, 71)$。\n  - FPG：$(129, 72)$。\n- 患者 $12$，$y=0$：\n  - 诊断：无。\n  - 用药：无。\n  - A1c：$(0.064, 15)$。\n  - FPG：$(125, 16)$。\n\n要求：\n1. 使用给定的代码列表和实验室阈值 $t_{\\text{A1c}} = 0.065$ 及 $t_{\\text{FPG}} = 126$ mg/dL，完全按照上述定义实现四种算法 $\\mathcal{A}$、$\\mathcal{B}$、$\\mathcal{C}$ 和 $\\mathcal{D}$。\n2. 对每种算法，对照 $12$ 位患者的病历审查金标准，计算敏感性 $S$、PPV $P$ 和 F-score $F$。应用上述指定的分母为零的边界情况约定。\n3. 将每个 $S$、$P$ 和 $F$ 值四舍五入到小数点后 $3$ 位。\n4. 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。第 $i$ 个元素必须是算法 $i$ 的列表 $[S_i,P_i,F_i]$，顺序为 $\\mathcal{A}, \\mathcal{B}, \\mathcal{C}, \\mathcal{D}$。例如，输出必须看起来像 $[[S_{\\mathcal{A}},P_{\\mathcal{A}},F_{\\mathcal{A}}],[S_{\\mathcal{B}},P_{\\mathcal{B}},F_{\\mathcal{B}}],[S_{\\mathcal{C}},P_{\\mathcal{C}},F_{\\mathcal{C}}],[S_{\\mathcal{D}},P_{\\mathcal{D}},F_{\\mathcal{D}}]]$。", "solution": "用户提供的问题陈述内部一致，在医学信息学领域具有科学依据，且定义明确。获得唯一解所需的所有数据、定义、阈值和逻辑规则都已明确提供。该问题是实现和评估可计算表型分析算法的一项有效练习。因此，有理由提供一个完整的解决方案。\n\n任务是为 $2$ 型糖尿病实现四种不同的可计算表型分析算法（$\\mathcal{A}$、$\\mathcal{B}$、$\\mathcal{C}$ 和 $\\mathcal{D}$），将它们应用于一个包含 $12$ 名合成患者的数据集，并对照金标准评估其性能。需要计算的性能指标是敏感性 ($S$)、阳性预测值 ($P$) 和 F-score ($F$)。\n\n首先，我们将给定的参数和定义形式化。\n实验室阈值为 $t_{\\text{A1c}} = 0.065$ 和 $t_{\\text{FPG}} = 126$ mg/dL。\n相关 ICD 代码集为 $\\mathcal{C}_{\\text{T2D}} = \\{\\text{\"E11\"}, \\text{\"E11.9\"}, \\text{\"250.00\"}\\}$。\n相关抗糖尿病药物集为 $\\mathcal{M}_{\\text{T2D}} = \\{\\text{\"MET\"}, \\text{\"SULF\"}, \\text{\"INS\"}, \\text{\"GLP1\"}\\}$。\n患者 $p$ 的金标准表示为 $y_p \\in \\{0, 1\\}$。算法的预测为 $\\hat{y}_p \\in \\{0, 1\\}$。\n\n评估指标定义如下：\n- 敏感性：$S = \\dfrac{\\text{TP}}{\\text{TP} + \\text{FN}}$\n- 阳性预测值 (PPV)：$P = \\dfrac{\\text{TP}}{\\text{TP} + \\text{FP}}$\n- F-score：$F = \\dfrac{2 \\cdot P \\cdot S}{P + S}$\n\n此处，$\\text{TP}$ 是真阳性（$\\hat{y}_p = 1, y_p = 1$）的数量，$\\text{FP}$ 是假阳性（$\\hat{y}_p = 1, y_p = 0$）的数量，$\\text{FN}$ 是假阴性（$\\hat{y}_p = 0, y_p = 1$）的数量。边界情况通过以下方式处理：如果 $\\text{TP} + \\text{FN} = 0$，则设 $S=0$；如果 $\\text{TP} + \\text{FP} = 0$，则设 $P=0$；如果 $P+S=0$，则设 $F=0$。\n\n为了系统地应用这些算法，我们根据每个患者的数据定义一组二元特征指示符：\n1.  $f_{\\text{dx1}}(p)$：如果患者在 $\\mathcal{C}_{\\text{T2D}}$ 中至少有一次诊断，则为真。\n2.  $f_{\\text{dx2}}(p)$：如果患者在不同日期在 $\\mathcal{C}_{\\text{T2D}}$ 中至少有两次诊断，则为真。\n3.  $f_{\\text{med1}}(p)$：如果患者在 $\\mathcal{M}_{\\text{T2D}}$ 中至少有一次用药，则为真。\n4.  $f_{\\text{med2}}(p)$：如果患者在 $\\mathcal{M}_{\\text{T2D}}$ 中至少有两次用药，其处方日期 $d_{j_1}, d_{j_2}$ 满足 $|d_{j_2} - d_{j_1}| \\le 180$，则为真。\n5.  $f_{\\text{a1c}}(p)$：如果患者有任何 A1c 测量值 $a_k \\ge t_{\\text{A1c}}$，则为真。\n6.  $f_{\\text{fpg1}}(p)$：如果患者有任何空腹血糖测量值 $g_\\ell \\ge t_{\\text{FPG}}$，则为真。\n7.  $f_{\\text{fpg2}}(p)$：如果患者在不同日期至少有两次空腹血糖测量值 $g_\\ell \\ge t_{\\text{FPG}}$，则为真。\n\n使用这些指示符，算法定义如下：\n-   $\\mathcal{A}(p) = f_{\\text{dx1}}(p) \\lor f_{\\text{med2}}(p) \\lor f_{\\text{a1c}}(p) \\lor f_{\\text{fpg2}}(p)$\n-   $\\mathcal{B}(p) = f_{\\text{dx2}}(p) \\lor (f_{\\text{med1}}(p) \\land (f_{\\text{a1c}}(p) \\lor f_{\\text{fpg1}}(p))) \\lor (f_{\\text{a1c}}(p) \\land f_{\\text{fpg1}}(p))$\n-   $\\mathcal{C}(p) = f_{\\text{dx1}}(p) \\lor f_{\\text{med1}}(p) \\lor f_{\\text{a1c}}(p) \\lor f_{\\text{fpg1}}(p)$\n-   $\\mathcal{D}(p) = f_{\\text{dx2}}(p) \\land f_{\\text{med2}}(p) \\land f_{\\text{a1c}}(p) \\land f_{\\text{fpg2}}(p)$\n\n我们为 12 位患者中的每一位评估这些特征：\n\n| 患者 ($p$) | $y_p$ | $f_{\\text{dx1}}$ | $f_{\\text{dx2}}$ | $f_{\\text{med1}}$ | $f_{\\text{med2}}$ | $f_{\\text{a1c}}$ | $f_{\\text{fpg1}}$ | $f_{\\text{fpg2}}$ |\n|:-------------:|:-----:|:----------------:|:----------------:|:-----------------:|:-----------------:|:----------------:|:------------------:|:------------------:|\n| 1             | 1     | T                | T                | T                 | F                 | T                | T                  | T                  |\n| 2             | 1     | F                | F                | T                 | T                 | F                | T                  | F                  |\n| 3             | 0     | F                | F                | F                 | F                 | F                | F                  | F                  |\n| 4             | 1     | F                | F                | F                 | F                 | T                | F                  | F                  |\n| 5             | 0     | T                | F                | F                 | F                 | F                | F                  | F                  |\n| 6             | 1     | F                | F                | F                 | F                 | F                | T                  | T                  |\n| 7             | 0     | F                | F                | T                 | F                 | F                | F                  | F                  |\n| 8             | 1     | T                | F                | F                 | F                 | T                | F                  | F                  |\n| 9             | 1     | T                | F                | T                 | T                 | T                | T                  | F                  |\n| 10            | 0     | T                | T                | F                 | F                 | F                | F                  | F                  |\n| 11            | 1     | F                | F                | T                 | F                 | T                | T                  | F                  |\n| 12            | 0     | F                | F                | F                 | F                 | F                | F                  | F                  |\n\n金标准中的阳性病例总数为 $N_P = \\text{TP} + \\text{FN} = 7$。\n阴性病例总数为 $N_N = \\text{FP} + \\text{TN} = 5$。\n\n接下来，我们确定每个算法对每个患者的预测 $\\hat{y}_p$，然后计算混淆矩阵的元素。\n\n**算法 $\\mathcal{A}$ 评估：**\n- 预测 ($\\hat{y}_{\\mathcal{A}}$)：P1(1), P2(1), P3(0), P4(1), P5(1), P6(1), P7(0), P8(1), P9(1), P10(1), P11(1), P12(0)。\n- $\\text{TP} = 7$ (P1, P2, P4, P6, P8, P9, P11)\n- $\\text{FP} = 2$ (P5, P10)\n- $\\text{TN} = 3$ (P3, P7, P12)\n- $\\text{FN} = 0$\n- $S = \\frac{7}{7+0} = 1.0$\n- $P = \\frac{7}{7+2} = \\frac{7}{9} \\approx 0.778$\n- $F = \\frac{2 \\cdot 0.778 \\cdot 1.0}{0.778 + 1.0} = \\frac{1.556}{1.778} \\approx 0.875$\n\n**算法 $\\mathcal{B}$ 评估：**\n- 预测 ($\\hat{y}_{\\mathcal{B}}$)：P1(1), P2(1), P3(0), P4(0), P5(0), P6(0), P7(0), P8(0), P9(1), P10(1), P11(1), P12(0)。\n- $\\text{TP} = 4$ (P1, P2, P9, P11)\n- $\\text{FP} = 1$ (P10)\n- $\\text{TN} = 4$ (P3, P5, P7, P12)\n- $\\text{FN} = 3$ (P4, P6, P8)\n- $S = \\frac{4}{4+3} = \\frac{4}{7} \\approx 0.571$\n- $P = \\frac{4}{4+1} = \\frac{4}{5} = 0.8$\n- $F = \\frac{2 \\cdot 0.8 \\cdot 0.571}{0.8 + 0.571} = \\frac{0.9136}{1.371} \\approx 0.667$\n\n**算法 $\\mathcal{C}$ 评估：**\n- 预测 ($\\hat{y}_{\\mathcal{C}}$)：P1(1), P2(1), P3(0), P4(1), P5(1), P6(1), P7(1), P8(1), P9(1), P10(1), P11(1), P12(0)。\n- $\\text{TP} = 7$ (P1, P2, P4, P6, P8, P9, P11)\n- $\\text{FP} = 3$ (P5, P7, P10)\n- $\\text{TN} = 2$ (P3, P12)\n- $\\text{FN} = 0$\n- $S = \\frac{7}{7+0} = 1.0$\n- $P = \\frac{7}{7+3} = \\frac{7}{10} = 0.7$\n- $F = \\frac{2 \\cdot 0.7 \\cdot 1.0}{0.7 + 1.0} = \\frac{1.4}{1.7} \\approx 0.824$\n\n**算法 $\\mathcal{D}$ 评估：**\n- 预测 ($\\hat{y}_{\\mathcal{D}}$)：P1(0), P2(0), P3(0), P4(0), P5(0), P6(0), P7(0), P8(0), P9(0), P10(0), P11(0), P12(0)。\n- $\\text{TP} = 0$\n- $\\text{FP} = 0$\n- $\\text{TN} = 5$ (P3, P5, P7, P10, P12)\n- $\\text{FN} = 7$ (P1, P2, P4, P6, P8, P9, P11)\n- $S = \\frac{0}{0+7} = 0.0$\n- $P = \\frac{0}{0+0} = 0.0$（根据边界情况规则）\n- $F = 0.0$（因为 $P+S=0$）\n\n最终结果四舍五入到小数点后 $3$ 位，如下所示：\n- 算法 $\\mathcal{A}$：$[S, P, F] = [1.000, 0.778, 0.875]$\n- 算法 $\\mathcal{B}$：$[S, P, F] = [0.571, 0.800, 0.667]$\n- 算法 $\\mathcal{C}$：$[S, P, F] = [1.000, 0.700, 0.824]$\n- 算法 $\\mathcal{D}$：$[S, P, F] = [0.000, 0.000, 0.000]$\n\n这些结果将被格式化为最终输出所需的列表的列表。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Implements and evaluates four computable phenotyping algorithms for Type 2 Diabetes.\n    \"\"\"\n    \n    # Define constants and code lists\n    C_T2D = {\"E11\", \"E11.9\", \"250.00\"}\n    M_T2D = {\"MET\", \"SULF\", \"INS\", \"GLP1\"}\n    T_A1C = 0.065\n    T_FPG = 126\n\n    # Test suite data for 12 patients\n    test_cases = [\n        {\"id\": 1, \"y\": 1, \"dx\": [(\"E11\", 10), (\"E11.9\", 80)], \"med\": [(\"MET\", 15)], \"a1c\": [(0.072, 12)], \"fpg\": [(145, 11), (150, 85)]},\n        {\"id\": 2, \"y\": 1, \"dx\": [], \"med\": [(\"MET\", 5), (\"MET\", 100)], \"a1c\": [(0.062, 30)], \"fpg\": [(130, 35)]},\n        {\"id\": 3, \"y\": 0, \"dx\": [], \"med\": [], \"a1c\": [(0.058, 25)], \"fpg\": [(110, 27)]},\n        {\"id\": 4, \"y\": 1, \"dx\": [], \"med\": [], \"a1c\": [(0.068, 44)], \"fpg\": [(118, 46)]},\n        {\"id\": 5, \"y\": 0, \"dx\": [(\"E11\", 200)], \"med\": [], \"a1c\": [(0.059, 210)], \"fpg\": [(115, 212)]},\n        {\"id\": 6, \"y\": 1, \"dx\": [], \"med\": [], \"a1c\": [], \"fpg\": [(128, 60), (130, 190)]},\n        {\"id\": 7, \"y\": 0, \"dx\": [], \"med\": [(\"MET\", 300)], \"a1c\": [(0.060, 302)], \"fpg\": [(100, 303)]},\n        {\"id\": 8, \"y\": 1, \"dx\": [(\"E11\", 120)], \"med\": [], \"a1c\": [(0.070, 121)], \"fpg\": [(125, 119)]},\n        {\"id\": 9, \"y\": 1, \"dx\": [(\"E11.9\", 50)], \"med\": [(\"INS\", 51), (\"MET\", 200)], \"a1c\": [(0.066, 52)], \"fpg\": [(140, 53)]},\n        {\"id\": 10, \"y\": 0, \"dx\": [(\"E11\", 160), (\"E11.9\", 161)], \"med\": [], \"a1c\": [(0.061, 162)], \"fpg\": [(120, 163)]},\n        {\"id\": 11, \"y\": 1, \"dx\": [], \"med\": [(\"SULF\", 70)], \"a1c\": [(0.067, 71)], \"fpg\": [(129, 72)]},\n        {\"id\": 12, \"y\": 0, \"dx\": [], \"med\": [], \"a1c\": [(0.064, 15)], \"fpg\": [(125, 16)]},\n    ]\n\n    # --- Helper functions for algorithm conditions ---\n    def f_dx1(p): return any(c in C_T2D for c, d in p[\"dx\"])\n    def f_dx2(p):\n        t2d_dx_days = {d for c, d in p[\"dx\"] if c in C_T2D}\n        return len(t2d_dx_days) >= 2\n    def f_med1(p): return any(m in M_T2D for m, d in p[\"med\"])\n    def f_med2(p):\n        t2d_meds = [(m, d) for m, d in p[\"med\"] if m in M_T2D]\n        if len(t2d_meds)  2: return False\n        return any(abs(d1 - d2) = 180 for (_, d1), (_, d2) in combinations(t2d_meds, 2))\n    def f_a1c(p): return any(a >= T_A1C for a, d in p[\"a1c\"])\n    def f_fpg1(p): return any(g >= T_FPG for g, d in p[\"fpg\"])\n    def f_fpg2(p):\n        high_fpg_days = {d for g, d in p[\"fpg\"] if g >= T_FPG}\n        return len(high_fpg_days) >= 2\n\n    # --- Phenotyping Algorithms ---\n    def algo_A(p): return f_dx1(p) or f_med2(p) or f_a1c(p) or f_fpg2(p)\n    def algo_B(p): return f_dx2(p) or (f_med1(p) and (f_a1c(p) or f_fpg1(p))) or (f_a1c(p) and f_fpg1(p))\n    def algo_C(p): return f_dx1(p) or f_med1(p) or f_a1c(p) or f_fpg1(p)\n    def algo_D(p): return f_dx2(p) and f_med2(p) and f_a1c(p) and f_fpg2(p)\n\n    algorithms = [algo_A, algo_B, algo_C, algo_D]\n    all_results = []\n\n    for algo in algorithms:\n        tp, fp, tn, fn = 0, 0, 0, 0\n        for patient in test_cases:\n            y_true = patient[\"y\"]\n            y_pred = 1 if algo(patient) else 0\n            \n            if y_pred == 1 and y_true == 1:\n                tp += 1\n            elif y_pred == 1 and y_true == 0:\n                fp += 1\n            elif y_pred == 0 and y_true == 0:\n                tn += 1\n            elif y_pred == 0 and y_true == 1:\n                fn += 1\n\n        # Calculate metrics with edge-case handling\n        sensitivity = tp / (tp + fn) if (tp + fn) > 0 else 0.0\n        ppv = tp / (tp + fp) if (tp + fp) > 0 else 0.0\n        f_score = (2 * ppv * sensitivity) / (ppv + sensitivity) if (ppv + sensitivity) > 0 else 0.0\n        \n        # Round to 3 decimal places\n        s_rounded = round(sensitivity, 3)\n        p_rounded = round(ppv, 3)\n        f_rounded = round(f_score, 3)\n        \n        # Ensure floating point representation\n        all_results.append([float(s_rounded), float(p_rounded), float(f_rounded)])\n\n    # Format the final output string\n    # Using a nested list comprehension and str.format for precise output\n    result_str = '[' + ','.join([f'[{s},{p},{f}]' for s, p, f in all_results]) + ']'\n    print(result_str)\n\nsolve()\n```", "id": "4856368"}]}