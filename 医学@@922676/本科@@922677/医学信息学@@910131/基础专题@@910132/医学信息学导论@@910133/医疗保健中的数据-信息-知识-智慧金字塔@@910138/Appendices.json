{"hands_on_practices": [{"introduction": "在医疗保健领域，一项核心任务是解释临床数据以辅助决策。本练习将通过一个经典的诊断测试场景，演示如何运用贝叶斯定理，将原始的观测结果（数据）和已知的测试性能（信息）合成为具有临床意义的知识——即患者患有某种疾病的后验概率。掌握这一过程是循证医学和构建智能诊断支持系统的基石。[@problem_id:4860486]", "problem": "一家医院实验室正在评估一项二元筛选测试，该测试是数据、信息、知识、智慧（DIKW）流水线的一部分。在这个流水线中，关于测试结果和疾病状态的原始观测数据（数据）被总结为操作特性（信息），然后结合基线患病率等背景信息，生成后验概率（知识），最终用于指导临床行动（智慧）。设 $D$ 表示随机选择的一名患者确实患有该疾病的事件，设 $+$ 表示测试结果为阳性的事件。已知该测试的灵敏度为 $0.85$，特异度为 $0.90$，目标人群中的疾病患病率为 $0.20$。\n\n请仅从条件概率的定义 $P(A \\mid B) = \\frac{P(A \\cap B)}{P(B)}$ 和全概率定律 $P(B) = P(B \\mid A)P(A) + P(B \\mid \\overline{A})P(\\overline{A})$ 出发，推导后验概率 $P(D \\mid +)$ 的一般表达式，该表达式应使用 $P(+ \\mid D)$、$P(+ \\mid \\overline{D})$、$P(D)$ 和 $P(\\overline{D})$ 来表示。然后，利用给定的灵敏度、特异度和患病率值，计算 $P(D \\mid +)$ 的数值。将您的最终答案表示为精确分数。不要包含单位，也不要进行四舍五入。", "solution": "问题要求推导在给定阳性测试结果下患有疾病的后验概率 $P(D \\mid +)$ 的表达式，然后使用所提供的数据计算其数值。推导过程必须从条件概率的基本定义和全概率定律开始。\n\n首先，让我们将给定的信息形式化。\n设 $D$ 为患者患有该疾病的事件。\n设 $\\overline{D}$ 为患者未患该疾病的事件。\n设 $+$ 为测试结果为阳性的事件。\n设 $-$ 为测试结果为阴性的事件。\n\n问题提供了以下量：\n1.  测试的灵敏度，即在患者患有疾病的条件下测试结果为阳性的概率：$P(+ \\mid D) = 0.85$。\n2.  测试的特异度，即在患者未患疾病的条件下测试结果为阴性的概率：$P(- \\mid \\overline{D}) = 0.90$。\n3.  人群中的疾病患病率，即患者患有该疾病的先验概率：$P(D) = 0.20$。\n\n推导需从两个给定的原则开始：\n1.  条件概率的定义：$P(A \\mid B) = \\frac{P(A \\cap B)}{P(B)}$。\n2.  全概率定律：$P(B) = P(B \\mid A)P(A) + P(B \\mid \\overline{A})P(\\overline{A})$。\n\n我们的目标是推导 $P(D \\mid +)$ 的表达式。使用条件概率的定义，我们可以写出：\n$$\nP(D \\mid +) = \\frac{P(D \\cap +)}{P(+)}\n$$\n符号 $P(D \\cap +)$ 表示患者患有疾病且测试结果为阳性的联合概率。分子可以使用 $P(+ \\mid D)$ 的条件概率定义来重新表达：\n$$\nP(+ \\mid D) = \\frac{P(+ \\cap D)}{P(D)}\n$$\n由于交集运算符是可交换的，所以 $P(+ \\cap D) = P(D \\cap +)$。重新整理这个方程，得到分子的表达式：\n$$\nP(D \\cap +) = P(+ \\mid D) P(D)\n$$\n现在，我们来处理分母 $P(+)$，即测试结果为阳性的总概率。我们使用全概率定律，将样本空间划分为事件 $D$（患病）和 $\\overline{D}$（不患病）。将该定律应用于事件 $+$，我们得到：\n$$\nP(+) = P(+ \\mid D)P(D) + P(+ \\mid \\overline{D})P(\\overline{D})\n$$\n将分子 $P(D \\cap +)$ 和分母 $P(+)$ 的表达式代入我们最初的 $P(D \\mid +)$ 方程，我们得到一般表达式：\n$$\nP(D \\mid +) = \\frac{P(+ \\mid D) P(D)}{P(+ \\mid D)P(D) + P(+ \\mid \\overline{D})P(\\overline{D})}\n$$\n这个表达式是贝叶斯定理的一种形式，按要求从基本原理推导得出。\n\n接下来，我们使用给定的数据计算 $P(D \\mid +)$ 的数值。我们有：\n- $P(+ \\mid D) = 0.85$ (灵敏度)\n- $P(D) = 0.20$ (患病率)\n\n我们还需要 $P(+ \\mid \\overline{D})$ 和 $P(\\overline{D})$ 的值。\n不患病的概率是患病率的补集：\n$$\nP(\\overline{D}) = 1 - P(D) = 1 - 0.20 = 0.80\n$$\n在没有疾病的情况下测试结果为阳性的概率 $P(+ \\mid \\overline{D})$，被称为假阳性率。它是特异度 $P(- \\mid \\overline{D})$ 的补集：\n$$\nP(+ \\mid \\overline{D}) = 1 - P(- \\mid \\overline{D}) = 1 - 0.90 = 0.10\n$$\n现在我们可以将所有数值代入推导出的公式中：\n$$\nP(D \\mid +) = \\frac{(0.85) \\times (0.20)}{(0.85) \\times (0.20) + (0.10) \\times (0.80)}\n$$\n让我们计算乘积：\n- 分子：$0.85 \\times 0.20 = 0.17$\n- 分母中的第一项：$0.85 \\times 0.20 = 0.17$\n- 分母中的第二项：$0.10 \\times 0.80 = 0.08$\n\n将这些结果代回方程：\n$$\nP(D \\mid +) = \\frac{0.17}{0.17 + 0.08} = \\frac{0.17}{0.25}\n$$\n为了将其表示为精确分数，我们可以将小数值写成分数形式并化简：\n$$\nP(D \\mid +) = \\frac{\\frac{17}{100}}{\\frac{25}{100}} = \\frac{17}{100} \\times \\frac{100}{25} = \\frac{17}{25}\n$$\n因此，在给定阳性测试结果的情况下，患有该疾病的后验概率为 $\\frac{17}{25}$。这个结果代表了DIKW金字塔中的“知识”步骤，其中原始数据（个体结果）和信息（灵敏度、特异度、患病率）被综合起来，以生成一个具有临床意义的概率。", "answer": "$$\n\\boxed{\\frac{17}{25}}\n$$", "id": "4860486"}, {"introduction": "大部分的医疗数据并非整齐的表格，而是以临床笔记等非结构化文本形式存在。本练习将带你进入自然语言处理（NLP）的世界，展示如何应用特定规则（知识）将原始文本（数据）转换为结构化的断言（信息），例如判断一个症状是被确认存在还是被明确排除了。这项技能对于从电子健康记录（EHR）中释放巨大价值至关重要。[@problem_id:4860503]", "problem": "您将获得一组从电子健康记录（EHR）中提取的简短临床陈述。分析目标是通过设计和评估一个基于规则的自然语言处理（NLP）组件，来展示医疗保健领域的数据、信息、知识、智慧（DIKW）金字塔。该组件将原始文本（$data$）转换为结构化断言（$information$），支持表型决策函数（$knowledge$），并对规则的适用性及其预期影响产生评估性见解（$wisdom$）。我们关注的表型是当前是否存在肺炎。您必须专门为短语“no evidence of pneumonia”构建一个否定范围检测算法，并评估其相对于朴素基线的表型特异性和敏感性的影响。\n\n基本基础：\n- 临床语言学惯例：短语“no evidence of $X$”表示在所描述的上下文中不存在$X$；这是临床放射学和评估记录中广泛接受的文档模式。\n- 混淆矩阵定义：对于二元分类器，一个带标签的案例数据集会产生真阳性（TP）、假阳性（FP）、真阴性（TN）、假阴性（FN）的计数。敏感性和特异性定义如下\n$$\\text{sensitivity} = \\frac{TP}{TP + FN}, \\quad \\text{specificity} = \\frac{TN}{TN + FP}.$$\n- 将文本分词为序列的过程被建模为根据字母单词和子句边界标点符号对字符串进行分割。\n\n形式化：\n- 设临床陈述为有限字母表上的字符串$S$。经过小写转换和分词后，$S$被映射为一个词元序列$\\{t_1, t_2, \\dots, t_n\\}$，其中每个$t_i$要么是一个字母单词，要么是边界符号$\\{',',';','.'\\}$之一。\n- 定义边界集 $B = \\{ \\text{'but'}, \\text{'however'}, ',', ';', '.' \\}$。边界词元用于为确定范围而切分子句。\n- 定义朴素表型检测器$g(S)$，当且仅当任何词元等于单词“pneumonia”时返回$1$（表型存在）；否则返回$0$。\n- 定义改进的检测器$h(S)$，当且仅当存在至少一个等于“pneumonia”的词元，且该词元不在任何连续出现的三词元短语“no evidence of”的前向范围内时，返回$1$。形式上，对于任何满足$(t_k, t_{k+1}, t_{k+2}) = (\\text{no}, \\text{evidence}, \\text{of})$的索引$k$，定义其前向范围区间为$I_k = \\{ k+3, k+4, \\dots, m-1 \\}$，其中$m$是满足$t_m \\in B$的最小索引（$\\ge k+3$），如果不存在这样的边界，则$m=n+1$。位于位置$j$的词元“pneumonia”被认为是已否定的，如果存在一个$k$使得$j \\in I_k$。如果存在某个位置$j$处的“pneumonia”词元未被否定，则函数$h(S)$输出$1$；否则输出$0$。\n\n您必须实现$g(S)$和$h(S)$，并使用以下带标签的测试套件对它们进行评估。每个案例是一个元组$(S, y)$，其中$S$是临床陈述，$y \\in \\{0,1\\}$是当前肺炎表型的真实标签。该测试套件旨在包含一般情况、边界条件以及与通过标点符号和语篇标记终止范围相关的边缘情况。\n\n测试套件（每个$y$是$\\{0,1\\}$中的一个整数）：\n$1$. $(\\text{\"There is no evidence of pneumonia.\"}, 0)$\n$2$. $(\\text{\"There is evidence of pneumonia.\"}, 1)$\n$3$. $(\\text{\"No evidence of pneumonia or pleural effusion.\"}, 0)$\n$4$. $(\\text{\"No evidence of pneumonia, but mild atelectasis.\"}, 0)$\n$5$. $(\\text{\"Findings compatible with pneumonia.\"}, 1)$\n$6$. $(\\text{\"No evidence of lobar pneumonia seen today.\"}, 0)$\n$7$. $(\\text{\"Pneumonia is present in the right lower lobe.\"}, 1)$\n$8$. $(\\text{\"No evidence of pneumonia; clinical pneumonia persists.\"}, 1)$\n$9$. $(\\text{\"History: pneumonia last year.\"}, 0)$\n$10$. $(\\text{\"No evidence of pneumonia and consolidation.\"}, 0)$\n$11$. $(\\text{\"No evidence of pneumonia however bacterial bronchitis noted.\"}, 0)$\n$12$. $(\\text{\"Pneumonia suspected clinically.\"}, 1)$\n$13$. $(\\text{\"Clear lungs without infiltrate.\"}, 0)$\n\n计算要求：\n- 计算$g$和$h$在所有$13$个案例上的混淆矩阵计数$(TP, FP, TN, FN)$。\n- 以十进制小数形式计算$g$和$h$的敏感性和特异性。如果任何分母等于$0$，则为此作业目的将相应指标定义为$0$。\n- 将每个指标四舍五入到$3$位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按$[\\text{sensitivity}_g,\\text{specificity}_g,\\text{sensitivity}_h,\\text{specificity}_h]$的顺序排列，其中每个条目都是一个四舍五入到$3$位小数的浮点数，例如$[0.857,0.750,0.900,0.900]$。", "solution": "该问题是有效的，因为它具有科学依据、定义明确、客观，并包含推导唯一解所需的所有必要信息。任务是根据一组临床陈述，实现并评估两个用于检测肺炎是否存在的表型检测算法$g(S)$和$h(S)$。这个过程展示了数据、信息、知识、智慧（DIKW）的层次结构：原始文本$S$是*数据*；检测器的结构化输出是*信息*；算法本身代表了应用的*知识*；而对其性能的比较评估则产生了关于其效用的*智慧*。解决方案分四步进行：分词、实现两个检测器、针对测试套件进行评估以及计算性能指标。\n\n**第一步：分词**\n\n第一步是将每个原始临床陈述字符串$S$转换为词元序列。根据问题的形式化定义，这包括将字符串转换为小写，然后将其分割为字母单词或指定的边界标点符号$\\{',', ';', '.'\\}$之一。这可以通过使用正则表达式来稳健地实现，该表达式查找所有一个或多个字母字符的序列，或匹配其中一个标点字符。将模式`r'[a-z]+|[.,;]'`应用于小写字符串即可实现此目的，能正确地将像`\"No evidence of pneumonia; ...\"`这样的字符串解析为词元列表`['no', 'evidence', 'of', 'pneumonia', ';', ...]`。不在标点符号集中的非字母字符，例如`\"History:\"`中的冒号，被有效忽略，这与问题对有效词元的定义是一致的。\n\n**第二步：朴素表型检测器 $g(S)$**\n\n朴素检测器$g(S)$模拟了简单的关键词搜索。如果分词后的序列中任何位置存在词元`'pneumonia'`，它就将陈述分类为肺炎阳性。\n该函数定义为：\n$$ g(S) = \\begin{cases} 1  \\text{if 'pneumonia' is a token in } S \\\\ 0  \\text{otherwise} \\end{cases} $$\n通过对输入字符串$S$进行分词，然后检查目标词元是否存在，可以直接实现此函数。\n\n**第三步：改进的表型检测器 $h(S)$**\n\n改进的检测器$h(S)$融合了上下文知识，特别是用于否定范围检测的规则。它旨在通过识别术语`'pneumonia'`何时被短语`\"no evidence of\"`否定的情况，来减少假阳性。\n\n$h(S)$的逻辑如下：\n$1$. 将输入字符串$S$分词为词元序列$\\{t_0, t_1, \\dots, t_{N-1}\\}$，其中$N$是词元总数。\n$2$. 识别出词元`'pneumonia'`出现的所有索引。设这个索引集为$P_{idx}$。如果$P_{idx}$为空，则$h(S)$立即返回$0$。\n$3$. 识别出连续的三词元短语`('no', 'evidence', 'of')`开始的所有索引。对于每个这样的起始索引$k$，我们必须确定其前向范围。\n$4$. 索引$k$处否定的前向范围覆盖从$k+3$开始直到（但不包括）第一个后续边界词元的词元索引。边界词元集定义为$B = \\{ \\text{'but'}, \\text{'however'}, ',', ';', '.' \\}$。如果在索引$k+2$之后没有找到边界词元，则范围延伸至陈述末尾。形式上，对于每个始于$k$的否定，其范围区间为$I_k = \\{k+3, \\dots, m-1\\}$，其中$m$是满足$t_m \\in B$的最小索引（$\\ge k+3$），如果不存在这样的边界，则$m=N$。\n$5$. 通过取所有这些范围区间$I_k$的并集，构造一个包含所有被否定索引的主集合$N_{idx}$。\n$6$. 当且仅当$P_{idx}$中存在至少一个不在被否定索引集$N_{idx}$中的肺炎索引时，函数$h(S)$返回$1$。否则，如果所有`'pneumonia'`的提及都在否定范围内，则$h(S)$返回$0$。\n\n这个逻辑正确地处理了陈述中既包含否定又包含肯定提及肺炎的情况，例如`\"No evidence of pneumonia; clinical pneumonia persists.\"`。\n\n**第四步：评估和指标计算**\n\n为了评估$g(S)$和$h(S)$的性能，我们处理提供的包含$13$个案例的测试套件。对于每个检测器，通过将其对每个陈述$S$的预测与真实标签$y$进行比较来填充混淆矩阵。这会产生真阳性（$TP$）、假阳性（$FP$）、真阴性（$TN$）和假阴性（$FN$）的计数。\n\n数据中阳性实例的总数为$P = TP + FN$，阴性实例的总数为$N = TN + FP$。根据测试套件，$P=5$且$N=8$。\n\n性能指标是敏感性和特异性，定义如下：\n$$ \\text{sensitivity} = \\frac{TP}{TP + FN} \\quad \\text{and} \\quad \\text{specificity} = \\frac{TN}{TN + FP} $$\n如果任何分母为零，则该指标定义为$0$。\n\n- **对于函数$g(S)$**：任何提及`'pneumonia'`都会导致阳性预测。这正确地识别了所有$5$个真阳性案例（$TP_g=5, FN_g=0$），但错误地分类了$8$个阴性案例中的$7$个，这些案例在被否定或不相关的上下文中提及了肺炎（$FP_g=7, TN_g=1$）。\n  - $\\text{sensitivity}_g = \\frac{5}{5+0} = 1.0$\n  - $\\text{specificity}_g = \\frac{1}{1+7} = 0.125$\n\n- **对于函数$h(S)$**：否定逻辑正确地识别了阴性案例中的否定提及，显著减少了假阳性。它正确地分类了所有$5$个真阳性案例（$TP_h=5, FN_h=0$）。它仅错误地将一个阴性案例`\"History: pneumonia last year.\"`分类为阳性，因为该规则只考虑了否定而没有考虑时间性（$FP_h=1$）。它正确地分类了其他$7$个阴性案例（$TN_h=7$）。\n  - $\\text{sensitivity}_h = \\frac{5}{5+0} = 1.0$\n  - $\\text{specificity}_h = \\frac{7}{7+1} = 0.875$\n\n最终结果四舍五入到$3$位小数，并以要求的格式呈现。特异性从$0.125$提高到$0.875$而敏感性没有损失，这证明了否定检测规则的价值，提供了问题陈述中所寻求的分析性*智慧*。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport re\n\ndef solve():\n    \"\"\"\n    Implements and evaluates two phenotype detectors for pneumonia based on a\n    rule-based NLP approach, demonstrating the DIKW pyramid.\n    \"\"\"\n    \n    # Test suite: (clinical_statement, ground_truth_label)\n    # ground_truth_label: 1 for pneumonia present, 0 for absent.\n    test_cases = [\n        (\"There is no evidence of pneumonia.\", 0),\n        (\"There is evidence of pneumonia.\", 1),\n        (\"No evidence of pneumonia or pleural effusion.\", 0),\n        (\"No evidence of pneumonia, but mild atelectasis.\", 0),\n        (\"Findings compatible with pneumonia.\", 1),\n        (\"No evidence of lobar pneumonia seen today.\", 0),\n        (\"Pneumonia is present in the right lower lobe.\", 1),\n        (\"No evidence of pneumonia; clinical pneumonia persists.\", 1),\n        (\"History: pneumonia last year.\", 0),\n        (\"No evidence of pneumonia and consolidation.\", 0),\n        (\"No evidence of pneumonia however bacterial bronchitis noted.\", 0),\n        (\"Pneumonia suspected clinically.\", 1),\n        (\"Clear lungs without infiltrate.\", 0)\n    ]\n\n    def tokenize(sentence: str) -> list[str]:\n        \"\"\"\n        Tokenizes a sentence according to the problem's formalization.\n        It lowercases the string and extracts alphabetic words or specific\n        punctuation marks.\n        \"\"\"\n        return re.findall(r'[a-z]+|[.,;]', sentence.lower())\n\n    def g(sentence: str) -> int:\n        \"\"\"\n        Naive phenotype detector g(S). Returns 1 if 'pneumonia' is found, 0 otherwise.\n        \"\"\"\n        tokens = tokenize(sentence)\n        return 1 if 'pneumonia' in tokens else 0\n\n    def h(sentence: str) -> int:\n        \"\"\"\n        Improved phenotype detector h(S) with negation scope detection.\n        Returns 1 if an un-negated 'pneumonia' is found, 0 otherwise.\n        \"\"\"\n        tokens = tokenize(sentence)\n        n = len(tokens)\n        boundary_set = {'but', 'however', ',', ';', '.'}\n        negation_phrase = ['no', 'evidence', 'of']\n\n        pneumonia_indices = {i for i, token in enumerate(tokens) if token == 'pneumonia'}\n        if not pneumonia_indices:\n            return 0\n\n        negated_indices = set()\n        for k in range(n - len(negation_phrase) + 1):\n            if tokens[k:k + len(negation_phrase)] == negation_phrase:\n                scope_start = k + len(negation_phrase)\n                scope_end = n\n                for m in range(scope_start, n):\n                    if tokens[m] in boundary_set:\n                        scope_end = m\n                        break\n                # The scope includes indices from scope_start up to scope_end.\n                negated_indices.update(range(scope_start, scope_end))\n\n        # Check if there is any pneumonia index that is not negated.\n        for p_idx in pneumonia_indices:\n            if p_idx not in negated_indices:\n                return 1\n        \n        return 0\n\n    # Initialize confusion matrix counters\n    conf_g = {'TP': 0, 'FP': 0, 'TN': 0, 'FN': 0}\n    conf_h = {'TP': 0, 'FP': 0, 'TN': 0, 'FN': 0}\n\n    # Evaluate both detectors over the test suite\n    for sentence, y_true in test_cases:\n        y_pred_g = g(sentence)\n        y_pred_h = h(sentence)\n\n        # Update confusion matrix for g(S)\n        if y_pred_g == 1 and y_true == 1: conf_g['TP'] += 1\n        elif y_pred_g == 1 and y_true == 0: conf_g['FP'] += 1\n        elif y_pred_g == 0 and y_true == 0: conf_g['TN'] += 1\n        elif y_pred_g == 0 and y_true == 1: conf_g['FN'] += 1\n\n        # Update confusion matrix for h(S)\n        if y_pred_h == 1 and y_true == 1: conf_h['TP'] += 1\n        elif y_pred_h == 1 and y_true == 0: conf_h['FP'] += 1\n        elif y_pred_h == 0 and y_true == 0: conf_h['TN'] += 1\n        elif y_pred_h == 0 and y_true == 1: conf_h['FN'] += 1\n    \n    # Calculate metrics, with division-by-zero handling\n    sens_den_g = conf_g['TP'] + conf_g['FN']\n    sensitivity_g = conf_g['TP'] / sens_den_g if sens_den_g > 0 else 0.0\n    spec_den_g = conf_g['TN'] + conf_g['FP']\n    specificity_g = conf_g['TN'] / spec_den_g if spec_den_g > 0 else 0.0\n\n    sens_den_h = conf_h['TP'] + conf_h['FN']\n    sensitivity_h = conf_h['TP'] / sens_den_h if sens_den_h > 0 else 0.0\n    spec_den_h = conf_h['TN'] + conf_h['FP']\n    specificity_h = conf_h['TN'] / spec_den_h if spec_den_h > 0 else 0.0\n    \n    results = [sensitivity_g, specificity_g, sensitivity_h, specificity_h]\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{x:.3f}' for x in results)}]\")\n\nsolve()\n```", "id": "4860503"}, {"introduction": "DIKW金字塔的稳固性完全取决于其基础——数据。本练习探讨了一个关键的现实世界问题：数据质量问题（如缺失值或单位错误）如何破坏整个分析流程。通过计算这些问题对临床风险评分造成的误差，你将学会量化“脏数据”的影响，并理解数据验证在智慧医疗体系中的重要性。[@problem_id:4860506]", "problem": "一家医院正在部署一个临床风险模型，该模型是数据-信息-知识-智慧（DIKW）流程的一部分。在此流程中，原始实验室数据（数据）被标准化并汇总成一个数值化的风险评分（信息），以支持临床决策（知识）和政策制定（智慧）。请重点关注血清钠浓度对该风险评分的贡献。\n\n假设随机一名患者的真实血清钠浓度（记为 $X$）服从正态分布，其均值为 $\\mu = 140$ 毫摩尔/升，标准差为 $\\sigma = 4$ 毫摩尔/升。该模型使用一个标准化的钠特征 $Z = (X - \\mu)/\\sigma$，其在风险评分中的线性系数为 $\\beta$；也就是说，仅由钠浓度贡献的风险评分部分为 $S_{\\text{true}} = \\beta Z$。假设 $\\beta = 0.6$ 风险评分单位/标准差。评分中的其他特征与 $X$ 独立，并且不受下述数据质量问题的影响。\n\n假设数据处理流程存在两种互斥的数据质量问题，影响了钠的测量值：\n- 一部分比例为 $p_{m} = 0.10$ 的记录缺失，在标准化之前用样本均值 $\\mu$ 进行填补。\n- 一部分比例为 $p_{u} = 0.02$ 的记录以毫克/分升为单位，但被错误标记并当作以毫摩尔/升为单位进行处理，因此其数值在标准化之前被错误地乘以一个常数因子 $k = \\frac{23}{10}$。所有其余记录均被正确处理。假设数据是完全随机缺失（MCAR），且 $X$ 与错误机制之间相互独立。\n\n令 $X_{\\text{obs}}$ 表示经过这些处理步骤后的钠值，并将仅由钠浓度贡献的估计评分定义为 $S_{\\text{hat}} = \\beta \\,(X_{\\text{obs}} - \\mu)/\\sigma$。请仅使用期望、方差和线性误差传播的基本定义，推导一个闭式表达式，用于计算由这些数据质量问题引起的钠浓度对风险评分贡献的均方误差，\n$$\\mathrm{MSE} = \\mathbb{E}\\!\\left[(S_{\\text{hat}} - S_{\\text{true}})^{2}\\right],$$\n然后使用上述参数对其进行数值计算。将最终数值答案四舍五入至四位有效数字。最终的均方误差以（风险评分单位）的平方表示。\n\n请用一两句话提出一个具体的修正计划，以解决流程中的两种错误模式。只有均方误差的数值会被评分。", "solution": "此问题要求推导和计算在考虑两种数据质量问题的情况下，钠浓度对临床风险评分贡献的均方误差（MSE）。首先，我们验证问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n- 真实血清钠 $X$ 服从正态分布：$X \\sim \\mathcal{N}(\\mu, \\sigma^2)$。\n- 真实血清钠均值：$\\mu = 140$ 毫摩尔/升。\n- 真实血清钠标准差：$\\sigma = 4$ 毫摩尔/升。\n- 真实标准化钠特征：$Z = (X - \\mu)/\\sigma$。\n- 真实的仅由钠浓度贡献的评分部分：$S_{\\text{true}} = \\beta Z$。\n- 线性系数：$\\beta = 0.6$。\n- 缺失记录的比例：$p_{m} = 0.10$。\n- 缺失记录的填补值：$\\mu$。\n- 单位错误记录的比例：$p_{u} = 0.02$。\n- 单位错误的缩放因子：$k = \\frac{23}{10}$。\n- 处理后的观测钠值：$X_{\\text{obs}}$。\n- 估计的仅由钠浓度贡献的评分部分：$S_{\\text{hat}} = \\beta (X_{\\text{obs}} - \\mu)/\\sigma$。\n- 待计算量：$\\mathrm{MSE} = \\mathbb{E}\\!\\left[(S_{\\text{hat}} - S_{\\text{true}})^{2}\\right]$。\n- 假设：数据质量问题是互斥的；错误发生是完全随机缺失（MCAR）；错误机制与 $X$ 独立。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，在真实的医学信息学背景下使用了标准的统计学原理（$\\mathcal{N}$ 分布、期望、方差、MSE）。参数在临床上是合理的：血清钠均值 $\\mu=140$ 和标准差 $\\sigma=4$ 是典型值。缩放因子 $k=2.3$ 正确地反映了钠（原子量 $\\approx 23$ g/mol）在 mg/dL 和 mmol/L 之间的大致转换关系。问题提法明确，提供了所有必要信息，并且陈述的假设（互斥性、MCAR）确保可以推导出唯一解。问题是客观的，没有歧义。\n\n### 步骤 3：结论与行动\n问题有效。解题过程将继续进行。\n\n### 解题推导\n待计算的量是均方误差（MSE），其定义为：\n$$\n\\mathrm{MSE} = \\mathbb{E}\\!\\left[(S_{\\text{hat}} - S_{\\text{true}})^{2}\\right]\n$$\n首先，我们用基本变量表示差值 $S_{\\text{hat}} - S_{\\text{true}}$：\n$$\nS_{\\text{hat}} - S_{\\text{true}} = \\beta \\frac{X_{\\text{obs}} - \\mu}{\\sigma} - \\beta \\frac{X - \\mu}{\\sigma} = \\frac{\\beta}{\\sigma} (X_{\\text{obs}} - X)\n$$\n将此代入 MSE 的定义，我们得到：\n$$\n\\mathrm{MSE} = \\mathbb{E}\\!\\left[\\left(\\frac{\\beta}{\\sigma} (X_{\\text{obs}} - X)\\right)^{2}\\right] = \\frac{\\beta^2}{\\sigma^2} \\mathbb{E}\\!\\left[(X_{\\text{obs}} - X)^{2}\\right]\n$$\n问题的核心是计算期望 $\\mathbb{E}\\!\\left[(X_{\\text{obs}} - X)^{2}\\right]$。我们使用全期望定律，以描述数据处理过程的三个互斥事件为条件：\n1.  $E_c$：记录正确。\n2.  $E_m$：记录缺失并被填补。\n3.  $E_u$：记录存在单位错误。\n\n这些事件的概率是已知的或可以推导得出：\n- $P(E_m) = p_m = 0.10$\n- $P(E_u) = p_u = 0.02$\n- $P(E_c) = p_c = 1 - p_m - p_u = 1 - 0.10 - 0.02 = 0.88$\n\n根据全期望定律：\n$$\n\\mathbb{E}\\!\\left[(X_{\\text{obs}} - X)^{2}\\right] = \\mathbb{E}\\!\\left[(X_{\\text{obs}} - X)^{2} | E_c\\right] p_c + \\mathbb{E}\\!\\left[(X_{\\text{obs}} - X)^{2} | E_m\\right] p_m + \\mathbb{E}\\!\\left[(X_{\\text{obs}} - X)^{2} | E_u\\right] p_u\n$$\n我们计算每个条件期望：\n\n情况1：记录正确 ($E_c$)。\n此时，$X_{\\text{obs}} = X$。误差为 $X_{\\text{obs}} - X = 0$。\n$$\n\\mathbb{E}\\!\\left[(X_{\\text{obs}} - X)^{2} | E_c\\right] = \\mathbb{E}\\!\\left[0^2\\right] = 0\n$$\n\n情况2：记录缺失 ($E_m$)。\n该值由均值填补，因此 $X_{\\text{obs}} = \\mu$。误差为 $X_{\\text{obs}} - X = \\mu - X$。\n$$\n\\mathbb{E}\\!\\left[(X_{\\text{obs}} - X)^{2} | E_m\\right] = \\mathbb{E}\\!\\left[(\\mu - X)^{2} | E_m\\right]\n$$\n由于 MCAR 假设，$X$ 的分布与事件 $E_m$ 独立。因此，该期望就是 $X$ 的方差。\n$$\n\\mathbb{E}\\!\\left[(\\mu - X)^{2}\\right] = \\mathrm{Var}(X) = \\sigma^2\n$$\n\n情况3：单位错误 ($E_u$)。\n该值被错误缩放，因此 $X_{\\text{obs}} = kX$。误差为 $X_{\\text{obs}} - X = kX - X = (k-1)X$。\n$$\n\\mathbb{E}\\!\\left[(X_{\\text{obs}} - X)^{2} | E_u\\right] = \\mathbb{E}\\!\\left[((k-1)X)^{2} | E_u\\right] = (k-1)^2 \\mathbb{E}\\!\\left[X^2 | E_u\\right]\n$$\n同样，根据独立性，$\\mathbb{E}\\!\\left[X^2 | E_u\\right] = \\mathbb{E}\\!\\left[X^2\\right]$。我们知道 $\\mathrm{Var}(X) = \\mathbb{E}\\!\\left[X^2\\right] - (\\mathbb{E}[X])^2$，这意味着 $\\mathbb{E}\\!\\left[X^2\\right] = \\mathrm{Var}(X) + (\\mathbb{E}[X])^2 = \\sigma^2 + \\mu^2$。\n$$\n\\mathbb{E}\\!\\left[(X_{\\text{obs}} - X)^{2} | E_u\\right] = (k-1)^2 (\\sigma^2 + \\mu^2)\n$$\n\n现在，我们将这些结果代回全期望定律公式：\n$$\n\\mathbb{E}\\!\\left[(X_{\\text{obs}} - X)^{2}\\right] = (0) \\cdot p_c + (\\sigma^2) \\cdot p_m + (k-1)^2 (\\sigma^2 + \\mu^2) \\cdot p_u\n$$\n$$\n\\mathbb{E}\\!\\left[(X_{\\text{obs}} - X)^{2}\\right] = p_m \\sigma^2 + p_u (k-1)^2 (\\sigma^2 + \\mu^2)\n$$\n最后，我们将此代入 MSE 的表达式：\n$$\n\\mathrm{MSE} = \\frac{\\beta^2}{\\sigma^2} \\left[ p_m \\sigma^2 + p_u (k-1)^2 (\\sigma^2 + \\mu^2) \\right]\n$$\n化简此表达式得到 MSE 的最终闭式方程：\n$$\n\\mathrm{MSE} = \\beta^2 \\left[ p_m + p_u (k-1)^2 \\left(1 + \\frac{\\mu^2}{\\sigma^2}\\right) \\right]\n$$\n\n### 数值计算\n我们将给定值代入推导出的公式：\n$\\beta = 0.6$, $p_m = 0.10$, $p_u = 0.02$, $k = \\frac{23}{10} = 2.3$, $\\mu = 140$, $\\sigma = 4$。\n\n首先，我们计算表达式的各个组成部分：\n- $\\beta^2 = (0.6)^2 = 0.36$\n- $k-1 = 2.3 - 1 = 1.3$\n- $(k-1)^2 = (1.3)^2 = 1.69$\n- 均值与标准差之比为 $\\frac{\\mu}{\\sigma} = \\frac{140}{4} = 35$。\n- 该比值的平方为 $\\left(\\frac{\\mu}{\\sigma}\\right)^2 = 35^2 = 1225$。\n- 项 $\\left(1 + \\frac{\\mu^2}{\\sigma^2}\\right) = 1 + 1225 = 1226$。\n\n现在，将这些值代入 MSE 公式：\n$$\n\\mathrm{MSE} = 0.36 \\left[ 0.10 + (0.02) \\cdot (1.69) \\cdot (1226) \\right]\n$$\n$$\n\\mathrm{MSE} = 0.36 \\left[ 0.10 + 41.4388 \\right]\n$$\n$$\n\\mathrm{MSE} = 0.36 \\left[ 41.5388 \\right]\n$$\n$$\n\\mathrm{MSE} = 14.953968\n$$\n将最终结果四舍五入到四位有效数字，我们得到 $14.95$。单位是（风险评分单位）的平方。\n\n### 建议的修正计划\n为修正这些错误，数据处理流程应实施自动化验证规则，以标记出在合理生理范围（例如，$100$ 至 $180$ mmol/L）之外的钠值，从而检测和处理可能的单位错误；同时，应使用更高级的统计技术（如多重插补）取代简单的均值插补，为缺失数据提供更可靠的估计值。", "answer": "$$\\boxed{14.95}$$", "id": "4860506"}]}