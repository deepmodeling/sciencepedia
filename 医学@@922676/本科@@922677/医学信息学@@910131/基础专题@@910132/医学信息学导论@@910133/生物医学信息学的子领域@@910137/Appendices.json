{"hands_on_practices": [{"introduction": "在医疗信息化的世界里，数据互操作性是实现信息无缝交换和有效利用的基石。然而，来自不同电子健康记录（EHR）系统的数据往往使用不同的编码体系，如用于诊断的 ICD-10-CM 码或各实验室内部的本地编码。本实践 [@problem_id:4857505] 将引导你完成一项生物医学信息学中的核心任务：将这些异构的临床数据映射到国际标准术语集，如 SNOMED CT 和 LOINC，并使用精确率（precision）、召回率（recall）和 $F_1$ 分数等标准指标来量化评估映射的质量。", "problem": "您将接触一个来自临床术语与标准映射领域的场景，这是生物医学信息学的一个子领域，专注于临床概念的可互操作表示。一份电子健康记录 (EHR) 包含一个以国际疾病分类第十次修订版临床修订本 (ICD-10-CM) 编码的问题列表，以及一个以本地实验室代码编码的实验室检查组合。您的任务是设计一个程序，使用提供的交叉映射词典，将这些源头代码映射到目标术语：将问题映射到SNOMED CT (医学系统命名法临床术语)，将实验室检查映射到LOINC (逻辑观察标识符名称和代码)。然后，根据提供的金标准概念对齐来评估映射质量。\n\n评估的基本原理源于集合论和信息检索：给定一个预测对齐集 $P$ 和一个金标准对齐集 $G$，各项计数定义为真阳性 $TP = |P \\cap G|$、假阳性 $FP = |P \\setminus G|$ 和假阴性 $FN = |G \\setminus P|$。然后，精确率、召回率和调和平均数 $F_1$ 定义如下：\n$$\\text{precision} = \\begin{cases}\n\\frac{TP}{|P|}  \\text{if } |P| > 0 \\\\\n0  \\text{if } |P| = 0\n\\end{cases},\\quad\n\\text{recall} = \\begin{cases}\n\\frac{TP}{|G|}  \\text{if } |G| > 0 \\\\\n0  \\text{if } |G| = 0\n\\end{cases},\\quad\nF_1 = \\begin{cases}\n\\frac{2 \\cdot \\text{precision} \\cdot \\text{recall}}{\\text{precision} + \\text{recall}}  \\text{if } \\text{precision} + \\text{recall} > 0 \\\\\n0  \\text{otherwise}\n\\end{cases}.$$\n\n设计假设和约束：\n- 使用提供的交叉映射词典，通过精确代码等效进行映射：\n  - ICD-10-CM到SNOMED CT的映射函数 $f_{\\text{diag}}$ 是一个从ICD-10-CM代码到SNOMED CT概念标识符的词典。\n  - 本地实验室代码到LOINC的映射函数 $f_{\\text{lab}}$ 是一个从本地实验室代码到LOINC代码的词典。\n- 如果某个源代码在相应的交叉映射词典中不存在，则不产生预测对齐。\n- 在金标准下，概念等效性取决于目标代码的完全相等。如果对于同一源，预测的目标代码与金标准目标代码不同，它将在总计数中贡献一个 $FP$ 和一个 $FN$（因为不正确的预测配对不在 $G$ 中，而正确的金标准配对不在 $P$ 中）。\n- 所有EHR项目都被独立处理；预测对齐集 $P$ 是针对该案例的EHR输入，由 $f_{\\text{diag}}$ 和 $f_{\\text{lab}}$ 产生的所有配对的并集。\n\n为所有测试用例提供的全局交叉映射词典：\n- ICD-10-CM 到 SNOMED CT ($f_{\\text{diag}}$):\n  - $ \\texttt{I10} \\mapsto \\texttt{59621000} $ (原发性高血压)\n  - $ \\texttt{E11.9} \\mapsto \\texttt{44054006} $ (2型糖尿病)\n  - $ \\texttt{J45.909} \\mapsto \\texttt{195967001} $ (哮喘)\n  - $ \\texttt{R79.9} \\mapsto \\texttt{165346000} $ (血液化学异常)\n  - $ \\texttt{M54.5} \\mapsto \\texttt{279039007} $ (下背痛)\n- 本地实验室代码 到 LOINC ($f_{\\text{lab}}$):\n  - $ \\texttt{LIPID\\_PANEL} \\mapsto \\texttt{24331-1} $\n  - $ \\texttt{GLU\\_FAST} \\mapsto \\texttt{1557-8} $\n  - $ \\texttt{A1C} \\mapsto \\texttt{4548-4} $\n  - $ \\texttt{CREA\\_SER} \\mapsto \\texttt{2160-0} $\n\n测试套件：\n- 案例1（一般情况，包含一个有意过度映射的模糊诊断）：\n  - EHR 问题：$[\\texttt{I10}, \\texttt{E11.9}, \\texttt{J45.909}, \\texttt{R79.9}]$\n  - EHR 实验室检查：$[\\texttt{LIPID\\_PANEL}, \\texttt{A1C}, \\texttt{CREA\\_SER}]$\n  - 金标准对齐 $G$：\n    - 问题： $(\\texttt{I10}, \\texttt{59621000})$, $(\\texttt{E11.9}, \\texttt{44054006})$, $(\\texttt{J45.909}, \\texttt{195967001})$\n    - 实验室检查： $(\\texttt{LIPID\\_PANEL}, \\texttt{24331-1})$, $(\\texttt{A1C}, \\texttt{4548-4})$, $(\\texttt{CREA\\_SER}, \\texttt{2160-0})$\n- 案例2（空输入）：\n  - EHR 问题：$[\\ ]$\n  - EHR 实验室检查：$[\\ ]$\n  - 金标准对齐 $G$：空集\n- 案例3（部分覆盖和一个空腹血糖的单位系统不匹配）：\n  - EHR 问题：$[\\texttt{I10}, \\texttt{E11.65}, \\texttt{M54.5}]$\n  - EHR 实验室检查：$[\\texttt{GLU\\_FAST}, \\texttt{A1C}]$\n  - 金标准对齐 $G$：\n    - 问题： $(\\texttt{I10}, \\texttt{59621000})$, $(\\texttt{E11.65}, \\texttt{237599002})$, $(\\texttt{M54.5}, \\texttt{279039007})$\n    - 实验室检查： $(\\texttt{GLU\\_FAST}, \\texttt{1558-6})$, $(\\texttt{A1C}, \\texttt{4548-4})$\n- 案例4（交叉映射词典中无可用映射，但金标准期望有一个）：\n  - EHR 问题：$[\\texttt{E11.65}]$\n  - EHR 实验室检查：$[\\ ]$\n  - 金标准对齐 $G$：$(\\texttt{E11.65}, \\texttt{237599002})$\n- 案例5（金标准排除了对模糊或上下文相关项目的映射）：\n  - EHR 问题：$[\\texttt{R79.9}]$\n  - EHR 实验室检查：$[\\texttt{LIPID\\_PANEL}]$\n  - 金标准对齐 $G$：空集\n- 案例6（完美映射）：\n  - EHR 问题：$[\\texttt{I10}, \\texttt{E11.9}]$\n  - EHR 实验室检查：$[\\texttt{A1C}]$\n  - 金标准对齐 $G$：$(\\texttt{I10}, \\texttt{59621000})$, $(\\texttt{E11.9}, \\texttt{44054006})$, $(\\texttt{A1C}, \\texttt{4548-4})$\n\n编程要求：\n- 通过将 $f_{\\text{diag}}$ 应用于问题列表，将 $f_{\\text{lab}}$ 应用于实验室检查列表来实现映射，忽略任何没有交叉映射条目的源代码。预测对齐集 $P$ 是该案例中来自两个领域的配对的并集。\n- 对于每个案例，根据上述定义计算 $\\text{precision}$、$\\text{recall}$ 和 $F_1$。\n- 最终输出格式：您的程序应生成单行输出，其中包含案例1到6的 $F_1$ 值，按顺序排列，每个值四舍五入到4位小数，以逗号分隔并用方括号括起来，例如 $[\\ldots]$。\n- 此任务中不涉及物理单位或角度。", "solution": "该问题是有效的。这是一个在生物医学信息学领域中定义明确、有科学依据的问题，具体涉及术语映射的评估。所有必要数据，包括映射函数（交叉映射）和用于评估的金标准集，都已提供。评估指标——精确率、召回率和 $F_1$ 分数——是标准的且定义清晰。该过程是确定性的，并且可以通过计算进行验证。\n\n任务是将电子健康记录 (EHR) 中的源代码映射到标准术语，并评估此映射的质量。源术语是用于问题的ICD-10-CM和用于实验室检查的本地代码。目标术语分别是SNOMED CT和LOINC。\n\n该方法的核心涉及预测对齐集 $P$ 和金标准对齐集 $G$ 之间的集合论比较。$P$ 和 $G$ 都是由 $(\\text{source\\_code, target\\_code})$ 形式的配对组成的集合。\n\n每个案例的预测集 $P$ 是通过将提供的交叉映射词典（$f_{\\text{diag}}$ 用于问题，$f_{\\text{lab}}$ 用于实验室检查）应用于输入的EHR数据而生成的。\n- $f_{\\text{diag}} = \\{ \\texttt{I10}: \\texttt{59621000}, \\texttt{E11.9}: \\texttt{44054006}, \\texttt{J45.909}: \\texttt{195967001}, \\texttt{R79.9}: \\texttt{165346000}, \\texttt{M54.5}: \\texttt{279039007} \\}$\n- $f_{\\text{lab}} = \\{ \\texttt{LIPID\\_PANEL}: \\texttt{24331-1}, \\texttt{GLU\\_FAST}: \\texttt{1557-8}, \\texttt{A1C}: \\texttt{4548-4}, \\texttt{CREA\\_SER}: \\texttt{2160-0} \\}$\n\n如果EHR中的某个源代码在相应的词典中不是一个键，则不会为其预测任何对齐。\n\n评估指标基于真阳性 ($TP$)、假阳性 ($FP$) 和假阴性 ($FN$) 的计数：\n$$ TP = |P \\cap G| $$\n$$ FP = |P \\setminus G| $$\n$$ FN = |G \\setminus P| $$\n\n根据这些计数，精确率、召回率和 $F_1$ 分数的计算如下：\n$$ \\text{precision} = \\frac{TP}{|P|} = \\frac{TP}{TP + FP} \\quad (\\text{if } |P| > 0) $$\n$$ \\text{recall} = \\frac{TP}{|G|} = \\frac{TP}{TP + FN} \\quad (\\text{if } |G| > 0) $$\n$$ F_1 = \\frac{2 \\cdot \\text{precision} \\cdot \\text{recall}}{\\text{precision} + \\text{recall}} \\quad (\\text{if } \\text{precision} + \\text{recall} > 0) $$\n如果这些表达式中任何一个的分母为零，则该指标的值定义为 $0$。\n\n每个测试用例的分析如下：\n\n**案例 1:**\n- EHR 输入：问题 $[\\texttt{I10}, \\texttt{E11.9}, \\texttt{J45.909}, \\texttt{R79.9}]$，实验室检查 $[\\texttt{LIPID\\_PANEL}, \\texttt{A1C}, \\texttt{CREA\\_SER}]$\n- 预测集 $P = \\{(\\texttt{I10}, \\texttt{59621000}), (\\texttt{E11.9}, \\texttt{44054006}), (\\texttt{J45.909}, \\texttt{195967001}), (\\texttt{R79.9}, \\texttt{165346000}), (\\texttt{LIPID\\_PANEL}, \\texttt{24331-1}), (\\texttt{A1C}, \\texttt{4548-4}), (\\texttt{CREA\\_SER}, \\texttt{2160-0})\\}$。因此 $|P|=7$。\n- 金标准集 $G = \\{(\\texttt{I10}, \\texttt{59621000}), (\\texttt{E11.9}, \\texttt{44054006}), (\\texttt{J45.909}, \\texttt{195967001}), (\\texttt{LIPID\\_PANEL}, \\texttt{24331-1}), (\\texttt{A1C}, \\texttt{4548-4}), (\\texttt{CREA\\_SER}, \\texttt{2160-0})\\}$。因此 $|G|=6$。\n- $TP = |P \\cap G| = 6$。\n- $FP = |P \\setminus G| = 1$，对应配对 $(\\texttt{R79.9}, \\texttt{165346000})$。\n- $FN = |G \\setminus P| = 0$。\n- $\\text{precision} = 6/7$，$\\text{recall} = 6/6=1$。\n- $F_1 = (2 \\cdot (6/7) \\cdot 1) / (6/7 + 1) = (12/7) / (13/7) = 12/13 \\approx 0.9231$。\n\n**案例 2:**\n- EHR 输入：问题 $[\\ ]$，实验室检查 $[\\ ]$。\n- 预测集 $P = \\emptyset$，因此 $|P|=0$。\n- 金标准集 $G = \\emptyset$，因此 $|G|=0$。\n- $TP = 0, FP = 0, FN = 0$。\n- 因为 $|P|=0$，所以 $\\text{precision}=0$。因为 $|G|=0$，所以 $\\text{recall}=0$。\n- $F_1 = 0$。\n\n**案例 3:**\n- EHR 输入：问题 $[\\texttt{I10}, \\texttt{E11.65}, \\texttt{M54.5}]$，实验室检查 $[\\texttt{GLU\\_FAST}, \\texttt{A1C}]$\n- 预测集 $P = \\{(\\texttt{I10}, \\texttt{59621000}), (\\texttt{M54.5}, \\texttt{279039007}), (\\texttt{GLU\\_FAST}, \\texttt{1557-8}), (\\texttt{A1C}, \\texttt{4548-4})\\}$。因此 $|P|=4$。\n- 金标准集 $G = \\{(\\texttt{I10}, \\texttt{59621000}), (\\texttt{E11.65}, \\texttt{237599002}), (\\texttt{M54.5}, \\texttt{279039007}), (\\texttt{GLU\\_FAST}, \\texttt{1558-6}), (\\texttt{A1C}, \\texttt{4548-4})\\}$。因此 $|G|=5$。\n- $TP = |P \\cap G| = 3$。正确的配对是 $\\texttt{I10}$、$\\texttt{M54.5}$ 和 $\\texttt{A1C}$。\n- $FP = |P \\setminus G| = 1$，对应配对 $(\\texttt{GLU\\_FAST}, \\texttt{1557-8})$。\n- $FN = |G \\setminus P| = 2$，对应配对 $(\\texttt{E11.65}, \\texttt{237599002})$ 和 $(\\texttt{GLU\\_FAST}, \\texttt{1558-6})$。\n- $\\text{precision} = 3/4 = 0.75$，$\\text{recall} = 3/5 = 0.6$。\n- $F_1 = (2 \\cdot 0.75 \\cdot 0.6) / (0.75 + 0.6) = 0.9 / 1.35 = 2/3 \\approx 0.6667$。\n\n**案例 4:**\n- EHR 输入：问题 $[\\texttt{E11.65}]$，实验室检查 $[\\ ]$。\n- 预测集 $P = \\emptyset$ (因为 $\\texttt{E11.65}$ 不在 $f_{\\text{diag}}$ 中)。因此 $|P|=0$。\n- 金标准集 $G = \\{(\\texttt{E11.65}, \\texttt{237599002})\\}$。因此 $|G|=1$。\n- $TP = 0, FP = 0, FN = 1$。\n- $\\text{precision}=0$，$\\text{recall}=0/1=0$。\n- $F_1 = 0$。\n\n**案例 5:**\n- EHR 输入：问题 $[\\texttt{R79.9}]$，实验室检查 $[\\texttt{LIPID\\_PANEL}]$。\n- 预测集 $P = \\{(\\texttt{R79.9}, \\texttt{165346000}), (\\texttt{LIPID\\_PANEL}, \\texttt{24331-1})\\}$。因此 $|P|=2$。\n- 金标准集 $G = \\emptyset$。因此 $|G|=0$。\n- $TP = 0, FP = 2, FN = 0$。\n- $\\text{precision}=0/2=0$，$\\text{recall}=0$。\n- $F_1 = 0$。\n\n**案例 6:**\n- EHR 输入：问题 $[\\texttt{I10}, \\texttt{E11.9}]$，实验室检查 $[\\texttt{A1C}]$。\n- 预测集 $P = \\{(\\texttt{I10}, \\texttt{59621000}), (\\texttt{E11.9}, \\texttt{44054006}), (\\texttt{A1C}, \\texttt{4548-4})\\}$。因此 $|P|=3$。\n- 金标准集 $G = \\{(\\texttt{I10}, \\texttt{59621000}), (\\texttt{E11.9}, \\texttt{44054006}), (\\texttt{A1C}, \\texttt{4548-4})\\}$。因此 $|G|=3$。\n- $P$ 和 $G$ 完全相同。\n- $TP = 3, FP = 0, FN = 0$。\n- $\\text{precision} = 3/3=1$，$\\text{recall} = 3/3=1$。\n- $F_1 = (2 \\cdot 1 \\cdot 1) / (1+1) = 1.0$。\n\n$F_1$ 分数总结：\n- 案例 1: $0.9231$\n- 案例 2: $0.0000$\n- 案例 3: $0.6667$\n- 案例 4: $0.0000$\n- 案例 5: $0.0000$\n- 案例 6: $1.0000$", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the clinical terminology mapping evaluation problem for all test cases.\n    \"\"\"\n\n    # Global crosswalk dictionaries as defined in the problem\n    f_diag = {\n        'I10': '59621000',\n        'E11.9': '44054006',\n        'J45.909': '195967001',\n        'R79.9': '165346000',\n        'M54.5': '279039007',\n    }\n    f_lab = {\n        'LIPID_PANEL': '24331-1',\n        'GLU_FAST': '1557-8',\n        'A1C': '4548-4',\n        'CREA_SER': '2160-0',\n    }\n\n    # Test suite data\n    test_cases = [\n        {\n            \"ehr_problems\": ['I10', 'E11.9', 'J45.909', 'R79.9'],\n            \"ehr_labs\": ['LIPID_PANEL', 'A1C', 'CREA_SER'],\n            \"gold_alignments\": {\n                ('I10', '59621000'), ('E11.9', '44054006'), ('J45.909', '195967001'),\n                ('LIPID_PANEL', '24331-1'), ('A1C', '4548-4'), ('CREA_SER', '2160-0')\n            }\n        },\n        {\n            \"ehr_problems\": [],\n            \"ehr_labs\": [],\n            \"gold_alignments\": set()\n        },\n        {\n            \"ehr_problems\": ['I10', 'E11.65', 'M54.5'],\n            \"ehr_labs\": ['GLU_FAST', 'A1C'],\n            \"gold_alignments\": {\n                ('I10', '59621000'), ('E11.65', '237599002'), ('M54.5', '279039007'),\n                ('GLU_FAST', '1558-6'), ('A1C', '4548-4')\n            }\n        },\n        {\n            \"ehr_problems\": ['E11.65'],\n            \"ehr_labs\": [],\n            \"gold_alignments\": {('E11.65', '237599002')}\n        },\n        {\n            \"ehr_problems\": ['R79.9'],\n            \"ehr_labs\": ['LIPID_PANEL'],\n            \"gold_alignments\": set()\n        },\n        {\n            \"ehr_problems\": ['I10', 'E11.9'],\n            \"ehr_labs\": ['A1C'],\n            \"gold_alignments\": {\n                ('I10', '59621000'), ('E11.9', '44054006'), ('A1C', '4548-4')\n            }\n        }\n    ]\n\n    f1_results = []\n\n    for case in test_cases:\n        # Step 1: Generate the predicted alignment set, P\n        predicted_alignments = set()\n        for prob_code in case[\"ehr_problems\"]:\n            if prob_code in f_diag:\n                predicted_alignments.add((prob_code, f_diag[prob_code]))\n        for lab_code in case[\"ehr_labs\"]:\n            if lab_code in f_lab:\n                predicted_alignments.add((lab_code, f_lab[lab_code]))\n\n        # Step 2: Get the gold standard alignment set, G\n        gold_alignments = case[\"gold_alignments\"]\n\n        # Step 3: Calculate TP, FP, FN using set operations\n        tp = len(predicted_alignments.intersection(gold_alignments))\n        fp = len(predicted_alignments.difference(gold_alignments))\n        fn = len(gold_alignments.difference(predicted_alignments))\n\n        # Step 4: Calculate precision, recall, and F1 score\n        # Precision = TP / |P| = TP / (TP + FP)\n        if (tp + fp) > 0:\n            precision = tp / (tp + fp)\n        else:\n            precision = 0.0\n\n        # Recall = TP / |G| = TP / (TP + FN)\n        if (tp + fn) > 0:\n            recall = tp / (tp + fn)\n        else:\n            recall = 0.0\n\n        # F1 = 2 * (precision * recall) / (precision + recall)\n        if (precision + recall) > 0:\n            f1_score = 2 * (precision * recall) / (precision + recall)\n        else:\n            f1_score = 0.0\n            \n        f1_results.append(f1_score)\n\n    # Format the final output as specified\n    formatted_results = [f\"{score:.4f}\" for score in f1_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "4857505"}, {"introduction": "在标准化的临床数据基础上，我们如何利用这些信息来识别具有特定疾病或特征的患者群体呢？“可计算表型”正是解决这一问题的关键技术，它通过构建精确的算法，在海量电子病历数据中自动识别符合特定条件的患者。本实践 [@problem_id:4857553] 将带你以 2 型糖尿病为例，亲手设计一个综合了诊断、检验和用药信息的可计算表型算法，并学习如何使用阳性预测值（PPV）、阴性预测值（NPV）、敏感性（sensitivity）和特异性（specificity）等指标来评估其性能。", "problem": "您正在临床信息学（生物医学信息学的一个子领域）领域工作，任务是利用结构化电子健康记录（EHR）数据为 $2$ 型糖尿病（T2DM）设计一个可计算表型。您必须使用公认的诊断标准和二元分类逻辑，形式化一个算法，该算法根据诊断代码、实验室测量值和药物，将患者分类为预测的 T2DM 病例状态，然后根据经病历审查的金标准计算性能指标。\n\n使用的基本依据：\n- 来自美国糖尿病协会（American Diabetes Association, ADA）的广泛接受的糖尿病诊断阈值，此处作为经过充分检验的事实陈述：\n  - 糖化血红蛋白（HbA1c）标准：HbA1c 分数 $\\geq 0.065$（小数形式，非百分比）。\n  - 空腹血糖（FPG）标准：FPG $\\geq 126$ mg/dL。\n  - 随机血糖（RPG）标准：RPG $\\geq 200$ mg/dL。\n- 基于混淆矩阵的核心二元分类定义：\n  - 真正例（$TP$）、假正例（$FP$）、真反例（$TN$）、假反例（$FN$）。\n  - 阳性预测值（PPV）、阴性预测值（NPV）、灵敏度、特异度。\n\n任务：\n1. 定义一个可计算表型函数，该函数仅使用以下规则集将每个患者的结构化记录映射到一个预测病例标签 $\\hat{Y} \\in \\{0,1\\}$。该规则集以科学上真实的方式整合了诊断代码、实验室检查和药物：\n   - 令 $C$ 表示指示 T2DM 的国际疾病分类（International Classification of Diseases, ICD）诊断代码的数量。\n   - 令 $A$ 表示 HbA1c 分数（无单位，以小数形式表示，如 $0.072$），$F$ 表示空腹血糖（单位 mg/dL），$R$ 表示随机血糖（单位 mg/dL）。\n   - 令 $M$ 表示是否存在主要用于治疗 T2DM 的药物的布尔指标。\n   - 定义实验室阳性指标\n     $$L := (A \\geq 0.065) \\lor (F \\geq 126) \\lor (R \\geq 200)。$$\n   - 预测的病例标签为\n     $$\\hat{Y} := \\begin{cases}\n     1  \\text{if } (C \\geq 2) \\lor L \\lor (M \\land (C \\geq 1)) \\\\\n     0  \\text{otherwise.}\n     \\end{cases}$$\n   此规则集反映了临床信息学的实践：结合诊断代码、标准实验室阈值和药物以平衡灵敏度和特异度。\n\n2. 使用上述 $\\hat{Y}$，根据提供的经病历审查的金标准标签 $Y \\in \\{0,1\\}$ 计算 $TP$、$FP$、$TN$ 和 $FN$，然后计算：\n   - $$\\mathrm{PPV} = \\frac{TP}{TP + FP},\\quad \\mathrm{NPV} = \\frac{TN}{TN + FN},$$\n   - $$\\text{sensitivity} = \\frac{TP}{TP + FN},\\quad \\text{specificity} = \\frac{TN}{TN + FP}。$$\n   将每个指标表示为十进制数。不允许使用百分号。\n\n测试集（每条记录是一个元组 $(C, A, F, R, M, Y)$）：\n- 记录 $1$：$(3, 0.072, 160, 210, \\text{True}, 1)$\n- 记录 $2$：$(0, 0.050, 95, 100, \\text{False}, 0)$\n- 记录 $3$：$(0, 0.065, 110, 170, \\text{False}, 1)$\n- 记录 $4$：$(0, 0.060, 100, 150, \\text{True}, 0)$\n- 记录 $5$：$(1, 0.058, 100, 130, \\text{False}, 1)$\n- 记录 $6$：$(0, 0.062, 110, 200, \\text{False}, 1)$\n- 记录 $7$：$(0, 0.064, 125, 180, \\text{False}, 0)$\n- 记录 $8$：$(0, 0.060, 130, 160, \\text{False}, 1)$\n- 记录 $9$：$(1, 0.055, 95, 100, \\text{True}, 0)$\n- 记录 $10$：$(2, 0.055, 100, 120, \\text{False}, 1)$\n\n覆盖范围基本原理：\n- 恰好在阈值上的边界情况：$A = 0.065$（记录 $3$），$R = 200$（记录 $6$），$F = 130 \\geq 126$（记录 $8$）。\n- 仅用药情景（记录 $4$）。\n- 无实验室检查或药物的单代码情景（记录 $5$）。\n- 实验室检查正常的多个代码情景（记录 $10$）。\n- 明确的阴性病例（记录 $2$ 和 $7$）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\mathrm{PPV}, \\mathrm{NPV}, \\text{sensitivity}, \\text{specificity}]$，每个值四舍五入到三位小数。例如，输出行可能看起来像 $[0.833,0.750,0.833,0.750]$。\n- 输出中不需要单位，因为这些性能指标是无量纲的。", "solution": "该问题是有效的。这是临床信息学领域一个定义明确、有科学依据且客观的任务。问题为可计算表型提供了一个清晰的、确定性的算法，一套完整的测试数据，以及待计算性能指标的标准定义。输入是一致的，并且所需的输出有明确的定义。\n\n目标是实施一个 $2$ 型糖尿病（T2DM）的可计算表型，并根据金标准评估其性能。这是一个二元分类问题，每个患者被分为病例（$\\hat{Y}=1$）或非病例（$\\hat{Y}=0$）。\n\n分类规则基于结构化电子健康记录（EHR）数据：\n- $C$：T$2$DM 特异性国际疾病分类（International Classification of Diseases, ICD）代码的数量。\n- $A$：糖化血红蛋白（Hemoglobin A1c, HbA1c）值，以小数表示。\n- $F$：空腹血糖水平，单位 mg/dL。\n- $R$：随机血糖水平，单位 mg/dL。\n- $M$：是否开具了 T$2$DM 特异性药物的布尔指标。\n\n首先，我们根据美国糖尿病协会（American Diabetes Association, ADA）的诊断阈值定义一个实验室阳性指标 $L$。如果满足以下任何一个条件，则认为患者按实验室标准为阳性：\n$$L := (A \\geq 0.065) \\lor (F \\geq 126) \\lor (R \\geq 200)$$\n逻辑运算符 $\\lor$ 代表“或”。\n\n最终的预测病例状态 $\\hat{Y}$ 由一个综合了诊断代码、实验室结果和药物的复合规则确定：\n$$\\hat{Y} := \\begin{cases}\n1  \\text{if } (C \\geq 2) \\lor L \\lor (M \\land (C \\geq 1)) \\\\\n0  \\text{otherwise.}\n\\end{cases}$$\n这里，逻辑运算符 $\\land$ 代表“与”。该规则将满足以下条件的患者分类为 T$2$DM 病例：至少有两个相关诊断代码，或至少有一个阳性实验室值，或至少有一个相关诊断代码且正在服用 T$2$DM 药物。\n\n我们将此规则应用于 $10$ 个患者记录中的每一个。对于每条记录，我们将预测标签 $\\hat{Y}$ 与金标准病历审查标签 $Y$ 进行比较，以确定分类结果：\n- 真正例（$TP$）：$\\hat{Y}=1$ 且 $Y=1$。\n- 假正例（$FP$）：$\\hat{Y}=1$ 且 $Y=0$。\n- 真反例（$TN$）：$\\hat{Y}=0$ 且 $Y=0$。\n- 假反例（$FN$）：$\\hat{Y}=0$ 且 $Y=1$。\n\n下表详细说明了每条记录的分类结果：\n- **记录 1**：$(3, 0.072, 160, 210, \\text{True}, 1)$。条件 $(C \\geq 2)$ 为真，因为 $C=3$。因此，$\\hat{Y}=1$。由于 $Y=1$，这是一个 $TP$。\n- **记录 2**：$(0, 0.050, 95, 100, \\text{False}, 0)$。条件 $L$ 为假（$A  0.065, F  126, R  200$）。所有其他条件都为假。因此，$\\hat{Y}=0$。由于 $Y=0$，这是一个 $TN$。\n- **记录 3**：$(0, 0.065, 110, 170, \\text{False}, 1)$。条件 $L$ 为真，因为 $A=0.065$。因此，$\\hat{Y}=1$。由于 $Y=1$，这是一个 $TP$。\n- **记录 4**：$(0, 0.060, 100, 150, \\text{True}, 0)$。条件 $L$ 为假。条件 $(M \\land (C \\geq 1))$ 为假，因为 $C=0$。因此，$\\hat{Y}=0$。由于 $Y=0$，这是一个 $TN$。\n- **记录 5**：$(1, 0.058, 100, 130, \\text{False}, 1)$。条件 $L$ 为假。条件 $(M \\land (C \\geq 1))$ 为假，因为 $M$ 是 False。条件 $(C \\geq 2)$ 为假。因此，$\\hat{Y}=0$。由于 $Y=1$，这是一个 $FN$。\n- **记录 6**：$(0, 0.062, 110, 200, \\text{False}, 1)$。条件 $L$ 为真，因为 $R=200$。因此，$\\hat{Y}=1$。由于 $Y=1$，这是一个 $TP$。\n- **记录 7**：$(0, 0.064, 125, 180, \\text{False}, 0)$。条件 $L$ 为假（$A  0.065, F  126, R  200$）。所有其他条件都为假。因此，$\\hat{Y}=0$。由于 $Y=0$，这是一个 $TN$。\n- **记录 8**：$(0, 0.060, 130, 160, \\text{False}, 1)$。条件 $L$ 为真，因为 $F=130 \\geq 126$。因此，$\\hat{Y}=1$。由于 $Y=1$，这是一个 $TP$。\n- **记录 9**：$(1, 0.055, 95, 100, \\text{True}, 0)$。条件 $L$ 为假。条件 $(M \\land (C \\geq 1))$ 为真，因为 $M$ 是 True 且 $C=1$。因此，$\\hat{Y}=1$。由于 $Y=0$，这是一个 $FP$。\n- **记录 10**：$(2, 0.055, 100, 120, \\text{False}, 1)$。条件 $(C \\geq 2)$ 为真，因为 $C=2$。因此，$\\hat{Y}=1$。由于 $Y=1$，这是一个 $TP$。\n\n汇总这些结果，得出混淆矩阵计数：\n- $TP = 5$\n- $FP = 1$\n- $TN = 3$\n- $FN = 1$\n\n最后，我们计算标准性能指标。\n1. 阳性预测值（PPV），或精确率：\n   $$\\mathrm{PPV} = \\frac{TP}{TP + FP} = \\frac{5}{5 + 1} = \\frac{5}{6} \\approx 0.833$$\n\n2. 阴性预测值（NPV）：\n   $$\\mathrm{NPV} = \\frac{TN}{TN + FN} = \\frac{3}{3 + 1} = \\frac{3}{4} = 0.750$$\n\n3. 灵敏度，或召回率：\n   $$\\text{sensitivity} = \\frac{TP}{TP + FN} = \\frac{5}{5 + 1} = \\frac{5}{6} \\approx 0.833$$\n\n4. 特异度：\n   $$\\text{specificity} = \\frac{TN}{TN + FP} = \\frac{3}{3 + 1} = \\frac{3}{4} = 0.750$$\n\n这四个指标四舍五入到三位小数，对给定数据集上可计算表型的性能提供了定量评估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are necessary for this problem.\n\ndef classify_patient(C, A, F, R, M):\n    \"\"\"\n    Applies the computable phenotype rule to classify a patient.\n\n    Args:\n        C (int): Count of T2DM ICD codes.\n        A (float): HbA1c fraction.\n        F (float): Fasting plasma glucose in mg/dL.\n        R (float): Random plasma glucose in mg/dL.\n        M (bool): Indicator for T2DM medications.\n\n    Returns:\n        int: Predicted case label (1 for case, 0 for non-case).\n    \"\"\"\n    lab_positive = (A = 0.065) or (F = 126) or (R = 200)\n    \n    # The rule for predicting the case label Y_hat\n    # Y_hat = 1 if (C = 2) or L or (M and (C = 1))\n    if (C = 2) or lab_positive or (M and (C = 1)):\n        return 1\n    else:\n        return 0\n\ndef solve():\n    \"\"\"\n    Solves the problem by classifying patients and calculating performance metrics.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each record is a tuple (C, A, F, R, M, Y)\n    test_cases = [\n        (3, 0.072, 160, 210, True, 1),\n        (0, 0.050, 95, 100, False, 0),\n        (0, 0.065, 110, 170, False, 1),\n        (0, 0.060, 100, 150, True, 0),\n        (1, 0.058, 100, 130, False, 1),\n        (0, 0.062, 110, 200, False, 1),\n        (0, 0.064, 125, 180, False, 0),\n        (0, 0.060, 130, 160, False, 1),\n        (1, 0.055, 95, 100, True, 0),\n        (2, 0.055, 100, 120, False, 1),\n    ]\n\n    # Initialize confusion matrix counters\n    tp, fp, tn, fn = 0, 0, 0, 0\n\n    for case in test_cases:\n        C, A, F, R, M, Y_true = case\n        Y_pred = classify_patient(C, A, F, R, M)\n\n        if Y_pred == 1 and Y_true == 1:\n            tp += 1\n        elif Y_pred == 1 and Y_true == 0:\n            fp += 1\n        elif Y_pred == 0 and Y_true == 0:\n            tn += 1\n        elif Y_pred == 0 and Y_true == 1:\n            fn += 1\n            \n    # Calculate performance metrics\n    # Handle division by zero for robustness, though not strictly required by this problem's data\n    ppv = tp / (tp + fp) if (tp + fp)  0 else 0.0\n    npv = tn / (tn + fn) if (tn + fn)  0 else 0.0\n    sensitivity = tp / (tp + fn) if (tp + fn)  0 else 0.0\n    specificity = tn / (tn + fp) if (tn + fp)  0 else 0.0\n\n    # Format results to three decimal places\n    results = [round(ppv, 3), round(npv, 3), round(sensitivity, 3), round(specificity, 3)]\n    \n    # Final print statement in the exact required format.\n    # The format requirement of \"0.750\" means we need to format the float.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4857553"}, {"introduction": "生物医学信息学的范畴远不止于临床数据，它还涵盖了对海量生物学数据的分析，其中基因组学是核心领域之一。生物信息学的一个基本工作流程是从 DNA 测序产生的短序列片段（reads）开始，将其与参考基因组进行比对，并从中识别出个体特有的基因变异。本实践 [@problem_id:4857495] 模拟了这一关键流程，你将学习如何通过最小化汉明距离（Hamming distance）来比对序列，构建碱基堆叠（pileup），并根据预设阈值调用单核苷酸变异（SNV），最终通过计算转换/颠换比率（Ti/Tv ratio）等指标来评估变异识别的质量。", "problem": "您需要以代码形式实现一个极简的端到端变异检测和评估流程，该流程处理简化的脱氧核糖核酸（DNA）字符串。本练习属于生物医学信息学中的生物信息学子领域，重点关注如何从基本定义中推导出比对、变异检测和评估指标。\n\n从以下基本概念开始：\n1. 核苷酸字母表：脱氧核糖核酸（DNA）序列是在字母表 $\\{A,C,G,T\\}$ 上的有限字符串，其中 $A$ 和 $G$ 是嘌呤，$C$ 和 $T$ 是嘧啶。在基因组坐标 $p$（零基索引）处的单核苷酸变异（SNV）将参考碱基 $r \\in \\{A,C,G,T\\}$ 替换为备选碱基 $a \\in \\{A,C,G,T\\}$，且 $a \\neq r$。\n2. 汉明距离（Hamming distance）：对于两个等长（长度为 $L$）的字符串 $x$ 和 $y$，汉明距离 $d_H(x,y)$ 是指使得 $x[i] \\neq y[i]$ 的位置 $i \\in \\{0,\\dots,L-1\\}$ 的数量。\n3. 比对规则：要将长度为 $L$ 的读段 $q$ 与长度为 $N$ 的参考序列 $R$ 进行比对，需评估所有偏移量 $s \\in \\{0,1,\\dots,N-L\\}$。选择使 $d_H\\!\\big(q, R[s:s+L]\\big)$ 最小化的偏移量 $s^\\star$。如果多个偏移量都能最小化该距离，则选择其中最小的 $s^\\star$（最左平局规则）。假设只可能发生错配（无插入或删除）。\n4. 堆积（Pileup）和变异检测规则：比对所有读段后，对于每个位置 $p \\in \\{0,\\dots,N-1\\}$，令 $\\text{cov}(p)$ 为覆盖 $p$ 的已比对读段碱基总数，对于每个碱基 $b \\in \\{A,C,G,T\\}$，令 $c_p(b)$ 为在 $p$ 处观察到的碱基 $b$ 的计数。只考虑非参考碱基，即 $b \\neq R[p]$。令 $b^\\star$ 为具有最大 $c_p(b)$ 的非参考碱基；如果存在平局，则选择最大化者中字典序最小的那个。定义支持计数 $c^\\star = c_p(b^\\star)$ 和等位基因分数 $f^\\star = c^\\star / \\text{cov}(p)$。当且仅当 $c^\\star \\ge n_{\\min}$ 且 $f^\\star \\ge f_{\\min}$ 时，在 $p$ 处检测到一个备选碱基为 $b^\\star$ 的变异，其中 $n_{\\min}$ 是一个非负整数阈值，$f_{\\min} \\in [0,1]$ 是一个分数阈值。\n5. 针对 SNV 真值集 $T$ 的评估指标：\n   - 真阳性 $\\mathrm{TP}$、假阳性 $\\mathrm{FP}$ 和假阴性 $\\mathrm{FN}$ 通过坐标和备选碱基的精确匹配来计算。\n   - 灵敏度定义为 $\\mathrm{TP}/(\\mathrm{TP}+\\mathrm{FN})$，当 $\\mathrm{TP}+\\mathrm{FN} > 0$ 时。如果 $\\mathrm{TP}+\\mathrm{FN} = 0$，则在没有检出变异时定义灵敏度为 $1$，否则为 $0$。\n   - 精确率定义为 $\\mathrm{TP}/(\\mathrm{TP}+\\mathrm{FP})$，当 $\\mathrm{TP}+\\mathrm{FP} > 0$ 时。如果 $\\mathrm{TP}+\\mathrm{FP} = 0$，则定义精确率为 $1$。\n6. 转换/颠换（Ti/Tv）比率：在检出的 SNV 中，转换是指嘌呤到嘌呤或嘧啶到嘧啶的改变，即 $A \\leftrightarrow G$ 或 $C \\leftrightarrow T$。颠换是任何其他类型的改变。令 $\\mathrm{Ti}$ 和 $\\mathrm{Tv}$ 分别为检出的 SNV 中转换和颠换的计数（相对于该坐标的参考碱基）。当 $\\mathrm{Tv} > 0$ 时，定义 Ti/Tv 比率为 $\\mathrm{Ti}/\\mathrm{Tv}$。如果没有检出 SNV，则定义该比率为 $0$。如果 $\\mathrm{Tv} = 0$ 且至少有一个检出的 SNV，则该比率为 $+\\infty$。\n\n实现一个程序，该程序：\n- 使用上述规则将每个读段与参考序列进行比对。\n- 根据比对后的读段构建每个位置的碱基计数。\n- 使用指定的阈值 $n_{\\min}$ 和 $f_{\\min}$ 检测变异。\n- 针对每个测试用例，使用上述定义计算灵敏度、精确率和 Ti/Tv 比率。\n- 在最终输出中将每个指标四舍五入到恰好 $6$ 位小数。\n\n输入作为以下测试套件嵌入在程序中。所有坐标都是零基的，所有读段都完全由字母表 $\\{A,C,G,T\\}$ 中的字符组成。\n\n测试套件：\n- 用例 1（正常路径，两个真值变异具有足够的支持度，且检出的变异包含转换和颠换）：\n  - 参考序列 $R_1$: \"ATGCCTAGGCTAACGT\" (长度 $16$)。\n  - 读段 $Q_1$: [\"GCCTGGGC\",\"CCTGGGCT\",\"CTGGGCTA\",\"TAGGCTAA\",\"AGGCTAAC\",\"GGCTACCG\",\"GCTACCGT\",\"ACGCCTAG\"]。\n  - 阈值：$n_{\\min} = 2$, $f_{\\min} = 0.4$。\n  - 真值 SNV $T_1$: $\\{(6,\\text{'G'}),(12,\\text{'C'})\\}`。\n- 用例 2（模糊比对平局，最左平局规则导致无任何检出；阈值边界情况）：\n  - 参考序列 $R_2$: \"AAAACCAAAACCTTTT\" (长度 $16$)。\n  - 读段 $Q_2$: [\"AAAATC\",\"AAAATC\"]。\n  - 阈值：$n_{\\min} = 3$, $f_{\\min} = 0.6$。\n  - 真值 SNV $T_2$: $\\{(10,\\text{'T'})\\}`。\n- 用例 3（无真值变异，完全匹配的读段，无检出：评估指标分母的边缘情况）：\n  - 参考序列 $R_3$: \"GCTAGCATCGATCG\" (长度 $14$)。\n  - 读段 $Q_3$: [\"GCTAGCAT\",\"GCATCGAT\",\"ATCGATCG\"]。\n  - 阈值：$n_{\\min} = 2$, $f_{\\min} = 0.5$。\n  - 真值 SNV $T_3$: $\\emptyset$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含三个浮点值的列表 $[\\text{sensitivity},\\text{precision},\\text{Ti/Tv}]$，所有值都四舍五入到恰好 $6$ 位小数。对于以上三个用例，总输出必须采用以下形式：\n  - [[$s_1$,$p_1$,$t_1$],[$s_2$,$p_2$,$t_2$],[$s_3$,$p_3$,$t_3$]]\n其中每个 $s_i$、$p_i$、$t_i$ 都以小数点后恰好 $6$ 位数字打印。", "solution": "用户提供了一个需要解决的计算生物学问题。我将首先验证问题陈述，如果有效，则提供一个合理的解决方案。\n\n### 第 1 步：提取已知条件\n\n1.  **核苷酸字母表**：$\\{A,C,G,T\\}$。嘌呤：$\\{A, G\\}$。嘧啶：$\\{C, T\\}$。\n2.  **单核苷酸变异 (SNV)**：在零基坐标 $p$ 处，一个参考碱基 $r$ 被一个备选碱基 $a$ 替换，其中 $a \\neq r$。\n3.  **汉明距离**：对于两个等长字符串 $x, y$，$d_H(x,y)$ 是 $x[i] \\neq y[i]$ 的位置 $i$ 的数量。\n4.  **比对规则**：对于长度为 $L$ 的读段 $q$ 和长度为 $N$ 的参考序列 $R$，找到一个偏移量 $s^\\star \\in \\{0, 1, \\dots, N-L\\}$，它能最小化 $d_H(q, R[s:s+L])$。如果出现平局，选择最小的（最左边的）$s^\\star$。\n5.  **变异检测规则**：\n    - 对于每个位置 $p$，$\\text{cov}(p)$ 是覆盖 $p$ 的已比对读段碱基的总数。\n    - $c_p(b)$ 是在位置 $p$ 观察到的碱基 $b \\in \\{A,C,G,T\\}$ 的计数。\n    - 候选变异是非参考碱基 $b^\\star$（其中 $b^\\star \\neq R[p]$），它具有最大的计数 $c_p(b)$。平局通过选择字典序最小的碱基来解决。\n    - $c^\\star = c_p(b^\\star)$ 是支持计数。\n    - $f^\\star = c^\\star / \\text{cov}(p)$ 是等位基因分数。\n    - 当且仅当 $c^\\star \\ge n_{\\min}$ 且 $f^\\star \\ge f_{\\min}$ 时，才会检测到一个变异。\n6.  **评估指标**：\n    - **TP, FP, FN**：真阳性、假阳性、假阴性是通过与真值集 $T$ 进行（坐标，备选碱基）的精确匹配来计算的。\n    - **灵敏度**：若 $\\mathrm{TP}+\\mathrm{FN} > 0$，则为 $\\mathrm{TP}/(\\mathrm{TP}+\\mathrm{FN})$。若 $\\mathrm{TP}+\\mathrm{FN} = 0$，则在没有检出变异时为 $1$，否则为 $0$。\n    - **精确率**：若 $\\mathrm{TP}+\\mathrm{FP} > 0$，则为 $\\mathrm{TP}/(\\mathrm{TP}+\\mathrm{FP})$。若 $\\mathrm{TP}+\\mathrm{FP} = 0$，则为 $1$。\n7.  **转换/颠换 (Ti/Tv) 比率**：\n    - **转换 (Ti)**：在检出的 SNV 中，嘌呤到嘌呤（$A \\leftrightarrow G$）或嘧啶到嘧啶（$C \\leftrightarrow T$）的改变。\n    - **颠换 (Tv)**：任何其他的改变（嘌呤 $\\leftrightarrow$ 嘧啶）。\n    - **比率**：若 $\\mathrm{Tv} > 0$，则为 $\\mathrm{Ti}/\\mathrm{Tv}$。若没有检出 SNV，比率为 $0$。若 $\\mathrm{Tv}=0$ 且至少检出一个 SNV，比率为 $+\\infty$。\n8.  **输出格式**：所有指标必须四舍五入到恰好 $6$ 位小数。\n9.  **测试套件**：\n    - **用例 1**：$R_1=$ \"ATGCCTAGGCTAACGT\", $Q_1=$ [\"GCCTGGGC\",\"CCTGGGCT\",\"CTGGGCTA\",\"TAGGCTAA\",\"AGGCTAAC\",\"GGCTACCG\",\"GCTACCGT\",\"ACGCCTAG\"], $n_{\\min} = 2$, $f_{\\min} = 0.4$, $T_1 = \\{(6,'G'),(12,'C')\\}$。\n    - **用例 2**：$R_2=$ \"AAAACCAAAACCTTTT\", $Q_2=$ [\"AAAATC\",\"AAAATC\"], $n_{\\min} = 3$, $f_{\\min} = 0.6$, $T_2 = \\{(10,'T')\\}$。\n    - **用例 3**：$R_3=$ \"GCTAGCATCGATCG\", $Q_3=$ [\"GCTAGCAT\",\"GCATCGAT\",\"ATCGATCG\"], $n_{\\min} = 2$, $f_{\\min} = 0.5$, $T_3=\\emptyset$。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题是真实世界生物信息学流程的一个简化模型。像参考序列比对、堆积、变异检测、灵敏度、精确率和 Ti/Tv 比率等概念在基因组学中都是标准概念。所做的简化（例如，使用汉明距离，没有插入和删除）都已明确定义，并未违反科学原则；它们只是定义了这个特定计算模型的边界。\n-   **问题定义明确**：该问题定义明确。比对规则（最左平局）和变异检测规则（备选碱基的字典序平局决胜）确保了对于任何给定的输入，结果都是确定且唯一的。对指标（包括分母为零的边缘情况）的定义都已明确提供，避免了歧义。\n-   **客观性**：问题以精确、客观的语言陈述。所有术语要么是标准术语，要么有明确定义。\n-   **完整性和一致性**：问题是自成体系的。所有必要的数据（参考序列、读段、阈值、真值集）和所有计算规则都已提供。定义中没有明显的矛盾。Ti/Tv 比率的定义中存在一个微小的模糊之处，即指定了 $+\\infty$ 值，这与将输出格式化为 6 位小数的浮点数的要求相冲突。然而，所提供的测试用例中没有一个会触发此条件，因此对于给定的输入，问题仍然是可解的。\n-   **现实性**：虽然经过简化，但参数和序列对于该领域的玩具问题来说是合理的。\n\n### 第 3 步：结论与行动\n\n该问题是**有效的**。这是一个定义明确、自成体系且具有科学依据的计算任务。我现在将继续提供解决方案。\n\n### 解决方案设计\n\n该解决方案将通过将问题分解为其逻辑组件来实现，这些组件对应于生物信息学流程的各个步骤。对于每个测试用例，将执行以下操作序列：\n\n1.  **比对**：对于读段集合 $Q$ 中的每个读段，我们必须在参考序列 $R$ 上找到其最佳比对位置。根据规则，这涉及遍历所有可能的起始比对偏移量 $s$，从 $0$ 到 $N-L$，其中 $N$ 是参考序列的长度，$L$ 是读段的长度。对于每个偏移量 $s$，我们计算汉明距离 $d_H(q, R[s:s+L])$。选择产生最小汉明距离的偏移量 $s^\\star$。“最左平局规则”规定，如果多个偏移量产生相同的最小距离，则选择最小的偏移量值。对所有读段重复此过程。\n\n2.  **堆积构建**：确定每个读段的比对偏移量后，我们构建一个堆积。这可以被概念化为一个计数表格，由基因组位置 $p$ 和核苷酸碱基 $b \\in \\{A,C,G,T\\}$ 索引。一个大小为 $N \\times 4$ 的二维数组是一个合适的数据结构。我们遍历每个读段及其对应的比对偏移量 $s^\\star$。对于读段中的每个碱基，我们确定其在参考序列上的位置 $p = s^\\star + j$（其中 $j$ 是读段内的索引），并在我们的堆积表中增加该位置 $p$ 上该碱基的计数。\n\n3.  **变异检测**：我们从 $0$ 到 $N-1$ 遍历参考序列的每个位置 $p$。在每个位置，我们执行以下检查以检测变异：\n    a. 通过对该位置所有碱基计数求和来确定总覆盖度 $\\text{cov}(p)$。如果 $\\text{cov}(p) = 0$，我们无法进行检测并继续到下一个位置。\n    b. 确定参考碱基 $R[p]$。\n    c. 检查所有非参考碱基的计数。我们找到具有最高计数 $c_p(b)$ 的非参考碱基 $b^\\star$。如果存在平局，则选择字典序最小的碱基。\n    d. 变异的支持计数为 $c^\\star = c_p(b^\\star)$，等位基因分数为 $f^\\star = c^\\star / \\text{cov}(p)$。\n    e. 当且仅当 $c^\\star \\ge n_{\\min}$ 和 $f^\\star \\ge f_{\\min}$ 同时为真时，在位置 $p$ 处检测到一个备选碱基为 $b^\\star$ 的变异。所有这样检出的变异，表示为元组 $(p, b^\\star)$，被收集到一个集合中。\n\n4.  **评估**：将检出的变异集合与提供的真值集进行比较。\n    a. **TP, FP, FN 计数**：\n        - 真阳性 ($\\mathrm{TP}$): *同时*存在于检出集和真值集中的变异数量。这是两个集合交集的大小。\n        - 假阳性 ($\\mathrm{FP}$): 存在于检出集中但*不*在真值集中的变异数量。这是集合差的大小：检出集 - 真值集。\n        - 假阴性 ($\\mathrm{FN}$): 存在于真值集中但*不*在检出集中的变异数量。这是集合差的大小：真值集 - 检出集。\n    b. **灵敏度和精确率**：使用它们的明确定义计算这些指标，包括对分母为零的边缘情况的指定处理。\n        - 灵敏度 = $\\mathrm{TP} / (\\mathrm{TP} + \\mathrm{FN})$ 或其边缘情况值。\n        - 精确率 = $\\mathrm{TP} / (\\mathrm{TP} + \\mathrm{FP})$ 或其边缘情况值。\n    c. **Ti/Tv 比率**：我们遍历*检出的*变异集合。对于每个变异，我们比较参考碱基和备选碱基，将其分类为转换或颠换。\n        - 转换 (Ti)：嘌呤 $\\leftrightarrow$ 嘌呤或嘧啶 $\\leftrightarrow$ 嘧啶。\n        - 颠换 (Tv)：嘌呤 $\\leftrightarrow$ 嘧啶。\n        - 统计总计数 $\\mathrm{Ti}$ 和 $\\mathrm{Tv}$。然后根据规则计算比率，处理 $\\mathrm{Tv}=0$ 或没有检出变异的情况。\n\n5.  **输出格式化**：每个测试用例计算出的三个指标（灵敏度、精确率、Ti/Tv 比率）被四舍五入到 $6$ 位小数，并格式化为所需的字符串格式。整个过程被封装在一个处理所提供测试套件的程序中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef solve():\n    \"\"\"\n    Main function to run the bioinformatics pipeline on a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"R\": \"ATGCCTAGGCTAACGT\",\n            \"Q\": [\"GCCTGGGC\", \"CCTGGGCT\", \"CTGGGCTA\", \"TAGGCTAA\", \"AGGCTAAC\", \"GGCTACCG\", \"GCTACCGT\", \"ACGCCTAG\"],\n            \"n_min\": 2,\n            \"f_min\": 0.4,\n            \"T\": {(6, 'G'), (12, 'C')}\n        },\n        {\n            \"R\": \"AAAACCAAAACCTTTT\",\n            \"Q\": [\"AAAATC\", \"AAAATC\"],\n            \"n_min\": 3,\n            \"f_min\": 0.6,\n            \"T\": {(10, 'T')}\n        },\n        {\n            \"R\": \"GCTAGCATCGATCG\",\n            \"Q\": [\"GCTAGCAT\", \"GCATCGAT\", \"ATCGATCG\"],\n            \"n_min\": 2,\n            \"f_min\": 0.5,\n            \"T\": set()\n        }\n    ]\n\n    all_results = []\n    \n    base_to_idx = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    idx_to_base = ['A', 'C', 'G', 'T']\n    purines = {'A', 'G'}\n    pyrimidines = {'C', 'T'}\n\n    for case in test_cases:\n        ref_seq, reads, n_min, f_min, truth_variants = case[\"R\"], case[\"Q\"], case[\"n_min\"], case[\"f_min\"], case[\"T\"]\n        ref_len = len(ref_seq)\n        \n        # 1. Alignment\n        alignments = []\n        for read in reads:\n            min_dist = float('inf')\n            best_offset = -1\n            read_len = len(read)\n            for s in range(ref_len - read_len + 1):\n                ref_substring = ref_seq[s : s + read_len]\n                dist = sum(1 for i in range(read_len) if read[i] != ref_substring[i])\n                if dist  min_dist:\n                    min_dist = dist\n                    best_offset = s\n            alignments.append(best_offset)\n\n        # 2. Pileup Construction\n        pileup = np.zeros((ref_len, 4), dtype=int)\n        for i, read in enumerate(reads):\n            offset = alignments[i]\n            for j, base in enumerate(read):\n                pos = offset + j\n                pileup[pos, base_to_idx[base]] += 1\n        \n        # 3. Variant Calling\n        called_variants = set()\n        for p in range(ref_len):\n            coverage = np.sum(pileup[p])\n            if coverage == 0:\n                continue\n\n            ref_base = ref_seq[p]\n            \n            # Find best non-reference alternate base\n            best_alt_base = None\n            max_alt_count = -1\n            \n            # Iterate in lexicographical order to handle ties correctly\n            for alt_base_idx, alt_base in enumerate(idx_to_base):\n                if alt_base == ref_base:\n                    continue\n                \n                alt_count = pileup[p, alt_base_idx]\n                if alt_count  max_alt_count:\n                    max_alt_count = alt_count\n                    best_alt_base = alt_base\n            \n            if max_alt_count = 0: # Ensure there is at least one non-reference read\n                continue\n\n            support_count = max_alt_count\n            allele_fraction = support_count / coverage\n\n            if support_count = n_min and allele_fraction = f_min:\n                called_variants.add((p, best_alt_base))\n\n        # 4. Evaluation\n        tp = len(called_variants.intersection(truth_variants))\n        fp = len(called_variants.difference(truth_variants))\n        fn = len(truth_variants.difference(called_variants))\n\n        # Sensitivity\n        if tp + fn  0:\n            sensitivity = tp / (tp + fn)\n        else:\n            sensitivity = 1.0 if not called_variants else 0.0\n\n        # Precision\n        if tp + fp  0:\n            precision = tp / (tp + fp)\n        else:\n            precision = 1.0\n            \n        # Ti/Tv Ratio\n        ti_count = 0\n        tv_count = 0\n        if not called_variants:\n            titv_ratio = 0.0\n        else:\n            for p, alt_base in called_variants:\n                ref_base = ref_seq[p]\n                is_ref_purine = ref_base in purines\n                is_alt_purine = alt_base in purines\n                \n                if (is_ref_purine and is_alt_purine) or (not is_ref_purine and not is_alt_purine):\n                    ti_count += 1\n                else:\n                    tv_count += 1\n            \n            if tv_count  0:\n                titv_ratio = ti_count / tv_count\n            else: # tv_count == 0\n                # Per problem, if Ti  0, this is infinity.\n                # Since output must be a float, and no test cases hit this, we'll\n                # implement the other part of the rule. If Ti=0 and Tv=0, no variants were called,\n                # which is handled above. This branch is for Ti  0, Tv = 0.\n                titv_ratio = float('inf')\n\n        all_results.append([sensitivity, precision, titv_ratio])\n\n    # Final print statement in the exact required format.\n    # The 'inf' value is not tested, so we don't need special formatting for it.\n    formatted_results = []\n    for s, p, t in all_results:\n        formatted_results.append(f\"[{s:.6f},{p:.6f},{t:.6f}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4857495"}]}