{"hands_on_practices": [{"introduction": "要在预防医学中应用正态分布，第一步是熟练掌握如何计算特定范围内的概率。本练习通过一个简化的场景，清晰地展示了如何使用标准正态累积分布函数 $\\Phi(z)$ 来计算一个变量落在某个区间内的概率，这是处理更复杂的统计推断问题前必须掌握的基本功。[@problem_id:1956240]", "problem": "在一个半导体制造的质量控制流程中，某种微芯片的归一化电噪声水平被发现可以由一个标准正态随机变量精确建模，我们将其表示为 $Z$。\n\n标准正态分布是一个连续概率分布，其概率密度函数为 $f(z) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{z^2}{2}\\right)$，其中 $-\\infty  z  \\infty$。随机变量 $Z$ 取值小于或等于某个常数 $c$ 的概率由其累积分布函数（CDF）给出，通常表示为 $\\Phi(c) = P(Z \\le c)$。\n\n如果一个芯片的归一化噪声水平 $Z$ 严格介于一个正常数 $k$ 和该常数的两倍之间，即 $k  Z  2k$，则该芯片被指定为“高性能”。\n\n求一个随机选择的微芯片被归类为“高性能”的概率的一般表达式。您的答案必须仅用标准正态CDF $\\Phi$ 和参数 $k$ 来表示。", "solution": "设 $Z$ 是一个标准正态随机变量，其累积分布函数为 $\\Phi(c) = P(Z \\le c)$。一个芯片被归类为“高性能”的事件是 $k  Z  2k$。我们要求解的概率是 $P(k  Z  2k)$。利用累积分布函数的性质，我们可以将这个区间的概率表示为两个累积概率的差：$$P(k  Z  2k) = P(Z \\le 2k) - P(Z \\le k)$$ 这直接转化为使用 $\\Phi$ 函数的表达式：$\\Phi(2k) - \\Phi(k)$。", "answer": "$$\\boxed{\\Phi(2k)-\\Phi(k)}$$", "id": "1956240"}, {"introduction": "在预防医学实践中，我们常常需要用样本数据来估计未知的总体参数，例如社区人群的平均血糖水平。本练习将指导你如何当总体方差未知时，利用与正态分布密切相关的学生t分布（Student's t-distribution）来构建和解释总体均值的置信区间，这是分析监测或筛查数据的核心技能。[@problem_id:4563667]", "problem": "一个社区预防医学项目通过定期筛查成年人的空腹血糖来进行公共卫生监测。在一次筛查中，根据一项旨在近似于从一个总体中进行独立同分布（iid）抽样的设计，获得了一个大小为 $n = 25$ 的成年人简单随机样本。设个体测量值为 $X_{1}, X_{2}, \\dots, X_{n}$，其中每个 $X_{i}$ 被建模为服从共同均值为 $\\mu$ 和方差为 $\\sigma^{2}$ 的独立同分布正态分布，即 $X_{i} \\sim \\text{iid } N(\\mu, \\sigma^{2})$，且 $\\sigma^{2}$ 未知。该样本的样本均值为 $\\bar{x} = 102$ 毫克/分升（mg/dL），样本标准差为 $s = 18$ mg/dL。\n\n仅使用核心定义和正态模型下关于抽样分布的成熟结论，首先推导当 $\\sigma^{2}$ 未知时 $\\mu$ 的 $100(1-\\alpha)\\%$ 置信区间的解析表达式。然后，将 $\\alpha$ 取值为 $0.05$，并使用给定数据计算 $\\mu$ 的 $95\\%$ 置信区间的数值端点。将您的数值端点四舍五入到四位有效数字。最终的区间端点以 mg/dL 为单位表示。\n\n最后，在监测背景下解释该区间的覆盖属性：解释在相同设计和总体条件下重复进行此类监测时，该区间构造方法具有 $95\\%$ 覆盖率的含义。", "solution": "首先，我们推导当总体方差 $\\sigma^2$ 未知时，总体均值 $\\mu$ 的 $100(1-\\alpha)\\%$ 置信区间的解析表达式。\n模型指出，个体测量值 $X_1, X_2, \\dots, X_n$ 是从均值为 $\\mu$、方差为 $\\sigma^2$ 的正态分布中抽取的独立同分布（iid）样本，记为 $X_i \\sim N(\\mu, \\sigma^2)$。样本大小为 $n$。\n样本均值为 $\\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i$。根据正态分布的性质，样本均值 $\\bar{X}$ 也服从正态分布，其均值为 $\\mu$，方差为 $\\frac{\\sigma^2}{n}$，即 $\\bar{X} \\sim N(\\mu, \\frac{\\sigma^2}{n})$。\n\n由于 $\\sigma^2$ 未知，必须从样本中进行估计。$\\sigma^2$ 的无偏估计量是样本方差 $S^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\bar{X})^2$。样本标准差为 $S = \\sqrt{S^2}$。\n\n枢轴量是样本数据和未知参数的函数，其分布不依赖于该未知参数。对于方差未知的正态样本，合适的枢轴量是 t-统计量：\n$$\nT = \\frac{\\bar{X} - \\mu}{S / \\sqrt{n}}\n$$\n根据统计学中的一个基本结果（常与Cochran定理相关），该量 $T$ 服从自由度为 $\\nu = n-1$ 的学生t分布。我们将其记为 $T \\sim t_{n-1}$。\n\n为了构建一个 $100(1-\\alpha)\\%$ 的置信区间，我们从t分布中找到一个临界值 $t_{n-1, \\alpha/2}$，使得值落在尾部的概率为 $\\alpha$。具体来说，$P(T > t_{n-1, \\alpha/2}) = \\alpha/2$。由于t分布关于 $0$ 对称，我们有：\n$$\nP(-t_{n-1, \\alpha/2}  T  t_{n-1, \\alpha/2}) = 1 - \\alpha\n$$\n代入 $T$ 的表达式：\n$$\nP\\left(-t_{n-1, \\alpha/2}  \\frac{\\bar{X} - \\mu}{S / \\sqrt{n}}  t_{n-1, \\alpha/2}\\right) = 1 - \\alpha\n$$\n现在我们整理不等式以分离出参数 $\\mu$：\n$$\n-t_{n-1, \\alpha/2} \\cdot \\frac{S}{\\sqrt{n}}  \\bar{X} - \\mu  t_{n-1, \\alpha/2} \\cdot \\frac{S}{\\sqrt{n}}\n$$\n所有部分都减去 $\\bar{X}$：\n$$\n-\\bar{X} - t_{n-1, \\alpha/2} \\cdot \\frac{S}{\\sqrt{n}}  -\\mu  -\\bar{X} + t_{n-1, \\alpha/2} \\cdot \\frac{S}{\\sqrt{n}}\n$$\n乘以 $-1$ 并反转不等号方向：\n$$\n\\bar{X} + t_{n-1, \\alpha/2} \\cdot \\frac{S}{\\sqrt{n}} > \\mu > \\bar{X} - t_{n-1, \\alpha/2} \\cdot \\frac{S}{\\sqrt{n}}\n$$\n这就得到了 $\\mu$ 的 $100(1-\\alpha)\\%$ 置信区间的解析表达式：\n$$\n\\left( \\bar{X} - t_{n-1, 1-\\alpha/2} \\frac{S}{\\sqrt{n}}, \\bar{X} + t_{n-1, 1-\\alpha/2} \\frac{S}{\\sqrt{n}} \\right)\n$$\n或者更紧凑地表示为 $\\bar{X} \\pm t_{n-1, 1-\\alpha/2} \\frac{S}{\\sqrt{n}}$。\n\n接下来，我们将此结果应用于给定数据，并计算 $95\\%$ 的置信区间。\n给定值为：\n样本大小 $n = 25$。\n样本均值 $\\bar{x} = 102$ mg/dL。\n样本标准差 $s = 18$ mg/dL。\n置信水平为 $95\\%$，所以 $1-\\alpha = 0.95$，这意味着 $\\alpha = 0.05$ 且 $\\alpha/2 = 0.025$。\n自由度为 $\\nu = n-1 = 25 - 1 = 24$。\n\n我们需要临界值 $t_{\\nu, 1-\\alpha/2} = t_{24, 0.975}$。从标准的t分布表或统计软件中，可以查到该值约为 $2.064$。\n$t_{24, 0.975} \\approx 2.064$。\n\n均值标准误计算如下：\n$$\nSE(\\bar{x}) = \\frac{s}{\\sqrt{n}} = \\frac{18}{\\sqrt{25}} = \\frac{18}{5} = 3.6\n$$\n误差范围（ME）为：\n$$\nME = t_{24, 0.975} \\times SE(\\bar{x}) \\approx 2.064 \\times 3.6 = 7.4304\n$$\n置信区间的端点是：\n下限：$\\bar{x} - ME = 102 - 7.4304 = 94.5696$。\n上限：$\\bar{x} + ME = 102 + 7.4304 = 109.4304$。\n\n问题要求将端点四舍五入到四位有效数字。\n对于下限 $94.5696$，四位有效数字是 $9$、$4$、$5$ 和 $6$。下一位数字是 $9$，因此我们向上取整：$94.57$。\n对于上限 $109.4304$，四位有效数字是 $1$、$0$、$9$ 和 $4$。下一位数字是 $3$，因此我们不向上取整：$109.4$。\n$\\mu$ 的数值 $95\\%$ 置信区间为 $(94.57, 109.4)$ mg/dL。\n\n最后，我们解释此区间构造方法的覆盖属性。\n$95\\%$ 的置信水平指的是该方法的长期性能，而不是指单个计算出的区间。在公共卫生监测项目的背景下，其解释如下：如果在相同的总体条件下，将此筛查过程（抽取一个大小为 $n=25$ 的成年人简单随机样本，并计算空腹血糖均值的 $95\\%$ 置信区间）重复非常多次，那么这样构造出的所有区间中，大约有 $95\\%$ 会包含真实但未知的总体血糖均值 $\\mu$。另外 $5\\%$ 的区间则不会捕获 $\\mu$。声称特定的区间 $(94.57, 109.4)$ 有 $95\\%$ 的概率包含 $\\mu$ 是不正确的；一旦计算出来，这个区间要么包含 $\\mu$，要么不包含。概率是与生成区间的过程相关联的，而不是与单次实例的结果相关联。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n94.57  109.4\n\\end{pmatrix}\n}\n$$", "id": "4563667"}, {"introduction": "许多健康风险因素（如血压、体重指数和胆固醇）并非相互独立，而是彼此相关的。本计算实践将引导你通过编程，学习如何模拟具有特定均值和协方差结构的多维正态数据，这项技术对于现代流行病学建模和评估复杂健康干预措施至关重要。[@problem_id:4563690]", "problem": "一个公共卫生研究小组正在准备一项蒙特卡洛研究，以评估一个大型队列中的筛查策略。为了真实地反映经过标准转换后近似呈高斯分布的连续风险因素（例如，收缩压、身体质量指数和低密度脂蛋白胆固醇）的联合变异，他们需要使用预先指定的均值向量和协方差矩阵来模拟相关的正态样本。目标是实现一个基于第一性原理的有原则的算法，该算法能生成具有给定均值向量和协方差矩阵的多元正态样本，然后使用基于抽样变异性证明的容差，对照其目标来验证经验均值向量和经验协方差矩阵。\n\n问题的基本基础：\n- 多元正态分布的定义，以及独立标准正态变量的线性变换会产生一般多元正态变量的性质。\n- 协方差矩阵的性质，包括对称性和正定性，以及这类矩阵存在唯一的下三角因子，该因子可用于构建所需的线性变换。\n- 从多元正态分布中进行独立同分布抽样的经验矩的抽样变异性，包括样本均值的方差以及当真实均值已知时最大似然协方差估计量的方差结构。\n\n你的任务是编写一个完整、可运行的程序，对于每个提供的测试用例，以纯粹的数学和算法方式执行以下步骤：\n\n1. 输入规范在程序内部固定（无外部输入）。对于每个测试用例，给定：\n   - 一个由均值向量 $\\boldsymbol{\\mu} \\in \\mathbb{R}^d$ 的长度所隐含的维度 $d$。\n   - 一个旨在为正定的对称协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{d \\times d}$。\n   - 一个样本量 $N \\in \\mathbb{N}$。\n   - 一个伪随机种子 $s \\in \\mathbb{N}$。\n\n2. 验证 $\\boldsymbol{\\Sigma}$ 是对称且正定的。如果 $\\boldsymbol{\\Sigma}$ 不是对称的或不是正定的，则测试用例的结果必须是 $[\\text{False},\\text{False}]$。\n\n3. 使用正定性所保证的唯一一个下三角因子，构建一个将独立标准正态抽样映射到均值为 $\\boldsymbol{\\mu}$、协方差为 $\\boldsymbol{\\Sigma}$ 的多元正态抽样的变换。使用以种子 $s$ 初始化的可复现伪随机数生成器生成 $N$ 个独立样本。\n\n4. 使用已知的目标均值 $\\boldsymbol{\\mu}$ 进行中心化，计算经验均值向量 $\\widehat{\\boldsymbol{\\mu}} \\in \\mathbb{R}^d$ 和最大似然协方差估计 $\\widehat{\\boldsymbol{\\Sigma}} \\in \\mathbb{R}^{d \\times d}$。\n\n5. 定义反映多元正态模型下抽样变异性的容差阈值：\n   - 对于均值，对每个分量 $j \\in \\{1,\\dots,d\\}$，定义容差\n     $$\\tau^{(\\mu)}_j = k_{\\mu} \\sqrt{\\frac{\\boldsymbol{\\Sigma}_{jj}}{N}},$$\n     其中 $k_{\\mu} \\in \\mathbb{R}$ 是一个固定的乘数。使用 $k_{\\mu} = 4.0$。\n   - 对于协方差，对每个元素 $(i,j)$，定义容差\n     $$\\tau^{(\\Sigma)}_{ij} = k_{\\Sigma} \\sqrt{\\frac{\\boldsymbol{\\Sigma}_{ij}^2 + \\boldsymbol{\\Sigma}_{ii}\\boldsymbol{\\Sigma}_{jj}}{N}},$$\n     其中 $k_{\\Sigma} \\in \\mathbb{R}$ 是一个固定的乘数。使用 $k_{\\Sigma} = 4.0$。\n\n6. 为每个测试用例确定两个布尔值：\n   - 一个均值接受布尔值，当且仅当对于所有 $j \\in \\{1,\\dots,d\\}$ 都有 $|\\widehat{\\mu}_j - \\mu_j| \\le \\tau^{(\\mu)}_j$ 时，该值为 $\\text{True}$。\n   - 一个协方差接受布尔值，当且仅当对于所有 $i,j \\in \\{1,\\dots,d\\}$ 都有 $|\\widehat{\\Sigma}_{ij} - \\Sigma_{ij}| \\le \\tau^{(\\Sigma)}_{ij}$ 时，该值为 $\\text{True}$。\n\n7. 最终的程序输出必须是单行，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身是一个包含步骤6中描述的两个布尔值的双元素方括号列表。例如，格式为\n   $$[\\,[b_{1,1},b_{1,2}],\\,[b_{2,1},b_{2,2}],\\,[b_{3,1},b_{3,2}],\\,[b_{4,1},b_{4,2}]\\,],$$\n   打印时不含空格，其中每个 $b_{k,\\ell}$ 为 $\\text{True}$ 或 $\\text{False}$。\n\n测试套件：\n- 案例1（单位协方差，零均值）：\n  - $\\boldsymbol{\\mu} = [\\,0,\\,0,\\,0\\,]$.\n  - 相关矩阵 $\\mathbf{C}_1 = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$ 和标准差 $\\boldsymbol{\\sigma} = [\\,1,\\,1,\\,1\\,]$，因此 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{\\sigma})\\,\\mathbf{C}_1\\,\\mathrm{diag}(\\boldsymbol{\\sigma})$ 等于单位矩阵。\n  - $N = 50000$。\n  - $s = 12345$。\n\n- 案例2（实际的中等相关性）：\n  - $\\boldsymbol{\\mu} = [\\,120,\\,27,\\,130\\,]$。\n  - 相关矩阵 $\\mathbf{C}_2 = \\begin{bmatrix} 1  0.4  -0.2 \\\\ 0.4  1  0.3 \\\\ -0.2  0.3  1 \\end{bmatrix}$ 和标准差 $\\boldsymbol{\\sigma} = [\\,12,\\,4,\\,25\\,]$，因此 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{\\sigma})\\,\\mathbf{C}_2\\,\\mathrm{diag}(\\boldsymbol{\\sigma})$。\n  - $N = 60000$。\n  - $s = 2468$。\n\n- 案例3（近奇异高相关性）：\n  - $\\boldsymbol{\\mu} = [\\,50,\\,50,\\,50\\,]$。\n  - 具有恒定非对角线元素 $r$ 的相关矩阵：$\\mathbf{C}_3 = \\begin{bmatrix} 1  r  r \\\\ r  1  r \\\\ r  r  1 \\end{bmatrix}$，$r = 0.99$，标准差 $\\boldsymbol{\\sigma} = [\\,10,\\,10,\\,10\\,]$，因此 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{\\sigma})\\,\\mathbf{C}_3\\,\\mathrm{diag}(\\boldsymbol{\\sigma})$。\n  - $N = 80000$。\n  - $s = 13579$。\n\n- 案例4（负相关和混合相关）：\n  - $\\boldsymbol{\\mu} = [\\,110,\\,23,\\,95\\,]$。\n  - 相关矩阵 $\\mathbf{C}_4 = \\begin{bmatrix} 1  -0.4  0.1 \\\\ -0.4  1  0.3 \\\\ 0.1  0.3  1 \\end{bmatrix}$ 和标准差 $\\boldsymbol{\\sigma} = [\\,8,\\,6,\\,5\\,]$，因此 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{\\sigma})\\,\\mathbf{C}_4\\,\\mathrm{diag}(\\boldsymbol{\\sigma})$。\n  - $N = 70000$。\n  - $s = 97531$。\n\n实现约束：\n- 您必须为每个案例使用带有固定种子的伪随机数生成器，以确保可复现性。\n- 将协方差估计在已知目标 $\\boldsymbol{\\mu}$ 处中心化，而不是在样本均值处，以便与已知均值下的最大似然估计量对齐。\n- 无外部输入或文件；所有参数都在程序内部定义。\n- 最终输出必须严格按照步骤7中描述的格式打印为单行，不含空格。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[\\,[\\text{True},\\text{True}],\\,[\\text{True},\\text{False}]\\,]$），打印时不含空格。", "solution": "### 理论框架\n\n从一般多元正态分布生成样本是基于该分布的一个基本性质。如果一个 $d$ 维随机向量 $\\mathbf{X}$，对于任何常数向量 $\\mathbf{a} \\in \\mathbb{R}^d$，线性组合 $\\mathbf{a}^T\\mathbf{X}$ 都是一个单变量正态随机变量，则称该向量服从均值向量为 $\\boldsymbol{\\mu} \\in \\mathbb{R}^d$、协方差矩阵为 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{d \\times d}$ 的多元正态分布，记为 $\\mathbf{X} \\sim \\mathcal{N}_d(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$。\n\n生成此类样本的核心原理基于仿射变换性质。设 $\\mathbf{Z}$ 是一个 $d$ 维随机向量，其分量是独立同分布的标准正态随机变量，即对于 $i=1, \\dots, d$，有 $Z_i \\sim \\mathcal{N}(0, 1)$。$\\mathbf{Z}$ 的均值为 $\\mathbb{E}[\\mathbf{Z}] = \\mathbf{0}$，其协方差矩阵为 $\\mathbb{E}[\\mathbf{Z}\\mathbf{Z}^T] = \\mathbf{I}$，即单位矩阵。\n\n考虑 $\\mathbf{Z}$ 的一个线性变换，形式如下：\n$$ \\mathbf{X} = \\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{Z} $$\n其中 $\\mathbf{L}$ 是一个 $d \\times d$ 矩阵。$\\mathbf{X}$ 的均值为：\n$$ \\mathbb{E}[\\mathbf{X}] = \\mathbb{E}[\\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{Z}] = \\boldsymbol{\\mu} + \\mathbf{L}\\mathbb{E}[\\mathbf{Z}] = \\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{0} = \\boldsymbol{\\mu} $$\n$\\mathbf{X}$ 的协方差矩阵为：\n$$ \\mathrm{Cov}(\\mathbf{X}) = \\mathbb{E}[(\\mathbf{X} - \\boldsymbol{\\mu})(\\mathbf{X} - \\boldsymbol{\\mu})^T] = \\mathbb{E}[(\\mathbf{L}\\mathbf{Z})(\\mathbf{L}\\mathbf{Z})^T] = \\mathbb{E}[\\mathbf{L}\\mathbf{Z}\\mathbf{Z}^T\\mathbf{L}^T] = \\mathbf{L}\\mathbb{E}[\\mathbf{Z}\\mathbf{Z}^T]\\mathbf{L}^T = \\mathbf{L}\\mathbf{I}\\mathbf{L}^T = \\mathbf{L}\\mathbf{L}^T $$\n要生成具有目标协方差矩阵 $\\boldsymbol{\\Sigma}$ 的样本 $\\mathbf{X}$，我们必须找到一个矩阵 $\\mathbf{L}$，使得 $\\boldsymbol{\\Sigma} = \\mathbf{L}\\mathbf{L}^T$。\n\n### Cholesky分解\n\n找到这样一个矩阵 $\\mathbf{L}$ 的一个标准且计算高效的方法是Cholesky分解。协方差矩阵 $\\boldsymbol{\\Sigma}$ 必须是对称且正定的。一个实对称矩阵 $\\boldsymbol{\\Sigma}$ 是正定的，当且仅当它能唯一地分解为一个对角线元素为正的下三角矩阵 $\\mathbf{L}$ 与其转置 $\\mathbf{L}^T$ 的乘积：\n$$ \\boldsymbol{\\Sigma} = \\mathbf{L}\\mathbf{L}^T $$\n此分解提供了所需的变换矩阵 $\\mathbf{L}$。这种唯一分解的存在性也是一种检验正定性的构造性方法。如果Cholesky分解算法成功，则矩阵是正定的；如果失败，则不是。\n\n### 算法与实现\n\n对于每个测试用例，解决方案按以下步骤进行。\n\n1.  **输入规范与验证**：定义给定的目标均值向量 $\\boldsymbol{\\mu}$、相关矩阵 $\\mathbf{C}$、标准差向量 $\\boldsymbol{\\sigma}$、样本量 $N$ 和种子 $s$。通过关系式 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{\\sigma})\\,\\mathbf{C}\\,\\mathrm{diag}(\\boldsymbol{\\sigma})$ 构建协方差矩阵 $\\boldsymbol{\\Sigma}$。首先验证矩阵 $\\boldsymbol{\\Sigma}$ 的对称性，即检查是否 $\\boldsymbol{\\Sigma} = \\boldsymbol{\\Sigma}^T$。随后，通过尝试计算其Cholesky分解来确认其正定性。如果 $\\boldsymbol{\\Sigma}$ 不是对称的或分解失败，则该矩阵不是正定的，并且该测试用例的结果记录为 $[\\text{False}, \\text{False}]$。\n\n2.  **样本生成**：\n    - 使用指定的种子 $s$ 初始化一个伪随机数生成器，以确保可复现性。\n    - 生成一个 $N \\times d$ 的独立标准正态样本矩阵 $\\mathbf{Z}_s$。$\\mathbf{Z}_s$ 的每一行代表从 $d$ 维标准正态分布中进行的一次抽样 $\\mathbf{z}^T$。\n    - 从有效的协方差矩阵 $\\boldsymbol{\\Sigma}$ 计算Cholesky因子 $\\mathbf{L}$。\n    - 使用变换生成来自 $\\mathcal{N}_d(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$ 的 $N$ 个样本。设 $\\mathbf{X}$ 为生成的 $N \\times d$ 样本矩阵。$\\mathbf{X}$ 的第 $i$ 行，记为 $\\mathbf{x}_i^T$，计算为 $\\mathbf{x}_i^T = \\boldsymbol{\\mu}^T + \\mathbf{z}_i^T \\mathbf{L}^T$。用矩阵表示法，即为 $\\mathbf{X} = \\mathbf{1}\\boldsymbol{\\mu}^T + \\mathbf{Z}_s \\mathbf{L}^T$，其中 $\\mathbf{1}$ 是一个长度为 $N$ 的全一列向量。\n\n3.  **经验矩估计**：\n    - 通过对样本向量求平均来计算经验均值向量 $\\widehat{\\boldsymbol{\\mu}}$：\n      $$ \\widehat{\\boldsymbol{\\mu}} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{x}_i $$\n    - 在给定已知总体均值 $\\boldsymbol{\\mu}$ 的情况下，协方差矩阵的最大似然估计计算如下：\n      $$ \\widehat{\\boldsymbol{\\Sigma}} = \\frac{1}{N} \\sum_{i=1}^N (\\mathbf{x}_i - \\boldsymbol{\\mu})(\\mathbf{x}_i - \\boldsymbol{\\mu})^T $$\n\n4.  **容差计算与验证**：\n    - **均值验证**：对于每个分量 $j \\in \\{1,\\dots,d\\}$，将绝对差 $|\\widehat{\\mu}_j - \\mu_j|$ 与容差 $\\tau_j^{(\\mu)}$ 进行比较。此容差与样本均值估计量 $\\widehat{\\mu}_j$ 的标准差成正比，即 $\\sqrt{\\boldsymbol{\\Sigma}_{jj}/N}$。容差设置为：\n      $$ \\tau_j^{(\\mu)} = k_{\\mu} \\sqrt{\\frac{\\boldsymbol{\\Sigma}_{jj}}{N}} $$\n      其中 $k_{\\mu} = 4.0$。如果对所有 $j$ 都满足 $|\\widehat{\\mu}_j - \\mu_j| \\le \\tau_j^{(\\mu)}$，则均值接受布尔值为 $\\text{True}$。\n\n    - **协方差验证**：对于每个元素 $(i,j)$，将绝对差 $|\\widehat{\\Sigma}_{ij} - \\Sigma_{ij}|$ 与容差 $\\tau_{ij}^{(\\Sigma)}$ 进行比较。对于具有已知均值的正态分布，此容差与估计量 $\\widehat{\\Sigma}_{ij}$ 的标准差成正比，即 $\\sqrt{(\\boldsymbol{\\Sigma}_{ij}^2 + \\boldsymbol{\\Sigma}_{ii}\\boldsymbol{\\Sigma}_{jj})/N}$。容差设置为：\n      $$ \\tau_{ij}^{(\\Sigma)} = k_{\\Sigma} \\sqrt{\\frac{\\boldsymbol{\\Sigma}_{ij}^2 + \\boldsymbol{\\Sigma}_{ii}\\boldsymbol{\\Sigma}_{jj}}{N}} $$\n      其中 $k_{\\Sigma} = 4.0$。如果对所有对 $(i, j)$ 都满足 $|\\widehat{\\Sigma}_{ij} - \\Sigma_{ij}| \\le \\tau_{ij}^{(\\Sigma)}$，则协方差接受布尔值为 $\\text{True}$。\n\n乘数 $k=4.0$ 意味着检查经验估计值是否落在其期望值的4个标准差之内。根据 Chebyshev's inequality，任何单次检查失败的概率小于 $1/k^2 = 1/16$，而对于高斯估计量，这个概率要小得多（约为 $6 \\times 10^{-5}$）。这使得测试变得严格，但考虑了预期的抽样变异性。\n\n最终输出是一个列表，其中包含每个测试用例的布尔值对 $[\\text{均值接受}, \\text{协方差接受}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multivariate normal simulation and validation problem.\n    \"\"\"\n    test_cases = [\n        # Case 1: identity covariance, zero mean\n        {'mu': np.array([0., 0., 0.]),\n         'C': np.array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]),\n         'sigma_vec': np.array([1., 1., 1.]),\n         'N': 50000,\n         's': 12345},\n        # Case 2: realistic moderate correlations\n        {'mu': np.array([120., 27., 130.]),\n         'C': np.array([[1., 0.4, -0.2], [0.4, 1., 0.3], [-0.2, 0.3, 1.]]),\n         'sigma_vec': np.array([12., 4., 25.]),\n         'N': 60000,\n         's': 2468},\n        # Case 3: near-singular high correlation\n        {'mu': np.array([50., 50., 50.]),\n         'C': np.array([[1., 0.99, 0.99], [0.99, 1., 0.99], [0.99, 0.99, 1.]]),\n         'sigma_vec': np.array([10., 10., 10.]),\n         'N': 80000,\n         's': 13579},\n        # Case 4: negative and mixed correlations\n        {'mu': np.array([110., 23., 95.]),\n         'C': np.array([[1., -0.4, 0.1], [-0.4, 1., 0.3], [0.1, 0.3, 1.]]),\n         'sigma_vec': np.array([8., 6., 5.]),\n         'N': 70000,\n         's': 97531},\n    ]\n\n    results = []\n    k_mu = 4.0\n    k_Sigma = 4.0\n\n    for case in test_cases:\n        mu = case['mu']\n        C = case['C']\n        sigma_vec = case['sigma_vec']\n        N = case['N']\n        s = case['s']\n\n        # 1. Construct covariance matrix Sigma\n        D = np.diag(sigma_vec)\n        Sigma = D @ C @ D\n        \n        # 2. Validate Sigma: must be symmetric and positive definite\n        # Check symmetry\n        if not np.allclose(Sigma, Sigma.T):\n            results.append([False, False])\n            continue\n        \n        # Check positive definiteness by attempting Cholesky decomposition\n        try:\n            L = np.linalg.cholesky(Sigma)\n        except np.linalg.LinAlgError:\n            results.append([False, False])\n            continue\n\n        # 3. Generate samples\n        d = len(mu)\n        rng = np.random.default_rng(seed=s)\n        Z = rng.standard_normal(size=(N, d))\n        # X = mu + Z @ L.T\n        X = mu + Z.dot(L.T)\n\n        # 4. Compute empirical statistics\n        # Empirical mean\n        mu_hat = np.mean(X, axis=0)\n        \n        # Empirical covariance (MLE with known mean mu)\n        X_centered_known_mean = X - mu\n        # Sigma_hat = (X_centered_known_mean.T @ X_centered_known_mean) / N\n        Sigma_hat = np.cov(X_centered_known_mean, rowvar=False, ddof=0)\n        \n        # 5. Define tolerance thresholds\n        # Mean tolerance\n        tol_mu = k_mu * np.sqrt(np.diag(Sigma) / N)\n        \n        # Covariance tolerance\n        Sigma_ii = np.diag(Sigma).reshape(-1, 1)\n        Sigma_jj = np.diag(Sigma).reshape(1, -1)\n        Sigma_ii_jj = Sigma_ii @ Sigma_jj\n        tol_Sigma = k_Sigma * np.sqrt((np.square(Sigma) + Sigma_ii_jj) / N)\n\n        # 6. Determine acceptance booleans\n        mean_accepted = np.all(np.abs(mu_hat - mu) = tol_mu)\n        cov_accepted = np.all(np.abs(Sigma_hat - Sigma) = tol_Sigma)\n        \n        results.append([bool(mean_accepted), bool(cov_accepted)])\n\n    # 7. Format final output\n    formatted_results = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4563690"}]}