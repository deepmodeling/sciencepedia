{"hands_on_practices": [{"introduction": "在疫情调查中，我们首先需要明确“谁是病例”。病例定义通常结合多种标准，如临床症状和实验室检测结果。本练习将探讨构建病例定义时的核心权衡。[@problem_id:4507895]\n\n我们将学习如何通过串联（“与”逻辑）和并联（“或”逻辑）两种方式组合诊断测试，并分析这两种策略如何影响病例定义的整体灵敏度与特异度。串联检测通常以牺牲灵敏度为代价来提高特异度，而并联检测则相反；理解这一权衡对于制定科学的公共卫生决策至关重要。", "problem": "一个呼吸道疾病暴发调查小组正在制定一个病例定义，以构建每日新增病例的流行曲线。他们考虑采用一种双重检测算法，包括初步的症状筛查，然后进行逆转录聚合酶链式反应 (RT-PCR) 检测。症状筛查的灵敏度为 $0.78$，特异度为 $0.65$，而 RT-PCR 检测的灵敏度为 $0.92$，特异度为 $0.98$。假设在给定患病状态的情况下，检测结果是条件独立的：对于患病个体，两次检测结果均为阳性的概率是各自概率的乘积；对于非患病个体，两次检测结果均为阳性的概率也是各自概率的乘积。\n\n正在考虑两种候选病例定义：\n- 串联（与）结构：当且仅当症状筛查和 RT-PCR 检测结果均为阳性时，才归类为病例。\n- 并联（或）结构：如果症状筛查或 RT-PCR 检测任一结果为阳性，则归类为病例。\n\n仅使用灵敏度和特异度作为正确分类的条件概率的核心定义以及所述的独立性假设，计算该双重检测算法在串联（与）和并联（或）结构下的联合灵敏度和联合特异度。按以下顺序提供您的最终答案：串联灵敏度、串联特异度、并联灵敏度、并联特异度。请用小数表示您的答案（不要使用百分号），并四舍五入到四位有效数字。", "solution": "该问题要求计算一个双重检测算法在两种不同组合结构下（串联（与）和并联（或））的联合灵敏度和特异度。我们首先形式化地定义给定的参数，然后推导所求量的表达式。\n\n设 $D$ 表示个体患病的事件，$D^c$ 表示个体未患病的事件。设 $T_1$ 表示症状筛查，$T_2$ 表示 RT-PCR 检测。检测 $i$ 的阳性结果表示为 $T_i^+$，阴性结果表示为 $T_i^-$。\n\n一项检测的灵敏度是在个体患病条件下检测结果为阳性的概率。一项检测的特异度是在个体未患病条件下检测结果为阴性的概率。\n\n给定的灵敏度为：\n检测1的灵敏度：$S_1 = P(T_1^+ | D) = 0.78$\n检测2的灵敏度：$S_2 = P(T_2^+ | D) = 0.92$\n\n给定的特异度为：\n检测1的特异度：$C_1 = P(T_1^- | D^c) = 0.65$\n检测2的特异度：$C_2 = P(T_2^- | D^c) = 0.98$\n\n根据这些定义，我们可以推导出互补事件的概率：\n检测1的假阴性概率为 $P(T_1^- | D) = 1 - P(T_1^+|D) = 1 - S_1 = 1 - 0.78 = 0.22$。\n检测1的假阳性概率为 $P(T_1^+ | D^c) = 1 - P(T_1^-|D^c) = 1 - C_1 = 1 - 0.65 = 0.35$。\n检测2的假阴性概率为 $P(T_2^- | D) = 1 - P(T_2^+|D) = 1 - S_2 = 1 - 0.92 = 0.08$。\n检测2的假阳性概率为 $P(T_2^+ | D^c) = 1 - P(T_2^-|D^c) = 1 - C_2 = 1 - 0.98 = 0.02$。\n\n问题陈述，在给定患病状态下，检测结果是条件独立的。这意味着对于 $T_1$ 和 $T_2$ 的任何结果，它们在给定患病状态下的联合条件概率是它们各自条件概率的乘积。例如，$P(T_1^+, T_2^+ | D) = P(T_1^+ | D) P(T_2^+ | D)$。\n\n**串联（与）结构**\n在串联结构中，当且仅当两次检测结果均为阳性时，个体才被归类为病例。如果事件 $T_1^+ \\cap T_2^+$ 发生，则总体检测结果为阳性。\n\n串联算法的联合灵敏度 $S_{serial}$ 是在个体患病条件下，组合检测结果为阳性的概率：\n$$S_{serial} = P(T_1^+ \\cap T_2^+ | D)$$\n使用条件独立性假设：\n$$S_{serial} = P(T_1^+ | D) \\times P(T_2^+ | D) = S_1 \\times S_2$$\n代入给定值：\n$$S_{serial} = 0.78 \\times 0.92 = 0.7176$$\n\n串联算法的联合特异度 $C_{serial}$ 是在个体未患病条件下，组合检测结果为阴性的概率。在串联算法中，阴性结果意味着并非两次检测都为阳性，即事件 $(T_1^+ \\cap T_2^+)^c = T_1^- \\cup T_2^-$。\n$$C_{serial} = P((T_1^+ \\cap T_2^+)^c | D^c) = 1 - P(T_1^+ \\cap T_2^+ | D^c)$$\n使用条件独立性假设：\n$$C_{serial} = 1 - \\left( P(T_1^+ | D^c) \\times P(T_2^+ | D^c) \\right) = 1 - (1 - C_1)(1 - C_2)$$\n代入给定值：\n$$C_{serial} = 1 - (1 - 0.65)(1 - 0.98) = 1 - (0.35)(0.02) = 1 - 0.007 = 0.993$$\n\n**并联（或）结构**\n在并联结构中，如果任一检测结果为阳性，个体就被归类为病例。如果事件 $T_1^+ \\cup T_2^+$ 发生，则总体检测结果为阳性。\n\n并联算法的联合灵敏度 $S_{parallel}$ 是在个体患病条件下，组合检测结果为阳性的概率：\n$$S_{parallel} = P(T_1^+ \\cup T_2^+ | D)$$\n使用互补事件计算更为简单。“至少一个阳性”的互补事件是“均为阴性”，即 $(T_1^+ \\cup T_2^+)^c = T_1^- \\cap T_2^-$。\n$$S_{parallel} = 1 - P(T_1^- \\cap T_2^- | D)$$\n使用条件独立性假设：\n$$S_{parallel} = 1 - \\left( P(T_1^- | D) \\times P(T_2^- | D) \\right) = 1 - (1 - S_1)(1 - S_2)$$\n代入给定值：\n$$S_{parallel} = 1 - (1 - 0.78)(1 - 0.92) = 1 - (0.22)(0.08) = 1 - 0.0176 = 0.9824$$\n\n并联算法的联合特异度 $C_{parallel}$ 是在个体未患病条件下，组合检测结果为阴性的概率。在并联算法中，阴性结果要求两次检测均为阴性，即事件 $T_1^- \\cap T_2^-$。\n$$C_{parallel} = P(T_1^- \\cap T_2^- | D^c)$$\n使用条件独立性假设：\n$$C_{parallel} = P(T_1^- | D^c) \\times P(T_2^- | D^c) = C_1 \\times C_2$$\n代入给定值：\n$$C_{parallel} = 0.65 \\times 0.98 = 0.637$$\n\n问题要求答案以小数形式表示，并四舍五入到四位有效数字。\n- 串联灵敏度：$S_{serial} = 0.7176$。这有四位有效数字。\n- 串联特异度：$C_{serial} = 0.993$。保留四位有效数字，为 $0.9930$。\n- 并联灵敏度：$S_{parallel} = 0.9824$。这有四位有效数字。\n- 并联特异度：$C_{parallel} = 0.637$。保留四位有效数字，为 $0.6370$。\n\n最终结果按指定顺序（串联灵敏度、串联特异度、并联灵敏度、并联特异度）为 $0.7176$，$0.9930$，$0.9824$ 和 $0.6370$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.7176  0.9930  0.9824  0.6370\n\\end{pmatrix}\n}\n$$", "id": "4507895"}, {"introduction": "掌握了病例定义的理论基础后，我们将在本练习中将其付诸实践。我们将看到，对同一份原始患者数据应用不同的病例定义（例如，一个严格，一个宽松）会如何产生形态迥异的流行曲线。[@problem_id:4507891]\n\n通过亲手构建这些曲线，并使用归一化均方根误差（NRMSE）来量化它们之间的差异，您将直观地理解病例定义的选择如何直接影响我们对疫情规模、发展速度和时间进程的判断。这项练习强调了在解读任何流行曲线时，清晰阐明并理解其所依据的病例定义是何等重要。", "problem": "给定一份包含个体症状发作时间和代表临床与流行病学标准的二进制属性的病例清单。您的任务是根据两种不同的病例定义构建流行曲线，使用归一化均方根误差比较它们随时间变化的形状，并报告每个测试用例的结果。此问题的科学基础是公共卫生监测中的病例定义概念，以及作为新发病例按时间汇总计数的流行曲线。时间以天为单位进行测量，并表示为整数日期索引。您必须按天进行汇总，并以四舍五入到六位小数的实数报告结果。\n\n定义和假设：\n- 流行曲线是在一个时间窗口内，满足给定病例定义的新发病例每日计数序列。给定一组有限的包含发病时间的病例清单记录，将时间窗口定义为从该病例清单中观察到的最小发病日到最大发病日的闭区间范围。\n- 对于一个固定的时间窗口，其日期索引为 $t \\in \\{t_{\\min}, t_{\\min}+1, \\dots, t_{\\max}\\}$，令 $c_{A}(t)$ 和 $c_{B}(t)$ 分别表示病例定义 $A$ 和 $B$ 下的每日计数。\n- 均方根误差定义为\n$$\n\\mathrm{RMSE}(A,B) = \\sqrt{\\frac{1}{|T|} \\sum_{t \\in T} \\left(c_{A}(t) - c_{B}(t)\\right)^2},\n$$\n其中 $T$ 是窗口中所有日期的集合， $|T|$ 是天数。\n- 为了在无标度的基础上比较曲线，定义归一化常数\n$$\n\\mu = \\frac{1}{2}\\left(\\overline{c_{A}} + \\overline{c_{B}}\\right),\n$$\n其中 $\\overline{c_{A}} = \\frac{1}{|T|}\\sum_{t \\in T} c_{A}(t)$ 且 $\\overline{c_{B}} = \\frac{1}{|T|}\\sum_{t \\in T} c_{B}(t)$。\n- 则归一化均方根误差为\n$$\n\\mathrm{NRMSE}(A,B) =\n\\begin{cases}\n0,  \\text{if } \\mu = 0, \\\\\n\\dfrac{\\mathrm{RMSE}(A,B)}{\\mu},  \\text{if } \\mu \\neq 0.\n\\end{cases}\n$$\n\n病例定义：\n- 病例定义 $A$ (严格)：当且仅当同时出现发烧和咳嗽，并且至少满足实验室确诊或已知暴露史中的一项时，才纳入记录。使用二进制变量 $F$ (发烧)、$C$ (咳嗽)、$S$ (呼吸急促)、$L$ (实验室确诊) 和 $E$ (已知暴露史)，纳入规则为\n$$\nA: \\quad (F = 1) \\wedge (C = 1) \\wedge \\left((L = 1) \\vee (E = 1)\\right).\n$$\n- 病例定义 $B$ (宽松)：当且仅当出现发烧、咳嗽或呼吸急促中至少一项，并且至少满足实验室确诊或已知暴露史中的一项时，才纳入记录：\n$$\nB: \\quad \\left((F = 1) \\vee (C = 1) \\vee (S = 1)\\right) \\wedge \\left((L = 1) \\vee (E = 1)\\right).\n$$\n\n数据模型：\n- 病例清单中的每条记录都是一个 $(d, F, C, S, L, E)$ 形式的元组，其中 $d$ 是以天为单位的整数发病日，$F, C, S, L, E \\in \\{0,1\\}$ 是二进制指示符。\n- 时间单位是天。所有发病日 $d$ 都是以天为单位的整数。\n\n任务：\n- 对于每个提供的测试用例，通过对该测试用例病例清单中从 $t_{\\min}$ 到 $t_{\\max}$ 的闭区间范围内的每一天 $t$ 计数符合条件的记录，来计算 $c_{A}(t)$ 和 $c_{B}(t)$。然后，按上述定义计算 $\\mathrm{NRMSE}(A,B)$。\n- 将每个测试用例的最终结果表示为一个精确到六位小数的实数。\n\n测试套件：\n- 测试用例 $1$：\n  - 病例清单记录：\n    - $(0, 1, 1, 0, 1, 0)$\n    - $(0, 1, 0, 0, 1, 0)$\n    - $(1, 1, 1, 0, 0, 1)$\n    - $(1, 1, 0, 1, 0, 1)$\n    - $(2, 1, 1, 0, 0, 0)$\n    - $(2, 0, 1, 1, 1, 0)$\n    - $(3, 0, 0, 1, 0, 1)$\n    - $(3, 1, 1, 1, 1, 1)$\n    - $(4, 1, 1, 0, 1, 1)$\n    - $(5, 1, 1, 0, 0, 1)$\n    - $(6, 0, 0, 0, 1, 1)$\n    - $(7, 1, 0, 0, 0, 1)$\n    - $(8, 0, 1, 0, 1, 0)$\n    - $(9, 1, 1, 1, 0, 0)$\n- 测试用例 $2$：\n  - 病例清单记录：\n    - $(0, 1, 1, 0, 1, 0)$\n    - $(0, 1, 1, 0, 0, 1)$\n    - $(1, 1, 1, 0, 1, 1)$\n    - $(1, 0, 0, 1, 0, 0)$\n    - $(2, 1, 1, 0, 0, 0)$\n    - $(2, 1, 1, 1, 1, 1)$\n    - $(3, 0, 0, 0, 1, 1)$\n    - $(3, 1, 1, 0, 0, 1)$\n- 测试用例 $3$：\n  - 病例清单记录：\n    - $(5, 0, 1, 0, 1, 0)$\n- 测试用例 $4$：\n  - 病例清单记录：\n    - $(2, 0, 0, 0, 1, 1)$\n    - $(3, 1, 0, 0, 0, 0)$\n    - $(4, 0, 1, 1, 0, 0)$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个值都精确到六位小数，并按测试用例 $1$、测试用例 $2$、测试用例 $3$、测试用例 $4$ 的顺序排列；例如，一个有效的格式是\n$$\n[\\text{value}_{1},\\text{value}_{2},\\text{value}_{3},\\text{value}_{4}].\n$$", "solution": "问题陈述已经过分析并被确定为有效。它在科学上基于流行病学原理，特别是公共卫生监测、病例定义和流行曲线分析。该问题定义明确，提供了获得唯一且可验证解所需的所有必要定义、数据和数学公式。语言客观，结构合乎逻辑。\n\n解法是通过对每个测试用例执行一系列明确定义的计算步骤得出的。总体方法包括：\n1.  从提供的病例清单中确定监测时间窗口。\n2.  根据严格（A）和宽松（B）的病例定义对每个病例进行分类，并按天汇总计数，从而构建两条流行曲线 $c_A(t)$ 和 $c_B(t)$。\n3.  使用提供的公式计算两条曲线之间的归一化均方根误差（$\\mathrm{NRMSE}$）。\n\n让我们详细说明这些步骤。\n\n**第1步：确定时间窗口**\n对于每个测试用例，我们都得到一份病例清单记录，其中每条记录都包含一个整数发病日 $d$。监测时间窗口 $T$ 是从观察到的最小发病日 $t_{\\min}$ 到最大发病日 $t_{\\max}$ 的整数日闭区间集合。\n$$T = \\{t \\in \\mathbb{Z} \\mid t_{\\min} \\leq t \\leq t_{\\max}\\}$$\n此窗口的持续时间，即我们分析的时间点数量，为 $|T| = t_{\\max} - t_{\\min} + 1$。\n\n**第2步：构建流行曲线**\n我们初始化两个向量 $c_A$ 和 $c_B$，分别代表每个定义的每日病例数，其长度为 $|T|$，所有元素均设为0。然后，我们遍历病例清单中的每条记录 $(d, F, C, S, L, E)$。对于每条记录，我们评估与病例定义相对应的两个布尔条件。\n\n严格病例定义 $A$ 的条件是：\n$$ (F = 1) \\wedge (C = 1) \\wedge \\left((L = 1) \\vee (E = 1)\\right) $$\n宽松病例定义 $B$ 的条件是：\n$$ \\left((F = 1) \\vee (C = 1) \\vee (S = 1)\\right) \\wedge \\left((L = 1) \\vee (E = 1)\\right) $$\n其中 $\\wedge$ 表示逻辑与，$\\vee$ 表示逻辑或。\n\n如果一条记录满足定义 $A$ 的条件，我们就增加其发病日 $d$ 的计数。具体来说，我们在向量 $c_A$ 中增加索引为 $(d - t_{\\min})$ 的元素值。类似地，如果记录满足定义 $B$ 的条件，我们就在向量 $c_B$ 中增加相应元素的值。处理完所有记录后，向量 $c_A$ 和 $c_B$ 就代表了每日病例计数的离散时间序列，即流行曲线。\n\n**第3步：NRMSE计算**\n最后一步是计算 $\\mathrm{NRMSE}(A,B)$，它量化了两条曲线之间形状的差异，并按其平均水平进行归一化。\n\n首先，我们计算均方根误差（$\\mathrm{RMSE}$）：\n$$ \\mathrm{RMSE}(A,B) = \\sqrt{\\frac{1}{|T|} \\sum_{t \\in T} \\left(c_{A}(t) - c_{B}(t)\\right)^2} $$\n这是两条曲线每日计数之差的平方的均值的平方根。\n\n接下来，我们计算归一化因子 $\\mu$。这是两条曲线平均值的平均值。每条曲线的平均值由下式给出：\n$$ \\overline{c_{A}} = \\frac{1}{|T|}\\sum_{t \\in T} c_{A}(t) \\quad \\text{and} \\quad \\overline{c_{B}} = \\frac{1}{|T|}\\sum_{t \\in T} c_{B}(t) $$\n那么归一化因子为：\n$$ \\mu = \\frac{1}{2}\\left(\\overline{c_{A}} + \\overline{c_{B}}\\right) $$\n\n最后，$\\mathrm{NRMSE}$ 是 $\\mathrm{RMSE}$ 与 $\\mu$ 的比值。定义了一个特殊情况，即当 $\\mu=0$ 时，这种情况当且仅当两条曲线在所有 $t \\in T$ 上都为零时发生。\n$$\n\\mathrm{NRMSE}(A,B) =\n\\begin{cases}\n0,  \\text{if } \\mu = 0 \\\\\n\\dfrac{\\mathrm{RMSE}(A,B)}{\\mu},  \\text{if } \\mu \\neq 0\n\\end{cases}\n$$\n每个测试用例的结果是该值四舍五入到六位小数。\n\n**测试用例1的计算示例：**\n- **时间窗口**：发病日范围从 $d=0$ 到 $d=9$。因此，$t_{\\min}=0$, $t_{\\max}=9$, 且 $|T|=10$。\n- **曲线构建**：根据定义处理所有14条记录，得出以下每日计数：\n  - $c_A = [1, 1, 0, 1, 1, 1, 0, 0, 0, 0]$\n  - $c_B = [2, 2, 1, 2, 1, 1, 0, 1, 1, 0]$\n- **NRMSE计算**：\n  - A的总病例数：$\\sum c_A(t) = 5$。B的总病例数：$\\sum c_B(t) = 11$。\n  - $\\overline{c_{A}} = 5/10 = 0.5$。\n  - $\\overline{c_{B}} = 11/10 = 1.1$。\n  - $\\mu = \\frac{1}{2}(0.5 + 1.1) = 0.8$。\n  - 差异向量为 $c_A - c_B = [-1, -1, -1, -1, 0, 0, 0, -1, -1, 0]$。\n  - 平方差异向量为 $[1, 1, 1, 1, 0, 0, 0, 1, 1, 0]$。\n  - 平方差异之和为 $6$。\n  - $\\mathrm{RMSE} = \\sqrt{6/10} = \\sqrt{0.6} \\approx 0.77459667$。\n  - $\\mathrm{NRMSE} = \\frac{0.77459667}{0.8} \\approx 0.96824584$。\n- **结果**：四舍五入到六位小数，结果为 $0.968246$。\n\n此过程被系统地应用于所有提供的测试用例，以得出最终答案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases by calculating the Normalized\n    Root Mean Square Error (NRMSE) between epidemic curves generated from\n    two different case definitions.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        [\n            (0, 1, 1, 0, 1, 0), (0, 1, 0, 0, 1, 0), (1, 1, 1, 0, 0, 1),\n            (1, 1, 0, 1, 0, 1), (2, 1, 1, 0, 0, 0), (2, 0, 1, 1, 1, 0),\n            (3, 0, 0, 1, 0, 1), (3, 1, 1, 1, 1, 1), (4, 1, 1, 0, 1, 1),\n            (5, 1, 1, 0, 0, 1), (6, 0, 0, 0, 1, 1), (7, 1, 0, 0, 0, 1),\n            (8, 0, 1, 0, 1, 0), (9, 1, 1, 1, 0, 0)\n        ],\n        # Test Case 2\n        [\n            (0, 1, 1, 0, 1, 0), (0, 1, 1, 0, 0, 1), (1, 1, 1, 0, 1, 1),\n            (1, 0, 0, 1, 0, 0), (2, 1, 1, 0, 0, 0), (2, 1, 1, 1, 1, 1),\n            (3, 0, 0, 0, 1, 1), (3, 1, 1, 0, 0, 1)\n        ],\n        # Test Case 3\n        [\n            (5, 0, 1, 0, 1, 0)\n        ],\n        # Test Case 4\n        [\n            (2, 0, 0, 0, 1, 1), (3, 1, 0, 0, 0, 0), (4, 0, 1, 1, 0, 0)\n        ]\n    ]\n\n    results = []\n    for line_list in test_cases:\n        results.append(calculate_nrmse_for_case(line_list))\n\n    # Format the final output string exactly as specified.\n    formatted_results = ','.join(f\"{r:.6f}\" for r in results)\n    print(f\"[{formatted_results}]\")\n\ndef calculate_nrmse_for_case(line_list):\n    \"\"\"\n    Calculates the NRMSE for a single test case's line list.\n\n    Args:\n        line_list: A list of tuples, where each tuple is a record\n                   (d, F, C, S, L, E).\n\n    Returns:\n        The calculated NRMSE value as a float.\n    \"\"\"\n    if not line_list:\n        return 0.0\n\n    data = np.array(line_list, dtype=int)\n    onset_days = data[:, 0]\n    \n    t_min = np.min(onset_days)\n    t_max = np.max(onset_days)\n    num_days = t_max - t_min + 1\n\n    counts_a = np.zeros(num_days, dtype=float)\n    counts_b = np.zeros(num_days, dtype=float)\n\n    for record in data:\n        d, f, c, s, l, e = record\n        \n        # Epidemiologic criteria: Lab confirmation or known exposure\n        epi_criterion = (l == 1) or (e == 1)\n\n        # Apply Case Definition A (strict)\n        # Fever AND Cough AND (Lab OR Exposure)\n        is_case_a = (f == 1) and (c == 1) and epi_criterion\n        if is_case_a:\n            counts_a[d - t_min] += 1\n\n        # Apply Case Definition B (broad)\n        # (Fever OR Cough OR Shortness of Breath) AND (Lab OR Exposure)\n        clinical_criterion_b = (f == 1) or (c == 1) or (s == 1)\n        is_case_b = clinical_criterion_b and epi_criterion\n        if is_case_b:\n            counts_b[d - t_min] += 1\n\n    # Calculate normalization factor mu\n    mean_a = np.mean(counts_a)\n    mean_b = np.mean(counts_b)\n    mu = 0.5 * (mean_a + mean_b)\n\n    # Handle the case where both curves are zero\n    if mu == 0:\n        return 0.0\n\n    # Calculate RMSE\n    squared_diff = (counts_a - counts_b) ** 2\n    mse = np.mean(squared_diff)\n    rmse = np.sqrt(mse)\n\n    # Calculate NRMSE\n    nrmse = rmse / mu\n    return nrmse\n\nsolve()\n```", "id": "4507891"}, {"introduction": "流行曲线的监测往往贯穿疫情始终，但在长期监测过程中，病例定义本身可能会发生变化（例如，引入了更灵敏的检测技术）。这种变化会在流行曲线上造成人为的“断层”或不连续，可能被误读为疫情传播的真实波动。[@problem_id:4507858]\n\n这个高级练习将引导您处理这一棘手的现实问题。您将学习如何通过一个数学模型来估计病例定义变化所带来的影响，并对历史数据进行校正，从而使整条曲线具有可比性。这项技能对于准确评估疫情的长期趋势和公共卫生干预措施的真实效果至关重要。", "problem": "一次急性传染病暴发通过按症状发作时间统计的每周计数来进行监测。在第 $t=0$ 周结束时，监测项目更新了病例定义，扩大了病例的确认范围。设 $O_t$ 表示流行病学第 $t$ 周（$t$ 为整数）的观测病例数，负数 $t$ 表示变更前的周数，正数 $t$ 表示变更后的周数。假设在一个较短的局部时间窗口内，真实发病率 $I_t$ 服从指数动态模型 $I_t = I_0 \\exp(r t)$，在这些周内具有恒定的增长率 $r$，并且病例定义的更新导致病例确认率发生了一个时间不变的乘法变化，变化因子为 $k0$。形式上，对于 $t0$，$O_t = \\alpha I_t$；对于 $t0$，$O_t = k \\alpha I_t$，其中 $\\alpha0$ 是变更前的检出乘数；$I_0$、$r$、$\\alpha$ 和 $k$ 是未知常数。\n\n为避免过渡期的人为误差，第 $t=0$ 周被排除在外。观测到的周计数如下：\n- $O_{-3} = 81$，\n- $O_{-2} = 110$，\n- $O_{-1} = 148$，\n- $O_{+1} = 540$，\n- $O_{+2} = 729$。\n\n从这些定义和假设（发病率呈指数增长且增长率 $r$ 恒定，在 $t=0$ 后病例确认率发生一个乘性、时不变的偏移 $k$）出发，首先仅使用对称的周 $\\{t=-2,-1,+1,+2\\}$ 推导出一个 $k$ 的估计量，该估计量能消除冗余参数 $I_0$、$r$ 和 $\\alpha$。然后，使用你估计的 $k$ 作为一个乘性可比性因子，将变更前 $t=-3$ 的计数调整到变更后的尺度上，即计算 $k \\times O_{-3}$。\n\n以病例数表示的第 $t=-3$ 周的调整后计数是多少？将你最终的调整后计数四舍五入到四位有效数字。", "solution": "用户想要解决一个基于传染病暴发数学模型的问题。\n\n### 第1步：提取已知条件\n问题指明了以下模型和数据：\n- 第 `t` 周的真实发病率 `I_t` 由指数模型给出：$I_t = I_0 \\exp(r t)$，其中 `I_0` 和 `r` 是未知常数。\n- 观测病例数 `O_t` 通过一个检出乘数与真实发病率 `I_t` 相关联。\n- 对于病例定义变更前的周 ($t0$)：$O_t = \\alpha I_t$，其中 $\\alpha  0$ 是变更前的检出乘数。\n- 对于病例定义变更后的周 ($t0$)：$O_t = k \\alpha I_t$，其中 $k  0$ 是乘性确认因子。\n- 第 $t=0$ 周被排除在分析之外。\n- 未知常数是 $I_0$、$r$、$\\alpha$ 和 $k$。\n- 观测到的周计数为：$O_{-3} = 81$，$O_{-2} = 110$，$O_{-1} = 148$，$O_{+1} = 540$，$O_{+2} = 729$。\n\n### 第2步：使用提取的已知条件进行验证\n该问题具有科学依据，采用了流行病学中常见的标准指数增长模型。由于病例定义修改而导致病例确认发生变化的概念，是一个现实的监测现象。该问题在数学上是适定的；它提供了一个方程组和足够的数据来估计感兴趣的参数。语言客观而精确。所有术语都有明确的定义。数据点与基础模型一致；例如，每个时期内连续项的比率几乎是恒定的：$O_{-1}/O_{-2} = 148/110 \\approx 1.345$ 和 $O_{+2}/O_{+1} = 729/540 = 1.35$，这支持了增长率 $r$ 恒定的假设。这个问题不简单，需要系统的推导来分离出参数 $k$。该问题被认为是有效的。\n\n### 第3步：推导与求解\n\n第一个任务是仅使用来自对称周 $t \\in \\{-2, -1, +1, +2\\}$ 的数据，为确认因子 $k$ 推导一个估计量。必须消除冗余参数 $I_0$、$r$ 和 $\\alpha$。\n\n让我们用模型参数来表示这些周的观测计数。\n对于 $t  0$：\n$O_t = \\alpha I_t = \\alpha I_0 \\exp(rt)$\n对于 $t=-1$：$O_{-1} = \\alpha I_0 \\exp(-r)$\n对于 $t=-2$：$O_{-2} = \\alpha I_0 \\exp(-2r)$\n\n对于 $t  0$：\n$O_t = k \\alpha I_t = k \\alpha I_0 \\exp(rt)$\n对于 $t=+1$：$O_{+1} = k \\alpha I_0 \\exp(r)$\n对于 $t=+2$：$O_{+2} = k \\alpha I_0 \\exp(2r)$\n\n为了消除这些参数，我们可以构建这些观测值的比率。让我们构建在对称时间点 $t$ 和 $-t$（对于 $t0$）的观测值比率。\n考虑 $t=1$ 时的比率：\n$$ \\frac{O_{+1}}{O_{-1}} = \\frac{k \\alpha I_0 \\exp(r)}{\\alpha I_0 \\exp(-r)} = k \\exp(2r) $$\n现在考虑 $t=2$ 时的比率：\n$$ \\frac{O_{+2}}{O_{-2}} = \\frac{k \\alpha I_0 \\exp(2r)}{\\alpha I_0 \\exp(-2r)} = k \\exp(4r) $$\n这样就得到了一个包含两个未知数 $k$ 和 $r$（或者更方便地，是 $k$ 和 $\\exp(2r)$）的方程组：\n1. $\\frac{O_{+1}}{O_{-1}} = k \\exp(2r)$\n2. $\\frac{O_{+2}}{O_{-2}} = k \\exp(4r) = k (\\exp(2r))^2$\n\n我们可以解这个方程组。从方程（1）中，我们可以用 $k$ 来表示 $\\exp(2r)$：\n$$ \\exp(2r) = \\frac{1}{k} \\frac{O_{+1}}{O_{-1}} $$\n将这个表达式代入方程（2）：\n$$ \\frac{O_{+2}}{O_{-2}} = k \\left( \\frac{1}{k} \\frac{O_{+1}}{O_{-1}} \\right)^2 = k \\frac{1}{k^2} \\left( \\frac{O_{+1}}{O_{-1}} \\right)^2 = \\frac{1}{k} \\left( \\frac{O_{+1}}{O_{-1}} \\right)^2 $$\n现在我们可以解出 $k$：\n$$ k = \\frac{\\left( \\frac{O_{+1}}{O_{-1}} \\right)^2}{\\frac{O_{+2}}{O_{-2}}} = \\frac{O_{+1}^2}{O_{-1}^2} \\frac{O_{-2}}{O_{+2}} = \\frac{O_{+1}^2 O_{-2}}{O_{-1}^2 O_{+2}} $$\n这个 $k$ 的表达式就是所求的估计量，因为它只依赖于指定周的观测计数，并且消除了所有冗余参数。\n\n现在，我们将给定的数值代入这个估计量：\n$O_{-2} = 110$\n$O_{-1} = 148$\n$O_{+1} = 540$\n$O_{+2} = 729$\n\n$$ k = \\frac{(540)^2 \\times 110}{(148)^2 \\times 729} $$\n为了简化计算，我们可以注意到 $540 = 20 \\times 27$ 并且 $729 = 27^2$。\n$$ k = \\frac{(20 \\times 27)^2 \\times 110}{148^2 \\times 27^2} = \\frac{20^2 \\times 27^2 \\times 110}{148^2 \\times 27^2} = \\frac{400 \\times 110}{148^2} $$\n此外，$148 = 4 \\times 37$。\n$$ k = \\frac{400 \\times 110}{(4 \\times 37)^2} = \\frac{400 \\times 110}{16 \\times 37^2} = \\frac{25 \\times 110}{37^2} = \\frac{2750}{1369} $$\n计算 $k$ 的数值：\n$$ k \\approx 2.0087655... $$\n\n第二个任务是使用这个估计的 $k$ 值来调整变更前 $t=-3$ 时的计数。调整后的计数是变更前的计数乘以可比性因子 $k$，这实际上是将其投影到变更后的确认尺度上。\n调整后计数 = $k \\times O_{-3}$。\n已知 $O_{-3} = 81$。\n$$ \\text{Adjusted count} = \\frac{2750}{1369} \\times 81 = \\frac{222750}{1369} \\approx 162.7099... $$\n\n最后一步是将此结果四舍五入到四位有效数字。前四位有效数字是 $1$、$6$、$2$ 和 $7$。第五位数字是 $0$，所以向下舍入。\n调整后计数四舍五入到四位有效数字为 $162.7$。", "answer": "$$\\boxed{162.7}$$", "id": "4507858"}]}