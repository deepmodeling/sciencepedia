{"hands_on_practices": [{"introduction": "任何网络meta分析都建立在对单个治疗比较（即直接比较）进行证据综合的基础之上。本练习将带您回顾成对meta分析的核心计算过程，这是后续更复杂网络分析的基石。通过处理一个预防医学领域的假想案例，您将练习如何合并来自多个试验的数据，以获得一个统一的效应估计，并计算预测区间以理解不同研究间异质性的实际影响。[@problem_id:4551808]", "problem": "一个预防医学团队正计划进行一项网络荟萃分析 (NMA)，以比较在社区环境中减少二元不良结局的干预措施。作为 NMA 的一部分，他们首先在正态-正态分层框架下使用随机效应模型，综合比较干预措施 $A$ 和干预措施 $B$ 的直接证据。二元结局是 $30$ 天内发生可预防的不良事件。对于 $k=5$ 个以 $i \\in \\{1,2,3,4,5\\}$ 为索引的双臂试验，每个试验都给出了各组的事件数和随机分配的总人数：\n- 试验 $1$：$A$ 组 $n_{A,1} = 500$ 人中有 $a_{1} = 40$ 例事件，$B$ 组 $n_{B,1} = 500$ 人中有 $c_{1} = 60$ 例事件。\n- 试验 $2$：$A$ 组 $n_{A,2} = 400$ 人中有 $a_{2} = 28$ 例事件，$B$ 组 $n_{B,2} = 400$ 人中有 $c_{2} = 48$ 例事件。\n- 试验 $3$：$A$ 组 $n_{A,3} = 300$ 人中有 $a_{3} = 21$ 例事件，$B$ 组 $n_{B,3} = 300$ 人中有 $c_{3} = 36$ 例事件。\n- 试验 $4$：$A$ 组 $n_{A,4} = 600$ 人中有 $a_{4} = 66$ 例事件，$B$ 组 $n_{B,4} = 600$ 人中有 $c_{4} = 90$ 例事件。\n- 试验 $5$：$A$ 组 $n_{A,5} = 250$ 人中有 $a_{5} = 80$ 例事件，$B$ 组 $n_{B,5} = 250$ 人中有 $c_{5} = 70$ 例事件。\n\n从风险比 $RR_{i} = \\frac{a_{i}/n_{A,i}}{c_{i}/n_{B,i}}$ 的定义和二项式似然的大样本正态近似出发，构建研究特异性对数风险比 $y_{i} = \\ln(RR_{i})$ 及其研究内方差 $v_{i}$。使用随机效应正态-正态模型，并采用矩估计法估计研究间方差（异质性）$\\tau^{2}$，计算：\n1. 合并的对数风险比 $\\hat{\\mu}$ 及其转换为合并风险比 $\\exp(\\hat{\\mu})$。\n2. 通过转换对数尺度预测区间 $\\hat{\\mu} \\pm z \\sqrt{\\tau^{2} + V_{\\hat{\\mu}}}$ 得到的风险比的 $95\\%$ 预测区间，其中 $z$ 是标准正态分布的 $0.975$ 分位数，$V_{\\hat{\\mu}}$ 是随机效应加权下 $\\hat{\\mu}$ 的方差。\n\n然后，用预防医学的术语解释合并效应和预测区间。将最终答案表示为一个行向量，包含合并风险比以及 $95\\%$ 预测区间的下限和上限，每个值都以十进制形式表示并四舍五入至三位有效数字。最终的数值中不允许出现百分号。", "solution": "该问题要求对 $k=5$ 项试验进行随机效应荟萃分析，比较两种干预措施 $A$ 和 $B$ 对一个二元结局的影响。目标是计算合并风险比及其 $95\\%$ 的预测区间。\n\n分析过程分为几个步骤：\n1.  对于每项试验 $i \\in \\{1, 2, 3, 4, 5\\}$，计算研究特异性对数风险比 $y_i$ 及其研究内方差 $v_i$。\n2.  使用矩估计法（DerSimonian-Laird 方法）估计研究间方差（异质性）$\\tau^2$。\n3.  在随机效应模型下计算合并对数风险比 $\\hat{\\mu}$。\n4.  计算未来研究中真实效应的 $95\\%$ 预测区间。\n5.  将对数尺度的估计值转换回风险比尺度，并进行解释。\n\n首先，我们为 $k=5$ 项研究中的每一项计算对数风险比 $y_i = \\ln\\left(\\frac{a_i/n_{A,i}}{c_i/n_{B,i}}\\right)$ 及其方差 $v_i = \\frac{1}{a_i} - \\frac{1}{n_{A,i}} + \\frac{1}{c_i} - \\frac{1}{n_{B,i}}$。数据以干预措施 $A$ 的 $(a_i, n_{A,i})$ 和干预措施 $B$ 的 $(c_i, n_{B,i})$ 形式给出。\n\n-   试验 $1$：$a_1=40, n_{A,1}=500, c_1=60, n_{B,1}=500$。\n    $y_1 = \\ln\\left(\\frac{40/500}{60/500}\\right) = \\ln\\left(\\frac{40}{60}\\right) \\approx -0.40547$。\n    $v_1 = \\frac{1}{40} - \\frac{1}{500} + \\frac{1}{60} - \\frac{1}{500} \\approx 0.037667$。\n-   试验 $2$：$a_2=28, n_{A,2}=400, c_2=48, n_{B,2}=400$。\n    $y_2 = \\ln\\left(\\frac{28/400}{48/400}\\right) = \\ln\\left(\\frac{28}{48}\\right) \\approx -0.53900$。\n    $v_2 = \\frac{1}{28} - \\frac{1}{400} + \\frac{1}{48} - \\frac{1}{400} \\approx 0.051548$。\n-   试验 $3$：$a_3=21, n_{A,3}=300, c_3=36, n_{B,3}=300$。\n    $y_3 = \\ln\\left(\\frac{21/300}{36/300}\\right) = \\ln\\left(\\frac{21}{36}\\right) \\approx -0.53900$。\n    $v_3 = \\frac{1}{21} - \\frac{1}{300} + \\frac{1}{36} - \\frac{1}{300} \\approx 0.068730$。\n-   试验 $4$：$a_4=66, n_{A,4}=600, c_4=90, n_{B,4}=600$。\n    $y_4 = \\ln\\left(\\frac{66/600}{90/600}\\right) = \\ln\\left(\\frac{66}{90}\\right) \\approx -0.31015$。\n    $v_4 = \\frac{1}{66} - \\frac{1}{600} + \\frac{1}{90} - \\frac{1}{600} \\approx 0.022929$。\n-   试验 $5$：$a_5=80, n_{A,5}=250, c_5=70, n_{B,5}=250$。\n    $y_5 = \\ln\\left(\\frac{80/250}{70/250}\\right) = \\ln\\left(\\frac{80}{70}\\right) \\approx 0.13353$。\n    $v_5 = \\frac{1}{80} - \\frac{1}{250} + \\frac{1}{70} - \\frac{1}{250} \\approx 0.018786$。\n\n接下来，我们估计研究间方差 $\\hat{\\tau}^2$。这需要计算 Cochran's $Q$ 统计量。我们首先计算固定效应权重 $w_i = 1/v_i$ 和固定效应合并估计值 $\\hat{\\mu}_{FE}$。\n权重为：$w_1 \\approx 26.549$，$w_2 \\approx 19.400$，$w_3 \\approx 14.549$，$w_4 \\approx 43.613$，$w_5 \\approx 53.232$。\n权重之和为 $\\sum w_i \\approx 157.342$。\n加权效应之和为 $\\sum w_i y_i \\approx 26.549(-0.40547) + 19.400(-0.53900) + 14.549(-0.53900) + 43.613(-0.31015) + 53.232(0.13353) \\approx -35.481$。\n固定效应估计值为 $\\hat{\\mu}_{FE} = \\frac{\\sum w_i y_i}{\\sum w_i} \\approx \\frac{-35.481}{157.342} \\approx -0.22550$。\nCochran's $Q$ 统计量为 $Q = \\sum w_i(y_i - \\hat{\\mu}_{FE})^2$。\n$Q \\approx 26.549(-0.40547 - (-0.22550))^2 + \\dots + 53.232(0.13353 - (-0.22550))^2 \\approx 11.368$。\n矩估计法的常数 $C$ 为 $C = \\sum w_i - \\frac{\\sum w_i^2}{\\sum w_i}$。\n$\\sum w_i^2 \\approx 26.549^2 + 19.400^2 + 14.549^2 + 43.613^2 + 53.232^2 \\approx 6028.57$。\n$C \\approx 157.342 - \\frac{6028.57}{157.342} \\approx 119.030$。\n异质性估计值为 $\\hat{\\tau}^2 = \\frac{Q-(k-1)}{C} = \\frac{11.368 - (5-1)}{119.030} = \\frac{7.368}{119.030} \\approx 0.06190$。由于 $Q > k-1$，存在异质性的证据。\n\n现在我们计算随机效应合并对数风险比 $\\hat{\\mu}$。随机效应权重为 $w_i^* = \\frac{1}{v_i + \\hat{\\tau}^2}$。\n$w_1^* = \\frac{1}{0.037667+0.06190} \\approx 10.043$。\n$w_2^* = \\frac{1}{0.051548+0.06190} \\approx 8.815$。\n$w_3^* = \\frac{1}{0.068730+0.06190} \\approx 7.655$。\n$w_4^* = \\frac{1}{0.022929+0.06190} \\approx 11.788$。\n$w_5^* = \\frac{1}{0.018786+0.06190} \\approx 12.394$。\n随机效应权重之和为 $\\sum w_i^* \\approx 50.695$。\n加权效应之和为 $\\sum w_i^* y_i \\approx 10.043(-0.40547) + \\dots + 12.394(0.13353) \\approx -14.949$。\n随机效应合并估计值为 $\\hat{\\mu} = \\frac{\\sum w_i^* y_i}{\\sum w_i^*} \\approx \\frac{-14.949}{50.695} \\approx -0.29487$。\n合并风险比为 $\\exp(\\hat{\\mu}) \\approx \\exp(-0.29487) \\approx 0.7446$。\n\n最后，我们计算风险比的 $95\\%$ 预测区间 (PI)。对数尺度的 PI 为 $\\hat{\\mu} \\pm z \\sqrt{\\hat{\\tau}^2 + V_{\\hat{\\mu}}}$，其中 $z$ 是标准正态分布的 $0.975$ 分位数 ($z \\approx 1.96$)，$V_{\\hat{\\mu}}$ 是 $\\hat{\\mu}$ 的方差。\n$V_{\\hat{\\mu}} = \\frac{1}{\\sum w_i^*} \\approx \\frac{1}{50.695} \\approx 0.019726$。\n预测的标准误为 $\\sqrt{\\hat{\\tau}^2 + V_{\\hat{\\mu}}} \\approx \\sqrt{0.06190 + 0.019726} = \\sqrt{0.081626} \\approx 0.28570$。\n对数尺度 PI 的误差范围是 $1.96 \\times 0.28570 \\approx 0.55997$。\n对数尺度的 $95\\%$ PI 为 $\\hat{\\mu} \\pm 0.55997 \\approx -0.29487 \\pm 0.55997$。\n下限：$-0.29487 - 0.55997 = -0.85484$。\n上限：$-0.29487 + 0.55997 = 0.26510$。\n通过取指数转换回风险比尺度：\nPI 下限：$\\exp(-0.85484) \\approx 0.4253$。\nPI 上限：$\\exp(0.26510) \\approx 1.3036$。\n\n解释：合并风险比约为 $0.745$。这表明，与干预措施 $B$ 相比，干预措施 $A$ 平均可将不良事件的风险降低 $25.5\\%$。这个平均效应的 $95\\%$ 置信区间约为 $[0.57, 0.98]$，不包含 $1$，表明平均效应具有统计学意义。然而，$95\\%$ 的预测区间 $[0.425, 1.304]$ 要宽得多。该区间代表了新研究中真实风险比预期所在的范围。由于它包含了无效值 $1.0$，这意味着尽管平均效应是有利的，但未来的试验仍有可能显示干预措施 $A$ 相对于 $B$ 没有差异，甚至可能产生有害效果。这反映了纳入研究之间存在显著的异质性，其效应范围从保护性（试验 $1-4$）到潜在有害性（试验 $5$）。从预防医学的角度来看，宽的预测区间表明干预措施 $A$ 的有效性在不同情境下并不一致，因此在广泛实施前需要谨慎，并表明需要进一步研究以了解这种异质性的来源。\n\n最终答案要求提供合并风险比、PI 下限和 PI 上限，并四舍五入至三位有效数字。\n合并 RR：$0.7446 \\to 0.745$。\nPI 下限：$0.4253 \\to 0.425$。\nPI 上限：$1.3036 \\to 1.30$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.745 & 0.425 & 1.30\n\\end{pmatrix}\n}\n$$", "id": "4551808"}, {"introduction": "网络meta分析最核心的创新在于它能够比较从未在同一试验中直接对比过的干预措施。这个强大的功能是基于“间接比较”的逻辑推断。本练习将引导您从第一性原理出发，推导间接比较效应量及其方差的基本公式，从而揭示构成整个证据网络推断的数学基础和一致性假设。[@problem_id:4977502]", "problem": "考虑一组随机对照试验 (RCT)，它们构成一个最小连通的三臂治疗网络，其中治疗 $A$ 与治疗 $B$ 进行了比较，治疗 $B$ 与治疗 $C$ 进行了比较，但治疗 $A$ 与治疗 $C$ 之间没有直接比较。假设效应量是在一个可加尺度上（例如，均数差或比率尺度效应的对数，使得在该转换尺度上可加性成立）。设每种治疗 $t \\in \\{A,B,C\\}$ 都与一个研究水平的参数 $\\theta_{t}$ 相关联，该参数表示其在可加尺度上的期望结局。定义治疗 $X$ 相对于治疗 $Y$ 的相对效应为 $d_{XY} = \\theta_{X} - \\theta_{Y}$。\n\n假设从 $A$ 对 $B$ 的比较和 $B$ 对 $C$ 的比较中，可以获得成对meta分析的合并估计值分别为 $\\hat{d}_{AB}$ 和 $\\hat{d}_{BC}$，在标准的meta分析正则性条件下，它们分别是 $d_{AB}$ 和 $d_{BC}$ 的无偏估计。设它们的抽样方差为 $v_{AB} = \\operatorname{Var}(\\hat{d}_{AB})$ 和 $v_{BC} = \\operatorname{Var}(\\hat{d}_{BC})$。假设 $A$ 对 $B$ 的证据和 $B$ 对 $C$ 的证据来自不相交的试验集，并且没有同时连接 $A$、$B$ 和 $C$ 的多臂试验，因此 $\\hat{d}_{AB}$ 和 $\\hat{d}_{BC}$ 是独立的。\n\n从上述核心定义和网状meta分析 (NMA) 的一致性假设（即特定于治疗的参数 $\\theta_{t}$ 在整个网络中是一致的）出发，推导 $A$ 对 $C$ 相对效应的间接估计量 $\\hat{d}_{AC}$，并在所述的独立性条件下确定其抽样方差。将你的最终答案表示为以 $\\hat{d}_{AB}$、$\\hat{d}_{BC}$、$v_{AB}$ 和 $v_{BC}$ 表示的闭式解析表达式。无需进行数值计算，也无需四舍五入。将你的最终答案以包含间接估计量及其方差的双元素行矩阵形式提供。", "solution": "该问题提出了网状meta分析领域一个有效且适定的问题。它提供了一套完整且一致的给定条件，遵循既定的科学原则，并以精确、客观的语言表述。任务是推导间接比较的估计量及其对应的方差，这是该统计领域的一个基本步骤。\n\n该问题描述了一个涉及治疗 $A$、$B$ 和 $C$ 的三臂治疗网络。现有证据包括 $A$ 与 $B$ 之间的直接比较，以及 $B$ 与 $C$ 之间的直接比较。没有比较 $A$ 和 $C$ 的直接证据。目标是利用现有信息估计 $A$ 相对于 $C$ 的相对效应，记为 $d_{AC}$。\n\n设 $\\theta_A$、$\\theta_B$ 和 $\\theta_C$ 分别表示治疗 $A$、$B$ 和 $C$ 在可加尺度上的真实平均效应。任意两种治疗 $X$ 和 $Y$ 之间的相对治疗效应定义为 $d_{XY} = \\theta_X - \\theta_Y$。\n\n能够在一个网络中综合证据的核心原则是一致性假设。该假设假定所有治疗效应都是一致的，并且可以映射到一个由特定于治疗的参数 $\\theta_t$ 定义的单一潜在框架中。对于我们的三臂治疗链 $A-B-C$，一致性方程将直接效应和间接效应关联如下：\n$$\nd_{AC} = d_{AB} + d_{BC}\n$$\n这可以通过将相对效应的定义（以绝对效应表示）代入来证明：\n$$\nd_{AB} + d_{BC} = (\\theta_A - \\theta_B) + (\\theta_B - \\theta_C) = \\theta_A - \\theta_C = d_{AC}\n$$\n一致性方程为间接估计 $d_{AC}$ 提供了理论基础。\n\n我们得到了两个用于直接比较的独立、无偏的估计量：\n1. $d_{AB}$ 的估计量 $\\hat{d}_{AB}$，其方差为 $v_{AB} = \\operatorname{Var}(\\hat{d}_{AB})$。\n2. $d_{BC}$ 的估计量 $\\hat{d}_{BC}$，其方差为 $v_{BC} = \\operatorname{Var}(\\hat{d}_{BC})$。\n\n无偏性意味着 $E[\\hat{d}_{AB}] = d_{AB}$ 和 $E[\\hat{d}_{BC}] = d_{BC}$。独立性意味着它们的协方差为零：$\\operatorname{Cov}(\\hat{d}_{AB}, \\hat{d}_{BC}) = 0$。\n\n为了推导 $d_{AC}$ 的间接估计量（我们记为 $\\hat{d}_{AC}$），我们使用基于一致性方程的“代入”原则。我们将真实效应的估计量代入该方程：\n$$\n\\hat{d}_{AC} = \\hat{d}_{AB} + \\hat{d}_{BC}\n$$\n该表达式提供了 $A$ 对 $C$ 间接比较的点估计。我们可以验证该估计量对于 $d_{AC}$ 是无偏的。利用期望算子的线性性质：\n$$\nE[\\hat{d}_{AC}] = E[\\hat{d}_{AB} + \\hat{d}_{BC}] = E[\\hat{d}_{AB}] + E[\\hat{d}_{BC}]\n$$\n代入已知的期望值：\n$$\nE[\\hat{d}_{AC}] = d_{AB} + d_{BC}\n$$\n根据一致性方程，$d_{AB} + d_{BC} = d_{AC}$，所以我们有：\n$$\nE[\\hat{d}_{AC}] = d_{AC}\n$$\n因此，间接估计量 $\\hat{d}_{AC}$ 是真实相对效应 $d_{AC}$ 的一个无偏估计量。\n\n接下来，我们推导这个间接估计量的抽样方差 $\\operatorname{Var}(\\hat{d}_{AC})$。两个随机变量之和的方差由以下公式给出：\n$$\n\\operatorname{Var}(X+Y) = \\operatorname{Var}(X) + \\operatorname{Var}(Y) + 2\\operatorname{Cov}(X,Y)\n$$\n将此公式应用于我们的估计量 $\\hat{d}_{AC}$：\n$$\n\\operatorname{Var}(\\hat{d}_{AC}) = \\operatorname{Var}(\\hat{d}_{AB} + \\hat{d}_{BC}) = \\operatorname{Var}(\\hat{d}_{AB}) + \\operatorname{Var}(\\hat{d}_{BC}) + 2\\operatorname{Cov}(\\hat{d}_{AB}, \\hat{d}_{BC})\n$$\n问题陈述指明，$A$ 对 $B$ 和 $B$ 对 $C$ 的证据来自不相交的试验集，这确保了估计量 $\\hat{d}_{AB}$ 和 $\\hat{d}_{BC}$ 在统计上是独立的。对于独立的随机变量，协方差为零。\n$$\n\\operatorname{Cov}(\\hat{d}_{AB}, \\hat{d}_{BC}) = 0\n$$\n将此代入方差方程，可将其简化为：\n$$\n\\operatorname{Var}(\\hat{d}_{AC}) = \\operatorname{Var}(\\hat{d}_{AB}) + \\operatorname{Var}(\\hat{d}_{BC})\n$$\n最后，使用所提供的方差符号 $v_{AB} = \\operatorname{Var}(\\hat{d}_{AB})$ 和 $v_{BC} = \\operatorname{Var}(\\hat{d}_{BC})$，我们得到间接估计量方差的最终表达式：\n$$\n\\operatorname{Var}(\\hat{d}_{AC}) = v_{AB} + v_{BC}\n$$\n这表明，对于一个间接比较，在独立性假设下，其点估计是各组成部分直接估计的总和，其方差是它们方差的总和。\n\n因此，所要求的两个量是间接估计量 $\\hat{d}_{AC} = \\hat{d}_{AB} + \\hat{d}_{BC}$ 及其抽样方差 $\\operatorname{Var}(\\hat{d}_{AC}) = v_{AB} + v_{BC}$。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\hat{d}_{AB} + \\hat{d}_{BC} & v_{AB} + v_{BC} \\end{pmatrix}}\n$$", "id": "4977502"}, {"introduction": "在结合了直接和间接证据之后，一个关键的质量控制步骤是检验两者是否一致。如果直接证据和间接证据得出的结论存在显著差异，那么整个网络的结论就可能是不可靠的。本练习将通过一个编程任务，指导您实现“节点劈裂法”（node-splitting），这是一种强大的诊断技术，用于量化和检验网络中特定治疗比较的非一致性。[@problem_id:4551831]", "problem": "您正在处理一个预防医学领域的四臂治疗网络荟萃分析，治疗方案标记为 $A$、$B$、$C$ 和 $D$。随机对照试验报告了二元结局的对数风险比的研究水平估计值。假设采用固定效应模型，并对研究水平的估计值使用正态近似。一项使用节点分裂法 (node-splitting) 的网络荟萃分析 (NMA) 旨在评估 $A$ 对比 $B$ 的直接证据是否与通过网络其余部分（不包括 $A$ 对比 $B$ 的直接比较）获得的间接证据相一致。\n\n请使用以下基本原理：\n- 在方差已知的固定效应模型下，使用反方差权重法对各个研究的无偏正态估计值进行合并。\n- 当独立的正态估计值进行相减或组合时，所得结果的方差是各组成部分方差的总和。\n- 在正态近似下，对标准化差异进行双侧统计检验时使用标准正态分布。\n\n您必须按照以下方式为 $A$ 对比 $B$ 实施节点分裂，并严格遵守上述基本原理，不得引入未经检验的假设：\n- 使用反方差权重法合并所有比较 $A$ 与 $B$ 的直接证据，以获得 $A$ 对比 $B$ 的单个合并直接估计值及其标准误。\n- 同样地，合并 $A$ 对比 $C$、$B$ 对比 $C$、$A$ 对比 $D$ 以及 $B$ 对比 $D$ 的证据。\n- 通过排除直接的 $A$ 对比 $B$ 数据，并沿可用的独立路径组合证据，来构建 $A$ 对比 $B$ 的间接估计值：\n  - 对于任何共同比较者 $X \\in \\{C,D\\}$，如果同时存在 $A$ 对比 $X$ 和 $B$ 对比 $X$ 的合并估计值，则通过从合并的 $A$ 对比 $X$ 估计值中减去合并的 $B$ 对比 $X$ 估计值，形成一个通过 $X$ 的 $A$ 对比 $B$ 的间接估计值，并根据独立性假设计算其方差。\n  - 如果通过 $C$ 和通过 $D$ 的两条路径都可用，则使用反方差权重法将这些间接估计值组合起来，以产生 $A$ 对比 $B$ 的单个间接估计值及其标准误。\n  - 如果只有一条路径可用，则使用该单路径作为间接估计值。\n- 计算一个不一致性统计量，即合并的直接估计值与合并的间接估计值之差，以及在独立性假设下该差异的标准误、相应的标准化 $z$ 分数和使用标准正态分布计算的双侧 $p$ 值。使用显著性水平 $\\alpha = 0.05$ 来判断是否检测到不一致性（如果双侧 $p$ 值小于 $0.05$，则布尔值为 true）。\n\n所有效应量均为无量纲的对数风险比，应以实数形式报告。不要使用百分号。不涉及角度。最终程序必须生成单行输出，其中包含一个以方括号括起来的逗号分隔列表形式的结果。\n\n测试套件：\n对于下方的每个测试用例，数据以各试验中治疗方案间比较的研究水平估计值列表的形式给出。每个元素是一对 $(y_i, s_i)$，其中 $y_i$ 是该研究中“第一种治疗方案对比第二种治疗方案”的对数风险比，$s_i$ 是其标准误。例如，$AB$ 下的一个条目 $(y_i, s_i)$ 对应于 $A$ 对比 $B$。\n\n请实施程序以处理以下四个测试用例。每个测试用例提供了 $AB$、$AC$、$BC$、$AD$、$BD$ 和 $CD$ 比较的数据；如果某个比较缺失，则视为不可用。\n\n- 测试用例 1（网络经构造确保一致）：\n  - $AB$: $[(-0.20, 0.10),\\, (-0.22, 0.10),\\, (-0.18, 0.10)]$\n  - $AC$: $[(-0.10, 0.12),\\, (-0.12, 0.12)]$\n  - $BC$: $[(0.10, 0.12),\\, (0.08, 0.12)]$\n  - $AD$: $[(-0.30, 0.14)]$\n  - $BD$: $[(-0.10, 0.14)]$\n  - $CD$: $[(-0.20, 0.15)]$\n- 测试用例 2（直接证据和间接证据之间存在故意的不一致）：\n  - $AB$: $[(-0.05, 0.07),\\, (-0.04, 0.07)]$\n  - $AC$: $[(-0.30, 0.06),\\, (-0.28, 0.06)]$\n  - $BC$: $[(0.00, 0.06),\\, (0.02, 0.06)]$\n  - $AD$: $[(-0.32, 0.08)]$\n  - $BD$: $[(-0.02, 0.08)]$\n  - $CD$: $[(-0.25, 0.09)]$\n- 测试用例 3（仅有一条通过 $C$ 的间接路径可用）：\n  - $AB$: $[(-0.15, 0.10)]$\n  - $AC$: $[(-0.05, 0.15),\\, (-0.06, 0.15)]$\n  - $BC$: $[(0.10, 0.15),\\, (0.09, 0.15)]$\n  - $AD$: $[\\ ]$ (缺失)\n  - $BD$: $[\\ ]$ (缺失)\n  - $CD$: $[(-0.14, 0.16)]$\n- 测试用例 4（直接证据方差大，间接证据精确）：\n  - $AB$: $[(-0.20, 0.30),\\, (-0.22, 0.30)]$\n  - $AC$: $[(-0.15, 0.10)]$\n  - $BC$: $[(-0.05, 0.10)]$\n  - $AD$: $[(-0.25, 0.15)]$\n  - $BD$: $[(-0.10, 0.15)]$\n  - $CD$: $[(0.05, 0.12)]$\n\n您的程序必须为每个测试用例输出一个按以下顺序排列的列表：\n$[\\text{direct\\_estimate},\\, \\text{indirect\\_estimate},\\, \\text{difference},\\, \\text{se\\_difference},\\, \\text{z},\\, \\text{p\\_value},\\, \\text{inconsistency\\_detected}]$,\n其中所有数值均为浮点数，布尔值为 true 或 false。在内部可根据需要对数值进行合理四舍五入，但输出应为程序计算出的原始数值。最后，将四个测试用例的列表聚合为单个列表，并以 $[[\\cdot], [\\cdot], [\\cdot], [\\cdot]]$ 的格式精确打印一行，不含任何其他文本。", "solution": "该问题要求实施一次节点分裂分析，以评估一个四臂治疗网络（$A, B, C, D$）中特定比较（$A$ 对比 $B$）的直接证据与间接证据之间的一致性。该分析基于使用反方差权重法的固定效应模型，这是 Meta 分析中的一种标准技术。整个过程将依据所提供的基本原理进行推导。\n\n核心计算工具是用于合并多个研究估计值的反方差权重法。给定一组 $k$ 个独立研究，每个研究提供一个估计值 $y_i$ 及其对应的标准误 $s_i$（$i=1, \\dots, k$），则每个估计值的方差为 $v_i = s_i^2$。每个研究的权重是其方差的倒数，$w_i = 1/v_i$。合并后的估计值 $\\hat{y}$ 是各个估计值的加权平均：\n$$\n\\hat{y} = \\frac{\\sum_{i=1}^{k} w_i y_i}{\\sum_{i=1}^{k} w_i}\n$$\n这个合并估计值的方差 $V$ 是权重总和的倒数：\n$$\nV = \\frac{1}{\\sum_{i=1}^{k} w_i}\n$$\n合并估计值的标准误是其方差的平方根，$S = \\sqrt{V}$。如果某个比较没有研究，则其证据被视为不可用。\n\n节点分裂程序主要分三个阶段执行：\n\n**1. 直接效应的估计**\n\n$A$ 对比 $B$ 的直接证据来自所有直接比较这两种治疗方案的试验。这些试验的估计值（以 $AB$ 比较的 $(y_i, s_i)$ 对形式提供）使用上述的反方差权重法进行合并。由此得到合并的直接估计值，我们记为 $y_{\\text{direct}}$，及其对应的标准误 $s_{\\text{direct}}$。\n\n**2. 间接效应的估计**\n\n$A$ 对比 $B$ 的间接证据是通过网络中不涉及直接 $AB$ 比较的路径合成的。可用的中间治疗方案是 $C$ 和 $D$。\n\n首先，对于每个相关的比较（$AC$, $BC$, $AD$, $BD$），我们使用同样的反方差权重法合并可用的研究水平数据，为每个比较获得一个单一的汇总估计值及其标准误（例如，$y_{AC}$ 和 $s_{AC}$，$y_{BC}$ 和 $s_{BC}$ 等）。\n\n接下来，我们通过共同比较者构建 $A$ 对比 $B$ 的间接估计值。\n- **通过 C 的路径：** 如果 $A$ 对比 $C$ ($y_{AC}, s_{AC}$) 和 $B$ 对比 $C$ ($y_{BC}, s_{BC}$) 的汇总估计值都存在，则可以形成一个 $A$ 对比 $B$ 的间接估计值。通过 $C$ 获得的 $A$ 对比 $B$ 的对数风险比是 $y_{\\text{indirect}, C} = y_{AC} - y_{BC}$。根据独立估计值之差的方差等于它们各自方差之和的原理，这个间接估计值的方差是 $v_{\\text{indirect}, C} = s_{AC}^2 + s_{BC}^2$。其标准误为 $s_{\\text{indirect}, C} = \\sqrt{v_{\\text{indirect}, C}}$。\n\n- **通过 D 的路径：** 类似地，如果 $A$ 对比 $D$ ($y_{AD}, s_{AD}$) 和 $B$ 对比 $D$ ($y_{BD}, s_{BD}$) 的汇总估计值都可用，则通过 $D$ 的间接估计值是 $y_{\\text{indirect}, D} = y_{AD} - y_{BD}$，其标准误是 $s_{\\text{indirect}, D} = \\sqrt{s_{AD}^2 + s_{BD}^2}$。\n\n最后，将这些独立的间接估计值进行组合。\n- 如果两条路径（通过 $C$ 和通过 $D$）都可用，则这两个间接估计值 $(y_{\\text{indirect}, C}, s_{\\text{indirect}, C})$ 和 $(y_{\\text{indirect}, D}, s_{\\text{indirect}, D})$ 本身也使用反方差权重法进行合并。这提供了最终的汇总间接估计值 $y_{\\text{indirect}}$ 及其标准误 $s_{\\text{indirect}}$。\n- 如果只有一条路径可用（例如，仅通过 $C$），则该单路径的估计值即成为最终的间接估计值：$y_{\\text{indirect}} = y_{\\text{indirect}, C}$ 且 $s_{\\text{indirect}} = s_{\\text{indirect}, C}$。\n\n**3. 不一致性统计量的计算**\n\n最后一步是量化直接估计值和间接估计值之间的差异。不一致性被建模为两个估计值之差 $\\omega$：\n$$\n\\omega = y_{\\text{direct}} - y_{\\text{indirect}}\n$$\n假设直接和间接估计值是独立的，这个差值的方差是它们各自方差的总和。因此，差值的标准误 $s_{\\omega}$ 为：\n$$\ns_{\\omega} = \\sqrt{s_{\\text{direct}}^2 + s_{\\text{indirect}}^2}\n$$\n为了检验真实差值为零的原假设（$\\omega_0 = 0$），我们计算一个标准化的检验统计量，即 $z$ 分数：\n$$\nz = \\frac{\\omega}{s_{\\omega}}\n$$\n在原假设下，这个 $z$ 分数服从标准正态分布。双侧 $p$ 值计算为观测到至少与 $|z|$ 一样极端的值的概率：\n$$\np = 2 \\times (1 - \\Phi(|z|))\n$$\n其中 $\\Phi$ 是标准正态分布的累积分布函数（CDF）。\n\n最后，我们通过将 $p$ 值与预定义的显著性水平 $\\alpha = 0.05$ 进行比较，来确定是否存在统计上显著的不一致性。如果 $p  0.05$，则检测到不一致性。结果是一个布尔值。\n\n将此计算序列应用于每个测试用例，以生成所需的输出：$[y_{\\text{direct}}, y_{\\text{indirect}}, \\omega, s_{\\omega}, z, p, \\text{inconsistency\\_detected}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the network meta-analysis node-splitting problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"AB\": [(-0.20, 0.10), (-0.22, 0.10), (-0.18, 0.10)],\n            \"AC\": [(-0.10, 0.12), (-0.12, 0.12)],\n            \"BC\": [(0.10, 0.12), (0.08, 0.12)],\n            \"AD\": [(-0.30, 0.14)],\n            \"BD\": [(-0.10, 0.14)],\n            \"CD\": [(-0.20, 0.15)],\n        },\n        {\n            \"AB\": [(-0.05, 0.07), (-0.04, 0.07)],\n            \"AC\": [(-0.30, 0.06), (-0.28, 0.06)],\n            \"BC\": [(0.00, 0.06), (0.02, 0.06)],\n            \"AD\": [(-0.32, 0.08)],\n            \"BD\": [(-0.02, 0.08)],\n            \"CD\": [(-0.25, 0.09)],\n        },\n        {\n            \"AB\": [(-0.15, 0.10)],\n            \"AC\": [(-0.05, 0.15), (-0.06, 0.15)],\n            \"BC\": [(0.10, 0.15), (0.09, 0.15)],\n            \"AD\": [],\n            \"BD\": [],\n            \"CD\": [(-0.14, 0.16)],\n        },\n        {\n            \"AB\": [(-0.20, 0.30), (-0.22, 0.30)],\n            \"AC\": [(-0.15, 0.10)],\n            \"BC\": [(-0.05, 0.10)],\n            \"AD\": [(-0.25, 0.15)],\n            \"BD\": [(-0.10, 0.15)],\n            \"CD\": [(0.05, 0.12)],\n        },\n    ]\n\n    def pool_estimates(studies):\n        \"\"\"\n        Pools estimates from multiple studies using inverse-variance weighting.\n        \n        Args:\n            studies (list): A list of tuples, where each tuple is (estimate, std_error).\n            \n        Returns:\n            A tuple (pooled_estimate, pooled_std_error). Returns (np.nan, np.nan) \n            if the list of studies is empty.\n        \"\"\"\n        if not studies:\n            return np.nan, np.nan\n\n        estimates = np.array([s[0] for s in studies])\n        std_errors = np.array([s[1] for s in studies])\n        \n        variances = std_errors**2\n        weights = 1.0 / variances\n        \n        sum_weights = np.sum(weights)\n        if sum_weights == 0:\n            return np.nan, np.nan # Should not happen with positive SEs\n            \n        pooled_estimate = np.sum(weights * estimates) / sum_weights\n        pooled_variance = 1.0 / sum_weights\n        pooled_std_error = np.sqrt(pooled_variance)\n        \n        return pooled_estimate, pooled_std_error\n\n    all_results = []\n    alpha = 0.05\n\n    for case_data in test_cases:\n        # Step 1: Pool direct evidence for A vs B\n        y_direct, s_direct = pool_estimates(case_data.get(\"AB\", []))\n        \n        # Step 2: Pool evidence for other comparisons needed for indirect paths\n        y_ac, s_ac = pool_estimates(case_data.get(\"AC\", []))\n        y_bc, s_bc = pool_estimates(case_data.get(\"BC\", []))\n        y_ad, s_ad = pool_estimates(case_data.get(\"AD\", []))\n        y_bd, s_bd = pool_estimates(case_data.get(\"BD\", []))\n        \n        # Step 3: Construct indirect estimate(s)\n        indirect_paths = []\n        \n        # Path via C\n        if not np.isnan(y_ac) and not np.isnan(y_bc):\n            y_indirect_c = y_ac - y_bc\n            v_indirect_c = s_ac**2 + s_bc**2\n            s_indirect_c = np.sqrt(v_indirect_c)\n            indirect_paths.append((y_indirect_c, s_indirect_c))\n        \n        # Path via D\n        if not np.isnan(y_ad) and not np.isnan(y_bd):\n            y_indirect_d = y_ad - y_bd\n            v_indirect_d = s_ad**2 + s_bd**2\n            s_indirect_d = np.sqrt(v_indirect_d)\n            indirect_paths.append((y_indirect_d, s_indirect_d))\n        \n        # Step 4: Combine indirect paths\n        if len(indirect_paths) == 0:\n            # Should not happen with the given test cases, but handle defensively\n            y_indirect, s_indirect = np.nan, np.nan\n        elif len(indirect_paths) == 1:\n            y_indirect, s_indirect = indirect_paths[0]\n        else: # More than one path, pool them\n            y_indirect, s_indirect = pool_estimates(indirect_paths)\n            \n        # Step 5: Compute inconsistency statistics\n        difference = y_direct - y_indirect\n        se_difference = np.sqrt(s_direct**2 + s_indirect**2)\n        \n        if se_difference == 0:\n            z_score = np.inf if difference !=0 else 0.0\n        else:\n            z_score = difference / se_difference\n\n        # Two-sided p-value from standard normal distribution\n        p_value = 2 * norm.sf(np.abs(z_score))\n        \n        inconsistency_detected = p_value  alpha\n        \n        result_list = [\n            y_direct, \n            y_indirect, \n            difference, \n            se_difference, \n            z_score, \n            p_value, \n            inconsistency_detected\n        ]\n        all_results.append(result_list)\n        \n    # Format the final output string as specified\n    output_parts = []\n    for res_list in all_results:\n        formatted_items = []\n        for item in res_list:\n            if isinstance(item, bool):\n                formatted_items.append(str(item).lower())\n            else:\n                formatted_items.append(str(item))\n        output_parts.append(f\"[{','.join(formatted_items)}]\")\n\n    final_string = f\"[{','.join(output_parts)}]\"\n    print(final_string)\n\nsolve()\n```", "id": "4551831"}]}