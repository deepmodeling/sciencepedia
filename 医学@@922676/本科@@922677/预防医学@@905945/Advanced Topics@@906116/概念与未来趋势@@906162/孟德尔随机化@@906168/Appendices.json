{"hands_on_practices": [{"introduction": "模拟是理解统计方法行为的强大工具。本练习将通过代码实现一个孟德尔随机化（MR）的数据生成过程，帮助你建立直观认识：为何在核心假设成立时，MR能得出无偏的因果效应估计；而当假设被违背时（如存在弱工具变量或水平多效性），偏倚又是如何产生的。这将为你后续理解和应用MR打下坚实的基础。[@problem_id:2404055]", "problem": "实现一个完全确定性的模拟，以在核心工具变量假设下评估孟德尔随机化（MR）因果效应估计量的无偏性。考虑一个包含单个双等位基因工具变量、一个未测量的混杂因素、一个连续暴露和一个连续结局的数据生成过程。令 $G$ 表示基因工具变量，$U$ 表示未测量的混杂因素，$X$ 表示暴露，$Y$ 表示结局。假设存在以下带有加性噪声的线性结构方程：\n$$\nX \\;=\\; \\pi \\, G \\;+\\; \\gamma \\, U \\;+\\; \\varepsilon_X,\n$$\n$$\nY \\;=\\; \\beta \\, X \\;+\\; \\delta \\, U \\;+\\; \\alpha \\, G \\;+\\; \\varepsilon_Y,\n$$\n其中 $G \\sim \\text{Binomial}(2,p)$，$U \\sim \\mathcal{N}(0,1)$，$\\varepsilon_X \\sim \\mathcal{N}(0,\\sigma_X^2)$，以及 $\\varepsilon_Y \\sim \\mathcal{N}(0,\\sigma_Y^2)$。除了由结构方程所引致的相关性外，所有随机变量都是相互独立的。在给定的模拟情景中，参数 $\\pi$、$\\gamma$、$\\delta$、$\\alpha$、$\\beta$、$p$、$\\sigma_X$ 和 $\\sigma_Y$ 是固定常数。\n\n孟德尔随机化假设如下：\n- 相关性：$G$ 与 $X$ 相关，这对应于 $\\pi \\neq 0$。\n- 独立性：$G$ 独立于 $U$ 以及 $X$ 和 $Y$ 的所有其他未测量原因。\n- 排他性限制：$G$ 对 $Y$ 没有除通过 $X$ 之外的直接因果效应，这对应于 $\\alpha = 0$。\n\n将单个工具变量的工具变量估计量 $\\hat{\\beta}_{\\mathrm{IV}}$ 定义为对于给定大小为 $N$ 的样本，满足以下经验矩条件的唯一标量 $\\hat{\\beta}$：\n$$\n\\frac{1}{N} \\sum_{i=1}^{N} G_i \\,\\bigl(Y_i - \\hat{\\beta}\\, X_i \\bigr) \\;=\\; 0,\n$$\n将朴素普通最小二乘（OLS）估计量 $\\hat{\\beta}_{\\mathrm{OLS}}$ 定义为最小化以下经验均方差的标量 $\\hat{\\beta}$：\n$$\n\\frac{1}{N} \\sum_{i=1}^{N} \\bigl(Y_i - \\hat{\\beta}\\, X_i \\bigr)^2.\n$$\n\n对于下面的每个测试用例，您必须生成 $R$ 次独立的蒙特卡洛重复。在每次重复中，从指定的数据生成过程中抽取一个大小为 $N$ 的独立样本，从该重复中计算 $\\hat{\\beta}_{\\mathrm{IV}}$，然后计算重复偏差 $\\hat{\\beta}_{\\mathrm{IV}} - \\beta$。通过取其算术平均值来汇总重复偏差，以获得该测试用例的平均工具变量偏差。使用固定的伪随机数生成器种子以确保确定性：对于索引为 $k$（从零开始）的测试用例，使用种子 $2025 + k$。\n\n使用以下测试套件，其中每个项目列出了 $(N, R, p, \\pi, \\beta, \\gamma, \\delta, \\alpha, \\sigma_X, \\sigma_Y)$：\n\n- 测试用例 A（理想情况，存在未测量混杂的有效工具变量）：$(\\,N=\\;4000,\\; R=\\;800,\\; p=\\;0.3,\\; \\pi=\\;0.2,\\; \\beta=\\;0.5,\\; \\gamma=\\;0.8,\\; \\delta=\\;0.8,\\; \\alpha=\\;0.0,\\; \\sigma_X=\\;1.0,\\; \\sigma_Y=\\;1.0\\,)$。\n- 测试用例 B（边界情况，存在未测量混杂的弱但有效工具变量）：$(\\,N=\\;4000,\\; R=\\;800,\\; p=\\;0.3,\\; \\pi=\\;0.01,\\; \\beta=\\;0.5,\\; \\gamma=\\;0.8,\\; \\delta=\\;0.8,\\; \\alpha=\\;0.0,\\; \\sigma_X=\\;1.0,\\; \\sigma_Y=\\;1.0\\,)$。\n- 测试用例 C（边缘情况，违反排他性限制）：$(\\,N=\\;4000,\\; R=\\;800,\\; p=\\;0.3,\\; \\pi=\\;0.2,\\; \\beta=\\;0.5,\\; \\gamma=\\;0.8,\\; \\delta=\\;0.8,\\; \\alpha=\\;0.2,\\; \\sigma_X=\\;1.0,\\; \\sigma_Y=\\;1.0\\,)$。\n- 测试用例 D（边缘情况，无未测量混杂）：$(\\,N=\\;4000,\\; R=\\;800,\\; p=\\;0.3,\\; \\pi=\\;0.2,\\; \\beta=\\;0.5,\\; \\gamma=\\;0.0,\\; \\delta=\\;0.0,\\; \\alpha=\\;0.0,\\; \\sigma_X=\\;1.0,\\; \\sigma_Y=\\;1.0\\,)$。\n\n设无偏性的容忍度为 $\\tau = 0.05$。对于每个测试用例，输出一个布尔值，指示平均工具变量偏差的绝对值是否最多为 $\\tau$，即 $\\bigl|\\frac{1}{R}\\sum_{r=1}^{R} (\\hat{\\beta}_{\\mathrm{IV},r} - \\beta)\\bigr| \\le \\tau$ 是否成立。\n\n您的程序必须生成单行输出，其中包含测试用例 A、B、C、D 的布尔值，按此顺序，格式为逗号分隔的列表，并用方括号括起，无空格，例如 `[{\\tt True},{\\tt False},{\\tt True},{\\tt True}]`。", "solution": "该问题要求实现一个确定性的蒙特卡洛模拟，以在孟德尔随机化（MR）框架内评估因果效应 $\\beta$ 的工具变量（IV）估计量的无偏性。评估在几种情景下进行，每种情景由线性结构方程模型的一组参数定义。\n\n数据生成过程由以下方程组定义：\n$$\nX \\;=\\; \\pi \\, G \\;+\\; \\gamma \\, U \\;+\\; \\varepsilon_X\n$$\n$$\nY \\;=\\; \\beta \\, X \\;+\\; \\delta \\, U \\;+\\; \\alpha \\, G \\;+\\; \\varepsilon_Y\n$$\n这里，$G$ 是基因工具变量，$U$ 是未测量的混杂因素，$X$ 是暴露，$Y$ 是结局。随机变量的分布如下：$G \\sim \\text{Binomial}(2,p)$，$U \\sim \\mathcal{N}(0,1)$，$\\varepsilon_X \\sim \\mathcal{N}(0,\\sigma_X^2)$，以及 $\\varepsilon_Y \\sim \\mathcal{N}(0,\\sigma_Y^2)$。所有外生变量（$G$、$U$、$\\varepsilon_X$、$\\varepsilon_Y$）被规定为相互独立。\n\n问题通过经验矩条件定义了工具变量估计量 $\\hat{\\beta}_{\\mathrm{IV}}$：\n$$\n\\frac{1}{N} \\sum_{i=1}^{N} G_i \\,\\bigl(Y_i - \\hat{\\beta}_{\\mathrm{IV}}\\, X_i \\bigr) \\;=\\; 0\n$$\n对于一个大小为 $N$ 的样本。这个条件必须被满足。我们可以通过简单的代数运算推导出 $\\hat{\\beta}_{\\mathrm{IV}}$ 的闭式表达式。将 $G_i$ 分配并重新整理求和项可得：\n$$\n\\sum_{i=1}^{N} G_i Y_i - \\hat{\\beta}_{\\mathrm{IV}} \\sum_{i=1}^{N} G_i X_i = 0\n$$\n求解 $\\hat{\\beta}_{\\mathrm{IV}}$ 可得到单工具变量估计量的表达式，通常称为 Wald 估计量：\n$$\n\\hat{\\beta}_{\\mathrm{IV}} = \\frac{\\sum_{i=1}^{N} G_i Y_i}{\\sum_{i=1}^{N} G_i X_i}\n$$\n这个公式计算简单，并构成了我们模拟的基础。分母也可以写成一个样本均值 $\\mathbb{E}_N[GY] = \\frac{1}{N}\\sum G_i Y_i$ 除以另一个样本均值 $\\mathbb{E}_N[GX] = \\frac{1}{N}\\sum G_i X_i$。\n\n核心的工具变量假设是：\n1. **相关性**：工具变量 $G$ 必须与暴露 $X$ 相关。在此模型中，这要求 $\\pi \\neq 0$。\n2. **独立性**：工具变量 $G$ 必须独立于未测量的混杂因素 $U$。这一点由问题的数据生成过程保证。\n3. **排他性限制**：工具变量 $G$ 不得通过除暴露 $X$ 以外的途径影响结局 $Y$。这要求直接效应参数 $\\alpha$ 为零，即 $\\alpha = 0$。\n\n当这些假设成立时，IV 估计量是真实因果效应 $\\beta$ 的一致估计量。即，当 $N \\to \\infty$ 时，$\\hat{\\beta}_{\\mathrm{IV}} \\xrightarrow{p} \\beta$。然而，在有限样本中，或者当假设被违反时，该估计量可能是有偏的。\n\n对于每个由参数元组 $(N, R, p, \\pi, \\beta, \\gamma, \\delta, \\alpha, \\sigma_X, \\sigma_Y)$ 指定的测试用例，模拟算法如下：\n1. 使用一个固定的伪随机数生成器种子，对于第 $k$ 个测试用例（从 $k=0$ 开始）为 $2025+k$，以确保结果的确定性和可复现性。\n2. 共生成 $R$ 次蒙特卡洛重复。\n3. 在每次重复 $r \\in \\{1, \\dots, R\\}$ 中：\n    a. 抽取一个大小为 $N$ 的样本。这涉及为每个外生变量生成 $N$ 个独立抽样：$G_i \\sim \\text{Binomial}(2,p)$，$U_i \\sim \\mathcal{N}(0,1)$，$\\varepsilon_{X,i} \\sim \\mathcal{N}(0,\\sigma_X^2)$，以及 $\\varepsilon_{Y,i} \\sim \\mathcal{N}(0,\\sigma_Y^2)$。\n    b. 对于每个观测值 $i \\in \\{1, \\dots, N\\}$，使用结构方程构建内生变量 $X_i$ 和 $Y_i$。\n    c. 使用上面推导的公式计算该次重复的 IV 估计值 $\\hat{\\beta}_{\\mathrm{IV},r}$。\n    d. 计算该次重复的偏差为 $\\hat{\\beta}_{\\mathrm{IV},r} - \\beta$。\n4. 在所有 $R$ 次重复完成后，计算平均偏差，即所有单次重复偏差的算术平均值：$\\text{平均偏差} = \\frac{1}{R} \\sum_{r=1}^{R} (\\hat{\\beta}_{\\mathrm{IV},r} - \\beta)$。\n5. 最后，将平均偏差的绝对值与指定的容忍度 $\\tau=0.05$ 进行比较。如果 $|\\text{平均偏差}| \\le \\tau$，结果为 `True`，否则为 `False`。\n\n我们根据 MR 理论分析每个测试用例的预期结果：\n- **测试用例 A**：所有三个 MR 假设都满足，且工具变量很强（$\\pi=0.2$）。估计量应该近似无偏。我们预期平均偏差会远小于容忍度 $\\tau=0.05$。\n- **测试用例 B**：工具变量的相关性假设满足，但工具变量很弱（$\\pi=0.01$）。已知弱工具变量会产生有限样本偏差，该偏差趋向于朴素 OLS 估计量的偏差。由于存在混杂（$\\gamma=0.8, \\delta=0.8$），OLS 估计是有偏的，因此 IV 估计也将有显著偏差。我们预期平均偏差将超过 $\\tau=0.05$。\n- **测试用例 C**：排他性限制被违反（$\\alpha=0.2$）。这种违反正引入了渐进偏差。估计量 $\\hat{\\beta}_{\\mathrm{IV}}$ 在概率上收敛于 $\\beta + \\alpha/\\pi$ 而非 $\\beta$。在这种情况下，渐进偏差为 $0.2/0.2 = 1.0$，远大于 $\\tau=0.05$。\n- **测试用例 D**：没有未测量的混杂（$\\gamma = 0$ 且 $\\delta = 0$）。在这种情景下，内生性的主要来源被移除了。MR 假设得到满足，IV 估计量应该是无偏的。在这种情况下，即使是朴素的 OLS 估计量也是无偏的。我们预期平均偏差会远小于 $\\tau=0.05$。\n\n实现将遵循这一逻辑来提供最终的布尔值输出。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, R, p, pi, beta, gamma, delta, alpha, sigma_X, sigma_Y, seed):\n    \"\"\"\n    Runs a Monte Carlo simulation for a single Mendelian randomization scenario.\n    \n    Args:\n        N (int): Sample size per replicate.\n        R (int): Number of Monte Carlo replicates.\n        p (float): Allele frequency for the binomial genetic instrument.\n        pi (float): Effect of instrument G on exposure X.\n        beta (float): Causal effect of exposure X on outcome Y.\n        gamma (float): Effect of confounder U on exposure X.\n        delta (float): Effect of confounder U on outcome Y.\n        alpha (float): Direct effect of instrument G on outcome Y (pleiotropy).\n        sigma_X (float): Standard deviation of the noise term for X.\n        sigma_Y (float): Standard deviation of the noise term for Y.\n        seed (int): Seed for the pseudorandom number generator.\n        \n    Returns:\n        float: The mean bias of the IV estimator over all replicates.\n    \"\"\"\n    # Set the seed for reproducibility for this entire test case.\n    np.random.seed(seed)\n    \n    replicate_biases = []\n    \n    for _ in range(R):\n        # 1. Generate exogenous variables for a sample of size N.\n        G = np.random.binomial(2, p, size=N)\n        U = np.random.normal(0, 1, size=N)\n        eps_X = np.random.normal(0, sigma_X, size=N)\n        eps_Y = np.random.normal(0, sigma_Y, size=N)\n        \n        # 2. Generate endogenous variables based on structural equations.\n        X = pi * G + gamma * U + eps_X\n        Y = beta * X + delta * U + alpha * G + eps_Y\n        \n        # 3. Compute the IV estimator for the replicate.\n        sum_GX = np.sum(G * X)\n        sum_GY = np.sum(G * Y)\n        \n        # The probability of sum_GX being zero is astronomically small for the given\n        # parameters (N=4000, p=0.3) and can be safely disregarded.\n        if sum_GX == 0:\n            continue\n            \n        beta_iv = sum_GY / sum_GX\n        \n        # 4. Calculate and store the bias for this replicate.\n        bias = beta_iv - beta\n        replicate_biases.append(bias)\n        \n    # 5. Compute the mean bias over all replicates.\n    if not replicate_biases:\n        # This branch is effectively unreachable under the problem's constraints.\n        return np.nan\n        \n    mean_bias = np.mean(replicate_biases)\n    \n    return mean_bias\n\ndef solve():\n    \"\"\"\n    Defines the test cases, runs the simulations, and prints the results.\n    \"\"\"\n    # Test cases defined as (N, R, p, pi, beta, gamma, delta, alpha, sigma_X, sigma_Y)\n    test_cases = [\n        # Case A: Happy path, valid instrument\n        (4000, 800, 0.3, 0.2, 0.5, 0.8, 0.8, 0.0, 1.0, 1.0),\n        # Case B: Boundary, weak instrument\n        (4000, 800, 0.3, 0.01, 0.5, 0.8, 0.8, 0.0, 1.0, 1.0),\n        # Case C: Edge case, exclusion restriction violated\n        (4000, 800, 0.3, 0.2, 0.5, 0.8, 0.8, 0.2, 1.0, 1.0),\n        # Case D: Edge case, no confounding\n        (4000, 800, 0.3, 0.2, 0.5, 0.0, 0.0, 0.0, 1.0, 1.0),\n    ]\n    \n    tau = 0.05\n    results = []\n    \n    for k, case_params in enumerate(test_cases):\n        seed = 2025 + k\n        mean_bias = run_simulation(*case_params, seed=seed)\n        \n        # Check if the absolute mean bias is within the tolerance.\n        is_unbiased_within_tolerance = abs(mean_bias) = tau\n        results.append(is_unbiased_within_tolerance)\n        \n    # Print the final results in the specified format: [True,False,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2404055"}, {"introduction": "在理解了MR的基本原理后，下一步是处理真实的（或模拟的）汇总数据。本练习将指导你计算最常见的MR估计值（如IVW和MR-Egger），并生成关键诊断图（如散点图和漏斗图）的数值基础。这些分析对于识别和评估潜在的水平多效性和异质性至关重要。[@problem_id:2404096]", "problem": "在孟德尔随机化（MR）的设定下，您将获得来自全基因组关联研究（GWAS）的汇总关联数据。这些数据来源于作为工具变量的单核苷酸多态性（SNP）。对于每个 SNP，您拥有其与暴露的关联性，表示为 $ \\beta_{GX,i} $，以及其与结局的关联性，表示为 $ \\beta_{GY,i} $，同时还有结局关联性的标准误 $ \\sigma_{GY,i} $。假设遵循以下基本原则：(i) 暴露-结局关系服从线性因果模型；(ii) 除了任何潜在的水平多效性外，工具变量仅通过暴露影响结局；(iii) $ \\beta_{GY,i} $ 的抽样变异由 $ \\sigma_{GY,i} $ 量化，并且在加权时，$ \\beta_{GX,i} $ 的不确定性相对于 $ \\sigma_{GY,i} $ 可以忽略不计；(iv) 因果效应可以通过使用加权最小二乘法汇总每个变异体的信息来估计。\n\n您的任务是编写一个完整的程序，该程序针对下述每个测试用例，计算生成以下图形所需的数值对象：(a) 一个 $ \\beta_{GY} $ 相对于 $ \\beta_{GX} $ 的散点图，图中包含截距约束的反方差加权（IVW）回归线和孟德尔随机化 Egger（MR-Egger）回归线；(b) 一个比率估计值相对于其标准误的漏斗图，用于直观检查异质性和多效性。您的程序无需绘制任何图形，但必须返回定义这些图形的精确数值。\n\n请仅根据上述基本原则，为每个测试用例实现以下计算：\n- 使用由结局方差的倒数定义的权重 $ w_i $，即 $ w_i = 1 / \\sigma_{GY,i}^2 $。\n- 通过求解截距固定为零的加权最小二乘问题，即最小化 $ \\sum_i w_i \\left( \\beta_{GY,i} - b \\, \\beta_{GX,i} \\right)^2 $（对 $ b $），来计算截距约束的 IVW 因果斜率估计值。\n- 通过最小化 $ \\sum_i w_i \\left( \\beta_{GY,i} - a - b \\, \\beta_{GX,i} \\right)^2 $（对 $ a $ 和 $ b $），计算具有无约束截距的 MR-Egger 加权回归线。\n- 计算 IVW 拟合下的异质性 Cochran's $ Q $ 统计量和相应的 $ I^2 $ 异质性度量，其中 $ Q $ 比较了加权残差的离散度与其在同质性假设下的期望值。\n- 对于漏斗图，假设 $ \\beta_{GX,i} $ 的不确定性相对于 $ \\sigma_{GY,i} $ 可以忽略不计，计算每个变异体的比率估计值 $ \\theta_i $ 及其近似标准误 $ s_i $。然后，围绕合并的 IVW 效应，计算每个变异体的伪 $ 95\\% $ 漏斗图边界，公式为 $ \\theta_{\\text{IVW}} \\pm 1.96 \\, s_i $。\n\n您的程序必须将这些计算应用于以下测试套件。每个测试用例由三个等长的列表定义：$ \\beta_{GX} $、$ \\beta_{GY} $ 和 $ \\sigma_{GY} $。\n\n测试用例 A（理想路径；一致的工具变量）：\n- $ \\beta_{GX} = [\\, 0.08, \\, 0.12, \\, 0.10, \\, 0.15, \\, 0.07, \\, 0.11 \\,] $\n- $ \\beta_{GY} = [\\, 0.040, \\, 0.060, \\, 0.051, \\, 0.072, \\, 0.033, \\, 0.057 \\,] $\n- $ \\sigma_{GY} = [\\, 0.020, \\, 0.018, \\, 0.022, \\, 0.019, \\, 0.021, \\, 0.020 \\,] $\n\n测试用例 B（方向性多效性；预期非零截距）：\n- $ \\beta_{GX} = [\\, 0.05, \\, -0.04, \\, 0.09, \\, 0.12, \\, 0.03, \\, 0.07 \\,] $\n- $ \\beta_{GY} = [\\, 0.037, \\, 0.007, \\, 0.048, \\, 0.054, \\, 0.029, \\, 0.042 \\,] $\n- $ \\sigma_{GY} = [\\, 0.020, \\, 0.021, \\, 0.019, \\, 0.018, \\, 0.022, \\, 0.020 \\,] $\n\n测试用例 C（异质性和一个弱工具变量）：\n- $ \\beta_{GX} = [\\, 0.20, \\, 0.15, \\, 0.10, \\, 0.05, \\, 0.004 \\,] $\n- $ \\beta_{GY} = [\\, 0.080, \\, 0.070, \\, 0.045, \\, 0.050, \\, 0.010 \\,] $\n- $ \\sigma_{GY} = [\\, 0.015, \\, 0.015, \\, 0.016, \\, 0.020, \\, 0.020 \\,] $\n\n测试用例 D（平衡多效性；异质性，但截距近似为零）：\n- $ \\beta_{GX} = [\\, 0.10, \\, 0.12, \\, 0.09, \\, 0.11, \\, 0.08 \\,] $\n- $ \\beta_{GY} = [\\, 0.080, \\, 0.052, \\, 0.064, \\, 0.056, \\, 0.048 \\,] $\n- $ \\sigma_{GY} = [\\, 0.020, \\, 0.020, \\, 0.020, \\, 0.020, \\, 0.020 \\,] $\n\n实现和数值要求：\n- 将所有权重视为 $ w_i = 1 / \\sigma_{GY,i}^2 $。\n- 对于漏斗图，计算 $ \\theta_i = \\beta_{GY,i} / \\beta_{GX,i} $ 和 $ s_i = \\sigma_{GY,i} / \\lvert \\beta_{GX,i} \\rvert $。\n- 在漏斗图边界 $ \\theta_{\\text{IVW}} \\pm 1.96 \\, s_i $ 中，使用 IVW 斜率作为合并效应。\n- 对于 IVW 拟合下的 Cochran 异质性统计量，计算 $ Q $，然后计算 $ I^2 = \\max \\left( 0, \\, \\dfrac{Q - (M - 1)}{Q} \\right) $，其中 $ M $ 是变异体的数量。如果 $ Q = 0 $，则设 $ I^2 = 0 $。\n- 对于每个测试用例，您的程序必须按以下顺序输出一个包含九个元素的列表：\n  1. IVW 斜率（一个浮点数），\n  2. MR-Egger 斜率（一个浮点数），\n  3. MR-Egger 截距（一个浮点数），\n  4. IVW Cochran’s $ Q $（一个浮点数），\n  5. IVW $ I^2 $（一个浮点数），\n  6. 比率估计值列表 $ [ \\theta_i ] $，\n  7. 比率标准误列表 $ [ s_i ] $，\n  8. 漏斗图下界列表 $ [ \\theta_{\\text{IVW}} - 1.96 \\, s_i ] $，\n  9. 漏斗图上界列表 $ [ \\theta_{\\text{IVW}} + 1.96 \\, s_i ] $。\n- 将所有浮点数四舍五入至六位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含四个测试用例的结果，这些结果聚合为一个用方括号括起来的逗号分隔列表，且没有空格。即，形式为 $ [r_A, r_B, r_C, r_D] $ 的单行，其中每个 $ r_\\cdot $ 是上述的九元素列表。\n\n边界条件和科学真实性：\n- 确保 $ \\lvert \\beta_{GX,i} \\rvert $ 不为零，以避免在比率计算中出现除以零的情况。所提供的测试套件满足此条件；一般而言，如果任何 $ \\lvert \\beta_{GX,i} \\rvert $ 低于某个小阈值 $ \\varepsilon $，则应将该变异体从比率和漏斗图组件中排除，同时在回归拟合中（如果处理得当）保持一致。在此测试套件中，无需进行任何排除。", "solution": "问题陈述经评估有效。它在科学上基于孟德尔随机化（MR）的既定原则，这是一种遗传流行病学中的标准方法。问题设定良好，为所需的计算提供了所有必要的数据和明确的数学定义。语言客观、正式，没有歧义或主观论断。它提出了一个基于可验证的统计学和数学原理的可解计算任务。\n\n我们现在将系统地推导所需的量。背景是使用遗传变异作为工具变量来估计暴露对结局的因果效应。对于M个遗传变异（SNP），我们已知其与暴露的估计关联 $ \\beta_{GX,i} $、其与结局的估计关联 $ \\beta_{GY,i} $ 以及后者的标准误 $ \\sigma_{GY,i} $。\n\n所有加权计算的权重由结局方差的倒数定义，假设为此目的 $ \\beta_{GX,i} $ 的不确定性可以忽略不计：\n$$\nw_i = \\frac{1}{\\sigma_{GY,i}^2}\n$$\n\n**1. 截距约束的反方差加权（IVW）斜率**\n\nIVW 方法通过求解一个将回归线强制通过原点的加权最小二乘问题来估计因果效应 $b$。这对应于无水平多效性的假设。目标是最小化加权残差平方和：\n$$\nS(b) = \\sum_{i=1}^{M} w_i \\left( \\beta_{GY,i} - b \\, \\beta_{GX,i} \\right)^2\n$$\n为求最小值，我们将关于 $b$ 的导数设为零：\n$$\n\\frac{dS}{db} = -2 \\sum_{i=1}^{M} w_i \\beta_{GX,i} \\left( \\beta_{GY,i} - b \\, \\beta_{GX,i} \\right) = 0\n$$\n求解 $b$ 可得 IVW 估计值，我们将其表示为 $\\theta_{\\text{IVW}}$：\n$$\n\\theta_{\\text{IVW}} = \\frac{\\sum_{i=1}^{M} w_i \\beta_{GX,i} \\beta_{GY,i}}{\\sum_{i=1}^{M} w_i \\beta_{GX,i}^2}\n$$\n\n**2. 孟德尔随机化 Egger (MR-Egger) 回归**\n\nMR-Egger 方法放宽了 IVW 方法的无多效性假设，允许在 $\\beta_{GY,i}$ 对 $\\beta_{GX,i}$ 的回归中存在非零截距。截距 $a$ 可被解释为平均方向性多效效应的估计值，而斜率 $b$ 仍然是因果效应的估计值。我们对 $a$ 和 $b$ 最小化以下目标函数：\n$$\nS(a, b) = \\sum_{i=1}^{M} w_i \\left( \\beta_{GY,i} - a - b \\, \\beta_{GX,i} \\right)^2\n$$\n这是一个标准的加权线性回归问题。MR-Egger 斜率（$b_{\\text{Egger}}$）和截距（$a_{\\text{Egger}}$）的解由正规方程给出：\n$$\nb_{\\text{Egger}} = \\frac{ \\left(\\sum w_i\\right) \\left(\\sum w_i \\beta_{GX,i} \\beta_{GY,i}\\right) - \\left(\\sum w_i \\beta_{GX,i}\\right) \\left(\\sum w_i \\beta_{GY,i}\\right) }{ \\left(\\sum w_i\\right) \\left(\\sum w_i \\beta_{GX,i}^2\\right) - \\left(\\sum w_i \\beta_{GX,i}\\right)^2 }\n$$\n$$\na_{\\text{Egger}} = \\frac{\\sum w_i \\beta_{GY,i}}{\\sum w_i} - b_{\\text{Egger}} \\frac{\\sum w_i \\beta_{GX,i}}{\\sum w_i}\n$$\n这些公式对应于加权最小二乘回归系数的标准解。\n\n**3. Cochran’s Q 统计量和 I² 异质性度量**\n\n工具变量特异性因果估计值之间的异质性可能表明违反了 MR 假设（例如多效性），或者表明对于不同工具变量所针对的人群子集，真实的因果效应有所不同。IVW 模型的 Cochran’s $Q$ 统计量通过对单个比率估计值与合并 IVW 估计值之间的加权平方差求和来量化这种异质性。其计算公式为：\n$$\nQ = \\sum_{i=1}^{M} w_i \\left( \\frac{\\beta_{GY,i}}{\\beta_{GX,i}} - \\theta_{\\text{IVW}} \\right)^2 \\beta_{GX,i}^2 = \\sum_{i=1}^{M} w_i \\left( \\beta_{GY,i} - \\theta_{\\text{IVW}} \\beta_{GX,i} \\right)^2\n$$\n在同质性的零假设下（即所有工具变量估计相同的因果效应），$Q$ 服从自由度为 $M-1$ 的卡方分布。\n\n$I^2$ 统计量描述了工具变量间的变异中由异质性而非抽样误差导致的百分比。它由 $Q$ 导出：\n$$\nI^2 = \\max\\left(0, \\frac{Q - (M-1)}{Q}\\right)\n$$\n如果 $Q=0$（在实践中极不可能发生），则定义 $I^2$ 为 $0$。\n\n**4. 漏斗图组件**\n\n漏斗图是一种用于研究异质性和发表偏倚的可视化工具。它将每个工具变量的效应大小与其精确度的度量进行绘图。\n\n- **每个变异体的比率估计值（$\\theta_i$）：** 这是从单个工具变量 $i$ 估计的因果效应：\n    $$\n    \\theta_i = \\frac{\\beta_{GY,i}}{\\beta_{GX,i}}\n    $$\n- **比率估计值的标准误（$s_i$）：** 使用 delta 方法并假设 $\\beta_{GX,i}$ 的测量误差可忽略不计，$\\theta_i$ 的标准误近似为：\n    $$\n    s_i = \\text{SE}(\\theta_i) \\approx \\frac{\\sigma_{GY,i}}{\\lvert \\beta_{GX,i} \\rvert}\n    $$\n- **漏斗图边界：** 漏斗图围绕合并的 IVW 因果估计值 $\\theta_{\\text{IVW}}$ 构建。对于伪 $95\\%$ 置信区间，每个变异体 $i$ 的边界为：\n    $$\n    \\text{Bounds}_i = \\theta_{\\text{IVW}} \\pm 1.96 \\, s_i\n    $$\n    下界和上界分别为 $\\theta_{\\text{IVW}} - 1.96 \\, s_i$ 和 $\\theta_{\\text{IVW}} + 1.96 \\, s_i$。\n\n该实现将为每个提供的测试用例计算这九个量：IVW 斜率、MR-Egger 斜率和截距、IVW 拟合的 Cochran's $Q$ 和 $I^2$ 统计量，以及比率估计值列表、其标准误列表以及相应的漏斗图下界和上界列表。所有浮点数将按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef calculate_mr_metrics(beta_gx: list[float], beta_gy: list[float], sigma_gy: list[float]) - list:\n    \"\"\"\n    Computes Mendelian randomization metrics for a given set of summary statistics.\n\n    Args:\n        beta_gx: List of SNP-exposure associations.\n        beta_gy: List of SNP-outcome associations.\n        sigma_gy: List of standard errors for SNP-outcome associations.\n\n    Returns:\n        A list containing nine elements as specified in the problem description.\n    \"\"\"\n    # Convert lists to NumPy arrays for vectorized operations\n    bgx = np.array(beta_gx)\n    bgy = np.array(beta_gy)\n    sgy = np.array(sigma_gy)\n    \n    # 1. Weights\n    # w_i = 1 / sigma_GY,i^2\n    w = 1.0 / (sgy**2)\n    \n    # 2. IVW Slope (Intercept-constrained)\n    # theta_ivw = (sum w_i * beta_gx_i * beta_gy_i) / (sum w_i * beta_gx_i^2)\n    ivw_numerator = np.sum(w * bgx * bgy)\n    ivw_denominator = np.sum(w * bgx**2)\n    ivw_slope = ivw_numerator / ivw_denominator\n    \n    # 3. MR-Egger Slope and Intercept\n    # Weighted least squares regression of bgy on bgx with weights w\n    W = np.sum(w)\n    Swx = np.sum(w * bgx)\n    Swy = np.sum(w * bgy)\n    Swxx = np.sum(w * bgx**2)\n    Swxy = np.sum(w * bgx * bgy)\n    \n    egger_denominator = (W * Swxx - Swx**2)\n    if egger_denominator == 0:\n        # This case is unlikely with real data but handle for robustness\n        mr_egger_slope = np.nan\n        mr_egger_intercept = np.nan\n    else:\n        mr_egger_slope = (W * Swxy - Swx * Swy) / egger_denominator\n        mr_egger_intercept = (Swy / W) - mr_egger_slope * (Swx / W)\n\n    # 4. Cochran's Q for IVW\n    # Q = sum w_i * (beta_gy_i - theta_ivw * beta_gx_i)^2\n    cochran_q = np.sum(w * (bgy - ivw_slope * bgx)**2)\n    \n    # 5. I^2 for IVW\n    M = len(bgx)\n    df = M - 1\n    if cochran_q == 0:\n        i_squared = 0.0\n    else:\n        i_squared = max(0.0, (cochran_q - df) / cochran_q)\n\n    # 6. Ratio estimates (theta_i)\n    # theta_i = beta_gy_i / beta_gx_i\n    theta_i = bgy / bgx\n    \n    # 7. Ratio standard errors (s_i)\n    # s_i = sigma_gy_i / |beta_gx_i|\n    s_i = sgy / np.abs(bgx)\n    \n    # 8.  9. Funnel plot bounds\n    # lower/upper = theta_ivw +/- 1.96 * s_i\n    z_score = 1.96\n    funnel_lower_bounds = ivw_slope - z_score * s_i\n    funnel_upper_bounds = ivw_slope + z_score * s_i\n    \n    # Assemble results and round to 6 decimal places\n    results = [\n        round(ivw_slope, 6),\n        round(mr_egger_slope, 6),\n        round(mr_egger_intercept, 6),\n        round(cochran_q, 6),\n        round(i_squared, 6),\n        [round(val, 6) for val in theta_i],\n        [round(val, 6) for val in s_i],\n        [round(val, 6) for val in funnel_lower_bounds],\n        [round(val, 6) for val in funnel_upper_bounds],\n    ]\n    \n    return results\n\ndef format_result_list(res_list: list) - str:\n    \"\"\"Formats a single test case result list into the required string format.\"\"\"\n    str_parts = []\n    for item in res_list:\n        if isinstance(item, list):\n            formatted_list = f\"[{','.join([f'{x:.6f}' for x in item])}]\"\n            str_parts.append(formatted_list)\n        else:\n            str_parts.append(f\"{item:.6f}\")\n    return f\"[{','.join(str_parts)}]\"\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = {\n        'A': {\n            \"beta_gx\": [0.08, 0.12, 0.10, 0.15, 0.07, 0.11],\n            \"beta_gy\": [0.040, 0.060, 0.051, 0.072, 0.033, 0.057],\n            \"sigma_gy\": [0.020, 0.018, 0.022, 0.019, 0.021, 0.020]\n        },\n        'B': {\n            \"beta_gx\": [0.05, -0.04, 0.09, 0.12, 0.03, 0.07],\n            \"beta_gy\": [0.037, 0.007, 0.048, 0.054, 0.029, 0.042],\n            \"sigma_gy\": [0.020, 0.021, 0.019, 0.018, 0.022, 0.020]\n        },\n        'C': {\n            \"beta_gx\": [0.20, 0.15, 0.10, 0.05, 0.004],\n            \"beta_gy\": [0.080, 0.070, 0.045, 0.050, 0.010],\n            \"sigma_gy\": [0.015, 0.015, 0.016, 0.020, 0.020]\n        },\n        'D': {\n            \"beta_gx\": [0.10, 0.12, 0.09, 0.11, 0.08],\n            \"beta_gy\": [0.080, 0.052, 0.064, 0.056, 0.048],\n            \"sigma_gy\": [0.020, 0.020, 0.020, 0.020, 0.020]\n        }\n    }\n\n    all_results_str = []\n    # Process cases in alphabetical order to match output format\n    for key in sorted(test_cases.keys()):\n        case = test_cases[key]\n        result = calculate_mr_metrics(case[\"beta_gx\"], case[\"beta_gy\"], case[\"sigma_gy\"])\n        all_results_str.append(format_result_list(result))\n\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2404096"}, {"introduction": "水平多效性是MR研究中的一个主要挑战，为此研究者开发了多种对无效工具变量更不敏感的稳健方法。本练习将介绍标准IVW方法之外的几种常用方法。通过实现和比较IVW、加权中位数和加权众数估计量，你将学会如何评估一个因果结论在不同模型假设下的一致性和稳健性。[@problem_id:2404047]", "problem": "实现一个程序，该程序根据为若干独立遗传变异提供的汇总双样本孟德尔随机化 (MR) 数据，计算三种因果效应估计量：反方差加权 (IVW) 估计量、加权中位数估计量和加权众数估计量。背景是孟德尔随机化 (MR)，其中遗传变异可作为暴露-结局关系的工具变量。您将获得每个变异对于暴露和对于结局的关联估计值及其标准误，您必须仅使用这些汇总输入，根据基本定义计算每种估计量。\n\n设有 $m$ 个独立的遗传变异（单核苷酸多态性 (SNP)），由 $i \\in \\{1,\\dots,m\\}$ 索引。对于每个变异 $i$，您将获得暴露关联 $\\hat{\\gamma}_{X,i}$、其标准误 $\\operatorname{se}(\\hat{\\gamma}_{X,i})$、结局关联 $\\hat{\\gamma}_{Y,i}$ 及其标准误 $\\operatorname{se}(\\hat{\\gamma}_{Y,i})$。假设是无样本重叠的双样本 MR，因此在近似比率估计量的方差时，可以忽略 $\\hat{\\gamma}_{X,i}$ 中的测量误差。对于每个变异，定义比率估计值\n$$\n\\hat{\\beta}_i \\equiv \\frac{\\hat{\\gamma}_{Y,i}}{\\hat{\\gamma}_{X,i}},\n$$\n近似标准误\n$$\n\\hat{\\sigma}_{\\beta_i} \\equiv \\frac{\\operatorname{se}(\\hat{\\gamma}_{Y,i})}{\\lvert \\hat{\\gamma}_{X,i} \\rvert},\n$$\n以及反方差权重\n$$\nw_i \\equiv \\frac{1}{\\hat{\\sigma}_{\\beta_i}^2} = \\left(\\frac{\\lvert \\hat{\\gamma}_{X,i} \\rvert}{\\operatorname{se}(\\hat{\\gamma}_{Y,i})}\\right)^2.\n$$\n\n三种估计量定义如下：\n\n1. 反方差加权 (IVW) 估计量：\n$$\n\\hat{\\beta}_{\\mathrm{IVW}} \\equiv \\frac{\\sum_{i=1}^m w_i \\hat{\\beta}_i}{\\sum_{i=1}^m w_i}.\n$$\n\n2. 加权中位数估计量：令 $(\\hat{\\beta}_{(1)}, \\dots, \\hat{\\beta}_{(m)})$ 为按非递减顺序排序的比率估计值，其相应权重 $(w_{(1)}, \\dots, w_{(m)})$ 也进行一致的排列，并令 $W \\equiv \\sum_{i=1}^m w_i$。加权中位数是满足以下条件的任何 $\\hat{\\beta}_{(k)}$：\n$$\n\\sum_{j=1}^{k-1} \\frac{w_{(j)}}{W}  0.5 \\le \\sum_{j=1}^{k} \\frac{w_{(j)}}{W}.\n$$\n返回满足条件的最小的 $\\hat{\\beta}_{(k)}$。\n\n3. 加权众数估计量：对于一个固定的带宽 $h  0$，为任何 $b \\in \\mathbb{R}$ 定义加权高斯核得分为\n$$\nS_h(b) \\equiv \\sum_{i=1}^m w_i \\exp\\!\\left(-\\frac{(\\,b - \\hat{\\beta}_i\\,)^2}{2 h^2}\\right).\n$$\n加权众数估计量是\n$$\n\\hat{\\beta}_{\\mathrm{mode}}(h) \\equiv \\operatorname*{arg\\,max}_{b \\in \\mathbb{R}} S_h(b).\n$$\n为进行数值计算，在一个覆盖\n$$\n\\left[\\min_i \\hat{\\beta}_i - 0.2,\\; \\max_i \\hat{\\beta}_i + 0.2\\right]\n$$\n的均匀网格上评估 $S_h(b)$，该网格至少有 $20001$ 个均匀间隔的点，并取该网格上的最大化子。对所有测试用例使用一个通用带宽 $h = 0.06$。\n\n您的程序必须为下面的每个测试用例计算 $(\\hat{\\beta}_{\\mathrm{IVW}}, \\hat{\\beta}_{\\mathrm{WM}}, \\hat{\\beta}_{\\mathrm{mode}})$，其中 $\\hat{\\beta}_{\\mathrm{WM}}$ 表示加权中位数，然后将所有结果作为列表的列表在单行上打印，每个内部列表按顺序对应一个测试用例，并且每个数值都四舍五入到恰好 $4$ 位小数。\n\n测试套件（三个案例）：\n- 案例 A（所有工具变量均有效，围绕单一因果效应聚集）：$m = 12$ 且\n$$\n\\hat{\\gamma}_{X} = (0.10, 0.12, 0.08, -0.09, 0.15, -0.11, 0.07, 0.20, -0.13, 0.05, -0.16, 0.14),\n$$\n$$\n\\operatorname{se}(\\hat{\\gamma}_{X}) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02),\n$$\n$$\n\\hat{\\gamma}_{Y} = (0.053, 0.056, 0.042, -0.044, 0.080, -0.057, 0.038, 0.094, -0.062, 0.026, -0.084, 0.072),\n$$\n$$\n\\operatorname{se}(\\hat{\\gamma}_{Y}) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02).\n$$\n\n- 案例 B（恰好 $50\\%$ 的工具变量无效，存在两个聚类；无效集表现出与暴露关联成比例的定向多效性）：$m = 12$ 且\n$$\n\\hat{\\gamma}_{X} = (0.10, 0.12, 0.08, -0.09, 0.15, -0.11, 0.07, 0.20, -0.13, 0.05, -0.16, 0.14),\n$$\n$$\n\\operatorname{se}(\\hat{\\gamma}_{X}) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02),\n$$\n$$\n\\hat{\\gamma}_{Y} = (0.052, 0.057, 0.041, -0.043, 0.079, -0.056, 0.057, 0.156, -0.101, 0.042, -0.132, 0.115),\n$$\n$$\n\\operatorname{se}(\\hat{\\gamma}_{Y}) = (0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03).\n$$\n在这种情况下，有 $6$ 个变异（前 $6$ 个条目）是有效的，有 $6$ 个变异（后 $6$ 个条目）是无效的。\n\n- 案例 C（恰好 $50\\%$ 的工具变量无效，其中一个是对暴露的极弱工具变量）：$m = 12$ 且\n$$\n\\hat{\\gamma}_{X} = (0.02, 0.06, -0.07, 0.09, -0.05, 0.11, -0.10, 0.04, 0.13, -0.08, 0.03, 0.12),\n$$\n$$\n\\operatorname{se}(\\hat{\\gamma}_{X}) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02),\n$$\n$$\n\\hat{\\gamma}_{Y} = (0.011, 0.047, -0.034, 0.0655, -0.026, 0.0855, -0.048, 0.029, 0.062, -0.058, 0.016, 0.086),\n$$\n$$\n\\operatorname{se}(\\hat{\\gamma}_{Y}) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02).\n$$\n在这种情况下，根据构造，有 $6$ 个变异是有效的，有 $6$ 个变异是无效的；第一个条目包含一个非常弱的暴露关联 $\\hat{\\gamma}_{X,1} = 0.02$。\n\n您的程序应生成单行输出，其中包含三个案例的结果，格式为逗号分隔的列表的列表，形式如下\n$$\n\\big[\\,[\\hat{\\beta}_{\\mathrm{IVW}}^{(A)}, \\hat{\\beta}_{\\mathrm{WM}}^{(A)}, \\hat{\\beta}_{\\mathrm{mode}}^{(A)}],\\; [\\hat{\\beta}_{\\mathrm{IVW}}^{(B)}, \\hat{\\beta}_{\\mathrm{WM}}^{(B)}, \\hat{\\beta}_{\\mathrm{mode}}^{(B)}],\\; [\\hat{\\beta}_{\\mathrm{IVW}}^{(C)}, \\hat{\\beta}_{\\mathrm{WM}}^{(C)}, \\hat{\\beta}_{\\mathrm{mode}}^{(C)}] \\big],\n$$\n每个数值都四舍五入到恰好 $4$ 位小数。不应打印任何额外文本。角度和物理单位在此不适用。所有数值结果必须以上述列表的列表格式，以十进制浮点数报告。", "solution": "该问题陈述经验证具有科学依据、定义明确且客观。它提出了孟德尔随机化 (MR) 领域内的一个标准计算任务，而孟德尔随机化是统计遗传学和流行病学中一种公认的方法。所有必要的数据、数学定义和数值参数均已提供，使得问题自洽且无歧义。所定义的估计量——反方差加权 (IVW)、加权中位数和加权众数——在 MR 文献中都是标准方法。提供的数值数据对于来自全基因组关联研究的汇总统计数据是符合实际的。因此，我们着手解决该问题。\n\n任务是使用来自 $m$ 个独立遗传变异的汇总数据，计算暴露对结局的因果效应的三种不同估计量，这些遗传变异充当工具变量。对于每个变异 $i \\in \\{1, \\dots, m\\}$，我们都获得了与暴露的关联估计值 $\\hat{\\gamma}_{X,i}$、其标准误 $\\operatorname{se}(\\hat{\\gamma}_{X,i})$、与结局的关联估计值 $\\hat{\\gamma}_{Y,i}$ 及其标准误 $\\operatorname{se}(\\hat{\\gamma}_{Y,i})$。\n\n首先，我们为每个变异 $i$ 计算两个关键量：因果效应的比率估计值 $\\hat{\\beta}_i$ 及其对应的反方差权重 $w_i$。\n\n比率估计值是变异-结局关联与变异-暴露关联的比值：\n$$\n\\hat{\\beta}_i = \\frac{\\hat{\\gamma}_{Y,i}}{\\hat{\\gamma}_{X,i}}\n$$\n该估计值表示由变异 $i$ 作为工具变量所估计的暴露对结局的因果效应。\n\n此比率估计值的方差可以使用德尔塔方法进行近似。在双样本 MR 且无样本重叠的假设下，$\\hat{\\gamma}_{X,i}$ 和 $\\hat{\\gamma}_{Y,i}$ 之间的协方差为零。此外，我们可以忽略分母 $\\hat{\\gamma}_{X,i}$ 中的不确定性（即暴露的“无测量误差”或 NOME 假设），当变异-暴露关联很强时，这是一种常见的简化方法。这导致了近似方差：\n$$\n\\operatorname{Var}(\\hat{\\beta}_i) \\approx \\frac{\\operatorname{Var}(\\hat{\\gamma}_{Y,i})}{\\gamma_{X,i}^2} = \\frac{\\operatorname{se}(\\hat{\\gamma}_{Y,i})^2}{\\gamma_{X,i}^2}\n$$\n用其估计值 $\\hat{\\gamma}_{X,i}$ 替换真实效应 $\\gamma_{X,i}$，得到比率估计值的估计标准误：\n$$\n\\hat{\\sigma}_{\\beta_i} = \\frac{\\operatorname{se}(\\hat{\\gamma}_{Y,i})}{|\\hat{\\gamma}_{X,i}|}\n$$\n使用绝对值以确保标准误为正。每个比率估计值的反方差权重是其估计方差的倒数：\n$$\nw_i = \\frac{1}{\\hat{\\sigma}_{\\beta_i}^2} = \\left( \\frac{|\\hat{\\gamma}_{X,i}|}{\\operatorname{se}(\\hat{\\gamma}_{Y,i})} \\right)^2\n$$\n这些权重反映了每个单独比率估计值的精度。\n\n为所有 $m$ 个变异计算出 $\\hat{\\beta}_i$ 和 $w_i$ 后，我们现在可以定义并计算所需的三种估计量。\n\n1.  **反方差加权 (IVW) 估计量**\n    IVW 估计量 $\\hat{\\beta}_{\\mathrm{IVW}}$ 是单个比率估计值 $\\hat{\\beta}_i$ 的加权平均值，权重为 $w_i$：\n    $$\n    \\hat{\\beta}_{\\mathrm{IVW}} = \\frac{\\sum_{i=1}^m w_i \\hat{\\beta}_i}{\\sum_{i=1}^m w_i}\n    $$\n    在所有变异都是有效工具变量且不存在水平多效性（或任何多效性在零附近平衡）的假设下，该估计量是统计有效的。它等价于将 $\\hat{\\gamma}_{Y,i}$ 对 $\\hat{\\gamma}_{X,i}$ 进行加权线性回归，且截距约束为零时得到的斜率。\n\n2.  **加权中位数估计量**\n    当相当一部分（最多 $50\\%$）的遗传变异是无效工具变量（即表现出水平多效性）时，加权中位数估计量 $\\hat{\\beta}_{\\mathrm{WM}}$ 提供了一个稳健的估计。计算过程如下：\n    首先，将比率估计值 $\\hat{\\beta}_i$ 按非递减顺序排序，得到 $(\\hat{\\beta}_{(1)}, \\dots, \\hat{\\beta}_{(m)})$。相应的权重 $(w_{(1)}, \\dots, w_{(m)})$ 也进行一致的排列。\n    其次，计算总权重 $W = \\sum_{i=1}^m w_i$。\n    第三，我们找到最小的索引 $k$，使得截至该索引的归一化权重累积和至少为 $0.5$。形式上，我们寻找 $\\hat{\\beta}_{(k)}$，其中：\n    $$\n    \\sum_{j=1}^{k-1} \\frac{w_{(j)}}{W}  0.5 \\le \\sum_{j=1}^{k} \\frac{w_{(j)}}{W}\n    $$\n    加权中位数估计值即为 $\\hat{\\beta}_{\\mathrm{WM}} = \\hat{\\beta}_{(k)}$。该算法涉及按 $\\hat{\\beta}_i$ 对 $(\\hat{\\beta}_i, w_i)$ 对进行排序，并确定累积归一化权重首次达到或超过 $0.5$ 时的值。\n\n3.  **加权众数估计量**\n    加权众数估计量 $\\hat{\\beta}_{\\mathrm{mode}}$ 将因果效应确定为单个比率估计值分布的众数，并按其精度进行加权。当最大的一组变异是有效的工具变量时，即使它们不构成多数，这种方法也特别有用。众数是通过找到 $\\hat{\\beta}_i$ 值的加权核密度估计的最大值来估计的。对于给定的带宽 $h  0$，加权高斯核得分函数 $S_h(b)$ 定义为：\n    $$\n    S_h(b) = \\sum_{i=1}^m w_i \\phi_h(b - \\hat{\\beta}_i) = \\sum_{i=1}^m w_i \\exp\\left(-\\frac{(b - \\hat{\\beta}_i)^2}{2 h^2}\\right)\n    $$\n    其中问题简化了高斯核的归一化因子。估计量是使该得分最大化的 $b$ 值：\n    $$\n    \\hat{\\beta}_{\\mathrm{mode}}(h) = \\operatorname*{arg\\,max}_{b \\in \\mathbb{R}} S_h(b)\n    $$\n    为了进行数值计算，此最大化通过网格搜索来执行。我们使用指定的带宽 $h = 0.06$。在区间 $[\\min_i \\hat{\\beta}_i - 0.2, \\max_i \\hat{\\beta}_i + 0.2]$ 上构建一个包含 $20001$ 个点的均匀网格。在此网格的每个点上计算得分 $S_h(b)$，并将产生最大得分的 $b$ 值作为估计值 $\\hat{\\beta}_{\\mathrm{mode}}$。\n\n该程序为所提供的每个测试用例实现了这三种估计量的计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes IVW, Weighted Median, and Weighted Mode estimators for Mendelian Randomization.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            \"gamma_x\": np.array([0.10, 0.12, 0.08, -0.09, 0.15, -0.11, 0.07, 0.20, -0.13, 0.05, -0.16, 0.14]),\n            \"se_gamma_x\": np.full(12, 0.02),\n            \"gamma_y\": np.array([0.053, 0.056, 0.042, -0.044, 0.080, -0.057, 0.038, 0.094, -0.062, 0.026, -0.084, 0.072]),\n            \"se_gamma_y\": np.full(12, 0.02),\n        },\n        # Case B\n        {\n            \"gamma_x\": np.array([0.10, 0.12, 0.08, -0.09, 0.15, -0.11, 0.07, 0.20, -0.13, 0.05, -0.16, 0.14]),\n            \"se_gamma_x\": np.full(12, 0.02),\n            \"gamma_y\": np.array([0.052, 0.057, 0.041, -0.043, 0.079, -0.056, 0.057, 0.156, -0.101, 0.042, -0.132, 0.115]),\n            \"se_gamma_y\": np.array([0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03]),\n        },\n        # Case C\n        {\n            \"gamma_x\": np.array([0.02, 0.06, -0.07, 0.09, -0.05, 0.11, -0.10, 0.04, 0.13, -0.08, 0.03, 0.12]),\n            \"se_gamma_x\": np.full(12, 0.02),\n            \"gamma_y\": np.array([0.011, 0.047, -0.034, 0.0655, -0.026, 0.0855, -0.048, 0.029, 0.062, -0.058, 0.016, 0.086]),\n            \"se_gamma_y\": np.full(12, 0.02),\n        }\n    ]\n\n    H_BANDWIDTH = 0.06\n    MODE_GRID_POINTS = 20001\n    \n    all_results = []\n\n    for case in test_cases:\n        gamma_x = case[\"gamma_x\"]\n        gamma_y = case[\"gamma_y\"]\n        se_gamma_y = case[\"se_gamma_y\"]\n\n        # Calculate ratio estimates and weights\n        beta_hat = gamma_y / gamma_x\n        w = (np.abs(gamma_x) / se_gamma_y)**2\n\n        # 1. Inverse-variance weighted (IVW) estimator\n        ivw_est = np.sum(w * beta_hat) / np.sum(w)\n\n        # 2. Weighted median estimator\n        sorted_indices = np.argsort(beta_hat)\n        beta_hat_sorted = beta_hat[sorted_indices]\n        w_sorted = w[sorted_indices]\n        \n        total_weight = np.sum(w)\n        w_cumsum_norm = np.cumsum(w_sorted) / total_weight\n        \n        median_index = np.where(w_cumsum_norm >= 0.5)[0][0]\n        wm_est = beta_hat_sorted[median_index]\n        \n        # 3. Weighted mode estimator\n        b_min = np.min(beta_hat) - 0.2\n        b_max = np.max(beta_hat) + 0.2\n        b_grid = np.linspace(b_min, b_max, num=MODE_GRID_POINTS)\n\n        # Vectorized calculation of scores S_h(b)\n        b_grid_reshaped = b_grid[:, np.newaxis]\n        diff_sq = (b_grid_reshaped - beta_hat)**2\n        h_sq = 2 * H_BANDWIDTH**2\n        scores = np.sum(w * np.exp(-diff_sq / h_sq), axis=1)\n        \n        mode_est = b_grid[np.argmax(scores)]\n\n        all_results.append([ivw_est, wm_est, mode_est])\n\n    # Format the final output string as a list of lists with 4 decimal places\n    output_str_parts = []\n    for res in all_results:\n        inner_list_str = f\"[{res[0]:.4f}, {res[1]:.4f}, {res[2]:.4f}]\"\n        output_str_parts.append(inner_list_str)\n    \n    final_output_str = f\"[{', '.join(output_str_parts)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2404047"}]}