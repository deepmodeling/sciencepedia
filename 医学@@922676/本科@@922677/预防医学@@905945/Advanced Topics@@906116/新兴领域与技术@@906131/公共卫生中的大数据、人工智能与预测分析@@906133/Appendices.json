{"hands_on_practices": [{"introduction": "大数据并不总是意味着完美数据，自我报告的数据尤其容易出现系统性偏差。例如，“数字偏好”（即将数值四舍五入到以0或5结尾）是一种常见的数据“堆积”现象，它会扭曲数据分布。这项蒙特卡洛模拟练习将帮助您理解这种偏差如何导致个体在关键临床阈值（如肥胖的BMI临界值）附近被错误分类，并量化其对公共卫生统计数据的影响 [@problem_id:4506110]。", "problem": "要求您建立一个蒙特卡洛模拟，以量化在一个大型合成人口中，自我报告的体重测量中的数字偏好和数据堆积如何扭曲基于身体质量指数（BMI）的肥胖患病率估计。在预防医学和公共卫生分析中，身体质量指数（BMI）定义为 $ \\mathrm{BMI} = \\dfrac{W}{H^2} $，其中 $ W $ 是以千克（$ \\mathrm{kg} $）为单位的体重，$ H $ 是以米（$ \\mathrm{m} $）为单位的身高。当 $ \\mathrm{BMI} \\geq 30 $ 时被归为肥胖（单位为 $ \\mathrm{kg}/\\mathrm{m}^2 $，尽管在分析中该比率是无量纲的）。该任务要求模拟称为数字偏好和数据堆积的测量偏差，其中自我报告的体重会优先四舍五入到特定的数字（例如，以 $ 0 $ 或 $ 5 $ 结尾的体重），从而使一些个体跨越肥胖阈值，并改变患病率的估计。\n\n从 $ \\mathrm{BMI} $ 的基本定义、患病率作为人口中满足特定标准的个体比例的概念，以及数据堆积将体重转换到偏好值的离散格点上的概念出发。生成一个合成人口，并以严格的单位计算以下内容：真实肥胖患病率（以小数表示）、自我报告体重经过数据堆积后的观测肥胖患病率、绝对误差（以小数表示）以及相对误差（绝对误差除以真实患病率，以小数表示）。\n\n人口生成过程：\n- 身高 $ H $ 服从在 $ [1.5, 2.0] $ 米上的截断正态分布，均值为 $ 1.70 $，标准差为 $ 0.10 $。所有身高必须以 $ \\mathrm{m} $ 为单位。\n- 真实BMI值服从在 $ [16, 60] $ 上的截断正态分布（无量纲），具有特定案例的均值 $ \\mu_{\\mathrm{BMI}} $ 和标准差 $ \\sigma_{\\mathrm{BMI}} $。\n- 真实体重计算为 $ W_{\\mathrm{true}} = \\mathrm{BMI}_{\\mathrm{true}} \\times H^2 $，单位为 $ \\mathrm{kg} $。\n\n数据堆积模型：\n- 以概率 $ p $，自我报告的体重 $ W_{\\mathrm{reported}} $ 是一个堆积值，通过将 $ W_{\\mathrm{true}} $ 四舍五入到堆积步长 $ h $（单位为 $ \\mathrm{kg} $）的最近倍数计算得出，即将 $ W_{\\mathrm{true}} $ 映射到集合 $ \\{ k \\cdot h : k \\in \\mathbb{Z} \\} $ 中的最近值。\n- 以概率 $ 1 - p $，$ W_{\\mathrm{reported}} = W_{\\mathrm{true}} $。\n- 观测BMI使用 $ W_{\\mathrm{reported}} $，即 $ \\mathrm{BMI}_{\\mathrm{obs}} = \\dfrac{W_{\\mathrm{reported}}}{H^2} $。\n\n输出和单位：\n- 计算真实肥胖患病率，即 $ \\mathrm{BMI}_{\\mathrm{true}} \\geq 30 $ 的个体所占比例（小数，非百分比）。\n- 计算观测肥胖患病率，即 $ \\mathrm{BMI}_{\\mathrm{obs}} \\geq 30 $ 的个体所占比例（小数）。\n- 计算绝对误差，即观测患病率与真实患病率之间的绝对差值（小数）。\n- 计算相对误差，即绝对误差除以真实肥胖患病率（小数）。\n- 将所有报告的患病率和误差四舍五入到 $ 6 $ 位小数。\n\n测试套件：\n对于每个测试案例，使用指定的参数（人口大小 $ N $、$ \\mu_{\\mathrm{BMI}} $、$ \\sigma_{\\mathrm{BMI}} $、数据堆积概率 $ p $、堆积步长 $ h $（单位 $ \\mathrm{kg} $）以及随机种子）。身高分布参数在所有案例中均按上述规定固定。\n\n- 案例 $ 1 $（基线，无数据堆积）：$ N = 100000 $，$ \\mu_{\\mathrm{BMI}} = 29 $，$ \\sigma_{\\mathrm{BMI}} = 4 $，$ p = 0 $，$ h = 5 $ $ \\mathrm{kg} $，种子 $ 202311 $。\n- 案例 $ 2 $（中度堆积到 $ 5 $ $ \\mathrm{kg} $ 的倍数）：$ N = 100000 $，$ \\mu_{\\mathrm{BMI}} = 29 $，$ \\sigma_{\\mathrm{BMI}} = 4 $，$ p = 0.30 $，$ h = 5 $ $ \\mathrm{kg} $，种子 $ 202311 $。\n- 案例 $ 3 $（高度堆积到 $ 5 $ $ \\mathrm{kg} $ 的倍数）：$ N = 100000 $，$ \\mu_{\\mathrm{BMI}} = 29 $，$ \\sigma_{\\mathrm{BMI}} = 4 $，$ p = 0.70 $，$ h = 5 $ $ \\mathrm{kg} $，种子 $ 202311 $。\n- 案例 $ 4 $（高度堆积到更粗略的 $ 10 $ $ \\mathrm{kg} $ 的倍数）：$ N = 100000 $，$ \\mu_{\\mathrm{BMI}} = 29 $，$ \\sigma_{\\mathrm{BMI}} = 4 $，$ p = 0.70 $，$ h = 10 $ $ \\mathrm{kg} $，种子 $ 202311 $。\n- 案例 $ 5 $（接近阈值的BMI分布以放大跨越效应）：$ N = 100000 $，$ \\mu_{\\mathrm{BMI}} = 30 $，$ \\sigma_{\\mathrm{BMI}} = 2 $，$ p = 0.70 $，$ h = 5 $ $ \\mathrm{kg} $，种子 $ 202312 $。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果。每个测试案例的结果本身应是包含四个小数的列表，顺序为 $ [\\text{true\\_prev}, \\text{obs\\_prev}, \\text{abs\\_err}, \\text{rel\\_err}] $，四舍五入到 $ 6 $ 位小数，不含嵌入的空格。例如，输出必须类似于单行的 $ [[0.312345,0.310000,0.002345,0.007508],[\\dots]] $。", "solution": "用户提供了一个需要严谨科学和计算程序的问题陈述。根据我的职责，我将首先验证该问题陈述。\n\n### 步骤1：提取既定条件\n\n问题提供了以下定义、参数和过程：\n-   **身体质量指数（BMI）定义**：$ \\mathrm{BMI} = \\dfrac{W}{H^2} $，其中 $ W $ 是以千克（$ \\mathrm{kg} $）为单位的体重，$ H $ 是以米（$ \\mathrm{m} $）为单位的身高。\n-   **肥胖分类**：$ \\mathrm{BMI} \\geq 30 $。\n-   **人口生成**：\n    -   身高 $ H $：在区间 $ [1.5, 2.0] $ 米上的截断正态分布，均值为 $ 1.70 $，标准差为 $ 0.10 $。\n    -   真实BMI值 $ \\mathrm{BMI}_{\\mathrm{true}} $：在区间 $ [16, 60] $ 上的截断正态分布，具有特定案例的均值 $ \\mu_{\\mathrm{BMI}} $ 和标准差 $ \\sigma_{\\mathrm{BMI}} $。\n    -   真实体重 $ W_{\\mathrm{true}} $：计算为 $ W_{\\mathrm{true}} = \\mathrm{BMI}_{\\mathrm{true}} \\times H^2 $。\n-   **数据堆积模型**：\n    -   以概率 $ p $，报告的体重是堆积值：$ W_{\\mathrm{reported}} = h \\cdot \\text{round}(W_{\\mathrm{true}} / h) $，其中 $ h $ 是堆积步长。\n    -   以概率 $ 1 - p $，报告的体重是真实体重：$ W_{\\mathrm{reported}} = W_{\\mathrm{true}} $。\n    -   观测BMI计算为 $ \\mathrm{BMI}_{\\mathrm{obs}} = \\dfrac{W_{\\mathrm{reported}}}{H^2} $。\n-   **要求的输出**：\n    1.  真实肥胖患病率 ($ P_{\\mathrm{true}} $)：$ \\mathrm{BMI}_{\\mathrm{true}} \\geq 30 $ 的个体比例。\n    2.  观测肥胖患病率 ($ P_{\\mathrm{obs}} $)：$ \\mathrm{BMI}_{\\mathrm{obs}} \\geq 30 $ 的个体比例。\n    3.  绝对误差 ($ E_{\\mathrm{abs}} $)：$ |P_{\\mathrm{obs}} - P_{\\mathrm{true}}| $。\n    4.  相对误差 ($ E_{\\mathrm{rel}} $)：$ E_{\\mathrm{abs}} / P_{\\mathrm{true}} $。\n-   **格式化**：所有输出值四舍五入到 $ 6 $ 位小数。\n-   **测试套件**：\n    -   案例 $ 1 $：$ N = 100000 $，$ \\mu_{\\mathrm{BMI}} = 29 $，$ \\sigma_{\\mathrm{BMI}} = 4 $，$ p = 0 $，$ h = 5 $ $ \\mathrm{kg} $，种子 $ 202311 $。\n    -   案例 $ 2 $：$ N = 100000 $，$ \\mu_{\\mathrm{BMI}} = 29 $，$ \\sigma_{\\mathrm{BMI}} = 4 $，$ p = 0.30 $，$ h = 5 $ $ \\mathrm{kg} $，种子 $ 202311 $。\n    -   案例 $ 3 $：$ N = 100000 $，$ \\mu_{\\mathrm{BMI}} = 29 $，$ \\sigma_{\\mathrm{BMI}} = 4 $，$ p = 0.70 $，$ h = 5 $ $ \\mathrm{kg} $，种子 $ 202311 $。\n    -   案例 $ 4 $：$ N = 100000 $，$ \\mu_{\\mathrm{BMI}} = 29 $，$ \\sigma_{\\mathrm{BMI}} = 4 $，$ p = 0.70 $，$ h = 10 $ $ \\mathrm{kg} $，种子 $ 202311 $。\n    -   案例 $ 5 $：$ N = 100000 $，$ \\mu_{\\mathrm{BMI}} = 30 $，$ \\sigma_{\\mathrm{BMI}} = 2 $，$ p = 0.70 $，$ h = 5 $ $ \\mathrm{kg} $，种子 $ 202312 $。\n\n### 步骤2：使用提取的既定条件进行验证\n\n根据验证标准对问题进行评估。\n\n-   **科学依据**：该问题在生物统计学和公共卫生领域有充分的依据。BMI和肥胖的定义是标准的。数字偏好和数据堆积现象是调查数据中一个公认的问题。使用截断正态分布来模拟身高和BMI等生物学参数是一种标准且恰当的统计实践。\n-   **适定性**：问题是完全指定的。它为分布（$ \\mu, \\sigma $, 截断边界）、数据堆积模型（$ p, h $）、人口大小（$ N $）和用于可复现性的随机种子提供了所有必要的参数。这确保了可以计算出唯一且稳定的解。\n-   **客观性**：问题使用精确、客观的语言和量化定义陈述。没有主观或模糊的术语。\n\n该问题不具有任何列出的无效性缺陷。它不是科学上不合理、不可形式化、不完整、不现实或不适定的。这是一个实质性的计算问题，而不是一个微不足道的问题。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。将开发一个解决方案。\n\n### 解决方案\n\n目标是执行一个蒙特卡洛模拟，以量化自我报告体重数据堆积对肥胖患病率估计的影响。该模拟将针对多个测试案例执行，对于每个案例，我们将计算真实患病率、观测患病率以及由此产生的误差。\n\n对于每个测试案例，解决方案分四个阶段进行：人口生成、数据堆积模拟、患病率计算和误差计算。\n\n**阶段1：合成人口生成**\n\n生成一个大小为 $ N $ 的合成人口。为了确保可复现性，对随机数生成器进行播种。\n\n首先，从一个截断正态分布中抽取一个包含 $ N $ 个身高的向量 $ \\mathbf{H} $。该分布的均值为 $ \\mu_H = 1.70 \\ \\mathrm{m} $，标准差为 $ \\sigma_H = 0.10 \\ \\mathrm{m} $，截断区间为 $ [1.5, 2.0] \\ \\mathrm{m} $。该分布的标准化边界为 $ a_H = (1.5 - 1.70) / 0.10 = -2.0 $ 和 $ b_H = (2.0 - 1.70) / 0.10 = 3.0 $。\n\n其次，从另一个截断正态分布中抽取一个包含 $ N $ 个真实BMI值的向量 $ \\mathbf{BMI}_{\\mathrm{true}} $。该分布由特定案例的均值 $ \\mu_{\\mathrm{BMI}} $ 和标准差 $ \\sigma_{\\mathrm{BMI}} $ 定义，并截断在区间 $ [16, 60] $ 内。标准化边界为 $ a_{\\mathrm{BMI}} = (16 - \\mu_{\\mathrm{BMI}}) / \\sigma_{\\mathrm{BMI}} $ 和 $ b_{\\mathrm{BMI}} = (60 - \\mu_{\\mathrm{BMI}}) / \\sigma_{\\mathrm{BMI}} $。\n\n第三，使用重新排列的BMI公式，根据身高和真实BMI计算出真实体重向量 $ \\mathbf{W}_{\\mathrm{true}} $（单位为 $ \\mathrm{kg} $）。这是一个逐元素操作：\n$$ \\mathbf{W}_{\\mathrm{true}} = \\mathbf{BMI}_{\\mathrm{true}} \\circ \\mathbf{H}^2 $$\n其中 $ \\circ $ 表示哈达玛（逐元素）乘积。\n\n**阶段2：数据堆积模拟**\n\n数据堆积模型模拟了自我报告体重中的测量误差。对于合成人口中的每个个体，随机决定其体重是否被“堆积”。\n\n从 $ [0, 1) $ 上的均匀分布中抽取一个包含 $ N $ 个随机数的向量 $ \\mathbf{u} $。创建一个布尔掩码 $ \\mathbf{M} $，如果 $ u_i  p $，则第 $ i $ 个元素 $ M_i $ 为真，否则为假。平均而言，人口中将有比例为 $ p $ 的个体的体重被堆积。\n\n对于 $ M_i $ 为真的个体，其报告体重 $ W_{\\mathrm{reported}, i} $ 是通过将其真实体重 $ W_{\\mathrm{true}, i} $ 四舍五入到堆积步长 $ h $ 的最近倍数来计算的。四舍五入函数由下式给出：\n$$ \\text{heap}(W, h) = h \\times \\text{round} \\left( \\frac{W}{h} \\right) $$\n其中 $ \\text{round}(\\cdot) $ 四舍五入到最近的整数（0.5则舍入到最近的偶数整数，这是一种标准的无偏选择）。对于 $ M_i $ 为假的个体，$ W_{\\mathrm{reported}, i} = W_{\\mathrm{true}, i} $。\n这可以为整个向量 $ \\mathbf{W}_{\\mathrm{reported}} $ 紧凑地表示。\n\n**阶段3：患病率计算**\n\n有了真实数据和报告数据，我们可以计算各自的肥胖患病率。肥胖阈值为 $ \\mathrm{BMI} \\geq 30 $。\n\n真实肥胖患病率 $ P_{\\mathrm{true}} $ 是人口中真实BMI达到或超过阈值的比例：\n$$ P_{\\mathrm{true}} = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbb{I}(\\mathrm{BMI}_{\\mathrm{true}, i} \\geq 30) $$\n其中 $ \\mathbb{I}(\\cdot) $ 是指示函数，如果条件为真，则为 $ 1 $，否则为 $ 0 $。\n\n为了计算观测患病率，我们必须首先使用每个人的报告体重和真实身高来找到其观测BMI $ \\mathbf{BMI}_{\\mathrm{obs}} $：\n$$ \\mathbf{BMI}_{\\mathrm{obs}} = \\mathbf{W}_{\\mathrm{reported}} \\circ \\mathbf{H}^{-2} $$\n观测肥胖患病率 $ P_{\\mathrm{obs}} $ 则是人口中观测BMI达到或超过阈值的比例：\n$$ P_{\\mathrmobs} = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbb{I}(\\mathrm{BMI}_{\\mathrm{obs}, i} \\geq 30) $$\n\n**阶段4：误差计算**\n\n最后，使用两个误差指标来量化由数据堆积引入的失真。\n\n绝对误差 $ E_{\\mathrm{abs}} $ 是观测患病率与真实患病率之间的绝对差值：\n$$ E_{\\mathrm{abs}} = |P_{\\mathrm{obs}} - P_{\\mathrm{true}}| $$\n相对误差 $ E_{\\mathrm{rel}} $ 衡量的是绝对误差占真实患病率的比例：\n$$ E_{\\mathrm{rel}} = \\frac{E_{\\mathrm{abs}}}{P_{\\mathrm{true}}} $$\n如果 $ P_{\\mathrm{true}} $ 为 $ 0 $，则相对误差未定义；但是，根据给定的问题参数，这种情况预计不会发生。所有四个结果指标（$ P_{\\mathrm{true}}, P_{\\mathrm{obs}}, E_{\\mathrm{abs}}, E_{\\mathrm{rel}} $）都按要求四舍五入到 $ 6 $ 位小数。对每个测试案例重复整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import truncnorm\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # (N, mu_bmi, sigma_bmi, p, h, seed)\n        (100000, 29, 4, 0, 5, 202311),\n        (100000, 29, 4, 0.30, 5, 202311),\n        (100000, 29, 4, 0.70, 5, 202311),\n        (100000, 29, 4, 0.70, 10, 202311),\n        (100000, 30, 2, 0.70, 5, 202312),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        all_results.append(result)\n\n    # Format the final output string as specified: [[r1_1,r1_2,...],[r2_1,r2_2,...],...]\n    # No extra spaces are introduced by this formatting method.\n    result_strings = [\n        f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        for res in all_results\n    ]\n    print(f\"[{','.join(result_strings)}]\")\n\ndef run_simulation(N, mu_bmi, sigma_bmi, p, h, seed):\n    \"\"\"\n    Performs the Monte Carlo simulation for a single test case.\n\n    Args:\n        N (int): Population size.\n        mu_bmi (float): Mean of the BMI distribution.\n        sigma_bmi (float): Standard deviation of the BMI distribution.\n        p (float): Probability of heaping.\n        h (float): Heaping step in kg.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        list: A list containing [true_prev, obs_prev, abs_err, rel_err],\n              each rounded to 6 decimal places.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    obesity_threshold = 30.0\n\n    # Stage 1: Synthetic Population Generation\n    # Generate Heights (H) from a truncated normal distribution\n    h_mean, h_std = 1.70, 0.10\n    h_min, h_max = 1.5, 2.0\n    a_h = (h_min - h_mean) / h_std\n    b_h = (h_max - h_mean) / h_std\n    heights = truncnorm.rvs(a_h, b_h, loc=h_mean, scale=h_std, size=N, random_state=rng)\n\n    # Generate true BMI values from a truncated normal distribution\n    bmi_min, bmi_max = 16.0, 60.0\n    a_bmi = (bmi_min - mu_bmi) / sigma_bmi\n    b_bmi = (bmi_max - mu_bmi) / sigma_bmi\n    bmi_true = truncnorm.rvs(a_bmi, b_bmi, loc=mu_bmi, scale=sigma_bmi, size=N, random_state=rng)\n\n    # Calculate true weights\n    w_true = bmi_true * (heights ** 2)\n\n    # Stage 2: Heaping Simulation\n    # Determine which individuals will have heaped weights\n    heap_mask = rng.random(size=N)  p\n\n    # Calculate reported weights\n    w_reported = np.copy(w_true)\n    weights_to_heap = w_reported[heap_mask]\n    heaped_values = h * np.round(weights_to_heap / h)\n    w_reported[heap_mask] = heaped_values\n    \n    # Stage 3: Prevalence Calculation\n    # True prevalence\n    true_obese_count = np.sum(bmi_true >= obesity_threshold)\n    true_prevalence = true_obese_count / N\n\n    # Observed BMI and prevalence\n    bmi_obs = w_reported / (heights ** 2)\n    obs_obese_count = np.sum(bmi_obs >= obesity_threshold)\n    observed_prevalence = obs_obese_count / N\n\n    # Stage 4: Error Computation\n    absolute_error = np.abs(observed_prevalence - true_prevalence)\n    \n    # Avoid division by zero if true_prevalence is 0\n    if true_prevalence == 0:\n        relative_error = 0.0\n    else:\n        relative_error = absolute_error / true_prevalence\n        \n    # Round all results to 6 decimal places\n    return [\n        round(true_prevalence, 6),\n        round(observed_prevalence, 6),\n        round(absolute_error, 6),\n        round(relative_error, 6),\n    ]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "4506110"}, {"introduction": "一个预测模型可能很准确，但它对于制定决策真的有用吗？决策曲线分析（Decision Curve Analysis, DCA）通过权衡真阳性的收益与假阳性的危害，帮助我们评估模型的临床或政策效用。这项练习将挑战您超越传统的分类指标，推导出能够最大化人群“净收益”的最佳决策阈值，从而将预测分析与公共卫生影响直接联系起来 [@problem_id:4506189]。", "problem": "一个公共卫生部门正在部署一个人工智能（AI）风险模型，以支持旨在减少动脉粥样硬化性心血管疾病（Atherosclerotic Cardiovascular Disease, ASCVD）事件的启用他汀类药物的预防医学政策。该模型输出一个个体在10年内发生ASCVD事件的校准概率 $p \\in [0,1]$。在一个目标筛查队列中，疾病患病率为 $\\pi = 0.20$。对于将要发生ASCVD事件的个体（患病者，$Y=1$），其预测风险的分布可以很好地用形状参数为 $(2,1)$ 的贝塔分布来近似；而对于不会发生事件的个体（非患病者，$Y=0$），其预测风险的分布则可以用形状参数为 $(1,2)$ 的贝塔分布来近似。也就是说，对于 $Y=1$，当 $p \\in [0,1]$ 时，其密度函数为 $f_{1}(p) = 2p$；而对于 $Y=0$，当 $p \\in [0,1]$ 时，其密度函数为 $f_{0}(p) = 2(1-p)$。\n\n为了制定群体层面的政策决策，该部门将对所有预测风险达到或超过某个阈值 $c \\in [0,1]$ 的个体启用他汀类药物治疗。定义正确治疗一个将要发生ASCVD事件的患者所带来的收益为 $B0$，而不必要地治疗一个不会发生ASCVD事件的个体所造成的危害为 $H0$。因此，假阳性造成的危害与真阳性带来的收益之比为 $\\lambda = H/B$。对于此队列，项目评估设定 $\\lambda = 0.05$。\n\n决策曲线分析（Decision Curve Analysis, DCA）将阈值为 $c$ 时的人均净收益定义为：真阳性带来的期望收益减去假阳性带来的期望危害，该结果经过人口规模归一化，并以 $B$ 为单位表示。请仅使用患病率、真阳性率和假阳性率的基本定义，以及 $\\lambda$、$H$ 和 $B$ 之间的关系，从第一性原理出发，推导出净收益作为 $c$ 的函数的解析表达式，并在给定的 $\\pi$、$\\lambda$ 和所述分布下，计算使该净收益最大化的阈值 $c^{\\ast}$。将最终阈值 $c^{\\ast}$ 以0到1之间的小数形式表示，并四舍五入至四位有效数字。", "solution": "用户提供了一个在尝试解答前需要验证的问题。\n\n### 步骤 1：提取已知条件\n-   **模型输出：** 10年期动脉粥样硬化性心血管疾病（ASCVD）事件的校准后个体概率 $p \\in [0,1]$。\n-   **疾病患病率：** $\\pi =_D P(Y=1) = 0.20$。\n-   **患病者（$Y=1$）的分布：** 概率密度函数为 $f_{1}(p) = 2p$，$p \\in [0,1]$。这是一个参数为 $(\\alpha, \\beta) = (2,1)$ 的贝塔分布。\n-   **非患病者（$Y=0$）的分布：** 概率密度函数为 $f_{0}(p) = 2(1-p)$，$p \\in [0,1]$。这是一个参数为 $(\\alpha, \\beta) = (1,2)$ 的贝塔分布。\n-   **决策规则：** 对预测风险 $p$ 大于或等于阈值 $c$ 的个体启用他汀类药物，即当 $p \\ge c$ 时。\n-   **真阳性收益：** $B  0$。\n-   **假阳性危害：** $H  0$。\n-   **相对危害/收益比：** $\\lambda = \\frac{H}{B} = 0.05$。\n-   **目标：** 推导净收益作为阈值 $c$ 的函数的解析表达式。\n-   **目标：** 计算使该净收益最大化的最优阈值 $c^{\\ast}$。\n-   **约束：** 仅使用基本定义并从第一性原理出发进行推导。\n-   **最终答案格式：** 将 $c^{\\ast}$ 表示为小数，并四舍五入至四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题牢固地建立在统计决策理论及其在医疗决策中的应用之上。决策曲线分析（DCA）是评估预测模型和临床指南的一种标准且经过验证的方法。使用贝塔分布来为概率建模是常见的做法。给定的患病率和相对危害在公共卫生背景下是现实的。\n2.  **问题的适定性：** 这是一个适定问题。所有必要信息——患病率、风险评分的条件分布、决策规则以及目标函数（净收益）——都已明确给出。在一个闭区间上最大化一个连续可微函数的目标确保了解的存在。\n3.  **客观性：** 问题以精确、定量和客观的语言陈述，没有歧义或主观论断。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。它在科学上是合理的，问题是适定的，并且是客观的。将按要求推导出解答。\n\n### 推导与求解\n\n目标是找到一个决策阈值 $c$，使得筛查和治疗策略的净收益最大化。\n\n首先，我们根据问题描述将净收益（Net Benefit, NB）形式化。净收益是指真阳性带来的期望收益减去假阳性带来的期望危害，经过人口规模归一化，并以收益单位 $B$ 表示。\n\n设 $TPR(c)$ 为真阳性率，即被正确识别需要治疗的患病个体（$Y=1$）的比例（其风险 $p \\ge c$）。设 $FPR(c)$ 为假阳性率，即被错误识别需要治疗的非患病个体（$Y=0$）的比例（其风险 $p \\ge c$）。\n\n在一个规模为 $N$ 的群体中，真阳性的总数为 $N \\cdot \\pi \\cdot TPR(c)$。总收益为 $N \\cdot \\pi \\cdot TPR(c) \\cdot B$。假阳性的总数为 $N \\cdot (1-\\pi) \\cdot FPR(c)$。总危害为 $N \\cdot (1-\\pi) \\cdot FPR(c) \\cdot H$。\n\n总净收益是总收益减去总危害：$N\\pi B \\cdot TPR(c) - N(1-\\pi)H \\cdot FPR(c)$。人均净收益是此数量除以 $N$：$\\pi B \\cdot TPR(c) - (1-\\pi)H \\cdot FPR(c)$。最后，将其以 $B$ 为单位表示（通过除以 $B$），得到决策曲线分析中净收益 $NB(c)$ 的标准公式：\n$$NB(c) = \\pi \\cdot TPR(c) - (1-\\pi) \\frac{H}{B} \\cdot FPR(c)$$\n使用给定的定义 $\\lambda = \\frac{H}{B}$，表达式变为：\n$$NB(c) = \\pi \\cdot TPR(c) - (1-\\pi)\\lambda \\cdot FPR(c)$$\n\n接下来，我们使用所提供的概率密度函数，从 $TPR(c)$ 和 $FPR(c)$ 的基本定义出发，推导它们的表达式。\n$TPR(c)$ 是患病个体风险评分 $p \\ge c$ 的概率。\n$$TPR(c) = P(p \\ge c | Y=1) = \\int_{c}^{1} f_{1}(p) \\,dp$$\n给定 $f_{1}(p) = 2p$：\n$$TPR(c) = \\int_{c}^{1} 2p \\,dp = [p^2]_{c}^{1} = 1^2 - c^2 = 1 - c^2$$\n\n$FPR(c)$ 是非患病个体风险评分 $p \\ge c$ 的概率。\n$$FPR(c) = P(p \\ge c | Y=0) = \\int_{c}^{1} f_{0}(p) \\,dp$$\n给定 $f_{0}(p) = 2(1-p)$：\n$$FPR(c) = \\int_{c}^{1} 2(1-p) \\,dp = 2\\left[p - \\frac{p^2}{2}\\right]_{c}^{1} = 2\\left( \\left(1 - \\frac{1}{2}\\right) - \\left(c - \\frac{c^2}{2}\\right) \\right) = 2\\left(\\frac{1}{2} - c + \\frac{c^2}{2}\\right) = 1 - 2c + c^2 = (1-c)^2$$\n\n现在，我们将 $TPR(c)$ 和 $FPR(c)$ 的这些表达式代入净收益方程。这就得到了净收益作为 $c$ 的函数的解析表达式：\n$$NB(c) = \\pi(1 - c^2) - (1-\\pi)\\lambda(1-c)^2$$\n为了找到使 $NB(c)$ 最大化的阈值 $c^{\\ast}$，我们对 $NB(c)$ 关于 $c$求导，并令其等于 $0$。\n$$\\frac{d(NB)}{dc} = \\frac{d}{dc} \\left[ \\pi(1 - c^2) - (1-\\pi)\\lambda(1-c)^2 \\right]$$\n$$\\frac{d(NB)}{dc} = \\pi(-2c) - (1-\\pi)\\lambda \\cdot 2(1-c)(-1)$$\n$$\\frac{d(NB)}{dc} = -2\\pi c + 2(1-\\pi)\\lambda(1-c)$$\n将导数设为零以找到临界点：\n$$-2\\pi c^{\\ast} + 2(1-\\pi)\\lambda(1-c^{\\ast}) = 0$$\n$$\\pi c^{\\ast} = (1-\\pi)\\lambda(1-c^{\\ast})$$\n$$\\pi c^{\\ast} = (1-\\pi)\\lambda - (1-\\pi)\\lambda c^{\\ast}$$\n现在，我们求解 $c^{\\ast}$：\n$$\\pi c^{\\ast} + (1-\\pi)\\lambda c^{\\ast} = (1-\\pi)\\lambda$$\n$$c^{\\ast}[\\pi + \\lambda(1-\\pi)] = \\lambda(1-\\pi)$$\n$$c^{\\ast} = \\frac{\\lambda(1-\\pi)}{\\pi + \\lambda(1-\\pi)}$$\n为了确认这是一个最大值，我们检查二阶导数：\n$$\\frac{d^2(NB)}{dc^2} = \\frac{d}{dc} [-2\\pi c + 2(1-\\pi)\\lambda(1-c)] = -2\\pi - 2(1-\\pi)\\lambda$$\n由于 $\\pi  0$，$(1-\\pi)  0$ 且 $\\lambda  0$，我们有 $-2\\pi  0$ 和 $-2(1-\\pi)\\lambda  0$。因此，$\\frac{d^2(NB)}{dc^2}  0$，这证实了临界点 $c^{\\ast}$ 对应一个局部最大值。由于这是区间 $(0,1)$ 内唯一的临界点，因此它也是全局最大值。\n\n最后，我们将给定的数值 $\\pi = 0.20$ 和 $\\lambda = 0.05$ 代入 $c^{\\ast}$ 的表达式中。\n$$c^{\\ast} = \\frac{0.05(1-0.20)}{0.20 + 0.05(1-0.20)}$$\n$$c^{\\ast} = \\frac{0.05(0.80)}{0.20 + 0.05(0.80)}$$\n$$c^{\\ast} = \\frac{0.04}{0.20 + 0.04}$$\n$$c^{\\ast} = \\frac{0.04}{0.24} = \\frac{4}{24} = \\frac{1}{6}$$\n将分数转换为小数得到 $c^{\\ast} = 0.16666...$。\n四舍五入到四位有效数字，我们得到 $c^{\\ast} \\approx 0.1667$。", "answer": "$$\\boxed{0.1667}$$", "id": "4506189"}]}