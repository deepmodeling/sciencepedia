{"hands_on_practices": [{"introduction": "基因组流行病学的核心是“分子钟”假说，即突变以相对恒定的速率累积。第一个练习将引导你推导一个基础公式，该公式将演化时间与两个病原体基因组之间的预期遗传差异数量联系起来，为追踪疫情传播提供了定量基础。[@problem_id:4527622]", "problem": "在一次克隆性细菌爆发中，两名患者在同一日历时间从一个共同来源感染，然后他们的感染在没有重组的情况下独立进化。两名患者在从共同来源分化后经过 $\\Delta t$ 的时间后，在同一调查时间进行取样。假设一个严格的分子钟，其每位点替换率为 $\\mu$（替换数/位点/年），核心基因组长度为 $L$ 个可调用位点，并且突变根据泊松过程在各位点上作为独立事件发生。从泊松过程的定义和期望的线性性出发，推导一个表达式，用于计算采样时两个基因组之间单核苷酸多态性（SNP）差异的期望数量，该表达式用 $\\mu$、$L$ 和 $\\Delta t$ 表示。陈述使您的表达式在用于疫情控制的基因组流行病学背景下成为有效近似的最小模型假设。然后，使用 $\\mu = 1.0 \\times 10^{-6}$ 替换数/位点/年，$L = 4.0 \\times 10^{6}$ 个位点，以及 $\\Delta t = 0.25$ 年，计算预期的 SNP 差异。将您的最终数值答案四舍五入到三位有效数字。将您的最终答案表示为一个纯数（无量纲计数）。", "solution": "问题陈述已经过验证，被认为是合理的。它具有科学依据，提法明确且客观。所有必要的参数和定义都已提供，它代表了基因组流行病学中一个可形式化的问题。\n\n问题要求推导从一个共同来源分化的两个细菌基因组之间单核苷酸多态性（SNP）差异的期望数量。\n\n让我们定义所提供的参数：\n- 每位点替换率为 $\\mu$，单位为替换数/位点/年。\n- 核心基因组长度为 $L$ 个可调用位点。\n- 从共同来源分化后经过的时间为 $\\Delta t$ 年。\n\n进化情景涉及两个谱系（在患者1和患者2中），它们从一个共同祖先分化而来。两个谱系都独立进化了 $\\Delta t$ 的时间。分隔两个采样基因组的总进化时间是两个分支回到它们最近共同祖先的长度之和。因此，区分这两个基因组的突变累积的总时间是 $T = \\Delta t + \\Delta t = 2\\Delta t$。\n\n问题陈述指出，突变根据泊松过程在各位点上作为独立事件发生。我们将首先考虑单个位点，位点 $i$，其中 $i$ 是从 $1$ 到 $L$ 的整数。\n\n在这个单位点的替换率是 $\\mu$。对于泊松过程，给定区间的速率参数 $\\lambda$ 是速率与区间长度的乘积。在这种情况下，区间是总进化时间 $T = 2\\Delta t$。因此，单个位点 $i$ 的替换数量的速率参数是 $\\lambda_{\\text{site}} = \\mu \\times T = 2\\mu\\Delta t$。\n\n设 $K_i$ 为表示在总进化时间 $T$ 内在位点 $i$ 发生的替换数量的随机变量。根据问题定义，$K_i$ 服从参数为 $\\lambda_{\\text{site}}$ 的泊松分布。\n$$ K_i \\sim \\text{Poisson}(2\\mu\\Delta t) $$\n服从泊松分布的随机变量的期望值等于其速率参数。因此，位点 $i$ 的预期替换数量为：\n$$ E[K_i] = 2\\mu\\Delta t $$\n现在，我们考虑长度为 $L$ 的整个基因组。设 $K_{\\text{total}}$ 为所有 $L$ 个位点上的总替换数量。由于不同位点的突变被假定为独立事件，$K_{\\text{total}}$ 是每个位点上替换数量的总和：\n$$ K_{\\text{total}} = \\sum_{i=1}^{L} K_i $$\n问题要求我们使用期望的线性性。应用这一原理，总替换数量的期望值是各个期望值的总和：\n$$ E[K_{\\text{total}}] = E\\left[\\sum_{i=1}^{L} K_i\\right] = \\sum_{i=1}^{L} E[K_i] $$\n由于假定替换率 $\\mu$ 在所有 $L$ 个位点上是均匀的，所以每个位点 $i$ 的期望值 $E[K_i]$ 都是相同的。\n$$ E[K_{\\text{total}}] = \\sum_{i=1}^{L} (2\\mu\\Delta t) = L(2\\mu\\Delta t) = 2\\mu L\\Delta t $$\n问题要求的是 SNP 差异的期望数量，我们将其表示为 $E[N_{\\text{SNP}}]$。一个位点上的 SNP 差异对应于该位点发生了一次或多次替换事件。总替换数量 $K_{\\text{total}}$ 与 SNP 差异数量 $N_{\\text{SNP}}$ 并不严格相同，因为在同一位点可能发生多次替换（这种事件被称为“多次命中”）。如果一个位点经历两次或更多次替换，它仍然只算作一个 SNP 差异。\n\n然而，在基因组流行病学中短期爆发的背景下，总进化时间 $T = 2\\Delta t$ 通常非常短，且突变率 $\\mu$ 很低。因此，单个位点的速率参数 $2\\mu\\Delta t$ 远小于 $1$。对于速率参数 $\\lambda$ 非常小的泊松过程，观察到两次或更多事件的概率 $P(k \\ge 2)$ 与观察到一次事件的概率 $P(k=1)$ 相比可以忽略不计。\n$P(k=0) = \\exp(-\\lambda) \\approx 1 - \\lambda$\n$P(k=1) = \\lambda \\exp(-\\lambda) \\approx \\lambda$\n$P(k=2) = \\frac{\\lambda^2}{2} \\exp(-\\lambda) \\approx \\frac{\\lambda^2}{2}$\n由于 $\\lambda \\ll 1$，我们有 $\\lambda^2 \\ll \\lambda$。因此，单个位点发生多次命中的概率可以忽略不计。\n\n在这个有效的近似下，至少有一次替换的位点数（$N_{\\text{SNP}}$）约等于总替换数（$K_{\\text{total}}$）。因此，它们的期望值也近似相等：\n$$ E[N_{\\text{SNP}}] \\approx E[K_{\\text{total}}] $$\n所以，推导出的 SNP 差异期望数量的表达式是：\n$$ E[N_{\\text{SNP}}] = 2\\mu L\\Delta t $$\n使该表达式成为有效近似的最小模型假设是：\n1.  **严格分子钟**：替换率 $\\mu$ 在时间和所有谱系中是恒定的。\n2.  **位点间速率一致**：替换率 $\\mu$ 对所有 $L$ 个基因组位点都是相同的。\n3.  **位点独立性**：不同位点上的替换是独立事件。\n4.  **泊松过程**：替换随时间的发生遵循泊松分布。\n5.  **克隆进化**：基因组在没有重组的情况下进化。\n6.  **罕见突变近似**：在时间段内同一位点发生多次替换的概率可以忽略不计（$2\\mu\\Delta t \\ll 1$），这使得 SNP 的期望数量可以用替换的期望数量来近似。\n\n最后，我们使用提供的数据计算数值：\n- $\\mu = 1.0 \\times 10^{-6}$ 替换数/位点/年\n- $L = 4.0 \\times 10^{6}$ 个位点\n- $\\Delta t = 0.25$ 年\n\n将这些值代入我们推导的表达式中：\n$$ E[N_{\\text{SNP}}] = 2 \\times (1.0 \\times 10^{-6}) \\times (4.0 \\times 10^{6}) \\times (0.25) $$\n$$ E[N_{\\text{SNP}}] = 2 \\times 1.0 \\times 4.0 \\times 0.25 \\times 10^{-6} \\times 10^{6} $$\n$$ E[N_{\\text{SNP}}] = (2 \\times 0.25) \\times 4.0 $$\n$$ E[N_{\\text{SNP}}] = 0.5 \\times 4.0 $$\n$$ E[N_{\\text{SNP}}] = 2.0 $$\n问题要求答案四舍五入到三位有效数字。因此，结果是 $2.00$。结果是一个无量纲的计数，因为单位抵消了：$(\\text{位点}^{-1} \\text{年}^{-1}) \\times (\\text{位点}) \\times (\\text{年})$。", "answer": "$$\n\\boxed{2.00}\n$$", "id": "4527622"}, {"introduction": "疫情应对中的一个关键挑战是区分近期的传播事件与社区中的背景传播。本练习将展示如何将分子演化原理转化为统计决策规则。你将确定一个最佳的单核苷酸多态性（SNP）阈值来对病例对进行分类，这是集中公共卫生干预措施的一项关键任务。[@problem_id:4527583]", "problem": "在预防医学的疫情控制中，基因组流行病学的一个核心决策问题是确定两个病例是由近期直接传播关联，还是无关的社区病例。考虑一种具有近似恒定分子钟的病原体，其突变过程由泊松突变过程建模：沿每个谱系的突变以每单位时间的恒定速率独立发生。假设以下有科学依据的事实作为推导基础：在分子钟下，突变随时间近似线性累积，并且沿独立谱系累积的单核苷酸多态性（SNP）数量由一个泊松过程描述，其均值与流逝的时间成正比。设每基因组的替换率为每年 $\\mu$ 次替换。对于一对样本，设总时间分支长度（从最近共同祖先到每个样本的时间总和）为 $L$，因此期望的 SNP 计数为 $\\lambda = \\mu \\times L$，观测到的成对 SNP 计数 $D$ 被建模为均值为 $\\lambda$ 的泊松随机变量。\n\n给定以下疫情背景，其参数选择对于一种快速演变的呼吸道病毒是符合实际的：\n\n- 每基因组替换率 $\\mu = 25$ 次替换/基因组/年。\n- 在直接传播情景中，两个病例在传播事件发生后 $t_{A} = 9$ 天和 $t_{B} = 14$ 天被采样。假设在直接传播下，最近共同祖先（MRCA）与传播事件重合，因此总分支长度为 $L_{\\mathrm{direct}} = t_{A} + t_{B}$，以天为单位。\n- 在无关社区情景中，两个病历的谱系平均在过去的 $T_{c} = 0.7$ 年前合并，这反映了传播群体中的背景多样性。在此情景下，总分支长度近似为 $L_{\\mathrm{unrelated}} = 2 T_{c} + \\frac{t_{A} + t_{B}}{365}$，以年为单位（即从 MRCA 到每个样本的时间总和，包括微小的宿主内采样延迟）。\n\n当基于观测到的 SNP 距离 $D$ 决定聚类成员资格时，假设“直接传播”和“无关社区”这两个假设具有相等的先验概率和相等的错分成本。使用泊松突变模型和这些假设，计算应设置决策边界的最佳整数 SNP 阈值 $d^{*}$，使得当 $D \\leq d^{*}$ 时，该对样本被归类为传播关联的聚类，而当 $D  d^{*}$ 时，则被归类为无关。请以单核苷酸多态性（SNP）的整数形式表示您的最终答案。除了根据决策规则取相应的整数外，不需要额外的四舍五入指令。在方框内的最终答案中不要包含单位。", "solution": "问题要求基于分隔一对病原体基因组的单核苷酸多态性（SNP）数量，找出一个最佳整数阈值，用于将其分类为直接传播关联或无关社区病例。这是一个统计决策理论中的经典二元假设检验问题。\n\n首先，我们根据所提供的信息将两个相互竞争的假设形式化。设 $D$ 为观测到的 SNP 数量，它是一个随机变量。\n-   假设 $H_0$：两个病例由直接传播关联。在此假设下，SNP 计数 $D$ 服从均值为 $\\lambda_0$ 的泊松分布，即 $D \\sim \\mathrm{Poisson}(\\lambda_0)$。\n-   假设 $H_1$：两个病例来自无关社区。在此假设下，SNP 计数 $D$ 服从均值为 $\\lambda_1$ 的泊松分布，即 $D \\sim \\mathrm{Poisson}(\\lambda_1)$。\n\n泊松分布的均值 $\\lambda$ 由每基因组替换率 $\\mu$ 和总时间分支长度 $L$ 的乘积给出。因此，$\\lambda = \\mu L$。我们必须使用给定的参数计算 $\\lambda_0$ 和 $\\lambda_1$，并确保单位一致。替换率为每年每基因组 $\\mu = 25$ 次替换。我们将所有时间间隔转换为年。一年中的天数取为 365。\n\n两个病例的采样时间为 $t_{A} = 9$ 天和 $t_{B} = 14$ 天。\n\n在假设 $H_0$（直接传播）下，总分支长度为 $L_{\\mathrm{direct}} = t_{A} + t_{B}$。\n$$L_{\\mathrm{direct}} = (9 + 14) \\text{ days} = 23 \\text{ days}$$\n将其转换为年：\n$$L_{\\mathrm{direct}} = \\frac{23}{365} \\text{ years}$$\n在 $H_0$ 下泊松分布的均值为：\n$$\\lambda_0 = \\mu \\times L_{\\mathrm{direct}} = 25 \\times \\frac{23}{365} = \\frac{575}{365} = \\frac{115}{73}$$\n\n在假设 $H_1$（无关社区）下，总分支长度由公式 $L_{\\mathrm{unrelated}} = 2 T_{c} + \\frac{t_{A} + t_{B}}{365}$ 给出，其中平均合并时间为 $T_c = 0.7$ 年。\n$$L_{\\mathrm{unrelated}} = 2 \\times 0.7 + \\frac{9+14}{365} = 1.4 + \\frac{23}{365} \\text{ years}$$\n在 $H_1$ 下泊松分布的均值为：\n$$\\lambda_1 = \\mu \\times L_{\\mathrm{unrelated}} = 25 \\times \\left(1.4 + \\frac{23}{365}\\right) = 25 \\times 1.4 + 25 \\times \\frac{23}{365}$$\n$$\\lambda_1 = 35 + \\lambda_0 = 35 + \\frac{115}{73} = \\frac{35 \\times 73 + 115}{73} = \\frac{2555 + 115}{73} = \\frac{2670}{73}$$\n\n问题陈述，我们对这两个假设有相等的先验概率（$P(H_0) = P(H_1) = 0.5$）和相等的错分成本。在这种情况下，贝叶斯最优决策规则是选择具有较高后验概率的假设，这简化为选择具有较高似然的假设。如果观测到 $D$ 在 $H_0$ 下的概率大于或等于在 $H_1$ 下的概率，我们应将观测值 $D$ 归类为“直接传播”聚类（$H_0$）。决策规则是如果 $P(D|H_0) \\ge P(D|H_1)$，则选择 $H_0$。\n\n均值为 $\\lambda$ 的泊松随机变量的概率质量函数为 $P(D=k) = \\frac{\\exp(-\\lambda) \\lambda^k}{k!}$。因此，我们的决策规则是：\n$$\\frac{\\exp(-\\lambda_0) \\lambda_0^D}{D!} \\ge \\frac{\\exp(-\\lambda_1) \\lambda_1^D}{D!}$$\n由于 $D!$ 是正数，我们可以消去它。\n$$\\exp(-\\lambda_0) \\lambda_0^D \\ge \\exp(-\\lambda_1) \\lambda_1^D$$\n对两边取自然对数：\n$$-\\lambda_0 + D \\ln(\\lambda_0) \\ge -\\lambda_1 + D \\ln(\\lambda_1)$$\n重新整理各项以解出 $D$：\n$$\\lambda_1 - \\lambda_0 \\ge D \\ln(\\lambda_1) - D \\ln(\\lambda_0)$$\n$$\\lambda_1 - \\lambda_0 \\ge D (\\ln(\\lambda_1) - \\ln(\\lambda_0))$$\n由于 $L_{\\mathrm{unrelated}} > L_{\\mathrm{direct}}$，因此 $\\lambda_1 > \\lambda_0$，所以 $\\ln(\\lambda_1) - \\ln(\\lambda_0) > 0$。我们可以用这一项相除而不改变不等式的方向：\n$$D \\le \\frac{\\lambda_1 - \\lambda_0}{\\ln(\\lambda_1) - \\ln(\\lambda_0)}$$\n我们定义临界值 $D_c = \\frac{\\lambda_1 - \\lambda_0}{\\ln(\\lambda_1) - \\ln(\\lambda_0)}$。规则是如果 $D \\le D_c$，则分类为 $H_0$。\n\n问题要求一个整数阈值 $d^*$，使得当 $D \\le d^*$ 时，一对样本被归类为传播关联的聚类。我们将 $D$ 分类为 $H_0$ 的整数值集合是 $\\{0, 1, \\dots, d^*\\}$。这意味着 $d^*$ 必须是满足条件 $d^* \\le D_c$ 的最大整数。因此，最佳整数阈值是 $d^* = \\lfloor D_c \\rfloor$。\n\n现在我们代入 $\\lambda_0$ 和 $\\lambda_1$ 的数值：\n$$\\lambda_0 = \\frac{115}{73} \\approx 1.5753$$\n$$\\lambda_1 = \\frac{2670}{73} \\approx 36.5753$$\n差值为 $\\lambda_1 - \\lambda_0 = 35$。\n比值为 $\\frac{\\lambda_1}{\\lambda_0} = \\frac{2670/73}{115/73} = \\frac{2670}{115} = \\frac{534}{23}$。\n\n我们计算 $D_c$：\n$$D_c = \\frac{\\lambda_1 - \\lambda_0}{\\ln(\\lambda_1/\\lambda_0)} = \\frac{35}{\\ln(534/23)}$$\n使用数值计算：\n$$D_c \\approx \\frac{35}{\\ln(23.21739...)} \\approx \\frac{35}{3.14490...} \\approx 11.1291$$\n最佳整数阈值 $d^*$ 是该值的向下取整：\n$$d^* = \\lfloor D_c \\rfloor = \\lfloor 11.1291 \\rfloor = 11$$\n\n因此，最佳决策边界在 11 个 SNP 处。如果观测到的 SNP 计数 $D$ 小于或等于 11，则该对样本被归类为直接传播。如果 $D$ 大于 11，则被归类为无关。", "answer": "$$\\boxed{11}$$", "id": "4527583"}, {"introduction": "现代疫情调查很少依赖单一数据源，其威力来自于综合分析。最后一个练习将挑战你实现一个聚类算法，该算法整合了基因组数据（SNP距离）和传统的流行病学数据（接触者关联）。通过构建和评估此算法，你将亲身体验在真实世界的突发公共卫生事件中所使用的多方面分析方法。[@problem_id:4527634]", "problem": "一个公共卫生团队正在利用基因组序列数据和接触者追踪数据，调查一次病原体暴发中的潜在传播簇。每个病例在图中由一个顶点表示。对于每个测试用例，您将获得一个两两配对的单核苷酸变异 (SNV) 距离的对称矩阵、一个对称的二进制流行病学关联矩阵，以及一个将病例划分为传播簇的真实情况划分（仅用于评估）。您的任务是设计、实现并评估一种算法，该算法整合序列相似性和流行病学关联来推断簇，并量化不相关病例被错误地归为一组的比率。\n\n基本定义与约束：\n- 两个病例之间的单核苷酸变异 (SNV) 距离是在一个可比较的基因组区域内核苷酸差异的数量；距离矩阵记为 $D \\in \\mathbb{N}^{n \\times n}$，其中对于所有 $i \\neq j$，有 $D_{ii} = 0$ 且 $D_{ij} = D_{ji}$。\n- 流行病学关联由一个对称二进制矩阵 $L \\in \\{0,1\\}^{n \\times n}$ 表示，其中 $L_{ii} = 0$ 且 $L_{ij} = L_{ji}$。$L_{ij} = 1$ 的值表示病例 $i$ 和 $j$ 之间存在与潜在传播一致的有记录的关联。\n- 设 $t_s \\in \\mathbb{N}$ 为一个严格的 SNV 阈值，$t_e \\in \\mathbb{N}$ 为一个流行病学上宽松的 SNV 阈值，且 $t_s \\leq t_e$。\n\n使用的原则：\n- 在基因组流行病学中，亲缘关系密切的基因组（SNV 距离小）和佐证的流行病学关联都支持近期发生了传播。通过构建一个包含 $n$ 个顶点的无向图 $G$ 来对此建模，其中顶点 $i$ 和 $j$ 之间存在一条边，当且仅当满足以下任一条件：\n  1. $D_{ij} \\leq t_s$，或\n  2. $L_{ij} = 1$ 且 $D_{ij} \\leq t_e$。\n- 将 $G$ 的连通分量推断为簇。\n\n要计算的评估指标：\n- 设真实情况以集合 $\\{0,1,\\dots,n-1\\}$ 的一个划分为形式给出，该划分导出一个对称矩阵 $T \\in \\{0,1\\}^{n \\times n}$，其中 $T_{ij} = 1$ 当且仅当 $i$ 和 $j$ 在同一个真实簇中且 $i \\neq j$，并且 $T_{ii} = 0$。\n- 设 $\\widehat{C}$ 为推断出的聚类。定义推断阳性对的集合为 $\\mathcal{P} = \\{(i,j) : 0 \\leq i  j \\leq n-1, \\text{ 且 } i,j \\text{ 在 } G \\text{ 的同一个连通分量中}\\}$。\n- 定义真阳性数量为 $\\mathrm{TP} = \\sum_{(i,j) \\in \\mathcal{P}} \\mathbf{1}\\{T_{ij} = 1\\}$，假阳性数量为 $\\mathrm{FP} = \\sum_{(i,j) \\in \\mathcal{P}} \\mathbf{1}\\{T_{ij} = 0\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n- 错误聚类率（以小数表示）定义为\n$$\n\\mathrm{FCR} =\n\\begin{cases}\n\\dfrac{\\mathrm{FP}}{\\mathrm{TP} + \\mathrm{FP}},  \\text{if } \\mathrm{TP} + \\mathrm{FP} > 0, \\\\\n0,  \\text{if } \\mathrm{TP} + \\mathrm{FP} = 0.\n\\end{cases}\n$$\n\n实现一个程序，对下面的每个测试用例，使用给定的阈值和上述决策规则构建图 $G$，并返回错误聚类率。所有输出必须是四舍五入到3位小数的小数。\n\n测试套件：\n- 对所有测试用例，使用 $t_s = 2$ 和 $t_e = 5$。\n\n- 测试用例 1 ($n=6$)：\n  - SNV 距离\n    $$\n    D =\n    \\begin{bmatrix}\n    0  2  4  8  7  6 \\\\\n    2  0  3  9  8  7 \\\\\n    4  3  0  10  9  8 \\\\\n    8  9  10  0  1  12 \\\\\n    7  8  9  1  0  11 \\\\\n    6  7  8  12  11  0\n    \\end{bmatrix}\n    $$\n  - 流行病学关联\n    $$\n    L =\n    \\begin{bmatrix}\n    0  1  0  0  0  0 \\\\\n    1  0  1  0  0  0 \\\\\n    0  1  0  0  0  0 \\\\\n    0  0  0  0  1  0 \\\\\n    0  0  0  1  0  0 \\\\\n    0  0  0  0  0  0\n    \\end{bmatrix}\n    $$\n  - 真实簇：$\\{\\{0,1,2\\}, \\{3,4\\}, \\{5\\}\\}$。\n\n- 测试用例 2 ($n=3$)：\n  - SNV 距离\n    $$\n    D =\n    \\begin{bmatrix}\n    0  9  9 \\\\\n    9  0  9 \\\\\n    9  9  0\n    \\end{bmatrix}\n    $$\n  - 流行病学关联\n    $$\n    L =\n    \\begin{bmatrix}\n    0  0  0 \\\\\n    0  0  0 \\\\\n    0  0  0\n    \\end{bmatrix}\n    $$\n  - 真实簇：$\\{\\{0\\}, \\{1\\}, \\{2\\}\\}$。\n\n- 测试用例 3 ($n=5$)：\n  - SNV距离\n    $$\n    D =\n    \\begin{bmatrix}\n    0  2  4  9  10 \\\\\n    2  0  2  8  9 \\\\\n    4  2  0  5  9 \\\\\n    9  8  5  0  2 \\\\\n    10  9  9  2  0\n    \\end{bmatrix}\n    $$\n  - 流行病学关联\n    $$\n    L =\n    \\begin{bmatrix}\n    0  0  0  0  0 \\\\\n    0  0  0  0  0 \\\\\n    0  0  0  1  0 \\\\\n    0  0  1  0  0 \\\\\n    0  0  0  0  0\n    \\end{bmatrix}\n    $$\n  - 真实簇：$\\{\\{0,1,2\\}, \\{3,4\\}\\}$。\n\n- 测试用例 4 ($n=4$)：\n  - SNV 距离\n    $$\n    D =\n    \\begin{bmatrix}\n    0  2  5  6 \\\\\n    2  0  6  5 \\\\\n    5  6  0  5 \\\\\n    6  5  5  0\n    \\end{bmatrix}\n    $$\n  - 流行病学关联\n    $$\n    L =\n    \\begin{bmatrix}\n    0  0  0  0 \\\\\n    0  0  0  0 \\\\\n    0  0  0  1 \\\\\n    0  0  1  0\n    \\end{bmatrix}\n    $$\n  - 真实簇：$\\{\\{0,1\\}, \\{2,3\\}\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按测试用例 1 到 4 排序的 4 个错误聚类率，格式为逗号分隔的列表，并用方括号括起来，每个值四舍五入到3位小数（例如，$[0.123,0.000,0.700,0.250]$）。", "solution": "这个问题要求实现并评估一种用于推断病原体传播簇的算法，该算法通过整合基因组和流行病学数据来实现。评估是通过对照提供的真实情况计算错误聚类率 (FCR) 来执行的。该过程是确定性的，可分解为三个主要阶段：图构建、簇识别和指标计算。\n\n设 $n$ 为调查中的病例数。每个测试用例的输入是一个对称的单核苷酸变异 (SNV) 距离矩阵 $D \\in \\mathbb{N}^{n \\times n}$、一个对称的二进制流行病学关联矩阵 $L \\in \\{0,1\\}^{n \\times n}$、一个严格的 SNV 阈值 $t_s$ 和一个宽松的 SNV 阈值 $t_e$。对于此问题，阈值固定为 $t_s = 2$ 和 $t_e = 5$。\n\n首先，我们为无向图 $G=(V, E)$ 构建一个邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$，其中 $V = \\{0, 1, \\dots, n-1\\}$ 代表病例。如果两个不同的病例 $i$ 和 $j$ 根据指定标准被视为相关，则它们之间存在一条边 $(i, j)$。矩阵元素 $A_{ij}$ 定义如下：\n$$\nA_{ij} = \\begin{cases}\n1  \\text{if } (D_{ij} \\leq t_s) \\lor (L_{ij} = 1 \\land D_{ij} \\leq t_e) \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n对于所有 $i \\neq j$。对角线元素为 $A_{ii} = 0$。条件 $D_{ij} \\leq t_s$ 仅基于高度遗传相似性来关联病例，表明传播发生得非常近。第二个条件 $L_{ij} = 1 \\land D_{ij} \\leq t_e$ 将流行病学证据（$L_{ij} = 1$）与一个更宽松的遗传距离阈值（$D_{ij} \\leq t_e$）相结合，允许在存在已知接触的情况下，关联遗传差异稍大的基因组。\n\n其次，推断的传播簇被定义为图 $G$ 的连通分量。连通分量是一个子图，其中任意两个顶点都通过路径相互连接，并且该子图不与超图中的任何其他顶点相连。可以采用标准算法，如广度优先搜索 (BFS) 或深度优先搜索 (DFS)，从邻接矩阵 $A$ 中找到这些分量。结果是将顶点集 $V$ 划分成不相交的子集，其中每个子集构成一个推断出的簇。将此推断出的聚类记为 $\\widehat{C}$。\n\n第三，我们根据真实情况的聚类来评估推断出的聚类 $\\widehat{C}$。评估基于成对关系。我们首先定义推断阳性对的集合 $\\mathcal{P}$，作为所有被分到同一个推断簇中的唯一病例对 $(i, j)$（其中 $i  j$）。\n$$\n\\mathcal{P} = \\{(i,j) : 0 \\leq i  j \\leq n-1, \\text{ 且 } i,j \\text{ 在 } G \\text{ 的同一个连通分量中}\\}\n$$\n真实情况以病例的一个划分给出，这定义了一个相应的真值矩阵 $T \\in \\{0,1\\}^{n \\times n}$，其中当且仅当病例 $i$ 和 $j$ 属于同一个真实簇时 ($i \\neq j$)，$T_{ij} = 1$。对于每个对 $(i, j) \\in \\mathcal{P}$，如果它们也属于同一个真实簇（$T_{ij} = 1$），我们将其分类为真阳性 (TP)；如果不是（$T_{ij} = 0$），则分类为假阳性 (FP)。总数是：\n$$\n\\mathrm{TP} = \\sum_{(i,j) \\in \\mathcal{P}} \\mathbf{1}\\{T_{ij} = 1\\}\n$$\n$$\n\\mathrm{FP} = \\sum_{(i,j) \\in \\mathcal{P}} \\mathbf{1}\\{T_{ij} = 0\\}\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n最后，计算错误聚类率 (FCR)。该指标表示在所有被算法聚类到一起的对中，被错误聚类的对所占的比例。公式为：\n$$\n\\mathrm{FCR} =\n\\begin{cases}\n\\dfrac{\\mathrm{FP}}{\\mathrm{TP} + \\mathrm{FP}},  \\text{if } \\mathrm{TP} + \\mathrm{FP} > 0 \\\\\n0,  \\text{if } \\mathrm{TP} + \\mathrm{FP} = 0\n\\end{cases}\n$$\n如果算法没有将任何对聚类在一起，则 $\\mathrm{TP} + \\mathrm{FP} = 0$，FCR 为 $0$。\n\n将这整个过程应用于每个测试用例，以计算相应的 FCR，然后按要求四舍五入到3位小数。`scipy.sparse.csgraph.connected_components` 函数是从邻接矩阵 $A$ 识别簇的合适工具。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse.csgraph import connected_components\n\ndef solve():\n    \"\"\"\n    Solves the genomic epidemiology clustering problem for the given test cases.\n    \"\"\"\n    \n    # Define the global thresholds from the problem statement.\n    t_s = 2\n    t_e = 5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"D\": np.array([\n                [0, 2, 4, 8, 7, 6],\n                [2, 0, 3, 9, 8, 7],\n                [4, 3, 0, 10, 9, 8],\n                [8, 9, 10, 0, 1, 12],\n                [7, 8, 9, 1, 0, 11],\n                [6, 7, 8, 12, 11, 0]\n            ]),\n            \"L\": np.array([\n                [0, 1, 0, 0, 0, 0],\n                [1, 0, 1, 0, 0, 0],\n                [0, 1, 0, 0, 0, 0],\n                [0, 0, 0, 0, 1, 0],\n                [0, 0, 0, 1, 0, 0],\n                [0, 0, 0, 0, 0, 0]\n            ]),\n            \"true_clusters\": [{0, 1, 2}, {3, 4}, {5}]\n        },\n        {\n            \"D\": np.array([\n                [0, 9, 9],\n                [9, 0, 9],\n                [9, 9, 0]\n            ]),\n            \"L\": np.array([\n                [0, 0, 0],\n                [0, 0, 0],\n                [0, 0, 0]\n            ]),\n            \"true_clusters\": [{0}, {1}, {2}]\n        },\n        {\n            \"D\": np.array([\n                [0, 2, 4, 9, 10],\n                [2, 0, 2, 8, 9],\n                [4, 2, 0, 5, 9],\n                [9, 8, 5, 0, 2],\n                [10, 9, 9, 2, 0]\n            ]),\n            \"L\": np.array([\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0],\n                [0, 0, 0, 0, 0]\n            ]),\n            \"true_clusters\": [{0, 1, 2}, {3, 4}]\n        },\n        {\n            \"D\": np.array([\n                [0, 2, 5, 6],\n                [2, 0, 6, 5],\n                [5, 6, 0, 5],\n                [6, 5, 5, 0]\n            ]),\n            \"L\": np.array([\n                [0, 0, 0, 0],\n                [0, 0, 0, 0],\n                [0, 0, 0, 1],\n                [0, 0, 1, 0]\n            ]),\n            \"true_clusters\": [{0, 1}, {2, 3}]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        D = case[\"D\"]\n        L = case[\"L\"]\n        true_clusters = case[\"true_clusters\"]\n        n = D.shape[0]\n\n        # 1. Construct the adjacency matrix A for graph G.\n        A = np.zeros((n, n), dtype=int)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (D[i, j] = t_s) or (L[i, j] == 1 and D[i, j] = t_e):\n                    A[i, j] = 1\n                    A[j, i] = 1\n\n        # 2. Infer clusters as connected components of G.\n        n_components, labels = connected_components(csgraph=A, directed=False, return_labels=True)\n\n        # 3. Create a look-up for ground truth pairs.\n        true_pairs = set()\n        for cluster in true_clusters:\n            cluster_nodes = sorted(list(cluster))\n            for i in range(len(cluster_nodes)):\n                for j in range(i + 1, len(cluster_nodes)):\n                    true_pairs.add((cluster_nodes[i], cluster_nodes[j]))\n\n        # 4. Calculate TP and FP based on inferred clusters.\n        tp = 0\n        fp = 0\n        \n        # Iterate through all unique pairs (i, j) with i  j.\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check if the pair is in the same inferred cluster.\n                if labels[i] == labels[j]:\n                    pair = (i, j)\n                    if pair in true_pairs:\n                        tp += 1\n                    else:\n                        fp += 1\n        \n        # 5. Calculate the False Clustering Rate (FCR).\n        denominator = tp + fp\n        if denominator == 0:\n            fcr = 0.0\n        else:\n            fcr = fp / denominator\n        \n        results.append(fcr)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4527634"}]}