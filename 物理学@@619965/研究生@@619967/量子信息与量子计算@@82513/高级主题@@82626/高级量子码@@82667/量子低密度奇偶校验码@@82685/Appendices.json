{"hands_on_practices": [{"introduction": "逻辑算符是在编码信息上进行操作的算符，它们构成了量子纠错码的“可计算”门。理解和识别这些算符至关重要，因为最低权重的逻辑算符的权重定义了码的距离，并代表了最可能导致计算失败的不可校正错误。本练习 [@problem_id:123389] 提供了一个基础但核心的训练，即如何从一个给定的校验矩阵中找出逻辑X算符。", "problem": "一个量子CSS (Calderbank-Shor-Steane) 码由两个满足 $C_Z \\subseteq C_X$ 的经典线性码 $C_X$ 和 $C_Z$ 定义。一个更通用的构造是使用两个校验矩阵 $H_X$ 和 $H_Z$，分别用于X型和Z型稳定子。稳定子必须相互对易，对于CSS码，这可转化为在 $\\mathbb{F}_2$ 上满足条件 $H_X H_Z^T = 0$。这类码的量子比特与这些矩阵的列相关联。\n\n一个X型逻辑算符是形如 $L_X = \\bigotimes_i X_i^{\\ell_i}$ 的泡利算符，由一个二进制向量 $\\ell$ 表示。它与所有Z型稳定子对易，但本身不是一个X型稳定子。对易条件意味着 $\\ell \\in \\ker(H_Z)$。“不是X型稳定子”这一条件意味着 $\\ell$ 不在 $H_X$ 的行空间中。$L_X$ 的权重是向量 $\\ell$ 的汉明权重。\n\n考虑一个作用于 $N=8$ 个量子比特的量子码，它被构造为一个CSS码，其中用于X型和Z型稳定子的经典码是相同的，并由定义在 $\\mathbb{F}_2$ 上的校验矩阵 $H$ 给出：\n$$\nH = \\begin{pmatrix}\n1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{pmatrix}\n$$\n因此，$H_X = H_Z = H$。由于 $H H^T = 0 \\pmod 2$，该构造定义了一个有效的CSS码。\n\n你的任务是找出该码的一个X型逻辑算符的最小权重。", "solution": "我们希望找到一个非平凡X逻辑算符的最小汉明权重，即一个向量 $\\ell$ 满足 $\\ell\\in\\ker(H)$ 但 $\\ell\\notin\\mathrm{rowspace}(H)$。\n\n1.  在 $\\mathbb{F}_2$ 上写出校验条件 $H\\ell=0$。若 $\\ell=(\\ell_1,\\dots,\\ell_8)^T$，则\n$$\n\\ell_1+\\ell_2+\\ell_3+\\ell_4=0,\n\\quad\n\\ell_3+\\ell_4+\\ell_5+\\ell_6=0,\n\\quad\n\\ell_5+\\ell_6+\\ell_7+\\ell_8=0.\n$$\n\n2.  很容易检验，权重为1的向量无法满足所有三个方程，而权重为2的向量\n$$\n\\ell=e_1+e_2=(1,1,0,0,0,0,0,0)^T\n$$\n则满足：\n$$\n(1+1+0+0,\\;0+0+0+0,\\;0+0+0+0)\\equiv(0,0,0)\\pmod2.\n$$\n因此 $e_1+e_2\\in\\ker(H)$。\n\n3.  我们还必须验证 $e_1+e_2\\notin\\mathrm{rowspace}(H)$。$\\mathrm{rowspace}(H)$ 中的任意向量都形如\n$$\nx(1,1,1,1,0,0,0,0)+y(0,0,1,1,1,1,0,0)+z(0,0,0,0,1,1,1,1),\n$$\n可以检验，$(x,y,z)\\in\\mathbb{F}_2^3$ 的任何取值都无法得到 $(1,1,0,0,0,0,0,0)$。\n\n4.  因此，一个非平凡逻辑X算符的最小权重是 $2$。", "answer": "$$\\boxed{2}$$", "id": "123389"}, {"introduction": "在了解了我们需要避免哪些错误（即逻辑错误）之后，我们需要学习如何纠正那些更常见的、低权的错误。置信传播（Belief Propagation, BP）是一种强大的迭代解码算法，它通过在码的Tanner图上传递消息（对数似然比）来推断最可能的错误模式。本练习 [@problem_id:123319] 将带领您逐步完成对一个小规模码的BP解码过程，从而将抽象的算法更新规则具体化和形象化。", "problem": "一个量子CSS码由两个相同的经典线性码构成，其奇偶校验矩阵 $H$ 定义了一个具有 $N=8$ 个变量节点（量子比特）和 $M=6$ 个校验节点（稳定子校验）的 $(d_v, d_c) = (3,4)$-正则Tanner图。Z错误使用其稳定子校验进行独立解码，其对应的Tanner图由以下校验到变量的邻域列表描述：\n- $N(c_1) = \\{v_1, v_2, v_3, v_4\\}$\n- $N(c_2) = \\{v_5, v_6, v_7, v_8\\}$\n- $N(c_3) = \\{v_1, v_2, v_5, v_6\\}$\n- $N(c_4) = \\{v_3, v_4, v_7, v_8\\}$\n- $N(c_5) = \\{v_1, v_3, v_5, v_7\\}$\n- $N(c_6) = \\{v_2, v_4, v_6, v_8\\}$\n\n量子比特受到独立噪声的影响，任意量子比特 $i$ 上发生Z错误的初始先验对数似然比（LLR）由 $L_{ch} = \\log \\frac{P(e_i=0)}{P(e_i=1)} = 2 \\text{arctanh}(1/2)$ 给出。\n\n一个Z错误发生在量子比特 $v_1$ 上。产生的校正子被测量并提供给一个置信度传播（和积）解码器。请计算解码算法经过两次完整迭代后，量子比特 $v_1$ 的最终LLR，记为 $L_1^{(\\text{final})}$。\n\n置信度传播的更新规则如下：\n- **初始化**：令 $L_i^{(0)} = L_{ch}$ 为每个量子比特 $i$ 的初始LLR。在第一次迭代时，从校验节点到变量节点的消息初始化为零，即 $u_{j \\to i}^{(0)}=0$。\n- **变量到校验（V2C）消息**：在第 $t$ 次迭代时，从变量节点 $i$ 到校验节点 $j$ 的消息为：\n$$m_{i \\to j}^{(t)} = L_i^{(0)} + \\sum_{k \\in N(i) \\setminus \\{j\\}} u_{k \\to i}^{(t-1)}$$\n- **校验到变量（C2V）消息**：在第 $t$ 次迭代时，从校验节点 $j$ 到变量节点 $i$ 的消息为：\n$$u_{j \\to i}^{(t)} = 2 \\text{arctanh} \\left( (-1)^{s_j} \\prod_{k \\in N(j) \\setminus \\{i\\}} \\tanh\\left(\\frac{m_{k \\to j}^{(t)}}{2}\\right) \\right)$$\n其中 $s_j \\in \\{0,1\\}$ 是校验 $j$ 的测量校正子比特。\n- **最终LLR**：经过 $T$ 次迭代后，量子比特 $i$ 的最终LLR为：\n$$L_i^{(T)} = L_i^{(0)} + \\sum_{j \\in N(i)} u_{j \\to i}^{(T)}$$", "solution": "我们记\n$$\\alpha = L_{ch} = 2\\text{arctanh}\\bigl(\\tfrac12\\bigr),\\qquad\na = \\text{arctanh}\\bigl(\\tfrac18\\bigr),\\qquad\nb = 2a = 2\\text{arctanh}\\bigl(\\tfrac18\\bigr).$$\n在第1次迭代时，所有的校验到变量消息为\n$$u_{j\\to i}^{(1)} = 2\\text{arctanh}\\bigl((-1)^{s_j}( \\tanh(\\alpha/2))^3\\bigr)\n=2\\text{arctanh}\\bigl((-1)^{s_j}\\tfrac1{8}\\bigr)\n=\\begin{cases}+\\,b,&s_j=0,\\\\-\\,b,&s_j=1.\\end{cases}$$\n由于 $v_1$ 上的单个错误导致 $s_{1,3,5}=1$ 和 $s_{2,4,6}=0$，我们有\n$$u_{c_j\\to i}^{(1)}=-b\\quad(j=1,3,5),\\quad u_{c_j\\to i}^{(1)}=+b\\quad(j=2,4,6).$$\n在第2次迭代时，来自每个 $v_i$ 的变量到校验消息为\n$$m_{i\\to j}^{(2)}\n=\\alpha+\\sum_{k\\in N(i)\\setminus\\{j\\}}u_{k\\to i}^{(1)},$$\n我们可以逐个情况进行核对。特别是对于 $v_1$，每个\n$$m_{1\\to j}^{(2)}=\\alpha+(-b)+(-b)=\\alpha-2b\\quad(j=1,3,5).$$\n接下来，对于 $j\\in\\{1,3,5\\}$，在第2次迭代时的校验到变量消息为\n$$u_{j\\to1}^{(2)}\n=2\\text{arctanh}\\Bigl((-1)^{s_j}\\!\\prod_{k\\in N(j)\\setminus\\{1\\}}\\tanh\\bigl(m_{k\\to j}^{(2)}/2\\bigr)\\Bigr).$$\n对于每个这样的 $j$，我们发现恰好有两个邻居的 $m=\\alpha$，一个邻居的 $m=\\alpha+2b$，因此\n$$\\tanh\\bigl(\\alpha/2\\bigr)=\\tfrac12,\\quad\n\\tanh\\bigl((\\alpha+2b)/2\\bigr)\n=\\tanh\\bigl(d+b\\bigr) = \\frac{97}{146}, \\text{ 其中 } d=\\text{arctanh}(\\tfrac12).$$\n因此\n$$\\prod\\tanh=\\bigl(\\tfrac12\\bigr)^2\\cdot\\frac{97}{146}=\\frac{97}{584},$$\n并且由于 $s_j=1$，\n$$u_{j\\to1}^{(2)}=2\\text{arctanh}\\!\\Bigl(-\\tfrac{97}{584}\\Bigr)=-2\\text{arctanh}\\!\\Bigl(\\tfrac{97}{584}\\Bigr).$$\n最后，经过两次迭代后的后验LLR为\n$$L_1^{(2)}=L_1^{(0)}+\\sum_{j\\in N(1)}u_{j\\to1}^{(2)}\n=\\alpha-3\\cdot2\\text{arctanh}\\!\\Bigl(\\tfrac{97}{584}\\Bigr)\n=2\\text{arctanh}\\!\\Bigl(\\tfrac12\\Bigr)-6\\text{arctanh}\\!\\Bigl(\\tfrac{97}{584}\\Bigr).$$", "answer": "$$\\boxed{2\\text{arctanh}\\!\\bigl(\\tfrac12\\bigr)\\;-\\;6\\text{arctanh}\\!\\bigl(\\tfrac{97}{584}\\bigr)}$$", "id": "123319"}, {"introduction": "解码算法并非万无一失，它们的性能极限决定了容错计算的阈值。本练习将探讨一个简单解码器失效的场景，这种情况通常发生在错误图样自身构成了一个逻辑算符或其它“陷阱集”结构时。通过使用与第一个练习相同的量子码 [@problem_id:123310]，本练习将清晰地展示一个低权的逻辑错误如何“欺骗”一个简单的翻转解码器，使其不采取任何纠正措施，最终导致逻辑错误的发生。这个例子将逻辑算符的概念与解码器的实际性能直接联系起来，从而为本章的学习画上句号。", "problem": "一个量子 CSS 码构建在 $n=8$ 个量子比特上。该码由两组稳定子生成元定义，一组由泡利-X 算符的乘积组成（X型稳定子），另一组由泡利-Z 算符的乘积组成（Z型稳定子）。在 $\\mathbb{F}_2$ 上的标准向量表示中，它们由两个奇偶校验矩阵 $H_X$ 和 $H_Z$ 指定。对于这个特定的码，这两个矩阵是相同的，即 $H_X = H_Z = H$，其中\n$$ H = \\begin{pmatrix} 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\end{pmatrix} $$\n$H$ 的行对应于稳定子群的生成元。例如，第一个 X 型稳定子是 $S_{X1} = X_1 X_2 X_3 X_4$。\n\n考虑该码在纯 Z 型错误下的性能，这类错误由二元向量 $e_Z \\in \\mathbb{F}_2^n$ 表示。错误使用一个简单的小集合翻转（SSF）解码算法进行解码，其工作原理如下：\n\n1.  给定一个错误向量 $e_Z$，计算伴随式向量 $s = H e_Z^T \\pmod 2$。\n2.  如果 $s$ 是零向量，解码器终止。施加的校正为单位算符。\n3.  如果 $s$ 非零，则识别未满足的校验集 $U = \\{i \\mid s_i = 1\\}$。\n4.  对于每个量子比特 $j \\in \\{1, \\dots, 8\\}$，计算一个分数 $w_j = \\sum_{i \\in U} H_{ij}$，该分数计算了量子比特 $j$ 参与了多少个未满足的校验。\n5.  识别具有最大分数 $w_{j_0}$ 的量子比特 $j_0$。如果存在平局，则选择索引 $j$ 最小的量子比特。\n6.  通过翻转已识别的量子比特来施加校正：更新错误向量 $e_Z \\leftarrow e_Z + \\delta_{j_0}$，其中 $\\delta_{j_0}$ 是一个在位置 $j_0$ 处为 1，其他位置为 0 的向量。\n7.  使用新的错误向量从步骤 1 重复。\n8.  如果算法终止后，净错误（初始错误加上所有施加校正的总和）是一个非平凡的逻辑算符，则称该解码器在初始错误 $e_Z$ 上解码失败。\n\n如果一个算符与所有 X-稳定子对易，但其本身不是一个 Z-稳定子，则该算符是一个逻辑 Z-算符。在向量表示法中，如果 $H l_Z^T = 0$ 且 $l_Z$ 不在 $H_Z=H$ 的行空间中，则向量 $l_Z$ 表示一个逻辑 Z-算符。\n\n导致此 SSF 解码器失败的 Z-错误配置 $e_Z$ 的最小权重是多少？错误 $e_Z$ 的权重是其汉明权重，即非零项的数目。", "solution": "当错误向量 $e_Z$ 本身是一个逻辑Z算符时，SSF解码器会失败，因为此时伴随式 $s=H e_Z^T=0$，解码器会终止而不进行任何操作。因此，问题转化为寻找该码的最小权重逻辑Z算符。\n一个逻辑Z算符 $l_Z$ 是一个向量，它满足 $H l_Z^T = 0$，但不在 $H$ 的行空间中。\n\n1.  通过检验可以发现，任何权重为1的错误向量都会产生非零伴随式，因此不会导致这种“无察觉”的失败。\n2.  现在考虑权重为2的错误向量。令 $e_Z = (1, 1, 0, 0, 0, 0, 0, 0)$。\n3.  我们计算其伴随式：$s = H e_Z^T = (1\\cdot1 + 1\\cdot1, 0, 0)^T = (0, 0, 0)^T \\pmod 2$。\n4.  由于伴随式为零，SSF解码器将终止，不采取任何纠正措施。\n5.  然而，错误向量 $e_Z$ 本身并不在 $H$ 的行空间中，因此它是一个非平凡的逻辑算符。这就导致了一次解码失败。\n6.  因此，导致此SSF解码器失败的Z错误配置的最小权重是2。", "answer": "$$\\boxed{2}$$", "id": "123310"}]}