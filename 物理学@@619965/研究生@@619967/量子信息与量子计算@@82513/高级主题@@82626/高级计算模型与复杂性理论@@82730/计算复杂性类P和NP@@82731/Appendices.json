{"hands_on_practices": [{"introduction": "在计算复杂性理论中，将问题转化为标准形式至关重要，对于布尔可满足性问题（SAT）而言，这个标准形式就是合取范式（Conjunctive Normal Form, CNF）。Tseitin变换是实现这种转化的关键算法，它在保持可满足性的同时，只会线性增加公式的大小。这项练习 [@problem_id:61650] 让您亲手分析该变换在一个递归定义的布尔公式上引入的新变量数量，旨在锻炼您对算法的分析能力以及求解递归关系（recurrence relation）的技巧。", "problem": "Tseitin 变换是一种标准算法，用于将任意布尔公式转换为一个等可满足的合取范式 (CNF) 公式。该变换的一个关键特征是，为原始公式中每个逻辑门（或对应于一个逻辑联结词的子公式）的输出引入一个新的布尔变量。因此，引入的新变量总数等于该公式表达式树中逻辑联结词的数量。在本问题中，我们考虑的逻辑联结词集合为 $\\{\\land, \\lor, \\neg\\}$ (与、或、非)。\n\n考虑一个递归定义的布尔公式族，记为 $\\Psi_n$，它定义在一组原子变量 $\\{x_i\\}_{i \\in \\mathbb{N}}$ 上。\n\n当 $n=0$ 时的基例公式为：\n$$ \\Psi_0(x_1) = x_1 $$\n对于任意整数 $n \\geq 1$，公式 $\\Psi_n$ 由作用于不相交变量集合的三个 $\\Psi_{n-1}$ 实例来定义：\n$$ \\Psi_n(x_1, \\ldots, x_{3^n}) = \\left( \\Psi_{n-1}^{(1)} \\land \\Psi_{n-1}^{(2)} \\right) \\lor \\left( \\neg \\Psi_{n-1}^{(3)} \\right) $$\n其中\n- $\\Psi_{n-1}^{(1)} = \\Psi_{n-1}(x_1, \\ldots, x_{3^{n-1}})$\n- $\\Psi_{n-1}^{(2)} = \\Psi_{n-1}(x_{3^{n-1}+1}, \\ldots, x_{2 \\cdot 3^{n-1}})$\n- $\\Psi_{n-1}^{(3)} = \\Psi_{n-1}(x_{2 \\cdot 3^{n-1}+1}, \\ldots, x_{3^n})$\n\n请确定对布尔公式 $\\Psi_n$ 应用 Tseitin 变换所引入的新变量数量 $V(n)$。你的答案应该是一个关于非负整数 $n$ 的闭式表达式。", "solution": "1. 设 $C(n)$ 为 $\\Psi_n$ 中联结词的数量。每个联结词会引入一个新的 Tseitin 变量，因此 $V(n)=C(n)$。\n2. 基例：$\\Psi_0(x_1)=x_1$ 不含联结词，所以\n   $$\n   C(0)=0.\n   $$\n3. 对于 $n\\ge1$，$\\Psi_n=(\\Psi_{n-1}^{(1)}\\land\\Psi_{n-1}^{(2)})\\lor(\\neg\\Psi_{n-1}^{(3)})$ 包含\n   - 三个子公式，每个子公式含有 $C(n-1)$ 个联结词，\n   - 一个 $\\land$、一个 $\\lor$ 和一个 $\\neg$，总共新增三个联结词。\n   因此\n   $$\n   C(n)=3\\,C(n-1)+3.\n   $$\n4. 求解递推关系 $C(n)=3C(n-1)+3$，其中 $C(0)=0$。齐次解为 $A\\cdot3^n$。一个常数特解 $C_p$ 满足\n   $$\n   C_p=3C_p+3\n   \\;\\Longrightarrow\\;-2C_p=3\n   \\;\\Longrightarrow\\;C_p=-\\tfrac32.\n   $$\n   因此\n   $$\n   C(n)=A\\cdot3^n-\\tfrac32.\n   $$\n   使用 $C(0)=0$ 可得 $A-\\tfrac32=0$，所以 $A=\\tfrac32$。因此\n   $$\n   C(n)=\\tfrac32\\cdot3^n-\\tfrac32\n         =\\frac{3^{n+1}-3}{2}.\n   $$\n5. 结论：引入的新 Tseitin 变量数量为\n   $$\n   V(n)=C(n)=\\frac{3^{n+1}-3}{2}.\n   $$", "answer": "$$\\boxed{\\frac{3^{n+1}-3}{2}}$$", "id": "61650"}, {"introduction": "理解了如何将问题表述为CNF形式后，下一步自然是学习如何求解它们。这项练习将带您深入现代SAT求解器的核心引擎：冲突驱动子句学习（Conflict-Driven Clause Learning, CDCL）算法。这个实践问题 [@problem_id:61735] 让您置身于求解器遇到冲突的关键时刻，通过分析蕴含图（implication graph）来找到“第一唯一蕴含点”（1-UIP）并派生出新的学习子句。通过这个过程，您将具体地理解求解器是如何从错误中“学习”并高效剪枝巨大搜索空间的。", "problem": "此问题探讨了现代“冲突驱动子句学习”（CDCL）SAT求解器中的冲突分析机制。具体来说，您的任务是通过从给定的冲突场景中识别“第一唯一蕴含点”（1-UIP）来推导出学习子句。\n\n#### 背景\n\n**1. 布尔可满足性（SAT）**\n如果一个布尔公式是子句的合取（AND），其中每个子句是文字的析取（OR），则该公式处于合取范式（CNF）中。一个文字是一个布尔变量（例如，$x_i$）或其否定（例如，$\\neg x_i$）。SAT 问题旨在判断是否存在一种对变量的真值赋值，使得整个公式为真。\n\n**2. CDCL 求解器**\nCDCL 求解器探索变量赋值的搜索空间。它们进行一系列*决策*，在某个*决策层级*为变量赋一个真值。在每次决策之后，它们执行*单元传播*（或布尔约束传播），该过程识别出已成为*单元子句*（在当前部分赋值下，除一个文字外所有文字都为假）的子句，并强制将剩余的文字赋值为真。\n\n**3. 冲突与蕴含图**\n当一个子句被当前的部分赋值证伪（即其所有文字都为假）时，就发生了*冲突*。导致冲突的蕴含链可以用一个*蕴含图*来表示，它是一个有向无环图（DAG）。\n- **节点**：节点是在当前决策层级赋值的文字，外加一个特殊的冲突节点 $\\kappa$。节点也可以表示在先前层级赋值的、对当前层级的蕴含有所贡献的文字。\n- **边**：如果将 $l_1, \\dots, l_k$ 赋值为真会使子句 $C = (\\neg l_1 \\lor \\dots \\lor \\neg l_k \\lor l)$ 成为一个单元子句，从而蕴含 $l$，那么就存在从文字集合 $\\{l_1, \\dots, l_k\\}$ 到文字 $l$ 的一条边。该子句 $C$ 被称为 $l$ 的*前因*（antecedent）。冲突节点 $\\kappa$ 的入边来自那些证伪*冲突子句*的文字。\n\n**4. 冲突分析与 1-UIP**\n当发生冲突时，求解器会分析蕴含图，以学习一个新的子句，从而防止未来发生同样的冲突。1-UIP 方案是一种常见且高效的分析方法。\n- **唯一蕴含点（UIP）** 是蕴含图中当前决策层级的一个节点（文字），从当前层级的决策文字到冲突节点 $\\kappa$ 的每一条路径都穿过它。\n- **第一 UIP（1-UIP）** 是图中距离冲突节点 $\\kappa$ 最近的 UIP。\n- 学习子句是通过一系列从冲突子句开始的归结步骤推导出来的。这个过程持续进行，直到结果子句在当前决策层级只包含一个被赋值的文字。这个文字保证是 1-UIP 的否定。\n\n#### 问题描述\n\n一个 CDCL 求解器正在处理一个 CNF 公式。它在决策层级 $d$ 达到了一个冲突状态。该状态描述如下：\n\n- **来自先前层级（$<d$）的赋值：** 文字 $\\{\\neg x_1, \\neg x_6, \\neg x_7\\}$ 为真。\n- **在层级 $d$ 的决策：** 求解器决策 $x_5 = \\text{True}$。\n- **在层级 $d$ 的单元传播：** 决策 $x_5@d$ 触发了以下一系列蕴含：\n    1. $x_2@d$ 被蕴含，其前因子句为 $C_1 = (x_1 \\lor \\neg x_5 \\lor x_2)$。\n    2. $x_3@d$ 被蕴含，其前因子句为 $C_2 = (\\neg x_5 \\lor x_3)$。\n    3. $x_4@d$ 被蕴含，其前因子句为 $C_3 = (\\neg x_2 \\lor \\neg x_3 \\lor x_4)$。\n    4. $x_8@d$ 被蕴含，其前因子句为 $C_4 = (\\neg x_4 \\lor x_8)$。\n    5. $x_9@d$ 被蕴含，其前因子句为 $C_5 = (x_6 \\lor \\neg x_4 \\lor x_9)$。\n- **冲突：** 在子句 $C_6 = (x_7 \\lor \\neg x_8 \\lor \\neg x_9)$ 中发生冲突，因为在当前赋值下，文字 $x_7$、$\\neg x_8$ 和 $\\neg x_9$ 都为假。\n\n您的任务是使用 1-UIP 学习方案来确定学习子句。将学习子句表示为一个整数集合，其中文字 $x_i$ 由整数 $i$ 表示，$\\neg x_i$ 由 $-i$ 表示。\n\n**求解目标：** 计算最终学习子句中表示文字的整数的绝对值之和。", "solution": "1. 冲突子句：\n   $$C_6 = (x_7 \\lor \\neg x_8 \\lor \\neg x_9)$$\n   在层级 $d$ 赋值的文字：$x_5,x_2,x_3,x_4,x_8,x_9$。当前的学习子句 $L$ 初始化为 $C_6$。\n\n2. 在层级 $d$ 的赋值序列中，最后被蕴含的文字是 $x_9$。我们用 $x_9$ 的前因子句 $C_5 = (x_6 \\lor \\neg x_4 \\lor x_9)$ 对 $L$ 进行归结 (Resolution)：\n   $$ L := \\text{Resolve}(L, C_5, x_9) = (x_7 \\lor \\neg x_8 \\lor x_6 \\lor \\neg x_4) $$\n   现在 $L$ 中在层级 $d$ 赋值的文字是 $\\{\\neg x_8, \\neg x_4\\}$。\n\n3. 下一个要归结的文字是 $x_8$（在蕴含序列中比 $x_4$ 更晚）。其前因子句为 $C_4 = (\\neg x_4 \\lor x_8)$。\n   $$ L := \\text{Resolve}(L, C_4, x_8) = (x_7 \\lor x_6 \\lor \\neg x_4) $$\n   此时，$L$ 中只有一个在层级 $d$ 赋值的文字 ($\\neg x_4$)，它的变量 ($x_4$) 就是第一唯一蕴含点 (1-UIP)。\n\n4. 学习到的子句是：\n   $$ L = (x_7 \\lor x_6 \\lor \\neg x_4) $$\n   表示为整数集合 $\\{-4, 6, 7\\}$。\n\n5. 整数的绝对值之和为 $|-4| + |6| + |7| = 4 + 6 + 7 = 17$。", "answer": "$$\\boxed{17}$$", "id": "61735"}, {"introduction": "尽管许多问题在最坏情况下是NP难的，但这并不意味着所有实例都同样难以处理。本练习将探索“固定参数可解性”（Fixed-Parameter Tractability, FPT），这是一种当问题的某个特定参数很小时能够高效求解NP难问题的强大理论框架。这项练习 [@problem_id:61767] 要求您追踪一个经典的顶点覆盖（Vertex Cover）FPT算法的执行过程，观察其规约和分支规则如何在有界深度的搜索树中协同工作。这次实践将揭示我们如何通过利用问题的内在结构，为理论上的难题找到切实可行的解决方案。", "problem": "顶点覆盖问题是计算机科学中一个经典的 NP-hard 问题。给定一个图 $G=(V, E)$，顶点覆盖是顶点集的一个子集 $S \\subseteq V$，使得对于每条边 $(u,v) \\in E$，$u$ 或 $v$ 中至少有一个顶点在 $S$ 中。该问题要求找到一个大小尽可能最小的覆盖。\n\n虽然该问题通常是困难的，但当所需覆盖的大小 $k$ 较小时，它变得易于处理。这是一个固定参数可解 (FPT) 问题的例子。顶点覆盖问题的一种标准 FPT 方法是使用递归、有界深度的搜索树算法。理解此类算法的行为在计算复杂性理论中至关重要，为研究经典和量子复杂性类提供了背景。\n\n考虑以下确定性递归算法 `CountLeaves(G, k)`，该算法计算用于寻找大小至多为 $k$ 的顶点覆盖的搜索树中的叶节点数量。叶节点代表递归的终止点。\n\n**`CountLeaves(G, k)` 算法：**\n\n该算法以一个图 $G=(V,E)$ 和一个整数 $k$ 作为输入。它按顺序应用以下规则：\n1.  **基本情况（成功）：** 如果图中没有边（$E = \\emptyset$），则当前选择的顶点集是一个有效的覆盖。这是一个成功叶节点。返回 1。\n2.  **基本情况（失败）：** 如果预算 $k \\le 0$ 且图中仍有边（$E \\ne \\emptyset$），则无法在预算内找到覆盖。这是一个失败叶节点。返回 1。\n3.  **规约规则 A（高度数顶点）：** 如果存在任何度数大于 $k$ 的顶点 $v$（即 $\\deg(v) > k$），那么这样的顶点必须在任何大小为 $k$ 的顶点覆盖中。设 $v_0$ 是满足此条件的索引最小的顶点。算法通过将 $v_0$ 加入覆盖来继续执行，不进行分支。返回递归调用 `CountLeaves($G - \\{v_0\\}$, $k-1$)` 的结果，其中 $G - \\{v_0\\}$ 是移除了 $v_0$ 及其所有关联边后的图。\n4.  **规约规则 B（度为 1 的顶点）：** 如果存在任何度数为 1 的顶点 $v$，设其唯一的邻居为 $u$。对于最优覆盖，选择 $u$ 总是比选择 $v$ 更优。设 $v_0$ 是度数为 1 的索引最小的顶点，其邻居为 $u_0$。算法通过将 $u_0$ 加入覆盖来继续执行，不进行分支。返回递归调用 `CountLeaves($G - \\{u_0\\}$, $k-1$)` 的结果。\n5.  **分支规则：** 如果以上条件均不满足，算法必须进行分支。\n    a. 选择一个至少有一条边的索引最小的顶点 $u$。\n    b. 选择 $u$ 的一个索引最小的邻居 $v$。\n    c. 由于边 $(u,v)$ 必须被覆盖，所以 $u$ 或 $v$ 必须在顶点覆盖中。算法根据这两种可能性进行分支。返回两个递归调用的结果之和：`CountLeaves($G - \\{u\\}$, $k-1$) + CountLeaves($G - \\{v\\}$, $k-1$)`。\n\n**你的任务：**\n\n给定图 $G=(V, E)$，其中顶点集 $V = \\{1, 2, 3, 4, 5, 6\\}$，边集 $E = \\{(1,2), (1,3), (2,3), (2,4), (3,5), (4,5), (4,6), (5,6)\\}$，以及参数 $k=3$，计算 `CountLeaves(G, k)` 算法生成的叶节点总数。", "solution": "我们给定的图为 $G = (V, E)$，其中 $V = \\{1, 2, 3, 4, 5, 6\\}$，$E = \\{(1,2), (1,3), (2,3), (2,4), (3,5), (4,5), (4,6), (5,6)\\}$，参数 $k = 3$。我们需要使用 `CountLeaves($G, k$)` 算法计算叶节点的数量。\n\n初始调用：`CountLeaves($G, 3$)`。\n1. **初始状态：** $k=3$。初始度数为：$\\deg(1) = 2$, $\\deg(2) = 3$, $\\deg(3) = 3$, $\\deg(4) = 3$, $\\deg(5) = 3$, $\\deg(6) = 2$。\n2. 规则 1-4 不适用（没有顶点的度数 $>3$）。\n3. **规则 5 (分支)：** 选择索引最小的顶点 $u=1$ 及其索引最小的邻居 $v=2$。分支：\n   - **分支 1：** `CountLeaves($G - \\{1\\}, 2$)`\n   - **分支 2：** `CountLeaves($G - \\{2\\}, 2$)`\n\n**追踪分支 1：** `CountLeaves($G_1, 2$)`\n- $k=2$。图 $G_1$ 的边集为 $E_1 = \\{(2,3), (2,4), (3,5), (4,5), (4,6), (5,6)\\}$。\n- $G_1$ 中的度数：$\\deg(2)=2$, $\\deg(3)=2$, $\\deg(4)=3$, $\\deg(5)=3$, $\\deg(6)=2$。\n- **规则 3 (高度数)：** $\\deg(4)=3 > k=2$。选择索引最小的此类顶点，$v_0=4$。不分支，递归调用 `CountLeaves($G_1 - \\{4\\}, 1$)`。\n  - **子调用 1.1：** `CountLeaves($G_{1a}, 1$)`\n    - $k=1$。$G_{1a}$ 的边集为 $E_{1a} = \\{(2,3), (3,5), (5,6)\\}$。\n    - $G_{1a}$ 中的度数：$\\deg(2)=1, \\deg(3)=2, \\deg(5)=2, \\deg(6)=1$。\n    - **规则 3 (高度数)：** $\\deg(3)=2 > k=1$。选择 $v_0=3$。递归调用 `CountLeaves($G_{1a} - \\{3\\}, 0$)`。\n      - **子调用 1.1.1：** `CountLeaves($G_{1b}, 0$)`\n        - $k=0$。$G_{1b}$ 的边集为 $E_{1b} = \\{(5,6)\\}$。\n        - **规则 2 (失败)：** $k \\le 0$ 且 $E_{1b} \\neq \\emptyset$。这是一个**失败叶节点**。返回 1。\n- 分支 1 的结果是 1。\n\n**追踪分支 2：** `CountLeaves($G_2, 2$)`\n- $k=2$。图 $G_2$ 的边集为 $E_2 = \\{(1,3), (3,5), (4,5), (4,6), (5,6)\\}$。\n- $G_2$ 中的度数：$\\deg(1)=1$, $\\deg(3)=2$, $\\deg(4)=2$, $\\deg(5)=3$, $\\deg(6)=2$。\n- **规则 3 (高度数)：** $\\deg(5)=3 > k=2$。选择 $v_0=5$。不分支，递归调用 `CountLeaves($G_2 - \\{5\\}, 1$)`。\n  - **子调用 2.1：** `CountLeaves($G_{2a}, 1$)`\n    - $k=1$。$G_{2a}$ 的边集为 $E_{2a} = \\{(1,3), (4,6)\\}$。\n    - $G_{2a}$ 中的度数：$\\deg(1)=1, \\deg(3)=1, \\deg(4)=1, \\deg(6)=1$。\n    - 规则 3 不适用。\n    - **规则 4 (度为 1)：** 索引最小的度为 1 的顶点是 $v_0=1$，其邻居是 $u_0=3$。选择邻居 $u_0=3$。递归调用 `CountLeaves($G_{2a} - \\{3\\}, 0$)`。\n      - **子调用 2.1.1：** `CountLeaves($G_{2b}, 0$)`\n        - $k=0$。$G_{2b}$ 的边集为 $E_{2b} = \\{(4,6)\\}$。\n        - **规则 2 (失败)：** $k \\le 0$ 且 $E_{2b} \\neq \\emptyset$。这是一个**失败叶节点**。返回 1。\n- 分支 2 的结果是 1。\n\n**总结：**\n总叶节点数 = (分支 1 的叶节点数) + (分支 2 的叶节点数) = $1 + 1 = 2$。", "answer": "\\boxed{2}", "id": "61767"}]}