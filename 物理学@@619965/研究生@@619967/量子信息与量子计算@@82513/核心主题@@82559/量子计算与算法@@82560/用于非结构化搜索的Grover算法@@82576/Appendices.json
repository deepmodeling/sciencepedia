{"hands_on_practices": [{"introduction": "我们的实践探索始于一个结合了理论与实际考量的问题。Grover 算法的理论通常假设搜索空间的大小 $N$ 是 2 的整数次幂，但现实世界中的问题很少如此规整。这个练习 [@problem_id:1426398] 将引导你处理一个大小为 $N=10$ 的搜索空间，这需要你首先将其嵌入到一个更大的、由量子比特自然构成的 $2^n$ 维希尔伯特空间中。通过计算单次 Grover 迭代后的成功概率，你将亲眼见证振幅放大的力量，并掌握在非理想化场景下应用该算法的第一个关键步骤。", "problem": "一个量子算法被用来在一组10个不同的候选解中搜索一个唯一的解。该搜索是使用Grover算法实现的。该量子系统被初始化为表示10个候选解所需的最少量子比特数的所有计算基态的等幅叠加态，以及填充量子比特寄存器所需的任何附加辅助态。一次完整的Grover迭代包括一次神谕（oracle）算符的应用（它会翻转被标记解的状态的振幅符号），然后是一次Grover扩散算符的应用。\n\n计算在一次完整的Grover迭代后，测量得到对应于唯一解的状态的概率。将你的最终答案四舍五入到四位有效数字。", "solution": "我们必须使用最少数量的量子比特以二进制表示10个候选解。满足 $2^{n} \\geq 10$ 的最小整数 $n$ 是 $n=4$，因此希尔伯特空间有 $N=2^{4}=16$ 个计算基态。恰好有一个基态被标记，其余的 $N-1=15$ 个状态是未标记的。系统被初始化为所有 $N$ 个基态的均匀叠加态：\n$$\n|s\\rangle=\\frac{1}{\\sqrt{N}}\\sum_{x=0}^{N-1}|x\\rangle.\n$$\n定义 $|w\\rangle$ 为标记的基态（由于只有一个唯一解，标记态的等幅叠加就是那个基态本身），$|r\\rangle$ 为所有未标记基态的归一化等幅叠加。于是 $|s\\rangle$ 分解为\n$$\n|s\\rangle=\\sin\\theta\\,|w\\rangle+\\cos\\theta\\,|r\\rangle,\n$$\n其中\n$$\n\\sin\\theta=\\sqrt{\\frac{M}{N}}=\\sqrt{\\frac{1}{16}}=\\frac{1}{4},\\qquad \\cos\\theta=\\sqrt{\\frac{N-M}{N}}=\\sqrt{\\frac{15}{16}},\n$$\n这里 $M=1$ 是标记态的数量。\n\n单次Grover迭代（一个神谕算符加上一个扩散算符）在由 $\\{|w\\rangle,|r\\rangle\\}$ 张成的二维子空间中实现一个角度为 $2\\theta$ 的旋转。经过 $k$ 次迭代，状态变为\n$$\n|\\psi_{k}\\rangle=\\sin\\bigl((2k+1)\\theta\\bigr)\\,|w\\rangle+\\cos\\bigl((2k+1)\\theta\\bigr)\\,|r\\rangle.\n$$\n对于一次迭代，$k=1$，所以标记态的振幅是 $\\sin(3\\theta)$。使用三倍角恒等式\n$$\n\\sin(3\\theta)=3\\sin\\theta-4\\sin^{3}\\theta,\n$$\n并代入 $\\sin\\theta=\\frac{1}{4}$ 得\n$$\n\\sin(3\\theta)=3\\cdot\\frac{1}{4}-4\\left(\\frac{1}{4}\\right)^{3}=\\frac{3}{4}-\\frac{4}{64}=\\frac{3}{4}-\\frac{1}{16}=\\frac{11}{16}.\n$$\n因此，在一次Grover迭代后测量到标记态的概率是\n$$\nP=\\left|\\sin(3\\theta)\\right|^{2}=\\left(\\frac{11}{16}\\right)^{2}=\\frac{121}{256}=0.47265625.\n$$\n四舍五入到四位有效数字，得到 $0.4727$。", "answer": "$$\\boxed{0.4727}$$", "id": "1426398"}, {"introduction": "在理解了 Grover 迭代的整体效果之后，我们自然会问：算法的核心部件——“神谕”(oracle)——在物理上是如何实现的？这个练习 [@problem_id:1426395] 将带领我们从抽象的算符转向具体的量子电路。你的任务是使用基本的量子门来构建一个能够标记特定状态的神谕电路，这个过程是连接量子算法理论与未来量子计算机硬件编程的关键桥梁，也是所有量子算法设计师必须掌握的基本技能。", "problem": "在一个三量子比特系统的量子搜索算法的开发中，一个关键组成部分是“神谕”算符 $U_w$。该算符被设计用于识别一个特定的“标记”计算基态 $|w\\rangle$，方法是向其施加一个 $-1$ 的相移，同时保持所有其他基态不变。神谕的作用被正式描述为变换 $U_w|x\\rangle = (-1)^{f(x)}|x\\rangle$，其中当输入态 $|x\\rangle$ 是标记态 $|w\\rangle$ 时，$f(x)=1$；否则 $f(x)=0$。\n\n考虑一个三量子比特寄存器，其中的量子比特从右到左索引，因此一个通用基态写作 $|q_2 q_1 q_0\\rangle$。我们搜索问题的标记态是 $|w\\rangle = |110\\rangle$。\n\n你被提供一个用于构建神谕的基本量子门库。该库包括：\n1.  一个单量子比特泡利X门，记作 $X_k$，作用于量子比特 $k$。该门翻转量子比特的状态，使得 $X_k|0\\rangle = |1\\rangle$ 且 $X_k|1\\rangle = |0\\rangle$。\n2.  一个三量子比特双控Z门，记作 $CCZ_{i,j,k}$。该门当且仅当两个控制量子比特 $i$ 和 $j$ 都处于 $|1\\rangle$ 态时，对目标量子比特 $k$ 施加一个泡利Z门。泡利Z门对 $|1\\rangle$ 态施加一个相位翻转（$Z|1\\rangle = -|1\\rangle$），并保持 $|0\\rangle$ 态不变（$Z|0\\rangle = |0\\rangle$）。因此，$CCZ_{i,j,k}$ 门仅对量子比特 $i, j, k$ 全为 $|1\\rangle$ 的基态施加一个 $-1$ 的相位。\n\n门序列按照从右到左的施加顺序书写。例如，序列 $A \\cdot B \\cdot C$ 表示首先施加门 $C$，然后是门 $B$，最后是门 $A$。\n\n以下哪个门序列正确地实现了标记态 $|w\\rangle = |110\\rangle$ 所需的神谕？\n\nA. $CCZ_{2,1,0}$\n\nB. $X_0 \\cdot CCZ_{2,1,0} \\cdot X_0$\n\nC. $X_2 \\cdot CCZ_{2,1,0} \\cdot X_2$\n\nD. $X_1 \\cdot CCZ_{2,1,0} \\cdot X_1$\n\nE. $X_2 \\cdot X_1 \\cdot CCZ_{2,1,0} \\cdot X_1 \\cdot X_2$", "solution": "我们需要一个神谕 $U_{w}$，其对计算基态的作用如下\n$$\nU_{w}|q_{2}q_{1}q_{0}\\rangle =\n\\begin{cases}\n-\\,|q_{2}q_{1}q_{0}\\rangle, & \\text{if } |q_{2}q_{1}q_{0}\\rangle=|110\\rangle,\\\\\n\\;\\;|q_{2}q_{1}q_{0}\\rangle, & \\text{otherwise}.\n\\end{cases}\n$$\n等价地，对于比特值 $q_{k}\\in\\{0,1\\}$，这可以表示为\n$$\nU_{w}|q_{2}q_{1}q_{0}\\rangle = (-1)^{q_{2}q_{1}(1-q_{0})}|q_{2}q_{1}q_{0}\\rangle,\n$$\n因此只有 $q_{2}=1$, $q_{1}=1$, $q_{0}=0$ 的状态会获得一个 $-1$ 的相位。\n\n可用的 $CCZ_{2,1,0}$ 门仅对 $|111\\rangle$ 施加一个 $-1$ 的相位，即\n$$\nCCZ_{2,1,0}|q_{2}q_{1}q_{0}\\rangle = (-1)^{q_{2}q_{1}q_{0}}|q_{2}q_{1}q_{0}\\rangle.\n$$\n为了将标记模式从 $|111\\rangle$ 移动到 $|110\\rangle$，我们用 $X_{0}$ 对 $CCZ_{2,1,0}$ 进行共轭操作，即在其前后翻转第三个量子比特（目标比特）：\n$$\nU := X_{0}\\cdot CCZ_{2,1,0}\\cdot X_{0}.\n$$\n作用于一个通用基态，\n1) 最右边的 $X_{0}$ 将 $|q_{2}q_{1}q_{0}\\rangle$ 映射到 $|q_{2}q_{1}\\bar{q}_{0}\\rangle$，其中 $\\bar{q}_{0}=1-q_{0}$。\n2) 然后 $CCZ_{2,1,0}$ 贡献一个 $-1$ 的相位，当且仅当 $q_{2}=1$，$q_{1}=1$ 且 $\\bar{q}_{0}=1$，即恰好在 $q_{2}=1$，$q_{1}=1$，$q_{0}=0$ 时。\n3) 最左边的 $X_{0}$ 恢复第三个量子比特，得到原始基态和预期的相位。\n\n因此\n$$\n\\left(X_{0}\\cdot CCZ_{2,1,0}\\cdot X_{0}\\right)|q_{2}q_{1}q_{0}\\rangle\n= (-1)^{q_{2}q_{1}(1-q_{0})}|q_{2}q_{1}q_{0}\\rangle,\n$$\n这正是标记态 $|110\\rangle$ 所需的神谕。\n\n验证其他选项：\n- 单独的 $CCZ_{2,1,0}$ 标记 $|111\\rangle$，而不是 $|110\\rangle$。\n- $X_{2}\\cdot CCZ_{2,1,0}\\cdot X_{2}$ 标记 $q_{2}=0$, $q_{1}=1$, $q_{0}=1$ 的状态，即 $|011\\rangle$。\n- $X_{1}\\cdot CCZ_{2,1,0}\\cdot X_{1}$ 标记 $|101\\rangle$。\n- $X_{2}\\cdot X_{1}\\cdot CCZ_{2,1,0}\\cdot X_{1}\\cdot X_{2}$ 标记 $|001\\rangle$。\n\n因此，正确的序列是 $X_{0}\\cdot CCZ_{2,1,0}\\cdot X_{0}$，即选项 B。", "answer": "$$\\boxed{B}$$", "id": "1426395"}, {"introduction": "单次迭代可以提升找到标记项的概率，但这通常远未达到最优。Grover 算法的真正威力在于其迭代特性，但过犹不及——迭代次数过多反而会降低成功率。这个练习 [@problem_id:1426405] 让你直面优化问题：对于一个大规模的搜索任务，应执行多少次 Grover 迭代才能最大化成功的机会？通过计算这个最佳迭代次数，你将深入理解算法的周期性行为，并掌握有效利用 Grover 算法解决实际问题所需的核心性能分析方法。", "problem": "一个网络安全团队正在使用一台量子计算机来搜索一个密码系统中的漏洞。总搜索空间包含 $N = 2^{10}$ 种可能的配置。由于一个设计缺陷，已知这些配置中恰好有 $M=4$ 个是“弱”配置，如果被找到将会危及系统的安全。该团队采用 Grover 搜索算法来寻找这些弱配置中的一个。\n\n在 Grover 算法中，一个被称为“Grover 迭代”的量子操作序列会重复地应用于一个量子态。在一定数量的迭代之后，会进行一次测量。测量到弱配置的概率取决于所执行的迭代次数。\n\n确定该团队应该执行的 Grover 迭代的最优次数 $k$，以便在测量时有最高的概率识别出弱配置。迭代次数必须为整数。", "solution": "设 $N$ 为项目总数，$M$ 为标记（弱）项目的数量。在 Grover 算法中，定义角度 $\\theta$ 为\n$$\n\\sin(\\theta)=\\sqrt{\\frac{M}{N}}.\n$$\n经过 $k$ 次 Grover 迭代后，成功概率为\n$$\nP(k)=\\sin^{2}\\big((2k+1)\\theta\\big).\n$$\n当 $(2k+1)\\theta$ 尽可能接近 $\\frac{\\pi}{2}$ 时，该概率达到最大值，从而得到最优迭代次数\n$$\nk^{\\ast}=\\left\\lfloor \\frac{\\pi}{4\\theta}-\\frac{1}{2}\\right\\rfloor.\n$$\n对于给定的值 $N=2^{10}$ 和 $M=4$，\n$$\n\\sqrt{\\frac{M}{N}}=\\sqrt{\\frac{4}{2^{10}}}=\\sqrt{\\frac{1}{256}}=\\frac{1}{16},\n$$\n所以\n$$\n\\theta=\\arcsin\\!\\left(\\frac{1}{16}\\right).\n$$\n因此，\n$$\nk^{\\ast}=\\left\\lfloor \\frac{\\pi}{4\\arcsin\\!\\left(\\frac{1}{16}\\right)}-\\frac{1}{2}\\right\\rfloor.\n$$\n为选择正确的整数，进行近似评估。使用 $\\arcsin(x)$ 在 $x=\\frac{1}{16}$ 处的级数展开，\n$$\n\\arcsin(x)=x+\\frac{x^{3}}{6}+\\frac{3x^{5}}{40}+\\frac{5x^{7}}{112}+\\cdots,\n$$\n可得\n$$\n\\theta=\\arcsin\\!\\left(\\frac{1}{16}\\right)\\approx 0.062540761796,\n$$\n因此\n$$\n\\frac{\\pi}{4\\theta}\\approx \\frac{3.141592653589793}{4\\times 0.062540761796}\\approx 12.5581803,\n$$\n所以\n$$\n\\frac{\\pi}{4\\theta}-\\frac{1}{2}\\approx 12.0581803.\n$$\n取底函数得到 $k^{\\ast}=12$。等价地，使用常用近似公式 $k\\approx \\left\\lfloor \\frac{\\pi}{4}\\sqrt{\\frac{N}{M}} \\right\\rfloor$ 可得 $\\left\\lfloor \\frac{\\pi}{4}\\cdot 16 \\right\\rfloor=\\left\\lfloor 4\\pi \\right\\rfloor=12$，这与更精确的计算结果一致。", "answer": "$$\\boxed{12}$$", "id": "1426405"}]}