{"hands_on_practices": [{"introduction": "要真正理解计算的本质，没有比亲手操作图灵机更好的方法了。这个练习旨在揭开图灵机这一基本计算模型的神秘面纱，通过追踪一台执行简单操作的图灵机，您将直观地感受到一系列简单规则如何实现复杂的计算任务。这个实践将帮助您为算法的执行建立起一种机械式的直觉 [@problem_id:93270]。", "problem": "一台特定的图灵机由状态集合 $Q = \\{q_0, q_1, q_2, q_h\\}$ 定义，其中 $q_0$ 是起始状态，$q_h$ 是停机状态。纸带字母表为 $\\Gamma = \\{0, 1, X, B\\}$，其中 $B$ 是空白符号。该图灵机的行为由以下转移函数 $\\delta(q, s) = (q', s', d)$ 描述，其中 $q$ 是当前状态，$s$ 是读写头下的符号，$q'$ 是下一个状态，$s'$ 是要写入纸带的符号，$d \\in \\{L, R\\}$ 是读写头移动的方向。\n\n转移规则如下：\n1.  $\\delta(q_0, 1) = (q_1, X, R)$\n2.  $\\delta(q_0, X) = (q_0, X, R)$\n3.  $\\delta(q_0, 0) = (q_h, 0, R)$\n4.  $\\delta(q_1, 1) = (q_1, 1, R)$\n5.  $\\delta(q_1, 0) = (q_1, 0, R)$\n6.  $\\delta(q_1, B) = (q_2, B, L)$\n7.  $\\delta(q_2, 1) = (q_2, 1, L)$\n8.  $\\delta(q_2, 0) = (q_2, 0, L)$\n9.  $\\delta(q_2, X) = (q_2, X, L)$\n10. $\\delta(q_2, B) = (q_0, B, R)$\n\n该图灵机从包含字符串 `1^n01^m` 的纸带开始运行，其中 $n$ 和 $m$ 为非负整数，字符串两侧由空白符号包围。纸带的配置为 `... B B 1...1 0 1...1 B B ...`，其中第一个 `1...1` 长度为 $n$，第二个 `1...1` 长度为 $m$。读写头初始位置在输入字符串的最左边符号上。如果 $n>0$，则为第一个 '1'。如果 $n=0$，则字符串为 `01^m`，读写头从 '0' 开始。\n\n计算图灵机进入停机状态 $q_h$ 所需的总步数，并将其表示为参数 $n$ 和 $m$ 的函数。", "solution": "我们分析一个“标记并返回”的周期，该周期对初始的 $n$ 个 1 中的每一个重复一次，然后进行最后一次扫描以停机。\n\n1. 在状态 $q_0$ 中，对于第 $i$ 个周期，读写头从最左边的符号（位置1）开始，向右移动越过 $i-1$ 个 X，然后读取第 $i$ 个未标记的 1：\n$$\\text{在 }q_0 \\text{ 中的步数} = (i-1)+1 = i.$$\n\n2. 将该 1 标记为 X 并进入 $q_1$ 状态后，读写头从位置 $i+1$ 向右移动到位于 $n+2+m$ 的第一个空白符号 `B` 处，包括该空白单元格：\n$$\\text{在 }q_1 \\text{ 中的步数} = (n+2+m)-(i+1)+1 = n+m+2-i.$$\n\n3. 读取空白符号 `B` 并进入 $q_2$ 状态后，读写头从位置 $n+1+m$ 向左移动，回到位置 0 处的空白符号 `B`，包括该空白符号：\n$$\\text{在 }q_2 \\text{ 中的步数} = (n+1+m)-0+1 = n+m+2.$$\n\n4. 每个周期的总步数（与 $i$ 无关）：\n$$i + (n+m+2-i) + (n+m+2) = 2n + 2m + 4.$$\n\n5. 对 $i=1,\\dots,n$ 求和可得\n$$n(2n+2m+4)=2n^2+2nm+4n.$$\n\n6. 在第 $n$ 个周期之后，图灵机在位置 1 返回到状态 $q_0$，跳过所有 $n$ 个 X，然后读取 0 并停机。这额外增加了\n$$n + 1$$\n步。\n\n7. 总步数：\n$$2n^2 +2nm+4n + (n+1)=2n^2+2nm+5n+1.$$\n可以验证，当 $n=0$ 时，该公式的结果为 1，与单步停机的情况相符。\n\n因此，图灵机在\n$$2n^2 +2nm+5n +1$$\n步后停机。", "answer": "$$\\boxed{2n^2 + 2nm + 5n + 1}$$", "id": "93270"}, {"introduction": "在了解了图灵机的顺序计算模型后，我们转向另一种核心模型：布尔电路，它更贴近现代计算机硬件的并行特性。此问题以奇偶校验函数为核心，这是一个在计算复杂性理论中具有基石地位的例子。通过分析计算该函数所需电路的“深度”，您将学习到一个衡量并行计算时间效率的重要指标 [@problem_id:93272]。", "problem": "在经典计算理论中，布尔电路是一个表示布尔函数的有向无环图。图的顶点称为门，边表示导线。入度为0的顶点是电路的输入，而一些指定的顶点是输出。每个非输入门代表一种布尔运算，例如与 (AND)、或 (OR)、非 (NOT) 或异或 (XOR)。\n\n电路的深度定义为从任意输入顶点到任意输出顶点的最长路径的长度。这个度量对于理解函数的并行计算时间至关重要。\n\n考虑计算一个二进制字符串的奇偶性问题。一个字符串 $x = x_1x_2...x_n$ 的奇偶性定义为 $P(x) = x_1 \\oplus x_2 \\oplus \\dots \\oplus x_n$，其中 $\\oplus$ 表示异或 (XOR) 运算，等价于模2加法。\n\n我们的任务是设计一个电路，用于计算长度为 $n = 2^k$ 的输入字符串的奇偶性，其中 $k$ 是一个正整数。该电路只能使用双输入异或门。设计遵循一种特定的级联结构：\n1.  第一层门接收初始的 $n$ 个输入位，并成对计算它们的异或。\n2.  随后的每一层都接收前一层的输出，并成对计算它们的异或。\n3.  这个过程持续进行，直到产生一个代表最终奇偶性的单个比特。\n\n求这个奇偶校验电路的深度，并将其表示为 $k$ 的函数。", "solution": "用于计算长度为 $n = 2^k$ 的输入字符串奇偶性的电路，是通过分层重复应用双输入异或门来构建的。其深度是将输入减少到单个输出比特所需的层数。\n\n- 最初，有 $n = 2^k$ 个输入位。\n- 经过第一层后，比特数减半至 $n/2 = 2^{k-1}$，因为每个异或门组合了两个比特。\n- 经过第二层后，比特数再次减半至 $2^{k-2}$。\n- 这种减半过程一直持续到只剩下一个比特。\n\n设深度为 $d$。经过 $d$ 层后，比特数为 $2^{k-d}$。将其设为1，可得：\n\n$$\n2^{k-d} = 1\n$$\n\n因为 $2^0 = 1$，所以：\n\n$$\nk - d = 0\n$$\n\n解出 $d$：\n\n$$\nd = k\n$$\n\n因此，电路的深度为 $k$。", "answer": "$$ \\boxed{k} $$", "id": "93272"}, {"introduction": "虽然图灵机和布尔电路看起来是两种截然不同的计算模型，但它们之间存在深刻的联系。本练习将明确地揭示这一联系，要求您为一台判断奇偶性的图灵机设计其“大脑”——也就是控制单元的逻辑电路。这个过程将向您展示，图灵机的状态转移函数可以完全通过布尔逻辑来实现，从而体现了不同计算范式之间的内在统一性 [@problem_id:93292]。", "problem": "一台图灵机（TM）被设计用于判定语言 $L$，该语言由含有偶数个1的二进制字符串组成。该语言定义在字母表 $\\Sigma = \\{0, 1\\}$ 上。该图灵机的设计细节如下：\n\n1.  **状态：** 非停机状态的集合为 $Q = \\{q_{\\text{even}}, q_{\\text{odd}}\\}$，其中 $q_{\\text{even}}$ 是起始状态。\n2.  **带字母表：** 带字母表为 $\\Gamma = \\{0, 1, B\\}$，其中 $B$ 是空白符号。\n3.  **操作：** 图灵机从状态 $q_{\\text{even}}$ 开始，其读写头位于输入字符串最左侧的符号上。它从左到右读取字符串。\n    *   如果读到 `0`，其状态不改变。\n    *   如果读到 `1`，其状态翻转（从 $q_{\\text{even}}$ 到 $q_{\\text{odd}}$ 或反之）。\n    *   当读取 `0` 或 `1` 时，它将相同的符号写回带上，并将其读写头向右（R）移动。\n    *   当读取到第一个空白符号 `B`（表示输入结束）时，它停机。如果它从状态 $q_{\\text{even}}$ 停机，则输入字符串被接受。如果它从状态 $q_{\\text{odd}}$ 停机，则输入被拒绝。停机时，它将 `B` 写回带上并向右移动。\n\n该图灵机的转移函数将被实现为一个组合逻辑电路。该电路的输入和输出由基于特定编码方案的布尔变量表示：\n\n*   **输入：**\n    *   当前非停机状态由单个比特 $s_c$ 编码，其中 $q_{\\text{even}} \\leftrightarrow 0$ 且 $q_{\\text{odd}} \\leftrightarrow 1$。\n    *   从带上读取的符号由两个比特 $t_1t_0$ 编码，其中 $0 \\leftrightarrow 00$，$1 \\leftrightarrow 01$，且 $B \\leftrightarrow 10$。假定输入比特组合 $t_1t_0 = 11$ 永远不会出现。\n\n*   **输出：** 电路有五个输出比特：\n    *   $H$：一个停机信号。如果机器停机，则 $H=1$，否则 $H=0$。\n    *   $s_n$：下一个状态比特，编码方式与 $s_c$ 相同。此输出仅在 $H=0$ 时有意义；如果 $H=1$，其值为“无关项”。\n    *   $t'_1t'_0$：要写入带上的符号的两个比特，使用与输入符号相同的编码。\n    *   $d$：读写头移动方向。$d=1$ 表示向右（R），$d=0$ 表示向左（L）。\n\n您的任务是确定此转移函数的逻辑总规模。规模定义为所有五个输出函数（$H, s_n, t'_1, t'_0, d$）的最小析取范式（DNF）表达式中字面量 (literal) 的总数。一个字面量是一个变量或其否定（例如，表达式 $a\\bar{b} \\lor c$ 有3个字面量）。", "solution": "我们将输入比特索引为 $s=s_c$, $t_1,t_0$。我们有三类实际的符号：\n(1) $t_1t_0=00$（‘0’），\n(2) $t_1t_0=01$（‘1’），\n(3) $t_1t_0=10$（空白，停机）。$t_1t_0=11$ 的情况未使用。\n\n将6个实际输入行列表，输出为 $(H,s_n,t'_1,t'_0,d)$：\n\n1.  $t=00,s=0$：读取‘0’⇒ 保持在偶数状态 ⇒ $H=0,\\;s_n=0,\\;t'=00,\\;d=1$。\n2.  $t=00,s=1$：读取‘0’⇒ 保持在奇数状态 ⇒ $H=0,\\;s_n=1,\\;t'=00,\\;d=1$。\n3.  $t=01,s=0$：读取‘1’⇒ 翻转到奇数状态 ⇒ $H=0,\\;s_n=1,\\;t'=01,\\;d=1$。\n4.  $t=01,s=1$：读取‘1’⇒ 翻转到偶数状态 ⇒ $H=0,\\;s_n=0,\\;t'=01,\\;d=1$。\n5.  $t=10,s=0$：空白 ⇒ 在偶数状态停机 ⇒ $H=1,\\;s_n=\\text{dc},\\;t'=10,\\;d=1$。\n6.  $t=10,s=1$：空白 ⇒ 在奇数状态停机 ⇒ $H=1,\\;s_n=\\text{dc},\\;t'=10,\\;d=1$。\n\n我们可以选择在空白符号输入时 $s_n$ 的“无关项”值以进行最小化。当 $t=10$ 时，设 $s_n=0$。\n\n现在为每个输出推导最小DNF：\n\n1.  $H=1$ 当且仅当 $t_1t_0=10$。因此\n    $$H = t_1 \\land \\neg t_0$$\n    一项，2个字面量。\n\n2.  对于所有实际输入，$d=1$ ⇒ 恒为 1。DNF有0个字面量。\n\n3.  $t'_1$ 等于1当且仅当 $t_1=1$（空白），否则为0。所以\n    $$t'_1 = t_1$$\n    一项，1个字面量。\n\n4.  对于所有实际输入，$t'_0$ 等于 $t_0$ ⇒\n    $$t'_0 = t_0$$\n    一项，1个字面量。\n\n5.  当输入为 $00$ 时，$s_n= s$；当输入为 $01$ 时，$s_n= \\neg s$；当输入为 $10$ 时，$s_n=0$。因此\n    $$s_n = (\\neg t_1 \\land \\neg t_0 \\land s) \\lor (\\neg t_1 \\land t_0 \\land \\neg s)$$\n    两个积项，每个积项有3个字面量 ⇒ 总共6个字面量。\n\n字面量求和：$H:2,\\;d:0,\\;t'_1:1,\\;t'_0:1,\\;s_n:6$。\n总字面量 $=2+0+1+1+6=10$。", "answer": "$$\\boxed{10}$$", "id": "93292"}]}