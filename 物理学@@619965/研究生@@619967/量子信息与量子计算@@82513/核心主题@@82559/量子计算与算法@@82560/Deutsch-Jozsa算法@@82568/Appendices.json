{"hands_on_practices": [{"introduction": "理论的理想化是完美的，但现实世界中的量子计算机总会伴随着噪声。这些动手实践旨在引导您超越理想化的模型，去探索和理解噪声与更高级的量子现象如何影响算法的实际表现。我们的第一个实践将探讨一种最基本的误差来源：不完美的状态制备。我们将研究当关键的辅助量子比特并非完美地初始化在 $|1\\rangle$ 态，而是处于一个概率性混合态时，算法的性能会发生什么变化。这个练习将引导您使用密度矩阵这一核心工具来分析算法在面对实际硬件缺陷时的稳健性。[@problem_id:151531]", "problem": "Deutsch-Jozsa 算法提供了一种方法，用于确定一个函数 $f: \\{0,1\\}^n \\to \\{0,1\\}$ 的性质。该函数保证是*常数*函数（对于所有输入，输出都相同）或*平衡*函数（对于恰好一半的输入，输出为0，对于另一半，输出为1）。\n\n标准算法使用一个量子线路，该线路包含 $n$ 个输入量子比特和一个目标（或辅助）量子比特。初始状态为 $|0\\rangle^{\\otimes n}|1\\rangle$。该线路施加一系列门操作：\n1. 对每个 $n+1$ 量子比特施加一个 Hadamard 门。\n2. 函数谕示 $U_f$，它执行变换 $|x\\rangle|y\\rangle \\mapsto |x\\rangle|y \\oplus f(x)\\rangle$。\n3. 对前 $n$ 个输入量子比特各施加一个 Hadamard 门。\n\n最后，对前 $n$ 个量子比特进行计算基测量。如果结果是全零状态 $|0\\rangle^{\\otimes n}$，则函数被判断为常数函数。如果得到任何其他结果，则函数被判断为平衡函数。在其理想形式下，该算法是确定性的，并且总是给出正确的答案。\n\n考虑对该过程的一个修改，其中目标量子比特的态制备是不完美的。$n$ 个输入量子比特被正确地制备在状态 $|0\\rangle^{\\otimes n}$ 中。然而，目标量子比特被制备在由以下密度算符描述的混合态中：\n$$\n\\rho_{\\text{target}} = (1-p) |1\\rangle\\langle 1| + p |0\\rangle\\langle 0|\n$$\n其中 $p \\in [0, 1]$ 是一个表征制备误差的参数。\n\n算法的其余部分（步骤1-3和最终的测量规则）按上述方式进行。假设已知函数 $f$ 是一个平衡函数。计算该算法正确地将其识别为平衡函数的概率。", "solution": "如果对前 $n$ 个量子比特的测量结果不是全零状态 $|0\\rangle^{\\otimes n}$，那么该算法就正确地将函数识别为平衡函数。$n$ 个输入量子比特的初始状态是 $|0\\rangle^{\\otimes n}$，而目标量子比特处于混合态：\n\n$$\n\\rho_{\\text{target}} = (1-p) |1\\rangle\\langle 1| + p |0\\rangle\\langle 0|.\n$$\n\n这个混合态对应于两种情形：\n- 情形A：目标量子比特是 $|1\\rangle$ 的概率为 $1-p$。\n- 情形B：目标量子比特是 $|0\\rangle$ 的概率为 $p$。\n\n在情形A中（目标量子比特初始为 $|1\\rangle$），线路是理想的。在施加 Hadamard 门、谕示 $U_f$ 和另一组 Hadamard 门之后，对于一个平衡函数 $f$，前 $n$ 个量子比特的状态在 $|0\\rangle^{\\otimes n}$ 上的幅为零。因此，测量到 $|0\\rangle^{\\otimes n}$ 的概率为 0。\n\n在情形B中（目标量子比特初始为 $|0\\rangle$），在第一批 Hadamard 门之后，目标量子比特的状态为 $|+\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}$。谕示 $U_f$ 的作用为 $|x\\rangle|y\\rangle \\mapsto |x\\rangle|y \\oplus f(x)\\rangle$。由于：\n\n$$\nU_f |x\\rangle|+\\rangle = |x\\rangle \\frac{|f(x)\\rangle + |1 \\oplus f(x)\\rangle}{\\sqrt{2}} = |x\\rangle|+\\rangle,\n$$\n\n状态在 $U_f$ 作用下保持不变。在对前 $n$ 个量子比特施加最后的 Hadamard 门之后，状态变为 $|0\\rangle^{\\otimes n} \\otimes |+\\rangle$。因此，对前 $n$ 个量子比特的测量总是以概率 1 得到 $|0\\rangle^{\\otimes n}$。\n\n测量到 $|0\\rangle^{\\otimes n}$ 的总概率是加权平均值：\n\n$$\nP(\\text{measure } |0\\rangle^{\\otimes n}) = (1-p) \\cdot 0 + p \\cdot 1 = p.\n$$\n\n如果测量到 $|0\\rangle^{\\otimes n}$，算法会错误地将函数判断为常数函数。由于函数是平衡的，正确识别（判断为平衡）的概率是：\n\n$$\nP(\\text{correct}) = 1 - P(\\text{measure } |0\\rangle^{\\otimes n}) = 1 - p.\n$$", "answer": "$$ \\boxed{1 - p} $$", "id": "151531"}, {"introduction": "在状态制备误差的基础上，我们进一步探讨在量子计算过程中发生的误差。本次实践将聚焦于一种普遍存在于多种量子计算架构中的相干误差——“串扰”（crosstalk）。我们将模拟在执行预言机操作时，相邻的输入量子比特之间发生不期望的相互作用。通过这个练习，您将深入理解这种不必要的量子耦合如何引入破坏性的相位，从而影响算法的最终结果，这是量子硬件独有的挑战。[@problem_id:151393]", "problem": "Deutsch-Jozsa 算法用于判断一个函数 $f: \\{0, 1\\}^n \\to \\{0, 1\\}$ 是常数函数还是平衡函数，并保证该函数是这两种情况之一。该算法使用一个 $n$ 量子比特的输入寄存器和一个单个量子比特的辅助寄存器。\n\n标准算法流程如下：\n1.  将状态初始化为 $|0\\rangle^{\\otimes n} |1\\rangle$。\n2.  对每个量子比特应用一个 Hadamard 门 $H$，制备出状态 $\\frac{1}{\\sqrt{2^n}} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle)$。\n3.  应用神谕查询 $U_f$，其作用是将 $|x\\rangle|y\\rangle$ 映射到 $|x\\rangle|y \\oplus f(x)\\rangle$。对所制备状态的作用会引发一个相位反冲，将输入寄存器的状态变换为 $\\frac{1}{\\sqrt{2^n}} \\sum_{x \\in \\{0,1\\}^n} (-1)^{f(x)} |x\\rangle$。辅助量子比特保持在状态 $\\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle)$，此后可以忽略。\n4.  对输入寄存器的每个量子比特应用一个 Hadamard 门 $H$。\n5.  在计算基下测量输入寄存器。如果结果为 $|0\\rangle^{\\otimes n}$，则断定该函数为常数函数。否则，断定其为平衡函数。对于一个理想的神谕，这个判断总是正确的。\n\n考虑一个实际实现，其中输入寄存器的 $n$ 个量子比特排列成一维链状。在应用神谕的步骤中，相邻量子比特之间会发生寄生的 ZZ 串扰相互作用。这个相干误差可以用一个酉算符 $U_{err}$ 来建模，它在理想神谕 $U_f$ 之后立即作用于输入寄存器。因此，在神谕步骤中的总变换是 $U_{err} U_f$。\n\n该误差算符由下式给出：\n$$\nU_{err} = \\exp\\left(-i \\theta \\sum_{j=1}^{n-1} Z_j Z_{j+1}\\right)\n$$\n其中 $Z_j$ 是作用在第 $j$ 个量子比特上的泡利-Z 算符，$\\theta$ 是一个实的、无量纲的参数，它表征了寄生相互作用的强度。\n\n假设函数 $f$ 是常数函数，计算算法正确地将其识别出来的概率 $P_{success}$（即，对输入寄存器的最终测量得到 $|0\\rangle^{\\otimes n}$ 状态）。", "solution": "1. 对于常数函数，在理想神谕作用之后，输入寄存器处于一个乘积态，例如对于 $f(x)=c$ 的情况，状态为 $(-1)^c |+\\rangle^{\\otimes n}$。为简单起见，我们考虑 $f(x)=0$ 的情况，此时状态为 $|\\psi_1\\rangle = |+\\rangle^{\\otimes n}$。\n2. 相干误差酉算符为 \n$$U_{err}\n=\\exp\\Bigl(-i\\theta\\sum_{j=1}^{n-1}Z_jZ_{j+1}\\Bigr).$$\n3. 算法成功的振幅是通过施加最后的 Hadamard 层并投影到 $|0\\rangle^{\\otimes n}$ 上来计算的：\n$$A\n=\\langle 0|^{\\otimes n} H^{\\otimes n} U_{err} |+\\rangle^{\\otimes n}.$$\n4. 我们可以将基矢变换到 $H^{\\otimes n}$ 的右边，利用 $H Z H = X$ 和 $H|+\\rangle = |0\\rangle$。振幅变为：\n$$A\n=\\langle 0|^{\\otimes n}\\left(H^{\\otimes n} U_{err} H^{\\otimes n}\\right) (H^{\\otimes n}|+\\rangle^{\\otimes n})\n=\\langle 0|^{\\otimes n}\\exp\\Bigl(-i\\theta\\sum_{j=1}^{n-1}X_jX_{j+1}\\Bigr)|0\\rangle^{\\otimes n}.$$\n5. 由于各项算符 $X_jX_{j+1}$ 相互对易，指数算符可以因子化：\n$$\\exp\\Bigl(-i\\theta\\sum_{j=1}^{n-1}X_jX_{j+1}\\Bigr)\n=\\prod_{j=1}^{n-1}\\exp(-i\\theta X_jX_{j+1})=\\prod_{j=1}^{n-1}(\\cos\\theta\\,I - i\\sin\\theta\\,X_jX_{j+1}).$$\n当这个算符作用在 $|0\\rangle^{\\otimes n}$ 上时，任何包含 $X$ 算符的项都会翻转量子比特，使其与 $\\langle 0|^{\\otimes n}|$ 正交。因此，唯一对振幅有贡献的项是当我们从乘积的每个因子中都选择单位算符 $I$ 时。\n6. 因此，振幅是所有 $\\cos\\theta$ 项的乘积：\n$$A=\\langle 0|^{\\otimes n} (\\cos\\theta)^{n-1} I |0\\rangle^{\\otimes n} = (\\cos\\theta)^{n-1}.$$\n成功的概率为：\n$$P_{success}=|A|^2=\\cos^{2(n-1)}\\!\\theta.$$", "answer": "$$\\boxed{\\cos^{2(n-1)}\\!\\theta}$$", "id": "151393"}, {"introduction": "最后的实践将超越误差分析的范畴，深入探索量子计算的一个深刻而迷人的特性。我们将设想一个场景：算法所应用的不再是单个确定的预言机，而是由一个处于叠加态的量子比特来相干地控制对一个常数函数预言机和一个平衡函数预言机的选择。这种“计算的叠加”是量子并行性强大能力的极致体现，它将挑战我们去分析最终的测量结果如何依赖于这个相干控制参数，从而揭示量子算法更深层次的运作机理。[@problem_id:151519]", "problem": "考虑一个 Deutsch-Jozsa 算法的变体，其中涉及一个辅助量子比特，该比特相干地控制应用两个神谕中的哪一个。该系统由一个辅助量子比特、一个 $n$ 量子比特的输入寄存器和一个单位量子比特的输出寄存器组成。\n\n我们给定两个函数，$f_c: \\{0,1\\}^n \\to \\{0,1\\}$ 和 $f_b: \\{0,1\\}^n \\to \\{0,1\\}$。我们被承诺 $f_c$ 是一个常数函数（即对于所有 $x \\in \\{0,1\\}^n$，$f_c(x)$ 的值都相同），而 $f_b$ 是一个平衡函数（即对于恰好一半的可能输入 $x$，$f_b(x)=0$，对于另一半，$f_b(x)=1$）。\n\n量子电路由以下步骤定义：\n1.  辅助量子比特被初始化到状态 $|\\psi_a\\rangle = \\cos(\\theta) |0\\rangle + \\sin(\\theta) |1\\rangle$。\n2.  $n$ 量子比特的输入寄存器被初始化为 $|0\\rangle^{\\otimes n}$，输出量子比特被初始化为 $|1\\rangle$。\n3.  对 $n$ 个输入量子比特和输出量子比特都施加一个 Hadamard 门。\n4.  施加一个受控神谕操作 $C\\text{-}U$。如果辅助比特为 $|0\\rangle$，此酉算子在输入和输出寄存器上作用为 $U_{f_c}$；如果辅助比特为 $|1\\rangle$，则作用为 $U_{f_b}$。更正式地，$C\\text{-}U = |0\\rangle\\langle 0|_a \\otimes U_{f_c} + |1\\rangle\\langle 1|_a \\otimes U_{f_b}$，其中神谕 $U_f$ 通过其在计算基态上的作用来定义：$U_f|x\\rangle|y\\rangle = |x\\rangle|y \\oplus f(x)\\rangle$。\n5.  对辅助量子比特和 $n$ 个输入量子比特都施加一个 Hadamard 门。\n\n在完全演化之后，在计算基中测量 $n$ 量子比特的输入寄存器。计算在输入寄存器中测量到全零状态 $|0^n\\rangle$ 的概率。用参数 $\\theta$ 表示你的答案。", "solution": "1.  在受控神谕操作之前，系统的状态（忽略未纠缠的输出寄存器 $|-\\rangle$）为：\n    $$\n    |\\psi_{\\text{pre}}\\rangle = \\left( \\cos\\theta |0\\rangle_a + \\sin\\theta |1\\rangle_a \\right) \\otimes \\left( \\frac{1}{\\sqrt{2^n}} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle \\right)\n    $$\n2.  受控神谕 $C\\text{-}U$ 应用相位回踢。作用后的状态变为：\n    $$\n    |\\psi_{\\text{post}}\\rangle = \\cos\\theta |0\\rangle_a \\otimes |\\psi_c\\rangle + \\sin\\theta |1\\rangle_a \\otimes |\\psi_b\\rangle\n    $$\n    其中 $|\\psi_c\\rangle = \\frac{1}{\\sqrt{2^n}}\\sum_x (-1)^{f_c(x)} |x\\rangle$ 和 $|\\psi_b\\rangle = \\frac{1}{\\sqrt{2^n}}\\sum_x (-1)^{f_b(x)} |x\\rangle$。\n\n3.  接下来，对辅助量子比特和输入寄存器施加 Hadamard 门 ($H_a \\otimes H_{in}^{\\otimes n}$)。最终状态为：\n    $$\n    |\\psi_{\\text{final}}\\rangle = \\cos\\theta (H_a|0\\rangle_a \\otimes H_{in}^{\\otimes n}|\\psi_c\\rangle) + \\sin\\theta (H_a|1\\rangle_a \\otimes H_{in}^{\\otimes n}|\\psi_b\\rangle)\n    $$\n    定义沃尔什-阿达马变换系数 $A_f(z) = \\langle z | H_{in}^{\\otimes n} | \\psi_f \\rangle = \\frac{1}{2^n} \\sum_x (-1)^{f(x) + x \\cdot z}$。\n    状态可以写成：\n    $$\n    |\\psi_{\\text{final}}\\rangle = \\cos\\theta \\left(\\frac{|0\\rangle_a+|1\\rangle_a}{\\sqrt{2}}\\right) \\otimes \\sum_z A_c(z)|z\\rangle + \\sin\\theta \\left(\\frac{|0\\rangle_a-|1\\rangle_a}{\\sqrt{2}}\\right) \\otimes \\sum_z A_b(z)|z\\rangle\n    $$\n4.  通过输入寄存器状态 $|z\\rangle$ 重新组合项：\n    $$\n    |\\psi_{\\text{final}}\\rangle = \\sum_z |z\\rangle \\otimes \\frac{1}{\\sqrt{2}} \\left[ \\left( \\cos\\theta A_c(z) + \\sin\\theta A_b(z) \\right)|0\\rangle_a + \\left( \\cos\\theta A_c(z) - \\sin\\theta A_b(z) \\right)|1\\rangle_a \\right]\n    $$\n5.  在输入寄存器中测得 $|z\\rangle$ 的概率是通过对辅助量子比特的状态求迹得到的，即对两个基态 $|0\\rangle_a$ 和 $|1\\rangle_a$ 的振幅平方求和：\n    $$\n    P(z) = \\frac{1}{2} |\\cos\\theta A_c(z) + \\sin\\theta A_b(z)|^2 + \\frac{1}{2} |\\cos\\theta A_c(z) - \\sin\\theta A_b(z)|^2\n    $$\n    利用恒等式 $(a+b)^2+(a-b)^2 = 2(a^2+b^2)$，并注意到 $A_f(z)$ 是实数，上式简化为：\n    $$\n    P(z) = \\cos^2\\theta A_c(z)^2 + \\sin^2\\theta A_b(z)^2\n    $$\n6.  我们关心的是测量到全零状态 $|0^n\\rangle$ 的概率，即 $z=0$ 的情况。此时，$x \\cdot z = 0$。\n    -   对于常数函数 $f_c(x) = c$，我们有 $A_c(0) = \\frac{1}{2^n} \\sum_x (-1)^c = \\frac{1}{2^n} \\cdot 2^n (-1)^c = (-1)^c$。因此，$A_c(0)^2 = 1$。\n    -   对于平衡函数 $f_b$，根据定义，输出为0和1的输入数量相等。因此，$\\sum_x (-1)^{f_b(x)} = 0$，这意味着 $A_b(0) = 0$。\n7.  将这些值代入 $P(z)$ 的表达式中：\n    $$\n    P(|0^n\\rangle) = \\cos^2\\theta \\cdot (1) + \\sin^2\\theta \\cdot (0) = \\cos^2\\theta\n    $$\n    因此，测得全零状态的概率是 $\\cos^2\\theta$。", "answer": "$$ \\boxed{\\cos^{2} \\theta} $$", "id": "151519"}]}