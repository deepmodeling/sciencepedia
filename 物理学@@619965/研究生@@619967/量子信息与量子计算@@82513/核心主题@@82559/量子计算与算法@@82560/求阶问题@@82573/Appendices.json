{"hands_on_practices": [{"introduction": "量子阶寻找算法的核心在于利用量子傅里叶逆变换（Inverse QFT）将周期性信息转化为可测量的频率峰值。这个练习将带你亲手计算一个具体案例的测量概率，从而直观地理解算法是如何通过干涉效应，将概率集中在与阶 $r$ 相关的特定结果上的。通过这个计算，你将掌握从量子态到最终测量结果的核心数学步骤。[@problem_id:160729]", "problem": "量子求阶算法是 Shor 整数分解算法的一个关键组成部分。该算法旨在找到一个最小的正整数 $r$（称为阶），使得对于给定的互质整数 $x$ 和 $N$，满足 $x^r \\equiv 1 \\pmod{N}$。\n\n该算法使用两个量子寄存器：一个具有 $Q=2^n$ 个状态的控制寄存器（其中 $n$ 为某个整数）和一个目标寄存器。经过一系列涉及受控模幂运算的操作后，对目标寄存器的测量会将控制寄存器投影到一个由计算基态构成的周期性叠加态上。为简单起见，我们考虑测量后状态为以下形式的情况：\n$$\n|\\psi\\rangle = \\frac{1}{\\sqrt{M}} \\sum_{m=0}^{M-1} |mr\\rangle\n$$\n此处，$r$ 是阶，求和是对所有满足 $mr < Q$ 的非负整数 $m$ 进行的。归一化因子为 $1/\\sqrt{M}$，其中 $M$ 是叠加态中项的总数。\n\n算法的最后一步是对状态 $|\\psi\\rangle$ 应用逆量子傅里叶变换（QFT），然后测量控制寄存器。逆量子傅里叶变换对基态 $|j\\rangle$ 的作用定义为：\n$$\n\\text{QFT}^\\dagger |j\\rangle = \\frac{1}{\\sqrt{Q}} \\sum_{k=0}^{Q-1} e^{-2\\pi i jk/Q} |k\\rangle\n$$\n\n考虑一个具体问题：求 $x=10$ 模 $N=21$ 的阶。在此情况下，阶为 $r=6$。设控制寄存器的大小为 $Q=256$。假设在进行量子傅里叶变换之前，控制寄存器的状态恰好是上述的状态 $|\\psi\\rangle$，计算在控制寄存器中测量到结果 $k=128$ 的概率。", "solution": "应用逆量子傅里叶变换之前的状态为：\n\n$$\n|\\psi\\rangle = \\frac{1}{\\sqrt{M}} \\sum_{m=0}^{M-1} |m r\\rangle\n$$\n\n其中，$r=6$ 是阶，$Q=256$ 是控制寄存器的大小，$M$ 是满足 $mr < Q$ 的项数。$m$ 的取值范围是从 0 到满足 $mr < Q$ 的最大整数。因为 $r = 6$ 且 $Q = 256$：\n\n$$\nm_{\\text{max}} = \\left\\lfloor \\frac{Q - 1}{r} \\right\\rfloor = \\left\\lfloor \\frac{255}{6} \\right\\rfloor = 42\n$$\n\n因此，$m = 0, 1, 2, \\ldots, 42$，总共有 $M = 43$ 项。\n\n逆量子傅里叶变换对基态 $|j\\rangle$ 的作用如下：\n\n$$\n\\text{QFT}^\\dagger |j\\rangle = \\frac{1}{\\sqrt{Q}} \\sum_{k=0}^{Q-1} e^{-2\\pi i j k / Q} |k\\rangle\n$$\n\n对 $|\\psi\\rangle$ 应用逆量子傅里叶变换：\n\n$$\n\\text{QFT}^\\dagger |\\psi\\rangle = \\frac{1}{\\sqrt{M}} \\sum_{m=0}^{M-1} \\text{QFT}^\\dagger |m r\\rangle = \\frac{1}{\\sqrt{M}} \\sum_{m=0}^{M-1} \\left( \\frac{1}{\\sqrt{Q}} \\sum_{k=0}^{Q-1} e^{-2\\pi i (m r) k / Q} |k\\rangle \\right)\n$$\n\n状态 $|k\\rangle$ 的概率幅为：\n\n$$\n\\alpha_k = \\frac{1}{\\sqrt{M Q}} \\sum_{m=0}^{M-1} e^{-2\\pi i m r k / Q}\n$$\n\n测量到结果 $k$ 的概率为 $|\\alpha_k|^2$。对于 $k = 128$：\n\n$$\n\\alpha_{128} = \\frac{1}{\\sqrt{M Q}} \\sum_{m=0}^{M-1} e^{-2\\pi i m \\cdot 6 \\cdot 128 / 256}\n$$\n\n化简指数部分：\n\n$$\n\\frac{6 \\cdot 128}{256} = \\frac{768}{256} = 3\n$$\n\n因此：\n\n$$\ne^{-2\\pi i m \\cdot 3} = e^{-6\\pi i m} = (e^{-2\\pi i})^{3m} = 1^{3m} = 1\n$$\n\n因为 $e^{-2\\pi i} = 1$。求和变为：\n\n$$\n\\sum_{m=0}^{M-1} 1 = M\n$$\n\n所以概率幅为：\n\n$$\n\\alpha_{128} = \\frac{1}{\\sqrt{M Q}} \\cdot M = \\sqrt{\\frac{M}{Q}}\n$$\n\n概率为：\n\n$$\n|\\alpha_{128}|^2 = \\left( \\sqrt{\\frac{M}{Q}} \\right)^2 = \\frac{M}{Q}\n$$\n\n代入 $M = 43$ 和 $Q = 256$：\n\n$$\n\\frac{43}{256}\n$$", "answer": "$$ \\boxed{\\dfrac{43}{256}} $$", "id": "160729"}, {"introduction": "量子测量并非总能一步到位地揭示真正的阶 $r$。当测量的结果对应于一个与 $r$ 不互质的整数时，经典后处理步骤（例如连分数算法）可能会得到 $r$ 的一个因子，即一个“子阶”。这个练习模拟了多次独立实验均得到不完整结果的情景，并向你展示如何利用数论工具，从这些看似失败的测量中推断出正确的阶，这体现了算法在实践中的鲁棒性。[@problem_id:160640]", "problem": "量子阶寻找算法是Shor整数分解算法的一个关键组成部分。其目标是找到一个整数$a$模$M$的阶$r$，这个阶$r$是满足$a^r \\equiv 1 \\pmod{M}$的最小正整数。\n\n该算法利用量子计算机来制备一个特定的量子态，对一个控制寄存器的测量会得到一个整数结果$k$。这个结果用于一个经典的后处理步骤。在很高的概率下，比值$k/N$（其中$N$是控制寄存器希尔伯特空间的大小）是某个有理数$j/r$的一个良好近似，其中$j$是介于$0$和$r-1$之间的某个整数。然后使用连分数算法从估计值$k/N$中高效地提取出分数$j/s$。\n\n如果整数$j$（由量子态随机决定）与真实阶$r$互质（即 $\\gcd(j, r) = 1$），则通过连分数算法找到的分母$s$将是真实阶$r$。然而，如果$\\gcd(j, r) = d > 1$，则分数$j/r$不是最简分数。连分数算法将找到其约化分数$j'/s'$，其中$j/r = j'/s'$。得到的分母$s'$将是真实阶的一个因子，具体来说，$s' = r/d$。\n\n一位实验者正在尝试寻找一个元素$a$模$M$的阶$r$。他们独立地进行了两次量子阶寻找算法的运行。\n1. 第一次运行得到了一个候选阶$s_1$。通过经典方法检验，他们发现$a^{s_1} \\not\\equiv 1 \\pmod{M}$。\n2. 第二次运行得到了另一个不同的候选阶$s_2$。他们同样发现$a^{s_2} \\not\\equiv 1 \\pmod{M}$。\n\n实验者得出结论，两次运行都对应于上述的失败模式，这意味着$s_1$和$s_2$都是真实阶$r$的真因数。给定观测到的两个子阶$s_1 = 90$和$s_2 = 105$，请确定真实阶$r$最可能的值。假设$r$是与两次测量结果都一致的最小整数。", "solution": "我们给定两个观测到的子阶$s_1=90$和$s_2=105$，它们都是真实阶$r$的真因数。与这些观测结果一致的最小的$r$必须满足\n\n$$\ns_1\\mid r,\\quad s_2\\mid r,\n$$\n\n并且是最小的。因此\n\n$$\nr=\\mathrm{lcm}(s_1,s_2).\n$$\n\n计算其素数分解：\n\n$$\n90 = 2\\cdot 3^2\\cdot 5,\\qquad\n105 = 3\\cdot 5\\cdot 7.\n$$\n\n最小公倍数取每个素数的最高次幂：\n\n$$\n\\mathrm{lcm}(90,105)\n=2^1\\cdot3^2\\cdot5^1\\cdot7^1\n=2\\cdot9\\cdot5\\cdot7\n=630.\n$$\n\n因此，最小可能的真实阶是$r=630$。", "answer": "$$\\boxed{630}$$", "id": "160640"}, {"introduction": "在真实的量子计算机中，噪声和错误是不可避免的。本练习探讨了一种常见的硬件错误——测量过程中的单比特翻转——如何影响阶寻找算法的最终结果。你将从一个理想的测量结果出发，引入一个错误，然后执行经典的连分数分析，看看这个错误如何“误导”算法，并最终推导出一个什么样的候选阶，这个过程有助于深入理解算法对物理错误的敏感性。[@problem_id:160805]", "problem": "肖尔求阶算法的经典部分依赖于寻找分数 $\\frac{k}{Q}$ 的一个良好有理近似，其中 $k$ 是从测量量子计算机的第一个寄存器得到的整数，而 $Q=2^t$ 是该寄存器希尔伯特空间的维度，$t$ 是量子比特的数量。测量结果 $k$ 期望是一个接近分数 $\\frac{sQ}{r}$ 之一的整数，其中整数 $s \\in \\{0, 1, \\dots, r-1\\}$，$r$ 是我们希望找到的阶。\n\n连分数算法被用来寻找 $\\frac{k}{Q}$ 的一系列逐次更优的有理近似（收敛子）。这些收敛子的分母为阶 $r$ 提供了一个候选列表。\n\n考虑一个具有以下参数的求阶算法实例：\n- 待求的真实阶为 $r$。\n- 第一个寄存器的计算基大小为 $Q = 2^t$。\n- 理想测量与整数 $s=1$ 相关联。\n\n在理想的、无错误的执行中，测量结果将为 $k_{ideal} = \\lfloor \\frac{sQ}{r} \\rfloor$。然而，在测量过程中发生了一个单位比特错误。具体来说，$k_{ideal}$ 的 $t$ 比特二进制表示的最高有效位 (MSB) 被翻转了。令得到的错误测量结果为 $k_{err}$。\n\n然后将标准的经典程序应用于错误的分数 $\\frac{k_{err}}{Q}$。该算法生成收敛子的分母作为阶的候选。这些候选值会被依次进行检验。给定真实阶为 $r$，如果一个候选值 $r'_{cand}$ 满足 $x^{r'_{cand}} \\equiv 1 \\pmod N$，则认为它是成功的，这在 $r'_{cand}$ 是 $r$ 的倍数时得到保证。\n\n给定真实阶 $r=17$ 和一个 $t=10$ 量子比特的寄存器（$Q=2^{10}$），计算当经典后处理应用于错误测量值 $k_{err}$ 时，第一个能被成功识别的候选阶 $r'$。", "solution": "1. 理想的测量结果是\n$$k_{\\text{ideal}} = \\Big\\lfloor \\frac{s\\,Q}{r}\\Big\\rfloor,\\quad s=1,\\;Q=2^t=2^{10},\\;r=17,$$\n因此\n$$k_{\\text{ideal}} = \\Big\\lfloor \\frac{2^{10}}{17}\\Big\\rfloor.$$\n\n2. 用二进制（10位）表示，$k_{\\text{ideal}} = \\lfloor2^{10}/17\\rfloor =60_{10}=0000111100_2$。翻转最高有效位（第9位）会加上 $2^9$，因此\n$$k_{\\text{err}} = 2^9 + \\Big\\lfloor\\frac{2^{10}}{17}\\Big\\rfloor =512 +60 =572,$$\n并且\n$$\\frac{k_{\\text{err}}}{Q} = \\frac{572}{1024} = \\frac{143}{256}.$$\n\n3. 计算 $\\tfrac{143}{256}$ 的连分数。可以得到\n$$\\frac{143}{256}=[0;1,1,3,1,3,3,2],$$\n其收敛子的分母为\n$$q_1=1,\\;q_2=2,\\;q_3=7,\\;q_4=9,\\;q_5=34,\\;q_6=111,\\;q_7=256.$$\n\n4. 真实阶是 $r=17$。第一个是 $17$ 的倍数的分母 $q_i$ 是\n$$q_5 = 34 = 2\\cdot17.$$\n因此，第一个成功的候选值是 $r'=34\\,。$", "answer": "$$\\boxed{34}$$", "id": "160805"}]}