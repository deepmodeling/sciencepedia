{"hands_on_practices": [{"introduction": "掌握维格纳-赛兹原胞 (Wigner-Seitz cell) 的第一步是能够从其基本定义出发，精确地构建它。这个练习将引导你对一个二维面心矩形晶格进行操作，这是一个比简单矩形晶格更具启发性的模型。通过从第一性原理出发，利用最近邻晶格矢量构建垂直平分面，你将亲手推导出原胞的精确多边形形状，并理解为何它一般不是一个简单的矩形 [@problem_id:3020949]。这种严谨的几何构建是理解更复杂三维晶体结构中电子能带和声子谱的基础。", "problem": "考虑一个二维中心矩形 Bravais 晶格，其常规晶胞的边长为 $a$ 和 $b$，与笛卡尔坐标轴对齐，并且每个常规矩形的中心有一个额外的格点。此 Bravais 晶格的一个有效原胞基矢选择是 $\\mathbf{u} = \\left(\\frac{a}{2}, \\frac{b}{2}\\right)$ 和 $\\mathbf{v} = \\left(\\frac{a}{2}, -\\frac{b}{2}\\right)$，因此格点位置为 $\\mathbf{R}_{m,n} = m\\,\\mathbf{u} + n\\,\\mathbf{v}$，其中 $m$ 和 $n$ 为整数。位于原点的格点的 Wigner-Seitz 原胞（晶格的 Voronoi 原胞）被定义为平面中所有点 $\\mathbf{r}$ 的集合，这些点到原点的距离不大于到任何其他格点的距离。\n\n从 Bravais 晶格和 Wigner-Seitz 原胞的核心定义出发，使用垂直平分线作图法：\n- 使用从最近邻非零格矢导出的不等式，解释为何此中心矩形晶格的 Wigner-Seitz 原胞通常不是一个简单矩形。\n- 在 $a \\geq b$ 的假设下，通过从相关的最近邻矢量确定其顶点的有序坐标，计算 Wigner-Seitz 原胞的显式多边形形状。从 $x$ 轴上最右侧的顶点开始，按逆时针顺序排列顶点。\n\n将您的最终答案表示为关于 $a$ 和 $b$ 的单个闭式解析表达式，将六个顶点的有序坐标 $(x_1,y_1),\\dots,(x_6,y_6)$ 在一行中给出。无需四舍五入，也无需单位。", "solution": "该问题要求构建一个二维中心矩形 Bravais 晶格的 Wigner-Seitz 原胞，并确定其顶点坐标。\n\n### 问题验证\n该问题陈述是有效的。它描述了一个标准的物理系统（一个二维 Bravais 晶格），并要求使用凝聚态物理的既定原理来确定一个明确定义的几何构造（Wigner-Seitz 原胞）。提供的原胞基矢 $\\mathbf{u} = (\\frac{a}{2}, \\frac{b}{2})$ 和 $\\mathbf{v} = (\\frac{a}{2}, -\\frac{b}{2})$ 正确地生成了中心矩形晶格。$a \\geq b$ 这个条件是一个有效的约束，它确保了最近邻距离的明确排序。任务是清晰、客观且可解的。\n\n### 解题推导\n\n以原点为中心的 Wigner-Seitz 原胞是所有点 $\\mathbf{r}=(x, y)$ 的集合，这些点到原点的距离比到任何其他格点 $\\mathbf{R}_{m,n} = m\\mathbf{u} + n\\mathbf{v}$（其中 $m$ 和 $n$ 是不全为零的整数）的距离更近。条件是对于所有非零的 $\\mathbf{R}_{m,n}$，都有 $|\\mathbf{r}| \\leq |\\mathbf{r} - \\mathbf{R}_{m,n}|$。这个不等式等价于 $\\mathbf{r} \\cdot \\mathbf{R}_{m,n} \\leq \\frac{1}{2}|\\mathbf{R}_{m,n}|^2$。Wigner-Seitz 原胞的边界是连接原点与最近格点的矢量的垂直平分线。\n\n首先，我们必须确定最短的非零格矢 $\\mathbf{R}_{m,n} = (\\frac{a}{2}(m+n), \\frac{b}{2}(m-n))$。其长度的平方为 $|\\mathbf{R}_{m,n}|^2 = \\frac{a^2}{4}(m+n)^2 + \\frac{b^2}{4}(m-n)^2$。\n\n我们来确定最短的矢量：\n1.  对于 $(m,n) = (1,1)$ 或 $(-1,-1)$：$\\mathbf{R} = \\pm(a, 0)$。长度的平方为 $a^2$。\n2.  对于 $(m,n) = (1,-1)$ 或 $(-1,1)$：$\\mathbf{R} = \\pm(0, b)$。长度的平方为 $b^2$。\n3.  对于 $(m,n) = (1,0)$, $(-1,0)$, $(0,1)$ 或 $(0,-1)$：$\\mathbf{R} = (\\pm \\frac{a}{2}, \\pm \\frac{b}{2})$。长度的平方为 $\\frac{a^2}{4} + \\frac{b^2}{4} = \\frac{a^2+b^2}{4}$。\n\n给定 $a \\geq b > 0$，我们比较这些长度的平方：\n-   $b^2 \\leq a^2$。\n-   比较 $\\frac{a^2+b^2}{4}$ 和 $a^2$：$\\frac{a^2+b^2}{4} \\leq a^2 \\iff a^2+b^2 \\leq 4a^2 \\iff b^2 \\leq 3a^2$。因为 $a \\geq b$，所以这个条件总是成立的。\n-   比较 $\\frac{a^2+b^2}{4}$ 和 $b^2$：$\\frac{a^2+b^2}{4} \\leq b^2 \\iff a^2+b^2 \\leq 4b^2 \\iff a^2 \\leq 3b^2$。这个条件在 $a \\leq \\sqrt{3}b$ 时成立。\n\n此分析表明，定义原胞边界的矢量集合取决于比率 $a/b$。然而，Wigner-Seitz 原胞是所有半平面 $\\mathbf{r} \\cdot \\mathbf{R} \\leq \\frac{1}{2}|\\mathbf{R}|^2$ 的交集。原胞的一条边可能由一个不属于绝对最短矢量集合的矢量的平分线构成。\n\n边界线由方程 $\\mathbf{r} \\cdot \\mathbf{R} = \\frac{1}{2}|\\mathbf{R}|^2$ 给出：\n1.  由 $\\mathbf{R} = (\\pm a, 0)$ 得：$\\pm ax = \\frac{1}{2}a^2 \\implies x = \\pm \\frac{a}{2}$。\n2.  由 $\\mathbf{R} = (0, \\pm b)$ 得：$\\pm by = \\frac{1}{2}b^2 \\implies y = \\pm \\frac{b}{2}$。\n3.  由 $\\mathbf{R} = (\\pm \\frac{a}{2}, \\pm \\frac{b}{2})$ 得：对于 $\\mathbf{R} = (\\frac{a}{2}, \\frac{b}{2})$，方程为 $x\\frac{a}{2} + y\\frac{b}{2} = \\frac{1}{2}(\\frac{a^2}{4}+\\frac{b^2}{4}) = \\frac{a^2+b^2}{8}$。化简后为 $ax+by = \\frac{a^2+b^2}{4}$。根据对称性，我们有四条这样的线：$ax \\pm by = \\pm\\frac{a^2+b^2}{4}$。\n\n#### 关于非矩形形状的解释\n一个简单的矩形 Wigner-Seitz 原胞将仅由平面 $x=\\pm a/2$ 和 $y=\\pm b/2$ 定义。对于简单矩形晶格来说是这样。然而，对于中心矩形晶格，我们还必须考虑由中心格点施加的约束，这些约束对应于直线 $ax \\pm by = \\pm\\frac{a^2+b^2}{4}$。\n\n我们来检验一下简单矩形的一个角点，例如 $(\\frac{a}{2}, \\frac{b}{2})$，是否满足由 $\\mathbf{R}=(\\frac{a}{2}, \\frac{b}{2})$ 的平分线得出的不等式。该不等式为 $ax+by \\leq \\frac{a^2+b^2}{4}$。\n代入该点坐标：$a(\\frac{a}{2}) + b(\\frac{b}{2}) = \\frac{a^2+b^2}{2}$。\n不等式变为 $\\frac{a^2+b^2}{2} \\leq \\frac{a^2+b^2}{4}$，化简为 $2 \\leq 1$。这是不成立的。因此，由 $x=\\pm a/2$ 和 $y=\\pm b/2$ 定义的矩形的角被指向常规晶胞中心的矢量的垂直平分线“切掉”了。这种对角的截断导致了一个非简单矩形的多边形形状。对于 $a>b$，它是一个六边形。\n\n#### 六边形原胞顶点的计算\n对于 $a>b$，Wigner-Seitz 原胞是一个六边形。其顶点是与原点和另外两个非共线格点等距的点。根据对称性，这些顶点成组出现。\n六边形的顶点由边界线的交点形成。因为 $a \\geq b$，所以 $b^2 \\leq a^2$，这意味着直线 $y=\\pm b/2$ 构成边界，而直线 $x=\\pm a/2$ 可能不构成边界。六边形的顶点必须位于条带 $|x| \\le a/2$ 内。任何顶点的最大x坐标将是 $\\frac{a^2+b^2}{4a}$。由于 $\\frac{a^2+b^2}{4a} \\leq \\frac{a}{2}$ (因为 $a^2+b^2 \\leq 2a^2 \\iff b^2 \\leq a^2$)，该原胞总是包含在区域 $|x| \\leq a/2$ 内。因此，对于 $a>b$，直线 $x=\\pm a/2$ 不构成 Wigner-Seitz 原胞的边界。边界由 $y = \\pm \\frac{b}{2}$ 和 $ax \\pm by = \\pm\\frac{a^2+b^2}{4}$ 形成。\n\n顶点是这些边界线的交点。\n-   **最右侧顶点：** 该顶点位于 $x$ 轴上 $(y=0)$。它与原点以及两个格点 $(\\frac{a}{2}, \\frac{b}{2})$ 和 $(\\frac{a}{2}, -\\frac{b}{2})$ 等距。因此，它是直线 $ax+by = \\frac{a^2+b^2}{4}$ 和 $ax-by = \\frac{a^2+b^2}{4}$ 的交点。将这两个方程相加得到 $2ax = \\frac{a^2+b^2}{2}$，从而得出 $x = \\frac{a^2+b^2}{4a}$。该顶点是 $(\\frac{a^2+b^2}{4a}, 0)$。\n\n-   **其他顶点：** 剩余的顶点通过对称性和与其他相关边界线求交点得到。\n    - 第一象限的顶点与原点、$(0,b)$ 和 $(\\frac{a}{2}, \\frac{b}{2})$ 等距。它是平分线 $y=\\frac{b}{2}$ 和 $ax+by = \\frac{a^2+b^2}{4}$ 的交点。将 $y=\\frac{b}{2}$ 代入第二个方程：$ax + b(\\frac{b}{2}) = \\frac{a^2+b^2}{4} \\implies ax = \\frac{a^2-b^2}{4} \\implies x = \\frac{a^2-b^2}{4a}$。该顶点是 $(\\frac{a^2-b^2}{4a}, \\frac{b}{2})$。\n\n从 $x$ 轴上最右侧的顶点开始，按逆时针顺序排列的六个顶点是：\n\n-   顶点 1: $(\\frac{a^2+b^2}{4a}, 0)$\n-   顶点 2: $ax+by = \\frac{a^2+b^2}{4}$ 和 $y=\\frac{b}{2}$ 的交点，即 $(\\frac{a^2-b^2}{4a}, \\frac{b}{2})$。\n-   顶点 3: 顶点2关于 $y$ 轴对称，为 $(-\\frac{a^2-b^2}{4a}, \\frac{b}{2})$。\n-   顶点 4: 顶点1关于原点对称，为 $(-\\frac{a^2+b^2}{4a}, 0)$。\n-   顶点 5: 顶点2关于原点对称，为 $(-\\frac{a^2-b^2}{4a}, -\\frac{b}{2})$。\n-   顶点 6: 顶点2关于 $x$ 轴对称，为 $(\\frac{a^2-b^2}{4a}, -\\frac{b}{2})$。\n\n坐标的有序列表 $(x_1, y_1), \\dots, (x_6, y_6)$ 是：\n1.  $(\\frac{a^2+b^2}{4a}, 0)$\n2.  $(\\frac{a^2-b^2}{4a}, \\frac{b}{2})$\n3.  $(-\\frac{a^2-b^2}{4a}, \\frac{b}{2})$\n4.  $(-\\frac{a^2+b^2}{4a}, 0)$\n5.  $(-\\frac{a^2-b^2}{4a}, -\\frac{b}{2})$\n6.  $(\\frac{a^2-b^2}{4a}, -\\frac{b}{2})$\n这个六边形形状在 $a>b$ 时有效。在 $a=b$ 的特殊情况下，顶点2和3的坐标变为 $(0, b/2)$，顶点5和6的坐标变为 $(0, -b/2)$。六边形退化为一个顶点在坐标轴上的正方形，这是简单正方形晶格的正确 Wigner-Seitz 原胞。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{a^2+b^2}{4a} & 0 & \\frac{a^2-b^2}{4a} & \\frac{b}{2} & -\\frac{a^2-b^2}{4a} & \\frac{b}{2} & -\\frac{a^2+b^2}{4a} & 0 & -\\frac{a^2-b^2}{4a} & -\\frac{b}{2} & \\frac{a^2-b^2}{4a} & -\\frac{b}{2}\n\\end{pmatrix}\n}\n$$", "id": "3020949"}, {"introduction": "维格纳-赛兹原胞的形状并非一成不变，它对其所在晶格的几何参数十分敏感。这个练习让你深入探究这一迷人特性，通过分析一个二维面心矩形晶格，你将发现并计算一个临界的晶格常数之比 $\\gamma = b/a$ [@problem_id:262364]。在这个临界比值下，原胞的拓扑结构会从一个六边形转变为一个矩形。这个实践不仅能巩固你对原胞构建的理解，更重要的是，它揭示了晶体基本几何性质如何随系统参数连续变化而发生突变，这是理解固体物理中结构相变等深刻概念的一个绝佳入口。", "problem": "一个二维带心矩形晶格由一个边长为 $a$ 和 $b$ 的矩形常规晶胞定义，其晶格点位于矩形的顶点和中心。数学上，若将原点置于一个晶格点上，则其他晶格点的位置为 $\\vec{R} = m(a\\hat{x}) + n(b\\hat{y})$ 和 $\\vec{R} = (m+\\frac{1}{2})(a\\hat{x}) + (n+\\frac{1}{2})(b\\hat{y})$，其中 $m, n$ 为任意整数。\n\n该晶格的 Wigner-Seitz 晶胞是一个空间区域，该区域内的所有点到原点的距离比到任何其他晶格点的距离都近。该晶胞的形状取决于常规晶胞的边长之比 $\\gamma = b/a$。对于这个比值的大多数情况，Wigner-Seitz 晶胞是六边形。然而，在一个特定的临界比值下，该晶胞会变成一个矩形。\n\n假设 $b \\ge a$，求出使 Wigner-Seitz 晶胞转变为矩形的临界比值 $\\gamma = b/a$。", "solution": "1. 离原点最近的非零晶格矢量是 $\\mathbf{R}_1 = (a,0)$, $\\mathbf{R}_2 = (0,b)$, $\\mathbf{R}_3 = (a/2,b/2)$, $\\mathbf{R}_4 = (a/2,-b/2), \\dots$\n2. 它们到原点的距离是 $d_1 = |\\mathbf{R}_1| = a$, $d_2 = |\\mathbf{R}_2| = b$, $d_3 = |\\mathbf{R}_3| = \\frac{1}{2}\\sqrt{a^2 + b^2}.$\n3. 当“斜穿中心”的格点 $\\mathbf{R}_3$ 到原点的距离与 x 轴上的格点 $\\mathbf{R}_1$ 到原点的距离相等时，恰好形成矩形的 Wigner–Seitz 晶胞（四边形）。因此我们令\n$$\\frac{1}{2}\\sqrt{a^2 + b^2} = a$$\n4. 两边平方：\n$$\\frac{1}{4}(a^2 + b^2) = a^2$$\n   ⇒ $a^2 + b^2 = 4a^2$\n   ⇒ $b^2 = 3a^2.$\n5. 因此，临界长宽比为\n$$\\gamma = b/a = \\sqrt{3}.$$", "answer": "$$\\boxed{\\sqrt{3}}$$", "id": "262364"}, {"introduction": "在现代凝聚态物理研究中，将理论概念转化为高效的计算策略至关重要。这个高级实践将带你进入计算物理学的核心，要求你为三维晶格设计一个构建维格纳-赛兹原胞的算法 [@problem_id:3020917]。你不仅要实现一个朴素的构建方法，更要通过利用晶格的点群对称性来极大地优化计算效率。这个练习的价值在于，它让你深刻体会到群论在固体理论中的强大威力——对称性如何将一个看似繁杂的计算问题简化为少数几个代表性元素的计算，这是处理真实晶体结构电子性质和动力学问题的标准研究范式。", "problem": "给定一个由三个原胞基矢 $a_1$、$a_2$ 和 $a_3$ 指定的三维Bravais晶格。Wigner-Seitz原胞（WSC）定义为空间 $\\mathbb{R}^3$ 中比邻近任何其他格点更邻近原点的点的集合 $x$。根据基本几何构造，Wigner-Seitz原胞可以写成一系列半空间的交集\n$$\n\\{\\, x \\in \\mathbb{R}^3 \\mid x \\cdot R \\le \\tfrac{1}{2} \\lVert R \\rVert^2 \\,\\}\n$$\n其中 $R = n_1 a_1 + n_2 a_2 + n_3 a_3$ 是任意非零晶格矢量，$n_1$、$n_2$ 和 $n_3$ 为整数。晶格的点群对称性是指作用于 $\\mathbb{R}^3$ 的一组旋转操作 $G$，这些操作将晶格映射到其自身，即对于任意晶格矢量 $R$ 和任意 $g \\in G$， $gR$ 也是一个晶格矢量。如果存在 $g \\in G$ 使得 $R' = g R$，则称两个晶格矢量 $R$ 和 $R'$ 是对称等价的。\n\n您的任务是设计并实现一个完整的、可运行的程序，该程序通过半空间求交来构建给定晶格的Wigner-Seitz原胞，并通过将对称等价的晶格矢量分组和通过对称性复制面（半空间）来利用点群对称性以降低计算成本，同时生成与朴素构造法完全相同的原胞。您的程序必须实现以下两种策略：\n\n- 一种朴素策略，该策略枚举有界盒子 $[-N,N]^3$ 内具有整数系数 $n_i$ 的所有晶格矢量 $R$，通过径向截断 $\\lVert R \\rVert \\le R_{\\text{cut}}$ 对它们进行筛选，并构建半空间 $x \\cdot R \\le \\tfrac{1}{2} \\lVert R \\rVert^2$。\n\n- 一种利用对称性的策略，该策略在截断后使用相同的候选晶格矢量集，在点群 $G$ 的作用下将这些矢量划分为轨道，每个轨道选择一个代表矢量，然后通过将所有 $g \\in G$ 应用于代表矢量来重构完整的半空间集，并按容差去重。节约的计算量通过轨道代表的数量与朴素策略中使用的候选矢量总数的比较来衡量。\n\n您必须通过对半空间求交并计算所得顶点集的凸包来计算Wigner-Seitz原胞的体积。您必须通过比较每个测试用例中朴素方法和利用对称性方法的体积，来断言利用对称性方法的正确性，并报告它们是否在 $10^{-9}$ 的容差范围内匹配。\n\n使用以下测试套件，它涵盖了标准立方Bravais晶格。所有长度均以常规立方晶格常数 $a$ 为单位，所有体积必须以 $a^3$ 为单位报告：\n\n- 测试用例 1（简单立方, SC）：$a_1 = (1,0,0)$、$a_2 = (0,1,0)$、$a_3 = (0,0,1)$，整数边界 $N = 2$，径向截断 $R_{\\text{cut}} = 1.01$。点群 $G$ 是立方体的纯旋转对称群（八面体群），由所有行列式为 $+1$ 的 $3 \\times 3$ 正交矩阵组成，这些矩阵对坐标轴进行置换和变号。\n\n- 测试用例 2（体心立方, BCC）：$a_1 = \\tfrac{1}{2} (1,1,-1)$、 $a_2 = \\tfrac{1}{2} (1,-1,1)$、 $a_3 = \\tfrac{1}{2} (-1,1,1)$，整数边界 $N = 2$，径向截断 $R_{\\text{cut}} = 1.01$。使用相同的点群 $G$。\n\n- 测试用例 3（面心立方, FCC）：$a_1 = \\tfrac{1}{2} (0,1,1)$、$a_2 = \\tfrac{1}{2} (1,0,1)$、$a_3 = \\tfrac{1}{2} (1,1,0)$，整数边界 $N = 2$，径向截断 $R_{\\text{cut}} = 1.01$。使用相同的点群 $G$。\n\n对于每个测试用例 $t$，您的程序必须生成一个列表 $[b_t, v_t, r_t, c_t]$，其中：\n- $b_t$ 是一个布尔值，表示朴素方法和利用对称性方法的体积是否在 $10^{-9}$ 容差范围内匹配。\n- $v_t$ 是由任一方法计算出的Wigner-Seitz原胞体积（两者必须匹配），以 $a^3$ 为单位，表示为浮点数并四舍五入到12位小数。\n- $r_t$ 是一个整数，等于利用对称性方法所使用的轨道代表的数量。\n- $c_t$ 是一个整数，等于朴素方法在应用径向截断和去重后所使用的候选晶格矢量的数量。\n\n您的程序应生成单行输出，其中包含三个测试用例的结果列表，以逗号分隔，并用方括号括起来。例如，输出格式必须与 $[ [b_1,v_1,r_1,c_1], [b_2,v_2,r_2,c_2], [b_3,v_3,r_3,c_3] ]$ 完全一致，逗号和括号的显示方式需完全相同。\n\n这个问题不涉及角度；无需指定角度单位。所有数值输出必须是无量纲的，体积以指定的 $a^3$ 为单位。程序必须是自包含的，并且不需要用户输入。\n\n您必须使用的基本假设是以下核心定义和事实：\n- Bravais晶格是集合 $\\{ n_1 a_1 + n_2 a_2 + n_3 a_3 \\mid n_i \\in \\mathbb{Z} \\}$。\n- Wigner-Seitz原胞等于晶格关于原点的Voronoi原胞，可以通过对所有非零晶格矢量 $R$ 的垂直平分半空间 $x \\cdot R \\le \\tfrac{1}{2} \\lVert R \\rVert^2$ 求交来构造。\n- 晶格的点群 $G$ 作用于晶格并保持距离不变，因此它会对Wigner-Seitz原胞的定义半空间进行置换。\n- Wigner-Seitz原胞的体积等于原胞的体积，即 $V_{\\text{prim}} = \\lvert \\det A \\rvert$，其中 $A$ 是一个 $3 \\times 3$ 矩阵，其列是原胞基矢 $a_1$、$a_2$ 和 $a_3$。\n\n您的算法必须推导并证明为什么通过点群轨道对晶格矢量进行分组，可以只计算少量代表面，然后通过对称性生成全套等价面，从而在不改变最终Wigner-Seitz原胞的情况下，减少初始计算量（在轨道代表层面）。", "solution": "用户提供了一个在计算凝聚态物理领域中有效、良置且有科学依据的问题。任务是使用两种不同的计算策略——朴素枚举和利用对称性的方法——为几种Bravais晶格构建Wigner-Seitz原胞（WSC），并验证两种方法产生相同的结果。\n\n问题的核心在于Wigner-Seitz原胞的几何定义以及应用群论来优化其构造。以Bravais晶格 $\\mathcal{L}$ 原点为中心的WSC，是空间中所有比到任何其他格点 $R \\in \\mathcal{L} \\setminus \\{0\\}$ 更靠近原点的点的集合。这等同于原点的Voronoi原胞。在几何上，这个区域由一组半空间的交集定义。对于每个非零晶格矢量 $R$，原点和 $R$ 之间的垂直平分面由方程 $x \\cdot R = \\frac{1}{2} \\lVert R \\rVert^2$ 给出。WSC包含所有与原点位于该平面同一侧的点 $x$，从而得出不等式 $x \\cdot R \\le \\frac{1}{2} \\lVert R \\rVert^2$。因此，WSC是所有此类半空间的交集：\n$$\nW = \\bigcap_{R \\in \\mathcal{L}\\setminus\\{0\\}} \\{ x \\in \\mathbb{R}^3 \\mid x \\cdot R \\le \\tfrac{1}{2} \\lVert R \\rVert^2 \\}\n$$\n在任何实际计算中，对无限数量的半空间求交是不可行的。但是，通常只需要与最接近原点的晶格矢量 $R$ 相对应的半空间来定义WSC的面。来自更远矢量 $R$ 的半空间是冗余的，因为它们包含了由较近矢量定义的原胞。这证明了只考虑某一截断半径 $\\lVert R \\rVert \\le R_{\\text{cut}}$ 内的晶格矢量的通用计算实践的合理性，这也是“朴素”策略的基础。用于生成晶格矢量 $R = n_1 a_1 + n_2 a_2 + n_3 a_3$ 的整数集合 $n_i$ 也被限制在一个盒子内，例如 $n_i \\in [-N, N]$，以确保候选矢量集是有限的。\n\n需要展示的主要科学原理是对称性的利用。晶格的点群 $G$ 是所有能使晶格保持不变的旋转操作 $g$ （由正交矩阵表示）的集合，即对于任何晶格矢量 $R$ ，矢量 $gR$ 也是一个晶格矢量。因此，所有晶格矢量的集合 $\\mathcal{L}$ 在群 $G$ 的作用下是闭合的。\n\n这种对称性对WSC的结构有深远的影响。设 $g \\in G$ 为一个对称操作。由于 $g$ 是一个等距变换（保持距离的变换），它由一个正交矩阵表示，满足 $(gx) \\cdot (gy) = x \\cdot y$ 和 $\\lVert gx \\rVert = \\lVert x \\rVert$。半空间条件 $x \\cdot R \\le \\frac{1}{2} \\lVert R \\rVert^2$ 在 $g$ 的作用下变换如下：\n令 $x' = gx$ 和 $R' = gR$。点 $x'$ 位于由 $R'$ 定义的半空间内的条件是 $x' \\cdot R' \\le \\frac{1}{2} \\lVert R' \\rVert^2$。代入变换后的变量，我们得到 $(gx) \\cdot (gR) \\le \\frac{1}{2} \\lVert gR \\rVert^2$。由于正交性，这简化为 $x \\cdot R \\le \\frac{1}{2} \\lVert R \\rVert^2$，这正是点 $x$ 位于由 $R$ 定义的半空间内的原始条件。因此，一个点 $x$ 满足由 $R$ 定义的半空间条件，当且仅当变换后的点 $gx$ 满足由变换后的矢量 $gR$ 定义的半空间条件。我们可以将其表述为 $g(\\{x \\mid x \\cdot R \\le \\frac{1}{2} \\lVert R \\rVert^2\\}) = \\{y \\mid y \\cdot gR \\le \\frac{1}{2} \\lVert gR \\rVert^2\\}$。\n\nWSC是所有半空间的交集：$W = \\bigcap_{R \\in \\mathcal{L}\\setminus\\{0\\}} H_R$，其中 $H_R$ 是矢量 $R$ 对应的半空间。对原胞应用群操作 $g$ 会得到 $gW = g(\\bigcap_R H_R) = \\bigcap_R (gH_R) = \\bigcap_R H_{gR}$。由于晶格矢量集 $\\{R\\}$ 在 $G$ 的作用下是不变的，所以集合 $\\{gR \\mid R \\in \\mathcal{L}\\setminus\\{0\\}\\}$ 与 $\\mathcal{L}\\setminus\\{0\\}$ 是相同的。因此，$\\bigcap_R H_{gR} = \\bigcap_{R'} H_{R'} = W$。这证明了Wigner-Seitz原胞在晶格点群的所有操作下都是不变的 ($gW = W$)。\n\n候选晶格矢量集（即满足 $\\lVert R \\rVert \\le R_{\\text{cut}}$ 的矢量）可以在点群 $G$ 的作用下被划分为不相交的轨道。矢量 $R_i$ 的轨道是集合 $\\mathcal{O}_i = \\{g R_i \\mid g \\in G\\}$。定义WSC的所有半空间的集合同样可以根据这些轨道进行划分。利用对称性的策略利用了这一点：\n1. 从每个轨道中选择一个代表矢量。\n2. 对每个代表矢量 $R_i$，生成相应的对称等价半空间的全集 $\\{H_{gR_i} \\mid g \\in G\\}$。\n3. 将所有唯一轨道上的这些半空间集合并，可以重构出完整的相关半空间集，该集合与朴素方法中使用的集合相同。\n\n其优势在于计算效率。我们只需识别唯一的轨道，而无需单独处理每个候选矢量。此类轨道的数量通常远小于候选矢量的总数。对于具有高度对称性的立方晶格，这种减少是显著的。\n\n算法流程如下：\n1. 对每个测试用例（SC、BCC、FCC），定义原胞基矢 $a_1, a_2, a_3$。\n2. 生成纯八面体群 $O$ 的24个旋转矩阵。\n3. 为整数 $n_i \\in [-N, N]$，生成初始晶格矢量集 $R = n_1a_1 + n_2a_2 + n_3a_3$。\n4. 过滤这些矢量，只保留范数 $\\lVert R \\rVert \\le R_{\\text{cut}}$ 的唯一矢量。这就构成了包含 $c_t$ 个候选矢量的集合。\n5. **朴素方法**：直接使用 $c_t$ 个候选矢量来定义 $c_t$ 个形如 $R \\cdot x - \\frac{1}{2} \\lVert R \\rVert^2 \\le 0$ 的半空间。计算这些半空间的交集以找到WSC的顶点，然后计算所得凸多面体的体积。\n6. **利用对称性的方法**：\n    a. 将 $c_t$ 个候选矢量划分为在群 $G$ 作用下的轨道。轨道数为 $r_t$。\n    b. 从这 $r_t$ 个轨道中，每个轨道选择一个代表矢量。\n    c. 将所有24个群操作应用于这 $r_t$ 个代表矢量，以生成一个完整的法矢量集。去重后，该集合将与原始的 $c_t$ 个候选矢量相同。\n    d. 从这个重新生成的集合构建半空间，并像朴素方法一样计算体积。\n7. 验证两种方法的体积在 $10^{-9}$ 的容差内一致。WSC的体积也必须与原胞的理论体积 $V_{\\text{prim}} = |\\det(a_1, a_2, a_3)|$ 一致，对于SC、BCC和FCC，该体积分别为 $1a^3$、$0.5a^3$ 和 $0.25a^3$，其中 $a$ 是常规晶格常数。实现中使用 $a=1$。\n8. 报告每个用例的结果 $[b_t, v_t, r_t, c_t]$，其中 $b_t$ 是布尔匹配状态， $v_t$ 是计算出的体积， $r_t$ 是轨道代表的数量， $c_t$ 是候选矢量的总数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import HalfspaceIntersection, ConvexHull\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run the Wigner-Seitz cell construction for all test cases.\n    \"\"\"\n\n    def get_octahedral_group():\n        \"\"\"\n        Generates the 24 rotation matrices for the proper octahedral group O.\n        These are the rotational symmetries of a cube.\n        \"\"\"\n        matrices = set()\n        # Permutations of axes\n        for p in itertools.permutations([0, 1, 2]):\n            # Sign flips (even number of negative signs)\n            for signs in itertools.product([-1, 1], repeat=3):\n                if np.prod(signs) == 1:\n                    matrix = np.zeros((3, 3))\n                    matrix[0, p[0]] = signs[0]\n                    matrix[1, p[1]] = signs[1]\n                    matrix[2, p[2]] = signs[2]\n                    # Check determinant just in case (should be sgn(p) * prod(signs))\n                    # but our logic for group O_h is simpler: for any permutation\n                    # and any sign flip, the result is in O_h. For O we need det=+1.\n                    # The combination of permutation and sign flips can be tricky.\n                    # A robust way is to permute columns of I and apply sign flips\n                    # such that det = +1.\n                    # e.g., sgn(p)*prod(s) = 1\n        \n        # A simpler, more direct generation method\n        for p in itertools.permutations([0, 1, 2]):\n            p_matrix = np.eye(3)[:, list(p)]\n            p_sign = np.linalg.det(p_matrix)\n            for signs in itertools.product([-1, 1], repeat=3):\n                s_matrix = np.diag(signs)\n                s_sign = np.prod(signs)\n                if p_sign * s_sign > 0:\n                    matrices.add(tuple((s_matrix @ p_matrix).flatten()))\n\n        # Convert back to list of 3x3 arrays\n        group = [np.array(m).reshape(3, 3) for m in matrices]\n        return group\n\n    def process_case(a_vectors, N, R_cut, tol=1e-9):\n        \"\"\"\n        Processes a single lattice case to compute WSC properties.\n        \"\"\"\n        group = get_octahedral_group()\n        \n        # 1. Generate lattice vectors\n        R_vectors_list = []\n        n_range = range(-N, N + 1)\n        for n1, n2, n3 in itertools.product(n_range, repeat=3):\n            if n1 == 0 and n2 == 0 and n3 == 0:\n                continue\n            R = n1 * a_vectors[0] + n2 * a_vectors[1] + n3 * a_vectors[2]\n            R_vectors_list.append(R)\n\n        # 2. Deduplicate and filter by cutoff\n        unique_vectors_tuples = set()\n        for v in R_vectors_list:\n            # Round to deal with float inaccuracies before adding to set\n            unique_vectors_tuples.add(tuple(np.round(v, int(-np.log10(tol)))))\n\n        candidate_vectors_raw = [np.array(t) for t in unique_vectors_tuples]\n        \n        candidate_vectors = []\n        for R in candidate_vectors_raw:\n            if np.linalg.norm(R) <= R_cut:\n                candidate_vectors.append(R)\n        \n        c_t = len(candidate_vectors)\n\n        # Function to compute volume from a list of vectors\n        def compute_volume_from_vectors(vectors):\n            if not vectors:\n                return 0.0\n            # Define half-spaces: R.x <= 0.5 * ||R||^2 -> R.x - 0.5 * ||R||^2 <= 0\n            # scipy format: A.x + b <= 0, so b is -offset.\n            # Here, scipy wants Ax <= b, so A_i is R_i and b_i is 0.5*||R_i||^2\n            halfspaces = []\n            for R in vectors:\n                norm_sq = np.dot(R, R)\n                # Normal vector must point inwards for scipy's HalfspaceIntersection\n                # But ConvexHull works on vertices, which is more robust\n                # halfspaces format for HalfspaceIntersection: [n_x, n_y, n_z, -d]\n                # for plane n.x=d.我们的平面是 R.x = 0.5||R||^2\n                # half-space是 R.x <= 0.5||R||^2\n                halfspaces.append(np.append(R, -0.5 * norm_sq))\n            \n            # The origin is always an interior point for the WSC\n            interior_point = np.array([0.0, 0.0, 0.0])\n            \n            try:\n                # HalfspaceIntersection expects Ax + b <= 0.\n                # Our R.x <= 0.5*norm_sq is R.x - 0.5*norm_sq <= 0.\n                # So A_i = R_i and b_i = -0.5*norm_sq.\n                hs = HalfspaceIntersection(np.array(halfspaces), interior_point)\n                vertices = hs.intersections\n                if len(vertices) < 4: return 0.0\n                hull = ConvexHull(vertices)\n                return hull.volume\n            except Exception:\n                return -1.0 # Error indicator\n\n        # 3. Naive method\n        vol_naive = compute_volume_from_vectors(candidate_vectors)\n\n        # 4. Symmetry-exploiting method\n        # Partition into orbits\n        unclassified_vectors = {tuple(np.round(v, int(-np.log10(tol)))) for v in candidate_vectors}\n        representatives = []\n        \n        while unclassified_vectors:\n            rep_tuple = unclassified_vectors.pop()\n            rep_vec = np.array(rep_tuple)\n            representatives.append(rep_vec)\n            \n            orbit_tuples = set()\n            for g in group:\n                transformed_vec = g @ rep_vec\n                orbit_tuples.add(tuple(np.round(transformed_vec, int(-np.log10(tol)))))\n            \n            unclassified_vectors -= orbit_tuples\n            \n        r_t = len(representatives)\n\n        # Reconstruct half-spaces\n        reconstructed_vectors_set = set()\n        for rep in representatives:\n            for g in group:\n                transformed_vec = g @ rep\n                reconstructed_vectors_set.add(tuple(np.round(transformed_vec, int(-np.log10(tol)))))\n        \n        reconstructed_vectors = [np.array(v) for v in reconstructed_vectors_set]\n        \n        vol_symm = compute_volume_from_vectors(reconstructed_vectors)\n\n        # 5. Compare and format results\n        b_t = np.isclose(vol_naive, vol_symm, atol=1e-9)\n        v_t = round(vol_symm, 12)\n        \n        return [b_t, v_t, r_t, c_t]\n\n    test_cases = [\n        # Case 1: Simple Cubic (SC)\n        {'a_vectors': [np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0]), np.array([0.0, 0.0, 1.0])], 'N': 2, 'R_cut': 1.01},\n        # Case 2: Body-Centered Cubic (BCC)\n        {'a_vectors': [0.5 * np.array([1.0, 1.0, -1.0]), 0.5 * np.array([1.0, -1.0, 1.0]), 0.5 * np.array([-1.0, 1.0, 1.0])], 'N': 2, 'R_cut': 1.01},\n        # Case 3: Face-Centered Cubic (FCC)\n        {'a_vectors': [0.5 * np.array([0.0, 1.0, 1.0]), 0.5 * np.array([1.0, 0.0, 1.0]), 0.5 * np.array([1.0, 1.0, 0.0])], 'N': 2, 'R_cut': 1.01},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(case['a_vectors'], case['N'], case['R_cut'])\n        all_results.append(result)\n    \n    # Format the final output string exactly as specified.\n    output_parts = []\n    for res in all_results:\n        b_str = str(res[0]).lower()\n        v_str = f\"{res[1]:.12f}\"\n        r_str = str(res[2])\n        c_str = str(res[3])\n        output_parts.append(f\"[{b_str},{v_str},{r_str},{c_str}]\")\n    \n    # Final print statement must produce a single line.\n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "3020917"}]}