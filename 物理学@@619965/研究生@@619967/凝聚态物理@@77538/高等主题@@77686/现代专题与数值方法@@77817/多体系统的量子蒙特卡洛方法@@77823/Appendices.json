{"hands_on_practices": [{"introduction": "在量子蒙特卡洛方法中，我们常常需要在一个复杂的概率分布下计算可观测量，但直接从该分布中采样可能非常困难。重要性采样提供了一个强大的解决方案，它允许我们从一个更简单的、已知的分布中进行采样，然后通过“重加权”来修正结果。这个练习将引导你推导重要性采样的核心公式，并量化当采样分布与目标分布不匹配时，忽略重加权所引入的系统偏差 [@problem_id:3012335]，这是理解所有现代QMC方法统计基础的关键一步。", "problem": "考虑一个多体态的可观测量的量子蒙特卡洛（Quantum Monte Carlo, QMC）估计。令 $x$ 表示一个构型变量，其从一个目标概率密度 $p(x)$ 中抽取。该密度与一个处于平衡态的相互作用费米子晶格的子系统的试验波函数的振幅平方成正比。在实践中，人们通常从一个重要性分布 $q(x)$ 中进行采样，该分布更容易抽样，但与 $p(x)$ 不匹配。一个可观测量 $O(x)$ 在 $p(x)$下的期望值由基本概率法则定义为 $ \\langle O \\rangle_{p} = \\int O(x)\\, p(x)\\, dx$，并且样本 $\\{x_i\\}_{i=1}^{N}$ 是从 $q(x)$ 中独立抽取的。\n\n从基本的测度变换恒等式和期望的性质出发，推导一个用于 $\\langle O \\rangle_{p}$ 的采样估计量，该估计量在 $p(x)$ 仅在相差一个乘法归一化常数的情况下已知，并且 $q(x)$ 不匹配但其支撑集覆盖 $p(x)$ 的非零区域时仍然有效。分析如果使用从 $q(x)$ 抽取的样本，在没有任何重加权的情况下计算朴素样本均值 $\\frac{1}{N}\\sum_{i=1}^{N} O(x_i)$ 所产生的偏差，并用关于 $q(x)$ 和 $p(x)$ 的期望来表示这个偏差。\n\n为了使偏差具体化，考虑多体构型的一个一维边缘分布，其中 $p(x)$ 是标准正态密度 $p(x)=\\frac{1}{\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{x^{2}}{2}\\right)$，而采样是从参数为 $\\mu \\in \\mathbb{R}$ 和 $\\sigma>0$ 的高斯重要性分布 $q(x)=\\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\!\\left(-\\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right)$ 中进行的。令可观测量为 $O(x)=x^{2}$。仅使用高斯积分的公认性质和上述定义，计算朴素估计量的精确偏差，该偏差定义为 $\\mathbb{E}_{q}[O(x)] - \\mathbb{E}_{p}[O(x)]$，并以 $\\mu$ 和 $\\sigma$ 的单个闭式解析表达式形式给出最终答案。不需要单位。如果可以简化，请给出简化后的表达式。最终答案必须是一个解析表达式，不含额外的评注或中间步骤。", "solution": "首先根据所需准则验证问题。\n\n### 第1步：提取已知条件\n-   $x$：构型变量。\n-   $p(x)$：目标概率密度。\n-   $q(x)$：重要性采样分布。\n-   $\\langle O \\rangle_{p} = \\int O(x)\\, p(x)\\, dx$：可观测量 $O(x)$ 在 $p(x)$ 下的期望值。\n-   $\\{x_i\\}_{i=1}^{N}$：从 $q(x)$ 中抽取的 $N$ 个独立样本的集合。\n-   要求1：推导出 $\\langle O \\rangle_{p}$ 的一个采样估计量，该估计量在 $p(x)$ 仅在相差一个乘法归一化常数的情况下已知，并且 $q(x)$ 的支撑集覆盖 $p(x)$ 的非零区域时仍然有效。\n-   要求2：分析使用从 $q(x)$ 中抽取的样本计算朴素估计量 $\\frac{1}{N}\\sum_{i=1}^{N} O(x_i)$ 的偏差。\n-   要求3：用关于 $q(x)$ 和 $p(x)$ 的期望来表示这个偏差。\n-   偏差计算的具体案例：\n    -   目标密度：$p(x)=\\frac{1}{\\sqrt{2\\pi}}\\exp\\left(-\\frac{x^{2}}{2}\\right)$。\n    -   采样密度：$q(x)=\\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\left(-\\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right)$，其中 $\\mu \\in \\mathbb{R}$ 且 $\\sigma>0$。\n    -   可观测量：$O(x)=x^{2}$。\n-   具体案例的偏差定义：$\\mathbb{E}_{q}[O(x)] - \\mathbb{E}_{p}[O(x)]$。\n-   任务：以单个闭式解析表达式的形式计算具体案例的精确偏差。\n\n### 第2步：使用提取的已知条件进行验证\n该问题具有科学依据，提法明确，且客观。它描述了重要性采样这一标准统计方法，这是包括凝聚态物理在内的许多科学领域中蒙特卡洛模拟的基石。这些概念基于基础概率论。该问题提法明确，为一般性推导和具体计算提供了所有必要信息。使用高斯分布和可观测量 $O(x) = x^2$ 构成了一个标准、可解的教科书式问题。不存在矛盾、歧义或事实性错误。该问题要求进行严谨的数学推导和计算，而非主观意见。\n\n### 第3步：结论与行动\n该问题被判定为 **有效**。将提供完整解答。\n\n### 解答推导\n问题的第一部分要求推导一个通用的重要性采样估计量。可观测量 $O(x)$ 相对于概率密度 $p(x)$ 的期望定义为\n$$ \\langle O \\rangle_{p} = \\int O(x) p(x) \\, dx $$\n为了使用来自不同分布 $q(x)$ 的样本，我们采用测度变换的方法。我们将被积函数乘以并除以 $q(x)$，只要在 $O(x)p(x) \\neq 0$ 的地方有 $q(x) > 0$，这个操作就是允许的。这得到：\n$$ \\langle O \\rangle_{p} = \\int O(x) \\frac{p(x)}{q(x)} q(x) \\, dx $$\n这可以被解释为量 $O(x) \\frac{p(x)}{q(x)}$ 相对于分布 $q(x)$ 的期望：\n$$ \\langle O \\rangle_{p} = \\mathbb{E}_{q}\\left[ O(x) \\frac{p(x)}{q(x)} \\right] $$\n项 $w(x) = \\frac{p(x)}{q(x)}$ 被称为重要性权重。给定从 $q(x)$ 中抽取的 $N$ 个独立样本 $\\{x_i\\}_{i=1}^{N}$，$\\langle O \\rangle_{p}$ 的一个蒙特卡洛估计量是重加权可观测量的样本均值：\n$$ \\hat{O}_N = \\frac{1}{N} \\sum_{i=1}^{N} O(x_i) w(x_i) = \\frac{1}{N} \\sum_{i=1}^{N} O(x_i) \\frac{p(x_i)}{q(x_i)} $$\n现在，考虑 $p(x)$ 仅在相差一个归一化常数 $C_p$ 的情况下已知的情况，即 $p(x) = C_p \\tilde{p}(x)$，其中 $\\tilde{p}(x)$ 是未归一化的密度。真实的期望值被恰当地定义为一个比率：\n$$ \\langle O \\rangle_{p} = \\frac{\\int O(x) p(x) \\, dx}{\\int p(x) \\, dx} = \\frac{\\int O(x) C_p \\tilde{p}(x) \\, dx}{\\int C_p \\tilde{p}(x) \\, dx} = \\frac{\\int O(x) \\tilde{p}(x) \\, dx}{\\int \\tilde{p}(x) \\, dx} $$\n对分子和分母同时应用测度变换：\n$$ \\langle O \\rangle_{p} = \\frac{\\int O(x) \\frac{\\tilde{p}(x)}{q(x)} q(x) \\, dx}{\\int \\frac{\\tilde{p}(x)}{q(x)} q(x) \\, dx} = \\frac{\\mathbb{E}_{q}\\left[ O(x) \\frac{\\tilde{p}(x)}{q(x)} \\right]}{\\mathbb{E}_{q}\\left[ \\frac{\\tilde{p}(x)}{q(x)} \\right]} $$\n这导出了自归一化重要性采样（SNIS）估计量。令未归一化的权重为 $\\tilde{w}(x_i) = \\frac{\\tilde{p}(x_i)}{q(x_i)}$。$\\langle O \\rangle_p$ 的估计量是分子和分母的样本均值之比：\n$$ \\hat{O}_{\\text{SNIS}} = \\frac{\\frac{1}{N} \\sum_{i=1}^{N} O(x_i) \\tilde{w}(x_i)}{\\frac{1}{N} \\sum_{j=1}^{N} \\tilde{w}(x_j)} = \\frac{\\sum_{i=1}^{N} O(x_i) \\tilde{w}(x_i)}{\\sum_{j=1}^{N} \\tilde{w}(x_j)} $$\n即使当 $p(x)$ 未归一化时，这个估计量仍然有效。\n\n接下来，我们分析朴素估计量的偏差。朴素估计量就是使用从 $q(x)$ 抽取的样本 $x_i$ 计算的可观测量 $O(x)$ 的样本均值：\n$$ \\hat{O}_{\\text{naive}} = \\frac{1}{N} \\sum_{i=1}^{N} O(x_i) $$\n通过应用期望的线性性质，可以得到该估计量的期望。由于每个 $x_i$ 都根据 $q(x)$ 同分布：\n$$ \\mathbb{E}[\\hat{O}_{\\text{naive}}] = \\mathbb{E}\\left[\\frac{1}{N} \\sum_{i=1}^{N} O(x_i)\\right] = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbb{E}[O(x_i)] = \\mathbb{E}_q[O(x)] $$\n一个估计量的偏差是其期望值与被估计的真值之差。真值为 $\\langle O \\rangle_p = \\mathbb{E}_p[O(x)]$。因此，偏差是：\n$$ \\text{Bias} = \\mathbb{E}[\\hat{O}_{\\text{naive}}] - \\langle O \\rangle_p = \\mathbb{E}_q[O(x)] - \\mathbb{E}_p[O(x)] $$\n这个偏差的表达式在问题陈述中已经给出，我们的分析验证了它。\n\n最后，我们为所提供的具体案例计算这个偏差。我们已知：\n-   目标分布：$p(x)=\\frac{1}{\\sqrt{2\\pi}}\\exp\\left(-\\frac{x^{2}}{2}\\right)$，即标准正态分布 $\\mathcal{N}(0, 1)$。\n-   采样分布：$q(x)=\\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\left(-\\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right)$，即一般正态分布 $\\mathcal{N}(\\mu, \\sigma^2)$。\n-   可观测量：$O(x)=x^{2}$。\n\n我们需要计算期望 $\\mathbb{E}_p[x^2]$ 和 $\\mathbb{E}_q[x^2]$。对于任何均值为 $\\mathbb{E}[X]$、方差为 $\\text{Var}(X)$ 的随机变量 $X$，其二阶矩由关系式 $\\text{Var}(X) = \\mathbb{E}[X^2] - (\\mathbb{E}[X])^2$ 给出。这意味着 $\\mathbb{E}[X^2] = \\text{Var}(X) + (\\mathbb{E}[X])^2$。\n\n首先，我们计算关于 $p(x)$ 的期望。对于标准正态分布 $\\mathcal{N}(0, 1)$，均值为 $0$，方差为 $1$。\n$$ \\mathbb{E}_p[x] = 0 $$\n$$ \\text{Var}_p(x) = 1 $$\n因此，可观测量的期望真值为：\n$$ \\mathbb{E}_p[x^2] = \\text{Var}_p(x) + (\\mathbb{E}_p[x])^2 = 1 + 0^2 = 1 $$\n\n接下来，我们计算关于 $q(x)$ 的期望。对于一般正态分布 $\\mathcal{N}(\\mu, \\sigma^2)$，均值为 $\\mu$，方差为 $\\sigma^2$。\n$$ \\mathbb{E}_q[x] = \\mu $$\n$$ \\text{Var}_q(x) = \\sigma^2 $$\n因此，朴素估计量的期望值为：\n$$ \\mathbb{E}_q[x^2] = \\text{Var}_q(x) + (\\mathbb{E}_q[x])^2 = \\sigma^2 + \\mu^2 $$\n\n偏差是这两个量之差：\n$$ \\text{Bias} = \\mathbb{E}_q[x^2] - \\mathbb{E}_p[x^2] = (\\mu^2 + \\sigma^2) - 1 $$\n最终的偏差为 $\\mu^2 + \\sigma^2 - 1$。该表达式当且仅当 $\\mu=0$ 且 $\\sigma=1$ 时为零，这正如预期的那样，是采样分布与目标分布匹配（$q(x) = p(x)$）的情况。", "answer": "$$\\boxed{\\mu^{2} + \\sigma^{2} - 1}$$", "id": "3012335"}, {"introduction": "超越基本的蒙特卡洛方法，高效的算法设计是推动研究前沿的关键。蠕虫算法（Worm Algorithm）是世界线量子蒙特卡洛中一种强大的更新策略，它通过在扩展的构型空间中引入非对角线“蠕虫”来高效地对格点模型进行采样。此练习将挑战你在连续虚时极限下，直接从细致平衡条件出发，推导蠕虫插入和移除更新的接受率 [@problem_id:3012426]，这是掌握如何为特定物理问题设计高精度、无离散化误差更新方案的核心技能。", "problem": "考虑一个巨正则系综中的玻色多体系统，其哈密顿量为简化到玻色–哈伯德 (Bose–Hubbard) 模型的单个格点，由 $H = \\frac{U}{2}\\hat{n}(\\hat{n}-1) - \\mu \\hat{n}$ 给出，其中 $\\hat{n}$ 是粒子数算符，$U$ 是在位相互作用强度，$\\mu$ 是化学势。在自然单位制中进行计算，其中约化普朗克常数和玻尔兹曼常数满足 $\\hbar = 1$ 和 $k_{\\mathrm{B}} = 1$，因此能量是无量纲的，逆温度 $\\beta$ 的单位是能量的倒数，虚时间 $\\tau$ 的单位也是能量的倒数。在逆温度 $\\beta$ 下，巨正则配分函数为 $Z = \\mathrm{Tr}\\, e^{-\\beta H}$。在连续时间世界线表象中，单个格点上的一个构型由在区间 $[0,\\beta)$ 上的分段常数占据数 $n(\\tau)$（满足虚时间周期性边界条件）指定，其权重正比于 $\\exp\\left(-\\int_{0}^{\\beta} \\mathrm{d}\\tau\\, E(n(\\tau))\\right)$，其中 $E(n) = \\frac{U}{2}n(n-1) - \\mu n$。\n\n您将在一个扩展的构型空间中工作，该空间包含一个用于对非对角关联函数进行采样的蠕虫扇区 (worm sector)。在蠕虫扇区中，一对不连续点（一个蠕虫头和一个蠕虫尾）被插入到虚时间 $\\tau_{\\mathrm{head}}$ 和 $\\tau_{\\mathrm{tail}}$ 处，使得在这两个不连续点之间，占据数相对于对角扇区 (diagonal sector) 增加了 $+1$，而在该区间之外，占据数保持不变。设时间有序的分隔（抬升段的长度）为 $l \\in (0,\\beta)$，因此在 $\\tau_{\\mathrm{tail}}$ 和 $\\tau_{\\mathrm{head}}$ 之间占据数为 $n+1$，其他地方为 $n$。使用一个蠕虫算符，其矩阵元在占据数恰好改变1时等于1，因此没有额外的局域矩阵元因子。引入一个正的、无量纲的调节常数 $\\eta$，用于控制扩展系综中蠕虫扇区权重的相对归一化。在任何阶段都不要对虚时间进行离散化。\n\n您必须仅使用基本原理推导满足细致平衡条件的插入和移除移动的 Metropolis–Hastings 接受概率：\n- 世界线权重为 $w \\propto \\exp\\left(-\\int_{0}^{\\beta} \\mathrm{d}\\tau\\, E(n(\\tau))\\right)$。\n- 细致平衡要求 $P(C)\\, W(C\\to C')\\, A(C\\to C') = P(C')\\, W(C'\\to C)\\, A(C'\\to C)$，其中 $P(C)$ 是扩展系综中构型 $C$ 的未归一化权重，$W$ 表示提议概率或密度，$A$ 是待推导的未知接受概率。\n- 具有恒定占据数 $n$ 的单格点对角扇区构型的权重正比于 $\\exp(-\\beta E(n))$。\n- 具有长度为 $l$ 的抬升段的蠕虫扇区构型的权重正比于 $\\eta \\exp(-( \\beta - l) E(n) - l E(n+1))$。\n\n对于提议移动，采用以下无需时间离散化的显式、连续时间选择：\n- 从对角扇区出发，通过在 $[0,\\beta)$ 上均匀抽取蠕虫尾时间 $\\tau_{\\mathrm{tail}}$，并独立于 $\\tau_{\\mathrm{tail}}$ 从 $(0,\\beta)$ 上的概率密度 $f(l)$ 中抽取段长 $l$ 来提议一次插入。使用均匀的 $f(l)$，即 $f(l) = 1/\\beta$。为明确起见，仅考虑增加 $+1$ 的移动。\n- 从蠕虫扇区出发，通过确定性地选择唯一存在的蠕虫并尝试将其删除来提议一次移除，不涉及额外的随机选择。\n\n基于以上信息，在指定的提议方案下，为任意 $U>0$、实数 $\\mu$、逆温度 $\\beta>0$、整数占据数 $n \\geq 0$、段长 $l \\in (0,\\beta)$ 和调节常数 $\\eta>0$ 推导出满足细致平衡的显式插入和移除接受概率。\n\n接着，为此单格点问题实现一个连续时间蠕虫更新核心程序，用于计算给定参数下以下 Metropolis–Hastings 接受概率：\n- 插入一个蠕虫，使长度为 $l$ 的段上占据数增加 $+1$。\n- 移除该蠕虫。\n\n您的实现必须在虚时间上完全连续，并且不得依赖任何离散化。对于数值评估，请使用以下参数测试套件：\n- 情况 1：$\\beta = 2.0$, $U = 1.0$, $\\mu = 0.5$, $n = 1$, $\\eta = 0.1$, $l = 0.7$。\n- 情况 2：$\\beta = 2.0$, $U = 4.0$, $\\mu = 1.5$, $n = 0$, $\\eta = 0.05$, $l = 1.3$。\n- 情况 3：$\\beta = 10.0$, $U = 8.0$, $\\mu = 2.1$, $n = 2$, $\\eta = 0.01$, $l = 5.0$。\n- 情况 4（能量差为零的边界情况）：$\\beta = 3.0$, $U = 1.2$, $\\mu = 2.4$, $n = 2$, $\\eta = 0.2$, $l = 1.1$。\n\n所有量都应在所述的自然单位制下处理，因此答案是无量纲的实数。\n\n您的程序必须生成单行输出，其中包含上述四种情况的插入和移除接受概率，按顺序排列，形式为用方括号括起来的逗号分隔列表，每个数字四舍五入到十位小数：\n$[\\text{ins}_{1}, \\text{rem}_{1}, \\text{ins}_{2}, \\text{rem}_{2}, \\text{ins}_{3}, \\text{rem}_{3}, \\text{ins}_{4}, \\text{rem}_{4}]$。", "solution": "目标是为连续虚时间中的单格点玻色–哈伯德 (Bose–Hubbard) 模型推导蠕虫插入和移除移动的 Metropolis–Hastings 接受概率。该推导必须遵循细致平衡原理。\n\n系统由哈密顿量 $H = \\frac{U}{2}\\hat{n}(\\hat{n}-1) - \\mu \\hat{n}$ 描述。具有确定占据数 $n$ 的态的能量是 $E(n) = \\frac{U}{2}n(n-1) - \\mu n$。\n\n我们在一个扩展系综中考虑两种类型的构型：\n1.  对角构型 $C_D$，其中对于所有 $\\tau \\in [0, \\beta)$，占据数是常数 $n(\\tau) = n$。此构型的未归一化权重由 $P(C_D) = \\exp(-\\beta E(n))$ 给出。\n2.  蠕虫构型 $C_W$，其特征在于背景占据数 $n$、蠕虫尾时间 $\\tau_{\\mathrm{tail}}$ 和蠕虫长度 $l$。在 $\\tau_{\\mathrm{tail}}$ 和 $\\tau_{\\mathrm{head}} = (\\tau_{\\mathrm{tail}} + l) \\pmod \\beta$ 之间的虚时间间隔上，占据数为 $n+1$，在其他地方为 $n$。此构型的权重包含一个调节常数 $\\eta$，并由 $P(C_W) = \\eta \\exp(-(\\beta - l)E(n) - lE(n+1))$ 给出。这是关于连续变量 $\\tau_{\\mathrm{tail}}$ 和 $l$ 的权重密度。\n\n细致平衡原理指出，在平衡状态下，从态 $C$ 到态 $C'$ 的跃迁速率必须等于从 $C'$ 到 $C$ 的跃迁速率。对于以概率（或概率密度）$W$ 提议并以概率 $A$ 接受的移动，这表示为：\n$$P(C)\\, W(C\\to C')\\, A(C\\to C') = P(C')\\, W(C'\\to C)\\, A(C'\\to C)$$\n\n我们将此原理应用于插入和移除移动。\n\n**1. 插入移动: $C_D \\to C_W$**\n初始状态是具有恒定占据数 $n$ 的对角构型 $C_D$。通过以下方式提议一个蠕虫构型 $C_W$：\n-   从 $[0, \\beta)$ 上的均匀分布中抽取尾部时间 $\\tau_{\\mathrm{tail}}$。其概率密度为 $1/\\beta$。\n-   从 $(0, \\beta)$ 上的均匀分布中抽取蠕虫长度 $l$。其概率密度为 $f(l) = 1/\\beta$。\n\n因为这些选择是独立的，从对角态 $n$ 创建一个特定蠕虫 $(n, l, \\tau_{\\mathrm{tail}})$ 的总提议概率密度为：\n$$W(C_D \\to C_W) = \\frac{1}{\\beta} \\times \\frac{1}{\\beta} = \\frac{1}{\\beta^2}$$\n这是 $(\\tau_{\\mathrm{tail}}, l)$ 空间中的一个概率密度。\n\n**2. 移除移动: $C_W \\to C_D$**\n初始状态是一个蠕虫构型 $C_W$。提议是确定性地移除这个已存在的蠕虫，返回到对角构型 $C_D$。由于此提议是唯一的，并且没有相关的随机变量，其提议概率为：\n$$W(C_W \\to C_D) = 1$$\n\n**3. 细致平衡方程**\n我们现在构建细致平衡方程。正确处理离散概率与连续概率密度的量纲至关重要。该方程必须平衡离散态 $C_D$ 与由 $(\\tau_{\\mathrm{tail}}, l)$ 描述的 $C_W$ 连续状态空间的无穷小区域之间的概率流。\n\n$$P(C_D) \\, W(C_D \\to C_W) \\, A_{\\text{ins}} = P(C_W) \\, W(C_W \\to C_D) \\, A_{\\text{rem}}$$\n其中 $A_{\\text{ins}} = A(C_D \\to C_W)$ 且 $A_{\\text{rem}} = A(C_W \\to C_D)$。\n\nMetropolis–Hastings 对接受概率的选择由 $A(C \\to C') = \\min(1, R)$ 给出，其中比率 $R$ 为：\n$$R = \\frac{P(C') W(C' \\to C)}{P(C) W(C \\to C')}$$\n\n对于插入移动，比率 $R_{\\text{ins}}$ 是：\n$$R_{\\text{ins}} = \\frac{P(C_W) W(C_W \\to C_D)}{P(C_D) W(C_D \\to C_W)}$$\n代入权重和提议概率：\n$$R_{\\text{ins}} = \\frac{\\eta \\exp(-(\\beta - l)E(n) - lE(n+1)) \\cdot 1}{\\exp(-\\beta E(n)) \\cdot (1/\\beta^2)}$$\n化简表达式：\n$$R_{\\text{ins}} = \\eta \\beta^2 \\frac{\\exp(-\\beta E(n) + l E(n) - l E(n+1))}{\\exp(-\\beta E(n))}$$\n$$R_{\\text{ins}} = \\eta \\beta^2 \\exp(l(E(n) - E(n+1)))$$\n令 $\\Delta E = E(n+1) - E(n)$ 为增加一个粒子的能量成本。\n$$R_{\\text{ins}} = \\eta \\beta^2 \\exp(-l \\Delta E)$$\n\n我们计算 $\\Delta E$：\n$$E(n+1) = \\frac{U}{2}(n+1)n - \\mu(n+1)$$\n$$E(n) = \\frac{U}{2}n(n-1) - \\mu n$$\n$$\\Delta E = E(n+1) - E(n) = \\frac{U}{2}[n(n+1) - n(n-1)] - \\mu[(n+1) - n]$$\n$$\\Delta E = \\frac{U}{2}[n^2 + n - n^2 + n] - \\mu[1] = \\frac{U}{2}(2n) - \\mu$$\n$$\\Delta E = U n - \\mu$$\n因此，插入提议的比率为：\n$$R_{\\text{ins}} = \\eta \\beta^2 \\exp(-l(Un - \\mu))$$\n\n插入的接受概率是：\n$$A_{\\text{ins}} = \\min(1, R_{\\text{ins}}) = \\min(1, \\eta \\beta^2 \\exp(-l(Un - \\mu)))$$\n\n对于移除移动，比率 $R_{\\text{rem}}$ 是 $R_{\\text{ins}}$ 的倒数：\n$$R_{\\text{rem}} = \\frac{1}{R_{\\text{ins}}} = \\frac{1}{\\eta \\beta^2} \\exp(l(Un - \\mu))$$\n移除的接受概率是：\n$$A_{\\text{rem}} = \\min(1, R_{\\text{rem}}) = \\min(1, \\frac{1}{\\eta \\beta^2} \\exp(l(Un - \\mu)))$$\n\n这些表达式为任何有效的参数集 $\\beta > 0$、$U>0$、$\\mu \\in \\mathbb{R}$、整数 $n \\ge 0$、$\\eta > 0$ 和 $l \\in (0, \\beta)$ 提供了所需的接受概率。实现将包括为提供的测试用例评估这些公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Metropolis-Hastings acceptance probabilities for worm insertion and\n    removal in a continuous-time QMC simulation of the single-site Bose-Hubbard model.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (beta, U, mu, n, eta, l)\n    test_cases = [\n        # Case 1: beta=2.0, U=1.0, mu=0.5, n=1, eta=0.1, l=0.7\n        (2.0, 1.0, 0.5, 1, 0.1, 0.7),\n        # Case 2: beta=2.0, U=4.0, mu=1.5, n=0, eta=0.05, l=1.3\n        (2.0, 4.0, 1.5, 0, 0.05, 1.3),\n        # Case 3: beta=10.0, U=8.0, mu=2.1, n=2, eta=0.01, l=5.0\n        (10.0, 8.0, 2.1, 2, 0.01, 5.0),\n        # Case 4: beta=3.0, U=1.2, mu=2.4, n=2, eta=0.2, l=1.1\n        (3.0, 1.2, 2.4, 2, 0.2, 1.1),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        beta, U, mu, n, eta, l = case\n        \n        # Calculate the energy difference delta_E = E(n+1) - E(n)\n        # delta_E = (U/2 * (n+1)*n - mu*(n+1)) - (U/2 * n*(n-1) - mu*n)\n        # Simplified to:\n        delta_E = U * n - mu\n        \n        # Calculate the Metropolis-Hastings ratio for the insertion move.\n        # R_ins = eta * beta^2 * exp(-l * delta_E)\n        # This is the ratio of P(C')W(C'->C) / P(C)W(C->C')\n        # where C is the diagonal state and C' is the worm state.\n        # W(C->C') = 1/beta^2 (proposal density)\n        # W(C'->C) = 1 (deterministic proposal)\n        ratio = eta * (beta ** 2) * np.exp(-l * delta_E)\n        \n        # Acceptance probability for insertion is min(1, R_ins)\n        acc_ins = min(1.0, ratio)\n        \n        # Acceptance probability for removal is min(1, 1/R_ins)\n        # To avoid division by zero if `ratio` is extremely small (underflows to 0),\n        # note that `1.0/0.0` yields `inf` in Python, and `min(1.0, inf)` correctly gives 1.0.\n        if ratio == 0:\n            # This happens if l * delta_E is very large and positive.\n            # In this case R_ins = 0, so A_ins = 0.\n            # R_rem = infinity, so A_rem = 1.\n            acc_rem = 1.0\n        else:\n            acc_rem = min(1.0, 1.0 / ratio)\n            \n        results.append(acc_ins)\n        results.append(acc_rem)\n\n    # Format the results to ten decimal places as specified.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3012426"}, {"introduction": "量子蒙特卡洛模拟的最终目标是从计算出的原始数据（如能量）中提取有物理意义的热力学量。热力学积分是一种基本而强大的技术，它利用了统计力学中的基本恒等式，通过对一系列温度下的能量数据进行积分来计算熵。这个实践将指导你如何实现这一过程，并严谨地处理从模拟数据到最终物理量之间误差的传播 [@problem_id:3012293]，这是将模拟结果转化为可靠物理结论的关键步骤。", "problem": "给定一个多体系统的平衡能量在离散温度下的量子蒙特卡洛 (QMC) 测量值。在玻尔兹曼常数 $k_{B}=1$ 的单位制下，您必须实现一个基于热力学积分的熵估计器，并从一系列逆温 $\\beta=1/T$ 下的 QMC 数据中推导出其统计误差。您将从以下平衡统计力学的基本定义和恒等式出发：对于配分函数 $Z(\\beta)$，亥姆霍兹自由能 $F(\\beta)$ 满足 $F(\\beta)=-\\beta^{-1}\\ln Z(\\beta)$ 并且\n$$\\frac{d}{d\\beta}\\bigl(\\beta F(\\beta)\\bigr)=\\langle E\\rangle(\\beta),$$\n其中 $\\langle E\\rangle(\\beta)$ 是能量的热力学期望值。热力学熵遵循 $F=E-TS$，因此\n$$S(\\beta)=\\beta\\bigl(\\langle E\\rangle(\\beta)-F(\\beta)\\bigr)。$$\n\n从这些定义出发，使用离散的 QMC 数据 $\\{(\\beta_{j},\\langle E\\rangle_{j},\\sigma_{E,j})\\}_{j=0}^{i}$ 和在最低可用逆温 $\\beta_{0}$ 处已知的基线值 $B_{0}=\\beta_{0}F(\\beta_{0})$，推导 $S(\\beta_{i})$ 的估计器。合并这些恒等式，得到\n$$\\beta F(\\beta)=\\beta_{0}F(\\beta_{0})+\\int_{\\beta_{0}}^{\\beta}\\langle E\\rangle(\\beta')\\,d\\beta'。$$\n因此，给定 $B_{0}$，目标 $S(\\beta_{i})$ 为\n$$S(\\beta_{i})=\\beta_{i}\\langle E\\rangle_{i}-B_{0}-\\int_{\\beta_{0}}^{\\beta_{i}}\\langle E\\rangle(\\beta')\\,d\\beta'。$$\n在离散网格 $\\beta_{0}<\\beta_{1}<\\cdots<\\beta_{i}$ 上使用复合梯形法则实现该积分：\n$$\\int_{\\beta_{0}}^{\\beta_{i}}\\langle E\\rangle(\\beta')\\,d\\beta' \\approx \\sum_{j=0}^{i-1}\\frac{\\beta_{j+1}-\\beta_{j}}{2}\\bigl(\\langle E\\rangle_{j}+\\langle E\\rangle_{j+1}\\bigr),$$\n这可以重写为线性组合 $\\sum_{j=0}^{i}w_{j}^{(i)}\\langle E\\rangle_{j}$，其权重为\n$$w_{0}^{(i)}=\\frac{\\beta_{1}-\\beta_{0}}{2},\\quad w_{j}^{(i)}=\\frac{\\beta_{j+1}-\\beta_{j-1}}{2}\\ \\text{for}\\ 1\\le j\\le i-1,\\quad w_{i}^{(i)}=\\frac{\\beta_{i}-\\beta_{i-1}}{2}。$$\n假设不同温度下的能量估计值具有独立的、标准差为 $\\sigma_{E,j}$ 的高斯统计误差。在梯形估计下，推导积分和 $S(\\beta_{i})$ 的方差。使用线性误差传播，积分的方差为\n$$\\mathrm{Var}\\!\\left(\\sum_{j=0}^{i}w_{j}^{(i)}\\langle E\\rangle_{j}\\right)=\\sum_{j=0}^{i}\\left(w_{j}^{(i)}\\right)^{2}\\sigma_{E,j}^{2}。$$\n由于 $S(\\beta_{i})=\\beta_{i}\\langle E\\rangle_{i}-B_{0}-\\sum_{j=0}^{i}w_{j}^{(i)}\\langle E\\rangle_{j}$，$\\beta_{i}\\langle E\\rangle_{i}$ 和积分之间的协方差会产生影响。在不同温度下独立的假设下，$\\mathrm{Cov}(\\langle E\\rangle_{i},\\sum_{j}w_{j}^{(i)}\\langle E\\rangle_{j})=w_{i}^{(i)}\\sigma_{E,i}^{2}$。因此，\n$$\\mathrm{Var}\\bigl(S(\\beta_{i})\\bigr)=\\beta_{i}^{2}\\sigma_{E,i}^{2}+\\sum_{j=0}^{i}\\left(w_{j}^{(i)}\\right)^{2}\\sigma_{E,j}^{2}-2\\beta_{i}w_{i}^{(i)}\\sigma_{E,i}^{2}。$$\n您的程序必须：\n- 对于每个测试用例，使用梯形估计器计算所提供网格中所有索引 $i$ 的熵矢量 $S(\\beta_{i})$，以及由上述方差的平方根给出的相应标准不确定度。\n- 接受基线值 $B_{0}=\\beta_{0}F(\\beta_{0})$ 是直接提供，或者如果 $\\beta_{0}=0$，则希尔伯特空间维度 $D$ 是已知的；在后一种情况下，使用 $B_{0}=-\\ln D$，因为 $\\beta F(\\beta)=-\\ln Z(\\beta)$ 且 $Z(0)=D$。\n- 以 $k_{B}$ 为单位表示每个熵（在所采用的单位制中是无量纲的）。没有舍入要求；报告浮点数结果。\n- 不涉及使用弧度或度。\n\n输入作为以下参数集的测试套件嵌入在程序中（每个测试用例包括逆温数组 $\\beta$、平均能量数组 $\\langle E\\rangle$、其标准差数组 $\\sigma_{E}$，以及 $D$ 或 $B_{0}$）：\n1. 案例 A (正常路径，有限希尔伯特空间，基线在 $\\beta_{0}=0$):\n   - $\\beta=[0.0,0.5,1.0,2.0]$\n   - $\\langle E\\rangle=[0.0,-0.35,-0.62,-0.95]$\n   - $\\sigma_{E}=[0.01,0.02,0.02,0.03]$\n   - $D=4$。\n2. 案例 B (边界情况，两点网格，基线在 $\\beta_{0}=0$):\n   - $\\beta=[0.0,3.0]$\n   - $\\langle E\\rangle=[0.0,-1.2]$\n   - $\\sigma_{E}=[0.02,0.05]$\n   - $D=8$。\n3. 案例 C (非零基线在 $\\beta_{0}>0$，不知晓 $D$):\n   - $\\beta=[0.4,0.9,1.1,1.6]$\n   - $\\langle E\\rangle=[-0.2,-0.41,-0.46,-0.61]$\n   - $\\sigma_{E}=[0.03,0.04,0.04,0.05]$\n   - $B_{0}=-0.25$。\n4. 案例 D (边缘情况，具有大误差的非规则网格，基线在 $\\beta_{0}=0$):\n   - $\\beta=[0.0,0.1,0.5,0.8]$\n   - $\\langle E\\rangle=[0.0,-0.05,-0.30,-0.45]$\n   - $\\sigma_{E}=[0.20,0.15,0.10,0.10]$\n   - $D=64$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，并且本身是一个包含两个元素的列表：第一个元素是该案例的 $S(\\beta_{i})$ 值列表，第二个元素是其标准不确定度列表。例如，输出格式必须类似于\n\"[[[S_A_0,S_A_1,...],[sigma_A_0,sigma_A_1,...]],[[S_B_0,S_B_1],[sigma_B_0,sigma_B_1]],...]\" 不含任何额外文本。", "solution": "该问题要求基于一个多体系统能量的离散量子蒙特卡洛 (QMC) 数据，实现一个热力学熵 $S$ 及其统计不确定度的估计器。该解决方案在平衡统计力学框架内构建，其中单位的选择使得玻尔兹曼常数 $k_{B}=1$。\n\n推导始于亥姆霍兹自由能 $F(\\beta)$ 的基本定义，及其与逆温 $\\beta=1/T$ 下的正则配分函数 $Z(\\beta)$ 的关系：\n$$F(\\beta) = -\\frac{1}{\\beta} \\ln Z(\\beta)$$\n这等价于 $\\beta F(\\beta) = -\\ln Z(\\beta)$。能量的热力学期望值 $\\langle E \\rangle(\\beta)$ 通过热力学恒等式与自由能相关联：\n$$\\frac{d}{d\\beta}\\bigl(\\beta F(\\beta)\\bigr) = \\langle E\\rangle(\\beta)$$\n将此恒等式从参考逆温 $\\beta_0$ 积分到目标逆温 $\\beta$ 可得：\n$$\\beta F(\\beta) - \\beta_0 F(\\beta_0) = \\int_{\\beta_0}^{\\beta} \\langle E\\rangle(\\beta') \\,d\\beta'$$\n热力学熵 $S(\\beta)$ 由关系式 $F = \\langle E \\rangle - TS$ 定义，可重写为：\n$$S(\\beta) = \\beta\\bigl(\\langle E\\rangle(\\beta) - F(\\beta)\\bigr)$$\n将 $\\beta F(\\beta)$ 的积分表达式代入熵方程，得到在离散点 $\\beta_i$ 处 $S$ 的期望估计器：\n$$S(\\beta_i) = \\beta_i \\langle E\\rangle_i - \\beta_i F(\\beta_i) = \\beta_i \\langle E\\rangle_i - \\left( \\beta_0 F(\\beta_0) + \\int_{\\beta_0}^{\\beta_i} \\langle E\\rangle(\\beta') \\,d\\beta' \\right)$$\n令 $B_0 = \\beta_0 F(\\beta_0)$ 为已知的基线值，熵估计器的表达式变为：\n$$S(\\beta_i) = \\beta_i \\langle E\\rangle_i - B_0 - \\int_{\\beta_0}^{\\beta_i} \\langle E\\rangle(\\beta') \\,d\\beta'$$\n基线值 $B_0$ 要么直接提供，要么从高温极限 ($\\beta \\to 0$) 确定。在此极限下，配分函数 $Z(0)$ 等于总状态数，即希尔伯特空间维度 $D$。因此，如果 $\\beta_0=0$，我们有 $B_0 = \\lim_{\\beta \\to 0} \\beta F(\\beta) = -\\ln Z(0) = -\\ln D$。在 $\\beta_0=0$ 时，熵为 $S(0) = \\ln D$，其统计不确定度为零，因为它是系统的定义属性，而不是一个测量量。\n\n算法设计通过为一组离散的 QMC 数据点 $\\{(\\beta_j, \\langle E\\rangle_j, \\sigma_{E,j})\\}_{j=0}^{M-1}$ 实现此公式来进行。该积分使用复合梯形法则进行近似。对于一个目标点 $\\beta_i$，积分为：\n$$\\int_{\\beta_0}^{\\beta_i} \\langle E\\rangle(\\beta') \\,d\\beta' \\approx \\sum_{j=0}^{i-1} \\frac{\\beta_{j+1}-\\beta_j}{2} \\bigl(\\langle E\\rangle_j + \\langle E\\rangle_{j+1}\\bigr) = \\sum_{j=0}^{i} w_j^{(i)} \\langle E\\rangle_j$$\n权重 $w_j^{(i)}$ 由问题陈述给出：$w_0^{(i)} = \\frac{\\beta_1-\\beta_0}{2}$，$w_j^{(i)} = \\frac{\\beta_{j+1}-\\beta_{j-1}}{2}$ 对于 $1 \\le j < i$，以及 $w_i^{(i)} = \\frac{\\beta_i-\\beta_{i-1}}{2}$。\n\n为了确定 $S(\\beta_i)$ 的统计不确定度，我们使用线性误差传播。假设不同温度下的能量估计值 $\\langle E\\rangle_j$ 是具有方差 $\\sigma_{E,j}^2$ 的独立随机变量。熵估计器可以写成这些变量的线性组合：\n$$S(\\beta_i) = -B_0 - \\sum_{j=0}^{i-1} w_j^{(i)} \\langle E\\rangle_j + (\\beta_i - w_i^{(i)}) \\langle E\\rangle_i$$\n方差 $\\mathrm{Var}(S(\\beta_i))$ 是各项方差之和，因为 $B_0$ 是一个常数且各 $\\langle E\\rangle_j$ 是独立的：\n$$\\mathrm{Var}\\bigl(S(\\beta_i)\\bigr) = \\sum_{j=0}^{i} c_j^2 \\sigma_{E,j}^2$$\n其中系数 $c_j$ 由 $c_j = -w_j^{(i)}$ (对于 $j < i$) 和 $c_i = \\beta_i - w_i^{(i)}$ 给出。这得出了方差的最终表达式：\n$$\\mathrm{Var}\\bigl(S(\\beta_i)\\bigr) = \\left( \\sum_{j=0}^{i-1} (w_j^{(i)})^2 \\sigma_{E,j}^2 \\right) + (\\beta_i - w_i^{(i)})^2 \\sigma_{E,i}^2$$\n对于起始点 $i=0$，积分为零，因此 $S(\\beta_0) = \\beta_0 \\langle E\\rangle_0 - B_0$。其方差就是 $\\mathrm{Var}(S(\\beta_0)) = \\beta_0^2 \\sigma_{E,0}^2$。\n\n实现的程序遍历输入网格的每个点 $\\beta_i$ ($i=0, \\dots, M-1$)。对于每个 $i$，它首先计算到该点为止的梯形积分值。然后它计算熵 $S(\\beta_i)$。随后，它计算 $j=0, \\dots, i$ 的权重 $w_j^{(i)}$，并根据推导出的公式用它们来计算 $\\mathrm{Var}(S(\\beta_i))$。标准不确定度是该方差的平方根。此过程应用于每个测试用例，并且结果按规定格式化。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"beta\": [0.0, 0.5, 1.0, 2.0],\n            \"energy\": [0.0, -0.35, -0.62, -0.95],\n            \"sigma_E\": [0.01, 0.02, 0.02, 0.03],\n            \"D\": 4,\n            \"B0\": None,\n        },\n        {\n            \"beta\": [0.0, 3.0],\n            \"energy\": [0.0, -1.2],\n            \"sigma_E\": [0.02, 0.05],\n            \"D\": 8,\n            \"B0\": None,\n        },\n        {\n            \"beta\": [0.4, 0.9, 1.1, 1.6],\n            \"energy\": [-0.2, -0.41, -0.46, -0.61],\n            \"sigma_E\": [0.03, 0.04, 0.04, 0.05],\n            \"D\": None,\n            \"B0\": -0.25,\n        },\n        {\n            \"beta\": [0.0, 0.1, 0.5, 0.8],\n            \"energy\": [0.0, -0.05, -0.30, -0.45],\n            \"sigma_E\": [0.20, 0.15, 0.10, 0.10],\n            \"D\": 64,\n            \"B0\": None,\n        },\n    ]\n\n    all_case_results = []\n\n    for case in test_cases:\n        betas = np.array(case[\"beta\"], dtype=float)\n        energies = np.array(case[\"energy\"], dtype=float)\n        sigmas_E = np.array(case[\"sigma_E\"], dtype=float)\n        D = case[\"D\"]\n        B0_val = case[\"B0\"]\n\n        M = len(betas)\n        entropies = np.zeros(M)\n        uncertainties = np.zeros(M)\n        \n        # Determine the baseline value B0\n        if D is not None:\n            # If Hilbert space dimension D is given, B0 = -ln(D).\n            # This applies when beta_0 = 0.\n            B0 = -np.log(D)\n        else:\n            # Otherwise, B0 is given directly.\n            B0 = B0_val\n\n        # Iterate through each temperature point i to calculate S(beta_i)\n        for i in range(M):\n            beta_i = betas[i]\n            energy_i = energies[i]\n            sigma_E_i = sigmas_E[i]\n\n            # --- Entropy Calculation ---\n            # The integral is computed using the composite trapezoidal rule from beta_0 to beta_i.\n            integral_val = 0.0\n            if i > 0:\n                for j in range(i):\n                    # Sum of trapezoid areas from j to j+1\n                    h = betas[j+1] - betas[j]\n                    avg_E = (energies[j] + energies[j+1])\n                    integral_val += h * avg_E / 2.0\n            \n            # S(beta_i) = beta_i * <E>_i - B0 - integral\n            entropies[i] = beta_i * energy_i - B0 - integral_val\n            \n            # --- Variance and Uncertainty Calculation ---\n            if i == 0:\n                # For i=0, integral is 0. S_0 = beta_0 * E_0 - B0.\n                # Var(S_0) = Var(beta_0 * E_0) = beta_0^2 * sigma_E_0^2.\n                var_S_i = (beta_i**2) * (sigma_E_i**2)\n            else:\n                # For i>0, use the full error propagation formula.\n                # Var(S_i) = (beta_i - w_i)^2 * sigma_E_i^2 + sum_{j=0}^{i-1} w_j^2 * sigma_E_j^2\n                \n                # Calculate weights w_j^(i) for the integral from beta_0 to beta_i\n                weights = np.zeros(i + 1)\n                weights[0] = (betas[1] - betas[0]) / 2.0\n                if i > 1:\n                    for j in range(1, i):\n                        weights[j] = (betas[j+1] - betas[j-1]) / 2.0\n                weights[i] = (betas[i] - betas[i-1]) / 2.0\n\n                # Variance from the i-th energy measurement\n                var_term_i = ((beta_i - weights[i])**2) * (sigma_E_i**2)\n\n                # Variance from all other energy measurements (j < i)\n                var_sum_rest = np.sum(weights[:i]**2 * sigmas_E[:i]**2)\n\n                var_S_i = var_term_i + var_sum_rest\n\n            uncertainties[i] = np.sqrt(var_S_i)\n            \n            # Handle the specific case of beta_0=0 where S(0)=ln(D) is exact.\n            if betas[0] == 0.0 and i == 0:\n                uncertainties[0] = 0.0\n\n        all_case_results.append([entropies.tolist(), uncertainties.tolist()])\n    \n    # Format the final output string to match the required format exactly.\n    def format_single_case_result(res):\n        s_list_str = f\"[{','.join(map(str, res[0]))}]\"\n        sigma_list_str = f\"[{','.join(map(str, res[1]))}]\"\n        return f\"[{s_list_str},{sigma_list_str}]\"\n    \n    final_strings = [format_single_case_result(r) for r in all_case_results]\n    print(f\"[{','.join(final_strings)}]\")\n\nsolve()\n```", "id": "3012293"}]}