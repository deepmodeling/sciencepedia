{"hands_on_practices": [{"introduction": "掌握密度矩阵重整化群（DMRG）的第一步是理解其核心：矩阵乘积态（MPS）。这个练习将通过一个具体的例子——著名的格林伯格-霍恩-塞林格（GHZ）态——来引导你动手构建一个MPS。通过这个过程，你将直观地理解MPS如何编码量子纠缠，并揭示其关键参数“键维数”与态的纠缠度之间的深刻联系。", "problem": "在计算化学中使用的密度矩阵重整化群 (DMRG) 的背景下，矩阵乘积态 (MPS) 形式论用于表示一维格点上的量子态。考虑一个由 $N=3$ 个格点组成的链，每个格点对应一个自旋轨道，其局域占据数为基 $\\{|0\\rangle, |1\\rangle\\}$。一个态 $|\\Psi\\rangle$ 的开边界 MPS 可以写为\n$$\n|\\Psi\\rangle=\\sum_{s_1,s_2,s_3\\in\\{0,1\\}} \\left(v_L A^{[1] s_1} A^{[2] s_2} A^{[3] s_3} v_R\\right) |s_1 s_2 s_3\\rangle,\n$$\n其中 $A^{[i] s_i}$ 是与物理指标 $s_i\\in\\{0,1\\}$ 相关联的、依赖于格点的矩阵（具有兼容的键维数），而 $v_L$ 和 $v_R$ 是实现开边界条件的边界向量。考虑 $3$ 个格点上的 Greenberger–Horne–Zeilinger (GHZ) 态，\n$$\n|\\Psi_{\\mathrm{GHZ}}\\rangle=\\frac{1}{\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right).\n$$\n构造一个能精确生成具有正确归一化的 $|\\Psi_{\\mathrm{GHZ}}\\rangle$ 的显式开边界 MPS 表示，并确定任何在 $3$ 个格点上精确表示 $|\\Psi_{\\mathrm{GHZ}}\\rangle$ 的开边界 MPS 所需的最小键维数 $D_{\\min}$。最终答案只需报告 $D_{\\min}$ 的值。", "solution": "该问题在量子力学和张量网络理论的框架内得到了很好的定义，所有前提在事实上和科学上都是合理的。因此，我们可以直接进行形式推导。\n\n目标是确定 $N=3$ 格点 Greenberger–Horne–Zeilinger (GHZ) 态的精确开边界矩阵乘积态 (MPS) 表示所需的最小键维数，记为 $D_{\\min}$：\n$$ |\\Psi_{\\mathrm{GHZ}}\\rangle=\\frac{1}{\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right) $$\nMPS 态理论中的一个基本结果是，对于一维量子系统，在格点 $k$ 和格点 $k+1$ 之间的虚拟链上所需的最小键维数 $D_k$，恰好是量子态在将前 $k$ 个格点与其余 $N-k$ 个格点分开的二分划分下的施密特秩 $\\chi_k$。MPS 的总最小键维数 $D_{\\min}$ 是所有可能二分划分下这些施密特秩的最大值：\n$$ D_{\\min} = \\max_{1 \\le k < N} \\chi_k $$\n对于给定的 $N=3$ 格点系统，需要考虑两种这样的二分划分。\n\n1.  **在 $k=1$ 处的二分划分**：此切分将格点 $1$ 与格点 $\\{2, 3\\}$ 分开。为了找到施密特秩 $\\chi_1$，我们将 $|\\Psi_{\\mathrm{GHZ}}\\rangle$ 在一个能明确体现此划分的基中表示：\n    $$ |\\Psi_{\\mathrm{GHZ}}\\rangle = \\frac{1}{\\sqrt{2}} |0\\rangle_1 \\otimes |00\\rangle_{23} + \\frac{1}{\\sqrt{2}} |1\\rangle_1 \\otimes |11\\rangle_{23} $$\n    这是该态在指定切分下的施密特分解。态 $\\{|0\\rangle_1, |1\\rangle_1\\}$ 构成第一个子系统的正交归一基，而态 $\\{|00\\rangle_{23}, |11\\rangle_{23}\\}$ 构成第二个子系统的正交归一集。存在两个非零的施密特系数，$\\lambda_1 = \\frac{1}{\\sqrt{2}}$ 和 $\\lambda_2 = \\frac{1}{\\sqrt{2}}$。非零系数的数量定义了施密特秩。因此，对于此切分，施密特秩为 $\\chi_1 = 2$。\n\n2.  **在 $k=2$ 处的二分划分**：此切分将格点 $\\{1, 2\\}$ 与格点 $3$ 分开。我们为此划分重新表示 $|\\Psi_{\\mathrm{GHZ}}\\rangle$：\n    $$ |\\Psi_{\\mathrm{GHZ}}\\rangle = \\frac{1}{\\sqrt{2}} |00\\rangle_{12} \\otimes |0\\rangle_3 + \\frac{1}{\\sqrt{2}} |11\\rangle_{12} \\otimes |1\\rangle_3 $$\n    这同样是施密特分解。态 $\\{|00\\rangle_{12}, |11\\rangle_{12}\\}$ 构成第一个子系统的正交归一集，而 $\\{|0\\rangle_3, |1\\rangle_3\\}$ 构成第二个子系统的正交归一基。和之前一样，存在两个非零的施密特系数，$\\lambda_1 = \\frac{1}{\\sqrt{2}}$ 和 $\\lambda_2 = \\frac{1}{\\sqrt{2}}$。因此，此切分的施密特秩为 $\\chi_2 = 2$。\n\n综合这些结果，在 $3$ 个格点上精确表示 $|\\Psi_{\\mathrm{GHZ}}\\rangle$ 的 MPS 所需的最小键维数是所计算出的施密特秩的最大值：\n$$ D_{\\min} = \\max\\{\\chi_1, \\chi_2\\} = \\max\\{2, 2\\} = 2 $$\n这个值既是必要的（由施密特分解证明），也是充分的（因为存在一个键维数 $D=2$ 的显式 MPS 构造）。然而，问题只要求 $D_{\\min}$ 的值。", "answer": "$$\\boxed{2}$$", "id": "2453969"}, {"introduction": "在能够表示量子态之后，下一步是学习如何表示作用于这些态的算符，尤其是哈密顿量。本练习将挑战你将一个凝聚态物理中的标准模型——横场伊辛模型——的哈密顿量“翻译”成矩阵乘积算符（MPO）的形式，这是进行任何DMRG计算的关键步骤。通过构建MPO，你将掌握如何高效地将一个具有局域相互作用的哈密顿量编码为张量网络，并理解其结构如何决定了所需的最小键维数。", "problem": "考虑一个长度为 $N \\geq 2$ 的开链上的一维($1$D)横场伊辛哈密顿量，\n$$\nH = -\\sum_{i=1}^{N} \\left( g\\, \\sigma_i^{x} \\right) - \\sum_{i=1}^{N-1} \\left( \\sigma_i^{z} \\sigma_{i+1}^{z} \\right),\n$$\n其中 $\\sigma^{x}$ 和 $\\sigma^{z}$ 是泡利算符，$g$ 是一个实数参数。我们希望将 $H$ 精确地表示为一个矩阵乘积算符(MPO)，该MPO使用一个平移不变的体张量和开放边界矢量，且局域算符基限制在 $\\{ I, \\sigma^{x}, \\sigma^{z} \\}$ 内。MPO的辅助键维度用 $D$ 表示。\n\n确定对于所有链长 $N \\geq 2$ 都能精确表示 $H$ 的这种MPO存在的最小整数 $D$。以单个整数形式给出你的答案。无需四舍五入，也无需单位。", "solution": "该问题要求确定在一维开链上，对于给定的横场伊辛哈密顿量，其精确矩阵乘积算符(MPO)表示的最小辅助键维度 $D$。该哈密顿量为\n$$ H = -\\sum_{i=1}^{N} \\left( g\\, \\sigma_i^{x} \\right) - \\sum_{i=1}^{N-1} \\left( \\sigma_i^{z} \\sigma_{i+1}^{z} \\right) $$\n该MPO必须使用一个平移不变的体张量、开放边界矢量，并由限制在 $\\{ I, \\sigma^{x}, \\sigma^{z} \\}$ 内的局域算符基构成。\n\n首先，我们验证问题陈述的合理性。\n给定的已知条件是：\n- 哈密顿量：$H = -\\sum_{i=1}^{N} \\left( g\\, \\sigma_i^{x} \\right) - \\sum_{i=1}^{N-1} \\left( \\sigma_i^{z} \\sigma_{i+1}^{z} \\right)$。\n- 系统：长度为 $N \\geq 2$ 的一维开链。\n- 算符：$\\sigma^{x}$ 和 $\\sigma^{z}$ 是泡利算符。\n- 参数：$g$ 是一个实数参数。\n- 表示：精确矩阵乘积算符(MPO)。\n- MPO结构：平移不变的体张量和开放边界矢量。\n- 局域算符基：$\\{ I, \\sigma^{x}, \\sigma^{z} \\}$。\n- 目标：找到最小整数键维度 $D$。\n\n该问题具有科学依据，因为横场伊辛模型和MPO是凝聚态物理和计算科学中的基本概念。问题是适定的、客观的且自洽的。没有矛盾或信息缺失。因此，该问题被认为是有效的，我们将构造一个解。\n\nMPO将一个全局算符表示为局域张量的乘积。对于一个由局域项之和构成的哈密顿量，MPO可以被看作是一个生成算符串的有限自动机。MPO的键维度 $D$ 对应于此自动机中的状态数。在每个格点 $i$，自动机从左键读取虚拟态，在格点 $i$ 输出一个局域算符，并跃迁到一个新的虚拟态作为右键。完整的哈密顿量是由从一个指定的起始态到指定的终止态的所有有效路径生成的算符串之和。\n\n该哈密顿量包含两种类型的项：\n1.  在位项：对每个格点 $i$ 有 $-g\\sigma_i^x$。\n2.  最近邻项：对每对格点 $(i, i+1)$ 有 $-\\sigma_i^z \\sigma_{i+1}^z$。\n\n让我们分析一个自动机生成这些项所需的最小状态数。\n我们需要一个'起始'态，它对应于向右传播一个单位算符 $I$ 直到一个哈密顿量项开始。我们将这个状态标记为 $1$。\n我们需要一个'终止'或'汇'态，它对应于完成一个项，之后只应用单位算符。我们将这个状态标记为 $D$。\n\n考虑最近邻项 $-\\sigma_i^z \\sigma_{i+1}^z$。为了生成这一项，自动机必须在格点 $i$ 输出一个包含 $-\\sigma_i^z$ 的算符，并从'起始'态跃迁到一个中间态。将这个中间态标记为 $k$。在下一个格点 $i+1$，自动机必须输出一个包含 $\\sigma_{i+1}^z$ 的算符，并从状态 $k$ 跃迁到'终止'态。这个需要“记忆”一个格点的两步过程的存在，要求有一个不同于起始态和终止态的中间态。\n\n因此，我们至少需要三个状态：\n- 状态 1：'起始'态，在放置任何项的非单位部分之前。\n- 状态 2：中间态，在放置一个 $-\\sigma^z$ 之后，等待随后的 $\\sigma^z$。\n- 状态 3：'终止'态，在形成一个完整的项之后。\n\n这一推理路线意味着最小键维度为 $D \\ge 3$。$D=1$ 的键维度显然是不够的，因为它只能表示 $O_1 \\otimes O_2 \\otimes \\dots \\otimes O_N$ 形式的算符。$D=2$ 的维度也是不够的，因为它缺少必要的中间态来正确形成最近邻项 $-\\sigma_i^z \\sigma_{i+1}^z$ 而不会产生虚假的、不想要的项。例如，任何试图仅用一个起始态和一个终止态来创建两格点项的尝试，都需要一条诸如 $1 \\to 1 \\to 2$ 或 $1 \\to 2 \\to 2$ 的路径。前者会生成不正确的算符乘积, 后者会从MPO张量的 $(2,2)$ 元素中的项产生不想要的算符串。\n\n现在，我们通过显式构造来证明 $D=3$ 是足够的。我们定义一个 $3 \\times 3$ 的矩阵 $W$，其元素是来自指定局域基的算符。这个矩阵代表平移不变的体张量。\n$$\nW = \\begin{pmatrix}\nI & -\\sigma^z & -g\\sigma^x \\\\\n0 & 0 & \\sigma^z \\\\\n0 & 0 & I\n\\end{pmatrix}\n$$\n格点 $i$ 上的算符是 $W_i$，其中算符 $I, \\sigma^x, \\sigma^z$ 作用在格点 $i$ 的局域希尔伯特空间上。完整的哈密顿量被构造为这些张量矩阵乘积的一个特定元素。乘积定义为 $(A \\odot B)_{\\alpha\\gamma} = \\sum_{\\beta} A_{\\alpha\\beta} \\otimes B_{\\beta\\gamma}$。对于长度为 $N$ 的开链，哈密顿量由 $H = (L \\cdot (\\odot_{i=1}^N W_i) \\cdot R^T)$ 给出，其中 $L$ 和 $R$ 是边界矢量。\n\n我们选择左边界矢量 $L = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}$ 和右边界矢量 $R = \\begin{pmatrix} 0 & 0 & 1 \\end{pmatrix}$。这个选择选取了总乘积矩阵 $M^{(N)} = \\odot_{i=1}^N W_i$ 的 $(1,3)$ 元素。\n让我们分析对 $M^{(N)}_{1,3}$ 有贡献的算符串。一个项是由一串虚拟指标 $(\\alpha_0, \\alpha_1, \\dots, \\alpha_N)$ 形成的路径构成的，其中 $\\alpha_0=1$ 且 $\\alpha_N=3$。这样一条路径的算符乘积是 $\\bigotimes_{i=1}^N (W_i)_{\\alpha_{i-1}, \\alpha_i}$。\n\n$W$ 的非零元素只允许从状态 $1$ 到状态 $3$ 的两种非平凡路径：\n\n1.  在某个格点 $i$ 从状态 $1$ 直接跳到状态 $3$。\n    路径是 $(1, \\dots, 1, 3, \\dots, 3)$，其中跃迁 $1 \\to 3$ 发生在格点 $i$。对应的算符是：\n    $$ (W_1)_{1,1} \\otimes \\dots \\otimes (W_{i-1})_{1,1} \\otimes (W_i)_{1,3} \\otimes (W_{i+1})_{3,3} \\otimes \\dots \\otimes (W_N)_{3,3} $$\n    $$ = I_1 \\otimes \\dots \\otimes I_{i-1} \\otimes (-g\\sigma_i^x) \\otimes I_{i+1} \\otimes \\dots \\otimes I_N = -g\\sigma_i^x $$\n    对所有可能的格点 $i=1, \\dots, N$ 求和，生成了哈密顿量的在位部分 $\\sum_{i=1}^N (-g \\sigma_i^x)$。\n\n2.  从状态 $1$ 到 $2$，然后立即到 $3$ 的路径。\n    路径是 $(1, \\dots, 1, 2, 3, \\dots, 3)$，其中跃迁 $1 \\to 2$ 发生在格点 $i$，跃迁 $2 \\to 3$ 发生在格点 $i+1$。任何在状态 $2$ 停留超过一步的路径都为零，因为 $W_{2,2}=0$。此路径的算符为：\n    $$ (W_1)_{1,1} \\otimes \\dots \\otimes (W_i)_{1,2} \\otimes (W_{i+1})_{2,3} \\otimes \\dots \\otimes (W_N)_{3,3} $$\n    $$ = I_1 \\otimes \\dots \\otimes I_{i-1} \\otimes (-\\sigma_i^z) \\otimes (\\sigma_{i+1}^z) \\otimes I_{i+2} \\otimes \\dots \\otimes I_N = -\\sigma_i^z \\sigma_{i+1}^z $$\n    对所有可能的起始格点 $i=1, \\dots, N-1$ 求和，生成了哈密顿量的最近邻部分 $\\sum_{i=1}^{N-1} (-\\sigma_i^z \\sigma_{i+1}^z)$。\n\n由于 $W$ 的结构，所有其他从状态 $1$ 到 $3$ 的路径都为零。这两种路径的所有贡献之和精确地重构了完整的哈密顿量 $H$。所使用的局域算符\n($I, -g\\sigma^x, -\\sigma^z, \\sigma^z$) 都在允许的基 $\\{I, \\sigma^x, \\sigma^z\\}$ 的张成空间内。该构造对任何 $N \\ge 2$ 都有效。\n\n因为 $D=3$ 是足够的，并且我们已经论证了 $D < 3$ 是不足够的，所以最小的整数键维度是 $3$。", "answer": "$$\\boxed{3}$$", "id": "2453975"}, {"introduction": "实际的DMRG计算总是在有限的键维数 $\\chi$ 下进行，这必然会引入截断误差。这个高级实践将引导你完成一个获取高精度结果的核心流程：将能量外推至零误差极限。你将通过一个数值实验，亲手研究计算得到的能量 $E(\\chi)$ 与衡量截断误差的“舍弃权重” $w_{\\mathrm{disc}}$ 之间的关系，并利用该关系获得比任何单次有限 $\\chi$ 计算都更精确的基态能量估计值。", "problem": "考虑一个一维自旋-$\\frac{1}{2}$链，其由具有开放边界条件的横向场伊辛模型描述，哈密顿量定义为\n$$\n\\hat{H} = -J \\sum_{i=1}^{L-1} \\hat{\\sigma}^z_i \\hat{\\sigma}^z_{i+1} - h \\sum_{i=1}^{L} \\hat{\\sigma}^x_i,\n$$\n其中 $\\hat{\\sigma}^x$和 $\\hat{\\sigma}^z$是作用于每个格点上的 Pauli 算符，$L$是链长，$J$是相互作用强度，$h$是横向场。在$J=1$的单位制下，通过精确对角化得到基态波函数$\\ket{\\Psi_0}$。对于一系列递增的键维$\\chi$，通过在链上进行单次从左到右的扫描，在每个键上将 Schmidt 谱截断至$\\chi$个奇异值，从而近似基态。将总舍弃权重定义为\n$$\nw_{\\mathrm{disc}} = \\sum_{i=1}^{L-1} \\sum_{\\alpha > \\chi} \\lambda_{i,\\alpha}^2,\n$$\n其中 $\\{\\lambda_{i,\\alpha}\\}$是在键$i$处进行 Schmidt 分解得到的奇异值，对$\\alpha$的求和遍历了在该次扫描中于该键上被舍弃的奇异值。扫描结束后，将截断后的态$\\ket{\\tilde{\\Psi}}$重新归一化，并计算能量期望值\n$$\nE(\\chi) = \\bra{\\tilde{\\Psi}} \\hat{H} \\ket{\\tilde{\\Psi}}.\n$$\n你的任务是，对于一系列递增$\\chi$的矩阵乘积态 (MPS)，计算$E$与$w_{\\mathrm{disc}}$的关系，然后通过使用线性和二次模型拟合$E$作为$w_{\\mathrm{disc}}$的函数，将结果外推至$w_{\\mathrm{disc}} \\to 0$。外推能量定义为所选拟合在$w_{\\mathrm{disc}} = 0$处的截距：\n$$\nE_0^{\\mathrm{lin}} \\text{ from } E(w) = c_0 + c_1 w, \\quad E_0^{\\mathrm{quad}} \\text{ from } E(w) = c_0 + c_1 w + c_2 w^2,\n$$\n其中$w \\equiv w_{\\mathrm{disc}}$。为判断应采用线性拟合还是二次拟合，使用以下受微扰论证启发的选择标准：如果同时满足\n$$\n\\rho \\equiv \\frac{|c_2| \\, \\bar{w}}{|c_1| + \\epsilon} > \\tau\n$$\n和\n$$\n\\Delta R^2 \\equiv R^2_{\\mathrm{quad}} - R^2_{\\mathrm{lin}} > \\eta,\n$$\n则选择二次拟合，否则选择线性拟合。此处$\\bar{w}$是观测到的$w$值的平均值，$R^2$是决定系数，阈值为$\\epsilon = 10^{-12}$，$\\tau = 2 \\times 10^{-1}$和$\\eta = 10^{-3}$。\n\n请对以下参数集测试套件实施上述过程，所有参数均在$J=1$的单位制下：\n- 情况 A (有能隙区，理想情况)：$L = 10$，$h = 5 \\times 10^{-1}$，$\\chi \\in \\{2, 4, 8, 16\\}$。\n- 情况 B (临界区)：$L = 10$，$h = 1$，$\\chi \\in \\{2, 4, 8, 16\\}$。\n- 情况 C (强场边缘情况)：$L = 8$，$h = 2$，$\\chi \\in \\{2, 3, 4, 5, 6\\}$。\n\n对于每种情况，计算数据点对序列$(w_{\\mathrm{disc}}(\\chi), E(\\chi))$，执行线性和二次拟合，应用选择标准来判断应使用线性还是二次外推，并报告所选的拟合类型以及外推到$w_{\\mathrm{disc}} \\to 0$时的能量截距。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每种情况，输出拟合类型代码，后跟外推能量。其中，线性拟合的类型代码为$1$，二次拟合的类型代码为$2$，外推能量为一个保留$6$位小数的浮点数。例如，格式应为\n$$\n[\\text{type}_A, E_{0,A}, \\text{type}_B, E_{0,B}, \\text{type}_C, E_{0,C}],\n$$\n其中$E_{0}$以$J=1$设定的无量纲能量单位表示。", "solution": "用户希望解决一个涉及横向场伊辛模型 (TFIM) 的计算物理问题。该问题被认为是有效的，因为它在凝聚态物理学中有科学依据，问题陈述清晰，定义了所有必要的参数和步骤，并以客观、正式的语言编写。它没有违反任何无效标准。我们将进行完整解答。\n\n问题的核心是研究近似基态的能量与其近似所引入的误差之间的关系。这种近似是通过截断精确基态而得到的矩阵乘积态 (MPS)。误差通过“舍弃权重”来量化，即截断过程中丢弃的 Schmidt 系数平方和。已知对于较小的舍弃权重，能量误差与舍弃权重之间的关系近似呈线性，$E(\\chi) - E_{exact} \\propto w_{\\mathrm{disc}}$。这提供了一种强有力的方法，可以从有限键维$\\chi$下的计算结果外推出精确的基态能量($w_{\\mathrm{disc}} \\to 0$)。问题要求我们使用线性和二次拟合来执行此外推，并基于有物理动机的标准选择更合适的模型。\n\n总体步骤如下：\n1.  **构建哈密顿量**: 对于给定的链长 $L$ 和横向场 $h$ (相互作用 $J=1$)，TFIM 哈密顿量 $\\hat{H}$ 被构建为一个 $2^L \\times 2^L$ 的矩阵。哈密顿量中的每一项，如 $\\hat{\\sigma}^z_i \\hat{\\sigma}^z_{i+1}$ 或 $\\hat{\\sigma}^x_i$，都是通过 Pauli 矩阵和单位矩阵的张量积 (Kronecker 积) 来表示的。\n2.  **求解精确基态**: 哈密顿量矩阵是实对称的。我们使用精确对角化程序 (具体为 `scipy.linalg.eigh`) 来找到其特征值和特征向量。基态 $\\ket{\\Psi_0}$ 是对应于最低特征值的特征向量。\n3.  **生成近似 MPS 并计算可观测量**: 对于指定集合中的每个键维 $\\chi$，我们生成一个近似的 MPS $\\ket{\\tilde{\\Psi}(\\chi)}$，并计算相应的总舍弃权重 $w_{\\mathrm{disc}}(\\chi)$ 和能量 $E(\\chi)$。这是通过在链的键上进行一次从左到右的“扫描”来完成的：\n    a. 我们从精确基态向量的一个副本开始，$\\ket{\\Psi} = \\ket{\\Psi_0}$。\n    b. 对于从 $1$ 到 $L-1$ 的每个键 $i$，我们执行一次 Schmidt 分解。这包括将态向量 $\\ket{\\Psi}$ (大小为 $2^L$) 重塑为一个大小为 $2^i \\times 2^{L-i}$ 的矩阵 $M$，从而有效地将系统二分。\n    c. 然后我们计算 $M$ 的奇异值分解 (SVD)。奇异值即为 Schmidt 系数 $\\{\\lambda_{i,\\alpha}\\}$。\n    d. 通过对被舍弃的奇异值的平方求和来累积总舍弃权重：$\\sum_{\\alpha > \\chi} \\lambda_{i,\\alpha}^2$。此和被加到 $w_{\\mathrm{disc}}(\\chi)$ 的运行总和中。\n    e. 通过仅使用最大的 $\\chi$ 个奇异值及其对应的奇异向量来重构矩阵 $M$，从而更新态向量。然后将这个截断后的矩阵重新展平为一个向量，该向量成为扫描下一步的态 $\\ket{\\Psi}$。\n    f. 扫描完成后 (即遍历所有 $L-1$ 个键之后)，我们得到最终的截断态向量 $\\ket{\\tilde{\\Psi}(\\chi)}$。该态需要被归一化。\n    g. 能量 $E(\\chi)$ 作为期望值 $E(\\chi) = \\bra{\\tilde{\\Psi}(\\chi)} \\hat{H} \\ket{\\tilde{\\Psi}(\\chi)}$ 进行计算。\n4.  **外推能量**: 在获得了一系列键维的数据点 $(w_{\\mathrm{disc}}(\\chi_j), E(\\chi_j))$ 后，我们对 $E$ 作为 $w \\equiv w_{\\mathrm{disc}}$ 的函数执行两种多项式拟合：\n    *   **线性拟合**: $E(w) = c_0^{\\mathrm{lin}} + c_1^{\\mathrm{lin}} w$。外推能量为 $E_0^{\\mathrm{lin}} = c_0^{\\mathrm{lin}}$。\n    *   **二次拟合**: $E(w) = c_0^{\\mathrm{quad}} + c_1^{\\mathrm{quad}} w + c_2^{\\mathrm{quad}} w^2$。外推能量为 $E_0^{\\mathrm{quad}} = c_0^{\\mathrm{quad}}$。\n    拟合使用 `numpy.polyfit` 执行。\n5.  **选择最佳拟合**: 基于两个标准在线性和二次模型之间做出选择，这些标准旨在评估二次模型的额外复杂性是否合理。\n    *   第一个标准 $\\rho = |c_2| \\bar{w} / (|c_1| + \\epsilon) > \\tau$ 比较了在平均舍弃权重 $\\bar{w}$ 处的二次修正项的量级与线性项的量级。\n    *   第二个标准 $\\Delta R^2 = R^2_{\\mathrm{quad}} - R^2_{\\mathrm{lin}} > \\eta$ 检查二次模型在决定系数 $R^2$ 方面是否提供了足够好的改进。\n    *   如果两个标准都满足，则选择二次拟合 (拟合类型代码 $2$)。否则，选择更简洁的线性拟合 (拟合类型代码 $1$)。\n\n这整个过程将应用于问题中指定的三个测试用例中的每一个。最终输出是一个列表，其中包含每种情况下选择的拟合类型和相应的外推能量，并按要求格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\nimport functools\n\ndef solve():\n    \"\"\"\n    Solves the transverse-field Ising model problem as specified.\n    - Computes exact ground state via diagonalization.\n    - For a series of bond dimensions chi, approximates the ground state via MPS truncation\n      in a single sweep, calculating discarded weight and energy.\n    - Extrapolates energy to zero discarded weight using linear and quadratic fits.\n    - Selects the best fit based on given criteria and reports the result.\n    \"\"\"\n    \n    # Define test cases as per the problem statement\n    test_cases = [\n        {'L': 10, 'h': 0.5, 'J': 1.0, 'chi_values': [2, 4, 8, 16]},\n        {'L': 10, 'h': 1.0, 'J': 1.0, 'chi_values': [2, 4, 8, 16]},\n        {'L': 8,  'h': 2.0, 'J': 1.0, 'chi_values': [2, 3, 4, 5, 6]}\n    ]\n\n    # Constants for model selection criteria\n    epsilon = 1e-12\n    tau = 0.2\n    eta = 0.001\n\n    # Pauli matrices and Identity\n    sigma_x = np.array([[0, 1], [1, 0]], dtype=float)\n    sigma_z = np.array([[1, 0], [0, -1]], dtype=float)\n    identity = np.identity(2, dtype=float)\n\n    memoized_hamiltonians = {}\n    \n    def get_hamiltonian(L, h, J):\n        \"\"\"Constructs the TFIM Hamiltonian matrix.\"\"\"\n        key = (L, h, J)\n        if key in memoized_hamiltonians:\n            return memoized_hamiltonians[key]\n\n        H = np.zeros((2**L, 2**L), dtype=float)\n        # Interaction term\n        for i in range(L - 1):\n            op_list = [identity] * L\n            op_list[i] = sigma_z\n            op_list[i+1] = sigma_z\n            term = functools.reduce(np.kron, op_list)\n            H -= J * term\n        # Field term\n        for i in range(L):\n            op_list = [identity] * L\n            op_list[i] = sigma_x\n            term = functools.reduce(np.kron, op_list)\n            H -= h * term\n        \n        memoized_hamiltonians[key] = H\n        return H\n\n    def get_r2(x, y, coeffs):\n        \"\"\"Calculates the coefficient of determination (R-squared).\"\"\"\n        y_pred = np.polyval(coeffs, x)\n        ss_res = np.sum((y - y_pred)**2)\n        ss_tot = np.sum((y - np.mean(y))**2)\n        if ss_tot  1e-15: # Avoid division by zero if all y values are the same\n            return 1.0 if ss_res  1e-15 else 0.0\n        return 1 - ss_res / ss_tot\n\n    def process_case(L, h, J, chi_values):\n        \"\"\"Processes a single test case.\"\"\"\n        # 1. Exact Diagonalization\n        H = get_hamiltonian(L, h, J)\n        _, eigvecs = eigh(H)\n        psi_0 = eigvecs[:, 0]\n\n        w_data = []\n        E_data = []\n\n        # 2. Loop over bond dimensions\n        for chi in chi_values:\n            current_psi = np.copy(psi_0)\n            total_discarded_weight = 0.0\n            \n            # 3. Left-to-right sweep for truncation\n            for i in range(1, L):\n                dim_left = 2**i\n                dim_right = 2**(L-i)\n                M = current_psi.reshape((dim_left, dim_right))\n\n                U, s, Vh = np.linalg.svd(M, full_matrices=False)\n                \n                num_sv_to_keep = min(chi, len(s))\n                \n                discarded_s_sq = s[num_sv_to_keep:]**2\n                total_discarded_weight += np.sum(discarded_s_sq)\n\n                s_trunc = s[:num_sv_to_keep]\n                M_trunc = U[:, :num_sv_to_keep] @ np.diag(s_trunc) @ Vh[:num_sv_to_keep, :]\n                \n                current_psi = M_trunc.flatten()\n            \n            # 4. Calculate energy of the final truncated state\n            norm = np.linalg.norm(current_psi)\n            if norm  1e-15:\n                continue # Skip if state collapses to zero\n            psi_tilde = current_psi / norm\n            energy = (psi_tilde.T @ H @ psi_tilde)\n\n            w_data.append(total_discarded_weight)\n            E_data.append(energy)\n        \n        w_arr = np.array(w_data)\n        E_arr = np.array(E_data)\n        \n        # 5. Fitting and Extrapolation\n        # Handle cases with insufficient distinct data points for quadratic fit\n        if len(np.unique(w_arr))  3:\n             coeffs_lin = np.polyfit(w_arr, E_arr, 1)\n             E0_lin = coeffs_lin[1]\n             return 1, E0_lin\n\n        coeffs_lin = np.polyfit(w_arr, E_arr, 1)\n        E0_lin = coeffs_lin[1]\n        r2_lin = get_r2(w_arr, E_arr, coeffs_lin)\n\n        coeffs_quad = np.polyfit(w_arr, E_arr, 2)\n        c2, c1, c0 = coeffs_quad\n        E0_quad = c0\n        r2_quad = get_r2(w_arr, E_arr, coeffs_quad)\n\n        # 6. Model Selection\n        w_mean = np.mean(w_arr)\n        rho = (abs(c2) * w_mean) / (abs(c1) + epsilon)\n        delta_r2 = r2_quad - r2_lin\n\n        if rho > tau and delta_r2 > eta:\n            fit_type = 2\n            extrapolated_E = E0_quad\n        else:\n            fit_type = 1\n            extrapolated_E = E0_lin\n            \n        return fit_type, extrapolated_E\n\n    final_results = []\n    for case in test_cases:\n        fit_type, E0 = process_case(case['L'], case['h'], case['J'], case['chi_values'])\n        final_results.append(str(fit_type))\n        final_results.append(f\"{E0:.6f}\")\n\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "2980989"}]}