{"hands_on_practices": [{"introduction": "本练习将带领您从第一性原理出发，将阻塞的定义转化为一个可执行的计算任务。通过构建相容性矩阵和赫斯矩阵，您将学习如何通过线性稳定性分析来判断一个粒子系统是否处于阻塞状态。这项实践将使您对阻塞的核心力学判据——即除了整体平移和旋转之外，系统必须能抵抗任何微小形变——有一个具体而深入的理解 [@problem_id:2997429]。", "problem": "考虑一个在 $d$ 维空间中由 $N$ 个质点组成的有限集合，其位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，其中 $\\mathbf{r}_i \\in \\mathbb{R}^d$。假设粒子通过指定的配对 $(i,j)$ 之间进行无摩擦的中心力接触相互作用，每个接触都像一个刚度为 $k$ 的线性弹簧，仅抵抗沿连接两粒子直线方向上的距离变化。假设位移 $\\{\\mathbf{u}_i\\}_{i=1}^N$ 偏离参考位置的幅度很小，并且温度为零。该问题的基本基础是线性弹簧的胡克定律和牛顿第二定律的结合，这在小位移极限下导致了线性弹性。\n\n对于粒子 $i$ 和 $j$ 之间的一个接触，在参考构型中定义从 $i$ 到 $j$ 方向的单位法向量 $\\mathbf{n}_{ij}$。在位移作用下，此接触的线性化伸长量是相对位移在 $\\mathbf{n}_{ij}$ 上的投影。总二次能量可以写为由 $k$ 加权的伸长量平方和。从粒子位移到接触伸长量的线性映射由相容性矩阵表示，二次能量由 Hessian 矩阵（也称为动力学矩阵）表示。线性体系中的力学稳定性由 Hessian 矩阵的半正定性以及是否存在非平凡的软模决定。\n\n定义以下量：\n- 自由度 (DOF): $dN$。\n- 接触数: $M$。\n- 自由边界条件下的刚体零模数: $d(d+1)/2$，包括 $d$ 个全局平移和 $d(d-1)/2$ 个全局转动。\n- 自应力状态 (SSS): 接触力平衡的独立解，每个粒子上的合力为零，且不改变伸长量。\n\n一个构型被认为是阻塞的，如果在线性化体系中：\n- Hessian 矩阵是半正定的。\n- Hessian 矩阵的零度（零特征值的数量）等于刚体模式数 $d(d+1)/2$，这意味着除了全局平移和转动之外没有软模。\n- 接触数满足麦克斯韦判据 $M \\ge dN - d(d+1)/2$。\n\n你的任务是根据中心力、无摩擦接触的第一性原理构建相容性矩阵和 Hessian 矩阵，并评估每个给定的构型是否根据上述定义是阻塞的。使用以下测试用例构型，位置采用无量纲单位，且 $k = 1$：\n\n测试用例 1 (二维三角形, 等静定):\n- $d = 2$, $N = 3$。\n- 位置: $\\mathbf{r}_1 = (0,0)$，$\\mathbf{r}_2 = (1,0)$，$\\mathbf{r}_3 = (0.3,0.8)$。\n- 接触: $(1,2)$，$(2,3)$，$(3,1)$。\n- $M = 3$。\n\n测试用例 2 (二维正方形, 欠约束):\n- $d = 2$, $N = 4$。\n- 位置: $\\mathbf{r}_1 = (0,0)$，$\\mathbf{r}_2 = (1,0)$，$\\mathbf{r}_3 = (1,1)$，$\\mathbf{r}_4 = (0,1)$。\n- 接触: $(1,2)$，$(2,3)$，$(3,4)$，$(4,1)$。\n- $M = 4$。\n\n测试用例 3 (带一个对角线的二维正方形, 等静定):\n- $d = 2$, $N = 4$。\n- 位置: $\\mathbf{r}_1 = (0,0)$，$\\mathbf{r}_2 = (1,0)$，$\\mathbf{r}_3 = (1,1)$，$\\mathbf{r}_4 = (0,1)$。\n- 接触: $(1,2)$，$(2,3)$，$(3,4)$，$(4,1)$，$(1,3)$。\n- $M = 5$。\n\n测试用例 4 (三维四面体, 等静定):\n- $d = 3$, $N = 4$。\n- 位置: $\\mathbf{r}_1 = (0,0,0)$，$\\mathbf{r}_2 = (1,0,0)$，$\\mathbf{r}_3 = (0.2,0.9,0)$，$\\mathbf{r}_4 = (0.3,0.2,0.8)$。\n- 接触: $(1,2)$，$(1,3)$，$(1,4)$，$(2,3)$，$(2,4)$，$(3,4)$。\n- $M = 6$。\n\n测试用例 5 (三维, 欠约束网络):\n- $d = 3$, $N = 5$。\n- 位置: $\\mathbf{r}_1 = (0,0,0)$，$\\mathbf{r}_2 = (1,0,0)$，$\\mathbf{r}_3 = (2,0,0)$，$\\mathbf{r}_4 = (0.5,0.8,0)$，$\\mathbf{r}_5 = (1.5,0.8,0.1)$。\n- 接触: $(1,2)$，$(2,3)$，$(4,5)$，$(2,4)$，$(3,5)$。\n- $M = 5$。\n\n实现要求：\n- 构建大小为 $M \\times dN$ 的相容性矩阵 $A$ 如下：对于每个接触 $(i,j)$，计算从 $\\mathbf{r}_i$ 到 $\\mathbf{r}_j$ 的单位法向量 $\\mathbf{n}_{ij}$；$A$ 中对应的行在粒子 $i$ 的块中具有条目 $+\\mathbf{n}_{ij}$，在粒子 $j$ 的块中具有条目 $-\\mathbf{n}_{ij}$，其他地方为零。\n- 构建 Hessian 矩阵 $H$ 为 $H = A^\\top A$ (取弹簧刚度 $k = 1$）。\n- 计算 $H$ 的特征值，并统计有多少在数值容差范围内为零。选择一个与最大特征值成比例的容差，以保持无量纲和鲁棒性。\n- 通过检查上述三个条件，为每个测试用例决定其阻塞状态（布尔值）。\n\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果，例如 `[True,False,True,True,False]`，其中每个结果是对应测试用例的布尔值 `True` 或 `False`。", "solution": "该问题要求评估几个颗粒系统的力学稳定性，特别是确定它们是否处于“阻塞”状态。在此背景下，阻塞态是力学刚性的一种特定形式，体现在对小微扰的线性响应层面。解决方案涉及从线性弹性的第一性原理构建适当的数学对象，然后根据提供的阻塞标准对它们进行测试。\n\n物理模型包含 $d$ 维欧几里得空间中的 $N$ 个质点，它们通过 $M$ 个中心力弹簧相互作用。系统的总势能 $E$ 是存储在每个弹簧中的能量之和。对于刚度为 $k$ 的线性弹簧，其能量是其伸长或压缩量的二次函数。设 $\\delta l_c$ 为对应于接触 $c$ 的弹簧长度变化量。总能量为：\n$$E = \\frac{k}{2} \\sum_{c=1}^{M} (\\delta l_c)^2$$\n我们考虑每个粒子 $i$ 从其参考位置 $\\mathbf{r}_i$ 发生的小位移 $\\{\\mathbf{u}_i\\}_{i=1}^N$。新位置为 $\\mathbf{r}'_i = \\mathbf{r}_i + \\mathbf{u}_i$。对于粒子 $i$ 和 $j$ 之间的一个接触，长度变化量 $\\delta l_{ij}$ 是 $\\lvert \\mathbf{r}'_j - \\mathbf{r}'_i \\rvert - \\lvert \\mathbf{r}_j - \\mathbf{r}_i \\rvert$。在小位移极限下，这可以被线性化。令 $\\mathbf{u}_{ij} = \\mathbf{u}_j - \\mathbf{u}_i$ 及单位向量 $\\mathbf{n}_{ij} = (\\mathbf{r}_j - \\mathbf{r}_i) / \\lvert \\mathbf{r}_j - \\mathbf{r}_i \\rvert$ 沿接触方向，线性化伸长量为：\n$$\\delta l_{ij} \\approx \\mathbf{u}_{ij} \\cdot \\mathbf{n}_{ij} = (\\mathbf{u}_j - \\mathbf{u}_i) \\cdot \\mathbf{n}_{ij}$$\n这种关系可以用矩阵形式表示。设 $\\mathbf{U}$ 是一个 $dN \\times 1$ 的列向量，它连接了所有粒子的位移向量：$\\mathbf{U} = (\\mathbf{u}_1^T, \\mathbf{u}_2^T, \\dots, \\mathbf{u}_N^T)^T$。设 $\\mathbf{e}$ 是一个 $M \\times 1$ 的列向量，包含所有接触的伸长量 $\\delta l_c$。它们之间的线性关系是 $\\mathbf{e} = A \\mathbf{U}$，其中 $A$ 是 $M \\times dN$ 的相容性矩阵。根据问题指定的约定，对于一个接触 $(i, j)$，$A$ 的对应行在粒子 $i$ 的 $d$ 维块中包含向量分量条目 $+\\mathbf{n}_{ij}$，在粒子 $j$ 的块中包含 $-\\mathbf{n}_{ij}$。这个约定产生的伸长向量的符号与标准推导相反，但由于能量取决于伸长量的平方，这一选择对稳定性分析是无关紧要的。\n\n利用这种矩阵表示法，总势能为：\n$$E = \\frac{k}{2} \\mathbf{e}^T \\mathbf{e} = \\frac{k}{2} (A \\mathbf{U})^T (A \\mathbf{U}) = \\frac{1}{2} \\mathbf{U}^T (k A^T A) \\mathbf{U}$$\nHessian 矩阵 $H$ 表示能量的二次型，由 $E = \\frac{1}{2} \\mathbf{U}^T H \\mathbf{U}$ 定义。因此，$H = k A^T A$。由于问题指定 $k=1$，Hessian 矩阵就是 $H = A^T A$。\n\n一个构型被定义为阻塞的，如果它满足三个条件：\n1.  Hessian 矩阵 $H$ 是半正定的。根据构造，$H = A^T A$ 对于任何实矩阵 $A$ 总是半正定的，因为对于任何向量 $\\mathbf{U}$，$\\mathbf{U}^T H \\mathbfU = \\mathbf{U}^T A^T A \\mathbf{U} = (A \\mathbf{U})^T (A \\mathbf{U}) = \\lVert A \\mathbf{U} \\rVert^2 \\ge 0$。因此，这个条件是自动满足的。\n2.  接触数 $M$ 必须满足麦克斯韦稳定性判据，$M \\geq dN - N_{rb}$。这里，$N_{rb} = d(d+1)/2$是在自由边界条件下不拉伸任何接触的刚体运动模式（平移和转动）的数量。这是一个比较自由度（$dN$）和约束数（$M$）的计数论证。\n3.  结构必须是力学刚性的，除了全局刚体运动。这意味着没有“软模”（内部机制或非平凡的零能形变）。Hessian 矩阵 $H$ 的零空间对应于所有零能位移模式。对于一个刚性结构，这些模式必须完全由刚体运动张成。因此，$H$ 的零度（其零空间的维度，或其零特征值的数量）必须恰好等于 $N_{rb}$。\n\n确定一个构型是否阻塞的算法流程如下：\n首先，对于给定的测试用例，包括参数 $d$、$N$、粒子位置 $\\{\\mathbf{r}_i\\}$ 和接触，我们计算接触数 $M$ 和所需的刚体模式数 $N_{rb} = d(d+1)/2$。\n其次，我们检查麦克斯韦判据：$M \\geq dN - N_{rb}$。如果不满足，系统就不是阻塞的。\n第三，如果满足麦克斯韦判据，我们继续根据规则构建 $M \\times dN$ 的相容性矩阵 $A$。\n第四，我们计算 $dN \\times dN$ 的 Hessian 矩阵 $H=A^T A$。\n第五，我们计算 $H$ 的特征值。由于 $H$ 是一个实对称半正定矩阵，其所有特征值都是实数且非负。\n第六，我们使用一个小的数值容差（例如 $10^{-9}$）来计算为零的特征值数量，以考虑浮点误差。设这个计数为 $N_{zero}$。\n最后，我们检查零度条件：$N_{zero} = N_{rb}$。一个构型是阻塞的，当且仅当麦克斯韦判据和这个零度条件都得到满足。\n\n这个程序被系统地应用于所提供的每个测试用例。", "answer": "```python\nimport numpy as np\n\ndef check_jamming(d, N, positions, contacts):\n    \"\"\"\n    Checks if a configuration of particles is jammed based on linear stability analysis.\n\n    Args:\n        d (int): The spatial dimension.\n        N (int): The number of particles.\n        positions (np.ndarray): An N x d array of particle positions.\n        contacts (list of tuple): A list of (i, j) tuples representing contacts,\n                                  using 1-based indexing.\n\n    Returns:\n        bool: True if the configuration is jammed, False otherwise.\n    \"\"\"\n    M = len(contacts)\n    dN = d * N\n\n    # Condition 1: Maxwell criterion\n    num_rigid_body_modes = d * (d + 1) // 2\n    maxwell_count = dN - num_rigid_body_modes\n    is_maxwell = (M >= maxwell_count)\n\n    # If Maxwell criterion is not met, the system cannot be jammed.\n    if not is_maxwell:\n        return False\n\n    # Construct the compatibility matrix A (size M x dN)\n    A = np.zeros((M, dN))\n\n    for k, (i_raw, j_raw) in enumerate(contacts):\n        # Convert from 1-based to 0-based indexing\n        i, j = i_raw - 1, j_raw - 1\n\n        r_i = positions[i]\n        r_j = positions[j]\n\n        r_ij = r_j - r_i\n        dist = np.linalg.norm(r_ij)\n\n        # Handle the unlikely case of overlapping particles\n        if dist < 1e-12:\n            return False\n\n        n_ij = r_ij / dist\n        \n        # Populate the k-th row of A according to the problem statement:\n        # +n_ij in block for particle i, -n_ij in block for particle j\n        A[k, i * d : (i + 1) * d] = n_ij\n        A[k, j * d : (j + 1) * d] = -n_ij\n\n    # Construct the Hessian matrix H (size dN x dN)\n    # H = A^T A, with spring constant k=1\n    H = A.T @ A\n\n    # Compute eigenvalues of H. eigvalsh is efficient for real symmetric matrices.\n    eigenvalues = np.linalg.eigvalsh(H)\n\n    # Condition 2: Nullity of Hessian\n    # Count the number of zero eigenvalues within a numerical tolerance.\n    # The eigenvalues are non-negative, so we check for eigenvalues < tol.\n    tolerance = 1e-9\n    num_zero_modes = np.sum(eigenvalues < tolerance)\n    \n    is_rigid = (num_zero_modes == num_rigid_body_modes)\n\n    # A configuration is jammed if both Maxwell and rigidity conditions are met.\n    # The positive-semidefinite condition is met by construction.\n    is_jammed = is_maxwell and is_rigid\n\n    return is_jammed\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (two-dimensional triangle, isostatic)\n        {\n            \"d\": 2, \"N\": 3,\n            \"positions\": np.array([[0.0, 0.0], [1.0, 0.0], [0.3, 0.8]]),\n            \"contacts\": [(1, 2), (2, 3), (3, 1)]\n        },\n        # Test case 2 (two-dimensional square, underconstrained)\n        {\n            \"d\": 2, \"N\": 4,\n            \"positions\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"contacts\": [(1, 2), (2, 3), (3, 4), (4, 1)]\n        },\n        # Test case 3 (two-dimensional square with one diagonal, isostatic)\n        {\n            \"d\": 2, \"N\": 4,\n            \"positions\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"contacts\": [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]\n        },\n        # Test case 4 (three-dimensional tetrahedron, isostatic)\n        {\n            \"d\": 3, \"N\": 4,\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.2, 0.9, 0.0], [0.3, 0.2, 0.8]]),\n            \"contacts\": [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n        },\n        # Test case 5 (three-dimensional, underconstrained network)\n        {\n            \"d\": 3, \"N\": 5,\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [2.0, 0.0, 0.0], [0.5, 0.8, 0.0], [1.5, 0.8, 0.1]]),\n            \"contacts\": [(1, 2), (2, 3), (4, 5), (2, 4), (3, 5)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = check_jamming(\n            d=case[\"d\"],\n            N=case[\"N\"],\n            positions=case[\"positions\"],\n            contacts=case[\"contacts\"]\n        )\n        results.append(result)\n\n    # Print results in the specified format: [True,False,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2997429"}, {"introduction": "堵塞转变点附近的系统具有独特的振动特性，这一概念是理解其物理性质的关键。本练习将引导您探索阻塞状态的标志性特征：边缘稳定性 (marginal stability) 和软模 (soft modes)。您将通过编程为一个无序网络构建动力学矩阵，并分析其本征值谱，从而亲手验证当系统处于等静态 (isostatic) 极限时，软模与约束数量之间的深刻联系 [@problem_id:2997433]。", "problem": "考虑一个由 $d$ 维空间中的 $N$ 个点状粒子组成的网络，其单位质量 $m=1$，粒子间沿着一个无向接触图存在单位刚度 $k=1$ 的中心谐波接触。令 $\\mathbf{r}_i \\in \\mathbb{R}^d$ 表示粒子 $i$ 的平衡位置，$\\mathbf{u}_i \\in \\mathbb{R}^d$ 表示其微小位移。对于一个接触 $(i,j)$，定义接触单位向量 $\\hat{\\mathbf{e}}_{ij} = (\\mathbf{r}_i - \\mathbf{r}_j)/\\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。在谐波近似下，势能为\n$$\nE = \\frac{k}{2}\\sum_{(i,j)} \\left[\\hat{\\mathbf{e}}_{ij}\\cdot(\\mathbf{u}_i - \\mathbf{u}_j)\\right]^2.\n$$\n该二次型能量定义了一个大小为 $dN \\times dN$ 的 Hessian 矩阵 $H$，使得简正模方程为 $H\\mathbf{v} = \\omega^2 \\mathbf{v}$，其中 $\\omega$ 是角频率，$\\mathbf{v}$ 是模式向量。$H$ 的特征值 $\\lambda$ 满足 $\\lambda = \\omega^2$，其单位为 $k/m$；当 $k=1$ 且 $m=1$ 时，$\\omega$ 的单位为 $\\text{s}^{-1}$。\n\n软模式被定义为与在数值容差范围内可视为零的特征值 $\\lambda$ 相关联的特征向量。在中心力构成的自由浮动网络中，存在 $d(d+1)/2$ 个平凡刚体模式（均匀平移和旋转），它们总是产生零特征值。冗余自由度模式 (Floppy modes) 是指在这些平凡零模式之外的额外零模式。Maxwell 计数给出了冗余自由度模式的预测数量：\n$$\nF_{\\text{Maxwell}} = dN - N_c - \\frac{d(d+1)}{2},\n$$\n其中 $N_c$ 是接触数。当 $F_{\\text{Maxwell}} = 0$ 时，网络是等静定的；这类处于刚性阈值上的网络是临界稳定的：移除任何单个接触都会产生至少一个冗余自由度模式。在无摩擦非晶材料的阻塞相变中，临界稳定性与平均配位数在 $N\\to\\infty$ 时趋近于 $z = 2d$ 相关，其中\n$$\nz = \\frac{2N_c}{N}.\n$$\n\n您的任务是仅从上述物理定义和基本线性代数出发，实现以下内容：\n\n1. 通过为每个接触 $(i,j)$ 在对应于粒子 $i$ 和 $j$ 的块上组装 $d\\times d$ 的秩一投影算子 $k\\,\\hat{\\mathbf{e}}_{ij}\\hat{\\mathbf{e}}_{ij}^\\top$ 来构建 $H$，其标准形式反映了位移中的二次型能量：\n   - 将 $k\\,\\hat{\\mathbf{e}}_{ij}\\hat{\\mathbf{e}}_{ij}^\\top$ 添加到 $(i,i)$ 块。\n   - 将 $k\\,\\hat{\\mathbf{e}}_{ij}\\hat{\\mathbf{e}}_{ij}^\\top$ 添加到 $(j,j)$ 块。\n   - 将 $-k\\,\\hat{\\mathbf{e}}_{ij}\\hat{\\mathbf{e}}_{ij}^\\top$ 添加到 $(i,j)$ 块。\n   - 将 $-k\\,\\hat{\\mathbf{e}}_{ij}\\hat{\\mathbf{e}}_{ij}^\\top$ 添加到 $(j,i)$ 块。\n2. 计算 $H$ 的所有特征值，并使用数值阈值 $\\varepsilon = 10^{-9}$（单位为 $k/m$）来识别软模式。将在 $d(d+1)/2$ 个平凡刚体零模式之外，满足 $\\lambda \\le \\varepsilon$ 的特征值数量定义为整数 $n_{\\text{soft}}$。\n3. 将最小非零角频率 $\\omega_{\\min}$ 定义为 $\\sqrt{\\lambda_{\\min}}$，其中 $\\lambda_{\\min}$ 是严格大于 $\\varepsilon$ 的最小特征值。以 $\\text{s}^{-1}$ 为单位表示 $\\omega_{\\min}$。\n4. 定义一个布尔值 $b_{\\text{marginal}}$，其当且仅当以下条件成立时为真：\n   - Maxwell 计数得出 $F_{\\text{Maxwell}} = 0$，并且\n   - 移除一个接触（具体来说，是下文指定的确定性构建顺序中的最后一个接触）后，软模式的数量增加至少一个（即，在平凡刚体模式之外，至少有一个额外的特征值降到 $\\varepsilon$ 以下）。\n\n网络构建协议（确定性且物理上合理的）：\n- 在 $d=2$ 的维度下工作。\n- 使用指定的伪随机种子，在单位正方形 $[0,1]^2$ 中均匀采样 $N$ 个点，生成 $\\mathbf{r}_i$，以确保可复现性。\n- 通过依次将每个新粒子 $t$ ($t=1,\\dots,N-1$) 连接到欧几里得距离上最近的已添加粒子 $j\\in\\{0,\\dots,t-1\\}$，来构建一个连通生成树。\n- 计算所有尚未在边集合中的无序对 $(i,j)$（其中 $0 \\le i < j < N$）的两两距离，按距离递增排序这些对，并按此顺序添加接触，直到达到目标接触数 $N_c$。确定性构建顺序是：首先是按添加顺序排列的生成树边，然后是按距离排序后添加的边。上面提到的“最后一个接触”是这个最终有序列表中的最后一个接触。\n\n测试套件：\n- 案例 1 (亚稳态): $N=30$, $d=2$, 种子 $=123$, 目标 $N_c = dN - \\frac{d(d+1)}{2} - 4 = 53$。\n- 案例 2 (等静定/临界候选): $N=30$, $d=2$, 种子 $=456$, 目标 $N_c = dN - \\frac{d(d+1)}{2} = 57$。\n- 案例 3 (超静定): $N=30$, $d=2$, 种子 $=789$, 目标 $N_c = 70$。\n\n您的程序必须为每个案例输出列表 $[n_{\\text{soft}}, \\omega_{\\min}, b_{\\text{marginal}}]$，并将三个案例的结果汇总到单行输出中，形式为用方括号括起来的逗号分隔列表，不含空格，格式如下 `[[n_soft_1,omega_min_1,b_marginal_1],[n_soft_2,omega_min_2,b_marginal_2],[n_soft_3,omega_min_3,b_marginal_3]]`。\n角频率必须以 $\\text{s}^{-1}$ 为单位报告。所有输出都必须使用所提供的构建协议和定义进行计算，其中 $\\varepsilon = 10^{-9}$。\n\n您的程序应生成单行输出，包含用方括号括起来的逗号分隔列表形式的结果（例如：`[[1,0.123,True],[0,0.456,False],[2,0.078,False]]`）。不提供任何输入；所有参数均已在上面定义。", "solution": "目标是将阻塞阈值处的软模式和临界稳定性与谐波网络的第一性原理联系起来。我们从中心力接触的能量二次型开始。对于小位移，胡克定律意味着只有沿着接触的相对运动的纵向分量对能量有贡献；横向运动在一阶上不改变键长。对于沿着键的单位向量为 $\\hat{\\mathbf{e}}_{ij}$ 的单个接触 $(i,j)$，能量贡献是\n$$\nE_{ij} = \\frac{k}{2}\\left[\\hat{\\mathbf{e}}_{ij}\\cdot(\\mathbf{u}_i - \\mathbf{u}_j)\\right]^2,\n$$\n这是位移差的一个秩一二次型。对所有接触求和可得\n$$\nE = \\frac{1}{2}\\sum_{(i,j)} \\left(\\mathbf{u}^\\top P_{ij}\\mathbf{u}\\right),\\quad P_{ij} = k\\,\\mathbf{B}_{ij},\\quad \\mathbf{B}_{ij} \\text{ assembled from } \\hat{\\mathbf{e}}_{ij}\\hat{\\mathbf{e}}_{ij}^\\top,\n$$\n其中 $\\mathbf{u}$ 将所有粒子位移堆叠成 $\\mathbb{R}^{dN}$ 中的一个向量。Hessian 矩阵 $H$ 是所有 $P_{ij}$ 算子之和。对于一个接触 $(i,j)$，对各块矩阵的贡献是：\n- $(i,i)$ 块: $k\\,\\hat{\\mathbf{e}}_{ij}\\hat{\\mathbf{e}}_{ij}^\\top$,\n- $(j,j)$ 块: $k\\,\\hat{\\mathbf{e}}_{ij}\\hat{\\mathbf{e}}_{ij}^\\top$,\n- $(i,j)$ 块: $-k\\,\\hat{\\mathbf{e}}_{ij}\\hat{\\mathbf{e}}_{ij}^\\top$,\n- $(j,i)$ 块: $-k\\,\\hat{\\mathbf{e}}_{ij}\\hat{\\mathbf{e}}_{ij}^\\top$.\n\n这个 $H$ 是对称半正定的。在单位质量 $m=1$ 的情况下，简正模满足\n$$\nH\\mathbf{v} = \\omega^2 \\mathbf{v},\n$$\n其特征值为 $\\lambda = \\omega^2$，单位为 $k/m$。在自由浮动的中心力网络中，有 $d(d+1)/2$ 个由刚体运动（平移和旋转）产生的平凡零模式。任何等于或低于小阈值 $\\varepsilon$ 的额外特征值代表了平凡刚体运动之外的冗余自由度软模式。我们选择数值容差 $\\varepsilon = 10^{-9}$，因此我们定义\n$$\nn_{\\text{soft}} = \\max\\left(0,\\#\\{\\lambda \\mid \\lambda \\le \\varepsilon\\} - \\frac{d(d+1)}{2}\\right).\n$$\n我们通过选择严格大于 $\\varepsilon$ 的最小特征值（记为 $\\lambda_{\\min}$）来定义最小非零角频率，并计算\n$$\n\\omega_{\\min} = \\sqrt{\\lambda_{\\min}}.\n$$\n由于 $k=1$ 且 $m=1$，我们以 $\\text{s}^{-1}$ 为单位表示 $\\omega_{\\min}$。\n\n临界稳定性与等静定性相关。Maxwell 计数预测了冗余自由度模式的数量：\n$$\nF_{\\text{Maxwell}} = dN - N_c - \\frac{d(d+1)}{2}.\n$$\n等静定条件是 $F_{\\text{Maxwell}} = 0$。一个临界稳定网络是最小刚性的：移除任何单个接触都会产生一个冗余自由度模式，即至少出现一个额外的软模式。因此，我们定义布尔值\n$$\nb_{\\text{marginal}} = \\left(F_{\\text{Maxwell}} = 0\\right)\\ \\wedge\\ \\left(n_{\\text{soft}}^{\\text{(after removing one contact)}} \\ge n_{\\text{soft}} + 1\\right),\n$$\n其中我们移除确定性构建顺序中的最后一个接触以确保可复现性。\n\n为了构建没有特殊简并性的物理上合理的接触图，我们使用一个确定性协议：\n1. 使用固定种子在 $[0,1]^2$ 中均匀采样 $N$ 个位置 $\\{\\mathbf{r}_i\\}$。这控制了随机性并保证了可复现性。\n2. 构建一个连通生成树：对于从 $1$ 到 $N-1$ 的每个粒子 $t$，根据欧几里得距离将其连接到最近的已添加粒子 $j \\in \\{0,\\dots,t-1\\}$。这确保网络以 $N-1$ 条边连通。\n3. 计算所有尚未连接的对的距离，按升序排序，然后添加边，直到达到目标接触数 $N_c$。得到的构建顺序是生成树边的序列，后跟按距离排序添加的边。\n4. 对于每个接触，根据秩一投影算子规则组装 $H$，其中 $k=1$。然后使用对称特征求解器计算所有特征值。\n5. 通过计算小于等于 $\\varepsilon$ 的特征值数量来识别软模式，减去 $d(d+1)/2$ 个平凡刚体模式，从而计算 $n_{\\text{soft}}$。将 $\\omega_{\\min}$ 计算为大于 $\\varepsilon$ 的最小特征值的平方根。\n6. 对于 $b_{\\text{marginal}}$，计算 $F_{\\text{Maxwell}}$。如果 $F_{\\text{Maxwell}}=0$，则移除构建顺序中的最后一个接触，重建 $H$，重新计算软模式数量，并检查其是否至少增加 $1$。\n\n测试套件探究了不同的体系：\n- 亚稳态 ($N_c$ 低于等静定值)：我们预期 $F_{\\text{Maxwell}} > 0$，有额外的软模式，且非临界。\n- 等静定 (临界稳定性的候选者)：$F_{\\text{Maxwell}} = 0$，初始没有额外的冗余自由度模式，移除一个接触应产生至少一个额外的软模式，表明其为临界稳定。\n- 超静定 ($N_c$ 高于等静定值)：冗余的约束使得除了平凡零模式外，谱严格为正，移除一个接触通常不会产生冗余自由度模式；非临界。\n\n参数和单位：\n- $d=2$，$k=1$ (牛顿/米)，$m=1$ (千克)，因此 $\\omega$ 以 $\\text{s}^{-1}$ 为单位报告。\n- 特征值的数值容差 $\\varepsilon = 10^{-9}$，单位为 $k/m$。\n\n最终输出规格：\n对于每个案例，生成 $[n_{\\text{soft}}, \\omega_{\\min}, b_{\\text{marginal}}]$ 并将三个案例的结果汇总到一行，不含空格，格式如下 `[[n_soft_1,omega_min_1,b_marginal_1],[n_soft_2,omega_min_2,b_marginal_2],[n_soft_3,omega_min_3,b_marginal_3]]`。\n此过程从谐波中心力网络的第一性原理出发，体现了软模式和临界稳定性的概念，并允许通过 Hessian 矩阵的特征谱和 Maxwell 计数进行算法验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_positions(N, seed):\n    rng = np.random.RandomState(seed)\n    # Uniform positions in [0,1]^2\n    pos = rng.rand(N, 2)\n    return pos\n\ndef build_spanning_tree_edges(positions):\n    N = positions.shape[0]\n    edges = []\n    # Connect each node t to the nearest previous node\n    for t in range(1, N):\n        prev_indices = np.arange(0, t)\n        diffs = positions[prev_indices] - positions[t]\n        dists = np.linalg.norm(diffs, axis=1)\n        j = prev_indices[np.argmin(dists)]\n        edges.append((t, j))\n    return edges\n\ndef build_full_edge_set(positions, target_nc):\n    N = positions.shape[0]\n    # Start with a connected spanning tree\n    edges = build_spanning_tree_edges(positions)\n    existing = set()\n    for (i, j) in edges:\n        if i > j:\n            i, j = j, i\n        existing.add((i, j))\n    current_nc = len(edges)\n    if current_nc > target_nc:\n        # Should not happen with construction, but guard\n        return edges[:target_nc]\n    # Generate all remaining pairs and sort by distance\n    pairs = []\n    for i in range(N):\n        for j in range(i+1, N):\n            if (i, j) not in existing:\n                d = np.linalg.norm(positions[i] - positions[j])\n                pairs.append((d, i, j))\n    pairs.sort(key=lambda x: x[0])  # sort by ascending distance\n    # Add edges until reaching target_nc\n    k = 0\n    while current_nc < target_nc and k < len(pairs):\n        _, i, j = pairs[k]\n        edges.append((i, j))\n        existing.add((i, j))\n        current_nc += 1\n        k += 1\n    return edges\n\ndef assemble_hessian(positions, edges, k=1.0):\n    N = positions.shape[0]\n    d = positions.shape[1]\n    size = N * d\n    H = np.zeros((size, size), dtype=float)\n    for (i, j) in edges:\n        ri = positions[i]\n        rj = positions[j]\n        vec = ri - rj\n        norm = np.linalg.norm(vec)\n        # Guard against zero-length due to numerical issues\n        if norm <= 1e-15:\n            continue\n        e = vec / norm  # unit vector\n        # Rank-one projector\n        P = k * np.outer(e, e)  # d x d\n        # Indices in Hessian\n        ii = slice(i*d, (i+1)*d)\n        jj = slice(j*d, (j+1)*d)\n        # Assemble blocks\n        H[ii, ii] += P\n        H[jj, jj] += P\n        H[ii, jj] -= P\n        H[jj, ii] -= P\n    return H\n\ndef analyze_network(positions, edges, epsilon=1e-9, k=1.0, m=1.0):\n    d = positions.shape[1]\n    N = positions.shape[0]\n    H = assemble_hessian(positions, edges, k=k)\n    # Symmetric eigen-decomposition\n    w = np.linalg.eigvalsh(H)\n    # Correct small negative numerical artifacts\n    w = np.where(w < 0, w, w)  # keep as is; eigvalsh should be fine\n    # Count zeros within tolerance\n    trivial_zeros = d * (d + 1) // 2  # rigid-body modes\n    count_zero = int(np.sum(w <= epsilon))\n    n_soft = max(0, count_zero - trivial_zeros)\n    # Minimal nonzero eigenvalue\n    positive = w[w > epsilon]\n    if positive.size > 0:\n        lambda_min = float(np.min(positive))\n        omega_min = float(np.sqrt(lambda_min / (m)))  # since lambda = k/m * ... and k=1\n    else:\n        omega_min = 0.0\n    # Marginal stability: Maxwell F = dN - Nc - d(d+1)/2\n    Nc = len(edges)\n    F_maxwell = d * N - Nc - d * (d + 1) // 2\n    is_isostatic = (F_maxwell == 0)\n    # Remove the last edge, recompute soft modes\n    if len(edges) > 0:\n        edges_removed = edges[:-1]\n    else:\n        edges_removed = edges\n    H2 = assemble_hessian(positions, edges_removed, k=k)\n    w2 = np.linalg.eigvalsh(H2)\n    count_zero2 = int(np.sum(w2 <= epsilon))\n    n_soft2 = max(0, count_zero2 - trivial_zeros)\n    b_marginal = bool(is_isostatic and (n_soft2 >= n_soft + 1))\n    return n_soft, omega_min, b_marginal\n\ndef format_result(res):\n    n_soft, omega_min, b_marginal = res\n    # Ensure no spaces in the nested list formatting\n    return f\"[{n_soft},{omega_min},{b_marginal}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, d, seed, target_Nc)\n    test_cases = [\n        (30, 2, 123, 53),  # Hypostatic\n        (30, 2, 456, 57),  # Isostatic/marginal candidate\n        (30, 2, 789, 70),  # Hyperstatic\n    ]\n\n    epsilon = 1e-9\n    results = []\n    for (N, d, seed, target_Nc) in test_cases:\n        positions = generate_positions(N, seed)\n        edges = build_full_edge_set(positions, target_Nc)\n        res = analyze_network(positions, edges, epsilon=epsilon, k=1.0, m=1.0)\n        results.append(res)\n\n    # Final print statement in the exact required format: nested lists, no spaces.\n    print(f\"[{','.join(format_result(r) for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2997433"}]}