{"hands_on_practices": [{"introduction": "阻挫（Frustration）是自旋玻璃物理的基石，它源于无法同时被满足的竞争性相互作用。第一个练习提供了一种直接、定量的方式来理解这一概念。通过计算一个格子上最小回路（plaquette）发生阻挫的概率，您将对相互作用强度 $J_{ij}$ 中的无序如何导致自旋玻璃特有的复杂能量景观有一个基本的认识。", "problem": "考虑定义在正则格子上的爱德华兹-安德森伊辛自旋玻璃，其哈密顿量为 $H=-\\sum_{\\langle i j\\rangle} J_{i j} S_{i} S_{j}$，其中伊辛自旋 $S_{i}\\in\\{-1,+1\\}$，耦合 $J_{i j}$ 为淬火最近邻耦合。一个回路（例如，一个基本格框）被称为是阻挫的，当且仅当沿该回路的耦合 $J_{i j}$ 的乘积为负。设耦合 $J_{i j}$ 独立同分布，服从双峰定律 $J_{i j}\\in\\{+J,-J\\}$，其中 $\\mathbb{P}(J_{i j}=-J)=p$ 且 $\\mathbb{P}(J_{i j}=+J)=1-p$，并且 $J0$。\n\n- 仅使用上述基本定义，计算当 $p=1/2$ 时，方格子上一个基本方格框是阻挫的概率。\n- 然后，将您的结果推广至任意 z-正则图（每个顶点的配位数为 z）上长度为 $\\ell$ 的简单回路，将阻挫概率表示为 $\\ell$ 和 $p$ 的闭合形式函数。\n\n您的最终答案应为一个仅依赖于 $\\ell$ 和 $p$ 的单一闭合形式表达式，并且当 $\\ell=4$ 和 $p=1/2$ 时，该表达式可退化为您求得的方格框的值。无需进行数值计算，也不涉及单位。最终答案中请勿包含任何不等式。", "solution": "该问题要求计算晶格中一个回路发生阻挫的概率。一个回路被定义为阻挫，如果沿其键的淬火随机耦合 $J_{ij}$ 的乘积为负。设该回路是一个长度为 $\\ell$ 的简单圈，其耦合为 $J_1, J_2, \\dots, J_\\ell$。阻挫的条件是：\n$$ \\prod_{i=1}^{\\ell} J_i  0 $$\n耦合 $J_i$ 是从双峰分布中抽取的独立同分布随机变量：$J_i = +J$ 的概率为 $1-p$，$J_i = -J$ 的概率为 $p$，其中 $J0$。\n\n乘积 $\\prod_{i=1}^{\\ell} J_i$ 的符号由负耦合（即值为 $-J$ 的耦合）的数量决定。设回路中负耦合的数量为 $k$。乘积可以写作：\n$$ \\prod_{i=1}^{\\ell} J_i = (-1)^k J^{\\ell} $$\n由于 $J0$，$J^{\\ell}$ 总是正的。因此，阻挫条件 $\\prod_{i=1}^{\\ell} J_i  0$ 等价于 $(-1)^k = -1$，这意味着负耦合的数量 $k$ 必须是奇数。\n\n我们需要计算 $k$ 为奇数的概率。由于 $\\ell$ 个耦合是独立的，负耦合的数量 $k$ 服从二项分布，其参数为 $n=\\ell$（试验次数，即回路中的键数）和 $p$（成功概率，即耦合为负的概率）。其概率质量函数由下式给出：\n$$ \\mathbb{P}(k) = \\binom{\\ell}{k} p^k (1-p)^{\\ell-k} $$\n阻挫概率 $P_{\\text{frust}}$ 是 $k$ 所有可能奇数值的概率之和：\n$$ P_{\\text{frust}}(\\ell, p) = \\sum_{j=0}^{\\lfloor (\\ell-1)/2 \\rfloor} \\mathbb{P}(k=2j+1) = \\sum_{j=0}^{\\lfloor (\\ell-1)/2 \\rfloor} \\binom{\\ell}{2j+1} p^{2j+1} (1-p)^{\\ell-(2j+1)} $$\n为了找到此和的闭合形式表达式，我们使用一种涉及二项式定理的标准技巧。考虑 $(a+b)^\\ell$ 和 $(a-b)^\\ell$ 的展开式：\n$$ (a+b)^\\ell = \\sum_{k=0}^{\\ell} \\binom{\\ell}{k} b^k a^{\\ell-k} $$\n$$ (a-b)^\\ell = \\sum_{k=0}^{\\ell} \\binom{\\ell}{k} (-b)^k a^{\\ell-k} = \\sum_{k=0}^{\\ell} (-1)^k \\binom{\\ell}{k} b^k a^{\\ell-k} $$\n用第一个方程减去第二个方程：\n$$ (a+b)^\\ell - (a-b)^\\ell = \\sum_{k=0}^{\\ell} \\binom{\\ell}{k}b^k a^{\\ell-k}(1 - (-1)^k) $$\n项 $(1 - (-1)^k)$ 在 $k$ 为奇数时等于 $2$，在 $k$ 为偶数时等于 $0$。因此，该和只包含 $k$ 为奇数的项：\n$$ (a+b)^\\ell - (a-b)^\\ell = 2 \\sum_{k \\text{ is odd}} \\binom{\\ell}{k} b^k a^{\\ell-k} $$\n现在，我们令 $a = 1-p$ 和 $b=p$。右侧的和正好就是阻挫概率 $P_{\\text{frust}}(\\ell, p)$：\n$$ ((1-p)+p)^\\ell - ((1-p)-p)^\\ell = 2 \\sum_{k \\text{ is odd}} \\binom{\\ell}{k} p^k (1-p)^{\\ell-k} = 2 P_{\\text{frust}}(\\ell, p) $$\n化简左侧：\n$$ 1^\\ell - (1-2p)^\\ell = 2 P_{\\text{frust}}(\\ell, p) $$\n$$ 1 - (1-2p)^\\ell = 2 P_{\\text{frust}}(\\ell, p) $$\n解出 $P_{\\text{frust}}(\\ell, p)$，我们得到长度为 $\\ell$ 的回路的阻挫概率的通用闭合形式表达式：\n$$ P_{\\text{frust}}(\\ell, p) = \\frac{1}{2} \\left(1 - (1 - 2p)^{\\ell}\\right) $$\n该表达式仅依赖于回路长度 $\\ell$ 和负键的概率 $p$。只要回路是良定义的，图的配位数 $z$ 就无关紧要。\n\n问题的第一个部分要求计算方格子上基本方格框在 $p=1/2$ 时的特殊情况。一个方格框是长度为 $\\ell=4$ 的回路。将 $\\ell=4$ 和 $p=1/2$ 代入我们的通用公式：\n$$ P_{\\text{frust}}(4, 1/2) = \\frac{1}{2} \\left(1 - \\left(1 - 2\\left(\\frac{1}{2}\\right)\\right)^{4}\\right) $$\n$$ P_{\\text{frust}}(4, 1/2) = \\frac{1}{2} \\left(1 - (1 - 1)^{4}\\right) = \\frac{1}{2} \\left(1 - 0^{4}\\right) = \\frac{1}{2} (1 - 0) = \\frac{1}{2} $$\n要求的最终答案是推广此结果的单一闭合形式表达式。", "answer": "$$\n\\boxed{\\frac{1}{2} \\left(1 - (1 - 2p)^{\\ell}\\right)}\n$$", "id": "3016871"}, {"introduction": "Edwards-Anderson (EA) 模型拥有一种关键但微妙的局域 $\\mathbb{Z}_2$ 规范对称性，这对它的物理描述具有深远的影响。本实践将引导您证明这一对称性，并用它来确定哪些物理量是“规范不变”的，从而具有物理意义。理解这种对称性对于领会为何传统的序参量会失效，以及为何 EA 序参量要被构造成其特有形式至关重要。", "problem": "考虑一个具有 $N$ 个格点和 $M$ 条边的有限无向图上的 Edwards-Anderson 自旋玻璃模型（Edwards-Anderson模型），其中的自旋为伊辛自旋 $S_i \\in \\{-1,+1\\}$。其哈密顿量为\n$$\nH[\\{S\\}\\,|\\,\\{J\\}] \\equiv - \\sum_{\\langle i j \\rangle} J_{i j}\\, S_i S_j,\n$$\n其中，耦合 $J_{i j} = J_{j i}$ 是淬火随机变量，独立地从一个在 $J_{i j} \\to - J_{i j}$ 变换下对称且支撑集为有限区间的键分布中抽取。定义一个依赖于格点的变换，其中 $\\epsilon_i \\in \\{-1,+1\\}$ 的作用如下：\n$$\nS_i \\to S_i' \\equiv \\epsilon_i S_i, \\qquad J_{i j} \\to J_{i j}' \\equiv \\epsilon_i \\epsilon_j J_{i j}.\n$$\n从哈密顿量、逆温度 $\\beta$ 下的玻尔兹曼权重 $\\exp(-\\beta H)$ 和配分函数\n$$\nZ[\\{J\\}] \\equiv \\sum_{\\{S\\}} \\exp\\!\\big(-\\beta H[\\{S\\}\\,|\\,\\{J\\}]\\big),\n$$\n的基本定义出发，完成以下任务：\n\n- 明确证明，对于 $\\{\\epsilon_i\\}$ 的任意选择，变换后的哈密顿量 $H[\\{S'\\}\\,|\\,\\{J'\\}]$ 等于 $H[\\{S\\}\\,|\\,\\{J\\}]$，并由此通过适当的求和变量代换推导出 $Z[\\{J'\\}] = Z[\\{J\\}]$。\n\n- 仅使用上述变换规则，不引入任何未经证明的捷径，确定下列可观测量如何变换：磁化强度 $m \\equiv \\frac{1}{N} \\sum_{i=1}^{N} S_i$，键能量密度 $e_b \\equiv -\\frac{1}{M} \\sum_{\\langle i j \\rangle} J_{i j} S_i S_j$，以及双副本重叠（Edwards-Anderson 序参量候选项）$q \\equiv \\frac{1}{N} \\sum_{i=1}^{N} S_i^{(1)} S_i^{(2)}$，其中上标表示在相同淬火无序 $\\{J\\}$ 下演化的两个独立热力学副本。\n\n- 对任意可以写成单个单项式\n$$\n\\mathcal{O}(\\{S\\},\\{J\\}) = \\prod_{i=1}^{N} S_i^{a_i} \\prod_{\\langle i j \\rangle} J_{i j}^{b_{i j}},\n$$\n的可观测量，推导其规范不变性的普适选择定则，其中 $a_i$ 和 $b_{i j}$ 为非负整数。该定则需用每个格点上指数的宇称约束来表述。\n\n你的推导必须从上述定义出发，并清晰地论证每一步。作为最终答案，请给出规范不变的 Edwards-Anderson 序参量的显式解析表达式，用 $N$ 和 2 个副本的自旋变量来表示。不需要进行数值计算，也不涉及单位。", "solution": "本问题旨在分析 Edwards-Anderson 自旋玻璃模型的局域规范对称性。分析将分三部分进行：证明哈密顿量和配分函数的不变性，确定特定物理可观测量的变换性质，以及推导单项式可观测量规范不变性的普适选择定则。\n\n### 第一部分：哈密顿量和配分函数的不变性\n\nEdwards-Anderson 模型的哈密顿量由下式给出：\n$$\nH[\\{S\\}\\,|\\,\\{J\\}] \\equiv - \\sum_{\\langle i j \\rangle} J_{i j}\\, S_i S_j\n$$\n其中 $\\{S\\}$ 表示伊辛自旋 $S_i \\in \\{-1,+1\\}$ 的一个构型，而 $\\{J\\}$ 是淬火随机耦合 $J_{ij}$ 的一个实现。求和遍及图的所有边 $\\langle ij \\rangle$。\n\n局域规范变换由一组依赖于格点的变量 $\\epsilon_i \\in \\{-1,+1\\}$ 定义，其对自旋和耦合的作用如下：\n$$\nS_i \\to S_i' \\equiv \\epsilon_i S_i\n$$\n$$\nJ_{i j} \\to J_{i j}' \\equiv \\epsilon_i \\epsilon_j J_{i j}\n$$\n\n首先，我们证明哈密顿量的解析表达式在此变换下是不变的。我们将变换后的变量 $S_i'$ 和 $J_{ij}'$ 代入哈密顿量的定义表达式中：\n$$\nH[\\{S'\\}\\,|\\,\\{J'\\}] = - \\sum_{\\langle i j \\rangle} J_{i j}'\\, S_i' S_j'\n$$\n代入变换规则，我们得到：\n$$\nH[\\{S'\\}\\,|\\,\\{J'\\}] = - \\sum_{\\langle i j \\rangle} (\\epsilon_i \\epsilon_j J_{i j})\\, (\\epsilon_i S_i) (\\epsilon_j S_j)\n$$\n重新整理各项，并对任意格点 k 使用性质 $\\epsilon_k^2 = 1$：\n$$\nH[\\{S'\\}\\,|\\,\\{J'\\}] = - \\sum_{\\langle i j \\rangle} (\\epsilon_i^2 \\epsilon_j^2) J_{i j}\\, S_i S_j = - \\sum_{\\langle i j \\rangle} (1 \\cdot 1) J_{i j}\\, S_i S_j = - \\sum_{\\langle i j \\rangle} J_{i j}\\, S_i S_j\n$$\n这与原始的哈密顿量表达式 $H[\\{S\\}\\,|\\,\\{J\\}]$ 完全相同。因此，我们证明了 $H[\\{S'\\}\\,|\\,\\{J'\\}] = H[\\{S\\}\\,|\\,\\{J\\}]$。\n\n接下来，我们推导配分函数 $Z[\\{J\\}]$ 的不变性。对于一个耦合为 $\\{J'\\}$ 的系统，其配分函数定义为：\n$$\nZ[\\{J'\\}] \\equiv \\sum_{\\{S\\}} \\exp\\!\\big(-\\beta H[\\{S\\}\\,|\\,\\{J'\\}]\\big)\n$$\n求和遍及所有 $2^N$ 个自旋构型 $\\{S\\}$。指数中的哈密顿量使用自旋变量 $\\{S\\}$ 和变换后的耦合 $\\{J'\\}$ 进行计算：\n$$\nH[\\{S\\}\\,|\\,\\{J'\\}] = - \\sum_{\\langle i j \\rangle} J'_{i j}\\, S_i S_j = - \\sum_{\\langle i j \\rangle} (\\epsilon_i \\epsilon_j J_{i j})\\, S_i S_j\n$$\n将此式代入 $Z[\\{J'\\}]$ 的表达式中：\n$$\nZ[\\{J'\\}] = \\sum_{\\{S\\}} \\exp\\left( \\beta \\sum_{\\langle i j \\rangle} (\\epsilon_i \\epsilon_j J_{i j})\\, S_i S_j \\right)\n$$\n现在，我们在对自旋构型的求和中进行变量代换。我们定义一组新的自旋变量 $\\{S'\\}$，使得 $S_i' = \\epsilon_i S_i$。由于 $\\epsilon_i^2 = 1$，逆变换为 $S_i = \\epsilon_i S_i'$。这个变换是所有自旋构型集合到其自身的一一映射。因此，对所有 $\\{S\\}$ 求和等价于对所有 $\\{S'\\}$ 求和。\n将 $S_i = \\epsilon_i S_i'$ 代入 $Z[\\{J'\\}]$ 的表达式中，得到：\n$$\nZ[\\{J'\\}] = \\sum_{\\{S'\\}} \\exp\\left( \\beta \\sum_{\\langle i j \\rangle} (\\epsilon_i \\epsilon_j J_{i j})\\, (\\epsilon_i S_i') (\\epsilon_j S_j') \\right)\n$$\n化简指数内的项：\n$$\n(\\epsilon_i \\epsilon_j J_{i j})\\, (\\epsilon_i S_i') (\\epsilon_j S_j') = (\\epsilon_i^2 \\epsilon_j^2) J_{i j} S_i' S_j' = J_{i j} S_i' S_j'\n$$\n$Z[\\{J'\\}]$ 的表达式变为：\n$$\nZ[\\{J'\\}] = \\sum_{\\{S'\\}} \\exp\\left( \\beta \\sum_{\\langle i j \\rangle} J_{i j} S_i' S_j' \\right) = \\sum_{\\{S'\\}} \\exp\\left( -\\beta H[\\{S'\\}\\,|\\,\\{J\\}] \\right)\n$$\n由于 $\\{S'\\}$ 是求和哑变量，此表达式正是配分函数 $Z[\\{J\\}]$ 的定义。因此，我们证明了 $Z[\\{J'\\}] = Z[\\{J\\}]$。\n\n### 第二部分：可观测量的变换\n\n我们通过将规范变换应用于给定可观测量的定义表达式，来确定它们的变换方式。\n\n1.  **磁化强度, $m$**：\n    磁化强度为 $m \\equiv \\frac{1}{N} \\sum_{i=1}^{N} S_i$。变换后的可观测量 $m'$ 是将 $S_i$ 替换为 $S_i' = \\epsilon_i S_i$ 得到的：\n    $$\n    m' = \\frac{1}{N} \\sum_{i=1}^{N} S_i' = \\frac{1}{N} \\sum_{i=1}^{N} \\epsilon_i S_i\n    $$\n    通常情况下，$m' \\neq m$。磁化强度不是规范不变的。\n\n2.  **键能量密度, $e_b$**：\n    键能量密度为 $e_b \\equiv -\\frac{1}{M} \\sum_{\\langle i j \\rangle} J_{i j} S_i S_j$。变换后的可观测量 $e_b'$ 为：\n    $$\n    e_b' = -\\frac{1}{M} \\sum_{\\langle i j \\rangle} J_{i j}' S_i' S_j'\n    $$\n    从第一部分我们已经证明，哈密顿量的表达式是不变的，即 $\\sum_{\\langle i j \\rangle} J_{i j}' S_i' S_j' = \\sum_{\\langle i j \\rangle} J_{i j} S_i S_j$。因此：\n    $$\n    e_b' = -\\frac{1}{M} \\sum_{\\langle i j \\rangle} J_{i j} S_i S_j = e_b\n    $$\n    键能量密度是规范不变的。\n\n3.  **双副本重叠, $q$**：\n    双副本重叠为 $q \\equiv \\frac{1}{N} \\sum_{i=1}^{N} S_i^{(1)} S_i^{(2)}$。规范变换适用于给定格点 $i$ 上的所有物理变量。因此，两个副本的自旋变量以相同方式变换：$S_i^{(1)} \\to S_i^{(1)'} \\equiv \\epsilon_i S_i^{(1)}$ 和 $S_i^{(2)} \\to S_i^{(2)'} \\equiv \\epsilon_i S_i^{(2)}$。变换后的可观测量 $q'$ 为：\n    $$\n    q' = \\frac{1}{N} \\sum_{i=1}^{N} S_i^{(1)'} S_i^{(2)'} = \\frac{1}{N} \\sum_{i=1}^{N} (\\epsilon_i S_i^{(1)}) (\\epsilon_i S_i^{(2)})\n    $$\n    使用 $\\epsilon_i^2=1$：\n    $$\n    q' = \\frac{1}{N} \\sum_{i=1}^{N} \\epsilon_i^2 S_i^{(1)} S_i^{(2)} = \\frac{1}{N} \\sum_{i=1}^{N} S_i^{(1)} S_i^{(2)} = q\n    $$\n    双副本重叠是规范不变的。\n\n### 第三部分：规范不变性的普适选择定则\n\n我们考虑一个形式如下的普适单项式可观测量：\n$$\n\\mathcal{O}(\\{S\\},\\{J\\}) = \\prod_{i=1}^{N} S_i^{a_i} \\prod_{\\langle i j \\rangle} J_{i j}^{b_{i j}}\n$$\n其中 $a_i$ 和 $b_{ij}$ 是非负整数。我们寻求 $\\mathcal{O}$ 具有规范不变性（即 $\\mathcal{O}' = \\mathcal{O}$）的条件。变换后的可观测量 $\\mathcal{O}'$ 为：\n$$\n\\mathcal{O}' = \\prod_{i=1}^{N} (S_i')^{a_i} \\prod_{\\langle i j \\rangle} (J_{i j}')^{b_{i j}} = \\prod_{i=1}^{N} (\\epsilon_i S_i)^{a_i} \\prod_{\\langle i j \\rangle} (\\epsilon_i \\epsilon_j J_{i j})^{b_{i j}}\n$$\n分离出包含 $\\epsilon_k$ 的因子：\n$$\n\\mathcal{O}' = \\left( \\prod_{i=1}^{N} S_i^{a_i} \\prod_{\\langle i j \\rangle} J_{i j}^{b_{i j}} \\right) \\left( \\prod_{i=1}^{N} \\epsilon_i^{a_i} \\prod_{\\langle i j \\rangle} (\\epsilon_i \\epsilon_j)^{b_{i j}} \\right) = \\mathcal{O} \\left( \\prod_{i=1}^{N} \\epsilon_i^{a_i} \\prod_{\\langle i j \\rangle} \\epsilon_i^{b_{i j}} \\epsilon_j^{b_{i j}} \\right)\n$$\n为使 $\\mathcal{O}'=\\mathcal{O}$，对于 $\\{\\epsilon_i\\}$ 的任意选择，$\\epsilon$ 因子的乘积都必须等于 1。我们可以通过汇总每个格点 $k$ 的指数来重写这个乘积：\n$$\n\\prod_{k=1}^{N} \\epsilon_k^{P_k}\n$$\n对于给定的格点 $k$，其总指数 $P_k$ 由来自自旋因子的项 $a_k$ 以及来自每个与格点 $k$ 相连的边的贡献组成。对于每条边 $\\langle k j \\rangle$，因子 $J_{kj}^{b_{kj}}$ 对 $\\epsilon_k$ 的指数贡献了 $b_{kj}$。因此，总指数是：\n$$\nP_k = a_k + \\sum_{j \\in \\mathcal{N}(k)} b_{kj}\n$$\n其中 $\\mathcal{N}(k)$ 是格点 $k$ 的邻居集合。为了使乘积 $\\prod_k \\epsilon_k^{P_k}$ 对于 $\\{\\epsilon_k\\}$ 的任意选择都为 1，每个指数 $P_k$ 都必须是偶数。这可以通过选择 $\\epsilon_k = -1$ 以及对所有 $j \\neq k$ 选择 $\\epsilon_j = 1$ 来看出，这种选择可以分离出条件 $(-1)^{P_k} = 1$。\n\n因此，单项式可观测量具有规范不变性的普适选择定则是：对于图中的每个格点 $k$，该格点上自旋的指数与所有与该格点相连的键的指数之和必须是一个偶数：\n$$\na_k + \\sum_{j \\in \\mathcal{N}(k)} b_{kj} \\equiv 0 \\pmod 2 \\quad \\forall k \\in \\{1, \\dots, N\\}\n$$\n双副本重叠 $q$ 是形如 $S_i^{(1)}S_i^{(2)}$ 的单项式之和。这可以看作是一个更普适的多副本可观测量的一个特例。对于像 $S_k^{(1)}S_k^{(2)}$ 这样的项，格点 $k$ 处的总自旋指数为 $1+1=2$，所有其他指数均为 0。格点 $k$ 处的条件是 $2+0=2$（偶数），而任何其他格点 $i\\neq k$ 处的条件是 $0+0=0$（偶数）。由于 $q$ 的求和中的每一项都是独立规范不变的，它们的和 $q$ 也是规范不变的，正如在第二部分中所证明的那样。这种结构正是在具有这种局域对称性的系统中，一个良定义的序参量所需要的。\n\n规范不变的 Edwards-Anderson 序参量的显式解析表达式是双副本重叠 $q$，我们已经证明了其不变性。", "answer": "$$\n\\boxed{\\frac{1}{N} \\sum_{i=1}^{N} S_i^{(1)} S_i^{(2)}}\n$$", "id": "3016817"}, {"introduction": "虽然寻找一般自旋玻璃的基态是一个 NP-难问题，但在某些特定情况下，可以通过将其优雅地映射到计算机科学中的其他问题来精确求解。这个高级实践将挑战您实现一个经典算法，该算法将具有 $\\pm J$ 耦合的二维 EA 模型映射到一个最小权完美匹配（minimum-weight perfect matching）问题。这个练习巧妙地将阻挫的抽象概念与一种强大的、具体的计算技术联系起来，以求解精确的基态能量。", "problem": "考虑一个在具有自由边界条件的矩形方格晶格上的二维Edwards-Anderson自旋玻璃模型，其具有双峰耦合。设晶格顶点上有$L \\times M$个伊辛自旋，其变量为$S_i \\in \\{-1,+1\\}$，边上的最近邻耦合为$J_{ij} \\in \\{-1,+1\\}$。Edwards-Anderson哈密顿量为$H = -\\sum_{\\langle i j\\rangle} J_{ij} S_i S_j$，其中求和遍历所有最近邻对。在没有磁场且边界自由的情况下，基态可以通过映射到一个从对偶晶格派生出的平面图上的最小权完美匹配（MWPM）问题来精确计算。本题的目标是利用阻挫和畴壁的定义，从第一性原理出发构建该计算过程，并解释在对偶平面图上的MWPM如何得出精确的基态能量。\n\n您必须编写一个完整的程序，对于下面指定的每个测试实例，构建相应的平面-对偶图，建立与阻挫小方格对应的需求顶点集，分配边权重，并求解相应的最小权完美匹配以获得精确的基态能量。该程序必须是自包含的，且不得读取任何输入。它必须生成包含所有测试实例结果的单行输出。\n\n推导和方法的基本依据：\n- 使用Edwards-Anderson哈密顿量定义$H = -\\sum_{\\langle i j\\rangle} J_{ij} S_i S_j$。\n- 使用阻挫小方格的定义：对于每个基本方格面（小方格），计算四个关联耦合的乘积；当且仅当该乘积等于$-1$时，该小方格是阻挫的。\n- 在对偶晶格上使用奇偶性论证：未满足的边集合形成一个子图，该子图在阻挫小方格处的度数为奇数，在其他地方的度数为偶数，这可以表示为连接成对的阻挫小方格（当阻挫小方格数量为奇数时，可能还包括外平面）的路径的并集。\n- 利用以下事实：在$J_{ij} \\in \\{-1,+1\\}$的双峰情况下，对偶图上每条穿过的最近邻边的边权重等于$1$；因此，对偶网格上的距离是小方格中心之间的曼哈顿距离，而从小方格到外平面的距离等于到边界的最小对偶步数加$1$。\n\n您必须通过算法实现以下步骤：\n1. 对于每个测试实例，通过计算每个小方格的四个耦合的乘积来计算阻挫小方格的集合。用$N_{\\text{bonds}}$表示键的总数，用$N_{\\text{frust}}$表示阻挫小方格的数量。\n2. 如果$N_{\\text{frust}}$是奇数，则包含一个外平面需求顶点，以确保需求顶点的总数为偶数。\n3. 在需求顶点上构建完全加权图，其中两个内部小方格之间的权重是它们在小方格网格上坐标之间的曼哈顿距离，而一个内部小方格与外平面之间的权重是到任意边界的最小步数加$1$。\n4. 在此完全图上求解最小权完美匹配，以获得最小总路径长度$W$。您的实现必须是精确的；使用适合小图的方法，例如基于子集的动态规划，通过配对顶点来最小化总权重。\n5. 以$J$为单位（$J=1$）计算精确的基态能量，结果为整数。您的程序必须输出以$J$为单位的整数能量，不带任何其他单位。能量必须根据上述构造以科学上一致的方式计算。\n\n测试套件：\n对于每种情况，水平耦合由一个形状为$L \\times (M-1)$的矩阵$H$给出，其中$H_{r,c}$是位于$(r,c)$和$(r,c+1)$的自旋之间的耦合；垂直耦合由一个形状为$(L-1) \\times M$的矩阵$V$给出，其中$V_{r,c}$是位于$(r,c)$和$(r+1,c)$的自旋之间的耦合。所有条目均在$\\{-1,+1\\}$中。\n\n- 情况1（小的，含一个阻挫格）：\n  $L = 2$, $M = 2$,\n  $H = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$,\n  $V = \\begin{bmatrix} 1  -1 \\end{bmatrix}$。\n\n- 情况2（奇数个阻挫格，需要与外平面配对）：\n  $L = 3$, $M = 3$,\n  $H = \\begin{bmatrix} 1  -1 \\\\ -1  1 \\\\ 1  1 \\end{bmatrix}$,\n  $V = \\begin{bmatrix} 1  1  -1 \\\\ -1  1  1 \\end{bmatrix}$。\n\n- 情况3（具有多个阻挫格的较大网格）：\n  $L = 4$, $M = 4$,\n  $H = \\begin{bmatrix} 1  -1  1 \\\\ 1  1  -1 \\\\ -1  1  1 \\\\ 1  -1  -1 \\end{bmatrix}$,\n  $V = \\begin{bmatrix} 1  -1  1  1 \\\\ 1  1  -1  -1 \\\\ -1  1  1  1 \\end{bmatrix}$。\n\n- 情况4（具有混合耦合的矩形网格）：\n  $L = 3$, $M = 4$,\n  $H = \\begin{bmatrix} 1  1  -1 \\\\ -1  1  1 \\\\ 1  -1  1 \\end{bmatrix}$,\n  $V = \\begin{bmatrix} 1  -1  1  -1 \\\\ 1  1  -1  1 \\end{bmatrix}$。\n\n答案规范：\n- 对于每种情况，您的程序必须输出以$J$为单位（$J=1$）的精确基态能量，结果为整数。\n- 将四种情况的结果汇总到单行输出中，形式为用方括号括起来的逗号分隔列表，不含空格，例如：$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$。\n- 此问题不涉及角度或百分比。\n\n您的程序应生成一行包含方括号括起的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4]\"）。", "solution": "该问题要求计算一个在具有自由边界条件和双峰耦合的矩形晶格上的二维Edwards-Anderson自旋玻璃模型的基态能量。该解决方法基于一个成熟的理论，即将此特定问题映射到一个相关图上的最小权完美匹配（MWPM）问题。\n\n系统由位于方格晶格顶点上的$L \\times M$个伊辛自旋组成，由变量$S_i \\in \\{-1, +1\\}$描述。相互作用仅限于最近邻，并由耦合$J_{ij} \\in \\{-1, +1\\}$定义。系统的哈密顿量由下式给出\n$$H = -\\sum_{\\langle i j\\rangle} J_{ij} S_i S_j$$\n其中求和遍历所有最近邻对$\\langle i j\\rangle$。基态对应于使该哈密顿量最小化的自旋构型$\\{S_i\\}$。\n\n为了找到基态，我们可以分析键能$\\sigma_{ij} = J_{ij}S_iS_j$。哈密顿量可以重写为$H = -\\sum \\sigma_{ij}$。如果$\\sigma_{ij} = +1$，则键$\\langle ij \\rangle$是“满足的”；如果$\\sigma_{ij} = -1$，则是“未满足的”。设$N_{\\text{bonds}}$为总键数，$N_{\\text{sat}}$为满足的键数，$N_{\\text{unsat}}$为未满足的键数。能量可以表示为：\n$$E = -\\left( N_{\\text{sat}} \\cdot (+1) + N_{\\text{unsat}} \\cdot (-1) \\right) = N_{\\text{unsat}} - N_{\\text{sat}}$$\n由于$N_{\\text{sat}} = N_{\\text{bonds}} - N_{\\text{unsat}}$，能量变为：\n$$E = N_{\\text{unsat}} - (N_{\\text{bonds}} - N_{\\text{unsat}}) = 2N_{\\text{unsat}} - N_{\\text{bonds}}$$\n因此，最小化能量$E$等同于最小化未满足键的数量$N_{\\text{unsat}}$。\n\n关键的见解在于将未满足键的位置与“阻挫”的概念联系起来。一个小方格（晶格的一个基本方格）由其四个角的自旋和连接它们的四个键定义。小方格$p$的阻挫由其周围耦合的乘积确定：\n$$P_p = \\prod_{\\langle ij \\rangle \\in \\partial p} J_{ij}$$\n如果$P_p = -1$，则小方格$p$是阻挫的。对于任何给定的自旋构型$\\{S_i\\}$，一个小方格周围键能的乘积为$\\prod_{\\langle ij \\rangle \\in \\partial p} \\sigma_{ij} = \\prod (J_{ij}S_iS_j) = (\\prod J_{ij})(\\prod S_iS_j)$。由于每个自旋顶点在小方格边界中是两个键的一部分，因此每个自旋变量在第二个乘积中出现两次，所以$\\prod S_iS_j = \\prod S_k^2 = 1$。因此，$\\prod \\sigma_{ij} = P_p$。\n如果一个小方格是非阻挫的（$P_p = +1$），它必须被偶数个未满足的键包围。如果是阻挫的（$P_p = -1$），它必须被奇数个未满足的键包围。\n\n该性质使我们能够在对偶晶格上将问题可视化。对偶晶格的顶点对应于原始晶格中小方格的中心。原始晶格中未满足的键集合在对偶晶格上形成一系列路径和闭环。阻挫小方格是这些路径的端点，因为它们是对偶晶格上唯一可以具有奇数度（奇数个关联的未满足键）的顶点。\n\n为了最小化$N_{\\text{unsat}}$，我们必须找到这些路径的一种构型，使其总长度最小，并将所有阻挫小方格成对连接。这正是一个最小权完美匹配问题。匹配图的顶点是“需求顶点”，由阻挫小方格组成。由于匹配是顶点配对，需求顶点的数量必须是偶数。如果阻挫小方格的数量$N_{\\text{frust}}$是奇数，则意味着其中一条路径必须在系统边界终止。这通过向需求顶点集中添加一个“外平面”顶点来建模。\n\n算法步骤如下：\n1.  **识别阻挫小方格**：对于一个给定的$L \\times M$晶格，其水平耦合为$H$，垂直耦合为$V$，我们考虑$(L-1) \\times (M-1)$的小方格网格。对于小方格网格坐标为$(r, c)$（其中$r \\in [0, L-2]$，$c \\in [0, M-2]$）的每个小方格，我们计算其周围四个键耦合的乘积。如果乘积为$-1$，则该小方格是阻挫的。我们记录所有阻挫小方格的坐标。\n\n2.  **构建需求顶点**：我们形成一个需求顶点列表。该列表包含所有阻挫小方格的坐标。如果阻挫小方格的数量$N_{\\text{frust}}$是奇数，我们向列表中添加一个虚拟的“外平面”顶点，以确保总数为偶数。\n\n3.  **建立成本矩阵**：我们在需求顶点集上构建一个完全加权图。两个顶点之间的边权重是连接它们所需的一条未满足键路径的成本。对于双峰耦合（$J_{ij}=\\pm 1$），此成本就是对偶网格上的路径长度。\n    *   两个内部小方格$(r_1, c_1)$和$(r_2, c_2)$之间的权重是它们的曼哈顿距离：$w = |r_1 - r_2| + |c_1 - c_2|$。\n    *   一个内部小方格$(r, c)$与外平面顶点之间的权重是到小方格网格边界的最短曼哈顿距离加一。对于一个位于$(L-1) \\times (M-1)$小方格网格上坐标为$(r, c)$的小方格，此权重为$w = \\min(r, (L-2)-r, c, (M-2)-c) + 1$。\n\n4.  **求解MWPM**：我们求解该完全图上的最小权完美匹配问题。对于少量顶点，这可以通过使用基于顶点子集的动态规划算法精确完成。设成本矩阵为$C$。递归函数$f(\\text{mask})$计算由位掩码表示的顶点子集的最小匹配成本。如果$i$是掩码中索引最小的顶点，则递归关系为：\n    $$f(\\text{mask}) = \\min_{j  i, j \\in \\text{mask}} \\left\\{ C_{ij} + f(\\text{mask} \\setminus \\{i, j\\}) \\right\\}$$\n    匹配的总最小权重$W$是包含所有顶点的初始调用的结果。\n\n5.  **计算基态能量**：从MWPM得到的最小权重$W$是未满足键的最小可能数量$N_{\\text{unsat}}^{\\min}$。然后使用前面导出的公式计算基态能量$E_0$：\n    $$E_0 = 2W - N_{\\text{bonds}}$$\n    其中，$N_{\\text{bonds}} = L(M-1) + (L-1)M$是晶格上的总键数。\n\n此过程应用于每个测试案例，以找到其精确的基态能量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\nimport sys\n\n# Set a higher recursion limit for the MWPM solver, although not strictly\n# necessary for the small problem sizes given.\nsys.setrecursionlimit(2000)\n\ndef solve():\n    \"\"\"\n    Computes the exact ground-state energy for several 2D Edwards-Anderson\n    spin glass instances using a mapping to a minimum-weight perfect matching problem.\n    \"\"\"\n\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 2, \"M\": 2,\n            \"H\": np.array([[1], [1]]),\n            \"V\": np.array([[1, -1]])\n        },\n        # Case 2\n        {\n            \"L\": 3, \"M\": 3,\n            \"H\": np.array([[1, -1], [-1, 1], [1, 1]]),\n            \"V\": np.array([[1, 1, -1], [-1, 1, 1]])\n        },\n        # Case 3\n        {\n            \"L\": 4, \"M\": 4,\n            \"H\": np.array([[1, -1, 1], [1, 1, -1], [-1, 1, 1], [1, -1, -1]]),\n            \"V\": np.array([[1, -1, 1, 1], [1, 1, -1, -1], [-1, 1, 1, 1]])\n        },\n        # Case 4\n        {\n            \"L\": 3, \"M\": 4,\n            \"H\": np.array([[1, 1, -1], [-1, 1, 1], [1, -1, 1]]),\n            \"V\": np.array([[1, -1, 1, -1], [1, 1, -1, 1]])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L, M = case[\"L\"], case[\"M\"]\n        H_couplings, V_couplings = case[\"H\"], case[\"V\"]\n\n        # The number of plaquettes is (L-1) x (M-1)\n        num_plaq_rows, num_plaq_cols = L - 1, M - 1\n\n        frustrated_plaquettes = []\n        if num_plaq_rows > 0 and num_plaq_cols > 0:\n            for r in range(num_plaq_rows):\n                for c in range(num_plaq_cols):\n                    # Bonds for plaquette (r,c) are H(r,c), H(r+1,c), V(r,c), V(r,c+1)\n                    p_prod = (H_couplings[r, c] * H_couplings[r + 1, c] *\n                              V_couplings[r, c] * V_couplings[r, c + 1])\n                    if p_prod == -1:\n                        frustrated_plaquettes.append((r, c))\n\n        demand_nodes = list(frustrated_plaquettes)\n        num_frustrated = len(demand_nodes)\n        \n        # If the number of frustrated plaquettes is odd, add the outer face as a demand node.\n        # We represent the outer face with a special coordinate, e.g., None.\n        outer_face_node = None\n        has_outer_face_node = False\n        if num_frustrated % 2 != 0:\n            demand_nodes.append(outer_face_node)\n            has_outer_face_node = True\n\n        num_demand_nodes = len(demand_nodes)\n        if num_demand_nodes == 0:\n            min_matching_weight = 0\n        else:\n            cost_matrix = np.zeros((num_demand_nodes, num_demand_nodes), dtype=int)\n            for i in range(num_demand_nodes):\n                for j in range(i + 1, num_demand_nodes):\n                    node1 = demand_nodes[i]\n                    node2 = demand_nodes[j]\n                    \n                    is_node1_outer = (node1 is outer_face_node)\n                    is_node2_outer = (node2 is outer_face_node)\n\n                    cost = 0\n                    if is_node1_outer and not is_node2_outer:\n                        # Cost between outer face and an inner plaquette\n                        r, c = node2\n                        cost = min(r, num_plaq_rows - 1 - r, c, num_plaq_cols - 1 - c) + 1\n                    elif not is_node1_outer and is_node2_outer:\n                        # Symmetric case\n                        r, c = node1\n                        cost = min(r, num_plaq_rows - 1 - r, c, num_plaq_cols - 1 - c) + 1\n                    else: # Both are inner plaquettes\n                        r1, c1 = node1\n                        r2, c2 = node2\n                        cost = abs(r1 - r2) + abs(c1 - c2)\n                    \n                    cost_matrix[i, j] = cost_matrix[j, i] = cost\n            \n            # --- Minimum Weight Perfect Matching Solver (DP with memoization) ---\n            memo = {}\n            def solve_mwpm(mask):\n                if mask == 0:\n                    return 0\n                if mask in memo:\n                    return memo[mask]\n\n                min_cost = float('inf')\n                \n                # Find the first vertex `i` in the mask\n                i = 0\n                while not (mask  (1  i)):\n                    i += 1\n                \n                # Pair `i` with every other vertex `j` in the mask\n                for j in range(i + 1, num_demand_nodes):\n                    if mask  (1  j):\n                        new_mask = mask ^ (1  i) ^ (1  j)\n                        current_cost = cost_matrix[i, j] + solve_mwpm(new_mask)\n                        if current_cost  min_cost:\n                            min_cost = current_cost\n                \n                memo[mask] = min_cost\n                return min_cost\n\n            initial_mask = (1  num_demand_nodes) - 1\n            min_matching_weight = solve_mwpm(initial_mask)\n\n        # Calculate total number of bonds\n        num_bonds = L * (M - 1) + (L - 1) * M\n\n        # Ground state energy E_0 = 2 * W - N_bonds, where W = min_matching_weight\n        ground_energy = 2 * min_matching_weight - num_bonds\n        results.append(ground_energy)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3016831"}]}