{"hands_on_practices": [{"introduction": "安德森局域化最直接的体现是量子波包在无序系统中的传播受到抑制。本练习通过数值求解含时薛定谔方程，让学生直观地观察到一个初始局域的波包如何停止扩散并被限制在初始位置附近，这是局域化现象的核心特征。通过计算均方位移随时间的变化，学生可以定量地确认这种输运抑制，从而建立对局域化现象的基本直观理解 [@problem_id:2969458]。", "problem": "考虑一个具有开放边界条件的一维 (1D) 紧束缚安德森 (Anderson) 模型。哈密顿量定义在长度为 $L$ 的有限链上，形式如下：\n$$\n\\hat{H} = -J \\sum_{j=0}^{L-2} \\left( \\lvert j \\rangle \\langle j+1 \\rvert + \\lvert j+1 \\rangle \\langle j \\rvert \\right) + \\sum_{j=0}^{L-1} \\varepsilon_j \\lvert j \\rangle \\langle j \\rvert,\n$$\n其中 $J$ 是最近邻跃迁振幅，$\\varepsilon_j$ 是独立的在位能，从区间 $[-W/2, W/2]$ 上的均匀分布中抽取。计算中采用 $\\hbar = 1$、晶格间距 $a = 1$ 和 $J = 1$ 的单位制。含时薛定谔方程 (TDSE) 为\n$$\ni \\frac{d}{dt} \\lvert \\psi(t) \\rangle = \\hat{H} \\lvert \\psi(t) \\rangle.\n$$\n设初始波函数为位于链中心的一个单点局域态，\n$$\n\\lvert \\psi(0) \\rangle = \\lvert j_0 \\rangle, \\quad j_0 = \\left\\lfloor \\frac{L-1}{2} \\right\\rfloor,\n$$\n使得初始概率密度为 $\\lvert \\psi_j(0) \\rvert^2 = \\delta_{j,j_0}$。定义均方位移为\n$$\n\\langle r^2(t) \\rangle = \\sum_{j=0}^{L-1} (j - j_0)^2 \\, \\lvert \\psi_j(t) \\rvert^2.\n$$\n你的任务是，对于一组指定的无序链，通过谱分解方法精确求解 TDSE 来计算 $\\langle r^2(t) \\rangle$，并量化末期生长速率，以展示在非零无序强度下一维系统中由安德森局域化导致的饱和现象。\n\n你必须通过对角化单粒子哈密顿量 $\\hat{H}$，将其本征基展开初始态，演化相位因子 $e^{-i E_n t}$，并重构 $\\psi_j(t)$ 来实现精确的幺正时间演化。然后，对于均匀间隔的时间点 $t_k = k \\Delta t$（其中 $\\Delta t = T_{\\max}/(N_t-1)$，$k = 0, 1, \\dots, N_t-1$），计算 $\\langle r^2(t) \\rangle$ 的时间序列。为量化末期增长，定义末期线性增长速率 $s_{\\mathrm{late}}$ 为 $\\langle r^2(t) \\rangle$ 对 $t$ 在最后 $1/5$ 时间样本上的最小二乘线性拟合的斜率。报告最终值 $\\langle r^2(T_{\\max}) \\rangle$ 和 $s_{\\mathrm{late}}$。\n\n在所述单位制下，所有量均为无量纲，因此无需进行物理单位转换。\n\n测试组。为保证可复现性，请为每个案例使用指定的固定伪随机种子。对于每个测试案例，使用开放边界条件（格点 $j=0$ 和 $j=L-1$ 之间无耦合）、所述的均匀在位无序以及上述初始条件来构建哈密顿量。三个测试案例如下：\n- 案例 Alpha：$L = 401$，$W = 5.0$，$T_{\\max} = 200.0$，$N_t = 161$，种子 $= 7$。\n- 案例 Beta：$L = 401$，$W = 2.0$，$T_{\\max} = 200.0$，$N_t = 161$，种子 $= 11$。\n- 案例 Gamma：$L = 401$，$W = 0.0$，$T_{\\max} = 60.0$，$N_t = 161$，种子 $= 0$。\n\n对每个案例，计算：\n- 最终时刻的均方位移 $\\langle r^2(T_{\\max}) \\rangle$。\n- 通过对 $\\{t_k\\}$ 最后 $1/5$ 的数据进行最小二乘回归定义的末期斜率 $s_{\\mathrm{late}}$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n\\big[ \\langle r^2(T_{\\max}) \\rangle_{\\mathrm{Alpha}}, \\ s_{\\mathrm{late,Alpha}}, \\ \\langle r^2(T_{\\max}) \\rangle_{\\mathrm{Beta}}, \\ s_{\\mathrm{late,Beta}}, \\ \\langle r^2(T_{\\max}) \\rangle_{\\mathrm{Gamma}}, \\ s_{\\mathrm{late,Gamma}} \\big].\n$$\n每个条目都必须是浮点数。不应打印任何其他文本。", "solution": "该问题要求对由安德森紧束缚模型描述的一维无序系统中的量子粒子的含时均方位移 (MSD) 进行数值计算。主要目标是观察安德森局域化的标志性特征——在存在非零无序时，MSD 在末期出现的饱和现象，并将其与纯净系统中的弹道输运进行对比。解决方案将通过使用哈密顿量的谱分解方法精确求解含时薛定谔方程 (TDSE) 来获得。\n\n过程步骤如下：\n1.  为长度为 $L$ 的有限链构建哈密顿量 $\\hat{H}$ 的矩阵表示。\n2.  通过数值对角化哈密顿量矩阵来求解定态薛定谔方程，以找到其本征值 $E_n$ 和本征矢量 $\\lvert \\phi_n \\rangle$。\n3.  在哈密顿量的本征基中表示初始态 $\\lvert \\psi(0) \\rangle$。\n4.  通过在本征基中应用时间演化算符，将状态随时间演化以获得 $\\lvert \\psi(t) \\rangle$。\n5.  从时间演化后的波函数 $\\lvert \\psi(t) \\rangle$ 计算均方位移 $\\langle r^2(t) \\rangle$。\n6.  通过计算其最终值并将时间序列的末端部分拟合一条直线以找到斜率 $s_{\\mathrm{late}}$，来分析 $\\langle r^2(t) \\rangle$ 的末期行为。\n\n所有计算都在一个单位系统中进行，其中约化普朗克常数 $\\hbar = 1$，晶格间距 $a = 1$，以及最近邻跃迁振幅 $J = 1$。\n\n**1. 哈密顿量构建**\n该系统由具有开放边界条件的 $1$D 链上的安德森紧束缚哈密顿量描述：\n$$\n\\hat{H} = -J \\sum_{j=0}^{L-2} \\left( \\lvert j \\rangle \\langle j+1 \\rvert + \\lvert j+1 \\rangle \\langle j \\rvert \\right) + \\sum_{j=0}^{L-1} \\varepsilon_j \\lvert j \\rangle \\langle j \\rvert\n$$\n在位置基 $\\{|j\\rangle\\}_{j=0}^{L-1}$ 中，哈密顿量由一个 $L \\times L$ 的实对称矩阵 $H$ 表示。矩阵元为 $H_{ij} = \\langle i | \\hat{H} | j \\rangle$。\n- 对角元是在位能：$H_{jj} = \\varepsilon_j$。这些是从均匀分布 $U[-W/2, W/2]$ 中抽取的独立随机变量，其中 $W$ 是无序强度。对于纯净情况 ($W=0$)，所有 $\\varepsilon_j = 0$。\n- 非对角元对应于最近邻跃迁。当 $J=1$ 时，我们有 $H_{j, j+1} = H_{j+1, j} = -1$。\n所有其他矩阵元均为零。这种结构形成一个三对角矩阵。\n\n**2. 谱分解与时间演化**\n量子态 $\\lvert \\psi(t) \\rangle$ 的时间演化由 TDSE 控制，$i \\frac{d}{dt} \\lvert \\psi(t) \\rangle = \\hat{H} \\lvert \\psi(t) \\rangle$。对于不含时的哈密顿量，其形式解为 $\\lvert \\psi(t) \\rangle = e^{-i\\hat{H}t} \\lvert \\psi(0) \\rangle$。\n\n计算矩阵指数 $e^{-iHt}$ 作用的最有效方法是通过谱分解。我们求解哈密顿量矩阵 $H$ 的本征值问题：\n$$\nH \\mathbf{v}_n = E_n \\mathbf{v}_n\n$$\n其中 $E_n$ 是能量本征值，$\\mathbf{v}_n$ 是对应的本征矢量（表示为列向量）。由于 $H$ 是一个实对称矩阵，其本征值 $E_n$ 是实数，其本征矢量 $\\{\\mathbf{v}_n\\}$ 构成一个完备正交基。设 $V$ 是以本征矢量 $\\mathbf{v}_n$ 为列的正交矩阵。对角化可以写作 $H = V D V^T$，其中 $D$ 是本征值的对角矩阵，$D_{nn} = E_n$。\n\n时间演化算符则为：\n$$\ne^{-iHt} = V e^{-iDt} V^T\n$$\n其中 $(e^{-iDt})_{nn} = e^{-iE_n t}$。\n\n初始态局域在链的中心：$\\lvert \\psi(0) \\rangle = \\lvert j_0 \\rangle$，其中 $j_0 = \\lfloor (L-1)/2 \\rfloor$。在向量表示法中，$\\boldsymbol{\\psi}(0)$ 是一个在索引 $j_0$ 处为 $1$、其他位置为 $0$ 的列向量。在时间 $t$ 的状态是：\n$$\n\\boldsymbol{\\psi}(t) = V e^{-iDt} V^T \\boldsymbol{\\psi}(0)\n$$\n乘积 $V^T \\boldsymbol{\\psi}(0)$ 得到一个展开系数的列向量，$c_n = \\langle \\phi_n | \\psi(0) \\rangle = (\\mathbf{v}_n)_{j_0} = V_{j_0,n}$。设 $\\mathbf{c} = V^T \\boldsymbol{\\psi}(0)$ 为该系数向量。那么 $\\boldsymbol{\\psi}(t)$ 可以计算为：\n$$\n\\boldsymbol{\\psi}(t) = V \\left( \\mathbf{c} \\odot e^{-i\\mathbf{E}t} \\right)\n$$\n其中 $\\mathbf{E}$ 是本征值向量，$\\odot$ 表示逐元素乘积，向量指数运算也是逐元素的。在时间 $t$ 的波函数的第 $j$ 个分量是：\n$$\n\\psi_j(t) = \\sum_{n=0}^{L-1} V_{j,n} c_n e^{-iE_n t} = \\sum_{n=0}^{L-1} V_{j,n} V_{j_0,n} e^{-iE_n t}\n$$\n\n**3. 均方位移**\n均方位移 (MSD) 衡量波包的空间扩展程度：\n$$\n\\langle r^2(t) \\rangle = \\sum_{j=0}^{L-1} (j - j_0)^2 \\, \\lvert \\psi_j(t) \\rvert^2\n$$\n其中 $\\lvert \\psi_j(t) \\rvert^2$ 是在时间 $t$ 在格点 $j$ 找到粒子的概率。此量在每个时间步长 $t_k = k \\Delta t$（$k \\in \\{0, 1, \\dots, N_t-1\\}$）上计算。\n\n**4. 末期增长分析**\n为量化动力学行为，计算两个值：\n- 最终的 MSD，$\\langle r^2(T_{\\max}) \\rangle$。\n- 末期斜率 $s_{\\mathrm{late}}$。这被定义为对最后 $1/5$ 时间样本的数据点 $\\{ (t_k, \\langle r^2(t_k) \\rangle) \\}$ 进行简单线性回归拟合得到的直线的斜率。对于 $N_t$ 个样本，该拟合在最后 $\\lceil N_t/5 \\rceil$ 个点上执行。斜率使用最小二乘拟合的标准公式计算。\n\n在强无序情况下（例如，案例 Alpha，$W=5.0$），安德森局域化意味着波包会保持在其初始位置附近局域。因此，$\\langle r^2(t) \\rangle$ 预期会先增长，然后饱和到一个与局域化长度相关的恒定值。末期斜率 $s_{\\mathrm{late}}$ 应接近于零。对于较弱的无序（例如，案例 Beta，$W=2.0$），局域化长度更大，导致 MSD 的饱和值也更大。对于纯净情况（案例 Gamma，$W=0.0$），粒子进行弹道输运，其中 $\\langle r^2(t) \\rangle \\propto t^2$。计算出的“线性”斜率 $s_{\\mathrm{late}}$ 将是一个大的正数，反映了 MSD 在线性尺度上的加速增长。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n\n    def solve_case(L, W, T_max, N_t, seed):\n        \"\"\"\n        Solves the Anderson localization problem for a single parameter set.\n\n        Args:\n            L (int): The length of the 1D chain.\n            W (float): The disorder strength. On-site energies are in [-W/2, W/2].\n            T_max (float): The maximum evolution time.\n            N_t (int): The number of time steps.\n            seed (int): The seed for the pseudo-random number generator.\n\n        Returns:\n            A tuple containing:\n            - r2_final (float): The mean-square displacement at T_max.\n            - s_late (float): The late-time linear growth rate of the MSD.\n        \"\"\"\n        # 1. System Setup\n        J = 1.0  # Hopping amplitude, set to 1\n        j0 = (L - 1) // 2  # Initial position at the center of the chain\n        t_points = np.linspace(0, T_max, N_t)  # Array of time points\n\n        # 2. Hamiltonian Construction\n        rng = np.random.default_rng(seed)\n        if W > 0:\n            onsite_energies = rng.uniform(-W / 2.0, W / 2.0, size=L)\n        else:\n            onsite_energies = np.zeros(L)\n        \n        # The Hamiltonian is a tridiagonal matrix\n        H = np.diag(onsite_energies) + \\\n            np.diag(-J * np.ones(L - 1), k=1) + \\\n            np.diag(-J * np.ones(L - 1), k=-1)\n\n        # 3. Spectral Decomposition\n        # E contains eigenvalues, V contains corresponding eigenvectors as columns\n        E, V = np.linalg.eigh(H)\n\n        # 4. Initial State Projection\n        # The initial state is |psi(0)> = |j0>. Its expansion coefficients in the\n        # eigenbasis {_n} are c_n = <_n|psi(0)> = <_n|j0> = V[j0, n].\n        coeffs_initial = V[j0, :]\n\n        # 5. Time Evolution and MSD Calculation\n        msd_series = []\n        # Pre-calculate the vector of squared distances from the center\n        j_indices = np.arange(L)\n        dist_sq = (j_indices - j0)**2\n\n        for t in t_points:\n            # Evolve the coefficients in the eigenbasis: c_n(t) = c_n(0) * e^(-i*E_n*t)\n            evolved_coeffs = coeffs_initial * np.exp(-1j * E * t)\n            \n            # Reconstruct the wavefunction in the site basis: |psi(t)> = sum_n c_n(t) |_n>\n            psi_t = V @ evolved_coeffs\n\n            # Calculate probability density |psi_j(t)|^2\n            prob_density = np.abs(psi_t)**2\n            \n            # Calculate mean-square displacement <r^2(t)>\n            msd = np.sum(dist_sq * prob_density)\n            msd_series.append(msd)\n        \n        msd_series = np.array(msd_series)\n\n        # 6. Analysis of Late-Time Dynamics\n        # The final value of the MSD is the last element of the series.\n        r2_final = msd_series[-1]\n\n        # Calculate the late-time slope s_late via linear regression.\n        # The fit is over the final 1/5 of the time samples.\n        num_fit_points = int(np.ceil(N_t / 5.0))\n        if num_fit_points < 2: # Need at least 2 points for a fit\n             s_late = 0.0\n        else:\n            fit_slice = slice(N_t - num_fit_points, N_t)\n            t_fit = t_points[fit_slice]\n            msd_fit = msd_series[fit_slice]\n            \n            # Perform linear regression to find the slope\n            lin_reg_result = stats.linregress(t_fit, msd_fit)\n            s_late = lin_reg_result.slope\n\n        return r2_final, s_late\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'L': 401, 'W': 5.0, 'T_max': 200.0, 'N_t': 161, 'seed': 7},    # Case Alpha\n        {'L': 401, 'W': 2.0, 'T_max': 200.0, 'N_t': 161, 'seed': 11},   # Case Beta\n        {'L': 401, 'W': 0.0, 'T_max': 60.0, 'N_t': 161, 'seed': 0},     # Case Gamma\n    ]\n\n    results = []\n    for case in test_cases:\n        r2_final, s_late = solve_case(**case)\n        results.extend([r2_final, s_late])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2969458"}, {"introduction": "在观察到局域化现象后，下一步是进行定量表征。局域化长度 $\\xi$ 是描述局域态空间范围的核心物理量，它可以通过计算系统传递矩阵的李雅普诺夫指数来获得。本练习将引导学生理解传递矩阵方法的原理，这是计算准一维系统中局域化长度的标准工具 [@problem_id:2969478]。通过这个练习，学生不仅能学习到一个强大的计算技术，还能体会到在处理大量矩阵乘积时维持数值稳定性的重要性，例如通过QR分解等技巧。", "problem": "考虑一个宽度为 $M$ 的无序紧束缚条带，其纵向为 $x \\in \\{1,2,\\dots,L\\}$，横向采用开放边界条件。在固定能量 $E$ 下，沿着 $x$ 方向的离散薛定谔方程可以写成如下的块形式\n$$ t_{\\parallel} \\,\\psi_{x+1} + t_{\\parallel} \\,\\psi_{x-1} + H_y \\,\\psi_x + V_x \\,\\psi_x = E \\,\\psi_x, $$\n其中 $t_{\\parallel}$ 是纵向跃迁振幅，$H_y$ 是尺寸为 $M \\times M$ 的横向跃迁矩阵，而 $V_x$ 是在切片 $x$ 处的一个对角的 $M \\times M$ 随机势。引入 $2M$ 分量的状态 $\\Phi_x = \\begin{pmatrix} \\psi_x \\\\ \\psi_{x-1} \\end{pmatrix}$ 和转移矩阵\n$$ T_x = \\begin{pmatrix} A_x & -I_M \\\\ I_M & 0 \\end{pmatrix}, \\quad A_x = \\frac{1}{t_{\\parallel}}\\big(E I_M - H_y - V_x\\big), $$\n递归关系变为 $\\Phi_{x+1} = T_x \\,\\Phi_x$。对于这类实数、流守恒的模型，每个 $T_x$ 都是辛矩阵，即 $T_x^{\\top} J T_x = J$，其中 $J = \\begin{pmatrix} 0 & I_M \\\\ -I_M & 0 \\end{pmatrix}$，并且乘积 $P_L = T_L T_{L-1}\\cdots T_1$ 通过乘法遍历定理定义了 Lyapunov 指数：奇异值 $\\sigma_i(P_L)$ 通常随 $L$ 指数增长或衰减，指数 $\\gamma_i$ 定义为 $\\gamma_i = \\lim_{L\\to\\infty} \\frac{1}{L}\\ln \\sigma_i(P_L)$。\n\n选择一个选项，该选项正确描述了一种高效且数值稳定的转移矩阵算法，用于计算准一维局域化长度，并概述了适用于此场景的可靠的收敛性诊断方法。\n\nA. 构建 $2M \\times 2M$ 转移矩阵 $T_x$ 序列，并通过重复相乘来传播 $\\mathbb{R}^{2M}$ 的一个标准正交基 $Q$。每 $n$ 步，对演化后的基 $Y = T_{x+n-1}\\cdots T_x \\, Q = \\widetilde{Q} R$ 应用基于 Householder 变换的 $QR$ (标准正交-三角) 分解，将 $Q$ 替换为 $\\widetilde{Q}$，并累加 $R$ 的对角线元素的对数。通过将累加和除以总长度 $L$ 并排序来估计 Lyapunov 谱。为确保数值稳定性，避免显式地构建 $P_L$，通过以适中的 $n$ 进行 $QR$ 分解来维持标准正交性，并监视 $T_x^{\\top} J T_x - J$ 的范数以跟踪辛性误差。对于收敛性诊断，验证倒数配对 $\\gamma_i = -\\gamma_{2M+1-i}$，$\\sum_{i=1}^{2M} \\gamma_i \\approx 0$，指数相对于初始 $Q$ 和再正交化间隔 $n$ 的选择的独立性，以及统计方差大约按 $1/L$ 衰减。准一维局域化长度由最小的正 Lyapunov 指数得到。\n\nB. 构建完整乘积 $P_L = T_L T_{L-1}\\cdots T_1$，计算其特征值 $\\lambda_i$，并通过 $\\gamma_i = \\frac{1}{L} \\ln |\\lambda_i|$ 估计 Lyapunov 指数。通过使用双精度并在最后对 $P_L$ 进行一次对角化来实现数值稳定性。通过特征向量的正交性以及检查谱对宽度 $M$ 不敏感来评估收敛性。\n\nC. 在递归关系 $\\Phi_{x+1} = T_x \\,\\Phi_x$ 下演化单个随机向量 $\\Phi_0$，并在每一步将其欧几里得范数归一化为 1，并通过 $\\ln \\|\\Phi_x\\|$ 在 $x$ 上的时间平均来估计局域化长度。稳定性通过频繁的归一化来保证，收敛性通过 $\\ln \\|\\Phi_x\\|$ 的平稳性以及不同初始 $\\Phi_0$ 的结果一致性来诊断。\n\nD. 在每一步，计算奇异值分解 (SVD) $T_x = U_x \\Sigma_x V_x^{\\top}$，将各个切片的对角奇异值 $\\Sigma_x$ 相乘得到 $P_L$ 的奇异值，并通过将这些乘积的对数除以 $L$ 来获得指数。由于 SVD 是后向稳定的，因此稳定性得到保证。通过 $U_x$ 和 $V_x$ 的幺正性以及监视奇异值是否成对倒数来验证收敛性。", "solution": "用户提供了一个关于准一维无序系统中局域化长度数值计算的问题陈述。我的任务是首先验证该问题陈述，然后在有效的情况下，推导出正确的方法并评估给定的选项。\n\n### 问题验证\n\n**步骤 1：提取已知信息**\n\n问题提供了以下信息：\n- 一个宽度为 $M$、长度为 $L$ 的无序紧束缚条带，其纵向坐标为 $x \\in \\{1,2,\\dots,L\\}$，横向为开放边界条件。\n- 在能量 $E$ 下的离散薛定谔方程：$t_{\\parallel} \\,\\psi_{x+1} + t_{\\parallel} \\,\\psi_{x-1} + H_y \\,\\psi_x + V_x \\,\\psi_x = E \\,\\psi_x$。\n- 其中，$\\psi_x$ 是一个 $M$ 分量向量，$t_{\\parallel}$ 是纵向跃迁振幅，$H_y$ 是 $M \\times M$ 横向跃迁矩阵，$V_x$ 是一个 $M \\times M$ 对角随机势矩阵。\n- 使用一个 $2M$ 分量状态 $\\Phi_x = \\begin{pmatrix} \\psi_x \\\\ \\psi_{x-1} \\end{pmatrix}$ 来构建一阶递归关系。\n- 递归关系由 $\\Phi_{x+1} = T_x \\,\\Phi_x$ 给出，其中转移矩阵 $T_x$ 是：\n$$ T_x = \\begin{pmatrix} A_x & -I_M \\\\ I_M & 0 \\end{pmatrix}, \\quad \\text{其中} \\quad A_x = \\frac{1}{t_{\\parallel}}\\big(E I_M - H_y - V_x\\big) $$\n其中 $I_M$ 是 $M \\times M$ 单位矩阵。\n- 对于实数、流守恒的模型，$T_x$ 的一个性质是它们是辛矩阵：$T_x^{\\top} J T_x = J$，其中 $J = \\begin{pmatrix} 0 & I_M \\\\ -I_M & 0 \\end{pmatrix}$。\n- 长度为 $L$ 的总转移矩阵是 $P_L = T_L T_{L-1}\\cdots T_1$。\n- Lyapunov 指数 $\\gamma_i$ 通过乘法遍历定理定义为 $\\gamma_i = \\lim_{L\\to\\infty} \\frac{1}{L}\\ln \\sigma_i(P_L)$，其中 $\\sigma_i(P_L)$ 是 $P_L$ 的奇异值。\n- 问题要求给出一个高效且数值稳定的算法来计算准一维局域化长度，并附带适当的收敛性诊断方法。\n\n**步骤 2：使用提取的信息进行验证**\n\n对照验证标准仔细审查问题陈述：\n- **科学依据：** 该表述是研究准一维系统中 Anderson 局域化的一个标准和基石方法。薛定谔方程、由此构建转移矩阵、由流守恒产生的辛性质，以及通过总转移矩阵的奇异值定义 Lyapunov 指数，这些都是凝聚态物理中公认的概念。\n- **问题定义良好：** 问题是定义良好的。它要求一种数值方法来计算一个明确定义的物理量（局域化长度），该物理量由 Lyapunov 指数导出。Oseledets 的乘法遍历定理保证了这类随机矩阵乘积的指数存在性。\n- **客观性：** 问题以精确、客观的数学语言陈述。所有术语要么是标准的，要么有明确定义。\n- **一致性与完整性：** 所提供的定义是自洽的，并且足以构建数值挑战。物理模型与数学对象（$T_x$, $P_L$, $\\gamma_i$）之间的关系表述清晰。没有矛盾之处。\n\n**步骤 3：结论与行动**\n\n问题陈述在科学上是合理的、定义良好的，并且没有任何指定的缺陷。它代表了计算物理学中一个标准的、非平凡的问题。\n**结论：** 问题有效。\n**行动：** 继续推导解决方案并评估选项。\n\n### 解法推导\n\n目标是计算 Lyapunov 指数 $\\gamma_i = \\lim_{L\\to\\infty} \\frac{1}{L}\\ln \\sigma_i(P_L)$。首先计算乘积矩阵 $P_L = T_L T_{L-1}\\cdots T_1$ 然后计算其奇异值的朴素方法，对于大的 $L$ 在数值上是不可行的。随着 $L$ 的增长，$P_L$ 的列向量越来越倾向于与最大 Lyapunov 指数对应的方向对齐，使得 $P_L$ 严重病态。其奇异值将跨越一个巨大的范围，例如 $\\sigma_1 \\sim e^{\\gamma_1 L}$ 和 $\\sigma_{2M} \\sim e^{\\gamma_{2M} L}$，这会迅速导致数值上溢和下溢，并丢失关于较小指数的信息。\n\n一种高效且稳定的算法必须避免显式构造 $P_L$。标准程序依赖于对一组被转移矩阵相乘的向量进行周期性的再正交化。这通常通过 QR 分解来实现。\n\n算法流程如下：\n1. 初始化一个 $2M \\times 2M$ 正交矩阵 $Q_0$。一个简单的选择是单位矩阵，$Q_0 = I_{2M}$。该矩阵代表状态空间的一个标准正交基。\n2. 以 $n$ 个格点为一块，遍历整个系统。设总长度为 $L = k \\cdot n$。对于每个块 $j=1, \\dots, k$：\n    a. 将当前的基 $Q_{j-1}$ 在该块上传播：$Y_j = T_{jn} T_{jn-1} \\cdots T_{(j-1)n+1} \\, Q_{j-1}$。\n    b. $Y_j$ 的列向量会经过拉伸/收缩和旋转，失去其正交性。使用 QR 分解来恢复正交性：$Y_j = Q_j R_j$，其中 $Q_j$ 是一个正交矩阵，$R_j$ 是一个对角线元素为正的上三角矩阵。\n    c. 用于下一块的新基是 $Q_j$。矩阵 $R_j$ 存储了第 $j$ 块的拉伸和剪切信息。\n3. 遍历完整个长度 $L$ 后，作用于初始基上的总转移矩阵是 $P_L Q_0 = (T_L \\cdots T_{L-n+1}) \\cdots (T_n \\cdots T_1) Q_0 = Q_k R_k \\cdots R_1$。\n4. Lyapunov 指数与 $R_j$ 矩阵的对角线元素有关。第 $i$ 个对角线元素的对数之和给出了第 $i$ 个基向量的累积对数拉伸因子。然后指数可估计为：\n    $$ \\gamma_i \\approx \\frac{1}{L} \\sum_{j=1}^{k} \\ln \\left( (R_j)_{ii} \\right) $$\n    为使此公式对单个指数都准确，最终可能需要对指数列表进行排序，因为基中向量的顺序可能会波动。更严谨地，前 $p$ 个指数之和由 $p$ 维子空间体积的增长率给出，这可以从 $R_j$ 矩阵左上角 $p \\times p$ 子块的行列式计算得出。但是，对对角线元素的对数求和是常用且实用的方法。\n\n**关键性质和诊断：**\n- **辛结构**：每个 $T_x$ 都是辛矩阵（$T_x^{\\top} J T_x = J$）这一事实意味着乘积 $P_L$ 也是辛矩阵。这对 Lyapunov 谱施加了强烈的对称性：指数必须成对出现 $(\\gamma, -\\gamma)$。如果它们被排序为 $\\gamma_1 \\geq \\gamma_2 \\geq \\dots \\geq \\gamma_{2M}$，则有 $\\gamma_i = -\\gamma_{2M+1-i}$。一个直接的推论是它们的和为零：$\\sum_{i=1}^{2M} \\gamma_i = 0$。验证这一点为数值实现提供了一个强有力的检验。\n- **局域化长度**：在准一维局域化系统中，局域化长度 $\\xi_M$ 与最小的正 Lyapunov 指数成反比。根据上述排序，有 $M$ 个正指数 $\\gamma_1, \\dots, \\gamma_M$。最小的正指数是 $\\gamma_M$。因此，$\\xi_M = 1/\\gamma_M$。\n- **收敛性检查**：\n    - **统计性：** 计算涉及随机势，因此有限 $L$ 的结果是一个统计估计。该估计的方差应随 $1/L$ 减小。\n    - **系统性：** 最终的指数必须独立于非物理的数值参数，如初始基 $Q_0$ 和再正交化间隔 $n$。间隔 $n$ 的选择应审慎：足够小以防止 $Y_j$ 的列向量在数值上变得共线，但又足够大以保证效率。\n    - **实现：** 可以监视 $\\|T_x^\\top J T_x - J\\|$ 以确保转移矩阵的构造在机器精度内是正确的。\n\n### 逐项分析\n\n**A. 构建 $2M \\times 2M$ 转移矩阵 $T_x$ 序列，并通过重复相乘来传播 $\\mathbb{R}^{2M}$ 的一个标准正交基 $Q$。每 $n$ 步，对演化后的基 $Y = T_{x+n-1}\\cdots T_x \\, Q = \\widetilde{Q} R$ 应用基于 Householder 变换的 $QR$ (标准正交-三角) 分解，将 $Q$ 替换为 $\\widetilde{Q}$，并累加 $R$ 的对角线元素的对数。通过将累加和除以总长度 $L$ 并排序来估计 Lyapunov 谱。为确保数值稳定性，避免显式地构建 $P_L$，通过以适中的 $n$ 进行 $QR$ 分解来维持标准正交性，并监视 $T_x^{\\top} J T_x - J$ 的范数以跟踪辛性误差。对于收敛性诊断，验证倒数配对 $\\gamma_i = -\\gamma_{2M+1-i}$，$\\sum_{i=1}^{2M} \\gamma_i \\approx 0$，指数相对于初始 $Q$ 和再正交化间隔 $n$ 的选择的独立性，以及统计方差大约按 $1/L$ 衰减。准一维局域化长度由最小的正 Lyapunov 指数得到。**\n\n这个选项准确地描述了最先进的基于 QR 的算法。它正确地指出了需要避免构建 $P_L$ 并使用再正交化。它列出了一套全面且正确的收敛性诊断方法：检查谱的辛对称性（$\\gamma_i = -\\gamma_{2M+1-i}$ 和 $\\sum \\gamma_i = 0$）、验证与数值参数（$Q$, $n$）的无关性，以及检查预期的统计收敛（方差 $\\propto 1/L$）。它还正确地将局域化长度与最小正指数联系起来。提到监视 $T_x$ 的辛性是严谨方法的一个标志。\n**结论：正确**\n\n**B. 构建完整乘积 $P_L = T_L T_{L-1}\\cdots T_1$，计算其特征值 $\\lambda_i$，并通过 $\\gamma_i = \\frac{1}{L} \\ln |\\lambda_i|$ 估计 Lyapunov 指数。通过使用双精度并在最后对 $P_L$ 进行一次对角化来实现数值稳定性。通过特征向量的正交性以及检查谱对宽度 $M$ 不敏感来评估收敛性。**\n\n这个选项有两个主要缺陷。首先，Lyapunov 指数由**奇异值**定义，而非特征值。对于像 $P_L$ 这样的非正常矩阵，其奇异值和特征值的模可以有天壤之别。其次，所提出的构建完整乘积 $P_L$ 的算法正是由于其极端的数值不稳定性而必须避免的。双精度算术不足以防止 $P_L$ 的条件数随 $L$ 指数增长。所提出的收敛性检查也不恰当。\n**结论：不正确**\n\n**C. 在递归关系 $\\Phi_{x+1} = T_x \\,\\Phi_x$ 下演化单个随机向量 $\\Phi_0$，并在每一步将其欧几里得范数归一化为 1，并通过 $\\ln \\|\\Phi_x\\|$ 在 $x$ 上的时间平均来估计局域化长度。稳定性通过频繁的归一化来保证，收敛性通过 $\\ln \\|\\Phi_x\\|$ 的平稳性以及不同初始 $\\Phi_0$ 的结果一致性来诊断。**\n\n这个选项描述了幂迭代法。该方法是稳定的，并且能正确计算**最大**的 Lyapunov 指数 $\\gamma_1$。然而，问题要求的是局域化长度，它由 $\\xi_M = 1/\\gamma_M$ 给出，其中 $\\gamma_M$ 是最小的正指数。幂迭代法无法用于寻找除最大指数之外的任何其他指数。因此，该方法不足以完成所述任务。\n**结论：不正确**\n\n**D. 在每一步，计算奇异值分解 (SVD) $T_x = U_x \\Sigma_x V_x^{\\top}$，将各个切片的对角奇异值 $\\Sigma_x$ 相乘得到 $P_L$ 的奇异值，并通过将这些乘积的对数除以 $L$ 来获得指数。由于 SVD 是后向稳定的，因此稳定性得到保证。通过 $U_x$ 和 $V_x$ 的幺正性以及监视奇异值是否成对倒数来验证收敛性。**\n\n该选项基于一个根本性的数学错误。矩阵乘积的奇异值 $\\sigma_i(AB)$ 不等于各个矩阵奇异值的乘积 $\\sigma_i(A)\\sigma_i(B)$。它们之间的关系要复杂得多，因为它涉及到 SVD 中的正交矩阵（$A=U_A \\Sigma_A V_A^\\top, B=U_B \\Sigma_B V_B^\\top \\Rightarrow AB = U_A \\Sigma_A (V_A^\\top U_B) \\Sigma_B V_B^\\top$）。项 $V_A^\\top U_B$ 混合了奇异向量，使得简单的乘积法则无效。因此，所提出的算法在数学上是无效的。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "2969478"}, {"introduction": "与一维和二维系统不同，三维无序系统存在一个临界能量，即迁移率边 $E_c$，它分隔了扩展态和局域态。这个迁移率边的存在标志着安德森相变——一种量子相变。本练习旨在介绍一种在现代研究中广泛使用的数值技术：有限尺寸标度分析，用以精确定位迁移率边的位置 [@problem_id:2969482]。通过对不同系统尺寸下的可观测量（如归一化逆参与率）进行分析，学生将学习如何从有限体系的数值结果中提取出热力学极限下的临界行为，这是研究量子相变的核心技能。", "problem": "您的任务是根据一个无量纲局域化可观测量随能量变化的有限尺寸数据，来定义并定位一个三维迁移率边。工作在安德森紧束缚模型（Anderson tight-binding model）的框架下进行，该模型建立在立方晶格上，最近邻跃迁振幅设为 $t=1$（能量为无量纲）。三维迁移率边的严格定义如下：迁移率边是临界能量 $E_c$，它将局域态与扩展态分开。在热力学极限 $L \\to \\infty$ 下，能量为 $E$ 的态，若满足 $|E| < E_c$ 则为扩展态，若满足 $|E| > E_c$ 则为局域态（或根据无序强度反之亦然），该转变的特征是局域化长度发散和一个非平凡的临界指数。在实践中，可以通过对一个无量纲可观测量进行有限尺寸标度来估计 $E_c$。对于不同的系统尺寸 $L$，该可观测量作为能量 $E$ 的函数所绘制的曲线会在 $E_c$ 附近交叉。\n\n从凝聚态物理和无序系统的第一性原理出发，形式化一个算法，通过对约化局域化长度或约化逆参与率进行依赖于能量的有限尺寸标度，来定位 $E_c$。约化局域化长度定义为 $\\Lambda(L,E) = \\lambda(L,E)/L$，其中 $\\lambda(L,E)$ 是准一维局域化长度，例如可以通过传输矩阵方法（TMM）获得。逆参与率由归一化的本征态 $\\psi$ 定义为 $\\mathrm{IPR}(L,E) = \\sum_{i=1}^{L^3} |\\psi_i|^4$，而约化逆参与率定义为 $R(L,E) = L^3 \\,\\mathrm{IPR}(L,E)$。在临界点 $E=E_c$ 处，一个经过适当约化的无量纲可观测量满足单参数有限尺寸标度形式 $F\\!\\left((E - E_c)L^{1/\\nu}\\right)$，其中 $\\nu$ 是临界指数。这意味着对于不同的 $L$，各曲线的交点在 $E_c$ 附近，其偏差不超过次领头的非相关修正。\n\n您的程序必须实现一个稳健的、基于交叉点的 $E_c$ 估计器，该估计器使用来自离散能量格点和多个系统尺寸的数据：\n- 对于每对系统尺寸 $(L_1,L_2)$，计算所选约化可观测量 $Q$ 的差值 $D_{12}(E_j) = Q(L_1,E_j) - Q(L_2,E_j)$（在本问题中，使用 $Q \\equiv R$）。\n- 在离散能量格点 $\\{E_j\\}$ 上识别 $D_{12}$ 的零点交叉：当 $D_{12}(E_j)$ 和 $D_{12}(E_{j+1})$ 符号相反时，在区间 $[E_j,E_{j+1}]$ 内执行线性插值来估计交叉点能量 $E^{\\times}_{12}$。如果 $E_j$ 处出现精确的零点，则将 $E_j$ 视为一个交叉点。\n- 聚合所有不同尺寸对的交叉点估计值 $\\{E^{\\times}_{12}\\}$，并返回这些交叉点能量的中位数作为 $E_c$ 的稳健估计。\n- 如果在所提供的能量窗口内，所有尺寸对都没有检测到符号变化，则返回格点上的一个能量 $E^*$，在该能量点，可观测量在不同尺寸间的方差 $\\mathrm{Var}_L\\!\\left[Q(L,E)\\right]$ 最小。这可作为对最接近标度不变临界点的一个保守的替代估计。\n\n以跃迁振幅 $t$ 为单位（无量纲能量）作答。您的程序应计算以下测试套件的结果，并以浮点数形式生成最终输出。请勿使用任何随机性。\n\n测试套件（无量纲参数和格点）：\n\n- 测试用例1（理想情况，存在交叉点）：\n  - 尺寸：$L \\in \\{12,16,24\\}$。\n  - 能量：$E \\in \\{-0.2,0.2,0.6,0.8,1.0,1.4\\}$。\n  - 为遵循标度假设而构建的合成约化逆参与率，包含温和的非相关修正：\n    $$R(L,E) = A + B\\,(E - E_c^{\\mathrm{true}})\\,L^{1/\\nu} + \\frac{C}{L},$$\n    参数为 $A=1.2$，$B=0.25$，$C=0.7$，$\\nu=1.57$，$E_c^{\\mathrm{true}}=0.8$。\n\n- 测试用例2（在给定能量窗口内无交叉点；边界行为）：\n  - 尺寸：$L \\in \\{10,14,20\\}$。\n  - 能量：$E \\in \\{-2.0,-1.5,-1.0,-0.5\\}$。\n  - 合成约化逆参与率：\n    $$R(L,E) = A + B\\,(E - E_c^{\\mathrm{true}})\\,L^{1/\\nu} + \\frac{C}{L},$$\n    参数为 $A=0.9$，$B=0.3$，$C=0.5$，$\\nu=1.57$，$E_c^{\\mathrm{true}}=0.8$。\n\n- 测试用例3（由于微小的非相关振荡修正导致多个交叉点；稳健性测试）：\n  - 尺寸：$L \\in \\{10,12,18,26\\}$。\n  - 能量：$E \\in \\{0.0,0.2,0.4,0.6,0.8,1.0,1.2\\}$。\n  - 合成约化逆参与率：\n    $$R(L,E) = A + B\\,(E - E_c^{\\mathrm{true}})\\,L^{1/\\nu} + \\frac{C}{L} + \\frac{\\epsilon}{L}\\,\\sin\\!\\big(\\omega\\,(E - E_c^{\\mathrm{true}})\\big),$$\n    参数为 $A=1.0$，$B=0.28$，$C=0.6$，$\\nu=1.57$，$E_c^{\\mathrm{true}}=0.6$，$\\epsilon=0.05$，$\\omega=7.0$。\n\n程序要求：\n- 实现上述基于交叉点的估计器，为每个测试用例返回一个 $E_c$ 估计值，必要时遵循备用规则。\n- 数值细节：按照描述，在每个检测到符号变化的区间内使用线性插值。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的三个测试用例的 $E_c$ 估计值列表，四舍五入到三位小数，例如 $[e_1,e_2,e_3]$。", "solution": "所提出的问题是有效的。它在科学上基于凝聚态物理的原理，特别是安德森局域化理论和临界现象。这是一个适定问题，它提供了一个清晰、自洽且确定性的算法，用于从合成的有限尺寸标度数据中估计迁移率边 $E_c$。所有参数、定义和步骤（包括备用规则）都已明确说明，从而可以得到一个唯一且可验证的解。\n\n该解决方案的核心原理是连续相变中的有限尺寸标度（FSS）。在安德森局域化相变的背景下，像约化逆参与率 $R(L,E)$ 这样的无量纲量，在临界能量 $E_c$ 附近应遵循一个标度定律。FSS 假设断言，对于大系统尺寸 $L$ 和接近 $E_c$ 的能量 $E$，可观测量可以由一个单变量的普适标度函数 $\\mathcal{F}$ 描述：\n$$\nR(L,E) \\approx \\mathcal{F}\\left( (E - E_c)L^{1/\\nu} \\right)\n$$\n此处，$\\nu$ 是关联长度的临界指数，关联长度在相变点处发散，其形式为 $\\xi \\propto |E - E_c|^{-\\nu}$。在临界点 $E = E_c$ 处，标度函数的自变量为零，这意味着 $R(L, E_c) \\approx \\mathcal{F}(0)$ 变得与系统尺寸 $L$ 无关。因此，对于不同的系统尺寸 $L$，$R(L,E)$ 对 $E$ 的曲线将相交于一个公共点，该点提供了对 $E_c$ 的估计。\n\n在实践中，存在标度修正，这会导致有限尺寸系统对的交叉点发生轻微漂移。所提供的合成数据包含一个领头的非相关修正项，其形式通常为 $L^{-\\omega}$（其中 $\\omega > 0$），例如问题描述中的 $C/L$ 项。该算法被设计用来稳健地处理这些修正。\n\n估计 $E_c$ 的算法流程如下：\n\n$1$. **数据生成**：对于每个测试用例，使用提供的解析公式，为指定格点上的每个系统尺寸 $L$ 和能量 $E$ 计算约化逆参与率 $R(L,E)$。\n\n$2$. **逐对交叉分析**：对于每个不同的系统尺寸对 $(L_1, L_2)$，我们分析其差值函数 $D_{12}(E) = R(L_1, E) - R(L_2, E)$。两条曲线 $R(L_1, E)$ 和 $R(L_2, E)$ 的交叉点对应于 $D_{12}(E)$ 的零点。\n\n$3$. **求根**：在离散能量格点 $\\{E_j\\}$ 上定位 $D_{12}(E)$ 的根。\n    -   首先，我们识别格点上任何使得 $D_{12}(E_j) = 0$（在数值精度范围内）精确成立的能量点 $E_j$。这些点被视为精确的交叉点。\n    -   其次，我们搜索发生在格点之间的交叉点。对于每对相邻的能量 $(E_j, E_{j+1})$，我们检查差值函数的符号是否发生变化，即 $D_{12}(E_j) \\cdot D_{12}(E_{j+1}) < 0$。如果检测到符号变化，则在区间 $[E_j, E_{j+1}]$ 内必有一个根。其位置 $E^{\\times}_{12}$ 通过线性插值法估计：\n        $$\n        E^{\\times}_{12} = E_j - D_{12}(E_j) \\frac{E_{j+1} - E_j}{D_{12}(E_{j+1}) - D_{12}(E_j)}\n        $$\n\n$4$. **聚合与稳健估计**：将从所有系统尺寸对中找到的所有交叉点能量 $\\{E^{\\times}_{ij}\\}$ 收集到一个集合中。最终的 $E_c$ 估计值是该集合的中位数。中位数是一种稳健的统计度量，使其对可能由强标度修正或（如测试用例3中的）振荡项引起的异常值不那么敏感。\n\n$5$. **备用程序**：如果分析显示在整个能量范围内所有尺寸对都没有交叉点，这可能意味着临界点位于研究窗口之外。在这种情况下，规定的备用方案是确定一个能量 $E^*$，在该能量点，不同尺寸的曲线彼此“最接近”。这种“接近度”通过可观测量在不同系统尺寸间的方差 $\\mathrm{Var}_L\\!\\left[R(L,E)\\right]$ 来量化。使该方差最小的能量 $E^*$ 将作为在有限数据下对 $E_c$ 的最佳估计返回。这具有物理动机，因为在临界点，$R(L, E_c)$ 理想情况下与 $L$ 无关，对应于零方差。\n\n对三个测试用例中的每一个都实施此系统性程序，以确定各自的迁移率边能量 $E_c$ 的估计值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\n# No other libraries outside the Python standard library are permitted.\n\ndef R_case1(L, E, A=1.2, B=0.25, C=0.7, nu=1.57, Ec_true=0.8):\n    \"\"\"Computes the synthetic reduced IPR for Test Case 1.\"\"\"\n    return A + B * (E - Ec_true) * (L**(1/nu)) + C / L\n\ndef R_case2(L, E, A=0.9, B=0.3, C=0.5, nu=1.57, Ec_true=0.8):\n    \"\"\"Computes the synthetic reduced IPR for Test Case 2.\"\"\"\n    return A + B * (E - Ec_true) * (L**(1/nu)) + C / L\n\ndef R_case3(L, E, A=1.0, B=0.28, C=0.6, nu=1.57, Ec_true=0.6, epsilon=0.05, omega=7.0):\n    \"\"\"Computes the synthetic reduced IPR for Test Case 3.\"\"\"\n    return A + B * (E - Ec_true) * (L**(1/nu)) + C / L + (epsilon / L) * np.sin(omega * (E - Ec_true))\n\ndef find_ec_estimate(system_sizes, energies, r_func):\n    \"\"\"\n    Implements the crossing-based estimator for the mobility edge E_c.\n    \n    Args:\n        system_sizes (list): A list of system sizes L.\n        energies (list): A sorted list of energy grid points E.\n        r_func (callable): The function to compute R(L, E).\n\n    Returns:\n        float: The estimated mobility edge E_c.\n    \"\"\"\n    size_pairs = list(itertools.combinations(system_sizes, 2))\n    all_crossings = []\n\n    for L1, L2 in size_pairs:\n        # Ensure L1 < L2 for consistency if needed, although not required by the algorithm\n        if L1 > L2:\n            L1, L2 = L2, L1\n\n        # Precompute R(L,E) for the current pair to avoid repeated calls\n        R_values_L1 = [r_func(L1, E) for E in energies]\n        R_values_L2 = [r_func(L2, E) for E in energies]\n        \n        D_values = [r1 - r2 for r1, r2 in zip(R_values_L1, R_values_L2)]\n\n        # Find crossings by checking for sign changes and exact zeros\n        for j in range(len(energies) - 1):\n            E_j, E_j1 = energies[j], energies[j+1]\n            D_j, D_j1 = D_values[j], D_values[j+1]\n            \n            # Condition for crossing: sign change or an exact zero at a grid point\n            if D_j * D_j1 <= 0:\n                # Handle exact zero at E_j\n                if np.isclose(D_j, 0):\n                    all_crossings.append(E_j)\n                # Handle exact zero at E_j1 but not E_j\n                elif np.isclose(D_j1, 0):\n                    # This crossing will be found as an exact zero at the start of the next interval\n                    # but adding here makes logic robust if that interval is the last one.\n                    all_crossings.append(E_j1)\n                # Handle sign change between two non-zero values\n                else:\n                    # Linear interpolation formula\n                    crossing_E = E_j - D_j * (E_j1 - E_j) / (D_j1 - D_j)\n                    all_crossings.append(crossing_E)\n\n    # If crossings were found, return the median\n    if all_crossings:\n        # Remove potential duplicates from exact zeros at interval endpoints\n        unique_crossings = sorted(list(set(all_crossings)))\n        return np.median(unique_crossings)\n\n    # Fallback: if no crossings are found, find a minimum variance point\n    else:\n        min_variance = float('inf')\n        best_energy = None\n        \n        for E in energies:\n            r_values_at_E = [r_func(L, E) for L in system_sizes]\n            variance = np.var(r_values_at_E)\n            \n            if variance < min_variance:\n                min_variance = variance\n                best_energy = E\n        \n        return best_energy\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"sizes\": [12, 16, 24],\n            \"energies\": [-0.2, 0.2, 0.6, 0.8, 1.0, 1.4],\n            \"r_func\": R_case1\n        },\n        {\n            \"sizes\": [10, 14, 20],\n            \"energies\": [-2.0, -1.5, -1.0, -0.5],\n            \"r_func\": R_case2\n        },\n        {\n            \"sizes\": [10, 12, 18, 26],\n            \"energies\": [0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2],\n            \"r_func\": R_case3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        ec_estimate = find_ec_estimate(case[\"sizes\"], case[\"energies\"], case[\"r_func\"])\n        results.append(ec_estimate)\n\n    # Format the final output string as required\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2969482"}]}