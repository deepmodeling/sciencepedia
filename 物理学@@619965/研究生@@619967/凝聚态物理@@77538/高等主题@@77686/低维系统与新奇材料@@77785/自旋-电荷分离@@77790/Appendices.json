{"hands_on_practices": [{"introduction": "要深入理解任何物理现象，第一步往往是量化其基本激发。在强关联的一维哈伯德模型中，自旋-电荷分离意味着低能物理被自旋子（spinon）主导。这个练习将引导你通过一个基础但至关重要的计算，将复杂的哈伯德模型映射到更简单的有效海森堡模型，并从中推导出关键参数——自旋子速度 $v_s$。[@problem_id:1199662]", "problem": "一维Hubbard模型是理解强关联电子系统的基石。其哈密顿量由下式给出：\n$$ H = -t \\sum_{i, \\sigma} (c_{i\\sigma}^\\dagger c_{i+1,\\sigma} + c_{i+1,\\sigma}^\\dagger c_{i\\sigma}) + U \\sum_i n_{i\\uparrow} n_{i\\downarrow} $$\n此处，$c_{i\\sigma}^\\dagger$ ($c_{i\\sigma}$) 在晶格间距为 $a=1$ 的一维链的格点 $i$ 上产生（湮灭）一个自旋为 $\\sigma \\in \\{\\uparrow, \\downarrow\\}$ 的电子。算符 $n_{i\\sigma} = c_{i\\sigma}^\\dagger c_{i\\sigma}$ 是格点 $i$ 上自旋为 $\\sigma$ 的粒子数算符。参数 $t$ 是最近邻跃迁振幅，$U$ 代表在位库仑排斥。\n\n我们考虑半填充情况下的模型，这意味着平均每个格点上有一个电子。在强耦合极限下，即排斥 $U$ 远大于跃迁振幅 $t$ ($U \\gg t$) 时，产生双占据格点在能量上是高代价的。这导致了Mott绝缘态，其中电荷激发被一个能隙所抑制。然而，局域电子的自旋自由度仍然活跃。它们的动力学行为由一个有效低能哈密顿量所描述。这个自旋系统的元激发，被称为自旋子，是无能隙的，并以特征速度 $v_s$ 传播。\n\n确定在大 $U$ 极限下，半填充一维Hubbard模型的自旋速度 $v_s$。答案用参数 $t$ 和 $U$ 表示，并保留到小参数 $t/U$ 的首个非零阶。", "solution": "1. 在 $U\\gg t$ 的极限下，电子的虚跃迁导出一个有效的自旋1/2 Heisenberg哈密顿量\n$$H_{\\rm eff}=J\\sum_i\\mathbf S_i\\cdot\\mathbf S_{i+1},$$\n其交换耦合常数为\n$$J=\\frac{4t^2}{U}\\,+\\mathcal O\\bigl(t^4/U^3\\bigr).$$\n2. 根据Bethe-ansatz，一维自旋1/2 Heisenberg链（晶格间距 $a=1$）的自旋子（自旋波）速度为\n$$v_s=\\frac{\\pi}{2}\\,J.$$\n3. 将 $J=4t^2/U$ 代入可得\n$$v_s=\\frac{\\pi}{2}\\,\\frac{4t^2}{U}\n=2\\pi\\,\\frac{t^2}{U}\n+\\mathcal O\\bigl(t^4/U^3\\bigr).$$", "answer": "$$\\boxed{\\frac{2\\pi\\,t^2}{U}}$$", "id": "1199662"}, {"introduction": "理论概念的威力在于其可被实验验证的预言。自旋-电荷分离最引人注目的后果之一，体现在单粒子谱函数 $A(k, \\omega)$ 中，这是角分辨光电子能谱（ARPES）等实验可以直接测量的量。本练习将让你亲手计算，在托莫永-拉廷格液体（Tomonaga-Luttinger Liquid）的框架下，一个注入的电子如何在能量-动量空间中分裂成以不同速度 $v_c$ 和 $v_s$ 传播的电荷与自旋分支。[@problem_id:1199615]", "problem": "在一维相互作用电子系统中，其低能物理性质由Tomonaga-Luttinger液体（TLL）模型描述。该模型的一个标志性特征是自旋-电荷分离：其元激发不是类电子的准粒子，而是分离的电荷集体模式（空穴子，速度为 $v_c$）和自旋集体模式（自旋子，速度为 $v_s$）。\n\n当一个电子被添加到系统中时，它会分数化为这些基本激发。因此，描述电子添加过程的单粒子谱函数 $A(k, \\omega)$ 不会呈现一个尖锐的$\\delta$函数峰。相反，对于给定的动量 $k$，谱权重分布在一个连续的能量 $\\omega$ 范围内。\n\n考虑一个费米动量为 $k_F$ 的有自旋TLL。对于一个动量 $k$ 大于 $k_F$ 的被添加电子，其谱函数 $A(k, \\omega)$ 在 $(\\omega, k)$ 平面内的谱支撑边界上具有幂律奇异性。这些边界定义了空穴子和自旋子分支的色散关系。鉴于电荷速度大于自旋速度，即 $v_c  v_s$，空穴子分支对应于谱支撑的上能量边界，而自旋子分支对应于下能量边界。\n\n您的任务是计算在特定动量 $k = \\frac{3}{2} k_F$ 时，空穴子分支（$\\omega_h$）与自旋子分支（$\\omega_s$）之间的能量差 $\\Delta \\omega = \\omega_h(k) - \\omega_s(k)$。请用 $v_c$、$v_s$ 和 $k_F$ 表示您的答案。", "solution": "1. 对于在有自旋TLL中添加一个动量 $kk_F$ 的电子，其相关色散关系为\n$$\n\\omega_h(k)=v_c\\,(k-k_F), \n\\quad\n\\omega_s(k)=v_s\\,(k-k_F).\n$$\n2. 能量差为\n$$\n\\Delta\\omega=\\omega_h(k)-\\omega_s(k)\n=(v_c-v_s)\\,(k-k_F).\n$$\n3. 对于 $k=\\tfrac32k_F$，有 $k-k_F=\\tfrac12k_F$，所以\n$$\n\\Delta\\omega=(v_c-v_s)\\,\\frac12k_F\n=\\frac12\\,(v_c-v_s)\\,k_F.\n$$", "answer": "$$\\boxed{\\frac12\\,(v_c - v_s)\\,k_F}$$", "id": "1199615"}, {"introduction": "从解析计算到数值模拟是物理学研究的飞跃，它能将抽象的方程转化为动态的、直观的图像。这项高级实践将带你进入计算凝聚态物理学的世界，通过精确的数值演化来模拟向一维链中注入一个电子后的实时动态。你将直接“看到”电荷和自旋密度波包如何分离并以不同的速度传播，为自旋-电荷分离现象提供最生动的可视化证据。[@problem_id:3017411]", "problem": "考虑一个具有开放边界条件的一维 Hubbard 链，在具有 $L$ 个格点的一维晶格上用二次量子化进行建模。每个格点包含两种费米子模式，即自旋向上和自旋向下，通过模式索引 $m = 2j + s$ 进行正则排序，其中 $j \\in \\{0, 1, \\dots, L-1\\}$ 标记格点，$s \\in \\{0,1\\}$ 标记自旋，$s=0$ 代表自旋向上，$s=1$ 代表自旋向下。费米子产生和湮灭算符 $c_m^\\dagger$ 和 $c_m$ 满足正则反对易关系 $\\{c_m, c_n^\\dagger\\} = \\delta_{mn}$ 和 $\\{c_m, c_n\\} = \\{c_m^\\dagger, c_n^\\dagger\\} = 0$。哈密顿量是标准的一维排斥 Hubbard 模型，\n$$\nH = -t \\sum_{j=0}^{L-2} \\sum_{s=0}^{1} \\left( c_{2j+s}^\\dagger c_{2(j+1)+s} + c_{2(j+1)+s}^\\dagger c_{2j+s} \\right) + U \\sum_{j=0}^{L-1} n_{j\\uparrow} n_{j\\downarrow},\n$$\n其中 $t$ 是最近邻跃迁振幅（设为 $t=1$），$U$ 是在位相互作用强度，$n_{j\\uparrow} = c_{2j}^\\dagger c_{2j}$，$n_{j\\downarrow} = c_{2j+1}^\\dagger c_{2j+1}$。我们选择单位使得 $\\hbar = 1$。\n\n您的任务是模拟局部电子注入后的幺正时间演化，并通过提取超额电荷密度和自旋密度的空间分离峰值位置来量化自旋-电荷分离现象。您不需要实现完整的演化块十进法（Time-Evolving Block Decimation, TEBD）或时间依赖的密度矩阵重整化群（time-dependent Density Matrix Renormalization Group, DMRG），而是应该通过对稀疏哈密顿量进行指数化，在一个小链上执行数值精确的时间演化。对于短时间和小型系统，这种方法在概念上与 TEBD 一致。\n\n初态：准备一个半填充的乘积态，每个格点上恰好有一个电子，且自旋模式交替出现，即 $|\\psi_\\mathrm{init}\\rangle$。具体而言，当 $j$ 为偶数时，格点被自旋向上的电子占据；当 $j$ 为奇数时，格点被自旋向下的电子占据。然后，通过对 $|\\psi_\\mathrm{init}\\rangle$ 施加算符 $c^\\dagger_{2 j_0}$，在格点 $j_0$ 处注入一个局域的自旋向上电子，并将得到的态 $|\\psi(0)\\rangle$ 归一化。通过重复应用单步演化 $|\\psi(t+\\Delta t)\\rangle \\approx e^{-i H \\Delta t} |\\psi(t)\\rangle$，在哈密顿量 $H$ 的作用下将 $|\\psi(0)\\rangle$ 演化时间 $T$，其中时间步长固定为 $\\Delta t$。在最终时刻 $T$ 计算以下局域可观测量：\n- 电荷密度 $n_j(T) = \\langle \\psi(T) | n_{j\\uparrow} + n_{j\\downarrow} | \\psi(T) \\rangle$。\n- z-方向自旋密度 $S^z_j(T) = \\frac{1}{2} \\langle \\psi(T) | n_{j\\uparrow} - n_{j\\downarrow} | \\psi(T) \\rangle$。\n定义相对于注入前初始乘积态 $|\\psi_\\mathrm{init}\\rangle$ 的相应超额密度：\n$$\n\\Delta n_j(T) = n_j(T) - n_j^\\mathrm{init}, \\quad \\Delta S^z_j(T) = S^z_j(T) - S^{z,\\mathrm{init}}_j.\n$$\n为量化自旋-电荷分离，需要确定向右移动的峰值位置。对于 $j  j_0$，分别取使 $\\Delta n_j(T)$ 达到最大值的索引 $j$ 和在正值中使 $\\Delta S^z_j(T)$ 达到最大值的索引。如果对于某个可观测量，在右侧未找到正的超额值，则将其右峰位置定义为 $j_0$。分离度量是这两个峰值位置之差，以晶格格点单位表示：\n$$\n\\Delta x = j^\\ast_\\mathrm{charge}(T) - j^\\ast_\\mathrm{spin}(T).\n$$\n\n使用 $2L$ 个费米子模式上的占据数表象来实现希尔伯特空间，该表象由从 $0$ 到 $2^{2L}-1$ 的整数的位串表示。使用由 $m = 2 j + s$ 指定的正则排序。通过枚举基态并应用源自 Jordan–Wigner 排序的费米子符号规则来构建稀疏哈密顿量。使用对向量作用的数值稳定的稀疏指数运算来执行时间演化。根据概率分布 $|\\psi(T)|^2$ 和占据数表象中数算符的对角结构来计算密度。\n\n测试套件：\n针对以下三组参数集运行模拟，所有参数集均设置跃迁振幅 $t=1$ 和开放边界条件：\n- 情况 A：$L=6$, $U=0$, $T=0.6$, $\\Delta t=0.05$, $j_0=3$。\n- 情况 B：$L=6$, $U=4$, $T=0.6$, $\\Delta t=0.05$, $j_0=3$。\n- 情况 C：$L=6$, $U=8$, $T=0.6$, $\\Delta t=0.05$, $j_0=3$。\n\n您的程序必须输出单行，包含一个用逗号分隔的三个浮点数列表，单位为晶格格点，每个浮点数分别对应各种情况下的分离度量 $\\Delta x$，并用方括号括起来（例如 $[\\Delta x_A,\\Delta x_B,\\Delta x_C]$）。不允许有其他输出。此问题不涉及角度。以晶格格点单位表示的距离应为纯数（无量纲的晶格位置）。请确保数值稳定性，并提供通过标准 Python 浮点数格式化字符串四舍五入的结果。", "solution": "用户提供的问题是计算凝聚态物理中一个定义明确且具有科学依据的练习。它要求模拟一维 Hubbard 模型中的量子动力学，以展示自旋-电荷分离现象。该问题是有效的，因为它是自洽的、客观的，并且基于已建立的物理原理。指定的参数和系统尺寸（$L=6$）对于精确对角化方法在计算上是可行的。\n\n解决方案的实现方式是：在占据数表象中表示多体量子系统，将哈密顿量构建为稀疏矩阵，使用矩阵指数函数执行时间演化，最后计算所需的物理可观测量。\n\n### 1. 希尔伯特空间与基矢表示\n该系统由一个包含 $L$ 个格点的晶格组成，每个格点有两个费米子模式，分别对应自旋向上（$s=0$）和自旋向下（$s=1$）。费米子模式总数为 $2L$。希尔伯特空间是由这 $2L$ 个模式所有可能的占据方式张成的 Fock 空间。该空间的完备基是占据数表象，其中每个基态通过指明哪些模式被占据来确定。\n\n对于一个有 $2L$ 个模式的系统，每个基态都可以唯一地映射到一个 $2L$ 位的整数，通常称为位掩码（bitmask）。如果模式 $m$ 被占据，则该整数的第 $m$ 位设置为 $1$，否则为 $0$。模式索引 $m$ 定义为 $m = 2j + s$，其中 $j \\in \\{0, 1, \\dots, L-1\\}$ 是格点索引。这建立了从 $m=0$（格点0，自旋向上）到 $m=2L-1$（格点 $L-1$，自旋向下）的模式的正则排序。该希尔伯特空间的维度是 $2^{2L}$。对于 $L=6$，维度为 $2^{12} = 4096$，这对于直接数值计算是可控的。\n\n### 2. 哈密顿量构建\nHubbard 哈密顿量 $H = H_t + H_U$ 由一个动能（跃迁）项 $H_t$ 和一个势能（在位相互作用）项 $H_U$ 组成。\n\n相互作用项为 $H_U = U \\sum_{j=0}^{L-1} n_{j\\uparrow} n_{j\\downarrow}$，其中 $n_{j\\uparrow} = c_{2j}^\\dagger c_{2j}$ 和 $n_{j\\downarrow} = c_{2j+1}^\\dagger c_{2j+1}$ 是数算符。在占据数表象中，数算符是对角的。一个基态 $|k\\rangle$（由整数 $k$ 表示）是 $H_U$ 的一个本征态。相应的本征值是 $U$ 乘以在态 $|k\\rangle$ 中双重占据的格点数。因此，$H_U$ 的矩阵表示是对角的，其矩阵元为 $\\langle k | H_U | k \\rangle = U \\sum_{j=0}^{L-1} \\left( (k \\gg 2j) \\ 1 \\right) \\cdot \\left( (k \\gg (2j+1)) \\ 1 \\right)$。\n\n跃迁项为 $H_t = -t \\sum_{j=0}^{L-2} \\sum_{s=0}^{1} \\left( c_{2j+s}^\\dagger c_{2(j+1)+s} + \\text{h.c.} \\right)$。该项是非对角的。像 $c_{m_2}^\\dagger c_{m_1}$ 这样的算符在模式 $m_1$ 中湮灭一个费米子，并在模式 $m_2$ 中产生一个。它将一个 $m_1$ 被占据而 $m_2$ 为空的基态 $|k\\rangle$ 连接到一个 $m_1$ 为空而 $m_2$ 被占据的态 $|k'\\rangle$。费米子算符的一个关键方面是 Jordan-Wigner 符号，它源于反对易关系。算符 $c_{m_2}^\\dagger c_{m_1}$ 作用于态 $|k\\rangle$ 会产生一个符号 $(-1)^P$，其中 $P$ 是 $m_1$ 和 $m_2$ 之间（不包括两端）被占据的模式数。假设 $m_1  m_2$，该符号由整数 $k$ 在位位置 $m_1+1$ 和 $m_2-1$ 之间的置位（set bits）数量的奇偶性决定。矩阵元为 $\\langle k' | H_t | k \\rangle = -t \\cdot (-1)^P$。由于哈密顿量是厄米（Hermitian）的，所以 $\\langle k | H_t | k' \\rangle = \\langle k' | H_t | k \\rangle$。\n\n结合这些，我们构建了完整的哈密顿量 $H$ 作为一个 $2^{2L} \\times 2^{2L}$ 的稀疏矩阵。\n\n### 3. 初态与时间演化\n模拟从一个特定的初态开始。首先，定义一个基态 $|\\psi_\\mathrm{init}\\rangle$ 作为一个具有交替自旋模式的半填充乘积态：如果 $j$ 是偶数，格点 $j$ 有一个自旋向上的电子；如果 $j$ 是奇数，则有一个自旋向下的电子。这对应于我们 Fock 空间中的单个基矢。\n\n用于时间演化的态 $|\\psi(0)\\rangle$ 是通过在格点 $j_0$ 注入一个自旋向上的电子来创建的。这是通过将产生算符 $c_{2j_0}^\\dagger$ 作用于 $|\\psi_\\mathrm{init}\\rangle$ 来实现的。由于格点 $j_0$ 的自旋向上模式初始为空，此操作是良定义的，并产生一个新的、已经是归一化的单基矢态。$|\\psi(0)\\rangle$ 的态矢量表示是一个大小为 $2^{2L}$ 的数组，在对应于适当位掩码的索引处为 1，其他地方为 0。\n\n态矢量的时间演化遵循薛定谔方程，即 $|\\psi(t)\\rangle = e^{-iHt} |\\psi(0)\\rangle$（其中 $\\hbar = 1$）。这是通过数值计算得到的。问题指定使用单步传播算符 $e^{-iH\\Delta t}$ 的重复应用，但为了提高数值精度和稳定性，我们通过计算完整的矩阵指数 $e^{-iHT}$ 对初态 $|\\psi(0)\\rangle$ 的作用来直接计算终态 $|\\psi(T)\\rangle$。`scipy.sparse.linalg.expm_multiply` 函数对此非常理想，因为它可以在不显式构造稠密矩阵 $e^{-iHT}$ 的情况下计算此作用。\n\n### 4. 可观测量的测量\n在最终时刻 $T$，我们得到态矢量 $|\\psi(T)\\rangle = \\sum_k \\alpha_k |k\\rangle$。一个对角算符 $O$ 的期望值为 $\\langle O \\rangle = \\langle \\psi(T) | O | \\psi(T) \\rangle = \\sum_k |\\alpha_k|^2 \\langle k | O | k \\rangle$。\n电荷密度 $n_j = n_{j\\uparrow} + n_{j\\downarrow}$ 和 z-方向自旋密度 $S^z_j = \\frac{1}{2}(n_{j\\uparrow} - n_{j\\downarrow})$ 在占据数表象中是对角的。它们在时刻 $T$ 的期望值是通过对每个基态 $|k\\rangle$ 的本征值求和计算的，并以相应的概率 $|\\alpha_k|^2$ 进行加权。\n\n### 5. 自旋-电荷分离分析\n为量化自旋-电荷分离，我们首先通过减去初始（注入前）密度来计算超额密度：\n$\\Delta n_j(T) = n_j(T) - n_j^\\mathrm{init}$\n$\\Delta S^z_j(T) = S^z_j(T) - S^{z,\\mathrm{init}}_j$\n\n然后定位这些超额密度在注入点右侧（$j  j_0$）的峰值位置。\n- 对于电荷（$j^\\ast_\\mathrm{charge}$）：如果在 $j  j_0$ 处存在任何正的超额电荷 $\\Delta n_j(T)  0$，则峰值是使 $\\Delta n_j(T)$ 最大化的索引 $j$。否则，该位置定义为 $j_0$。\n- 对于自旋（$j^\\ast_\\mathrm{spin}$）：如果在 $j  j_0$ 处存在任何正的超额自旋 $\\Delta S^z_j(T)  0$，则峰值是在这些正值中使 $\\Delta S^z_j(T)$ 最大化的索引 $j$。否则，该位置定义为 $j_0$。\n\n最终的分离度量是这些峰值位置之差：$\\Delta x = j^\\ast_\\mathrm{charge}(T) - j^\\ast_\\mathrm{spin}(T)$。对提供的三组参数集中的每一组重复整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import expm_multiply\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A: L=6, U=0, T=0.6, Δt=0.05, j₀=3\n        {'L': 6, 'U': 0, 't': 1, 'T': 0.6, 'dt': 0.05, 'j0': 3},\n        # Case B: L=6, U=4, T=0.6, Δt=0.05, j₀=3\n        {'L': 6, 'U': 4, 't': 1, 'T': 0.6, 'dt': 0.05, 'j0': 3},\n        # Case C: L=6, U=8, T=0.6, Δt=0.05, j₀=3\n        {'L': 6, 'U': 8, 't': 1, 'T': 0.6, 'dt': 0.05, 'j0': 3},\n    ]\n\n    results = []\n    for params in test_cases:\n        delta_x = run_simulation(**params)\n        results.append(delta_x)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(L, U, t, T, dt, j0):\n    \"\"\"\n    Performs the simulation for a single set of parameters.\n    \"\"\"\n    num_modes = 2 * L\n    hilbert_dim = 1  num_modes\n\n    # 1. Initial State Preparation\n    # |psi_init>: Alternating spin-up/down product state (half-filling)\n    init_mask = 0\n    for j in range(L):\n        if j % 2 == 0:  # Even site: spin-up\n            init_mask |= (1  (2 * j))\n        else:  # Odd site: spin-down\n            init_mask |= (1  (2 * j + 1))\n\n    # Pre-injection densities for calculating excess densities later\n    n_init = np.ones(L)\n    Sz_init = np.array([0.5 if j % 2 == 0 else -0.5 for j in range(L)])\n\n    # |psi(0)>: Inject one spin-up electron at site j0\n    m_inj = 2 * j0\n    inj_mask = init_mask | (1  m_inj)\n    \n    psi_0 = np.zeros(hilbert_dim, dtype=np.complex128)\n    psi_0[inj_mask] = 1.0\n\n    # 2. Hamiltonian Construction\n    H = lil_matrix((hilbert_dim, hilbert_dim), dtype=float)\n\n    for k in range(hilbert_dim):\n        # On-site interaction term (diagonal)\n        if U != 0:\n            U_term = 0\n            for j in range(L):\n                m_up = 2 * j\n                m_down = 2 * j + 1\n                if ((k >> m_up)  1) and ((k >> m_down)  1):\n                    U_term += U\n            if U_term != 0:\n                H[k, k] = U_term\n\n    # Hopping term (off-diagonal)\n    for j in range(L - 1): # site index\n        for s in range(2): # spin index {0: up, 1: down}\n            m1 = 2 * j + s\n            m2 = 2 * (j + 1) + s\n            \n            for k in range(hilbert_dim):\n                # Check if hop from m1 to m2 is possible in state k\n                if ((k >> m1)  1) and not ((k >> m2)  1):\n                    k_prime = k ^ (1  m1) ^ (1  m2)\n                    \n                    # Jordan-Wigner sign\n                    # Count occupied fermions between m1 and m2\n                    mask = ((1  (m2 - m1 - 1)) - 1)  (m1 + 1)\n                    sub_k = k  mask\n                    parity = bin(sub_k).count('1')\n                    sign = 1 if parity % 2 == 0 else -1\n                    \n                    val = -t * sign\n                    # Since H is built once, fill both symmetric elements\n                    if k  k_prime: # To avoid processing each pair twice\n                        H[k_prime, k] += val\n                        H[k, k_prime] += val\n\n    H_csr = H.tocsr()\n    \n    # 3. Time Evolution\n    num_steps = int(round(T / dt))\n    \n    # Evolve state from t=0 to t=T. expm_multiply can do this in one call\n    # for better accuracy than repeated multiplication.\n    psi_T = expm_multiply(-1j * H_csr, psi_0, start=0, stop=T, num=num_steps + 1)[-1]\n    \n    # 4. Calculate Observables\n    # Pre-calculate observable values for each basis state to vectorize computation\n    n_vals_per_site = np.zeros((L, hilbert_dim), dtype=np.int8)\n    Sz_vals_per_site = np.zeros((L, hilbert_dim), dtype=float)\n\n    for k in range(hilbert_dim):\n        for j in range(L):\n            m_up = 2 * j\n            m_down = 2 * j + 1\n            n_up_k = (k >> m_up)  1\n            n_down_k = (k >> m_down)  1\n            n_vals_per_site[j, k] = n_up_k + n_down_k\n            Sz_vals_per_site[j, k] = 0.5 * (n_up_k - n_down_k)\n            \n    probs = np.abs(psi_T)**2\n    n_T = n_vals_per_site @ probs\n    Sz_T = Sz_vals_per_site @ probs\n    \n    # 5. Excess Densities\n    delta_n = n_T - n_init\n    delta_Sz = Sz_T - Sz_init\n    \n    # 6. Find Peak Positions\n    j_charge_peak = j0\n    j_spin_peak = j0\n    \n    search_indices = np.arange(j0 + 1, L)\n    \n    # Charge peak: find max of delta_n if any value is positive on the right\n    if len(search_indices) > 0:\n        excess_charge_right = delta_n[search_indices]\n        if np.any(excess_charge_right > 0):\n            peak_idx_in_slice = np.argmax(excess_charge_right)\n            j_charge_peak = search_indices[peak_idx_in_slice]\n\n    # Spin peak: find max among positive values of delta_Sz on the right\n    if len(search_indices) > 0:\n        excess_spin_right = delta_Sz[search_indices]\n        positive_spin_mask = excess_spin_right > 0\n        if np.any(positive_spin_mask):\n            positive_spin_values = excess_spin_right[positive_spin_mask]\n            positive_spin_indices = search_indices[positive_spin_mask]\n            peak_idx_in_subset = np.argmax(positive_spin_values)\n            j_spin_peak = positive_spin_indices[peak_idx_in_subset]\n\n    # 7. Separation Measure\n    delta_x = float(j_charge_peak - j_spin_peak)\n    return delta_x\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3017411"}]}