{"hands_on_practices": [{"introduction": "复合费米子理论的一个关键预测是拓扑位移（topological shift）$\\mathcal{S}$的存在，它是粒子数与磁通量子数关系中的一个微妙修正。这个位移直接源于磁通附着过程以及复合费米子形成的有效朗道能级结构。这项实践将指导你在霍尔丹球（Haldane sphere）这一研究拓扑性质的理想几何模型上，一步步推导出拓扑位移的表达式，这是一个将微观模型与可观测量联系起来的基础性计算。[@problem_id:2976554]", "problem": "一个二维电子气被限制在一个球面上，球心处有一个强度为 $Q$ 的磁单极子，因此穿过球面的总磁通量子数为 $N_{\\phi} = 2Q$。对于一个填充因子为 $\\nu$ 的不可压缩分数量子霍尔态，球面上的移动（shift）$\\mathcal{S}$ 由以下关系定义\n$$\n2Q \\;=\\; \\nu^{-1} N_{e} \\;-\\; \\mathcal{S},\n$$\n其中 $N_{e}$ 是电子数。考虑一个完全自旋极化的 Jain 复合费米子构造，其中每个电子绑定 $2p$ 个磁通量子（$p \\in \\mathbb{Z}_{\\ge 0}$），并且所得到的复合费米子在简化的有效磁场中填充了 $n$ 个有效朗道能级。在球面上，令 $Q^{\\star}$ 表示复合费米子所感受到的有效磁单极子强度。\n\n仅假设以下标准且经过充分检验的输入条件：\n- 在磁单极子场 $Q^{\\star}$ 中，球面上最低的 $n$ 个朗道能级的简并度为 $g_{k} = 2(Q^{\\star} + k) + 1$，其中 $k = 0, 1, \\dots, n-1$。\n- 球面上的磁通附加根据 $2Q^{\\star} = 2Q - 2p\\,(N_{e} - 1)$ 来修正有效磁通。\n\n完成以下任务：\n1) 从上述输入条件出发，推导填充因子为 $\\nu = \\dfrac{n}{2pn + 1}$ 的 Jain 序列态的移动 $\\mathcal{S}$ 关于 $n$ 和 $p$ 的闭式表达式，不得引用任何关于 $\\mathcal{S}$ 的现有公式。\n2) 使用你的表达式计算 $\\nu = \\dfrac{2}{5}$ 和 $\\nu = \\dfrac{3}{7}$ 状态下 $\\mathcal{S}$ 的具体值。\n3) 简要验证你的结果与已知的 Jain 态的拓扑数据一致，即结果可以分解为一个整数量子霍尔贡献和一个磁通附加贡献。不提供数值比较数据；只需说明你获得的值是否与标准的 Jain 拓扑场论期望相符。\n\n你的最终答案必须是 $\\nu = \\dfrac{2}{5}$ 和 $\\nu = \\dfrac{3}{7}$ 的两个移动值，分别以精确整数形式写出。不包括单位。无需四舍五入。", "solution": "首先对问题进行验证。\n\n### 第一步：提取已知条件\n- 一个二维电子气位于球面上。\n- 球心处有一个强度为 $Q$ 的磁单极子。\n- 总磁通量子数为 $N_{\\phi} = 2Q$。\n- 定义移动 $\\mathcal{S}$ 的关系式是 $2Q = \\nu^{-1} N_{e} - \\mathcal{S}$，其中 $N_e$ 是电子数，$\\nu$ 是填充因子。\n- 对于一个 Jain 复合费米子态，每个电子绑定 $2p$ 个磁通量子，其中 $p \\in \\mathbb{Z}_{\\ge 0}$。\n- 所得的复合费米子（CF）填充了 $n$ 个有效朗道能级。\n- 复合费米子感受到的有效磁单极子强度为 $Q^{\\star}$。\n- 对于磁单极子 $Q^{\\star}$，球面上第 $k$ 个朗道能级的简并度为 $g_{k} = 2(Q^{\\star} + k) + 1$，其中 $k = 0, 1, \\dots, n-1$。\n- 球面上的磁通附加规则是 $2Q^{\\star} = 2Q - 2p(N_{e} - 1)$。\n- Jain 序列的填充因子是 $\\nu = \\dfrac{n}{2pn + 1}$。\n\n### 第二步：使用提取的已知条件进行验证\n该问题具有科学依据，是分数量子霍尔效应凝聚态物理学中的一个标准理论练习。球面上朗道能级（Haldane 球）、Jain 复合费米子构造、拓扑移动的定义以及磁通附加规则都是该领域的既定组成部分。所提供的方程，包括简并度公式 $g_k = 2(Q^{\\star} + k) + 1$ 和磁通附加关系式 $2Q^{\\star} = 2Q - 2p(N_{e} - 1)$，对于这个理论模型是标准且正确的。该问题是适定的，因为它提供了一套自洽的方程组，可以从中代数推导出移动 $\\mathcal{S}$。语言客观而精确。该问题不违反任何无效性标准。\n\n### 第三步：结论与行动\n该问题被认定为有效。将提供完整解答。\n\n### 求解推导\n\n按要求，推导过程分为三部分。\n\n#### 1) 移动 $\\mathcal{S}$ 的推导\n\n总电子数 $N_e$ 必须等于复合费米子填充的 $n$ 个朗道能级中的总可用态数。每个能级 $k$ 的态数由其简并度 $g_k$ 给出。\n\n总电子数是已填充的复合费米子朗道能级简并度之和：\n$$\nN_e = \\sum_{k=0}^{n-1} g_k = \\sum_{k=0}^{n-1} \\left[ 2(Q^{\\star} + k) + 1 \\right]\n$$\n我们可以将求和拆分：\n$$\nN_e = \\sum_{k=0}^{n-1} (2Q^{\\star} + 1) + 2 \\sum_{k=0}^{n-1} k\n$$\n第一项是 $n$ 个相同项的和，第二项是等差数列的和：\n$$\nN_e = n(2Q^{\\star} + 1) + 2 \\left( \\frac{(n-1)n}{2} \\right)\n$$\n$$\nN_e = 2nQ^{\\star} + n + n(n-1) = 2nQ^{\\star} + n + n^2 - n\n$$\n$$\nN_e = 2nQ^{\\star} + n^2\n$$\n这个方程将电子数 $N_e$、有效磁单极子强度 $Q^{\\star}$ 以及已填充的复合费米子能级数 $n$ 联系起来。我们可以重新整理它以表示 $2Q^{\\star}$：\n$$\n2Q^{\\star} = \\frac{N_e - n^2}{n} = \\frac{N_e}{n} - n\n$$\n现在，我们使用给定的磁通附加规则：\n$$\n2Q^{\\star} = 2Q - 2p(N_e - 1)\n$$\n代入我们刚刚推导出的 $2Q^{\\star}$ 的表达式：\n$$\n\\frac{N_e}{n} - n = 2Q - 2p(N_e - 1)\n$$\n我们需要找到移动 $\\mathcal{S}$，它出现在定义关系 $2Q = \\nu^{-1}N_e - \\mathcal{S}$ 中。为此，我们首先解上述方程得到 $2Q$：\n$$\n2Q = \\frac{N_e}{n} - n + 2p(N_e - 1)\n$$\n$$\n2Q = \\frac{N_e}{n} - n + 2pN_e - 2p\n$$\n将与 $N_e$ 成正比的项和常数项分组：\n$$\n2Q = N_e \\left( \\frac{1}{n} + 2p \\right) - (n + 2p)\n$$\n让我们用公分母来表示 $N_e$ 的系数：\n$$\n\\frac{1}{n} + 2p = \\frac{1 + 2pn}{n}\n$$\n因此，$2Q$ 的表达式变为：\n$$\n2Q = N_e \\left( \\frac{1 + 2pn}{n} \\right) - (n + 2p)\n$$\n现在我们将此结果与移动的定义直接比较：\n$$\n2Q = \\nu^{-1} N_e - \\mathcal{S}\n$$\n通过匹配各项，我们可以确定 $\\nu^{-1}$ 和 $\\mathcal{S}$：\n$$\n\\nu^{-1} = \\frac{1 + 2pn}{n} \\quad \\implies \\quad \\nu = \\frac{n}{1 + 2pn}\n$$\n$$\n\\mathcal{S} = n + 2p\n$$\n推导出的填充因子 $\\nu = \\frac{n}{2pn+1}$ 与问题陈述中给出的完全匹配，这成功地验证了推导的一致性。移动的闭式表达式为 $\\mathcal{S} = n + 2p$。\n\n#### 2) 具体移动值的计算\n\n我们使用推导出的公式 $\\mathcal{S} = n + 2p$ 和给定的填充因子来找到整数参数 $n$ 和 $p$。\n\n对于 $\\nu = \\dfrac{2}{5}$：\n我们将其与通用形式 $\\nu = \\dfrac{n}{2pn+1}$ 进行匹配：\n$$\n\\frac{2}{5} = \\frac{n}{2pn+1}\n$$\n通过观察，令分子 $n=2$ 得到：\n$$\n\\frac{2}{5} = \\frac{2}{2p(2)+1} = \\frac{2}{4p+1}\n$$\n比较分母，我们得到 $5 = 4p+1$，即 $4p=4$，所以 $p=1$。\n当 $n=2$ 且 $p=1$ 时，移动为：\n$$\n\\mathcal{S} = n + 2p = 2 + 2(1) = 4\n$$\n\n对于 $\\nu = \\dfrac{3}{7}$：\n我们再次将其与通用形式进行匹配：\n$$\n\\frac{3}{7} = \\frac{n}{2pn+1}\n$$\n通过观察，令分子 $n=3$ 得到：\n$$\n\\frac{3}{7} = \\frac{3}{2p(3)+1} = \\frac{3}{6p+1}\n$$\n比较分母，我们得到 $7 = 6p+1$，即 $6p=6$，所以 $p=1$。\n当 $n=3$ 且 $p=1$ 时，移动为：\n$$\n\\mathcal{S} = n + 2p = 3 + 2(1) = 5\n$$\n\n#### 3) 一致性验证\n\n对于一个层级或复合费米子量子霍尔态，其拓扑移动通常被理解为是可加的。它由准粒子（即复合费米子）的有效整数量子霍尔态的贡献和磁通附加过程本身的贡献组成。\n\n来自相关的 Chern-Simons 场论的标准期望是 $\\mathcal{S} = \\mathcal{S}_{\\text{IQHE}} + \\mathcal{S}_{\\text{flux}}$。对于复合费米子填充 $n$ 个朗道能级的状态，移动的整数量子霍尔部分是 $\\mathcal{S}_{\\text{IQHE}} = n$。对应于每个电子绑定 $2p$ 个磁通量的磁通附加部分贡献了 $\\mathcal{S}_{\\text{flux}} = 2p$。\n因此，期望的移动是 $\\mathcal{S} = n + 2p$。\n\n我们推导出的表达式 $\\mathcal{S} = n + 2p$ 与这一既定的理论期望完全一致。该结果正确地分解为依赖于已填充复合费米子朗道能级数的 $n$ 部分，和依赖于附加磁通量子数的 $2p$ 部分。因此，我们计算出的值（对于 $\\nu=2/5$ 时 $\\mathcal{S}=4$ 和对于 $\\nu=3/7$ 时 $\\mathcal{S}=5$）与已知的 Jain 序列态的拓扑数据是一致的。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4 & 5\n\\end{pmatrix}\n}\n$$", "id": "2976554"}, {"introduction": "我们已经了解了如何构建复合费米子态，但什么使它们成为物理上可实现的基态呢？答案在于电子间的相互作用性质。这项练习将通过霍尔丹赝势（Haldane pseudopotentials）$V_m$的语言来探讨这个问题，赝势是描述最低朗道能级中相互作用的有效参数。你需要基于不同复合费米子态的对关联函数（pair-correlation function）特性，来推断它们在给定相互作用下的能量与稳定性。[@problem_id:2976558]", "problem": "考虑一个自旋极化的二维电子气，它处于强垂直磁场下，被投影到最低朗道能级 (LLL)，并通过一个平移和旋转不变的两体相互作用进行相互作用。在LLL中，这种相互作用完全由其Haldane赝势 $V_m$ 来表征，其中 $m$ 是相对对角动量（对于费米子为奇数）。在复合费米子 (CF) 图像中，每个电子附着 $2p$ 个涡旋（磁通量子）形成复合费米子，这些复合费米子感受到一个减弱的等效磁场，从而产生Jain分数序列 $\\nu = \\dfrac{n}{2pn \\pm 1}$，其中整数 $n,p \\ge 1$。关注 $p=1$ 且带加号的Jain分数，即 $\\nu = 1/3,\\,2/5,\\,3/7,\\dots$，并假设系统位于一个球面上，对于这些试探态具有通常的磁通偏移。\n\n要求您根据上述定义以及Haldane赝势和CF波函数的结构，推断短程相互作用模型——特别是只保留 $V_1$ 或强烈抑制更高阶 $V_m$ 的截断模型——如何改变Jain分数的相对稳定性，并确定哪些赝势最强烈地控制这些分数下的能隙。\n\n下列哪个陈述是正确的？\n\nA. 在一个只保留非零 $V_1$ 的模型中，$\\nu = 1/3$ 处的Laughlin态是一个精确的零能基态，并且是在所有零能态中填充数最高的态；对于 $n \\ge 2$ 的Jain分数，例如 $\\nu = 2/5$ 和 $\\nu = 3/7$，在这种截断相互作用下在能量上是不利的，因为它们的对分布包含相对角动量 $m=1$。\n\nB. $\\nu = 2/5$ 处的能隙完全由 $V_5$ 控制，对 $V_1$ 和 $V_3$ 的敏感度可以忽略不计。\n\nC. 增加比值 $V_3/V_1$（同时保持 $V_1>0$）倾向于增强 $\\nu = 2/5$ 和 $\\nu = 3/7$ 相对于由 $V_1$ 主导的相互作用的稳定性，因为这些态在 $m=1$ 和 $m=3$ 处（对于 $\\nu=3/7$ 还在 $m=5$ 处）具有非零权重；因此 $V_1$ 和 $V_3$ 是对 $p=1$ 的Jain分数影响最大的赝势。\n\nD. 将相互作用截断到仅有 $V_1$ 通常会在 $\\nu = 1/2$ 处产生一个不可压缩态。\n\nE. 当比值 $V_3/V_1$ 减小（相互作用变得更短程）时，Jain分数 $\\nu = 2/5$ 和 $\\nu = 3/7$ 相对于 $\\nu = 1/3$ 会变弱。", "solution": "背景设定是最低朗道能级 (LLL)，其中存在一个平移和旋转不变的两体相互作用，该相互作用完全由Haldane赝势 $V_m$ 描述。一个给定的归一化LLL态的多体能量可以用两粒子相对角动量通道的占据数（对振幅）来表示。具体来说，令 $\\mathcal{G}_m$ 表示找到两个电子处于相对角动量为 $m$ 的状态的概率（每对），则每个粒子的相互作用能可以写为\n$$\n\\frac{E}{N} = \\sum_{m \\in \\{1,3,5,\\dots\\}} V_m\\, \\mathcal{G}_m,\n$$\n其中 $N$ 是粒子数，对于费米子 $m$ 是奇数。这个结果来自于将相互作用投影到LLL中，并在两体相对角动量本征态的完备基上展开；$V_m$ 是相应的矩阵元，$\\mathcal{G}_m$ 是两体投影算子 $P_m$ 的期望值。\n\n对于 $\\nu = 1/q$ （$q$ 为奇数）处的Laughlin态，当任意两个粒子靠近时，其波函数以 $(z_i - z_j)^q$ 的形式趋于零，这意味着对于 $m < q$ 有 $\\mathcal{G}_m = 0$，而 $\\mathcal{G}_q > 0$（以及在多体约束允许的更高 $m$ 值）。特别地，对于 $\\nu=1/3$，有 $\\mathcal{G}_1 = 0$ 和 $\\mathcal{G}_3 > 0$。对于 $p=1$ 且 $n \\ge 2$ 的Jain分数（例如 $\\nu=2/5$ 和 $\\nu=3/7$），复合费米子构造将一个由 $n$ 个填满的复合费米子能级构成的Slater行列式乘以一个Jastrow因子 $\\prod_{i<j}(z_i - z_j)^{2p}$（其中 $p=1$）。相对于Laughlin 1/3态，其短程行为被软化：尽管小 $m$ 处的对振幅被抑制，但它们在 $m=1$ 处并不恒为零；通常有 $\\mathcal{G}_1 > 0$，并且随着 $n$ 的增加，$\\mathcal{G}_3$ 和 $\\mathcal{G}_5$ 也非零且权重增加。这些定性特征已通过对复合费米子试探态的对关联函数和对振幅的显式计算得到证实。\n\n我们现在逐一分析每个陈述。\n\nA. 在只保留非零 $V_1$ 且对 $m \\ge 3$ 有 $V_m = 0$ 的截断模型中，哈密顿量为 $H = V_1 \\sum P_1$。任何满足 $\\mathcal{G}_1 = 0$ 的态都是一个精确的零能本征态。$\\nu=1/3$ 处的Laughlin态具有 $\\mathcal{G}_1 = 0$，因此 $E=0$。此外，在所有 $\\mathcal{G}_1=0$ 的零能态中，密度最高的平移不变基态在 $\\nu=1/3$ 处：这可以从导心（细环面）根构型约束中看出，该约束禁止占据相邻轨道以避免 $m=1$ 的情况，从而导致了密度为 $\\nu=1/3$ 的最密周期性占据模式 $100100\\cdots$。$n \\ge 2$ 的Jain态具有 $\\mathcal{G}_1 > 0$，因此它们在这种截断相互作用下会获得正能量，故而在能量上相对于 $\\nu=1/3$ 是不利的。结论：正确。\n\nB. 对于 $\\nu=2/5$，能量的主要短程贡献来自于 $m=1$ 和 $m=3$ 通道，因为复合费米子态没有消除 $m=1$，并且在 $m=3$ 处有显著的权重。$m=5$ 通道也有贡献，但对于真实的LLL相互作用（如库仑相互作用或适度的短程修正），其贡献通常次于 $m=1$ 和 $m=3$。因此，声称能隙完全由 $V_5$ 控制，而 $V_1$ 和 $V_3$ 可以忽略不计，这与已建立的赝势重要性层级相矛盾；$V_1$ 和 $V_3$ 对 $\\nu=2/5$ 的影响最大。结论：不正确。\n\nC. 考虑一个最初由 $V_1$ 主导的相互作用（$V_1$ 很大，而 $V_3, V_5$ 很小或为零）。在此极限下，$\\nu=1/3$ 更受青睐，因为 $\\mathcal{G}_1=0$，而 $\\nu=2/5$ 和 $\\nu=3/7$ 则因 $\\mathcal{G}_1>0$ 而处于不利地位。在固定的 $V_1$ 下增加 $V_3$ 会使相互作用更接近真实的LLL轮廓（例如库仑相互作用），其中 $V_1$ 和 $V_3$ 之间的平衡提供了稳定 $\\nu=2/5$ 和 $\\nu=3/7$ 所必需的短程排斥结构。由于这些Jain态在 $m=1$ 和 $m=3$ 处（对于 $\\nu=3/7$ 还在 $m=5$ 处）具有非零权重，因此对 $p=1$ 的Jain分数影响最大的赝势确实是 $V_1$ 和 $V_3$（对于 $\\nu=3/7$，$V_5$ 也变得相关）。虽然增加 $V_3$ 也会增加这些态的绝对能量（因为 $\\mathcal{G}_3>0$），但关于相对稳定性的关键点在于由 $V_1$ 主导的相互作用所引起的区分效应：通过将 $V_3$ 提升到实际值来减弱这种区分效应，会增强 $\\nu=2/5$ 和 $\\nu=3/7$ 相对于纯 $V_1$ 极限的鲁棒性。结论：正确。\n\nD. 在 $\\nu=1/2$ 处，著名的复合费米子费米海对于类库仑的LLL相互作用是一个可压缩态。一个只保留非零 $V_1$ 的截断模型通常不会将 $\\nu=1/2$ 转变为不可压缩态；$V_1$ 母哈密顿量筛选出消除了 $m=1$ 对的零能态，其中密度最高的平移不变态在 $\\nu=1/3$ 处。在仅有 $V_1$ 的截断中，没有机制可以在 $\\nu=1/2$ 处产生能隙。结论：不正确。\n\nE. 减小 $V_3/V_1$ 的比值（使相互作用变得更尖锐的短程）会增加 $m=1$ 通道在决定能量时的相对权重。由于 $\\nu=2/5$ 和 $\\nu=3/7$ 具有 $\\mathcal{G}_1>0$，在这种短程主导下，它们的能量增长比 $\\nu=1/3$ 的能量更快，因为 $\\nu=1/3$ 具有 $\\mathcal{G}_1=0$ 并且在纯 $V_1$ 极限下受到保护。因此，随着 $V_3/V_1$ 的减小，$\\nu=2/5$ 和 $\\nu=3/7$ 的相对稳定性相较于 $\\nu=1/3$ 会减弱。这一趋势在研究有限层厚度或有效减小 $V_3$ 相对于 $V_1$ 的修正相互作用中是众所周知的。结论：正确。\n\n总而言之，对 $p=1$ 的Jain分数影响最大的赝势是 $V_1$ 和 $V_3$（随着 $n$ 的增长，$V_5$ 的相关性也增加），而截断到短程的 $V_1$ 模型会强烈地偏爱 $\\nu=1/3$，同时抑制更高 $n$ 的Jain分数。", "answer": "$$\\boxed{ACE}$$", "id": "2976558"}, {"introduction": "拓扑相的一个深刻特征是体-边对应（bulk-edge correspondence）：有能隙体态的性质决定了无能隙边缘激发的性质，而复合费米子理论对此对应关系做出了精确的预测。这项计算实践将引导你通过比较两种看似不同的计算来验证这一原理。你需要计算一个微观“排斥准则”模型（轨道纠缠谱）的低能态计数，并将其与边缘有效共形场论（CFT）的计数进行比较。通过编写程序来检验这种对应关系，你将亲身体验凝聚态物理学中一个强大而现代的概念，并体会到纠缠与拓扑之间的深刻联系。[@problem_id:2976521]", "problem": "考虑一个置于强磁场中的二维电子系统，其形成一个由复合费米子描述的分数量子霍尔态。2个单位的磁通束缚将电子转变为复合费米子，这些复合费米子填满了 $n$ 个有效朗道能级，从而在填充因子为 $\\nu = n/(2n+1)$ 处产生一个 Jain 序列态。在朗道规范下的圆柱体上，单粒子轨道可用一个整数指标 $j \\in \\{0,1,\\dots,L_A-1\\}$ 来标记，这些轨道属于一个长度为 $L_A$ 的连续轨道子集 $A$。设 $N_A$ 表示子集 $A$ 中的粒子数，并将 $A$ 中的占据组态定义为一个二元序列 $\\{n_j\\}$，其中 $n_j \\in \\{0,1\\}$。\n\n细环面极限为 Jain 态提供了一条经过充分检验的广义排除法则：在任意 $r = 2n+1$ 个连续轨道的区块中，最多只能有 $k = n$ 个被占据的轨道。对于给定的 $(n,L_A,N_A)$，将 $A$ 中的最小左对齐组态定义为满足此法则且使 $A$ 中总轨道动量 $K_A = \\sum_{j=0}^{L_A-1} j\\, n_j$ 最小化的组态。设此最小组态的基线动量为 $K_0$，并定义 $\\Delta K = K_A - K_0$。在固定 $\\Delta K$ 下的轨道纠缠谱计数，是指 $A$ 中满足广义排除法则、恰好包含 $N_A$ 个粒子、且产生指定 $\\Delta K$ 值的不同组态 $\\{n_j\\}$ 的数量。\n\n复合费米子的边缘物理由边缘共形场论（CFT）中的 $n$ 个无能隙手性玻色子模式所描述。在总动量移动为 $\\Delta K$ 的情况下，边缘激发的简并度可以通过将 $\\Delta K$ 分配到 $n$ 个独立的整数振子塔中来推导得出，分配时需满足每个振子模式的占据数为非负整数。这为边缘理论的简并度提供了一个明确的组合计数方法。\n\n你的任务是实现一个程序，该程序对每个测试用例执行以下步骤：\n1. 计算 $A$ 中的最小左对齐组态及其相关的基线动量 $K_0$。\n2. 枚举 $A$ 中所有满足广义排除法则且恰好有 $N_A$ 个粒子的有效组态，计算每个组态的 $K_A$，并对每个 $\\Delta K = K_A - K_0$ 值，统计其对应的组态数量。\n3. 通过计算以 $n$ 个独立玻色子振子塔的激发来实现总动量移动 $\\Delta K$ 的方式数量，来计算在相同的 $\\Delta K$ 值下 $n$ 个手性玻色子模式的边缘 CFT 简并度。\n4. 对 $\\Delta K = 0,1,\\dots,M_{\\mathrm{check}}$ 比较这两种计数结果。其中，每个测试用例的 $M_{\\mathrm{check}}$ 定义为 $\\min(M_{\\mathrm{target}}, S)$，而“松弛量” $S$ 是最小左对齐组态中最后一个被占据轨道右侧的空轨道数量，即 $S = (L_A - 1) - j_{\\mathrm{last}}$。这一选择确保了来自 $A$ 右边界的有限尺寸效应不会污染低 $\\Delta K$ 的比较区间。\n5. 对每个测试用例，输出一个布尔值，该值指示对于所有 $\\Delta K \\in \\{0,1,\\dots,M_{\\mathrm{check}}\\}$，轨道纠缠谱计数是否与边缘 CFT 简并度匹配。\n\n你的程序应该生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，`[true,false,true]`），并使用编程语言的小写布尔值。\n\n使用以下测试套件，它涵盖了不同的复合费米子扇区和有限尺寸体系：\n- 测试用例 1（理想路径，Jain 序列中的 Laughlin 极限）：$(n,L_A,N_A,M_{\\mathrm{target}}) = (1,24,6,6)$。\n- 测试用例 2（双分量复合费米子）：$(n,L_A,N_A,M_{\\mathrm{target}}) = (2,25,8,5)$。\n- 测试用例 3（三分量复合费米子）：$(n,L_A,N_A,M_{\\mathrm{target}}) = (3,28,10,4)$。\n- 测试用例 4（边界敏感体系，具有较小的 $L_A$）：$(n,L_A,N_A,M_{\\mathrm{target}}) = (2,15,6,3)$。\n\n所有数学量必须如上定义，其中 $\\Delta K$ 被视为整数。不需要物理单位。最终输出必须是一个布尔值列表，每个测试用例对应一个布尔值，并采用指定的单行格式。", "solution": "该问题被评估为 **有效的**。这是一个定义明确的计算问题，植根于分数量子霍尔效应（FQHE）的既定理论框架。其中涉及的概念——Jain 序列态、复合费米子、磁通束缚、广义排除原理，以及轨道纠缠谱（OES）与描述边缘激发的共形场论（CFT）之间的对应关系——都是现代凝聚态物理学中的标准和核心课题。该问题提供了一套清晰、自洽且可形式化的规则和数值参数，从而可以得出一个唯一且有意义的解。数值验证 OES-CFT 对应关系是该领域一个标准且富有洞察力的练习。\n\n该解决方案通过执行两个独立的计数程序来计算低能激发的数量，并对结果进行比较。\n\n### 1. 基于微观模型的轨道纠缠谱（OES）计数\n\n这种方法直接使用系统的微观规则来对允许的多体组态进行计数。\n\n**a. 广义排除原理**\n问题指出，在细环面极限下，填充因子为 $\\nu = \\frac{n}{2n+1}$ 的 Jain 态具有一个“广义排除法则”的特征：在任意 $r = 2n+1$ 个轨道的连续区块中，最多只能有 $k=n$ 个粒子。这些组态通常被称为“容许”态或“压缩”态。\n\n**b. 基线组态和动量 ($K_0$)**\n用于计算动量移动的参考态是最小左对齐组态。这是 $L_A$ 个轨道中 $N_A$ 个粒子的容许组态，它使总轨道动量 $K_A = \\sum_{j} j\\,n_j$ 最小化，其中 $n_j \\in \\{0, 1\\}$ 是轨道 $j$ 的占据数。该状态通过一个贪心算法构建：从轨道 $j=0$ 开始，当且仅当放置粒子不违反排除法则时，我们才放置一个粒子。我们继续此过程，直到所有 $N_A$ 个粒子都被放置。该状态的动量就是基线动量 $K_0$。\n\n**c. 激发的枚举**\n激发态是所有其他具有相同粒子数 $N_A$ 的容许组态。为了找到这些组态，我们采用了一种递归回溯（深度优先搜索）算法。该算法系统地构建 $N_A$ 个粒子在 $L_A$ 个轨道上的所有可能放置方式，并剪除任何违反广义排除法则的搜索分支。\n\n对于找到的每个有效组态，计算其总动量 $K_A$，并计算相对于基线的动量移动 $\\Delta K = K_A - K_0$。产生相同 $\\Delta K$ 的不同组态的数量即为 OES 简并度，我们将其表示为 $C_{\\text{OES}}(\\Delta K)$。此计数对 $\\Delta K$ 执行，直至达到指定的最大值 $M_{\\text{check}}$。\n\n### 2. 边缘共形场论（CFT）简并度计数\n\n这种方法使用有效场论来描述 FQHE 液体边缘的低能物理。\n\n**a. 边缘模式结构**\n对于参数为 $n$ 的 Jain 态，其边缘理论由 $n$ 个独立的、无能隙的、手性的玻色子模式描述。该系统中的激发是通过向这些模式增加动量来创建的。在总动量移动为 $\\Delta K$ 时，状态的简并度就是将该动量分配到 $n$ 个玻色子模式中的方式数量。\n\n**b. 生成函数与划分函数**\n单个手性玻色子模式的生成函数是整数划分的生成函数 $P(q) = \\sum_{k=0}^{\\infty} p(k)q^k = \\prod_{m=1}^{\\infty} \\frac{1}{1-q^m}$。$n$ 个独立且相同的模式的总生成函数是此单模式生成函数的 $n$ 次方：\n$$G_n(q) = [P(q)]^n = \\left( \\prod_{m=1}^{\\infty} \\frac{1}{1-q^m} \\right)^n$$\n动量移动为 $\\Delta K$ 时的状态数，表示为 $C_{\\text{CFT}}(\\Delta K)$，是 $G_n(q)$ 级数展开中 $q^{\\Delta K}$ 项的系数。\n\n**c. 计算算法**\n系数 $C_{\\text{CFT}}(\\Delta K)$ 按如下方式计算：\n1.  首先，我们计算 $P(q)$ 的系数，即整数划分数 $p(k)$。这些系数可以使用欧拉五边形数定理高效地计算，该定理给出了以下递推关系：\n    $$p(k) = \\sum_{j=1}^{\\infty} (-1)^{j-1} \\left( p\\left(k - \\frac{j(3j-1)}{2}\\right) + p\\left(k - \\frac{j(3j+1)}{2}\\right) \\right)$$\n2.  接下来，我们求 $[P(q)]^n$ 的系数。这可以通过将系数序列重复与自身卷积来完成。如果 $C_1(k) = p(k)$，则 $n$ 个模式的系数由序列 $C_n(q)$ 给出，该序列通过计算 $C_i(q) = C_{i-1}(q) \\cdot P(q)$ (其中 $i=2, \\dots, n$) 获得。在计算上，这对应于系数数组的离散卷积。\n\n### 3. 比较\n\n最后一步是对于从 $0$ 到 $M_{\\text{check}}$ 的每个整数动量移动 $\\Delta K$，比较两组计数结果 $C_{\\text{OES}}(\\Delta K)$ 和 $C_{\\text{CFT}}(\\Delta K)$。选择 $M_{\\text{check}} = \\min(M_{\\mathrm{target}}, S)$ 这个值是为了确保比较在有限尺寸效应（由松弛量 $S$ 量化）最小的区间内进行。松弛量 $S = (L_A - 1) - j_{\\text{last}}$ 代表最小组态右边缘可用的空轨道数量，为低能激发在受到 $j=L_A-1$ 处边界影响之前提供了“空间”的度量。如果在此范围内的所有 $\\Delta K$ 的计数都匹配，则该测试用例的对应关系得到验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom bisect import bisect_left, bisect_right\n\ndef solve():\n    \"\"\"\n    Main function to run the validation for all test cases.\n    \"\"\"\n    test_cases = [\n        # (n, L_A, N_A, M_target)\n        (1, 24, 6, 6),  # Test case 1\n        (2, 25, 8, 5),  # Test case 2\n        (3, 28, 10, 4), # Test case 3\n        (2, 15, 6, 3),  # Test case 4\n    ]\n\n    results = []\n    \n    # Pre-calculate partitions up to a global max M_target to be safe\n    max_m_target = max(tc[3] for tc in test_cases)\n    partitions_p = _calculate_partitions(max_m_target + 10) # a bit of buffer\n\n    for n, L_A, N_A, M_target in test_cases:\n        # Step 1: Compute minimal config and baseline momentum K0\n        min_config_indices, K0 = _get_minimal_config(n, L_A, N_A)\n        \n        if min_config_indices is None:\n            # This should not happen for the given valid test cases\n            results.append(False)\n            continue\n            \n        # Step 2: Define the comparison range M_check\n        j_last = min_config_indices[-1]\n        S = (L_A - 1) - j_last\n        M_check = min(M_target, S)\n\n        # Step 3: Enumerate all configurations and get OES counts\n        oes_counts = _get_oes_counts(n, L_A, N_A, K0, M_check)\n        \n        # Step 4: Compute CFT multiplicities\n        cft_counts = _get_cft_counts(n, M_check, partitions_p)\n        \n        # Step 5: Compare OES and CFT counts\n        is_match = True\n        for dK in range(M_check + 1):\n            oes_count = oes_counts.get(dK, 0)\n            cft_count = cft_counts[dK]\n            if oes_count != cft_count:\n                is_match = False\n                break\n        results.append(is_match)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\ndef _get_minimal_config(n, L_A, N_A):\n    \"\"\"\n    Constructs the minimal left-justified configuration using a greedy algorithm.\n    Returns the indices of occupied orbitals and the total momentum K0.\n    \"\"\"\n    r = 2 * n + 1\n    k_max = n\n    \n    config_indices = []\n    for j in range(L_A):\n        # Try to place a particle at orbital j\n        # Check against exclusion rule for all windows containing j\n        is_valid_placement = True\n        # Windows containing j start from max(0, j-r+1) to j\n        for win_start in range(max(0, j - r + 1), j + 1):\n            win_end = win_start + r - 1\n            # Count existing particles in the window + the new one\n            count = 1 + sum(1 for p_idx in config_indices if win_start <= p_idx <= win_end)\n            if count > k_max:\n                is_valid_placement = False\n                break\n        \n        if is_valid_placement:\n            config_indices.append(j)\n            if len(config_indices) == N_A:\n                break\n    \n    if len(config_indices) < N_A:\n        return None, None\n        \n    K0 = sum(config_indices)\n    return config_indices, K0\n\ndef _get_oes_counts(n, L_A, N_A, K0, M_check):\n    \"\"\"\n    Enumerates all valid configurations and counts them based on momentum shift.\n    \"\"\"\n    oes_counts = {}\n    \n    for config_indices in _generate_valid_configs(n, L_A, N_A):\n        K_A = sum(config_indices)\n        dK = K_A - K0\n        if 0 <= dK <= M_check:\n            oes_counts[dK] = oes_counts.get(dK, 0) + 1\n            \n    return oes_counts\n\ndef _is_valid_for_new_particle(indices, n):\n    \"\"\"\n    Checks if adding the last particle in `indices` maintains the exclusion rule.\n    Assumes `indices` is sorted.\n    \"\"\"\n    if not indices:\n        return True\n    \n    new_particle_idx = indices[-1]\n    r = 2 * n + 1\n    k_max = n\n\n    for win_start in range(max(0, new_particle_idx - r + 1), new_particle_idx + 1):\n        win_end = win_start + r - 1\n        \n        # Count particles in indices that fall in [win_start, win_end]\n        # using binary search for efficiency.\n        left = bisect_left(indices, win_start)\n        right = bisect_right(indices, win_end)\n        \n        if (right - left) > k_max:\n            return False\n    return True\n\ndef _generate_valid_configs_recursive(start_orbital, particles_left, L_A, n, current_indices):\n    \"\"\"Helper for the recursive generator.\"\"\"\n    if particles_left == 0:\n        yield list(current_indices)\n        return\n\n    # Optimization: if not enough orbitals are left to place remaining particles.\n    if start_orbital + particles_left > L_A:\n        return\n    \n    # Iterate through possible positions for the next particle\n    for j in range(start_orbital, L_A - particles_left + 1):\n        current_indices.append(j)\n        # Check rule only for the newly added particle\n        if _is_valid_for_new_particle(current_indices, n):\n            yield from _generate_valid_configs_recursive(j + 1, particles_left - 1, L_A, n, current_indices)\n        current_indices.pop()  # Backtrack\n\ndef _generate_valid_configs(n, L_A, N_A):\n    \"\"\"\n    A generator that yields all valid configurations of N_A particles.\n    \"\"\"\n    yield from _generate_valid_configs_recursive(0, N_A, L_A, n, [])\n\ndef _calculate_partitions(max_k):\n    \"\"\"\n    Calculates partition numbers p(k) up to max_k using Euler's pentagonal number theorem.\n    \"\"\"\n    p = np.zeros(max_k + 1, dtype=np.int64)\n    p[0] = 1\n    \n    for k in range(1, max_k + 1):\n        val = 0\n        for i in range(1, k + 1):\n            sign = -1 if (i - 1) % 2 else 1\n            \n            p1_idx = k - (i * (3 * i - 1) // 2)\n            if p1_idx >= 0:\n                val += sign * p[p1_idx]\n            \n            p2_idx = k - (i * (3 * i + 1) // 2)\n            if p2_idx >= 0:\n                val += sign * p[p2_idx]\n            \n            if p1_idx < 0 and p2_idx < 0:\n                break\n        p[k] = val\n    return p\n\ndef _get_cft_counts(n, M_check, partitions_p):\n    \"\"\"\n    Calculates CFT multiplicities for n modes up to momentum M_check.\n    \"\"\"\n    if n == 0:\n        counts = np.zeros(M_check + 1, dtype=np.int64)\n        if M_check >= 0:\n            counts[0] = 1\n        return counts\n\n    # Ensure pre-computed partitions are sufficient\n    p = partitions_p[:M_check + 1]\n    \n    # Start with n=1 mode counts\n    current_counts = p.copy()\n    \n    # Convolve for additional modes\n    for _ in range(1, n):\n        current_counts = np.convolve(current_counts, p)[:M_check + 1]\n        \n    return current_counts.astype(np.int64)\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2976521"}]}