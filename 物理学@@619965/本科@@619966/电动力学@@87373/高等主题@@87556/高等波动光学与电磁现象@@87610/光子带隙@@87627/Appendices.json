{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式就是亲手实践。我们的第一个练习将从最基本的一维光子晶体——分布式布拉格反射器（Distributed Bragg Reflector）开始。这个练习旨在通过计算其基本反射带（即阻带）的中心波长，来巩固由周期性结构中相长干涉形成带隙的核心概念。通过这个直接的计算 [@problem_id:1596452]，你将对设计特定波长的光学滤波器和反射镜有一个基本的认识。", "problem": "一位材料科学家正在设计一种分布式布拉格反射镜 (DBR)，它是许多光学器件（如激光器和滤波器）中的关键组件。该 DBR 由两种不同的非磁性、无损耗介电材料交替堆叠而成的周期性结构构成，并沉积在衬底上。对于这个具体的设计，第一种材料是五氧化二钽，其折射率为 $n_1 = 2.15$，每层物理厚度为 $d_1 = 78.0$ nm。第二种材料是二氧化硅，其折射率为 $n_2 = 1.46$，层厚度为 $d_2 = 115.0$ nm。\n\n假设光垂直入射到该结构的表面，计算一阶光子禁带的中心波长。该波长对应于来自周期性各层的反射光发生最大相长干涉时的波长。\n\n以纳米 (nm) 为单位表示你的答案，并四舍五入到三位有效数字。", "solution": "对于由两种非磁性、无损耗介电层构成的一维周期性堆叠，在垂直入射的情况下，其一阶光子禁带的中心（布拉格）波长由一个周期的光学厚度等于半个波长的条件决定。这给出了布拉格条件\n$$\n\\lambda_{0}=\\frac{2\\left(n_{1}d_{1}+n_{2}d_{2}\\right)}{m},\n$$\n其中 $m$ 是衍射级数。对于一阶， $m=1$ ，因此\n$$\n\\lambda_{0}=2\\left(n_{1}d_{1}+n_{2}d_{2}\\right).\n$$\n代入给定值，\n$$\nn_{1}d_{1}=2.15\\times 78.0\\ \\text{nm}=167.7\\ \\text{nm},\n$$\n$$\nn_{2}d_{2}=1.46\\times 115.0\\ \\text{nm}=167.9\\ \\text{nm},\n$$\n所以\n$$\nn_{1}d_{1}+n_{2}d_{2}=167.7\\ \\text{nm}+167.9\\ \\text{nm}=335.6\\ \\text{nm}.\n$$\n因此，\n$$\n\\lambda_{0}=2\\times 335.6\\ \\text{nm}=671.2\\ \\text{nm}.\n$$\n四舍五入到三位有效数字得到 $671$ nm。", "answer": "$$\\boxed{671}$$", "id": "1596452"}, {"introduction": "掌握了如何计算静态带隙后，让我们探索一个更强大、更普适的原理：如何主动调控带隙。这个练习利用了麦克斯韦方程组的标度不变性（scaling laws），一个深刻的物理性质，来预测几何尺寸和材料折射率的变化将如何移动带隙的位置。这个思想实验 [@problem_id:1596477] 将你的理解从特定公式提升到普适物理定律的层面，展示了设计可定制光子器件的强大能力。", "problem": "一个研究团队正在开发一种用作光学滤波器的三维光子晶体。初始原型由一个周期性结构组成，该结构由磷化镓 (GaP)（折射率 $n_{\\text{GaP}} = 3.31$）构成，并浸没在一种折射率为 $n_{\\text{fluid},1} = 1.655$ 的特殊光学液体中。研究发现，该原型的带隙中心波长为 $\\lambda_1 = 1300$ nm。\n\n为了满足新的规格要求，该团队设计了第二个器件。首先，他们将整个周期性结构按 $s = 0.9$ 的比例因子进行几何缩小。其次，他们替换了组成材料。GaP 被折射率为 $n_{\\text{Si}} = 3.48$ 的硅 (Si) 所取代，而原始光学液体则被一种折射率为 $n_{\\text{fluid},2} = 1.74$ 的新液体所取代。您可以假设在所关心的波长范围内折射率是恒定的，并且周围介质是非磁性的。\n\n计算这个新器件的光子带隙的新中心波长 $\\lambda_2$。请用纳米（nm）表示您的答案，并四舍五入到三位有效数字。", "solution": "该问题要求计算在几何缩放和材料变更后，光子带隙的新中心波长。解决方案在于应用麦克斯韦方程组的标度不变性。\n\n光子晶体的本征模式是电磁波方程的解，该方程可以用磁场 $\\mathbf{H}$ 表示为：\n$$\n\\nabla \\times \\left( \\frac{1}{\\epsilon(\\mathbf{r})} \\nabla \\times \\mathbf{H}(\\mathbf{r}) \\right) = \\left( \\frac{\\omega}{c} \\right)^2 \\mathbf{H}(\\mathbf{r})\n$$\n其中 $\\epsilon(\\mathbf{r}) = n(\\mathbf{r})^2$ 是与位置相关的介电常数，$n(\\mathbf{r})$ 是折射率分布，$\\omega$ 是模式的角频率，$c$ 是真空中的光速。这个方程有两个重要的标度不变性。\n\n**1. 几何缩放**\n如果我们将所有空间维度按因子 $s$ 进行缩放（即 $\\mathbf{r} \\to \\mathbf{r'} = s\\mathbf{r}$），同时保持材料不变，则新的折射率分布为 $n'(\\mathbf{r'}) = n(\\mathbf{r})$。新的本征频率 $\\omega'$ 和波长 $\\lambda'$ 与原始值的关系为：\n$$\n\\omega' = \\frac{\\omega}{s} \\quad \\implies \\quad \\lambda' = s \\lambda\n$$\n因此，将结构按因子 $s$ 进行几何缩放，会导致谐振波长也按相同的因子 $s$ 进行缩放。\n\n**2. 折射率缩放**\n如果我们保持几何结构不变，但将整个结构中的所有折射率按一个恒定因子 $k$ 进行缩放（即 $n'(\\mathbf{r}) = k \\cdot n(\\mathbf{r})$），则新的本征频率 $\\omega'$ 和波长 $\\lambda'$ 与原始值的关系为：\n$$\n\\omega' = \\frac{\\omega}{k} \\quad \\implies \\quad \\lambda' = k \\lambda\n$$\n这是因为将 $n'(\\mathbf{r})=k \\cdot n(\\mathbf{r})$ 代入波动方程，会得到一个与原问题等价的本征值问题，只是 $\\omega$ 被替换为 $\\omega/k$。\n\n**将缩放定律应用于本问题**\n\n我们可以依次处理这两个变换——几何缩放和材料变更。\n\n**步骤 1：应用几何缩放。**\n原始结构被按因子 $s = 0.9$ 缩小。设此缩放后的中间波长为 $\\lambda_{\\text{inter}}$。根据几何缩放定律：\n$$\n\\lambda_{\\text{inter}} = s \\cdot \\lambda_1 = 0.9 \\cdot \\lambda_1\n$$\n\n**步骤 2：应用材料变更（折射率缩放）。**\n接下来，更换材料。初始材料是 GaP ($n_{\\text{GaP}} = 3.31$) 和液体 1 ($n_{\\text{fluid},1} = 1.655$)。新材料是 Si ($n_{\\text{Si}} = 3.48$) 和液体 2 ($n_{\\text{fluid},2} = 1.74$)。要应用折射率缩放定律，所有组成材料的折射率必须按同一个公共因子 $k$ 进行缩放。我们来检查一下这个条件是否满足。\n\n我们计算固体组分的缩放因子：\n$$\nk_{\\text{solid}} = \\frac{n_{\\text{Si}}}{n_{\\text{GaP}}} = \\frac{3.48}{3.31}\n$$\n以及液体组分的缩放因子：\n$$\nk_{\\text{fluid}} = \\frac{n_{\\text{fluid},2}}{n_{\\text{fluid},1}} = \\frac{1.74}{1.655}\n$$\n让我们计算这些比值。我们注意到 $1.74 = 0.5 \\times 3.48$ 并且 $1.655 = 0.5 \\times 3.31$。因此：\n$$\nk_{\\text{fluid}} = \\frac{0.5 \\times 3.48}{0.5 \\times 3.31} = \\frac{3.48}{3.31} = k_{\\text{solid}}\n$$\n由于两种材料的折射率都按相同的因子缩放，因此可以应用折射率缩放定律。公共缩放因子为：\n$$\nk = \\frac{3.48}{3.31}\n$$\n将折射率缩放定律应用于中间波长 $\\lambda_{\\text{inter}}$，得到最终波长 $\\lambda_2$：\n$$\n\\lambda_2 = k \\cdot \\lambda_{\\text{inter}}\n$$\n\n**步骤 3：结合两种变换并计算最终答案。**\n结合两个步骤的结果：\n$$\n\\lambda_2 = k \\cdot (s \\cdot \\lambda_1) = s \\cdot k \\cdot \\lambda_1\n$$\n现在我们代入给定的数值：\n$$\n\\lambda_2 = 0.9 \\times \\left( \\frac{3.48}{3.31} \\right) \\times 1300 \\, \\text{nm}\n$$\n$$\n\\lambda_2 \\approx 0.9 \\times 1.0513595 \\times 1300 \\, \\text{nm}\n$$\n$$\n\\lambda_2 \\approx 1230.08... \\, \\text{nm}\n$$\n问题要求答案四舍五入到三位有效数字。\n$$\n\\lambda_2 \\approx 1230 \\, \\text{nm}\n$$", "answer": "$$\\boxed{1230}$$", "id": "1596477"}, {"introduction": "前面的练习主要关注带隙的中心，而本练习将带你进入一个更全面的视角：计算完整的光子能带结构。通过编写代码实现传输矩阵方法（transfer matrix method），你将能精确确定任意一维光子晶体所有带隙的边界。这个高级的计算实践 [@problem_id:2387580] 是连接理论与工程应用的关键桥梁，它让你掌握一个分析和设计复杂光学叠层的强大工具。", "problem": "一个一维光子晶体由一个晶胞在正入射条件下无限周期性重复构成，该晶胞包含两层均匀、各向同性、无损耗、非磁性的介电层。设第 1 层的相对介电常数为 $\\varepsilon_{r1}$，厚度为 $d_1$（单位：米）；第 2 层的相对介电常数为 $\\varepsilon_{r2}$，厚度为 $d_2$（单位：米）。假设真空磁导率 $\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{N/A^2}$，真空光速 $c = 299{,}792{,}458\\,\\mathrm{m/s}$，以及真空介电常数 $\\varepsilon_0 = 1/(\\mu_0 c^2)\\,\\mathrm{F/m}$。第 $j$ 层的折射率为 $n_j = \\sqrt{\\varepsilon_{rj}}$。晶胞按第 1 层后接第 2 层的顺序排列，周期为 $a = d_1 + d_2$。考虑角频率为 $\\omega = 2\\pi f$ 的时谐场在正入射情况下，并要求存在与周期性结构相符的非平凡 Bloch 波。对于每个频率 $f$（单位：赫兹），确定是否存在传播的 Bloch 解；不存在传播 Bloch 解的频率范围构成光子带隙。对于下方的每个测试用例，请在给定的频率范围 $[f_{\\min}, f_{\\max}]$ 内，识别出构成光子带隙的所有频率区间，并将每个区间以双元素列表 $[f_\\mathrm{lower}, f_\\mathrm{upper}]$（单位：赫兹）的形式报告。所有报告的频率均以赫兹 (Hz) 为单位，并四舍五入到最接近的 $1.0\\times 10^{10}\\,\\mathrm{Hz}$。如果在指定范围内没有光子带隙，则该测试用例报告一个空列表。\n\n测试套件（每个元组为 $(\\varepsilon_{r1}, \\varepsilon_{r2}, d_1, d_2, f_{\\min}, f_{\\max})$，其中厚度单位为米，频率单位为赫兹）：\n- 用例 1（高对比度，中心频率附近的四分之一波长设计）：$\\left(2.25,\\ 12.25,\\ \\frac{c}{4\\,\\sqrt{2.25}\\,2.0\\times 10^{14}},\\ \\frac{c}{4\\,\\sqrt{12.25}\\,2.0\\times 10^{14}},\\ 1.0\\times 10^{14},\\ 4.0\\times 10^{14}\\right)$。\n- 用例 2（均匀介质极限）：$\\left(4.0,\\ 4.0,\\ 2.0\\times 10^{-7},\\ 3.0\\times 10^{-7},\\ 1.0\\times 10^{14},\\ 3.0\\times 10^{14}\\right)$。\n- 用例 3（低对比度，中心频率附近的四分之一波长设计）：$\\left(2.25,\\ 2.56,\\ \\frac{c}{4\\,\\sqrt{2.25}\\,3.0\\times 10^{14}},\\ \\frac{c}{4\\,\\sqrt{2.56}\\,3.0\\times 10^{14}},\\ 1.5\\times 10^{14},\\ 4.5\\times 10^{14}\\right)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。第 $i$ 个元素对应第 $i$ 个测试用例，并且其本身必须是一个列表，包含为该测试用例找到的光子带隙。每个带隙均按上述舍入规则，以双元素列表 $[f_\\mathrm{lower}, f_\\mathrm{upper}]$（单位：赫兹）的形式报告。例如，第一个用例有两个带隙而第二个用例没有带隙的有效输出结构如下所示：$[[f_{1,\\mathrm{low}},f_{1,\\mathrm{high}}],[f_{2,\\mathrm{low}},f_{2,\\mathrm{high}}]],[]$。程序必须将三个测试用例的结果汇总到一行中，例如：$[[\\dots],[\\dots,\\dots]],[],[[\\dots]]]$。不应打印任何额外文本。", "solution": "问题在于，确定一维无限光子晶体在正入射情况下的光子带隙所对应的频率区间。该问题是适定的且科学上合理的，其依据是分析周期性介电结构的标准传输矩阵法。\n\n光子带隙由周期性结构中无法存在传播性 Bloch 波的频率组成。在周期为 $a$ 的一维周期性结构中，存在 Bloch 波矢为 $K$ 的传播性 Bloch 波的条件由色散关系给出，该关系可使用传输矩阵法推导。\n\n设晶胞由两层介质构成，其折射率分别为 $n_1 = \\sqrt{\\varepsilon_{r1}}$ 和 $n_2 = \\sqrt{\\varepsilon_{r2}}$，厚度分别为 $d_1$ 和 $d_2$。周期为 $a = d_1 + d_2$。对于角频率为 $\\omega = 2\\pi f$ 且正入射的时谐电磁波，其在分层结构中的传播可以通过一个 $2 \\times 2$ 的传输矩阵来描述。该矩阵将一个晶胞起点的电场和磁场的切向分量 $(E, H)$ 与该晶胞终点的场关联起来。\n\n一个周期（$a=d_1+d_2$）的传输矩阵 $U_{cell}$ 是各层矩阵的乘积，$U_{cell} = U_2 U_1$，其中 $U_j$ 是第 $j$ 层的正向传播传输矩阵。对于厚度为 $d_j$、折射率为 $n_j$ 的单层，其矩阵为：\n$$\nU_j = \\begin{pmatrix} \\cos(k_j d_j) & -i\\eta_j \\sin(k_j d_j) \\\\ -i\\frac{1}{\\eta_j} \\sin(k_j d_j) & \\cos(k_j d_j) \\end{pmatrix}\n$$\n此处，$k_j = n_j \\omega/c = 2\\pi f n_j / c$ 是该层中的波数，$\\eta_j = \\eta_0/n_j$ 是波阻抗，其中 $\\eta_0 = \\sqrt{\\mu_0/\\varepsilon_0}$ 是自由空间的阻抗。由于问题涉及的是无损耗、非磁性介质，此公式是适用的。各层矩阵的乘积给出了晶胞的传输矩阵：$U_{cell} = U_2 U_1$。\n\n根据 Bloch 定理，对于周期系统中的一个本征模，一个晶胞终点的场必须等于起点的场乘以一个相位因子 $e^{iKa}$，其中 $K$ 是 Bloch 波矢。这意味着 $e^{iKa}$ 必须是晶胞传输矩阵 $U_{cell}$ 的一个特征值。对于一个行列式为 1 的 $2 \\times 2$ 矩阵（此处即是这种情况，因为 $\\det(U_j)=1$），其特征值 $\\lambda$ 由特征方程 $\\lambda^2 - \\text{Tr}(U_{cell})\\lambda + 1 = 0$ 给出。\n\n特征值为 $e^{\\pm iKa}$，它们的和为 $2\\cos(Ka) = \\text{Tr}(U_{cell})$。这导出了色散关系：\n$$\n\\cos(Ka) = \\frac{1}{2} \\text{Tr}(U_{cell})\n$$\n只有当右侧的值在 $[-1, 1]$ 范围内时，传播波（实数 $K$）才存在。对于频率 $|\\frac{1}{2} \\text{Tr}(U_{cell})| > 1$ 的情况，对应于复数 $K$，代表了无法无限传播的倏逝波。这些频率范围就是光子带隙。\n\n我们来计算 $U_{cell} = U_2 U_1$ 的迹：\n$$\n\\text{Tr}(U_{cell}) = 2\\cos(k_1d_1)\\cos(k_2d_2) - \\left(\\frac{\\eta_2}{\\eta_1} + \\frac{\\eta_1}{\\eta_2}\\right)\\sin(k_1d_1)\\sin(k_2d_2)\n$$\n由于 $\\eta_j = \\eta_0/n_j$，比值 $\\eta_2/\\eta_1 = n_1/n_2$。代入此式，我们定义一个函数 $H(f)$：\n$$\nH(f) = \\frac{1}{2}\\text{Tr}(U_{cell}) = \\cos(k_1d_1)\\cos(k_2d_2) - \\frac{1}{2}\\left(\\frac{n_1}{n_2} + \\frac{n_2}{n_1}\\right)\\sin(k_1d_1)\\sin(k_2d_2)\n$$\n光子带隙是满足 $|H(f)| > 1$ 的频率区间。\n\n寻找这些带隙的算法步骤如下：\n1.  对于每个测试用例，定义参数 $\\varepsilon_{r1}, \\varepsilon_{r2}, d_1, d_2, f_{\\min}, f_{\\max}$。折射率为 $n_j = \\sqrt{\\varepsilon_{rj}}$。光速 $c$ 给定为 $299{,}792{,}458\\,\\mathrm{m/s}$。一个特殊情况是当 $n_1=n_2$ 时，这对应于均匀介质。在这种情况下，项 $\\frac{1}{2}(\\frac{n_1}{n_2} + \\frac{n_2}{n_1}) = 1$，并且 $H(f)$ 简化为 $\\cos(k_1(d_1+d_2))$。由于余弦函数的值总是在 $-1$ 和 $1$ 之间，因此不存在带隙。\n2.  带边是满足 $|H(f)| = 1$（即 $H(f) = 1$ 或 $H(f) = -1$）的频率 $f$。\n3.  我们以数值方式找到这些带边频率。将频率范围 $[f_{\\min}, f_{\\max}]$ 离散化为一个精细的网格。我们在此网格上搜索函数 $H(f)-1$ 或 $H(f)+1$ 变号的区间，这表明存在一个根。\n4.  `scipy.optimize.brentq` 函数用于在这些包围区间内找到每个根的精确位置。\n5.  所有找到的根，连同 $f_{\\min}$ 和 $f_{\\max}$，构成一组边界点，将频率范围进行划分。\n6.  对于两个连续边界点之间的每个子区间，我们通过计算该子区间中点的 $H(f)$ 值来检查它是否位于带隙内。如果 $|H(f_{mid})| > 1$，则该子区间是带隙的一部分。\n7.  收集得到的带隙区间。将形成单个连续带隙的相邻区间合并。\n8.  每个最终带隙区间的下限和上限按规定四舍五入到最接近的 $1.0\\times 10^{10}\\,\\mathrm{Hz}$。\n9.  每个测试用例的最终结果是这些经过舍入的带隙区间的列表。如果未找到带隙，则报告一个空列表。\n\n这种数值方法对于任何参数集都是通用且稳健的。对于四分之一波长堆栈的特殊情况（用例 1 和 3），存在解析解，可用于验证数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for photonic band gaps in a 1D photonic crystal for given test cases.\n\n    The method is based on the transfer matrix formalism for 1D periodic systems.\n    A band gap exists for frequencies where the magnitude of the half-trace of\n    the unit cell transfer matrix exceeds 1. This condition is checked across the\n    specified frequency range for each test case.\n    \"\"\"\n\n    C_LIGHT = 299792458.0  # Speed of light in vacuum, m/s\n\n    def setup_test_cases():\n        \"\"\"Pre-calculates parameters for test cases to avoid using eval().\"\"\"\n        \n        # Case 1: High-contrast quarter-wave stack\n        c1_eps1, c1_eps2 = 2.25, 12.25\n        c1_n1, c1_n2 = np.sqrt(c1_eps1), np.sqrt(c1_eps2)\n        c1_fc = 2.0e14\n        c1_d1 = C_LIGHT / (4.0 * c1_n1 * c1_fc)\n        c1_d2 = C_LIGHT / (4.0 * c1_n2 * c1_fc)\n        c1_fmin, c1_fmax = 1.0e14, 4.0e14\n        case1 = (c1_eps1, c1_eps2, c1_d1, c1_d2, c1_fmin, c1_fmax)\n\n        # Case 2: Homogeneous medium\n        c2_eps1, c2_eps2 = 4.0, 4.0\n        c2_d1, c2_d2 = 2.0e-7, 3.0e-7\n        c2_fmin, c2_fmax = 1.0e14, 3.0e14\n        case2 = (c2_eps1, c2_eps2, c2_d1, c2_d2, c2_fmin, c2_fmax)\n\n        # Case 3: Low-contrast quarter-wave stack\n        c3_eps1, c3_eps2 = 2.25, 2.56\n        c3_n1, c3_n2 = np.sqrt(c3_eps1), np.sqrt(c3_eps2)\n        c3_fc = 3.0e14\n        c3_d1 = C_LIGHT / (4.0 * c3_n1 * c3_fc)\n        c3_d2 = C_LIGHT / (4.0 * c3_n2 * c3_fc)\n        c3_fmin, c3_fmax = 1.5e14, 4.5e14\n        case3 = (c3_eps1, c3_eps2, c3_d1, c3_d2, c3_fmin, c3_fmax)\n        \n        return [case1, case2, case3]\n\n    test_cases = setup_test_cases()\n    all_results = []\n    \n    for case in test_cases:\n        eps1, eps2, d1, d2, f_min, f_max = case\n        \n        n1 = np.sqrt(eps1)\n        n2 = np.sqrt(eps2)\n        \n        # Handle the homogeneous case where no contrast means no band gaps\n        if np.isclose(n1, n2):\n            all_results.append([])\n            continue\n\n        def H_func(f):\n            \"\"\"Calculates the half-trace of the transfer matrix.\"\"\"\n            f = np.asarray(f)\n            k1 = n1 * 2.0 * np.pi * f / C_LIGHT\n            k2 = n2 * 2.0 * np.pi * f / C_LIGHT\n            \n            cos_k1d1 = np.cos(k1 * d1)\n            cos_k2d2 = np.cos(k2 * d2)\n            sin_k1d1 = np.sin(k1 * d1)\n            sin_k2d2 = np.sin(k2 * d2)\n            \n            ratio_term = 0.5 * (n1 / n2 + n2 / n1)\n            \n            return cos_k1d1 * cos_k2d2 - ratio_term * sin_k1d1 * sin_k2d2\n\n        # Find roots of H(f) = +/- 1, which are the band edges\n        boundaries = {f_min, f_max}\n        num_points = 20000\n        freqs = np.linspace(f_min, f_max, num_points)\n        h_vals = H_func(freqs)\n        \n        h_plus_1 = h_vals + 1.0\n        h_minus_1 = h_vals - 1.0\n\n        for i in range(num_points - 1):\n            if h_plus_1[i] * h_plus_1[i+1] < 0:\n                try:\n                    root = brentq(lambda f: H_func(f) + 1.0, freqs[i], freqs[i+1])\n                    boundaries.add(root)\n                except ValueError:\n                    pass\n            if h_minus_1[i] * h_minus_1[i+1] < 0:\n                try:\n                    root = brentq(lambda f: H_func(f) - 1.0, freqs[i], freqs[i+1])\n                    boundaries.add(root)\n                except ValueError:\n                    pass\n        \n        sorted_boundaries = sorted(list(boundaries))\n        \n        gaps = []\n        rounding_precision = 1.0e10\n        \n        for i in range(len(sorted_boundaries) - 1):\n            f_low = sorted_boundaries[i]\n            f_high = sorted_boundaries[i+1]\n            \n            if f_high - f_low < 1e-9 * (f_max - f_min):\n                continue\n\n            mid_f = (f_low + f_high) / 2.0\n            h_mid = H_func(mid_f)\n            \n            # Check if the interval is a band gap\n            if h_mid > 1.0 or h_mid < -1.0:\n                f_low_rounded = round(f_low / rounding_precision) * rounding_precision\n                f_high_rounded = round(f_high / rounding_precision) * rounding_precision\n                \n                if f_low_rounded < f_high_rounded:\n                    # Merge with previous gap if adjacent\n                    if gaps and np.isclose(gaps[-1][1], f_low_rounded):\n                        gaps[-1][1] = f_high_rounded\n                    else:\n                        gaps.append([f_low_rounded, f_high_rounded])\n\n        all_results.append(gaps)\n\n    # Format the final output string as specified\n    output_str_parts = []\n    for res in all_results:\n        # Custom string formatting to avoid extra spaces and ensure correct structure\n        if not res:\n            output_str_parts.append(\"[]\")\n        else:\n            gap_strs = [f\"[{g[0]},{g[1]}]\" for g in res]\n            output_str_parts.append(f\"[{','.join(gap_strs)}]\")\n            \n    print(f\"[{','.join(output_str_parts)}]\")\n\nsolve()\n```", "id": "2387580"}]}