{"hands_on_practices": [{"introduction": "在直接应用复杂的诺伊曼公式之前，通过其基本定义来建立物理直觉至关重要。互感的基本思想是，一个电路中的电流会在空间中产生磁场，从而在另一个电路中产生磁通量。这个练习 [@problem_id:1594773] 旨在通过一个简化的理想模型来阐明这一核心概念。通过利用大环路在中心区域产生的磁场可近似为匀场的假设（$r \\ll R$），我们可以轻松计算出穿过小环路的磁通量，进而推导出互感系数，深刻理解几何构型如何影响电路间的耦合。", "problem": "一个半径为 $R$ 的大圆形线圈和一个半径为 $r$ 的极小圆形线圈同心放置，且满足条件 $r \\ll R$。小线圈的平面发生倾斜，与大线圈的平面形成一个角度 $\\theta$。你的目标是确定这对线圈之间的互感 $M$。请用给定的参数 $R$、$r$、$\\theta$ 及真空磁导率 $\\mu_0$ 推导出 $M$ 的表达式。", "solution": "互感的定义为 $M=\\frac{\\Phi_{21}}{I_{1}}$，其中 $\\Phi_{21}$ 是由线圈1（大线圈）中的电流 $I_{1}$ 穿过线圈2（小线圈）的磁通量。\n\n根据毕奥–萨伐尔（Biot–Savart）定律的结果，一个半径为 $R$、载有电流 $I_{1}$ 的圆形线圈在其中心产生的磁场为：\n$$\nB=\\frac{\\mu_{0} I_{1}}{2R}\n$$\n当 $r \\ll R$ 时，小线圈所处区域的磁场可近似视为均匀场，其值等于在共同中心处的值。穿过小线圈的磁通量为：\n$$\n\\Phi_{21}=\\int \\mathbf{B}\\cdot d\\mathbf{a}=B A_{2}\\cos\\theta,\n$$\n其中 $A_{2}=\\pi r^{2}$ 是小线圈的面积，$\\theta$ 是小线圈的法线与磁场 $\\mathbf{B}$ 方向（即大线圈的法线方向）之间的夹角。代入 $B$ 和 $A_{2}$ 可得：\n$$\n\\Phi_{21}=\\left(\\frac{\\mu_{0} I_{1}}{2R}\\right)\\left(\\pi r^{2}\\right)\\cos\\theta\n$$\n因此，互感为：\n$$\nM=\\frac{\\Phi_{21}}{I_{1}}=\\frac{\\mu_{0}\\pi r^{2}}{2R}\\cos\\theta\n$$\n此结果在 $r \\ll R$ 的近似下为首项。", "answer": "$$\\boxed{\\frac{\\mu_{0}\\pi r^{2}}{2R}\\cos\\theta}$$", "id": "1594773"}, {"introduction": "掌握了互感的基本概念后，我们将直接应用诺伊曼公式进行更复杂的解析计算。这个练习 [@problem_id:27135] 要求我们计算两个同轴但不共面的圆弧之间的互感。虽然对于任意距离，这个问题极为复杂，但它引导我们使用一种在理论物理中至关重要的技巧——在极限情况下（即远距离分离，$h \\gg R$）进行分析。通过对诺伊曼公式中的积分项进行近似展开，我们可以得到一个简洁的解析解，这个过程能极大地锻炼我们处理矢量积分和应用近似方法的能力。", "problem": "考虑两个相同的细导线圆弧，每个半径为 $R$，对角为 $\\alpha$。这两个圆弧共轴排列且相互平行，相距为 $h$。假设这两个圆弧以 z 轴为中心，分别位于平面 $z=0$ 和 $z=h$ 中。假设两个圆弧中的电流沿相同的方位角方向流动。\n\n两个回路 $\\mathcal{C}_1$ 和 $\\mathcal{C}_2$ 之间的互感 $M$ 由 Neumann 公式给出：\n$$\nM = \\frac{\\mu_0}{4\\pi} \\oint_{\\mathcal{C}_1} \\oint_{\\mathcal{C}_2} \\frac{d\\mathbf{l}_1 \\cdot d\\mathbf{l}_2}{|\\mathbf{r}_1 - \\mathbf{r}_2|}\n$$\n其中 $d\\mathbf{l}_1$ 和 $d\\mathbf{l}_2$ 是沿着导线的无穷小线元，而 $|\\mathbf{r}_1 - \\mathbf{r}_2|$ 是它们之间的距离。\n\n推导在两个圆弧大间距极限下（即 $h \\gg R$）的互感表达式。你的最终答案应该是按小参数 $R/h$ 展开后的首个非零项。你应该只考虑两个指定圆弧之间的相互作用，忽略任何可能为它们馈电的导线所产生的磁场。", "solution": "我们从两个载流回路 $\\mathcal{C}_1$ 和 $\\mathcal{C}_2$ 之间的互感 Neumann 公式开始，\n$$\nM=\\frac{\\mu_0}{4\\pi}\\oint_{\\mathcal{C}_1}\\oint_{\\mathcal{C}_2}\\frac{d\\mathbf{l}_1\\cdot d\\mathbf{l}_2}{|\\mathbf{r}_1-\\mathbf{r}_2|}\\,.\n$$\n用角度 $\\phi_1, \\phi_2 \\in [0, \\alpha]$ 将两个半径为 $R$、对角为 $\\alpha$ 的圆弧参数化：\n$$\n\\mathbf{r}_1=R(\\cos\\phi_1,\\sin\\phi_1,0),\\quad d\\mathbf{l}_1=R(-\\sin\\phi_1,\\cos\\phi_1,0)\\,d\\phi_1,\n$$\n$$\n\\mathbf{r}_2=R(\\cos\\phi_2,\\sin\\phi_2,h),\\quad d\\mathbf{l}_2=R(-\\sin\\phi_2,\\cos\\phi_2,0)\\,d\\phi_2.\n$$\n于是\n$$\nd\\mathbf{l}_1\\cdot d\\mathbf{l}_2\n=R^2[\\sin\\phi_1\\sin\\phi_2+\\cos\\phi_1\\cos\\phi_2]\\,d\\phi_1d\\phi_2\n=R^2\\cos(\\phi_1-\\phi_2)\\,d\\phi_1d\\phi_2,\n$$\n且\n$$\n|\\mathbf{r}_1-\\mathbf{r}_2|=\\sqrt{2R^2[1-\\cos(\\phi_1-\\phi_2)]+h^2}\n=h\\sqrt{1+\\frac{2R^2}{h^2}[1-\\cos\\Delta]}\\,,\n$$\n其中 $\\Delta = \\phi_1 - \\phi_2$。对于 $h \\gg R$ 的情况，展开\n$$\n\\frac1{|\\mathbf{r}_1-\\mathbf{r}_2|}\n=\\frac1h\\left[1-\\frac{R^2[1-\\cos\\Delta]}{h^2}+\\mathcal{O}\\left(\\frac{R^4}{h^4}\\right)\\right].\n$$\n因此，$M$ 的首项为\n$$\nM\\approx\\frac{\\mu_0R^2}{4\\pi h}\n\\int_0^\\alpha\\!\\int_0^\\alpha\\cos(\\phi_1-\\phi_2)\\,d\\phi_1d\\phi_2\n=\\frac{\\mu_0R^2}{4\\pi h}\\,2\\bigl[1-\\cos\\alpha\\bigr]\n=\\frac{\\mu_0R^2}{\\pi h}\\sin^2\\!\\frac\\alpha2\\,.\n$$\n所有更高阶的修正项都是 $\\mathcal{O}(R^4/h^3)$ 级别的，因此是次要的。", "answer": "$$\\boxed{\\frac{\\mu_0 R^2}{\\pi h}\\sin^2\\!\\Bigl(\\frac{\\alpha}{2}\\Bigr)}$$", "id": "27135"}, {"introduction": "在现实世界的工程和物理问题中，电路的几何构型往往非常复杂，不具备理想的对称性，导致解析积分无法求解。此时，数值方法便显示出其强大的威力。这个终极练习 [@problem_id:2419641] 将理论与实践相结合，要求你编写程序来数值求解任意位置和方向的两个环形线圈之间的互感。通过将诺伊曼公式这个双重线积分转化为一个可计算的数值问题，你将学会如何解决那些无法用纸笔解决的真实电磁学问题，为你打开计算物理学的大门。", "problem": "给定自由空间中的两个细的闭合圆形线圈，它们在三维欧几里得空间中被建模为曲线 $\\mathcal{C}_1$ 和 $\\mathcal{C}_2$。每个线圈 $i \\in \\{1,2\\}$ 由其半径 $R_i$（单位：米）、中心位置矢量 $\\mathbf{c}_i$（单位：米）以及指示其平面方向的单位法向量 $\\mathbf{n}_i$ 来描述。在国际单位制（SI）中，磁常数 $\\mu_0$ 等于 $4\\pi \\times 10^{-7}$ 亨利每米。两个线圈之间的互感 $M$（单位：亨利）由第一性原理出发，通过 Neumann 公式定义：\n$$\nM \\;=\\; \\frac{\\mu_0}{4\\pi}\\;\\oint_{\\mathcal{C}_1}\\;\\oint_{\\mathcal{C}_2}\\;\\frac{\\mathrm{d}\\boldsymbol{\\ell}_1 \\cdot \\mathrm{d}\\boldsymbol{\\ell}_2}{\\|\\mathbf{r}_1 - \\mathbf{r}_2\\|}\\,,\n$$\n其中 $\\mathbf{r}_1 \\in \\mathcal{C}_1$，$\\mathbf{r}_2 \\in \\mathcal{C}_2$，$\\mathrm{d}\\boldsymbol{\\ell}_1$ 和 $\\mathrm{d}\\boldsymbol{\\ell}_2$ 是沿着线圈的微分线元。将每个线圈建模为理想的圆形细丝。使用的任何角度参数都必须以弧度为单位进行解释。\n\n编写一个程序，对以下每个测试用例进行 $M$ 的数值计算。所有输入数据中，几何量的单位均为米，且需严格按照给定值处理。您必须假设各处均为自由空间，并且不存在磁性材料。最终答案必须以亨利为单位，表示为浮点数。\n\n测试套件（按给定顺序处理）：\n\n- 用例 $1$（一般情况，非共轴、非共面，中等间距）：\n  - $R_1 = 0.10$, $\\mathbf{c}_1 = (0.00,\\,0.00,\\,0.00)$, $\\mathbf{n}_1 = (0,\\,0,\\,1)$。\n  - $R_2 = 0.08$, $\\mathbf{c}_2 = (0.05,\\,0.02,\\,0.03)$, $\\mathbf{n}_2 = \\frac{1}{\\sqrt{3}}(1,\\,1,\\,1)$。\n\n- 用例 $2$（大间距，弱耦合）：\n  - $R_1 = 0.20$, $\\mathbf{c}_1 = (0.20,\\,-0.10,\\,0.00)$, $\\mathbf{n}_1 = (0,\\,1,\\,0)$。\n  - $R_2 = 0.15$, $\\mathbf{c}_2 = (1.00,\\,-0.50,\\,0.80)$, $\\mathbf{n}_2 = (0,\\,0,\\,1)$。\n\n- 用例 $3$（近似相交的朝向，为避免相交设置微小偏移）：\n  - $R_1 = 0.10$, $\\mathbf{c}_1 = (0.00,\\,0.00,\\,0.00)$, $\\mathbf{n}_1 = (0,\\,0,\\,1)$。\n  - $R_2 = 0.10$, $\\mathbf{c}_2 = (0.005,\\,0.00,\\,0.00)$, $\\mathbf{n}_2 = (0,\\,1,\\,0)$。\n\n- 用例 $4$（任意倾斜朝向和偏移）：\n  - $R_1 = 0.12$, $\\mathbf{c}_1 = (-0.03,\\,0.04,\\,0.02)$, $\\mathbf{n}_1 = \\frac{1}{\\sqrt{(0.2)^2+(0.9)^2+(0.4)^2}}(0.2,\\,0.9,\\,0.4)$。\n  - $R_2 = 0.07$, $\\mathbf{c}_2 = (0.06,\\,-0.02,\\,0.05)$, $\\mathbf{n}_2 = \\frac{1}{\\sqrt{(-0.3)^2+(0.1)^2+(0.95)^2}}(-0.3,\\,0.1,\\,0.95)$。\n\n要求：\n\n- 将每个线圈视为一个完美的圆形，位于与 $\\mathbf{n}_i$ 正交的平面内，以 $\\mathbf{c}_i$ 为中心，半径为 $R_i$。\n- 您必须通过对角度参数在区间 $[0, 2\\pi]$（角度以弧度为单位）上积分来计算 $M$ 的定义式中的双重线积分，每个角度参数遍历其对应的圆周一次。\n- 输出单位：亨利。每个结果必须是浮点数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的四个数值结果列表，结果顺序与用例 $1$ 至 $4$ 的顺序一致，例如 $[m_1,m_2,m_3,m_4]$。每个 $m_i$ 必须采用科学记数法格式，并至少包含 $10$ 位有效数字（例如，$1.234567890\\times 10^{-6}$ 应打印为 $1.234567890e-06$）。输出行中不允许出现额外的文本或空格。", "solution": "所述问题在科学上是合理的，内容自洽且适定。这是一个计算电磁学中的标准问题，其基础是静磁学的基本原理。所有必要数据均已提供，问题客观且无歧义。因此，将提供一个解决方案。\n\n两个闭合电流回路 $\\mathcal{C}_1$ 和 $\\mathcal{C}_2$ 之间的互感 $M$ 由 Neumann 公式定义：\n$$\nM \\;=\\; \\frac{\\mu_0}{4\\pi}\\;\\oint_{\\mathcal{C}_1}\\;\\oint_{\\mathcal{C}_2}\\;\\frac{\\mathrm{d}\\boldsymbol{\\ell}_1 \\cdot \\mathrm{d}\\boldsymbol{\\ell}_2}{\\|\\mathbf{r}_1 - \\mathbf{r}_2\\|}\\\n$$\n在此，$\\mu_0 = 4\\pi \\times 10^{-7}$ 亨利每米是磁常数，这使得在国际单位制中，前置因子简化为 $\\frac{\\mu_0}{4\\pi} = 10^{-7}$。矢量 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 分别是指导向线圈 $\\mathcal{C}_1$ 和 $\\mathcal{C}_2$ 上点的位置矢量，而 $\\mathrm{d}\\boldsymbol{\\ell}_1$、$\\mathrm{d}\\boldsymbol{\\ell}_2$ 是沿着这些线圈的微分矢量线元。\n\n为了计算这个双重线积分，我们必须首先对圆形线圈进行参数化。三维空间中的一个圆 $\\mathcal{C}_i$ 由其中心 $\\mathbf{c}_i$、半径 $R_i$ 和其所在平面的单位法向量 $\\mathbf{n}_i$ 指定。为了描述圆上的点，建立一个局部右手系标准正交基 $(\\mathbf{u}_i, \\mathbf{v}_i, \\mathbf{n}_i)$ 会很方便，其中矢量 $\\mathbf{u}_i$ 和 $\\mathbf{v}_i$ 张成包含该圆的平面。\n\n对于给定的 $\\mathbf{n}_i$，构建这些基矢量的一个稳健的方法如下：\n$1$. 选择一个不与 $\\mathbf{n}_i$ 共线的辅助矢量 $\\mathbf{t}$。一个标准的选择是 $\\mathbf{t} = (0, 0, 1)$。如果 $\\mathbf{n}_i$ 与 $z$ 轴平行（即 $\\mathbf{n}_i = (0, 0, \\pm 1)$），则必须使用一个不同的矢量，如 $\\mathbf{t} = (1, 0, 0)$，以确保叉积不为零。\n$2$. 第一个平面基矢量 $\\mathbf{u}_i$ 通过计算 $\\mathbf{n}_i$ 和 $\\mathbf{t}$ 的叉积并将结果单位化来获得：\n$$\n\\mathbf{u}_i = \\frac{\\mathbf{n}_i \\times \\mathbf{t}}{\\|\\mathbf{n}_i \\times \\mathbf{t}\\|}\n$$\n$3$. 然后通过 $\\mathbf{n}_i$ 和 $\\mathbf{u}_i$ 的叉积找到第二个平面基矢量 $\\mathbf{v}_i$，这样就构成了一套完整的标准正交基：\n$$\n\\mathbf{v}_i = \\mathbf{n}_i \\times \\mathbf{u}_i\n$$\n有了这个基，圆 $\\mathcal{C}_i$ 上的任意点 $\\mathbf{r}_i(\\theta_i)$ 都可以通过角度变量 $\\theta_i \\in [0, 2\\pi]$ 进行参数化：\n$$\n\\mathbf{r}_i(\\theta_i) = \\mathbf{c}_i + R_i (\\cos(\\theta_i) \\mathbf{u}_i + \\sin(\\theta_i) \\mathbf{v}_i)\n$$\n微分线元 $\\mathrm{d}\\boldsymbol{\\ell}_i$ 通过对 $\\mathbf{r}_i(\\theta_i)$ 关于其参数 $\\theta_i$ 求导得到：\n$$\n\\mathrm{d}\\boldsymbol{\\ell}_i = \\frac{\\mathrm{d}\\mathbf{r}_i}{\\mathrm{d}\\theta_i} \\mathrm{d}\\theta_i = R_i (-\\sin(\\theta_i) \\mathbf{u}_i + \\cos(\\theta_i) \\mathbf{v}_i) \\mathrm{d}\\theta_i\n$$\n将两个线圈（使用下标 1 和 2）的这些表达式代入 Neumann 公式，双重线积分就转换为关于参数 $\\theta_1$ 和 $\\theta_2$ 的二重定积分：\n$$\nM = \\frac{\\mu_0}{4\\pi} \\int_{0}^{2\\pi} \\int_{0}^{2\\pi} \\frac{\\left(\\frac{\\mathrm{d}\\mathbf{r}_1(\\theta_1)}{\\mathrm{d}\\theta_1}\\right) \\cdot \\left(\\frac{\\mathrm{d}\\mathbf{r}_2(\\theta_2)}{\\mathrm{d}\\theta_2}\\right)}{\\|\\mathbf{r}_1(\\theta_1) - \\mathbf{r}_2(\\theta_2)\\|} \\mathrm{d}\\theta_1 \\mathrm{d}\\theta_2\n$$\n被积函数的分子是两个切向量的点积：\n$$\n\\left(\\frac{\\mathrm{d}\\mathbf{r}_1}{\\mathrm{d}\\theta_1}\\right) \\cdot \\left(\\frac{\\mathrm{d}\\mathbf{r}_2}{\\mathrm{d}\\theta_2}\\right) = R_1 R_2 \\left( -\\sin(\\theta_1)\\mathbf{u}_1 + \\cos(\\theta_1)\\mathbf{v}_1 \\right) \\cdot \\left(-\\sin(\\theta_2)\\mathbf{u}_2 + \\cos(\\theta_2)\\mathbf{v}_2 \\right)\n$$\n分母是线圈上两点之间分离矢量的模长：\n$$\n\\|\\mathbf{r}_1(\\theta_1) - \\mathbf{r}_2(\\theta_2)\\| = \\|(\\mathbf{c}_1 - \\mathbf{c}_2) + R_1(\\cos(\\theta_1)\\mathbf{u}_1 + \\sin(\\theta_1)\\mathbf{v}_1) - R_2(\\cos(\\theta_2)\\mathbf{u}_2 + \\sin(\\theta_2)\\mathbf{v}_2)\\|\n$$\n该积分通常没有闭式解，必须进行数值计算。程序将使用标准的数值积分库来实现此计算。对于每个测试用例，算法流程如下：\n$1$. 定义线圈参数（$R_i, \\mathbf{c}_i, \\mathbf{n}_i$）。对所有给定的法向量进行单位化，确保它们是单位矢量。\n$2$. 预先计算每个线圈的标准正交基矢量 $(\\mathbf{u}_i, \\mathbf{v}_i)$。\n$3$. 定义一个被积函数，它接受积分变量 $(\\theta_2, \\theta_1)$ 并返回核函数的值。这个参数顺序与 `scipy` 中数值积分程序的要求一致，该程序会首先计算内层积分。\n$4$. 使用 `scipy.integrate.dblquad` 计算在定义域 $[0, 2\\pi] \\times [0, 2\\pi]$ 上的二重积分。设置高精度容差以确保准确性，特别是对于线圈彼此靠近的情况。\n$5$. 将积分结果乘以常数因子 $\\frac{\\mu_0}{4\\pi} = 10^{-7}$，得出最终的互感 $M$，单位为亨利。\n\n该过程被系统地应用于所有给定的测试用例，并且结果按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Calculates the mutual inductance between two circular loops for several test cases.\n    \"\"\"\n    \n    # Magnetic constant mu_0 / (4*pi) in H/m\n    MU0_OVER_4PI = 1e-7\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General non-coaxial, non-coplanar, moderate separation\n        {\n            \"R1\": 0.10, \"c1\": (0.00, 0.00, 0.00), \"n1\": (0.0, 0.0, 1.0),\n            \"R2\": 0.08, \"c2\": (0.05, 0.02, 0.03), \"n2\": (1.0, 1.0, 1.0),\n        },\n        # Case 2: Large separation, small coupling\n        {\n            \"R1\": 0.20, \"c1\": (0.20, -0.10, 0.00), \"n1\": (0.0, 1.0, 0.0),\n            \"R2\": 0.15, \"c2\": (1.00, -0.50, 0.80), \"n2\": (0.0, 0.0, 1.0),\n        },\n        # Case 3: Nearly intersecting orientation\n        {\n            \"R1\": 0.10, \"c1\": (0.00, 0.00, 0.00), \"n1\": (0.0, 0.0, 1.0),\n            \"R2\": 0.10, \"c2\": (0.005, 0.00, 0.00), \"n2\": (0.0, 1.0, 0.0),\n        },\n        # Case 4: Arbitrary oblique orientations and offsets\n        {\n            \"R1\": 0.12, \"c1\": (-0.03, 0.04, 0.02), \"n1\": (0.2, 0.9, 0.4),\n            \"R2\": 0.07, \"c2\": (0.06, -0.02, 0.05), \"n2\": (-0.3, 0.1, 0.95),\n        },\n    ]\n\n    results = []\n\n    def setup_loop_basis(n_vec):\n        \"\"\"\n        Given a normal vector n, creates an orthonormal basis (u, v, n).\n        \"\"\"\n        n = np.array(n_vec, dtype=float)\n        n /= np.linalg.norm(n)\n        \n        # Choose an auxiliary vector t not parallel to n\n        if np.abs(np.dot(n, [0.0, 0.0, 1.0])) > 1.0 - 1e-9:\n            # n is parallel to the z-axis, so choose t along the x-axis\n            t = np.array([1.0, 0.0, 0.0])\n        else:\n            # n is not parallel to the z-axis, so choose t along the z-axis\n            t = np.array([0.0, 0.0, 1.0])\n            \n        u = np.cross(n, t)\n        u /= np.linalg.norm(u)\n        \n        v = np.cross(n, u)\n        return u, v\n\n    for case in test_cases:\n        # Unpack parameters\n        R1, c1, n1 = case[\"R1\"], np.array(case[\"c1\"]), np.array(case[\"n1\"])\n        R2, c2, n2 = case[\"R2\"], np.array(case[\"c2\"]), np.array(case[\"n2\"])\n        \n        # Normalize normal vectors\n        n1 /= np.linalg.norm(n1)\n        n2 /= np.linalg.norm(n2)\n        \n        # Setup local coordinate systems for loops\n        u1, v1 = setup_loop_basis(n1)\n        u2, v2 = setup_loop_basis(n2)\n        \n        # Define the integrand for dblquad\n        def integrand(theta2, theta1):\n            # Position vectors on each loop\n            r1 = c1 + R1 * (np.cos(theta1) * u1 + np.sin(theta1) * v1)\n            r2 = c2 + R2 * (np.cos(theta2) * u2 + np.sin(theta2) * v2)\n            \n            # Differential line elements (tangent vectors scaled by R)\n            dl1_dth1 = R1 * (-np.sin(theta1) * u1 + np.cos(theta1) * v1)\n            dl2_dth2 = R2 * (-np.sin(theta2) * u2 + np.cos(theta2) * v2)\n            \n            # Numerator of the Neumann formula kernel\n            numerator = np.dot(dl1_dth1, dl2_dth2)\n            \n            # Denominator of the Neumann formula kernel\n            distance = np.linalg.norm(r1 - r2)\n            \n            # The problem setup ensures distance is never zero\n            return numerator / distance\n\n        # Perform numerical integration over theta1 from 0 to 2*pi and theta2 from 0 to 2*pi\n        integral_val, _ = dblquad(\n            integrand,\n            0, 2 * np.pi,  # Outer integral limits (theta1)\n            0, 2 * np.pi,  # Inner integral limits (theta2)\n            epsabs=1e-12, epsrel=1e-12 # Strict tolerance for high accuracy\n        )\n        \n        mutual_inductance = MU0_OVER_4PI * integral_val\n        results.append(mutual_inductance)\n\n    # Format the final output string as required\n    output_str = f\"[{','.join(f'{r:.15e}' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2419641"}]}