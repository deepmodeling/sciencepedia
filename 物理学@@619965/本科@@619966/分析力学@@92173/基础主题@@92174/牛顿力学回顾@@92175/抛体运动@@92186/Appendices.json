{"hands_on_practices": [{"introduction": "掌握了理想抛体运动的基本方程后，一个重要的下一步是培养对这些方程如何运作的物理直觉。这个练习将引导你探索运动学参数之间的比例关系，通过分析初始速度 $v_0$ 和引力加速度 $g$ 的变化如何影响飞行时间、最大高度和水平射程。这不仅是求解数字，更是在培养一种核心能力——深刻理解并预测物理系统的行为。[@problem_id:2210018]", "problem": "在一项名为“Aero-Sphere”的未来体育项目中，运动员在一个引力场可调节的行星上通过发射抛射体进行比赛。一名运动员从地面发射一个球体。在第一次试验中，发射设置为：初速度 $v_0$，与水平方向的发射角 $\\theta$，以及重力加速度 $g_0$。这次试验得到的飞行时间为 $T_0$，最大高度为 $H_0$，水平射程为 $R_0$。\n\n在第二次试验中，参数被修改。发射速度增加到 $v_1 = 3v_0$，而重力加速度减小到 $g_1 = \\frac{1}{3}g_0$。发射角 $\\theta$ 保持不变。设新的飞行时间、最大高度和水平射程分别为 $T_1$、$H_1$ 和 $R_1$。\n\n假设地面是水平的且空气阻力可以忽略不计，确定这些运动学量的缩放因子。具体来说，求出三个比率：$\\frac{T_1}{T_0}$、$\\frac{H_1}{H_0}$ 和 $\\frac{R_1}{R_0}$。将这三个数值按指定顺序呈现在一个行矩阵中。", "solution": "设抛射体以初速度 $v$、发射角 $\\theta$ 从水平地面发射，在恒定重力加速度 $g$ 下运动，忽略空气阻力。将速度分解为分量：水平分量 $v\\cos\\theta$ 和竖直分量 $v\\sin\\theta$。竖直位置为\n$$\ny(t)=v\\sin\\theta\\, t-\\frac{1}{2}gt^{2}.\n$$\n飞行时间 $T$ 来自于 $y(T)=0$ 且 $T>0$，得出\n$$\nT=\\frac{2v\\sin\\theta}{g}.\n$$\n当竖直速度为零时，达到最大高度 $H$。竖直速度为\n$$\nv_{y}(t)=v\\sin\\theta-g t,\n$$\n所以 $v_{y}(t_{h})=0$ 给出 $t_{h}=\\frac{v\\sin\\theta}{g}$。代入 $y(t)$ 中，\n$$\nH=y(t_{h})=v\\sin\\theta\\left(\\frac{v\\sin\\theta}{g}\\right)-\\frac{1}{2}g\\left(\\frac{v\\sin\\theta}{g}\\right)^{2}\n=\\frac{v^{2}\\sin^{2}\\theta}{2g}.\n$$\n射程 $R$ 是 $t=T$ 时的水平位移，水平运动方程为 $x(t)=v\\cos\\theta\\, t$，因此\n$$\nR=x(T)=v\\cos\\theta\\left(\\frac{2v\\sin\\theta}{g}\\right)=\\frac{v^{2}\\sin 2\\theta}{g}.\n$$\n\n对于第一次试验 $(v_{0},g_{0})$，我们有\n$$\nT_{0}=\\frac{2v_{0}\\sin\\theta}{g_{0}},\\quad H_{0}=\\frac{v_{0}^{2}\\sin^{2}\\theta}{2g_{0}},\\quad R_{0}=\\frac{v_{0}^{2}\\sin 2\\theta}{g_{0}}.\n$$\n对于第二次试验，其中 $v_{1}=3v_{0}$ 且 $g_{1}=\\frac{1}{3}g_{0}$（$\\theta$ 相同），\n$$\nT_{1}=\\frac{2v_{1}\\sin\\theta}{g_{1}}=\\frac{2\\cdot 3v_{0}\\sin\\theta}{g_{0}/3}=\\frac{18v_{0}\\sin\\theta}{g_{0}},\n$$\n$$\nH_{1}=\\frac{v_{1}^{2}\\sin^{2}\\theta}{2g_{1}}=\\frac{(3v_{0})^{2}\\sin^{2}\\theta}{2\\,(g_{0}/3)}=\\frac{9v_{0}^{2}\\sin^{2}\\theta}{2}\\cdot\\frac{3}{g_{0}}=\\frac{27v_{0}^{2}\\sin^{2}\\theta}{2g_{0}},\n$$\n$$\nR_{1}=\\frac{v_{1}^{2}\\sin 2\\theta}{g_{1}}=\\frac{(3v_{0})^{2}\\sin 2\\theta}{g_{0}/3}=\\frac{9v_{0}^{2}\\sin 2\\theta}{1}\\cdot\\frac{3}{g_{0}}=\\frac{27v_{0}^{2}\\sin 2\\theta}{g_{0}}.\n$$\n因此，这些比率为\n$$\n\\frac{T_{1}}{T_{0}}=\\frac{18v_{0}\\sin\\theta/g_{0}}{2v_{0}\\sin\\theta/g_{0}}=9,\\quad\n\\frac{H_{1}}{H_{0}}=\\frac{\\frac{27v_{0}^{2}\\sin^{2}\\theta}{2g_{0}}}{\\frac{v_{0}^{2}\\sin^{2}\\theta}{2g_{0}}}=27,\\quad\n\\frac{R_{1}}{R_{0}}=\\frac{\\frac{27v_{0}^{2}\\sin 2\\theta}{g_{0}}}{\\frac{v_{0}^{2}\\sin 2\\theta}{g_{0}}}=27.\n$$\n这些缩放因子与 $\\theta$ 无关，因为两次试验之间的角度没有改变，并且三角函数因子在比率中被约去了。", "answer": "$$\\boxed{\\begin{pmatrix}9 & 27 & 27\\end{pmatrix}}$$", "id": "2210018"}, {"introduction": "现实世界中的力学问题常常涉及多个物体的相互作用，而不仅仅是单个抛体。这个练习通过一个巧妙的场景，将抛体运动与相对运动的概念结合起来，要求你在一个特定时刻相对速度为纯水平的拦截条件下，反向推导出初始条件。掌握这种结合不同物理概念并运用参考系思想来解决问题的方法，对于处理更复杂的动力学问题至关重要。[@problem_id:2210027]", "problem": "一位工程师正在测试一套新的抛射物发射系统。一个小球从水平地面上的一点被发射。与此同时，一架配备有捕捉装置的研究用无人机开始从相当高的高度垂直下降。该无人机以恒定速率 $v_L$ 下降。当小球处于离地高度为 $h$ 时，无人机成功拦截并捕捉到它。在拦截的瞬间，观测到小球相对于无人机的速度为纯水平方向。假设重力加速度为 $g$ 且空气阻力可忽略不计，求小球发射初速度的竖直分量。请用 $h$、$v_L$ 和 $g$ 的符号表达式来表示你的答案。", "solution": "选取竖直轴，以向上为正方向，并取地面为 $y=0$。设小球的初始竖直速度为 $v_{0y}$。无人机以恒定速率 $v_{L}$ 下降，因此其竖直速度为 $-v_{L}$。\n\n忽略空气阻力，小球的竖直运动遵循以下运动学方程：\n$$\ny(t) = v_{0y} t - \\frac{1}{2} g t^{2}, \\quad v_{y}(t) = v_{0y} - g t.\n$$\n在拦截时，满足两个条件：\n1) 小球的高度为 $h$，因此 $y(t)=h$。\n2) 小球相对于无人机的速度是纯水平的，这要求它们的竖直速度分量相等：$v_{y}(t) = -v_{L}$。\n\n根据第二个条件，\n$$\nv_{0y} - g t = -v_{L} \\quad \\Rightarrow \\quad t = \\frac{v_{0y} + v_{L}}{g}.\n$$\n将这个 $t$ 代入 $y(t)=h$：\n$$\nh = v_{0y} \\left(\\frac{v_{0y} + v_{L}}{g}\\right) - \\frac{1}{2} g \\left(\\frac{v_{0y} + v_{L}}{g}\\right)^{2}.\n$$\n化简等式右侧：\n$$\nh = \\frac{v_{0y}(v_{0y} + v_{L})}{g} - \\frac{(v_{0y} + v_{L})^{2}}{2g}\n= \\frac{1}{2g}\\left[v_{0y}^{2} - v_{L}^{2}\\right].\n$$\n因此，\n$$\nv_{0y}^{2} = v_{L}^{2} + 2 g h.\n$$\n由于小球必须是向上发射的，我们取正根：\n$$\nv_{0y} = \\sqrt{v_{L}^{2} + 2 g h}.\n$$\n这就是用 $h$、$v_{L}$ 和 $g$ 表示的发射初速度的竖直分量。", "answer": "$$\\boxed{\\sqrt{v_{L}^{2} + 2 g h}}$$", "id": "2210027"}, {"introduction": "虽然理想模型是学习的绝佳起点，但真实世界的抛体（如棒球或炮弹）会受到不可忽略的空气阻力。此练习将你带入计算物理学的领域，处理更符合现实的二次空气阻力模型，该模型由于其非线性特性而无法解析求解。你将学习使用“打靶法”这一强大的数值技术，通过编程来找到击中特定目标所需的发射角度，这真实地反映了现代物理学家和工程师解决复杂问题的方法。[@problem_id:2430429]", "problem": "一个质量为 $m$ 的二维抛射体从原点以初速度大小 $v_0$ 和发射角 $\\theta$（从水平方向测量）发射。该抛射体在均匀重力加速度 $\\mathbf{g} = (0,-g)$ 下运动，并受到一个与速度大小的平方成正比、方向与瞬时速度相反的二次空气动力阻力。使用牛顿第二定律对阻力建模如下。设状态为 $\\mathbf{r}(t) = (x(t),y(t))$ 和 $\\mathbf{v}(t) = (v_x(t),v_y(t))$，其中 $v(t) = \\sqrt{v_x(t)^2 + v_y(t)^2}$。运动方程为\n$$\n\\frac{d x}{d t} = v_x, \\quad \\frac{d y}{d t} = v_y,\n$$\n$$\n\\frac{d v_x}{d t} = -k\\, v\\, v_x, \\quad \\frac{d v_y}{d t} = -g - k\\, v\\, v_y,\n$$\n初始条件为\n$$\nx(0) = 0,\\quad y(0) = 0,\\quad v_x(0) = v_0 \\cos\\theta,\\quad v_y(0) = v_0 \\sin\\theta.\n$$\n阻力参数 $k$ 定义为\n$$\nk = \\frac{\\tfrac{1}{2}\\,\\rho\\, C_d\\, A}{m},\n$$\n其中 $\\rho$ 是空气密度，$C_d$ 是阻力系数，$A$ 是横截面积。\n\n你的任务是编写一个完整、可运行的程序，对于每个目标点 $(x_T,y_T)$，使用一个求根算法来确定所有能使抛射体在高度 $y = y_T$ 处通过垂直线 $x = x_T$ 的发射角 $\\theta \\in (0,\\tfrac{\\pi}{2})$（严格介于水平和垂直之间）。求根过程必须应用于一个根据第一性原理构建的发射角标量函数，具体如下。\n\n1. 对于一个给定的 $\\theta$，定义标量函数\n$$\nF(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T,\n$$\n其中 $t^\\star(\\theta)$ 是以角度 $\\theta$ 和速度大小 $v_0$ 发射的飞行过程中，$x\\big(t^\\star(\\theta)\\big) = x_T$ 的第一个时刻（如果存在）。如果抛射体永远不会到达 $x_T$（例如，在 $x$ 到达 $x_T$ 之前它就在 $y=0$ 处着陆），则 $F(\\theta)$ 未定义，并且该 $\\theta$ 不应用于求根的区间端点。\n\n2. 一个有效的解角度 $\\theta^\\star$ 满足 $F(\\theta^\\star) = 0$。你的程序必须系统性地搜索区间 $\\theta \\in [\\theta_{\\min}, \\theta_{\\max}]$，其中 $\\theta_{\\min} = 0.1^\\circ$ 且 $\\theta_{\\max} = 89.9^\\circ$，以检测 $F(\\theta)$ 符号改变的子区间，然后对每个检测到的子区间应用一维求根算法（例如，区间法）来收敛到一个根。\n\n3. 如果存在多个不同的根，则必须找到并报告所有在 $(0^\\circ, 90^\\circ)$ 内的此类角度。如果不存在根，则为该情况报告一个空列表。\n\n数值要求和约定：\n\n- 仅使用上述微分方程和初始条件作为唯一的物理模型；不要代入任何闭合形式的轨迹公式。\n- 实现一个数值常微分方程积分器，当 $x(t)$ 首次等于 $x_T$ 时（如果发生）或当抛射体在下降过程中击中地面 $y(t)=0$ 时停止。使用足够紧的容差以可靠地检测穿越。\n- 距离单位必须是米，时间单位是秒，质量单位是千克，空气密度单位是千克/立方米，面积单位是平方米，加速度单位是米/平方秒。角度必须以度为单位报告。\n- 以度为单位报告每个解角度，并四舍五入到三位小数。\n- 如果在穿越时刻 $t^\\star$，$|y(t^\\star) - y_T|$ 的值在 $10^{-3}$ 米以内，则该解角度是可接受的。你的求根容差应确保达到此目标精度。\n- 为了可复现性，对所有测试用例使用以下固定的物理参数：$m = 0.145$ 千克, $\\rho = 1.225$ 千克/立方米, $C_d = 0.47$, $A = 0.0042$ 平方米, 以及 $g = 9.81$ 米/平方秒。\n\n用于覆盖不同情况的测试套件：\n\n- 案例1（理想情况，地面目标，预期有两个解）：$v_0 = 40.0$ 米/秒，$(x_T,y_T) = (80.0, 0.0)$ 米。\n- 案例2（高处目标，通常有一或两个解）：$v_0 = 40.0$ 米/秒，$(x_T,y_T) = (60.0, 10.0)$ 米。\n- 案例3（短射程，预期有两个解）：$v_0 = 30.0$ 米/秒，$(x_T,y_T) = (30.0, 0.0)$ 米。\n- 案例4（超出最大射程，预期无解）：$v_0 = 40.0$ 米/秒，$(x_T,y_T) = (200.0, 0.0)$ 米。\n\n程序输入和输出规范：\n\n- 无外部输入。使用上述确切的常数和测试套件。\n- 你的程序应产生单行输出，其中包含四个案例的结果，格式为一个用方括号括起来的逗号分隔列表。每个案例的结果必须是一个以度为单位的解角度列表，按升序排序并四舍五入到三位小数。如果某个案例没有解，则为该案例输出一个空列表。\n- 例如，所需的整体输出格式类似于 $[ [\\ldots], [\\ldots], [\\ldots], [\\ldots] ]$，其中数值以十进制形式显示，且无额外文本。\n\n你的程序必须是完整且可直接运行的，并且必须使用应用于如上定义的 $F(\\theta)$ 的求根算法来为每个案例定位解角度。角度必须以度为单位报告。", "solution": "所提出的问题是计算物理学中一个定义明确的标准练习。它有科学依据，数学上一致，并且提供了求解所需的所有必要参数。该物理模型基于牛顿第二定律和二次空气阻力，是在粘性介质中抛射体运动的典型表示。这个数值任务是找到能使抛射体穿过一个特定目标点的发射角，它构成一个边值问题。指定的求解方法——打靶法结合标量函数的求根算法——是解决此类问题的一种稳健且合适的技术。因此，该问题是有效的，我们将继续提供一个完整的解决方案。\n\n问题的核心是求解一个一阶耦合常微分方程组（ODEs）。设系统在时刻 $t$ 的状态由向量 $\\mathbf{S}(t) = [x(t), y(t), v_x(t), v_y(t)]^T$ 描述。运动方程可以写成 $\\frac{d\\mathbf{S}}{dt} = \\mathbf{f}(t, \\mathbf{S})$ 的形式，其中函数 $\\mathbf{f}$ 定义为：\n$$\n\\mathbf{f}(t, \\mathbf{S}) = \n\\begin{pmatrix}\nv_x \\\\\nv_y \\\\\n-k \\sqrt{v_x^2 + v_y^2} \\, v_x \\\\\n-g - k \\sqrt{v_x^2 + v_y^2} \\, v_y\n\\end{pmatrix}\n$$\n在 $t=0$ 时的初始状态由 $\\mathbf{S}(0) = [0, 0, v_0 \\cos\\theta, v_0 \\sin\\theta]^T$ 给出。参数 $\\theta$ 是发射角，这是我们必须确定的。\n\n对于该系统，轨迹 $\\mathbf{r}(t)$ 的直接解析解不存在。我们必须采用数值方法。问题要求我们找到使轨迹通过目标点 $(x_T, y_T)$ 的 $\\theta$ 值。这是一个边值问题。我们将使用“打靶法”来解决它，该方法将边值问题转化为一个求根问题。\n\n打靶法的步骤如下：\n1.  我们选择一个试验发射角 $\\theta$。这完全确定了初始条件 $\\mathbf{S}(0)$。\n2.  我们从 $t=0$ 开始对ODEs系统随时间向前进行数值积分。这个过程就是“发射”抛射体。\n3.  我们监控轨迹，找到抛射体的水平位置 $x(t)$ 首次等于目标水平位置 $x_T$ 的时刻 $t^\\star$。\n4.  在这个时刻 $t^\\star$，我们评估抛射体的高度 $y(t^\\star)$。\n5.  我们定义一个标量目标函数 $F(\\theta)$，作为抛射体在 $x=x_T$ 处的高度与目标高度 $y_T$ 之间的差值：\n    $$\n    F(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T\n    $$\n    一个解角度 $\\theta^\\star$ 是使 $F(\\theta^\\star) = 0$ 成立的角度。因此，问题被简化为寻找函数 $F(\\theta)$ 的根。\n\n为了实现这个方法，我们需要一个稳健的ODE积分器。SciPy库中的`solve_ivp`函数是完成此任务的极好工具。`solve_ivp`的一个关键特性是其检测“事件”（即状态和时间的某个函数变为零的条件）的能力。我们将使用此功能来精确确定穿越时间 $t^\\star$，而无需积分到固定的最大时间然后再进行插值。\n\n我们定义两个终止事件函数：\n1.  `event_reach_x_target(t, S)`：此函数返回 $x(t) - x_T$。当该值为零时，积分器将停止，表明抛射体已到达目标的水平位置。\n2.  `event_hit_ground(t, S)`：此函数返回 $y(t)$。我们将其配置为仅在 $y(t)$ 减小时（即抛射体正在下落时）触发，这表明抛射体在到达 $x=x_T$ 之前已击中地面。\n\n函数 $F(\\theta)$ 是通过为给定的 $\\theta$ 调用ODE求解器来构建的。如果积分因 `event_reach_x_target` 事件而终止，我们计算并返回 $y(t^\\star) - y_T$。如果积分因 `event_hit_ground` 事件而终止，或者在未触发任何事件的情况下达到最大模拟时间，则意味着轨迹射程不足。在这种情况下，为进行区间划分的目的，函数 $F(\\theta)$ 被认为是未定义的，我们可以返回一个非数值（如 `NaN`，Not a Number）来表示这一点。\n\n为了在指定区间 $\\theta \\in [0.1^\\circ, 89.9^\\circ]$ 内找到 $F(\\theta)=0$ 的所有根，我们采用一个两阶段过程：\n1.  **划分区间**：我们首先将搜索区间离散化为一个精细的角度网格。我们在此网格的每个点上评估 $F(\\theta)$。通过搜索函数符号改变的相邻网格点 $(\\theta_i, \\theta_{i+1})$（即 $F(\\theta_i) \\cdot F(\\theta_{i+1})  0$），根据介值定理，我们识别出保证包含至少一个根的子区间。正确处理 `NaN` 情况非常重要，因为一个有效的区间需要在两端都有已定义的数值。\n2.  **求解**：对于找到的每个区间 $[\\theta_a, \\theta_b]$，我们应用一个数值求根算法。在 `scipy.optimize.brentq` 中实现的Brent方法是一个非常有效的选择。它结合了二分法的保证收敛性和割线法的更快收敛性，是在已知根所在区间时进行一维求根的标准方法。求根器的容差将被设置，以确保角度和最终目标高度都达到所需的精度。\n\n这个由数值积分、事件检测、划分区间和求根组成的系统性过程，将被应用于每个测试用例，以找到所有有效的发射角。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the projectile motion problem for all test cases.\n    \"\"\"\n    # Fixed physical parameters\n    M = 0.145  # mass in kg\n    RHO = 1.225  # air density in kg/m^3\n    C_D = 0.47  # drag coefficient (dimensionless)\n    A = 0.0042  # cross-sectional area in m^2\n    G = 9.81  # gravitational acceleration in m/s^2\n\n    # Derived drag parameter k = (rho * C_d * A) / (2 * m)\n    K = (0.5 * RHO * C_D * A) / M\n\n    # Test suite\n    test_cases = [\n        (40.0, (80.0, 0.0)),   # Case 1\n        (40.0, (60.0, 10.0)),  # Case 2\n        (30.0, (30.0, 0.0)),   # Case 3\n        (40.0, (200.0, 0.0)),  # Case 4\n    ]\n\n    def derivatives(t, state, k, g):\n        \"\"\"\n        Computes the derivatives for the system of ODEs.\n        state = [x, y, v_x, v_y]\n        \"\"\"\n        x, y, vx, vy = state\n        v = np.sqrt(vx**2 + vy**2)\n        \n        # Avoid division by zero if velocity is zero, though unlikely in this problem.\n        if v == 0:\n            ax = 0\n            ay = -g\n        else:\n            ax = -k * v * vx\n            ay = -g - k * v * vy\n            \n        return [vx, vy, ax, ay]\n\n    def calculate_y_error_at_xT(theta_deg, v0, xT, yT, k_param, g_param):\n        \"\"\"\n        Calculates the error F(theta) = y(t*) - yT for a given launch angle.\n        Returns np.nan if the projectile does not reach xT.\n        \"\"\"\n        theta_rad = np.deg2rad(theta_deg)\n        vx0 = v0 * np.cos(theta_rad)\n        vy0 = v0 * np.sin(theta_rad)\n        \n        initial_state = [0.0, 0.0, vx0, vy0]\n        \n        # Event: projectile reaches the target's x-coordinate\n        def reach_x_target(t, state, k, g):\n            return state[0] - xT\n        reach_x_target.terminal = True\n        reach_x_target.direction = 1 # Trigger only when x is increasing\n\n        # Event: projectile hits the ground (y=0)\n        def hit_ground(t, state, k, g):\n            return state[1]\n        hit_ground.terminal = True\n        hit_ground.direction = -1 # Trigger only when y is decreasing\n\n        t_span = (0, 100) # Max integration time of 100s is sufficient\n        sol = solve_ivp(\n            fun=derivatives,\n            t_span=t_span,\n            y0=initial_state,\n            args=(k_param, g_param),\n            events=[reach_x_target, hit_ground],\n            dense_output=True,\n            rtol=1e-8,\n            atol=1e-8\n        )\n\n        # Check which event terminated the integration\n        if sol.status == 1 and sol.t_events[0].size > 0:\n            # The 'reach_x_target' event was triggered\n            y_at_t_star = sol.y_events[0][0][1]\n            return y_at_t_star - yT\n        else:\n            # Projectile hit the ground first or integration timed out\n            return np.nan\n\n    all_results = []\n    for v0, (xT, yT) in test_cases:\n        \n        # Define the function for root finding, which depends on the case parameters\n        objective_func = lambda th: calculate_y_error_at_xT(th, v0, xT, yT, K, G)\n\n        # 1. Bracketing stage: Scan the angle range to find sign changes\n        theta_min_deg = 0.1\n        theta_max_deg = 89.9\n        scan_step_deg = 0.5  # Step size for scanning\n        \n        angles_to_scan = np.arange(theta_min_deg, theta_max_deg + scan_step_deg, scan_step_deg)\n        f_values = np.array([objective_func(th) for th in angles_to_scan])\n        \n        case_roots = []\n        for i in range(len(angles_to_scan) - 1):\n            th1, f1 = angles_to_scan[i], f_values[i]\n            th2, f2 = angles_to_scan[i+1], f_values[i+1]\n\n            if not np.isnan(f1) and not np.isnan(f2):\n                if f1 * f2  0:\n                    # Found a bracket [th1, th2]\n                    try:\n                        # 2. Solving stage: Find the root within the bracket\n                        root_deg = brentq(objective_func, th1, th2, xtol=1e-5)\n                        # Check if this root is a duplicate before adding\n                        is_duplicate = False\n                        for existing_root in case_roots:\n                            if abs(root_deg - existing_root)  1e-4:\n                                is_duplicate = True\n                                break\n                        if not is_duplicate:\n                            case_roots.append(root_deg)\n                    except ValueError:\n                        # brentq can fail if signs are not opposite, though our check prevents this.\n                        pass\n        \n        case_roots.sort()\n        all_results.append([round(r, 3) for r in case_roots])\n\n    # Format the final output string as specified\n    case_strs = []\n    for res_list in all_results:\n        num_strs = [f\"{num:.3f}\" for num in res_list]\n        case_strs.append(f\"[{','.join(num_strs)}]\")\n    \n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```", "id": "2430429"}]}