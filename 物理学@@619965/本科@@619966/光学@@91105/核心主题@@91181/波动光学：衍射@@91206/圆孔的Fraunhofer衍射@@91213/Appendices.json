{"hands_on_practices": [{"introduction": "要将理论知识付诸实践，一个典型任务就是设计能产生特定光学效应的实验装置。本练习将引导你完成一个基础但至关重要的计算：为了在屏幕上获得一个特定大小的艾里斑，你需要使用多大直径的针孔。这个练习将帮助你熟练运用圆形孔径夫琅禾费衍射的核心公式，并理解衍射图案尺寸与系统物理参数之间的直接联系。[@problem_id:2230831]", "problem": "一名本科生正在为大学的科普活动搭建一个夫琅禾费衍射演示装置。该装置包含一个来自受激辐射光放大（LASER）源的连续波光束，该光束垂直照射到一个小的圆形孔径（针孔）上。产生的衍射图样被投射到距离针孔很远的一个屏幕上。该学生的目标是在屏幕上形成一个具有特定半径的中央亮斑，也称为艾里斑。\n\n激光器发射波长为 $\\lambda = 632.8 \\text{ nm}$ 的单色光束。屏幕距离针孔的距离为 $L = 4.50 \\text{ m}$。学生需要艾里斑的半径（从图样中心到第一个暗环的距离）恰好为 $y_1 = 2.50 \\text{ cm}$。\n\n假设屏幕到针孔的距离远大于艾里斑的半径，计算所需的针孔直径。你的答案需以毫米（mm）为单位，并四舍五入到三位有效数字。", "solution": "对于圆形孔径的夫琅禾费衍射，第一级暗纹（屏幕上艾里斑的半径）出现在满足 $\\sin\\theta_{1}=1.22\\,\\frac{\\lambda}{D}$ 的角度 $\\theta_{1}$ 处，其中 $D$ 是孔径直径，$\\lambda$ 是波长。在远场（小角度）近似下，$\\theta_{1}\\approx \\tan\\theta_{1}$，屏幕上的线性半径为 $y_{1}=L\\,\\theta_{1}$。联立这些公式可得\n$$\ny_{1}\\approx L\\left(1.22\\,\\frac{\\lambda}{D}\\right)\\quad\\Rightarrow\\quad D=\\frac{1.22\\,\\lambda\\,L}{y_{1}}.\n$$\n将给定物理量转换为国际单位制（SI）单位并代入：\n$$\n\\lambda=632.8\\times 10^{-9}\\ \\text{m},\\quad L=4.50\\ \\text{m},\\quad y_{1}=2.50\\times 10^{-2}\\ \\text{m},\n$$\n$$\nD=\\frac{1.22\\,(632.8\\times 10^{-9})\\,(4.50)}{2.50\\times 10^{-2}}\\ \\text{m}.\n$$\n计算分子：\n$$\n(632.8\\times 10^{-9})\\times 4.50=2.8476\\times 10^{-6},\n$$\n$$\n1.22\\times 2.8476\\times 10^{-6}=3.474072\\times 10^{-6}.\n$$\n现在除以 $2.50\\times 10^{-2}$：\n$$\nD=\\frac{3.474072\\times 10^{-6}}{2.50\\times 10^{-2}}=1.3896288\\times 10^{-4}\\ \\text{m}.\n$$\n换算成毫米：\n$$\nD=(1.3896288\\times 10^{-4})\\ \\text{m}\\times \\frac{10^{3}\\ \\text{mm}}{1\\ \\text{m}}=0.13896288\\ \\text{mm}.\n$$\n四舍五入到三位有效数字，所需的直径为\n$$\n0.139\\ \\text{mm}.\n$$", "answer": "$$\\boxed{0.139}$$", "id": "2230831"}, {"introduction": "光学系统的性能，特别是其分辨本领，直接受衍射效应的制约。本练习通过一个天文学观测的假想场景，探讨改变光源波长和望远镜口径将如何共同影响最终形成的艾里斑大小。通过分析这些参数变化带来的比例关系，你将能更深刻地理解瑞利判据的实际意义，并培养对光学系统性能进行定性预测的直觉。[@problem_id:2230833]", "problem": "一位业余天文学家正使用一台反射式望远镜观测一颗遥远的、点状的恒星，其主镜直径为 $D_1$，焦距为 $f$。来自恒星的光穿过望远镜的圆形孔径，在目镜或相机传感器所在的焦平面上形成一个衍射图样，称为艾里图样 (Airy pattern)。该图样第一暗环的角半径 $\\theta$ 可由近似公式 $\\sin(\\theta) \\approx 1.22 \\frac{\\lambda}{D}$ 给出，其中 $\\lambda$ 是光的波长，$D$ 是孔径的直径。在对天文观测有效的小角度近似下，焦平面上中央亮斑（艾里斑）的线性半径为 $R \\approx f \\theta$。\n\n最初，这位天文学家使用一个滤光片，该滤光片允许中心波长为 $\\lambda_1$ 的光通过。之后，为了增强某些特征，天文学家同时做了两项改变：\n1.  他们将滤光片更换为另一个，允许中心波长为 $\\lambda_2 = 2\\lambda_1$ 的光通过。\n2.  他们在主镜上放置了一个“离轴孔径光阑”(off-axis aperture stop)，这是一个遮罩，可有效地将集光孔径减小到一个新的圆形直径 $D_2 = \\frac{1}{2} D_1$。\n\n设 $R_1$ 为初始配置下艾里斑的线性半径，$R_2$ 为修改后的线性半径。比值 $\\frac{R_2}{R_1}$ 的值是多少？\n\nA. $\\frac{1}{4}$\n\nB. $\\frac{1}{2}$\n\nC. $1$\n\nD. $2$\n\nE. $4$", "solution": "对于圆形孔径，其衍射极限下第一暗环的角半径由瑞利判据 (Rayleigh criterion) 给出：\n$$\n\\sin(\\theta) \\approx 1.22 \\frac{\\lambda}{D}.\n$$\n对于天文学中适用的小角度，小角度近似给出 $\\sin(\\theta) \\approx \\theta$，因此\n$$\n\\theta \\approx 1.22 \\frac{\\lambda}{D}.\n$$\n焦平面上艾里斑的线性半径 $R$ 与角半径 $\\theta$ 的关系为\n$$\nR \\approx f \\theta,\n$$\n所以代入 $\\theta$ 的表达式可得\n$$\nR \\approx f \\left(1.22 \\frac{\\lambda}{D}\\right) = 1.22 \\frac{f \\lambda}{D}.\n$$\n对于初始配置，波长为 $\\lambda_{1}$，孔径直径为 $D_{1}$，其艾里斑半径为\n$$\nR_{1} = 1.22 \\frac{f \\lambda_{1}}{D_{1}}.\n$$\n修改之后，新的波长和直径分别为 $\\lambda_{2} = 2 \\lambda_{1}$ 和 $D_{2} = \\frac{1}{2} D_{1}$，所以\n$$\nR_{2} = 1.22 \\frac{f \\lambda_{2}}{D_{2}} = 1.22 \\frac{f (2 \\lambda_{1})}{\\frac{1}{2} D_{1}} = 1.22 \\frac{f \\cdot 2 \\lambda_{1} \\cdot 2}{D_{1}} = 4 \\left(1.22 \\frac{f \\lambda_{1}}{D_{1}}\\right) = 4 R_{1}.\n$$\n因此，该比值为\n$$\n\\frac{R_{2}}{R_{1}} = 4.\n$$\n这对应于选项 E。", "answer": "$$\\boxed{E}$$", "id": "2230833"}, {"introduction": "超越简化公式，我们可以利用计算工具来模拟衍射现象，从而揭示其背后更深层次的物理原理。本练习要求你通过编程，利用离散傅里叶变换（DFT）来模拟从一个二维孔径到其夫琅禾费衍射场的完整过程。这个高级实践不仅能让你直观地看到衍射图案与孔径形状的傅里叶变换关系，还将引导你探索光学成像中的一个核心挑战——相位丢失问题。[@problem_id:2431156]", "problem": "你的任务是以一种计算上可复现的方式，演示二元孔径的夫琅禾费衍射如何通过傅里叶变换将其形状编码到复数场中，以及强度图样中相位的缺失如何使得恢复过程仅限于孔径的自相关。你的程序必须完全在离散域中实现以下内容：\n\n- 使用离散傅里叶变换 (DFT) 来模拟从采样孔径透射函数到采样夫琅禾费衍射场的过程。假设标量衍射理论和夫琅禾费近似为基本依据。在此模型中，远场复振幅与孔径的连续傅里叶变换成正比；在采样设置中，使用一对具有适当中心化的一致二维 DFT。\n\n- 对于从复数场进行的重建，使用同一对 DFT 的逆变换，并量化其与真实孔径相比的重建误差。\n\n- 对于仅有强度的数据，应用离散形式的维纳-辛钦定理：功率谱的逆 DFT 等于孔径的自相关（在有限网格上解释为循环自相关）。通过检查零延迟自相关等于孔径总能量这一标量属性来验证该定理。\n\n你可以不经证明直接使用的基本假设：\n- 在标量衍射理论和夫琅禾费近似下，远场复振幅与孔径透射函数的傅里叶变换成正比。\n- 当一致定义时，二维离散傅里叶变换 (DFT) 及其逆变换在有限网格上构成一个双射线性对。\n- 维纳-辛钦定理指出，功率谱密度的傅里叶逆变换等于自相关函数。\n\n待使用的定义和约定：\n- 设孔径为一个实值数组 $A[i,j]$，在一个 $N \\times N$ 网格上采样，像素间距视为无量纲单位 1。角度必须以弧度表示。\n- 设二维 DFT 由 $\\mathcal{F}\\{\\cdot\\}$ 表示，其逆变换由 $\\mathcal{F}^{-1}\\{\\cdot\\}$ 表示，使用一致的中心化约定，使零空间频率位于数组中心。在代码中，你必须通过在 DFT 调用前后进行移位来实现这一点，以遵循夫琅禾费变换的物理中心化。\n- 远场复振幅 $U[k,\\ell]$ 取为 $U = \\mathcal{F}\\{A\\}$，强度为 $I = |U|^{2}$。\n- 从复数场重建的孔径为 $A_{\\text{rec}} = \\mathcal{F}^{-1}\\{U\\}$。\n- 从仅有强度的数据中恢复的离散自相关 $C[m,n]$ 为 $C = \\mathcal{F}^{-1}\\{I\\}$，这对应于 $N \\times N$ 网格上的循环自相关。\n- 定义用于比较重建 $\\hat{X}$ 与真实值 $X$ 的归一化均方根误差 (NRMSE) 为\n$$\n\\mathrm{NRMSE}(X,\\hat{X}) = \\sqrt{\\frac{\\sum_{i,j} ( \\hat{X}[i,j] - X[i,j])^{2}}{\\sum_{i,j} X[i,j]^{2}}}.\n$$\n- 对于二元孔径，零延迟自相关 $C[0,0]$（数组中心元素）等于 $\\sum_{i,j} A[i,j]^{2}$，即孔径透射等于 1 的像素数量。\n\n算法要求：\n- 构建以网格原点为中心的二元孔径：\n  - 宽度为 $w$、高度为 $h$ 的轴对齐矩形。\n  - 半径为 $r$ 的圆盘。\n  - 宽度为 $w$、高度为 $h$、围绕数组中心旋转角度 $\\theta$ 的旋转矩形。\n  - 单像素孔径（位于中心的离散 δ 函数）。\n- 通过带有适当中心化的二维 DFT 计算远场复振幅 $U$。\n- 通过应用具有匹配中心化的逆变换，从 $U$ 重建 $A_{\\text{rec}}$。\n- 为每种情况计算 $\\mathrm{NRMSE}(A,A_{\\text{rec}})$。\n- 对于仅有强度的验证，使用轴对齐矩形的情况计算 $I = |U|^{2}$，然后计算 $C = \\mathcal{F}^{-1}\\{I\\}$ 并报告零延迟值的相对误差：\n$$\n\\varepsilon_{\\text{zero-lag}} = \\frac{\\left| C[0,0] - \\sum_{i,j} A[i,j]^{2} \\right|}{\\sum_{i,j} A[i,j]^{2}}.\n$$\n- 所有角度必须以弧度为单位。\n\n待实现的测试套件：\n- 情况 $1$（理想路径）：$N=128$，矩形，其中 $w=32$，$h=16$，$\\theta = 0$。\n- 情况 $2$（形状差异）：$N=128$，圆盘，其中 $r=15$。\n- 情况 $3$（旋转压力测试）：$N=128$，矩形，其中 $w=20$，$h=40$，$\\theta = \\pi/6$。\n- 情况 $4$（边界极端情况）：$N=64$，位于中心的单像素孔径。\n- 情况 $5$（仅有强度的属性检查）：复用情况 $1$ 的矩形来计算 $\\varepsilon_{\\text{zero-lag}}$。\n\n数值输出：\n- 对于情况 $1$ 至 $4$，以 $4$ 个浮点数的形式输出 $\\mathrm{NRMSE}$ 值。\n- 对于情况 $5$，以一个浮点数的形式输出 $\\varepsilon_{\\text{zero-lag}}$。\n\n最终输出格式：\n- 你的程序必须生成单行输出，其中包含一个 Python 风格的列表，内有按情况 $1$ 至 $5$ 的顺序排列的 $5$ 个逗号分隔的浮点数，并用方括号括起来，不含任何额外文本，例如：“[x1,x2,x3,x4,x5]”。", "solution": "所述问题已经过严格验证。\n\n**步骤1：提取的已知条件**\n- **任务**：使用离散傅里叶变换（DFT）以计算方式演示二元孔径、其夫琅禾费衍射图样（复数场和强度）以及重建之间的关系。\n- **基本原理**：标量衍射理论、夫琅禾费近似、作为连续傅里叶变换模型的二维 DFT，以及维纳-辛钦定理。\n- **定义**：\n    - 孔径：$N \\times N$ 网格上的 $A[i,j]$。\n    - DFT 算子：$\\mathcal{F}\\{\\cdot\\}$（正向），$\\mathcal{F}^{-1}\\{\\cdot\\}$（逆向），对零频率进行中心化。\n    - 复数场：$U = \\mathcal{F}\\{A\\}$。\n    - 强度：$I = |U|^{2}$。\n    - 基于场的重建：$A_{\\text{rec}} = \\mathcal{F}^{-1}\\{U\\}$。\n    - 基于强度的自相关：$C = \\mathcal{F}^{-1}\\{I\\}$。\n    - NRMSE 指标：$\\mathrm{NRMSE}(X,\\hat{X}) = \\sqrt{\\frac{\\sum_{i,j} ( \\hat{X}[i,j] - X[i,j])^{2}}{\\sum_{i,j} X[i,j]^{2}}}$。\n    - 零延迟误差指标：$\\varepsilon_{\\text{zero-lag}} = \\frac{\\left| C[0,0] - \\sum_{i,j} A[i,j]^{2} \\right|}{\\sum_{i,j} A[i,j]^{2}}$，其中 $C[0,0]$ 是数组中心的值。\n- **孔径几何形状**：轴对齐矩形（$w, h$）、圆盘（$r$）、旋转矩形（$w, h, \\theta$）、单像素。\n- **测试套件**：\n    - 情况 1：$N=128$，矩形（$w=32, h=16$），计算 NRMSE。\n    - 情况 2：$N=128$，圆盘（$r=15$），计算 NRMSE。\n    - 情况 3：$N=128$，旋转矩形（$w=20, h=40, \\theta=\\pi/6$），计算 NRMSE。\n    - 情况 4：$N=64$，单像素，计算 NRMSE。\n    - 情况 5：使用情况 1 计算 $\\varepsilon_{\\text{zero-lag}}$。\n\n**步骤2：验证**\n- **科学依据**：该问题正确地基于傅里叶光学和数字信号处理的原理。夫琅禾费衍射图样是孔径的傅里叶变换，这是一个基础概念。使用 DFT 对其进行建模是计算物理领域的标准做法。维纳-辛钦定理是关联信号自相关与其功率谱的一个基本定理。所有前提在事实上和科学上都是合理的。\n- **适定性**：该问题是适定的。它为每个测试用例提供了所有必要的定义、约束和参数。目标陈述清晰，所需输出的规定明确。\n- **客观性**：该问题以客观、正式的语言陈述，没有主观性或含糊之处。\n\n**步骤3：结论与行动**\n该问题被认为是**有效的**。这是一个正确且定义明确的计算物理学练习。将提供一个解决方案。\n\n解决方案的步骤如下。我们首先使用离散数学对物理系统进行建模，然后以计算方式实现该模型，以验证所述的物理原理。\n\n基本物理原理是，在夫琅禾费近似下，远场衍射图样中的复电场振幅 $U$ 与孔径透射函数 $A$ 的傅里叶变换成正比。在离散网格上，我们使用二维离散傅里叶变换（DFT）（表示为 $\\mathcal{F}\\{\\cdot\\}$）来对此关系进行建模。\n$$\nU[k,\\ell] \\propto (\\mathcal{F}\\{A\\})[k,\\ell]\n$$\n一个关键细节是正确的中心化。一个物理孔径通常关于空间原点 $(x,y) = (0,0)$ 对称。然而，标准的快速傅里叶变换（FFT）算法假定原点位于数组索引 $(0,0)$ 处。为了协调这些约定，我们必须在变换前后应用移位操作。对于中心化的正向变换，正确的步骤是 $U = \\text{fftshift}(\\mathcal{F}(\\text{ifftshift}(A)))$，而对于逆变换，则是 $A_{\\text{rec}} = \\text{fftshift}(\\mathcal{F}^{-1}(\\text{ifftshift}(U)))$。由于 DFT 及其逆变换构成一个数值稳定的对，我们预期从完整复数场 $U$ 重建的 $A_{\\text{rec}}$ 将与原始孔径 $A$ 几乎完全相同。由归一化均方根误差（NRMSE）量化的重建误差应接近于零，仅受浮点精度的限制。\n$$\n\\mathrm{NRMSE}(A, A_{\\text{rec}}) \\approx 0\n$$\n这表明，如果振幅和相位信息（编码在复数场 $U$ 中）都被保留，原始孔径的形状可以被完美恢复。\n\n演示的第二部分涉及相位信息的丢失。在典型的实验中，探测器测量的是强度 $I$，而不是复数场。强度是场的模长的平方：$I = |U|^2$。相位信息在此过程中丢失。维纳-辛钦定理规定了能从仅有强度的数据中恢复什么。该定理指出，功率谱密度（$I$ 与其成正比）的傅里叶逆变换是原始信号的自相关函数。\n$$\nC = \\mathcal{F}^{-1}\\{I\\} = \\mathcal{F}^{-1}\\{|\\mathcal{F}\\{A\\}|^2\\} \\propto A \\star A\n$$\n其中 $\\star$ 表示相关。这意味着我们无法恢复孔径 $A$ 本身，而只能恢复其自相关 $C$。自相关函数的一个关键性质是，其在零延迟处的值 $C[0,0]$ 等于信号的总能量。对于一个二元孔径，其中 $A[i,j] \\in \\{0, 1\\}$，这个能量是平方和 $\\sum_{i,j} A[i,j]^2$，也就是非零像素的数量。我们通过计算计算出的自相关 $C$ 的中心元素与孔径 $A$ 的已知能量之间的相对误差 $\\varepsilon_{\\text{zero-lag}}$ 来验证这个性质。\n$$\n\\varepsilon_{\\text{zero-lag}} = \\frac{\\left| C_{\\text{center}} - \\sum_{i,j} A[i,j]^{2} \\right|}{\\sum_{i,j} A[i,j]^{2}} \\approx 0\n$$\n计算实现包括在 $N \\times N$ 网格上生成指定的二元孔径。对于每种情况，我们应用中心化的 DFT 获得 $U$，然后应用中心化的逆 DFT 获得 $A_{\\text{rec}}$ 并计算 NRMSE。对于最后一种情况，我们从情况 1 中计算强度 $I$，对其进行中心化的逆 DFT 以找到自相关 $C$，然后计算相对误差 $\\varepsilon_{\\text{zero-lag}}$。给定测试套件的结果将在数值上证实这些傅里叶光学的基础原理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational physics problem demonstrating properties of the DFT\n    in the context of Fraunhofer diffraction.\n    \"\"\"\n\n    def create_grid(N):\n        \"\"\"Creates centered coordinate grids for an N x N array.\"\"\"\n        # Creates coordinates from -N/2 to N/2 - 1\n        axis = np.arange(-N/2, N/2)\n        x, y = np.meshgrid(axis, axis)\n        return x, y\n\n    def create_rectangle_aperture(N, w, h, theta):\n        \"\"\"Creates a binary rectangle aperture, possibly rotated.\"\"\"\n        x, y = create_grid(N)\n        # Rotate coordinates for the aperture check\n        cos_t = np.cos(theta)\n        sin_t = np.sin(theta)\n        x_rot = x * cos_t + y * sin_t\n        y_rot = -x * sin_t + y * cos_t\n        # Aperture is 1 where coordinates are within the rotated rectangle bounds\n        aperture = np.where((np.abs(x_rot) < w / 2) & (np.abs(y_rot) < h / 2), 1.0, 0.0)\n        return aperture\n\n    def create_disk_aperture(N, r):\n        \"\"\"Creates a binary circular disk aperture.\"\"\"\n        x, y = create_grid(N)\n        # Aperture is 1 where distance from center is less than radius\n        radius_map = np.sqrt(x**2 + y**2)\n        aperture = np.where(radius_map < r, 1.0, 0.0)\n        return aperture\n\n    def create_pixel_aperture(N):\n        \"\"\"Creates a single-pixel aperture at the grid center.\"\"\"\n        aperture = np.zeros((N, N), dtype=float)\n        # Center of the grid in array indices\n        center = N // 2\n        aperture[center, center] = 1.0\n        return aperture\n\n    def calculate_nrmse(X, X_hat):\n        \"\"\"Calculates the Normalized Root-Mean-Square Error.\"\"\"\n        numerator = np.sum((X_hat - X)**2)\n        denominator = np.sum(X**2)\n        if denominator == 0:\n            # Handle case of zero-energy ground truth, though not expected here\n            return 0.0 if numerator == 0 else np.inf\n        return np.sqrt(numerator / denominator)\n\n    # Define test cases as per the problem statement\n    test_cases_params = [\n        {'type': 'rectangle', 'N': 128, 'w': 32, 'h': 16, 'theta': 0.0},\n        {'type': 'disk', 'N': 128, 'r': 15},\n        {'type': 'rectangle', 'N': 128, 'w': 20, 'h': 40, 'theta': np.pi/6},\n        {'type': 'pixel', 'N': 64},\n    ]\n\n    results = []\n    \n    # Store results of Case 1 for Case 5\n    A1, U1 = None, None\n\n    # Process Cases 1-4: NRMSE for reconstruction from complex field\n    for i, params in enumerate(test_cases_params):\n        N = params['N']\n        if params['type'] == 'rectangle':\n            A = create_rectangle_aperture(N, params['w'], params['h'], params['theta'])\n        elif params['type'] == 'disk':\n            A = create_disk_aperture(N, params['r'])\n        elif params['type'] == 'pixel':\n            A = create_pixel_aperture(N)\n\n        # Compute far-field complex amplitude U using centered DFT\n        # np.fft.ifftshift moves the (0,0) origin from center to corner\n        # np.fft.fft2 computes the DFT\n        # np.fft.fftshift moves the zero-frequency from corner back to center\n        U = np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(A)))\n\n        # Reconstruct aperture A_rec from complex field U\n        A_rec = np.real(np.fft.fftshift(np.fft.ifft2(np.fft.ifftshift(U))))\n        \n        # Calculate NRMSE\n        nrmse = calculate_nrmse(A, A_rec)\n        results.append(nrmse)\n        \n        # Save results of Case 1 for later use in Case 5\n        if i == 0:\n            A1, U1 = A, U\n\n    # Process Case 5: Zero-lag autocorrelation property from intensity\n    N_case5 = test_cases_params[0]['N']\n    # Compute intensity I from the complex field of Case 1\n    I1 = np.abs(U1)**2\n\n    # Compute autocorrelation C via inverse DFT of intensity\n    # The result should be real, so we take np.real to discard small imaginary parts\n    # due to floating-point inaccuracies.\n    # The shifting logic is the same as for the aperture reconstruction.\n    C1 = np.real(np.fft.fftshift(np.fft.ifft2(np.fft.ifftshift(I1))))\n\n    # Get zero-lag value from the center of the autocorrelation array\n    center_idx = N_case5 // 2\n    C1_zero_lag = C1[center_idx, center_idx]\n\n    # Calculate total energy of the original aperture\n    total_energy = np.sum(A1**2)\n\n    # Calculate relative error of the zero-lag value\n    epsilon_zero_lag = np.abs(C1_zero_lag - total_energy) / total_energy\n    results.append(epsilon_zero_lag)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "2431156"}]}