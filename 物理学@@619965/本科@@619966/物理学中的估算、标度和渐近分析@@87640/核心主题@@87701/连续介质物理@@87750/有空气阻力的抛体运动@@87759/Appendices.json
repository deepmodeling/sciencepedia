{"hands_on_practices": [{"introduction": "在我们对物理世界的初步认识中，例如在真空中，抛射体的上升和下降过程是完全对称的。然而，现实世界中的空气阻力打破了这种完美的对称性。这个练习将挑战你运用物理直觉而非复杂的数学计算，通过分析物体上升过程中的受力情况，来理解空气阻力是如何影响不同阶段的飞行时间的。[@problem_id:1923869]", "problem": "一个质量为 $m$ 的物体以某一初速度从地面（$y=0$）被垂直向上发射。物体受到一个大小为 $mg$ 的恒定向下引力和一个空气阻力（拖曳力）。阻力的方向始终与物体的速度方向相反，其大小由 $F_d = bv^2$ 给出，其中 $b$ 是一个正常数，$v$ 是物体的瞬时速率。\n\n物体在开始下落前达到最大高度 $H$。设 $t_{bottom}$ 是物体从地面行进到高度 $H/2$ 所花费的时间。设 $t_{top}$ 是物体从高度 $H/2$ 行进到其最大高度 $H$ 所花费的时间。\n\n以下哪个陈述正确描述了 $t_{top}$ 和 $t_{bottom}$ 之间的关系？\n\nA. $t_{top} > t_{bottom}$\n\nB. $t_{top} < t_{bottom}$\n\nC. $t_{top} = t_{bottom}$\n\nD. 该关系取决于物体的质量 $m$。\n\nE. 如果不知道 $b$ 和初速度的具体值，则无法确定该关系。", "solution": "让我们分析物体在上升过程中受到的力。存在两个力：方向朝下的引力 $F_g = mg$，以及由于物体向上运动同样方向朝下的空气阻力（拖曳力）$F_d = bv^2$。\n\n物体在上升期间受到的合力是这两个力的和：\n$$F_{net, up} = F_g + F_d = mg + bv^2$$\n这个合力的方向朝下，导致物体减速。根据牛顿第二定律 $F_{net} = ma$，物体在上升过程中其加速度（或减速度）的大小为：\n$$a_{up} = \\frac{F_{net, up}}{m} = \\frac{mg + bv^2}{m} = g + \\frac{b}{m}v^2$$\n\n现在，让我们考虑上升过程的两个阶段：\n1.  **下半段：** 物体从高度 $y=0$ 行进到 $y=H/2$。\n2.  **上半段：** 物体从高度 $y=H/2$ 行进到 $y=H$。\n\n在整个上升过程中，物体的速率 $v$ 持续减小。它在运动开始时速率最快，在达到最高点 $H$ 时速率变为零。这意味着物体在其轨迹下半部分的任意一点的速率都大于其在轨迹上半部分的任意一点的速率。\n\n设 $\\bar{v}_{bottom}$ 是物体通过下半段（从 $y=0$ 到 $y=H/2$）时的平均速率。\n设 $\\bar{v}_{top}$ 是物体通过上半段（从 $y=H/2$ 到 $y=H$）时的平均速率。\n\n由于在上升过程中速率一直在减小，因此在前半段路程的平均速率必然大于在后半段路程的平均速率。\n$$\\bar{v}_{bottom} > \\bar{v}_{top}$$\n\n轨迹的两个阶段所覆盖的距离相同，均为 $\\Delta y = H/2$。走过某段距离所花费的时间与该段距离上的平均速率通过近似关系式 $t = \\frac{\\text{距离}}{\\text{平均速率}}$ 相关联。\n因此，我们可以比较时间 $t_{bottom}$ 和 $t_{top}$：\n$$t_{bottom} = \\frac{H/2}{\\bar{v}_{bottom}}$$\n$$t_{top} = \\frac{H/2}{\\bar{v}_{top}}$$\n\n由于 $\\bar{v}_{bottom} > \\bar{v}_{top}$，因此 $t_{bottom}$ 的分母大于 $t_{top}$ 的分母。这意味着：\n$$t_{bottom} < t_{top}$$\n或等价地，\n$$t_{top} > t_{bottom}$$\n\n物体在上升的后半段运动得更慢，因此与运动得更快的下半段相比，它需要更多的时间来走完这段距离。这个结论对于 $m$ 和 $b$ 的任何正值以及任何足以达到高度 $H$ 的初速度都成立。因此，选项 D 和 E 是不正确的。选项 C 只有在没有空气阻力（$b=0$）的情况下才成立，此时加速度为常数（$a=g$），导致速度随位置对称变化。\n\n正确的关系是 $t_{top} > t_{bottom}$。", "answer": "$$\\boxed{A}$$", "id": "1923869"}, {"introduction": "在建立了定性的物理直觉后，我们现在转向定量的数学分析。在有空气阻力的运动中，一个核心概念是终端速度 ($v_t$)，此时阻力与重力相平衡。这个练习要求你解出物体从静止下落的运动微分方程，从而推导出达到其终端速度特定比例所需的时间，让你掌握处理这类动力学问题的基本解析方法。[@problem_id:1923884]", "problem": "一个小型的球形钢珠从静止开始，自很高处落入一大缸粘性流体中。钢珠受到一个与其速度平方成正比的阻力，此机制称为二次阻力。经过足够长的时间后，钢珠的速度会趋于一个恒定值，称为终端速度，记为 $v_t$。令 $g$ 为有效重力加速度的大小，该值已计入重力以及流体提供的恒定浮力。请确定钢珠达到其终端速度50%所需的时间 $t_{1/2}$。将你的答案表示为一个以 $v_t$ 和 $g$ 表达的闭式解析表达式。", "solution": "设向下为正方向。由于二次阻力与运动方向相反，施加于钢珠的合力为\n$$\nm \\frac{dv}{dt} = m g - k v^{2},\n$$\n其中 $k>0$ 是阻力系数，$g$ 是有效重力加速度（已包含浮力）。在终端速度 $v_{t}$ 时，加速度为零，因此\n$$\n0 = m g - k v_{t}^{2} \\quad \\Rightarrow \\quad \\frac{k}{m} = \\frac{g}{v_{t}^{2}}.\n$$\n代入运动方程可得\n$$\n\\frac{dv}{dt} = g \\left(1 - \\frac{v^{2}}{v_{t}^{2}}\\right).\n$$\n从 $v(0)=0$ 开始，分离变量并积分：\n$$\n\\int_{0}^{v} \\frac{dv'}{1 - \\frac{{v'}^{2}}{v_{t}^{2}}} = \\int_{0}^{t} g \\, dt'.\n$$\n令 $u = v'/v_{t}$，则 $dv' = v_{t} \\, du$；于是\n$$\nv_{t} \\int_{0}^{v/v_{t}} \\frac{du}{1 - u^{2}} = g t.\n$$\n使用 $\\int \\frac{du}{1 - u^{2}} = \\operatorname{artanh}(u)$，\n$$\nv_{t} \\, \\operatorname{artanh}\\!\\left(\\frac{v}{v_{t}}\\right) = g t.\n$$\n因此\n$$\n\\frac{v}{v_{t}} = \\tanh\\!\\left(\\frac{g t}{v_{t}}\\right).\n$$\n为达到终端速度的一半，设 $v = \\frac{v_{t}}{2}$：\n$$\n\\tanh\\!\\left(\\frac{g t_{1/2}}{v_{t}}\\right) = \\frac{1}{2}\n\\quad \\Rightarrow \\quad\n\\frac{g t_{1/2}}{v_{t}} = \\operatorname{artanh}\\!\\left(\\frac{1}{2}\\right).\n$$\n使用 $\\operatorname{artanh}(x) = \\frac{1}{2} \\ln\\!\\left(\\frac{1+x}{1-x}\\right)$，我们得到\n$$\n\\operatorname{artanh}\\!\\left(\\frac{1}{2}\\right) = \\frac{1}{2} \\ln(3),\n$$\n由此可得\n$$\nt_{1/2} = \\frac{v_{t}}{2 g} \\ln(3).\n$$", "answer": "$$\\boxed{\\frac{v_{t}}{2 g}\\ln(3)}$$", "id": "1923884"}, {"introduction": "虽然解析解优雅而深刻，但在许多真实的复杂问题中，例如考虑了二次空气阻力的二维抛体运动，它们却非常罕见。这正是计算物理学成为不可或缺工具的原因。在这个实践中，你将从第一性原理出发，构建一个数值模拟程序来模拟炮弹的轨迹，并判断它能否越过城墙，这个任务将基础物理原理与现代计算问题解决方法紧密结合。[@problem_id:2430459]", "problem": "一枚质量为 $m$ 的炮弹从地面发射，初速度为 $v_0$，发射角为水平线上方 $\\theta$。运动发生在大小为 $g$ 的匀强重力场中，炮弹受到与速度平方成正比的二次空气动力阻力。空气密度为 $\\rho$，炮弹被建模为半径为 $r$、阻力系数为 $C_d$、横截面积为 $A = \\pi r^2$ 的刚性球体。阻力始终与瞬时速度方向相反。在距离发射点水平距离 $D$ 处，有一座高度为 $H$ 的垂直城堡墙壁。任务是通过第一性原理和数值模拟，确定炮弹是否能越过墙壁，越过墙壁的定义为：在炮弹落地前，其在水平位置 $x = D$ 处的高度大于或等于 $H$。\n\n您的程序必须：\n- 从基本物理定律（牛顿第二定律和运动学定义）出发，建立炮弹在匀强重力和二次空气阻力下的运动方程。\n- 实现一个时间推进的数值积分器，以演化系统状态 $(x(t), y(t), v_x(t), v_y(t))$，从 $t = 0$ 开始，直到发生以下条件之一：\n    1. 水平位置达到或超过墙壁位置 ($x \\ge D$）。\n    2. 炮弹击中地面 ($y < 0$）。\n    3. 超过预设的最大模拟时间（声明未能到达墙壁）。\n- 当满足条件 $x \\ge D$ 时，通过在包围 $D$ 的最后两个时间步之间进行线性插值，计算出在 $x=D$ 处的垂直位置，并将其与 $H$ 比较，以判断是否越过墙壁。\n- 如果炮弹在到达 $x = D$ 之前击中地面，或者在达到最大模拟时间时仍未到达 $x \\ge D$，则声明未越过墙壁。\n\n所有量都必须用国际单位制 (SI) 表示：长度单位为 $\\mathrm{m}$，质量单位为 $\\mathrm{kg}$，时间单位为 $\\mathrm{s}$，重力加速度单位为 $\\mathrm{m/s^2}$。使用 $g = 9.81\\,\\mathrm{m/s^2}$。角度 $\\theta$ 以度为单位指定。\n\n测试套件：\n使用以下五个测试用例。对于每个用例，输出一个布尔值，指示炮弹是否越过墙壁（如果越过则为 True，否则为 False）。所有用例的参数使用相同的空气密度 $\\rho$ 和重力加速度 $g$，但其他参数可能因用例而异。\n\n通用参数：\n- $\\rho = 1.225\\,\\mathrm{kg/m^3}$，\n- $g = 9.81\\,\\mathrm{m/s^2}$。\n\n各用例参数：\n1. 用例 1（理想情况，轻松越过）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 200.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 100.0\\,\\mathrm{m}$，$H = 10.0\\,\\mathrm{m}$。\n2. 用例 2（边界情况：纯垂直发射，永远无法到达墙壁）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 100.0\\,\\mathrm{m/s}$，$\\theta = 90.0^\\circ$，$D = 50.0\\,\\mathrm{m}$，$H = 5.0\\,\\mathrm{m}$。\n3. 用例 3（边界情况：墙壁在发射点）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 100.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 0.0\\,\\mathrm{m}$，$H = 1.0\\,\\mathrm{m}$。\n4. 用例 4（低速，真空极限情况，测试在到达墙壁前落地）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.0$，$v_0 = 20.0\\,\\mathrm{m/s}$，$\\theta = 10.0^\\circ$，$D = 30.0\\,\\mathrm{m}$，$H = 0.1\\,\\mathrm{m}$。\n5. 用例 5（合理的中世纪高性能射击，在一定距离上越过）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 250.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 300.0\\,\\mathrm{m}$，$H = 30.0\\,\\mathrm{m}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的布尔值列表。例如，一个包含五个结果的有效输出形式为“[True,False,True,False,True]”。不应打印任何其他文本。\n\n角度单位要求：\n角度 $\\theta$ 以度为单位提供，在进行任何三角计算时必须在内部转换为弧度。\n\n单位要求：\n所有内部计算均使用国际单位制；比较结果是无单位的布尔值。判断是否越过墙壁是将插值得到的高度 $y(D)$（单位为 $\\mathrm{m}$）与墙高 $H$（单位为 $\\mathrm{m}$）进行比较。\n\n您的程序必须是一个完整的、可运行的程序，该程序对上述测试套件进行了硬编码，并打印出所要求的单行输出。", "solution": "我们从牛顿第二定律和运动学出发。设 $(x(t), y(t))$ 表示炮弹的位置，$(v_x(t), v_y(t))$ 表示其速度分量，速率为 $v(t) = \\sqrt{v_x(t)^2 + v_y(t)^2}$。质量为 $m$，重力大小为 $g$，方向向下。在中等雷诺数下的稳定流中，球体所受的阻力被建模为与速度的二次方成正比，其大小为 $\\frac{1}{2}\\rho C_d A v(t)^2$，方向与瞬时速度相反。这里 $\\rho$ 是空气密度，$C_d$ 是阻力系数，$A = \\pi r^2$ 是横截面积。\n\n根据牛顿第二定律，\n$$\nm \\frac{d\\mathbf{v}}{dt} = \\mathbf{F}_g + \\mathbf{F}_d,\n$$\n其中 $\\mathbf{F}_g = (0, - m g)$ 且 $\\mathbf{F}_d = - \\frac{1}{2} \\rho C_d A \\, v \\, \\mathbf{v}$，因为 $v \\, \\mathbf{v}$ 等于沿 $\\mathbf{v}$ 方向大小为 $v^2$ 的向量，而负号强制其与运动方向相反。用分量表示，\n$$\n\\frac{dv_x}{dt} = - \\frac{\\frac{1}{2} \\rho C_d A}{m} \\, v \\, v_x, \\quad\n\\frac{dv_y}{dt} = - g - \\frac{\\frac{1}{2} \\rho C_d A}{m} \\, v \\, v_y.\n$$\n运动学给出\n$$\n\\frac{dx}{dt} = v_x, \\quad \\frac{dy}{dt} = v_y.\n$$\n\n从地面（$x(0)=0$, $y(0)=0$）发射的初始条件（$t=0$）由初速度 $v_0$ 和角度 $\\theta$（以度为单位，转换为弧度 $\\theta_\\mathrm{rad}$）确定：\n$$\nv_x(0) = v_0 \\cos(\\theta_\\mathrm{rad}), \\quad v_y(0) = v_0 \\sin(\\theta_\\mathrm{rad}).\n$$\n\n这些耦合的、非线性的、一阶常微分方程在二次阻力下通常没有闭式解，因此我们采用数值方法求解。一个稳健的选择是经典的四阶 Runge–Kutta (RK4) 方法。对于状态向量 $\\mathbf{s} = (x, y, v_x, v_y)$ 和时间步长 $\\Delta t$，定义右侧函数 $\\mathbf{f}(\\mathbf{s}) = (v_x, v_y, a_x, a_y)$，其中\n$$\na_x = - \\frac{1}{2} \\frac{\\rho C_d A}{m} v v_x, \\quad a_y = - g - \\frac{1}{2} \\frac{\\rho C_d A}{m} v v_y, \\quad v = \\sqrt{v_x^2 + v_y^2}.\n$$\n在时刻 $t_n$ 给定 $\\mathbf{s}_n$ 时，RK4 通过以下方式推进到时刻 $t_{n+1} = t_n + \\Delta t$ 时的 $\\mathbf{s}_{n+1}$：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= \\mathbf{f}(\\mathbf{s}_n), \\\\\n\\mathbf{k}_2 &= \\mathbf{f}\\left(\\mathbf{s}_n + \\tfrac{1}{2}\\Delta t \\, \\mathbf{k}_1 \\right), \\\\\n\\mathbf{k}_3 &= \\mathbf{f}\\left(\\mathbf{s}_n + \\tfrac{1}{2}\\Delta t \\, \\mathbf{k}_2 \\right), \\\\\n\\mathbf{k}_4 &= \\mathbf{f}\\left(\\mathbf{s}_n + \\Delta t \\, \\mathbf{k}_3 \\right), \\\\\n\\mathbf{s}_{n+1} &= \\mathbf{s}_n + \\frac{\\Delta t}{6} \\left( \\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4 \\right).\n\\end{aligned}\n$$\n\n终止与事件处理：\n- 我们向前积分，直到满足三个条件之一：(i) 水平方向上达到或超过墙壁 ($x \\ge D$)，(ii) 炮弹撞击地面 ($y < 0$)，或 (iii) 达到最大模拟时间 $t_{\\max}$ 以避免在退化情况下（例如，水平速度为零）出现无限循环。\n- 为了在墙壁精确位置 $x = D$ 处评估垂直位置，我们在满足 $x_\\text{prev} < D \\le x_\\text{next}$ 的最后两个积分状态之间执行线性插值。将这两个包围状态表示为 $(x_\\text{prev}, y_\\text{prev})$ 和 $(x_\\text{next}, y_\\text{next})$，且 $x_\\text{next} \\ne x_\\text{prev}$，插值得到的墙壁高度为\n$$\ny(D) \\approx y_\\text{prev} + \\frac{D - x_\\text{prev}}{x_\\text{next} - x_\\text{prev}} \\left( y_\\text{next} - y_\\text{prev} \\right).\n$$\n- 当且仅当 $y(D) \\ge H$ 且炮弹在到达 $x = D$ 之前未撞击地面时，才算越过墙壁。\n\n数值参数：\n- 我们使用指定的 $g = 9.81\\,\\mathrm{m/s^2}$ 和 $\\rho = 1.225\\,\\mathrm{kg/m^3}$。\n- 固定的时间步长 $\\Delta t$（例如 $\\Delta t = 10^{-3}\\,\\mathrm{s}$）为测试套件中的距离和速度在准确度和计算成本之间提供了平衡。\n- 最大模拟时间 $t_{\\max}$ 可以设置为一个足够大的值（例如，$t_{\\max} = 200\\,\\mathrm{s}$）以确保终止。\n\n正确性考量：\n- 对于平滑的右侧函数，RK4 格式在 $\\Delta t$ 上具有四阶精度。阻力和重力是状态的平滑函数，因此该方法是合适的。\n- 对于小的 $\\Delta t$ 来说，在 $x$ 方向上进行线性插值是合理的，因为状态变化平滑，且 $x_\\text{prev}$ 和 $x_\\text{next}$ 之间的距离很小。\n\n应用于测试套件：\n我们现在对每个案例进行定性分析；程序会执行精确的数值评估和比较。\n\n1. 用例 1：$m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 200.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 100.0\\,\\mathrm{m}$，$H = 10.0\\,\\mathrm{m}$。即使没有阻力，在 $x = D$ 处的高度也相当大（约为 $10^2\\,\\mathrm{m}$ 的数量级），因此计入阻力后，$y(D)$ 仍然远大于 $H$。程序产生 True。\n2. 用例 2：$\\theta = 90.0^\\circ$ 意味着 $v_x(0) = 0$。炮弹垂直运动，永远无法到达 $x = D = 50.0\\,\\mathrm{m}$，因此无法越过墙壁。程序产生 False。\n3. 用例 3：$D = 0.0\\,\\mathrm{m}$ 意味着我们将初始高度 $y(0) = 0$ 与 $H = 1.0\\,\\mathrm{m}$ 进行比较。由于 $0 < 1.0$，墙壁未被越过。程序产生 False。\n4. 用例 4：在真空 ($C_d = 0.0$) 中，$v_0 = 20.0\\,\\mathrm{m/s}$ 和 $\\theta = 10.0^\\circ$ 产生一个低矮且快速下降的弹道，在 $x$ 到达 $D = 30.0\\,\\mathrm{m}$ 之前就撞击地面（这可以在无阻力极限下进行解析验证），因此墙壁未被越过。程序产生 False。\n5. 用例 5：$v_0 = 250.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 300.0\\,\\mathrm{m}$，$H = 30.0\\,\\mathrm{m}$。炮弹在大约几秒钟内到达 $x = 300.0\\,\\mathrm{m}$，并且尽管有阻力，仍保持在相当高的高度；因此 $y(D) \\ge H$。程序产生 True。\n\n因此，五个测试用例按顺序预期的布尔值输出列表是：\n[True, False, False, False, True]。\n\n随附的程序实现了 RK4 积分器、事件检测、在 $x = D$ 处的插值，并精确打印所需的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_clearance(m, r, Cd, rho, v0, theta_deg, D, H, g=9.81, dt=1e-3, t_max=200.0):\n    \"\"\"\n    Simulate a projectile with quadratic drag and determine if it clears a wall.\n\n    Parameters:\n        m (float): mass [kg]\n        r (float): radius [m]\n        Cd (float): drag coefficient [-]\n        rho (float): air density [kg/m^3]\n        v0 (float): initial speed [m/s]\n        theta_deg (float): launch angle [deg]\n        D (float): wall horizontal distance [m]\n        H (float): wall height [m]\n        g (float): gravitational acceleration [m/s^2]\n        dt (float): time step [s]\n        t_max (float): maximum simulation time [s]\n\n    Returns:\n        bool: True if clears (y(D) >= H before ground impact), else False.\n    \"\"\"\n    # Handle trivial D == 0 without integrating\n    if D == 0.0:\n        # Launched from y=0, so cannot clear any positive H\n        return 0.0 >= H\n\n    # Cross-sectional area of sphere\n    A = np.pi * r * r\n\n    # Initial state\n    theta = np.deg2rad(theta_deg)\n    vx = v0 * np.cos(theta)\n    vy = v0 * np.sin(theta)\n    x = 0.0\n    y = 0.0\n    t = 0.0\n\n    # Precompute drag factor\n    drag_coeff_factor = 0.5 * rho * Cd * A / m\n\n    # Keep previous state for interpolation\n    prev_x, prev_y = x, y\n\n    # Integration loop using RK4\n    while t < t_max:\n        if x >= D:\n            break\n        if y < 0.0:\n            # Impacted ground before reaching the wall\n            return False\n\n        # Store current for interpolation after step\n        prev_x, prev_y = x, y\n\n        # Define RHS function\n        def rhs(state):\n            sx, sy, svx, svy = state\n            v = np.hypot(svx, svy)\n            ax = -drag_coeff_factor * v * svx\n            ay = -g - drag_coeff_factor * v * svy\n            return np.array([svx, svy, ax, ay], dtype=float)\n\n        state = np.array([x, y, vx, vy], dtype=float)\n\n        k1 = rhs(state)\n        k2 = rhs(state + 0.5 * dt * k1)\n        k3 = rhs(state + 0.5 * dt * k2)\n        k4 = rhs(state + dt * k3)\n\n        state_next = state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n        x, y, vx, vy = state_next\n        t += dt\n\n        # Check if we have crossed or reached the wall this step\n        if x >= D:\n            dx = x - prev_x\n            if dx == 0.0:\n                # No horizontal progress; cannot interpolate meaningfully\n                # Let the loop continue (will hit t_max or ground)\n                continue\n            # Linear interpolation to find y at x = D\n            frac = (D - prev_x) / dx\n            y_at_D = prev_y + frac * (y - prev_y)\n            return y_at_D >= H\n\n    # If loop exits due to time max or other reasons without reaching D, or check at end\n    if x >= D:\n        # If exactly at or beyond D at final step, compute y_at_D by interpolation\n        dx = x - prev_x\n        if dx == 0.0:\n            # Degenerate; treat as not cleared unless y itself is defined at D (unlikely)\n            return y >= H\n        frac = (D - prev_x) / dx\n        y_at_D = prev_y + frac * (y - prev_y)\n        return y_at_D >= H\n\n    # Did not reach the wall\n    return False\n\ndef solve():\n    # Common parameters\n    rho = 1.225  # kg/m^3\n    g = 9.81     # m/s^2\n\n    # Test cases as tuples: (m, r, Cd, rho, v0, theta_deg, D, H)\n    test_cases = [\n        # Case 1: happy path, clears easily\n        (5.0, 0.06, 0.47, rho, 200.0, 45.0, 100.0, 10.0),\n        # Case 2: vertical launch; never reaches the wall\n        (5.0, 0.06, 0.47, rho, 100.0, 90.0, 50.0, 5.0),\n        # Case 3: wall at launch point\n        (5.0, 0.06, 0.47, rho, 100.0, 45.0, 0.0, 1.0),\n        # Case 4: low speed, vacuum; hits ground before reaching D\n        (5.0, 0.06, 0.0,  rho, 20.0,  10.0, 30.0, 0.1),\n        # Case 5: plausible medieval high-performance shot\n        (5.0, 0.06, 0.47, rho, 250.0, 45.0, 300.0, 30.0),\n    ]\n\n    results = []\n    for (m, r, Cd, rho_i, v0, theta_deg, D, H) in test_cases:\n        clears = simulate_clearance(\n            m=m, r=r, Cd=Cd, rho=rho_i, v0=v0,\n            theta_deg=theta_deg, D=D, H=H, g=g, dt=1e-3, t_max=200.0\n        )\n        results.append(clears)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2430459"}]}