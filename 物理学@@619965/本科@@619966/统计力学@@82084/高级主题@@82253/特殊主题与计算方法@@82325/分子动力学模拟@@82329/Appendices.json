{"hands_on_practices": [{"introduction": "分子动力学模拟的第一步是建立一个能代表我们想要研究的宏观条件的初始构型。本练习将引导你完成一个关键的初始化步骤：设置系统温度。通过一个具体案例，你将学习如何应用均分定理，通过统一缩放所有原子的速度，来确保模拟从一个精确的目标温度开始，这是保证所有后续模拟准确性的基础 [@problem_id:1981020]。", "problem": "一位计算物理专业的学生正准备进行一次分子动力学（MD）模拟，这是一种用于分析原子和分子物理运动的计算机模拟方法。该模拟将对一个液态氩系统进行建模。\n\n系统由 $N=500$ 个氩原子组成，每个原子的质量为 $m = 6.634 \\times 10^{-26}$ kg。目标是初始化系统，使其初始动能温度恰好为 $T = 120.0$ K。\n\n为实现这一目标，该学生首先使用随机数生成器为每个原子分配一个初始速度矢量。作为防止整个系统在空间中漂移的标准程序，随后会调整速度，以使质心的总动量为零。经过此校正后，测得系统中所有原子速率平方和为 $\\sum_{i=1}^{N} |\\vec{v}'_i|^2 = 3.500 \\times 10^7 \\text{ (m/s)}^2$，其中 $\\vec{v}'_i$ 是动量校正后第 $i$ 个原子的速度。\n\n为了达到期望的温度，所有这些经过校正的速度矢量 $\\vec{v}'_i$ 都必须通过一个无量纲因子 $\\lambda$ 进行统一缩放，以获得最终的初始速度 $\\vec{v}_i = \\lambda \\vec{v}'_i$。计算这个缩放因子 $\\lambda$ 所需的值。\n\n使用玻尔兹曼常数 $k_B = 1.381 \\times 10^{-23}$ J/K。将你的最终答案四舍五入到四位有效数字。", "solution": "在经典分子动力学中，瞬时动能温度由能量均分定理确定。在质心动量约束为零的情况下，平动动能的自由度数为 $f = 3N - 3$。总动能必须满足\n$$\nK = \\frac{f}{2} k_{B} T = \\frac{3N-3}{2} k_{B} T.\n$$\n对于质量为 $m$ 的相同原子，在将已经过动量校正的速度 $\\vec{v}'_{i}$ 统一缩放因子 $\\lambda$ 以得到 $\\vec{v}_{i} = \\lambda \\vec{v}'_{i}$ 后，其动能为\n$$\nK = \\frac{1}{2} m \\sum_{i=1}^{N} |\\vec{v}_{i}|^{2} = \\frac{1}{2} m \\lambda^{2} \\sum_{i=1}^{N} |\\vec{v}'_{i}|^{2}.\n$$\n将这些等式联立并求解 $\\lambda$ 可得\n$$\n\\frac{1}{2} m \\lambda^{2} \\sum_{i=1}^{N} |\\vec{v}'_{i}|^{2} = \\frac{3N-3}{2} k_{B} T\n\\;\\;\\Longrightarrow\\;\\;\n\\lambda = \\sqrt{\\frac{(3N-3) k_{B} T}{m \\sum_{i=1}^{N} |\\vec{v}'_{i}|^{2}}}.\n$$\n代入给定值 $N=500$，$k_{B} = 1.381 \\times 10^{-23}$ J/K，$T = 120.0$ K，$m = 6.634 \\times 10^{-26}$ kg，以及 $\\sum_{i=1}^{N} |\\vec{v}'_{i}|^{2} = 3.500 \\times 10^{7}$ (m/s)$^{2}$：\n$$\n\\lambda = \\sqrt{\\frac{(3 \\times 500 - 3)\\,(1.381 \\times 10^{-23})\\,(120.0)}{(6.634 \\times 10^{-26})\\,(3.500 \\times 10^{7})}}.\n$$\n计算分子：\n$$\n(3 \\times 500 - 3)\\,(1.381 \\times 10^{-23})\\,(120.0) = 1497 \\times 1.381 \\times 10^{-23} \\times 120.0 = 2.4808284 \\times 10^{-18}.\n$$\n除以 $m$：\n$$\n\\frac{2.4808284 \\times 10^{-18}}{6.634 \\times 10^{-26}} = 3.73956648 \\times 10^{7}.\n$$\n除以 $\\sum_{i} |\\vec{v}'_{i}|^{2}$：\n$$\n\\frac{3.73956648 \\times 10^{7}}{3.500 \\times 10^{7}} = 1.068447566.\n$$\n取平方根得到\n$$\n\\lambda = \\sqrt{1.068447566} \\approx 1.033657\\ldots\n$$\n四舍五入到四位有效数字，\n$$\n\\lambda = 1.034.\n$$\n单位一致，且 $\\lambda$ 是无量纲的，符合要求。", "answer": "$$\\boxed{1.034}$$", "id": "1981020"}, {"introduction": "分子动力学模拟的核心在于通过数值积分求解牛顿运动方程，而积分步长 $dt$ 的选择至关重要。过大的步长会导致能量不守恒和模拟“爆炸”，而过小的步长则会耗费不必要的计算资源。这个动手实践将让你通过一个计算实验，亲手探索一个简化模型（谐振子）的稳定性极限，从而直观地理解选择合适时间步长的理论和实践意义 [@problem_id:2458247]。", "problem": "要求您实现一个独立的、基于第一性原理的计算实验，以研究代表分子动力学 (MD) 中蛋白质刚性简正模的单一维谐振模式的时间步长稳定性。该系统是一个质量为 $m$ 的粒子，被限制在力常数为 $k$ 的谐波势中，其运动遵循牛顿第二定律。整个过程使用约化的无量纲单位；不要为任何量附加物理单位。\n\n动力学由牛顿第二定律 $m \\,\\ddot{x}(t) = - k \\, x(t)$ 定义，初始条件为 $x(0) = x_0$ 和 $\\dot{x}(0) = v_0$。总能量为 $E(t) = \\tfrac{1}{2} m \\,\\dot{x}(t)^2 + \\tfrac{1}{2} k \\, x(t)^2$。对于给定的离散时间步长 $dt$，模拟总时间为 $T$ 的运动，并在轨迹中监测 $E(t)$。\n\n如果在任何模拟步骤中发生以下三个事件中的任何一个，则定义为对于选定的 $dt$ 发生了“爆炸”：\n- 计算出的总能量 $E(t)$ 变为非有限（即，不是一个实数、有限的数）。\n- 相对能量误差超过指定容差，即在模拟结束前的任何时间 $t$，有 $\\lvert E(t) - E(0) \\rvert / E(0) > \\varepsilon$。\n- 位置的绝对值超过了从初始能量导出的一个预设界限，即对于任何 $t$，有 $\\lvert x(t) \\rvert > B \\, A_0$，其中 $A_0 = \\sqrt{2 E(0)/k}$。\n\n对于下面的每个测试用例，您将获得一个参数集 $(m, k, x_0, v_0, T, \\varepsilon, B)$ 和一个有序的时间步长列表 $[dt_1, dt_2, \\dots, dt_n]$。对每个测试用例，按给定顺序分别为列表中的每个 $dt_i$ 模拟系统，并找出列表中导致上述定义“爆炸”的最小 $dt_i$。如果所列的 $dt_i$ 均未导致爆炸，则返回哨兵值 $-1.0$。\n\n使用以下四个测试用例。下面所有的符号和数字都应解释为约化的无量纲单位。\n\n测试用例 1:\n- 参数：$m = 1.0$, $k = 1.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 100.0$, $\\varepsilon = 0.20$, $B = 100.0$。\n- 要测试的时间步长（按升序排列）：$[0.1, 0.5, 1.5, 1.9, 2.0, 2.1]$。\n\n测试用例 2:\n- 参数：$m = 1.0$, $k = 16.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 20.0$, $\\varepsilon = 0.10$, $B = 100.0$。\n- 要测试的时间步长（按升序排列）：$[0.05, 0.10, 0.30, 0.49, 0.50, 0.51]$。\n\n测试用例 3:\n- 参数：$m = 2.0$, $k = 0.5$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 50.0$, $\\varepsilon = 0.05$, $B = 1000.0$。\n- 要测试的时间步长（按升序排列）：$[0.50, 1.00, 2.00, 3.00, 3.50]$。\n\n测试用例 4:\n- 参数：$m = 1.0$, $k = 100.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 8.0$, $\\varepsilon = 0.15$, $B = 100.0$。\n- 要测试的时间步长（按升序排列）：$[0.02, 0.10, 0.19, 0.20, 0.25]$。\n\n您的程序必须产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。每个结果都必须是四舍五入到六位小数的浮点数，顺序与上述测试用例相同。例如，如果四个测试用例的结果是 $r_1$、$r_2$、$r_3$ 和 $r_4$，您的程序必须精确打印 \"[r1,r2,r3,r4]\"，其中每个 $r_i$ 都格式化为六位小数，且不含任何其他文本。\n\n角度量（如果内部出现）必须以弧度处理。此问题中的所有值在构造上都是无量纲的，因此输出中不应显示任何物理单位。", "solution": "该问题要求进行一个计算实验，以确定一维谐振子的数值积分方案的稳定性极限，该谐振子可作为分子动力学 (MD) 模拟中刚性振动模式的模型。该问题是适定的，且有科学依据。它构成了对数值积分稳定性的直接测试，这是计算科学中的一个基本概念。\n\n该系统由简谐振子的运动方程描述：\n$$\nm \\frac{d^2x}{dt^2} = -k x(t)\n$$\n其中 $m$ 是质量，$k$ 是力常数，$x(t)$ 是位置。此振子的角频率为 $\\omega = \\sqrt{k/m}$。动力学将使用离散时间步长 $dt$ 从初始条件 $x(0) = x_0$ 和 $\\dot{x}(0) = v_0$ 开始进行传播。\n\n问题陈述没有指定数值积分算法。对于牛顿力学的MD模拟，Velocity-Verlet算法因其时间可逆性和辛性而成为一个标准、广泛使用且稳健的选择，这带来了良好的长期能量守恒特性。因此，Velocity-Verlet积分器是需要实现的合适算法。\n\nVelocity-Verlet 算法包含以下步骤，用于将系统从时间 $t$ 推进到 $t+dt$：\n1.  计算半步速度：\n    $$\n    v(t + \\tfrac{1}{2}dt) = v(t) + \\tfrac{1}{2} a(t) dt\n    $$\n2.  将位置更新到完整的新时间步：\n    $$\n    x(t + dt) = x(t) + v(t + \\tfrac{1}{2}dt) dt\n    $$\n3.  计算新位置处的加速度。加速度由力 $F(x) = -kx$ 导出，因此 $a(x) = F(x)/m = -(k/m)x$：\n    $$\n    a(t + dt) = -\\frac{k}{m} x(t + dt)\n    $$\n4.  计算新时间下的全步速度：\n    $$\n    v(t + dt) = v(t + \\tfrac{1}{2}dt) + \\tfrac{1}{2} a(t + dt) dt\n    $$\n\n对于每个测试用例，我们得到一组参数 $(m, k, x_0, v_0, T, \\varepsilon, B)$ 和一个有序的时间步长列表 $[dt_1, dt_2, \\dots]$。任务是从这个列表中找出导致模拟变得不稳定或“爆炸”的最小 $dt_i$。对于给定的 $dt$，模拟运行总时间 $T$，对应于 $N_{steps} = \\lfloor T/dt \\rfloor$ 个积分步骤。\n\n在模拟循环开始之前，我们必须为爆炸判据建立基线。初始总能量 $E(0)$ 计算如下：\n$$\nE(0) = \\frac{1}{2} m v_0^2 + \\frac{1}{2} k x_0^2\n$$\n问题指出，对于所有测试用例，$x_0$、$v_0$、$m$ 和 $k$ 均为正值，确保了 $E(0) > 0$。然后定义特征振幅 $A_0$ 为：\n$$\nA_0 = \\sqrt{\\frac{2 E(0)}{k}}\n$$\n这个 $A_0$ 代表了精确解析解中的最大位移。\n\n模拟通过迭代 Velocity-Verlet 算法 $N_{steps}$ 次来进行。在每一步之后，我们获得新状态 $(x(t+dt), v(t+dt))$ 并检查三个爆炸条件：\n1.  **能量的有限性**：新步骤的总能量 $E(t+dt) = \\frac{1}{2} m v(t+dt)^2 + \\frac{1}{2} k x(t+dt)^2$ 必须是一个有限的实数。在计算上，通过检查该值是否为 `NaN`（非数值）或无穷大来验证。此条件可检测灾难性的数值溢出。\n2.  **相对能量守恒**：当前能量与初始能量的相对偏差不得超过容差 $\\varepsilon$。\n    $$\n    \\frac{\\lvert E(t+dt) - E(0) \\rvert}{E(0)} > \\varepsilon\n    $$\n    此条件检测数值积分误差何时导致总能量出现显著的、非物理的漂移，即使轨迹尚未发散到无穷大。\n3.  **位置界限**：位置的绝对值不得超过特征振幅的一个大倍数。\n    $$\n    \\lvert x(t+dt) \\rvert > B \\cdot A_0\n    $$\n    这是对轨迹发散的另一个实用性检查，用于检测粒子是否逃逸到了离势能最小值非物理的大距离处。\n\n每个测试用例的总体流程如下：\n遍历所提供的按升序排列的时间步长列表 $dt_i$。对于每个 $dt_i$：\n- 运行总时间为 $T$ 的完整模拟。\n- 在模拟的每一步，检查三个爆炸条件。\n- 如果在模拟过程中的任何时刻满足了任何一个条件，则认为此次使用 $dt_i$ 的模拟是不稳定的。这个 $dt_i$ 就是该测试用例的结果，我们接着处理下一个测试用例。\n- 如果模拟在时间 $T$ 内完成且未发生任何爆炸，则认为这个 $dt_i$是稳定的。然后我们继续测试列表中的下一个 $dt_i$。\n\n如果给定测试用例列表中的所有时间步长都导致了稳定的模拟，则该测试用例的结果为哨兵值 $-1.0$。\n\n实现将包含一个主函数，该函数遍历所有测试用例。此函数将为每个测试用例调用一个子函数，该子函数再遍历所提供的 $dt$ 值并调用一个模拟函数。模拟函数实现 Velocity-Verlet 循环和上述的稳定性检查。最终输出是每个案例的最小爆炸 $dt$ 列表，如果未找到则为 $-1.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m, k, x0, v0, T, epsilon, B, dt) -> bool:\n    \"\"\"\n    Runs a simulation of a 1D harmonic oscillator using the Velocity-Verlet algorithm.\n\n    Args:\n        m (float): Mass.\n        k (float): Force constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        T (float): Total simulation time.\n        epsilon (float): Relative energy error tolerance.\n        B (float): Position bound factor.\n        dt (float): Time step.\n\n    Returns:\n        bool: True if an explosion occurs, False otherwise.\n    \"\"\"\n    if dt <= 0:\n        return False  # A time step of zero or less is not meaningful.\n\n    num_steps = int(T / dt)\n    \n    # Initial conditions\n    x = float(x0)\n    v = float(v0)\n    \n    # Calculate initial energy and derived bounds for explosion criteria\n    e0 = 0.5 * m * v**2 + 0.5 * k * x**2\n    \n    # The problem constraints ensure e0 > 0, so no division by zero.\n    a0 = np.sqrt(2 * e0 / k)\n    x_bound = B * a0\n\n    # Initial acceleration\n    a = -(k / m) * x\n    \n    # Main simulation loop\n    for _ in range(num_steps):\n        # Velocity-Verlet integrator\n        # v(t + dt/2)\n        v_half = v + 0.5 * a * dt\n        # x(t + dt)\n        x = x + v_half * dt\n        # a(t + dt)\n        a_new = -(k / m) * x\n        # v(t + dt)\n        v = v_half + 0.5 * a_new * dt\n        \n        # Update acceleration for the next step\n        a = a_new\n        \n        # Calculate current energy at the full step\n        e_current = 0.5 * m * v**2 + 0.5 * k * x**2\n        \n        # --- Check for explosion conditions ---\n        \n        # 1. Non-finite energy (numerical overflow)\n        if not np.isfinite(e_current):\n            return True  # Explosion\n            \n        # 2. Relative energy error exceeds tolerance\n        # In the case e0 is 0, any change would be an infinite relative error.\n        # But for the given test cases, e0 is always positive.\n        if abs(e_current - e0) / e0 > epsilon:\n            return True  # Explosion\n        \n        # 3. Position exceeds bound\n        if abs(x) > x_bound:\n            return True  # Explosion\n            \n    return False  # No explosion occurred\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'params': (1.0, 1.0, 1.0, 1.0, 100.0, 0.20, 100.0),\n            'dts': [0.1, 0.5, 1.5, 1.9, 2.0, 2.1],\n        },\n        {\n            'params': (1.0, 16.0, 1.0, 1.0, 20.0, 0.10, 100.0),\n            'dts': [0.05, 0.10, 0.30, 0.49, 0.50, 0.51],\n        },\n        {\n            'params': (2.0, 0.5, 1.0, 1.0, 50.0, 0.05, 1000.0),\n            'dts': [0.50, 1.00, 2.00, 3.00, 3.50],\n        },\n        {\n            'params': (1.0, 100.0, 1.0, 1.0, 8.0, 0.15, 100.0),\n            'dts': [0.02, 0.10, 0.19, 0.20, 0.25],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, k, x0, v0, T, epsilon, B = case['params']\n        dts = case['dts']\n        \n        explosion_dt = -1.0\n        # The 'dts' lists are sorted, so we find the smallest by breaking on the first hit.\n        for dt in dts:\n            if run_simulation(m, k, x0, v0, T, epsilon, B, dt):\n                explosion_dt = dt\n                break\n        \n        results.append(f\"{explosion_dt:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2458247"}, {"introduction": "计算机模拟总是在有限尺寸的盒子中进行，但这与我们通常希望了解的宏观（无限大）系统性质存在差异。这种差异被称为“有限尺寸效应”，是解读模拟结果时必须考虑的关键因素。本练习提供了一个分析模拟数据的绝佳机会，你将学习如何利用理论模型，通过对不同系统尺寸下的模拟结果进行线性回归外推，来估算物质在热力学极限下的真实物理性质 [@problem_id:1980948]。", "problem": "一位研究人员正在进行一系列分子动力学 (MD) 模拟，以确定一种简单流体的自扩散系数 $D$。模拟在一个具有周期性边界条件的立方盒子中进行。众所周知，对于此类系统，由于有限尺寸效应，计算出的扩散系数 $D(L)$ 取决于模拟盒子的边长 $L$。一个成熟的理论模型预测，对于较大的 $L$，这种依赖关系为：\n$$D(L) = D_\\infty - \\frac{k_{H}}{L}$$\n其中 $D_\\infty$ 是热力学极限（无限大系统）下的真实扩散系数，而 $k_{H}$ 是一个取决于流体性质的常数。\n\n为了求出 $D_\\infty$，研究人员在保持数密度 $\\rho$ 恒定为 $0.80 \\, \\sigma_0^{-3}$ 的条件下，对不同粒子数 $N$ 运行了三次模拟，其中 $\\sigma_0$ 是一个特征长度单位。测得的扩散系数以 $\\sigma_0^2/\\tau_0$ 为单位记录如下，其中 $\\tau_0$ 是一个特征时间单位：\n\n| 模拟 | 粒子数 ($N$) | 测得的扩散系数 ($D/\\left(\\sigma_0^2/\\tau_0\\right)$) |\n|------------|---------------------------|----------------------------------------------------------|\n| 1          | 256                       | 1.05                                                     |\n| 2          | 512                       | 1.34                                                     |\n| 3          | 1000                      | 1.56                                                     |\n\n使用所提供的数据和理论模型，确定真实扩散系数 $D_\\infty$ 的最佳估计值。将最终答案表示为一个以 $\\sigma_0^2/\\tau_0$ 为单位的数值，并四舍五入到三位有效数字。", "solution": "我们从扩散系数的有限尺寸标度关系开始，\n$$D(L) = D_{\\infty} - \\frac{k_{H}}{L}.$$\n在数密度 $\\rho$ 固定的情况下，立方模拟盒子的边长 $L$ 与粒子数 $N$ 的关系为\n$$\\rho = \\frac{N}{L^{3}} \\quad \\Rightarrow \\quad L = \\left(\\frac{N}{\\rho}\\right)^{1/3}, \\quad \\frac{1}{L} = \\left(\\frac{\\rho}{N}\\right)^{1/3}.$$\n定义 $x \\equiv \\frac{1}{L}$ 和 $y \\equiv D(L)$。那么该模型是线性的，\n$$y = D_{\\infty} - k_{H} x.$$\n等价地，令 $s \\equiv N^{-1/3}$，则有 $x = \\rho^{1/3} s$，所以\n$$y = D_{\\infty} - \\bigl(k_{H}\\rho^{1/3}\\bigr) s.$$\n对 $s$ 进行 $y$ 的线性回归与对 $x$ 进行回归具有相同的截距 $D_{\\infty}$，因为如果对于一个正常数 $c$ 有 $x=c\\,s$，那么对于最小二乘拟合 $y=a+bs$，我们有 $a=\\bar{y} - \\frac{\\operatorname{cov}(s,y)}{\\operatorname{var}(s)}\\,\\bar{s}$，而对于 $y=a'+b'x$，我们有 $a'=\\bar{y} - \\frac{\\operatorname{cov}(x,y)}{\\operatorname{var}(x)}\\,\\bar{x}=\\bar{y} - \\frac{c\\,\\operatorname{cov}(s,y)}{c^{2}\\operatorname{var}(s)}\\,c\\,\\bar{s}=\\bar{y} - \\frac{\\operatorname{cov}(s,y)}{\\operatorname{var}(s)}\\,\\bar{s}=a$。\n\n因此我们使用 $s_{i}=N_{i}^{-1/3}$ 来拟合这三个数据点：\n$$s_{1}=256^{-1/3} \\approx 0.157490131,$$\n$$s_{2}=512^{-1/3}=0.125,$$\n$$s_{3}=1000^{-1/3}=0.1,$$\n其中 $y_{1}=1.05$，$y_{2}=1.34$，$y_{3}=1.56$。\n\n对于一条最小二乘直线 $y=a+ms$，\n$$m=\\frac{\\sum_{i=1}^{3}(s_{i}-\\bar{s})(y_{i}-\\bar{y})}{\\sum_{i=1}^{3}(s_{i}-\\bar{s})^{2}}, \\quad a=\\bar{y}-m\\,\\bar{s},$$\n其中\n$$\\bar{s}=\\frac{s_{1}+s_{2}+s_{3}}{3}\\approx \\frac{0.157490131+0.125+0.1}{3}\\approx 0.127496710,$$\n$$\\bar{y}=\\frac{1.05+1.34+1.56}{3}=\\frac{3.95}{3}\\approx 1.316666667.$$\n计算所需的总和：\n$$\\sum s_{i}y_{i}\\approx 0.157490131\\cdot 1.05+0.125\\cdot 1.34+0.1\\cdot 1.56\\approx 0.488864638,$$\n$$\\sum s_{i}^{2}\\approx (0.157490131)^{2}+0.125^{2}+0.1^{2}\\approx 0.050428141,$$\n$$\\sum s_{i}\\approx 0.382490131,\\quad \\sum y_{i}=3.95.$$\n然后，使用等价公式\n$$m=\\frac{3\\sum s_{i}y_{i}-(\\sum s_{i})(\\sum y_{i})}{3\\sum s_{i}^{2}-(\\sum s_{i})^{2}}, \\quad a=\\frac{(\\sum y_{i})(\\sum s_{i}^{2})-(\\sum s_{i})(\\sum s_{i}y_{i})}{3\\sum s_{i}^{2}-(\\sum s_{i})^{2}},$$\n我们通过数值计算得到\n$$a \\approx 2.448 \\quad \\Rightarrow \\quad D_{\\infty}\\approx 2.448.$$\n四舍五入到三位有效数字，得到\n$$D_{\\infty}\\approx 2.45 \\quad \\text{in units of } \\sigma_{0}^{2}/\\tau_{0}.$$", "answer": "$$\\boxed{2.45}$$", "id": "1980948"}]}