{"hands_on_practices": [{"introduction": "要真正掌握 Metropolis 算法，最好的方法就是亲手实践。这个练习提供了一个具体的、分步的演练，让你模拟一个在一维势能中运动的单个经典粒子。通过手动执行提议、计算能量变化以及接受或拒绝这些步骤，你将清晰地理解构成任何蒙特卡洛模拟核心的循环过程，从而揭开该算法的神秘面纱 [@problem_id:2005962]。", "problem": "一个经典粒子在一维空间中运动，其所受势能为 $V(x) = x^4 - 2x^2$。该粒子与温度为 $T$ 的热浴处于热平衡状态。我们希望通过使用 Metropolis 算法进行一次小规模的蒙特卡洛模拟，来估算其平均势能 $\\langle V \\rangle$。\n\n该模拟以离散步的方式进行。从初始位置 $x_0$ 开始，在第 $i$ 步，通过一个随机步长 $\\delta_i$ 提出了一个新的位置 $x_{new}$：$x_{new} = x_{old} + \\delta_i$。势能的变化为 $\\Delta V = V(x_{new}) - V(x_{old})$。提议的移动被接受的概率 $P_{acc}$ 由下式给出：\n$$P_{acc} = \\min\\left(1, \\exp\\left(-\\frac{\\Delta V}{k_B T}\\right)\\right)$$\n为了决定是否接受该移动，我们将一个从区间 $[0, 1)$ 中均匀抽取的随机数 $r_i$ 与 $P_{acc}$ 进行比较。如果 $r_i  P_{acc}$，则接受该移动，粒子的新位置为 $x_i = x_{new}$。如果 $r_i \\ge P_{acc}$，则拒绝该移动，粒子保持在旧位置，即 $x_i = x_{old}$。注意，在任何一种情况下，该构型（无论是新构型还是重复的旧构型）都会被添加到轨迹中，用于计算平均值。\n\n本次模拟使用以下参数：\n- 热能为 $k_B T = 1.0$（任意能量单位）。势能 $V(x)$ 也用相同的单位表示。\n- 粒子的初始位置为 $x_0 = 1.0$。\n- 您将模拟 4 步（从 $i=1$ 到 $i=4$）。\n- 随机步长位移序列为：$\\delta_1 = 0.40$, $\\delta_2 = -0.30$, $\\delta_3 = 0.10$, $\\delta_4 = -0.50$。\n- 用于接受检验的随机数序列为：$r_1 = 0.50$, $r_2 = 0.20$, $r_3 = 0.90$, $r_4 = 0.10$。\n\n计算在包含 5 个状态（$i=0$ 时的初始状态以及 4 步中每一步之后的状态）的完整轨迹上的平均势能。将您的答案以单个实数形式报告，并四舍五入到三位有效数字。", "solution": "我们使用 Metropolis 算法，势能为 $V(x)=x^{4}-2x^{2}$，热能为 $k_{B}T=1$，初始位置为 $x_{0}=1.0$，并使用给定的序列 $\\delta_{i}$ 和 $r_{i}$。在每一步，提议 $x_{\\text{new}}=x_{\\text{old}}+\\delta_{i}$，计算 $\\Delta V=V(x_{\\text{new}})-V(x_{\\text{old}})$，并以概率 $P_{\\text{acc}}=\\min\\left(1,\\exp\\left(-\\frac{\\Delta V}{k_{B}T}\\right)\\right)=\\min\\left(1,\\exp(-\\Delta V)\\right)$ 接受（因为 $k_{B}T=1$）。\n\n初始状态 $i=0$：$x_{0}=1.0$，所以\n$$\nV(x_{0})=1^{4}-2\\cdot 1^{2}=1-2=-1.\n$$\n\n步骤 $i=1$：$\\delta_{1}=0.40$。提议 $x_{\\text{new}}=1.0+0.40=1.40$。\n$$\nV(1.40)=1.40^{4}-2\\cdot 1.40^{2}=3.8416-3.92=-0.0784.\n$$\n$$\n\\Delta V=-0.0784-(-1)=0.9216,\\quad P_{\\text{acc}}=\\exp(-0.9216)\\approx 0.398.\n$$\n由于 $r_{1}=0.500.398$，拒绝。因此 $x_{1}=1.0$ 且 $V(x_{1})=-1$。\n\n步骤 $i=2$：$\\delta_{2}=-0.30$。提议 $x_{\\text{new}}=1.0-0.30=0.70$。\n$$\nV(0.70)=0.70^{4}-2\\cdot 0.70^{2}=0.2401-0.98=-0.7399.\n$$\n$$\n\\Delta V=-0.7399-(-1)=0.2601,\\quad P_{\\text{acc}}=\\exp(-0.2601)\\approx 0.771.\n$$\n由于 $r_{2}=0.200.771$，接受。因此 $x_{2}=0.70$ 且 $V(x_{2})=-0.7399$。\n\n步骤 $i=3$：$\\delta_{3}=0.10$。提议 $x_{\\text{new}}=0.70+0.10=0.80$。\n$$\nV(0.80)=0.80^{4}-2\\cdot 0.80^{2}=0.4096-1.28=-0.8704.\n$$\n$$\n\\Delta V=-0.8704-(-0.7399)=-0.1305.\n$$\n由于 $\\Delta V0$, $P_{\\text{acc}}=1$，所以接受。因此 $x_{3}=0.80$ 且 $V(x_{3})=-0.8704$。\n\n步骤 $i=4$：$\\delta_{4}=-0.50$。提议 $x_{\\text{new}}=0.80-0.50=0.30$。\n$$\nV(0.30)=0.30^{4}-2\\cdot 0.30^{2}=0.0081-0.18=-0.1719.\n$$\n$$\n\\Delta V=-0.1719-(-0.8704)=0.6985,\\quad P_{\\text{acc}}=\\exp(-0.6985)\\approx 0.498.\n$$\n由于 $r_{4}=0.100.498$，接受。因此 $x_{4}=0.30$ 且 $V(x_{4})=-0.1719$。\n\n轨迹中的势能为：\n$$\nV(x_{0})=-1,\\quad V(x_{1})=-1,\\quad V(x_{2})=-0.7399,\\quad V(x_{3})=-0.8704,\\quad V(x_{4})=-0.1719.\n$$\n总和：\n$$\nS=-1-1-0.7399-0.8704-0.1719=-3.7822.\n$$\n对 5 个状态求平均值：\n$$\n\\langle V\\rangle=\\frac{S}{5}=\\frac{-3.7822}{5}=-0.75644\\approx -0.756\\ \\text{(保留三位有效数字)}。\n$$", "answer": "$$\\boxed{-0.756}$$", "id": "2005962"}, {"introduction": "在掌握了单个粒子的模拟之后，我们现在将注意力转向由相互作用的组分构成的系统，这是统计力学中的常见情景。这个关于经典二维伊辛模型的练习 [@problem_id:2005989] 演示了如何应用 Metropolis 算法来探索多体系统的构型空间。通过这个练习，你将看到热涨落如何使得系统即使从最低能量状态出发，也能够演化到能量更高的状态。", "problem": "考虑一个磁性材料的简化模型，该模型由一个包含四个经典自旋的2x2方格晶格表示。这些自旋位于位置 $(i,j)$ 处，其中 $i,j \\in \\{1, 2\\}$，并记为 $s_{ij}$。每个自旋只能指向两个方向之一，由值 $s_{ij} = +1$ 或 $s_{ij} = -1$ 表示。系统的总能量由铁磁性Ising哈密顿量给出：\n$$H = -J \\sum_{\\langle (ij), (kl) \\rangle} s_{ij} s_{kl}$$\n其中，求和遍历晶格上所有唯一的最近邻自旋对，而 $J$ 是一个正常数耦合常数。系统初始处于铁磁基态，其中所有四个自旋都对齐：$s_{11} = s_{12} = s_{21} = s_{22} = +1$。\n\n系统通过与固定温度 $T$ 的热浴接触，进行Monte Carlo模拟演化。模拟以离散的步骤进行。在每一步中，选择一个自旋并尝试将其翻转（即改变其符号）。计算所提议的翻转导致的能量变化 $\\Delta E$。\n- 如果 $\\Delta E \\le 0$，则总是接受该翻转。\n- 如果 $\\Delta E  0$，则该翻转以概率 $P = \\exp(-\\Delta E / (k_B T))$ 被接受，其中 $k_B$ 是Boltzmann常数。\n\n为了使此问题的过程确定化，概率性决策按如下方式处理：对于需要此类决策的第 $k$ 步移动，仅当计算出的概率 $P$ 大于给定的比较值 $R_k$ 时，该移动才被接受。\n\n系统处于某一温度，其热能由 $k_B T = \\frac{4J}{\\ln 2}$ 给出。根据以下顺序执行两步模拟：\n1.  尝试翻转自旋 $s_{11}$。如果需要，此步骤的比较值为 $R_1 = 0.4$。\n2.  从第一步产生的构型开始，尝试翻转自旋 $s_{22}$。如果需要，此步骤的比较值为 $R_2 = 0.4$。\n\n计算这两步之后系统的最终能量 $H_{final}/J$。你的答案应该是一个整数。", "solution": "我们考虑一个具有开放边界条件的2x2晶格，因此对唯一最近邻对的求和恰好包括四个键：$(11)-(12)$、$(11)-(21)$、$(12)-(22)$ 和 $(21)-(22)$。Ising哈密顿量为 $H=-J\\sum_{\\langle (ij),(kl)\\rangle}s_{ij}s_{kl}$，其中 $J0$。在完全对齐的初始状态下，每对自旋的乘积均为 $s_{ij}s_{kl}=+1$，因此初始能量为\n$$\nH_{0}=-J\\,(1+1+1+1)=-4J.\n$$\n\n在格点 $p$ 处进行单自旋翻转只会改变与该格点相连的键。能量变化的标准结果是\n$$\n\\Delta E=2J\\,s_{p}\\sum_{q\\in \\text{nn}(p)}s_{q},\n$$\n其中求和遍历 $p$ 的所有最近邻。对于 $\\Delta E0$ 的情况，Metropolis接受概率为 $P=\\exp\\!\\big(-\\Delta E/(k_{B}T)\\big)$，此处的确定性规则为：当且仅当 $PR_{k}$ 时接受。\n\n第1步：提议翻转 $s_{11}$。其最近邻为 $s_{12}$ 和 $s_{21}$，初始值均为 $+1$，且 $s_{11}=+1$。因此\n$$\n\\Delta E_{1}=2J\\,(+1)\\big[(+1)+(+1)\\big]=4J0.\n$$\n当 $k_{B}T=\\frac{4J}{\\ln 2}$ 时，接受概率为\n$$\nP_{1}=\\exp\\!\\left(-\\frac{\\Delta E_{1}}{k_{B}T}\\right)=\\exp\\!\\left(-\\frac{4J}{4J/\\ln 2}\\right)=\\exp(-\\ln 2)=2^{-1}.\n$$\n由于 $2^{-1}=0.5R_{1}=0.4$，该翻转被接受。新的能量为\n$$\nH_{1}=H_{0}+\\Delta E_{1}=-4J+4J=0.\n$$\n\n第2步：从此构型开始，提议翻转 $s_{22}$。其最近邻为 $s_{12}=+1$ 和 $s_{21}=+1$，且 $s_{22}=+1$，所以\n$$\n\\Delta E_{2}=2J\\,(+1)\\big[(+1)+(+1)\\big]=4J0.\n$$\n接受概率与之前相同，\n$$\nP_{2}=\\exp\\!\\left(-\\frac{4J}{4J/\\ln 2}\\right)=2^{-1}.\n$$\n由于 $2^{-1}=0.5R_{2}=0.4$，此翻转也被接受。因此，最终能量为\n$$\nH_{\\text{final}}=H_{1}+\\Delta E_{2}=0+4J=4J,\n$$\n所以\n$$\n\\frac{H_{\\text{final}}}{J}=4.\n$$", "answer": "$$\\boxed{4}$$", "id": "2005989"}, {"introduction": "Metropolis 算法的强大之处在于其广泛的适用性，远远超出了传统的物理学问题。这个练习 [@problem_id:2412845] 将通过编写代码，使用马尔可夫链蒙特卡洛（MCMC）方法来估算圆周率 $\\pi$，以此来检验算法的通用性。这个练习不仅突出了算法在从特定概率分布（本例中为正方形上的均匀分布）中抽样以解决几何或数学问题的能力，还强调了“预烧”（burn-in）和步长调整等重要的实际编程概念。", "problem": "你需要编写一个完整、可运行的程序，通过计算一个内切于以原点为中心、边长为 $2$ 的正方形的单位半径圆的面积比来估计数学常数 $\\pi$。该正方形是集合 $\\mathcal{S} = \\{(x,y) \\in \\mathbb{R}^2 : -1 \\le x \\le 1,\\,-1 \\le y \\le 1\\}$，该圆是集合 $\\mathcal{C} = \\{(x,y) \\in \\mathbb{R}^2 : x^2 + y^2 \\le 1\\}$ 。常数 $\\pi$ 满足 $\\pi = 4 \\cdot \\text{Area}(\\mathcal{C}) / \\text{Area}(\\mathcal{S})$，其中 $\\text{Area}(\\mathcal{S}) = 4$ 且 $\\text{Area}(\\mathcal{C}) = \\pi$。你的程序必须使用基于指定标准差的对称高斯位移的可逆马尔可夫链，在 $\\mathcal{S}$ 中生成一个具有均匀平稳分布的平稳点序列。在每一步中，将提议的位移加到当前点上；如果提议的点位于 $\\mathcal{S}$ 内，则接受该点，否则链将停留在当前点。使用 $\\mathcal{C}$ 的指示函数的长期平均值来生成 $\\pi$ 的估计量。\n\n对于每个独立案例，指定了以下参数：在丢弃长度为 $N_{\\mathrm{burn}}$ 的初始老化（burn-in）段后用于估计的样本数 $N$，高斯位移尺度 $s  0$，初始点 $(x_0,y_0) \\in \\mathcal{S}$，以及用于初始化伪随机数生成器的整数随机种子 $\\sigma_{\\mathrm{seed}}$。估计量必须按如下方式计算：\n$$\n\\widehat{\\pi} = 4 \\cdot \\frac{1}{N} \\sum_{t=1}^{N} \\mathbf{1}\\{X_t^2 + Y_t^2 \\le 1\\},\n$$\n其中 $\\{(X_t,Y_t)\\}_{t=1}^{N}$ 是丢弃前 $N_{\\mathrm{burn}}$ 次转移后链的最后 $N$ 个状态。\n\n你的程序必须精确实现以下测试套件，每个元素格式为 $(N, N_{\\mathrm{burn}}, s, x_0, y_0, \\sigma_{\\mathrm{seed}})$：\n- 案例 A（通用情况）：$(N = 200000,\\, N_{\\mathrm{burn}} = 1000,\\, s = 0.5,\\, x_0 = 0.0,\\, y_0 = 0.0,\\, \\sigma_{\\mathrm{seed}} = 12345)$。\n- 案例 B（因步长小导致的高相关性）：$(N = 60000,\\, N_{\\mathrm{burn}} = 1000,\\, s = 0.05,\\, x_0 = 0.9,\\, y_0 = -0.9,\\, \\sigma_{\\mathrm{seed}} = 2024)$。\n- 案例 C（因步长大导致的频繁拒绝）：$(N = 60000,\\, N_{\\mathrm{burn}} = 1000,\\, s = 3.0,\\, x_0 = 0.0,\\, y_0 = 0.0,\\, \\sigma_{\\mathrm{seed}} = 9876)$。\n- 案例 D（边界起始，短时间运行）：$(N = 10000,\\, N_{\\mathrm{burn}} = 1000,\\, s = 0.5,\\, x_0 = 1.0,\\, y_0 = 1.0,\\, \\sigma_{\\mathrm{seed}} = 4242)$。\n\n对于每个案例，生成估计值 $\\widehat{\\pi}$，结果为四舍五入到六位小数的实数。不涉及物理单位。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\widehat{\\pi}_{\\text{A}}, \\widehat{\\pi}_{\\text{B}}, \\widehat{\\pi}_{\\text{C}}, \\widehat{\\pi}_{\\text{D}}]$。", "solution": "所提出的问题是计算物理学中的一个有效练习，特别是在马尔可夫链蒙特卡罗（MCMC）方法的应用方面。它在科学上是合理的、定义明确的，并且为可复现的数值实验提供了所有必要的参数。我们将继续进行求解。\n\n其基本原理是通过计算一个圆与其外切正方形的面积之比来估计常数 $\\pi$。我们给定了一个正方形域 $\\mathcal{S} = \\{(x,y) \\in \\mathbb{R}^2 : -1 \\le x \\le 1,\\,-1 \\le y \\le 1\\}$ 和一个内切圆 $\\mathcal{C} = \\{(x,y) \\in \\mathbb{R}^2 : x^2 + y^2 \\le 1\\}$。正方形的面积是 $\\text{Area}(\\mathcal{S}) = (2)^2 = 4$，单位半径圆的面积是 $\\text{Area}(\\mathcal{C}) = \\pi (1)^2 = \\pi$。因此，这些面积的比率为：\n$$\n\\frac{\\text{Area}(\\mathcal{C})}{\\text{Area}(\\mathcal{S})} = \\frac{\\pi}{4}\n$$\n这意味着 $\\pi = 4 \\cdot \\frac{\\text{Area}(\\mathcal{C})}{\\text{Area}(\\mathcal{S})}$。\n\n我们可以使用蒙特卡罗方法来估计这个面积比。如果我们在正方形 $\\mathcal{S}$ 内生成均匀分布的点 $(X,Y)$，那么一个给定的点也落入圆 $\\mathcal{C}$ 内的概率正是这个面积比。令 $\\mathbf{1}_{\\mathcal{C}}(x,y)$ 为指示函数，如果 $(x,y) \\in \\mathcal{C}$，其值等于 $1$，否则等于 $0$。根据大数定律，对于来自 $\\mathcal{S}$ 上均匀分布的 $N$ 个独立同分布点序列 $\\{(X_t, Y_t)\\}_{t=1}^{N}$，我们有：\n$$\n\\lim_{N \\to \\infty} \\frac{1}{N} \\sum_{t=1}^{N} \\mathbf{1}_{\\mathcal{C}}(X_t, Y_t) = E[\\mathbf{1}_{\\mathcal{C}}(X,Y)] = P((X,Y) \\in \\mathcal{C}) = \\frac{\\text{Area}(\\mathcal{C})}{\\text{Area}(\\mathcal{S})} = \\frac{\\pi}{4}\n$$\n这就得到了估计量 $\\widehat{\\pi} = 4 \\cdot \\frac{1}{N} \\sum_{t=1}^{N} \\mathbf{1}_{\\mathcal{C}}(X_t, Y_t)$。\n\n然而，问题规定了点序列必须通过一个特定的马尔可夫链生成，而不是通过独立抽样。当从一个分布中直接抽样困难时，这是一种常用且强大的技术。在这里，我们必须从 $\\mathcal{S}$ 上的均匀分布中抽样。指定的算法是 Metropolis-Hastings 算法的一个实例。\n\n令链在步骤 $k$ 的状态为 $Z_k = (X_k, Y_k) \\in \\mathcal{S}$。要生成下一个状态 $Z_{k+1}$，我们遵循一个两步过程：\n$1$. **提议：** 从提议分布 $q(Z'|Z_k)$ 生成一个候选点 $Z'_{k+1}$。问题指定了对称高斯位移，因此 $Z'_{k+1} = Z_k + \\epsilon_k$，其中 $\\epsilon_k$ 是从每个分量的均值为 $(0,0)$、标准差为 $s$ 的高斯分布中抽取的二维随机变量。提议的对称性意味着 $q(Z'|Z) = q(Z|Z')$。\n\n$2$. **接受/拒绝：** 候选点 $Z'_{k+1}$ 以概率 $\\alpha(Z'_{k+1}|Z_k)$ 被接受。对于对称提议，这个概率简化为：\n$$\n\\alpha(Z'_{k+1}|Z_k) = \\min\\left(1, \\frac{p(Z'_{k+1})}{p(Z_k)}\\right)\n$$\n其中 $p(Z)$ 是目标概率密度函数。我们的目标是 $\\mathcal{S}$ 上的均匀分布，因此对于 $Z \\in \\mathcal{S}$，$p(Z)$ 是一个常数，否则为 $0$。\n- 如果 $Z'_{k+1}$ 在正方形 $\\mathcal{S}$ 内，则 $p(Z'_{k+1}) = p(Z_k)  0$，所以 $\\frac{p(Z'_{k+1})}{p(Z_k)} = 1$，接受概率 $\\alpha$ 为 $1$。提议的点总是被接受。\n- 如果 $Z'_{k+1}$ 在正方形 $\\mathcal{S}$ 外，则 $p(Z'_{k+1}) = 0$，所以 $\\alpha = 0$。提议的点总是被拒绝。\n\n如果提议被接受，下一个状态是 $Z_{k+1} = Z'_{k+1}$。如果被拒绝，链将停留在当前状态，所以 $Z_{k+1} = Z_k$。这个逻辑与问题描述完全匹配：“如果提议的点位于 $\\mathcal{S}$ 内，则接受该点，否则链将停留在当前点”。这种构造保证了马尔可夫链的平稳分布是 $\\mathcal{S}$ 上的均匀分布。\n\n对于每个测试案例 $(N, N_{\\mathrm{burn}}, s, x_0, y_0, \\sigma_{\\mathrm{seed}})$，模拟过程如下：\n$1$. 用种子 $\\sigma_{\\mathrm{seed}}$ 初始化伪随机数生成器。\n$2$. 将链的初始状态设置为 $Z_0 = (x_0, y_0)$。\n$3$. 运行链 $N_{\\mathrm{burn}}$ 步（“老化”期）。这是为了让链从其初始状态 $Z_0$ 收敛到其平稳分布。这些样本被丢弃，不用于估计。\n$4$. 继续运行链 $N$ 步。令此状态序列为 $\\{Z_t\\}_{t=1}^{N}$。\n$5$. 对于该序列中的每个状态 $Z_t = (X_t, Y_t)$，我们计算指示函数 $\\mathbf{1}_{\\mathcal{C}}(Z_t) = \\mathbf{1}\\{X_t^2 + Y_t^2 \\le 1\\}$。\n$6$. 然后，根据马尔可夫链的遍历定理（这与大数定律类似）计算 $\\pi$ 的估计量：\n$$\n\\widehat{\\pi} = 4 \\cdot \\frac{1}{N} \\sum_{t=1}^{N} \\mathbf{1}\\{X_t^2 + Y_t^2 \\le 1\\}\n$$\n所提供的代码将为每个指定的测试案例实现这个精确的过程，最终的数值结果按要求四舍五入到六位小数。参数 $s$ 控制提议的步长。一个非常小的 $s$（案例 B）将导致高接受率但状态空间探索缓慢，从而导致样本之间的高度自相关。一个非常大的 $s$（案例 C）将导致大多数提议落到 $\\mathcal{S}$ 之外，从而导致高拒绝率，链会长时间停留在同一个位置。一个最优的 $s$ 会在这两种效应之间取得平衡，以确保高效采样。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for estimating pi using a Markov Chain Monte Carlo method.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Format: (N, N_burn, s, x0, y0, sigma_seed)\n    test_cases = [\n        (200000, 1000, 0.5, 0.0, 0.0, 12345),   # Case A\n        (60000, 1000, 0.05, 0.9, -0.9, 2024),   # Case B\n        (60000, 1000, 3.0, 0.0, 0.0, 9876),    # Case C\n        (10000, 1000, 0.5, 1.0, 1.0, 4242)     # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        pi_estimate = run_mcmc_pi_estimation(*case)\n        results.append(pi_estimate)\n\n    # Format the results as strings rounded to six decimal places\n    # The problem asks for the number to be rounded, then converted to a string.\n    formatted_results = [str(round(res, 6)) for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_mcmc_pi_estimation(N, N_burn, s, x0, y0, sigma_seed):\n    \"\"\"\n    Estimates pi using a Markov chain on a square domain.\n\n    Args:\n        N (int): Number of samples for estimation after burn-in.\n        N_burn (int): Number of burn-in samples to discard.\n        s (float): Standard deviation of the Gaussian displacement.\n        x0 (float): Initial x-coordinate.\n        y0 (float): Initial y-coordinate.\n        sigma_seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        float: The estimate of pi.\n    \"\"\"\n    # Initialize the pseudorandom number generator for reproducibility.\n    rng = np.random.default_rng(seed=sigma_seed)\n\n    # Set the initial point of the Markov chain.\n    current_point = np.array([x0, y0])\n\n    points_in_circle_count = 0\n    total_iterations = N_burn + N\n\n    for i in range(total_iterations):\n        # 1. Propose a new point using a symmetric Gaussian displacement.\n        displacement = rng.normal(loc=0.0, scale=s, size=2)\n        proposed_point = current_point + displacement\n\n        # 2. Apply acceptance/rejection rule.\n        # Check if the proposed point is within the square S = [-1, 1] x [-1, 1].\n        if np.all(np.abs(proposed_point) = 1.0):\n            # Accept the proposal.\n            current_point = proposed_point\n        # else: reject the proposal, the point remains the same.\n        \n        # After the burn-in period, start collecting samples for the estimation.\n        if i = N_burn:\n            # Check if the current point is inside the unit circle C.\n            # The condition is x^2 + y^2 = 1.\n            if np.sum(current_point**2) = 1.0:\n                points_in_circle_count += 1\n    \n    # 3. Compute the estimator for pi.\n    # The ratio of points in the circle to total samples approximates Area(C)/Area(S) = pi/4.\n    if N == 0:\n        return 0.0\n    \n    pi_estimate = 4.0 * points_in_circle_count / N\n    \n    return pi_estimate\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2412845"}]}