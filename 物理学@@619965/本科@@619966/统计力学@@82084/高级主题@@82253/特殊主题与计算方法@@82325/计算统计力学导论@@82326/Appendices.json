{"hands_on_practices": [{"introduction": "要掌握计算统计力学，最好的起点是亲手实现其最核心的算法之一：Metropolis 蒙特卡洛方法。这个方法通过模拟系统的热涨落，使我们能够计算其在热平衡状态下的宏观性质。本练习 [@problem_id:1971585] 将通过一个简单的一维三态自旋链模型，引导您一步步手动执行 Metropolis 算法的核心逻辑：提出一个随机的系统状态变化，计算其引起的能量变化 $\\Delta E$，并根据这一变化决定是接受还是拒绝该变化。通过这个具体的计算过程，您将建立起对蒙特卡洛模拟如何工作的直观理解。", "problem": "考虑一个简化的聚合物链一维模型，该模型由 $N=4$ 个链段在一个圆环上排列组成，使得最后一个链段与第一个相连（周期性边界条件）。每个链段 $i$ 可以存在于三种构象态之一，由变量 $S_i \\in \\{-1, 0, +1\\}$ 表示。该聚合物链的总能量由以下哈密顿量描述：\n$$H = -J \\sum_{i=1}^{4} S_i S_{i+1}$$\n其中索引对 4 取模（即 $S_5 \\equiv S_1$）。参数 $J$ 是一个正的耦合常数，代表相邻链段之间的相互作用能。给定 $J = 1.0 \\text{ eV}$。系统与温度为 $T$ 的热浴处于热平衡状态，使得热能为 $k_B T = 1.5 \\text{ eV}$，其中 $k_B$ 是玻尔兹曼常数。\n\n系统的构型通过一系列离散时间步演化，这可使用蒙特卡洛（MC）过程进行模拟。在每一步中，选择单个链段，并为其提议一个新状态。提议的改变根据以下规则被接受或拒绝：\n1. 计算能量变化 $\\Delta E = E_{\\text{new}} - E_{\\text{current}}$，其中 $E_{\\text{current}}$ 是改变前的能量，$E_{\\text{new}}$ 是提议的新构型的能量。\n2. 如果 $\\Delta E \\le 0$，该改变总是被接受。\n3. 如果 $\\Delta E > 0$，该改变以概率 $P = \\exp(-\\Delta E / (k_B T))$ 被接受。为实现这一点，会生成一个在 $[0, 1)$ 上均匀分布的随机数 $r$。如果 $r < P$，则接受改变；否则，拒绝改变，系统保持其当前状态。\n\n假设系统从初始构型 $(S_1, S_2, S_3, S_4) = (+1, -1, +1, -1)$ 开始。请您按照下表中的详细说明，手动执行 4 个连续的更新步骤。\n\n| 步骤 ($k$) | 待更新链段 | 提议的新状态 | 随机数 ($r_k$) |\n| :---: | :---: | :---: | :---: |\n| 1 | $S_2$ | $0$ | 不适用 |\n| 2 | $S_4$ | $+1$ | 不适用 |\n| 3 | $S_1$ | $0$ | $0.80$ |\n| 4 | $S_3$ | $-1$ | $0.10$ |\n\n计算系统的平均能量，其定义为初始状态和四个更新步骤后各状态能量的算术平均值。以 eV 为单位表示您的最终答案，并四舍五入到三位有效数字。", "solution": "哈密顿量为 $H=-J\\sum_{i=1}^{4}S_{i}S_{i+1}$，且 $S_{5}\\equiv S_{1}$。对于位点 $i$ 的单个状态改变，只有涉及 $S_{i}$ 的两个键会发生变化，因此能量变化为\n$$\n\\Delta E=-J\\left[\\left(S_{i-1}S_{i}^{\\text{new}}+S_{i}^{\\text{new}}S_{i+1}\\right)-\\left(S_{i-1}S_{i}^{\\text{old}}+S_{i}^{\\text{old}}S_{i+1}\\right)\\right].\n$$\n当 $\\Delta E\\leq 0$ 时，移动被接受；如果 $\\Delta E>0$，则以概率 $P=\\exp\\!\\left(-\\frac{\\Delta E}{k_{B}T}\\right)$ 接受，否则拒绝。\n\n初始构型 $(S_{1},S_{2},S_{3},S_{4})=(+1,-1,+1,-1)$。\n计算初始能量：\n$$\n\\sum_{i}S_{i}S_{i+1}=(-1)+(-1)+(-1)+(-1)=-4,\\quad E_{0}=-J(-4)=4J.\n$$\n\n步骤 1：更新 $S_{2}:-1\\to 0$。相邻链段为 $S_{1}=+1$, $S_{3}=+1$。\n旧的和：$(+1)(-1)+(-1)(+1)=-2$。新的和：$(+1)(0)+(0)(+1)=0$。\n$$\n\\Delta E_{1}=-J\\left[0-(-2)\\right]=-2J\\leq 0\\ \\Rightarrow\\ \\text{接受}。\n$$\n因此 $E_{1}=E_{0}+\\Delta E_{1}=4J-2J=2J$，状态变为 $(+1,0,+1,-1)$。\n\n步骤 2：更新 $S_{4}:-1\\to +1$。相邻链段为 $S_{3}=+1$, $S_{1}=+1$。\n旧的和：$(+1)(-1)+(-1)(+1)=-2$。新的和：$(+1)(+1)+(+1)(+1)=2$。\n$$\n\\Delta E_{2}=-J\\left[2-(-2)\\right]=-4J\\leq 0\\ \\Rightarrow\\ \\text{接受}。\n$$\n因此 $E_{2}=E_{1}+\\Delta E_{2}=2J-4J=-2J$，状态变为 $(+1,0,+1,+1)$。\n\n步骤 3：更新 $S_{1}:+1\\to 0$，随机数为 $r_{3}=0.80$。相邻链段为 $S_{4}=+1$, $S_{2}=0$。\n旧的和：$(+1)(+1)+(+1)(0)=1$。新的和：$(+1)(0)+(0)(0)=0$。\n$$\n\\Delta E_{3}=-J\\left[0-1\\right]=+J>0,\\quad P=\\exp\\!\\left(-\\frac{J}{k_{B}T}\\right)=\\exp\\!\\left(-\\frac{1}{1.5}\\right)=\\exp\\!\\left(-\\frac{2}{3}\\right)\\approx 0.513.\n$$\n由于 $r_{3}=0.80>P$，拒绝该移动。因此 $E_{3}=E_{2}=-2J$，状态保持 $(+1,0,+1,+1)$。\n\n步骤 4：更新 $S_{3}:+1\\to -1$，随机数为 $r_{4}=0.10$。相邻链段为 $S_{2}=0$, $S_{4}=+1$。\n旧的和：$(0)(+1)+(+1)(+1)=1$。新的和：$(0)(-1)+(-1)(+1)=-1$。\n$$\n\\Delta E_{4}=-J\\left[(-1)-1\\right]=+2J>0,\\quad P=\\exp\\!\\left(-\\frac{2J}{k_{B}T}\\right)=\\exp\\!\\left(-\\frac{2}{1.5}\\right)=\\exp\\!\\left(-\\frac{4}{3}\\right)\\approx 0.264.\n$$\n由于 $r_{4}=0.10<P$, 接受该移动。因此 $E_{4}=E_{3}+\\Delta E_{4}=-2J+2J=0$，状态变为 $(+1,0,-1,+1)$。\n\n五个构型（初始构型加四个步骤后的构型）的能量分别为\n$$\nE_{0}=4J,\\quad E_{1}=2J,\\quad E_{2}=-2J,\\quad E_{3}=-2J,\\quad E_{4}=0.\n$$\n平均能量为\n$$\n\\bar{E}=\\frac{E_{0}+E_{1}+E_{2}+E_{3}+E_{4}}{5}=\\frac{4J+2J-2J-2J+0}{5}=\\frac{2}{5}J.\n$$\n当 $J=1.0\\ \\text{eV}$ 时，$\\bar{E}=\\frac{2}{5}\\ \\text{eV}=0.4\\ \\text{eV}$，保留三位有效数字为 $0.400\\ \\text{eV}$。", "answer": "$$\\boxed{0.400}$$", "id": "1971585"}, {"introduction": "Metropolis 算法的强大之处在于其广泛的适用性。它不仅限于模拟自旋系统，同样可以应用于描述由空间坐标定义的粒子系统。本练习 [@problem_id:1971599] 要求您将 Metropolis 算法应用于一个在一维离散格点上运动的单个粒子，该粒子处于一个不对称的线性势场中。通过这个实践，您将学会如何处理边界条件，并理解势能梯度如何通过接受概率影响粒子的平衡位置分布，从而加深对细致平衡原理和算法通用性的认识。", "problem": "我们通过计算模拟研究一个单粒子。该粒子被限制在一个一维离散格子上运动，格点位置为 $x=0, 1, 2, 3$。该粒子处于一个维持在恒定温度 $T$ 的系统中，并受到一个由 $U(x) = \\alpha x$ 给出的非对称势能函数的作用，其中 $\\alpha$ 是一个正的能量常数。系统的热能被设定为 $k_B T = \\alpha$，其中 $k_B$ 是玻尔兹曼常数。\n\n粒子的运动使用Metropolis算法进行模拟。粒子初始位于位置 $x_{initial} = 2$。模拟以离散时间步进行。在每一步中，会向一个相邻格点提出一个尝试移动，$x_{trial} = x_{current} \\pm 1$。移动提议的方向由一个从 $[0, 1)$ 的均匀分布中抽取的伪随机数 $r_p$ 决定。如果 $r_p < 0.5$，提议的移动是向左 ($x \\to x-1$)；如果 $r_p \\ge 0.5$，提议的移动是向右 ($x \\to x+1$)。如果提议的位置超出了允许的格点范围 $\\{0, 1, 2, 3\\}$，则该移动被自动拒绝，粒子在下一步的位置与其当前位置相同。\n\n如果提议的移动是到一个有效格点，则计算势能的变化量 $\\Delta U = U(x_{trial}) - U(x_{current})$。该移动以概率 $P_{acc} = \\min(1, \\exp(-\\Delta U / (k_B T)))$ 被接受。为了实现这一点，从 $[0, 1)$ 的均匀分布中抽取第二个伪随机数 $r_a$。如果 $r_a < P_{acc}$，移动被接受，粒子的新位置是 $x_{trial}$。否则，移动被拒绝，粒子保持在 $x_{current}$。\n\n你需要进行3个步骤的模拟，从 $x_0 = x_{initial} = 2$ 开始。需要使用的伪随机数序列如下：\n用于移动提议：$r_{p,1} = 0.60$, $r_{p,2} = 0.25$, $r_{p,3} = 0.82$。\n用于接受判决：$r_{a,1} = 0.40$, $r_{a,2} = 0.90$, $r_{a,3} = 0.30$。\n\n计算在整个模拟轨迹中粒子的时间平均位置 $\\langle x \\rangle$，该轨迹包括初始位置和3个步骤之后的位置。将你的答案表示为一个实数，四舍五入到三位有效数字。", "solution": "粒子在格点 $x \\in \\{0,1,2,3\\}$ 上运动，其势能为 $U(x)=\\alpha x$，热能为 $k_{B}T=\\alpha$。对于一个提议的移动，Metropolis接受概率为\n$$\nP_{\\text{acc}}=\\min\\left(1,\\exp\\!\\left(-\\frac{\\Delta U}{k_{B}T}\\right)\\right).\n$$\n对于从 $x$ 到 $x\\pm 1$ 的最近邻移动，能量变化为 $\\Delta U=U(x\\pm 1)-U(x)=\\alpha[(x\\pm 1)-x]=\\pm \\alpha$。因此，使用 $k_{B}T=\\alpha$ 可得：\n\n$$\nP_{\\text{acc}} = \\begin{cases}\n\\min\\left(1,\\exp(-(+\\alpha)/\\alpha)\\right)=\\exp(-1), & \\text{对于 } x\\to x+1 \\\\\n\\min\\left(1,\\exp(-(-\\alpha)/\\alpha)\\right)=\\min(1,\\exp(1))=1, & \\text{对于 } x\\to x-1\n\\end{cases}\n$$\n\n因此，向左的移动（如果在边界内）总是被接受，而向右的移动以概率 $\\exp(-1)$ 被接受。\n\n模拟从 $x_{0}=2$ 开始，并使用给定的伪随机数进行三个步骤。\n\n步骤1：当前 $x=2$。提议随机数 $r_{p,1}=0.60\\geq 0.5$ 意味着提议向右移动：$x_{\\text{trial}}=3$（有效）。对于向右移动， $P_{\\text{acc}}=\\exp(-1)$。由于 $r_{a,1}=0.40$ 且 $\\exp(-1)\\approx 0.368$，我们有 $r_{a,1}>\\exp(-1)$，所以移动被拒绝。因此 $x_{1}=2$。\n\n步骤2：当前 $x=2$。提议随机数 $r_{p,2}=0.25<0.5$ 意味着提议向左移动：$x_{\\text{trial}}=1$（有效）。对于向左移动， $P_{\\text{acc}}=1$。由于 $r_{a,2}=0.90<1$，移动被接受。因此 $x_{2}=1$。\n\n步骤3：当前 $x=1$。提议随机数 $r_{p,3}=0.82\\geq 0.5$ 意味着提议向右移动：$x_{\\text{trial}}=2$（有效）。对于向右移动， $P_{\\text{acc}}=\\exp(-1)$。由于 $r_{a,3}=0.30<\\exp(-1)\\approx 0.368$，移动被接受。因此 $x_{3}=2$。\n\n包括初始位置和其后三个位置的轨迹是 $\\{x_{0},x_{1},x_{2},x_{3}\\}=\\{2,2,1,2\\}$。这四个位置的时间平均值为\n$$\n\\langle x \\rangle=\\frac{2+2+1+2}{4}=\\frac{7}{4}=1.75.\n$$\n四舍五入到三位有效数字，结果是 $1.75$。", "answer": "$$\\boxed{1.75}$$", "id": "1971599"}, {"introduction": "虽然逐点更新的 Metropolis 算法非常基础和重要，但在某些情况下（例如在相变点附近）其效率会变得很低，这种现象被称为“临界慢化”。为了解决这个问题，研究者们开发了更高级的团簇更新算法，其中最著名的就是 Wolff 算法。本练习 [@problem_id:1971630] 旨在让您亲手体验 Wolff 算法的精妙之处，您将从一个“种子”自旋开始，根据特定的概率规则 $p = 1 - \\exp(-2\\beta J)$ 递归地构建一个自旋团簇，并最终将整个团簇进行翻转。这个过程将使您直观地理解为何这种全局更新策略能够高效地模拟临界现象，并为探索更复杂的物理系统打下基础。", "problem": "在计算统计力学中，Wolff 算法是一种强大的蒙特卡罗方法，用于模拟伊辛模型，尤其是在临界温度附近。考虑一个 4x4 的自旋方格，其中每个自旋 $s_i$ 可以是向上 (+1) 或向下 (-1)。该系统遵循具有最近邻相互作用的伊辛模型。我们将应用周期性边界条件，这意味着晶格从上到下和从左到右循环包裹。\n\n晶格上自旋的初始构型如下所示，其中 `+` 表示自旋向上 (+1)，`-` 表示自旋向下 (-1)，并且我们使用基于1的（行，列）索引：\n\n```\n+ - + +\n- - + -\n+ - - +\n- + + -\n```\n\nWolff 算法的单次更新步骤如下：\n1.  随机选择一个自旋位点作为簇的“种子”。\n2.  算法接着检查种子自旋的最近邻。对于每个与种子自旋方向相同的邻居，一个键以概率 $p = 1 - \\exp(-2\\beta J)$ 被“激活”，其中 $J$ 是耦合常数，$\\beta$ 是逆温度。\n3.  如果一个键被激活，相邻的自旋被添加到簇中。这个过程递归地重复：每个新添加的自旋的邻居也根据相同的规则被考虑添加到簇中。一个自旋只被考虑添加一次。\n4.  一旦没有更多的自旋可以被添加，簇就完成了。最终簇内的所有自旋都被翻转（从 +1 变为 -1，或从 -1 变为 +1）。\n\n对于本题，我们将执行一次确定性的 Wolff 更新步骤。种子自旋选择为位点 (2, 2) 处的自旋。物理参数满足 $2\\beta J = \\ln(4)$。为消除此问题中的随机性元素，对于您需要做出的每个概率性决策，您必须按所需顺序使用以下预先确定的伪随机数序列：`0.21, 0.89, 0.45, 0.60, 0.92, 0.15, 0.77, 0.33`。如果对应的伪随机数小于概率 $p$，则键被激活。\n\n确定在这次单次更新步骤中被翻转的自旋总数。", "solution": "我们使用 Wolff 簇更新规则：对于具有相同自旋方向的最近邻之间的键，以概率 $p=1-\\exp(-2\\beta J)$ 激活。给定 $2\\beta J=\\ln(4)$，\n$$\np=1-\\exp(-\\ln(4))=1-\\frac{1}{4}=\\frac{3}{4}.\n$$\n种子在位点 $(2,2)$，从晶格中可知其自旋为 $s_{2,2}=-1$。我们对每个位点固定一个确定性的邻居处理顺序，即上、右、下、左（考虑周期性边界条件），并且我们按照位点被添加到簇中的顺序（广度优先）来处理它们。一个自旋最多只被考虑添加一次；如果它已经在簇中或已经被测试过，则跳过它，不抽取随机数。当且仅当给定序列中的下一个伪随机数小于 $p=\\frac{3}{4}$ 时，键才被激活。\n\n用种子初始化簇：簇 $C=\\{(2,2)\\}$。\n\n处理 $(2,2)$（自旋 $-1$）；按上、右、下、左的顺序检查邻居：\n- 上方 $(1,2)$ 的自旋为 $-1$（相同）。抽取 $0.21<\\frac{3}{4}$，键激活；将 $(1,2)$ 添加到 $C$ 中。\n- 右侧 $(2,3)$ 的自旋为 $+1$（相反）。跳过，不抽取。\n- 下方 $(3,2)$ 的自旋为 $-1$（相同）。抽取 $0.89\\geq\\frac{3}{4}$，键未激活；不添加；标记为已考虑。\n- 左侧 $(2,1)$ 的自旋为 $-1$（相同）。抽取 $0.45<\\frac{3}{4}$，键激活；将 $(2,1)$ 添加到 $C$ 中。\n\n队列现在依次包含 $(1,2)$ 和 $(2,1)$。\n\n处理 $(1,2)$（自旋 $-1$）；按上、右、下、左的顺序检查邻居（考虑周期性边界条件）：\n- 上方 $(4,2)$ 的自旋为 $+1$（相反）。跳过。\n- 右侧 $(1,3)$ 的自旋为 $+1$（相反）。跳过。\n- 下方 $(2,2)$ 已经在 $C$ 中。跳过，不抽取。\n- 左侧 $(1,1)$ 的自旋为 $+1$（相反）。跳过。\n此处没有添加新位点，也未使用随机数抽取。\n\n处理 $(2,1)$（自旋 $-1$）；按上、右、下、左的顺序检查邻居：\n- 上方 $(1,1)$ 的自旋为 $+1$（相反）。跳过。\n- 右侧 $(2,2)$ 已经在 $C$ 中。跳过。\n- 下方 $(3,1)$ 的自旋为 $+1$（相反）。跳过。\n- 左侧 $(2,4)$（周期性包裹）的自旋为 $-1$（相同）且尚未被考虑。抽取 $0.60<\\frac{3}{4}$，键激活；将 $(2,4)$ 添加到 $C$ 中。\n\n处理 $(2,4)$（自旋 $-1$）；按上、右、下、左的顺序检查邻居：\n- 上方 $(1,4)$ 的自旋为 $+1$（相反）。跳过。\n- 右侧 $(2,1)$ 已经在 $C$ 中。跳过。\n- 下方 $(3,4)$ 的自旋为 $+1$（相反）。跳过。\n- 左侧 $(2,3)$ 的自旋为 $+1$（相反）。跳过。\n没有添加新位点。\n\n簇的构建过程终止。最终的簇是 $C=\\{(2,2),(1,2),(2,1),(2,4)\\}$，包含 $4$ 个自旋。在 Wolff 更新中，$C$ 中的所有自旋都被翻转。因此，被翻转的自旋总数为 $4$。", "answer": "$$\\boxed{4}$$", "id": "1971630"}]}