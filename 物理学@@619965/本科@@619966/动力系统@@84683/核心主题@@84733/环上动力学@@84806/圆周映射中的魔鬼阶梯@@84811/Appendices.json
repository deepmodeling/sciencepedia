{"hands_on_practices": [{"introduction": "这个首个练习将探究圆映射旋转数的一个基本性质。通过考察当频率参数 $\\Omega$ 增加一个整数时旋转数如何变化，你将揭示一个关键的对称性，这个对称性大大简化了对整个系统的分析。掌握这一原理是理解魔鬼阶梯周期性结构的第一步 [@problem_id:1672670]。", "problem": "标准圆映射是非线性动力学研究中的一个基本模型，常用于描述周期性受迫振子锁相等现象。系统在离散时间步 $n=0, 1, 2, \\dots$ 的状态由一个角度 $\\theta_n \\in [0, 1)$ 描述。该角度的演化由以下迭代映射给出：\n$$ \\theta_{n+1} = \\left( \\theta_n + \\Omega - \\frac{K}{2\\pi} \\sin(2\\pi \\theta_n) \\right) \\pmod 1 $$\n这里，$\\Omega$ 是一个与振子固有频率相关的参数，而 $K \\ge 0$ 是与周期性驱动力的非线性耦合强度。\n\n为了分析其长期行为，我们引入该映射的一个“提升”，即实线上的一个变量 $X_n$，它不受模运算的约束。该提升的演化遵循：\n$$ X_{n+1} = X_n + \\Omega - \\frac{K}{2\\pi} \\sin(2\\pi X_n) $$\n角度 $\\theta_n$ 可通过 $\\theta_n = X_n \\pmod 1$ 恢复。平均旋转速率由旋转数 $\\rho$ 捕捉，其定义为以下极限：\n$$ \\rho = \\lim_{n \\to \\infty} \\frac{X_n}{n} $$\n该极限若存在，则与初始条件 $X_0$ 无关。\n\n考虑该系统的一个具体实例，其中参数设置为 $\\Omega = 5$ 和 $K = 0.8$。计算该系统旋转数 $\\rho$ 的数值。", "solution": "我们考虑标准圆映射的提升，\n$$\nf_{\\Omega,K}(x) = x + \\Omega - \\frac{K}{2\\pi}\\sin(2\\pi x),\n$$\n使得 $X_{n+1} = f_{\\Omega,K}(X_n)$，且当极限存在时，旋转数为 $\\rho(\\Omega,K) = \\lim_{n\\to\\infty} \\frac{X_n}{n}$。对于 $K<1$，提升的导数为\n$$\nf_{\\Omega,K}'(x) = 1 - K \\cos(2\\pi x) \\ge 1 - K > 0,\n$$\n因此 $f_{\\Omega,K}$ 导出保向圆微分同胚，旋转数存在且与 $X_0$ 无关（Poincaré 旋转数）。\n\n关于 $\\Omega$ 整数平移的关键可加性：对任意整数 $m$，定义 $f_{\\Omega+m,K}(x) = x + \\Omega + m - \\frac{K}{2\\pi}\\sin(2\\pi x)$。设 $X_n^{(\\Omega)}$ 和 $X_n^{(\\Omega+m)}$ 分别是在 $f_{\\Omega,K}$ 和 $f_{\\Omega+m,K}$ 下的轨道，具有相同的初始条件 $X_0^{(\\Omega)} = X_0^{(\\Omega+m)}$。定义 $Y_n = X_n^{(\\Omega)} + m n$。然后利用周期性 $\\sin(2\\pi(Y_n)) = \\sin(2\\pi X_n^{(\\Omega)} + 2\\pi m n) = \\sin(2\\pi X_n^{(\\Omega)})$，我们计算\n$$\nY_{n+1} = X_{n+1}^{(\\Omega)} + m(n+1) = \\left(X_n^{(\\Omega)} + \\Omega - \\frac{K}{2\\pi}\\sin(2\\pi X_n^{(\\Omega)})\\right) + m + m n\n= Y_n + \\Omega + m - \\frac{K}{2\\pi}\\sin(2\\pi Y_n).\n$$\n因此 $Y_n$ 满足与 $X_n^{(\\Omega+m)}$ 相同的递推关系和初始条件，故 $X_n^{(\\Omega+m)} = Y_n = X_n^{(\\Omega)} + m n$。两边同除以 $n$ 并令 $n \\to \\infty$ 可得\n$$\n\\rho(\\Omega + m, K) = \\rho(\\Omega, K) + m.\n$$\n\n因此，对于 $\\Omega = 5$，\n$$\n\\rho(5, K) = \\rho(0, K) + 5.\n$$\n\n我们现在计算当 $K=0.8$ 时的 $\\rho(0, K)$。当 $\\Omega = 0$ 时，该映射为\n$$\nf_{0,K}(x) = x - \\frac{K}{2\\pi}\\sin(2\\pi x).\n$$\n不动点满足 $f_{0,K}(x^{\\ast}) = x^{\\ast}$，即：\n$$\n\\sin(2\\pi x^{\\ast}) = 0 \\quad \\Longrightarrow \\quad x^{\\ast} \\in \\frac{1}{2}\\mathbb{Z}.\n$$\n从任何此类不动点开始，都会得到一个常数轨道 $X_n \\equiv x^{\\ast}$，因此\n$$\n\\lim_{n\\to\\infty} \\frac{X_n}{n} = 0.\n$$\n由于当 $K < 1$ 时旋转数存在且与初始条件无关，可以得出\n$$\n\\rho(0, 0.8) = 0.\n$$\n\n综合起来，我们得到\n$$\n\\rho(5, 0.8) = \\rho(0, 0.8) + 5 = 5.\n$$", "answer": "$$\\boxed{5}$$", "id": "1672670"}, {"introduction": "从广义的对称性转向阶梯的具体结构，这项练习将深入探讨魔鬼阶梯的定量特征。你将使用一个关于锁模区间宽度的简化模型，来比较不同有理数锁定的“强度”。这项实践有助于你建立直觉，理解为什么某些有理数锁定比其他锁定更显著，以及非线性如何影响阶梯的外观 [@problem_id:1672710]。", "problem": "在动力系统的研究中，圆映射为受驱振子的同步等现象提供了一个简单的模型。圆映射的一种标准形式由以下迭代给出：\n$$ \\theta_{n+1} = \\left( \\theta_n + \\Omega - \\frac{K}{2\\pi}\\sin(2\\pi\\theta_n) \\right) \\pmod 1 $$\n此处，$\\theta_n$ 代表系统在单位周长的圆上第 $n$ 步的状态，$\\Omega$ 是一个驱动参数（“裸”绕数），而 $K \\ge 0$ 是一个非线性常数。\n\n对于一组给定的参数，长期平均旋转率由绕数 $\\rho = \\lim_{n \\to \\infty} \\frac{\\theta_n - \\theta_0}{n}$ 描述。当 $K > 0$ 时，对于参数 $\\Omega$ 的某些范围，绕数 $\\rho$ 会锁定到一个有理数值 $P/Q$ 上。这些 $\\Omega$ 的区域被称为锁模区间或阿诺德舌。对于固定的 $K>0$，将 $\\rho$ 对 $\\Omega$ 作图，会形成一个复杂的自相似结构，称为“魔鬼阶梯”，它由无限多个位于每个有理数高度的平坦台阶组成。\n\n考虑该系统的一个简化理论模型，其中非线性度 $K$ 是一个小的正数。在此模型中，对应于绕数 $\\rho = P/Q$ 的锁模区间的宽度 $\\Delta\\Omega(P/Q)$ 由以下公式给出：\n$$ \\Delta\\Omega(P/Q) = C \\frac{K^{Q-1}}{Q^4} $$\n其中 $P/Q$ 是一个既约分数，$C$ 是一个正常数，$K$ 是非线性参数。此公式适用于开区间 $\\rho \\in (0, 1)$ 内的绕数，因此我们考虑 $0 < P < Q$。\n\n使用此模型，计算所有对应于分母为 $Q=3$ 的绕数的锁模台阶的总宽度，与所有对应于分母为 $Q=2$ 的绕数的锁模台阶的总宽度之比。将你的答案表示为关于 $K$ 的符号表达式。", "solution": "给定绕数为 $\\rho = P/Q$ 的锁模区间的宽度公式为\n$$\n\\Delta\\Omega\\left(\\frac{P}{Q}\\right) = C \\frac{K^{Q-1}}{Q^{4}},\n$$\n其中 $0<P<Q$ 且 $\\gcd(P,Q)=1$。对于一个固定的分母 $Q$，所有这些台阶的总宽度可以通过对所有允许的分子 $P$ 求和得到。这样的 $P$ 的数量是 $\\varphi(Q)$，即欧拉函数，因为它计算的是满足 $1 \\le P \\le Q-1$ 和 $\\gcd(P,Q)=1$ 的整数 $P$ 的个数。因为 $\\Delta\\Omega(P/Q)$ 仅取决于 $Q$ （而不取决于 $P$），所以分母为 $Q$ 的总宽度是\n$$\nW_{Q} = \\varphi(Q)\\, C \\frac{K^{Q-1}}{Q^{4}}.\n$$\n\n对于 $Q=2$，我们有 $\\varphi(2)=1$，所以\n$$\nW_{2} = 1 \\cdot C \\frac{K^{1}}{2^{4}} = C \\frac{K}{16}.\n$$\n\n对于 $Q=3$，我们有 $\\varphi(3)=2$，所以\n$$\nW_{3} = 2 \\cdot C \\frac{K^{2}}{3^{4}} = 2 C \\frac{K^{2}}{81}.\n$$\n\n所要求的 $Q=3$ 的总宽度与 $Q=2$ 的总宽度之比为\n$$\n\\frac{W_{3}}{W_{2}} = \\frac{2 C K^{2} / 81}{C K / 16} = \\frac{2 K^{2}}{81} \\cdot \\frac{16}{K} = \\frac{32}{81} K.\n$$\n常数 $C$ 被消掉，结果是关于 $K$ 的线性表达式。", "answer": "$$\\boxed{\\frac{32}{81}K}$$", "id": "1672710"}, {"introduction": "作为一项综合性的实践，这最后一个练习将让你亲手数值生成魔鬼阶梯。通过编程实现旋转数的定义并检测频率锁定平台，你将把理论概念与计算结果联系起来。这将使你对这一复杂的、自相似的分形结构获得深刻的理解和直观的感受 [@problem_id:2731669]。", "problem": "考虑由提升动力学定义的离散时间圆映射\n$$\nx_{k+1} \\;=\\; x_k \\;+\\; \\Omega \\;-\\; \\frac{K}{2\\pi}\\,\\sin(2\\pi x_k),\n$$\n其中 $x_k \\in \\mathbb{R}$，$K \\ge 0$ 是非线性参数，$\\Omega \\in [0,1]$ 是归一化驱动频率。圆上的物理相位是 $\\theta_k = x_k \\bmod 1$。旋转数由以下极限定义\n$$\n\\rho(K,\\Omega) \\;=\\; \\lim_{n\\to\\infty} \\frac{x_n - x_0}{n},\n$$\n对于该系统，在广泛条件下此极限存在，并且在遍历区域内与 $x_0$ 无关。当 $\\Omega$ (对于固定的 $K$ ) 变化时，已知映射 $\\Omega \\mapsto \\rho(K,\\Omega)$ 形成一个非递减的阶梯函数，其平台（plateau）表示频率锁定（也称锁模），在这些平台上，$\\rho$ 在非零的 $\\Omega$ 区间内取有理数值 $p/q$。这个分形单调函数通常被称为魔鬼阶梯。\n\n您的任务是在一系列固定的 $K$ 值下，对 $\\Omega$ 值网格上的 $\\rho(K,\\Omega)$ 进行数值近似，检测 $\\rho$ 为小分母有理数的频率锁定平台，并测量平台宽度。仅使用通过提升动力学和基本数值迭代得到的旋转数定义。\n\n使用以下数值步骤和检测标准。\n\n- 对于指定网格上的每一对 $(K,\\Omega)$，从 $x_0=0$ 开始，通过迭代提升映射来近似旋转数：\n  1. 运行 $N_{\\mathrm{tr}}$ 步的暂态过程，以减少对初始条件的敏感性。\n  2. 然后运行 $N_{\\mathrm{avg}}$ 步并计算\n     $$\n     \\widehat{\\rho}(K,\\Omega) \\;=\\; \\frac{x_{N_{\\mathrm{tr}}+N_{\\mathrm{avg}}} - x_{N_{\\mathrm{tr}}}}{N_{\\mathrm{avg}}}.\n     $$\n- 为识别在给定 $(K,\\Omega)$ 处的频率锁定，使用最佳有理数逼近（例如，连分数）将 $\\widehat{\\rho}$ 近似为有理数 $p/q$，其中 $1 \\le q \\le q_{\\max}$。如果满足以下条件，则宣布该点被锁定：\n  $$\n  \\left| \\widehat{\\rho}(K,\\Omega) - \\frac{p}{q} \\right| \\le \\varepsilon_{\\mathrm{lock}},\n  $$\n  并记录标签 $(p,q)$。\n- 为在给定的 $K$ 和一系列 $\\Omega$ 值下识别平台，找到所有点都以相同 $(p,q)$ 锁定的连续 $\\Omega$ 区间。平台宽度是该区间中最大和最小 $\\Omega$ 之间的差值。如果一个平台包含至少 $m_{\\min}$ 个网格点，并且宽度至少为 $w_{\\min}$，则接受该平台。\n\n在本问题的所有计算中，采用以下固定的数值设置：\n- 使用 $N_{\\mathrm{tr}} = 1500$，$N_{\\mathrm{avg}} = 3000$。\n- 使用 $[0,1]$ 内均匀的 $\\Omega$ 网格，有 $N_{\\Omega} = 401$ 个点（包括端点），即步长为 $1/400$。\n- 使用 $q_{\\max} = 8$，锁定容差 $\\varepsilon_{\\mathrm{lock}} = 5\\times 10^{-4}$，最小平台宽度 $w_{\\min} = 0.01$，以及最小平台点数 $m_{\\min} = 3$。\n- 所有运行均使用 $x_0 = 0$。\n\n测试套件。\n您必须评估以下四个测试用例，每个用例由 $(K,\\Omega_{\\min},\\Omega_{\\max},N_{\\Omega},q_{\\max},w_{\\min})$ 定义：\n1. $K = 0.0$, $\\Omega_{\\min} = 0.0$, $\\Omega_{\\max} = 1.0$, $N_{\\Omega} = 401$, $q_{\\max} = 8$, $w_{\\min} = 0.01$。\n2. $K = 0.5$, $\\Omega_{\\min} = 0.0$, $\\Omega_{\\max} = 1.0$, $N_{\\Omega} = 401$, $q_{\\max} = 8$, $w_{\\min} = 0.01$。\n3. $K = 1.0$, $\\Omega_{\\min} = 0.0$, $\\Omega_{\\max} = 1.0$, $N_{\\Omega} = 401$, $q_{\\max} = 8$, $w_{\\min} = 0.01$。\n4. $K = 1.2$, $\\Omega_{\\min} = 0.0$, $\\Omega_{\\max} = 1.0$, $N_{\\Omega} = 401$, $q_{\\max} = 8$, $w_{\\min} = 0.01$。\n\n对于每个测试用例，您的程序必须：\n- 计算给定 $K$ 在 $\\Omega$ 网格上所有被接受的平台列表。\n- 每个测试用例返回三个输出：\n  1. 被接受平台的整数总数。\n  2. 一个布尔值，指示 $1:2$ 锁定平台（即 $\\rho = 1/2$）是否存在于被接受的平台中。\n  3. 最宽的被接受平台的宽度，作为一个实数，四舍五入到 $4$ 位小数。\n\n最终输出格式。\n您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表。每个内部列表对应上述顺序中的一个测试用例，并且必须具有 $[\\text{count},\\text{bool},\\text{width}]$ 的形式，例如：\n$[[3,True,0.1250],[\\dots],[\\dots],[\\dots]]$。\n此问题不涉及单位。根据映射的定义，正弦函数内的角度以弧度为单位。所有浮点输出在打印前必须按上述规定四舍五入到 $4$ 位小数。", "solution": "该问题要求对标准圆映射进行数值研究，这是研究非线性动力系统和频率锁定现象的一个基本模型。目标是在多个非线性参数 $K$ 值下，对驱动频率 $\\Omega$ 网格上的旋转数 $\\rho(K,\\Omega)$ 进行近似，并识别和表征被称为阿诺德舌（Arnold tongues）的频率锁定平台。\n\n解决方案是通过直接实现问题陈述中指定的程序来构建的。该方法论遵循基于第一原理的层次化结构。\n\n分析的核心是旋转数，定义为 $\\rho = \\lim_{n\\to\\infty} (x_n - x_0)/n$。这个量度量了系统相位的平均渐近变化率。我们被要求通过迭代提升映射来计算数值近似值 $\\widehat{\\rho}$：\n$$\nx_{k+1} = x_k + \\Omega - \\frac{K}{2\\pi}\\sin(2\\pi x_k)\n$$\n对于每一对 $(K, \\Omega)$，计算从 $x_0 = 0$ 开始。前 $N_{\\mathrm{tr}} = 1500$ 次迭代作为暂态阶段被丢弃，以确保系统已稳定到其吸引子上。随后的 $N_{\\mathrm{avg}} = 3000$ 次迭代用于计算平均频率：\n$$\n\\widehat{\\rho}(K,\\Omega) = \\frac{x_{N_{\\mathrm{tr}}+N_{\\mathrm{avg}}} - x_{N_{\\mathrm{tr}}}}{N_{\\mathrm{avg}}}\n$$\n对于每个指定的测试用例 $K$，此过程被系统地应用于区间 $[0,1]$ 内 $N_{\\Omega} = 401$ 个 $\\Omega$ 值的均匀网格上的每个点。\n\n一旦为给定的 $\\Omega$ 计算出 $\\widehat{\\rho}$，下一步是测试频率锁定。这是一个分类任务。如果一个点的数值计算旋转数足够接近一个简单有理数，则该点被视为锁定。这通过一个两步过程实现：\n1.  **最佳有理数逼近**：对于每个 $\\widehat{\\rho}$，我们找到其最佳有理数逼近 $p/q$，其中分母 $q$ 不超过最大值 $q_{\\max} = 8$。这可以通过使用连分数方法在算法上完成，该方法在标准库中有高效实现。\n2.  **锁定条件**：如果计算出的旋转数与其有理数逼近之间的绝对差在指定容差范围内，则点 $(\\Omega, \\widehat{\\rho})$ 被分类为以有理数 $p/q$ 锁定：\n    $$\n    \\left| \\widehat{\\rho}(K,\\Omega) - \\frac{p}{q} \\right| \\le \\varepsilon_{\\mathrm{lock}}\n    $$\n    其中 $\\varepsilon_{\\mathrm{lock}} = 5 \\times 10^{-4}$。如果满足此条件，该状态被标记为对 $(p,q)$；否则，它被视为未锁定。\n\n在给定 $K$ 的 $\\Omega$ 网格上的所有点都被分类后，扫描生成的标签序列以识别平台。平台定义为所有点都锁定到相同的有理数 $(p,q)$ 的连续网格点子序列。\n\n然后，每个识别出的潜在平台都经过验证标准的检验，以过滤掉虚假或不显着的结果。一个段落只有在同时满足以下两个条件时才被接受为有效平台：\n- 它必须包含至少 $m_{\\min} = 3$ 个连续的网格点。\n- 该段落中 $\\Omega$ 值的跨度，定义为该段落的 $\\Omega_{\\max} - \\Omega_{\\min}$，必须至少为 $w_{\\min} = 0.01$。\n\n最后，对于每个 $K$ 值，分析被接受的平台集合，以提取所需的摘要指标：\n1.  被接受平台的总数。\n2.  一个布尔标志，指示与 $1:2$ 频率锁定（$\\rho=1/2$）对应的平台是否存在于被接受的集合中。\n3.  找到的最宽平台的宽度，四舍五入到小数点后四位。如果没有被接受的平台，则此宽度报告为 $0$。\n\n整个计算过程被封装在一个程序中，该程序遍历四个指定的 $K$ 值，对每个值进行分析，并按要求将最终结果格式化为单行输出。$K=0$ 的情况作为一个基准，此时映射是线性的（$x_{k+1} = x_k + \\Omega$），因此 $\\rho=\\Omega$。在这种线性情况下，真正的平台无法形成，而指定的验证标准能如预期地正确过滤掉有理数逼近过程中产生的任何伪影。对于 $K>0$，非线性会引起真正的频率锁定，该算法旨在检测和测量由此产生的平台。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom fractions import Fraction\n\ndef solve():\n    \"\"\"\n    Solves the circle map problem by numerically approximating rotation numbers,\n    detecting frequency-locked plateaus, and reporting statistics for several\n    nonlinearity parameters K.\n    \"\"\"\n    # Define the fixed numerical settings from the problem statement.\n    N_TR = 1500\n    N_AVG = 3000\n    EPS_LOCK = 5e-4\n    m_min = 3\n    X0 = 0.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (K, Omega_min, Omega_max, N_Omega, q_max, w_min)\n        (0.0, 0.0, 1.0, 401, 8, 0.01),\n        (0.5, 0.0, 1.0, 401, 8, 0.01),\n        (1.0, 0.0, 1.0, 401, 8, 0.01),\n        (1.2, 0.0, 1.0, 401, 8, 0.01),\n    ]\n\n    all_case_results = []\n    for K, omega_min, omega_max, n_omega, q_max, w_min in test_cases:\n        # Create the grid of Omega values.\n        omega_grid = np.linspace(omega_min, omega_max, n_omega)\n        locked_states = []\n\n        # Pre-compute the K-dependent term for efficiency.\n        k_term = K / (2 * np.pi)\n\n        # Iterate over each Omega to compute rho_hat and determine its locked state.\n        for omega in omega_grid:\n            x = X0\n            \n            # 1. Iterate the map to compute rho_hat.\n            # Transient steps.\n            for _ in range(N_TR):\n                x = x + omega - k_term * np.sin(2 * np.pi * x)\n            \n            x_transient = x\n            \n            # Averaging steps.\n            for _ in range(N_AVG):\n                x = x + omega - k_term * np.sin(2 * np.pi * x)\n            \n            x_final = x\n            \n            rho_hat = (x_final - x_transient) / N_AVG\n            \n            # 2. Find best rational approximation p/q.\n            frac = Fraction(rho_hat).limit_denominator(q_max)\n            p, q = frac.numerator, frac.denominator\n            \n            # 3. Check for frequency locking.\n            if abs(rho_hat - p / q) <= EPS_LOCK and q >= 1:\n                locked_states.append((p, q))\n            else:\n                locked_states.append(None)\n        \n        # 4. Identify and validate plateaus from contiguous locked states.\n        accepted_plateaus = []\n        i = 0\n        while i < n_omega:\n            current_state = locked_states[i]\n            if current_state is None:\n                i += 1\n                continue\n            \n            # A potential plateau starts at index i.\n            start_index = i\n            j = i + 1\n            while j < n_omega and locked_states[j] == current_state:\n                j += 1\n            end_index = j - 1\n            \n            # Apply validation criteria for the identified segment.\n            num_points = end_index - start_index + 1\n            if num_points >= m_min:\n                width = omega_grid[end_index] - omega_grid[start_index]\n                if width >= w_min:\n                    p_val, q_val = current_state\n                    plateau_info = {'p': p_val, 'q': q_val, 'width': width}\n                    accepted_plateaus.append(plateau_info)\n            \n            i = j  # Continue search from the end of the current segment.\n        \n        # 5. Compute the required output metrics for the current test case.\n        count = len(accepted_plateaus)\n        has_1_2 = any(p['p'] == 1 and p['q'] == 2 for p in accepted_plateaus)\n        \n        max_width = 0.0\n        if accepted_plateaus:\n            max_width = max(p['width'] for p in accepted_plateaus)\n            \n        all_case_results.append([count, has_1_2, max_width])\n    \n    # Final print statement in the exact required format.\n    result_strings = []\n    for count, has_bool, width in all_case_results:\n        bool_str = 'True' if has_bool else 'False'\n        width_str = f\"{round(width, 4):.4f}\" # Round then format\n        result_strings.append(f\"[{count},{bool_str},{width_str}]\")\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2731669"}]}