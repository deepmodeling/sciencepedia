{"hands_on_practices": [{"introduction": "自适应求解器的强大之处在于它们能够动态调整步长，以最小的计算成本满足所需的精度。第一个练习将深入探讨这种调整的核心机制。通过理解局部误差、步长和数值方法阶数之间的直接关系，即 $\\epsilon \\propto h^{p+1}$，你将推导出用于提出新的、更合适的步长的基本公式 [@problem_id:1659045]。", "problem": "在计算科学领域，数值方法被用来求解常微分方程 (ODEs) 的近似解。现代求解器的一个关键方面是自适应步长控制，它通过调整积分步长 $h$ 来维持期望的精度，同时最小化计算成本。\n\n考虑一个 $p$ 阶的数值积分方法。单步产生的局部截断误差 $\\epsilon$ 已知与步长的 $(p+1)$ 次方成正比。该关系可以表示为 $\\epsilon \\propto h^{p+1}$。\n\n一位工程师正在使用一个方法阶数为 $p=4$ 的求解器。该求解器为局部误差配置了一个恒定的目标容差 $tol$。在采用步长 $h_{old}$ 完成一个步进后，误差估计模块报告的局部误差为 $\\epsilon_{old} = \\frac{1}{2} tol$。为了准备下一个积分步，控制算法必须提出一个新的步长 $h_{new}$。新步长的选择应使得下一步的预测误差 $\\epsilon_{new}$ 恰好等于目标容差 $tol$。\n\n假设在这两个连续的步进之间，连接误差与步长的比例常数没有显著变化，请确定用旧步长 $h_{old}$ 表示的新步长 $h_{new}$ 的表达式。", "solution": "一个 $p$ 阶方法的局部截断误差满足 $\\epsilon = C h^{p+1}$，其中 $C$ 是在连续步进之间近似恒定的比例因子。对于旧步长，\n$$\n\\epsilon_{old} = C h_{old}^{p+1} = \\frac{1}{2} tol.\n$$\n对于建议的新步长，我们要求\n$$\n\\epsilon_{new} = C h_{new}^{p+1} = tol.\n$$\n取二者之比，\n$$\n\\frac{\\epsilon_{new}}{\\epsilon_{old}} = \\frac{C h_{new}^{p+1}}{C h_{old}^{p+1}} = \\left(\\frac{h_{new}}{h_{old}}\\right)^{p+1} = \\frac{tol}{\\frac{1}{2} tol} = 2.\n$$\n因此，\n$$\n\\left(\\frac{h_{new}}{h_{old}}\\right)^{p+1} = 2 \\quad \\Rightarrow \\quad \\frac{h_{new}}{h_{old}} = 2^{\\frac{1}{p+1}}.\n$$\n当 $p=4$ 时，我们得到\n$$\nh_{new} = 2^{\\frac{1}{5}} h_{old}.\n$$", "answer": "$$\\boxed{2^{\\frac{1}{5}} h_{old}}$$", "id": "1659045"}, {"introduction": "自适应步长控制器不仅仅是用来管理误差，其行为本身就可以为我们揭示解的内在性质。本练习将探讨一个引人入胜的场景：当求解器接近一个有限时间奇点时会发生什么。你将分析步长必须如何以可预测的方式缩小，从而展示自适应求解器如何像诊断工具一样，揭示动力系统的挑战性特征 [@problem_id:1659002]。", "problem": "一位工程师正在使用数值求解器来模拟一个特定的化学反应。某种物质的浓度，记为 $y(t)$，由以下常微分方程所描述：\n$$\n\\frac{dy}{dt} = A y^{n}\n$$\n其中 $t$ 是时间。对于此特定反应，常数参数为 $A > 0$ 和 $n=3$。在 $t=0$ 时的初始浓度为 $y(0) = y_0 > 0$。已知该方程的解 $y(t)$ 会出现有限时间奇异性，这意味着它会在一个有限的时间 $t_s > 0$ 达到无穷大。\n\n该数值求解器采用一种自适应步长控制策略。它使用一个阶数为 $p=4$ 的积分方法。该自适应算法的核心是调整步长 $h$，以使每一步的局部截断误差 $\\epsilon$ 保持近似恒定。单步的局部截断误差由以下公式估计：\n$$\n\\text{Err} \\approx C |y^{(p+1)}(t)| h^{p+1}\n$$\n其中 $y^{(p+1)}(t)$ 是精确解关于时间的 $(p+1)$ 阶导数，而 $C$ 是一个表征该数值方法的常数。求解器调整 $h$ 以使得 $\\text{Err} \\approx \\epsilon$。\n\n当模拟时间 $t$ 接近奇异时间 $t_s$ 时，观察到步长 $h$ 会随着剩余时间 $\\tau = t_s - t$ 遵循幂律关系而缩小。这种关系可以表示为：\n$$\nh \\approx K \\tau^{\\beta}\n$$\n对于某个常数 $K$ 和一个标度指数 $\\beta$，在 $\\tau \\to 0$ 的极限情况下成立。\n\n确定指数 $\\beta$ 的数值。", "solution": "我们从给定的 $n=3$ 的常微分方程开始：\n$$\n\\frac{dy}{dt} = A y^{3}, \\quad A>0, \\quad y(0)=y_{0}>0.\n$$\n分离变量并积分：\n$$\n\\int y^{-3}\\,dy = \\int A\\,dt \\quad \\Longrightarrow \\quad -\\frac{1}{2} y^{-2} = A t + c.\n$$\n代入 $y(0)=y_{0}$ 求 $c$：\n$$\n-\\frac{1}{2} y_{0}^{-2} = c \\quad \\Longrightarrow \\quad y^{-2}(t) = y_{0}^{-2} - 2 A t.\n$$\n爆破（有限时间奇异性）发生在 $y^{-2}(t_{s})=0$ 的时间点 $t_{s}$，因此\n$$\nt_{s} = \\frac{y_{0}^{-2}}{2A}.\n$$\n定义剩余时间 $\\tau = t_{s}-t$。在 $t_{s}$ 附近（即，当 $\\tau \\to 0^{+}$ 时），\n$$\ny^{-2}(t) = 2A \\tau \\quad \\Longrightarrow \\quad y(t) \\sim (2A)^{-\\frac{1}{2}} \\tau^{-\\frac{1}{2}}.\n$$\n因此，渐近地，$y(t)$ 的行为类似于 $c \\tau^{-m}$，其中 $c=(2A)^{-\\frac{1}{2}}$ 且 $m=\\frac{1}{2}$。关于 $t$ 的导数可以通过 $d/dt = - d/d\\tau$ 与关于 $\\tau$ 的导数联系起来。对于 $k \\in \\mathbb{N}$，\n$$\n\\frac{d^{k}}{dt^{k}} y(t) = (-1)^{k} \\frac{d^{k}}{d\\tau^{k}} \\big(c \\tau^{-m}\\big) \\sim \\text{const} \\cdot \\tau^{-m-k},\n$$\n其中常数取决于 $c$、$m$ 和 $k$，但 $\\tau$ 的幂是 $-m-k$。因此，对于一个阶数为 $p=4$ 的方法，我们需要 $(p+1)$ 阶导数，即 $k=5$，我们得到\n$$\n\\big|y^{(5)}(t)\\big| \\sim \\text{const} \\cdot \\tau^{-\\left(m+5\\right)} = \\text{const} \\cdot \\tau^{-\\frac{11}{2}}.\n$$\n自适应步长控制使用局部截断误差模型\n$$\n\\text{Err} \\approx C \\big|y^{(p+1)}(t)\\big| h^{p+1},\n$$\n并在 $p=4$ 的情况下保持 $\\text{Err} \\approx \\epsilon$，所以\n$$\n\\epsilon \\approx C \\big|y^{(5)}(t)\\big| h^{5} \\quad \\Longrightarrow \\quad h^{5} \\approx \\frac{\\epsilon}{C \\big|y^{(5)}(t)\\big|}.\n$$\n使用渐近标度关系 $\\big|y^{(5)}(t)\\big| \\sim \\text{const} \\cdot \\tau^{-\\frac{11}{2}}$，我们发现\n$$\nh \\sim \\left(\\frac{\\epsilon}{C}\\right)^{\\frac{1}{5}} \\big(\\text{const}\\big)^{-\\frac{1}{5}} \\tau^{\\frac{11}{10}}.\n$$\n因此，在关系式 $h \\approx K \\tau^{\\beta}$ 中，当 $\\tau \\to 0^{+}$ 时，指数为\n$$\n\\beta = \\frac{11}{10}.\n$$", "answer": "$$\\boxed{\\frac{11}{10}}$$", "id": "1659002"}, {"introduction": "在探索了自适应步长的基本原理和分析能力之后，这最后一个练习将挑战你将所学知识综合成一个功能完整的程序。你将实现一个完整的自适应前向欧拉求解器，包括误差估计、步长接受/拒绝逻辑以及步长更新规则。这个动手编程练习将理论与实践联系起来，让你具体地理解这些强大的算法是如何被构建和验证的 [@problem_id:2395159]。", "problem": "编写一个完整、可运行的程序，该程序使用基于局部截断误差估计的自适应步长控制的前向欧拉法，来求解常微分方程的初值问题。对于从时间 $t$ 到 $t + h$ 的一次步长尝试，令 $y^{[h]}$ 表示单步前向欧拉更新，令 $y^{[h/2]}$ 表示两次步长为 $h/2$ 的前向欧拉半步的复合。将该次尝试步长的局部误差估计定义为 $e = \\| y^{[h/2]} - y^{[h]} \\|$，其中标量状态使用绝对值，向量状态使用欧几里得范数。当且仅当 $e \\le \\epsilon$ 时，一个步长被接受，此时解推进至 $t \\leftarrow t + h$，状态更新为 $y \\leftarrow y^{[h/2]}$。如果 $e > \\epsilon$，则该步长被拒绝，此时 $(t,y)$ 保持不变，必须使用更小的步长重试。在每次接受或拒绝后，根据以下公式更新试探性的下一步长：\n$$\nh_{\\text{new}} \\;=\\; h \\cdot \\sigma \\cdot \\mathrm{clip}\\!\\left(\\left(\\frac{\\epsilon}{\\max(e, e_{\\min})}\\right)^{1/2}, \\gamma_{\\min}, \\gamma_{\\max}\\right),\n$$\n固定参数为 $\\sigma = 0.9$，$e_{\\min} = 10^{-16}$，$\\gamma_{\\min} = 0.2$，以及 $\\gamma_{\\max} = 5.0$。在每次尝试中，强制执行边界条件 $h \\ge h_{\\min}$（其中 $h_{\\min} = 10^{-12}$），并通过在步长尝试前将 $h$ 替换为 $\\min(h, T_{\\text{end}} - t)$ 来避免超过最终时间。使用以下前向欧拉更新：\n$$\ny^{[h]} \\;=\\; y \\;+\\; h\\, f(t, y), \\qquad\ny^{[h/2]} \\;=\\; y \\;+\\; \\frac{h}{2}\\, f(t, y) \\;+\\; \\frac{h}{2}\\, f\\!\\left(t+\\frac{h}{2},\\, y + \\frac{h}{2}\\, f(t, y)\\right).\n$$\n当 $t = T_{\\text{end}}$ 时终止。\n\n将上述方法应用于以下初值问题测试套件。对于每个案例，通过与指定的精确解进行比较，计算最终时间的绝对误差（标量）或误差的欧几里得范数（向量）。\n\n- 测试案例 A（标量，非线性）：\n  - 微分方程：$y'(t) = -\\,y(t)^2$。\n  - 初始条件：$y(0) = 1$。\n  - 时间区间：$t \\in [0, 1]$。\n  - 容差：$\\epsilon = 10^{-6}$。\n  - 初始步长：$h_0 = 0.4$。\n  - 在时间 $t$ 的精确解：$y(t) = \\dfrac{1}{1 + t}$。\n\n- 测试案例 B（标量，线性，非自治）：\n  - 微分方程：$y'(t) = \\cos(t) - y(t)$。\n  - 初始条件：$y(0) = 0$。\n  - 时间区间：$t \\in [0, 3]$。\n  - 容差：$\\epsilon = 10^{-5}$。\n  - 初始步长：$h_0 = 0.3$。\n  - 在时间 $t$ 的精确解：$y(t) = \\dfrac{\\sin t + \\cos t}{2} \\;-\\; \\dfrac{1}{2}\\, e^{-t}$。\n\n- 测试案例 C（向量，线性，解耦/受力）：\n  - 微分方程：\n    $$\n    \\begin{bmatrix} y_1'(t) \\\\[4pt] y_2'(t) \\end{bmatrix}\n    \\;=\\;\n    \\begin{bmatrix} -2\\, y_1(t) \\\\[4pt] -\\tfrac{1}{2}\\, y_2(t) + \\sin t \\end{bmatrix}.\n    $$\n  - 初始条件：$\\begin{bmatrix} y_1(0) \\\\[2pt] y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\[2pt] 0 \\end{bmatrix}$。\n  - 时间区间：$t \\in [0, 2]$。\n  - 容差：$\\epsilon = 10^{-6}$。\n  - 初始步长：$h_0 = 0.2$。\n  - 在时间 $t$ 的精确解：$y_1(t) = e^{-2 t}$ 和 $y_2(t) = \\dfrac{ \\tfrac{1}{2} \\sin t - \\cos t + e^{-t/2}}{1.25}$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试案例 A、B、C 的顺序列出结果。每个结果都必须是一个浮点数，等于最终时间 $T_{\\text{end}}$ 的绝对误差（对于标量问题）或误差的欧几里得范数（对于向量问题），并使用标准四舍五入到小数点后 $10$ 位。例如，要求的输出格式为\n$$\n[\\text{err\\_A},\\text{err\\_B},\\text{err\\_C}],\n$$\n其中 $\\text{err\\_A}$、$\\text{err\\_B}$ 和 $\\text{err\\_C}$ 均需精确显示小数点后 $10$ 位，且无额外空格。", "solution": "本任务要求为一个形式为 $y'(t) = f(t, y)$ 且 $y(t_0) = y_0$ 的初值问题实现一个自适应步长积分方案。该方法的核心是一阶前向欧拉法，并通过一个自动步长调整机制来控制局部误差。\n\n前向欧拉法使用截断到一阶项的泰勒展开来近似时间 $t_{n+1} = t_n + h$ 处的解：\n$$\ny_{n+1} = y_n + h f(t_n, y_n)\n$$\n该方法的局部截断误差为 $O(h^2)$ 阶。\n\n为了自适应地调整步长 $h$，我们需要对这个局部误差进行估计。问题指定了一种常用的技术，即比较大小为 $h$ 的单步结果与两次连续的大小为 $h/2$ 的步长的结果。\n\n设 $y_n$ 是时间 $t_n$ 处的解。\n1.  我们使用一个大小为 $h$ 的前向欧拉步来计算 $y(t_n+h)$ 的一个近似：\n    $$\n    y^{[h]} = y_n + h f(t_n, y_n)\n    $$\n2.  我们通过采取两个连续的半步来计算另一个近似：\n    从 $t_n$ 到 $t_n+h/2$ 的第一个半步：\n    $$\n    y_{n+1/2} = y_n + \\frac{h}{2} f(t_n, y_n)\n    $$\n    从 $t_n+h/2$ 到 $t_n+h$ 的第二个半步：\n    $$\n    y^{[h/2]} = y_{n+1/2} + \\frac{h}{2} f(t_n + \\frac{h}{2}, y_{n+1/2})\n    $$\n    将 $y_{n+1/2}$ 代入第二个方程，得到问题陈述中给出的 $y^{[h/2]}$ 的公式。这个两步过程等同于称为显式中点法的二阶龙格-库塔方法的单步，其局部截断误差为 $O(h^3)$。\n\n这两个近似之间的差异 $e = \\|y^{[h/2]} - y^{[h]}\\|$，可作为低阶方法 $y^{[h]}$ 的误差估计。由于精确解 $y_{\\text{exact}}(t_n+h)$ 可以写成 $y_{\\text{exact}} \\approx y^{[h]} + C h^2$ 和 $y_{\\text{exact}} \\approx y^{[h/2]} + O(h^3)$，差异 $e$ 是对项 $C h^2$ 的一个良好代理。\n\n有了这个误差估计，我们就可以应用步长控制。对于给定的容差 $\\epsilon$，如果 $e \\le \\epsilon$，则步长是成功的。如果是这样，我们使用更精确的近似来推进解：$t_{n+1} = t_n + h$ 和 $y_{n+1} = y^{[h/2]}$。这是一种称为“局部外推”的形式。如果步长被拒绝 ($e > \\epsilon$)，我们必须用一个更小的步长从 $t_n$ 重试。\n\n新步长 $h_{\\text{new}}$ 的确定目标是使下一步的误差约等于 $\\epsilon$。由于 $e \\approx C h^2$，我们希望 $h_{\\text{new}}$ 满足 $\\epsilon \\approx C h_{\\text{new}}^2$。这导致关系式 $h_{\\text{new}} \\approx h (\\epsilon/e)^{1/2}$。问题提供了一个更稳健的控制公式，其中包含一个安全因子 $\\sigma$，并对步长变化因子进行裁剪以防止过于激进的调整：\n$$\nh_{\\text{new}} = h \\cdot \\sigma \\cdot \\mathrm{clip}\\!\\left(\\left(\\frac{\\epsilon}{\\max(e, e_{\\min})}\\right)^{1/2}, \\gamma_{\\min}, \\gamma_{\\max}\\right)\n$$\n此更新在每次尝试后都会执行，无论该步是否被接受，都使用尝试的步长 $h$ 和由此产生的误差 $e$。\n\n整个算法实现为一个循环，将解从初始时间 $t_0$ 推进到最终时间 $T_{\\text{end}}$，在每次迭代中根据估计的局部误差调整步长 $h$。该实现将处理标量和向量 ODE，并应用指定的步长约束。最后，通过将计算出的 $T_{\\text{end}}$ 处的解与所提供的精确解析解进行比较来评估方法的准确性。", "answer": "```python\nimport numpy as np\n\ndef adaptive_euler_solver(f, t_span, y0, h0, eps, params):\n    \"\"\"\n    Solves an IVP using Forward Euler with adaptive step-size control.\n    \"\"\"\n    t_start, t_end = t_span\n    t = t_start\n    # Ensure y is a numpy array for consistent vector/scalar operations\n    y = np.array(y0, dtype=np.float64)\n    h = h0\n\n    sigma = params['sigma']\n    e_min = params['e_min']\n    gamma_min = params['gamma_min']\n    gamma_max = params['gamma_max']\n    h_min = params['h_min']\n\n    while t  t_end:\n        # Prevent floating point precision issues near the end\n        if np.isclose(t, t_end):\n            break\n        \n        # Adjust step size to not overshoot T_end and respect h_min\n        h_try = min(h, t_end - t)\n        h_try = max(h_try, h_min)\n\n        # One full step (Forward Euler)\n        # y_h = y + h_try * f(t, y)\n        k1 = f(t, y)\n        y_h = y + h_try * k1\n\n        # Two half-steps (Explicit Midpoint)\n        # y_h_half = y + h/2*f + h/2*f(t+h/2, y+h/2*f)\n        y_mid = y + (h_try / 2.0) * k1\n        k2 = f(t + h_try / 2.0, y_mid)\n        y_h_half = y_mid + (h_try / 2.0) * k2\n        \n        # Error estimate\n        error_vec = y_h_half - y_h\n        e = np.linalg.norm(error_vec)\n\n        # Step acceptance/rejection\n        if e = eps:\n            # Accept step and advance solution with the more accurate result\n            t = t + h_try\n            y = y_h_half\n\n        # Update step size for the next attempt (always)\n        ratio = eps / max(e, e_min)\n        factor = np.clip(np.sqrt(ratio), gamma_min, gamma_max)\n        h = h_try * sigma * factor\n        \n    return y\n\ndef solve():\n    \"\"\"\n    Sets up and solves the test cases, then prints the final errors.\n    \"\"\"\n    # Universal parameters for the solver\n    solver_params = {\n        'sigma': 0.9,\n        'e_min': 1e-16,\n        'gamma_min': 0.2,\n        'gamma_max': 5.0,\n        'h_min': 1e-12,\n    }\n\n    # Test Case A\n    def f_a(t, y):\n        return -y[0]**2\n    def y_exact_a(t):\n        return np.array([1.0 / (1.0 + t)])\n\n    # Test Case B\n    def f_b(t, y):\n        return np.cos(t) - y[0]\n    def y_exact_b(t):\n        return np.array([(np.sin(t) + np.cos(t) - np.exp(-t)) / 2.0])\n\n    # Test Case C\n    def f_c(t, y):\n        dy1_dt = -2.0 * y[0]\n        dy2_dt = -0.5 * y[1] + np.sin(t)\n        return np.array([dy1_dt, dy2_dt])\n    def y_exact_c(t):\n        y1 = np.exp(-2.0 * t)\n        y2 = (0.5 * np.sin(t) - np.cos(t) + np.exp(-t / 2.0)) / 1.25\n        return np.array([y1, y2])\n\n    test_cases = [\n        {\n            'f': f_a, 'y_exact': y_exact_a, 't_span': [0.0, 1.0],\n            'y0': [1.0], 'h0': 0.4, 'eps': 1e-6\n        },\n        {\n            'f': f_b, 'y_exact': y_exact_b, 't_span': [0.0, 3.0],\n            'y0': [0.0], 'h0': 0.3, 'eps': 1e-5\n        },\n        {\n            'f': f_c, 'y_exact': y_exact_c, 't_span': [0.0, 2.0],\n            'y0': [1.0, 0.0], 'h0': 0.2, 'eps': 1e-6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        t_end = case['t_span'][1]\n        \n        y_final = adaptive_euler_solver(\n            case['f'], case['t_span'], case['y0'],\n            case['h0'], case['eps'], solver_params\n        )\n        \n        y_true = case['y_exact'](t_end)\n        error = np.linalg.norm(y_final - y_true)\n        results.append(error)\n\n    # Format output as specified\n    formatted_results = [f\"{res:.10f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2395159"}]}