{"hands_on_practices": [{"introduction": "实验数据常常受到噪声的干扰，这会掩盖我们感兴趣的潜在动态趋势。时间序列分析的首要步骤之一就是数据平滑，而移动平均是一种最基本且有效的滤波技术。这个练习将指导你应用一个中心移动平均滤波器来处理一个带噪声的温度时间序列，让你亲身体验如何从原始测量中提取出更清晰的信号 [@problem_id:1723028]。", "problem": "一位研究人员正在分析一种新材料的温度稳定性。一个传感器每秒记录一次材料的温度，但原始数据受到高频电子噪声的影响。为了辨别潜在的温度趋势，应用了一种称为移动平均的常用信号处理技术。\n\n考虑在时间索引 $i=1, 2, ..., 9$ 记录的以下九个连续温度测量值序列 $T_i$：\n$T = \\{35.3, 36.2, 35.1, 34.7, 35.8, 35.2, 36.1, 34.9, 35.5\\}$\n\n平滑后时间序列在给定时间索引 $i$ 处的值，是使用一个5点中心移动平均计算的。其定义为索引 $i$ 处的数据点、其紧邻的前两个数据点以及紧邻的后两个数据点的算术平均值。\n\n使用此定义，计算在时间索引 $i=6$ 处的平滑后温度值。将您的答案以摄氏度表示，并四舍五入到三位有效数字。", "solution": "在索引 $i$ 处的5点中心移动平均被定义为在索引 $i-2$、$i-1$、$i$、$i+1$ 和 $i+2$ 处的值的算术平均值。将平滑后的值表示为 $\\overline{T}_{i}$。则\n$$\n\\overline{T}_{i}=\\frac{1}{5}\\sum_{k=-2}^{2}T_{i+k}.\n$$\n对于 $i=6$，所需的索引是 $4,5,6,7,8$，其对应的值为 $T_{4}=34.7$、$T_{5}=35.8$、$T_{6}=35.2$、$T_{7}=36.1$ 和 $T_{8}=34.9$。它们的和是\n$$\n34.7+35.8+35.2+36.1+34.9=176.7.\n$$\n因此，\n$$\n\\overline{T}_{6}=\\frac{176.7}{5}=35.34.\n$$\n四舍五入到三位有效数字得到 $35.3$。", "answer": "$$\\boxed{35.3}$$", "id": "1723028"}, {"introduction": "在平滑数据以观察趋势之后，下一步是理解产生这些趋势的动力学机制。逻辑斯蒂映射，$x_{n+1} = r x_n (1 - x_n)$，是动力系统中的一个经典范例，它揭示了简单的非线性方程如何能产生从稳定到混沌的复杂行为。此练习将引导你超越简单的数值模拟，通过解析推导来精确地找到系统发生倍周期分岔（从一个稳定点变为两个交替出现的点）的临界点，从而深入理解系统行为质变的数学根源 [@problem_id:1723003]。", "problem": "一个用于描述非重叠世代昆虫物种的种群动力学的简化模型由离散逻辑斯谛映射给出。设 $x_n$ 为第 $n$ 代的种群比例（一个介于 0 和 1 之间的值）。下一代的种群 $x_{n+1}$ 由以下方程确定：\n$$x_{n+1} = r x_n (1 - x_n)$$\n其中 $r$ 是一个正参数，代表繁殖和饥饿的综合效应。\n\n对于 $r$ 的某些值（特别是当 $r>3$ 时），种群不会稳定到一个单一、恒定的平衡值。相反，经过许多代之后，它会进入一个稳定状态，在该状态下，种群在两个不同的种群比例之间无限交替。这种行为被称为周期-2 循环。\n\n设这个稳定循环中的两个种群比例用 $p_1$ 和 $p_2$ 表示。请找出 $p_1$ 和 $p_2$ 关于参数 $r$ 的解析表达式。请以有序对 $(p_1, p_2)$ 的形式提供你的答案，其中 $p_1 < p_2$。", "solution": "我们考虑逻辑斯谛映射 $f(x) = r x (1 - x) = r x - r x^{2}$。一个周期-2 循环由两个不同的点 $p_{1}$ 和 $p_{2}$ 组成，满足 $f(p_{1}) = p_{2}$ 和 $f(p_{2}) = p_{1}$，这意味着它们是第二次迭代函数 $f^{(2)}(x)$ 的不动点，但不是 $f(x)$ 的不动点。因此，我们求解 $f(f(x)) = x$ 并舍去 $f$ 的不动点。\n\n首先计算 $f(f(x))$。令 $y = f(x) = r x - r x^{2}$。那么\n$$\nf(f(x)) = f(y) = r y - r y^{2} = r (r x - r x^{2}) - r (r x - r x^{2})^{2}.\n$$\n令 $f(f(x)) = x$ 并代数化简，可知 $f(x)$ 的不动点 $x=0$ 和 $x=1-1/r$ 是 $f(f(x))=x$ 的解。将这两个根的对应因子 $(x)$ 和 $(x-(1-1/r))$ 从 $f(f(x))-x=0$ 的多项式中除掉，剩下的二次方程的根就是周期-2 的点。该二次方程为：\n$$\nr x^{2} - (r + 1) x + \\frac{r+1}{r} = 0.\n$$\n应用二次方程求根公式，\n$$\nx = \\frac{r+1 \\pm \\sqrt{(r+1)^2 - 4r(\\frac{r+1}{r})}}{2r} = \\frac{r+1 \\pm \\sqrt{(r+1)^2 - 4(r+1)}}{2r} = \\frac{r+1 \\pm \\sqrt{(r+1)(r-3)}}{2r}.\n$$\n当 $r>3$ 时，判别式 $(r+1)(r-3)$ 为正，从而得到两个位于 $(0,1)$ 内的不同实数值。将它们按 $p_{1} < p_{2}$ 排序，我们为 $p_{1}$ 取减号，为 $p_{2}$ 取加号：\n$$\np_{1} = \\frac{r+1 - \\sqrt{(r+1)(r-3)}}{2 r}, \\qquad p_{2} = \\frac{r+1 + \\sqrt{(r+1)(r-3)}}{2 r}.\n$$\n这些就是在 $r>3$ 时，逻辑斯谛映射的稳定周期-2 循环点的解析表达式。", "answer": "$$\\boxed{\\left(\\frac{r+1-\\sqrt{(r+1)(r-3)}}{2 r}, \\frac{r+1+\\sqrt{(r+1)(r-3)}}{2 r}\\right)}$$", "id": "1723003"}, {"introduction": "理论分析为我们提供了对理想化模型（如逻辑斯蒂映射）的深刻理解，但在处理真实的、来源未知的实验数据时，我们如何判断系统动力学是否发生了变化？这个综合性计算实践将引导你应用现代非线性时间序列分析的高级技术，包括时间延迟嵌入重构相空间和代理数据假设检验。你将学习如何从单个时间序列中检测分岔等动态行为的质变，这是连接理论与实际数据分析的关键一步 [@problem_id:2376563]。", "problem": "您面临一项概念性任务，该任务基于时间延迟嵌入和代理数据方法，旨在分析标量离散时间序列，以寻找与分岔一致的动力学定性变化证据。您必须编写一个完整且可运行的程序。对于每个提供的测试用例，该程序需要使用时间延迟嵌入重构状态空间，在两个时间窗口上估计一个非线性不变量，构建一个保留线性属性的代理数据零分布，并执行假设检验，以判断两个窗口之间是否存在具有统计显著性的类分岔变化证据。最终输出必须是单行文本，其中包含一个方括号内的逗号分隔的布尔值列表。\n\n从基本定义开始。标量时间序列是一个以均匀间隔采样的序列 $\\{x_n\\}_{n=0}^{N-1}$。根据 Takens 嵌入定理，通过构建延迟向量 $\\mathbf{X}_n = \\left(x_n, x_{n-\\tau}, \\dots, x_{n-(m-1)\\tau}\\right)$（其中 $m$ 为嵌入维度，$\\tau$ 为延迟），可以从单个可观测量重构出光滑动力系统底层吸引子的一个微分同胚像。您将使用相关和来估计重构吸引子的结构复杂度。对于 $M$ 个嵌入点 $\\{\\mathbf{X}_i\\}_{i=0}^{M-1}$，相关和定义为\n$$\nC(r) = \\frac{2}{M(M-1)} \\sum_{0 \\le i < j \\le M-1} \\Theta\\!\\left(r - \\left\\|\\mathbf{X}_i - \\mathbf{X}_j\\right\\|\\right),\n$$\n其中 $\\Theta$ 是赫维赛德阶跃函数，$\\|\\cdot\\|$ 是欧几里得范数。在合适的 $r$ 标度范围内，$\\log C(r)$ 关于 $\\log r$ 的斜率可以作为相关维度的代理，而相关维度是衡量吸引子复杂度的标准指标。\n\n为了使计算对于有限数据具有统计鲁棒性和计算效率，您必须：\n- 在计算距离时，使用一个 Theiler 窗来排除时间上相邻的点对，具体要求是 $|i-j| > w$，其中 $w = m\\tau$。\n- 通过在基于采样点对距离分位数的标度范围内选择半径 $r$ 来估计斜率。您可以在距离分布的两个分位数之间，使用固定数量的对数间隔的半径值，并通过在该范围内对 $\\log C(r)$ 与 $\\log r$ 进行线性回归来获得斜率。\n- 通过对满足 $i \\ne j$ 和 $|i-j| > w$ 的不同点对 $(i,j)$ 进行大规模均匀随机采样来近似相关和。\n\n为了检验时间序列的早期窗口和晚期窗口之间是否存在类分岔变化，请使用调幅傅里叶变换 (AAFT) 方法构建一个代理数据零模型。该方法能保留边际振幅分布并近似功率谱（因此也近似自相关）。对于每个窗口：\n- 生成 $S$ 个独立的 AAFT 代理数据。\n- 对于每个窗口和每个代理数据，计算上述的相同斜率统计量。\n- 设 $\\Delta_{\\mathrm{obs}}$ 为晚期斜率与早期斜率之间的观测差异。通过跨窗口配对代理数据以获得 $\\{\\Delta_s\\}_{s=1}^S$，来构建差异的蒙特卡洛零分布，并按如下方式计算双边蒙特卡洛 p 值：\n$$\np = \\frac{1 + \\#\\{s : |\\Delta_s| \\ge |\\Delta_{\\mathrm{obs}}|\\}}{S+1}.\n$$\n如果对于选定的显著性水平 $\\alpha$，有 $p < \\alpha$，则判定存在分岔的证据。\n\n请实现以下测试套件。在所有情况下，均使用嵌入维度 $m = 3$，延迟 $\\tau = 1$，Theiler 窗 $w = m\\tau$，代理数据数量 $S = 20$，点对样本量 $P = 8000$，显著性水平 $\\alpha = 0.05$，以及一个固定的随机种子以保证可复现性。程序必须在内部生成每个时间序列，并且在嵌入之前，必须通过减去均值并除以标准差来对每个分析窗口进行标准化。\n\n- 测试用例 1 (平稳非线性动力学，预期无分岔)：具有固定参数 $r = 3.70$ 的 Logistic 映射。从 $x_0 = 0.2$ 开始，由 $x_{n+1} = r x_n (1 - x_n)$ 生成 $N = 4096$ 个点，并在分析前丢弃前 $512$ 个值作为瞬态。\n- 测试用例 2 (慢参数漂移跨越定性变化，预期有分岔)：具有线性斜坡参数 $r_n$ 的 Logistic 映射，该参数在 $N = 4096$ 个点上从 $r_{\\min} = 3.20$ 线性增加到 $r_{\\max} = 3.70$，从 $x_0 = 0.2$ 开始，并在分析前丢弃前 $256$ 个点。\n- 测试用例 3 (线性随机动力学，预期无分岔)：由 $x_{n+1} = \\phi x_n + \\epsilon_n$给出的一阶自回归过程，其中 $\\phi = 0.8$，$\\epsilon_n \\sim \\mathcal{N}(0,\\sigma^2)$ 且 $\\sigma = 0.5$。生成 $N = 4096$ 个点，并在分析前丢弃前 $512$ 个点作为瞬态。\n\n您的程序必须对每个测试用例执行上述过程，并判断时间序列的前半部分和后半部分之间是否存在具有统计显著性的分岔证据。最终输出必须是单行文本，其中按顺序包含测试用例 1、2 和 3 的三个布尔结果，格式为方括号内由逗号分隔的列表（例如，“[True,False,True]”）。此任务不涉及任何物理单位。如果在中间计算中出现角度，默认为弧度。\n\n您的实现必须是完整和自包含的，且不得要求任何用户输入。程序应严格按照指定格式生成一行输出。", "solution": "该问题提出了一个在非线性时间序列分析领域中有效且定义明确的计算任务。它基于已确立的科学原理，并为其实现提供了清晰、客观和完整的规范。任务是创建一个程序，通过比较两个时间窗口内的复杂度度量，并使用基于代理数据的假设检验来判断统计显著性，从而测试标量时间序列内的动力学是否存在类分岔变化。\n\n解决方案的结构是首先实现分析的基本组件，然后将它们集成到一个完整的假设检验流程中，并应用于指定的测试用例。核心原理包括状态空间重构、作为复杂度度量的相关维度，以及用于生成零假设数据的调幅傅里叶变换 (AAFT) 方法。\n\n首先，我们讨论状态空间重构的原理。根据 Takens 嵌入定理，系统的动力学可以从单个时间序列可观测量 $\\{x_n\\}$ 中重构出来。这是通过形成 $m$ 维延迟向量 $\\mathbf{X}_n = (x_n, x_{n-\\tau}, \\dots, x_{n-(m-1)\\tau})$ 来实现的，其中 $m$ 是嵌入维度，$\\tau$ 是时间延迟。对于这个问题，我们使用指定值 $m=3$ 和 $\\tau=1$。这些向量的集合 $\\{\\mathbf{X}_n\\}$ 在一个 $m$ 维状态空间中形成一条轨迹，在特定条件下，该轨迹与原始系统的吸引子是微分同胚的。\n\n其次，我们使用相关维度 $\\nu$ 的一个代理来量化重构吸引子的几何复杂度。相关和 $C(r)$ 衡量了在吸引子上随机选择的两点之间距离小于 $r$ 的概率。对于 $M$ 个点，其形式化定义为：\n$$\nC(r) = \\frac{2}{M(M-1)} \\sum_{0 \\le i < j \\le M-1} \\Theta(r - \\|\\mathbf{X}_i - \\mathbf{X}_j\\|)\n$$\n其中 $\\Theta$ 是赫维赛德阶跃函数。对于分形吸引子， $C(r)$ 在一定半径范围内表现出幂律标度关系，$C(r) \\propto r^\\nu$。指数 $\\nu$ 就是相关维度。我们通过线性回归计算 $\\log{C(r)}$ 关于 $\\log{r}$ 的斜率来估计 $\\nu$。为使计算高效，我们通过对大量的（$P=8000$）不同点对 $(\\mathbf{X}_i, \\mathbf{X}_j)$进行采样，并计算成对距离小于或等于 $r$ 的比例来近似 $C(r)$。为了避免时间上相邻点造成的伪相关，我们采用了一个 Theiler 窗 $w=m\\tau=3$，要求采样的点对满足 $|i-j| > w$。用于线性拟合的标度区域是通过动态选择大约 20 个半径来确定的，这些半径在采样距离分布的第 5 百分位数和第 95 百分位数之间呈对数间隔分布。\n\n第三，我们构建一个基于代理数据的统计检验来检测动力学变化。零假设 $H_0$ 是时间序列由一个平稳过程生成。如果 $H_0$ 为真，那么从序列早期窗口估计的相关维度应与晚期窗口的相关维度在统计上无法区分。一个显著的差异 $\\Delta_{\\mathrm{obs}} = \\nu_{\\mathrm{late}} - \\nu_{\\mathrm{early}}$ 将表明底层动力学发生了变化，这与分岔是一致的。为评估显著性，我们使用调幅傅里叶变换 (AAFT) 方法生成 $\\Delta$ 的零分布。对于早期和晚期窗口，我们各生成 $S=20$ 个代理时间序列。AAFT 代理数据旨在保留原始数据段的精确振幅分布并近似其功率谱（从而也近似自相关函数）。它们代表了与原始窗口具有相似线性属性的平稳数据。通过为每对代理数据计算斜率差异 $\\Delta_s$，我们构建一个蒙特卡洛零分布。\n\n观测差异 $\\Delta_{\\mathrm{obs}}$ 的统计显著性随后通过一个双边 p 值来量化，计算公式如下：\n$$\np = \\frac{1 + \\#\\{s : |\\Delta_s| \\ge |\\Delta_{\\mathrm{obs}}|\\}}{S+1}\n$$\n如果该 p 值小于指定的显著性水平 $\\alpha=0.05$，我们就拒绝平稳性的零假设，并断定存在类分岔变化的证据。\n\n整个过程被封装在一个 Python 程序中。该程序首先为三个不同的测试用例生成时间序列：(1) 一个平稳的混沌 Logistic 映射，(2) 一个具有漂移参数的非平稳 Logistic 映射，以及 (3) 一个平稳的线性随机 AR(1) 过程。每个序列被分为前半部分和后半部分。在分析之前，每个窗口都被标准化为零均值和单位方差。然后对每个案例执行假设检验，并记录布尔结果（如果变化显著则为 True，否则为 False）。所有涉及随机性的计算（数据生成、点对采样、代理数据创建）都由一个单一的、固定的随机种子控制，以确保完全的可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to execute the bifurcation detection analysis for all test cases.\n    \"\"\"\n    # Set a fixed random seed for reproducibility of the entire script.\n    SEED = 42\n    rng = np.random.default_rng(SEED)\n\n    # --- Global parameters from the problem statement ---\n    M_DIM = 3\n    TAU = 1\n    THEILER_W = M_DIM * TAU\n    N_SURROGATES = 20\n    N_PAIRS = 8000\n    ALPHA = 0.05\n\n    # --- Time series generation functions ---\n\n    def generate_logistic(r_param, N, x0, discard, rng):\n        \"\"\"Generates a time series from the logistic map.\"\"\"\n        x = np.zeros(N)\n        x[0] = x0\n        if np.isscalar(r_param):\n            for i in range(N - 1):\n                x[i + 1] = r_param * x[i] * (1 - x[i])\n        else:  # Ramped parameter\n            for i in range(N - 1):\n                x[i + 1] = r_param[i] * x[i] * (1 - x[i])\n        return x[discard:]\n\n    def generate_ar1(phi, sigma, N, x0, discard, rng):\n        \"\"\"Generates a time series from an AR(1) process.\"\"\"\n        x = np.zeros(N)\n        x[0] = x0\n        noise = rng.normal(0, sigma, N)\n        for i in range(N - 1):\n            x[i + 1] = phi * x[i] + noise[i]\n        return x[discard:]\n\n    # --- Core analysis functions ---\n\n    def embed(series, m, tau):\n        \"\"\"Performs time-delay embedding on a series.\"\"\"\n        n_points = len(series) - (m - 1) * tau\n        # This check is added for robustness with short series\n        if n_points = 0:\n            return np.empty((0, m))\n        embedded = np.lib.stride_tricks.as_strided(\n            series,\n            shape=(n_points, m),\n            strides=(series.strides[0], series.strides[0] * tau)\n        )\n        return embedded\n\n    def generate_aaft_surrogate(series, rng):\n        \"\"\"Generates one Amplitude-Adjusted Fourier Transform (AAFT) surrogate.\"\"\"\n        n = len(series)\n        \n        # 1. FFT the original series to get its magnitudes\n        fft_original = np.fft.rfft(series)\n        magnitudes_original = np.abs(fft_original)\n        \n        # 2. Create a phase-randomized surrogate of a Gaussian signal\n        white_noise = rng.standard_normal(size=n)\n        fft_noise = np.fft.rfft(white_noise)\n        random_phases = np.angle(fft_noise)\n\n        # 3. Create a new spectrum using original magnitudes and random phases\n        new_fft_spec = magnitudes_original * np.exp(1j * random_phases)\n        \n        # 4. Inverse FFT to get a series with the target spectrum but Gaussian distribution\n        y_prime = np.fft.irfft(new_fft_spec, n=n)\n        \n        # 5. Restore original amplitude distribution by rank-ordering\n        sorted_series = np.sort(series)\n        ranks_y_prime = np.argsort(np.argsort(y_prime))\n        \n        surrogate = sorted_series[ranks_y_prime]\n        return surrogate\n\n    def compute_slope(series, m, tau, w, n_pairs, rng):\n        \"\"\"Computes the correlation dimension slope for a given series.\"\"\"\n        embedded_series = embed(series, m, tau)\n        m_points = len(embedded_series)\n        \n        if m_points  w + 2:\n            return 0.0\n\n        # Sample pairs of points respecting the Theiler window\n        # Oversample to efficiently find n_pairs valid pairs\n        max_attempts = n_pairs * 5\n        cand_i = rng.integers(0, m_points, size=max_attempts)\n        cand_j = rng.integers(0, m_points, size=max_attempts)\n        \n        valid_mask = (cand_i != cand_j)  (np.abs(cand_i - cand_j) > w)\n        \n        pairs_i = cand_i[valid_mask][:n_pairs]\n        pairs_j = cand_j[valid_mask][:n_pairs]\n        \n        if len(pairs_i)  n_pairs: # Fallback if not enough pairs were found\n            return 0.0\n\n        # Compute distances and determine scaling range for radii\n        distances = np.linalg.norm(embedded_series[pairs_i] - embedded_series[pairs_j], axis=1)\n        \n        # Filter out zero distances to avoid issues with quantiles/log\n        pos_distances = distances[distances > 1e-12]\n        if len(pos_distances)  2:\n            return 0.0\n        \n        q_low, q_high = np.quantile(pos_distances, [0.05, 0.95])\n        \n        if q_high = q_low:\n             return 0.0\n        \n        radii = np.geomspace(q_low, q_high, num=20)\n        \n        # Approximate correlation sum C(r)\n        c_r = np.array([np.sum(distances = r) for r in radii]) / n_pairs\n        \n        # Perform linear regression on log-log plot to find the slope\n        valid_mask = (c_r > 1e-9)  (c_r  1.0)\n        log_radii = np.log(radii[valid_mask])\n        log_c_r = np.log(c_r[valid_mask])\n        \n        if len(log_radii)  2:\n            return 0.0 # Cannot perform regression\n        \n        slope, _, _, _, _ = linregress(log_radii, log_c_r)\n        \n        return slope if np.isfinite(slope) else 0.0\n\n    def run_test_case(series_generator, gen_params, m, tau, w, s_count, p_count, alpha_level, rng_instance):\n        \"\"\"Runs the entire hypothesis test for a single case.\"\"\"\n        ts_full = series_generator(**gen_params, rng=rng_instance)\n        \n        # Split into early and late windows\n        midpoint = len(ts_full) // 2\n        ts_early = ts_full[:midpoint]\n        ts_late = ts_full[midpoint:]\n\n        # Standardize each window\n        ts_early_std = (ts_early - np.mean(ts_early)) / np.std(ts_early)\n        ts_late_std = (ts_late - np.mean(ts_late)) / np.std(ts_late)\n        \n        # Compute observed difference in slopes\n        slope_early_obs = compute_slope(ts_early_std, m, tau, w, p_count, rng_instance)\n        slope_late_obs = compute_slope(ts_late_std, m, tau, w, p_count, rng_instance)\n        delta_obs = slope_late_obs - slope_early_obs\n\n        # Generate null distribution from surrogates\n        delta_surrogates = []\n        for _ in range(s_count):\n            surr_early = generate_aaft_surrogate(ts_early, rng_instance)\n            surr_late = generate_aaft_surrogate(ts_late, rng_instance)\n            \n            surr_early_std = (surr_early - np.mean(surr_early)) / np.std(surr_early)\n            surr_late_std = (surr_late - np.mean(surr_late)) / np.std(surr_late)\n            \n            slope_early_surr = compute_slope(surr_early_std, m, tau, w, p_count, rng_instance)\n            slope_late_surr = compute_slope(surr_late_std, m, tau, w, p_count, rng_instance)\n            \n            delta_surrogates.append(slope_late_surr - slope_early_surr)\n        \n        delta_surrogates = np.array(delta_surrogates)\n        \n        # Compute Monte Carlo p-value and make a decision\n        num_exceed = np.sum(np.abs(delta_surrogates) >= np.abs(delta_obs))\n        p_value = (1 + num_exceed) / (s_count + 1)\n        \n        return p_value  alpha_level\n\n    # --- Define and run test cases ---\n    \n    test_cases = [\n        # Case 1: Stationary Logistic Map (no bifurcation expected)\n        {\n            'generator': generate_logistic,\n            'params': {'r_param': 3.70, 'N': 4096, 'x0': 0.2, 'discard': 512}\n        },\n        # Case 2: Non-stationary Logistic Map (bifurcation expected)\n        {\n            'generator': generate_logistic,\n            'params': {'r_param': np.linspace(3.20, 3.70, 4096), 'N': 4096, 'x0': 0.2, 'discard': 256}\n        },\n        # Case 3: Stationary AR(1) Process (no bifurcation expected)\n        {\n            'generator': generate_ar1,\n            'params': {'phi': 0.8, 'sigma': 0.5, 'N': 4096, 'x0': 0.0, 'discard': 512}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(\n            series_generator=case['generator'],\n            gen_params=case['params'],\n            m=M_DIM,\n            tau=TAU,\n            w=THEILER_W,\n            s_count=N_SURROGATES,\n            p_count=N_PAIRS,\n            alpha_level=ALPHA,\n            rng_instance=rng\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).capitalize() for r in results)}]\")\n\nsolve()\n```", "id": "2376563"}]}