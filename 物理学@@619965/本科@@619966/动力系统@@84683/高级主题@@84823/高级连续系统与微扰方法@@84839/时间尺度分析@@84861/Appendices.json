{"hands_on_practices": [{"introduction": "本练习将介绍时间尺度分析中最基本也最强大的技术之一：准稳态近似 (Quasi-Steady-State Approximation, QSSA)。当一个系统的某些部分比其他部分响应快得多时，我们可以假设快速变化的变量相对于慢速变量几乎瞬间达到平衡。这个关于热控制系统的练习 [@problem_id:1723561] 提供了一个直观的物理场景，让你能够亲手应用此方法，通过简化模型来推导系统在慢时间尺度下的主导行为。", "problem": "一个热控制系统的简化模型包含一个嵌入在更大块体材料中的小型加热元件。加热元件相对于环境基准的温度由$x(t)$给出，而块体材料的相对温度由$y(t)$给出。系统的动力学由一对耦合线性微分方程描述。\n\n加热元件的温度$x(t)$对变化响应迅速，并受其与块体材料的热相互作用控制：\n$$m \\frac{d^2x}{dt^2} + b \\frac{dx}{dt} + k(x - y) = 0$$\n这里，$m$是有效热惯量，$b$是热耗散系数，$k$是元件与块体材料之间的热导率。所有这些常数都是正的。\n\n块体材料的温度$y(t)$变化非常缓慢。其演化由一个依赖于自身温度和加热元件温度的控制定律决定：\n$$\\tau \\frac{dy}{dt} = -y - \\beta x$$\n这里，$\\tau$是一个代表块体材料高热容的大时间常数，$\\beta$是一个正的无量纲反馈增益。\n\n假设系统运行在一个特定区域，其中加热元件$x(t)$的动力学相对于块体材料$y(t)$的动力学要快得多。这使得对于任何给定的块体材料温度，加热元件的温度都能迅速达到一个准稳态。在一个初始的短暂瞬态期之后，系统进入一个由$y(t)$的动力学控制的缓慢演化过程。\n\n确定描述在此长期演化过程中块体材料温度$y(t)$缓慢衰减的特征时间常数。用给定参数的符号表达式表示你的答案。", "solution": "耦合动力学方程为\n$$m \\frac{d^{2}x}{dt^{2}} + b \\frac{dx}{dt} + k(x - y) = 0,$$\n$$\\tau \\frac{dy}{dt} = -y - \\beta x,$$\n其中 $m,b,k,\\tau,\\beta>0$。\n\n根据所述的时间尺度分离，加热元件$x(t)$的演化远快于块体$y(t)$。在初始的快速瞬态后，$x(t)$对于缓慢变化的$y(t)$达到了一个准稳态。在准稳态近似下，快速子系统的时间导数项与耦合项相比可以忽略不计，因此我们设\n$$m \\frac{d^{2}x}{dt^{2}} \\approx 0, \\qquad b \\frac{dx}{dt} \\approx 0.$$\n快速方程简化为代数约束\n$$k(x - y) \\approx 0 \\quad \\Longrightarrow \\quad x \\approx y.$$\n\n这定义了慢流形。将$x \\approx y$代入慢方程，得到$y$的简化动力学方程：\n$$\\tau \\frac{dy}{dt} = -y - \\beta x \\approx -y - \\beta y = -(1+\\beta)\\,y.$$\n这个线性常微分方程的解为\n$$y(t) = y(0)\\,\\exp\\!\\left(-\\frac{1+\\beta}{\\tau}\\,t\\right),$$\n因此，缓慢衰减由特征值$-(1+\\beta)/\\tau$控制。特征时间常数$T$由$y(t) \\sim \\exp(-t/T)$定义，因此\n$$T = \\frac{\\tau}{1+\\beta}.$$", "answer": "$$\\boxed{\\frac{\\tau}{1+\\beta}}$$", "id": "1723561"}, {"introduction": "我们将简化思想从确定性系统推广到随机系统。如果一个系统的快过程不是简单的弛豫，而是在不同状态间快速随机切换，我们该如何分析？这个练习 [@problem_id:1723613] 引入了强大的平均化原理 (averaging principle)。你将学习如何通过计算快速随机过程的稳态分布，并对其影响进行平均，从而推导出慢变量的有效确定性动力学方程。", "problem": "考虑一个细胞内信号分子浓度 $x(t)$ 的简化模型。该分子的浓度由以下微分方程决定：\n$$ \\frac{dx}{dt} = \\alpha_{I(t)} - \\beta x^2 $$\n其中 $\\beta$ 是一个正常数，代表二阶降解过程的速率。生成速率 $\\alpha_{I(t)}$ 不是一个常数，而是取决于一个分子开关 $I(t)$ 的状态，该开关可以处于两种构型之一：状态1或状态2。当开关处于状态 $i \\in \\{1, 2\\}$ 时，生成速率是一个正常数 $\\alpha_i$。\n\n切换过程 $I(t)$ 是一个非常快速的连续时间 Markov 跳跃过程。从状态1到状态2的转移以 $k_1/\\epsilon$ 的速率发生，从状态2到状态1的转移以 $k_2/\\epsilon$ 的速率发生。此处，$k_1$ 和 $k_2$ 是正速率常数，而 $\\epsilon$ 是一个小的、正的、无量纲参数，它确立了快速切换和慢速浓度动力学之间的时间尺度分离。\n\n在无限快切换的极限 $\\epsilon \\to 0$ 下，浓度变量的行为可以用一个关于慢变量 $\\bar{x}(t)$ 的单一、有效的确定性微分方程来近似。这个有效方程具有形式 $\\frac{d\\bar{x}}{dt} = G(\\bar{x})$。\n\n请确定函数 $G(\\bar{x})$ 的表达式，用 $\\bar{x}$ 以及系统参数 $\\alpha_1, \\alpha_2, \\beta, k_1,$ 和 $k_2$ 来表示。", "solution": "给定一个双时间尺度系统，其中慢变量 $x(t)$ 根据以下方程演化：\n$$\n\\frac{dx}{dt}=\\alpha_{I(t)}-\\beta x^{2},\n$$\n其中 $I(t)\\in\\{1,2\\}$ 是一个连续时间 Markov 链，它以 $k_{1}/\\epsilon$ 的速率从状态1切换到2，并以 $k_{2}/\\epsilon$ 的速率从状态2切换到1，且 $\\epsilon\\to 0^{+}$。\n\n对于具有快速 Markov 切换的系统，随机平均原理指出，在 $x(t)$ 的慢时间尺度上，快速过程 $I(t)$ 会在 $x$ 准静态的条件下，迅速平衡到其稳态分布。因此，在极限 $\\epsilon\\to 0$ 下，确定性平均方程\n$$\n\\frac{d\\bar{x}}{dt}=G(\\bar{x})\n$$\n中的有效漂移 $G(\\bar{x})$ 是通过将快速变化的 $\\alpha_{I(t)}$ 替换为其关于快速链不变分布的稳态均值而得到的，同时保持慢项 $-\\beta \\bar{x}^{2}$ 不变。\n\n我们计算具有以下生成元矩阵的两状态链的稳态概率 $p_{1}$ 和 $p_{2}$：\n$$\nQ=\\begin{pmatrix}\n-\\frac{k_{1}}{\\epsilon} & \\frac{k_{1}}{\\epsilon} \\\\\n\\frac{k_{2}}{\\epsilon} & -\\frac{k_{2}}{\\epsilon}\n\\end{pmatrix}.\n$$\n稳态分布满足 $p_{1}+p_{2}=1$ 以及细致平衡（或全局平衡）关系：\n$$\np_{1}\\frac{k_{1}}{\\epsilon}=p_{2}\\frac{k_{2}}{\\epsilon}.\n$$\n消去公因子 $\\frac{1}{\\epsilon}$ 得到：\n$$\np_{1}k_{1}=p_{2}k_{2},\\quad p_{1}+p_{2}=1.\n$$\n求解可得：\n$$\np_{1}=\\frac{k_{2}}{k_{1}+k_{2}},\\qquad p_{2}=\\frac{k_{1}}{k_{1}+k_{2}}.\n$$\n因此，生成速率的稳态均值为：\n$$\n\\mathbb{E}[\\alpha_{I}]=p_{1}\\alpha_{1}+p_{2}\\alpha_{2}=\\frac{k_{2}\\alpha_{1}+k_{1}\\alpha_{2}}{k_{1}+k_{2}}.\n$$\n根据平均原理，慢变量 $\\bar{x}(t)$ 的有效漂移是稳态均值输入减去慢降解项：\n$$\nG(\\bar{x})=\\frac{k_{2}\\alpha_{1}+k_{1}\\alpha_{2}}{k_{1}+k_{2}}-\\beta \\bar{x}^{2}.\n$$\n这就提供了所求的 $G(\\bar{x})$ 的表达式，用 $\\bar{x}$ 和参数 $\\alpha_{1},\\alpha_{2},\\beta,k_{1},k_{2}$ 表示。", "answer": "$$\\boxed{\\frac{k_{2}\\alpha_{1}+k_{1}\\alpha_{2}}{k_{1}+k_{2}}-\\beta \\bar{x}^{2}}$$", "id": "1723613"}, {"introduction": "理论必须与实践相结合。在计算机模拟中，时间尺度分离会带来一个关键的挑战：数值刚性 (numerical stiffness)。这类“刚性”系统会使标准数值求解器失效或效率极低。这个练习 [@problem_id:2374943] 将让你通过一个金融市场模型，亲身体验如何识别并解决刚性常微分方程组，这需要你运用专门为这类问题设计的数值方法，从而将时间尺度分析的理论与计算实践联系起来。", "problem": "给定一个耦合常微分方程组，该方程组用于模拟一个具有分离时间尺度的程式化市场中两种类型交易主体之间的相互作用。状态向量为 $y(t) = [p(t), m(t), f(t)]^\\top$，其中 $p(t)$ 是可观测价格，$m(t)$ 是一个快速的算法交易压力变量，$f(t)$ 是一个缓慢变化的基本价值。对于固定的参数 $a \\gt 0$、$b \\gt 0$、$\\theta \\ge 0$、$\\tau_f \\gt 0$、$\\tau_s \\gt 0$ 和 $f_\\mathrm{bar} \\in \\mathbb{R}$，动力学由以下自治系统定义（$t \\ge 0$）：\n$$\n\\frac{d}{dt} p(t) = a\\, m(t) + b\\,\\big(f(t) - p(t)\\big),\n$$\n$$\n\\frac{d}{dt} m(t) = \\frac{\\theta\\,\\frac{d}{dt}p(t) - m(t)}{\\tau_f},\n$$\n$$\n\\frac{d}{dt} f(t) = -\\frac{f(t) - f_\\mathrm{bar}}{\\tau_s}.\n$$\n设初始条件为 $p(0)=p_0$、$m(0)=m_0$、$f(0)=f_0$，$T \\gt 0$ 表示终止时间。\n\n你的任务是编写一个完整的、可运行的程序，对下面列出的每个测试用例，在 $t \\in [0, T]$ 上数值求解该初值问题，并返回终止时刻的价格 $p(T)$（一个浮点数）。请确保数值精度足以处理 $\\tau_f$ 相对于 $\\tau_s$ 非常小的参数体系。最终输出必须将所有测试用例的结果汇总到一行，形式为方括号内逗号分隔的列表（例如，$[x_1,x_2,x_3]$）。不应打印任何额外文本。\n\n测试集（每个元组列出 $(a, b, \\theta, \\tau_f, \\tau_s, f_\\mathrm{bar}, p_0, m_0, f_0, T)$）：\n\n-   案例 $1$（中度刚性，“理想路径”）：$(1.0, 0.5, 0.2, 1.0\\times 10^{-3}, 1.0, 100.0, 95.0, 0.0, 100.0, 2.0)$\n-   案例 $2$（高度刚性的快速时间尺度）：$(1.0, 0.5, 0.2, 1.0\\times 10^{-6}, 1.0, 100.0, 95.0, 0.0, 100.0, 2.0)$\n-   案例 $3$（平衡边界条件）：$(1.0, 0.5, 0.2, 1.0\\times 10^{-3}, 1.0, 100.0, 100.0, 0.0, 100.0, 2.0)$\n-   案例 $4$（接近不稳定但仍稳定的区域）：$(1.0, 0.5, 0.9, 1.0\\times 10^{-4}, 1.0, 100.0, 95.0, 0.0, 100.0, 2.0)$\n-   案例 $5$（弱刚性基准）：$(1.0, 0.5, 0.2, 2.0\\times 10^{-1}, 1.0, 100.0, 95.0, 0.0, 100.0, 2.0)$\n\n对每个测试用例，生成单个标量 $p(T)$（浮点数）。你的程序应生成一行输出，其中包含按上述测试集顺序排列的结果，格式为方括号内逗号分隔的列表，即 $[p^{(1)}(T),p^{(2)}(T),p^{(3)}(T),p^{(4)}(T),p^{(5)}(T)]$。", "solution": "所述问题构成一个有效的初值问题。严格分析证实了其科学和数学上的合理性。然而，其初始表述不够精确。该系统不是一个标准的常微分方程组（ODEs），因为变量 $m(t)$ 的变化率方程，\n$$\n\\frac{d}{dt} m(t) = \\frac{\\theta\\,\\frac{d}{dt}p(t) - m(t)}{\\tau_f},\n$$\n包含了导数 $\\frac{dp}{dt}$。这种结构定义了一个微分代数方程组（DAEs）。为了使用标准积分器进行数值求解，必须将此系统转换为显式常微分方程形式 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{F}(t, \\mathbf{y})$。这可以通过直接的代数代换来完成。\n\n我们将第一个方程中 $\\frac{dp}{dt}$ 的表达式，\n$$\n\\frac{d}{dt} p(t) = a\\, m(t) + b\\,\\big(f(t) - p(t)\\big),\n$$\n代入 $\\frac{dm}{dt}$ 的方程中。得到：\n$$\n\\frac{d}{dt} m(t) = \\frac{\\theta\\,\\left[ a\\, m(t) + b\\,\\big(f(t) - p(t)\\big) \\right] - m(t)}{\\tau_f}.\n$$\n整理这些项，我们得到了 $\\frac{dm}{dt}$ 关于状态变量 $p(t)$、$m(t)$ 和 $f(t)$ 的显式表达式：\n$$\n\\frac{d}{dt} m(t) = \\frac{(\\theta a - 1)m(t) - \\theta b p(t) + \\theta b f(t)}{\\tau_f}.\n$$\n完整的系统，其状态向量为 $\\mathbf{y}(t) = [p(t), m(t), f(t)]^\\top$，现在可以写成一个线性的、自治的一阶常微分方程组 $\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y} + \\mathbf{c}$：\n$$\n\\frac{d}{dt}\n\\begin{pmatrix} p(t) \\\\ m(t) \\\\ f(t) \\end{pmatrix}\n=\n\\begin{pmatrix}\n-b & a & b \\\\\n-\\frac{\\theta b}{\\tau_f} & \\frac{\\theta a - 1}{\\tau_f} & \\frac{\\theta b}{\\tau_f} \\\\\n0 & 0 & -\\frac{1}{\\tau_s}\n\\end{pmatrix}\n\\begin{pmatrix} p(t) \\\\ m(t) \\\\ f(t) \\end{pmatrix}\n+\n\\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{f_\\mathrm{bar}}{\\tau_s} \\end{pmatrix}.\n$$\n对于给定的初始条件 $\\mathbf{y}(0) = [p_0, m_0, f_0]^\\top$，该系统保证有唯一解。系统的稳定性取决于矩阵 $A$ 的特征值。分析证实，对于所有给定的测试用例，该系统都是稳定的，即所有特征值都具有负实部。平衡态为 $(p, m, f) = (f_\\mathrm{bar}, 0, f_\\mathrm{bar})$。\n\n问题指定了时间尺度 $\\tau_f$ 远小于 $\\tau_s$ 的参数区域（例如，$\\tau_f = 10^{-6}$ 对比 $\\tau_s = 1.0$）。这种时间尺度上的差异引入了数值刚性。系统矩阵 $A$ 的特征值在量级上会相差悬殊，其中一些会是绝对值很大的负数（量级约为 $1/\\tau_f$）。显式数值方法，如前向欧拉法或标准的 Runge-Kutta 方法，是条件稳定的，需要一个不切实际的小时间步长（与 $\\tau_f$ 成正比）来维持稳定性，这使得它们对于解决此问题效率低下。\n\n因此，必须使用专为刚性常微分方程设计的数值方法。后向差分公式（Backward Differentiation Formulas, BDF）是一族隐式多步法，因其对刚性方程具有出色的稳定性而非常适合此类问题。我们将采用 SciPy 库中 `scipy.integrate.solve_ivp` 函数所实现的 BDF 方法。\n\n对每个测试用例，实现过程如下：\n$1$. 定义参数 $(a, b, \\theta, \\tau_f, \\tau_s, f_\\mathrm{bar})$ 和初始条件 $(p_0, m_0, f_0, T)$。\n$2$. 实现一个函数，该函数代表显式常微分方程组的右侧，即 $\\mathbf{F}(\\mathbf{y}) = A\\mathbf{y} + \\mathbf{c}$。\n$3$. 调用 `scipy.integrate.solve_ivp` 求解器，并将方法参数设置为 `'BDF'`。从初始状态 $\\mathbf{y}(0)$ 开始，在时间区间 $[0, T]$ 上进行积分。为确保高精度，指定了严格的相对和绝对误差容限，例如 $rtol = 10^{-8}$ 和 $atol = 10^{-10}$。\n$4$. 求解器返回解向量 $\\mathbf{y}(t)$。所需的目标价格 $p(T)$ 是解向量在最终时间点的第一个分量。\n$5$. 将所有测试用例的结果汇总到一个列表中，并格式化为所需的输出字符串。\n该过程确保了在所有指定的参数体系（包括高度刚性的体系）下，对给定的初值问题都能得到数值上稳定且准确的解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves a stiff system of ODEs modeling market dynamics for multiple test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (a, b, theta, tau_f, tau_s, f_bar, p0, m0, f0, T)\n    test_cases = [\n        (1.0, 0.5, 0.2, 1.0e-3, 1.0, 100.0, 95.0, 0.0, 100.0, 2.0),\n        (1.0, 0.5, 0.2, 1.0e-6, 1.0, 100.0, 95.0, 0.0, 100.0, 2.0),\n        (1.0, 0.5, 0.2, 1.0e-3, 1.0, 100.0, 100.0, 0.0, 100.0, 2.0),\n        (1.0, 0.5, 0.9, 1.0e-4, 1.0, 100.0, 95.0, 0.0, 100.0, 2.0),\n        (1.0, 0.5, 0.2, 2.0e-1, 1.0, 100.0, 95.0, 0.0, 100.0, 2.0),\n    ]\n\n    results = []\n\n    def odefun(t, y, a, b, theta, tau_f, tau_s, f_bar):\n        \"\"\"\n        Defines the right-hand side of the explicit ODE system y' = F(t, y).\n        The system has been algebraically converted from DAE to ODE form.\n        y = [p, m, f]\n        \"\"\"\n        p, m, f = y\n        \n        # Equation for dp/dt\n        dp_dt = -b * p + a * m + b * f\n        \n        # Equation for dm/dt (re-arranged explicit form)\n        dm_dt = (-(theta * b) * p + (theta * a - 1) * m + (theta * b) * f) / tau_f\n        \n        # Equation for df/dt\n        df_dt = (-f + f_bar) / tau_s\n        \n        return [dp_dt, dm_dt, df_dt]\n\n    for case in test_cases:\n        # Unpack parameters, initial conditions, and terminal time\n        a, b, theta, tau_f, tau_s, f_bar, p0, m0, f0, T = case\n        \n        # Set initial condition vector and time span for the solver\n        y0 = np.array([p0, m0, f0])\n        t_span = [0, T]\n        \n        # Numerically solve the initial value problem.\n        # 'BDF' method is essential due to the stiffness of the system.\n        # Tight tolerances are used to ensure accuracy.\n        sol = solve_ivp(\n            fun=odefun,\n            t_span=t_span,\n            y0=y0,\n            method='BDF',\n            args=(a, b, theta, tau_f, tau_s, f_bar),\n            rtol=1e-8,\n            atol=1e-10\n        )\n        \n        # Extract the terminal price p(T) from the solution.\n        # sol.y contains the solution values, with shape (n_vars, n_time_points).\n        # We need the first variable at the last time point.\n        p_T = sol.y[0, -1]\n        results.append(p_T)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2374943"}]}