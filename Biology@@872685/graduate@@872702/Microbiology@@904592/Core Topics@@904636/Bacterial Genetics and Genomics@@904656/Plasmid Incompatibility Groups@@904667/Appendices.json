{"hands_on_practices": [{"introduction": "Understanding plasmid incompatibility begins with quantifying how co-resident plasmids compete for cellular resources. This exercise establishes a foundational, deterministic model to explore the core mechanism of iteron-based copy number control. By deriving the steady-state copy number, you will mathematically demonstrate how a shared replication control system imposes a fixed total \"carrying capacity,\" providing a clear rationale for why two similar plasmids cannot independently reach their optimal numbers in the same cell [@problem_id:2522959].", "problem": "In iteron-based plasmid copy number control, replication initiation is inhibited as the total number of iteron-bearing plasmids increases due to pairing (\"handcuffing\") and titration of initiator. Consider a well-mixed single bacterial cell growing exponentially with specific growth rate $\\mu$, so that any intracellular species that does not replicate is diluted at rate proportional to its abundance with coefficient $\\mu$. You are given the following modeling assumptions grounded in standard population-balance reasoning and iteron control phenomenology:\n\n1. For a single plasmid species with copy number $n(t)$, each plasmid independently attempts replication initiation with a time-homogeneous rate that decreases with the total number of iteron sites. Model this by a per-plasmid initiation rate that scales as $k/(1+\\alpha n)$, where $k>0$ is the basal initiation constant and $\\alpha>0$ quantifies the strength of initiation inhibition by iteron coupling.\n2. Each successful initiation produces one additional plasmid copy instantly.\n3. Exponential cell growth at rate $\\mu$ leads to dilution of plasmids, which is modeled deterministically as a first-order loss term $\\mu n(t)$ in the copy-number balance.\n4. Parameters satisfy $k>\\mu$ and $\\alpha>0$ so that a positive steady state exists.\n\nPart A. Starting from these assumptions and without assuming any pre-derived copy-number formula, write the mass-balance for $n(t)$ and derive the unique positive steady-state copy number $n^{\\ast}$ for the single plasmid species.\n\nPart B. Now introduce a second plasmid species with identical iteron sequences and identical kinetic parameters $k$, $\\alpha$, and the same cellular growth rate $\\mu$. Let $n_{1}(t)$ and $n_{2}(t)$ denote their copy numbers. Because the iterons are identical and cross-interacting, the initiation inhibition for each species depends on the total iteron abundance. Under the same assumptions as above but with cross-inhibition, derive the coupled mass-balance equations and determine how the steady-state shifts. In particular, characterize the steady-state condition in terms of the total copy number $N(t)=n_{1}(t)+n_{2}(t)$, and, on the symmetric branch where $n_{1}=n_{2}$, determine the per-species steady-state copy number $n_{\\mathrm{sym}}^{\\ast}$.\n\nExpress your final answer as a two-entry row vector containing the single-species steady state $n^{\\ast}$ and the symmetric per-species steady state with two identical plasmids $n_{\\mathrm{sym}}^{\\ast}$. No numerical evaluation is required. Provide your answer as closed-form analytic expressions in terms of $k$, $\\alpha$, and $\\mu$. Do not include units. If you choose to provide any numerical approximations, also provide the exact expressions; rounding instructions are not needed for this problem.", "solution": "The problem as stated is scientifically sound, well-posed, and contains sufficient information for a unique analytical solution. It describes a standard deterministic model for iteron-based plasmid copy number control, a fundamental topic in molecular microbiology. We shall proceed with the derivation.\n\nPart A: Single Plasmid Species\n\nThe dynamics of the plasmid copy number, $n(t)$, are governed by a mass-balance equation. The rate of change of $n(t)$, denoted $\\frac{dn}{dt}$, is the difference between the total rate of plasmid replication and the total rate of plasmid loss due to dilution.\n\n$1$. The production term: Each of the $n$ plasmids initiates replication with a rate $\\frac{k}{1+\\alpha n}$. Since each successful initiation event produces one new plasmid, the total production rate is the product of the number of plasmids and the per-plasmid initiation rate.\n$$\n\\text{Replication Rate} = n \\left( \\frac{k}{1+\\alpha n} \\right) = \\frac{kn}{1+\\alpha n}\n$$\n\n$2$. The loss term: The cell grows exponentially with specific growth rate $\\mu$. This leads to a dilution of the intracellular plasmid concentration, which is modeled as a first-order loss process. The total loss rate is proportional to the copy number $n$.\n$$\n\\text{Dilution Rate} = \\mu n\n$$\n\n$3$. The complete mass-balance equation is therefore:\n$$\n\\frac{dn}{dt} = \\frac{kn}{1+\\alpha n} - \\mu n\n$$\nTo find the steady-state copy number, $n^{\\ast}$, we set the rate of change to zero, $\\frac{dn}{dt} = 0$.\n$$\n\\frac{kn^{\\ast}}{1+\\alpha n^{\\ast}} - \\mu n^{\\ast} = 0\n$$\nThis equation can be factored:\n$$\nn^{\\ast} \\left( \\frac{k}{1+\\alpha n^{\\ast}} - \\mu \\right) = 0\n$$\nThis equation has two solutions. The first is the trivial solution $n^{\\ast} = 0$, which corresponds to the extinction of the plasmid. The second, non-trivial solution is found by setting the term in the parentheses to zero. This corresponds to the positive steady state we seek.\n$$\n\\frac{k}{1+\\alpha n^{\\ast}} - \\mu = 0\n$$\nThe problem states that $k > \\mu$ and $\\alpha > 0$, which guarantees the existence of a positive $n^{\\ast}$. We now solve for $n^{\\ast}$:\n$$\n\\frac{k}{1+\\alpha n^{\\ast}} = \\mu\n$$\n$$\nk = \\mu(1+\\alpha n^{\\ast})\n$$\n$$\nk = \\mu + \\mu \\alpha n^{\\ast}\n$$\n$$\nk - \\mu = \\mu \\alpha n^{\\ast}\n$$\nThe unique positive steady-state copy number for the single plasmid species is:\n$$\nn^{\\ast} = \\frac{k-\\mu}{\\mu \\alpha}\n$$\n\nPart B: Two Co-resident Plasmid Species\n\nWe now introduce a second plasmid species, with copy number $n_{2}(t)$, that has identical iteron sequences and kinetic parameters $k$ and $\\alpha$. The cell growth rate $\\mu$ remains the same. The key modification is that the replication initiation of each plasmid species is inhibited by the *total* number of iteron-bearing plasmids, $N(t) = n_{1}(t) + n_{2}(t)$.\n\n$1$. The coupled mass-balance equations are constructed following the same logic as in Part A. For plasmid species $1$, the production rate depends on its own copy number $n_{1}$ and the total copy number $N = n_{1}+n_{2}$. The dilution rate remains $\\mu n_{1}$.\n$$\n\\frac{dn_{1}}{dt} = n_{1} \\left( \\frac{k}{1+\\alpha(n_{1}+n_{2})} \\right) - \\mu n_{1}\n$$\nBy symmetry, the equation for plasmid species $2$ is:\n$$\n\\frac{dn_{2}}{dt} = n_{2} \\left( \\frac{k}{1+\\alpha(n_{1}+n_{2})} \\right) - \\mu n_{2}\n$$\n\n$2$. To characterize the steady state in terms of the total copy number $N(t)$, we derive an equation for $\\frac{dN}{dt}$ by summing the two individual rate equations:\n$$\n\\frac{dN}{dt} = \\frac{dn_{1}}{dt} + \\frac{dn_{2}}{dt} = \\left[ n_{1} \\frac{k}{1+\\alpha N} - \\mu n_{1} \\right] + \\left[ n_{2} \\frac{k}{1+\\alpha N} - \\mu n_{2} \\right]\n$$\nFactoring terms, we obtain:\n$$\n\\frac{dN}{dt} = (n_{1}+n_{2}) \\frac{k}{1+\\alpha N} - \\mu (n_{1}+n_{2})\n$$\nSubstituting $N = n_{1}+n_{2}$:\n$$\n\\frac{dN}{dt} = N \\frac{k}{1+\\alpha N} - \\mu N\n$$\nThis equation for the total copy number $N(t)$ is mathematically identical to the equation for the single-species copy number $n(t)$ derived in Part A. Therefore, the total steady-state copy number, $N^{\\ast} = n_{1}^{\\ast} + n_{2}^{\\ast}$, must be the same as the single-species steady-state copy number $n^{\\ast}$.\n$$\nN^{\\ast} = \\frac{k-\\mu}{\\mu \\alpha}\n$$\nThis result demonstrates that the total carrying capacity for plasmids sharing the same iteron-based replication control system is fixed by the parameters $k$, $\\alpha$, and $\\mu$.\n\n$3$. The problem asks for the per-species steady-state copy number on the symmetric branch, where $n_{1} = n_{2} = n_{\\mathrm{sym}}^{\\ast}$. At this symmetric steady state, the total copy number is $N^{\\ast} = n_{\\mathrm{sym}}^{\\ast} + n_{\\mathrm{sym}}^{\\ast} = 2n_{\\mathrm{sym}}^{\\ast}$.\nWe equate this to the expression for $N^{\\ast}$:\n$$\n2n_{\\mathrm{sym}}^{\\ast} = \\frac{k-\\mu}{\\mu \\alpha}\n$$\nSolving for the symmetric per-species steady state, $n_{\\mathrm{sym}}^{\\ast}$:\n$$\nn_{\\mathrm{sym}}^{\\ast} = \\frac{1}{2} \\left( \\frac{k-\\mu}{\\mu \\alpha} \\right) = \\frac{k-\\mu}{2\\mu \\alpha}\n$$\nThus, when two identical plasmids are present, they symmetrically share the total available copy number, each maintaining a copy number that is half of what a single plasmid would achieve alone. This is the mathematical basis of plasmid incompatibility for this class of plasmids.\n\nThe final answer is the two-entry row vector containing $n^{\\ast}$ and $n_{\\mathrm{sym}}^{\\ast}$.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{k-\\mu}{\\mu \\alpha} & \\frac{k-\\mu}{2\\mu \\alpha} \\end{pmatrix}}\n$$", "id": "2522959"}, {"introduction": "While deterministic models reveal the average behavior of plasmid populations, they do not capture the random fluctuations that ultimately drive one plasmid to extinction. This practice moves from the deterministic average to the stochastic reality of a single cell by formulating a birth-death process. By setting up and solving this continuous-time Markov chain, you will directly compute the probability of plasmid loss, providing a quantitative grasp of incompatibility as a stochastic race to extinction [@problem_id:2522995].", "problem": "You are to formalize a continuous-time Markov chain for two co-resident plasmids that share a replication control mechanism and thereby exhibit cross-inhibition characteristic of plasmid incompatibility groups. The process models stochastic copy-number fluctuations of two plasmid types, indexed by $i \\in \\{1,2\\}$, within a single cell. Your program must compute, for specified parameters and initial copy numbers, the probability that plasmid $1$ becomes extinct (its copy number first hits $0$) before plasmid $2$ becomes extinct. All probabilities must be reported as decimals rounded to exactly six places.\n\nBase your formulation on the following fundamental biological definitions and well-tested modeling assumptions appropriate for plasmid incompatibility: shared negative feedback in replication responds to total copy number, and random loss occurs due to degradation or partitioning at cell division. Encode these assumptions as a continuous-time birth-death process on a finite state space.\n\n1. State space:\n   - The state is $(n_1,n_2)$ with $n_1 \\in \\mathbb{Z}_{\\ge 0}$ and $n_2 \\in \\mathbb{Z}_{\\ge 0}$ constrained by $n_1 + n_2 \\le K$, where $K$ is a fixed capacity parameter that bounds total copy number.\n   - The boundary states $(0,n_2)$ with $n_2 > 0$ and $(n_1,0)$ with $n_1 > 0$ are absorbing for the purpose of the event “which plasmid is lost first,” as defined below. The state $(0,0)$ is not a valid initial state for the test suite.\n\n2. Transitions and rates:\n   - Replication (birth) of plasmid $i$ increases $n_i$ by $1$ at rate\n     $$ b_i(n_1,n_2) \\;=\\; \\alpha_i\\, n_i \\,\\max\\!\\Big(0,\\; 1 - \\frac{n_1+n_2}{K} \\Big), $$\n     where $\\alpha_i$ is the intrinsic per-copy replication attempt rate and the factor $\\max(0,\\cdot)$ enforces shared negative feedback based on total copy number. Replication is only possible from states with $n_1+n_2 < K$.\n   - Loss (death) of plasmid $i$ decreases $n_i$ by $1$ at rate\n     $$ d_i(n_1,n_2) \\;=\\; \\delta_i\\, n_i, $$\n     where $\\delta_i$ is the per-copy loss rate representing degradation and partitioning noise.\n   - No other transitions occur.\n\n3. Event of interest and extinction probability:\n   - Define $T_1$ as the hitting time of the set $\\{(0,n_2): n_2 \\ge 0\\}$ and $T_2$ as the hitting time of the set $\\{(n_1,0): n_1 \\ge 0\\}$ by the Markov chain.\n   - For any initial state $(n_1,n_2)$ with $n_1>0$ and $n_2>0$, define\n     $$ h(n_1,n_2) \\;=\\; \\mathbb{P}\\big( T_1 < T_2 \\,\\big|\\, (n_1(0),n_2(0))=(n_1,n_2) \\big), $$\n     the probability that plasmid $1$ becomes extinct before plasmid $2$.\n   - Boundary conditions are:\n     $$ h(0,n_2) \\;=\\; 1 \\quad \\text{for } n_2>0, \\qquad h(n_1,0) \\;=\\; 0 \\quad \\text{for } n_1>0. $$\n\n4. Computational task:\n   - Formulate the above as a linear system derived from first-step analysis of continuous-time Markov chains and solve for $h(n_1,n_2)$ on the finite state space with the specified parameters.\n   - Your program must compute $h(n_1,n_2)$ for each parameter set in the test suite below and produce a single line of output containing all results as a comma-separated list enclosed in square brackets, with each value rounded to exactly six decimal places.\n\n5. Test suite:\n   Use the following parameter sets, where $K$ is the capacity, $\\alpha_1$ and $\\alpha_2$ are replication parameters, $\\delta_1$ and $\\delta_2$ are loss parameters, and $(n_1,n_2)$ is the initial state. All numerical values are to be interpreted as dimensionless rates or counts:\n   - Test $1$: $K=10$, $\\alpha_1=1.0$, $\\alpha_2=1.0$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(2,2)$.\n   - Test $2$: $K=10$, $\\alpha_1=1.2$, $\\alpha_2=0.8$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(2,2)$.\n   - Test $3$: $K=10$, $\\alpha_1=1.0$, $\\alpha_2=1.0$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(0,5)$.\n   - Test $4$: $K=10$, $\\alpha_1=1.0$, $\\alpha_2=1.0$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(5,0)$.\n   - Test $5$: $K=10$, $\\alpha_1=1.0$, $\\alpha_2=1.0$, $\\delta_1=0.2$, $\\delta_2=0.2$, $(n_1,n_2)=(7,1)$.\n\n6. Final output format:\n   - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the tests above, for example\n     $$ [x_1,x_2,x_3,x_4,x_5] $$\n     where each $x_i$ is a decimal rounded to exactly six places. Do not print any other text.\n\nYour derivation must start from core definitions of continuous-time Markov chains and first-step analysis, and from the biological assumption that shared replication control depends on total copy number. You must not invoke target shortcut formulas; derive the linear equations that determine $h(n_1,n_2)$ from the generator characterization or first-step decomposition. No physical units or angles are involved in this problem. All probabilities must be reported as decimals rounded to exactly six places, not as percentages.", "solution": "The problem requires the computation of an extinction probability for one of two co-resident plasmid types, a scenario central to the study of plasmid incompatibility. The system is modeled as a continuous-time Markov chain (CTMC) on a finite two-dimensional state space. The quantity to be computed is $h(n_1, n_2)$, the probability that plasmid type $1$ becomes extinct before plasmid type $2$, given initial copy numbers $(n_1, n_2)$. This is a standard first-passage hitting probability problem.\n\nThe state of the system is given by the pair of non-negative integers $(n_1, n_2)$, representing the copy numbers of the two plasmid types. The state space is constrained by the total copy number capacity $K$, such that $\\mathcal{S} = \\{(n_1, n_2) \\in \\mathbb{Z}_{\\ge 0} \\times \\mathbb{Z}_{\\ge 0} \\mid n_1 + n_2 \\le K\\}$. This state space can be partitioned into three disjoint sets relevant to the problem:\n1. The set of interior, or transient, states $\\mathcal{S}_T = \\{(n_1, n_2) \\in \\mathcal{S} \\mid n_1 > 0, n_2 > 0\\}$. The desired probabilities for these states are the unknowns we must solve for.\n2. The target absorbing boundary for the extinction of plasmid $1$, $\\mathcal{B}_1 = \\{(0, n_2) \\in \\mathcal{S} \\mid n_2 > 0\\}$.\n3. The competing absorbing boundary for the extinction of plasmid $2$, $\\mathcal{B}_2 = \\{(n_1, 0) \\in \\mathcal{S} \\mid n_1 > 0\\}$.\n\nThe probability function $h(n_1, n_2) = \\mathbb{P}(T_1 < T_2 \\mid (n_1(0), n_2(0))=(n_1, n_2))$, where $T_i$ is the first hitting time of the set where $n_i=0$, must satisfy the boundary conditions specified by the problem definition:\n- For any state on the target boundary, $h(n_1, n_2) = 1$ if $(n_1, n_2) \\in \\mathcal{B}_1$. This is because plasmid $1$ is already extinct.\n- For any state on the competing boundary, $h(n_1, n_2) = 0$ if $(n_1, n_2) \\in \\mathcal{B}_2$. This is because plasmid $2$ became extinct first (or at the same time, which has probability zero for a CTMC, but in any case, the event $T_1 < T_2$ did not occur).\n\nFor any interior state $(n_1, n_2) \\in \\mathcal{S}_T$, the value $h(n_1, n_2)$ is governed by a set of linear equations derived from first-step analysis. For a CTMC, any bounded harmonic function (which hitting probabilities are) must satisfy $(\\mathcal{L}h)(x)=0$ for all transient states $x$, where $\\mathcal{L}$ is the generator of the process. The generator's action on a function $f$ at state $x$ is defined as $(\\mathcal{L}f)(x) = \\sum_{y \\ne x} q_{x \\to y} (f(y) - f(x))$, where $q_{x \\to y}$ is the transition rate from state $x$ to state $y$.\n\nThe specified transition rates from an arbitrary state $(n_1, n_2)$ are:\n- Replication of plasmid $1$: to $(n_1+1, n_2)$ at rate $b_1(n_1, n_2) = \\alpha_1 n_1 \\max(0, 1 - \\frac{n_1+n_2}{K})$.\n- Replication of plasmid $2$: to $(n_1, n_2+1)$ at rate $b_2(n_1, n_2) = \\alpha_2 n_2 \\max(0, 1 - \\frac{n_1+n_2}{K})$.\n- Loss of plasmid $1$: to $(n_1-1, n_2)$ at rate $d_1(n_1, n_2) = \\delta_1 n_1$.\n- Loss of plasmid $2$: to $(n_1, n_2-1)$ at rate $d_2(n_1, n_2) = \\delta_2 n_2$.\n\nSetting $(\\mathcal{L}h)(n_1, n_2) = 0$ for $(n_1, n_2) \\in \\mathcal{S}_T$ yields the following equation:\n$$ b_1(n_1, n_2) [h(n_1+1, n_2) - h(n_1, n_2)] + b_2(n_1, n_2) [h(n_1, n_2+1) - h(n_1, n_2)] $$\n$$ + d_1(n_1, n_2) [h(n_1-1, n_2) - h(n_1, n_2)] + d_2(n_1, n_2) [h(n_1, n_2-1) - h(n_1, n_2)] = 0 $$\n\nThis equation relates the unknown probability at state $(n_1, n_2)$ to the probabilities at its four neighboring states. We can rearrange this by grouping terms involving $h(n_1, n_2)$:\n$$ Q(n_1, n_2) h(n_1, n_2) - b_1(n_1, n_2) h(n_1+1, n_2) - b_2(n_1, n_2) h(n_1, n_2+1) - d_1(n_1, n_2) h(n_1-1, n_2) - d_2(n_1, n_2) h(n_1, n_2-1) = 0 $$\nwhere $Q(n_1, n_2) = b_1(n_1, n_2) + b_2(n_1, n_2) + d_1(n_1, n_2) + d_2(n_1, n_2)$ is the total rate of leaving state $(n_1, n_2)$.\n\nThis provides one linear equation for each interior state $(n_1, n_2) \\in \\mathcal{S}_T$. The number of such states is $|\\mathcal{S}_T| = \\sum_{s=2}^{K} (s-1) = \\frac{(K-1)K}{2}$. For $K=10$, we have $45$ unknown probabilities, yielding a $45 \\times 45$ system of linear equations.\n\nWe formulate this system in matrix form as $Ax = b$. The vector $x$ contains the unknown probabilities $h(n_1, n_2)$ for all $(n_1, n_2) \\in \\mathcal{S}_T$. The construction is as follows:\n1. An indexing scheme is established to map each state $(n_1, n_2) \\in \\mathcal{S}_T$ to a unique index $k \\in \\{0, 1, \\dots, |\\mathcal{S}_T|-1\\}$.\n2. For each state $(n_1, n_2)$ with index $k$, we construct the $k$-th row of the matrix $A$ and the $k$-th element of vector $b$.\n3. The diagonal element $A_{kk}$ is set to the total exit rate, $Q(n_1, n_2)$.\n4. The off-diagonal elements $A_{kj}$ are set to the negative of the transition rate from state $k$ to state $j$, provided state $j$ is also an interior state.\n5. If a transition leads to a boundary state, its known $h$ value is used. For a transition from $(n_1, n_2)$ to $(n_1-1, n_2)$ where $n_1-1=0$, we have $h(0, n_2)=1$. The term $d_1(1, n_2)h(0, n_2) = d_1(1, n_2) = \\delta_1$ is moved to the right-hand side, becoming a contribution to the element $b_k$. For a transition to a state on boundary $\\mathcal{B}_2$ where $h=0$, the contribution to the right-hand side is zero.\n\nSpecifically, for each interior state $(n_1, n_2)$ with index $k$, its corresponding equation is:\n$$ A_{kk}x_k + \\sum_{j \\ne k, j \\in \\text{indices of } \\mathcal{S}_T} A_{kj}x_j = b_k. $$\n$A_{kk} = Q(n_1, n_2)$.\nFor neighbor $(n'_1, n'_2)$ with index $j$, $A_{kj} = -q_{(n_1, n_2) \\to (n'_1, n'_2)}$.\nThe vector $b_k$ is the sum of terms $q_{(n_1, n_2) \\to (n''_1, n''_2)} h(n''_1, n''_2)$ for all boundary neighbors $(n''_1, n''_2)$. In our case, this means $b_k = \\delta_1$ if $n_1=1$, and $b_k=0$ otherwise, because only transitions to $\\mathcal{B}_1$ contribute.\n\nThe resulting linear system $Ax=b$ is solved numerically. The solution vector $x$ provides the required probabilities for all interior starting states. For test cases with initial states on the boundaries, the probabilities are given directly as $1$ or $0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It orchestrates the calculation for different parameter sets\n    and collects the results.\n    \"\"\"\n\n    test_cases = [\n        {'K': 10, 'alpha1': 1.0, 'alpha2': 1.0, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (2, 2)},\n        {'K': 10, 'alpha1': 1.2, 'alpha2': 0.8, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (2, 2)},\n        {'K': 10, 'alpha1': 1.0, 'alpha2': 1.0, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (0, 5)},\n        {'K': 10, 'alpha1': 1.0, 'alpha2': 1.0, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (5, 0)},\n        {'K': 10, 'alpha1': 1.0, 'alpha2': 1.0, 'delta1': 0.2, 'delta2': 0.2, 'initial_n': (7, 1)},\n    ]\n\n    # Cache solutions for parameter sets to avoid re-computation\n    # Key is a tuple of parameters (K, alpha1, alpha2, delta1, delta2)\n    # Value is the dictionary of h(n1, n2) values\n    h_solutions_cache = {}\n    \n    results = []\n\n    for case in test_cases:\n        K = case['K']\n        alpha1 = case['alpha1']\n        alpha2 = case['alpha2']\n        delta1 = case['delta1']\n        delta2 = case['delta2']\n        n1_init, n2_init = case['initial_n']\n\n        # Handle boundary cases directly\n        if n1_init == 0:\n            results.append(1.0)\n            continue\n        if n2_init == 0:\n            results.append(0.0)\n            continue\n            \n        param_key = (K, alpha1, alpha2, delta1, delta2)\n\n        if param_key not in h_solutions_cache:\n            h_solutions_cache[param_key] = compute_extinction_probabilities(K, alpha1, alpha2, delta1, delta2)\n\n        h_solution = h_solutions_cache[param_key]\n        result = h_solution.get((n1_init, n2_init))\n        if result is not None:\n            results.append(result)\n        else:\n            # Should not happen for valid interior states\n            raise ValueError(f\"Solution for state {(n1_init, n2_init)} not found.\")\n\n    # Format the final output string\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\ndef compute_extinction_probabilities(K, alpha1, alpha2, delta1, delta2):\n    \"\"\"\n    Formulates and solves the linear system for h(n1, n2).\n    \n    Returns:\n        A dictionary mapping interior states (n1, n2) to their\n        extinction probabilities h(n1, n2).\n    \"\"\"\n    \n    # 1. Map interior states (n1>0, n2>0, n1+n2=K) to indices\n    state_to_idx = {}\n    idx_to_state = []\n    idx = 0\n    # Total copy number s = n1 + n2\n    for s in range(2, K + 1):\n        # n1 runs from 1 to s-1, ensuring n1>0 and n2=s-n1>0\n        for n1 in range(1, s):\n            n2 = s - n1\n            state = (n1, n2)\n            state_to_idx[state] = idx\n            idx_to_state.append(state)\n            idx += 1\n    \n    num_interior_states = len(idx_to_state)\n    \n    # 2. Build the linear system Ax = b\n    A = np.zeros((num_interior_states, num_interior_states))\n    b = np.zeros(num_interior_states)\n    \n    for k in range(num_interior_states):\n        n1, n2 = idx_to_state[k]\n        \n        # Calculate transition rates from state (n1, n2)\n        total_n = n1 + n2\n        rep_factor = max(0, 1 - total_n / K)\n        \n        b1_rate = alpha1 * n1 * rep_factor\n        b2_rate = alpha2 * n2 * rep_factor\n        d1_rate = delta1 * n1\n        d2_rate = delta2 * n2\n        \n        total_q = b1_rate + b2_rate + d1_rate + d2_rate\n        A[k, k] = total_q\n        \n        # Transitions to neighboring states\n        \n        # a) Replication of plasmid 1: (n1+1, n2)\n        # This is only possible if total_n  K\n        if total_n  K:\n            neighbor_state = (n1 + 1, n2)\n            neighbor_idx = state_to_idx[neighbor_state]\n            A[k, neighbor_idx] = -b1_rate\n        \n        # b) Replication of plasmid 2: (n1, n2+1)\n        # This is only possible if total_n  K\n        if total_n  K:\n            neighbor_state = (n1, n2 + 1)\n            neighbor_idx = state_to_idx[neighbor_state]\n            A[k, neighbor_idx] = -b2_rate\n            \n        # c) Loss of plasmid 1: (n1-1, n2)\n        if n1 - 1 > 0:\n            # Neighbor is an interior state\n            neighbor_state = (n1 - 1, n2)\n            neighbor_idx = state_to_idx[neighbor_state]\n            A[k, neighbor_idx] = -d1_rate\n        else:\n            # Neighbor is on the boundary {n1=0}, where h=1\n            b[k] += d1_rate * 1.0\n            \n        # d) Loss of plasmid 2: (n1, n2-1)\n        if n2 - 1 > 0:\n            # Neighbor is an interior state\n            neighbor_state = (n1, n2 - 1)\n            neighbor_idx = state_to_idx[neighbor_state]\n            A[k, neighbor_idx] = -d2_rate\n        else:\n            # Neighbor is on the boundary {n2=0}, where h=0\n            b[k] += d2_rate * 0.0\n\n    # 3. Solve the linear system Ax = b\n    h_vector = np.linalg.solve(A, b)\n    \n    # 4. Create a dictionary of solutions\n    h_solutions = {idx_to_state[i]: h_vector[i] for i in range(num_interior_states)}\n    \n    return h_solutions\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2522995"}, {"introduction": "Moving from theoretical models to practical genomics, a crucial task is to classify newly sequenced plasmids into their respective incompatibility groups. This exercise bridges this gap by guiding you through the construction of a Naive Bayes classifier, a powerful tool in modern bioinformatics. You will learn to formalize biological intuition—that replication proteins and DNA motifs are predictive of Inc groups—into a statistical framework capable of making probabilistic assignments from sequence-derived features [@problem_id:2522962].", "problem": "You are asked to formalize a principled Bayesian classifier for plasmid incompatibility (Inc) group assignment that integrates two biologically motivated features derived from a plasmid: (i) replication initiation protein (Rep) sequence similarity and (ii) presence or absence of an iteron motif. In bacterial plasmid biology, Inc groups are operationally defined sets of plasmids that cannot be stably maintained together in the same cell due to shared replication control systems; these systems often involve Rep proteins and iteron repeats. Your task is to implement a classifier that computes, for each test case, the posterior probability over a fixed set of Inc groups, given a scalar Rep similarity score and a binary iteron motif indicator.\n\nUse the following fundamental base:\n- Bayes’ theorem: for a discrete class variable $G$ and observed features $X$, the posterior is\n$$\nP(G=g \\mid X) \\;=\\; \\frac{P(X \\mid G=g)\\,P(G=g)}{\\sum\\_{h} P(X \\mid G=h)\\,P(G=h)}.\n$$\n- Conditional independence assumption: conditioned on $G$, the features are independent.\n- Beta distribution for similarity scores on $[0,1]$ and Bernoulli distribution for binary motif presence, both widely used for modeling such data types.\n\nModel specification:\n- Let the class variable $G$ take values in the ordered set $\\{ \\text{IncF}, \\text{IncI}, \\text{IncP}, \\text{IncQ} \\}$.\n- Let the observed feature vector be $(s, m)$ where $s \\in [0,1]$ is the Rep similarity score (unitless fraction), and $m \\in \\{0,1\\}$ indicates iteron motif presence ($m=1$) or absence ($m=0$).\n- Assume the following generative model:\n  - Prior over classes: $P(G=g) = \\pi\\_g$.\n  - Likelihood for the similarity score: $s \\mid (G=g) \\sim \\mathrm{Beta}(\\alpha\\_g, \\beta\\_g)$ with probability density\n    $$\n    f\\_g(s) \\;=\\; \\frac{s^{\\alpha\\_g-1} (1-s)^{\\beta\\_g-1}}{B(\\alpha\\_g,\\beta\\_g)},\n    $$\n    where $B(\\cdot,\\cdot)$ is the Beta function.\n  - Likelihood for the motif indicator: $m \\mid (G=g) \\sim \\mathrm{Bernoulli}(\\rho\\_g)$ with probability mass function\n    $$\n    p\\_g(m) \\;=\\; \\rho\\_g^{\\,m}\\,(1-\\rho\\_g)^{\\,1-m}.\n    $$\n  - Conditional independence: $P(s,m \\mid G=g) = f\\_g(s)\\,p\\_g(m)$.\n- Therefore, the posterior for each group $g$ given $(s,m)$ is\n$$\nP(G=g \\mid s,m) \\;=\\; \\frac{\\pi\\_g \\, f\\_g(s) \\, p\\_g(m)}{\\sum\\_{h \\in \\{\\text{IncF},\\text{IncI},\\text{IncP},\\text{IncQ}\\}} \\pi\\_h \\, f\\_h(s) \\, p\\_h(m)}.\n$$\n\nUse the following fixed parameter values, in the exact group order $\\{\\text{IncF},\\text{IncI},\\text{IncP},\\text{IncQ}\\}$:\n- Priors $\\pi$: $\\pi = [0.35,\\, 0.25,\\, 0.25,\\, 0.15]$.\n- Beta parameters $(\\alpha, \\beta)$:\n  - IncF: $(\\alpha, \\beta) = (22, 4)$,\n  - IncI: $(\\alpha, \\beta) = (12, 6)$,\n  - IncP: $(\\alpha, \\beta) = (6, 12)$,\n  - IncQ: $(\\alpha, \\beta) = (3, 3)$.\n- Bernoulli parameters $\\rho$ (motif presence probabilities):\n  - IncF: $\\rho = 0.9$,\n  - IncI: $\\rho = 0.6$,\n  - IncP: $\\rho = 0.2$,\n  - IncQ: $\\rho = 0.5$.\n\nNumerical stability requirements:\n- When evaluating logarithms of $s$, $1-s$, $\\rho$, and $1-\\rho$, clip each argument into the closed interval $[\\varepsilon, 1-\\varepsilon]$ with $\\varepsilon = 10^{-12}$ before taking the logarithm.\n- It is acceptable to compute the posterior in log space using the log-sum-exp trick.\n\nYour program must implement the classifier that, for each test case $(s,m)$, returns the posterior vector\n$$\n\\left[P(G=\\text{IncF} \\mid s,m),\\, P(G=\\text{IncI} \\mid s,m),\\, P(G=\\text{IncP} \\mid s,m),\\, P(G=\\text{IncQ} \\mid s,m)\\right].\n$$\n\nTest suite:\nCompute posteriors for the following six cases, in this exact order, where each $s$ is unitless and each $m$ is an integer in $\\{0,1\\}$:\n1. $(s,m) = (0.92, 1)$,\n2. $(s,m) = (0.78, 0)$,\n3. $(s,m) = (0.30, 1)$,\n4. $(s,m) = (0.55, 0)$,\n5. $(s,m) = (1.00, 0)$,\n6. $(s,m) = (0.00, 1)$.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of six posterior vectors, one per test case, in the specified group order. Each posterior vector must be a list of four floating-point numbers rounded to exactly six digits after the decimal point. The overall output must be a single list of lists, with no spaces anywhere in the line. For example, an output with two cases would look like\n$$\n[[0.100000,0.200000,0.300000,0.400000],[0.250000,0.250000,0.250000,0.250000]].\n$$\n- For this problem, you must produce\n$$\n\\left[\\text{post}(0.92,1),\\,\\text{post}(0.78,0),\\,\\text{post}(0.30,1),\\,\\text{post}(0.55,0),\\,\\text{post}(1.00,0),\\,\\text{post}(0.00,1)\\right],\n$$\nwith each $\\text{post}(s,m)$ rounded as specified and arranged in the exact order above.", "solution": "The problem requires the formulation and implementation of a Naive Bayes classifier to determine the posterior probability distribution over a set of plasmid incompatibility (Inc) groups, given two features: a replication initiation protein (Rep) similarity score, $s$, and a binary indicator for the presence of an iteron motif, $m$.\n\nThe problem has been validated and is deemed scientifically sound, well-posed, and objective. It presents a standard application of Bayesian statistical inference to a problem in computational biology. All necessary parameters and definitions are provided, and the task is a direct implementation of the specified model.\n\nThe core of the classifier is Bayes' theorem, which relates the posterior probability of a class (Inc group $g$) to the prior probability of that class and the likelihood of observing the data given the class. The class variable $G$ can take one of four values from the set $\\{\\text{IncF}, \\text{IncI}, \\text{IncP}, \\text{IncQ}\\}$. The observed features are the vector $X = (s,m)$, where $s \\in [0,1]$ is the similarity score and $m \\in \\{0,1\\}$ is the motif indicator.\n\nThe posterior probability for a group $g$ is given by:\n$$\nP(G=g \\mid s,m) = \\frac{P(s,m \\mid G=g) P(G=g)}{\\sum_{h} P(s,m \\mid G=h) P(G=h)}\n$$\nThe problem specifies a conditional independence (Naive Bayes) assumption, meaning the features $s$ and $m$ are independent given the group $G$. Thus, the likelihood term factorizes:\n$$\nP(s,m \\mid G=g) = P(s \\mid G=g) P(m \\mid G=g)\n$$\nThe model components are defined as follows:\n1.  **Prior probability**: The prior probability of a plasmid belonging to Inc group $g$ is denoted by $P(G=g) = \\pi_g$.\n2.  **Likelihood of similarity score**: The score $s$, conditioned on the group $g$, is modeled by a Beta distribution, $s \\mid (G=g) \\sim \\mathrm{Beta}(\\alpha_g, \\beta_g)$. Its probability density function (PDF) is $f_g(s)$:\n    $$\n    f_g(s) = P(s \\mid G=g) = \\frac{s^{\\alpha_g-1} (1-s)^{\\beta_g-1}}{B(\\alpha_g,\\beta_g)}\n    $$\n    where $B(\\alpha_g, \\beta_g)$ is the Beta function.\n3.  **Likelihood of motif indicator**: The motif indicator $m$, conditioned on the group $g$, is modeled by a Bernoulli distribution, $m \\mid (G=g) \\sim \\mathrm{Bernoulli}(\\rho_g)$. Its probability mass function (PMF) is $p_g(m)$:\n    $$\n    p_g(m) = P(m \\mid G=g) = \\rho_g^m (1-\\rho_g)^{1-m}\n    $$\nSubstituting these into the posterior formula yields:\n$$\nP(G=g \\mid s,m) = \\frac{\\pi_g f_g(s) p_g(m)}{\\sum_{h} \\pi_h f_h(s) p_h(m)}\n$$\nDirect computation of this expression can lead to numerical underflow due to the multiplication of small probability values. A more stable approach is to work in logarithmic space. The unnormalized log-posterior, or log-joint probability, for group $g$ is:\n$$\n\\log J(g; s,m) = \\log\\left(\\pi_g f_g(s) p_g(m)\\right) = \\log(\\pi_g) + \\log(f_g(s)) + \\log(p_g(m))\n$$\nExpanding the log-likelihood terms:\n$$\n\\log(f_g(s)) = (\\alpha_g-1)\\log(s) + (\\beta_g-1)\\log(1-s) - \\log B(\\alpha_g, \\beta_g)\n$$\n$$\n\\log(p_g(m)) = m\\log(\\rho_g) + (1-m)\\log(1-\\rho_g)\n$$\nThe problem specifies a numerical stability requirement for evaluating logarithms at the boundaries of the domain (e.g., $s=0$ or $s=1$). The argument $x$ of any logarithm, $\\log(x)$, must first be clipped to the interval $[\\varepsilon, 1-\\varepsilon]$, where $\\varepsilon = 10^{-12}$. This procedure applies to the arguments $s$, $1-s$, $\\rho_g$, and $1-\\rho_g$. The term $\\log B(\\alpha_g, \\beta_g)$ can be computed robustly using log-gamma functions, as $\\log B(\\alpha, \\beta) = \\log\\Gamma(\\alpha) + \\log\\Gamma(\\beta) - \\log\\Gamma(\\alpha+\\beta)$, a function commonly available as `betaln` in scientific computing libraries.\n\nAfter computing the vector of log-joint probabilities $\\mathbf{L} = [\\log J(g; s,m)]$ for all groups $g$, we convert them back to a normalized posterior probability distribution. To avoid overflow and underflow during exponentiation, the log-sum-exp trick is employed. Let $L_{\\max} = \\max_g(\\mathbf{L})$. The posterior probability for group $g$ is:\n$$\nP(G=g \\mid s,m) = \\frac{\\exp(\\log J(g; s,m))}{\\sum_h \\exp(\\log J(h; s,m))} = \\frac{\\exp(\\log J(g; s,m) - L_{\\max})}{\\sum_h \\exp(\\log J(h; s,m) - L_{\\max})}\n$$\nThis calculation is robust against floating-point precision issues.\n\nThe computational algorithm proceeds as follows for each test case $(s,m)$:\n1.  Define the parameter vectors for priors $\\boldsymbol{\\pi}$, Beta parameters $\\boldsymbol{\\alpha}$ and $\\boldsymbol{\\beta}$, and Bernoulli parameters $\\boldsymbol{\\rho}$.\n2.  Calculate the vector of log-priors: $\\log(\\boldsymbol{\\pi})$.\n3.  Calculate the vector of log-likelihoods for the similarity score $s$. This involves clipping $s$ and $1-s$ to $[\\varepsilon, 1-\\varepsilon]$ before taking their logarithms, and using the formula for the log-PDF of the Beta distribution.\n4.  Calculate the vector of log-likelihoods for the motif indicator $m$. This uses the formula for the log-PMF of the Bernoulli distribution. The parameters $\\boldsymbol{\\rho}$ and $1-\\boldsymbol{\\rho}$ are also clipped, though for the given values this has no effect.\n5.  Sum the log-prior and the two log-likelihood vectors to obtain the log-joint vector $\\mathbf{L}$.\n6.  Normalize $\\mathbf{L}$ using the log-sum-exp procedure to obtain the final posterior probability vector.\n7.  Format the resulting vector according to the specified output requirements.", "answer": "```python\nimport numpy as np\nfrom scipy.special import betaln\n\ndef solve():\n    \"\"\"\n    Implements a Bayesian classifier for plasmid incompatibility group assignment.\n    \"\"\"\n    # Fixed parameters in the order {IncF, IncI, IncP, IncQ}\n    PIS = np.array([0.35, 0.25, 0.25, 0.15])\n    ALPHAS = np.array([22, 12, 6, 3])\n    BETAS = np.array([4, 6, 12, 3])\n    RHOS = np.array([0.9, 0.6, 0.2, 0.5])\n    \n    # Numerical stability constant\n    EPSILON = 1e-12\n\n    # Test cases: (s, m)\n    test_cases = [\n        (0.92, 1),\n        (0.78, 0),\n        (0.30, 1),\n        (0.55, 0),\n        (1.00, 0),\n        (0.00, 1),\n    ]\n\n    # Pre-compute log priors and log beta function values\n    log_priors = np.log(PIS)\n    log_beta_funcs = betaln(ALPHAS, BETAS)\n    \n    # Pre-clip rho values as per the problem statement\n    clipped_rhos = np.clip(RHOS, EPSILON, 1.0 - EPSILON)\n    clipped_one_minus_rhos = np.clip(1.0 - RHOS, EPSILON, 1.0 - EPSILON)\n    log_rhos = np.log(clipped_rhos)\n    log_one_minus_rhos = np.log(clipped_one_minus_rhos)\n\n    results_as_strings = []\n    for s, m in test_cases:\n        # Clip similarity score arguments for log as specified\n        s_clipped = np.clip(s, EPSILON, 1.0 - EPSILON)\n        one_minus_s_clipped = np.clip(1.0 - s, EPSILON, 1.0 - EPSILON)\n        \n        # Calculate log-likelihood for the Beta distribution\n        log_s = np.log(s_clipped)\n        log_one_minus_s = np.log(one_minus_s_clipped)\n        log_likelihood_beta = (ALPHAS - 1) * log_s + (BETAS - 1) * log_one_minus_s - log_beta_funcs\n        \n        # Calculate log-likelihood for the Bernoulli distribution\n        log_likelihood_bern = m * log_rhos + (1 - m) * log_one_minus_rhos\n        \n        # Calculate unnormalized log-posterior (log-joint)\n        log_joint = log_priors + log_likelihood_beta + log_likelihood_bern\n        \n        # Normalize using the log-sum-exp trick for numerical stability\n        log_joint_max = np.max(log_joint)\n        scaled_joint = np.exp(log_joint - log_joint_max)\n        posterior = scaled_joint / np.sum(scaled_joint)\n        \n        # Format the posterior vector as a string\n        formatted_posterior = [f\"{p:.6f}\" for p in posterior]\n        results_as_strings.append(f\"[{','.join(formatted_posterior)}]\")\n\n    # Print the final result in the exact required format\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "2522962"}]}