{"hands_on_practices": [{"introduction": "Mastering the translation of biochemical processes into a computable format is a foundational skill in systems biology. This first exercise [@problem_id:2776472] guides you through the construction of a basic bimolecular reaction model in SBML, focusing on the critical details of unit handling and the distinction between species represented by amount versus concentration. Properly implementing these concepts is essential for creating valid, reproducible models that can be reliably exchanged and simulated.", "problem": "You are asked to formalize a simple bimolecular reaction in the Systems Biology Markup Language (SBML) and compute its reaction rate consistently with SBML unit semantics. The reaction is $A + B \\xrightarrow{k} C$ in a single well-mixed compartment. You must conceptually construct the SBML entities and, using the law of mass action, derive and implement a kinetic law that yields a production rate for $C$ in amount per time with correct units. Your program will evaluate the derived kinetic law on a provided test suite and validate dimensional consistency by unit algebra.\n\nFundamental basis for derivation:\n- Law of mass action: for an elementary bimolecular reaction, the reaction rate is proportional to the product of reactant concentrations.\n- Definitions: concentration $c_X = n_X / V$, where $n_X$ is amount (in $\\mathrm{mol}$) and $V$ is volume (in $\\mathrm{L}$); production rate of $C$ as amount per time is $dn_C/dt$ in $\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n- Unit algebra: treat base units $\\mathrm{mol}$, $\\mathrm{L}$, and $\\mathrm{s}$ with exponent arithmetic under multiplication and division.\n\nSBML entities to be constructed conceptually:\n- Compartment: a single compartment named “cell” with constant size $V$ (units $\\mathrm{L}$).\n- Species: three species $A$, $B$, and $C$. Depending on representation:\n  - If species are represented by amount, use `initialAmount` with units $\\mathrm{mol}$ and set `hasOnlySubstanceUnits=\"true\"`.\n  - If species are represented by concentration, use `initialConcentration` with units $\\mathrm{mol}\\,\\mathrm{L}^{-1}$ and set `hasOnlySubstanceUnits=\"false\"`.\n- Parameter: a global parameter $k$ for the rate constant with units $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n- Reaction: a single irreversible reaction $A + B \\rightarrow C$ with a kinetic law that yields $dn_C/dt$ in $\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n\nKinetic law to implement based on representation choice:\n- If species values are amounts $n_A$ and $n_B$ in $\\mathrm{mol}$, then use\n$$\n\\frac{dn_C}{dt} \\;=\\; k\\,\\frac{n_A\\,n_B}{V},\n$$\nwhich has units $\\mathrm{mol}\\,\\mathrm{s}^{-1}$ when $k$ is in $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$ and $V$ in $\\mathrm{L}$.\n- If species values are concentrations $c_A$ and $c_B$ in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$, then use\n$$\n\\frac{dn_C}{dt} \\;=\\; V\\,k\\,c_A\\,c_B,\n$$\nwhich also yields $\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n\nYour program must:\n1. For each test case, compute the numeric production rate of $C$ as $dn_C/dt$ in $\\mathrm{mol}\\,\\mathrm{s}^{-1}$ according to the specified representation (amount or concentration), with $k$ in $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$ and $V$ in $\\mathrm{L}$.\n2. Validate dimensional consistency by computing the composite unit exponents for the kinetic law and checking they equal the target unit $\\mathrm{mol}^1\\,\\mathrm{L}^0\\,\\mathrm{s}^{-1}$.\n3. Output, for each test case, a list of two elements: the computed rate as a float (in $\\mathrm{mol}\\,\\mathrm{s}^{-1}$) and a boolean indicating whether the unit check passed.\n\nPhysical units: all amounts must be in $\\mathrm{mol}$, volumes in $\\mathrm{L}$, time in $\\mathrm{s}$, and concentrations in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$. If a test case specifies a molecular count, convert molecules to moles using Avogadro’s constant $N_A = 6.02214076\\times 10^{23}\\ \\mathrm{mol}^{-1}$.\n\nAngle units do not apply. No percentages are used.\n\nTest suite (all constants and values must be used exactly as specified):\n- Case 1 (amounts, nonzero): $n_A = 2\\times 10^{-6}\\ \\mathrm{mol}$, $n_B = 3\\times 10^{-6}\\ \\mathrm{mol}$, $V = 10^{-3}\\ \\mathrm{L}$, $k = 10^{3}\\ \\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n- Case 2 (concentrations, equivalence check): $c_A = 2\\times 10^{-3}\\ \\mathrm{mol}\\,\\mathrm{L}^{-1}$, $c_B = 3\\times 10^{-3}\\ \\mathrm{mol}\\,\\mathrm{L}^{-1}$, $V = 10^{-3}\\ \\mathrm{L}$, $k = 10^{3}\\ \\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n- Case 3 (boundary, zero reactant): $n_A = 10^{-6}\\ \\mathrm{mol}$, $n_B = 0\\ \\mathrm{mol}$, $V = 10^{-3}\\ \\mathrm{L}$, $k = 10^{3}\\ \\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n- Case 4 (cell-scale amounts via molecules): $N_A = 6.02214076\\times 10^{23}\\ \\mathrm{mol}^{-1}$, $N_A$ must be used to convert molecule counts to moles. Let $n_A = 100/N_A\\ \\mathrm{mol}$ and $n_B = 100/N_A\\ \\mathrm{mol}$, $V = 10^{-15}\\ \\mathrm{L}$, $k = 10^{6}\\ \\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- Each element must itself be a two-element list $[rate,unit\\_ok]$, where $rate$ is the computed float in $\\mathrm{mol}\\,\\mathrm{s}^{-1}$ and $unit\\_ok$ is a boolean.\n- For example, the shape must be like $[[r_1,b_1],[r_2,b_2],[r_3,b_3],[r_4,b_4]]$ with no extra whitespace or text.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded in fundamental principles of chemical kinetics, well-posed, objective, and internally consistent. All necessary parameters and definitions for a unique solution are provided. We may therefore proceed with the derivation and computation.\n\nThe problem requires the formalization and evaluation of a kinetic law for the elementary bimolecular reaction $A + B \\xrightarrow{k} C$ within a single, well-mixed compartment of constant volume $V$. The objective is to compute the production rate of species $C$ in units of amount per time ($\\mathrm{mol}\\,\\mathrm{s}^{-1}$), consistent with the semantics of the Systems Biology Markup Language (SBML).\n\nThe cornerstone of this analysis is the Law of Mass Action. For the given reaction, the rate of reaction, $v$, is proportional to the product of the concentrations of the reactants. Let $[A]$ and $[B]$ denote the concentrations of species $A$ and $B$, respectively. The reaction rate is then given by:\n$$\nv = k [A] [B]\n$$\nThe rate constant $k$ has units that ensure dimensional homogeneity. Since $[A]$ and $[B]$ are in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$, and the reaction rate $v$ is conventionally expressed in concentration per time ($\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$), the units of $k$ must be $(\\mathrm{mol}\\,\\mathrm{L}^{-1})^{-1}\\,\\mathrm{s}^{-1}$, which simplifies to $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$. This matches the units provided in the problem statement.\n\nSBML kinetic laws, however, must be formulated to return a rate of change in amount per time (e.g., $\\mathrm{mol}\\,\\mathrm{s}^{-1}$), not concentration per time. The rate of change of the amount of a species $X$, denoted $n_X$, is related to the reaction rate $v$ and the compartment volume $V$ by:\n$$\n\\frac{dn_X}{dt} = \\nu_X \\cdot V \\cdot v\n$$\nwhere $\\nu_X$ is the stoichiometric coefficient of species $X$ in the reaction. For the product $C$, the stoichiometric coefficient is $\\nu_C = +1$. Therefore, the production rate of $C$ is:\n$$\n\\frac{dn_C}{dt} = V \\cdot v = V \\cdot k [A] [B]\n$$\nThis is the fundamental equation from which we derive the specific kinetic laws based on how species quantities are represented.\n\nThere are two common representations for species in SBML, which the problem requires us to handle:\n\n1.  **Species represented by concentration**: If the model provides species quantities as concentrations $c_A$ and $c_B$ (in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$), we can directly substitute $[A] = c_A$ and $[B] = c_B$ into our fundamental equation:\n    $$\n    \\frac{dn_C}{dt} = V\\,k\\,c_A\\,c_B\n    $$\n    This is the first kinetic law provided in the problem statement.\n\n2.  **Species represented by amount**: If the model provides species quantities as amounts $n_A$ and $n_B$ (in $\\mathrm{mol}$), we must first express their concentrations using the compartment volume $V$. The concentration is defined as amount divided by volume, so $[A] = n_A/V$ and $[B] = n_B/V$. Substituting these into the fundamental equation yields:\n    $$\n    \\frac{dn_C}{dt} = V \\cdot k \\left(\\frac{n_A}{V}\\right) \\left(\\frac{n_B}{V}\\right) = k \\frac{n_A n_B}{V}\n    $$\n    This is the second kinetic law provided in the problem statement.\n\nThe problem also mandates a validation of dimensional consistency. We represent the units in terms of their exponents for the base dimensions of amount ($\\mathrm{mol}$), length cubed or volume ($\\mathrm{L}$), and time ($\\mathrm{s}$). The target unit for $\\frac{dn_C}{dt}$ is $\\mathrm{mol}\\,\\mathrm{s}^{-1}$, corresponding to the exponent vector $[\\mathrm{mol}: 1, \\mathrm{L}: 0, \\mathrm{s}: -1]$.\n\nLet us perform the dimensional analysis for the amount-based representation as an example. The units of the terms are:\n-   $k$: $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1} \\implies [\\mathrm{mol}: -1, \\mathrm{L}: 1, \\mathrm{s}: -1]$\n-   $n_A$, $n_B$: $\\mathrm{mol} \\implies [\\mathrm{mol}: 1, \\mathrm{L}: 0, \\mathrm{s}: 0]$\n-   $V$: $\\mathrm{L} \\implies [\\mathrm{mol}: 0, \\mathrm{L}: 1, \\mathrm{s}: 0]$\n\nFor the expression $k \\frac{n_A n_B}{V}$, we sum the exponents for multiplication and subtract for division:\n-   $\\mathrm{mol}$ exponent: $(-1) + 1 + 1 - 0 = 1$\n-   $\\mathrm{L}$ exponent: $1 + 0 + 0 - 1 = 0$\n-   $\\mathrm{s}$ exponent: $(-1) + 0 + 0 - 0 = -1$\nThe resulting unit exponent vector is $[1, 0, -1]$, which correctly matches the target unit of $\\mathrm{mol}\\,\\mathrm{s}^{-1}$. A similar analysis for the concentration-based formula $V k c_A c_B$ yields the same result, confirming the dimensional consistency of both formulations.\n\nWe now apply these validated formulas to the provided test suite.\n\n**Case 1 (amounts, nonzero):**\n-   Given: $n_A = 2 \\times 10^{-6}\\,\\mathrm{mol}$, $n_B = 3 \\times 10^{-6}\\,\\mathrm{mol}$, $V = 10^{-3}\\,\\mathrm{L}$, $k = 10^3\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n-   Formula: $\\frac{dn_C}{dt} = k \\frac{n_A n_B}{V}$.\n-   Calculation: $\\frac{dn_C}{dt} = (10^3) \\frac{(2 \\times 10^{-6})(3 \\times 10^{-6})}{10^{-3}} = 10^3 \\frac{6 \\times 10^{-12}}{10^{-3}} = 6 \\times 10^{-6}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n-   Result: $[6.0 \\times 10^{-6}, \\mathrm{True}]$.\n\n**Case 2 (concentrations, equivalence check):**\n-   Given: $c_A = 2 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $c_B = 3 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $V = 10^{-3}\\,\\mathrm{L}$, $k = 10^3\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n-   Formula: $\\frac{dn_C}{dt} = V k c_A c_B$.\n-   Calculation: $\\frac{dn_C}{dt} = (10^{-3})(10^3)(2 \\times 10^{-3})(3 \\times 10^{-3}) = 6 \\times 10^{-6}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n-   This result is identical to Case 1, as expected, since the reactant concentrations correspond precisely ($n_A/V = 2 \\times 10^{-6} / 10^{-3} = 2 \\times 10^{-3} = c_A$).\n-   Result: $[6.0 \\times 10^{-6}, \\mathrm{True}]$.\n\n**Case 3 (boundary, zero reactant):**\n-   Given: $n_A = 10^{-6}\\,\\mathrm{mol}$, $n_B = 0\\,\\mathrm{mol}$, $V = 10^{-3}\\,\\mathrm{L}$, $k = 10^3\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n-   Formula: $\\frac{dn_C}{dt} = k \\frac{n_A n_B}{V}$.\n-   Calculation: $\\frac{dn_C}{dt} = (10^3) \\frac{(10^{-6})(0)}{10^{-3}} = 0\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n-   Result: $[0.0, \\mathrm{True}]$.\n\n**Case 4 (cell-scale amounts via molecules):**\n-   Given: $N_\\text{molecules} = 100$, $V = 10^{-15}\\,\\mathrm{L}$, $k = 10^6\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$. Avogadro's constant $N_A = 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1}$.\n-   First, convert molecule counts to moles: $n_A = n_B = 100 / N_A = 100 / (6.02214076 \\times 10^{23})\\,\\mathrm{mol}$.\n-   Formula: $\\frac{dn_C}{dt} = k \\frac{n_A n_B}{V}$.\n-   Calculation: $\\frac{dn_C}{dt} = (10^6) \\frac{(100/N_A)^2}{10^{-15}} = 10^6 \\frac{10^4/N_A^2}{10^{-15}} = \\frac{10^{25}}{N_A^2} = \\frac{10^{25}}{(6.02214076 \\times 10^{23})^2} \\approx 2.757434 \\times 10^{-23}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n-   Result: $[\\approx 2.757434 \\times 10^{-23}, \\mathrm{True}]$.\n\nThe implementation will follow this logic to compute the values for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes reaction rates and validates units for a bimolecular reaction\n    according to SBML semantics.\n    \"\"\"\n    # Avogadro's constant, as specified.\n    N_A = 6.02214076e23\n\n    # Test suite definition. Each case is a dictionary for clarity.\n    test_cases = [\n        {\n            \"type\": \"amount\", \"params\": {\"nA\": 2e-6, \"nB\": 3e-6, \"V\": 1e-3, \"k\": 1e3}\n        },\n        {\n            \"type\": \"concentration\", \"params\": {\"cA\": 2e-3, \"cB\": 3e-3, \"V\": 1e-3, \"k\": 1e3}\n        },\n        {\n            \"type\": \"amount\", \"params\": {\"nA\": 1e-6, \"nB\": 0.0, \"V\": 1e-3, \"k\": 1e3}\n        },\n        {\n            \"type\": \"amount\", \"params\": {\"nA\": 100 / N_A, \"nB\": 100 / N_A, \"V\": 1e-15, \"k\": 1e6}\n        }\n    ]\n\n    def check_units(case_type):\n        \"\"\"\n        Performs dimensional analysis by operating on unit exponent vectors.\n        The base units are [mol, L, s].\n        \"\"\"\n        # Target unit is mol^1 L^0 s^-1\n        target_exponents = np.array([1, 0, -1])\n        \n        # Unit exponents for each parameter\n        unit_exponents = {\n            \"k\": np.array([-1, 1, -1]),  # L / (mol * s)\n            \"V\": np.array([0, 1, 0]),    # L\n            \"n\": np.array([1, 0, 0]),    # mol\n            \"c\": np.array([1, -1, 0]),   # mol / L\n        }\n\n        if case_type == \"amount\":\n            # rate = k * nA * nB / V\n            # units = (k) * (n) * (n) / (V)\n            computed_exponents = (unit_exponents[\"k\"] + \n                                  unit_exponents[\"n\"] + \n                                  unit_exponents[\"n\"] - \n                                  unit_exponents[\"V\"])\n        elif case_type == \"concentration\":\n            # rate = V * k * cA * cB\n            # units = (V) * (k) * (c) * (c)\n            computed_exponents = (unit_exponents[\"V\"] + \n                                  unit_exponents[\"k\"] + \n                                  unit_exponents[\"c\"] + \n                                  unit_exponents[\"c\"])\n        else:\n            # Should not be reached with the current test suite.\n            return False\n\n        return np.array_equal(computed_exponents, target_exponents)\n\n    results = []\n    for case in test_cases:\n        case_type = case[\"type\"]\n        params = case[\"params\"]\n        rate = 0.0\n        \n        # Calculate the rate based on the representation type\n        if case_type == \"amount\":\n            rate = params[\"k\"] * params[\"nA\"] * params[\"nB\"] / params[\"V\"]\n        elif case_type == \"concentration\":\n            rate = params[\"V\"] * params[\"k\"] * params[\"cA\"] * params[\"cB\"]\n        \n        # Perform the unit check\n        unit_ok = check_units(case_type)\n        \n        results.append([rate, unit_ok])\n\n    # The final print statement must follow the exact specified format.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2776472"}, {"introduction": "The journey from a biological design to a dynamic model often involves information that doesn't fit neatly into a system of equations. This practice [@problem_id:2776305] explores the crucial task of mapping non-dynamic structural information from an SBOL design, such as assembly scars or combinatorial libraries, into an SBML model. You will evaluate different strategies for preserving this design intent using SBML's annotation features, learning how to enrich models without altering their core mathematical semantics.", "problem": "A team is building an automated exporter from Synthetic Biology Open Language (SBOL) to Systems Biology Markup Language (SBML) so that a design can be simulated while preserving as much design intent as possible. Start from the following fundamentals: SBOL captures sequence-level structure, modular hierarchy, design intent, constraints, provenance, and links to ontologies for physical parts; SBML encodes quantitative models of biochemical networks whose semantics are given by ordinary differential equations of the form $\\frac{d \\mathbf{x}}{dt}=\\mathbf{f}(\\mathbf{x},\\boldsymbol{\\theta})$, where $\\mathbf{x}$ are species amounts or concentrations, and $\\boldsymbol{\\theta}$ are parameters, with model elements such as species, reactions, parameters, compartments, and a general-purpose metadata attachment mechanism. SBOL includes features such as assembly scars, restriction sites, primer binding sites, combinatorial design spaces, sequence order constraints, and provenance trails; SBML does not natively model sequence coordinates or design spaces, but can carry arbitrary metadata in annotations and supports optional packages for composition. The team must ensure that any mapping does not invent dynamics that alter $\\frac{d \\mathbf{x}}{dt}$ and remains standards-compliant.\n\nWhich of the following proposals correctly identify SBOL edge cases that lack a direct SBML counterpart and propose preservation strategies that do not misrepresent system dynamics and use SBML’s extensibility appropriately? Select all that apply.\n\nA. Represent SBOL assembly scar sequences as SBML species in a dedicated “DNA” compartment, set degradation rate $k_{\\text{deg}}=0$ to avoid consumption, and mark them as boundary to keep $\\frac{d \\mathbf{x}}{dt}=\\mathbf{0}$ for these species; this preserves the scar in the SBML state vector without affecting other model entities.\n\nB. For SBOL restriction enzyme cut sites and assembly scars embedded in a plasmid, attach Resource Description Framework (RDF) annotations to the SBML species that represents the plasmid, including Sequence Ontology (SO) terms and absolute start/end offsets on the underlying deoxyribonucleic acid (DNA) sequence. Use Minimal Information Required In the Annotation of Models (MIRIAM) compliant identifiers and do not introduce any reactions or parameters associated with these features.\n\nC. For SBOL combinatorial design spaces (for example, a CombinatorialDerivation over promoter variants), use SBML Level $3$ Hierarchical Model Composition (comp) to define a template submodel with a promoter “port” and enumerate variant SBML models via replaced elements. Preserve back-references to the SBOL variants via Uniform Resource Identifier (URI) annotations; do not encode the combinatorial choices as reactions or species.\n\nD. Map SBOL SequenceConstraint relationships (for example, “precedes”) to SBML by ordering reactions so that reaction $r_1$ precedes reaction $r_2$ in the document and add a zero-flux constraint to enforce precedence during simulation, ensuring that $\\frac{d \\mathbf{x}}{dt}$ reflects the intended order.\n\nE. Serialize SBOL provenance information (for example, W3C Provenance Ontology, PROV-O, statements such as prov:wasDerivedFrom and prov:wasAttributedTo) into the SBML model’s annotation element as RDF, including timestamps and agent URIs, without introducing new species, reactions, or parameters.\n\nAnswer choices:\n- A\n- B\n- C\n- D\n- E", "solution": "The problem statement will first be subjected to rigorous validation.\n\n### Step 1: Extract Givens\n\nThe provided information is as follows:\n- **Goal:** Build an automated exporter from Synthetic Biology Open Language (SBOL) to Systems Biology Markup Language (SBML).\n- **Core SBOL Features:** Captures sequence-level structure, modular hierarchy, design intent, constraints, provenance, links to ontologies, assembly scars, restriction sites, primer binding sites, combinatorial design spaces, sequence order constraints, and provenance trails.\n- **Core SBML Features:** Encodes quantitative models of biochemical networks with semantics given by ordinary differential equations (ODEs), $\\frac{d \\mathbf{x}}{dt}=\\mathbf{f}(\\mathbf{x},\\boldsymbol{\\theta})$, where $\\mathbf{x}$ are species amounts/concentrations and $\\boldsymbol{\\theta}$ are parameters. Model elements include species, reactions, parameters, compartments, and a general-purpose metadata annotation mechanism. SBML does not natively model sequence coordinates or design spaces but supports optional packages (e.g., for composition) and can carry arbitrary metadata.\n- **Primary Constraints on Mapping:**\n    1. Must not invent dynamics that alter $\\frac{d \\mathbf{x}}{dt}$.\n    2. Must remain standards-compliant.\n    3. Should preserve as much design intent as possible.\n    4. Should use SBML's extensibility (annotations, packages) appropriately.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is evaluated against the validation criteria:\n\n- **Scientifically Grounded:** The problem is firmly located within the domain of computational systems biology and synthetic biology. SBOL and SBML are well-established, community-driven data standards. The concepts mentioned—ODEs, RDF, PROV-O, Sequence Ontology (SO), MIRIAM identifiers—are all standard and widely used in the field. The problem statement is factually correct in its description of these standards.\n- **Well-Posed:** The problem is well-posed. It asks for an evaluation of specific proposed mapping strategies against a clear and consistent set of constraints. A unique set of correct and incorrect options can be determined through logical deduction based on the provided descriptions of the standards.\n- **Objective:** The problem is stated in precise, objective language. It describes the capabilities and limitations of SBOL and SBML factually, without subjective or biased terminology.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is scientifically sound, well-posed, and objective, concerning a real-world challenge in bioinformatics. I will now proceed with the solution by analyzing each proposal.\n\nThe task is to evaluate proposals for mapping SBOL constructs, which lack direct SBML counterparts, into SBML while adhering to the specified constraints. The fundamental principle is that SBML's core purpose is to model dynamics, $\\frac{d \\mathbf{x}}{dt}=\\mathbf{f}(\\mathbf{x},\\boldsymbol{\\theta})$, while SBOL's purpose is to model the structure and intent of a biological design. Any mapping must respect this division of concerns. Information from SBOL that is not dynamic in nature must not be forced into the dynamic components of an SBML model.\n\n### Option-by-Option Analysis\n\n**A. Represent SBOL assembly scar sequences as SBML species...**\nThis proposal suggests creating an SBML `Species` to represent a static DNA sequence feature (an assembly scar). To prevent this species from participating in dynamics, its degradation rate $k_{\\text{deg}}$ is set to $0$ and it is marked as a boundary species, which ensures its concentration is constant, thus its entry in the state vector derivative is $\\frac{dx_{scar}}{dt} = 0$.\n\n- **Critique:** While this technically adheres to the constraint of not altering the dynamics of *other* species, it is a gross semantic misrepresentation. A `Species` in SBML represents a pool of chemical entities whose amount or concentration is a state variable of the system. An assembly scar is not a chemical species; it is a static, structural feature *of another molecule* (e.g., a plasmid). Representing it as a separate `Species` element is conceptually incorrect and poor modeling practice. It clutters the state vector $\\mathbf{x}$ with non-physical entities and misleads anyone interpreting the model. The correct approach is to describe the scar as an attribute of the species it belongs to, not as a species itself. This proposal fails to \"use SBML’s extensibility appropriately.\"\n- **Verdict:** **Incorrect**.\n\n**B. For SBOL restriction enzyme cut sites and assembly scars... attach Resource Description Framework (RDF) annotations...**\nThis proposal suggests using the `annotation` element of the SBML `Species` that represents the plasmid. The annotation would contain structured RDF data describing the sequence features, using standard ontologies like Sequence Ontology (SO) and providing precise sequence coordinates. The proposal explicitly states not to introduce new reactions or parameters.\n\n- **Critique:** This is a correct and standard-compliant approach. The `annotation` element in SBML is specifically designed for this purpose: to store arbitrary, machine-readable metadata that enriches the model without affecting its mathematical semantics. Using RDF, community-standard ontologies (SO), and MIRIAM-compliant identifiers is considered best practice for creating interoperable and richly described models. This method correctly treats the scar/site as a feature of the plasmid, preserves the design information precisely, and, by design, does not alter the system dynamics $\\frac{d \\mathbf{x}}{dt}$.\n- **Verdict:** **Correct**.\n\n**C. For SBOL combinatorial design spaces... use SBML Level $3$ Hierarchical Model Composition (comp)...**\nThis proposal addresses the mapping of SBOL `CombinatorialDerivation`, which defines a space of related designs (e.g., a library of plasmids with different promoters). The strategy is to use the SBML Level $3$ 'comp' package to define a template model with a replaceable \"port\" for the variant component. The design space is then represented by enumerating the concrete SBML models that result from filling the port with each variant.\n\n- **Critique:** This is a sophisticated and correct application of SBML's extension mechanism. An SBOL combinatorial design space is not a single dynamic system but a collection of distinct potential systems. It is a structural concept. Attempting to model the \"choice\" between promoters as a dynamic process within a single SBML model would be inventing dynamics. This proposal correctly avoids that trap. It uses the 'comp' package for its intended purpose: to manage and compose models hierarchically. This preserves the design intent of the combinatorial library by structuring the output as a set of related, simulatable models, which is a faithful representation. Back-references via URIs ensure traceability.\n- **Verdict:** **Correct**.\n\n**D. Map SBOL SequenceConstraint relationships... to SBML by ordering reactions... and add a zero-flux constraint...**\nThis proposal attempts to map an SBOL `SequenceConstraint` (e.g., feature A `precedes` feature B on the DNA) to a temporal ordering of SBML `Reaction` elements.\n\n- **Critique:** This proposal is based on a fundamental misunderstanding. First, an SBOL `SequenceConstraint` describes the **spatial arrangement** of components on a nucleic acid sequence. It has no intrinsic relation to the **temporal dynamics** of biochemical reactions. The verb \"precedes\" in this context means \"is upstream of\". Second, the order of `reaction` elements in an SBML XML document has **no semantic meaning** for the system of ODEs; all reaction rate equations contribute simultaneously to the derivatives of the species. Third, the term \"zero-flux constraint\" is typically associated with steady-state modeling approaches like Flux Balance Analysis (FBA), which is not the general ODE context $\\frac{d \\mathbf{x}}{dt}=\\mathbf{f}(\\mathbf{x},\\boldsymbol{\\theta})$ specified in the problem. Enforcing a temporal sequence of reactions in an ODE model would require complex `Event` structures that would radically alter the system dynamics, thus violating the primary constraint. This mapping is conceptually flawed and technically infeasible as described.\n- **Verdict:** **Incorrect**.\n\n**E. Serialize SBOL provenance information... into the SBML model’s annotation element as RDF...**\nThis proposal suggests taking SBOL's provenance data, typically encoded using the W3C PROV-O ontology, and embedding it as RDF within the top-level `model` annotation in SBML.\n\n- **Critique:** This is analogous to proposal B, but for model-level metadata instead of feature-level metadata. Provenance (e.g., who created the design, what it was derived from) is critical design information but is entirely non-dynamic. The SBML `annotation` element is the correct and standard-compliant location for such information. Serializing it as RDF using a standard vocabulary like PROV-O ensures the information is machine-readable and interoperable. This method perfectly adheres to the constraints: it preserves crucial design intent without introducing any species, reactions, or parameters, thus leaving $\\frac{d \\mathbf{x}}{dt}$ completely unaffected.\n- **Verdict:** **Correct**.", "answer": "$$\\boxed{BCE}$$", "id": "2776305"}, {"introduction": "The ultimate goal of using standards is to enable automated and reproducible scientific discovery. This capstone exercise [@problem_id:2776369] integrates the full stack of standards—SBOL for design, SBML for modeling, and SED-ML for simulation—to execute a complete computational experiment. You will implement a parameter sweep for a genetic oscillator, connecting abstract design parameters to concrete simulation results, thereby demonstrating a powerful, automated design-build-test-learn cycle.", "problem": "You are given a modeling and exchange task that integrates Systems Biology Markup Language (SBML), Synthetic Biology Open Language (SBOL), and Simulation Experiment Description Markup Language (SED-ML) concepts into a single computational experiment. The goal is to design a parameter sweep that systematically explores oscillatory regimes in a repressing ring oscillator model and to report the results back in terms of SBOL variable features that encode promoter strengths.\n\nYou will emulate a Systems Biology Markup Language (SBML) ordinary differential equation model of a three-gene repressing ring oscillator. Denote the concentrations of the gene products by $x(t)$, $y(t)$, and $z(t)$. Assume Hill-type transcriptional repression with Hill coefficient $n$, maximal synthesis rates (promoter strengths) $\\alpha_X$, $\\alpha_Y$, and $\\alpha_Z$, and first-order degradation with rates $\\delta_X$, $\\delta_Y$, and $\\delta_Z$. The model is:\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha_X}{1 + z^n} \\;-\\; \\delta_X x,\\quad\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha_Y}{1 + x^n} \\;-\\; \\delta_Y y,\\quad\n\\frac{dz}{dt} \\;=\\; \\frac{\\alpha_Z}{1 + y^n} \\;-\\; \\delta_Z z.\n$$\nAssume nondimensionalized variables and parameters so that the units are dimensionless; in particular, let $\\delta_X = \\delta_Y = \\delta_Z = 1$ and use a fixed Hill coefficient $n$ common to all three repressors. This is a plausible abstraction derived from mass-action kinetics and the Central Dogma of Molecular Biology, under quasi-steady-state assumptions for transcriptional regulation represented by Hill functions.\n\nA Synthetic Biology Open Language (SBOL) design provides variable features for three promoters, denoted $\\mathrm{P\\_X}$, $\\mathrm{P\\_Y}$, and $\\mathrm{P\\_Z}$, each with a candidate set of promoter strengths. A Simulation Experiment Description Markup Language (SED-ML) parameter sweep defines a Cartesian product over these candidate sets. For each combination $(\\alpha_X,\\alpha_Y,\\alpha_Z)$ from the sweep, you must simulate the SBML-style model over a fixed time horizon and determine whether the time course exhibits sustained oscillations.\n\nDefine “sustained oscillation” operationally as follows. For a given simulation time series for $y(t)$, discard an initial transient portion corresponding to the first half of the simulation time interval, then:\n- Count peaks as the number of indices $i$ in the sampled discrete signal such that $y_i > y_{i-1}$ and $y_i > y_{i+1}$.\n- Compute the post-transient amplitude $\\Delta y$ as $\\max(y) - \\min(y)$ on the post-transient portion.\n- Classify the trajectory as oscillatory if and only if the number of peaks is at least $5$ and the amplitude satisfies $\\Delta y \\ge 0.5$.\n\nAssume all simulations use the same initial condition $x(0) = y(0) = z(0) = 0.1$, the same total time horizon $T = 200$, and uniform sampling at $N = 5000$ points over $[0,T]$. Use a Hill coefficient of $n = 12$ and $\\delta_X = \\delta_Y = \\delta_Z = 1$. All quantities are dimensionless.\n\nImplement a program that adheres to the following constraints and requirements:\n- Emulate the SED-ML parameter sweep by iterating over the Cartesian product of SBOL variable feature candidate lists for promoter strengths. Each candidate list is associated with a promoter via its SBOL variable feature identifier, which in this problem is implicit by order: index $0$ corresponds to $\\mathrm{P\\_X}$, index $1$ to $\\mathrm{P\\_Y}$, and index $2$ to $\\mathrm{P\\_Z}$.\n- For each combination in the sweep, numerically integrate the model, apply the oscillation classifier defined above, and, if oscillatory, record the zero-based index triple $[i,j,k]$, where $i$ is the index into the candidate list for $\\mathrm{P\\_X}$, $j$ for $\\mathrm{P\\_Y}$, and $k$ for $\\mathrm{P\\_Z}$.\n- For each test case defined below, output the sorted list (lexicographic order on $[i,j,k]$) of all index triples classified as oscillatory.\n\nTest suite:\n- Case $1$ (non-oscillatory baseline, low promoter strengths):\n  - $\\mathrm{P\\_X}$ candidates: $[0.5, 1.0]$\n  - $\\mathrm{P\\_Y}$ candidates: $[0.5, 1.0]$\n  - $\\mathrm{P\\_Z}$ candidates: $[0.5, 1.0]$\n- Case $2$ (oscillation-prone, high promoter strengths):\n  - $\\mathrm{P\\_X}$ candidates: $[10.0, 20.0]$\n  - $\\mathrm{P\\_Y}$ candidates: $[10.0, 20.0]$\n  - $\\mathrm{P\\_Z}$ candidates: $[10.0, 20.0]$\n- Case $3$ (asymmetric mixed promoter strengths):\n  - $\\mathrm{P\\_X}$ candidates: $[8.0, 16.0]$\n  - $\\mathrm{P\\_Y}$ candidates: $[2.0, 6.0]$\n  - $\\mathrm{P\\_Z}$ candidates: $[8.0, 16.0]$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the order above and is itself a list of index triples. There must be no whitespace anywhere in the line. For example, a valid output with hypothetical content is\n- `[[[0,1,1],[1,1,1]],[[0,0,1]],[]]`\nbut without any spaces, i.e., `[[[0,1,1],[1,1,1]],[[0,0,1]],[]]`.\n\nYour program must be completely self-contained and require no input. All computations and outputs are in dimensionless units. The final output must be a single line printed exactly in the format described above.", "solution": "The problem statement has been evaluated and is deemed valid. It is scientifically grounded, well-posed, objective, and provides a complete and consistent set of specifications for a computational task in systems biology. The problem requires the emulation of a parameter sweep experiment, as one might define using SED-ML, over a genetic circuit design space represented conceptually by SBOL, with the circuit's dynamics described by an SBML-style ODE model.\n\nThe core of the problem is the analysis of a three-gene transcriptional repressor ring network, commonly known as a repressilator. The dynamics are described by a system of three coupled ordinary differential equations (ODEs):\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha_X}{1 + z^n} \\;-\\; \\delta_X x \\\\\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha_Y}{1 + x^n} \\;-\\; \\delta_Y y \\\\\n\\frac{dz}{dt} \\;=\\; \\frac{\\alpha_Z}{1 + y^n} \\;-\\; \\delta_Z z\n$$\nHere, $x(t)$, $y(t)$, and $z(t)$ represent the concentrations of the three gene products. Repression of each gene by the product of another is modeled using a Hill function, where the term $1/(1 + P^n)$ describes the repressive effect of a protein $P$. The parameter $n$ is the Hill coefficient, which determines the steepness of the repressive response. The parameters $\\alpha_X$, $\\alpha_Y$, and $\\alpha_Z$ represent the maximal synthesis rates, conceptually equivalent to promoter strengths. The parameters $\\delta_X$, $\\delta_Y$, and $\\delta_Z$ represent first-order degradation rates.\n\nThe problem specifies dimensionless parameters: a common degradation rate $\\delta_X = \\delta_Y = \\delta_Z = 1$ and a Hill coefficient $n = 12$. The parameter sweep involves systematically varying the promoter strengths $(\\alpha_X, \\alpha_Y, \\alpha_Z)$ through a Cartesian product of candidate sets provided for three test cases.\n\nFor each specific combination of $(\\alpha_X, \\alpha_Y, \\alpha_Z)$, the system of ODEs constitutes an initial value problem (IVP) with the specified initial condition $x(0) = y(0) = z(0) = 0.1$. This IVP is solved numerically over a time interval of $t \\in [0, T]$, where $T=200$. The solution is sampled at $N=5000$ uniformly spaced time points. The numerical integration will be performed using a robust adaptive solver, specifically the `solve_ivp` function from the `scipy.integrate` library, which is well-suited for such systems, including potentially stiff ones that can arise from high Hill coefficients.\n\nFollowing the numerical simulation, each resulting trajectory is classified as either oscillatory or non-oscillatory based on a precise, operational definition applied to the time series of the $y(t)$ component. The analysis is restricted to the post-transient phase, defined as the second half of the simulation time interval, from $t=100$ to $t=200$. The corresponding samples of the discrete time series, from index $N/2$ to $N-1$, are used.\n\nThe classification is based on two criteria which must both be met:\n1.  **Amplitude Threshold**: The post-transient amplitude, calculated as $\\Delta y = \\max(y_{\\text{post-transient}}) - \\min(y_{\\text{post-transient}})$, must be greater than or equal to a threshold of $0.5$.\n2.  **Peak Count**: The number of local maxima in the post-transient $y(t)$ signal must be at least $5$. A peak is strictly defined as a point $y_i$ that is greater than its immediate neighbors, i.e., $y_i > y_{i-1}$ and $y_i > y_{i+1}$.\n\nThe overall procedure is as follows:\nFirst, we structure the program to handle the three distinct test cases. For each case, we iterate through all combinations of promoter strengths defined by the candidate lists. This is achieved by taking the Cartesian product of the index ranges of the candidate lists. For each resulting index triple $[i,j,k]$, the corresponding promoter strengths $(\\alpha_X, \\alpha_Y, \\alpha_Z)$ are used to configure the ODE model. The model is then simulated. The resulting time series for $y(t)$ is analyzed according to the specified classification rules. If the trajectory is classified as oscillatory, the index triple $[i,j,k]$ is stored. After all combinations for a test case are evaluated, the collected list of oscillatory index triples is sorted lexicographically and added to a master list of results.\n\nFinally, the master list, containing the results for all three test cases, is formatted into a single-line string with no whitespace, as per the output specification. This entire process is encapsulated within a self-contained Python script.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run the parameter sweep for the three test cases,\n    classify trajectories, and print results in the specified format.\n    \"\"\"\n    # Global parameters for the simulation\n    n = 12.0\n    # Degradation rates are fixed to 1 and are incorporated in the ODE directly.\n    \n    # Simulation settings\n    t_span = [0.0, 200.0]\n    t_points = 5000\n    t_eval = np.linspace(t_span[0], t_span[1], t_points)\n    v0 = [0.1, 0.1, 0.1]\n    \n    # Oscillation classifier parameters\n    transient_split_index = t_points // 2\n    min_peaks = 5\n    min_amplitude = 0.5\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1 (non-oscillatory baseline, low promoter strengths)\n        {\n            \"alpha_x_cands\": [0.5, 1.0],\n            \"alpha_y_cands\": [0.5, 1.0],\n            \"alpha_z_cands\": [0.5, 1.0],\n        },\n        # Case 2 (oscillation-prone, high promoter strengths)\n        {\n            \"alpha_x_cands\": [10.0, 20.0],\n            \"alpha_y_cands\": [10.0, 20.0],\n            \"alpha_z_cands\": [10.0, 20.0],\n        },\n        # Case 3 (asymmetric mixed promoter strengths)\n        {\n            \"alpha_x_cands\": [8.0, 16.0],\n            \"alpha_y_cands\": [2.0, 6.0],\n            \"alpha_z_cands\": [8.0, 16.0],\n        }\n    ]\n\n    # Model definition\n    def repressilator_ode(t, v, alpha_x, alpha_y, alpha_z):\n        x, y, z = v\n        dxdt = alpha_x / (1.0 + z**n) - x\n        dydt = alpha_y / (1.0 + x**n) - y\n        dzdt = alpha_z / (1.0 + y**n) - z\n        return [dxdt, dydt, dzdt]\n\n    all_results = []\n    \n    for case in test_cases:\n        alpha_x_cands = case[\"alpha_x_cands\"]\n        alpha_y_cands = case[\"alpha_y_cands\"]\n        alpha_z_cands = case[\"alpha_z_cands\"]\n        \n        case_oscillatory_indices = []\n        \n        # Create Cartesian product of indices for the parameter sweep\n        indices_product = itertools.product(\n            range(len(alpha_x_cands)),\n            range(len(alpha_y_cands)),\n            range(len(alpha_z_cands))\n        )\n\n        for i, j, k in indices_product:\n            alpha_x = alpha_x_cands[i]\n            alpha_y = alpha_y_cands[j]\n            alpha_z = alpha_z_cands[k]\n            \n            # Numerically integrate the ODE system\n            sol = solve_ivp(\n                fun=repressilator_ode,\n                t_span=t_span,\n                y0=v0,\n                method='LSODA',  # Robust for potentially stiff systems\n                t_eval=t_eval,\n                args=(alpha_x, alpha_y, alpha_z)\n            )\n            \n            # Check if integration was successful\n            if not sol.success:\n                continue\n\n            # Extract y(t) time series\n            y_signal = sol.y[1, :]\n            \n            # Analyze post-transient part\n            y_post_transient = y_signal[transient_split_index:]\n\n            # 1. Check amplitude\n            amplitude = np.max(y_post_transient) - np.min(y_post_transient)\n            \n            if amplitude < min_amplitude:\n                continue\n                \n            # 2. Count peaks\n            peak_count = 0\n            # Iterate from the second to the second-to-last point to check neighbors\n            for p_idx in range(1, len(y_post_transient) - 1):\n                if y_post_transient[p_idx] > y_post_transient[p_idx-1] and \\\n                   y_post_transient[p_idx] > y_post_transient[p_idx+1]:\n                    peak_count += 1\n            \n            # Classify as oscillatory if both conditions are met\n            if peak_count >= min_peaks:\n                case_oscillatory_indices.append([i, j, k])\n\n        # Sort the results for the current case lexicographically\n        case_oscillatory_indices.sort()\n        all_results.append(case_oscillatory_indices)\n\n    # Format the final output string to have no whitespace\n    final_output_str = str(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```", "id": "2776369"}]}