{"hands_on_practices": [{"introduction": "A common task in synthetic biology is expressing a gene from one organism, such as an AT-rich parasite, in a well-characterized host like a GC-rich bacterium. This practice provides a tangible understanding of the direct consequences of codon optimization, a standard technique to solve expression challenges. By re-encoding a gene using host-preferred codons, you will quantify the resulting shifts in both nucleotide composition, measured by the GC3 fraction, and a proxy for mRNA stability based on a nearest-neighbor energy model [@problem_id:2721544].", "problem": "You are tasked with formalizing, implementing, and computing a simple compositional model that quantifies how codon optimization of Adenine-Thymine (AT)-rich parasite genes for expression in Guanine-Cytosine (GC)-rich bacterial hosts alters both the fraction of Guanine-Cytosine at third codon positions (GC3) and a proxy for messenger Ribonucleic Acid (mRNA) secondary structural stability. The derivation and computation must start from the following foundational bases: the Central Dogma of molecular biology (Deoxyribonucleic Acid (DNA) is transcribed to mRNA, which is translated to protein), the degeneracy of the genetic code (synonymous codons encode the same amino acid), the wobble position concept (the third position of many codons is often degenerate), and the well-tested empirical observation that higher GC content tends to increase RNA duplex stability via stronger base-pairing and stacking interactions. For the structural proxy, use an additive nearest-neighbor stacking model tailored to a perfectly base-paired duplex registry against the reverse complement, which serves here as a composition-sensitive stability index rather than a full secondary structure prediction.\n\nDefine the following quantities and computational rules precisely:\n\n- Let a coding DNA sequence have length $L_{\\mathrm{nt}}$ nucleotides with $L_{\\mathrm{nt}} \\bmod 3 = 0$, and thus $n = L_{\\mathrm{cod}} = L_{\\mathrm{nt}}/3$ codons. The GC3 fraction is defined as\n  $$ \\mathrm{GC3}(\\text{DNA}) = \\frac{1}{n} \\sum_{i=1}^{n} \\mathbf{1}\\left\\{ b_{3i} \\in \\{\\mathrm{G},\\mathrm{C}\\} \\right\\}, $$\n  where $b_{3i}$ is the nucleotide at the third position of codon $i$, and $\\mathbf{1}\\{\\cdot\\}$ is the indicator function.\n\n- To model mRNA structural stability, first transcribe DNA to RNA by replacing $\\mathrm{T} \\rightarrow \\mathrm{U}$. For an RNA sequence of length $L$, define the Expected Duplex Stacking Energy (EDSE) proxy as the average of dinucleotide stacking contributions under perfect Watson–Crick registry with the reverse complement:\n  $$ \\mathrm{EDSE}(\\text{RNA}) = \\frac{1}{L-1} \\sum_{i=1}^{L-1} e\\left( s_i s_{i+1} \\right), $$\n  where $s_i \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ and $e(\\cdot)$ is a simplified Turner-like nearest-neighbor energy (in $\\mathrm{kcal/mol}$) for the dinucleotide step indicated by the top-strand adjacent bases $s_i s_{i+1}$, assuming perfect Watson–Crick pairing against its reverse complement. Use the following fixed energy table for $e(\\cdot)$ at $37\\,^{\\circ}\\mathrm{C}$ (units: $\\mathrm{kcal/mol}$), defined for all $16$ dinucleotides:\n\n  - $e(\\mathrm{AA}) = -0.93$, $e(\\mathrm{AC}) = -1.10$, $e(\\mathrm{AG}) = -1.30$, $e(\\mathrm{AU}) = -1.10$.\n  - $e(\\mathrm{CA}) = -1.10$, $e(\\mathrm{CC}) = -2.08$, $e(\\mathrm{CG}) = -2.17$, $e(\\mathrm{CU}) = -1.30$.\n  - $e(\\mathrm{GA}) = -1.30$, $e(\\mathrm{GC}) = -2.24$, $e(\\mathrm{GG}) = -2.08$, $e(\\mathrm{GU}) = -1.10$.\n  - $e(\\mathrm{UA}) = -0.90$, $e(\\mathrm{UC}) = -1.30$, $e(\\mathrm{UG}) = -1.10$, $e(\\mathrm{UU}) = -0.93$.\n\n- Codon optimization rule: given an amino acid sequence translated from the input coding DNA under the Standard Genetic Code, re-encode the protein by choosing, for each amino acid independently, the host’s most frequent synonymous codon (as provided below). For amino acids with only one codon, retain that codon. This results in a host-optimized DNA sequence with the same amino acid sequence but potentially different GC3 and EDSE.\n\n- For each test case, compute the changes:\n  $$ \\Delta \\mathrm{GC3} = \\mathrm{GC3}(\\text{optimized DNA}) - \\mathrm{GC3}(\\text{original DNA}), $$\n  $$ \\Delta \\mathrm{EDSE} = \\mathrm{EDSE}(\\text{optimized RNA}) - \\mathrm{EDSE}(\\text{original RNA}). $$\n  Report $\\Delta\\mathrm{EDSE}$ in $\\mathrm{kcal/mol}$ per step. Note that more negative $\\Delta\\mathrm{EDSE}$ indicates a predicted increase in average stacking-based stability.\n\nHost specification for a GC-rich bacterial codon preference model, given as the host’s most frequent codon for each amino acid under the Standard Genetic Code:\n\n- Alanine $\\mathrm{A}$: $\\mathrm{GCC}$\n- Arginine $\\mathrm{R}$: $\\mathrm{CGC}$\n- Asparagine $\\mathrm{N}$: $\\mathrm{AAC}$\n- Aspartate $\\mathrm{D}$: $\\mathrm{GAC}$\n- Cysteine $\\mathrm{C}$: $\\mathrm{TGC}$\n- Glutamine $\\mathrm{Q}$: $\\mathrm{CAG}$\n- Glutamate $\\mathrm{E}$: $\\mathrm{GAG}$\n- Glycine $\\mathrm{G}$: $\\mathrm{GGC}$\n- Histidine $\\mathrm{H}$: $\\mathrm{CAC}$\n- Isoleucine $\\mathrm{I}$: $\\mathrm{ATC}$\n- Leucine $\\mathrm{L}$: $\\mathrm{CTG}$\n- Lysine $\\mathrm{K}$: $\\mathrm{AAG}$\n- Methionine $\\mathrm{M}$: $\\mathrm{ATG}$ (single codon)\n- Phenylalanine $\\mathrm{F}$: $\\mathrm{TTC}$\n- Proline $\\mathrm{P}$: $\\mathrm{CCG}$\n- Serine $\\mathrm{S}$: $\\mathrm{TCG}$\n- Threonine $\\mathrm{T}$: $\\mathrm{ACC}$\n- Tryptophan $\\mathrm{W}$: $\\mathrm{TGG}$ (single codon)\n- Tyrosine $\\mathrm{Y}$: $\\mathrm{TAC}$\n- Valine $\\mathrm{V}$: $\\mathrm{GTC}$\n\nTest suite. Use the following three coding DNA sequences, each uppercase, length a multiple of $3$, with no internal stop codons:\n\n- Case A (AT-rich parasite-like, includes one tryptophan): \n  $$ \\text{ATGAAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT TGG} $$\n  Concatenate without spaces to obtain the sequence.\n\n- Case B (short, includes Proline and Glycine to test GC-driven codons): \n  $$ \\text{ATG CCT GGT TTT AAT ATT AAA TAT TGG} $$\n\n- Case C (bias toward six-fold degenerate amino acids using AT-rich source codons): \n  $$ \\text{ATG TTA TCT AGA TTA TCT AGA TTA TCT AGA GAA GAT CAA AAA AAT TTT ATT TAT CAT TGT} $$\n\nYour program must:\n\n- Implement the Standard Genetic Code to translate codons to amino acids and re-encode with the host’s preferred codons.\n- Compute $GC3$ fractions for original and optimized DNA, and their difference $\\Delta\\mathrm{GC3}$ as a unitless decimal fraction.\n- Compute $\\mathrm{EDSE}$ for original and optimized RNA via the dinucleotide average specified above, and their difference $\\Delta\\mathrm{EDSE}$ in $\\mathrm{kcal/mol}$ per step.\n- Round both $\\Delta\\mathrm{GC3}$ and $\\Delta\\mathrm{EDSE}$ to $6$ decimal places.\n\nFinal output format requirement:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the order A, B, C, and is itself a two-element list in the form $[\\Delta GC3, \\Delta \\mathrm{EDSE}]$. For example: $[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$.", "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a clearly defined computational task based on fundamental principles of molecular and synthetic biology, providing all necessary data and rules for a unique and verifiable solution. The problem is a standard exercise in bioinformatics and requires no speculative assumptions. We may therefore proceed with the formal derivation and implementation of the solution.\n\nThe objective is to quantify the effects of codon optimization on two key molecular properties: the Guanine-Cytosine content at the third codon position (GC3) and a proxy for messenger RNA (mRNA) structural stability, the Expected Duplex Stacking Energy (EDSE). This is performed for an AT-rich gene sequence optimized for expression in a GC-rich host. We will compute the change in these two metrics, $\\Delta\\mathrm{GC3}$ and $\\Delta\\mathrm{EDSE}$.\n\nThe overall computational procedure is as follows:\n$1$. For a given original DNA sequence, calculate its initial GC3 value, denoted $\\mathrm{GC3}(\\text{original DNA})$, and initial stability proxy, $\\mathrm{EDSE}(\\text{original RNA})$.\n$2$. Translate the original DNA sequence into its corresponding amino acid sequence using the Standard Genetic Code.\n$3$. Re-encode this amino acid sequence into a new, optimized DNA sequence by selecting the host's preferred codon for each amino acid, as specified in the provided codon usage table.\n$4$. For this new optimized DNA sequence, calculate its final GC3 value, $\\mathrm{GC3}(\\text{optimized DNA})$, and final stability proxy, $\\mathrm{EDSE}(\\text{optimized RNA})$.\n$5$. Compute the differences: $\\Delta\\mathrm{GC3} = \\mathrm{GC3}(\\text{optimized DNA}) - \\mathrm{GC3}(\\text{original DNA})$ and $\\Delta\\mathrm{EDSE} = \\mathrm{EDSE}(\\text{optimized RNA}) - \\mathrm{EDSE}(\\text{original RNA})$.\n\nTo implement this procedure, we will first establish the necessary data structures.\n\nThe Standard Genetic Code maps DNA codons to amino acids. A mapping from the $64$ possible codons to the $20$ standard amino acids and stop signals is required. For this problem, we only need the forward translation.\nExample mappings include: `TTT` $\\rightarrow$ Phenylalanine (F), `ATG` $\\rightarrow$ Methionine (M), `GGC` $\\rightarrow$ Glycine (G).\n\nThe host's preferred codon table provides a deterministic rule for re-encoding. It maps each amino acid to a single, specific DNA codon. For example:\n- Alanine (A): $\\mathrm{GCC}$\n- Arginine (R): $\\mathrm{CGC}$\n- ...and so on, for all $20$ amino acids.\n\nThe nearest-neighbor energy table gives the stacking energy contribution $e(s_i s_{i+1})$ for each of the $16$ possible RNA dinucleotides. For example:\n- $e(\\mathrm{GC}) = -2.24 \\, \\mathrm{kcal/mol}$\n- $e(\\mathrm{AU}) = -1.10 \\, \\mathrm{kcal/mol}$\n- $e(\\mathrm{AA}) = -0.93 \\, \\mathrm{kcal/mol}$\n\nWith these data structures, we define the computational functions.\n\nFirst, the GC3 fraction is calculated. For a DNA sequence of length $L_{\\mathrm{nt}}$ containing $n = L_{\\mathrm{nt}}/3$ codons, the function iterates through the sequence, examining the nucleotide at each third codon position (i.e., positions $3, 6, 9, \\ldots, L_{\\mathrm{nt}}$ with $1$-based indexing). The count of Guanine ('G') or Cytosine ('C') at these positions is divided by the total number of codons, $n$.\n$$\n\\mathrm{GC3}(\\text{DNA}) = \\frac{\\text{Count of G or C at third positions}}{\\text{Total number of codons}}\n$$\n\nSecond, the $\\mathrm{EDSE}$ is calculated. A given DNA sequence is first transcribed into its corresponding mRNA sequence by replacing every Thymine ('T') with Uracil ('U'). For the resulting RNA sequence of length $L$, we calculate the sum of nearest-neighbor stacking energies over all $L-1$ adjacent dinucleotide pairs. This sum is then normalized by the number of pairs, $L-1$.\n$$\n\\mathrm{EDSE}(\\text{RNA}) = \\frac{1}{L-1} \\sum_{i=1}^{L-1} e\\left( s_i s_{i+1} \\right)\n$$\nHere, $s_i$ is the base at position $i$ of the RNA sequence, and $e(\\cdot)$ is the energy function defined by the provided table. A more negative $\\mathrm{EDSE}$ value implies greater average stability under the model's assumption of a perfect duplex.\n\nThird, the sequence optimization function performs a two-step process.\nStep $1$, translation: The input DNA sequence is parsed into a list of $3$-base codons. Each codon is translated into an amino acid using the Standard Genetic Code map. The result is a string of amino acids representing the encoded protein.\nStep $2$, re-encoding: This amino acid string is then translated back into a DNA sequence. For each amino acid in the string, the corresponding preferred codon from the host's codon usage table is chosen. These codons are concatenated to form the final, optimized DNA sequence.\n\nFinally, the main algorithm is executed for each test case. The GC3 and $\\mathrm{EDSE}$ values are computed for both the original and optimized sequences. The differences, $\\Delta\\mathrm{GC3}$ and $\\Delta\\mathrm{EDSE}$, are calculated and then rounded to $6$ decimal places as required. The results are aggregated and formatted into the specified output structure. This systematic application of defined rules to the provided data ensures a reproducible and correct solution.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the codon optimization problem by calculating changes in GC3 and EDSE.\n    \"\"\"\n    \n    # --- Data Structures ---\n    \n    # Standard Genetic Code: DNA Codon -> Amino Acid (1-letter code)\n    STANDARD_GENETIC_CODE = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',\n        'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',\n        'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n    }\n    \n    # Host's Preferred Codon Table: Amino Acid -> DNA Codon\n    HOST_CODON_USAGE = {\n        'A': 'GCC', 'R': 'CGC', 'N': 'AAC', 'D': 'GAC', 'C': 'TGC',\n        'Q': 'CAG', 'E': 'GAG', 'G': 'GGC', 'H': 'CAC', 'I': 'ATC',\n        'L': 'CTG', 'K': 'AAG', 'M': 'ATG', 'F': 'TTC', 'P': 'CCG',\n        'S': 'TCG', 'T': 'ACC', 'W': 'TGG', 'Y': 'TAC', 'V': 'GTC',\n    }\n    \n    # Nearest-Neighbor Stacking Energy Table (kcal/mol) for RNA\n    ENERGY_TABLE = {\n        'AA': -0.93, 'AC': -1.10, 'AG': -1.30, 'AU': -1.10,\n        'CA': -1.10, 'CC': -2.08, 'CG': -2.17, 'CU': -1.30,\n        'GA': -1.30, 'GC': -2.24, 'GG': -2.08, 'GU': -1.10,\n        'UA': -0.90, 'UC': -1.30, 'UG': -1.10, 'UU': -0.93,\n    }\n\n    # --- Core Functions ---\n\n    def calculate_gc3(dna_sequence):\n        \"\"\"Calculates the GC3 fraction of a DNA sequence.\"\"\"\n        num_codons = len(dna_sequence) // 3\n        if num_codons == 0:\n            return 0.0\n        \n        gc3_count = 0\n        for i in range(num_codons):\n            third_base = dna_sequence[i * 3 + 2]\n            if third_base in ('G', 'C'):\n                gc3_count += 1\n        return gc3_count / num_codons\n\n    def calculate_edse(dna_sequence):\n        \"\"\"Calculates the Expected Duplex Stacking Energy (EDSE) of an RNA sequence.\"\"\"\n        rna_sequence = dna_sequence.replace('T', 'U')\n        seq_len = len(rna_sequence)\n        if seq_len < 2:\n            return 0.0\n\n        total_energy = 0.0\n        for i in range(seq_len - 1):\n            dinucleotide = rna_sequence[i:i+2]\n            total_energy += ENERGY_TABLE[dinucleotide]\n        \n        return total_energy / (seq_len - 1)\n\n    def optimize_sequence(dna_sequence):\n        \"\"\"Optimizes a DNA sequence based on host codon preference.\"\"\"\n        # 1. Translate original DNA to amino acid sequence\n        num_codons = len(dna_sequence) // 3\n        amino_acid_seq = []\n        for i in range(num_codons):\n            codon = dna_sequence[i * 3 : i * 3 + 3]\n            amino_acid = STANDARD_GENETIC_CODE[codon]\n            amino_acid_seq.append(amino_acid)\n        \n        # 2. Re-encode amino acid sequence using host preferences\n        optimized_codons = []\n        for aa in amino_acid_seq:\n            optimized_codons.append(HOST_CODON_USAGE[aa])\n        \n        return \"\".join(optimized_codons)\n\n    # --- Test Cases ---\n    \n    test_cases_raw = {\n        \"A\": \"ATGAAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT TGG\",\n        \"B\": \"ATG CCT GGT TTT AAT ATT AAA TAT TGG\",\n        \"C\": \"ATG TTA TCT AGA TTA TCT AGA TTA TCT AGA GAA GAT CAA AAA AAT TTT ATT TAT CAT TGT\"\n    }\n\n    # Concatenate sequences by removing spaces\n    test_cases = [seq.replace(\" \", \"\") for seq in test_cases_raw.values()]\n\n    # --- Main Logic ---\n\n    results = []\n    for original_dna in test_cases:\n        # Calculate metrics for original sequence\n        gc3_orig = calculate_gc3(original_dna)\n        edse_orig = calculate_edse(original_dna)\n        \n        # Generate optimized sequence\n        optimized_dna = optimize_sequence(original_dna)\n        \n        # Calculate metrics for optimized sequence\n        gc3_opt = calculate_gc3(optimized_dna)\n        edse_opt = calculate_edse(optimized_dna)\n        \n        # Compute differences and round\n        delta_gc3 = np.round(gc3_opt - gc3_orig, 6)\n        delta_edse = np.round(edse_opt - edse_orig, 6)\n        \n        results.append([delta_gc3, delta_edse])\n\n    # Format and print the final output\n    # Convert floats to strings for custom list representation asked by the problem\n    # e.g., [[x1, y1], [x2, y2]] --> \"[[x1,y1],[x2,y2]]\"\n    result_str = \",\".join([f\"[{d_gc3},{d_edse}]\" for d_gc3, d_edse in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2721544"}, {"introduction": "Effective gene design often requires more than simply maximizing protein output; controlling the dynamics of the translation process itself can be critical for outcomes like proper protein folding. This exercise reframes codon optimization as a sophisticated design challenge: engineering a specific, position-dependent profile of translation elongation rates along a transcript. You will develop a selection algorithm to choose synonymous codons whose individual elongation rates best match a desired target profile, introducing the concept of using codon choice as a tool to engineer dynamic biological processes [@problem_id:2721491].", "problem": "You are given a simplified, self-contained model of translation elongation in heterologous expression that captures how synonymous codon choice modulates position-specific elongation rates. Under this model, each codon has an associated dimensionless relative elongation rate in the interval $[0,1]$, and the desired elongation profile along the coding sequence is provided as a continuous function $k(x)$ defined on the unit interval, which is sampled at evenly spaced, codon-centered positions. Your task is to implement an algorithm that, for each amino acid position $i \\in \\{1,\\dots,N\\}$ of a given polypeptide, selects one synonymous codon so that the realized elongation rate $k_i$ closely approximates the target $k(x_i)$ within a user-specified absolute error tolerance $\\epsilon$.\n\nFoundational assumptions and definitions:\n- Central Dogma of Molecular Biology: DNA is transcribed to RNA and translated to protein. Translation proceeds codon-by-codon, and measurable differences in decoding kinetics across codons lead to codon-specific elongation rates. We model these rates as fixed, codon-dependent constants based on host translational machinery.\n- Let $r(c)$ denote the dimensionless relative elongation rate associated with codon $c$ in the expression host. For an amino acid $a$, let $\\mathcal{S}(a)$ denote the set of synonymous codons that encode $a$ in the standard genetic code.\n- Consider a polypeptide of length $N$ amino acids with sequence $(a_1,a_2,\\dots,a_N)$. Define a continuous target elongation profile $k(x)$ on $x \\in [0,1]$. We discretize it at codon-centered positions $x_i = \\frac{i - 0.5}{N}$ for $i \\in \\{1,\\dots,N\\}$. The target at position $i$ is $\\hat{k}_i = k(x_i)$.\n- A codon assignment $(c_1,c_2,\\dots,c_N)$ induces realized per-position rates $k_i = r(c_i)$ with $c_i \\in \\mathcal{S}(a_i)$. The per-position absolute error is $e_i = |k_i - \\hat{k}_i|$. The design is deemed feasible if $\\max_i e_i \\le \\epsilon$.\n\nRequired algorithmic task:\n- Implement a position-wise selection rule that, for each position $i$, chooses $c_i \\in \\mathcal{S}(a_i)$ minimizing $|r(c_i) - \\hat{k}_i|$. In the event of a tie, break ties by preferring the codon with the larger $r(c)$ value. Report whether the induced sequence achieves $|k_i - \\hat{k}_i| \\le \\epsilon$ at every position.\n\nUnits and angle convention:\n- All elongation rates are dimensionless and normalized to $[0,1]$.\n- For any trigonometric function, evaluate angles in radians.\n\nCodon set and rates:\n- Methionine ($\\mathrm{M}$): $\\{ \\mathrm{AUG} \\}$ with $r(\\mathrm{AUG}) = 0.75$.\n- Tryptophan ($\\mathrm{W}$): $\\{ \\mathrm{UGG} \\}$ with $r(\\mathrm{UGG}) = 0.65$.\n- Alanine ($\\mathrm{A}$): $\\{ \\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG} \\}$ with $r(\\mathrm{GCU}) = 0.65$, $r(\\mathrm{GCC}) = 0.85$, $r(\\mathrm{GCA}) = 0.60$, $r(\\mathrm{GCG}) = 0.40$.\n- Leucine ($\\mathrm{L}$): $\\{ \\mathrm{UUA}, \\mathrm{UUG}, \\mathrm{CUU}, \\mathrm{CUC}, \\mathrm{CUA}, \\mathrm{CUG} \\}$ with $r(\\mathrm{UUA}) = 0.30$, $r(\\mathrm{UUG}) = 0.55$, $r(\\mathrm{CUU}) = 0.50$, $r(\\mathrm{CUC}) = 0.70$, $r(\\mathrm{CUA}) = 0.35$, $r(\\mathrm{CUG}) = 0.95$.\n- Glycine ($\\mathrm{G}$): $\\{ \\mathrm{GGU}, \\mathrm{GGC}, \\mathrm{GGA}, \\mathrm{GGG} \\}$ with $r(\\mathrm{GGU}) = 0.60$, $r(\\mathrm{GGC}) = 0.90$, $r(\\mathrm{GGA}) = 0.50$, $r(\\mathrm{GGG}) = 0.40$.\n- Serine ($\\mathrm{S}$): $\\{ \\mathrm{UCU}, \\mathrm{UCC}, \\mathrm{UCA}, \\mathrm{UCG}, \\mathrm{AGU}, \\mathrm{AGC} \\}$ with $r(\\mathrm{UCU}) = 0.55$, $r(\\mathrm{UCC}) = 0.80$, $r(\\mathrm{UCA}) = 0.50$, $r(\\mathrm{UCG}) = 0.35$, $r(\\mathrm{AGU}) = 0.60$, $r(\\mathrm{AGC}) = 0.85$.\n\nTarget profiles:\n- For a constant target profile, $k(x) = \\alpha$, with $\\alpha \\in [0,1]$.\n- For a linear ramp, $k(x) = k_0 + (k_1 - k_0) x$, with $k_0, k_1 \\in [0,1]$.\n- For a sinusoidal profile, $k(x) = B + A \\sin(2\\pi f x)$, with $A \\ge 0$, $B \\in [0,1]$, $f > 0$, and angles in radians. Ensure $k(x) \\in [0,1]$ for the parameters used in the test suite below.\n\nTest suite:\n- Case $1$ (happy path): Sequence $\\mathrm{MALWGS}$, target $k(x) = 0.8$, tolerance $\\epsilon = 0.25$.\n- Case $2$ (stringent and infeasible due to a single-codon bottleneck): Sequence $\\mathrm{WLLLLL}$, target $k(x) = 0.1 + 0.8 x$, tolerance $\\epsilon = 0.05$.\n- Case $3$ (oscillatory target within feasible range): Sequence $\\mathrm{ASGSA}$, target $k(x) = 0.5 + 0.3 \\sin(2\\pi \\cdot 1 \\cdot x)$, tolerance $\\epsilon = 0.2$.\n- Case $4$ (boundary condition with zero tolerance): Sequence $\\mathrm{MW}$, target $k(x) = 0.65$, tolerance $\\epsilon = 0.0$.\n\nFinal output specification:\n- For each test case, output a boolean indicating whether there exists a synonymous codon assignment that yields $|k_i - \\hat{k}_i| \\le \\epsilon$ at every position under the position-wise optimal selection rule described above.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[ \\mathrm{True}, \\mathrm{False} ]$). The booleans must be unquoted.", "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n- **Model:** A model where each codon $c$ has a dimensionless relative elongation rate $r(c) \\in [0,1]$.\n- **Polypeptide:** Sequence $(a_1, a_2, \\dots, a_N)$ of length $N$.\n- **Target Profile:** A continuous function $k(x)$ on $x \\in [0,1]$.\n- **Discretized Target Rate:** At position $i$, the target is $\\hat{k}_i = k(x_i)$, where $x_i = \\frac{i - 0.5}{N}$ for $i \\in \\{1, \\dots, N\\}$.\n- **Realized Rate:** For a chosen codon $c_i$ for amino acid $a_i$, the realized rate is $k_i = r(c_i)$.\n- **Optimization Goal:** For each position $i$, choose codon $c_i$ from the set of synonymous codons $\\mathcal{S}(a_i)$ to minimize the absolute error $e_i = |r(c_i) - \\hat{k}_i|$.\n- **Tie-Breaking Rule:** In case of a tie in minimum error, the codon with the larger rate $r(c)$ is chosen.\n- **Feasibility Condition:** The design is feasible if the maximum positional error is within a tolerance $\\epsilon$, i.e., $\\max_{i=1..N} (\\min_{c_i \\in \\mathcal{S}(a_i)} |r(c_i) - \\hat{k}_i|) \\le \\epsilon$.\n- **Codon Data:** A specific set of elongation rates $r(c)$ is provided for synonymous codons of amino acids $\\mathrm{M}, \\mathrm{W}, \\mathrm{A}, \\mathrm{L}, \\mathrm{G}, \\mathrm{S}$.\n- **Target Profile Functions:**\n    - Constant: $k(x) = \\alpha$.\n    - Linear: $k(x) = k_0 + (k_1 - k_0) x$.\n    - Sinusoidal: $k(x) = B + A \\sin(2\\pi f x)$.\n- **Test Cases:** Four specific test cases are provided, each with a sequence, a target profile function, and a tolerance $\\epsilon$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded:** The problem uses a simplified but standard model from synthetic biology and computational biology. The concepts of codon usage, synonymous codons, and their effect on translation rates are well-established scientific principles. The problem is a valid abstraction for computational analysis.\n- **Well-Posed:** The problem is unambiguous. The objective—to determine feasibility based on a clearly defined optimization rule and error threshold—is precise. The input data, including amino acid sequences, codon rates, target profiles, and tolerances, are fully specified for each test case. The existence of a solution is guaranteed because the optimization at each step is over a finite set. The tie-breaking rule ensures a unique codon choice, though it does not affect the minimum error value which is the basis for the feasibility check.\n- **Objective:** The language is formal and objective. All parameters and functions are mathematically defined.\n- **Completeness and Consistency:** The problem is self-contained and provides all necessary information. There are no contradictions in the provided data or constraints.\n- **Other Flaws:** The problem is not trivial, unrealistic, or unverifiable. It represents a standard algorithmic task in bioinformatics.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. A reasoned solution and implementation can be provided.\n\n### Principle-Based Design\nThe task is to determine if, for a given polypeptide sequence, it is possible to select a synonymous codon at each position such that the resulting elongation rate profile stays within a specified tolerance $\\epsilon$ of a target profile $k(x)$. The selection at each position must be optimal, meaning it must minimize the local error.\n\nThe algorithmic approach directly implements this specification. The core of the algorithm is a sequential analysis of each amino acid position in the input polypeptide.\n\n1.  **Data Structuring:** The provided codon data, mapping amino acids to their synonymous codons and associated elongation rates $r(c)$, are first organized into a suitable data structure, such as a nested dictionary. This allows for efficient lookup of the set of synonymous codons $\\mathcal{S}(a_i)$ and their rates for any given amino acid $a_i$.\n\n2.  **Iterative Positional Analysis:** The algorithm iterates through each given test case. For each case, defined by an amino acid sequence $(a_1, a_2, \\dots, a_N)$, a target profile $k(x)$, and a tolerance $\\epsilon$, the feasibility is assessed. This is done by iterating through each amino acid position $i$ from $1$ to $N$.\n\n3.  **Target Rate Calculation:** At each position $i$, the corresponding continuous coordinate $x_i = \\frac{i - 0.5}{N}$ is calculated. This coordinate represents the center of the $i$-th codon. Using this $x_i$, the target elongation rate $\\hat{k}_i = k(x_i)$ is evaluated based on the specified profile function for the test case (constant, linear, or sinusoidal).\n\n4.  **Optimal Codon Selection and Error Calculation:** For the amino acid $a_i$ at position $i$, the algorithm retrieves the set of available synonymous codons $\\mathcal{S}(a_i)$ and their respective elongation rates $\\{r(c) | c \\in \\mathcal{S}(a_i)\\}$. According to the problem's requirement, the best choice is the codon that minimizes the absolute error $|r(c) - \\hat{k}_i|$. Therefore, the minimum possible error at this position is found by computing:\n    $$e_{i, \\text{min}} = \\min_{c \\in \\mathcal{S}(a_i)} |r(c) - \\hat{k}_i|$$\n    The specified tie-breaking rule (preferring higher $r(c)$) affects which codon would be selected in a tie but does not alter the value of $e_{i, \\text{min}}$.\n\n5.  **Feasibility Check:** The calculated minimum error for the position, $e_{i, \\text{min}}$, is compared against the global tolerance $\\epsilon$. If $e_{i, \\text{min}} > \\epsilon$, it is impossible to satisfy the error constraint at position $i$. This single failure is sufficient to render the entire design infeasible for the given test case. In this event, the analysis for the current sequence is terminated, and the result is recorded as `False`.\n\n6.  **Final Verdict:** If the loop completes for all positions $i=1, \\dots, N$ without any position violating the condition $e_{i, \\text{min}} \\le \\epsilon$, the design is deemed feasible for the test case, and the result is recorded as `True`.\n\nThis procedure is applied to all test cases, and the final boolean results are collected and formatted as specified. The implementation in the final answer uses `numpy` for mathematical functions as permitted.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the codon optimization problem for a given set of test cases.\n    \"\"\"\n    # Codon data: {Amino Acid: {Codon: Elongation Rate}}\n    CODON_RATES = {\n        'M': {'AUG': 0.75},\n        'W': {'UGG': 0.65},\n        'A': {'GCU': 0.65, 'GCC': 0.85, 'GCA': 0.60, 'GCG': 0.40},\n        'L': {'UUA': 0.30, 'UUG': 0.55, 'CUU': 0.50, 'CUC': 0.70, 'CUA': 0.35, 'CUG': 0.95},\n        'G': {'GGU': 0.60, 'GGC': 0.90, 'GGA': 0.50, 'GGG': 0.40},\n        'S': {'UCU': 0.55, 'UCC': 0.80, 'UCA': 0.50, 'UCG': 0.35, 'AGU': 0.60, 'AGC': 0.85}\n    }\n\n    # Test suite from the problem statement\n    test_cases = [\n        {'seq': \"MALWGS\", 'profile': 'constant', 'params': {'alpha': 0.8}, 'eps': 0.25},\n        {'seq': \"WLLLLL\", 'profile': 'linear', 'params': {'k0': 0.1, 'k1': 0.9}, 'eps': 0.05},\n        {'seq': \"ASGSA\", 'profile': 'sinusoidal', 'params': {'B': 0.5, 'A': 0.3, 'f': 1.0}, 'eps': 0.2},\n        {'seq': \"MW\", 'profile': 'constant', 'params': {'alpha': 0.65}, 'eps': 0.0}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        sequence = case['seq']\n        profile_type = case['profile']\n        params = case['params']\n        epsilon = case['eps']\n        \n        N = len(sequence)\n        is_feasible_for_case = True\n        \n        for i, amino_acid in enumerate(sequence):\n            # Codon-centered position from 1 to N\n            pos_idx = i + 1\n            x = (pos_idx - 0.5) / N\n            \n            # Calculate target elongation rate k_hat\n            if profile_type == 'constant':\n                k_hat = params['alpha']\n            elif profile_type == 'linear':\n                # Re-parameterize k(x) = k0 + (k1-k0)x to use given k0, k1\n                # The problem statement has k(x) = 0.1+0.8x, so k0=0.1, k1-k0=0.8 -> k1=0.9\n                k0 = params['k0']\n                k1 = params['k1'] \n                k_hat = k0 + (k1 - k0) * x\n            elif profile_type == 'sinusoidal':\n                B, A, f = params['B'], params['A'], params['f']\n                k_hat = B + A * np.sin(2 * np.pi * f * x)\n            else:\n                raise ValueError(\"Unknown profile type\")\n\n            # Find the minimum possible error for the current amino acid\n            synonymous_codon_rates = CODON_RATES[amino_acid].values()\n            if not synonymous_codon_rates:\n                # Should not happen with valid input\n                is_feasible_for_case = False\n                break\n                \n            min_error = min(abs(rate - k_hat) for rate in synonymous_codon_rates)\n            \n            # Check if minimum error exceeds tolerance\n            if min_error > epsilon:\n                is_feasible_for_case = False\n                break\n        \n        results.append(is_feasible_for_case)\n\n    # Format output as specified: [True,False,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2721491"}, {"introduction": "Computational models provide powerful predictions, but their relevance hinges on validation against experimental data and accounting for environmental context. This practice bridges modeling with data analysis by tasking you to test a key hypothesis: whether the effect of codon optimality on mRNA stability is constant or changes with the cell's growth condition. Using ordinary least squares regression on hypothetical datasets, you will learn to fit a model with an interaction term and use statistical inference to determine if the relationship is condition-dependent, a crucial skill for building robust biological systems [@problem_id:2721531].", "problem": "You are given paired observations for two cellular growth conditions (Condition A and Condition B) for multiple coding sequences: a codon optimality score (dimensionless; for example, a proxy such as Transfer RNA Adaptation Index (tAI) or Codon Adaptation Index (CAI)) and a measured messenger ribonucleic acid (mRNA) half-life (in minutes). Starting from the Central Dogma and the well-tested observation that translation elongation kinetics (influenced by codon optimality) can couple to mRNA decay pathways, assume that a linear response model with an interaction term can capture condition-dependence of the codon optimality effect on stability. Your task is to test, for each dataset, whether the effect of codon optimality on mRNA half-life depends on the growth condition and to quantify the interaction term.\n\nFundamental base to use:\n- The Central Dogma (DNA → RNA → protein) and the coupling between translation elongation and mRNA decay is a well-tested biological observation.\n- Ordinary least squares is the standard method to estimate unknown coefficients in a linear model by minimizing the sum of squared residuals.\n\nYour program must:\n- For each dataset, combine the two conditions into a single analysis with a binary indicator $c \\in \\{0,1\\}$ for the condition (use $c=0$ for Condition A and $c=1$ for Condition B), include an intercept and a main effect for the codon optimality score $s$, and include the product $s \\cdot c$ to capture a potential condition-dependent slope.\n- Estimate the interaction coefficient (the coefficient multiplying $s \\cdot c$) using ordinary least squares, compute its two-sided $t$-test $p$-value under the null hypothesis that the interaction coefficient equals $0$, using degrees of freedom $n-p$ where $n$ is the number of observations and $p$ is the number of fitted coefficients.\n- Use a significance level $\\alpha = 0.05$ (as a decimal) to make a boolean decision to reject the null hypothesis if the $p$-value is less than $\\alpha$.\n- Report, for each dataset, the estimated interaction coefficient (a float), the two-sided $p$-value (a float), and the boolean decision (a boolean).\n\nPhysical and numerical units:\n- mRNA half-life must be treated in minutes. The codon optimality score is dimensionless. The estimated interaction coefficient has units of minutes per unit codon optimality score. The $p$-value and the decision are unitless. You must output only raw numbers and booleans with no unit labels.\n\nTest suite (three datasets):\n- Dataset $1$ (Condition-dependent effect expected):\n  - Condition A: codon scores $s_A = [\\,0.2,\\,0.3,\\,0.5,\\,0.7,\\,0.9\\,]$, half-lives $h_A$ (minutes) $= [\\,3 + 2\\cdot 0.2 + 0.05,\\; 3 + 2\\cdot 0.3 - 0.03,\\; 3 + 2\\cdot 0.5 + 0.02,\\; 3 + 2\\cdot 0.7 - 0.04,\\; 3 + 2\\cdot 0.9 + 0.01\\,]$.\n  - Condition B: codon scores $s_B = [\\,0.2,\\,0.3,\\,0.5,\\,0.7,\\,0.9\\,]$, half-lives $h_B$ (minutes) $= [\\,4 + 3.5\\cdot 0.2 - 0.02,\\; 4 + 3.5\\cdot 0.3 + 0.01,\\; 4 + 3.5\\cdot 0.5 - 0.03,\\; 4 + 3.5\\cdot 0.7 + 0.04,\\; 4 + 3.5\\cdot 0.9 - 0.01\\,]$.\n- Dataset $2$ (No interaction expected):\n  - Condition A: codon scores $s_A = [\\,0.1,\\,0.25,\\,0.5,\\,0.75,\\,0.9,\\,0.95\\,]$, half-lives $h_A$ (minutes) $= [\\,4 + 1.5\\cdot 0.1 + 0.02,\\; 4 + 1.5\\cdot 0.25 - 0.01,\\; 4 + 1.5\\cdot 0.5 + 0.0,\\; 4 + 1.5\\cdot 0.75 - 0.02,\\; 4 + 1.5\\cdot 0.9 + 0.01,\\; 4 + 1.5\\cdot 0.95 - 0.03\\,]$.\n  - Condition B: codon scores $s_B = [\\,0.1,\\,0.25,\\,0.5,\\,0.75,\\,0.9,\\,0.95\\,]$, half-lives $h_B$ (minutes) $= [\\,4.5 + 1.5\\cdot 0.1 - 0.01,\\; 4.5 + 1.5\\cdot 0.25 + 0.02,\\; 4.5 + 1.5\\cdot 0.5 - 0.02,\\; 4.5 + 1.5\\cdot 0.75 + 0.01,\\; 4.5 + 1.5\\cdot 0.9 + 0.0,\\; 4.5 + 1.5\\cdot 0.95 + 0.01\\,]$.\n- Dataset $3$ (Edge case with small sample size and a slope reduction in Condition B):\n  - Condition A: codon scores $s_A = [\\,0.2,\\,0.8,\\,0.9\\,]$, half-lives $h_A$ (minutes) $= [\\,2 + 1\\cdot 0.2 + 0.01,\\; 2 + 1\\cdot 0.8 - 0.02,\\; 2 + 1\\cdot 0.9 + 0.03\\,]$.\n  - Condition B: codon scores $s_B = [\\,0.1,\\,0.4,\\,0.95\\,]$, half-lives $h_B$ (minutes) $= [\\,2 + 0\\cdot 0.1 - 0.01,\\; 2 + 0\\cdot 0.4 + 0.0,\\; 2 + 0\\cdot 0.95 + 0.02\\,]$.\n\nRequired statistical procedure for each dataset:\n- Construct the combined design with an intercept, the codon score $s$, the condition indicator $c$, and the interaction $s\\cdot c$.\n- Estimate coefficients by minimizing the sum of squared residuals.\n- Compute the residual variance estimate, the standard error of the interaction coefficient, the $t$-statistic, and the two-sided $p$-value using the Student distribution with $n-p$ degrees of freedom.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all datasets as a comma-separated list enclosed in square brackets. Each dataset’s result must be a list in the form [$\\hat{\\beta}_\\text{int}$, $p$, decision], where $\\hat{\\beta}_\\text{int}$ is the estimated interaction coefficient, $p$ is the two-sided $p$-value, and `decision` is a boolean that is `True` if $p  \\alpha$ and `False` otherwise. Round all floats to $6$ decimal places. For example, the overall output must look like $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3]]$.", "solution": "We begin from the Central Dogma (DNA transcribed to RNA and translated to protein) and the well-tested observation that translation elongation kinetics, modulated by codon optimality, can influence messenger ribonucleic acid (mRNA) decay rates via coupling between the ribosome and decay machinery. Thus, an increase in codon optimality score $s$ can increase translation elongation speed and, in many systems, stabilize transcripts, implying that mRNA half-life $h$ depends on $s$. Environmental or growth conditions can alter transfer ribonucleic acid (tRNA) pools or decay factors, potentially changing how $s$ maps to $h$. To capture condition-dependence, we posit a linear response with an interaction between the codon optimality score and a condition indicator.\n\nAlgorithmic modeling framework:\n- For each observation $i$, define $s_i$ as the codon optimality score and $c_i \\in \\{0,1\\}$ as the binary indicator of Condition B (with Condition A coded as $c_i=0$). Let $h_i$ be the measured mRNA half-life (in minutes).\n- Consider a linear model with an intercept, main effects, and an interaction term:\n  $$ h_i = \\beta_0 + \\beta_s s_i + \\beta_c c_i + \\beta_{sc}\\, s_i c_i + \\varepsilon_i, $$\n  where $\\varepsilon_i$ are independent, zero-mean noise terms with finite variance, and $\\beta_{sc}$ quantifies the condition-dependence of the slope relating $s$ to $h$.\n- Stack all $n$ observations into matrix form:\n  $$ \\mathbf{h} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}, $$\n  where $\\mathbf{h}\\in\\mathbb{R}^{n}$, $\\boldsymbol{\\beta} = [\\beta_0,\\beta_s,\\beta_c,\\beta_{sc}]^\\top \\in \\mathbb{R}^{4}$, and\n  $$ \\mathbf{X} = \\begin{bmatrix}\n  1  s_1  c_1  s_1 c_1\\\\\n  \\vdots  \\vdots  \\vdots  \\vdots\\\\\n  1  s_n  c_n  s_n c_n\n  \\end{bmatrix}. $$\n- Estimate coefficients by ordinary least squares (OLS), which minimizes the sum of squared residuals $S(\\boldsymbol{\\beta}) = \\|\\mathbf{h} - \\mathbf{X}\\boldsymbol{\\beta}\\|_2^2$. The OLS estimate is\n  $$ \\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^\\top \\mathbf{X})^{-1}\\mathbf{X}^\\top \\mathbf{h}, $$\n  assuming $\\mathbf{X}$ has full column rank.\n- Compute fitted values $\\hat{\\mathbf{h}} = \\mathbf{X}\\hat{\\boldsymbol{\\beta}}$ and residuals $\\hat{\\boldsymbol{\\varepsilon}} = \\mathbf{h} - \\hat{\\mathbf{h}}$. Let $p=4$ be the number of parameters. The unbiased residual variance estimator is\n  $$ \\hat{\\sigma}^2 = \\frac{\\hat{\\boldsymbol{\\varepsilon}}^\\top \\hat{\\boldsymbol{\\varepsilon}}}{n-p}. $$\n- The covariance matrix of $\\hat{\\boldsymbol{\\beta}}$ under the usual OLS assumptions is\n  $$ \\widehat{\\mathrm{Cov}}(\\hat{\\boldsymbol{\\beta}}) = \\hat{\\sigma}^2 (\\mathbf{X}^\\top \\mathbf{X})^{-1}. $$\n  The standard error of the interaction coefficient is\n  $$ \\mathrm{SE}(\\hat{\\beta}_{sc}) = \\sqrt{\\left[\\widehat{\\mathrm{Cov}}(\\hat{\\boldsymbol{\\beta}})\\right]_{4,4}}. $$\n- To test the null hypothesis $H_0:\\ \\beta_{sc}=0$ versus the two-sided alternative $H_1:\\ \\beta_{sc}\\neq 0$, use the $t$-statistic\n  $$ t = \\frac{\\hat{\\beta}_{sc}}{\\mathrm{SE}(\\hat{\\beta}_{sc})}, $$\n  which, under $H_0$ and standard OLS assumptions, follows a Student distribution with $n-p$ degrees of freedom. The two-sided $p$-value is\n  $$ p = 2\\left(1 - F_{t,n-p}(|t|)\\right), $$\n  where $F_{t,\\nu}$ is the cumulative distribution function of the $t$-distribution with $\\nu$ degrees of freedom.\n- With significance level $\\alpha = 0.05$, reject $H_0$ if $p  \\alpha$. The decision is returned as a boolean.\n\nImplementation details applied to the test suite:\n- For each dataset, build the combined design matrix by concatenating Condition A and Condition B observations. Set $c=0$ for all Condition A rows and $c=1$ for all Condition B rows. Construct the columns $[1, s, c, s\\cdot c]$, estimate $\\hat{\\boldsymbol{\\beta}}$, compute $\\hat{\\sigma}^2$, extract $\\hat{\\beta}_{sc}$ and its standard error, form $t$, evaluate the two-sided $p$-value with $n-p$ degrees of freedom, and compare to $\\alpha=0.05$.\n- Return, for each dataset, the triple [$\\hat{\\beta}_\\text{int}$, $p$, decision], where $\\hat{\\beta}_\\text{int} \\equiv \\hat{\\beta}_{sc}$, rounding $\\hat{\\beta}_\\text{int}$ and $p$ to $6$ decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t as student_t\n\ndef ols_interaction_test(s_A, h_A, s_B, h_B, alpha=0.05):\n    \"\"\"\n    Fit OLS with intercept, s, c, s*c and test interaction coefficient.\n    Returns (beta_interaction, p_value, decision_bool).\n    \"\"\"\n    # Prepare data\n    s_A = np.asarray(s_A, dtype=float)\n    h_A = np.asarray(h_A, dtype=float)\n    s_B = np.asarray(s_B, dtype=float)\n    h_B = np.asarray(h_B, dtype=float)\n\n    # Concatenate\n    s = np.concatenate([s_A, s_B])\n    h = np.concatenate([h_A, h_B])\n    c = np.concatenate([np.zeros_like(s_A), np.ones_like(s_B)])\n\n    # Design matrix: [1, s, c, s*c]\n    X = np.column_stack([np.ones_like(s), s, c, s * c])\n    n, p = X.shape\n\n    # OLS estimates\n    # Compute (X^T X)^{-1} X^T h robustly\n    XtX = X.T @ X\n    XtX_inv = np.linalg.inv(XtX)\n    beta_hat = XtX_inv @ (X.T @ h)\n\n    # Residuals and variance estimate\n    h_hat = X @ beta_hat\n    resid = h - h_hat\n    dof = n - p\n    # Guard against division by zero if dof = 0 (should not occur with provided tests)\n    sigma2_hat = (resid @ resid) / dof\n\n    # Standard errors\n    cov_beta = sigma2_hat * XtX_inv\n    se_beta = np.sqrt(np.diag(cov_beta))\n\n    # Interaction coefficient is the 4th parameter\n    beta_int = beta_hat[3]\n    se_int = se_beta[3]\n\n    # t-statistic and two-sided p-value\n    t_stat = beta_int / se_int\n    p_value = 2.0 * (1.0 - student_t.cdf(np.abs(t_stat), df=dof))\n\n    decision = bool(p_value  alpha)\n    # Round floats to 6 decimals\n    beta_int_r = round(float(beta_int), 6)\n    p_value_r = round(float(p_value), 6)\n    return [beta_int_r, p_value_r, decision]\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Dataset 1\n    sA1 = [0.2, 0.3, 0.5, 0.7, 0.9]\n    hA1 = [3 + 2*0.2 + 0.05,\n           3 + 2*0.3 - 0.03,\n           3 + 2*0.5 + 0.02,\n           3 + 2*0.7 - 0.04,\n           3 + 2*0.9 + 0.01]\n    sB1 = [0.2, 0.3, 0.5, 0.7, 0.9]\n    hB1 = [4 + 3.5*0.2 - 0.02,\n           4 + 3.5*0.3 + 0.01,\n           4 + 3.5*0.5 - 0.03,\n           4 + 3.5*0.7 + 0.04,\n           4 + 3.5*0.9 - 0.01]\n\n    # Dataset 2\n    sA2 = [0.1, 0.25, 0.5, 0.75, 0.9, 0.95]\n    hA2 = [4 + 1.5*0.1 + 0.02,\n           4 + 1.5*0.25 - 0.01,\n           4 + 1.5*0.5 + 0.0,\n           4 + 1.5*0.75 - 0.02,\n           4 + 1.5*0.9 + 0.01,\n           4 + 1.5*0.95 - 0.03]\n    sB2 = [0.1, 0.25, 0.5, 0.75, 0.9, 0.95]\n    hB2 = [4.5 + 1.5*0.1 - 0.01,\n           4.5 + 1.5*0.25 + 0.02,\n           4.5 + 1.5*0.5 - 0.02,\n           4.5 + 1.5*0.75 + 0.01,\n           4.5 + 1.5*0.9 + 0.0,\n           4.5 + 1.5*0.95 + 0.01]\n\n    # Dataset 3\n    sA3 = [0.2, 0.8, 0.9]\n    hA3 = [2 + 1*0.2 + 0.01,\n           2 + 1*0.8 - 0.02,\n           2 + 1*0.9 + 0.03]\n    sB3 = [0.1, 0.4, 0.95]\n    hB3 = [2 + 0*0.1 - 0.01,\n           2 + 0*0.4 + 0.0,\n           2 + 0*0.95 + 0.02]\n\n    alpha = 0.05\n\n    test_cases = [\n        (sA1, hA1, sB1, hB1, alpha),\n        (sA2, hA2, sB2, hB2, alpha),\n        (sA3, hA3, sB3, hB3, alpha),\n    ]\n\n    results = []\n    for sA, hA, sB, hB, a in test_cases:\n        result = ols_interaction_test(sA, hA, sB, hB, alpha=a)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # It should be a single line: [[b1,p1,dec1],[b2,p2,dec2],[b3,p3,dec3]]\n    def format_item(x):\n        if isinstance(x, bool):\n            return \"True\" if x else \"False\"\n        else:\n            return str(x)\n\n    formatted = \"[\" + \",\".join(\n        \"[\" + \",\".join(format_item(x) for x in res) + \"]\" for res in results\n    ) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2721531"}]}