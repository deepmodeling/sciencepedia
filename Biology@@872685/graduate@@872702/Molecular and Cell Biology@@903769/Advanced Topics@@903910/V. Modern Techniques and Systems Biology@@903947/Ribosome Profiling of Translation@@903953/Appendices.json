{"hands_on_practices": [{"introduction": "A key indicator of high-quality ribosome profiling data is strong triplet periodicity, which reflects the codon-by-codon movement of ribosomes along coding sequences. The accuracy of this signal depends critically on correctly inferring the ribosome's P-site from each sequenced footprint. This practice problem sharpens your analytical skills by having you calculate how a common experimental artifact—a systematic error in P-site assignment—distorts the observed frame distribution and degrades quantitative measures of periodicity. [@problem_id:2963266]", "problem": "Ribosome profiling (Ribo-seq) estimates ribosome positions on messenger ribonucleic acid (mRNA) by mapping the protected fragment and inferring the peptidyl-site (P-site) nucleotide of the ribosome. Translation proceeds in codons of length $3$, so reads aligned to protein-coding regions exhibit triplet periodicity: when the aligned P-site positions are reduced modulo $3$, the majority fall in the annotated coding frame. Consider the following controlled scenario of coding-region reads in which the investigator’s P-site offset is misestimated by a systematic shift of $+1$ nucleotide (that is, every assigned P-site is advanced by exactly $1$ nucleotide relative to its true position).\n\nAssume the following fundamental basis:\n- Translation maintains a constant reading frame; modulo-$3$ frame indices are $j \\in \\{0,1,2\\}$, with $j=0$ denoting the annotated coding frame.\n- The true frame-assignment probabilities of bona fide coding-region footprints are $p_{0}, p_{1}, p_{2}$ with $\\sum_{j=0}^{2} p_{j} = 1$.\n- A circular shift of the assigned P-site by $+1$ nucleotide maps a true frame $j$ to an observed frame $(j+1) \\bmod 3$.\n- A fraction $c$ of aligned reads derive from genuine elongating ribosomes on coding sequences (signal) with the above triplet structure, and the remaining fraction $r = 1-c$ are background reads with no frame preference (noise) that are uniformly distributed across frames with probability vector $u = (1/3, 1/3, 1/3)$.\n\nLet the true frame probabilities be $p = (p_{0}, p_{1}, p_{2}) = (0.82, 0.09, 0.09)$, and let the signal fraction be $c = 0.80$ (so $r = 0.20$). Define the investigator’s triplet periodicity statistic as the magnitude of the first nonzero discrete Fourier transform (DFT) component of the frame-deviation vector from uniform:\n$$\nA(p) \\equiv \\left| \\sum_{j=0}^{2} \\left(p_{j} - \\frac{1}{3}\\right) \\,\\omega^{j} \\right|, \\quad \\text{where } \\omega \\equiv \\exp\\!\\left(-\\frac{2\\pi i}{3}\\right).\n$$\n\nStarting only from the above definitions and assumptions, compute under the systematic $+1$-nucleotide P-site error:\n1) the observed frame-assignment probability vector across coding regions after mixing signal and noise, and\n2) the corresponding triplet periodicity amplitude.\n\nExpress your final answer as a single row matrix $\\begin{pmatrix} \\hat{p}_{0} & \\hat{p}_{1} & \\hat{p}_{2} & \\hat{A} \\end{pmatrix}$, where $\\hat{p}_{j}$ are the observed frame probabilities and $\\hat{A}$ is the observed periodicity amplitude. Round each entry to four significant figures. The quantities are dimensionless.", "solution": "We begin from the definitions of frame indices modulo $3$, mixture of signal and uniform background, and the discrete Fourier transform (DFT)-based periodicity statistic. Let the true frame-distribution vector for bona fide coding reads be $p = (p_{0}, p_{1}, p_{2})$ with $\\sum_{j=0}^{2} p_{j} = 1$. A systematic $+1$-nucleotide P-site assignment error maps a true frame $j$ to an observed frame $(j+1) \\bmod 3$, which is a circular shift of the frame vector by one position. Denote this rotation operator by $R$, so that\n$$\nR(p) \\equiv \\big(p_{2},\\, p_{0},\\, p_{1}\\big).\n$$\nGiven a signal fraction $c$ and a background fraction $r = 1-c$ that is uniform across frames with $u = (1/3, 1/3, 1/3)$, the observed frame vector under the systematic error is the mixture\n$$\n\\hat{p} \\equiv c\\,R(p) + r\\,u.\n$$\n\nSubstituting the provided values $p = (0.82, 0.09, 0.09)$ and $c=0.80$ (so $r=0.20$), we first compute the rotated coding component:\n$$\nR(p) = \\big(0.09,\\, 0.82,\\, 0.09\\big).\n$$\nMixing with uniform background yields\n$$\n\\hat{p} = 0.80 \\cdot \\big(0.09,\\, 0.82,\\, 0.09\\big) + 0.20 \\cdot \\left(\\frac{1}{3},\\, \\frac{1}{3},\\, \\frac{1}{3}\\right).\n$$\nCompute each component:\n$$\n0.80 \\cdot 0.09 = 0.072,\\quad 0.80 \\cdot 0.82 = 0.656,\\quad 0.20 \\cdot \\frac{1}{3} = \\frac{1}{15} \\approx 0.066\\overline{6}.\n$$\nTherefore\n$$\n\\hat{p}_{0} = 0.072 + \\frac{1}{15} = \\frac{9}{125} + \\frac{1}{15} = \\frac{52}{375} \\approx 0.1386\\overline{6},\n$$\n$$\n\\hat{p}_{1} = 0.656 + \\frac{1}{15} = \\frac{82}{125} + \\frac{1}{15} = \\frac{271}{375} \\approx 0.7226\\overline{6},\n$$\n$$\n\\hat{p}_{2} = 0.072 + \\frac{1}{15} = \\frac{52}{375} \\approx 0.1386\\overline{6}.\n$$\n\nNext, we compute the triplet periodicity amplitude. By definition,\n$$\nA(p) \\equiv \\left| \\sum_{j=0}^{2} \\left(p_{j} - \\frac{1}{3}\\right)\\omega^{j} \\right|,\\quad \\omega \\equiv \\exp\\!\\left(-\\frac{2\\pi i}{3}\\right).\n$$\nWe will first establish two general invariance properties using only the definitions:\n\n1) Invariance to circular shift up to phase. For a $+1$ circular shift, $R(p)_{j} = p_{j-1}$ with indices modulo $3$. Then\n$$\n\\sum_{j=0}^{2} \\left(R(p)_{j} - \\frac{1}{3}\\right)\\omega^{j}\n= \\sum_{j=0}^{2} \\left(p_{j-1} - \\frac{1}{3}\\right)\\omega^{j}\n= \\omega \\sum_{m=0}^{2} \\left(p_{m} - \\frac{1}{3}\\right)\\omega^{m},\n$$\nwhere we substituted $m=j-1$ and extracted a factor $\\omega$ because $\\omega^{j} = \\omega \\cdot \\omega^{m}$. Since $|\\omega|=1$, it follows that\n$$\nA\\big(R(p)\\big) = A(p).\n$$\n\n2) Linearity and annihilation of the uniform component. For the mixture $\\hat{p} = c\\,R(p) + r\\,u$,\n$$\nA(\\hat{p}) = \\left| \\sum_{j=0}^{2} \\left(c\\,R(p)_{j} + r\\,\\frac{1}{3} - \\frac{1}{3}\\right)\\omega^{j} \\right|\n= \\left| c \\sum_{j=0}^{2} \\left(R(p)_{j} - \\frac{1}{3}\\right)\\omega^{j} + (r-1)\\sum_{j=0}^{2} \\frac{1}{3}\\omega^{j} \\right|.\n$$\nBut $\\sum_{j=0}^{2} \\omega^{j} = 0$ for third roots of unity, hence the uniform term vanishes and\n$$\nA(\\hat{p}) = c \\left| \\sum_{j=0}^{2} \\left(R(p)_{j} - \\frac{1}{3}\\right)\\omega^{j} \\right| = c\\,A\\big(R(p)\\big) = c\\,A(p).\n$$\n\nTherefore, we only need $A(p)$ for the given $p$ and then scale by $c=0.80$. Compute $A(p)$ explicitly. Let\n$$\nq_{j} \\equiv p_{j} - \\frac{1}{3}.\n$$\nFor $p=(0.82,0.09,0.09)$,\n$$\nq_{0} = 0.82 - \\frac{1}{3} = \\frac{41}{50} - \\frac{1}{3} = \\frac{73}{150},\n$$\n$$\nq_{1} = 0.09 - \\frac{1}{3} = \\frac{9}{100} - \\frac{1}{3} = -\\frac{73}{300},\n$$\n$$\nq_{2} = -\\frac{73}{300}.\n$$\nUsing $\\omega^{0}=1$, $\\omega^{1}=-\\frac{1}{2} - i\\frac{\\sqrt{3}}{2}$, and $\\omega^{2}=-\\frac{1}{2} + i\\frac{\\sqrt{3}}{2}$, observe that $q_{1}=q_{2}$, so the imaginary parts cancel:\n$$\n\\sum_{j=0}^{2} q_{j}\\omega^{j} = q_{0}\\cdot 1 + q_{1}\\omega + q_{2}\\omega^{2}\n= q_{0} + q_{1}(\\omega + \\omega^{2}) = q_{0} + q_{1}(-1) = q_{0} - q_{1}.\n$$\nThus\n$$\nA(p) = |q_{0} - q_{1}| = \\left|\\frac{73}{150} - \\left(-\\frac{73}{300}\\right)\\right| = \\left|\\frac{73}{150} + \\frac{73}{300}\\right| = \\frac{73}{100} = 0.73.\n$$\nApplying the scaling by $c=0.80 = \\frac{4}{5}$,\n$$\n\\hat{A} = A(\\hat{p}) = c\\,A(p) = \\frac{4}{5} \\cdot \\frac{73}{100} = \\frac{73}{125} = 0.584.\n$$\n\nCollecting results and rounding each entry to four significant figures:\n$$\n\\hat{p}_{0} \\approx 0.1387,\\quad \\hat{p}_{1} \\approx 0.7227,\\quad \\hat{p}_{2} \\approx 0.1387,\\quad \\hat{A} \\approx 0.5840.\n$$\n\nThese values encode how the $+1$-nucleotide systematic P-site offset error circularly permutes the frame-assignment probabilities while leaving the triplet periodicity amplitude invariant except for the dilution by uniform background, which scales the amplitude by the signal fraction $c$.", "answer": "$$\\boxed{\\begin{pmatrix}0.1387 & 0.7227 & 0.1387 & 0.5840\\end{pmatrix}}$$", "id": "2963266"}, {"introduction": "A major challenge in quantifying gene expression from sequencing data is handling reads that map to multiple genomic locations, a common issue for recently duplicated or paralogous genes. Different statistical strategies can be used to allocate these ambiguous \"multi-mapping\" reads, with significant consequences for the final expression estimates. This coding exercise provides hands-on experience in implementing and evaluating several key allocation algorithms, from simple heuristics to a more principled iterative maximum-likelihood approach, revealing their impact on translational efficiency estimates. [@problem_id:2963228]", "problem": "You are given a principled modeling task rooted in ribosome profiling of translation. Use the following fundamental basis to derive an algorithm and then implement it as a program. Fundamental basis: the Central Dogma states that genes are transcribed into messenger RNA (mRNA) and translated by ribosomes into protein. In ribosome profiling, ribosome-protected fragments (RPFs) are sequenced; counts of RPFs reflect ribosome occupancy. It is well established that, for a gene indexed by $g$, if $m_g$ denotes its mRNA abundance and $\\theta_g$ denotes its translational efficiency (TE), then the expected RPF count is proportional to $m_g \\theta_g$. A practical definition of translational efficiency in this setup is $TE_g \\equiv \\theta_g = \\text{RPF}_g / m_g$, which is dimensionless. Multi-mapping reads arise when a read aligns equally well to multiple paralogous genes; the allocation of these ambiguous reads across genes influences estimates of $TE_g$.\n\nYour task is to derive, from the above basis and standard likelihood principles, a method to weight multi-mapping reads across paralogous genes and to evaluate how different weighting schemes influence estimates of $TE_g$. Specifically:\n\n1. Represent a paralog group as a set of genes $\\{g\\}$ for which you are given:\n   - An mRNA abundance vector $\\mathbf{m} = (m_g)$,\n   - A vector of unique RPF counts $\\mathbf{u} = (u_g)$, and\n   - A scalar $M$ denoting the total number of ambiguous RPF reads that map equally to any gene in the group.\n   - A ground-truth translational efficiency vector $\\boldsymbol{\\theta}^{\\ast} = (\\theta^{\\ast}_g)$ used solely for evaluation.\n\n2. Define and implement three allocation schemes for the $M$ ambiguous reads in a group:\n   - Uniform allocation: allocate equally across all genes in the group.\n   - Proportional-to-mRNA allocation: allocate proportional to $m_g$.\n   - An iterative maximum-likelihood allocation justified by a Poisson generative model in which observed RPF counts for gene $g$ follow a Poisson distribution with mean $m_g \\theta_g$. Under this model, ambiguous read responsibilities for gene $g$ at iteration $t$ are proportional to $m_g \\theta_g^{(t)}$. Initialize $\\theta_g^{(0)}$ using only information available without knowledge of multi-mappers by combining the unique-data estimator with a nonzero baseline so that $\\theta_g^{(0)} = u_g / m_g + \\lambda$, where $\\lambda$ is the baseline estimated as the global unique-data mean $\\lambda = \\left(\\sum_g u_g\\right)/\\left(\\sum_g m_g\\right)$. Iterate until the maximum absolute change in $\\theta_g$ across genes is below a tolerance of $10^{-10}$ or until $10{,}000$ iterations, whichever occurs first. After convergence, define the allocated ambiguous reads as $a_g$, the expected ambiguous read count for gene $g$, with $\\sum_g a_g = M$, and compute the resulting $\\widehat{\\theta}_g = (u_g + a_g)/m_g$.\n   Your program must implement all three schemes exactly as described.\n\n3. For each scheme, compute the translational efficiency estimate $\\widehat{\\theta}_g = (u_g + a_g)/m_g$ and evaluate the mean squared error (MSE) against the provided ground truth $\\theta^{\\ast}_g$ across genes in the group:\n   $$ \\text{MSE} = \\frac{1}{G} \\sum_{g=1}^{G} \\left(\\widehat{\\theta}_g - \\theta^{\\ast}_g \\right)^2, $$\n   where $G$ is the number of genes in the paralog group.\n\nTest suite. Implement your program to run on the following four paralog-group cases. Each case specifies $(\\mathbf{m}, \\mathbf{u}, M, \\boldsymbol{\\theta}^{\\ast})$.\n\n- Case A (balanced paralogs):\n  - $\\mathbf{m} = [500, 500]$,\n  - $\\mathbf{u} = [10, 10]$,\n  - $M = 20$,\n  - $\\boldsymbol{\\theta}^{\\ast} = [0.04, 0.04]$.\n\n- Case B (imbalanced translational efficiencies with equal mRNA):\n  - $\\mathbf{m} = [500, 500]$,\n  - $\\mathbf{u} = [16, 4]$,\n  - $M = 30$,\n  - $\\boldsymbol{\\theta}^{\\ast} = [0.08, 0.02]$.\n\n- Case C (one paralog with zero unique RPFs):\n  - $\\mathbf{m} = [400, 200]$,\n  - $\\mathbf{u} = [2, 0]$,\n  - $M = 22$,\n  - $\\boldsymbol{\\theta}^{\\ast} = [0.05, 0.02]$.\n\n- Case D (three paralogs with sparse unique RPFs):\n  - $\\mathbf{m} = [300, 150, 50]$,\n  - $\\mathbf{u} = [4, 1, 0]$,\n  - $M = 19$,\n  - $\\boldsymbol{\\theta}^{\\ast} = [0.06, 0.03, 0.015]$.\n\nOutput specification. Your program must compute, for each case in the order A, B, C, D, the MSE under the three schemes in the fixed order: uniform, proportional-to-mRNA, iterative maximum-likelihood. Aggregate all $12$ floating-point MSE values into a single list in this order:\n$$[\\text{A\\_uniform}, \\text{A\\_mRNA}, \\text{A\\_iterative}, \\text{B\\_uniform}, \\text{B\\_mRNA}, \\text{B\\_iterative}, \\text{C\\_uniform}, \\text{C\\_mRNA}, \\text{C\\_iterative}, \\text{D\\_uniform}, \\text{D\\_mRNA}, \\text{D\\_iterative}]$$\nand print them as a single line, as a comma-separated list enclosed in square brackets. Express each number with exactly $6$ digits after the decimal point (round half away from zero if needed). No additional text may be printed.", "solution": "The central task is to estimate gene-specific translational efficiencies, denoted by $\\theta_g$, from ribosome profiling data. The fundamental relationship provided is that the expected ribosome-protected fragment (RPF) count for a gene $g$, $\\text{RPF}_g$, is proportional to the product of its messenger RNA (mRNA) abundance, $m_g$, and its translational efficiency, $\\theta_g$. A practical estimator for $\\theta_g$ is thus $\\widehat{\\theta}_g = \\text{RPF}_g / m_g$.\n\nThe complexity arises from multi-mapping reads, which are RPFs that cannot be uniquely assigned to a single gene. For a paralog group of $G$ genes, we are given a vector of uniquely mapped RPF counts, $\\mathbf{u} = (u_1, u_2, \\ldots, u_G)$, the vector of mRNA abundances, $\\mathbf{m} = (m_1, m_2, \\ldots, m_G)$, and a total count of ambiguous RPFs, $M$. The total RPF count for gene $g$ is $u_g + a_g$, where $a_g$ is the number of ambiguous reads allocated to gene $g$, and $\\sum_{g=1}^G a_g = M$. The estimated translational efficiency is then given by:\n$$ \\widehat{\\theta}_g = \\frac{u_g + a_g}{m_g} $$\nWe will now derive the allocation vector $\\mathbf{a} = (a_1, a_2, \\ldots, a_G)$ for each of the three specified schemes and then evaluate their performance using the Mean Squared Error (MSE) against a ground truth $\\boldsymbol{\\theta}^{\\ast}$:\n$$ \\text{MSE} = \\frac{1}{G} \\sum_{g=1}^{G} \\left(\\widehat{\\theta}_g - \\theta^{\\ast}_g \\right)^2 $$\n\nScheme 1: Uniform Allocation\nThis scheme is the most naive approach, distributing the ambiguous reads equally among all genes in the paralog group, irrespective of any other information. For a group of size $G$, the allocation for each gene $g$ is:\n$$ a_g = \\frac{M}{G} $$\n\nScheme 2: Proportional-to-mRNA Allocation\nThis scheme assumes that the likelihood of an ambiguous read originating from a gene is proportional to that gene's mRNA abundance. This is a more informed heuristic than the uniform scheme. The proportion of reads allocated to gene $g$ is the ratio of its mRNA abundance to the total mRNA abundance in the group.\n$$ a_g = M \\cdot \\frac{m_g}{\\sum_{i=1}^G m_i} $$\n\nScheme 3: Iterative Maximum-Likelihood Allocation\nThis scheme is derived from a generative statistical model. We assume the total RPF count for gene $g$ follows a Poisson distribution with mean (and variance) $\\lambda_g = m_g \\theta_g$. The goal is to find the $\\theta_g$ values that maximize the likelihood of the observed data, which consists of the unique counts $\\mathbf{u}$ and the ambiguous count $M$. This is a classic missing data problem, solvable with an Expectation-Maximization (EM) algorithm.\n\nThe algorithm proceeds as follows:\n1.  **Initialization**: At iteration $t=0$, we require an initial estimate for the translational efficiencies, $\\boldsymbol{\\theta}^{(0)}$. The problem specifies an initialization that combines the unique-read information with a baseline term $\\lambda$ to avoid zero estimates for genes with no unique reads.\n    The baseline is the global mean TE calculated from unique reads:\n    $$ \\lambda = \\frac{\\sum_{i=1}^G u_i}{\\sum_{i=1}^G m_i} $$\n    The initial TE for gene $g$ is:\n    $$ \\theta_g^{(0)} = \\frac{u_g}{m_g} + \\lambda $$\n2.  **Iteration**: The algorithm iterates between an E-step and an M-step.\n    -   **E-Step (Expectation)**: At iteration $t$, given the current TE estimates $\\boldsymbol{\\theta}^{(t)}$, we calculate the expected allocation of the $M$ ambiguous reads. The probability (or responsibility) that an ambiguous read belongs to gene $g$ is proportional to the expected number of RPFs from that gene, which is $m_g \\theta_g^{(t)}$. Thus, the responsibility for gene $g$ is:\n        $$ r_g^{(t)} = \\frac{m_g \\theta_g^{(t)}}{\\sum_{i=1}^G m_i \\theta_i^{(t)}} $$\n        The expected number of ambiguous reads allocated to gene $g$, denoted $a_g^{(t)}$, is then:\n        $$ a_g^{(t)} = M \\cdot r_g^{(t)} $$\n    -   **M-Step (Maximization)**: Using the expected allocation $a_g^{(t)}$, we update the TE estimate for each gene to get $\\boldsymbol{\\theta}^{(t+1)}$. The updated total RPF count for gene $g$ is $u_g + a_g^{(t)}$. The new TE estimate that maximizes the Poisson likelihood is:\n        $$ \\theta_g^{(t+1)} = \\frac{u_g + a_g^{(t)}}{m_g} $$\n3.  **Termination**: The iteration continues until the maximum absolute change in any $\\theta_g$ between successive iterations falls below a tolerance of $10^{-10}$, or until a maximum of $10,000$ iterations is reached.\n\nUpon convergence, the final allocation $\\mathbf{a}$ is taken from the last iteration, and the final TE estimates $\\widehat{\\boldsymbol{\\theta}}$ and the resulting MSE are computed.\n\nThe implementation will apply these three distinct methodologies to each of the four test cases provided, calculating the MSE for each combination of case and scheme.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ribosome profiling multi-mapper problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: balanced paralogs\n        {\n            \"m\": np.array([500, 500]),\n            \"u\": np.array([10, 10]),\n            \"M\": 20,\n            \"theta_star\": np.array([0.04, 0.04])\n        },\n        # Case B: imbalanced TEs with equal mRNA\n        {\n            \"m\": np.array([500, 500]),\n            \"u\": np.array([16, 4]),\n            \"M\": 30,\n            \"theta_star\": np.array([0.08, 0.02])\n        },\n        # Case C: one paralog with zero unique RPFs\n        {\n            \"m\": np.array([400, 200]),\n            \"u\": np.array([2, 0]),\n            \"M\": 22,\n            \"theta_star\": np.array([0.05, 0.02])\n        },\n        # Case D: three paralogs with sparse unique RPFs\n        {\n            \"m\": np.array([300, 150, 50]),\n            \"u\": np.array([4, 1, 0]),\n            \"M\": 19,\n            \"theta_star\": np.array([0.06, 0.03, 0.015])\n        }\n    ]\n\n    all_mse_results = []\n\n    for case in test_cases:\n        m, u, M, theta_star = case[\"m\"], case[\"u\"], case[\"M\"], case[\"theta_star\"]\n        G = len(m) # Number of genes in the paralog group\n\n        # --- Scheme 1: Uniform allocation ---\n        a_uniform = M / G\n        theta_hat_uniform = (u + a_uniform) / m\n        mse_uniform = np.mean((theta_hat_uniform - theta_star)**2)\n        all_mse_results.append(mse_uniform)\n\n        # --- Scheme 2: Proportional-to-mRNA allocation ---\n        # A small epsilon is added to the denominator to prevent division by zero\n        # if total mRNA count is zero, though not the case in test data.\n        sum_m = np.sum(m)\n        a_proportional = M * m / (sum_m if sum_m > 0 else 1.0)\n        theta_hat_proportional = (u + a_proportional) / m\n        mse_proportional = np.mean((theta_hat_proportional - theta_star)**2)\n        all_mse_results.append(mse_proportional)\n\n        # --- Scheme 3: Iterative maximum-likelihood allocation ---\n        # Initialization\n        sum_u_total = np.sum(u)\n        sum_m_total = np.sum(m)\n        \n        # Prevent division by zero, though not in test data.\n        if sum_m_total > 0:\n            lambda_baseline = sum_u_total / sum_m_total\n        else:\n            lambda_baseline = 0\n            \n        theta_t = u / m + lambda_baseline\n        \n        # Iteration\n        max_iter = 10000\n        tolerance = 1e-10\n        a_iter = np.zeros_like(m, dtype=float)\n\n        for _ in range(max_iter):\n            theta_prev = theta_t.copy()\n            \n            # E-step: calculate responsibilities and expected allocations\n            weighted_sum = np.sum(m * theta_t)\n            if weighted_sum > 0:\n                responsibilities = (m * theta_t) / weighted_sum\n            else:\n                responsibilities = np.ones(G) / G # Fallback to uniform\n            \n            a_iter = M * responsibilities\n            \n            # M-step: update TE estimates\n            theta_t = (u + a_iter) / m\n            \n            # Check for convergence\n            if np.max(np.abs(theta_t - theta_prev))  tolerance:\n                break\n        \n        # Final calculation after convergence or max iterations\n        theta_hat_iter = theta_t\n        mse_iterative = np.mean((theta_hat_iter - theta_star)**2)\n        all_mse_results.append(mse_iterative)\n\n    # Format output as specified\n    formatted_results = [f\"{res:.6f}\" for res in all_mse_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "2963228"}, {"introduction": "To uncover genuine gene-specific regulation, raw estimates of translational efficiency (TE) must be normalized to account for global, systemic shifts that can occur between experimental conditions. A robust normalization strategy can be developed by modeling the fundamental kinetics of translation and leveraging a set of internal control genes. This exercise challenges you to derive such a normalization scheme from first principles and apply it to a realistic dataset, bridging the gap between theoretical models of translation and the practical correction of experimental data. [@problem_id:2963235]", "problem": "A central task in ribosome profiling is to infer how translation changes between conditions from counts of ribosome protected fragments (RPF) and messenger ribonucleic acid (mRNA) abundances measured by RNA sequencing (RNA-seq). Consider two conditions, denoted $A$ and $B$. Assume steady state translation where ribosome density on a transcript is proportional to the initiation rate and the mean ribosome dwell time along the coding sequence, and assume elongation kinetics and coding sequence length are unchanged between $A$ and $B$. Under these assumptions, a widely used estimator of per-transcript translation activity equates it to the ratio of RPF abundance to mRNA abundance. Starting from these fundamentals (ribosome density proportional to initiation rate times mRNA abundance when elongation is unchanged), derive how a global multiplicative change in initiation rates across condition $B$ relative to $A$ appears in this ratio-based estimator and therefore can confound gene-specific translation inferences. Then, propose a principled normalization scheme that corrects for such global scaling using a set of housekeeping genes whose gene-specific translation is unchanged between $A$ and $B$. Your scheme should define a condition-specific scaling factor and a corrected translation estimator.\n\nFinally, apply your normalization scheme to the following dataset. The quantities below for each gene are per-cell calibrated abundances (so that cross-condition comparisons are meaningful). For each gene, you are given the mRNA abundance and the RPF abundance in both conditions:\n- Gene H1: mRNA $A = 100$, mRNA $B = 100$; RPF $A = 400$, RPF $B = 720$.\n- Gene H2: mRNA $A = 200$, mRNA $B = 200$; RPF $A = 400$, RPF $B = 720$.\n- Gene H3: mRNA $A = 150$, mRNA $B = 150$; RPF $A = 450$, RPF $B = 810$.\n- Gene H4: mRNA $A = 80$, mRNA $B = 80$; RPF $A = 400$, RPF $B = 720$.\n- Gene X: mRNA $A = 120$, mRNA $B = 120$; RPF $A = 300$, RPF $B = 810$.\n\nTreat H1–H4 as housekeeping genes whose gene-specific translation is unchanged between $A$ and $B$. Using your derived normalization scheme, compute the corrected translation estimator for Gene X in condition $B$. Express your final answer as a single dimensionless value and round your answer to four significant figures.", "solution": "Let the index $g$ denote a specific gene. We are given the following quantities:\n- $P_g$: RPF abundance for gene $g$.\n- $M_g$: mRNA abundance for gene $g$.\n- $I_g$: Translation initiation rate for gene $g$.\n- $\\tau_g$: Mean ribosome dwell time for gene $g$ (related to elongation).\n- $L_g$: Length of the coding sequence for gene $g$.\n\nThe total number of ribosome-protected fragments, $P_g$, is proportional to the total number of ribosomes translating the mRNA of gene $g$. This can be expressed as the product of the number of mRNA transcripts ($M_g$) and the average number of ribosomes per transcript. The latter is the product of ribosome density ($R_g$) and the length of the translated region ($L_g$).\n$$P_g \\propto M_g \\cdot R_g \\cdot L_g$$\nThe problem states that ribosome density is proportional to the initiation rate and the mean dwell time:\n$$R_g \\propto I_g \\cdot \\tau_g$$\nCombining these proportionalities yields:\n$$P_g \\propto M_g \\cdot I_g \\cdot \\tau_g \\cdot L_g$$\nWe can introduce a gene-specific constant of proportionality $c_g$ to formalize this:\n$$P_g = c_g \\cdot M_g \\cdot I_g \\cdot \\tau_g \\cdot L_g$$\nThe problem defines the per-transcript translation activity estimator, which we will call $T_g$, as the ratio of RPF abundance to mRNA abundance:\n$$T_g = \\frac{P_g}{M_g} = c_g \\cdot I_g \\cdot \\tau_g \\cdot L_g$$\nLet's denote the two conditions with superscripts $A$ and $B$.\n$$T_g^A = \\frac{P_g^A}{M_g^A} \\quad \\text{and} \\quad T_g^B = \\frac{P_g^B}{M_g^B}$$\nThe problem assumes that elongation kinetics ($\\tau_g$) and coding sequence length ($L_g$) are unchanged between conditions. The proportionality constant $c_g$ is also an intrinsic property. Therefore, the term $C_g = c_g \\cdot \\tau_g \\cdot L_g$ is a constant for gene $g$ across both conditions. This leads to:\n$$T_g^A = C_g \\cdot I_g^A$$\n$$T_g^B = C_g \\cdot I_g^B$$\nThe ratio of these estimators for a gene $g$ is:\n$$\\frac{T_g^B}{T_g^A} = \\frac{C_g \\cdot I_g^B}{C_g \\cdot I_g^A} = \\frac{I_g^B}{I_g^A}$$\nThis ratio directly measures the fold-change in the translation initiation rate.\n\nA global multiplicative change in initiation rates in condition $B$ can be modeled by representing the initiation rate $I_g^B$ as a product of a global, systemic factor $S$ and a gene-specific regulatory factor $\\lambda_g$:\n$$I_g^B = S \\cdot \\lambda_g \\cdot I_g^A$$\nSubstituting this into the ratio of estimators demonstrates the confounding effect:\n$$\\frac{T_g^B}{T_g^A} = S \\cdot \\lambda_g$$\nThe observed fold-change in the translation estimator is contaminated by the global factor $S$, preventing direct inference of the true gene-specific change $\\lambda_g$.\n\nTo correct for this, we use housekeeping genes (indexed by $h$), which are assumed to have no gene-specific change in translation, i.e., $\\lambda_h = 1$. For such a gene:\n$$\\frac{T_h^B}{T_h^A} = S \\cdot 1 = S$$\nThis provides a method to estimate $S$. A robust estimate, $\\hat{S}$, can be obtained by averaging this ratio over all available housekeeping genes.\n\nThe resulting normalization scheme is:\n1.  **Condition-Specific Scaling Factor**: The factor for condition $B$ relative to reference condition $A$ is $S$. We estimate it as $\\hat{S}$ using the set of housekeeping genes, $H$:\n    $$\\hat{S} = \\underset{h \\in H}{\\text{mean}}\\left( \\frac{T_h^B}{T_h^A} \\right) = \\underset{h \\in H}{\\text{mean}}\\left( \\frac{P_h^B / M_h^B}{P_h^A / M_h^A} \\right)$$\n2.  **Corrected Translation Estimator**: The estimator in condition $B$, $T_g^B$, is systemically scaled by $S$. To place it on the same scale as condition $A$, we normalize by dividing by $\\hat{S}$. The corrected estimator, $T'^{B}_g$, is:\n    $$T'^{B}_g = \\frac{T_g^B}{\\hat{S}} = \\frac{P_g^B / M_g^B}{\\hat{S}}$$\n\n**Application to Provided Data**\n\nFirst, we calculate the scaling factor $\\hat{S}$ from the housekeeping genes H1–H4.\nFor Gene H1:\n$T_{H1}^A = \\frac{P_{H1}^A}{M_{H1}^A} = \\frac{400}{100} = 4.0$\n$T_{H1}^B = \\frac{P_{H1}^B}{M_{H1}^B} = \\frac{720}{100} = 7.2$\nRatio: $\\frac{T_{H1}^B}{T_{H1}^A} = \\frac{7.2}{4.0} = 1.8$.\n\nFor Gene H2:\n$T_{H2}^A = \\frac{P_{H2}^A}{M_{H2}^A} = \\frac{400}{200} = 2.0$\n$T_{H2}^B = \\frac{P_{H2}^B}{M_{H2}^B} = \\frac{720}{200} = 3.6$\nRatio: $\\frac{T_{H2}^B}{T_{H2}^A} = \\frac{3.6}{2.0} = 1.8$.\n\nFor Gene H3:\n$T_{H3}^A = \\frac{P_{H3}^A}{M_{H3}^A} = \\frac{450}{150} = 3.0$\n$T_{H3}^B = \\frac{P_{H3}^B}{M_{H3}^B} = \\frac{810}{150} = 5.4$\nRatio: $\\frac{T_{H3}^B}{T_{H3}^A} = \\frac{5.4}{3.0} = 1.8$.\n\nFor Gene H4:\n$T_{H4}^A = \\frac{P_{H4}^A}{M_{H4}^A} = \\frac{400}{80} = 5.0$\n$T_{H4}^B = \\frac{P_{H4}^B}{M_{H4}^B} = \\frac{720}{80} = 9.0$\nRatio: $\\frac{T_{H4}^B}{T_{H4}^A} = \\frac{9.0}{5.0} = 1.8$.\n\nAll housekeeping genes yield an identical ratio. Thus, the mean is simply this value.\n$$\\hat{S} = 1.8$$\nNext, we compute the corrected translation estimator for Gene X in condition $B$, which is $T'^{B}_X$. First, we compute the uncorrected estimator $T_X^B$:\n$$T_X^B = \\frac{P_X^B}{M_X^B} = \\frac{810}{120} = 6.75$$\nNow, we apply the normalization:\n$$T'^{B}_X = \\frac{T_X^B}{\\hat{S}} = \\frac{6.75}{1.8} = 3.75$$\nThe final answer must be given to four significant figures.\n$$3.750$$", "answer": "$$\\boxed{3.750}$$", "id": "2963235"}]}