{"hands_on_practices": [{"introduction": "The classical Lotka-Volterra competition model provides a powerful, albeit simplified, framework for understanding how species interactions influence population dynamics and community structure. This exercise requires you to apply this model to determine the outcome of competition between two plant species based on their empirically estimated life-history parameters. By analyzing the conditions for mutual invasibility, you will practice assessing whether interspecific competition is sufficiently weak relative to intraspecific competition to permit stable coexistence, a cornerstone of niche theory [@problem_id:2535012].", "problem": "Two herbaceous plant species, labeled species $1$ and species $2$, compete for a single limiting soil nutrient on a homogeneous $1 \\times 1$ meter plot. Empirical field estimates provide the following parameters: intrinsic growth rates $r_{1} = 0.20$ day$^{-1}$ and $r_{2} = 0.15$ day$^{-1}$; carrying capacities $K_{1} = 400$ and $K_{2} = 300$ individuals per square meter; and interspecific competition coefficients $\\alpha_{12} = 0.40$ and $\\alpha_{21} = 0.60$, where $\\alpha_{ij}$ quantifies the effect of species $j$ on species $i$ relative to the effect of species $i$ on itself. Assume population dynamics follow the classical two-species Lotka–Volterra (LV) competition framework with logistic self-limitation for each species, and that parameters are time-invariant. Using only core definitions of the ecological niche as the joint utilization of resources and conditions, and the LV representation of intraspecific versus interspecific competition, determine from first principles whether a locally stable interior coexistence state is expected under these parameters, and compute the interior coexistence equilibrium if it exists. Report only the equilibrium abundance of species $1$ (that is, the equilibrium density of species $1$), expressed in individuals per square meter. Round your answer to four significant figures.", "solution": "The problem requires an analysis of a two-species competition system governed by the classical Lotka-Volterra (LV) competition model. We must first validate the conditions for a locally stable coexistence equilibrium before computing any values.\n\nThe dynamics of the two species, with population densities $N_1$ and $N_2$, are described by the following system of coupled differential equations:\n$$ \\frac{dN_1}{dt} = r_1 N_1 \\left( 1 - \\frac{N_1 + \\alpha_{12} N_2}{K_1} \\right) $$\n$$ \\frac{dN_2}{dt} = r_2 N_2 \\left( 1 - \\frac{N_2 + \\alpha_{21} N_1}{K_2} \\right) $$\nThe parameters provided are:\nIntrinsic growth rates: $r_1 = 0.20$, $r_2 = 0.15$.\nCarrying capacities: $K_1 = 400$, $K_2 = 300$.\nCompetition coefficients: $\\alpha_{12} = 0.40$, $\\alpha_{21} = 0.60$.\n\nAn interior coexistence equilibrium ($N_1^*  0$, $N_2^*  0$) occurs where the net growth rates of both species are zero. This requires finding the point of intersection of the non-trivial zero-growth isoclines. The isoclines are found by setting the derivatives to zero:\nFor species $1$ ($\\frac{dN_1}{dt} = 0$):\n$$ 1 - \\frac{N_1 + \\alpha_{12} N_2}{K_1} = 0 \\implies N_1 + \\alpha_{12} N_2 = K_1 $$\nFor species $2$ ($\\frac{dN_2}{dt} = 0$):\n$$ 1 - \\frac{N_2 + \\alpha_{21} N_1}{K_2} = 0 \\implies \\alpha_{21} N_1 + N_2 = K_2 $$\n\nA locally stable coexistence equilibrium is only possible if interspecific competition is weaker than intraspecific competition for both species, in a relative sense. This condition for mutual invasibility, which leads to a stable equilibrium, is stated as a pair of inequalities: each species must be able to increase from a low density when the other species is at its carrying capacity.\n1. For species $1$ to invade a population of species $2$ at its carrying capacity ($N_2=K_2$), the growth rate $\\frac{dN_1}{dt}$ must be positive. This requires the parenthetical term in its growth equation to be positive for $N_1 \\approx 0$ and $N_2 = K_2$. This yields the condition $K_1  \\alpha_{12} K_2$.\n2. For species $2$ to invade a population of species $1$ at its carrying capacity ($N_1=K_1$), the growth rate $\\frac{dN_2}{dt}$ must be positive. This yields the condition $K_2  \\alpha_{21} K_1$.\n\nWe must verify these conditions using the given parameters:\nCondition 1: Is $K_1  \\alpha_{12} K_2$?\n$$ 400  0.40 \\times 300 $$\n$$ 400  120 $$\nThis inequality is true. Species $1$ can invade a monoculture of species $2$.\n\nCondition 2: Is $K_2  \\alpha_{21} K_1$?\n$$ 300  0.60 \\times 400 $$\n$$ 300  240 $$\nThis inequality is also true. Species $2$ can invade a monoculture of species $1$.\n\nSince both conditions for mutual invasibility are satisfied, a locally stable interior coexistence equilibrium exists. We can now proceed to calculate the equilibrium densities by solving the system of linear equations for the isoclines:\n$$ N_1^* + \\alpha_{12} N_2^* = K_1 $$\n$$ \\alpha_{21} N_1^* + N_2^* = K_2 $$\nUsing Cramer's rule or substitution, the solution for the equilibrium densities ($N_1^*$, $N_2^*$) is:\n$$ N_1^* = \\frac{K_1 - \\alpha_{12} K_2}{1 - \\alpha_{12} \\alpha_{21}} $$\n$$ N_2^* = \\frac{K_2 - \\alpha_{21} K_1}{1 - \\alpha_{12} \\alpha_{21}} $$\nThe problem asks for the equilibrium abundance of species $1$, $N_1^*$. Substituting the given values into the formula for $N_1^*$:\n$$ N_1^* = \\frac{400 - (0.40)(300)}{1 - (0.40)(0.60)} $$\n$$ N_1^* = \\frac{400 - 120}{1 - 0.24} $$\n$$ N_1^* = \\frac{280}{0.76} $$\nPerforming the division:\n$$ N_1^* = \\frac{28000}{76} = \\frac{7000}{19} \\approx 368.42105... $$\nThe problem requires the answer to be rounded to four significant figures.\n$$ N_1^* \\approx 368.4 $$\nThe equilibrium abundance of species $1$ is $368.4$ individuals per square meter.", "answer": "$$\\boxed{368.4}$$", "id": "2535012"}, {"introduction": "Moving from theoretical models to empirical data, this practice operationalizes the Hutchinsonian niche concept using modern computational methods. You will work with simulated occurrence data from a species' native and invaded ranges to quantify and compare their environmental niches using kernel density estimation [@problem_id:2535013]. This hands-on exercise involves calculating key niche overlap metrics and performing non-parametric statistical tests to distinguish between niche conservatism and niche shifts, accounting for differences in the available environmental background.", "problem": "You are given a formalization of Hutchinson’s niche concept in a two-dimensional environmental space. Occurrence points from a native range and an invaded range are treated as independent and identically distributed samples from unknown probability density functions over environmental space. Two additional point clouds (called backgrounds) represent the environmental availability in each range, and associated nonnegative weights represent sampling bias in background sampling.\n\nUsing only the following fundamental bases:\n- The niche of a species is a subset of an environmental space defined by a joint probability distribution over environmental variables, and occurrences are samples from that distribution.\n- Kernel density estimation using a Gaussian kernel produces a nonnegative, integrable function that can approximate an unknown density.\n- The $L^{1}$ distance between two probability distributions measures their absolute difference, and the Hellinger distance measures the Euclidean distance between their square-root transformed densities.\n\nYour tasks are:\n1) Standardize all environmental variables by subtracting the pooled background mean and dividing by the pooled background standard deviation (computed across backgrounds from both ranges jointly and applied dimensionwise to every point). If any pooled background standard deviation in a dimension is $0$, replace it by a small positive constant $10^{-8}$ to avoid division by zero.\n\n2) Estimate a continuous density for each occurrence set using a Gaussian kernel density estimator. Evaluate each density over a regular Cartesian grid of size $G \\times G$ that spans the minimum and maximum of the pooled backgrounds on each axis, expanded by a padding margin of $m$ times the pooled background range on each axis. Approximate the resulting continuous densities on the grid by a nonnegative raster that sums to $1$ under a Riemann sum with constant grid-cell area $\\Delta x \\Delta y$.\n\n3) Compute two niche overlap metrics between the two rasterized densities:\n- An $L^{1}$-based overlap that maps the $L^{1}$ distance to the unit interval by subtracting from $1$ after scaling the $L^{1}$ distance by $1/2$.\n- A Hellinger-based overlap that maps the squared Hellinger distance to the unit interval by subtracting from $1$ after scaling the squared Hellinger distance by $1/2$.\nBoth overlap metrics must be in the closed interval $\\left[0,1\\right]$, with $1$ indicating identical rasterized densities and $0$ indicating disjoint support in the discretization.\n\n4) Niche equivalency test for the $L^{1}$-based overlap: Under the null hypothesis that the two occurrence samples are drawn from the same underlying niche, combine occurrences from both ranges, randomly permute labels, and split back into two sets of the original sizes. For each permutation, estimate densities and compute the $L^{1}$-based overlap as in steps $1$–$3$. The one-tailed $p$-value for “less overlap than expected under equivalency” is the fraction of permuted overlaps that are less than or equal to the observed $L^{1}$-based overlap.\n\n5) Background similarity tests for the $L^{1}$-based overlap in both directions to control for background availability and sampling bias: For native-to-invaded, hold the native occurrences fixed and repeatedly draw pseudo-occurrences with replacement from the invaded background with probability proportional to the invaded background weights; for each draw, estimate density and compute the overlap with the fixed native density. The one-tailed $p$-value for “less overlap than expected given invaded background and bias” is the fraction of replicate overlaps less than or equal to the observed $L^{1}$-based overlap. Repeat symmetrically for invaded-to-native using native background and weights while holding invaded occurrences fixed.\n\nImplementation details to be followed exactly:\n- Use a Gaussian kernel density estimator and evaluate on a regular grid. The bandwidth may be selected by a standard rule that depends only on the data (for example, Scott’s rule), but must be deterministic given the input data. The grid-cell area is $\\Delta x \\Delta y$, where $\\Delta x$ and $\\Delta y$ are the constant spacings in $x$ and $y$, respectively, and the raster must be normalized so that the Riemann sum equals $1$.\n- For permutation and background tests, use independent Monte Carlo replicates as specified in the test suite of each case. All random draws must use the specified random seeds.\n- All outputs are dimensionless and must be expressed as decimals.\n\nTest suite. For each case below, construct the data exactly as specified and then compute:\n- The two overlap metrics in the order: $L^{1}$-based overlap, Hellinger-based overlap.\n- The $p$-value for the equivalency test (one-tailed, “less overlap”).\n- The $p$-values for the background similarity tests (one-tailed, “less overlap”) in the two directions: native-to-invaded, invaded-to-native, in that order.\n\nFor all cases, report the five results for that case rounded to exactly $6$ decimal places.\n\nCommon grid parameters for all cases:\n- Grid size $G = 35$.\n- Padding fraction $m = 0.05$.\n- Number of Monte Carlo replicates $R = 49$.\n\nCase A (partial overlap, heterogeneous backgrounds, biased sampling):\n- Random seed $123$ for all random draws in this case.\n- Native occurrences: draw $60$ points independently from a bivariate normal with mean $\\left(0, 0\\right)$ and covariance matrix $$\\begin{bmatrix}1.0  0.3 \\\\ 0.3  1.2\\end{bmatrix}$$.\n- Invaded occurrences: draw $60$ points independently from a bivariate normal with mean $\\left(0.8, 0.6\\right)$ and covariance matrix $$\\begin{bmatrix}1.2  -0.2 \\\\ -0.2  1.0\\end{bmatrix}$$.\n- Native background: draw $500$ points from a mixture, half from a bivariate normal with mean $\\left(0, 0\\right)$ and covariance $\\operatorname{diag}(2.0, 2.0)$ and half from a bivariate normal with mean $\\left(2, -1\\right)$ and covariance $\\operatorname{diag}(1.0, 1.0)$.\n- Invaded background: draw $500$ points from a mixture, half from a bivariate normal with mean $\\left(1, 1\\right)$ and covariance $\\operatorname{diag}(2.0, 1.5)$ and half from a bivariate normal with mean $\\left(-1, 1\\right)$ and covariance $\\operatorname{diag}(1.0, 1.0)$.\n- Native background sampling-bias weights: for a background point $\\left(x, y\\right)$, weight $w = \\exp\\left(0.5 x - 0.3 y\\right)$.\n- Invaded background sampling-bias weights: for a background point $\\left(x, y\\right)$, weight $w = \\exp\\left(-0.4 x + 0.2 y\\right)$.\n\nCase B (identical niches, identical backgrounds, no bias):\n- Random seed $456$ for all random draws in this case.\n- Native occurrences: draw $50$ points from a bivariate normal with mean $\\left(0, 0\\right)$ and covariance $\\operatorname{diag}(1.0, 1.0)$.\n- Invaded occurrences: use the exact same $50$ points as the native occurrences (not redrawn).\n- Native and invaded backgrounds: independently draw $400$ points for each from a bivariate normal with mean $\\left(0, 0\\right)$ and covariance $\\operatorname{diag}(2.0, 2.0)$.\n- Background sampling-bias weights: all ones for both ranges.\n\nCase C (weak overlap with similar broad backgrounds and mild bias):\n- Random seed $789$ for all random draws in this case.\n- Native occurrences: draw $40$ points from a bivariate normal with mean $\\left(-2, -2\\right)$ and covariance $\\operatorname{diag}(0.5, 0.5)$.\n- Invaded occurrences: draw $40$ points from a bivariate normal with mean $\\left(2, 2\\right)$ and covariance $\\operatorname{diag}(0.5, 0.5)$.\n- Native background: draw $500$ points from a mixture with $250$ from a bivariate normal mean $\\left(-2, -2\\right)$ covariance $\\operatorname{diag}(1.5, 1.5)$ and $250$ from mean $\\left(2, 2\\right)$ covariance $\\operatorname{diag}(1.5, 1.5)$.\n- Invaded background: same mixture structure and parameters as the native background, independently drawn.\n- Background sampling-bias weights for both ranges: for a background point $\\left(x, y\\right)$, weight $w = \\exp\\left(0.2 x + 0.2 y\\right)$.\n\nFinal output format:\n- For each case in the order A, B, C, compute the vector of five values: $\\left[\\text{L1-overlap}, \\text{Hellinger-overlap}, p_{\\text{equiv, less}}, p_{\\text{bg native}\\to\\text{invaded, less}}, p_{\\text{bg invaded}\\to\\text{native, less}}\\right]$, each rounded to exactly $6$ decimal places.\n- Your program should produce a single line of output containing a list of these three vectors in order, formatted as a comma-separated list of lists without spaces, for example: $\\left[ [a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],[c_1,c_2,c_3,c_4,c_5] \\right]$ but with no spaces and numeric entries in decimal form rounded as specified.", "solution": "The problem is a well-posed computational task in quantitative ecology, requiring the implementation of a niche comparison framework based on Hutchinson's n-dimensional hypervolume concept. The problem is scientifically grounded, using standard statistical methods such as kernel density estimation (KDE), non-parametric hypothesis testing (permutation and bootstrap-style resampling), and established niche overlap metrics. All required parameters and procedures are specified with sufficient precision to permit a unique, verifiable solution. Therefore, the problem is deemed valid and a complete solution is provided below.\n\nThe solution follows a structured, multi-step process for each test case.\n\n**Step 1: Data Generation and Standardization**\nFirst, for each case ($A$, $B$, or $C$), the point-cloud data are generated according to the specified statistical distributions and parameters, using the designated random seed for reproducibility. This includes native occurrences ($Occ_{nat}$), invaded occurrences ($Occ_{inv}$), native background ($Bg_{nat}$), and invaded background ($Bg_{inv}$). The associated sampling-bias weights for background points are also computed.\n\nAll environmental data must exist in a common, standardized space to be comparable. The two background datasets, $Bg_{nat}$ and $Bg_{inv}$, are pooled to form a combined background $Bg_{pool} = Bg_{nat} \\cup Bg_{inv}$. The mean vector $\\boldsymbol{\\mu}_{pool}$ and the vector of standard deviations $\\boldsymbol{\\sigma}_{pool}$ are computed across $Bg_{pool}$ for each of the two environmental dimensions. If a standard deviation along any dimension is found to be zero, it is replaced by a small constant, $10^{-8}$, to prevent division by zero.\nEvery point $\\mathbf{x} = (x, y)$ in all four datasets ($Occ_{nat}$, $Occ_{inv}$, $Bg_{nat}$, $Bg_{inv}$) is then standardized via the transformation:\n$$\n\\mathbf{x}' = \\left( \\frac{x - \\mu_{pool,x}}{\\sigma_{pool,x}}, \\frac{y - \\mu_{pool,y}}{\\sigma_{pool,y}} \\right)\n$$\nAll subsequent calculations are performed in this standardized environmental space.\n\n**Step 2: Grid Construction and Density Estimation**\nA regular Cartesian grid is constructed over the standardized environmental space. The grid's extent is determined by the range of the pooled background, $Bg_{pool}$. Let the minimum and maximum coordinates of the standardized $Bg_{pool}$ be $(\\min_x, \\min_y)$ and $(\\max_x, \\max_y)$. The range for each axis is $R_x = \\max_x - \\min_x$ and $R_y = \\max_y - \\min_y$. The grid is expanded by a padding margin $m=0.05$ on all sides. The final grid spans from $\\min_x - m \\cdot R_x$ to $\\max_x + m \\cdot R_x$ on the x-axis, and similarly on the y-axis. This domain is discretized into a $G \\times G$ grid, with $G=35$.\n\nThe environmental niche of a species is modeled as a probability density function (PDF). This unknown PDF is estimated from occurrence data using a bivariate Gaussian kernel density estimator (KDE). For a set of $n$ occurrence points $\\{\\mathbf{x}_i\\}_{i=1}^n$, the estimated density at a point $\\mathbf{x}$ is:\n$$\n\\hat{f}(\\mathbf{x}) = \\sum_{i=1}^n K_H(\\mathbf{x} - \\mathbf{x}_i)\n$$\nwhere $K_H$ is the Gaussian kernel with a bandwidth matrix $H$. The bandwidth is determined automatically using Scott's rule, which is a standard, deterministic method based on the data's dimensionality and sample size.\nThis procedure is applied to estimate the native niche density, $\\hat{f}_{nat}(\\mathbf{x})$, from the standardized $Occ_{nat}$ points, and the invaded niche density, $\\hat{f}_{inv}(\\mathbf{x})$, from the standardized $Occ_{inv}$ points. Both continuous densities are then evaluated at each of the $G \\times G$ points on the environmental grid, producing two matrices of raw density values, $Z_{nat}$ and $Z_{inv}$.\n\nThe problem requires normalization such that the Riemann sum of the density over the grid equals $1$. Let $P_{nat}$ be the final normalized raster for the native density. Its values $P_{nat,ij}$ must satisfy $\\sum_{i,j} P_{nat,ij} \\Delta x \\Delta y = 1$, where $\\Delta x$ and $\\Delta y$ are the grid spacings. This is achieved by setting $P_{nat,ij} = Z_{nat,ij} / (\\sum_{k,l} Z_{nat,kl} \\Delta x \\Delta y)$. However, when calculating the overlap metrics, which are themselves integrals (approximated by sums), this $\\Delta x \\Delta y$ factor cancels out. A mathematically equivalent and computationally simpler approach is to create a discrete probability mass function over the grid cells. The raw density values in matrix $Z$ are normalized to sum to $1$:\n$$\np_{nat,ij} = \\frac{Z_{nat,ij}}{\\sum_{k,l} Z_{nat,kl}} \\quad \\text{and} \\quad p_{inv,ij} = \\frac{Z_{inv,ij}}{\\sum_{k,l} Z_{inv,kl}}\n$$\nThese matrices, $p_{nat}$ and $p_{inv}$, are used for all subsequent overlap calculations.\n\n**Step 3: Niche Overlap Metrics**\nTwo metrics are computed to quantify the overlap between the rasterized niche densities, $p_{nat}$ and $p_{inv}$.\n1.  **$L^1$-based Overlap (Schoener's D)**: This metric is derived from the $L^1$ distance between the two discrete distributions.\n    $$\n    d_{L1} = \\sum_{i,j} | p_{nat,ij} - p_{inv,ij} |\n    $$\n    The distance $d_{L1}$ ranges from $0$ to $2$. The overlap metric is defined as:\n    $$\n    O_{L1} = 1 - \\frac{1}{2} d_{L1}\n    $$\n    This value lies in $[0, 1]$, where $1$ means identical distributions and $0$ means no overlap.\n\n2.  **Hellinger-based Overlap (Bhattacharyya Coefficient)**: This metric is based on the squared Hellinger distance.\n    $$\n    d_H^2 = \\sum_{i,j} \\left( \\sqrt{p_{nat,ij}} - \\sqrt{p_{inv,ij}} \\right)^2\n    $$\n    The squared distance $d_H^2$ also ranges from $0$ to $2$. The overlap metric is defined as:\n    $$\n    O_H = 1 - \\frac{1}{2} d_H^2 = \\sum_{i,j} \\sqrt{p_{nat,ij} \\cdot p_{inv,ij}}\n    $$\n    This value also lies in $[0, 1]$ with the same interpretation as $O_{L1}$.\n\nThese two values, $O_{L1,obs}$ and $O_{H,obs}$, represent the observed niche overlap.\n\n**Step 4: Niche Equivalency Test**\nThis test assesses whether the observed niche overlap is significantly different from what would be expected if both sets of occurrences came from the same underlying niche distribution. The null hypothesis is that $Occ_{nat}$ and $Occ_{inv}$ are random samples from a common source.\nA permutation procedure is used with $R=49$ replicates:\n1.  Pool all occurrence points: $Occ_{pool} = Occ_{nat} \\cup Occ_{inv}$.\n2.  Randomly shuffle $Occ_{pool}$ and split it back into two new sets: a pseudo-native set of size $|Occ_{nat}|$ and a pseudo-invaded set of size $|Occ_{inv}|$.\n3.  For each new pair of sets, estimate their respective densities on the same grid and compute the $L^1$-based overlap, $O_{L1,perm}$. This generates a null distribution of $R$ overlap values.\n4.  The one-tailed $p$-value for \"less overlap than expected\" is the proportion of permuted overlaps that are less than or equal to the observed overlap:\n    $$\n    p_{equiv} = \\frac{1}{R} \\sum_{k=1}^R \\mathbb{I}(O_{L1,perm}^{(k)} \\le O_{L1,obs})\n    $$\n    where $\\mathbb{I}(\\cdot)$ is the indicator function.\n\n**Step 5: Background Similarity Tests**\nThese tests evaluate whether the observed niche overlap is constrained by the environmental conditions available in each range.\n1.  **Native-to-Invaded Test**: This tests if the invader's niche is more different from the native's niche than expected, given the environment available in the invaded range.\n    *   The native density $p_{nat}$ is held fixed.\n    *   For $R=49$ replicates, a set of pseudo-invaded occurrences is generated by sampling $|Occ_{inv}|$ points with replacement from the invaded background, $Bg_{inv}$. The sampling probability for each background point is proportional to its weight.\n    *   For each replicate, a density is estimated from the pseudo-invaded set, and the $L^1$-based overlap with the fixed $p_{nat}$ is calculated ($O_{L1,bg,n \\to i}$).\n    *   The $p$-value is the proportion of these replicate overlaps that are less than or equal to the observed overlap $O_{L1,obs}$.\n\n2.  **Invaded-to-Native Test**: This symmetrically tests if the native's niche is more different from the invader's niche than expected, given the environment available in the native range.\n    *   The invaded density $p_{inv}$ is held fixed.\n    *   For $R=49$ replicates, pseudo-native occurrences are sampled from $Bg_{nat}$ with weights.\n    *   The $L^1$-based overlap with the fixed $p_{inv}$ is calculated ($O_{L1,bg,i \\to n}$).\n    *   The $p$-value is calculated analogously.\n\nFor each test case, these five values ($O_{L1,obs}$, $O_{H,obs}$, $p_{equiv}$, $p_{bg,n \\to i}$, $p_{bg,i \\to n}$) are computed, rounded to $6$ decimal places, and reported.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import gaussian_kde\n\n# Common parameters for all cases\nG = 35\nM = 0.05\nR = 49\nSTD_DEV_MIN = 1e-8\n\ndef generate_case_data(case_name, rng):\n    \"\"\"Generates data for a specific case.\"\"\"\n    if case_name == 'A':\n        occ_nat = rng.multivariate_normal([0, 0], [[1.0, 0.3], [0.3, 1.2]], 60)\n        occ_inv = rng.multivariate_normal([0.8, 0.6], [[1.2, -0.2], [-0.2, 1.0]], 60)\n        \n        bg_nat_1 = rng.multivariate_normal([0, 0], [[2.0, 0.0], [0.0, 2.0]], 250)\n        bg_nat_2 = rng.multivariate_normal([2, -1], [[1.0, 0.0], [0.0, 1.0]], 250)\n        bg_nat = np.vstack([bg_nat_1, bg_nat_2])\n        \n        bg_inv_1 = rng.multivariate_normal([1, 1], [[2.0, 0.0], [0.0, 1.5]], 250)\n        bg_inv_2 = rng.multivariate_normal([-1, 1], [[1.0, 0.0], [0.0, 1.0]], 250)\n        bg_inv = np.vstack([bg_inv_1, bg_inv_2])\n        \n        w_nat = np.exp(0.5 * bg_nat[:, 0] - 0.3 * bg_nat[:, 1])\n        w_inv = np.exp(-0.4 * bg_inv[:, 0] + 0.2 * bg_inv[:, 1])\n        return occ_nat, occ_inv, bg_nat, bg_inv, w_nat, w_inv\n\n    if case_name == 'B':\n        occ_nat = rng.multivariate_normal([0, 0], [[1.0, 0.0], [0.0, 1.0]], 50)\n        occ_inv = occ_nat  # Exactly the same points\n        \n        bg_nat = rng.multivariate_normal([0, 0], [[2.0, 0.0], [0.0, 2.0]], 400)\n        bg_inv = rng.multivariate_normal([0, 0], [[2.0, 0.0], [0.0, 2.0]], 400)\n        \n        w_nat = np.ones(bg_nat.shape[0])\n        w_inv = np.ones(bg_inv.shape[0])\n        return occ_nat, occ_inv, bg_nat, bg_inv, w_nat, w_inv\n\n    if case_name == 'C':\n        occ_nat = rng.multivariate_normal([-2, -2], [[0.5, 0.0], [0.0, 0.5]], 40)\n        occ_inv = rng.multivariate_normal([2, 2], [[0.5, 0.0], [0.0, 0.5]], 40)\n        \n        bg_nat_1 = rng.multivariate_normal([-2, -2], [[1.5, 0.0], [0.0, 1.5]], 250)\n        bg_nat_2 = rng.multivariate_normal([2, 2], [[1.5, 0.0], [0.0, 1.5]], 250)\n        bg_nat = np.vstack([bg_nat_1, bg_nat_2])\n        \n        bg_inv_1 = rng.multivariate_normal([-2, -2], [[1.5, 0.0], [0.0, 1.5]], 250)\n        bg_inv_2 = rng.multivariate_normal([2, 2], [[1.5, 0.0], [0.0, 1.5]], 250)\n        bg_inv = np.vstack([bg_inv_1, bg_inv_2])\n\n        w_nat = np.exp(0.2 * bg_nat[:, 0] + 0.2 * bg_nat[:, 1])\n        w_inv = np.exp(0.2 * bg_inv[:, 0] + 0.2 * bg_inv[:, 1])\n        return occ_nat, occ_inv, bg_nat, bg_inv, w_nat, w_inv\n\ndef get_kde_raster(points, grid_coords):\n    \"\"\"Performs KDE and evaluates on a grid, normalizing the resulting raster.\"\"\"\n    if points.shape[1]  2: # handle edge cases with 0 or 1 point\n        z = np.zeros(grid_coords[0].size)\n    else:\n        kde = gaussian_kde(points.T)\n        _grid = np.vstack([grid_coords[0].ravel(), grid_coords[1].ravel()])\n        z = kde.evaluate(_grid)\n    \n    z_sum = np.sum(z)\n    if z_sum  0:\n        return z.reshape(G, G) / z_sum\n    return np.zeros((G, G))\n\ndef calculate_overlaps(p_nat, p_inv):\n    \"\"\"Calculates L1-based and Hellinger-based overlaps.\"\"\"\n    # L1-based overlap (Schoener's D)\n    d_l1 = 0.5 * np.sum(np.abs(p_nat - p_inv))\n    o_l1 = 1 - d_l1\n    \n    # Hellinger-based overlap (Bhattacharyya coefficient)\n    o_h = np.sum(np.sqrt(p_nat * p_inv))\n    \n    return o_l1, o_h\n\ndef solve_case(case_name, seed):\n    \"\"\"Main function to process one test case.\"\"\"\n    rng = np.random.default_rng(seed)\n    occ_nat_orig, occ_inv_orig, bg_nat_orig, bg_inv_orig, w_nat, w_inv = generate_case_data(case_name, rng)\n\n    # 1. Standardization\n    bg_pool = np.vstack([bg_nat_orig, bg_inv_orig])\n    mean_pool = np.mean(bg_pool, axis=0)\n    std_pool = np.std(bg_pool, axis=0)\n    std_pool[std_pool == 0] = STD_DEV_MIN\n\n    occ_nat = (occ_nat_orig - mean_pool) / std_pool\n    occ_inv = (occ_inv_orig - mean_pool) / std_pool\n    bg_nat = (bg_nat_orig - mean_pool) / std_pool\n    bg_inv = (bg_inv_orig - mean_pool) / std_pool\n    \n    # 2. Grid Construction\n    bg_pool_std = (bg_pool - mean_pool) / std_pool\n    min_bg = np.min(bg_pool_std, axis=0)\n    max_bg = np.max(bg_pool_std, axis=0)\n    range_bg = max_bg - min_bg\n    \n    grid_min = min_bg - M * range_bg\n    grid_max = max_bg + M * range_bg\n\n    x_grid = np.linspace(grid_min[0], grid_max[0], G)\n    y_grid = np.linspace(grid_min[1], grid_max[1], G)\n    grid_coords = np.meshgrid(x_grid, y_grid)\n\n    # 3. Observed Overlap\n    p_nat_obs = get_kde_raster(occ_nat, grid_coords)\n    p_inv_obs = get_kde_raster(occ_inv, grid_coords)\n    o_l1_obs, o_h_obs = calculate_overlaps(p_nat_obs, p_inv_obs)\n\n    # 4. Equivalency Test\n    occ_pool = np.vstack([occ_nat, occ_inv])\n    n_nat = occ_nat.shape[0]\n    \n    perm_overlaps = np.zeros(R)\n    for i in range(R):\n        rng.shuffle(occ_pool)\n        perm_occ_nat = occ_pool[:n_nat, :]\n        perm_occ_inv = occ_pool[n_nat:, :]\n        \n        p_nat_perm = get_kde_raster(perm_occ_nat, grid_coords)\n        p_inv_perm = get_kde_raster(perm_occ_inv, grid_coords)\n        \n        o_l1_perm, _ = calculate_overlaps(p_nat_perm, p_inv_perm)\n        perm_overlaps[i] = o_l1_perm\n\n    p_equiv = np.sum(perm_overlaps = o_l1_obs) / R\n\n    # 5. Background Similarity Tests\n    # Native-to-Invaded\n    n_inv = occ_inv.shape[0]\n    p_w_inv = w_inv / np.sum(w_inv)\n    bg_n2i_overlaps = np.zeros(R)\n    for i in range(R):\n        indices = rng.choice(bg_inv.shape[0], size=n_inv, p=p_w_inv)\n        pseudo_occ_inv = bg_inv[indices, :]\n        p_pseudo_inv = get_kde_raster(pseudo_occ_inv, grid_coords)\n        o_l1_bg, _ = calculate_overlaps(p_nat_obs, p_pseudo_inv)\n        bg_n2i_overlaps[i] = o_l1_bg\n    \n    p_bg_n2i = np.sum(bg_n2i_overlaps = o_l1_obs) / R\n\n    # Invaded-to-Native\n    p_w_nat = w_nat / np.sum(w_nat)\n    bg_i2n_overlaps = np.zeros(R)\n    for i in range(R):\n        indices = rng.choice(bg_nat.shape[0], size=n_nat, p=p_w_nat)\n        pseudo_occ_nat = bg_nat[indices, :]\n        p_pseudo_nat = get_kde_raster(pseudo_occ_nat, grid_coords)\n        o_l1_bg, _ = calculate_overlaps(p_inv_obs, p_pseudo_nat)\n        bg_i2n_overlaps[i] = o_l1_bg\n    \n    p_bg_i2n = np.sum(bg_i2n_overlaps = o_l1_obs) / R\n    \n    return [\n        round(o_l1_obs, 6),\n        round(o_h_obs, 6),\n        round(p_equiv, 6),\n        round(p_bg_n2i, 6),\n        round(p_bg_i2n, 6)\n    ]\n\ndef solve():\n    test_cases = [\n        ('A', 123),\n        ('B', 456),\n        ('C', 789)\n    ]\n\n    results = []\n    for case_name, seed in test_cases:\n        result_vector = solve_case(case_name, seed)\n        results.append(result_vector)\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{','.join(map(str, res))}]\" for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2535013"}, {"introduction": "This final practice bridges ecology and evolution, demonstrating how niche-based competition can be a powerful engine for speciation. Using the framework of adaptive dynamics, you will analyze a model where competition for resources along a continuous axis generates frequency-dependent selection [@problem_id:2535009]. Your task is to derive the mathematical condition for disruptive selection and determine when it is strong enough to overcome the homogenizing effects of recombination, leading to an evolutionary bifurcation and the emergence of two new, specialized lineages.", "problem": "You will formalize a one-dimensional adaptive dynamics model for a sexually reproducing consumer population exploiting a continuous resource axis. The ecological mechanism is Gaussian competition along a resource axis and a Gaussian carrying capacity (resource productivity) profile; mating is assortative such that sexual reproduction homogenizes trait differences at an effective rate. Your task is to derive, implement, and evaluate the linearized divergence criterion near the singular strategy, and then determine whether the ecological disruptive selection can overcome homogenization to yield a bifurcation into two diverging phenotypic clusters that correspond to incipient species occupying distinct niches.\n\nStart from the following fundamental base:\n- Logistic ecological dynamics with frequency-dependent competition. For a monomorphic resident with trait value $x$, its ecological equilibrium abundance equals the carrying capacity at $x$ due to self-limitation.\n- Invasion fitness of a rare mutant with trait value $y$ in a resident environment at equilibrium is its per-capita growth rate when rare.\n- Gaussian functions for carrying capacity and competition are widely used and empirically grounded approximations to resource limitation and niche overlap along a continuous niche axis.\n\nModel ingredients and definitions:\n- Let the one-dimensional trait be $z \\in \\mathbb{R}$, representing resource-use phenotype on a continuous axis.\n- The carrying capacity as a function of $z$ is $K(z) = K_{0} \\exp\\!\\left( - \\dfrac{(z - \\theta)^{2}}{2 \\sigma_{K}^{2}} \\right)$, where $\\sigma_{K}  0$ is the width of the resource profile and $\\theta$ is its peak. Without loss of generality, set $\\theta = 0$.\n- The symmetric Gaussian competition kernel is $\\alpha(z, z') = \\exp\\!\\left( - \\dfrac{(z - z')^{2}}{2 \\sigma_{\\alpha}^{2}} \\right)$, where $\\sigma_{\\alpha}  0$ is the niche-overlap scale.\n- Consider logistic growth with intrinsic rate $r  0$. The invasion fitness of a rare mutant $y$ in a resident $x$ at the resident’s monomorphic equilibrium is\n  $$ s(y, x) = r \\left( 1 - \\dfrac{\\alpha(y, x) \\, K(x)}{K(y)} \\right). $$\n- Under adaptive dynamics, the selection gradient at $x$ is the partial derivative $\\left. \\dfrac{\\partial s(y, x)}{\\partial y} \\right|_{y = x}$, which points toward the singular strategy $x^{\\ast} = 0$ in this model.\n- The local curvature of invasion fitness with respect to the mutant trait at the singular strategy controls whether selection is stabilizing or disruptive. Define\n  $$ s'' \\equiv \\left. \\dfrac{\\partial^{2} s(y, x)}{\\partial y^{2}} \\right|_{y = x = 0}. $$\n- Sexual reproduction with assortative mating homogenizes phenotypic differences. Let $h \\ge 0$ denote the effective per-time homogenization rate induced by mating and recombination at very small trait separation. Smaller $h$ corresponds to stronger assortative mating (less homogenization); larger $h$ corresponds to weaker assortative mating (more homogenization, approaching random mating).\n- Consider two subclusters located at $\\pm d/2$ with small separation $d$. Linearize their separation dynamics. The leading-order coefficient (per-unit separation) governing divergence versus merger is\n  $$ \\lambda = s'' - h. $$\n  If $\\lambda  0$ then disruptive selection dominates homogenization and a pitchfork-type bifurcation into two diverging clusters is initiated (incipient sympatric speciation). If $\\lambda \\le 0$ then homogenization dominates and the system remains unimodal.\n\nYour tasks:\n1. From the model definitions and fundamental principles above, derive an explicit formula for $s''$ in terms of $r$, $\\sigma_{K}$, and $\\sigma_{\\alpha}$.\n2. Using that formula and the definition of $\\lambda$, implement a program that, for each test case, computes $\\lambda$ and reports it as a float rounded to six decimal places.\n3. The role of assortative mating strength must be made explicit by the sign of $\\lambda$: interpret $h$ as the effective homogenization rate due to mating. Stronger assortative mating corresponds to smaller $h$, which increases $\\lambda$ and promotes bifurcation; weaker assortative mating corresponds to larger $h$, which decreases $\\lambda$ and inhibits bifurcation.\n\nTest suite:\nFor each tuple $(r, \\sigma_{K}, \\sigma_{\\alpha}, h)$ below, compute $\\lambda$ as specified.\n- Case A (baseline disruptive selection, weak homogenization): $(r, \\sigma_{K}, \\sigma_{\\alpha}, h) = (1.0, 1.2, 0.8, 0.1)$.\n- Case B (same ecology as A, strong homogenization): $(r, \\sigma_{K}, \\sigma_{\\alpha}, h) = (1.0, 1.2, 0.8, 1.0)$.\n- Case C (boundary of ecological disruptiveness): $(r, \\sigma_{K}, \\sigma_{\\alpha}, h) = (1.0, 1.0, 1.0, 0.0)$.\n- Case D (no ecological disruptiveness): $(r, \\sigma_{K}, \\sigma_{\\alpha}, h) = (1.0, 0.7, 1.1, 0.0)$.\n- Case E (broad resource, narrow competition, low intrinsic growth, modest homogenization): $(r, \\sigma_{K}, \\sigma_{\\alpha}, h) = (0.05, 2.0, 0.5, 0.02)$.\n- Case F (exact balance between disruptiveness and homogenization): $(r, \\sigma_{K}, \\sigma_{\\alpha}, h) = (0.5, 1.0, 0.5, 1.5)$.\n\nOutput specification:\n- For the given ordered test suite [A, B, C, D, E, F], output a single line containing a Python-style list of the computed $\\lambda$ values, each rounded to six decimal places, with no additional text. For example, the format should be like $[\\lambda_{A}, \\lambda_{B}, \\lambda_{C}, \\lambda_{D}, \\lambda_{E}, \\lambda_{F}]$.\n- No physical units or angles are involved; the output is dimensionless. Each reported value must be a decimal (float).", "solution": "The problem as stated is scientifically grounded, mathematically well-posed, and internally consistent. It represents a standard, canonical model in the field of adaptive dynamics for studying sympatric speciation. The definitions are precise, and the objectives are clear. We shall proceed with the derivation and solution.\n\nThe primary task is to derive the criterion for evolutionary branching, $\\lambda$, which determines whether a unimodal population distribution at a singular strategy is evolutionarily stable or will bifurcate into two distinct phenotypic clusters. This criterion depends on the balance between ecological disruptive selection and the homogenizing effect of sexual reproduction.\n\n**1. Derivation of the Ecological Curvature of Selection ($s''$)**\n\nThe analysis centers on the invasion fitness $s(y, x)$ of a rare mutant with phenotype $y$ in a monomorphic resident population of phenotype $x$ at its ecological equilibrium. The fitness function is given as:\n$$\ns(y, x) = r \\left( 1 - \\dfrac{\\alpha(y, x) \\, K(x)}{K(y)} \\right)\n$$\nwhere $r  0$ is the intrinsic rate of increase. The carrying capacity $K(z)$ and competition kernel $\\alpha(z, z')$ are Gaussian functions:\n$$\nK(z) = K_{0} \\exp\\!\\left( - \\dfrac{z^{2}}{2 \\sigma_{K}^{2}} \\right)\n$$\n$$\n\\alpha(z, z') = \\exp\\!\\left( - \\dfrac{(z - z')^{2}}{2 \\sigma_{\\alpha}^{2}} \\right)\n$$\nThe problem asks for the second partial derivative of the invasion fitness with respect to the mutant trait $y$, evaluated at the singular strategy $x=x^*=0$ and $y=x=0$. This quantity is denoted $s''$:\n$$\ns'' \\equiv \\left. \\dfrac{\\partial^{2} s(y, x)}{\\partial y^{2}} \\right|_{y = x = 0}\n$$\nTo compute this, we first find the partial derivatives of $s(y,x)$ with respect to $y$. It is convenient to analyze the term $F(y,x) = \\dfrac{\\alpha(y, x)}{K(y)}$.\n$$\ns(y,x) = r(1 - F(y,x)K(x))\n$$\nThus,\n$$\n\\dfrac{\\partial^{2} s(y, x)}{\\partial y^{2}} = -r K(x) \\dfrac{\\partial^{2} F(y, x)}{\\partial y^{2}}\n$$\nLet us express $F(y,x)$ explicitly:\n$$\nF(y,x) = \\dfrac{\\exp\\!\\left( - \\dfrac{(y - x)^{2}}{2 \\sigma_{\\alpha}^{2}} \\right)}{K_{0} \\exp\\!\\left( - \\dfrac{y^{2}}{2 \\sigma_{K}^{2}} \\right)} = \\dfrac{1}{K_0} \\exp\\left( \\dfrac{y^2}{2\\sigma_K^2} - \\dfrac{(y-x)^2}{2\\sigma_\\alpha^2} \\right)\n$$\nThe first partial derivative with respect to $y$ is:\n$$\n\\dfrac{\\partial F(y,x)}{\\partial y} = F(y,x) \\left( \\dfrac{2y}{2\\sigma_K^2} - \\dfrac{2(y-x)}{2\\sigma_\\alpha^2} \\right) = F(y,x) \\left( \\dfrac{y}{\\sigma_K^2} - \\dfrac{y-x}{\\sigma_\\alpha^2} \\right)\n$$\nThe second partial derivative, using the product rule, is:\n$$\n\\dfrac{\\partial^{2} F(y,x)}{\\partial y^{2}} = \\dfrac{\\partial F}{\\partial y} \\left( \\dfrac{y}{\\sigma_K^2} - \\dfrac{y-x}{\\sigma_\\alpha^2} \\right) + F(y,x) \\left( \\dfrac{1}{\\sigma_K^2} - \\dfrac{1}{\\sigma_\\alpha^2} \\right)\n$$\n$$\n\\dfrac{\\partial^{2} F(y,x)}{\\partial y^{2}} = F(y,x) \\left( \\dfrac{y}{\\sigma_K^2} - \\dfrac{y-x}{\\sigma_\\alpha^2} \\right)^2 + F(y,x) \\left( \\dfrac{1}{\\sigma_K^2} - \\dfrac{1}{\\sigma_\\alpha^2} \\right)\n$$\nWe must evaluate this at the singular strategy, which is given as $x^*=0$. We therefore set $x=0$ and $y=0$.\nAt $y=x=0$:\n- The term $\\left( \\dfrac{y}{\\sigma_K^2} - \\dfrac{y-x}{\\sigma_\\alpha^2} \\right)$ evaluates to $0$.\n- The function $F(y,x)$ evaluates to $F(0,0) = \\dfrac{\\alpha(0,0)}{K(0)} = \\dfrac{1}{K_0}$.\n\nSubstituting these into the expression for the second derivative of $F$:\n$$\n\\left. \\dfrac{\\partial^{2} F(y,x)}{\\partial y^{2}} \\right|_{y=x=0} = \\dfrac{1}{K_0} (0)^2 + \\dfrac{1}{K_0} \\left( \\dfrac{1}{\\sigma_K^2} - \\dfrac{1}{\\sigma_\\alpha^2} \\right) = \\dfrac{1}{K_0} \\left( \\dfrac{1}{\\sigma_K^2} - \\dfrac{1}{\\sigma_\\alpha^2} \\right)\n$$\nNow we can compute $s''$. At $x=0$, $K(x) = K(0) = K_0$.\n$$\ns'' = -r K(0) \\left. \\dfrac{\\partial^{2} F(y,x)}{\\partial y^{2}} \\right|_{y=x=0} = -r K_0 \\left[ \\dfrac{1}{K_0} \\left( \\dfrac{1}{\\sigma_K^2} - \\dfrac{1}{\\sigma_\\alpha^2} \\right) \\right]\n$$\nThis simplifies to the final expression for the curvature of the fitness landscape:\n$$\ns'' = -r \\left( \\dfrac{1}{\\sigma_{K}^{2}} - \\dfrac{1}{\\sigma_{\\alpha}^{2}} \\right) = r \\left( \\dfrac{1}{\\sigma_{\\alpha}^{2}} - \\dfrac{1}{\\sigma_{K}^{2}} \\right)\n$$\n\n**2. The Divergence Criterion and its Interpretation**\n\nThe term $s''$ quantifies the strength of frequency-dependent disruptive selection at the singular strategy.\n- If $s''  0$, selection is disruptive. This occurs if and only if $1/\\sigma_\\alpha^2  1/\\sigma_K^2$, which is equivalent to $\\sigma_K  \\sigma_\\alpha$. This condition means that the width of the resource distribution (niche availability) is greater than the width of the competition kernel (niche overlap). Individuals at the phenotypic center face more intense competition than individuals at the periphery, which selects for divergence.\n- If $s'' \\le 0$, selection is stabilizing or neutral, which occurs when $\\sigma_K \\le \\sigma_\\alpha$.\n\nSexual reproduction and recombination act as a cohesive force, counteracting divergence. This is modeled by the homogenization rate $h \\ge 0$. The overall tendency for two incipient clusters to diverge or merge is given by the linearized divergence rate $\\lambda$:\n$$\n\\lambda = s'' - h\n$$\nSubstituting our derived expression for $s''$:\n$$\n\\lambda = r \\left( \\dfrac{1}{\\sigma_{\\alpha}^{2}} - \\dfrac{1}{\\sigma_{K}^{2}} \\right) - h\n$$\nThe biological interpretation is as follows:\n- If $\\lambda  0$, the disruptive force from ecological competition is stronger than the homogenizing force from mating. The monomorphic population is evolutionarily unstable, and a bifurcation occurs, leading to two diverging phenotypic clusters (incipient sympatric speciation).\n- If $\\lambda \\le 0$, the homogenizing force is strong enough to overwhelm any disruptive selection. The population remains unimodal, and evolutionary branching is prevented.\n\n**3. Implementation and Evaluation for Test Cases**\n\nThe derived formula for $\\lambda$ is implemented in a program to evaluate the given test cases. For each provided tuple of parameters $(r, \\sigma_K, \\sigma_\\alpha, h)$, the program calculates $\\lambda$ and rounds the result to six decimal places. The code automates this calculation, providing a quantitative assessment of the speciation potential under different ecological and mating scenarios. The results from this computation will be formatted into a single list as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the divergence criterion lambda for a series of test cases based on an\n    adaptive dynamics model of sympatric speciation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (r, sigma_K, sigma_alpha, h)\n    test_cases = [\n        (1.0, 1.2, 0.8, 0.1),    # Case A\n        (1.0, 1.2, 0.8, 1.0),    # Case B\n        (1.0, 1.0, 1.0, 0.0),    # Case C\n        (1.0, 0.7, 1.1, 0.0),    # Case D\n        (0.05, 2.0, 0.5, 0.02),  # Case E\n        (0.5, 1.0, 0.5, 1.5),    # Case F\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for clarity\n        r, sigma_k, sigma_alpha, h = case\n\n        # Calculate the curvature of invasion fitness, s''\n        # s_double_prime = r * (1/sigma_alpha^2 - 1/sigma_k^2)\n        # Using np.power for robust calculation, though **2 is fine.\n        s_double_prime = r * (1 / np.power(sigma_alpha, 2) - 1 / np.power(sigma_k, 2))\n\n        # Calculate the divergence criterion lambda\n        # lambda = s'' - h\n        lambda_val = s_double_prime - h\n\n        # Round the result to six decimal places as specified\n        rounded_lambda = round(lambda_val, 6)\n        \n        # Ensure that -0.0 is represented as 0.0\n        if rounded_lambda == -0.0:\n            rounded_lambda = 0.0\n\n        results.append(rounded_lambda)\n\n    # Format the results into the exact specified string format.\n    # Using map(str, ...) handles float-to-string conversion correctly.\n    output_string = f\"[{','.join(map(str, results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_string)\n\nsolve()\n```", "id": "2535009"}]}