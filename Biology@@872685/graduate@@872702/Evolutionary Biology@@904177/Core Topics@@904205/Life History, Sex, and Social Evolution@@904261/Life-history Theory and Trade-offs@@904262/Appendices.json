{"hands_on_practices": [{"introduction": "While the net reproductive rate, $R_0$, tells us if a population can replace itself over a generation, it is insensitive to the timing of reproduction. This exercise demonstrates the superior utility of the intrinsic rate of increase, $r$, as a fitness metric by comparing life-history schedules that are identical in total offspring but differ in their timing. By numerically solving the Euler-Lotka equation, you will directly quantify why selection often favors earlier reproduction, a cornerstone concept of life-history theory [@problem_id:2728454].", "problem": "You will implement and apply a numerical method to compare intrinsic rates of increase for pairs of life-history schedules that share the same net reproductive rate. Work in a discrete, female-only, age-structured setting with one-year age classes. Let $x \\in \\{0,1,2,\\dots,\\omega\\}$ denote age in years, let $s_x$ denote the probability of surviving from age $x$ to age $x+1$, and define survivorship $l_x$ by $l_0 = 1$ and $l_{x+1} = l_x s_x$. Let $m_x$ denote the expected number of female offspring produced at exact age $x$ by a female who is alive at age $x$. The net reproductive rate (NRR), $R_0$, is defined as $R_0 = \\sum_{x=0}^{\\omega} l_x m_x$. The intrinsic rate of increase $r$ (in per year) is defined as the unique real number solving the Euler–Lotka balance for discrete ages with continuous-time exponential growth,\n$$\n\\sum_{x=0}^{\\omega} l_x m_x e^{-r x} = 1,\n$$\nwith $x$ measured in years and $r$ in per year.\n\nFor each test case below, two schedules are specified by a common survival profile $\\{s_x\\}_{x=0}^{\\omega-1}$, a common target $R_0$, and two disjoint sets of reproductive ages: an “early” schedule $E$ and a “late” schedule $L$. For each schedule $S \\in \\{E,L\\}$, define $m_x^{(S)}$ to be equal across the ages $x \\in S$ and zero elsewhere, with the common value chosen so that $\\sum_{x \\in S} l_x m_x^{(S)} = R_0$. That is, for $S \\in \\{E,L\\}$ and $x \\in S$,\n$$\nm_x^{(S)} = \\frac{R_0}{\\sum_{a \\in S} l_a},\n$$\nand $m_x^{(S)} = 0$ for $x \\notin S$.\n\nTasks:\n- For each test case, compute $l_x$ from $s_x$, construct $m_x^{(E)}$ and $m_x^{(L)}$ as above, then compute $r_E$ and $r_L$ by solving the Euler–Lotka equation for each schedule.\n- Report $r_E$ and $r_L$ in per year, rounded to six decimal places.\n- Also report an indicator, rounded to an integer, equal to $1$ if $r_E  r_L$ and $0$ otherwise.\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, each inner list being [$r_E$, $r_L$, indicator]. For example, a two-case output should look like $[[0.123456,0.012345,1],[0.000000,0.000000,0]]$.\n\nUse the following test suite. In each case, $s_x$ is given for $x \\in \\{0,\\dots,\\omega-1\\}$ as an ordered list, ages are in years, and $R_0$ is dimensionless:\n- Case A:\n  - $s_x = [\\,0.7,\\,0.8,\\,0.8,\\,0.75\\,]$ (so $\\omega = 4$ and ages run $0$ through $4$).\n  - $R_0 = 1.6$.\n  - $E = \\{\\,1,\\,2\\,\\}$ and $L = \\{\\,3,\\,4\\,\\}$.\n- Case B:\n  - $s_x = [\\,0.4,\\,0.9,\\,0.95,\\,0.95\\,]$.\n  - $R_0 = 1.2$.\n  - $E = \\{\\,1\\,\\}$ and $L = \\{\\,4\\,\\}$.\n- Case C:\n  - $s_x = [\\,0.95,\\,0.95,\\,0.95,\\,0.95,\\,0.95,\\,0.95,\\,0.95,\\,0.95,\\,0.95\\,]$ (so $\\omega = 9$ and ages run $0$ through $9$).\n  - $R_0 = 1.05$.\n  - $E = \\{\\,2,\\,3\\,\\}$ and $L = \\{\\,8,\\,9\\,\\}$.\n- Case D (boundary condition):\n  - $s_x = [\\,0.5,\\,0.9,\\,0.9\\,]$.\n  - $R_0 = 1.0$.\n  - $E = \\{\\,1,\\,2\\,\\}$ and $L = \\{\\,3\\,\\}$.\n\nAngle units are not applicable. All reported $r$ values must be expressed in per year and rounded to six decimal places as specified. The final one-line output must be the list of four inner lists in the exact order A, B, C, D as described above.", "solution": "The problem statement has been critically evaluated and is deemed valid. It is scientifically grounded in the established principles of demographic theory, specifically life-history theory using age-structured models. The problem is well-posed, providing sufficient and consistent information to determine a unique solution for each case. The definitions of survivorship ($l_x$), fecundity ($m_x$), net reproductive rate ($R_0$), and the intrinsic rate of increase ($r$) via the discrete-time Euler-Lotka equation are standard and mathematically sound. The problem is objective and free from ambiguity. We may therefore proceed with a rigorous analytical solution.\n\nThe core of the problem is to find the intrinsic rate of increase, $r$, which is the unique real root of the Euler-Lotka equation:\n$$\n\\sum_{x=0}^{\\omega} l_x m_x e^{-r x} = 1\n$$\nThis must be done for two distinct reproductive schedules, an \"early\" schedule $E$ and a \"late\" schedule $L$, under the constraint that both yield the same net reproductive rate, $R_0$.\n\nThe solution procedure is executed for each test case as follows:\n\n1.  **Computation of the Survivorship Schedule ($l_x$)**:\n    The survivorship schedule, $\\{l_x\\}$, which represents the probability of survival from birth (age $0$) to the beginning of age class $x$, is computed from the provided age-specific survival probabilities, $\\{s_x\\}$. We begin with the axiom that survivorship to age $0$ is certain, thus $l_0 = 1$. For all subsequent ages $x \\in \\{0, 1, \\dots, \\omega-1\\}$, the survivorship is calculated via the recurrence relation:\n    $$\n    l_{x+1} = l_x s_x\n    $$\n    This generates a complete vector of survivorship values from age $0$ to the maximum age $\\omega$.\n\n2.  **Construction of Fecundity Schedules ($m_x^{(S)}$)**:\n    For each reproductive schedule $S \\in \\{E, L\\}$, the fecundity $m_x^{(S)}$ is defined to be a constant value, let us call it $m_S$, for all ages $x \\in S$, and zero for all ages $x \\notin S$. This constant $m_S$ is determined by the constraint that the net reproductive rate, $R_0$, must be achieved. The definition of $R_0$ is $\\sum_{x=0}^{\\omega} l_x m_x$. For schedule $S$, this becomes:\n    $$\n    R_0 = \\sum_{x \\in S} l_x m_S = m_S \\sum_{x \\in S} l_x\n    $$\n    From this, we solve for the constant fecundity value:\n    $$\n    m_S = \\frac{R_0}{\\sum_{a \\in S} l_a}\n    $$\n    This formulation is applied separately to the early age set $E$ and the late age set $L$ to construct the two respective fecundity schedules, $\\{m_x^{(E)}\\}$ and $\\{m_x^{(L)}\\}$.\n\n3.  **Solving for the Intrinsic Rate of Increase ($r$)**:\n    With the survivorship ($l_x$) and fecundity ($m_x^{(S)}$) schedules established, we must solve the Euler-Lotka equation for the intrinsic rate of increase, $r_S$. Substituting the expression for $m_x^{(S)}$ into the equation gives:\n    $$\n    \\sum_{x \\in S} l_x \\left( \\frac{R_0}{\\sum_{a \\in S} l_a} \\right) e^{-r_S x} = 1\n    $$\n    Rearranging, the problem becomes finding the root $r_S$ of the function $g_S(r)$:\n    $$\n    g_S(r) = R_0 \\sum_{x \\in S} l_x e^{-r x} - \\sum_{a \\in S} l_a = 0\n    $$\n    The function $g_S(r)$ is monotonically decreasing with respect to $r$ because its derivative, $g_S'(r) = -R_0 \\sum_{x \\in S} x l_x e^{-r x}$, is strictly negative for any non-trivial schedule. This monotonicity guarantees a unique real root.\n    We note that $g_S(0) = R_0 \\sum_{x \\in S} l_x - \\sum_{a \\in S} l_a = (R_0 - 1) \\sum_{a \\in S} l_a$.\n    -   If $R_0  1$, then $g_S(0)  0$. As $r \\to \\infty$, $g_S(r) \\to -\\sum l_a  0$. Thus, a unique positive root $r_S$ exists.\n    -   If $R_0  1$, then $g_S(0)  0$. As $r \\to -\\infty$, $g_S(r) \\to \\infty$. Thus, a unique negative root $r_S$ exists.\n    -   If $R_0 = 1$, then $g_S(0) = 0$, which immediately yields the solution $r_S = 0$.\n\n    For the cases where $R_0 \\neq 1$, a numerical root-finding algorithm is required. The bisection method, or more efficiently, Brent's method, is suitable for finding the root of this well-behaved monotonic function within a specified bracket. The analysis of $g_S(0)$ informs the selection of an appropriate search interval, such as $[0, A]$ for $R_0  1$ and $[-A, 0]$ for $R_0  1$, where $A$ is a sufficiently large positive constant.\n\n4.  **Final Comparison and Reporting**:\n    After computing $r_E$ and $r_L$ for each test case, the values are compared. An indicator variable is set to $1$ if $r_E  r_L$ and $0$ otherwise. The values of $r_E$ and $r_L$ are rounded to six decimal places, and the results are compiled into the specified list-of-lists format for output. This procedure is repeated for all provided test cases.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Implements and applies a numerical method to compare intrinsic rates of increase \n    for pairs of life-history schedules sharing the same net reproductive rate.\n    \"\"\"\n    test_cases = [\n        {\n            # Case A\n            \"s_x\": [0.7, 0.8, 0.8, 0.75],\n            \"R0\": 1.6,\n            \"E\": {1, 2},\n            \"L\": {3, 4}\n        },\n        {\n            # Case B\n            \"s_x\": [0.4, 0.9, 0.95, 0.95],\n            \"R0\": 1.2,\n            \"E\": {1},\n            \"L\": {4}\n        },\n        {\n            # Case C\n            \"s_x\": [0.95] * 9,\n            \"R0\": 1.05,\n            \"E\": {2, 3},\n            \"L\": {8, 9}\n        },\n        {\n            # Case D (boundary condition)\n            \"s_x\": [0.5, 0.9, 0.9],\n            \"R0\": 1.0,\n            \"E\": {1, 2},\n            \"L\": {3}\n        }\n    ]\n\n    # This list will store the string-formatted result for each case\n    all_results_str = []\n\n    for case in test_cases:\n        s_x_list = case[\"s_x\"]\n        R0 = case[\"R0\"]\n        E = case[\"E\"]\n        L = case[\"L\"]\n        \n        omega = len(s_x_list)\n        s_x = np.array(s_x_list)\n        \n        # 1. Compute survivorship schedule l_x\n        l_x = np.zeros(omega + 1)\n        l_x[0] = 1.0\n        for x in range(omega):\n            l_x[x+1] = l_x[x] * s_x[x]\n\n        def calculate_r(schedule_ages, R0_val, lx_vals):\n            \"\"\"\n            Calculates the intrinsic rate of increase 'r' for a given schedule.\n            \n            Args:\n                schedule_ages (set): The set of ages for reproduction.\n                R0_val (float): The net reproductive rate.\n                lx_vals (np.ndarray): The survivorship schedule.\n\n            Returns:\n                float: The intrinsic rate of increase, r.\n            \"\"\"\n            # Handle boundary case where R_0 = 1, which implies r = 0\n            if np.isclose(R0_val, 1.0):\n                return 0.0\n\n            ages = np.array(list(schedule_ages))\n            sum_l = np.sum(lx_vals[ages])\n\n            # Define the function whose root we need to find, based on the Euler-Lotka equation:\n            # g(r) = R0 * sum(l_x * exp(-r*x)) - sum(l_x) = 0\n            def euler_lotka_func(r):\n                return R0_val * np.sum(lx_vals[ages] * np.exp(-r * ages)) - sum_l\n\n            # Find the root numerically using Brent's method\n            # The search interval is determined by whether R0  1 (r  0) or R0  1 (r  0)\n            if R0_val  1.0:\n                # For R0  1, r is positive. g(0) is positive, and g(r) decreases.\n                # A sufficiently large upper bound ensures the function becomes negative.\n                bracket = [0.0, 10.0]\n            else: # R0_val  1.0\n                # For R0  1, r is negative. g(0) is negative, and g(r) increases as r becomes more negative.\n                bracket = [-10.0, 0.0]\n            \n            try:\n                # Use a tight tolerance for high accuracy before rounding\n                r_val = brentq(euler_lotka_func, bracket[0], bracket[1], xtol=1e-12, rtol=1e-12)\n            except ValueError:\n                # This should not happen for a valid problem setup\n                r_val = np.nan\n                \n            return r_val\n\n        # 2. Compute r_E and r_L for the early and late schedules\n        r_E = calculate_r(E, R0, l_x)\n        r_L = calculate_r(L, R0, l_x)\n        \n        # 3. Compute the indicator\n        # Note: Direct comparison is safe here as we are not checking for equality\n        indicator = 1 if r_E  r_L else 0\n        \n        # 4. Format results as a string and append to the list\n        case_result_str = f\"[{r_E:.6f},{r_L:.6f},{indicator}]\"\n        all_results_str.append(case_result_str)\n\n    # 5. Print the final combined output in the specified single-line format\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2728454"}, {"introduction": "Understanding which vital rates most influence population growth is crucial for predicting evolutionary trajectories. This practice introduces elasticity analysis, a form of perturbation analysis that reveals the proportional sensitivity of the population growth rate, $\\lambda$, to changes in specific life-history parameters [@problem_id:2728457]. By calculating and comparing the elasticities of different vital rates, you will learn how to identify the primary targets of selection in different life-history strategies, connecting demographic models directly to evolutionary prediction.", "problem": "Consider a stage-structured population with three discrete stages: juveniles ($1$), subadults ($2$), and adults ($3$). Dynamics at low density are assumed to be density independent, so the long-term per-capita growth rate (fitness proxy) is given by the dominant eigenvalue $\\,\\lambda\\,$ of the stage-structured population projection matrix. Vital rates are parameterized as follows: juveniles can remain juveniles with probability $g_{1}$ or mature to subadults with probability $m_{1}$ in one time step; subadults can remain subadults with probability $g_{2}$ or mature to adults with probability $m_{2}$; adults survive and remain adults with probability $g_{3}$; adults produce $F$ newborns that enter the juvenile stage.\n\nTwo life histories differ in juvenile survival and adult fecundity, while retaining identical subadult and adult transitions:\n- Life history $1$: $g_{1} = 0.05$, $m_{1} = 0.30$, $g_{2} = 0.30$, $m_{2} = 0.50$, $g_{3} = 0.60$, $F = 6$.\n- Life history $2$: $g_{1} = 0.40$, $m_{1} = 0.30$, $g_{2} = 0.30$, $m_{2} = 0.50$, $g_{3} = 0.60$, $F = 2$.\n\nThus, the population projection matrices are\n$$\n\\mathbf{A}_{1} \\;=\\; \n\\begin{pmatrix}\n0.05  0  6 \\\\\n0.30  0.30  0 \\\\\n0  0.50  0.60\n\\end{pmatrix},\n\\qquad\n\\mathbf{A}_{2} \\;=\\; \n\\begin{pmatrix}\n0.40  0  2 \\\\\n0.30  0.30  0 \\\\\n0  0.50  0.60\n\\end{pmatrix}.\n$$\n\nStarting from core definitions in structured population theory, do the following for each life history:\n1. Compute the dominant eigenvalue $\\,\\lambda\\,$ and the associated right eigenvector $\\,\\mathbf{w}\\,$ (stable stage distribution) and left eigenvector $\\,\\mathbf{v}\\,$ (reproductive value vector), normalized only insofar as needed to evaluate sensitivities.\n2. Using the formal definition of elasticity as a proportional sensitivity of $\\,\\lambda\\,$ to proportional changes in a vital rate (matrix element), compute the elasticities of $\\,\\lambda\\,$ to adult fecundity $F$ (i.e., the element $a_{13}$) and to juvenile stasis $g_{1}$ (i.e., the element $a_{11}$). Denote these $e_{F}$ and $e_{g_{1}}$ for each life history.\n3. Based on the elasticities, predict which vital rate change (a small proportional increase in $F$ versus a small proportional increase in $g_{1}$) would be most strongly favored by selection at low density for each life history, under the standard assumption that selection increases $\\,\\lambda\\,$ most rapidly along the direction of greatest elasticity when costs are measured on a proportional scale.\n\nFinally, report the single numerical value\n$$\nR \\;=\\; \\frac{e_{F}^{(1)}}{e_{g_{1}}^{(1)}},\n$$\nwhere the superscript $(1)$ denotes Life history $1$. Round your reported value of $R$ to four significant figures. Express the final answer as a pure number with no units.", "solution": "The problem requires an analysis of two life histories using stage-structured population projection matrices. The core of this analysis relies on the properties of eigenvalues and eigenvectors of these matrices.\n\nLet $\\mathbf{A}$ be a population projection matrix where the element $a_{ij}$ represents the per-capita contribution of individuals in stage $j$ to stage $i$ in one time step. The long-term, density-independent population dynamics are described by the dominant eigenvalue $\\lambda$ and its corresponding right and left eigenvectors, $\\mathbf{w}$ and $\\mathbf{v}$.\n$$ \\mathbf{A} \\mathbf{w} = \\lambda \\mathbf{w} \\quad \\text{and} \\quad \\mathbf{v}^T \\mathbf{A} = \\lambda \\mathbf{v}^T $$\nHere, $\\lambda$ is the asymptotic population growth rate, $\\mathbf{w}$ is the stable stage distribution (the proportional abundance of individuals in each stage), and $\\mathbf{v}$ is the reproductive value vector (the relative contribution of an individual in each stage to future population growth).\n\nThe sensitivity of the population growth rate $\\lambda$ to a change in a matrix element $a_{ij}$ is given by\n$$ s_{ij} = \\frac{\\partial \\lambda}{\\partial a_{ij}} = \\frac{v_i w_j}{\\langle \\mathbf{v}, \\mathbf{w} \\rangle} $$\nwhere $\\langle \\mathbf{v}, \\mathbf{w} \\rangle = \\sum_k v_k w_k$ is the scalar product of the left and right eigenvectors. Elasticity, $e_{ij}$, is the proportional sensitivity, which measures the proportional change in $\\lambda$ for a proportional change in $a_{ij}$:\n$$ e_{ij} = \\frac{a_{ij}}{\\lambda} \\frac{\\partial \\lambda}{\\partial a_{ij}} = \\frac{a_{ij}}{\\lambda} \\frac{v_i w_j}{\\langle \\mathbf{v}, \\mathbf{w} \\rangle} $$\nElasticities are used to assess the relative importance of different vital rates to population growth. Selection at low density will most strongly favor changes in vital rates with the highest elasticity.\n\nThe general form of the population projection matrix for this three-stage system is\n$$ \\mathbf{A} = \\begin{pmatrix} g_1  0  F \\\\ m_1  g_2  0 \\\\ 0  m_2  g_3 \\end{pmatrix} $$\nThe characteristic equation is $\\det(\\mathbf{A} - \\lambda \\mathbf{I}) = 0$, which expands to:\n$$ (g_1 - \\lambda)(g_2 - \\lambda)(g_3 - \\lambda) + F m_1 m_2 = 0 $$\n$$ (\\lambda - g_1)(\\lambda - g_2)(\\lambda - g_3) = F m_1 m_2 $$\n\nWe will now apply this framework to each life history.\n\n**Analysis of Life History 1**\nThe matrix is\n$$ \\mathbf{A}_{1} = \\begin{pmatrix} 0.05  0  6 \\\\ 0.30  0.30  0 \\\\ 0  0.50  0.60 \\end{pmatrix} $$\nThe parameters are $g_1 = 0.05$, $m_1 = 0.30$, $g_2 = 0.30$, $m_2 = 0.50$, $g_3 = 0.60$, and $F = 6$. The characteristic equation is\n$$ (\\lambda - 0.05)(\\lambda - 0.30)(\\lambda - 0.60) = (6)(0.30)(0.50) = 0.9 $$\n$$ \\lambda^3 - 0.95\\lambda^2 + 0.225\\lambda - 0.909 = 0 $$\nSolving this cubic equation numerically for the dominant (largest positive real) root yields $\\lambda_1 \\approx 1.30896$.\n\nTo find the right eigenvector $\\mathbf{w}^{(1)}$, we solve $(\\mathbf{A}_1 - \\lambda_1 \\mathbf{I})\\mathbf{w}^{(1)} = \\mathbf{0}$. We set $w_1 = 1$:\nFrom the second row: $0.30 w_1 + (0.30 - \\lambda_1) w_2 = 0 \\implies w_2 = \\frac{0.30}{\\lambda_1 - 0.30} w_1 = \\frac{0.30}{1.30896 - 0.30} \\approx 0.29734$.\nFrom the third row: $0.50 w_2 + (0.60 - \\lambda_1) w_3 = 0 \\implies w_3 = \\frac{0.50}{\\lambda_1 - 0.60} w_2 = \\frac{0.50}{1.30896 - 0.60} (0.29734) \\approx 0.20969$.\nSo, $\\mathbf{w}^{(1)} \\propto \\begin{pmatrix} 1 \\\\ 0.29734 \\\\ 0.20969 \\end{pmatrix}$.\n\nTo find the left eigenvector $\\mathbf{v}^{(1)}$, we solve $\\mathbf{v}^{(1)T}(\\mathbf{A}_1 - \\lambda_1 \\mathbf{I}) = \\mathbf{0}^T$. We set $v_1=1$:\nFrom the first column: $(0.05 - \\lambda_1) v_1 + 0.30 v_2 = 0 \\implies v_2 = \\frac{\\lambda_1 - 0.05}{0.30} v_1 = \\frac{1.30896 - 0.05}{0.30} \\approx 4.19653$.\nFrom the second column: $(0.30 - \\lambda_1) v_2 + 0.50 v_3 = 0 \\implies v_3 = \\frac{\\lambda_1 - 0.30}{0.50} v_2 = \\frac{1.30896 - 0.30}{0.50} (4.19653) \\approx 8.46823$.\nSo, $\\mathbf{v}^{(1)T} \\propto \\begin{pmatrix} 1  4.19653  8.46823 \\end{pmatrix}$.\n\nThe scalar product is:\n$$ \\langle \\mathbf{v}^{(1)}, \\mathbf{w}^{(1)} \\rangle = (1)(1) + (4.19653)(0.29734) + (8.46823)(0.20969) \\approx 1 + 1.24783 + 1.77573 \\approx 4.02359 $$\n\nThe elasticities are:\n$e_{F}^{(1)} = e_{13}^{(1)} = \\frac{a_{13}^{(1)}}{\\lambda_1} \\frac{v_1^{(1)} w_3^{(1)}}{\\langle \\mathbf{v}^{(1)}, \\mathbf{w}^{(1)} \\rangle} = \\frac{6}{1.30896} \\frac{(1)(0.20969)}{4.02359} \\approx 4.5835 \\times 0.05212 \\approx 0.23891$.\n$e_{g_1}^{(1)} = e_{11}^{(1)} = \\frac{a_{11}^{(1)}}{\\lambda_1} \\frac{v_1^{(1)} w_1^{(1)}}{\\langle \\mathbf{v}^{(1)}, \\mathbf{w}^{(1)} \\rangle} = \\frac{0.05}{1.30896} \\frac{(1)(1)}{4.02359} \\approx 0.03819 \\times 0.24853 \\approx 0.009492$.\n\nSince $e_{F}^{(1)} (0.23891)  e_{g_1}^{(1)} (0.009492)$, a small proportional increase in adult fecundity $F$ would be more strongly favored by selection than such an increase in juvenile stasis $g_1$.\n\n**Analysis of Life History 2**\nThe matrix is\n$$ \\mathbf{A}_{2} = \\begin{pmatrix} 0.40  0  2 \\\\ 0.30  0.30  0 \\\\ 0  0.50  0.60 \\end{pmatrix} $$\nThe characteristic equation is $(\\lambda - 0.40)(\\lambda - 0.30)(\\lambda - 0.60) = (2)(0.30)(0.50) = 0.3$.\n$$ \\lambda^3 - 1.3\\lambda^2 + 0.54\\lambda - 0.372 = 0 $$\nThe dominant eigenvalue is $\\lambda_2 \\approx 1.11538$. Following similar calculations as for Life History 1:\n$\\mathbf{w}^{(2)} \\propto \\begin{pmatrix} 1 \\\\ 0.3680 \\\\ 0.3570 \\end{pmatrix}$, $\\mathbf{v}^{(2)T} \\propto \\begin{pmatrix} 1  2.3846  3.8893 \\end{pmatrix}$.\nThe scalar product is $\\langle \\mathbf{v}^{(2)}, \\mathbf{w}^{(2)} \\rangle \\approx 3.2657$.\nThe elasticities are:\n$e_{F}^{(2)} = e_{13}^{(2)} = \\frac{2}{1.11538} \\frac{(1)(0.3570)}{3.2657} \\approx 0.1962$.\n$e_{g_1}^{(2)} = e_{11}^{(2)} = \\frac{0.40}{1.11538} \\frac{(1)(1)}{3.2657} \\approx 0.1098$.\nSince $e_{F}^{(2)} (0.1962)  e_{g_1}^{(2)} (0.1098)$, selection would again more strongly favor a proportional increase in fecundity $F$.\n\n**Final Calculation of R**\nThe problem asks for the ratio $R = \\frac{e_{F}^{(1)}}{e_{g_{1}}^{(1)}} = \\frac{e_{13}^{(1)}}{e_{11}^{(1)}}$.\nUsing the definition of elasticity:\n$$ R = \\frac{\\frac{a_{13}^{(1)}}{\\lambda_1} \\frac{v_1^{(1)} w_3^{(1)}}{\\langle \\mathbf{v}^{(1)}, \\mathbf{w}^{(1)} \\rangle}}{\\frac{a_{11}^{(1)}}{\\lambda_1} \\frac{v_1^{(1)} w_1^{(1)}}{\\langle \\mathbf{v}^{(1)}, \\mathbf{w}^{(1)} \\rangle}} = \\frac{a_{13}^{(1)}}{a_{11}^{(1)}} \\frac{w_3^{(1)}}{w_1^{(1)}} = \\frac{F_1}{g_1^{(1)}} \\frac{w_3^{(1)}}{w_1^{(1)}} $$\nThis expression avoids the need to calculate the left eigenvector $\\mathbf{v}$ and the scalar product. From the first row of the eigenvector equation $\\mathbf{A}_1 \\mathbf{w}^{(1)} = \\lambda_1 \\mathbf{w}^{(1)}$:\n$$ a_{11}^{(1)} w_1^{(1)} + a_{13}^{(1)} w_3^{(1)} = \\lambda_1 w_1^{(1)} \\implies F_1 w_3^{(1)} = (\\lambda_1 - g_1^{(1)}) w_1^{(1)} $$\nSubstituting this into the expression for $R$:\n$$ R = \\frac{1}{g_1^{(1)}} \\left( F_1 \\frac{w_3^{(1)}}{w_1^{(1)}} \\right) = \\frac{1}{g_1^{(1)}} (\\lambda_1 - g_1^{(1)}) = \\frac{\\lambda_1 - g_1^{(1)}}{g_1^{(1)}} $$\nThis provides a direct and more robust way to compute $R$, using only the dominant eigenvalue $\\lambda_1$ and the parameter $g_1^{(1)}$.\nUsing the accurately computed value $\\lambda_1 \\approx 1.30896$:\n$$ R = \\frac{1.30896 - 0.05}{0.05} = \\frac{1.25896}{0.05} = 25.1792 $$\nRounding to four significant figures, the result is $25.18$.\nThis value is consistent with the ratio from the full elasticity calculation: $R \\approx \\frac{0.23891}{0.009492} \\approx 25.17$.", "answer": "$$ \\boxed{25.18} $$", "id": "2728457"}, {"introduction": "Many organisms exhibit flexible life-history strategies, where the decision to grow or reproduce depends on their current state and the time horizon. This exercise moves beyond fixed schedules to model such state-dependent decisions using dynamic programming, a powerful optimization technique [@problem_id:2728453]. By implementing backward induction, you will determine the optimal policy for an organism facing a trade-off, revealing how the best course of action changes as a function of its size and the approaching end of a season.", "problem": "Consider a finite-horizon decision problem that formalizes a life-history allocation trade-off between growth and current reproduction for an organism with two discrete size states $s\\in\\{S,L\\}$ (small, large). At each decision step, the organism chooses an action $a\\in\\{0,1\\}$, where $a=0$ denotes allocating to growth (no immediate reproduction), and $a=1$ denotes allocating to current reproduction. The season ends after a fixed number of steps $T\\in\\mathbb{N}$, interpreted as the time remaining to season end. Time is discrete, with a step index equal to the number $t$ of steps remaining, $t\\in\\{0,1,2,\\dots,T\\}$. The terminal boundary condition is that with $t=0$ steps remaining there is no further reproductive output.\n\nFundamental model components:\n- Immediate fecundity: if the organism in state $s$ takes action $a$, the immediate expected reproductive output is $F(s,a)$ where $F(s,0)=0$ and $F(S,1)=f_S$, $F(L,1)=f_L$, for given nonnegative constants $f_S$ and $f_L$.\n- Survival to the next step: the probability of surviving to the next decision step is $\\sigma_{s,a}\\in[0,1]$, which depends on state $s$ and action $a$. Death ends the process for that season (no further returns).\n- State transition upon survival: conditional on survival, the next size state $s'\\in\\{S,L\\}$ is drawn from a distribution that depends on current state and action, with probabilities $P_{s,a}(s')$, satisfying $P_{s,a}(S)+P_{s,a}(L)=1$ for each $(s,a)$.\n- Policies and objectives: a policy at time remaining $t$ maps each state $s$ to an action $a\\in\\{0,1\\}$. A policy is optimal if it maximizes expected cumulative reproductive output from the current time until $t=0$. Ties in expected value must be broken deterministically in favor of growth, that is, choose $a=0$ when two actions have exactly equal expected value.\n\nYou must implement value iteration via backward induction from first principles (no prepackaged dynamic programming routines) to compute:\n- The optimal value function $V_t(s)$: the maximal expected cumulative reproductive output from state $s$ with $t$ steps remaining, for all $t\\in\\{0,1,\\dots,T\\}$ and both states $s\\in\\{S,L\\}$.\n- The corresponding optimal policy $\\pi_t(s)\\in\\{0,1\\}$ for each time remaining $t\\in\\{1,\\dots,T\\}$ and each state $s\\in\\{S,L\\}$.\n- The values $V_T(S)$ and $V_T(L)$, which are the expected total reproductive outputs when starting in state $S$ or $L$ at the start of the season (i.e., with $T$ steps remaining), under the optimal policy.\n\nInterpretation and assumptions must use only:\n- Definitions of expected value and the law of total expectation.\n- The Markov property for this process, implied by the given survival and transition probabilities.\n- The terminal condition $V_0(s)=0$ for all $s$.\n\nNo other shortcut formulas should be assumed in the problem statement; your solution must derive any needed recursion from these bases.\n\nTest suite. For each of the following parameter sets, run your program to compute the optimal values and policies. For each case, the state set is $s\\in\\{S,L\\}$, the action set is $a\\in\\{0,1\\}$ with $a=0$ denoting growth and $a=1$ denoting reproduction, and the required parameters are:\n- Survival matrix entries $\\sigma_{s,a}$.\n- Transition probabilities $P_{s,a}(S)$ and $P_{s,a}(L)$, which must sum to $1$ for each $(s,a)$.\n- Fecundities $f_S$ and $f_L$.\n- Horizon $T$.\n\nCase A (typical growth-reproduction trade-off, season length $T=4$):\n- Horizon: $T=4$.\n- Fecundities: $f_S=1.0$, $f_L=3.0$.\n- Survival probabilities:\n  - $\\sigma_{S,0}=0.8$, $\\sigma_{S,1}=0.7$,\n  - $\\sigma_{L,0}=0.9$, $\\sigma_{L,1}=0.85$.\n- Transitions upon survival:\n  - From $S$ under growth: $P_{S,0}(S)=0.4$, $P_{S,0}(L)=0.6$.\n  - From $S$ under reproduction: $P_{S,1}(S)=0.8$, $P_{S,1}(L)=0.2$.\n  - From $L$ under growth: $P_{L,0}(S)=0.1$, $P_{L,0}(L)=0.9$.\n  - From $L$ under reproduction: $P_{L,1}(S)=0.3$, $P_{L,1}(L)=0.7$.\n\nCase B (boundary case, zero time remaining, $T=0$):\n- Horizon: $T=0$.\n- Fecundities: $f_S=1.0$, $f_L=3.0$.\n- Survival probabilities:\n  - $\\sigma_{S,0}=0.8$, $\\sigma_{S,1}=0.7$,\n  - $\\sigma_{L,0}=0.9$, $\\sigma_{L,1}=0.85$.\n- Transitions upon survival:\n  - From $S$ under growth: $P_{S,0}(S)=0.4$, $P_{S,0}(L)=0.6$.\n  - From $S$ under reproduction: $P_{S,1}(S)=0.8$, $P_{S,1}(L)=0.2$.\n  - From $L$ under growth: $P_{L,0}(S)=0.1$, $P_{L,0}(L)=0.9$.\n  - From $L$ under reproduction: $P_{L,1}(S)=0.3$, $P_{L,1}(L)=0.7$.\n\nCase C (reproduction comparatively favorable, $T=3$):\n- Horizon: $T=3$.\n- Fecundities: $f_S=2.0$, $f_L=4.0$.\n- Survival probabilities:\n  - $\\sigma_{S,0}=0.8$, $\\sigma_{S,1}=0.79$,\n  - $\\sigma_{L,0}=0.85$, $\\sigma_{L,1}=0.84$.\n- Transitions upon survival:\n  - From $S$ under growth: $P_{S,0}(S)=0.5$, $P_{S,0}(L)=0.5$.\n  - From $S$ under reproduction: $P_{S,1}(S)=0.6$, $P_{S,1}(L)=0.4$.\n  - From $L$ under growth: $P_{L,0}(S)=0.05$, $P_{L,0}(L)=0.95$.\n  - From $L$ under reproduction: $P_{L,1}(S)=0.1$, $P_{L,1}(L)=0.9$.\n\nCase D (short season and low survival, $T=2$):\n- Horizon: $T=2$.\n- Fecundities: $f_S=0.8$, $f_L=5.0$.\n- Survival probabilities:\n  - $\\sigma_{S,0}=0.3$, $\\sigma_{S,1}=0.25$,\n  - $\\sigma_{L,0}=0.4$, $\\sigma_{L,1}=0.35$.\n- Transitions upon survival:\n  - From $S$ under growth: $P_{S,0}(S)=0.5$, $P_{S,0}(L)=0.5$.\n  - From $S$ under reproduction: $P_{S,1}(S)=0.9$, $P_{S,1}(L)=0.1$.\n  - From $L$ under growth: $P_{L,0}(S)=0.2$, $P_{L,0}(L)=0.8$.\n  - From $L$ under reproduction: $P_{L,1}(S)=0.4$, $P_{L,1}(L)=0.6$.\n\nComputational requirements and output specification:\n- Implement backward induction over $t=T,T-1,\\dots,1$ using only the fundamental definitions above. Use deterministic tie-breaking in favor of growth ($a=0$) when two actions have equal expected value.\n- For each test case, compute and collect in order:\n  1. The two floats $V_T(S)$ and $V_T(L)$ rounded to six decimal places.\n  2. The optimal actions as integers for each time remaining $t=1,2,\\dots,T$ in increasing order of $t$, listed for state $S$ then state $L$ at each $t$ (encode growth as $0$ and reproduction as $1$). If $T=0$, include no actions.\n- Your program should produce a single line of output containing the results for all test cases concatenated into one list, formatted as a comma-separated list enclosed in square brackets (for example, $[x_1,x_2,\\dots]$), where floats are rounded to six decimal places as specified and actions are integers.", "solution": "The problem statement will first be subjected to a rigorous validation procedure.\n\n### Step 1: Extract Givens\n\n- **States**: $s \\in \\{S, L\\}$ (small, large).\n- **Actions**: $a \\in \\{0, 1\\}$ ($0$ for growth, $1$ for reproduction).\n- **Time Horizon**: Finite, with $t \\in \\{0, 1, ..., T\\}$ steps remaining until the season ends.\n- **Terminal Condition**: At $t=0$, reproductive output is zero. This implies the terminal value function is $V_0(s) = 0$ for all $s$.\n- **Immediate Fecundity**: $F(s, a)$, with $F(s, 0) = 0$, $F(S, 1) = f_S$, and $F(L, 1) = f_L$.\n- **Survival Probability**: $\\sigma_{s,a} \\in [0, 1]$.\n- **State Transition Probability**: $P_{s,a}(s')$, conditional on survival. $P_{s,a}(S) + P_{s,a}(L) = 1$.\n- **Objective**: Maximize expected cumulative reproductive output from the current time until $t=0$.\n- **Policy**: A mapping $\\pi_t(s)$ from state $s$ to action $a$ at time remaining $t$.\n- **Tie-Breaking Rule**: If expected values for both actions are equal, choose action $a=0$ (growth).\n- **Required Computations**:\n    1. Optimal value function $V_t(s)$ for $t \\in \\{0, \\dots, T\\}$ and $s \\in \\{S, L\\}$.\n    2. Optimal policy $\\pi_t(s)$ for $t \\in \\{1, \\dots, T\\}$ and $s \\in \\{S, L\\}$.\n    3. Final values $V_T(S)$ and $V_T(L)$.\n- **Method**: Value iteration via backward induction from first principles.\n- **Test Cases**: Four parameter sets (A, B, C, D) are provided with specific values for $T$, $f_S$, $f_L$, $\\sigma_{s,a}$, and $P_{s,a}(s')$.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientific Grounding**: The problem describes a finite-horizon Markov Decision Process (MDP), which is a standard and robust framework for modeling sequential decision-making under uncertainty. Its application to life-history trade-offs is a classic topic in theoretical evolutionary biology. The model is a valid, albeit simplified, representation of a biological process. It is scientifically grounded.\n- **Well-Posedness**: The state space, action space, and time horizon are all finite. The objective function (maximization of expected total reward) is clearly defined. The terminal condition is specified, and the recursive structure defined by the problem implies a unique solution exists. The deterministic tie-breaking rule resolves any ambiguity in the optimal policy. The problem is well-posed.\n- **Objectivity**: The problem is stated in precise mathematical and logical terms, free of subjective or ambiguous language.\n- **Consistency and Completeness**: All parameters required to define the MDP are provided for each test case. The transition probabilities for each state-action pair sum to $1$ as required ($P_{s,a}(S) + P_{s,a}(L) = 1$). For example, in Case A, for $(s,a)=(S,0)$, $P_{S,0}(S)+P_{S,0}(L) = 0.4+0.6=1.0$. This holds for all specified transitions. The problem is self-contained and internally consistent.\n\n### Step 3: Verdict and Action\n\nThe problem is scientifically sound, well-posed, and complete. It is a valid problem of dynamic optimization. We will now proceed with the derivation of the solution.\n\n---\n\nThe problem requires the computation of an optimal policy for a finite-horizon decision process. This is a standard problem in dynamic programming, which we solve using backward induction, starting from the terminal time.\n\nLet $V_t(s)$ be the maximum expected cumulative reproductive output obtainable when the organism is in state $s \\in \\{S,L\\}$ with $t$ time steps remaining. Our objective is to find $V_t(s)$ and the corresponding optimal policy $\\pi_t(s)$ for all $s$ and $t \\in \\{1, \\dots, T\\}$.\n\n**Terminal Condition**\nAt time $t=0$, there are no steps remaining. No further reproduction is possible. Therefore, the value function at the terminal time is zero for both states:\n$$V_0(s) = 0 \\quad \\forall s \\in \\{S,L\\}$$\n\n**Backward Induction**\nWe derive the solution by working backwards from $t=0$. For any time $t  0$, the optimal value $V_t(s)$ is found by choosing the action $a \\in \\{0, 1\\}$ that maximizes the sum of the immediate reward and the expected future rewards. This is the principle of optimality articulated by Bellman's equation.\n\nLet $Q_t(s,a)$ denote the expected total reproductive output given that the organism is in state $s$ with $t$ steps remaining, takes action $a$, and proceeds optimally thereafter. This is the action-value function. It is composed of two parts: an immediate reproductive output, $F(s,a)$, and the expected value of future reproduction.\n\nThe future value is realized only if the organism survives to the next time step, which occurs with probability $\\sigma_{s,a}$. If it survives, the time remaining will be $t-1$. The organism will transition to a new state $s' \\in \\{S,L\\}$ with probability $P_{s,a}(s')$. From that new state $s'$, the maximum expected future return is, by definition, $V_{t-1}(s')$.\n\nUsing the law of total expectation, the expected future reward, conditional on taking action $a$ in state $s$ at time $t$, is:\n$$ \\sigma_{s,a} \\times \\mathbb{E}[V_{t-1}(s') | s, a] = \\sigma_{s,a} \\left( P_{s,a}(S)V_{t-1}(S) + P_{s,a}(L)V_{t-1}(L) \\right) $$\n\nTherefore, the action-value function $Q_t(s,a)$ is:\n$$ Q_t(s,a) = F(s,a) + \\sigma_{s,a} \\left( P_{s,a}(S)V_{t-1}(S) + P_{s,a}(L)V_{t-1}(L) \\right) $$\n\nTo obtain the optimal value function $V_t(s)$, we must choose the action that maximizes this quantity:\n$$ V_t(s) = \\max_{a \\in \\{0,1\\}} \\{ Q_t(s,a) \\} $$\nThe optimal policy $\\pi_t(s)$ is the action that achieves this maximum:\n$$ \\pi_t(s) = \\arg\\max_{a \\in \\{0,1\\}} \\{ Q_t(s,a) \\} $$\n\nWe can write out the expressions for $Q_t(s,a)$ for each action $a \\in \\{0,1\\}$.\nFor action $a=0$ (growth):\n$$ Q_t(s,0) = F(s,0) + \\sigma_{s,0} \\left( P_{s,0}(S)V_{t-1}(S) + P_{s,0}(L)V_{t-1}(L) \\right) $$\nGiven $F(s,0) = 0$, this simplifies to:\n$$ Q_t(s,0) = \\sigma_{s,0} \\left( P_{s,0}(S)V_{t-1}(S) + P_{s,0}(L)V_{t-1}(L) \\right) $$\n\nFor action $a=1$ (reproduction):\n$$ Q_t(s,1) = F(s,1) + \\sigma_{s,1} \\left( P_{s,1}(S)V_{t-1}(S) + P_{s,1}(L)V_{t-1}(L) \\right) $$\nwhere $F(S,1)=f_S$ and $F(L,1)=f_L$.\n\nThe decision rule for the optimal policy $\\pi_t(s)$ at each state $s$ and time $t$ is determined by comparing $Q_t(s,0)$ and $Q_t(s,1)$. Incorporating the specified tie-breaking rule (choose growth, $a=0$, if values are equal):\n$$\n\\pi_t(s) =\n\\begin{cases}\n  1  \\text{if } Q_t(s,1)  Q_t(s,0) \\\\\n  0  \\text{if } Q_t(s,1) \\le Q_t(s,0)\n\\end{cases}\n$$\nAnd the value function is updated accordingly:\n$$ V_t(s) = \\max\\{Q_t(s,0), Q_t(s,1)\\} $$\n\nThe algorithm proceeds as follows:\n1. Initialize $V_0(S) = 0$ and $V_0(L) = 0$.\n2. For each time step $t$ from $1$ to $T$:\n    a. For each state $s \\in \\{S,L\\}$:\n        i. Calculate $Q_t(s,0)$ and $Q_t(s,1)$ using the values $V_{t-1}(S)$ and $V_{t-1}(L)$ from the previous step.\n        ii. Determine $\\pi_t(s)$ based on the comparison of $Q_t(s,0)$ and $Q_t(s,1)$ and the tie-breaking rule.\n        iii. Set $V_t(s)$ to the value corresponding to the optimal action, i.e., $Q_t(s, \\pi_t(s))$.\n3. After iterating up to $t=T$, the final values $V_T(S)$ and $V_T(L)$, along with the stored policies $\\pi_t(s)$ for $t=1,\\dots,T$, constitute the solution.\n\nThis procedure is implemented for each test case provided.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"case_id\": \"A\", \"T\": 4, \"fS\": 1.0, \"fL\": 3.0,\n            \"sigma\": np.array([[0.8, 0.7], [0.9, 0.85]]),\n            \"P\": np.array([[[0.4, 0.6], [0.8, 0.2]], [[0.1, 0.9], [0.3, 0.7]]])\n        },\n        {\n            \"case_id\": \"B\", \"T\": 0, \"fS\": 1.0, \"fL\": 3.0,\n            \"sigma\": np.array([[0.8, 0.7], [0.9, 0.85]]),\n            \"P\": np.array([[[0.4, 0.6], [0.8, 0.2]], [[0.1, 0.9], [0.3, 0.7]]])\n        },\n        {\n            \"case_id\": \"C\", \"T\": 3, \"fS\": 2.0, \"fL\": 4.0,\n            \"sigma\": np.array([[0.8, 0.79], [0.85, 0.84]]),\n            \"P\": np.array([[[0.5, 0.5], [0.6, 0.4]], [[0.05, 0.95], [0.1, 0.9]]])\n        },\n        {\n            \"case_id\": \"D\", \"T\": 2, \"fS\": 0.8, \"fL\": 5.0,\n            \"sigma\": np.array([[0.3, 0.25], [0.4, 0.35]]),\n            \"P\": np.array([[[0.5, 0.5], [0.9, 0.1]], [[0.2, 0.8], [0.4, 0.6]]])\n        }\n    ]\n\n    full_results = []\n    for params in test_cases:\n        result = solve_case(params)\n        full_results.extend(result)\n\n    # Format final output line as specified.\n    formatted_results = []\n    for item in full_results:\n        if isinstance(item, float):\n            formatted_results.append(f\"{item:.6f}\")\n        else:\n            formatted_results.append(str(item))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef solve_case(params):\n    \"\"\"\n    Solves a single instance of the dynamic programming problem.\n    \"\"\"\n    T = params[\"T\"]\n    fecundity = np.array([params[\"fS\"], params[\"fL\"]])\n    sigma = params[\"sigma\"]  # sigma[s, a]\n    P = params[\"P\"]          # P[s, a, s']\n\n    # States: S=0, L=1. Actions: Growth=0, Reproduction=1.\n    \n    # V_prev corresponds to V_{t-1}\n    V_prev = np.zeros(2)  # V_0(S) = 0, V_0(L) = 0\n\n    if T == 0:\n        return [V_prev[0], V_prev[1]]\n\n    # policies[t-1][s] stores the policy for time t, state s\n    policies = np.zeros((T, 2), dtype=int)\n    \n    # V_curr corresponds to V_t\n    V_curr = np.zeros(2)\n\n    # Backward induction from t=1 to T\n    for t in range(1, T + 1):\n        for s in range(2):  # s=0 for Small, s=1 for Large\n            # Expected future value from the previous time step's optimal values\n            # This is sum_{s'} P(s'|s,a) * V_{t-1}(s')\n            exp_future_val = P[s, :, 0] * V_prev[0] + P[s, :, 1] * V_prev[1]\n            \n            # Action a=0 (Growth): F(s,0) = 0\n            q_val_0 = sigma[s, 0] * exp_future_val[0]\n\n            # Action a=1 (Reproduction): F(s,1) = fecundity[s]\n            q_val_1 = fecundity[s] + sigma[s, 1] * exp_future_val[1]\n\n            # Decision rule with tie-breaking for growth (a=0)\n            if q_val_1  q_val_0:\n                V_curr[s] = q_val_1\n                policies[t-1, s] = 1\n            else:\n                V_curr[s] = q_val_0\n                policies[t-1, s] = 0\n        \n        # Update V_prev for the next iteration\n        V_prev = V_curr.copy()\n\n    # V_prev now holds V_T(S) and V_T(L)\n    final_v_s, final_v_l = V_prev[0], V_prev[1]\n\n    # Assemble the results as specified\n    case_results = [final_v_s, final_v_l]\n    # Flatten policies in the required order: pi_1(S),pi_1(L), pi_2(S),pi_2(L),...\n    for t in range(T):\n        case_results.append(policies[t, 0])\n        case_results.append(policies[t, 1])\n        \n    return case_results\n\nsolve()\n```", "id": "2728453"}]}