{"hands_on_practices": [{"introduction": "The Multispecies Coalescent (MSC) model is built upon the foundation of the standard neutral coalescent process, which describes how gene lineages merge backward in time within a single population. This first exercise challenges you to build this fundamental engine from first principles. By deriving and simulating the distribution of intercoalescent waiting times, you will gain a direct, hands-on understanding of the stochastic nature of gene genealogies, a crucial step before tackling more complex multi-species scenarios [@problem_id:2726286].", "problem": "You are to implement a simulation of a neutral coalescent genealogy for a sample of size $n=5$ under a constant diploid effective population size $N_e$ within the classical constant-size Wright–Fisher model. This simulation represents the within-branch process assumed by the Multispecies Coalescent (MSC) framework, which is the standard model used to study incomplete lineage sorting. Your program must simulate the intercoalescent intervals by correctly deriving, from first principles, the waiting-time distribution when there are $k$ ancestral lineages, for $k$ decreasing from $5$ to $2$, under two possible time scalings: generations, and coalescent time units scaled by $2N_e$. You must base your derivation only on core definitions and well-tested facts: the definition of the coalescent process in a constant-size diploid population, the per-pair coalescence rate under neutrality, and the distributional property of the minimum of independent exponential waiting times. Do not use any pre-packaged or shortcut formulas in your derivation.\n\nYour program must:\n- Implement a general simulator for the intercoalescent intervals for $n=5$, stepping $k$ from $5$ down to $2$, under a constant $N_e$.\n- Support two time-unit options:\n  - $u=\\text{\"gen\"}$: time measured in generations.\n  - $u=\\text{\"coal\"}$: time measured in coalescent units, where one coalescent unit equals $2N_e$ generations.\n- Use a specified pseudorandom seed to ensure reproducibility.\n- Return, for each test case, a list of $4$ floating-point numbers corresponding to the simulated intercoalescent intervals $(T_5,T_4,T_3,T_2)$ in the requested unit $u$.\n\nScientific and mathematical requirements you must satisfy in your derivation and implementation:\n- Begin from the following foundational base:\n  - In a constant-size diploid Wright–Fisher population, each unordered pair of ancestral lineages coalesces at a constant rate per generation determined by $N_e$.\n  - When there are $k$ lineages, there are $\\binom{k}{2}$ unordered pairs.\n  - The minimum of independent exponential waiting times is exponential, and the identity of the minimum is independent of that minimum.\n- From this base, derive the distribution of each intercoalescent interval $T_k$ while there are $k$ lineages. Explicitly identify the rate parameter in generations and in coalescent units, clarifying the scaling between these units. Provide the expectation of $T_k$ under each scaling based on your derived distribution.\n- Translate your derivation into a correct simulation algorithm that draws $T_k$ for $k=5,4,3,2$, using the appropriate rate for the chosen unit $u$.\n- Ensure scientific realism by keeping all parameters within plausible biological ranges and by adhering to the neutral coalescent assumptions.\n\nTest suite:\nYour program must run the following test cases internally (do not request user input), in the order listed, and aggregate the results into a single output line as specified below. Each test case is a tuple $(n,N_e,u,\\text{seed})$, where $n=5$ for all cases:\n- Case $1$: $(5,\\,10000,\\,\\text{\"coal\"},\\,12345)$.\n- Case $2$: $(5,\\,50000,\\,\\text{\"gen\"},\\,20231102)$.\n- Case $3$: $(5,\\,500,\\,\\text{\"gen\"},\\,42)$.\n- Case $4$: $(5,\\,10000,\\,\\text{\"gen\"},\\,0)$.\n\nUnits:\n- When $u=\\text{\"gen\"}$, report times in generations.\n- When $u=\\text{\"coal\"}$, report times in coalescent units, where one unit equals $2N_e$ generations.\n\nAnswer type and final output format:\n- For each test case, return a list of $4$ floating-point numbers $(T_5,T_4,T_3,T_2)$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list of four floats for a test case. For example, a valid output shape is: [[t51,t41,t31,t21],[t52,t42,t32,t22],[t53,t43,t33,t23],[t54,t44,t34,t24]].\n- Floats may be printed in standard unrounded form.\n\nYour solution must include:\n- A principled derivation of the intercoalescent distributions from the foundational base above.\n- A clear description of the algorithmic steps.\n- The complete program that executes the simulation and produces the required single-line output for the specified test suite.", "solution": "The problem requires the derivation and simulation of intercoalescent waiting times for a sample of $n=5$ lineages under the neutral Wright-Fisher model with a constant diploid effective population size $N_e$. The derivation must proceed from first principles, and the simulation must be reproducible, supporting time units of both generations and coalescent units.\n\nFirst, we shall derive the distribution of the intercoalescent time $T_k$, which is the waiting time for any two of $k$ ancestral lineages to coalesce.\n\nThe foundational assumptions are as follows:\n$1$. We consider a constant-size diploid population of $N_e$ individuals, which corresponds to $2N_e$ gene copies in each generation.\n$2$. We trace the ancestry of a sample of $k$ lineages backward in time.\n$3$. Under the neutral Wright-Fisher model, each lineage in generation $t+1$ chooses its parent from generation $t$ uniformly at random from the $2N_e$ gene copies.\n\nConsider two specific lineages. The probability that they choose the same parental gene copy in the preceding generation is $1/(2N_e)$. The probability that they do not is $1 - 1/(2N_e)$. The event of coalescence is therefore a Bernoulli trial in each generation. The time until the first success (coalescence) follows a geometric distribution with success probability $p = 1/(2N_e)$. For a large effective population size $N_e$, which is a standard assumption in coalescent theory, this discrete-time geometric process is well-approximated by a continuous-time exponential waiting process. The rate of this exponential process, $\\lambda_{\\text{pair}}$, is equal to the probability of the event occurring in a single time step. Thus, the rate of coalescence for a single pair of lineages is:\n$$ \\lambda_{\\text{pair}} = \\frac{1}{2N_e} \\text{ per generation} $$\nThe waiting time for this specific pair to coalesce is an exponential random variable with this rate.\n\nNow, consider the case with $k$ distinct ancestral lineages. A coalescence event occurs when any pair of these lineages finds a common ancestor. The number of distinct, unordered pairs of lineages is given by the binomial coefficient:\n$$ \\binom{k}{2} = \\frac{k(k-1)}{2} $$\nEach of these $\\binom{k}{2}$ pairs represents an independent opportunity for a coalescence event. The total time until the *next* coalescence event, $T_k$, is the minimum of the waiting times for each of the $\\binom{k}{2}$ pairs. A fundamental property of exponential distributions states that the minimum of a set of independent exponential random variables is itself an exponential random variable. Its rate is the sum of the individual rates.\n\nSince each pair coalesces at a rate of $\\lambda_{\\text{pair}} = 1/(2N_e)$ per generation, the total rate of coalescence for any pair, $\\lambda_k$, is the sum of the rates of all pairs:\n$$ \\lambda_k^{\\text{gen}} = \\binom{k}{2} \\times \\lambda_{\\text{pair}} = \\frac{k(k-1)}{2} \\times \\frac{1}{2N_e} = \\frac{k(k-1)}{4N_e} \\text{ per generation} $$\nTherefore, the intercoalescent time $T_k$ measured in generations is an exponential random variable with rate $\\lambda_k^{\\text{gen}}$:\n$$ T_k(\\text{gen}) \\sim \\text{Exp}\\left(\\frac{k(k-1)}{4N_e}\\right) $$\nThe expected waiting time in generations is the reciprocal of the rate:\n$$ E[T_k(\\text{gen})] = \\frac{1}{\\lambda_k^{\\text{gen}}} = \\frac{4N_e}{k(k-1)} $$\n\nNext, we derive the distribution in coalescent time units. One coalescent time unit is defined as $2N_e$ generations. Let $t_{\\text{gen}}$ be time in generations and $t_{\\text{coal}}$ be time in coalescent units. The relationship is:\n$$ t_{\\text{coal}} = \\frac{t_{\\text{gen}}}{2N_e} $$\nIf a random variable $X$ has an exponential distribution with rate $\\lambda$, the scaled random variable $Y = cX$ has an exponential distribution with rate $\\lambda/c$. To convert the rate from generations to coalescent units, we use the scaling factor $c = 1/(2N_e)$. The new rate, $\\lambda_k^{\\text{coal}}$, is:\n$$ \\lambda_k^{\\text{coal}} = \\lambda_k^{\\text{gen}} \\times (2N_e) = \\left(\\frac{k(k-1)}{4N_e}\\right) \\times (2N_e) = \\frac{k(k-1)}{2} = \\binom{k}{2} $$\nThus, when time is measured in coalescent units, the intercoalescent time $T_k$ follows an exponential distribution with a rate that is independent of population size:\n$$ T_k(\\text{coal}) \\sim \\text{Exp}\\left(\\binom{k}{2}\\right) $$\nThe expected waiting time in coalescent units is:\n$$ E[T_k(\\text{coal})] = \\frac{1}{\\lambda_k^{\\text{coal}}} = \\frac{1}{\\binom{k}{2}} = \\frac{2}{k(k-1)} $$\n\nThe simulation algorithm proceeds as follows. For each test case specified by $(n, N_e, u, \\text{seed})$:\n$1$. A pseudorandom number generator is initialized with the provided `seed` to ensure reproducibility.\n$2$. The simulation iterates backward in time, from $k=n$ down to $k=2$. For this problem, $n=5$, so the loop runs for $k \\in \\{5, 4, 3, 2\\}$.\n$3$. In each iteration $k$, the rate parameter $\\lambda_k$ is calculated according to the specified time unit $u$:\n    - If $u = \\text{\"gen\"}$, the rate is $\\lambda_k^{\\text{gen}} = \\frac{k(k-1)}{4N_e}$.\n    - If $u = \\text{\"coal\"}$, the rate is $\\lambda_k^{\\text{coal}} = \\binom{k}{2} = \\frac{k(k-1)}{2}$.\n$4$. A random variate $T_k$ is drawn from the exponential distribution with the calculated rate $\\lambda_k$. This is achieved using the inverse transform sampling method, where $T_k = -\\ln(U) / \\lambda_k$ for a uniform random variable $U \\sim \\text{Uniform(0,1)}$. In practice, we use a library function that implements this, such as `numpy.random.exponential`, which takes a scale parameter $\\beta = 1/\\lambda_k$.\n$5$. The simulated time $T_k$ is stored. After the loop completes, the result is a list of four time intervals: $(T_5, T_4, T_3, T_2)$.\n$6$. This procedure is repeated for all test cases, and the results are aggregated into a single formatted output string.", "answer": "```python\nimport numpy as np\n\ndef simulate_coalescent_intervals(n, Ne, unit, seed):\n    \"\"\"\n    Simulates intercoalescent intervals for a sample of size n.\n\n    Args:\n        n (int): The initial sample size.\n        Ne (int): The diploid effective population size.\n        unit (str): The time unit, either \"gen\" (generations) or \"coal\" (coalescent units).\n        seed (int): The seed for the pseudorandom number generator.\n\n    Returns:\n        list[float]: A list of simulated intercoalescent intervals [T_n, T_{n-1}, ..., T_2].\n    \"\"\"\n    # 1. Initialize the pseudorandom number generator with the given seed.\n    rng = np.random.default_rng(seed)\n    \n    intervals = []\n    \n    # 2. Loop for k from n down to 2.\n    for k in range(n, 1, -1):\n        # 3. Calculate the rate parameter lambda_k.\n        num_pairs = k * (k - 1) / 2\n        \n        if unit == \"gen\":\n            # For time in generations, the rate is kC2 times the pairwise rate of 1/(2*Ne).\n            # The total rate is k(k-1)/(4*Ne)\n            if Ne <= 0:\n                raise ValueError(\"Effective population size Ne must be positive.\")\n            rate = num_pairs / (2 * Ne)\n        elif unit == \"coal\":\n            # For time in coalescent units, the rate is kC2.\n            rate = num_pairs\n        else:\n            raise ValueError(\"Unit must be 'gen' or 'coal'.\")\n            \n        # The scale parameter for numpy's exponential is 1/rate.\n        scale = 1.0 / rate\n        \n        # 4. Draw a random variate from the exponential distribution.\n        t_k = rng.exponential(scale)\n        \n        # 5. Store the simulated time.\n        intervals.append(t_k)\n        \n    return intervals\n\ndef solve():\n    \"\"\"\n    Runs the simulation for a predefined set of test cases and prints the results.\n    \"\"\"\n    # Define the test suite as specified in the problem statement.\n    # Each case is a tuple: (n, Ne, unit, seed)\n    test_cases = [\n        (5, 10000, \"coal\", 12345),\n        (5, 50000, \"gen\", 20231102),\n        (5, 500, \"gen\", 42),\n        (5, 10000, \"gen\", 0)\n    ]\n\n    # Aggregate results from all test cases.\n    all_results = []\n    for n, Ne, unit, seed in test_cases:\n        result = simulate_coalescent_intervals(n, Ne, unit, seed)\n        all_results.append(result)\n\n    # Format the final output string as per the problem requirements.\n    # The format is [[t51,t41,t31,t21],[t52,t42,t32,t22],...].\n    # str() on a list of lists creates spaces, which must be removed.\n    final_output = str(all_results).replace(\" \", \"\")\n    \n    print(final_output)\n\nsolve()\n```", "id": "2726286"}, {"introduction": "Having mastered the coalescent process within a population, we now explore its primary consequence in a phylogenetic context: incomplete lineage sorting (ILS). This practice bridges the gap between the abstract coalescent model and observable patterns in genomic data, showing how the failure of lineages to coalesce within the timeframes defined by species tree branches leads to gene tree topologies that are discordant with the species tree [@problem_id:2726274]. By constructing a dataset and deriving the probabilities of discordance as a function of branch length, you will solidify your intuition for why short internal branches are hotspots for ILS.", "problem": "Consider a rooted species tree with three species labeled $A$, $B$, and $C$, where the species tree topology is $(A,B)\\mid C$. Assume one sampled haploid lineage per species, constant and equal effective population sizes on all branches, no recombination within a locus, and free recombination among loci. Let the length of the internal branch that separates the ancestral population of $A$ and $B$ from $C$ be $T$ coalescent units, where time is scaled by the appropriate effective population size so that the waiting time to coalescence among $k$ lineages is exponentially distributed with rate $\\binom{k}{2}$.\n\nTask:\n1) Construct a minimal three-locus dataset (one short alignment per locus) across species $A$, $B$, and $C$ such that, when each locus is analyzed independently, each locus supports a different rooted gene tree topology among the three possible topologies $(A,B)\\mid C$, $(A,C)\\mid B$, and $(B,C)\\mid A$. Your dataset should be scientifically plausible under a standard mutation model (for example, the infinite-sites model) and should be justified by indicating which parsimony-informative site(s) support each locus’s inferred gene tree.\n2) Explain mechanistically, using incomplete lineage sorting under the Multispecies Coalescent (MSC; Multispecies Coalescent), how a single underlying species tree $(A,B)\\mid C$ with internal branch length $T$ can generate three different rooted gene trees across three independent loci.\n3) Starting from first principles of the coalescent (exponential waiting times for coalescence and symmetry among pairs when three lineages are present in the same ancestral population), derive a closed-form analytic expression for the probability that, across $3$ independent loci, you observe exactly one instance of each of the three rooted topologies. Your final answer must be a single simplified analytic expression in terms of $T$ only, with no numerical approximation or units. Do not use any pre-memorized shortcut formulas; derive what you need from the fundamental coalescent assumptions given above.", "solution": "We first construct an explicit, plausible three-locus dataset under the infinite-sites model that yields three different rooted gene trees across the three loci. Then we explain why such discordance is expected under the Multispecies Coalescent (MSC; Multispecies Coalescent) with incomplete lineage sorting. Finally, we derive from first principles the probability that three independent loci produce all three distinct rooted topologies exactly once, as a function of the internal branch length $T$ (in coalescent units).\n\nStep 1: Constructing a minimal dataset.\nUnder the infinite-sites model, a single biallelic site that places the derived state on the branch subtending a pair of taxa provides parsimony support for that pair as a clade. For three taxa, one informative biallelic site per locus suffices. We can therefore propose the following alignments, where $0$ denotes the ancestral state and $1$ the derived state:\n\n- Locus $1$: $(A,B)\\mid C$\n  - Site pattern: $A=1,\\ B=1,\\ C=0$. This single parsimony-informative site supports $(A,B)\\mid C$.\n\n- Locus $2$: $(A,C)\\mid B$\n  - Site pattern: $A=1,\\ B=0,\\ C=1$. This supports $(A,C)\\mid B$.\n\n- Locus $3$: $(B,C)\\mid A$\n  - Site pattern: $A=0,\\ B=1,\\ C=1$. This supports $(B,C)\\mid A$.\n\nEach locus has exactly one parsimony-informative site consistent with one of the three possible rooted gene trees, and the three loci collectively realize all three topologies.\n\nStep 2: Why discordant gene trees are consistent with a single species tree under the MSC.\nConsider the species tree $(A,B)\\mid C$ with internal branch length $T$ (in coalescent units). Sample one lineage from each of $A$, $B$, and $C$. On the internal branch ancestral to $A$ and $B$, the two lineages $A$ and $B$ can coalesce before the ancestral population common to $A$, $B$, and $C$ is reached. If $A$ and $B$ coalesce on this internal branch, then the gene tree at that locus must be $(A,B)\\mid C$. If they fail to coalesce on this internal branch, then all three lineages $A$, $B$, and $C$ enter the deeper ancestral population simultaneously; by exchangeability and symmetry of the coalescent with $3$ lineages, the first coalescent event picks each pair with probability $1/3$. Consequently, conditional on failing to coalesce on the internal branch, each of the three topologies $(A,B)\\mid C$, $(A,C)\\mid B$, and $(B,C)\\mid A$ occurs with probability $1/3$. Therefore, even when the species tree is $(A,B)\\mid C$, discordant gene trees $(A,C)\\mid B$ and $(B,C)\\mid A$ will arise with nonzero probability due to incomplete lineage sorting, especially when $T$ is small.\n\nStep 3: Deriving the probability of observing all three topologies across three loci.\nWe use only the fundamental coalescent assumptions:\n\n- Along a branch where there are $k$ lineages present in the same population, the waiting time to the next coalescent event is exponential with rate $\\binom{k}{2}$.\n- If three lineages enter the same population at the same time, the first coalescent event groups each pair with equal probability $1/3$, due to exchangeability.\n\nLet $T$ be the length (in coalescent units) of the internal branch ancestral to $A$ and $B$ and descendant of the common ancestor of all three species.\n\nFor a single locus:\n- The probability that lineages $A$ and $B$ do not coalesce on the internal branch of length $T$ is $\\exp(-\\binom{2}{2} T) = \\exp(-T)$, because there are $k=2$ lineages ($A$ and $B$) along that branch and the coalescent rate is $\\binom{2}{2}=1$.\n- With the complementary probability $1-\\exp(-T)$, $A$ and $B$ do coalesce on the internal branch, yielding gene tree $(A,B)\\mid C$.\n- If $A$ and $B$ fail to coalesce on the internal branch (probability $\\exp(-T)$), then the three lineages $A$, $B$, and $C$ enter the ancestral population together. The first coalescent event involves any of the three pairs with equal probability $1/3$. Hence, conditional on failure to coalesce on the internal branch, each of the three rooted gene tree topologies occurs with probability $1/3$.\n\nTherefore, letting $p$ denote the per-locus probability that the gene tree agrees with the species tree $(A,B)\\mid C$, and $q$ the per-locus probability of each discordant topology $(A,C)\\mid B$ or $(B,C)\\mid A$, we have\n$$\np = \\left(1 - \\exp(-T)\\right) + \\exp(-T)\\cdot \\frac{1}{3}\n= 1 - \\frac{2}{3}\\exp(-T),\n$$\n$$\nq = \\exp(-T)\\cdot \\frac{1}{3} = \\frac{1}{3}\\exp(-T).\n$$\n\nAcross $3$ independent loci (free recombination among loci), the probability that we observe exactly one instance of each of the three topologies equals the probability of any ordered assignment of topologies across the loci that contains one $(A,B)\\mid C$, one $(A,C)\\mid B$, and one $(B,C)\\mid A$. For a specific ordering, the probability is $p\\cdot q\\cdot q$. There are $3! = 6$ distinct permutations of these three categories across $3$ loci. Hence, the total probability is\n$$\n6\\,p\\,q^{2} = 6\\left(1 - \\frac{2}{3}\\exp(-T)\\right)\\left(\\frac{1}{3}\\exp(-T)\\right)^{2}.\n$$\nWe can simplify this expression:\n$$\n6\\left(1 - \\frac{2}{3}\\exp(-T)\\right)\\left(\\frac{1}{9}\\exp(-2T)\\right)\n= \\frac{6}{9}\\exp(-2T)\\left(1 - \\frac{2}{3}\\exp(-T)\\right)\n= \\frac{2}{3}\\exp(-2T) - \\frac{4}{9}\\exp(-3T).\n$$\n\nEither form is a valid closed-form expression in terms of $T$. By construction, this probability quantifies how a single species tree under the Multispecies Coalescent can produce three different rooted gene trees across three unlinked loci, consistent with the example dataset in Step $1$.\n\nThus, the required probability as a function of $T$ is\n$$\n\\frac{2}{3}\\exp(-2T)\\left(1 - \\frac{2}{3}\\exp(-T)\\right),\n$$\nequivalently,\n$$\n\\frac{2}{3}\\exp(-2T) - \\frac{4}{9}\\exp(-3T).\n$$", "answer": "$$\\boxed{\\frac{2}{3}\\exp(-2T)-\\frac{4}{9}\\exp(-3T)}$$", "id": "2726274"}, {"introduction": "A key challenge in modern phylogenomics is that gene tree discordance is not caused by ILS alone; other processes like hybridization and introgression can produce similar topological conflicts. This advanced practice introduces a powerful statistical approach for disentangling these signals using a mixture model. You will formulate and implement an Expectation-Maximization (EM) algorithm to estimate the proportion of loci whose topologies are better explained by introgression versus the background expectation from ILS, moving from theoretical understanding to a practical data analysis framework [@problem_id:2726261].", "problem": "Consider a single unrooted quartet of species with three possible unrooted gene-tree topologies, denoted $\\mathcal{T}_s$ (the concordant topology that matches the species tree), $\\mathcal{T}_1$, and $\\mathcal{T}_2$ (the two discordant alternatives). Under the multispecies coalescent for a symmetric quartet with internal branch length $t$ measured in coalescent units, the probability that a randomly sampled neutral locus has gene-tree topology $\\mathcal{T}_s$ is $p_s(t) = 1 - \\tfrac{2}{3} e^{-t}$, and the probabilities of each discordant topology are $p_a(t) = \\tfrac{1}{3} e^{-t}$ and $p_b(t) = \\tfrac{1}{3} e^{-t}$. Suppose that across $L$ independent loci we observe gene-tree topologies as counts $\\mathbf{n} = (n_s, n_1, n_2)$, where $n_s$ is the number of loci supporting $\\mathcal{T}_s$, $n_1$ is the number supporting $\\mathcal{T}_1$, and $n_2$ is the number supporting $\\mathcal{T}_2$, with $L = n_s + n_1 + n_2$.\n\nWe posit a two-component mixture model for the per-locus topology distribution: a component for incomplete lineage sorting (ILS) with distribution $\\mathbf{p}^{\\mathrm{ILS}}(t) = \\big(p_s(t), p_a(t), p_b(t)\\big)$ and a component for introgression-induced topologies with a known distribution $\\mathbf{q} = (q_s, q_1, q_2)$ over $\\{\\mathcal{T}_s,\\mathcal{T}_1,\\mathcal{T}_2\\}$. Let $\\pi \\in [0,1]$ be the mixing proportion (as a decimal, not a percentage) for the introgression component, so that the per-locus marginal distribution over topologies is\n$$\n\\mathbf{m}(\\pi, t) \\;=\\; (1-\\pi)\\,\\mathbf{p}^{\\mathrm{ILS}}(t) \\;+\\; \\pi\\,\\mathbf{q}.\n$$\nAssume loci are independent and identically distributed given $(\\pi,t)$, and that $\\mathbf{q}$ and $t$ are known constants for each scenario. The likelihood of $\\pi$ given the observed counts $\\mathbf{n}$ is multinomial with class probabilities $\\mathbf{m}(\\pi,t)$.\n\nYour tasks are:\n- Formulate a latent-variable model with a hidden indicator $z_\\ell \\in \\{0,1\\}$ for each locus $\\ell \\in \\{1,\\dots,L\\}$, where $z_\\ell = 1$ indicates that locus $\\ell$ arose from the introgression component and $z_\\ell = 0$ indicates the ILS component. Derive the Expectation-Maximization (EM) algorithm updates for estimating the maximum likelihood value $\\hat{\\pi}$, treating $\\mathbf{q}$ and $t$ as known. You must start from the definitions of the multispecies coalescent probabilities for a symmetric quartet and the standard complete-data log-likelihood for a finite mixture with known component distributions. Do not introduce any additional shortcut formulas beyond these bases.\n- Implement a program that, for each test case below, computes $\\hat{\\pi}$ by EM using an initialization $\\pi^{(0)} = 0.5$, iterating until the absolute change in $\\pi$ is less than $\\varepsilon = 10^{-12}$ or until a maximum of $10{,}000$ iterations is reached, whichever comes first. To ensure numerical stability, constrain iterates to remain in the closed interval $[10^{-12}, 1 - 10^{-12}]$ after each update.\n\nTest suite. For each test case, you are given: the internal branch length $t$ (in coalescent units), the introgression component distribution $\\mathbf{q}$, and the observed counts $\\mathbf{n} = (n_s, n_1, n_2)$. Treat $\\mathbf{q}$ as fixed and exactly known for each case, and compute $\\mathbf{p}^{\\mathrm{ILS}}(t)$ using the multispecies coalescent expressions above. Then run EM to estimate $\\hat{\\pi}$ from $\\mathbf{n}$.\n- Case $1$: $t = 1.0$, $\\mathbf{q} = (0, 1, 0)$, $\\mathbf{n} = (528, 386, 86)$.\n- Case $2$: $t = 0.5$, $\\mathbf{q} = (0, 1, 0)$, $\\mathbf{n} = (357, 121, 122)$.\n- Case $3$: $t = 1.5$, $\\mathbf{q} = (0, 1, 0)$, $\\mathbf{n} = (34, 763, 3)$.\n- Case $4$: $t = 0.05$, $\\mathbf{q} = (0, 1, 0)$, $\\mathbf{n} = (329, 386, 285)$.\n- Case $5$: $t = 0.8$, $\\mathbf{q} = (0, 0, 1)$, $\\mathbf{n} = (630, 135, 435)$.\n\nYour program must produce a single line of output containing the estimated mixing proportions as a comma-separated list enclosed in square brackets, with each estimate rounded to exactly six digits after the decimal point, in the order of the cases above. For example, the output must be of the form\n$[\\hat{\\pi}_1,\\hat{\\pi}_2,\\hat{\\pi}_3,\\hat{\\pi}_4,\\hat{\\pi}_5]$,\nwhere each $\\hat{\\pi}_i$ is a decimal with exactly six digits after the decimal point. No physical units are involved, and proportions must be decimals, not percentages.", "solution": "The problem requires the derivation and implementation of an Expectation-Maximization (EM) algorithm to estimate the mixing proportion, $\\pi$, in a two-component mixture model for gene-tree topologies. The model combines incomplete lineage sorting (ILS) and introgression.\n\n### Model Specification\n\nThe set of possible unrooted gene-tree topologies for a quartet is $\\{\\mathcal{T}_s, \\mathcal{T}_1, \\mathcal{T}_2\\}$.\nThe distribution of topologies is a mixture of two components:\n\n1.  **ILS Component:** The probabilities are governed by the multispecies coalescent model for a symmetric quartet with internal branch length $t$ (in coalescent units). Let $\\mathbf{p}^{\\mathrm{ILS}}(t) = (p_s(t), p_1(t), p_2(t))$, where:\n    $$ p_s(t) = 1 - \\tfrac{2}{3} e^{-t} $$\n    $$ p_1(t) = p_2(t) = \\tfrac{1}{3} e^{-t} $$\n    These are the probabilities for the concordant topology ($\\mathcal{T}_s$) and the two discordant topologies ($\\mathcal{T}_1, \\mathcal{T}_2$), respectively. For notational simplicity, we will denote $p_j(t)$ as $p_j$ for $j \\in \\{s, 1, 2\\}$, as $t$ is a known constant.\n\n2.  **Introgression Component:** This component has a known, fixed distribution over the topologies, denoted by $\\mathbf{q} = (q_s, q_1, q_2)$.\n\nThe parameter to be estimated is $\\pi \\in [0, 1]$, the mixing proportion for the introgression component. The marginal probability of observing topology $j \\in \\{s, 1, 2\\}$ is:\n$$ m_j(\\pi) = (1-\\pi)p_j + \\pi q_j $$\n\nThe observed data consist of counts $\\mathbf{n} = (n_s, n_1, n_2)$ for the three topologies across $L = n_s + n_1 + n_2$ independent loci.\n\n### Latent Variable Formulation\n\nTo derive the EM algorithm, we introduce a latent indicator variable $z_\\ell \\in \\{0, 1\\}$ for each locus $\\ell \\in \\{1, \\dots, L\\}$.\n-   $z_\\ell = 0$ if locus $\\ell$ arises from the ILS component.\n-   $z_\\ell = 1$ if locus $\\ell$ arises from the introgression component.\n\nThe observed data for a single locus $\\ell$ is its topology, which we can represent with an indicator vector $\\mathbf{y}_\\ell$ (e.g., $(1,0,0)$ for $\\mathcal{T}_s$). The complete data for locus $\\ell$ is the pair $(\\mathbf{y}_\\ell, z_\\ell)$. The probability of the complete data for one locus is:\n$$ P(\\mathbf{y}_\\ell, z_\\ell | \\pi) = [ (1-\\pi)P(\\mathbf{y}_\\ell | z_\\ell=0) ]^{1-z_\\ell} [ \\pi P(\\mathbf{y}_\\ell | z_\\ell=1) ]^{z_\\ell} $$\nIf locus $\\ell$ has topology $j$, then $P(\\mathbf{y}_\\ell=\\text{topology }j | z_\\ell=0) = p_j$ and $P(\\mathbf{y}_\\ell=\\text{topology }j | z_\\ell=1) = q_j$.\n\n### Complete-Data Log-Likelihood\n\nThe complete-data log-likelihood for all $L$ loci is the sum of the log-probabilities of each individual complete observation:\n$$ \\mathcal{L}_c(\\pi) = \\sum_{\\ell=1}^{L} \\log P(\\mathbf{y}_\\ell, z_\\ell | \\pi) = \\sum_{\\ell=1}^{L} \\left[ (1-z_\\ell) \\log(1-\\pi) + (1-z_\\ell)\\log p(\\mathbf{y}_\\ell) + z_\\ell \\log(\\pi) + z_\\ell \\log q(\\mathbf{y}_\\ell) \\right] $$\nwhere $p(\\mathbf{y}_\\ell)$ and $q(\\mathbf{y}_\\ell)$ are the probabilities of the observed topology of locus $\\ell$ under the ILS and introgression components, respectively.\n\nGrouping terms with respect to $\\pi$:\n$$ \\mathcal{L}_c(\\pi) = \\left( \\sum_{\\ell=1}^{L} (1-z_\\ell) \\right) \\log(1-\\pi) + \\left( \\sum_{\\ell=1}^{L} z_\\ell \\right) \\log(\\pi) + C $$\nwhere $C$ contains terms not dependent on $\\pi$. Let $N_0 = \\sum_{\\ell=1}^{L} (1-z_\\ell)$ and $N_1 = \\sum_{\\ell=1}^{L} z_\\ell$ be the unobserved total counts of loci from the ILS and introgression components, respectively.\n$$ \\mathcal{L}_c(\\pi) = N_0 \\log(1-\\pi) + N_1 \\log(\\pi) + C $$\n\n### Expectation-Maximization (EM) Algorithm Derivation\n\nThe EM algorithm is an iterative procedure consisting of an Expectation (E) step and a Maximization (M) step.\n\n**E-Step:**\nIn the E-step of iteration $k+1$, we compute the expectation of the complete-data log-likelihood with respect to the posterior distribution of the latent variables $Z = \\{z_\\ell\\}$, given the observed data $Y = \\{\\mathbf{y}_\\ell\\}$ and the current parameter estimate $\\pi^{(k)}$. This is the Q-function:\n$$ Q(\\pi | \\pi^{(k)}) = E_{Z|Y, \\pi^{(k)}}[\\mathcal{L}_c(\\pi)] $$\nDue to the linearity of expectation, we only need the expectation of the latent variables $z_\\ell$. Let $\\gamma_\\ell^{(k)} = E[z_\\ell | \\mathbf{y}_\\ell, \\pi^{(k)}]$. This is the posterior probability that locus $\\ell$ belongs to the introgression component, given the observed topology and the current estimate $\\pi^{(k)}$.\nUsing Bayes' theorem:\n$$ \\gamma_\\ell^{(k)} = P(z_\\ell=1 | \\mathbf{y}_\\ell, \\pi^{(k)}) = \\frac{ P(\\mathbf{y}_\\ell | z_\\ell=1) P(z_\\ell=1 | \\pi^{(k)}) }{ P(\\mathbf{y}_\\ell | \\pi^{(k)}) } $$\nThe value of $\\gamma_\\ell^{(k)}$ depends only on the topology of locus $\\ell$. For a locus with topology $j \\in \\{s, 1, 2\\}$, this responsibility is:\n$$ \\gamma_j^{(k)} = \\frac{ \\pi^{(k)} q_j }{ (1-\\pi^{(k)})p_j + \\pi^{(k)}q_j } $$\nThe Q-function becomes:\n$$ Q(\\pi | \\pi^{(k)}) = E_{Z|Y, \\pi^{(k)}}[N_0 \\log(1-\\pi) + N_1 \\log(\\pi)] + C' $$\n$$ Q(\\pi | \\pi^{(k)}) = E[N_0] \\log(1-\\pi) + E[N_1] \\log(\\pi) + C' $$\nThe expected counts are:\n$E[N_1] = E[\\sum_{\\ell=1}^L z_\\ell] = \\sum_{\\ell=1}^L E[z_\\ell | \\mathbf{y}_\\ell, \\pi^{(k)}] = \\sum_{j \\in \\{s,1,2\\}} n_j \\gamma_j^{(k)}$.\n$E[N_0] = L - E[N_1]$.\n\n**M-Step:**\nIn the M-step, we find the value of $\\pi$ that maximizes $Q(\\pi | \\pi^{(k)})$, which gives the next estimate $\\pi^{(k+1)}$. We differentiate $Q(\\pi | \\pi^{(k)})$ with respect to $\\pi$ and set it to zero:\n$$ \\frac{\\partial Q}{\\partial \\pi} = -\\frac{E[N_0]}{1-\\pi} + \\frac{E[N_1]}{\\pi} = 0 $$\nSolving for $\\pi$ gives:\n$$ \\pi = \\frac{E[N_1]}{E[N_0] + E[N_1]} = \\frac{E[N_1]}{L} $$\nThus, the update rule for $\\pi$ is:\n$$ \\pi^{(k+1)} = \\frac{1}{L} \\sum_{j \\in \\{s,1,2\\}} n_j \\gamma_j^{(k)} $$\nSubstituting the expression for $\\gamma_j^{(k)}$:\n$$ \\pi^{(k+1)} = \\frac{1}{L} \\sum_{j \\in \\{s,1,2\\}} n_j \\left( \\frac{\\pi^{(k)} q_j}{(1-\\pi^{(k)})p_j + \\pi^{(k)}q_j} \\right) $$\n\nThis iterative procedure is initiated with $\\pi^{(0)}=0.5$ and repeated until convergence, defined as $|\\pi^{(k+1)} - \\pi^{(k)}| < \\varepsilon = 10^{-12}$. To ensure numerical stability, intermediate values of $\\pi$ are constrained to $[10^{-12}, 1-10^{-12}]$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all given test cases.\n    It computes the maximum likelihood estimate of the introgression proportion pi\n    for each case using an Expectation-Maximization (EM) algorithm.\n    \"\"\"\n\n    def estimate_pi(t, q, n, pi0, tol, max_iter, clip_val):\n        \"\"\"\n        Estimates the mixing proportion pi using the EM algorithm.\n\n        Args:\n            t (float): Internal branch length in coalescent units.\n            q (tuple): The introgression component distribution (q_s, q_1, q_2).\n            n (tuple): The observed gene-tree counts (n_s, n_1, n_2).\n            pi0 (float): Initial value for pi.\n            tol (float): Convergence tolerance.\n            max_iter (int): Maximum number of iterations.\n            clip_val (float): Value for numerical stability clipping.\n\n        Returns:\n            float: The estimated mixing proportion pi.\n        \"\"\"\n        ns, n1, n2 = n\n        qs, q1, q2 = q\n        L = float(ns + n1 + n2)\n\n        # A case with no data has no basis for an estimate; return initial.\n        if L == 0:\n            return pi0\n\n        # Pre-calculate ILS probabilities (p_s, p_1, p_2)\n        # Note: p_1 = p_2\n        e_neg_t = np.exp(-t)\n        p_s = 1.0 - (2.0 / 3.0) * e_neg_t\n        p_a = (1.0 / 3.0) * e_neg_t\n        p = np.array([p_s, p_a, p_a])\n        \n        q_vec = np.array([qs, q1, q2])\n        n_vec = np.array([ns, n1, n2])\n\n        pi_k = pi0\n\n        for _ in range(max_iter):\n            # E-step: Calculate responsibilities (posterior probabilities gamma_j)\n            # gamma_j = P(locus is from introgression | locus has topology j)\n            \n            # Denominator for Bayes' rule: m_j = (1-pi)*p_j + pi*q_j\n            denom = (1.0 - pi_k) * p + pi_k * q_vec\n            \n            responsibilities = np.zeros(3)\n            # Numerator: pi * q_j\n            num = pi_k * q_vec\n            \n            # Calculate gamma_j where denom is non-zero to avoid division by zero.\n            # If denom[j] is 0, it implies n_vec[j] must be 0 for a valid model,\n            # so the contribution to the sum is 0.\n            safe_indices = denom > 1e-100 # Use a small threshold for safety\n            responsibilities[safe_indices] = num[safe_indices] / denom[safe_indices]\n\n            # M-step: Update pi\n            # Expected number of loci from the introgression component\n            n1_exp = np.sum(n_vec * responsibilities)\n            \n            pi_new = n1_exp / L\n            \n            # Enforce numerical stability constraints\n            pi_k_plus_1 = np.clip(pi_new, clip_val, 1.0 - clip_val)\n\n            # Check for convergence\n            if np.abs(pi_k_plus_1 - pi_k) < tol:\n                pi_k = pi_k_plus_1\n                break\n            \n            pi_k = pi_k_plus_1\n\n        return pi_k\n\n    # Test suite from the problem statement\n    test_cases = [\n        {'t': 1.0, 'q': (0.0, 1.0, 0.0), 'n': (528, 386, 86)},\n        {'t': 0.5, 'q': (0.0, 1.0, 0.0), 'n': (357, 121, 122)},\n        {'t': 1.5, 'q': (0.0, 1.0, 0.0), 'n': (34, 763, 3)},\n        {'t': 0.05, 'q': (0.0, 1.0, 0.0), 'n': (329, 386, 285)},\n        {'t': 0.8, 'q': (0.0, 0.0, 1.0), 'n': (630, 135, 435)}\n    ]\n\n    # Algorithm parameters\n    pi0 = 0.5\n    tolerance = 1e-12\n    max_iterations = 10000\n    clip_value = 1e-12\n\n    results = []\n    for case in test_cases:\n        pi_hat = estimate_pi(\n            case['t'], case['q'], case['n'],\n            pi0, tolerance, max_iterations, clip_value\n        )\n        results.append(pi_hat)\n        \n    # Format the output as specified: a list of strings, each with 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2726261"}]}