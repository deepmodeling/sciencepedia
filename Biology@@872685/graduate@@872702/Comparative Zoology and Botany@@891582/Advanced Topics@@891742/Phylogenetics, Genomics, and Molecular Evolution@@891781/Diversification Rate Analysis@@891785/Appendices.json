{"hands_on_practices": [{"introduction": "The pure-birth, or Yule, process is the simplest and most fundamental model of diversification. To truly understand how clades grow under this model, we must first grasp its most basic component: the time between speciation events. This practice challenges you to derive the expected waiting time to the next speciation event from first principles, building a core intuition for how the speciation rate $\\lambda$ translates into the observable tempo of evolution. [@problem_id:2567064]", "problem": "In comparative zoology and botany, one commonly models clade diversification under a pure-birth process (Yule process), in which each extant lineage independently gives rise to a new lineage (a speciation event) at a constant per-lineage rate $\\lambda$ over time. Consider a focal extant lineage observed at the present. Assume the following foundational properties, which operationally define the Yule process at the lineage level: over an infinitesimal interval of time $[t,t+\\mathrm{d}t)$, conditional on no speciation having occurred up to time $t$ on the focal lineage, the probability that a speciation event occurs on that lineage in $[t,t+\\mathrm{d}t)$ is $\\lambda\\,\\mathrm{d}t + o(\\mathrm{d}t)$; the probability of more than one event in $[t,t+\\mathrm{d}t)$ is $o(\\mathrm{d}t)$; and the process has no memory beyond the current state.\n\nLet $T$ denote the waiting time from the present to the next speciation event on the focal lineage. Starting solely from the infinitesimal rate characterization above and the independence of increments implied by the Yule process, derive the expected value $\\mathbb{E}[T]$.\n\nProvide your final result as a single closed-form analytic expression in terms of $\\lambda$ only. Do not include units in your final boxed answer. If you find multiple equivalent forms, choose one and present that single form.", "solution": "The problem requires the derivation of the expected waiting time, $\\mathbb{E}[T]$, for the next speciation event on a single focal lineage, based on the fundamental properties of a Yule process. The derivation must proceed from first principles, using the provided infinitesimal rate characterization.\n\nLet $T$ be the random variable representing the waiting time from the present ($t=0$) until the next speciation event. We seek to find the expected value of $T$, denoted $\\mathbb{E}[T]$. The core of the problem lies in first deriving the probability distribution of $T$.\n\nLet $S(t) = \\mathbb{P}(T  t)$ be the survival function of $T$. This function gives the probability that the speciation event has not occurred by time $t$. By definition, $S(0) = \\mathbb{P}(T  0) = 1$, as the waiting time must be positive.\n\nThe problem statement provides the conditional probability of a speciation event occurring in the infinitesimal time interval $[t, t+\\mathrm{d}t)$, given that no event has occurred up to time $t$. This is the definition of the hazard rate, $h(t)$. Mathematically,\n$$\nh(t) = \\lim_{\\mathrm{d}t \\to 0} \\frac{\\mathbb{P}(t  T \\leq t+\\mathrm{d}t | T  t)}{\\mathrm{d}t}\n$$\nFrom the problem statement, this conditional probability is given as $\\lambda\\,\\mathrm{d}t + o(\\mathrm{d}t)$. Therefore, the hazard rate is:\n$$\nh(t) = \\lim_{\\mathrm{d}t \\to 0} \\frac{\\lambda\\,\\mathrm{d}t + o(\\mathrm{d}t)}{\\mathrm{d}t} = \\lambda\n$$\nThe rate $\\lambda$ is constant, which is a key property of the process, indicating that it is memoryless.\n\nThe hazard rate $h(t)$ is fundamentally related to the survival function $S(t)$ and the probability density function $f(t) = -S'(t)$. The conditional probability can be expressed as:\n$$\n\\mathbb{P}(t  T \\leq t+\\mathrm{d}t | T  t) = \\frac{\\mathbb{P}((t  T \\leq t+\\mathrm{d}t) \\cap (T  t))}{\\mathbb{P}(T  t)} = \\frac{\\mathbb{P}(t  T \\leq t+\\mathrm{d}t)}{\\mathbb{P}(T  t)}\n$$\nFor an infinitesimal interval $\\mathrm{d}t$, the probability $\\mathbb{P}(t  T \\leq t+\\mathrm{d}t)$ is approximately $f(t)\\,\\mathrm{d}t$. Thus,\n$$\nh(t) = \\frac{f(t)}{S(t)}\n$$\nSince $f(t) = -\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t}$, we can write:\n$$\nh(t) = -\\frac{1}{S(t)}\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t} = -\\frac{\\mathrm{d}}{\\mathrm{d}t} \\ln(S(t))\n$$\nWe have established that $h(t) = \\lambda$. Substituting this into the equation yields a first-order ordinary differential equation for $S(t)$:\n$$\n-\\frac{1}{S(t)}\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t} = \\lambda\n$$\nRearranging the terms gives:\n$$\n\\frac{\\mathrm{d}S(t)}{S(t)} = -\\lambda\\,\\mathrm{d}t\n$$\nTo find $S(t)$, we integrate both sides of the equation from time $0$ to a general time $t$:\n$$\n\\int_{S(0)}^{S(t)} \\frac{1}{S} \\, \\mathrm{d}S = \\int_0^t -\\lambda \\, \\mathrm{d}\\tau\n$$\nThe integral of the left side is $\\ln(S(t)) - \\ln(S(0))$, and the integral of the right side is $-\\lambda t$.\n$$\n\\ln(S(t)) - \\ln(S(0)) = -\\lambda t\n$$\nUsing the initial condition $S(0)=1$, we have $\\ln(1)=0$. Therefore:\n$$\n\\ln(S(t)) = -\\lambda t\n$$\nExponentiating both sides gives the survival function:\n$$\nS(t) = \\exp(-\\lambda t)\n$$\nThis is the survival function of an exponential distribution with rate parameter $\\lambda$.\n\nNow, we can compute the expected value $\\mathbb{E}[T]$. For a non-negative random variable such as waiting time $T$, the expected value can be calculated by integrating the survival function over its support, from $0$ to $\\infty$:\n$$\n\\mathbb{E}[T] = \\int_0^\\infty S(t) \\, \\mathrm{d}t\n$$\nSubstituting the derived survival function $S(t) = \\exp(-\\lambda t)$:\n$$\n\\mathbb{E}[T] = \\int_0^\\infty \\exp(-\\lambda t) \\, \\mathrm{d}t\n$$\nThis is a standard integral. The evaluation proceeds as follows:\n$$\n\\mathbb{E}[T] = \\left[ -\\frac{1}{\\lambda} \\exp(-\\lambda t) \\right]_0^\\infty\n$$\nEvaluating the expression at the limits of integration:\n$$\n\\mathbb{E}[T] = \\lim_{t \\to \\infty} \\left(-\\frac{1}{\\lambda} \\exp(-\\lambda t)\\right) - \\left(-\\frac{1}{\\lambda} \\exp(-\\lambda \\cdot 0)\\right)\n$$\nSince $\\lambda$ is a rate, it must be positive ($\\lambda  0$). As $t \\to \\infty$, the term $\\exp(-\\lambda t)$ approaches $0$. The second term evaluates to $-\\frac{1}{\\lambda} \\exp(0) = -\\frac{1}{\\lambda}$.\n$$\n\\mathbb{E}[T] = (0) - \\left(-\\frac{1}{\\lambda}\\right) = \\frac{1}{\\lambda}\n$$\nThus, the expected waiting time to the next speciation event on the focal lineage is the reciprocal of the speciation rate $\\lambda$. This result is consistent with the general properties of an exponential distribution, which has been rigorously derived here from the provided infinitesimal characterization.", "answer": "$$\\boxed{\\frac{1}{\\lambda}}$$", "id": "2567064"}, {"introduction": "Having established the probabilistic nature of waiting times in a Yule process, we can now address a central task in comparative biology: inferring the process parameters from data. This exercise guides you in deriving the Maximum Likelihood Estimator (MLE) for the speciation rate $\\lambda$, using the sequence of waiting times observed in a phylogeny. Completing this practice provides a foundational understanding of how statistical inference is applied to diversification models, bridging the gap between theory and data analysis. [@problem_id:2567022]", "problem": "A clade evolves under a pure-birth Yule process with per-lineage speciation rate $\\lambda$, a standard model in diversification rate analysis in comparative zoology and botany. The process starts at time $0$ with $1$ lineage and is observed until the number of lineages first reaches $n$. Let $w_1, w_2, \\dots, w_{n-1}$ denote the waiting times between successive branching events that grow the process from $1$ to $n$ lineages. Under this model, when there are $k$ lineages, each lineage independently gives rise to a new lineage at rate $\\lambda$, so the total event rate is $k \\lambda$, and the waiting time to the next event is exponentially distributed. The memoryless property of the exponential distribution and the independence of lineages imply that inter-event waiting times are independent.\n\nWorking from these foundational facts about Poisson processes and exponential waiting times, and without assuming any pre-derived estimator, do the following:\n\n- Write the joint probability density of the observed waiting times $w_1, \\dots, w_{n-1}$ as a function of $\\lambda$.\n- Use the factorization theorem to identify a sufficient statistic for $\\lambda$ in terms of $w_1, \\dots, w_{n-1}$.\n- Derive the maximum likelihood estimator (MLE) of $\\lambda$ using this sufficient statistic, and express it in closed form in terms of $n$ and the $w_i$.\n\nExpress your final answer as a single closed-form expression for the MLE $\\hat{\\lambda}$. No numerical evaluation or units are required.", "solution": "The problem requires the derivation of the maximum likelihood estimator (MLE) for the per-lineage speciation rate $\\lambda$ in a pure-birth Yule process, based on the observed waiting times between successive speciation events. The derivation must proceed from first principles.\n\nThe process begins with $1$ lineage at time $t=0$ and is observed until there are $n$ lineages. The waiting times between the $(i)$-th and $(i+1)$-th speciation events are denoted by $w_i$, for $i = 1, 2, \\dots, n-1$.\n\nFirst, we establish the probability distribution for each waiting time $w_i$. The problem states that when there are $k$ lineages, the total rate of a new speciation event is $k\\lambda$. The waiting time until the next event is exponentially distributed with this rate. The waiting time $w_i$ corresponds to the interval during which the number of lineages grows from $i$ to $i+1$. Throughout this interval, there are exactly $i$ lineages. Therefore, the total rate of speciation during this interval is $i\\lambda$.\nThe waiting time $w_i$ is thus a random variable drawn from an exponential distribution with rate parameter $i\\lambda$. The probability density function (PDF) of $w_i$ is given by:\n$$f_{w_i}(w_i; \\lambda) = (i\\lambda) \\exp(-i\\lambda w_i), \\quad \\text{for } w_i \\geq 0$$\nThis holds for $i = 1, 2, \\dots, n-1$.\n\nThe problem states that the waiting times $w_1, w_2, \\dots, w_{n-1}$ are independent. The joint probability density function of these waiting times is the product of their individual PDFs. This joint PDF is also the likelihood function for $\\lambda$, which we denote by $L(\\lambda; w_1, \\dots, w_{n-1})$.\n\n$$L(\\lambda; w_1, \\dots, w_{n-1}) = \\prod_{i=1}^{n-1} f_{w_i}(w_i; \\lambda) = \\prod_{i=1}^{n-1} (i\\lambda) \\exp(-i\\lambda w_i)$$\nWe can separate the terms involving $\\lambda$ from the others:\n$$L(\\lambda; w_1, \\dots, w_{n-1}) = \\left(\\prod_{i=1}^{n-1} i\\right) \\left(\\prod_{i=1}^{n-1} \\lambda\\right) \\left(\\prod_{i=1}^{n-1} \\exp(-i\\lambda w_i)\\right)$$\n$$L(\\lambda; w_1, \\dots, w_{n-1}) = (n-1)! \\lambda^{n-1} \\exp\\left(-\\sum_{i=1}^{n-1} i\\lambda w_i\\right)$$\n$$L(\\lambda; w_1, \\dots, w_{n-1}) = (n-1)! \\lambda^{n-1} \\exp\\left(-\\lambda \\sum_{i=1}^{n-1} i w_i\\right)$$\nThis is the joint probability density of the observed waiting times.\n\nNext, we identify a sufficient statistic for $\\lambda$ using the Neyman-Fisher factorization theorem. The theorem states that a statistic $T(W)$ is sufficient for a parameter $\\theta$ if the likelihood function $L(\\theta; W)$ can be factored into a product of two functions: $L(\\theta; W) = g(T(W), \\theta) h(W)$, where $g$ depends on the data $W = (w_1, \\dots, w_{n-1})$ only through the statistic $T(W)$, and $h$ does not depend on the parameter $\\theta$.\n\nFrom our likelihood function:\n$$L(\\lambda; w_1, \\dots, w_{n-1}) = \\underbrace{\\left( \\lambda^{n-1} \\exp\\left(-\\lambda \\sum_{i=1}^{n-1} i w_i\\right) \\right)}_{g(T(W), \\lambda)} \\underbrace{\\left( (n-1)! \\right)}_{h(W)}$$\nBy setting a statistic $T(W) = \\sum_{i=1}^{n-1} i w_i$, we can see that the factorization holds. The function $h(W)$ is a constant, $(n-1)!$, and the function $g$ depends on the data only through $T(W)$. Therefore, $T(W) = \\sum_{i=1}^{n-1} i w_i$ is a sufficient statistic for $\\lambda$. This statistic represents the total time lived by all lineages combined up to the point where the $n$-th lineage appears, which is also known as the total length of the phylogenetic tree.\n\nFinally, we derive the maximum likelihood estimator (MLE) of $\\lambda$, denoted $\\hat{\\lambda}$. The MLE is the value of $\\lambda$ that maximizes the likelihood function $L(\\lambda)$. It is computationally simpler to maximize the natural logarithm of the likelihood function, the log-likelihood $\\ell(\\lambda)$, as the logarithm is a strictly increasing function.\n$$\\ell(\\lambda) = \\ln(L(\\lambda; w_1, \\dots, w_{n-1})) = \\ln\\left((n-1)! \\lambda^{n-1} \\exp\\left(-\\lambda \\sum_{i=1}^{n-1} i w_i\\right)\\right)$$\n$$\\ell(\\lambda) = \\ln((n-1)!) + \\ln(\\lambda^{n-1}) + \\ln\\left(\\exp\\left(-\\lambda \\sum_{i=1}^{n-1} i w_i\\right)\\right)$$\n$$\\ell(\\lambda) = \\ln((n-1)!) + (n-1)\\ln(\\lambda) - \\lambda \\sum_{i=1}^{n-1} i w_i$$\nTo find the maximum, we compute the first derivative of $\\ell(\\lambda)$ with respect to $\\lambda$ and set it to zero.\n$$\\frac{d\\ell}{d\\lambda} = \\frac{d}{d\\lambda}\\left(\\ln((n-1)!) + (n-1)\\ln(\\lambda) - \\lambda \\sum_{i=1}^{n-1} i w_i\\right)$$\n$$\\frac{d\\ell}{d\\lambda} = 0 + \\frac{n-1}{\\lambda} - \\sum_{i=1}^{n-1} i w_i$$\nSetting the derivative to zero to find the MLE $\\hat{\\lambda}$:\n$$\\frac{n-1}{\\hat{\\lambda}} - \\sum_{i=1}^{n-1} i w_i = 0$$\nSolving for $\\hat{\\lambda}$:\n$$\\frac{n-1}{\\hat{\\lambda}} = \\sum_{i=1}^{n-1} i w_i$$\n$$\\hat{\\lambda} = \\frac{n-1}{\\sum_{i=1}^{n-1} i w_i}$$\nTo confirm that this value corresponds to a maximum, we examine the second derivative of the log-likelihood function:\n$$\\frac{d^2\\ell}{d\\lambda^2} = \\frac{d}{d\\lambda}\\left(\\frac{n-1}{\\lambda} - \\sum_{i=1}^{n-1} i w_i\\right) = -\\frac{n-1}{\\lambda^2}$$\nSince the number of lineages $n$ must be at least $2$ for there to be any waiting times, $n-1 \\ge 1$. As $\\lambda^2  0$, the second derivative $\\frac{d^2\\ell}{d\\lambda^2}$ is strictly negative. This confirms that the log-likelihood function is concave and that our estimator $\\hat{\\lambda}$ is indeed the unique maximum likelihood estimator. The estimator is the ratio of the number of observed speciation events, $n-1$, to the total time lived by all lineages, $\\sum_{i=1}^{n-1} i w_i$.", "answer": "$$\\boxed{\\frac{n-1}{\\sum_{i=1}^{n-1} i w_i}}$$", "id": "2567022"}, {"introduction": "Beyond analytical derivations and statistical inference for simple models, a deep understanding of diversification comes from building and observing the process dynamically. This final practice moves into the computational domain, challenging you to implement a stochastic simulation of the more general birth-death process. By programming the rules of speciation and extinction, you gain an intuitive feel for how these events shape phylogenies over time and create a powerful tool for testing hypotheses or generating null models for your own research. [@problem_id:2566990]", "problem": "You will implement a Continuous-Time Markov Chain (CTMC) birth–death diversification simulator using the Stochastic Simulation Algorithm (SSA, also called Gillespie algorithm) to generate birth–death trees for comparative zoology and botany. In this context, lineages speciate (birth) at a per-lineage rate $ \\lambda $ and go extinct (death) at a per-lineage rate $ \\mu $. The state variable is the number of extant lineages $ n(t) $ at time $ t $. The fundamental base for the derivation is the standard CTMC framework for independent Poisson processes governing competing exponential clocks, together with the memoryless property of the exponential distribution and superposition of independent Poisson processes: when there are $ n $ independent and identical exponential clocks with rates $ \\lambda $ for birth and $ \\mu $ for death per lineage, the time to the next event is exponentially distributed with a total hazard equal to the sum of all active hazards, and the next event type is selected proportionally to its contribution to the total hazard.\n\nYour task is to derive from these principles the event scheduling and implement an SSA that:\n- Initializes with $ n_0 $ lineages at time $ t = 0 $.\n- At any time with $ n $ extant lineages, schedules the next event time and event type based only on $ \\lambda $, $ \\mu $, and $ n $.\n- Updates $ n $ by $ +1 $ for a birth or $ -1 $ for a death, and updates the current time accordingly.\n- Continues until a stopping criterion is met.\n\nYour stopping criterion must be the logical disjunction of the following conditions:\n- Time exceeds a maximum horizon $ T_{\\max} $.\n- All lineages go extinct, so $ n = 0 $ at some time.\n- A safety cap for computational tractability is reached with $ n \\ge N_{\\max} $, where $ N_{\\max} $ is a user-specified upper bound on the number of extant lineages to prevent explosive growth in supercritical regimes.\n\nTreat all lineages as exchangeable and identically and independently distributed with respect to their event hazards, and do not condition on survival or impose any additional constraints beyond the stopping criteria above.\n\nYou will produce a program that, for each test case, runs a single stochastic simulation with a fixed pseudorandom seed and returns a triplet of integers summarizing the outcome:\n- The number of extant lineages at termination, $ n_{\\text{final}} $.\n- The total number of birth events that occurred, $ B $.\n- The total number of death events that occurred, $ D $.\n\nEvent times are in arbitrary time units; your output is dimensionless counts. Do not include any physical units in the output.\n\nFrom first principles, derive:\n- How to schedule waiting times between events given $ n $, $ \\lambda $, and $ \\mu $.\n- How to choose the event type and the affected lineage (given exchangeability).\n- Why the stopping criterion above ensures a well-defined simulation even in supercritical regimes.\n\nThen implement the algorithm and run it on the following test suite of parameter sets. Each test case is a tuple $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) $:\n- Case A (general supercritical): $ (0.4, 0.2, 5.0, 1, 2000, 42) $.\n- Case B (pure-birth or Yule limit): $ (1.0, 0.0, 1.0, 1, 2000, 7) $.\n- Case C (pure-death): $ (0.0, 0.5, 3.0, 3, 2000, 123) $.\n- Case D (supercritical with cap reached): $ (2.0, 0.1, 10.0, 1, 50, 1) $.\n- Case E (null dynamics): $ (0.0, 0.0, 2.0, 5, 100, 99) $.\n\nFor each case, run exactly one simulation replication with the given seed, and output a single line containing a comma-separated list enclosed in square brackets where each element is itself a list $ [n_{\\text{final}},B,D] $ for that case, in the same order as specified above. There must be no spaces anywhere in the line. For example, the format must be exactly like:\n[[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15]]\n\nYour program must be completely deterministic with respect to the provided seeds and must not require any user input or external files.", "solution": "We model lineage diversification as a Continuous-Time Markov Chain (CTMC) with independent and identically distributed per-lineage birth and death hazards. At any time $ t $, if there are $ n(t) = n $ extant lineages, each lineage contributes two possible event channels: a birth with per-lineage rate $ \\lambda $ and a death with per-lineage rate $ \\mu $. The system thus has $ n $ independent and identically distributed potential birth events and $ n $ independent and identically distributed potential death events.\n\nFundamental base:\n- Independent Poisson processes and the memoryless property imply that if $ X_1, \\dots, X_k $ are independent exponential random variables with rates $ r_1, \\dots, r_k $, then $ \\min(X_1,\\dots,X_k) $ is exponentially distributed with rate $ r_1 + \\dots + r_k $, and the probability that the minimum corresponds to process $ i $ equals $ r_i / (r_1 + \\dots + r_k) $. This is the superposition property of Poisson processes and the basis of the Stochastic Simulation Algorithm (SSA).\n- The CTMC jump chain evolves by selecting the next event time as an exponential waiting time with parameter equal to the total exit rate from the current state, and then selecting the event type according to relative rates.\n\nEvent scheduling derivation:\n- With $ n $ extant lineages, there are $ n $ birth channels each with rate $ \\lambda $ and $ n $ death channels each with rate $ \\mu $. The total rate is therefore\n$$ R(n) = n \\lambda + n \\mu = n (\\lambda + \\mu). $$\n- The waiting time $ \\Delta t $ to the next event is exponential with rate $ R(n) $, that is, $ \\Delta t \\sim \\text{Exponential}(R(n)) $.\n- Conditional on an event occurring, the probability it is a birth is the total birth rate divided by the total rate,\n$$ \\mathbb{P}(\\text{birth} \\mid n) = \\frac{n \\lambda}{n (\\lambda + \\mu)} = \\frac{\\lambda}{\\lambda + \\mu}, $$\nand the probability it is a death is\n$$ \\mathbb{P}(\\text{death} \\mid n) = \\frac{n \\mu}{n (\\lambda + \\mu)} = \\frac{\\mu}{\\lambda + \\mu}. $$\n- Exchangeability across lineages implies that, given the event type, the affected lineage is uniformly random among the $ n $ extant lineages, because all contribute identically to the hazard.\n\nAlgorithm design (Stochastic Simulation Algorithm):\n- Initialize time $ t \\leftarrow 0 $, number of extant lineages $ n \\leftarrow n_0 $, and counters $ B \\leftarrow 0 $ and $ D \\leftarrow 0 $ for births and deaths. Maintain a list of extant lineage identifiers, but because all lineages are exchangeable and only counts are needed for the output, it suffices to track $ n $; however, we can also maintain explicit identifiers to make lineage selection explicit.\n- While none of the stopping criteria holds, compute the total rate $ R(n) = n (\\lambda + \\mu) $.\n    - If $ R(n) = 0 $ (for example, $ \\lambda = 0 $ and $ \\mu = 0 $, or $ n = 0 $), then no further events can occur; terminate.\n    - Sample a waiting time $ \\Delta t $ from an exponential distribution with rate $ R(n) $. If $ t + \\Delta t  T_{\\max} $, then the next event would occur beyond the horizon; terminate without applying the event.\n    - Otherwise, set $ t \\leftarrow t + \\Delta t $, then select the event type: sample a uniform random variable $ U \\in (0,1) $. If $ U  \\lambda / (\\lambda + \\mu) $, treat the event as a birth; otherwise treat it as a death.\n    - For a birth, increment $ B \\leftarrow B + 1 $ and $ n \\leftarrow n + 1 $.\n    - For a death, increment $ D \\leftarrow D + 1 $ and $ n \\leftarrow n - 1 $.\n- After each event, check the stopping criteria: if $ n = 0 $, terminate due to extinction; if $ n \\ge N_{\\max} $, terminate due to safety cap; if $ t \\ge T_{\\max} $, terminate due to time limit. Because we check $ t + \\Delta t $ before applying an event, the $ t \\ge T_{\\max} $ condition will occur naturally when no further events can occur within the horizon.\n\nWhy these stopping criteria ensure a well-defined simulation:\n- If $ \\lambda \\le \\mu $, the process is critical or subcritical on average and will not explode in finite time; the horizon $ T_{\\max} $ and extinction boundary $ n = 0 $ suffice.\n- If $ \\lambda  \\mu $, the process is supercritical and can grow rapidly; bounding $ n $ by $ N_{\\max} $ guarantees that the algorithm terminates in finite steps even if the horizon is very large. This acts as a truncation that preserves statistical coherence up to the cap.\n\nEdge cases:\n- If $ \\lambda = 0 $ and $ \\mu  0 $, the process is pure death; the algorithm will eventually hit $ n = 0 $ or reach $ T_{\\max} $ if started with $ n_0  0 $.\n- If $ \\lambda  0 $ and $ \\mu = 0 $, the process is pure birth (Yule); growth may be fast, so $ N_{\\max} $ prevents computational blow-up.\n- If $ \\lambda = 0 $ and $ \\mu = 0 $, then $ R(n) = 0 $ for any $ n $, so no events can occur; the state remains $ n = n_0 $ until $ T_{\\max} $; the algorithm detects $ R(n) = 0 $ and terminates immediately.\n\nTest suite and outputs:\n- For each case, we use a fixed pseudorandom seed so the simulation is reproducible. The program outputs a single line with no spaces containing a list of the results for the five cases, in order, where each result is the list $ [n_{\\text{final}}, B, D] $ of integers. The cases are:\n    - Case A: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (0.4, 0.2, 5.0, 1, 2000, 42) $.\n    - Case B: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (1.0, 0.0, 1.0, 1, 2000, 7) $.\n    - Case C: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (0.0, 0.5, 3.0, 3, 2000, 123) $.\n    - Case D: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (2.0, 0.1, 10.0, 1, 50, 1) $.\n    - Case E: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (0.0, 0.0, 2.0, 5, 100, 99) $.\n\nComputational considerations:\n- Each event requires $ \\mathcal{O}(1) $ work. The number of events up to $ T_{\\max} $ is random but almost surely finite under the cap $ N_{\\max} $ and finite $ T_{\\max} $.\n- Using a high-quality pseudorandom number generator and fixed seeds ensures reproducibility.\n\nThe implementation follows these steps exactly and adheres to the specified output format with no spaces, for deterministic evaluation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_birth_death(lambda_rate, mu_rate, T_max, n0, N_max, seed):\n    \"\"\"\n    Simulate a birth-death process using a Gillespie-style SSA.\n\n    Parameters:\n        lambda_rate (float): per-lineage birth rate (lambda)\n        mu_rate (float): per-lineage death rate (mu)\n        T_max (float): time horizon\n        n0 (int): initial number of lineages\n        N_max (int): safety cap for maximum number of extant lineages\n        seed (int): random seed for reproducibility\n\n    Returns:\n        (n_final, births, deaths): tuple of integers\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    t = 0.0\n    n = int(n0)\n    births = 0\n    deaths = 0\n\n    # Main SSA loop\n    while True:\n        # Check stopping criteria at loop top to handle initial conditions like n0==0\n        if n == 0:\n            break\n        if n >= N_max:\n            break\n        if t >= T_max:\n            break\n\n        total_rate = n * (lambda_rate + mu_rate)\n\n        # If no events can occur, terminate.\n        if total_rate = 0.0:\n            break\n\n        # Sample waiting time to next event\n        dt = rng.exponential(1.0 / total_rate)\n\n        # If next event occurs beyond T_max, stop without applying it\n        if t + dt > T_max:\n            break\n\n        # Advance time\n        t += dt\n\n        # Decide event type: birth with probability lambda/(lambda+mu)\n        if (lambda_rate + mu_rate) > 0.0:\n            p_birth = lambda_rate / (lambda_rate + mu_rate)\n        else:\n            p_birth = 0.0  # Should not happen because total_rate > 0 implies lambda+mu>0\n\n        if rng.random()  p_birth:\n            # Birth event: choose affected lineage uniformly (exchangeable)\n            # Since all lineages are identical and only counts are needed, we do not need explicit IDs.\n            births += 1\n            n += 1\n        else:\n            # Death event\n            deaths += 1\n            n -= 1\n\n        # Loop continues; stopping criteria are checked at top.\n\n    n_final = n\n    return int(n_final), int(births), int(deaths)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (lambda, mu, T_max, n0, N_max, seed)\n    test_cases = [\n        (0.4, 0.2, 5.0, 1, 2000, 42),   # Case A: general supercritical\n        (1.0, 0.0, 1.0, 1, 2000, 7),    # Case B: pure birth (Yule)\n        (0.0, 0.5, 3.0, 3, 2000, 123),  # Case C: pure death\n        (2.0, 0.1, 10.0, 1, 50, 1),     # Case D: supercritical with cap\n        (0.0, 0.0, 2.0, 5, 100, 99),    # Case E: null dynamics\n    ]\n\n    results = []\n    for params in test_cases:\n        lam, mu, Tmax, n0, Nmax, seed = params\n        n_final, births, deaths = simulate_birth_death(lam, mu, Tmax, n0, Nmax, seed)\n        results.append([n_final, births, deaths])\n\n    # Format output with no spaces as required: [[a,b,c],[d,e,f],...]\n    inner = \",\".join(\"[\" + \",\".join(map(str, res)) + \"]\" for res in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2566990"}]}