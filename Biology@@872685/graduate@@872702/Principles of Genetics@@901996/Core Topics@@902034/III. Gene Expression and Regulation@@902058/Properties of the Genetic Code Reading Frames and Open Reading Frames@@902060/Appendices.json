{"hands_on_practices": [{"introduction": "Before we can identify genuine protein-coding genes in a genome, we must first understand the statistical properties of random sequences. This practice explores a fundamental null model by calculating the expected length of an open reading frame (ORF) that would occur by chance. By parameterizing this model with genomic GC-content ($g$), you will directly investigate how base composition, a key feature of any genome, influences the landscape of random, non-functional ORFs [@problem_id:2843265].", "problem": "A long, double-stranded Deoxyribonucleic Acid (DNA) sequence is generated by an independent and identically distributed (IID) process over nucleotides with base frequencies $p_A$, $p_C$, $p_G$, $p_T$, where $p_A + p_C + p_G + p_T = 1$. Consider translation on one strand in a fixed reading frame in the $5' \\to 3'$ direction, where in-frame stops are recognized only at triplet boundaries. In the standard genetic code, the three stop codons are $\\text{TAA}$, $\\text{TAG}$, and $\\text{TGA}$. Define the per-codon stop probability in this frame as $p_{\\text{stop}}$.\n\n- Using only the independence assumption and the definition of a codon as a triplet read left-to-right, express $P(\\text{TAA})$, $P(\\text{TAG})$, and $P(\\text{TGA})$ in terms of $p_A$, $p_C$, $p_G$, $p_T$, and hence obtain $p_{\\text{stop}}$.\n\n- Now parameterize nucleotide composition by the Guanine-Cytosine (GC) content $g \\in [0,1]$ under strand-symmetric composition, assuming $p_G = p_C = g/2$ and $p_A = p_T = (1-g)/2$. Express $p_{\\text{stop}}$ as a function of $g$.\n\n- An open reading frame (ORF) is defined here as the maximal contiguous run of sense codons (that is, non-stop codons) encountered before the first in-frame stop codon. Under the IID assumptions above, successive non-overlapping codons are IID with per-codon stop probability $p_{\\text{stop}}(g)$. From first principles, derive the expected ORF length in codons, denoted $L(g)$, as a function of $g$.\n\nProvide your final answer as a single, fully simplified, closed-form analytic expression for $L(g)$. No numerical approximation or rounding is required. Do not include any units in your final answer.", "solution": "The problem statement has been validated against the specified criteria and is found to be valid. It is scientifically grounded in the principles of molecular genetics and probability theory, is well-posed with all necessary information provided, and is formulated objectively. We may proceed with the solution.\n\nThe problem requires a derivation in three parts. We will address each in sequence.\n\nPart 1: Expression for the per-codon stop probability, $p_{\\text{stop}}$.\nThe DNA sequence is generated by an independent and identically distributed (IID) process. This means the probability of any specific nucleotide at any position is independent of all other nucleotides. A codon is a triplet of nucleotides. The probability of observing a specific codon is the product of the probabilities of its constituent nucleotides.\n\nThe three stop codons in the standard genetic code are $\\text{TAA}$, $\\text{TAG}$, and $\\text{TGA}$. Their probabilities are calculated as follows:\nThe probability of codon $\\text{TAA}$ is $P(\\text{TAA}) = p_T \\cdot p_A \\cdot p_A = p_T p_A^{2}$.\nThe probability of codon $\\text{TAG}$ is $P(\\text{TAG}) = p_T \\cdot p_A \\cdot p_G = p_T p_A p_G$.\nThe probability of codon $\\text{TGA}$ is $P(\\text{TGA}) = p_T \\cdot p_G \\cdot p_A = p_T p_G p_A$.\n\nThe per-codon stop probability, $p_{\\text{stop}}$, is the sum of the probabilities of these three mutually exclusive events for any given codon.\n$$p_{\\text{stop}} = P(\\text{TAA}) + P(\\text{TAG}) + P(\\text{TGA})$$\n$$p_{\\text{stop}} = p_T p_A^{2} + p_T p_A p_G + p_T p_G p_A$$\nFactoring out common terms, we get:\n$$p_{\\text{stop}} = p_T p_A (p_A + p_G + p_G) = p_T p_A (p_A + 2p_G)$$\n\nPart 2: Expression for $p_{\\text{stop}}$ as a function of GC-content, $g$.\nThe problem introduces a parameterization based on GC-content, $g \\in [0,1]$, under the assumption of strand-symmetric composition. The base frequencies are given as:\n$p_G = p_C = \\frac{g}{2}$\n$p_A = p_T = \\frac{1-g}{2}$\n\nWe substitute these expressions into the formula for $p_{\\text{stop}}$:\n$$p_{\\text{stop}}(g) = \\left(\\frac{1-g}{2}\\right) \\left(\\frac{1-g}{2}\\right) \\left[ \\left(\\frac{1-g}{2}\\right) + 2\\left(\\frac{g}{2}\\right) \\right]$$\nSimplifying this expression:\n$$p_{\\text{stop}}(g) = \\left(\\frac{1-g}{2}\\right)^{2} \\left[ \\frac{1-g}{2} + g \\right]$$\n$$p_{\\text{stop}}(g) = \\frac{(1-g)^{2}}{4} \\left[ \\frac{1-g+2g}{2} \\right]$$\n$$p_{\\text{stop}}(g) = \\frac{(1-g)^{2}}{4} \\left[ \\frac{1+g}{2} \\right]$$\n$$p_{\\text{stop}}(g) = \\frac{(1-g)^{2}(1+g)}{8}$$\nThis expression can be expanded for later use:\n$$(1-g)^{2}(1+g) = (1 - 2g + g^{2})(1+g) = 1 - 2g + g^{2} + g - 2g^{2} + g^{3} = 1 - g - g^{2} + g^{3}$$\nSo, an alternative form is $p_{\\text{stop}}(g) = \\frac{1 - g - g^{2} + g^{3}}{8}$.\n\nPart 3: Derivation of the expected ORF length, $L(g)$.\nAn open reading frame (ORF) is defined as a sequence of sense (non-stop) codons terminated by the first in-frame stop codon. The length of the ORF is the number of sense codons *before* this first stop codon.\n\nThe codons are IID. Each codon is a Bernoulli trial where \"success\" is observing a stop codon with probability $p_{\\text{stop}}(g)$, and \"failure\" is observing a sense codon with probability $p_{\\text{sense}}(g) = 1 - p_{\\text{stop}}(g)$.\n\nLet the random variable $X$ denote the length of the ORF in codons. The event $\\{X=k\\}$, for $k \\in \\{0, 1, 2, \\dots\\}$, corresponds to observing a sequence of $k$ sense codons followed by one stop codon. The probability of this event is:\n$$P(X=k) = (p_{\\text{sense}})^{k} \\cdot p_{\\text{stop}} = (1 - p_{\\text{stop}})^{k} p_{\\text{stop}}$$\nThis is the probability mass function for a geometric distribution defined on the set of non-negative integers $\\{0, 1, 2, \\dots\\}$.\n\nThe expected value of a random variable $X$ following this distribution is given by $E[X] = \\frac{1-p_{\\text{stop}}}{p_{\\text{stop}}}$.\nWe are asked to find the expected ORF length, $L(g)$, which is precisely this expectation, $E[X]$, with $p_{\\text{stop}}$ being a function of $g$.\n$$L(g) = E[X] = \\frac{1-p_{\\text{stop}}(g)}{p_{\\text{stop}}(g)}$$\nThis can also be written as $L(g) = \\frac{1}{p_{\\text{stop}}(g)} - 1$.\n\nNow, we substitute the expression for $p_{\\text{stop}}(g)$ into the formula for $L(g)$:\n$$L(g) = \\frac{1 - \\frac{(1-g)^{2}(1+g)}{8}}{\\frac{(1-g)^{2}(1+g)}{8}}$$\n$$L(g) = \\frac{\\frac{8 - (1-g)^{2}(1+g)}{8}}{\\frac{(1-g)^{2}(1+g)}{8}}$$\nThe factor of $\\frac{1}{8}$ in the numerator and denominator cancels:\n$$L(g) = \\frac{8 - (1-g)^{2}(1+g)}{(1-g)^{2}(1+g)}$$\nUsing the expanded polynomial form we found earlier, $(1-g)^{2}(1+g) = 1 - g - g^{2} + g^{3}$, we can write the final expression as a rational function of polynomials:\n$$L(g) = \\frac{8 - (1 - g - g^{2} + g^{3})}{1 - g - g^{2} + g^{3}}$$\n$$L(g) = \\frac{8 - 1 + g + g^{2} - g^{3}}{1 - g - g^{2} + g^{3}}$$\n$$L(g) = \\frac{7 + g + g^{2} - g^{3}}{1 - g - g^{2} + g^{3}}$$\nThis is the fully simplified, closed-form analytic expression for the expected ORF length as a function of GC-content $g$.", "answer": "$$\\boxed{\\frac{7+g+g^{2}-g^{3}}{1-g-g^{2}+g^{3}}}$$", "id": "2843265"}, {"introduction": "While the random sequence model provides a useful baseline, biological sequences are sculpted by selection and are far from random. A prominent example is codon usage bias, where synonymous codons encoding the same amino acid appear at different frequencies. This exercise introduces Relative Synonymous Codon Usage (RSCU), a standard metric to quantify this bias, allowing you to analyze codon preferences within a hypothetical gene and understand how cells might optimize translation [@problem_id:2843258].", "problem": "A coding sequence is translated in a fixed reading frame, partitioning the nucleotide string into non-overlapping triplet codons, and an open reading frame (ORF) is defined as a contiguous set of codons from a start codon to a stop codon without interruption in the same frame. In the validated longest open reading frame (ORF) of a bacterial gene (standard genetic code), codon counts for selected synonymous families were tabulated in the $+1$ reading frame as follows (codon families are listed with their observed counts in this ORF; all other amino acids and codons not listed can be ignored for this analysis):\n\n- Proline (CCN): CCT $6$, CCC $2$, CCA $4$, CCG $2$.\n- Alanine (GCN): GCT $3$, GCC $9$, GCA $2$, GCG $0$.\n- Glycine (GGN): GGT $5$, GGC $1$, GGA $4$, GGG $8$.\n- Valine (GTN): GTT $2$, GTC $10$, GTA $0$, GTG $4$.\n- Threonine (ACN): ACT $4$, ACC $4$, ACA $4$, ACG $0$.\n- Phenylalanine (TTT/TTC): TTT $7$, TTC $1$.\n- Isoleucine (ATT/ATC/ATA): ATT $3$, ATC $9$, ATA $0$.\n- Leucine (TTA/TTG/CTT/CTC/CTA/CTG): TTA $1$, TTG $5$, CTT $2$, CTC $7$, CTA $1$, CTG $14$.\n\nStarting from the degeneracy of the standard genetic code and the concept of a fixed reading frame and open reading frame, use the definition of Relative Synonymous Codon Usage (RSCU) as a normalization against the equal-usage null model within each synonymous family to compute RSCU values for every codon listed. Define a codon as overrepresented if its RSCU is strictly greater than $1$, underrepresented if strictly less than $1$, and neither if exactly equal to $1$.\n\nWhat is the total number of overrepresented codons across all the listed synonymous families, according to this criterion? Provide your answer as a single integer. No rounding is required.", "solution": "The problem statement is validated as scientifically grounded, well-posed, and objective. It provides a clear definition of Relative Synonymous Codon Usage (RSCU) and presents a complete set of codon count data for a series of synonymous families. The task is to compute the RSCU for each codon and determine how many are \"overrepresented,\" defined as having an RSCU value strictly greater than $1$. The problem is a direct and standard application of principles in bioinformatics and molecular genetics.\n\nThe Relative Synonymous Codon Usage (RSCU) for a specific codon $i$ within a synonymous family of $n$ codons is defined as the ratio of its observed count ($x_i$) to its expected count under a model of uniform usage. The total count for the amino acid is $\\sum_{j=1}^{n} x_j$, so the expected count for any given codon is $\\frac{1}{n} \\sum_{j=1}^{n} x_j$. The RSCU is therefore calculated as:\n$$\n\\text{RSCU}_i = \\frac{x_i}{\\frac{1}{n} \\sum_{j=1}^{n} x_j} = \\frac{n \\cdot x_i}{\\sum_{j=1}^{n} x_j}\n$$\nA codon is overrepresented if $\\text{RSCU}_i > 1$. We will systematically analyze each amino acid family provided.\n\nProline (Pro): This family has a degeneracy of $n=4$. The codons and their counts are: CCT ($6$), CCC ($2$), CCA ($4$), CCG ($2$).\nThe total count is $\\sum x_j = 6 + 2 + 4 + 2 = 14$.\nThe expected count per codon is $\\frac{14}{4} = 3.5$. A codon is overrepresented if its count is greater than $3.5$.\n- CCT: count is $6 > 3.5$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 6}{14} = \\frac{12}{7} > 1$)\n- CCC: count is $2 < 3.5$. Underrepresented.\n- CCA: count is $4 > 3.5$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 4}{14} = \\frac{8}{7} > 1$)\n- CCG: count is $2 < 3.5$. Underrepresented.\nNumber of overrepresented codons for Proline: $2$.\n\nAlanine (Ala): This family has a degeneracy of $n=4$. The codons and their counts are: GCT ($3$), GCC ($9$), GCA ($2$), GCG ($0$).\nThe total count is $\\sum x_j = 3 + 9 + 2 + 0 = 14$.\nThe expected count per codon is $\\frac{14}{4} = 3.5$.\n- GCT: count is $3 < 3.5$. Underrepresented.\n- GCC: count is $9 > 3.5$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 9}{14} = \\frac{18}{7} > 1$)\n- GCA: count is $2 < 3.5$. Underrepresented.\n- GCG: count is $0 < 3.5$. Underrepresented.\nNumber of overrepresented codons for Alanine: $1$.\n\nGlycine (Gly): This family has a degeneracy of $n=4$. The codons and their counts are: GGT ($5$), GGC ($1$), GGA ($4$), GGG ($8$).\nThe total count is $\\sum x_j = 5 + 1 + 4 + 8 = 18$.\nThe expected count per codon is $\\frac{18}{4} = 4.5$.\n- GGT: count is $5 > 4.5$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 5}{18} = \\frac{10}{9} > 1$)\n- GGC: count is $1 < 4.5$. Underrepresented.\n- GGA: count is $4 < 4.5$. Underrepresented.\n- GGG: count is $8 > 4.5$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 8}{18} = \\frac{16}{9} > 1$)\nNumber of overrepresented codons for Glycine: $2$.\n\nValine (Val): This family has a degeneracy of $n=4$. The codons and their counts are: GTT ($2$), GTC ($10$), GTA ($0$), GTG ($4$).\nThe total count is $\\sum x_j = 2 + 10 + 0 + 4 = 16$.\nThe expected count per codon is $\\frac{16}{4} = 4$. A codon is overrepresented if its count is strictly greater than $4$.\n- GTT: count is $2 < 4$. Underrepresented.\n- GTC: count is $10 > 4$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 10}{16} = 2.5 > 1$)\n- GTA: count is $0 < 4$. Underrepresented.\n- GTG: count is $4$. Not strictly greater, so it is not overrepresented. ($\\text{RSCU} = \\frac{4 \\times 4}{16} = 1$)\nNumber of overrepresented codons for Valine: $1$.\n\nThreonine (Thr): This family has a degeneracy of $n=4$. The codons and their counts are: ACT ($4$), ACC ($4$), ACA ($4$), ACG ($0$).\nThe total count is $\\sum x_j = 4 + 4 + 4 + 0 = 12$.\nThe expected count per codon is $\\frac{12}{4} = 3$.\n- ACT: count is $4 > 3$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 4}{12} = \\frac{4}{3} > 1$)\n- ACC: count is $4 > 3$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 4}{12} = \\frac{4}{3} > 1$)\n- ACA: count is $4 > 3$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 4}{12} = \\frac{4}{3} > 1$)\n- ACG: count is $0 < 3$. Underrepresented.\nNumber of overrepresented codons for Threonine: $3$.\n\nPhenylalanine (Phe): This family has a degeneracy of $n=2$. The codons and their counts are: TTT ($7$), TTC ($1$).\nThe total count is $\\sum x_j = 7 + 1 = 8$.\nThe expected count per codon is $\\frac{8}{2} = 4$.\n- TTT: count is $7 > 4$. Overrepresented. ($\\text{RSCU} = \\frac{2 \\times 7}{8} = 1.75 > 1$)\n- TTC: count is $1 < 4$. Underrepresented.\nNumber of overrepresented codons for Phenylalanine: $1$.\n\nIsoleucine (Ile): This family has a degeneracy of $n=3$. The codons and their counts are: ATT ($3$), ATC ($9$), ATA ($0$).\nThe total count is $\\sum x_j = 3 + 9 + 0 = 12$.\nThe expected count per codon is $\\frac{12}{3} = 4$.\n- ATT: count is $3 < 4$. Underrepresented.\n- ATC: count is $9 > 4$. Overrepresented. ($\\text{RSCU} = \\frac{3 \\times 9}{12} = 2.25 > 1$)\n- ATA: count is $0 < 4$. Underrepresented.\nNumber of overrepresented codons for Isoleucine: $1$.\n\nLeucine (Leu): This family has a degeneracy of $n=6$. The codons and their counts are: TTA ($1$), TTG ($5$), CTT ($2$), CTC ($7$), CTA ($1$), CTG ($14$).\nThe total count is $\\sum x_j = 1 + 5 + 2 + 7 + 1 + 14 = 30$.\nThe expected count per codon is $\\frac{30}{6} = 5$. A codon is overrepresented if its count is strictly greater than $5$.\n- TTA: count is $1 < 5$. Underrepresented.\n- TTG: count is $5$. Not strictly greater, so it is not overrepresented. ($\\text{RSCU} = \\frac{6 \\times 5}{30} = 1$)\n- CTT: count is $2 < 5$. Underrepresented.\n- CTC: count is $7 > 5$. Overrepresented. ($\\text{RSCU} = \\frac{6 \\times 7}{30} = 1.4 > 1$)\n- CTA: count is $1 < 5$. Underrepresented.\n- CTG: count is $14 > 5$. Overrepresented. ($\\text{RSCU} = \\frac{6 \\times 14}{30} = 2.8 > 1$)\nNumber of overrepresented codons for Leucine: $2$.\n\nTo obtain the final answer, we sum the number of overrepresented codons from each family:\nTotal overrepresented codons = $2 (\\text{Pro}) + 1 (\\text{Ala}) + 2 (\\text{Gly}) + 1 (\\text{Val}) + 3 (\\text{Thr}) + 1 (\\text{Phe}) + 1 (\\text{Ile}) + 2 (\\text{Leu})$.\nTotal = $2 + 1 + 2 + 1 + 3 + 1 + 1 + 2 = 13$.", "answer": "$$\\boxed{13}$$", "id": "2843258"}, {"introduction": "The genetic code's structure allows for remarkable complexity, such as overlapping genes where a single DNA sequence encodes multiple proteins in different reading frames. This creates strong evolutionary constraints, as a single mutation can affect two separate gene products. This final practice moves from statistical analysis to computational implementation, challenging you to design an algorithm that identifies synonymous mutations that are 'safe' in two overlapping reading frames, a classic problem in computational virology and synthetic biology [@problem_id:2843175].", "problem": "Construct a complete, runnable program that, given a deoxyribonucleic acid (DNA) sequence and two reading frames on the same strand, enumerates all single-nucleotide synonymous substitutions in one frame that do not introduce a stop codon or a nonsynonymous change in the overlapping frame. The algorithm must be derived from fundamental definitions of the Central Dogma of Molecular Biology (DNA to messenger ribonucleic acid to protein), the standard genetic code, and the formal notion of a reading frame and an open reading frame.\n\nThe fundamental base comprises:\n- The DNA alphabet $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$.\n- Codons are consecutive triplets of nucleotides, and the standard nuclear genetic code is a mapping $g : \\Sigma^3 \\rightarrow \\mathcal{A} \\cup \\{\\ast\\}$ where $\\mathcal{A}$ is the set of amino acids and $\\ast$ denotes a stop signal.\n- A reading frame with offset $r \\in \\{0,1,2\\}$ on a sequence $S$ defines codon starts at indices $k$ such that $k \\equiv r \\pmod{3}$, and each codon is the triplet $S[k]S[k+1]S[k+2]$ when these indices lie within the region of interest.\n- An open reading frame (ORF) is a contiguous series of codons that encode amino acids without internal stop codons.\n- A single-nucleotide substitution at position $i$ replacing nucleotide $b \\in \\Sigma$ with $b' \\in \\Sigma \\setminus \\{b\\}$ is synonymous in a given frame if the amino acid encoded by the codon containing $i$ remains unchanged after the substitution.\n\nFormally, let the inputs be a DNA string $S$ over $\\Sigma$, a primary frame offset $p \\in \\{0,1,2\\}$, an overlapping frame offset $q \\in \\{0,1,2\\}$, and a half-open index interval $[s,e)$ with $s,e \\in \\mathbb{Z}$, $0 \\le s < e \\le |S|$. A position $i \\in \\{s,s+1,\\dots,e-1\\}$ participates in a valid codon in frame offset $r$ if there is a unique codon start $k$ with $k \\equiv r \\pmod{3}$, $k \\le i \\le k+2$, and $s \\le k$ and $k+2 < e$. For a candidate substitution $(i,b \\to b')$ to be included in the output set, all of the following must hold:\n- The primary-frame codon containing $i$ and the overlapping-frame codon containing $i$ both exist entirely within $[s,e)$.\n- The unmutated codon in the primary frame encodes $g(\\cdot) \\in \\mathcal{A}$ (not $\\ast$).\n- The unmutated codon in the overlapping frame encodes $g(\\cdot) \\in \\mathcal{A}$ (not $\\ast$).\n- After substituting $b$ with $b'$ at position $i$, the primary-frame codon’s amino acid is unchanged (synonymous in the primary frame).\n- After substituting $b$ with $b'$ at position $i$, the overlapping-frame codon’s amino acid is unchanged and is not a stop codon (no stop or nonsynonymous change is introduced in the overlapping frame).\n\nYour program must:\n- Implement the standard nuclear genetic code for $g$ explicitly.\n- Enumerate all valid single-nucleotide substitutions satisfying the above constraints.\n- Encode each substitution as a triple $[i', \\phi(b), \\phi(b')]$, where $i' = i - s$ is the $0$-based index within the region $[s,e)$, and $\\phi$ is the bijection $\\phi(\\text{A})=0$, $\\phi(\\text{C})=1$, $\\phi(\\text{G})=2$, $\\phi(\\text{T})=3$.\n- Sort the triples by increasing $i'$, breaking ties by increasing $\\phi(b')$.\n\nDesign your algorithm using only the definitions above, without shortcut formulas. Be careful to enforce codon completeness within $[s,e)$ and to exclude any site where the unmutated codon in either frame is a stop. Assume the sequence is on the same strand for both frames; do not consider reverse complement frames.\n\nTest Suite. Use the following test cases, each specified as a $5$-tuple $(S,p,q,s,e)$:\n- Case $1$: $S=\\text{\"GGTTATGGTTAT\"}$, $p=0$, $q=2$, $s=0$, $e=12$.\n- Case $2$: $S=\\text{\"GGTGGTGGTGGTGGTGGT\"}$, $p=0$, $q=1$, $s=0$, $e=18$.\n- Case $3$: $S=\\text{\"GGTTATGGT\"}$, $p=0$, $q=2$, $s=1$, $e=8$.\n- Case $4$: $S=\\text{\"GGTGAT\"}$, $p=0$, $q=2$, $s=0$, $e=6$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element is the list of encoded triples for the corresponding test case, in order. For example, a valid output has the form\n\"[list_for_case_1,list_for_case_2,list_for_case_3,list_for_case_4]\".", "solution": "The problem requires the enumeration of single-nucleotide substitutions that are simultaneously synonymous in a primary reading frame and a specified overlapping reading frame, without introducing stop codons. The problem is scientifically grounded, well-posed, and objective, based on fundamental principles of molecular genetics. It is therefore deemed valid and a reasoned solution can be constructed.\n\nThe algorithm is designed by directly implementing the formal definitions provided. The core of the solution is to iterate through every possible single-nucleotide substitution at each relevant position and test it against a set of strictly defined criteria.\n\nFirst, we must establish the necessary biological and mathematical context. The standard nuclear genetic code is a function $g: \\Sigma^3 \\rightarrow \\mathcal{A} \\cup \\{\\ast\\}$, where $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ is the DNA alphabet, $\\mathcal{A}$ is the set of amino acids, and $\\ast$ represents a stop signal. This mapping is implemented as a dictionary. A numerical encoding $\\phi$ for the nucleotides is also defined as $\\phi(\\text{A})=0$, $\\phi(\\text{C})=1$, $\\phi(\\text{G})=2$, $\\phi(\\text{T})=3$.\n\nThe overall algorithm processes a set of test cases. For each case, specified by a DNA sequence $S$, a primary frame offset $p \\in \\{0, 1, 2\\}$, an overlapping frame offset $q \\in \\{0, 1, 2\\}$, and a half-open index interval $[s, e)$, the following steps are performed:\n\n1.  **Iteration over Positions**: The algorithm iterates through each nucleotide position $i$ within the specified range, from $s$ to $e-1$. For each position $i$, we consider all possible substitutions of the original base $S[i]$ with a different base from $\\Sigma$.\n\n2.  **Codon Identification**: For a given position $i$, we must identify the codons in the primary frame ($p$) and overlapping frame ($q$) that contain this nucleotide. The starting position $k_r$ of a codon in a frame with offset $r$ that includes index $i$ is uniquely determined by the formula $k_r = i - (i-r) \\pmod{3}$. Using this, we find the start of the primary codon, $k_p = i - (i-p) \\pmod{3}$, and the start of the overlapping codon, $k_q = i - (i-q) \\pmod{3}$.\n\n3.  **Codon Validity Check**: A codon starting at index $k$ is considered valid within the region of interest $[s, e)$ only if it is fully contained within this region's boundaries. This is enforced by the two conditions: $s \\le k$ and $k+2 < e$. At each position $i$, we compute $k_p$ and $k_q$ and verify that both these conditions hold for both codon starts. If either codon is not fully contained, the position $i$ cannot host a valid substitution under the problem's rules, and we proceed to the next position.\n\n4.  **Initial State Verification**: Before considering any mutations, we must check the status of the unmutated codons. We extract the primary codon $C_p = S[k_p:k_p+3]$ and the overlapping codon $C_q = S[k_q:k_q+3]$. We then translate them using the genetic code map $g$ to find their corresponding amino acids, $A_p = g(C_p)$ and $A_q = g(C_q)$. The problem stipulates that a position is only a candidate for valid substitutions if neither of the original codons encodes a stop signal. Therefore, if $A_p = \\ast$ or $A_q = \\ast$, we discard position $i$ and continue to the next.\n\n5.  **Substitution Analysis**: If the position $i$ passes the validity and initial state checks, we proceed to test all three possible single-nucleotide substitutions. Let the original base be $b = S[i]$. We iterate through each alternative base $b' \\in \\Sigma \\setminus \\{b\\}$. For each potential substitution $(i, b \\to b')$:\n    a. We construct the two mutated codons, $C'_p$ and $C'_q$. The mutation occurs at position $i-k_p$ within the primary codon and $i-k_q$ within the overlapping codon.\n    b. We translate these mutated codons to get the new amino acids, $A'_p = g(C'_p)$ and $A'_q = g(C'_q)$.\n    c. We check the substitution against the required constraints:\n        i.  **Synonymy in Primary Frame**: The substitution must be synonymous, meaning the amino acid does not change. This is verified by checking if $A'_p = A_p$.\n        ii. **No Change in Overlapping Frame**: The substitution must not introduce a stop codon or a nonsynonymous change. This condition simplifies to requiring that the substitution also be synonymous in the overlapping frame: $A'_q = A_q$.\n\n6.  **Result Compilation and Sorting**: If a substitution $(i, b \\to b')$ satisfies both conditions, it is deemed valid. It is then encoded into the specified output format: a triple $[i', \\phi(b), \\phi(b')]$, where $i' = i - s$ is the $0$-based index within the region $[s,e)$. These triples are collected for the current test case. After all positions $i$ have been processed, the resulting list of triples is sorted first by increasing $i'$ and then, as a tie-breaker, by increasing $\\phi(b')$.\n\n7.  **Final Output Generation**: The sorted list of triples for each test case is collected. The final output is a single string representing a list of these results, formatted compactly without spaces as per the implicit requirement for a machine-readable format.", "answer": "```python\nimport numpy as np\n# No scipy needed for this problem.\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding single-nucleotide synonymous substitutions\n    in overlapping reading frames as per the problem description.\n    \"\"\"\n\n    # The standard nuclear genetic code mapping codons to amino acids.\n    # '*' denotes a stop codon.\n    GENETIC_CODE = {\n        'ATA': 'I', 'ATC': 'I', 'ATT': 'I', 'ATG': 'M',\n        'ACA': 'T', 'ACC': 'T', 'ACG': 'T', 'ACT': 'T',\n        'AAC': 'N', 'AAT': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGC': 'S', 'AGT': 'S', 'AGA': 'R', 'AGG': 'R',\n        'CTA': 'L', 'CTC': 'L', 'CTG': 'L', 'CTT': 'L',\n        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCT': 'P',\n        'CAC': 'H', 'CAT': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGA': 'R', 'CGC': 'R', 'CGG': 'R', 'CGT': 'R',\n        'GTA': 'V', 'GTC': 'V', 'GTG': 'V', 'GTT': 'V',\n        'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCT': 'A',\n        'GAC': 'D', 'GAT': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGT': 'G',\n        'TCA': 'S', 'TCC': 'S', 'TCG': 'S', 'TCT': 'S',\n        'TTC': 'F', 'TTT': 'F', 'TTA': 'L', 'TTG': 'L',\n        'TAC': 'Y', 'TAT': 'Y', 'TAA': '*', 'TAG': '*',\n        'TGC': 'C', 'TGT': 'C', 'TGA': '*', 'TGG': 'W',\n    }\n    \n    # Mapping of nucleotides to integers as per the problem.\n    BASE_MAP = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    BASES = ['A', 'C', 'G', 'T']\n\n    def find_substitutions(S, p, q, s, e):\n        \"\"\"\n        Analyzes a single DNA sequence configuration.\n        \"\"\"\n        valid_substitutions = []\n        n = len(S)\n\n        for i in range(s, e):\n            # 1. Identify codons in both frames containing position i\n            # Primary frame codon start\n            k_p = i - (i - p) % 3\n            # Overlapping frame codon start\n            k_q = i - (i - q) % 3\n\n            # 2. Validate codon existence entirely within [s, e)\n            if not (s <= k_p and k_p + 2 < e):\n                continue\n            if not (s <= k_q and k_q + 2 < e):\n                continue\n\n            # 3. Extract original codons and check for initial stop codons\n            codon_p_str = S[k_p : k_p + 3]\n            codon_q_str = S[k_q : k_q + 3]\n\n            orig_aa_p = GENETIC_CODE.get(codon_p_str)\n            orig_aa_q = GENETIC_CODE.get(codon_q_str)\n\n            if orig_aa_p == '*' or orig_aa_q == '*':\n                continue\n\n            # 4. Iterate through all possible single-nucleotide substitutions at i\n            original_base = S[i]\n            \n            for new_base in BASES:\n                if new_base == original_base:\n                    continue\n\n                # Create mutated sequence as a list of characters for modification\n                mut_s_list = list(S)\n                mut_s_list[i] = new_base\n                \n                # Construct mutated codons\n                mut_codon_p_str = \"\".join(mut_s_list[k_p : k_p + 3])\n                mut_codon_q_str = \"\".join(mut_s_list[k_q : k_q + 3])\n                \n                # Translate mutated codons\n                mut_aa_p = GENETIC_CODE.get(mut_codon_p_str)\n                mut_aa_q = GENETIC_CODE.get(mut_codon_q_str)\n                \n                # 5. Check constraints\n                # Synonymous in primary frame\n                is_synonymous_p = (mut_aa_p == orig_aa_p)\n                # Synonymous (and not a stop) in overlapping frame\n                is_synonymous_q = (mut_aa_q == orig_aa_q)\n\n                if is_synonymous_p and is_synonymous_q:\n                    # Encode and store the valid substitution\n                    i_prime = i - s\n                    encoded_b = BASE_MAP[original_base]\n                    encoded_b_prime = BASE_MAP[new_base]\n                    valid_substitutions.append([i_prime, encoded_b, encoded_b_prime])\n        \n        # 6. Sort the results as required\n        valid_substitutions.sort(key=lambda x: (x[0], x[2]))\n        \n        return valid_substitutions\n\n    # Test cases from the problem statement\n    test_cases = [\n        (\"GGTTATGGTTAT\", 0, 2, 0, 12),\n        (\"GGTGGTGGTGGTGGTGGT\", 0, 1, 0, 18),\n        (\"GGTTATGGT\", 0, 2, 1, 8),\n        (\"GGTGAT\", 0, 2, 0, 6),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        S, p, q, s, e = case\n        result = find_substitutions(S, p, q, s, e)\n        all_results.append(result)\n\n    def format_list_compact(l):\n        \"\"\"Recursively formats lists and nested lists into a compact string.\"\"\"\n        if not isinstance(l, list):\n            return str(l)\n        return \"[\" + \",\".join(format_list_compact(item) for item in l) + \"]\"\n\n    # Final print statement in the exact required format.\n    print(format_list_compact(all_results))\n\nsolve()\n```", "id": "2843175"}]}