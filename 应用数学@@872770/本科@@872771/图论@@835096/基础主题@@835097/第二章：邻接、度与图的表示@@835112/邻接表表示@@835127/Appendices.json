{"hands_on_practices": [{"introduction": "理解数据结构的空间复杂度是算法分析的基础。这个练习将理论与实践相结合，通过分析完全图这种“最坏情况”下的稠密图，帮助你掌握计算邻接表总条目数的方法 [@problem_id:1479131]。这让你能直观地理解图的边数与其邻接表表示的存储需求之间的正比关系。", "problem": "设 $K_n$ 是一个有 $n$ 个顶点的完全图，其中 $n \\geq 2$。完全图是一个简单的无向图，其中每对不同的顶点都由一条唯一的边连接。\n\n该图使用邻接表结构表示。在这种表示方法中，对于 $n$ 个顶点中的每一个，我们都维护一个包含所有与之直接相连的其他顶点的列表。\n\n确定一个公式，用于计算图 $K_n$ 的所有邻接表中条目的总数。将你的答案表示为关于 $n$ 的函数。", "solution": "在邻接表表示法中，所有列表中的条目总数等于所有顶点的度数之和，因为每个顶点为其每个邻居贡献一个条目。\n\n在完全图 $K_{n}$ 中，每个顶点都与所有其他顶点相邻，因此每个顶点的度为 $n-1$。因此，直接对度数求和可得\n$$\n\\sum_{v \\in V} \\deg(v) = n \\cdot (n-1) = n(n-1).\n$$\n等价地，根据握手引理，度数之和等于边数的两倍：\n$$\n\\sum_{v \\in V} \\deg(v) = 2|E|.\n$$\n对于 $K_{n}$，边数是\n$$\n|E| = \\binom{n}{2} = \\frac{n(n-1)}{2},\n$$\n所以\n$$\n\\sum_{v \\in V} \\deg(v) = 2 \\cdot \\frac{n(n-1)}{2} = n(n-1).\n$$\n因此，$K_{n}$ 的邻接表条目总数是 $n(n-1)$。", "answer": "$$\\boxed{n(n-1)}$$", "id": "1479131"}, {"introduction": "在许多实际应用中，例如软件依赖分析或任务调度，识别没有前置依赖的“源”节点至关重要。标准的邻接表通常只存储每个顶点的出边，而此练习将引导你思考如何仅利用这些信息来高效地找出所有入度为零的源顶点 [@problem_id:1479134]。这个过程是许多图算法（如拓扑排序）的关键前置步骤。", "problem": "在一个大型软件项目中，构建系统会分析不同模块之间的依赖关系，以确定正确的编译顺序。这些依赖关系可以被建模为一个有向图 $G = (V, E)$，其中顶点集合 $V$ 代表模块，一条有向边 $(U, V) \\in E$ 表示模块 $U$ 必须在模块 $V$ 之前编译。\n\n依赖信息存储在标准的邻接表表示中。对于每个模块 $U \\in V$，都有一个列表 `adj[U]`，其中包含所有存在边 $(U, V)$ 的模块 $V$。\n\n“基础模块”被定义为没有先决条件的模块；它不依赖于任何其他模块。用图论的术语来说，这对应于“源顶点”，即入度为零的顶点。\n\n考虑一个有8个模块的项目，标记为 $V = \\{0, 1, 2, 3, 4, 5, 6, 7\\}$。该依赖图的邻接表如下所示：\n- `adj[0] = [1, 2]`\n- `adj[1] = [3]`\n- `adj[2] = [3, 4]`\n- `adj[3] = []`\n- `adj[4] = []`\n- `adj[5] = [6]`\n- `adj[6] = [4]`\n- `adj[7] = []`\n\n仅使用所提供的邻接表，找出所有基础模块的完整集合。\n\nA. {3, 4, 7}\n\nB. {0, 5, 7}\n\nC. {0, 5}\n\nD. {7}\n\nE. {0, 1, 2, 5, 6}", "solution": "给定一个有向图，其顶点集为 $V=\\{0,1,2,3,4,5,6,7\\}$，以及指定出边的邻接表。一个基础模块是一个源顶点，即入度为零的顶点。令 $\\deg^{-}(v)$ 表示顶点 $v$ 的入度。\n\n对所有 $v \\in V$ 初始化：\n$$\n\\deg^{-}(v)=0.\n$$\n\n处理每个邻接表，并为每条有向边的目标顶点增加 $\\deg^{-}$ 的值：\n- 从 $0$ 出发：边 $(0,1)$ 和 $(0,2)$ 得到\n$$\n\\deg^{-}(1)\\leftarrow \\deg^{-}(1)+1=1,\\quad \\deg^{-}(2)\\leftarrow \\deg^{-}(2)+1=1.\n$$\n- 从 $1$ 出发：边 $(1,3)$ 得到\n$$\n\\deg^{-}(3)\\leftarrow \\deg^{-}(3)+1=1.\n$$\n- 从 $2$ 出发：边 $(2,3)$ 和 $(2,4)$ 得到\n$$\n\\deg^{-}(3)\\leftarrow \\deg^{-}(3)+1=2,\\quad \\deg^{-}(4)\\leftarrow \\deg^{-}(4)+1=1.\n$$\n- 从 $3$ 出发：没有边，无变化。\n- 从 $4$ 出发：没有边，无变化。\n- 从 $5$ 出发：边 $(5,6)$ 得到\n$$\n\\deg^{-}(6)\\leftarrow \\deg^{-}(6)+1=1.\n$$\n- 从 $6$ 出发：边 $(6,4)$ 得到\n$$\n\\deg^{-}(4)\\leftarrow \\deg^{-}(4)+1=2.\n$$\n- 从 $7$ 出发：没有边，无变化。\n\n汇总最终的入度：\n$$\n\\deg^{-}(0)=0,\\ \\deg^{-}(1)=1,\\ \\deg^{-}(2)=1,\\ \\deg^{-}(3)=2,\\ \\deg^{-}(4)=2,\\ \\deg^{-}(5)=0,\\ \\deg^{-}(6)=1,\\ \\deg^{-}(7)=0.\n$$\n\n入度 $\\deg^{-}(v)=0$ 的顶点是\n$$\n\\{0,5,7\\}.\n$$\n与选项比较，这与选项 B 匹配。", "answer": "$$\\boxed{B}$$", "id": "1479134"}, {"introduction": "邻接表是实现复杂图算法的基石，尤其是在解决涉及有向无环图（DAG）的优化问题时。这个练习模拟了项目管理中的关键路径分析，要求你计算从每个模块开始的最长依赖序列的长度 [@problem_id:1479126]。通过解决这个问题，你将亲身体验如何利用动态规划和记忆化搜索，在邻接表表示的图上高效地解决路径优化问题。", "problem": "一个软件项目由几个相互依赖的模块组成。这些依赖关系形成一个有向图，其中从模块 `u` 到模块 `v` 的一条边表示 `u` 必须在 `v` 开始之前完成。项目管理团队已经确认不存在循环依赖，这意味着该图是一个有向无环图（DAG）。一个任务序列的“完成时间”取决于顺序依赖步骤的数量。具体来说，图中路径的长度定义为其包含的边的数量。\n\n考虑一个有7个模块的项目，标记为0到6。依赖关系由以下邻接表表示，其中 `Adj[i]` 包含直接依赖于模块 `i` 的模块列表：\n\n*   `Adj[0] = [1, 2]`\n*   `Adj[1] = [3]`\n*   `Adj[2] = [3, 4]`\n*   `Adj[3] = [5]`\n*   `Adj[4] = [5, 6]`\n*   `Adj[5] = []`\n*   `Adj[6] = []`\n\n你的任务是确定对于每个模块，在其之后必须完成的最长依赖模块序列的长度。这对应于在依赖图中找到从每个顶点开始的最长路径的长度。\n\n请分别计算从顶点0到6出发的最长路径的长度。将你的最终答案以行矩阵的形式呈现，其中按顺序包含从顶点0到顶点6的这七个整数长度。", "solution": "设给定的有向无环图为 $G = (V, E)$，其中 $V = \\{0, 1, 2, 3, 4, 5, 6\\}$ 是顶点（模块）的集合，$E$ 是由邻接表定义的边（依赖关系）的集合。我们需要找到从每个顶点 $u \\in V$ 开始的最长路径的长度。我们用 $L(u)$ 表示这个量。路径的长度是它所包含的边的数量。\n\n这个问题可以使用动态规划和记忆化来高效解决。关键的思路是递归地定义 $L(u)$。\n一个没有出边（汇点）的顶点 $u$ 不能作为任何路径的起点，因此从它开始的最长路径长度为0。\n对于任何其他顶点 $u$，从 $u$ 开始的路径由一条到其邻居 $v$ 的边 $(u, v)$ 和一条从 $v$ 开始的路径组成。为了找到从 $u$ 开始的最长路径，我们必须选择从其开始的路径最长的那个邻居 $v$。\n\n这给了我们以下关于 $L(u)$ 的递推关系：\n- 如果 $u$ 的出度为0（即 `Adj[u]` 为空），则 $L(u) = 0$。\n- 否则，$L(u) = 1 + \\max_{v \\in \\text{Adj}[u]} \\{L(v)\\}$。\n\n这个公式的一个朴素的递归实现效率会很低，因为单个顶点 $v$ 的 $L(v)$ 值可能会被重复计算多次。例如，在我们的图中，计算 $L(1)$ 和 $L(2)$ 都需要 $L(3)$。\n\n为了避免重复计算，我们使用记忆化。我们将使用一个与顶点数量相同大小的数组，称之为 `memo`，并用一个哨兵值（例如-1）进行初始化，以表示该顶点的最长路径尚未计算。\n\n算法过程如下：我们定义一个函数 `compute_L(u)`，用于计算 $L(u)$。\n1.  如果 `memo[u]` 不等于-1，这意味着我们已经计算过 $L(u)$，所以我们返回存储的值 `memo[u]`。\n2.  如果 `Adj[u]` 为空，$u$ 是一个汇点。我们设置 `memo[u] = 0` 并返回0。\n3.  否则，我们对所有邻居 $v \\in \\text{Adj}[u]$ 递归调用 `compute_L(v)`。我们取这些返回值的最大值，加1，然后将结果存储在 `memo[u]` 中。\n4.  最后，我们遍历所有顶点 $i \\in V$，如果其值尚未计算，则调用 `compute_L(i)`。\n\n让我们将此方法应用于给定的图。初始化 `memo = [-1, -1, -1, -1, -1, -1, -1]`。\n\n我们需要计算 $L(0), L(1), \\dots, L(6)$。让我们从 `compute_L(0)` 开始，以深度优先的方式计算它们。\n\n- **`compute_L(0)`**：`memo[0]` 为-1。`Adj[0] = [1, 2]`。我们需要 $L(1)$ 和 $L(2)$。\n    - **`compute_L(1)`**：`memo[1]` 为-1。`Adj[1] = [3]`。我们需要 $L(3)$。\n        - **`compute_L(3)`**：`memo[3]` 为-1。`Adj[3] = [5]`。我们需要 $L(5)$。\n            - **`compute_L(5)`**：`memo[5]` 为-1。`Adj[5]` 为空。因此，$L(5) = 0$。设置 `memo[5] = 0`。返回0。\n        - 回到 `compute_L(3)`，我们有 $L(5)=0$。因此，$L(3) = 1 + L(5) = 1 + 0 = 1$。设置 `memo[3] = 1`。返回1。\n    - 回到 `compute_L(1)`，我们有 $L(3)=1$。因此，$L(1) = 1 + L(3) = 1 + 1 = 2$。设置 `memo[1] = 2`。返回2。\n    - 现在 `compute_L(0)` 需要 $L(2)$。\n    - **`compute_L(2)`**：`memo[2]` 为-1。`Adj[2] = [3, 4]`。我们需要 $L(3)$ 和 $L(4)$。\n        - **`compute_L(3)`**：`memo[3]` 为1（已计算）。返回1。\n        - **`compute_L(4)`**：`memo[4]` 为-1。`Adj[4] = [5, 6]`。我们需要 $L(5)$ 和 $L(6)$。\n            - **`compute_L(5)`**：`memo[5]` 为0（已计算）。返回0。\n            - **`compute_L(6)`**：`memo[6]` 为-1。`Adj[6]` 为空。因此，$L(6) = 0$。设置 `memo[6] = 0`。返回0。\n        - 回到 `compute_L(4)`，我们有 $L(5)=0$ 和 $L(6)=0$。因此，$L(4) = 1 + \\max(L(5), L(6)) = 1 + \\max(0, 0) = 1$。设置 `memo[4] = 1`。返回1。\n    - 回到 `compute_L(2)`，我们有 $L(3)=1$ 和 $L(4)=1$。因此，$L(2) = 1 + \\max(L(3), L(4)) = 1 + \\max(1, 1) = 2$。设置 `memo[2] = 2`。返回2。\n- 回到 `compute_L(0)`，我们有 $L(1)=2$ 和 $L(2)=2$。因此，$L(0) = 1 + \\max(L(1), L(2)) = 1 + \\max(2, 2) = 3$。设置 `memo[0] = 3`。\n\n此时，`memo` 数组为 `[3, 2, 2, 1, 1, 0, 0]`。所有值都已在对 `compute_L(0)` 的初始调用中计算完毕。我们可以验证我们的结果：\n- $L(6) = 0$ (汇点)\n- $L(5) = 0$ (汇点)\n- $L(4) = 1 + \\max(L(5), L(6)) = 1 + \\max(0, 0) = 1$\n- $L(3) = 1 + L(5) = 1 + 0 = 1$\n- $L(2) = 1 + \\max(L(3), L(4)) = 1 + \\max(1, 1) = 2$\n- $L(1) = 1 + L(3) = 1 + 1 = 2$\n- $L(0) = 1 + \\max(L(1), L(2)) = 1 + \\max(2, 2) = 3$\n\n计算结果是一致的。从顶点0到6排序的最长路径长度的最终列表是 (3, 2, 2, 1, 1, 0, 0)。", "answer": "$$\\boxed{\\begin{pmatrix} 3  2  2  1  1  0  0 \\end{pmatrix}}$$", "id": "1479126"}]}