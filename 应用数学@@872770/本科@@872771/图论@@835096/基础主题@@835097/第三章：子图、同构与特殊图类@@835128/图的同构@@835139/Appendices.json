{"hands_on_practices": [{"introduction": "要证明两个图**不**同构，最直接的方法是找到一个它们之间存在差异的结构属性。这些在同构变换下保持不变的属性被称为“图不变量”。本练习 ( [@problem_id:1379143] ) 将通过一个基本案例，利用是否存在3-圈（$C_3$）这一不变量，清晰地展示如何快速判定两个图并非同构。", "problem": "考虑两个简单无向图 $G_1$ 和 $G_2$。\n\n图 $G_1$，被称为“牛图”，其构造如下：它有五个顶点的集合 $\\{v_1, v_2, v_3, v_4, v_5\\}$。顶点集 $\\{v_1, v_2, v_3\\}$ 形成一个三角形，意味着边 $\\{v_1, v_2\\}$、$\\{v_2, v_3\\}$ 和 $\\{v_3, v_1\\}$ 都存在。此外，有一条从 $v_1$ 到 $v_4$ 的边和一条从 $v_2$ 到 $v_5$ 的边。没有其他边。\n\n图 $G_2$ 是 5-圈图，记作 $C_5$。它由五个顶点以单一的循环序列连接而成。\n\n如果两个图的顶点之间存在保持顶点邻接性的一一对应关系，则这两个图是同构的。如果两个图同构，它们必须共享所有结构属性（例如，顶点数、边数、圈长、顶点度数等）。\n\n下列哪个陈述为图 $G_1$ 和 $G_2$ 不同构提供了一个有效的理由？\n\nA. $G_1$ 中的顶点数与 $G_2$ 中的顶点数不同。\nB. $G_1$ 中的边数与 $G_2$ 中的边数不同。\nC. $G_1$ 包含一个同构于 3-圈 ($C_3$) 的子图，而 $G_2$ 不包含。\nD. $G_1$ 中任意顶点的最小度数与 $G_2$ 中任意顶点的最小度数相同。\nE. $G_1$ 和 $G_2$ 都是二分图。", "solution": "我们比较 $G_1$（牛图）和 $G_2=C_5$ 的同构不变量。\n\n计算 $G_1$ 的基本计数：\n- 顶点数：$|V(G_1)|=5$。\n- 边数：$\\{v_1,v_2,v_3\\}$ 上的三角形贡献了 $3$ 条边，加上边 $\\{v_1,v_4\\}$ 和 $\\{v_2,v_5\\}$，得到 $|E(G_1)|=5$。\n- 度数：$\\deg(v_1)=3$, $\\deg(v_2)=3$, $\\deg(v_3)=2$, $\\deg(v_4)=1$, $\\deg(v_5)=1$，所以度数多重集是 $\\{3,3,2,1,1\\}$ 且 $\\delta(G_1)=1$。\n- 圈：$G_1$ 包含一个 $C_3$（$\\{v_1,v_2,v_3\\}$ 上的三角形）。\n\n计算 $G_2=C_5$ 的基本计数：\n- 顶点数：$|V(G_2)|=5$。\n- 边数：$|E(G_2)|=5$。\n- 度数：每个顶点的度数都是 $2$，所以度数多重集是 $\\{2,2,2,2,2\\}$ 且 $\\delta(G_2)=2$。\n- 圈：$C_5$ 不包含 $C_3$。\n\n使用同构不变量评估这些陈述：\n- A 是错误的，因为 $|V(G_1)|=|V(G_2)|=5$。\n- B 是错误的，因为 $|E(G_1)|=|E(G_2)|=5$。\n- C 是正确的：$C_3$ 的存在与否在同构下是保持不变的；$G_1$ 有一个 $C_3$ 而 $G_2$ 没有，所以它们不同构。\n- D 是错误的，因为 $\\delta(G_1)=1$ 和 $\\delta(G_2)=2$ 不相同。该选项陈述它们相同，这是一个错误的陈述。\n- E 是错误的，因为两个图都不是二分图：$G_1$ 有一个 $C_3$，$G_2=C_5$ 是一个奇圈。\n\n因此，有效的理由由选项 C 给出。", "answer": "$$\\boxed{C}$$", "id": "1379143"}, {"introduction": "与证明非同构不同，要证明两个图同构，仅仅比较不变量是不够的；我们必须构造一个具体的顶点映射，并证明该映射保持了边的邻接关系。这个练习 ( [@problem_id:1379138] ) 提供了一个绝佳的实践机会，挑战你为一个图和它的补图之间找到一个有效的同构映射，这本身就是一个有趣且深刻的图论概念。", "problem": "考虑两个不同的通信网络，阿尔法（Alpha）和贝塔（Beta），每个网络都由四个标记为 $\\{n_1, n_2, n_3, n_4\\}$ 的节点组成。这两个网络由其节点之间的直接通信链路定义。\n\n在网络阿尔法中，链路被配置为一条简单路径：在 $n_1$ 和 $n_2$ 之间、 $n_2$ 和 $n_3$ 之间以及 $n_3$ 和 $n_4$ 之间存在链路。网络阿尔法中不存在其他链路。\n\n网络贝塔是基于与网络阿尔法互补的原则设计的。网络贝塔中任意两个节点之间存在直接链路，当且仅当这两个节点在网络阿尔法中*没有*直接链路。\n\n如果一个网络可以通过简单地重新标记其节点而转换成另一个网络，那么这两个网络被认为是结构相同或同构的。形式上，这意味着存在一个一一对应且满射的函数 $f$（一个双射），将网络阿尔法的节点映射到网络贝塔的节点，使得网络阿尔法中任意两个节点 $u$ 和 $v$ 之间存在链路，当且仅当网络贝塔中对应的节点 $f(u)$ 和 $f(v)$ 之间也存在链路。\n\n以下哪个函数 $f: \\{n_1, n_2, n_3, n_4\\} \\to \\{n_1, n_2, n_3, n_4\\}$ 表示从网络阿尔法到网络贝塔的一个有效同构？\n\nA. $f(n_1) = n_1$, $f(n_2) = n_2$, $f(n_3) = n_3$, $f(n_4) = n_4$\nB. $f(n_1) = n_4$, $f(n_2) = n_3$, $f(n_3) = n_2$, $f(n_4) = n_1$\nC. $f(n_1) = n_2$, $f(n_2) = n_4$, $f(n_3) = n_1$, $f(n_4) = n_3$\nD. $f(n_1) = n_2$, $f(n_2) = n_1$, $f(n_3) = n_4$, $f(n_4) = n_3$\nE. $f(n_1) = n_1$, $f(n_2) = n_3$, $f(n_3) = n_2$, $f(n_4) = n_4$", "solution": "设 $V=\\{n_1, n_2, n_3, n_4\\}$。在网络阿尔法（称之为 $A$）中，边集为\n$$\nE_A=\\big\\{\\{n_1, n_2\\}, \\{n_2, n_3\\}, \\{n_3, n_4\\}\\big\\}.\n$$\n网络贝塔（称之为 $B$）是 $A$ 在 $V$ 上的补图，因此它的边恰好是 $A$ 的非边。由于完全图 $K_4$ 有 6 条边而 $E_A$ 有 3 条边，所以补图的边为\n$$\nE_B=\\big\\{\\{n_1, n_3\\}, \\{n_1, n_4\\}, \\{n_2, n_4\\}\\big\\}.\n$$\n一个函数 $f:V \\to V$ 是从 $A$到 $B$ 的一个同构，当且仅当对于所有不同的 $u,v \\in V$，\n$$\n\\{u,v\\}\\in E_A \\quad\\Longleftrightarrow\\quad \\{f(u),f(v)\\}\\in E_B.\n$$\n\n检验每个选项：\n\nA. 恒等函数 $f(n_i)=n_i$ 不成立，因为 $\\{n_1,n_2\\}\\in E_A$ 映射到 $\\{n_1,n_2\\}\\notin E_B$。\n\nB. $f(n_1)=n_4$, $f(n_2)=n_3$, $f(n_3)=n_2$, $f(n_4)=n_1$ 不成立，因为 $\\{n_1,n_2\\}\\in E_A$ 映射到 $\\{n_4,n_3\\}=\\{n_3,n_4\\}\\notin E_B$。\n\nC. $f(n_1)=n_2$, $f(n_2)=n_4$, $f(n_3)=n_1$, $f(n_4)=n_3$ 成立。检查 $A$ 的边：\n- $\\{n_1,n_2\\}\\in E_A \\mapsto \\{f(n_1),f(n_2)\\}=\\{n_2,n_4\\}\\in E_B$。\n- $\\{n_2,n_3\\}\\in E_A \\mapsto \\{f(n_2),f(n_3)\\}=\\{n_4,n_1\\}=\\{n_1,n_4\\}\\in E_B$。\n- $\\{n_3,n_4\\}\\in E_A \\mapsto \\{f(n_3),f(n_4)\\}=\\{n_1,n_3\\}\\in E_B$。\n检查 $A$ 的非边（必须映射到 $B$ 的非边）：\n- $\\{n_1,n_3\\}\\notin E_A \\mapsto \\{f(n_1),f(n_3)\\}=\\{n_2,n_1\\}=\\{n_1,n_2\\}\\notin E_B$。\n- $\\{n_1,n_4\\}\\notin E_A \\mapsto \\{f(n_1),f(n_4)\\}=\\{n_2,n_3\\}\\notin E_B$。\n- $\\{n_2,n_4\\}\\notin E_A \\mapsto \\{f(n_2),f(n_4)\\}=\\{n_4,n_3\\}=\\{n_3,n_4\\}\\notin E_B$。\n因此，当且仅当的条件成立，所以 $f$ 是一个同构。\n\nD. $f(n_1)=n_2$, $f(n_2)=n_1$, $f(n_3)=n_4$, $f(n_4)=n_3$ 不成立，因为 $\\{n_1,n_2\\}\\in E_A$ 映射到 $\\{n_2,n_1\\}=\\{n_1,n_2\\}\\notin E_B$。\n\nE. $f(n_1)=n_1$, $f(n_2)=n_3$, $f(n_3)=n_2$, $f(n_4)=n_4$ 不成立，因为 $\\{n_2,n_3\\}\\in E_A$ 映射到 $\\{n_3,n_2\\}=\\{n_2,n_3\\}\\notin E_B$。\n\n因此，选项中唯一有效的同构是 C。", "answer": "$$\\boxed{C}$$", "id": "1379138"}, {"introduction": "在理论之外，我们如何让计算机高效地判断图的同构？对于树这类特殊的图，一种强大的方法是为其生成一个唯一的“规范标签”或“签名”。如果两棵（有根）树的签名相同，它们就是同构的。本练习 ( [@problem_id:1507616] ) 将引导你通过一个递归算法，为一棵树生成其规范字符串，从而将抽象的同构概念转化为具体的计算过程。", "problem": "在为层次结构数据设计的数据库系统中，通常需要为树状数据结构生成一个唯一的、紧凑的“结构签名”。这个签名仅取决于树的拓扑结构，可用于快速相等性检查和索引。\n\n您的任务是为一个给定的有根树生成这样一种签名，我们称之为规范层次字符串 (CHS)。CHS 由以下递归规则定义：\n\n1.  **叶节点规则**：叶节点（没有子节点的节点）的 CHS 是字符串 \"0\"。\n2.  **内部节点规则**：对于内部节点（有子节点的节点），其 CHS 的构造如下：\n    a. 首先，递归地计算其每个子节点的 CHS。这将为每个子节点的子树生成一组字符串。\n    b. 将这组字符串按字典序（即按字母顺序，就像它们在字典中出现的顺序，基于标准字符编码）排序。\n    c. 将排序后的字符串按顺序拼接起来，不加任何分隔符，形成一个单一的新字符串。\n    d. 最后，将这个新拼接的字符串用一对括号 `(` 和 `)` 括起来。得到的字符串就是该内部节点的 CHS。\n\n考虑以下由其父子关系定义的有根树：\n- 树的根节点是 `N0`。\n- `N0` 有两个子节点：`N1` 和 `N2`。\n- `N1` 有两个子节点：`N3` 和 `N4`。\n- `N2` 有三个子节点：`N5`、`N6` 和 `N7`。\n- `N3` 有两个子节点：`N8` 和 `N9`。\n- `N4` 有一个子节点：`N10`。\n- `N5` 有一个子节点：`N11`。\n- `N6` 有一个子节点：`N12`。\n- 节点 `N7`、`N8`、`N9`、`N10`、`N11` 和 `N12` 都是叶节点。\n\n确定根节点 `N0` 的规范层次字符串 (CHS)。", "solution": "我们应用规范层次字符串 (CHS) 的递归定义，自底向上为树中的每个节点计算其签名。\n\n1.  **叶节点**：根据规则 1，所有叶节点（$N_7, N_8, N_9, N_{10}, N_{11}, N_{12}$）的 CHS 都是字符串 `\"0\"`。\n\n2.  **第一层内部节点**：\n    *   节点 $N_3$（子节点 $N_8, N_9$）：其子节点的 CHS 列表是 `[\"0\", \"0\"]`。排序后不变。拼接为 `\"00\"`。用括号括起来得到 `CHS(N_3)` 是 `\"(00)\"`。\n    *   节点 $N_4$（子节点 $N_{10}$）：其子节点的 CHS 列表是 `[\"0\"]`。拼接为 `\"0\"`。用括号括起来得到 `CHS(N_4)` 是 `\"(0)\"`。\n    *   节点 $N_5$（子节点 $N_{11}$）：同理，`CHS(N_5)` 是 `\"(0)\"`。\n    *   节点 $N_6$（子节点 $N_{12}$）：同理，`CHS(N_6)` 是 `\"(0)\"`。\n\n3.  **第二层内部节点**：\n    *   节点 $N_1$（子节点 $N_3, N_4$）：其子节点的 CHS 列表是 `[\"(00)\", \"(0)\"]`。按字典序排序，`\"(0)\"` 在 `\"(00)\"` 之前（因为在第一个不同字符处，`')'` 的 ASCII 码小于 `'0'` 的 ASCII 码）。排序后的列表为 `[\"(0)\", \"(00)\"]`。拼接为 `\"(0)(00)\"`。用括号括起来得到 `CHS(N_1)` 是 `\"((0)(00))\"`。\n    *   节点 $N_2$（子节点 $N_5, N_6, N_7$）：其子节点的 CHS 列表是 `[\"(0)\", \"(0)\", \"0\"]`。按字典序排序，`\"(0)\"` 在 `\"0\"` 之前（因为 `'('` 的 ASCII 码小于 `'0'` 的 ASCII 码）。排序后的列表为 `[\"(0)\", \"(0)\", \"0\"]`。拼接为 `\"(0)(0)0\"`。用括号括起来得到 `CHS(N_2)` 是 `\"((0)(0)0)\"`。\n\n4.  **根节点**：\n    *   节点 $N_0$（子节点 $N_1, N_2$）：其子节点的 CHS 列表是 `[\"((0)(00))\", \"((0)(0)0)\"]`。按字典序排序，`\"((0)(0)0)\"` 在 `\"((0)(00))\"` 之前（因为在第七个字符处，`')'` 的 ASCII 码小于 `'0'` 的 ASCII 码）。排序后的列表为 `[\"((0)(0)0)\", \"((0)(00))\"]`。拼接为 `\"((0)(0)0)((0)(00))\"`。用括号括起来得到 `CHS(N_0)` 是 `\"(((0)(0)0)((0)(00)))\"`。\n\n最终，根节点 `N0` 的规范层次字符串为 `(((0)(0)0)((0)(00)))`。", "answer": "$$\\boxed{(((0)(0)0)((0)(00)))}$$", "id": "1507616"}]}