{"hands_on_practices": [{"introduction": "Kosaraju 算法巧妙地运用了两次深度优先搜索（DFS）来识别强连通分量。第一遍 DFS 的核心任务是为图中的每个顶点计算一个“完成时间”，这个时间戳对于后续步骤至关重要。这个练习将引导你手动追踪一个给定图的 DFS 过程，通过计算每个顶点的完成时间，为掌握整个算法打下坚实的基础 [@problem_id:1517012]。", "problem": "考虑一个有向图 $G = (V, E)$，其顶点集为 $V = \\{v_0, v_1, v_2, v_3, v_4\\}$，有向边集为 $E$。边的定义如下：\n- 有一个中心顶点 $v_0$，它有指向所有其他顶点的出边。\n- 其他顶点根据其下标按顺时针方向形成一个环。\n具体来说，边集为 $E = \\{(v_0, v_1), (v_0, v_2), (v_0, v_3), (v_0, v_4), (v_1, v_2), (v_2, v_3), (v_3, v_4), (v_4, v_1)\\}$。\n\n我们将对该图 $G$ 执行深度优先搜索 (DFS)。DFS 过程使用一个全局整数计时器，其初始值为 0。\n- 当首次发现顶点 `u` 时，其发现时间 `d[u]` 被记录为计时器的当前值，然后计时器加 1。\n- 在访问完 `u` 的所有邻居后，`u` 的访问结束。其结束时间 `f[u]` 被记录为计时器的当前值，然后计时器加 1。\n\nDFS 遍历遵循以下特定规则：\n1. DFS 主循环按顶点下标顺序 $v_0, v_1, v_2, v_3, v_4$ 处理顶点。此序列中第一个未被访问的顶点被选为新搜索树的起点。\n2. 在探索任何给定顶点的邻居时，邻居将按其顶点下标的递增顺序被访问。例如，从顶点 $v_0$ 出发，算法将尝试访问 $v_1$，然后是 $v_2$，接着是 $v_3$，最后是 $v_4$。\n\n你的任务是确定在 DFS 遍历完成后所有顶点 $v_0, v_1, v_2, v_3, v_4$ 的结束时间。请将你的答案表示为一个包含五个整数的序列，按顺序分别代表 $v_0, v_1, v_2, v_3, v_4$ 的结束时间。", "solution": "我们执行一个标准的 DFS，其中全局计时器初始化为 $t=0$。当发现一个顶点 $u$ 时，我们设置 $d[u]=t$ 然后更新 $t \\leftarrow t+1$。在完成对 $u$ 的所有邻居的访问后，我们设置 $f[u]=t$ 然后更新 $t \\leftarrow t+1$。主循环按 $v_{0},v_{1},v_{2},v_{3},v_{4}$ 的顺序访问顶点，且邻接表按递增的下标顺序进行探索。\n\n从 $v_{0}$（未访问）开始，因此我们调用 $\\mathrm{DFS\\mbox{-}Visit}(v_{0})$：\n- 发现 $v_{0}$：\n$$d[v_{0}]=0,\\quad t\\leftarrow 1.$$\n按顺序 $v_{1},v_{2},v_{3},v_{4}$ 探索 $v_{0}$ 的邻居。\n\n从 $v_{0}$，访问 $v_{1}$（白色）：\n- 发现 $v_{1}$：\n$$d[v_{1}]=1,\\quad t\\leftarrow 2.$$\n$v_{1}$ 的邻居：只有 $v_{2}$。访问 $v_{2}$（白色）：\n- 发现 $v_{2}$：\n$$d[v_{2}]=2,\\quad t\\leftarrow 3.$$\n$v_{2}$ 的邻居：只有 $v_{3}$。访问 $v_{3}$（白色）：\n- 发现 $v_{3}$：\n$$d[v_{3}]=3,\\quad t\\leftarrow 4.$$\n$v_{3}$ 的邻居：只有 $v_{4}$。访问 $v_{4}$（白色）：\n- 发现 $v_{4}$：\n$$d[v_{4}]=4,\\quad t\\leftarrow 5.$$\n$v_{4}$ 的邻居：只有 $v_{1}$，它已经被发现（灰色），所以没有递归调用。结束 $v_{4}$ 的访问：\n$$f[v_{4}]=5,\\quad t\\leftarrow 6.$$\n\n返回到 $v_{3}$，没有更多邻居。结束 $v_{3}$ 的访问：\n$$f[v_{3}]=6,\\quad t\\leftarrow 7.$$\n\n返回到 $v_{2}$，没有更多邻居。结束 $v_{2}$ 的访问：\n$$f[v_{2}]=7,\\quad t\\leftarrow 8.$$\n\n返回到 $v_{1}$，没有更多邻居。结束 $v_{1}$ 的访问：\n$$f[v_{1}]=8,\\quad t\\leftarrow 9.$$\n\n回到 $v_{0}$，继续其邻居列表：$v_{2},v_{3},v_{4}$ 均已访问完成（黑色），所以没有新的访问。结束 $v_{0}$ 的访问：\n$$f[v_{0}]=9,\\quad t\\leftarrow 10.$$\n\n主循环检查 $v_{1},v_{2},v_{3},v_{4}$，它们都已经被访问过，因此 DFS 终止。因此，按顺序 $(v_{0},v_{1},v_{2},v_{3},v_{4})$ 的结束时间为\n$$f[v_{0}]=9,\\quad f[v_{1}]=8,\\quad f[v_{2}]=7,\\quad f[v_{3}]=6,\\quad f[v_{4}]=5.$$", "answer": "$$\\boxed{\\begin{pmatrix}9  8  7  6  5\\end{pmatrix}}$$", "id": "1517012"}, {"introduction": "在完成了对原始图 $G$ 的第一次 DFS 并获得了所有顶点的完成时间后，Kosaraju 算法的精髓体现在第二遍 DFS 中。这一遍是在转置图 $G^T$ 上进行的，其起点顺序并非任意，而是严格遵循第一次 DFS 得到的完成时间。这个练习将精确地考察你对这一关键步骤的理解，即如何利用完成时间来确定第二次搜索的正确顺序 [@problem_id:1517044]。", "problem": "考虑一个有向图 $G = (V, E)$，其中顶点集为 $V = \\{A, B, C, D, E, F, G, H\\}$。边 $E$ 由以下邻接表表示：\n\n- $A: B$\n- $B: C, E, F$\n- $C: D, G$\n- $D: C, H$\n- $E: A, F$\n- $F: G$\n- $G: F$\n- $H: D$\n\n在一个寻找该图强连通分量的算法的第一阶段，对图 $G$ 执行深度优先搜索 (DFS)。该 DFS 的主循环按字母顺序（A，然后 B，然后 C，依此类推）来考虑顶点，若顶点尚未被访问，则以其为起点开始新的搜索树。DFS 完成后，每个顶点的完成时间记录如下：\n\n- $f(A) = 16$\n- $f(B) = 15$\n- $f(C) = 12$\n- $f(D) = 7$\n- $f(E) = 14$\n- $f(F) = 10$\n- $f(G) = 11$\n- $f(H) = 6$\n\n该算法的第二阶段涉及对该图的转置图 $G^T$ 执行一次 DFS。在第二次 DFS 中，选择顶点作为起始点的顺序是由第一阶段的结果决定的一个特定顺序。在第二阶段中，用作 DFS 遍历起始点的正确顶点序列是什么？\n\nA. A, B, E, C, G, F, D, H\n\nB. A, B, C, D, E, F, G, H\n\nC. H, D, F, G, C, E, B, A\n\nD. C, G, F, D, H, A, E, B\n\nE. A, E, B, F, C, G, D, H", "solution": "在 Kosaraju 算法中，第一阶段对图 $G$ 运行一次 DFS，并记录每个顶点 $v$ 的完成时间 $f(v)$。第二阶段对转置图 $G^{T}$ 运行一次 DFS，并按照第一阶段完成时间的严格递减顺序来选择新的 DFS 起始顶点。\n\n根据给定的数据，\n$f(A)=16$, $f(B)=15$, $f(E)=14$, $f(C)=12$, $f(G)=11$, $f(F)=10$, $f(D)=7$, $f(H)=6$。\n将顶点按 $f$ 的递减顺序排序，得到序列\n$$A, B, E, C, G, F, D, H.$$\n这与选项 A 相符。", "answer": "$$\\boxed{A}$$", "id": "1517044"}, {"introduction": "掌握了算法的执行步骤（“如何做”）之后，探索其背后的原理（“为什么”）能让你获得更深刻的理解。这个练习是一个思想实验，它挑战了 Kosaraju 算法的标准流程，提出了一个“反向”版本。通过分析这个反向算法为何在某些情况下会失效，你将能够洞察原算法设计的巧妙之处，并理解其正确性为何依赖于特定的操作顺序 [@problem_id:1517055]。", "problem": "一位算法设计者正在研究如何寻找有向图 $G=(V, E)$ 的强连通分量（SCC）。他们熟悉 Kosaraju 算法，该算法包含以下步骤：\n1.  对图 $G$ 运行深度优先搜索（DFS），以确定所有顶点的完成时间（或后序遍历序列）。\n2.  计算转置图 $G^T$，即图 $G$ 中所有边反向后得到的图。\n3.  对 $G^T$ 运行 DFS，主循环按照步骤1中确定的完成时间的降序处理顶点。最终得到的 DFS 森林中的每棵树都对应于原始图 $G$ 的一个不同的 SCC。\n\n该设计者通过交换 $G$ 和 $G^T$ 在主要步骤中的角色，提出了一个“反向 Kosaraju 算法”。所提出的算法如下：\n1.  计算转置图 $G^T$。\n2.  对转置图 $G^T$ 运行 DFS，以确定所有顶点的完成时间。\n3.  对原始图 $G$ 运行 DFS，主循环按照步骤2中确定的完成时间的降序处理顶点。设计者声称，这第二个 DFS 森林中的每棵树都将对应一个不同的 SCC。\n\n下列哪个陈述准确地评估了这种“反向 Kosaraju 算法”的正确性？\n\nA. 是的，这种反向算法也是一种寻找任何有向图的所有强连通分量的正确方法。\n\nB. 不，对于任何包含多个强连通分量的有向图，这种反向算法都会失败。\n\nC. 不，这种反向算法不正确，因为从 $G^T$ 导出的处理顺序不能保证在处理完第一个分量后，对 $G$ 的 DFS 会被限制在单个 SCC 内。\n\nD. 不，这种反向算法不正确，因为最后一步在原始图 $G$ 上的 DFS 不能利用从转置图 $G^T$ 计算出的完成时间。", "solution": "让我们系统地分析这个“反向 Kosaraju 算法”的正确性。标准算法和反向算法的正确性都取决于深度优先搜索（DFS）完成时间与图的收缩图（其强连通分量构成的有向无环图）之间的一个关键属性。\n\n设 $G=(V,E)$ 是一个有向图， $G^T$ 是其转置图。令 $C(G)$ 为 $G$ 的收缩图，其中每个节点代表 $G$ 的一个强连通分量（SCC）。如果在 $G$ 中存在一条从 SCC $S_1$ 中的顶点到 SCC $S_2$ 中的顶点的边，则在 $C(G)$ 中存在一条边 $S_1 \\to S_2$。DFS 的一个关键引理是：\n**引理：** 如果在 $C(G)$ 中存在一条从 SCC $S_1$ 到 $S_2$ 的边，那么在对 $G$ 进行 DFS 的过程中，$S_1$ 中所有顶点的最大完成时间将大于 $S_2$ 中所有顶点的最大完成时间。即 $f_G(S_1) > f_G(S_2)$。\n\n现在我们将此引理应用于所提出的反向算法：\n\n1.  **步骤 1 & 2：在 $G^T$ 上运行 DFS 以获得完成时间。**\n    转置图的收缩图 $C(G^T)$ 恰好是 $C(G)$ 中所有边反向的结果。因此，如果在 $C(G)$ 中存在边 $S_1 \\to S_2$，那么在 $C(G^T)$ 中就存在边 $S_2 \\to S_1$。\n    将上述引理应用于在 $G^T$ 上进行的 DFS，我们得到：如果在 $C(G^T)$ 中存在边 $S_2 \\to S_1$，则 $f_{G^T}(S_2) > f_{G^T}(S_1)$。\n    这意味着，如果我们将 SCC 按在 $G^T$ 上 DFS 得到的完成时间降序排列，其顺序相当于对原始收缩图 $C(G)$ 的一次**逆向拓扑排序**。在 $G$ 中没有出边的 SCC（即“汇”分量）将出现在这个排序列表的最前面。\n\n2.  **步骤 3：使用新顺序在原始图 $G$ 上运行 DFS。**\n    第二次 DFS 在原始图 $G$ 上进行，其起始顶点遵循步骤 2 确定的顺序。选择的第一个顶点（设为 $v$）将属于 $G$ 的一个“汇” SCC（我们称之为 $S_{sink}$）。\n    当我们从 $v \\in S_{sink}$ 开始在 $G$ 上执行 DFS 时，搜索将访问所有从 $v$ 可达的顶点。由于 $S_{sink}$ 是 $C(G)$ 中的一个汇分量，不存在任何从 $S_{sink}$ 中的顶点指向其外部顶点的边。因此，这次 DFS 将被完全限制在 $S_{sink}$ 内部。最终得到的 DFS 树将精确地包含该 SCC 的所有顶点。\n\n这个过程成功地识别出了一个强连通分量。然后，算法移至排序列表中的下一个未访问顶点（它将属于*剩余*图的一个汇分量），并重复此过程。因此，第二次 DFS 森林中的每棵树都正确地对应 $G$ 的一个强连通分量。\n\n结论是，标准 Kosaraju 算法和这个“反向”变体都是正确的。它们互为对称版本。标准算法使用对 $C(G)$ 的拓扑排序来引导在 $G^T$ 上的搜索（从 $G$ 的源分量开始）。反向算法则使用对 $C(G)$ 的逆向拓扑排序来引导在 $G$ 上的搜索（从 $G$ 的汇分量开始）。\n\n因此，该反向算法是一种寻找任何有向图的所有强连通分量的正确方法。选项 A 是正确的。", "answer": "$$\\boxed{A}$$", "id": "1517055"}]}