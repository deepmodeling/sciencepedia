{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。要真正掌握图遍历算法，最有效的方法之一就是亲手模拟它的执行过程。这个练习将引导你逐步执行一个基于广度优先搜索（BFS）的验证算法，以检查网络中的频率分配是否存在冲突。通过这个实践，你将加深对队列、已访问集合以及BFS逐层扩展核心机制的理解 [@problem_id:1508906]。", "problem": "一家电信公司正在部署一个由 $N$ 座传输塔组成的新无线网络。为防止信号干扰，网络中的相邻塔必须分配不同的频率信道。一位初级工程师为所有塔提出了一个初始频率分配方案。您的任务是分析一个专门用于检查此分配是否存在冲突的验证算法的输出。\n\n该网络被建模为一个简单的无向图，其中塔是顶点，索引从 $0$ 到 $N-1$。如果两个顶点对应的塔距离足够近以至于会产生干扰，则它们之间存在一条边。频率分配以数组形式给出，其中第 $i$ 个元素是分配给塔 $i$ 的信道。\n\n验证算法的执行过程如下：\n1. 它对图执行广度优先搜索 (BFS) 遍历。\n2. 遍历从索引最低的顶点（顶点 0）开始。如果图有多个不连通的分量，遍历将只探索与顶点 0 相连的那个分量。\n3. 维护一个待访问顶点的队列。初始时，它只包含顶点 0。同时维护一个已访问顶点的集合，初始时也只包含顶点 0。\n4. 在每一步中，从队列中取出一个顶点 `u`。对于它的每一个邻居 `v`（按索引值升序排列），算法会检查顶点 `v` 是否与顶点 `u` 分配了相同的频率。\n5. 如果 `frequency(u) = frequency(v)`，则检测到冲突。算法立即终止并输出顶点索引对 `(u, v)`。\n6. 如果 `frequency(u) != frequency(v)` 且 `v` 未被访问过，则将 `v` 标记为已访问并加入队列。\n7. 如果BFS完成而没有发现任何此类冲突，算法将报告该分配在已探索的分量中是有效的。\n\n考虑一个有 $N=8$ 座塔的网络，编号为 0 到 7。\n频率分配由信道给出：`[Red, Green, Blue, Green, Red, Blue, Green, Red]`，分别对应塔 0 到 7。\n干扰链路（边）是：\n`(0, 1), (0, 4), (1, 2), (1, 3), (1, 6), (2, 5), (3, 7), (4, 5), (6, 7)`\n\n对于给定的网络配置，这个验证算法会产生什么输出？\n\nA. 顶点对 `(1, 3)`\nB. 顶点对 `(0, 4)`\nC. 顶点对 `(2, 5)`\nD. 频率分配有效。\nE. 顶点对 `(4, 5)`", "solution": "我们将网络建模为一个无向图，其顶点为 $0,1,\\ldots,7$，边集为 $\\{(0,1),(0,4),(1,2),(1,3),(1,6),(2,5),(3,7),(4,5),(6,7)\\}$。分配的频率（信道）为 $c(0)=\\text{Red}$，$c(1)=\\text{Green}$，$c(2)=\\text{Blue}$，$c(3)=\\text{Green}$，$c(4)=\\text{Red}$，$c(5)=\\text{Blue}$，$c(6)=\\text{Green}$，$c(7)=\\text{Red}$。\n\n验证算法从索引最低的顶点 0 开始执行BFS。它将队列初始化为 $[0]$，已访问集合初始化为 $\\{0\\}$。在每一步中，它从队列中取出一个顶点 $u$，并按索引递增的顺序扫描其邻居 $v$。对于每个邻居 $v$，它首先检查是否有 $c(u)=c(v)$。如果是，它会立即终止并输出顶点对 $(u,v)$。如果 $c(u)\\neq c(v)$ 且 $v$ 未被访问过，它会将 $v$ 标记为已访问并将其加入队列。\n\n执行过程：\n- 从队列中取出 $u=0$。顶点 0 的邻居是 $\\{1,4\\}$，按顺序为 $[1,4]$。\n  - 对于 $v=1$：$c(0)=\\text{Red}$ 且 $c(1)=\\text{Green}$，所以 $c(0)\\neq c(1)$。由于 1 未被访问，将其标记为已访问，得到 $\\{0,1\\}$，并将 1 加入队列，队列变为 $[1]$。\n  - 对于 $v=4$：$c(0)=\\text{Red}$ 且 $c(4)=\\text{Red}$，所以 $c(0)=c(4)$。检测到冲突，算法立即终止，输出顶点对 $(0,4)$。\n\n由于算法在检测到第一个冲突时停止，因此输出为 $(0,4)$，对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1508906"}, {"introduction": "图遍历不仅能用于寻找路径，更能揭示图的深层结构特性。这个练习将向你展示如何利用遍历来解决一个关于路径长度奇偶性的问题。通过判断一个图是否为二分图——这本身就可以通过BFS或DFS着色来实现——我们可以迅速确定两节点之间是否存在偶数长度的路径，这体现了遍历算法在图结构分析中的强大能力 [@problem_id:1508937]。", "problem": "在容错通信网络的设计中，工程师们正在探索一种冗余协议。为了验证一个数据包，它必须能够通过一条包含偶数条链路的路径，从源节点传输到目标节点。路径被定义为由边连接的一系列不同顶点。\n\n该网络拓扑由一个无向图表示，该图包含8个节点，标记为A到H。其连接（边）由以下邻接表给出：\n- A: [B, D]\n- B: [A, C, G]\n- C: [B, D, F]\n- D: [A, C, E]\n- E: [D, F, H]\n- F: [C, E, G]\n- G: [B, F, H]\n- H: [E, G]\n\n基于此网络结构，下列哪个陈述是正确的？\n\nA. 存在一条从节点A到节点G的偶数长度路径，但不存在从节点B到节点E的偶数长度路径。\nB. 存在一条从节点B到节点E的偶数长度路径，但不存在从节点A到节点G的偶数长度路径。\nC. 对于(A, G)和(B, E)这两对节点，都存在偶数长度的路径。\nD. 对于(A, G)和(B, E)这两对节点，都不存在偶数长度的路径。", "solution": "我们需要确定，对于给定的无向图，在指定的顶点对之间是否存在长度为偶数的简单路径（所有顶点都不同的路径）。我们使用的关键图论原理是二分图的特征：一个图是二分图当且仅当它不包含奇数环，等价地，它的顶点可以被划分到两个不相交的集合中，使得每条边都连接着一个集合到另一个集合。在一个划分为集合 $X$ 和 $Y$ 的二分图中，任何路径都在 $X$ 和 $Y$ 之间交替，因此对于任何从 $u$ 到 $v$ 的路径，其长度 $\\ell$ 满足\n$$\n\\ell \\equiv \n\\begin{cases}\n0 \\pmod{2},  \\text{if } u,v \\in X \\text{ or } u,v \\in Y, \\\\\n1 \\pmod{2},  \\text{if } u \\in X, v \\in Y \\text{ or } u \\in Y, v \\in X.\n\\end{cases}\n$$\n因此，两个顶点之间存在偶数长度的路径，当且仅当它们位于二分划分的同一部分中，前提是这两个顶点之间是连通的。\n\n现在我们通过构建一个有效的二着色（划分）来证明给定的图是二分图。首先将 $A$ 放入 $X$。由于 $A$ 与 $B$ 和 $D$ 相邻，我们必须将 $B,D \\in Y$。由于 $B$ 与 $C$ 和 $G$ 相邻，我们必须将 $C,G \\in X$。由于 $D$ 与 $C$ 和 $E$ 相邻，这要求 $C \\in X$（与之前一致）并且 $E \\in X$。接下来，由于 $C$ 与 $F$ 相邻，我们将 $F$ 放入 $Y$。由于 $E$ 与 $H$ 相邻，我们将 $H$ 放入 $Y$。检查所有剩余的邻接关系：$F$ 的邻居是 $\\{C,E,G\\}$，它们都在 $X$ 中；$G$ 的邻居是 $\\{B,F,H\\}$，它们都在 $Y$ 中；$H$ 的邻居是 $\\{E,G\\}$，它们都在 $X$ 中。这个分配是一致的，因此该图是二分图，其划分为\n$$\nX = \\{A,C,E,G\\}, \\quad Y = \\{B,D,F,H\\}.\n$$\n\n应用奇偶性规则：\n- 对于 $(A,G)$，我们有 $A \\in X$ 和 $G \\in X$，所以任何 $A$–$G$ 路径都具有偶数长度，因此存在偶数长度的路径。一个明确的例子是 $A-B-G$，其长度为2且使用不同的顶点。\n- 对于 $(B,E)$，我们有 $B \\in Y$ 和 $E \\in X$，所以任何 $B$–$E$ 路径都具有奇数长度。因此，不存在从 $B$ 到 $E$ 的偶数长度路径。例如，不存在长度为2的路径，因为从 $B$ 到其任何邻居 $\\{A,C,G\\}$，没有一个邻居与 $E$ 相邻，而二分划分的论证普遍排除了所有偶数长度的可能性。\n\n因此，存在从 $A$ 到 $G$ 的偶数长度路径，但不存在从 $B$ 到 $E$ 的偶数长度路径，这对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1508937"}, {"introduction": "在处理大型图时，标准的单向搜索可能会效率低下。为了解决这个问题，我们可以采用更高级的遍历策略，例如双向搜索。本练习介绍了一种“双向收敛搜索”算法，它从起点和终点同时开始搜索，并在中间交汇，显著减小了搜索空间。通过追踪这个“中间相遇”的过程，你将学会如何将基本的遍历思想扩展为解决复杂问题的更高效算法 [@problem_id:1508918]。", "problem": "一家名为“ConnectSphere”的科技公司正在为其服务器网状网络测试一种新的路由算法。该网络由一组服务器组成，通过整数ID进行标识。数据可以通过双向链接在特定的服务器对之间传输。该算法名为“双向收敛搜索 (Bidirectional Convergence Search, BCS)”，旨在寻找源服务器 `s` 和目标服务器 `t` 之间的通信路径。\n\nBCS 算法的规定如下：\n- 同时启动两个搜索过程：一个从 `s` 开始的“前向搜索”和一个从 `t` 开始的“后向搜索”。\n- 算法维护两个已访问服务器的集合：用于前向搜索的 `V_s` 和用于后向搜索的 `V_t`。初始时，`V_s = {s}` 且 `V_t = {t}`。\n- 它还维护两个待访问服务器的先进先出队列，代表每次搜索的前沿：`Q_s` 和 `Q_t`。初始时，`Q_s` 仅包含 `s`，`Q_t` 仅包含 `t`。\n- 算法以离散、交替的步骤进行（一次前向扩展后跟一次后向扩展）。\n\n1.  **前向扩展步骤**：前向搜索扩展一层。对于当前 `Q_s` 前沿的每个服务器 `u`，检查其所有邻居。任何尚未被添加到 `V_s` 的邻居 `v` 都会被添加到 `V_s` 中，并入队到一个用于下一个前向前沿的临时队列中。在处理完当前 `Q_s` 中的所有服务器后，`Q_s` 被这个临时队列替换。\n2.  **前向终止检查**：前向扩展完成后，算法检查集合 $V_s$ 和 $V_t$ 是否有任何共同的服务器。如果 $V_s \\cap V_t$ 不是空集，算法立即终止。\n3.  **后向扩展步骤**：如果算法没有终止，则后向搜索扩展一层。此步骤与前向扩展类似：对于 `Q_t` 中的每个服务器 `u`，任何不在 `V_t` 中的邻居 `v` 都会被添加到 `V_t` 中，并入队到一个用于下一个后向前沿的临时队列中。然后 `Q_t` 被这个临时队列替换。\n4.  **后向终止检查**：后向扩展后，算法再次检查 $V_s \\cap V_t$ 是否非空。如果非空，算法终止。否则，过程从前向扩展步骤开始重复。\n\n考虑一个由12个服务器组成的网络，其连接由以下服务器ID对给出：\n(1, 2), (1, 3), (1, 4), (2, 5), (3, 6), (3, 7), (4, 8), (5, 9), (6, 9), (7, 10), (8, 11), (9, 12), (10, 12), (11, 12)。\n\n源服务器是 `s=2`，目标服务器是 `t=11`。你的任务是确定算法终止时已访问的独立服务器总数。这是两个已访问集合在终止时刻的并集的大小，即 $|V_s \\cup V_t|$。", "solution": "将网络视为一个无向图，其邻居集由给定的双向链接确定。从这些服务器对中，可以得到邻居集为\n$$\n\\begin{aligned}\nN(1)=\\{2,3,4\\},\\quad N(2)=\\{1,5\\},\\quad N(3)=\\{1,6,7\\},\\quad N(4)=\\{1,8\\},\\\\\nN(5)=\\{2,9\\},\\quad N(6)=\\{3,9\\},\\quad N(7)=\\{3,10\\},\\quad N(8)=\\{4,11\\},\\\\\nN(9)=\\{5,6,12\\},\\quad N(10)=\\{7,12\\},\\quad N(11)=\\{8,12\\},\\quad N(12)=\\{9,10,11\\}.\n\\end{aligned}\n$$\n初始化双向搜索，源为 $s=2$，目标为 $t=11$：\n$$\nV_{s}=\\{2\\},\\quad Q_{s}=[2],\\quad V_{t}=\\{11\\},\\quad Q_{t}=[11].\n$$\n前向扩展步骤 1 (处理 $Q_{s}$ 中的所有元素)：从 $2$ 添加未访问过的邻居 $1,5$：\n$$\nV_{s}=\\{2,1,5\\},\\quad Q_{s}=[1,5].\n$$\n前向终止检查：\n$$\nV_{s}\\cap V_{t}=\\{2,1,5\\}\\cap\\{11\\}=\\varnothing.\n$$\n后向扩展步骤 1 (处理 $Q_{t}$ 中的所有元素)：从 $11$ 添加未访问过的邻居 $8,12$：\n$$\nV_{t}=\\{11,8,12\\},\\quad Q_{t}=[8,12].\n$$\n后向终止检查：\n$$\nV_{s}\\cap V_{t}=\\{2,1,5\\}\\cap\\{11,8,12\\}=\\varnothing.\n$$\n前向扩展步骤 2 (处理 $Q_{s}$ 中的所有元素)：从 $1$ 添加未访问过的邻居 $3,4$；从 $5$ 添加未访问过的邻居 $9$：\n$$\nV_{s}=\\{2,1,5,3,4,9\\},\\quad Q_{s}=[3,4,9].\n$$\n前向终止检查：\n$$\nV_{s}\\cap V_{t}=\\{2,1,5,3,4,9\\}\\cap\\{11,8,12\\}=\\varnothing.\n$$\n后向扩展步骤 2 (处理 $Q_{t}$ 中的所有元素)：从 $8$ 添加未访问过的邻居 $4$；从 $12$ 添加未访问过的邻居 $9,10$：\n$$\nV_{t}=\\{11,8,12,4,9,10\\},\\quad Q_{t}=[4,9,10].\n$$\n后向终止检查：\n$$\nV_{s}\\cap V_{t}=\\{2,1,5,3,4,9\\}\\cap\\{11,8,12,4,9,10\\}=\\{4,9\\}\\neq\\varnothing,\n$$\n因此算法在此处终止。终止时访问过的独立服务器总数为\n$$\n|V_{s}\\cup V_{t}|=\\left|\\{1,2,3,4,5,9\\}\\cup\\{11,8,12,4,9,10\\}\\right|=\\left|\\{1,2,3,4,5,8,9,10,11,12\\}\\right|=10.\n$$", "answer": "$$\\boxed{10}$$", "id": "1508918"}]}