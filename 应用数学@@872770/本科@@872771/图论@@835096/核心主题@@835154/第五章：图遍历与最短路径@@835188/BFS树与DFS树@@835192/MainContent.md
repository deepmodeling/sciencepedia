## 引言
[图遍历](@entry_id:267264)是算法领域探索和理解复杂网络结构的基石，而[广度优先搜索](@entry_id:156630)（BFS）和[深度优先搜索](@entry_id:270983)（DFS）是其中最核心的两种策略。然而，它们的意义远不止于访问图中的每个节点。在遍历过程中，这两种算法都会在图上隐式地勾勒出一棵生成树——即[BFS树](@entry_id:263690)或[DFS树](@entry_id:268024)。理解这两类树的内在结构、特性及其深刻差异，是解锁[图算法](@entry_id:148535)强大潜能的关键，但这部分知识往往被初学者所忽略。

本文旨在填补这一认知空白，系统性地剖析[BFS树](@entry_id:263690)与[DFS树](@entry_id:268024)。我们将超越算法的表面步骤，深入探讨它们为何以及如何在结构上产生分化，并最终决定其在不同问题域中的应用优势。

- 在**第一章“原理与机制”**中，我们将解剖这两种树的构建过程，对比它们的路径长度、[树高](@entry_id:264337)以及至关重要的非树边属性，揭示其结构差异的根源。
- 接着，在**第二章“应用与跨学科联系”**中，我们将展示这些理论特性如何转化为强大的应用工具，从解决[图论](@entry_id:140799)中的经典问题（如[环路检测](@entry_id:274955)、[二分图判定](@entry_id:635538)、关键节点识别）到助力[计算物理学](@entry_id:146048)和[生物信息学](@entry_id:146759)等前沿科学研究。
- 最后，**第三章“动手实践”**提供了一系列精心设计的问题，引导你通过实践来巩固对[BFS树](@entry_id:263690)和[DFS树](@entry_id:268024)的理解，将理论知识内化为解决实际问题的能力。

通过本次学习，你将不仅掌握两种基础的[图遍历](@entry_id:267264)算法，更能获得一种从结构视角分析和运用[图算法](@entry_id:148535)的深刻洞察力。

## 原理与机制

图的遍历是探索和分析其结构的基础。[广度优先搜索](@entry_id:156630)（BFS）和[深度优先搜索](@entry_id:270983)（DFS）是两种最核心的[图遍历](@entry_id:267264)算法。当我们在一个图上执行这些算法时，它们不仅访问了图中的顶点，还在图上隐式地定义了一棵[生成树](@entry_id:261279)（或在[非连通图](@entry_id:192455)中的[生成森林](@entry_id:262990)）。本章将深入探讨这两种遍历所产生的树（即[BFS树](@entry_id:263690)和[DFS树](@entry_id:268024)）的内在原理、结构特性及其根本差异。

### [图遍历](@entry_id:267264)的解剖：树边与非树边

无论是BFS还是DFS，当从一个起始顶点开始遍历一个连通图时，算法都会通过一系列“发现边”来构建一棵覆盖图中所有顶点的树。这棵树被称为**生成树**（Spanning Tree）。构成这棵树的边被称为**树边**（tree edges）。

给定一个含有 $n$ 个顶点和 $m$ 条边的连通[无向图](@entry_id:270905) $G=(V, E)$，任何由遍历算法生成的[生成树](@entry_id:261279) $T$ 都具有一些普适的性质。根据树的基本定义，一个包含 $n$ 个顶点的树必然恰好有 $n-1$ 条边。因此，无论我们使用BFS还是DFS，也无论我们从哪个顶点开始，生成的生成树中的树边数量都是恒定的：

树边数量 $= n-1$

图 $G$ 中不属于生成树 $T$ 的其余所有边被称为**非树边**（non-tree edges）。这些边的数量也同样是确定的，等于原图的总边数减去树边的数量 [@problem_id:1483535]。

非树边数量 $= m - (n-1) = m - n + 1$

虽然树边和非树边的数量是固定的，但它们的具体构成和[拓扑性质](@entry_id:141605)则深刻地揭示了[BFS和DFS](@entry_id:272000)这两种算法的本质区别。非树边并非无用；相反，它们在图中形成了“捷径”或“回路”，其相对于[生成树](@entry_id:261279)的连接方式是理解图结构的关键。

### [广度优先搜索](@entry_id:156630)（BFS）：逐层探索

[广度优先搜索](@entry_id:156630)从一个源顶点 $s$ 开始，系统地探索整个图。其核心机制是使用一个先进先出（FIFO）队列来管理待访问的顶点。这种机制确保了BFS的探索过程是逐“层”进行的：首先访问所有与 $s$ 距离为1的顶点，然后是所有距离为2的顶点，依此类推。

#### [BFS树](@entry_id:263690)及其定义性属性：最短路径

BFS遍历过程中，当顶点 $v$ 通过边 $(u, v)$ 被首次发现时，边 $(u, v)$ 就成为[BFS树](@entry_id:263690)的一条树边，并且 $u$ 成为 $v$ 的父节点。这样构建的树被称为**[BFS树](@entry_id:263690)**（BFS Tree），我们记为 $T_B$。

[BFS树](@entry_id:263690)最重要的，也是其定义性的属性是：在[无权图](@entry_id:273533)中，从根节点 $s$ 到任何其他顶点 $v$ 在[BFS树](@entry_id:263690) $T_B$ 中的唯一路径，同时也是在原图 $G$ 中的一条**[最短路径](@entry_id:157568)**。若我们用 $d_G(s, v)$ 表示在图 $G$ 中从 $s$ 到 $v$ 的[最短路径](@entry_id:157568)长度（边的数量），用 $d_{T_B}(s, v)$ 表示在树 $T_B$ 中从 $s$ 到 $v$ 的路径长度，那么以下等式恒成立 [@problem_id:1483517]：

$d_{T_B}(s, v) = d_G(s, v)$

这个属性源于BFS的逐层探索机制。我们可以通过对顶点所在的“层级”（即其到源点的最短距离）进行归纳来证明这一点。第 $k$ 层的顶点是在第 $k$ 次迭代中被发现的，并且它们必然是通过一条边从第 $k-1$ 层的某个顶点访问到的。这保证了树路径的长度恰好等于其层级，也就是[最短路径](@entry_id:157568)的长度。

#### BFS中非树边的结构

BFS中非树边的连接方式也具有鲜明的特征。对于任意一条非树边 $(u, v)$，其两个端点 $u$ 和 $v$ 在[BFS树](@entry_id:263690)中所处的层级 $L(u)$ 和 $L(v)$ 之间的关系必然满足：

$|L(u) - L(v)| \le 1$

这意味着，在[无向图](@entry_id:270905)中，一条非树边要么连接同一层级的两个顶点，要么连接相邻层级的两个顶点。为什么会这样？我们可以用[反证法](@entry_id:276604)来理解 [@problem_id:1483555]。假设存在一条非树边 $(u, v)$，使得 $L(u) = k$ 而 $L(v) = k+2$。根据BFS的定义，当算法在处理第 $k$ 层的顶点（包括 $u$）时，它会检查 $u$ 的所有邻居。此时，$v$ 尚未被发现，因此算法会通过边 $(u, v)$ 发现 $v$，并将其层级设为 $k+1$。这与 $L(v) = k+2$ 的假设相矛盾。因此，非树边不可能跨越两个或更多的层级。

#### [BFS树](@entry_id:263690)的唯一性

[BFS树](@entry_id:263690)的结构是否是唯一的？答案是否定的。它取决于算法在处理同一层顶点时访问其邻居的顺序。只有当原图中从源点 $s$ 到每个其他顶点 $v$ 的最短路径都是唯一的时候，[BFS树](@entry_id:263690)才是唯一的 [@problem_id:1483529]。

如果某个顶点 $v$ 在第 $k$ 层，并且它在第 $k-1$ 层有多个邻居（例如 $u_1$ 和 $u_2$），那么从 $s$ 到 $v$ 就存在多条长度为 $k$ 的[最短路径](@entry_id:157568)。在这种情况下，根据[BFS算法](@entry_id:264512)处理 $u_1$ 和 $u_2$ 的顺序， $v$ 的父节点可能是 $u_1$ 也可能是 $u_2$，从而产生结构不同的[BFS树](@entry_id:263690) [@problem_id:1483532]。一个典型的例子是偶数长度的环图，例如 $C_6$。从任一顶点 $s$ 出发，其对面的顶点将有两条等长的最短路径，导致[BFS树](@entry_id:263690)不唯一 [@problem_id:1483529]。相反，在奇数环图、完全图或[星形图](@entry_id:271558)中，从任何顶点出发的最短路径都是唯一的，因此[BFS树](@entry_id:263690)也是唯一的。

### [深度优先搜索](@entry_id:270983)（DFS）：深入探索

与BFS的广度扩展不同，[深度优先搜索](@entry_id:270983)（DFS）尽可能深地探索图的分支。一旦发现一个新顶点，它会立即从该新顶点继续探索，直到路径的尽头，然后才回溯到前一个顶点，探索其尚未访问的邻居。

#### DFS的机制：递归与栈

DFS的“深入”特性天然地通过递归实现。函数的[调用栈](@entry_id:634756)（call stack）自动维护了回溯所需的信息。我们也可以通过一个后进先出（LIFO）的**栈**（stack）来迭代地实现DFS。这揭示了一个深刻的联系：如果我们将BFS实现中的FIFO队列替换为LIFO栈，那么遍历行为就从广度优先转变为深度优先 [@problem_id:1483530]。

#### [DFS树](@entry_id:268024)与发现/完成时间

DFS遍历同样会生成一棵**[DFS树](@entry_id:268024)**（或森林），由发现新顶点时所经过的边构成。与BFS不同，[DFS树](@entry_id:268024)中的路径通常不是原[图中的最短路径](@entry_id:267725)。

DFS的一个强大分析工具是为每个顶点 $v$ 记录两个时间戳：**发现时间** $d[v]$ 和**完成时间** $f[v]$。$d[v]$ 是 $v$ 第一次被访问的时间，$f[v]$ 是 $v$ 的所有后代都被访问完毕，算法准备从 $v$ 回溯的时间。

这些时间戳形成了一个被称为**括号定理**（Parenthesis Theorem）的优美结构。对于任意两个顶点 $u$ 和 $v$，它们的时间区间 $[d[u], f[u]]$ 和 $[d[v], f[v]]$ 之间的关系只有两种可能：要么它们完全不相交，要么一个区间完全包含另一个。一个区间被另一个包含，正对应着图中的祖先-后代关系 [@problem_id:1483514]：

$v$ 是 $u$ 的后代 $\iff d[u]  d[v]  f[v]  f[u]$

这个性质使得我们仅凭时间戳就能准确判断[DFS树](@entry_id:268024)中的祖先关系，这对于边分类、[环路检测](@entry_id:274955)和[拓扑排序](@entry_id:156507)等应用至关重要。

#### DFS中非树边的结构

在DFS中，非树边同样可以根据其端点在[DFS树](@entry_id:268024)中的关系进行分类，包括**[后向边](@entry_id:260589)**（back edge，连接顶点到其祖先）、**前向边**（forward edge，连接顶点到其后代）和**交叉边**（cross edge，连接无祖先关系的两个顶点）。

对于**[无向图](@entry_id:270905)**的DFS而言，其非树边结构有一个极其重要的特性：**所有非树边都是[后向边](@entry_id:260589)** [@problem_id:1483552]。这意味着在[无向图](@entry_id:270905)的DFS遍历中，不可能出现前向边或交叉边 [@problem_id:1483541]。

为什么会这样？假设在DFS过程中，从顶点 $u$ 探索到一条边 $(u,v)$，而 $v$ 已经被访问过（因此 $(u,v)$ 是一条非树边）。因为 $v$ 已被访问，所以 $d[v]  d[u]$。在[无向图](@entry_id:270905)中，如果 $v$ 不是 $u$ 的祖先，那么 $v$ 肯定已经探索完毕并完成了（即 $f[v]  d[u]$），并且 $u$ 和 $v$ 属于不同的子树。但是，如果 $v$ 已经完成，那么在访问 $v$ 的过程中，由于边 $(v,u)$ 的存在（[无向图](@entry_id:270905)），算法本应该发现 $u$。这将使得 $u$ 成为 $v$ 的后代，这与 $d[v]  d[u]$ 且 $v$ 不是 $u$ 的祖先相矛盾。因此，唯一可能的情况是 $v$ 尚未完成探索，即 $u$ 正在 $v$ 的递归调用链中。这正是 $v$ 是 $u$ 的祖先的定义。所以，边 $(u,v)$ 必然是一条连接 $u$ 到其祖先 $v$ 的[后向边](@entry_id:260589)。

### [BFS树](@entry_id:263690)与[DFS树](@entry_id:268024)的比较分析

现在，我们可以系统地总结[BFS树](@entry_id:263690)和[DFS树](@entry_id:268024)在关键特性上的差异。

#### 路径长度与[树高](@entry_id:264337)

- **路径长度**：[BFS树](@entry_id:263690)保证了从根到任意顶点的路径都是最短的。[DFS树](@entry_id:268024)则不提供这样的保证；它的路径可能非常长且曲折。
- **[树高](@entry_id:264337)**：[树的高度](@entry_id:264337)定义为从根到最远叶子节点的路径长度。由于BFS路径是最短的，[BFS树](@entry_id:263690)的高度等于根节点在原图中的**偏心率**（到最远顶点的距离）。任何[生成树](@entry_id:261279)中从根到顶点的路径长度都不可能小于该顶点在原图中的最短距离。因此，对于同一图和同一根节点，我们总有 [@problem_id:1483528]：

$h_{BFS} \le h_{DFS}$

在某些情况下，两者的高度差可能非常显著。例如，在一个 $n$ 个顶点的完全图上，从任意顶点 $s$ 出发的[BFS树](@entry_id:263690)高度为1（一个[星形图](@entry_id:271558)），而DFS则可能生成一条包含所有 $n$ 个顶点的长链，其高度为 $n-1$ [@problem_id:1483517]。

#### 非树边的性质

- **BFS**：在[无向图](@entry_id:270905)中，非树边连接同一层级或相邻层级的顶点。它们可以是**交叉边**。
- **DFS**：在[无向图](@entry_id:270905)中，非树边**总是**连接顶点到其祖先的**[后向边](@entry_id:260589)**。

这个结构性差异是两种算法应用不同的根本原因。DFS中非树边必然形成环路（树边路径加上一条[后向边](@entry_id:260589)），这使得DFS成为检测环路的天然工具。而BFS的非树边则揭示了图中“捷径”的存在，这些捷径不长于两条相邻的树边。

总之，[BFS和DFS](@entry_id:272000)不仅仅是两种遍历图的方法。它们通过构建具有截然不同结构属性的[生成树](@entry_id:261279)，为我们提供了两种独特的视角来理解和利用图的拓扑。选择哪种算法，取决于我们是更关心“最短距离”还是更关心“连通性与回溯结构”。