{"hands_on_practices": [{"introduction": "在实践中，确定一个图的确切色数（$\\chi(G)$）通常是一个计算上的难题。因此，我们常常借助高效的算法来寻找一个上界。贪心算法就是一种直观且应用广泛的策略，而 Welsh-Powell 算法是其中的一个著名变体，它优先为度数最高的顶点分配颜色。通过这个练习 [@problem_id:1552856]，你将对一个具体的图应用该算法，亲身体验这种启发式方法如何一步步生成一个有效的顶点着色，并由此得到色数的一个可靠上界。", "problem": "考虑一个无向图 $G = (V, E)$，其顶点集为 $V = \\{A, B, C, D, E, F, G\\}$，边集 $E$ 包含以下边对：\n$E = \\{(A, B), (A, C), (A, D), (A, F), (B, C), (B, D), (B, E), (C, E), (C, F), (D, G), (E, G)\\}$.\n\nWelsh-Powell 算法是一种用于寻找图着色的贪心算法。它为图的色数提供了一个上界。该算法的步骤如下：\n1.  计算图中每个顶点的度。\n2.  按度数降序排列顶点。如果度数相同，则按字母顺序排列。\n3.  将第一种颜色分配给排序列表中的第一个顶点。\n4.  遍历排序列表中余下的顶点。对于每个顶点，如果它不与任何已用当前颜色着色的顶点相邻，则将此颜色分配给它。\n5.  如果仍有未着色的顶点，选择排序列表中的第一个未着色顶点，并为其分配一种新的、第二种颜色。\n6.  对所有未着色的顶点使用新颜色重复步骤4中描述的过程。\n7.  继续这个过程，每当所有剩余的未着色顶点都与至少一个使用当前颜色的顶点相邻时，就引入一种新颜色，直到所有顶点都被着色为止。\n\n通过将 Welsh-Powell 算法应用于图 $G$，确定实现有效着色所使用的颜色总数。这个数字是多少？", "solution": "通过计算每个顶点的邻边数量来计算其度数：\n$$\\deg(A)=4,\\ \\deg(B)=4,\\ \\deg(C)=4,\\ \\deg(D)=3,\\ \\deg(E)=3,\\ \\deg(F)=2,\\ \\deg(G)=2.$$\n按度数降序排列顶点，度数相同时按字母顺序排列：\n$$(A, B, C, D, E, F, G).$$\n第一种颜色：将颜色1分配给$A$。遍历列表；如果一个顶点不与所有已用颜色1着色的顶点相邻，则它可以被赋予颜色1。$B,C,D,F$与$A$相邻，不能使用颜色1；$E$不与$A$相邻，被赋予颜色1；$G$与$E$相邻，因此不能使用颜色1。此轮过后，使用颜色1的顶点集为 $\\{A,E\\}$。\n\n第二种颜色：顺序中第一个未着色的顶点是$B$，将颜色2分配给$B$。继续遍历：$C$与$B$相邻，跳过；$D$与$B$相邻，跳过；$F$不与$B$相邻，得到颜色2；$G$不与$B$和$F$相邻，得到颜色2。此轮过后，使用颜色2的顶点集为 $\\{B,F,G\\}$。\n\n第三种颜色：剩余未着色的顶点是$C$和$D$。将颜色3分配给$C$，然后检查$D$；由于$C$和$D$之间没有边，所以$D$也得到颜色3。此轮过后，所有顶点都用颜色$\\{1,2,3\\}$着色了。\n\n因此，Welsh-Powell 算法在该图上总共使用了3种颜色。", "answer": "$$\\boxed{3}$$", "id": "1552856"}, {"introduction": "尽管贪心算法提供了一种快速找到着色方案的方法，但其结果的好坏可能天差地别，这完全取决于顶点的处理顺序。一个“糟糕”的排序可能导致使用的颜色数量远超实际所需。这个练习 [@problem_id:1552858] 巧妙地揭示了贪心算法的这一“阿喀琉斯之踵”，通过对同一图应用两种截然不同的顶点排序，你将看到算法得出的颜色数可以从最优的 2 色急剧增加到 $n$ 色。这个鲜明的对比深刻地揭示了顶点排序在算法性能中的关键作用。", "problem": "考虑一个图族，我们称之为交错二部图（Staggered Bipartite Graphs），对于任意整数 $n \\ge 2$，记为 $S_n$。图 $S_n$ 有一个包含 $2n$ 个顶点的集合，$V = \\{a_1, a_2, \\dots, a_n\\} \\cup \\{b_1, b_2, \\dots, b_n\\}$。顶点 $a_i$ 和顶点 $b_j$ 之间存在一条边，当且仅当它们的下标不同，即 $i \\neq j$。在集合 $\\{a_1, \\ldots, a_n\\}$ 内部或集合 $\\{b_1, \\ldots, b_n\\}$ 内部，顶点之间没有边相连。\n\n贪婪着色算法根据一个指定的顺序逐个处理图的顶点来进行着色。对于每个顶点，它会分配一个尚未被其任何已着色邻居使用的最小正整数颜色。\n\n我们考虑 $S_n$ 的两种不同顶点排序：\n1. 排序 $\\pi_1$：顶点按先列出所有 'a' 顶点再列出所有 'b' 顶点的顺序排列：$(a_1, a_2, \\dots, a_n, b_1, b_2, \\dots, b_n)$。\n2. 排序 $\\pi_2$：顶点根据其下标在 'a' 和 'b' 集合之间交替排列：$(a_1, b_1, a_2, b_2, \\dots, a_n, b_n)$。\n\n设 $k_1$ 为贪婪算法在排序 $\\pi_1$ 下对图 $S_n$ 使用的颜色数。\n设 $k_2$ 为贪婪算法在排序 $\\pi_2$ 下对图 $S_n$ 使用的颜色数。\n\n求比值 $\\frac{k_2}{k_1}$ 关于 $n$ 的表达式。", "solution": "给定图 $S_{n}$，其顶点集为 $A=\\{a_{1},\\dots,a_{n}\\}$ 和 $B=\\{b_{1},\\dots,b_{n}\\}$，边恰好存在于 $i\\neq j$ 的 $a_{i}$ 和 $b_{j}$ 之间。在 $A$ 内部或 $B$ 内部没有边。贪婪着色算法按给定顺序为每个顶点分配一个未被其任何已着色邻居使用的最小正整数。\n\n首先考虑排序 $\\pi_{1}=(a_{1},\\dots,a_{n},b_{1},\\dots,b_{n})$。\n- 对于每个 $a_{i}$，当它被处理时，它的邻居都还没有被着色，因为 $a_{i}$ 的所有邻居都在集合 $B$ 中，而 $B$ 中的顶点在排序中出现得更晚。因此，每个 $a_{i}$ 都被赋予颜色 $1$。\n- 对于每个 $b_{j}$，其已着色的邻居是所有满足 $i\\neq j$ 的 $a_{i}$，而所有这些 $a_{i}$ 的颜色都是 $1$。因此，颜色 $1$ 被禁用，可用的最小颜色是 $2$。由于 $B$ 的顶点之间没有边，每个 $b_{j}$ 也都获得颜色 $2$。\n因此，在排序 $\\pi_1$ 下，贪婪算法恰好使用 $k_{1}=2$ 种颜色。\n\n接下来考虑排序 $\\pi_{2}=(a_{1},b_{1},a_{2},b_{2},\\dots,a_{n},b_{n})$。\n我们对 $i$ 进行归纳，以证明对于每个 $i$， $a_{i}$ 和 $b_{i}$ 都被赋予颜色 $i$。\n- 归纳基础 $i=1$：$a_{1}$ 没有已着色的邻居，所以它获得颜色 $1$。然后，$b_{1}$ 与 $a_{1}$ 没有边，所以它也没有已着色的邻居，也获得颜色 $1$。\n- 归纳步骤：假设对于 $1\\leq m\\leq i-1$，$a_{m}$ 和 $b_{m}$ 的颜色都是 $m$。当处理 $a_{i}$ 时，其已着色的邻居恰好是 $b_{1},\\dots,b_{i-1}$（因为对于 $j\\neq i$，$b_{j}$ 与 $a_{i}$ 相邻）。根据归纳假设，这些邻居使用了颜色 $1,2,\\dots,i-1$，所以 $a_{i}$ 可用的最小颜色是 $i$。接下来，对于 $b_{i}$，其已着色的邻居恰好是 $a_{1},\\dots,a_{i-1}$（因为对于 $j\\neq i$，$a_{j}$ 与 $b_{i}$ 相邻），根据归纳假设，它们的颜色是 $1,2,\\dots,i-1$。因此，$b_{i}$ 可用的最小颜色也是 $i$。\n根据归纳法，当 $i=n$ 时，算法恰好使用了颜色 $1,2,\\dots,n$，所以 $k_{2}=n$。\n\n因此，比值为\n$$\n\\frac{k_{2}}{k_{1}}=\\frac{n}{2}.\n$$", "answer": "$$\\boxed{\\frac{n}{2}}$$", "id": "1552858"}, {"introduction": "既然顶点排序如此关键，我们自然会思考：是否存在一种“最佳”排序，能够揭示图的某种内在结构特性？“简并度”（degeneracy），记作 $d(G)$，正是这样一个概念。它与一种特殊的顶点排序相关，并为图的色数提供了一个可靠且重要的理论上界：$\\chi(G) \\le d(G)+1$。这个练习 [@problem_id:1552838] 要求你为一个结构较为复杂的图家族确定其简并度，这不仅是对你寻找最优顶点排序能力的挑战，也是一次从算法过程到图结构分析的思维升级。", "problem": "如果图 $G$ 的每个子图都至少有一个度最大为 $k$ 的顶点，则称图 $G$ 为 $k$-退化图。使图 $G$ 是 $k$-退化的最小整数 $k$ 称为图 $G$ 的退化度。定义退化度的一种等价方式是通过顶点排序：退化度是最小的整数 $k$，使得存在图 $G$ 的顶点的一个排序，例如 $(v_1, v_2, \\ldots, v_N)$，其中每个顶点 $v_i$ 在集合 $\\{v_{i+1}, \\ldots, v_N\\}$ 中最多有 $k$ 个邻点。\n\n考虑一个称为桥接轮图的特殊图，记作 $BW_n$，为整数 $n \\geq 3$ 构建。其构建过程如下：\n1. 从两个相同且不相交的轮图副本开始。每个轮图由一个中心顶点和一个由“轮辐”顶点组成的 $n$-圈构成，其中中心顶点与每个轮辐顶点相连。因此，每个轮图有 $n+1$ 个顶点。\n2. 设第一个轮图的中心顶点为 $c_1$，其轮辐顶点按圈排列为 $(u_1, u_2, \\ldots, u_n)$。这个圈的边是 $(u_i, u_{i+1})$（对于 $i=1,\\dots,n-1$）和 $(u_n, u_1)$。\n3. 设第二个轮图的中心顶点为 $c_2$，其轮辐顶点按类似的圈排列为 $(v_1, v_2, \\ldots, v_n)$。\n4. 图 $BW_n$ 是由这两个轮图的并集，并加上一组“桥”边构成的。对于从 $1$ 到 $n$ 的每个 $i$，添加一条连接顶点 $u_i$ 和顶点 $v_i$ 的边。\n\n确定对于任意整数 $n \\ge 5$ 时，桥接轮图 $BW_n$ 的退化度。", "solution": "设 $G$ 为桥接轮图 $BW_n$。我们首先确定在 $n \\ge 5$ 的情况下 $G$ 中所有顶点的度。图 $G$ 总共有 $2(n+1)$ 个顶点：两个中心顶点 $\\{c_1, c_2\\}$，以及 $2n$ 个轮辐顶点 $\\{u_1, \\ldots, u_n\\}$ 和 $\\{v_1, \\ldots, v_n\\}$。\n\n1.  **中心顶点 ($c_1, c_2$):** 中心顶点 $c_1$ 与其所有 $n$ 个轮辐顶点 $u_1, \\ldots, u_n$ 相连。中心顶点 $c_2$ 与其所有 $n$ 个轮辐顶点 $v_1, \\ldots, v_n$ 相连。因此，$\\deg(c_1) = \\deg(c_2) = n$。\n\n2.  **轮辐顶点 ($u_i, v_i$):**\n    对于第一个轮辐上的每个顶点 $u_i$，其邻点是：\n    - 中心顶点 $c_1$。\n    - 它在圈上的两个邻点，$u_{i-1}$ 和 $u_{i+1}$（下标在集合 $\\{1, \\ldots, n\\}$ 中对 $n$ 取模）。\n    - 另一个轮辐上的相应顶点 $v_i$，通过一条桥边相连。\n    因此，对于每个 $i \\in \\{1,\\ldots,n\\}$，$\\deg(u_i) = 1 + 2 + 1 = 4$。\n    类似地，对于第二个轮辐上的每个顶点 $v_i$，$\\deg(v_i) = 1 + 2 + 1 = 4$。\n\n图 $G$ 中所有顶点的度集为 $\\{n, 4\\}$。因为问题说明 $n \\ge 5$，所以 $G$ 中任意顶点的最小度为 $\\delta(G) = \\min(n, 4) = 4$。\n\n现在，设 $d(G)$ 表示 $G$ 的退化度。一个图的退化度总是大于或等于其任何子图的最小度。特别地，$d(G)$ 必须大于或等于 $G$ 本身的最小度。因此，我们得到了退化度的一个下界：\n$$d(G) \\ge \\delta(G) = 4$$\n\n为了找到一个上界，我们使用退化度的等价定义并构造一个顶点排序。我们需要找到一个顶点排序 $(p_1, p_2, \\ldots, p_{2n+2})$，使得任何顶点 $p_j$ 在序列中后面出现的顶点 $(p_{j+1}, \\ldots, p_{2n+2})$ 中最多有 $k$ 个邻点。如果我们能为 $k=4$ 找到这样一个排序，我们就证明了 $d(G) \\le 4$。\n\n考虑以下排序 $\\mathcal{O}$：\n$$ \\mathcal{O} = (u_1, u_2, \\ldots, u_n, v_1, v_2, \\ldots, v_n, c_1, c_2) $$\n让我们分析每个顶点的“前向邻点”（在 $\\mathcal{O}$ 中后出现的邻点）的数量。\n\n- **对于顶点 $u_i$（其中 $1 \\le i \\le n$）：** $u_i$ 的邻点是 $\\{u_{i-1}, u_{i+1}, c_1, v_i\\}$。\n    - 如果 $i=1$，其邻点是 $\\{u_n, u_2, c_1, v_1\\}$。在排序 $\\mathcal{O}$ 中，所有这些邻点都出现在 $u_1$ 之后。所以，$u_1$ 有 4 个前向邻点。\n    - 如果 $1  i  n$，其邻点是 $\\{u_{i-1}, u_{i+1}, c_1, v_i\\}$。顶点 $u_{i-1}$ 在 $\\mathcal{O}$ 中出现在 $u_i$ 之前。顶点 $u_{i+1}, c_1, v_i$ 都出现在 $u_i$ 之后。所以，$u_i$ 有 3 个前向邻点。\n    - 如果 $i=n$，其邻点是 $\\{u_{n-1}, u_1, c_1, v_n\\}$。顶点 $u_{n-1}$ 和 $u_1$ 出现在 $u_n$ 之前。顶点 $c_1$ 和 $v_n$ 出现在 $u_n$ 之后。所以，$u_n$ 有 2 个前向邻点。\n在 $\\{u_1, \\ldots, u_n\\}$ 这一组顶点中，任何顶点的最大前向邻点数是 4。\n\n- **对于顶点 $v_i$（其中 $1 \\le i \\le n$）：** $v_i$ 的邻点是 $\\{v_{i-1}, v_{i+1}, c_2, u_i\\}$。\n    - 对任何 $i$，顶点 $u_i$ 出现在排序的第一部分，所以它总是一个“后向邻点”。\n    - 如果 $i=1$，其邻点是 $\\{v_n, v_2, c_2, u_1\\}$。后向邻点是 $u_1$。前向邻点是 $\\{v_n, v_2, c_2\\}$。所以，$v_1$ 有 3 个前向邻点。\n    - 如果 $1  i  n$，其邻点是 $\\{v_{i-1}, v_{i+1}, c_2, u_i\\}$。后向邻点是 $v_{i-1}$ 和 $u_i$。前向邻点是 $\\{v_{i+1}, c_2\\}$。所以，$v_i$ 有 2 个前向邻点。\n    - 如果 $i=n$，其邻点是 $\\{v_{n-1}, v_1, c_2, u_n\\}$。后向邻点是 $v_{n-1}$、$v_1$ 和 $u_n$。唯一的前向邻点是 $c_2$。所以，$v_n$ 有 1 个前向邻点。\n在 $\\{v_1, \\ldots, v_n\\}$ 这一组顶点中，任何顶点的最大前向邻点数是 3。\n\n- **对于中心顶点 $c_1$ 和 $c_2$：**\n    - $c_1$ 的邻点是 $\\{u_1, \\ldots, u_n\\}$。所有这些顶点在排序 $\\mathcal{O}$ 中都出现在 $c_1$ 之前。因此，$c_1$ 有 0 个前向邻点。\n    - $c_2$ 的邻点是 $\\{v_1, \\ldots, v_n\\}$。所有这些顶点在 $\\mathcal{O}$ 中都出现在 $c_2$ 之前。因此，$c_2$ 有 0 个前向邻点。\n\n对于此排序 $\\mathcal{O}$，图中所有顶点的最大前向邻点数为 4（由顶点 $u_1$ 达到）。这证明了图 $G$ 的退化度最多为 4。\n$$d(G) \\le 4$$\n\n结合我们的两个结果，$d(G) \\ge 4$ 和 $d(G) \\le 4$，我们得出结论，对于 $n \\ge 5$，桥接轮图 $BW_n$ 的退化度恰好为 4。", "answer": "$$\\boxed{4}$$", "id": "1552838"}]}