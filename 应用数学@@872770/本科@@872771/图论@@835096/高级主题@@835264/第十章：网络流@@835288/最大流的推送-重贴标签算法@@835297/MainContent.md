## 引言
推送-重贴标签算法是解决网络[最大流问题](@entry_id:272639)的强大而高效的工具，它与传统的基于增广路的算法（如[Ford-Fulkerson](@entry_id:274348)）在思路上有着本质的区别。当增广路算法致力于在整个网络中寻找并增加流路径时，它们可能面临性能瓶颈，尤其是在特定结构的图中。推送-重贴标签算法通过一种新颖的“局部化”视角绕开了这一挑战，它允许流量在中间节点暂时“累积”，然后像水流一样，在高度[势能](@entry_id:748988)的引导下逐步流向汇点。这种方法不仅在理论上优雅，在实践中也常常表现出卓越的性能。

本文将系统性地引导你深入掌握推送-重贴标签算法。在第一章**“原理与机制”**中，我们将剖析算法的基石——预流与[高度函数](@entry_id:181180)，并详细拆解其核心的推送与重贴标签操作。接下来，在第二章**“应用与跨学科联系”**中，我们将探索[提升算法](@entry_id:635795)效率的实用优化技巧，展示其在解决最大[二分匹配](@entry_id:274152)等组合问题中的威力，并揭示其与[线性规划](@entry_id:138188)等领域的深刻联系。最后，在第三章**“动手实践”**中，你将通过一系列精心设计的问题，亲手模拟和分析算法的关键步骤，将理论知识转化为实践能力。

让我们首先进入算法的核心，深入探讨其独特的原理与机制。

## 原理与机制

与依赖于在[残差图](@entry_id:169585)中寻找增广路的算法（如[Ford-Fulkerson](@entry_id:274348)或Edmonds-Karp）不同，推送-重贴标签（Push-Relabel）算法采用了一种截然不同的局部化策略来计算[最大流](@entry_id:178209)。增广路算法在每次迭代中都维持一个有效的流，并逐步增加其流量值。相比之下，推送-重贴标签算法在一个更宽松的约束下运作，它维护一个**预流（preflow）**。这个预流最终将被转化为一个有效的最大流。这种方法的核心在于两个概念：**超额流（excess flow）**和**[高度函数](@entry_id:181180)（height function）**。

### 预流、超额流与[高度函数](@entry_id:181180)

为了理解推送-重贴标签算法，我们必须首先掌握它的基本概念。

**预流 (Preflow)**

一个预流 $f$ 是一个定义在图的边上的函数，它类似于一个正常的流，但有一个关键的例外。它必须满足以下两个条件：

1.  **容量限制 (Capacity Constraint):** 对于网络中的任意一条边 $(u, v)$，其上的流量不能超过该边的容量，即 $0 \le f(u, v) \le c(u, v)$。
2.  **松弛的流守恒 (Relaxed Conservation):** 对于除了源点 $s$ 和汇点 $t$ 之外的任意一个中间节点 $v$，流入该节点的总流量必须大于或等于流出该节点的总流量。

形式上，我们定义一个节点的**超额流 (excess flow)** $e(v)$ 为：
$$e(v) = \sum_{(u,v) \in E} f(u, v) - \sum_{(v,w) \in E} f(v, w)$$

对于一个预流，所有中间节点 $v \in V \setminus \{s, t\}$ 都必须满足 $e(v) \ge 0$。这意味着流量可以在中间节点“暂存”或“累积”。当一个中间节点 $v$ 的超额流严格为正，即 $e(v) > 0$ 时，我们称该节点是**活跃的 (active)**。推送-重贴标签算法的根本目标，就是通过一系列操作，将所有活跃节点的超额流“推送”到汇点 $t$ 或“退回”到源点 $s$，直到网络中不再有任何活跃节点。

例如，考虑一个网络 $V = \{s, a, b, c, t\}$，以及一个给定的预流。我们可以通过计算每个中间节点的流入量和流出量之差来确定其是否为活跃节点 [@problem_id:1529556]。假设 $f(s, a) = 7$，$f(a, b) = 3$，$f(a, c) = 2$，则节点 $a$ 的超额流为 $e(a) = f(s, a) - (f(a, b) + f(a, c)) = 7 - (3 + 2) = 2$。由于 $e(a) > 0$，节点 $a$ 是一个活跃节点。

**[高度函数](@entry_id:181180) (Height Function)**

[高度函数](@entry_id:181180) $h: V \to \mathbb{N}$ 是推送-重贴标签算法的另一个核心。这个函数为每个节点分配一个非负整数“高度”。这个高度并不代表任何物理距离，而是一个用于指导流向的势函数。其直观思想是，流量只能从较高的节点“向下”流向较低的节点。源点 $s$ 被赋予一个最高的高度，而汇点 $t$ 的高度始终为零，这就像创建了一个“水位差”，驱动着超额流最终流向汇点。

### 算法的构建模块

推送-重贴标签算法通过三个阶段进行：初始化、执行一系列的推送和重贴标签操作，以及终止。

#### 初始化

算法的起点是一个特定的初始预流和[高度函数](@entry_id:181180)配置。

1.  **初始化流 (Initialize Flow):** 将所有与源点 $s$ 直接相连的边的流量设置为其容量上限，即对于所有邻接于 $s$ 的节点 $v$，令 $f(s, v) = c(s, v)$。网络中所有其他边的流量均设为 $0$。这相当于在源点“打开阀门”，让流量尽可能多地涌入网络。
2.  **初始化高度 (Initialize Height):** 将源点 $s$ 的高度设置为网络中的节点总数 $|V|$，即 $h(s) = |V|$。所有其他节点 $v \in V \setminus \{s\}$ 的高度均初始化为 $0$。汇点 $t$ 的高度 $h(t)=0$ 将在整个算法执行期间保持不变。
3.  **计算初始超额流 (Calculate Initial Excess):** 基于初始化的流，计算每个节点的超额流。源点 $s$ 会有一个巨大的负超额（所有流出的流量），而与源点直接相连的邻居节点将获得正的超额流，成为初始的活跃节点。

例如，在一个包含四个节点 $s, u, v, t$ 的网络中，其中 $|V|=4$，初始化过程将设置 $h(s) = 4, h(u)=h(v)=h(t)=0$。如果 $c(s,u)=15$，则 $f(s,u)=15$，这导致 $e(u)=15$ 且 $e(s)=-15$ [@problem_id:1529545]。节点 $u$ 因此成为一个活跃节点。

#### 基本操作

初始化之后，算法进入主循环，只要网络中还存在活跃节点，就持续执行以下两种基本操作之一。算法只对活跃节点进行操作，因为只有这些节点才有多余的流量需要被处理 [@problem_id:1529569]。

**推送操作 (The Push Operation)**

推送操作将流量从一个活跃节点 $u$ 发送到它的一个邻居节点 $v$。一个推送操作 `Push(u,v)` 是**可应用的 (applicable)**，当且仅当满足以下所有条件：
1.  节点 $u$ 是活跃的 ($e(u) > 0$)。
2.  边 $(u,v)$ 在**[残差图](@entry_id:169585) (residual graph)** $G_f$ 中存在，即其残差容量 $c_f(u, v) = c(u, v) - f(u, v) > 0$（对于[反向边](@entry_id:260589)，则是 $c_f(v,u) = f(u,v) > 0$）。
3.  节点 $u$ 的高度恰好比节点 $v$ 的高度大 1，即 $h(u) = h(v) + 1$。

满足条件2和3的边 $(u,v)$ 被称为**可允许边 (admissible edge)** [@problem_id:1529562]。推送操作只能沿着可允许边进行。推送的流量 $\delta$ 等于节点 $u$ 的超额流和边 $(u,v)$ 的残差容量中的较小者：
$$\delta = \min(e(u), c_f(u, v))$$

推送操作之后，[流函数](@entry_id:266505) $f$ 和相[关节点](@entry_id:637448)的超额流会相应更新：$f(u,v)$ 增加 $\delta$，$f(v,u)$ 减少 $\delta$，$e(u)$ 减少 $\delta$，$e(v)$ 增加 $\delta$。值得注意的是，如果 $u$ 和 $v$ 都是中间节点，那么它们超额流的总和 $e(u)+e(v)$ 在推送前后保持不变，流量只是在它们之间重新分配 [@problem_id:1529567]。

**重贴标签操作 (The Relabel Operation)**

如果一个活跃节点 $u$ 没有任何出射的可允许边，这意味着它的超额流被“困住”了——它无法将流量推送到任何更低的邻居节点。在这种情况下，就需要执行**重贴标签 (relabel)** 操作。

一个重贴标签操作 `Relabel(u)` 是**可应用的**，当且仅当：
1.  节点 $u$ 是活跃的 ($e(u) > 0$)。
2.  对于所有在[残差图](@entry_id:169585) $G_f$ 中与 $u$ 相邻的节点 $v$（即 $c_f(u,v) > 0$），都不满足 $h(u) = h(v) + 1$。实际上，可以证明此时必然满足 $h(u) \le h(v)$。

重贴标签操作会增加节点 $u$ 的高度，使其“高过”它在[残差图](@entry_id:169585)中的最低邻居，从而为未来的推送操作创造条件。新的高度被设置为：
$$h(u) \leftarrow 1 + \min \{ h(v) \mid (u,v) \text{ is an edge in } G_f \}$$

例如，如果一个活跃节点 $a$ 的高度 $h(a)=0$，而它在[残差图](@entry_id:169585)中的所有邻居 $v$ 的高度也都是 $0$ 或更高，那么就不存在可允许边。此时必须对 $a$ 进行重贴标签。如果其邻居的最低高度为 $0$，则 $a$ 的新高度将变为 $h(a) = 1+0 = 1$ [@problem_id:1529526]。这个操作为之后从 $a$ 到高度为 $0$ 的邻居的推送创造了可能 [@problem_id:1529588]。

#### 放电过程 (The Discharge Procedure)

许多推送-重贴标签算法的实现将针对单个活跃节点的操作组织成一个名为**放电 (Discharge)** 的过程。`Discharge(u)` 会持续对活跃节点 $u$ 应用推送和重贴标签操作，直到该节点的超额流 $e(u)$ 变为零。在一个典型的 `Discharge(u)` 过程中，算法会优先寻找可允许边进行推送；如果找不到，就对 $u$ 进行一次重贴标签，然后继续尝试推送，如此循环往复 [@problem_id:1529546]。

### 算法的[不变性](@entry_id:140168)、终止性与正确性

推送-重贴标签算法的优雅之处在于其看似简单的局部操作能够保证全局的正确性。这依赖于几个关键的性质。

#### 关键不变性

在算法的整个执行过程中（初始化之后），以下**高度不变性 (height invariant)** 始终保持成立：
对于[残差图](@entry_id:169585) $G_f$ 中的任意一条边 $(u,v)$，都有 $h(u) \le h(v) + 1$。

这个[不变性](@entry_id:140168)是算法正确性的基石。推送操作显然维持此[不变性](@entry_id:140168)，因为它只在 $h(u) = h(v) + 1$ 时发生。而重贴标签操作的设计也正是为了在节点“被困”时恢复这个属性。如果[算法终止](@entry_id:143996)时，我们发现[残差图](@entry_id:169585)中存在一条边 $(u,v)$ 使得 $h(u) > h(v) + 1$，那么这必然意味着算法的执行或最终状态的记录出现了错误，因为它违反了这个核心属性 [@problem_id:1529587]。

#### 终止性分析

推送-重贴标签算法一定会终止吗？答案是肯定的。这可以通过分析重贴标签和推送操作的总数来证明。

一个关键的观察是，每次对节点 $u$ 进行重贴标签，其高度 $h(u)$ 都会严格增加。那么，一个节点的高度可以无限增加吗？并不能。可以证明，对于任何活跃节点 $u \in V \setminus \{s,t\}$，在[残差图](@entry_id:169585)中总存在一条从 $u$ 到源点 $s$ 的简单路径。利用高度[不变性](@entry_id:140168) $h(v_i) \le h(v_{i+1}) + 1$ 在这条路径上进行累加，并结合 $h(s)=|V|$，可以推导出任何中间节点的高度 $h(u)$ 的[上界](@entry_id:274738)为 $2|V|-1$ [@problem_id:1529523]。由于每个节点的高度有[上界](@entry_id:274738)且只增不减，所以重贴标签操作的总数是有限的。两次重贴标签之间的推送操作（称为饱和推送）数量也是有限的。因此，整个算法必然会在有限步内终止。

#### [正确性证明](@entry_id:636428)

当[算法终止](@entry_id:143996)时，网络中没有活跃节点，这意味着所有中间节点的超额流都为零。此时的预流满足了流[守恒定律](@entry_id:269268)，因此是一个有效的流。但我们如何确信这个流是最大流呢？

这可以通过证明在[算法终止](@entry_id:143996)时，[残差图](@entry_id:169585) $G_{f'}$ 中不存在任何从 $s$ 到 $t$ 的增广路来完成。根据[最大流最小割定理](@entry_id:150459)，这足以证明 $f'$ 是最大流。

证明过程是一个经典的[反证法](@entry_id:276604)，它巧妙地结合了高度不变性和源点/汇点的高度设置。假设在最终的[残差图](@entry_id:169585) $G_{f'}$ 中存在一条从 $s$ 到 $t$ 的简单路径 $s = v_0, v_1, \dots, v_k = t$。由于这条路径上的每一条边 $(v_i, v_{i+1})$ 都满足高度不变性 $h'(v_i) \le h'(v_{i+1}) + 1$，我们可以得到：
$$h'(s) = h'(v_0) \le h'(v_1) + 1 \le h'(v_2) + 2 \le \dots \le h'(v_k) + k = h'(t) + k$$

由于算法固定 $h'(s) = |V|$ 且 $h'(t) = 0$，上述不等式变为：
$$|V| \le 0 + k = k$$

然而，因为该路径是简单的，它最多包含 $|V|-1$ 条边，即 $k \le |V|-1$。于是我们得到了 $|V| \le |V|-1$ 的矛盾。这个矛盾说明，我们的初始假设——存在一条 $s-t$ 增广路——是错误的。因此，最终得到的流必定是[最大流](@entry_id:178209) [@problem_id:1529571]。

综上所述，推送-重贴标签算法通过维护预流和[高度函数](@entry_id:181180)，以一系列纯粹的局部操作，巧妙地将一个初始的、非法的预流逐步修正为一个有效的[最大流](@entry_id:178209)，其正确性由贯穿始终的高度不变性来保证。