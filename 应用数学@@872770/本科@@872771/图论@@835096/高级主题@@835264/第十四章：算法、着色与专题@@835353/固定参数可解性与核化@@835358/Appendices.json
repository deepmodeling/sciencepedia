{"hands_on_practices": [{"introduction": "核化是参数化算法的核心技术之一，它通过应用一系列“规约规则”来反复简化问题实例。本练习将让你亲自动手，在一个具体图上应用几条简单的规约规则，直观地体验图是如何被一步步化简的[@problem_id:1504250]。通过这个过程，你将加深对核化过程和“不可规约”实例（即“核”）的理解。", "problem": "在计算复杂性理论中，反馈顶点集（Feedback Vertex Set, FVS）问题是一个经典的图问题。对于一个无向图 $G=(V, E)$，反馈顶点集是顶点的一个子集 $S \\subseteq V$，使得通过移除 $S$ 中的顶点及所有相关联的边得到的图 $G-S$ 是无环的（即森林）。FVS问题的判定版本是，对于给定的图 $G$ 和一个整数参数 $k$，是否存在一个大小最多为 $k$ 的反馈顶点集。\n\n通常情况下，这个问题是计算困难的。然而，它是固定参数可解的，这意味着我们可以设计一个核化算法。核化算法包含一组多项式时间的规约规则，可将一个问题实例 $(G, k)$ 转换为一个等价的、更小的实例 $(G', k')$。如果一个实例的解可以用来构造原始实例的解，那么这两个实例就被认为是等价的。对于FVS问题，如果 $G'$ 的任何最小FVS可以被转换为 $G$ 的最小FVS（反之亦然），那么这个规约规则是安全的。如果不能再应用任何规约规则，则称该实例是不可规约的。最终的不可规约实例称为核。\n\n考虑以下两个针对FVS问题的简单规约规则：\n- **规则 A (孤立顶点移除):** 如果一个顶点 $v$ 的度为0，则通过从图中移除 $v$ 形成一个等价实例。新的实例是 $(G-v, k)$。\n- **规则 B (叶顶点移除):** 如果一个顶点 $v$ 的度为1，则通过从图中移除 $v$ 形成一个等价实例。新的实例是 $(G-v, k)$。\n\n给定一个无向图 $G$，其顶点集为 $V = \\{v_1, v_2, v_3, v_4, v_5, v_6, v_7, v_8, v_9, v_{10}, v_{11}, v_{12}\\}$，边集 $E$ 包含以下边：$\\{v_2, v_3\\}$, $\\{v_3, v_4\\}$, $\\{v_4, v_2\\}$, $\\{v_5, v_6\\}$, $\\{v_6, v_7\\}$, $\\{v_7, v_5\\}$, $\\{v_4, v_5\\}$, $\\{v_2, v_8\\}$, $\\{v_8, v_9\\}$, $\\{v_6, v_{10}\\}$ 和 $\\{v_{11}, v_{12}\\}$。\n\n从图 $G$ 开始，以任意顺序重复应用规则 A 和规则 B，直到图不可规约（即无法再应用任何规则）。最终的不可规约图中的顶点总数是多少？", "solution": "我们从无向图 $G=(V,E)$ 开始，其中顶点集 $V=\\{v_{1},v_{2},v_{3},v_{4},v_{5},v_{6},v_{7},v_{8},v_{9},v_{10},v_{11},v_{12}\\}$，边集 $E=\\{\\{v_{2},v_{3}\\},\\{v_{3},v_{4}\\},\\{v_{4},v_{2}\\},\\{v_{5},v_{6}\\},\\{v_{6},v_{7}\\},\\{v_{7},v_{5}\\},\\{v_{4},v_{5}\\},\\{v_{2},v_{8}\\},\\{v_{8},v_{9}\\},\\{v_{6},v_{10}\\},\\{v_{11},v_{12}\\}\\}$。我们通过计算关联的边来计算初始度数：\n$$\n\\deg(v_{1})=0,\\quad \\deg(v_{2})=3,\\quad \\deg(v_{3})=2,\\quad \\deg(v_{4})=3,\\quad \\deg(v_{5})=3,\\quad \\deg(v_{6})=3,\n$$\n$$\n\\deg(v_{7})=2,\\quad \\deg(v_{8})=2,\\quad \\deg(v_{9})=1,\\quad \\deg(v_{10})=1,\\quad \\deg(v_{11})=1,\\quad \\deg(v_{12})=1.\n$$\n我们重复应用规则 A（移除孤立顶点）和规则 B（移除叶顶点）。\n\n1) 对 $v_{1}$ 应用规则 A，因为 $\\deg(v_{1})=0$。新的顶点集是 $V_{1}=V\\setminus\\{v_{1}\\}$。所有其他顶点的度数不变。\n\n2) 对 $v_{9}$ 应用规则 B，因为 $\\deg(v_{9})=1$，其邻居是 $v_{8}$。移除 $v_{9}$：$V_{2}=V_{1}\\setminus\\{v_{9}\\}$。更新其邻居的度数：\n$$\n\\deg_{2}(v_{8})=\\deg(v_{8})-1=1.\n$$\n\n3) 对 $v_{8}$ 应用规则 B，因为现在 $\\deg_{2}(v_{8})=1$，其邻居是 $v_{2}$。移除 $v_{8}$：$V_{3}=V_{2}\\setminus\\{v_{8}\\}$。更新其邻居的度数：\n$$\n\\deg_{3}(v_{2})=\\deg(v_{2})-1=2.\n$$\n\n4) 对 $v_{10}$ 应用规则 B，因为 $\\deg(v_{10})=1$，其邻居是 $v_{6}$。移除 $v_{10}$：$V_{4}=V_{3}\\setminus\\{v_{10}\\}$。更新其邻居的度数：\n$$\n\\deg_{4}(v_{6})=\\deg(v_{6})-1=2.\n$$\n\n5) 对 $v_{11}$ 应用规则 B，因为 $\\deg(v_{11})=1$，其邻居是 $v_{12}$。移除 $v_{11}$：$V_{5}=V_{4}\\setminus\\{v_{11}\\}$。更新其邻居的度数：\n$$\n\\deg_{5}(v_{12})=\\deg(v_{12})-1=0.\n$$\n\n6) 对 $v_{12}$ 应用规则 A，因为现在 $\\deg_{5}(v_{12})=0$。移除 $v_{12}$：$V_{6}=V_{5}\\setminus\\{v_{12}\\}$。\n\n剩余的顶点是 $V_{6}=\\{v_{2},v_{3},v_{4},v_{5},v_{6},v_{7}\\}$。剩余的边是那些不与被移除顶点相关联的边：\n$$\nE_{6}=\\{\\{v_{2},v_{3}\\},\\{v_{3},v_{4}\\},\\{v_{4},v_{2}\\},\\{v_{5},v_{6}\\},\\{v_{6},v_{7}\\},\\{v_{7},v_{5}\\},\\{v_{4},v_{5}\\}\\}.\n$$\n计算最终的度数：\n$$\n\\deg_{6}(v_{2})=2,\\quad \\deg_{6}(v_{3})=2,\\quad \\deg_{6}(v_{4})=3,\\quad \\deg_{6}(v_{5})=3,\\quad \\deg_{6}(v_{6})=2,\\quad \\deg_{6}(v_{7})=2.\n$$\n没有度为0或1的顶点，因此无法再应用规则 A 或规则 B。该实例是不可规约的。因此，最终的不可规约图中的顶点总数为 $|V_{6}|=6$。", "answer": "$$\\boxed{6}$$", "id": "1504250"}, {"introduction": "在应用规约规则时，我们必须确保规则是“安全”的，即它不会改变问题的最终答案。本练习将引导你从“如何应用”转向“为何有效”，通过分析支配集问题中的一个经典规约规则，你将学习如何通过严谨的逻辑（特别是替换论证法）来证明一条规则的安全性[@problem_id:1504226]。这是设计新算法时的一项核心技能。", "problem": "在图论中，图 $G=(V, E)$ 的一个 **支配集** (dominating set) 是一个顶点子集 $D \\subseteq V$，使得每个不在 $D$ 中的顶点都与 $D$ 中至少一个顶点相邻。**$k$-支配集** ($k$-Dominating Set) 问题询问给定的图 $G$ 是否有一个规模至多为 $k$ 的支配集。这个问题是一个经典的 NP难问题。\n\n解决此类问题的一种方法是 **固定参数可解性 (Fixed-Parameter Tractability, FPT)**。FPT 中的一个核心技术是 **核化 (kernelization)**，它涉及使用多项式时间的 **规约规则 (reduction rules)** 将一个问题实例 $(G, k)$ 简化为一个等价的、更小的实例 $(G', k')$。如果原始实例 $(G, k)$ 有解当且仅当规约后的实例 $(G', k')$ 有解，则称该规约规则是“安全的”(safe)。\n\n让我们考虑无向图 $G$ 中的一个特定场景。对于任何顶点 $x \\in V$，其 **闭邻域 (closed neighborhood)**（记作 $N[x]$）是包含 $x$ 及其所有相邻顶点的集合。假设我们有两个不同的顶点 $u$ 和 $v$，使得 $u$ 的闭邻域是 $v$ 的闭邻域的子集，即 $N[u] \\subseteq N[v]$。\n\n针对这种情况，一个常见的规约规则是移除顶点 $u$。这条规则的安全性的论证依赖于一个关于任何潜在的最小规模支配集结构的关键观察。具体来说，可以证明，如果图 $G$ 存在任何最小支配集，那么也 *必然* 存在一个不包含顶点 $u$ 的最小支配集。\n\n下列哪个陈述为这一特定论断（即，总能找到一个不包含 $u$ 的最小支配集）提供了最准确和完整的理由？\n\nA. 如果一个最小支配集 $D$ 包含 $u$，我们可以创建一个新集合 $D^* = D \\setminus \\{u\\}$。这个新集合比 $D$ 小，并且由于 $N[u] \\subseteq N[v]$，它仍然支配几乎所有相同的顶点。这意味着 $D$ 不是最小的，这是一个矛盾。\n\nB. 如果一个最小支配集 $D$ 包含 $u$，我们可以构造一个新集合 $D^* = (D \\setminus \\{u\\}) \\cup \\{v\\}$。任何最初由 $u$ 支配的顶点都属于 $N[u]$。由于 $N[u] \\subseteq N[v]$，该顶点也处于 $N[v]$ 中，因此在新集合 $D^*$ 中被 $v$ 支配。所有其他顶点仍然被 $D$ 的其他成员支配。$D^*$ 的规模至多与 $D$ 的规模相同，因此我们找到了一个规模不大于原集合且不包含 $u$ 的支配集。\n\nC. 因为 $N[u] \\subseteq N[v]$，顶点 $v$ 在图中更具中心性。中心顶点更有可能出现在最小支配集中。因此，任何搜索最小支配集的算法都应优先选择 $v$ 而非 $u$，这意味着我们可以安全地假设 $u$ 不被选中。\n\nD. 任何支配集都必须支配 $u$。能够支配 $u$ 的顶点在集合 $N[u]$ 中。由于 $N[u] \\subseteq N[v]$，使用 $v$ 来支配 $N[u]$ 中的顶点总是比使用 $u$ 本身更有效率。因此， $u$ 永远不应被选为最小支配集的一部分。\n\nE. 设 $D$ 是一个包含 $u$ 的最小支配集。为了支配 $u$，$D$ 必须包含一个来自 $N[u]$ 的顶点。由于 $u \\in D$，这个条件得到了满足。因为 $N[u] \\subseteq N[v]$，这意味着 $D$ 也必须包含一个来自 $N[v]$ 的顶点，这意味着可以在不影响支配属性的情况下移除 $u$。", "solution": "我们回顾一下定义。对于图 $G=(V,E)$ 和顶点 $x\\in V$，闭邻域是 $N[x]=\\{x\\}\\cup\\{y\\in V:\\{x,y\\}\\in E\\}$。如果对于每个 $w\\in V$，都存在一个 $d\\in D$ 使得 $w\\in N[d]$，则集合 $D\\subseteq V$ 是一个支配集。假设 $u,v\\in V$ 是不同的顶点且满足 $N[u]\\subseteq N[v]$。\n\n论断：如果 $D$ 是一个最小支配集且 $u\\in D$，则存在一个最小支配集 $D^{*}$ 使得 $u\\notin D^{*}$。\n\n证明。定义 $D^{\\prime}=(D\\setminus\\{u\\})\\cup\\{v\\}$。我们证明 $D^{\\prime}$ 是一个支配集并且 $|D^{\\prime}|\\leq |D|$。首先，根据构造，要么 $v$ 已经属于 $D$，此时 $D^{\\prime}=D\\setminus\\{u\\}$ 且 $|D^{\\prime}|=|D|-1$；要么 $v\\notin D$，此时 $|D^{\\prime}|=|D|$。因此，在所有情况下都有 $|D^{\\prime}|\\leq |D|$。\n\n接下来，我们验证其支配属性。设 $w\\in V$ 为任意顶点。由于 $D$ 是一个支配集，存在某个 $d\\in D$ 使得 $w\\in N[d]$。如果 $d\\neq u$，那么 $d\\in D\\setminus\\{u\\}\\subseteq D^{\\prime}$，因此在 $D^{\\prime}$ 中 $w$ 仍然被 $d$ 支配。如果 $d=u$，那么 $w\\in N[u]$。因为 $N[u]\\subseteq N[v]$，所以 $w\\in N[v]$。由于根据定义 $v\\in D^{\\prime}$，因此在 $D^{\\prime}$ 中 $w$ 被 $v$ 支配。所以，每个 $w\\in V$ 都被 $D^{\\prime}$ 中的某个顶点支配，故 $D^{\\prime}$ 是一个支配集。\n\n因为 $D$ 是最小的（即基数最小），不等式 $|D^{\\prime}|\\leq |D|$ 意味着 $|D^{\\prime}|=|D|$，所以 $D^{\\prime}$ 也是一个最小支配集。此外，如果 $v\\in D$，那么 $D^{\\prime}=D\\setminus\\{u\\}$ 已经排除了 $u$；如果 $v\\notin D$，那么根据构造 $D^{\\prime}$ 也排除了 $u$。因此，无论哪种情况，都存在一个不包含 $u$ 的最小支配集。\n\n这个论证与选项B完全相符。其他选项都有缺陷：A 移除了 $u$ 却没有保证对仅由 $u$ 支配的顶点的支配性；C 诉诸于启发式的“中心性”而非正确性证明；D 声称“更有效率”却没有给出正式的替换论证；E 错误地推断出 $D$ 中存在某个 $N[v]$ 中的顶点（可能仅是 $u$ 本身）就允许在没有替换的情况下移除 $u$，这是不合理的。因此，最准确和完整的理由由 B 给出。", "answer": "$$\\boxed{B}$$", "id": "1504226"}, {"introduction": "固定参数可解性 (FPT) 不仅仅局限于核化，有界搜索树是另一种强大的FPT技术。本练习将分析一个旨在寻找偶度子图的算法，让你学习如何利用参数 $k$ 来约束递归搜索树的规模[@problem_id:1504264]。这有助于你理解算法的复杂度如何被参数所控制，并展示了与核化不同的另一种解决NP难问题的思路。", "problem": "如果图中每个顶点的度数都为偶数，则称该图为“偶度图”。一位计算机科学家正在研究**通过删除顶点得到偶度子图 (Even-Degree Subgraph by Vertex Deletion)** 的问题：给定一个图 $G=(V, E)$ 和一个整数参数 $k$，我们能否通过删除至多 $k$ 个顶点来得到一个偶度子图？\n\n他们提出了以下名为 `Solve(G, k)` 的有界搜索树算法：\n1.  识别当前图 $G$ 中度数为奇数的顶点集合 $O$。\n2.  如果集合 $O$ 为空，则条件已满足。返回 `TRUE`。\n3.  如果 $k=0$ 且集合 $O$ 不为空，我们没有更多顶点可以删除。返回 `FALSE`。\n4.  选择一个奇度顶点 $v \\in O$。\n5.  对 $v$ 的闭邻域（记为 $N[v] = \\{v\\} \\cup N(v)$，其中 $N(v)$ 是 $v$ 的邻居集合）内的所有可能的单顶点删除进行分支。对于每个顶点 $u \\in N[v]$：\n    a. 递归调用算法 `Solve(G-u, k-1)`。\n    b. 如果该递归调用返回 `TRUE`，则找到了一个解。立即返回 `TRUE`。\n6.  如果所有分支都已探索完毕且没有一个返回 `TRUE`，则此路径下无解。返回 `FALSE`。\n\n在你的分析中，可以依赖一个图论中已确立（但在此未证明）的结论：在步骤 4 中，总是可以选择一个奇度顶点 $v$，其在当前图中的度数 $\\deg(v)$ 以 $2k'+1$ 为界，其中 $k'$ 是该递归调用中当前的删除预算。\n\n你的任务是确定该算法在初始预算为 $k$ 时生成的搜索树中叶子节点数量的一个紧上界。用一个关于 $k$ 的数学表达式来表示你的答案。", "solution": "设 $L(k)$ 表示以预算 $k$ 调用该算法时所产生的搜索树中叶子节点的最大数量。\n\n基本情况：\n- 如果 $k=0$，算法会在步骤 2 或步骤 3 中立即返回而不进行分支，因此 $L(0) \\leq 1$。\n\n归纳分支界：\n- 考虑一个当前预算为 $k' \\geq 1$ 的递归调用。根据给定的图论保证，存在一个奇度顶点 $v$，其度数满足 $\\deg(v) \\leq 2k' + 1$。\n- 算法对 $N[v]$ 中的所有顶点进行分支，因此该节点的分支数最多为\n$$\n|N[v]| \\leq \\deg(v) + 1 \\leq 2k' + 2.\n$$\n- 每个分支将预算减一，因此叶子节点的数量满足以下递推关系\n$$\nL(k') \\leq (2k' + 2)\\,L(k' - 1), \\quad \\text{for } k' \\geq 1,\n$$\n其中 $L(0) \\leq 1$。\n\n将递推关系从 $k$ 向下展开到 $0$ 可得\n$$\nL(k) \\leq \\prod_{i=1}^{k} (2i + 2)\\,L(0) \\leq \\prod_{i=1}^{k} (2i + 2).\n$$\n计算该乘积：\n$$\n\\prod_{i=1}^{k} (2i + 2) = 2^{k} \\prod_{i=1}^{k} (i + 1) = 2^{k} (k + 1)!.\n$$\n\n因此，叶子节点的数量上界为 $2^{k} (k+1)!$。对于此分支方案和度数界，该上界是紧的，因为存在最坏情况的实例，在这些实例中，每一层的所选奇度顶点都达到 $\\deg(v) = 2k' + 1$，并且在耗尽预算之前没有分支会提前终止，从而实现了分支因子的完全乘积。", "answer": "$$\\boxed{2^{k}(k+1)!}$$", "id": "1504264"}]}