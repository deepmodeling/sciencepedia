{"hands_on_practices": [{"introduction": "要真正掌握 Kruskal 算法，没有什么比一步步地实际操作更好的方法了。第一个练习模拟了一个真实世界的网络设计场景，你需要为多个数据中心规划成本最低的连接方案。通过遵循该算法的简单规则——按权重对边进行排序，并在不形成环路的情况下添加它们——你将亲手构建一个最小生成树，并巩固对该过程核心机制的理解。[@problem_id:1517280]", "problem": "一家科技公司正在设计一个私有加密广域网 (WAN)，以连接其八个主要数据中心，标记为 DC1 至 DC8。目标是建立一个网络拓扑，该拓扑能直接或间接地连接所有数据中心，并使光纤链路的年租赁成本最低。可用的点对点链路及其相关的年成本（单位：千美元）如下所列。该列表是根据另一项内部指标预先排序的，而不是按成本排序。\n\n*   (DC5, DC7) - 成本: 17\n*   (DC1, DC2) - 成本: 11\n*   (DC3, DC8) - 成本: 20\n*   (DC5, DC6) - 成本: 13\n*   (DC1, DC5) - 成本: 18\n*   (DC2, DC4) - 成本: 15\n*   (DC7, DC8) - 成本: 16\n*   (DC1, DC3) - 成本: 14\n*   (DC3, DC4) - 成本: 12\n*   (DC2, DC6) - 成本: 19\n\n网络工程团队决定应用 Kruskal 算法来确定要租赁的最优链路集合。根据该算法成功添加了前五条链路之后，构成网络的链路集合是什么？\n\nA. {(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3), (DC7, DC8)}\n\nB. {(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3), (DC2, DC4)}\n\nC. {(DC1, DC2), (DC3, DC4), (DC1, DC3), (DC5, DC7), (DC1, DC5)}\n\nD. {(DC3, DC8), (DC2, DC6), (DC1, DC5), (DC5, DC7), (DC7, DC8)}", "solution": "Kruskal 算法通过从所有可用边的列表中迭代地选择权重最低的边来构建一个最小生成树 (MST)，条件是添加该边不会与已选择的边形成环路。\n\n首先，我们必须将所有可用的链路（边）按其成本（权重）进行非递减排序。\n\n提供的列表是：\n*   (DC5, DC7), 成本: 17\n*   (DC1, DC2), 成本: 11\n*   (DC3, DC8), 成本: 20\n*   (DC5, DC6), 成本: 13\n*   (DC1, DC5), 成本: 18\n*   (DC2, DC4), 成本: 15\n*   (DC7, DC8), 成本: 16\n*   (DC1, DC3), 成本: 14\n*   (DC3, DC4), 成本: 12\n*   (DC2, DC6), 成本: 19\n\n按成本对这些链路进行排序，得到以下有序列表：\n1.  (DC1, DC2), 成本: 11\n2.  (DC3, DC4), 成本: 12\n3.  (DC5, DC6), 成本: 13\n4.  (DC1, DC3), 成本: 14\n5.  (DC2, DC4), 成本: 15\n6.  (DC7, DC8), 成本: 16\n7.  (DC5, DC7), 成本: 17\n8.  (DC1, DC5), 成本: 18\n9.  (DC2, DC6), 成本: 19\n10. (DC3, DC8), 成本: 20\n\n接下来，我们追踪算法的执行过程。最初，每个数据中心都位于其自身的不相交集合中，代表一个由八个连通分量组成的森林：`{DC1}, {DC2}, {DC3}, {DC4}, {DC5}, {DC6}, {DC7}, {DC8}`。已选择的边集合为空。\n\n**第 1 步 (第一次成功添加):**\n我们考虑成本最低的边：(DC1, DC2)，成本为 11。数据中心 DC1 和 DC2 位于不同的集合（`{DC1}` 和 `{DC2}`）中。添加这条边不会产生环路。因此，我们添加它。\n*   已选择的边: `{(DC1, DC2)}`\n*   当前集合为: `{{DC1, DC2}, {DC3}, {DC4}, {DC5}, {DC6}, {DC7}, {DC8}}`\n\n**第 2 步 (第二次成功添加):**\n下一条成本最低的边是 (DC3, DC4)，成本为 12。DC3 和 DC4 位于不同的集合（`{DC3}` 和 `{DC4}`）中。我们添加这条边。\n*   已选择的边: `{(DC1, DC2), (DC3, DC4)}`\n*   当前集合为: `{{DC1, DC2}, {DC3, DC4}, {DC5}, {DC6}, {DC7}, {DC8}}`\n\n**第 3 步 (第三次成功添加):**\n下一条边是 (DC5, DC6)，成本为 13。DC5 和 DC6 位于不同的集合（`{DC5}` 和 `{DC6}`）中。我们添加这条边。\n*   已选择的边: `{(DC1, DC2), (DC3, DC4), (DC5, DC6)}`\n*   当前集合为: `{{DC1, DC2}, {DC3, DC4}, {DC5, DC6}, {DC7}, {DC8}}`\n\n**第 4 步 (第四次成功添加):**\n下一条边是 (DC1, DC3)，成本为 14。DC1 位于集合 `{DC1, DC2}` 中，而 DC3 位于集合 `{DC3, DC4}` 中。由于它们属于不同的集合，添加该边不会形成环路。我们添加该边并将两个集合合并。\n*   已选择的边: `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3)}`\n*   当前集合为: `{{DC1, DC2, DC3, DC4}, {DC5, DC6}, {DC7}, {DC8}}`\n\n**第 5 步 (环路检测):**\n下一条边是 (DC2, DC4)，成本为 15。我们检查 DC2 和 DC4 属于哪个集合。DC2 位于 `{DC1, DC2, DC3, DC4}` 中，DC4 也位于 `{DC1, DC2, DC3, DC4}` 中。由于它们在同一个集合中，添加这条边会创建一个环路（具体来说是 DC1-DC2-DC4-DC3-DC1）。因此，我们**拒绝**这条边。\n\n**第 6 步 (第五次成功添加):**\n我们继续处理排序列表中的下一条边：(DC7, DC8)，成本为 16。DC7 位于 `{DC7}` 中，DC8 位于 `{DC8}` 中。它们属于不同的集合，所以我们添加这条边。这是我们成功添加的第五条边。\n*   已选择的边: `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3), (DC7, DC8)}`\n*   当前集合为: `{{DC1, DC2, DC3, DC4}, {DC5, DC6}, {DC7, DC8}}`\n\n过程到此结束，因为题目要求的是成功添加的前五条边的集合。得到的集合是 `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3), (DC7, DC8)}`。\n\n将此结果与给定选项进行比较，我们发现它与选项 A 匹配。", "answer": "$$\\boxed{A}$$", "id": "1517280"}, {"introduction": "在掌握了 Kruskal 算法的基本操作之后，让我们来深入探讨其背后的“为什么”。这个问题以一个猜想的形式，挑战你对算法贪心选择性质的理解。通过评估这个猜想，你将超越简单的算法执行，开始像算法理论家一样思考，理解为何每一步的局部最优选择最终能导向全局最优解。[@problem_id:1517301]", "problem": "在一门关于算法的计算机科学课程中，一名学生正在学习用于寻找最小生成树 (MST) 的 Kruskal 算法。最小生成树是一个连接所有顶点、无环且总边权尽可能小的子图。该学生提出了以下猜想：\n\n“在任何至少有3个顶点、所有边权都不同的连通简单无向图中，图中权重第二小的边必须总是包含在最小生成树中。”\n\n你的任务是评估这个猜想。以下哪个陈述是正确的，并提供了最准确的推理？\n\nA. 该猜想是错误的。考虑一个由三个顶点组成的环（三角形），其边是图中权重最轻的三条边。被考虑的第三条边，它可能是整张图中权重第二小的边，会因形成一个环而被舍弃，所以它不总是被包含在内。\n\nB. 该猜想是正确的。权重最小的边总是首先被包含。权重第二小的边紧接着被考虑。由于图是简单的且所有边权都不同，这两条边不可能连接同一对顶点。因此，第二条边不可能与第一条边形成一个环，所以它总是会被包含。\n\nC. 该猜想是错误的。如果一条边的两个端点已经连通，Kruskal 算法就会排除这条边。权重第二小的边的两个端点有可能通过一条由若干条都比它权重小的其他边组成的路径相连。\n\nD. 该猜想是正确的。Kruskal 算法是一种贪心算法。为确保最终的树权重最小化，它必须选择可用的两条权重最小的边来开始构建树，因为这提供了“最廉价”的连接。\n\nE. 该猜想的有效性无法保证，它取决于图的具体结构。在稀疏图中它可能是正确的，但在稠密图中则可能是错误的。", "solution": "设 $G=(V,E)$ 是一个连通的简单无向图，其中 $|V| \\geq 3$ 且所有边权都不同。设所有边按权重严格递增排序为 $e_{1}, e_{2}, \\dots, e_{m}$，其中 $w(e_{1})  w(e_{2})  \\dots  w(e_{m})$。Kruskal 算法按此顺序考虑各条边，当且仅当一条边不会与已选中的边形成环时，才将其加入；等价地说，如果一条边的两个端点位于当前森林的不同连通分量中，则算法会加入这条边。\n\n首先，当考虑 $e_{1}$ 时，还没有选择任何边，所以加入 $e_{1}$ 不可能形成环。因此 $e_{1}$ 总是被包含在内。\n\n接下来，考虑 $e_{2}$。在考虑 $e_{2}$ 的那一刻，唯一被先前考虑过并可能已包含的边是 $e_{1}$。当前的森林最多只有一条边，即 $e_{1}$，它将其两个端点连接成一个单独的连通分量，而所有其他顶点则各自处于独立的单点连通分量中。在这一点上，根据 Kruskal 的规则，$e_{2}$ 被排除的唯一可能是其两个端点已经通过一条仅由已包含边构成的路径相连。唯一可用的已包含边是 $e_{1}$。因此，要使 $e_{2}$ 的端点已经连通，$e_{2}$ 必须连接与 $e_{1}$ 相同的无序顶点对。然而，因为图是简单的，任意一对顶点之间最多只有一条边，所以 $e_{2}$ 不可能是 $e_{1}$ 的平行边。因此，在考虑 $e_{2}$ 时，其两个端点位于不同的连通分量中，加入 $e_{2}$ 不会形成环。因此 Kruskal 算法必须包含 $e_{2}$。\n\n因为所有边权都不同，所以最小生成树是唯一的，而 Kruskal 算法能够生成这个唯一的 MST。因此，$e_{2}$ 包含在 MST 中。这直接验证了该猜想。\n\n评估各个选项：\n- A 是不正确的，因为它错误地将算法考虑的第三条边识别为可能是权重第二小的边；权重第二小的边是第二条被考虑的边，并且如前所示，它会被包含。\n- B 是正确的：它精确地阐明了，对于简单图和不同边权的情况，在考虑 $e_{2}$ 时它不可能形成环，所以它总是被包含在内。\n- C 对于权重第二小的边是不正确的：不可能存在一条由多条都比 $e_{2}$ 权重小的边组成的路径，因为只有 $e_{1}$ 的权重比它小。\n- D 得出了正确的结论，但给出的理由不精确；Kruskal 算法选择边，不仅仅是因为它们是抽象意义上权重最小的两条，而是因为权重第二小的边在轮到它时不会形成环。\n- E 是不正确的；在给定的假设下，这个属性不依赖于图的稀疏性或稠密性。\n\n因此，具有准确推理的正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1517301"}, {"introduction": "现实世界的网络很少是静态的，链路成本会随着技术升级而改变。最后一个练习将你置于网络工程师的角色，面对一个动态更新的挑战。你将学习如何利用最小生成树的环路性质，在不从头重新计算的情况下，高效地更新网络，这展示了深刻的理论知识如何转化为强大的实际解决方案。[@problem_id:1517296]", "problem": "一家航空公司管理着一个由 $n$ 颗通信卫星组成的大型在轨卫星星座。这些卫星之间可能的通信链路网络被建模为一个带权无向图 $G=(V, E)$，其中 $V$ 是 $n$ 颗卫星的集合，$E$ 是所有可能的直接通信链路的集合。$E$ 中一条边 $(u, v)$ 的权重表示卫星 $u$ 和卫星 $v$ 之间的信号延迟。为了确保通信高效、可靠且总延迟最小，活动链路被配置成图 $G$ 的一个最小生成树 (MST)，记为 $T$。\n\n假设一项新的激光通信技术被部署在一对卫星 $(u, v)$ 上。这条特定的链路 $(u, v)$ *不*是原始最小生成树 $T$ 的一部分。这次升级将其通信延迟从原始值 $w(u,v)$ 降低到了一个新的、更低的值 $w'(u,v)$。网络管理员必须确定是否应将这条新的、更快的链路并入通信骨干网，如果需要，如何形成新的最小生成树 $T'$。\n\n一个提议的更新过程如下：\n1. 临时将新升级的链路 $(u, v)$ 添加到现有的最小生成树 $T$ 中。此操作会创建一个新图 $T \\cup \\{(u,v)\\}$，其中恰好包含一个环。\n2. 为了形成新的最小生成树 $T'$ 并保持总延迟最小的特性，必须从此新形成的环中移除恰好一条链路。\n\n下列哪个陈述正确地指出了从环中选择要移除的链路的规则，以及识别这条特定链路的最坏情况时间复杂度？给定现有的最小生成树 $T$（其表示方式便于高效遍历，例如邻接表），以及两颗卫星 $u$ 和 $v$。卫星总数为 $n$。\n\nA. 移除环中延迟最小的链路。复杂度为 $O(n \\log n)$。\n\nB. 移除环中延迟最大的链路。复杂度为 $O(n)$。\n\nC. 如果 $w'(u, v)$ 小于环中其他所有链路的延迟，则移除环中延迟最大的链路；否则，最小生成树保持不变。做出此判断的复杂度为 $O(n^2)$。\n\nD. 移除环中延迟最大的链路。复杂度为 $O(\\log n)$。\n\nE. 总是移除链路 $(u, v)$ 本身，因为它是最新添加的。复杂度为 $O(1)$。\n\nF. 移除环中延迟最大的链路。复杂度为 $O(n^2)$。", "solution": "我们将卫星星座建模为一个带权无向图 $G=(V,E)$，其权重代表延迟。设 $T$ 是 $G$ 的一个最小生成树。一条非树边 $(u,v)$ 的权重从 $w(u,v)$ 减小到 $w'(u,v)$，我们考虑更新 $T$。\n\n将 $(u,v)$ 添加到 $T$ 中会产生恰好一个环，因为 $T$ 是一棵树，所以在 $T$ 中 $u$ 和 $v$ 之间存在一条唯一的简单路径 $P_{T}(u,v)$；因此该环为\n$$\nC \\;=\\; P_{T}(u,v) \\cup \\{(u,v)\\}.\n$$\n设 $e^{\\ast}$ 是环 $C$ 中延迟最大的一条边：\n$$\ne^{\\ast} \\;\\in\\; \\arg\\max_{e \\in C} w(e),\n$$\n其中对于 $(u,v)$，我们使用更新后的权重 $w'(u,v)$。根据最小生成树的环性质：在任何环中，如果一条边的权重严格大于环中其他任何边的权重，那么这条边不属于任何最小生成树。因此，为了在添加 $(u,v)$ 后保持总延迟最小，正确的操作是从环 $C$ 中移除一条具有最大延迟的边。存在两种情况：\n- 如果 $w'(u,v)  \\max_{e \\in P_{T}(u,v)} w(e)$，那么 $e^{\\ast} \\neq (u,v)$ 并且\n$$\nw(T \\cup \\{(u,v)\\} \\setminus \\{e^{\\ast}\\}) \\;=\\; w(T) + w'(u,v) - w(e^{\\ast})  w(T),\n$$\n所以更新后的最小生成树是 $T' = T \\cup \\{(u,v)\\} \\setminus \\{e^{\\ast}\\}$。\n- 如果 $w'(u,v) \\ge \\max_{e \\in P_{T}(u,v)} w(e)$，那么 $e^{\\ast} = (u,v)$（或出现权重相同的情况），移除 $(u,v)$ 会得到原始的树 $T$，它仍然是最小生成树。\n\n因此，选择规则是“移除环中延迟最大的链路”。\n\n为了确定要移除的具体链路，我们需要找到唯一路径 $P_{T}(u,v)$ 上权重最大的边。给定以邻接表表示的 $T$ 以及顶点 $u$ 和 $v$，我们可以：\n1. 从 $u$ 开始执行深度优先搜索（DFS）或广度优先搜索（BFS）来找到 $v$ 并记录父指针；因为 $T$ 是一棵树，此过程最多遍历 $n-1$ 条边，因此需要 $O(n)$ 时间。\n2. 从父指针重构路径 $P_{T}(u,v)$，并扫描其边以找到最大延迟；在最坏情况下，这也需要 $O(n)$ 时间。\n\n因此，总的最坏情况时间是 $O(n)$。在这些选项中，这对应于移除最大延迟边，时间复杂度为 $O(n)$。\n\n因此，正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1517296"}]}