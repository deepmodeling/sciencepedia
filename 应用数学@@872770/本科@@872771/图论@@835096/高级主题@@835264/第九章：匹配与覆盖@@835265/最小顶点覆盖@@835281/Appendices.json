{"hands_on_practices": [{"introduction": "为了掌握最小顶点覆盖的概念，我们从最基本的图结构——完全图开始。这个练习将帮助你运用顶点覆盖的定义来推导一个密集网络所需的最小监控节点数。通过这个直观的例子，你可以建立对顶点覆盖问题核心约束的深刻理解 [@problem_id:1357691]。", "problem": "在一个新的数据中心设计中，8台服务器必须完全互连，这意味着每台服务器都有一条专用的直接通信链路连接到其他每一台服务器。在图论中，这种网络拓扑被称为完全图，对于一个包含$n$台服务器的网络，记为$K_n$。\n\n为确保网络安全并监控所有流量，必须在这些服务器的一个子集上安装监控软件。安装在特定服务器上的软件可以监控所有直接连接到该服务器的通信链路。如果网络中的每一条通信链路都至少被集合中的一台服务器监控，那么被选中安装软件的服务器集合就被认为是一个有效的监控集合。\n\n确定要为这个包含8台服务器的网络形成一个有效的监控集合，最少需要安装监控软件的服务器数量。", "solution": "将网络模型化为完全图$K_{n}$，其中$n=8$，其顶点集$V$代表服务器，边集$E$代表通信链路。在服务器上安装监控软件对应于选择一个顶点，该顶点监控所有与其关联的边。因此，一个有效的监控集合就是一个顶点覆盖：一个子集$S \\subseteq V$，使得$E$中的每一条边至少有一个端点在$S$中。\n\n我们来确定$K_{n}$中顶点覆盖的最小规模。设$S$为任意一个顶点覆盖，并设$T = V \\setminus S$为未被选择的顶点集合。如果$|T| \\geq 2$，那么存在两个不同的顶点$a, b \\in T$。因为该图是完全图，所以边$(a,b)$存在。由于$a$和$b$都不在$S$中，边$(a,b)$不与$S$中的任何顶点关联，这与$S$是顶点覆盖的定义相矛盾。因此，我们必须有\n$$\n|T| \\leq 1 \\quad \\Longrightarrow \\quad |S| \\geq n - 1.\n$$\n这个下界是可以通过选择任意$n-1$个顶点组成的集合$S$来达到的；因为最多只有一个未被选择的顶点，所以两个未被选择的顶点之间不存在边，每条边都至少有一个端点在$S$中。因此，$K_{n}$中最小顶点覆盖的大小恰好是$n-1$。\n\n对于$n=8$，所需的最少服务器数量是\n$$\n8 - 1 = 7.\n$$", "answer": "$$\\boxed{7}$$", "id": "1357691"}, {"introduction": "虽然在一般图上寻找最小顶点覆盖是计算上的难题，但在某些特殊类型的图上，我们可以找到高效的解决方法。本练习将引导你为树形结构设计一种递归算法，这是一种在计算机科学和网络设计中常见的重要结构。掌握这种方法不仅能解决特定问题，还能让你领略算法设计中动态规划的魅力 [@problem_id:1522363]。", "problem": "在图论中，一个图的**顶点覆盖**是其顶点的一个子集，使得图中的每条边都与该子集中的至少一个顶点相关联。**最小顶点覆盖**是包含顶点数量最少的顶点覆盖。\n\n**树**是一种不包含环的连通图。\n\n考虑一个特定的树 $T$，它由顶点集 $V = \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13\\}$ 和由以下顶点对组成的边集 $E$ 定义：\n(1, 2), (1, 3), (1, 4), (2, 5), (2, 6), (3, 7), (4, 8), (4, 9), (7, 10), (7, 11), (8, 12), (8, 13)。\n\n确定这棵树 $T$ 的最小顶点覆盖的大小。", "solution": "树上的最小顶点覆盖可以通过在有根树上进行动态规划来计算。将树 $T$ 以顶点 $1$ 为根，并对每个顶点 $v$ 定义：\n- $\\text{in}(v)$: 在顶点 $v$ 被包含在覆盖中的条件下，以 $v$ 为根的子树的最小顶点覆盖的大小。\n- $\\text{out}(v)$: 在顶点 $v$ 不被包含在覆盖中的条件下，以 $v$ 为根的子树的最小顶点覆盖的大小。\n\n对于任何拥有子节点 $\\text{ch}(v)$ 的顶点 $v$，标准的递推关系是：\n$$\n\\text{in}(v)=1+\\sum_{u\\in \\text{ch}(v)}\\min\\big(\\text{in}(u),\\text{out}(u)\\big),\\qquad\n\\text{out}(v)=\\sum_{u\\in \\text{ch}(v)}\\text{in}(u).\n$$\n对于一个叶节点 $v$ (即 $\\text{ch}(v)=\\varnothing$)，基础值为\n$$\n\\text{in}(v)=1,\\qquad \\text{out}(v)=0.\n$$\n\n根据给定的边，选择与以 $1$ 为根相一致的子节点集：\n$$\n\\text{ch}(1)=\\{2,3,4\\},\\quad \\text{ch}(2)=\\{5,6\\},\\quad \\text{ch}(3)=\\{7\\},\\quad \\text{ch}(4)=\\{8,9\\},\n$$\n$$\n\\text{ch}(7)=\\{10,11\\},\\quad \\text{ch}(8)=\\{12,13\\},\\quad \\text{并且}\\quad 5,6,9,10,11,12,13\\ \\text{是叶节点}。\n$$\n\n自底向上计算。\n\n对于每个叶节点 $v\\in\\{5,6,9,10,11,12,13\\}$：\n$$\n\\text{in}(v)=1,\\quad \\text{out}(v)=0.\n$$\n\n对于子节点为 $5,6$ 的顶点 $v=2$：\n$$\n\\text{in}(2)=1+\\min(1,0)+\\min(1,0)=1,\\qquad \\text{out}(2)=1+1=2.\n$$\n\n对于子节点为 $10,11$ 的顶点 $v=7$：\n$$\n\\text{in}(7)=1+\\min(1,0)+\\min(1,0)=1,\\qquad \\text{out}(7)=1+1=2.\n$$\n\n对于子节点为 $12,13$ 的顶点 $v=8$：\n$$\n\\text{in}(8)=1+\\min(1,0)+\\min(1,0)=1,\\qquad \\text{out}(8)=1+1=2.\n$$\n\n对于子节点为 $7$ 的顶点 $v=3$：\n$$\n\\text{in}(3)=1+\\min\\big(\\text{in}(7),\\text{out}(7)\\big)=1+\\min(1,2)=2,\\qquad \\text{out}(3)=\\text{in}(7)=1.\n$$\n\n对于子节点为 $8,9$ 的顶点 $v=4$：\n$$\n\\text{in}(4)=1+\\min\\big(\\text{in}(8),\\text{out}(8)\\big)+\\min\\big(\\text{in}(9),\\text{out}(9)\\big)=1+\\min(1,2)+\\min(1,0)=2,\n$$\n$$\n\\text{out}(4)=\\text{in}(8)+\\text{in}(9)=1+1=2.\n$$\n\n最后，对于根节点 $v=1$，其子节点为 $2,3,4$：\n$$\n\\text{in}(1)=1+\\min\\big(\\text{in}(2),\\text{out}(2)\\big)+\\min\\big(\\text{in}(3),\\text{out}(3)\\big)+\\min\\big(\\text{in}(4),\\text{out}(4)\\big)\n=1+\\min(1,2)+\\min(2,1)+\\min(2,2)=5,\n$$\n$$\n\\text{out}(1)=\\text{in}(2)+\\text{in}(3)+\\text{in}(4)=1+2+2=5.\n$$\n\n树 $T$ 的最小顶点覆盖的大小是 $\\min\\big(\\text{in}(1),\\text{out}(1)\\big)=5$。", "answer": "$$\\boxed{5}$$", "id": "1522363"}, {"introduction": "在处理NP-困难问题时，我们常常会尝试使用简单直观的“贪心”策略来寻找近似解。然而，这些启发式方法并非总是最优的。这个练习通过一个精心构造的例子，揭示了为何一种常见的贪心算法（选择度最高的顶点）无法保证找到最小顶点覆盖，并量化了其表现有多差 [@problem_id:1522337]。这对于理解近似算法的局限性和评估其性能至关重要。", "problem": "在图论中，一个图的顶点覆盖是其顶点的一个子集，使得图中的每条边都至少与该子集中的一个顶点相关联。最小顶点覆盖是包含顶点数量最少的顶点覆盖。\n\n寻找一个小的顶点覆盖的一种常用启发式算法是“最大度贪心算法”。该算法的工作方式如下：\n1. 初始化一个空的顶点覆盖 $\\mathcal{C}$。\n2. 当图中仍有边时：\n   a. 选择图中当前度数最高的顶点 `v`。\n   b. 将 `v` 添加到覆盖 $\\mathcal{C}$ 中。\n   c. 从图中移除 `v` 及其所有关联的边。\n3. 返回 $\\mathcal{C}$ 作为顶点覆盖。\n\n如果最高度数出现平局，可以选择任何一个度数相同的顶点。虽然这个算法很简单，但它并不总能产生最小顶点覆盖。\n\n考虑一个为整数 $k \\ge 3$ 构建的特定图 $G_k$。该图有三个不相交的顶点集：$V_A = \\{a\\}$，$V_B = \\{b_1, b_2, \\dots, b_k\\}$ 和 $V_C = \\{c_1, c_2, \\dots, c_k\\}$。\n图的边定义如下：\n- 对于从 $1$ 到 $k$ 的每个 $i$，有一条连接顶点 $a$ 和顶点 $b_i$ 的边。\n- 对于从 $1$ 到 $k$ 的每个 $i$，有一条连接顶点 $b_i$ 和顶点 $c_i$ 的边。\n没有其他边。\n\n设 $\\mathcal{C}_G$ 是由最大度贪心算法为 $G_k$ 生成的顶点覆盖，设 $\\mathcal{C}^*$ 是 $G_k$ 的一个真正的最小顶点覆盖。确定它们大小的比率 $|\\mathcal{C}_G| / |\\mathcal{C}^*|$。将你的答案表示为 $k$ 的函数。", "solution": "我们分析图 $G_{k}$，其顶点集为 $V_{A}=\\{a\\}$、$V_{B}=\\{b_{1},\\dots,b_{k}\\}$ 和 $V_{C}=\\{c_{1},\\dots,c_{k}\\}$，边集为 $\\{(a,b_{i}) : i=1,\\dots,k\\}$ 和 $\\{(b_{i},c_{i}) : i=1,\\dots,k\\}$。各顶点的度数为 $\\deg(a)=k$，$\\deg(b_{i})=2$ 和 $\\deg(c_{i})=1$。\n\n贪心覆盖的大小 $|\\mathcal{C}_{G}|$：\n- 根据最大度贪心算法，在第一次迭代中，唯一度数最大的顶点是 $a$（因为 $k \\ge 3$），所以选择 $a$。这使得覆盖的大小增加 $1$。\n- 移除 $a$ 及其关联的边后，剩下 $k$ 条不相交的边 $\\{(b_{i},c_{i}) : i=1,\\dots,k\\}$，这是一个匹配。在这个残余图中，每个剩余顶点的度数都为 $1$，因此接下来的每一次贪心选择都会选择一条剩余边的一个端点，并恰好移除那一条边。\n- 因为有 $k$ 条这样的边，所以需要额外进行 $k$ 次选择才能将它们全部移除。因此，\n$$\n|\\mathcal{C}_{G}| = 1 + k.\n$$\n\n最小覆盖的大小 $|\\mathcal{C}^{*}|$：\n- $k$ 条边 $\\{(b_{i},c_{i})\\}$ 构成一个匹配。任何顶点覆盖都必须包含这 $k$ 条两两不相交的边中每一条的至少一个端点，因此\n$$\n|\\mathcal{C}^{*}| \\ge k.\n$$\n- 这个下界可以通过选择所有顶点 $\\{b_{1},\\dots,b_{k}\\}$ 来达到，这个集合覆盖了所有的边 $(a,b_{i})$ 和 $(b_{i},c_{i})$。因此，\n$$\n|\\mathcal{C}^{*}| = k.\n$$\n\n比率：\n$$\n\\frac{|\\mathcal{C}_{G}|}{|\\mathcal{C}^{*}|} = \\frac{k+1}{k}.\n$$", "answer": "$$\\boxed{\\frac{k+1}{k}}$$", "id": "1522337"}]}