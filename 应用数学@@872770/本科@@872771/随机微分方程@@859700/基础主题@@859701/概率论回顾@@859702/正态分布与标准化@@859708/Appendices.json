{"hands_on_practices": [{"introduction": "理解正态分布的关键在于掌握标准化。这个练习将通过第一性原理，引导你从标准正态变量 $Z \\sim \\mathcal{N}(0,1)$ 出发，推导出一般正态变量 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$ 的前四阶矩。通过这个过程，你将亲手揭示一个分布的均值、方差、偏度和峰度等核心特征是如何通过简单的线性变换（即标准化）建立起来的 [@problem_id:3068835]。", "problem": "考虑随机微分方程 (SDE) $dX_{t} = a\\,dt + b\\,dW_{t}$，其中 $W_{t}$ 是一个标准维纳过程，$a$ 和 $b$ 是常数。在一个固定的时间步长 $\\Delta t$ 上，欧拉-丸山 (Euler–Maruyama) 增量 $\\Delta X := X_{t+\\Delta t} - X_{t}$ 服从正态分布，其均值为 $\\mu := a\\,\\Delta t$，方差为 $\\sigma^{2} := b^{2}\\,\\Delta t$。因此，我们可以写作 $\\Delta X \\sim \\mathcal{N}(\\mu,\\sigma^{2})$。令 $X$ 表示一个一般的正态随机变量，其分布为 $X \\sim \\mathcal{N}(\\mu,\\sigma^{2})$。使用标准化方法，从矩的定义和关于标准正态分布的公认事实出发，计算前四个原始矩 $\\mathbb{E}[X^{k}]$（$k \\in \\{1,2,3,4\\}$）。然后，使用标准化偏度和峰度的定义，\n- 偏度 $\\gamma_{1} := \\mathbb{E}\\!\\left[\\left(\\frac{X-\\mu}{\\sigma}\\right)^{3}\\right]$，\n- 峰度 $\\kappa := \\mathbb{E}\\!\\left[\\left(\\frac{X-\\mu}{\\sigma}\\right)^{4}\\right]$,\n利用你计算出的矩来说明正态分布的零偏度和特定峰度值。\n\n请将你的最终结果按 $(\\mathbb{E}[X],\\ \\mathbb{E}[X^{2}],\\ \\mathbb{E}[X^{3}],\\ \\mathbb{E}[X^{4}],\\ \\gamma_{1},\\ \\kappa)$ 的顺序列为一个单行矩阵。无需进行数值四舍五入，且不涉及物理单位。", "solution": "该问题具有科学依据，提法明确，客观，并包含了获得唯一解所需的所有信息。因此，我们可以开始推导。\n\n该问题要求计算一个服从正态分布 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$ 的随机变量 $X$ 的前四个原始矩、偏度和峰度。核心技术是标准化，它将 $X$ 与一个标准正态随机变量 $Z \\sim \\mathcal{N}(0, 1)$ 联系起来。\n\n该关系由以下变换给出：\n$$Z = \\frac{X - \\mu}{\\sigma}$$\n由此，我们可以用 $Z$ 来表示 $X$：\n$$X = \\mu + \\sigma Z$$\n为了计算 $X$ 的原始矩 $\\mathbb{E}[X^k]$，我们将使用上述 $X$ 的表达式以及期望算子的线性性。这需要用到标准正态变量 $Z$ 的矩。根据问题允许使用“关于标准正态分布的公认事实”，我们将使用以下已知的 $Z$ 的矩：\n由于分布关于 $0$ 点对称，$Z$ 的所有奇数阶矩均为零。\n$$\\mathbb{E}[Z^n] = 0 \\quad \\text{for odd } n$$\n具体来说，$\\mathbb{E}[Z^1] = \\mathbb{E}[Z] = 0$ 且 $\\mathbb{E}[Z^3] = 0$。\n\n偶数阶矩由双阶乘 $(n-1)!! = (n-1)(n-3)\\cdots1$ 给出。\n$$\\mathbb{E}[Z^2] = (2-1)!! = 1$$\n这与 $Z$ 的方差为 $1$ 的事实相符，因为 $\\text{Var}(Z) = \\mathbb{E}[Z^2] - (\\mathbb{E}[Z])^2 = 1 - 0^2 = 1$。\n$$\\mathbb{E}[Z^4] = (4-1)!! = 3 \\cdot 1 = 3$$\n\n现在，我们计算 $X$ 的前四个原始矩。\n\n一阶原始矩 ($k=1$):\n$$\\mathbb{E}[X] = \\mathbb{E}[\\mu + \\sigma Z] = \\mathbb{E}[\\mu] + \\sigma\\mathbb{E}[Z] = \\mu + \\sigma(0) = \\mu$$\n\n二阶原始矩 ($k=2$):\n我们使用 $(\\mu + \\sigma Z)^2$ 的二项式展开。\n$$\\mathbb{E}[X^2] = \\mathbb{E}[(\\mu + \\sigma Z)^2] = \\mathbb{E}[\\mu^2 + 2\\mu\\sigma Z + \\sigma^2 Z^2]$$\n根据期望的线性性：\n$$\\mathbb{E}[X^2] = \\mathbb{E}[\\mu^2] + 2\\mu\\sigma\\mathbb{E}[Z] + \\sigma^2\\mathbb{E}[Z^2] = \\mu^2 + 2\\mu\\sigma(0) + \\sigma^2(1) = \\mu^2 + \\sigma^2$$\n\n三阶原始矩 ($k=3$):\n我们使用 $(\\mu + \\sigma Z)^3$ 的二项式展开。\n$$\\mathbb{E}[X^3] = \\mathbb{E}[(\\mu + \\sigma Z)^3] = \\mathbb{E}[\\mu^3 + 3\\mu^2\\sigma Z + 3\\mu\\sigma^2 Z^2 + \\sigma^3 Z^3]$$\n根据期望的线性性：\n$$\\mathbb{E}[X^3] = \\mathbb{E}[\\mu^3] + 3\\mu^2\\sigma\\mathbb{E}[Z] + 3\\mu\\sigma^2\\mathbb{E}[Z^2] + \\sigma^3\\mathbb{E}[Z^3]$$\n$$\\mathbb{E}[X^3] = \\mu^3 + 3\\mu^2\\sigma(0) + 3\\mu\\sigma^2(1) + \\sigma^3(0) = \\mu^3 + 3\\mu\\sigma^2$$\n\n四阶原始矩 ($k=4$):\n我们使用 $(\\mu + \\sigma Z)^4$ 的二项式展开。\n$$\\mathbb{E}[X^4] = \\mathbb{E}[(\\mu + \\sigma Z)^4] = \\mathbb{E}[\\mu^4 + 4\\mu^3\\sigma Z + 6\\mu^2\\sigma^2 Z^2 + 4\\mu\\sigma^3 Z^3 + \\sigma^4 Z^4]$$\n根据期望的线性性：\n$$\\mathbb{E}[X^4] = \\mathbb{E}[\\mu^4] + 4\\mu^3\\sigma\\mathbb{E}[Z] + 6\\mu^2\\sigma^2\\mathbb{E}[Z^2] + 4\\mu\\sigma^3\\mathbb{E}[Z^3] + \\sigma^4\\mathbb{E}[Z^4]$$\n$$\\mathbb{E}[X^4] = \\mu^4 + 4\\mu^3\\sigma(0) + 6\\mu^2\\sigma^2(1) + 4\\mu\\sigma^3(0) + \\sigma^4(3) = \\mu^4 + 6\\mu^2\\sigma^2 + 3\\sigma^4$$\n\n接下来，我们根据问题中的定义计算偏度和峰度。\n\n偏度 ($\\gamma_1$):\n偏度被定义为三阶标准化矩。\n$$\\gamma_1 := \\mathbb{E}\\left[\\left(\\frac{X-\\mu}{\\sigma}\\right)^3\\right]$$\n认识到 $\\frac{X-\\mu}{\\sigma} = Z$，这其实就是标准正态分布的三阶矩。\n$$\\gamma_1 = \\mathbb{E}[Z^3] = 0$$\n零偏度反映了正态分布关于其均值的对称性。\n\n峰度 ($\\kappa$):\n峰度被定义为四阶标准化矩。\n$$\\kappa := \\mathbb{E}\\left[\\left(\\frac{X-\\mu}{\\sigma}\\right)^4\\right]$$\n同样地，这是标准正态分布的四阶矩。\n$$\\kappa = \\mathbb{E}[Z^4] = 3$$\n这个值是正态分布常态峰（mesokurtic）特性的一个决定性特征。\n\n问题要求使用计算出的矩来说明零偏度和特定峰度。所提供的 $\\gamma_1$ 和 $\\kappa$ 的定义是直接用标准化变量 $Z$ 来表示的，我们在整个过程中都使用了 $Z$ 的矩。从 $Z$ 的矩计算出这些值，即可作为所要求的说明。\n\n最后，我们将结果组合成指定的单行矩阵 $(\\mathbb{E}[X], \\mathbb{E}[X^2], \\mathbb{E}[X^3], \\mathbb{E}[X^4], \\gamma_1, \\kappa)$。\n矩阵的元素为：\n$\\mathbb{E}[X] = \\mu$\n$\\mathbb{E}[X^2] = \\mu^2 + \\sigma^2$\n$\\mathbb{E}[X^3] = \\mu^3 + 3\\mu\\sigma^2$\n$\\mathbb{E}[X^4] = \\mu^4 + 6\\mu^2\\sigma^2 + 3\\sigma^4$\n$\\gamma_1 = 0$\n$\\kappa = 3$", "answer": "$$ \\boxed{ \\begin{pmatrix} \\mu & \\mu^2 + \\sigma^2 & \\mu^3 + 3\\mu\\sigma^2 & \\mu^4 + 6\\mu^2\\sigma^2 + 3\\sigma^4 & 0 & 3 \\end{pmatrix} } $$", "id": "3068835"}, {"introduction": "理论必须通过实践来检验，尤其是在随机模拟领域。本练习将理论付诸实践，要求你利用标准化原理——即通过缩放一个标准正态变量来生成一个具有特定方差的正态变量——来模拟布朗运动的基本增量 $\\Delta B$。你不仅要实现这个模拟，还需要计算样本均值和方差，并依据统计原理来验证你的模拟结果是否与理论预测相符 [@problem_id:3068854]。", "problem": "考虑一个维纳过程（也称为布朗运动）$\\{B_t\\}_{t \\geq 0}$，根据定义，它具有独立增量，并且满足对于任何固定的时间步长 $\\Delta t > 0$，增量 $\\Delta B := B_{t+\\Delta t} - B_t$ 服从均值为 $0$、方差为 $\\Delta t$ 的正态分布。在随机微分方程 (SDE) 的数值模拟中，例如 $dX_t = \\mu(X_t,t)\\,dt + \\sigma(X_t,t)\\,dB_t$，需要对小时间步长 $\\Delta t$ 上的增量 $\\Delta B$ 进行近似。一种标准方法是利用正态分布的尺度变换性质：如果 $Z \\sim \\mathcal{N}(0,1)$ 是一个标准正态随机变量，那么对于任何 $\\sigma > 0$，经过尺度变换的变量 $\\sigma Z$ 满足 $\\sigma Z \\sim \\mathcal{N}(0,\\sigma^2)$。因此，该增量可以通过变换 $\\Delta B = \\sqrt{\\Delta t}\\,Z$ 来模拟。\n\n任务：从这些基本定义和事实出发，您必须完成两件事：\n- 从正态分布的基本原理和布朗运动增量的定义出发，推导出当 $Z \\sim \\mathcal{N}(0,1)$ 时，为什么 $\\Delta B = \\sqrt{\\Delta t}\\,Z$ 的分布是 $\\mathcal{N}(0,\\Delta t)$。\n- 通过使用 $\\Delta B_i = \\sqrt{\\Delta t}\\,Z_i$（其中 $Z_i \\sim \\mathcal{N}(0,1)$）模拟独立样本 $\\{\\Delta B_i\\}_{i=1}^N$，并计算样本均值 $\\hat{m} = \\frac{1}{N}\\sum_{i=1}^N \\Delta B_i$ 和无偏样本方差 $\\hat{s}^2 = \\frac{1}{N-1}\\sum_{i=1}^N (\\Delta B_i - \\hat{m})^2$，来经验性地验证矩估计的收敛性。运用概率论推理来确定这些估计量的预期精度，然后实现一个测试，以量化的水平判断经验估计值是否与均值的理论目标值 $0$ 和方差的理论目标值 $\\Delta t$ 一致。\n\n每个测试用例的接受标准：设 $\\hat{m}$ 和 $\\hat{s}^2$ 为经验估计量。对于方差为 $\\Delta t$ 的独立抽样，样本均值的理论方差为 $\\mathrm{Var}(\\hat{m}) = \\Delta t / N$，因此 $\\hat{m}$ 波动的自然尺度是 $\\sqrt{\\Delta t / N}$。此外，对于正态数据，无偏样本方差满足 $(N-1)\\hat{s}^2 / \\Delta t \\sim \\chi^2_{N-1}$，这意味着 $\\mathbb{E}[\\hat{s}^2] = \\Delta t$ 和 $\\mathrm{Var}(\\hat{s}^2) = \\frac{2\\,\\Delta t^2}{N-1}$，因此 $\\hat{s}^2 - \\Delta t$ 波动的自然尺度是 $\\sqrt{\\frac{2\\,\\Delta t^2}{N-1}}$。对于每个测试用例，如果以下两个不等式都成立，则声明其通过：\n$$|\\hat{m} - 0| \\leq c \\sqrt{\\frac{\\Delta t}{N}}, \\quad |\\hat{s}^2 - \\Delta t| \\leq c \\sqrt{\\frac{2\\,\\Delta t^2}{N-1}},$$\n其中 $c$ 是一个固定的常数乘子（使用 $c = 3$）。这量化了经验估计值位于其目标值的几个标准误差范围内的概念。\n\n您的程序必须：\n- 使用可复现的随机数生成器模拟指定的测试用例。\n- 对于每个用例，计算 $\\hat{m}$ 和 $\\hat{s}^2$，并使用 $c=3$ 检查上述接受标准。\n- 生成单行输出，其中包含一个布尔值列表，指示每个测试用例的通过或失败，格式为用方括号括起来的逗号分隔列表。\n\n测试套件：\n- 用例 1：$(\\Delta t, N) = (0, 1000)$，用于探测增量方差为零且确定性地为 $0$ 的边界情况。\n- 用例 2：$(\\Delta t, N) = (0.1, 5000)$，小时间步长与中等样本量。\n- 用例 3：$(\\Delta t, N) = (1.0, 100000)$，单位时间步长与大样本量。\n- 用例 4：$(\\Delta t, N) = (10^{-4}, 200000)$，测试数值精度的极小时间步长。\n- 用例 5：$(\\Delta t, N) = (2.5, 50000)$，较大时间步长与中等样本量。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$，其中每个 $\\text{result}_i$ 是对应于第 $i$ 个测试用例通过/失败结果的 $\\text{True}$ 或 $\\text{False}$。", "solution": "该问题是有效的，因为它科学地基于随机微积分和统计学原理，问题设定良好，目标明确，并为获得唯一解提供了所有必要信息。它不包含任何矛盾、歧义或事实错误。\n\n根据要求，解决方案包括两部分：理论推导和经验验证。\n\n### 第 1 部分：理论推导\n\n推导从随机变量线性变换的期望和方差的基本性质开始。设 $Z$ 是一个均值为 $\\mathbb{E}[Z]$、方差为 $\\mathrm{Var}(Z)$ 的随机变量。对于常数 $a$ 和 $b$，变换后的变量 $Y = aZ + b$ 的均值为 $\\mathbb{E}[Y] = a\\mathbb{E}[Z] + b$，方差为 $\\mathrm{Var}(Y) = a^2\\mathrm{Var}(Z)$。正态分布的一个关键性质是其在仿射变换下的封闭性：如果 $Z$ 是正态分布的，那么 $Y$ 也是。\n\n给定一个标准正态随机变量 $Z \\sim \\mathcal{N}(0, 1)$，其期望为 $\\mathbb{E}[Z] = 0$，方差为 $\\mathrm{Var}(Z) = 1$。布朗增量 $\\Delta B$ 被构造为随机变量 $\\Delta B = \\sqrt{\\Delta t}\\,Z$。这是一个线性变换，其缩放因子为 $a = \\sqrt{\\Delta t}$，平移量为 $b = 0$。\n\n首先，我们计算 $\\Delta B$ 的期望：\n$$\n\\mathbb{E}[\\Delta B] = \\mathbb{E}[\\sqrt{\\Delta t}\\,Z] = \\sqrt{\\Delta t}\\,\\mathbb{E}[Z]\n$$\n代入已知值 $\\mathbb{E}[Z] = 0$：\n$$\n\\mathbb{E}[\\Delta B] = \\sqrt{\\Delta t} \\cdot 0 = 0\n$$\n这证明了增量的均值为 $0$。\n\n其次，我们计算 $\\Delta B$ 的方差：\n$$\n\\mathrm{Var}(\\Delta B) = \\mathrm{Var}(\\sqrt{\\Delta t}\\,Z) = (\\sqrt{\\Delta t})^2\\,\\mathrm{Var}(Z)\n$$\n代入已知值 $\\mathrm{Var}(Z) = 1$：\n$$\n\\mathrm{Var}(\\Delta B) = \\Delta t \\cdot 1 = \\Delta t\n$$\n这证明了增量的方差为 $\\Delta t$。\n\n鉴于 $Z$ 是一个正态分布的随机变量，线性变换后的变量 $\\Delta B$ 也必须是正态分布的。结合这些发现——一个均值为 $0$、方差为 $\\Delta t$ 的正态分布——我们得出结论，$\\Delta B$ 服从分布 $\\mathcal{N}(0, \\Delta t)$。这完成了从第一性原理出发的推导，证实了用于模拟维纳过程增量的尺度变换性质。\n\n### 第 2 部分：经验验证\n\n对于经验验证，根据问题规范实现了一个数值模拟。该实现的核心是处理一套测试用例，每个用例由一对参数 $(\\Delta t, N)$ 定义，分别代表时间步长和样本数量。\n\n每个测试用例的流程如下：\n$1$. 使用一个可复现的随机数生成器从标准正态分布 $\\mathcal{N}(0, 1)$ 中生成 $N$ 个独立样本 $\\{Z_i\\}_{i=1}^N$。\n$2$. 使用理论推导出的关系 $\\Delta B_i = \\sqrt{\\Delta t}\\,Z_i$，对这些标准样本进行尺度变换，以生成维纳过程的增量 $\\{\\Delta B_i\\}_{i=1}^N$。\n$3$. 使用标准估计量计算生成增量的样本均值 $\\hat{m}$ 和无偏样本方差 $\\hat{s}^2$：\n$$ \\hat{m} = \\frac{1}{N}\\sum_{i=1}^N \\Delta B_i $$\n$$ \\hat{s}^2 = \\frac{1}{N-1}\\sum_{i=1}^N (\\Delta B_i - \\hat{m})^2 $$\n$4$. 然后将这些经验统计量与其理论期望值进行比较，均值的理论期望值为 $\\mathbb{E}[\\hat{m}] = 0$，方差的理论期望值为 $\\mathbb{E}[\\hat{s}^2] = \\Delta t$。\n$5$. 接受标准量化了经验估计值是否在统计上与理论目标一致。如果估计值位于其期望值的指定标准误差倍数范围内，则认为该测试用例通过。问题指定乘数为 $c=3$。\n$6$. 第一个条件检查样本均值。样本均值的理论方差为 $\\mathrm{Var}(\\hat{m}) = \\frac{\\Delta t}{N}$。条件是：\n$$ |\\hat{m} - 0| \\leq c \\sqrt{\\frac{\\Delta t}{N}} $$\n$7$. 第二个条件检查样本方差。对于来自正态分布的样本，无偏样本方差估计量的方差为 $\\mathrm{Var}(\\hat{s}^2) = \\frac{2\\Delta t^2}{N-1}$。条件是：\n$$ |\\hat{s}^2 - \\Delta t| \\leq c \\sqrt{\\frac{2\\Delta t^2}{N-1}} $$\n$8$. 如果两个条件都满足，则测试用例标记为 `True`，否则标记为 `False`。对于 $\\Delta t = 0$ 的边界情况，增量 $\\Delta B_i$ 全部恒等于 $0$，导致 $\\hat{m}=0$ 和 $\\hat{s}^2=0$。接受阈值也计算为 $0$，因此两个条件 $|0| \\leq 0$ 都满足，该用例通过。该实现无需特殊条件逻辑即可正确处理此极限情况，因为数值计算在整个过程中正确地产生零值。\n\n最终输出是一个布尔值列表，每个值对应一个测试用例，指示验证的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates Brownian motion increments and verifies their statistical properties.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (delta_t, N_samples)\n        (0.0, 1000),\n        (0.1, 5000),\n        (1.0, 100000),\n        (1e-4, 200000),\n        (2.5, 50000),\n    ]\n\n    # Acceptance criterion multiplier\n    c = 3.0\n\n    # Initialize a reproducible random number generator for consistent results.\n    # The seed value is arbitrary but fixed.\n    rng = np.random.default_rng(42)\n\n    results = []\n    for dt, N in test_cases:\n        # The case N = 1 is not in the test suite. If it were, the denominator\n        # N-1 in the variance of the sample variance would be problematic.\n        # We assume N > 1 as per the test suite.\n        \n        # 1. Generate N standard normal random variables Z ~ N(0,1).\n        Z = rng.standard_normal(size=N)\n        \n        # 2. Scale Z to obtain Brownian increments dB ~ N(0, dt).\n        dB = np.sqrt(dt) * Z\n        \n        # 3. Compute the sample mean and unbiased sample variance.\n        m_hat = np.mean(dB)\n        # Using ddof=1 ensures the denominator is N-1 for an unbiased estimate.\n        s2_hat = np.var(dB, ddof=1)\n        \n        # 4. Calculate the acceptance thresholds.\n        # The formulas are robust and handle the dt=0 case correctly, where\n        # thresholds become 0.\n        mean_threshold = c * np.sqrt(dt / N)\n        var_threshold = c * np.sqrt(2 * (dt**2) / (N - 1))\n        \n        # 5. Check if the empirical estimates are within the thresholds.\n        mean_check = np.abs(m_hat - 0) = mean_threshold\n        var_check = np.abs(s2_hat - dt) = var_threshold\n        \n        # A test case passes if and only if both conditions are met.\n        results.append(mean_check and var_check)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3068854"}, {"introduction": "一个高质量的模拟器不仅要“看起来”正确，更要经得起严格的统计检验。这个进阶练习将引导你设计一个完整的验证流程，以检验布朗运动模拟器是否真正符合其理论定义。你将使用柯尔莫哥洛夫-斯米尔诺夫检验（Kolmogorov-Smirnov test）来验证正态性，并使用自相关函数来检验增量之间的独立性，这是评估任何随机模拟器可靠性的专业方法 [@problem_id:3068822]。", "problem": "您需要实现并应用一种统计验证方法，通过使用标准化增量来验证一个一维布朗运动模拟器。令 $\\{W_t\\}_{t \\ge 0}$ 表示一个布朗运动，由随机微分方程的核心性质定义：对于任意划分 $0 = t_0  t_1  \\dots  t_n$，增量 $\\Delta W_k := W_{t_k} - W_{t_{k-1}}$ 是独立的，且服从均值为 $0$、方差为 $t_k - t_{k-1}$ 的正态分布。特别地，对于步长为 $\\Delta t  0$ 的等距网格，每个增量满足 $\\Delta W_k \\sim \\mathcal{N}(0,\\Delta t)$，而标准化增量 $Z_k := \\Delta W_k / \\sqrt{\\Delta t}$ 满足 $Z_k \\sim \\mathcal{N}(0,1)$ 且对于 $j \\ne k$ 与 $Z_j$ 独立。\n\n您的任务是设计一个程序化测试，该测试在给定一个时间离散化过程的模拟增量后，使用标准化增量来验证布朗运动所需的两个基本属性：\n- 标准化增量的正态性，通过与标准正态分布进行柯尔莫哥洛夫–斯米尔诺夫检验来评估。\n- 标准化增量的独立性，通过在多个滞后上对样本自相关进行近似显著性检验来评估。\n\n从以下基本原理开始：\n- 布朗运动的增量属性：对于等距时间 $t_k = k \\Delta t$，增量满足 $\\Delta W_k \\sim \\mathcal{N}(0,\\Delta t)$ 且相互独立。\n- 标准化原理：如果 $X \\sim \\mathcal{N}(0,\\sigma^2)$，则 $X/\\sigma \\sim \\mathcal{N}(0,1)$。\n- 对于一个样本 $z_1,\\dots,z_n$，与标准正态分布进行比较的柯尔莫哥洛夫–斯米尔诺夫检验统计量，在原假设为 $\\mathcal{N}(0,1)$ 的情况下，会产生一个 $p$ 值。\n- 对于大样本量 $n$，如果 $\\{z_k\\}$ 是一个均值为零且方差有限的独立序列，则在独立性原假设下，滞后 $\\ell$ 的样本自相关（记为 $r_\\ell$）近似服从 $\\mathcal{N}(0,1/n)$ 分布。等价地，$\\sqrt{n}\\, r_\\ell$ 近似服从 $\\mathcal{N}(0,1)$ 分布，从而可以计算双边 $p$ 值。\n\n您必须实现以下验证流程：\n- 给定在步长为 $\\Delta t$ 的等距网格上的模拟增量 $\\Delta W_k$，计算标准化增量 $Z_k := \\Delta W_k/\\sqrt{\\Delta t}$。\n- 对 $\\{Z_k\\}$ 与 $\\mathcal{N}(0,1)$ 进行柯尔莫哥洛夫–斯米尔诺夫检验，显著性水平为 $\\alpha_{\\text{norm}}$。如果柯尔莫哥洛夫–斯米尔诺夫检验的 $p$ 值满足 $p_{\\text{KS}} \\ge \\alpha_{\\text{norm}}$，则声明正态性检验通过。\n- 对于给定的有限滞后集合 $\\mathcal{L} = \\{\\ell_1,\\dots,\\ell_m\\}$，使用标准的中心化估计量为每个 $\\ell \\in \\mathcal{L}$ 计算样本自相关 $r_{\\ell}$：\n$$\nr_{\\ell} = \\frac{\\sum_{k=1}^{n-\\ell} \\left(Z_k - \\bar{Z}\\right)\\left(Z_{k+\\ell} - \\bar{Z}\\right)}{\\sum_{k=1}^{n} \\left(Z_k - \\bar{Z}\\right)^2},\n$$\n其中 $\\bar{Z}$ 是 $\\{Z_k\\}_{k=1}^n$ 的样本均值。在独立性原假设下，将 $\\sqrt{n}\\, r_{\\ell}$ 视为标准正态分布来近似计算双边 $p$ 值。在各个滞后上使用Bonferroni校正，将族群错误率控制在 $\\alpha_{\\text{indep}}$，也就是说，要求所有 $\\ell \\in \\mathcal{L}$ 都满足 $p_{\\ell} \\ge \\alpha_{\\text{indep}}/m$ 才声明独立性检验通过。这里 $m = |\\mathcal{L}|$。\n- 当且仅当正态性检验和独立性检验都通过时，声明总体通过。\n\n实现上述流程，并将其应用于以下测试套件，其中每个案例都指定了增量的生成方式。在所有案例中，使用提供的伪随机种子以确保确定性行为。角度单位不适用，也不涉及物理单位。所有显著性水平必须视为十进制小数，而非百分比。\n\n全局测试参数：\n- 使用 $\\mathcal{L} = \\{1,2,5\\}$，因此 $m = 3$ 个滞后。\n- 使用 $\\alpha_{\\text{norm}} = 0.01$ 和 $\\alpha_{\\text{indep}} = 0.01$。\n\n四个案例的测试套件：\n- 案例 1（理想布朗模拟器，“理想路径”）：模拟 $n = 10000$ 个增量，$\\Delta t = 0.001$，种子为 $123456$。生成 $\\Delta W_k = \\sqrt{\\Delta t}\\, \\xi_k$，其中 $\\xi_k \\sim \\mathcal{N}(0,1)$ 是独立同分布的。\n- 案例 2（非正态但独立的增量）：模拟 $n = 10000$ 个增量，$\\Delta t = 0.001$，种子为 $24681012$。从自由度为 $\\nu = 3$ 的学生t分布中生成独立的标准化增量 $T_k$，并将其缩放至单位方差，然后设置 $\\Delta W_k = \\sqrt{\\Delta t}\\, T_k$。这保留了独立性但违反正态性。具体来说，如果 $U_k \\sim \\chi^2_{\\nu}$ 和 $G_k \\sim \\mathcal{N}(0,1)$ 独立，则定义 $S_k = G_k/\\sqrt{U_k/\\nu}$ 和 $T_k = S_k/\\sqrt{\\nu/(\\nu-2)}$（对于 $\\nu  2$）以实现单位方差。\n- 案例 3（正态但相关的增量）：模拟 $n = 10000$ 个增量，$\\Delta t = 0.001$，种子为 $314159$，自回归相关系数为 $\\rho = 0.3$。通过 $Y_1 \\sim \\mathcal{N}(0,1)$ 和 $Y_k = \\rho Y_{k-1} + \\sqrt{1-\\rho^2}\\, \\xi_k$ 生成一个一阶平稳自回归过程（AR($1$))，其中 $\\xi_k \\sim \\mathcal{N}(0,1)$ 是独立同分布的。设置 $\\Delta W_k = \\sqrt{\\Delta t}\\, Y_k$。这会产生标准正态的边际分布，但存在时间上的相关性。\n- 案例 4（边界样本量）：使用案例 1 中的理想布朗模拟器，模拟 $n = 400$ 个增量，$\\Delta t = 0.01$，种子为 $271828$。\n\n程序要求：\n- 精确按照定义实现每个案例的模拟器逻辑，由带种子的伪随机数生成器驱动。\n- 按照规定实现标准化、柯尔莫哥洛夫–斯米尔诺夫检验和带Bonferroni校正的自相关独立性检验。\n- 对于每个案例，输出一个布尔值，指示该过程是否同时通过了正态性检验和独立性检验。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3,result4]\"），其中每个条目是按顺序 1 到 4 的相应案例的布尔结果。\n\n您的最终输出必须是所描述格式的单行文本，不得包含任何多余的文本或换行。答案不涉及任何物理单位，角度也不适用。所有数值都应视为纯数字。", "solution": "该问题要求实现一个统计验证流程，用于验证一维布朗运动的模拟增量。该验证基于标准化增量的两个基本性质：正态性和独立性。解决方案涉及开发一个程序化测试，并将其应用于四个旨在探测验证器有效性的不同测试案例。\n\n对于给定的对应于时间步长 $\\Delta t$ 的增量序列 $\\{\\Delta W_k\\}_{k=1}^n$，验证流程按以下步骤进行。\n\n**步骤 1：增量的标准化**\n\n布朗运动的理论基础表明，对于步长为 $\\Delta t  0$ 的等距时间网格，增量 $\\Delta W_k$ 是独立同分布（i.i.d.）的，服从均值为 $0$、方差为 $\\Delta t$ 的正态分布，记为 $\\Delta W_k \\sim \\mathcal{N}(0, \\Delta t)$。\n\n为了便于进行标准的统计检验，我们首先将增量转换为标准正态尺度。标准化增量 $Z_k$ 定义为：\n$$\nZ_k = \\frac{\\Delta W_k}{\\sqrt{\\Delta t}}\n$$\n在原假设（即原始增量来自真实的布朗运动）下，标准化增量 $\\{Z_k\\}$ 必须是从标准正态分布 $Z_k \\sim \\mathcal{N}(0,1)$ 中抽取的独立同分布样本。这个标准化序列 $\\{Z_k\\}_{k=1}^n$ 是后续统计检验的对象。\n\n**步骤 2：正态性检验**\n\n第一个要验证的属性是标准化增量服从标准正态分布。为此，我们采用柯尔莫哥洛夫–斯米尔诺夫（KS）检验。KS检验将样本数据 $\\{Z_k\\}$ 的经验累积分布函数（ECDF）与假设分布（在此情况下为 $\\mathcal{N}(0,1)$）的累积分布函数（CDF）进行比较。\n\n原假设 ($H_0$) 是数据来自标准正态分布。该检验产生一个 $p$ 值，$p_{\\text{KS}}$。一个小的 $p$ 值表明样本分布与理论分布有显著差异。我们将此 $p$ 值与预定义的显著性水平 $\\alpha_{\\text{norm}}$ 进行比较。如果反对原假设的证据不具有统计显著性，即满足以下条件，则检验被宣告“通过”：\n$$\np_{\\text{KS}} \\ge \\alpha_{\\text{norm}}\n$$\n对于本问题，$\\alpha_{\\text{norm}} = 0.01$。\n\n**步骤 3：独立性检验**\n\n第二个要验证的属性是标准化增量的独立性。这通过检查不同时间滞后下的样本自相关函数（ACF）来评估。如果序列 $\\{Z_k\\}$ 是真正独立的，其对于所有非零滞后的自相关应在统计上与零无法区分。\n\n对于给定的滞后 $\\ell  0$，样本自相关 $r_{\\ell}$ 的计算公式为：\n$$\nr_{\\ell} = \\frac{\\sum_{k=1}^{n-\\ell} (Z_k - \\bar{Z})(Z_{k+\\ell} - \\bar{Z})}{\\sum_{k=1}^{n} (Z_k - \\bar{Z})^2}\n$$\n其中 $n$ 是样本大小，$\\bar{Z}$ 是 $\\{Z_k\\}$ 的样本均值。\n\n在独立性原假设下，对于大样本量 $n$，样本自相关 $r_{\\ell}$ 近似服从均值为 $0$、方差为 $1/n$ 的正态分布。因此，检验统计量 $\\sqrt{n}\\, r_{\\ell}$ 近似服从标准正态分布：\n$$\n\\sqrt{n}\\, r_{\\ell} \\sim \\mathcal{N}(0,1)\n$$\n据此，我们可以计算出一个双边 $p$ 值 $p_{\\ell}$，它表示如果序列是真正独立的，观测到与 $r_{\\ell}$ 一样极端的自相关的概率。$p_{\\ell} = 2 \\cdot (1 - \\Phi(|\\sqrt{n}\\, r_{\\ell}|))$，其中 $\\Phi$ 是标准正态CDF。\n\n由于我们是在多个滞后（具体为 $\\mathcal{L} = \\{1, 2, 5\\}$）上检验独立性，我们执行了三个独立的假设检验。为了将族群错误率（犯至少一个I类错误的概率）控制在水平 $\\alpha_{\\text{indep}}$ 以下，我们使用Bonferroni校正。每个独立检验的显著性水平被调整为 $\\alpha_{\\text{indep}}/m$，其中 $m = |\\mathcal{L}| = 3$。只有当条件 $p_{\\ell} \\ge \\alpha_{\\text{indep}}/m$ 对所有滞后 $\\ell \\in \\mathcal{L}$ 都成立时，独立性检验才被宣告“通过”。对于本问题，$\\alpha_{\\text{indep}} = 0.01$，因此校正后的阈值为 $0.01/3$。\n\n**步骤 4：总体验证和测试案例实现**\n\n对于给定的增量序列，总体验证通过当且仅当正态性检验和独立性检验均通过。\n\n实现将根据问题规范生成四组增量，使用带种子的伪随机数生成器以保证可复现性。\n\n- **案例 1（理想情况）：** 增量生成方式为 $\\Delta W_k = \\sqrt{\\Delta t}\\, \\xi_k$，其中 $\\xi_k \\sim \\mathcal{N}(0,1)$ i.i.d。这里，$Z_k = \\xi_k$，因此正态性和独立性在构造上都得到满足。此案例预期会通过检验。\n\n- **案例 2（非正态）：** 增量使用缩放后的学生t分布变量生成。一个自由度为 $\\nu=3$ 的标准学生t变量 $S_k$ 被缩放以获得单位方差，$T_k = S_k / \\sqrt{\\nu/(\\nu-2)}$，然后用于定义 $\\Delta W_k = \\sqrt{\\Delta t}\\, T_k$。得到的 $Z_k = T_k$ 是独立的但非正态分布。此案例预期会无法通过正态性检验。\n\n- **案例 3（相关）：** 增量从一个标准正态的一阶自回归过程（AR($1$)）$Y_k = \\rho Y_{k-1} + \\sqrt{1-\\rho^2}\\, \\xi_k$ 生成，其中 $\\rho=0.3$。每个 $Y_k$ 的边际分布是 $\\mathcal{N}(0,1)$，但各项之间存在序列相关。通过设置 $\\Delta W_k = \\sqrt{\\Delta t}\\, Y_k$，我们得到 $Z_k = Y_k$。这个序列应该能通过正态性检验，但无法通过独立性检验，尤其是在滞后 $\\ell=1$ 时。\n\n- **案例 4（边界样本量）：** 此案例使用理想生成器，但样本量较小（$n=400$）。统计检验的功效较低，但考虑到给定的参数，它仍预期会通过，用以测试该程序在较小数据集上的稳健性。\n\n最终输出是一个包含四个布尔值的列表，每个布尔值表示相应测试案例的总体通过/失败状态。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Implements a statistical validation pipeline for Brownian motion simulators\n    and applies it to four test cases.\n    \"\"\"\n\n    # Global test parameters\n    LAGS = [1, 2, 5]\n    ALPHA_NORM = 0.01\n    ALPHA_INDEP = 0.01\n\n    def calculate_autocorrelation(z_series, lag):\n        \"\"\"\n        Calculates the sample autocorrelation for a given lag.\n        \"\"\"\n        n = len(z_series)\n        z_demeaned = z_series - np.mean(z_series)\n        \n        # Numerator: sum_{k=1}^{n-l} (Z_k - Z_bar)(Z_{k+l} - Z_bar)\n        # Python indices: z_demeaned[:n-lag] and z_demeaned[lag:]\n        numerator = np.sum(z_demeaned[:n-lag] * z_demeaned[lag:])\n        \n        # Denominator: sum_{k=1}^{n} (Z_k - Z_bar)^2\n        denominator = np.sum(z_demeaned**2)\n        \n        if denominator == 0:\n            return 0.0\n            \n        return numerator / denominator\n\n    def validate_increments(delta_W, delta_t):\n        \"\"\"\n        Runs the full validation pipeline for a given set of increments.\n        \n        Args:\n            delta_W (np.ndarray): The simulated increments.\n            delta_t (float): The time step.\n\n        Returns:\n            bool: True if both normality and independence tests pass, False otherwise.\n        \"\"\"\n        n = len(delta_W)\n        \n        # Step 1: Standardization\n        # Avoid division by zero if delta_t is 0\n        if delta_t == 0:\n            Z = delta_W\n        else:\n            Z = delta_W / np.sqrt(delta_t)\n        \n        # Step 2: Normality Test (Kolmogorov-Smirnov)\n        _ks_stat, ks_p_value = stats.kstest(Z, 'norm')\n        normality_pass = (ks_p_value >= ALPHA_NORM)\n        \n        # Step 3: Independence Test (Autocorrelation)\n        independence_pass = True\n        m = len(LAGS)\n        alpha_bonferroni = ALPHA_INDEP / m\n        \n        for lag in LAGS:\n            if lag >= n:\n                continue  # Lag is too large for the series\n            \n            r_lag = calculate_autocorrelation(Z, lag)\n            \n            # Test statistic: sqrt(n) * r_lag ~ N(0,1) under H0\n            test_stat = np.sqrt(n) * r_lag\n            \n            # Two-sided p-value from standard normal distribution\n            p_value_lag = 2 * (1 - stats.norm.cdf(np.abs(test_stat)))\n            \n            if p_value_lag  alpha_bonferroni:\n                independence_pass = False\n                break  # Fail fast\n                \n        # Step 4: Overall Result\n        return normality_pass and independence_pass\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'n': 10000, 'dt': 0.001, 'seed': 123456, 'type': 'ideal', 'params': {}},\n        {'n': 10000, 'dt': 0.001, 'seed': 24681012, 'type': 'student_t', 'params': {'nu': 3}},\n        {'n': 10000, 'dt': 0.001, 'seed': 314159, 'type': 'ar1', 'params': {'rho': 0.3}},\n        {'n': 400, 'dt': 0.01, 'seed': 271828, 'type': 'ideal', 'params': {}},\n    ]\n\n    results = []\n    for case in test_cases:\n        n, dt, seed = case['n'], case['dt'], case['seed']\n        gen_type, params = case['type'], case['params']\n        \n        rng = np.random.default_rng(seed)\n        delta_W = np.array([])\n\n        if gen_type == 'ideal':\n            # Case 1  4: Ideal Brownian motion increments\n            xi = rng.normal(loc=0.0, scale=1.0, size=n)\n            delta_W = np.sqrt(dt) * xi\n        elif gen_type == 'student_t':\n            # Case 2: Non-normal (Student's t) but independent increments\n            nu = params['nu']\n            # Generate standard t-distributed variates\n            s_k = rng.standard_t(df=nu, size=n)\n            # Scale to have unit variance. Var(t_nu) = nu / (nu - 2) for nu > 2.\n            scale_factor = np.sqrt(nu / (nu - 2))\n            t_k = s_k / scale_factor\n            delta_W = np.sqrt(dt) * t_k\n        elif gen_type == 'ar1':\n            # Case 3: Normal but dependent (AR(1)) increments\n            rho = params['rho']\n            Y = np.zeros(n)\n            # Generate N(0,1) innovations\n            innovations = rng.normal(loc=0.0, scale=1.0, size=n)\n            # Initialize with stationary distribution\n            Y[0] = innovations[0]\n            # Generate the AR(1) series\n            for k in range(1, n):\n                Y[k] = rho * Y[k-1] + np.sqrt(1 - rho**2) * innovations[k]\n            delta_W = np.sqrt(dt) * Y\n\n        # Run the validation pipeline for the generated increments\n        pass_status = validate_increments(delta_W, dt)\n        results.append(pass_status)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3068822"}]}