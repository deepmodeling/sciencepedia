{"hands_on_practices": [{"introduction": "理论是一回事，亲眼所见又是另一回事。我们的第一个动手实践旨在通过数值方法来验证布朗运动路径的一些最令人惊讶的特性。我们将从第一性原理（即独立的、服从高斯分布的增量）出发模拟路径，并利用这些模拟来探索二次变分的概念。这个特性从根本上将布朗运动路径与经典微积分中研究的光滑曲线区分开来，是随机分析的基石。本练习将引导你观察二次变分在尺度变换下的行为，以及它如何不受漂移项的影响，从而为这些理论结果提供一种可触摸的直观感受。[@problem_id:3074685]", "problem": "编写一个完整、可运行的程序，该程序使用独立高斯增量模拟布朗运动的样本路径，并使用这些模拟来数值研究路径连续性和二次变差。你的推理必须仅基于以下基本定义和事实，不得调用任何未经证明的简化公式：(i) 一个标准布朗运动 $\\{W_t\\}_{t \\ge 0}$ 是一个随机过程，满足 $W_0 = 0$，具有独立平稳增量，并且对于所有 $0 \\le s  t$，$W_t - W_s$ 是均值为 $0$、方差为 $t-s$ 的高斯分布；(ii) 对于一个网格尺寸为 $\\Delta t = T/N$ 的均匀划分 $\\Pi = \\{0 = t_0  t_1  \\dots  t_N = T\\}$，一个欧拉型离散近似将增量 $\\Delta W_i = W_{t_i} - W_{t_{i-1}}$ 模拟为来自均值为 $0$、方差为 $\\Delta t$ 的正态分布的独立样本，并通过部分和 $W_{t_i} = \\sum_{j=1}^i \\Delta W_j$ 构建路径；(iii) 一个过程 $\\{X_t\\}$ 沿划分 $\\Pi$ 的二次变差是平方增量之和 $\\sum_{i=1}^N (X_{t_i} - X_{t_{i-1}})^2$，对于缩放布朗运动 $X_t = \\sigma W_t$ 和带漂移的布朗运动 $X_t = \\mu t + \\sigma W_t$，这些定义适用于它们各自的增量。你的程序必须从这些基础出发，通过第一性原理实现增量的模拟并计算指定的统计量。\n\n对于给定的测试套件，你的程序必须执行以下操作。在所有情况下，为伪随机数生成器使用固定的种子以确保确定性输出。对于给定的时间范围 $T$ 和步数 $N$，定义均匀步长 $\\Delta t = T/N$。对于给定的波动率 $\\sigma$，将增量独立地模拟为 $\\Delta W_i \\sim \\mathcal{N}(0, \\sigma^2 \\Delta t)$。对于给定的漂移 $\\mu$，使用相同的底层 $\\Delta W_i$ 定义带漂移的增量 $\\Delta X_i = \\mu \\Delta t + \\sigma \\Delta W_i$。\n\n测试套件和要求的输出：\n- 案例 $1$ (基准二次变差近似)：模拟一个标准布朗运动，参数为 $T = 1$, $N = 100000$, $\\sigma = 1$。使用 $314159$ 作为生成器种子。计算经验二次变差 $Q_1 = \\sum_{i=1}^N (\\Delta W_i)^2$ 并以浮点数形式输出 $Q_1$。\n- 案例 $2$ (缩放方差)：使用 $T = 2$, $N = 200000$, $\\sigma = 0.8$ 进行模拟。使用 $314160$ 作为生成器种子。计算经验二次变差 $Q_2 = \\sum_{i=1}^N (\\Delta W_i)^2$ 并以浮点数形式输出 $Q_2$。\n- 案例 $3$ (网格趋于零时的漂移不变性)：对两个过程使用相同的底层高斯增量，模拟一个带漂移的过程，参数为 $T = 1$, $N = 400000$, $\\sigma = 1$, $\\mu = 0.5$，以及其不带漂移的对应过程，参数为 $T = 1$, $N = 400000$, $\\sigma = 1$, $\\mu = 0$。使用 $314161$ 作为生成器种子。使用相同的 $\\Delta W_i$ 计算 $Q^{\\text{drift}} = \\sum_{i=1}^N (\\Delta X_i)^2$ 和 $Q^{\\text{nodrift}} = \\sum_{i=1}^N (\\sigma \\Delta W_i)^2$，并以浮点数形式输出绝对差 $D_3 = \\lvert Q^{\\text{drift}} - Q^{\\text{nodrift}} \\rvert$。\n- 案例 $4$ (在划分尺度上连续性的经验模态统计量)：对于一个标准布朗运动，计算最大绝对增量 $M = \\max_{1 \\le i \\le N} \\lvert \\Delta W_i \\rvert$，参数为 $T = 1$, $N = 131072$, $\\sigma = 1$。使用 $314162$ 作为生成器种子。构建尺度 $S = \\sqrt{2 \\Delta t \\log(1/\\Delta t)}$，并以浮点数形式输出比率 $R_4 = M / S$。\n\n最终输出格式：\n- 你的程序必须生成单行输出，其中包含按 $[Q_1, Q_2, D_3, R_4]$ 顺序排列、用逗号分隔并用方括号括起来的结果列表。\n- 每个条目必须打印为小数点后恰好保留 $6$ 位的小数。\n\n本问题不涉及物理单位。所有角度（如果有）都将以弧度为单位，但未使用任何角度。你的程序必须完全自包含，不得接受任何输入，也不得读取或写入任何文件或访问任何网络资源。", "solution": "问题陈述已经过验证，被认为是有效的，尽管存在显著的符号模糊性。一种与所提供的布朗运动基本定义和随机微积分标准实践相符的一致性解释是可能的。核心的模糊性在于符号 $\\Delta W_i$ 的不一致使用。严谨的解释要求区分标准布朗运动的增量与缩放或带漂移过程的增量。\n\n为求解所采纳的解释如下：\n1.  基本构建模块是标准布朗运动 $\\{W_t\\}_{t \\ge 0}$ 的增量，此处表示为 $\\Delta W_i^{\\text{std}} = W_{t_i} - W_{t_{i-1}}$。对于时间步长 $\\Delta t = T/N$，这些增量被模拟为来自高斯分布 $\\mathcal{N}(0, \\Delta t)$ 的独立随机变量。这通过生成标准正态变量 $Z_i \\sim \\mathcal{N}(0, 1)$ 并设置 $\\Delta W_i^{\\text{std}} = Z_i \\sqrt{\\Delta t}$ 来实现。\n2.  要模拟的一般过程是形式为 $X_t = \\mu t + \\sigma W_t$ 的带漂移的扩散过程。其离散增量由 $\\Delta X_i = \\mu \\Delta t + \\sigma \\Delta W_i^{\\text{std}}$ 给出。\n3.  在每种情况下，术语“二次变差”被解释为正在模拟的特定过程的经验二次变差，即 $\\sum_{i=1}^N (\\Delta X_i)^2$，其中 $\\Delta X_i$ 是该过程的增量。问题中的模糊符号，例如 $\\sum (\\Delta W_i)^2$，通过假设它指的是该案例上下文中指定过程的增量来解决。\n\n这种解释使得问题适定且科学上合理，从而能够得出一个唯一且有意义的解。\n\n每种情况的模拟和计算执行如下：\n\n**通用模拟步骤**\n对于每个具有时间范围 $T$、步数 $N$、波动率 $\\sigma$、漂移 $\\mu$ 和一个随机种子的测试用例，采取以下步骤：\n1.  使用指定的种子初始化随机数生成器，以确保确定性输出。\n2.  时间步长计算为 $\\Delta t = T/N$。\n3.  生成一个包含 $N$ 个独立标准正态样本的向量 $\\{Z_i\\}_{i=1}^N$。\n4.  根据参数构建相应随机过程的增量 $\\{ \\Delta X_i \\}_{i=1}^N$。\n\n**案例1：基准二次变差**\n参数为 $T = 1$, $N = 100000$, $\\sigma = 1$, $\\mu = 0$。该过程是标准布朗运动 $X_t = W_t$。\n-   时间步长为 $\\Delta t = 1/100000$。\n-   增量为 $\\Delta X_i = 1 \\cdot Z_i \\sqrt{\\Delta t} = Z_i \\sqrt{\\Delta t}$。\n-   二次变差计算为 $Q_1 = \\sum_{i=1}^N (\\Delta X_i)^2 = \\sum_{i=1}^N (Z_i \\sqrt{\\Delta t})^2 = \\Delta t \\sum_{i=1}^N Z_i^2$。\n理论上，二次变差收敛到 $T = 1$。模拟提供了一个数值近似值。\n\n**案例2：缩放二次变差**\n参数为 $T = 2$, $N = 200000$, $\\sigma = 0.8$, $\\mu = 0$。该过程是缩放布朗运动 $X_t = \\sigma W_t = 0.8 W_t$。\n-   时间步长为 $\\Delta t = 2/200000 = 1/100000$。\n-   增量为 $\\Delta X_i = \\sigma Z_i \\sqrt{\\Delta t} = 0.8 \\cdot Z_i \\sqrt{\\Delta t}$。\n-   二次变差计算为 $Q_2 = \\sum_{i=1}^N (\\Delta X_i)^2 = \\sum_{i=1}^N (0.8 \\cdot Z_i \\sqrt{\\Delta t})^2 = \\sigma^2 \\Delta t \\sum_{i=1}^N Z_i^2$。\n理论上，$X_t = \\sigma W_t$ 在 $[0, T]$ 上的二次变差为 $\\sigma^2 T = (0.8)^2 \\cdot 2 = 0.64 \\cdot 2 = 1.28$。\n\n**案例3：二次变差的漂移不变性**\n参数为 $T = 1$, $N = 400000$, $\\sigma = 1$。比较两个过程，一个带漂移 $\\mu = 0.5$，一个不带漂移 $\\mu = 0$。两者都基于相同的随机变量序列 $\\{Z_i\\}_{i=1}^N$。\n-   时间步长为 $\\Delta t = 1/400000$。\n-   标准维纳增量为 $\\Delta W_i^{\\text{std}} = Z_i \\sqrt{\\Delta t}$。\n-   不带漂移过程（$\\mu=0, \\sigma=1$）的增量为 $\\Delta Y_i = \\sigma \\Delta W_i^{\\text{std}} = 1 \\cdot Z_i \\sqrt{\\Delta t}$。其二次变差为 $Q^{\\text{nodrift}} = \\sum_{i=1}^N (\\Delta Y_i)^2$。\n-   带漂移过程（$\\mu=0.5, \\sigma=1$）的增量为 $\\Delta X_i = \\mu \\Delta t + \\sigma \\Delta W_i^{\\text{std}} = 0.5 \\Delta t + 1 \\cdot Z_i \\sqrt{\\Delta t}$。其二次变差为 $Q^{\\text{drift}} = \\sum_{i=1}^N (\\Delta X_i)^2$。\n-   展开 $Q^{\\text{drift}}$ 得到 $\\sum (\\mu \\Delta t)^2 + 2\\mu \\Delta t \\sum \\Delta W_i^{\\text{std}} + \\sum (\\Delta W_i^{\\text{std}})^2$。\n差值为 $D_3 = |Q^{\\text{drift}} - Q^{\\text{nodrift}}| = |\\sum_{i=1}^N ((\\mu\\Delta t)^2 + 2\\mu\\Delta t \\Delta W_i^{\\text{std}})|$。\n当 $N \\to \\infty$ 且 $\\Delta t \\to 0$ 时，此差异趋于零，因为各项的阶数为 $\\Delta t$ 或更小。模拟数值上证明了这一性质。\n\n**案例4：经验连续模**\n参数为 $T = 1$, $N = 131072$, $\\sigma = 1$, $\\mu = 0$。该过程是标准布朗运动。\n-   时间步长为 $\\Delta t = 1/131072$。\n-   增量为 $\\Delta X_i = 1 \\cdot Z_i \\sqrt{\\Delta t}$。\n-   计算最大绝对增量：$M = \\max_{1 \\le i \\le N} |\\Delta X_i| = \\sqrt{\\Delta t} \\max_i |Z_i|$。\n-   根据布朗增量的重对数律，一个理论上的缩放因子是 $S = \\sqrt{2 \\Delta t \\log(1/\\Delta t)}$。\n-   计算比率 $R_4 = M/S$。理论表明 $\\limsup_{\\Delta t \\to 0} \\frac{\\max_{i} |W_{t_i} - W_{t_{i-1}}|}{\\sqrt{2 \\Delta t \\log(1/\\Delta t)}} = 1$ 几乎必然成立。该模拟为有限的 $\\Delta t$ 提供了该比率的单路径实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates sample paths of Brownian motion to investigate path continuity\n    and quadratic variation based on the problem specification.\n    \"\"\"\n    \n    test_cases = [\n        {'id': 1, 'T': 1.0, 'N': 100000, 'sigma': 1.0, 'seed': 314159},\n        {'id': 2, 'T': 2.0, 'N': 200000, 'sigma': 0.8, 'seed': 314160},\n        {'id': 3, 'T': 1.0, 'N': 400000, 'sigma': 1.0, 'mu': 0.5, 'seed': 314161},\n        {'id': 4, 'T': 1.0, 'N': 131072, 'sigma': 1.0, 'seed': 314162}\n    ]\n\n    results = []\n\n    # Case 1: Baseline quadratic variation\n    case1 = test_cases[0]\n    rng1 = np.random.default_rng(case1['seed'])\n    T1, N1, sigma1 = case1['T'], case1['N'], case1['sigma']\n    dt1 = T1 / N1\n    Z1 = rng1.standard_normal(size=N1)\n    # The increments of the process X_t = sigma * W_t are dX_i = sigma * dW_i\n    # where dW_i ~ N(0, dt). dW_i = Z_i * sqrt(dt). So dX_i = sigma * Z_i * sqrt(dt).\n    # Quadratic variation is Sum(dX_i^2) = Sum( (sigma * Z_i * sqrt(dt))^2 )\n    # = sigma^2 * dt * Sum(Z_i^2)\n    q1 = (sigma1**2) * dt1 * np.sum(Z1**2)\n    results.append(q1)\n    \n    # Case 2: Scaled variance\n    case2 = test_cases[1]\n    rng2 = np.random.default_rng(case2['seed'])\n    T2, N2, sigma2 = case2['T'], case2['N'], case2['sigma']\n    dt2 = T2 / N2\n    Z2 = rng2.standard_normal(size=N2)\n    q2 = (sigma2**2) * dt2 * np.sum(Z2**2)\n    results.append(q2)\n\n    # Case 3: Drift invariance\n    case3 = test_cases[2]\n    rng3 = np.random.default_rng(case3['seed'])\n    T3, N3, sigma3, mu3 = case3['T'], case3['N'], case3['sigma'], case3['mu']\n    dt3 = T3 / N3\n    Z3 = rng3.standard_normal(size=N3)\n    \n    # Standard Wiener increments\n    dW_std = Z3 * np.sqrt(dt3)\n    \n    # Non-drifted process increments: dY_i = sigma * dW_i\n    nodrift_increments = sigma3 * dW_std\n    q_nodrift = np.sum(nodrift_increments**2)\n    \n    # Drifted process increments: dX_i = mu*dt + sigma*dW_i\n    drifted_increments = mu3 * dt3 + sigma3 * dW_std\n    q_drift = np.sum(drifted_increments**2)\n    \n    d3 = np.abs(q_drift - q_nodrift)\n    results.append(d3)\n    \n    # Case 4: Empirical modulus statistic\n    case4 = test_cases[3]\n    rng4 = np.random.default_rng(case4['seed'])\n    T4, N4, sigma4 = case4['T'], case4['N'], case4['sigma']\n    dt4 = T4 / N4\n    Z4 = rng4.standard_normal(size=N4)\n    \n    # Process increments for standard BM (sigma=1)\n    increments = sigma4 * Z4 * np.sqrt(dt4)\n    \n    # M = max |increment_i|\n    M = np.max(np.abs(increments))\n    \n    # S = sqrt(2*dt*log(1/dt))\n    S = np.sqrt(2 * dt4 * np.log(1 / dt4))\n    \n    r4 = M / S\n    results.append(r4)\n\n    # Format output to 6 decimal places and print in the required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3074685"}, {"introduction": "在掌握了基本的路径模拟技能之后，一个自然的问题是：我们能否构造出满足特定条件的路径？例如，一条从0点出发并在未来某个时刻 $T$ 到达特定值 $a$ 的路径。这就引出了“布朗桥”的概念。这个实践不仅涉及模拟，更要求你首先从高斯过程的基本性质出发，推导出布朗桥的统计特性。然后，你将通过编写代码来生成这些受约束的路径，并通过经验数据验证你的理论推导是否正确，从而将解析理论与计算实践紧密联系起来。[@problem_id:3074672]", "problem": "给定标准布朗运动（也称维纳过程）$\\{W_t\\}_{t \\ge 0}$ 的定义为一个高斯过程，其几乎必然满足 $W_0 = 0$，具有独立增量，并且对于 $0 \\le s  t$ 有 $W_t - W_s \\sim \\mathcal{N}(0, t - s)$，请考虑将布朗运动约束于未来某一时刻的固定终值。设给定 $T > 0$ 和一个终值 $a \\in \\mathbb{R}$。将在中间时刻 $t \\in [0, T]$ 的条件过程（布朗桥）定义为 $B_t := W_t \\mid \\{W_T = a\\}$。从高斯过程和布朗运动的基本性质出发，推导 $B_t$ 的条件分布（以其均值和方差表示），并推导出一个仅使用布朗运动定义性质的 $B_t$ 模拟程序，而不调用任何快捷公式。\n\n您的程序必须完全基于这些原理实现以下内容：\n- 对于给定的 $t$ 和 $T$，使用基于布朗运动基本增量结构的蒙特卡洛模拟，生成配对 $(W_t, W_T)$ 的独立样本。\n- 根据这些样本，构造对应于以 $W_T = a$ 为条件的布朗桥 $B_t$ 的样本。\n- 从生成的样本中，经验性地估计 $B_t$ 的均值和方差。\n- 将这些经验值与您推导出的解析均值和方差进行比较，并报告每个估计值是否在指定的容差范围内。\n\n必须严格遵守的实现细节：\n- 每个测试用例使用 $N = 400000$ 个蒙特卡洛样本。\n- 为了可复现性，使用固定的伪随机数生成器种子，其值为 $314159265$。\n- 对均值使用容差 $\\varepsilon_{\\mu} = 5 \\times 10^{-3}$，对 variance 使用容差 $\\varepsilon_{\\sigma^2} = 5 \\times 10^{-3}$。\n- 为模拟 $(W_t, W_T)$，您必须使用布朗运动增量结构：模拟 $W_t \\sim \\mathcal{N}(0, t)$ 和一个独立的增量 $I_{t \\to T} \\sim \\mathcal{N}(0, T - t)$（理解为方差为 $0$ 意味着相应变量确定性地为 $0$），然后设置 $W_T := W_t + I_{t \\to T}$。\n- 仅使用您推导出的关系，从模拟的 $(W_t, W_T)$ 中构造 $B_t$ 的样本，然后计算其经验均值和方差。\n\n测试套件：\n您的程序必须运行以下测试用例，每个用例指定为一个元组 $(T, a, t)$：\n- $(1.0, 0.0, 0.5)$\n- $(2.0, 1.0, 1.0)$\n- $(3.0, -1.5, 0.0)$\n- $(1.25, 0.7, 1.25)$\n\n对于每个测试用例，计算两个布尔值：\n- $b_{\\mu}$：如果经验均值与解析均值之间的绝对误差最多为 $\\varepsilon_{\\mu}$，则为 true。\n- $b_{\\sigma^2}$：如果经验方差与解析方差之间的绝对误差最多为 $\\varepsilon_{\\sigma^2}$，则为 true。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。按顺序连接每个测试用例的两个布尔值，形成一个长度为 $8$ 的列表，即：\n$[b_{\\mu}^{(1)}, b_{\\sigma^2}^{(1)}, b_{\\mu}^{(2)}, b_{\\sigma^2}^{(2)}, b_{\\mu}^{(3)}, b_{\\sigma^2}^{(3)}, b_{\\mu}^{(4)}, b_{\\sigma^2}^{(4)}]$。\n不应打印任何额外的文本或行。\n\n此问题中的所有量都是无量纲的；不涉及物理单位。不出现角度，也不需要百分比。在所有计算中，确保 $T > 0$ 和 $t \\in [0, T]$。", "solution": "该问题要求推导标准布朗运动 $\\{W_t\\}_{t \\ge 0}$ 在给定其终值 $W_T = a$ 的条件下，于中间时刻 $t \\in [0, T]$ 的条件分布。这个条件过程 $B_t := W_t \\mid \\{W_T = a\\}$ 被称为布朗桥。我们必须从第一性原理出发推导其均值和方差，然后同样从第一性原理出发推导一个模拟程序。最后，我们将实现这个程序来经验性地验证我们的解析结果。\n\n**1. 布朗桥条件分布的推导**\n\n标准布朗运动 $\\{W_t\\}_{t \\ge 0}$ 是一个高斯过程，其特征如下：\n1.  $W_0 = 0$ 几乎必然成立。\n2.  对于任意时间集合 $0 \\le t_1  t_2  \\dots  t_n$，增量 $W_{t_1}, W_{t_2}-W_{t_1}, \\dots, W_{t_n}-W_{t_{n-1}}$ 是独立的。\n3.  对于 $0 \\le s  t$，增量 $W_t - W_s$ 是一个正态分布的随机变量，$W_t - W_s \\sim \\mathcal{N}(0, t-s)$。\n\n由这些性质可知，对于任意 $t > 0$，$W_t \\sim \\mathcal{N}(0, t)$，并且 $\\mathbb{E}[W_t] = 0$。\n\n为了找到 $B_t = W_t \\mid \\{W_T = a\\}$ 的分布，我们考虑对于固定的 $t$（满足 $0 \\le t \\le T$），随机变量 $W_t$ 和 $W_T$ 的联合分布。由于 $\\{W_t\\}$ 是一个高斯过程，向量 $(W_t, W_T)^T$ 服从二元正态分布。我们必须确定其均值向量和协方差矩阵。\n\n均值向量为 $\\boldsymbol{\\mu} = (\\mathbb{E}[W_t], \\mathbb{E}[W_T])^T = (0, 0)^T$。\n\n协方差矩阵 $\\Sigma$ 由下式给出：\n$$\n\\Sigma = \\begin{pmatrix} \\text{Var}(W_t)  \\text{Cov}(W_t, W_T) \\\\ \\text{Cov}(W_t, W_T)  \\text{Var}(W_T) \\end{pmatrix}\n$$\n方差由定义直接给出：$\\text{Var}(W_t) = t$ 和 $\\text{Var}(W_T) = T$。\n为了求协方差 $\\text{Cov}(W_t, W_T)$，我们使用独立增量的性质。我们将 $W_T$ 写成 $W_t + (W_T - W_t)$。对于 $t  T$，随机变量 $W_t$ 和 $(W_T - W_t)$ 是独立的。\n$$\n\\text{Cov}(W_t, W_T) = \\mathbb{E}[W_t W_T] - \\mathbb{E}[W_t]\\mathbb{E}[W_T] = \\mathbb{E}[W_t W_T]\n$$\n$$\n\\mathbb{E}[W_t W_T] = \\mathbb{E}[W_t (W_t + W_T - W_t)] = \\mathbb{E}[W_t^2] + \\mathbb{E}[W_t(W_T - W_t)]\n$$\n由于独立性以及对于任何 $s$ 都有 $\\mathbb{E}[W_s] = 0$ 的事实，我们有：\n$$\n\\mathbb{E}[W_t(W_T - W_t)] = \\mathbb{E}[W_t]\\mathbb{E}[W_T - W_t] = 0 \\cdot 0 = 0\n$$\n因此，协方差为：\n$$\n\\text{Cov}(W_t, W_T) = \\mathbb{E}[W_t^2] = \\text{Var}(W_t) + (\\mathbb{E}[W_t])^2 = t + 0^2 = t\n$$\n此公式也对边界情况 $t=T$ 成立，此时 $\\text{Cov}(W_T, W_T) = \\text{Var}(W_T) = T$。\n因此，$(W_t, W_T)^T$ 的协方差矩阵为：\n$$\n\\Sigma = \\begin{pmatrix} t  t \\\\ t  T \\end{pmatrix}\n$$\n对于一个一般的二元正态向量 $(X_1, X_2)^T$，其均值为 $(\\mu_1, \\mu_2)^T$，协方差矩阵为 $\\begin{pmatrix} \\Sigma_{11}  \\Sigma_{12} \\\\ \\Sigma_{21}  \\Sigma_{22} \\end{pmatrix}$，给定 $X_2 = x_2$ 时 $X_1$ 的条件分布是正态的，其条件均值和方差由以下公式给出：\n$$\n\\mathbb{E}[X_1 \\mid X_2=x_2] = \\mu_1 + \\Sigma_{12} \\Sigma_{22}^{-1} (x_2 - \\mu_2)\n$$\n$$\n\\text{Var}(X_1 \\mid X_2=x_2) = \\Sigma_{11} - \\Sigma_{12} \\Sigma_{22}^{-1} \\Sigma_{21}\n$$\n将这些公式应用于我们的情况（其中 $X_1 = W_t, X_2 = W_T, x_2 = a, \\mu_1 = \\mu_2 = 0$），我们得到布朗桥 $B_t$ 的解析均值和方差：\n解析均值为：\n$$\n\\mathbb{E}[B_t] = \\mathbb{E}[W_t \\mid W_T=a] = 0 + t \\cdot T^{-1} \\cdot (a - 0) = \\frac{at}{T}\n$$\n解析方差为：\n$$\n\\text{Var}(B_t) = \\text{Var}(W_t \\mid W_T=a) = t - t \\cdot T^{-1} \\cdot t = t - \\frac{t^2}{T} = \\frac{tT - t^2}{T} = \\frac{t(T-t)}{T}\n$$\n所以，条件分布为 $B_t \\sim \\mathcal{N}\\left(\\frac{at}{T}, \\frac{t(T-t)}{T}\\right)$。\n\n**2. 模拟程序的推导**\n\n问题要求从第一性原理推导一个模拟程序。我们可以通过构造一个与条件变量 $W_T$ 独立的、与布朗桥相关的过程来实现这一点。让我们为 $t \\in [0, T]$ 定义一个新过程 $X_t$：\n$$\nX_t = W_t - \\frac{t}{T}W_T\n$$\n由于 $X_t$ 是联合高斯随机变量的线性组合，它也是一个高斯过程。让我们计算它与 $W_T$ 的协方差：\n$$\n\\text{Cov}(X_t, W_T) = \\text{Cov}\\left(W_t - \\frac{t}{T}W_T, W_T\\right) = \\text{Cov}(W_t, W_T) - \\frac{t}{T}\\text{Var}(W_T)\n$$\n使用我们之前推导的结果 $\\text{Cov}(W_t, W_T) = t$ 和 $\\text{Var}(W_T) = T$：\n$$\n\\text{Cov}(X_t, W_T) = t - \\frac{t}{T} \\cdot T = 0\n$$\n由于 $X_t$ 和 $W_T$ 是联合高斯的且它们的协方差为零，所以它们是独立的。\n我们可以用 $X_t$ 和 $W_T$ 来表示 $W_t$：\n$$\nW_t = X_t + \\frac{t}{T}W_T\n$$\n当我们以事件 $\\{W_T = a\\}$ 为条件时，随机变量 $W_T$ 变成常数 $a$。因为 $X_t$ 独立于 $W_T$，它的分布不受此条件的影响。因此，条件过程 $B_t = W_t \\mid \\{W_T = a\\}$ 与随机变量 $X_t + \\frac{at}{T}$ 具有相同的分布。\n过程 $X_t$ 是一个标准布朗桥（从 $0$ 到 $0$），其分布是正态的，均值为 $\\mathbb{E}[X_t] = \\mathbb{E}[W_t] - \\frac{t}{T}\\mathbb{E}[W_T] = 0$，方差为 $\\text{Var}(X_t) = \\frac{t(T-t)}{T}$（如前一节所计算）。\n\n这种分解提供了模拟程序：\n1.  生成无条件对 $(W_t, W_T)$ 的一个样本。问题要求使用独立增量结构来完成此操作：\n    a. 从 $\\mathcal{N}(0, t)$ 生成一个样本 $w_t$。\n    b. 从 $\\mathcal{N}(0, T-t)$ 生成一个独立样本 $i_{t \\to T}$。\n    c. 形成样本 $w_T = w_t + i_{t \\to T}$。\n2.  从样本对 $(w_t, w_T)$，构造标准桥过程 $X_t$ 的一个样本：\n    $$\n    x_t = w_t - \\frac{t}{T}w_T\n    $$\n    这个 $x_t$ 是从 $\\mathcal{N}(0, \\frac{t(T-t)}{T})$ 中随机抽取的一个值。\n3.  通过加上确定性漂移来构造所需的条件桥 $B_t$ 的样本：\n    $$\n    b_t = x_t + \\frac{at}{T} = \\left(w_t - \\frac{t}{T}w_T\\right) + \\frac{at}{T}\n    $$\n这个程序严格遵守了生成 $(W_t, W_T)$ 样本，然后完全基于布朗运动的基本性质，使用推导出的关系构造 $B_t$ 样本的流程。我们现在将实现此算法，为每个测试用例生成 $N=400000$ 个样本，并将经验均值和方差与上面推导的解析结果进行比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# SciPy is specified as available but is not required for this problem.\n# from scipy import stats\n\ndef solve():\n    \"\"\"\n    Derives and simulates a Brownian bridge to verify its mean and variance.\n    \"\"\"\n    # Define the simulation parameters from the problem statement.\n    N = 400000\n    SEED = 314159265\n    TOL_MEAN = 5e-3\n    TOL_VAR = 5e-3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, a, t)\n        (1.0, 0.0, 0.5),\n        (2.0, 1.0, 1.0),\n        (3.0, -1.5, 0.0),\n        (1.25, 0.7, 1.25),\n    ]\n\n    # Set the seed for the pseudorandom number generator for reproducibility.\n    rng = np.random.default_rng(SEED)\n\n    results = []\n    for T, a, t in test_cases:\n        # Step 1: Calculate the analytical mean and variance of the Brownian bridge B_t.\n        # Handle the case T=0 to avoid division by zero, although problem constraints ensure T > 0.\n        if T == 0:\n            # If T=0, then t must be 0. W_0 = 0.\n            # If a is not 0, the conditioning is on an impossible event.\n            # However, problem states T > 0.\n            mean_analytical = 0.0 if a == 0 else np.nan\n            var_analytical = 0.0\n        else:\n            mean_analytical = a * t / T\n            var_analytical = t * (T - t) / T\n\n        # Step 2: Perform Monte Carlo simulation based on the derived procedure.\n        \n        # Variances for the normal distributions. Variances can be zero.\n        # std_dev = sqrt(variance)\n        std_dev_W_t = np.sqrt(t)\n        std_dev_inc = np.sqrt(T - t)\n\n        # Generate N samples of W_t from N(0, t).\n        # If t=0, std_dev_W_t=0, and this correctly generates an array of zeros.\n        W_t_samples = rng.normal(loc=0.0, scale=std_dev_W_t, size=N)\n\n        # Generate N samples of the independent increment I_{t->T} from N(0, T-t).\n        # If t=T, std_dev_inc=0, and this correctly generates an array of zeros.\n        inc_samples = rng.normal(loc=0.0, scale=std_dev_inc, size=N)\n\n        # Construct N samples of W_T = W_t + I_{t->T}.\n        W_T_samples = W_t_samples + inc_samples\n\n        # Construct N samples of the Brownian bridge B_t using the derived relation:\n        # b_t = (w_t - (t/T)*w_T) + (a*t)/T\n        # This is numerically stable since T > 0 for all test cases.\n        bridge_samples = (W_t_samples - (t / T) * W_T_samples) + (a * t / T)\n\n        # Step 3: Calculate empirical mean and variance from the samples.\n        # We use population variance (ddof=0) for comparison against theoretical value.\n        mean_empirical = np.mean(bridge_samples)\n        var_empirical = np.var(bridge_samples, ddof=0)\n\n        # Step 4: Compare empirical results to analytical values within tolerance.\n        b_mu = abs(mean_empirical - mean_analytical) = TOL_MEAN\n        b_sigma2 = abs(var_empirical - var_analytical) = TOL_VAR\n\n        results.extend([b_mu, b_sigma2])\n\n    # Final print statement in the exact required format.\n    # The default str() for bool is 'True'/'False' with capitalization.\n    # The problem format example like [b_mu, b_sigma2] suggests this is OK.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3074672"}, {"introduction": "最后，我们将转向一个更具应用性的场景。模拟随机路径通常是实现更宏大目标的手段，例如，在金融数学中，我们常常需要估计那些依赖于整个路径历史的量的期望值。最后的这项实践就将处理这样一个问题，但重点在于效率。你将了解到，朴素的蒙特卡洛模拟收敛速度可能很慢，并进一步探索两种强大的方差缩减技术——对偶变量法和控制变量法——来显著提高估计的精度。这项练习为你打开了一扇窗，让你得以一窥定量金融和计算科学领域中的实际挑战与精妙对策。[@problem_id:3074678]", "problem": "您需要设计并实现一个模拟，以在使用三种蒙特卡洛估计量估计标准布朗运动的路径依赖泛函的期望时，量化方差缩减的效果。从标准布朗运动的基本原理出发，标准布朗运动 $\\{B_t\\}_{t \\ge 0}$ 是一个连续时间随机过程，满足 $B_0 = 0$，具有独立增量，并且对于 $0 \\le s  t$ 有 $B_t - B_s \\sim \\mathcal{N}(0, t - s)$。使用带有均匀网格的离散时间近似，通过独立的标准高斯增量来构建样本路径。\n\n对于给定的参数 $\\alpha$ 和时间范围 $T$，定义路径泛函为\n$$\nI = \\int_0^T \\exp\\!\\big(\\alpha\\, B_t - \\tfrac{1}{2}\\alpha^2 t\\big)\\, dt.\n$$\n在一个包含 $M$ 个步长（$\\Delta t = T/M$）的均匀网格上，使用 $\\{B_{k\\Delta t}\\}_{k=0}^{M-1}$ 的值，通过左黎曼和来近似该积分。对于每个路径，计算样本路径近似值\n$$\n\\widehat{I} = \\sum_{k=0}^{M-1} \\exp\\!\\big(\\alpha\\, B_{k\\Delta t} - \\tfrac{1}{2}\\alpha^2 (k\\Delta t)\\big)\\, \\Delta t.\n$$\n\n您的目标是使用三种估计量来估计 $\\mu = \\mathbb{E}[\\widehat{I}]$，并量化每种方法下蒙特卡洛估计量（即样本均值）的方差。该方差表示为该方法所使用的逐路径贡献的样本方差除以对均值有贡献的有效独立项数。\n\n实现以下估计量：\n- 普通蒙特卡洛（MC）：模拟 $N$ 条独立路径，并计算 $\\widehat{I}$ 的样本均值。将此样本均值的估计方差报告为 $\\widehat{\\mathrm{Var}}_{\\text{plain}} = s^2(\\widehat{I}_1,\\dots,\\widehat{I}_N)/N$，其中 $s^2$ 表示从 $N$ 个路径值计算出的无偏样本方差。\n- 对偶变量：对于 $N/2$ 组独立模拟的高斯增量 $\\{\\Delta B_k\\}_{k=1}^M$，使用 $\\Delta B_k$ 和 $-\\Delta B_k$ 形成一对路径，以计算 $\\widehat{I}^{(+)}$ 和 $\\widehat{I}^{(-)}$。使用成对平均值 $Y_i = \\tfrac{1}{2}(\\widehat{I}^{(+)}_i + \\widehat{I}^{(-)}_i)$ 作为对估计量的贡献，并将样本均值的方差计算为 $\\widehat{\\mathrm{Var}}_{\\text{anti}} = s^2(Y_1,\\dots,Y_{N/2})/(N/2)$。\n- 控制变量：对于与普通蒙特卡洛方法中相同的 $N$ 条独立路径，使用终端值 $C = B_T$（其期望已知为 $\\mathbb{E}[C] = 0$）构建一个线性控制变量。构造调整后的贡献 $Z_i = \\widehat{I}_i - \\beta C_i$，其中系数 $\\beta$ 基于相同的模拟数据选择，以最小化所有实系数下 $Z_i$ 的样本方差。将样本均值的估计方差报告为 $\\widehat{\\mathrm{Var}}_{\\text{ctrl}} = s^2(Z_1,\\dots,Z_N)/N$。\n\n遵循标准布朗运动模拟的原理：将增量生成为方差等于时间步长的独立高斯随机变量，并通过累积求和获得离散路径值。按照规定使用左端点构建黎曼和。\n\n测试套件：\n为了可复现性，使用一个固定的随机数生成器种子，其值等于 $12345$，并使用以下三个测试用例：\n1. 用例 A（正常路径）：$N = 20000$, $T = 1.0$, $M = 200$, $\\alpha = 1.0$。\n2. 用例 B（小时间边界）：$N = 20000$, $T = 0.05$, $M = 5$, $\\alpha = 1.0$。\n3. 用例 C（粗糙网格边缘）：$N = 20000$, $T = 1.0$, $M = 1$, $\\alpha = 1.0$。\n\n对于每个用例，按顺序计算并返回一个浮点数三元组 $\\big(\\widehat{\\mathrm{Var}}_{\\text{plain}}, \\widehat{\\mathrm{Var}}_{\\text{anti}}, \\widehat{\\mathrm{Var}}_{\\text{ctrl}}\\big)$。将所有用例的结果按用例 A、用例 B、用例 C 的顺序拼接成一个包含九个浮点数的扁平列表。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含九个十进制数，按顺序对应于三个用例中每个用例的三个方差，并四舍五入到六位小数。例如，一个有效的输出行应如下所示：\n$[$$0.001234$$,$$0.000987$$,$$0.000543$$,$$0.000111$$,$$0.000098$$,$$0.000076$$,$$0.0$$,$$0.0$$,$$0.0$$]$.\n不应打印任何其他文本。", "solution": "首先评估用户问题的有效性。\n\n### 第 1 步：提取已知条件\n- **过程**：标准布朗运动 $\\{B_t\\}_{t \\ge 0}$，满足 $B_0 = 0$，具有独立增量，且对于 $0 \\le s  t$ 有 $B_t - B_s \\sim \\mathcal{N}(0, t - s)$。\n- **路径泛函**：$I = \\int_0^T \\exp\\big(\\alpha\\, B_t - \\tfrac{1}{2}\\alpha^2 t\\big)\\, dt$。\n- **离散化**：均匀时间网格，包含 $M$ 个步长，$\\Delta t = T/M$。使用路径值 $\\{B_{k\\Delta t}\\}_{k=0}^{M-1}$。\n- **近似泛函**：左黎曼和 $\\widehat{I} = \\sum_{k=0}^{M-1} \\exp\\big(\\alpha\\, B_{k\\Delta t} - \\tfrac{1}{2}\\alpha^2 (k\\Delta t)\\big)\\, \\Delta t$。\n- **目标**：估计 $\\mu = \\mathbb{E}[\\widehat{I}]$ 并计算三个估计量的样本均值方差。\n- **估计量**：\n    1.  **普通蒙特卡洛（MC）**：$N$ 条独立路径。估计量方差：$\\widehat{\\mathrm{Var}}_{\\text{plain}} = s^2(\\widehat{I}_1,\\dots,\\widehat{I}_N)/N$。\n    2.  **对偶变量**：$N/2$ 组独立增量，形成路径对 $(B, -B)$。贡献项为 $Y_i = \\tfrac{1}{2}(\\widehat{I}^{(+)}_i + \\widehat{I}^{(-)}_i)$。估计量方差：$\\widehat{\\mathrm{Var}}_{\\text{anti}} = s^2(Y_1,\\dots,Y_{N/2})/(N/2)$。\n    3.  **控制变量**：来自普通 MC 的 $N$ 条路径。控制变量为 $C = B_T$。调整后的贡献项为 $Z_i = \\widehat{I}_i - \\beta C_i$，其中 $\\beta$ 通过估计以最小化样本方差。估计量方差：$\\widehat{\\mathrm{Var}}_{\\text{ctrl}} = s^2(Z_1,\\dots,Z_N)/N$。\n- **模拟参数**：\n    - 随机种子：$12345$。\n    - 用例 A：$N = 20000$，$T = 1.0$，$M = 200$，$\\alpha = 1.0$。\n    - 用例 B：$N = 20000$，$T = 0.05$，$M = 5$，$\\alpha = 1.0$。\n    - 用例 C：$N = 20000$，$T = 1.0$，$M = 1$，$\\alpha = 1.0$。\n- **输出**：一个包含九个浮点数的扁平列表，按顺序为每个用例的 $(\\widehat{\\mathrm{Var}}_{\\text{plain}}, \\widehat{\\mathrm{Var}}_{\\text{anti}}, \\widehat{\\mathrm{Var}}_{\\text{ctrl}})$，四舍五入至六位小数。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据验证标准评估问题。\n- **有科学依据**：该问题基于随机过程（布朗运动）和统计模拟（蒙特卡洛方法）的成熟数学理论。所有定义和概念在量化金融和计算数学中都是标准的。量 $X_t = \\exp(\\alpha B_t - \\frac{1}{2}\\alpha^2 t)$ 是一个几何布朗运动，是金融建模中的一个基本对象。\n- **良态的**：问题提供了一个清晰、明确的计算任务。所有参数都已指定，输出格式也很精确。对于给定的种子，存在唯一的数值解。\n- **客观的**：问题陈述是形式化和客观的，没有主观或推测性元素。\n- **无缺陷**：问题不违反任何无效标准。它科学上合理、可形式化、完整、可行且定义明确。$M=1$ 的特殊情况是一个有效的边缘案例，而非缺陷。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。将提供一个合理的解决方案。\n\n### 基于原理的解决方案设计\n\n问题的核心是估计一个随机过程泛函的期望 $\\mu = \\mathbb{E}[\\widehat{I}]$，并量化不同蒙特卡洛估计量的效率。\n\n**理论基础**\n过程 $X_t = \\exp(\\alpha B_t - \\frac{1}{2}\\alpha^2 t)$ 是一个关于由标准布朗运动 $B_t$ 生成的信息流的鞅。这是 Girsanov 定理的直接推论，并且可以使用伊藤引理（Itô's lemma）进行验证，该引理表明 $dX_t = \\alpha X_t dB_t$，这是一个没有漂移项的随机微分方程。作为一个鞅，其期望随时间保持不变：对于所有 $t \\ge 0$，$\\mathbb{E}[X_t] = X_0 = \\exp(0-0) = 1$。\n因此，离散化泛函 $\\widehat{I}$ 的期望可以解析计算得出：\n$$\n\\mu = \\mathbb{E}[\\widehat{I}] = \\mathbb{E}\\left[\\sum_{k=0}^{M-1} X_{k\\Delta t} \\Delta t\\right] = \\sum_{k=0}^{M-1} \\mathbb{E}[X_{k\\Delta t}] \\Delta t = \\sum_{k=0}^{M-1} (1) \\Delta t = M \\Delta t = T.\n$$\n期望的精确值是时间范围 $T$。这为模拟结果提供了一个有价值的合理性检查，因为所有估计量的样本均值都应收敛到 $T$。\n\n**布朗路径模拟**\n标准布朗运动的路径在离散时间网格 $t_k = k \\Delta t$（其中 $k = 0, 1, \\dots, M$，$\\Delta t = T/M$）上进行模拟。路径由其基本属性构建：\n1.  $B_{t_0} = B_0 = 0$。\n2.  增量 $\\Delta B_k = B_{t_k} - B_{t_{k-1}}$（其中 $k=1, \\dots, M$）是独立同分布（i.i.d.）的正态随机变量，$\\Delta B_k \\sim \\mathcal{N}(0, \\Delta t)$。\n这些增量通过缩放标准正态变量 $Z_k \\sim \\mathcal{N}(0, 1)$ 生成，即 $\\Delta B_k = \\sqrt{\\Delta t} Z_k$。然后通过累积和构建路径：$B_{t_k} = \\sum_{j=1}^k \\Delta B_j$。\n\n**估计量实现**\n\n对于每个测试用例，根据问题规范实现三个估计量。一个随机数生成器，为每个用例使用指定种子重新初始化，提供随机性来源。\n\n1.  **普通蒙特卡洛（MC）**：这是基准方法。我们生成 $N$ 条独立的布朗运动路径。对于每条路径 $i \\in \\{1, \\dots, N\\}$，我们计算泛函值 $\\widehat{I}_i$。$\\mu$ 的估计是样本均值 $\\bar{I} = \\frac{1}{N} \\sum_{i=1}^N \\widehat{I}_i$。此样本均值的方差，用于衡量估计量的精度，通过 $\\widehat{\\mathrm{Var}}_{\\text{plain}} = s^2(\\{\\widehat{I}_i\\}) / N$ 来估计，其中 $s^2$ 是收集到的 $\\widehat{I}_i$ 值的无偏样本方差。\n\n2.  **对偶变量**：该技术利用了布朗运动增量的对称性。由于驱动噪声 $\\{Z_k\\}$ 的分布关于 0 对称，由增量 $-\\Delta B_k$ 生成的路径 $-B_t$ 与路径 $B_t$ 同样可能。对于像 $\\widehat{I}$ 这样的凸泛函（指数函数是凸的），$\\widehat{I}(B_t)$ 和 $\\widehat{I}(-B_t)$ 的平均值预计比单独的 $\\widehat{I}(B_t)$ 具有更低的方差。我们生成 $N/2$ 条独立路径，表示为 $B^{(+)}_i$，以及它们的对偶对应项 $B^{(-)}_i = -B^{(+)}_i$。然后我们形成 $N/2$ 个新的观测值 $Y_i = \\frac{1}{2}(\\widehat{I}(B^{(+)}_i) + \\widehat{I}(B^{(-)}_i))$。所得样本均值的方差通过 $\\widehat{\\mathrm{Var}}_{\\text{anti}} = s^2(\\{Y_i\\}) / (N/2)$ 来估计。\n\n3.  **控制变量**：此方法通过减去一个具有已知均值的相关变量来减少方差。我们使用布朗路径的终端值 $C = B_T$ 作为控制变量。我们知道 $\\mathbb{E}[C] = \\mathbb{E}[B_T] = 0$。我们形成一组新的观测值 $Z_i = \\widehat{I}_i - \\beta(C_i - \\mathbb{E}[C_i]) = \\widehat{I}_i - \\beta C_i$。最小化 $\\mathrm{Var}(Z_i)$ 的最优系数 $\\beta$ 是 $\\beta^* = \\mathrm{Cov}(\\widehat{I}, C) / \\mathrm{Var}(C)$。我们从 $N$ 个模拟样本 $\\widehat{I}_i$ 和 $C_i$ 中估计 $\\beta^*$：\n    $$\n    \\hat{\\beta} = \\frac{\\widehat{\\mathrm{Cov}}(\\{\\widehat{I}_i\\}, \\{C_i\\})}{\\widehat{\\mathrm{Var}}(\\{C_i\\})}.\n    $$\n    使用这个估计的 $\\hat{\\beta}$，我们计算调整后的值 $Z_i = \\widehat{I}_i - \\hat{\\beta} C_i$。受控估计量均值的方差则由 $\\widehat{\\mathrm{Var}}_{\\text{ctrl}} = s^2(\\{Z_i\\}) / N$ 给出。如果 $\\widehat{I}$ 和 $B_T$ 显著相关，则此方法有效。由于后期被积函数的值依赖于方差较大的 $B_t$ 值，而这些值与 $B_T$ 高度相关，因此预计存在强相关性。\n\n对于边缘案例 C，其中 $M=1$，黎曼和简化为 $k=0$ 的单个项。由于 $B_0=0$ 且 $t_0=0$，$\\widehat{I} = \\exp(0)\\Delta t = \\Delta t = T/M = 1.0/1.0 = 1.0$。由于 $\\widehat{I}$ 是一个常数，所有估计量的方差均为 0。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates Brownian motion paths to quantify variance reduction in estimating the\n    expectation of a path-dependent functional using three Monte Carlo techniques:\n    Plain Monte Carlo, Antithetic Variates, and Control Variates.\n    \"\"\"\n\n    def calculate_variances_for_case(N, T, M, alpha, rng):\n        \"\"\"\n        Calculates the variances of the sample mean for the three estimators\n        for a single set of parameters.\n\n        Args:\n            N (int): Number of paths for Plain MC and Control Variates.\n            T (float): Time horizon.\n            M (int): Number of time steps in the discretization.\n            alpha (float): Parameter in the path functional.\n            rng (np.random.Generator): The random number generator instance.\n\n        Returns:\n            tuple: A triple of floats (var_plain, var_anti, var_ctrl).\n        \"\"\"\n        delta_t = T / M\n\n        # Handle the trivial edge case where the functional is constant.\n        if M == 1:\n            # For M=1, the sum has one term at k=0.\n            # I_hat = exp(alpha*B_0 - 0.5*alpha^2*t_0) * delta_t\n            # Since B_0=0 and t_0=0, I_hat = exp(0) * T = T.\n            # The value is constant, so variance is 0 for all methods.\n            return 0.0, 0.0, 0.0\n\n        # --- Plain MC and Control Variate Calculations ---\n        # Generate N paths, each with M steps.\n        # Z_mc are the standard normal innovations.\n        Z_mc = rng.standard_normal(size=(N, M))\n        delta_B_mc = Z_mc * np.sqrt(delta_t)\n        \n        # B_mc are the Brownian paths. Shape: (N, M+1) since B_0=0 is prepended.\n        B_mc = np.cumsum(delta_B_mc, axis=1)\n        B_mc = np.hstack((np.zeros((N, 1)), B_mc))\n        \n        # Time grid for the Riemann sum (k=0 to M-1).\n        t_grid = np.arange(M) * delta_t\n        \n        # Calculate the approximate functional I_hat for each of the N paths.\n        # B_for_I uses path values from t_0 to t_{M-1}.\n        B_for_I = B_mc[:, :M]\n        exponent = alpha * B_for_I - 0.5 * alpha**2 * t_grid\n        integrand = np.exp(exponent)\n        I_hats_mc = np.sum(integrand, axis=1) * delta_t\n        \n        # 1. Plain MC variance of the sample mean\n        var_plain_samples = np.var(I_hats_mc, ddof=1)\n        var_plain_mean = var_plain_samples / N\n        \n        # 3. Control Variate variance of the sample mean\n        C = B_mc[:, -1] # Control variate C = B_T\n        cov_matrix = np.cov(I_hats_mc, C, ddof=1)\n        \n        # Estimate the optimal coefficient beta.\n        # Check for Var(C)=0 to avoid division by zero, though unlikely here.\n        if cov_matrix[1, 1] == 0:\n            beta_hat = 0.0\n        else:\n            beta_hat = cov_matrix[0, 1] / cov_matrix[1, 1]\n\n        Z = I_hats_mc - beta_hat * C\n        var_Z_samples = np.var(Z, ddof=1)\n        var_ctrl_mean = var_Z_samples / N\n\n        # --- Antithetic Variate Calculation ---\n        N_half = N // 2\n        \n        # Generate N/2 new sets of increments.\n        Z_anti = rng.standard_normal(size=(N_half, M))\n        \n        # Construct positive and negative paths from the same increments.\n        delta_B_pos = Z_anti * np.sqrt(delta_t)\n        B_pos = np.cumsum(delta_B_pos, axis=1)\n        B_pos = np.hstack((np.zeros((N_half, 1)), B_pos))\n        B_neg = -B_pos\n        \n        # Calculate I_hat for positive paths.\n        B_for_I_pos = B_pos[:, :M]\n        exponent_pos = alpha * B_for_I_pos - 0.5 * alpha**2 * t_grid\n        integrand_pos = np.exp(exponent_pos)\n        I_hats_pos = np.sum(integrand_pos, axis=1) * delta_t\n        \n        # Calculate I_hat for negative paths.\n        B_for_I_neg = B_neg[:, :M]\n        exponent_neg = alpha * B_for_I_neg - 0.5 * alpha**2 * t_grid\n        integrand_neg = np.exp(exponent_neg)\n        I_hats_neg = np.sum(integrand_neg, axis=1) * delta_t\n        \n        # 2. Antithetic Variate variance of the sample mean.\n        # Y are the pairwise averages.\n        Y = 0.5 * (I_hats_pos + I_hats_neg)\n        var_Y_samples = np.var(Y, ddof=1)\n        var_anti_mean = var_Y_samples / N_half\n\n        return var_plain_mean, var_anti_mean, var_ctrl_mean\n\n    seed = 12345\n    \n    test_cases = [\n        # (N, T, M, alpha)\n        (20000, 1.0, 200, 1.0),  # Case A\n        (20000, 0.05, 5, 1.0),   # Case B\n        (20000, 1.0, 1, 1.0)     # Case C\n    ]\n\n    results = []\n    for case_params in test_cases:\n        N, T, M, alpha = case_params\n        # A new RNG is created for each test case, seeded with the same value\n        # to ensure each case is independently reproducible.\n        rng = np.random.default_rng(seed)\n        case_variances = calculate_variances_for_case(N, T, M, alpha, rng)\n        results.extend(case_variances)\n\n    # Format the final output list as a comma-separated string of floats\n    # rounded to six decimal places, enclosed in square brackets.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "3074678"}]}