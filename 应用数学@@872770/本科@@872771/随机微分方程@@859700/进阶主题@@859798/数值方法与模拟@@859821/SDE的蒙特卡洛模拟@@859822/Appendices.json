{"hands_on_practices": [{"introduction": "为了数值模拟随机微分方程（SDE），我们必须将连续的时间过程离散化为一系列小的时间步。这个练习将重点放在执行单个时间步最基本的方法——欧拉-丸山（Euler-Maruyama）格式上。通过这个动手计算，你将具体理解在一个微小的时间间隔内，漂移项和扩散项是如何共同驱动过程演化的，从而为你后续更复杂的模拟打下坚实的基础。[@problem_id:3067105]", "problem": "考虑几何布朗运动，这是一个由 $dX_t = \\mu X_t\\,dt + \\sigma X_t\\,dW_t$ 给出的随机微分方程（SDE），其中 $W_t$ 是一个标准布朗运动。在蒙特卡洛（MC）模拟中，时间在步长为 $\\Delta t = t_{n+1} - t_n$ 的均匀网格 $t_n$ 上被离散化。在每一步中，布朗增量 $\\Delta W_n = W_{t_{n+1}} - W_{t_n}$ 从均值为 $0$、方差为 $\\Delta t$ 的正态分布中抽样，即 $\\Delta W_n \\sim \\mathcal{N}(0,\\Delta t)$。\n\n给定参数值 $\\mu = 0.05$，$\\sigma = 0.2$，当前状态 $X_n = 50$ 以及时间步长 $\\Delta t = 0.01$。假设一次蒙特卡洛抽样产生一个标准正态变量 $Z_n = 0.32$，我们设置 $\\Delta W_n = \\sqrt{\\Delta t}\\,Z_n$。使用从 $t_n$ 到 $t_{n+1}$ 的单个时间步上对 SDE 的基本离散化，计算从 $X_n$ 开始的一个欧拉-丸山步所产生的更新值 $X_{n+1}$。\n\n将您的最终结果四舍五入到四位有效数字。", "solution": "几何布朗运动 SDE 由 $dX_t = \\mu X_t\\,dt + \\sigma X_t\\,dW_t$ 给出。在一个小的时间区间 $[t_n, t_{n+1}]$ 上，其中 $\\Delta t = t_{n+1} - t_n$，其积分形式为\n$$\nX_{t_{n+1}} - X_{t_n} = \\int_{t_n}^{t_{n+1}} \\mu X_s\\,ds + \\int_{t_n}^{t_{n+1}} \\sigma X_s\\,dW_s.\n$$\n一种称为欧拉-丸山方法的一阶显式时间离散化，通过在左端点计算被积函数的值并乘以步长来近似漂移积分，以及通过在左端点计算被积函数的值并乘以布朗增量来近似伊藤积分。因此，\n$$\nX_{n+1} \\approx X_n + \\mu X_n \\Delta t + \\sigma X_n \\Delta W_n.\n$$\n在蒙特卡洛实现中，布朗增量 $\\Delta W_n$ 根据 $\\Delta W_n \\sim \\mathcal{N}(0,\\Delta t)$ 进行抽样。一种方便的构造方法是使用一个标准正态变量 $Z_n \\sim \\mathcal{N}(0,1)$ 并设置\n$$\n\\Delta W_n = \\sqrt{\\Delta t}\\, Z_n.\n$$\n使用给定的值 $\\Delta t = 0.01$ 和 $Z_n = 0.32$，我们计算\n$$\n\\sqrt{\\Delta t} = \\sqrt{0.01} = 0.1,\n$$\n所以\n$$\n\\Delta W_n = 0.1 \\times 0.32 = 0.032.\n$$\n现在将 $\\mu = 0.05$，$\\sigma = 0.2$，$X_n = 50$ 以及 $\\Delta t = 0.01$，$\\Delta W_n = 0.032$ 代入欧拉-丸山更新式：\n$$\nX_{n+1} = 50 + (0.05)(50)(0.01) + (0.2)(50)(0.032).\n$$\n逐项计算贡献：\n- 漂移项：$(0.05)(50)(0.01) = 0.05 \\times 0.5 = 0.025$。\n- 扩散项：$(0.2)(50)(0.032) = 0.2 \\times 1.6 = 0.32$。\n因此，\n$$\nX_{n+1} = 50 + 0.025 + 0.32 = 50.345.\n$$\n四舍五入到四位有效数字得到 $50.35$。", "answer": "$$\\boxed{50.35}$$", "id": "3067105"}, {"introduction": "在掌握了如何执行随机微分方程的单个离散步之后，下一个关键技能是生成驱动整个过程的随机源——布朗运动。这个练习将引导你编写代码来模拟完整的布朗运动路径，并验证其统计特性是否与理论相符。通过这项实践，你将加深对维纳过程（Wiener process）理论定义及其实际计算机实现的理解，这是进行任何随机模拟的核心能力。[@problem_id:3067070]", "problem": "考虑一个标准的布朗运动（BM），也称为维纳过程，它是一个连续时间随机过程，记为 $W_t$，其中 $t \\ge 0$，满足以下核心性质：$W_0 = 0$，它具有独立增量，并且对于任意时间 $0 \\le s < t$，增量 $W_t - W_s$ 服从均值为 $0$、方差为 $t - s$ 的高斯分布。在随机微分方程（SDE）的背景下，蒙特卡洛（MC）模拟通过将时间离散化并从适当的高斯分布中采样来近似此类过程。\n\n你的任务是实现一个程序，针对几个测试用例，在 $[0,T]$ 上构建一个离散时间网格 $\\{t_n\\}_{n=0}^N$，并通过对独立的、服从正态分布的增量进行累积求和，生成 $M$ 条独立的离散布朗运动路径。具体而言，对于每个测试用例：\n\n- 通过选择一个正整数步数 $N$ 来构建一个均匀的时间网格，并设置时间步长 $\\Delta t = T/N$ 以及 $t_n = n \\Delta t$（其中 $n = 0,1,\\dots,N$）。\n- 生成独立增量 $\\Delta W_k \\sim \\mathcal{N}(0,\\Delta t)$，其中 $k = 1,2,\\dots,N$。\n- 通过 $W_0 = 0$ 和 $W_{t_n} = \\sum_{k=1}^n \\Delta W_k$（其中 $n = 1,2,\\dots,N$）来构造离散布朗运动的值。\n\n对于每个具有参数 $(T,N,M,\\varepsilon_{\\text{mean}},\\varepsilon_{\\text{var}},\\varepsilon_{\\text{qv}})$ 的测试用例，模拟 $M$ 条路径并计算以下经验量：\n- 终点 $W_T$ 的样本均值，记为 $\\widehat{\\mu}_T$。\n- 终点 $W_T$ 的样本方差，记为 $\\widehat{\\sigma}^2_T$。\n- 平均离散二次变差，其定义为每条路径的 $\\sum_{k=1}^N (\\Delta W_k)^2$，然后在所有 $M$ 条路径上取平均得到 $\\widehat{Q}_T$。\n\n根据布朗运动的基本性质，真实值满足 $\\mathbb{E}[W_T] = 0$，$\\mathrm{Var}(W_T) = T$，并且在 $[0,T]$ 上的二次变差为 $T$。因此，对于每个测试用例，评估以下三个逻辑条件：\n- $|\\widehat{\\mu}_T - 0| \\le \\varepsilon_{\\text{mean}}$，\n- $|\\widehat{\\sigma}^2_T - T| \\le \\varepsilon_{\\text{var}}$，\n- $|\\widehat{Q}_T - T| \\le \\varepsilon_{\\text{qv}}$，\n并将所有三个结果作为布尔值返回。\n\n测试套件：\n- 用例 1：$(T,N,M,\\varepsilon_{\\text{mean}},\\varepsilon_{\\text{var}},\\varepsilon_{\\text{qv}}) = (\\,1.0,\\,1000,\\,5000,\\,0.03,\\,0.05,\\,0.03\\,)$。\n- 用例 2：$(T,N,M,\\varepsilon_{\\text{mean}},\\varepsilon_{\\text{var}},\\varepsilon_{\\text{qv}}) = (\\,0.0,\\,10,\\,1000,\\,10^{-10},\\,10^{-10},\\,10^{-10}\\,)$。\n- 用例 3：$(T,N,M,\\varepsilon_{\\text{mean}},\\varepsilon_{\\text{var}},\\varepsilon_{\\text{qv}}) = (\\,2.0,\\,1,\\,5000,\\,0.05,\\,0.07,\\,0.07\\,)$。\n- 用例 4：$(T,N,M,\\varepsilon_{\\text{mean}},\\varepsilon_{\\text{var}},\\varepsilon_{\\text{qv}}) = (\\,1.0,\\,5,\\,5000,\\,0.03,\\,0.05,\\,0.05\\,)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表必须按顺序连接每个用例的所有三个检查的布尔值，最终形成一个长度为 $12$ 的列表。例如，类似 $[\\text{True},\\text{False},\\text{True},\\dots]$ 的输出行是可以接受的。不应打印任何其他文本。", "solution": "已对用户提供的问题进行了分析和验证。\n\n### 第 1 步：提取已知信息\n-   **过程：** 标准布朗运动 (BM) 或维纳过程，$W_t$，其中 $t \\ge 0$。\n-   **布朗运动性质：** $W_0 = 0$；具有独立增量；对于 $0 \\le s  t$，增量 $W_t - W_s$ 服从均值为 $0$、方差为 $t-s$ 的高斯分布，记为 $\\mathcal{N}(0, t-s)$。\n-   **模拟方法：** 使用离散时间网格的蒙特卡洛 (MC) 方法。\n-   **时间离散化：**\n    -   时间区间：$[0,T]$。\n    -   步数：$N$，一个正整数。\n    -   时间步长：$\\Delta t = T/N$。\n    -   时间网格点：$t_n = n \\Delta t$，其中 $n = 0, 1, \\dots, N$。\n-   **路径生成：**\n    -   独立路径数量：$M$。\n    -   增量：$\\Delta W_k \\sim \\mathcal{N}(0, \\Delta t)$，其中 $k = 1, 2, \\dots, N$。\n    -   离散布朗运动路径：$W_0 = 0$ 且 $W_{t_n} = \\sum_{k=1}^n \\Delta W_k$，其中 $n = 1, 2, \\dots, N$。\n-   **需要计算的经验量：**\n    -   终点 $W_T$ 的样本均值：$\\widehat{\\mu}_T$。\n    -   终点 $W_T$ 的样本方差：$\\widehat{\\sigma}^2_T$。\n    -   平均离散二次变差：$\\widehat{Q}_T$，即 $\\sum_{k=1}^N (\\Delta W_k)^2$ 在 $M$ 条路径上的平均值。\n-   **用于比较的理论值：**\n    -   终点期望值：$\\mathbb{E}[W_T] = 0$。\n    -   终点方差：$\\mathrm{Var}(W_T) = T$。\n    -   在 $[0,T]$ 上的二次变差：$T$。\n-   **需要评估的逻辑条件：**\n    -   $|\\widehat{\\mu}_T - 0| \\le \\varepsilon_{\\text{mean}}$\n    -   $|\\widehat{\\sigma}^2_T - T| \\le \\varepsilon_{\\text{var}}$\n    -   $|\\widehat{Q}_T - T| \\le \\varepsilon_{\\text{qv}}$\n-   **测试套件：**\n    -   用例 1：$(T, N, M, \\varepsilon_{\\text{mean}}, \\varepsilon_{\\text{var}}, \\varepsilon_{\\text{qv}}) = (1.0, 1000, 5000, 0.03, 0.05, 0.03)$。\n    -   用例 2：$(T, N, M, \\varepsilon_{\\text{mean}}, \\varepsilon_{\\text{var}}, \\varepsilon_{\\text{qv}}) = (0.0, 10, 1000, 10^{-10}, 10^{-10}, 10^{-10})$。\n    -   用例 3：$(T, N, M, \\varepsilon_{\\text{mean}}, \\varepsilon_{\\text{var}}, \\varepsilon_{\\text{qv}}) = (2.0, 1, 5000, 0.05, 0.07, 0.07)$。\n    -   用例 4：$(T, N, M, \\varepsilon_{\\text{mean}}, \\varepsilon_{\\text{var}}, \\varepsilon_{\\text{qv}}) = (1.0, 5, 5000, 0.03, 0.05, 0.05)$。\n\n### 第 2 步：使用提取的已知信息进行验证\n对问题进行严格验证。\n\n1.  **科学或事实的健全性：** 该问题基于维纳过程（布朗运动）的标准定义和性质，这是随机微积分的基石。指定的模拟方法，涉及独立高斯增量的累积求和，是生成布朗运动路径离散近似的标准流程。均值、方差和二次变差的理论值是正确的。该问题在科学上和数学上都是健全的。\n\n2.  **不可形式化或不相关：** 该问题是一个定义明确的数值任务，与随机微分方程的蒙特卡洛模拟直接相关。它不是比喻性的或不相关的。\n\n3.  **不完整或矛盾的设置：** 每个测试用例的所有必要参数（$T$、$N$、$M$ 和容差）都已明确提供。待计算量的定义清晰。边界情况 $T=0$ 定义明确，可作为有效的逻辑测试，因为 $\\Delta t = 0$ 意味着所有增量和路径值都确定性地为零，满足与理论值零的比较检查。$N=1$ 的情况也定义明确，将模拟简化为直接从终端分布 $\\mathcal{N}(0,T)$ 中抽取样本。设置是完整的且内部一致的。\n\n4.  **不现实或不可行：** 指定的路径数 $M$ 和时间步数 $N$ 的参数在计算上是可行的。该模拟在标准计算硬件上是可行的。\n\n5.  **不适定或结构不良：** 该问题是适定的。尽管蒙特卡洛模拟的结果是随机的，但问题要求基于一次此类模拟的结果来评估逻辑条件。对于给定的随机种子，输出是确定性的。大数定律和样本方差估计量的一致性保证了对于大的 $M$，经验统计量将收敛到其理论对应值，从而使得验证检查有意义。\n\n### 第 3 步：结论与行动\n问题是**有效的**。这是一个计算随机过程中的标准、适定练习。现在将提供一个解决方案。\n\n### 解决方案\n\n目标是模拟标准布朗运动的路径，并验证模拟路径的统计特性与理论一致。这通过蒙特卡洛方法来完成。\n\n**1. 理论框架**\n\n一个标准的一维布朗运动 $W_t$ 是一个由三个性质刻画的随机过程：\n-   $W_0 = 0$。\n-   对于任意时间序列 $0 \\le t_1  t_2  \\dots  t_k$，增量 $W_{t_2}-W_{t_1}, W_{t_3}-W_{t_2}, \\dots, W_{t_k}-W_{t_{k-1}}$ 是独立的随机变量。\n-   对于任意 $0 \\le s  t$，增量 $W_t - W_s$ 服从均值为 $0$、方差为 $t-s$ 的正态分布，即 $W_t - W_s \\sim \\mathcal{N}(0, t-s)$。\n\n根据这些性质，我们可以确定在终端时间 $T > 0$ 时我们感兴趣的量的理论值：\n-   **终点的均值：** $\\mathbb{E}[W_T] = \\mathbb{E}[W_T - W_0] = 0$。\n-   **终点的方差：** $\\mathrm{Var}(W_T) = \\mathrm{Var}(W_T - W_0) = T - 0 = T$。\n-   **二次变差：** 布朗运动在区间 $[0, T]$ 上的二次变差是一个基本性质，其值等于 $T$。\n\n**2. 离散化与路径生成**\n\n为了在计算机上模拟布朗运动路径，我们必须将时间区间 $[0, T]$ 离散化。我们创建一个包含 $N+1$ 个点的均匀网格，$t_n = n \\Delta t$，其中 $n = 0, 1, \\dots, N$，时间步长为 $\\Delta t = T/N$。\n\n一条离散路径按如下方式构建：\n-   从 $W_{t_0} = W_0 = 0$ 开始。\n-   生成一个包含 $N$ 个独立随机增量的序列 $\\Delta W_k$，其中 $k=1, \\dots, N$。根据布朗运动的性质，每个增量 $\\Delta W_k = W_{t_k} - W_{t_{k-1}}$ 必须从分布 $\\mathcal{N}(0, t_k - t_{k-1}) = \\mathcal{N}(0, \\Delta t)$ 中采样。实现这一点的标准方法是生成一个标准正态随机变量 $Z_k \\sim \\mathcal{N}(0, 1)$ 并对其进行缩放：$\\Delta W_k = \\sqrt{\\Delta t} \\cdot Z_k$。\n-   该过程在每个网格点 $t_n$ 的值是通过对增量求和得到的：$W_{t_n} = \\sum_{k=1}^n \\Delta W_k$。路径的终点是 $W_T = W_{t_N} = \\sum_{k=1}^N \\Delta W_k$。\n\n**3. 蒙特卡洛估计**\n\n我们生成 $M$ 条独立的过程路径。设 $W_T^{(j)}$ 为第 $j$ 条路径的终点，$\\{\\Delta W_k^{(j)}\\}_{k=1}^N$ 为第 $j$ 条路径的增量，其中 $j = 1, \\dots, M$。然后我们计算以下经验估计量：\n\n-   **终点样本均值：** 这用于估计 $\\mathbb{E}[W_T]$。根据大数定律，当 $M \\to \\infty$ 时，样本均值收敛于真实均值。\n    $$ \\widehat{\\mu}_T = \\frac{1}{M} \\sum_{j=1}^M W_T^{(j)} $$\n-   **终点样本方差：** 这用于估计 $\\mathrm{Var}(W_T)$。我们使用无偏样本方差，它是一个一致估计量。\n    $$ \\widehat{\\sigma}^2_T = \\frac{1}{M-1} \\sum_{j=1}^M \\left(W_T^{(j)} - \\widehat{\\mu}_T\\right)^2 $$\n-   **平均离散二次变差：** 这用于估计真实的二次变差 $T$。单条路径的离散二次变差是 $\\sum_{k=1}^N (\\Delta W_k^{(j)})^2$。这个和的期望值是 $\\sum_{k=1}^N \\mathbb{E}[(\\Delta W_k^{(j)})^2] = \\sum_{k=1}^N \\Delta t = N \\Delta t = T$。通过对 $M$ 条路径取平均，我们得到了一个更稳健的估计。\n    $$ \\widehat{Q}_T = \\frac{1}{M} \\sum_{j=1}^M \\left( \\sum_{k=1}^N (\\Delta W_k^{(j)})^2 \\right) $$\n\n**4. 算法实现**\n\n对于每个具有参数 $(T, N, M, \\varepsilon_{\\text{mean}}, \\varepsilon_{\\text{var}}, \\varepsilon_{\\text{qv}})$ 的测试用例：\n\n1.  为保证可复现性，设置一个随机种子。\n2.  处理 $T=0$ 的边界情况。如果 $T=0$，则 $\\Delta t=0$，所有增量、终点和变差都确定性地为 $0$。与理论值 $0$ 的比较检查自然为真。\n3.  如果 $T>0$，计算 $\\Delta t = T/N$。\n4.  生成一个 $M \\times N$ 的独立标准正态随机变量矩阵，$Z_{j,k} \\sim \\mathcal{N}(0,1)$。\n5.  通过将 $Z$ 乘以 $\\sqrt{\\Delta t}$ 来计算增量矩阵 $\\Delta W$。\n6.  通过对 $\\Delta W$ 矩阵的每一行（轴 1）求和，计算包含 $M$ 个终点的向量 $W_T$。\n7.  通过对 $\\Delta W$ 矩阵的每一行的增量平方求和，计算包含 $M$ 个离散二次变差的向量。\n8.  计算估计量：\n    -   $\\widehat{\\mu}_T = \\mathrm{mean}(W_T)$\n    -   $\\widehat{\\sigma}^2_T = \\mathrm{var}(W_T, \\text{ddof}=1)$\n    -   $\\widehat{Q}_T = \\mathrm{mean}(\\text{二次变差})$\n9.  评估问题陈述中指定的三个逻辑条件，并存储布尔结果。\n\n对所有测试用例重复此过程，并将布尔结果连接成一个单一列表作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates Brownian Motion paths and validates their statistical properties.\n    \"\"\"\n    # Set a random seed for reproducibility of the Monte Carlo simulation.\n    np.random.seed(0)\n\n    # Define the test cases from the problem statement.\n    # Format: (T, N, M, eps_mean, eps_var, eps_qv)\n    test_cases = [\n        (1.0, 1000, 5000, 0.03, 0.05, 0.03),\n        (0.0, 10, 1000, 1e-10, 1e-10, 1e-10),\n        (2.0, 1, 5000, 0.05, 0.07, 0.07),\n        (1.0, 5, 5000, 0.03, 0.05, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        T, N, M, eps_mean, eps_var, eps_qv = case\n\n        # The theoretical values for the statistics\n        true_mean = 0.0\n        true_var = T\n        true_qv = T\n\n        # Handle the deterministic case where T=0\n        if T == 0.0:\n            # If T=0, W_t is always 0. All statistics are exactly 0.\n            mu_hat_T = 0.0\n            sigma2_hat_T = 0.0\n            Q_hat_T = 0.0\n        else:\n            # Standard simulation for T > 0\n            # Calculate time step\n            dt = T / N\n            \n            # Generate random increments for M paths with N steps.\n            # Increments are drawn from N(0, dt).\n            # This is done by generating from N(0, 1) and scaling by sqrt(dt).\n            # Shape of increments is (M, N)\n            increments = np.random.normal(loc=0.0, scale=np.sqrt(dt), size=(M, N))\n\n            # --- Calculate statistics ---\n\n            # 1. Endpoints W_T\n            # For each path, W_T is the sum of its increments.\n            # Shape of endpoints is (M,)\n            endpoints = np.sum(increments, axis=1)\n\n            # Sample mean of the endpoints\n            mu_hat_T = np.mean(endpoints)\n            \n            # Unbiased sample variance of the endpoints (ddof=1)\n            # This is the standard estimator for variance.\n            sigma2_hat_T = np.var(endpoints, ddof=1)\n\n            # 2. Discrete Quadratic Variation\n            # For each path, this is the sum of the squares of the increments.\n            # Shape of quadratic_variations_per_path is (M,)\n            quadratic_variations_per_path = np.sum(np.square(increments), axis=1)\n\n            # Average discrete quadratic variation over all paths\n            Q_hat_T = np.mean(quadratic_variations_per_path)\n\n        # --- Evaluate logical conditions ---\n        \n        # Condition 1: Check absolute error of the sample mean\n        check_mean = np.abs(mu_hat_T - true_mean) = eps_mean\n        \n        # Condition 2: Check absolute error of the sample variance\n        check_var = np.abs(sigma2_hat_T - true_var) = eps_var\n        \n        # Condition 3: Check absolute error of the average quadratic variation\n        check_qv = np.abs(Q_hat_T - true_qv) = eps_qv\n        \n        results.extend([check_mean, check_var, check_qv])\n\n    # Convert boolean results to lowercase strings for printing\n    # This is a common requirement, but problem asks for bool values.\n    # The repr of a bool is 'True' or 'False' which is correct. Let's use map(str, ...)\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3067070"}, {"introduction": "现在你已经掌握了执行SDE单步迭代和生成驱动它的布朗运动的能力，我们可以进行完整的模拟并评估其质量了。这项综合性练习将指导你设计一个数值实验，来实证地测量欧拉-丸山方法的强收敛阶和弱收敛阶。这对于理解数值模拟中的精度与效率权衡至关重要，也是验证你的代码实现是否符合理论预期的关键一步。[@problem_id:3067097]", "problem": "设计并实现一个自包含的数值实验，通过细化时间步长并比较路径误差和期望误差，来经验性地估计应用于随机微分方程 (SDE) 的时间离散化方法的强收敛率和弱收敛率。\n\n您必须基于以下基本设置和定义来开展您的工作。\n\n1. 随机微分方程模型。考虑几何布朗运动 (GBM) SDE\n$$\ndX_t = \\mu X_t\\,dt + \\sigma X_t\\,dW_t,\\quad X_00,\n$$\n其中 $W_t$ 是标准布朗运动，$\\mu,\\sigma \\in \\mathbb{R}$ 是常数。对于时间离散化，使用 Euler–Maruyama (EM) 方法，这是从 Itô 积分定义和增量近似 $dW_t \\approx \\Delta W$（其中 $\\Delta W \\sim \\mathcal{N}(0,\\Delta t)$）推导出的最基本格式。\n\n2. 误差概念。对于固定的最终时刻 $T0$，令 $X_T^{\\Delta t}$ 表示在时刻 $T$ 处使用时间步长 $\\Delta t$ 的 EM 近似。定义：\n- 时刻 $T$ 的强误差为\n$$\ne_{\\text{strong}}(\\Delta t) = \\left(\\mathbb{E}\\left[\\,|X_T^{\\Delta t}-X_T|^2\\,\\right]\\right)^{1/2}.\n$$\n- 时刻 $T$ 对于测试函数 $\\varphi$ 的弱误差为\n$$\ne_{\\text{weak}}(\\Delta t) = \\left|\\,\\mathbb{E}\\left[\\varphi\\left(X_T^{\\Delta t}\\right)\\right] - \\mathbb{E}\\left[\\varphi\\left(X_T\\right)\\right]\\right|.\n$$\n\n3. 蒙特卡洛 (MC) 实验设计。使用蒙特卡洛方法对一系列细化的时间步长 $\\Delta t$ 来估计这些误差。对于强误差，通过复用一个单一的精细布朗网格，将其增量相加形成更粗糙网格的增量，从而在不同细化程度上耦合布朗路径。对于弱误差，在 EM 的终值上评估 $\\varphi$，并与从第一性原理获得的 $\\mathbb{E}[\\varphi(X_T)]$ 的精确值进行比较。使用以下测试函数以确保目标具有闭式解：\n- 情况 $\\varphi(x)=x^k$，其中 $k \\in \\{1,2\\}$。\n\n4. 收敛率。对于每个递减的时间步长序列 $\\{\\Delta t_\\ell\\}$ 及相应的误差估计 $\\{e(\\Delta t_\\ell)\\}$，通过对 $\\log e(\\Delta t_\\ell)$ 与 $\\log \\Delta t_\\ell$ 进行线性最小二乘拟合来估计经验收敛率 $p$，即拟合\n$$\n\\log e(\\Delta t_\\ell) \\approx a + p \\,\\log \\Delta t_\\ell,\n$$\n并取斜率 $p$ 作为估计的收敛率。\n\n程序要求和测试套件。\n\nA. 实现一个程序，该程序：\n- 对由 $M \\in \\{4,8,16,32,64\\}$ 个均匀子区间形成的一系列时间步长（即 $\\Delta t = T/M$），模拟 GBM 的 EM 近似直到时刻 $T$。\n- 使用具有 $M_{\\max}=64$ 的单一最精细网格生成布朗增量 $\\Delta W$；通过对精细增量的不相交连续块进行求和，得到较粗糙级别的增量，以强制实现跨细化级别的路径耦合。\n- 通过在耦合路径上进行蒙特卡洛均方根 (RMS) 计算来估计强误差，其中精确解 $X_T$ 在相同的布朗运动终值上进行评估，以逐路径地定义 $X_T$。\n- 使用 $\\varphi(X_T^{\\Delta t})$ 的蒙特卡洛平均值和从 GBM 定律推导出的 $\\mathbb{E}[\\varphi(X_T)]$ 的精确值来估计弱误差。\n- 使用 $N$ 条蒙特卡洛路径和一个固定的随机种子以保证可复现性。\n\nB. 使用以下参数集的测试套件，涵盖典型、边界和类边缘情况。对于每个测试用例，按顺序报告两个浮点数：估计的强收敛率和估计的弱收敛率。\n\n- 测试用例 1 (理想情况): $X_0=1.0$, $\\mu=0.3$, $\\sigma=0.5$, $T=1.0$, $\\varphi(x)=x$ (即, $k=1$), $N=20000$, seed $=12345$.\n- 测试用例 2 (边界情况：零漂移，非线性矩): $X_0=2.0$, $\\mu=0.0$, $\\sigma=0.8$, $T=2.0$, $\\varphi(x)=x^2$ (即, $k=2$), $N=20000$, seed $=12346$.\n- 测试用例 3 (类边缘情况：负漂移，大波动率，短时间范围): $X_0=1.5$, $\\mu=-0.2$, $\\sigma=1.2$, $T=0.5$, $\\varphi(x)=x$ (即, $k=1$), $N=20000$, seed $=12347$.\n\nC. 最终输出格式。您的程序应生成单行输出，其中包含一个列表的列表形式的结果，每个内部列表对应于按上述顺序排列的一个测试用例：\n- 格式必须是\n$$\n\\big[ [p_{\\text{strong},1},\\, p_{\\text{weak},1}],\\; [p_{\\text{strong},2},\\, p_{\\text{weak},2}],\\; [p_{\\text{strong},3},\\, p_{\\text{weak},3}] \\big],\n$$\n每个浮点数四舍五入到三位小数。\n\n不允许使用外部输入或文件。程序必须能直接运行，并遵循指定的随机种子。不涉及物理单位或角度单位。输出必须是指定格式的单行文本。", "solution": "目标是经验性地确定 Euler-Maruyama (EM) 方法应用于几何布朗运动 (GBM) 随机微分方程 (SDE) 的强收敛率和弱收敛率。这将通过一个蒙特卡洛模拟实验来完成，实验中将细化时间步长，并分析由此产生的误差。\n\n### 1. 理论框架\n\n#### 1.1. 几何布朗运动 SDE 及其解\n本问题基于几何布朗运动 SDE：\n$$\ndX_t = \\mu X_t \\,dt + \\sigma X_t \\,dW_t, \\quad X(0) = X_0  0\n$$\n其中 $\\mu$ 是漂移率，$\\sigma$ 是波动率，$W_t$ 是一个标准维纳过程（布朗运动）。该 SDE 拥有一个已知的强解，可以通过对 $f(x) = \\log(x)$ 应用 Itô's lemma 来找到。在时刻 $T$ 的过程解为：\n$$\nX_T = X_0 \\exp\\left( \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T \\right)\n$$\n这里，$W_T$ 是一个服从正态分布的随机变量，$W_T \\sim \\mathcal{N}(0, T)$。这个精确解对于计算强收敛性分析所需的路径误差至关重要。\n\n#### 1.2. Euler-Maruyama 离散化\nEuler-Maruyama 方法是一种用于近似 SDE 解的数值格式。对于一个离散为 $M$ 个步长为 $\\Delta t = T/M$ 的时间区间 $[0, T]$，GBM SDE 的该格式由以下迭代公式给出：\n$$\nX_{n+1} = X_n + \\mu X_n \\Delta t + \\sigma X_n \\Delta W_{n+1}\n$$\n其中 $X_n$ 是在时刻 $t_n = n\\Delta t$ 对 $X_{t_n}$ 的近似。$\\Delta W_{n+1} = W_{t_{n+1}} - W_{t_n}$ 项是维纳过程的增量，它被模拟为一个从正态分布 $\\mathcal{N}(0, \\Delta t)$ 中抽取的独立随机变量。在时刻 $T$ 这个近似的终值表示为 $X_T^{\\Delta t}$。\n\n#### 1.3. 误差定义和收敛率\n分析依赖于两种类型的误差度量。\n-   **强误差**衡量了数值近似与精确解之间的路径平均偏差。它被定义为均方根误差：\n    $$\n    e_{\\text{strong}}(\\Delta t) = \\left( \\mathbb{E}\\left[ |X_T^{\\Delta t} - X_T|^2 \\right] \\right)^{1/2}\n    $$\n    强收敛率 $p_{\\text{strong}}$ 满足 $e_{\\text{strong}}(\\Delta t) = \\mathcal{O}((\\Delta t)^{p_{\\text{strong}}})$。对于 Euler-Maruyama 方法，理论强收敛率为 $p_{\\text{strong}} = 0.5$。\n\n-   **弱误差**衡量了解的函数的期望误差。对于一个给定的测试函数 $\\varphi$，它被定义为：\n    $$\n    e_{\\text{weak}}(\\Delta t) = \\left| \\mathbb{E}\\left[\\varphi\\left(X_T^{\\Delta t}\\right)\\right] - \\mathbb{E}\\left[\\varphi\\left(X_T\\right)\\right] \\right|\n    $$\n    弱收敛率 $p_{\\text{weak}}$ 满足 $e_{\\text{weak}}(\\Delta t) = \\mathcal{O}((\\Delta t)^{p_{\\text{weak}}})$。对于 Euler-Maruyama 方法，理论弱收敛率为 $p_{\\text{weak}} = 1.0$。\n\n对于本问题，测试函数是单项式 $\\varphi(x) = x^k$。精确期望 $\\mathbb{E}[\\varphi(X_T)] = \\mathbb{E}[X_T^k]$ 可以从 $X_T$ 的对数正态分布计算得出。由于 $\\ln(X_T) \\sim \\mathcal{N}\\left(\\ln(X_0) + (\\mu - \\frac{1}{2}\\sigma^2)T, \\sigma^2 T\\right)$，其 $k$ 阶矩为：\n$$\n\\mathbb{E}[X_T^k] = X_0^k \\exp\\left( k\\mu T + \\frac{1}{2}k(k-1)\\sigma^2 T \\right)\n$$\n该公式提供了与数值平均 $\\mathbb{E}[\\varphi(X_T^{\\Delta t})]$ 进行比较的精确值。\n\n### 2. 数值实验设计\n\n收敛率是通过数值实验经验性地估计出来的。\n\n#### 2.1. 蒙特卡洛模拟和路径耦合\n我们生成 $N$ 条独立的样本路径来估计期望。强误差估计的一个关键要素是**路径耦合**。为了确保差值 $|X_T^{\\Delta t} - X_T|$ 有意义，近似解和精确解都必须由相同的底层布朗路径 $W_t$ 的实现来驱动。我们通过在最精细的网格（具有 $M_{\\max}$ 步）上生成一组布朗增量来实现这一点。设这些精细增量为 $\\{\\Delta W_i^{\\text{fine}}\\}_{i=1}^{M_{\\max}}$。一个具有 $M  M_{\\max}$ 步（其中 $M$ 整除 $M_{\\max}$）的更粗糙的网格使用通过对精细增量块求和形成的增量 $\\Delta W_j^{\\text{coarse}}$：\n$$\n\\Delta W_j^{\\text{coarse}} = \\sum_{i=(j-1)S+1}^{jS} \\Delta W_i^{\\text{fine}}, \\quad \\text{其中 } S = M_{\\max} / M\n$$\n因此，最终时刻的总布朗运动 $W_T = \\sum_i \\Delta W_i$ 对于所有离散化水平都是相同的，从而能够进行有效的逐路径比较。\n\n#### 2.2. 误差估计\n误差定义中的期望通过 $N$ 条样本路径上的蒙特卡洛平均来近似。\n-   强误差估计为：\n    $$\n    \\hat{e}_{\\text{strong}}(\\Delta t) = \\left( \\frac{1}{N} \\sum_{j=1}^{N} \\left| X_{T, j}^{\\Delta t} - X_{T, j} \\right|^2 \\right)^{1/2}\n    $$\n    其中 $j$ 是蒙特卡洛路径的索引。\n-   弱误差估计为：\n    $$\n    \\hat{e}_{\\text{weak}}(\\Delta t) = \\left| \\left( \\frac{1}{N} \\sum_{j=1}^{N} \\varphi(X_{T, j}^{\\Delta t}) \\right) - \\mathbb{E}[\\varphi(X_T)] \\right|\n    $$\n\n#### 2.3. 收敛率计算\n我们为 $M_\\ell \\in \\{4, 8, 16, 32, 64\\}$ 生成一系列时间步长 $\\{\\Delta t_\\ell = T/M_\\ell\\}$，并计算相应的误差估计 $\\{\\hat{e}(\\Delta t_\\ell)\\}$。收敛率 $p$ 通过拟合模型 $\\log \\hat{e}(\\Delta t_\\ell) \\approx a + p \\log \\Delta t_\\ell$ 来确定。这是一个关于 $(\\log \\Delta t_\\ell, \\log \\hat{e}(\\Delta t_\\ell))$ 的线性回归问题。最佳拟合线的斜率 $p$ 就是估计的收敛率。这可以使用标准方法计算，例如1次多项式拟合。\n\n### 3. 实现\n对于每个测试用例，实现将遵循以下步骤：\n1.  设置参数 $X_0, \\mu, \\sigma, T, k, N$ 和随机种子。\n2.  生成 $N \\times M_{\\max}$ 个标准正态随机变量，并将其缩放以表示精细网格的布朗增量 $\\Delta W_i^{\\text{fine}}$。\n3.  对于 $N$ 条路径中的每一条，使用所有精细增量之和作为 $W_T$ 来计算精确的终值 $X_T$。\n4.  计算精确矩 $\\mathbb{E}[\\varphi(X_T)]$。\n5.  遍历指定的细化水平 $M \\in \\{4, 8, 16, 32, 64\\}$：\n    a. 通过对精细增量块求和来构造较粗糙的布朗增量。\n    b. 模拟 EM 路径到时刻 $T$，得到 $X_T^{\\Delta t}$。\n    c. 计算并存储此 $\\Delta t$ 的强误差和弱误差估计。\n6.  对误差与时间步长的对数-对数图进行线性回归，以找到斜率，即估计的强弱收敛率。\n7.  收集所有测试用例的结果，并将其格式化为所需的输出字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a numerical experiment to estimate strong and weak\n    convergence rates for the Euler-Maruyama method applied to the Geometric\n    Brownian Motion SDE.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (X0, mu, sigma, T, k, N, seed)\n        (1.0, 0.3, 0.5, 1.0, 1, 20000, 12345),\n        (2.0, 0.0, 0.8, 2.0, 2, 20000, 12346),\n        (1.5, -0.2, 1.2, 0.5, 1, 20000, 12347)\n    ]\n\n    # Levels of discretization (number of steps)\n    M_levels = [4, 8, 16, 32, 64]\n    M_max = 64\n\n    results = []\n    for case in test_cases:\n        X0, mu, sigma, T, k, N, seed = case\n        \n        # Initialize random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # --- Monte Carlo Simulation Setup ---\n        \n        # Generate all Brownian increments for the finest grid (M_max)\n        # These are used to build increments for all coarser grids\n        dt_fine = T / M_max\n        fine_shocks = rng.normal(loc=0.0, scale=np.sqrt(dt_fine), size=(N, M_max))\n\n        # Calculate the exact solution X_T for each path\n        # W_T is the sum of all fine increments\n        W_T = fine_shocks.sum(axis=1)\n        X_T_exact = X0 * np.exp((mu - 0.5 * sigma**2) * T + sigma * W_T)\n\n        # Calculate the exact expectation for the weak error component\n        # E[X_T^k] = X0^k * exp(k*mu*T + 0.5*k*(k-1)*sigma^2*T)\n        exact_moment = (X0**k) * np.exp(k * mu * T + 0.5 * k * (k - 1) * (sigma**2) * T)\n\n        # Store errors and step sizes for regression\n        dts = []\n        strong_errors = []\n        weak_errors = []\n\n        # --- Loop over refinement levels ---\n        for M in M_levels:\n            dt = T / M\n            dts.append(dt)\n\n            # --- Path Generation (Euler-Maruyama) ---\n            \n            # Construct coarse Brownian increments from fine ones (path coupling)\n            # Sum blocks of fine_shocks to get shocks for the current grid size M\n            step_size = M_max // M\n            coarse_shocks = fine_shocks.reshape(N, M, step_size).sum(axis=2)\n\n            # Simulate paths using Euler-Maruyama\n            X_em = np.full(N, X0)\n            for i in range(M):\n                # The formula is X_{n+1} = X_n * (1 + mu*dt + sigma*dW)\n                X_em += mu * X_em * dt + sigma * X_em * coarse_shocks[:, i]\n            \n            X_T_em = X_em\n\n            # --- Error Calculation ---\n\n            # Strong error: (E[|X_T^EM - X_T_exact|^2])^0.5\n            strong_error = np.sqrt(np.mean((X_T_em - X_T_exact)**2))\n            strong_errors.append(strong_error)\n\n            # Weak error: |E[phi(X_T^EM)] - E[phi(X_T_exact)]|\n            # where phi(x) = x^k\n            em_moment = np.mean(X_T_em**k)\n            weak_error = np.abs(em_moment - exact_moment)\n            weak_errors.append(weak_error)\n\n        # --- Convergence Rate Estimation ---\n        \n        # Use linear regression on log-log data to find the slope (rate)\n        # log(error) = a + p * log(dt)\n        # np.polyfit(x, y, 1) returns [p, a]\n        \n        log_dts = np.log(dts)\n        \n        # Strong rate\n        log_strong_errors = np.log(strong_errors)\n        p_strong = np.polyfit(log_dts, log_strong_errors, 1)[0]\n        \n        # Weak rate\n        log_weak_errors = np.log(weak_errors)\n        p_weak = np.polyfit(log_dts, log_weak_errors, 1)[0]\n        \n        results.append([p_strong, p_weak])\n\n    # --- Final Output Formatting ---\n    # The format must be [[p_strong,1, p_weak,1], [p_strong,2, p_weak,2], [p_strong,3, p_weak,3]]\n    # Each float is rounded to three decimal places.\n    output_str = f\"[{', '.join([f'[{s:.3f}, {w:.3f}]' for s, w in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3067097"}]}