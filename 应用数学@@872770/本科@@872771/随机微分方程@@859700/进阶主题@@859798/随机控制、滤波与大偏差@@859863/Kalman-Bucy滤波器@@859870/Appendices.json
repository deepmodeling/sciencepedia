{"hands_on_practices": [{"introduction": "理论的掌握始于对其最基本形式的深刻理解。在处理复杂的多维卡尔曼-布西滤波器之前，通过一个简化的标量系统来推导其核心方程，是建立直观认识和数学基础的绝佳途径。本练习将引导你从第一性原理出发，为最简单的非平凡情况推导并求解著名的里卡蒂微分方程，从而揭示滤波器误差方差的动态演化过程及其与系统参数的内在联系。[@problem_id:3080944]", "problem": "考虑由独立标准布朗运动驱动的标量、线性、时不变连续时间模型，\n$$\n\\mathrm{d}x_t = a\\,x_t\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t,\\qquad\n\\mathrm{d}y_t = c\\,x_t\\,\\mathrm{d}t + \\sqrt{r}\\,\\mathrm{d}V_t,\n$$\n其中 $a\\in\\mathbb{R}$，$c\\in\\mathbb{R}$，$q\\ge 0$，$r>0$ 是给定常数，$W_t$ 和 $V_t$ 是独立的标准维纳过程。令 $\\hat{x}_t$ 表示由卡尔曼-布西滤波器（KBF）产生的估计值，并定义估计误差 $e_t = x_t - \\hat{x}_t$ 及其误差方差 $P_t = \\mathbb{E}[e_t^2]$。假设初始方差 $P_0 \\ge 0$。\n\n从随机微分方程（SDE）模型和 $e_t$ 的定义出发，根据第一性原理（不引用现成的滤波器公式）推导控制卡尔曼-布西滤波器中 $P_t$ 的常微分方程（ODE）。然后，在初始条件 $P_0$ 下，显式求解这个标量 ODE 得到 $P_t$。接下来，确定在何种关于 $a$, $c$, $q$, $r$ 和 $P_0$ 的精确条件下，$P_t$ 会收敛到一个有限的稳态值 $P_{\\infty} = \\lim_{t\\to\\infty} P_t$，并给出 $P_{\\infty}$ 的闭式表达式。\n\n最后，对于数值 $a=0.4$, $c=1.5$, $q=0.2$, $r=0.5$ 和 $P_0=1.0$，数值计算稳态值 $P_{\\infty}$。将答案四舍五入到四位有效数字。最终答案无需单位。", "solution": "该问题要求推导标量卡尔曼-布西滤波器的方差动态，求解所得的微分方程，确定稳态收敛的条件，并对稳态方差进行数值计算。\n\n该过程从给定的线性时不变系统开始：\n状态方程：\n$$\n\\mathrm{d}x_t = a\\,x_t\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t\n$$\n测量方程：\n$$\n\\mathrm{d}y_t = c\\,x_t\\,\\mathrm{d}t + \\sqrt{r}\\,\\mathrm{d}V_t\n$$\n其中 $a, c, q, r$ 是常数，满足 $q \\ge 0$ 和 $r>0$，$W_t, V_t$ 是独立的标准维纳过程。\n\n卡尔曼-布西滤波器提供状态 $x_t$ 的最优估计 $\\hat{x}_t$。该系统的滤波器形式如下：\n$$\n\\mathrm{d}\\hat{x}_t = a\\,\\hat{x}_t\\,\\mathrm{d}t + K_t(\\mathrm{d}y_t - c\\,\\hat{x}_t\\,\\mathrm{d}t)\n$$\n其中 $K_t$ 是我们将要确定的卡尔曼增益。项 $\\mathrm{d}y_t - c\\,\\hat{x}_t\\,\\mathrm{d}t$ 是新息过程。\n\n**1. 误差方差 $P_t$ 的 ODE 推导**\n\n估计误差定义为 $e_t = x_t - \\hat{x}_t$。我们通过取其微分来推导其 SDE：$\\mathrm{d}e_t = \\mathrm{d}x_t - \\mathrm{d}\\hat{x}_t$。\n代入 $\\mathrm{d}x_t$ 和 $\\mathrm{d}\\hat{x}_t$ 的表达式：\n$$\n\\mathrm{d}e_t = (a\\,x_t\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t) - \\left( a\\,\\hat{x}_t\\,\\mathrm{d}t + K_t(\\mathrm{d}y_t - c\\,\\hat{x}_t\\,\\mathrm{d}t) \\right)\n$$\n现在，将 $\\mathrm{d}y_t = c\\,x_t\\,\\mathrm{d}t + \\sqrt{r}\\,\\mathrm{d}V_t$ 代入方程：\n$$\n\\mathrm{d}e_t = a\\,(x_t - \\hat{x}_t)\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t - K_t(c\\,x_t\\,\\mathrm{d}t + \\sqrt{r}\\,\\mathrm{d}V_t - c\\,\\hat{x}_t\\,\\mathrm{d}t)\n$$\n按 $e_t = x_t - \\hat{x}_t$ 合并项：\n$$\n\\mathrm{d}e_t = a\\,e_t\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t - K_t(c\\,(x_t - \\hat{x}_t)\\,\\mathrm{d}t + \\sqrt{r}\\,\\mathrm{d}V_t)\n$$\n$$\n\\mathrm{d}e_t = (a - K_t c)\\,e_t\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t - K_t\\sqrt{r}\\,\\mathrm{d}V_t\n$$\n误差方差为 $P_t = \\mathbb{E}[e_t^2]$。为了找到其动态方程，我们将伊藤引理应用于函数 $f(e_t) = e_t^2$。\n$$\n\\mathrm{d}(e_t^2) = 2\\,e_t\\,\\mathrm{d}e_t + (\\mathrm{d}e_t)^2\n$$\n二次变分项 $(\\mathrm{d}e_t)^2$ 是根据 $\\mathrm{d}e_t$ 的随机部分计算的：\n$$\n(\\mathrm{d}e_t)^2 = (\\sqrt{q}\\,\\mathrm{d}W_t - K_t\\sqrt{r}\\,\\mathrm{d}V_t)^2 = q(\\mathrm{d}W_t)^2 + (K_t\\sqrt{r})^2(\\mathrm{d}V_t)^2 - 2\\sqrt{q}K_t\\sqrt{r}\\,\\mathrm{d}W_t\\mathrm{d}V_t\n$$\n由于 $W_t$ 和 $V_t$ 是独立的，我们有 $(\\mathrm{d}W_t)^2 = \\mathrm{d}t$，$(\\mathrm{d}V_t)^2 = \\mathrm{d}t$ 和 $\\mathrm{d}W_t\\mathrm{d}V_t = 0$。\n$$\n(\\mathrm{d}e_t)^2 = (q + K_t^2 r)\\,\\mathrm{d}t\n$$\n将 $\\mathrm{d}e_t$ 和 $(\\mathrm{d}e_t)^2$ 代入 $\\mathrm{d}(e_t^2)$ 的表达式中：\n$$\n\\mathrm{d}(e_t^2) = 2\\,e_t \\left( (a - K_t c)\\,e_t\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t - K_t\\sqrt{r}\\,\\mathrm{d}V_t \\right) + (q + K_t^2 r)\\,\\mathrm{d}t\n$$\n$$\n\\mathrm{d}(e_t^2) = 2(a - K_t c)\\,e_t^2\\,\\mathrm{d}t + (q + K_t^2 r)\\,\\mathrm{d}t + 2\\sqrt{q}\\,e_t\\,\\mathrm{d}W_t - 2K_t\\sqrt{r}\\,e_t\\,\\mathrm{d}V_t\n$$\n为了得到 $P_t = \\mathbb{E}[e_t^2]$ 的 ODE，我们对两边取期望。随机积分项（鞅）的期望为零。\n$$\n\\mathrm{d}P_t = \\mathrm{d}\\mathbb{E}[e_t^2] = \\mathbb{E}[\\mathrm{d}(e_t^2)] = \\mathbb{E}[2(a - K_t c)\\,e_t^2\\,\\mathrm{d}t + (q + K_t^2 r)\\,\\mathrm{d}t]\n$$\n$$\n\\frac{\\mathrm{d}P_t}{\\mathrm{d}t} = 2(a - K_t c)\\,\\mathbb{E}[e_t^2] + q + K_t^2 r = 2(a - K_t c)\\,P_t + q + K_t^2 r\n$$\n卡尔曼-布西滤波器增益 $K_t$ 的选择是为了最小化误差方差 $P_t$。这通过在每一时刻最小化变化率 $\\frac{\\mathrm{d}P_t}{\\mathrm{d}t}$ 来实现。我们将右侧视为 $K_t$ 的函数，并通过将其导数设为零来找到最小值：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}K_t} \\left( 2(a - K_t c)\\,P_t + q + K_t^2 r \\right) = -2c\\,P_t + 2r\\,K_t = 0\n$$\n这给出了最优卡尔曼增益：\n$$\nK_t = \\frac{c\\,P_t}{r}\n$$\n将这个最优增益代回 $P_t$ 的 ODE：\n$$\n\\frac{\\mathrm{d}P_t}{\\mathrm{d}t} = 2\\left(a - \\frac{c\\,P_t}{r} c\\right)P_t + q + \\left(\\frac{c\\,P_t}{r}\\right)^2 r\n$$\n$$\n\\frac{\\mathrm{d}P_t}{\\mathrm{d}t} = 2a\\,P_t - \\frac{2c^2}{r}P_t^2 + q + \\frac{c^2 P_t^2}{r}\n$$\n这可以简化为连续时间标量里卡蒂微分方程：\n$$\n\\frac{\\mathrm{d}P_t}{\\mathrm{d}t} = -\\frac{c^2}{r}P_t^2 + 2a\\,P_t + q\n$$\n\n**2. 里卡蒂 ODE 的求解**\n\n这是一个一阶非线性 ODE。对于 $c \\ne 0$，我们可以通过找到其稳態解并使用分离变量法来求解它。令 $P_{\\infty}$ 为一个稳態解，此时 $\\frac{\\mathrm{d}P}{\\mathrm{d}t}=0$：\n$$\n-\\frac{c^2}{r}P_{\\infty}^2 + 2a\\,P_{\\infty} + q = 0 \\implies \\frac{c^2}{r}P_{\\infty}^2 - 2a\\,P_{\\infty} - q = 0\n$$\n这个二次方程的根是：\n$$\nP_{\\infty} = \\frac{2a \\pm \\sqrt{4a^2 - 4(\\frac{c^2}{r})(-q)}}{2(\\frac{c^2}{r})} = \\frac{r}{c^2}\\left(a \\pm \\sqrt{a^2 + \\frac{c^2 q}{r}}\\right)\n$$\n令 $\\gamma = \\sqrt{a^2 + \\frac{c^2 q}{r}}$。两个根是 $\\lambda_1 = \\frac{r}{c^2}(a+\\gamma)$ 和 $\\lambda_2 = \\frac{r}{c^2}(a-\\gamma)$。由于 $\\gamma \\ge |a|$，所以 $\\lambda_1 \\ge 0$ 且 $\\lambda_2 \\le 0$。方差 $P_t$ 必须是非负的。$\\lambda_1$ 是 $P_t \\ge 0$ 的稳定平衡点。\n该 ODE 可以写作 $\\frac{\\mathrm{d}P_t}{\\mathrm{d}t} = -\\frac{c^2}{r}(P_t - \\lambda_1)(P_t - \\lambda_2)$。使用分离变量法：\n$$\n\\int_{P_0}^{P_t} \\frac{\\mathrm{d}P}{(P - \\lambda_1)(P - \\lambda_2)} = -\\frac{c^2}{r} \\int_0^t \\mathrm{d}s = -\\frac{c^2}{r}t\n$$\n使用部分分式分解，$\\frac{1}{(P - \\lambda_1)(P - \\lambda_2)} = \\frac{1}{\\lambda_1 - \\lambda_2}\\left(\\frac{1}{P - \\lambda_1} - \\frac{1}{P - \\lambda_2}\\right)$。积分变为：\n$$\n\\frac{1}{\\lambda_1 - \\lambda_2} \\left[ \\ln\\left|\\frac{P-\\lambda_1}{P-\\lambda_2}\\right| \\right]_{P_0}^{P_t} = -\\frac{c^2}{r} t\n$$\n由于 $P_t$ 从 $P_0$ 收敛到 $\\lambda_1$ 且不会越过 $\\lambda_2$（因为 $\\lambda_2 \\le 0$ 且 $P_t \\ge 0$），$(P_t-\\lambda_1)$ 和 $(P_0-\\lambda_1)$ 的符号相同，且 $(P_t-\\lambda_2)>0, (P_0-\\lambda_2)>0$。我们可以去掉绝对值符号。\n$$\n\\ln\\left(\\frac{P_t-\\lambda_1}{P_t-\\lambda_2}\\right) - \\ln\\left(\\frac{P_0-\\lambda_1}{P_0-\\lambda_2}\\right) = -(\\lambda_1 - \\lambda_2)\\frac{c^2}{r} t\n$$\n注意到 $\\lambda_1 - \\lambda_2 = \\frac{2r\\gamma}{c^2}$，指数变为 $-(\\frac{2r\\gamma}{c^2})\\frac{c^2}{r} t = -2\\gamma t$。\n$$\n\\frac{P_t-\\lambda_1}{P_t-\\lambda_2} = \\frac{P_0-\\lambda_1}{P_0-\\lambda_2} \\exp(-2\\gamma t)\n$$\n求解 $P_t$：\n$$\nP_t = \\frac{\\lambda_1(P_0-\\lambda_2) - \\lambda_2(P_0-\\lambda_1)\\exp(-2\\gamma t)}{(P_0-\\lambda_2) - (P_0-\\lambda_1)\\exp(-2\\gamma t)}\n$$\n其中 $\\lambda_1 = \\frac{r}{c^2}(a+\\gamma)$，$\\lambda_2 = \\frac{r}{c^2}(a-\\gamma)$，以及 $\\gamma = \\sqrt{a^2 + \\frac{c^2 q}{r}}$。\n\n**3. 收敛条件与稳态值 $P_{\\infty}$**\n\n为了使 $P_t$ 收敛到一个有限的稳态值 $P_{\\infty} = \\lim_{t\\to\\infty} P_t$，解必须趋于一个有限极限。从显式解可知，这在系统是“能检测的”（detectable）情况下发生。对于这个标量系统，能检测性意味着任何不稳定或中性稳定模态（$a \\ge 0$）必须是能观测的（$c \\ne 0$）。这等价于条件：\n$$\na < 0 \\quad \\text{或} \\quad c \\ne 0\n$$\n如果这个条件成立，我们可以通过取 $t \\to \\infty$ 时 $P_t$ 的极限来求得 $P_{\\infty}$。假设 $\\gamma > 0$（如果 $a \\neq 0$ 或 $c^2q \\neq 0$ 则此假设成立），则项 $\\exp(-2\\gamma t)$ 趋于 $0$。\n$$\nP_{\\infty} = \\lim_{t\\to\\infty} P_t = \\frac{\\lambda_1(P_0-\\lambda_2) - 0}{(P_0-\\lambda_2) - 0} = \\lambda_1\n$$\n这对应于里卡蒂方程的稳定、非负平衡点。稳态方差的闭式表达式为：\n$$\nP_{\\infty} = \\frac{r}{c^2}\\left(a + \\sqrt{a^2 + \\frac{c^2 q}{r}}\\right)\n$$\n该表达式在 $c \\ne 0$ 时有效。如果 $c=0$，收敛条件要求 $a < 0$。在这种情况下，里卡蒂 ODE 变为线性的：$\\frac{\\mathrm{d}P_t}{\\mathrm{d}t} = 2aP_t + q$，其稳态解为 $P_{\\infty} = -q/(2a)$。对于 $a < 0$ 的情况，当 $c \\to 0$ 时，$c \\ne 0$ 的公式能正确地趋向于这个极限。\n\n**4. 数值计算**\n\n给定数值：$a=0.4$，$c=1.5$，$q=0.2$，$r=0.5$ 以及 $P_0=1.0$。\n首先，我们检查收敛条件。我们有 $a=0.4 > 0$，但 $c=1.5 \\ne 0$。条件（$a < 0$ 或 $c \\ne 0$）得到满足，因此存在一个有限的稳态方差。我们使用 $P_{\\infty}$ 的公式：\n$$\nP_{\\infty} = \\frac{r}{c^2}\\left(a + \\sqrt{a^2 + \\frac{c^2 q}{r}}\\right)\n$$\n代入给定值：\n$$\nP_{\\infty} = \\frac{0.5}{(1.5)^2}\\left(0.4 + \\sqrt{(0.4)^2 + \\frac{(1.5)^2 (0.2)}{0.5}}\\right)\n$$\n$$\nP_{\\infty} = \\frac{0.5}{2.25}\\left(0.4 + \\sqrt{0.16 + \\frac{2.25 \\times 0.2}{0.5}}\\right)\n$$\n$$\nP_{\\infty} = \\frac{0.5}{2.25}\\left(0.4 + \\sqrt{0.16 + \\frac{0.45}{0.5}}\\right)\n$$\n$$\nP_{\\infty} = \\frac{0.5}{2.25}\\left(0.4 + \\sqrt{0.16 + 0.9}\\right)\n$$\n$$\nP_{\\infty} = \\frac{0.5}{2.25}\\left(0.4 + \\sqrt{1.06}\\right)\n$$\n计算数值：\n$$\nP_{\\infty} \\approx \\frac{0.5}{2.25}\\left(0.4 + 1.029563\\right) \\approx 0.222222 \\times (1.429563) \\approx 0.3176806\n$$\n四舍五入到四位有效数字，我们得到：\n$$\nP_{\\infty} \\approx 0.3177\n$$", "answer": "$$\n\\boxed{0.3177}\n$$", "id": "3080944"}, {"introduction": "从理论推导到实际应用，关键的一步是实现一个稳健的数值求解器。本练习将带你进入卡尔曼-布西滤波器的核心实现环节：编写一个程序来求解矩阵里卡蒂微分方程。你不仅会应用像四阶龙格-库塔这样的标准数值方法，还将直面并解决实际计算中至关重要的问题——如何确保协方差矩阵 $P_t$ 在迭代过程中始终保持其物理上必需的对称性和正半定性。[@problem_id:3080947]", "problem": "考虑一个由标准维纳过程驱动的连续时间线性高斯状态空间模型，其状态动态和测量由下式给出\n$$\n\\mathrm{d}x_t = A x_t \\,\\mathrm{d}t + G\\,\\mathrm{d}W_t,\\qquad \\mathrm{d}y_t = C x_t \\,\\mathrm{d}t + R^{1/2}\\,\\mathrm{d}V_t,\n$$\n其中 $x_t \\in \\mathbb{R}^n$，$y_t \\in \\mathbb{R}^m$，$A \\in \\mathbb{R}^{n\\times n}$，$G \\in \\mathbb{R}^{n\\times r}$，$C \\in \\mathbb{R}^{m\\times n}$，单位时间的噪声协方差为 $Q \\in \\mathbb{R}^{r\\times r}$ 和 $R \\in \\mathbb{R}^{m\\times m}$，且 $Q \\succeq 0$，$R \\succ 0$。Kalman-Bucy 滤波器协方差 $P_t \\in \\mathbb{R}^{n\\times n}$ 根据以下矩阵微分方程演化\n$$\n\\dot{P}_t \\;=\\; A P_t + P_t A^{\\top} + G Q G^{\\top} \\;-\\; P_t C^{\\top} R^{-1} C P_t,\\qquad P_0 \\succeq 0.\n$$\n您的任务是为此协方差常微分方程实现一个固定步长的显式四阶 Runge–Kutta 积分器，并结合一个数值鲁棒的步后投影，以强制保证 $P_t$ 的对称性和正半定性。具体要求如下：\n- 使用固定步长 $h$ 从 $t=0$ 积分到 $t=T$。\n- 每一步之后，通过将 $P$ 替换为 $\\tfrac{1}{2}(P+P^{\\top})$ 来强制对称性。\n- 然后，通过计算对称化矩阵的特征值分解，并将任何负特征值截断为 $0$ 后再重构矩阵，来强制正半定性。\n\n对于下方的每个测试用例，从指定的初始协方差 $P_0$ 开始，以给定的步长 $h$ 积分到指定的终端时间 $T$，并报告等于终端协方差的迹 $\\operatorname{tr}(P_T)$ 的标量输出。此任务中不需要物理单位。\n\n测试套件（每个项目指定 $A$、$G$、$Q$、$C$、$R$、$P_0$、$T$、$h$）：\n1. 正常路径（稳定动态、信息丰富的测量、过程噪声）：\n   - $\n   A_1=\\begin{bmatrix}\n   -1.0  0.5\\\\\n   -0.4  -1.2\n   \\end{bmatrix},\\quad\n   G_1=\\begin{bmatrix}\n   1.0  0.0\\\\\n   0.0  1.0\n   \\end{bmatrix},\\quad\n   Q_1=\\begin{bmatrix}\n   0.3  0.0\\\\\n   0.0  0.1\n   \\end{bmatrix},\n   $\n   $$\n   C_1=\\begin{bmatrix} 1.0  0.2 \\end{bmatrix},\\quad\n   R_1=\\begin{bmatrix} 0.2 \\end{bmatrix},\\quad\n   P_{0,1}=\\begin{bmatrix}\n   1.0  0.0\\\\\n   0.0  1.0\n   \\end{bmatrix},\\quad\n   T_1=4.0,\\quad h_1=0.005.\n   $$\n2. 边界情况（无过程噪声，可观测输出；协方差应衰减至 $0$）：\n   - $\n   A_2=\\begin{bmatrix}\n   -1.0  0.5\\\\\n   -0.4  -1.2\n   \\end{bmatrix},\\quad\n   G_2=\\begin{bmatrix}\n   1.0  0.0\\\\\n   0.0  1.0\n   \\end{bmatrix},\\quad\n   Q_2=\\begin{bmatrix}\n   0.0  0.0\\\\\n   0.0  0.0\n   \\end{bmatrix},\n   $\n   $$\n   C_2=\\begin{bmatrix} 0.7  -0.3 \\end{bmatrix},\\quad\n   R_2=\\begin{bmatrix} 0.05 \\end{bmatrix},\\quad\n   P_{0,2}=\\begin{bmatrix}\n   2.0  0.3\\\\\n   0.3  1.0\n   \\end{bmatrix},\\quad\n   T_2=4.0,\\quad h_2=0.005.\n   $$\n3. 边缘情况（无测量；协方差通过 Lyapunov 方程演化）：\n   - $\n   A_3=\\begin{bmatrix}\n   -1.5  0.0\\\\\n   0.0  -0.8\n   \\end{bmatrix},\\quad\n   G_3=\\begin{bmatrix}\n   1.0  0.0\\\\\n   0.0  1.0\n   \\end{bmatrix},\\quad\n   Q_3=\\begin{bmatrix}\n   0.4  0.0\\\\\n   0.0  0.2\n   \\end{bmatrix},\n   $\n   $$\n   C_3=\\begin{bmatrix} 0.0  0.0 \\end{bmatrix},\\quad\n   R_3=\\begin{bmatrix} 1.0 \\end{bmatrix},\\quad\n   P_{0,3}=\\begin{bmatrix}\n   0.0  0.0\\\\\n   0.0  0.0\n   \\end{bmatrix},\\quad\n   T_3=5.0,\\quad h_3=0.005.\n   $$\n4. 病态测量（小的测量噪声方差）：\n   - $\n   A_4=\\begin{bmatrix}\n   0.0  1.0\\\\\n   -2.0  -0.5\n   \\end{bmatrix},\\quad\n   G_4=\\begin{bmatrix}\n   1.0  0.0\\\\\n   0.0  1.0\n   \\end{bmatrix},\\quad\n   Q_4=\\begin{bmatrix}\n   0.05  0.0\\\\\n   0.0  0.05\n   \\end{bmatrix},\n   $\n   $$\n   C_4=\\begin{bmatrix} 1.0  0.0 \\end{bmatrix},\\quad\n   R_4=\\begin{bmatrix} 0.001 \\end{bmatrix},\\quad\n   P_{0,4}=\\begin{bmatrix}\n   1.0  0.0\\\\\n   0.0  1.0\n   \\end{bmatrix},\\quad\n   T_4=2.0,\\quad h_4=0.001.\n   $$\n\n实现要求：\n- 实现右侧函数 $f(P)=A P + P A^{\\top} + G Q G^{\\top} - P C^{\\top} R^{-1} C P$。\n- 使用固定步长 $h$ 的四阶 Runge–Kutta 方法进行积分。\n- 每一步之后，将 $P$ 替换为 $\\tfrac{1}{2}(P+P^{\\top})$，然后计算对称化后的 $P$ 的特征值分解，并在重构 $P$ 之前将所有负特征值设置为 $0$。\n- 对于每个测试用例，计算并返回标量 $\\operatorname{tr}(P_T)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个方括号括起来的四个迹值的逗号分隔列表，每个值四舍五入到小数点后六位，例如 $[\\dots]$。", "solution": "用户要求为连续时间 Kalman-Bucy 滤波器协方差方程实现一个数值求解器，该方程是一个矩阵 Riccati 微分方程。该解决方案需要使用固定步长的显式四阶 Runge-Kutta (RK4) 方法，并辅以步后投影来保持协方差矩阵的物理属性。\n\n状态空间模型由下式给出：\n$$\n\\mathrm{d}x_t = A x_t \\,\\mathrm{d}t + G\\,\\mathrm{d}W_t\n$$\n$$\n\\mathrm{d}y_t = C x_t \\,\\mathrm{d}t + R^{1/2}\\,\\mathrm{d}V_t\n$$\n其中 $x_t \\in \\mathbb{R}^n$ 是状态向量，$y_t \\in \\mathbb{R}^m$ 是测量向量，$\\mathrm{d}W_t$ 和 $\\mathrm{d}V_t$ 是向量值标准维纳过程。相应的单位时间过程噪声和测量噪声协方差矩阵分别是 $Q$ 和 $R$。\n\n滤波器估计的误差协方差矩阵 $P_t = \\mathbb{E}[ (x_t - \\hat{x}_t)(x_t - \\hat{x}_t)^\\top ]$ 根据矩阵 Riccati 微分方程演化：\n$$\n\\dot{P}_t = A P_t + P_t A^{\\top} + G Q G^{\\top} - P_t C^{\\top} R^{-1} C P_t\n$$\n初始条件为 $P_0 \\succeq 0$。我们将此常微分方程 (ODE) 的右侧表示为 $f(P_t)$。\n\n为了数值求解此 ODE，我们采用四阶 Runge-Kutta (RK4) 方法。对于一个通用 ODE $\\dot{\\mathbf{y}} = \\mathbf{f}(t, \\mathbf{y})$，从时间 $t_n$ 到 $t_{n+1} = t_n + h$ 的一个步长为 $h$ 的积分步骤由下式给出：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{f}(t_n + h/2, \\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{f}(t_n + h/2, \\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{f}(t_n + h, \\mathbf{y}_n + h \\mathbf{k}_3) \\\\\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\n在我们的特定情况下，状态 $\\mathbf{y}$ 是矩阵 $P_t$，函数 $f$ 是时不变的，即 $f(t, P_t) = f(P_t)$。因此，RK4 的阶段 $k_1, k_2, k_3, k_4$ 是 $n \\times n$ 的矩阵，计算如下：\n$$\n\\begin{aligned}\nk_1 = f(P_n) \\\\\nk_2 = f(P_n + \\frac{h}{2} k_1) \\\\\nk_3 = f(P_n + \\frac{h}{2} k_2) \\\\\nk_4 = f(P_n + h k_3)\n\\end{aligned}\n$$\n经过一个原始积分步骤后的协方差矩阵是：\n$$\nP_{n+1, \\text{raw}} = P_n + \\frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n$$\n为提高计算效率， $f(P_t)$ 中的常数项被预先计算。令 $Q' = G Q G^{\\top}$ 和 $H = C^{\\top} R^{-1} C$。ODE 函数变为 $f(P) = A P + P A^{\\top} + Q' - P H P$。$Q'$ 和 $H$ 都在积分循环开始前计算一次。\n\n真实的协方差矩阵 $P_t$ 必须是对称且正半定的。数值积分可能会引入微小误差，从而违反这些属性。因此，在每次 RK4 更新后应用一个投影步骤。\n1.  **对称化**：通过将原始更新后的矩阵 $P_{n+1, \\text{raw}}$ 与其转置取平均，使其对称：\n    $$\n    P_{n+1, \\text{sym}} = \\frac{1}{2} (P_{n+1, \\text{raw}} + P_{n+1, \\text{raw}}^{\\top})\n    $$\n2.  **强制正半定性**：为确保正半定性，我们对对称化矩阵进行特征值分解，$P_{n+1, \\text{sym}} = U \\Lambda U^{\\top}$，其中 $U$ 是特征向量构成的正交矩阵，$\\Lambda$ 是实数特征值构成的对角矩阵。然后，我们将任何负特征值截断为零，形成一个新的对角矩阵 $\\Lambda'$，其中 $\\Lambda'_{ii} = \\max(\\Lambda_{ii}, 0)$。最终的投影矩阵通过以下方式重构：\n    $$\n    P_{n+1} = U \\Lambda' U^{\\top}\n    $$\n此过程在 Frobenius 范数下找到最接近 $P_{n+1, \\text{sym}}$ 的正半定矩阵。\n\n整个算法包括将 $P$ 初始化为 $P_0$，然后迭代地应用 RK4 步骤和随后的两部分投影，迭代次数等于 $\\text{round}(T/h)$。每个测试用例的最终输出是终端协方差矩阵的迹，即 $\\operatorname{tr}(P_T)$。\n```python\nimport numpy as np\n\ndef solve_problem_2():\n    \"\"\"\n    Main function to solve the Kalman-Bucy covariance integration for all test cases.\n    \"\"\"\n\n    def integrate_covariance(A, G, Q, C, R, P0, T, h):\n        \"\"\"\n        Integrates the Kalman-Bucy covariance equation using RK4 with post-step projection.\n\n        Args:\n            A (np.ndarray): State dynamics matrix.\n            G (np.ndarray): Process noise input matrix.\n            Q (np.ndarray): Process noise covariance matrix per unit time.\n            C (np.ndarray): Measurement matrix.\n            R (np.ndarray): Measurement noise covariance matrix per unit time.\n            P0 (np.ndarray): Initial covariance matrix.\n            T (float): Total integration time.\n            h (float): Fixed step size.\n\n        Returns:\n            np.ndarray: The terminal covariance matrix P(T).\n        \"\"\"\n        # Pre-compute constant matrices for the ODE function to improve efficiency.\n        GQGT = G @ Q @ G.T\n        try:\n            R_inv = np.linalg.inv(R)\n        except np.linalg.LinAlgError:\n            # Handle singular R if it occurs, though problem constraints say R > 0.\n            # In this problem context, it's not expected.\n            raise\n            \n        H = C.T @ R_inv @ C\n\n        def f(P):\n            \"\"\"RHS of the Riccati ODE: dP/dt = f(P)\"\"\"\n            lyapunov_part = A @ P + P @ A.T + GQGT\n            riccati_part = P @ H @ P\n            return lyapunov_part - riccati_part\n\n        P = P0.copy()\n        num_steps = int(round(T / h))\n\n        for _ in range(num_steps):\n            # Standard explicit fourth-order Runge-Kutta (RK4) step\n            k1 = f(P)\n            k2 = f(P + 0.5 * h * k1)\n            k3 = f(P + 0.5 * h * k2)\n            k4 = f(P + h * k3)\n            P_raw = P + (h / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n            # Post-step projection to enforce physical constraints\n            # 1. Symmetrization\n            P_sym = 0.5 * (P_raw + P_raw.T)\n\n            # 2. Positive Semidefinite Enforcement via eigenvalue clipping\n            # Use np.linalg.eigh as it is specialized for symmetric matrices\n            eigenvalues, eigenvectors = np.linalg.eigh(P_sym)\n            \n            # Clip negative eigenvalues to zero\n            eigenvalues[eigenvalues  0] = 0.0\n            \n            # Reconstruct the matrix from modified eigenvalues\n            P = eigenvectors @ np.diag(eigenvalues) @ eigenvectors.T\n\n        return P\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Happy path\n        {\n            \"A\": np.array([[-1.0, 0.5], [-0.4, -1.2]]),\n            \"G\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"Q\": np.array([[0.3, 0.0], [0.0, 0.1]]),\n            \"C\": np.array([[1.0, 0.2]]),\n            \"R\": np.array([[0.2]]),\n            \"P0\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"T\": 4.0, \"h\": 0.005\n        },\n        # Case 2: Boundary case (no process noise)\n        {\n            \"A\": np.array([[-1.0, 0.5], [-0.4, -1.2]]),\n            \"G\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"Q\": np.array([[0.0, 0.0], [0.0, 0.0]]),\n            \"C\": np.array([[0.7, -0.3]]),\n            \"R\": np.array([[0.05]]),\n            \"P0\": np.array([[2.0, 0.3], [0.3, 1.0]]),\n            \"T\": 4.0, \"h\": 0.005\n        },\n        # Case 3: Edge case (no measurements)\n        {\n            \"A\": np.array([[-1.5, 0.0], [0.0, -0.8]]),\n            \"G\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"Q\": np.array([[0.4, 0.0], [0.0, 0.2]]),\n            \"C\": np.array([[0.0, 0.0]]),\n            \"R\": np.array([[1.0]]),\n            \"P0\": np.array([[0.0, 0.0], [0.0, 0.0]]),\n            \"T\": 5.0, \"h\": 0.005\n        },\n        # Case 4: Ill-conditioned measurement\n        {\n            \"A\": np.array([[0.0, 1.0], [-2.0, -0.5]]),\n            \"G\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"Q\": np.array([[0.05, 0.0], [0.0, 0.05]]),\n            \"C\": np.array([[1.0, 0.0]]),\n            \"R\": np.array([[0.001]]),\n            \"P0\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"T\": 2.0, \"h\": 0.001\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        P_T = integrate_covariance(case[\"A\"], case[\"G\"], case[\"Q\"], case[\"C\"], case[\"R\"], case[\"P0\"], case[\"T\"], case[\"h\"])\n        trace_PT = np.trace(P_T)\n        results.append(trace_PT)\n\n    # Format the final output as a comma-separated list of values rounded to 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    return f\"[{','.join(formatted_results)}]\"\n\n# The result is generated by running the function, but not printed here.\n# print(solve_problem_2())\n# Result: [0.342111,0.000185,0.258162,0.119098]\n```", "answer": "[0.342111,0.000185,0.258162,0.119098]", "id": "3080947"}, {"introduction": "当你成功构建并运行一个滤波器后，如何判断它是否工作在最佳状态？本练习将教你一种强大而常用的滤波器诊断技术：检验新息过程的“白性”。一个最优滤波器产生的预测误差序列（即新息）理论上应该是无关联的白噪声。通过模拟一个系统、应用滤波器并对新息序列进行统计自相关分析，你将学会如何验证这一关键理论特性，这对于滤波器的调试和性能验证至关重要。[@problem_id:3080965]", "problem": "考虑一个被连续观测并由连续时间线性 Kalman-Bucy 滤波器进行滤波的线性随机系统。状态过程由随机微分方程 $dx_t = A x_t \\, dt + G \\, dW_t$ 给出，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个稳定的漂移矩阵，$G \\in \\mathbb{R}^{n \\times r}$ 是扩散输入矩阵，$W_t$ 是一个标准的 $r$ 维维纳过程。观测过程由 $dy_t = H x_t \\, dt + d\\eta_t$ 给出，其中 $H \\in \\mathbb{R}^{m \\times n}$ 是观测矩阵，$\\eta_t$ 是一个 $m$ 维维纳过程，其瞬时协方差强度为 $R_{\\text{eff}} = H R H^{\\top}$，对于某个正定矩阵 $R \\in \\mathbb{R}^{n \\times n}$。卡尔曼-布西滤波器的新息过程是观测增量与其模型预测增量之间的差异。\n\n从线性随机微分方程和卡尔曼-布西滤波器中新息过程的定义出发，设计一个程序，从第一性原理执行以下步骤：\n\n- 使用一种对 Itô 过程一致的科学方法，在步长为 $dt$（秒）的均匀采样网格上离散化上述连续时间模型。根据上述定义生成 $x_t$ 和 $y_t$ 的样本路径，确保观测噪声增量的协方差为 $R_{\\text{eff}} \\, dt$。\n- 以与基本定义一致的方式实现 Kalman-Bucy 滤波方程，除了连续时间线性高斯设定外，不使用任何预先推导的快捷公式。使用显式 Euler 方法来近似连续时间滤波器的更新。\n- 在每个时间步，根据模型预测的观测增量和实际实现的观测增量，计算新息序列增量 $\\Delta \\nu_k$。\n- 估计新息序列在延迟 $0$、$1$ 和 $2$ 处的样本自协方差矩阵。使用从随机向量间协方差定义推导出的无偏或一致的有限样本估计量。\n- 将估计的延迟-$0$ 新息协方差与由分布极限 $H R H^{\\top} \\, \\delta$ 表征的理论行为进行比较，这意味着在离散步长上，延迟-$0$ 协方差等于 $H R H^{\\top} \\, dt$，而对于 $\\ell \\ge 1$，延迟-$\\ell$ 协方差为 $0$。使用差值的 Frobenius 范数（由 $H R H^{\\top} \\, dt$ 的 Frobenius 范数归一化）来量化延迟 $0$ 处的失配，并使用延迟-$1$ 协方差的 Frobenius 范数（由延迟-$0$ 协方差的 Frobenius 范数归一化）来量化非白性。\n\n您的程序必须在以下参数集的测试套件下模拟和测试新息的白性。在每个测试用例中，$dt$ 以秒为单位指定，步数 $N$ 是一个正整数。所有矩阵必须在科学上是合理的，具有稳定的 $A$ 和正定的噪声协方差：\n\n- 测试用例 $1$（基准二维系统，良好调校的滤波器）：\n  - $n = 2$，$m = 2$，$r = 2$。\n  - $A = \\begin{bmatrix} -0.5  0.0 \\\\ 0.0  -1.0 \\end{bmatrix}$，$G = I_2$，$H = \\begin{bmatrix} 1.0  0.5 \\\\ 0.0  1.0 \\end{bmatrix}$。\n  - $Q = I_2$（过程噪声协方差强度），$R = \\operatorname{diag}(0.4, 0.6)$（用于构造 $R_{\\text{eff}} = H R H^{\\top}$）。\n  - $dt = 0.01$ 秒，$N = 5000$，初始均值 $x_0 = 0$，初始滤波器协方差 $P_0 = I_2$。\n  - 滤波器必须使用真实的 $R_{\\text{eff}}$。\n\n- 测试用例 $2$（边界一维系统，小步长）：\n  - $n = 1$，$m = 1$，$r = 1$。\n  - $A = [-2.0]$，$G = [1.0]$，$H = [1.0]$。\n  - $Q = [1.0]$，$R = [0.2]$，因此 $R_{\\text{eff}} = H R H^{\\top} = [0.2]$。\n  - $dt = 0.002$ 秒，$N = 15000$，初始均值 $x_0 = 0$，初始滤波器协方差 $P_0 = [1.0]$。\n  - 滤波器必须使用真实的 $R_{\\text{eff}}$。\n\n- 测试用例 $3$（滤波器中的测量噪声失配以引发非白性）：\n  - 与测试用例 1 相同，但滤波器必须使用失配的测量噪声协方差强度 $\\widehat{R}_{\\text{eff}} = 0.25 \\times R_{\\text{eff}}$，而模拟的观测噪声仍使用真实的 $R_{\\text{eff}}$。\n\n对于每个测试用例，计算两个标量指标：\n- 归一化的延迟-$0$ 失配 $\\rho_0 = \\dfrac{\\| \\widehat{\\Gamma}_0 - R_{\\text{eff}} \\, dt \\|_F}{\\| R_{\\text{eff}} \\, dt \\|_F}$，其中 $\\widehat{\\Gamma}_\\ell$ 表示在延迟 $\\ell$ 处的样本自协方差，$\\|\\cdot\\|_F$ 表示 Frobenius 范数。\n- 归一化的延迟-$1$ 幅值 $\\rho_1 = \\dfrac{\\| \\widehat{\\Gamma}_1 \\|_F}{\\| \\widehat{\\Gamma}_0 \\|_F}$。\n\n为每个测试用例声明一个布尔值的通过/失败结果，如果 $\\rho_0 \\le 0.3$ 和 $\\rho_1 \\le 0.25$ 同时满足，则定义为 true，否则为 false。这些阈值是无量纲的，并且必须对所有测试用例一致应用。\n\n您的程序应生成单行输出，其中包含三个测试用例的通过/失败结果，形式为方括号内以逗号分隔的列表，例如 $[ \\text{true}, \\text{false}, \\text{true} ]$。输出值为布尔值且无量纲。不得打印任何其他输出。", "solution": "本问题的目标是数值验证连续时间线性 Kalman-Bucy 滤波器的一个基本性质：其新息过程的白性。该任务涉及模拟一个线性随机系统，应用 Kalman-Bucy 滤波器的离散化版本，并分析所得新息序列的统计特性。分析将针对三个不同的测试用例进行，包括一个良好调校的滤波器和一个参数失配的滤波器，以观察理论性质及其失效情况。\n\n该系统由一对 Itô 随机微分方程 (SDE) 描述。状态过程 $x_t \\in \\mathbb{R}^n$ 根据以下方程演化：\n$$dx_t = A x_t \\, dt + G \\, dW_t$$\n观测过程 $y_t \\in \\mathbb{R}^m$ 由以下方程给出：\n$$dy_t = H x_t \\, dt + d\\eta_t$$\n此处，$A$ 是状态动力学矩阵，$G$ 是过程噪声输入矩阵，$H$ 是观测矩阵。$W_t$ 和 $\\eta_t$ 是维纳过程。过程噪声项 $G \\, dW_t$ 的协方差强度矩阵为 $Q_c = G Q G^T$，其中基础维纳过程 $W_t$ 增量的协方差是 $Q \\, dt$。观测噪声 $d\\eta_t$ 具有指定的协方差强度矩阵 $R_{\\text{eff}} = H R H^T$，其中 $R$ 是一个给定的正定矩阵。\n\n**1. 系统与滤波器离散化**\n\n为了在数字计算机上模拟系统和滤波器，我们必须在步长为 $dt$ 的均匀时间网格上对连续时间方程进行离散化。\n\n**系统离散化**：我们使用 Euler-Maruyama 方法，这是一种针对 SDE 的标准一阶数值格式。对于一个很小的时间步长 $dt$，在时间 $t_{k+1} = t_k + dt$ 的状态近似为：\n$$x_{k+1} \\approx x_k + A x_k \\, dt + \\Delta\\xi_k$$\n其中 $\\Delta\\xi_k$ 是一个均值为零、协方差矩阵为 $E[\\Delta\\xi_k \\Delta\\xi_k^T] = Q_c \\, dt = (G Q G^T) \\, dt$ 的高斯随机向量。\n\n通过在区间 $[t_k, t_{k+1}]$ 上积分来离散化观测方程，得到观测增量 $\\Delta y_k = y_{k+1} - y_k$：\n$$\\Delta y_k \\approx H x_k \\, dt + \\Delta\\eta_k$$\n其中 $\\Delta\\eta_k$ 是一个均值为零、协方差矩阵为 $E[\\Delta\\eta_k \\Delta\\eta_k^T] = R_{\\text{eff}} \\, dt$ 的高斯随机向量。\n\n**滤波器离散化**：Kalman-Bucy 滤波器提供状态 $x_t$ 的最优估计 $\\hat{x}_t$。该估计及其误差协方差矩阵 $P_t = E[(x_t - \\hat{x}_t)(x_t - \\hat{x}_t)^T]$ 根据连续时间微分方程演化。我们使用显式 Euler 方法来近似其解。\n\n状态估计更新由以下 SDE 给出：\n$$d\\hat{x}_t = A \\hat{x}_t \\, dt + K_t (dy_t - H \\hat{x}_t \\, dt)$$\n其 Euler 离散化为：\n$$\\hat{x}_{k+1} \\approx \\hat{x}_k + (A \\hat{x}_k) \\, dt + K_k (\\Delta y_k - H \\hat{x}_k \\, dt)$$\n误差协方差 $P_t$ 根据连续时间代数 Riccati 方程演化：\n$$\\frac{dP_t}{dt} = A P_t + P_t A^T - P_t H^T \\widehat{R}_{\\text{eff}}^{-1} H P_t + Q_c$$\n其中 $\\widehat{R}_{\\text{eff}}$ 是滤波器所假设的测量噪声协方差强度，它可能与真实的 $R_{\\text{eff}}$ 不匹配。Kalman 增益 $K_t$ 由 $K_t = P_t H^T \\widehat{R}_{\\text{eff}}^{-1}$ 给出。代入增益表达式，Riccati 方程变为 $\\frac{dP_t}{dt} = A P_t + P_t A^T - K_t H P_t + Q_c$。协方差的显式 Euler 更新为：\n$$P_{k+1} \\approx P_k + (A P_k + P_k A^T - K_k H P_k + Q_c) \\, dt$$\n在每一步中，增益 $K_k = P_k H^T \\widehat{R}_{\\text{eff}}^{-1}$ 使用当前的协方差 $P_k$ 进行计算。\n\n**2. 新息序列与自协方差分析**\n\nKalman 滤波器的一个关键组成部分是新息过程，它代表了最新测量所提供的新信息。连续时间新息为 $d\\nu_t = dy_t - H \\hat{x}_t \\, dt$。对于最优滤波器，新息过程是一个与测量噪声具有相同统计特性的维纳过程，即 $E[d\\nu_t d\\nu_s^T] = R_{\\text{eff}} \\delta(t-s) \\, dt ds$。\n\n在步骤 $k$ 的离散化新息增量为：\n$$\\Delta \\nu_k = \\Delta y_k - H \\hat{x}_k \\, dt$$\n理论性质表明，对于最优滤波器，序列 $\\{\\Delta\\nu_k\\}$ 应该是一个零均值、不相关（白色）的向量序列，其零延迟协方差矩阵为 $\\Gamma_0 = E[\\Delta\\nu_k \\Delta\\nu_k^T] = R_{\\text{eff}} \\, dt$，并且对于所有非零延迟，协方差为零，即 $\\Gamma_\\ell = E[\\Delta\\nu_{k+\\ell} \\Delta\\nu_k^T] = 0$ 对 $\\ell \\ge 1$ 成立。\n\n为验证此性质，我们从模拟的新息序列 $\\{\\Delta\\nu_0, \\Delta\\nu_1, \\dots, \\Delta\\nu_{N-1}\\}$ 中估计样本自协方差矩阵：\n$$\\widehat{\\Gamma}_\\ell = \\frac{1}{N-\\ell} \\sum_{k=0}^{N-1-\\ell} \\Delta\\nu_{k+\\ell} \\Delta\\nu_k^T$$\n我们计算延迟 $\\ell=0$ 和 $\\ell=1$ 的情况。\n\n**3. 性能指标与评估**\n\n问题指定了两个指标来量化所估计新息序列的白性：\n1.  **归一化零延迟失配 ($\\rho_0$)**：该指标衡量估计的零延迟协方差与其理论值的偏差。\n    $$\\rho_0 = \\frac{\\| \\widehat{\\Gamma}_0 - R_{\\text{eff}} \\, dt \\|_F}{\\| R_{\\text{eff}} \\, dt \\|_F}$$\n    其中 $\\|\\cdot\\|_F$ 是 Frobenius 范数。一个小的 $\\rho_0$ 表示滤波器正确地捕捉了新息的方差。\n\n2.  **归一化延迟-1 幅值 ($\\rho_1$)**：该指标衡量延迟 $1$ 处的相关程度，由零延迟功率归一化。\n    $$\\rho_1 = \\frac{\\| \\widehat{\\Gamma}_1 \\|_F}{\\| \\widehat{\\Gamma}_0 \\|_F}$$\n    一个小的 $\\rho_1$ 表明新息接近于不相关（白色），这与理论预期相符。\n\n如果一个测试用例同时满足 $\\rho_0 \\le 0.3$ 和 $\\rho_1 \\le 0.25$，则认为其通过。该标准检查滤波器的性能是否接近最优。测试用例 3 使用了失配的噪声协方差 $\\widehat{R}_{\\text{eff}}$，预计会产生次优滤波器，导致有色新息，并可能无法通过此测试。\n\n程序实现了这整个过程：它为每组参数模拟系统和滤波器，计算新息序列，估计其自协方差，计算指标 $\\rho_0$ 和 $\\rho_1$，并确定通过/失败的结果。\n```python\nimport numpy as np\n\ndef run_simulation(params):\n    \"\"\"\n    Simulates a linear stochastic system, applies a Kalman-Bucy filter,\n    and analyzes the whiteness of the innovation sequence.\n    \"\"\"\n    n, m, A, G, H, Q, R, dt, N, P0, R_eff_mismatch_factor = params\n    \n    # --- 1. Initialization ---\n    \n    # Ensure all matrices are 2D arrays for consistent matrix multiplication\n    A, G, H, Q, R, P0 = map(np.atleast_2d, (A, G, H, Q, R, P0))\n\n    # True continuous-time noise covariance matrices\n    Qc = G @ Q @ G.T\n    R_eff = H @ R @ H.T\n    \n    # Filter's assumed continuous-time measurement noise covariance\n    R_eff_hat = R_eff * R_eff_mismatch_factor\n    R_eff_hat_inv = np.linalg.inv(R_eff_hat)\n\n    # Initial states as column vectors\n    x = np.zeros((n, 1))\n    x_hat = np.zeros((n, 1))\n    P = np.copy(P0)\n\n    # Storage for innovation increments\n    innovations = np.zeros((N, m))\n    \n    # Discrete-time noise covariance matrices for simulation\n    Q_proc_dt = Qc * dt\n    R_obs_dt = R_eff * dt\n\n    mean_n = np.zeros(n)\n    mean_m = np.zeros(m)\n    \n    # --- 2. Simulation Loop ---\n    for k in range(N):\n        # Generate noise increments as column vectors\n        proc_noise = np.random.multivariate_normal(mean_n, Q_proc_dt).reshape(n, 1)\n        obs_noise = np.random.multivariate_normal(mean_m, R_obs_dt).reshape(m, 1)\n        \n        # S-1: Simulate true system observation increment at step k\n        delta_y = (H @ x) * dt + obs_noise\n        \n        # S-2: Simulate true system state update for step k+1\n        x_next = x + (A @ x) * dt + proc_noise\n        \n        # F-1: Calculate innovation increment at step k\n        delta_nu = delta_y - (H @ x_hat) * dt\n        innovations[k, :] = delta_nu.flatten()\n\n        # F-2: Calculate Kalman gain at step k\n        K = P @ H.T @ R_eff_hat_inv\n        \n        # F-3: Update filter state estimate for step k+1\n        x_hat_next = x_hat + (A @ x_hat) * dt + K @ delta_nu\n        \n        # F-4: Update filter covariance for step k+1 via Euler on Riccati eq.\n        dP_dt = A @ P + P @ A.T - K @ H @ P + Qc\n        P_next = P + dP_dt * dt\n        \n        # Advance time step\n        x, x_hat, P = x_next, x_hat_next, P_next\n        \n    # --- 3. Post-Processing ---\n    \n    # Estimate autocovariances using vectorized operations\n    Gamma_hat_0 = (innovations.T @ innovations) / N\n    Gamma_hat_1 = (innovations[1:].T @ innovations[:-1]) / (N - 1)\n    \n    # Theoretical lag-0 covariance\n    Gamma_0_th = R_eff * dt\n    \n    # Calculate Frobenius norms for metrics\n    norm_gamma_th_0 = np.linalg.norm(Gamma_0_th, 'fro')\n    if norm_gamma_th_0  1e-15: norm_gamma_th_0 = 1.0\n\n    norm_gamma_hat_0 = np.linalg.norm(Gamma_hat_0, 'fro')\n    if norm_gamma_hat_0  1e-15: norm_gamma_hat_0 = 1.0\n\n    # Calculate metrics\n    rho_0 = np.linalg.norm(Gamma_hat_0 - Gamma_0_th, 'fro') / norm_gamma_th_0\n    rho_1 = np.linalg.norm(Gamma_hat_1, 'fro') / norm_gamma_hat_0\n\n    # Apply pass/fail criterion\n    is_pass = rho_0 = 0.3 and rho_1 = 0.25\n    return is_pass\n\ndef solve_problem_3():\n    \"\"\"\n    Main function to define test cases and run the simulations.\n    \"\"\"\n    # Test Case 1: Baseline 2D system, well-tuned filter\n    A1 = np.array([[-0.5, 0.0], [0.0, -1.0]])\n    G1 = np.eye(2)\n    H1 = np.array([[1.0, 0.5], [0.0, 1.0]])\n    Q1 = np.eye(2)\n    R1 = np.diag([0.4, 0.6])\n    P0_1 = np.eye(2)\n    case1 = (2, 2, A1, G1, H1, Q1, R1, 0.01, 5000, P0_1, 1.0)\n\n    # Test Case 2: Boundary 1D system, well-tuned filter\n    A2 = np.array([[-2.0]])\n    G2 = np.array([[1.0]])\n    H2 = np.array([[1.0]])\n    Q2 = np.array([[1.0]])\n    R2 = np.array([[0.2]])\n    P0_2 = np.array([[1.0]])\n    case2 = (1, 1, A2, G2, H2, Q2, R2, 0.002, 15000, P0_2, 1.0)\n\n    # Test Case 3: Mismatched filter (underestimates measurement noise)\n    case3 = (2, 2, A1, G1, H1, Q1, R1, 0.01, 5000, P0_1, 0.25)\n    \n    test_cases = [case1, case2, case3]\n    \n    # Using a fixed seed for reproducibility of the stochastic simulation results.\n    np.random.seed(42)\n    \n    results = []\n    for case in test_cases:\n        pass_fail = run_simulation(case)\n        results.append(str(pass_fail).lower())\n\n    # Final print statement in the exact required format.\n    return f\"[{','.join(results)}]\"\n\n# print(solve_problem_3())\n# Result: [true,true,false]\n```", "answer": "[true,true,false]", "id": "3080965"}]}