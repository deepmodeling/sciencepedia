{"hands_on_practices": [{"introduction": "良序原则确保了任何非空正整数集都存在一个最小元素。这个性质在数论中有着深刻的应用，例如证明两个整数 $a$ 和 $b$ 的任何整数线性组合 $ax+by$ 所能构成的最小正数恰好是它们的最大公约数 $\\gcd(a, b)$。这个练习 [@problem_id:1411715] 将这个抽象的证明过程具象化为一个在网格上移动的机器人，让你通过计算亲手发现这一基本原理。", "problem": "一个机器人智能体在一个无限的一维网格上运行。该智能体从原点（位置0）开始。其程序中有两个基本移动指令：`move_A`，将其位置移动+14个单位；`move_B`，将其位置移动+35个单位。该智能体也可以反向执行这些指令（即移动-14或-35个单位）。在任意一系列移动之后，智能体的最终位置 $P$ 可以用线性组合 $P = 14x + 35y$ 来描述，其中 $x$ 和 $y$ 是整数，分别代表 `move_A` 和 `move_B`（及其反向移动）被执行的净次数。\n\n我们感兴趣的是该智能体可以访问的所有可能位置的集合。设 $S$ 为该智能体可到达的所有*正*整数位置的集合。根据良序原则，任何非空的正整数集合必包含一个最小元。可以证明 $S$ 是非空的。设 $d$ 是 $S$ 的最小元。\n\n这个最小正位置 $d$ 的数值是多少？", "solution": "问题要求解 $d$ 的值，其中 $d$ 是可以表示为 $14x + 35y$ 形式的最小正整数，$x$ 和 $y$ 为整数。所有此类正整数的集合记为 $S$。\n\n首先，我们确认集合 $S$ 是非空的。例如，如果我们选择 $x=1$ 和 $y=0$，位置为 $14(1) + 35(0) = 14$。因为14是一个正整数，所以 $14 \\in S$，因此S是非空的。根据良序原则，$S$ 必然有一个最小元，我们称之为 $d$。\n\n因为 $d \\in S$，根据 $S$ 的定义，必然存在整数 $x_0$ 和 $y_0$ 使得：\n$$d = 14x_0 + 35y_0$$\n\n现在，我们将证明 $d$ 必须是14和35的公约数。我们从14开始。根据带余除法，我们可以找到唯一的整数 $q$ 和 $r$ 使得：\n$$14 = qd + r, \\quad \\text{其中 } 0 \\le r  d$$\n\n我们想要确定 $r$ 的值。我们可以将 $r$ 表示为线性组合的形式：\n$$r = 14 - qd$$\n代入 $d$ 的表达式：\n$$r = 14 - q(14x_0 + 35y_0)$$\n$$r = 14 - 14qx_0 - 35qy_0$$\n$$r = 14(1 - qx_0) + 35(-qy_0)$$\n设 $x' = 1 - qx_0$ 和 $y' = -qy_0$。由于 $q$、$x_0$ 和 $y_0$ 都是整数，所以 $x'$ 和 $y'$ 也是整数。因此，$r$ 是14和35的一个整系数线性组合。\n\n如果 $r > 0$，那么 $r$ 将是集合 $S$ 的一个元素。然而，我们从带余除法中知道 $r  d$。这意味着 $r$ 是 $S$ 中一个比 $d$ 更小的元素，这与 $d$ 是 $S$ 的*最小*元的事实相矛盾。因此，假设 $r > 0$ 必定是错误的。\n\n由于 $r$ 必须是非负的（$0 \\le r  d$），唯一剩下的可能性是 $r=0$。\n如果 $r=0$，那么 $14 = qd$。这意味着 $d$ 是14的一个约数。\n\n我们可以应用完全相同的论证来证明 $d$ 也必须是35的一个约数。我们写出 $35 = q'd + r'$，其中 $0 \\le r'  d$。余数 $r'$ 可以表示为 $r' = 35 - q'd = 35(1-q'y_0) + 14(-q'x_0)$，这表明它也是一个线性组合。与之前相同的原因，$r'$ 必须为0，这意味着 $35 = q'd$。因此，$d$ 也是35的一个约数。\n\n所以，$d$ 是14和35的一个公约数。\n\n现在，我们来考虑14和35的最大公约数，我们记作 $g = \\gcd(14, 35)$。由于 $d$ 是14和35的一个公约数，它必须小于或等于*最大*公约数。即 $d \\le g$。\n\n接下来，我们知道 $g$ 整除14并且 $g$ 整除35。这意味着我们可以写成 $14 = ga$ 和 $35 = gb$，其中 $a$ 和 $b$ 是某个整数。\n我们再来看一下 $d$ 的表达式：\n$$d = 14x_0 + 35y_0$$\n将14和35用 $g$ 的表达式代入：\n$$d = (ga)x_0 + (gb)y_0$$\n$$d = g(ax_0 + by_0)$$\n由于 $a, x_0, b, y_0$ 都是整数，项 $(ax_0 + by_0)$ 是一个整数。这个方程表明 $g$ 是 $d$ 的一个约数。由于 $d$ 是一个正整数，这意味着 $g \\le d$。\n\n我们已经建立了两个不等式：$d \\le g$ 和 $g \\le d$。两者同时成立的唯一方式是 $d = g$。\n因此，最小正位置 $d$ 等于14和35的最大公约数。\n\n我们来计算最大公约数：\n14的质因数分解是 $2 \\times 7$。\n35的质因数分解是 $5 \\times 7$。\n最大公约数是公共质因数的乘积，即7。\n所以，$\\gcd(14, 35) = 7$。\n\n因此，$d$ 的值是7。", "answer": "$$\\boxed{7}$$", "id": "1411715"}, {"introduction": "在网络路由或图论中，一个基本问题是如何在两点之间找到一条不重复经过任何节点的“简单路径”。良序原则为我们提供了坚实的理论保证：如果两点之间存在任何“漫步”（允许重复节点），那么必定存在一条最短的漫步，而这条最短漫步一定是一条简单路径。这个练习 [@problem_id:1411727] 将让你扮演网络工程师的角色，通过一个具体的算法，将一个包含循环的冗余路径优化为一条直接、高效的简单路径，从而直观地理解良序原则在结构优化中的应用。", "problem": "在通信网络中，一个数据包的传输过程被建模为它所访问的一系列路由器。我们可以将这个网络表示为一个图 $G=(V, E)$，其中 $V$ 是路由器（顶点）的集合，$E$ 是直接连接（边）的集合。\n\n从起始路由器 $u$ 到终点路由器 $v$ 的长度为 $k$ 的*漫游*(walk)是一个路由器序列 $(v_0, v_1, \\dots, v_k)$，满足 $v_0 = u$，$v_k = v$，并且对于每个 $i \\in \\{1, \\dots, k\\}$，在 $v_{i-1}$ 和 $v_i$ 之间都存在一条边。在漫游中，路由器可以被重复访问。\n\n*简单路径*(simple path)是一种没有路由器被访问超过一次的漫游。\n\n如果一个漫游不是简单路径，这意味着它至少包含一个*环*(cycle)。环可以被看作是漫游序列中起始和结束于同一路由器的部分，例如，子序列 $(R_i, \\dots, R_j)$，其中 $R_i = R_j$ 且 $i  j$。任何包含环的漫游都可以通过系统地移除这些冗余的环路遍历，转换为一条更短的简单路径。例如，漫游 $(A, B, C, D, B, E)$ 包含环 $(B, C, D, B)$，可以被简化为简单路径 $(A, B, E)$。\n\n考虑一个数据包，它遵循从路由器 `V1` 到路由器 `V10` 的一条特定漫游。访问的路由器序列如下：\n(`V1`, `V2`, `V3`, `V4`, `V5`, `V3`, `V6`, `V7`, `V2`, `V8`, `V6`, `V9`, `V10`)\n\n请确定从这条给定的漫游中消除所有环后得到的简单路径的长度。", "solution": "漫游是连续顶点相邻的顶点序列；简单路径是没有重复顶点的漫游。漫游中的任何重复顶点都标识出一个环；移除该顶点的第一次出现与重复出现之间的子漫游，会产生一条具有相同端点的更短的漫游。重复此过程会产生一条从相同起点到相同终点的简单路径。\n\n从左到右处理给定的漫游，维护一个不含重复项的当前路径 $P$。每当一个顶点重复出现时，将 $P$ 截断回该顶点的第一次出现处：\n\n从 $P=(V1)$ 开始。按顺序读取顶点：\n- 读取 V2：不在 $P$ 中，所以 $P=(V1, V2)$。\n- 读取 V3：不在 $P$ 中，所以 $P=(V1, V2, V3)$。\n- 读取 V4：不在 $P$ 中，所以 $P=(V1, V2, V3, V4)$。\n- 读取 V5：不在 $P$ 中，所以 $P=(V1, V2, V3, V4, V5)$。\n- 读取 V3：V3 重复；通过截断到第一个 V3 来移除先前的 V3 与当前 V3 之间的环：$P=(V1, V2, V3)$。\n- 读取 V6：不在 $P$ 中，所以 $P=(V1, V2, V3, V6)$。\n- 读取 V7：不在 $P$ 中，所以 $P=(V1, V2, V3, V6, V7)$。\n- 读取 V2：V2 重复；截断到第一个 V2：$P=(V1, V2)$。\n- 读取 V8：不在 $P$ 中，所以 $P=(V1, V2, V8)$。\n- 读取 V6：不在 $P$ 中，所以 $P=(V1, V2, V8, V6)$。\n- 读取 V9：不在 $P$ 中，所以 $P=(V1, V2, V8, V6, V9)$。\n- 读取 V10：不在 $P$ 中，所以 $P=(V1, V2, V8, V6, V9, V10)$。\n\n这个路径 $P$ 没有重复的顶点，因此它是最终的简单路径。如果 $|P|$ 表示 $P$ 中的顶点数，那么简单路径的长度 $L$（边的数量）为\n$$\nL = |P| - 1 = 6 - 1 = 5.\n$$", "answer": "$$\\boxed{5}$$", "id": "1411727"}, {"introduction": "“L形三格骨牌”平铺问题是组合数学中一个著名而有趣的谜题。它断言，任何移除了一个方格的 $2^n \\times 2^n$ 棋盘都可以被L形三格骨牌完美覆盖。这个结论的证明通常采用数学归纳法，而数学归纳法在逻辑上等价于良序原则。通过解决这个问题 [@problem_id:1411693]，你将亲手执行一个递归分割算法，体验证明从抽象到具体的过程，并领会良序原则是如何保证这类复杂构造问题总有解的。", "problem": "离散数学中一个经典的结果（可用数学归纳法或良序原则证明）指出，任何一个移除了单个方格的 $2^n \\times 2^n$ 方格棋盘，都可以被 L 形三格骨牌完美地铺满。一个 L 形三格骨牌是由三个单位方格组成的瓦片，形状如同字母“L”。\n\n考虑该问题在 $n=3$ 时的特定实例，此时为一个 $8 \\times 8$ 的棋盘。我们为方格定义一个坐标系 $(r, c)$，其中 $r$ 是行号（$1 \\le r \\le 8$，从上到下），而 $c$ 是列号（$1 \\le c \\le 8$，从左到右）。假设从该棋盘上移除的单个方格位于 $(2, 7)$。\n\n铺设过程是使用一个标准的递归四分法算法来完成的。在每一步中，如果一个象限不包含被移除的方格，就会在主棋盘的中心放置一个三格骨牌，以覆盖该象限中的一个方格。这将问题简化为四个更小的铺设问题。\n\n任何一个三格骨牌的方向可以由其 $2 \\times 2$ 边界框内“缺失”的单个方格的位置来描述。我们定义四种方向如下：\n- A：三格骨牌占据其 $2 \\times 2$ 边界框的右上、左下和右下方格（即，左上角方格缺失）。\n- B：三格骨牌占据其 $2 \\times 2$ 边界框的左上、左下和右下方格（即，右上角方格缺失）。\n- C：三格骨牌占据其 $2 \\times 2$ 边界框的左上、右上和右下方格（即，左下角方格缺失）。\n- D：三格骨牌占据其 $2 \\times 2$ 边界框的左上、右上和左下方格（即，右下角方格缺失）。\n\n给定移除了方格 $(2, 7)$ 的棋盘，请确定覆盖位置 $(5, 4)$ 的特定三格骨牌的方向。", "solution": "将 $8\\times 8$ 棋盘划分为四个 $4\\times 4$ 的象限：\n- 左上：$1\\leq r\\leq 4$, $1\\leq c\\leq 4$。\n- 右上：$1\\leq r\\leq 4$, $5\\leq c\\leq 8$。\n- 左下：$5\\leq r\\leq 8$, $1\\leq c\\leq 4$。\n- 右下：$5\\leq r\\leq 8$, $5\\leq c\\leq 8$。\n\n被移除的方格在 $(2,7)$，它位于右上象限。在标准的递归算法中，第一个三格骨牌被放置在中心的 $2\\times 2$ 区域上，使得它恰好覆盖了不包含被移除方格的三个象限中的各一个方格，而属于包含被移除方格的那个象限的中心方格则不被覆盖。\n\n中心的 $2\\times 2$ 区域由方格\n$$(4,4),\\ (4,5),\\ (5,4),\\ (5,5)$$\n组成。它们分别属于左上、右上、左下和右下象限。由于被移除的方格位于右上象限，因此中心的方格 $(4,5)$ 必须不被覆盖。因此，初始的三格骨牌覆盖了另外三个中心方格：\n$$(4,4),\\ (5,4),\\ (5,5).$$\n\n因此，方格 $(5,4)$ 被这个初始的中心三格骨牌所覆盖。相对于其由行 $4,5$ 和列 $4,5$ 组成的 $2\\times 2$ 边界框，缺失的角是右上方的方格 $(4,5)$。根据给定的方向定义，一个占据其 $2\\times 2$ 边界框的左上、左下和右下方格（右上角缺失）的三格骨牌，其方向为 B。因此，覆盖 $(5,4)$ 的三格骨牌的方向为 B。", "answer": "$$\\boxed{B}$$", "id": "1411693"}]}