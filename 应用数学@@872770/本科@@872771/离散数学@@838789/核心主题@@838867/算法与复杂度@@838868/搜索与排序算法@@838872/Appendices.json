{"hands_on_practices": [{"introduction": "二分搜索是在有序数据集中查找元素的基石算法，以其对数时间复杂度 $O(\\log n)$ 而闻名。然而，它的效率依赖于完美无瑕的实现，即使是微小的“差一”错误也可能导致无限循环或错误结果。这个练习 [@problem_id:1398583] 让你追踪一个带有常见实现错误的二分搜索算法，通过亲手实践，你将更深刻地理解指针更新的精确性为何至关重要，并学会如何调试和验证搜索算法的正确性。", "problem": "一位程序员正在实现一个二分搜索程序，用于在一个已排序的、从0开始索引的数组 `A` 中查找目标值 `T`。然而，该实现包含一个细微的错误。\n\n该算法定义如下：\n1. 初始化搜索边界：`low = 0` 和 `high = n-1`，其中 `n` 是数组中元素的数量。\n2. 当 `low = high` 时，执行以下步骤：\n   a. 计算中间索引：`mid = floor((low + high) / 2)`。\n   b. 将目标值 `T` 与元素 `A[mid]`进行比较。\n   c. 如果 `T == A[mid]`，搜索成功终止。\n   d. 如果 `T  A[mid]`，上边界被正确更新：`high = mid - 1`。\n   e. 如果 `T > A[mid]`，由于一个错误，下边界被错误地更新：`low = mid`。（正确的实现会使用 `low = mid + 1`）。\n\n你的任务是，在已排序数组 `A = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]` 上搜索目标值 `T = 25` 时，追踪这个有错误的算法的执行过程。\n\n计算在此搜索执行过程中，与目标值 `T` 进行比较的前三个数组元素的和。", "solution": "我们有一个已排序的、从0开始索引的数组 $A = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]$，其中 $n = 10$，目标值为 $T = 25$。该算法初始化 $low = 0$ 和 $high = n - 1 = 9$，并在每次迭代中计算 $mid = \\left\\lfloor \\frac{low + high}{2} \\right\\rfloor$。由于存在错误，当 $T > A[mid]$ 时，它将 $low$ 更新为 $low \\leftarrow mid$，而不是 $low \\leftarrow mid + 1$。\n\n迭代 1：\n- 初始边界：$low = 0$, $high = 9$。\n- 中间索引：$mid_{1} = \\left\\lfloor \\frac{0 + 9}{2} \\right\\rfloor = \\left\\lfloor \\frac{9}{2} \\right\\rfloor = 4$。\n- 比较的元素：$A[mid_{1}] = A[4] = 16$。\n- 比较结果：$T = 25 > 16 = A[4]$。\n- 错误的更新：$low \\leftarrow mid = 4$；$high$ 保持为 $9$。\n\n迭代 2：\n- 边界：$low = 4$, $high = 9$。\n- 中间索引：$mid_{2} = \\left\\lfloor \\frac{4 + 9}{2} \\right\\rfloor = \\left\\lfloor \\frac{13}{2} \\right\\rfloor = 6$。\n- 比较的元素：$A[mid_{2}] = A[6] = 38$。\n- 比较结果：$T = 25  38 = A[6]$。\n- 正确的上边界更新：$high \\leftarrow mid - 1 = 5$；$low$ 保持为 $4$。\n\n迭代 3：\n- 边界：$low = 4$, $high = 5$。\n- 中间索引：$mid_{3} = \\left\\lfloor \\frac{4 + 5}{2} \\right\\rfloor = \\left\\lfloor \\frac{9}{2} \\right\\rfloor = 4$。\n- 比较的元素：$A[mid_{3}] = A[4] = 16$。\n- 比较结果：$T = 25 > 16 = A[4]$。\n- 错误的更新：$low \\leftarrow mid = 4$（这将导致搜索陷入死循环，但题目只要求前三次比较）。\n\n前三个被比较的元素是 $16$、$38$ 和 $16$。因此，所求的和是\n$$S = 16 + 38 + 16 = 70.$$", "answer": "$$\\boxed{70}$$", "id": "1398583"}, {"introduction": "快速排序是一种高效的“分而治之”排序算法，其核心在于“分区”(partition)操作，该操作围绕一个“主元”(pivot)重新排列数组元素。理解分区过程是掌握快速排序工作原理的关键。本练习 [@problem_id:1398611] 提供了一个具体数组，让你模拟执行一次分区操作，从而直观地感受数据是如何被组织，为后续的递归排序奠定基础。", "problem": "在分布式计算环境中，负载均衡器需要根据分配的优先级值，快速重排传入的任务列表。目标是执行一次分区过程，相对于一个选定的基准任务，将优先级较低的任务分组到优先级较高的任务之前。这有助于更高效地分派任务。\n\n给定五个任务的优先级值列表：$[7, 2, 9, 1, 5]$。\n\n要使用的分区算法如下：\n1. 选择列表中的最后一个元素作为基准值。\n2. 一个边界索引 `i` 初始化为列表中第一个元素之前的一个位置。\n3. 第二个索引 `j` 从列表的第一个元素开始遍历，直到（但不包括）基准元素。\n4. 在迭代过程中，如果索引 `j` 处的元素小于或等于基准值，则先将边界索引 `i` 递增，然后将索引 `i` 处的元素与索引 `j` 处的元素交换。\n5. 迭代完成后，将基准元素与索引 `i+1` 处的元素交换。\n\n下列哪个列表表示在这一次分区过程完成后任务列表的状态？\n\nA. $[2, 1, 5, 7, 9]$\n\nB. $[1, 2, 5, 7, 9]$\n\nC. $[2, 1, 9, 7, 5]$\n\nD. $[5, 2, 7, 1, 9]$\n\nE. $[2, 1, 7, 5, 9]$", "solution": "我们对列表 $A = [7,2,9,1,5]$ 应用所述的分区方法，并使用最后一个元素作为基准。\n\n设置基准 $p = A[4] = 5$，并初始化边界索引 $i = -1$。迭代 $j$ 从 $0$ 到 $3$，并在 $A[j] \\leq p$ 时执行条件交换。\n\n当 $j=0$ 时：$A[0] = 7$。因为 $7 \\leq 5$ 为假，所以不做任何操作；$i=-1$, $A=[7,2,9,1,5]$。\n\n当 $j=1$ 时：$A[1] = 2$。因为 $2 \\leq 5$ 为真，将 $i$ 递增到 $0$ 并交换 $A[0]$ 和 $A[1]$，得到 $A=[2,7,9,1,5]$。\n\n当 $j=2$ 时：$A[2] = 9$。因为 $9 \\leq 5$ 为假，所以不做任何操作；$i=0$, $A=[2,7,9,1,5]$。\n\n当 $j=3$ 时：$A[3] = 1$。因为 $1 \\leq 5$ 为真，将 $i$ 递增到 $1$ 并交换 $A[1]$ 和 $A[3]$，得到 $A=[2,1,9,7,5]$。\n\n循环结束后，将基准与 $A[i+1]$ 交换，即交换 $A[2]$ 和 $A[4]$，结果为 $A=[2,1,5,7,9]$。\n\n因此，一次分区过程后列表的状态是 $[2,1,5,7,9]$，这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1398611"}, {"introduction": "在设计数据处理系统时，我们经常面临一个经典的权衡：是为每一次查询都使用一个简单但较慢的方法，还是先进行一次性的预处理（例如排序）以便后续查询能够高效执行？这个问题 [@problem_id:1398631] 将这种权衡形式化，要求你通过成本分析来确定一个临界点。通过解决这个问题，你将学会如何量化比较不同的算法策略，并根据操作成本和查询频率做出明智的技术决策。", "problem": "一个数据处理系统必须对一个存储为包含 $n$ 个唯一项的数组的静态数据集执行 $k$ 次独立的搜索查询。正在考虑两种策略来处理这些查询。每种策略的效率通过其总计算时间来衡量，该时间由两种基本操作的数量决定：键比较和数据移动。单次键比较所需的时间是 $T_c$，单次数据移动所需的时间是 $T_m$。您可以假设 $n \\ge 3$。\n\n**策略1：重复线性搜索**\n对于 $k$ 次查询中的每一次，都在原始的未排序数组上执行一次线性搜索。在最坏情况下，一次线性搜索需要 $n$ 次键比较。\n\n**策略2：先排序后搜索**\n首先，使用一种基于比较的排序算法的特定实现对数组进行一次排序。在最坏情况下，该算法执行恰好 $A \\cdot n \\log_2(n)$ 次键比较和 $B \\cdot n \\log_2(n)$ 次数据移动，其中 $A$ 和 $B$ 是该算法的特征常数。排序后，对 $k$ 次查询中的每一次执行一次二分搜索。在最坏情况下，对大小为 $n$ 的已排序数组进行二分搜索需要 $\\lfloor \\log_2(n) \\rfloor + 1$ 次键比较。在搜索阶段，数据移动不是一个影响因素。\n\n确定使策略2的总最坏情况时间成本严格小于策略1的总最坏情况时间成本的最小整数 $k$ 值。您的答案应该是一个用 $n, T_c, T_m, A$ 和 $B$ 表示的公式。", "solution": "令 $L=\\lfloor \\log_{2}(n) \\rfloor + 1$ 表示在大小为 $n$ 的数组上进行二分搜索的最坏情况下的键比较次数。\n\n策略1（重复线性搜索）的最坏情况总时间为：\n$$\nT_{1}=k \\cdot n \\cdot T_{c}\n$$\n\n策略2（先排序后搜索）的最坏情况总时间为排序成本与 $k$ 次搜索成本之和：\n$$\nT_{2} = \\left(A \\cdot n \\log_{2}(n) \\cdot T_c + B \\cdot n \\log_{2}(n) \\cdot T_m\\right) + k \\cdot L \\cdot T_{c}\n$$\n$$\nT_{2}=n \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)+k L T_{c}\n$$\n\n我们需要找到使 $T_{2}  T_{1}$ 成立的最小整数 $k$：\n$$\nn \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)+k L T_{c}  k n T_{c}\n$$\n$$\nn \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)  k (n T_{c} - L T_{c})\n$$\n$$\nk > \\frac{n \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)}{T_{c}(n - L)}\n$$\n$$\nk > \\frac{n \\log_{2}(n)}{n - L} \\left(A + B \\frac{T_m}{T_c}\\right)\n$$\n由于 $k$ 必须是整数，最小的 $k$ 值是大于右侧表达式的最小整数，即：\n$$\nk_{min} = \\left\\lfloor \\frac{n \\log_{2}(n)}{n - L}\\left(A+B \\frac{T_{m}}{T_{c}}\\right)\\right\\rfloor + 1\n$$\n将 $L$ 的表达式代入，即可得到最终答案中给出的公式。", "answer": "$$\\boxed{\\left\\lfloor \\frac{n \\log_{2}(n)}{\\,n-\\left(\\lfloor \\log_{2}(n) \\rfloor +1\\right)\\,}\\left(A+B \\frac{T_{m}}{T_{c}}\\right)\\right\\rfloor +1}$$", "id": "1398631"}]}