{"hands_on_practices": [{"introduction": "让我们从构建线性码的基础开始。在这个练习中，你将使用一个生成矩阵来为一个简单的系统创建所有可能的码字。这个动手过程将帮助你理解汉明权重的概念，并计算出码的最小权重——这是决定其检错和纠错能力的一个基本属性。[@problem_id:1367884]", "problem": "在数字通信中，线性分组码用于检测和纠正错误。线性码 $C$ 是一组固定长度的二进制串，称为码字。定义这种码的一种常用方法是使用生成矩阵。\n\n考虑一个将2比特信息字编码为4比特码字的系统。编码通过一个 $2 \\times 4$ 的生成矩阵 $G$ 来执行。一个表示为长度为2的行向量的信息字 $u$，通过矩阵乘法 $c = uG$ 被编码为一个长度为4的行向量的码字 $c$。所有的算术运算都是在模2下进行的（即 $1+1=0$）。\n\n该系统的生成矩阵由下式给出：\n$$G = \\begin{pmatrix} 1  1  0  1 \\\\ 0  1  1  0 \\end{pmatrix}$$\n\n码字的汉明重量，记为 $w(c)$，是码字中1的个数。码 $C$ 的最小重量是 $C$ 中所有非零码字中最小的汉明重量。\n\n确定由矩阵 $G$ 生成的码的最小重量。", "solution": "由矩阵 $G$ 生成的二元线性码包含所有形如 $c = uG$ 的码字 $c$，其中 $u$ 是一个二元行向量。对于给定的生成矩阵\n$$\nG=\\begin{pmatrix}\n1  1  0  1\\\\\n0  1  1  0\n\\end{pmatrix},\n$$\n令其两行分别记为 $g_{1}$ 和 $g_{2}$：\n$$\ng_{1}=(1,1,0,1), \\quad g_{2}=(0,1,1,0).\n$$\n由于所有运算都是在模2下进行的，码字的集合为\n$$\nC=\\{u_{1}g_{1}+u_{2}g_{2} \\mid u_{1},u_{2}\\in\\{0,1\\}\\}.\n$$\n我们枚举所有可能的非零信息向量 $u=(u_{1},u_{2})$ 并计算相应的码字：\n- 对于 $u=(1,0)$：\n$$\nc=g_{1}=(1,1,0,1), \\quad w(c)=3.\n$$\n- 对于 $u=(0,1)$：\n$$\nc=g_{2}=(0,1,1,0), \\quad w(c)=2.\n$$\n- 对于 $u=(1,1)$：\n$$\nc=g_{1}+g_{2}=(1,1,0,1)+(0,1,1,0)=(1,0,1,1), \\quad w(c)=3.\n$$\n零信息 $u=(0,0)$ 产生零码字，这在最小重量的定义中被排除。因此，所有非零码字中的最小汉明重量是\n$$\n\\min\\{3,2,3\\}=2.\n$$\n因此，由 $G$ 生成的码的最小重量是 $2$。", "answer": "$$\\boxed{2}$$", "id": "1367884"}, {"introduction": "创建编码后，下一步是利用它来检测错误。这个练习将我们的重点转移到接收端的视角。你将学习如何计算接收到的字词的“伴随式”，这是一种使用校验矩阵来快速判断传输中是否发生了错误的关键技术。[@problem_id:1367894]", "problem": "在线性分组码理论中，对于二元域 $\\mathbb{F}_2 = \\{0, 1\\}$ 上的码，接收字 $y$ 的伴随式是一个用于检错的向量 $s$。它通过矩阵向量积 $s = H y^T$ 计算得出，其中 $H$ 是该码的校验矩阵，$y^T$ 是字 $y$ 的转置。所有算术运算都在模2下进行，即 $1+1=0$。\n\n考虑一个由以下校验矩阵定义的特定线性码：\n$$\nH = \\begin{pmatrix}\n1  1  0  1  0 \\\\\n0  1  1  0  1 \\\\\n1  0  1  1  0\n\\end{pmatrix}\n$$\n假设接收到的字为 $y = (1, 0, 1, 1, 0)$。计算其对应的伴随式 $s$。请将您的答案表示为行矩阵。", "solution": "我们在 $\\mathbb{F}_{2}$ 上使用 $s=H y^{T}$ 计算伴随式 $s$，其中算术运算是模2的。给定的校验矩阵为\n$$\nH=\\begin{pmatrix}\n1  1  0  1  0 \\\\\n0  1  1  0  1 \\\\\n1  0  1  1  0\n\\end{pmatrix},\n$$\n接收字作为列向量为\n$$\ny^{T}=\\begin{pmatrix}1 \\\\ 0 \\\\ 1 \\\\ 1 \\\\ 0\\end{pmatrix}.\n$$\n将 $H$ 的每一行与 $y^{T}$ 进行点积运算，计算 $s$ 的每个分量，所有运算均在模2下进行：\n- 第一个分量：$(1)(1)+(1)(0)+(0)(1)+(1)(1)+(0)(0)=1+0+0+1+0=2\\equiv 0 \\pmod{2}$。\n- 第二个分量：$(0)(1)+(1)(0)+(1)(1)+(0)(1)+(1)(0)=0+0+1+0+0=1\\equiv 1 \\pmod{2}$。\n- 第三个分量：$(1)(1)+(0)(0)+(1)(1)+(1)(1)+(0)(0)=1+0+1+1+0=3\\equiv 1 \\pmod{2}$。\n\n因此，作为列向量的 $s=\\begin{pmatrix}0 \\\\ 1 \\\\ 1\\end{pmatrix}$，表示为行矩阵即为 $\\begin{pmatrix}0  1  1\\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix}0  1  1\\end{pmatrix}}$$", "id": "1367894"}, {"introduction": "这最后一个练习将编码的理论性质与其实际性能极限联系起来。通过分析一个二进制擦除信道的场景，你将发现编码的最小距离与它能完美纠正的最大擦除次数之间的精确关系。这个练习将抽象概念（如最小距离）与可靠通信这一实际目标联系在一起。[@problem_id:1367876]", "problem": "考虑一个二元线性码 $C$，它是向量空间 $\\mathbb{F}_2^n$ 的一个子空间，其中 $\\mathbb{F}_2 = \\{0, 1\\}$。该码的最小距离，记为 $d$，是 $C$ 中任意两个不同码字之间的最小汉明距离。\n\n一个码字 $c \\in C$ 通过一个二元删除信道（BEC）传输。该信道不会翻转比特，但可能会删除其中一些比特。一个被删除的比特被一个特殊符号，即删除符，所替代，记为“?”。因此，接收到的字 $y$ 是一个长度为 $n$ 的向量，其分量来自集合 $\\{0, 1, ?\\}$。例如，如果发送的码字是 $c = (1, 0, 1, 1, 0)$，并且第二个和第五个比特被删除，那么接收到的字就是 $y = (1, ?, 1, 1, ?)$。\n\n解码器接收到字 $y$ 并尝试恢复原始码字 $c$。解码策略如下：解码器搜索所有码字的集合 $S = \\{c' \\in C \\mid c' \\text{ is consistent with } y\\}$，其中，如果一个码字 $c'$ 在所有未删除的位置上与 $y$ 匹配，则称它与 $y$ “一致”。当且仅当集合 $S$ 只包含一个元素（该元素必然是已发送的码字）时，解码器才能成功恢复原始码字。如果 $S$ 为空或包含多个码字，解码器则宣告失败。\n\n假设除了删除之外没有其他错误发生，对于任意发送的码字和任意 $t$ 个删除的模式，该解码策略能保证成功的最大删除整数 $t$ 是多少？请用码 $C$ 的最小距离 $d$ 的解析表达式来表示你的答案。", "solution": "设 $C \\subseteq \\mathbb{F}_{2}^{n}$ 是一个最小距离为 $d$ 的线性码。对于一个接收到的字 $y \\in \\{0,1,?\\}^{n}$，设 $E \\subseteq \\{1,\\dots,n\\}$ 为被删除坐标的集合，且 $t = |E|$。解码器构建集合\n$$\nS = \\{c' \\in C \\mid c'_{i} = y_{i} \\text{ for all } i \\notin E\\}。\n$$\n由于信道只引入删除（没有翻转），如果发送了码字 $c \\in C$，那么 $c \\in S$。当且仅当 $S = \\{c\\}$ 时，解码成功。\n\n我们来描述 $S$ 含有唯一元素的条件。假设存在两个不同的码字 $c_{1}, c_{2} \\in S$。在 $\\mathbb{F}_{2}$ 上，它们的差 $v = c_{1} - c_{2} = c_{1} + c_{2}$ 是 $C$ 中的一个非零码字。此外，对于所有 $i \\notin E$，有 $c_{1,i} = y_{i} = c_{2,i}$，因此对于所有 $i \\notin E$，有 $v_{i} = 0$。因此，\n$$\n\\operatorname{supp}(v) \\subseteq E.\n$$\n反之，如果存在一个非零码字 $v \\in C$ 且其支撑集 $\\operatorname{supp}(v) \\subseteq E$，那么对于实际发送的码字 $c \\in C$，码字 $c$ 和 $c+v$ 在所有坐标 $i \\notin E$ 上都与 $y$ 一致，因此它们都属于 $S$，且 $|S| \\geq 2$。因此，对于给定的删除模式 $E$，解码唯一性成立的充要条件是不存在非零码字 $v \\in C$ 使得其支撑集 $\\operatorname{supp}(v) \\subseteq E$。\n\n根据最小距离的定义，\n$$\nd = \\min_{v \\in C \\setminus \\{0\\}} w_{H}(v) = \\min_{v \\in C \\setminus \\{0\\}} |\\operatorname{supp}(v)|.\n$$\n因此，如果 $t  d$，那么没有非零码字的整个支撑集能被包含在 $E$ 中，因为 $|\\operatorname{supp}(v)| \\geq d > t$。因此，对于所有 $|E| = t  d$ 的删除模式，集合 $S$ 是一个单元素集，解码成功。\n\n另一方面，如果 $t \\geq d$，选择一个非零码字 $v \\in C$ 使得其汉明重量 $w_{H}(v) = d$，并令 $E = \\operatorname{supp}(v)$。那么对于任意发送的码字 $c \\in C$，码字 $c$ 和 $c+v$ 在所有 $i \\notin E$ 的位置上都一致，因此 $|S| \\geq 2$，解码不保证唯一。因此，对于 $t \\geq d$ 的情况，无法保证成功解码。\n\n所以，对于任意发送的码字和任意 $t$ 个删除的模式，该解码策略能保证成功的最大整数 $t$ 是\n$$\nt = d - 1.\n$$", "answer": "$$\\boxed{d-1}$$", "id": "1367876"}]}