{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本练习将引导你完成汉明码最基本的操作：编码。通过将一个4位数据信息转换为一个7位的(7,4)汉明码字，你将亲手计算校验位并构建最终的码字，这为你理解可靠数字通信的基本原理打下坚实的基础 [@problem_id:1373675]。", "problem": "在为一个远程环境监测站设计容错通信系统时，一位工程师采用标准的$(7,4)$汉明码将4位数据消息编码成7位码字。这个过程增加了冗余，以便能够检测和纠正无线传输过程中可能出现的单位错误。\n\n编码方案定义如下：\n一个表示为$(d_1, d_2, d_3, d_4)$的4位消息被嵌入到一个表示为$(c_1, c_2, c_3, c_4, c_5, c_6, c_7)$的7位码字中。比特位从左到右编号为1到7。\n- 数据位$(d_1, d_2, d_3, d_4)$分别放置在码字的位置$(3, 5, 6, 7)$上。因此，$c_3=d_1$，$c_5=d_2$，$c_6=d_3$，$c_7=d_4$。\n- 剩余的位置，即2的幂次位置$(1, 2, 4)$，用校验位$(p_1, p_2, p_3)$填充。因此，$c_1=p_1$，$c_2=p_2$，$c_4=p_3$。\n- 每个校验位的计算是为了在一组特定的码字位置上强制执行偶校验规则。校验使用异或（XOR，用$\\oplus$表示）运算，其中被校验的位（包括校验位本身）的异或和结果必须为0。\n  - $p_1$ 校验位置 1, 3, 5, 7。（$c_1 \\oplus c_3 \\oplus c_5 \\oplus c_7 = 0$）\n  - $p_2$ 校验位置 2, 3, 6, 7。（$c_2 \\oplus c_3 \\oplus c_6 \\oplus c_7 = 0$）\n  - $p_3$ 校验位置 4, 5, 6, 7。（$c_4 \\oplus c_5 \\oplus c_6 \\oplus c_7 = 0$）\n\n一个传感器传输4位消息 `1011`。生成的对应的7位汉明码是什么？\n\nA. 0110011\n\nB. 1011011\n\nC. 1010101\n\nD. 0010011\n\nE. 1110011", "solution": "设消息为$(d_{1},d_{2},d_{3},d_{4})=(1,0,1,1)$。将数据位放入码字位置：$c_{3}=d_{1}=1$，$c_{5}=d_{2}=0$，$c_{6}=d_{3}=1$，$c_{7}=d_{4}=1$。设校验位为$c_{1}=p_{1}$，$c_{2}=p_{2}$，$c_{4}=p_{3}$并执行偶校验。\n\n对于位置 $1,3,5,7$ 上的 $p_{1}$：\n$$c_{1}\\oplus c_{3}\\oplus c_{5}\\oplus c_{7}=0 \\implies c_{1}\\oplus 1\\oplus 0\\oplus 1=0 \\implies c_{1}\\oplus 0=0 \\implies c_{1}=0.$$\n\n对于位置 $2,3,6,7$ 上的 $p_{2}$：\n$$c_{2}\\oplus c_{3}\\oplus c_{6}\\oplus c_{7}=0 \\implies c_{2}\\oplus 1\\oplus 1\\oplus 1=0 \\implies c_{2}\\oplus 1=0 \\implies c_{2}=1.$$\n\n对于位置 $4,5,6,7$ 上的 $p_{3}$：\n$$c_{4}\\oplus c_{5}\\oplus c_{6}\\oplus c_{7}=0 \\implies c_{4}\\oplus 0\\oplus 1\\oplus 1=0 \\implies c_{4}\\oplus 0=0 \\implies c_{4}=0.$$\n\n因此，码字为$(c_{1},c_{2},c_{3},c_{4},c_{5},c_{6},c_{7})=(0,1,1,0,0,1,1)$，即 $0110011$，这对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1373675"}, {"introduction": "汉明码的核心价值在于其强大的纠错能力。当一个编码后的信息在传输中发生单个比特错误时，我们如何定位并修复它？本练习将向你展示如何利用校验矩阵 ($H$) 和“伴随式”($s$) 这一精妙的数学工具，通过计算伴随式并将其与校验矩阵的列进行匹配，来精确找出并纠正错误，让你亲身体验汉明码的纠错机制 [@problem_id:1373652]。", "problem": "在一个监控环境数据的数字通信系统中，消息使用（7,4）系统汉明码进行编码，以防止在通过噪声信道传输过程中可能发生的单比特错误。一个4比特的数据消息，记为 $m = (d_1, d_2, d_3, d_4)$，被编码成一个7比特的码字 $c = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$。\n\n码字的结构如下：\n- 数据位被放置在不是2的幂次方的位上：$c_3 = d_1$，$c_5 = d_2$，$c_6 = d_3$ 和 $c_7 = d_4$。\n- 奇偶校验位 $p_1, p_2, p_3$ 被放置在是2的幂次方的位上：$c_1 = p_1$，$c_2 = p_2$ 和 $c_4 = p_3$。\n\n一个码字是有效的，当且仅当它满足条件 $Hc^T = \\mathbf{0}$，其中 $\\mathbf{0}$ 是 $3 \\times 1$ 的零向量，且所有算术运算都在模2下进行。这个特定码的奇偶校验矩阵 $H$ 如下所示：\n$$ H = \\begin{pmatrix} 0  0  0  1  1  1  1 \\\\ 0  1  1  0  0  1  1 \\\\ 1  0  1  0  1  0  1 \\end{pmatrix} $$\n从传感器接收到一个7比特字 $r = (0, 0, 0, 1, 0, 0, 1)$。假设在传输过程中最多只有一个比特被翻转，请确定发送的原始4比特数据消息 $m = (d_1, d_2, d_3, d_4)$。\n\n从以下选项中选择正确的消息：\n\nA. 0001\n\nB. 0101\n\nC. 1001\n\nD. 0011\n\nE. 1100", "solution": "我们使用单比特纠错汉明码的伴随式译码规则：对于一个接收到的字 $r=(r_{1},\\dots,r_{7})$，其伴随式为 $s=Hr^{T}$ (在 $\\mathbb{F}_{2}$ 上)。如果在位置 $j$ 恰好有一个比特出错，那么 $s$ 就等于 $H$ 的第 $j$ 列的转置。\n\n已知\n$$\nH=\\begin{pmatrix}\n0  0  0  1  1  1  1\\\\\n0  1  1  0  0  1  1\\\\\n1  0  1  0  1  0  1\n\\end{pmatrix},\\qquad\nr=(0,0,0,1,0,0,1),\n$$\n通过逐行点积计算 $s=Hr^{T}$ 模2：\n$$\ns_{1}=(0\\cdot 0)+(0\\cdot 0)+(0\\cdot 0)+(1\\cdot 1)+(1\\cdot 0)+(1\\cdot 0)+(1\\cdot 1)\\equiv 1+0+0+1\\equiv 0 \\pmod{2},\n$$\n$$\ns_{2}=(0\\cdot 0)+(1\\cdot 0)+(1\\cdot 0)+(0\\cdot 1)+(0\\cdot 0)+(1\\cdot 0)+(1\\cdot 1)\\equiv 1 \\pmod{2},\n$$\n$$\ns_{3}=(1\\cdot 0)+(0\\cdot 0)+(1\\cdot 0)+(0\\cdot 1)+(1\\cdot 0)+(0\\cdot 0)+(1\\cdot 1)\\equiv 1 \\pmod{2}.\n$$\n因此 $s=(0,1,1)$。将 $s$ 转置为列向量，我们得到 $(0,1,1)^T$。$H$ 的各列为\n$H_{\\cdot,1}=\\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix}$, \n$H_{\\cdot,2}=\\begin{pmatrix}0\\\\1\\\\0\\end{pmatrix}$, \n$H_{\\cdot,3}=\\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix}$, \n$H_{\\cdot,4}=\\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix}$, \n$H_{\\cdot,5}=\\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix}$, \n$H_{\\cdot,6}=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix}$, \n$H_{\\cdot,7}=\\begin{pmatrix}1\\\\1\\\\1\\end{pmatrix}$.\n\n因为 $s^T=H_{\\cdot,3}$，所以单比特错误发生在位置3。通过翻转 $r_{3}$ 来纠正 $r$，得到码字\n$$\n\\hat{c}=r+e_{3}=(0,0,1,1,0,0,1),\n$$\n其中 $e_{3}$ 是在位置3为1的单位向量。使用 $c_{3}=d_{1}$，$c_{5}=d_{2}$，$c_{6}=d_{3}$，$c_{7}=d_{4}$ 提取数据位：\n$$\n(d_{1},d_{2},d_{3},d_{4})=(c_{3},c_{5},c_{6},c_{7})=(1,0,0,1).\n$$\n选项 C 对应于 $1001$。快速检验可以确认其有效性：$H\\hat{c}^{T}=\\mathbf{0}$ (在 $\\mathbb{F}_{2}$ 上)。", "answer": "$$\\boxed{C}$$", "id": "1373652"}, {"introduction": "任何纠错码都有其能力边界，汉明码也不例外。它被设计用来完美纠正单个比特错误，但如果出现多个错误会发生什么？这个练习模拟了一个两位错误的情景，揭示了它可能会如何“误导”解码器，使其产生一个非零伴随式，从而做出错误的“纠正”[@problem_id:1373639]。通过这个实践，你将更深刻地理解汉明码的设计假设及其在现实应用中的局限性。", "problem": "一个通信系统使用一种（7,4）系统汉明码来传输4位数据字。一个7位码字 $c = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$ 由一个4位数据字构成，该数据字的比特被放置在码字的位置3、5、6和7。三个奇偶校验位被计算并放置在位置1、2和4。因此，码字位的排列方式为 $c = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$，其中 $c_1, c_2, c_4$ 是奇偶校验位。奇偶校验位使用以下偶校验方程计算，其中 $\\oplus$ 表示异或（XOR）操作：\n$c_1 \\oplus c_3 \\oplus c_5 \\oplus c_7 = 0$\n$c_2 \\oplus c_3 \\oplus c_6 \\oplus c_7 = 0$\n$c_4 \\oplus c_5 \\oplus c_6 \\oplus c_7 = 0$\n\n接收到一个7位字 $y = (y_1, y_2, y_3, y_4, y_5, y_6, y_7)$ 后，接收器按如下方式计算一个3位伴随式（syndrome） $s = (s_1, s_2, s_3)$：\n$s_1 = y_4 \\oplus y_5 \\oplus y_6 \\oplus y_7$\n$s_2 = y_2 \\oplus y_3 \\oplus y_6 \\oplus y_7$\n$s_3 = y_1 \\oplus y_3 \\oplus y_5 \\oplus y_7$\n\n该解码系统设计为最多纠正一个比特错误。如果伴随式 $s$ 为 $(0,0,0)$，则该字被接受为正确。如果 $s$ 非零，则它被解释为单个错误比特位置的二进制表示，其中 $s_1$ 是最高有效位。例如，伴随式 $(1,0,1)$ 表示在比特位置5有一个错误。解码器然后翻转所指示位置的比特以尝试纠正。\n\n假设用于位置 $(3, 5, 6, 7)$ 的4位数据字为 $(1, 0, 1, 1)$，它被编码为其对应的码字 $c$。在传输过程中，码字被损坏，使得位置3和6的比特被翻转。接收器的单比特纠错解码器将识别出哪个比特位置有错误？", "solution": "该码是一种系统汉明码，数据位放置在位置 $3,5,6,7$，奇偶校验位放置在位置 $1,2,4$。偶校验方程为\n$$c_{1} \\oplus c_{3} \\oplus c_{5} \\oplus c_{7} = 0,$$\n$$c_{2} \\oplus c_{3} \\oplus c_{6} \\oplus c_{7} = 0,$$\n$$c_{4} \\oplus c_{5} \\oplus c_{6} \\oplus c_{7} = 0.$$\n当数据位为 $(c_{3},c_{5},c_{6},c_{7})=(1,0,1,1)$ 时，求解奇偶校验位：\n$$c_{1} = c_{3} \\oplus c_{5} \\oplus c_{7} = 1 \\oplus 0 \\oplus 1 = 0,$$\n$$c_{2} = c_{3} \\oplus c_{6} \\oplus c_{7} = 1 \\oplus 1 \\oplus 1 = 1,$$\n$$c_{4} = c_{5} \\oplus c_{6} \\oplus c_{7} = 0 \\oplus 1 \\oplus 1 = 0.$$\n因此，传输的码字是\n$(c_{1},c_{2},c_{3},c_{4},c_{5},c_{6},c_{7})=(0,1,1,0,0,1,1)$。\n在传输过程中，位置 $3$ 和 $6$ 的比特被翻转，得到接收到的字\n$(y_{1},y_{2},y_{3},y_{4},y_{5},y_{6},y_{7})=(0,1,0,0,0,0,1)$。\n伴随式计算如下\n$$s_{1}=y_{4} \\oplus y_{5} \\oplus y_{6} \\oplus y_{7}=0 \\oplus 0 \\oplus 0 \\oplus 1=1,$$\n$$s_{2}=y_{2} \\oplus y_{3} \\oplus y_{6} \\oplus y_{7}=1 \\oplus 0 \\oplus 0 \\oplus 1=0,$$\n$$s_{3}=y_{1} \\oplus y_{3} \\oplus y_{5} \\oplus y_{7}=0 \\oplus 0 \\oplus 0 \\oplus 1=1。$$\n因此 $s=(s_{1},s_{2},s_{3})=(1,0,1)$，其中 $s_{1}$ 为最高有效位，这是位置 $5$ 的二进制表示。因此，单比特纠错解码器将识别出比特位置 $5$ 存在错误。", "answer": "$$\\boxed{5}$$", "id": "1373639"}]}