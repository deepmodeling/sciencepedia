## 引言
布尔函数与表达式是[离散数学](@entry_id:149963)和计算机科学的基石，为数字世界提供了基本的语言和逻辑框架。从智能手机中的微处理器到保护我们在线[通信安全](@entry_id:265098)的复杂算法，[布尔逻辑](@entry_id:143377)无处不在，它将复杂的现实世界问题转化为可以用0和1精确描述和解决的形式。然而，要真正驾驭其力量，仅仅了解基本的“与”、“或”、“非”操作是远远不够的。我们需要一个系统性的方法来分析、简化和应用这些函数，以设计出高效、可靠且安全的系统。本文旨在填补这一知识空白，引导读者从基础原理走向高级应用。

本文将分三步深入探讨布尔函数的世界。在“原理与机制”一章中，我们将建立坚实的理论基础，学习函数的规范表示法、关键属性以及判断算子表达能力的强大工具。接着，在“应用与跨学科联系”一章中，我们将看到这些抽象理论如何转化为[数字电路设计](@entry_id:167445)、密码学、信息论甚至社会科学中的具体解决方案。最后，“动手实践”部分将提供精选的练习，帮助您巩固所学知识，并将其应用于解决实际问题。

## 原理与机制

在对[布尔函数](@entry_id:276668)的初步介绍之后，我们现在将深入探讨其结构性的原理和核心机制。理解这些原理对于函数的分析、简化以及在[数字逻辑设计](@entry_id:141122)、算法和计算复杂性理论中的应用至关重要。本章将系统地阐述[布尔函数](@entry_id:276668)的标准表示方法，探讨其关键的内在属性，并最终引入一个强大的理论框架，用于判断任意一组逻辑算子的[表达能力](@entry_id:149863)。

### [布尔函数](@entry_id:276668)的规范表示法

尽管一个[布尔函数](@entry_id:276668)可以通过多种代数表达式来描述，但为了实现[标准化](@entry_id:637219)和系统性分析，我们通常采用两种规范形式（Canonical Forms）：[析取范式](@entry_id:151536)（Sum-of-Products, SOP）和[合取范式](@entry_id:148377)（Product-of-Sums, POS）。这两种形式都直接源于函数最根本的定义——[真值表](@entry_id:145682)。

#### [析取范式](@entry_id:151536)（SOP）与最小项

任何一个[布尔函数](@entry_id:276668)都可以被唯一地表示为其所有使其值为 $1$ 的输入组合的总和。这种表示形式的核心是 **最小项 (minterm)**。对于一个 $n$ 变量的布尔函数，一个最小项是一个包含所有 $n$ 个变量的乘积项（逻辑与），其中每个变量以其原形或反演（取反）形式出现。每个[最小项](@entry_id:178262)的性质是，它仅对唯一一种输入组合求值为 $1$。

具体来说，对于输入向量 $(x_1, x_2, \dots, x_n)$，对应的最小项 $m_i$ 的构造规则是：如果 $x_j=1$，则变量 $x_j$ 在乘积项中以原形出现；如果 $x_j=0$，则以其反演形式 $x_j'$ 出现。函数的 **[析取范式](@entry_id:151536) (SOP)**，也称为 **主[析取范式](@entry_id:151536) (canonical SOP form)**，就是所有使函数输出为 $1$ 的最小项的逻辑和（逻辑或）。

让我们考虑一个实际场景：一个保险库的数字锁控制系统，其开启取决于三个独立的传感器 $a, b, c$ [@problem_id:1353544]。该锁仅在以下三种精确条件下打开，即函数 $L(a,b,c)=1$：
1.  传感器 $A$ 不活跃 ($a=0$)，而 $B$ 和 $C$ 都活跃 ($b=1, c=1$)。
2.  传感器 $B$ 不活跃 ($b=0$)，而 $A$ 和 $C$ 都活跃 ($a=1, c=1$)。
3.  传感器 $C$ 不活跃 ($c=0$)，而 $A$ 和 $B$ 都活跃 ($a=1, b=1$)。

我们可以为每个条件写出对应的[最小项](@entry_id:178262)：
1.  对于输入 $(0,1,1)$，最小项是 $a'bc$。
2.  对于输入 $(1,0,1)$，[最小项](@entry_id:178262)是 $ab'c$。
3.  对于输入 $(1,1,0)$，最小项是 $abc'$。

由于只有这三种情况能使锁打开，因此该锁的[控制函数](@entry_id:183140) $L(a,b,c)$ 的[析取范式](@entry_id:151536)就是这三个最小项的逻辑和：
$L(a,b,c) = a'bc + ab'c + abc'$

这个表达式是“规范的”，因为它直接反映了真值表中所有值为 $1$ 的行。这个特定函数的“权重”（即输出为 $1$ 的输入组合数量）为 $3$。

有时，我们会从一个非规范的表达式开始。例如，一个[环境监测](@entry_id:196500)无人机的逻辑 $F = AB + C'$ [@problem_id:1353562]。要将其转换为[析取范式](@entry_id:151536)，我们需要确保每一项都包含所有变量（$A, B, C$）。我们可以通过应用[布尔代数](@entry_id:168482)恒等式 $X = X \cdot 1 = X(Y+Y')$ 来引入缺失的变量。
对于第一项 $AB$，它缺少变量 $C$：
$AB = AB(C+C') = ABC + ABC'$

对于第二项 $C'$，它缺少变量 $A$ 和 $B$：
$C' = C'(A+A') = AC' + A'C' = (AC' + A'C')(B+B') = AB C' + AB'C' + A'BC' + A'B'C'$

合并所有项并使用[幂等律](@entry_id:269266) $X+X=X$ 消除重复项 $ABC'$，我们得到完整的[析取范式](@entry_id:151536)：
$F(A,B,C) = A'B'C' + A'BC' + AB'C' + ABC' + ABC$

#### [合取范式](@entry_id:148377)（POS）与[最大项](@entry_id:171771)

与[析取范式](@entry_id:151536)对偶地，任何布尔函数也可以表示为其所有使其值为 $0$ 的输入组合的积。这种表示形式的基础是 **[最大项](@entry_id:171771) (maxterm)**。一个[最大项](@entry_id:171771)是一个包含所有 $n$ 个变量的逻辑和项（逻辑或）。每个[最大项](@entry_id:171771)的性质是，它仅对唯一一种输入组合求值为 $0$。

[最大项](@entry_id:171771)的构造规则与[最小项](@entry_id:178262)相反：对于输入向量 $(x_1, x_2, \dots, x_n)$，对应的[最大项](@entry_id:171771) $M_i$ 的构造规则是：如果 $x_j=0$，则变量 $x_j$ 在和项中以原形出现；如果 $x_j=1$，则以其反演形式 $x_j'$ 出现。函数的 **[合取范式](@entry_id:148377) (POS)**，也称为 **主[合取范式](@entry_id:148377) (canonical POS form)**，是所有使函数输出为 $0$ 的[最大项](@entry_id:171771)的逻辑积（逻辑与）。

例如，一个诊断系统警报协议 $F(x,y,z)$ 仅当三个子系统中恰好有一个报告异常时才触发（$F=1$）[@problem_id:1353539]。要找到其[合取范式](@entry_id:148377)，我们首先需要确定哪些输入组合使 $F=0$。通过构建[真值表](@entry_id:145682)，我们发现 $F=0$ 发生在输入中 $1$ 的个数为 $0, 2, 3$ 的情况下：
*   $(0,0,0) \Rightarrow F=0$
*   $(0,1,1) \Rightarrow F=0$
*   $(1,0,1) \Rightarrow F=0$
*   $(1,1,0) \Rightarrow F=0$
*   $(1,1,1) \Rightarrow F=0$

现在我们为每一个 $F=0$ 的行构造对应的[最大项](@entry_id:171771)：
*   输入 $(0,0,0)$ 对应的[最大项](@entry_id:171771)是 $(x+y+z)$。
*   输入 $(0,1,1)$ 对应的[最大项](@entry_id:171771)是 $(x+y'+z')$。
*   输入 $(1,0,1)$ 对应的[最大项](@entry_id:171771)是 $(x'+y+z')$。
*   输入 $(1,1,0)$ 对应的[最大项](@entry_id:171771)是 $(x'+y'+z)$。
*   输入 $(1,1,1)$ 对应的[最大项](@entry_id:171771)是 $(x'+y'+z')$。

因此，$F(x,y,z)$ 的完整[合取范式](@entry_id:148377)是这些[最大项](@entry_id:171771)的逻辑积：
$F(x,y,z) = (x+y+z)(x+y'+z')(x'+y+z')(x'+y'+z)(x'+y'+z')$

#### 最小项与[最大项](@entry_id:171771)索引

对于一个 $n$ 变量的函数，总共有 $2^n$ 种可能的输入组合。我们可以将每种输入组合 $(x_1, \dots, x_n)$ 解释为一个二进制数，从而为每个组合分配一个从 $0$ 到 $2^n-1$ 的唯一 **索引 (index)**。例如，对于三变量函数 $F(x,y,z)$，输入 $(1,0,1)$ 对应于二进制数 $101_2$，即十进制的 $5$。

*   **最小项列表** $\sum m(\dots)$ 列出了所有使函数为 $1$ 的输入的索引。
*   **[最大项](@entry_id:171771)列表** $\prod M(\dots)$ 列出了所有使函数为 $0$ 的输入的索引。

这两个集合之间存在一个基本且重要的关系：它们是[全集](@entry_id:264200) $U = \{0, 1, \dots, 2^n-1\}$ 的 **补集**。这意味着，如果一个函数由其[最小项](@entry_id:178262)索引集合定义，那么其[最大项](@entry_id:171771)索引集合就是全集中所有未出现的索引。

例如，如果一个四变量函数 $F(w,x,y,z)$ 的[最小项](@entry_id:178262)索引列表为 $\sum m(0, 2, 5, 7, 8, 10, 13, 15)$ [@problem_id:1353529]，这意味着当输入对应的十[进制](@entry_id:634389)值为这些数时，$F=1$。由于四变量函数有 $2^4=16$ 个可能的输入（索引从 $0$ 到 $15$），那么使 $F=0$ 的输入索引集合必然是全集 $\{0, \dots, 15\}$ 中除去最小项索引后的剩余部分。因此，其[最大项](@entry_id:171771)索引列表为：
$\prod M(1, 3, 4, 6, 9, 11, 12, 14)$

这种互补关系为在SOP和POS表示之间进行转换提供了一条捷径，而无需进行繁琐的代数运算。

### 布尔函数的基本属性

除了它们的[代数表示](@entry_id:143783)之外，布尔函数还可以根据其固有的结构对称性和行为来进行分类。这些属性不仅具有理论上的重要性，而且在[电路优化](@entry_id:176944)和[可满足性问题](@entry_id:262806)等领域也有实际应用。

#### 对偶性与[自对偶函数](@entry_id:178669)

**[对偶原理](@entry_id:276615) (Principle of Duality)** 是布尔代数中的一个基本概念。它指出，对于任何一个有效的布尔等式，通过交换其中的 $\land$ 和 $\lor$ 运算符，并交换常量 $0$ 和 $1$，我们能得到另一个同样有效的布尔等式。这个原理可以推广到任意[布尔表达式](@entry_id:262805)，以获得其 **对偶 (dual)** 表达式。

一个表达式 $F$ 的对偶 $F^d$ 的构造规则是 [@problem_id:1353564]：
1.  将每个 $\land$ 运算符替换为 $\lor$。
2.  将每个 $\lor$ 运算符替换为 $\land$。
3.  将每个常量 $0$ 替换为 $1$。
4.  将每个常量 $1$ 替换为 $0$。
5.  变量及其反演形式保持不变。

例如，考虑表达式 $F(x, y, z) = (x \land y') \lor (z \land 1) \lor 0$。其对偶表达式 $F^d$ 是：
$F^d(x, y, z) = (x \lor y') \land (z \lor 0) \land 1$
利用[布尔代数](@entry_id:168482)恒等式（$a \lor 0 = a$ 和 $a \land 1 = a$），我们可以简化这个对偶表达式为：
$F^d(x, y, z) = (x \lor y') \land z$

一个特别有趣的属性是 **[自对偶性](@entry_id:140268) (self-duality)**。一个 $n$ 变量[布尔函数](@entry_id:276668) $f$ 被称为自对偶的，如果它满足以下条件：
$f(x_1, x_2, \dots, x_n) = \neg f(\neg x_1, \neg x_2, \dots, \neg x_n)$
这意味着，将所有输入变量取反，其效果等同于将原始输出取反。从真值表的角度看，如果输入向量 $\mathbf{v}$ 和其“对跖点”向量 $\neg \mathbf{v}$（所有位都取反）对应的函数值总是相反的，那么该函数就是自对偶的。

两个经典的[自对偶函数](@entry_id:178669)例子是 [@problem_id:1353558]：
1.  **多数表决函数**: $g(x,y,z) = (x \land y) \lor (y \land z) \lor (z \land x)$。这个函数当且仅当至少两个输入为 $1$ 时输出为 $1$。如果输入 $(x,y,z)$ 中有 $k$ 个 $1$，那么其反转输入 $(\neg x, \neg y, \neg z)$ 中就有 $3-k$ 个 $1$。$g(x,y,z)=1$ 当且仅当 $k \ge 2$，而 $g(\neg x, \neg y, \neg z)=1$ 当且仅当 $3-k \ge 2$，即 $k \le 1$。这恰好是 $g(x,y,z)=0$ 的条件，因此 $\neg g(\neg x, \neg y, \neg z) = g(x,y,z)$。
2.  **奇偶校验函数**: $k(x,y,z) = x \oplus y \oplus z$。这个函数当且仅当奇数个输入为 $1$ 时输出为 $1$。利用代数性质 $\neg a = a \oplus 1$，可以证明 $k(\neg x, \neg y, \neg z) = (\neg x) \oplus (\neg y) \oplus (\neg z) = (x \oplus 1) \oplus (y \oplus 1) \oplus (z \oplus 1) = (x \oplus y \oplus z) \oplus (1 \oplus 1 \oplus 1) = k(x,y,z) \oplus 1 = \neg k(x,y,z)$。

#### [单调性](@entry_id:143760)

**单调性 (monotonicity)** 描述了函数输出如何响应输入的“增加”。首先，我们需要在布尔向量上定义一个偏[序关系](@entry_id:138937)。对于两个布尔向量 $\mathbf{u}=(u_1, \dots, u_n)$ 和 $\mathbf{v}=(v_1, \dots, v_n)$，我们说 $\mathbf{u} \le \mathbf{v}$ 当且仅当对于所有的 $i=1, \dots, n$ 都有 $u_i \le v_i$（其中 $0 \le 1$）。直观上，这意味着从 $\mathbf{u}$ 到 $\mathbf{v}$ 的变化中，没有任何一位是从 $1$ 变为 $0$。

一个布尔函数 $f$ 被称为 **单调递增 (monotone increasing)** 的，如果对于其定义域中的任意一对输入向量 $\mathbf{u}$ 和 $\mathbf{v}$，只要 $\mathbf{u} \le \mathbf{v}$，就必有 $f(\mathbf{u}) \le f(\mathbf{v})$ [@problem_id:1353524]。换句话说，将任何一个输入位从 $0$ 变为 $1$（同时保持其他位不变），函数的输出永远不会从 $1$ 变为 $0$。

一个判断单调性的简单句法规则是：**如果一个[布尔表达式](@entry_id:262805)仅由变量的原形（没有反演）以及 $\land$ 和 $\lor$ 运算符构成，那么它一定是单调的。** 这是因为 $\land$ 和 $\lor$ 运算符本身对于它们的每个参数都是单调的。

例如，函数 $f_C(x,y,z) = (x \land y) \lor (y \land z) \lor (z \land x)$ 和 $f_B(x,y,z) = (x \lor y) \land (x \lor z)$ 都是单调的，因为它们没有使用任何取反操作 [@problem_id:1353524]。

要证明一个函数 **不是** 单调的，只需找到一个反例。例如，考虑函数 $f_A(x,y,z) = (x \land y) \lor (\neg x \land z)$。让我们选择输入 $\mathbf{u}=(0,0,1)$ 和 $\mathbf{v}=(1,0,1)$。显然，$\mathbf{u} \le \mathbf{v}$，因为只有第一个分量从 $0$ 增加到 $1$。但是，计算函数值：
$f_A(\mathbf{u}) = (0 \land 0) \lor (1 \land 1) = 1$
$f_A(\mathbf{v}) = (1 \land 0) \lor (0 \land 1) = 0$
由于 $f_A(\mathbf{u}) > f_A(\mathbf{v})$，这违反了[单调性](@entry_id:143760)的定义。因此，$f_A$ 不是单调函数。表达式中出现变量的反演形式（如 $\neg x$）是函数可能非单调的一个强烈信号。

#### 对称性

一个 $n$ 变量的[布尔函数](@entry_id:276668) $f(x_1, \dots, x_n)$ 被称为 **对称的 (symmetric)**，如果其输出值仅取决于输入变量中为 $1$ 的 **数量**（即输入的[汉明权重](@entry_id:265886)），而与这些 $1$ 所在的 **具体位置** 无关。换句话说，任意交换输入变量的位置，函数的输出都保持不变。例如，如果一个三变量函数 $f(x,y,z)$ 是对称的，那么必然有 $f(1,0,0) = f(0,1,0) = f(0,0,1)$。

许多通过“计数”来定义的函数天然就是对称的 [@problem_id:1353526]。
*   $F_A(w,x,y,z)$：当且仅当恰好一个输入为真时为真。此函数的输出仅依赖于输入中 $1$ 的个数是否为 $1$，因此它是对称的。
*   $F_B(w,x,y,z)$：当且仅当为真的输入个数是偶数（0, 2, 或 4）时为真。这同样只依赖于输入中 $1$ 的个数，所以它也是对称的。

要证明一个函数 **不是** 对称的，我们只需找到两个[汉明权重](@entry_id:265886)相同但函数输出不同的输入向量。
*   $F_C(w,x,y,z) = w \lor \text{odd}(x,y,z)$。考虑两个权重为 $2$ 的输入：$(1,1,0,0)$ 和 $(0,1,1,0)$。
    *   $F_C(1,1,0,0) = 1 \lor \text{odd}(1,0,0) = 1 \lor 1 = 1$。
    *   $F_C(0,1,1,0) = 0 \lor \text{odd}(1,1,0) = 0 \lor 0 = 0$。
    权重相同，输出不同，故 $F_C$ 不对称。变量 $w$ 的特殊角色破坏了对称性。
*   $F_D(w,x,y,z) = (w \lor x) \land \neg(y \land z)$。考虑两个权重为 $2$ 的输入：$(1,1,0,0)$ 和 $(0,0,1,1)$。
    *   $F_D(1,1,0,0) = (1 \lor 1) \land \neg(0 \land 0) = 1 \land 1 = 1$。
    *   $F_D(0,0,1,1) = (0 \lor 0) \land \neg(1 \land 1) = 0 \land 0 = 0$。
    权重相同，输出不同，故 $F_D$ 也不对称。

### [功能完备性](@entry_id:138720)与波斯特判据

一个核心的理论问题是：给定一组布尔运算符，是否可以用它们来构造出任意一个[布尔函数](@entry_id:276668)？如果可以，我们称这个算[子集](@entry_id:261956)合是 **功能完备的 (functionally complete)**。例如，众所周知，$\{\land, \lor, \neg\}$ 是一个功能完备集。了解[功能完备性](@entry_id:138720)对于设计[通用计算](@entry_id:275847)设备至关重要。

证明一个集合是功能完备的一种方法是，用它来构造出一个已知的完备集。例如，要证明集合 $\{\rightarrow, 0\}$（其中 $\rightarrow$ 是蕴含，$0$ 是常数假）是功能完备的，我们可以展示如何用它来构造 $\neg$ 和 $\land$ [@problem_id:1353568]。
*   **构造 NOT**: $\neg p \equiv p \rightarrow 0$。
*   **构造 AND**: $p \land q \equiv \neg(p \rightarrow \neg q) \equiv (p \rightarrow (q \rightarrow 0)) \rightarrow 0$。
既然可以构造出 $\{\neg, \land\}$，那么 $\{\rightarrow, 0\}$ 也是功能完备的。作为练习，我们可以用它来构造更复杂的函数，如[异或](@entry_id:172120) (XOR) $x \oplus y$：
$x \oplus y \equiv \neg(x \leftrightarrow y) \equiv \neg((x \rightarrow y) \land (y \rightarrow x))$
利用[德摩根定律](@entry_id:138529)和蕴含的定义，$\neg(A \land B)$ 等价于 $A \rightarrow \neg B$。结合我们已有的 $\neg p \equiv p \rightarrow 0$ 规则，可以将表达式翻译为：
$x \oplus y \equiv (x \rightarrow y) \rightarrow ((y \rightarrow x) \rightarrow 0)$

虽然这种构造法是可行的，但它可能很繁琐。Emil Post 在20世纪早期提供了一个更为优雅和强大的非构造性方法，即 **波斯特判据 (Post's Criterion)**。该判据基于 **波斯特格 (Post's Lattice)** 的理论，它对所有[布尔函数](@entry_id:276668)“克隆”（在[函数复合](@entry_id:144881)下封闭的函数集）进行了完整分类。判据的核心是五个特殊的函数集合，称为 **最大克隆 (maximal clones)** 或 **波斯特类 (Post's classes)**。

一个函数集合是功能完备的，当且仅当它不完全包含在这五个最大克隆中的任何一个之内。这五个集合是 [@problem_id:1353543]：
1.  **$T_0$ 类 (0-保持函数)**: 所有满足 $f(0, 0, \dots, 0) = 0$ 的函数。
2.  **$T_1$ 类 (1-保持函数)**: 所有满足 $f(1, 1, \dots, 1) = 1$ 的函数。
3.  **$S$ 类 ([自对偶函数](@entry_id:178669))**: 所有满足 $f(\neg x_1, \dots, \neg x_n) = \neg f(x_1, \dots, x_n)$ 的函数。
4.  **$M$ 类 ([单调函数](@entry_id:145115))**: 所有单调递增的函数。
5.  **$L$ 类 (线性函数)**: 所有可以表示为变量的[异或](@entry_id:172120)和加上一个常数（$c_0 \oplus c_1 x_1 \oplus \dots \oplus c_n x_n$）的函数。

要判断一个函数属于哪个类别，我们只需逐一检验其是否满足每个类的定义。注意，前四个类别（$T_0, T_1, S, M$）正是我们之前讨论过的基本属性。第五类，**线性函数**，可以通过将其转换为 **代数[范式](@entry_id:161181) (Algebraic Normal Form, ANF)** 来检验。ANF 是将函数表示为变量乘积的[异或](@entry_id:172120)和。如果一个函数的ANF中所有项的次数都不超过1（即没有类似 $x_1x_2$ 的项），那么该函数就是线性的。

让我们以函数 $g(w, x, y, z) = \neg(w \oplus x) \lor (y \land z)$ 为例，系统地将其归类 [@problem_id:1353543]：
*   **$T_0$ (0-保持性)**: $g(0,0,0,0) = \neg(0 \oplus 0) \lor (0 \land 0) = \neg 0 \lor 0 = 1 \lor 0 = 1$。因为结果不为 $0$，所以 $g \notin T_0$。
*   **$T_1$ (1-保持性)**: $g(1,1,1,1) = \neg(1 \oplus 1) \lor (1 \land 1) = \neg 0 \lor 1 = 1 \lor 1 = 1$。因为结果为 $1$，所以 $g \in T_1$。
*   **$S$ ([自对偶性](@entry_id:140268))**: 我们需要检验 $g(\neg w, \dots, \neg z)$ 是否等于 $\neg g(w, \dots, z)$。如前所述，不满足此条件，故 $g \notin S$。
*   **$M$ (单调性)**: 我们已经看到，改变一个输入（如 $w$ 从 $0$ 到 $1$）可能导致输出从 $1$ 降到 $0$（例如当 $x=y=z=0$时）。因此，$g \notin M$。
*   **$L$ (线性)**: 我们需要找到 $g$ 的ANF。$g = (w \leftrightarrow x) \lor (yz)$。利用 $A \lor B = A \oplus B \oplus AB$，我们有 $g = (1 \oplus w \oplus x) \oplus yz \oplus ((1 \oplus w \oplus x)yz)$。展开后得到 $g = 1 \oplus w \oplus x \oplus wyz \oplus xyz$。因为ANF中包含了次数为 $3$ 的项（$wyz$ 和 $xyz$），所以 $g$ 不是线性函数，$g \notin L$。

综上所述，函数 $g$ 仅属于 $T_1$ 这一个最大克隆。这意味着，如果我们将函数 $g$ 添加到一个函数集合中，它将“打破” $T_0, S, M, L$ 这四个属性的封闭性。根据波斯特判据，要形成一个功能完备集，我们还需要至少一个不属于 $T_1$ 的函数。这个强大的框架将我们对布尔函数各种离散属性的理解统一到了一个关于计算[表达能力](@entry_id:149863)的宏大理论之中。