{"hands_on_practices": [{"introduction": "米利机（Mealy machine）设计的核心在于如何利用状态来记忆关键的输入历史。本练习将引导你设计一个能够识别特定序列的米利机。通过将“检测到连续第三个‘a’”这一具体要求转化为一个正式的状态转换和输出表，你将实践如何定义每个状态所代表的“记忆”，这是从需求到实现的关键一步。[@problem_id:1383551]", "problem": "Mealy机是一种有限状态机，其输出值由当前状态和当前输入共同决定。它被正式定义为一个六元组 $(S, S_0, \\Sigma, \\Omega, \\delta, \\lambda)$，其中：\n- $S$ 是一个有限的状态集合。\n- $S_0 \\in S$ 是起始状态。\n- $\\Sigma$ 是一个称为输入字母表的有限集合。\n- $\\Omega$ 是一个称为输出字母表的有限集合。\n- $\\delta: S \\times \\Sigma \\to S$ 是状态转移函数。\n- $\\lambda: S \\times \\Sigma \\to \\Omega$ 是输出函数。\n\n考虑一个设计为Mealy机的简单数据流监控系统。该系统处理来自输入字母表 $\\Sigma = \\{a, b\\}$ 的字符输入流，并从输出字母表 $\\Omega = \\{0, 1\\}$ 中产生输出。该系统旨在检测一个特定模式：如果当前输入字符是流中连续的第三个 'a'，则必须输出 '1'；在所有其他情况下，必须输出 '0'。\n\n该机器使用三个状态，$S = \\{S_0, S_1, S_2\\}$，其中 $S_0$ 是起始状态。每个状态的含义如下：\n- $S_0$：初始状态。如果到目前为止处理的输入字符串不以 'a' 结尾（即，为空或以 'b' 结尾），则机器处于此状态。\n- $S_1$：如果到目前为止处理的输入字符串恰好以一个 'a' 结尾，则机器处于此状态。\n- $S_2$：如果到目前为止处理的输入字符串恰好以两个连续的 'a' 结尾，则机器处于此状态。\n\n以下哪个表格正确表示了此Mealy机的转移函数 $\\delta$（下一个状态）和输出函数 $\\lambda$（输出）？\n\nA.\n| 当前状态 | 输入 | 下一个状态 | 输出 |\n| :--- | :--- | :--- | :--- |\n| $S_0$ | a | $S_1$ | 0 |\n| $S_0$ | b | $S_0$ | 0 |\n| $S_1$ | a | $S_2$ | 0 |\n| $S_1$ | b | $S_0$ | 0 |\n| $S_2$ | a | $S_2$ | 1 |\n| $S_2$ | b | $S_0$ | 0 |\n\nB.\n| 当前状态 | 输入 | 下一个状态 | 输出 |\n| :--- | :--- | :--- | :--- |\n| $S_0$ | a | $S_1$ | 0 |\n| $S_0$ | b | $S_0$ | 0 |\n| $S_1$ | a | $S_2$ | 0 |\n| $S_1$ | b | $S_0$ | 0 |\n| $S_2$ | a | $S_0$ | 1 |\n| $S_2$ | b | $S_0$ | 0 |\n\nC.\n| 当前状态 | 输入 | 下一个状态 | 输出 |\n| :--- | :--- | :--- | :--- |\n| $S_0$ | a | $S_1$ | 0 |\n| $S_0$ | b | $S_0$ | 0 |\n| $S_1$ | a | $S_2$ | 1 |\n| $S_1$ | b | $S_0$ | 0 |\n| $S_2$ | a | $S_2$ | 0 |\n| $S_2$ | b | $S_0$ | 0 |\n\nD.\n| 当前状态 | 输入 | 下一个状态 | 输出 |\n| :--- | :--- | :--- | :--- |\n| $S_0$ | a | $S_1$ | 0 |\n| $S_0$ | b | $S_0$ | 0 |\n| $S_1$ | a | $S_2$ | 0 |\n| $S_1$ | b | $S_1$ | 0 |\n| $S_2$ | a | $S_2$ | 1 |\n| $S_2$ | b | $S_0$ | 0 |", "solution": "我们使用Mealy机的定义：输出取决于当前状态和当前输入。“当且仅当当前输入字符是连续的第三个a时输出1”这一要求意味着：\n- 唯一产生输出1的情况是：在读取当前输入之前，我们已经在已处理前缀的末尾看到了恰好两个连续的a，并且当前输入是a。\n- 在所有其他状态-输入对中，输出必须为0。\n\n根据给定的状态的预期作用：\n- $S_{0}$ 表示已处理的前缀以零个连续的a结尾（即，为空或以b结尾）。\n- $S_{1}$ 表示已处理的前缀恰好以一个连续的a结尾。\n- $S_{2}$ 表示已处理的前缀恰好以两个连续的a结尾。\n\n因此，输出函数 $\\lambda$ 必须满足：\n- $\\lambda(S_{2}, a) = 1$，\n- 并且对于所有其他对 $(S, x) \\in \\{S_{0}, S_{1}, S_{2}\\} \\times \\{a, b\\}$ 且 $(S, x) \\neq (S_{2}, a)$，有 $\\lambda(S, x) = 0$。\n\n接下来，我们通过计算读取当前输入后字符串以多少个连续的a结尾来推导转移函数 $\\delta$：\n- 从 $S_{0}$ 开始：\n  - 输入为 $a$ 时：新的后缀计数为 $1$，因此 $\\delta(S_{0}, a) = S_{1}$。\n  - 输入为 $b$ 时：新的后缀计数为 $0$，因此 $\\delta(S_{0}, b) = S_{0}$。\n- 从 $S_{1}$ 开始：\n  - 输入为 $a$ 时：新的后缀计数为 $2$，因此 $\\delta(S_{1}, a) = S_{2}$。\n  - 输入为 $b$ 时：新的后缀计数为 $0$，因此 $\\delta(S_{1}, b) = S_{0}$。\n- 从 $S_{2}$ 开始：\n  - 输入为 $a$ 时：此输入是连续的第三个a，因此 $\\lambda(S_{2}, a) = 1$。处理完这个a之后，已处理的字符串以至少三个a结尾。在只有三个状态的情况下，为了继续正确检测任何后续的a（同时保留在当前a之前至少有两个a时发出1的能力），标准的构造是在输入a时保持在 $S_{2}$ 状态，即 $\\delta(S_{2}, a) = S_{2}$。\n  - 输入为 $b$ 时：新的后缀计数为 $0$，因此 $\\delta(S_{2}, b) = S_{0}$，并且 $\\lambda(S_{2}, b) = 0$。\n\n将这些组合在一起，得出下表：\n- $S_{0}$ 输入 $a$：下一个状态 $S_{1}$，输出 $0$。\n- $S_{0}$ 输入 $b$：下一个状态 $S_{0}$，输出 $0$。\n- $S_{1}$ 输入 $a$：下一个状态 $S_{2}$，输出 $0$。\n- $S_{1}$ 输入 $b$：下一个状态 $S_{0}$，输出 $0$。\n- $S_{2}$ 输入 $a$：下一个状态 $S_{2}$，输出 $1$。\n- $S_{2}$ 输入 $b$：下一个状态 $S_{0}$，输出 $0$。\n\n与选项比较，这完全对应于选项A。选项B、C和D各自违反了推导出的条件之一：\n- B 错误地将 $(S_{2}, a)$ 转移到 $S_{0}$，这会中断对连续a的正确追踪。\n- C 错误地在 $(S_{1}, a)$ 上输出 $1$，将第二个a当作第三个。\n- D 错误地在输入b时将状态 $(S_{1}, b)$ 保持在 $S_{1}$，尽管b应该将连续a的计数重置为零。\n\n因此，A是正确的表格。", "answer": "$$\\boxed{A}$$", "id": "1383551"}, {"introduction": "除了模式识别，米利机还拥有强大的计算能力。这个练习将挑战你设计一个执行算术运算——二进制乘法——的米利机。这里的关键洞见在于，你可以使用状态来存储和传递运算过程中的“进位”（carry），这不仅展示了自动机的通用性，也揭示了抽象模型与数字算术电路之间的深刻联系。[@problem_id:1383549]", "problem": "Mealy机是一种有限状态机，其输出取决于当前状态和当前输入。它可以被形式化地定义为一个六元组 $(S, S_0, \\Sigma, \\Lambda, T, G)$，其中 $S$ 是有限的状态集，$S_0$ 是起始状态，$\\Sigma$ 是输入字母表，$\\Lambda$ 是输出字母表，$T: S \\times \\Sigma \\to S$ 是转移函数，$G: S \\times \\Sigma \\to \\Lambda$ 是输出函数。\n\n考虑一个数字流处理器，其设计用于将任意给定的二进制数乘以3。该处理器以Mealy机实现。它从最低有效位（LSB）开始，一次读取一个整数的二进制表示的一位。对于它读取的每个输入位，它会产生一个输出位。该机器有一个输入字母表 $\\Sigma = \\{0, 1\\}$ 和一个输出字母表 $\\Lambda = \\{0, 1\\}$。\n\n该机器从初始状态 $S_0$ 开始，这对应于零进位条件。状态用 $S_i$ 表示，其中索引 $i$ 代表机器存储的进位值。以下哪个表格正确地描述了执行此乘法操作的最小Mealy机的转移函数 $T$ 和输出函数 $G$？表格条目以（下一状态，输出）的格式呈现。\n\nA)\n| 当前状态 | 输入 0 | 输入 1 |\n|:---:|:---:|:---:|\n| $S_0$ | ($S_0$, 0) | ($S_1$, 1) |\n| $S_1$ | ($S_0$, 1) | ($S_2$, 0) |\n| $S_2$ | ($S_1$, 0) | ($S_2$, 1) |\n\nB)\n| 当前状态 | 输入 0 | 输入 1 |\n|:---:|:---:|:---:|\n| $S_0$ | ($S_0$, 0) | ($S_1$, 1) |\n| $S_1$ | ($S_1$, 1) | ($S_2$, 0) |\n| $S_2$ | ($S_1$, 0) | ($S_0$, 1) |\n\nC)\n| 当前状态 | 输入 0 | 输入 1 |\n|:---:|:---:|:---:|\n| $S_0$ | ($S_0$, 0) | ($S_1$, 1) |\n| $S_1$ | ($S_0$, 1) | ($S_1$, 0) |\n| $S_2$ | ($S_1$, 0) | ($S_2$, 1) |\n\nD)\n| 当前状态 | 输入 0 | 输入 1 |\n|:---:|:---:|:---:|\n| $S_0$ | ($S_0$, 0) | ($S_0$, 1) |\n| $S_1$ | ($S_0$, 1) | ($S_1$, 0) |\n\nE)\n| 当前状态 | 输入 0 | 输入 1 |\n|:---:|:---:|:---:|\n| $S_0$ | ($S_0$, 0) | ($S_1$, 1) |\n| $S_1$ | ($S_0$, 1) | ($S_2$, 0) |\n| $S_2$ | ($S_2$, 0) | ($S_1$, 1) |", "solution": "我们用一个Mealy机来模拟对从最低有效位开始读取的二进制流乘以3的操作，该机器的状态 $S_{i}$ 编码了当前的进位 $i$。设当前输入位为 $b \\in \\{0,1\\}$，当前进位为 $c \\in \\{0,1,2\\}$（因为 $3 \\cdot 1 + 2 = 5$，所以进位最多为2）。在每一步，该比特位的和是\n$$\ns = 3b + c.\n$$\n$s$ 的最低有效位是输出位，所以\n$$\ny = s \\bmod 2,\n$$\n而下一个进位是其更高部分，\n$$\nc' = \\left\\lfloor \\frac{s}{2} \\right\\rfloor.\n$$\n因此，转移到状态 $S_{c'}$ 并输出 $y$。\n\n计算所有情况：\n\n1) 对于 $c=0$：\n- 若 $b=0$：$s=0$, $y=0$, $c'=0$ 得到 $(S_{0},0)$。\n- 若 $b=1$：$s=3$, $y=1$, $c'=1$ 得到 $(S_{1},1)$。\n\n2) 对于 $c=1$：\n- 若 $b=0$：$s=1$, $y=1$, $c'=0$ 得到 $(S_{0},1)$。\n- 若 $b=1$：$s=4$, $y=0$, $c'=2$ 得到 $(S_{2},0)$。\n\n3) 对于 $c=2$：\n- 若 $b=0$：$s=2$, $y=0$, $c'=1$ 得到 $(S_{1},0)$。\n- 若 $b=1$：$s=5$, $y=1$, $c'=2$ 得到 $(S_{2},1)$。\n\n汇总各行：\n\n- $S_{0}$：输入 $0 \\to (S_{0},0)$，输入 $1 \\to (S_{1},1)$。\n- $S_{1}$：输入 $0 \\to (S_{0},1)$，输入 $1 \\to (S_{2},0)$。\n- $S_{2}$：输入 $0 \\to (S_{1},0)$，输入 $1 \\to (S_{2},1)$。\n\n这与选项 A 中的表格完全匹配，且与其他所有选项都不同。三个进位 $\\{0,1,2\\}$ 都是必需的，因此该机器是最小的。", "answer": "$$\\boxed{A}$$", "id": "1383549"}, {"introduction": "设计出状态机后，一个自然的问题是：这个设计是否最优？我们能否用更少的状态实现相同的功能？本练习引入了“状态可区分性”（state distinguishability）这一核心概念，它是状态机最小化的理论基石。通过寻找一个能为两个不同起始状态产生不同输出的输入字符串，你将学会如何证明这两个状态不等价，从而为构建最高效的机器奠定分析基础。[@problem_id:1383517]", "problem": "考虑一个由元组 $(S, \\Sigma, \\Gamma, \\delta, \\lambda)$ 定义的 Mealy 机 $M$，其中：\n- 状态集为 $S = \\{s_0, s_1, s_2, s_3, s_4\\}$。\n- 输入字母表为 $\\Sigma = \\{0, 1\\}$。\n- 输出字母表为 $\\Gamma = \\{a, b\\}$。\n- 转移函数 $\\delta: S \\times \\Sigma \\to S$ 和输出函数 $\\lambda: S \\times \\Sigma \\to \\Gamma$ 由下表指定：\n\n| 当前状态 | 输入 | 下一状态 ($\\delta$) | 输出 ($\\lambda$) |\n|:-------------:|:-----:|:---------------------:|:------------------:|\n|     $s_0$     |   0   |         $s_0$         |         $b$        |\n|     $s_0$     |   1   |         $s_1$         |         $a$        |\n|     $s_1$     |   0   |         $s_2$         |         $a$        |\n|     $s_1$     |   1   |         $s_0$         |         $b$        |\n|     $s_2$     |   0   |         $s_0$         |         $a$        |\n|     $s_2$     |   1   |         $s_3$         |         $b$        |\n|     $s_3$     |   0   |         $s_1$         |         $a$        |\n|     $s_3$     |   1   |         $s_4$         |         $a$        |\n|     $s_4$     |   0   |         $s_3$         |         $a$        |\n|     $s_4$     |   1   |         $s_0$         |         $b$        |\n\n如果存在一个输入字符串 $w$，当机器分别从状态 $s_i$ 和状态 $s_j$ 开始时，产生不同的输出字符串，则称状态 $s_i$ 和 $s_j$ 是可区分的。满足该条件的最短字符串 $w$ 称为最小长度区分字符串。\n\n找出状态对 $(s_1, s_4)$ 的一个最小长度区分字符串。", "solution": "问题要求找出状态 $s_1$ 和 $s_4$ 的一个最小长度区分字符串。一个区分字符串 $w$ 是指，对于该字符串，从 $s_1$ 开始生成的输出序列与从 $s_4$ 开始生成的输出序列不同。我们将通过测试长度从1开始递增的输入字符串来寻找这样的字符串。\n\n我们将扩展输出函数表示为 $\\lambda^*(s, w)$，它表示从状态 $s$ 开始，在输入字符串 $w$ 下生成的输出字符串。我们在寻找满足 $\\lambda^*(s_1, w) \\neq \\lambda^*(s_4, w)$ 的最短字符串 $w$。\n\n**第1步：测试长度为1的字符串。**\n输入字母表为 $\\Sigma = \\{0, 1\\}$，所以长度为1的字符串是 `0` 和 `1`。\n\n- 对于输入字符串 $w = 0$：\n  - 从状态 $s_1$ 开始：输出为 $\\lambda(s_1, 0) = a$。\n  - 从状态 $s_4$ 开始：输出为 $\\lambda(s_4, 0) = a$。\n  - 输出相同。因此，`0` 不是一个区分字符串。\n\n- 对于输入字符串 $w = 1$：\n  - 从状态 $s_1$ 开始：输出为 $\\lambda(s_1, 1) = b$。\n  - 从状态 $s_4$ 开始：输出为 $\\lambda(s_4, 1) = b$。\n  - 输出相同。因此，`1` 不是一个区分字符串。\n\n由于没有长度为1的字符串可以区分 $s_1$ 和 $s_4$，因此区分字符串的最小长度必须大于1。\n\n**第2步：测试长度为2的字符串。**\n在 $\\Sigma$ 上长度为2的字符串有 `00`、`01`、`10` 和 `11`。我们按顺序进行测试。\n\n为了找到字符串 $w = x_1x_2$ 的输出，我们首先从起始状态应用输入 $x_1$，记录输出和新状态，然后从新状态应用输入 $x_2$。\n\n- 对于输入字符串 $w = 00$：\n  - 从 $s_1$ 开始：\n    - 输入 `0`：输出为 $\\lambda(s_1, 0) = a$。新状态为 $\\delta(s_1, 0) = s_2$。\n    - 从 $s_2$ 开始，输入 `0`：输出为 $\\lambda(s_2, 0) = a$。\n    - 总输出字符串 $\\lambda^*(s_1, 00)$ 为 `aa`。\n  - 从 $s_4$ 开始：\n    - 输入 `0`：输出为 $\\lambda(s_4, 0) = a$。新状态为 $\\delta(s_4, 0) = s_3$。\n    - 从 $s_3$ 开始，输入 `0`：输出为 $\\lambda(s_3, 0) = a$。\n    - 总输出字符串 $\\lambda^*(s_4, 00)$ 为 `aa`。\n  - 输出字符串相同。`00` 不是一个区分字符串。\n\n- 对于输入字符串 $w = 01$：\n  - 从 $s_1$ 开始：\n    - 输入 `0`：输出为 $\\lambda(s_1, 0) = a$。新状态为 $\\delta(s_1, 0) = s_2$。\n    - 从 $s_2$ 开始，输入 `1`：输出为 $\\lambda(s_2, 1) = b$。\n    - 总输出字符串 $\\lambda^*(s_1, 01)$ 为 `ab`。\n  - 从 $s_4$ 开始：\n    - 输入 `0`：输出为 $\\lambda(s_4, 0) = a$。新状态为 $\\delta(s_4, 0) = s_3$。\n    - 从 $s_3$ 开始，输入 `1`：输出为 $\\lambda(s_3, 1) = a$。\n    - 总输出字符串 $\\lambda^*(s_4, 01)$ 为 `aa`。\n  - 输出字符串 `ab` 和 `aa` 不同。因此，`01` 是一个区分字符串。\n\n**第3步：结论。**\n我们找到了一个长度为2的区分字符串，即 `01`。由于我们在第1步中表明没有长度为1的字符串可以区分这两个状态，因此区分字符串的最小长度为2。因此，字符串 `01` 是一个最小长度区分字符串。", "answer": "$$\\boxed{01}$$", "id": "1383517"}]}