## 引言
[米利机](@entry_id:177066)（Mealy Machine）是[计算理论](@entry_id:273524)中一种基础而强大的[有限状态自动机](@entry_id:267099)模型。与输出仅由当前状态决定的[摩尔机](@entry_id:170836)不同，[米利机](@entry_id:177066)的独特之处在于其输出同时取决于当前[状态和](@entry_id:193625)当前输入。这一特性使其能够对外部事件做出即时、动态的响应，成为设计各种响应式系统的理想工具，从数字电路中的控制器到复杂的通信协议，其应用无处不在。

然而，要真正掌握[米利机](@entry_id:177066)，仅仅理解其抽象定义是远远不够的。许多学习者在将这一理论模型应用于解决实际问题时会遇到困难。本文旨在填补这一知识鸿沟，提供一个从理论基础到前沿应用的全面指南。我们将系统地引导您穿越[米利机](@entry_id:177066)的世界，不仅揭示其工作原理，更展示其在多个学科中的强大威力。

在接下来的内容中，我们将分三步深入探索：首先，在“原理与机制”一章中，我们将奠定坚实的理论基础，涵盖其形式化定义、执行模拟以及[状态最小化](@entry_id:273227)等核心分析技术。接着，在“应用与跨学科联系”一章中，我们将通过一系列生动的案例，展示[米利机](@entry_id:177066)如何在计算机科学、[数字逻辑](@entry_id:178743)、密码学乃至合成生物学中解决实际问题。最后，通过“动手实践”部分，您将有机会运用所学知识，设计和分析自己的[米利机](@entry_id:177066)，从而将理论真正内化为实践能力。让我们一同开启这段激动人心的学习之旅。

## 原理与机制

在本章中，我们将深入探讨[米利机](@entry_id:177066)（Mealy Machine）的基本原理和核心机制。作为一种关键的[有限状态自动机](@entry_id:267099)模型，[米利机](@entry_id:177066)在[数字逻辑设计](@entry_id:141122)、编译器构造、通信协议以及[计算理论](@entry_id:273524)的多个领域中扮演着核心角色。我们将从其形式化定义出发，逐步学习如何模拟其执行过程，并最终探讨一些高级分析技术，如等价性、[状态最小化](@entry_id:273227)和同步。

### [米利机](@entry_id:177066)的形式化定义

与输出仅由当前状态决定的[摩尔机](@entry_id:170836)（Moore Machine）不同，[米利机](@entry_id:177066)的核心特征在于其**输出同时取决于当前[状态和](@entry_id:193625)当前输入**。这种设计使得[米利机](@entry_id:177066)能够对输入信号做出即时响应，使其在需要对事件进行快速反应的系统中特别有用。

一个[米利机](@entry_id:177066)在形式上被定义为一个六元组 $M = (S, \Sigma, \Gamma, \delta, \lambda, s_0)$，其中：

*   $S$ 是一个有穷的**状态集**。
*   $\Sigma$ 是一个有穷的**输入字母表**，代表机器可以接收的所有可能输入符号。
*   $\Gamma$ 是一个有穷的**输出字母表**，代表机器可以生成的所有可能输出符号。
*   $\delta: S \times \Sigma \to S$ 是**[转移函数](@entry_id:273897)**。对于给定的当前状态 $s \in S$ 和输入符号 $a \in \Sigma$，$\delta(s, a)$ 决定了机器将进入的下一个状态。
*   $\lambda: S \times \Sigma \to \Gamma$ 是**输出函数**。对于给定的当前状态 $s \in S$ 和输入符号 $a \in \Sigma$，$\lambda(s, a)$ 决定了机器在该转移过程中生成的输出符号 [@problem_id:1383537]。这是[米利机](@entry_id:177066)区别于其他有限自动机模型的关键。
*   $s_0 \in S$ 是**初始状态**，即机器在处理任何输入之前的起始状态。

为了将这个抽象定义具体化，让我们考虑一个实际例子：一个可配置的[比特流](@entry_id:164631)处理器。该处理器有两种工作模式：`pass-through` 模式（状态 $S_{pass}$）和 `invert` 模式（状态 $S_{inv}$）。在 $S_{pass}$ 状态下，它原样输出输入的比特；在 $S_{inv}$ 状态下，它输出输入比特的逻辑反。机器的模式根据输入发生变化：输入 `0` 使其保持当前模式，输入 `1` 使其切换到另一种模式。机器的初始状态为 $S_{pass}$。

我们可以根据上述描述构建该[米利机](@entry_id:177066)的形式化六元组定义 [@problem_id:1383539]：

*   **状态集** $S = \{S_{pass}, S_{inv}\}$，代表两种工作模式。
*   **输入字母表** $\Sigma = \{0, 1\}$，代表二[进制](@entry_id:634389)[比特流](@entry_id:164631)。
*   **输出字母表** $\Gamma = \{0, 1\}$，代表机器产生的输出。
*   **初始状态** $s_0 = S_{pass}$。
*   **[转移函数](@entry_id:273897)** $\delta$ 根据模式切换规则定义：
    *   $\delta(S_{pass}, 0) = S_{pass}$ （保持模式）
    *   $\delta(S_{pass}, 1) = S_{inv}$ （切换模式）
    *   $\delta(S_{inv}, 0) = S_{inv}$ （保持模式）
    *   $\delta(S_{inv}, 1) = S_{pass}$ （切换模式）
*   **输出函数** $\lambda$ 根据模式的输出行为定义：
    *   $\lambda(S_{pass}, 0) = 0$ （直通）
    *   $\lambda(S_{pass}, 1) = 1$ （直通）
    *   $\lambda(S_{inv}, 0) = 1$ （反转）
    *   $\lambda(S_{inv}, 1) = 0$ （反转）

这个例子清晰地展示了如何将一个系统的行为描述精确地映射到一个形式化的数学模型中。

### 模拟[米利机](@entry_id:177066)的执行

理解了[米利机](@entry_id:177066)的构成后，下一个关键步骤是学习如何模拟其对输入序列的处理过程。当一个[米利机](@entry_id:177066)接收到一个输入字符串 $w = x_1x_2...x_k$ 时，它从初始状态 $s_0$ 开始，依次处理每个输入符号。

在第 $i$ 步（其中 $i$ 从 $1$ 到 $k$），假设机器处于状态 $s_{i-1}$ 并接收到输入符号 $x_i$，它会：
1.  生成一个输出符号 $y_i = \lambda(s_{i-1}, x_i)$。
2.  转移到一个新的状态 $s_i = \delta(s_{i-1}, x_i)$。

整个过程结束后，机器将产生一个与输入字符串等长的输出字符串 $Y = y_1y_2...y_k$，并停留在最终状态 $s_k$。

让我们通过一个具体的例子来追踪这个过程 [@problem_id:1383558] [@problem_id:1383543]。考虑一个[米利机](@entry_id:177066)，其状态集为 $\{s_0, s_1, s_2\}$，输入字母表为 $\{0, 1\}$，输出字母表为 $\{a, b\}$，初始状态为 $s_0$。其行为规则如下：

*   在 $s_0$ 状态：输入 `0`，转移到 $s_1$，输出 `a`；输入 `1`，停在 $s_0$，输出 `b`。
*   在 $s_1$ 状态：输入 `0`，转移到 $s_2$，输出 `b`；输入 `1`，转移到 $s_0$，输出 `a`。
*   在 $s_2$ 状态：输入 `0`，停在 $s_2$，输出 `a`；输入 `1`，转移到 $s_1$，输出 `b`。

现在，我们来处理输入字符串 `100110`：

1.  **初始状态**: $s_0$。**输入**: `1`。
    *   输出: $\lambda(s_0, 1) = b$。
    *   下一状态: $\delta(s_0, 1) = s_0$。
    *   累计输出: `b`。

2.  **当前状态**: $s_0$。**输入**: `0`。
    *   输出: $\lambda(s_0, 0) = a$。
    *   下一状态: $\delta(s_0, 0) = s_1$。
    *   累计输出: `ba`。

3.  **当前状态**: $s_1$。**输入**: `0`。
    *   输出: $\lambda(s_1, 0) = b$。
    *   下一状态: $\delta(s_1, 0) = s_2$。
    *   累计输出: `bab`。

4.  **当前状态**: $s_2$。**输入**: `1`。
    *   输出: $\lambda(s_2, 1) = b$。
    *   下一状态: $\delta(s_2, 1) = s_1$。
    *   累计输出: `babb`。

5.  **当前状态**: $s_1$。**输入**: `1`。
    *   输出: $\lambda(s_1, 1) = a$。
    *   下一状态: $\delta(s_1, 1) = s_0$。
    *   累计输出: `babba`。

6.  **当前状态**: $s_0$。**输入**: `0`。
    *   输出: $\lambda(s_0, 0) = a$。
    *   下一状态: $\delta(s_0, 0) = s_1$。
    *   累计输出: `babbaa`。

处理完整个输入序列后，机器的最终状态是 $s_1$，生成的完整输出字符串是 `babbaa`。无论是通过规则列表、[状态转移表](@entry_id:163350)还是形式化函数定义，只要信息完整，我们都可以用这种逐步追踪的方式精确地确定任何[米利机](@entry_id:177066)对任意输入序列的响应 [@problem_id:1383511]。

### 等价性、最小化与分析

除了模拟单个机器的行为，我们还经常需要对[米利机](@entry_id:177066)进行更深入的分析，例如比较两个不同的机器或优化一个已有的机器。

#### [米利机](@entry_id:177066)的等价性

我们称两个[米利机](@entry_id:177066) $M_1$ 和 $M_2$ 是**等价的**，如果它们具有相同的输入和输出字母表，并且对于任何可能的输入字符串，它们从各自的初始状态开始，都产生完全相同的输出字符串。

如果两个机器不等价，那么必然存在至少一个输入字符串，它能使两个机器产生不同的输出。这样的字符串被称为**区分字符串**（distinguishing string）。

例如，考虑两台[米利机](@entry_id:177066) $M_1$ 和 $M_2$ [@problem_id:1383529]。$M_1$ 被设计为在输入子串 `bab` 出现时，在其最后一个符号处输出 `1`，否则输出 `0`。$M_2$ 则被设计为在输入子串 `aba` 出现时，在其最后一个符号处输出 `1`。我们可以通过寻找最短区分字符串来证明它们不等价。

*   对于长度为 1 或 2 的任何输入字符串（如 `a`, `b`, `aa`, `ab`, `ba`, `bb`），两个机器都无法识别到长度为 3 的子串，因此它们的输出都将是全零序列，如 `0`，`00`。
*   现在考虑长度为 3 的字符串 `aba`。
    *   $M_1$（检测 `bab`）处理 `aba` 的输出是 `000`。
    *   $M_2$（检测 `aba`）处理 `aba` 的输出是 `001`，因为最后一个 `a` 完成了 `aba` 子串。
*   由于输入 `aba` 产生了不同的输出序列 (`000` vs `001`)，`aba` 是一个区分字符串。由于长度为 1 和 2 的字符串都无法区分它们，`aba` 是一个最短的区分字符串，其长度为 3。

#### [状态等价](@entry_id:261329)性与最小化

在设计数字电路或软件时，我们常常希望用最少的资源实现所需的功能。对于[米利机](@entry_id:177066)而言，这意味着找到一个与给定机器等价且状态数最少的机器。这个过程被称为**[状态最小化](@entry_id:273227)**。

[状态最小化](@entry_id:273227)的基础是**[状态等价](@entry_id:261329)性**的概念。在单个[米利机](@entry_id:177066)中，如果从两个状态 $s_i$ 和 $s_j$ 出发，对于任意输入字符串 $w$，产生的输出序列总是相同的，那么我们称这两个状态是等价的，记作 $s_i \equiv s_j$。

一个常用的[状态最小化](@entry_id:273227)算法是**状态[划分算法](@entry_id:637954)**（partitioning algorithm）。该算法首先根据输出行为对状态进行初始划分，然后通过检查转移行为来不断细化这个划分，直到无法再细化为止。最终的划分中的每一个块（block）都对应于最小化机器的一个状态。

我们通过一个例子来演示这个过程 [@problem_id:1968874]。考虑一个有 6 个状态 $\{S0, S1, S2, S3, S4, S5\}$ 的[米利机](@entry_id:177066)。

1.  **初始划分 ($P_0$)**: 根据输出对 $(z(x=0), z(x=1))$ 进行划分。
    *   $S0$: 输出 $(a, a)$
    *   $S1$: 输出 $(b, a)$
    *   $S2$: 输出 $(a, b)$
    *   $S3$: 输出 $(b, a)$
    *   $S4$: 输出 $(a, b)$
    *   $S5$: 输出 $(a, b)$
    初始划分为 $P_0 = \{\{S0\}, \{S1, S3\}, \{S2, S4, S5\}\}$。我们称这些块为 $A, B, C$。

2.  **第一次细化 ($P_1$)**: 检查每个块内状态的转移目标是否在相同的块中。
    *   块 $B=\{S1, S3\}$:
        *   $S1$: 输入 `0` 转移到 $S4 \in C$，输入 `1` 转移到 $S5 \in C$。转移目标为 $(C, C)$。
        *   $S3$: 输入 `0` 转移到 $S4 \in C$，输入 `1` 转移到 $S5 \in C$。转移目标为 $(C, C)$。
        由于转移目标模式相同，$S1$ 和 $S3$ 暂时保持在同一块。
    *   块 $C=\{S2, S4, S5\}$:
        *   $S2$: 输入 `0` 转移到 $S0 \in A$，输入 `1` 转移到 $S3 \in B$。转移目标为 $(A, B)$。
        *   $S4$: 输入 `0` 转移到 $S0 \in A$，输入 `1` 转移到 $S0 \in A$。转移目标为 $(A, A)$。
        *   $S5$: 输入 `0` 转移到 $S0 \in A$，输入 `1` 转移到 $S1 \in B$。转移目标为 $(A, B)$。
        由于 $S4$ 的转移目标模式 $(A, A)$ 与 $S2, S5$ 的 $(A, B)$ 不同，块 $C$ 需要被细化。
    细化后的划分为 $P_1 = \{\{S0\}, \{S1, S3\}, \{S2, S5\}, \{S4\}\}$。

3.  **第二次细化 ($P_2$)**: 再次检查新划分的稳定性。我们发现 $\{S1, S3\}$ 和 $\{S2, S5\}$ 内部状态的转移目标相对于 $P_1$ 仍然是一致的。因此，划分不再改变。

[算法终止](@entry_id:143996)。最终的划分为 $\{\{S0\}, \{S1, S3\}, \{S2, S5\}, \{S4\}\}$，共有 4 个[等价类](@entry_id:156032)。这意味着原始的 6 状态机可以被一个等价的 4 [状态机](@entry_id:171352)替代，从而实现了[状态最小化](@entry_id:273227)。

#### [同步序列](@entry_id:265236)

在某些应用中，我们需要一种方法将机器从任何未知状态强制带入一个特定的已知状态。例如，在系统启动或错误恢复时，这非常有用。能够实现这一功能的输入字符串被称为**[同步序列](@entry_id:265236)**（synchronizing sequence）或**复位序列**（reset sequence）。

一个输入字符串 $w$ 是[同步序列](@entry_id:265236)，如果对于机器中的所有状态 $s \in S$，应用输入 $w$ 后，机器都将达到同一个最终状态。

为了寻找[同步序列](@entry_id:265236)，我们可以追踪输入序列作用下可能的状态集合。初始时，这个集合是 $S$。我们的目标是找到一个输入串 $w$，使得状态集合在处理完 $w$ 后只包含一个元素。

考虑一个四状态机 $\{s_0, s_1, s_2, s_3\}$ [@problem_id:1383520]。
*   初始状态集: $\{s_0, s_1, s_2, s_3\}$。
*   输入 `1`: 状态集 $\{s_0, s_1, s_2, s_3\}$ 变为 $\{\delta(s_0,1), \delta(s_1,1), \delta(s_2,1), \delta(s_3,1)\} = \{s_0, s_0, s_3, s_3\} = \{s_0, s_3\}$。状态集的大小从 4 减少到 2。
*   接着输入 `0`: 状态集 $\{s_0, s_3\}$ 变为 $\{\delta(s_0,0), \delta(s_3,0)\} = \{s_1, s_0\}$。
*   再接着输入 `1`: 状态集 $\{s_1, s_0\}$ 变为 $\{\delta(s_1,1), \delta(s_0,1)\} = \{s_0, s_0\} = \{s_0\}$。

此时，无论初始状态是什么，经过输入序列 `101` 后，机器的最终状态都将是 $s_0$。因此，`101` 是该机器的一个[同步序列](@entry_id:265236)。

#### 可解析性

在[密码学](@entry_id:139166)和数据编码等领域，我们关心一个过程是否会丢失信息。对于[米利机](@entry_id:177066)，一个有趣的问题是：是否可以从输出字符串唯一地确定输入字符串？一个相关的强属性是**可[解析性](@entry_id:140716)**（resolvability）。

一个[米利机](@entry_id:177066)被称为**可解析的**，如果对于任何长度 $k \ge 1$，任意两个不同的长度为 $k$ 的输入字符串 $w_1, w_2$，从初始状态 $s_0$ 出发，产生的输出字符串 $G^*(s_0, w_1)$ 和 $G^*(s_0, w_2)$ 也必须是不同的。

一个机器是可解析的，当且仅当对于其所有[可达状态](@entry_id:265999) $s$，以下条件成立：对于任意两个不同的输入符号 $x_1, x_2$，如果它们的输出相同，即 $G(s, x_1) = G(s, x_2)$，那么它们的下一状态必须是不等价的，即 $T(s, x_1) \not\equiv T(s, x_2)$。

让我们用这个定理来分析一个机器 [@problem_id:1383516]。考虑一个状态为 $\{A, B, C, D\}$，初始状态为 $A$ 的机器。在状态 $A$ 时，我们有：
*   $G(A, 0) = p$ 且 $T(A, 0) = B$。
*   $G(A, 1) = p$ 且 $T(A, 1) = C$。

这里，不同的输入 `0` 和 `1` 产生了相同的输出 `p`。根据可[解析性](@entry_id:140716)条件，我们需要检查下一状态 $B$ 和 $C$ 是否不等价。然而，通过进一步分析可以发现，对于任何输入 $x \in \{0, 1\}$，状态 $B$ 和 $C$ 不仅产生相同的输出，而且转移到相同的下一状态（输入`0`都到`D`，输入`1`都到`A`）。这意味着对于任何输入字符串 $w$，从 $B$ 和 $C$ 出发的输出序列都是相同的，因此 $B \equiv C$。

由于在状态 $A$ 存在不同输入 `0` 和 `1` 产生相同输出 `p`，但其下一状态 $B$ 和 $C$ 却是等价的，这违反了可[解析性](@entry_id:140716)的条件。因此，该机器是不可解析的。事实上，输入 `0` 和 `1` 从状态 $A$ 开始就会产生相同的输出 `p`，这本身就意味着它不是可解析的。

### 与[摩尔机](@entry_id:170836)的关系

最后，将[米利机](@entry_id:177066)与另一种重要的[有限状态机](@entry_id:174162)模型——[摩尔机](@entry_id:170836)进行比较是很有启发性的。如前所述，[摩尔机](@entry_id:170836)的输出只依赖于当前状态，而[米利机](@entry_id:177066)的输出依赖于当前[状态和](@entry_id:193625)当前输入。

这种差异导致了输出时序的不同。[摩尔机](@entry_id:170836)在进入一个状态时就确定了其输出。[米利机](@entry_id:177066)则在发生状态转移的“过程中”产生输出。因此，对于长度为 $n$ 的输入串，[米利机](@entry_id:177066)产生长度为 $n$ 的输出串，而[摩尔机](@entry_id:170836)（包括初始状态的输出）会产生长度为 $n+1$ 的输出串。

尽[管模型](@entry_id:140303)不同，但在一定条件下，它们可以相互转换。特别是，任何[摩尔机](@entry_id:170836)都可以被转换成一个等价的[米利机](@entry_id:177066)。转换的规则很简单：对于[米利机](@entry_id:177066)中的一个转移，其输出被设置为[摩尔机](@entry_id:170836)中该转移**到达**的状态的输出。

形式上，如果一个[摩尔机](@entry_id:170836)的[转移函数](@entry_id:273897)是 $\delta_M$，输出函数是 $g_M$（它将状态映射到输出），那么等价的[米利机](@entry_id:177066)的[转移函数](@entry_id:273897) $\delta_{Mealy}$ 与 $\delta_M$ 相同，其输出函数 $\lambda_{Mealy}$ 定义为：
$$ \lambda_{Mealy}(s, a) = g_M(\delta_M(s, a)) $$

例如，考虑一个检测输入 `1` 的个数是奇数还是偶数的[摩尔机](@entry_id:170836) [@problem_id:1383550]。它有两个状态：$S_0$（偶数个 `1`）和 $S_1$（奇数个 `1`）。输出 $g_M(S_0) = \text{'E'}$，$g_M(S_1) = \text{'O'}$。输入 `0` 保持状态，输入 `1` 切换状态。

应用转换规则，我们可以得到等价[米利机](@entry_id:177066)的输出函数：
*   $\lambda_{Mealy}(S_0, 0) = g_M(\delta_M(S_0, 0)) = g_M(S_0) = \text{'E'}$
*   $\lambda_{Mealy}(S_0, 1) = g_M(\delta_M(S_0, 1)) = g_M(S_1) = \text{'O'}$
*   $\lambda_{Mealy}(S_1, 0) = g_M(\delta_M(S_1, 0)) = g_M(S_1) = \text{'O'}$
*   $\lambda_{Mealy}(S_1, 1) = g_M(\delta_M(S_1, 1)) = g_M(S_0) = \text{'E'}$

这个转换过程清晰地揭示了两种模型之间的深刻联系，并为根据特定应用需求选择合适的模型提供了灵活性。