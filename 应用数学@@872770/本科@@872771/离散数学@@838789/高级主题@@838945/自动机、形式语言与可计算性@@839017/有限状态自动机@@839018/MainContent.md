## 引言
有限状态自动机（Finite-State Automata, FSA）是[计算理论](@entry_id:273524)中最基本也是最强大的概念之一。它是一种抽象的数学模型，用于描述那些拥有有限数量状态、并能根据一系列输入在这些状态之间转换的系统。尽管其结构简单，FSA 却构成了现代计算机科学许多分支的理论基石，从[编译器设计](@entry_id:271989)到[数字电路](@entry_id:268512)，再到人工智能。它的重要性不仅在于能做什么，更在于它清晰地界定了“[有限记忆](@entry_id:136984)”计算的边界，从而为理解更复杂的计算模型铺平了道路。

本文旨在系统性地解决一个核心问题：如何从理论上理解、在实践中构建并应用这种看似简单的计算机器？我们将带领读者踏上一段从抽象原理到具体应用的旅程，深入探索有限状态自动机的世界。

在接下来的内容中，我们将分三个核心部分展开：第一章，**原理与机制**，将深入剖析确定性与[非确定性](@entry_id:273591)自动机的形式化定义、计算过程、等价性转换以及最小化方法，为您建立坚实的理论基础。第二章，**应用与跨学科联系**，将展示FSA如何在计算机科学、数字工程乃至生命科学等不同领域中作为强大的建模工具，解决从模式识别到系统验证的各类实际问题。最后，**动手实践**部分将提供一系列精心设计的练习，帮助您将理论知识转化为解决问题的实践能力。通过这趟旅程，您将不仅掌握FSA的“是什么”和“为什么”，更能学会“怎么用”。

## 原理与机制

在本章中，我们将深入探讨有限状态自动机的核心原理与运作机制。我们将从其最基本的确定性形式开始，逐步引入更复杂的非确定性概念，并最终探讨这些计算模型的内在能力与局限性。我们的目标是建立一个坚实的理论基础，使我们不仅能理解自动机是什么，更能理解它们如何工作，以及我们如何设计它们来解决实际问题。

### 确定性有限自动机 (DFA)

在[计算理论](@entry_id:273524)中，最基础的模型之一是**确定性有限自动机 (Deterministic Finite Automaton, DFA)**。我们可以将其直观地想象成一个非常简单的机器，它拥有有限数量的**状态 (states)**，并且可以根据外部输入从一个状态**转换 (transition)**到另一个状态。这个机器没有记忆存储，它唯一知道的就是它当前所处的状态。

为了精确地描述一个 DFA，我们使用一个五元组进行形式化定义：$(Q, \Sigma, \delta, q_0, F)$。这五个组成部分分别代表：

1.  $Q$：一个有限的**状态集合 (set of states)**。
2.  $\Sigma$：一个有限的**输入字母表 (input alphabet)**，即机器可以识别的符号集合。
3.  $\delta$：**[转移函数](@entry_id:273897) (transition function)**，其形式为 $\delta: Q \times \Sigma \to Q$。它规定了在某个状态下接收到某个输入符号后，应该转移到哪一个新状态。其“确定性”正体现在对于任何[状态和](@entry_id:193625)输入的组合，目标状态都是唯一确定的。
4.  $q_0$：**起始状态 (start state)**，是机器在处理任何输入之前所处的初始状态，且 $q_0 \in Q$。
5.  $F$：一个**接受状态集合 (set of accepting states)**，也称为终止状态。它是 $Q$ 的一个[子集](@entry_id:261956) ($F \subseteq Q$)。如果机器在处理完整个输入字符串后，恰好停留在 $F$ 中的某个状态，我们就说这个字符串被“接受”了。

为了让这个抽象的定义更加具体，让我们来看一个例子。假设我们正在为一个简单的机械臂设计控制逻辑，该机械臂有三种状态：“就绪”($Q_R$)、“伸展”($Q_E$)和“夹取”($Q_G$)。它的行为由一系列指令驱动，指令集为“伸展”(`e`)和“夹取”(`g`)。根据设计要求，机械臂从“就绪”状态开始，只有在成功进入“夹取”状态后，任务才算完成。具体的转移规则如下：
-   在 $Q_R$ 状态，输入 `e` 进入 $Q_E$；输入 `g` 保持在 $Q_R$。
-   在 $Q_E$ 状态，输入 `e` 保持在 $Q_E$；输入 `g` 进入 $Q_G$。
-   在 $Q_G$ 状态，输入 `e` 返回 $Q_R$；输入 `g` 保持在 $Q_G$。

我们可以将这个控制逻辑精确地映射到 DFA 的五元组定义上：
-   $Q = \{Q_R, Q_E, Q_G\}$，包含了所有可能的状态。
-   $\Sigma = \{e, g\}$，包含了所有合法的输入指令。
-   $q_0 = Q_R$，因为机械臂从“就绪”状态开始。
-   $F = \{Q_G\}$，因为“夹取”是唯一代表任务完成的接受状态。
-   $\delta$ 函数则由上述规则详细定义：
    -   $\delta(Q_R, e) = Q_E$, $\delta(Q_R, g) = Q_R$
    -   $\delta(Q_E, e) = Q_E$, $\delta(Q_E, g) = Q_G$
    -   $\delta(Q_G, e) = Q_R$, $\delta(Q_G, g) = Q_G$

通过这种方式，一个看似复杂的行为系统被清晰、无歧义地模型化了。

### 计算的机制

定义了 DFA 之后，下一个关键问题是：它如何处理输入并做出“接受”或“拒绝”的判断？这个过程非常直观。当一个输入字符串（例如 `1001`）被提供给 DFA 时，机器从其**起始状态** $q_0$ 开始，逐个读取字符串中的符号。每读取一个符号，它就根据**[转移函数](@entry_id:273897)** $\delta$ 更新其当前状态。当所有符号都被读取完毕后，机器停止。此时，如果它所在的最终状态属于**接受状态集** $F$，则该输入字符串被**接受 (accepted)**。否则，该字符串被**拒绝 (rejected)**。

一个 DFA 所接受的所有字符串的集合被称为该自动机的**语言 (language)**。

让我们通过追踪一个具体的计算过程来加深理解。考虑一个 DFA，其定义如下：
-   $Q = \{q_0, q_1, q_2, q_3\}$
-   $\Sigma = \{0, 1\}$
-   $q_0$ 是起始状态
-   $F = \{q_0, q_1, q_2\}$
-   $\delta$ 函数定义为：
    -   $\delta(q_0, 0) = q_0$, $\delta(q_0, 1) = q_1$
    -   $\delta(q_1, 0) = q_0$, $\delta(q_1, 1) = q_2$
    -   $\delta(q_2, 0) = q_3$, $\delta(q_2, 1) = q_2$
    -   $\delta(q_3, 0) = q_3$, $\delta(q_3, 1) = q_3$

现在，我们输入字符串 `1001`。计算过程如下：
1.  初始状态为 $q_0$。
2.  读取第一个符号 `1`。根据 $\delta(q_0, 1) = q_1$，机器转移到状态 $q_1$。
3.  读取第二个符号 `0`。根据 $\delta(q_1, 0) = q_0$，机器转移到状态 $q_0$。
4.  读取第三个符号 `0`。根据 $\delta(q_0, 0) = q_0$，机器保持在状态 $q_0$。
5.  读取第四个符号 `1`。根据 $\delta(q_0, 1) = q_1$，机器转移到状态 $q_1$。

输入字符串处理完毕，机器的最终状态是 $q_1$。我们检查接受状态集 $F = \{q_0, q_1, q_2\}$。由于 $q_1 \in F$，我们得出结论：字符串 `1001` 被该 DFA **接受**。整个状态序列（包括起始状态）是 $q_0, q_1, q_0, q_0, q_1$。

### 引入[非确定性](@entry_id:273591)

DFA 的一个核心特性是其“确定性”：在任何状态下，对于任何输入，下一个状态都是唯一确定的。然而，在某些情况下，放宽这一限制可以使自动机的设计变得更加简单和直观。这就引出了**[非确定性有限自动机](@entry_id:273744) (Nondeterministic Finite Automaton, NFA)**。

NFA 与 DFA 在形式化定义上非常相似，但有一个关键区别：它的[转移函数](@entry_id:273897)。对于 NFA，[转移函数](@entry_id:273897) $\delta$ 的形式为 $\delta: Q \times \Sigma \to \mathcal{P}(Q)$，其中 $\mathcal{P}(Q)$ 是 $Q$ 的**幂集 (power set)**，即 $Q$ 的所有[子集](@entry_id:261956)的集合。这意味着，在某个状态下接收到某个输入后，机器可以同时转移到**一个状态集合**中的任何一个状态。它仿佛拥有了在多个计算路径上并行探索的能力。

NFA 的接受规则也因此有所不同：如果存在**至少一条**可能的计算路径，能够在处理完整个输入字符串后到达一个接受状态，那么该字符串就被 NFA **接受**。

让我们看一个例子。一个用于验证二[进制](@entry_id:634389)信号的 NFA，其起始状态为 $q_0$，接受状态为 $q_4$。其[转移函数](@entry_id:273897)部分定义如下：
-   $\delta(q_0, 1) = \{q_0, q_1\}$
-   $\delta(q_0, 0) = \{q_3\}$
-   $\delta(q_1, 0) = \{q_2\}$
-   $\delta(q_2, 1) = \{q_4\}$
-   $\delta(q_3, 1) = \{q_4\}$

现在，我们输入信号 `101`。
1.  从起始状态 $q_0$ 开始，读取第一个符号 `1`。根据 $\delta(q_0, 1) = \{q_0, q_1\}$，自动机“分裂”成两条路径。一条路径到达 $q_0$，另一条到达 $q_1$。
2.  **路径 1 (当前状态 $q_0$)**: 读取第二个符号 `0`。根据 $\delta(q_0, 0) = \{q_3\}$，路径转移到 $q_3$。接着读取第三个符号 `1`，根据 $\delta(q_3, 1) = \{q_4\}$，路径转移到 $q_4$。这条路径的完整状态序列是 $(q_0, q_0, q_3, q_4)$。
3.  **路径 2 (当前状态 $q_1$)**: 读取第二个符号 `0`。根据 $\delta(q_1, 0) = \{q_2\}$，路径转移到 $q_2$。接着读取第三个符号 `1`，根据 $\delta(q_2, 1) = \{q_4\}$，路径转移到 $q_4$。这条路径的完整状态序列是 $(q_0, q_1, q_2, q_4)$。

输入处理完毕后，我们发现存在两条不同的计算路径，它们都到达了接受状态 $q_4$。由于至少有一条成功的路径，字符串 `101` 被这个 NFA **接受**。这种[非确定性](@entry_id:273591)允许 NFA 以一种更灵活、有时也更简洁的方式来捕捉语言的模式。

### NFA 与 DFA 的等价性

NFA 的非确定性看似比 DFA 更强大，但计算理论中一个基础性的结果是：**NFA 和 DFA 在计算能力上是等价的**。这意味着对于任何一个 NFA，我们总能构造出一个接受完全相同语言的 DFA。

这个转化的核心思想是**[子集](@entry_id:261956)构造 (subset construction)**。其直觉是，我们可以构造一个 DFA，该 DFA 的每个状态对应于原 NFA 可能处于的**状态集合**。如果一个 NFA 在处理某个输入后可能处于 $\{q_i, q_j, q_k\}$ 这几个状态中的任何一个，那么等价的 DFA 就会进入一个代表集合 $\{q_i, q_j, q_k\}$ 的单一状态。

在 NFA 的设计中，我们还可以引入一种特殊的转移，称为**$\epsilon$-转移 (epsilon transition)**。这种转移允许自动机在不消耗任何输入符号的情况下改变状态。这极大地增强了设计的便利性，但同样不增加其计算能力。包含 $\epsilon$-转移的 NFA 也可以被转换为等价的 DFA。

在进行[子集](@entry_id:261956)构造时，我们必须首先处理 $\epsilon$-转移。对于 NFA 的任何一个状态 $q$，其**$\epsilon$-闭包 (epsilon closure)**，记作 $E(q)$，是从 $q$ 出发仅通过 $\epsilon$-转移（包括零次转移，即 $q$ 本身）所能到达的所有状态的集合。

让我们通过一个例子来演示这个过程。假设有一个 NFA，其状态为 $\{q_0, q_1, q_2\}$，起始状态为 $q_0$，接受状态为 $\{q_2\}$，转移规则包括 $\delta(q_0, a) = \{q_0, q_1\}$, $\delta(q_0, \epsilon) = \{q_1\}$, $\delta(q_1, b) = \{q_2\}$ 等。

1.  **计算 $\epsilon$-闭包**：
    -   从 $q_0$ 可以通过 $\epsilon$-转移到达 $q_1$，所以 $E(q_0) = \{q_0, q_1\}$。
    -   $q_1$ 和 $q_2$ 没有出射的 $\epsilon$-转移，所以 $E(q_1) = \{q_1\}$，$E(q_2) = \{q_2\}$。

2.  **[子集](@entry_id:261956)构造**：
    -   DFA 的起始状态是 NFA 起始状态的 $\epsilon$-[闭包](@entry_id:148169)：$S_0 = E(q_0) = \{q_0, q_1\}$。
    -   从状态 $S_0 = \{q_0, q_1\}$ 开始，计算其在输入 `a` 和 `b` 下的转移：
        -   **输入 `a`**: 首先找到 $\{q_0, q_1\}$ 中的状态在 `a` 下能转移到的所有状态，即 $\delta(q_0, a) \cup \delta(q_1, a) = \{q_0, q_1\} \cup \emptyset = \{q_0, q_1\}$。然后取这个新集合的 $\epsilon$-闭包，即 $E(q_0) \cup E(q_1) = \{q_0, q_1\} = S_0$。所以，DFA 在状态 $S_0$ 收到 `a` 时，会回到 $S_0$。
        -   **输入 `b`**: $\{q_0, q_1\}$ 在 `b` 下能转移到 $\delta(q_0, b) \cup \delta(q_1, b) = \emptyset \cup \{q_2\} = \{q_2\}$。取其 $\epsilon$-[闭包](@entry_id:148169) $E(q_2) = \{q_2\}$。这是一个我们之前没见过的新状态，我们将其命名为 $S_2 = \{q_2\}$。

    -   现在我们有了新状态 $S_2 = \{q_2\}$，我们需要计算它的转移：
        -   **输入 `a`**: $q_2$ 在 `a` 下转移到 $\{q_2\}$，其 $\epsilon$-[闭包](@entry_id:148169)是 $\{q_2\}=S_2$。
        -   **输入 `b`**: $q_2$ 在 `b` 下转移到 $\{q_0\}$，其 $\epsilon$-[闭包](@entry_id:148169)是 $E(q_0)=\{q_0, q_1\}=S_0$。

3.  **确定接受状态**：DFA 的任何一个状态，只要它所代表的 NFA 状态集合中包含了至少一个 NFA 的接受状态，那么这个 DFA 状态就是接受状态。在这个例子中，NFA 的接受状态是 $q_2$。DFA 的状态 $S_0 = \{q_0, q_1\}$ 不包含 $q_2$，所以是非接受状态。状态 $S_2 = \{q_2\}$ 包含了 $q_2$，所以是接受状态。

经过这个过程，我们构建了一个只有两个状态 $S_0$ 和 $S_2$ 的 DFA，它与原始的 NFA 等价。

### 构建自动机

理论上，我们可以为任何**[正则语言](@entry_id:267831) (regular language)** 构建一个有限自动机。实践中，我们常常从更高层次的描述开始，例如[正则表达式](@entry_id:265845)或语言属性的组合，然后系统地构造出相应的自动机。

#### 从[正则表达式](@entry_id:265845)构建

**[正则表达式](@entry_id:265845) (Regular Expressions)** 是一种用来描述字符串模式的强大而简洁的语言。计算理论的一个基石是 **Kleene 定理**，它指出[正则表达式](@entry_id:265845)和有限自动机在[表达能力](@entry_id:149863)上是等价的：任何可以用[正则表达式](@entry_id:265845)描述的语言都是[正则语言](@entry_id:267831)，反之亦然。

**[Thompson 构造法](@entry_id:272510)**是一种经典的算法，可以将任意[正则表达式](@entry_id:265845)递归地转换为一个等价的、带有 $\epsilon$-转移的 NFA。该方法为每种[正则表达式](@entry_id:265845)操作（符号、连接、并集、克里尼星号）定义了简单的构造规则：

1.  **符号**：对于单个符号 $x$，构造一个 NFA，包含一个起始[状态和](@entry_id:193625)一个接受状态，中间由一条标有 $x$ 的边连接。
2.  **并集 (Union, $R_1|R_2$)**：为 $R_1$ 和 $R_2$ 对应的 NFA $N_1$ 和 $N_2$ 创建一个新的总起始[状态和](@entry_id:193625)总接受状态。从新起始状态引出 $\epsilon$-转移到 $N_1$ 和 $N_2$ 各自的起始状态；从 $N_1$ 和 $N_2$ 各自的接受状态引出 $\epsilon$-转移到新接受状态。
3.  **连接 (Concatenation, $R_1R_2$)**：将 $N_1$ 的接受状态通过 $\epsilon$-转移连接到 $N_2$ 的起始状态。新的 NFA 以 $N_1$ 的起始状态为起始，以 $N_2$ 的接受状态为接受。
4.  **克里尼星号 (Kleene Star, $R_1^*$)**：为 $N_1$ 创建一个新的起始[状态和](@entry_id:193625)接受状态。添加四条 $\epsilon$-转移：(1) 从新起始到新接受（匹配空串）；(2) 从新起始到 $N_1$ 的起始；(3) 从 $N_1$ 的接受到新接受；(4) 从 $N_1$ 的接受回到 $N_1$ 的起始（实现重复）。

通过反复应用这些规则，我们可以为复杂的[正则表达式](@entry_id:265845) `a(b|c)*d` 构建出相应的 NFA。这个过程是机械的，完美地展示了如何将一个声明性的模式描述（[正则表达式](@entry_id:265845)）转化为一个操作性的计算模型（NFA）。

#### 从语言属性构建

当一个语言由多个简单[正则语言](@entry_id:267831)的交集或并集定义时，我们可以通过**乘积构造 (product construction)** 来构建其自动机。例如，考虑一个语言，它要求字符串同时满足两个条件：(1) 以 `a` 开头；(2) 包含偶数个 `b`。

我们可以将这个问题看作是两个语言 $L_1$ 和 $L_2$ 的交集 $L = L_1 \cap L_2$。
-   $L_1 = \{w \mid w \text{ 以 'a' 开头}\}$
-   $L_2 = \{w \mid w \text{ 中 'b' 的数量为偶数}\}$

$L_1$ 和 $L_2$ 都是[正则语言](@entry_id:267831)，可以分别用一个简单的 DFA 来识别。$L_1$ 的 DFA 需要三个状态（初始、`a`开头、`b`开头/失败），而 $L_2$ 的 DFA 需要两个状态（偶数个`b`、奇数个`b`）。

乘积构造法告诉我们，我们可以构造一个识别 $L$ 的新 DFA，其状态是原 DFA 状态的[有序对](@entry_id:269702)。新 DFA 的状态 $(p, q)$ 同时追踪原 DFA 在处理相同输入时分别会达到的状态 $p$ 和 $q$。

对于上述例子，我们可以直接设计一个 DFA，其状态需要记录两个维度的信息：
1.  **首字母信息**：是初始状态，还是首字母为 `a`，或是首字母为 `b`（这将导致永久拒绝）。
2.  **`b` 的奇偶性**：到目前为止 `b` 的数量是偶数还是奇数。

这引导我们设计出四个有意义的状态：
-   $S_{start}$：初始状态，等待第一个输入。非接受。
-   $S_{a, even}$：首字母是 `a`，且已见偶数个 `b`。这是接受状态。
-   $S_{a, odd}$：首字母是 `a`，且已见奇数个 `b`。非接受。
-   $S_{dead}$：首字母是 `b`，或者处于其他任何导致字符串无效的状态。这是一个永久拒绝的“陷阱”状态。

从 $S_{start}$ 开始，输入 `a` 进入 $S_{a, even}$（因为 `b` 的数量为0，是偶数），输入 `b` 进入 $S_{dead}$。在 $S_{a, even}$ 和 $S_{a, odd}$ 之间，输入 `a` 不改变奇偶性，状态不变；输入 `b` 则在两者之间切换。$S_{dead}$ 状态在任何输入下都保持不变。这个包含4个状态的 DFA 精确地识别了目标语言。这个构造过程是乘积思想的一个直观应用。

### 优化自动机：最小化

对于任何一个[正则语言](@entry_id:267831)，都存在一个唯一的（在同构意义下）状态数最少的 DFA 来识别它。这个 DFA 被称为**最小 DFA**。从一个普通的 DFA 出发，找到等价的最小 DFA 的过程称为**最小化 (minimization)**。最小化对于提高识别效率和节省存储空间至关重要。

最小化的核心是识别并合并**等价状态 (equivalent states)**。如果从状态 $p$ 和状态 $q$ 出发，对于**任意**的后续输入字符串 $w$，机器的最终结果（接受或拒绝）都完全相同，那么我们称 $p$ 和 $q$ 是等价的。

**划分细化算法 (partition refinement algorithm)** 是一个标准的最小化方法：
1.  **初始划分**：将所有状态划分为两个集合：接受状态集 $F$ 和非接受状态集 $Q \setminus F$。显然，一个接受[状态和](@entry_id:193625)一个非接受状态是不等价的。
2.  **迭代细化**：检查每个划分块中的状态。如果在一个块中，存在两个状态 $p$ 和 $q$，它们在接收到某个相同输入符号 $a$ 后，转移到了**不同**的划分块中，那么 $p$ 和 $q$ 就是**可区分的 (distinguishable)**。根据这个发现，将当前块分裂成更小的块。
3.  **终止**：重复上述过程，直到在任何一次迭代中，没有任何块可以被进一步细化。此时，每个留下的块都代表一个等价类。

最终的最小 DFA 的状态就是这些等价类。让我们看一个例子。给定一个5状态的 DFA $Q = \{S_0, S_1, S_2, S_3, S_4\}$，接受状态为 $F=\{S_4\}$。
-   **初始划分 $P_0$**: $\{\{S_4\}, \{S_0, S_1, S_2, S_3\}\}$。
-   **第一次细化**: 考虑非接受块 $\{S_0, S_1, S_2, S_3\}$。检查输入 `b` 的转移目标：
    -   $\delta(S_0, b) = S_3$，目标在 $\{S_0, S_1, S_2, S_3\}$ 块中。
    -   $\delta(S_1, b) = S_4$，目标在 $\{S_4\}$ 块中。
    -   $\delta(S_2, b) = S_1$，目标在 $\{S_0, S_1, S_2, S_3\}$ 块中。
    -   $\delta(S_3, b) = S_4$，目标在 $\{S_4\}$ 块中。
    因为 $S_0, S_2$ 的转移目标和 $S_1, S_3$ 的转移目标属于不同的块，所以我们需要将 $\{S_0, S_1, S_2, S_3\}$ 细化为 $\{S_0, S_2\}$ 和 $\{S_1, S_3\}$。
    **新划分 $P_1$**: $\{\{S_4\}, \{S_0, S_2\}, \{S_1, S_3\}\}$。
-   **第二次细化**:
    -   检查块 $\{S_0, S_2\}$：输入 `a` 时，$\delta(S_0, a)=S_1$, $\delta(S_2, a)=S_3$。$S_1$ 和 $S_3$ 都在 $\{S_1, S_3\}$ 块中。输入 `b` 时，$\delta(S_0, b)=S_3$, $\delta(S_2, b)=S_1$。$S_3$ 和 $S_1$ 也都在 $\{S_1, S_3\}$ 块中。因此，$\{S_0, S_2\}$ 不可再分。
    -   检查块 $\{S_1, S_3\}$：输入 `a` 时，$\delta(S_1, a)=S_0$, $\delta(S_3, a)=S_2$。$S_0$ 和 $S_2$ 都在 $\{S_0, S_2\}$ 块中。输入 `b` 时，$\delta(S_1, b)=S_4$, $\delta(S_3, b)=S_4$。两者都在 $\{S_4\}$ 块中。因此，$\{S_1, S_3\}$ 也不可再分。

由于没有块可以再被细化，[算法终止](@entry_id:143996)。最终的等价类是 $\{S_4\}$, $\{S_0, S_2\}$, $\{S_1, S_3\}$。这意味着最小 DFA 有3个状态。

### 有限自动机的局限性

尽管有限自动机非常有用，但它们并非万能。其核心限制在于其“有限”的记忆。一个只有有限状态的机器，无法完成需要无限记忆的任务，例如无限制地计数。

我们可以用一个简单的**[鸽巢原理](@entry_id:268698) (pigeonhole principle)** 论证来直观理解这一点。假设一个自动机有 $S$ 个状态，我们想用它来识别形如 $0^n1^n$（$n$ 个 `0` 跟着 $n$ 个 `1`）的语言。为了做到这一点，机器在读完所有的 `0` 之后，必须“记住”它究竟读了多少个 `0`，以便稍后与 `1` 的数量进行比较。

考虑机器在读取不同数量的 `0` 之后的状态：$\delta(0^0), \delta(0^1), \delta(0^2), \ldots, \delta(0^S)$。这里我们有 $S+1$ 个不同的前缀，但机器只有 $S$ 个状态。根据[鸽巢原理](@entry_id:268698)，必然存在两个不同的整数 $i$ 和 $j$（其中 $0 \le i  j \le S$），使得 $\delta(0^i) = \delta(0^j)$。这意味着机器在读取了 $i$ 个 `0` 和 $j$ 个 `0` 之后，进入了完全相同的状态。它已经“混淆”了这两种情况。如果机器此时接受了后续的 $1^i$（形成合法的 $0^i1^i$），那么它也必须接受 $1^i$ 跟在 $0^j$ 之后（形成非法的 $0^j1^i$），从而导致错误。

这个思想被形式化为**[正则语言](@entry_id:267831)的[泵引理](@entry_id:275448) (Pumping Lemma for Regular Languages)**。它是一个强大的工具，用于证明某个语言**不是**[正则语言](@entry_id:267831)。[泵引理](@entry_id:275448)声明：如果一个语言 $L$是正则的，那么存在一个常数 $p$（[泵引理](@entry_id:275448)长度），使得 $L$ 中任何长度大于或等于 $p$ 的字符串 $s$，都可以被分解为三部分 $s=xyz$，满足：
1.  $|y| > 0$
2.  $|xy| \le p$
3.  对于所有 $i \ge 0$，字符串 $xy^iz$（即“泵送”中间部分 $y$）仍然在 $L$ 中。

如果我们可以为一个语言找到一个足够长的字符串，证明它无法被如此分解和泵送而不产生不属于该语言的字符串，那么我们就证明了该语言不是正则的。

一个经典的例子是语言 $L_D$，即所有“格式正确”的括号序列的语言（例如，"()" 和 "[[]()]"）。要证明它不是正则的，我们可以使用[泵引理](@entry_id:275448)。
1.  假设 $L_D$ 是正则的，设其[泵引理](@entry_id:275448)长度为 $p$。
2.  选择字符串 $s = [^p]^p$（$p$ 个左括号后跟 $p$ 个右括号）。这个字符串显然在 $L_D$ 中且长度大于 $p$。
3.  根据[泵引理](@entry_id:275448)，$s$ 可以分解为 $xyz$。由于 $|xy| \le p$，所以 $x$ 和 $y$ 都完全由左括号 `[` 组成。又因为 $|y| > 0$，$y$ 至少包含一个 `[`。
4.  现在我们来“泵送”。考虑 $i=0$ 的情况，即 $xz$。这个新字符串比原来的 $s$ 少了 $|y|$ 个左括号，但右括号数量不变。因此，它不再满足括号匹配的条件，也就不在 $L_D$ 中。
5.  这与[泵引理](@entry_id:275448)的结论（$xy^iz$ 必须在 $L$ 中）相矛盾。因此，我们最初的假设是错误的。$L_D$ 不是[正则语言](@entry_id:267831)，不能被任何有限自动机识别。

相比之下，像“`[` 的总数为偶数”或“不包含子串 `[a]`”这样的语言是正则的，因为它们只需要有限的记忆（例如，一个比特来追踪奇偶性，或几个状态来追踪子串匹配的进度）。

### 带输出的自动机

到目前为止，我们讨论的自动机都只作为“接受器”，它们的输出是二元的（接受/拒绝）。然而，在许多应用中，我们希望机器能根据输入[序列生成](@entry_id:635570)一个输出序列。这就引出了两种带输出的自动机模型：**米里机 (Mealy Machine)** 和 **[摩尔机](@entry_id:170836) (Moore Machine)**。

-   **米里机 (Mealy Machine)**：其输出取决于**当前状态**和**当前输入符号**。输出函数的形式为 $\lambda: Q \times \Sigma \to \Gamma$，其中 $\Gamma$ 是输出字母表。
-   **[摩尔机](@entry_id:170836) (Moore Machine)**：其输出仅取决于**当前状态**。输出函数的形式为 $\lambda: Q \to \Gamma$。

米里机对于需要对特定输入立即做出反应的场景非常有用，例如[网络入侵检测](@entry_id:633942)系统。假设我们需要设计一个系统来检测二进制流中的恶意签名 `1011`。每当成功匹配该签名时，系统应立即输出 'A' (Alert)，否则输出 'N' (Normal)。

我们可以设计一个米里机，其状态代表已匹配的签名前缀的长度：
-   $S_0$：空匹配（初始状态）
-   $S_1$：已匹配 `1`
-   $S_2$：已匹配 `10`
-   $S_3$：已匹配 `101`

转移和输出规则如下：
-   从 $S_0$：输入 `1` 到 $S_1$ (输出 N)；输入 `0` 到 $S_0$ (输出 N)。
-   从 $S_1$：输入 `0` 到 $S_2$ (输出 N)；输入 `1` 到 $S_1$ (因为 `11` 的后缀最长匹配前缀是 `1`) (输出 N)。
-   从 $S_2$：输入 `1` 到 $S_3$ (输出 N)；输入 `0` 到 $S_0$ (因为 `100` 的后缀没有匹配的前缀) (输出 N)。
-   从 $S_3$：输入 `0` 到 $S_2$ (因为 `1010` 的后缀最长匹配前缀是 `10`) (输出 N)；输入 `1` 时，成功匹配 `1011`，所以**输出 'A'**。然后，我们需要确定下一个状态。完整字符串 `1011` 的最长真后缀（proper suffix）同时也是 `1011` 的前缀是 `1`，所以转移到 $S_1$，以便立即开始检测下一个可能的重叠匹配。

这个例子展示了带输出的自动机如何将识别模式的能力与生成响应的行为结合起来，从而在信号处理、协议分析和控制系统等领域发挥重要作用。