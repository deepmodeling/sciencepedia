{"hands_on_practices": [{"introduction": "在我们设计自己的下推自动机之前，首先必须学会如何解读它们的形式化定义。这个练习提供了一个具体的下推自动机，要求你通过追踪其执行过程来找到一个它所接受的字符串。这项实践将帮助你熟练掌握状态、转移和栈操作的基本机制，这是理解和设计任何自动机的基础 [@problem_id:1394348]。", "problem": "一个下推自动机（PDA）被形式化地定义为一个7元组 $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$。考虑下面定义的特定PDA $M$：\n-   $Q = \\{q_0, q_1, q_2\\}$ 是状态集。\n-   $\\Sigma = \\{a, b, c\\}$ 是输入字母表。\n-   $\\Gamma = \\{X, Z_0\\}$ 是栈字母表。\n-   $q_0$ 是起始状态。\n-   $Z_0$ 是初始栈符号。\n-   $F = \\{q_2\\}$ 是最终（接受）状态集。\n-   $\\delta$ 是转移函数，由以下规则定义：\n    1.  $\\delta(q_0, a, Z_0) = \\{(q_0, XXZ_0)\\}$\n    2.  $\\delta(q_0, a, X) = \\{(q_0, XXX)\\}$\n    3.  $\\delta(q_0, c, X) = \\{(q_1, X)\\}$\n    4.  $\\delta(q_1, b, X) = \\{(q_1, \\epsilon)\\}$\n    5.  $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\n这里，一条转移规则 $\\delta(q_i, \\sigma, A) = \\{(q_j, B)\\}$ 意味着，如果自动机处于状态 $q_i$，读入输入符号 $\\sigma$，且栈顶符号为 $A$，那么它可以转移到状态 $q_j$ 并将栈上的 $A$ 替换为 $B$。输入符号 $\\epsilon$ 表示空串（该转移不消耗输入符号），而替换字符串 $\\epsilon$ 表示一次出栈操作（从栈中移除该符号而不压入任何东西）。\n\n找到一个被该PDA $M$ 接受的非空字符串。", "solution": "我们分析每个转移的效果。在状态 $q_0$ 中，当栈顶是 $Z_0$ 时读入一个 $a$，应用 $\\delta(q_0, a, Z_0) = \\{(q_0, XXZ_0)\\}$，压入两个符号 $X$。对于后续的 $a$ 符号且栈顶为 $X$ 时，$\\delta(q_0, a, X) = \\{(q_0, XXX)\\}$ 将栈顶的 $X$ 替换为 $XXX$，即每读入一个 $a$ 就使 $X$ 的数量增加两个。因此，在 $q_0$ 状态下读入 $n \\ge 1$ 个 $a$ 后，栈中 $Z_0$ 之上会有 $2n$ 个 $X$。当栈顶为 $X$ 时读入 $c$ 会执行 $\\delta(q_0, c, X) = \\{(q_1, X)\\}$，切换到状态 $q_1$ 而不改变栈。在 $q_1$ 中，每个 $b$ 且栈顶为 $X$ 时，应用 $\\delta(q_1, b, X) = \\{(q_1, \\epsilon)\\}$，弹出一个 $X$。在恰好读入 $2n$ 个 $b$ 之后，栈顶变为 $Z_0$，此时 $\\epsilon$-转移 $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$ 将自动机移动到接受状态 $q_2$。因此，该PDA接受的语言是 $\\{a^n c b^{2n} \\mid n \\ge 1\\}$，所以一个具体的非空接受字符串是 $acbb$（即 $n=1$ 的情况）。\n\n我们现在使用瞬时描述 $(\\text{状态}, \\text{剩余输入}, \\text{栈})$ 来给出 $w=acbb$ 的显式计算过程，其中栈顶在左侧：\n$$(q_{0}, acbb, Z_{0}) \\vdash (q_{0}, cbb, XXZ_{0}) \\quad\\text{依据 }\\delta(q_{0}, a, Z_{0})=(q_{0}, XXZ_{0}),$$\n$$(q_{0}, cbb, XXZ_{0}) \\vdash (q_{1}, bb, XXZ_{0}) \\quad\\text{依据 }\\delta(q_{0}, c, X)=(q_{1}, X),$$\n$$(q_{1}, bb, XXZ_{0}) \\vdash (q_{1}, b, XZ_{0}) \\quad\\text{依据 }\\delta(q_{1}, b, X)=(q_{1}, \\epsilon),$$\n$$(q_{1}, b, XZ_{0}) \\vdash (q_{1}, \\epsilon, Z_{0}) \\quad\\text{依据 }\\delta(q_{1}, b, X)=(q_{1}, \\epsilon),$$\n$$(q_{1}, \\epsilon, Z_{0}) \\vdash (q_{2}, \\epsilon, Z_{0}) \\quad\\text{依据 }\\delta(q_{1}, \\epsilon, Z_{0})=(q_{2}, Z_{0}).$$\n由于 $q_{2}\\in F$ 且输入已耗尽，字符串 $acbb$ 被接受。", "answer": "$$\\boxed{acbb}$$", "id": "1394348"}, {"introduction": "掌握了如何追踪自动机的运行后，下一步是培养分析和调试能力。在计算科学中，定位和修复设计中的缺陷是一项核心技能。这个问题提供了一个为特定语言设计的下推自动机，但其中包含一个微妙的错误，你的任务是找出那个导致其行为不符合预期的错误转移规则 [@problem_id:1394387]。", "problem": "一位计算机科学家正在设计一个自动机来识别一个特定的语言。目标语言是 $L = \\{w\\#w^R \\mid w \\in \\{0,1\\}^*\\}$，其中 $w^R$ 是字符串 $w$ 的反转。例如，字符串 `011#110` 属于 $L$，而 `01#01` 则不属于。\n\n这位科学家提出了一个下推自动机 (Pushdown Automaton, PDA)，这是一种配备了栈的自动机。所提出的 PDA 由一个七元组 $M = (Q, \\Sigma, \\Gamma, \\delta, q_{start}, Z_0, F)$ 定义，其组成部分如下：\n-   状态集：$Q = \\{q_0, q_1, q_2\\}$\n-   输入字母表：$\\Sigma = \\{0, 1, \\#\\}$\n-   栈字母表：$\\Gamma = \\{0, 1, Z_0\\}$\n-   起始状态：$q_{start} = q_0$\n-   初始栈符号：$Z_0$\n-   最终（接受）状态集：$F = \\{q_2\\}$\n\n该 PDA 的设计操作如下：在状态 $q_0$ 中，它读取子字符串 $w$ 并将其符号推入栈中。当它读取到 `#` 符号时，它转换到状态 $q_1$。在状态 $q_1$ 中，它将输入的 $w^R$ 的符号与从栈中弹出的符号进行匹配。如果输入被完全读取且栈为空（除了 $Z_0$），它将转移到接受状态 $q_2$。\n\n转移函数 $\\delta$ 中恰好包含一条错误的规则，导致该 PDA 无法完成识别语言 $L$ 的任务。这意味着该 PDA 要么接受了不属于 $L$ 的字符串，要么拒绝了属于 $L$ 的字符串。转移规则集如下所列。\n\n-   $\\delta(q_0, 0, X) = \\{(q_0, 0X)\\}$ 对任何 $X \\in \\Gamma$ 成立\n-   $\\delta(q_0, 1, X) = \\{(q_0, 1X)\\}$ 对任何 $X \\in \\Gamma$ 成立\n-   $\\delta(q_0, \\#, X) = \\{(q_1, X)\\}$ 对任何 $X \\in \\Gamma$ 成立\n-   $\\delta(q_1, 0, 0) = \\{(q_1, \\epsilon)\\}$\n-   $\\delta(q_1, 1, 1) = \\{(q_1, \\epsilon)\\}$\n-   $\\delta(q_1, 0, 1) = \\{(q_1, \\epsilon)\\}$\n-   $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\n你的任务是从下面提供的选项中找出错误的转移规则。\n\nA. 转移规则 $\\delta(q_0, 0, X) = \\{(q_0, 0X)\\}$ 对任何 $X \\in \\Gamma$ 成立。\n\nB. 转移规则 $\\delta(q_0, \\#, X) = \\{(q_1, X)\\}$ 对任何 $X \\in \\Gamma$ 成立。\n\nC. 转移规则 $\\delta(q_1, 0, 1) = \\{(q_1, \\epsilon)\\}$。\n\nD. 转移规则 $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$。", "solution": "我们希望这个 PDA 能够精确地接受语言 $L = \\{w\\#w^R \\mid w \\in \\{0,1\\}^*\\}$。设 $w = a_1 a_2 \\dots a_n$，其中每个 $a_i \\in \\{0,1\\}$。在状态 $q_0$ 中，PDA 将读取到的 $w$ 的每个符号推入栈中，这样，在读取完整个 $w$ 后，栈的内容（从顶到底）为 $a_n a_{n-1} \\dots a_1 Z_0$。在读取到 $\\#$ 时，它必须转换到 $q_1$ 并且不改变栈，以便在 $q_1$ 中可以将输入的符号与栈顶进行比较。在 $q_1$ 中，为了强制匹配 $w^R$，每个接下来的输入符号必须与当前的栈顶符号相等并被弹出；当所有输入都被消耗完且栈中只剩下 $Z_0$ 时，执行一个 $\\epsilon$-转移到接受状态 $q_2$。\n\n现在根据这个预期的行为来检查每个列出的转移规则。\n\n1) $\\delta(q_0, 0, X) = \\{(q_0, 0X)\\}$ 对任何 $X \\in \\Gamma$ 成立。这个规则在读取左半部分 $w$ 时，正确地将一个 $0$ 推到栈顶，无论栈上原有何物。它实现了所需的推入行为，因此是一致的。\n\n2) $\\delta(q_0, \\#, X) = \\{(q_1, X)\\}$ 对任何 $X \\in \\Gamma$ 成立。这个规则在遇到分隔符 $\\#$ 时，正确地从构建栈的阶段转换到匹配阶段，并保持栈不变，这正是所需要的。\n\n3) $\\delta(q_1, 0, 1) = \\{(q_1, \\epsilon)\\}$。在匹配阶段，对于语言 $w\\#w^R$，输入符号必须与栈顶符号相等才能将其弹出。然而，这条规则在读取一个 $0$ 时弹出了一个 $1$，允许了不匹配的情况。这种对不匹配的接受导致 PDA 接受了不属于 $L$ 的字符串。一个具体的反例是输入 $1\\#0$：从 $Z_0$ 开始，在 $q_0$ 中读取 $1$ 会将 $1$ 推入栈，栈变为 $1Z_0$；读取 $\\#$ 转换到 $q_1$，栈不变；在 $q_1$ 中读取 $0$，错误的规则 $\\delta(q_1, 0, 1) = \\{(q_1, \\epsilon)\\}$ 弹出了 $1$；此时输入已耗尽，栈顶为 $Z_0$，转移 $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$ 使其进入状态 $q_2$。因此 $1\\#0$ 被接受，但 $1\\#0 \\notin L$ 因为 $w=1$ 意味着 $w^R=1$，而不是 $0$。因此这条规则是错误的。\n\n4) $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$。一旦输入被消耗完并且栈已返回到 $Z_0$ 状态，这个规则允许通过最终状态来接受。它与预期的接受条件一致，并且不会引入不正确的接受，因为只有当输入被消耗完时，到达 $q_2$ 才是一个接受配置。\n\n因此，在这些选项中，唯一错误的转移是 $\\delta(q_1, 0, 1) = \\{(q_1, \\epsilon)\\}$，即选项 C。", "answer": "$$\\boxed{C}$$", "id": "1394387"}, {"introduction": "从分析现有设计到亲手构建，我们现在进入综合与设计的阶段。成功设计一个下推自动机，关键在于制定一个清晰的策略来利用栈实现语言的结构要求，例如计数。这个练习提供了一个部分完成的自动机，挑战你补全缺失的关键转移，从而让你实践如何将语言的抽象规则（例如 $a^n b^{2n}$）转化为具体的机器指令 [@problem_id:1394356]。", "problem": "一位计算机科学家正在设计一个下推自动机（Pushdown Automaton, PDA），这是一种计算模型，用于识别上下文无关语言 $L = \\{a^n b^{2n} \\mid n \\ge 1\\}$。如果一个字符串由一个或多个 'a' 后跟两倍数量的 'b' 组成，则该字符串属于 $L$。\n\n该 PDA 由七元组 $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$ 形式化定义，其中：\n- 状态集 $Q = \\{q_0, q_1, q_2\\}$\n- 输入字母表 $\\Sigma = \\{a, b\\}$\n- 栈字母表 $\\Gamma = \\{A, Z_0\\}$\n- 起始状态为 $q_0$\n- 初始栈符号为 $Z_0$\n- 最终（接受）状态集 $F = \\{q_2\\}$\n- 转移函数 $\\delta : Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\times \\Gamma \\to \\mathcal{P}(Q \\times \\Gamma^*)$ 定义了机器的行为。我们将一个转移 $(q', \\gamma') \\in \\delta(q, x, \\gamma)$ 表示为 $(q, x, \\gamma) \\to (q', \\gamma')$, 其中 $q$ 是当前状态，$x$ 是输入符号，$\\gamma$ 是从栈中弹出的符号，$q'$ 是下一个状态，$\\gamma'$ 是推入栈中的字符串。\n\n设计者已经实现了以下转移：\n1.  $(q_0, a, Z_0) \\to (q_0, AAZ_0)$\n2.  $(q_0, a, A) \\to (q_0, AAA)$\n3.  $(q_0, b, A) \\to (q_1, \\epsilon)$\n4.  $(q_1, \\epsilon, Z_0) \\to (q_2, Z_0)$\n\n然而，一条关键的转移规则缺失了。没有这条规则，该 PDA 无法正确接受语言 $L$ 中的所有字符串。必须添加以下哪个转移来完善该 PDA？\n\nA. $(q_1, b, A) \\to (q_1, \\epsilon)$\n\nB. $(q_1, a, A) \\to (q_1, \\epsilon)$\n\nC. $(q_0, \\epsilon, Z_0) \\to (q_2, Z_0)$\n\nD. $(q_1, b, A) \\to (q_0, A)$\n\nE. $(q_0, b, A) \\to (q_0, \\epsilon)$", "solution": "我们需要一个能够识别 $L = \\{a^n b^{2n} \\mid n \\ge 1\\}$ 的 PDA。其工作方式是：为每个 $a$ 推入两个栈符号，然后为每个 $b$ 弹出一个栈符号，并且仅在为 $a$ 推入的所有 $A$ 都被弹出且输入结束时才接受字符串。\n\n分析给定的关于 $a$ 的转移：\n- $(q_0, a, Z_0) \\to (q_0, AAZ_0)$ 为第一个 $a$ 推入两个 $A$。\n- $(q_0, a, A) \\to (q_0, AAA)$ 将栈顶的 $A$ 替换为 $AAA$，这相当于为每个后续的 $a$ 净增加两个 $A$。\n\n对在状态 $q_0$ 中读取的 $a$ 的数量 $k$ 进行归纳证明：\n- 基础情况 $k=1$：当栈顶是 $Z_0$ 时，读取一个 $a$ 后，栈变为 $A^2 Z_0$。\n- 归纳步骤：假设读取 $k$ 个 $a$ 后栈为 $A^{2k}Z_0$。当栈顶为 $A$ 时再读取一个 $a$，会应用转移 $(q_0, a, A) \\to (q_0, AAA)$，该转移用 $AAA$ 替换一个 $A$，增加了两个 $A$。因此栈变为 $A^{2(k+1)}Z_0$。\n因此，在 $q_0$ 状态下读取 $k$ 个 $a$ 后，栈的内容是 $A^{2k}Z_0$。\n\n现在，处理 $b$ 的阶段必须通过为每个 $b$ 弹出一个 $A$ 来消耗恰好 $2k$ 个 $b$。已提供的转移\n- $(q_0, b, A) \\to (q_1, \\epsilon)$\n处理遇到的第一个 $b$，弹出一个 $A$ 并转移到 $q_1$。为了继续消耗剩下的 $b$，我们需要在 $q_1$ 中有一个转移，该转移为每个 $b$ 弹出一个 $A$ 并保持在 $q_1$ 状态。这个必要的规则是\n- $(q_1, b, A) \\to (q_1, \\epsilon)$，\n它确保在 $q_1$ 状态下读取 $m$ 个 $b$ 之后，栈的内容变为 $A^{2k-m}Z_0$。\n\n最后，接受必须在所有 $A$ 都被弹出且输入结束时发生。给定的转移\n- $(q_1, \\epsilon, Z_0) \\to (q_2, Z_0)$\n允许在栈顶恰好为 $Z_0$ 时进行一个到接受状态 $q_2$ 的 $\\epsilon$-移动，也就是说，在消耗了恰好 $2k$ 个 $b$ 之后。如果读取的 $b$ 少于 $2k$ 个，栈中至少会剩下一个 $A$，因此无法启用 $\\epsilon$-接受。如果读取的 $b$ 多于 $2k$ 个，当栈顶为 $Z_0$ 时会遇到一个 $b$，对此没有定义转移，从而导致拒绝。此外，一旦进入状态 $q_1$，就没有关于 $a$ 的转移，所以 $a$ 不能出现在任何 $b$ 之后，这保证了 $a^n b^{2n}$ 的要求形式。\n\n因此，缺失的规则必须是 $(q_1, b, A) \\to (q_1, \\epsilon)$，即选项 A。\n\n为什么其他选项不正确：\n- B: $(q_1, a, A) \\to (q_1, \\epsilon)$ 会允许在开始 $b$ 阶段后出现 $a$，从而接受不属于 $L$ 的字符串。\n- C: $(q_0, \\epsilon, Z_0) \\to (q_2, Z_0)$ 会接受空字符串，但 $n \\ge 1$ 的条件排除了空字符串。\n- D: $(q_1, b, A) \\to (q_0, A)$ 既没有弹出 $A$，也没有阻止返回到 $a$ 阶段，破坏了所需的分隔和计数。\n- E: $(q_0, b, A) \\to (q_0, \\epsilon)$ 在读取 $b$ 时使机器保持在 $q_0$ 状态，这会允许 $a$ 和 $b$ 交错出现，而没有建立严格的先 $a$ 后 $b$ 的阶段。", "answer": "$$\\boxed{A}$$", "id": "1394356"}]}