{"hands_on_practices": [{"introduction": "我们将从一个基本问题开始：我们能否编写一个算法来检查程序代码的某个结构性特征？这项练习 [@problem_id:1377291] 探讨了一个基于图灵机编码的简单、可验证属性的语言。它将帮助你理解，判定器有时可以像一个语法检查器一样，通过分析机器的描述本身来工作，而无需模拟其复杂的动态行为。", "problem": "在计算理论中，我们通过将算法建模为图灵机（TMs）来分析其性质。一台图灵机 $M$ 可以被一个元组形式化地描述，该元组代表了它的状态集、带字母表、转移函数、起始状态、接受状态和拒绝状态。任何这样的形式化描述都可以被编码为一个有限长度的字符串，记作 $\\langle M \\rangle$。\n\n考虑在这些编码的字母表上定义的语言 $L$。语言 $L$ 由所有具有特定结构属性的图灵机字符串编码组成。具体来说，该语言定义为：\n$$L = \\{ \\langle M \\rangle \\mid M \\text{ 是一台具有有限个偶数状态的图灵机} \\}$$\n\n语言 $L$ 是可判定的吗？请从以下选项中选择正确的陈述和理由。\n\nA. 语言 $L$ 是可判定的，因为可以构建一个判定器来解析编码 $\\langle M \\rangle$，计算机器描述中指定的状态数量，如果这个数量是偶数，则接受。这个过程保证对任何输入都会停机。\n\nB. 语言 $L$ 是不可判定的，因为确定图灵机的属性需要解决停机问题，因为需要查看在计算过程中实际使用了哪些状态。\n\nC. 语言 $L$ 是不可判定的，因为根据莱斯定理（Rice's Theorem），图灵机所识别语言的任何非平凡属性都是不可判定的。\n\nD. 语言 $L$ 是可判定的，因为可以使用通用图灵机在所有可能的输入上模拟 $M$，以计算它进入的状态数量，并且由于状态数量是有限的，模拟最终将确定访问过的状态数量是否为偶数。", "solution": "我们给定的语言是 $L = \\{ \\langle M \\rangle \\mid M \\text{ 是一台具有有限个偶数状态的图灵机} \\}$。在图灵机的标准形式化定义中，状态集 $Q$ 根据定义是有限的。因此，定义 $L$ 的属性可以归结为基数 $|Q|$ 为偶数的语法属性。\n\n为了判定 $L$，构建一个判定器 $D$ 对任意输入字符串 $w$ 进行如下操作：\n1. 在固定的、有效的编码方案下，验证 $w$ 是否为图灵机的有效编码 $\\langle M \\rangle$。这个检查是对有限字符串的有限语法解析过程，是可判定的。如果 $w$ 不是一个有效的编码，则拒绝，因为 $w \\notin L$。\n2. 如果 $w = \\langle M \\rangle$ 是有效的，解析该描述以提取 $M$ 的状态集 $Q$，并通过计算编码中列出的状态来计算 $n = |Q|$。\n3. 计算 $n \\bmod 2$，当且仅当 $n \\bmod 2 = 0$ 时接受。\n\n正确性：根据构造，该机器恰好接受那些其图灵机具有偶数个状态的编码。停机性：每个步骤都包括解析有限字符串以及执行有限的计数和算术运算，因此该过程对所有输入都会停机。因此 $L$ 是可判定的。\n\n这与陈述 A 相符。陈述 B 是不正确的，因为该属性关系到描述中定义的状态数量，而不是在任何计算过程中访问了哪些状态，所以无需诉诸停机问题。陈述 C 错误地应用了莱斯定理（Rice’s Theorem），该定理涉及图灵机所识别语言的语义属性；而这里的属性是关于机器编码的纯粹语法属性。陈述 D 是不正确的，因为在所有输入上进行模拟是不必要的，并且不会产生一个通用的判定器；此外，它计算的是访问过的状态，而不是定义的状态总数。\n\n因此，正确的选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1377291"}, {"introduction": "停机问题是不可判定问题的著名范例，但如果我们对计算施加一个“最后期限”，情况会如何？这项练习 [@problem_id:1377286] 让你直面这个经典问题的一个变体。它旨在揭示资源限制如何从根本上改变一个问题的可计算性，通过一个固定步数的模拟，将一个普遍意义上的不可解问题转变为一个具体场景下的可解问题。", "problem": "在计算理论中，我们研究机器的基本能力和局限性。图灵机（TM）是一种假设的计算设备的数学模型，它根据一套规则在一条带子上操作符号。图灵机的描述，记作 $\\langle M \\rangle$，是一个编码其状态、字母表和转移函数的有限字符串。\n\n语言是一个字符串的集合。我们说一个语言 $L$ 是**可判定的**（decidable），如果存在一个特殊的图灵机，称为判定器（decider），对于任何给定的输入字符串 $w$，它总会停机并正确地确定 $w$ 是否在 $L$ 中。如果一个图灵机停机并进入一个指定的`accept`（接受）状态，我们说它接受了该输入。\n\n考虑以下语言，我们称之为 $L_{CyberGuard}$：\n$$L_{CyberGuard} = \\{ \\langle M \\rangle \\mid M \\text{ 是一个在至多 4096 步内接受其自身描述 } \\langle M \\rangle \\text{ 作为输入的图灵机} \\}$$\n\n关于语言 $L_{CyberGuard}$，以下哪个陈述是正确的？\n\nA. $L_{CyberGuard}$ 是可判定的。\n\nB. $L_{CyberGuard}$ 是不可判定的，因为它等价于停机问题，而停机问题是已知的不可判定问题。\n\nC. $L_{CyberGuard}$ 是不可判定的，但它是图灵可识别的（也称为递归可枚举的）。\n\nD. 在不知道用于 $\\langle M \\rangle$ 的具体编码方案的情况下，无法确定 $L_{CyberGuard}$ 的可判定性。\n\nE. $L_{CyberGuard}$ 是一个空语言，因为没有图灵机可以分析自己的代码。", "solution": "我们旨在确定语言 $L_{CyberGuard} = \\{ \\langle M \\rangle \\mid M \\text{ 在至多 } 4096 \\text{ 步内接受 } \\langle M \\rangle \\}$ 的可判定性。\n\n关键原则：对于任何固定的时间界限 $t \\in \\mathbb{N}$，属性“$M$ 在至多 $t$ 步内接受 $w$”是可判定的。这是因为通用模拟器可以在至多 $t$ 步内模拟 $M$ 在输入 $w$ 上的运行，这是一个有限的、有效有界的计算。因此，执行此模拟并在界限内检查接受状态的机器是一个判定器。\n\n为 $L_{CyberGuard}$ 构建一个判定器 $D$：\n- 在输入字符串 $x$ 上：\n  1. 检查 $x$ 是否是某个图灵机的有效编码。如果不是，则拒绝。对于任何固定的有效图灵机编码，这种解析检查都是可判定的。\n  2. 令 $x = \\langle M \\rangle$。使用标准的通用图灵机程序，在输入 $\\langle M \\rangle$ 上模拟 $M$ 的运行，最多 4096 步。维护一个初始化为 $0$ 的计数器 $c$。\n  3. 当 `c  4096` 且 $M$ 尚未停机时，执行一次模拟转移并设置 $c := c + 1$。\n  4. 如果在此模拟期间，$M$ 在 $c$ 达到 4096 之前进入接受状态，则接受；否则拒绝。\n\n停机性：循环最多执行 4096 次迭代，并且每个模拟步骤都是可计算的。因此 $D$ 在所有输入上都会停机，所以 $D$ 是一个判定器。\n\n正确性：根据构造，$D$ 恰好接受那些满足“$M$ 在至多 4096 步内接受 $\\langle M \\rangle$”的编码 $\\langle M \\rangle$，这正是 $L_{CyberGuard}$ 的定义。\n\n对各个选项的分析：\n- A 是正确的：$L_{CyberGuard}$ 可由上述判定器 $D$ 判定。\n- B 是错误的：与停机问题（无界）不同，这里的时间受一个固定常数限制，这使得该属性是可判定的。\n- C 是错误的：该语言不仅仅是图灵可识别的；它是可判定的。\n- D 是错误的：可判定性不依赖于具体的标准编码，只要它是有效的编码即可；对于任何固定的有效编码，上述判定器都有效。\n- E 是错误的：该语言不是空语言；例如，一个立即接受任何输入的图灵机，会在少于 4096 步内接受其自身的描述。\n\n因此，正确的陈述是 A。", "answer": "$$\\boxed{A}$$", "id": "1377286"}, {"introduction": "现实世界的系统验证通常需要满足多个标准，其中一些标准可以被完全自动化地检查，而另一些则可能导致分析过程无限运行。这个问题 [@problem_id:1377273] 通过一个可判定语言和一个图灵可识别语言的交集来精确地模拟这一场景。这是一个绝佳的练习，它能让你深入理解不同语言类的定义，并学习如何构造一个新的计算模型来处理组合后的复杂属性。", "problem": "在理论计算机科学领域，我们根据解决问题所需的计算能力对问题进行分类。一个“语言”被形式化地定义为一个字符串集合。我们使用图灵机作为我们的计算模型。\n\n我们来定义两类重要的语言：\n1.  如果存在一台图灵机，对于任意给定的输入字符串 $w$，它总能停机并正确判断 $w$ 是否在 $L$ 中，那么语言 $L$ 是**可判定的**。这种类型的图灵机被称为“判定器”。\n2.  如果存在一台图灵机，对于任意给定的输入字符串 $w$，当 $w$ 在 $L$ 中时，它会停机并接受，那么语言 $L$ 是**图灵可识别的**。然而，如果 $w$ 不在 $L$ 中，该机器可能会停机并拒绝，也可能会无限循环。这种类型的图灵机被称为“识别器”。注意，每个可判定的语言也都是图灵可识别的，但反之不一定成立。\n\n考虑一个场景：一家网络安全公司正在为软件驱动程序开发一个自动验证系统。该系统根据两个不同的标准来检查每个驱动程序（表示为一个字符串）：\n\n*   **标准 A（语法和类型安全）：** 如果一个驱动程序遵守一套严格的语法和类型安全规则，它就通过此项检查。我们已经构建了一台图灵机 $M_A$，它可以处理任何驱动程序，并保证能够停机报告其是否通过此项检查。令 $L_A$ 为满足标准A的所有驱动程序的语言。\n\n*   **标准 B（安全漏洞）：** 如果一个驱动程序可以被证明不含有一种特定的、复杂的零日漏洞，它就通过此项检查。为此，我们使用第二台图灵机 $M_B$。如果一个驱动程序没有该漏洞，$M_B$ 最终会停机并确认这一点。然而，如果驱动程序*确实*包含该漏洞，分析过程会非常复杂，以至于 $M_B$ 可能会永远运行而无法给出明确的答案。令 $L_B$ 为满足标准B的所有驱动程序的语言。\n\n该公司对满足*两个*标准的驱动程序集合感兴趣。令这个集合为语言 $L_{AB} = L_A \\cap L_B$。根据图灵机 $M_A$ 和 $M_B$ 的性质，对于*任何*符合描述的语言 $L_A$ 和 $L_B$，关于语言 $L_{AB}$ 能做出的最强的正确陈述是什么？\n\nA. $L_{AB}$ 总是可判定的。\n\nB. $L_{AB}$ 总是图灵可识别的。\n\nC. 不保证 $L_{AB}$ 是图灵可识别的。\n\nD. $L_{AB}$ 总是余图灵可识别的（意味着其补集 $\\overline{L_{AB}}$ 是图灵可识别的）。\n\nE. 没有关于这些标准的更具体信息，无法确定 $L_{AB}$ 的可计算性。", "solution": "我们已知 $L_A$ 是可判定的，因此存在一个判定器 $M_A$，它在所有输入上都会停机，并且只接受 $L_A$ 中的字符串。因此 $L_A$ 也是图灵可识别的。我们还已知 $L_B$ 是图灵可识别的，由一个识别器 $M_B$ 来证明，它对 $L_B$ 中的字符串会停机并接受，而对不在 $L_B$ 中的字符串可能会拒绝或无限循环。\n\n我们如下分析 $L_{AB} = L_A \\cap L_B$。\n\n为了证明 $L_{AB}$ 总是图灵可识别的，我们使用 $M_A$ 和 $M_B$ 构建一个 $L_{AB}$ 的识别器 $M_{AB}$：\n- 在输入 $w$ 上，运行 $M_A$。由于 $M_A$ 是 $L_A$ 的一个判定器，它会停机并接受或拒绝。\n- 如果 $M_A$ 拒绝，则拒绝 $w$。\n- 如果 $M_A$ 接受，则在 $w$ 上模拟 $M_B$，并在 $M_B$ 接受时接受。如果 $M_B$ 永不接受，则不停机。\n\n$M_{AB}$ 的正确性：\n- 如果 $w \\in L_A \\cap L_B$，那么 $M_A$ 接受 $w$，并且 $M_B$ 也接受 $w$，所以 $M_{AB}$ 接受 $w$。\n- 如果 $w \\notin L_A \\cap L_B$，那么要么 $w \\notin L_A$，此时 $M_A$ 拒绝，$M_{AB}$ 也拒绝；要么 $w \\in L_A$ 但 $w \\notin L_B$，此时 $M_B$ 永不接受，$M_{AB}$ 也无需停机。这种行为满足 $L_{AB}$ 的图灵识别器的定义。\n\n因此，$L_{AB}$ 总是图灵可识别的。\n\n接下来，我们证明 $L_{AB}$ 不必是可判定的，也不必是余图灵可识别的。令 $\\Sigma$ 为任意固定的有限字母表，并取 $L_A = \\Sigma^{*}$，这是一个可判定的语言，可由一台接受所有输入的机器来判定。令 $L_B = K$，其中 $K = \\{ \\langle M,w \\rangle : \\text{$M$ 在输入 $w$ 上停机} \\}$ 是标准的停机语言，它是图灵可识别的，但不是可判定的，也不是余图灵可识别的。那么\n$$\nL_{AB} \\;=\\; L_A \\cap L_B \\;=\\; \\Sigma^{*} \\cap K \\;=\\; K,\n$$\n因此，在这个例子中，$L_{AB}$ 不是可判定的，也不是余图灵可识别的。因此，断言可判定性或余图灵可识别性在一般情况下成立的陈述是错误的，并且“可识别性无法确定”这一情况也不成立，因为我们已经证明了它总是成立的。\n\n因此，最强的正确一般性陈述是 $L_{AB}$ 总是图灵可识别的。", "answer": "$$\\boxed{B}$$", "id": "1377273"}]}