{"hands_on_practices": [{"introduction": "掌握二叉树的关键在于理解其结构和遍历方式之间的内在联系。后序遍历和中序遍历序列共同提供了唯一确定一棵二叉树所需的所有信息。本练习将引导你运用这两种遍历的特性，通过识别根节点和划分左右子树，来精确地重建树的局部结构 [@problem_id:1352772]。", "problem": "一个非空二叉树由其唯一的节点遍历方式所定义。一个具有7个节点、标有唯一字符的特定二叉树的后序遍历序列为 `[D, E, B, F, G, C, A]`。同一棵树的中序遍历序列为 `[D, B, E, A, F, C, G]`。\n\n根据这两种遍历方式，确定根节点的右子树的中序遍历。\n\n从以下选项中选择正确的序列。\n\nA. `F, C, G`\n\nB. `F, G, C`\n\nC. `C, F, G`\n\nD. `D, B, E`\n\nE. `G, C, F`", "solution": "我们已知同一棵具有唯一节点标签的二叉树的后序遍历为 $[D,E,B,F,G,C,A]$，中序遍历为 $[D,B,E,A,F,C,G]$。\n\n1.  **确定根节点**：根据后序遍历（左-右-根）的定义，序列的最后一个元素是树的根。因此，根节点是 $A$。\n2.  **划分左右子树**：根据中序遍历（左-根-右）的定义，在中序遍历序列 $[D,B,E,A,F,C,G]$ 中找到根节点 $A$ 的位置。所有在 $A$ 左边的元素构成左子树，所有在 $A$ 右边的元素构成右子树。\n    *   左子树的中序遍历：$[D,B,E]$\n    *   右子树的中序遍历：$[F,C,G]$\n\n问题要求的是根节点右子树的中序遍历，因此序列 $[F, C, G]$ 就是答案。这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1352772"}, {"introduction": "二叉搜索树 (BST) 是一个带有额外排序规则的特殊二叉树，这个规则极大地增强了其功能。对于普通二叉树，仅有前序遍历序列不足以确定其结构，但对于BST，其内在的顺序性使之成为可能。这个练习将向你展示如何利用BST的这一强大特性，仅从一个前序遍历序列出发，就能完整地推导出树的另一种遍历序列 [@problem_id:1352792]。", "problem": "二叉搜索树（BST）是一种有根二叉树数据结构，其中每个内部节点的键都大于其左子树中所有节点的键，并小于其右子树中所有节点的键。二叉树的三种最常见的深度优先遍历方法是：\n- 前序遍历：访问根节点，然后遍历左子树，再遍历右子树。\n- 中序遍历：遍历左子树，然后访问根节点，再遍历右子树。\n- 后序遍历：遍历左子树，然后遍历右子树，再访问根节点。\n\n给定一个特定二叉搜索树的前序遍历得到的节点值序列：`[30, 20, 10, 25, 40, 35, 45]`。\n\n无需直观地构建这棵树，请确定该二叉搜索树的正确后序遍历序列。\n\n从以下选项中选择正确的序列。\n\nA. `10, 25, 20, 35, 45, 40, 30`\n\nB. `10, 20, 25, 30, 35, 40, 45`\n\nC. `45, 35, 40, 25, 10, 20, 30`\n\nD. `35, 45, 40, 10, 25, 20, 30`", "solution": "使用 BST 的性质和遍历的定义：\n\n1) 在 BST 中，根节点左子树中的所有键都小于根节点，右子树中的所有键都大于根节点。在前序遍历中，第一个元素是根节点，其后是左子树的前序遍历，然后是右子树的前序遍历。\n\n给定前序序列 $[30,20,10,25,40,35,45]$，根节点是 $30$。通过与 $30$ 比较，将剩余元素划分为左子树和右子树：\n$$\\text{左子序列：}[20,10,25]\\quad(\\text{均}  30),\\qquad \\text{右子序列：}[40,35,45]\\quad(\\text{均} > 30)。$$\n\n2) 对左子序列 $[20,10,25]$ 进行递归。根节点是 $20$。通过与 $20$ 比较进行划分：\n$$\\text{20 的左侧：}[10],\\qquad \\text{20 的右侧：}[25].$$\n因此，左子树的根节点是 $20$，左孩子是 $10$，右孩子是 $25$。\n\n3) 对右子序列 $[40,35,45]$ 进行递归。根节点是 $40$。通过与 $40$ 比较进行划分：\n$$\\text{40 的左侧：}[35],\\qquad \\text{40 的右侧：}[45].$$\n因此，右子树的根节点是 $40$，左孩子是 $35$，右孩子是 $45$。\n\n4) 计算后序遍历（左、右、根）：\n- 左子树的后序遍历：访问 $[10]$，然后是 $[25]$，再是 $20$，得到 $[10,25,20]$。\n- 右子树的后序遍历：访问 $[35]$，然后是 $[45]$，再是 $40$，得到 $[35,45,40]$。\n- 整棵树的后序遍历：左子树 $[10,25,20]$，右子树 $[35,45,40]$，然后是根节点 $30$，得出\n$$[10,25,20,35,45,40,30].$$\n\n5) 与选项比较：结果与选项 A 匹配。", "answer": "$$\\boxed{A}$$", "id": "1352792"}, {"introduction": "理论知识的价值最终体现在解决实际问题上。二叉搜索树的中序遍历会产生一个严格递增的序列，这一特性不仅是理论上的，更是数据校验的有力工具。本练习模拟了一个真实场景：在一个本应有序的数据序列中，由于两个元素的错位导致了顺序异常，你的任务就是利用BST的这一基本性质来定位问题所在，这体现了数据结构知识在调试和维护中的实际应用 [@problem_id:1352833]。", "problem": "一个数据采集系统被设计用于记录一系列不同的测量值。该系统将这些测量值作为节点存储在二叉搜索树（BST）中。二叉搜索树是一种数据结构，对于任意给定节点，其左子树中的所有值都小于该节点的值，而其右子树中的所有值都大于该节点的值。为了导出数据，系统执行中序遍历。对于一个结构正确的BST，中序遍历应产生一个严格递增的数值序列。\n\n在一次常规的数据完整性检查中，系统输出了以下序列。已知该序列是对一个BST进行中序遍历的结果，但由于内存故障，其中恰好有两个节点的值被交换了：\n$$\nS = [22, 35, 94, 48, 56, 65, 71, 89, 41, 99, 105]\n$$\n你的任务是找出被交换的两个值。请将你的答案表示为一个 $1 \\times 2$ 的矩阵，其中较小的数字在前。例如，如果你确定被交换的数字是5和10，你的答案应格式化为 $\\begin{pmatrix} 5  10 \\end{pmatrix}$。", "solution": "对于一个有效的二叉搜索树（BST），中序遍历会产生一个严格递增的序列。如果恰好有两个节点的值被交换，那么在中序遍历序列中，将会出现一个或两个不满足顺序条件的位置，即满足 $S_{i}  S_{i+1}$ 的位置。如果在正确的顺序中，被交换的元素不相邻，则会发生两次这样的违规；如果它们相邻，则只会发生一次。\n\n给定 $S = [22, 35, 94, 48, 56, 65, 71, 89, 41, 99, 105]$，我们扫描序列以寻找满足 $S_{i}  S_{i+1}$ 的索引 $i$：\n- 比较 $22, 35$ 和 $35, 94$：没有违规。\n- 在 $94$ 和 $48$ 处，我们有 $94 > 48$：第一次违规。将较大的前一个元素记录为候选值 $x = 94$。\n- 继续：$48, 56, 65, 71, 89$：没有违规。\n- 在 $89$ 和 $41$ 处，我们有 $89 > 41$：第二次违规。将较小的后一个元素记录为另一个候选值 $y = 41$。\n- 继续：$41, 99, 105$：没有更多违规。\n\n出现两次违规，说明被交换的值是第一次违规中较大的元素和第二次违规中较小的元素，即 $x = 94$ 和 $y = 41$。\n\n通过在 $S$ 中交换这两个值进行验证，得到：\n$$[22, 35, 41, 48, 56, 65, 71, 89, 94, 99, 105],$$\n该序列是严格递增的，从而证实了我们的判断。\n\n因此，被交换的值是 $41$ 和 $94$，所要求的将较小值放在前面的 $1 \\times 2$ 矩阵是 $\\begin{pmatrix} 41  94 \\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix} 41  94 \\end{pmatrix}}$$", "id": "1352833"}]}