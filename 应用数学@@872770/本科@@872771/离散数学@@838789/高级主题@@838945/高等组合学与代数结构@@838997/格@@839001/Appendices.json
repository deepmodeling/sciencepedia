{"hands_on_practices": [{"introduction": "理解格的第一步是掌握其底层的偏序关系。这个练习通过一个关于开关的直观场景，帮助你从基本关系出发，构建一个四元布尔代数的结构。通过识别“直接后继”关系，你可以练习构建格的哈斯图，这是将抽象代数结构可视化的关键一步 [@problem_id:1380545]。", "problem": "一个简单的设备控制面板有两个独立的拨动开关，开关1和开关2。每个开关可以处于关状态（用整数0表示）或开状态（用整数1表示）。控制面板的整体状态由一个有序对 $(s_1, s_2)$ 描述，其中 $s_1$ 是开关1的状态，$s_2$ 是开关2的状态。\n\n如果可以仅通过将开关从关（OFF）拨到开（ON）来从状态 $A = (a_1, a_2)$ 转换到状态 $B = (b_1, b_2)$，则状态 $A$ 被定义为状态 $B$ 的“前驱”（precursor）。换句话说，在此过程中，已经处于开状态的开关不能被拨回关状态。我们用 $A \\preceq B$ 表示这种关系。\n\n此外，我们定义状态 $B$ 为状态 $A$ 的“直接后继”（immediate successor），如果 $A$ 是 $B$ 的前驱（$A \\preceq B$），$A$ 不等于 $B$，并且不存在一个不同的状态 $C$（其中 $C \\ne A$ 且 $C \\ne B$）使得 $A$ 是 $C$ 的前驱且 $C$ 是 $B$ 的前驱。\n\n以下哪个集合正确且完整地列出了所有使得 $B$ 是 $A$ 的直接后继的状态对 $(A, B)$？\n\nA. $\\{((0,0), (1,0)), ((0,0), (0,1)), ((1,0), (1,1)), ((0,1), (1,1))\\}$\n\nB. $\\{((0,0), (1,0)), ((0,0), (0,1)), ((0,0), (1,1))\\}$\n\nC. $\\{((0,0), (1,1)), ((1,0), (0,1))\\}$\n\nD. $\\{((0,0), (1,0)), ((0,0), (0,1)), ((1,0), (1,1)), ((0,1), (1,1)), ((0,0), (1,1))\\}$\n\nE. $\\{((1,0), (0,0)), ((0,1), (0,0)), ((1,1), (1,0)), ((1,1), (0,1))\\}$", "solution": "设控制面板的状态集合为 $S$。由于两个开关中的每一个都可以处于两种状态（0或1）之一，因此总的状态数为 $2 \\times 2 = 4$。状态集合为：\n$S = \\{(0,0), (1,0), (0,1), (1,1)\\}$。\n\n对于两个状态 $A = (a_1, a_2)$ 和 $B = (b_1, b_2)$，“前驱”关系 $A \\preceq B$ 被定义为能够仅通过将开关从关（0）拨到开（1）来从 $A$ 转换到 $B$。这意味着对于每个开关，其在状态 $B$ 中的状态必须大于或等于其在状态 $A$ 中的状态。在数学上，这可以表示为：\n$(a_1, a_2) \\preceq (b_1, b_2)$ 当且仅当 $a_1 \\le b_1$ 且 $a_2 \\le b_2$。\n这在状态集合 $S$ 上定义了一个偏序关系。\n\n问题要求找出所有的状态对 $(A, B)$，其中 $B$ 是 $A$ 的“直接后继”。根据定义，这意味着：\n1. $A \\preceq B$\n2. $A \\ne B$（这可以与第一个条件合并写为 $A \\prec B$）\n3. 不存在状态 $C$ 使得 $A \\prec C \\prec B$。\n\n这是偏序集中覆盖关系的定义。我们需要找到所有满足 $B$ 覆盖 $A$ 的对 $(A, B)$。我们可以通过系统地检查所有可能的不同状态对来做到这一点。\n\n为清晰起见，我们表示这些状态：\n$S_A = (0,0)$\n$S_B = (1,0)$\n$S_C = (0,1)$\n$S_D = (1,1)$\n\n我们可以分析状态对 $(X, Y)$ 之间的关系，其中 $X \\ne Y$：\n\n1.  **涉及 $S_A = (0,0)$ 作为前驱的状态对：**\n    -   $S_B = (1,0)$ 是 $S_A$ 的直接后继吗？\n        我们有 $(0,0) \\preceq (1,0)$ 因为 $0 \\le 1$ 且 $0 \\le 0$。它们不相等。我们需要检查是否存在一个状态 $C=(c_1, c_2)$ 使得 $(0,0) \\prec (c_1, c_2) \\prec (1,0)$。这将意味着 $0 \\le c_1 \\le 1$，$0 \\le c_2 \\le 0$，并且 $C$ 必须不同于 $(0,0)$ 和 $(1,0)$。对第二个分量的条件意味着 $c_2 = 0$。对第一个分量的条件，结合 $C \\ne (0,0)$ 和 $C \\ne (1,0)$，是不可能的，因为 $c_1$ 必须是整数。因此，不存在这样的中间状态 $C$。所以，$((0,0), (1,0))$ 是一个有效的对。\n    -   $S_C = (0,1)$ 是 $S_A$ 的直接后继吗？\n        通过与前一个案例的对称性，我们有 $(0,0) \\preceq (0,1)$，并且没有中间状态。所以，$((0,0), (0,1))$ 是一个有效的对。\n    -   $S_D = (1,1)$ 是 $S_A$ 的直接后继吗？\n        我们有 $(0,0) \\preceq (1,1)$ 因为 $0 \\le 1$ 且 $0 \\le 1$。但是我们可以找到一个中间状态。例如，令 $C = S_B = (1,0)$。我们有 $(0,0) \\prec (1,0)$ 且 $(1,0) \\prec (1,1)$。所以，$(0,0) \\prec (1,0) \\prec (1,1)$。由于存在中间状态，$S_D$ 不是 $S_A$ 的直接后继。\n\n2.  **涉及 $S_B = (1,0)$ 作为前驱的状态对：**\n    -   $S_C = (0,1)$ 是后继吗？不是，因为 $1 \\not\\le 0$，所以 $(1,0) \\not\\preceq (0,1)$。这两个状态是不可比的。\n    -   $S_D = (1,1)$ 是 $S_B$ 的直接后继吗？\n        我们有 $(1,0) \\preceq (1,1)$ 因为 $1 \\le 1$ 且 $0 \\le 1$。我们检查是否存在中间状态 $C=(c_1, c_2)$ 使得 $(1,0) \\prec (c_1, c_2) \\prec (1,1)$。这要求 $1 \\le c_1 \\le 1$ 且 $0 \\le c_2 \\le 1$。第一部分意味着 $c_1 = 1$。不等性要求 $C \\ne (1,0)$ 且 $C \\ne (1,1)$，这对于整数 $c_2$ 是不可能的。不存在中间状态。所以，$((1,0), (1,1))$ 是一个有效的对。\n\n3.  **涉及 $S_C = (0,1)$ 作为前驱的状态对：**\n    -   $S_D = (1,1)$ 是 $S_C$ 的直接后继吗？\n        通过与 $S_B$ 的情况对称，我们有 $(0,1) \\preceq (1,1)$，并且没有中间状态。所以，$((0,1), (1,1))$ 是一个有效的对。\n\n总结一下 $B$ 是 $A$ 的直接后继的状态对 $(A, B)$：\n- $((0,0), (1,0))$\n- $((0,0), (0,1))$\n- $((1,0), (1,1))$\n- $((0,1), (1,1))$\n\n这些对的完整集合是 $\\{((0,0), (1,0)), ((0,0), (0,1)), ((1,0), (1,1)), ((0,1), (1,1))\\}$。\n这对应于选项A。\n\n我们简要分析一下错误的选项：\n-   选项B不完整；它漏掉了 $(1,0)$ 和 $(0,1)$ 的后继。\n-   选项C包含了 $((0,0), (1,1))$，这不是一个直接后继关系，以及 $((1,0), (0,1))$，其中两个状态是不可比的。\n-   选项D是所有 $A \\ne B$ 的前驱关系集合（直接后继关系的传递闭包），但它错误地包含了非直接后继对 $((0,0), (1,1))$。\n-   选项E颠倒了前驱关系。\n\n因此，唯一正确的选项是A。", "answer": "$$\\boxed{A}$$", "id": "1380545"}, {"introduction": "一旦我们理解了格的结构，下一步就是学习如何在其中进行运算，例如“交”（meet）和“并”（join）。这个问题将我们带入一个更复杂的系统，演示了在积格（product lattice）中这些运算是如何逐点（pointwise）进行的。掌握这种分量计算是在计算机科学中处理许多常见格的基本技能 [@problem_id:1380519]。", "problem": "考虑一个由四个数字组件组成的系统，其索引集为 $\\{1, 2, 3, 4\\}$。每个组件可以处于两种状态之一：“关”（用整数 0 表示）或“开”（用整数 1 表示）。系统的一个完整状态可以用函数 $s: \\{1, 2, 3, 4\\} \\to \\{0, 1\\}$ 来描述，其中 $s(i)$ 表示组件 $i$ 的状态。\n\n所有可能的系统状态集合上定义了一个偏序关系 $\\preceq$。对于任意两个状态 $s_1$ 和 $s_2$，我们定义 $s_1 \\preceq s_2$ 当且仅当对于每个组件 $i \\in \\{1, 2, 3, 4\\}$，都有 $s_1(i) \\le s_2(i)$，这里使用的是标准的整数比较 $0 \\le 1$。这个结构构成一个格。\n\n定义了两个特定的状态 $f$ 和 $g$ 如下：\n- 状态 $f$：组件 1 和 3 为“开”，而组件 2 和 4 为“关”。\n- 状态 $g$：组件 2 和 3 为“开”，而组件 1 和 4 为“关”。\n\n您的任务是求出这两个状态的交（meet），记为 $h = f \\land g$。交的定义是关于偏序关系 $\\preceq$ 的 $f$ 和 $g$ 的最大下界。所得状态 $h$ 用其值的元组 $(h(1), h(2), h(3), h(4))$ 表示。以下哪个选项正确地描述了状态 $h$？\n\nA. $(1, 1, 1, 0)$\n\nB. $(0, 0, 1, 0)$\n\nC. $(0, 0, 0, 0)$\n\nD. $(1, 0, 1, 0)$\n\nE. $(0, 1, 1, 0)$", "solution": "状态空间是函数集合 $s:\\{1,2,3,4\\}\\to\\{0,1\\}$，其上的逐分量偏序关系定义为：$s_{1}\\preceq s_{2}$ 当且仅当对每个 $i\\in\\{1,2,3,4\\}$ 都有 $s_{1}(i)\\leq s_{2}(i)$。在这个积格（product lattice）中，交 $f\\land g$ 是通过在每个坐标上取 $\\{0,1\\}$ 中的交来逐点计算的，这等于取最小值：\n$$\n(f\\land g)(i)=\\min\\{f(i),g(i)\\}\\quad\\text{对所有 }i\\in\\{1,2,3,4\\}.\n$$\n根据描述：\n- $f$ 的分量 1 和 3 等于 $1$，分量 2 和 4 等于 $0$，所以 $f=(1,0,1,0)$。\n- $g$ 的分量 2 和 3 等于 $1$，分量 1 和 4 等于 $0$，所以 $g=(0,1,1,0)$。\n\n逐坐标计算交：\n$$\n\\begin{aligned}\nh(1)=\\min\\{f(1),g(1)\\}=\\min\\{1,0\\}=0,\\\\\nh(2)=\\min\\{f(2),g(2)\\}=\\min\\{0,1\\}=0,\\\\\nh(3)=\\min\\{f(3),g(3)\\}=\\min\\{1,1\\}=1,\\\\\nh(4)=\\min\\{f(4),g(4)\\}=\\min\\{0,0\\}=0.\n\\end{aligned}\n$$\n因此，交为 $h=(0,0,1,0)$，对应选项 B。", "answer": "$$\\boxed{B}$$", "id": "1380519"}, {"introduction": "正如我们在群论中研究子群一样，我们在格论中研究子格。这个练习要求你判断一个给定的除数格的子集是否为一个真正的子格，你需要检查它对于原格的交运算（最大公约数）和并运算（最小公倍数）是否封闭。这突显了子集要继承父格的完整结构所需满足的严格条件 [@problem_id:1380475]。", "problem": "在离散数学中，一个偏序集 (poset) $(L, \\preceq)$ 被称为一个格，如果对于集合 $L$ 中的每一对元素 $a, b$，在 $L$ 中都存在唯一的最大下界（称为交，记作 $a \\land b$）和唯一的最小上界（称为并，记作 $a \\lor b$）。\n\n考虑36的所有正整数因子组成的集合，记作 $D_{36}$。这个集合在整除性偏序关系（用符号 $|$ 表示）下构成一个格。对于这个格 $(D_{36}, |)$，两个元素的交是它们的最大公约数 (gcd)，并是它们的最小公倍数 (lcm)。也就是说，对于任意 $x, y \\in D_{36}$，我们有 $x \\land y = \\operatorname{gcd}(x, y)$ 和 $x \\lor y = \\operatorname{lcm}(x, y)$。\n\n格 $L$ 的一个非空子集 $S$ 被称为一个子格，如果 $S$ 在 $L$ 的交和并运算下是封闭的。这意味着对于 $S$ 中的任意两个元素 $a, b$，它们在 $L$ 中计算出的交 $a \\land b$ 和并 $a \\lor b$ 也必须是 $S$ 中的元素。\n\n令 $S$ 是 $D_{36}$ 的一个子集，定义为 $S = \\{1, 2, 3, 4, 6\\}$。判断 $S$ 是否是 $(D_{36}, |)$ 的一个子格。\n\nA. 是，它是一个子格。\n\nB. 否，因为它在交运算（最大公约数）下不封闭。\n\nC. 否，因为它在并运算（最小公倍数）下不封闭。\n\nD. 否，因为它在整除关系下不是一个偏序集。", "solution": "我们在格 $(D_{36}, |)$ 中进行研究，其中 $D_{36}=\\{d\\in \\mathbb{Z}_{>0}: d|36\\}$，交和并运算分别是 $\\operatorname{gcd}$ 和 $\\operatorname{lcm}$。所考虑的子集是 $S=\\{1,2,3,4,6\\}$。一个子格必须在 $D_{36}$ 中计算的交和并运算下是封闭的。\n\n首先，验证交运算的封闭性。对于任意 $a,b\\in S$，计算 $\\operatorname{gcd}(a,b)$ 并检查其是否在 $S$ 中：\n- 对于 $1$：对于所有 $x\\in S$，$\\operatorname{gcd}(1,x)=1\\in S$。\n- $\\operatorname{gcd}(2,3)=1\\in S$，$\\operatorname{gcd}(2,4)=2\\in S$，$\\operatorname{gcd}(2,6)=2\\in S$。\n- $\\operatorname{gcd}(3,4)=1\\in S$，$\\operatorname{gcd}(3,6)=3\\in S$。\n- $\\operatorname{gcd}(4,6)=2\\in S$。\n因此 $S$ 在交运算下是封闭的。\n\n接下来，验证并运算的封闭性。对于任意 $a,b\\in S$，计算 $\\operatorname{lcm}(a,b)$ 并检查其是否在 $S$ 中：\n- 对于 $1$：对于所有 $x\\in S$，$\\operatorname{lcm}(1,x)=x\\in S$。\n- $\\operatorname{lcm}(2,3)=6\\in S$，$\\operatorname{lcm}(2,4)=4\\in S$，$\\operatorname{lcm}(2,6)=6\\in S$。\n- $\\operatorname{lcm}(3,4)=12\\notin S$ 且 $\\operatorname{lcm}(4,6)=12\\notin S$。\n因此 $S$ 在并运算下不封闭。\n\n由于 $S$ 是一个偏序集的子集，在诱导的整除关系下，它仍然是一个偏序集；问题具体在于它没有在并运算（最小公倍数）下封闭。因此，$S$ 不是一个子格，因为它在并运算下不封闭。", "answer": "$$\\boxed{C}$$", "id": "1380475"}]}