{"hands_on_practices": [{"introduction": "Theoretical concepts often become clearest when applied to practical scenarios, such as the automated analysis of programming languages. This first practice explores whether we can algorithmically determine if a formal grammar can produce any valid strings at all. It serves as a foundational example of a non-trivial but decidable problem, demonstrating how we can analyze a finite structure (the grammar) to answer a definitive question about a potentially infinite set (the language it generates) [@problem_id:1361679].", "problem": "A team of computer scientists is designing a new programming language called \"Aether\". To help developers write better code, they want to build a static analysis tool that can detect \"unreachable code\". In Aether's formal specification, the language's syntax is defined by a Context-Free Grammar (CFG). A CFG is formally defined as a 4-tuple $G = (V, T, P, S)$, where:\n- $V$ is a finite set of non-terminal symbols (variables).\n- $T$ is a finite set of terminal symbols (the alphabet of the language), disjoint from $V$.\n- $P$ is a finite set of production rules, where each rule is of the form $A \\to \\alpha$, with $A \\in V$ and $\\alpha$ being a string of symbols from $(V \\cup T)^*$.\n- $S \\in V$ is the special start symbol.\n\nThe language generated by the grammar, denoted $L(G)$, is the set of all strings of terminal symbols that can be derived from the start symbol $S$.\n\nA critical feature of the static analysis tool is to determine if the language defined by Aether's grammar is completely \"dead\"—that is, if it's impossible to generate any valid program (any string of terminals) from the start symbol. In formal terms, the tool needs to decide if $L(G) = \\emptyset$ for the given grammar $G$.\n\nThe team needs to know if it is theoretically possible to create an algorithm that, for any given CFG $G$, will always terminate and correctly answer whether $L(G)$ is empty.\n\nWhich of the following statements correctly assesses the decidability of this problem?\n\nA. Yes, it is decidable. An algorithm can be constructed that systematically identifies all non-terminals capable of generating a terminal string and then checks if the start symbol is one of them.\nB. No, it is undecidable. This problem is computationally equivalent to the Halting Problem, as checking all possible derivations from the start symbol could lead to an infinite loop if the grammar generates an infinite language.\nC. No, it is undecidable. To determine if the language is non-empty, an algorithm would have to check an infinite number of potential strings to see if any can be generated, which is an impossible task.\nD. Yes, it is decidable, but only if the grammar does not contain any recursive rules (e.g., rules of the form $A \\to \\alpha A \\beta$). If recursion is present, the problem becomes undecidable.", "solution": "The problem asks whether there exists an algorithm that can determine if the language generated by an arbitrary Context-Free Grammar (CFG), $L(G)$, is empty. This is known as the emptiness problem for Context-Free Languages. The problem is, in fact, decidable. Let's describe an algorithm that solves it.\n\nThe core idea is to identify all \"productive\" non-terminals in the grammar. A non-terminal is productive if it can derive at least one string consisting entirely of terminals. If the start symbol $S$ is productive, then $L(G)$ is not empty. Otherwise, $L(G)$ is empty.\n\nThe algorithm proceeds as follows:\n\n1.  **Initialization**: We will maintain a set of non-terminals that we have identified as productive. Let's call this set `ProductiveSymbols`. Initially, `ProductiveSymbols` is empty.\n\n2.  **Base Case**: We perform an initial pass through all the production rules $P$ of the grammar $G = (V, T, P, S)$. We identify all non-terminals $A$ that have a rule of the form $A \\to w$, where $w$ is a string consisting exclusively of terminal symbols from $T$ (including the empty string $\\epsilon$). For every such rule, we add the non-terminal $A$ to our set `ProductiveSymbols`.\n\n3.  **Iterative Step**: We repeatedly iterate through the set of all production rules $P$. In each iteration, for every rule $B \\to \\alpha_1 \\alpha_2 ... \\alpha_k$, we check if every symbol $\\alpha_i$ in the right-hand side string is either a terminal symbol or a non-terminal symbol that is already in our `ProductiveSymbols` set. If this condition holds for a rule with a non-terminal $B$ on the left-hand side, and $B$ is not yet in `ProductiveSymbols`, we add $B$ to `ProductiveSymbols`.\n\n4.  **Termination**: We continue the iterative step (Step 3) until a full pass over all production rules results in no new non-terminals being added to `ProductiveSymbols`. This process is guaranteed to terminate because the set of non-terminals $V$ is finite, and in each step that modifies the set, we add at least one non-terminal. The size of `ProductiveSymbols` can at most be $|V|$.\n\n5.  **Decision**: Once the algorithm terminates, we check if the start symbol $S$ is in the set `ProductiveSymbols`.\n    *   If $S \\in \\text{ProductiveSymbols}$, it means that $S$ can derive a string of terminals, so $L(G)$ is not empty.\n    *   If $S \\notin \\text{ProductiveSymbols}$, it means there is no way for $S$ to ever derive a string consisting only of terminals, so $L(G)$ is empty.\n\nSince we have described an algorithm that is guaranteed to terminate for any CFG and provide a correct \"yes\" or \"no\" answer to the question of whether $L(G)$ is empty, the problem is decidable.\n\nLet's analyze the given options:\n*   **A**: This correctly states that the problem is decidable and accurately summarizes the logic of the algorithm described above.\n*   **B**: This is incorrect. While checking derivations naively can lead to infinite loops, this problem is not equivalent to the Halting Problem. The algorithm above analyzes the grammar's structure itself, which is a finite object, rather than simulating infinite derivations.\n*   **C**: This is incorrect. The algorithm does not involve testing an infinite number of strings. It works directly on the finite set of rules of the grammar. The question is not \"is this string in the language?\" but \"is there *any* string in the language?\".\n*   **D**: This is incorrect. The presence of recursion does not make the problem undecidable. The described algorithm handles recursive rules correctly. For a rule like $A \\to aA$, $A$ would be marked as productive if it has another rule, say $A \\to b$, that allows it to terminate. The algorithm correctly propagates this \"productivity\".\n\nTherefore, the correct statement is A.", "answer": "$$\\boxed{A}$$", "id": "1361679"}, {"introduction": "Having established a baseline for a decidable problem, we now venture into a more ambiguous territory where decidable and undecidable languages interact. This thought experiment probes how the property of decidability behaves under standard set operations, specifically intersection. You will investigate whether combining a solvable problem with an unsolvable one always results in an unsolvable problem, teaching a crucial lesson in computability theory about the power of proof by constructing specific examples [@problem_id:1361666].", "problem": "In the theory of computation, a formal language is defined as a set of strings over a specific alphabet $\\Sigma$. We are interested in the classes of languages that can be recognized by computational models.\n\nA language $L$ is called **(Turing) decidable** if there exists a Turing machine that, for any given input string, will always halt and definitively answer whether the string belongs to $L$. A language that is not decidable is called **undecidable**.\n\nLet $L_D$ be an arbitrary decidable language and $L_U$ be an arbitrary undecidable language, both defined over the same alphabet $\\Sigma$. Consider their intersection, defined as the language $L_{int} = L_D \\cap L_U$.\n\nWhich of the following statements about the decidability of $L_{int}$ is correct?\n\nA. $L_{int}$ is always decidable.\nB. $L_{int}$ is always undecidable.\nC. The decidability of $L_{int}$ depends on the specific choice of $L_D$ and $L_U$; it can be either decidable or undecidable.\nD. The intersection of a decidable and an undecidable language is not a well-defined language, so its decidability cannot be discussed.\nE. $L_{int}$ is decidable if and only if $L_D$ is a finite language.", "solution": "The problem asks us to determine the nature of the decidability of the intersection of a decidable language, $L_D$, and an undecidable language, $L_U$. Let's analyze the possibilities by attempting to construct examples. The goal is to determine if the result is always decidable, always undecidable, or if it can be either.\n\nFirst, let's consider if the intersection $L_{int} = L_D \\cap L_U$ can be decidable.\nTo show this is possible, we need to find at least one pair of a decidable language $L_D$ and an undecidable language $L_U$ such that their intersection is decidable.\n\nLet's choose a very simple decidable language for $L_D$. The empty language, $L_D = \\emptyset$, is decidable. A Turing machine deciding it would simply reject every input string immediately, and it would always halt. So, $L_D = \\emptyset$ is decidable.\n\nNow, let $L_U$ be any undecidable language. A canonical example is the Halting Problem language, often denoted as $A_{TM}$. $A_{TM}$ is the set of all pairs $\\langle M, w \\rangle$ where $M$ is the encoding of a Turing machine and $w$ is an input string, such that $M$ halts on input $w$. It is a foundational result in computability theory that $A_{TM}$ is undecidable.\n\nLet's compute the intersection for this specific choice:\n$$L_{int} = L_D \\cap L_U = \\emptyset \\cap A_{TM} = \\emptyset$$\nThe resulting language is the empty language, $\\emptyset$. As established, the empty language is decidable. Therefore, we have found an instance where the intersection of a decidable language and an undecidable language is decidable. This proves that statement B, \"$L_{int}$ is always undecidable,\" is false.\n\nNext, let's consider if the intersection $L_{int} = L_D \\cap L_U$ can be undecidable.\nTo show this is possible, we need to find at least one pair of a decidable language $L_D$ and an undecidable language $L_U$ such that their intersection is undecidable.\n\nLet's choose a different simple decidable language for $L_D$. The language of all possible strings over the alphabet $\\Sigma$, denoted $\\Sigma^*$, is decidable. A Turing machine deciding it would simply accept every input string immediately, and it would always halt. So, $L_D = \\Sigma^*$ is decidable.\n\nAgain, let $L_U$ be the undecidable language $A_{TM}$.\n\nLet's compute the intersection for this new choice:\n$$L_{int} = L_D \\cap L_U = \\Sigma^* \\cap A_{TM}$$\nSince $A_{TM}$ is a set of strings over some alphabet $\\Sigma$, all its elements are by definition contained within $\\Sigma^*$. Therefore, the intersection of $A_{TM}$ with $\\Sigma^*$ is just $A_{TM}$ itself.\n$$L_{int} = A_{TM}$$\nThe resulting language is $A_{TM}$, which we know is undecidable. Therefore, we have found an instance where the intersection of a decidable language and an undecidable language is undecidable. This proves that statement A, \"$L_{int}$ is always decidable,\" is false.\n\nSince we have demonstrated a case where the intersection is decidable and another case where it is undecidable, the decidability of the intersection is not fixed. It depends on the specific languages $L_D$ and $L_U$ that are chosen. This directly supports statement C.\n\nLet's quickly review the other options.\n- Statement D is incorrect. The intersection of two sets (languages) is always a well-defined set (language).\n- Statement E is incorrect. In our first example, $L_D = \\emptyset$, which is finite, and the intersection was decidable. In our second example, $L_D = \\Sigma^*$, which is infinite, and the intersection was undecidable. This might suggest a pattern. However, consider $L_D = \\{ \\langle M, w \\rangle \\mid \\text{the encoding has an even number of symbols} \\}$. This is an infinite, decidable language. Its intersection with $A_{TM}$ is $A_{TM}^{\\text{even}} = \\{ \\langle M, w \\rangle \\in A_{TM} \\mid \\text{the encoding has an even number of symbols} \\}$. This language can be shown to be undecidable (via reduction from $A_{TM}$). So an infinite $L_D$ can lead to an undecidable intersection. But if we take the same infinite $L_D$ and intersect it with $L_U = \\text{COMPLEMENT}(A_{TM})$, the intersection can be undecidable too. However, if we take $L_D$ as the set of all strings that do not start with the encoding of a Turing machine, which is an infinite and decidable set, then $L_D \\cap A_{TM} = \\emptyset$, which is decidable. Thus, having an infinite $L_D$ does not guarantee an undecidable intersection. Therefore, statement E is false.\n\nThe only correct conclusion is that the outcome depends on the specific languages.", "answer": "$$\\boxed{C}$$", "id": "1361666"}, {"introduction": "Our final practice uses the deceptively simple goal of printing \"Hello, world!\" to introduce a critical distinction between *decidability* and *Turing-recognizability*. We often face problems that are undecidable, meaning no algorithm can solve them for all inputs. However, this exercise reveals that for some of these problems, we can still build a procedure that confirms \"yes\" instances, even if it runs forever on \"no\" instances, thereby illustrating the important class of semi-decidable problems [@problem_id:1361702].", "problem": "In the theory of computation, we use the Turing Machine (TM) as a formal model for an arbitrary computer program. A language is a set of strings. We are interested in classifying the difficulty of problems by analyzing the computability properties of their corresponding languages. The encoding of a Turing Machine $M$ is represented as a string $\\langle M \\rangle$.\n\nConsider the following language, which we'll call the \"Hello World\" language, $L_{HW}$:\n$$ L_{HW} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM that, when started on a blank input tape, eventually prints \"Hello, world!\"} \\} $$\nThis means that for a TM to be in the language $L_{HW}$, there must be some finite number of steps after which its output tape contains the exact string \"Hello, world!\". The machine is not required to halt after printing the string.\n\nFor context, recall the following standard definitions:\n*   A language is **decidable** if there exists a Turing Machine that halts on every input, accepting strings that are in the language and rejecting strings that are not.\n*   A language is **Turing-recognizable** if there exists a Turing Machine that accepts all strings in the language. For strings not in the language, this machine may either reject or loop forever.\n*   A language is **co-Turing-recognizable** if its complement is Turing-recognizable.\n\nWhich of the following statements correctly classifies the language $L_{HW}$?\n\nA. $L_{HW}$ is decidable.\nB. $L_{HW}$ is Turing-recognizable, but not decidable.\nC. $L_{HW}$ is co-Turing-recognizable, but not Turing-recognizable.\nD. $L_{HW}$ is neither Turing-recognizable nor co-Turing-recognizable.", "solution": "We must determine whether the language $L_{HW}=\\{\\langle M\\rangle\\mid M\\text{ is a TM that, on blank input, eventually prints \"Hello, world!\"}\\}$ is decidable, Turing-recognizable, co-Turing-recognizable, or neither.\n\nFirst, we show that $L_{HW}$ is Turing-recognizable. By definition, a language is Turing-recognizable if there exists a Turing Machine that accepts exactly the strings in the language, possibly looping forever on strings not in the language. Construct a recognizer $R$ that, on input $x$, proceeds as follows: if $x$ is not a valid TM encoding, $R$ may reject immediately (this does not affect recognizability). If $x=\\langle M\\rangle$ for some TM $M$, $R$ simulates $M$ step-by-step on a blank input tape. After each simulated step, $R$ scans the portion of the output tape that has been written so far and checks whether the exact finite string \"Hello, world!\" appears as a contiguous block (equivalently, whether the output tape at that time contains that string). If such an event occurs at some finite simulation time, $R$ accepts. If $M$ never produces that string, then $R$ continues simulating forever and never accepts. This procedure is effective because at any finite time the written portion of the tape is finite and checking for a fixed finite pattern is decidable. Therefore, $L_{HW}$ is Turing-recognizable.\n\nSecond, we show that $L_{HW}$ is not decidable by a mapping reduction from the standard undecidable language $A_{TM} = \\{\\langle M, w \\rangle \\mid M \\text{ accepts } w\\}$. Define a computable function $f$ that, given $\\langle M,w\\rangle$, outputs the encoding $\\langle N\\rangle$ of a TM $N$ with the following behavior on blank input: $N$ simulates $M$ on input $w$; if and when the simulation shows $M$ enters an accept state on $w$, $N$ proceeds to write exactly the string \"Hello, world!\" on its output tape (and then may loop or halt arbitrarily). If $M$ rejects $w$ or does not halt on $w$, then $N$ never produces the string \"Hello, world!\". Such an $N$ can be effectively constructed by hard-coding $M$ and $w$ into $N$’s transition function, so $f$ is computable. By construction,\n$$ \\langle M, w \\rangle \\in A_{TM} \\iff \\langle N \\rangle = f(\\langle M, w \\rangle) \\in L_{HW} $$\nThus $A_{TM} \\le_m L_{HW}$. Since $A_{TM}$ is undecidable, it follows that $L_{HW}$ is undecidable.\n\nThird, we show that $L_{HW}$ is not co-Turing-recognizable. Suppose, for contradiction, that both $L_{HW}$ and its complement $\\overline{L_{HW}}$ were Turing-recognizable. Then there would exist recognizers for both, and by dovetailing the two recognizers on any input, one of them would eventually accept, yielding a decider for $L_{HW}$. This contradicts the undecidability of $L_{HW}$. Therefore, $\\overline{L_{HW}}$ is not Turing-recognizable.\n\nCombining these results, $L_{HW}$ is Turing-recognizable but not decidable, and its complement is not Turing-recognizable. Hence the correct classification is option B.", "answer": "$$\\boxed{B}$$", "id": "1361702"}]}