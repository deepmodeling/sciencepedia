{"hands_on_practices": [{"introduction": "The foundational equations of projectile motion do more than just predict a trajectory; they reveal inherent geometric relationships. This first exercise [@problem_id:2209981] challenges you to explore such a relationship by linking the horizontal range ($R$) and maximum height ($H$) of a projectile. By deriving the launch angle $\\theta$ required for a trajectory where $R=nH$, you will discover a principle that is independent of the initial launch speed, highlighting the pure geometry of ideal motion.", "problem": "A sports analytics firm is designing a realistic physics engine for a new virtual reality game. A key mechanic in the game involves throwing a ball from ground level with an initial speed $v_0$ at a launch angle $\\theta$ with respect to the horizontal. For a specific in-game challenge, the trajectory of the ball must satisfy a precise aesthetic condition: the total horizontal distance it travels before landing back on the ground (its range, $R$) must be exactly $n$ times its maximum vertical height ($H$). The ball is launched and lands at the same vertical level.\n\nAssuming the acceleration due to gravity is a constant $g$ and that air resistance is negligible, derive an analytical expression for the launch angle $\\theta$ in terms of the dimensionless factor $n$.", "solution": "Let the initial speed be $v_{0}$ and the launch angle be $\\theta$ above the horizontal. Under constant gravitational acceleration $g$ downward and with no air resistance, the projectile’s motion is governed by\n$$\nx(t)=v_{0}\\cos\\theta\\, t,\\qquad y(t)=v_{0}\\sin\\theta\\, t-\\frac{1}{2}gt^{2}.\n$$\nThe time of flight $T$ (returning to the launch height, so $y(T)=0$ with $T>0$) satisfies\n$$\n0=v_{0}\\sin\\theta\\, T-\\frac{1}{2}gT^{2}\\quad\\Rightarrow\\quad T=\\frac{2v_{0}\\sin\\theta}{g}.\n$$\nThe range $R$ is the horizontal displacement at $t=T$:\n$$\nR=x(T)=v_{0}\\cos\\theta\\left(\\frac{2v_{0}\\sin\\theta}{g}\\right)=\\frac{v_{0}^{2}}{g}\\sin(2\\theta).\n$$\nThe maximum height $H$ occurs when the vertical velocity vanishes. The vertical velocity is $v_{y}(t)=v_{0}\\sin\\theta-gt$, so setting $v_{y}(t_{h})=0$ gives\n$$\nt_{h}=\\frac{v_{0}\\sin\\theta}{g}.\n$$\nThus,\n$$\nH=y(t_{h})=v_{0}\\sin\\theta\\left(\\frac{v_{0}\\sin\\theta}{g}\\right)-\\frac{1}{2}g\\left(\\frac{v_{0}\\sin\\theta}{g}\\right)^{2}=\\frac{v_{0}^{2}\\sin^{2}\\theta}{2g}.\n$$\nThe condition $R=nH$ yields\n$$\n\\frac{v_{0}^{2}}{g}\\sin(2\\theta)=n\\left(\\frac{v_{0}^{2}\\sin^{2}\\theta}{2g}\\right).\n$$\nCanceling the common factor $\\frac{v_{0}^{2}}{g}$ and using $\\sin(2\\theta)=2\\sin\\theta\\cos\\theta$,\n$$\n\\sin(2\\theta)=\\frac{n}{2}\\sin^{2}\\theta\n\\quad\\Rightarrow\\quad\n2\\sin\\theta\\cos\\theta=\\frac{n}{2}\\sin^{2}\\theta\n\\quad\\Rightarrow\\quad\n4\\cos\\theta=n\\sin\\theta.\n$$\nTherefore,\n$$\n\\cot\\theta=\\frac{n}{4}\\quad\\Rightarrow\\quad \\tan\\theta=\\frac{4}{n}\\quad\\Rightarrow\\quad \\theta=\\arctan\\!\\left(\\frac{4}{n}\\right).\n$$\nFor $n>0$, this yields the unique physically relevant launch angle in the interval $(0,\\frac{\\pi}{2})$.", "answer": "$$\\boxed{\\arctan\\!\\left(\\frac{4}{n}\\right)}$$", "id": "2209981"}, {"introduction": "Real-world scenarios rarely conform to the simple ground-to-ground template. This practice [@problem_id:2210027] presents a more dynamic situation: a projectile interception where the state of motion is known only at the moment of capture. To find the initial launch conditions, you must apply the core principles of kinematics with greater flexibility and consider the concept of relative velocity, moving from rote formula application to true physical reasoning.", "problem": "An engineer is testing a new projectile launching system. A small ball is launched from a point on level ground. Simultaneously, a research drone equipped with a catching mechanism begins to descend vertically from a significant height. The drone descends with a constant speed $v_L$. The drone successfully intercepts and catches the ball when it is at a height $h$ above the ground. At the precise moment of interception, the ball's velocity as measured by the drone is observed to be purely horizontal. Assuming the acceleration due to gravity is $g$ and air resistance is negligible, determine the initial vertical component of the ball's launch velocity. Express your answer as a symbolic expression in terms of $h$, $v_L$, and $g$.", "solution": "Choose the vertical axis with positive upward and take the ground as $y=0$. Let the ball’s initial vertical velocity be $v_{0y}$. The drone descends at constant speed $v_{L}$, so its vertical velocity is $-v_{L}$.\n\nNeglecting air resistance, the ball’s vertical motion obeys the kinematic equations:\n$$\ny(t) = v_{0y} t - \\frac{1}{2} g t^{2}, \\quad v_{y}(t) = v_{0y} - g t.\n$$\nAt the interception, two conditions hold:\n1) The height of the ball is $h$, so $y(t)=h$.\n2) The ball’s velocity relative to the drone is purely horizontal, which requires the vertical components to match: $v_{y}(t) = -v_{L}$.\n\nFrom the second condition,\n$$\nv_{0y} - g t = -v_{L} \\quad \\Rightarrow \\quad t = \\frac{v_{0y} + v_{L}}{g}.\n$$\nSubstitute this $t$ into $y(t)=h$:\n$$\nh = v_{0y} \\left(\\frac{v_{0y} + v_{L}}{g}\\right) - \\frac{1}{2} g \\left(\\frac{v_{0y} + v_{L}}{g}\\right)^{2}.\n$$\nSimplify the right-hand side:\n$$\nh = \\frac{v_{0y}(v_{0y} + v_{L})}{g} - \\frac{(v_{0y} + v_{L})^{2}}{2g}\n= \\frac{1}{2g}\\left[v_{0y}^{2} - v_{L}^{2}\\right].\n$$\nTherefore,\n$$\nv_{0y}^{2} = v_{L}^{2} + 2 g h.\n$$\nSince the ball must be launched upward, take the positive root:\n$$\nv_{0y} = \\sqrt{v_{L}^{2} + 2 g h}.\n$$\nThis is the initial vertical component of the launch velocity in terms of $h$, $v_{L}$, and $g$.", "answer": "$$\\boxed{\\sqrt{v_{L}^{2} + 2 g h}}$$", "id": "2210027"}, {"introduction": "While ideal models are essential for learning, they have their limits. The inclusion of air resistance, a crucial factor in most real-world applications, often renders the equations of motion analytically unsolvable. This final, advanced practice [@problem_id:2430429] guides you through this challenge by using numerical methods to solve a projectile problem with quadratic drag. You will implement a 'shooting method' to find the correct launch angle, gaining invaluable hands-on experience with the computational tools that engineers and physicists use to model complex, realistic systems.", "problem": "A two-dimensional projectile of mass $m$ is launched from the origin with initial speed $v_0$ at launch angle $\\theta$ measured from the horizontal. The projectile moves under uniform gravitational acceleration $\\mathbf{g} = (0,-g)$ and experiences a quadratic aerodynamic drag force proportional to the square of the speed and opposite to the instantaneous velocity. Model the drag using Newton's second law as follows. Let the state be $\\mathbf{r}(t) = (x(t),y(t))$ and $\\mathbf{v}(t) = (v_x(t),v_y(t))$ with $v(t) = \\sqrt{v_x(t)^2 + v_y(t)^2}$. The equations of motion are\n$$\n\\frac{d x}{d t} = v_x, \\quad \\frac{d y}{d t} = v_y,\n$$\n$$\n\\frac{d v_x}{d t} = -k\\, v\\, v_x, \\quad \\frac{d v_y}{d t} = -g - k\\, v\\, v_y,\n$$\nwith initial conditions\n$$x(0) = 0,\\quad y(0) = 0,\\quad v_x(0) = v_0 \\cos\\theta,\\quad v_y(0) = v_0 \\sin\\theta.$$\nThe drag parameter $k$ is defined by\n$$\nk = \\frac{\\tfrac{1}{2}\\,\\rho\\, C_d\\, A}{m},\n$$\nwhere $\\rho$ is the air density, $C_d$ is the drag coefficient, and $A$ is the cross-sectional area.\n\nYour task is to write a complete, runnable program that, for each target point $(x_T,y_T)$, uses a root-finding algorithm to determine all launch angle(s) $\\theta \\in (0,\\tfrac{\\pi}{2})$ (strictly between horizontal and vertical) that cause the projectile to pass the vertical line $x = x_T$ at height $y = y_T$. The root-finding must be applied to a scalar function of the launch angle constructed from first principles as follows.\n\n1. For a given $\\theta$, define the scalar function\n$$F(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T,$$\nwhere $t^\\star(\\theta)$ is the first time (if any) at which $x\\big(t^\\star(\\theta)\\big) = x_T$ during the flight launched at angle $\\theta$ with speed $v_0$. If the projectile never reaches $x_T$ (for example, if it lands with $y=0$ before $x$ reaches $x_T$), then $F(\\theta)$ is undefined and that $\\theta$ should not be used in a bracketing pair for root finding.\n\n2. A valid solution angle $\\theta^\\star$ satisfies $F(\\theta^\\star) = 0$. Your program must systematically search the interval $\\theta \\in [\\theta_{\\min}, \\theta_{\\max}]$ with $\\theta_{\\min} = 0.1^\\circ$ and $\\theta_{\\max} = 89.9^\\circ$ to detect subintervals where $F(\\theta)$ changes sign, and then apply a one-dimensional root-finding algorithm (for example, a bracketing method) to each detected subinterval to converge to a root.\n\n3. If multiple distinct roots exist, all such angles in $(0^\\circ,90^\\circ)$ must be found and reported. If no root exists, report an empty list for that case.\n\nNumerical requirements and conventions:\n\n- Use the above differential equations and initial conditions as the only physical model; do not substitute any closed-form trajectory formulas.\n- Implement a numerical ordinary differential equation integrator that halts when $x(t)$ first equals $x_T$ (if it occurs) or when the projectile hits the ground $y(t)=0$ while descending. Use tolerances sufficiently tight to reliably detect crossings.\n- Distances must be in meters, time in seconds, mass in kilograms, air density in kilograms per cubic meter, area in square meters, and acceleration in meters per second squared. Angles must be reported in degrees.\n- Report each solution angle in degrees, rounded to three decimal places.\n- A solution angle is acceptable if, at the crossing time $t^\\star$, the value $|y(t^\\star) - y_T|$ is within $10^{-3}$ meters. Your root-finding tolerance should ensure this target accuracy.\n- For reproducibility, use the following fixed physical parameters for all test cases: $m = 0.145$ kilograms, $\\rho = 1.225$ kilograms per cubic meter, $C_d = 0.47$, $A = 0.0042$ square meters, and $g = 9.81$ meters per second squared.\n\nTest suite to cover different regimes:\n\n- Case $1$ (happy path, ground target with two solutions expected): $v_0 = 40.0$ meters per second, $(x_T,y_T) = (80.0, 0.0)$ meters.\n- Case $2$ (elevated target, typically one or two solutions): $v_0 = 40.0$ meters per second, $(x_T,y_T) = (60.0, 10.0)$ meters.\n- Case $3$ (short range, two solutions expected): $v_0 = 30.0$ meters per second, $(x_T,y_T) = (30.0, 0.0)$ meters.\n- Case $4$ (beyond maximum range, no solution expected): $v_0 = 40.0$ meters per second, $(x_T,y_T) = (200.0, 0.0)$ meters.\n\nProgram input and output specification:\n\n- There is no external input. Use the exact constants and test suite above.\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets. Each case's result must be a list of the solution angle(s) in degrees, sorted in ascending order and rounded to three decimal places. If no solution exists for a case, output an empty list for that case.\n- For example, the required overall output format is like $[ [\\ldots], [\\ldots], [\\ldots], [\\ldots] ]$ with numeric entries shown in decimal form and no extra text.\n\nYour program must be complete and runnable as provided, and it must use a root-finding algorithm applied to $F(\\theta)$ as defined above to locate the solution angle(s) for each case. Angles must be reported in degrees.", "solution": "The problem proposed is a well-defined and standard exercise in computational physics. It is scientifically grounded, mathematically consistent, and all necessary parameters for its solution are provided. The physical model, based on Newton's second law with quadratic air resistance, is a canonical representation of projectile motion in a viscous medium. The numerical task, which is to find the launch angles that result in the projectile passing through a specific target point, constitutes a boundary value problem. The prescribed method of solution—the shooting method coupled with a root-finding algorithm for a scalar function—is a robust and appropriate technique for this class of problems. Therefore, the problem is valid and we shall proceed with a complete solution.\n\nThe core of the problem is to solve a system of coupled first-order ordinary differential equations (ODEs). Let the state of the system at time $t$ be described by the vector $\\mathbf{S}(t) = [x(t), y(t), v_x(t), v_y(t)]^T$. The equations of motion can be written in the form $\\frac{d\\mathbf{S}}{dt} = \\mathbf{f}(t, \\mathbf{S})$, where the function $\\mathbf{f}$ is defined as:\n$$\n\\mathbf{f}(t, \\mathbf{S}) = \n\\begin{pmatrix}\nv_x \\\\\nv_y \\\\\n-k \\sqrt{v_x^2 + v_y^2} \\, v_x \\\\\n-g - k \\sqrt{v_x^2 + v_y^2} \\, v_y\n\\end{pmatrix}\n$$\nThe initial state at $t=0$ is given by $\\mathbf{S}(0) = [0, 0, v_0 \\cos\\theta, v_0 \\sin\\theta]^T$. The parameter $\\theta$ is the launch angle, which we must determine.\n\nA direct analytical solution for the trajectory $\\mathbf{r}(t)$ does not exist for this system. We must employ a numerical approach. The problem asks us to find the value(s) of $\\theta$ for which the trajectory passes through the target point $(x_T, y_T)$. This is a boundary value problem. We will solve it using a \"shooting method,\" which transforms the boundary value problem into a root-finding problem.\n\nThe shooting method proceeds as follows:\n1.  We select a trial launch angle $\\theta$. This fully specifies the initial conditions $\\mathbf{S}(0)$.\n2.  We numerically integrate the system of ODEs from $t=0$ forward in time. This process \"shoots\" the projectile.\n3.  We monitor the trajectory to find the time $t^\\star$ at which the projectile's horizontal position $x(t)$ first equals the target's horizontal position $x_T$.\n4.  At this time $t^\\star$, we evaluate the projectile's height, $y(t^\\star)$.\n5.  We define a scalar objective function, $F(\\theta)$, as the difference between the projectile's height at $x=x_T$ and the target height $y_T$:\n    $$\n    F(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T\n    $$\n    A solution angle $\\theta^\\star$ is one for which $F(\\theta^\\star) = 0$. The problem is therefore reduced to finding the roots of the function $F(\\theta)$.\n\nTo implement this method, we require a robust ODE integrator. The `solve_ivp` function from the SciPy library is an excellent tool for this. A critical feature of `solve_ivp` is its ability to detect \"events\"—conditions where a function of the state and time becomes zero. We will use this feature to precisely determine the crossing time $t^\\star$ without having to integrate to a fixed maximum time and then interpolate.\n\nWe define two terminal event functions:\n1.  `event_reach_x_target(t, S)`: This function returns $x(t) - x_T$. The integrator will stop when this value is zero, indicating the projectile has reached the target's longitude.\n2.  `event_hit_ground(t, S)`: This function returns $y(t)$. We configure it to trigger only when $y(t)$ is decreasing (i.e., the projectile is falling), which signals that the projectile has hit the ground before reaching $x=x_T$.\n\nThe function $F(\\theta)$ is constructed by calling the ODE solver for a given $\\theta$. If the integration is terminated by the `event_reach_x_target` event, we calculate and return $y(t^\\star) - y_T$. If it is terminated by `event_hit_ground`, or if it reaches a maximum simulation time without triggering any event, it means the trajectory falls short. In this case, the function $F(\\theta)$ is considered undefined for the purpose of bracketing, and we can return a non-numerical value like `NaN` (Not a Number) to signify this.\n\nTo find all roots of $F(\\theta)=0$ in the specified interval $\\theta \\in [0.1^\\circ, 89.9^\\circ]$, we employ a two-stage process:\n1.  **Bracketing**: We first discretize the search interval into a fine grid of angles. We evaluate $F(\\theta)$ at each point on this grid. By searching for adjacent grid points $(\\theta_i, \\theta_{i+1})$ where the sign of the function changes (i.e., $F(\\theta_i) \\cdot F(\\theta_{i+1}) < 0$), we identify sub-intervals that are guaranteed to contain at least one root, according to the Intermediate Value Theorem. It is important to handle the `NaN` cases correctly, as a valid bracket requires defined numerical values at both ends.\n2.  **Solving**: For each bracket $[\\theta_a, \\theta_b]$ found, we apply a numerical root-finding algorithm. Brent's method, implemented in `scipy.optimize.brentq`, is a highly effective choice. It combines the guaranteed convergence of the bisection method with the faster convergence of the secant method, and it is the standard for one-dimensional root-finding when a bracketing interval is known. The tolerance of the root-finder will be set to ensure the required precision on both the angle and the final target height.\n\nThis systematic procedure of numerical integration, event detection, bracketing, and root-solving will be applied to each test case to find all valid launch angles.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the projectile motion problem for all test cases.\n    \"\"\"\n    # Fixed physical parameters\n    M = 0.145  # mass in kg\n    RHO = 1.225  # air density in kg/m^3\n    C_D = 0.47  # drag coefficient (dimensionless)\n    A = 0.0042  # cross-sectional area in m^2\n    G = 9.81  # gravitational acceleration in m/s^2\n\n    # Derived drag parameter k = (rho * C_d * A) / (2 * m)\n    K = (0.5 * RHO * C_D * A) / M\n\n    # Test suite\n    test_cases = [\n        (40.0, (80.0, 0.0)),   # Case 1\n        (40.0, (60.0, 10.0)),  # Case 2\n        (30.0, (30.0, 0.0)),   # Case 3\n        (40.0, (200.0, 0.0)),  # Case 4\n    ]\n\n    def derivatives(t, state, k, g):\n        \"\"\"\n        Computes the derivatives for the system of ODEs.\n        state = [x, y, v_x, v_y]\n        \"\"\"\n        x, y, vx, vy = state\n        v = np.sqrt(vx**2 + vy**2)\n        \n        # Avoid division by zero if velocity is zero, though unlikely in this problem.\n        if v == 0:\n            ax = 0\n            ay = -g\n        else:\n            ax = -k * v * vx\n            ay = -g - k * v * vy\n            \n        return [vx, vy, ax, ay]\n\n    def calculate_y_error_at_xT(theta_deg, v0, xT, yT, k_param, g_param):\n        \"\"\"\n        Calculates the error F(theta) = y(t*) - yT for a given launch angle.\n        Returns np.nan if the projectile does not reach xT.\n        \"\"\"\n        theta_rad = np.deg2rad(theta_deg)\n        vx0 = v0 * np.cos(theta_rad)\n        vy0 = v0 * np.sin(theta_rad)\n        \n        initial_state = [0.0, 0.0, vx0, vy0]\n        \n        # Event: projectile reaches the target's x-coordinate\n        def reach_x_target(t, state, k, g):\n            return state[0] - xT\n        reach_x_target.terminal = True\n        reach_x_target.direction = 1 # Trigger only when x is increasing\n\n        # Event: projectile hits the ground (y=0)\n        def hit_ground(t, state, k, g):\n            return state[1]\n        hit_ground.terminal = True\n        hit_ground.direction = -1 # Trigger only when y is decreasing\n\n        t_span = (0, 100) # Max integration time of 100s is sufficient\n        sol = solve_ivp(\n            fun=derivatives,\n            t_span=t_span,\n            y0=initial_state,\n            args=(k_param, g_param),\n            events=[reach_x_target, hit_ground],\n            dense_output=True,\n            rtol=1e-8,\n            atol=1e-8\n        )\n\n        # Check which event terminated the integration\n        if sol.status == 1 and sol.t_events[0].size > 0:\n            # The 'reach_x_target' event was triggered\n            y_at_t_star = sol.y_events[0][0][1]\n            return y_at_t_star - yT\n        else:\n            # Projectile hit the ground first or integration timed out\n            return np.nan\n\n    all_results = []\n    for v0, (xT, yT) in test_cases:\n        \n        # Define the function for root finding, which depends on the case parameters\n        objective_func = lambda th: calculate_y_error_at_xT(th, v0, xT, yT, K, G)\n\n        # 1. Bracketing stage: Scan the angle range to find sign changes\n        theta_min_deg = 0.1\n        theta_max_deg = 89.9\n        scan_step_deg = 0.5  # Step size for scanning\n        \n        angles_to_scan = np.arange(theta_min_deg, theta_max_deg + scan_step_deg, scan_step_deg)\n        f_values = np.array([objective_func(th) for th in angles_to_scan])\n        \n        case_roots = []\n        for i in range(len(angles_to_scan) - 1):\n            th1, f1 = angles_to_scan[i], f_values[i]\n            th2, f2 = angles_to_scan[i+1], f_values[i+1]\n\n            if not np.isnan(f1) and not np.isnan(f2):\n                if f1 * f2  0:\n                    # Found a bracket [th1, th2]\n                    try:\n                        # 2. Solving stage: Find the root within the bracket\n                        root_deg = brentq(objective_func, th1, th2, xtol=1e-5)\n                        # Check if this root is a duplicate before adding\n                        is_duplicate = False\n                        for existing_root in case_roots:\n                            if abs(root_deg - existing_root)  1e-4:\n                                is_duplicate = True\n                                break\n                        if not is_duplicate:\n                            case_roots.append(root_deg)\n                    except ValueError:\n                        # brentq can fail if signs are not opposite, though our check prevents this.\n                        pass\n        \n        case_roots.sort()\n        all_results.append([round(r, 3) for r in case_roots])\n\n    # Format the final output string as specified\n    case_strs = []\n    for res_list in all_results:\n        num_strs = [f\"{num:.3f}\" for num in res_list]\n        case_strs.append(f\"[{','.join(num_strs)}]\")\n    \n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```", "id": "2430429"}]}