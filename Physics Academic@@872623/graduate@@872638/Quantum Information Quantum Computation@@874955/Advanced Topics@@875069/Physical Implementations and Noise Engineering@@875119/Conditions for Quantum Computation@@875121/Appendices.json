{"hands_on_practices": [{"introduction": "A crucial step in realizing quantum computation is translating abstract quantum circuits into sequences of operations executable on specific hardware. This practice explores the practical challenge of circuit compilation, where physical constraints such as limited qubit connectivity dictate the final circuit depth and runtime [@problem_id:63601]. By mapping the well-known Quantum Fourier Transform onto a linear array with nearest-neighbor interactions, you will gain hands-on experience in gate decomposition and resource estimation, fundamental skills for any quantum engineer.", "problem": "A crucial aspect of designing quantum algorithms for physical hardware is compiling the abstract circuit into a sequence of native gates executable on a specific quantum processor architecture. A common architecture is a linear array of qubits with nearest-neighbor connectivity.\n\nConsider a 3-qubit system with qubits labeled $q_0, q_1, q_2$ arranged in a line, such that two-qubit gates can only be performed between adjacent pairs $(q_0, q_1)$ and $(q_1, q_2)$. The native gate set consists of arbitrary single-qubit unitary gates and Controlled-NOT (CNOT) gates between adjacent qubits.\n\nThe Quantum Fourier Transform (QFT) on 3 qubits is defined by the standard circuit composed of Hadamard (H) gates, controlled-phase gates ($C-P(\\phi)$), and a final SWAP gate to correctly order the output qubits. The logical circuit is given by:\n$$ U_{\\text{QFT3}} = \\text{SWAP}(q_0, q_2) \\cdot (I \\otimes I \\otimes H_2) \\cdot C-P_{21}(\\pi/2) \\cdot C-P_{20}(\\pi/4) \\cdot (I \\otimes H_1 \\otimes I) \\cdot C-P_{10}(\\pi/2) \\cdot (H_0 \\otimes I \\otimes I) $$\nwhere $C-P_{ij}(\\phi)$ is a controlled-phase gate with control qubit $q_i$ and target qubit $q_j$, and $H_k$ is a Hadamard gate on qubit $q_k$.\n\nTo implement this on the linear array, the logical gates must be decomposed into native gates. Use the following standard decompositions:\n1.  A controlled-phase gate $C-P(\\phi)$ can be constructed from two CNOT gates and single-qubit rotations. For this problem, we will count this as costing 2 CNOTs.\n2.  A CNOT gate between non-adjacent qubits, e.g., CNOT($q_i, q_{i+2}$), must be implemented by SWAPping the intermediate qubit. The sequence SWAP($q_{i+1}, q_{i+2}$), CNOT($q_i, q_{i+1}$), SWAP($q_{i+1}, q_{i+2}$) accomplishes this. Since a nearest-neighbor SWAP costs 3 CNOTs, this full sequence costs $3+1+3=7$ CNOTs.\n3.  A SWAP gate between non-adjacent qubits $q_i$ and $q_{i+2}$ is implemented by a sequence of three nearest-neighbor SWAPs: SWAP($q_i, q_{i+1}$), SWAP($q_{i+1}, q_{i+2}$), SWAP($q_i, q_{i+1}$). A nearest-neighbor SWAP($j, j+1$) is implemented with three CNOTs: CNOT($j, j+1$), CNOT($j+1, j$), CNOT($j, j+1$).\n\nThe circuit depth is defined as the number of layers of simultaneously executable gates. A layer can consist of:\n- Any number of single-qubit gates acting on different qubits.\n- A set of non-overlapping CNOT gates. Note that on a 3-qubit linear array, CNOT($q_0,q_1$) and CNOT($q_1,q_2$) conflict, so at most one CNOT can be active in any layer.\n\nAssume CNOTs in both directions (e.g., CNOT($q_0,q_1$) and CNOT($q_1,q_0$)) are available as primitive gates of depth 1.\n\nDetermine the minimum circuit depth required to implement the full 3-qubit QFT on this linear array.", "solution": "To find the total circuit depth, we first calculate the total number of nearest-neighbor CNOT gates required, as only one CNOT can be executed per time step on the 3-qubit linear array. The depth will be dominated by this CNOT count.\n\n1.  **Analyze the Logical Circuit:** The QFT circuit is executed from right to left:\n    $H_0 \\rightarrow C-P_{10}(\\pi/2) \\rightarrow H_1 \\rightarrow C-P_{20}(\\pi/4) \\rightarrow C-P_{21}(\\pi/2) \\rightarrow H_2 \\rightarrow \\text{SWAP}(q_0, q_2)$.\n    Single-qubit Hadamard ($H$) gates have a depth of 1 but can often be merged with other single-qubit gates or executed in parallel, so we focus on the two-qubit gates which determine the minimal number of sequential layers.\n\n2.  **Calculate CNOT Cost for Each Logical Gate:**\n    *   **$C-P_{10}(\\pi/2)$:** This is a controlled-phase gate between adjacent qubits ($q_1$ and $q_0$). According to rule 1, this costs **2 CNOTs**.\n    *   **$C-P_{20}(\\pi/4)$:** This is a controlled-phase gate between non-adjacent qubits ($q_2$ and $q_0$). To implement this, we need to decompose it into non-adjacent CNOTs. A non-adjacent CNOT costs 7 CNOTs (rule 2). Since the C-P gate requires two CNOTs, the total cost is $2 \\times 7 = \\textbf{14 CNOTs}$.\n    *   **$C-P_{21}(\\pi/2)$:** This is a controlled-phase gate between adjacent qubits ($q_2$ and $q_1$). This costs **2 CNOTs**.\n    *   **$\\text{SWAP}(q_0, q_2)$:** This is a SWAP between non-adjacent qubits. According to rule 3, this is decomposed into three nearest-neighbor SWAPs. Each nearest-neighbor SWAP costs 3 CNOTs. Therefore, the total cost is $3 \\times 3 = \\textbf{9 CNOTs}$.\n\n3.  **Sum the CNOTs:** The total number of sequential CNOT gates is the sum of the costs for each part:\n    Total CNOTs = (Cost of $C-P_{10}$) + (Cost of $C-P_{20}$) + (Cost of $C-P_{21}$) + (Cost of $\\text{SWAP}_{02}$)\n    Total CNOTs = $2 + 14 + 2 + 9 = 27$.\n\n4.  **Determine Circuit Depth:**\n    On the linear array, only one CNOT gate can be active at a time. Therefore, each of the 27 CNOT gates requires its own layer in the circuit. Single-qubit gates can be scheduled into layers between CNOTs without increasing the total depth, as there are idle qubits. Thus, the minimum circuit depth is determined by the total number of sequential CNOT operations.\n\n    Minimum Depth = Total CNOTs = 27.", "answer": "$$\\boxed{27}$$", "id": "63601"}, {"introduction": "The successful execution of quantum algorithms fundamentally depends on the ability to perform high-fidelity gate operations in the presence of environmental noise. This exercise provides a concrete model of how quasi-static noise, such as fluctuations in a qubit's frequency, degrades the performance of a fundamental single-qubit gate [@problem_id:63624]. By calculating the average gate infidelity, you will learn how to connect a physical noise model to a key performance benchmark, a critical skill for characterizing and improving quantum hardware.", "problem": "A single qubit is subjected to a resonant driving field. In a rotating frame, the Hamiltonian describing this system in the presence of a frequency detuning $\\delta$ is given by:\n$$ H = \\frac{\\hbar}{2} \\left( \\Omega \\sigma_x + \\delta \\sigma_z \\right) $$\nwhere $\\sigma_x$ and $\\sigma_z$ are Pauli matrices, $\\Omega$ is the Rabi frequency of the driving field, and $\\delta$ represents a quasi-static detuning of the qubit's transition frequency from the drive frequency. The detuning $\\delta$ is a random variable that is constant during a single gate operation but varies from one operation to the next. It is drawn from a Gaussian probability distribution $P(\\delta)$ with zero mean and variance $\\sigma^2$:\n$$ P(\\delta) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{\\delta^2}{2\\sigma^2}\\right) $$\nAn ideal single-qubit NOT gate (an X-gate) is implemented by a resonant ($\\delta = 0$) $\\pi$-pulse, which corresponds to applying the drive for a time $T = \\pi/\\Omega$. The presence of the detuning $\\delta$ causes errors in the gate operation.\n\nThe quality of the gate is quantified by the average gate fidelity, $\\bar{F}$. The corresponding average gate infidelity is $\\mathcal{I} = 1 - \\bar{F}$. In the limit of small noise, where the standard deviation of the detuning is much smaller than the Rabi frequency ($\\sigma \\ll \\Omega$), the average gate infidelity can be approximated by its leading-order term:\n$$ \\mathcal{I} \\approx C \\left( \\frac{\\sigma}{\\Omega} \\right)^2 $$\nYour task is to calculate the dimensionless coefficient $C$. For this problem, you may set $\\hbar=1$.", "solution": "We set $\\hbar=1$ and define the small parameter $\\epsilon = \\delta/\\Omega$. The ideal X-gate is $V = \\exp(-i(\\pi/2)\\sigma_x) = -i\\sigma_x$ (up to a global phase). The actual evolution under $H = \\frac{1}{2}\\Omega(\\sigma_x + \\epsilon\\sigma_z)$ for time $T=\\pi/\\Omega$ is\n$$ U(\\delta) = \\exp\\left[-i\\frac{\\pi}{2}(\\sigma_x + \\epsilon\\sigma_z)\\right] = \\cos\\frac{\\theta}{2}I - i\\sin\\frac{\\theta}{2}(\\mathbf{N}\\cdot\\boldsymbol{\\sigma}) $$\nwith $\\theta = \\pi\\sqrt{1+\\epsilon^2}$ and $\\mathbf{N} = (1, 0, \\epsilon)/\\sqrt{1+\\epsilon^2}$. The average gate fidelity for a qubit ($d=2$) is given by\n$$ F(\\delta) = \\frac{|\\text{Tr}(V^\\dagger U)|^2+2}{6} $$\nSince $V^\\dagger = i\\sigma_x$, we find\n$$ \\text{Tr}(V^\\dagger U) = i\\text{Tr}(\\sigma_x U) = 2 N_x \\sin\\frac{\\theta}{2}, \\quad \\text{where } N_x = \\frac{1}{\\sqrt{1+\\epsilon^2}} $$\nThus\n$$ |\\text{Tr}(V^\\dagger U)|^2 = \\frac{4}{1+\\epsilon^2}\\sin^2\\left(\\frac{\\pi}{2}\\sqrt{1+\\epsilon^2}\\right) $$\nand\n$$ F(\\delta) = \\frac{4(1+\\epsilon^2)^{-1}\\sin^2\\left(\\frac{\\pi}{2}\\sqrt{1+\\epsilon^2}\\right)+2}{6} $$\nFor $\\epsilon \\ll 1$, we expand $\\sqrt{1+\\epsilon^2} \\approx 1+\\epsilon^2/2 + O(\\epsilon^4)$ and\n$$ \\sin^2\\left(\\frac{\\pi}{2}\\sqrt{1+\\epsilon^2}\\right) = \\sin^2\\left(\\frac{\\pi}{2}+\\frac{\\pi}{4}\\epsilon^2+O(\\epsilon^4)\\right) = \\cos^2\\left(\\frac{\\pi}{4}\\epsilon^2\\right) = 1 - O(\\epsilon^4) $$\nHence, the fidelity is\n$$ F(\\delta) = \\frac{4(1-\\epsilon^2+O(\\epsilon^4))(1 - O(\\epsilon^4))+2}{6} = \\frac{4-4\\epsilon^2+2}{6} + O(\\epsilon^4) = 1 - \\frac{2}{3}\\epsilon^2 + O(\\epsilon^4) $$\nThe infidelity for a given $\\delta$ is $\\mathcal{I}(\\delta) = 1 - F(\\delta) \\approx \\frac{2}{3}\\epsilon^2 = \\frac{2}{3}(\\delta/\\Omega)^2$. Averaging over the Gaussian distribution of $\\delta$ gives the average infidelity:\n$$ \\mathcal{I} = \\langle \\mathcal{I}(\\delta) \\rangle = \\frac{2}{3\\Omega^2}\\langle \\delta^2 \\rangle = \\frac{2}{3\\Omega^2}\\sigma^2 = \\frac{2}{3}\\left(\\frac{\\sigma}{\\Omega}\\right)^2 $$\nComparing with the given form $\\mathcal{I} \\approx C (\\sigma/\\Omega)^2$, we identify the coefficient $C = 2/3$.", "answer": "$$\\boxed{\\frac{2}{3}}$$", "id": "63624"}, {"introduction": "Achieving universal fault-tolerant quantum computation requires the use of non-Clifford gates, like the T-gate, which are typically resource-intensive to implement. This creates a strong incentive to minimize their usage, a process known as gate synthesis or compilation. This problem challenges you to find the most resource-efficient way to approximate a target rotation gate within a given precision, using a standard algorithm based on number theory [@problem_id:63628]. Mastering this trade-off between accuracy and resource cost is essential for designing algorithms that can run on future fault-tolerant quantum computers.", "problem": "In the field of fault-tolerant quantum computation, the Clifford+T gate set is a standard choice for universal computation. The set consists of the Clifford gates (Hadamard gate $H$, Phase gate $S=\\sqrt{Z}$, and CNOT) and the non-Clifford $T$ gate, where $T=S^{1/2}=\\begin{pmatrix} 1  0 \\\\ 0  e^{i\\pi/4} \\end{pmatrix}$. While Clifford gates can be implemented fault-tolerantly with relative ease (e.g., via state distillation and gate teleportation), the $T$ gate is a resource-intensive \"magic\" state. Consequently, it is crucial to minimize the number of $T$ gates (the T-count) in a quantum circuit.\n\nArbitrary single-qubit rotations, such as $R_z(\\theta) = \\exp(-i\\theta Z/2) = \\begin{pmatrix} e^{-i\\theta/2}  0 \\\\ 0  e^{i\\theta/2} \\end{pmatrix}$, must be approximated by sequences of Clifford and T gates. A common and efficient strategy for synthesizing Z-rotations is to use a number-theoretic algorithm that finds an optimal approximation of $R_z(\\theta)$ by a rotation of the form $R_z(k\\pi/2^m)$, where $k$ and $m$ are integers. Such a rotation can be synthesized using only Clifford and T gates.\n\nFor a target gate $U_{target}$ and its approximation $U_{approx}$, the synthesis error is measured by the operator norm distance $\\epsilon = \\|U_{target} - U_{approx}\\|$. The relationship between the operator norm distance and the angle difference for two Z-rotations is given by $\\|R_z(\\theta_1) - R_z(\\theta_2)\\| = 2|\\sin((\\theta_1-\\theta_2)/4)|$.\n\nState-of-the-art algorithms can synthesize the gate $R_z(k\\pi/2^m)$, for an odd integer $k$, with a T-count of exactly $T_c = 4m-2$. If $k$ is even, say $k=2j$, then $R_z(k\\pi/2^m) = R_z(j\\pi/2^{m-1})$, and a more efficient synthesis with a T-count based on $m-1$ is possible. Therefore, to find the optimal T-count, one should always reduce the fraction $k/2^m$ until $k$ is odd.\n\nYour task is to determine the optimal (minimum) T-count required to synthesize the single-qubit rotation $R_z(\\pi/15)$ to a precision of $\\epsilon = 10^{-10}$.", "solution": "We wish to approximate $R_z(\\pi/15)$ by $R_z(k\\pi/2^m)$ with an operator norm error $\\epsilon \\le 10^{-10}$.\n\n1.  **Error Condition:** The error is given by $\\|R_z(\\theta_1) - R_z(\\theta_2)\\| = 2|\\sin((\\theta_1 - \\theta_2)/4)| \\le \\epsilon$.\n    Let $\\theta_1 = \\pi/15$ and $\\theta_2 = k\\pi/2^m$. Let $\\delta\\theta = \\theta_1 - \\theta_2$. The condition becomes:\n    $2|\\sin(\\delta\\theta/4)| \\le 10^{-10}$.\n    For small angles, $\\sin(x) \\approx x$, so we have $|\\delta\\theta/2| \\le 10^{-10}$, which means $|\\delta\\theta| \\le 2 \\times 10^{-10}$. A more precise bound is $|\\delta\\theta| \\le 4\\arcsin(\\epsilon/2)$.\n    $|\\frac{\\pi}{15} - \\frac{k\\pi}{2^m}| \\le 4\\arcsin(0.5 \\times 10^{-10})$\n\n2.  **Angle Tolerance:** We can divide by $\\pi$ to get the tolerance for the angle coefficient:\n    $|\\frac{1}{15} - \\frac{k}{2^m}| \\le \\frac{4\\arcsin(0.5 \\times 10^{-10})}{\\pi} \\equiv \\Delta$.\n    Calculating the tolerance: $\\Delta \\approx \\frac{4 \\times (0.5 \\times 10^{-10})}{\\pi} \\approx 6.366 \\times 10^{-11}$.\n\n3.  **Find Minimum `m`:** We need to find the smallest integer $m$ for which there exists an integer $k$ satisfying the inequality. This is equivalent to finding a rational number with denominator $2^m$ that is very close to $1/15$.\n    The error of approximating a number $x$ by its closest fraction with denominator $D$ is at most $1/(2D)$. So we need $|\\frac{1}{15} - \\frac{k}{2^m}| \\le \\frac{1}{2 \\cdot 15} = \\frac{1}{30}$. This is not the bound we need. We need to find $k,m$ such that $|\\frac{2^m - 15k}{15 \\cdot 2^m}| \\le \\Delta$.\n    A simpler approach is to find the minimum $m$ such that the distance between adjacent representable angles is smaller than the required tolerance. The distance between grid points is $1/2^m$. A sufficient condition is $1/2^m  2\\Delta$, or more safely $1/(2 \\cdot 2^m)  \\Delta$.\n    $2^{m+1} > 1/\\Delta \\approx 1/(6.366 \\times 10^{-11}) \\approx 1.5708 \\times 10^{10}$.\n    $m+1 > \\log_2(1.5708 \\times 10^{10}) \\approx 33.86$.\n    This suggests we should try $m = 33$.\n\n4.  **Test `m` values:**\n    Let's check if $m=32$ is sufficient. We need to find $k = \\text{round}(2^{32}/15) = \\text{round}(286331153.0666...) = 286331153$.\n    The actual error is $|\\frac{1}{15} - \\frac{286331153}{2^{32}}| = |\\frac{1/15}{2^{32}}| = \\frac{0.0666...}{2^{32}} \\approx 1.55 \\times 10^{-11}$.\n    Since $1.55 \\times 10^{-11}  6.366 \\times 10^{-11}$, $m=32$ is sufficient.\n\n5.  **Check if `m-1` is sufficient:** Let's test $m=31$. We need $k = \\text{round}(2^{31}/15) = \\text{round}(143165576.533...) = 143165577$.\n    The error is $|\\frac{1}{15} - \\frac{143165577}{2^{31}}| = |\\frac{2^{31} - 15 \\times 143165577}{15 \\cdot 2^{31}}| = \\frac{|2147483648 - 2147483655|}{15 \\cdot 2^{31}} = \\frac{7}{15 \\cdot 2^{31}} \\approx 2.17 \\times 10^{-10}$.\n    Since $2.17 \\times 10^{-10} > 6.366 \\times 10^{-11}$, $m=31$ is not sufficient.\n\n6.  **Calculate T-Count:** The minimum required value is $m=32$. The corresponding integer $k=286331153$ is odd.\n    The T-count is given by $T_c = 4m - 2$.\n    $T_c = 4(32) - 2 = 128 - 2 = 126$.\n\nTherefore, the minimal T-count is 126.", "answer": "$$\\boxed{126}$$", "id": "63628"}]}