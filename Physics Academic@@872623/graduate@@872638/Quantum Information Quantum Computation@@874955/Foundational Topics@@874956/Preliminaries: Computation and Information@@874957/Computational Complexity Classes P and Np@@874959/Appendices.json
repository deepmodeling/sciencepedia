{"hands_on_practices": [{"introduction": "While the general Boolean Satisfiability (SAT) problem is famously NP-complete, certain restricted versions fall into the class P. This exercise [@problem_id:61693] explores 2-SAT, which can be solved in polynomial time using an elegant algorithm based on implication graphs. By constructing this graph and analyzing its strongly connected components, you can directly determine a formula's satisfiability, gaining crucial insight into the structural properties that distinguish tractable problems from intractable ones.", "problem": "In the study of computational complexity, the Boolean satisfiability problem (SAT) plays a central role. While the general SAT problem is NP-complete, a notable special case, 2-Satisfiability (2-SAT), is solvable in polynomial time. An elegant algorithm for 2-SAT involves constructing an *implication graph* from the given 2-CNF formula.\n\nA 2-CNF formula is a conjunction (AND) of clauses, where each clause is a disjunction (OR) of two literals. A literal is a Boolean variable or its negation. For a formula with variables $\\{x_1, \\dots, x_n\\}$, the set of literals is $\\{x_1, \\neg x_1, \\dots, x_n, \\neg x_n\\}$.\n\nThe implication graph $G=(V, E)$ for a 2-CNF formula is a directed graph where the vertices $V$ are the set of all literals. For each clause of the form $(a \\lor b)$ in the formula, we add two directed edges to $E$: $(\\neg a \\to b)$ and $(\\neg b \\to a)$. These represent the logical implications that if $a$ is false, $b$ must be true, and if $b$ is false, $a$ must be true.\n\nA 2-CNF formula is unsatisfiable if and only if there exists a variable $x_i$ such that $x_i$ and its negation $\\neg x_i$ are in the same *strongly connected component* (SCC) of the implication graph. An SCC is a maximal subgraph where for any two vertices $u, v$ in the component, there is a directed path from $u$ to $v$ and a directed path from $v$ to $u$.\n\nWe define a **contradictory strongly connected component** as an SCC that contains at least one pair of literals $\\{x_i, \\neg x_i\\}$ for some variable $x_i$.\n\nConsider the following 2-CNF formula $\\Phi$ over the set of variables $\\{x_1, x_2, x_3, x_4, x_5, x_6, x_7\\}$.\n$$\n\\Phi = (\\neg x_1 \\lor x_2) \\land (\\neg x_2 \\lor \\neg x_1) \\land (x_1 \\lor \\neg x_2) \\land (x_1 \\lor x_2)\n\\land (\\neg x_3 \\lor x_4) \\land (\\neg x_4 \\lor \\neg x_3) \\land (x_3 \\lor \\neg x_4) \\land (x_3 \\lor x_4)\n\\land (\\neg x_5 \\lor x_6) \\land (\\neg x_6 \\lor x_5) \\land (x_1 \\lor x_7)\n$$\n\nYour task is to determine the total number of contradictory strongly connected components in the implication graph of the formula $\\Phi$.", "solution": "1. **Implication-graph construction.** For each clause $(a \\lor b)$ we add edges $(\\neg a \\to b)$ and $(\\neg b \\to a)$.\n\n   **Clauses on $x_1, x_2$**:\n   $$\n   \\begin{aligned}\n   (\\neg x_1 \\lor x_2) &\\implies x_1 \\to x_2,\\; \\neg x_2 \\to \\neg x_1 \\\\\n   (\\neg x_2 \\lor \\neg x_1) &\\implies x_2 \\to \\neg x_1,\\; x_1 \\to \\neg x_2 \\\\\n   (x_1 \\lor \\neg x_2) &\\implies \\neg x_1 \\to \\neg x_2,\\; x_2 \\to x_1 \\\\\n   (x_1 \\lor x_2) &\\implies \\neg x_1 \\to x_2,\\; \\neg x_2 \\to x_1\n   \\end{aligned}\n   $$\n   From the edges $x_1 \\to x_2$ (from clause 1) and $x_2 \\to x_1$ (from clause 3), we see that $x_1$ and $x_2$ are in the same SCC. Similarly, $\\neg x_1 \\to \\neg x_2$ and $\\neg x_2 \\to \\neg x_1$ put $\\neg x_1$ and $\\neg x_2$ in the same SCC.\n   Crucially, there are paths connecting literals to their negations. For example, there is a path from $x_1$ to $\\neg x_1$ (via $x_1 \\to \\neg x_2 \\to \\neg x_1$) and a path from $\\neg x_1$ to $x_1$ (via $\\neg x_1 \\to x_2 \\to x_1$).\n   Because there are paths in both directions between any two literals in the set $\\{x_1, x_2, \\neg x_1, \\neg x_2\\}$, this entire set forms a single strongly connected component (SCC). Since it contains both $x_1$ and $\\neg x_1$ (and also $x_2$ and $\\neg x_2$), it is a contradictory SCC.\n\n2. **Clauses on $x_3, x_4$**: These are identical in form to the clauses for $x_1, x_2$. By the same logic, they form another SCC:\n   $$\\{x_3, x_4, \\neg x_3, \\neg x_4\\}$$\n   This SCC is also contradictory as it contains both $x_3, \\neg x_3$ and $x_4, \\neg x_4$.\n\n3. **Clauses on $x_5, x_6$**:\n   $$\n   \\begin{aligned}\n   (\\neg x_5 \\lor x_6) &\\implies x_5 \\to x_6,\\; \\neg x_6 \\to \\neg x_5 \\\\\n   (\\neg x_6 \\lor x_5) &\\implies x_6 \\to x_5,\\; \\neg x_5 \\to \\neg x_6\n   \\end{aligned}\n   $$\n   This yields two disjoint SCCs:\n   $$\\{x_5, x_6\\} \\quad \\text{and} \\quad \\{\\neg x_5, \\neg x_6\\}$$\n   Neither of these contains a variable and its negation.\n\n4. **Clause on $x_1, x_7$**: The clause $(x_1 \\lor x_7)$ adds edges:\n   $$\\neg x_1 \\to x_7 \\quad \\text{and} \\quad \\neg x_7 \\to x_1$$\n   These edges connect the single literals $x_7$ and $\\neg x_7$ to the large SCC containing $x_1$ and $\\neg x_1$. However, they do not create a path from $x_7$ back to $\\neg x_7$, so $x_7$ and $\\neg x_7$ do not join an existing contradictory SCC, nor do they form a new one. They remain in separate, non-contradictory SCCs (which may now include other literals but not their negations).\n\n5. **Count contradictory SCCs**: We have identified exactly two SCCs that contain a variable and its negation:\n   - $\\{x_1, x_2, \\neg x_1, \\neg x_2\\}$\n   - $\\{x_3, x_4, \\neg x_3, \\neg x_4\\}$\n   \n   Hence the total number is 2.", "answer": "$$\\boxed{2}$$", "id": "61693"}, {"introduction": "Many NP-complete problems are deeply interconnected, and understanding the reductions between them is central to computational complexity. This exercise [@problem_id:61625] focuses on two classic examples: the Minimum Vertex Cover and Maximum Independent Set problems. By proving the identity that links their optimal solution sizes, you will practice a fundamental proof technique and appreciate the powerful concept of duality in combinatorial optimization.", "problem": "In graph theory, two fundamental concepts are independent sets and vertex covers. Consider an undirected graph $G = (V, E)$, where $V$ is the set of vertices and $E$ is the set of edges. Let the total number of vertices be $N = |V|$.\n\nAn **independent set** is a subset of vertices $S \\subseteq V$ such that for every pair of distinct vertices $u, v \\in S$, the edge $(u, v)$ is not in $E$. In other words, no two vertices in an independent set are adjacent. The size of the maximum independent set of $G$ is denoted by $\\alpha(G)$.\n\nA **vertex cover** is a subset of vertices $C \\subseteq V$ such that every edge in $E$ has at least one of its endpoints in $C$. The size of the minimum vertex cover of $G$ is denoted by $\\tau(G)$.\n\nBoth finding the maximum independent set and the minimum vertex cover are classic NP-hard problems. However, there is a direct relationship between their sizes for any given graph.\n\nGiven a graph $G$ with $N$ vertices, suppose the size of its maximum independent set is $\\alpha(G) = \\alpha$. Determine the size of its minimum vertex cover, $\\tau(G)$, expressed in terms of $N$ and $\\alpha$.", "solution": "In graph theory, for any undirected graph $G = (V, E)$ with $|V| = N$ vertices, the following relationship holds between the maximum independent set and the minimum vertex cover:\n\n- Let $S$ be an independent set. Then, the complement set $V \\setminus S$ is a vertex cover. This is because for any edge $(u, v) \\in E$, both $u$ and $v$ cannot be in $S$ (since no two vertices in an independent set are adjacent), so at least one endpoint must be in $V \\setminus S$.\n\n- Conversely, if $C$ is a vertex cover, then $V \\setminus C$ is an independent set. This is because if there were an edge between two vertices in $V \\setminus C$, that edge would not be covered by $C$, contradicting the definition of a vertex cover.\n\nGiven that $\\alpha(G) = \\alpha$ is the size of the maximum independent set:\n\n1. Let $S^*$ be a maximum independent set, so $|S^*| = \\alpha$.\n   - The complement $V \\setminus S^*$ is a vertex cover, with size $|V \\setminus S^*| = N - \\alpha$.\n   - Since $\\tau(G)$ is the size of the minimum vertex cover, it satisfies:\n     \n$$\n     \\tau(G) \\leq N - \\alpha\n     $$\n\n   because the minimum vertex cover cannot be larger than any vertex cover.\n\n2. Let $C^*$ be a minimum vertex cover, so $|C^*| = \\tau(G)$.\n   - The complement $V \\setminus C^*$ is an independent set, with size $|V \\setminus C^*| = N - \\tau(G)$.\n   - Since $\\alpha$ is the size of the maximum independent set, it satisfies:\n     \n$$\n     N - \\tau(G) \\leq \\alpha\n     $$\n\n   because no independent set can be larger than the maximum independent set.\n\n3. Rearranging the inequality from step 2:\n   \n$$\n   N - \\tau(G) \\leq \\alpha \\implies \\tau(G) \\geq N - \\alpha\n   $$\n\n\n4. Combining the inequalities from steps 1 and 3:\n   \n$$\n   \\tau(G) \\leq N - \\alpha \\quad \\text{and} \\quad \\tau(G) \\geq N - \\alpha\n   $$\n\n   Therefore,\n   \n$$\n   \\tau(G) = N - \\alpha\n   $$\n\n\nThus, the size of the minimum vertex cover is $N - \\alpha$.", "answer": "$$\n\\boxed{N - \\alpha}\n$$", "id": "61625"}, {"introduction": "The label 'NP-hard' does not mean a problem is always unsolvable in practice; it often motivates a search for more nuanced approaches to complexity. Fixed-Parameter Tractability (FPT) offers one such approach by isolating hardness into a specific parameter, $k$. This exercise [@problem_id:61767] allows you to simulate a classic FPT algorithm for Vertex Cover, revealing how a bounded-depth search tree can efficiently solve instances where the desired cover size $k$ is small, even if the total graph size is large.", "problem": "The Vertex Cover problem is a classic NP-hard problem in computer science. Given a graph $G=(V, E)$, a vertex cover is a subset of vertices $S \\subseteq V$ such that for every edge $(u,v) \\in E$, at least one of $u$ or $v$ is in $S$. The problem asks for a cover of minimum possible size.\n\nWhile the problem is hard in general, it becomes tractable for instances where the desired cover size, $k$, is small. This is an example of a fixed-parameter tractable (FPT) problem. A standard FPT approach for Vertex Cover uses a recursive, bounded-depth search tree algorithm. Understanding the behavior of such algorithms is crucial in computational complexity theory, providing context for the study of both classical and quantum complexity classes.\n\nConsider the following deterministic recursive algorithm, `CountLeaves(G, k)`, which computes the number of leaf nodes in the search tree for finding a vertex cover of size at most $k$. The leaf nodes represent the termination points of the recursion.\n\n**The `CountLeaves(G, k)` Algorithm:**\n\nThe algorithm takes a graph $G=(V,E)$ and an integer $k$ as input. It applies the following rules in order:\n1.  **Base Case (Success):** If the graph has no edges ($E = \\emptyset$), the current set of chosen vertices is a valid cover. This is a success leaf. Return 1.\n2.  **Base Case (Failure):** If the budget $k \\le 0$ and the graph still has edges ($E \\ne \\emptyset$), it's impossible to find a cover within the budget. This is a failure leaf. Return 1.\n3.  **Reduction Rule A (High-Degree Vertex):** If there is any vertex $v$ with degree greater than $k$ (i.e., $\\deg(v) > k$), such a vertex must be in any vertex cover of size $k$. Let $v_0$ be the vertex with the smallest index that satisfies this condition. The algorithm proceeds without branching by adding $v_0$ to the cover. Return the result of the recursive call `CountLeaves(G - {v_0}, k-1)`.\n4.  **Reduction Rule B (Degree-1 Vertex):** If there is any vertex $v$ with degree equal to 1, let its single neighbor be $u$. For an optimal cover, it is always better to choose $u$ than $v$. Let $v_0$ be the vertex with the smallest index that has degree 1, and let its neighbor be $u_0$. The algorithm proceeds without branching by adding $u_0$ to the cover. Return the result of the recursive call `CountLeaves(G - {u_0}, k-1)`.\n5.  **Branching Rule:** If none of the above conditions are met, the algorithm must branch.\n    a. Select a vertex $u$ with the smallest index that has at least one edge.\n    b. Select a neighbor $v$ of $u$ with the smallest index.\n    c. Since the edge $(u,v)$ must be covered, either $u$ or $v$ must be in the vertex cover. The algorithm branches on these two possibilities. Return the sum of the results from two recursive calls: `CountLeaves(G - {u}, k-1) + CountLeaves(G - {v}, k-1)`.\n\n**Your Task:**\n\nGiven the graph $G=(V, E)$ with vertices $V = \\{1, 2, 3, 4, 5, 6\\}$ and edges $E = \\{(1,2), (1,3), (2,3), (2,4), (3,5), (4,5), (4,6), (5,6)\\}$, and the parameter $k=3$, calculate the total number of leaf nodes generated by the `CountLeaves(G, k)` algorithm.", "solution": "We are given the graph $G = (V, E)$ with $V = \\{1, 2, 3, 4, 5, 6\\}$ and $E = \\{(1,2), (1,3), (2,3), (2,4), (3,5), (4,5), (4,6), (5,6)\\}$, and parameter $k = 3$. We need to compute the number of leaf nodes using the `CountLeaves(G, k)` algorithm.\n\nThe algorithm applies rules in order:\n\n1. **Initial Call: `CountLeaves(G, 3)`**\n   - The graph has edges and $k=3 > 0$.\n   - Degrees are: $\\deg(1)=2, \\deg(2)=3, \\deg(3)=3, \\deg(4)=3, \\deg(5)=3, \\deg(6)=2$.\n   - **Rule A (High-Degree):** No vertex has degree $> 3$. Skip.\n   - **Rule B (Degree-1):** No vertex has degree 1. Skip.\n   - **Rule 5 (Branching):** Select smallest-index vertex $u=1$. Its smallest-index neighbor is $v=2$. The algorithm branches, returning the sum of `CountLeaves(G-{1}, 2)` and `CountLeaves(G-{2}, 2)`.\n\n2. **Branch 1: `CountLeaves(G_1, 2)`** where $G_1 = G-\\{1\\}$ and $k_1 = 2$.\n   - $G_1$ has vertices $\\{2, 3, 4, 5, 6\\}$ and edges $\\{(2,3), (2,4), (3,5), (4,5), (4,6), (5,6)\\}$.\n   - Degrees in $G_1$: $\\deg(2)=2, \\deg(3)=2, \\deg(4)=3, \\deg(5)=3, \\deg(6)=2$.\n   - **Rule A (High-Degree):** Yes. $k_1=2$. Vertex 4 has $\\deg(4)=3 > 2$. We must select vertex 4.\n   - Recurse on `CountLeaves(G_{1a}, 1)` where $G_{1a} = G_1-\\{4\\}$ and $k_{1a}=1$.\n   - $G_{1a}$ has vertices $\\{2, 3, 5, 6\\}$ and edges $\\{(2,3), (3,5), (5,6)\\}$.\n   - Degrees in $G_{1a}$: $\\deg(2)=1, \\deg(3)=2, \\deg(5)=2, \\deg(6)=1$.\n   - **Rule A (High-Degree):** Yes. $k_{1a}=1$. Vertex 3 has $\\deg(3)=2 > 1$. We must select vertex 3.\n   - Recurse on `CountLeaves(G_{1b}, 0)` where $G_{1b} = G_{1a}-\\{3\\}$ and $k_{1b}=0$.\n   - $G_{1b}$ has vertices $\\{2, 5, 6\\}$ and edge $\\{(5,6)\\}$.\n   - **Rule 2 (Failure):** $k_{1b} \\le 0$ and graph has an edge. This is a **failure leaf**. Return 1.\n   - The result for Branch 1 is 1.\n\n3. **Branch 2: `CountLeaves(G_2, 2)`** where $G_2 = G-\\{2\\}$ and $k_2 = 2$.\n   - $G_2$ has vertices $\\{1, 3, 4, 5, 6\\}$ and edges $\\{(1,3), (3,5), (4,5), (4,6), (5,6)\\}$.\n   - Degrees in $G_2$: $\\deg(1)=1, \\deg(3)=2, \\deg(4)=2, \\deg(5)=3, \\deg(6)=2$.\n   - **Rule A (High-Degree):** Yes. $k_2=2$. Vertex 5 has $\\deg(5)=3 > 2$. We must select vertex 5.\n   - Recurse on `CountLeaves(G_{2a}, 1)` where $G_{2a} = G_2-\\{5\\}$ and $k_{2a}=1$.\n   - $G_{2a}$ has vertices $\\{1, 3, 4, 6\\}$ and edges $\\{(1,3), (4,6)\\}$.\n   - Degrees in $G_{2a}$: all are 1.\n   - **Rule A (High-Degree):** No vertex has degree $>1$. Skip.\n   - **Rule B (Degree-1):** Yes. Smallest-index vertex with degree 1 is 1. Its neighbor is 3. We must select the neighbor, vertex 3.\n   - Recurse on `CountLeaves(G_{2b}, 0)` where $G_{2b} = G_{2a}-\\{3\\}$ and $k_{2b}=0$.\n   - $G_{2b}$ has vertices $\\{1, 4, 6\\}$ and edge $\\{(4,6)\\}$.\n   - **Rule 2 (Failure):** $k_{2b} \\le 0$ and graph has an edge. This is a **failure leaf**. Return 1.\n   - The result for Branch 2 is 1.\n\n**Total Leaves:**\nThe initial call results in `CountLeaves(G, 3) = (result of Branch 1) + (result of Branch 2) = 1 + 1 = 2`.\nThe total number of leaf nodes is 2.", "answer": "\\boxed{2}", "id": "61767"}]}