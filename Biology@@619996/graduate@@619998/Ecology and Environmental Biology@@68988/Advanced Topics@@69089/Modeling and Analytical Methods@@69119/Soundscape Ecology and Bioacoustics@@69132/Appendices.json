{"hands_on_practices": [{"introduction": "A fundamental task in soundscape ecology is to understand the spatial scale of acoustic interactions. Before deploying a single microphone, we must ask: how far away can we detect a sound of interest? This practice will guide you through the foundational physics of sound propagation, combining the effects of geometric spreading and atmospheric absorption to predict the sound pressure level at a distance. By deriving and applying the propagation model, you will gain a crucial skill for survey design and for estimating the effective monitoring area of your sensors.[@problem_id:2533884]", "problem": "An autonomous recorder deployed in a semi-arid savanna is used to monitor the propagation of a tonal bird call centered at frequency $f = 4000$ Hz. In calibration trials near the source, the Sound Pressure Level (SPL) at $1$ m from the bird was measured to be $L_{p,1\\text{ m}} = 110$ dB re $20$ $\\mu$Pa. Assume free-field, homogeneous, stationary atmospheric conditions with no ground interaction, wind, or temperature gradients. The atmosphere’s frequency-dependent absorption is characterized, under these conditions, by a simplified coefficient $\\alpha(f)$ given in decibels per meter by\n$\\alpha(f) = A f^{2}$,\nwhere $A = 2.5 \\times 10^{-10}$ dB m$^{-1}$ Hz$^{-2}$. A recorder is placed at a range of $r = 1500$ m from the source.\n\nStarting only from the following fundamental bases:\n- Acoustic intensity under spherical spreading decreases with distance as the inverse square of range in a free field.\n- Molecular absorption in a homogeneous medium follows Beer–Lambert attenuation.\n- SPL is defined by $L_{p} = 20 \\log_{10}\\!\\big(p_{\\mathrm{rms}}/p_{\\mathrm{ref}}\\big)$ with $p_{\\mathrm{ref}} = 20$ $\\mu$Pa, and for plane waves $I \\propto p_{\\mathrm{rms}}^{2}$,\n\nderive the analytic expression for the received SPL at range $r$ in terms of $L_{p,1\\text{ m}}$, $r$, and $\\alpha(f)$, and then evaluate it numerically for the given $f$, $A$, and $r$. Use meters for distance and express $\\alpha(f)$ in dB m$^{-1}$. Round your final SPL to four significant figures and express the result in dB.", "solution": "The problem statement is subjected to validation.\n\nFirst, the givens are extracted verbatim:\n- Source frequency: $f = 4000$ Hz\n- Reference Sound Pressure Level (SPL) at $1$ m: $L_{p,1\\text{ m}} = 110$ dB re $20$ $\\mu$Pa\n- Environmental assumptions: free-field, homogeneous, stationary atmospheric conditions, no ground interaction, wind, or temperature gradients.\n- Atmospheric absorption coefficient: $\\alpha(f) = A f^{2}$\n- Constant for absorption coefficient: $A = 2.5 \\times 10^{-10}$ dB m$^{-1}$ Hz$^{-2}$\n- Receiver range: $r = 1500$ m\n- Fundamental bases for derivation:\n    1. Acoustic intensity under spherical spreading decreases as the inverse square of range.\n    2. Molecular absorption follows Beer–Lambert attenuation.\n    3. SPL is defined by $L_{p} = 20 \\log_{10}(p_{\\mathrm{rms}}/p_{\\mathrm{ref}})$ with $p_{\\mathrm{ref}} = 20$ $\\mu$Pa.\n    4. For plane waves, intensity $I$ is proportional to the square of the root-mean-square pressure, $p_{\\mathrm{rms}}^{2}$.\n\nThe problem is evaluated for validity. It is scientifically grounded in the fundamental principles of acoustics. The physical model—combining geometric spreading and frequency-dependent atmospheric absorption—is standard for analyzing sound propagation over long distances. The problem is well-posed, providing all necessary parameters and a clear objective. The language is precise and objective. All provided values ($f$, $L_{p,1\\text{ m}}$, $r$, $A$) are physically plausible for a bioacoustics monitoring scenario. The problem is a standard exercise in applied physics and contains no scientific, logical, or structural flaws.\n\nVerdict: The problem is valid. A rigorous solution will be developed.\n\nThe task is to derive an expression for the received SPL at range $r$, and then to compute its value. The derivation must start from the specified fundamental principles.\n\nLet $L_{p,r}$ be the Sound Pressure Level at a distance $r$ from the source. By definition,\n$$L_{p} = 20 \\log_{10}\\left(\\frac{p_{\\mathrm{rms}}}{p_{\\mathrm{ref}}}\\right)$$\nThe problem states that acoustic intensity $I$ is proportional to $p_{\\mathrm{rms}}^{2}$, i.e., $I = \\kappa p_{\\mathrm{rms}}^{2}$ for some constant of proportionality $\\kappa$. This allows us to express SPL in terms of intensity:\n$$L_{p} = 10 \\log_{10}\\left(\\frac{p_{\\mathrm{rms}}^{2}}{p_{\\mathrm{ref}}^{2}}\\right) = 10 \\log_{10}\\left(\\frac{I/\\kappa}{I_{\\mathrm{ref}}/\\kappa}\\right) = 10 \\log_{10}\\left(\\frac{I}{I_{\\mathrm{ref}}}\\right)$$\nwhere $I_{\\mathrm{ref}}$ is the reference intensity corresponding to the reference pressure $p_{\\mathrm{ref}}$.\n\nLet $I_1$ be the intensity at the reference distance $r_1 = 1$ m. The total attenuation of sound intensity from $r_1$ to $r$ is due to two independent physical phenomena: geometric spreading and atmospheric absorption.\n\n1.  **Geometric Spreading**: For a point source in a free field, acoustic energy radiates spherically. The intensity decreases as the inverse square of the distance from the source. The intensity $I_{\\text{spread}}(r)$ at range $r$ due to spreading alone is related to the intensity $I_1$ at $r_1$ by:\n    $$I_{\\text{spread}}(r) = I_1 \\left(\\frac{r_1}{r}\\right)^2$$\n\n2.  **Atmospheric Absorption**: According to the Beer–Lambert law, absorption causes an exponential decay of intensity with distance. When expressed in decibels, this corresponds to a linear loss with distance. The absorption coefficient $\\alpha(f)$ is given in units of dB m$^{-1}$. The total absorption loss in dB over the path from $r_1$ to $r$ is $\\alpha(f)(r - r_1)$. The corresponding reduction in intensity is given by a multiplicative factor of $10^{-\\frac{\\text{Loss in dB}}{10}}$.\n\nCombining these two effects, the final intensity $I_r$ at distance $r$ is:\n$$I_r = I_1 \\left(\\frac{r_1}{r}\\right)^2 \\times 10^{-\\frac{\\alpha(f)(r-r_1)}{10}}$$\nNow, we can find the SPL at distance $r$, $L_{p,r}$:\n$$L_{p,r} = 10 \\log_{10}\\left(\\frac{I_r}{I_{\\mathrm{ref}}}\\right) = 10 \\log_{10}\\left(\\frac{I_1}{I_{\\mathrm{ref}}} \\left(\\frac{r_1}{r}\\right)^2 10^{-\\frac{\\alpha(f)(r-r_1)}{10}}\\right)$$\nUsing the properties of logarithms, we can separate the terms:\n$$L_{p,r} = 10 \\log_{10}\\left(\\frac{I_1}{I_{\\mathrm{ref}}}\\right) + 10 \\log_{10}\\left(\\left(\\frac{r_1}{r}\\right)^2\\right) + 10 \\log_{10}\\left(10^{-\\frac{\\alpha(f)(r-r_1)}{10}}\\right)$$\nThe first term is the definition of the SPL at the reference distance $r_1$, which is $L_{p,r_1}$. The second term simplifies to $20 \\log_{10}(r_1/r)$, which is equal to $-20 \\log_{10}(r/r_1)$. The third term simplifies to $-\\alpha(f)(r-r_1)$.\nThus, we arrive at the general sound propagation equation:\n$$L_{p,r} = L_{p,r_1} - 20 \\log_{10}\\left(\\frac{r}{r_1}\\right) - \\alpha(f)(r-r_1)$$\nSubstituting the problem's reference condition, $r_1 = 1$ m, and $L_{p,r_1} = L_{p,1\\text{ m}}$, the specific analytic expression is:\n$$L_{p,r} = L_{p,1\\text{ m}} - 20 \\log_{10}(r) - \\alpha(f)(r-1)$$\nThis completes the derivation.\n\nNext, we evaluate this expression numerically. The given parameters are:\n$L_{p,1\\text{ m}} = 110$ dB\n$r = 1500$ m\n$f = 4000$ Hz\n$A = 2.5 \\times 10^{-10}$ dB m$^{-1}$ Hz$^{-2}$\n\nFirst, we calculate the atmospheric absorption coefficient $\\alpha(f)$:\n$$\\alpha(f) = A f^2$$\n$$\\alpha(4000) = (2.5 \\times 10^{-10}) \\times (4000)^2 = (2.5 \\times 10^{-10}) \\times (1.6 \\times 10^{7}) = 4 \\times 10^{-2} = 0.04 \\text{ dB m}^{-1}$$\nWait, there is a calculation error. Let us recompute.\n$\\alpha(4000) = (2.5 \\times 10^{-10}) \\times (4000)^2 = (2.5 \\times 10^{-10}) \\times (16 \\times 10^6) = 40 \\times 10^{-4} = 0.004$ dB m$^{-1}$. This is correct.\n\nNow, we calculate the SPL at $r = 1500$ m. The expression is:\n$$L_{p,1500\\text{ m}} = 110 - 20 \\log_{10}(1500) - 0.004 \\times (1500-1)$$\nThe two loss terms are calculated separately.\n1.  **Spreading Loss**: $L_{\\text{spread}} = 20 \\log_{10}(1500)$.\n    $$L_{\\text{spread}} = 20 \\log_{10}(1.5 \\times 10^3) = 20 (\\log_{10}(1.5) + 3) \\approx 20 (0.17609 + 3) = 20(3.17609) \\approx 63.5218 \\text{ dB}$$\n2.  **Absorption Loss**: $L_{\\text{abs}} = \\alpha(4000) \\times (r-1)$.\n    $$L_{\\text{abs}} = 0.004 \\times (1500-1) = 0.004 \\times 1499 = 5.996 \\text{ dB}$$\n\nFinally, we compute the received SPL:\n$$L_{p,1500\\text{ m}} = L_{p,1\\text{ m}} - L_{\\text{spread}} - L_{\\text{abs}}$$\n$$L_{p,1500\\text{ m}} = 110 - 63.5218 - 5.996 = 40.4822 \\text{ dB}$$\nThe problem requires the final answer to be rounded to four significant figures.\n$$L_{p,1500\\text{ m}} \\approx 40.48 \\text{ dB}$$\nThis is the final numerical result.", "answer": "$$\\boxed{40.48}$$", "id": "2533884"}, {"introduction": "Once a sound is recorded, we often need to summarize its intensity with a single value. However, because the decibel scale is logarithmic, this is not as simple as taking an average. This exercise demystifies the correct way to average sound levels by having you implement the Equivalent Continuous Sound Level ($L_{eq,T}$), a metric based on energy, and contrast it with the common but misleading arithmetic mean of instantaneous decibel values. Through coding with different signal types, you will build a solid, practical understanding of this vital acoustic metric.[@problem_id:2533871]", "problem": "A time series of acoustic pressure as a function of time, denoted $p(t)$ in Pascals, is observed over a finite duration $T$ in seconds at a uniform sampling rate $f_s$ in Hertz. In air, the acoustic intensity for a plane progressive wave is proportional to the squared pressure, and the Sound Pressure Level (SPL) in decibels relative to a reference pressure $p_0$ is defined at each instant by $L(t)=10\\log_{10}\\!\\left(\\frac{p^2(t)}{p_0^2}\\right)$, where the reference pressure is $p_0=2\\times 10^{-5}$ Pascals. The Equivalent Continuous Sound Level over a duration $T$ is defined as the constant level that would deliver the same total acoustic energy as the measured signal over $[0,T]$.\n\nYour task is to design and implement a program that, for each of the specified test cases below, does the following from first principles:\n\n- Using only the above base definitions, derive and compute the equivalent continuous sound level over the entire duration, denoted $L_{\\mathrm{eq},T}$, as the decibel level corresponding to the time average of the squared pressure over $[0,T]$.\n- Compute the arithmetic mean of the instantaneous decibel values, denoted $\\overline{L}$, defined as the simple arithmetic average of $L(t)$ over all discrete samples. To avoid undefined logarithms when $p(t)=0$, use a strictly positive noise floor $p_{\\min}$ when taking logs, by computing $L(t)=10\\log_{10}\\!\\left(\\frac{\\max\\{p^2(t),p_{\\min}^2\\}}{p_0^2}\\right)$ before averaging. Do not apply any floor to $p(t)$ when computing $L_{\\mathrm{eq},T}$.\n- Report, for each test case, the triple of floats [$L_{\\mathrm{eq},T}$, $\\overline{L}$, $L_{\\mathrm{eq},T}-\\overline{L}$], where all three quantities are in decibels relative to $p_0$. Express the final numeric outputs as plain decimal floats without units. Round each float to $6$ decimal places.\n\nAll computations must be purely numerical on the provided synthetic signals and must use Pascals for pressure and seconds for time. The arithmetic of angles within trigonometric functions should be in radians. The required sampling rate $f_s$ and duration $T$ are specified for each test.\n\nUse the following constants and parameter choices across tests:\n- Reference pressure: $p_0=2\\times 10^{-5}$ Pascals.\n- Instantaneous-level noise floor: $p_{\\min}=1\\times 10^{-12}$ Pascals.\n\nFor each test case, generate the time series $p(t)$ as follows. For all cases, construct a discrete-time vector of $N$ samples with uniform sampling interval $\\Delta t=1/f_s$ over the half-open interval $[0,T)$ using $t_n=n\\,\\Delta t$ for $n\\in\\{0,1,\\dots,N-1\\}$, where $N=\\lfloor T\\,f_s\\rfloor$.\n\nTest suite:\n- Case A (stationary Gaussian noise):\n  - Sampling rate: $f_s=44100$ Hertz.\n  - Duration: $T=10$ seconds.\n  - Generate zero-mean Gaussian noise with target root-mean-square (RMS) pressure $\\sigma_p=0.02$ Pascals, i.e., $p(t)\\sim \\mathcal{N}(0,\\sigma_p^2)$ independently at each sample. Use a fixed random seed $s=12345$ for reproducibility.\n- Case B (pure tone):\n  - Sampling rate: $f_s=48000$ Hertz.\n  - Duration: $T=2.5$ seconds.\n  - Sinusoid amplitude: $A=0.1$ Pascals.\n  - Frequency: $f=1000$ Hertz.\n  - Define $p(t)=A\\sin(2\\pi f t)$.\n- Case C (amplitude-gated tone, $50$ percent duty):\n  - Sampling rate: $f_s=32000$ Hertz.\n  - Duration: $T=8$ seconds.\n  - Sinusoid amplitude: $A=0.02$ Pascals.\n  - Frequency: $f=500$ Hertz.\n  - Square-gate period: $P=1$ second with $50$ percent duty cycle. Define the envelope $g(t)=1$ if $(t\\bmod P)0.5$ and $g(t)=0$ otherwise, and $p(t)=g(t)\\,A\\sin(2\\pi f t)$.\n- Case D (sparse bursts, approximately $1$ percent duty):\n  - Sampling rate: $f_s=44100$ Hertz.\n  - Duration: $T=5$ seconds.\n  - Sinusoid amplitude: $A=2\\times 10^{-4}$ Pascals.\n  - Frequency: $f=1000$ Hertz.\n  - Square-gate period: $P=0.5$ seconds with on-duration $\\tau_{\\mathrm{on}}=0.005$ seconds. Define the envelope $g(t)=1$ if $(t\\bmod P)\\tau_{\\mathrm{on}}$ and $g(t)=0$ otherwise, and $p(t)=g(t)\\,A\\sin(2\\pi f t)$.\n\nAlgorithmic requirements:\n- For $L_{\\mathrm{eq},T}$, numerically approximate the time average of $p^2(t)$ over $[0,T)$ using the discrete-time mean of the squared samples, i.e., $\\frac{1}{N}\\sum_{n=0}^{N-1}p^2(t_n)$, and then convert to decibels relative to $p_0$.\n- For $\\overline{L}$, compute $L(t_n)=10\\log_{10}\\!\\left(\\frac{\\max\\{p^2(t_n),p_{\\min}^2\\}}{p_0^2}\\right)$ for each sample and then take the arithmetic mean over $n$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list of lists enclosed in square brackets, with each inner list being the three floats for the corresponding case in the order [$L_{\\mathrm{eq},T}$, $\\overline{L}$, $L_{\\mathrm{eq},T}-\\overline{L}$]. For example, the printed structure should look like $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4]]$ with each $x_i, y_i, z_i$ rounded to $6$ decimal places as specified.", "solution": "The solution proceeds from fundamental definitions and standard properties of logarithms. In linear acoustics for plane progressive waves in air, the instantaneous acoustic intensity $I(t)$ is proportional to the square of the acoustic pressure $p(t)$, with $I(t)=\\frac{p^2(t)}{\\rho c}$, where $\\rho$ is the density of air and $c$ is the speed of sound. The Sound Pressure Level (SPL) relative to a reference intensity $I_0$ is defined by $L(t)=10\\log_{10}\\!\\left(\\frac{I(t)}{I_0}\\right)$. Choosing the conventional reference pressure $p_0=2\\times 10^{-5}$ Pascals and $I_0=\\frac{p_0^2}{\\rho c}$ yields the standard SPL expression\n$$\nL(t)=10\\log_{10}\\!\\left(\\frac{p^2(t)}{p_0^2}\\right).\n$$\nThe Equivalent Continuous Sound Level over a time interval $[0,T]$ is defined to be the level $L_{\\mathrm{eq},T}$ of a hypothetical constant-pressure signal that would deliver the same time-averaged acoustic energy (equivalently, the same mean-square pressure) as the observed $p(t)$ over $[0,T]$. Denote the mean-square pressure by\n$$\n\\overline{p^2}=\\frac{1}{T}\\int_0^T p^2(t)\\,dt.\n$$\nBy definition, $L_{\\mathrm{eq},T}$ is the SPL corresponding to $\\overline{p^2}$, namely\n$$\nL_{\\mathrm{eq},T}=10\\log_{10}\\!\\left(\\frac{\\overline{p^2}}{p_0^2}\\right).\n$$\nFor uniformly sampled data with sampling interval $\\Delta t=\\frac{1}{f_s}$ and $N=\\lfloor T f_s\\rfloor$ samples at times $t_n=n\\Delta t$ for $n\\in\\{0,1,\\dots,N-1\\}$, the Riemann-sum approximation gives\n$$\n\\overline{p^2}\\approx \\frac{1}{N}\\sum_{n=0}^{N-1}p^2(t_n).\n$$\nThus, computationally one can use\n$$\nL_{\\mathrm{eq},T}\\approx 10\\log_{10}\\!\\left(\\frac{\\frac{1}{N}\\sum_{n=0}^{N-1}p^2(t_n)}{p_0^2}\\right).\n$$\nIn contrast, the arithmetic mean of instantaneous decibel values is defined here as\n$$\n\\overline{L}=\\frac{1}{N}\\sum_{n=0}^{N-1}10\\log_{10}\\!\\left(\\frac{\\max\\{p^2(t_n),p_{\\min}^2\\}}{p_0^2}\\right),\n$$\nwhere $p_{\\min}0$ is a specified noise-floor pressure to avoid undefined logarithms when $p(t_n)=0$. Importantly, the floor $p_{\\min}$ is not applied to $p(t)$ when computing $L_{\\mathrm{eq},T}$, which remains a physical time-average of $p^2(t)$.\n\nA key theoretical relationship follows from Jensen’s inequality. The base-$10$ logarithm $\\log_{10}(x)$ is a concave function on $(0,\\infty)$, so for any nonnegative sequence $\\{x_n\\}$,\n$$\n\\frac{1}{N}\\sum_{n=0}^{N-1}\\log_{10}(x_n)\\le \\log_{10}\\!\\left(\\frac{1}{N}\\sum_{n=0}^{N-1}x_n\\right),\n$$\nwith equality if and only if all $x_n$ are equal almost everywhere. Applying this to $x_n=\\frac{p^2(t_n)}{p_0^2}$ (ignoring the floor for the conceptual inequality) and multiplying both sides by $10$ shows\n$$\n\\overline{L}\\le L_{\\mathrm{eq},T},\n$$\nwith equality if and only if $\\frac{p^2(t)}{p_0^2}$ is constant in time almost everywhere, that is, when the squared pressure is constant across the interval. This formalizes why the arithmetic mean of instantaneous decibels generally underestimates the energy-equivalent level.\n\nAlgorithmic design:\n- For each test case, construct the discrete-time vector $t_n=n/f_s$ for $n=0,\\dots,N-1$ with $N=\\lfloor T f_s\\rfloor$.\n- Generate $p(t_n)$ according to the specified case:\n  - Case A: draw independent samples from a zero-mean Gaussian with standard deviation $\\sigma_p$, using a fixed pseudorandom seed to ensure reproducibility.\n  - Case B: compute $p(t_n)=A\\sin(2\\pi f t_n)$.\n  - Case C: compute the square envelope $g(t_n)$ with period $P$ and $50$ percent duty cycle, then $p(t_n)=g(t_n)A\\sin(2\\pi f t_n)$.\n  - Case D: compute the square envelope $g(t_n)$ with period $P$ and on-duration $\\tau_{\\mathrm{on}}$, then $p(t_n)=g(t_n)A\\sin(2\\pi f t_n)$.\n- Compute $L_{\\mathrm{eq},T}=10\\log_{10}\\!\\left(\\frac{\\frac{1}{N}\\sum p^2(t_n)}{p_0^2}\\right)$.\n- Compute instantaneous levels $L(t_n)=10\\log_{10}\\!\\left(\\frac{\\max\\{p^2(t_n),p_{\\min}^2\\}}{p_0^2}\\right)$ and then $\\overline{L}=\\frac{1}{N}\\sum L(t_n)$.\n- Report $[L_{\\mathrm{eq},T},\\ \\overline{L},\\ L_{\\mathrm{eq},T}-\\overline{L}]$, rounding each to $6$ decimal places.\n\nSanity checks and expectations:\n- Case B (pure tone) has RMS pressure $A/\\sqrt{2}$, so one expects $L_{\\mathrm{eq},T}\\approx 20\\log_{10}\\!\\left(\\frac{A/\\sqrt{2}}{p_0}\\right)$; for $A=0.1$ Pascals and $p_0=2\\times 10^{-5}$ Pascals, this gives approximately $70.96$ decibels. The arithmetic mean $\\overline{L}$ will be lower because $\\log_{10}$ is concave and because instantaneous decibel values emphasize low-pressure instants disproportionately.\n- Case C (half-time gated tone) halves the energy relative to continuous tone with the same amplitude, so the overall RMS is reduced by a factor $\\sqrt{0.5}$, implying a $3$ decibel reduction in $L_{\\mathrm{eq},T}$ relative to the continuous tone at the same amplitude and frequency.\n- Case D (sparse bursts) yields an $L_{\\mathrm{eq},T}$ that reflects the overall duty cycle $d=\\frac{\\tau_{\\mathrm{on}}}{P}$, with RMS scaling as $\\sqrt{d}$; the arithmetic mean $\\overline{L}$ is expected to be much lower due to the extended silences and the concavity of the logarithm, even with a small $p_{\\min}$.\n\nThe program implements these computations and prints the results for all cases as a single line in the exact format required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef leq_from_timeseries(p, p0):\n    \"\"\"\n    Compute equivalent continuous sound level L_eq,T in dB re p0\n    from a discrete-time pressure series p (Pascals).\n    \"\"\"\n    mean_square = np.mean(p**2)\n    # Avoid negative inf only if mean_square is zero (which shouldn't happen except all zeros)\n    if mean_square = 0.0:\n        return float(\"-inf\")\n    return 10.0 * np.log10(mean_square / (p0**2))\n\ndef mean_instantaneous_db(p, p0, pmin):\n    \"\"\"\n    Compute arithmetic mean of instantaneous dB values:\n    L_inst[n] = 10*log10(max(p[n]^2, pmin^2) / p0^2)\n    \"\"\"\n    squared = p**2\n    squared_clamped = np.maximum(squared, pmin**2)\n    L_inst = 10.0 * np.log10(squared_clamped / (p0**2))\n    return float(np.mean(L_inst))\n\ndef generate_time_vector(fs, T):\n    \"\"\"\n    Generate time vector t = [0, 1/fs, 2/fs, ..., T - 1/fs]\n    \"\"\"\n    N = int(np.floor(T * fs))\n    t = np.arange(N, dtype=np.float64) / fs\n    return t\n\ndef case_A_gaussian_noise(fs, T, sigma_p, seed):\n    t = generate_time_vector(fs, T)\n    rng = np.random.default_rng(seed)\n    p = rng.normal(loc=0.0, scale=sigma_p, size=t.shape)\n    return p\n\ndef case_B_pure_tone(fs, T, A, f):\n    t = generate_time_vector(fs, T)\n    p = A * np.sin(2.0 * np.pi * f * t)\n    return p\n\ndef square_gate(t, period, on_duration):\n    \"\"\"\n    Square gating envelope g(t): 1 if (t % period)  on_duration else 0\n    \"\"\"\n    phase = np.mod(t, period)\n    return (phase  on_duration).astype(np.float64)\n\ndef case_C_gated_tone(fs, T, A, f, P):\n    t = generate_time_vector(fs, T)\n    # 50% duty: on for P/2\n    gate = square_gate(t, period=P, on_duration=0.5 * P)\n    p = gate * A * np.sin(2.0 * np.pi * f * t)\n    return p\n\ndef case_D_sparse_bursts(fs, T, A, f, P, tau_on):\n    t = generate_time_vector(fs, T)\n    gate = square_gate(t, period=P, on_duration=tau_on)\n    p = gate * A * np.sin(2.0 * np.pi * f * t)\n    return p\n\ndef solve():\n    # Constants\n    p0 = 2e-5  # Pa\n    pmin = 1e-12  # Pa, floor for instantaneous dB only\n\n    # Define the test cases as tuples: (generator_func, params_dict)\n    test_cases = [\n        # Case A: Gaussian noise\n        (\"A\", case_A_gaussian_noise, dict(fs=44100.0, T=10.0, sigma_p=0.02, seed=12345)),\n        # Case B: Pure tone\n        (\"B\", case_B_pure_tone, dict(fs=48000.0, T=2.5, A=0.1, f=1000.0)),\n        # Case C: 50% duty gated tone\n        (\"C\", case_C_gated_tone, dict(fs=32000.0, T=8.0, A=0.02, f=500.0, P=1.0)),\n        # Case D: Sparse bursts ~1% duty\n        (\"D\", case_D_sparse_bursts, dict(fs=44100.0, T=5.0, A=2e-4, f=1000.0, P=0.5, tau_on=0.005)),\n    ]\n\n    results = []\n    for _, gen, params in test_cases:\n        p = gen(**params)\n        L_eq = leq_from_timeseries(p, p0)\n        L_avg = mean_instantaneous_db(p, p0, pmin)\n        diff = L_eq - L_avg\n        # Round to 6 decimal places as required\n        results.append([round(L_eq, 6), round(L_avg, 6), round(diff, 6)])\n\n    # Final print statement in the exact required format.\n    # Print a single line: list of lists\n    # Ensure standard Python list formatting with commas\n    print(str(results).replace(\" \", \"\"))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2533871"}, {"introduction": "Field recordings are rarely pristine; they are often contaminated by noise from wind, rain, or human activity. This final practice dives into the essential signal processing task of noise reduction. You will implement the classic spectral subtraction algorithm from first principles to enhance a biotic signal masked by simulated wind noise. More importantly, you will confront a common side effect of this process—the creation of 'musical noise'—and develop a method to quantify it, providing a deep insight into the practical tradeoffs inherent in audio enhancement.[@problem_id:2533913]", "problem": "You are tasked with constructing, from first principles, a complete spectral subtraction pipeline to reduce wind noise in a simulated terrestrial bioacoustic recording and to quantify musical noise artifacts as a function of an over-subtraction parameter. Your implementation must start from the definition of the Short-Time Fourier Transform (STFT) and the concept of additive noise, without relying on any pre-given closed-form spectral subtraction equations. You must also formalize and compute a concrete musical noise index that depends on the time–frequency structure of the enhanced signal.\n\nFundamental base to be used:\n- Additive mixture model: a discrete-time observed signal $y[n]$ that is the sum of an unknown clean biotic signal $x[n]$ and an additive wind noise process $v[n]$, i.e., $y[n] = x[n] + v[n]$.\n- The Short-Time Fourier Transform (STFT) of a sequence $x[n]$ with analysis window $w[m]$, window length $N$, and hop size $H$ is defined as\n$$\nX(k,n) = \\sum_{m=0}^{N-1} x[nH+m]\\, w[m] \\, e^{-j 2\\pi k m / N}, \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\n- A noise power spectrum estimate can be obtained by time-averaging periodograms over frames known to contain only noise, using\n$$\n\\widehat{P}_v(k) = \\frac{1}{N_\\text{noise}} \\sum_{n \\in \\mathcal{I}_\\text{noise}} \\left| V(k,n) \\right|^2,\n$$\nwhere $\\mathcal{I}_\\text{noise}$ indexes noise-only frames.\n\nYou must implement the following pipeline in a single program:\n\n1) Synthetic dataset construction, sampling, and units:\n- Use a sampling rate of $F_s = 16000$ Hz and generate a duration of $T = 6$ seconds, i.e., $N_\\text{samples} = F_s \\cdot T$ samples.\n- Generate a clean biotic signal $x[n]$ as the sum of two tonal components with slowly varying amplitude, representing a simplified bird song:\n  - Carrier frequencies $f_1 = 2000$ Hz and $f_2 = 3500$ Hz.\n  - An amplitude envelope that creates three burst-like syllables: each burst of duration $0.8$ seconds, separated by silence of duration $0.2$ seconds, starting at $t = 0.5$ seconds for the first burst. Use smooth onset and offset within each burst (for example, raised-cosine ramps) so that $x[n]$ is continuous and differentiable at burst boundaries.\n- Generate wind noise $v[n]$ as follows:\n  - Start with independent and identically distributed Gaussian noise with zero mean and unit variance.\n  - Apply a low-pass filter to emulate wind spectral coloration with dominant low-frequency energy. The low-pass cutoff should be $f_c = 500$ Hz, and the filter should be at least second-order and stable.\n  - Impose slow-varying amplitude modulation to emulate gusts by creating a nonnegative multiplicative envelope with characteristic modulation below $3$ Hz (for example, by low-pass filtering a zero-mean Gaussian sequence and taking its rectified and scaled version).\n- Combine the signals as $y[n] = x[n] + \\lambda \\, v[n]$, where $\\lambda$ is a scalar chosen to achieve a target signal-to-noise ratio of $-5$ decibels measured over the whole duration. The signal-to-noise ratio in decibels is defined as\n$$\n\\mathrm{SNR}_\\mathrm{dB} = 10 \\log_{10} \\left( \\frac{\\sum_{n=0}^{N_\\text{samples}-1} x[n]^2}{\\sum_{n=0}^{N_\\text{samples}-1} (\\lambda v[n])^2} \\right).\n$$\n- To ensure determinism, you must initialize the random number generator with a fixed seed $s = 12345$.\n\n2) Time–frequency analysis:\n- Compute the STFT of $y[n]$ using a Hann window of length $N = 1024$, hop size $H = 256$, and one-sided spectra for real signals. Use the same parameters to compute the STFT of $x[n]$ and $v[n]$ when needed for diagnostics or estimation, and to reconstruct time signals if required by your design.\n\n3) Noise estimation:\n- Estimate the noise power spectrum $\\widehat{P}_v(k)$ using only the first $\\tau_0 = 1.0$ seconds of the mixture $y[n]$, which you must assume to be noise-dominant. Use time-averaged periodograms over those frames to form a per-frequency-bin estimate. Do not use any oracle access to $v[n]$ in this step.\n\n4) Spectral subtraction enhancement with over-subtraction and flooring:\n- Construct an enhancement module that forms an estimate of the clean-magnitude spectrum per time–frequency bin by subtracting a scaled version of the noise power estimate from the observed power spectrum. The subtraction must be controlled by an over-subtraction parameter $\\alpha \\ge 0$ and must include a nonnegative spectral floor controlled by a parameter $\\beta$ that prevents the enhanced power from dropping below a fixed fraction of the noise power in each frequency bin. You must operate in the power spectral domain, and you must use the observed mixture phase to form a complex spectrum for potential resynthesis.\n- Use $\\beta = 0.02$ for all runs.\n\n5) Musical noise index (MNI) definition and computation:\n- Define a musical noise index that identifies isolated narrowband peaks within each time frame of the enhanced magnitude spectrum. For each frame index $n$:\n  - Let $\\left| \\widehat{X}(k,n) \\right|$ denote the enhanced magnitude spectrum.\n  - Form a frequency-smoothed magnitude $\\widetilde{M}(k,n)$ by convolving $\\left| \\widehat{X}(k,n) \\right|$ along frequency with a length-$3$ averaging kernel, i.e., a kernel proportional to $[1,1,1]$, with appropriate handling at the boundaries.\n  - Define a peak mask\n  $$\n  \\Pi(k,n) = \\begin{cases}\n  1,  \\text{if } \\left| \\widehat{X}(k,n) \\right|  \\gamma \\, \\widetilde{M}(k,n),\\\\\n  0,  \\text{otherwise},\n  \\end{cases}\n  $$\n  where the peak factor is $\\gamma = 3.0$.\n  - Define an isolated-peak indicator\n  $$\n  I(k,n) = \\begin{cases}\n  1,  \\text{if } \\Pi(k,n) = 1 \\text{ and } \\Pi(k-1,n) = 0 \\text{ and } \\Pi(k+1,n) = 0,\\\\\n  0,  \\text{otherwise},\n  \\end{cases}\n  $$\n  with the convention that out-of-range neighbors are treated as $0$.\n  - Let $B$ denote the number of retained frequency bins per frame (i.e., the number of one-sided bins including $k=0$ and $k=N/2$ when applicable). The frame-level isolated-peak rate is\n  $$\n  r(n) = \\frac{1}{B} \\sum_{k=0}^{B-1} I(k,n).\n  $$\n- The musical noise index (MNI) is the time-average\n$$\n\\mathrm{MNI} = \\frac{1}{N_\\text{frames}} \\sum_{n=0}^{N_\\text{frames}-1} r(n),\n$$\nwhich is a dimensionless scalar in the interval $[0,1]$.\n\n6) Test suite and outputs:\n- Evaluate the pipeline for five over-subtraction parameters $\\alpha \\in \\{ 0.0, 1.0, 2.0, 4.0, 8.0 \\}$ with fixed $\\beta = 0.02$.\n- For each $\\alpha$, compute the corresponding musical noise index $\\mathrm{MNI}(\\alpha)$ as defined above.\n\nProgram requirements and final output format:\n- Your program must be a single, complete, runnable script that performs all steps deterministically as specified, using the stated parameters and seed $s = 12345$.\n- The final program output must be a single line containing a comma-separated list enclosed in square brackets with the five $\\mathrm{MNI}(\\alpha)$ values in the order of increasing $\\alpha$, each rounded to exactly $6$ decimal places. The values are unitless real numbers. For example, a syntactically correct output line is of the form\n\"[0.012345,0.023456,0.034567,0.045678,0.056789]\".", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It presents a complete and self-contained task in digital signal processing, specifically in the domain of audio enhancement. All parameters, models, and evaluation metrics are defined with sufficient rigor to permit a unique, verifiable solution. The problem requires the construction of a signal processing pipeline from fundamental principles, which I shall now delineate.\n\nThe process is organized into six principal stages: (1) generation of a synthetic, noisy bioacoustic signal; (2) time-frequency transformation of this signal using the Short-Time Fourier Transform (STFT); (3) estimation of the noise characteristics; (4) enhancement of the signal via spectral subtraction; (5) quantification of processing artifacts using a Musical Noise Index (MNI); and (6) execution of this pipeline over a prescribed set of parameters.\n\n**1. Synthetic Signal Generation**\n\nThe foundation of this analysis is a synthetic dataset that simulates a realistic scenario. The observed signal $y[n]$ is an additive mixture of a desired clean signal $x[n]$ and an interfering noise process $v[n]$:\n$$y[n] = x[n] + v[n]$$\nAll signals are generated at a sampling rate of $F_s = 16000 \\, \\text{Hz}$ for a total duration of $T = 6 \\, \\text{s}$.\n\nThe clean signal $x[n]$ is an idealized biotic vocalization, modeled as the sum of two sinusoids with frequencies $f_1 = 2000 \\, \\text{Hz}$ and $f_2 = 3500 \\, \\text{Hz}$. Its temporal structure is defined by an amplitude envelope $A(t)$ that produces three distinct \"syllables,\" each of $0.8 \\, \\text{s}$ duration, separated by $0.2 \\, \\text{s}$ of silence. The first syllable commences at $t = 0.5 \\, \\text{s}$. Smooth onsets and offsets are ensured using raised-cosine ramps, making the signal model well-behaved. The signal is thus:\n$$x[n] = A(n/F_s) \\left( \\cos(2\\pi f_1 n/F_s) + \\cos(2\\pi f_2 n/F_s) \\right)$$\n\nThe noise process $v[n]$ is constructed to emulate wind. It begins as a sequence of independent and identically distributed (i.i.d.) Gaussian random variables. This white noise is then subjected to two shaping operations:\n- **Spectral Shaping**: A second-order low-pass Butterworth filter with a cutoff frequency of $f_c = 500 \\, \\text{Hz}$ is applied to concentrate the noise energy at lower frequencies, which is characteristic of wind.\n- **Amplitude Modulation**: To simulate gusts, the spectrally shaped noise is multiplied by a slowly varying positive envelope. This envelope is generated by low-pass filtering another i.i.d. Gaussian sequence with a cutoff below $3 \\, \\text{Hz}$ and then rectifying the result.\n\nThe final mixture $y[n]$ is formed by scaling the noise component and adding it to the clean signal. The scaling factor $\\lambda$ is carefully determined to achieve a global Signal-to-Noise Ratio (SNR) of $-5 \\, \\text{dB}$, according to the specified formula:\n$$\n\\mathrm{SNR}_\\mathrm{dB} = 10 \\log_{10} \\left( \\frac{P_x}{P_v} \\right) = -5\n$$\nwhere $P_x = \\sum_{n} x[n]^2$ is the energy of the clean signal and $P_v = \\sum_{n} (\\lambda v_{\\text{unscaled}}[n])^2$ is the energy of the scaled noise. From this, $\\lambda$ is computed as:\n$$\n\\lambda = \\sqrt{ \\frac{\\sum x[n]^2}{\\sum v_{\\text{unscaled}}[n]^2} \\cdot 10^{0.5} }\n$$\nA fixed seed for the random number generator ensures the deterministic reproducibility of the generated signals.\n\n**2. Time-Frequency Analysis via STFT**\n\nThe analysis proceeds in the time-frequency domain. The STFT is computed for the noisy signal $y[n]$. Following the definition provided, the signal is segmented into overlapping frames of length $N=1024$ samples, with a hop size of $H=256$ samples. Each frame is multiplied by a Hann window $w[m]$ before applying the Discrete Fourier Transform (DFT). The STFT coefficient for frequency bin $k$ and time frame index $n$ is:\n$$\nY(k,n) = \\sum_{m=0}^{N-1} y[nH+m]\\, w[m] \\, e^{-j 2\\pi k m / N}\n$$\nGiven that $y[n]$ is real-valued, we compute the one-sided STFT, retaining only the non-negative frequency components, which results in $B = N/2 + 1 = 513$ frequency bins per frame.\n\n**3. Noise Power Spectrum Estimation**\n\nA crucial step in spectral subtraction is estimating the power spectrum of the noise. The problem specifies that the initial $\\tau_0 = 1.0 \\, \\text{s}$ of the recording is to be considered \"noise-dominant.\" The noise power spectrum, $\\widehat{P}_v(k)$, is estimated by averaging the power spectra (periodograms) of the STFT frames whose centers fall within this initial segment. If $\\mathcal{I}_\\text{noise}$ is the set of indices of these frames, the estimate is:\n$$\n\\widehat{P}_v(k) = \\frac{1}{|\\mathcal{I}_\\text{noise}|} \\sum_{n \\in \\mathcal{I}_\\text{noise}} |Y(k,n)|^2\n$$\nThis estimate is a single vector, representing the time-averaged power of the noise at each frequency bin. It is assumed to be stationary for the duration of the signal.\n\n**4. Spectral Subtraction Enhancement**\n\nThe core of the enhancement is the spectral subtraction rule. Assuming that the signal and noise are uncorrelated, the power spectrum of the mixture is approximately the sum of the power spectra of the clean signal and the noise:\n$$|Y(k,n)|^2 \\approx |X(k,n)|^2 + |V(k,n)|^2$$\nFrom this, an estimate for the clean signal power spectrum, $\\widehat{P}_x(k,n)$, can be derived by subtracting the estimated noise power spectrum from the mixture power spectrum. The algorithm incorporates two key parameters for refinement:\n- **Over-subtraction factor $\\alpha$**: This factor scales the noise estimate to compensate for estimation errors and reduce residual noise. A value $\\alpha  1$ subtracts more than the estimated noise power.\n- **Spectral flooring parameter $\\beta$**: Subtraction can result in negative power estimates. To prevent this and to mitigate the \"musical noise\" artifact, a spectral floor is established, ensuring that the estimated signal power does not fall below a small fraction $\\beta$ of the estimated noise power.\n\nThe resulting power spectral subtraction rule is:\n$$\n\\widehat{P}_x(k,n) = \\max \\left( |Y(k,n)|^2 - \\alpha \\widehat{P}_v(k), \\, \\beta \\widehat{P}_v(k) \\right)\n$$\nThe enhanced signal magnitude is the square root of this power estimate, $|\\widehat{X}(k,n)| = \\sqrt{\\widehat{P}_x(k,n)}$. The phase of the enhanced signal is assumed to be the same as the phase of the original noisy signal, a standard practice known as preserving the \"short-time phase\". The enhanced complex spectrum is thus:\n$$\n\\widehat{X}(k,n) = |\\widehat{X}(k,n)| \\frac{Y(k,n)}{|Y(k,n)|}\n$$\n\n**5. Musical Noise Index (MNI) Quantification**\n\nSpectral subtraction is known to introduce artifacts perceived as isolated, short-lived tonal bursts, termed \"musical noise.\" The problem requires the formalization and computation of a Musical Noise Index (MNI) to quantify this effect. The MNI is designed to measure the prevalence of isolated spectral peaks in the enhanced spectrogram. For each time frame $n$:\n\n- First, the enhanced magnitude spectrum $|\\widehat{X}(k,n)|$ is smoothed along the frequency axis by convolution with a length-3 averaging kernel, $[1/3, 1/3, 1/3]$, yielding a local mean magnitude $\\widetilde{M}(k,n)$.\n- A peak mask $\\Pi(k,n)$ is created by identifying bins where the magnitude significantly exceeds the local mean:\n$$\n\\Pi(k,n) = 1 \\quad \\text{if } |\\widehat{X}(k,n)|  \\gamma \\widetilde{M}(k,n), \\quad \\text{with } \\gamma=3.0\n$$\n- An isolated-peak indicator $I(k,n)$ is then defined for peaks that have no adjacent peaks:\n$$\nI(k,n) = 1 \\quad \\text{if } \\Pi(k,n) = 1 \\text{ and } \\Pi(k-1,n) = 0 \\text{ and } \\Pi(k+1,n) = 0\n$$\n- The frame-level isolated-peak rate $r(n)$ is the fraction of frequency bins in that frame identified as isolated peaks:\n$$\nr(n) = \\frac{1}{B} \\sum_{k=0}^{B-1} I(k,n)\n$$\n- Finally, the MNI is the average of these rates over all time frames, providing a single scalar metric for the entire enhanced signal:\n$$\n\\mathrm{MNI} = \\frac{1}{N_\\text{frames}} \\sum_{n=0}^{N_\\text{frames}-1} r(n)\n$$\n\n**6. Computational Procedure**\n\nThe final program implements this entire pipeline. It first synthesizes the signals $x[n]$ and $v[n]$ and mixes them to the target SNR. It then computes the STFT of the mixture $y[n]$ and estimates the noise power spectrum $\\widehat{P}_v(k)$. For each specified value of the over-subtraction parameter $\\alpha \\in \\{0.0, 1.0, 2.0, 4.0, 8.0\\}$, it performs spectral subtraction with the fixed flooring parameter $\\beta = 0.02$. It then calculates the Musical Noise Index (MNI) on the resulting enhanced spectrogram. The computed MNI values for each $\\alpha$ are collected and formatted into the required output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Constructs a full spectral subtraction pipeline from first principles,\n    evaluates it on a synthetic bioacoustic signal, and quantifies musical\n    noise artifacts as a function of the over-subtraction parameter.\n    \"\"\"\n    \n    # ---------------------------------------------------------------------\n    # 0. Global Parameters and Setup\n    # ---------------------------------------------------------------------\n    FS = 16000  # Sampling rate in Hz\n    T = 6.0     # Signal duration in seconds\n    N_SAMPLES = int(FS * T)\n    t = np.arange(N_SAMPLES) / FS\n    \n    # STFT parameters\n    N_FFT = 1024      # Window length for STFT\n    HOP_LENGTH = 256  # Hop size for STFT\n    \n    # Spectral subtraction parameters\n    BETA = 0.02       # Spectral flooring parameter\n    ALPHAS = [0.0, 1.0, 2.0, 4.0, 8.0] # Over-subtraction parameters\n    \n    # MNI parameters\n    GAMMA = 3.0       # Peak factor for MNI\n    \n    # Noise estimation parameter\n    TAU_0 = 1.0       # Duration of noise-only segment in seconds\n    \n    # RNG setup for determinism\n    RNG_SEED = 12345\n    rng = np.random.default_rng(RNG_SEED)\n\n    # ---------------------------------------------------------------------\n    # 1. Synthetic Dataset Construction\n    # ---------------------------------------------------------------------\n    \n    # a) Clean Biotic Signal (x[n])\n    f1, f2 = 2000.0, 3500.0\n    signal_x = (np.cos(2 * np.pi * f1 * t) + np.cos(2 * np.pi * f2 * t))\n    \n    envelope = np.zeros(N_SAMPLES)\n    burst_duration_s = 0.8\n    silence_duration_s = 0.2\n    ramp_duration_s = 0.05 # Smooth onset/offset\n    ramp_samples = int(ramp_duration_s * FS)\n    \n    t_ramp = np.arange(ramp_samples) / ramp_samples\n    ramp_up = 0.5 * (1 - np.cos(np.pi * t_ramp))\n    ramp_down = np.flip(ramp_up)\n    \n    start_time = 0.5\n    for i in range(3):\n        burst_start_s = start_time + i * (burst_duration_s + silence_duration_s)\n        burst_end_s = burst_start_s + burst_duration_s\n        \n        start_idx = int(burst_start_s * FS)\n        end_idx = int(burst_end_s * FS)\n        \n        envelope[start_idx : start_idx + ramp_samples] = ramp_up\n        envelope[start_idx + ramp_samples : end_idx - ramp_samples] = 1.0\n        envelope[end_idx - ramp_samples : end_idx] = ramp_down\n\n    x = signal_x * envelope\n    \n    # b) Wind Noise Signal (v[n])\n    # Generate base Gaussian noise\n    noise_base = rng.standard_normal(N_SAMPLES)\n    \n    # Apply low-pass filter for spectral coloration\n    fc_noise = 500.0\n    b_noise, a_noise = signal.butter(2, fc_noise, btype='low', fs=FS)\n    noise_colored = signal.lfilter(b_noise, a_noise, noise_base)\n    \n    # Generate and apply amplitude modulation for gusts\n    gust_raw = rng.standard_normal(N_SAMPLES)\n    fc_gust = 2.0  # Modulation frequency  3 Hz\n    b_gust, a_gust = signal.butter(1, fc_gust, btype='low', fs=FS)\n    gust_filtered = signal.lfilter(b_gust, a_gust, gust_raw)\n    gust_env = np.abs(gust_filtered)\n    gust_env /= np.mean(gust_env)\n    \n    v_unscaled = noise_colored * gust_env\n\n    # c) Signal Mixture (y[n])\n    power_x = np.sum(x**2)\n    power_v_unscaled = np.sum(v_unscaled**2)\n    \n    target_snr_db = -5.0\n    target_snr_linear = 10**(target_snr_db / 10.0)\n    \n    lambda_val = np.sqrt((power_x / power_v_unscaled) / target_snr_linear)\n    v = lambda_val * v_unscaled\n    y = x + v\n\n    # ---------------------------------------------------------------------\n    # 2. Time-Frequency Analysis (manual STFT)\n    # ---------------------------------------------------------------------\n    window = np.hanning(N_FFT)\n    num_frames = (N_SAMPLES - N_FFT) // HOP_LENGTH + 1\n    num_freq_bins = N_FFT // 2 + 1\n    \n    Y_stft = np.zeros((num_freq_bins, num_frames), dtype=np.complex128)\n    \n    for n in range(num_frames):\n        start_idx = n * HOP_LENGTH\n        frame = y[start_idx : start_idx + N_FFT]\n        windowed_frame = frame * window\n        spectrum = np.fft.rfft(windowed_frame)\n        Y_stft[:, n] = spectrum\n        \n    # ---------------------------------------------------------------------\n    # Main processing loop\n    # ---------------------------------------------------------------------\n    \n    results = []\n    \n    # 3. Noise Estimation (run once)\n    noise_est_end_idx = int(TAU_0 * FS)\n    # Use frames whose center is within the noise estimation period\n    noise_frames_end_n = int((noise_est_end_idx - N_FFT/2) / HOP_LENGTH)\n    \n    noise_stft_frames = Y_stft[:, :noise_frames_end_n]\n    noise_power_spec = np.mean(np.abs(noise_stft_frames)**2, axis=1)\n\n    for alpha in ALPHAS:\n        # 4. Spectral Subtraction Enhancement\n        Y_power = np.abs(Y_stft)**2\n        \n        # Broadcasting noise_power_spec to match Y_power dimensions\n        noise_power_spec_broadcast = noise_power_spec[:, np.newaxis]\n        \n        X_hat_power = Y_power - alpha * noise_power_spec_broadcast\n        \n        spectral_floor = BETA * noise_power_spec_broadcast\n        X_hat_power = np.maximum(X_hat_power, spectral_floor)\n        \n        X_hat_mag = np.sqrt(X_hat_power)\n        \n        # 5. Musical Noise Index (MNI) Computation\n        r_n_list = []\n        for n in range(num_frames):\n            mag_frame = X_hat_mag[:, n]\n            \n            # Frequency smoothing\n            conv_kernel = np.array([1, 1, 1]) / 3.0\n            smoothed_mag_frame = np.convolve(mag_frame, conv_kernel, mode='same')\n            \n            # Peak mask\n            peak_mask = mag_frame  GAMMA * smoothed_mag_frame\n            \n            # Isolated peak indicator\n            pi = peak_mask.astype(float)\n            pi_left = np.pad(pi, (1, 0), 'constant', constant_values=0)[:-1]\n            pi_right = np.pad(pi, (0, 1), 'constant', constant_values=0)[1:]\n            \n            isolated_mask = (pi == 1)  (pi_left == 0)  (pi_right == 0)\n            \n            # Frame-level isolated-peak rate\n            num_isolated_peaks = np.sum(isolated_mask)\n            r_n = num_isolated_peaks / num_freq_bins\n            r_n_list.append(r_n)\n        \n        # Final MNI calculation\n        mni = np.mean(r_n_list)\n        results.append(mni)\n        \n    # 6. Final Output Formatting\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2533913"}]}