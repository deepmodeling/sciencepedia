{"hands_on_practices": [{"introduction": "The Fisher-KPP equation is a cornerstone of mathematical ecology, providing a fundamental model for how populations with logistic growth and random dispersal invade new territory. This exercise [@problem_id:2534611] guides you through two essential analytical techniques. First, you will use non-dimensionalization to distill the equation into its universal form, a powerful method for revealing the intrinsic scales of a system. Second, you will analyze traveling wave solutions to derive the minimal speed of invasion, linking microscopic parameters like growth rate ($r$) and diffusivity ($D$) to the emergent, macroscopic phenomenon of population spread.", "problem": "A spatially explicit population with local logistic growth and random dispersal along a one-dimensional ($1$-D) unbounded habitat is modeled by the Fisher–Kolmogorov–Petrovsky–Piskunov (Fisher–KPP) reaction–diffusion equation\n$$\n\\frac{\\partial N}{\\partial t} \\;=\\; D\\,\\frac{\\partial^{2}N}{\\partial x^{2}} \\;+\\; r\\,N\\Bigl(1-\\frac{N}{K}\\Bigr),\n$$\nwhere $N(x,t)$ is the population density, $D$ is the diffusion coefficient, $r$ is the intrinsic growth rate, and $K$ is the carrying capacity. Consider a species for which $D=0.5\\,\\text{km}^{2}/\\text{yr}$, $r=0.2\\,\\text{yr}^{-1}$, and $K=100\\,\\text{ind}/\\text{km}^{2}$. \n\nUsing first principles of dimensional analysis and scaling, perform the following:\n\n1) Introduce dimensionless variables by selecting characteristic scales $L$ for space, $T$ for time, and $K$ for density to transform the equation into a dimensionless form. Choose $L$ and $T$ so that the coefficients of the diffusion and growth terms in the transformed equation are both equal to $1$. Write the resulting dimensionless partial differential equation and identify any remaining intrinsic dimensionless parameters appearing in the equation.\n\n2) On the unbounded line, consider monotone traveling invasion waves that connect the unstable state to the stable state. Starting from the dimensionless equation obtained in part ($1$), use a traveling-wave reduction and a linearization about the leading edge to determine the minimal dimensionless invasion speed. Then convert this minimal speed back to dimensional units to obtain an explicit expression in terms of $D$ and $r$. Finally, evaluate this minimal invasion speed numerically for the given species. Express your final numerical answer in $\\text{km}/\\text{yr}$ and round to four significant figures.\n\nYour final reported answer must be a single real number, representing the minimal invasion speed in $\\text{km}/\\text{yr}$, rounded to four significant figures.", "solution": "The problem presented is a standard and well-posed exercise in the analysis of reaction-diffusion equations, specifically the Fisher-Kolmogorov-Petrovsky-Piskunov (Fisher-KPP) equation. It is scientifically grounded, internally consistent, and contains all necessary information for a unique solution. We shall proceed with the analysis.\n\nThe governing equation is given as:\n$$\n\\frac{\\partial N}{\\partial t} \\;=\\; D\\,\\frac{\\partial^{2}N}{\\partial x^{2}} \\;+\\; r\\,N\\Bigl(1-\\frac{N}{K}\\Bigr)\n$$\nwhere $N(x,t)$ is population density, $D$ is the diffusion coefficient, $r$ is the intrinsic growth rate, and $K$ is the carrying capacity. The given parameter values are $D=0.5\\,\\text{km}^{2}/\\text{yr}$, $r=0.2\\,\\text{yr}^{-1}$, and $K=100\\,\\text{ind}/\\text{km}^{2}$.\n\n**Part 1: Nondimensionalization**\n\nWe introduce the following dimensionless variables, using the characteristic scales $L$ for length, $T$ for time, and $K$ for population density:\n$$\nu = \\frac{N}{K}, \\quad \\xi = \\frac{x}{L}, \\quad \\tau = \\frac{t}{T}\n$$\nHere, $u$, $\\xi$, and $\\tau$ are the dimensionless density, space, and time variables, respectively. We express the derivatives from the original equation in terms of these new variables using the chain rule:\n$$\n\\frac{\\partial N}{\\partial t} = \\frac{\\partial (Ku)}{\\partial \\tau} \\frac{\\partial \\tau}{\\partial t} = \\frac{K}{T} \\frac{\\partial u}{\\partial \\tau}\n$$\n$$\n\\frac{\\partial N}{\\partial x} = \\frac{\\partial (Ku)}{\\partial \\xi} \\frac{\\partial \\xi}{\\partial x} = \\frac{K}{L} \\frac{\\partial u}{\\partial \\xi} \\quad \\implies \\quad \\frac{\\partial^{2} N}{\\partial x^{2}} = \\frac{\\partial}{\\partial x}\\left(\\frac{K}{L}\\frac{\\partial u}{\\partial \\xi}\\right) = \\frac{K}{L} \\frac{\\partial}{\\partial \\xi}\\left(\\frac{\\partial u}{\\partial \\xi}\\right) \\frac{\\partial \\xi}{\\partial x} = \\frac{K}{L^2} \\frac{\\partial^{2} u}{\\partial \\xi^{2}}\n$$\nSubstituting these expressions into the Fisher-KPP equation yields:\n$$\n\\frac{K}{T} \\frac{\\partial u}{\\partial \\tau} = D \\frac{K}{L^2} \\frac{\\partial^{2} u}{\\partial \\xi^{2}} + r (Ku) \\left(1 - \\frac{Ku}{K}\\right)\n$$\nDividing the entire equation by $K$ and rearranging gives:\n$$\n\\frac{1}{T} \\frac{\\partial u}{\\partial \\tau} = \\frac{D}{L^2} \\frac{\\partial^{2} u}{\\partial \\xi^{2}} + r u(1 - u)\n$$\nMultiplying by $T$, we obtain:\n$$\n\\frac{\\partial u}{\\partial \\tau} = \\frac{DT}{L^2} \\frac{\\partial^{2} u}{\\partial \\xi^{2}} + rT u(1 - u)\n$$\nThe problem requires that we choose the characteristic scales $L$ and $T$ such that the coefficients of the diffusion term and the reaction term are both equal to $1$. This gives a system of two algebraic equations for $L$ and $T$:\n$$\n\\frac{DT}{L^2} = 1\n$$\n$$\nrT = 1\n$$\nFrom the second equation, we find the characteristic time scale $T$:\n$$\nT = \\frac{1}{r}\n$$\nSubstituting this result into the first equation allows us to solve for the characteristic length scale $L$:\n$$\n\\frac{D(1/r)}{L^2} = 1 \\quad \\implies \\quad \\frac{D}{r} = L^2 \\quad \\implies \\quad L = \\sqrt{\\frac{D}{r}}\n$$\nWith these characteristic scales, the dimensionless form of the Fisher-KPP equation becomes:\n$$\n\\frac{\\partial u}{\\partial \\tau} = \\frac{\\partial^2 u}{\\partial \\xi^2} + u(1-u)\n$$\nIn this canonical form, all dimensional parameters ($D$, $r$, $K$) have been absorbed into the scaling of the variables. Therefore, there are no remaining intrinsic dimensionless parameters in the equation itself.\n\n**Part 2: Minimal Invasion Speed**\n\nWe analyze the dimensionless equation for traveling wave solutions of the form $u(\\xi, \\tau) = U(z)$, where $z = \\xi - c\\tau$ is the traveling wave coordinate and $c$ is the constant, dimensionless wave speed. The wave connects the unstable equilibrium state $u=0$ to the stable equilibrium state $u=1$. The derivatives transform as:\n$$\n\\frac{\\partial u}{\\partial \\tau} = -c \\frac{dU}{dz}, \\quad \\frac{\\partial^2 u}{\\partial \\xi^2} = \\frac{d^2 U}{dz^2}\n$$\nSubstituting these into the dimensionless PDE yields a second-order ordinary differential equation for the wave profile $U(z)$:\n$$\n-c U' = U'' + U(1-U) \\quad \\text{or} \\quad U'' + cU' + U(1-U) = 0\n$$\nThe boundary conditions for an invasion front are $U(z) \\to 0$ as $z \\to \\infty$ (the leading edge) and $U(z) \\to 1$ as $z \\to -\\infty$ (the trailing edge).\n\nTo determine the minimal speed, we analyze the behavior at the leading edge of the wave, where $U$ is close to $0$. In this limit, the term $U(1-U) = U - U^2$ can be linearized to just $U$. The ODE becomes:\n$$\nU'' + cU' + U \\approx 0\n$$\nThis is a linear homogeneous ODE with constant coefficients. We seek an exponential solution of the form $U(z) \\propto \\exp(-\\lambda z)$, which must decay for large $z$ (so $\\lambda > 0$). Substitution into the linearized ODE gives the characteristic equation for $\\lambda$:\n$$\n\\lambda^2 - c\\lambda + 1 = 0\n$$\nThe roots for $\\lambda$ are given by the quadratic formula:\n$$\n\\lambda = \\frac{c \\pm \\sqrt{c^2 - 4}}{2}\n$$\nFor a monotonic (non-oscillatory) decay of the population density at the leading edge, the roots $\\lambda$ must be real and positive. The condition for real roots is that the discriminant must be non-negative:\n$$\nc^2 - 4 \\ge 0 \\quad \\implies \\quad c^2 \\ge 4\n$$\nSince invasion speed $c$ must be positive, this implies $c \\ge 2$. The minimum possible dimensionless speed is therefore:\n$$\nc_{min} = 2\n$$\nNow, we must convert this minimal dimensionless speed back into dimensional units. The dimensional speed $v$ is related to the dimensionless speed $c$ by the characteristic speed $L/T$:\n$$\nv = c \\frac{L}{T}\n$$\nUsing the expressions for $L$ and $T$ derived earlier:\n$$\n\\frac{L}{T} = \\frac{\\sqrt{D/r}}{1/r} = r \\sqrt{\\frac{D}{r}} = \\sqrt{r^2 \\frac{D}{r}} = \\sqrt{Dr}\n$$\nThus, the dimensional speed is $v = c \\sqrt{Dr}$. The minimal invasion speed $v_{min}$ corresponds to $c_{min}=2$:\n$$\nv_{min} = 2\\sqrt{Dr}\n$$\nThis is the celebrated formula for the minimal speed of invasion for the Fisher-KPP equation.\n\nFinally, we evaluate this speed using the given parameter values: $D = 0.5\\,\\text{km}^{2}/\\text{yr}$ and $r = 0.2\\,\\text{yr}^{-1}$.\n$$\nv_{min} = 2 \\sqrt{(0.5\\,\\text{km}^{2}/\\text{yr})(0.2\\,\\text{yr}^{-1})} = 2 \\sqrt{0.1\\,\\text{km}^{2}/\\text{yr}^{2}}\n$$\n$$\nv_{min} = 2 \\sqrt{0.1} \\, \\text{km}/\\text{yr} \\approx 2 \\times 0.316227766... \\, \\text{km}/\\text{yr}\n$$\n$$\nv_{min} \\approx 0.632455532... \\, \\text{km}/\\text{yr}\n$$\nRounding the result to four significant figures as requested, we obtain $0.6325\\,\\text{km}/\\text{yr}$.", "answer": "$$\n\\boxed{0.6325}\n$$", "id": "2534611"}, {"introduction": "While continuous models are elegant, many real-world landscapes are fragmented into discrete patches. This practice [@problem_id:2534600] transitions to a patch-based framework, a vital tool in metapopulation ecology and conservation. You will first classify habitat patches as 'sources' or 'sinks' based on local demographic data, and then implement a numerical model to solve for the equilibrium occupancy of these patches. This exercise provides critical hands-on experience in simulating how dispersal connectivity allows sources to sustain populations in sinks, a core principle of metapopulation viability.", "problem": "You are given a spatially explicit, density-independent patch model. For each patch indexed by $i \\in \\{0,1,2,3,4\\}$, you have per-time-step per capita survival $s_i$ and per-time-step per capita fecundity measured in census recruits $f_i$. Assume a post-breeding census such that the local finite rate of increase is $\\lambda_i = s_i + f_i$. Define the intrinsic rate of increase as $r_i = \\ln(\\lambda_i)$. A patch is a source if $r_i > 0$ and a sink if $r_i < 0$. \n\nDispersal-driven colonization is modeled by a connectivity matrix $A(\\alpha)$ with entries\n$$\nA_{ij}(\\alpha) = \n\\begin{cases}\n\\exp\\left(-\\dfrac{d_{ij}}{\\alpha}\\right), & \\text{if } i \\neq j, \\\\\n0, & \\text{if } i = j,\n\\end{cases}\n$$\nwhere $d_{ij}$ is the Euclidean distance between the centroids of patches $i$ and $j$, and $\\alpha > 0$ is a dispersal length-scale parameter. For each patch $i$, the colonization pressure is $c_i = \\beta \\sum_{j=0}^{4} A_{ij}(\\alpha) p_j$, where $p_i \\in [0,1]$ is the occupancy probability of patch $i$ at equilibrium, and $\\beta > 0$ is a global colonization scaling. Local extinction rates are patch-type dependent: if patch $i$ is a source, $e_i = e_{\\text{src}}$; if patch $i$ is a sink, $e_i = e_{\\text{snk}}$. The occupancy dynamics follow the classical patch-occupancy differential equation\n$$\n\\frac{dp_i}{dt} = \\left(1 - p_i\\right) c_i - e_i p_i,\n$$\nand the equilibrium is determined by the fixed-point condition\n$$\np_i = \\frac{c_i}{c_i + e_i} \\quad \\text{with} \\quad c_i = \\beta \\sum_{j=0}^{4} A_{ij}(\\alpha) p_j.\n$$\nYou must solve for the stable fixed point $p \\in [0,1]^5$ by fixed-point iteration for each specified $\\alpha$, starting from any reasonable initial guess, and iterating until the infinity norm of the difference between successive iterates is below a strict tolerance.\n\nUse the following data:\n- Patch coordinates as $(x_i,y_i)$:\n  - Patch $0$: $(0.0, 0.0)$\n  - Patch $1$: $(1.5, 0.2)$\n  - Patch $2$: $(0.8, 1.0)$\n  - Patch $3$: $(2.5, 1.7)$\n  - Patch $4$: $(3.0, 0.1)$\n- Survival $s_i$ and fecundity $f_i$:\n  - $s = [0.70, 0.50, 0.65, 0.40, 0.55]$\n  - $f = [0.60, 0.30, 0.55, 0.35, 0.30]$\n- Colonization scaling and extinction parameters:\n  - $\\beta = 0.60$\n  - $e_{\\text{src}} = 0.10$\n  - $e_{\\text{snk}} = 0.50$\n\nYour tasks:\n1. Compute $\\lambda_i = s_i + f_i$ and $r_i = \\ln(\\lambda_i)$ for each $i \\in \\{0,1,2,3,4\\}$. Classify each patch as a source if $r_i > 0$ and as a sink if $r_i < 0$. Represent the classification as a list of integers of length $5$ with $1$ for source and $0$ for sink, in ascending patch index order.\n2. For each scenario value of the dispersal length-scale $\\alpha$, solve the equilibrium fixed-point system\n   $$\n   p_i = \\frac{\\beta \\sum_{j=0}^{4} A_{ij}(\\alpha) p_j}{\\beta \\sum_{j=0}^{4} A_{ij}(\\alpha) p_j + e_i}\n   $$\n   using fixed-point iteration with a strict convergence tolerance of $\\varepsilon = 10^{-12}$ on the infinity norm and a hard cap of $10^6$ iterations to avoid non-termination if convergence fails. Use the classification from step $1$ to set $e_i$ for each patch.\n3. For each scenario, report only the occupancy probabilities of the sink patches, in ascending patch index order, each rounded to exactly three decimal places as decimals.\n\nTest suite:\n- Use the following four $\\alpha$ values to constitute the test suite and assess model behavior across connectivity regimes: $\\alpha \\in \\{0.50, 1.00, 2.00, 4.00\\}$. This set includes a low-connectivity case, two intermediate cases, and a high-connectivity case.\n\nFinal output format:\n- Your program should produce a single line of output containing two items enclosed in an outer pair of square brackets.\n  1. The first item is the classification list of length $5$ with entries in $\\{0,1\\}$, indicating sink ($0$) or source ($1$), in patch-index order $[0,1,2,3,4]$.\n  2. The second item is a list of lists, one inner list per $\\alpha$ in the order $\\alpha = 0.50, 1.00, 2.00, 4.00$, where each inner list contains the equilibrium occupancy probabilities for sink patches only, ordered by ascending patch index and rounded to three decimals.\n- For example, the final line should look like:\n  $$\n  [[b_0,b_1,b_2,b_3,b_4],[[q_{1}^{(1)},q_{3}^{(1)},q_{4}^{(1)}],[q_{1}^{(2)},q_{3}^{(2)},q_{4}^{(2)}],[q_{1}^{(3)},q_{3}^{(3)},q_{4}^{(3)}],[q_{1}^{(4)},q_{3}^{(4)},q_{4}^{(4)}]]]\n  $$\n  where $b_i \\in \\{0,1\\}$ and each $q_{k}^{(\\ell)}$ is a decimal rounded to three places. Ensure the program prints only this line, with no extra whitespace or text.\n\nAll quantities in this problem are unitless and per time step. Angles are not involved. The required answers are lists of integers and lists of floats as specified above. Your solution must be implemented as a complete, runnable program.", "solution": "The problem statement has been validated and is deemed scientifically sound, well-posed, and self-contained. It presents a standard patch-occupancy metapopulation model from theoretical ecology. All parameters and governing equations are explicitly defined. We shall proceed with the solution.\n\nThe problem requires a two-part computation. First, we must classify each patch as a source or a sink based on its intrinsic demographic properties. Second, for a given set of dispersal length-scales $\\alpha$, we must solve for the equilibrium patch occupancy probabilities $p_i$ using a fixed-point iteration scheme.\n\n**Part 1: Patch Classification**\n\nThe classification of a patch as a source or sink depends on its intrinsic rate of increase, $r_i$. This is derived from the per capita survival $s_i$ and fecundity $f_i$ for each patch $i \\in \\{0, 1, 2, 3, 4\\}$. The local finite rate of increase, $\\lambda_i$, is defined as the sum of survival and fecundity for a post-breeding census model:\n$$\n\\lambda_i = s_i + f_i\n$$\nThe intrinsic rate of increase, $r_i$, is the natural logarithm of $\\lambda_i$:\n$$\nr_i = \\ln(\\lambda_i)\n$$\nA patch $i$ is a source if its population would grow in isolation ($r_i > 0$), and a sink if it would decline ($r_i < 0$).\n\nThe given data are:\n- Survival rates: $s = [0.70, 0.50, 0.65, 0.40, 0.55]$\n- Fecundity rates: $f = [0.60, 0.30, 0.55, 0.35, 0.30]$\n\nWe calculate $\\lambda_i$ for each patch $i$:\n- $\\lambda_0 = s_0 + f_0 = 0.70 + 0.60 = 1.30$\n- $\\lambda_1 = s_1 + f_1 = 0.50 + 0.30 = 0.80$\n- $\\lambda_2 = s_2 + f_2 = 0.65 + 0.55 = 1.20$\n- $\\lambda_3 = s_3 + f_3 = 0.40 + 0.35 = 0.75$\n- $\\lambda_4 = s_4 + f_4 = 0.55 + 0.30 = 0.85$\n\nNext, we calculate $r_i = \\ln(\\lambda_i)$:\n- $r_0 = \\ln(1.30) \\approx 0.262 > 0 \\implies$ Source\n- $r_1 = \\ln(0.80) \\approx -0.223 < 0 \\implies$ Sink\n- $r_2 = \\ln(1.20) \\approx 0.182 > 0 \\implies$ Source\n- $r_3 = \\ln(0.75) \\approx -0.288 < 0 \\implies$ Sink\n- $r_4 = \\ln(0.85) \\approx -0.163 < 0 \\implies$ Sink\n\nThe classification, represented by $1$ for a source and $0$ for a sink, is $[1, 0, 1, 0, 0]$.\nThe corresponding local extinction rates $e_i$ are set according to this classification using the provided parameters $e_{\\text{src}} = 0.10$ and $e_{\\text{snk}} = 0.50$:\n$$\ne = [0.10, 0.50, 0.10, 0.50, 0.50]\n$$\n\n**Part 2: Equilibrium Occupancy Probabilities**\n\nThe equilibrium occupancy probabilities $p = [p_0, p_1, p_2, p_3, p_4]$ are determined by the fixed-point equation:\n$$\np_i = \\frac{c_i}{c_i + e_i}\n$$\nwhere the colonization pressure $c_i$ is given by\n$$\nc_i = \\beta \\sum_{j=0}^{4} A_{ij}(\\alpha) p_j\n$$\nThe global colonization scaling is $\\beta = 0.60$. The connectivity matrix $A(\\alpha)$ depends on the dispersal length-scale $\\alpha$ and the Euclidean distances $d_{ij}$ between patch centroids. The entries are $A_{ij}(\\alpha) = \\exp(-d_{ij}/\\alpha)$ for $i \\neq j$ and $A_{ii}(\\alpha) = 0$.\n\nFirst, we compute the symmetric distance matrix $D$ where $D_{ij} = d_{ij}$ using the patch coordinates:\n- $P_0=(0.0, 0.0)$, $P_1=(1.5, 0.2)$, $P_2=(0.8, 1.0)$, $P_3=(2.5, 1.7)$, $P_4=(3.0, 0.1)$.\nThis yields distances such as $d_{01} = \\sqrt{(1.5-0.0)^2 + (0.2-0.0)^2} \\approx 1.513$.\n\nWe must solve the system for each specified value of $\\alpha \\in \\{0.50, 1.00, 2.00, 4.00\\}$. The problem specifies using a fixed-point iteration method. Let the vector of probabilities be $p^{(k)}$ at iteration $k$. The next iterate $p^{(k+1)}$ is given by the mapping $F$:\n$$\np^{(k+1)} = F(p^{(k)})\n$$\nwhere the $i$-th component of the mapping is:\n$$\n[F(p)]_i = \\frac{\\beta \\sum_{j=0}^{4} A_{ij}(\\alpha) p_j}{\\beta \\sum_{j=0}^{4} A_{ij}(\\alpha) p_j + e_i}\n$$\nThe iteration proceeds as follows for each $\\alpha$:\n1.  Compute the connectivity matrix $A(\\alpha)$ using the pre-computed distance matrix $D$.\n2.  Initialize the probability vector $p^{(0)}$. A reasonable choice that avoids the trivial fixed point at $p=0$ is $p^{(0)}_i = 0.5$ for all $i$.\n3.  Iterate $p^{(k+1)} = F(p^{(k)})$ for $k = 0, 1, 2, \\ldots$\n4.  Stop when the infinity norm of the difference between successive iterates is below the tolerance $\\varepsilon = 10^{-12}$:\n    $$\n    \\|p^{(k+1)} - p^{(k)}\\|_{\\infty} = \\max_i |p_{i}^{(k+1)} - p_{i}^{(k)}| < \\varepsilon\n    $$\n5.  A maximum of $10^6$ iterations is enforced to prevent non-termination.\n\nOnce the iteration converges to a fixed point $p^*$, we extract the probabilities for the sink patches, which are patches $1$, $3$, and $4$. These probabilities ($p_1^*, p_3^*, p_4^*$) are then rounded to three decimal places. This process is repeated for each $\\alpha$ in the test suite.\n\nThe final output is a list containing two elements: the patch classification list and a list of lists, where each inner list contains the rounded equilibrium occupancy probabilities for the sink patches for a given $\\alpha$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the patch-occupancy model problem as specified.\n\n    1. Classifies patches as sources or sinks.\n    2. For each alpha, solves for equilibrium occupancies using fixed-point iteration.\n    3. Formats the results into the required output string.\n    \"\"\"\n    # Define given parameters\n    coords = np.array([\n        [0.0, 0.0],  # Patch 0\n        [1.5, 0.2],  # Patch 1\n        [0.8, 1.0],  # Patch 2\n        [2.5, 1.7],  # Patch 3\n        [3.0, 0.1]   # Patch 4\n    ])\n    s = np.array([0.70, 0.50, 0.65, 0.40, 0.55])\n    f = np.array([0.60, 0.30, 0.55, 0.35, 0.30])\n    \n    beta = 0.60\n    e_src = 0.10\n    e_snk = 0.50\n    \n    alphas = [0.50, 1.00, 2.00, 4.00]\n    tolerance = 1e-12\n    max_iterations = 1_000_000\n    n_patches = len(coords)\n\n    # --- Task 1: Patch Classification ---\n    lambda_vals = s + f\n    r_vals = np.log(lambda_vals)\n    \n    # Classification: 1 for source (r > 0), 0 for sink (r < 0)\n    classification = (r_vals > 0).astype(int).tolist()\n    \n    # Assign extinction rates based on classification\n    e_rates = np.where(r_vals > 0, e_src, e_snk)\n    \n    # Identify indices of sink patches for final reporting\n    sink_indices = np.where(r_vals < 0)[0]\n    \n    # --- Pre-computation: Distance Matrix ---\n    dist_matrix = np.zeros((n_patches, n_patches))\n    for i in range(n_patches):\n        for j in range(i, n_patches):\n            dist = np.linalg.norm(coords[i] - coords[j])\n            dist_matrix[i, j] = dist\n            dist_matrix[j, i] = dist\n\n    # --- Task 2 & 3: Fixed-Point Iteration and Result Collection ---\n    all_sink_occupancies = []\n    \n    for alpha in alphas:\n        # Compute connectivity matrix A(alpha)\n        # We explicitly set a large value where alpha is zero to avoid division by zero,\n        # though the problem states alpha > 0. This is just for robustness.\n        # The exponential of a large negative number will be zero.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            A = np.exp(-dist_matrix / alpha)\n        \n        # Diagonal entries are 0\n        np.fill_diagonal(A, 0)\n        \n        # Initialize occupancy probabilities (vector p)\n        # Start with 0.5 to avoid the trivial fixed point at p=0\n        p = np.full(n_patches, 0.5)\n\n        for _ in range(max_iterations):\n            p_old = p.copy()\n            \n            # Calculate colonization pressure (vector c)\n            c = beta * (A @ p_old)\n            \n            # Update occupancy probabilities using the fixed-point equation\n            # p_i = c_i / (c_i + e_i)\n            # Handle c_i + e_i = 0 case, though unlikely as e_i > 0\n            denominator = c + e_rates\n            p = np.divide(c, denominator, out=np.zeros_like(c), where=denominator!=0)\n\n            # Check for convergence using the infinity norm\n            if np.linalg.norm(p - p_old, ord=np.inf) < tolerance:\n                break\n        \n        # Extract occupancy probabilities for sink patches\n        sink_p = p[sink_indices]\n        \n        # Round to three decimal places\n        rounded_sink_p = np.round(sink_p, 3).tolist()\n        all_sink_occupancies.append(rounded_sink_p)\n        \n    # --- Final Output Formatting ---\n    # Assemble the final data structure\n    final_result = [classification, all_sink_occupancies]\n    \n    # Convert the result to a string representation without spaces\n    output_str = str(final_result).replace(\" \", \"\")\n    \n    print(output_str)\n\nsolve()\n```", "id": "2534600"}, {"introduction": "This advanced exercise [@problem_id:2534612] elevates the patch model by incorporating two crucial layers of realism: stochasticity and optimization. Real populations are subject to random local extinctions, and a key goal of applied ecology is to design management strategies that maximize persistence in the face of this uncertainty. You are tasked with constructing a stochastic patch occupancy model from first principles as a finite-state Markov chain and using it to solve an optimal reserve design problem. This practice bridges theoretical modeling with practical decision-making, challenging you to find the best conservation strategy under a fixed budget.", "problem": "You are asked to formalize and solve an optimization problem for a discrete-time, stochastic, spatially explicit metapopulation on a finite graph. The system is a set of habitat patches represented by nodes, with potential colonization attempts along edges weighted by a distance-dependent kernel. At each time step, occupied patches may go extinct, and empty patches may be colonized by incoming propagules. A reserve network protects a chosen subset of patches by reducing their extinction rates. The goal is to choose which patches to protect, subject to a fixed budget, to maximize the probability that the metapopulation persists (is not globally extinct) at a specified future time point.\n\nModeling assumptions and fundamental base:\n- Let there be $n$ habitat patches (nodes). The occupancy of patch $i$ at discrete time $t$ is a binary random variable $X_i(t) \\in \\{0,1\\}$, with $X_i(t)=1$ meaning occupied and $X_i(t)=0$ meaning empty. The system state is $X(t) = (X_1(t),\\dots,X_n(t)) \\in \\{0,1\\}^n$.\n- Extinction process: For each occupied patch $i$ at time $t$, the event of local extinction by time $t+1$ occurs with probability $e_i'$, where $e_i'$ equals the baseline extinction probability $e_i$ if the patch is not protected and equals the reduced extinction probability $r \\cdot e_i$ if the patch is protected, with $r \\in (0,1)$ a given protection factor.\n- Colonization process: For each empty patch $i$ at time $t$, each occupied donor patch $j \\neq i$ attempts colonization independently with success probability $p_{ji}$, where $p_{ji} = 1 - \\exp(-\\beta K_{ji})$, the dispersal kernel is $K_{ji} = \\exp(-\\alpha d_{ji})$ with $d_{ji}$ the given inter-patch distance, $\\alpha > 0$ the distance-decay parameter, and $\\beta > 0$ the dispersal intensity parameter. There is no self-colonization, so $K_{ii} = 0$. By independence of donor attempts, the probability that patch $i$ is colonized by time $t+1$ given the donor set at time $t$ equals $1 - \\prod_{j: X_j(t)=1, j \\neq i} (1 - p_{ji})$.\n- Conditional independence across recipient patches: Given $X(t)$, transitions for distinct patches are independent. As a result, the occupancy state $X(t)$ forms a finite, time-homogeneous Markov chain (MC) on the state space $\\{0,1\\}^n$, with a transition probability from $x \\in \\{0,1\\}^n$ to $y \\in \\{0,1\\}^n$ equal to the product over $i \\in \\{1,\\dots,n\\}$ of the single-patch transition probabilities implied by the rules above.\n\nObjective definition:\n- For a fixed time horizon $T \\in \\mathbb{N}$ and an initial state $x^{(0)} \\in \\{0,1\\}^n$, let $P_R$ denote the transition kernel when the protected set of patches is $R \\subseteq \\{1,\\dots,n\\}$. Let $\\pi_0$ be the point mass on $x^{(0)}$. Evolve the distribution by $\\pi_{t+1} = \\pi_t P_R$. The persistence-by-time-$T$ probability under protection set $R$ is the probability that the non-extinct region of the state space is reached at time $T$, namely $1 - \\pi_T(\\mathbf{0})$, where $\\mathbf{0}$ is the all-zero vector. Your task is to choose $R$ with $|R| = B$ to maximize this probability.\n- This problem must be solved exactly for the given small graphs by exhaustive search over all size-$B$ subsets.\n\nProgram requirements:\n- Implement the model exactly as described above, explicitly constructing the finite-state Markov chain transition kernel for each protection set $R$, evolving the distribution for exactly $T$ steps from the given initial state $x^{(0)}$, and computing the resulting persistence-by-time-$T$ probability. Then return the maximal probability over all protection sets $R$ of size $B$.\n- The program must not use any randomization. All probabilities must be computed exactly from the model specifications without simulation.\n- All answers must be reported as floating-point numbers rounded to exactly six digits after the decimal point.\n\nAngle units are not used. There are no physical units.\n\nTest suite:\nFor each case, you are given the number of patches $n$, the inter-patch distance matrix $D = (d_{ij})$, the baseline extinction vector $e = (e_1,\\dots,e_n)$, the initial occupancy state $x^{(0)}$, the time horizon $T$, the budget $B$, the protection factor $r$, and the kernel parameters $\\alpha$ and $\\beta$. For the distance matrices, $d_{ii} = 0$ for all $i$, and $d_{ij} = d_{ji} > 0$ for $i \\neq j$. The dispersal kernel is $K_{ji} = \\exp(-\\alpha d_{ji})$ and $p_{ji} = 1 - \\exp(-\\beta K_{ji})$.\n\n- Case A (line graph of four patches):\n  - $n = 4$\n  - $D = \\begin{bmatrix} 0 & 1 & 2 & 3 \\\\ 1 & 0 & 1 & 2 \\\\ 2 & 1 & 0 & 1 \\\\ 3 & 2 & 1 & 0 \\end{bmatrix}$\n  - $e = [\\,0.20,\\,0.25,\\,0.25,\\,0.20\\,]$\n  - $x^{(0)} = [\\,0,\\,1,\\,0,\\,0\\,]$\n  - $T = 5$\n  - $B = 1$\n  - $r = 0.40$\n  - $\\alpha = 1.00$\n  - $\\beta = 0.90$\n\n- Case B (square of four patches at unit spacing):\n  - $n = 4$\n  - $D = \\begin{bmatrix} 0 & 1 & 1.4142135624 & 1 \\\\ 1 & 0 & 1 & 1.4142135624 \\\\ 1.4142135624 & 1 & 0 & 1 \\\\ 1 & 1.4142135624 & 1 & 0 \\end{bmatrix}$\n  - $e = [\\,0.05,\\,0.06,\\,0.05,\\,0.06\\,]$\n  - $x^{(0)} = [\\,1,\\,0,\\,1,\\,0\\,]$\n  - $T = 10$\n  - $B = 2$\n  - $r = 0.50$\n  - $\\alpha = 0.70$\n  - $\\beta = 0.60$\n\n- Case C (no colonization edge case on a line of four patches):\n  - $n = 4$\n  - $D = \\begin{bmatrix} 0 & 1 & 2 & 3 \\\\ 1 & 0 & 1 & 2 \\\\ 2 & 1 & 0 & 1 \\\\ 3 & 2 & 1 & 0 \\end{bmatrix}$\n  - $e = [\\,0.15,\\,0.20,\\,0.18,\\,0.22\\,]$\n  - $x^{(0)} = [\\,1,\\,0,\\,0,\\,1\\,]$\n  - $T = 6$\n  - $B = 1$\n  - $r = 0.30$\n  - $\\alpha = 1.00$\n  - $\\beta = 0.00$\n\n- Case D (star-like geometry with five patches: one center and four leaves):\n  - $n = 5$\n  - $D$ corresponds to coordinates $[\\, (0,0),\\,(1,0),\\,(-1,0),\\,(0,1),\\,(0,-1) \\,]$, i.e., center-leaf distances are $1$, opposite leaves distance is $2$, and orthogonal leaves distance is $\\sqrt{2}$. Numerically,\n    $D = \\begin{bmatrix}\n    0 & 1 & 1 & 1 & 1 \\\\\n    1 & 0 & 2 & 1.4142135624 & 1.4142135624 \\\\\n    1 & 2 & 0 & 1.4142135624 & 1.4142135624 \\\\\n    1 & 1.4142135624 & 1.4142135624 & 0 & 2 \\\\\n    1 & 1.4142135624 & 1.4142135624 & 2 & 0\n    \\end{bmatrix}$\n  - $e = [\\,0.25,\\,0.20,\\,0.20,\\,0.20,\\,0.20\\,]$\n  - $x^{(0)} = [\\,1,\\,0,\\,0,\\,0,\\,0\\,]$\n  - $T = 7$\n  - $B = 1$\n  - $r = 0.30$\n  - $\\alpha = 1.20$\n  - $\\beta = 0.80$\n\nYour program must produce a single line of output containing the four maximal persistence-by-time-$T$ probabilities, in the order A, B, C, D, rounded to six digits after the decimal point, as a comma-separated list enclosed in square brackets. For example, an output could look like \"[0.123456,0.234567,0.345678,0.456789]\" but with the correct values for the test suite above.", "solution": "The problem statement submitted for analysis is subjected to a rigorous validation process.\n\n### Step 1: Extracted Givens\n- **System**: A discrete-time, stochastic, spatially explicit metapopulation model on a graph with $n$ patches (nodes).\n- **State**: The state of patch $i$ at time $t$ is $X_i(t) \\in \\{0, 1\\}$. The system state is $X(t) = (X_1(t), \\dots, X_n(t))$.\n- **Extinction**: An occupied patch $i$ goes extinct with probability $e'_i$. If patch $i$ is in the protected set $R$, $e'_i = r \\cdot e_i$; otherwise, $e'_i = e_i$. $r \\in (0,1)$ is the protection factor.\n- **Colonization**: An empty patch $i$ is colonized by an occupied donor patch $j \\neq i$ with success probability $p_{ji} = 1 - \\exp(-\\beta K_{ji})$. The dispersal kernel is $K_{ji} = \\exp(-\\alpha d_{ji})$, where $d_{ji}$ is the distance between patches, $\\alpha > 0$, and $\\beta > 0$. Self-colonization is forbidden ($K_{ii} = 0$). The total colonization probability for patch $i$ is $C_i(X(t)) = 1 - \\prod_{j: X_j(t)=1, j \\neq i} (1 - p_{ji})$.\n- **Dynamics**: The system is a time-homogeneous Markov chain on the state space $\\{0,1\\}^n$. Transitions for different patches are conditionally independent given the state $X(t)$.\n- **Objective**: Given an initial state $x^{(0)}$, a time horizon $T$, and a budget $B$, choose a protection set $R$ with $|R| = B$ to maximize the persistence probability at time $T$. The persistence probability is $1 - \\pi_T(\\mathbf{0})$, where $\\pi_T$ is the state probability distribution at time $T$ and $\\mathbf{0}$ is the all-empty state.\n- **Method**: The problem is to be solved by exhaustive search over all valid protection sets $R$.\n- **Data**: Specific numerical values for $n$, distance matrix $D$, baseline extinction rates $e$, initial state $x^{(0)}$, time horizon $T$, budget $B$, protection factor $r$, and kernel parameters $\\alpha, \\beta$ are provided for four test cases.\n\n### Step 2: Validation\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded**: The model is a standard stochastic patch occupancy model (SPOM), a cornerstone of metapopulation theory in ecology. The formulation is based on established principles. The problem is scientifically sound.\n- **Well-Posed**: The problem is well-defined. It requires maximizing a clearly specified objective function over a finite set of choices. For any choice, the system's evolution is governed by a well-defined finite-state Markov chain, guaranteeing the existence and uniqueness of the resulting probability distribution. A maximum persistence probability must exist.\n- **Objective**: The problem is specified with precise mathematical definitions and free of ambiguity or subjective language.\n- **Completeness and Consistency**: All parameters and conditions required to construct and solve the model are provided for each test case. There are no contradictions.\n- **Feasibility**: The state space for the given cases ($n=4$ and $n=5$) is small ($2^4=16$ and $2^5=32$ states, respectively), making the construction and analysis of the Markov chain transition matrix computationally feasible, as required.\n\n### Step 3: Verdict\nThe problem is **valid**. A solution will be furnished.\n\n### Solution Derivation\nThe problem is to find an optimal control policy for a discrete-time finite-state Markov chain. The control action is the one-time selection of a permanent set of protected patches.\n\n**State Space**\nThe state space is $S = \\{0, 1\\}^n$, containing $N = 2^n$ possible states. We can establish a bijective mapping between a state vector $x = (X_1, \\dots, X_n)$ and an integer index $s \\in \\{0, 1, \\dots, N-1\\}$ using the binary representation: $s = \\sum_{i=1}^{n} X_i 2^{i-1}$. Under this mapping, the global extinction state $\\mathbf{0} = (0, \\dots, 0)$ corresponds to index $s=0$.\n\n**Markov Chain Transition Matrix**\nFor a given protection set $R$, the system's evolution is governed by a $N \\times N$ transition matrix $P_R$. The entry $P_R(x, y)$ denotes the probability of transitioning from state $x$ to state $y$ in one time step. Due to the assumption of conditional independence of patch dynamics, this probability is the product of single-patch transition probabilities:\n$$ P_R(x \\rightarrow y) = \\prod_{i=1}^{n} \\text{Pr}(X_i(t+1)=y_i | X(t)=x, R) $$\nThe single-patch transition probability, $\\text{Pr}(X_i(t+1)=y_i | X(t)=x, R)$, is determined as follows:\n1.  **If patch $i$ is occupied ($x_i=1$)**: The patch remains occupied ($y_i=1$) with probability $(1 - e'_i)$ and becomes empty ($y_i=0$) with probability $e'_i$. The effective extinction rate is $e'_i = r \\cdot e_i$ for $i \\in R$ and $e'_i = e_i$ for $i \\notin R$.\n2.  **If patch $i$ is empty ($x_i=0$)**: The patch becomes occupied ($y_i=1$) through colonization with probability $C_i(x)$. It remains empty ($y_i=0$) with probability $(1 - C_i(x))$.\n\nThe colonization probability, $C_i(x)$, for an empty patch $i$ is given by the complementary probability of no colonization from any occupied donor patch $j$:\n$$ C_i(x) = 1 - \\prod_{j: x_j=1} (1 - p_{ji}) $$\nwhere $p_{ji} = 1 - \\exp(-\\beta K_{ji})$ and $K_{ji} = \\exp(-\\alpha d_{ji})$. Note that since $K_{ii}=0$ is specified, the product can be taken over all $j$ where $x_j=1$. This expression is more reliably computed as:\n$$ C_i(x) = 1 - \\exp\\left(-\\beta \\sum_{j: x_j=1} K_{ji}\\right) $$\nThe term $\\sum_{j: x_j=1} K_{ji}$ represents the total colonization pressure on patch $i$ from all occupied patches in state $x$.\n\n**Optimization Algorithm**\nThe objective is to maximize the persistence probability at time $T$, $J(R) = 1 - \\pi_T(\\mathbf{0})$, where $\\pi_T$ is the probability distribution vector at time $T$.\nThe initial distribution, $\\pi_0$, is a vector of length $N=2^n$ with a $1$ at the index corresponding to the initial state $x^{(0)}$ and $0$s elsewhere. The distribution is evolved for $T$ steps using the relation $\\pi_{t+1} = \\pi_t P_R$. This is equivalent to computing $\\pi_T = \\pi_0 (P_R)^T$.\nThe optimization proceeds via exhaustive search:\n1.  Generate all possible protection sets $R \\subseteq \\{1, \\dots, n\\}$ of size $|R|=B$. This constitutes $\\binom{n}{B}$ combinations.\n2.  For each candidate set $R$:\n    a. Construct the $2^n \\times 2^n$ transition matrix $P_R$ based on the rules derived above.\n    b. Initialize the probability distribution vector $\\pi_0$ based on $x^{(0)}$.\n    c. Compute the distribution at time $T$ by iterating $\\pi_{t+1} = \\pi_t P_R$ for $T$ steps.\n    d. Calculate the persistence probability $J(R) = 1 - \\pi_T(0)$, where $\\pi_T(0)$ is the probability of the state with index $s=0$.\n3.  The solution is the maximum value of $J(R)$ found across all candidate sets. This procedure yields the exact optimal value under the model assumptions.", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the metapopulation persistence optimization problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            \"n\": 4,\n            \"D\": np.array([\n                [0, 1, 2, 3],\n                [1, 0, 1, 2],\n                [2, 1, 0, 1],\n                [3, 2, 1, 0]\n            ], dtype=float),\n            \"e\": np.array([0.20, 0.25, 0.25, 0.20]),\n            \"x0\": np.array([0, 1, 0, 0]),\n            \"T\": 5, \"B\": 1, \"r\": 0.40, \"alpha\": 1.00, \"beta\": 0.90\n        },\n        # Case B\n        {\n            \"n\": 4,\n            \"D\": np.array([\n                [0, 1, 1.4142135624, 1],\n                [1, 0, 1, 1.4142135624],\n                [1.4142135624, 1, 0, 1],\n                [1, 1.4142135624, 1, 0]\n            ], dtype=float),\n            \"e\": np.array([0.05, 0.06, 0.05, 0.06]),\n            \"x0\": np.array([1, 0, 1, 0]),\n            \"T\": 10, \"B\": 2, \"r\": 0.50, \"alpha\": 0.70, \"beta\": 0.60\n        },\n        # Case C\n        {\n            \"n\": 4,\n            \"D\": np.array([\n                [0, 1, 2, 3],\n                [1, 0, 1, 2],\n                [2, 1, 0, 1],\n                [3, 2, 1, 0]\n            ], dtype=float),\n            \"e\": np.array([0.15, 0.20, 0.18, 0.22]),\n            \"x0\": np.array([1, 0, 0, 1]),\n            \"T\": 6, \"B\": 1, \"r\": 0.30, \"alpha\": 1.00, \"beta\": 0.00\n        },\n        # Case D\n        {\n            \"n\": 5,\n            \"D\": np.array([\n                [0, 1, 1, 1, 1],\n                [1, 0, 2, 1.4142135624, 1.4142135624],\n                [1, 2, 0, 1.4142135624, 1.4142135624],\n                [1, 1.4142135624, 1.4142135624, 0, 2],\n                [1, 1.4142135624, 1.4142135624, 2, 0]\n            ], dtype=float),\n            \"e\": np.array([0.25, 0.20, 0.20, 0.20, 0.20]),\n            \"x0\": np.array([1, 0, 0, 0, 0]),\n            \"T\": 7, \"B\": 1, \"r\": 0.30, \"alpha\": 1.20, \"beta\": 0.80\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        n, D, e, x0, T, B = case[\"n\"], case[\"D\"], case[\"e\"], case[\"x0\"], case[\"T\"], case[\"B\"]\n        r, alpha, beta = case[\"r\"], case[\"alpha\"], case[\"beta\"]\n\n        patch_indices = range(n)\n        possible_protections = combinations(patch_indices, B)\n        \n        K_matrix = np.exp(-alpha * D)\n        np.fill_diagonal(K_matrix, 0)\n        \n        num_states = 2**n\n        \n        # Pre-calculate state vectors\n        state_vectors = []\n        for s in range(num_states):\n            state_vectors.append(np.array([(s >> i) & 1 for i in range(n)]))\n\n        max_persistence_prob = 0.0\n\n        for R in possible_protections:\n            # 1. Determine effective extinction rates for this protection set R\n            e_prime = e.copy()\n            for protected_idx in R:\n                e_prime[protected_idx] *= r\n\n            # 2. Build the transition matrix P_R\n            P_matrix = np.zeros((num_states, num_states))\n            for s_from in range(num_states):\n                x = state_vectors[s_from]\n                \n                # Colonization probabilities for empty patches\n                # Colonization pressure on patch i is sum_j K_ij*x_j\n                # As K is symmetric, this is sum_j K_ji*x_j\n                colonization_pressure = K_matrix @ x\n                C_i_of_x = 1 - np.exp(-beta * colonization_pressure)\n                \n                for s_to in range(num_states):\n                    y = state_vectors[s_to]\n                    \n                    prob_x_to_y = 1.0\n                    for i in range(n):\n                        if x[i] == 1:\n                            prob_i = (1 - e_prime[i]) if y[i] == 1 else e_prime[i]\n                        else:  # x[i] == 0\n                            prob_i = C_i_of_x[i] if y[i] == 1 else (1 - C_i_of_x[i])\n                        prob_x_to_y *= prob_i\n                    \n                    P_matrix[s_from, s_to] = prob_x_to_y\n            \n            # 3. Evolve the distribution starting from x0\n            s0_idx = sum(val * (1 << i) for i, val in enumerate(x0))\n            \n            pi = np.zeros(num_states)\n            pi[s0_idx] = 1.0\n            \n            for _ in range(T):\n                pi = pi @ P_matrix\n                \n            # 4. Calculate persistence probability\n            persistence_prob = 1.0 - pi[0]  # State 0 is global extinction\n            if persistence_prob > max_persistence_prob:\n                max_persistence_prob = persistence_prob\n        \n        results.append(f\"{max_persistence_prob:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2534612"}]}