{"hands_on_practices": [{"introduction": "The heart of evolutionary theory on family life is parent-offspring conflict. This conflict arises because parents are equally related to all their offspring, while each offspring is more related to itself than to its past or future siblings. This asymmetry in genetic interests naturally leads to a clash over the optimal amount of parental investment. This exercise provides a hands-on application of inclusive fitness theory to quantify this very conflict, allowing you to use the tools of calculus to make an abstract evolutionary concept precise and tangible [@problem_id:2517971].", "problem": "Consider a single bout of parental provisioning in a diploid species where a parent allocates a nonnegative amount of investment $I \\ge 0$ to a focal offspring. Let the offspring’s fitness benefit from investment be $B(I) = b_0 \\ln(1 + a I)$ with $b_0  0$ and $a  0$, and let the parental fitness cost be $C(I) = c I$ with $c  0$. Assume a classical parent–offspring conflict framework in which the parent maximizes inclusive fitness $W_P(I) = r B(I) - C(I)$ and the offspring’s preferred provisioning level corresponds to the level that would maximize $W_O(I) = B(I) - C(I)$ if it could unilaterally determine $I$, where $r$ is the diploid parent–offspring relatedness. Take $r = \\tfrac{1}{2}$. Assume $I$ is constrained to be nonnegative, and if the unconstrained optimum is negative, the constrained optimum is $I = 0$.\n\nStarting from the definitions of inclusive fitness and marginal optimization (first-order and second-order conditions), derive the interior optima and the parameter conditions under which they are positive. When the interior optima are positive, compute the parent-preferred investment $I_P$ and the offspring-preferred investment $I_O$ in closed form in terms of $a$, $b_0$, and $c$. Express your final answer as the ordered pair $(I_P, I_O)$ as exact analytic expressions. No numerical rounding is required, and no units are required for $I$.", "solution": "The problem statement is first subjected to a rigorous validation process.\n\nStep 1: Extract Givens.\nThe provided information is as follows:\n- Investment level: $I \\ge 0$.\n- Offspring fitness benefit function: $B(I) = b_0 \\ln(1 + a I)$, with parameters $b_0  0$ and $a  0$.\n- Parental fitness cost function: $C(I) = c I$, with parameter $c  0$.\n- Parent's inclusive fitness function: $W_P(I) = r B(I) - C(I)$.\n- Offspring's preferred provisioning-level fitness function: $W_O(I) = B(I) - C(I)$.\n- Parent-offspring relatedness for a diploid species: $r = \\frac{1}{2}$.\n- Constraint: If an unconstrained optimum is negative, the constrained optimum is $I = 0$.\n- Objective: Derive the parent-preferred investment $I_P$ and offspring-preferred investment $I_O$ as closed-form interior optima, and present the answer as the ordered pair $(I_P, I_O)$.\n\nStep 2: Validate Using Extracted Givens.\nThe problem is a standard exercise in behavioral ecology, specifically applying Hamilton's rule and optimization theory to a parent-offspring conflict model.\n- **Scientifically Grounded:** The model is based on established principles of evolutionary biology, namely inclusive fitness theory. The use of a logarithmic benefit function represents diminishing returns to investment, a common and realistic assumption. The linear cost function is a standard simplification. The value $r = \\frac{1}{2}$ for diploid parent-offspring relatedness is correct. The problem is scientifically sound.\n- **Well-Posed:** The problem provides two well-defined, continuous, and twice-differentiable objective functions, $W_P(I)$ and $W_O(I)$, to be maximized over the domain $I \\ge 0$. The structure guarantees that a unique maximum exists for each case.\n- **Objective:** The problem is stated in precise mathematical language, free of ambiguity or subjective claims.\n\nStep 3: Verdict and Action.\nThe problem is deemed valid. It is self-contained, consistent, and grounded in established scientific and mathematical principles. A solution will be derived.\n\nThe methodology is optimization using differential calculus. We seek to find the values of $I$ that maximize the parent's inclusive fitness, $W_P(I)$, and the offspring's fitness, $W_O(I)$, respectively. These are denoted $I_P$ and $I_O$.\n\nFirst, we determine the parent-preferred investment, $I_P$.\nThe parent's inclusive fitness function is:\n$$W_P(I) = r B(I) - C(I) = \\frac{1}{2} b_0 \\ln(1 + a I) - c I$$\nTo find the maximum, we compute the first derivative with respect to $I$ and set it to zero. This is the first-order condition for an interior optimum.\n$$\\frac{dW_P}{dI} = \\frac{d}{dI} \\left( \\frac{1}{2} b_0 \\ln(1 + a I) - c I \\right) = \\frac{1}{2} b_0 \\frac{a}{1 + a I} - c$$\nSetting the derivative to zero yields:\n$$\\frac{a b_0}{2(1 + a I)} - c = 0$$\n$$\\frac{a b_0}{2c} = 1 + a I$$\n$$a I = \\frac{a b_0}{2c} - 1$$\n$$I_P = \\frac{1}{a} \\left( \\frac{a b_0}{2c} - 1 \\right) = \\frac{b_0}{2c} - \\frac{1}{a}$$\nThis is the candidate for the interior optimum. To confirm it is a maximum, we check the second-order condition. The second derivative must be negative.\n$$\\frac{d^2W_P}{dI^2} = \\frac{d}{dI} \\left( \\frac{a b_0}{2} (1 + a I)^{-1} - c \\right) = -\\frac{a b_0}{2} (1 + a I)^{-2} (a) = -\\frac{a^2 b_0}{2(1 + a I)^2}$$\nGiven that $a  0$ and $b_0  0$, the numerator $a^2 b_0$ is positive. The denominator $2(1+aI)^2$ is also positive for $I \\ge 0$. Therefore, $\\frac{d^2W_P}{dI^2}  0$, which confirms that the critical point is a local maximum.\nThe problem requires an interior optimum, which means $I_P  0$. The condition for this is:\n$$\\frac{b_0}{2c} - \\frac{1}{a}  0 \\implies \\frac{b_0}{2c}  \\frac{1}{a} \\implies a b_0  2c$$\nIf $a b_0 \\le 2c$, the marginal benefit at $I=0$ is non-positive, and the optimal investment is the corner solution $I_P=0$. The problem asks for the interior optimum, which is the expression derived above under the condition it is positive.\n\nNext, we determine the offspring-preferred investment, $I_O$.\nThe offspring's fitness function is:\n$$W_O(I) = B(I) - C(I) = b_0 \\ln(1 + a I) - c I$$\nNote that the cost $C(I)$ is the cost to the parent, but it affects the offspring's inclusive fitness through its impact on the parent's future reproductive success, which involves siblings to which the focal offspring is related. The function $W_O(I)$ represents the offspring's evolutionary interest, where it devalues the cost to the parent by a factor of its relatedness to the parent, not by its relatedness to itself ($1$).\nThe problem statement defines $W_O(I) = B(I) - C(I)$, which implies the offspring values the cost to the parent's fitness equally to the benefit to its own fitness. This represents the extreme of the conflict.\nWe find the first derivative with respect to $I$:\n$$\\frac{dW_O}{dI} = \\frac{d}{dI} \\left( b_0 \\ln(1 + a I) - c I \\right) = b_0 \\frac{a}{1 + a I} - c$$\nSetting the derivative to zero for the first-order condition:\n$$\\frac{a b_0}{1 + a I} - c = 0$$\n$$\\frac{a b_0}{c} = 1 + a I$$\n$$a I = \\frac{a b_0}{c} - 1$$\n$$I_O = \\frac{1}{a} \\left( \\frac{a b_0}{c} - 1 \\right) = \\frac{b_0}{c} - \\frac{1}{a}$$\nWe check the second-order condition:\n$$\\frac{d^2W_O}{dI^2} = \\frac{d}{dI} \\left( a b_0 (1 + a I)^{-1} - c \\right) = -a b_0 (1 + a I)^{-2} (a) = -\\frac{a^2 b_0}{(1 + a I)^2}$$\nSince $a  0$ and $b_0  0$, we have $\\frac{d^2W_O}{dI^2}  0$, confirming a local maximum.\nThe condition for an interior optimum, $I_O  0$, is:\n$$\\frac{b_0}{c} - \\frac{1}{a}  0 \\implies \\frac{b_0}{c}  \\frac{1}{a} \\implies a b_0  c$$\nThe problem asks for the closed-form expressions for the positive interior optima. Thus, the expressions for $I_P$ and $I_O$ are valid when the respective conditions ($a b_0  2c$ and $a b_0  c$) are met. The condition for $I_P0$ is stricter than for $I_O0$. When an interior optimum exists for the parent, one must also exist for the offspring.\n\nThe final answer is the ordered pair $(I_P, I_O)$.\n$$I_P = \\frac{b_0}{2c} - \\frac{1}{a}$$\n$$I_O = \\frac{b_0}{c} - \\frac{1}{a}$$", "answer": "$$\n\\boxed{\n\\left( \\frac{b_0}{2c} - \\frac{1}{a}, \\frac{b_0}{c} - \\frac{1}{a} \\right)\n}\n$$", "id": "2517971"}, {"introduction": "Beyond deciding the total amount to invest, a parent with multiple young faces the challenge of how to allocate that investment. This dilemma is particularly acute in species with mixed paternity, where a caregiver's degree of genetic relatedness can vary significantly across a single brood. This problem applies the principle of constrained optimization to show how a parent should distribute a fixed resource budget to maximize inclusive fitness, balancing the inherent quality of each offspring against its specific genetic value [@problem_id:2517949]. By using the method of Lagrange multipliers, you will solve for the optimal investment in each nestling and directly observe how paternity uncertainty can drive a dramatic, but evolutionarily rational, reallocation of resources.", "problem": "A territorial male bird provides parental care that can be divided among three nestlings. Let $I_i \\ge 0$ denote the care time allocated to nestling $i \\in \\{1,2,3\\}$, and let the total care budget be $I$, so that $\\sum_{i=1}^{3} I_i = I$. The male’s inclusive fitness return from care invested in nestling $i$ is the product of a genetic relatedness coefficient $r_i$ and a diminishing-returns benefit function $B_i(I_i)$. Assume that the fundamental quantities follow these definitions:\n- Inclusive fitness is the sum across recipients of genetic relatedness times recipient fitness effects.\n- Genetic relatedness of a sire to a nestling equals one-half times the sire’s paternity probability for that nestling.\n- Parental care returns are concave in effort due to diminishing returns.\n\nSuppose mixed paternity yields paternity probabilities $p_1 = 1$, $p_2 = 0.6$, and $p_3 = 0.2$. Hence, the expected relatednesses are $r_i = \\tfrac{1}{2} p_i$, so that $r_1 = 0.5$, $r_2 = 0.3$, and $r_3 = 0.1$. Let the benefit functions be $B_i(I_i) = s_i \\sqrt{I_i}$ with efficiency multipliers $s_1 = 1.0$, $s_2 = 0.8$, and $s_3 = 1.2$. The total available care is $I = 120$ hours.\n\nStarting from the core definitions above and using Lagrange multipliers, derive from first principles the optimal allocation $I_i^{\\ast}$ that maximizes the male’s inclusive fitness $\\sum_{i=1}^{3} r_i B_i(I_i)$ subject to $\\sum_{i=1}^{3} I_i = I$ and $I_i \\ge 0$. Then compute the numerical values of $(I_1^{\\ast}, I_2^{\\ast}, I_3^{\\ast})$ for the given parameters. Finally, analyze how mixed paternity affects $I_i^{\\ast}$ relative to the case of full paternity for all nestlings (that is, $p_i = 1$ for all $i$).\n\nReport your final numerical allocation vector $(I_1^{\\ast}, I_2^{\\ast}, I_3^{\\ast})$ in hours, rounded to four significant figures.", "solution": "The problem posed is a well-defined exercise in constrained optimization, grounded in standard principles of behavioral ecology. It is scientifically sound and internally consistent. We shall therefore proceed to its solution.\n\nThe objective is to maximize the male's total inclusive fitness, $F$, which is the sum of the fitness returns from each of the three nestlings. The fitness return for nestling $i$ is the product of the genetic relatedness, $r_i$, and the benefit function, $B_i(I_i)$. The total inclusive fitness is:\n$$ F(I_1, I_2, I_3) = \\sum_{i=1}^{3} r_i B_i(I_i) $$\nThe investment of care time, $I_i$, must be non-negative, $I_i \\ge 0$, and is subject to a total budget constraint:\n$$ \\sum_{i=1}^{3} I_i = I $$\nGiven the specific forms of the functions and parameters:\n- Paternity probabilities: $p_1 = 1$, $p_2 = 0.6$, $p_3 = 0.2$.\n- Relatedness coefficients: $r_i = \\frac{1}{2} p_i$, so $r_1 = 0.5$, $r_2 = 0.3$, $r_3 = 0.1$.\n- Benefit functions: $B_i(I_i) = s_i \\sqrt{I_i}$.\n- Efficiency multipliers: $s_1 = 1.0$, $s_2 = 0.8$, $s_3 = 1.2$.\n- Total budget: $I = 120$.\n\nThe objective function becomes:\n$$ F(I_1, I_2, I_3) = r_1 s_1 \\sqrt{I_1} + r_2 s_2 \\sqrt{I_2} + r_3 s_3 \\sqrt{I_3} $$\nThis is a problem of maximizing a function subject to an equality constraint and non-negativity constraints. We use the method of Lagrange multipliers. The Lagrangian function, $\\mathcal{L}$, is constructed as:\n$$ \\mathcal{L}(I_1, I_2, I_3, \\lambda) = \\left( \\sum_{i=1}^{3} r_i s_i \\sqrt{I_i} \\right) - \\lambda \\left( \\left( \\sum_{i=1}^{3} I_i \\right) - I \\right) $$\nThe non-negativity constraints $I_i \\ge 0$ must also be considered. The full Karush-Kuhn-Tucker (KKT) conditions would be required if a boundary solution ($I_i=0$ for some $i$) were possible. However, the marginal benefit for nestling $i$ is $\\frac{\\partial (r_i B_i)}{\\partial I_i} = \\frac{r_i s_i}{2\\sqrt{I_i}}$. As $I_i \\to 0^+$, this marginal benefit approaches infinity for any nestling with $r_i s_i  0$. In this problem, all products $r_i s_i$ are positive:\n- $r_1 s_1 = (0.5)(1.0) = 0.5$\n- $r_2 s_2 = (0.3)(0.8) = 0.24$\n- $r_3 s_3 = (0.1)(1.2) = 0.12$\nSince the marginal return is infinite at zero investment, any optimal allocation must have $I_i^{\\ast}  0$ for all $i$. Thus, the non-negativity constraints are not binding, and we can find the optimum by setting the partial derivatives of the Lagrangian with respect to each $I_i$ to zero.\n\nThe first-order conditions for a maximum are:\n$$ \\frac{\\partial \\mathcal{L}}{\\partial I_i} = \\frac{r_i s_i}{2\\sqrt{I_i}} - \\lambda = 0 \\quad \\text{for } i \\in \\{1, 2, 3\\} $$\n$$ \\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = I - \\sum_{i=1}^{3} I_i = 0 $$\nFrom the first condition, we find that at the optimum, the marginal inclusive fitness return from investing in each nestling must be equal to a constant, $\\lambda$:\n$$ \\frac{r_i s_i}{2\\sqrt{I_i}} = \\lambda $$\nSolving for $I_i$ yields its value in terms of the Lagrange multiplier $\\lambda$:\n$$ \\sqrt{I_i} = \\frac{r_i s_i}{2\\lambda} \\implies I_i = \\left(\\frac{r_i s_i}{2\\lambda}\\right)^2 = \\frac{(r_i s_i)^2}{4\\lambda^2} $$\nNow, we substitute this expression for $I_i$ into the budget constraint to find $\\lambda$:\n$$ \\sum_{i=1}^{3} I_i = \\sum_{i=1}^{3} \\frac{(r_i s_i)^2}{4\\lambda^2} = I $$\n$$ \\frac{1}{4\\lambda^2} \\sum_{i=1}^{3} (r_i s_i)^2 = I $$\n$$ 4\\lambda^2 = \\frac{1}{I} \\sum_{j=1}^{3} (r_j s_j)^2 $$\nSubstituting this back into the expression for $I_i$, we derive the optimal allocation $I_i^{\\ast}$ for each nestling:\n$$ I_i^{\\ast} = \\frac{(r_i s_i)^2}{ \\frac{1}{I} \\sum_{j=1}^{3} (r_j s_j)^2 } = I \\cdot \\frac{(r_i s_i)^2}{\\sum_{j=1}^{3} (r_j s_j)^2} $$\nThis is the general solution. It shows that the optimal investment in nestling $i$ is proportional to the total budget $I$ and to the square of its effective quality, $(r_i s_i)^2$, relative to the sum of squares for all nestlings.\n\nWe now compute the numerical values for the specific mixed-paternity case. First, calculate the squared effective qualities:\n- $(r_1 s_1)^2 = (0.5)^2 = 0.25$\n- $(r_2 s_2)^2 = (0.24)^2 = 0.0576$\n- $(r_3 s_3)^2 = (0.12)^2 = 0.0144$\nThe sum is:\n$$ \\sum_{j=1}^{3} (r_j s_j)^2 = 0.25 + 0.0576 + 0.0144 = 0.322 $$\nWith a total budget of $I=120$ hours, the optimal allocations are:\n$$ I_1^{\\ast} = 120 \\cdot \\frac{0.25}{0.322} \\approx 93.1677 \\text{ hours} $$\n$$ I_2^{\\ast} = 120 \\cdot \\frac{0.0576}{0.322} \\approx 21.4658 \\text{ hours} $$\n$$ I_3^{\\ast} = 120 \\cdot \\frac{0.0144}{0.322} \\approx 5.3665 \\text{ hours} $$\nFinally, we analyze the effect of mixed paternity by comparing this allocation to the hypothetical case of full paternity, where $p_i = 1$ and thus $r_i = 0.5$ for all $i$.\nIn the full paternity scenario, the effective qualities are:\n- $r_1 s_1 = (0.5)(1.0) = 0.5$\n- $r_2 s_2 = (0.5)(0.8) = 0.4$\n- $r_3 s_3 = (0.5)(1.2) = 0.6$\nThe squared effective qualities are:\n- $(r_1 s_1)^2 = 0.25$\n- $(r_2 s_2)^2 = 0.16$\n- $(r_3 s_3)^2 = 0.36$\nThe sum is $\\sum_{j=1}^{3} (r_j s_j)^2 = 0.25 + 0.16 + 0.36 = 0.77$.\nThe optimal allocations under full paternity would be:\n$$ I_{1, \\text{full}}^{\\ast} = 120 \\cdot \\frac{0.25}{0.77} \\approx 38.96 \\text{ hours} $$\n$$ I_{2, \\text{full}}^{\\ast} = 120 \\cdot \\frac{0.16}{0.77} \\approx 24.94 \\text{ hours} $$\n$$ I_{3, \\text{full}}^{\\ast} = 120 \\cdot \\frac{0.36}{0.77} \\approx 56.10 \\text{ hours} $$\nComparing the allocations:\n- Mixed Paternity: $(I_1^{\\ast}, I_2^{\\ast}, I_3^{\\ast}) \\approx (93.17, 21.47, 5.367)$\n- Full Paternity: $(I_{1, \\text{full}}^{\\ast}, I_{2, \\text{full}}^{\\ast}, I_{3, \\text{full}}^{\\ast}) \\approx (38.96, 24.94, 56.10)$\nThe analysis is clear. The uncertainty of paternity for nestlings $2$ and $3$ causes a dramatic reallocation of parental care. Investment in the nestling of certain paternity ($I_1^{\\ast}$) more than doubles, increasing from approximately $39$ hours to $93$ hours. Conversely, investment in the nestlings of uncertain paternity plummets. Investment in nestling $3$ (lowest paternity) decreases by a factor of ten, from $56$ hours to just over $5$ hours. Investment in nestling $2$ (intermediate paternity) also decreases. The male bird concentrates his limited resources on the offspring that provides the highest inclusive fitness return, which is determined by the combined effect of genetic relatedness ($r_i$) and conversion efficiency ($s_i$). Reduced paternity sharply devalues a nestling in the male's fitness calculation, causing a rational shift of investment toward his own genetic issue.\n\nRounding the results for the mixed-paternity case to four significant figures as required: $I_1^{\\ast} = 93.17$, $I_2^{\\ast} = 21.47$, and $I_3^{\\ast} = 5.367$.", "answer": "$$\n\\boxed{\\left( 93.17, 21.47, 5.367 \\right)}\n$$", "id": "2517949"}, {"introduction": "Parental investment decisions are rarely one-shot events; rather, they are sequential choices made over an entire breeding season. A parent must constantly balance the immediate benefits of provisioning current offspring against the need to save energy for its own survival and future reproductive opportunities. This complex trade-off between current and future reproduction is best analyzed using the framework of dynamic programming, a powerful technique for finding optimal state-dependent strategies over time [@problem_id:2517947]. This computational exercise challenges you to implement a backward induction algorithm, providing a deeper appreciation for the forward-looking logic that shapes life-history strategies.", "problem": "Consider an energetics-based parental provisioning problem over a finite breeding season with discrete time periods indexed by $t \\in \\{0,1,\\dots,T-1\\}$. The parent has an energy storage state $S_t$ (in kilojoules), receives exogenous energy input $I_t$ (in kilojoules) each period from foraging opportunities, and allocates $C_t$ (in kilojoules) to provisioning of offspring. The storage state evolves according to the material balance\n$$\nS_{t+1} = S_t + I_t - C_t,\n$$\nwith the feasibility constraints $S_t \\ge 0$ and $C_t \\ge 0$ for all $t$. The initial storage $S_0$ is given. The objective is to maximize the discounted sum of per-period reproductive gains from provisioning plus a terminal survival/reproductive value of end-of-season reserves. Specifically, assume per-period reproductive gain\n$$\nf(C_t) = \\alpha \\,\\log(1 + C_t),\n$$\nwhere $\\log(\\cdot)$ denotes the natural logarithm and $\\alpha  0$ captures the marginal benefit scale, and a terminal value\n$$\ng(S_T) = \\gamma \\,\\sqrt{S_T},\n$$\nwith $\\gamma  0$. The parent chooses a feasible sequence $\\{C_t\\}_{t=0}^{T-1}$ to maximize\n$$\n\\max_{\\{C_t\\}} \\quad \\sum_{t=0}^{T-1} \\beta^t f(C_t) + \\beta^T g(S_T),\n$$\nsubject to the storage dynamics and nonnegativity constraints above, where $0  \\beta \\le 1$ is the intertemporal discount factor. The ecological interpretation is that $f(C_t)$ captures diminishing returns to current offspring provisioning, and $g(S_T)$ captures future survival or residual reproductive value from end-of-season reserves, both standard in life-history theory.\n\nYour task is to derive from first principles the dynamic programming recursion and implement a numerical algorithm that computes an approximately optimal provisioning policy $\\pi_t(S)$ mapping any storage $S$ at time $t$ to an action $C_t$, using a discretized state-action space and linear interpolation of continuation values. Assume the following modeling and numerical conditions hold:\n- The Principle of Optimality applies, so a Bellman equation exists and the value functions are well-defined for the finite horizon.\n- The functions $f(\\cdot)$ and $g(\\cdot)$ are concave and increasing on their domains, and the feasible action set at time $t$ given state $S_t$ is $A_t(S_t) = \\{C_t \\in \\mathbb{R}_{\\ge 0} \\,:\\, C_t \\le S_t + I_t\\}$.\n- You must implement backward induction on a uniform grid of storage states. Let the state grid be $\\mathcal{S} = \\{0, \\Delta, 2\\Delta, \\dots, S_{\\max}\\}$, where $S_{\\max} = S_0 + \\sum_{t=0}^{T-1} I_t$, and $\\Delta  0$ is a specified grid step. For each state $S \\in \\mathcal{S}$ and time $t$, enumerate feasible actions on the uniform action grid $\\{0, \\Delta, 2\\Delta, \\dots, \\lfloor (S+I_t)/\\Delta \\rfloor \\Delta\\}$, and evaluate the Bellman operator using linear interpolation in $S$ for off-grid $S_{t+1}$ values.\n- Break ties deterministically by selecting the smallest $C_t$ among those that achieve the maximal value to within numerical tolerance.\n\nAfter computing the policy by backward induction, simulate the optimal provisioning sequence from the given initial condition $S_0$ using the policy and the realized $I_t$ path, selecting for each period the policy action associated with the nearest state-grid node to the current $S_t$ and then updating $S_{t+1}$ exactly from the storage balance.\n\nAnswer all provisioning values $C_t$ in kilojoules (kJ) and round each to three decimal places. Angles are not involved. Do not include unit strings in the printed output.\n\nTest Suite:\nProvide results for the following five cases, each specified by a tuple $(T,\\beta,\\alpha,\\gamma,S_0,\\{I_t\\}_{t=0}^{T-1},\\Delta)$.\n\n- Case A (happy path): $(3,\\, 0.95,\\, 2.0,\\, 1.0,\\, 5.0,\\, \\{2.0,\\, 1.0,\\, 0.5\\},\\, 0.5)$.\n- Case B (high terminal value, encourages saving): $(3,\\, 0.97,\\, 1.5,\\, 4.0,\\, 3.0,\\, \\{1.5,\\, 0.5,\\, 0.5\\},\\, 0.5)$.\n- Case C (no income, storage only): $(3,\\, 0.90,\\, 2.5,\\, 0.5,\\, 3.0,\\, \\{0.0,\\, 0.0,\\, 0.0\\},\\, 0.5)$.\n- Case D (present-biased, large early input): $(3,\\, 0.50,\\, 2.0,\\, 1.0,\\, 4.0,\\, \\{3.0,\\, 0.0,\\, 0.0\\},\\, 0.5)$.\n- Case E (one-period horizon boundary): $(1,\\, 0.95,\\, 2.0,\\, 2.0,\\, 2.0,\\, \\{1.0\\},\\, 0.5)$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list $[C_0,\\dots,C_{T-1}]$ of the computed optimal provisioning sequence for the corresponding test case, with each number rounded to three decimal places, for example: $[[c_{0}^{(A)},c_{1}^{(A)},c_{2}^{(A)}],[c_{0}^{(B)},\\dots],\\dots]$.", "solution": "The problem posed is a finite-horizon discrete-time optimal control problem, which falls squarely within the domain of dynamic programming. The objective is to determine an optimal provisioning policy $\\{C_t\\}_{t=0}^{T-1}$ that maximizes a discounted sum of rewards, subject to a linear state-space model representing energy storage dynamics. The problem is well-posed and scientifically grounded in the principles of life-history theory. The solution is derived by applying the Principle of Optimality, which allows us to formulate a Bellman equation and solve it numerically using backward induction.\n\nLet $V_t(S)$ be the optimal value of the objective function from time $t$ to the end of the horizon $T$, given that the system is in state $S_t = S$. The value function is defined over the discounted sum of future gains, normalized to the start of period $t$. The Bellman equation for this problem is:\n$$\nV_t(S) = \\max_{C_t \\in A_t(S)} \\left\\{ f(C_t) + \\beta V_{t+1}(S_{t+1}) \\right\\}\n$$\nfor time periods $t \\in \\{0, 1, \\dots, T-1\\}$, where $S_{t+1} = S + I_t - C_t$. The feasible action set is $A_t(S) = \\{C_t \\in \\mathbb{R}_{\\ge 0} \\,|\\, C_t \\le S + I_t\\}$. The terminal condition at time $T$ is given by the terminal value function:\n$$\nV_T(S) = g(S) = \\gamma \\sqrt{S}\n$$\nThe per-period reward function is $f(C_t) = \\alpha \\log(1 + C_t)$. The concavity of $f(\\cdot)$ and $g(\\cdot)$ ensures that for each time step $t$, the value function $V_t(S)$ is also concave in $S$, which guarantees that the maximization problem within the Bellman equation is well-behaved.\n\nThe analytical solution to this problem is generally intractable. Therefore, we will implement the specified numerical algorithm based on backward induction over a discretized state space.\n\n**1. Discretization and Initialization:**\nFirst, we discretize the continuous state space. The state variable $S_t$ can range from $0$ to a maximum possible value of $S_{\\max} = S_0 + \\sum_{t=0}^{T-1} I_t$. We construct a uniform state grid $\\mathcal{S} = \\{0, \\Delta, 2\\Delta, \\dots, N_S\\Delta\\}$, where $N_S\\Delta$ is the smallest grid point greater than or equal to $S_{\\max}$. We will store the value function $V_t(S)$ as an array of values corresponding to each point $S \\in \\mathcal{S}$. We also initialize a policy matrix $\\Pi$ of size $T \\times |\\mathcal{S}|$ to store the optimal action $\\pi_t(S)$ for each state-time pair $(S, t)$.\n\n**2. Backward Induction:**\nThe core of the algorithm is a backward loop in time, from $t=T-1$ down to $t=0$.\n\n- **Terminal Step ($t=T$):** We begin by computing the terminal value function $V_T(S)$ for all states $S \\in \\mathcal{S}$. This is directly given by $V_T(S_i) = g(S_i) = \\gamma\\sqrt{S_i}$, where $S_i$ are the points on our state grid. This array of values represents the continuation value for the final decision period.\n\n- **Recursive Step ($t = T-1, \\dots, 0$):** For each time step $t$, we compute the value function $V_t(S)$ and the optimal policy $\\pi_t(S)$ for every state $S$ on the grid.\n    - For a given state $S_i \\in \\mathcal{S}$, we enumerate all feasible actions. The problem specifies an action grid $\\{0, \\Delta, 2\\Delta, \\dots, \\lfloor (S_i+I_t)/\\Delta \\rfloor \\Delta\\}$.\n    - For each candidate action $C_k$ on this grid, we compute the right-hand side of the Bellman equation, which we denote as the Q-value: $Q_t(S_i, C_k) = f(C_k) + \\beta V_{t+1}(S_i + I_t - C_k)$.\n    - The next state, $S_{t+1} = S_i + I_t - C_k$, will not generally fall on a grid point. We must therefore evaluate $V_{t+1}(S_{t+1})$ using linear interpolation on the previously computed value function array for time $t+1$. Given $S_{t+1}$, we find the two adjacent grid points $S_{low}$ and $S_{high}$ and compute $V_{t+1}(S_{t+1})$ as a weighted average of $V_{t+1}(S_{low})$ and $V_{t+1}(S_{high})$.\n    - After evaluating the Q-value for all feasible actions $C_k$, we find the maximum value, $V_t(S_i) = \\max_{k} Q_t(S_i, C_k)$.\n    - The optimal action, $\\pi_t(S_i)$, is the action $C_k$ that yields this maximum value. To handle ties, we select the smallest action $C_k$ that achieves the maximum Q-value, adhering to the problem specification.\n    - We store the computed $V_t(S_i)$ and $\\pi_t(S_i)$ and proceed to the next state on the grid. After all states are processed for time $t$, we move to time $t-1$, using the newly computed $V_t$ array as the continuation value function.\n\n**3. Forward Simulation:**\nOnce the backward induction is complete, we have a complete policy map $\\Pi = \\{\\pi_t(S)\\}_{t=0, S\\in\\mathcal{S}}^{T-1}$. We then simulate the system's trajectory forward in time, starting from the given initial state $S_0$.\n\n- For each time period $t = 0, 1, \\dots, T-1$:\n    - The current state $S_t$ may not be on the grid. We find the nearest grid point, $S_{grid} \\in \\mathcal{S}$, to $S_t$.\n    - We retrieve the optimal action from our computed policy: $C_t = \\pi_t(S_{grid})$.\n    - This $C_t$ is recorded as part of the optimal provisioning sequence.\n    - The state is updated for the next period using the exact dynamics: $S_{t+1} = S_t + I_t - C_t$. This process is repeated until $t=T-1$.\n\nThis procedure yields the approximately optimal sequence of provisioning actions $\\{C_0, C_1, \\dots, C_{T-1}\\}$ for the given initial conditions and exogenous inputs. The entire process is repeated for each of the five test cases provided.```python\nimport numpy as np\n\ndef solve_case(T, beta, alpha, gamma, S0, I_t, Delta):\n    \"\"\"\n    Solves a single instance of the parental provisioning dynamic programming problem.\n    \"\"\"\n\n    # 1. Initialization\n    S_max = S0 + sum(I_t)\n    # Ensure the state grid covers S_max and its points are multiples of Delta\n    # using a small tolerance for floating point comparisons.\n    S_max_grid = np.ceil(S_max / Delta) * Delta\n    state_grid = np.arange(0, S_max_grid + 1e-9, Delta)\n    num_states = len(state_grid)\n\n    policy = np.zeros((T, num_states))\n\n    # Define utility functions\n    f = lambda C: alpha * np.log(1 + C)\n    # Ensure S is non-negative for sqrt\n    g = lambda S: gamma * np.sqrt(np.maximum(0, S))\n\n    # 2. Backward Induction\n    # At time T, the value is just the terminal value function g(S_T)\n    V_next = g(state_grid)\n\n    # Loop backwards from t = T-1 down to 0\n    for t in range(T - 1, -1, -1):\n        V_current = np.zeros(num_states)\n        \n        # Iterate over each possible state S in the state grid\n        for i, S in enumerate(state_grid):\n            resources = S + I_t[t]\n            if resources  0: resources = 0\n\n            # Define the discrete action grid for the current state S\n            max_C_val = np.floor(resources / Delta) * Delta\n            if max_C_val  0:\n                action_grid = np.array([0.0])\n            else:\n                num_actions = int(round(max_C_val / Delta)) + 1\n                action_grid = np.linspace(0, max_C_val, num_actions)\n\n            # Vectorized calculation of Q-values\n            S_next = S + I_t[t] - action_grid\n            # Enforce non-negativity of next state\n            S_next = np.maximum(0, S_next)\n\n            # Interpolate the value function at the next states\n            V_next_interp = np.interp(S_next, state_grid, V_next)\n\n            # Calculate Q-values for all actions\n            q_values = f(action_grid) + beta * V_next_interp\n            \n            # Find the best action according to the tie-breaking rule\n            # (smallest C among those achieving the maximal value)\n            if len(q_values) > 0:\n                max_q = np.max(q_values)\n                # Find the first index corresponding to the max value\n                best_action_idx = np.where(np.isclose(q_values, max_q))[0][0]\n                best_action = action_grid[best_action_idx]\n                \n                policy[t, i] = best_action\n                V_current[i] = max_q\n            else:\n                # No feasible action other than C=0 (if resources=0)\n                policy[t, i] = 0.0\n                # Value is determined by C=0 and subsequent optimal path\n                S_next_zero_C = S + I_t[t]\n                V_next_interp_zero_C = np.interp(S_next_zero_C, state_grid, V_next)\n                V_current[i] = f(0.0) + beta * V_next_interp_zero_C\n\n        # Move to the next step of the recursion\n        V_next = V_current\n\n    # 3. Forward Simulation\n    optimal_C = []\n    S_current = S0\n    for t in range(T):\n        # Find the nearest state grid index for the current state\n        s_idx = int(np.round(S_current / Delta))\n        # Clip the index to be within the valid range of the policy table\n        s_idx = np.clip(s_idx, 0, num_states - 1)\n        \n        # Get the optimal action from the computed policy\n        C_t = policy[t, s_idx]\n        optimal_C.append(C_t)\n        \n        # Update the state using the exact dynamics\n        S_current = S_current + I_t[t] - C_t\n        # Enforce non-negativity of state\n        S_current = np.maximum(0, S_current)\n\n    return optimal_C\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # (T, beta, alpha, gamma, S0, {I_t}, Delta)\n        (3, 0.95, 2.0, 1.0, 5.0, [2.0, 1.0, 0.5], 0.5), # Case A\n        (3, 0.97, 1.5, 4.0, 3.0, [1.5, 0.5, 0.5], 0.5), # Case B\n        (3, 0.90, 2.5, 0.5, 3.0, [0.0, 0.0, 0.0], 0.5), # Case C\n        (3, 0.50, 2.0, 1.0, 4.0, [3.0, 0.0, 0.0], 0.5), # Case D\n        (1, 0.95, 2.0, 2.0, 2.0, [1.0], 0.5),             # Case E\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        all_results.append(result)\n\n    # Format the output string as per requirements\n    formatted_cases = []\n    for case_result in all_results:\n        # Format each number to exactly three decimal places\n        formatted_nums = [f\"{num:.3f}\" for num in case_result]\n        # Join numbers into a string representation of a list\n        formatted_cases.append(f\"[{','.join(formatted_nums)}]\")\n    \n    # Join all case strings into the final output format\n    final_output = f\"[{','.join(formatted_cases)}]\"\n    print(final_output)\n\nsolve()\n```", "answer": "[[2.500,2.000,2.500],[0.500,1.000,1.500],[1.500,1.000,0.500],[5.500,0.000,0.000],[1.000]]", "id": "2517947"}]}