{"hands_on_practices": [{"introduction": "Regeneration, at its core, involves the massive proliferation of cells to rebuild lost tissue. Before delving into the complex signals that orchestrate this process, we can ask a fundamental quantitative question: how fast must these cells divide? This exercise [@problem_id:2607001] guides you through a \"back-of-the-envelope\" calculation using a simple exponential growth model to estimate the population doubling time in a regenerating blastema. This practice is invaluable for developing an intuition for biological timescales and for learning to critically evaluate the results of a simplified model against real-world biological constraints.", "problem": "A regenerating salamander limb blastema is initially composed of $10^{5}$ proliferative cells. Under a nutrient-replete, growth-factor-rich condition, assume the cell population follows idealized exponential growth driven by a constant per-capita division rate, and that cell loss is negligible over the time window considered. After $7$ days of regeneration, the blastema is measured to contain $10^{7}$ cells. Using only the core definitions of exponential growth and doubling time from population kinetics, derive an expression for the constant doubling time that would exactly achieve this expansion over $7$ days, and then compute its numerical value. Express your final answer in hours (h) and round to $3$ significant figures.\n\nThen, using first principles of cell-cycle control and comparative knowledge of proliferative rates in animal blastemas and plant callus cultures derived from totipotent cells, argue briefly whether the computed rate is biologically plausible, explicitly stating the assumptions under which your judgment holds. Your final reported answer must be only the computed doubling time.", "solution": "The problem requires the calculation of the cell population doubling time in a regenerating salamander limb blastema and a subsequent discussion on the biological plausibility of the result. The analysis will proceed in two stages: first, the mathematical derivation and computation based on the provided data, and second, a critical evaluation of the result based on established principles of cell biology.\n\nLet $N(t)$ be the number of cells at time $t$. The problem states that the cell population follows idealized exponential growth, which is described by the differential equation $\\frac{dN}{dt} = rN$, where $r$ is the constant per-capita division rate. The solution to this equation is:\n$$N(t) = N_0 \\exp(rt)$$\nwhere $N_0$ is the initial cell population at $t=0$.\n\nThe givens are:\nInitial population, $N_0 = 10^5$ cells.\nFinal population, $N(t_f) = 10^7$ cells.\nTime interval, $t_f = 7$ days.\n\nFirst, we must determine the growth rate $r$ from the data.\n$$N(t_f) = N_0 \\exp(r t_f)$$\n$$\\frac{N(t_f)}{N_0} = \\exp(r t_f)$$\nTaking the natural logarithm of both sides:\n$$\\ln\\left(\\frac{N(t_f)}{N_0}\\right) = r t_f$$\n$$r = \\frac{1}{t_f} \\ln\\left(\\frac{N(t_f)}{N_0}\\right)$$\nSubstituting the given values:\n$$r = \\frac{1}{7 \\text{ days}} \\ln\\left(\\frac{10^7}{10^5}\\right) = \\frac{1}{7 \\text{ days}} \\ln(100) = \\frac{2 \\ln(10)}{7 \\text{ days}}$$\n\nNext, we derive the expression for the doubling time, $T_d$. The doubling time is defined as the time required for the population to become twice its initial size, i.e., $N(T_d) = 2N_0$.\n$$2N_0 = N_0 \\exp(r T_d)$$\n$$2 = \\exp(r T_d)$$\n$$\\ln(2) = r T_d$$\n$$T_d = \\frac{\\ln(2)}{r}$$\nThis equation shows that the doubling time is inversely proportional to the growth rate.\n\nNow, we substitute our derived expression for $r$ into the equation for $T_d$:\n$$T_d = \\frac{\\ln(2)}{\\frac{1}{t_f} \\ln\\left(\\frac{N(t_f)}{N_0}\\right)} = t_f \\frac{\\ln(2)}{\\ln\\left(\\frac{N(t_f)}{N_0}\\right)}$$\nUsing the specific values from the problem:\n$$T_d = (7 \\text{ days}) \\frac{\\ln(2)}{\\ln\\left(\\frac{10^7}{10^5}\\right)} = (7 \\text{ days}) \\frac{\\ln(2)}{\\ln(100)} = (7 \\text{ days}) \\frac{\\ln(2)}{2\\ln(10)}$$\nTo obtain a numerical value, we use the standard values for $\\ln(2)$ and $\\ln(10)$:\n$$T_d \\approx (7 \\text{ days}) \\frac{0.6931}{2 \\times 2.3026} \\approx (7 \\text{ days}) \\times 0.1505 \\approx 1.0535 \\text{ days}$$\nThe problem requires the answer in hours, rounded to $3$ significant figures. We convert days to hours:\n$$T_d \\approx 1.0535 \\text{ days} \\times \\frac{24 \\text{ hours}}{1 \\text{ day}} \\approx 25.284 \\text{ hours}$$\nRounding to $3$ significant figures gives:\n$$T_d \\approx 25.3 \\text{ hours}$$\n\nThe second part of the task is to assess the biological plausibility of this result.\nA computed average doubling time of approximately $25.3$ hours for the entire cell population is rapid, but it falls within a plausible biological range for highly proliferative tissues, especially under the idealized conditions specified.\n\n1.  **Comparison with Animal Cell Cycle Times**: The eukaryotic cell cycle duration varies significantly depending on cell type and external conditions. Many standard mammalian cell lines grown in optimal culture conditions (e.g., human fibroblasts, HeLa cells) have doubling times of approximately $24$ hours. The calculated value of $25.3$ hours is therefore very close to the proliferation rates of robust, well-established in vitro systems.\n\n2.  **Context of Regenerative Blastemas**: Salamander blastema cells are known for their high proliferative activity, which fuels the regenerative process. Experimental studies on axolotl (Ambystoma mexicanum) blastemas have reported cell cycle times ranging from $30$ to $60$ hours. Our calculated value of $25.3$ hours is at the faster end of this spectrum. However, the problem specifies a \"nutrient-replete, growth-factor-rich condition\". Such idealized laboratory conditions are designed to maximize cell proliferation, primarily by shortening the G1 phase of the cell cycle. Therefore, observing a population doubling time that is faster than typical in vivo measurements is not unexpected and remains plausible.\n\n3.  **Comparative Biology with Plant Totipotency**: A comparison with plant regenerative systems is also instructive. When plant tissues are cultured to form a callus (a mass of undifferentiated, totipotent cells), they also exhibit rapid proliferation. Depending on the plant species and culture medium, the doubling times for plant callus or cell suspension cultures typically range from $24$ to $72$ hours. The calculated value for the salamander blastema fits comfortably within this range, underscoring that such proliferation rates are a common feature of highly regenerative biological systems across different kingdoms.\n\nIn conclusion, the computed doubling time of $25.3$ hours is biologically plausible. This judgment holds under the explicit assumptions of the problem: a simplified model of pure exponential growth (i.e., negligible cell death, differentiation, or exit from the cell cycle) and an optimally stimulating environment that pushes the proliferative capacity of the cells to its physiological limit. In a real biological system, factors such as cell heterogeneity, contact inhibition, and evolving signaling gradients would introduce complexities not captured by this idealized model.", "answer": "$$\\boxed{25.3}$$", "id": "2607001"}, {"introduction": "Once a pool of proliferative cells is established, how is it organized into a complex, patterned structure like a limb or a plant shoot? The answer often lies in morphogen gradients, signaling molecules whose concentrations vary across space. This exercise [@problem_id:2606968] delves into the physics of this process, using a steady-state reaction-diffusion model to derive the fundamental characteristic length scale of a gradient. By calculating this length, you will gain a concrete understanding of how the interplay between molecular diffusion and degradation dictates the effective range of a developmental signal.", "problem": "In both axolotl limb regeneration and plant callus reprogramming, localized organizers establish morphogen concentration fields that guide patterning. Assume a single morphogen with concentration field $C(\\mathbf{r},t)$ is produced at a localized source and undergoes diffusion with coefficient $D$ and uniform first-order degradation with rate constant $k$. Starting from Fickâ€™s second law augmented by a linear decay term, the governing equation is\n$$\n\\frac{\\partial C}{\\partial t} \\;=\\; D \\nabla^{2} C \\;-\\; k\\, C \\;+\\; S(\\mathbf{r},t),\n$$\nwhere $S(\\mathbf{r},t)$ represents a localized source. Consider the steady state around a point source, so that $\\partial C/\\partial t = 0$ and $S(\\mathbf{r},t)$ is time-independent and sharply localized at the origin. Use first-principles reasoning to identify the natural spatial scale over which $C(\\mathbf{r})$ decays away from the source by balancing the diffusion and degradation terms in the steady-state equation. Then, compute this characteristic length using $D = 1.0 \\times 10^{-7}$ cm$^{2}$/s and $k = 1.0 \\times 10^{-3}$ s$^{-1}$. Report only the characteristic length in centimeters, rounded to two significant figures. Finally, briefly state how this length scale constrains morphogen spread relative to typical tissue dimensions in an axolotl blastema or a plant callus. The final numerical answer to be graded is the characteristic length in centimeters; do not include any units in your final numerical answer.", "solution": "The starting point is the steady-state reaction-diffusion equation for a morphogen with linear degradation,\n$$\n0 \\;=\\; D \\nabla^{2} C(\\mathbf{r}) \\;-\\; k\\, C(\\mathbf{r}) \\;+\\; S(\\mathbf{r}),\n$$\nwhere $S(\\mathbf{r})$ is a sharply localized source (idealized as a point source). Far from the source, or for the purpose of identifying the intrinsic decay scale in space, the homogeneous part obtained by omitting $S(\\mathbf{r})$ determines how perturbations decay:\n$$\nD \\nabla^{2} C(\\mathbf{r}) \\;-\\; k\\, C(\\mathbf{r}) \\;=\\; 0.\n$$\nTo extract the natural length scale from first principles, one can nondimensionalize the spatial coordinate. Let $r$ denote distance from the source and introduce a characteristic length $\\ell$ with dimension of length, and define a dimensionless coordinate $x = r/\\ell$. The Laplacian rescales as $\\nabla^{2} \\to \\ell^{-2} \\nabla_{x}^{2}$. Substituting into the homogeneous equation yields\n$$\nD \\left(\\frac{1}{\\ell^{2}}\\right) \\nabla_{x}^{2} C(x) \\;-\\; k\\, C(x) \\;=\\; 0.\n$$\nFor the equation to admit nontrivial spatial variation with order-one dimensionless derivatives, the diffusion and degradation terms must balance in magnitude. This balance requires\n$$\n\\frac{D}{\\ell^{2}} \\sim k \\quad \\Rightarrow \\quad \\ell^{2} \\sim \\frac{D}{k}.\n$$\nThus the intrinsic characteristic length that controls how $C$ decays away from the source is\n$$\n\\ell \\;=\\; \\sqrt{\\frac{D}{k}}.\n$$\nThis $\\ell$ is the decay length that appears, for example, in the asymptotic solution of the homogeneous radial equation in three dimensions, where $C(r)$ decays like $\\exp(-r/\\ell)$ up to geometric factors.\n\nNow compute the numerical value with the provided parameters. With $D = 1.0 \\times 10^{-7}\\ \\text{cm}^{2}\\,\\text{s}^{-1}$ and $k = 1.0 \\times 10^{-3}\\ \\text{s}^{-1}$,\n$$\n\\ell \\;=\\; \\sqrt{\\frac{D}{k}} \\;=\\; \\sqrt{\\frac{1.0 \\times 10^{-7}}{1.0 \\times 10^{-3}}}\\ \\text{cm}\n\\;=\\; \\sqrt{1.0 \\times 10^{-4}}\\ \\text{cm}\n\\;=\\; 1.0 \\times 10^{-2}\\ \\text{cm}.\n$$\nRounded to two significant figures and expressed in centimeters, the characteristic length is $1.0 \\times 10^{-2}$ cm.\n\nInterpretation for regenerative contexts: a length of $1.0 \\times 10^{-2}$ cm equals $0.10$ mm ($100$ micrometers). In an axolotl blastema or a plant callus whose linear dimension is on the order of millimeters, a decay length of about $0.10$ mm implies that morphogen concentrations established by a localized source will attenuate substantially within a fraction of the tissue extent, enforcing local patterning near the source unless additional transport or distributed production extends the gradient.", "answer": "$$\\boxed{1.0 \\times 10^{-2}}$$", "id": "2606968"}, {"introduction": "The decision for a cell to abandon its differentiated state and contribute to regeneration is controlled by a complex underlying gene regulatory network. We can abstract the logic of this network using a Boolean model, which treats genes and signals as simple on/off switches. This computational practice [@problem_id:2607051] challenges you to build and analyze such a network, exploring how feedback and memory mechanisms create stable cellular \"attractors\" that correspond to distinct biological states. This approach provides powerful insights into the logic of cellular reprogramming in both plant and animal regeneration.", "problem": "You are asked to formalize a minimal synchronous Boolean network that captures a switch-like dedifferentiation module used to compare injury-induced limb regeneration in animals and totipotency induction in plants. The network has four conceptual nodes: injury signal, a Myc-like driver, chromatin opening, and cell cycle re-entry. The injury signal is treated as an external clamped input. The Myc-like driver represents a fast-acting transcriptional activator of proliferation and chromatin remodeling. Chromatin opening represents widespread accessibility of Deoxyribonucleic Acid (DNA) regulatory elements. The cell cycle node represents re-entry into proliferation, a hallmark of dedifferentiation.\n\nYour modeling must begin from the following foundational base, which you should treat as definitions and well-tested biological regularities: (i) the Central Dogma of molecular biology linking regulatory state to gene expression dynamics, (ii) the use of deterministic synchronous Boolean networks as minimal abstractions of gene regulatory circuits where each node is updated by a logical function of its regulators, and (iii) the interpretation of attractors as steady cell states (fixed points) or recurring patterns (cycles) in the state space.\n\nDefine binary variables $I$, $M$, $O$, $C$ taking values in $\\{0,1\\}$ for the injury input, Myc-like driver, chromatin opening, and cell cycle, respectively. Time is discrete, $t \\in \\mathbb{N}$. The injury input $I$ is clamped to a constant value $I \\in \\{0,1\\}$ within a given simulation. Let $f \\in \\{0,1\\}$ represent the presence ($f=1$) or absence ($f=0$) of a positive feedback from chromatin opening to sustain the Myc-like driver, capturing driver persistence only when chromatin is open. Let $e \\in \\{0,1\\}$ represent the presence ($e=1$) or absence ($e=0$) of epigenetic memory that can sustain chromatin opening even in the absence of the driver.\n\nUpdate the network synchronously by the following logic, derived from the biological premises but mathematically precise:\n- The driver is activated by injury and can self-sustain when chromatin is open if the feedback is present. Formally, for $t \\mapsto t+1$, set $M(t+1) = I$ if $f=0$, and $M(t+1) = I \\lor (M(t) \\land O(t))$ if $f=1$.\n- Chromatin opening is induced by the driver and may persist via epigenetic memory. Formally, $O(t+1) = M(t) \\lor (e \\land O(t))$.\n- Cell cycle re-entry requires both driver activity and open chromatin, so $C(t+1) = M(t) \\land O(t)$.\n- The input is clamped: $I(t+1) = I$ for all $t$.\n\nAn attractor is any cycle in the finite state space under synchronous updates, including fixed points as cycles of length $1$. You must analyze the attractor structure for each specified parameter set by exhaustively simulating from all initial configurations of the three internal nodes $(M,O,C) \\in \\{0,1\\}^3$ with the input $I$ held fixed.\n\nRepresent any network state of the three internal nodes $(M,O,C)$ as a single integer code using the map\n$$\n\\mathrm{code}(M,O,C) = 4 M + 2 O + C,\n$$\nso that, for example, $(M,O,C)=(1,1,1)$ maps to $7$ and $(M,O,C)=(0,0,0)$ maps to $0$. The input $I$ is not included in this code and must not appear in attractor encodings.\n\nFor each parameter set, collect all distinct attractors reached from the $2^3 = 8$ initial states. For each attractor, output the set of its member states as a sorted list of integer codes in non-decreasing order. For a given parameter set, output a list of these lists, with duplicates removed (attractors that are identical as sets must appear only once). The set of parameter values to analyze (the test suite) is:\n\n- Case A (bistable switch without chromatin memory): $(I,f,e)=(0,1,0)$.\n- Case B (sustained injury drive): $(I,f,e)=(1,1,0)$.\n- Case C (no feedback, no memory, no injury): $(I,f,e)=(0,0,0)$.\n- Case D (chromatin memory present, no injury): $(I,f,e)=(0,1,1)$.\n\nYour program must produce a single line of output containing the results for these four cases, in the above order, as a comma-separated list enclosed in square brackets. Each element of this top-level list must be the list of attractors for the corresponding case, where each attractor is itself represented as a bracket-enclosed, comma-separated list of integer codes. For example, a syntactically valid output has the form\n$[ [\\ldots], [\\ldots], [\\ldots], [\\ldots] ]$\nwith each inner list filled according to the conventions above. There are no physical units or angles in this problem. The final results must be fully determined by the specified update logic and parameter sets, with all simulations run until an attractor is detected by observing a repeated state.", "solution": "The problem statement is critically reviewed and determined to be valid. It is scientifically grounded in the established paradigms of systems biology, specifically the use of synchronous Boolean networks to model gene regulatory circuits. The problem is well-posed, with all variables, parameters, and deterministic update rules explicitly and unambiguously defined. The state space is finite, guaranteeing that all system trajectories converge to attractors (cycles or fixed points). The objective is clear and computationally tractable: to find all attractors for four specified parameter sets by exhaustive simulation. The problem is self-contained, logically consistent, and free of any scientific, mathematical, or formal flaws.\n\nThe problem requires the analysis of a four-node Boolean network designed to model cellular dedifferentiation. The network consists of three dynamic nodesâ€”a Myc-like driver ($M$), chromatin opening ($O$), and cell cycle re-entry ($C$)â€”and one external input node for an injury signal ($I$). The state of each dynamic node at time $t+1$ is a Boolean function of the states of the nodes at time $t$. The network's behavior is governed by the clamped input $I \\in \\{0, 1\\}$ and two binary parameters: $f \\in \\{0,1\\}$, which controls a positive feedback loop, and $e \\in \\{0,1\\}$, which controls epigenetic memory.\n\nThe state of the three internal nodes $(M, O, C)$ is represented by a unique integer code calculated as:\n$$\n\\mathrm{code}(M,O,C) = 4M + 2O + C\n$$\nThis encoding maps the $2^3 = 8$ possible states onto the integers $\\{0, 1, \\dots, 7\\}$.\n\nThe synchronous update rules for the network are given by:\n$$\n\\begin{align*}\n    M(t+1) &= \\begin{cases} I & \\text{if } f=0 \\\\ I \\lor (M(t) \\land O(t)) & \\text{if } f=1 \\end{cases} \\\\\n    O(t+1) &= M(t) \\lor (e \\land O(t)) \\\\\n    C(t+1) &= M(t) \\land O(t)\n\\end{align*}\n$$\n\nAn attractor is a set of states that the system cycles through indefinitely. A fixed point is an attractor of length one. We will find all attractors for each of the four specified parameter sets by simulating the network's evolution from all $8$ possible initial states until a cycle is detected.\n\n**Case A: Bistable switch without chromatin memory $(I,f,e)=(0,1,0)$**\nFor this parameter set, the update rules simplify to:\n$$\n\\begin{align*}\n    M(t+1) &= M(t) \\land O(t) \\\\\n    O(t+1) &= M(t) \\\\\n    C(t+1) &= M(t) \\land O(t)\n\\end{align*}\n$$\nAnalysis of the state transitions reveals two fixed-point attractors:\n1.  Starting from any state where $M(0)=0$ (codes $0,1,2,3$), the system converges to the state $(M,O,C)=(0,0,0)$. This is a fixed point since $(0,0,0) \\to (0,0,0)$. The integer code is $0$.\n2.  Starting from any state where $M(0)=1$ and $O(0)=1$ (codes $6,7$), the system converges to the state $(M,O,C)=(1,1,1)$. This is a fixed point since $(1,1,1) \\to (1,1,1)$. The integer code is $7$. Initial states with $M(0)=1, O(0)=0$ (codes $4,5$) transition to $(0,1,0)$, which subsequently converges to $(0,0,0)$.\nThe distinct attractors are $\\{0\\}$ and $\\{7\\}$. This represents a bistable switch, with \"off\" ($0$) and \"on\" ($7$) states.\nThe set of attractors is `[[0], [7]]`.\n\n**Case B: Sustained injury drive $(I,f,e)=(1,1,0)$**\nWith a constant injury signal ($I=1$), the update rules are:\n$$\n\\begin{align*}\n    M(t+1) &= 1 \\lor (M(t) \\land O(t)) = 1 \\\\\n    O(t+1) &= M(t) \\\\\n    C(t+1) &= M(t) \\land O(t)\n\\end{align*}\n$$\nSince $M(t+1)$ is always $1$ for any $t \\geq 0$, after one time step, the system will be in a state where $M=1$.\nLet's trace the trajectory from any initial state. If $M(t)=0$, then $M(t+1)=1$ and $O(t+1)=0$. The state becomes $(1,0,C')$. From state $(1,0,C')$, the next state is $(M,O,C)=(1,1,0)$. From $(1,1,0)$, the next state is $(1,1,1)$. The state $(1,1,1)$ is a fixed point: $M(t+1)=1$, $O(t+1)=1$, $C(t+1)=1$.\nTherefore, all $8$ initial states eventually converge to the single fixed-point attractor $(1,1,1)$, which has code $7$. This represents a fully active, pro-regenerative state sustained by injury.\nThe set of attractors is `[[7]]`.\n\n**Case C: No feedback, no memory, no injury $(I,f,e)=(0,0,0)$**\nThis is the baseline case with no activating signals or memory mechanisms. The update rules simplify significantly:\n$$\n\\begin{align*}\n    M(t+1) &= 0 \\\\\n    O(t+1) &= M(t) \\\\\n    C(t+1) &= M(t) \\land O(t)\n\\end{align*}\n$$\nFor any initial state $(M(0), O(0), C(0))$, after one step, $M(1)=0$. At the next step, $M(2)=0$ and $O(2)=M(1)=0$. At the third step, the state will be $(M,O,C)=(0,0,0)$.\nSpecifically, $(M_t, O_t, C_t) \\to (0, M_t, M_t \\land O_t) \\to (0, 0, 0)$. The state $(0,0,0)$ is a fixed point. Thus, all trajectories converge to the single fixed point $(0,0,0)$, which has code $0$. This represents a quiescent, non-regenerative ground state.\nThe set of attractors is `[[0]]`.\n\n**Case D: Chromatin memory present, no injury $(I,f,e)=(0,1,1)$**\nIn this scenario, we have epigenetic memory ($e=1$) and feedback ($f=1$) but no injury input. The rules are:\n$$\n\\begin{align*}\n    M(t+1) &= M(t) \\land O(t) \\\\\n    O(t+1) &= M(t) \\lor O(t) \\\\\n    C(t+1) &= M(t) \\land O(t)\n\\end{align*}\n$$\nAnalyzing the state space reveals three distinct fixed-point attractors:\n1.  The state $(0,0,0)$ is a fixed point (code $0$). States $(0,0,1)$ flow into it. This is the quiescent state.\n2.  The state $(0,1,0)$ is a fixed point (code $2$). $(0,1,0) \\to (0\\land1, 0\\lor1, 0\\land1)=(0,1,0)$. States $(0,1,1)$, $(1,0,0)$, and $(1,0,1)$ all converge to this attractor. This represents a state with open chromatin but no driver activity, a form of \"poised\" or memory state.\n3.  The state $(1,1,1)$ is a fixed point (code $7$). States $(1,1,0)$ flow into it. This is the self-sustaining active state, maintained by the feedback loop between $M$ and $O$.\nThe presence of epigenetic memory creates a tristable system with three possible final cell fates in the absence of an injury signal.\nThe set of attractors is `[[0], [2], [7]]`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the attractor structure of a Boolean network for given parameter sets.\n    \"\"\"\n    # test_cases defines the parameters (I, f, e) for each of the four cases.\n    # Case A: (I,f,e)=(0,1,0)\n    # Case B: (I,f,e)=(1,1,0)\n    # Case C: (I,f,e)=(0,0,0)\n    # Case D: (I,f,e)=(0,1,1)\n    test_cases = [\n        (0, 1, 0),\n        (1, 1, 0),\n        (0, 0, 0),\n        (0, 1, 1),\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        I, f, e = params\n        found_attractors = set()\n\n        # Iterate through all 2^3 = 8 initial states for (M, O, C)\n        for i in range(8):\n            # Decode integer 'i' into state (M, O, C)\n            M = (i >> 2) & 1\n            O = (i >> 1) & 1\n            C = (i & 1)  # C is not needed for update, but part of state\n            \n            current_state = (M, O, C)\n            \n            # Simulate trajectory to find an attractor\n            trajectory = [current_state]\n            visited_states = {current_state: 0} # {state: time_step}\n\n            while True:\n                M_t, O_t, C_t = current_state\n\n                # Apply the synchronous update rules\n                if f == 0:\n                    M_next = I\n                else: # f == 1\n                    M_next = I or (M_t and O_t)\n                \n                O_next = M_t or (e and O_t)\n                C_next = M_t and O_t\n                \n                next_state = (int(M_next), int(O_next), int(C_next))\n\n                if next_state in visited_states:\n                    # Cycle detected, an attractor has been found\n                    cycle_start_index = visited_states[next_state]\n                    attractor_states = trajectory[cycle_start_index:]\n                    \n                    # Convert states to integer codes\n                    attractor_codes = []\n                    for state in attractor_states:\n                        m, o, c = state\n                        code = 4 * m + 2 * o + c\n                        attractor_codes.append(code)\n                    \n                    # Sort codes and add to set of found attractors to ensure uniqueness\n                    attractor_codes.sort()\n                    found_attractors.add(tuple(attractor_codes))\n                    break\n                \n                # Continue simulation\n                visited_states[next_state] = len(trajectory)\n                trajectory.append(next_state)\n                current_state = next_state\n        \n        # Convert set of tuples to a sorted list of lists\n        sorted_attractors = sorted([list(att) for att in found_attractors])\n        all_results.append(sorted_attractors)\n\n    # Format the final output string as per problem specification.\n    # The format is a list of lists of lists, e.g., [[[0],[7]],[[7]],...]\n    outer_list_parts = []\n    for case_attractors in all_results:\n        inner_list_parts = []\n        for attractor in case_attractors:\n            attractor_str = f\"[{','.join(map(str, attractor))}]\"\n            inner_list_parts.append(attractor_str)\n        case_str = f\"[{','.join(inner_list_parts)}]\"\n        outer_list_parts.append(case_str)\n    \n    final_output = f\"[{','.join(outer_list_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2607051"}]}