{"hands_on_practices": [{"introduction": "At the heart of every birth-death model lies a simple stochastic rule: the waiting time until the next event. Before tackling complex clades, this first practice grounds us in the fundamental building block of a pure-birth, or Yule, process. By deriving the expected waiting time for a new species to arise from a single lineage [@problem_id:2567064], you will cement your understanding of how a constant per-lineage rate $\\lambda$ translates into the predictable, memoryless behavior described by the exponential distribution.", "problem": "In comparative zoology and botany, one commonly models clade diversification under a pure-birth process (Yule process), in which each extant lineage independently gives rise to a new lineage (a speciation event) at a constant per-lineage rate $\\lambda$ over time. Consider a focal extant lineage observed at the present. Assume the following foundational properties, which operationally define the Yule process at the lineage level: over an infinitesimal interval of time $[t,t+\\mathrm{d}t)$, conditional on no speciation having occurred up to time $t$ on the focal lineage, the probability that a speciation event occurs on that lineage in $[t,t+\\mathrm{d}t)$ is $\\lambda\\,\\mathrm{d}t + o(\\mathrm{d}t)$; the probability of more than one event in $[t,t+\\mathrm{d}t)$ is $o(\\mathrm{d}t)$; and the process has no memory beyond the current state.\n\nLet $T$ denote the waiting time from the present to the next speciation event on the focal lineage. Starting solely from the infinitesimal rate characterization above and the independence of increments implied by the Yule process, derive the expected value $\\mathbb{E}[T]$.\n\nProvide your final result as a single closed-form analytic expression in terms of $\\lambda$ only. Do not include units in your final boxed answer. If you find multiple equivalent forms, choose one and present that single form.", "solution": "The problem requires the derivation of the expected waiting time, $\\mathbb{E}[T]$, for the next speciation event on a single focal lineage, based on the fundamental properties of a Yule process. The derivation must proceed from first principles, using the provided infinitesimal rate characterization.\n\nLet $T$ be the random variable representing the waiting time from the present ($t=0$) until the next speciation event. We seek to find the expected value of $T$, denoted $\\mathbb{E}[T]$. The core of the problem lies in first deriving the probability distribution of $T$.\n\nLet $S(t) = \\mathbb{P}(T > t)$ be the survival function of $T$. This function gives the probability that the speciation event has not occurred by time $t$. By definition, $S(0) = \\mathbb{P}(T > 0) = 1$, as the waiting time must be positive.\n\nThe problem statement provides the conditional probability of a speciation event occurring in the infinitesimal time interval $[t, t+\\mathrm{d}t)$, given that no event has occurred up to time $t$. This is the definition of the hazard rate, $h(t)$. Mathematically,\n$$\nh(t) = \\lim_{\\mathrm{d}t \\to 0} \\frac{\\mathbb{P}(t < T \\leq t+\\mathrm{d}t | T > t)}{\\mathrm{d}t}\n$$\nFrom the problem statement, this conditional probability is given as $\\lambda\\,\\mathrm{d}t + o(\\mathrm{d}t)$. Therefore, the hazard rate is:\n$$\nh(t) = \\lim_{\\mathrm{d}t \\to 0} \\frac{\\lambda\\,\\mathrm{d}t + o(\\mathrm{d}t)}{\\mathrm{d}t} = \\lambda\n$$\nThe rate $\\lambda$ is constant, which is a key property of the process, indicating that it is memoryless.\n\nThe hazard rate $h(t)$ is fundamentally related to the survival function $S(t)$ and the probability density function $f(t) = -S'(t)$. The conditional probability can be expressed as:\n$$\n\\mathbb{P}(t < T \\leq t+\\mathrm{d}t | T > t) = \\frac{\\mathbb{P}((t < T \\leq t+\\mathrm{d}t) \\cap (T > t))}{\\mathbb{P}(T > t)} = \\frac{\\mathbb{P}(t < T \\leq t+\\mathrm{d}t)}{\\mathbb{P}(T > t)}\n$$\nFor an infinitesimal interval $\\mathrm{d}t$, the probability $\\mathbb{P}(t < T \\leq t+\\mathrm{d}t)$ is approximately $f(t)\\,\\mathrm{d}t$. Thus,\n$$\nh(t) = \\frac{f(t)}{S(t)}\n$$\nSince $f(t) = -\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t}$, we can write:\n$$\nh(t) = -\\frac{1}{S(t)}\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t} = -\\frac{\\mathrm{d}}{\\mathrm{d}t} \\ln(S(t))\n$$\nWe have established that $h(t) = \\lambda$. Substituting this into the equation yields a first-order ordinary differential equation for $S(t)$:\n$$\n-\\frac{1}{S(t)}\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t} = \\lambda\n$$\nRearranging the terms gives:\n$$\n\\frac{\\mathrm{d}S(t)}{S(t)} = -\\lambda\\,\\mathrm{d}t\n$$\nTo find $S(t)$, we integrate both sides of the equation from time $0$ to a general time $t$:\n$$\n\\int_{S(0)}^{S(t)} \\frac{1}{S} \\, \\mathrm{d}S = \\int_0^t -\\lambda \\, \\mathrm{d}\\tau\n$$\nThe integral of the left side is $\\ln(S(t)) - \\ln(S(0))$, and the integral of the right side is $-\\lambda t$.\n$$\n\\ln(S(t)) - \\ln(S(0)) = -\\lambda t\n$$\nUsing the initial condition $S(0)=1$, we have $\\ln(1)=0$. Therefore:\n$$\n\\ln(S(t)) = -\\lambda t\n$$\nExponentiating both sides gives the survival function:\n$$\nS(t) = \\exp(-\\lambda t)\n$$\nThis is the survival function of an exponential distribution with rate parameter $\\lambda$.\n\nNow, we can compute the expected value $\\mathbb{E}[T]$. For a non-negative random variable such as waiting time $T$, the expected value can be calculated by integrating the survival function over its support, from $0$ to $\\infty$:\n$$\n\\mathbb{E}[T] = \\int_0^\\infty S(t) \\, \\mathrm{d}t\n$$\nSubstituting the derived survival function $S(t) = \\exp(-\\lambda t)$:\n$$\n\\mathbb{E}[T] = \\int_0^\\infty \\exp(-\\lambda t) \\, \\mathrm{d}t\n$$\nThis is a standard integral. The evaluation proceeds as follows:\n$$\n\\mathbb{E}[T] = \\left[ -\\frac{1}{\\lambda} \\exp(-\\lambda t) \\right]_0^\\infty\n$$\nEvaluating the expression at the limits of integration:\n$$\n\\mathbb{E}[T] = \\lim_{t \\to \\infty} \\left(-\\frac{1}{\\lambda} \\exp(-\\lambda t)\\right) - \\left(-\\frac{1}{\\lambda} \\exp(-\\lambda \\cdot 0)\\right)\n$$\nSince $\\lambda$ is a rate, it must be positive ($\\lambda > 0$). As $t \\to \\infty$, the term $\\exp(-\\lambda t)$ approaches $0$. The second term evaluates to $-\\frac{1}{\\lambda} \\exp(0) = -\\frac{1}{\\lambda}$.\n$$\n\\mathbb{E}[T] = (0) - \\left(-\\frac{1}{\\lambda}\\right) = \\frac{1}{\\lambda}\n$$\nThus, the expected waiting time to the next speciation event on the focal lineage is the reciprocal of the speciation rate $\\lambda$. This result is consistent with the general properties of an exponential distribution, which has been rigorously derived here from the provided infinitesimal characterization.", "answer": "$$\\boxed{\\frac{1}{\\lambda}}$$", "id": "2567064"}, {"introduction": "Having mastered the waiting time for a single event, we now scale up to simulate the growth and decline of an entire clade. This exercise guides you through implementing a Gillespie-style stochastic simulation algorithm, the computational engine behind most birth-death models [@problem_id:2566990]. By programming the rules for event scheduling and selection, you will gain a powerful, hands-on intuition for how the macroscopic patterns of diversification emerge from the simple, per-lineage rates of speciation ($\\lambda$) and extinction ($\\mu$).", "problem": "You will implement a Continuous-Time Markov Chain (CTMC) birth–death diversification simulator using the Stochastic Simulation Algorithm (SSA, also called Gillespie algorithm) to generate birth–death trees for comparative zoology and botany. In this context, lineages speciate (birth) at a per-lineage rate $ \\lambda $ and go extinct (death) at a per-lineage rate $ \\mu $. The state variable is the number of extant lineages $ n(t) $ at time $ t $. The fundamental base for the derivation is the standard CTMC framework for independent Poisson processes governing competing exponential clocks, together with the memoryless property of the exponential distribution and superposition of independent Poisson processes: when there are $ n $ independent and identical exponential clocks with rates $ \\lambda $ for birth and $ \\mu $ for death per lineage, the time to the next event is exponentially distributed with a total hazard equal to the sum of all active hazards, and the next event type is selected proportionally to its contribution to the total hazard.\n\nYour task is to derive from these principles the event scheduling and implement an SSA that:\n- Initializes with $ n_0 $ lineages at time $ t = 0 $.\n- At any time with $ n $ extant lineages, schedules the next event time and event type based only on $ \\lambda $, $ \\mu $, and $ n $.\n- Updates $ n $ by $ +1 $ for a birth or $ -1 $ for a death, and updates the current time accordingly.\n- Continues until a stopping criterion is met.\n\nYour stopping criterion must be the logical disjunction of the following conditions:\n- Time exceeds a maximum horizon $ T_{\\max} $.\n- All lineages go extinct, so $ n = 0 $ at some time.\n- A safety cap for computational tractability is reached with $ n \\ge N_{\\max} $, where $ N_{\\max} $ is a user-specified upper bound on the number of extant lineages to prevent explosive growth in supercritical regimes.\n\nTreat all lineages as exchangeable and identically and independently distributed with respect to their event hazards, and do not condition on survival or impose any additional constraints beyond the stopping criteria above.\n\nYou will produce a program that, for each test case, runs a single stochastic simulation with a fixed pseudorandom seed and returns a triplet of integers summarizing the outcome:\n- The number of extant lineages at termination, $ n_{\\text{final}} $.\n- The total number of birth events that occurred, $ B $.\n- The total number of death events that occurred, $ D $.\n\nEvent times are in arbitrary time units; your output is dimensionless counts. Do not include any physical units in the output.\n\nFrom first principles, derive:\n- How to schedule waiting times between events given $ n $, $ \\lambda $, and $ \\mu $.\n- How to choose the event type and the affected lineage (given exchangeability).\n- Why the stopping criterion above ensures a well-defined simulation even in supercritical regimes.\n\nThen implement the algorithm and run it on the following test suite of parameter sets. Each test case is a tuple $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) $:\n- Case A (general supercritical): $ (0.4, 0.2, 5.0, 1, 2000, 42) $.\n- Case B (pure-birth or Yule limit): $ (1.0, 0.0, 1.0, 1, 2000, 7) $.\n- Case C (pure-death): $ (0.0, 0.5, 3.0, 3, 2000, 123) $.\n- Case D (supercritical with cap reached): $ (2.0, 0.1, 10.0, 1, 50, 1) $.\n- Case E (null dynamics): $ (0.0, 0.0, 2.0, 5, 100, 99) $.\n\nFor each case, run exactly one simulation replication with the given seed, and output a single line containing a comma-separated list enclosed in square brackets where each element is itself a list $ [n_{\\text{final}},B,D] $ for that case, in the same order as specified above. There must be no spaces anywhere in the line. For example, the format must be exactly like:\n[[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15]]\n\nYour program must be completely deterministic with respect to the provided seeds and must not require any user input or external files.", "solution": "We model lineage diversification as a Continuous-Time Markov Chain (CTMC) with independent and identically distributed per-lineage birth and death hazards. At any time $ t $, if there are $ n(t) = n $ extant lineages, each lineage contributes two possible event channels: a birth with per-lineage rate $ \\lambda $ and a death with per-lineage rate $ \\mu $. The system thus has $ n $ independent and identically distributed potential birth events and $ n $ independent and identically distributed potential death events.\n\nFundamental base:\n- Independent Poisson processes and the memoryless property imply that if $ X_1, \\dots, X_k $ are independent exponential random variables with rates $ r_1, \\dots, r_k $, then $ \\min(X_1,\\dots,X_k) $ is exponentially distributed with rate $ r_1 + \\dots + r_k $, and the probability that the minimum corresponds to process $ i $ equals $ r_i / (r_1 + \\dots + r_k) $. This is the superposition property of Poisson processes and the basis of the Stochastic Simulation Algorithm (SSA).\n- The CTMC jump chain evolves by selecting the next event time as an exponential waiting time with parameter equal to the total exit rate from the current state, and then selecting the event type according to relative rates.\n\nEvent scheduling derivation:\n- With $ n $ extant lineages, there are $ n $ birth channels each with rate $ \\lambda $ and $ n $ death channels each with rate $ \\mu $. The total rate is therefore\n$$ R(n) = n \\lambda + n \\mu = n (\\lambda + \\mu). $$\n- The waiting time $ \\Delta t $ to the next event is exponential with rate $ R(n) $, that is, $ \\Delta t \\sim \\text{Exponential}(R(n)) $.\n- Conditional on an event occurring, the probability it is a birth is the total birth rate divided by the total rate,\n$$ \\mathbb{P}(\\text{birth} \\mid n) = \\frac{n \\lambda}{n (\\lambda + \\mu)} = \\frac{\\lambda}{\\lambda + \\mu}, $$\nand the probability it is a death is\n$$ \\mathbb{P}(\\text{death} \\mid n) = \\frac{n \\mu}{n (\\lambda + \\mu)} = \\frac{\\mu}{\\lambda + \\mu}. $$\n- Exchangeability across lineages implies that, given the event type, the affected lineage is uniformly random among the $ n $ extant lineages, because all contribute identically to the hazard.\n\nAlgorithm design (Stochastic Simulation Algorithm):\n- Initialize time $ t \\leftarrow 0 $, number of extant lineages $ n \\leftarrow n_0 $, and counters $ B \\leftarrow 0 $ and $ D \\leftarrow 0 $ for births and deaths. Maintain a list of extant lineage identifiers, but because all lineages are exchangeable and only counts are needed for the output, it suffices to track $ n $; however, we can also maintain explicit identifiers to make lineage selection explicit.\n- While none of the stopping criteria holds, compute the total rate $ R(n) = n (\\lambda + \\mu) $.\n    - If $ R(n) = 0 $ (for example, $ \\lambda = 0 $ and $ \\mu = 0 $, or $ n = 0 $), then no further events can occur; terminate.\n    - Sample a waiting time $ \\Delta t $ from an exponential distribution with rate $ R(n) $. If $ t + \\Delta t > T_{\\max} $, then the next event would occur beyond the horizon; terminate without applying the event.\n    - Otherwise, set $ t \\leftarrow t + \\Delta t $, then select the event type: sample a uniform random variable $ U \\in (0,1) $. If $ U < \\lambda / (\\lambda + \\mu) $, treat the event as a birth; otherwise treat it as a death.\n    - For a birth, increment $ B \\leftarrow B + 1 $ and $ n \\leftarrow n + 1 $.\n    - For a death, increment $ D \\leftarrow D + 1 $ and $ n \\leftarrow n - 1 $.\n- After each event, check the stopping criteria: if $ n = 0 $, terminate due to extinction; if $ n \\ge N_{\\max} $, terminate due to safety cap; if $ t \\ge T_{\\max} $, terminate due to time limit. Because we check $ t + \\Delta t $ before applying an event, the $ t \\ge T_{\\max} $ condition will occur naturally when no further events can occur within the horizon.\n\nWhy these stopping criteria ensure a well-defined simulation:\n- If $ \\lambda \\le \\mu $, the process is critical or subcritical on average and will not explode in finite time; the horizon $ T_{\\max} $ and extinction boundary $ n = 0 $ suffice.\n- If $ \\lambda > \\mu $, the process is supercritical and can grow rapidly; bounding $ n $ by $ N_{\\max} $ guarantees that the algorithm terminates in finite steps even if the horizon is very large. This acts as a truncation that preserves statistical coherence up to the cap.\n\nEdge cases:\n- If $ \\lambda = 0 $ and $ \\mu > 0 $, the process is pure death; the algorithm will eventually hit $ n = 0 $ or reach $ T_{\\max} $ if started with $ n_0 > 0 $.\n- If $ \\lambda > 0 $ and $ \\mu = 0 $, the process is pure birth (Yule); growth may be fast, so $ N_{\\max} $ prevents computational blow-up.\n- If $ \\lambda = 0 $ and $ \\mu = 0 $, then $ R(n) = 0 $ for any $ n $, so no events can occur; the state remains $ n = n_0 $ until $ T_{\\max} $; the algorithm detects $ R(n) = 0 $ and terminates immediately.\n\nTest suite and outputs:\n- For each case, we use a fixed pseudorandom seed so the simulation is reproducible. The program outputs a single line with no spaces containing a list of the results for the five cases, in order, where each result is the list $ [n_{\\text{final}}, B, D] $ of integers. The cases are:\n    - Case A: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (0.4, 0.2, 5.0, 1, 2000, 42) $.\n    - Case B: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (1.0, 0.0, 1.0, 1, 2000, 7) $.\n    - Case C: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (0.0, 0.5, 3.0, 3, 2000, 123) $.\n    - Case D: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (2.0, 0.1, 10.0, 1, 50, 1) $.\n    - Case E: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (0.0, 0.0, 2.0, 5, 100, 99) $.\n\nComputational considerations:\n- Each event requires $ \\mathcal{O}(1) $ work. The number of events up to $ T_{\\max} $ is random but almost surely finite under the cap $ N_{\\max} $ and finite $ T_{\\max} $.\n- Using a high-quality pseudorandom number generator and fixed seeds ensures reproducibility.\n\nThe implementation follows these steps exactly and adheres to the specified output format with no spaces, for deterministic evaluation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_birth_death(lambda_rate, mu_rate, T_max, n0, N_max, seed):\n    \"\"\"\n    Simulate a birth-death process using a Gillespie-style SSA.\n\n    Parameters:\n        lambda_rate (float): per-lineage birth rate (lambda)\n        mu_rate (float): per-lineage death rate (mu)\n        T_max (float): time horizon\n        n0 (int): initial number of lineages\n        N_max (int): safety cap for maximum number of extant lineages\n        seed (int): random seed for reproducibility\n\n    Returns:\n        (n_final, births, deaths): tuple of integers\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    t = 0.0\n    n = int(n0)\n    births = 0\n    deaths = 0\n\n    # Main SSA loop\n    while True:\n        # Check stopping criteria at loop top to handle initial conditions like n0==0\n        if n == 0:\n            break\n        if n >= N_max:\n            break\n        if t >= T_max:\n            break\n\n        total_rate = n * (lambda_rate + mu_rate)\n\n        # If no events can occur, terminate.\n        if total_rate = 0.0:\n            break\n\n        # Sample waiting time to next event\n        dt = rng.exponential(1.0 / total_rate)\n\n        # If next event occurs beyond T_max, stop without applying it\n        if t + dt > T_max:\n            break\n\n        # Advance time\n        t += dt\n\n        # Decide event type: birth with probability lambda/(lambda+mu)\n        if (lambda_rate + mu_rate) > 0.0:\n            p_birth = lambda_rate / (lambda_rate + mu_rate)\n        else:\n            p_birth = 0.0  # Should not happen because total_rate > 0 implies lambda+mu>0\n\n        if rng.random()  p_birth:\n            # Birth event: choose affected lineage uniformly (exchangeable)\n            # Since all lineages are identical and only counts are needed, we do not need explicit IDs.\n            births += 1\n            n += 1\n        else:\n            # Death event\n            deaths += 1\n            n -= 1\n\n        # Loop continues; stopping criteria are checked at top.\n\n    n_final = n\n    return int(n_final), int(births), int(deaths)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (lambda, mu, T_max, n0, N_max, seed)\n    test_cases = [\n        (0.4, 0.2, 5.0, 1, 2000, 42),   # Case A: general supercritical\n        (1.0, 0.0, 1.0, 1, 2000, 7),    # Case B: pure birth (Yule)\n        (0.0, 0.5, 3.0, 3, 2000, 123),  # Case C: pure death\n        (2.0, 0.1, 10.0, 1, 50, 1),     # Case D: supercritical with cap\n        (0.0, 0.0, 2.0, 5, 100, 99),    # Case E: null dynamics\n    ]\n\n    results = []\n    for params in test_cases:\n        lam, mu, Tmax, n0, Nmax, seed = params\n        n_final, births, deaths = simulate_birth_death(lam, mu, Tmax, n0, Nmax, seed)\n        results.append([n_final, births, deaths])\n\n    # Format output with no spaces as required: [[a,b,c],[d,e,f],...]\n    inner = \",\".join(\"[\" + \",\".join(map(str, res)) + \"]\" for res in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2566990"}, {"introduction": "From understanding and simulating diversification, we now turn to the inverse challenge: inferring process parameters from real, and often incomplete, phylogenetic data. This final practice confronts a critical issue in comparative methods—parameter identifiability and the impact of model misspecification [@problem_id:2567025]. You will analytically determine how an incorrect assumption about the sampling fraction $\\rho$ systematically biases our estimates of key diversification parameters, revealing which aspects of evolution we can confidently measure and which are more elusive.", "problem": "A comparative study in zoology and botany aims to compare diversification dynamics between a clade of passerine birds and a clade of angiosperms using constant-rate birth–death models. For each clade, the reconstructed phylogeny of sampled extant species is analyzed under the assumptions of a time-homogeneous birth–death process with speciation rate $\\lambda$, extinction rate $\\mu$, and present-day Bernoulli sampling with sampling fraction $\\rho$. The inference targets are the net diversification rate $r$ and the relative extinction fraction $\\epsilon$, defined by $r = \\lambda - \\mu$ and $\\epsilon = \\frac{\\mu}{\\lambda}$. An analyst uses maximum likelihood estimation (maximum likelihood estimate (MLE)) on reconstructed trees conditioned on crown age and number of sampled tips, but mistakenly fixes the sampling fraction at a value $\\rho'$ different from the true $\\rho$.\n\nIt is a well-tested fact for the constant-rate birth–death process with present-day Bernoulli sampling that the likelihood of reconstructed branching times depends on the model only through the two composite quantities $r$ and $\\psi$, where $\\psi = \\rho \\lambda$. Consequently, under a large-tree limit (many branching times), the MLE converges to the pseudo-true parameters that match the true values of these identifiable composites.\n\nAssume the analyst’s model class fixes $\\rho'$ and estimates parameters $(\\lambda', \\mu')$, equivalently $(r', \\epsilon')$, from the reconstructed tree. Under the large-tree limit, derive the pseudo-true limits $(r^{\\ast}, \\epsilon^{\\ast})$ of the MLE as closed-form functions of the true $(r, \\epsilon, \\rho)$ and the analyst’s fixed $\\rho'$. Express your final answer as a $1 \\times 2$ row vector $\\bigl(r^{\\ast}, \\epsilon^{\\ast}\\bigr)$ using standard mathematical notation. No numerical approximation or rounding is required.", "solution": "The problem statement is scientifically sound, well-posed, objective, and provides all necessary information for a unique solution. It is based on established principles of phylogenetic comparative methods, specifically the properties of the constant-rate birth-death model. Thus, the problem is valid, and I will proceed with its solution.\n\nThe problem requires deriving the pseudo-true parameter estimates $(r^{\\ast}, \\epsilon^{\\ast})$ that an analyst would obtain under a large-tree limit when misspecifying the sampling fraction. The core of the solution lies in the provided fact that the likelihood of the reconstructed tree depends on the birth-death model parameters only through two identifiable composite quantities: the net diversification rate, $r = \\lambda - \\mu$, and a second composite, $\\psi = \\rho \\lambda$. Here, $\\lambda$ is the speciation rate, $\\mu$ is the extinction rate, and $\\rho$ is the sampling fraction.\n\nLet the true parameters of the evolutionary process be $(\\lambda, \\mu, \\rho)$. The true values of the derived parameters are $r = \\lambda - \\mu$ and $\\epsilon = \\frac{\\mu}{\\lambda}$. The true identifiable composite quantities are:\n$$\nr_{\\text{true}} = \\lambda - \\mu\n$$\n$$\n\\psi_{\\text{true}} = \\rho \\lambda\n$$\n\nThe analyst uses a model with estimated parameters $(\\lambda', \\mu')$ but fixes the sampling fraction to an incorrect value, $\\rho'$. For this model, the composite quantities are expressed as:\n$$\nr_{\\text{model}} = \\lambda' - \\mu'\n$$\n$$\n\\psi_{\\text{model}} = \\rho' \\lambda'\n$$\n\nIn the large-tree limit, the maximum likelihood estimates (MLE) converge to pseudo-true parameters, which we denote as $(\\lambda^{\\ast}, \\mu^{\\ast})$. These are the parameter values within the analyst's specified model class that make the identifiable composite quantities match their true values. This gives rise to a system of two equations:\n\n$1$. The net diversification rate of the pseudo-true model must equal the true net diversification rate:\n$$\n\\lambda^{\\ast} - \\mu^{\\ast} = \\lambda - \\mu\n$$\n$2$. The second composite quantity of the pseudo-true model must equal the true second composite quantity:\n$$\n\\rho' \\lambda^{\\ast} = \\rho \\lambda\n$$\n\nOur objective is to find the pseudo-true derived parameters, $r^{\\ast} = \\lambda^{\\ast} - \\mu^{\\ast}$ and $\\epsilon^{\\ast} = \\frac{\\mu^{\\ast}}{\\lambda^{\\ast}}$, as functions of the true parameters $(r, \\epsilon, \\rho)$ and the analyst's choice $\\rho'$.\n\nFrom the first equation, we can directly determine $r^{\\ast}$. By definition, $r^{\\ast} = \\lambda^{\\ast} - \\mu^{\\ast}$ and $r = \\lambda - \\mu$. Therefore:\n$$\nr^{\\ast} = r\n$$\nThis shows that the estimate of the net diversification rate is robust to misspecification of the sampling fraction, a known result in phylogenetics.\n\nNext, we derive the expression for $\\epsilon^{\\ast}$. We need to solve for $\\lambda^{\\ast}$ and $\\mu^{\\ast}$ in terms of the true parameters. From the second equation in our system:\n$$\n\\lambda^{\\ast} = \\frac{\\rho \\lambda}{\\rho'}\n$$\nFrom the first equation, we can express $\\mu^{\\ast}$ as:\n$$\n\\mu^{\\ast} = \\lambda^{\\ast} - (\\lambda - \\mu)\n$$\nNow, we can compute the ratio $\\epsilon^{\\ast} = \\frac{\\mu^{\\ast}}{\\lambda^{\\ast}}$:\n$$\n\\epsilon^{\\ast} = \\frac{\\lambda^{\\ast} - (\\lambda - \\mu)}{\\lambda^{\\ast}} = 1 - \\frac{\\lambda - \\mu}{\\lambda^{\\ast}}\n$$\nSubstitute the expression for $\\lambda^{\\ast}$ into this equation:\n$$\n\\epsilon^{\\ast} = 1 - \\frac{\\lambda - \\mu}{\\frac{\\rho \\lambda}{\\rho'}} = 1 - \\left(\\frac{\\rho'}{\\rho}\\right) \\frac{\\lambda - \\mu}{\\lambda}\n$$\nThe term $\\frac{\\lambda - \\mu}{\\lambda}$ can be written as $1 - \\frac{\\mu}{\\lambda}$. By definition, the true relative extinction fraction is $\\epsilon = \\frac{\\mu}{\\lambda}$. So, we have:\n$$\n\\frac{\\lambda - \\mu}{\\lambda} = 1 - \\epsilon\n$$\nSubstituting this back into the expression for $\\epsilon^{\\ast}$ gives the final form:\n$$\n\\epsilon^{\\ast} = 1 - \\frac{\\rho'}{\\rho} (1 - \\epsilon)\n$$\nThis expression shows how the estimated relative extinction fraction $\\epsilon^{\\ast}$ is biased as a function of the ratio of the incorrect sampling fraction to the true one, $\\frac{\\rho'}{\\rho}$, and the true relative extinction fraction $\\epsilon$.\n\nCombining our two results, the pseudo-true limits for the estimated parameters, $(r^{\\ast}, \\epsilon^{\\ast})$, are given by the vector:\n$$\n\\left(r, 1 - \\frac{\\rho'}{\\rho} (1 - \\epsilon)\\right)\n$$\nThis vector expresses the asymptotic bias in the estimation of diversification parameters when the sampling fraction is misspecified.", "answer": "$$\\boxed{\\begin{pmatrix} r  1 - \\frac{\\rho'}{\\rho} (1 - \\epsilon) \\end{pmatrix}}$$", "id": "2567025"}]}