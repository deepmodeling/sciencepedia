{"hands_on_practices": [{"introduction": "Effective foraging is a cornerstone of pollinator fitness, often involving rapid decisions based on incomplete or ambiguous floral signals. This exercise applies the powerful framework of Signal Detection Theory (SDT) to model how a pollinator should optimally decide whether to visit a flower based on a continuous cue, like color, that imperfectly correlates with a nectar reward. By deriving the optimal decision threshold, you will gain hands-on experience in modeling how animals balance sensory evidence with the economic consequences of their choices, a fundamental skill in behavioral and evolutionary ecology. [@problem_id:2602882]", "problem": "A nectar-feeding pollinator uses color to decide whether to probe a flower. Let the perceived scalar color metric be $x \\in \\mathbb{R}$. Due to overlapping pigmentation phenotypes, the color metric for rewarding flowers ($R$) and nonrewarding flowers ($N$) are distributed as Gaussian densities with identical variance but different means: if the flower is rewarding, $x \\sim \\mathcal{N}(\\mu_{R}, \\sigma^{2})$; if the flower is nonrewarding, $x \\sim \\mathcal{N}(\\mu_{N}, \\sigma^{2})$, with $\\mu_{R} > \\mu_{N}$ and $\\sigma > 0$. The prior probability that an encountered flower is rewarding is $p_{R} \\in (0,1)$, and $p_{N} = 1 - p_{R}$. If the pollinator probes a flower and it is rewarding, it gains nectar worth $E > 0$ (in a consistent energy-equivalent unit); if it probes and the flower is nonrewarding, it gains $0$ nectar and incurs a net energetic/opportunity cost $K > 0$. Skipping a flower yields $0$ with no cost. Assume decisions are independent and the pollinator maximizes expected nectar intake per decision according to Bayesian updating as in Signal Detection Theory (SDT).\n\nStarting only from Bayes’ theorem and expected utility maximization, derive the Bayes-optimal decision rule of the form “probe if and only if $x \\ge x^{\\ast}$,” and obtain a closed-form expression for the optimal threshold $x^{\\ast}$ in terms of $\\mu_{R}$, $\\mu_{N}$, $\\sigma$, $p_{R}$, $p_{N}$, $E$, and $K$. Express your final answer as an analytic expression for $x^{\\ast}$; no rounding is required and no units should be included with the expression.", "solution": "The problem requires the derivation of an optimal decision threshold for a nectar-feeding pollinator, based on the principles of Bayesian decision theory and expected utility maximization. This is a classic problem in Signal Detection Theory.\n\nLet the two possible states of a flower be Rewarding ($R$) and Nonrewarding ($N$). The pollinator observes a continuous color metric $x \\in \\mathbb{R}$. The decision to be made is between two actions: Probe ($A_P$) or Skip ($A_S$). The objective is to choose the action that maximizes the expected utility, or energetic gain.\n\nThe utility of skipping a flower is always zero, regardless of the observation $x$.\n$$\n\\mathbb{E}[U(A_S | x)] = 0\n$$\n\nThe expected utility of probing a flower, given the observation $x$, is the sum of the utilities for each possible state, weighted by the posterior probability of that state given the observation.\n$$\n\\mathbb{E}[U(A_P | x)] = U(A_P, R) \\cdot P(R | x) + U(A_P, N) \\cdot P(N | x)\n$$\nFrom the problem statement, the utility of probing a rewarding flower is a gain of $E$, so $U(A_P, R) = E$. The utility of probing a nonrewarding flower is a cost of $K$, so $U(A_P, N) = -K$. Thus, the expected utility of probing is:\n$$\n\\mathbb{E}[U(A_P | x)] = E \\cdot P(R | x) - K \\cdot P(N | x)\n$$\nA Bayes-optimal decision rule dictates that the pollinator should probe if and only if the expected utility of probing is greater than or equal to the expected utility of skipping.\n$$\n\\mathbb{E}[U(A_P | x)] \\ge \\mathbb{E}[U(A_S | x)]\n$$\n$$\nE \\cdot P(R | x) - K \\cdot P(N | x) \\ge 0\n$$\nThis inequality can be rearranged to:\n$$\n\\frac{P(R | x)}{P(N | x)} \\ge \\frac{K}{E}\n$$\nThe posterior probabilities $P(R | x)$ and $P(N | x)$ are not directly given. We must use Bayes' theorem to express them in terms of the likelihoods of the observation, $P(x|R)$ and $P(x|N)$, and the prior probabilities, $P(R) = p_R$ and $P(N) = p_N$.\n$$\nP(R | x) = \\frac{P(x | R) P(R)}{P(x)} \\quad \\text{and} \\quad P(N | x) = \\frac{P(x | N) P(N)}{P(x)}\n$$\nSubstituting these into the decision rule inequality:\n$$\n\\frac{\\frac{P(x | R) p_R}{P(x)}}{\\frac{P(x | N) p_N}{P(x)}} \\ge \\frac{K}{E}\n$$\nThe evidence term $P(x)$ cancels, yielding the likelihood ratio test:\n$$\n\\frac{P(x | R)}{P(x | N)} \\ge \\frac{K p_N}{E p_R}\n$$\nThe problem states that the color metrics are distributed as Gaussian densities. Let $P(x|R) = f_R(x)$ and $P(x|N) = f_N(x)$.\n$$\nf_R(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x - \\mu_{R})^2}{2\\sigma^{2}}\\right)\n$$\n$$\nf_N(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x - \\mu_{N})^2}{2\\sigma^{2}}\\right)\n$$\nThe likelihood ratio $\\lambda(x) = \\frac{f_R(x)}{f_N(x)}$ is:\n$$\n\\lambda(x) = \\frac{\\exp\\left(-\\frac{(x - \\mu_{R})^2}{2\\sigma^{2}}\\right)}{\\exp\\left(-\\frac{(x - \\mu_{N})^2}{2\\sigma^{2}}\\right)} = \\exp\\left(\\frac{1}{2\\sigma^{2}} \\left[ (x - \\mu_{N})^2 - (x - \\mu_{R})^2 \\right] \\right)\n$$\nThe decision rule is to probe if $\\lambda(x) \\ge \\frac{K p_N}{E p_R}$. Since the natural logarithm function $\\ln(\\cdot)$ is monotonically increasing, we can take the logarithm of both sides of the inequality without altering the decision.\n$$\n\\ln(\\lambda(x)) \\ge \\ln\\left(\\frac{K p_N}{E p_R}\\right)\n$$\n$$\n\\frac{1}{2\\sigma^{2}} \\left[ (x - \\mu_{N})^2 - (x - \\mu_{R})^2 \\right] \\ge \\ln\\left(\\frac{K p_N}{E p_R}\\right)\n$$\nWe expand the quadratic terms in the bracket:\n$$\n(x - \\mu_{N})^2 - (x - \\mu_{R})^2 = (x^2 - 2x\\mu_N + \\mu_N^2) - (x^2 - 2x\\mu_R + \\mu_R^2)\n$$\n$$\n= 2x(\\mu_R - \\mu_N) - (\\mu_R^2 - \\mu_N^2)\n$$\nUsing the difference of squares, $\\mu_R^2 - \\mu_N^2 = (\\mu_R - \\mu_N)(\\mu_R + \\mu_N)$, this simplifies to:\n$$\n= (\\mu_R - \\mu_N) [2x - (\\mu_R + \\mu_N)]\n$$\nSubstituting this back into the inequality:\n$$\n\\frac{(\\mu_R - \\mu_N)}{2\\sigma^{2}} [2x - (\\mu_R + \\mu_N)] \\ge \\ln\\left(\\frac{K p_N}{E p_R}\\right)\n$$\nNow, we must solve for $x$. Since it is given that $\\mu_R > \\mu_N$, the term $(\\mu_R - \\mu_N)$ is positive. We can multiply and divide without changing the direction of the inequality.\n$$\n2x - (\\mu_R + \\mu_N) \\ge \\frac{2\\sigma^{2}}{\\mu_R - \\mu_N} \\ln\\left(\\frac{K p_N}{E p_R}\\right)\n$$\n$$\n2x \\ge (\\mu_R + \\mu_N) + \\frac{2\\sigma^{2}}{\\mu_R - \\mu_N} \\ln\\left(\\frac{K p_N}{E p_R}\\right)\n$$\nFinally, dividing by $2$ gives the condition on $x$ for which the pollinator must probe:\n$$\nx \\ge \\frac{\\mu_R + \\mu_N}{2} + \\frac{\\sigma^{2}}{\\mu_R - \\mu_N} \\ln\\left(\\frac{K p_N}{E p_R}\\right)\n$$\nThis is of the form \"probe if and only if $x \\ge x^{\\ast}$\". Therefore, the optimal decision threshold $x^{\\ast}$ is the expression on the right-hand side. This expression correctly balances the sensory evidence (first term, the midpoint of the distributions) with the priors and payoffs (the logarithmic adjustment term).", "answer": "$$\\boxed{\\frac{\\mu_{R} + \\mu_{N}}{2} + \\frac{\\sigma^{2}}{\\mu_{R} - \\mu_{N}} \\ln\\left(\\frac{K p_{N}}{E p_{R}}\\right)}$$", "id": "2602882"}, {"introduction": "The relationship between plants and pollinators is a classic example of coevolution, where the evolutionary trajectory of each partner is shaped by the other. This practice moves beyond a one-sided decision problem to model the interaction as a strategic game, where the plant's fitness depends on the pollinator's effort, and vice-versa. Using the principles of game theory, you will derive the best-response functions for both players to find the Nash equilibrium of this mutualistic system, providing insight into the stability of cooperation and the potential for coordination failure. [@problem_id:2602899]", "problem": "A plant–pollinator interaction is modeled as a simultaneous-move game between a representative plant and a representative pollinator. The plant chooses a nonnegative nectar reward level per flower per unit time, denoted by $r \\ge 0$, and the pollinator chooses a nonnegative visitation effort, denoted by $e \\ge 0$. Ecological constraints imply that nectar production costs increase with visitation because high visitation forces more frequent replenishment, and handling time at high reward increases the marginal energetic cost of visitation. Assume the following payoffs per unit time:\n\n- Plant fitness (scaled) is given by\n$$\nU_{p}(r;e) \\;=\\; s \\, n \\, e \\, r \\;-\\; \\frac{1}{2}\\, c \\, \\bigl(1 + b\\, e\\bigr)\\, r^{2},\n$$\nwhere $s>0$ converts pollination service into seed success, $n>0$ converts product $e r$ into pollen transfer, $c>0$ is a baseline marginal cost parameter for nectar production, and $b>0$ scales the increase in nectar replenishment cost with visitation $e$.\n\n- Pollinator net energy intake (scaled utility) is given by\n$$\nU_{m}(e;r) \\;=\\; m \\, r \\, e \\;-\\; \\frac{1}{2}\\, k \\, \\bigl(1 + f\\, r\\bigr)\\, e^{2},\n$$\nwhere $m>0$ converts nectar reward into energetic benefit for the pollinator, $k>0$ is a baseline marginal cost parameter for effort, and $f>0$ scales the increase in effort cost with reward $r$ due to handling time.\n\nBoth payoff functions are strictly concave in the player’s own strategy for any fixed opponent strategy.\n\nTasks:\n\n- Using only the definition of a Nash equilibrium and first-order optimality under concavity, derive each player’s best-response function and solve analytically for all symmetric Nash equilibria $(r^{\\ast}, e^{\\ast})$ with $r^{\\ast} \\ge 0$ and $e^{\\ast} \\ge 0$.\n\n- Determine parameter conditions under which there exists a strictly positive (interior) equilibrium with $r^{\\ast} > 0$ and $e^{\\ast} > 0$. Explain, from first principles of strategic interaction in this ecological setting, when multiple equilibria occur and how this relates to coordination failure between plants and pollinators.\n\n- Express the interior Nash equilibrium strategy pair $(r^{\\ast}, e^{\\ast})$, when it exists, as a closed-form analytic expression in terms of $s, n, c, b, m, k,$ and $f$. Report your final answer as a single row vector $(r^{\\ast}, e^{\\ast})$; no numerical approximation is required, and no units are requested.", "solution": "The problem is subjected to validation prior to any attempt at a solution.\n\nFirst, we extract the givens verbatim from the problem statement.\nPlayers: A representative plant and a representative pollinator.\nStrategies: Plant chooses nectar reward level $r \\ge 0$. Pollinator chooses visitation effort $e \\ge 0$.\nPlant's Payoff Function: $U_{p}(r;e) = s \\, n \\, e \\, r - \\frac{1}{2}\\, c \\, (1 + b\\, e)\\, r^{2}$.\nPollinator's Payoff Function: $U_{m}(e;r) = m \\, r \\, e - \\frac{1}{2}\\, k \\, (1 + f\\, r)\\, e^{2}$.\nParameters: $s>0$, $n>0$, $c>0$, $b>0$, $m>0$, $k>0$, $f>0$.\nProperty: Both payoff functions are strictly concave in the player’s own strategy for any fixed opponent strategy.\nTasks:\n1. Derive best-response functions and solve for all non-negative Nash equilibria $(r^{\\ast}, e^{\\ast})$.\n2. Determine parameter conditions for a strictly positive (interior) equilibrium and explain the context of multiple equilibria and coordination failure.\n3. Express the interior Nash equilibrium as a closed-form analytic expression.\n\nNow, we validate the problem. The problem is a standard application of game theory to a question in evolutionary ecology, a topic within the specified STEM domain. It is scientifically grounded, modeling a mutualistic interaction with well-accepted assumptions of costs and benefits. The payoff functions are mathematically well-defined, and the stated concavity property ensures that first-order conditions are sufficient for finding best responses, which makes the problem well-posed. The terminology is precise and objective. There are no violations of scientific principles, no missing information, and no internal contradictions. The problem is valid. We will proceed with the solution.\n\nA Nash Equilibrium $(r^{\\ast}, e^{\\ast})$ is a strategy profile where neither player can improve their payoff by unilaterally changing their strategy. Given the strict concavity of the payoff functions, the best-response function for each player is found by setting the first partial derivative of their payoff function with respect to their own strategy to zero, provided the solution is non-negative.\n\nFirst, we determine the plant's best-response function, $BR_p(e)$, which is the value of $r$ that maximizes $U_p(r;e)$ for a given $e \\ge 0$.\n$$ \\frac{\\partial U_p}{\\partial r} = s \\, n \\, e - c(1 + b\\,e)r = 0 $$\nSolving for $r$ gives the plant's reaction function:\n$$ r(e) = \\frac{s \\, n \\, e}{c(1 + b\\,e)} $$\nSince all parameters ($s, n, c, b$) are positive and $e \\ge 0$, it follows that $r(e) \\ge 0$.\n\nSecond, we determine the pollinator's best-response function, $BR_m(r)$, which is the value of $e$ that maximizes $U_m(e;r)$ for a given $r \\ge 0$.\n$$ \\frac{\\partial U_m}{\\partial e} = m \\, r - k(1 + f\\,r)e = 0 $$\nSolving for $e$ gives the pollinator's reaction function:\n$$ e(r) = \\frac{m \\, r}{k(1 + f\\,r)} $$\nSince all parameters ($m, k, f$) are positive and $r \\ge 0$, it follows that $e(r) \\ge 0$.\n\nA Nash Equilibrium $(r^{\\ast}, e^{\\ast})$ must simultaneously satisfy both best-response functions:\n$$ r^{\\ast} = \\frac{s \\, n \\, e^{\\ast}}{c(1 + b\\,e^{\\ast})} \\quad \\text{and} \\quad e^{\\ast} = \\frac{m \\, r^{\\ast}}{k(1 + f\\,r^{\\ast})} $$\nWe analyze this system for its solutions.\nBy inspection, $(r^{\\ast}, e^{\\ast}) = (0, 0)$ is a solution. If $e^{\\ast}=0$, the first equation gives $r^{\\ast}=0$. If $r^{\\ast}=0$, the second equation gives $e^{\\ast}=0$. This is the trivial equilibrium, representing a state of no interaction between the plant and the pollinator.\n\nTo find any non-trivial, or interior, equilibria with $r^{\\ast} > 0$ and $e^{\\ast} > 0$, we substitute the expression for $e^{\\ast}$ into the first equation:\n$$ r^{\\ast} = \\frac{s \\, n}{c} \\frac{\\frac{m \\, r^{\\ast}}{k(1 + f\\,r^{\\ast})}}{1 + b\\left(\\frac{m \\, r^{\\ast}}{k(1 + f\\,r^{\\ast})}\\right)} $$\nSince we assume $r^{\\ast} > 0$, we can divide both sides by $r^{\\ast}$:\n$$ 1 = \\frac{s \\, n}{c} \\frac{\\frac{m}{k(1 + f\\,r^{\\ast})}}{\\frac{k(1 + f\\,r^{\\ast}) + b\\,m\\,r^{\\ast}}{k(1 + f\\,r^{\\ast})}} $$\n$$ 1 = \\frac{s \\, n \\, m}{c(k(1 + f\\,r^{\\ast}) + b\\,m\\,r^{\\ast})} $$\n$$ c(k + k\\,f\\,r^{\\ast} + b\\,m\\,r^{\\ast}) = s \\, n \\, m $$\n$$ c\\,k + c(k\\,f + b\\,m)r^{\\ast} = s \\, n \\, m $$\nWe solve for $r^{\\ast}$:\n$$ r^{\\ast} = \\frac{s \\, n \\, m - c \\, k}{c(k\\,f + b\\,m)} $$\nFor this to be a strictly positive equilibrium strategy, we must have $r^{\\ast} > 0$. Since all parameters in the denominator are positive, this condition requires the numerator to be positive:\n$$ s \\, n \\, m - c \\, k > 0 \\implies s \\, n \\, m > c \\, k $$\nIf this condition holds, we have a unique, strictly positive $r^{\\ast}$. The corresponding equilibrium effort $e^{\\ast}$ can be found by substituting this $r^{\\ast}$ into the pollinator's best response function. Alternatively, by symmetry, we can substitute $r^{\\ast}$ into the second best-response equation and solve for $e^{\\ast} > 0$. This yields:\n$$ e^{\\ast} = \\frac{m s n - k c}{k(c b + s n f)} $$\nThe positivity of $e^{\\ast}$ also depends on the same condition $s \\, n \\, m > c \\, k$.\n\nThus, for the existence of a strictly positive (interior) equilibrium, the necessary and sufficient condition is $s\\,n\\,m > c\\,k$. This inequality can be written as $\\frac{s\\,n\\,m}{c\\,k} > 1$. This condition has a clear ecological interpretation. The term $s\\,n\\,m$ is a product of terms related to the marginal benefits of the interaction, while $c\\,k$ is a product of baseline marginal costs. The condition states that for a mutualistic interaction to be self-sustaining, the product of marginal benefits must exceed the product of marginal costs at the origin (i.e., when $r$ and $e$ are close to zero).\n\nWhen $s\\,n\\,m > c\\,k$, there are two Nash equilibria: the trivial equilibrium $(0, 0)$ and the interior equilibrium $(r^{\\ast}, e^{\\ast})$. This is a classic coordination game. At the interior equilibrium, the payoffs are $U_p^{\\ast} = \\frac{1}{2}c(1+be^{\\ast})(r^{\\ast})^2 > 0$ and $U_m^{\\ast} = \\frac{1}{2}k(1+fr^{\\ast})(e^{\\ast})^2 > 0$, which are strictly greater than the zero payoffs at the trivial equilibrium. The interior equilibrium is therefore Pareto-superior. Coordination failure occurs if the system gets trapped at the $(0, 0)$ equilibrium because each player expects the other to choose a zero strategy. This is a fundamental problem in the evolution of cooperation: a mutually beneficial state exists, but reaching it requires coordinated \"investment\" from both parties. If this coordination is absent, the system remains in a state of no interaction, which is also evolutionarily stable.\n\nThe interior Nash equilibrium strategy pair $(r^{\\ast}, e^{\\ast})$ is given by the following closed-form expressions:\n$$ r^{\\ast} = \\frac{s \\, n \\, m - c \\, k}{c(k\\,f + b\\,m)} $$\n$$ e^{\\ast} = \\frac{s \\, n \\, m - c \\, k}{k(c\\,b + s\\,n\\,f)} $$\nThis is the required analytical result.", "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{s n m - c k}{c(k f + b m)} & \\frac{s n m - c k}{k(c b + s n f)} \\end{pmatrix} } $$", "id": "2602899"}, {"introduction": "Individual interactions between plants and pollinators are embedded within complex community-wide networks, and the structure of these networks has profound implications for ecosystem stability. This hands-on computational exercise elevates our perspective from dyadic interactions to the entire community, introducing you to the field of network ecology. You will implement algorithms to calculate key structural properties of a pollination network and simulate the cascading effects of species loss to quantify its robustness, gaining practical skills in computational analysis that are essential for modern ecology and conservation biology. [@problem_id:2602895]", "problem": "You are given bipartite plant–pollinator interaction matrices that represent empirical pollination networks, where plants form one guild and animal pollinators form the other. From first principles in network ecology, define the following for a bipartite adjacency matrix $A$ of size $I \\times J$ with entries $A_{ij} \\in \\{0,1\\}$ indicating the presence or absence of an interaction between plant $i$ and pollinator $j$:\n\n1. Connectance $C$ of a bipartite network is defined from the core ecological concept of realized interactions out of all possible interactions. Let $L = \\sum_{i=1}^{I} \\sum_{j=1}^{J} A_{ij}$ be the number of realized interactions. The connectance is $C = L / (I \\cdot J)$.\n\n2. Bipartite modularity $Q$ under the null model of independent connections constrained by degrees (Barber modularity) measures the excess of within-module interactions relative to a configuration model. Let $k_i^{(P)} = \\sum_{j=1}^{J} A_{ij}$ be the degree of plant $i$ and $k_j^{(A)} = \\sum_{i=1}^{I} A_{ij}$ be the degree of pollinator $j$. Assign each node (plant or pollinator) to a module label $g$ given by its connected component in the undirected bipartite graph induced by $A$ (so all nodes within the same connected component share the same module label; isolated nodes each form their own module). Define the Kronecker delta $\\delta(g_i,g_j) = 1$ if plant $i$ and pollinator $j$ share a module label and $\\delta(g_i,g_j) = 0$ otherwise. The bipartite modularity is\n$$\nQ = \n\\begin{cases}\n\\frac{1}{L} \\sum_{i=1}^{I} \\sum_{j=1}^{J} \\left( A_{ij} - \\frac{k_i^{(P)} \\, k_j^{(A)}}{L} \\right) \\delta(g_i,g_j), & \\text{if } L > 0, \\\\\n0, & \\text{if } L = 0.\n\\end{cases}\n$$\n\n3. Secondary extinction under sequential pollinator loss is derived from the ecological principle that a plant persists if and only if it retains at least one pollinator. Consider a removal sequence of pollinators $\\pi$ of length $J$ and denote by $k_i^{(P)}(t)$ the remaining degree of plant $i$ after the first $t$ pollinators in $\\pi$ have been removed (with $t \\in \\{0,1,\\dots,J\\}$ and $k_i^{(P)}(0) = k_i^{(P)}$). Define the plant survival fraction at step $t$ as\n$$\ns(t) = \\frac{1}{I} \\sum_{i=1}^{I} \\mathbf{1}\\!\\left( k_i^{(P)}(t) > 0 \\right),\n$$\nwhere $\\mathbf{1}(\\cdot)$ is the indicator function. The network robustness $R$ to pollinator loss is the discrete area under the survival curve,\n$$\nR(\\pi) = \\frac{1}{J} \\sum_{t=0}^{J} s(t).\n$$\nFor random sequences, estimate robustness by Monte Carlo averaging over $n$ independent permutations with a fixed pseudorandom seed $s$,\n$$\n\\widehat{R} = \\frac{1}{n} \\sum_{\\ell=1}^{n} R(\\pi^{(\\ell)}).\n$$\n\nYour task is to write a complete program that, for each test case below, computes $C$, $Q$, and an $R$ defined by the specified removal protocol. All outputs must be rounded to $6$ decimal places. The final program must produce a single line that is a list of lists, where each inner list is $[C,Q,R]$ for a test case, printed as a Python-style list literal without spaces (e.g., $[[0.1,0.2,0.3],[...],...]$).\n\nDefinitions to use:\n- The network is bipartite with $I$ plants and $J$ pollinators.\n- The adjacency matrix $A$ has entries $A_{ij} \\in \\{0,1\\}$.\n- The connectance is $C = L/(I \\cdot J)$ with $L = \\sum_{i=1}^{I}\\sum_{j=1}^{J} A_{ij}$.\n- The module assignment for modularity $Q$ is given by connected components of the undirected bipartite graph induced by $A$; isolated nodes each form their own module.\n- If $L=0$, set $Q=0$ by convention.\n- The robustness $R$ is the area under the plant survival curve $s(t)$, with $t$ measured as the number of pollinators removed. At $t=0$, plants with zero initial degree contribute $0$ to $s(0)$.\n\nAngle units are not applicable. There are no physical units. All fractions must be expressed as decimals.\n\nTest Suite:\nFor each test case $k$, you are given $(A^{(k)}, \\text{removal protocol parameters})$. Implement the specified protocol exactly to ensure deterministic results.\n\n- Test case $1$ (general case; random-removal Monte Carlo):\n  - $I=4$, $J=5$,\n  - $$A^{(1)} = \\begin{bmatrix}\n  1 & 1 & 0 & 0 & 1 \\\\\n  0 & 1 & 1 & 0 & 0 \\\\\n  1 & 0 & 0 & 1 & 0 \\\\\n  0 & 0 & 1 & 1 & 0 \\\\\n  \\end{bmatrix}$$,\n  - Removal protocol: random pollinator permutations with seed $s=17$ and $n=200$ independent permutations. Compute $\\widehat{R}$.\n\n- Test case $2$ (boundary case; fully connected; targeted removal):\n  - $I=2$, $J=2$,\n  - $$A^{(2)} = \\begin{bmatrix}\n  1 & 1 \\\\\n  1 & 1 \\\\\n  \\end{bmatrix}$$,\n  - Removal protocol: targeted highest-degree-first removal of pollinators computed once from initial degrees; break ties by ascending pollinator index. Compute $R$ for this single sequence.\n\n- Test case $3$ (edge case; disconnected with isolated nodes; random-removal Monte Carlo):\n  - $I=3$, $J=3$,\n  - $$A^{(3)} = \\begin{bmatrix}\n  1 & 0 & 0 \\\\\n  1 & 0 & 0 \\\\\n  0 & 0 & 0 \\\\\n  \\end{bmatrix}$$,\n  - Removal protocol: random pollinator permutations with seed $s=5$ and $n=1000$ independent permutations. Compute $\\widehat{R}$.\n\nProgram requirements:\n- Do not read input; hard-code the test cases.\n- For each test case, compute $C$, $Q$, and $R$ (or $\\widehat{R}$) as defined above.\n- Round each of $C$, $Q$, and $R$ to $6$ decimal places.\n- Output a single line that is a Python-style list literal of the three triplets, e.g., $[[C_1,Q_1,R_1],[C_2,Q_2,R_2],[C_3,Q_3,R_3]]$, with no spaces.\n\nYour solution must be based strictly on the foundational definitions above and must not invoke any external network analysis libraries or rely on unspecified modularity maximization. All modules for $Q$ must be the connected components induced by $A$ as defined in this problem.", "solution": "The problem statement is subjected to rigorous validation and is found to be valid. It is scientifically grounded in established principles of network ecology, well-posed with precise mathematical definitions and deterministic computational procedures, and articulated with objective, unambiguous language. All necessary data and parameters for the test cases are fully provided. Therefore, I will proceed with a complete solution.\n\nThe task is to compute three network metrics—connectance ($C$), bipartite modularity ($Q$), and robustness ($R$)—for three given plant-pollinator interaction networks. The solution for each metric is derived directly from the definitions provided.\n\n**1. Calculation of Connectance ($C$)**\n\nConnectance is defined as the ratio of realized interactions ($L$) to all possible interactions in the bipartite network ($I \\times J$). The number of realized interactions, $L$, is the total number of non-zero entries in the adjacency matrix $A$.\nThe formula is:\n$$\nC = \\frac{L}{I \\cdot J} = \\frac{\\sum_{i=1}^{I} \\sum_{j=1}^{J} A_{ij}}{I \\cdot J}\n$$\nThis calculation is straightforward for each test case by summing the elements of the given matrix $A$ and dividing by the product of its dimensions.\n\n**2. Calculation of Bipartite Modularity ($Q$)**\n\nThe bipartite modularity, $Q$, quantifies the degree to which a network is divided into distinct modules. The problem specifies that modules are defined by the connected components of the undirected bipartite graph induced by the adjacency matrix $A$. This prescription circumvents the otherwise complex task of modularity maximization.\n\nThe formula for $Q$ is:\n$$\nQ = \\frac{1}{L} \\sum_{i=1}^{I} \\sum_{j=1}^{J} \\left( A_{ij} - \\frac{k_i^{(P)} \\, k_j^{(A)}}{L} \\right) \\delta(g_i,g_j)\n$$\nwhere $\\delta(g_i,g_j)=1$ if plant $i$ and pollinator $j$ are in the same module (connected component), and $0$ otherwise. If $L=0$, $Q=0$.\n\nThis expression can be simplified by summing over modules instead of individual nodes. Let $\\mathcal{M}$ be the set of modules (connected components). Let $L_m$ be the number of links within module $m$. Since the modules are connected components, any link $A_{ij}=1$ must have its endpoints $i$ and $j$ within the same component. Therefore, $\\sum_{m \\in \\mathcal{M}} L_m = L$.\n\nThe sum can be partitioned by module:\n$$\nQ = \\frac{1}{L} \\sum_{m \\in \\mathcal{M}} \\sum_{i \\in m_P, j \\in m_A} \\left( A_{ij} - \\frac{k_i^{(P)} k_j^{(A)}}{L} \\right)\n$$\nwhere $m_P$ and $m_A$ are the sets of plant and pollinator nodes in module $m$. This simplifies to:\n$$\nQ = \\frac{1}{L} \\sum_{m \\in \\mathcal{M}} \\left( L_m - \\frac{(\\sum_{i \\in m_P} k_i^{(P)}) (\\sum_{j \\in m_A} k_j^{(A)})}{L} \\right)\n$$\nFor a connected component $m$, the sum of degrees of its plant nodes equals the sum of degrees of its pollinator nodes, which equals the number of links within that component, $L_m$. That is, $\\sum_{i \\in m_P} k_i^{(P)} = \\sum_{j \\in m_A} k_j^{(A)} = L_m$.\nSubstituting this yields:\n$$\nQ = \\sum_{m \\in \\mathcal{M}} \\left( \\frac{L_m}{L} - \\left(\\frac{L_m}{L}\\right)^2 \\right)\n$$\nLetting $e_m = L_m/L$ be the fraction of links in module $m$, the formula becomes $Q = \\sum_{m \\in \\mathcal{M}} (e_m - e_m^2)$.\n\nThe algorithm is as follows:\n1. Construct the bipartite graph from matrix $A$. The graph has $I+J$ nodes.\n2. Find all connected components using Breadth-First Search (BFS) or Depth-First Search (DFS). Each component is a module.\n3. For each module $m$, calculate the number of links $L_m$ it contains.\n4. Calculate $Q$ using the simplified formula.\n\n**3. Calculation of Network Robustness ($R$)**\n\nRobustness measures the persistence of plants following the sequential removal of pollinators. We must simulate this process according to the specified removal protocol for each test case.\n\nThe procedure for a single removal sequence $\\pi$ is:\n1. Initialize the survival fraction list. At step $t=0$ (before any removals), calculate the initial plant degrees $k_i^{(P)}(0)$. The survival fraction is $s(0) = \\frac{1}{I} \\sum_{i=1}^{I} \\mathbf{1}(k_i^{(P)}(0) > 0)$.\n2. For each step $t$ from $1$ to $J$, remove the $t$-th pollinator in the sequence $\\pi$. This corresponds to setting a column of the adjacency matrix to zero.\n3. After each removal, recalculate the degrees of all plants, $k_i^{(P)}(t)$, and compute the new survival fraction $s(t)$.\n4. After all $J$ pollinators are removed, we have a series of $J+1$ survival fractions: $s(0), s(1), \\dots, s(J)$. Note that $s(J)$ is always $0$.\n5. The robustness for this sequence is calculated as specified:\n$$\nR(\\pi) = \\frac{1}{J} \\sum_{t=0}^{J} s(t)\n$$\n\nFor each test case, the protocol is:\n- **Test cases 1 and 3 (Random Removal)**: An estimate $\\widehat{R}$ is obtained by averaging $R(\\pi^{(\\ell)})$ over $n$ independent random permutations $\\pi^{(\\ell)}$, generated using a fixed pseudorandom seed for reproducibility.\n- **Test case 2 (Targeted Removal)**: A single, deterministic removal sequence is constructed by sorting pollinators in descending order of their initial degree, with ties broken by ascending pollinator index. $R$ is calculated for this one sequence.\n\nAll computations are performed, and the final results for $[C, Q, R]$ for each test case are rounded to $6$ decimal places.\n\n**Calculations for Test Cases:**\n\n- **Test Case 1**: $I=4, J=5$. $L=8$. $C = 8/20 = 0.4$. The graph is fully connected, resulting in one module. Thus $L_1=L=8$, $e_1=1$, and $Q = 1 - 1^2 = 0$. $\\widehat{R}$ is computed via Monte Carlo simulation.\n- **Test Case 2**: $I=2, J=2$. $L=4$. $C = 4/4 = 1.0$. The graph is a complete bipartite graph, hence one connected component. $Q=0$. For targeted removal, pollinator degrees are both $2$. Tie-breaking by index gives removal sequence $(0, 1)$. This leads to $s(0)=1.0, s(1)=1.0, s(2)=0.0$. $R = (1.0+1.0+0.0)/2 = 1.0$.\n- **Test Case 3**: $I=3, J=3$. $L=2$. $C = 2/9 \\approx 0.222222$. The graph has one non-trivial component containing all links. Thus, $L_1=L=2$, $e_1=1$, and $Q = 1 - 1^2 = 0$. $\\widehat{R}$ is computed via Monte Carlo simulation.\n\nThe implementation will follow these principles precisely.", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases, calculating Connectance (C),\n    Bipartite Modularity (Q), and Robustness (R) for each.\n    \"\"\"\n\n    def calculate_c(A):\n        \"\"\"Calculates connectance C.\"\"\"\n        if A.size == 0:\n            return 0.0\n        I, J = A.shape\n        L = np.sum(A)\n        return L / (I * J)\n\n    def calculate_q(A):\n        \"\"\"Calculates bipartite modularity Q.\"\"\"\n        I, J = A.shape\n        L = np.sum(A)\n        if L == 0:\n            return 0.0\n\n        num_nodes = I + J\n        adj = [[] for _ in range(num_nodes)]\n        for i in range(I):\n            for j in range(J):\n                if A[i, j] == 1:\n                    adj[i].append(I + j)\n                    adj[I + j].append(i)\n\n        visited = [False] * num_nodes\n        components = []\n        for i in range(num_nodes):\n            if not visited[i]:\n                current_component = []\n                queue = deque([i])\n                visited[i] = True\n                while queue:\n                    u = queue.popleft()\n                    current_component.append(u)\n                    for v in adj[u]:\n                        if not visited[v]:\n                            visited[v] = True\n                            queue.append(v)\n                components.append(current_component)\n\n        L_m_list = []\n        for comp in components:\n            plant_nodes = sorted([node for node in comp if node < I])\n            pollinator_nodes = sorted([node - I for node in comp if node >= I])\n\n            if not plant_nodes or not pollinator_nodes:\n                L_m_list.append(0)\n            else:\n                sub_matrix = A[np.ix_(plant_nodes, pollinator_nodes)]\n                L_m = np.sum(sub_matrix)\n                L_m_list.append(L_m)\n\n        q_val = 0.0\n        for L_m in L_m_list:\n            if L > 0:\n                e_m = L_m / L\n                q_val += e_m - e_m**2\n        return q_val\n\n    def _calculate_r_for_sequence(A, pi):\n        \"\"\"Helper function to calculate R for a single permutation.\"\"\"\n        I, J = A.shape\n        if I == 0: return 0.0 # No plants to survive\n        if J == 0:\n             k_p_0 = np.sum(A, axis=1) if A.shape[1] > 0 else np.zeros(I)\n             s0 = np.sum(k_p_0 > 0) / I\n             return s0 # With J=0, sum is just s(0) and R formula is undefined.\n                      # Per problem context, J>=1 for all tests.\n\n        A_current = A.copy()\n        s_values = []\n\n        # t=0\n        plant_degrees = np.sum(A_current, axis=1)\n        s_values.append(np.sum(plant_degrees > 0) / I)\n\n        # t=1 to J\n        for pollinator_idx in pi:\n            A_current[:, pollinator_idx] = 0\n            plant_degrees = np.sum(A_current, axis=1)\n            s_values.append(np.sum(plant_degrees > 0) / I)\n        \n        return np.sum(s_values) / J\n    \n    def calculate_r(A, protocol):\n        \"\"\"Calculates robustness R based on the specified protocol.\"\"\"\n        I, J = A.shape\n        removal_type = protocol['type']\n        \n        if removal_type == 'random':\n            seed = protocol['seed']\n            n = protocol['n']\n            rng = np.random.default_rng(seed)\n            r_values = []\n            for _ in range(n):\n                pi = rng.permutation(J)\n                r_values.append(_calculate_r_for_sequence(A, pi))\n            return np.mean(r_values)\n\n        elif removal_type == 'targeted':\n            pollinator_degrees = np.sum(A, axis=0)\n            # Sort by degree (desc) then by index (asc)\n            indices = np.arange(J)\n            sorted_indices = sorted(indices, key=lambda i: (-pollinator_degrees[i], i))\n            pi = np.array(sorted_indices)\n            return _calculate_r_for_sequence(A, pi)\n        \n        else:\n            raise ValueError(\"Unknown removal protocol\")\n\n    test_cases = [\n        {\n            \"A\": np.array([\n                [1, 1, 0, 0, 1],\n                [0, 1, 1, 0, 0],\n                [1, 0, 0, 1, 0],\n                [0, 0, 1, 1, 0]\n            ]),\n            \"protocol\": {\"type\": \"random\", \"seed\": 17, \"n\": 200}\n        },\n        {\n            \"A\": np.array([\n                [1, 1],\n                [1, 1]\n            ]),\n            \"protocol\": {\"type\": \"targeted\"}\n        },\n        {\n            \"A\": np.array([\n                [1, 0, 0],\n                [1, 0, 0],\n                [0, 0, 0]\n            ]),\n            \"protocol\": {\"type\": \"random\", \"seed\": 5, \"n\": 1000}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        protocol = case[\"protocol\"]\n        \n        C = calculate_c(A)\n        Q = calculate_q(A)\n        R = calculate_r(A, protocol)\n        \n        results.append([round(C, 6), round(Q, 6), round(R, 6)])\n\n    # Format the final output string as a list literal with no spaces\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2602895"}]}