{"hands_on_practices": [{"introduction": "The species is a fundamental unit in the hierarchy of life, yet its boundaries can be ambiguous. This practice dives into modern population genetics by asking you to implement a Bayesian model comparison to weigh evidence for one versus two species using genetic data [@problem_id:2580969]. You will derive the Bayes factor from first principles, providing a powerful tool for quantitative species delimitation and a hands-on understanding of how statistical evidence is formally evaluated in evolutionary biology.", "problem": "You are studying the hierarchical organization of the biosphere at the species level by comparing two alternative hypotheses for how diploid genotypes are organized across space in a salamander ring species scenario. The two hypotheses are: $H_1$ (one species): both geographic groups are a single panmictic species sharing the same allele frequency at each locus; $H_2$ (two species): the two geographic groups are distinct species with independent allele frequencies at each locus. Use fundamental population genetic modeling assumptions that within each species, diploid individuals conform to Hardy–Weinberg Equilibrium (HWE), and that across unlinked loci, data are independent given the allele frequencies. Under HWE, allele counts are sufficient statistics for genotype data. Assume a Beta prior $\\mathrm{Beta}(\\alpha,\\beta)$ on the allele frequency for each species at each locus, with $\\alpha=\\beta=1$ (uniform prior on allele frequency). For each locus $\\ell$, let the data be $k_{1\\ell}$ successes (allele $A$) out of $m_{1\\ell}$ total Bernoulli trials (chromosomes) in group $1$, and $k_{2\\ell}$ out of $m_{2\\ell}$ in group $2$.\n\nStarting only from the following foundations:\n- The binomial sampling model for allele counts under Hardy–Weinberg Equilibrium (HWE).\n- The Beta prior $\\mathrm{Beta}(\\alpha,\\beta)$ on the allele frequency parameter $p$.\n- The Beta function identity $\\mathrm{B}(x,y)=\\dfrac{\\Gamma(x)\\Gamma(y)}{\\Gamma(x+y)}$ and its role in conjugate Beta–Binomial integrals.\n- Conditional independence across unlinked loci.\n\nDerive the marginal likelihood under $H_1$ and under $H_2$ for one locus by analytically integrating out allele frequencies, then derive the Bayes factor (BF), defined as $B_{21}=\\dfrac{P(D\\mid H_2)}{P(D\\mid H_1)}$, across multiple loci as a product of per-locus ratios. Your program must compute, for each test case, the total evidence across all loci as $\\log_{10} B_{21}$.\n\nTest suite. For each test case below, each locus is specified as a quadruple $(k_1,m_1,k_2,m_2)$ using allele counts (for diploids, $m_i$ is twice the number of sampled individuals). All loci are unlinked, and use $\\alpha=\\beta=1$. Compute $\\log_{10} B_{21}$ for each case, rounding to $6$ decimal places.\n\n- Test case $1$ (strong terminal divergence, consistent with distinct terminal forms in a ring species):\n  - Loci: $(4,4,0,4)$, $(4,4,0,4)$, $(3,4,1,4)$, $(4,4,0,4)$, $(3,4,1,4)$.\n- Test case $2$ (little divergence, consistent with a single species along the ring interior):\n  - Loci: $(2,4,2,4)$, $(1,4,1,4)$, $(3,4,3,4)$, $(2,4,2,4)$, $(2,4,2,4)$.\n- Test case $3$ (intermediate divergence, representing partial differentiation at the contact zone):\n  - Loci: $(3,4,2,4)$, $(2,4,1,4)$, $(3,4,2,4)$, $(2,4,1,4)$, $(2,4,2,4)$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry equal to $\\log_{10} B_{21}$ for one test case, rounded to $6$ decimal places, in the same order as above. For example, an acceptable format is [$x_1,x_2,x_3$] where each $x_i$ is a float with exactly $6$ digits after the decimal point. No other output is permitted.", "solution": "The problem as stated is subjected to rigorous validation. All provided assumptions and data are explicit and self-contained. The framework is grounded in fundamental principles of population genetics and Bayesian statistics, specifically utilizing the Beta-Binomial conjugate model, which is standard for analyzing allele count data. The problem is well-posed, with a unique solution derivable from the provided information. The hypotheses to be compared, $H_1$ and $H_2$, are clearly defined and mutually exclusive models for the observed data. The objective is unambiguous and requires a standard calculation in Bayesian model selection. Therefore, the problem is deemed valid and a formal solution will now be derived.\n\nThe task is to compute the Bayes factor, $B_{21}$, which compares two hypotheses for population structure. Let $D$ be the observed data, which consists of allele counts across $L$ unlinked loci. For each locus $\\ell \\in \\{1, \\dots, L\\}$, the data are $D_\\ell = (k_{1\\ell}, m_{1\\ell}, k_{2\\ell}, m_{2\\ell})$, where $k_{i\\ell}$ is the count of allele '$A$' out of $m_{i\\ell}$ total alleles sampled from geographic group $i$.\n\nThe Bayes factor is defined as the ratio of the marginal likelihoods of the data under the two hypotheses:\n$$ B_{21} = \\frac{P(D \\mid H_2)}{P(D \\mid H_1)} $$\nSince the loci are unlinked, the data are conditionally independent across loci given a hypothesis. Thus, the total Bayes factor is the product of the per-locus Bayes factors:\n$$ B_{21} = \\prod_{\\ell=1}^{L} \\frac{P(D_\\ell \\mid H_2)}{P(D_\\ell \\mid H_1)} = \\prod_{\\ell=1}^{L} B_{21, \\ell} $$\nThe required output is the logarithm base $10$ of this quantity, which is the sum of the per-locus log Bayes factors:\n$$ \\log_{10}(B_{21}) = \\sum_{\\ell=1}^{L} \\log_{10}(B_{21, \\ell}) $$\nWe proceed by deriving the marginal likelihood for a single locus $\\ell$. We will omit the subscript $\\ell$ for clarity in this section.\n\nThe marginal likelihood, or evidence, for a model is obtained by integrating the likelihood function over the prior distribution of the parameters. The general form is $P(D \\mid H) = \\int P(D \\mid \\theta, H) P(\\theta \\mid H) d\\theta$.\nThe sampling distribution for allele counts is Binomial. For a sample of size $m$ with an allele frequency $p$, the probability of observing $k$ copies of the allele is:\n$$ P(k \\mid m, p) = \\binom{m}{k} p^k (1-p)^{m-k} $$\nThe prior distribution for the allele frequency $p$ is a Beta distribution:\n$$ P(p \\mid \\alpha, \\beta) = \\frac{p^{\\alpha-1} (1-p)^{\\beta-1}}{B(\\alpha, \\beta)} $$\nwhere $B(\\alpha, \\beta) = \\frac{\\Gamma(\\alpha)\\Gamma(\\beta)}{\\Gamma(\\alpha+\\beta)}$ is the Beta function. The problem specifies a uniform prior, which corresponds to setting hyperparameters $\\alpha=1$ and $\\beta=1$.\n\n**Marginal Likelihood under $H_1$ (One Species):**\nUnder $H_1$, both groups share a single allele frequency $p$. The data from both groups, $D = (k_1, m_1, k_2, m_2)$, can be pooled. The total number of successes is $k_{tot} = k_1 + k_2$ and the total number of trials is $m_{tot} = m_1 + m_2$. The likelihood of the data given $p$ is:\n$$ P(D \\mid p, H_1) = P(k_1 \\mid m_1, p) P(k_2 \\mid m_2, p) = \\binom{m_1}{k_1} p^{k_1} (1-p)^{m_1-k_1} \\binom{m_2}{k_2} p^{k_2} (1-p)^{m_2-k_2} $$\n$$ P(D \\mid p, H_1) = \\binom{m_1}{k_1} \\binom{m_2}{k_2} p^{k_{tot}} (1-p)^{m_{tot}-k_{tot}} $$\nThe marginal likelihood is the integral of the likelihood over the prior on $p$:\n$$ P(D \\mid H_1) = \\int_0^1 \\binom{m_1}{k_1} \\binom{m_2}{k_2} p^{k_{tot}} (1-p)^{m_{tot}-k_{tot}} \\frac{p^{\\alpha-1} (1-p)^{\\beta-1}}{B(\\alpha, \\beta)} dp $$\n$$ P(D \\mid H_1) = \\frac{\\binom{m_1}{k_1} \\binom{m_2}{k_2}}{B(\\alpha, \\beta)} \\int_0^1 p^{k_{tot}+\\alpha-1} (1-p)^{m_{tot}-k_{tot}+\\beta-1} dp $$\nRecognizing the integral as the definition of the Beta function, we obtain the Beta-Binomial probability:\n$$ P(D \\mid H_1) = \\binom{m_1}{k_1} \\binom{m_2}{k_2} \\frac{B(k_{tot}+\\alpha, m_{tot}-k_{tot}+\\beta)}{B(\\alpha, \\beta)} $$\n\n**Marginal Likelihood under $H_2$ (Two Species):**\nUnder $H_2$, the two groups have independent allele frequencies, $p_1$ and $p_2$, each with an independent prior $P(p_i \\mid \\alpha, \\beta) = \\mathrm{Beta}(\\alpha, \\beta)$. The likelihood factorizes, and so does the marginal likelihood integral:\n$$ P(D \\mid H_2) = \\left( \\int_0^1 P(k_1 \\mid m_1, p_1) P(p_1) dp_1 \\right) \\times \\left( \\int_0^1 P(k_2 \\mid m_2, p_2) P(p_2) dp_2 \\right) $$\nEach term is a separate Beta-Binomial calculation:\n$$ P(D \\mid H_2) = \\left( \\binom{m_1}{k_1} \\frac{B(k_1+\\alpha, m_1-k_1+\\beta)}{B(\\alpha, \\beta)} \\right) \\times \\left( \\binom{m_2}{k_2} \\frac{B(k_2+\\alpha, m_2-k_2+\\beta)}{B(\\alpha, \\beta)} \\right) $$\n\n**Bayes Factor for a Single Locus:**\nWe now form the ratio for $B_{21, \\ell}$. The binomial coefficient terms $\\binom{m_1}{k_1}$ and $\\binom{m_2}{k_2}$ cancel, as does one $B(\\alpha, \\beta)$ term:\n$$ B_{21} = \\frac{P(D \\mid H_2)}{P(D \\mid H_1)} = \\frac{B(k_1+\\alpha, m_1-k_1+\\beta) \\cdot B(k_2+\\alpha, m_2-k_2+\\beta)}{B(\\alpha, \\beta) \\cdot B(k_1+k_2+\\alpha, m_1+m_2-k_1-k_2+\\beta)} $$\nFor the specified uniform prior, $\\alpha=1$ and $\\beta=1$. This simplifies the expression, as $B(1, 1) = \\frac{\\Gamma(1)\\Gamma(1)}{\\Gamma(2)} = 1$.\n$$ B_{21} = \\frac{B(k_1+1, m_1-k_1+1) \\cdot B(k_2+1, m_2-k_2+1)}{B(k_1+k_2+1, m_1+m_2-k_1-k_2+1)} $$\nTo avoid numerical instability with very large or small numbers from factorials, computation must be performed in log-space using the log-gamma function, $\\ln \\Gamma(x)$. The natural logarithm of the Beta function is $\\ln B(x, y) = \\ln \\Gamma(x) + \\ln \\Gamma(y) - \\ln \\Gamma(x+y)$. The natural logarithm of the per-locus Bayes factor is:\n$$ \\ln(B_{21, \\ell}) = \\ln B(k_{1\\ell}+1, m_{1\\ell}-k_{1\\ell}+1) + \\ln B(k_{2\\ell}+1, m_{2\\ell}-k_{2\\ell}+1) - \\ln B(k_{1\\ell}+k_{2\\ell}+1, m_{1\\ell}+m_{2\\ell}-k_{1\\ell}-k_{2\\ell}+1) $$\nThe total log Bayes factor across all loci is the sum of these per-locus terms:\n$$ \\ln(B_{21}) = \\sum_{\\ell=1}^{L} \\ln(B_{21, \\ell}) $$\nFinally, to obtain the result in base $10$, we use the change of base formula:\n$$ \\log_{10}(B_{21}) = \\frac{\\ln(B_{21})}{\\ln(10)} $$\nThe algorithm is to iterate through each test case, and for each case, iterate through its loci. For each locus, calculate $\\ln(B_{21, \\ell})$ using the above formula with log-gamma functions. Sum these values, convert to base $10$, and report the result.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef solve():\n    \"\"\"\n    Computes the log10 Bayes Factor (B_21) for species delimitation\n    based on allele count data across multiple loci.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each locus is a tuple (k1, m1, k2, m2).\n    test_cases = [\n        # Test case 1 (strong terminal divergence)\n        [\n            (4, 4, 0, 4),\n            (4, 4, 0, 4),\n            (3, 4, 1, 4),\n            (4, 4, 0, 4),\n            (3, 4, 1, 4),\n        ],\n        # Test case 2 (little divergence)\n        [\n            (2, 4, 2, 4),\n            (1, 4, 1, 4),\n            (3, 4, 3, 4),\n            (2, 4, 2, 4),\n            (2, 4, 2, 4),\n        ],\n        # Test case 3 (intermediate divergence)\n        [\n            (3, 4, 2, 4),\n            (2, 4, 1, 4),\n            (3, 4, 2, 4),\n            (2, 4, 1, 4),\n            (2, 4, 2, 4),\n        ],\n    ]\n\n    # Hyperparameters for the Beta prior. a=b=1 corresponds to a uniform prior.\n    alpha = 1.0\n    beta = 1.0\n\n    def calculate_ln_B21_for_locus(k1, m1, k2, m2, a, b):\n        \"\"\"\n        Calculates the natural logarithm of the Bayes Factor B_21 for a single locus.\n        B_21 = P(Data|H2) / P(Data|H1)\n        \"\"\"\n        # Calculate log of Beta function, ln B(x, y) = gammaln(x) + gammaln(y) - gammaln(x+y)\n\n        # Numerator of B_21: Product of Beta functions for H2 (two independent species)\n        # ln( B(k1+a, m1-k1+b) * B(k2+a, m2-k2+b) )\n        ln_num = (gammaln(k1 + a) + gammaln(m1 - k1 + b) - gammaln(m1 + a + b)) + \\\n                 (gammaln(k2 + a) + gammaln(m2 - k2 + b) - gammaln(m2 + a + b))\n\n        # Denominator of B_21: Product of Beta functions for H1 (one species, pooled data)\n        # ln( B(a,b) * B(k1+k2+a, m1+m2-k1-k2+b) )\n        k_tot = k1 + k2\n        m_tot = m1 + m2\n        ln_den = (gammaln(a) + gammaln(b) - gammaln(a + b)) + \\\n                 (gammaln(k_tot + a) + gammaln(m_tot - k_tot + b) - gammaln(m_tot + a + b))\n        \n        # ln(B_21) = ln(numerator) - ln(denominator)\n        ln_B21 = ln_num - ln_den\n        return ln_B21\n\n    results = []\n    for case_loci in test_cases:\n        total_ln_B21 = 0.0\n        for locus in case_loci:\n            k1, m1, k2, m2 = locus\n            total_ln_B21 += calculate_ln_B21_for_locus(k1, m1, k2, m2, alpha, beta)\n        \n        # Convert total natural log Bayes Factor to log base 10\n        log10_B21 = total_ln_B21 / np.log(10)\n        \n        # Format the result to 6 decimal places\n        results.append(f\"{log10_B21:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2580969"}, {"introduction": "Populations are not isolated but are connected by the movement of individuals across landscapes, forming metapopulations. This exercise explores the crucial concept of landscape connectivity by modeling how different organisms perceive and traverse a heterogeneous environment [@problem_id:2580971]. By implementing both least-cost path and circuit-theory methods, you will gain practical skills in spatial analysis and appreciate how dispersal ability shapes the geographic organization of life.", "problem": "A landscape can be abstracted as a gridded resistance surface where each cell encodes the movement difficulty experienced by organisms. In the hierarchical organization of the biosphere, movement of individuals across landscapes scales up to population connectivity and metapopulation dynamics, affecting communities and ecosystems. Two complementary measures of functional connectivity used in comparative zoology and botany are the least-cost path and circuit-theory effective resistance. The least-cost path approximates the single most efficient route used by an individual, whereas circuit-theory effective resistance aggregates all possible routes and quantifies redundancy of pathways. This problem asks you to implement both measures for two taxa, a pollinating insect and a wind-dispersed tree, using a single base resistance surface that is transformed by species-specific perception rules.\n\nFundamental base and definitions to be used:\n- A resistance surface is a matrix of nonnegative movement resistances. Movement along an undirected edge between adjacent cells has an edge resistance equal to the path length multiplied by the mean of the endpoint cell resistances.\n- The least-cost path cost between a source and a target is the minimum, over all paths connecting them through the grid, of the sum of edge resistances along the path. In continuous terms, this is a discrete approximation to the line integral of resistance along a path.\n- Circuit-theory connectivity maps the grid to a resistor network, where adjacent cells are connected by resistors. The conductance of an edge is the reciprocal of its edge resistance. By Ohm’s Law and Kirchhoff’s Current Law, injecting unit current at a source cell and extracting unit current at a target cell yields a voltage field whose potential difference between the source and target equals the effective resistance between them. Formally, if $L$ is the weighted graph Laplacian constructed from conductances, the potentials $V$ satisfy $L V = I$ with current injection vector $I$ having $+1$ at the source and $-1$ at the target and $0$ elsewhere, after fixing a reference potential. The effective resistance is $R_{\\mathrm{eff}} = V_s - V_t$ for unit current.\n- Species-specific perception of the same base surface is modeled by a monotone transformation $R_{\\mathrm{species}}(i,j) = \\left(R_{\\mathrm{base}}(i,j)\\right)^{\\alpha}$ with exponent $\\alpha$ that differs between species.\n\nGrid and neighborhood:\n- Use an $8$-neighbor scheme on the grid. For orthogonal moves, the step length is $1$. For diagonal moves, the step length is $\\sqrt{2}$. If two adjacent cells have resistances $r_u$ and $r_v$, the edge resistance is $R_{uv} = d \\cdot \\frac{r_u + r_v}{2}$ where $d$ is the step length. The corresponding edge conductance is $C_{uv} = 1 / R_{uv}$.\n- Use zero-based indexing for grid coordinates, specified as ordered pairs $(\\text{row}, \\text{col})$.\n\nSpecies parameters:\n- Pollinator exponent $\\alpha_{\\mathrm{pol}} = 1.2$.\n- Wind-dispersed tree exponent $\\alpha_{\\mathrm{tree}} = 0.8$.\n\nTasks to implement:\n- Given a base resistance surface and a pair of source and target cells, compute for each species:\n  1. The least-cost path cost between the source and target using the species-specific resistance surface and the edge resistance rule above.\n  2. The circuit-theory effective resistance between the source and target by constructing the resistor network on the species-specific resistance surface and solving the network using the Laplacian method with unit current injection.\n\nNumerical and algorithmic requirements:\n- Build the weighted graph implicitly from the grid; you must not assume any special structure beyond the $8$-neighbor connectivity and the edge resistance rule specified above.\n- For the least-cost path, use Dijkstra’s algorithm on nonnegative edge resistances to compute the minimal cumulative cost.\n- For the effective resistance, assemble the weighted graph Laplacian $L$ using conductances and solve $L_{\\setminus g} V_{\\setminus g} = I_{\\setminus g}$ for potentials after grounding a single node $g$ not equal to the source or target, where the subscript $\\setminus g$ indicates the matrix and vector with the grounded node’s row and column removed. Then compute $R_{\\mathrm{eff}} = V_s - V_t$.\n\nUnits and output representation:\n- Resistances are dimensionless in this abstraction. All requested outputs are pure numbers without physical units.\n- All angles, if any, are irrelevant; do not use angles in this problem.\n- Express all final outputs as decimal floating-point numbers rounded to exactly $6$ digits after the decimal point.\n\nTest suite:\nImplement your program to run the following three test cases. In each case, the base resistance surface is provided as a matrix of integers, but you must apply the species-specific exponent to obtain the working resistance surface for each species as described above.\n\nCommon species exponents for all tests:\n- Pollinator exponent $\\alpha_{\\mathrm{pol}} = 1.2$.\n- Wind-dispersed tree exponent $\\alpha_{\\mathrm{tree}} = 0.8$.\n\nTest case $1$:\n- Base resistance surface $R_{\\mathrm{base}}$ of shape $5 \\times 5$:\n  $$\n  \\begin{bmatrix}\n  1 & 1 & 2 & 3 & 5 \\\\\n  1 & 5 & 5 & 3 & 1 \\\\\n  1 & 1 & 2 & 2 & 1 \\\\\n  3 & 5 & 5 & 1 & 1 \\\\\n  1 & 1 & 1 & 1 & 1\n  \\end{bmatrix}\n  $$\n- Pollinator source $s_{\\mathrm{pol}} = (0,0)$, target $t_{\\mathrm{pol}} = (4,4)$.\n- Tree source $s_{\\mathrm{tree}} = (0,4)$, target $t_{\\mathrm{tree}} = (4,0)$.\n\nTest case $2$:\n- Base resistance surface $R_{\\mathrm{base}}$ of shape $5 \\times 5$:\n  $$\n  \\begin{bmatrix}\n  1 & 1 & 1 & 1 & 1 \\\\\n  1 & 1 & 1 & 1 & 1 \\\\\n  100 & 100 & 2 & 100 & 100 \\\\\n  1 & 1 & 1 & 1 & 1 \\\\\n  1 & 1 & 1 & 1 & 1\n  \\end{bmatrix}\n  $$\n- Pollinator source $s_{\\mathrm{pol}} = (0,2)$, target $t_{\\mathrm{pol}} = (4,2)$.\n- Tree source $s_{\\mathrm{tree}} = (0,0)$, target $t_{\\mathrm{tree}} = (4,4)$.\n\nTest case $3$:\n- Base resistance surface $R_{\\mathrm{base}}$ of shape $3 \\times 3$:\n  $$\n  \\begin{bmatrix}\n  1 & 2 & 3 \\\\\n  2 & 4 & 2 \\\\\n  3 & 2 & 1\n  \\end{bmatrix}\n  $$\n- Pollinator source $s_{\\mathrm{pol}} = (0,0)$, target $t_{\\mathrm{pol}} = (1,1)$.\n- Tree source $s_{\\mathrm{tree}} = (0,1)$, target $t_{\\mathrm{tree}} = (0,2)$.\n\nRequired final output format:\n- Your program must produce a single line containing a comma-separated list enclosed in square brackets. For each test case in order $1$, $2$, $3$, append the following $4$ values in this exact order:\n  $[\\text{LCP}_{\\mathrm{pol}}, \\text{R}_{\\mathrm{eff,pol}}, \\text{LCP}_{\\mathrm{tree}}, \\text{R}_{\\mathrm{eff,tree}}]$,\n  where $\\text{LCP}$ denotes the least-cost path cost and $\\text{R}_{\\mathrm{eff}}$ denotes the circuit-theory effective resistance. Concatenate these quadruples for the three test cases into a single flat list. Each numeric value must be rounded to exactly $6$ digits after the decimal point. For example, the output structure should be $[\\text{tc1\\_pol\\_lcp},\\text{tc1\\_pol\\_re},\\text{tc1\\_tree\\_lcp},\\text{tc1\\_tree\\_re},\\text{tc2\\_pol\\_lcp},\\dots,\\text{tc3\\_tree\\_re}]$ with $12$ numbers total.", "solution": "The problem as stated is subjected to rigorous validation.\n\nStep 1: Extracted Givens\n- **Resistance Surface**: A matrix of nonnegative movement resistances, $R(i,j)$.\n- **Edge Resistance**: Between adjacent cells $u$ and $v$ with resistances $r_u$ and $r_v$, the edge resistance is $R_{uv} = d \\cdot \\frac{r_u + r_v}{2}$.\n- **Path Length, $d$**: For an $8$-neighbor grid, $d=1$ for orthogonal moves, $d=\\sqrt{2}$ for diagonal moves.\n- **Least-Cost Path (LCP) Cost**: The minimum sum of edge resistances over all paths connecting a source and target.\n- **Circuit Theory Effective Resistance ($R_{\\mathrm{eff}}$)**:\n    - **Edge Conductance**: $C_{uv} = 1 / R_{uv}$.\n    - **Laplacian System**: The potential vector $V$ is found by solving $L V = I$, where $L$ is the weighted graph Laplacian constructed from conductances, and $I$ is the current injection vector ($+1$ at source, $-1$ at target, $0$ elsewhere).\n    - **Solving the System**: Ground a single node $g$ (not source or target) and solve the reduced system $L_{\\setminus g} V_{\\setminus g} = I_{\\setminus g}$.\n    - **Effective Resistance Calculation**: $R_{\\mathrm{eff}} = V_s - V_t$ for unit current.\n- **Species-Specific Perception**: $R_{\\mathrm{species}}(i,j) = \\left(R_{\\mathrm{base}}(i,j)\\right)^{\\alpha}$.\n- **Species Parameters**: Pollinator exponent $\\alpha_{\\mathrm{pol}} = 1.2$; Wind-dispersed tree exponent $\\alpha_{\\mathrm{tree}} = 0.8$.\n- **Grid Indexing**: Zero-based $(\\text{row}, \\text{col})$.\n- **Algorithms**: Dijkstra’s for LCP; Laplacian matrix inversion for $R_{\\mathrm{eff}}$.\n- **Output Format**: All outputs as floating-point numbers rounded to $6$ decimal digits. The final output is a single flat list of $12$ numbers corresponding to $[\\text{LCP}_{\\mathrm{pol}}, \\text{R}_{\\mathrm{eff,pol}}, \\text{LCP}_{\\mathrm{tree}}, \\text{R}_{\\mathrm{eff,tree}}]$ for each of the three test cases, concatenated.\n- **Test Case 1**:\n    - $R_{\\mathrm{base}} = \\begin{bmatrix} 1 & 1 & 2 & 3 & 5 \\\\ 1 & 5 & 5 & 3 & 1 \\\\ 1 & 1 & 2 & 2 & 1 \\\\ 3 & 5 & 5 & 1 & 1 \\\\ 1 & 1 & 1 & 1 & 1 \\end{bmatrix}$\n    - Pollinator: $s=(0,0)$, $t=(4,4)$.\n    - Tree: $s=(0,4)$, $t=(4,0)$.\n- **Test Case 2**:\n    - $R_{\\mathrm{base}} = \\begin{bmatrix} 1 & 1 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 & 1 \\\\ 100 & 100 & 2 & 100 & 100 \\\\ 1 & 1 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 & 1 \\end{bmatrix}$\n    - Pollinator: $s=(0,2)$, $t=(4,2)$.\n    - Tree: $s=(0,0)$, $t=(4,4)$.\n- **Test Case 3**:\n    - $R_{\\mathrm{base}} = \\begin{bmatrix} 1 & 2 & 3 \\\\ 2 & 4 & 2 \\\\ 3 & 2 & 1 \\end{bmatrix}$\n    - Pollinator: $s=(0,0)$, $t=(1,1)$.\n    - Tree: $s=(0,1)$, $t=(0,2)$.\n\nStep 2: Validation Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded**: The problem uses established concepts from landscape ecology (resistance surfaces), graph theory (Dijkstra's algorithm), and circuit theory (Laplacian matrices, effective resistance). These methods are standard for modeling landscape connectivity. The problem is scientifically sound.\n- **Well-Posed**: The problem provides all necessary data, including matrices, parameters, source-target pairs, and precise mathematical definitions. The algorithms specified, Dijkstra's for LCP and the Laplacian method for effective resistance, are guaranteed to produce unique and meaningful solutions for the given inputs (nonnegative edge weights and a connected graph). The problem is self-contained and unambiguous.\n- **Objective**: The problem is stated in precise, mathematical language, devoid of any subjectivity or non-formalizable claims.\n\nThe problem does not exhibit any of the flaws listed in the validation checklist. It is a well-defined computational exercise based on established scientific models.\n\nStep 3: Verdict and Action\nThe problem is valid. A solution will be constructed.\n\nThe problem requires the implementation of two distinct connectivity metrics on a grid-based landscape: the least-cost path cost and the circuit-theory effective resistance. These calculations must be performed for two species, each characterized by a unique perception exponent $\\alpha$, across three test scenarios.\n\nThe fundamental data structure is a graph, where the nodes correspond to the cells of the input grid. For an $H \\times W$ grid, there are $N = H \\times W$ nodes. Edges connect each node to its $8$ adjacent neighbors (if they exist within the grid boundaries).\n\nFirst, for each species, the species-specific resistance surface $R_{\\mathrm{species}}$ is computed from the base resistance surface $R_{\\mathrm{base}}$ using the provided power-law transformation:\n$$\nR_{\\mathrm{species}}(i,j) = \\left(R_{\\mathrm{base}}(i,j)\\right)^{\\alpha}\n$$\nwhere $\\alpha$ is either $\\alpha_{\\mathrm{pol}} = 1.2$ or $\\alpha_{\\mathrm{tree}} = 0.8$. All subsequent calculations for a given species use its corresponding $R_{\\mathrm{species}}$ surface.\n\nThe resistance of an edge connecting two adjacent nodes, $u$ and $v$ (corresponding to grid cells $(r_u, c_u)$ and $(r_v, c_v)$), is given by:\n$$\nR_{uv} = d_{uv} \\cdot \\frac{R_{\\mathrm{species}}(r_u, c_u) + R_{\\mathrm{species}}(r_v, c_v)}{2}\n$$\nwhere $d_{uv}$ is the Euclidean distance between the cell centers. For orthogonal neighbors, $d_{uv} = 1$. For diagonal neighbors, $d_{uv} = \\sqrt{2}$.\n\n**Part 1: Least-Cost Path (LCP) Cost**\nThe LCP cost is the shortest path distance on the graph where edge weights are the edge resistances $R_{uv}$. Since all cell resistances are nonnegative, all edge resistances $R_{uv}$ are also nonnegative. Therefore, Dijkstra's algorithm is the appropriate method.\nThe algorithm proceeds as follows:\n1. Initialize a distance array, `dist`, of size $N$, with `dist[s] = 0` for the source node $s$ and `dist[v] = \\infty` for all other nodes $v$.\n2. Maintain a priority queue of nodes to visit, prioritized by their current distance from the source. Initially, it contains only the source node.\n3. While the priority queue is not empty, extract the node $u$ with the smallest distance.\n4. For each neighbor $v$ of $u$, calculate the potential new distance to $v$ through $u$ as `dist[u] + R_uv`.\n5. If this new distance is less than `dist[v]`, update `dist[v]` to this new value and add or update $v$ in the priority queue.\nThe algorithm terminates when the target node $t$ is extracted from the queue, or the queue becomes empty. The LCP cost is the final recorded value of `dist[t]`.\n\n**Part 2: Circuit-Theory Effective Resistance ($R_{\\mathrm{eff}}$)**\nThis metric is derived from electrical circuit theory. The landscape is treated as a resistor network. The conductance of an edge is the reciprocal of its resistance: $C_{uv} = 1/R_{uv}$.\nThe behavior of this network is described by the graph Laplacian matrix, $L$, an $N \\times N$ matrix defined as:\n$$\nL_{ij} =\n\\begin{cases}\n\\sum_{k \\neq i} C_{ik} & \\text{if } i = j \\\\\n-C_{ij} & \\text{if } i \\text{ and } j \\text{ are adjacent} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nA current of $I_{\\mathrm{inj}} = 1$ unit is injected at the source node $s$ and withdrawn at the target node $t$. This is represented by a current vector $I$ of size $N$, where $I_s = 1$, $I_t = -1$, and all other entries are $0$.\nThe node potentials (voltages) $V$ are determined by the linear system $LV = I$. The Laplacian matrix $L$ is singular (its rows sum to zero), reflecting that potentials are only defined up to an additive constant. To obtain a unique solution, we must set a reference potential. The problem specifies grounding one node $g$ (where $g \\neq s, t$), which means setting its potential $V_g = 0$.\nThis is computationally achieved by:\n1. Choosing a ground node index $g$ that is not the source or target index.\n2. Constructing the reduced Laplacian matrix $L_{\\setminus g}$ by removing the row and column corresponding to node $g$.\n3. Constructing the reduced current vector $I_{\\setminus g}$ by removing the entry for node $g$.\n4. Solving the non-singular linear system $L_{\\setminus g} V_{\\setminus g} = I_{\\setminus g}$ for the remaining potentials $V_{\\setminus g}$.\n5. Reconstructing the full potential vector $V$ by inserting $V_g=0$ at the appropriate position.\nThe effective resistance is the potential difference between the source and target nodes:\n$$\nR_{\\mathrm{eff}} = V_s - V_t\n$$\nThis quantity is independent of the choice of the ground node $g$.\n\nThe implementation will systematically apply these two procedures for each species and test case, formatting the numerical results as specified. A mapping from 2D grid coordinates $(r, c)$ to a 1D node index, e.g., `idx = r * W + c`, is used to construct the graph matrices and vectors.", "answer": "```python\nimport numpy as np\nimport scipy.linalg\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and compute landscape connectivity metrics.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"r_base\": np.array([\n                [1, 1, 2, 3, 5],\n                [1, 5, 5, 3, 1],\n                [1, 1, 2, 2, 1],\n                [3, 5, 5, 1, 1],\n                [1, 1, 1, 1, 1]\n            ], dtype=float),\n            \"s_pol\": (0, 0), \"t_pol\": (4, 4),\n            \"s_tree\": (0, 4), \"t_tree\": (4, 0)\n        },\n        {\n            \"r_base\": np.array([\n                [1, 1, 1, 1, 1],\n                [1, 1, 1, 1, 1],\n                [100, 100, 2, 100, 100],\n                [1, 1, 1, 1, 1],\n                [1, 1, 1, 1, 1]\n            ], dtype=float),\n            \"s_pol\": (0, 2), \"t_pol\": (4, 2),\n            \"s_tree\": (0, 0), \"t_tree\": (4, 4)\n        },\n        {\n            \"r_base\": np.array([\n                [1, 2, 3],\n                [2, 4, 2],\n                [3, 2, 1]\n            ], dtype=float),\n            \"s_pol\": (0, 0), \"t_pol\": (1, 1),\n            \"s_tree\": (0, 1), \"t_tree\": (0, 2)\n        }\n    ]\n\n    alpha_pol = 1.2\n    alpha_tree = 0.8\n    all_results = []\n\n    for case in test_cases:\n        r_base = case[\"r_base\"]\n\n        # Pollinator calculations\n        r_pol = np.power(r_base, alpha_pol)\n        lcp_pol = calculate_lcp(r_pol, case[\"s_pol\"], case[\"t_pol\"])\n        reff_pol = calculate_reff(r_pol, case[\"s_pol\"], case[\"t_pol\"])\n        all_results.extend([lcp_pol, reff_pol])\n\n        # Tree calculations\n        r_tree = np.power(r_base, alpha_tree)\n        lcp_tree = calculate_lcp(r_tree, case[\"s_tree\"], case[\"t_tree\"])\n        reff_tree = calculate_reff(r_tree, case[\"s_tree\"], case[\"t_tree\"])\n        all_results.extend([lcp_tree, reff_tree])\n\n    # Format output as specified\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef get_neighbors(r, c, H, W):\n    \"\"\"Generates 8-neighbor coordinates and step lengths.\"\"\"\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                dist = np.sqrt(dr**2 + dc**2)\n                yield (nr, nc), dist\n\ndef calculate_lcp(r_surface, source, target):\n    \"\"\"Calculates least-cost path cost using Dijkstra's algorithm.\"\"\"\n    H, W = r_surface.shape\n    num_nodes = H * W\n    source_idx = source[0] * W + source[1]\n    target_idx = target[0] * W + target[1]\n\n    dist = np.full(num_nodes, np.inf)\n    dist[source_idx] = 0\n    pq = [(0, source_idx)]  # (distance, node_index)\n\n    while pq:\n        d, u_idx = heapq.heappop(pq)\n\n        if d > dist[u_idx]:\n            continue\n        \n        if u_idx == target_idx:\n            return dist[target_idx]\n\n        r, c = u_idx // W, u_idx % W\n        r_u = r_surface[r, c]\n\n        for (nr, nc), step_len in get_neighbors(r, c, H, W):\n            v_idx = nr * W + nc\n            r_v = r_surface[nr, nc]\n            \n            edge_resistance = step_len * (r_u + r_v) / 2.0\n            \n            if dist[u_idx] + edge_resistance < dist[v_idx]:\n                dist[v_idx] = dist[u_idx] + edge_resistance\n                heapq.heappush(pq, (dist[v_idx], v_idx))\n    \n    return dist[target_idx]\n\n\ndef calculate_reff(r_surface, source, target):\n    \"\"\"Calculates effective resistance using the Laplacian matrix method.\"\"\"\n    H, W = r_surface.shape\n    num_nodes = H * W\n    \n    source_idx = source[0] * W + source[1]\n    target_idx = target[0] * W + target[1]\n\n    laplacian = np.zeros((num_nodes, num_nodes))\n\n    for r in range(H):\n        for c in range(W):\n            u_idx = r * W + c\n            r_u = r_surface[r, c]\n            \n            for (nr, nc), step_len in get_neighbors(r, c, H, W):\n                v_idx = nr * W + nc\n                if u_idx > v_idx: continue # Process each edge once\n                \n                r_v = r_surface[nr, nc]\n                edge_resistance = step_len * (r_u + r_v) / 2.0\n                \n                if edge_resistance > 0:\n                    conductance = 1.0 / edge_resistance\n                    laplacian[u_idx, u_idx] += conductance\n                    laplacian[v_idx, v_idx] += conductance\n                    laplacian[u_idx, v_idx] -= conductance\n                    laplacian[v_idx, u_idx] -= conductance\n\n    # Set up current vector\n    current = np.zeros(num_nodes)\n    current[source_idx] = 1.0\n    current[target_idx] = -1.0\n\n    # Ground a node to solve the system\n    ground_node = 0\n    if ground_node == source_idx or ground_node == target_idx:\n        ground_node = 1\n\n    nodes_to_keep = list(range(num_nodes))\n    nodes_to_keep.remove(ground_node)\n    \n    L_reduced = laplacian[np.ix_(nodes_to_keep, nodes_to_keep)]\n    I_reduced = current[nodes_to_keep]\n\n    # Solve for potentials\n    try:\n        V_reduced = scipy.linalg.solve(L_reduced, I_reduced)\n    except np.linalg.LinAlgError:\n         # In case of disconnected graph, use pseudoinverse\n         L_pinv = scipy.linalg.pinv(L_reduced)\n         V_reduced = L_pinv @ I_reduced\n\n\n    potentials = np.zeros(num_nodes)\n    potentials[nodes_to_keep] = V_reduced\n    # The potential of the ground node remains 0\n\n    return potentials[source_idx] - potentials[target_idx]\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2580971"}, {"introduction": "Communities are complex webs of interacting species, and their stability is a key emergent property. This practice challenges you to construct a trophic network from the ground up, using fundamental allometric scaling laws that link body size to ecological interactions [@problem_id:2580979]. By implementing a generalized Lotka-Volterra model and analyzing its Jacobian matrix, you will explore the relationship between community structure and dynamic stability, a central theme in theoretical ecology.", "problem": "You are asked to formalize an allometric trophic network and assess the local stability of a feasible equilibrium of a community governed by generalized Lotka–Volterra dynamics. Build everything from first principles given below and implement a program that computes the dominant real-part eigenvalue of the community Jacobian and a boolean stability verdict for several test cases.\n\nFundamental base:\n- Generalized Lotka–Volterra (GLV) population dynamics: for each species index $i \\in \\{1,\\dots,S\\}$ with abundance $x_i(t)$, the dynamics are\n$$\n\\frac{d x_i}{d t} \\;=\\; x_i \\left( r_i + \\sum_{j=1}^{S} a_{ij} x_j \\right).\n$$\n- Local stability of an equilibrium $(x_1^\\ast,\\dots,x_S^\\ast)$ with $x_i^\\ast > 0$ requires that all eigenvalues of the Jacobian matrix at that equilibrium have strictly negative real parts.\n- The Jacobian of the GLV system at a feasible equilibrium satisfies\n$$\nJ \\;=\\; \\mathrm{diag}(x^\\ast) \\, A,\n$$\nbecause at equilibrium one has $r_i + \\sum_{j} a_{ij} x_j^\\ast = 0$ for each $i$, hence $J_{ij} = x_i^\\ast a_{ij}$ for all $i,j$.\n\nAllometric construction of the interaction matrix:\n- You are given body masses $M_i$ (in kilograms) for $i \\in \\{1,\\dots,S\\}$. Define a directed trophic adjacency $L_{ij} \\in \\{0,1\\}$ by the body-mass ratio rule\n$$\nL_{ij} \\;=\\; \\begin{cases}\n1, & \\text{if } i \\neq j \\text{ and } \\dfrac{M_i}{M_j} \\ge \\theta,\\\\\n0, & \\text{otherwise,}\n\\end{cases}\n$$\nmeaning species $i$ consumes species $j$ if and only if the mass ratio threshold $\\theta$ is met.\n- Let $b_0 > 0$ be a base interaction scale, $\\alpha \\in \\mathbb{R}$ an allometric exponent, and $e \\in (0,1]$ a biomass conversion efficiency. For each consumer–resource link with $L_{ij}=1$ and ratio $R_{ij} = M_i/M_j$, define the per-capita effect magnitudes\n$$\nb_{ij} \\;=\\; b_0 \\, R_{ij}^{\\alpha}.\n$$\n- Assemble the interaction matrix $A \\in \\mathbb{R}^{S \\times S}$ with predator–prey sign structure:\n$$\na_{ij} \\;=\\; \\begin{cases}\n+ e \\, b_{ij}, & \\text{if } L_{ij}=1 \\text{ (effect of prey } j \\text{ on predator } i),\\\\\n- b_{ji}, & \\text{if } L_{ji}=1 \\text{ (effect of predator } j \\text{ on prey } i),\\\\\n0, & \\text{otherwise,}\n\\end{cases}\n$$\nand intraspecific self-regulation\n$$\na_{ii} \\;=\\; - s,\n$$\nfor a given $s > 0$ (assumed identical across species in this problem).\n\nAllometric equilibrium anchoring:\n- Assume a feasible equilibrium abundance scaling motivated by Damuth’s law: for constants $c>0$ and $\\beta>0$,\n$$\nx_i^\\ast \\;=\\; c \\, M_i^{-\\beta}.\n$$\n- Define the intrinsic rates $r \\in \\mathbb{R}^S$ by enforcing feasibility at $x^\\ast$: set\n$$\nr \\;=\\; - A \\, x^\\ast,\n$$\nso that $x^\\ast$ is an equilibrium of the GLV system by construction.\n\nStability objective:\n- Compute $J = \\mathrm{diag}(x^\\ast) A$, then compute the spectrum of $J$. Let $\\lambda_{\\max}$ denote the maximum real part among all eigenvalues of $J$. The equilibrium is locally asymptotically stable if and only if $\\lambda_{\\max} < 0$.\n\nAlgorithmic task:\n- For each test case below, construct $L$, then $A$, then $x^\\ast$, then $r$, then $J$, and finally compute $\\lambda_{\\max}$ and a boolean stability verdict $S$ defined as $S=\\text{True}$ if $\\lambda_{\\max} < -\\varepsilon$ and $S=\\text{False}$ otherwise, where $\\varepsilon = 10^{-9}$ is a strict numerical tolerance.\n- Report for each case the pair $[S, \\lambda_{\\max}]$, with $\\lambda_{\\max}$ rounded to $6$ decimal places.\n\nPhysical and numerical units:\n- Body mass inputs $M_i$ are in kilograms. No output quantity requires physical units.\n\nAngle unit:\n- No angles are involved.\n\nOutput format:\n- Your program should produce a single line of output containing a single top-level list of length equal to the number of test cases. Each element must be a two-element list $[S_i,\\lambda_i]$, where $S_i$ is a boolean and $\\lambda_i$ is a floating-point number rounded to $6$ decimal places. For example: $[[\\text{True},-0.123456],[\\text{False},0.010000]]$.\n\nTest suite:\nUse the following four test cases. Each case provides $S$, the masses $\\{M_i\\}_{i=1}^S$ in kilograms, and parameters $(\\theta, b_0, \\alpha, e, s, c, \\beta)$.\n\n- Case $1$ (baseline chain, moderate coupling):\n  - $S = 4$\n  - $M = [\\,0.01,\\,0.1,\\,1,\\,10\\,]$\n  - $\\theta = 10$, $b_0 = 0.05$, $\\alpha = 0.25$, $e = 0.2$, $s = 1.0$, $c = 1000$, $\\beta = 0.75$\n- Case $2$ (stronger coupling on same topology):\n  - $S = 4$\n  - $M = [\\,0.01,\\,0.1,\\,1,\\,10\\,]$\n  - $\\theta = 10$, $b_0 = 0.5$, $\\alpha = 0.25$, $e = 0.2$, $s = 1.0$, $c = 1000$, $\\beta = 0.75$\n- Case $3$ (sparser trophic links via a higher threshold):\n  - $S = 4$\n  - $M = [\\,0.01,\\,0.1,\\,1,\\,10\\,]$\n  - $\\theta = 100$, $b_0 = 0.5$, $\\alpha = 0.25$, $e = 0.2$, $s = 1.0$, $c = 1000$, $\\beta = 0.75$\n- Case $4$ (wider mass spectrum, altered exponents and self-regulation):\n  - $S = 5$\n  - $M = [\\,0.002,\\,0.02,\\,0.2,\\,2,\\,20\\,]$\n  - $\\theta = 10$, $b_0 = 0.2$, $\\alpha = 0.5$, $e = 0.3$, $s = 1.2$, $c = 800$, $\\beta = 0.75$\n\nThe program must implement the construction exactly as stated and output a single line with the list $[[S_1,\\lambda_1], [S_2,\\lambda_2], [S_3,\\lambda_3], [S_4,\\lambda_4]]$, where each $\\lambda_i$ is rounded to $6$ decimal places.", "solution": "The problem statement is subjected to validation.\n\nGivens are extracted as follows:\n1.  **System Dynamics**: The Generalized Lotka–Volterra (GLV) equations describe the population dynamics for $S$ species with abundances $x_i(t)$:\n    $$ \\frac{d x_i}{d t} = x_i \\left( r_i + \\sum_{j=1}^{S} a_{ij} x_j \\right) $$\n    for each species $i \\in \\{1, \\dots, S\\}$.\n2.  **Equilibrium and Stability**: An equilibrium $x^\\ast = (x_1^\\ast, \\dots, x_S^\\ast)$ with all $x_i^\\ast > 0$ is locally asymptotically stable if all eigenvalues of the Jacobian matrix $J$ evaluated at $x^\\ast$ have strictly negative real parts.\n3.  **Jacobian Matrix**: At a feasible equilibrium, the Jacobian is given by $J = \\mathrm{diag}(x^\\ast) A$, where $A$ is the interaction matrix. This follows from the equilibrium condition $r_i + \\sum_{j=1}^{S} a_{ij} x_j^\\ast = 0$.\n4.  **Trophic Network Structure**: A directed adjacency matrix $L \\in \\{0, 1\\}^{S \\times S}$ is defined using body masses $M_i$ and a threshold $\\theta$:\n    $$ L_{ij} = \\begin{cases} 1, & \\text{if } i \\neq j \\text{ and } \\frac{M_i}{M_j} \\ge \\theta \\\\ 0, & \\text{otherwise} \\end{cases} $$\n5.  **Interaction Matrix Construction**:\n    -   Per-capita interaction magnitudes for a link $L_{ij}=1$ are $b_{ij} = b_0 (M_i/M_j)^{\\alpha}$, with $b_0 > 0$ and $\\alpha \\in \\mathbb{R}$.\n    -   The interaction matrix $A \\in \\mathbb{R}^{S \\times S}$ is defined by:\n        $$ a_{ij} = \\begin{cases} + e \\, b_{ij}, & \\text{if } L_{ij}=1 \\\\ - b_{ji}, & \\text{if } L_{ji}=1 \\\\ 0, & \\text{otherwise} \\end{cases} \\quad \\text{for } i \\neq j $$\n        and intraspecific competition $a_{ii} = -s$ for a given $s > 0$. The parameter $e \\in (0,1]$ is the biomass conversion efficiency.\n6.  **Equilibrium Abundance**: A feasible equilibrium $x^\\ast$ is assumed to follow an allometric scaling law:\n    $$ x_i^\\ast = c \\, M_i^{-\\beta} $$\n    for constants $c > 0$ and $\\beta > 0$. The intrinsic growth rates are set to $r = -A x^\\ast$ to ensure $x^\\ast$ is an equilibrium.\n7.  **Computational Objective**:\n    -   Compute the Jacobian $J = \\mathrm{diag}(x^\\ast) A$.\n    -   Determine the maximum real part of the eigenvalues of $J$, denoted $\\lambda_{\\max}$.\n    -   The stability verdict $S$ is $\\text{True}$ if $\\lambda_{\\max} < -\\varepsilon$ and $\\text{False}$ otherwise, with a numerical tolerance of $\\varepsilon = 10^{-9}$.\n    -   Report the pair $[S, \\lambda_{\\max}]$ for each test case, with $\\lambda_{\\max}$ rounded to $6$ decimal places.\n8.  **Test Cases**: Four distinct test cases are provided, specifying all necessary parameters $(S, \\{M_i\\}, \\theta, b_0, \\alpha, e, s, c, \\beta)$.\n\nValidation reveals the problem is scientifically grounded, well-posed, and objective. It is based on established principles of theoretical ecology (Lotka-Volterra dynamics, allometric scaling) and dynamical systems theory (local stability analysis). The problem provides a complete, unambiguous, and self-consistent set of instructions and parameters, forming a well-defined computational task. No scientific, logical, or mathematical flaws are detected. The problem is therefore deemed **valid**.\n\nThe solution proceeds by constructing the required mathematical objects in a stepwise manner, as specified.\n\nThe process begins with the given body masses $\\{M_i\\}_{i=1}^S$ and parameters for each test case.\n\nFirst, we construct the trophic adjacency matrix $L$. For each pair of distinct species $(i, j)$, we compute the mass ratio $R_{ij} = M_i/M_j$. If $R_{ij} \\ge \\theta$, then species $i$ consumes species $j$, and we set the matrix element $L_{ij} = 1$. Otherwise, $L_{ij} = 0$. The condition $i \\neq j$ ensures no self-consumption. For the given test sets, where all masses are distinct and $\\theta > 1$, it is impossible for both $L_{ij}=1$ and $L_{ji}=1$ to hold simultaneously for any pair $(i, j)$.\n\nSecond, we construct the community interaction matrix $A \\in \\mathbb{R}^{S \\times S}$. The diagonal elements are set to represent intraspecific competition: $a_{ii} = -s$. For the off-diagonal elements, we first compute the per-capita interaction magnitudes $b_{ij} = b_0 R_{ij}^{\\alpha}$ for all pairs $(i, j)$ where a trophic link exists ($L_{ij} = 1$). The elements of $A$ are then populated according to the predator-prey dynamics:\n-   If $L_{ij} = 1$ (species $i$ eats species $j$), the effect of prey $j$ on predator $i$ is positive: $a_{ij} = +e \\cdot b_{ij}$.\n-   Conversely, the effect of predator $i$ on prey $j$ is negative. This corresponds to an element $a_{ji}$, for which the relevant trophic link is $L_{ij}=1$. The problem statement implies that for the term $a_{ji}$, the link is from $i$ to $j$, i.e., $L_{ij}=1$. The rule is stated as $a_{ij} = -b_{ji}$ if $L_{ji}=1$. Thus, for a pair $(i, j)$ where $i$ eats $j$, we have $a_{ij} = e b_{ij}$ and $a_{ji} = -b_{ij}$.\n\nThird, we determine the equilibrium abundance vector $x^\\ast$. This is calculated directly from the allometric scaling law, $x_i^\\ast = c M_i^{-\\beta}$ for each species $i$.\n\nFourth, we construct the Jacobian matrix $J$ of the system at the equilibrium $x^\\ast$. As specified, $J = \\mathrm{diag}(x^\\ast) A$. The $(i, j)$-th element of the Jacobian is therefore $J_{ij} = x_i^\\ast a_{ij}$. The diagonal elements are $J_{ii} = x_i^\\ast a_{ii} = -s x_i^\\ast$. The off-diagonal elements are $J_{ij} = x_i^\\ast a_{ij}$ for $i \\neq j$.\n\nFinally, we perform the stability analysis. We compute the set of eigenvalues $\\{\\lambda_k\\}_{k=1}^S$ of the matrix $J$. The local stability of the equilibrium is determined by the sign of the maximum real part of these eigenvalues, $\\lambda_{\\max} = \\max_k \\{ \\mathrm{Re}(\\lambda_k) \\}$. The equilibrium is locally asymptotically stable if and only if $\\lambda_{\\max} < 0$. We apply the strict numerical criterion provided: the stability verdict $S$ is $\\text{True}$ if $\\lambda_{\\max} < -10^{-9}$, and $\\text{False}$ otherwise.\n\nThis procedure is applied to each of the four test cases to obtain the final results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the stability of allometric trophic networks for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"case_id\": 1,\n            \"S\": 4,\n            \"M\": np.array([0.01, 0.1, 1, 10]),\n            \"params\": {\"theta\": 10.0, \"b0\": 0.05, \"alpha\": 0.25, \"e\": 0.2, \"s\": 1.0, \"c\": 1000.0, \"beta\": 0.75}\n        },\n        {\n            \"case_id\": 2,\n            \"S\": 4,\n            \"M\": np.array([0.01, 0.1, 1, 10]),\n            \"params\": {\"theta\": 10.0, \"b0\": 0.5, \"alpha\": 0.25, \"e\": 0.2, \"s\": 1.0, \"c\": 1000.0, \"beta\": 0.75}\n        },\n        {\n            \"case_id\": 3,\n            \"S\": 4,\n            \"M\": np.array([0.01, 0.1, 1, 10]),\n            \"params\": {\"theta\": 100.0, \"b0\": 0.5, \"alpha\": 0.25, \"e\": 0.2, \"s\": 1.0, \"c\": 1000.0, \"beta\": 0.75}\n        },\n        {\n            \"case_id\": 4,\n            \"S\": 5,\n            \"M\": np.array([0.002, 0.02, 0.2, 2, 20]),\n            \"params\": {\"theta\": 10.0, \"b0\": 0.2, \"alpha\": 0.5, \"e\": 0.3, \"s\": 1.2, \"c\": 800.0, \"beta\": 0.75}\n        }\n    ]\n\n    results = []\n    epsilon = 1e-9\n\n    for case in test_cases:\n        S = case[\"S\"]\n        M = case[\"M\"]\n        p = case[\"params\"]\n        \n        # Step 1: Construct trophic adjacency matrix L\n        # R_ij = M_i / M_j. Using numpy broadcasting for efficiency.\n        R = M[:, np.newaxis] / M\n        L = (R >= p[\"theta\"]).astype(float)\n        np.fill_diagonal(L, 0) # Enforce i != j\n\n        # Step 2: Construct interaction matrix A\n        A = np.zeros((S, S))\n        \n        # Calculate per-capita interaction magnitudes b_ij\n        b = p[\"b0\"] * (R ** p[\"alpha\"])\n        \n        # Populate off-diagonal elements of A based on L\n        # a_ij = +e * b_ij for predator i on prey j (L_ij = 1)\n        # a_ji = -b_ij for predator i on prey j (L_ij = 1)\n        # We can vectorize this: A_predator_gain = e * (b * L)\n        # A_prey_loss = -(b * L).T\n        A = p[\"e\"] * (b * L) - (b * L).T\n\n        # Set diagonal elements for intraspecific self-regulation\n        np.fill_diagonal(A, -p[\"s\"])\n\n        # Step 3: Construct equilibrium abundance vector x*\n        x_star = p[\"c\"] * (M ** -p[\"beta\"])\n\n        # Step 4: Construct the Jacobian matrix J = diag(x*) @ A\n        J = np.diag(x_star) @ A\n        \n        # Step 5: Compute eigenvalues and determine stability\n        eigenvalues = np.linalg.eigvals(J)\n        lambda_max = np.max(np.real(eigenvalues))\n        \n        is_stable = lambda_max < -epsilon\n        \n        results.append([is_stable, round(lambda_max, 6)])\n\n    # Format output as a single string\n    output_str = \"[\" + \",\".join([f\"[{str(r[0]).lower()},{r[1]:.6f}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2580979"}]}