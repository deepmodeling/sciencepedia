{"hands_on_practices": [{"introduction": "Before constructing a phylogenetic tree, a crucial first step is to evaluate which characters in a dataset contain useful evolutionary signal. This exercise [@problem_id:2605510] provides fundamental practice in applying the formal definition of a \"parsimony-informative character,\" a core concept in cladistics. By working through the provided data, you will develop a critical skill for assessing phylogenetic datasets and learn to handle common issues like missing or ambiguous states.", "problem": "A comparative dataset of cat-like and dog-like species, named using binomial nomenclature, is assembled to evaluate parsimony informativeness of morphological and nucleotide characters under the principles of phylogenetic systematics. Work under unordered-character Fitch parsimony. Use the following foundational definitions from systematics.\n\n- A character is a mapping from taxa to discrete states.\n- A character under unordered Fitch parsimony is parsimony-informative if and only if, after restricting to taxa that are unambiguously coded at that character (i.e., have a single state, not an ambiguity, missing, or inapplicable), there exist at least two distinct states, each represented in at least $2$ such taxa.\n- Treat ambiguous and missing entries as follows:\n  - For nucleotides, the International Union of Pure and Applied Chemistry (IUPAC) single-letter ambiguity codes denote sets of possible nucleotides: $R=\\{A,G\\}$, $Y=\\{C,T\\}$, $S=\\{G,C\\}$, $W=\\{A,T\\}$, $K=\\{G,T\\}$, $M=\\{A,C\\}$, $N=\\{A,C,G,T\\}$. A hyphen $-$ denotes inapplicable. Only the unambiguous nucleotides $\\{A,C,G,T\\}$ contribute to counts; all other codes and $-$ are ignored for counting.\n  - For morphological characters, states are coded as $0,1,2,3$ (unordered), with $?$ denoting missing and $-$ denoting inapplicable. Only numeric singleton states contribute to counts; $?$ and $-$ are ignored for counting.\n\nThe taxa (in this fixed order for all characters) are the following $9$ species: *Panthera leo*, *Panthera tigris*, *Panthera pardus*, *Neofelis nebulosa*, *Acinonyx jubatus*, *Lynx lynx*, *Felis catus*, *Prionailurus bengalensis*, *Canis lupus*.\n\nFor each character $C_{i}$, the states for the $9$ taxa are given in the fixed taxon order above.\n\n- $C_{1}$ (morphological, binary): $1,\\,1,\\,1,\\,1,\\,1,\\,0,\\,0,\\,0,\\,0$.\n- $C_{2}$ (morphological, binary): $0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,1,\\,0$.\n- $C_{3}$ (morphological, ternary): $0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,?,\\,0$.\n- $C_{4}$ (nucleotide): $A,\\,A,\\,A,\\,R,\\,G,\\,G,\\,G,\\,N,\\,A$.\n- $C_{5}$ (nucleotide): $T,\\,T,\\,T,\\,Y,\\,T,\\,A,\\,N,\\,-,\\,G$.\n- $C_{6}$ (morphological, binary): $1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0,\\,?$.\n- $C_{7}$ (morphological, ternary): $0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,1,\\,-$.\n- $C_{8}$ (nucleotide): $C,\\,C,\\,C,\\,C,\\,C,\\,S,\\,G,\\,G,\\,R$.\n- $C_{9}$ (nucleotide): $A,\\,G,\\,R,\\,G,\\,G,\\,R,\\,A,\\,A,\\,N$.\n- $C_{10}$ (nucleotide): $A,\\,A,\\,A,\\,A,\\,A,\\,A,\\,G,\\,C,\\,T$.\n- $C_{11}$ (morphological, four-state): $0,\\,1,\\,2,\\,3,\\,0,\\,1,\\,2,\\,3,\\,?$.\n- $C_{12}$ (nucleotide): $N,\\,N,\\,N,\\,N,\\,N,\\,G,\\,C,\\,-,\\,N$.\n- $C_{13}$ (morphological, binary): $1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1$.\n- $C_{14}$ (nucleotide): $A,\\,A,\\,M,\\,C,\\,C,\\,M,\\,C,\\,C,\\,A$.\n- $C_{15}$ (morphological, binary): $?,\\,?,\\,1,\\,0,\\,-,\\,-,\\,-,\\,1,\\,-$.\n\nTask: Using only the definitions above (unordered Fitch parsimony and the handling of ambiguity, missing, and inapplicability), compute the total number of parsimony-informative characters among $C_{1}$ through $C_{15}$. Express your final answer as an integer with no units. No rounding is required.", "solution": "The problem will first be validated against the required criteria of scientific soundness, well-posedness, and objectivity.\n\n**Step 1: Extract Givens**\n\nThe problem provides the following definitions, data, and constraints:\n1.  **Systematics Principle**: The analysis is based on unordered-character Fitch parsimony.\n2.  **Definition of Parsimony-Informativeness**: A character is parsimony-informative if and only if, after restricting to unambiguously coded taxa, there exist at least two distinct states, each represented in at least $2$ taxa.\n3.  **Handling of Ambiguity/Missing Data (Nucleotides)**: Unambiguous states are $\\{A, C, G, T\\}$. Ambiguous states are the IUPAC codes $R=\\{A,G\\}$, $Y=\\{C,T\\}$, $S=\\{G,C\\}$, $W=\\{A,T\\}$, $K=\\{G,T\\}$, $M=\\{A,C\\}$, and $N=\\{A,C,G,T\\}$. The symbol $-$ denotes an inapplicable state. Only unambiguous states contribute to counts; all others are ignored.\n4.  **Handling of Ambiguity/Missing Data (Morphology)**: Unambiguous states are $\\{0, 1, 2, 3\\}$. The symbol $?$ denotes a missing state, and $-$ denotes an inapplicable state. Only numeric singleton states contribute to counts; $?$ and $-$ are ignored.\n5.  **Taxa**: A fixed set of $9$ taxa: *Panthera leo*, *Panthera tigris*, *Panthera pardus*, *Neofelis nebulosa*, *Acinonyx jubatus*, *Lynx lynx*, *Felis catus*, *Prionailurus bengalensis*, *Canis lupus*.\n6.  **Character Data**: State assignments for $15$ characters, $C_{1}$ through $C_{15}$, across the $9$ taxa.\n    - $C_{1}$: $1,\\,1,\\,1,\\,1,\\,1,\\,0,\\,0,\\,0,\\,0$.\n    - $C_{2}$: $0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,1,\\,0$.\n    - $C_{3}$: $0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,?,\\,0$.\n    - $C_{4}$: $A,\\,A,\\,A,\\,R,\\,G,\\,G,\\,G,\\,N,\\,A$.\n    - $C_{5}$: $T,\\,T,\\,T,\\,Y,\\,T,\\,A,\\,N,\\,-,\\,G$.\n    - $C_{6}$: $1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0,\\,?$.\n    - $C_{7}$: $0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,1,\\,-$.\n    - $C_{8}$: $C,\\,C,\\,C,\\,C,\\,C,\\,S,\\,G,\\,G,\\,R$.\n    - $C_{9}$: $A,\\,G,\\,R,\\,G,\\,G,\\,R,\\,A,\\,A,\\,N$.\n    - $C_{10}$: $A,\\,A,\\,A,\\,A,\\,A,\\,A,\\,G,\\,C,\\,T$.\n    - $C_{11}$: $0,\\,1,\\,2,\\,3,\\,0,\\,1,\\,2,\\,3,\\,?$.\n    - $C_{12}$: $N,\\,N,\\,N,\\,N,\\,N,\\,G,\\,C,\\,-,\\,N$.\n    - $C_{13}$: $1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1$.\n    - $C_{14}$: $A,\\,A,\\,M,\\,C,\\,C,\\,M,\\,C,\\,C,\\,A$.\n    - $C_{15}$: $?,\\,?,\\,1,\\,0,\\,-,\\,-,\\,-,\\,1,\\,-$.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem is rooted in fundamental principles of phylogenetic systematics, specifically cladistic parsimony. The definition of parsimony-informativeness is a standard concept in the field. The use of binomial nomenclature, IUPAC codes for nucleotides, and standard coding for morphological data is correct and established practice. The problem is scientifically sound.\n- **Well-Posed**: The problem provides an explicit and unambiguous algorithm for determining parsimony-informativeness. All necessary data and definitions are supplied. The task is to apply this algorithm to a given dataset, which leads to a unique, stable, and meaningful integer solution.\n- **Objective**: The problem is stated in precise, formal language, free of subjective or opinion-based claims.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid as it is scientifically grounded, well-posed, objective, and self-contained. A rigorous solution can be derived by applying the provided definitions to the data.\n\n**Solution Derivation**\n\nThe task is to determine the total number of parsimony-informative characters among $C_{1}$ through $C_{15}$. Each character will be evaluated against the given definition.\n\n- **$C_{1}$ (morphological)**: States are $1,\\,1,\\,1,\\,1,\\,1,\\,0,\\,0,\\,0,\\,0$. All $9$ taxa are unambiguously coded. State frequencies: Count($1$) = $5$, Count($0$) = $4$. Both frequencies are $\\ge 2$. Thus, **$C_{1}$ is parsimony-informative**.\n\n- **$C_{2}$ (morphological)**: States are $0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,1,\\,0$. All $9$ taxa are unambiguously coded. State frequencies: Count($0$) = $8$, Count($1$) = $1$. Only one state has a frequency $\\ge 2$. Thus, $C_{2}$ is not parsimony-informative.\n\n- **$C_{3}$ (morphological)**: States are $0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,?,\\,0$. One taxon is coded as $?$. The remaining $8$ states are $0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,0$. State frequencies: Count($0$) = $3$, Count($1$) = $2$, Count($2$) = $3$. All three frequencies are $\\ge 2$. Thus, **$C_{3}$ is parsimony-informative**.\n\n- **$C_{4}$ (nucleotide)**: States are $A,\\,A,\\,A,\\,R,\\,G,\\,G,\\,G,\\,N,\\,A$. Two taxa are coded with ambiguous states ($R, N$). The remaining $7$ states are $A,\\,A,\\,A,\\,G,\\,G,\\,G,\\,A$. State frequencies: Count($A$) = $4$, Count($G$) = $3$. Both frequencies are $\\ge 2$. Thus, **$C_{4}$ is parsimony-informative**.\n\n- **$C_{5}$ (nucleotide)**: States are $T,\\,T,\\,T,\\,Y,\\,T,\\,A,\\,N,\\,-,\\,G$. Three taxa are coded with ambiguous or inapplicable states ($Y, N, -$). The remaining $6$ states are $T,\\,T,\\,T,\\,T,\\,A,\\,G$. State frequencies: Count($T$) = $4$, Count($A$) = $1$, Count($G$) = $1$. Only one state has a frequency $\\ge 2$. Thus, $C_{5}$ is not parsimony-informative.\n\n- **$C_{6}$ (morphological)**: States are $1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0,\\,?$. One taxon is coded as $?$. The remaining $8$ states are $1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0$. State frequencies: Count($1$) = $4$, Count($0$) = $4$. Both frequencies are $\\ge 2$. Thus, **$C_{6}$ is parsimony-informative**.\n\n- **$C_{7}$ (morphological)**: States are $0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,1,\\,-$. One taxon is coded as $-$. The remaining $8$ states are $0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,1$. State frequencies: Count($0$) = $1$, Count($1$) = $3$, Count($2$) = $4$. The frequencies of states $1$ and $2$ are $\\ge 2$. Thus, **$C_{7}$ is parsimony-informative**.\n\n- **$C_{8}$ (nucleotide)**: States are $C,\\,C,\\,C,\\,C,\\,C,\\,S,\\,G,\\,G,\\,R$. Two taxa are coded with ambiguous states ($S, R$). The remaining $7$ states are $C,\\,C,\\,C,\\,C,\\,C,\\,G,\\,G$. State frequencies: Count($C$) = $5$, Count($G$) = $2$. Both frequencies are $\\ge 2$. Thus, **$C_{8}$ is parsimony-informative**.\n\n- **$C_{9}$ (nucleotide)**: States are $A,\\,G,\\,R,\\,G,\\,G,\\,R,\\,A,\\,A,\\,N$. Three taxa are coded with ambiguous states ($R, R, N$). The remaining $6$ states are $A,\\,G,\\,G,\\,G,\\,A,\\,A$. State frequencies: Count($A$) = $3$, Count($G$) = $3$. Both frequencies are $\\ge 2$. Thus, **$C_{9}$ is parsimony-informative**.\n\n- **$C_{10}$ (nucleotide)**: States are $A,\\,A,\\,A,\\,A,\\,A,\\,A,\\,G,\\,C,\\,T$. All $9$ taxa are unambiguously coded. State frequencies: Count($A$) = $6$, Count($G$) = $1$, Count($C$) = $1$, Count($T$) = $1$. Only one state has a frequency $\\ge 2$. Thus, $C_{10}$ is not parsimony-informative.\n\n- **$C_{11}$ (morphological)**: States are $0,\\,1,\\,2,\\,3,\\,0,\\,1,\\,2,\\,3,\\,?$. One taxon is coded as $?$. The remaining $8$ states are $0,\\,1,\\,2,\\,3,\\,0,\\,1,\\,2,\\,3$. State frequencies: Count($0$) = $2$, Count($1$) = $2$, Count($2$) = $2$, Count($3$) = $2$. All four frequencies are $\\ge 2$. Thus, **$C_{11}$ is parsimony-informative**.\n\n- **$C_{12}$ (nucleotide)**: States are $N,\\,N,\\,N,\\,N,\\,N,\\,G,\\,C,\\,-,\\,N$. Seven taxa are coded with ambiguous or inapplicable states ($N, -$). The remaining $2$ states are $G,\\,C$. State frequencies: Count($G$) = $1$, Count($C$) = $1$. No state has a frequency $\\ge 2$. Thus, $C_{12}$ is not parsimony-informative.\n\n- **$C_{13}$ (morphological)**: States are $1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1$. All $9$ taxa are unambiguously coded. State frequencies: Count($1$) = $5$, Count($0$) = $4$. Both frequencies are $\\ge 2$. Thus, **$C_{13}$ is parsimony-informative**.\n\n- **$C_{14}$ (nucleotide)**: States are $A,\\,A,\\,M,\\,C,\\,C,\\,M,\\,C,\\,C,\\,A$. Two taxa are coded with an ambiguous state ($M$). The remaining $7$ states are $A,\\,A,\\,C,\\,C,\\,C,\\,C,\\,A$. State frequencies: Count($A$) = $3$, Count($C$) = $4$. Both frequencies are $\\ge 2$. Thus, **$C_{14}$ is parsimony-informative**.\n\n- **$C_{15}$ (morphological)**: States are $?,\\,?,\\,1,\\,0,\\,-,\\,-,\\,-,\\,1,\\,-$. Seven taxa are coded with missing or inapplicable states ($?, -$). The remaining $3$ states are $1,\\,0,\\,1$. State frequencies: Count($1$) = $2$, Count($0$) = $1$. Only one state has a frequency $\\ge 2$. Thus, $C_{15}$ is not parsimony-informative.\n\n**Conclusion**\n\nThe parsimony-informative characters are $C_{1}, C_{3}, C_{4}, C_{6}, C_{7}, C_{8}, C_{9}, C_{11}, C_{13}, \\text{ and } C_{14}$.\nThe total count of parsimony-informative characters is $10$.", "answer": "$$\n\\boxed{10}\n$$", "id": "2605510"}, {"introduction": "The evolutionary history of a single gene often differs from the history of the species that carries it, a central challenge in modern systematics. Incomplete Lineage Sorting (ILS) is a major cause of this discordance, and its likelihood can be quantified using the Multispecies Coalescent model as a function of effective population size ($N_e$) and divergence times. This problem [@problem_id:2605544] provides direct practice in calculating these probabilities, building a quantitative intuition for how population genetic forces shape the phylogenies inferred from genomic data.", "problem": "A taxonomist is evaluating how incomplete lineage sorting influences the inference of a species tree for three closely related oak species named under binomial nomenclature: *Quercus alba*, *Quercus rubra*, and *Quercus robur*. The hypothesized species tree is $((\\textit{Q. alba}, \\textit{Q. rubra}), \\textit{Q. robur})$, with divergence times in generations given by $t_{AB} = 2.0 \\times 10^{5}$ for the split between $\\textit{Q. alba}$ and $\\textit{Q. rubra}$, and $t_{ABC} = 3.2 \\times 10^{5}$ for the split between their ancestor and $\\textit{Q. robur}$. Assume the internal ancestral branch between these two divergence times has constant effective population sizes: for a biparentally inherited diploid nuclear locus, $N_{e}^{\\text{nuc}} = 2.5 \\times 10^{5}$, and for a maternally inherited haploid chloroplast deoxyribonucleic acid (cpDNA) locus, $N_{e}^{\\text{cp}} = 6.25 \\times 10^{4}$. You sample one lineage per species per locus.\n\nUnder the standard neutral Multispecies Coalescent (MSC) model (panmictic populations, no selection, no migration, constant effective sizes on each branch), and considering only incomplete lineage sorting as the cause of topological discordance, compute the ratio\n$$\nR \\;=\\; \\frac{\\Pr(\\text{a nuclear gene tree is topologically discordant with the species tree})}{\\Pr(\\text{a cpDNA gene tree is topologically discordant with the species tree})}.\n$$\nExpress your final answer as a decimal rounded to four significant figures. No units are required.", "solution": "The problem is first validated for scientific and logical soundness. The givens are:\n1.  Species: *Quercus alba* (species A), *Quercus rubra* (species B), and *Quercus robur* (species C).\n2.  Species tree topology: $((A, B), C)$.\n3.  Divergence time between A and B: $t_{AB} = 2.0 \\times 10^{5}$ generations.\n4.  Divergence time between the ancestor of (A, B) and C: $t_{ABC} = 3.2 \\times 10^{5}$ generations.\n5.  Nuclear locus is diploid with effective population size $N_{e}^{\\text{nuc}} = 2.5 \\times 10^{5}$.\n6.  Chloroplast locus (cpDNA) is haploid with effective population size $N_{e}^{\\text{cp}} = 6.25 \\times 10^{4}$.\n7.  The model is the standard neutral Multispecies Coalescent (MSC).\n8.  The task is to compute the ratio $R$ of the probabilities of gene tree discordance for the nuclear locus versus the cpDNA locus.\n\nThe problem statement is scientifically grounded in the established principles of coalescent theory and population genetics. It is well-posed, providing all necessary parameters and a clear objective. There are no contradictions, ambiguities, or factual inaccuracies. The problem is deemed valid and a solution will be provided.\n\nThe core of this problem lies in understanding incomplete lineage sorting (ILS) as described by the Multispecies Coalescent model for a three-taxon case. For a species tree with the topology $((A, B), C)$, there are three possible rooted gene tree topologies for a sample of one lineage from each species: the concordant topology $((A, B), C)$, and two discordant topologies, $((A, C), B)$ and $((B, C), A)$.\n\nThe probability of obtaining a discordant gene tree is a direct function of the length of the internal branch of the species tree, measured in coalescent units. The probability that two gene lineages, sampled from sister species A and B, fail to coalesce in their common ancestral population is given by $\\exp(-T)$, where $T$ is the duration of that ancestral population (the internal branch) in coalescent units. If they fail to coalesce, all three lineages (from A, B, and C) enter the deeper ancestral population. Under neutrality, any pair of these three lineages is then equally likely to coalesce first, with a probability of $\\frac{1}{3}$ for each pairing. The gene tree topology will be concordant, i.e., $((A, B), C)$, only if lineages A and B coalesce first. The other two pairings, (A, C) and (B, C), result in discordant topologies.\n\nTherefore, the total probability of obtaining a discordant gene tree is the probability of non-coalescence on the internal branch multiplied by the probability of a discordant coalescence event in the deep ancestor:\n$$\n\\Pr(\\text{discordant}) = \\exp(-T) \\times \\left( \\Pr(A,C \\text{ coalesce first}) + \\Pr(B,C \\text{ coalesce first}) \\right) = \\exp(-T) \\times \\left( \\frac{1}{3} + \\frac{1}{3} \\right) = \\frac{2}{3} \\exp(-T)\n$$\n\nThe length of the internal branch in generations, $\\tau$, is the time between the two speciation events:\n$$\n\\tau = t_{ABC} - t_{AB} = (3.2 \\times 10^{5}) - (2.0 \\times 10^{5}) = 1.2 \\times 10^{5} \\text{ generations}\n$$\nThe length of this branch in coalescent units, $T$, depends on the effective population size $N_e$ and the ploidy of the locus. The rate of coalescence for two lineages is $\\frac{1}{2N_e}$ for a diploid locus and $\\frac{1}{N_e}$ for a haploid locus. The branch length $T$ is the product of the time in generations and the coalescence rate.\n\nFirst, we calculate $T$ for the diploid nuclear locus, $T_{\\text{nuc}}$:\n$$\nT_{\\text{nuc}} = \\frac{\\tau}{2 N_{e}^{\\text{nuc}}} = \\frac{1.2 \\times 10^{5}}{2 \\times (2.5 \\times 10^{5})} = \\frac{1.2 \\times 10^{5}}{5.0 \\times 10^{5}} = 0.24\n$$\nThe probability of a discordant nuclear gene tree, $\\Pr(\\text{nuc discordant})$, is:\n$$\n\\Pr(\\text{nuc discordant}) = \\frac{2}{3} \\exp(-T_{\\text{nuc}}) = \\frac{2}{3} \\exp(-0.24)\n$$\n\nNext, we calculate $T$ for the haploid cpDNA locus, $T_{\\text{cp}}$. The effective population size for a maternally inherited haploid organelle is typically one-quarter that of a biparentally inherited diploid nuclear gene, assuming equal sex ratio and variance in reproductive success. The given values $N_{e}^{\\text{cp}} = 6.25 \\times 10^{4}$ and $N_{e}^{\\text{nuc}} = 2.5 \\times 10^{5}$ are consistent with this expectation, as $\\frac{N_{e}^{\\text{nuc}}}{4} = \\frac{2.5 \\times 10^{5}}{4} = 6.25 \\times 10^{4} = N_{e}^{\\text{cp}}$.\n$$\nT_{\\text{cp}} = \\frac{\\tau}{N_{e}^{\\text{cp}}} = \\frac{1.2 \\times 10^{5}}{6.25 \\times 10^{4}} = 1.92\n$$\nThe probability of a discordant cpDNA gene tree, $\\Pr(\\text{cpDNA discordant})$, is:\n$$\n\\Pr(\\text{cpDNA discordant}) = \\frac{2}{3} \\exp(-T_{\\text{cp}}) = \\frac{2}{3} \\exp(-1.92)\n$$\n\nFinally, we compute the required ratio, $R$:\n$$\nR = \\frac{\\Pr(\\text{nuc discordant})}{\\Pr(\\text{cpDNA discordant})} = \\frac{\\frac{2}{3} \\exp(-T_{\\text{nuc}})}{\\frac{2}{3} \\exp(-T_{\\text{cp}})} = \\frac{\\exp(-0.24)}{\\exp(-1.92)}\n$$\nUsing the properties of exponents, this simplifies to:\n$$\nR = \\exp(-0.24 - (-1.92)) = \\exp(1.92 - 0.24) = \\exp(1.68)\n$$\nNow we compute the numerical value and round to four significant figures:\n$$\nR \\approx 5.365555...\n$$\n$$\nR \\approx 5.366\n$$\nThe result indicates that a nuclear gene tree is substantially more likely to be discordant with the species tree than a cpDNA gene tree under these conditions. This is an expected outcome because the larger effective population size of the nuclear genome (scaled by ploidy, $2N_e$ vs $N_e$) results in a shorter internal branch length in coalescent units, increasing the probability of ILS.", "answer": "$$\\boxed{5.366}$$", "id": "2605544"}, {"introduction": "Species delimitation is the synthetic process of identifying distinct evolutionary lineages and assigning them valid names according to formal rules. This capstone exercise [@problem_id:2605531] moves from theory to practice by tasking you with an implementation of a complete, algorithm-based delimitation workflow. By writing code to integrate genetic and morphological data and apply nomenclatural checks, you will gain hands-on experience with the computational tools that are central to modern taxonomy.", "problem": "Implement a program that formalizes a transparent, principle-based species delimitation workflow and validates binomial names for the delimited species. The workflow must be derived from core definitions in taxonomy and systematics, not from black-box formulas. You must integrate genetic and morphological evidence through a reproducible, purely mathematical construction and then check binomial nomenclature constraints.\n\nFoundational base:\n- Species are operationally recognized as cohesive, diagnosable clusters: individuals are more similar to each other than to individuals outside the cluster under a justifiable criterion.\n- The “barcode gap” condition formalizes diagnosability: for any two putative species, the smallest between-cluster dissimilarity should exceed the largest within-cluster dissimilarity.\n- Binomial nomenclature requires that, within a genus, species epithets are unique and each binomial is well-formed.\n\nDefinitions to implement:\n- Let $D \\in \\mathbb{R}^{n \\times n}$ be a symmetric genetic distance matrix with $D_{ii}=0$.\n- Let $M \\in \\mathbb{R}^{n \\times p}$ be a morphological trait matrix (continuous traits).\n- Let $w_g \\in \\mathbb{R}_{\\ge 0}$ and $w_m \\in \\mathbb{R}_{\\ge 0}$ be weights for genetic and morphological evidence, respectively.\n- Standardize each morphological trait by its sample standard deviation $s_k$ across the $n$ specimens; if any $s_k=0$, treat that trait as contributing $0$ to morphological distances.\n- Define the combined dissimilarity between specimens $i$ and $j$ as\n$$\n\\delta_{ij} \\;=\\; w_g \\, D_{ij} \\;+\\; w_m \\, \\sqrt{\\sum_{k=1}^{p} \\left(\\frac{M_{ik}-M_{jk}}{s_k}\\right)^2}.\n$$\n- Given a threshold $\\tau_{\\text{intra}} \\in \\mathbb{R}_{>0}$, construct an undirected graph on the $n$ specimens by adding an edge $\\{i,j\\}$ if and only if $\\delta_{ij} \\le \\tau_{\\text{intra}}$. The connected components of this graph are the provisional species.\n- For any component $C$, define its maximum within-cluster dissimilarity by\n$$\n\\Delta_{\\text{intra}}(C) \\;=\\; \\begin{cases}\n0, & |C|\\le 1,\\\\\n\\max\\limits_{i,j \\in C,\\, i<j} \\delta_{ij}, & |C|\\ge 2,\n\\end{cases}\n$$\nand for components $C_a \\neq C_b$, define the minimum between-cluster dissimilarity\n$$\n\\Delta_{\\text{inter}}(C_a, C_b) \\;=\\; \\min\\limits_{i \\in C_a,\\, j \\in C_b} \\delta_{ij}.\n$$\n- Barcode-gap merging loop: if there exists a pair $(C_a, C_b)$ with $\\Delta_{\\text{intra}}(C_a) \\ge \\Delta_{\\text{inter}}(C_a,C_b)$ or $\\Delta_{\\text{intra}}(C_b) \\ge \\Delta_{\\text{inter}}(C_a,C_b)$, merge the violating pair with the smallest $\\Delta_{\\text{inter}}$ into a single component and repeat. The loop terminates when no violations remain. Let $m$ be the total number of merges performed.\n- Binomial nomenclature validity check for the final components:\n  - Each final component must have a single genus shared by all its members; the genus must be alphabetic with exactly one leading uppercase letter followed by lowercase letters.\n  - Each final component must have a single species epithet shared by all its members; the epithet must be alphabetic, all lowercase, with length between $3$ and $12$ inclusive.\n  - Within each genus, species epithets across different components must be unique.\n\nYour program must:\n- Implement the construction of $\\delta_{ij}$, the $\\tau_{\\text{intra}}$-graph, the barcode-gap merging loop, and the binomial nomenclature validity check as specified above.\n- For each test case, output a three-element list $[k, m, \\text{naming\\_ok}]$ where $k$ is the final number of delimited species (the number of connected components after the merging loop), $m$ is the integer count of merges performed, and $\\text{naming\\_ok}$ is a boolean indicating whether the final binomials pass the validity checks.\n\nTest suite (use these exact numerical parameters):\n- Test case A:\n  - $n=6$, $p=2$, $w_g=1.0$, $w_m=0.3$, $\\tau_{\\text{intra}}=0.1$.\n  - Genetic distance matrix $D$ (rows in order $0$ to $5$):\n    - Row $0$: $[0,\\,0.018,\\,0.022,\\,0.14,\\,0.15,\\,0.16]$\n    - Row $1$: $[0.018,\\,0,\\,0.019,\\,0.13,\\,0.14,\\,0.15]$\n    - Row $2$: $[0.022,\\,0.019,\\,0,\\,0.12,\\,0.13,\\,0.14]$\n    - Row $3$: $[0.14,\\,0.13,\\,0.12,\\,0,\\,0.017,\\,0.021]$\n    - Row $4$: $[0.15,\\,0.14,\\,0.13,\\,0.017,\\,0,\\,0.020]$\n    - Row $5$: $[0.16,\\,0.15,\\,0.14,\\,0.021,\\,0.020,\\,0]$\n  - Morphological trait matrix $M$:\n    - Row $0$: $[0.02,\\,-0.03]$\n    - Row $1$: $[-0.01,\\,0.04]$\n    - Row $2$: $[0.00,\\,0.00]$\n    - Row $3$: $[1.02,\\,0.97]$\n    - Row $4$: $[0.95,\\,1.03]$\n    - Row $5$: $[1.01,\\,0.96]$\n  - Genus list: [\"Rana\", \"Rana\", \"Rana\", \"Rana\", \"Rana\", \"Rana\"].\n  - Epithet list: [\"lutea\", \"lutea\", \"lutea\", \"rubra\", \"rubra\", \"rubra\"].\n\n- Test case B:\n  - $n=4$, $p=2$, $w_g=1.0$, $w_m=0.05$, $\\tau_{\\text{intra}}=0.06$.\n  - Genetic distance matrix $D$:\n    - Row $0$: $[0,\\,0.04,\\,0.08,\\,0.07]$\n    - Row $1$: $[0.04,\\,0,\\,0.04,\\,0.075]$\n    - Row $2$: $[0.08,\\,0.04,\\,0,\\,0.072]$\n    - Row $3$: $[0.07,\\,0.075,\\,0.072,\\,0]$\n  - Morphological trait matrix $M$:\n    - Row $0$: $[0.00,\\,0.00]$\n    - Row $1$: $[0.02,\\,-0.01]$\n    - Row $2$: $[0.03,\\,-0.02]$\n    - Row $3$: $[0.04,\\,0.00]$\n  - Genus list: [\"Quercus\", \"Quercus\", \"Quercus\", \"Quercus\"].\n  - Epithet list: [\"alba\", \"alba\", \"albus\", \"alba\"].\n\n- Test case C:\n  - $n=5$, $p=2$, $w_g=1.0$, $w_m=0.25$, $\\tau_{\\text{intra}}=0.09$.\n  - Genetic distance matrix $D$:\n    - Row $0$: $[0,\\,0.03,\\,0.11,\\,0.22,\\,0.23]$\n    - Row $1$: $[0.03,\\,0,\\,0.12,\\,0.21,\\,0.22]$\n    - Row $2$: $[0.11,\\,0.12,\\,0,\\,0.24,\\,0.25]$\n    - Row $3$: $[0.22,\\,0.21,\\,0.24,\\,0,\\,0.027]$\n    - Row $4$: $[0.23,\\,0.22,\\,0.25,\\,0.027,\\,0]$\n  - Morphological trait matrix $M$:\n    - Row $0$: $[0.00,\\,0.00]$\n    - Row $1$: $[0.01,\\,-0.02]$\n    - Row $2$: $[0.60,\\,0.60]$\n    - Row $3$: $[2.00,\\,2.00]$\n    - Row $4$: $[1.98,\\,2.02]$\n  - Genus list: [\"Salvia\", \"Salvia\", \"Salvia\", \"Pinus\", \"Pinus\"].\n  - Epithet list: [\"officinalis\", \"officinalis\", \"splendens\", \"officinalis\", \"officinalis\"].\n\nAngle or physical units are not applicable. All outputs are dimensionless.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces. Each test case result must be a three-element list of the form $[k,m,\\text{naming\\_ok}]$. For example: $[[2,0,\\text{True}],[1,1,\\text{False}],[3,0,\\text{True}]]$.", "solution": "The problem statement is subjected to validation.\n\nStep 1: Extract Givens.\nThe problem provides a detailed, algorithmic framework for species delimitation and a set of rules for validating binomial nomenclature. It specifies the following definitions and computational steps:\n- A symmetric genetic distance matrix $D \\in \\mathbb{R}^{n \\times n}$.\n- A morphological trait matrix $M \\in \\mathbb{R}^{n \\times p}$.\n- Non-negative scalar weights $w_g$ and $w_m$.\n- A positive dissimilarity threshold $\\tau_{\\text{intra}}$.\n- A formula for combined dissimilarity $\\delta_{ij}$:\n$$\n\\delta_{ij} \\;=\\; w_g \\, D_{ij} \\;+\\; w_m \\, \\sqrt{\\sum_{k=1}^{p} \\left(\\frac{M_{ik}-M_{jk}}{s_k}\\right)^2}\n$$\nwhere $s_k$ is the sample standard deviation of the $k$-th trait. If $s_k=0$, the trait's contribution is $0$.\n- A procedure for initial clustering: specimens $i$ and $j$ are connected if $\\delta_{ij} \\le \\tau_{\\text{intra}}$. Provisional species are the connected components of this graph.\n- A procedure for refining clusters via a barcode-gap merging loop. A pair of clusters $(C_a, C_b)$ is merged if $\\Delta_{\\text{intra}}(C_a) \\ge \\Delta_{\\text{inter}}(C_a,C_b)$ or $\\Delta_{\\text{intra}}(C_b) \\ge \\Delta_{\\text{inter}}(C_a,C_b)$. The pair with the smallest $\\Delta_{\\text{inter}}$ is merged first. This process is repeated until no such violating pairs exist.\n- A set of binomial nomenclature validity checks for final clusters regarding genus and epithet format, consistency within a cluster, and uniqueness of epithets within a genus.\n- Three fully specified test cases (A, B, C) with all necessary inputs ($n, p, w_g, w_m, \\tau_{\\text{intra}}, D, M$, and name lists).\n\nStep 2: Validate Using Extracted Givens.\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded**: The problem is well-grounded in the principles of systematics and taxonomy. The core idea of defining species as diagnosable clusters based on a gap between intra- and inter-specific variation (the \"barcode gap\") is a standard concept. The use of a combined evidence approach (genetic and morphological data) is also standard practice. The specific mathematical formulation is a simplified, operational model, but it is not pseudoscience; it is a formalization of established biological principles.\n- **Well-Posed**: The problem is algorithmically precise. Each step, from the calculation of $\\delta_{ij}$ to the merging loop and the final name validation, is deterministically defined. The merging loop has a clear termination condition (no more violating pairs exist), ensuring the process concludes. Given a set of inputs, a unique solution exists.\n- **Objective**: The problem is stated in objective, mathematical language. Vague concepts like \"cohesion\" and \"diagnosability\" are given explicit, quantitative definitions ($\\tau_{\\text{intra}}$-graph and barcode-gap condition). There are no subjective or opinion-based claims.\n- The problem is self-contained and internally consistent. It is not trivial, as it requires careful implementation of a multi-step algorithm involving graph theory and iterative refinement. It is not based on false premises or circular reasoning.\n\nStep 3: Verdict and Action.\nThe problem is deemed **valid**. It is a rigorous computational biology problem that formalizes principles from taxonomy into a reproducible workflow. A complete solution will be provided.\n\nThe solution is implemented by following the prescribed workflow. The main steps are: calculation of the combined dissimilarity matrix, initial clustering based on a threshold, iterative merging of clusters based on the barcode-gap criterion, and final validation of the binomial nomenclature.\n\n1.  **Combined Dissimilarity Matrix ($\\delta$) Calculation**:\n    For a set of $n$ specimens and $p$ morphological traits, the first step is to compute the $n \\times n$ combined dissimilarity matrix $\\delta$. For each pair of specimens $(i, j)$, $\\delta_{ij}$ integrates genetic distance $D_{ij}$ and morphological distance. The morphological distance is a weighted Euclidean distance in the trait space, where each trait axis $k$ is standardized by its sample standard deviation, $s_k$. This standardization ensures that traits with larger variance do not disproportionately influence the distance. Per the problem, if a trait has zero variance ($s_k = 0$), its contribution to the distance is $0$. The total dissimilarity is the weighted sum:\n    $$\n    \\delta_{ij} \\;=\\; w_g \\, D_{ij} \\;+\\; w_m \\, \\sqrt{\\sum_{k=1}^{p} \\left(\\frac{M_{ik}-M_{jk}}{s_k}\\right)^2}.\n    $$\n    This matrix $\\delta$ serves as the basis for all subsequent clustering steps.\n\n2.  **Initial Clustering**:\n    An undirected graph is constructed with $n$ vertices, representing the specimens. An edge is placed between vertices $i$ and $j$ if and only if their combined dissimilarity $\\delta_{ij}$ is less than or equal to a given threshold, $\\tau_{\\text{intra}}$. This threshold represents a maximum level of dissimilarity considered to be \"intra-specific\". The connected components of this graph form the set of provisional species. A standard graph traversal algorithm, such as Breadth-First Search (BFS) or Depth-First Search (DFS), is used to identify these components.\n\n3.  **Barcode-Gap Merging Loop**:\n    This is an iterative refinement process. The initial clusters are tested against the barcode-gap criterion, which formalizes the principle that within-group variation should be smaller than between-group variation. For any two distinct clusters $C_a$ and $C_b$:\n    - The maximum intra-cluster dissimilarity is $\\Delta_{\\text{intra}}(C) = \\max_{i,j \\in C} \\delta_{ij}$.\n    - The minimum inter-cluster dissimilarity is $\\Delta_{\\text{inter}}(C_a, C_b) = \\min_{i \\in C_a, j \\in C_b} \\delta_{ij}$.\n    A violation occurs if $\\Delta_{\\text{intra}}(C_a) \\ge \\Delta_{\\text{inter}}(C_a, C_b)$ or $\\Delta_{\\text{intra}}(C_b) \\ge \\Delta_{\\text{inter}}(C_a, C_b)$. This indicates that the two clusters are not clearly diagnosable, as the largest gap within one is greater than or equal to the smallest gap between them.\n    The algorithm proceeds in a loop:\n    a. In each iteration, all pairs of current clusters are checked for violations.\n    b. If no violations are found, the process terminates. The current set of clusters is the final delimitation.\n    c. If one or more violating pairs exist, the one for which $\\Delta_{\\text{inter}}$ is the smallest is chosen for merging. The two clusters in this pair are combined into a single new cluster. The count of merges, $m$, is incremented.\n    d. The loop then repeats with the new set of clusters. This greedy strategy aims to resolve the most egregious violation first.\n\n4.  **Binomial Nomenclature Validation**:\n    After the merging loop terminates, the final $k$ clusters are checked for compliance with nomenclatural rules. A boolean flag, $\\text{naming\\_ok}$, is used to track validity. The checks are performed for each cluster:\n    a. **Consistency**: All specimens within a single cluster must have the same genus name and the same species epithet.\n    b. **Format**: Genus names must be alphabetic and capitalized (e.g., `Rana`). Species epithets must be alphabetic, lowercase, and have a length between $3$ and $12$ characters, inclusive.\n    c. **Uniqueness**: Within a given genus, all delimited species (clusters) must have unique species epithets. For example, two distinct final clusters cannot both be named `Rana lutea`.\n    If any of these rules are violated for any cluster, $\\text{naming\\_ok}$ is set to `False` and the validation can be stopped. Otherwise, it remains `True`.\n\nThe final output for each test case is a list containing the final number of species $k$, the total number of merges $m$, and the boolean validation result $\\text{naming\\_ok}$.", "answer": "```python\nimport numpy as np\nimport re\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Test case A\n        {\n            \"n\": 6, \"p\": 2, \"wg\": 1.0, \"wm\": 0.3, \"tau_intra\": 0.1,\n            \"D\": np.array([\n                [0, 0.018, 0.022, 0.14, 0.15, 0.16],\n                [0.018, 0, 0.019, 0.13, 0.14, 0.15],\n                [0.022, 0.019, 0, 0.12, 0.13, 0.14],\n                [0.14, 0.13, 0.12, 0, 0.017, 0.021],\n                [0.15, 0.14, 0.13, 0.017, 0, 0.020],\n                [0.16, 0.15, 0.14, 0.021, 0.020, 0]\n            ]),\n            \"M\": np.array([\n                [0.02, -0.03], [-0.01, 0.04], [0.00, 0.00],\n                [1.02, 0.97], [0.95, 1.03], [1.01, 0.96]\n            ]),\n            \"genera\": [\"Rana\", \"Rana\", \"Rana\", \"Rana\", \"Rana\", \"Rana\"],\n            \"epithets\": [\"lutea\", \"lutea\", \"lutea\", \"rubra\", \"rubra\", \"rubra\"]\n        },\n        # Test case B\n        {\n            \"n\": 4, \"p\": 2, \"wg\": 1.0, \"wm\": 0.05, \"tau_intra\": 0.06,\n            \"D\": np.array([\n                [0, 0.04, 0.08, 0.07],\n                [0.04, 0, 0.04, 0.075],\n                [0.08, 0.04, 0, 0.072],\n                [0.07, 0.075, 0.072, 0]\n            ]),\n            \"M\": np.array([\n                [0.00, 0.00], [0.02, -0.01], [0.03, -0.02], [0.04, 0.00]\n            ]),\n            \"genera\": [\"Quercus\", \"Quercus\", \"Quercus\", \"Quercus\"],\n            \"epithets\": [\"alba\", \"alba\", \"albus\", \"alba\"]\n        },\n        # Test case C\n        {\n            \"n\": 5, \"p\": 2, \"wg\": 1.0, \"wm\": 0.25, \"tau_intra\": 0.09,\n            \"D\": np.array([\n                [0, 0.03, 0.11, 0.22, 0.23],\n                [0.03, 0, 0.12, 0.21, 0.22],\n                [0.11, 0.12, 0, 0.24, 0.25],\n                [0.22, 0.21, 0.24, 0, 0.027],\n                [0.23, 0.22, 0.25, 0.027, 0]\n            ]),\n            \"M\": np.array([\n                [0.00, 0.00], [0.01, -0.02], [0.60, 0.60],\n                [2.00, 2.00], [1.98, 2.02]\n            ]),\n            \"genera\": [\"Salvia\", \"Salvia\", \"Salvia\", \"Pinus\", \"Pinus\"],\n            \"epithets\": [\"officinalis\", \"officinalis\", \"splendens\", \"officinalis\", \"officinalis\"]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_one_case(**case)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    print(str(results).replace(\" \", \"\"))\n\ndef _find_components(n, adj):\n    \"\"\"Finds connected components in a graph using BFS.\"\"\"\n    visited = [False] * n\n    components = []\n    for i in range(n):\n        if not visited[i]:\n            component = []\n            q = [i]\n            visited[i] = True\n            head = 0\n            while head < len(q):\n                u = q[head]\n                head += 1\n                component.append(u)\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            components.append(sorted(component))\n    return components\n\ndef _solve_one_case(n, p, wg, wm, tau_intra, D, M, genera, epithets):\n    \"\"\"\n    Implements the entire species delimitation and validation workflow for a single test case.\n    \"\"\"\n    # Step 1: Calculate combined dissimilarity matrix\n    s = np.std(M, axis=0, ddof=1) if n > 1 else np.zeros(p)\n    \n    delta = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i + 1, n):\n            morph_dist_sq = 0\n            for k in range(p):\n                # Only add contribution if trait has variance\n                if s[k] > 0:\n                    morph_dist_sq += ((M[i, k] - M[j, k]) / s[k])**2\n            \n            morph_dist = np.sqrt(morph_dist_sq)\n            delta[i, j] = wg * D[i, j] + wm * morph_dist\n            delta[j, i] = delta[i, j]\n\n    # Step 2: Initial clustering\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if delta[i, j] <= tau_intra:\n                adj[i].append(j)\n                adj[j].append(i)\n    \n    components = _find_components(n, adj)\n\n    # Step 3: Barcode-gap merging loop\n    merges = 0\n    while True:\n        violating_pairs = []\n        num_components = len(components)\n        \n        for i in range(num_components):\n            for j in range(i + 1, num_components):\n                Ca, Cb = components[i], components[j]\n                \n                max_intra_a = 0.0\n                if len(Ca) > 1:\n                    max_intra_a = max(delta[u, v] for u_idx, u in enumerate(Ca) for v in Ca[u_idx+1:])\n                \n                max_intra_b = 0.0\n                if len(Cb) > 1:\n                    max_intra_b = max(delta[u, v] for u_idx, u in enumerate(Cb) for v in Cb[u_idx+1:])\n                \n                min_inter = min(delta[u, v] for u in Ca for v in Cb)\n                \n                if max_intra_a >= min_inter or max_intra_b >= min_inter:\n                    violating_pairs.append({'inter': min_inter, 'pair_indices': (i, j)})\n        \n        if not violating_pairs:\n            break\n        \n        violating_pairs.sort(key=lambda x: x['inter'])\n        idx_a, idx_b = violating_pairs[0]['pair_indices']\n        \n        # Merge the two components. Create a new list for the next iteration.\n        merged_component = sorted(components[idx_a] + components[idx_b])\n        new_components = [merged_component]\n        for k in range(num_components):\n            if k != idx_a and k != idx_b:\n                new_components.append(components[k])\n        \n        components = new_components\n        merges += 1\n    \n    # Step 4: Binomial nomenclature validity check\n    k = len(components)\n    naming_ok = True\n    genus_epithets = {}\n    \n    gen_pattern = re.compile(r'^[A-Z][a-z]+$')\n    epi_pattern = re.compile(r'^[a-z]{3,12}$')\n\n    for comp in components:\n        if not naming_ok: break\n        \n        first_genus = genera[comp[0]]\n        first_epithet = epithets[comp[0]]\n\n        if not gen_pattern.fullmatch(first_genus) or not epi_pattern.fullmatch(first_epithet):\n            naming_ok = False\n            continue\n        \n        if not all(genera[i] == first_genus and epithets[i] == first_epithet for i in comp):\n            naming_ok = False\n            continue\n\n        if first_genus not in genus_epithets:\n            genus_epithets[first_genus] = set()\n        \n        if first_epithet in genus_epithets[first_genus]:\n            naming_ok = False\n        else:\n            genus_epithets[first_genus].add(first_epithet)\n\n    return [k, merges, naming_ok]\n\nsolve()\n```", "id": "2605531"}]}