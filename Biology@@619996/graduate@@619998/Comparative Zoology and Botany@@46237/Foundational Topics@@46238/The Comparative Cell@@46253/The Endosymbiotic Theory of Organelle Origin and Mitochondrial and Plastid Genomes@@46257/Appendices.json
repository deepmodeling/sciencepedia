{"hands_on_practices": [{"introduction": "The endosymbiotic theory suggests that mitochondria descended from an alphaproteobacterial ancestor, but what was this ancestor's gene content like? This practice allows you to step into the role of a computational biologist and use the principle of maximum parsimony to reconstruct the ancestral protein profile [@problem_id:2616609]. You will implement a dynamic programming algorithm to find the most likely ancestral states, exploring how changing the relative costs of gene gain ($g$) and loss ($\\ell$) impacts our inference about the ancient endosymbiont's proteome.", "problem": "You are given a binary character matrix that encodes the presence ($1$) or absence ($0$) of bacterial signature proteins across a set of eukaryotic mitochondrial proteomes, together with a fixed rooted binary phylogeny relating these eukaryotic taxa. Under the endosymbiotic theory, the mitochondrial ancestor was an alphaproteobacterial endosymbiont; in this problem, you will model the inference of the most parsimonious ancestral donor profile at the mitochondrial root as an instance of rooted maximum parsimony with asymmetric gain and loss costs.\n\nFundamental base and definitions to use:\n- Principle of maximum parsimony: among all possible assignments of ancestral character states on a fixed tree, prefer the assignment that minimizes the total number of state changes (with costs if asymmetric).\n- Additive cost model on a rooted tree: for a binary character with parent state $s \\in \\{0,1\\}$ and child state $t \\in \\{0,1\\}$, an edge contributes a nonnegative cost $w_{s,t}$ to the total, with $w_{0,0} = w_{1,1} = 0$, $w_{0,1} = g$ (a gain), and $w_{1,0} = \\ell$ (a loss). The total cost is the sum over all edges and characters.\n\nYou must compute, for each character independently, the ancestral state at the root that minimizes the total parsimony cost under the specified $(g,\\ell)$, using the dynamic programming recursion consistent with the rooted parsimony model above. When there is a tie at the root (equal minimal cost for root state $0$ and $1$), you must break ties deterministically by a majority-of-leaves rule: choose root state $1$ if and only if the number of leaves in state $1$ for that character is greater than or equal to half the number of leaves; otherwise choose $0$. This rule must only be used when the two minimal costs are exactly equal.\n\nFixed rooted binary tree (parent to children):\n- Root $\\rightarrow$ $N3$, $N4$.\n- $N3 \\rightarrow N1$, $N2$.\n- $N1 \\rightarrow$ Human $(H)$, Yeast $(Y)$.\n- $N2 \\rightarrow$ Tetrahymena $(Te)$, Trypanosoma $(Tr)$.\n- $N4 \\rightarrow$ Arabidopsis $(A)$, Cyanidioschyzon $(Cn)$.\n\nLeaf order for data vectors is $(H, Y, A, Cn, Te, Tr)$.\n\nBinary character matrix for $8$ bacterial signature proteins $P1,\\dots,P8$ (each as a vector of length $6$ in the leaf order above):\n- $P1$: $[1,1,1,1,1,1]$.\n- $P2$: $[1,0,1,1,1,0]$.\n- $P3$: $[1,0,1,1,0,0]$.\n- $P4$: $[0,0,0,0,0,1]$.\n- $P5$: $[1,1,0,0,0,0]$.\n- $P6$: $[1,1,1,1,0,1]$.\n- $P7$: $[0,1,0,1,1,0]$.\n- $P8$: $[0,0,0,0,0,0]$.\n\nYour task:\n- Implement a rooted maximum parsimony algorithm for binary characters under an asymmetric cost model with per-edge costs $w_{0,1} = g$ and $w_{1,0} = \\ell$ as defined above, and $w_{0,0} = w_{1,1} = 0$. For each protein $Pk$, compute the root state that minimizes the total parsimony cost. Use dynamic programming where for each node $v$ and state $s \\in \\{0,1\\}$, you compute the minimal cost $F_v(s)$ for the subtree below $v$ assuming $v$ is assigned state $s$, using the recurrence\n$$\nF_v(s) \\;=\\; \\sum_{u \\in \\text{children}(v)} \\min_{t \\in \\{0,1\\}} \\left( F_u(t) + w_{s,t} \\right),\n$$\nwith boundary conditions at leaves $x$: $F_x(t_x) = 0$ and $F_x(1 - t_x) = +\\infty$, where $t_x$ is the observed leaf state.\n- For each protein, choose the root state $s^\\star \\in \\{0,1\\}$ that minimizes $F_{\\text{root}}(s)$. Apply the tie-breaking rule stated above when $F_{\\text{root}}(0) = F_{\\text{root}}(1)$.\n\nTest suite:\nEvaluate the donor profile (the vector of root states across the $8$ proteins, in order $[P1,\\dots,P8]$) for the following four $(g,\\ell)$ settings:\n- Case 1: $(g,\\ell) = (1,1)$.\n- Case 2: $(g,\\ell) = (3,1)$.\n- Case 3: $(g,\\ell) = (1,3)$.\n- Case 4: $(g,\\ell) = (10,1)$.\n\nProgram output specification:\n- Your program must produce a single line of output containing the four inferred donor profiles, in the same order as the test suite cases above, aggregated as a comma-separated list enclosed in square brackets. Each donor profile must itself be a list of $8$ integers ($0$ or $1$) enclosed in square brackets. There must be no spaces anywhere in the output string. For example, a valid shape is $[[a_1,\\dots,a_8],[b_1,\\dots,b_8],[c_1,\\dots,c_8],[d_1,\\dots,d_8]]$ where each $a_i,b_i,c_i,d_i \\in \\{0,1\\}$.", "solution": "The problem requires the determination of the most parsimonious ancestral character states at the root of a given phylogeny. This is a classic instance of the \"small parsimony problem,\" where the tree topology is fixed and we seek the optimal assignment of states to internal nodes. The problem is to be solved for each of $8$ binary characters independently, under four different asymmetric cost models. The solution is formulated using a dynamic programming algorithm, commonly known as the Sankoff algorithm, adapted for a rooted tree.\n\nLet the given rooted binary tree be denoted by $T = (V, E)$, where $V$ is the set of nodes and $E$ is the set of directed edges from parent to child. The set of leaves, or terminal nodes, is denoted by $L \\subset V$. For each character, we are given the state $t_x \\in \\{0, 1\\}$ for each leaf $x \\in L$. We are also given a cost model for state changes along any edge $(v, u) \\in E$, where $v$ is the parent and $u$ is the child. The cost $w_{s,t}$ is incurred for a transition from parent state $s \\in \\{0,1\\}$ to child state $t \\in \\{0,1\\}$, defined as:\n$$\nw_{s,t} = \\begin{cases}\ng & \\text{if } s=0, t=1 \\quad (\\text{a gain}) \\\\\n\\ell & \\text{if } s=1, t=0 \\quad (\\text{a loss}) \\\\\n0 & \\text{if } s=t \\quad (\\text{no change})\n\\end{cases}\n$$\nwhere $g$ and $\\ell$ are non-negative cost parameters. The total parsimony cost of a full ancestral state assignment $\\mathcal{A} = \\{s_v\\}_{v \\in V}$ is the sum of costs over all edges:\n$$\nC(\\mathcal{A}) = \\sum_{(v,u) \\in E} w_{s_v, s_u}\n$$\nThe objective is to find an assignment $\\mathcal{A}$ that minimizes $C(\\mathcal{A})$.\n\nThe dynamic programming approach solves this by computing, for each node $v \\in V$ and each possible state $s \\in \\{0,1\\}$, the minimum parsimony cost for the subtree rooted at $v$, under the condition that node $v$ is assigned state $s$. Let this minimum cost be denoted by $F_v(s)$.\n\nThe computation proceeds via a post-order traversal of the tree, from the leaves to the root.\n\n$1$. Base Case: For any leaf node $x \\in L$, the observed state is $t_x$. The cost function is initialized according to these observations. Assigning the observed state $t_x$ to the leaf incurs zero cost for its (non-existent) subtree. Assigning the opposite state is impossible, so its cost is defined as infinite.\n$$\nF_x(s) =\n\\begin{cases}\n0 & \\text{if } s = t_x \\\\\n+\\infty & \\text{if } s \\neq t_x\n\\end{cases}\n$$\n\n$2$. Recursive Step: For any internal node $v \\in V$, let its children be $u_1, u_2, \\dots, u_k$. According to the principle of optimality, the minimum cost for the subtree at $v$ is the sum of the minimum costs for the subtrees of its children, plus the costs of the transitions from $v$ to its children. The recurrence relation is given by:\n$$\nF_v(s) = \\sum_{u \\in \\text{children}(v)} \\min_{t \\in \\{0,1\\}} (F_u(t) + w_{s,t})\n$$\nFor a binary tree where $v$ has children $u_1$ and $u_2$, and for the two possible states $s=0$ and $s=1$ for node $v$, this expands to:\n$$\nF_v(0) = \\left[ \\min(F_{u_1}(0) + w_{0,0}, F_{u_1}(1) + w_{0,1}) \\right] + \\left[ \\min(F_{u_2}(0) + w_{0,0}, F_{u_2}(1) + w_{0,1}) \\right]\n$$\nSubstituting the cost values $w_{0,0}=0$ and $w_{0,1}=g$:\n$$\nF_v(0) = \\left[ \\min(F_{u_1}(0), F_{u_1}(1) + g) \\right] + \\left[ \\min(F_{u_2}(0), F_{u_2}(1) + g) \\right]\n$$\nSimilarly, for state $s=1$ at node $v$, with costs $w_{1,1}=0$ and $w_{1,0}=\\ell$:\n$$\nF_v(1) = \\left[ \\min(F_{u_1}(0) + w_{1,0}, F_{u_1}(1) + w_{1,1}) \\right] + \\left[ \\min(F_{u_2}(0) + w_{1,0}, F_{u_2}(1) + w_{1,1}) \\right]\n$$\n$$\nF_v(1) = \\left[ \\min(F_{u_1}(0) + \\ell, F_{u_1}(1)) \\right] + \\left[ \\min(F_{u_2}(0) + \\ell, F_{u_2}(1)) \\right]\n$$\n\n$3$. Final Determination at the Root: After the traversal completes, we will have computed the costs $F_{\\text{root}}(0)$ and $F_{\\text{root}}(1)$. The minimum total parsimony cost for the entire tree is $\\min(F_{\\text{root}}(0), F_{\\text{root}}(1))$. The optimal ancestral state for the root, $s^\\star_{\\text{root}}$, is the one corresponding to this minimum cost.\n$$\ns^\\star_{\\text{root}} = \\arg\\min_{s \\in \\{0,1\\}} F_{\\text{root}}(s)\n$$\n\n$4$. Tie-Breaking Rule: In the specific case where $F_{\\text{root}}(0) = F_{\\text{root}}(1)$, the problem specifies a deterministic tie-breaking rule. Let $N_1$ be the number of leaves with state $1$ and $N$ be the total number of leaves. The root state is chosen as $1$ if and only if $N_1 \\ge N/2$; otherwise, it is chosen as $0$.\n\nThis procedure is implemented and applied to each of the $8$ protein characters for each of the $4$ specified $(g, \\ell)$ cost pairs. The resulting $8$-dimensional root state vectors for each case are then compiled into the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the most parsimonious root state for multiple characters on a fixed phylogeny\n    using a dynamic programming algorithm with asymmetric costs.\n    \"\"\"\n    \n    # Define the fixed rooted binary tree structure (parent -> children)\n    tree = {\n        'Root': ['N3', 'N4'],\n        'N3': ['N1', 'N2'],\n        'N4': ['A', 'Cn'],\n        'N1': ['H', 'Y'],\n        'N2': ['Te', 'Tr'],\n        'H': [], 'Y': [], 'A': [], 'Cn': [], 'Te': [], 'Tr': []\n    }\n    \n    # Define the leaf order for interpreting character data vectors\n    leaf_names = ['H', 'Y', 'A', 'Cn', 'Te', 'Tr']\n    num_leaves = len(leaf_names)\n\n    # Define the binary character matrix for 8 proteins\n    characters = {\n        'P1': [1, 1, 1, 1, 1, 1],\n        'P2': [1, 0, 1, 1, 1, 0],\n        'P3': [1, 0, 1, 1, 0, 0],\n        'P4': [0, 0, 0, 0, 0, 1],\n        'P5': [1, 1, 0, 0, 0, 0],\n        'P6': [1, 1, 1, 1, 0, 1],\n        'P7': [0, 1, 0, 1, 1, 0],\n        'P8': [0, 0, 0, 0, 0, 0],\n    }\n    # Ensure ordered processing\n    char_list = [characters[f'P{i}'] for i in range(1, 9)]\n\n    # Define the test suite of (gain, loss) cost settings\n    test_cases = [\n        (1, 1),   # Case 1\n        (3, 1),   # Case 2\n        (1, 3),   # Case 3\n        (10, 1),  # Case 4\n    ]\n\n    all_results = []\n    \n    # Memoization cache for the dynamic programming algorithm\n    memo = {}\n\n    def get_parsimony_costs(node, char_map, g, l):\n        \"\"\"\n        Recursively compute parsimony costs using post-order traversal.\n        \n        Args:\n            node (str): The name of the current node.\n            char_map (dict): A map from leaf names to their character states.\n            g (float): The cost of a 0 -> 1 gain.\n            l (float): The cost of a 1 -> 0 loss.\n        \n        Returns:\n            tuple: A tuple (cost_for_state_0, cost_for_state_1) for the subtree at 'node'.\n        \"\"\"\n        if node in memo:\n            return memo[node]\n\n        # Base case: leaf node\n        if not tree[node]:\n            state = char_map[node]\n            cost0 = 0 if state == 0 else np.inf\n            cost1 = 0 if state == 1 else np.inf\n            memo[node] = (cost0, cost1)\n            return cost0, cost1\n\n        # Recursive step: internal node\n        total_cost0 = 0\n        total_cost1 = 0\n        for child in tree[node]:\n            child_cost0, child_cost1 = get_parsimony_costs(child, char_map, g, l)\n            \n            # Cost for parent state 0: F_v(0) = sum_u min(F_u(0), F_u(1) + g)\n            total_cost0 += min(child_cost0, child_cost1 + g)\n            \n            # Cost for parent state 1: F_v(1) = sum_u min(F_u(0) + l, F_u(1))\n            total_cost1 += min(child_cost0 + l, child_cost1)\n\n        memo[node] = (total_cost0, total_cost1)\n        return total_cost0, total_cost1\n\n    for g, l in test_cases:\n        case_profiles = []\n        for char_vector in char_list:\n            memo.clear()\n            char_map = {name: state for name, state in zip(leaf_names, char_vector)}\n            \n            cost0, cost1 = get_parsimony_costs('Root', char_map, g, l)\n            \n            root_state = 0\n            if cost1 < cost0:\n                root_state = 1\n            elif cost1 == cost0:\n                # Tie-breaking rule: majority of leaves\n                num_ones = sum(char_vector)\n                if num_ones >= num_leaves / 2:\n                    root_state = 1\n                else:\n                    root_state = 0\n            \n            case_profiles.append(root_state)\n        all_results.append(case_profiles)\n\n    # Format the output string exactly as specified\n    profile_strings = []\n    for profile in all_results:\n        profile_str = f\"[{','.join(map(str, profile))}]\"\n        profile_strings.append(profile_str)\n    \n    final_output_string = f\"[{','.join(profile_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2616609"}, {"introduction": "Organelle genomes exist in large populations within a cell, but only a small sample is passed to the next generation, creating a population bottleneck. This exercise delves into the population genetics of this transmission process to quantify its stochastic consequences [@problem_id:2616678]. By applying fundamental principles of probability, you will derive the expected variance in organelle allele frequencies (heteroplasmy) following a bottleneck, providing a precise mathematical formulation for the effects of genetic drift on organellar evolution.", "problem": "In both animals and plants, the endosymbiotic theory implies that mitochondria and plastids descend from free-living bacteria, leaving modern cells with many copies of mitochondrial DNA (mtDNA) or plastid DNA (ptDNA) per cell. During germline development in animals or during the formation of segregating lineages in plants, a developmental bottleneck transmits only a subset of these organelle genomes to each zygote or propagule. Consider a maternal cell with a very large pool of organelle genomes where the mutant allele frequency (heteroplasmy) is $p \\in (0,1)$. During the bottleneck, exactly $N_b$ organelle genomes are transmitted to a new lineage, each genome arising from an independent draw from the large maternal pool with mutant probability $p$. Let $X$ denote the number of mutant genomes among these $N_b$ transmitted genomes, and let the post-bottleneck heteroplasmy be $p' = X/N_b$.\n\nUsing only fundamental definitions of expectation and variance together with the independence of draws implied by the large-pool sampling assumption, derive the exact expression for the expected variance of the post-bottleneck heteroplasmy across lineages, $\\mathrm{Var}(p')$, as a function of $p$ and $N_b$. Express your final answer as a closed-form symbolic expression. No numerical approximation or rounding is required.", "solution": "The problem statement is first subjected to validation.\n\nGivens are extracted verbatim:\n1.  A maternal cell has a very large pool of organelle genomes.\n2.  The mutant allele frequency (heteroplasmy) is $p \\in (0,1)$.\n3.  Exactly $N_b$ organelle genomes are transmitted to a new lineage.\n4.  Each genome arises from an independent draw from the large maternal pool.\n5.  The probability of drawing a mutant genome is $p$.\n6.  $X$ is the number of mutant genomes among the $N_b$ transmitted genomes.\n7.  Post-bottleneck heteroplasmy is $p' = X/N_b$.\n8.  The objective is to derive the exact expression for the expected variance of the post-bottleneck heteroplasmy, $\\mathrm{Var}(p')$, as a function of $p$ and $N_b$.\n9.  The derivation must use only fundamental definitions of expectation and variance and the independence of draws.\n\nValidation verdict:\nThe problem is scientifically grounded, describing the standard Wright-Fisher sampling model applied to organelle transmission, a fundamental concept in population genetics and evolutionary biology. It is well-posed, with all variables ($p, N_b, X, p'$) clearly defined and sufficient information provided to derive a unique solution. The language is objective and precise. The problem is formalizable and relevant to its stated topic. It does not violate any of the criteria for invalidity. Therefore, the problem is deemed valid and a solution will be furnished.\n\nThe derivation proceeds as follows. The problem describes a sampling process consisting of $N_b$ independent trials. For each trial, a single organelle genome is drawn from a large maternal pool. The outcome of each trial can be one of two states: mutant, with probability $p$, or wild-type, with probability $1-p$. Let us define a set of $N_b$ random variables, $\\{Y_1, Y_2, \\ldots, Y_{N_b}\\}$, corresponding to each of the $N_b$ independent draws. Each $Y_i$ is a Bernoulli random variable where $Y_i=1$ if the $i$-th genome drawn is a mutant and $Y_i=0$ if it is wild-type.\n\nThe probability mass function for any single draw $Y_i$ is:\n$P(Y_i=1) = p$\n$P(Y_i=0) = 1-p$\n\nUsing the fundamental definition of expectation, the expected value of $Y_i$ is:\n$$ \\mathrm{E}[Y_i] = \\sum_{y} y \\cdot P(Y_i=y) = (1)(p) + (0)(1-p) = p $$\n\nTo find the variance of $Y_i$, we first compute the expectation of $Y_i^2$:\n$$ \\mathrm{E}[Y_i^2] = \\sum_{y} y^2 \\cdot P(Y_i=y) = (1^2)(p) + (0^2)(1-p) = p $$\n\nThe variance of $Y_i$ is defined as $\\mathrm{Var}(Y_i) = \\mathrm{E}[Y_i^2] - (\\mathrm{E}[Y_i])^2$. Substituting the derived values:\n$$ \\mathrm{Var}(Y_i) = p - p^2 = p(1-p) $$\n\nThe total number of mutant genomes, $X$, is the sum of the outcomes of these $N_b$ independent draws:\n$$ X = \\sum_{i=1}^{N_b} Y_i $$\n\nThis structure identifies $X$ as a random variable following a binomial distribution, $X \\sim \\mathrm{Binomial}(N_b, p)$. The problem requires a derivation from fundamental principles, which includes the property that for independent random variables, the variance of their sum is the sum of their variances. Since the draws are independent, all $Y_i$ variables are independent.\n$$ \\mathrm{Var}(X) = \\mathrm{Var}\\left(\\sum_{i=1}^{N_b} Y_i\\right) = \\sum_{i=1}^{N_b} \\mathrm{Var}(Y_i) $$\n\nSince all draws are from the same pool, the Bernoulli random variables $Y_i$ are also identically distributed, meaning $\\mathrm{Var}(Y_i) = p(1-p)$ for all $i$ from $1$ to $N_b$.\nTherefore, the variance of $X$ is:\n$$ \\mathrm{Var}(X) = \\sum_{i=1}^{N_b} p(1-p) = N_b p(1-p) $$\n\nThe post-bottleneck heteroplasmy, $p'$, is defined as a scaled version of the random variable $X$:\n$$ p' = \\frac{X}{N_b} $$\n\nWe are tasked with finding $\\mathrm{Var}(p')$. We use the fundamental property of variance concerning scaling by a constant factor. For any random variable $Z$ and any constant $a$, $\\mathrm{Var}(aZ) = a^2 \\mathrm{Var}(Z)$.\nIn this case, the random variable is $X$ and the constant is $a = \\frac{1}{N_b}$. Applying this aformentioned property:\n$$ \\mathrm{Var}(p') = \\mathrm{Var}\\left(\\frac{1}{N_b} X\\right) = \\left(\\frac{1}{N_b}\\right)^2 \\mathrm{Var}(X) = \\frac{1}{N_b^2} \\mathrm{Var}(X) $$\n\nNow, we substitute the expression we derived for $\\mathrm{Var}(X)$:\n$$ \\mathrm{Var}(p') = \\frac{1}{N_b^2} \\left[ N_b p(1-p) \\right] $$\n\nSimplifying this expression yields the final result for the variance of the post-bottleneck heteroplasmy:\n$$ \\mathrm{Var}(p') = \\frac{p(1-p)}{N_b} $$\n\nThis result quantifies the increase in variance of allele frequencies between lineages as a result of a population bottleneck of size $N_b$. It is a direct consequence of genetic drift.", "answer": "$$\n\\boxed{\\frac{p(1-p)}{N_b}}\n$$", "id": "2616678"}, {"introduction": "A major theme in organelle evolution is the massive transfer of genes from the endosymbiont to the host nucleus, leaving behind \"footprints\" known as NUMTs (Nuclear Mitochondrial DNA segments) and NUPTs (Nuclear Plastid DNA segments). This applied problem challenges you to formalize and implement a bioinformatic pipeline to detect these fossilized gene insertions in a nuclear genome and estimate their age [@problem_id:2616685]. You will combine statistical significance testing, models of sequence evolution, and the molecular clock hypothesis to build a tool that can uncover and date these pivotal events in the history of eukaryotic genomes.", "problem": "You are asked to formalize a computational pipeline for detecting and dating Nuclear Mitochondrial DNA (NUMT) segment insertions using organelle read alignments to a nuclear genome and molecular evolutionary rate models. The task must be expressed entirely in mathematical-statistical terms derived from foundational principles. The goal is to implement a program that, for a small set of test cases, decides whether a nuclear genomic window contains a NUMT (or a nuclear plastid DNA insertion) and, if so, estimates the time since insertion. The principles to use are: (i) the binomial model for assessing similarity significance under a random-matching null hypothesis, (ii) the Jukes–Cantor (JC) model for correcting multiple substitutions in the observed Hamming divergence between homologous DNA sequences, and (iii) the molecular clock interpretation that equates expected corrected substitutions to the product of substitution rate and time. All time must be expressed in million years (Myr).\n\nFundamental base and definitions to use:\n- Detection significance is assessed by testing whether the number of matches in an alignment of length $L$ is unusually large under a null model where each site matches with probability $q = 0.25$ (assuming independent sites and uniform base composition). The number of matches $X$ under the null follows a binomial distribution $X \\sim \\mathrm{Binomial}(L, q)$.\n- The one-sided tail probability $\\Pr[X \\ge k]$ for $k$ observed matches provides a $p$-value for enrichment of similarity beyond random expectation. If this $p$-value is below a prespecified significance threshold $\\alpha$, the similarity is significant.\n- The observed Hamming proportion of differences between a NUMT and its current organelle homolog is $p_{\\mathrm{obs}} = m / L$, where $m$ is the count of mismatches in an alignment of length $L$.\n- Under the Jukes–Cantor model, the corrected number of substitutions per site is \n$$\nK = -\\frac{3}{4}\\ln\\!\\left(1 - \\frac{4}{3}p_{\\mathrm{obs}}\\right),\n$$\napplicable only when $p_{\\mathrm{obs}} < 0.75$.\n- After insertion time $t$, the expected corrected distance between the NUMT (evolving in the nucleus) and the organelle lineage equals the sum of branch lengths since insertion: \n$$\nK \\approx \\left(r_{\\mathrm{nuc}} + r_{\\mathrm{org}}\\right)t,\n$$\nwhere $r_{\\mathrm{nuc}}$ is the nuclear substitution rate and $r_{\\mathrm{org}}$ is the organelle rate (mitochondrial or plastid), all in substitutions per site per million years. Thus, when applicable,\n$$\nt = \\frac{K}{r_{\\mathrm{nuc}} + r_{\\mathrm{org}}}.\n$$\n- Coverage of a nuclear window by organelle-derived reads is computed as $c = \\frac{R \\cdot \\ell}{L}$, where $R$ is the number of mapped reads, $\\ell$ is the read length, and $L$ is the window length. A minimal coverage threshold $c_{\\min}$ must be satisfied to call a NUMT.\n\nDecision rule to implement:\n- Given $(L, m, R, \\ell)$, compute $k = L - m$, $c = \\frac{R \\cdot \\ell}{L}$, and the one-sided binomial tail probability $p\\_{\\mathrm{val}} = \\Pr[X \\ge k]$ for $X \\sim \\mathrm{Binomial}(L, 0.25)$. Call a window a valid NUMT (or nuclear plastid insertion) if both $c \\ge c_{\\min}$ and $p\\_{\\mathrm{val}} < \\alpha$.\n- If a window is valid and $p_{\\mathrm{obs}} < 0.75$, compute $K$ via the Jukes–Cantor model and then compute $t = \\frac{K}{r_{\\mathrm{nuc}} + r_{\\mathrm{org}}}$. If $p_{\\mathrm{obs}} \\ge 0.75$, the date is undefined due to saturation; treat this as not dateable.\n- For non-NUMT windows or undateable cases, return a sentinel value.\n\nRequired program behavior:\n- Implement the above logic for the provided test suite. Use $\\alpha = 0.01$ and $c_{\\min} = 5$.\n- Each test case supplies whether the organelle is mitochondrial or plastid, the alignment length $L$ (in base pairs), the mismatch count $m$, the number of mapped reads $R$, the read length $\\ell$ (in base pairs), and the substitution rates $r_{\\mathrm{nuc}}$, $r_{\\mathrm{mt}}$, and $r_{\\mathrm{pt}}$ in substitutions per site per million years. Choose $r_{\\mathrm{org}} = r_{\\mathrm{mt}}$ if the organelle flag is mitochondrial and $r_{\\mathrm{org}} = r_{\\mathrm{pt}}$ if plastid.\n- For each test case, output a single floating-point number equal to the estimated insertion time $t$ in million years, rounded to exactly three decimal places, if the window is a valid and dateable NUMT (or nuclear plastid insertion). Otherwise, output the sentinel value $-1.000$.\n- The final program output must be a single line containing the results for all test cases as a comma-separated list enclosed in square brackets, with no spaces, for example $[$$3.142$$,$$-1.000$$,$$0.000$$]$.\n\nTest suite (each case is a tuple: $(\\text{organelle}, L, m, R, \\ell, r_{\\mathrm{nuc}}, r_{\\mathrm{mt}}, r_{\\mathrm{pt}})$):\n- Case 1: (\"mt\", 1000, 80, 600, 100, 0.002, 0.020, 0.003).\n- Case 2: (\"mt\", 150, 50, 3, 100, 0.002, 0.020, 0.003).\n- Case 3: (\"mt\", 800, 620, 300, 100, 0.002, 0.020, 0.003).\n- Case 4: (\"pt\", 1200, 60, 240, 100, 0.001, 0.020, 0.003).\n- Case 5: (\"mt\", 500, 0, 50, 100, 0.002, 0.015, 0.003).\n- Case 6: (\"mt\", 100, 70, 20, 100, 0.002, 0.020, 0.003).\n\nAngle units are not applicable. There are no physical units other than time, which must be reported in million years (Myr). Percentages should not be used; fractional values must be decimals or fractions.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[$$3.818$$,$$-1.000$$,$$12.938$$,$$\\dots$$]$).", "solution": "The problem presented is a valid and well-posed exercise in computational biology and molecular evolution. It requires the formalization and implementation of a pipeline for identifying and dating the insertion of organelle DNA into a nuclear genome, a phenomenon resulting in so-called NUMTs (Nuclear Mitochondrial DNA segments) or NUPTs (Nuclear Plastid DNA segments). The problem is scientifically grounded, using established principles such as the binomial model for statistical significance, the Jukes-Cantor model for evolutionary distance correction, and the molecular clock hypothesis for time estimation. All necessary parameters and data are provided, and the logic is specified without ambiguity. Therefore, a reasoned solution can be constructed.\n\nThe procedure is divided into two primary stages: detection and dating.\n\n**Detection of Putative Organelle DNA Insertions**\n\nTo claim that a nuclear genomic window contains DNA of organelle origin, we must first establish two facts: first, that there is sufficient physical evidence of organelle-like sequences at that locus, and second, that the similarity between the nuclear segment and its organelle homolog is statistically significant, i.e., not a product of random chance.\n\nThe first criterion is addressed through a coverage threshold. The coverage, $c$, is defined as the average number of sequencing reads that map to each position in the window of length $L$. Given $R$ reads of length $\\ell$, the total number of bases contributed by all reads is $R \\cdot \\ell$. Averaged over the window length $L$, the coverage is:\n$$\nc = \\frac{R \\cdot \\ell}{L}\n$$\nWe require this value to exceed a minimum threshold, $c \\ge c_{\\min}$, set here to $c_{\\min} = 5$. This ensures that the signal is not based on a small number of potentially spurious read mappings.\n\nThe second criterion assesses the significance of sequence similarity. An alignment between the nuclear window and its putative organelle source sequence has length $L$ and contains $m$ mismatches. The number of matches is therefore $k = L - m$. We test the null hypothesis ($H_0$) that the nuclear and organelle sequences are unrelated. Under $H_0$, with a simplified assumption of uniform and independent nucleotide composition (A, C, G, T), the probability of a match at any given site is $q = 0.25$. The total number of matches, $X$, in an alignment of length $L$ thus follows a binomial distribution:\n$$\nX \\sim \\mathrm{Binomial}(L, q)\n$$\nWe quantify the unlikeliness of observing $k$ or more matches under this null model by calculating a one-sided $p$-value:\n$$\np_{\\mathrm{val}} = \\Pr[X \\ge k] = \\sum_{i=k}^{L} \\binom{L}{i} q^i (1-q)^{L-i}\n$$\nIf this $p$-value is below a pre-determined significance level, $\\alpha$ (here, $\\alpha = 0.01$), we reject the null hypothesis and conclude that the similarity is statistically significant. A candidate window is declared a valid NUMT (or NUPT) only if both the coverage and significance criteria are met.\n\n**Dating of Validated Organelle DNA Insertions**\n\nOnce a window is validated, we proceed to estimate the time of its insertion into the nuclear genome. The observed proportion of differences, $p_{\\mathrm{obs}} = m/L$, is a direct but naive measure of the divergence between the nuclear copy and its contemporary organelle homolog. This measure systematically underestimates the true number of substitutions because multiple mutations may have occurred at the same site since the divergence event (i.e., the insertion).\n\nTo account for these unobserved substitutions, we employ the Jukes-Cantor (JC) model. It provides a corrected measure of evolutionary distance, $K$, representing the estimated number of substitutions per site. The relationship is given by:\n$$\nK = -\\frac{3}{4}\\ln\\!\\left(1 - \\frac{4}{3}p_{\\mathrm{obs}}\\right)\n$$\nThis correction is mathematically valid only when the argument of the logarithm is positive, which requires $1 - \\frac{4}{3}p_{\\mathrm{obs}} > 0$, or $p_{\\mathrm{obs}} < 0.75$. If the observed divergence is at or above this saturation point, the evolutionary distance cannot be reliably estimated, and the insertion is considered \"undateable.\"\n\nFinally, we apply the molecular clock hypothesis to convert the corrected distance $K$ into an estimate of time, $t$. After the insertion event at time $t$ in the past (measured in Million years, Myr), the inserted sequence evolved in the nucleus at a rate $r_{\\mathrm{nuc}}$, while its counterpart in the organelle lineage continued evolving at the organelle-specific rate $r_{\\mathrm{org}}$. The total amount of divergence accumulated between them is a function of the combined rates over time. The expected distance $K$ is thus:\n$$\n\\mathbb{E}[K] \\approx (r_{\\mathrm{nuc}} + r_{\\mathrm{org}})t\n$$\nBy rearranging this equation, we can estimate the time since insertion:\n$$\nt = \\frac{K}{r_{\\mathrm{nuc}} + r_{\\mathrm{org}}}\n$$\nThe organelle rate $r_{\\mathrm{org}}$ is selected based on the origin of the insertion: $r_{\\mathrm{mt}}$ for mitochondrial or $r_{\\mathrm{pt}}$ for plastid.\n\nIf a window fails either of the detection criteria, or if it is validated but undateable ($p_{\\mathrm{obs}} \\ge 0.75$), a sentinel value of $-1.000$ is returned. Otherwise, the calculated time $t$ is returned, rounded to three decimal places. The following program implements this complete logic for the supplied test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import binom\n\ndef solve():\n    \"\"\"\n    Solves the NUMT detection and dating problem for a series of test cases.\n\n    The pipeline follows these steps for each case:\n    1.  Detection:\n        a. Calculate read coverage. Must be >= 5.\n        b. Calculate the p-value for the number of matches under a binomial\n           null model (p=0.25). Must be < 0.01.\n        c. If either check fails, the window is not a valid NUMT.\n\n    2.  Dating:\n        a. If the window is a valid NUMT, calculate the observed divergence p_obs.\n        b. If p_obs >= 0.75, the sequence is saturated and undateable.\n        c. Otherwise, calculate the corrected distance K using the Jukes-Cantor model.\n        d. Calculate the insertion time t using the molecular clock equation with\n           the appropriate nuclear and organelle substitution rates.\n\n    3.  Output:\n        a. For valid and dateable NUMTs, return the time t rounded to 3 decimal places.\n        b. Otherwise, return the sentinel value -1.000.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case: (organelle, L, m, R, l, r_nuc, r_mt, r_pt)\n    test_cases = [\n        (\"mt\", 1000, 80, 600, 100, 0.002, 0.020, 0.003),   # Case 1\n        (\"mt\", 150, 50, 3, 100, 0.002, 0.020, 0.003),      # Case 2\n        (\"mt\", 800, 620, 300, 100, 0.002, 0.020, 0.003),   # Case 3\n        (\"pt\", 1200, 60, 240, 100, 0.001, 0.020, 0.003),   # Case 4\n        (\"mt\", 500, 0, 50, 100, 0.002, 0.015, 0.003),      # Case 5\n        (\"mt\", 100, 70, 20, 100, 0.002, 0.020, 0.003),      # Case 6\n    ]\n\n    # Constants and thresholds\n    alpha = 0.01\n    c_min = 5.0\n    q_null = 0.25\n    sentinel_value = -1.0\n\n    results = []\n\n    for case in test_cases:\n        organelle, L, m, R, l, r_nuc, r_mt, r_pt = case\n        \n        # --- DETECTION STAGE ---\n\n        # 1. Coverage criterion\n        coverage = (R * l) / L\n        is_coverage_sufficient = coverage >= c_min\n        \n        # 2. Significance criterion\n        num_matches = L - m\n        # Calculate one-sided p-value: Pr[X >= k] where X ~ Binomial(L, q)\n        # scipy.stats.binom.sf(k-1, n, p) calculates Pr[X >= k]\n        p_value = binom.sf(num_matches - 1, L, q_null)\n        is_significant = p_value < alpha\n        \n        is_valid_numt = is_coverage_sufficient and is_significant\n        \n        # --- DATING STAGE ---\n        \n        if is_valid_numt:\n            p_obs = m / L\n            \n            # Check if divergence is within the range of the Jukes-Cantor model\n            if p_obs < 0.75:\n                # Calculate corrected distance K\n                if p_obs == 0:\n                    K = 0.0\n                else:\n                    K = -0.75 * np.log(1.0 - (4.0 / 3.0) * p_obs)\n                \n                # Select appropriate organelle rate\n                r_org = r_mt if organelle == \"mt\" else r_pt\n                \n                # Calculate total rate and time\n                r_total = r_nuc + r_org\n                \n                # Check for division by zero, though rates are positive\n                if r_total > 0:\n                    t = K / r_total\n                    results.append(t)\n                else: # Should not happen with given data\n                    results.append(sentinel_value)\n\n            else: # Undateable due to saturation\n                results.append(sentinel_value)\n        else: # Not a valid NUMT\n            results.append(sentinel_value)\n\n    # Format results to exactly three decimal places and create the final output string\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2616685"}]}