{"hands_on_practices": [{"introduction": "The power of modern spatial transcriptomics methods lies in their ability to simultaneously profile gene expression at thousands or even millions of distinct locations. This massive parallelism is enabled by a vast library of unique DNA barcodes that tag each spatial location. This foundational exercise guides you through the critical design process of such a library, applying principles of combinatorics and probability to determine the minimum barcode length $L$ required to ensure that each spatial spot receives a unique identifier with a very high probability [@problem_id:2673506].", "problem": "In a spatial transcriptomics assay, beads are randomly deposited across a tissue section to capture messenger ribonucleic acid (mRNA) molecules in situ. Each bead carries a deoxyribonucleic acid (DNA) spatial barcode of length $L$ nucleotides drawn from the four-nucleotide alphabet, so the total number of possible barcodes is $4^L$. Suppose $n = 10^6$ beads are independently and uniformly assigned barcodes from the $4^L$ possibilities. A collision occurs if two or more beads share the same barcode, which would confound the mapping of spatial positions to gene expression.\n\nUsing only first principles of combinatorics and probability for independent uniform sampling (e.g., counting arguments, Boole’s inequality for unions), determine the smallest integer $L$ such that the probability of at least one collision among the $n$ beads is strictly less than $\\varepsilon = 10^{-6}$. Provide the minimum integer $L$ that meets this requirement. No rounding is needed beyond determining this smallest integer.", "solution": "The problem requires the determination of the smallest integer barcode length, denoted by $L$, for a spatial transcriptomics assay. The condition is that the probability of at least one collision among $n$ beads must be strictly less than a specified threshold $\\varepsilon$.\n\nWe begin by formalizing the parameters provided in the problem statement.\nThe number of beads is $n = 10^6$.\nThe barcode is constructed from an alphabet of $4$ nucleotides.\nThe total number of possible unique barcodes of length $L$ is $N = 4^L$.\nThe probability of at least one collision, which we denote as $P_c$, must satisfy the inequality $P_c < \\varepsilon$, where $\\varepsilon = 10^{-6}$.\nThe assignment of barcodes to beads is an independent and uniform random process. This scenario is a classic combinatorial problem often referred to as the \"birthday problem\".\n\nDirectly calculating $P_c$ is difficult. It is more tractable to first calculate the probability of the complementary event, $P_{nc}$, which is the probability of having no collisions. A collision-free outcome means that every one of the $n$ beads receives a unique barcode.\n\nThe total number of possible ways to assign barcodes to $n$ beads, with replacement, is $N^n$, since each of the $n$ beads can be assigned any of the $N$ possible barcodes.\nThe number of ways to assign a unique barcode to each of the $n$ beads is the number of $n$-permutations of $N$ items, given by $P(N, n) = \\frac{N!}{(N-n)!}$.\n\nThe exact probability of no collisions is the ratio of these two quantities:\n$$ P_{nc} = \\frac{P(N, n)}{N^n} = \\frac{N(N-1)\\cdots(N-n+1)}{N^n} = \\prod_{k=0}^{n-1} \\left(1 - \\frac{k}{N}\\right) $$\nThe probability of at least one collision is $P_c = 1 - P_{nc}$. The problem's requirement is $1 - P_{nc} < \\varepsilon$.\n\nAs the problem suggests, we can use first principles, like Boole's inequality (also known as the union bound), to establish a simpler, sufficient condition. Let $E_{ij}$ be the event that bead $i$ and bead $j$ are assigned the same barcode, for any pair $i < j$. Due to the uniform and independent assignment, the probability of this event is $P(E_{ij}) = \\frac{1}{N}$.\n\nThe event of at least one collision, $C$, is the union of all such pairwise collision events: $C = \\bigcup_{1 \\le i < j \\le n} E_{ij}$. The number of distinct pairs of beads is $\\binom{n}{2} = \\frac{n(n-1)}{2}$.\n\nApplying Boole's inequality:\n$$ P_c = P(C) \\le \\sum_{1 \\le i < j \\le n} P(E_{ij}) = \\binom{n}{2} \\cdot \\frac{1}{N} = \\frac{n(n-1)}{2N} $$\nThis inequality provides an upper bound on the collision probability. To ensure that $P_c < \\varepsilon$, it is sufficient to require this upper bound to be less than $\\varepsilon$:\n$$ \\frac{n(n-1)}{2N} < \\varepsilon $$\nThis approximation is highly accurate when $N$ is significantly larger than $n$, a condition which must hold to keep the collision probability low.\n\nWe now solve this inequality for $L$. We substitute $N = 4^L$:\n$$ \\frac{n(n-1)}{2 \\cdot 4^L} < \\varepsilon $$\nRearranging the inequality to solve for $4^L$:\n$$ 4^L > \\frac{n(n-1)}{2\\varepsilon} $$\nWe substitute the given numerical values, $n = 10^6$ and $\\varepsilon = 10^{-6}$:\n$$ 4^L > \\frac{10^6(10^6 - 1)}{2 \\times 10^{-6}} $$\nGiven that $n = 10^6$ is large, the term $n-1$ is approximately equal to $n$. Using this approximation simplifies the arithmetic without affecting the final integer result:\n$$ 4^L > \\frac{(10^6)^2}{2 \\times 10^{-6}} = \\frac{10^{12}}{2 \\times 10^{-6}} = 0.5 \\times 10^{18} = 5 \\times 10^{17} $$\nTo find the integer $L$, we take the base-$10$ logarithm of both sides of the inequality:\n$$ \\log_{10}(4^L) > \\log_{10}(5 \\times 10^{17}) $$\n$$ L \\log_{10}(4) > \\log_{10}(5) + \\log_{10}(10^{17}) $$\nUsing the logarithm properties $\\log_{10}(4) = 2 \\log_{10}(2)$ and $\\log_{10}(5) = \\log_{10}(10/2) = 1 - \\log_{10}(2)$:\n$$ L \\cdot (2 \\log_{10}(2)) > (1 - \\log_{10}(2)) + 17 $$\n$$ L \\cdot (2 \\log_{10}(2)) > 18 - \\log_{10}(2) $$\nSolving for $L$:\n$$ L > \\frac{18 - \\log_{10}(2)}{2 \\log_{10}(2)} = \\frac{18}{2 \\log_{10}(2)} - \\frac{\\log_{10}(2)}{2 \\log_{10}(2)} = \\frac{9}{\\log_{10}(2)} - \\frac{1}{2} $$\nUsing the value $\\log_{10}(2) \\approx 0.30103$:\n$$ L > \\frac{9}{0.30103} - 0.5 $$\n$$ L > 29.89735 - 0.5 = 29.39735 $$\nSince $L$ must be an integer, the smallest integer value for $L$ that strictly satisfies this inequality is $30$. Thus, a barcode length of at least $30$ nucleotides is required to meet the specified low probability of collision.", "answer": "$$\\boxed{30}$$", "id": "2673506"}, {"introduction": "Once a spatial transcriptomics experiment is sequenced, the raw output consists of millions of paired-end reads containing a mixture of spatial barcodes, unique molecular identifiers (UMIs), and gene sequences. This hands-on programming challenge puts you in the role of a bioinformatician tasked with building a pipeline to make sense of this data. You will implement the complete workflow—from parsing reads and correcting barcode errors to assigning reads to genes and collapsing PCR duplicates—to construct the fundamental data object of spatial analysis: the spot-by-gene count matrix [@problem_id:2673484].", "problem": "You are tasked with implementing a complete, logically consistent demultiplexing and counting pipeline for paired-end spatial transcriptomics reads modeled after the 10x Genomics Visium library structure. The goal is to recover a spot-by-gene unique molecular identifier count matrix by parsing read structure, correcting spatial barcodes to a whitelist under a Hamming distance threshold, assigning reads to genes via a gene-tag dictionary, and collapsing polymerase chain reaction duplicates using unique molecular identifier adjacency within a specified edit distance.\n\nFundamental base:\n- Central Dogma of Molecular Biology: Deoxyribonucleic Acid transcribes to ribonucleic acid which is sequenced; molecular counts are inferred by deduplicating reads using unique molecular identifiers to approximate original molecules.\n- Barcoding and demultiplexing: A spatial barcode identifies the capture location (spot), and a unique molecular identifier distinguishes original molecules from amplification duplicates.\n- Hamming distance: For strings of equal length, the Hamming distance counts positional mismatches and is an appropriate error model for single-nucleotide substitution errors in sequencing.\n\nDefinitions and required behavior:\n- Let $L_b$ denote the spatial barcode length and $L_u$ denote the unique molecular identifier length contained in Read $1$, and let $L_g$ denote the gene tag length contained at the start of Read $2$.\n- Read $1$ structure: the first $L_b$ nucleotides are the spatial barcode $s$, followed immediately by the next $L_u$ nucleotides constituting the unique molecular identifier $u$. The remainder of Read $1$ is an anchor (e.g., poly-deoxythymidine) and is ignored for this problem.\n- Read $2$ structure: the first $L_g$ nucleotides are a gene-identifying tag $g$ (a short sequence that uniquely identifies a gene in the given dictionary), followed by the complementary deoxyribonucleic acid insert which is ignored for this problem.\n- Hamming distance between strings $x$ and $y$ of equal length is $$d_H(x,y) = \\sum_{i=1}^{|x|} \\mathbf{1}[x_i \\ne y_i],$$ where $\\mathbf{1}[\\cdot]$ is the indicator function and $|x|$ is the string length.\n- Spatial barcode correction: Given a whitelist set $W$ of spatial barcodes, a raw barcode $s$ is corrected to the unique element $w^\\star \\in W$ with minimum Hamming distance to $s$ if and only if $\\min_{w \\in W} d_H(s,w) \\le t_b$ and there is a unique minimizer; otherwise the read is discarded. Here $t_b$ is a nonnegative integer threshold.\n- Gene assignment: Given a gene tag dictionary $T: \\text{gene} \\mapsto \\text{tag}$ with tags of equal length $L_g$, a read with tag $g$ is assigned to the unique gene $k^\\star$ whose tag has minimum Hamming distance to $g$ if and only if $\\min_{k \\in \\text{genes}} d_H(g,T(k)) \\le t_g$ and there is a unique minimizer; otherwise the read is discarded. Here $t_g$ is a nonnegative integer threshold.\n- Grouping: After correction and assignment, reads are grouped by $(\\text{spot}, \\text{gene})$ pairs. Within each group, unique molecular identifier collapsing is performed via a greedy adjacency rule parameterized by $d_u$:\n  - Let $C(v)$ denote the observed count of unique molecular identifier sequence $v$ in the group. Initialize the set of unassigned unique molecular identifiers $U$ to all distinct unique molecular identifier sequences in the group. Initialize the cluster count to $0$.\n  - While $U$ is nonempty, select a leader $\\ell \\in U$ with maximal $C(\\ell)$ (break ties by lexicographically smallest $\\ell$). Form a cluster consisting of $\\ell$ and every $w \\in U$ such that $d_H(\\ell,w) \\le d_u$ and $C(w) \\le C(\\ell)$. Remove clustered elements from $U$ and increment the cluster count by $1$.\n  - The cluster count is the deduplicated molecule count for that $(\\text{spot}, \\text{gene})$ pair. Note that when $d_u = 0$, only identical unique molecular identifier sequences merge; when $d_u \\ge 1$, sequencing-error neighbors can merge into a more abundant leader.\n- Count matrix specification: Let $S$ be the whitelist of spatial barcodes and $G$ the set of gene identifiers (keys of $T$). The output count matrix has dimensions $|S| \\times |G|$ and is filled for all spots in $S$ (even if no reads map) and for all genes in $G$. Rows are ordered by the lexicographic sort of $S$, and columns are ordered by the lexicographic sort of $G$. The matrix entry at row $i$ and column $j$ is the deduplicated unique molecular identifier count for the corresponding $(\\text{spot}_i, \\text{gene}_j)$.\n\nImplementation requirements:\n- Implement the above demultiplexing and counting pipeline exactly as specified, using the Hamming distance, nearest-neighbor correction and assignment with uniqueness and thresholds $t_b$ and $t_g$, and the greedy unique molecular identifier adjacency collapsing with parameter $d_u$ and the specified leader and tie-breaking rule.\n- Any read with Read $1$ shorter than $L_b + L_u$ or Read $2$ shorter than $L_g$ must be discarded.\n- All thresholds $t_b$, $t_g$, and $d_u$ are nonnegative integers.\n\nTest suite:\nImplement your program to run the following three test cases, each defined by $(L_b, L_u, L_g, t_b, t_g, d_u)$, a whitelist $W$, a gene-tag dictionary $T$, and a list of paired-end reads, where each read is a tuple of strings $(\\text{R1}, \\text{R2})$.\n\n- Test case $1$ (general case with correction, gene assignment allowing mismatches, and unique molecular identifier adjacency):\n  - Parameters: $L_b = 4$, $L_u = 3$, $L_g = 4$, $t_b = 1$, $t_g = 1$, $d_u = 1$.\n  - Whitelist $W$: [\"ACGT\", \"TGCA\", \"GGGG\"].\n  - Gene tags $T$: {\"G1\": \"AAAA\", \"G2\": \"CCCC\", \"G3\": \"TTTT\"}.\n  - Paired-end reads:\n    - (\"ACGTAAATT\", \"AAAAAA\")\n    - (\"ACGTAAATT\", \"AAAACC\")\n    - (\"ACGTAATTT\", \"AAAAAA\")\n    - (\"ACGTAACTT\", \"AAAAAA\")\n    - (\"TGTAGGGTT\", \"CCCCGG\")\n    - (\"TGTAGGATT\", \"CCCCAA\")\n    - (\"GGGGTTTTT\", \"TTTTCC\")\n    - (\"GGGGTTACT\", \"TTTCAA\")\n- Test case $2$ (barcode tie ambiguity, strict gene assignment, and unique molecular identifier collapsing with distance):\n  - Parameters: $L_b = 4$, $L_u = 2$, $L_g = 3$, $t_b = 1$, $t_g = 0$, $d_u = 1$.\n  - Whitelist $W$: [\"AAAA\", \"AAAT\", \"TTTT\"].\n  - Gene tags $T$: {\"X\": \"ATG\", \"Y\": \"CAT\"}.\n  - Paired-end reads:\n    - (\"AAAGCCTT\", \"ATGAAA\")    [ambiguous barcode: discard]\n    - (\"AAAACCTT\", \"ATGCCC\")\n    - (\"AAAACGTT\", \"ATGCCC\")\n    - (\"AAATTTTT\", \"CATGGG\")\n    - (\"AAATTTAA\", \"CATCCC\")\n    - (\"TTTTGGTT\", \"CAGAAA\")    [unrecognized gene tag: discard]\n- Test case $3$ (no correction, exact gene matching, and exact unique molecular identifier deduplication only):\n  - Parameters: $L_b = 2$, $L_u = 1$, $L_g = 2$, $t_b = 0$, $t_g = 0$, $d_u = 0$.\n  - Whitelist $W$: [\"AC\", \"GT\"].\n  - Gene tags $T$: {\"A\": \"AA\", \"C\": \"CC\"}.\n  - Paired-end reads:\n    - (\"ACATT\", \"AAGG\")\n    - (\"ACATT\", \"AATC\")\n    - (\"ACTTT\", \"AAGG\")\n    - (\"GTGTT\", \"CCGG\")\n    - (\"GAGTT\", \"AAGG\")         [barcode not in whitelist and no correction: discard]\n\nFinal output specification:\n- For each test case, compute the spot-by-gene count matrix with rows ordered by the lexicographic order of the whitelist $W$ and columns ordered by the lexicographic order of the gene identifiers in $T$.\n- Flatten each matrix in row-major order (iterate spots in order, and within each spot iterate genes in order) to a list of integers.\n- Your program should produce a single line of output containing the concatenation of these flattened lists for the three test cases as a single comma-separated list enclosed in square brackets, for example, \"[a,b,c,...]\".", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the principles of molecular biology and bioinformatics, specifically relating to spatial transcriptomics data analysis. The problem is well-posed, with all parameters, algorithms, and boundary conditions defined unambiguously, including explicit rules for error correction, tie-breaking, and data structures. The language is objective and formal. Therefore, a solution will be provided.\n\nThe required task is to construct a computational pipeline that processes paired-end sequencing reads from a spatial transcriptomics experiment, modeled on the 10x Genomics Visium platform, to produce a spatially resolved gene expression count matrix. The process involves several discrete, sequential steps: read parsing, spatial barcode error correction, gene assignment, and Unique Molecular Identifier (UMI) deduplication.\n\nFirst, a function to compute the Hamming distance, $d_H(x,y)$, between two strings $x$ and $y$ of equal length must be implemented. This is defined as the number of positions at which the corresponding characters are different:\n$$d_H(x,y) = \\sum_{i=1}^{|x|} \\mathbf{1}[x_i \\ne y_i]$$\nwhere $\\mathbf{1}[\\cdot]$ is the indicator function. This metric is fundamental to the subsequent error correction steps.\n\nThe main pipeline proceeds as follows for each paired-end read $(\\text{R1}, \\text{R2})$:\n\n1.  **Parsing and Initial Filtering**: Each read pair is first inspected for sufficient length. A read is discarded if the length of R$1$ is less than $L_b + L_u$ or the length of R$2$ is less than $L_g$, where $L_b$ is the spatial barcode length, $L_u$ is the UMI length, and $L_g$ is the gene tag length. If the lengths are adequate, the raw spatial barcode $s$ is extracted from the first $L_b$ bases of R$1$, the UMI $u$ from the subsequent $L_u$ bases of R$1$, and the gene tag $g$ from the first $L_g$ bases of R$2$.\n\n2.  **Spatial Barcode Correction**: The raw barcode $s$ is compared against a given whitelist $W$ of valid spatial barcodes. A corrected barcode $w^\\star \\in W$ is identified if and only if it is the unique barcode in the whitelist that minimizes the Hamming distance to $s$, and this minimum distance does not exceed a given threshold $t_b$. Formally, $w^\\star$ is accepted if $\\min_{w \\in W} d_H(s,w) = d_H(s, w^\\star) \\le t_b$ and for all $w' \\in W$ with $w' \\ne w^\\star$, $d_H(s, w') > d_H(s, w^\\star)$. If no such unique $w^\\star$ exists, the read is discarded.\n\n3.  **Gene Assignment**: A similar nearest-neighbor search is performed for the raw gene tag $g$. It is compared against all tags in the provided gene-tag dictionary $T$. A gene $k^\\star$ is assigned to the read if its corresponding tag $T(k^\\star)$ is the unique tag that minimizes the Hamming distance to $g$, and this distance is no greater than the threshold $t_g$. Formally, an assignment is made if $\\min_{k \\in \\text{genes}} d_H(g, T(k)) = d_H(g, T(k^\\star)) \\le t_g$ and for all other genes $k' \\ne k^\\star$, $d_H(g, T(k')) > d_H(g, T(k^\\star))$. If these conditions are not met, the read is discarded.\n\n4.  **Grouping**: Reads that successfully pass the barcode correction and gene assignment steps are grouped by the tuple of their corrected spatial barcode (spot) and assigned gene, i.e., $(w^\\star, k^\\star)$. All UMIs associated with each group are collected for the final deduplication step.\n\n5.  **UMI Deduplication**: Within each $(w^\\star, k^\\star)$ group, we must collapse UMIs that likely originated from the same initial molecule but acquired errors during Polymerase Chain Reaction (PCR) amplification or sequencing. This is performed using a greedy adjacency algorithm parameterized by an edit distance threshold $d_u$.\n    - First, for the given group, the counts $C(v)$ for each distinct UMI sequence $v$ are tabulated.\n    - The set of unique UMIs, $U$, is initialized.\n    - The algorithm iteratively builds clusters. In each iteration, a \"leader\" UMI, $\\ell$, is selected from the set of remaining unassigned UMIs $U$. The leader is chosen as the UMI with the highest count $C(\\ell)$. Any ties are broken by selecting the lexicographically smallest UMI string.\n    - A cluster is formed around $\\ell$, containing $\\ell$ itself and all other UMIs $w \\in U$ that satisfy two conditions: their Hamming distance to the leader is within the threshold, $d_H(\\ell, w) \\le d_u$, and their count is less than or equal to the leader's count, $C(w) \\le C(\\ell)$.\n    - All UMIs in the newly formed cluster are removed from $U$.\n    - This process repeats until $U$ is empty. The total number of clusters formed is the final, deduplicated molecular count for the $(w^\\star, k^\\star)$ pair. If $d_u = 0$, this procedure simplifies to counting the number of unique UMI sequences.\n\n6.  **Count Matrix Assembly**: Finally, a count matrix of size $|S| \\times |G|$ is constructed, where $S$ is the set of all whitelisted spatial barcodes and $G$ is the set of all gene identifiers from the dictionary $T$. The rows correspond to the spatial barcodes in lexicographical order, and the columns correspond to the gene identifiers in lexicographical order. Each entry $(i, j)$ in the matrix is populated with the deduplicated UMI count for the corresponding $(\\text{spot}_i, \\text{gene}_j)$ pair. If a pair has no associated reads, its count is $0$. The resulting matrix is then flattened into a one-dimensional list in row-major order for the final output. This procedure is applied to all test cases, and the final flattened lists are concatenated.", "answer": "```python\nimport numpy as np\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Main function to run the spatial transcriptomics pipeline on all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"params\": (4, 3, 4, 1, 1, 1),\n            \"whitelist\": [\"ACGT\", \"TGCA\", \"GGGG\"],\n            \"gene_tags\": {\"G1\": \"AAAA\", \"G2\": \"CCCC\", \"G3\": \"TTTT\"},\n            \"reads\": [\n                (\"ACGTAAATT\", \"AAAAAA\"), (\"ACGTAAATT\", \"AAAACC\"), (\"ACGTAATTT\", \"AAAAAA\"),\n                (\"ACGTAACTT\", \"AAAAAA\"), (\"TGTAGGGTT\", \"CCCCGG\"), (\"TGTAGGATT\", \"CCCCAA\"),\n                (\"GGGGTTTTT\", \"TTTTCC\"), (\"GGGGTTACT\", \"TTTCAA\"),\n            ]\n        },\n        {\n            \"params\": (4, 2, 3, 1, 0, 1),\n            \"whitelist\": [\"AAAA\", \"AAAT\", \"TTTT\"],\n            \"gene_tags\": {\"X\": \"ATG\", \"Y\": \"CAT\"},\n            \"reads\": [\n                (\"AAAGCCTT\", \"ATGAAA\"), (\"AAAACCTT\", \"ATGCCC\"), (\"AAAACGTT\", \"ATGCCC\"),\n                (\"AAATTTTT\", \"CATGGG\"), (\"AAATTTAA\", \"CATCCC\"), (\"TTTTGGTT\", \"CAGAAA\"),\n            ]\n        },\n        {\n            \"params\": (2, 1, 2, 0, 0, 0),\n            \"whitelist\": [\"AC\", \"GT\"],\n            \"gene_tags\": {\"A\": \"AA\", \"C\": \"CC\"},\n            \"reads\": [\n                (\"ACATT\", \"AAGG\"), (\"ACATT\", \"AATC\"), (\"ACTTT\", \"AAGG\"),\n                (\"GTGTT\", \"CCGG\"), (\"GAGTT\", \"AAGG\"),\n            ]\n        }\n    ]\n\n    final_results = []\n    for case in test_cases:\n        result_matrix = process_reads(\n            case[\"params\"], case[\"whitelist\"], case[\"gene_tags\"], case[\"reads\"]\n        )\n        final_results.extend(result_matrix.flatten())\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\ndef hamming_distance(s1, s2):\n    \"\"\"Calculates the Hamming distance between two strings of equal length.\"\"\"\n    if len(s1) != len(s2):\n        raise ValueError(\"Strings must be of equal length.\")\n    return sum(c1 != c2 for c1, c2 in zip(s1, s2))\n\ndef find_best_match(raw_seq, valid_seqs, threshold):\n    \"\"\"Finds the unique best match for a sequence from a list within a threshold.\"\"\"\n    min_dist = float('inf')\n    best_matches = []\n\n    for valid_seq in valid_seqs:\n        dist = hamming_distance(raw_seq, valid_seq)\n        if dist < min_dist:\n            min_dist = dist\n            best_matches = [valid_seq]\n        elif dist == min_dist:\n            best_matches.append(valid_seq)\n\n    if min_dist <= threshold and len(best_matches) == 1:\n        return best_matches[0]\n    return None\n    \ndef process_reads(params, whitelist, gene_tags, reads):\n    \"\"\"\n    Processes a single test case of spatial transcriptomics reads.\n    \n    Args:\n        params (tuple): (L_b, L_u, L_g, t_b, t_g, d_u)\n        whitelist (list): A list of valid spatial barcode sequences.\n        gene_tags (dict): A dictionary mapping gene names to tag sequences.\n        reads (list of tuples): A list of (R1, R2) read pairs.\n\n    Returns:\n        numpy.ndarray: The final spot-by-gene count matrix.\n    \"\"\"\n    L_b, L_u, L_g, t_b, t_g, d_u = params\n    \n    # Invert gene_tags for efficient lookup\n    tag_to_gene = {v: k for k, v in gene_tags.items()}\n\n    # Group valid reads by (spot, gene)\n    grouped_umis = {}\n\n    for r1, r2 in reads:\n        # 1. Parsing and Initial Filtering\n        if len(r1) < L_b + L_u or len(r2) < L_g:\n            continue\n        \n        raw_barcode = r1[:L_b]\n        umi = r1[L_b : L_b + L_u]\n        raw_gene_tag = r2[:L_g]\n\n        # 2. Spatial Barcode Correction\n        corrected_barcode = find_best_match(raw_barcode, whitelist, t_b)\n        if corrected_barcode is None:\n            continue\n        \n        # 3. Gene Assignment\n        matched_tag = find_best_match(raw_gene_tag, list(tag_to_gene.keys()), t_g)\n        if matched_tag is None:\n            continue\n        assigned_gene = tag_to_gene[matched_tag]\n        \n        # 4. Grouping\n        key = (corrected_barcode, assigned_gene)\n        if key not in grouped_umis:\n            grouped_umis[key] = []\n        grouped_umis[key].append(umi)\n\n    # Prepare for matrix construction\n    sorted_spots = sorted(whitelist)\n    sorted_genes = sorted(gene_tags.keys())\n    spot_to_idx = {spot: i for i, spot in enumerate(sorted_spots)}\n    gene_to_idx = {gene: i for i, gene in enumerate(sorted_genes)}\n    \n    count_matrix = np.zeros((len(sorted_spots), len(sorted_genes)), dtype=int)\n\n    # 5. UMI Deduplication\n    for (spot, gene), umis in grouped_umis.items():\n        umi_counts = Counter(umis)\n        unassigned_umis = set(umi_counts.keys())\n        cluster_count = 0\n\n        while unassigned_umis:\n            # Select leader: max count, then lexicographically smallest\n            leader = sorted(\n                unassigned_umis,\n                key=lambda u: (-umi_counts[u], u)\n            )[0]\n            \n            cluster = {leader}\n            \n            # Form cluster\n            for other_umi in list(unassigned_umis):\n                if other_umi == leader:\n                    continue\n                if (hamming_distance(leader, other_umi) <= d_u and\n                        umi_counts[other_umi] <= umi_counts[leader]):\n                    cluster.add(other_umi)\n            \n            unassigned_umis -= cluster\n            cluster_count += 1\n        \n        # 6. Count Matrix Assembly\n        row_idx = spot_to_idx[spot]\n        col_idx = gene_to_idx[gene]\n        count_matrix[row_idx, col_idx] = cluster_count\n        \n    return count_matrix\n\nsolve()\n```", "id": "2673484"}, {"introduction": "The raw count matrix generated from sequencing is not a pristine reflection of an organism's biology; it is often contaminated by \"ambient\" transcripts from dissociated or lysed cells that are captured alongside genuine cellular content. This advanced exercise introduces a principled statistical approach to model and correct for this common artifact. You will derive and implement the Expectation-Maximization (EM) algorithm to deconvolve the observed expression in each spot as a mixture of its true profile and a global ambient profile, thereby estimating the contamination fraction $w$ and enabling a more accurate interpretation of the underlying biology [@problem_id:2673461].", "problem": "You are tasked with formulating and implementing a principled estimation procedure for ambient ribonucleic acid (RNA) contamination in spatial transcriptomics, framed as a convex mixture between a spot-specific expression profile and a global ambient profile. The core scientific foundation should start from the Central Dogma of molecular biology (deoxyribonucleic acid $\\rightarrow$ ribonucleic acid $\\rightarrow$ protein), where measured messenger RNA approximates gene expression, and the empirical fact that Unique Molecular Identifier (UMI) counts in droplet- or bead-based assays are well-approximated by a sampling model in which individual molecules are independently captured and counted. The in situ nature arises from spatially resolved capture spots, each with its own biological profile and some degree of contamination by ambient transcripts.\n\nMathematical model:\n- Let there be $G$ genes indexed by $g \\in \\{1,\\dots,G\\}$ and a single spatial spot indexed by $s$. For this spot, denote by $y_{g}$ the observed UMI counts for gene $g$, and $m = \\sum_{g=1}^{G} y_{g}$ the total UMI count in the spot.\n- Let $t_{g}$ be the spot’s true cellular expression profile over genes, with $\\sum_{g=1}^{G} t_{g} = 1$ and $t_{g} \\ge 0$.\n- Let $a_{g}$ be the global ambient expression profile over genes, with $\\sum_{g=1}^{G} a_{g} = 1$ and $a_{g} \\ge 0$.\n- Let $w \\in [0,1]$ be the unknown ambient mixture weight for the spot, representing the fraction of molecules arising from ambient RNA.\n- The observation model assumes independent molecule capture and a well-mixed pool per spot. Under these assumptions, the observed UMI count vector is modeled by a Multinomial distribution with $m$ trials and categorical probabilities $p_{g} = (1-w) t_{g} + w a_{g}$ for $g \\in \\{1,\\dots,G\\}$.\n\nYour tasks:\n1. From these foundations, derive an Expectation-Maximization (EM) algorithm to estimate the ambient mixture weight $w$ for a single spot given the observed counts $y_{g}$, the ambient profile $a_{g}$, and a specified spot-specific profile $t_{g}$. You must not assume access to any pre-derived formulae for the update steps; derive them starting from the complete-data likelihood under a latent-variable formulation in which each molecule is assigned to either the ambient or the spot-specific source. Use a uniform Beta prior $\\mathrm{Beta}(\\alpha,\\beta)$ on $w$ with $\\alpha = 1$ and $\\beta = 1$ (i.e., no regularization beyond the likelihood), and initialize the EM at $w^{(0)} = 0.5$. Your algorithm must iterate until the absolute change in $w$ is less than $\\varepsilon = 10^{-12}$ or until a maximum of $10{,}000$ iterations is reached.\n2. Implement your EM estimator in a program that processes a fixed test suite of spots. Each test case supplies $G$, a fixed ambient profile $a_{g}$, a spot-specific profile $t_{g}$, and an observed count vector $y_{g}$. Your program must output, for each test case, the estimated ambient mixture weight $\\widehat{w}$ as a floating-point number.\n\nTest suite:\n- Use $G = 5$ genes. Use the same ambient profile for all cases:\n  - $a = [0.05, 0.10, 0.20, 0.25, 0.40]$.\n- Case $1$ (typical mixture):\n  - $t = [0.30, 0.25, 0.20, 0.15, 0.10]$,\n  - $m = 1000$,\n  - observed counts $y = [250, 220, 200, 170, 160]$.\n- Case $2$ (no ambient contamination):\n  - $t = [0.10, 0.10, 0.20, 0.25, 0.35]$,\n  - $m = 800$,\n  - observed counts $y = [80, 80, 160, 200, 280]$.\n- Case $3$ (pure ambient):\n  - $t = [0.25, 0.25, 0.20, 0.20, 0.10]$,\n  - $m = 600$,\n  - observed counts $y = [30, 60, 120, 150, 240]$.\n- Case $4$ (non-identifiable edge case where $t = a$):\n  - $t = [0.05, 0.10, 0.20, 0.25, 0.40]$,\n  - $m = 500$,\n  - observed counts $y = [25, 50, 100, 125, 200]$.\n  - In this case, because $t = a$, the likelihood depends only on $p_{g} = a_{g}$ and is flat in $w$; the EM fixed point should equal the initialization, i.e., $0.5$.\n\nAngle units are not applicable. No physical units are used. All proportions must be expressed as decimals.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[0.2,0.0,1.0,0.5]\"). Specifically, output the four estimated mixture weights $\\widehat{w}$ for Cases $1$ through $4$ in order, each rounded to six decimal places, in a single list formatted exactly as a Python list literal, i.e., \"[x1,x2,x3,x4]\".", "solution": "The problem posed is valid, scientifically grounded, and well-posed. It describes a standard problem in computational biology—deconvolving a mixed signal—using a classical statistical method. We shall proceed with the derivation of the required Expectation-Maximization (EM) algorithm.\n\nThe objective is to find the maximum a posteriori (MAP) estimate for the ambient mixture weight, $w$, given the observed Unique Molecular Identifier (UMI) counts $\\mathbf{y} = (y_1, \\dots, y_G)$, the true cellular expression profile $\\mathbf{t} = (t_1, \\dots, t_G)$, and the global ambient expression profile $\\mathbf{a} = (a_1, \\dots, a_G)$. The model for the observed counts is a Multinomial distribution with $m = \\sum_{g=1}^G y_g$ trials and mixture probabilities $p_g = (1-w)t_g + w a_g$. We are given a uniform Beta prior on $w$, $p(w) = \\mathrm{Beta}(w | \\alpha=1, \\beta=1)$, which is a constant function over $w \\in [0,1]$. Therefore, MAP estimation is equivalent to Maximum Likelihood Estimation (MLE) constrained to this interval.\n\nThe EM algorithm is an iterative procedure for finding MLE or MAP estimates in models with latent variables. The direct maximization of the observed-data log-likelihood, $\\mathcal{L}(w|\\mathbf{y}) = \\sum_{g=1}^G y_g \\log((1-w)t_g + w a_g)$, is algebraically difficult. We thus introduce latent variables to simplify the problem.\n\n**1. Latent Variable Formulation and Complete-Data Likelihood**\n\nLet us define a set of latent variables that indicate the source of each observed molecule. For each gene $g$, the observed count $y_g$ is a sum of molecules from the true cellular source and the ambient source. Let $c_g$ be the number of molecules of gene $g$ from the cellular source and $d_g$ be the number from the ambient source, such that $y_g = c_g + d_g$. The set of all such counts, $\\mathbf{c}=(c_1, \\dots, c_G)$ and $\\mathbf{d}=(d_1, \\dots, d_G)$, constitutes our latent data. The complete data is $(\\mathbf{y}, \\mathbf{c}, \\mathbf{d})$, which is redundant; knowledge of $(\\mathbf{c}, \\mathbf{d})$ determines $\\mathbf{y}$.\n\nThe total number of molecules from the cellular source is $C = \\sum_{g=1}^G c_g$, and from the ambient source is $D = \\sum_{g=1}^G d_g$. The total number of molecules is $m = C+D$. The choice of $D$ molecules from $m$ to be from the ambient source follows a binomial probability with parameter $w$. The complete-data likelihood, expressing the joint probability of the latent counts given the parameter $w$, is built upon this. The probability of having $C$ molecules from the true profile and $D$ from the ambient is proportional to $(1-w)^C w^D$. The distribution of these molecules across genes follows Multinomial distributions with probabilities $\\mathbf{t}$ and $\\mathbf{a}$ respectively.\n\nThe complete-data log-likelihood, considering only terms that depend on $w$, is:\n$$\n\\log L(w | \\mathbf{c}, \\mathbf{d}) = \\left(\\sum_g c_g\\right) \\log(1-w) + \\left(\\sum_g d_g\\right) \\log(w) + \\text{constant}\n$$\n$$\n\\log L(w | C, D) = C \\log(1-w) + D \\log(w) + \\text{constant}\n$$\nThe problem specifies a $\\mathrm{Beta}(\\alpha=1, \\beta=1)$ prior for $w$. The log-prior is $\\log p(w) = (\\alpha-1)\\log w + (\\beta-1)\\log(1-w) - \\log B(\\alpha, \\beta)$. For $\\alpha=1, \\beta=1$, this is $\\log p(w) = 0$. The complete-data log-posterior is thus proportional to the complete-data log-likelihood.\n\n**2. Derivation of the EM Algorithm**\n\nThe EM algorithm iterates two steps: Expectation (E-step) and Maximization (M-step).\n\n**E-step:**\nIn the E-step, we compute the expectation of the complete-data log-likelihood, conditioned on the observed data $\\mathbf{y}$ and the current estimate of the parameter, $w^{(k)}$. This is equivalent to computing the expectation of the sufficient statistics, which are the total latent counts $C$ and $D$.\n$$\nQ(w | w^{(k)}) = E_{\\mathbf{c},\\mathbf{d} | \\mathbf{y}, w^{(k)}}[\\log L(w | \\mathbf{c}, \\mathbf{d})]\n$$\nLet $D^{(k+1)} = E[D | \\mathbf{y}, w^{(k)}]$ and $C^{(k+1)} = E[C | \\mathbf{y}, w^{(k)}]$. Then the objective function becomes:\n$$\nQ(w | w^{(k)}) = C^{(k+1)} \\log(1-w) + D^{(k+1)} \\log(w) + \\text{constant}\n$$\nTo find $D^{(k+1)}$, we sum the expected latent counts for each gene: $D^{(k+1)} = \\sum_{g=1}^G E[d_g | \\mathbf{y}, w^{(k)}]$. The expectation $E[d_g | \\mathbf{y}, w^{(k)}]$ is the sum of expectations for each of the $y_g$ molecules of gene $g$. For a single molecule observed to be of gene type $g$, the posterior probability that it originates from the ambient source is given by Bayes' theorem:\n$$\nP(\\text{source=ambient} | \\text{gene}=g, w^{(k)}) = \\frac{P(\\text{gene}=g | \\text{source=ambient}) P(\\text{source=ambient} | w^{(k)})}{P(\\text{gene}=g | w^{(k)})}\n$$\nThe terms are:\n- $P(\\text{gene}=g | \\text{source=ambient}) = a_g$\n- $P(\\text{source=ambient} | w^{(k)}) = w^{(k)}$\n- $P(\\text{gene}=g | w^{(k)}) = P(\\text{gene}=g, \\text{ambient}) + P(\\text{gene}=g, \\text{cellular})$\n  $= P(g|\\text{amb})P(\\text{amb}) + P(g|\\text{cell})P(\\text{cell}) = a_g w^{(k)} + t_g (1-w^{(k)}) = p_g^{(k)}$\n\nThus, the posterior probability is $\\frac{w^{(k)} a_g}{p_g^{(k)}}$. Since we have $y_g$ such molecules, by linearity of expectation, the expected number of ambient molecules for gene $g$ is:\n$$\nd_g^{(k+1)} \\equiv E[d_g | \\mathbf{y}, w^{(k)}] = y_g \\cdot \\frac{w^{(k)} a_g}{(1-w^{(k)})t_g + w^{(k)} a_g}\n$$\nThe total expected number of ambient molecules is the sum over all genes:\n$$\nD^{(k+1)} = \\sum_{g=1}^G d_g^{(k+1)} = \\sum_{g=1}^G y_g \\frac{w^{(k)} a_g}{(1-w^{(k)})t_g + w^{(k)} a_g}\n$$\nAlso, since $C+D=m$, we have $C^{(k+1)} = m - D^{(k+1)}$.\n\n**M-step:**\nIn the M-step, we find the value of $w$ that maximizes the expected log-posterior from the E-step. With a uniform prior, this is just maximizing the expected log-likelihood $Q(w|w^{(k)})$.\n$$\nw^{(k+1)} = \\arg\\max_{w \\in [0,1]} \\left( C^{(k+1)} \\log(1-w) + D^{(k+1)} \\log(w) \\right)\n$$\nTaking the derivative with respect to $w$ and setting it to zero:\n$$\n\\frac{\\partial Q}{\\partial w} = -\\frac{C^{(k+1)}}{1-w} + \\frac{D^{(k+1)}}{w} = 0\n$$\n$$\nD^{(k+1)}(1-w) = C^{(k+1)}w \\implies D^{(k+1)} = (C^{(k+1)} + D^{(k+1)})w = m w\n$$\nThis gives the update rule for $w$:\n$$\nw^{(k+1)} = \\frac{D^{(k+1)}}{m}\n$$\nNote that if we had used the general $\\mathrm{Beta}(\\alpha, \\beta)$ prior, the M-step would maximize $(D^{(k+1)} + \\alpha - 1)\\log w + (C^{(k+1)} + \\beta - 1)\\log(1-w)$, yielding the update $w^{(k+1)} = \\frac{D^{(k+1)} + \\alpha - 1}{m + \\alpha + \\beta - 2}$. For our case with $\\alpha=1, \\beta=1$, this simplifies to the MLE update rule.\n\n**Algorithm Summary:**\n1.  Initialize $w^{(0)} = 0.5$.\n2.  For $k=0, 1, \\dots$ up to a maximum of $10,000$ iterations:\n    a.  Compute the expected total ambient count $D^{(k+1)} = \\sum_{g=1}^G y_g \\frac{w^{(k)} a_g}{(1-w^{(k)})t_g + w^{(k)} a_g}$.\n    b.  Update the weight $w^{(k+1)} = \\frac{D^{(k+1)}}{m}$.\n    c.  Check for convergence: if $|w^{(k+1)} - w^{(k)}| < 10^{-12}$, terminate.\n3.  The final estimate is $\\widehat{w} = w^{(k+1)}$.\n\nThis algorithm will now be implemented to solve for the given test cases.", "answer": "```python\nimport numpy as np\n\ndef em_estimator(y: np.ndarray, t: np.ndarray, a: np.ndarray, m: int) -> float:\n    \"\"\"\n    Estimates the ambient mixture weight 'w' using an EM algorithm.\n\n    Args:\n        y: Observed UMI counts for G genes.\n        t: Spot's true cellular expression profile.\n        a: Global ambient expression profile.\n        m: Total UMI count in the spot.\n\n    Returns:\n        The estimated ambient mixture weight w_hat.\n    \"\"\"\n    w = 0.5\n    eps = 1e-12\n    max_iter = 10000\n\n    # In the non-identifiable case where t = a, the likelihood is flat w.r.t w.\n    # The EM update rule becomes w_new = w_old, so the algorithm converges\n    # immediately to the initial value. We can return it directly.\n    if np.allclose(t, a):\n        return 0.5\n\n    for _ in range(max_iter):\n        w_old = w\n\n        # E-step: Calculate the expected number of ambient molecules.\n        # The denominator is the mixture probability for each gene.\n        # It is guaranteed to be positive since all t_g and a_g are positive\n        # for w in [0, 1] in the given test cases.\n        p_g = (1.0 - w) * t + w * a\n        \n        # Posterior probability that a molecule of gene g is from ambient source.\n        # We multiply by y_g to get the expected count for that gene.\n        expected_ambient_counts = y * (w * a / p_g)\n        \n        # Sum over all genes to get total expected ambient counts.\n        total_expected_ambient = np.sum(expected_ambient_counts)\n\n        # M-step: Update w.\n        # With a Beta(1,1) prior (uniform), the MAP estimate is the MLE.\n        w = total_expected_ambient / m\n        \n        # Ensure w stays within the valid range [0, 1] due to potential floating point inaccuracies.\n        w = max(0.0, min(1.0, w))\n\n        # Check for convergence.\n        if np.abs(w - w_old) < eps:\n            break\n            \n    return w\n\ndef solve():\n    \"\"\"\n    Runs the EM estimator on the provided test suite and prints the results.\n    \"\"\"\n    # G = 5, but not explicitly needed as arrays are used.\n    # Ambient profile is constant for all cases.\n    a = np.array([0.05, 0.10, 0.20, 0.25, 0.40])\n    \n    test_cases = [\n        # Case 1 (typical mixture)\n        {'t': np.array([0.30, 0.25, 0.20, 0.15, 0.10]),\n         'y': np.array([250, 220, 200, 170, 160]),\n         'm': 1000},\n        # Case 2 (no ambient contamination)\n        {'t': np.array([0.10, 0.10, 0.20, 0.25, 0.35]),\n         'y': np.array([80, 80, 160, 200, 280]),\n         'm': 800},\n        # Case 3 (pure ambient)\n        {'t': np.array([0.25, 0.25, 0.20, 0.20, 0.10]),\n         'y': np.array([30, 60, 120, 150, 240]),\n         'm': 600},\n        # Case 4 (non-identifiable edge case where t = a)\n        {'t': np.array([0.05, 0.10, 0.20, 0.25, 0.40]),\n         'y': np.array([25, 50, 100, 125, 200]),\n         'm': 500}\n    ]\n    \n    results = []\n    for case in test_cases:\n        w_hat = em_estimator(case['y'], case['t'], a, case['m'])\n        # Round the result to six decimal places as required.\n        results.append(round(w_hat, 6))\n        \n    # Format the output as a Python list literal string.\n    # map(str, ...) on the rounded floats will produce the desired format\n    # (e.g., 0.0 instead of 0.000000).\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2673461"}]}