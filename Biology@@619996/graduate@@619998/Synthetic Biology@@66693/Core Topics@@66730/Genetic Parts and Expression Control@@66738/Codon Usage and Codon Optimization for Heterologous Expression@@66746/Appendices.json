{"hands_on_practices": [{"introduction": "Codon optimization is a cornerstone of synthetic biology, but its consequences extend beyond just translation speed. This foundational exercise allows you to quantify the direct impact of adapting an AT-rich gene for a GC-rich host by calculating changes in two key metrics: the GC-content at the third codon position ($GC3$) and a simplified mRNA stability proxy based on nearest-neighbor stacking energies ($\\mathrm{EDSE}$). By completing this practice [@problem_id:2721544], you will gain a tangible understanding of how synonymous codon substitutions systematically alter the compositional and biophysical properties of a gene.", "problem": "You are tasked with formalizing, implementing, and computing a simple compositional model that quantifies how codon optimization of Adenine-Thymine (AT)-rich parasite genes for expression in Guanine-Cytosine (GC)-rich bacterial hosts alters both the fraction of Guanine-Cytosine at third codon positions (GC3) and a proxy for messenger ribonucleic acid (mRNA) secondary structural stability. The derivation and computation must start from the following foundational bases: the Central Dogma of molecular biology (deoxyribonucleic acid (DNA) is transcribed to mRNA, which is translated to protein), the degeneracy of the genetic code (synonymous codons encode the same amino acid), the wobble position concept (the third position of many codons is often degenerate), and the well-tested empirical observation that higher GC content tends to increase RNA duplex stability via stronger base-pairing and stacking interactions. For the structural proxy, use an additive nearest-neighbor stacking model tailored to a perfectly base-paired duplex registry against the reverse complement, which serves here as a composition-sensitive stability index rather than a full secondary structure prediction.\n\nDefine the following quantities and computational rules precisely:\n\n- Let a coding DNA sequence have length $L_{\\mathrm{nt}}$ nucleotides with $L_{\\mathrm{nt}} \\bmod 3 = 0$, and thus $n = L_{\\mathrm{cod}} = L_{\\mathrm{nt}}/3$ codons. The GC3 fraction is defined as\n  $$ GC3(\\text{DNA}) = \\frac{1}{n} \\sum_{i=1}^{n} \\mathbf{1}\\left\\{ b_{3i} \\in \\{\\mathrm{G},\\mathrm{C}\\} \\right\\}, $$\n  where $b_{3i}$ is the nucleotide at the third position of codon $i$, and $\\mathbf{1}\\{\\cdot\\}$ is the indicator function.\n\n- To model mRNA structural stability, first transcribe DNA to RNA by replacing $\\mathrm{T} \\rightarrow \\mathrm{U}$. For an RNA sequence of length $L$, define the Expected Duplex Stacking Energy (EDSE) proxy as the average of dinucleotide stacking contributions under perfect Watson–Crick registry with the reverse complement:\n  $$ \\mathrm{EDSE}(\\text{RNA}) = \\frac{1}{L-1} \\sum_{i=1}^{L-1} e\\left( s_i s_{i+1} \\right), $$\n  where $s_i \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ and $e(\\cdot)$ is a simplified Turner-like nearest-neighbor energy (in $\\mathrm{kcal/mol}$) for the dinucleotide step indicated by the top-strand adjacent bases $s_i s_{i+1}$, assuming perfect Watson–Crick pairing against its reverse complement. Use the following fixed energy table for $e(\\cdot)$ at $37^\\circ \\mathrm{C}$ (units: $\\mathrm{kcal/mol}$), defined for all $16$ dinucleotides:\n\n  - $e(\\mathrm{AA}) = -0.93$, $e(\\mathrm{AC}) = -1.10$, $e(\\mathrm{AG}) = -1.30$, $e(\\mathrm{AU}) = -1.10$.\n  - $e(\\mathrm{CA}) = -1.10$, $e(\\mathrm{CC}) = -2.08$, $e(\\mathrm{CG}) = -2.17$, $e(\\mathrm{CU}) = -1.30$.\n  - $e(\\mathrm{GA}) = -1.30$, $e(\\mathrm{GC}) = -2.24$, $e(\\mathrm{GG}) = -2.08$, $e(\\mathrm{GU}) = -1.10$.\n  - $e(\\mathrm{UA}) = -0.90$, $e(\\mathrm{UC}) = -1.30$, $e(\\mathrm{UG}) = -1.10$, $e(\\mathrm{UU}) = -0.93$.\n\n- Codon optimization rule: given an amino acid sequence translated from the input coding DNA under the Standard Genetic Code, re-encode the protein by choosing, for each amino acid independently, the host’s most frequent synonymous codon (as provided below). For amino acids with only one codon, retain that codon. This results in a host-optimized DNA sequence with the same amino acid sequence but potentially different GC3 and EDSE.\n\n- For each test case, compute the changes:\n  $$ \\Delta GC3 = GC3(\\text{optimized DNA}) - GC3(\\text{original DNA}), $$\n  $$ \\Delta \\mathrm{EDSE} = \\mathrm{EDSE}(\\text{optimized RNA}) - \\mathrm{EDSE}(\\text{original RNA}). $$\n  Report $\\Delta \\mathrm{EDSE}$ in $\\mathrm{kcal/mol}$ per step. Note that more negative $\\Delta \\mathrm{EDSE}$ indicates a predicted increase in average stacking-based stability.\n\nHost specification for a GC-rich bacterial codon preference model, given as the host’s most frequent codon for each amino acid under the Standard Genetic Code:\n\n- Alanine $\\mathrm{A}$: $\\mathrm{GCC}$\n- Arginine $\\mathrm{R}$: $\\mathrm{CGC}$\n- Asparagine $\\mathrm{N}$: $\\mathrm{AAC}$\n- Aspartate $\\mathrm{D}$: $\\mathrm{GAC}$\n- Cysteine $\\mathrm{C}$: $\\mathrm{TGC}$\n- Glutamine $\\mathrm{Q}$: $\\mathrm{CAG}$\n- Glutamate $\\mathrm{E}$: $\\mathrm{GAG}$\n- Glycine $\\mathrm{G}$: $\\mathrm{GGC}$\n- Histidine $\\mathrm{H}$: $\\mathrm{CAC}$\n- Isoleucine $\\mathrm{I}$: $\\mathrm{ATC}$\n- Leucine $\\mathrm{L}$: $\\mathrm{CTG}$\n- Lysine $\\mathrm{K}$: $\\mathrm{AAG}$\n- Methionine $\\mathrm{M}$: $\\mathrm{ATG}$ (single codon)\n- Phenylalanine $\\mathrm{F}$: $\\mathrm{TTC}$\n- Proline $\\mathrm{P}$: $\\mathrm{CCG}$\n- Serine $\\mathrm{S}$: $\\mathrm{TCG}$\n- Threonine $\\mathrm{T}$: $\\mathrm{ACC}$\n- Tryptophan $\\mathrm{W}$: $\\mathrm{TGG}$ (single codon)\n- Tyrosine $\\mathrm{Y}$: $\\mathrm{TAC}$\n- Valine $\\mathrm{V}$: $\\mathrm{GTC}$\n\nTest suite. Use the following three coding DNA sequences, each uppercase, length a multiple of $3$, with no internal stop codons:\n\n- Case A (AT-rich parasite-like, includes one tryptophan): \n  $$ \\text{ATGAAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT TGG} $$\n  Concatenate without spaces to obtain the sequence.\n\n- Case B (short, includes Proline and Glycine to test GC-driven codons): \n  $$ \\text{ATG CCT GGT TTT AAT ATT AAA TAT TGG} $$\n\n- Case C (bias toward six-fold degenerate amino acids using AT-rich source codons): \n  $$ \\text{ATG TTA TCT AGA TTA TCT AGA TTA TCT AGA GAA GAT CAA AAA AAT TTT ATT TAT CAT TGT} $$\n\nYour program must:\n\n- Implement the Standard Genetic Code to translate codons to amino acids and re-encode with the host’s preferred codons.\n- Compute $GC3$ fractions for original and optimized DNA, and their difference $\\Delta GC3$ as a unitless decimal fraction.\n- Compute $\\mathrm{EDSE}$ for original and optimized RNA via the dinucleotide average specified above, and their difference $\\Delta \\mathrm{EDSE}$ in $\\mathrm{kcal/mol}$ per step.\n- Round both $\\Delta GC3$ and $\\Delta \\mathrm{EDSE}$ to $6$ decimal places.\n\nFinal output format requirement:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the order A, B, C, and is itself a two-element list in the form $[\\Delta GC3, \\Delta \\mathrm{EDSE}]$. For example: $[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$.", "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a clearly defined computational task based on fundamental principles of molecular and synthetic biology, providing all necessary data and rules for a unique and verifiable solution. The problem is a standard exercise in bioinformatics and requires no speculative assumptions. We may therefore proceed with the formal derivation and implementation of the solution.\n\nThe objective is to quantify the effects of codon optimization on two key molecular properties: the Guanine-Cytosine content at the third codon position ($GC3$) and a proxy for messenger RNA (mRNA) structural stability, the Expected Duplex Stacking Energy ($\\mathrm{EDSE}$). This is performed for an AT-rich gene sequence optimized for expression in a GC-rich host. We will compute the change in these two metrics, $\\Delta GC3$ and $\\Delta \\mathrm{EDSE}$.\n\nThe overall computational procedure is as follows:\n$1$. For a given original DNA sequence, calculate its initial $GC3$ value, denoted $GC3(\\text{original DNA})$, and initial stability proxy, $\\mathrm{EDSE}(\\text{original RNA})$.\n$2$. Translate the original DNA sequence into its corresponding amino acid sequence using the Standard Genetic Code.\n$3$. Re-encode this amino acid sequence into a new, optimized DNA sequence by selecting the host's preferred codon for each amino acid, as specified in the provided codon usage table.\n$4$. For this new optimized DNA sequence, calculate its final $GC3$ value, $GC3(\\text{optimized DNA})$, and final stability proxy, $\\mathrm{EDSE}(\\text{optimized RNA})$.\n$5$. Compute the differences: $\\Delta GC3 = GC3(\\text{optimized DNA}) - GC3(\\text{original DNA})$ and $\\Delta \\mathrm{EDSE} = \\mathrm{EDSE}(\\text{optimized RNA}) - \\mathrm{EDSE}(\\text{original RNA})$.\n\nTo implement this procedure, we will first establish the necessary data structures.\n\nThe Standard Genetic Code maps DNA codons to amino acids. A mapping from the $64$ possible codons to the $20$ standard amino acids and stop signals is required. For this problem, we only need the forward translation.\nExample mappings include: `TTT` $\\rightarrow$ Phenylalanine (F), `ATG` $\\rightarrow$ Methionine (M), `GGC` $\\rightarrow$ Glycine (G).\n\nThe host's preferred codon table provides a deterministic rule for re-encoding. It maps each amino acid to a single, specific DNA codon. For example:\n- Alanine (A): $\\mathrm{GCC}$\n- Arginine (R): $\\mathrm{CGC}$\n- ...and so on, for all $20$ amino acids.\n\nThe nearest-neighbor energy table gives the stacking energy contribution $e(s_i s_{i+1})$ for each of the $16$ possible RNA dinucleotides. For example:\n- $e(\\mathrm{GC}) = -2.24 \\, \\mathrm{kcal/mol}$\n- $e(\\mathrm{AU}) = -1.10 \\, \\mathrm{kcal/mol}$\n- $e(\\mathrm{AA}) = -0.93 \\, \\mathrm{kcal/mol}$\n\nWith these data structures, we define the computational functions.\n\nFirst, the $GC3$ fraction is calculated. For a DNA sequence of length $L_{\\mathrm{nt}}$ containing $n = L_{\\mathrm{nt}}/3$ codons, the function iterates through the sequence, examining the nucleotide at each third codon position (i.e., positions $3, 6, 9, \\ldots, L_{\\mathrm{nt}}$ with $1$-based indexing). The count of Guanine ('G') or Cytosine ('C') at these positions is divided by the total number of codons, $n$.\n$$\nGC3(\\text{DNA}) = \\frac{\\text{Count of G or C at third positions}}{\\text{Total number of codons}}\n$$\n\nSecond, the $\\mathrm{EDSE}$ is calculated. A given DNA sequence is first transcribed into its corresponding mRNA sequence by replacing every Thymine ('T') with Uracil ('U'). For the resulting RNA sequence of length $L$, we calculate the sum of nearest-neighbor stacking energies over all $L-1$ adjacent dinucleotide pairs. This sum is then normalized by the number of pairs, $L-1$.\n$$\n\\mathrm{EDSE}(\\text{RNA}) = \\frac{1}{L-1} \\sum_{i=1}^{L-1} e\\left( s_i s_{i+1} \\right)\n$$\nHere, $s_i$ is the base at position $i$ of the RNA sequence, and $e(\\cdot)$ is the energy function defined by the provided table. A more negative $\\mathrm{EDSE}$ value implies greater average stability under the model's assumption of a perfect duplex.\n\nThird, the sequence optimization function performs a two-step process.\nStep $1$, translation: The input DNA sequence is parsed into a list of $3$-base codons. Each codon is translated into an amino acid using the Standard Genetic Code map. The result is a string of amino acids representing the encoded protein.\nStep $2$, re-encoding: This amino acid string is then translated back into a DNA sequence. For each amino acid in the string, the corresponding preferred codon from the host's codon usage table is chosen. These codons are concatenated to form the final, optimized DNA sequence.\n\nFinally, the main algorithm is executed for each test case. The $GC3$ and $\\mathrm{EDSE}$ values are computed for both the original and optimized sequences. The differences, $\\Delta GC3$ and $\\Delta \\mathrm{EDSE}$, are calculated and then rounded to $6$ decimal places as required. The results are aggregated and formatted into the specified output structure. This systematic application of defined rules to the provided data ensures a reproducible and correct solution.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the codon optimization problem by calculating changes in GC3 and EDSE.\n    \"\"\"\n    \n    # --- Data Structures ---\n    \n    # Standard Genetic Code: DNA Codon -> Amino Acid (1-letter code)\n    STANDARD_GENETIC_CODE = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',\n        'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',\n        'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n    }\n    \n    # Host's Preferred Codon Table: Amino Acid -> DNA Codon\n    HOST_CODON_USAGE = {\n        'A': 'GCC', 'R': 'CGC', 'N': 'AAC', 'D': 'GAC', 'C': 'TGC',\n        'Q': 'CAG', 'E': 'GAG', 'G': 'GGC', 'H': 'CAC', 'I': 'ATC',\n        'L': 'CTG', 'K': 'AAG', 'M': 'ATG', 'F': 'TTC', 'P': 'CCG',\n        'S': 'TCG', 'T': 'ACC', 'W': 'TGG', 'Y': 'TAC', 'V': 'GTC',\n    }\n    \n    # Nearest-Neighbor Stacking Energy Table (kcal/mol) for RNA\n    ENERGY_TABLE = {\n        'AA': -0.93, 'AC': -1.10, 'AG': -1.30, 'AU': -1.10,\n        'CA': -1.10, 'CC': -2.08, 'CG': -2.17, 'CU': -1.30,\n        'GA': -1.30, 'GC': -2.24, 'GG': -2.08, 'GU': -1.10,\n        'UA': -0.90, 'UC': -1.30, 'UG': -1.10, 'UU': -0.93,\n    }\n\n    # --- Core Functions ---\n\n    def calculate_gc3(dna_sequence):\n        \"\"\"Calculates the GC3 fraction of a DNA sequence.\"\"\"\n        num_codons = len(dna_sequence) // 3\n        if num_codons == 0:\n            return 0.0\n        \n        gc3_count = 0\n        for i in range(num_codons):\n            third_base = dna_sequence[i * 3 + 2]\n            if third_base in ('G', 'C'):\n                gc3_count += 1\n        return gc3_count / num_codons\n\n    def calculate_edse(dna_sequence):\n        \"\"\"Calculates the Expected Duplex Stacking Energy (EDSE) of an RNA sequence.\"\"\"\n        rna_sequence = dna_sequence.replace('T', 'U')\n        seq_len = len(rna_sequence)\n        if seq_len < 2:\n            return 0.0\n\n        total_energy = 0.0\n        for i in range(seq_len - 1):\n            dinucleotide = rna_sequence[i:i+2]\n            total_energy += ENERGY_TABLE[dinucleotide]\n        \n        return total_energy / (seq_len - 1)\n\n    def optimize_sequence(dna_sequence):\n        \"\"\"Optimizes a DNA sequence based on host codon preference.\"\"\"\n        # 1. Translate original DNA to amino acid sequence\n        num_codons = len(dna_sequence) // 3\n        amino_acid_seq = []\n        for i in range(num_codons):\n            codon = dna_sequence[i * 3 : i * 3 + 3]\n            amino_acid = STANDARD_GENETIC_CODE[codon]\n            amino_acid_seq.append(amino_acid)\n        \n        # 2. Re-encode amino acid sequence using host preferences\n        optimized_codons = []\n        for aa in amino_acid_seq:\n            optimized_codons.append(HOST_CODON_USAGE[aa])\n        \n        return \"\".join(optimized_codons)\n\n    # --- Test Cases ---\n    \n    test_cases_raw = {\n        \"A\": \"ATGAAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT GAA GAT CAA AGA TAT CAT TGT ATA AAA AAT TTT ATT TGG\",\n        \"B\": \"ATG CCT GGT TTT AAT ATT AAA TAT TGG\",\n        \"C\": \"ATG TTA TCT AGA TTA TCT AGA TTA TCT AGA GAA GAT CAA AAA AAT TTT ATT TAT CAT TGT\"\n    }\n\n    # Concatenate sequences by removing spaces\n    test_cases = [seq.replace(\" \", \"\") for seq in test_cases_raw.values()]\n\n    # --- Main Logic ---\n\n    results = []\n    for original_dna in test_cases:\n        # Calculate metrics for original sequence\n        gc3_orig = calculate_gc3(original_dna)\n        edse_orig = calculate_edse(original_dna)\n        \n        # Generate optimized sequence\n        optimized_dna = optimize_sequence(original_dna)\n        \n        # Calculate metrics for optimized sequence\n        gc3_opt = calculate_gc3(optimized_dna)\n        edse_opt = calculate_edse(optimized_dna)\n        \n        # Compute differences and round\n        delta_gc3 = np.round(gc3_opt - gc3_orig, 6)\n        delta_edse = np.round(edse_opt - edse_orig, 6)\n        \n        results.append([delta_gc3, delta_edse])\n\n    # Format and print the final output\n    # Convert floats to strings for custom list representation asked by the problem\n    # e.g., [[x1, y1], [x2, y2]] --> \"[[x1,y1],[x2,y2]]\"\n    result_str = \",\".join([f\"[{d_gc3},{d_edse}]\" for d_gc3, d_edse in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2721544"}, {"introduction": "The biological impact of codon usage is not always constant; it can be significantly modulated by the cell's physiological state. This practice moves beyond deterministic calculations into the realm of statistical inference, where you will analyze hypothetical datasets from different growth conditions. By fitting a linear model with an interaction term [@problem_id:2721531], you will learn how to test whether the effect of codon optimality on mRNA half-life is condition-dependent, a critical skill for understanding and engineering robust biological systems.", "problem": "You are given paired observations for two cellular growth conditions (Condition A and Condition B) for multiple coding sequences: a codon optimality score (dimensionless; for example, a proxy such as Transfer RNA Adaptation Index (tAI) or Codon Adaptation Index (CAI)) and a measured messenger ribonucleic acid (mRNA) half-life (in minutes). Starting from the Central Dogma and the well-tested observation that translation elongation kinetics (influenced by codon optimality) can couple to mRNA decay pathways, assume that a linear response model with an interaction term can capture condition-dependence of the codon optimality effect on stability. Your task is to test, for each dataset, whether the effect of codon optimality on mRNA half-life depends on the growth condition and to quantify the interaction term.\n\nFundamental base to use:\n- The Central Dogma (DNA → RNA → protein) and the coupling between translation elongation and mRNA decay is a well-tested biological observation.\n- Ordinary least squares is the standard method to estimate unknown coefficients in a linear model by minimizing the sum of squared residuals.\n\nYour program must:\n- For each dataset, combine the two conditions into a single analysis with a binary indicator $c \\in \\{0,1\\}$ for the condition (use $c=0$ for Condition A and $c=1$ for Condition B), include an intercept and a main effect for the codon optimality score $s$, and include the product $s \\cdot c$ to capture a potential condition-dependent slope.\n- Estimate the interaction coefficient (the coefficient multiplying $s \\cdot c$) using ordinary least squares, compute its two-sided $t$-test $p$-value under the null hypothesis that the interaction coefficient equals $0$, using degrees of freedom $n-p$ where $n$ is the number of observations and $p$ is the number of fitted coefficients.\n- Use a significance level $\\alpha = 0.05$ (as a decimal) to make a boolean decision to reject the null hypothesis if the $p$-value is less than $\\alpha$.\n- Report, for each dataset, the estimated interaction coefficient (a float), the two-sided $p$-value (a float), and the boolean decision (a boolean).\n\nPhysical and numerical units:\n- mRNA half-life must be treated in minutes. The codon optimality score is dimensionless. The estimated interaction coefficient has units of minutes per unit codon optimality score. The $p$-value and the decision are unitless. You must output only raw numbers and booleans with no unit labels.\n\nTest suite (three datasets):\n- Dataset $1$ (Condition-dependent effect expected):\n  - Condition A: codon scores $s_A = [\\,0.2,\\,0.3,\\,0.5,\\,0.7,\\,0.9\\,]$, half-lives $h_A$ (minutes) $= [\\,3 + 2\\cdot 0.2 + 0.05,\\; 3 + 2\\cdot 0.3 - 0.03,\\; 3 + 2\\cdot 0.5 + 0.02,\\; 3 + 2\\cdot 0.7 - 0.04,\\; 3 + 2\\cdot 0.9 + 0.01\\,]$.\n  - Condition B: codon scores $s_B = [\\,0.2,\\,0.3,\\,0.5,\\,0.7,\\,0.9\\,]$, half-lives $h_B$ (minutes) $= [\\,4 + 3.5\\cdot 0.2 - 0.02,\\; 4 + 3.5\\cdot 0.3 + 0.01,\\; 4 + 3.5\\cdot 0.5 - 0.03,\\; 4 + 3.5\\cdot 0.7 + 0.04,\\; 4 + 3.5\\cdot 0.9 - 0.01\\,]$.\n- Dataset $2$ (No interaction expected):\n  - Condition A: codon scores $s_A = [\\,0.1,\\,0.25,\\,0.5,\\,0.75,\\,0.9,\\,0.95\\,]$, half-lives $h_A$ (minutes) $= [\\,4 + 1.5\\cdot 0.1 + 0.02,\\; 4 + 1.5\\cdot 0.25 - 0.01,\\; 4 + 1.5\\cdot 0.5 + 0.0,\\; 4 + 1.5\\cdot 0.75 - 0.02,\\; 4 + 1.5\\cdot 0.9 + 0.01,\\; 4 + 1.5\\cdot 0.95 - 0.03\\,]$.\n  - Condition B: codon scores $s_B = [\\,0.1,\\,0.25,\\,0.5,\\,0.75,\\,0.9,\\,0.95\\,]$, half-lives $h_B$ (minutes) $= [\\,4.5 + 1.5\\cdot 0.1 - 0.01,\\; 4.5 + 1.5\\cdot 0.25 + 0.02,\\; 4.5 + 1.5\\cdot 0.5 - 0.02,\\; 4.5 + 1.5\\cdot 0.75 + 0.01,\\; 4.5 + 1.5\\cdot 0.9 + 0.0,\\; 4.5 + 1.5\\cdot 0.95 + 0.01\\,]$.\n- Dataset $3$ (Edge case with small sample size and a slope reduction in Condition B):\n  - Condition A: codon scores $s_A = [\\,0.2,\\,0.8,\\,0.9\\,]$, half-lives $h_A$ (minutes) $= [\\,2 + 1\\cdot 0.2 + 0.01,\\; 2 + 1\\cdot 0.8 - 0.02,\\; 2 + 1\\cdot 0.9 + 0.03\\,]$.\n  - Condition B: codon scores $s_B = [\\,0.1,\\,0.4,\\,0.95\\,]$, half-lives $h_B$ (minutes) $= [\\,2 + 0\\cdot 0.1 - 0.01,\\; 2 + 0\\cdot 0.4 + 0.0,\\; 2 + 0\\cdot 0.95 + 0.02\\,]$.\n\nRequired statistical procedure for each dataset:\n- Construct the combined design with an intercept, the codon score $s$, the condition indicator $c$, and the interaction $s\\cdot c$.\n- Estimate coefficients by minimizing the sum of squared residuals.\n- Compute the residual variance estimate, the standard error of the interaction coefficient, the $t$-statistic, and the two-sided $p$-value using the Student distribution with $n-p$ degrees of freedom.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all datasets as a comma-separated list enclosed in square brackets. Each dataset’s result must be a list in the form $[\\hat{\\beta}_{\\text{int}}, p, \\text{decision}]$, where $\\hat{\\beta}_{\\text{int}}$ is the estimated interaction coefficient, $p$ is the two-sided $p$-value, and $\\text{decision}$ is a boolean that is $\\text{True}$ if $p  \\alpha$ and $\\text{False}$ otherwise. Round all floats to $6$ decimal places. For example, the overall output must look like $[[x\\_1,y\\_1,z\\_1],[x\\_2,y\\_2,z\\_2],[x\\_3,y\\_3,z\\_3]]$.", "solution": "We begin from the Central Dogma (DNA transcribed to RNA and translated to protein) and the well-tested observation that translation elongation kinetics, modulated by codon optimality, can influence messenger ribonucleic acid (mRNA) decay rates via coupling between the ribosome and decay machinery. Thus, an increase in codon optimality score $s$ can increase translation elongation speed and, in many systems, stabilize transcripts, implying that mRNA half-life $h$ depends on $s$. Environmental or growth conditions can alter transfer ribonucleic acid (tRNA) pools or decay factors, potentially changing how $s$ maps to $h$. To capture condition-dependence, we posit a linear response with an interaction between the codon optimality score and a condition indicator.\n\nAlgorithmic modeling framework:\n- For each observation $i$, define $s_i$ as the codon optimality score and $c_i \\in \\{0,1\\}$ as the binary indicator of Condition B (with Condition A coded as $c_i=0$). Let $h_i$ be the measured mRNA half-life (in minutes).\n- Consider a linear model with an intercept, main effects, and an interaction term:\n  $$ h_i = \\beta_0 + \\beta_s s_i + \\beta_c c_i + \\beta_{sc}\\, s_i c_i + \\varepsilon_i, $$\n  where $\\varepsilon_i$ are independent, zero-mean noise terms with finite variance, and $\\beta_{sc}$ quantifies the condition-dependence of the slope relating $s$ to $h$.\n- Stack all $n$ observations into matrix form:\n  $$ \\mathbf{h} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}, $$\n  where $\\mathbf{h}\\in\\mathbb{R}^{n}$, $\\boldsymbol{\\beta} = [\\beta_0,\\beta_s,\\beta_c,\\beta_{sc}]^\\top \\in \\mathbb{R}^{4}$, and\n  $$ \\mathbf{X} = \\begin{bmatrix}\n  1  s_1  c_1  s_1 c_1\\\\\n  \\vdots  \\vdots  \\vdots  \\vdots\\\\\n  1  s_n  c_n  s_n c_n\n  \\end{bmatrix}. $$\n- Estimate coefficients by ordinary least squares (OLS), which minimizes the sum of squared residuals $S(\\boldsymbol{\\beta}) = \\|\\mathbf{h} - \\mathbf{X}\\boldsymbol{\\beta}\\|_2^2$. The OLS estimate is\n  $$ \\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^\\top \\mathbf{X})^{-1}\\mathbf{X}^\\top \\mathbf{h}, $$\n  assuming $\\mathbf{X}$ has full column rank.\n- Compute fitted values $\\hat{\\mathbf{h}} = \\mathbf{X}\\hat{\\boldsymbol{\\beta}}$ and residuals $\\hat{\\boldsymbol{\\varepsilon}} = \\mathbf{h} - \\hat{\\mathbf{h}}$. Let $p=4$ be the number of parameters. The unbiased residual variance estimator is\n  $$ \\hat{\\sigma}^2 = \\frac{\\hat{\\boldsymbol{\\varepsilon}}^\\top \\hat{\\boldsymbol{\\varepsilon}}}{n-p}. $$\n- The covariance matrix of $\\hat{\\boldsymbol{\\beta}}$ under the usual OLS assumptions is\n  $$ \\widehat{\\mathrm{Cov}}(\\hat{\\boldsymbol{\\beta}}) = \\hat{\\sigma}^2 (\\mathbf{X}^\\top \\mathbf{X})^{-1}. $$\n  The standard error of the interaction coefficient is\n  $$ \\mathrm{SE}(\\hat{\\beta}_{sc}) = \\sqrt{\\left[\\widehat{\\mathrm{Cov}}(\\hat{\\boldsymbol{\\beta}})\\right]_{4,4}}. $$\n- To test the null hypothesis $H_0:\\ \\beta_{sc}=0$ versus the two-sided alternative $H_1:\\ \\beta_{sc}\\neq 0$, use the $t$-statistic\n  $$ t = \\frac{\\hat{\\beta}_{sc}}{\\mathrm{SE}(\\hat{\\beta}_{sc})}, $$\n  which, under $H_0$ and standard OLS assumptions, follows a Student distribution with $n-p$ degrees of freedom. The two-sided $p$-value is\n  $$ p = 2\\left(1 - F_{t,n-p}(|t|)\\right), $$\n  where $F_{t,\\nu}$ is the cumulative distribution function of the $t$-distribution with $\\nu$ degrees of freedom.\n- With significance level $\\alpha = 0.05$, reject $H_0$ if $p  \\alpha$. The decision is returned as a boolean.\n\nImplementation details applied to the test suite:\n- For each dataset, build the combined design matrix by concatenating Condition A and Condition B observations. Set $c=0$ for all Condition A rows and $c=1$ for all Condition B rows. Construct the columns $[1, s, c, s\\cdot c]$, estimate $\\hat{\\boldsymbol{\\beta}}$, compute $\\hat{\\sigma}^2$, extract $\\hat{\\beta}_{sc}$ and its standard error, form $t$, evaluate the two-sided $p$-value with $n-p$ degrees of freedom, and compare to $\\alpha=0.05$.\n- Return, for each dataset, the triple $[\\hat{\\beta}_{\\text{int}}, p, \\text{decision}]$, where $\\hat{\\beta}_{\\text{int}} \\equiv \\hat{\\beta}_{sc}$, rounding $\\hat{\\beta}_{\\text{int}}$ and $p$ to $6$ decimal places.\n\nThis procedure quantifies whether codon optimality effects on mRNA stability are condition-dependent (nonzero $\\hat{\\beta}_{sc}$) and provides a rigorous statistical test grounded in least squares estimation and $t$-distribution inference.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t as student_t\n\ndef ols_interaction_test(s_A, h_A, s_B, h_B, alpha=0.05):\n    \"\"\"\n    Fit OLS with intercept, s, c, s*c and test interaction coefficient.\n    Returns (beta_interaction, p_value, decision_bool).\n    \"\"\"\n    # Prepare data\n    s_A = np.asarray(s_A, dtype=float)\n    h_A = np.asarray(h_A, dtype=float)\n    s_B = np.asarray(s_B, dtype=float)\n    h_B = np.asarray(h_B, dtype=float)\n\n    # Concatenate\n    s = np.concatenate([s_A, s_B])\n    h = np.concatenate([h_A, h_B])\n    c = np.concatenate([np.zeros_like(s_A), np.ones_like(s_B)])\n\n    # Design matrix: [1, s, c, s*c]\n    X = np.column_stack([np.ones_like(s), s, c, s * c])\n    n, p = X.shape\n\n    # OLS estimates\n    # Compute (X^T X)^{-1} X^T h robustly\n    XtX = X.T @ X\n    XtX_inv = np.linalg.inv(XtX)\n    beta_hat = XtX_inv @ (X.T @ h)\n\n    # Residuals and variance estimate\n    h_hat = X @ beta_hat\n    resid = h - h_hat\n    dof = n - p\n    # Guard against division by zero if dof = 0 (should not occur with provided tests)\n    sigma2_hat = (resid @ resid) / dof\n\n    # Standard errors\n    cov_beta = sigma2_hat * XtX_inv\n    se_beta = np.sqrt(np.diag(cov_beta))\n\n    # Interaction coefficient is the 4th parameter\n    beta_int = beta_hat[3]\n    se_int = se_beta[3]\n\n    # t-statistic and two-sided p-value\n    t_stat = beta_int / se_int\n    p_value = 2.0 * (1.0 - student_t.cdf(np.abs(t_stat), df=dof))\n\n    decision = bool(p_value  alpha)\n    # Round floats to 6 decimals\n    beta_int_r = round(float(beta_int), 6)\n    p_value_r = round(float(p_value), 6)\n    return [beta_int_r, p_value_r, decision]\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Dataset 1\n    sA1 = [0.2, 0.3, 0.5, 0.7, 0.9]\n    hA1 = [3 + 2*0.2 + 0.05,\n           3 + 2*0.3 - 0.03,\n           3 + 2*0.5 + 0.02,\n           3 + 2*0.7 - 0.04,\n           3 + 2*0.9 + 0.01]\n    sB1 = [0.2, 0.3, 0.5, 0.7, 0.9]\n    hB1 = [4 + 3.5*0.2 - 0.02,\n           4 + 3.5*0.3 + 0.01,\n           4 + 3.5*0.5 - 0.03,\n           4 + 3.5*0.7 + 0.04,\n           4 + 3.5*0.9 - 0.01]\n\n    # Dataset 2\n    sA2 = [0.1, 0.25, 0.5, 0.75, 0.9, 0.95]\n    hA2 = [4 + 1.5*0.1 + 0.02,\n           4 + 1.5*0.25 - 0.01,\n           4 + 1.5*0.5 + 0.0,\n           4 + 1.5*0.75 - 0.02,\n           4 + 1.5*0.9 + 0.01,\n           4 + 1.5*0.95 - 0.03]\n    sB2 = [0.1, 0.25, 0.5, 0.75, 0.9, 0.95]\n    hB2 = [4.5 + 1.5*0.1 - 0.01,\n           4.5 + 1.5*0.25 + 0.02,\n           4.5 + 1.5*0.5 - 0.02,\n           4.5 + 1.5*0.75 + 0.01,\n           4.5 + 1.5*0.9 + 0.0,\n           4.5 + 1.5*0.95 + 0.01]\n\n    # Dataset 3\n    sA3 = [0.2, 0.8, 0.9]\n    hA3 = [2 + 1*0.2 + 0.01,\n           2 + 1*0.8 - 0.02,\n           2 + 1*0.9 + 0.03]\n    sB3 = [0.1, 0.4, 0.95]\n    hB3 = [2 + 0*0.1 - 0.01,\n           2 + 0*0.4 + 0.0,\n           2 + 0*0.95 + 0.02]\n\n    alpha = 0.05\n\n    test_cases = [\n        (sA1, hA1, sB1, hB1, alpha),\n        (sA2, hA2, sB2, hB2, alpha),\n        (sA3, hA3, sB3, hB3, alpha),\n    ]\n\n    results = []\n    for sA, hA, sB, hB, a in test_cases:\n        result = ols_interaction_test(sA, hA, sB, hB, alpha=a)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # It should be a single line: [[b1,p1,dec1],[b2,p2,dec2],[b3,p3,dec3]]\n    def format_item(x):\n        if isinstance(x, bool):\n            return \"True\" if x else \"False\"\n        else:\n            return str(x)\n\n    formatted = \"[\" + \",\".join(\n        \"[\" + \",\".join(format_item(x) for x in res) + \"]\" for res in results\n    ) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2721531"}, {"introduction": "Building upon the initial exploration of RNA stability, this advanced practice challenges you to implement a more sophisticated and realistic model of mRNA structure. You will replace a simple energy proxy with a full Minimum Free Energy (MFE) calculation using a Nussinov-style dynamic programming algorithm. This exercise [@problem_id:2721468] provides deep, hands-on experience with a classic bioinformatics algorithm and illuminates how subtle codon choices can dramatically reshape the intricate secondary structure of an mRNA molecule.", "problem": "You are given a computational task grounded in the Central Dogma of molecular biology and codon bias in heterologous gene expression. Protein coding sequences (coding DNA sequences, CDS) are composed of codons, each mapping to an amino acid. Due to degeneracy of the genetic code, multiple synonymous codons map to the same amino acid, but organisms often exhibit codon usage bias. Messenger ribonucleic acid (mRNA) secondary structure stability can be approximated through base-pairing energetics, and altering codon choice (while preserving the amino acid sequence) can change the minimum free energy (MFE) of the coding-region RNA. Your goal is to implement a principled estimator of the change in coding-region MFE when replacing neutral codon pairs with host-preferred pairs, while keeping the amino acid sequence unchanged.\n\nUse the following fundamental base:\n- Central Dogma: DNA is transcribed to RNA, which is translated into protein.\n- Codon degeneracy: Multiple codons can encode the same amino acid.\n- Host codon usage bias: Each amino acid has a distribution of synonymous codon frequencies, denoted by $f(c)$ for codon $c$, with $\\sum f(c)=1$ over all synonymous codons for the same amino acid.\n- RNA base pairing: Watson–Crick base pairs ($\\mathrm{AU}$, $\\mathrm{UA}$, $\\mathrm{GC}$, $\\mathrm{CG}$) and wobble pairs ($\\mathrm{GU}$, $\\mathrm{UG}$) contribute stabilizing (negative) energy to RNA secondary structure. As a simplified and physically motivated proxy to the thermodynamic minimum free energy, we adopt a weighted Nussinov-style dynamic programming model that finds a minimum-energy non-crossing set of base pairs subject to a minimum hairpin loop length.\n\nDefinitions and requirements:\n1. For an amino acid $a$ and its set of synonymous codons $\\mathcal{C}(a)$, define the host usage frequency $f(c)$ for each $c \\in \\mathcal{C}(a)$, with $\\sum_{c \\in \\mathcal{C}(a)} f(c) = 1$. Define the relative adaptiveness $w(c)$ by\n$$\nw(c) = \\frac{f(c)}{\\max_{c' \\in \\mathcal{C}(a)} f(c')}.\n$$\n2. A codon $c$ is called neutral if $w(c) \\ge \\theta$, where $\\theta \\in (0,1]$ is a given threshold. A codon pair $(c_i,c_{i+1})$ is called neutral if both $c_i$ and $c_{i+1}$ are neutral. You must scan codons in disjoint, non-overlapping adjacent pairs: $(c_1,c_2)$, $(c_3,c_4)$, $(c_5,c_6)$, etc. If the number of codons $N$ is odd, leave the last codon unchanged and unpaired for replacement decisions.\n3. For each neutral pair $(c_i,c_{i+1})$, replace it by the host-preferred pair $(c_i^\\star,c_{i+1}^\\star)$, where $c_i^\\star$ is any codon that achieves $\\max_{c \\in \\mathcal{C}(a_i)} f(c)$ for amino acid $a_i$, and similarly for $c_{i+1}^\\star$ for amino acid $a_{i+1}$. This produces an optimized DNA sequence that preserves the amino acid sequence.\n4. Transcribe DNA to RNA by replacing $\\mathrm{T}$ with $\\mathrm{U}$.\n5. Compute an MFE proxy $G(S)$ for an RNA sequence $S$ using the following weighted Nussinov-style dynamic programming:\n   - Allowed base pairs are $\\mathrm{AU}$, $\\mathrm{UA}$, $\\mathrm{GC}$, $\\mathrm{CG}$, $\\mathrm{GU}$, and $\\mathrm{UG}$, with pair energies (in kilocalories per mole) given by:\n     - $E(\\mathrm{AU})=E(\\mathrm{UA})=-2.1$\n     - $E(\\mathrm{GC})=E(\\mathrm{CG})=-3.4$\n     - $E(\\mathrm{GU})=E(\\mathrm{UG})=-0.9$\n   - Enforce a minimum hairpin loop length $L_0 = 3$, meaning positions $i$ and $j$ can pair only if $j - i - 1 \\ge L_0$.\n   - Let $S$ have length $L$. Define a dynamic programming matrix $D \\in \\mathbb{R}^{L \\times L}$ where $D[i,j]$ is the minimum energy achievable for the subsequence $S[i..j]$ under non-crossing base pairs. The recurrence is:\n     $$\n     D[i,j] = \\min \\Big\\{\n       D[i+1,j],\\;\n       D[i,j-1],\\;\n       D[i+1,j-1] + E(S[i],S[j]) \\;\\text{if pairing allowed},\\;\n       \\min_{k=i}^{j-1} \\big( D[i,k] + D[k+1,j] \\big)\n     \\Big\\}\n     $$\n     with base conditions $D[i,i]=0$ and $D[i,j]=0$ for $i \\ge j$. If a pairing is not allowed, treat that branch as $+\\infty$. The final MFE proxy is $G(S) = D[0,L-1]$ in kilocalories per mole.\n6. Define the change in MFE by\n$$\n\\Delta G = G(S_{\\text{opt}}) - G(S_{\\text{orig}}),\n$$\nin kilocalories per mole, where $S_{\\text{orig}}$ is the original transcribed RNA and $S_{\\text{opt}}$ is the optimized transcribed RNA. Express all reported energies in kilocalories per mole, rounded to $3$ decimal places.\n\nHost usage table and genetic code subset:\n- Consider only amino acids that appear in the test sequences and their synonymous codons. For each amino acid $a$, the host usage frequencies $f(c)$ (per codon $c$) are:\n  - Alanine ($\\mathrm{Ala}$, single-letter $\\mathrm{A}$): $\\{\\mathrm{GCT}:0.2,\\ \\mathrm{GCC}:0.5,\\ \\mathrm{GCA}:0.1,\\ \\mathrm{GCG}:0.2\\}$.\n  - Glycine ($\\mathrm{Gly}$, $\\mathrm{G}$): $\\{\\mathrm{GGT}:0.25,\\ \\mathrm{GGC}:0.45,\\ \\mathrm{GGA}:0.1,\\ \\mathrm{GGG}:0.2\\}$.\n  - Valine ($\\mathrm{Val}$, $\\mathrm{V}$): $\\{\\mathrm{GTT}:0.2,\\ \\mathrm{GTC}:0.2,\\ \\mathrm{GTA}:0.1,\\ \\mathrm{GTG}:0.5\\}$.\n  - Lysine ($\\mathrm{Lys}$, $\\mathrm{K}$): $\\{\\mathrm{AAA}:0.3,\\ \\mathrm{AAG}:0.7\\}$.\n  - Glutamate ($\\mathrm{Glu}$, $\\mathrm{E}$): $\\{\\mathrm{GAA}:0.35,\\ \\mathrm{GAG}:0.65\\}$.\n  - Methionine ($\\mathrm{Met}$, $\\mathrm{M}$): $\\{\\mathrm{ATG}:1.0\\}$.\n- Use the standard genetic code for these amino acids and their listed codons. All test sequences are composed exclusively of these codons.\n\nTest suite:\nEach test case is a pair $(\\text{DNA}, \\theta)$ where $\\text{DNA}$ is the coding DNA sequence (a string whose length is a multiple of $3$) and $\\theta$ is the neutrality threshold. For each test, compute $\\Delta G$ as defined above. Use $L_0 = 3$ for all tests. Report each result as a float in kilocalories per mole, rounded to $3$ decimal places.\n\n- Test $1$ (happy path): $(\\text{\"GCTGGTAAAGAA\"},\\ \\theta=0.4)$.\n- Test $2$ (already preferred, no change expected): $(\\text{\"GCCGGCAAGGAG\"},\\ \\theta=0.4)$.\n- Test $3$ (odd number of codons, last codon unpaired for replacement): $(\\text{\"GCTGTGAAA\"},\\ \\theta=0.4)$.\n- Test $4$ (includes single-codon amino acid Methionine): $(\\text{\"ATGGAA\"},\\ \\theta=0.4)$.\n- Test $5$ (strict neutrality threshold, replacements only if both codons are already top choices): $(\\text{\"GCTGGTAAAGAA\"},\\ \\theta=1.0)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of floats enclosed in square brackets, in the same order as the tests, with each float rounded to $3$ decimal places (e.g., `[-3.200,0.000,...]`).", "solution": "The problem is valid. It is scientifically grounded in established principles of molecular biology and computational biophysics, is well-posed with all necessary information provided, and is algorithmically formalizable. I will proceed with a complete solution.\n\nThe task is to compute the change in the minimum free energy ($\\Delta G$) of a coding sequence's transcribed RNA that results from a codon optimization procedure. This procedure aims to replace codon pairs of moderate-to-high frequency (\"neutral\") with the most frequent (\"preferred\") synonymous codons in a host organism. The solution involves two main components: first, implementing the codon optimization logic, and second, calculating an MFE proxy for the original and optimized RNA sequences using a specified dynamic programming algorithm.\n\nFirst, we must establish the data structures required by the problem. This includes the genetic code mapping codons to amino acids, the host codon usage frequencies $f(c)$ for each codon $c$, and the base-pairing energies $E$. From the given frequencies, we pre-calculate two key metrics for each amino acid $a$: the maximum synonymous codon frequency, $\\max_{c' \\in \\mathcal{C}(a)} f(c')$, and the corresponding most preferred codon, $c^\\star$. The relative adaptiveness $w(c)$ for any codon $c$ is then computed as required:\n$$\nw(c) = \\frac{f(c)}{\\max_{c' \\in \\mathcal{C}(a)} f(c')}\n$$\nwhere $a$ is the amino acid encoded by $c$.\n\nThe codon optimization algorithm proceeds as follows. The input DNA sequence is parsed into a sequence of $N$ codons, $(c_1, c_2, \\dots, c_N)$. These codons are processed in disjoint, non-overlapping pairs: $(c_1, c_2)$, $(c_3, c_4)$, and so on. If $N$ is odd, the final codon $c_N$ is not part of any pair and is left unmodified. For each pair $(c_i, c_{i+1})$, where $i$ is an odd index starting from $1$, we determine if the pair is \"neutral\". A pair is defined as neutral if both codons are individually neutral, meaning their relative adaptiveness values meet or exceed a given threshold $\\theta$:\n$$\nw(c_i) \\ge \\theta \\quad \\text{and} \\quad w(c_{i+1}) \\ge \\theta\n$$\nIf a pair is determined to be neutral, it is replaced by the host-preferred pair $(c_i^\\star, c_{i+1}^\\star)$, where $c_i^\\star$ is the most frequent codon for the amino acid $a_i$ (encoded by $c_i$), and $c_{i+1}^\\star$ is the most frequent codon for $a_{i+1}$. If the pair is not neutral, it remains unchanged. This process yields an optimized DNA sequence, which, by design, encodes the exact same amino acid sequence as the original.\n\nThe second part of the problem is to quantify the structural impact of this optimization by computing a minimum free energy (MFE) proxy, $G(S)$, for an RNA sequence $S$. The DNA sequence is first transcribed to RNA by replacing all occurrences of the base $\\mathrm{T}$ with $\\mathrm{U}$. The MFE proxy is calculated using a dynamic programming approach similar to the Nussinov algorithm for RNA secondary structure prediction. For an RNA sequence $S$ of length $L$, we compute an $L \\times L$ matrix $D$, where $D[i,j]$ stores the minimum free energy of the subsequence $S[i..j]$. The recurrence relation, as specified, considers all possibilities for a non-crossing structure: a base can be unpaired, it can form a pair with another base, or the structure can bifurcate into two independent substructures. Formally, for $0 \\le i  j  L$, the value of $D[i,j]$ is given by:\n$$\nD[i,j] = \\min \\Big\\{\n    D[i+1,j],\\;\n    D[i,j-1],\\;\n    D[i+1,j-1] + E(S[i],S[j]),\\;\n    \\min_{k=i}^{j-1} \\big( D[i,k] + D[k+1,j] \\big)\n\\Big\\}\n$$\nThe term $D[i+1,j-1] + E(S[i],S[j])$ is included only if a pairing between bases $S[i]$ and $S[j]$ is allowed. A pairing is allowed if it is one of the Watson-Crick ($\\mathrm{AU}$, $\\mathrm{GC}$) or wobble ($\\mathrm{GU}$) pairs and satisfies the minimum hairpin loop length constraint, $j - i - 1 \\ge L_0$, where $L_0 = 3$. The base-pairing energies $E$ are given as: $E(\\mathrm{AU})=E(\\mathrm{UA})=-2.1$, $E(\\mathrm{GC})=E(\\mathrm{CG})=-3.4$, and $E(\\mathrm{GU})=E(\\mathrm{UG})=-0.9$, all in kcal/mol. The base cases for the recursion are $D[i,i] = 0$ for all $i$, and $D[i,j] = 0$ for $i  j$. The MFE proxy for the entire sequence $S$ is $G(S) = D[0,L-1]$.\n\nTo solve each test case, we apply this MFE calculation to both the original RNA sequence, $S_{\\text{orig}}$, and the optimized RNA sequence, $S_{\\text{opt}}$, to obtain $G(S_{\\text{orig}})$ and $G(S_{\\text{opt}})$, respectively. The final quantity of interest is the change in MFE, $\\Delta G$, defined as:\n$$\n\\Delta G = G(S_{\\text{opt}}) - G(S_{\\text{orig}})\n$$\nThe result is reported in kilocalories per mole, rounded to $3$ decimal places. This entire procedure is encapsulated in a program that iterates through the provided test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the codon optimization and MFE calculation problem.\n    \"\"\"\n    # Define constants and data structures based on the problem statement.\n    genetic_code = {\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',  # Alanine\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',  # Glycine\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',  # Valine\n        'AAA': 'K', 'AAG': 'K',                          # Lysine\n        'GAA': 'E', 'GAG': 'E',                          # Glutamate\n        'ATG': 'M',                                      # Methionine\n    }\n\n    codon_usage = {\n        'A': {'GCT': 0.2, 'GCC': 0.5, 'GCA': 0.1, 'GCG': 0.2},\n        'G': {'GGT': 0.25, 'GGC': 0.45, 'GGA': 0.1, 'GGG': 0.2},\n        'V': {'GTT': 0.2, 'GTC': 0.2, 'GTA': 0.1, 'GTG': 0.5},\n        'K': {'AAA': 0.3, 'AAG': 0.7},\n        'E': {'GAA': 0.35, 'GAG': 0.65},\n        'M': {'ATG': 1.0},\n    }\n\n    pair_energies = {\n        'AU': -2.1, 'UA': -2.1,\n        'GC': -3.4, 'CG': -3.4,\n        'GU': -0.9, 'UG': -0.9,\n    }\n\n    L0 = 3\n\n    # Pre-calculate max frequencies and preferred codons for efficiency.\n    max_freqs = {aa: max(freqs.values()) for aa, freqs in codon_usage.items()}\n    preferred_codons = {\n        aa: max(freqs, key=freqs.get) for aa, freqs in codon_usage.items()\n    }\n\n    def calculate_mfe(dna_sequence: str) - float:\n        \"\"\"\n        Calculates the MFE proxy for a given DNA sequence using the specified DP.\n        \"\"\"\n        rna = dna_sequence.replace('T', 'U')\n        L = len(rna)\n        if L == 0:\n            return 0.0\n\n        # Initialize DP table. Zeros handle base cases D[i,i] and D[i,j] for ij.\n        dp = np.zeros((L, L))\n\n        # Iterate over subsequence length, l.\n        for l in range(2, L + 1):\n            # Iterate over start position, i.\n            for i in range(L - l + 1):\n                j = i + l - 1\n\n                # Term 1: i is unpaired.\n                term1 = dp[i + 1, j]\n\n                # Term 2: j is unpaired.\n                term2 = dp[i, j - 1]\n\n                # Term 3: i and j form a base pair.\n                term3 = float('inf')\n                pair = rna[i] + rna[j]\n                if j - i - 1 = L0 and pair in pair_energies:\n                    energy = pair_energies[pair]\n                    # Interior loop energy. If i+1  j-1, subproblem is empty, energy 0.\n                    sub_energy = dp[i + 1, j - 1] if i + 1 = j - 1 else 0.0\n                    term3 = energy + sub_energy\n\n                # Term 4: Bifurcation.\n                # Loop for k from i to j-1 to find the minimum energy split.\n                bifurcation_min = min(dp[i, k] + dp[k + 1, j] for k in range(i, j))\n                term4 = bifurcation_min\n\n                dp[i, j] = min(term1, term2, term3, term4)\n\n        return dp[0, L - 1]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"GCTGGTAAAGAA\", 0.4),\n        (\"GCCGGCAAGGAG\", 0.4),\n        (\"GCTGTGAAA\", 0.4),\n        (\"ATGGAA\", 0.4),\n        (\"GCTGGTAAAGAA\", 1.0),\n    ]\n\n    results = []\n    for dna, theta in test_cases:\n        # 1. Calculate MFE for the original sequence.\n        mfe_orig = calculate_mfe(dna)\n\n        # 2. Generate the optimized sequence.\n        codons = [dna[i:i+3] for i in range(0, len(dna), 3)]\n        num_codons = len(codons)\n        optimized_codons = list(codons)\n\n        # Iterate over non-overlapping pairs of codons.\n        for i in range(num_codons // 2):\n            idx1 = 2 * i\n            idx2 = 2 * i + 1\n            \n            c1 = codons[idx1]\n            c2 = codons[idx2]\n\n            aa1 = genetic_code[c1]\n            aa2 = genetic_code[c2]\n\n            w1 = codon_usage[aa1][c1] / max_freqs[aa1]\n            w2 = codon_usage[aa2][c2] / max_freqs[aa2]\n\n            # Check if the pair is neutral.\n            if w1 = theta and w2 = theta:\n                optimized_codons[idx1] = preferred_codons[aa1]\n                optimized_codons[idx2] = preferred_codons[aa2]\n\n        optimized_dna = \"\".join(optimized_codons)\n\n        # 3. Calculate MFE for the optimized sequence.\n        mfe_opt = calculate_mfe(optimized_dna)\n        \n        # 4. Compute the change in MFE, round, and store the result.\n        delta_g = mfe_opt - mfe_orig\n        results.append(delta_g)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "2721468"}]}