{"hands_on_practices": [{"introduction": "Genetic toggle switches are foundational motifs in synthetic biology, enabling cellular memory and decision-making. To design them effectively, we must first understand the principles governing their behavior. This practice guides you through a linear stability analysis of a symmetric toggle switch, a core technique to determine how a system responds to perturbations [@problem_id:2723594]. By analyzing the system's eigenvalues, you will derive the minimum level of cooperativity, represented by the Hill coefficient $n$, required to achieve bistability, providing a fundamental design rule for building reliable biological switches.", "problem": "A symmetric mutual-repression genetic toggle switch is commonly analyzed in computer-aided design (CAD) tools for genetic circuits by modeling transcriptional regulation with Hill functions derived from cooperative binding at quasi-equilibrium. Consider two transcriptional repressors with identical parameters whose dynamics are described by first-order mass balance ordinary differential equations (ODEs) with Hill-type repression and linear dilution-degradation. Specifically, let the protein concentrations be $x(t)$ and $y(t)$, and assume identical maximal synthesis rate $\\alpha > 0$, a Hill coefficient $n \\geq 0$ describing cooperativity of binding, and a time scale such that the effective first-order loss rate is $1$. The standard symmetric ODE model is\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha}{1 + y^{n}} \\;-\\; x, \n\\qquad\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha}{1 + x^{n}} \\;-\\; y.\n$$\nThese equations arise from the Central Dogma of Molecular Biology (transcription and translation producing protein) combined with first-order loss and a Hill repression function $\\alpha/(1+(\\cdot)^{n})$ that is a well-tested phenomenological reduction of cooperative binding.\n\nUsing linear stability analysis and only the fundamental definitions above, analyze how the cooperativity $n$ influences the existence of bistability in this symmetric system. In particular, determine the smallest Hill coefficient (interpreted as the infimum over real $n$) for which there exists some $\\alpha$ that yields bistability (two distinct, stable steady states related by exchange symmetry). Express your final answer as a single real number. No rounding is required.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It describes a canonical model in synthetic biology, the symmetric toggle switch, using standard mathematical formalisms. The parameters are defined, the governing equations are provided, and the objective is a precise mathematical question. There are no contradictions, ambiguities, or factual errors. Therefore, the problem is valid and I will proceed with a full solution.\n\nThe system of ordinary differential equations describing the protein concentrations $x(t)$ and $y(t)$ is given by:\n$$\n\\frac{dx}{dt} = \\frac{\\alpha}{1 + y^{n}} - x\n$$\n$$\n\\frac{dy}{dt} = \\frac{\\alpha}{1 + x^{n}} - y\n$$\nHere, $\\alpha > 0$ is the maximal synthesis rate, $n \\geq 0$ is the Hill coefficient representing cooperativity, and the effective degradation rate constant is scaled to $1$.\n\nBistability refers to the existence of two distinct stable steady states. In this symmetric system, bistability typically manifests as two stable asymmetric steady states $(\\bar{x}_a, \\bar{y}_a)$ and $(\\bar{y}_a, \\bar{x}_a)$ with $\\bar{x}_a \\neq \\bar{y}_a$, coexisting with an unstable symmetric steady state $(\\bar{x}_s, \\bar{y}_s)$ where $\\bar{x}_s = \\bar{y}_s$. The emergence of bistability is therefore linked to the loss of stability of the symmetric steady state. We begin by analyzing the stability of this symmetric state.\n\nFirst, we find the symmetric steady state concentration, which we denote as $x_s$. By setting $\\frac{dx}{dt} = 0$ and $x=y=x_s$, we obtain:\n$$\nx_s = \\frac{\\alpha}{1 + x_s^{n}}\n$$\nThis can be rewritten as $\\alpha = x_s(1 + x_s^n)$.\n\nTo analyze the stability, we linearize the system around the steady state $(x_s, x_s)$ by computing the Jacobian matrix $J$.\n$$\nJ(x, y) = \\begin{pmatrix} \\frac{\\partial}{\\partial x}\\left(\\frac{\\alpha}{1 + y^{n}} - x\\right) & \\frac{\\partial}{\\partial y}\\left(\\frac{\\alpha}{1 + y^{n}} - x\\right) \\\\ \\frac{\\partial}{\\partial x}\\left(\\frac{\\alpha}{1 + x^{n}} - y\\right) & \\frac{\\partial}{\\partial y}\\left(\\frac{\\alpha}{1 + x^{n}} - y\\right) \\end{pmatrix} = \\begin{pmatrix} -1 & -\\frac{\\alpha n y^{n-1}}{(1+y^n)^2} \\\\ -\\frac{\\alpha n x^{n-1}}{(1+x^n)^2} & -1 \\end{pmatrix}\n$$\nEvaluating the Jacobian at the symmetric steady state $(x_s, x_s)$:\n$$\nJ(x_s, x_s) = \\begin{pmatrix} -1 & -\\frac{\\alpha n x_s^{n-1}}{(1+x_s^n)^2} \\\\ -\\frac{\\alpha n x_s^{n-1}}{(1+x_s^n)^2} & -1 \\end{pmatrix}\n$$\nWe can simplify the off-diagonal terms by substituting $\\alpha = x_s(1 + x_s^n)$:\n$$\n-\\frac{\\alpha n x_s^{n-1}}{(1+x_s^n)^2} = -\\frac{x_s(1+x_s^n) n x_s^{n-1}}{(1+x_s^n)^2} = -\\frac{n x_s^n}{1+x_s^n}\n$$\nLet's define a quantity $S = \\frac{n x_s^n}{1+x_s^n}$. The Jacobian becomes:\n$$\nJ_s = \\begin{pmatrix} -1 & -S \\\\ -S & -1 \\end{pmatrix}\n$$\nThe eigenvalues $\\lambda$ of $J_s$ are found from the characteristic equation $\\det(J_s - \\lambda I) = 0$:\n$$\n(-1-\\lambda)^2 - (-S)^2 = 0 \\implies (1+\\lambda)^2 = S^2\n$$\nThis gives two eigenvalues:\n$$\n\\lambda_1 = -1 - S\n$$\n$$\n\\lambda_2 = -1 + S\n$$\nFor the steady state to be stable, the real parts of both eigenvalues must be negative. Since $\\alpha > 0$ and $n \\geq 0$, $x_s > 0$ and thus $S = \\frac{n x_s^n}{1+x_s^n} \\geq 0$.\nTherefore, $\\lambda_1 = -1 - S \\leq -1$ is always negative.\nThe stability of the symmetric steady state is determined entirely by the sign of $\\lambda_2$. The state is stable if $\\lambda_2 < 0$ and unstable if $\\lambda_2 > 0$. The bifurcation, where stability is lost and bistability can emerge, occurs at $\\lambda_2 = 0$.\n\nFor the symmetric state to be unstable, a condition necessary for bistability, we require $\\lambda_2 > 0$:\n$$\n-1 + S > 0 \\implies S > 1\n$$\nSubstituting the expression for $S$:\n$$\n\\frac{n x_s^n}{1+x_s^n} > 1\n$$\nThis inequality is the condition for instability of the symmetric steady state. The problem asks for the smallest $n$ for which there exists *some* $\\alpha > 0$ that yields bistability. This means we are looking for the smallest $n$ for which the instability condition can be satisfied for some choice of $\\alpha$.\n\nThe value of the steady state $x_s$ depends on $\\alpha$ through the equation $\\alpha = x_s(1+x_s^n)$. Let us consider the function $f(x_s) = x_s(1+x_s^n)$. For $x_s > 0$ and $n \\geq 0$, this function is continuous and strictly increasing, starting from $f(0)=0$ and tending to $\\infty$ as $x_s \\to \\infty$. This means that for any choice of $\\alpha > 0$, there is a unique corresponding $x_s > 0$. Conversely, for any desired value of $x_s > 0$, we can find a corresponding $\\alpha > 0$ that produces it as the symmetric steady state.\n\nTherefore, the question of whether the instability condition $\\frac{n x_s^n}{1+x_s^n} > 1$ can be satisfied for some $\\alpha$ is equivalent to asking whether this inequality can be satisfied for some $x_s > 0$.\nLet's analyze the expression $\\frac{n x_s^n}{1+x_s^n}$. Let $u = x_s^n$. Since $x_s$ can take any value in $(0, \\infty)$, $u$ also ranges over $(0, \\infty)$. The expression becomes a function of $u$ and $n$:\n$$\nG(u) = \\frac{nu}{1+u}\n$$\nWe need to determine for which values of $n$ the range of $G(u)$ for $u \\in (0, \\infty)$ contains values greater than $1$.\nThe function $G(u)$ is monotonically increasing for $u > 0$. Its range is given by the interval $(\\lim_{u\\to 0^+} G(u), \\lim_{u\\to\\infty} G(u))$.\n$$\n\\lim_{u\\to 0^+} G(u) = \\frac{n \\cdot 0}{1+0} = 0\n$$\n$$\n\\lim_{u\\to\\infty} G(u) = \\lim_{u\\to\\infty} \\frac{nu}{u(1/u+1)} = \\lim_{u\\to\\infty} \\frac{n}{1/u+1} = n\n$$\nSo, for a given $n$, the set of all possible values for the quantity $S = \\frac{n x_s^n}{1+x_s^n}$ (by varying $\\alpha$ and thus $x_s$) is the open interval $(0, n)$.\n\nThe condition for instability, $S > 1$, can be satisfied if and only if the interval $(0, n)$ contains values greater than $1$. This is true if and only if the supremum of the interval, $n$, is greater than $1$.\n$$\nn > 1\n$$\nIf $n \\leq 1$, the expression $\\frac{n x_s^n}{1+x_s^n}$ can never be greater than $1$, so the symmetric steady state is always stable, and no bistability occurs. If $n > 1$, we can always find a sufficiently large $\\alpha$ that results in a large enough $x_s$ such that $\\frac{n x_s^n}{1+x_s^n} > 1$, leading to an unstable symmetric state and the emergence of two stable asymmetric states (a standard supercritical pitchfork bifurcation scenario for this system).\n\nThus, the condition on the Hill coefficient for the existence of bistability for some choice of $\\alpha$ is $n>1$. The problem asks for the smallest such Hill coefficient, interpreted as the infimum over real $n$. The set of values of $n$ for which bistability is possible is the interval $(1, \\infty)$. The infimum of this set is $1$.", "answer": "$$\n\\boxed{1}\n$$", "id": "2723594"}, {"introduction": "Predictive models are only as good as their parameters, which must be grounded in experimental reality. This exercise demonstrates a fundamental method for parameter inference: estimating transcription and translation rates from time-course fluorescence data, a common output of cell-free systems or reporter assays [@problem_id:2723649]. By discretizing the underlying ordinary differential equations (ODEs), you will transform a dynamic modeling problem into a linear regression problem, a powerful technique for extracting key kinetic parameters from experimental measurements.", "problem": "You are given bulk transcriptionâ€“translation fluorescence time courses from a cell-free transcriptionâ€“translation (TXâ€“TL) reaction where messenger ribonucleic acid (mRNA) and protein fluorescence are recorded over time. Assume the following fundamental and widely used modeling assumptions grounded in the Central Dogma (deoxyribonucleic acid to ribonucleic acid to protein) and first-order mass-action kinetics:\n\n- The mRNA concentration dynamics satisfy the ordinary differential equation (ODE): $$\\frac{dm}{dt} = k_{\\mathrm{tx}} - \\delta_m m,$$ where $m$ is mRNA concentration in $\\mathrm{nM}$, $k_{\\mathrm{tx}}$ is the transcription rate in $\\mathrm{nM}\\,\\mathrm{min}^{-1}$, and $\\delta_m$ is the mRNA first-order degradation rate in $\\mathrm{min}^{-1}$.\n- The protein concentration dynamics satisfy the ODE: $$\\frac{dp}{dt} = k_{\\mathrm{tl}}\\, m - \\delta_p p,$$ where $p$ is protein concentration in $\\mathrm{nM}$, $k_{\\mathrm{tl}}$ is the translation rate in $\\mathrm{min}^{-1}$, and $\\delta_p$ is the protein first-order degradation/dilution rate in $\\mathrm{min}^{-1}$.\n- The recorded fluorescence signals are linearly related to concentrations via known calibration (gain) and baseline (offset): $$y_m = s_m\\, m + b_m,\\quad y_p = s_p\\, p + b_p,$$ where $y_m$ and $y_p$ are fluorescence in arbitrary units, $s_m$ and $s_p$ are calibration gains in $\\mathrm{au}\\,\\mathrm{nM}^{-1}$, and $b_m$ and $b_p$ are baseline offsets in $\\mathrm{au}$.\n\nUsing only these base assumptions, and discretely sampled time points, estimate the parameters $k_{\\mathrm{tx}}$, $\\delta_m$, $k_{\\mathrm{tl}}$, and $\\delta_p$ by recasting the ODEs into a linear-in-parameters regression using forward-difference approximations of the time derivatives. Specifically, for consecutive time points $t_i$ and $t_{i+1}$, approximate $$\\left.\\frac{dm}{dt}\\right|_{t_i} \\approx \\frac{m_{i+1}-m_i}{t_{i+1}-t_i},\\qquad \\left.\\frac{dp}{dt}\\right|_{t_i} \\approx \\frac{p_{i+1}-p_i}{t_{i+1}-t_i},$$ form the linear systems $$\\frac{m_{i+1}-m_i}{t_{i+1}-t_i} = -\\delta_m\\, m_i + k_{\\mathrm{tx}},\\qquad \\frac{p_{i+1}-p_i}{t_{i+1}-t_i} = k_{\\mathrm{tl}}\\, m_i - \\delta_p\\, p_i,$$ and solve for $k_{\\mathrm{tx}}$, $\\delta_m$, $k_{\\mathrm{tl}}$, and $\\delta_p$ in the least-squares sense over all valid indices $i$.\n\nImportant implementation requirements:\n- Convert fluorescence to concentration using $m_i = (y_{m,i} - b_m)/s_m$ and $p_i = (y_{p,i} - b_p)/s_p$ before computing derivatives.\n- Use forward differences exactly as written above, pairing $\\frac{m_{i+1}-m_i}{t_{i+1}-t_i}$ with the state values $m_i$ and $p_i$ on the left end of each interval.\n- Express all rate parameters in the specified units: $k_{\\mathrm{tx}}$ in $\\mathrm{nM}\\,\\mathrm{min}^{-1}$, $\\delta_m$ in $\\mathrm{min}^{-1}$, $k_{\\mathrm{tl}}$ in $\\mathrm{min}^{-1}$, and $\\delta_p$ in $\\mathrm{min}^{-1}$.\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, with each inner list ordered as $[k_{\\mathrm{tx}}, \\delta_m, k_{\\mathrm{tl}}, \\delta_p]$ for one test case, and all values rounded to six decimal places. The final format must be exactly like $$\\texttt{[[v\\_11,v\\_12,v\\_13,v\\_14],[v\\_21,v\\_22,v\\_23,v\\_24],\\dots]}$$ on a single line, with no spaces.\n\nTest Suite:\nFor each test case below, use the provided time vector, fluorescence traces, and calibration constants.\n\n- Test case $1$:\n  - Times in minutes: $[0, 2, 4, 6, 8, 10, 12]$.\n  - mRNA fluorescence $y_m$ in arbitrary units: $[400, 1600, 2320, 2752, 3011.2, 3166.72, 3260.032]$.\n  - Protein fluorescence $y_p$ in arbitrary units: $[1000, 1000, 1450, 2125, 2894.5, 3684.25, 4453.345]$.\n  - Calibration gains and baselines: $s_m = 120\\,\\mathrm{au}\\,\\mathrm{nM}^{-1}$, $b_m = 400\\,\\mathrm{au}$, $s_p = 15\\,\\mathrm{au}\\,\\mathrm{nM}^{-1}$, $b_p = 1000\\,\\mathrm{au}$.\n- Test case $2$:\n  - Times in minutes: $[0, 2, 4, 6, 8, 10]$.\n  - mRNA fluorescence $y_m$ in arbitrary units: $[100, 900, 1700, 2500, 3300, 4100]$.\n  - Protein fluorescence $y_p$ in arbitrary units: $[500, 500, 628, 858.4, 1170.72, 1548.576]$.\n  - Calibration gains and baselines: $s_m = 200\\,\\mathrm{au}\\,\\mathrm{nM}^{-1}$, $b_m = 100\\,\\mathrm{au}$, $s_p = 20\\,\\mathrm{au}\\,\\mathrm{nM}^{-1}$, $b_p = 500\\,\\mathrm{au}$.\n- Test case $3$:\n  - Times in minutes: $[0, 1, 2, 3, 4, 5, 6, 7]$.\n  - mRNA fluorescence $y_m$ in arbitrary units: $[200, 2000, 2900, 3350, 3575, 3687.5, 3743.75, 3771.875]$.\n  - Protein fluorescence $y_p$ in arbitrary units: $[900, 900, 1188, 1533.6, 1847.52, 2103.264, 2300.2848, 2447.19936]$.\n  - Calibration gains and baselines: $s_m = 150\\,\\mathrm{au}\\,\\mathrm{nM}^{-1}$, $b_m = 200\\,\\mathrm{au}$, $s_p = 12\\,\\mathrm{au}\\,\\mathrm{nM}^{-1}$, $b_p = 900\\,\\mathrm{au}$.\n\nOutput specification:\n- For each test case, estimate $(k_{\\mathrm{tx}}, \\delta_m, k_{\\mathrm{tl}}, \\delta_p)$ using the linear regression approach described.\n- Your program should produce exactly one line of output containing a single list of three inner lists, one per test case, ordered as $[[k_{\\mathrm{tx},1},\\delta_{m,1},k_{\\mathrm{tl},1},\\delta_{p,1}],[k_{\\mathrm{tx},2},\\delta_{m,2},k_{\\mathrm{tl},2},\\delta_{p,2}],[k_{\\mathrm{tx},3},\\delta_{m,3},k_{\\mathrm{tl},3},\\delta_{p,3}]]$ with all numbers rounded to six decimal places and no spaces.", "solution": "The problem is validated as scientifically grounded, well-posed, objective, and complete. It describes a standard and legitimate task in systems biology: the estimation of kinetic parameters from time-series data. The methodology prescribed, while elementary, is a valid application of numerical approximation and linear regression. We proceed with the solution.\n\nThe objective is to estimate the four kinetic parameters of the central dogma model: the transcription rate $k_{\\mathrm{tx}}$, the messenger RNA (mRNA) degradation rate $\\delta_m$, the translation rate $k_{\\mathrm{tl}}$, and the protein degradation rate $\\delta_p$. The estimation is performed using discrete time-series measurements of mRNA and protein fluorescence.\n\nThe system is governed by a pair of linear ordinary differential equations (ODEs):\n$$\n\\frac{dm}{dt} = k_{\\mathrm{tx}} - \\delta_m m(t) \\quad \\text{(1)}\n$$\n$$\n\\frac{dp}{dt} = k_{\\mathrm{tl}}\\, m(t) - \\delta_p p(t) \\quad \\text{(2)}\n$$\nwhere $m(t)$ and $p(t)$ represent the concentrations of mRNA and protein at time $t$, respectively.\n\nThe raw fluorescence data, $y_m$ and $y_p$, are first converted to concentrations, $m$ and $p$, using the provided linear calibration constants:\n$$\nm_i = \\frac{y_{m,i} - b_m}{s_m}\n$$\n$$\np_i = \\frac{y_{p,i} - b_p}{s_p}\n$$\nfor each time point $t_i$.\n\nThe core of the method is to transform the differential equations into algebraic equations suitable for linear regression. This is achieved by approximating the time derivatives using a first-order forward-difference scheme. For a time interval $[t_i, t_{i+1}]$, the derivatives at time $t_i$ are approximated as:\n$$\n\\left.\\frac{dm}{dt}\\right|_{t_i} \\approx \\frac{m_{i+1}-m_i}{t_{i+1}-t_i} \\quad \\text{and} \\quad \\left.\\frac{dp}{dt}\\right|_{t_i} \\approx \\frac{p_{i+1}-p_i}{t_{i+1}-t_i}\n$$\nSubstituting these approximations into equations ($1$) and ($2$) yields two sets of linear equations, one for mRNA dynamics and one for protein dynamics.\n\nFor the mRNA parameters, equation ($1$) becomes:\n$$\n\\frac{m_{i+1}-m_i}{t_{i+1}-t_i} \\approx k_{\\mathrm{tx}} - \\delta_m m_i\n$$\nThis equation is linear in the unknown parameters $k_{\\mathrm{tx}}$ and $\\delta_m$. We can construct a linear system of the form $A_m \\mathbf{x}_m = \\mathbf{b}_m$ by writing one such equation for each measurement interval $i = 0, 1, \\dots, N-2$, where $N$ is the total number of time points. The system components are:\n- The parameter vector $\\mathbf{x}_m = \\begin{bmatrix} k_{\\mathrm{tx}} \\\\ \\delta_m \\end{bmatrix}$.\n- The target vector $\\mathbf{b}_m$, an $(N-1) \\times 1$ column vector with entries $(\\mathbf{b}_m)_i = \\frac{m_{i+1}-m_i}{t_{i+1}-t_i}$.\n- The regressor matrix $A_m$, an $(N-1) \\times 2$ matrix with rows $(A_m)_i = \\begin{bmatrix} 1 & -m_i \\end{bmatrix}$.\n\nSimilarly, for the protein parameters, equation ($2$) becomes:\n$$\n\\frac{p_{i+1}-p_i}{t_{i+1}-t_i} \\approx k_{\\mathrm{tl}} m_i - \\delta_p p_i\n$$\nThis is linear in the parameters $k_{\\mathrm{tl}}$ and $\\delta_p$. A linear system $A_p \\mathbf{x}_p = \\mathbf{b}_p$ is constructed for $i = 0, 1, \\dots, N-2$:\n- The parameter vector $\\mathbf{x}_p = \\begin{bmatrix} k_{\\mathrm{tl}} \\\\ \\delta_p \\end{bmatrix}$.\n- The target vector $\\mathbf{b}_p$, an $(N-1) \\times 1$ column vector with entries $(\\mathbf{b}_p)_i = \\frac{p_{i+1}-p_i}{t_{i+1}-t_i}$.\n- The regressor matrix $A_p$, an $(N-1) \\times 2$ matrix with rows $(A_p)_i = \\begin{bmatrix} m_i & -p_i \\end{bmatrix}$.\n\nThe parameter vectors $\\mathbf{x}_m$ and $\\mathbf{x}_p$ are independently estimated by solving these overdetermined linear systems in the least-squares sense. The least-squares solution $\\hat{\\mathbf{x}}$ minimizes the sum of squared residuals $\\| A\\mathbf{x} - \\mathbf{b} \\|_2^2$ and is given by the solution to the normal equations:\n$$\n\\hat{\\mathbf{x}} = (A^T A)^{-1} A^T \\mathbf{b}\n$$\nThis solution is computed efficiently using standard numerical linear algebra routines. The final estimated parameter set for each test case is the ordered collection $[k_{\\mathrm{tx}}, \\delta_m, k_{\\mathrm{tl}}, \\delta_p]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for genetic circuit parameters using linear regression on\n    discretized ODEs for multiple test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"times\": np.array([0, 2, 4, 6, 8, 10, 12], dtype=float),\n            \"y_m\": np.array([400, 1600, 2320, 2752, 3011.2, 3166.72, 3260.032], dtype=float),\n            \"y_p\": np.array([1000, 1000, 1450, 2125, 2894.5, 3684.25, 4453.345], dtype=float),\n            \"calib\": {\"s_m\": 120.0, \"b_m\": 400.0, \"s_p\": 15.0, \"b_p\": 1000.0}\n        },\n        {\n            \"times\": np.array([0, 2, 4, 6, 8, 10], dtype=float),\n            \"y_m\": np.array([100, 900, 1700, 2500, 3300, 4100], dtype=float),\n            \"y_p\": np.array([500, 500, 628, 858.4, 1170.72, 1548.576], dtype=float),\n            \"calib\": {\"s_m\": 200.0, \"b_m\": 100.0, \"s_p\": 20.0, \"b_p\": 500.0}\n        },\n        {\n            \"times\": np.array([0, 1, 2, 3, 4, 5, 6, 7], dtype=float),\n            \"y_m\": np.array([200, 2000, 2900, 3350, 3575, 3687.5, 3743.75, 3771.875], dtype=float),\n            \"y_p\": np.array([900, 900, 1188, 1533.6, 1847.52, 2103.264, 2300.2848, 2447.19936], dtype=float),\n            \"calib\": {\"s_m\": 150.0, \"b_m\": 200.0, \"s_p\": 12.0, \"b_p\": 900.0}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Extract data for the current case\n        t = case[\"times\"]\n        y_m = case[\"y_m\"]\n        y_p = case[\"y_p\"]\n        s_m, b_m = case[\"calib\"][\"s_m\"], case[\"calib\"][\"b_m\"]\n        s_p, b_p = case[\"calib\"][\"s_p\"], case[\"calib\"][\"b_p\"]\n\n        # 1. Convert fluorescence to concentration\n        m = (y_m - b_m) / s_m\n        p = (y_p - b_p) / s_p\n        \n        # Number of data points\n        N = len(t)\n        if N < 2:\n            continue\n\n        # 2. Calculate time differences for derivative approximation\n        dt = np.diff(t)\n        \n        # 3. Estimate mRNA parameters (k_tx, delta_m)\n        # Approximate dm/dt using forward difference\n        dm_dt_approx = np.diff(m) / dt\n        # Regressors are taken at time t_i\n        m_reg = m[:-1]\n        # Construct the regressor matrix A_m for mRNA\n        A_m = np.vstack([np.ones(N - 1), -m_reg]).T\n        # Solve the linear system A_m * [k_tx, delta_m]^T = dm_dt_approx\n        theta_m, _, _, _ = np.linalg.lstsq(A_m, dm_dt_approx, rcond=None)\n        k_tx, delta_m = theta_m[0], theta_m[1]\n\n        # 4. Estimate protein parameters (k_tl, delta_p)\n        # Approximate dp/dt using forward difference\n        dp_dt_approx = np.diff(p) / dt\n        # Regressors are m_i and p_i\n        p_reg = p[:-1]\n        # Construct the regressor matrix A_p for protein\n        A_p = np.vstack([m_reg, -p_reg]).T\n        # Solve the linear system A_p * [k_tl, delta_p]^T = dp_dt_approx\n        theta_p, _, _, _ = np.linalg.lstsq(A_p, dp_dt_approx, rcond=None)\n        k_tl, delta_p = theta_p[0], theta_p[1]\n\n        all_results.append([k_tx, delta_m, k_tl, delta_p])\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res in all_results:\n        # Format each inner list with 6 decimal places\n        inner_str = \",\".join([f\"{val:.6f}\" for val in res])\n        formatted_results.append(f\"[{inner_str}]\")\n    \n    # Combine all formatted inner lists into the final string\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2723649"}, {"introduction": "As the complexity of genetic circuits grows, manual design becomes intractable, necessitating automated computational tools. This practice simulates a core function of such tools: mapping a desired logic function, in this case, an exclusive OR (XOR) gate, onto a library of characterized genetic components [@problem_id:2723633]. You will frame the design choice as a mixed-integer linear programming (MILP) problem, seeking the combination of gates that minimizes the error between the circuit's output and the target behavior, thereby providing a hands-on introduction to the principles of optimization-based circuit design.", "problem": "You are given a small, fully specified mixed-integer linear programming (MILP) instance that abstracts the mapping of a two-input exclusive OR (XOR) genetic logic function into a layered genetic circuit using a discrete library of threshold gates. The problem is framed using the central dogma of molecular biology (DNA to RNA to protein) and a digital-threshold approximation of gene regulation, which is a widely used abstraction in computational tools for genetic circuit design. The model assumes that each genetic gate can be represented by a single-input, single-output device with two possible output levels and a threshold that determines whether the output is at a high or low level based on its input concentration.\n\nStart from the following foundational base:\n- The central dogma of molecular biology ensures that gene expression is mediated by transcription and translation, and promoters can be activated or repressed by transcription factors in a monotone way.\n- In the digital abstraction, a genetic gate is modeled as a threshold device: for an activator, output switches from low to high as input concentration exceeds a threshold; for a repressor, output switches from high to low as input exceeds a threshold.\n- A feedforward layered genetic circuit is constructed by composing such gates, and its behavior on a fixed truth table can be compared to a desired digital function using a linear error metric.\n\nArchitecture and modeling assumptions:\n- Two inputs, denoted by $A$ and $B$, take on two concentration levels each: a low level $x_\\text{low} = 1\\,\\text{nM}$ and a high level $x_\\text{high} = 50\\,\\text{nM}$.\n- A layered circuit with three nodes is used:\n  - Node $1$ receives input $A$ through a selectable gate from a library.\n  - Node $2$ receives input $B$ through a selectable gate from a library.\n  - Node $3$ receives as input the sum $z = y_1 + y_2$ of the outputs (in arbitrary units (AU)) from nodes $1$ and $2$, and itself is a selectable gate from a library.\n- Each gate is either an activator or a repressor with a fixed threshold and fixed low/high output levels:\n  - For an activator with threshold $\\theta$ (in the same units as its input) and output levels $L$ and $H$ (in AU), the output $y$ is $H$ if the input $x \\ge \\theta$, and $L$ otherwise.\n  - For a repressor with threshold $\\theta$ and output levels $L$ and $H$, the output $y$ is $H$ if the input $x \\le \\theta$, and $L$ otherwise.\n- Desired XOR output levels are specified in AU: for $A,B \\in \\{0,1\\}$ denoting low/high concentrations, the desired output $y^\\text{true}$ is $0$ AU for $(A,B) \\in \\{(0,0),(1,1)\\}$ and $Y_\\text{true}$ AU for $(A,B) \\in \\{(0,1),(1,0)\\}$.\n\nMILP decision variables and constraints:\n- Let the set of input cases be $c \\in \\{0,1,2,3\\}$ corresponding to $(A,B) \\in \\{(0,0),(0,1),(1,0),(1,1)\\}$.\n- Define binary selection variables $t_m \\in \\{0,1\\}$ for $m \\in \\{1,\\dots,8\\}$, where each $m$ encodes one of the eight combinations of gate choices for nodes $1$, $2$, and $3$ (two options per node). Exactly one combination must be selected:\n  $$\\sum_{m=1}^{8} t_m = 1.$$\n- For each $m$ and each case $c$, the output $y^{(m)}_{3,c}$ is a constant obtained by deterministically applying the threshold rules to compute node $1$ and node $2$ outputs from the input concentrations and then node $3$ output from their sum $z$; this is explained below and is part of the provided data.\n- For each case $c$, the actual output of the selected circuit is\n  $$y_{3,c} = \\sum_{m=1}^{8} t_m \\, y^{(m)}_{3,c}.$$\n- Introduce nonnegative error variables $e_c \\ge 0$ and enforce the absolute deviation from the desired output via linear inequalities:\n  $$e_c \\ge y_{3,c} - y^\\text{true}_c,\\quad e_c \\ge -(y_{3,c} - y^\\text{true}_c).$$\n- The objective is to minimize the sum of absolute deviations across all four input cases:\n  $$\\min \\sum_{c=0}^{3} e_c.$$\n- The final objective value should be reported in arbitrary units (AU) as a floating-point number.\n\nGate library and test suite:\n- Inputs in nM: $x_\\text{low} = 1$, $x_\\text{high} = 50$.\n- Node $1$ library (choose one):\n  - $G_{1A}$: activator with $\\theta = 10$ nM, $L = 5$ AU, $H = 110$ AU.\n  - $G_{1R}$: repressor with $\\theta = 10$ nM, $L = 5$ AU, $H = 110$ AU.\n- Node $2$ library (choose one):\n  - $G_{2A}$: activator with $\\theta = 20$ nM, $L = 2$ AU, $H = 90$ AU.\n  - $G_{2R}$: repressor with $\\theta = 20$ nM, $L = 2$ AU, $H = 90$ AU.\n- Node $3$ library (choose one per instance):\n  - $G_{3A}$: activator with threshold $\\Theta$ AU, $L = 0$ AU, $H = H_3$ AU.\n  - $G_{3R}$: repressor with threshold $\\Theta$ AU, $L = 0$ AU, $H = H_3$ AU.\n- Desired XOR levels: $Y_\\text{true} = 100$ AU, so $y^\\text{true}_c \\in \\{0, 100\\}$ by the XOR truth table.\n\nYour program must solve the MILP exactly for each of the following three independent instances (parameterizations of node $3$) and report the optimal objective value for each:\n- Instance $1$: $\\Theta = 80$ AU, $H_3 = 120$ AU.\n- Instance $2$: $\\Theta = 130$ AU, $H_3 = 120$ AU.\n- Instance $3$: $\\Theta = 80$ AU, $H_3 = 100$ AU.\n\nImportant details:\n- For each instance, you may precompute all constants $y^{(m)}_{3,c}$ by exhaustively evaluating the eight gate combinations and four input cases. Because this is a small instance, an exact enumeration over the binary selection space is acceptable and equivalent to solving the MILP.\n- Scientific realism: thresholds and output levels are chosen to be monotone and saturating, consistent with well-studied digital abstractions of genetic devices.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of the three optimal objective values (in AU) enclosed in square brackets, for example, \"[x1,x2,x3]\".\n- All three values must be floating-point numbers printed in AU with no units in the text output.\n\nTest suite coverage rationale:\n- Instance $1$ is a typical \"happy path\" case with a moderate final threshold and higher-than-desired high output, testing tradeoffs between false highs and true highs that overshoot the desired level.\n- Instance $2$ is a boundary-shift case with a high final threshold that flips the classification of intermediate sums, testing sensitivity to $\\Theta$.\n- Instance $3$ aligns the final high output with the desired high level, testing whether output scaling reduces the optimal deviation.", "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, and objective. It presents a solvable optimization problem rooted in the digital abstraction of genetic circuits, a common approach in computational synthetic biology. The task is to determine the minimum possible error in implementing a two-input exclusive OR (XOR) function using a predefined library of genetic gates. This is framed as a small mixed-integer linear program (MILP), which, due to its limited size, can be solved by exhaustive enumeration of all possible circuit configurations.\n\nThe problem specifies a feedforward circuit with two inputs, $A$ and $B$, which take concentration levels of $x_\\text{low} = 1\\,\\text{nM}$ and $x_\\text{high} = 50\\,\\text{nM}$. The circuit has three nodes. Node $1$ processes input $A$ to produce output $y_1$, and Node $2$ processes input $B$ to produce output $y_2$. The input to Node $3$ is the sum $z = y_1 + y_2$, and its output, $y_3$, is the final output of the circuit.\n\nThe behavior of each gate is defined by a threshold model. For an activator with input $x$, threshold $\\theta$, low output $L$, and high output $H$, the output is $H$ if $x \\ge \\theta$ and $L$ otherwise. For a repressor, the output is $H$ if $x \\le \\theta$ and $L$ otherwise. The desired XOR logic corresponds to a target output vector across the four input cases $c \\in \\{0, 1, 2, 3\\}$, which represent $(A,B)$ input pairs of (low, low), (low, high), (high, low), and (high, high), respectively. The target output vector is $y^\\text{true} = [0, 100, 100, 0]$ in arbitrary units (AU).\n\nThe solution strategy involves iterating through all $2 \\times 2 \\times 2 = 8$ possible combinations of gates for the three nodes. For each combination, we calculate the total absolute error, $E = \\sum_{c=0}^{3} |y_{3,c} - y^\\text{true}_c|$, where $y_{3,c}$ is the circuit's output for input case $c$. The minimum error over all $8$ combinations is the solution for a given set of Node $3$ parameters.\n\nFirst, we pre-calculate the outputs of Node $1$ ($y_1$) and Node $2$ ($y_2$) for the available gates and input levels.\n\nNode $1$ Gate Library:\n- $G_{1A}$ (Activator): $\\theta_1 = 10\\,\\text{nM}$, $L_1 = 5\\,\\text{AU}$, $H_1 = 110\\,\\text{AU}$.\n  - For $x_A = x_\\text{low} = 1\\,\\text{nM} < 10\\,\\text{nM}$, $y_1 = 5\\,\\text{AU}$.\n  - For $x_A = x_\\text{high} = 50\\,\\text{nM} \\ge 10\\,\\text{nM}$, $y_1 = 110\\,\\text{AU}$.\n- $G_{1R}$ (Repressor): $\\theta_1 = 10\\,\\text{nM}$, $L_1 = 5\\,\\text{AU}$, $H_1 = 110\\,\\text{AU}$.\n  - For $x_A = x_\\text{low} = 1\\,\\text{nM} \\le 10\\,\\text{nM}$, $y_1 = 110\\,\\text{AU}$.\n  - For $x_A = x_\\text{high} = 50\\,\\text{nM} > 10\\,\\text{nM}$, $y_1 = 5\\,\\text{AU}$.\n\nNode $2$ Gate Library:\n- $G_{2A}$ (Activator): $\\theta_2 = 20\\,\\text{nM}$, $L_2 = 2\\,\\text{AU}$, $H_2 = 90\\,\\text{AU}$.\n  - For $x_B = x_\\text{low} = 1\\,\\text{nM} < 20\\,\\text{nM}$, $y_2 = 2\\,\\text{AU}$.\n  - For $x_B = x_\\text{high} = 50\\,\\text{nM} \\ge 20\\,\\text{nM}$, $y_2 = 90\\,\\text{AU}$.\n- $G_{2R}$ (Repressor): $\\theta_2 = 20\\,\\text{nM}$, $L_2 = 2\\,\\text{AU}$, $H_2 = 90\\,\\text{AU}$.\n  - For $x_B = x_\\text{low} = 1\\,\\text{nM} \\le 20\\,\\text{nM}$, $y_2 = 90\\,\\text{AU}$.\n  - For $x_B = x_\\text{high} = 50\\,\\text{nM} > 20\\,\\text{nM}$, $y_2 = 2\\,\\text{AU}$.\n\nFrom these, we can compute the Node $3$ input, $z = y_1 + y_2$, for the four combinations of first-layer gates across the four input cases:\n- Case $0$: $(x_A, x_B) = (1, 1)\\,\\text{nM}$\n- Case $1$: $(x_A, x_B) = (1, 50)\\,\\text{nM}$\n- Case $2$: $(x_A, x_B) = (50, 1)\\,\\text{nM}$\n- Case $3$: $(x_A, x_B) = (50, 50)\\,\\text{nM}$\n\nThe values of $z$ (in AU) are tabulated below:\n| Gate Combination (Node 1, Node 2) | Case $0$ (L,L) | Case $1$ (L,H) | Case $2$ (H,L) | Case $3$ (H,H) |\n|---|---|---|---|---|\n| $(G_{1A}, G_{2A})$ | $7$ | $95$ | $112$ | $200$ |\n| $(G_{1A}, G_{2R})$ | $95$ | $7$ | $200$ | $112$ |\n| $(G_{1R}, G_{2A})$ | $112$ | $200$ | $7$ | $95$ |\n| $(G_{1R}, G_{2R})$ | $200$ | $112$ | $95$ | $7$ |\n\nWe now solve the problem for each of the three specified instances by evaluating the $8$ total gate configurations.\n\nInstance $1$: $\\Theta = 80\\,\\text{AU}$, $H_3 = 120\\,\\text{AU}$.\nNode $3$ gates have $L_3 = 0\\,\\text{AU}$.\n- $G_{3A}$: Output is $120$ if $z \\ge 80$, else $0$.\n- $G_{3R}$: Output is $120$ if $z \\le 80$, else $0$.\nBy enumerating all $8$ configurations, we find the minimum total error is $120\\,\\text{AU}$. This is achieved by two configurations. For example, the configuration $(G_{1A}, G_{2R}, G_{3R})$:\n- The vector of intermediate sums is $z = [95, 7, 200, 112]$.\n- Applying the $G_{3R}$ rule ($z \\le 80 \\to 120$):\n  - Case $0$ ($z=95$): $y_3=0$. Error: $|0-0|=0$.\n  - Case $1$ ($z=7$): $y_3=120$. Error: $|120-100|=20$.\n  - Case $2$ ($z=200$): $y_3=0$. Error: $|0-100|=100$.\n  - Case $3$ ($z=112$): $y_3=0$. Error: $|0-0|=0$.\n- The total error is $0 + 20 + 100 + 0 = 120\\,\\text{AU}$.\n\nInstance $2$: $\\Theta = 130\\,\\text{AU}$, $H_3 = 120\\,\\text{AU}$.\nNode $3$ gates have $L_3 = 0\\,\\text{AU}$.\n- $G_{3A}$: Output is $120$ if $z \\ge 130$, else $0$.\n- $G_{3R}$: Output is $120$ if $z \\le 130$, else $0$.\nEnumerating all $8$ configurations reveals a minimum total error of $120\\,\\text{AU}$. This value is achieved by two configurations. For example, the configuration $(G_{1A}, G_{2R}, G_{3A})$:\n- The vector of intermediate sums is $z = [95, 7, 200, 112]$.\n- Applying the $G_{3A}$ rule ($z \\ge 130 \\to 120$):\n  - Case $0$ ($z=95$): $y_3=0$. Error: $|0-0|=0$.\n  - Case $1$ ($z=7$): $y_3=0$. Error: $|0-100|=100$.\n  - Case $2$ ($z=200$): $y_3=120$. Error: $|120-100|=20$.\n  - Case $3$ ($z=112$): $y_3=0$. Error: $|0-0|=0$.\n- The total error is $0 + 100 + 20 + 0 = 120\\,\\text{AU}$.\n\nInstance $3$: $\\Theta = 80\\,\\text{AU}$, $H_3 = 100\\,\\text{AU}$.\nHere, the high output of Node $3$ matches the desired high output for XOR ($100\\,\\text{AU}$). The threshold is the same as in Instance $1$.\n- $G_{3A}$: Output is $100$ if $z \\ge 80$, else $0$.\n- $G_{3R}$: Output is $100$ if $z \\le 80$, else $0$.\nThe minimum total error is found to be $100\\,\\text{AU}$. This is achieved by four configurations. For example, the configuration $(G_{1R}, G_{2A}, G_{3R})$:\n- The vector of intermediate sums is $z = [112, 200, 7, 95]$.\n- Applying the $G_{3R}$ rule ($z \\le 80 \\to 100$):\n  - Case $0$ ($z=112$): $y_3=0$. Error: $|0-0|=0$.\n  - Case $1$ ($z=200$): $y_3=0$. Error: $|0-100|=100$.\n  - Case $2$ ($z=7$): $y_3=100$. Error: $|100-100|=0$.\n  - Case $3$ ($z=95$): $y_3=0$. Error: $|0-0|=0$.\n- The total error is $0 + 100 + 0 + 0 = 100\\,\\text{AU}$.\n\nThe optimal objective values for the three instances are therefore $120.0$, $120.0$, and $100.0$ AU, respectively.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum error of a genetic XOR gate for three different\n    parameterizations of the final stage.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains (Theta_3, H_3) for Node 3.\n    test_cases = [\n        (80.0, 120.0),  # Instance 1\n        (130.0, 120.0), # Instance 2\n        (80.0, 100.0),  # Instance 3\n    ]\n\n    results = []\n    for case in test_cases:\n        Theta_3, H_3 = case\n        min_error = calculate_min_error_for_instance(Theta_3, H_3)\n        results.append(min_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_min_error_for_instance(Theta_3, H_3):\n    \"\"\"\n    Calculates the minimum total error for a single instance of Node 3 parameters\n    by enumerating all 8 possible gate combinations.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    x_low = 1.0\n    x_high = 50.0\n    y_true = np.array([0.0, 100.0, 100.0, 0.0])\n\n    # Input cases (A, B) corresponding to (low, low), (low, high), etc.\n    input_concentrations = [\n        (x_low, x_low),\n        (x_low, x_high),\n        (x_high, x_low),\n        (x_high, x_high)\n    ]\n    \n    # Gate library definitions as dictionaries\n    g1a = {'type': 'activator', 'theta': 10.0, 'L': 5.0, 'H': 110.0}\n    g1r = {'type': 'repressor', 'theta': 10.0, 'L': 5.0, 'H': 110.0}\n    g2a = {'type': 'activator', 'theta': 20.0, 'L': 2.0, 'H': 90.0}\n    g2r = {'type': 'repressor', 'theta': 20.0, 'L': 2.0, 'H': 90.0}\n    g3a = {'type': 'activator', 'theta': Theta_3, 'L': 0.0, 'H': H_3}\n    g3r = {'type': 'repressor', 'theta': Theta_3, 'L': 0.0, 'H': H_3}\n\n    # List of all possible gate choices for each node\n    node_gate_choices = [\n        [g1a, g1r],\n        [g2a, g2r],\n        [g3a, g3r]\n    ]\n    \n    def gate_output(x, params):\n        \"\"\"Calculates the output of a single genetic gate.\"\"\"\n        if params['type'] == 'activator':\n            return params['H'] if x >= params['theta'] else params['L']\n        elif params['type'] == 'repressor':\n            return params['H'] if x <= params['theta'] else params['L']\n        # This case should not be reached with valid parameters\n        return 0.0\n\n    min_total_error = float('inf')\n\n    # Exhaustively enumerate all 8 gate combinations (2x2x2)\n    for g1_params in node_gate_choices[0]:\n        for g2_params in node_gate_choices[1]:\n            for g3_params in node_gate_choices[2]:\n                \n                y3_outputs = np.zeros(4)\n                \n                # Evaluate the circuit for all 4 input cases\n                for c, (x_A, x_B) in enumerate(input_concentrations):\n                    # Layer 1 outputs\n                    y1 = gate_output(x_A, g1_params)\n                    y2 = gate_output(x_B, g2_params)\n                    \n                    # Layer 2 input\n                    z = y1 + y2\n                    \n                    # Layer 2 output (final circuit output)\n                    y3 = gate_output(z, g3_params)\n                    y3_outputs[c] = y3\n\n                # Calculate the sum of absolute deviations (total error)\n                total_error = np.sum(np.abs(y3_outputs - y_true))\n                \n                # Update the minimum error found\n                if total_error < min_total_error:\n                    min_total_error = total_error\n\n    return min_total_error\n\nsolve()\n```", "id": "2723633"}]}