{"hands_on_practices": [{"introduction": "Understanding the metabolic trade-offs within a microbial community is a cornerstone of consortium design. This first practice challenges you to model a fundamental interaction—cross-feeding—using a joint Flux Balance Analysis (FBA) framework. By formulating and solving a linear program to find Pareto-optimal growth states, you will gain hands-on experience in quantifying the cooperative and competitive dynamics that arise from shared resource pools. `[@problem_id:2728301]`", "problem": "You are tasked with constructing and solving a joint Flux Balance Analysis (FBA) optimization for a minimal two-organism synthetic consortium that exchanges one cross-feeding metabolite. The goal is to compute Pareto-optimal operating points by maximizing a weighted sum of organismal growth rates for specified weights. Your implementation must encode the linear optimization problem from first principles and solve it for a given test suite.\n\nModeling assumptions and fundamental base:\n- Adopt steady-state metabolic balances as in FBA: the internal metabolite accumulation is zero, which implies the linear constraints $S v = 0$ for a suitable stoichiometric matrix $S$ and flux vector $v$.\n- Each reaction flux is bounded by linear upper and lower bounds.\n- The joint objective is a weighted sum of the two growth rates. A solution that maximizes a weighted sum over different weights is Pareto optimal under convexity of the feasible set.\n\nConsortium description:\n- Organism A imports a shared external substrate $G$ (glucose) from a well-mixed medium, partitions it between biomass production and secretion of a cross-feeding metabolite $X$.\n- Organism B imports $G$ directly or imports $X$ produced by A, and converts either into biomass.\n- Both organisms satisfy internal steady-state balances.\n- Exchange of $G$ is constrained by a shared upper bound across both organisms.\n- Exchange of $X$ is constrained by a shared steady-state equality and an upper bound on the exchange capacity.\n\nDecision variables (all are nonnegative fluxes):\n- $v_{\\mathrm{A,inG}}$: A’s import of $G$.\n- $\\mu_{\\mathrm{A}}$: A’s biomass production rate (growth rate, to be expressed in $h^{-1}$).\n- $v_{\\mathrm{A,prodX}}$: A’s production of $X$ from internalized $G$.\n- $v_{\\mathrm{A,outX}}$: A’s export of $X$ to the medium.\n- $v_{\\mathrm{B,inG}}$: B’s import of $G$.\n- $v_{\\mathrm{B,inX}}$: B’s import of $X$ from the medium.\n- $\\mu_{\\mathrm{B,G}}$: B’s biomass production rate from $G$.\n- $\\mu_{\\mathrm{B,X}}$: B’s biomass production rate from $X$.\n\nSteady-state and exchange constraints:\n- A’s internal $G$ balance: $v_{\\mathrm{A,inG}} - c_{\\mathrm{A,bio}} \\, \\mu_{\\mathrm{A}} - c_{\\mathrm{A,X}} \\, v_{\\mathrm{A,prodX}} = 0$.\n- A’s internal $X$ balance: $v_{\\mathrm{A,prodX}} - v_{\\mathrm{A,outX}} = 0$.\n- B’s internal $G$ balance: $v_{\\mathrm{B,inG}} - \\mu_{\\mathrm{B,G}} = 0$.\n- B’s internal $X$ balance: $v_{\\mathrm{B,inX}} - \\mu_{\\mathrm{B,X}} = 0$.\n- External $X$ steady-state: $v_{\\mathrm{A,outX}} - v_{\\mathrm{B,inX}} = 0$.\n- Shared $G$ capacity: $v_{\\mathrm{A,inG}} + v_{\\mathrm{B,inG}} \\le G_{\\max}$.\n\nFlux bounds:\n- $0 \\le v_{\\mathrm{A,inG}} \\le A_{G,\\max}$, $0 \\le v_{\\mathrm{B,inG}} \\le B_{G,\\max}$, $0 \\le v_{\\mathrm{A,outX}} \\le X_{\\max}$, $0 \\le v_{\\mathrm{B,inX}} \\le X_{\\max}$.\n- $0 \\le \\mu_{\\mathrm{A}}$, $0 \\le v_{\\mathrm{A,prodX}}$, $0 \\le \\mu_{\\mathrm{B,G}}$, $0 \\le \\mu_{\\mathrm{B,X}}$.\n- Use the constants $c_{\\mathrm{A,bio}} = 1.2$, $c_{\\mathrm{A,X}} = 1.0$, which encode that A requires $1.2$ units of internalized $G$ per unit biomass and $1.0$ unit of internalized $G$ per unit of $X$ produced. For B, one unit of $G$ or $X$ yields one unit of biomass as enforced by the balances above.\n\nObjective:\n- For a given weight $w \\in [0,1]$, maximize the weighted sum $w \\, \\mu_{\\mathrm{A}} + (1 - w) \\, \\mu_{\\mathrm{B}}$, where $\\mu_{\\mathrm{B}} = \\mu_{\\mathrm{B,G}} + \\mu_{\\mathrm{B,X}}$.\n\nFixed parameters for all test cases unless otherwise specified:\n- $A_{G,\\max} = 10$.\n- $B_{G,\\max} = 3$.\n- $c_{\\mathrm{A,bio}} = 1.2$.\n- $c_{\\mathrm{A,X}} = 1.0$.\n\nAngle units do not apply. Physical units: report growth rates in $h^{-1}$ as floating-point numbers.\n\nTest suite:\nEach test case is a triple $(w, G_{\\max}, X_{\\max})$. For each case, compute and output the pair $[\\mu_{\\mathrm{A}}, \\mu_{\\mathrm{B}}]$, where $\\mu_{\\mathrm{B}} = \\mu_{\\mathrm{B,G}} + \\mu_{\\mathrm{B,X}}$, both rounded to $6$ decimal places, and interpreted in $h^{-1}$.\n\n- Case $1$: $(w, G_{\\max}, X_{\\max}) = (0.25, 10, 7)$.\n- Case $2$: $(w, G_{\\max}, X_{\\max}) = (1.0, 10, 10)$.\n- Case $3$: $(w, G_{\\max}, X_{\\max}) = (0.0, 10, 10)$.\n- Case $4$: $(w, G_{\\max}, X_{\\max}) = (0.7, 10, 10)$.\n- Case $5$: $(w, G_{\\max}, X_{\\max}) = (0.6, 5, 10)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list $[\\mu_{\\mathrm{A}}, \\mu_{\\mathrm{B}}]$ corresponding to the test cases above, in order. For example: `[[x_1,y_1],[x_2,y_2],...]`. There must be no spaces anywhere in the output. All reported growth rates must be rounded to $6$ decimal places and are to be interpreted in $h^{-1}$.", "solution": "The problem as stated is valid. It presents a well-posed optimization problem grounded in the established principles of Flux Balance Analysis (FBA) for metabolic networks. The problem is self-contained, with all necessary parameters, variables, and constraints clearly defined, permitting a rigorous mathematical formulation without ambiguity. The objective is to find Pareto-optimal states of a synthetic microbial consortium, which is a standard and meaningful goal in systems and synthetic biology. The problem is structured as a Linear Program (LP), for which a unique optimal value is guaranteed to exist.\n\nThe core of the task is to construct and solve this LP. The system involves two organisms, A and B, and two metabolites, a primary substrate $G$ and a cross-fed intermediate $X$. The state of the system is described by a set of $8$ non-negative fluxes: $v_{\\mathrm{A,inG}}$, $\\mu_{\\mathrm{A}}$, $v_{\\mathrm{A,prodX}}$, $v_{\\mathrm{A,outX}}$, $v_{\\mathrm{B,inG}}$, $v_{\\mathrm{B,inX}}$, $\\mu_{\\mathrm{B,G}}$, and $\\mu_{\\mathrm{B,X}}$.\n\nFirst, we simplify the system by resolving the equality constraints. The problem statement provides five linear equality constraints representing steady-state mass balances:\n$1$. $v_{\\mathrm{A,inG}} - c_{\\mathrm{A,bio}} \\, \\mu_{\\mathrm{A}} - c_{\\mathrm{A,X}} \\, v_{\\mathrm{A,prodX}} = 0$\n$2$. $v_{\\mathrm{A,prodX}} - v_{\\mathrm{A,outX}} = 0$\n$3$. $v_{\\mathrm{B,inG}} - \\mu_{\\mathrm{B,G}} = 0$\n$4$. $v_{\\mathrm{B,inX}} - \\mu_{\\mathrm{B,X}} = 0$\n$5$. $v_{\\mathrm{A,outX}} - v_{\\mathrm{B,inX}} = 0$\n\nFrom constraints $2$, $4$, and $5$, we deduce that the flux of metabolite $X$ from production in A to consumption in B is a single, unified channel:\n$$v_{X} \\equiv v_{\\mathrm{A,prodX}} = v_{\\mathrm{A,outX}} = v_{\\mathrm{B,inX}} = \\mu_{\\mathrm{B,X}}$$\nFrom constraint $3$, the biomass production of organism B from substrate $G$ is equal to its import flux of $G$:\n$$\\mu_{\\mathrm{B,G}} = v_{\\mathrm{B,inG}}$$\nUsing these relationships, we can eliminate most of the variables. We select a minimal set of three independent decision variables:\n- $\\mu_{\\mathrm{A}}$: The growth rate of organism A.\n- $\\mu_{\\mathrm{B,G}}$: The component of organism B's growth rate derived from substrate $G$.\n- $v_{X}$: The flux of the cross-fed metabolite $X$, which is also equal to the component of organism B's growth rate derived from $X$, $\\mu_{\\mathrm{B,X}}$.\n\nAll other flux variables can now be expressed in terms of this new basis:\n- $v_{\\mathrm{A,inG}} = c_{\\mathrm{A,bio}} \\, \\mu_{\\mathrm{A}} + c_{\\mathrm{A,X}} \\, v_{X} = 1.2 \\, \\mu_{\\mathrm{A}} + 1.0 \\, v_{X}$\n- $v_{\\mathrm{B,inG}} = \\mu_{\\mathrm{B,G}}$\n- $\\mu_{\\mathrm{B}} = \\mu_{\\mathrm{B,G}} + \\mu_{\\mathrm{B,X}} = \\mu_{\\mathrm{B,G}} + v_{X}$\n\nThe problem is now formulated as a Linear Program with these three variables. The objective is to maximize the weighted sum of growth rates:\n$$\\text{Maximize} \\quad J = w \\, \\mu_{\\mathrm{A}} + (1 - w) \\, \\mu_{\\mathrm{B}} = w \\, \\mu_{\\mathrm{A}} + (1 - w) (\\mu_{\\mathrm{B,G}} + v_{X})$$\nsubject to a set of linear inequality constraints arising from the flux bounds and shared resource limits. All variables must be non-negative: $\\mu_{\\mathrm{A}} \\ge 0$, $\\mu_{\\mathrm{B,G}} \\ge 0$, $v_{X} \\ge 0$.\n\nThe inequality constraints are:\n$1$. A's glucose import limit: $v_{\\mathrm{A,inG}} \\le A_{G,\\max} \\implies 1.2\\,\\mu_{\\mathrm{A}} + v_{X} \\le 10$\n$2$. B's glucose import limit: $v_{\\mathrm{B,inG}} \\le B_{G,\\max} \\implies \\mu_{\\mathrm{B,G}} \\le 3$\n$3$. Metabolite $X$ exchange limit: $v_{X} \\le X_{\\max}$\n$4$. Shared glucose availability: $v_{\\mathrm{A,inG}} + v_{\\mathrm{B,inG}} \\le G_{\\max} \\implies 1.2\\,\\mu_{\\mathrm{A}} + v_{X} + \\mu_{\\mathrm{B,G}} \\le G_{\\max}$\n\nThis constitutes a standard LP problem of the form: maximize $c^T x$ subject to $A_{ub} x \\le b_{ub}$ and $x \\ge 0$. Here, the decision variable vector is $x = [\\mu_{\\mathrm{A}}, \\mu_{\\mathrm{B,G}}, v_{X}]^T$. The objective vector is $c = [w, 1-w, 1-w]^T$. The constraint matrix $A_{ub}$ and vector $b_{ub}$ are:\n$$\nA_{ub} = \\begin{pmatrix} 1.2 & 0 & 1.0 \\\\ 0 & 1.0 & 0 \\\\ 0 & 0 & 1.0 \\\\ 1.2 & 1.0 & 1.0 \\end{pmatrix}, \\quad\nb_{ub} = \\begin{pmatrix} 10 \\\\ 3 \\\\ X_{\\max} \\\\ G_{\\max} \\end{pmatrix}\n$$\nThe scientific libraries in Python, specifically `scipy.optimize.linprog`, are designed to solve minimization problems. Therefore, we solve the equivalent problem of minimizing $-J$:\n$$\\text{Minimize} \\quad -J = -w \\, \\mu_{\\mathrm{A}} - (1 - w) (\\mu_{\\mathrm{B,G}} + v_{X})$$\nThe cost vector for the solver is $c_{min} = [-w, -(1-w), -(1-w)]^T$.\n\nA deeper analysis reveals a critical weight, $w_{crit}$, that dictates the qualitative behavior of the consortium. The metabolic trade-off between the growth of A and B is governed by their respective efficiencies in converting the shared substrate $G$ into biomass. For organism B, $1$ unit of $G$ generates $1$ unit of biomass (either as $\\mu_{\\mathrm{B,G}}$ or via $v_X$ which becomes $\\mu_{\\mathrm{B,X}}$). For organism A, $1$ unit of $G$ generates $1/c_{\\mathrm{A,bio}} = 1/1.2$ units of biomass. The change in the objective function $dJ$ for a differential trade-off between $\\mu_{\\mathrm{A}}$ and $\\mu_{\\mathrm{B}}$ is $dJ = (1-w - w/c_{\\mathrm{A,bio}})d\\mu_{\\mathrm{B}}$. The consortium will favor B's growth if the coefficient is positive, which occurs when $1-w > w/c_{\\mathrm{A,bio}}$, simplifying to $w < c_{\\mathrm{A,bio}} / (1+c_{\\mathrm{A,bio}})$.\nWith $c_{\\mathrm{A,bio}}=1.2$, the critical weight is $w_{crit} = 1.2 / 2.2 = 6/11 \\approx 0.545$.\n- If $w > w_{crit}$, the system maximizes A's growth, setting $\\mu_{\\mathrm{B}}=0$.\n- If $w < w_{crit}$, the system maximizes B's growth by allocating resources to $\\mu_{\\mathrm{B,G}}$ and $v_X$ up to their applicable limits.\nThis analytical insight confirms the solutions found by the LP solver for the given test cases. The implementation will proceed by constructing and solving the LP for each set of parameters in the test suite.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of joint flux balance analysis problems for a synthetic microbial consortium.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (w, G_max, X_max).\n    test_cases = [\n        (0.25, 10, 7),\n        (1.0, 10, 10),\n        (0.0, 10, 10),\n        (0.7, 10, 10),\n        (0.6, 5, 10),\n    ]\n\n    # Fixed parameters for all test cases\n    A_G_max = 10.0\n    B_G_max = 3.0\n    c_A_bio = 1.2\n    c_A_X = 1.0\n\n    results = []\n\n    # The problem is formulated as a Linear Program (LP).\n    # Decision variables x = [mu_A, mu_B,G, v_X]\n    # where mu_A is A's growth rate, mu_B,G is B's growth from substrate G,\n    # and v_X is the cross-feeding flux, equal to B's growth from metabolite X.\n\n    # Constraints: A_ub * x <= b_ub\n    # 1. v_A,inG <= A_G,max  => c_A_bio*mu_A + c_A_X*v_X <= A_G_max\n    # 2. v_B,inG <= B_G,max  => mu_B,G <= B_G_max\n    # 3. v_X <= X_max\n    # 4. v_A,inG + v_B,inG <= G_max => c_A_bio*mu_A + mu_B,G + c_A_X*v_X <= G_max\n    \n    A_ub = np.array([\n        [c_A_bio, 0.0,     c_A_X],\n        [0.0,     1.0,     0.0  ],\n        [0.0,     0.0,     1.0  ],\n        [c_A_bio, 1.0,     c_A_X]\n    ])\n    \n    for w, G_max, X_max in test_cases:\n        # Objective function to maximize: w*mu_A + (1-w)*(mu_B,G + v_X)\n        # scipy.optimize.linprog minimizes, so we minimize the negative of the objective.\n        c = np.array([-w, -(1 - w), -(1 - w)])\n\n        # Right-hand side of the inequality constraints\n        b_ub = np.array([A_G_max, B_G_max, X_max, G_max])\n        \n        # All variables are non-negative, which is the default for linprog.\n        # So bounds are (0, None) for all variables.\n        \n        # Solve the LP problem\n        res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, method='highs')\n\n        if res.success:\n            mu_A_opt = res.x[0]\n            mu_BG_opt = res.x[1]\n            v_X_opt = res.x[2]\n            \n            # Total growth rate of organism B\n            mu_B_opt = mu_BG_opt + v_X_opt\n            \n            # Append the formatted result\n            results.append(f\"[{mu_A_opt:.6f},{mu_B_opt:.6f}]\")\n        else:\n            # This should not happen for this well-posed problem\n            results.append(\"[error,error]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2728301"}, {"introduction": "Effective consortium design often requires balancing individual organism fitness with a community-level objective. This practice introduces a powerful conceptual tool, bilevel optimization, to formally model this hierarchical decision-making process. You will learn to translate this complex structure—where the community allocates resources and individuals selfishly optimize their growth—into a single, solvable linear program, a crucial skill for engineering predictable community functions. `[@problem_id:2728354]`", "problem": "Design a computational formulation for a simplified bilevel optimization capturing individual-species growth maximization under community-level metabolite budgets in a synthetic microbial consortium. Start from the core principles of Flux Balance Analysis (FBA, Flux Balance Analysis) and linear resource allocation, and derive a single-level optimization that is exactly equivalent to the original bilevel problem, without assuming any non-biological shortcuts. Implement a program that solves the derived optimization for a provided test suite and reports the requested scalar outputs.\n\nFoundational base and assumptions to use:\n- Each species experiences steady-state mass balance consistent with Flux Balance Analysis, with a single effective biomass reaction representing growth. For each species $i$, the growth rate is denoted by $\\mu_i$ measured in $h^{-1}$.\n- The community controls the allocation of two essential extracellular metabolites, denoted \"C\" and \"N\" (for instance, a carbon source and a nitrogen source), across species. Let $U_{C,i}$ and $U_{N,i}$ be the upper bounds on uptake fluxes allocated to species $i$, in $\\text{mmol gDW}^{-1} h^{-1}$, where $\\text{gDW}$ stands for gram dry weight.\n- For each species $i$, linear stoichiometric yields $y_{C,i}$ and $y_{N,i}$ (in $h^{-1}$ per $\\text{mmol gDW}^{-1} h^{-1}$) map allocated uptake capacities to an upper bound on achievable growth: the biomass production obeys $\\mu_i \\le y_{C,i} U_{C,i}$ and $\\mu_i \\le y_{N,i} U_{N,i}$ under optimal individual metabolism. This reflects the well-tested linearity of FBA under a single limiting substrate per constraint.\n- Community-level resource budgets impose $\\sum_i U_{C,i} \\le B_C$ and $\\sum_i U_{N,i} \\le B_N$, where $B_C$ and $B_N$ are the total community budgets for metabolites \"C\" and \"N\", in $\\text{mmol gDW}^{-1} h^{-1}$.\n- Optional per-species uptake caps $U_{C,i} \\le \\overline{U}_{C,i}$ and $U_{N,i} \\le \\overline{U}_{N,i}$ may apply, with nonnegativity $U_{C,i} \\ge 0$, $U_{N,i} \\ge 0$, $\\mu_i \\ge 0$.\n\nBilevel structure to capture:\n- Lower level (individual species, executed independently for each $i$): Given allocations $U_{C,i}$ and $U_{N,i}$ from the community, the species chooses its internal fluxes to maximize $\\mu_i$ subject to linear steady-state constraints. In this simplified effective-yield abstraction, the optimal $\\mu_i$ is bounded by $\\mu_i \\le y_{C,i} U_{C,i}$ and $\\mu_i \\le y_{N,i} U_{N,i}$.\n- Upper level (community): Chooses allocations $\\{U_{C,i}, U_{N,i}\\}_i$ to optimize a community objective subject to budgets. Consider two canonical community objectives:\n  - Weighted total growth: maximize $F_{\\mathrm{sum}} = \\sum_i w_i \\mu_i$, with weights $w_i \\ge 0$ dimensionless.\n  - Egalitarian max-min growth: maximize $t$ subject to $t \\le \\mu_i$ for all $i$.\nBoth objectives should produce a scalar value in $h^{-1}$.\n\nTasks:\n- Derive, from the above foundations only, a single-level linear optimization that is equivalent to the bilevel problem for either community objective, by sound reasoning that does not skip necessary logical steps.\n- Implement a program that, for each test case below, constructs and solves the appropriate single-level optimization and outputs the scalar optimal objective value in $h^{-1}$.\n- You must solve using linear programming and adhere to numerical robustness and feasibility.\n\nAngle units are not applicable. Physical units are specified above; report final scalar objective values in $h^{-1}$ rounded to exactly six decimal places.\n\nTest suite to implement and solve:\n- Case A (weighted total growth, \"sum\"):\n  - Species count: $2$.\n  - Budgets: $B_C = 10.0\\ \\text{mmol gDW}^{-1} h^{-1}$, $B_N = 10.0\\ \\text{mmol gDW}^{-1} h^{-1}$.\n  - Yields: $y_{C} = [0.5, 1.0]\\ h^{-1}\\ (\\text{mmol gDW}^{-1} h^{-1})^{-1}$, $y_{N} = [0.4, 0.8]\\ h^{-1}\\ (\\text{mmol gDW}^{-1} h^{-1})^{-1}$.\n  - Per-species caps: $\\overline{U}_C = [10.0, 8.0]\\ \\text{mmol gDW}^{-1} h^{-1}$, $\\overline{U}_N = [10.0, 8.0]\\ \\text{mmol gDW}^{-1} h^{-1}$.\n  - Weights: $w = [1.0, 1.0]$.\n  - Output: optimal $F_{\\mathrm{sum}}$ in $h^{-1}$.\n- Case B (egalitarian max-min, \"egal\"):\n  - Species count: $2$.\n  - Budgets: $B_C = 4.0\\ \\text{mmol gDW}^{-1} h^{-1}$, $B_N = 100.0\\ \\text{mmol gDW}^{-1} h^{-1}$.\n  - Yields: $y_{C} = [1.0, 0.5]\\ h^{-1}\\ (\\text{mmol gDW}^{-1} h^{-1})^{-1}$, $y_{N} = [1.0, 0.5]\\ h^{-1}\\ (\\text{mmol gDW}^{-1} h^{-1})^{-1}$.\n  - Per-species caps: $\\overline{U}_C = [1000.0, 1000.0]\\ \\text{mmol gDW}^{-1} h^{-1}$, $\\overline{U}_N = [1000.0, 1000.0]\\ \\text{mmol gDW}^{-1} h^{-1}$.\n  - Output: optimal egalitarian value $t$ in $h^{-1}$.\n- Case C (weighted total growth, \"sum\", nitrogen absent):\n  - Species count: $3$.\n  - Budgets: $B_C = 50.0\\ \\text{mmol gDW}^{-1} h^{-1}$, $B_N = 0.0\\ \\text{mmol gDW}^{-1} h^{-1}$.\n  - Yields: $y_{C} = [1.0, 0.7, 0.9]\\ h^{-1}\\ (\\text{mmol gDW}^{-1} h^{-1})^{-1}$, $y_{N} = [1.0, 0.7, 0.9]\\ h^{-1}\\ (\\text{mmol gDW}^{-1} h^{-1})^{-1}$.\n  - Per-species caps: $\\overline{U}_C = [1000.0, 1000.0, 1000.0]\\ \\text{mmol gDW}^{-1} h^{-1}$, $\\overline{U}_N = [1000.0, 1000.0, 1000.0]\\ \\text{mmol gDW}^{-1} h^{-1}$.\n  - Weights: $w = [1.0, 1.0, 1.0]$.\n  - Output: optimal $F_{\\mathrm{sum}}$ in $h^{-1}$.\n- Case D (weighted total growth, \"sum\", per-species cap dominates one species):\n  - Species count: $2$.\n  - Budgets: $B_C = 10.0\\ \\text{mmol gDW}^{-1} h^{-1}$, $B_N = 10.0\\ \\text{mmol gDW}^{-1} h^{-1}$.\n  - Yields: $y_{C} = [2.0, 1.0]\\ h^{-1}\\ (\\text{mmol gDW}^{-1} h^{-1})^{-1}$, $y_{N} = [2.0, 1.0]\\ h^{-1}\\ (\\text{mmol gDW}^{-1} h^{-1})^{-1}$.\n  - Per-species caps: $\\overline{U}_C = [2.0, 100.0]\\ \\text{mmol gDW}^{-1} h^{-1}$, $\\overline{U}_N = [2.0, 100.0]\\ \\text{mmol gDW}^{-1} h^{-1}$.\n  - Weights: $w = [1.0, 1.0]$.\n  - Output: optimal $F_{\\mathrm{sum}}$ in $h^{-1}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for Cases A, B, C, and D, in that order, as a comma-separated list enclosed in square brackets, with each value rounded to exactly six decimal places and expressed in $h^{-1}$. For example, the output should look like: `[x_A,x_B,x_C,x_D]`.", "solution": "The problem posed is a request to formulate and solve a bilevel optimization problem modeling resource allocation in a synthetic microbial consortium. A critical validation of the problem statement is the mandatory first step.\n\nThe problem is determined to be **valid**.\n1.  **Givens Extraction**: All necessary parameters, variables, and constraints are explicitly provided. These include the number of species, community-level resource budgets ($B_C$, $B_N$), species-specific yields ($y_{C,i}$, $y_{N,i}$), and per-species uptake caps ($\\overline{U}_{C,i}$, $\\overline{U}_{N,i}$), along with two distinct community objective functions.\n2.  **Scientific Grounding**: The formulation is a simplified but standard representation of metabolic interactions, based on the principles of Flux Balance Analysis (FBA). The assumptions of linear yields and resource budgets are common and valid abstractions for creating tractable models in systems and synthetic biology. The problem is scientifically sound.\n3.  **Well-Posedness and Objectivity**: The problem is expressed with mathematical precision. The objective functions are clearly defined, and the constraints form a convex, compact feasible set. The task of maximizing a linear function over such a set is a well-posed linear programming problem, which guarantees the existence of a unique optimal objective value. The problem is free of ambiguity or subjective claims.\n\nThe problem, being valid, may be solved. The core task is to convert the specified bilevel optimization problem into an equivalent single-level linear program (LP).\n\nThe bilevel structure consists of a lower level, where each species maximizes its own growth, and an upper level, where the community allocates resources to optimize a collective objective.\n\nFor each species $i$, the lower-level problem is to determine the maximal growth rate $\\mu_i$ given the allocated uptake flux capacities $U_{C,i}$ and $U_{N,i}$:\n$$\n\\begin{align*}\n\\mu_i^*(U_{C,i}, U_{N,i}) = \\max_{\\mu_i} \\quad & \\mu_i \\\\\n\\text{s.t.} \\quad & \\mu_i \\le y_{C,i} U_{C,i} \\\\\n& \\mu_i \\le y_{N,i} U_{N,i} \\\\\n& \\mu_i \\ge 0\n\\end{align*}\n$$\nThe solution to this elementary optimization is $\\mu_i^* = \\min(y_{C,i} U_{C,i}, y_{N,i} U_{N,i})$.\n\nThe upper-level problem is to choose the allocations $\\{U_{C,i}, U_{N,i}\\}_i$ to maximize a community objective which depends on the individual optimal growth rates $\\mu_i^*$. The decision variables are subject to community budget and individual uptake constraints.\nThe presence of the $\\min$ function in the objective, $\\text{Objective}(\\{\\min(y_{C,i} U_{C,i}, y_{N,i} U_{N,i})\\}_i)$, renders the problem non-linear.\n\nTo convert this into a single-level LP, we incorporate the lower-level problem's structure directly into the upper-level problem. We introduce the growth rates $\\mu_i$ as decision variables in the main optimization and replace the equality $\\mu_i = \\min(y_{C,i} U_{C,i}, y_{N,i} U_{N,i})$ with the inequalities from the lower-level problem: $\\mu_i \\le y_{C,i} U_{C,i}$ and $\\mu_i \\le y_{N,i} U_{N,i}$. This substitution is valid because both specified community objectives (weighted sum and max-min) are monotonically increasing with respect to each $\\mu_i$. Consequently, any optimization seeking to maximize the community objective will inherently drive each $\\mu_i$ to its maximum feasible value, which is precisely $\\min(y_{C,i} U_{C,i}, y_{N,i} U_{N,i})$.\n\nThis reformulation yields a single-level problem with decision variables $\\{\\mu_i, U_{C,i}, U_{N,i}\\}_{i=1}^N$. We now specify the complete LP for each community objective.\n\n**Objective 1: Weighted Total Growth ($F_{\\mathrm{sum}} = \\sum_i w_i \\mu_i$)**\nThe objective is to maximize a linear combination of growth rates. The resulting single-level LP is:\n$$\n\\begin{align*}\n\\max_{\\{\\mu_i, U_{C,i}, U_{N,i}\\}_i} \\quad & \\sum_{i=1}^N w_i \\mu_i \\\\\n\\text{s.t.} \\quad & \\mu_i - y_{C,i} U_{C,i} \\le 0 && \\forall i \\in \\{1, ..., N\\} \\\\\n& \\mu_i - y_{N,i} U_{N,i} \\le 0 && \\forall i \\in \\{1, ..., N\\} \\\\\n& \\sum_{i=1}^N U_{C,i} \\le B_C \\\\\n& \\sum_{i=1}^N U_{N,i} \\le B_N \\\\\n& 0 \\le U_{C,i} \\le \\overline{U}_{C,i} && \\forall i \\in \\{1, ..., N\\} \\\\\n& 0 \\le U_{N,i} \\le \\overline{U}_{N,i} && \\forall i \\in \\{1, ..., N\\} \\\\\n& \\mu_i \\ge 0 && \\forall i \\in \\{1, ..., N\\}\n\\end{align*}\n$$\nThis is a standard LP formulation. The decision variables are the growth rates $\\mu_i$, carbon uptake allocations $U_{C,i}$, and nitrogen uptake allocations $U_{N,i}$. The objective function and all constraints are linear with respect to these variables.\n\n**Objective 2: Egalitarian Max-Min Growth ($\\max t$ s.t. $t \\le \\mu_i$)**\nTo handle the max-min objective, we employ the standard epigraph reformulation. We introduce an auxiliary variable $t$, which represents the minimum growth rate in the community. The objective becomes maximizing $t$, subject to the additional constraints $t \\le \\mu_i$ for all species $i$.\n$$\n\\begin{align*}\n\\max_{\\{t, \\mu_i, U_{C,i}, U_{N,i}\\}_i} \\quad & t \\\\\n\\text{s.t.} \\quad & t - \\mu_i \\le 0 && \\forall i \\in \\{1, ..., N\\} \\\\\n& \\mu_i - y_{C,i} U_{C,i} \\le 0 && \\forall i \\in \\{1, ..., N\\} \\\\\n& \\mu_i - y_{N,i} U_{N,i} \\le 0 && \\forall i \\in \\{1, ..., N\\} \\\\\n& \\sum_{i=1}^N U_{C,i} \\le B_C \\\\\n& \\sum_{i=1}^N U_{N,i} \\le B_N \\\\\n& 0 \\le U_{C,i} \\le \\overline{U}_{C,i} && \\forall i \\in \\{1, ..., N\\} \\\\\n& 0 \\le U_{N,i} \\le \\overline{U}_{N,i} && \\forall i \\in \\{1, ..., N\\} \\\\\n& t \\ge 0, \\mu_i \\ge 0 && \\forall i \\in \\{1, ..., N\\}\n\\end{align*}\n$$\nThis is also a standard LP formulation. The decision variables now include the minimum growth rate $t$. The objective and all constraints remain linear.\n\nThese derived single-level LPs are equivalent to the original bilevel problem and can be solved using standard numerical solvers. A program will be implemented to construct and solve these LPs for the provided test suite. The implementation will use `scipy.optimize.linprog`, which solves minimization problems. Maximization of a function $f(x)$ is achieved by minimizing $-f(x)$. The final reported objective value will be the rescaled result from the solver.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_community_lp(\n    num_species, \n    budget_c, \n    budget_n, \n    yield_c, \n    yield_n, \n    uptake_cap_c, \n    uptake_cap_n, \n    obj_type, \n    weights=None\n):\n    \"\"\"\n    Constructs and solves a linear program for resource allocation in a microbial community.\n\n    Args:\n        num_species (int): Number of species in the consortium (N).\n        budget_c (float): Total community budget for metabolite C.\n        budget_n (float): Total community budget for metabolite N.\n        yield_c (list or np.ndarray): Yields for metabolite C for each species.\n        yield_n (list or np.ndarray): Yields for metabolite N for each species.\n        uptake_cap_c (list or np.ndarray): Per-species uptake caps for C.\n        uptake_cap_n (list or np.ndarray): Per-species uptake caps for N.\n        obj_type (str): The community objective ('sum' or 'egal').\n        weights (list or np.ndarray): Weights for the 'sum' objective.\n\n    Returns:\n        float: The optimal value of the community objective function.\n    \"\"\"\n    N = num_species\n\n    if obj_type == \"sum\":\n        # Variables are ordered as [mu_1,...,mu_N, Uc_1,...,Uc_N, Un_1,...,Un_N]\n        num_vars = 3 * N\n        \n        # Objective: maximize sum(w_i * mu_i), which is equivalent to\n        # minimizing -sum(w_i * mu_i).\n        c = np.zeros(num_vars)\n        c[:N] = -np.array(weights)\n\n        # Inequality constraints: A_ub @ x <= b_ub\n        num_constraints = 2 * N + 2\n        A_ub = np.zeros((num_constraints, num_vars))\n        b_ub = np.zeros(num_constraints)\n\n        # Constraints: mu_i - y_ci * Uc_i <= 0\n        for i in range(N):\n            A_ub[i, i] = 1        # mu_i term\n            A_ub[i, N + i] = -yield_c[i] # Uc_i term\n        \n        # Constraints: mu_i - y_ni * Un_i <= 0\n        for i in range(N):\n            A_ub[N + i, i] = 1        # mu_i term\n            A_ub[N + i, 2 * N + i] = -yield_n[i] # Un_i term\n\n        # Budget constraint: sum(Uc_i) <= budget_c\n        A_ub[2 * N, N:2 * N] = 1\n        b_ub[2 * N] = budget_c\n        \n        # Budget constraint: sum(Un_i) <= budget_n\n        A_ub[2 * N + 1, 2 * N:3 * N] = 1\n        b_ub[2 * N + 1] = budget_n\n\n        # Variable bounds\n        bounds = []\n        bounds.extend([(0, None)] * N)  # mu_i >= 0\n        bounds.extend([(0, uc) for uc in uptake_cap_c])\n        bounds.extend([(0, un) for un in uptake_cap_n])\n\n    elif obj_type == \"egal\":\n        # Variables: [mu_1,...,mu_N, Uc_1,...,Uc_N, Un_1,...,Un_N, t]\n        num_vars = 3 * N + 1\n        \n        # Objective: maximize t, which is equivalent to minimizing -t.\n        c = np.zeros(num_vars)\n        c[-1] = -1\n\n        # Inequality constraints\n        num_constraints = 3 * N + 2\n        A_ub = np.zeros((num_constraints, num_vars))\n        b_ub = np.zeros(num_constraints)\n        \n        # Constraints: t - mu_i <= 0\n        for i in range(N):\n            A_ub[i, i] = -1       # mu_i term\n            A_ub[i, 3 * N] = 1    # t term\n            \n        # Constraints: mu_i - y_ci * Uc_i <= 0\n        for i in range(N):\n            A_ub[N + i, i] = 1\n            A_ub[N + i, N + i] = -yield_c[i]\n            \n        # Constraints: mu_i - y_ni * Un_i <= 0\n        for i in range(N):\n            A_ub[2 * N + i, i] = 1\n            A_ub[2 * N + i, 2 * N + i] = -yield_n[i]\n            \n        # Budget constraint: sum(Uc_i) <= budget_c\n        A_ub[3 * N, N:2 * N] = 1\n        b_ub[3 * N] = budget_c\n        \n        # Budget constraint: sum(Un_i) <= budget_n\n        A_ub[3 * N + 1, 2 * N:3 * N] = 1\n        b_ub[3 * N + 1] = budget_n\n        \n        # Variable bounds\n        bounds = []\n        bounds.extend([(0, None)] * N)\n        bounds.extend([(0, uc) for uc in uptake_cap_c])\n        bounds.extend([(0, un) for un in uptake_cap_n])\n        bounds.append((0, None))  # t >= 0\n    \n    else:\n        raise ValueError(\"Invalid objective type specified.\")\n\n    # Solve the LP\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        # res.fun is the minimum of the objective, which is -max_value\n        return -res.fun\n    else:\n        # Return NaN or raise an error if the optimization fails\n        return np.nan\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (weighted total growth, \"sum\")\n        {\n            \"num_species\": 2, \"budget_c\": 10.0, \"budget_n\": 10.0,\n            \"yield_c\": [0.5, 1.0], \"yield_n\": [0.4, 0.8],\n            \"uptake_cap_c\": [10.0, 8.0], \"uptake_cap_n\": [10.0, 8.0],\n            \"obj_type\": \"sum\", \"weights\": [1.0, 1.0]\n        },\n        # Case B (egalitarian max-min, \"egal\")\n        {\n            \"num_species\": 2, \"budget_c\": 4.0, \"budget_n\": 100.0,\n            \"yield_c\": [1.0, 0.5], \"yield_n\": [1.0, 0.5],\n            \"uptake_cap_c\": [1000.0, 1000.0], \"uptake_cap_n\": [1000.0, 1000.0],\n            \"obj_type\": \"egal\"\n        },\n        # Case C (weighted total growth, \"sum\", nitrogen absent)\n        {\n            \"num_species\": 3, \"budget_c\": 50.0, \"budget_n\": 0.0,\n            \"yield_c\": [1.0, 0.7, 0.9], \"yield_n\": [1.0, 0.7, 0.9],\n            \"uptake_cap_c\": [1000.0, 1000.0, 1000.0], \"uptake_cap_n\": [1000.0, 1000.0, 1000.0],\n            \"obj_type\": \"sum\", \"weights\": [1.0, 1.0, 1.0]\n        },\n        # Case D (weighted total growth, \"sum\", per-species cap dominates)\n        {\n            \"num_species\": 2, \"budget_c\": 10.0, \"budget_n\": 10.0,\n            \"yield_c\": [2.0, 1.0], \"yield_n\": [2.0, 1.0],\n            \"uptake_cap_c\": [2.0, 100.0], \"uptake_cap_n\": [2.0, 100.0],\n            \"obj_type\": \"sum\", \"weights\": [1.0, 1.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_community_lp(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2728354"}, {"introduction": "Beyond predicting behavior, a key goal of synthetic biology is to control it and ensure its robustness. This final practice introduces a computational method for analyzing the structural resilience of a consortium's metabolic network. You will implement an algorithm to find minimal cut-sets—the smallest sets of reaction knockouts that disrupt a target metabolic flux—providing a systematic way to identify critical control points and potential failure modes in your design. `[@problem_id:2728387]`", "problem": "You are tasked with writing a complete, runnable program that, for a set of small, synthetic microbial consortia models, computes minimal cut-sets that disrupt a specified target metabolite flow and quantifies a resilience metric for each case. Your program must implement the following mathematically grounded framework.\n\nStart from the steady-state mass balance for intracellular and shared extracellular metabolites: for a stoichiometric matrix $S \\in \\mathbb{R}^{m \\times n}$ and a reaction flux vector $v \\in \\mathbb{R}^{n}$, the steady-state constraint is $S v = 0$. Reaction fluxes are constrained by lower and upper bounds $l \\le v \\le u$, where $l, u \\in \\mathbb{R}^{n}$. Under Flux Balance Analysis (FBA), formulating a Linear Programming (LP) problem, the maximal achievable flux through a designated target reaction indexed by $j^\\star$ is obtained by solving an LP that maximizes $v_{j^\\star}$ subject to the linear constraints $S v = 0$ and $l \\le v \\le u$. A set of reactions $K \\subseteq \\{0,1,\\dots,n-1\\}$ is designated as the knockable set, meaning only reactions in $K$ may be disabled (knocked out). A knock-out of a reaction $j$ is modeled by setting its flux bounds to $l_j = u_j = 0$.\n\nDefine a target threshold $\\tau > 0$. A set $C \\subseteq K$ is a cut-set if, after simultaneously knocking out all reactions $j \\in C$, every feasible steady-state flux vector $v$ satisfies $v_{j^\\star} < \\tau$. A minimal cut-set is a cut-set $C$ such that no proper subset of $C$ is also a cut-set. Let $|C|$ denote the cardinality of $C$. Define the resilience index $R$ for a case with at least one minimal cut-set as $R = \\frac{|C_{\\min}|}{|K|}$, where $|C_{\\min}|$ is the minimal cardinality among all minimal cut-sets for that case. If the target threshold $\\tau$ is not achievable in the intact network (i.e., before any knock-outs), treat the case as non-feasible for the target; in that situation, report that there is no need for cut-sets and do not define a resilience index. If the target is achievable but no cut-set exists under the allowed knockable set $K$, report that the network is not blockable under the allowed interventions and do not define a resilience index.\n\nYour program must:\n- For each provided test case, determine whether the target threshold is achievable in the intact network by solving an LP that maximizes the target flux $v_{j^\\star}$.\n- If achievable, enumerate subsets of $K$ in increasing size to find all minimal cut-sets of minimal cardinality that ensure $v_{j^\\star} < \\tau$ after knock-out of the subset.\n- For each case, produce a tuple of results:\n  1. A boolean indicating whether the target threshold is achievable in the intact network.\n  2. A boolean indicating whether the network is blockable under the allowed knockable set $K$ (i.e., whether at least one minimal cut-set exists).\n  3. The minimal cardinality $|C_{\\min}|$ of the cut-sets if blockable; otherwise, report $-1$.\n  4. The number of distinct minimal cut-sets achieving that minimal cardinality if blockable; otherwise, report $0$.\n  5. The resilience index $R$ as defined above if blockable; otherwise, report $-1$.\n\nAll fluxes are dimensionless in arbitrary units and require no specific physical units in the output.\n\nIndexing convention: use zero-based indexing for reactions.\n\nTest suite:\n- Case $1$ (single-path chain from feed to target):\n  - Metabolites (rows of $S_1$): $[F_e, F_A, P_A, P_e, P_B, T_B, T_e]$.\n  - Reactions (columns of $S_1$), in order $[R_1, R_2, R_3, R_4, R_5, R_6, R_7, R_8]$:\n    - $R_1$: environment $\\to F_e$,\n    - $R_2$: $F_e \\to F_A$,\n    - $R_3$: $F_A \\to P_A$,\n    - $R_4$: $P_A \\to P_e$,\n    - $R_5$: $P_e \\to P_B$,\n    - $R_6$: $P_B \\to T_B$,\n    - $R_7$: $T_B \\to T_e$ (target),\n    - $R_8$: $T_e \\to$ environment.\n  - Stoichiometric matrix $S_1 \\in \\mathbb{R}^{7 \\times 8}$:\n    $$\n    S_1 =\n    \\begin{bmatrix}\n    +1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n    0 & +1 & -1 & 0 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & +1 & -1 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & +1 & -1 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 & +1 & -1 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 & 0 & +1 & -1 & 0 \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & +1 & -1\n    \\end{bmatrix}.\n    $$\n  - Bounds $l_1 = (0,\\dots,0)$, $u_1 = (2.0, 1000, 1000, 1000, 1000, 1000, 1000, 1000)$.\n  - Target index $j^\\star = 6$.\n  - Threshold $\\tau = 1.0$.\n  - Knockable set $K_1 = \\{1,2,3,4,5\\}$.\n- Case $2$ (two parallel conversions in species A):\n  - Same metabolites as Case $1$.\n  - Reactions (columns of $S_2$), in order $[R_1, R_2, R_{3a}, R_{3b}, R_4, R_5, R_6, R_7, R_8]$:\n    - $R_1$: environment $\\to F_e$,\n    - $R_2$: $F_e \\to F_A$,\n    - $R_{3a}$: $F_A \\to P_A$,\n    - $R_{3b}$: $F_A \\to P_A$,\n    - $R_4$: $P_A \\to P_e$,\n    - $R_5$: $P_e \\to P_B$,\n    - $R_6$: $P_B \\to T_B$,\n    - $R_7$: $T_B \\to T_e$ (target),\n    - $R_8$: $T_e \\to$ environment.\n  - Stoichiometric matrix $S_2 \\in \\mathbb{R}^{7 \\times 9}$:\n    $$\n    S_2 =\n    \\begin{bmatrix}\n    +1 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n    0 & +1 & -1 & -1 & 0 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & +1 & +1 & -1 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 & +1 & -1 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 & 0 & +1 & -1 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & +1 & -1 & 0 \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & +1 & -1\n    \\end{bmatrix}.\n    $$\n  - Bounds $l_2 = (0,\\dots,0)$, $u_2 = (2.0, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000)$.\n  - Target index $j^\\star = 7$.\n  - Threshold $\\tau = 1.0$.\n  - Knockable set $K_2 = \\{2,3\\}$.\n- Case $3$ (threshold unattainable in intact network due to feed limitation):\n  - Identical to Case $1$ except $u_3 = (0.6, 1000, 1000, 1000, 1000, 1000, 1000, 1000)$.\n  - Target index $j^\\star = 6$.\n  - Threshold $\\tau = 1.0$.\n  - Knockable set $K_3 = \\{1,2,3,4,5\\}$.\n- Case $4$ (no interventions allowed):\n  - Identical to Case $1$ but with an empty knockable set $K_4 = \\emptyset$.\n  - Target index $j^\\star = 6$.\n  - Threshold $\\tau = 1.0$.\n\nYour program must use Linear Programming (LP) to evaluate target feasibility and to test whether a candidate knock-out subset is a cut-set by checking if the maximized target flux falls below $\\tau$. For each case, search for minimal cut-sets by enumerating subsets of $K$ in increasing cardinality until at least one cut-set is found; then report the minimal cardinality, the number of distinct minimal cut-sets of that cardinality, and the resilience index.\n\nFinal output format:\n- Produce a single line of output containing a list of per-case results, where each per-case result is a list of five entries as specified above. The output must be exactly one line in the format\n  `[result_case1,result_case2,result_case3,result_case4]`\n  where, for example, a per-case result could look like `[True,True,1,5,0.2]`.", "solution": "The problem presented is a standard exercise in computational systems biology, specifically concerning the analysis of metabolic network robustness using Flux Balance Analysis (FBA). The problem is well-defined, scientifically grounded, and contains all necessary information for a unique, verifiable solution. We shall proceed with its formal resolution.\n\nThe core of the problem rests upon the principle of mass conservation at steady-state in a metabolic network. For a system with $m$ metabolites and $n$ reactions, this principle is captured by the linear equation:\n$$S \\cdot v = 0$$\nwhere $S \\in \\mathbb{R}^{m \\times n}$ is the stoichiometric matrix, and $v \\in \\mathbb{R}^{n}$ is the vector of reaction fluxes. Each flux $v_j$ is further constrained by thermodynamic and capacity limits, expressed as lower and upper bounds, $l_j \\le v_j \\le u_j$.\n\nFlux Balance Analysis (FBA) uses Linear Programming (LP) to find a feasible flux distribution $v$ that optimizes a given biological objective, typically the maximization of a specific flux, such as biomass production or the synthesis of a target metabolite. To maximize the flux of a target reaction $v_{j^\\star}$, we solve the following LP problem:\n$$\n\\begin{align*}\n\\text{maximize} \\quad & v_{j^\\star} \\\\\n\\text{subject to} \\quad & S \\cdot v = 0 \\\\\n& l_j \\le v_j \\le u_j \\quad \\text{for } j=0, \\dots, n-1\n\\end{align*}\n$$\nThis is equivalent to minimizing $-v_{j^\\star}$. The objective function vector $c$ for a standard LP solver would be $c_j = -1$ for $j=j^\\star$ and $c_j=0$ for $j \\neq j^\\star$. The equality constraints are $A_{eq} = S$ and $b_{eq} = 0$. The flux bounds are handled directly by the solver.\n\nThe problem requires the identification of minimal cut-sets. A set of reactions $C$, chosen from a knockable set $K$, is a cut-set if, upon their removal, the maximal flux through the target reaction $v_{j^\\star}$ falls below a specified threshold $\\tau$. A reaction knock-out is simulated by setting its bounds to zero, i.e., $l_j = u_j = 0$ for all $j \\in C$. Thus, $C \\subseteq K$ is a cut-set if $\\max(v_{j^\\star})_{\\text{knockout}} < \\tau$.\n\nA minimal cut-set is a cut-set for which no proper subset is also a cut-set. The problem asks for minimal cut-sets of the *smallest possible cardinality*. The prescribed algorithm correctly identifies these by systematically enumerating subsets of $K$ in increasing order of cardinality, $|C|=k$, starting from $k=1$. When the first non-empty set of cut-sets is found at cardinality $k_{min}$, the search terminates. Any cut-set $C$ found at this stage must be minimal. If it were not, it would contain a proper subset $C' \\subset C$ that is also a cut-set. However, $|C'| < |C| = k_{min}$, which contradicts the premise that $k_{min}$ is the smallest cardinality at which any cut-set was found. Therefore, this iterative search correctly finds all minimal cut-sets of minimal cardinality.\n\nThe resilience index $R = \\frac{|C_{\\min}|}{|K|}$ is a normalized measure of the network's robustness to the allowed interventions. A higher value indicates that a larger fraction of the available intervention targets must be disabled simultaneously to disrupt the target flux, suggesting higher resilience. Special cases where the target flux is initially below the threshold or where no cut-sets exist within $K$ are handled as defined, resulting in undefined resilience.\n\nThe overall algorithm for each test case is as follows:\n1.  Define the model parameters: $S$, $l$, $u$, $j^\\star$, $\\tau$, and $K$.\n2.  Solve the FBA problem for the intact network to find the maximum possible target flux, $v_{max}^{intact}$.\n3.  Compare $v_{max}^{intact}$ with $\\tau$. If $v_{max}^{intact} < \\tau$, the target is unachievable. No cut-sets are necessary. Report `target_achievable = False` and default values for other metrics.\n4.  If $v_{max}^{intact} \\ge \\tau$, the target is achievable. Proceed to search for cut-sets. Report `target_achievable = True`.\n5.  Iterate on subset cardinality $k$ from $1$ to $|K|$. For each $k$, generate all combinations $C \\subseteq K$ of size $k$.\n6.  For each candidate set $C$, modify the flux bounds by setting $l_j=u_j=0$ for all $j \\in C$. Solve the resulting FBA problem to find the maximum target flux, $v_{max}^{ko}$.\n7.  If $v_{max}^{ko} < \\tau$, then $C$ is a minimal cut-set of minimal cardinality. Add it to a list of solutions for the current $k$.\n8.  If, after checking all subsets of size $k$, at least one cut-set has been found, the search terminates. The minimal cardinality is $k_{min}=k$, and the number of such sets is the length of the solution list. The resilience index is calculated as $R = k_{min} / |K|$.\n9.  If the loop completes without finding any cut-sets, the network is not blockable under the given constraints. Report `is_blockable = False` and default values for other metrics.\n\nThis procedure will be implemented for each provided test case.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations\n\ndef solve_fba(S, l, u, j_target):\n    \"\"\"\n    Solves the FBA problem to maximize flux through j_target.\n    \n    Args:\n        S (np.ndarray): Stoichiometric matrix.\n        l (np.ndarray): Lower bounds for fluxes.\n        u (np.ndarray): Upper bounds for fluxes.\n        j_target (int): Index of the target reaction.\n\n    Returns:\n        float: The maximal flux through the target reaction.\n    \"\"\"\n    num_reactions = S.shape[1]\n    c = np.zeros(num_reactions)\n    c[j_target] = -1  # Minimize -v_j_target to maximize v_j_target\n\n    bounds = list(zip(l, u))\n    b_eq = np.zeros(S.shape[0])\n\n    # Use 'highs-ds' method for robustness\n    res = linprog(c, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs-ds')\n\n    if res.success:\n        return -res.fun  # Return the maximized flux (negate back)\n    elif res.status == 2:  # Status 2 indicates the problem is infeasible\n        return 0.0  # Infeasible means no flux, so max flux is 0\n    else:\n        # For other errors, assume 0 flux as a safe default\n        return 0.0\n\ndef analyze_case(S, l, u, j_target, tau, K):\n    \"\"\"\n    Analyzes a single metabolic network case.\n    \n    Returns:\n        list: A list of 5 result metrics for the case.\n    \"\"\"\n    # 1. Check if target is achievable in the intact network\n    max_flux_initial = solve_fba(S, l, u, j_target)\n    \n    if max_flux_initial  tau:\n        # Target not achievable, no cut-sets needed\n        return [False, False, -1, 0, -1.0]\n\n    target_achievable = True\n    \n    # 2. Search for minimal cut-sets\n    K_list = sorted(list(K)) # Use a sorted list for deterministic iteration\n    is_blockable = False\n    minimal_cut_sets_found = []\n    min_card = -1\n\n    if not K_list: # Empty knockable set\n        is_blockable = False\n    else:\n        for k in range(1, len(K_list) + 1):\n            for C_tuple in combinations(K_list, k):\n                C = set(C_tuple)\n                l_mod = np.copy(l)\n                u_mod = np.copy(u)\n                \n                for j_knockout in C:\n                    l_mod[j_knockout] = 0.0\n                    u_mod[j_knockout] = 0.0\n\n                max_flux_knockout = solve_fba(S, l_mod, u_mod, j_target)\n\n                if max_flux_knockout  tau:\n                    minimal_cut_sets_found.append(C)\n                    is_blockable = True\n            \n            if is_blockable:\n                min_card = k\n                break # Found minimal cardinality, stop searching larger sets\n\n    # 3. Compile results\n    if is_blockable:\n        num_minimal_cut_sets = len(minimal_cut_sets_found)\n        resilience_index = float(min_card) / len(K_list) if K_list else -1.0\n        return [target_achievable, is_blockable, min_card, num_minimal_cut_sets, resilience_index]\n    else:\n        # Target is achievable but not blockable with the given K\n        return [target_achievable, False, -1, 0, -1.0]\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the analysis for each.\n    \"\"\"\n    # Case 1: single-path chain\n    S1 = np.array([\n        [+1, -1,  0,  0,  0,  0,  0,  0],\n        [ 0, +1, -1,  0,  0,  0,  0,  0],\n        [ 0,  0, +1, -1,  0,  0,  0,  0],\n        [ 0,  0,  0, +1, -1,  0,  0,  0],\n        [ 0,  0,  0,  0, +1, -1,  0,  0],\n        [ 0,  0,  0,  0,  0, +1, -1,  0],\n        [ 0,  0,  0,  0,  0,  0, +1, -1]\n    ], dtype=float)\n    l1 = np.zeros(8)\n    u1 = np.array([2.0, 1000, 1000, 1000, 1000, 1000, 1000, 1000])\n    j_star1 = 6\n    tau1 = 1.0\n    K1 = {1, 2, 3, 4, 5}\n\n    # Case 2: two parallel conversions\n    S2 = np.array([\n        [+1, -1,  0,  0,  0,  0,  0,  0,  0],\n        [ 0, +1, -1, -1,  0,  0,  0,  0,  0],\n        [ 0,  0, +1, +1, -1,  0,  0,  0,  0],\n        [ 0,  0,  0,  0, +1, -1,  0,  0,  0],\n        [ 0,  0,  0,  0,  0, +1, -1,  0,  0],\n        [ 0,  0,  0,  0,  0,  0, +1, -1,  0],\n        [ 0,  0,  0,  0,  0,  0,  0, +1, -1]\n    ], dtype=float)\n    l2 = np.zeros(9)\n    u2 = np.array([2.0, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000])\n    j_star2 = 7\n    tau2 = 1.0\n    K2 = {2, 3}\n\n    # Case 3: threshold unattainable\n    S3 = S1\n    l3 = l1\n    u3 = np.array([0.6, 1000, 1000, 1000, 1000, 1000, 1000, 1000])\n    j_star3 = 6\n    tau3 = 1.0\n    K3 = {1, 2, 3, 4, 5}\n\n    # Case 4: no interventions allowed\n    S4 = S1\n    l4 = l1\n    u4 = u1\n    j_star4 = 6\n    tau4 = 1.0\n    K4 = set()\n\n    test_cases = [\n        (S1, l1, u1, j_star1, tau1, K1),\n        (S2, l2, u2, j_star2, tau2, K2),\n        (S3, l3, u3, j_star3, tau3, K3),\n        (S4, l4, u4, j_star4, tau4, K4),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_case(*case)\n        results.append(result)\n\n    # Print results in the required list-of-lists format\n    print(results)\n\nsolve()\n```", "id": "2728387"}]}