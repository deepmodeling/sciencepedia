{"hands_on_practices": [{"introduction": "A central goal in synthetic embryology is to guide self-organizing tissues into desired patterns. This exercise will guide you through the process of building a computational model from the ground up to simulate how the precise timing and location of key signaling pathways—Nodal, Wnt, and BMP—orchestrate the arrangement of the three primary germ layers on a spherical synthetic embryo. By implementing this model, you will gain hands-on experience in simulating how dynamic morphogen fields are interpreted by cells to establish a body plan, a fundamental concept in developmental biology [@problem_id:2780289].", "problem": "Design and implement a simulation program that models how timing sequences of Nodal, Wnt, and Bone Morphogenetic Protein (BMP) pathway activities allocate germ layers on a spherical surface representing a synthetic embryo-like structure. The simulation must be axisymmetric about a fixed axis so that activities depend only on the polar angle. Use an ordinary differential equation (ODE)-based low-pass filter to capture finite signaling timescales, and a Hill-type transduction nonlinearity to capture gene-regulatory responses that determine germ layer fates.\n\nModeling assumptions and definitions:\n- Geometry and coordinates: Use the unit sphere with axial symmetry so that the state depends only on the polar angle $\\theta \\in [0,\\pi]$ (radians). The surface-area weight for averaging over the sphere is $\\sin(\\theta)$.\n- Time: Simulate over $t \\in [0,T]$ with $T>0$ (dimensionless time). Use a fixed time step $\\Delta t$ chosen small enough to resolve the ODE dynamics.\n- Pathways: For each pathway $P \\in \\{\\text{Nodal} (\\mathcal{N}), \\text{Wnt} (\\mathcal{W}), \\text{BMP} (\\mathcal{B})\\}$, define a concentration field $c_P(\\theta,t)$ governed by the first-order linear ODE\n  $$\\frac{\\mathrm{d}c_P(\\theta,t)}{\\mathrm{d}t} \\;=\\; -\\lambda_P\\,c_P(\\theta,t) \\;+\\; \\alpha_P\\, s_P(t)\\, g_P(\\theta), \\quad c_P(\\theta,0)=0,$$\n  where $\\lambda_P>0$ is a decay rate, $\\alpha_P>0$ is an input gain, $s_P(t)$ is a temporal source profile, and $g_P(\\theta)$ is a position-dependent sensitivity (both defined below). This ODE implements a first-order low-pass filter of the source input at each $\\theta$.\n- Temporal source profile: For each pathway $P$, use a rectangular pulse\n  $$s_P(t) \\;=\\; A_P \\cdot \\mathbf{1}\\!\\left[t_{\\mathrm{on},P} \\le t < t_{\\mathrm{on},P} + \\tau_P\\right],$$\n  where $A_P \\ge 0$ is amplitude, $t_{\\mathrm{on},P}\\ge 0$ is onset time, and $\\tau_P \\ge 0$ is duration.\n- Spatial sensitivity: For each pathway $P$, use a Gaussian function of the polar angle centered at $\\mu_P$ with width $\\sigma_P>0$,\n  $$g_P(\\theta) \\;=\\; \\exp\\!\\left(-\\frac{\\left(\\theta-\\mu_P\\right)^2}{2\\,\\sigma_P^2}\\right),$$\n  normalized implicitly by its maximum of $1$.\n- Signal transduction: Map concentrations to transcriptional responses by time-averaging a Hill function,\n  $$H(x;K,h) \\;=\\; \\frac{x^h}{K^h + x^h}, \\qquad r_P(\\theta) \\;=\\; \\frac{1}{T}\\int_{0}^{T} H\\!\\left(c_P(\\theta,t); K_P, h_P\\right)\\,\\mathrm{d}t,$$\n  where $K_P>0$ is an activation constant and $h_P\\ge 1$ is a Hill coefficient. The quantity $r_P(\\theta)\\in[0,1]$ is the time-averaged pathway response.\n- Fate scoring and allocation: Compute three fate scores from the averaged responses $r_{\\mathcal{N}}(\\theta)$, $r_{\\mathcal{W}}(\\theta)$, $r_{\\mathcal{B}}(\\theta)$,\n  $$S_{\\mathrm{end}}(\\theta) \\;=\\; r_{\\mathcal{N}}(\\theta)\\,\\bigl(1 - \\tfrac{1}{2} r_{\\mathcal{B}}(\\theta)\\bigr),$$\n  $$S_{\\mathrm{mes}}(\\theta) \\;=\\; r_{\\mathcal{W}}(\\theta)\\, r_{\\mathcal{B}}(\\theta)\\,\\bigl(\\tfrac{1}{2} + \\tfrac{1}{2} r_{\\mathcal{N}}(\\theta)\\bigr),$$\n  $$S_{\\mathrm{ect}}(\\theta) \\;=\\; \\bigl(1 - r_{\\mathcal{N}}(\\theta)\\bigr)\\,\\bigl(1 - r_{\\mathcal{W}}(\\theta)\\bigr)\\,\\bigl(\\tfrac{1}{2} + \\tfrac{1}{2} r_{\\mathcal{B}}(\\theta)\\bigr).$$\n  Allocate the fate at angle $\\theta$ by the largest score. In the event of an exact tie, break ties deterministically in the order endoderm $>$ mesoderm $>$ ectoderm.\n- Area fractions: Report the fraction of the spherical surface area assigned to each fate by integrating the indicator of the allocated fate with the correct surface-area weight. If $\\mathcal{F}_i$ is the set of $\\theta$ assigned to fate $i\\in\\{\\mathrm{ect},\\mathrm{mes},\\mathrm{end}\\}$, compute\n  $$f_i \\;=\\; \\frac{\\int_{0}^{\\pi} \\mathbf{1}\\!\\left[\\theta \\in \\mathcal{F}_i\\right] \\sin(\\theta)\\,\\mathrm{d}\\theta}{\\int_{0}^{\\pi} \\sin(\\theta)\\,\\mathrm{d}\\theta} \\;=\\; \\frac{1}{2}\\int_{0}^{\\pi} \\mathbf{1}\\!\\left[\\theta \\in \\mathcal{F}_i\\right] \\sin(\\theta)\\,\\mathrm{d}\\theta.$$\n  The fractions $f_{\\mathrm{ect}}, f_{\\mathrm{mes}}, f_{\\mathrm{end}}$ must sum to $1$ up to numerical rounding. Express each fraction as a decimal rounded to three digits after the decimal point.\n\nParameter values to use throughout unless otherwise specified in a test case:\n- Shared geometry and dynamics: $\\;T=10.0,\\;\\Delta t=0.01.$\n- Decay and gain: $\\;\\lambda_{\\mathcal{N}}=\\lambda_{\\mathcal{W}}=\\lambda_{\\mathcal{B}}=1.0,\\;\\alpha_{\\mathcal{N}}=\\alpha_{\\mathcal{W}}=\\alpha_{\\mathcal{B}}=1.0.$\n- Spatial sensitivity centers and widths (radians): $\\;\\mu_{\\mathcal{N}}=2.4,\\;\\mu_{\\mathcal{W}}=\\frac{\\pi}{2},\\;\\mu_{\\mathcal{B}}=0.4,\\;$ and $\\;\\sigma_{\\mathcal{N}}=\\sigma_{\\mathcal{W}}=\\sigma_{\\mathcal{B}}=0.5.$\n- Hill parameters: $\\;K_{\\mathcal{N}}=K_{\\mathcal{W}}=K_{\\mathcal{B}}=0.5,\\;h_{\\mathcal{N}}=h_{\\mathcal{W}}=h_{\\mathcal{B}}=2.$\n- Angular discretization: Use a uniform grid in $\\theta$ over $[0,\\pi]$ fine enough to resolve the Gaussian profiles and the $\\sin(\\theta)$ weighting.\n\nTest suite:\nProvide the area fractions $\\bigl[f_{\\mathrm{ect}},f_{\\mathrm{mes}},f_{\\mathrm{end}}\\bigr]$ for each of the following four source timing scenarios, each specified as a tuple of nine scalars $(A_{\\mathcal{N}}, t_{\\mathrm{on},\\mathcal{N}}, \\tau_{\\mathcal{N}}, A_{\\mathcal{W}}, t_{\\mathrm{on},\\mathcal{W}}, \\tau_{\\mathcal{W}}, A_{\\mathcal{B}}, t_{\\mathrm{on},\\mathcal{B}}, \\tau_{\\mathcal{B}})$:\n- Case $1$ (sequential $\\mathcal{N}\\to \\mathcal{W}\\to \\mathcal{B}$): $\\;(A_{\\mathcal{N}}, t_{\\mathrm{on},\\mathcal{N}}, \\tau_{\\mathcal{N}}, A_{\\mathcal{W}}, t_{\\mathrm{on},\\mathcal{W}}, \\tau_{\\mathcal{W}}, A_{\\mathcal{B}}, t_{\\mathrm{on},\\mathcal{B}}, \\tau_{\\mathcal{B}}) = (1.0, 0.0, 3.0, 1.0, 2.0, 3.0, 1.0, 4.0, 3.0)$.\n- Case $2$ (synchronous): $\\;(1.0, 0.0, 3.0, 1.0, 0.0, 3.0, 1.0, 0.0, 3.0)$.\n- Case $3$ (reverse $\\mathcal{B}\\to \\mathcal{W}\\to \\mathcal{N}$): $\\;(1.0, 4.0, 3.0, 1.0, 2.0, 3.0, 1.0, 0.0, 3.0)$.\n- Case $4$ (null inputs): $\\;(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)$.\n\nProgram requirements:\n- Implement the ODE integration with a forward-Euler scheme for each pathway at each $\\theta$.\n- Compute time-averaged Hill responses and fate scores as defined above.\n- Allocate fates by argmax with the specified tie-breaking rule.\n- Compute area-weighted fractions $f_{\\mathrm{ect}}, f_{\\mathrm{mes}}, f_{\\mathrm{end}}$ and round each to three digits after the decimal point.\n- Angles must be in radians. There are no physical units.\n- Final output format: The program should produce a single line of output containing the results for the four cases as a comma-separated list of lists enclosed in square brackets, for example, \"[[x11,x12,x13],[x21,x22,x23],[x31,x32,x33],[x41,x42,x43]]\" where each $x_{ij}$ is a decimal with exactly three digits after the decimal point.", "solution": "The problem statement has been rigorously validated. It describes a well-posed, scientifically grounded, and computationally tractable model of morphogen-driven cell fate specification in a synthetic biological context. The formulation is self-contained, and all parameters and functions are explicitly defined. There are no contradictions, ambiguities, or violations of scientific principles. Thus, the problem is deemed valid, and we proceed with the derivation and implementation of the solution.\n\nThe task is to simulate a system of ordinary differential equations (ODEs) that model signaling pathway dynamics and subsequently determine germ layer fates based on the time-integrated activity of these pathways. The solution requires a numerical approach, discretizing both time and the single spatial dimension, the polar angle $\\theta$.\n\n**1. Discretization of the Domain**\n\nThe continuous variables time $t$ and polar angle $\\theta$ must be discretized for numerical computation.\n\n-   **Time Discretization**: The simulation runs over the interval $t \\in [0, T]$, where $T=10.0$. A fixed time step $\\Delta t = 0.01$ is specified. This defines a discrete set of time points $t_k = k \\cdot \\Delta t$ for $k = 0, 1, \\dots, N_t$, where the total number of steps is $N_t = T / \\Delta t = 10.0 / 0.01 = 1000$. This results in $N_t+1 = 1001$ time points.\n\n-   **Spatial Discretization**: The spatial domain is the polar angle $\\theta \\in [0, \\pi]$. We must choose a grid fine enough to resolve the spatial features, which are Gaussian profiles with standard deviations $\\sigma_P = 0.5$ radians. A uniform grid of $N_\\theta$ points is appropriate. Let us choose $N_\\theta = 1001$ points, which provides a high resolution with an angular step of $\\Delta\\theta = \\pi / (N_\\theta - 1) = \\pi / 1000 \\approx 0.00314$ radians. The discrete angles are $\\theta_j = j \\cdot \\Delta\\theta$ for $j = 0, 1, \\dots, N_\\theta - 1$. This grid is more than sufficient to accurately represent the Gaussian sensitivity functions $g_P(\\theta)$ and the surface-area weighting factor $\\sin(\\theta)$.\n\n**2. Numerical Solution of the Signaling ODE**\n\nFor each pathway $P \\in \\{\\mathcal{N}, \\mathcal{W}, \\mathcal{B}\\}$, the concentration $c_P(\\theta, t)$ is governed by the ODE:\n$$\n\\frac{\\mathrm{d}c_P(\\theta,t)}{\\mathrm{d}t} = -\\lambda_P c_P(\\theta,t) + \\alpha_P s_P(t) g_P(\\theta), \\quad c_P(\\theta,0) = 0\n$$\nThe problem specifies the use of the forward Euler method for integration. For a given spatial point $\\theta_j$, the update rule from time $t_k$ to $t_{k+1}$ is:\n$$\nc_P(\\theta_j, t_{k+1}) = c_P(\\theta_j, t_k) + \\Delta t \\left( -\\lambda_P c_P(\\theta_j, t_k) + \\alpha_P s_P(t_k) g_P(\\theta_j) \\right)\n$$\nThis can be rewritten for computational efficiency as:\n$$\nc_P(\\theta_j, t_{k+1}) = (1 - \\lambda_P \\Delta t) c_P(\\theta_j, t_k) + (\\alpha_P \\Delta t) s_P(t_k) g_P(\\theta_j)\n$$\nThis update is applied iteratively for each time step $k$ from $0$ to $N_t - 1$, starting with the initial condition $c_P(\\theta_j, t_0) = 0$ for all $j$. The calculation can be vectorized across all spatial points $\\theta_j$ at each time step.\n\n**3. Calculation of Time-Averaged Pathway Response**\n\nAfter computing the full time-evolution of the concentrations $c_P(\\theta_j, t_k)$, we determine the time-averaged pathway response $r_P(\\theta_j)$. This involves two steps for each pathway $P$ and spatial point $\\theta_j$: a nonlinear transduction via a Hill function, followed by time integration.\nThe Hill function is given by:\n$$\nH(x; K_P, h_P) = \\frac{x^{h_P}}{K_P^{h_P} + x^{h_P}}\n$$\nWe apply this function to the concentration time-series $c_P(\\theta_j, t_k)$ for each $k=0, \\dots, N_t$. The time-averaged response $r_P(\\theta_j)$ is the integral:\n$$\nr_P(\\theta_j) = \\frac{1}{T} \\int_{0}^{T} H(c_P(\\theta_j, t); K_P, h_P) \\, \\mathrm{d}t\n$$\nThis integral is approximated numerically using the trapezoidal rule, which provides greater accuracy than a simple Riemann sum:\n$$\nr_P(\\theta_j) \\approx \\frac{1}{T} \\sum_{k=0}^{N_t-1} \\frac{H(c_P(\\theta_j, t_k)) + H(c_P(\\theta_j, t_{k+1}))}{2} \\Delta t = \\frac{1}{T} \\cdot \\mathrm{trapz}(H(c_P(\\theta_j, :)), \\mathrm{dx}=\\Delta t)\n$$\nThis computation yields three spatial profiles of integrated pathway response: $r_{\\mathcal{N}}(\\theta_j)$, $r_{\\mathcal{W}}(\\theta_j)$, and $r_{\\mathcal{B}}(\\theta_j)$.\n\n**4. Fate Allocation by Score Maximization**\n\nThe germ layer fate at each location $\\theta_j$ is determined by comparing three fate scores, which are functions of the aformentioned response profiles:\n$$\nS_{\\mathrm{end}}(\\theta_j) = r_{\\mathcal{N}}(\\theta_j) \\left(1 - \\frac{1}{2} r_{\\mathcal{B}}(\\theta_j)\\right)\n$$\n$$\nS_{\\mathrm{mes}}(\\theta_j) = r_{\\mathcal{W}}(\\theta_j) r_{\\mathcal{B}}(\\theta_j) \\left(\\frac{1}{2} + \\frac{1}{2} r_{\\mathcal{N}}(\\theta_j)\\right)\n$$\n$$\nS_{\\mathrm{ect}}(\\theta_j) = \\left(1 - r_{\\mathcal{N}}(\\theta_j)\\right) \\left(1 - r_{\\mathcal{W}}(\\theta_j)\\right) \\left(\\frac{1}{2} + \\frac{1}{2} r_{\\mathcal{B}}(\\theta_j)\\right)\n$$\nThe fate assigned to location $\\theta_j$ is the one corresponding to the maximum score. The problem specifies a deterministic tie-breaking rule: endoderm $>$ mesoderm $>$ ectoderm. This hierarchy is implemented by checking for the maximum score in this precise order. Programmatically, this can be achieved by stacking the scores in the order $[S_{\\mathrm{end}}, S_{\\mathrm{mes}}, S_{\\mathrm{ect}}]$ and finding the index of the maximum value along this new axis. The `argmax` function, which returns the index of the first occurrence of the maximum, naturally enforces this tie-breaking rule.\n\n**5. Calculation of Area Fractions**\n\nThe final step is to compute the fraction of the total spherical surface area occupied by each germ layer. For a given fate $i \\in \\{\\mathrm{ect}, \\mathrm{mes}, \\mathrm{end}\\}$, the area fraction $f_i$ is given by the integral:\n$$\nf_i = \\frac{\\int_{0}^{\\pi} \\mathbf{1}[\\theta \\in \\mathcal{F}_i] \\sin(\\theta) \\, \\mathrm{d}\\theta}{\\int_{0}^{\\pi} \\sin(\\theta) \\, \\mathrm{d}\\theta} = \\frac{1}{2} \\int_{0}^{\\pi} \\mathbf{1}[\\theta \\in \\mathcal{F}_i] \\sin(\\theta) \\, \\mathrm{d}\\theta\n$$\nwhere $\\mathbf{1}[\\theta \\in \\mathcal{F}_i]$ is an indicator function that is $1$ if the fate at $\\theta$ is $i$, and $0$ otherwise. We approximate this integral numerically, again using the trapezoidal rule for superior accuracy, applied to the discrete grid $\\theta_j$:\n$$\nf_i \\approx \\frac{1}{2} \\cdot \\mathrm{trapz}(\\mathbf{1}[\\theta_j \\in \\mathcal{F}_i] \\sin(\\theta_j), \\mathrm{x}=\\theta_j)\n$$\nWe perform this calculation for each of the three fates. The resulting fractions $f_{\\mathrm{ect}}, f_{\\mathrm{mes}}, f_{\\mathrm{end}}$ must sum to $1$, up to numerical precision errors. The final values are to be reported rounded to three decimal places.\n\nThis completes the logical design of the simulation. The implementation will follow these steps for each of the four test cases provided.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    # --- Model Parameters ---\n    # Shared geometry and dynamics\n    T = 10.0\n    DT = 0.01\n    N_THETA = 1001  # Number of spatial grid points for theta\n\n    # Pathway-specific parameters\n    PATHWAYS = ['Nodal', 'Wnt', 'BMP']\n    LAMBDAS = {'Nodal': 1.0, 'Wnt': 1.0, 'BMP': 1.0}\n    ALPHAS = {'Nodal': 1.0, 'Wnt': 1.0, 'BMP': 1.0}\n    MUS = {'Nodal': 2.4, 'Wnt': np.pi / 2, 'BMP': 0.4}\n    SIGMAS = {'Nodal': 0.5, 'Wnt': 0.5, 'BMP': 0.5}\n    KS = {'Nodal': 0.5, 'Wnt': 0.5, 'BMP': 0.5}\n    HS = {'Nodal': 2.0, 'Wnt': 2.0, 'BMP': 2.0}\n\n    # --- Test Cases ---\n    # Each case is a tuple of (A_N, t_on_N, tau_N, A_W, t_on_W, tau_W, A_B, t_on_B, tau_B)\n    test_cases = [\n        (1.0, 0.0, 3.0, 1.0, 2.0, 3.0, 1.0, 4.0, 3.0),  # Case 1: Sequential\n        (1.0, 0.0, 3.0, 1.0, 0.0, 3.0, 1.0, 0.0, 3.0),  # Case 2: Synchronous\n        (1.0, 4.0, 3.0, 1.0, 2.0, 3.0, 1.0, 0.0, 3.0),  # Case 3: Reverse Sequential\n        (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),  # Case 4: Null\n    ]\n\n    # --- Discretization Setup ---\n    theta_grid = np.linspace(0, np.pi, N_THETA)\n    n_t_steps = int(T / DT)\n    time_grid = np.linspace(0, T, n_t_steps + 1)\n\n    results = []\n    for case in test_cases:\n        source_params = {\n            'Nodal': {'A': case[0], 't_on': case[1], 'tau': case[2]},\n            'Wnt': {'A': case[3], 't_on': case[4], 'tau': case[5]},\n            'BMP': {'A': case[6], 't_on': case[7], 'tau': case[8]},\n        }\n\n        r = {}  # To store time-averaged responses r_P(theta)\n\n        for p_name in PATHWAYS:\n            # Get parameters for the current pathway\n            lambda_p, alpha_p = LAMBDAS[p_name], ALPHAS[p_name]\n            mu_p, sigma_p = MUS[p_name], SIGMAS[p_name]\n            K_p, h_p = KS[p_name], HS[p_name]\n            A_p = source_params[p_name]['A']\n            t_on_p = source_params[p_name]['t_on']\n            tau_p = source_params[p_name]['tau']\n\n            # Spatial sensitivity profile\n            g_p = np.exp(-((theta_grid - mu_p)**2) / (2 * sigma_p**2))\n\n            # --- ODE Integration (Forward Euler) ---\n            c_history = np.zeros((n_t_steps + 1, N_THETA))\n            for k in range(n_t_steps):\n                t_k = time_grid[k]\n                \n                # Rectangular pulse source term\n                s_p_k = A_p if t_on_p <= t_k < t_on_p + tau_p else 0.0\n                \n                # Euler update step (vectorized over theta)\n                c_current = c_history[k, :]\n                c_next = (c_current * (1 - lambda_p * DT) + \n                          (alpha_p * DT) * s_p_k * g_p)\n                c_history[k + 1, :] = c_next\n            \n            # --- Time-Averaged Response Calculation ---\n            # Hill function transduction\n            with np.errstate(divide='ignore', invalid='ignore'):\n                 c_history_h = np.power(c_history, h_p)\n                 K_p_h = K_p**h_p\n                 H_history = np.nan_to_num(c_history_h / (K_p_h + c_history_h))\n\n            # Numerical integration using trapezoidal rule\n            r[p_name] = (1 / T) * np.trapz(H_history, dx=DT, axis=0)\n\n        # Unpack responses\n        r_N, r_W, r_B = r['Nodal'], r['Wnt'], r['BMP']\n\n        # --- Fate Scoring ---\n        S_end = r_N * (1 - 0.5 * r_B)\n        S_mes = r_W * r_B * (0.5 + 0.5 * r_N)\n        S_ect = (1 - r_N) * (1 - r_W) * (0.5 + 0.5 * r_B)\n\n        # --- Fate Allocation with Tie-breaking ---\n        # Stacking order (end, mes, ect) implements the tie-breaking rule\n        # because np.argmax returns the index of the first maximum.\n        scores = np.stack([S_end, S_mes, S_ect], axis=0)\n        # fate_indices: 0=end, 1=mes, 2=ect\n        fate_indices = np.argmax(scores, axis=0)\n\n        # --- Area Fraction Calculation ---\n        # Integrands for each fate\n        integrand_end = (fate_indices == 0) * np.sin(theta_grid)\n        integrand_mes = (fate_indices == 1) * np.sin(theta_grid)\n        integrand_ect = (fate_indices == 2) * np.sin(theta_grid)\n\n        # Numerical integration using trapezoidal rule\n        f_end = 0.5 * np.trapz(integrand_end, x=theta_grid)\n        f_mes = 0.5 * np.trapz(integrand_mes, x=theta_grid)\n        f_ect = 0.5 * np.trapz(integrand_ect, x=theta_grid)\n\n        # Append results in specified order: [ect, mes, end]\n        results.append([f_ect, f_mes, f_end])\n\n    # --- Format and Print Final Output ---\n    case_results_str = []\n    for res in results:\n        # Round to three decimal places and format as a string list\n        case_results_str.append(f\"[{res[0]:.3f},{res[1]:.3f},{res[2]:.3f}]\")\n\n    final_output_str = f\"[{','.join(case_results_str)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2780289"}, {"introduction": "Beyond chemical signals, cells in developing tissues constantly sense and respond to their physical environment. This practice focuses on mechanotransduction, a key process where substrate stiffness non-autonomously directs cell fate. You will construct a quantitative model that connects substrate Young's modulus to the nuclear localization of the YAP/TAZ proteins and, subsequently, to transcriptional activity and a binary fate decision, providing insight into how physical cues are integrated into cellular decision-making programs [@problem_id:2780330].", "problem": "You are modeling how Yes-associated protein (YAP) and transcriptional coactivator with PDZ-binding motif (TAZ) mechanotransduction couples substrate stiffness to cell fate decisions in synthetic embryo-like structures and organoids. Build a minimal systems model that links substrate stiffness to nuclear translocation and transcriptional output, then converts transcriptional output to a fate decision probability. Use only first-principles kinetic balance and standard sigmoidal response curves as foundational bases, and derive any steady-state relations required from these bases. Implement the derived relations in a program that evaluates a specified test suite.\n\nFoundational bases to use:\n- Mass-action compartmental kinetics with conservation for nuclear-cytoplasmic shuttling of YAP/TAZ under steady state.\n- Saturating Hill-type response of actomyosin-mediated mechanosensing to substrate stiffness.\n- Saturating Hill-type transcriptional activation as a function of nuclear YAP/TAZ fraction.\n- A logistic input-output mapping from transcriptional activity to the probability of a binary fate choice.\n\nModel structure and definitions:\n- Let $Y_{\\text{N}}$ and $Y_{\\text{C}}$ be the nuclear and cytoplasmic fractions of the total YAP/TAZ pool, with $Y_{\\text{N}} + Y_{\\text{C}} = 1$. Let $k_{\\text{in}}(E)$ be the nuclear import rate, and $k_{\\text{out}}$ be the nuclear export rate. The dynamics obey\n$$\\frac{dY_{\\text{N}}}{dt} = k_{\\text{in}}(E)\\,Y_{\\text{C}} - k_{\\text{out}}\\,Y_{\\text{N}}.$$\nImpose steady state, and derive the steady-state nuclear fraction $f_{\\text{N}} = Y_{\\text{N}}^{\\ast}$ in terms of $k_{\\text{in}}(E)$ and $k_{\\text{out}}$ and the conservation constraint.\n- The import rate $k_{\\text{in}}(E)$ increases with substrate Young’s modulus $E$ via a mechanosensor $M(E)$ captured by a Hill function with coefficient $n$ and stiffness scale $K_{E}$:\n$$M(E) = \\frac{E^{n}}{K_{E}^{n} + E^{n}},\\quad k_{\\text{in}}(E) = k_{\\text{in0}}\\left(1 + \\alpha\\,M(E)\\right).$$\n- Transcriptional activity $A$ driven by nuclear YAP/TAZ is a Hill function of $f_{\\text{N}}$ with Hill coefficient $m$ and half-activation $K_{T}$:\n$$A = T_{\\max}\\,\\frac{f_{\\text{N}}^{m}}{K_{T}^{m} + f_{\\text{N}}^{m}}.$$\n- The probability of adopting fate $\\mathcal{F}_{A}$ versus an alternative fate $\\mathcal{F}_{B}$ is given by a logistic function of $A$ with slope $\\beta$ and midpoint $A_{50}$:\n$$p_{A} = \\frac{1}{1 + \\exp\\!\\left(-\\beta\\,(A - A_{50})\\right)}.$$\n\nParameter values:\n- Basal import rate $k_{\\text{in0}} = 0.02\\,\\text{s}^{-1}$.\n- Export rate $k_{\\text{out}} = 0.05\\,\\text{s}^{-1}$.\n- Mechanosensitivity amplitude $\\alpha = 8$ (dimensionless).\n- Mechanosensor Hill coefficient $n = 2$ (dimensionless).\n- Stiffness half-saturation $K_{E} = 5\\,\\text{kPa}$.\n- Maximum transcriptional activity $T_{\\max} = 1$ (dimensionless).\n- Transcriptional Hill coefficient $m = 3$ (dimensionless).\n- Transcriptional half-activation $K_{T} = 0.5$ (dimensionless, in units of $f_{\\text{N}}$).\n- Logistic slope $\\beta = 8$ (dimensionless).\n- Logistic midpoint $A_{50} = 0.4$ (dimensionless).\n\nUnits and inputs:\n- Substrate stiffness $E$ must be supplied in $\\text{kPa}$.\n- The output probability $p_{A}$ must be reported as a decimal fraction in $[0,1]$.\n\nTasks:\n- From the steady-state condition and conservation, derive an explicit expression for $f_{\\text{N}}$ in terms of $k_{\\text{in}}(E)$ and $k_{\\text{out}}$.\n- Compose the mappings $E \\mapsto M(E) \\mapsto k_{\\text{in}}(E) \\mapsto f_{\\text{N}} \\mapsto A \\mapsto p_{A}$ and implement them numerically.\n\nTest suite:\n- Evaluate the model for the following substrate stiffness values (all in $\\text{kPa}$): $E \\in \\{0,\\,0.2,\\,1,\\,5,\\,20,\\,100\\}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each $p_{A}$ rounded to $6$ decimal places, in the same order as the test suite (e.g., $\"[0.123456,0.234567,\\dots]\"$).", "solution": "The problem statement has been evaluated and is determined to be valid. It is scientifically grounded, well-posed, objective, and provides a complete, consistent set of definitions and parameters for a standard systems biology model. It is a tractable problem in computational modeling, not an ill-posed or pseudo-profound question. We will therefore proceed with the solution.\n\nThe solution requires two sequential tasks: first, the derivation of an analytical expression, and second, the numerical implementation of the full model.\n\n**1. Derivation of Steady-State Nuclear YAP/TAZ Fraction**\n\nThe dynamics of the nuclear fraction of YAP/TAZ, $Y_{\\text{N}}$, are given by the ordinary differential equation:\n$$\n\\frac{dY_{\\text{N}}}{dt} = k_{\\text{in}}(E)\\,Y_{\\text{C}} - k_{\\text{out}}\\,Y_{\\text{N}}\n$$\nHere, $Y_{\\text{C}}$ is the cytoplasmic fraction, $k_{\\text{in}}(E)$ is the stiffness-dependent nuclear import rate, and $k_{\\text{out}}$ is the constant nuclear export rate.\n\nThe total YAP/TAZ pool is conserved, so the fractions must sum to unity:\n$$\nY_{\\text{N}} + Y_{\\text{C}} = 1\n$$\nThis allows us to express $Y_{\\text{C}}$ in terms of $Y_{\\text{N}}$ as $Y_{\\text{C}} = 1 - Y_{\\text{N}}$.\n\nThe problem requires the steady-state solution. At steady state, the net change in nuclear concentration is zero. We denote the steady-state fractions as $Y_{\\text{N}}^{\\ast}$ and $Y_{\\text{C}}^{\\ast}$. The condition is:\n$$\n\\frac{dY_{\\text{N}}}{dt} = 0\n$$\nSubstituting the expressions for the rates and concentrations gives:\n$$\nk_{\\text{in}}(E)\\,Y_{\\text{C}}^{\\ast} - k_{\\text{out}}\\,Y_{\\text{N}}^{\\ast} = 0\n$$\nWe now use the conservation law to eliminate $Y_{\\text{C}}^{\\ast}$:\n$$\nk_{\\text{in}}(E)\\,(1 - Y_{\\text{N}}^{\\ast}) - k_{\\text{out}}\\,Y_{\\text{N}}^{\\ast} = 0\n$$\nThe problem defines the steady-state nuclear fraction as $f_{\\text{N}} = Y_{\\text{N}}^{\\ast}$. We solve the above linear algebraic equation for $f_{\\text{N}}$:\n$$\nk_{\\text{in}}(E) - k_{\\text{in}}(E)\\,f_{\\text{N}} - k_{\\text{out}}\\,f_{\\text{N}} = 0\n$$\n$$\nk_{\\text{in}}(E) = f_{\\text{N}}\\,(k_{\\text{in}}(E) + k_{\\text{out}})\n$$\nIsolating $f_{\\text{N}}$ yields the explicit expression in terms of the kinetic rates:\n$$\nf_{\\text{N}} = \\frac{k_{\\text{in}}(E)}{k_{\\text{in}}(E) + k_{\\text{out}}}\n$$\nThis completes the first task. This expression demonstrates that the steady-state nuclear fraction is a simple ratiometric function of the import and export rates.\n\n**2. Composition of Mappings and Numerical Evaluation**\n\nThe second task is to compose the full sequence of mappings from substrate stiffness $E$ to the fate decision probability $p_{A}$ and to evaluate this model for a given test suite. The sequence of calculations is as follows, with all parameters taken from the problem statement.\n\nStep 1: Calculate the mechanosensor activity $M(E)$ as a function of substrate stiffness $E$ (in units of $\\text{kPa}$).\n$$\nM(E) = \\frac{E^{n}}{K_{E}^{n} + E^{n}}\n$$\nwith $n=2$ and $K_{E}=5\\,\\text{kPa}$.\n\nStep 2: Calculate the nuclear import rate $k_{\\text{in}}(E)$ as a function of $M(E)$.\n$$\nk_{\\text{in}}(E) = k_{\\text{in0}}\\left(1 + \\alpha\\,M(E)\\right)\n$$\nwith $k_{\\text{in0}}=0.02\\,\\text{s}^{-1}$ and $\\alpha=8$.\n\nStep 3: Calculate the steady-state nuclear fraction $f_{\\text{N}}$ using the derived expression.\n$$\nf_{\\text{N}}(E) = \\frac{k_{\\text{in}}(E)}{k_{\\text{in}}(E) + k_{\\text{out}}}\n$$\nwith $k_{\\text{out}}=0.05\\,\\text{s}^{-1}$.\n\nStep 4: Calculate the transcriptional activity $A$ as a function of $f_{\\text{N}}$.\n$$\nA(f_{\\text{N}}) = T_{\\max}\\,\\frac{f_{\\text{N}}^{m}}{K_{T}^{m} + f_{\\text{N}}^{m}}\n$$\nwith $T_{\\max}=1$, $m=3$, and $K_{T}=0.5$.\n\nStep 5: Calculate the final probability of fate $\\mathcal{F}_{A}$, denoted $p_{A}$, as a function of $A$.\n$$\np_{A}(A) = \\frac{1}{1 + \\exp\\!\\left(-\\beta\\,(A - A_{50})\\right)}\n$$\nwith $\\beta=8$ and $A_{50}=0.4$.\n\nThese five steps compose the complete function $p_{A}(E)$. We will now implement this sequence numerically for each value of $E$ in the test suite $\\{0,\\,0.2,\\,1,\\,5,\\,20,\\,100\\}\\,\\text{kPa}$. The final program will execute this chain of calculations and format the output as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the YAP/TAZ mechanotransduction model for a given test suite of substrate stiffness values.\n    \"\"\"\n    # Define model parameters as provided in the problem statement.\n    k_in0 = 0.02   # Basal import rate (s^-1)\n    k_out = 0.05   # Export rate (s^-1)\n    alpha = 8.0    # Mechanosensitivity amplitude (dimensionless)\n    n = 2.0        # Mechanosensor Hill coefficient (dimensionless)\n    K_E = 5.0      # Stiffness half-saturation (kPa)\n    T_max = 1.0    # Maximum transcriptional activity (dimensionless)\n    m = 3.0        # Transcriptional Hill coefficient (dimensionless)\n    K_T = 0.5      # Transcriptional half-activation (dimensionless fraction)\n    beta = 8.0     # Logistic slope (dimensionless)\n    A_50 = 0.4     # Logistic midpoint (dimensionless)\n\n    # Define the test suite of substrate stiffness values.\n    test_cases_E = [0.0, 0.2, 1.0, 5.0, 20.0, 100.0]\n\n    # List to store the calculated probabilities.\n    results = []\n\n    # Iterate through each stiffness value and calculate the fate probability.\n    for E in test_cases_E:\n        # Step 1: Calculate mechanosensor activity M(E).\n        # The term E^n can be zero, so we handle division by zero for E=0\n        # although adding a small epsilon is more robust, direct check is fine here.\n        if E == 0.0:\n            M_E = 0.0\n        else:\n            M_E = (E**n) / (K_E**n + E**n)\n\n        # Step 2: Calculate the stiffness-dependent nuclear import rate k_in(E).\n        k_in_E = k_in0 * (1.0 + alpha * M_E)\n\n        # Step 3: Calculate the steady-state nuclear fraction f_N.\n        f_N = k_in_E / (k_in_E + k_out)\n\n        # Step 4: Calculate transcriptional activity A.\n        A = T_max * (f_N**m) / (K_T**m + f_N**m)\n        \n        # Step 5: Calculate the probability of fate A, p_A.\n        p_A = 1.0 / (1.0 + np.exp(-beta * (A - A_50)))\n        \n        # Append the formatted result to the list.\n        results.append(f\"{p_A:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver function.\nsolve()\n```", "id": "2780330"}, {"introduction": "Observing a pattern in a synthetic organoid is only the first step; the next is to infer the mechanism that created it. This advanced practice challenges you to design and implement a quantitative test to distinguish between two fundamental modes of pattern formation: spontaneous symmetry breaking and boundary-driven polarity. By employing spatial autocorrelation analysis and Fourier-based statistical controls, you will learn how to move beyond qualitative observation to rigorously test hypotheses about the underlying principles governing self-organization in your experimental data [@problem_id:2780370].", "problem": "Design and implement a complete, runnable program that quantitatively distinguishes boundary-driven polarity from spontaneous symmetry breaking in two-dimensional scalar fields modeling marker distributions across circular synthetic organoid domains. Your program must implement a decision test built from first principles using spatial autocorrelation and a phase-randomization control. The fundamental base you must use consists of: (i) the definition of spatial autocorrelation via Moran’s I (Moran’s I (MI)), (ii) the notion of a boundary distance field on a circular domain, and (iii) the construction of a surrogate null model by amplitude-preserving Fourier phase randomization. You must not use any shortcuts beyond these principles.\n\nDefinitions and required computations:\n- Spatial autocorrelation: Given a scalar field $X$ defined on pixels indexed by $i \\in \\{1,\\dots,N\\}$ inside a binary circular mask $\\mathcal{M}$, Moran’s I (MI) is defined for a symmetric binary nearest-neighbor weight matrix $W = [w_{ij}]$ where $w_{ij} = 1$ if $i$ and $j$ are four-neighbors on the orthogonal grid and both lie in $\\mathcal{M}$, and $w_{ij} = 0$ otherwise. Let $\\bar{X} = \\frac{1}{|\\mathcal{M}|}\\sum_{i \\in \\mathcal{M}} X_i$ and $S_0 = \\sum_{i}\\sum_{j} w_{ij}$. Then\n$$\nI = \\frac{|\\mathcal{M}|}{S_0} \\cdot \\frac{\\sum_{i}\\sum_{j} w_{ij}\\,(X_i - \\bar{X})(X_j - \\bar{X})}{\\sum_{i \\in \\mathcal{M}} (X_i - \\bar{X})^2}.\n$$\n- Boundary distance field: For a circular mask of radius $R$ centered at $(c_x,c_y)$, define the Euclidean distance to boundary for pixel at $(x,y)$ as $d_b(x,y) = R - \\sqrt{(x-c_x)^2 + (y-c_y)^2}$ inside the circle, and $d_b(x,y) = 0$ outside. Normalize to $[0,1]$ as $\\tilde{d}_b = d_b / R$ on $\\mathcal{M}$.\n- Boundary coupling statistic: Compute the Pearson correlation coefficient between $X$ and $\\tilde{d}_b$ across pixels in $\\mathcal{M}$. Let this correlation be $\\rho$ and define $|\\rho|$ to be the magnitude.\n- Phase-randomized surrogates: Let $\\mathcal{F}\\{X\\}$ denote the two-dimensional Discrete Fourier Transform of the full image where pixels outside $\\mathcal{M}$ are set to zero. Construct surrogate fields $X^{(s)}$ by preserving the amplitude spectrum $|\\mathcal{F}\\{X\\}|$ and randomizing phases uniformly on $[-\\pi,\\pi]$, enforcing Hermitian symmetry so that the inverse transform is real. Multiply the reconstructed field by the mask $\\mathcal{M}$ to restore the domain. This creates a null ensemble that matches the observed power spectrum (and thus overall spatial autocorrelation scale) but destroys specific phase alignments. For each surrogate, compute the magnitude of the boundary coupling $|\\rho^{(s)}|$ relative to $\\tilde{d}_b$. From $S$ surrogates, estimate the mean $\\mu_{\\mathrm{null}}$ and standard deviation $\\sigma_{\\mathrm{null}}$ of $|\\rho^{(s)}|$. Define the $z$-score\n$$\nz = \\frac{|\\rho| - \\mu_{\\mathrm{null}}}{\\sigma_{\\mathrm{null}} + \\epsilon},\n$$\nwith a small $\\epsilon$ to avoid division by zero.\n\nDecision rule grounded in the above:\n- First, assess whether a spatial pattern is present by requiring sufficiently positive spatial autocorrelation: call “no pattern” if $I < \\tau_I$.\n- Otherwise, assess boundary-driven polarity by the boundary coupling significance: call “boundary-driven polarity” if $z \\ge \\tau_z$, and call “spontaneous symmetry breaking” if $z < \\tau_z$.\n- Use $\\tau_I = 0.02$, $\\tau_z = 3.0$, and $\\epsilon = 10^{-9}$.\n\nTest suite to ensure coverage:\nAll fields are generated on a square grid of size $N \\times N$ with $N = 64$, with a circular mask centered at $(c_x,c_y) = (N/2,N/2)$ and radius $R = 28$. The program must internally synthesize the following four cases, using independent random seeds for reproducibility. Noise is independent and identically distributed Gaussian noise added after generating the base field; the standard deviation $\\sigma$ is specified per case. The base field is always set to zero outside the mask.\n1) Boundary-driven, radially centered-high: Base field $X(x,y) = \\tilde{d}_b(x,y)$ for $(x,y) \\in \\mathcal{M}$, plus noise with $\\sigma = 0.05$. Random seed $s = 1$.\n2) Spontaneous symmetry breaking, linear dipole: Let $\\mathbf{u} = (\\cos\\theta, \\sin\\theta)$ with fixed $\\theta = 37^\\circ$ in radians. Base field $X(x,y) = \\frac{(x-c_x)u_x + (y-c_y)u_y}{R}$ for $(x,y) \\in \\mathcal{M}$, plus noise with $\\sigma = 0.05$. Random seed $s = 2$.\n3) No pattern (white noise): Base field $X(x,y) = 0$ for all $(x,y)$; add noise with $\\sigma = 1.0$. Random seed $s = 3$.\n4) Boundary-driven, radially peripheral-high: Base field $X(x,y) = 1 - \\tilde{d}_b(x,y)$ for $(x,y) \\in \\mathcal{M}$, plus noise with $\\sigma = 0.05$. Random seed $s = 4$.\n\nSurrogate configuration: Use $S = 64$ surrogates for each case.\n\nRequired outputs and format:\n- For each case, output a classification integer: $0$ for “no pattern,” $1$ for “spontaneous symmetry breaking,” and $2$ for “boundary-driven polarity.”\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., “[2,1,0,2]”), corresponding to the four cases in the order listed above.\n- No user input is provided; the program must be fully self-contained and reproducible.\n\nScientific realism constraints:\n- Ensure that all computations are done only on pixels inside $\\mathcal{M}$ for statistics that require domain-restricted averages and correlations.\n- The construction of phase-randomized surrogates must strictly preserve the amplitude spectrum $|\\mathcal{F}\\{X\\}|$ and enforce Hermitian symmetry to ensure real-valued inverse transforms, thereby providing a valid control that preserves spatial autocorrelation length scales while eliminating boundary-phase coupling.", "solution": "The problem statement presented is valid. It is scientifically grounded in the principles of spatial statistics and signal processing, well-posed with a complete and consistent set of definitions, and objective in its formulation. It requests the implementation of a quantitative test to distinguish between two fundamental modes of pattern formation in biological systems—boundary-driven polarity and spontaneous symmetry breaking—modeled as scalar fields on a circular domain. The entire procedure is verifiable and computationally tractable. We will proceed with a rigorous, step-by-step implementation built from the specified first principles.\n\nThe solution is constructed by implementing a sequence of algorithms, each corresponding to a specific conceptual step in the decision-making process.\n\n**1. Generation of Synthetic Data and Reference Fields**\n\nFirst, we establish the computational domain. We define a square grid of size $N \\times N$ with $N=64$. Upon this grid, a circular mask $\\mathcal{M}$ is defined, centered at $(c_x, c_y) = (N/2, N/2)$ with a radius of $R=28$. A pixel at grid coordinates $(i, j)$ belongs to the mask if $\\sqrt{(i-c_x)^2 + (j-c_y)^2} < R$.\n\nThe problem requires a **boundary distance field**, which serves as a spatial template for radially organized patterns. For each pixel at $(x,y)$ inside the mask, the Euclidean distance to the boundary is defined as $d_b(x,y) = R - \\sqrt{(x-c_x)^2 + (y-c_y)^2}$. This field is normalized by the radius $R$ to create a dimensionless field $\\tilde{d}_b = d_b / R$ that ranges from $0$ at the boundary to $1$ at the center.\n\nFour test cases are synthesized as specified. Each case represents a different class of spatial pattern on the circular domain. A base field is generated and then perturbed by additive Gaussian noise with a specified standard deviation $\\sigma$, using a unique random seed for reproducibility. The final field $X$ is masked, meaning its value is set to $0$ outside of $\\mathcal{M}$.\n\n- **Case 1 (Boundary-driven, center-high):** $X(x,y) = \\tilde{d}_b(x,y) + \\text{noise}(\\sigma=0.05)$.\n- **Case 2 (Spontaneous dipole):** $X(x,y) = ((x-c_x)u_x + (y-c_y)u_y)/R + \\text{noise}(\\sigma=0.05)$, with $\\mathbf{u}$ being a unit vector at a fixed angle. This represents a linear gradient, a simple form of spontaneous symmetry breaking not aligned with the circular boundary.\n- **Case 3 (No pattern):** $X(x,y) = \\text{noise}(\\sigma=1.0)$, representing spatially uncorrelated white noise.\n- **Case 4 (Boundary-driven, periphery-high):** $X(x,y) = 1 - \\tilde{d}_b(x,y) + \\text{noise}(\\sigma=0.05)$.\n\n**2. Spatial Autocorrelation: Moran's I**\n\nThe first step in the decision rule is to determine if any significant spatial pattern exists. We use **Moran's I**, a measure of global spatial autocorrelation. The formula is:\n$$\nI = \\frac{|\\mathcal{M}|}{S_0} \\cdot \\frac{\\sum_{i \\in \\mathcal{M}}\\sum_{j \\in \\mathcal{M}} w_{ij}\\,(X_i - \\bar{X})(X_j - \\bar{X})}{\\sum_{i \\in \\mathcal{M}} (X_i - \\bar{X})^2}\n$$\nHere, $|\\mathcal{M}|$ is the number of pixels within the mask. $\\bar{X}$ is the mean value of the field $X$ over the mask. The weight matrix $W=[w_{ij}]$ is defined such that $w_{ij}=1$ if pixels $i$ and $j$ are four-connected neighbors (up, down, left, right) and both are within $\\mathcal{M}$; otherwise, $w_{ij}=0$. The term $S_0 = \\sum_i \\sum_j w_{ij}$ is the total sum of weights, which corresponds to twice the number of neighbor links within the mask.\n\nThe numerator, $\\sum_i \\sum_j w_{ij}(X_i - \\bar{X})(X_j - \\bar{X})$, quantifies the covariance between pixel values and the values of their neighbors. This term can be computed efficiently. Let $X'$ be the mean-centered field ($X' = X - \\bar{X}$ within $\\mathcal{M}$, and $0$ outside). The sum can be written as $\\sum_i X'_i (\\sum_j w_{ij} X'_j)$. The inner sum, $\\sum_j w_{ij} X'_j$, is a discrete convolution of the field $X'$ with a kernel representing the 4-neighbor connectivity. This is implemented using `scipy.ndimage.convolve`. We classify the pattern as \"no pattern\" (code $0$) if $I < \\tau_I = 0.02$.\n\n**3. Boundary Coupling Statistic**\n\nIf a pattern is detected ($I \\ge \\tau_I$), we must distinguish its origin. A key discriminator is the pattern's alignment with the circular boundary. We quantify this using the **Pearson correlation coefficient**, $\\rho$, between the data field $X$ and the normalized boundary distance field $\\tilde{d}_b$. The correlation is computed only over the pixels within the mask $\\mathcal{M}$.\n$$\n\\rho = \\frac{\\sum_{i \\in \\mathcal{M}} (X_i - \\bar{X})(\\tilde{d}_{b,i} - \\bar{\\tilde{d}}_b)}{\\sqrt{\\sum_{i \\in \\mathcal{M}} (X_i - \\bar{X})^2 \\sum_{i \\in \\mathcal{M}} (\\tilde{d}_{b,i} - \\bar{\\tilde{d}}_b)^2}}\n$$\nSince a boundary-driven pattern could be either high at the center (positive correlation) or high at the periphery (negative correlation), we use the magnitude of the correlation, $|\\rho|$, as our statistic.\n\n**4. Null Model via Phase-Randomized Surrogates**\n\nA high value of $|\\rho|$ could arise by chance, especially if the field has strong, low-frequency spatial correlations. To assess the statistical significance of the observed $|\\rho|$, we compare it against a null distribution. This null distribution is generated using **amplitude-preserving phase-randomization**.\n\nThe procedure is as follows:\n1.  Compute the 2D Discrete Fourier Transform of the data field $X$, yielding complex coefficients $\\mathcal{F}\\{X\\}$. For efficiency and to correctly handle the hermitian symmetry of real-valued data, we use the real-to-complex transform `numpy.fft.rfft2`.\n2.  Preserve the amplitude spectrum, $|\\mathcal{F}\\{X\\}|$, of the original data. This ensures that the surrogate fields will have the same power spectrum and, therefore, the same overall spatial autocorrelation characteristics (e.g., the same expected value of Moran's I).\n3.  Randomize the phase of each Fourier coefficient by drawing from a uniform distribution on $[0, 2\\pi)$. To ensure the inverse transform results in a real-valued field, the phases of the DC component ($k=0$) and Nyquist-frequency components are set to $0$.\n4.  Construct the surrogate Fourier spectrum $\\mathcal{F}\\{X^{(s)}\\}$ using the original amplitudes and the new random phases.\n5.  Apply the inverse Fourier transform (`numpy.fft.irfft2`) to obtain a real-valued surrogate field $X^{(s)}$.\n6.  Finally, re-apply the circular mask $\\mathcal{M}$ to the surrogate.\n\nThis process generates surrogate fields that are statistically similar to the original field in terms of their spatial texture and autocorrelation length scales, but any specific phase alignment—such as that which would cause a strong correlation with the radial boundary distance field—is destroyed. This provides a robust null hypothesis.\n\n**5. The Decision Rule**\n\nBy generating a large number of surrogates ($S=64$), we create an ensemble of $|\\rho^{(s)}|$ values. From this ensemble, we estimate the mean $\\mu_{\\mathrm{null}}$ and standard deviation $\\sigma_{\\mathrm{null}}$. The significance of the observed boundary coupling $|\\rho|$ is then quantified by the $z$-score:\n$$\nz = \\frac{|\\rho| - \\mu_{\\mathrm{null}}}{\\sigma_{\\mathrm{null}} + \\epsilon}\n$$\nwhere $\\epsilon=10^{-9}$ is a small constant to prevent division by zero.\n\nA large $z$-score indicates that the observed correlation with the boundary is highly unlikely to have occurred by chance, given the field's intrinsic spatial structure. The final classification follows:\n- If $z \\ge \\tau_z = 3.0$: The pattern is significantly coupled to the boundary. We classify it as **\"boundary-driven polarity\"** (code $2$).\n- If $z < \\tau_z = 3.0$: The pattern exists ($I \\ge \\tau_I$) but is not significantly coupled to the boundary. We classify it as **\"spontaneous symmetry breaking\"** (code $1$).\n\nThis complete algorithm will be applied to each of the four test cases to generate the final output.", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import convolve\n\ndef solve():\n    \"\"\"\n    Main function to run the classification on the four test cases.\n    \"\"\"\n    \n    # Define parameters from the problem statement\n    params = {\n        'N': 64,          # Grid size\n        'R': 28,          # Mask radius\n        'S': 64,          # Number of surrogates\n        'tau_I': 0.02,    # Moran's I threshold\n        'tau_z': 3.0,     # Z-score threshold\n        'epsilon': 1e-9   # Epsilon for z-score calculation\n    }\n\n    test_cases = [\n        {'case_id': 1, 'type': 'boundary-driven_center-high', 'sigma': 0.05, 'seed': 1},\n        {'case_id': 2, 'type': 'spontaneous_dipole', 'sigma': 0.05, 'seed': 2},\n        {'case_id': 3, 'type': 'no_pattern_noise', 'sigma': 1.0, 'seed': 3},\n        {'case_id': 4, 'type': 'boundary-driven_periphery-high', 'sigma': 0.05, 'seed': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate the specific data field for the current test case\n        X, M, d_b_norm = generate_test_case(case, params)\n        \n        # Classify the pattern\n        classification = classify_pattern(X, M, d_b_norm, params)\n        results.append(classification)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_test_case(case_info, params):\n    \"\"\"\n    Generates the scalar field X, mask M, and boundary distance field d_b_norm for a given test case.\n    \"\"\"\n    N = params['N']\n    R = params['R']\n    cx, cy = N / 2, N / 2\n    \n    np.random.seed(case_info['seed'])\n\n    # Create grid and mask\n    x = np.arange(N)\n    y = np.arange(N)\n    xx, yy = np.meshgrid(x, y)\n    dist_from_center = np.sqrt((xx - cx)**2 + (yy - cy)**2)\n    M = dist_from_center < R\n    \n    # Create normalized boundary distance field\n    d_b = R - dist_from_center\n    d_b_norm = np.zeros_like(d_b)\n    d_b_norm[M] = d_b[M] / R\n\n    # Generate the base field based on the case type\n    base_field = np.zeros((N, N))\n    if case_info['type'] == 'boundary-driven_center-high':\n        base_field = d_b_norm\n    elif case_info['type'] == 'spontaneous_dipole':\n        theta = np.deg2rad(37)\n        u = np.array([np.cos(theta), np.sin(theta)])\n        base_field = ((xx - cx) * u[0] + (yy - cy) * u[1]) / R\n    elif case_info['type'] == 'no_pattern_noise':\n        pass # Base field remains zero\n    elif case_info['type'] == 'boundary-driven_periphery-high':\n        base_field = 1.0 - d_b_norm\n        \n    # Add noise and apply mask\n    noise = np.random.normal(0, case_info['sigma'], (N, N))\n    X = base_field + noise\n    X[~M] = 0.0\n    \n    return X, M, d_b_norm\n\ndef calculate_morans_i(X, M):\n    \"\"\"\n    Calculates Moran's I for a given field X on a mask M.\n    \"\"\"\n    num_pixels_in_mask = np.sum(M)\n    if num_pixels_in_mask <= 1:\n        return 0.0\n\n    X_masked_vals = X[M]\n    mean_X = np.mean(X_masked_vals)\n    \n    # Create mean-centered field\n    X_centered = np.zeros_like(X)\n    X_centered[M] = X_masked_vals - mean_X\n\n    # Define 4-neighbor kernel\n    kernel = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n    \n    # Calculate sum of weights S0\n    W_matrix_image = convolve(M.astype(float), kernel, mode='constant', cval=0.0) * M\n    S0 = np.sum(W_matrix_image)\n    if S0 == 0:\n        return 0.0\n\n    # Numerator term calculation using convolution\n    convolved_X_centered = convolve(X_centered, kernel, mode='constant', cval=0.0)\n    numerator = np.sum(X_centered * convolved_X_centered)\n    \n    # Denominator term\n    denominator = np.sum(X_centered**2)\n    if denominator == 0:\n        return 0.0\n\n    I = (num_pixels_in_mask / S0) * (numerator / denominator)\n    return I\n\ndef calculate_boundary_coupling(X, d_b_norm, M):\n    \"\"\"\n    Calculates the absolute Pearson correlation between X and the boundary distance field.\n    \"\"\"\n    X_vec = X[M]\n    d_vec = d_b_norm[M]\n    \n    if len(X_vec) < 2:\n        return 0.0\n        \n    # np.corrcoef returns a matrix, we need the off-diagonal element\n    corr_matrix = np.corrcoef(X_vec, d_vec)\n    rho = corr_matrix[0, 1]\n    \n    return np.abs(rho)\n\ndef generate_surrogates(X, M, S):\n    \"\"\"\n    Generates phase-randomized surrogate fields.\n    \"\"\"\n    N, _ = X.shape\n    \n    # Compute FFT of the real-valued input field\n    F = np.fft.rfft2(X)\n    amplitudes = np.abs(F)\n\n    surrogates = []\n    for _ in range(S):\n        # Generate random phases\n        random_phases = np.random.uniform(0, 2 * np.pi, size=F.shape)\n        \n        # Create surrogate Fourier spectrum\n        F_surr = amplitudes * np.exp(1j * random_phases)\n        \n        # Enforce reality condition for real-valued output.\n        # DC component (0,0) and Nyquist frequencies must have phase 0 or pi.\n        # We set them to be real for simplicity.\n        F_surr[0, 0] = amplitudes[0, 0] # DC component must be real\n        if N % 2 == 0:\n            F_surr[N//2, 0] = amplitudes[N//2, 0] # Nyquist freq must be real\n            if F.shape[1] > N//2:\n                 F_surr[N//2, -1] = amplitudes[N//2, -1]\n        if F.shape[1] > N//2 and (N//2)*2 +1 == X.shape[1]:\n            F_surr[0, -1] = amplitudes[0, -1]\n\n        # Inverse FFT to get real-valued surrogate field\n        surrogate = np.fft.irfft2(F_surr, s=(N, N))\n        \n        # Apply mask\n        surrogate[~M] = 0.0\n        surrogates.append(surrogate)\n        \n    return surrogates\n\ndef classify_pattern(X, M, d_b_norm, params):\n    \"\"\"\n    Implements the full decision rule to classify the pattern.\n    \"\"\"\n    # Unpack parameters\n    tau_I = params['tau_I']\n    tau_z = params['tau_z']\n    S = params['S']\n    epsilon = params['epsilon']\n\n    # Step 1: Check for presence of a pattern using Moran's I\n    I = calculate_morans_i(X, M)\n    if I < tau_I:\n        return 0  # No pattern\n\n    # Step 2: Calculate observed boundary coupling\n    rho_obs = calculate_boundary_coupling(X, d_b_norm, M)\n    \n    # Step 3: Generate surrogates and their boundary couplings for the null model\n    surrogate_fields = generate_surrogates(X, M, S)\n    rho_surrogates = [calculate_boundary_coupling(s, d_b_norm, M) for s in surrogate_fields]\n\n    # Step 4: Calculate z-score\n    mu_null = np.mean(rho_surrogates)\n    sigma_null = np.std(rho_surrogates)\n    \n    z_score = (rho_obs - mu_null) / (sigma_null + epsilon)\n    \n    # Step 5: Apply decision rule based on z-score\n    if z_score >= tau_z:\n        return 2  # Boundary-driven polarity\n    else:\n        return 1  # Spontaneous symmetry breaking\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2780370"}]}