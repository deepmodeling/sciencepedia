{"hands_on_practices": [{"introduction": "Before diving into the specific techniques of random mutagenesis and DNA shuffling, it is crucial to understand the strategic context in which these powerful methods are employed. Protein engineering largely follows two philosophies: rational design, which relies on detailed structural and mechanistic knowledge to make targeted changes, and directed evolution, which uses iterative cycles of diversification and selection to search for improved functions. This first exercise [@problem_id:2108796] challenges you to consider a scenario with a newly discovered protein of unknown structure and function, articulating the fundamental reason for choosing one approach over the other. This practice solidifies your understanding of the core principles and informational requirements that guide modern protein engineering strategies.", "problem": "A team of biochemists has discovered a novel protein, which they have named \"Cryopro,\" in a species of Antarctic bacteria. The protein's amino acid sequence has been determined, but it shares no significant resemblance to any protein with a known three-dimensional structure or biological function in existing databases. The team's objective is to engineer Cryopro so that it binds with high specificity to a small-molecule biomarker associated with cellular damage from ice crystals. They must decide between two primary protein engineering strategies: rational design or directed evolution (e.g., using a method like yeast display or phage display).\n\nWhich of the following statements presents the most fundamental reason why a directed evolution approach is more suitable than a rational design approach in this specific scenario?\n\nA. Rational design is based on computational algorithms that are known to be inaccurate for proteins originating from extremophilic organisms like Antarctic bacteria.\n\nB. Directed evolution is inherently superior because it mimics the process of natural selection, which always produces more stable and active proteins than human-designed ones.\n\nC. Rational design requires pre-existing knowledge of the protein's three-dimensional structure and/or a well-understood mechanism of action to make targeted, purposeful mutations, which is completely lacking for Cryopro.\n\nD. Directed evolution methods like yeast display are necessary because they are the only techniques capable of introducing mutations into a protein's genetic code; rational design works by chemically modifying the protein itself.\n\nE. The high cost and specialized equipment required for the computational simulations in rational design make it impractical for academic research labs, which typically favor the lower cost of directed evolution.", "solution": "We evaluate the suitability of rational design versus directed evolution under the given constraints by analyzing the information requirements and methodological principles of each approach.\n\nRational design relies on making targeted sequence changes based on explicit hypotheses about structure-function relationships. The core prerequisite is prior knowledge such as a high-resolution three-dimensional structure, validated binding pockets, or at least a well-understood mechanistic model that links specific residues or motifs to the desired function. In the absence of structural homology and with no known mechanism for Cryopro, there is no reliable basis for hypothesizing which mutations will enhance binding to the biomarker. Without such information, rational design becomes guesswork rather than principled engineering.\n\nDirected evolution, in contrast, does not require prior structural or mechanistic knowledge. It leverages genotype-phenotype linkage and selection to empirically search sequence space for variants with a desired function (e.g., binding specificity), allowing the system to discover beneficial mutations through iterative diversification and selection. This is particularly advantageous when starting information is minimal, as is the case here.\n\nOption A is not a fundamental reason: rational design is not exclusively computational, and extremophilic origin does not categorically invalidate computational models. Option B is incorrect: directed evolution is not inherently superior nor does it always yield more stable or active proteins. Option D is false: both rational design and directed evolution introduce genetic mutations; rational design is not limited to chemical modification of proteins. Option E appeals to cost rather than the central methodological limitation, and is not the most fundamental reason.\n\nTherefore, the most fundamental reason is that rational design requires structural and/or mechanistic knowledge that is lacking for Cryopro, making directed evolution more suitable in this scenario.", "answer": "$$\\boxed{C}$$", "id": "2108796"}, {"introduction": "Once the path of directed evolution is chosen, the next critical step is to generate genetic diversity. While methods like error-prone PCR introduce mutations randomly across an entire gene, a more focused approach is often desired, especially when structural or functional data suggest a key residue is involved. This practice problem [@problem_id:2108788] presents a common scenario where the goal is to explore every possible amino acid substitution at a single, critical position. Your task is to select the most efficient and precise molecular technique for creating such a \"site-saturation\" library, thereby honing your ability to match experimental goals with the appropriate mutagenesis tools.", "problem": "A protein engineer is investigating the catalytic mechanism of a novel enzyme. Through structural analysis, they hypothesize that a specific tryptophan residue at position 88 (Trp88) plays a critical role in substrate binding. To test this hypothesis experimentally, the engineer aims to create a comprehensive mutational library where the Trp88 residue is systematically replaced by all 19 other standard proteinogenic amino acids. This library of gene variants will then be expressed, and the resulting proteins will be screened for their binding affinity.\n\nWhich of the following molecular biology techniques is the most direct and efficient method for generating the gene library described?\n\nA. Error-prone Polymerase Chain Reaction (PCR) performed on the entire gene.\n\nB. Site-directed mutagenesis using a single, specific, non-degenerate primer pair that changes the codon for Trp88 to the codon for Alanine.\n\nC. DNA shuffling using the wild-type gene and a set of homologous genes from related species.\n\nD. Site-directed mutagenesis using a degenerate primer containing an \"NNK\" codon at the position corresponding to residue 88.\n\nE. Random insertion mutagenesis using a transposon-based system.", "solution": "Goal: Generate a focused library in which a single codon (for Trp88) is diversified to encode all $19$ alternative standard amino acids, efficiently and directly at that position.\n\nEvaluate each option against the goal:\n- Option A (error-prone PCR): Error-prone PCR introduces random point mutations throughout the entire gene with a tunable but distributed mutation rate. It is not targeted to a single codon and will introduce many off-target mutations, producing a heterogeneous library that is inefficient for isolating the specific set of $19$ single-site substitutions at residue $88$. Therefore, it is not the most direct or efficient approach for this specific library.\n\n- Option B (site-directed mutagenesis with a non-degenerate primer to Alanine): This produces a single specific substitution (Trp88 to Ala88). It cannot generate the full set of $19$ substitutions in one step, so it is not suitable for creating the comprehensive library.\n\n- Option C (DNA shuffling): DNA shuffling recombines homologous sequences to redistribute existing mutations among related sequences. It is not designed to introduce all $19$ substitutions at a specific codon in the wild-type gene and would not directly yield the focused single-site variant set.\n\n- Option D (site-directed mutagenesis with a degenerate primer containing an NNK codon at residue $88$): In oligonucleotide notation, $N$ denotes any nucleotide and $K$ denotes $G$ or $T$. An NNK codon ($4 \\times 4 \\times 2 = 32$ codons) covers all $20$ standard amino acids with minimal stop-codon inclusion. Specifically, among stop codons (TAA, TAG, TGA), only TAG fits NNK (third base $G$), so the stop fraction is minimized. Using a degenerate primer bearing NNK exactly at the Trp88 codon generates a focused library comprising all single-codon variants at that position, efficiently covering all $19$ non-tryptophan amino acids (and typically the original Trp as well), with minimal unwanted diversification elsewhere. This is the standard, most direct method for saturation mutagenesis at a single site.\n\n- Option E (random insertion mutagenesis with a transposon): This creates insertions at random positions, often causing frameshifts or disruptive insertions, not single-codon substitutions. It does not generate the desired single-site substitution library.\n\nConclusion: The most direct and efficient technique for generating a comprehensive single-site saturation library at residue $88$ is site-directed mutagenesis using a degenerate NNK codon at the position of interest.\n\nTherefore, the correct choice is D.", "answer": "$$\\boxed{D}$$", "id": "2108788"}, {"introduction": "Moving beyond single-site mutations, DNA shuffling enables the recombination of gene fragments from multiple homologous parents, creating a library of chimeric proteins with novel combinations of pre-existing traits. A key challenge is to predict which chimeras are likely to remain folded and functional. To address this, we can use computational heuristics like the SCHEMA disruption energy, $E$, which quantifies the breakage of co-evolved residue contacts. This advanced computational exercise [@problem_id:2767666] offers a hands-on opportunity to simulate the DNA shuffling process, calculate the distribution of $E$ for the resulting library, and apply statistical analysis to guide library design and screening efforts.", "problem": "You are given aligned parental amino-acid sequences and a residue–residue contact map that defines which positions in the protein structure physically interact. The goal is to model deoxyribonucleic acid (DNA) shuffling as random crossover recombination and to empirically characterize, by simulation, the distribution of SCHEMA disruption energy across random crossover placements. You must then report specified percentile thresholds of the disruption distribution for selection decisions.\n\nBackground and definitions:\n- The Central Dogma establishes that sequence determines structure, and structure constrains function. In recombination of homologous proteins, chimeras are formed by exchanging contiguous sequence fragments between parental sequences.\n- A contact map is a set of undirected pairs of residue indices that are spatially proximal in the native protein fold. Let the aligned sequence length be $L$ and the set of contacts be $C \\subset \\{1,\\dots,L\\} \\times \\{1,\\dots,L\\}$, with $(i,j) \\in C$ implying a contact between positions $i$ and $j$ and $i \\neq j$.\n- SCHEMA disruption energy (commonly written as $E$) is defined here as the number of contacts whose interacting residues in a chimera originate from different parents. Formally, let $p_\\ell \\in \\{1,\\dots,K\\}$ denote the index of the parent that donates residue at position $\\ell$ in the chimera, where $K$ is the number of parents. Then\n$$\nE \\;=\\; \\sum_{(i,j)\\in C} \\mathbf{1}\\{p_i \\neq p_j\\},\n$$\nwhere $\\mathbf{1}\\{\\cdot\\}$ is the indicator function. This definition reflects the heuristic that co-adapted contact pairs are preserved when both residues are co-inherited from the same parent, and disrupted otherwise.\n\nRandom recombination model:\n- You are given $K$ aligned parental sequences of equal length $L$.\n- A chimera is constructed by placing $c$ crossovers uniformly at random without replacement among the $L-1$ possible inter-residue boundaries $\\{1,2,\\dots,L-1\\}$, then sorting them to partition the sequence into $c+1$ contiguous blocks.\n- The parent for the first block is chosen uniformly from $\\{1,\\dots,K\\}$. At each crossover, the next block’s parent is chosen uniformly from the $K-1$ parents different from the current block’s parent (immediate repetition is disallowed).\n- For a given chimera, $E$ is computed exactly from the parent-origin profile $(p_1,\\dots,p_L)$ and the contact set $C$ using the above equation.\n- To characterize the distribution of $E$ for a given set of parameters, simulate $n$ independent chimeras using the model above with a fixed pseudo-random seed for reproducibility. Estimate the requested quantile thresholds by applying the empirical quantile function with linear interpolation consistent with NumPy’s \"linear\" method.\n\nPercentile definition and rounding:\n- For a given list of quantile levels $\\{q_1,\\dots,q_m\\}$ where each $q_r \\in [0,1]$ is given as a decimal fraction, compute the empirical quantiles of the sampled $E$ values using linear interpolation. Report each threshold rounded to three decimal places.\n\nAngle or physical units are not involved; all reported quantities are dimensionless counts. The final outputs must be floats rounded to three decimal places.\n\nTest suite:\nImplement a program that solves the following three test cases. For all cases, contact indices below are one-based; your implementation may convert them to zero-based internally.\n\n- Test case $1$ (general multi-parent, moderate crossovers):\n  - Parents ($K=3$, $L=14$):\n    - Parent $1$: \"MKTLYDNNRVAIQL\"\n    - Parent $2$: \"MKTLYENNKIAVQL\"\n    - Parent $3$: \"MRTLYDGNKIAVAL\"\n  - Contacts $C$ (pairs): $(1,4)$, $(2,5)$, $(3,6)$, $(4,7)$, $(5,8)$, $(6,9)$, $(7,10)$, $(8,11)$, $(9,12)$, $(10,13)$, $(11,14)$, $(2,10)$, $(3,11)$, $(5,12)$, $(6,14)$.\n  - Number of crossovers $c=4$.\n  - Number of simulated chimeras $n=8000$.\n  - Quantiles to report $\\{0.1,0.5,0.9\\}$.\n  - Random seed $=123456$.\n\n- Test case $2$ (boundary: zero crossovers):\n  - Parents and contacts: identical to Test case $1$.\n  - Number of crossovers $c=0$.\n  - Number of simulated chimeras $n=4000$.\n  - Quantiles to report $\\{0.25,0.5,0.75\\}$.\n  - Random seed $=2024$.\n\n- Test case $3$ (two parents, many crossovers):\n  - Parents ($K=2$, $L=20$):\n    - Parent $1$: \"MKKTAIAALAGLVAGFAQDN\"\n    - Parent $2$: \"MKETAIAALVGIVAGFAQEN\"\n  - Contacts $C$ (pairs): $(1,4)$, $(2,5)$, $(3,6)$, $(4,7)$, $(5,8)$, $(6,9)$, $(7,10)$, $(8,11)$, $(9,12)$, $(10,13)$, $(11,14)$, $(12,15)$, $(13,16)$, $(14,17)$, $(15,18)$, $(16,19)$, $(17,20)$, $(5,15)$, $(6,16)$, $(7,17)$, $(8,18)$, $(9,19)$, $(10,20)$.\n  - Number of crossovers $c=9$.\n  - Number of simulated chimeras $n=6000$.\n  - Quantiles to report $\\{0.05,0.5,0.95\\}$.\n  - Random seed $=777$.\n\nProgram requirements:\n- Your program must implement the stochastic procedure exactly as specified, using the provided seeds for reproducibility.\n- For each test case in order, compute the requested quantile thresholds for the distribution of $E$ over $n$ simulated chimeras, rounding each to three decimal places.\n- Final output format: a single line containing a comma-separated flat list of all quantile thresholds across the three test cases, in the order the test cases and their quantiles are listed above, enclosed in square brackets. For example, if Test case $1$ produces three thresholds $t_{1,1},t_{1,2},t_{1,3}$, Test case $2$ produces $t_{2,1},t_{2,2},t_{2,3}$, and Test case $3$ produces $t_{3,1},t_{3,2},t_{3,3}$, your program must print\n\"[t_{1,1},t_{1,2},t_{1,3},t_{2,1},t_{2,2},t_{2,3},t_{3,1},t_{3,2},t_{3,3}]\" with each value rounded to three decimal places and no additional whitespace.", "solution": "The problem statement is a valid, well-posed computational biology problem. It requires the simulation of a stochastic model of protein recombination and the subsequent statistical analysis of a heuristic energy function. All parameters and definitions are provided with sufficient precision to construct a unique, reproducible solution.\n\nThe problem asks to characterize the distribution of SCHEMA disruption energy, denoted as $E$, arising from a model of DNA shuffling. This is achieved by simulating the creation of $n$ chimeric sequences and calculating $E$ for each. The final objective is to report specific quantile values of the resulting empirical distribution of $E$. The entire procedure will be implemented for three distinct test cases.\n\nThe core of the solution is a stochastic simulation. For each test case, specified by the number of parents $K$, sequence length $L$, a set of contacts $C$, the number of crossovers $c$, the number of simulations $n$, and a random seed, the following steps are executed:\n\n1.  **Initialization**: A pseudo-random number generator is initialized with the specified seed to ensure reproducibility. The contact map $C$, given in $1$-based indexing, is converted to $0$-based indexing for computational convenience. An array is prepared to store the $n$ calculated energy values.\n\n2.  **Chimera Simulation and Energy Calculation**: A loop is executed $n$ times. In each iteration, one chimeric sequence is modeled and its disruption energy $E$ is calculated.\n\n    a.  **Parent-of-Origin Profile Generation**: A chimera is represented by a parent-of-origin vector $\\mathbf{p} = (p_0, p_1, \\dots, p_{L-1})$, where each element $p_i \\in \\{1, \\dots, K\\}$ indicates the parent from which the residue at position $i$ was inherited. This vector is constructed as follows:\n        -   First, $c$ unique crossover locations are chosen uniformly at random from the $L-1$ possible inter-residue boundaries. These locations are sorted to partition the sequence into $c+1$ contiguous blocks.\n        -   A parent for the first block (from index $0$ to the first crossover) is selected uniformly at random from the set of $K$ parents.\n        -   For each subsequent block, a parent is chosen uniformly at random from the set of $K-1$ parents that are different from the parent of the immediately preceding block. This process defines the full parent-of-origin vector $\\mathbf{p}$.\n        -   A special case exists when $c=0$. In this scenario, no crossovers occur, and the entire sequence is inherited from a single, randomly chosen parent.\n\n    b.  **SCHEMA Disruption Energy ($E$) Calculation**: Once the parent profile $\\mathbf{p}$ is determined, the SCHEMA disruption energy $E$ is calculated using the provided formula:\n        $$ E \\;=\\; \\sum_{(i,j)\\in C} \\mathbf{1}\\{p_i \\neq p_j\\} $$\n        where $\\mathbf{1}\\{\\cdot\\}$ is the indicator function, which is $1$ if the condition is true and $0$ otherwise. This sum counts the number of contacts in the protein structure where the two interacting residues originate from different parents. For computational efficiency, this calculation is vectorized. A boolean mask is created by comparing the parent indices for all contact pairs $(i,j)$, and the energy $E$ is the sum of this mask.\n\n3.  **Statistical Analysis**: After completing all $n$ simulations, the collected list of $n$ energy values forms an empirical distribution of $E$. The problem requires estimating specific quantiles $\\{q_1, \\dots, q_m\\}$ from this distribution. This is accomplished using the `numpy.quantile` function, which implements the specified linear interpolation method (`interpolation='linear'`). This method accurately computes the value at a given quantile, interpolating between the two nearest data points if the quantile falls between them.\n\n4.  **Final Output**: The calculated quantile values for each test case are rounded to three decimal places. These values are then aggregated from all three test cases into a single, flat list. The final output is a string representation of this list, formatted exactly as specified: enclosed in square brackets, with elements separated by commas.\n\nThe specific case of $c=0$ (Test Case 2) serves as an important sanity check. With zero crossovers, the parent profile $\\mathbf{p}$ for any chimera will consist of a single parent index repeated $L$ times. Consequently, for any contact $(i,j)$, $p_i$ will always equal $p_j$, making the disruption energy $E = \\sum \\mathbf{1}\\{p_i \\neq p_j\\} = \\sum 0 = 0$. This holds for all $n$ simulations. Therefore, the empirical distribution of $E$ is a delta function at $0$, and any quantile of this distribution must also be $0$. The implementation must correctly reproduce this deterministic outcome.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DNA shuffling simulation problem for the three specified test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"K\": 3, \"L\": 14,\n            \"contacts\": [(1,4), (2,5), (3,6), (4,7), (5,8), (6,9), (7,10), (8,11), (9,12), (10,13), (11,14), (2,10), (3,11), (5,12), (6,14)],\n            \"c\": 4, \"n\": 8000,\n            \"quantiles\": [0.1, 0.5, 0.9],\n            \"seed\": 123456\n        },\n        {\n            \"K\": 3, \"L\": 14,\n            \"contacts\": [(1,4), (2,5), (3,6), (4,7), (5,8), (6,9), (7,10), (8,11), (9,12), (10,13), (11,14), (2,10), (3,11), (5,12), (6,14)],\n            \"c\": 0, \"n\": 4000,\n            \"quantiles\": [0.25, 0.5, 0.75],\n            \"seed\": 2024\n        },\n        {\n            \"K\": 2, \"L\": 20,\n            \"contacts\": [(1,4), (2,5), (3,6), (4,7), (5,8), (6,9), (7,10), (8,11), (9,12), (10,13), (11,14), (12,15), (13,16), (14,17), (15,18), (16,19), (17,20), (5,15), (6,16), (7,17), (8,18), (9,19), (10,20)],\n            \"c\": 9, \"n\": 6000,\n            \"quantiles\": [0.05, 0.5, 0.95],\n            \"seed\": 777\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        K, L, contacts_1based, c, n, quantiles, seed = case.values()\n        \n        # Initialize the random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Convert 1-based contact indices to 0-based for array access\n        # and pre-calculate vectors of i and j indices for contacts\n        contacts_0based = np.array(contacts_1based) - 1\n        contacts_i = contacts_0based[:, 0]\n        contacts_j = contacts_0based[:, 1]\n        \n        # Array to store the SCHEMA disruption energies for n simulations\n        E_samples = np.empty(n, dtype=np.int16)\n\n        # Pre-generate parent choice sets\n        all_possible_parents = np.arange(1, K + 1)\n\n        for i in range(n):\n            # Generate one chimera and calculate its disruption energy\n            parent_profile = np.empty(L, dtype=np.int8)\n\n            if c == 0:\n                # With zero crossovers, the whole sequence has one parent\n                parent = rng.integers(1, K + 1)\n                parent_profile.fill(parent)\n            else:\n                # Choose c unique crossover locations from L-1 possibilities\n                crossover_locs = rng.choice(L - 1, size=c, replace=False)\n                crossover_locs.sort()\n                \n                # Define block boundaries (start inclusive, end exclusive)\n                boundaries = np.concatenate(([0], crossover_locs + 1, [L]))\n\n                # Assign parents to blocks sequentially\n                current_parent = rng.choice(all_possible_parents)\n                \n                for j in range(c + 1):\n                    start, end = boundaries[j], boundaries[j+1]\n                    parent_profile[start:end] = current_parent\n                    \n                    # For the next block, choose a different parent\n                    if j  c: # No need to choose a next parent after the last block\n                        if K > 1:\n                            # Choose from parents that are not the current one\n                            parent_choices = all_possible_parents[all_possible_parents != current_parent]\n                            current_parent = rng.choice(parent_choices)\n                        # If K=1, parent remains the same (though c>0, K=1 is ill-defined)\n            \n            # Vectorized calculation of SCHEMA disruption energy\n            parents_at_i = parent_profile[contacts_i]\n            parents_at_j = parent_profile[contacts_j]\n            energy = np.sum(parents_at_i != parents_at_j)\n            E_samples[i] = energy\n\n        # Calculate empirical quantiles using linear interpolation\n        calculated_quantiles = np.quantile(E_samples, quantiles, interpolation='linear')\n        \n        # Round results to three decimal places and add to the final list\n        all_results.extend(np.round(calculated_quantiles, 3))\n\n    # Format and print the final output string\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2767666"}]}