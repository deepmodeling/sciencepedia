{"hands_on_practices": [{"introduction": "Before writing any model, we must understand the fundamental constructs that define its behavior over time. This exercise challenges you to correctly distinguish between SBML's `initialAssignment`, `assignmentRule`, and `rateRule` constructs, which are essential for defining a model's mathematical meaning. Mastering these is crucial for translating biological hypotheses into models that behave as intended, whether you are defining initial conditions, dynamic state changes, or algebraic constraints [@problem_id:2776394].", "problem": "A systems modeler is encoding a mechanistic model in the Systems Biology Markup Language (SBML), which represents model state variables as time-dependent quantities $x(t)$ that may have an initial value at $t=0$ and may be related by algebraic equalities or by differential equations of the form $dx/dt = f(\\cdot)$. The modeler must choose among three SBML constructs for different semantics: an initial assignment (initialAssignment), an assignment rule (assignmentRule), and a rate rule (rateRule). In SBML, an initial assignment sets the value of a symbol at $t=0$ only; an assignment rule enforces an algebraic equality for a symbol at all times $t$; and a rate rule defines the time derivative $dx/dt$ of a symbol.\n\nConsider the following generic modeling needs that commonly arise in synthetic biology models:\n- Algebraic dependency at all times: a quantity $X(t)$ is defined by other quantities via a formula, for example $X(t) = g(Y_1(t),\\dots,Y_n(t))$, and this relationship must hold for all $t$.\n- Dynamic evolution: a quantity $Z(t)$ evolves according to a differential equation, for example $dZ/dt = -k\\,Z$, with an initial condition $Z(0)$ that may be computed from other quantities measured or computed at $t=0$, such as $Z(0) = A(0)/B(0)$.\n- Conservation or tracking: a constraint such as $E_{\\text{tot}} = E(t) + ES(t)$ is intended to hold for all $t$, or a parameter $P$ should equal another changing quantity $X(t)$ at all times.\n- One-time computation: a parameter $P$ should be computed once at $t=0$ from other symbols, $P = h(Q(0))$, and then remain unchanged for $t>0$ even if $Q(t)$ changes.\n\nWhich of the following statements correctly map these semantics to SBML’s initialAssignment, assignmentRule, and rateRule choices, while respecting their definitions and mutual exclusivity constraints?\n\nA. If $X(t)$ must satisfy an algebraic dependency such as $X(t) = g(Y_1(t),\\dots,Y_n(t))$ for all $t$, then implement $X$ with an assignmentRule targeting $X$; do not also give $X$ an initialAssignment or an explicit initial value because the assignmentRule defines $X$ for all $t$, including $t=0$.\n\nB. If $Z(t)$ obeys $dZ/dt = -k\\,Z$ and $Z(0)$ should equal $A(0)/B(0)$, then implement $Z$ with a rateRule $dZ/dt = -k\\,Z$ and provide an initialAssignment setting $Z(0) = A/B$.\n\nC. If the conservation relationship $E_{\\text{tot}} = E(t) + ES(t)$ must hold for all $t$, it suffices to use a single initialAssignment setting $E(0) = E_{\\text{tot}} - ES(0)$; no assignmentRule is needed because the initialization will maintain the identity for $t>0$.\n\nD. If a parameter $P$ should equal $X(t)$ for all $t$ while $X(t)$ changes, the preferred approach is to give $P$ a rateRule $dP/dt = dX/dt$ so that $P$ tracks $X$ over time.\n\nE. If a parameter $P$ should be computed once at $t=0$ as $P = h(Q(0))$ and remain unchanged thereafter even if $Q(t)$ changes, use an initialAssignment for $P$ with the formula $h(Q)$ and do not give $P$ any rule; optionally declare $P$ constant so that it cannot change for $t>0$.\n\nSelect all that apply.", "solution": "The problem statement will first be validated for scientific and logical integrity.\n\n### Step 1: Extract Givens\n\nThe problem provides the following definitions and descriptions related to the Systems Biology Markup Language (SBML):\n- Model state variables are time-dependent quantities, denoted $x(t)$.\n- Variables may have an initial value at $t=0$.\n- Relationships can be algebraic equalities or differential equations of the form $dx/dt = f(\\cdot)$.\n- SBML constructs:\n    - `initialAssignment`: sets the value of a symbol at $t=0$ only.\n    - `assignmentRule`: enforces an algebraic equality for a symbol at all times $t$.\n    - `rateRule`: defines the time derivative $dx/dt$ of a symbol.\n\nThe problem presents four generic modeling needs:\n1.  **Algebraic dependency at all times**: A quantity $X(t)$ is defined by a formula $X(t) = g(Y_1(t),\\dots,Y_n(t))$ for all $t$.\n2.  **Dynamic evolution**: A quantity $Z(t)$ evolves according to $dZ/dt = -k\\,Z$, with an initial condition computed from other quantities at $t=0$, such as $Z(0) = A(0)/B(0)$.\n3.  **Conservation or tracking**: A constraint such as $E_{\\text{tot}} = E(t) + ES(t)$ must hold for all $t$, or a parameter $P$ should equal another changing quantity $X(t)$ at all times.\n4.  **One-time computation**: A parameter $P$ is computed once at $t=0$ from other symbols, $P = h(Q(0))$, and remains unchanged for $t>0$ even if $Q(t)$ changes.\n\nThe task is to identify which of the given statements correctly map these semantics to SBML constructs, respecting their definitions and mutual exclusivity constraints.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement describes a set of common modeling scenarios and asks for their correct implementation using specific constructs from a well-defined standard, SBML.\n- **Scientifically Grounded**: The problem is grounded in the field of computational systems biology and refers to a widely used, formal standard (SBML). The descriptions of `initialAssignment`, `assignmentRule`, and `rateRule` are accurate, albeit simplified, representations of their formal definitions in the SBML specification. The problem context is scientifically valid.\n- **Well-Posed**: The question is clear and unambiguous. It asks to evaluate the correctness of several statements based on the provided definitions. A definite answer can be derived for each statement.\n- **Objective**: The problem is stated in objective terms, based on the formal semantics of a data standard. There is no subjective or opinion-based content.\n\nThe problem is self-contained and internally consistent. The descriptions of the SBML constructs are sufficient to evaluate the options. The modeling scenarios are standard and well-understood in the context of ordinary differential equation (ODE) modeling.\n\n### Step 3: Verdict and Action\n\nThe problem is valid. It is a well-formed question about the correct application of the SBML standard. A rigorous analysis can proceed.\n\n### Solution Derivation\n\nThe analysis will proceed by evaluating each statement (A, B, C, D, E) against the definitions of the SBML constructs provided and their established rules of use.\n\n**A. If $X(t)$ must satisfy an algebraic dependency such as $X(t) = g(Y_1(t),\\dots,Y_n(t))$ for all $t$, then implement $X$ with an assignmentRule targeting $X$; do not also give $X$ an initialAssignment or an explicit initial value because the assignmentRule defines $X$ for all $t$, including $t=0$.**\n\nAn `assignmentRule` is defined to enforce an algebraic equality for all time $t \\ge 0$. If a variable $X$ is the target of an `assignmentRule`, its value is determined at every point in time by that rule's expression. This includes the initial time, $t=0$. Therefore, the value $X(0)$ is computed from the rule $X(0) = g(Y_1(0),\\dots,Y_n(0))$. The SBML standard explicitly forbids a variable that is the target of an `assignmentRule` from also being the target of an `initialAssignment` or having a separately defined initial value. This is because such a situation would create a redundant and potentially conflicting definition for the variable at $t=0$. The statement correctly describes the use of an `assignmentRule` and its exclusivity.\n\nVerdict: **Correct**.\n\n**B. If $Z(t)$ obeys $dZ/dt = -k\\,Z$ and $Z(0)$ should equal $A(0)/B(0)$, then implement $Z$ with a rateRule $dZ/dt = -k\\,Z$ and provide an initialAssignment setting $Z(0) = A/B$.**\n\nA `rateRule` is the correct construct for defining a differential equation, $dZ/dt = -k\\,Z$. A variable governed by a `rateRule` is determined by integration and requires a defined initial condition, $Z(0)$. The problem states that this initial condition is not a fixed number but is computed from the values of other model quantities at $t=0$, here $A(0)$ and $B(0)$. An `initialAssignment` is the specific SBML construct designed for this purpose: it evaluates an expression once at the beginning of the simulation ($t=0$) to set the initial value of a variable. Using a `rateRule` for the dynamics and an `initialAssignment` for the initial condition is the standard and correct pattern in SBML for this scenario.\n\nVerdict: **Correct**.\n\n**C. If the conservation relationship $E_{\\text{tot}} = E(t) + ES(t)$ must hold for all $t$, it suffices to use a single initialAssignment setting $E(0) = E_{\\text{tot}} - ES(0)$; no assignmentRule is needed because the initialization will maintain the identity for $t>0$.**\n\nAn `initialAssignment` sets a value only at $t=0$. It does not impose any constraint for $t>0$. The statement that initialization is *sufficient* to maintain the identity $E_{\\text{tot}} = E(t) + ES(t)$ is generally false. The conservation of a quantity like $E_{tot}$ depends entirely on the dynamics of the system, i.e., the set of differential and algebraic equations governing $E(t)$ and $ES(t)$. While some sets of reactions naturally conserve this sum (e.g., if $dE/dt = -d(ES)/dt$), this is a property of the model's rate laws, not a consequence of initialization. To *enforce* this conservation as a constraint, regardless of the other dynamics, one must use a construct that applies for all time. The correct tool for this is an `assignmentRule`, for example, by defining one of the quantities algebraically, such as $E(t) = E_{\\text{tot}} - ES(t)$. The claim that an `initialAssignment` is sufficient is incorrect.\n\nVerdict: **Incorrect**.\n\n**D. If a parameter $P$ should equal $X(t)$ for all $t$ while $X(t)$ changes, the preferred approach is to give $P$ a rateRule $dP/dt = dX/dt$ so that $P$ tracks $X$ over time.**\n\nThe requirement is to enforce an algebraic equality $P(t) = X(t)$ for all $t$. The SBML construct designed explicitly for this purpose is an `assignmentRule`. One would simply write an `assignmentRule` with the formula $X$ for the variable $P$. The suggested approach of using a `rateRule`, $dP/dt = dX/dt$, is a \"detour\" through calculus. While it is mathematically true that if $P(0) = X(0)$ and their derivatives are equal, then $P(t) = X(t)$, this is not the intended or \"preferred\" method in SBML. It is computationally less efficient and more complex. It requires the symbolic differentiation of $X(t)$, which may not be trivial or even possible for all simulators, and then requires the numerical integrator to solve an additional ODE for $P$. The `assignmentRule` is the direct, declarative, and computationally superior method. Therefore, the statement that the `rateRule` approach is preferred is false.\n\nVerdict: **Incorrect**.\n\n**E. If a parameter $P$ should be computed once at $t=0$ as $P = h(Q(0))$ and remain unchanged thereafter even if $Q(t)$ changes, use an initialAssignment for $P$ with the formula $h(Q)$ and do not give $P$ any rule; optionally declare $P$ constant so that it cannot change for $t>0$.**\n\nThis scenario describes a one-time calculation at the start of a simulation. This is the precise function of an `initialAssignment`. It calculates a value for $P$ at $t=0$ based on the expression $h(Q(0))$. In SBML, if a parameter is not the target of an `assignmentRule` or a `rateRule`, and is not changed by an `event`, its value remains constant throughout the simulation after its initial value is set. Thus, using an `initialAssignment` and no other rules correctly implements the desired behavior. Declaring the parameter $P$ with the attribute `constant=\"true\"` is a further valid step that makes the model more explicit and robust, as it formally forbids any subsequent changes to $P$. This statement accurately describes the correct SBML implementation.\n\nVerdict: **Correct**.\n\nIn summary, statements A, B, and E correctly describe the application of SBML constructs, while C and D propose incorrect or non-standard methods.", "answer": "$$\\boxed{ABE}$$", "id": "2776394"}, {"introduction": "With a grasp of model structure, we now focus on the mathematical implementation of reaction dynamics. This practice guides you through the correct formulation of a mass-action kinetic law, a cornerstone of biochemical modeling, paying strict attention to the rules of SBML's unit system [@problem_id:2776472]. You will learn the critical distinction between species represented by concentration versus amount, a detail essential for building physically meaningful and dimensionally consistent simulations.", "problem": "You are asked to formalize a simple bimolecular reaction in the Systems Biology Markup Language (SBML) and compute its reaction rate consistently with SBML unit semantics. The reaction is $A + B \\xrightarrow{k} C$ in a single well-mixed compartment. You must conceptually construct the SBML entities and, using the law of mass action, derive and implement a kinetic law that yields a production rate for $C$ in amount per time with correct units. Your program will evaluate the derived kinetic law on a provided test suite and validate dimensional consistency by unit algebra.\n\nFundamental base for derivation:\n- Law of mass action: for an elementary bimolecular reaction, the reaction rate is proportional to the product of reactant concentrations.\n- Definitions: concentration $c_X = n_X / V$, where $n_X$ is amount (in $\\mathrm{mol}$) and $V$ is volume (in $\\mathrm{L}$); production rate of $C$ as amount per time is $dn_C/dt$ in $\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n- Unit algebra: treat base units $\\mathrm{mol}$, $\\mathrm{L}$, and $\\mathrm{s}$ with exponent arithmetic under multiplication and division.\n\nSBML entities to be constructed conceptually:\n- Compartment: a single compartment named “cell” with constant size $V$ (units $\\mathrm{L}$).\n- Species: three species $A$, $B$, and $C$. Depending on representation:\n  - If species are represented by amount, use $initialAmount$ with units $\\mathrm{mol}$ and set `hasOnlySubstanceUnits=\"true\"`.\n  - If species are represented by concentration, use $initialConcentration$ with units $\\mathrm{mol}\\,\\mathrm{L}^{-1}$ and set `hasOnlySubstanceUnits=\"false\"`.\n- Parameter: a global parameter $k$ for the rate constant with units $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n- Reaction: a single irreversible reaction $A + B \\rightarrow C$ with a kinetic law that yields $dn_C/dt$ in $\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n\nKinetic law to implement based on representation choice:\n- If species values are amounts $n_A$ and $n_B$ in $\\mathrm{mol}$, then use\n$$\n\\frac{dn_C}{dt} \\;=\\; k\\,\\frac{n_A\\,n_B}{V},\n$$\nwhich has units $\\mathrm{mol}\\,\\mathrm{s}^{-1}$ when $k$ is in $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$ and $V$ in $\\mathrm{L}$.\n- If species values are concentrations $c_A$ and $c_B$ in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$, then use\n$$\n\\frac{dn_C}{dt} \\;=\\; V\\,k\\,c_A\\,c_B,\n$$\nwhich also yields $\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n\nYour program must:\n1. For each test case, compute the numeric production rate of $C$ as $dn_C/dt$ in $\\mathrm{mol}\\,\\mathrm{s}^{-1}$ according to the specified representation (amount or concentration), with $k$ in $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$ and $V$ in $\\mathrm{L}$.\n2. Validate dimensional consistency by computing the composite unit exponents for the kinetic law and checking they equal the target unit $\\mathrm{mol}^1\\,\\mathrm{L}^0\\,\\mathrm{s}^{-1}$.\n3. Output, for each test case, a list of two elements: the computed rate as a float (in $\\mathrm{mol}\\,\\mathrm{s}^{-1}$) and a boolean indicating whether the unit check passed.\n\nPhysical units: all amounts must be in $\\mathrm{mol}$, volumes in $\\mathrm{L}$, time in $\\mathrm{s}$, and concentrations in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$. If a test case specifies a molecular count, convert molecules to moles using Avogadro’s constant $N_A = 6.02214076\\times 10^{23}\\ \\mathrm{mol}^{-1}$.\n\nAngle units do not apply. No percentages are used.\n\nTest suite (all constants and values must be used exactly as specified):\n- Case 1 (amounts, nonzero): $n_A = 2\\times 10^{-6}\\ \\mathrm{mol}$, $n_B = 3\\times 10^{-6}\\ \\mathrm{mol}$, $V = 10^{-3}\\ \\mathrm{L}$, $k = 10^{3}\\ \\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n- Case 2 (concentrations, equivalence check): $c_A = 2\\times 10^{-3}\\ \\mathrm{mol}\\,\\mathrm{L}^{-1}$, $c_B = 3\\times 10^{-3}\\ \\mathrm{mol}\\,\\mathrm{L}^{-1}$, $V = 10^{-3}\\ \\mathrm{L}$, $k = 10^{3}\\ \\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n- Case 3 (boundary, zero reactant): $n_A = 10^{-6}\\ \\mathrm{mol}$, $n_B = 0\\ \\mathrm{mol}$, $V = 10^{-3}\\ \\mathrm{L}$, $k = 10^{3}\\ \\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n- Case 4 (cell-scale amounts via molecules): $N_A = 6.02214076\\times 10^{23}\\ \\mathrm{mol}^{-1}$, $N_A$ must be used to convert molecule counts to moles. Let $n_A = 100/N_A\\ \\mathrm{mol}$ and $n_B = 100/N_A\\ \\mathrm{mol}$, $V = 10^{-15}\\ \\mathrm{L}$, $k = 10^{6}\\ \\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- Each element must itself be a two-element list $[rate,unit\\_ok]$, where $rate$ is the computed float in $\\mathrm{mol}\\,\\mathrm{s}^{-1}$ and $unit\\_ok$ is a boolean.\n- For example, the shape must be like $[[r_1,b_1],[r_2,b_2],[r_3,b_3],[r_4,b_4]]$ with no extra whitespace or text.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded in fundamental principles of chemical kinetics, well-posed, objective, and internally consistent. All necessary parameters and definitions for a unique solution are provided. We may therefore proceed with the derivation and computation.\n\nThe problem requires the formalization and evaluation of a kinetic law for the elementary bimolecular reaction $A + B \\xrightarrow{k} C$ within a single, well-mixed compartment of constant volume $V$. The objective is to compute the production rate of species $C$ in units of amount per time ($\\mathrm{mol}\\,\\mathrm{s}^{-1}$), consistent with the semantics of the Systems Biology Markup Language (SBML).\n\nThe cornerstone of this analysis is the Law of Mass Action. For the given reaction, the rate of reaction, $v$, is proportional to the product of the concentrations of the reactants. Let $[A]$ and $[B]$ denote the concentrations of species $A$ and $B$, respectively. The reaction rate is then given by:\n$$\nv = k [A] [B]\n$$\nThe rate constant $k$ has units that ensure dimensional homogeneity. Since $[A]$ and $[B]$ are in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$, and the reaction rate $v$ is conventionally expressed in concentration per time ($\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$), the units of $k$ must be $(\\mathrm{mol}\\,\\mathrm{L}^{-1})^{-1}\\,\\mathrm{s}^{-1}$, which simplifies to $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$. This matches the units provided in the problem statement.\n\nSBML kinetic laws, however, must be formulated to return a rate of change in amount per time (e.g., $\\mathrm{mol}\\,\\mathrm{s}^{-1}$), not concentration per time. The rate of change of the amount of a species $X$, denoted $n_X$, is related to the reaction rate $v$ and the compartment volume $V$ by:\n$$\n\\frac{dn_X}{dt} = \\nu_X \\cdot V \\cdot v\n$$\nwhere $\\nu_X$ is the stoichiometric coefficient of species $X$ in the reaction. For the product $C$, the stoichiometric coefficient is $\\nu_C = +1$. Therefore, the production rate of $C$ is:\n$$\n\\frac{dn_C}{dt} = V \\cdot v = V \\cdot k [A] [B]\n$$\nThis is the fundamental equation from which we derive the specific kinetic laws based on how species quantities are represented.\n\nThere are two common representations for species in SBML, which the problem requires us to handle:\n\n1.  **Species represented by concentration**: If the model provides species quantities as concentrations $c_A$ and $c_B$ (in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$), we can directly substitute $[A] = c_A$ and $[B] = c_B$ into our fundamental equation:\n    $$\n    \\frac{dn_C}{dt} = V\\,k\\,c_A\\,c_B\n    $$\n    This is the first kinetic law provided in the problem statement.\n\n2.  **Species represented by amount**: If the model provides species quantities as amounts $n_A$ and $n_B$ (in $\\mathrm{mol}$), we must first express their concentrations using the compartment volume $V$. The concentration is defined as amount divided by volume, so $[A] = n_A/V$ and $[B] = n_B/V$. Substituting these into the fundamental equation yields:\n    $$\n    \\frac{dn_C}{dt} = V \\cdot k \\left(\\frac{n_A}{V}\\right) \\left(\\frac{n_B}{V}\\right) = k \\frac{n_A n_B}{V}\n    $$\n    This is the second kinetic law provided in the problem statement.\n\nThe problem also mandates a validation of dimensional consistency. We represent the units in terms of their exponents for the base dimensions of amount ($\\mathrm{mol}$), length cubed or volume ($\\mathrm{L}$), and time ($\\mathrm{s}$). The target unit for $\\frac{dn_C}{dt}$ is $\\mathrm{mol}\\,\\mathrm{s}^{-1}$, corresponding to the exponent vector $[\\mathrm{mol}: 1, \\mathrm{L}: 0, \\mathrm{s}: -1]$.\n\nLet us perform the dimensional analysis for the amount-based representation as an example. The units of the terms are:\n-   $k$: $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1} \\implies [\\mathrm{mol}: -1, \\mathrm{L}: 1, \\mathrm{s}: -1]$\n-   $n_A$, $n_B$: $\\mathrm{mol} \\implies [\\mathrm{mol}: 1, \\mathrm{L}: 0, \\mathrm{s}: 0]$\n-   $V$: $\\mathrm{L} \\implies [\\mathrm{mol}: 0, \\mathrm{L}: 1, \\mathrm{s}: 0]$\n\nFor the expression $k \\frac{n_A n_B}{V}$, we sum the exponents for multiplication and subtract for division:\n-   $\\mathrm{mol}$ exponent: $(-1) + 1 + 1 - 0 = 1$\n-   $\\mathrm{L}$ exponent: $1 + 0 + 0 - 1 = 0$\n-   $\\mathrm{s}$ exponent: $(-1) + 0 + 0 - 0 = -1$\nThe resulting unit exponent vector is $[1, 0, -1]$, which correctly matches the target unit of $\\mathrm{mol}\\,\\mathrm{s}^{-1}$. A similar analysis for the concentration-based formula $V k c_A c_B$ yields the same result, confirming the dimensional consistency of both formulations.\n\nWe now apply these validated formulas to the provided test suite.\n\n**Case 1 (amounts, nonzero):**\n-   Given: $n_A = 2 \\times 10^{-6}\\,\\mathrm{mol}$, $n_B = 3 \\times 10^{-6}\\,\\mathrm{mol}$, $V = 10^{-3}\\,\\mathrm{L}$, $k = 10^3\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n-   Formula: $\\frac{dn_C}{dt} = k \\frac{n_A n_B}{V}$.\n-   Calculation: $\\frac{dn_C}{dt} = (10^3) \\frac{(2 \\times 10^{-6})(3 \\times 10^{-6})}{10^{-3}} = 10^3 \\frac{6 \\times 10^{-12}}{10^{-3}} = 6 \\times 10^{-6}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n-   Result: $[6.0 \\times 10^{-6}, \\mathrm{True}]$.\n\n**Case 2 (concentrations, equivalence check):**\n-   Given: $c_A = 2 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $c_B = 3 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $V = 10^{-3}\\,\\mathrm{L}$, $k = 10^3\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n-   Formula: $\\frac{dn_C}{dt} = V k c_A c_B$.\n-   Calculation: $\\frac{dn_C}{dt} = (10^{-3})(10^3)(2 \\times 10^{-3})(3 \\times 10^{-3}) = 6 \\times 10^{-6}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n-   This result is identical to Case 1, as expected, since the reactant concentrations correspond precisely ($n_A/V = 2 \\times 10^{-6} / 10^{-3} = 2 \\times 10^{-3} = c_A$).\n-   Result: $[6.0 \\times 10^{-6}, \\mathrm{True}]$.\n\n**Case 3 (boundary, zero reactant):**\n-   Given: $n_A = 10^{-6}\\,\\mathrm{mol}$, $n_B = 0\\,\\mathrm{mol}$, $V = 10^{-3}\\,\\mathrm{L}$, $k = 10^3\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n-   Formula: $\\frac{dn_C}{dt} = k \\frac{n_A n_B}{V}$.\n-   Calculation: $\\frac{dn_C}{dt} = (10^3) \\frac{(10^{-6})(0)}{10^{-3}} = 0\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n-   Result: $[0.0, \\mathrm{True}]$.\n\n**Case 4 (cell-scale amounts via molecules):**\n-   Given: $N_\\text{molecules} = 100$, $V = 10^{-15}\\,\\mathrm{L}$, $k = 10^6\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$. Avogadro's constant $N_A = 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1}$.\n-   First, convert molecule counts to moles: $n_A = n_B = 100 / N_A = 100 / (6.02214076 \\times 10^{23})\\,\\mathrm{mol}$.\n-   Formula: $\\frac{dn_C}{dt} = k \\frac{n_A n_B}{V}$.\n-   Calculation: $\\frac{dn_C}{dt} = (10^6) \\frac{(100/N_A)^2}{10^{-15}} = 10^6 \\frac{10^4/N_A^2}{10^{-15}} = \\frac{10^{25}}{N_A^2} = \\frac{10^{25}}{(6.02214076 \\times 10^{23})^2} \\approx 2.757434 \\times 10^{-23}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$.\n-   Result: $[\\approx 2.757434 \\times 10^{-23}, \\mathrm{True}]$.\n\nThe implementation will follow this logic to compute the values for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes reaction rates and validates units for a bimolecular reaction\n    according to SBML semantics.\n    \"\"\"\n    # Avogadro's constant, as specified.\n    N_A = 6.02214076e23\n\n    # Test suite definition. Each case is a dictionary for clarity.\n    test_cases = [\n        {\n            \"type\": \"amount\", \"params\": {\"nA\": 2e-6, \"nB\": 3e-6, \"V\": 1e-3, \"k\": 1e3}\n        },\n        {\n            \"type\": \"concentration\", \"params\": {\"cA\": 2e-3, \"cB\": 3e-3, \"V\": 1e-3, \"k\": 1e3}\n        },\n        {\n            \"type\": \"amount\", \"params\": {\"nA\": 1e-6, \"nB\": 0.0, \"V\": 1e-3, \"k\": 1e3}\n        },\n        {\n            \"type\": \"amount\", \"params\": {\"nA\": 100 / N_A, \"nB\": 100 / N_A, \"V\": 1e-15, \"k\": 1e6}\n        }\n    ]\n\n    def check_units(case_type):\n        \"\"\"\n        Performs dimensional analysis by operating on unit exponent vectors.\n        The base units are [mol, L, s].\n        \"\"\"\n        # Target unit is mol^1 L^0 s^-1\n        target_exponents = np.array([1, 0, -1])\n        \n        # Unit exponents for each parameter\n        unit_exponents = {\n            \"k\": np.array([-1, 1, -1]),  # L / (mol * s)\n            \"V\": np.array([0, 1, 0]),    # L\n            \"n\": np.array([1, 0, 0]),    # mol\n            \"c\": np.array([1, -1, 0]),   # mol / L\n        }\n\n        if case_type == \"amount\":\n            # rate = k * nA * nB / V\n            # units = (k) * (n) * (n) / (V)\n            computed_exponents = (unit_exponents[\"k\"] + \n                                  unit_exponents[\"n\"] + \n                                  unit_exponents[\"n\"] - \n                                  unit_exponents[\"V\"])\n        elif case_type == \"concentration\":\n            # rate = V * k * cA * cB\n            # units = (V) * (k) * (c) * (c)\n            computed_exponents = (unit_exponents[\"V\"] + \n                                  unit_exponents[\"k\"] + \n                                  unit_exponents[\"c\"] + \n                                  unit_exponents[\"c\"])\n        else:\n            # Should not be reached with the current test suite.\n            return False\n\n        return np.array_equal(computed_exponents, target_exponents)\n\n    results = []\n    for case in test_cases:\n        case_type = case[\"type\"]\n        params = case[\"params\"]\n        rate = 0.0\n        \n        # Calculate the rate based on the representation type\n        if case_type == \"amount\":\n            rate = params[\"k\"] * params[\"nA\"] * params[\"nB\"] / params[\"V\"]\n        elif case_type == \"concentration\":\n            rate = params[\"V\"] * params[\"k\"] * params[\"cA\"] * params[\"cB\"]\n        \n        # Perform the unit check\n        unit_ok = check_units(case_type)\n        \n        results.append([rate, unit_ok])\n\n    # The final print statement must follow the exact specified format.\n    # The default str() for a list of lists produces the required output.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2776472"}, {"introduction": "The ultimate goal of using standards is to create seamless, automated workflows that connect design to analysis. This final exercise simulates a complete synthetic biology workflow, linking a design space of promoters (conceived in SBOL), a dynamic model of a genetic circuit (encoded in SBML), and a simulation experiment (described in SED-ML) [@problem_id:2776369]. By implementing a parameter sweep for the classic repressilator, you will experience firsthand how these standards combine to enable the systematic exploration of a design's behavior.", "problem": "You are given a modeling and exchange task that integrates Systems Biology Markup Language (SBML), Synthetic Biology Open Language (SBOL), and Simulation Experiment Description Markup Language (SED-ML) concepts into a single computational experiment. The goal is to design a parameter sweep that systematically explores oscillatory regimes in a repressing ring oscillator model and to report the results back in terms of SBOL variable features that encode promoter strengths.\n\nYou will emulate a Systems Biology Markup Language (SBML) ordinary differential equation model of a three-gene repressing ring oscillator. Denote the concentrations of the gene products by $x(t)$, $y(t)$, and $z(t)$. Assume Hill-type transcriptional repression with Hill coefficient $n$, maximal synthesis rates (promoter strengths) $\\alpha_X$, $\\alpha_Y$, and $\\alpha_Z$, and first-order degradation with rates $\\delta_X$, $\\delta_Y$, and $\\delta_Z$. The model is:\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha_X}{1 + z^n} \\;-\\; \\delta_X x,\\quad\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha_Y}{1 + x^n} \\;-\\; \\delta_Y y,\\quad\n\\frac{dz}{dt} \\;=\\; \\frac{\\alpha_Z}{1 + y^n} \\;-\\; \\delta_Z z.\n$$\nAssume nondimensionalized variables and parameters so that the units are dimensionless; in particular, let $\\delta_X = \\delta_Y = \\delta_Z = 1$ and use a fixed Hill coefficient $n$ common to all three repressors. This is a plausible abstraction derived from mass-action kinetics and the Central Dogma of Molecular Biology, under quasi-steady-state assumptions for transcriptional regulation represented by Hill functions.\n\nA Synthetic Biology Open Language (SBOL) design provides variable features for three promoters, denoted $\\mathrm{P\\_X}$, $\\mathrm{P\\_Y}$, and $\\mathrm{P\\_Z}$, each with a candidate set of promoter strengths. A Simulation Experiment Description Markup Language (SED-ML) parameter sweep defines a Cartesian product over these candidate sets. For each combination $(\\alpha_X,\\alpha_Y,\\alpha_Z)$ from the sweep, you must simulate the SBML-style model over a fixed time horizon and determine whether the time course exhibits sustained oscillations.\n\nDefine “sustained oscillation” operationally as follows. For a given simulation time series for $y(t)$, discard an initial transient portion corresponding to the first half of the simulation time interval, then:\n- Count peaks as the number of indices $i$ in the sampled discrete signal such that $y_i > y_{i-1}$ and $y_i > y_{i+1}$.\n- Compute the post-transient amplitude $\\Delta y$ as $\\max(y) - \\min(y)$ on the post-transient portion.\n- Classify the trajectory as oscillatory if and only if the number of peaks is at least $5$ and the amplitude satisfies $\\Delta y \\ge 0.5$.\n\nAssume all simulations use the same initial condition $x(0) = y(0) = z(0) = 0.1$, the same total time horizon $T = 200$, and uniform sampling at $N = 5000$ points over $[0,T]$. Use a Hill coefficient of $n = 12$ and $\\delta_X = \\delta_Y = \\delta_Z = 1$. All quantities are dimensionless.\n\nImplement a program that adheres to the following constraints and requirements:\n- Emulate the SED-ML parameter sweep by iterating over the Cartesian product of SBOL variable feature candidate lists for promoter strengths. Each candidate list is associated with a promoter via its SBOL variable feature identifier, which in this problem is implicit by order: index $0$ corresponds to $\\mathrm{P\\_X}$, index $1$ to $\\mathrm{P\\_Y}$, and index $2$ to $\\mathrm{P\\_Z}$.\n- For each combination in the sweep, numerically integrate the model, apply the oscillation classifier defined above, and, if oscillatory, record the zero-based index triple $[i,j,k]$, where $i$ is the index into the candidate list for $\\mathrm{P\\_X}$, $j$ for $\\mathrm{P\\_Y}$, and $k$ for $\\mathrm{P\\_Z}$.\n- For each test case defined below, output the sorted list (lexicographic order on $[i,j,k]$) of all index triples classified as oscillatory.\n\nTest suite:\n- Case $1$ (non-oscillatory baseline, low promoter strengths):\n  - $\\mathrm{P\\_X}$ candidates: $[0.5, 1.0]$\n  - $\\mathrm{P\\_Y}$ candidates: $[0.5, 1.0]$\n  - $\\mathrm{P\\_Z}$ candidates: $[0.5, 1.0]$\n- Case $2$ (oscillation-prone, high promoter strengths):\n  - $\\mathrm{P\\_X}$ candidates: $[10.0, 20.0]$\n  - $\\mathrm{P\\_Y}$ candidates: $[10.0, 20.0]$\n  - $\\mathrm{P\\_Z}$ candidates: $[10.0, 20.0]$\n- Case $3$ (asymmetric mixed promoter strengths):\n  - $\\mathrm{P\\_X}$ candidates: $[8.0, 16.0]$\n  - $\\mathrm{P\\_Y}$ candidates: $[2.0, 6.0]$\n  - $\\mathrm{P\\_Z}$ candidates: $[8.0, 16.0]$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the order above and is itself a list of index triples. There must be no whitespace anywhere in the line. For example, a valid output with hypothetical content is:\n- $[[[0,1,1],[1,1,1]],[[0,0,1]],[]]$\n\nYour program must be completely self-contained and require no input. All computations and outputs are in dimensionless units. The final output must be a single line printed exactly in the format described above.", "solution": "The problem statement has been evaluated and is deemed valid. It is scientifically grounded, well-posed, objective, and provides a complete and consistent set of specifications for a computational task in systems biology. The problem requires the emulation of a parameter sweep experiment, as one might define using SED-ML, over a genetic circuit design space represented conceptually by SBOL, with the circuit's dynamics described by an SBML-style ODE model.\n\nThe core of the problem is the analysis of a three-gene transcriptional repressor ring network, commonly known as a repressilator. The dynamics are described by a system of three coupled ordinary differential equations (ODEs):\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha_X}{1 + z^n} \\;-\\; \\delta_X x \\\\\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha_Y}{1 + x^n} \\;-\\; \\delta_Y y \\\\\n\\frac{dz}{dt} \\;=\\; \\frac{\\alpha_Z}{1 + y^n} \\;-\\; \\delta_Z z\n$$\nHere, $x(t)$, $y(t)$, and $z(t)$ represent the concentrations of the three gene products. Repression of each gene by the product of another is modeled using a Hill function, where the term $1/(1 + P^n)$ describes the repressive effect of a protein $P$. The parameter $n$ is the Hill coefficient, which determines the steepness of the repressive response. The parameters $\\alpha_X$, $\\alpha_Y$, and $\\alpha_Z$ represent the maximal synthesis rates, conceptually equivalent to promoter strengths. The parameters $\\delta_X$, $\\delta_Y$, and $\\delta_Z$ represent first-order degradation rates.\n\nThe problem specifies dimensionless parameters: a common degradation rate $\\delta_X = \\delta_Y = \\delta_Z = 1$ and a Hill coefficient $n = 12$. The parameter sweep involves systematically varying the promoter strengths $(\\alpha_X, \\alpha_Y, \\alpha_Z)$ through a Cartesian product of candidate sets provided for three test cases.\n\nFor each specific combination of $(\\alpha_X, \\alpha_Y, \\alpha_Z)$, the system of ODEs constitutes an initial value problem (IVP) with the specified initial condition $x(0) = y(0) = z(0) = 0.1$. This IVP is solved numerically over a time interval of $t \\in [0, T]$, where $T=200$. The solution is sampled at $N=5000$ uniformly spaced time points. The numerical integration will be performed using a robust adaptive solver, specifically the `solve_ivp` function from the `scipy.integrate` library, which is well-suited for such systems, including potentially stiff ones that can arise from high Hill coefficients.\n\nFollowing the numerical simulation, each resulting trajectory is classified as either oscillatory or non-oscillatory based on a precise, operational definition applied to the time series of the $y(t)$ component. The analysis is restricted to the post-transient phase, defined as the second half of the simulation time interval, from $t=100$ to $t=200$. The corresponding samples of the discrete time series, from index $N/2$ to $N-1$, are used.\n\nThe classification is based on two criteria which must both be met:\n1.  **Amplitude Threshold**: The post-transient amplitude, calculated as $\\Delta y = \\max(y_{\\text{post-transient}}) - \\min(y_{\\text{post-transient}})$, must be greater than or equal to a threshold of $0.5$.\n2.  **Peak Count**: The number of local maxima in the post-transient $y(t)$ signal must be at least $5$. A peak is strictly defined as a point $y_i$ that is greater than its immediate neighbors, i.e., $y_i > y_{i-1}$ and $y_i > y_{i+1}$.\n\nThe overall procedure is as follows:\nFirst, we structure the program to handle the three distinct test cases. For each case, we iterate through all combinations of promoter strengths defined by the candidate lists. This is achieved by taking the Cartesian product of the index ranges of the candidate lists. For each resulting index triple $[i,j,k]$, the corresponding promoter strengths $(\\alpha_X, \\alpha_Y, \\alpha_Z)$ are used to configure the ODE model. The model is then simulated. The resulting time series for $y(t)$ is analyzed according to the specified classification rules. If the trajectory is classified as oscillatory, the index triple $[i,j,k]$ is stored. After all combinations for a test case are evaluated, the collected list of oscillatory index triples is sorted lexicographically and added to a master list of results.\n\nFinally, the master list, containing the results for all three test cases, is formatted into a single-line string with no whitespace, as per the output specification. This entire process is encapsulated within a self-contained Python script.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run the parameter sweep for the three test cases,\n    classify trajectories, and print results in the specified format.\n    \"\"\"\n    # Global parameters for the simulation\n    n = 12.0\n    # Degradation rates are fixed to 1 and are incorporated in the ODE directly.\n    \n    # Simulation settings\n    t_span = [0.0, 200.0]\n    t_points = 5000\n    t_eval = np.linspace(t_span[0], t_span[1], t_points)\n    v0 = [0.1, 0.1, 0.1]\n    \n    # Oscillation classifier parameters\n    transient_split_index = t_points // 2\n    min_peaks = 5\n    min_amplitude = 0.5\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1 (non-oscillatory baseline, low promoter strengths)\n        {\n            \"alpha_x_cands\": [0.5, 1.0],\n            \"alpha_y_cands\": [0.5, 1.0],\n            \"alpha_z_cands\": [0.5, 1.0],\n        },\n        # Case 2 (oscillation-prone, high promoter strengths)\n        {\n            \"alpha_x_cands\": [10.0, 20.0],\n            \"alpha_y_cands\": [10.0, 20.0],\n            \"alpha_z_cands\": [10.0, 20.0],\n        },\n        # Case 3 (asymmetric mixed promoter strengths)\n        {\n            \"alpha_x_cands\": [8.0, 16.0],\n            \"alpha_y_cands\": [2.0, 6.0],\n            \"alpha_z_cands\": [8.0, 16.0],\n        }\n    ]\n\n    # Model definition\n    def repressilator_ode(t, v, alpha_x, alpha_y, alpha_z):\n        x, y, z = v\n        dxdt = alpha_x / (1.0 + z**n) - x\n        dydt = alpha_y / (1.0 + x**n) - y\n        dzdt = alpha_z / (1.0 + y**n) - z\n        return [dxdt, dydt, dzdt]\n\n    all_results = []\n    \n    for case in test_cases:\n        alpha_x_cands = case[\"alpha_x_cands\"]\n        alpha_y_cands = case[\"alpha_y_cands\"]\n        alpha_z_cands = case[\"alpha_z_cands\"]\n        \n        case_oscillatory_indices = []\n        \n        # Create Cartesian product of indices for the parameter sweep\n        indices_product = itertools.product(\n            range(len(alpha_x_cands)),\n            range(len(alpha_y_cands)),\n            range(len(alpha_z_cands))\n        )\n\n        for i, j, k in indices_product:\n            alpha_x = alpha_x_cands[i]\n            alpha_y = alpha_y_cands[j]\n            alpha_z = alpha_z_cands[k]\n            \n            # Numerically integrate the ODE system\n            sol = solve_ivp(\n                fun=repressilator_ode,\n                t_span=t_span,\n                y0=v0,\n                method='LSODA',  # Robust for potentially stiff systems\n                t_eval=t_eval,\n                args=(alpha_x, alpha_y, alpha_z)\n            )\n            \n            # Check if integration was successful\n            if not sol.success:\n                continue\n\n            # Extract y(t) time series\n            y_signal = sol.y[1, :]\n            \n            # Analyze post-transient part\n            y_post_transient = y_signal[transient_split_index:]\n\n            # 1. Check amplitude\n            amplitude = np.max(y_post_transient) - np.min(y_post_transient)\n            \n            if amplitude < min_amplitude:\n                continue\n                \n            # 2. Count peaks\n            peak_count = 0\n            # Iterate from the second to the second-to-last point to check neighbors\n            for p_idx in range(1, len(y_post_transient) - 1):\n                if y_post_transient[p_idx] > y_post_transient[p_idx-1] and \\\n                   y_post_transient[p_idx] > y_post_transient[p_idx+1]:\n                    peak_count += 1\n            \n            # Classify as oscillatory if both conditions are met\n            if peak_count >= min_peaks:\n                case_oscillatory_indices.append([i, j, k])\n\n        # Sort the results for the current case lexicographically\n        case_oscillatory_indices.sort()\n        all_results.append(case_oscillatory_indices)\n\n    # Format the final output string to have no whitespace\n    final_output_str = str(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```", "id": "2776369"}]}