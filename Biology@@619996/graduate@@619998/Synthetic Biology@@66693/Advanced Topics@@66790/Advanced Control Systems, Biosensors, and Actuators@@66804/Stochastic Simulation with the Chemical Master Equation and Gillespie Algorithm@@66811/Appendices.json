{"hands_on_practices": [{"introduction": "Before implementing complex simulations, it is crucial to grasp the theoretical bedrock of the Stochastic Simulation Algorithm (SSA). This practice challenges you to derive the core statistical properties of a single SSA step from the first principles of the Chemical Master Equation (CME). By working through a simple birth-death process by hand [@problem_id:2777186], you will build a foundational understanding of how the waiting time $\\tau$ and the choice of the next reaction are rigorously determined, connecting the abstract theory of the CME to the concrete mechanics of the Gillespie algorithm.", "problem": "In a constitutive single-gene expression model for a messenger RNA molecule in synthetic biology, the system is modeled as a two-reaction birth–death process under the Chemical Master Equation (CME) and simulated via the Stochastic Simulation Algorithm (SSA). At time $t$, the system has a current copy number $n \\in \\mathbb{N}_{0}$. The two reactions are:\n- Transcription (birth): $\\varnothing \\rightarrow \\text{mRNA}$ with a constant stochastic rate constant $k_b$ (units: $\\text{time}^{-1}$).\n- Degradation (death): $\\text{mRNA} \\rightarrow \\varnothing$ with a first-order stochastic rate constant $k_d$ (units: $\\text{time}^{-1}$).\n\nAssume that $k_b > 0$, $k_d > 0$, and $n$ is finite and nonnegative. Using only first principles of the Chemical Master Equation (CME) and the definition of propensities as hazard rates under well-mixed mass-action kinetics, consider a single step of the Stochastic Simulation Algorithm (SSA). Define the reaction index $J \\in \\{1,2\\}$, where $J=1$ denotes the transcription event and $J=2$ denotes the degradation event, and let $\\tau$ be the waiting time to the next event.\n\nDerive, from first principles, expressions for the conditional expected waiting time $\\mathbb{E}[\\tau \\mid n]$ and the conditional expected reaction index $\\mathbb{E}[J \\mid n]$ for the very next SSA step, as functions of $k_b$, $k_d$, and $n$. Your derivation must start from the CME interpretation of propensities as hazards and must not assume any specific SSA formulas without derivation.\n\nExpress your final answer as a single row vector $\\big(\\mathbb{E}[\\tau \\mid n],\\, \\mathbb{E}[J \\mid n]\\big)$ in closed form. No numerical approximation is required and no units should be included in the final answer.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It is a standard exercise in stochastic chemical kinetics. We will proceed with the derivation from first principles as required.\n\nThe system is defined by two chemical reactions:\n1.  Transcription: $\\varnothing \\xrightarrow{k_b} \\text{mRNA}$\n2.  Degradation: $\\text{mRNA} \\xrightarrow{k_d} \\varnothing$\n\nAt time $t$, the state of the system is the number of mRNA molecules, $n$. The evolution of the system is governed by the propensities of these two reactions. The propensity function $a_j(n)$ for a reaction $j$ represents the hazard rate of that reaction occurring, given the system is in state $n$. For a well-mixed system under mass-action kinetics, the propensities are defined as follows:\n\nFor reaction $1$, transcription, the rate is independent of the number of mRNA molecules, $n$. This is a zero-order reaction. The propensity is equal to the stochastic rate constant $k_b$.\n$$ a_1(n) = k_b $$\nFor reaction $2$, degradation, the rate is proportional to the number of mRNA molecules, $n$. This is a first-order reaction. The propensity is the product of the first-order rate constant $k_d$ and the number of molecules.\n$$ a_2(n) = k_d n $$\nThe total propensity, which is the hazard rate of *any* reaction occurring, is the sum of the individual propensities.\n$$ a_0(n) = a_1(n) + a_2(n) = k_b + k_d n $$\nThe foundation of the Stochastic Simulation Algorithm (SSA) is that the time until the next reaction, $\\tau$, is a continuous random variable, while the index of the next reaction, $J$, is a discrete random variable. We must derive their conditional expectations given the current state $n$.\n\nLet $\\tau_j$ be the waiting time for the next occurrence of reaction $j$. Under the CME, each reaction channel is an independent Poisson process. Therefore, the waiting time for each reaction is an independent, exponentially distributed random variable with a rate parameter equal to its propensity. The probability density function (PDF) for $\\tau_j$ is $f_j(t) = a_j(n) \\exp(-a_j(n) t)$ for $t \\ge 0$.\n\nThe waiting time to the very next event, $\\tau$, is the minimum of the waiting times for all possible reactions.\n$$ \\tau = \\min(\\tau_1, \\tau_2) $$\nThe cumulative distribution function (CDF) of $\\tau$ is $F_\\tau(t) = P(\\tau \\le t)$. It is simpler to first find the survival function, $S_\\tau(t) = P(\\tau > t)$.\n$$ P(\\tau > t) = P(\\min(\\tau_1, \\tau_2) > t) = P(\\tau_1 > t \\text{ and } \\tau_2 > t) $$\nDue to the independence of the reaction channels, we have:\n$$ P(\\tau > t) = P(\\tau_1 > t) P(\\tau_2 > t) $$\nFor an exponential distribution with rate $\\lambda$, the survival function is $P(T > t) = \\exp(-\\lambda t)$. Thus:\n$$ P(\\tau > t) = \\exp(-a_1(n) t) \\exp(-a_2(n) t) = \\exp(-(a_1(n) + a_2(n)) t) = \\exp(-a_0(n) t) $$\nThis is the survival function of an exponential distribution with rate parameter $a_0(n) = k_b + k_d n$. The expected value of an exponential random variable with rate $\\lambda$ is $1/\\lambda$. Therefore, the conditional expected waiting time $\\mathbb{E}[\\tau \\mid n]$ is:\n$$ \\mathbb{E}[\\tau \\mid n] = \\frac{1}{a_0(n)} = \\frac{1}{k_b + k_d n} $$\nThis completes the derivation for the first quantity.\n\nNext, we derive the conditional expectation of the reaction index, $\\mathbb{E}[J \\mid n]$. The random variable $J$ can take values $1$ or $2$. The probability that the next reaction is reaction $j$, $P(J=j \\mid n)$, is the probability that the waiting time for this reaction, $\\tau_j$, is less than or equal to the waiting times for all other reactions. For our two-reaction system, we need to find $P(J=1 \\mid n)$ and $P(J=2 \\mid n)$.\n\nLet us calculate $P(J=1 \\mid n) = P(\\tau_1 \\le \\tau_2)$. We can find this by integrating over all possible times $t$ for $\\tau_1$ to occur, multiplied by the probability that $\\tau_2$ has not occurred by that time.\n$$ P(\\tau_1 \\le \\tau_2) = \\int_0^\\infty P(\\tau_1=t, \\tau_2 \\ge t) dt = \\int_0^\\infty f_1(t) P(\\tau_2 > t) dt $$\nwhere $f_1(t)$ is the PDF of $\\tau_1$.\n$$ P(J=1 \\mid n) = \\int_0^\\infty \\left( a_1(n) \\exp(-a_1(n) t) \\right) \\left( \\exp(-a_2(n) t) \\right) dt $$\n$$ P(J=1 \\mid n) = a_1(n) \\int_0^\\infty \\exp(-(a_1(n) + a_2(n)) t) dt $$\n$$ P(J=1 \\mid n) = a_1(n) \\left[ \\frac{-\\exp(-(a_1(n) + a_2(n)) t)}{a_1(n) + a_2(n)} \\right]_0^\\infty $$\n$$ P(J=1 \\mid n) = a_1(n) \\left( 0 - \\left( \\frac{-1}{a_1(n) + a_2(n)} \\right) \\right) = \\frac{a_1(n)}{a_1(n) + a_2(n)} = \\frac{a_1(n)}{a_0(n)} $$\nSubstituting the propensity expressions:\n$$ P(J=1 \\mid n) = \\frac{k_b}{k_b + k_d n} $$\nSince there are only two reactions, the probabilities must sum to $1$.\n$$ P(J=2 \\mid n) = 1 - P(J=1 \\mid n) = 1 - \\frac{k_b}{k_b + k_d n} = \\frac{k_b + k_d n - k_b}{k_b + k_d n} = \\frac{k_d n}{k_b + k_d n} $$\nThis is consistent with the general formula $P(J=j \\mid n) = a_j(n)/a_0(n)$.\n\nNow we compute the conditional expected value of the reaction index $J$ using its definition:\n$$ \\mathbb{E}[J \\mid n] = \\sum_{j \\in \\{1,2\\}} j \\cdot P(J=j \\mid n) $$\n$$ \\mathbb{E}[J \\mid n] = 1 \\cdot P(J=1 \\mid n) + 2 \\cdot P(J=2 \\mid n) $$\n$$ \\mathbb{E}[J \\mid n] = 1 \\cdot \\left( \\frac{k_b}{k_b + k_d n} \\right) + 2 \\cdot \\left( \\frac{k_d n}{k_b + k_d n} \\right) $$\n$$ \\mathbb{E}[J \\mid n] = \\frac{k_b + 2 k_d n}{k_b + k_d n} $$\nThis completes the derivation for the second quantity.\n\nThe final answer is the row vector containing both derived conditional expected values.", "answer": "$$ \\boxed{\\begin{pmatrix} \\frac{1}{k_b + k_d n} & \\frac{k_b + 2 k_d n}{k_b + k_d n} \\end{pmatrix}} $$", "id": "2777186"}, {"introduction": "With a firm grasp of the theory, the next step is to translate it into a functional simulation. This hands-on coding exercise [@problem_id:2956741] guides you through implementing the Gillespie direct method for a negative autoregulatory gene circuit, a canonical motif in both natural and synthetic systems. Building this simulation from the ground up will reinforce your understanding of how to define reaction propensities and state updates, providing practical experience in modeling the stochastic dynamics that govern gene expression.", "problem": "You are to write a complete program that implements the Stochastic Simulation Algorithm (SSA; also known as the Gillespie direct method) for an autoregulatory gene that represses its own expression through protein binding to its promoter. The model has a single promoter with two mutually exclusive states, unbound and bound, and a single protein species. The system is assumed to be well-mixed, molecule counts are integer-valued, and time is continuous. The required quantities are the final protein copy numbers at specified end times for a small set of test parameterizations.\n\nUse the following fundamental base to construct the mathematical model and algorithm:\n- Stochastic mass-action kinetics under the Chemical Master Equation: For a unimolecular reaction, the propensity (reaction hazard) is $a = c \\cdot X$, where $c$ is the stochastic rate constant and $X$ is the current count of the reactant. For a bimolecular reaction between distinct species, the propensity is $a = c \\cdot X \\cdot Y$, where $X$ and $Y$ are the current counts. For a zeroth-order synthesis gated by a promoter state variable represented as a count of promoter in that state, the propensity is $a = c \\cdot S$, where $S \\in \\{0,1\\}$ is the promoter-state indicator.\n- Direct-method SSA dynamics: If the current propensities are $\\{a_r\\}_{r=1}^R$ with total $a_0 = \\sum_{r=1}^R a_r$, then the waiting time to the next reaction is an exponentially distributed random variable with mean $1/a_0$, and the next reaction index is sampled with probability $a_r/a_0$.\n\nModel specification:\n- Species: promoter unbound $U$, promoter bound $B$, protein $P$. The promoter exists in a single copy so $U+B = 1$ must hold at all times.\n- Reactions (state-change effects shown to the right):\n  1. Synthesis from unbound promoter: $U \\rightarrow U + P$ (protein count increases by $+1$; $U$ unchanged).\n  2. Leaky synthesis from bound promoter: $B \\rightarrow B + P$ (protein count increases by $+1$; $B$ unchanged).\n  3. Protein degradation: $P \\rightarrow \\varnothing$ (protein count decreases by $-1$).\n  4. Autoregulatory binding: $U + P \\rightarrow B$ (protein count decreases by $-1$; $U$ decreases by $-1$; $B$ increases by $+1$).\n  5. Unbinding: $B \\rightarrow U + P$ (protein count increases by $+1$; $B$ decreases by $-1$; $U$ increases by $+1$).\n\nYour program must:\n- Derive and implement the reaction propensities using the stochastic mass-action rules above. Do not assume any deterministic approximations.\n- Implement the Gillespie direct method to simulate trajectories until a specified end time $T_{\\text{end}}$, starting from specified initial counts. If at any step the total propensity $a_0$ becomes $0$, the system is absorbing and the simulation must stop immediately.\n- Use a pseudorandom number generator initialized deterministically for reproducibility as follows: define a base seed $314159$, and for the test case with zero-based index $i$, initialize that simulation’s generator with seed $314159 + i$.\n- For each test case, output the final protein count $P(T_{\\text{end}})$ as an integer.\n\nTest suite:\nProvide results for the following four parameter sets. For each case, the initial state and parameters are:\n- Case $0$ (happy path, moderate autorepression):\n  - Initial counts: $U_0 = 1$, $B_0 = 0$, $P_0 = 5$.\n  - Rates: $k_{\\text{synth}} = 1.0$, $k_{\\text{leak}} = 0.05$, $k_{\\text{deg}} = 0.1$, $k_{\\text{on}} = 0.02$, $k_{\\text{off}} = 0.5$.\n  - End time: $T_{\\text{end}} = 200.0$.\n- Case $1$ (boundary condition, no repression):\n  - Initial counts: $U_0 = 1$, $B_0 = 0$, $P_0 = 0$.\n  - Rates: $k_{\\text{synth}} = 1.0$, $k_{\\text{leak}} = 0.0$, $k_{\\text{deg}} = 0.1$, $k_{\\text{on}} = 0.0$, $k_{\\text{off}} = 0.0$.\n  - End time: $T_{\\text{end}} = 100.0$.\n- Case $2$ (edge case, strong repression via fast binding and slow unbinding):\n  - Initial counts: $U_0 = 1$, $B_0 = 0$, $P_0 = 10$.\n  - Rates: $k_{\\text{synth}} = 1.0$, $k_{\\text{leak}} = 0.0$, $k_{\\text{deg}} = 0.1$, $k_{\\text{on}} = 0.5$, $k_{\\text{off}} = 0.001$.\n  - End time: $T_{\\text{end}} = 200.0$.\n- Case $3$ (edge case, zero-time boundary):\n  - Initial counts: $U_0 = 1$, $B_0 = 0$, $P_0 = 7$.\n  - Rates: $k_{\\text{synth}} = 1.5$, $k_{\\text{leak}} = 0.0$, $k_{\\text{deg}} = 0.2$, $k_{\\text{on}} = 0.03$, $k_{\\text{off}} = 0.2$.\n  - End time: $T_{\\text{end}} = 0.0$.\n\nAnswer specification:\n- Your program must produce a single line of output containing the final protein counts for Cases $0$ through $3$ in order, as a comma-separated list enclosed in square brackets with no spaces, for example, $[x_0,x_1,x_2,x_3]$, where each $x_i$ is an integer equal to $P(T_{\\text{end}})$ for case $i$.\n- There are no physical units required in the output; molecule counts are unitless integers; time is an abstract continuous variable in arbitrary units. Angles are not used. Percentages are not used.", "solution": "The problem statement is critically assessed and found to be valid. It presents a well-defined task in computational systems biology: the stochastic simulation of a classic gene autoregulatory network. The model is based on established principles of chemical kinetics, the specified algorithm (Gillespie's Stochastic Simulation Algorithm, or SSA) is the standard for this class of problems, and all parameters and initial conditions are provided unambiguously. The problem is scientifically grounded, well-posed, and objective.\n\nThe system state can be completely specified by the number of protein molecules, $P$, and the state of the single gene promoter. The promoter can be either unbound, denoted by state $U$, or bound, denoted by state $B$. As there is only one promoter, its state is mutually exclusive, satisfying the constraint that the count of unbound promoters plus the count of bound promoters is always one. We can represent this promoter state with a binary variable, which we will also denote as $U$, where $U=1$ if the promoter is unbound and $U=0$ if it is bound. Consequently, the state of the bound promoter is $B = 1 - U$. The full system state at any time $t$ is thus described by the vector $\\mathbf{X}(t) = [P(t), U(t)]$.\n\nThe problem defines five reaction channels. We must first formulate the propensity function, $a_j(\\mathbf{X})$, for each reaction $j \\in \\{1, 2, 3, 4, 5\\}$. The propensity is the stochastic equivalent of a reaction rate and represents the probability per unit time that a reaction will occur. Following the provided rules of stochastic mass-action kinetics:\n\n1.  **Synthesis from unbound promoter ($U \\rightarrow U + P$)**: This is a zeroth-order synthesis process, gated by the promoter being in the unbound state $U$. The propensity is proportional to the rate constant $k_{\\text{synth}}$ and the indicator variable for the unbound state.\n    $$a_1 = k_{\\text{synth}} \\cdot U$$\n2.  **Leaky synthesis from bound promoter ($B \\rightarrow B + P$)**: Similarly, this is a gated zeroth-order process, occurring when the promoter is bound ($B=1$, or $U=0$).\n    $$a_2 = k_{\\text{leak}} \\cdot B = k_{\\text{leak}} \\cdot (1 - U)$$\n3.  **Protein degradation ($P \\rightarrow \\varnothing$)**: This is a unimolecular decay process. The propensity is proportional to the rate constant $k_{\\text{deg}}$ and the number of protein molecules $P$.\n    $$a_3 = k_{\\text{deg}} \\cdot P$$\n4.  **Autoregulatory binding ($U + P \\rightarrow B$)**: This is a bimolecular reaction between a protein molecule $P$ and the unbound promoter site $U$. The propensity is proportional to the rate constant $k_{\\text{on}}$, the number of protein molecules $P$, and the state of the promoter $U$. If the promoter is already bound ($U=0$), this reaction cannot occur.\n    $$a_4 = k_{\\text{on}} \\cdot U \\cdot P$$\n5.  **Unbinding ($B \\rightarrow U + P$)**: This is a unimolecular dissociation of the protein from the promoter. The propensity is proportional to the rate constant $k_{\\text{off}}$ and the state of the promoter being bound ($B=1$, or $U=0$).\n    $$a_5 = k_{\\text{off}} \\cdot B = k_{\\text{off}} \\cdot (1 - U)$$\n\nThe effect of each reaction on the state vector $\\mathbf{X} = [P, U]$ is captured by a state-change vector $\\boldsymbol{\\nu}_j$:\n-   $R_1$: $\\boldsymbol{\\nu}_1 = [+1, 0]^T$ (one protein created, promoter state unchanged).\n-   $R_2$: $\\boldsymbol{\\nu}_2 = [+1, 0]^T$ (one protein created, promoter state unchanged).\n-   $R_3$: $\\boldsymbol{\\nu}_3 = [-1, 0]^T$ (one protein destroyed, promoter state unchanged).\n-   $R_4$: $\\boldsymbol{\\nu}_4 = [-1, -1]^T$ (one protein consumed, promoter state changes from $U=1$ to $U=0$).\n-   $R_5$: $\\boldsymbol{\\nu}_5 = [+1, +1]^T$ (one protein created, promoter state changes from $U=0$ to $U=1$).\n\nThe Gillespie direct method simulates an exact trajectory of this stochastic system. The algorithm proceeds as follows:\n\n1.  **Initialization**: Set the current time $t = 0$. Initialize the state vector $\\mathbf{X}(0) = [P_0, U_0]$ with the given initial counts. Establish the simulation end time $T_{\\text{end}}$. A pseudorandom number generator (PRNG) is seeded for reproducibility. For test case $i$, the seed is $314159 + i$.\n\n2.  **Iteration**: The simulation proceeds in a loop that continues as long as $t < T_{\\text{end}}$.\n    a. **Calculate Propensities**: At the current state $\\mathbf{X}(t)$, calculate all five propensities $a_1, ..., a_5$.\n    b. **Calculate Total Propensity**: Compute the sum of all propensities, $a_0 = \\sum_{j=1}^{5} a_j$. If $a_0 = 0$, no further reactions can occur. This is an absorbing state, and the simulation terminates.\n    c. **Sample Waiting Time**: The time until the next reaction, $\\tau$, is an exponentially distributed random variable with rate $a_0$. We sample $\\tau$ by drawing a random number $r_1$ from the uniform distribution $U(0,1)$ and computing:\n       $$\\tau = \\frac{1}{a_0} \\ln\\left(\\frac{1}{r_1}\\right)$$\n    d. **Check End Time**: Before updating, we check if the next event occurs after the designated end time. If $t + \\tau \\geq T_{\\text{end}}$, the simulation concludes. The state of the system at $T_{\\text{end}}$ is taken to be the state at time $t$, and the loop terminates.\n    e. **Sample Next Reaction**: The index $\\mu$ of the next reaction to occur is chosen with probability $P(\\mu=j) = a_j/a_0$. This is done by drawing a second random number $r_2 \\sim U(0,1)$ and finding the smallest integer $\\mu$ that satisfies the condition:\n       $$\\sum_{j=1}^{\\mu} a_j > r_2 \\cdot a_0$$\n    f. **Update State and Time**: The system time is advanced by $\\tau$, so $t \\leftarrow t + \\tau$. The state vector is updated according to the chosen reaction $\\mu$: $\\mathbf{X} \\leftarrow \\mathbf{X} + \\boldsymbol{\\nu}_{\\mu}$.\n\n3.  **Termination**: Upon loop termination (either because $t \\geq T_{\\text{end}}$ or $a_0 = 0$), the final protein count $P$ is recorded as the result for the given test case. For the special case where $T_{\\text{end}} = 0$, the loop condition is immediately false, and the initial protein count $P_0$ is returned.\n\nThe program will implement this algorithm for each of the four test cases provided, using the specified parameters, initial conditions, and seeding protocol, to generate the required list of final protein counts.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_ssa_simulation(k_synth, k_leak, k_deg, k_on, k_off, P0, U0, T_end, seed):\n    \"\"\"\n    Implements the Gillespie direct method for a gene autoregulatory network.\n\n    Args:\n        k_synth (float): Synthesis rate from unbound promoter.\n        k_leak (float): Leaky synthesis rate from bound promoter.\n        k_deg (float): Protein degradation rate.\n        k_on (float): Protein-promoter binding rate.\n        k_off (float): Protein-promoter unbinding rate.\n        P0 (int): Initial protein count.\n        U0 (int): Initial promoter state (1=unbound, 0=bound).\n        T_end (float): Simulation end time.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        int: The final protein count at T_end.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    t = 0.0\n    P = P0\n    U = U0\n    \n    # Handle the edge case of T_end = 0.0\n    if T_end == 0.0:\n        return P\n\n    while t < T_end:\n        # 1. Calculate propensities for each reaction\n        # a1: Synthesis from unbound promoter (U -> U + P)\n        a1 = k_synth * U\n        # a2: Leaky synthesis from bound promoter (B -> B + P)\n        a2 = k_leak * (1 - U)\n        # a3: Protein degradation (P -> 0)\n        a3 = k_deg * P\n        # a4: Autoregulatory binding (U + P -> B)\n        a4 = k_on * U * P\n        # a5: Unbinding (B -> U + P)\n        a5 = k_off * (1 - U)\n\n        # 2. Calculate total propensity\n        a0 = a1 + a2 + a3 + a4 + a5\n\n        # If a0 is 0, the system is in an absorbing state, no more reactions can occur.\n        if a0 == 0.0:\n            break\n\n        # 3. Sample waiting time to the next reaction\n        r1 = rng.random()\n        tau = (1.0 / a0) * np.log(1.0 / r1)\n\n        # 4. Check if the next event is after T_end\n        if t + tau >= T_end:\n            break\n\n        # 5. Advance time\n        t += tau\n\n        # 6. Sample which reaction occurs\n        r2 = rng.random()\n        target = r2 * a0\n        \n        # Determine reaction index mu by checking cumulative propensities\n        if target < a1:\n            # Reaction 1: P -> P + 1\n            P += 1\n        elif target < a1 + a2:\n            # Reaction 2: P -> P + 1\n            P += 1\n        elif target < a1 + a2 + a3:\n            # Reaction 3: P -> P - 1\n            P -= 1\n        elif target < a1 + a2 + a3 + a4:\n            # Reaction 4: P -> P - 1, U -> 0\n            P -= 1\n            U = 0\n        else:\n            # Reaction 5: P -> P + 1, U -> 1\n            P += 1\n            U = 1\n\n    return P\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    base_seed = 314159\n\n    test_cases = [\n        # Case 0: happy path, moderate autorepression\n        {\"k_synth\": 1.0, \"k_leak\": 0.05, \"k_deg\": 0.1, \"k_on\": 0.02, \"k_off\": 0.5, \"P0\": 5, \"U0\": 1, \"T_end\": 200.0},\n        # Case 1: boundary condition, no repression\n        {\"k_synth\": 1.0, \"k_leak\": 0.0, \"k_deg\": 0.1, \"k_on\": 0.0, \"k_off\": 0.0, \"P0\": 0, \"U0\": 1, \"T_end\": 100.0},\n        # Case 2: edge case, strong repression\n        {\"k_synth\": 1.0, \"k_leak\": 0.0, \"k_deg\": 0.1, \"k_on\": 0.5, \"k_off\": 0.001, \"P0\": 10, \"U0\": 1, \"T_end\": 200.0},\n        # Case 3: edge case, zero-time boundary\n        {\"k_synth\": 1.5, \"k_leak\": 0.2, \"k_deg\": 0.2, \"k_on\": 0.03, \"k_off\": 0.2, \"P0\": 7, \"U0\": 1, \"T_end\": 0.0}\n    ]\n\n    results = []\n    for i, params in enumerate(test_cases):\n        seed = base_seed + i\n        final_P = run_ssa_simulation(\n            k_synth=params[\"k_synth\"],\n            k_leak=params[\"k_leak\"],\n            k_deg=params[\"k_deg\"],\n            k_on=params[\"k_on\"],\n            k_off=params[\"k_off\"],\n            P0=params[\"P0\"],\n            U0=params[\"U0\"],\n            T_end=params[\"T_end\"],\n            seed=seed\n        )\n        results.append(final_P)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2956741"}, {"introduction": "Building on your implementation skills, this final practice advances to a more complex, contemporary synthetic biology system: a CRISPR interference (CRISPRi) module. This problem [@problem_id:2777157] moves beyond simulating a single trajectory to a more scientifically relevant task of characterizing system behavior by analyzing an ensemble of simulations. By calculating the distribution of gene repression levels, you will learn how to use stochastic modeling to quantify the performance and reliability of synthetic circuits, a key skill for a synthetic biologist.", "problem": "You are tasked with developing a program that uses the Stochastic Simulation Algorithm (SSA; Gillespie algorithm) to simulate a Clustered Regularly Interspaced Short Palindromic Repeats interference (CRISPRi)-based repression module and to compute the distribution of target repression levels across stochastic trajectories. Start from the Chemical Master Equation (CME) perspective: a continuous-time, discrete-state Markov jump process with mass-action propensities. You will model guide RNA production, formation of the deoxyribonuclease-inactive CRISPR-associated protein 9 (dCas9):guide RNA complex, and complex binding to a single target DNA locus that represses transcription while bound. Your simulation should report the distribution of repression levels as dimensionless fractions.\n\nModel the following reaction network with one DNA locus and integer molecule counts. Let $G$ denote guide RNA copy number, $C$ free dCas9 copy number, $X$ free dCas9:guide RNA complex copy number, and $D_{\\mathrm{b}} \\in \\{0,1\\}$ denote the DNA occupancy state where $D_{\\mathrm{b}} = 1$ if bound and $D_{\\mathrm{b}} = 0$ if free. The total dCas9 copy number $C_{\\mathrm{tot}}$ is constant, so at all times $C + X + D_{\\mathrm{b}} = C_{\\mathrm{tot}}$. Reactions and their mass-action propensities are:\n\n1. Guide RNA transcription: $\\varnothing \\to G$ with propensity $a_1 = k_g$.\n2. Guide RNA degradation: $G \\to \\varnothing$ with propensity $a_2 = d_g \\, G$.\n3. Complex formation: $C + G \\to X$ with propensity $a_3 = k_{\\mathrm{on}} \\, C \\, G$.\n4. Complex dissociation: $X \\to C + G$ with propensity $a_4 = k_{\\mathrm{off}} \\, X$.\n5. DNA binding by complex: $D_{\\mathrm{f}} + X \\to D_{\\mathrm{b}}$ with propensity $a_5 = k_{\\mathrm{bind}} \\, (1 - D_{\\mathrm{b}}) \\, X$, where $D_{\\mathrm{f}} = 1 - D_{\\mathrm{b}}$.\n6. DNA unbinding: $D_{\\mathrm{b}} \\to D_{\\mathrm{f}} + X$ with propensity $a_6 = k_{\\mathrm{unbind}} \\, D_{\\mathrm{b}}$.\n\nAssume that transcription of the target gene proceeds at a baseline rate $k_{\\mathrm{tx}}$ when DNA is free and at a reduced “leaky” rate $\\alpha \\, k_{\\mathrm{tx}}$ when DNA is bound, with $0 \\le \\alpha \\le 1$. Define the instantaneous repression level as the fractional reduction in transcription rate relative to the baseline, which equals $1 - \\alpha$ when bound and $0$ when free. Over an observation window, define the time-averaged repression level for one trajectory as\n$$\nL = (1 - \\alpha) \\, f_{\\mathrm{bound}},\n$$\nwhere $f_{\\mathrm{bound}}$ is the fraction of the observation window during which $D_{\\mathrm{b}} = 1$. Thus $L \\in [0,1]$ is dimensionless.\n\nImplement the Gillespie algorithm using the CME foundations: at state $\\mathbf{n}(t)$ with total propensity $a_0 = \\sum_{i=1}^{6} a_i$, the waiting time $\\tau$ to the next reaction is an exponential random variable with mean $1/a_0$, and the reaction index $\\mu$ is chosen with probability $a_\\mu / a_0$. Simulate many independent trajectories, discarding an initial burn-in period to approximate stationarity, and then compute $L$ for each trajectory from the time-weighted occupancy of the bound state. If $a_0 = 0$, the system is trapped; in this case, advance time directly to the end of the simulation window and account for the occupancy of the current state.\n\nAll rates are to be interpreted in per-second units, all times are in seconds, and outputs are unitless fractions. You must use a fixed random seeding scheme for reproducibility: use a base seed $12345$ and, for test case index $i$ (zero-based) and trajectory index $j$ (zero-based), seed the pseudo-random number generator with $12345 + 10^5 \\, i + j$ for that trajectory.\n\nTest Suite. For each test case below, simulate $N_{\\mathrm{traj}}$ independent trajectories, each from initial state $G(0)=0$, $X(0)=0$, $D_{\\mathrm{b}}(0)=0$, $C(0)=C_{\\mathrm{tot}}$, over total time $T_{\\mathrm{tot}}$ with burn-in $T_{\\mathrm{burn}}$. For each case, return the sample mean and sample variance (using the population variance definition) of $L$ across trajectories, rounded to four decimal places. The parameters are:\n\n- Case $0$ (moderate repression regime; happy path):\n  - $k_g = 0.05$, $d_g = 0.005$, $C_{\\mathrm{tot}} = 10$, $k_{\\mathrm{on}} = 0.01$, $k_{\\mathrm{off}} = 0.001$, $k_{\\mathrm{bind}} = 0.02$, $k_{\\mathrm{unbind}} = 0.002$, $\\alpha = 0.05$, $k_{\\mathrm{tx}} = 0.1$.\n  - $T_{\\mathrm{tot}} = 2000$, $T_{\\mathrm{burn}} = 200$, $N_{\\mathrm{traj}} = 100$.\n\n- Case $1$ (low guide RNA production; boundary toward no repression):\n  - $k_g = 0.001$, $d_g = 0.01$, $C_{\\mathrm{tot}} = 10$, $k_{\\mathrm{on}} = 0.01$, $k_{\\mathrm{off}} = 0.01$, $k_{\\mathrm{bind}} = 0.02$, $k_{\\mathrm{unbind}} = 0.002$, $\\alpha = 0.05$, $k_{\\mathrm{tx}} = 0.1$.\n  - $T_{\\mathrm{tot}} = 2000$, $T_{\\mathrm{burn}} = 200$, $N_{\\mathrm{traj}} = 100$.\n\n- Case $2$ (strong repression; near-saturation binding with no leak):\n  - $k_g = 0.2$, $d_g = 0.005$, $C_{\\mathrm{tot}} = 20$, $k_{\\mathrm{on}} = 0.02$, $k_{\\mathrm{off}} = 0.001$, $k_{\\mathrm{bind}} = 0.05$, $k_{\\mathrm{unbind}} = 0.001$, $\\alpha = 0.0$, $k_{\\mathrm{tx}} = 0.1$.\n  - $T_{\\mathrm{tot}} = 2000$, $T_{\\mathrm{burn}} = 200$, $N_{\\mathrm{traj}} = 100$.\n\n- Case $3$ (no dCas9 available; edge case with zero repression):\n  - $k_g = 0.05$, $d_g = 0.005$, $C_{\\mathrm{tot}} = 0$, $k_{\\mathrm{on}} = 0.01$, $k_{\\mathrm{off}} = 0.001$, $k_{\\mathrm{bind}} = 0.02$, $k_{\\mathrm{unbind}} = 0.002$, $\\alpha = 0.05$, $k_{\\mathrm{tx}} = 0.1$.\n  - $T_{\\mathrm{tot}} = 2000$, $T_{\\mathrm{burn}} = 200$, $N_{\\mathrm{traj}} = 100$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element must be a two-element list $[m_i,v_i]$ for test case $i$, where $m_i$ is the sample mean of $L$ and $v_i$ is the sample variance of $L$, both rounded to four decimal places, in the order of the cases above. For example, the output should look like $[[m_0,v_0],[m_1,v_1],[m_2,v_2],[m_3,v_3]]$ with no additional text. No physical units should be printed because $L$ is dimensionless.", "solution": "The problem requires the implementation of the Gillespie Stochastic Simulation Algorithm (SSA) to model a CRISPR interference (CRISPRi) repression system. We are tasked with simulating the system's stochastic trajectories to compute the distribution, specifically the mean and variance, of the time-averaged repression level.\n\nFirst, we formalize the system based on the principles of the Chemical Master Equation (CME). The state of the system at any time $t$ is described by a vector of molecule counts, $\\mathbf{n}(t) = [G(t), X(t), D_{\\mathrm{b}}(t)]$, where $G$ is the number of guide RNA molecules, $X$ is the number of free dCas9:gRNA complex molecules, and $D_{\\mathrm{b}}$ is the status of the single DNA target locus, with $D_{\\mathrm{b}} \\in \\{0, 1\\}$. The number of free dCas9 proteins, $C$, is a dependent variable determined by the conservation of the total dCas9 copy number, $C_{\\mathrm{tot}}$, such that $C(t) = C_{\\mathrm{tot}} - X(t) - D_{\\mathrm{b}}(t)$. The state space is thus $\\mathbb{Z}_{\\ge 0} \\times \\mathbb{Z}_{\\ge 0} \\times \\{0, 1\\}$, constrained by $X+D_{\\mathrm{b}} \\le C_{\\mathrm{tot}}$.\n\nThe system evolves through a series of six chemical reactions, each representing a possible state transition. These reactions form a continuous-time, discrete-state Markov jump process. The state change vector for each reaction $R_j$ is denoted by $\\mathbf{v}_j$.\n\n1.  $R_1$: Guide RNA transcription, $\\varnothing \\to G$. State change $\\mathbf{v}_1 = [+1, 0, 0]^T$.\n2.  $R_2$: Guide RNA degradation, $G \\to \\varnothing$. State change $\\mathbf{v}_2 = [-1, 0, 0]^T$.\n3.  $R_3$: Complex formation, $C + G \\to X$. State change $\\mathbf{v}_3 = [-1, +1, 0]^T$.\n4.  $R_4$: Complex dissociation, $X \\to C + G$. State change $\\mathbf{v}_4 = [+1, -1, 0]^T$.\n5.  $R_5$: DNA binding by complex, $D_{\\mathrm{f}} + X \\to D_{\\mathrm{b}}$. State change $\\mathbf{v}_5 = [0, -1, +1]^T$.\n6.  $R_6$: DNA unbinding, $D_{\\mathrm{b}} \\to D_{\\mathrm{f}} + X$. State change $\\mathbf{v}_6 = [0, +1, -1]^T$.\n\nAssociated with each reaction $R_j$ is a propensity function $a_j(\\mathbf{n})$, which under the assumption of mass-action kinetics, gives the probability per unit time that reaction $j$ will occur. Given the state $\\mathbf{n} = [G, X, D_{\\mathrm{b}}]$, the propensities are:\n$a_1(\\mathbf{n}) = k_g$\n$a_2(\\mathbf{n}) = d_g G$\n$a_3(\\mathbf{n}) = k_{\\mathrm{on}} C G = k_{\\mathrm{on}} (C_{\\mathrm{tot}} - X - D_{\\mathrm{b}}) G$\n$a_4(\\mathbf{n}) = k_{\\mathrm{off}} X$\n$a_5(\\mathbf{n}) = k_{\\mathrm{bind}} (1 - D_{\\mathrm{b}}) X$\n$a_6(\\mathbf{n}) = k_{\\mathrm{unbind}} D_{\\mathrm{b}}$\n\nThe total propensity for any reaction to occur is $a_0(\\mathbf{n}) = \\sum_{j=1}^{6} a_j(\\mathbf{n})$. The Gillespie algorithm is a direct method to generate an exact realization of this stochastic process. It proceeds in two steps at each iteration:\n1.  Determine the waiting time $\\tau$ until the next reaction. This time is drawn from an exponential distribution with rate $a_0$, i.e., $P(\\tau) = a_0 e^{-a_0 \\tau}$. A value for $\\tau$ can be generated using inverse transform sampling: $\\tau = \\frac{1}{a_0} \\ln(\\frac{1}{r_1})$, where $r_1$ is a random number from a uniform distribution $U(0,1)$.\n2.  Determine which reaction occurs. The probability that the next reaction is $R_j$ is given by $a_j(\\mathbf{n}) / a_0(\\mathbf{n})$. This is equivalent to choosing an index $j$ by drawing a second uniform random number $r_2 \\in U(0,1)$ and finding the smallest $j$ such that $\\sum_{i=1}^{j} a_i(\\mathbf{n}) > r_2 a_0(\\mathbf{n})$.\n\nOnce a reaction $j$ is chosen at time $t$, the system time is advanced to $t+\\tau$, and the state is updated to $\\mathbf{n}(t+\\tau) = \\mathbf{n}(t) + \\mathbf{v}_j$. This process is repeated until the simulation time reaches a specified total time, $T_{\\mathrm{tot}}$. If at any point $a_0 = 0$, the system is in an absorbing state, and time is advanced directly to $T_{\\mathrm{tot}}$.\n\nThe quantity of interest is the time-averaged repression level, $L$. The instantaneous repression is $0$ if the DNA is free ($D_{\\mathrm{b}}=0$) and $1-\\alpha$ if it is bound ($D_{\\mathrm{b}}=1$). For a single trajectory, the time-averaged repression level over the observation window $[T_{\\mathrm{burn}}, T_{\\mathrm{tot}}]$ is\n$$L = (1-\\alpha) f_{\\mathrm{bound}}$$\nwhere $f_{\\mathrm{bound}}$ is the fraction of time the DNA locus was in the bound state ($D_{\\mathrm{b}}=1$) during this window.\n$$f_{\\mathrm{bound}} = \\frac{1}{T_{\\mathrm{tot}} - T_{\\mathrm{burn}}} \\int_{T_{\\mathrm{burn}}}^{T_{\\mathrm{tot}}} D_{\\mathrm{b}}(t) \\, dt$$\nIn the discrete-time steps of the simulation, this integral is computed by summing the durations of intervals where $D_{\\mathrm{b}}=1$ that fall within the observation window.\n\nThe algorithm for a single trajectory is as follows:\n1.  Initialize time $t=0$, state $\\mathbf{n}(0)=[0, 0, 0]$, and total bound time in the observation window `total_bound_time_obs = 0.0`.\n2.  Use the specified seeding scheme: for test case $i$ and trajectory $j$, the seed is $12345 + 10^5 i + j$.\n3.  Loop while $t < T_{\\mathrm{tot}}$:\n    a. Calculate all propensities $a_1, \\dots, a_6$ from the current state $\\mathbf{n}$.\n    b. Compute total propensity $a_0 = \\sum a_j$.\n    c. If $a_0 = 0$, set the time advancement $\\tau$ to be infinite (effectively, $t \\to T_{\\text{tot}}$). Otherwise, generate $r_1 \\sim U(0,1)$ and set $\\tau = (1/a_0)\\ln(1/r_1)$.\n    d. Let the current interval be $[t, t+\\tau]$. If the current state has $D_{\\mathrm{b}}=1$, calculate the length of the intersection of this interval with $[T_{\\mathrm{burn}}, T_{\\mathrm{tot}}]$ and add it to `total_bound_time_obs`.\n    e. Advance time: $t \\leftarrow t + \\tau$.\n    f. If $t \\ge T_{\\mathrm{tot}}$ or $a_0 = 0$, exit the loop.\n    g. Generate $r_2 \\sim U(0,1)$ and select reaction index $\\mu$.\n    h. Update state: $\\mathbf{n} \\leftarrow \\mathbf{n} + \\mathbf{v}_\\mu$.\n4.  Calculate $f_{\\mathrm{bound}} = \\text{total\\_bound\\_time\\_obs} / (T_{\\mathrm{tot}} - T_{\\mathrm{burn}})$.\n5.  Calculate $L=(1-\\alpha)f_{\\mathrm{bound}}$.\n\nThis procedure is repeated for $N_{\\mathrm{traj}}$ independent trajectories for each test case. From the resulting sample of $L$ values, $\\{L_k\\}_{k=1}^{N_{\\mathrm{traj}}}$, we compute the sample mean $\\bar{L} = \\frac{1}{N_{\\mathrm{traj}}}\\sum_k L_k$ and the sample's population variance $\\sigma_L^2 = \\frac{1}{N_{\\mathrm{traj}}}\\sum_k (L_k - \\bar{L})^2$. These values, rounded to four decimal places, constitute the final result for each case. The parameter $k_{\\mathrm{tx}}$ is conceptual and does not enter the simulation dynamics directly. Case $3$ where $C_{\\mathrm{tot}}=0$ is a special case where no complexes can form ($X(t)=0$) and no DNA binding can occur ($D_{\\mathrm{b}}(t)=0$), leading to $L=0$ for all trajectories.", "answer": "```python\nimport numpy as np\n\ndef gillespie_trajectory(params, seed):\n    \"\"\"\n    Simulates a single trajectory of the CRISPRi system using the Gillespie algorithm.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # Unpack parameters\n    k_g = params['k_g']\n    d_g = params['d_g']\n    C_tot = params['C_tot']\n    k_on = params['k_on']\n    k_off = params['k_off']\n    k_bind = params['k_bind']\n    k_unbind = params['k_unbind']\n    alpha = params['alpha']\n    T_tot = params['T_tot']\n    T_burn = params['T_burn']\n\n    # State vector: [G, X, D_b]\n    # G: guide RNA, X: complex, D_b: bound DNA state (0 or 1)\n    state = np.array([0, 0, 0], dtype=np.int64)\n    time = 0.0\n\n    # Stoichiometry matrix for [G, X, D_b] updates\n    stoichiometry = np.array([\n        [1, 0, 0],   # R1: G production\n        [-1, 0, 0],  # R2: G degradation\n        [-1, 1, 0],  # R3: Complex formation\n        [1, -1, 0],  # R4: Complex dissociation\n        [0, -1, 1],  # R5: DNA binding\n        [0, 1, -1]   # R6: DNA unbinding\n    ], dtype=np.int64)\n\n    total_bound_time_obs = 0.0\n    observation_duration = T_tot - T_burn\n\n    while time < T_tot:\n        G, X, D_b = state[0], state[1], state[2]\n        \n        # Dependent variable C (free dCas9)\n        C = C_tot - X - D_b\n\n        # Propensities\n        propensities = np.array([\n            k_g,\n            d_g * G,\n            k_on * C * G,\n            k_off * X,\n            k_bind * (1 - D_b) * X,\n            k_unbind * D_b\n        ], dtype=np.float64)\n\n        a0 = np.sum(propensities)\n        \n        t_prev = time\n        tau = 0.0\n\n        if a0 <= 0:\n            time = T_tot\n        else:\n            r1 = rng.random()\n            tau = (1.0 / a0) * np.log(1.0 / r1)\n            time += tau\n\n        # Account for time spent in the bound state during the observation window\n        if D_b == 1:\n            intersect_start = max(t_prev, T_burn)\n            intersect_end = min(time, T_tot)\n            if intersect_end > intersect_start:\n                total_bound_time_obs += (intersect_end - intersect_start)\n        \n        if a0 <= 0 or time >= T_tot:\n            break\n\n        # Select the next reaction\n        r2 = rng.random()\n        prop_cumsum = np.cumsum(propensities)\n        mu = np.searchsorted(prop_cumsum, r2 * a0, side='right')\n        \n        # Update the state\n        state += stoichiometry[mu]\n\n    # Calculate the final time-averaged repression level L\n    if observation_duration > 0:\n        f_bound = total_bound_time_obs / observation_duration\n    else:\n        f_bound = 0.0\n\n    L = (1.0 - alpha) * f_bound\n    return L\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 0\n        {'k_g': 0.05, 'd_g': 0.005, 'C_tot': 10, 'k_on': 0.01, 'k_off': 0.001, \n         'k_bind': 0.02, 'k_unbind': 0.002, 'alpha': 0.05, 'k_tx': 0.1, \n         'T_tot': 2000, 'T_burn': 200, 'N_traj': 100},\n        # Case 1\n        {'k_g': 0.001, 'd_g': 0.01, 'C_tot': 10, 'k_on': 0.01, 'k_off': 0.01,\n         'k_bind': 0.02, 'k_unbind': 0.002, 'alpha': 0.05, 'k_tx': 0.1, \n         'T_tot': 2000, 'T_burn': 200, 'N_traj': 100},\n        # Case 2\n        {'k_g': 0.2, 'd_g': 0.005, 'C_tot': 20, 'k_on': 0.02, 'k_off': 0.001, \n         'k_bind': 0.05, 'k_unbind': 0.001, 'alpha': 0.0, 'k_tx': 0.1, \n         'T_tot': 2000, 'T_burn': 200, 'N_traj': 100},\n        # Case 3\n        {'k_g': 0.05, 'd_g': 0.005, 'C_tot': 0, 'k_on': 0.01, 'k_off': 0.001, \n         'k_bind': 0.02, 'k_unbind': 0.002, 'alpha': 0.05, 'k_tx': 0.1, \n         'T_tot': 2000, 'T_burn': 200, 'N_traj': 100}\n    ]\n\n    all_results_str = []\n    base_seed = 12345\n    \n    for i, params in enumerate(test_cases):\n        L_values = []\n        N_traj = params['N_traj']\n        \n        for j in range(N_traj):\n            seed = base_seed + 100000 * i + j\n            L = gillespie_trajectory(params, seed)\n            L_values.append(L)\n            \n        mean_L = np.mean(L_values)\n        # Per problem, use population variance definition for the sample (ddof=0)\n        var_L = np.var(L_values, ddof=0)\n        \n        # Format results to four decimal places and append as a string\n        all_results_str.append(f\"[{mean_L:.4f},{var_L:.4f}]\")\n        \n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2777157"}]}