{"hands_on_practices": [{"introduction": "A primary motivation for developing Xeno Nucleic Acids (XNA) is to vastly increase the information storage capacity beyond that of natural DNA. This first practice moves from simple combinatorial counting to a more rigorous, quantitative framework using principles from Shannon information theory. By calculating the information density in bits per monomer for both standard and expanded genetic alphabets, you will establish a fundamental understanding of why XNA systems hold such promise for synthetic data storage and engineering novel genetic codes [@problem_id:2079319].", "id": "2079319", "problem": "In the field of synthetic biology, researchers explore the possibilities of creating Xeno Nucleic Acids (XNA), which are synthetic analogues of the natural nucleic acids, Deoxyribonucleic Acid (DNA) and Ribonucleic Acid (RNA). A standard DNA molecule stores genetic information using a four-letter alphabet consisting of the nucleobases Adenine (A), Guanine (G), Cytosine (C), and Thymine (T). A notable advancement in this area is the development of \"hachimoji\" DNA, which expands this alphabet to eight letters by incorporating four additional synthetic bases (P, Z, S, B) alongside the natural four.\n\nThe information storage density of a nucleic acid can be quantified in terms of bits per monomer (base). Assuming that for a given system, each possible base in its alphabet appears with equal probability in a long polymer, a condition which maximizes information content, calculate the ratio of the information storage density of the 8-letter hachimoji DNA system to that of the 4-letter standard DNA system.\n\nProvide your answer as a numerical value, rounded to three significant figures.\n\n", "solution": "The problem asks for the ratio of the information storage density of an 8-letter hachimoji DNA system to a 4-letter standard DNA system. The information storage density, in this context, is the amount of information in bits that can be stored per monomer (base).\n\nAccording to information theory, the maximum information content (or Shannon entropy), $H$, of a system with $N$ distinct, equally likely states is given by the formula:\n$$H = \\log_2(N)$$\nThe unit of this information is bits. Here, the \"states\" correspond to the different types of nucleobases available in the genetic alphabet.\n\nFirst, let's calculate the information storage density for the standard 4-letter DNA system. The number of possible bases is $N_{DNA} = 4$.\nThe information density for standard DNA, $H_{DNA}$, is:\n$$H_{DNA} = \\log_2(N_{DNA}) = \\log_2(4)$$\nSince $4 = 2^2$, we can simplify this expression:\n$$H_{DNA} = \\log_2(2^2) = 2 \\log_2(2) = 2 \\times 1 = 2 \\text{ bits per monomer}$$\n\nNext, we calculate the information storage density for the 8-letter hachimoji DNA system. The number of possible bases is $N_{Hachimoji} = 8$.\nThe information density for hachimoji DNA, $H_{Hachimoji}$, is:\n$$H_{Hachimoji} = \\log_2(N_{Hachimoji}) = \\log_2(8)$$\nSince $8 = 2^3$, we can simplify this expression:\n$$H_{Hachimoji} = \\log_2(2^3) = 3 \\log_2(2) = 3 \\times 1 = 3 \\text{ bits per monomer}$$\n\nThe problem requires us to find the ratio of the information storage density of the hachimoji DNA system to that of the standard DNA system. Let's call this ratio $R$.\n$$R = \\frac{H_{Hachimoji}}{H_{DNA}}$$\nSubstituting the values we calculated:\n$$R = \\frac{3 \\text{ bits per monomer}}{2 \\text{ bits per monomer}} = 1.5$$\n\nFinally, the problem asks for the answer to be rounded to three significant figures. The number 1.5 has two significant figures. To express it with three significant figures, we add a trailing zero.\n$$R = 1.50$$", "answer": "$$\\boxed{1.50}$$"}, {"introduction": "Expanding the genetic alphabet is meaningless without ensuring the fidelity of information transfer. This exercise transitions from the abstract potential of information density to the concrete physical chemistry that governs molecular recognition and specificity in XNA. You will apply a simplified thermodynamic model to quantify the stability difference, $\\Delta\\Delta G$, between a correctly formed XNA base pair and a mispair, revealing how hydrogen bonding patterns and steric hindrances enforce the rules of a synthetic genetic system [@problem_id:2079317].", "id": "2079317", "problem": "In the field of synthetic biology, the development of synthetic genetic polymers that can store and transmit information has led to the creation of \"hachimoji\" DNA, which expands the genetic alphabet from four to eight bases. This system includes four synthetic bases: `S`, `B`, `P`, and `Z`.\n\nConsider a simplified model for the thermodynamics of base pairing within a hachimoji DNA duplex. The stability of a base pair is determined by its hydrogen bonds and any unfavorable interactions. In this model:\n- The formation of one hydrogen bond contributes a Gibbs free energy of $\\Delta G_{\\text{H-bond}} = -8.5 \\text{ kJ/mol}$.\n- An unfavorable electrostatic repulsion or steric clash between non-bonding hydrogen bond donor or acceptor sites contributes an energy penalty of $\\Delta G_{\\text{repulsion}} = +6.0 \\text{ kJ/mol}$.\n\nThe canonical pairing in this system involves the purine-like base `Z` and the pyrimidine-like base `P`. The hydrogen bonding pattern of `Z` can be represented as (Acceptor-Donor-Donor), and the pattern of `P` as (Donor-Acceptor-Acceptor). For comparison, the standard DNA base thymine (`T`) has a pattern of (Acceptor-Donor-Acceptor).\n\nA synthetic biologist is designing a probe and needs to quantify the loss of stability when the intended `Z` base in the target strand is incorrectly paired with a `T` instead of its correct partner `P`. Assume that in both scenarios (Z:P and Z:T), the bases orient themselves to form the maximum number of hydrogen bonds possible, even if this results in some repulsive interactions. Also assume a constant baseline contribution to free energy from base stacking and backbone conformation that is identical for both the correct pair and the mispair.\n\nCalculate the difference in the Gibbs free energy of formation, $\\Delta\\Delta G = \\Delta G_{\\text{mispair}} - \\Delta G_{\\text{correct pair}}$, between the Z:T mispair and the correct Z:P pair. Express your answer in kJ/mol, rounded to three significant figures.\n\n", "solution": "The Gibbs free energy of formation for a base pair in this model is the sum of contributions from hydrogen bonds, repulsive mismatches, and a baseline stacking/backbone term. For any given pair,\n$$\n\\Delta G = n_{\\text{HB}}\\,\\Delta G_{\\text{H-bond}} + n_{\\text{rep}}\\,\\Delta G_{\\text{repulsion}} + \\Delta G_{\\text{baseline}}.\n$$\nThe baseline term is identical for both pairs and cancels in the difference. Therefore,\n$$\n\\Delta\\Delta G \\equiv \\Delta G_{\\text{mispair}} - \\Delta G_{\\text{correct pair}} = \\left(n_{\\text{HB}}^{\\text{m}} - n_{\\text{HB}}^{\\text{c}}\\right)\\Delta G_{\\text{H-bond}} + \\left(n_{\\text{rep}}^{\\text{m}} - n_{\\text{rep}}^{\\text{c}}\\right)\\Delta G_{\\text{repulsion}}.\n$$\n\nDetermine $n_{\\text{HB}}$ and $n_{\\text{rep}}$ for each pair by aligning donor (D) with acceptor (A) to form hydrogen bonds and counting D–D or A–A contacts as repulsions.\n\nFor the correct Z:P pair, with Z having pattern (A,D,D) and P having pattern (D,A,A), position-wise alignment gives three donor–acceptor matches and no repulsions:\n$$\nn_{\\text{HB}}^{\\text{c}} = 3, \\quad n_{\\text{rep}}^{\\text{c}} = 0.\n$$\nHence,\n$$\n\\Delta G_{\\text{correct pair}} = 3\\,\\Delta G_{\\text{H-bond}} + 0\\cdot \\Delta G_{\\text{repulsion}} = 3\\cdot(-8.5\\ \\text{kJ/mol}) = -25.5\\ \\text{kJ/mol}.\n$$\n\nFor the Z:T mispair, with T having pattern (A,D,A), the best orientation yields one donor–acceptor match and two mismatches (A–A and D–D), hence two repulsions:\n$$\nn_{\\text{HB}}^{\\text{m}} = 1, \\quad n_{\\text{rep}}^{\\text{m}} = 2.\n$$\nTherefore,\n$$\n\\Delta G_{\\text{mispair}} = 1\\cdot(-8.5\\ \\text{kJ/mol}) + 2\\cdot(+6.0\\ \\text{kJ/mol}) = -8.5\\ \\text{kJ/mol} + 12.0\\ \\text{kJ/mol} = 3.5\\ \\text{kJ/mol}.\n$$\n\nCompute the difference:\n$$\n\\Delta\\Delta G = \\Delta G_{\\text{mispair}} - \\Delta G_{\\text{correct pair}} = 3.5\\ \\text{kJ/mol} - (-25.5\\ \\text{kJ/mol}) = 29.0\\ \\text{kJ/mol}.\n$$\n\nRounded to three significant figures, the result is $29.0$ in kJ/mol.", "answer": "$$\\boxed{29.0}$$"}, {"introduction": "Building on the principles of base-pairing energetics, this final, advanced practice challenges you to construct a complete computational model of an XNA molecule's behavior. Using the foundational principles of statistical mechanics, you will implement a dynamic programming algorithm to calculate the entire ensemble of possible secondary structures, including key observables like the partition function $Z$ and ensemble free energy $G$. This capstone exercise bridges the gap between the properties of individual base pairs and the emergent folding landscape of the entire polymer, a cornerstone of modern nucleic acid biophysics and design [@problem_id:2787832].", "id": "2787832", "problem": "You are asked to formalize and compute a statistical mechanical ensemble of non-crossing secondary structures for short sequences of xeno nucleic acids (XNA; xeno nucleic acids (XNA)) under an additive base-pair energy model. Use the following fundamental base from statistical thermodynamics and the logic of secondary structure combinatorics. The ensemble is defined over the set of all non-crossing pairings of indices of a linear sequence (each position can be either unpaired or paired with at most one other position, with no crossing pairs). The energy of a structure is additive across base pairs. The Boltzmann distribution determines the weight of each structure. You must compute ensemble observables directly from these definitions, without relying on any shortcut formulas not derivable from the base principles.\n\nFundamental definitions to use as the starting point:\n- For a sequence of length $N$, a secondary structure $s$ is a set of index pairs $(i,j)$ with $1 \\le i < j \\le N$ that are non-crossing and mutually exclusive (each position appears in at most one pair).\n- The energy of a structure $s$ is $E(s) = \\sum_{(i,j) \\in s} \\varepsilon(b_i,b_j)$, where $b_k$ is the base (letter) at position $k$, and $\\varepsilon(b_i,b_j)$ is the specified pair energy in $\\mathrm{kcal/mol}$ for the ordered pair $(b_i,b_j)$; pairs not listed are disallowed and contribute no structures.\n- The Boltzmann constant is $k_B = 1.98720425864083 \\times 10^{-3}\\ \\mathrm{kcal/(mol\\cdot K)}$.\n- At absolute temperature $T$ (in $\\mathrm{K}$), the Boltzmann weight of a structure $s$ is $w(s) = \\exp\\!\\left(-E(s)/(k_B T)\\right)$, and the partition function is $Z = \\sum_{s} w(s)$ (summing over all allowed secondary structures $s$).\n- The ensemble free energy is $G = -k_B T \\ln Z$ (in $\\mathrm{kcal/mol}$).\n- The minimum free energy (MFE) structure has energy $E_{\\min} = \\min_{s} E(s)$ (in $\\mathrm{kcal/mol}$).\n- The base-pairing probability for indices $(i,j)$ is $p_{ij} = \\frac{1}{Z} \\sum_{s} \\mathbf{1}\\!\\left((i,j)\\in s\\right)\\, w(s)$, where $\\mathbf{1}(\\cdot)$ is the indicator function. Define the per-position pairing probability as $p_i = \\sum_{j\\ne i} p_{ij}$. Define the pairing Shannon diversity as $H = -\\sum_{1\\le i<j\\le N} p_{ij}\\,\\ln p_{ij}$, with the convention that terms with $p_{ij} = 0$ contribute $0$.\n- All logarithms are natural logarithms. All probabilities are dimensionless. Always express energies in $\\mathrm{kcal/mol}$.\n\nYour task is to write a program that, given a short sequence and a pair-energy specification (including expanded alphabets), computes the ensemble observables $G$, $E_{\\min}$, $H$, and the mean pairing probability $\\bar{p} = \\frac{1}{N}\\sum_{i=1}^{N} p_i$ using only the above definitions. You must account for all non-crossing secondary structures; do not include pseudoknots.\n\nAngle units are not applicable. Physical units must be handled exactly as specified above for energies and temperature.\n\nTest suite and parameters:\nFor each test case below, use $T = 310.15\\ \\mathrm{K}$ and $k_B = 1.98720425864083 \\times 10^{-3}\\ \\mathrm{kcal/(mol\\cdot K)}$. Energies are in $\\mathrm{kcal/mol}$. Only the listed ordered base pairs are allowed (a listed pair $(x,y)$ implies that $(y,x)$ is equally allowed with the same energy; all other pairs are disallowed).\n\n- Test case $1$ (no compatible pairs; boundary case):\n  - Sequence: \"AC\"\n  - Energies: $\\varepsilon(\\mathrm{A},\\mathrm{T}) = -1.0$, $\\varepsilon(\\mathrm{T},\\mathrm{A}) = -1.0$, $\\varepsilon(\\mathrm{G},\\mathrm{C}) = -2.0$, $\\varepsilon(\\mathrm{C},\\mathrm{G}) = -2.0$.\n\n- Test case $2$ (single possible pair):\n  - Sequence: \"GC\"\n  - Energies: $\\varepsilon(\\mathrm{A},\\mathrm{T}) = -1.0$, $\\varepsilon(\\mathrm{T},\\mathrm{A}) = -1.0$, $\\varepsilon(\\mathrm{G},\\mathrm{C}) = -2.0$, $\\varepsilon(\\mathrm{C},\\mathrm{G}) = -2.0$.\n\n- Test case $3$ (multiple competing structures with canonical alphabet):\n  - Sequence: \"GCGC\"\n  - Energies: $\\varepsilon(\\mathrm{A},\\mathrm{T}) = -1.0$, $\\varepsilon(\\mathrm{T},\\mathrm{A}) = -1.0$, $\\varepsilon(\\mathrm{G},\\mathrm{C}) = -2.0$, $\\varepsilon(\\mathrm{C},\\mathrm{G}) = -2.0$.\n\n- Test case $4$ (expanded alphabet; stronger additional pairing):\n  - Sequence: \"GPZC\"\n  - Energies: $\\varepsilon(\\mathrm{A},\\mathrm{T}) = -1.0$, $\\varepsilon(\\mathrm{T},\\mathrm{A}) = -1.0$, $\\varepsilon(\\mathrm{G},\\mathrm{C}) = -2.0$, $\\varepsilon(\\mathrm{C},\\mathrm{G}) = -2.0$, $\\varepsilon(\\mathrm{P},\\mathrm{Z}) = -3.5$, $\\varepsilon(\\mathrm{Z},\\mathrm{P}) = -3.5$.\n\nRequired outputs per test case:\n- A list of four real numbers $[G, E_{\\min}, H, \\bar{p}]$, in that exact order, where $G$ and $E_{\\min}$ are in $\\mathrm{kcal/mol}$, $H$ is in nats, and $\\bar{p}$ is a dimensionless fraction. Round each value to $6$ decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list of the four-number lists, enclosed in a single pair of square brackets. For example, a valid output shape is \"[[x11,x12,x13,x14],[x21,x22,x23,x24],[x31,x32,x33,x34],[x41,x42,x43,x44]]\" with each $x_{ij}$ rounded to $6$ decimal places as specified.\n\nScientific realism note:\n- Explicitly base your derivation and implementation on the Boltzmann distribution, the definition of the partition function, and the non-crossing combinatorics of secondary structures. The influence of expanded alphabets on the landscape must be captured only through changes in the allowed pair set and the pair energies $\\varepsilon(\\cdot,\\cdot)$; no other assumptions are permitted.", "solution": "The problem presented is a well-posed exercise in the statistical mechanics of polymeric chains, specifically the folding of xeno nucleic acids (XNA) into non-crossing secondary structures. It is scientifically grounded in the principles of the Boltzmann distribution and combinatorial enumeration of secondary structures. All parameters and definitions are provided, rendering the problem self-contained and solvable. Therefore, I will proceed with a full solution.\n\nThe core of the problem is to compute ensemble properties of XNA secondary structures. A direct enumeration of all possible structures is computationally intractable for all but the shortest of sequences due to combinatorial explosion. The constraint of non-crossing pairings, however, imparts a recursive structure to the problem that is amenable to a dynamic programming (DP) solution. This approach is not a \"shortcut\" but a direct and rigorous mathematical method for summing over the ensemble, derived from the first principles provided.\n\nLet the sequence be $S$ of length $N$. We use 0-based indexing, so the indices are $i, j \\in \\{0, 1, \\dots, N-1\\}$. The Boltzmann constant is $k_B$ and the temperature is $T$. The product $R T = k_B T$ will be used frequently.\n\nFirst, we establish a symmetric matrix of Boltzmann weights for all possible base pairs. The energy of a pair between base $b_i$ at position $i$ and base $b_j$ at position $j$ is $\\varepsilon(b_i, b_j)$. The corresponding Boltzmann weight is $w_{ij} = \\exp(-\\varepsilon(b_i, b_j) / (k_B T))$. If a pair is not specified in the problem's energy table, its energy is considered infinite, and its weight is $0$.\n\nThe primary quantities, the partition function $Z$ and the minimum free energy (MFE) structure's energy $E_{\\min}$, can be calculated using a DP approach that considers all valid structures for any given subsequence. Let $Z_{i,j}$ and $E_{i,j}$ be the partition function and MFE for the subsequence from index $i$ to $j$, inclusive.\n\nThe key recurrence relation stems from considering the status of the final base, $j$, in the subsequence $i..j$. Base $j$ can either be unpaired or paired with some base $k$ where $i \\le k < j$.\n1.  If $j$ is unpaired, the set of possible structures on $i..j$ is identical to that on $i..j-1$. The contribution to $Z_{i,j}$ is $Z_{i,j-1}$, and to $E_{i,j}$ is $E_{i,j-1}$.\n2.  If $j$ is paired with $k$, the non-crossing constraint dictates that the structure is partitioned into three independent components: the pair $(k,j)$ itself, the structures on the \"internal\" subsequence $k+1..j-1$, and the structures on the \"external\" subsequence $i..k-1$. The total energy is additive, and therefore the total partition function is multiplicative.\n\nThis leads to the following DP recurrences for $Z_{i,j}$ and $E_{i,j}$, where $j>i$:\n$$ Z_{i,j} = Z_{i,j-1} + \\sum_{k=i}^{j-1} Z_{i,k-1} \\cdot w_{kj} \\cdot Z_{k+1,j-1} $$\n$$ E_{i,j} = \\min\\left( E_{i,j-1}, \\min_{i \\le k < j} \\left( E_{i,k-1} + \\varepsilon(b_k,b_j) + E_{k+1,j-1} \\right) \\right) $$\n\nThe base cases for these recursions correspond to empty or single-base subsequences:\n$Z_{i,i-1} = 1$ (one empty structure with energy $0$, weight $e^0=1$).\n$Z_{i,i} = 1$ (one unpaired structure with energy $0$, weight $1$).\n$E_{i,i-1} = 0$ and $E_{i,i} = 0$.\n\nWe compute $Z_{i,j}$ and $E_{i,j}$ for all subsequences, filling the DP tables for increasing subsequence length. The final values for the entire sequence are $Z = Z_{0,N-1}$ and $E_{\\min} = E_{0,N-1}$. The ensemble free energy is then $G = -k_B T \\ln Z$.\n\nTo compute the base-pairing probabilities $p_{ab}$, we use the definition $p_{ab} = \\frac{1}{Z} \\sum_s \\mathbf{1}((a,b)\\in s) w(s)$. A formal method to compute the numerator is required. One could implement the full McCaskill inside-outside algorithm. However, an alternative, yet equally fundamental approach, is to use calculus. The pairing probability $p_{ab}$ is related to the derivative of the partition function with respect to the energy of the pair $(a,b)$:\n$$ p_{ab} = \\frac{w_{ab}}{Z} \\frac{\\partial Z}{\\partial w_{ab}} $$\nWe can compute the derivative $\\frac{\\partial Z_{i,j}}{\\partial w_{ab}}$ using another DP scheme. Let $D^{ab}_{i,j} = \\frac{\\partial Z_{i,j}}{\\partial w_{ab}}$. By applying the chain rule to the recurrence for $Z_{i,j}$, we obtain a recurrence for $D^{ab}_{i,j}$:\n$$ D^{ab}_{i,j} = D^{ab}_{i,j-1} + \\sum_{k=i}^{j-1} \\left( D^{ab}_{i,k-1} w_{kj} Z_{k+1,j-1} + Z_{i,k-1} w_{kj} D^{ab}_{k+1,j-1} \\right) + \\delta_{(k,j),(a,b)} Z_{i,a-1}Z_{a+1,b-1} $$\nThe Kronecker delta term $\\delta_{(k,j),(a,b)}$ adds $Z_{i,a-1}Z_{a+1,b-1}$ only if the term in the summation, $(k,j)$, corresponds to the pair $(a,b)$ whose probability we are calculating. This DP calculation is performed for each possible pair $(a,b)$. Once $D^{ab}_{0,N-1}$ is found, we compute $p_{ab} = (w_{ab}/Z_{0,N-1}) \\cdot D^{ab}_{0,N-1}$.\n\nWith the matrix of pairing probabilities $p_{ij}$ computed, the remaining quantities are found by their definitions:\n- Per-position pairing probability: $p_i = \\sum_{j \\ne i} p_{ij}$.\n- Mean pairing probability: $\\bar{p} = \\frac{1}{N} \\sum_{i=0}^{N-1} p_i$.\n- Pairing Shannon diversity: $H = -\\sum_{0 \\le i < j < N, p_{ij}>0} p_{ij} \\ln p_{ij}$.\n\nThe implementation will follow this logic precisely. Helper functions will manage DP table access for subproblems, correctly handling base cases for empty subsequences. The calculations will be performed for each test case provided.", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases for XNA secondary structure analysis.\n    \"\"\"\n    \n    # Global constants from the problem statement.\n    KB = 1.98720425864083e-3  # kcal/(mol*K)\n    T = 310.15  # K\n    RT = KB * T\n\n    test_cases = [\n        {\n            \"seq\": \"AC\",\n            \"energies\": {(\"A\", \"T\"): -1.0, (\"T\", \"A\"): -1.0, (\"G\", \"C\"): -2.0, (\"C\", \"G\"): -2.0}\n        },\n        {\n            \"seq\": \"GC\",\n            \"energies\": {(\"A\", \"T\"): -1.0, (\"T\", \"A\"): -1.0, (\"G\", \"C\"): -2.0, (\"C\", \"G\"): -2.0}\n        },\n        {\n            \"seq\": \"GCGC\",\n            \"energies\": {(\"A\", \"T\"): -1.0, (\"T\", \"A\"): -1.0, (\"G\", \"C\"): -2.0, (\"C\", \"G\"): -2.0}\n        },\n        {\n            \"seq\": \"GPZC\",\n            \"energies\": {(\"A\", \"T\"): -1.0, (\"T\", \"A\"): -1.0, (\"G\", \"C\"): -2.0, (\"C\", \"G\"): -2.0, (\"P\", \"Z\"): -3.5, (\"Z\", \"P\"): -3.5}\n        }\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        seq = case[\"seq\"]\n        energy_dict = case[\"energies\"]\n        N = len(seq)\n\n        # Symmetrize energy dictionary and create weight matrix\n        weights = np.zeros((N, N))\n        energies = np.full((N, N), float('inf'))\n        for (b1, b2), energy in energy_dict.items():\n            for i in range(N):\n                for j in range(i + 1, N):\n                    if (seq[i] == b1 and seq[j] == b2) or \\\n                       (seq[i] == b2 and seq[j] == b1):\n                        weights[i, j] = math.exp(-energy / RT)\n                        weights[j, i] = weights[i, j]\n                        energies[i, j] = energy\n                        energies[j, i] = energy\n\n        # DP tables for Partition Function (Z) and Minimum Free Energy (E)\n        Z = np.zeros((N, N))\n        E = np.full((N, N), float('inf'))\n\n        # Helper functions to handle out-of-bounds access for subproblems\n        def get_Z(i, j):\n            return 1.0 if i > j else Z[i, j]\n        def get_E(i, j):\n            return 0.0 if i > j else E[i, j]\n\n        # Inside pass: fill Z and E tables\n        for length in range(1, N + 1):\n            for i in range(N - length + 1):\n                j = i + length - 1\n                if i == j:\n                    Z[i, i] = 1.0\n                    E[i, i] = 0.0\n                    continue\n                \n                # Case 1: j is unpaired\n                z_unpaired = get_Z(i, j - 1)\n                e_unpaired = get_E(i, j - 1)\n                \n                # Case 2: j pairs with k (i <= k < j)\n                z_paired = 0.0\n                e_paired = float('inf')\n                for k in range(i, j):\n                    if weights[k, j] > 0:\n                        z_paired += get_Z(i, k - 1) * weights[k, j] * get_Z(k + 1, j - 1)\n                        e_paired = min(e_paired, get_E(i, k - 1) + energies[k,j] + get_E(k + 1, j - 1))\n                \n                Z[i, j] = z_unpaired + z_paired\n                E[i, j] = min(e_unpaired, e_paired)\n\n        # Total partition function and MFE\n        Z_total = get_Z(0, N - 1)\n        E_min = get_E(0, N - 1) if N > 0 else 0.0\n        \n        # Ensemble Free Energy\n        G = -RT * math.log(Z_total) if Z_total > 0 else float('inf')\n        if N == 0: G = 0.0\n\n        # Pairing Probabilities\n        P = np.zeros((N, N))\n        for a in range(N):\n            for b in range(a + 1, N):\n                if weights[a, b] == 0:\n                    continue\n\n                # DP table for derivative D_ij = dZ_ij / dw_ab\n                D = np.zeros((N, N))\n                def get_D(i, j):\n                    return 0.0 if i > j else D[i, j]\n\n                for length in range(1, N + 1):\n                    for i in range(N - length + 1):\n                        j = i + length - 1\n                        if i == j:\n                            continue\n                        \n                        # Term from j being unpaired\n                        d_unpaired = get_D(i, j-1)\n                        \n                        # Term from j being paired with k\n                        d_paired = 0.0\n                        for k in range(i, j):\n                            if weights[k, j] > 0:\n                                d_paired += (get_D(i, k - 1) * weights[k, j] * get_Z(k + 1, j - 1) +\n                                             get_Z(i, k - 1) * weights[k, j] * get_D(k + 1, j - 1))\n                                if k == a and j == b:\n                                    d_paired += get_Z(i, k - 1) * get_Z(k + 1, j - 1)\n                        D[i,j] = d_unpaired + d_paired\n\n                D_total = get_D(0, N - 1)\n                p_ab = (weights[a, b] / Z_total) * D_total if Z_total > 0 else 0.0\n                P[a, b] = P[b, a] = p_ab\n        \n        # Shannon Diversity H\n        H = 0.0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if P[i, j] > 1e-12:  # Use a small epsilon to avoid log(0)\n                    H -= P[i, j] * math.log(P[i, j])\n\n        # Mean pairing probability p_bar\n        p_i = np.sum(P, axis=1)\n        p_bar = np.mean(p_i) if N > 0 else 0.0\n\n        # Handle case with no possible pairs for E_min\n        if N > 0 and E[0, N-1] == float('inf'):\n            E_min = 0.0\n\n        final_results.append([\n            round(G, 6),\n            round(E_min, 6),\n            round(H, 6),\n            round(p_bar, 6)\n        ])\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{','.join(map(str, res))}]\" for res in final_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"}]}