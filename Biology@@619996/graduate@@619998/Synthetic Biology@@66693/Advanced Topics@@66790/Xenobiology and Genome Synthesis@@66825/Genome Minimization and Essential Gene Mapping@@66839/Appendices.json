{"hands_on_practices": [{"introduction": "A core principle of genome minimization is eliminating functional redundancy to create a streamlined biological chassis. This exercise provides a concrete application of this principle by focusing on the translation machinery. You will apply the fundamental rules of codon-anticodon pairing, including the wobble hypothesis, to determine the absolute minimum number of tRNA genes required to support the synthesis of a defined proteome, a classic problem in synthetic biology design. [@problem_id:2741600]", "problem": "An engineered minimal bacterial genome is being designed for a cell-free expression platform that produces a defined proteome. To ensure translation completeness, the design team must determine the smallest set of Transfer Ribonucleic Acid (tRNA) genes sufficient to decode every sense codon that actually appears in the expressed coding sequences of the proteome. Use as foundational base the Central Dogma of molecular biology (deoxyribonucleic acid to ribonucleic acid to protein) and the canonical rules of codon–anticodon base pairing, including wobble pairing at the third codon position. Assume the following widely accepted wobble pairing rules at the $5'$ position of the anticodon pairing with the $3'$ base of the codon: anticodon base $C$ pairs only with codon base $G$; $A$ pairs only with $U$; $U$ pairs with $A$ or $G$; $G$ pairs with $U$ or $C$; inosine ($I$), generated by adenosine deaminase acting on transfer ribonucleic acid (ADAT), pairs with $U$, $C$, or $A$. At the first two codon positions, only canonical Watson–Crick pairs are allowed. Each distinct tRNA gene is defined by a unique anticodon triplet and amino acid identity; a tRNA decodes only codons from boxes with the same first two bases. Stop codons are irrelevant here. For the purpose of counting, exclude the specialized initiator tRNA for methionine and consider only elongator tRNAs.\n\nThe set of sense codons observed in the proteome (codon demand) is given below, grouped by amino acid; codons not listed have zero demand and may be ignored. Numbers in parentheses are total counts across all transcripts and only indicate presence ($0$); any nonzero count requires decodability.\n\n- Phenylalanine: UUU ($50$), UUC ($120$)\n- Leucine: CUU ($70$), CUC ($180$), CUG ($400$)\n- Serine: UCU ($150$), UCC ($220$), AGU ($80$), AGC ($110$)\n- Proline: CCU ($140$), CCC ($100$), CCA ($90$), CCG ($70$)\n- Threonine: ACC ($130$), ACA ($120$)\n- Alanine: GCU ($200$), GCC ($210$), GCA ($190$)\n- Glycine: GGU ($300$), GGC ($280$)\n- Valine: GUU ($90$), GUC ($120$), GUG ($200$)\n- Aspartate: GAU ($160$), GAC ($140$)\n- Glutamate: GAA ($220$), GAG ($180$)\n- Lysine: AAA ($200$)\n- Asparagine: AAU ($70$), AAC ($60$)\n- Glutamine: CAA ($90$), CAG ($110$)\n- Histidine: CAU ($50$), CAC ($70$)\n- Tyrosine: UAU ($80$), UAC ($80$)\n- Cysteine: UGU ($40$), UGC ($60$)\n- Arginine: CGU ($100$), AGA ($130$)\n- Isoleucine: AUU ($200$), AUC ($220$)\n- Methionine (elongator): AUG ($150$)\n- Tryptophan: UGG ($60$)\n\nStarting from the fundamental definitions of codon–anticodon recognition and the wobble pairing rules stated above, determine the minimal number of distinct tRNA genes needed so that every listed codon can be decoded by at least one tRNA for its amino acid, respecting the constraint that tRNAs cannot cross boxes with different first two codon bases. Express your final answer as a single integer. No rounding is required, and no units are needed.", "solution": "The goal is to determine the minimum number of tRNA genes required to decode a specified set of messenger RNA (mRNA) sense codons. A tRNA is defined by its anticodon and the amino acid it carries. The pairing between the codon and anticodon is governed by canonical Watson-Crick rules for the first two codon positions and by specific wobble rules for the third position.\n\nThe wobble pairing rules for the $5'$ base of the anticodon ($A_1$) with the $3'$ base of the codon ($N_3$) are given as:\n- Anticodon $C$ pairs with codon $G$.\n- Anticodon $A$ pairs with codon $U$.\n- Anticodon $U$ pairs with codon $A$ or $G$.\n- Anticodon $G$ pairs with codon $U$ or $C$.\n- Anticodon $I$ (Inosine) pairs with codon $U$, $C$, or $A$.\n\nWe will analyze the codon demand for each amino acid, or each codon box used by an amino acid, to find the minimum number of tRNAs required. The total number will be the sum of these minima.\n\n1.  **Phenylalanine (Phe)**: Codons are $UUU$, $UUC$. This requires decoding of $N_3 \\in \\{U, C\\}$ in the $UU\\_$ box. A single tRNA with an anticodon beginning with $G$ (e.g., $GAA$) can recognize both $U$ and $C$ in the third position. Thus, $1$ tRNA is sufficient.\n\n2.  **Leucine (Leu)**: Codons are $CUU$, $CUC$, $CUG$. This requires decoding of $N_3 \\in \\{U, C, G\\}$ in the $CU\\_$ box. No single anticodon base ($A_1$) can pair with all three codon bases. A minimal set can be achieved with two tRNAs. For example, a tRNA with anticodon $GAG$ ($A_1 = G$) decodes $CUU$ and $CUC$. A second tRNA with anticodon $CAG$ ($A_1=C$) is then required to decode $CUG$. Thus, $2$ tRNAs are necessary.\n\n3.  **Serine (Ser)**: Serine uses two codon boxes.\n    - Box $UC\\_$: Codons are $UCU$, $UCC$. This requires decoding of $N_3 \\in \\{U, C\\}$. A single tRNA with an anticodon beginning with $G$ (e.g., $GGA$) suffices. This requires $1$ tRNA.\n    - Box $AG\\_$: Codons are $AGU$, $AGC$. This requires decoding of $N_3 \\in \\{U, C\\}$. A single tRNA with an anticodon beginning with $G$ (e.g., $GCU$) suffices. This requires $1$ tRNA.\n    Total for Serine: $1 + 1 = 2$ tRNAs.\n\n4.  **Proline (Pro)**: Codons are $CCU$, $CCC$, $CCA$, $CCG$. This requires decoding of all four bases $N_3 \\in \\{U, C, A, G\\}$. No single anticodon can achieve this. A minimum of two tRNAs is needed. For example, a tRNA with anticodon $GGG$ ($A_1 = G$) decodes $CCU$ and $CCC$. A second tRNA with anticodon $UGG$ ($A_1 = U$) decodes $CCA$ and $CCG$. Thus, $2$ tRNAs are necessary.\n\n5.  **Threonine (Thr)**: Codons are $ACC$, $ACA$. This requires decoding of $N_3 \\in \\{C, A\\}$. A single tRNA with an anticodon beginning with Inosine, $I$ (e.g., $IGU$), can recognize $U$, $C$, and $A$ in the third codon position, covering the demand. Thus, $1$ tRNA is sufficient.\n\n6.  **Alanine (Ala)**: Codons are $GCU$, $GCC$, $GCA$. This requires decoding of $N_3 \\in \\{U, C, A\\}$. A single tRNA with an anticodon beginning with $I$ (e.g., $IGC$) is sufficient. Thus, $1$ tRNA is sufficient.\n\n7.  **Glycine (Gly)**: Codons are $GGU$, $GGC$. This requires decoding of $N_3 \\in \\{U, C\\}$. A single tRNA with an anticodon beginning with $G$ (e.g., $GCC$) is sufficient. Thus, $1$ tRNA is sufficient.\n\n8.  **Valine (Val)**: Codons are $GUU$, $GUC$, $GUG$. This requires decoding of $N_3 \\in \\{U, C, G\\}$. Similar to Leucine, this requires a minimum of $2$ tRNAs.\n\n9.  **Aspartate (Asp)**: Codons are $GAU$, $GAC$. This requires decoding of $N_3 \\in \\{U, C\\}$. A single tRNA with an anticodon beginning with $G$ (e.g., $GUC$) is sufficient. Thus, $1$ tRNA is sufficient.\n\n10. **Glutamate (Glu)**: Codons are $GAA$, $GAG$. This requires decoding of $N_3 \\in \\{A, G\\}$. A single tRNA with an anticodon beginning with $U$ (e.g., $UUC$) is sufficient. Thus, $1$ tRNA is sufficient.\n\n11. **Lysine (Lys)**: Codon is $AAA$. This requires decoding of $N_3 = A$. A tRNA with an anticodon beginning with $U$ (e.g., $UUU$) can decode both $A$ and $G$ and is sufficient. Thus, $1$ tRNA is sufficient.\n\n12. **Asparagine (Asn)**: Codons are $AAU$, $AAC$. This requires decoding of $N_3 \\in \\{U, C\\}$. A single tRNA with an anticodon beginning with $G$ (e.g., $GUU$) is sufficient. Thus, $1$ tRNA is sufficient.\n\n13. **Glutamine (Gln)**: Codons are $CAA$, $CAG$. This requires decoding of $N_3 \\in \\{A, G\\}$. A single tRNA with an anticodon beginning with $U$ (e.g., $UUG$) is sufficient. Thus, $1$ tRNA is sufficient.\n\n14. **Histidine (His)**: Codons are $CAU$, $CAC$. This requires decoding of $N_3 \\in \\{U, C\\}$. A single tRNA with an anticodon beginning with $G$ (e.g., $GUG$) is sufficient. Thus, $1$ tRNA is sufficient.\n\n15. **Tyrosine (Tyr)**: Codons are $UAU$, $UAC$. This requires decoding of $N_3 \\in \\{U, C\\}$. A single tRNA with an anticodon beginning with $G$ (e.g., $GUA$) is sufficient. Thus, $1$ tRNA is sufficient.\n\n16. **Cysteine (Cys)**: Codons are $UGU$, $UGC$. This requires decoding of $N_3 \\in \\{U, C\\}$. A single tRNA with an anticodon beginning with $G$ (e.g., $GCA$) is sufficient. Thus, $1$ tRNA is sufficient.\n\n17. **Arginine (Arg)**: Arginine uses two codon boxes.\n    - Box $CG\\_$: Codon is $CGU$. This requires a tRNA that can decode $N_3 = U$. A tRNA with anticodon $GCG$ ($A_1=G$) can decode both $U$ and $C$, so it is sufficient. This requires $1$ tRNA.\n    - Box $AG\\_$: Codon is $AGA$. This requires a tRNA that can decode $N_3 = A$. A tRNA with anticodon $UCU$ ($A_1=U$) can decode both $A$ and $G$, so it is sufficient. This requires $1$ tRNA.\n    Total for Arginine: $1 + 1 = 2$ tRNAs.\n\n18. **Isoleucine (Ile)**: Codons are $AUU$, $AUC$. This requires decoding of $N_3 \\in \\{U, C\\}$. A single tRNA for Isoleucine with an anticodon beginning with $G$ (e.g., $GAU$) is sufficient. Thus, $1$ tRNA is sufficient.\n\n19. **Methionine (Met, elongator)**: Codon is $AUG$. This requires decoding of $N_3 = G$. A tRNA for Methionine with anticodon $CAU$ ($A_1=C$) can decode only $G$, which is sufficient. Thus, $1$ tRNA is sufficient.\n\n20. **Tryptophan (Trp)**: Codon is $UGG$. This requires decoding of $N_3 = G$. A tRNA with anticodon $CCA$ ($A_1=C$) is sufficient. Thus, $1$ tRNA is sufficient.\n\nTo obtain the total minimal number of tRNA genes, we sum the requirements for each amino acid's codon set:\n$N_{total} = N_{Phe} + N_{Leu} + N_{Ser} + N_{Pro} + N_{Thr} + N_{Ala} + N_{Gly} + N_{Val} + N_{Asp} + N_{Glu} + N_{Lys} + N_{Asn} + N_{Gln} + N_{His} + N_{Tyr} + N_{Cys} + N_{Arg} + N_{Ile} + N_{Met} + N_{Trp}$\n$N_{total} = 1 + 2 + 2 + 2 + 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 2 + 1 + 1 + 1$\n$N_{total} = 25$", "answer": "$$\\boxed{25}$$", "id": "2741600"}, {"introduction": "Beyond individual components, we can predict gene essentiality from a systems-level perspective using computational models of metabolism. This practice introduces Flux Balance Analysis (FBA), a cornerstone technique that simulates metabolic fluxes to predict cellular objectives like growth. You will implement a computational workflow to perform *in silico* single-reaction knockout experiments, allowing you to identify essential reactions within a network based on their impact on a biological function. [@problem_id:2741599]", "problem": "You are given the standard Flux Balance Analysis (FBA) setting for a metabolic network at steady state, where reaction fluxes are represented by a vector $v \\in \\mathbb{R}^{n}$ and internal metabolite mass balances are encoded by a stoichiometric matrix $S \\in \\mathbb{R}^{m \\times n}$. The steady-state assumption implies $S v = 0$. Reaction bounds satisfy $l \\le v \\le u$, where $l, u \\in \\mathbb{R}^{n}$ with $l_i \\le u_i$ for all indices $i \\in \\{0,\\ldots,n-1\\}$. A linear objective $c^{\\top} v$ represents a chosen cellular objective such as growth, where $c \\in \\mathbb{R}^{n}$. A reaction “knockout” for index $j$ enforces $v_j = 0$ in addition to the existing constraints. Define a threshold $\\mu_0 \\in \\mathbb{R}$, and say that reaction $j$ is $\\mu_0$-essential if, under the knockout $v_j = 0$, the optimal value of $c^{\\top} v$ is strictly less than $\\mu_0$. To avoid trivial classifications, if the optimal value of the unperturbed problem (no knockouts) is strictly less than $\\mu_0$, then by convention return the empty set (no reaction is reported as $\\mu_0$-essential in that case).\n\nStarting from the steady-state mass conservation $S v = 0$, bounds $l \\le v \\le u$, and the definition of a reaction knockout as $v_j = 0$, formulate the Linear Program (LP) for each reaction $j$ that decides $\\mu_0$-essentiality. Implement an algorithm that, given $(S,l,u,c,\\mu_0)$, returns the sorted list of zero-based indices $j$ that are $\\mu_0$-essential.\n\nYour implementation must solve the LP\n$$\n\\max_{v \\in \\mathbb{R}^{n}} \\; c^{\\top} v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l \\le v \\le u\n$$\nto obtain the unperturbed optimum, and for each reaction knockout index $j \\in \\{0,\\ldots,n-1\\}$, solve\n$$\n\\max_{v \\in \\mathbb{R}^{n}} \\; c^{\\top} v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l \\le v \\le u,\\;\\; v_j = 0.\n$$\nUse a strict comparison “$$” to test whether the knockout optimum is below $\\mu_0$. If the unperturbed optimum is strictly less than $\\mu_0$, return the empty set by convention.\n\nTest Suite. Use the following test cases, each specified by $(S,l,u,c,\\mu_0)$, with all arrays given in row-major order. All numbers in the definitions below are exact real numbers.\n\n- Test Case $1$ (redundant pathway, threshold equals wild-type optimum):\n  $$\n  S_1 =\n  \\begin{bmatrix}\n  1  -1  0  -1  -1 \\\\\n  0  1  -1  0  1\n  \\end{bmatrix},\\quad\n  l_1 = \\begin{bmatrix} 0  0  0  0  0 \\end{bmatrix},\\quad\n  u_1 = \\begin{bmatrix} 10  1000  1000  1000  1000 \\end{bmatrix},\n  $$\n  $$\n  c_1 = \\begin{bmatrix} 0  0  1  0  0 \\end{bmatrix},\\quad\n  \\mu_{0,1} = 10.\n  $$\n  The reactions are ordered as columns of $S_1$: index $0$ is uptake, index $2$ is the objective drain.\n\n- Test Case $2$ (same network, zero threshold):\n  $$\n  S_2 = S_1,\\;\\; l_2 = l_1,\\;\\; u_2 = u_1,\\;\\; c_2 = c_1,\\;\\; \\mu_{0,2} = 0.\n  $$\n\n- Test Case $3$ (blocked reaction present, threshold equals wild-type optimum):\n  $$\n  S_3 = \\begin{bmatrix} 1  -1  -1 \\end{bmatrix},\\quad\n  l_3 = \\begin{bmatrix} 0  0  0 \\end{bmatrix},\\quad\n  u_3 = \\begin{bmatrix} 1  1000  0 \\end{bmatrix},\\quad\n  c_3 = \\begin{bmatrix} 0  1  0 \\end{bmatrix},\\quad\n  \\mu_{0,3} = 1.\n  $$\n\n- Test Case $4$ (threshold above wild-type optimum, return empty set by convention):\n  $$\n  S_4 = S_3,\\;\\; l_4 = l_3,\\;\\; u_4 = u_3,\\;\\; c_4 = c_3,\\;\\; \\mu_{0,4} = 2.\n  $$\n\nYour program must compute, for each test case, the sorted list of zero-based indices of reactions that are $\\mu_0$-essential under the stated convention. The final output format is a single line containing the results for all test cases as a comma-separated list enclosed in square brackets. Each element corresponding to a test case should itself be a list of integers. For example, a valid output with four test cases could look like\n$[ [0,2], [\\,], [0,1], [\\,] ]$.\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3,result4]$). No units are involved in this problem. Angles are not involved. Percentages must not be used anywhere; any ratio, if needed, must be expressed as a decimal number.", "solution": "The problem requires implementing an algorithm to find $\\mu_0$-essential reactions in a metabolic network using Flux Balance Analysis (FBA). The core of the method is to solve a series of Linear Programs (LPs).\n\n**1. Unperturbed (Wild-Type) Analysis**\nFirst, we solve the base FBA problem to find the maximum objective value for the unperturbed network, $z_{wt}$. The LP is:\n$$\nz_{wt} = \\max_{v} \\; c^{\\top} v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l \\le v \\le u\n$$\nAccording to the problem's convention, if $z_{wt}  \\mu_0$, no reaction is considered essential, and the algorithm returns an empty set.\n\n**2. Single-Reaction Knockout Analysis**\nIf $z_{wt} \\ge \\mu_0$, we proceed to test each reaction $j$ from $0$ to $n-1$. For each reaction, we simulate a knockout by enforcing the constraint $v_j = 0$. This is equivalent to solving a modified LP where the bounds for reaction $j$ are set to $[0, 0]$. The LP for the knockout of reaction $j$ is:\n$$\nz_{ko,j} = \\max_{v} \\; c^{\\top} v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l \\le v \\le u,\\;\\; v_j = 0\n$$\nA reaction $j$ is defined as $\\mu_0$-essential if its knockout reduces the objective value to be strictly less than the threshold $\\mu_0$. That is, if $z_{ko,j}  \\mu_0$.\n\n**3. Algorithm Summary**\nThe overall algorithm is:\n1. Solve the unperturbed LP to get $z_{wt}$.\n2. If $z_{wt}  \\mu_0$, return an empty list.\n3. Otherwise, initialize an empty list `essential_reactions`.\n4. For each reaction index $j = 0, \\ldots, n-1$:\n    a. Solve the LP with the knockout constraint $v_j=0$ to get $z_{ko,j}$.\n    b. If $z_{ko,j}  \\mu_0$, append $j$ to `essential_reactions`.\n5. Return the sorted list `essential_reactions`.\n\nThe provided code in the answer block implements this logic using `scipy.optimize.linprog` to solve the required LPs for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the final result.\n    \"\"\"\n\n    # Test Case 1\n    S1 = np.array([\n        [1, -1, 0, -1, -1],\n        [0, 1, -1, 0, 1]\n    ])\n    l1 = np.array([0, 0, 0, 0, 0])\n    u1 = np.array([10, 1000, 1000, 1000, 1000])\n    c1 = np.array([0, 0, 1, 0, 0])\n    mu0_1 = 10.0\n\n    # Test Case 2\n    S2, l2, u2, c2 = S1, l1, u1, c1\n    mu0_2 = 0.0\n\n    # Test Case 3\n    S3 = np.array([[1, -1, -1]])\n    l3 = np.array([0, 0, 0])\n    u3 = np.array([1, 1000, 0])\n    c3 = np.array([0, 1, 0])\n    mu0_3 = 1.0\n\n    # Test Case 4\n    S4, l4, u4, c4 = S3, l3, u3, c3\n    mu0_4 = 2.0\n\n    test_cases = [\n        (S1, l1, u1, c1, mu0_1),\n        (S2, l2, u2, c2, mu0_2),\n        (S3, l3, u3, c3, mu0_3),\n        (S4, l4, u4, c4, mu0_4),\n    ]\n\n    def _solve_lp(c, S, l, u, knockout_idx=None):\n        \"\"\"\n        Helper function to solve the FBA linear program.\n        Maximizes c^T v subject to Sv=0 and l = v = u.\n        A knockout sets the flux of a specific reaction to zero.\n        Returns the optimal objective value, or -np.inf if infeasible.\n        \"\"\"\n        # We use linprog to minimize, so we minimize (-c)^T v\n        c_min = -np.array(c, dtype=float)\n        \n        # Prepare constraints\n        S_mat = np.array(S, dtype=float)\n        m, n = S_mat.shape\n        b_eq = np.zeros(m)\n        \n        # Prepare bounds\n        bounds = list(zip(l, u))\n        if knockout_idx is not None:\n            # Enforce v_j = 0 by setting bounds to (0, 0)\n            bounds[knockout_idx] = (0.0, 0.0)\n\n        # Solve the LP\n        res = linprog(c=c_min, A_eq=S_mat, b_eq=b_eq, bounds=bounds, method='highs')\n\n        # Return objective value for the maximization problem\n        if res.success:\n            return -res.fun\n        else:\n            # If infeasible (status=2) or another error, the maximum objective value \n            # is effectively negative infinity.\n            return -np.inf\n\n    def find_essential_reactions(S, l, u, c, mu_0):\n        \"\"\"\n        Identifies mu_0-essential reactions based on the problem definition.\n        \"\"\"\n        num_reactions = len(c)\n        \n        # 1. Solve the unperturbed (wild-type) problem\n        opt_wt = _solve_lp(c, S, l, u)\n        \n        # 2. Apply the convention for trivial classification\n        # We use a small tolerance for floating point comparisons to be robust,\n        # although direct comparison works for the given test cases.\n        # The problem asks for \"strictly less than\".\n        if opt_wt  mu_0:\n            return []\n            \n        essential_indices = []\n        # 3. Iterate through all possible single-reaction knockouts\n        for j in range(num_reactions):\n            opt_ko = _solve_lp(c, S, l, u, knockout_idx=j)\n            \n            # 4. Check if the knockout objective is strictly less than the threshold\n            if opt_ko  mu_0:\n                essential_indices.append(j)\n                \n        # The list is already sorted as we iterate from 0 to n-1.\n        return essential_indices\n\n    results = []\n    for case in test_cases:\n        S, l, u, c, mu_0 = case\n        result = find_essential_reactions(S, l, u, c, mu_0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output should be a string representation of a list of lists, with no spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n\n```", "id": "2741599"}, {"introduction": "Both experimental and computational screens for essential genes produce large datasets that require careful statistical evaluation. A common and critical challenge is class imbalance—essential genes are typically a small fraction of the genome, where the prevalence is denoted by $p$. This exercise delves into the mathematics of classifier performance, guiding you to derive why the precision-recall curve provides a more insightful evaluation than the Receiver Operating Characteristic (ROC) curve in this realistic, imbalanced scenario. [@problem_id:2741586]", "problem": "In a genome minimization project, you seek to map essential genes in a bacterium by predicting essentiality from transposon insertion sequencing features using a binary classifier that outputs a score. Let the fraction of essential genes in the genome (the positive class prevalence) be $p \\in (0,1)$, and suppose that, across decision thresholds, the classifier’s Receiver Operating Characteristic (ROC) curve is empirically well-approximated by the parametric relation $\\mathrm{TPR} = \\sqrt{\\mathrm{FPR}}$, where $\\mathrm{TPR}$ is the true positive rate and $\\mathrm{FPR}$ is the false positive rate.\n\nUse only fundamental definitions of evaluation metrics and Bayes’ rule for conditional probabilities to:\n\n1. Derive the expression for precision at a given threshold as a function of $p$, $\\mathrm{TPR}$, and $\\mathrm{FPR}$.\n2. Using the given ROC relation, compute the exact area under the precision–recall curve (average precision) as a function of $p$ by integrating precision over recall from $0$ to $1$.\n3. Briefly justify, based on your derivation, why the ROC area under the curve does not reflect the skew introduced by class imbalance when essential genes are a minority, but the precision–recall area does.\n\nYour final reported answer must be a single closed-form analytic expression in terms of $p$ for the precision–recall area under the curve. Do not include units. No numerical rounding is required.", "solution": "The goal is to connect class prevalence to evaluation metrics using first principles and then quantify the impact of class imbalance analytically.\n\nFoundational definitions:\n- Define the total number of genes as $N$, the number of essential (positive) genes as $N_{+} = pN$, and the number of nonessential (negative) genes as $N_{-} = (1-p)N$.\n- True positive rate (TPR; sensitivity, recall) is $\\mathrm{TPR} = \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FN}}$.\n- False positive rate (FPR) is $\\mathrm{FPR} = \\frac{\\mathrm{FP}}{\\mathrm{FP} + \\mathrm{TN}}$.\n- Precision (positive predictive value) is $\\mathrm{Prec} = \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}$.\n- By definition across thresholds, $\\mathrm{TP} = N_{+} \\cdot \\mathrm{TPR} = pN \\cdot \\mathrm{TPR}$ and $\\mathrm{FP} = N_{-} \\cdot \\mathrm{FPR} = (1-p)N \\cdot \\mathrm{FPR}$.\n- Precision can be derived via Bayes’ rule as the posterior probability that a predicted positive is truly positive: $\\mathrm{Prec} = \\mathbb{P}(\\text{positive} \\mid \\text{predicted positive})$.\n\nStep 1: Derive precision as a function of $p$, $\\mathrm{TPR}$, and $\\mathrm{FPR}$.\nUsing the definitions,\n$$\n\\mathrm{Prec} \\;=\\; \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}\n\\;=\\; \\frac{pN \\cdot \\mathrm{TPR}}{pN \\cdot \\mathrm{TPR} + (1-p)N \\cdot \\mathrm{FPR}}\n\\;=\\; \\frac{p \\cdot \\mathrm{TPR}}{p \\cdot \\mathrm{TPR} + (1-p) \\cdot \\mathrm{FPR}}.\n$$\nThis exhibits the explicit dependence of precision on the class prevalence $p$.\n\nStep 2: Compute the area under the precision–recall curve (average precision) as a function of $p$ given the ROC relation.\nWe are given the ROC curve $\\mathrm{TPR} = \\sqrt{\\mathrm{FPR}}$. Write $\\mathrm{FPR}$ as $u \\in [0,1]$ and denote recall $R = \\mathrm{TPR} = f(u) = \\sqrt{u}$. Precision at the threshold corresponding to $u$ is\n$$\n\\mathrm{Prec}(u) \\;=\\; \\frac{p \\cdot R}{p \\cdot R + (1-p) \\cdot u}\n\\;=\\; \\frac{p \\sqrt{u}}{p \\sqrt{u} + (1-p) u}.\n$$\nIt is algebraically convenient to divide numerator and denominator by $\\sqrt{u}$, yielding\n$$\n\\mathrm{Prec}(u) \\;=\\; \\frac{p}{p + (1-p)\\sqrt{u}}.\n$$\nAverage precision (AP) is defined as the area under the precision–recall curve,\n$$\n\\mathrm{AP}(p) \\;=\\; \\int_{0}^{1} \\mathrm{Prec}(R) \\, dR.\n$$\nUsing the parameter $u$ with $R = \\sqrt{u}$, we have $dR = \\frac{1}{2} u^{-1/2} \\, du$, so\n$$\n\\mathrm{AP}(p)\n\\;=\\; \\int_{u=0}^{1} \\mathrm{Prec}(u) \\, \\frac{dR}{du} \\, du\n\\;=\\; \\int_{0}^{1} \\frac{p}{p + (1-p)\\sqrt{u}} \\cdot \\frac{1}{2} u^{-1/2} \\, du.\n$$\nSubstitute $x = \\sqrt{u}$, so $u = x^{2}$ and $du = 2x \\, dx$. Then $u^{-1/2} = x^{-1}$. The integral simplifies to\n$$\n\\mathrm{AP}(p)\n\\;=\\; \\int_{x=0}^{1} \\frac{p}{p + (1-p)x} \\, dx.\n$$\nThis integral is elementary. Compute\n$$\n\\int \\frac{p}{p + (1-p)x} \\, dx\n\\;=\\; \\frac{p}{1-p} \\ln\\!\\big(p + (1-p)x\\big) \\;+\\; C.\n$$\nEvaluate from $x=0$ to $x=1$:\n$$\n\\mathrm{AP}(p)\n\\;=\\; \\frac{p}{1-p} \\left[ \\ln\\!\\big(p + (1-p)\\cdot 1\\big) - \\ln\\!\\big(p + (1-p)\\cdot 0\\big) \\right]\n\\;=\\; \\frac{p}{1-p} \\left[ \\ln(1) - \\ln(p) \\right].\n$$\nSince $\\ln(1) = 0$, we obtain the closed form\n$$\n\\mathrm{AP}(p) \\;=\\; - \\frac{p}{1-p} \\ln(p).\n$$\n\nStep 3: Justify why ROC area under the curve does not reflect class imbalance, but precision–recall area does.\nThe ROC area under the curve is\n$$\n\\mathrm{AUC}_{\\mathrm{ROC}} \\;=\\; \\int_{0}^{1} \\mathrm{TPR} \\, d(\\mathrm{FPR})\n\\;=\\; \\int_{0}^{1} \\sqrt{u} \\, du\n\\;=\\; \\left[ \\frac{2}{3} u^{3/2} \\right]_{0}^{1}\n\\;=\\; \\frac{2}{3},\n$$\nwhich is independent of $p$ because $\\mathrm{TPR}$ and $\\mathrm{FPR}$ are rates normalized by class totals. In contrast, the precision–recall area depends on $p$ through the posterior odds embodied in precision. Specifically,\n$$\n\\mathrm{AP}(p) \\;=\\; - \\frac{p}{1-p} \\ln(p),\n$$\nwhich decreases to $0$ as $p \\to 0$ and approaches $1$ as $p \\to 1$. Therefore, when essential genes constitute a minority class (small $p$), $\\mathrm{AUC}_{\\mathrm{ROC}}$ remains $\\frac{2}{3}$ and masks the severity of class imbalance, whereas $\\mathrm{AP}(p)$ shrinks, faithfully reflecting the difficulty of attaining high precision at low prevalence. This establishes the analytical basis for preferring precision–recall analysis over ROC analysis in the essential gene mapping setting under class imbalance.\n\nThe required final answer is the closed-form expression for $\\mathrm{AP}(p)$.", "answer": "$$\\boxed{-\\frac{p}{1-p}\\ln(p)}$$", "id": "2741586"}]}