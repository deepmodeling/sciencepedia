{"hands_on_practices": [{"introduction": "At the heart of any genetic code expansion system lies the orthogonal aminoacyl-tRNA synthetase (aaRS). Its ability to discriminate with high fidelity between the desired non-canonical amino acid (ncAA) and the cell's vast excess of the 20 canonical amino acids is paramount for success. This exercise [@problem_id:2541335] challenges you to move from biochemical data to cellular prediction, using the fundamental enzyme kinetic parameter of the specificity constant, $k_{\\text{cat}}/K_M$, to quantitatively assess the in vivo fidelity of an engineered aaRS.", "problem": "You have engineered an orthogonal aminoacyl-tRNA synthetase (aaRS) and transfer ribonucleic acid (tRNA) pair to incorporate a defined non-canonical amino acid (ncAA) in Escherichia coli. In vitro steady-state kinetics yield a specificity constant of $k_{\\mathrm{cat}}/K_M = 5\\times 10^{5} \\text{ M}^{-1}\\text{s}^{-1}$ for the ncAA and $k_{\\mathrm{cat}}/K_M  10^{2} \\text{ M}^{-1}\\text{s}^{-1}$ for each of the $20$ canonical amino acids. Assume the pair is orthogonal at the tRNA level: the engineered aaRS does not aminoacylate host tRNAs and no host aaRS aminoacylates the engineered tRNA. Further assume the enzyme operates in vivo in a regime where it is not saturated by any amino acid substrate. In fast-growing cells, the summed intracellular concentration of the $20$ canonical amino acids is approximately $10$ mM, with individual canonical amino acids each in the range $0.05$–$3$ mM, and a feeding strategy yields a cytosolic ncAA concentration of approximately $1$ mM. Ignore downstream factors such as elongation factor binding and ribosomal selection; focus on the amino acid selection step by the engineered aaRS.\n\nWhich statement is best supported regarding whether amino acid-level orthogonality and specificity are sufficient for in vivo use under these conditions?\n\nA. Yes. Under the stated concentrations, the engineered aaRS will charge the orthogonal tRNA with the ncAA in $99\\%$ of charging events, so amino acid-level orthogonality is sufficient; additional post-transfer editing would not materially change the outcome.\n\nB. No. Because the $20$ canonical amino acids sum to about $10$ mM, they will dominate enzyme encounters unless the ncAA reaction is diffusion-limited (on the order of $\\ge 10^{8}$ M$^{-1}$s$^{-1}$), which it is not, so mischarging will be prevalent.\n\nC. No. Without an explicit post-transfer editing domain, misactivated canonical amino acids will be transferred at high frequency irrespective of the measured specificity constants, so amino acid-level orthogonality is insufficient.\n\nD. Inconclusive. Separate knowledge of $k_{\\mathrm{cat}}$ and $K_M$ is required; the ratio $k_{\\mathrm{cat}}/K_M$ alone cannot inform selectivity in cells even when the enzyme is unsaturated by substrates.", "solution": "The problem asks for an evaluation of the in vivo sufficiency of an engineered aminoacyl-tRNA synthetase (aaRS) and its cognate transfer ribonucleic acid (tRNA) pair. The evaluation must be based on provided in vitro kinetic data and in vivo substrate concentrations.\n\nFirst, we must validate the problem statement.\n\n**Step 1: Extract Givens**\n- Engineered orthogonal aaRS/tRNA pair for incorporation of a non-canonical amino acid (ncAA).\n- Host organism: *Escherichia coli*.\n- Specificity constant for ncAA: $(k_{\\mathrm{cat}}/K_M)_{\\mathrm{ncAA}} = 5 \\times 10^{5} \\text{ M}^{-1}\\text{s}^{-1}$.\n- Specificity constant for each of the $20$ canonical amino acids (cAAs): $(k_{\\mathrm{cat}}/K_M)_{\\mathrm{cAA}}  10^{2} \\text{ M}^{-1}\\text{s}^{-1}$.\n- Assumption of tRNA-level orthogonality: The engineered aaRS does not aminoacylate host tRNAs, and host aaRSs do not aminoacylate the engineered tRNA.\n- Assumption of in vivo kinetics: The enzyme operates in a regime where it is not saturated by any amino acid substrate. That is, $[S] \\ll K_M$ for all amino acids.\n- Assumption to ignore downstream factors: Elongation factor binding and ribosomal selection are not to be considered.\n- Intracellular concentration of ncAA: $[\\mathrm{ncAA}] \\approx 1 \\text{ mM} = 1 \\times 10^{-3} \\text{ M}$.\n- Summed intracellular concentration of the $20$ cAAs: $\\sum_{i=1}^{20} [\\mathrm{cAA}_i] \\approx 10 \\text{ mM} = 1 \\times 10^{-2} \\text{ M}$.\n- Concentration range for individual cAAs: $0.05$–$3$ mM.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the principles of enzyme kinetics and synthetic biology. The scenario described is a standard problem in the field of genetic code expansion. The kinetic parameters and concentrations are within physically realistic and experimentally observed ranges. The statement is well-posed, providing all necessary information and assumptions to reach a conclusion. The critical assumption that the enzyme is unsaturated ($[S] \\ll K_M$) simplifies the kinetic analysis and makes the problem solvable with the given data, as it dictates the relevant kinetic parameter for determining specificity. The problem is objective and contains no logical contradictions or ambiguities.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. A quantitative solution can be derived.\n\n**Derivation of Solution**\nThe rate of an enzyme-catalyzed reaction, $v$, is described by the Michaelis-Menten equation:\n$$v = \\frac{k_{\\mathrm{cat}}[E_0][S]}{K_M + [S]}$$\nwhere $[E_0]$ is the total enzyme concentration, $[S]$ is the substrate concentration, $k_{\\mathrm{cat}}$ is the turnover number, and $K_M$ is the Michaelis constant.\n\nThe problem explicitly states that the enzyme is not saturated by any of its amino acid substrates. This corresponds to the kinetic regime where $[S] \\ll K_M$. Under this condition, the Michaelis-Menten equation simplifies to a second-order rate equation:\n$$v \\approx \\frac{k_{\\mathrm{cat}}[E_0][S]}{K_M} = \\left(\\frac{k_{\\mathrm{cat}}}{K_M}\\right) [E_0] [S]$$\nThe term $k_{\\mathrm{cat}}/K_M$ is the specificity constant, which measures the catalytic efficiency of the enzyme for a given substrate at low concentrations.\n\nWe can now compare the rate of correct charging with the ncAA, $v_{\\mathrm{ncAA}}$, to the total rate of mischarging with all $20$ competing canonical amino acids, $v_{\\mathrm{mischarge}}$.\n\nThe rate of correct charging is:\n$$v_{\\mathrm{ncAA}} = \\left(\\frac{k_{\\mathrm{cat}}}{K_M}\\right)_{\\mathrm{ncAA}} [E_0] [\\mathrm{ncAA}]$$\nSubstituting the given values:\n$$v_{\\mathrm{ncAA}} = (5 \\times 10^{5} \\text{ M}^{-1}\\text{s}^{-1}) [E_0] (1 \\times 10^{-3} \\text{ M}) = 500 [E_0] \\text{ s}^{-1}$$\n\nThe total rate of mischarging is the sum of the rates for each of the $20$ canonical amino acids:\n$$v_{\\mathrm{mischarge}} = \\sum_{i=1}^{20} \\left(\\frac{k_{\\mathrm{cat}}}{K_M}\\right)_{\\mathrm{cAA},i} [E_0] [\\mathrm{cAA}_i]$$\nWe are given an upper bound for the specificity constant for any cAA, $(k_{\\mathrm{cat}}/K_M)_{\\mathrm{cAA}}  10^{2} \\text{ M}^{-1}\\text{s}^{-1}$, and the total concentration of cAAs, $\\sum [\\mathrm{cAA}_i] \\approx 10^{-2}$ M. To assess the worst-case scenario for fidelity, we use the upper bound for the mischarging specificity constant for all cAAs. This leads to an upper bound on the total mischarging rate:\n$$v_{\\mathrm{mischarge}}  [E_0] \\sum_{i=1}^{20} (10^{2} \\text{ M}^{-1}\\text{s}^{-1}) [\\mathrm{cAA}_i]$$\n$$v_{\\mathrm{mischarge}}  (10^{2} \\text{ M}^{-1}\\text{s}^{-1}) [E_0] \\sum_{i=1}^{20} [\\mathrm{cAA}_i]$$\n$$v_{\\mathrm{mischarge}}  (10^{2} \\text{ M}^{-1}\\text{s}^{-1}) [E_0] (1 \\times 10^{-2} \\text{ M}) = 1 [E_0] \\text{ s}^{-1}$$\n\nThe fidelity of tRNA charging is the fraction of charging events that are correct. This is given by the ratio of the correct charging rate to the total charging rate ($v_{\\mathrm{total}} = v_{\\mathrm{ncAA}} + v_{\\mathrm{mischarge}}$).\n$$\\text{Fidelity} = \\frac{v_{\\mathrm{ncAA}}}{v_{\\mathrm{ncAA}} + v_{\\mathrm{mischarge}}}$$\nUsing our calculated values:\n$$\\text{Fidelity} \\approx \\frac{500 [E_0]}{500 [E_0] + 1 [E_0]} = \\frac{500}{501} \\approx 0.998$$\nThis translates to a charging fidelity of approximately $99.8\\%$. This is a high degree of specificity.\n\n**Evaluation of Options**\n\n**A. Yes. Under the stated concentrations, the engineered aaRS will charge the orthogonal tRNA with the ncAA in $99\\%$ of charging events, so amino acid-level orthogonality is sufficient; additional post-transfer editing would not materially change the outcome.**\nOur calculation demonstrates that the fidelity is approximately $99.8\\%$, which is indeed greater than $99\\%$. A fidelity this high is generally considered sufficient for many in vivo applications of genetic code expansion. The statement that post-transfer editing would not \"materially\" change the outcome is a reasonable judgment, as the system already performs with high precision. This statement is fully supported by the kinetic analysis.\n**Verdict: Correct.**\n\n**B. No. Because the $20$ canonical amino acids sum to about $10$ mM, they will dominate enzyme encounters unless the ncAA reaction is diffusion-limited (on the order of $\\ge 10^{8}$ M$^{-1}$s$^{-1}$), which it is not, so mischarging will be prevalent.**\nThis statement incorrectly concludes that the higher total concentration of canonical amino acids ($10$ mM) compared to the ncAA ($1$ mM) guarantees prevalent mischarging. It ignores the crucial role of the specificity constant, $k_{\\mathrm{cat}}/K_M$. The rate of reaction is proportional to the product of the specificity constant and the substrate concentration. The ratio of the overall rate of correct charging to mischarging is approximately $500:1$ in favor of the ncAA. Therefore, mischarging is rare, not prevalent. The reference to the diffusion limit is misleading; while a diffusion-limited rate would improve specificity, it is not a prerequisite for achieving high fidelity.\n**Verdict: Incorrect.**\n\n**C. No. Without an explicit post-transfer editing domain, misactivated canonical amino acids will be transferred at high frequency irrespective of the measured specificity constants, so amino acid-level orthogonality is insufficient.**\nThis statement is fundamentally flawed. The specificity constant $k_{\\mathrm{cat}}/K_M$ is precisely the parameter that quantifies the overall efficiency of an enzyme in converting a substrate to a product. It intrinsically accounts for all steps in the catalytic cycle, including substrate binding, any pre-transfer proofreading, chemical transfer ($k_{\\mathrm{cat}}$), and product release. To state that selectivity is \"irrespective of the measured specificity constants\" is a contradiction of basic enzyme kinetics. High specificity can be achieved without a post-transfer editing domain if the active site has very poor affinity ($K_M$) or catalytic activity ($k_{\\mathrm{cat}}$) for non-cognate substrates. The given data, $(k_{\\mathrm{cat}}/K_M)_{\\mathrm{cAA}}  10^{2} \\text{ M}^{-1}\\text{s}^{-1}$, reflects this poor efficiency for canonical amino acids.\n**Verdict: Incorrect.**\n\n**D. Inconclusive. Separate knowledge of $k_{\\mathrm{cat}}$ and $K_M$ is required; the ratio $k_{\\mathrm{cat}}/K_M$ alone cannot inform selectivity in cells even when the enzyme is unsaturated by substrates.**\nThis statement is incorrect. The condition that the enzyme is unsaturated ($[S] \\ll K_M$) is precisely the scenario where the specificity constant, $k_{\\mathrm{cat}}/K_M$, is the sole determinant of kinetic preference between competing substrates. The ratio of reaction rates for two substrates $S_1$ and $S_2$ simplifies to $\\frac{v_1}{v_2} = \\frac{(k_{\\mathrm{cat}}/K_M)_1 [S_1]}{(k_{\\mathrm{cat}}/K_M)_2 [S_2]}$. There is no need for separate values of $k_{\\mathrm{cat}}$ and $K_M$ under this specified condition. The problem is conclusive.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "2541335"}, {"introduction": "Beyond intrinsic enzyme specificity, the overall efficiency of ncAA incorporation is a systems-level property that depends on the concentration and availability of all components. A common but non-obvious failure mode is the \"sponge effect,\" where high-level expression of the target protein titrates the limited pool of suppressor tRNA, starving the ribosome of the necessary building block. This problem [@problem_id:2132932] guides you through the process of translating this biological phenomenon into a quantitative framework, building a steady-state kinetic model to predict the available concentration of charged tRNA, $[T^*]$, under different expression loads.", "problem": "A research group is optimizing a genetic code expansion system in *Escherichia coli* to incorporate a non-canonical amino acid (ncAA) in response to an amber stop codon (UAG). This system relies on an engineered, orthogonal aminoacyl-tRNA synthetase (aaRS) and its cognate suppressor transfer RNA (tRNA). The group observes a significant drop in the ncAA incorporation efficiency when the target protein's gene is moved from a low-copy to a high-copy plasmid. This suggests that the high load of target messenger RNA (mRNA) transcripts titrates out the limited pool of ncAA-incorporation machinery.\n\nTo quantify this \"sponge\" effect, consider a simplified kinetic model of the cell. The total cellular concentration of the orthogonal suppressor tRNA, $[T_{\\text{total}}]$, is constant. The orthogonal aaRS charges the uncharged tRNA with the ncAA at a rate that can be modeled as a first-order process with an effective rate constant $k_{charge}$. The resulting acylated (charged) suppressor tRNA, $[T^*]$, is consumed during translation. This consumption happens at two main sites: the UAG codons on the target gene's mRNA and the natural UAG stop codons of endogenous *E. coli* genes. The total rate of consumption of $[T^*]$ through endogenous gene translation can be modeled with an effective first-order rate constant $k_{endo}$. The rate of consumption of $[T^*]$ due to translation of the target gene is proportional to the plasmid copy number, $C$, and can be described by an effective rate constant $k_{target}$ per plasmid copy.\n\nGiven the following parameters for a strain harboring a high-copy plasmid:\n- Total cellular concentration of orthogonal suppressor tRNA, $[T_{\\text{total}}] = 2.0$ μM\n- Effective first-order rate constant for tRNA charging, $k_{charge} = 5.0$ s⁻¹\n- Effective first-order rate constant for consumption by endogenous genes, $k_{endo} = 1.0$ s⁻¹\n- Effective first-order rate constant for consumption per target plasmid copy, $k_{target} = 0.20$ s⁻¹\n- Plasmid copy number, $C_{high} = 300$\n\nCalculate the steady-state concentration of the acylated suppressor tRNA, $[T^*]$. Express your final answer in units of micromolar (μM), rounded to three significant figures.", "solution": "The problem asks for the steady-state concentration of the acylated (charged) suppressor tRNA, denoted as $[T^*]$. At steady state, the rate of formation of $[T^*]$ must equal its rate of consumption.\n\n**Step 1: Define the concentrations and the conservation equation.**\nLet $[T^*]$ be the concentration of the acylated suppressor tRNA and $[T_{\\text{un}}]$ be the concentration of the uncharged suppressor tRNA. The total concentration of the suppressor tRNA, $[T_{\\text{total}}]$, is the sum of the charged and uncharged forms:\n$$[T_{\\text{total}}] = [T^*] + [T_{\\text{un}}]$$\nFrom this, we can express the concentration of uncharged tRNA in terms of the total and charged concentrations:\n$$[T_{\\text{un}}] = [T_{\\text{total}}] - [T^*]$$\n\n**Step 2: Formulate the rate of formation of acylated tRNA.**\nThe problem states that the charging of the tRNA is a first-order process with respect to the uncharged tRNA concentration, $[T_{\\text{un}}]$. The rate of formation, $V_{\\text{formation}}$, is therefore:\n$$V_{\\text{formation}} = k_{charge} [T_{\\text{un}}]$$\nSubstituting the expression for $[T_{\\text{un}}]$ from Step 1:\n$$V_{\\text{formation}} = k_{charge} ([T_{\\text{total}}] - [T^*])$$\n\n**Step 3: Formulate the rate of consumption of acylated tRNA.**\nThe acylated tRNA is consumed in two parallel processes: translation of endogenous genes with UAG stop codons, and translation of the target gene which contains a UAG codon.\nThe rate of consumption by endogenous genes, $V_{\\text{endo}}$, is a first-order process with respect to $[T^*]$:\n$$V_{\\text{endo}} = k_{endo} [T^*]$$\nThe rate of consumption by the target gene, $V_{\\text{target}}$, depends on the concentration $[T^*]$, the rate constant per plasmid $k_{target}$, and the number of plasmids $C_{high}$:\n$$V_{\\text{target}} = k_{target} C_{high} [T^*]$$\nThe total rate of consumption, $V_{\\text{consumption}}$, is the sum of these two rates:\n$$V_{\\text{consumption}} = V_{\\text{endo}} + V_{\\text{target}} = k_{endo} [T^*] + k_{target} C_{high} [T^*]$$\n$$V_{\\text{consumption}} = (k_{endo} + k_{target} C_{high}) [T^*]$$\n\n**Step 4: Apply the steady-state approximation and solve for $[T^*]$.**\nAt steady state, the rate of formation equals the rate of consumption:\n$$V_{\\text{formation}} = V_{\\text{consumption}}$$\n$$k_{charge} ([T_{\\text{total}}] - [T^*]) = (k_{endo} + k_{target} C_{high}) [T^*]$$\nOur goal is to solve this equation for $[T^*]$. First, we distribute $k_{charge}$ on the left side:\n$$k_{charge} [T_{\\text{total}}] - k_{charge} [T^*] = (k_{endo} + k_{target} C_{high}) [T^*]$$\nNext, we gather all terms containing $[T^*]$ on one side of the equation:\n$$k_{charge} [T_{\\text{total}}] = k_{charge} [T^*] + (k_{endo} + k_{target} C_{high}) [T^*]$$\nFactor out $[T^*]$:\n$$k_{charge} [T_{\\text{total}}] = (k_{charge} + k_{endo} + k_{target} C_{high}) [T^*]$$\nFinally, isolate $[T^*]$ by dividing both sides by the term in the parenthesis:\n$$[T^*] = \\frac{k_{charge} [T_{\\text{total}}]}{k_{charge} + k_{endo} + k_{target} C_{high}}$$\n\n**Step 5: Substitute the numerical values and calculate the final answer.**\nNow we substitute the given values into the derived expression:\n$[T_{\\text{total}}] = 2.0$ μM\n$k_{charge} = 5.0$ s⁻¹\n$k_{endo} = 1.0$ s⁻¹\n$k_{target} = 0.20$ s⁻¹\n$C_{high} = 300$\n\n$$[T^*] = \\frac{(5.0 \\, \\text{s}^{-1}) (2.0 \\, \\mu\\text{M})}{5.0 \\, \\text{s}^{-1} + 1.0 \\, \\text{s}^{-1} + (0.20 \\, \\text{s}^{-1})(300)}$$\nFirst, calculate the product in the denominator:\n$$(0.20 \\, \\text{s}^{-1})(300) = 60 \\, \\text{s}^{-1}$$\nNow, substitute this back into the equation:\n$$[T^*] = \\frac{10.0 \\, \\mu\\text{M} \\cdot \\text{s}^{-1}}{5.0 \\, \\text{s}^{-1} + 1.0 \\, \\text{s}^{-1} + 60 \\, \\text{s}^{-1}}$$\n$$[T^*] = \\frac{10.0 \\, \\mu\\text{M} \\cdot \\text{s}^{-1}}{66.0 \\, \\text{s}^{-1}}$$\n$$[T^*] \\approx 0.151515... \\, \\mu\\text{M}$$\nThe problem requires the answer to be rounded to three significant figures.\n$$[T^*] \\approx 0.152 \\, \\mu\\text{M}$$\nThe final answer is required in units of μM.", "answer": "$$\\boxed{0.152}$$", "id": "2132932"}, {"introduction": "The metabolic and genetic burden imposed by a synthetic system is a critical consideration that can impact host cell fitness and the robustness of the engineered function. Expressing orthogonal translation machinery consumes shared cellular resources, most notably ribosomes, creating a trade-off between producing synthetic components and synthesizing the native proteins required for growth. In this advanced practice [@problem_id:2741416], you will implement a whole-cell computational model to explore this trade-off, predicting how the translational load from expressing aaRS–tRNA modules affects the global growth rate by solving a self-consistent system that couples ribosome allocation, tRNA charging dynamics, and translation elongation speed.", "problem": "You are tasked with writing a complete, runnable program that models resource competition in genetic code expansion with non-canonical amino acids (ncAAs) by quantifying how increasing expression of multiple aminoacyl-tRNA synthetases (aaRSs) and transfer RNAs (tRNAs) affects the host translation apparatus and, consequently, the growth rate. The model must be derived from fundamental principles: the Central Dogma (information flow from DNA to RNA to protein), ribosome-limited translation, and steady-state balance between tRNA charging and consumption. You must implement the model detailed below and compute the predicted steady-state growth rate for a provided test suite. All growth rates must be expressed in hours inverse ($\\mathrm{h}^{-1}$) and rounded to six decimal places.\n\nModeling assumptions and definitions:\n- There is a fixed total ribosome pool $R_{\\mathrm{tot}}$ that is allocated among translating classes proportional to their initiation loads. Let $\\Lambda_H$ denote the effective initiation load for the host proteome and $\\Lambda_j$ the load for the $j$-th additional expressed module (e.g., an aaRS–tRNA operon), for $j \\in \\{1,\\dots,n\\}$. The ribosomes allocated to host proteome synthesis are\n$$\nr_H \\;=\\; R_{\\mathrm{tot}} \\cdot \\frac{\\Lambda_H}{\\Lambda_H + \\sum_{j=1}^{n} \\Lambda_j}.\n$$\n- Translation elongation is limited by the availability of charged tRNA pools. Define $s=0$ as the canonical host pool and $s=j$ as the $j$-th ncAA pool, one per introduced aaRS–tRNA module. Let $w_s$ be the host codon demand weight for pool $s$ with $\\sum_{s} w_s = 1$. Let $v$ be the elongation rate in amino acids per second and $v_{\\max}$ its maximal value when charging is not limiting. The per-pool steady-state charged fraction $f_s$ follows a birth–death balance in which charging inflow equals consumption outflow:\n$$\nC_s \\cdot (1 - f_s) \\;=\\; D_s \\cdot f_s,\n$$\nwhere $C_s$ is the total charging capacity of pool $s$ (in amino acids per second aggregated over all tRNAs in that pool) and $D_s$ is the consumption demand from ribosomal elongation. With host translation consuming a fraction $w_s$ of incorporated residues, the total demand for pool $s$ is\n$$\nD_s \\;=\\; v \\cdot r_H \\cdot w_s.\n$$\nSolving the balance yields the steady-state charged fraction\n$$\nf_s \\;=\\; \\frac{C_s}{C_s + v \\cdot r_H \\cdot w_s}.\n$$\n- The overall elongation rate is bottlenecked by the scarcest charged pool:\n$$\nv \\;=\\; v_{\\max} \\cdot \\min_{s \\,\\text{with}\\, w_s  0} f_s.\n$$\n- The host growth rate $\\mu$ scales with the total host protein synthesis flux, which factorizes into the fraction of ribosomes translating the host proteome and the normalized elongation rate:\n$$\n\\mu \\;=\\; \\mu_{\\max} \\cdot \\left(\\frac{r_H}{R_{\\mathrm{tot}}}\\right) \\cdot \\left(\\frac{v}{v_{\\max}}\\right).\n$$\n\nYour program must:\n1. Implement the above model to compute the steady-state elongation rate $v$ self-consistently from its fixed-point definition. You must solve for $v$ numerically using a deterministic iteration that converges to the fixed point. If for any $s$ with $w_s0$ one has $C_s=0$, set $v=0$ (no growth due to an uncharged required pool).\n2. Compute $r_H$ from the initiation loads.\n3. Compute $\\mu$ in $\\mathrm{h}^{-1}$ from the final $v$.\n4. Round each $\\mu$ to six decimal places.\n\nConstants (shared by all test cases):\n- $R_{\\mathrm{tot}} = 20000$.\n- $v_{\\max} = 15$.\n- $\\mu_{\\max} = 1.5$.\n- $\\Lambda_H = 1.0$.\n\nTest suite (each test case specifies $(\\Lambda_1,\\Lambda_2,\\dots)$, $(C_0,C_1,\\dots)$, and $(w_0,w_1,\\dots)$):\n- Case 1 (single aaRS, moderate burden and capacity):\n  - Loads: $(\\Lambda_1) = (0.3)$.\n  - Capacities: $(C_0,C_1) = (1.2\\times 10^6,\\,1.0\\times 10^5)$.\n  - Weights: $(w_0,w_1) = (0.98,\\,0.02)$.\n- Case 2 (single aaRS, high burden, low capacity):\n  - Loads: $(\\Lambda_1) = (1.5)$.\n  - Capacities: $(C_0,C_1) = (1.2\\times 10^6,\\,5.0\\times 10^3)$.\n  - Weights: $(w_0,w_1) = (0.95,\\,0.05)$.\n- Case 3 (two aaRS modules, moderate burdens, canonical pool partially limiting):\n  - Loads: $(\\Lambda_1,\\Lambda_2) = (0.2,\\,0.4)$.\n  - Capacities: $(C_0,C_1,C_2) = (8.0\\times 10^5,\\,1.5\\times 10^5,\\,1.0\\times 10^5)$.\n  - Weights: $(w_0,w_1,w_2) = (0.90,\\,0.05,\\,0.05)$.\n- Case 4 (no ncAA incorporation but translation burden from expression):\n  - Loads: $(\\Lambda_1) = (1.0)$.\n  - Capacities: $(C_0,C_1) = (1.0\\times 10^6,\\,1.0\\times 10^5)$.\n  - Weights: $(w_0,w_1) = (1.00,\\,0.00)$.\n- Case 5 (very high aaRS expression burden but ample ncAA charging capacity):\n  - Loads: $(\\Lambda_1) = (3.0)$.\n  - Capacities: $(C_0,C_1) = (1.2\\times 10^6,\\,1.0\\times 10^7)$.\n  - Weights: $(w_0,w_1) = (0.95,\\,0.05)$.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[0.123456,0.234567,0.345678,0.456789,0.567890]\"). The list must contain the five computed growth rates $\\mu$ for the test cases in the order presented, each rounded to six decimal places, in units of $\\mathrm{h}^{-1}$.", "solution": "The submitted problem is subjected to rigorous validation and is deemed valid. It is a well-posed, scientifically grounded problem in quantitative systems biology, free from contradiction or ambiguity. The task is to compute the host organism's growth rate under the metabolic burden imposed by expressing components for genetic code expansion. The model is based on established principles of resource allocation in cellular growth. We shall proceed with the derivation of the solution.\n\nThe model is defined by a system of coupled algebraic equations. The key variables are the number of ribosomes allocated to host protein synthesis, $r_H$, the steady-state elongation rate, $v$, and the resulting growth rate, $\\mu$.\n\nFirst, the allocation of the total ribosome pool, $R_{\\mathrm{tot}}$, is determined by the relative translational initiation loads of the host proteome, $\\Lambda_H$, and the $n$ synthetic modules, $\\Lambda_j$. The number of ribosomes for the host is given by:\n$$\nr_H = R_{\\mathrm{tot}} \\cdot \\frac{\\Lambda_H}{\\Lambda_H + \\sum_{j=1}^{n} \\Lambda_j}\n$$\nThis quantity, $r_H$, is constant for a given set of expressed modules.\n\nSecond, the translation elongation rate, $v$, is limited by the availability of charged tRNAs. For each tRNA pool $s$ (where $s=0$ represents the canonical pools and $s  0$ the non-canonical ones), a steady-state is assumed between the charging rate and the consumption rate. The fraction of charged tRNA in pool $s$, $f_s$, is:\n$$\nf_s(v) = \\frac{C_s}{C_s + v \\cdot r_H \\cdot w_s}\n$$\nwhere $C_s$ is the charging capacity of the synthetase for pool $s$, and $w_s$ is the codon usage fraction for the corresponding amino acid in the host proteome. The elongation rate $v$ is bottlenecked by the least available charged tRNA pool required for translation (i.e., pools for which $w_s  0$):\n$$\nv = v_{\\max} \\cdot \\min_{s \\,|\\, w_s  0} \\{f_s(v)\\}\n$$\nThis equation defines $v$ implicitly as a fixed point. To solve for $v$, we must find the root of the equation $g(v) = v - F(v) = 0$, where $F(v)$ is the right-hand side of the equation for $v$.\nLet us define the function $F(v)$:\n$$\nF(v) = v_{\\max} \\cdot \\min_{s \\,|\\, w_s  0} \\left( \\frac{C_s}{C_s + v \\cdot r_H \\cdot w_s} \\right)\n$$\nThe function $F(v)$ is a continuous, monotonically non-increasing function of $v$ for $v \\ge 0$. The function $y=v$ is monotonically increasing. It follows that a unique non-negative fixed point $v^* = F(v^*)$ must exist. The problem specifies a deterministic iterative procedure. We will employ the fixed-point iteration scheme:\n$$\nv_{k+1} = F(v_k)\n$$\nWe initialize the iteration with $v_0 = v_{\\max}$. The iteration is performed for a sufficient number of steps to ensure convergence to the fixed point $v_{final}$. A special case must be handled: if $C_s = 0$ for any pool $s$ with a non-zero demand ($w_s  0$), then $f_s$ is always $0$, leading to $v_{final} = 0$.\n\nFinally, the host growth rate $\\mu$ is proportional to the total flux of host protein synthesis. This flux is the product of the number of ribosomes synthesizing host proteins, $r_H$, and their speed, $v$. Normalizing by the maximum possible values, we obtain:\n$$\n\\mu = \\mu_{\\max} \\cdot \\left(\\frac{r_H}{R_{\\mathrm{tot}}}\\right) \\cdot \\left(\\frac{v_{final}}{v_{\\max}}\\right)\n$$\nSubstituting the expressions for $r_H$ and $v_{final}$, we arrive at the final formula for $\\mu$:\n$$\n\\mu = \\mu_{\\max} \\cdot \\left(\\frac{\\Lambda_H}{\\Lambda_H + \\sum_{j=1}^{n} \\Lambda_j}\\right) \\cdot \\left( \\min_{s \\,|\\, w_s  0} \\left\\{ \\frac{C_s}{C_s + v_{final} \\cdot r_H \\cdot w_s} \\right\\} \\right)\n$$\n\nThe computational algorithm for each test case is as follows:\n$1$. Given the parameters $(\\Lambda_1, \\dots, \\Lambda_n)$, $(C_0, C_1, \\dots)$, and $(w_0, w_1, \\dots)$, and constants $R_{\\mathrm{tot}}$, $v_{\\max}$, $\\mu_{\\max}$, $\\Lambda_H$.\n$2$. Compute the sum of external loads $\\sum_{j=1}^{n} \\Lambda_j$.\n$3$. Calculate the number of host-translating ribosomes, $r_H = R_{\\mathrm{tot}} \\cdot \\Lambda_H / (\\Lambda_H + \\sum_{j=1}^{n} \\Lambda_j)$.\n$4$. Identify the set of indices $S_{req} = \\{s \\,|\\, w_s  0\\}$. Check if $C_s = 0$ for any $s \\in S_{req}$. If so, set $v_{final} = 0$ and proceed to step $6$.\n$5$. Numerically solve for the fixed point of $v$. Initialize $v_0 = v_{\\max}$. Iterate $v_{k+1} = v_{\\max} \\cdot \\min_{s \\in S_{req}} \\{ C_s / (C_s + v_k \\cdot r_H \\cdot w_s) \\}$ for a fixed number of iterations (e.g., $100$) to find $v_{final}$.\n$6$. Calculate the growth rate $\\mu = \\mu_{\\max} \\cdot (r_H/R_{\\mathrm{tot}}) \\cdot (v_{final}/v_{\\max})$.\n$7$. Round the result to six decimal places.\n\nThis procedure is implemented for all provided test cases to generate the final output. The use of floating-point arithmetic throughout the calculation maintains precision. The deterministic iteration is robust and converges rapidly for the given parameter space.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# Note: Although numpy is available, it is not required for this problem.\n\n# Define constants from the problem statement\nR_tot = 20000.0\nv_max = 15.0\nmu_max = 1.5\nLambda_H = 1.0\n\ndef calculate_growth_rate(lambdas, capacities, weights):\n    \"\"\"\n    Calculates the growth rate for a single set of parameters based on the model.\n    \"\"\"\n    # Step 1: Calculate the number of ribosomes allocated to host proteome synthesis, r_H.\n    sum_lambdas = sum(lambdas)\n    denominator_rH = Lambda_H + sum_lambdas\n    r_H = R_tot * Lambda_H / denominator_rH\n\n    # Step 2: Solve for the steady-state elongation rate, v, self-consistently.\n    # Find indices 's' for pools required for translation (where w_s > 0).\n    required_indices = [i for i, w in enumerate(weights) if w > 0]\n    \n    # Handle the special case where a required pool has zero charging capacity.\n    # This leads to zero elongation rate and thus zero growth.\n    for i in required_indices:\n        if capacities[i] == 0:\n            return 0.0\n\n    # Solve for v using fixed-point iteration as specified.\n    # Initialize v with its maximum possible value.\n    v = v_max\n    # A fixed number of iterations is robust and sufficient for convergence in this system.\n    for _ in range(100):\n        # Calculate the charged fraction f_s for each required tRNA pool.\n        f_s_values = [\n            capacities[i] / (capacities[i] + v * r_H * weights[i])\n            for i in required_indices\n        ]\n        \n        # The overall elongation rate is limited by the scarcest charged pool (min f_s).\n        min_f_s = min(f_s_values)\n        v = v_max * min_f_s\n    \n    v_final = v\n\n    # Step 3: Compute the host growth rate, mu.\n    # mu is a product of the maximal rate, ribosome allocation factor, and elongation factor.\n    # The term (r_H / R_tot) is the ribosome allocation factor.\n    # The term (v_final / v_max) is the elongation factor.\n    mu = mu_max * (r_H / R_tot) * (v_final / v_max)\n    \n    return mu\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Define the test suite from the problem statement.\n    test_cases = [\n        # Case 1: single aaRS, moderate burden and capacity\n        {\"lambdas\": (0.3,), \"capacities\": (1.2e6, 1.0e5), \"weights\": (0.98, 0.02)},\n        # Case 2: single aaRS, high burden, low capacity\n        {\"lambdas\": (1.5,), \"capacities\": (1.2e6, 5.0e3), \"weights\": (0.95, 0.05)},\n        # Case 3: two aaRS modules, moderate burdens, canonical pool partially limiting\n        {\"lambdas\": (0.2, 0.4), \"capacities\": (8.0e5, 1.5e5, 1.0e5), \"weights\": (0.90, 0.05, 0.05)},\n        # Case 4: no ncAA incorporation but translation burden from expression\n        {\"lambdas\": (1.0,), \"capacities\": (1.0e6, 1.0e5), \"weights\": (1.00, 0.00)},\n        # Case 5: very high aaRS expression burden but ample ncAA charging capacity\n        {\"lambdas\": (3.0,), \"capacities\": (1.2e6, 1.0e7), \"weights\": (0.95, 0.05)},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the growth rate for each case.\n        mu = calculate_growth_rate(case[\"lambdas\"], case[\"capacities\"], case[\"weights\"])\n        results.append(mu)\n\n    # Format the final output as a comma-separated list of strings,\n    # with each result rounded to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2741416"}]}