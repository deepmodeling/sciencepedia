{"hands_on_practices": [{"introduction": "Before engineering the genetic code, we must possess the tools to measure it. This exercise introduces the Relative Synonymous Codon Usage (RSCU) metric, a cornerstone for quantifying codon bias from sequence data. By deriving and applying the formula for RSCU to a hypothetical codon compression scenario [@problem_id:2772544], you will develop a quantitative intuition for how recoding schemes alter the statistical landscape of a genome, a skill essential for evaluating any genome engineering project.", "problem": "A core approach to genetic firewalling is sense codon compression, in which multiple synonymous codons that encode the same amino acid are merged into fewer functional classes to free codons for reassignment. Consider a single amino acid with multiple synonymous codons. In a corpus of coding sequences from an engineered organism, let the total number of occurrences of that amino acid be $N_{a}$, and let $k$ denote the original number of synonymous codons for that amino acid. For each synonymous codon $i$, let $n_{i}$ be its observed count. The Relative Synonymous Codon Usage (RSCU) metric is widely used to quantify codon bias relative to an equal-usage baseline across the $k$ synonymous codons.\n\nTasks:\n- Using only the definitions implied by the Central Dogma of Molecular Biology and the notion of a uniform-usage baseline across synonymous codons, give a precise mathematical definition of the Relative Synonymous Codon Usage (RSCU) for a codon $i$ encoding a given amino acid.\n- Under a codon-compression scheme that merges a subset $S$ of the $k$ synonymous codons for the amino acid into a single recoded codon class, while leaving the remaining codons partitioned into disjoint classes such that there are $k^{\\prime}$ total recoded classes for the amino acid after compression, define the transformed RSCU of the merged class $S$ by reference to the corresponding equal-usage baseline across the $k^{\\prime}$ classes. Derive an expression for this transformed RSCU in terms of the observed counts and, if possible from first principles, in terms of the pre-compression RSCU values.\n- Then, using the following scientifically plausible data for leucine in an engineered Escherichia coli genome undergoing sense codon compression for genetic firewalling, compute the transformed RSCU of the merged class $M_{1}$:\n  - Amino acid: leucine. Original synonym set size $k = 6$.\n  - Observed counts in a curated coding set: $n(\\mathrm{CTA}) = 31$, $n(\\mathrm{CTT}) = 29$, $n(\\mathrm{TTA}) = 40$, $n(\\mathrm{CTC}) = 25$, $n(\\mathrm{CTG}) = 75$, $n(\\mathrm{TTG}) = 20$.\n  - Compression merges into $k^{\\prime} = 2$ recoded classes: $M_{1} = \\{\\mathrm{CTA}, \\mathrm{CTT}, \\mathrm{TTA}\\}$ and $M_{2} = \\{\\mathrm{CTC}, \\mathrm{CTG}, \\mathrm{TTG}\\}$.\n  \nProvide the final transformed RSCU value of $M_{1}$ as an exact fraction. Do not round.", "solution": "The problem presents a valid, well-posed query within the domain of synthetic biology and bioinformatics. It is scientifically grounded, free of ambiguity, and contains all necessary information for a rigorous solution. We shall proceed by addressing the three tasks in the specified order.\n\nThe first task is to provide a precise mathematical definition of Relative Synonymous Codon Usage (RSCU). The RSCU metric compares the observed frequency of a codon to its expected frequency under a null hypothesis of equal usage among all synonymous codons for a given amino acid.\n\nLet there be an amino acid encoded by a set of $k$ synonymous codons. For a given corpus of gene sequences, let $n_{i}$ be the observed count of the $i$-th synonymous codon, where $i \\in \\{1, 2, \\dots, k\\}$. The total number of occurrences of this amino acid, $N_{a}$, is the sum of the counts of all its associated codons:\n$$N_{a} = \\sum_{j=1}^{k} n_{j}$$\nIf all $k$ codons were utilized with equal probability, the expected count, $E[n_i]$, for any codon $i$ would be the total count $N_a$ distributed evenly among the $k$ options:\n$$E[n_i] = \\frac{N_{a}}{k}$$\nThe RSCU for codon $i$, denoted $\\text{RSCU}_{i}$, is formally defined as the ratio of its observed count to its expected count:\n$$\\text{RSCU}_{i} = \\frac{n_{i}}{E[n_i]} = \\frac{n_{i}}{\\frac{N_{a}}{k}} = \\frac{k \\cdot n_{i}}{\\sum_{j=1}^{k} n_{j}}$$\n\nThe second task is to define and derive an expression for the transformed RSCU for a merged class of codons. In a codon-compression scheme, the original $k$ codons are partitioned into $k^{\\prime}$ new classes. Let $S$ be one such class, representing a subset of the original codons that are now treated as a single functional unit.\nThe fundamental principle of RSCU is conserved: it is the ratio of observed to expected usage. However, the uniform-usage baseline is now applied across the $k^{\\prime}$ new classes. The total count for the amino acid, $N_{a}$, remains unchanged.\nThe observed count for the merged class $S$, denoted $n_{S}$, is the sum of the counts of the individual codons it comprises:\n$$n_{S} = \\sum_{i \\in S} n_{i}$$\nThe new expected count for any of the $k^{\\prime}$ classes, under a uniform distribution, is:\n$$E'[n_S] = \\frac{N_{a}}{k^{\\prime}}$$\nThe transformed RSCU for the merged class $S$, which we denote $\\text{RSCU}'_{S}$, is therefore:\n$$\\text{RSCU}'_{S} = \\frac{n_{S}}{E'[n_S]} = \\frac{\\sum_{i \\in S} n_{i}}{\\frac{N_{a}}{k^{\\prime}}} = \\frac{k^{\\prime} \\cdot \\sum_{i \\in S} n_{i}}{\\sum_{j=1}^{k} n_{j}}$$\nThis expression can also be formulated in terms of the pre-compression $\\text{RSCU}_{i}$ values. From the original definition, $n_{i} = \\text{RSCU}_{i} \\cdot \\frac{N_{a}}{k}$. Substituting this into the expression for $n_{S}$ yields:\n$$n_{S} = \\sum_{i \\in S} \\left( \\text{RSCU}_{i} \\cdot \\frac{N_{a}}{k} \\right) = \\frac{N_{a}}{k} \\sum_{i \\in S} \\text{RSCU}_{i}$$\nSubstituting this back into the formula for $\\text{RSCU}'_{S}$:\n$$\\text{RSCU}'_{S} = \\frac{k^{\\prime} \\cdot n_{S}}{N_{a}} = \\frac{k^{\\prime}}{N_{a}} \\left(\\frac{N_{a}}{k} \\sum_{i \\in S} \\text{RSCU}_{i}\\right) = \\frac{k^{\\prime}}{k} \\sum_{i \\in S} \\text{RSCU}_{i}$$\nThis provides a direct relationship between the pre- and post-compression RSCU values.\n\nThe third task is to compute the transformed RSCU for a specific merged class using the provided data.\nThe givens are:\n- Amino acid: Leucine\n- Original number of codons: $k = 6$\n- New number of classes: $k^{\\prime} = 2$\n- Observed counts: $n(\\mathrm{CTA}) = 31$, $n(\\mathrm{CTT}) = 29$, $n(\\mathrm{TTA}) = 40$, $n(\\mathrm{CTC}) = 25$, $n(\\mathrm{CTG}) = 75$, $n(\\mathrm{TTG}) = 20$.\n- Merged class for calculation: $M_{1} = \\{\\mathrm{CTA}, \\mathrm{CTT}, \\mathrm{TTA}\\}$.\n\nFirst, we calculate the total count for leucine, $N_{a}$:\n$$N_{a} = 31 + 29 + 40 + 25 + 75 + 20 = 220$$\nNext, we calculate the total count for the merged class $M_{1}$, denoted $n_{M_{1}}$:\n$$n_{M_{1}} = n(\\mathrm{CTA}) + n(\\mathrm{CTT}) + n(\\mathrm{TTA}) = 31 + 29 + 40 = 100$$\nUsing the derived formula for the transformed RSCU, $\\text{RSCU}'_{S} = \\frac{k^{\\prime} \\cdot n_{S}}{N_{a}}$, we substitute the values for the class $M_1$:\n$$\\text{RSCU}'_{M_{1}} = \\frac{2 \\cdot 100}{220} = \\frac{200}{220}$$\nThe problem requires an exact fraction, so we simplify this result:\n$$\\text{RSCU}'_{M_{1}} = \\frac{20}{22} = \\frac{10}{11}$$", "answer": "$$\\boxed{\\frac{10}{11}}$$", "id": "2772544"}, {"introduction": "At its core, sense codon compression is an engineering design challenge: which codons should be kept, and which should be removed? This practice introduces a powerful method for solving this problem by framing it as a constrained optimization task known as an Integer Linear Program (ILP) [@problem_id:2772541]. You will learn to balance the objective of minimizing the codon set against the crucial constraints of proteome-wide amino acid demand and tRNA availability, providing a practical foundation in the computational design of synthetic genomes.", "problem": "You are tasked with formulating and solving a minimal-sense-codon compression problem as an Integer Linear Program (ILP) for genetic firewalling. The biological basis is the Central Dogma of molecular biology, which states that deoxyribonucleic acid (DNA) is transcribed to ribonucleic acid (RNA) and translated to protein. Translation uses the canonical mapping from codon triplets to amino acids. Sense codon compression reduces redundancy in the genetic code by retaining a subset of sense codons while ensuring that all amino acids required by a given set of coding sequences remain encodable after recoding. The goal is to minimize the number of retained sense codons while ensuring full amino acid coverage across all given coding sequences, under practical per-codon usage limits (capacities) and optional forbidden codons that cannot be retained (for example, because they are reassigned to a noncanonical amino acid to enforce a genetic firewall).\n\nFormally define:\n- Let $\\mathcal{S}$ be a set of coding sequences over the alphabet $\\{A, C, G, T\\}$, each with length divisible by $3$ and containing no stop codons in-frame.\n- Let $\\mathcal{C}$ be the set of all sense codons in the Standard Genetic Code (stop codons excluded).\n- Let $G: \\mathcal{C} \\to \\mathcal{A}$ be the canonical mapping from codons to amino acids, where $\\mathcal{A}$ is the set of standard amino acids represented by one-letter codes.\n- For each amino acid $a \\in \\mathcal{A}$, define $\\mathcal{C}(a) = \\{c \\in \\mathcal{C} \\mid G(c) = a\\}$.\n- For each amino acid $a$, define the total demand $d_a$ as the total number of occurrences of $a$ across all sequences in $\\mathcal{S}$ when translated via $G$.\n- For each codon $c \\in \\mathcal{C}$, define an integer capacity $k_c \\in \\mathbb{Z}_{\\ge 0}$ representing the maximum allowed usage of codon $c$ across the entire recoding task (motivated by translational supply-demand balance and design constraints to avoid problematic motifs).\n- Let $\\mathcal{F} \\subseteq \\mathcal{C}$ be the set of forbidden codons that cannot be retained.\n\nPose the following Integer Linear Program (ILP) to select retained sense codons:\n- Decision variables: for each codon $c \\in \\mathcal{C}$, let $x_c \\in \\{0,1\\}$ indicate whether $c$ is retained.\n- Objective: minimize $\\sum_{c \\in \\mathcal{C}} x_c$.\n- Constraints:\n  1. For each amino acid $a$ that appears at least once in the translations of $\\mathcal{S}$, ensure coverage by capacities:\n     $$\\sum_{c \\in \\mathcal{C}(a)} k_c \\, x_c \\ge d_a.$$\n  2. For each forbidden codon $c \\in \\mathcal{F}$, enforce $x_c = 0$.\n  3. For all $c \\in \\mathcal{C}$, enforce $x_c \\in \\{0,1\\}$.\n\nInterpretation: After choosing the retained codons, all coding sequences can be recoded so that every occurrence of an amino acid $a$ is rewritten using retained codons from $\\mathcal{C}(a)$ without exceeding per-codon usage capacities. This corresponds to sense codon compression compatible with the observed proteome while enhancing genetic firewalling by minimizing retained codons.\n\nYour task is to write a complete, runnable program that:\n- Computes the optimal objective value of the ILP above for each of the specified test cases.\n- If the ILP is infeasible, it must return $-1$ for that test case.\n\nNote: Although the problem is posed as an Integer Linear Program (ILP), you are free to exploit any structural properties to solve it algorithmically, provided the returned value is the true optimum.\n\nUse the Standard Genetic Code (DNA codons) for all sense codons, excluding stop codons. Angles are not involved. No physical units are involved. All outputs must be integers. \n\nTest Suite:\nFor each test case below, you are given:\n- A list of coding DNA sequences $\\mathcal{S}$, each in-frame and length divisible by $3$.\n- A base capacity $K_0$ applied to any codon not explicitly overridden.\n- A dictionary of per-codon capacity overrides $\\{(c, k_c)\\}$ that supersede $K_0$ when provided.\n- A set of forbidden codons $\\mathcal{F}$.\n\nYour program must compute the optimal value of $\\sum_{c \\in \\mathcal{C}} x_c$ for each case or $-1$ if infeasible.\n\n- Test case $1$:\n  - $\\mathcal{S} = [\\text{\"ATGGCTGTTGGTTCTCGTCCTACTAAAGAA\"}, \\text{\"ATGCTTACCGCAGGCAGA\"}]$\n  - $K_0 = 2$\n  - Overrides: none\n  - $\\mathcal{F} = \\varnothing$\n- Test case $2$:\n  - $\\mathcal{S} = [\\text{\"ATGGGTGGTGGTGGTGGTGGTGGTGGT\"}]$\n  - $K_0 = 3$\n  - Overrides: none\n  - $\\mathcal{F} = \\{\\text{\"GGG\"}\\}$\n- Test case $3$:\n  - $\\mathcal{S} = [\\text{\"ATGCTGCTGCTGCTGCTG\"}]$\n  - $K_0 = 2$\n  - Overrides: $\\{(\\text{\"CTG\"}, 4)\\}$\n  - $\\mathcal{F} = \\{\\text{\"TTA\"}, \\text{\"TTG\"}, \\text{\"CTT\"}, \\text{\"CTC\"}, \\text{\"CTA\"}\\}$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the test cases in the order given (e.g., $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$). Each $\\text{result}_i$ must be an integer, with infeasible cases denoted by $-1$.", "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded in molecular biology, mathematically well-posed as an Integer Linear Program (ILP), and provides a complete, unambiguous, and consistent set of definitions and data.\n\nThe problem is to find the optimal value of an ILP designed for sense codon compression. The objective is to minimize the total number of retained sense codons, subject to constraints that ensure all required amino acids remain encodable up to their specified demands, considering per-codon capacities and a set of forbidden codons.\n\nLet the decision variables be $x_c \\in \\{0, 1\\}$ for each sense codon $c \\in \\mathcal{C}$, where $x_c=1$ if codon $c$ is retained and $x_c=0$ otherwise. The ILP is formulated as:\n\nMinimize:\n$$ \\sum_{c \\in \\mathcal{C}} x_c $$\n\nSubject to:\n1. For each amino acid $a \\in \\mathcal{A}$ with demand $d_a > 0$: \n   $$ \\sum_{c \\in \\mathcal{C}(a)} k_c \\, x_c \\ge d_a $$\n2. For each forbidden codon $c \\in \\mathcal{F}$:\n   $$ x_c = 0 $$\n3. For all $c \\in \\mathcal{C}$:\n   $$ x_c \\in \\{0, 1\\} $$\n\nHere, $\\mathcal{C}(a)$ is the set of codons encoding amino acid $a$, $d_a$ is the total demand for amino acid $a$, and $k_c$ is the usage capacity of codon $c$.\n\nA critical structural property of this ILP is its decomposability. The objective function is a sum over all codons, which can be partitioned by the amino acid they encode:\n$$ \\sum_{c \\in \\mathcal{C}} x_c = \\sum_{a \\in \\mathcal{A}} \\left( \\sum_{c \\in \\mathcal{C}(a)} x_c \\right) $$\nThe constraints for a given amino acid $a$ involve only the decision variables $\\{x_c \\mid c \\in \\mathcal{C}(a)\\}$. These variables do not appear in the constraints for any other amino acid $a' \\neq a$. This independence allows the global optimization problem to be decomposed into a set of smaller, independent subproblems, one for each amino acid $a \\in \\mathcal{A}$ with a non-zero demand $d_a$.\n\nFor each such amino acid $a$, we must solve the following subproblem: find the minimum number of codons from $\\mathcal{C}(a)$ to retain, denoted by $N_a$, such that the demand $d_a$ is satisfied. The subproblem is:\n\nMinimize:\n$$ N_a = \\sum_{c \\in \\mathcal{C}(a)} x_c $$\n\nSubject to:\n$$ \\sum_{c \\in \\mathcal{C}(a) \\setminus \\mathcal{F}} k_c \\, x_c \\ge d_a $$\n$$ x_c \\in \\{0, 1\\} \\text{ for } c \\in \\mathcal{C}(a) \\setminus \\mathcal{F} $$\n\nThe total optimal number of codons for the original problem is then simply the sum of the optimal solutions to these subproblems: $\\sum_{a \\mid d_a > 0} N_a$. If any subproblem is infeasible, the entire problem is infeasible.\n\nEach subproblem is equivalent to the following: given a set of available (non-forbidden) codons for amino acid $a$, each with a specific capacity $k_c$, select the smallest possible subset of these codons whose capacities sum to at least $d_a$. This is a variant of the change-making or unbounded knapsack problem, but with a unit cost for each item.\n\nThis subproblem possesses an optimal greedy solution. To minimize the number of selected codons, one must prioritize those with the highest capacity. The algorithm is as follows:\n1. Consider the set of available codons for amino acid $a$, which is $\\mathcal{C}(a) \\setminus \\mathcal{F}$.\n2. Sort these codons in descending order of their capacities $k_c$.\n3. Sequentially select codons from this sorted list, accumulating their capacities, until the total capacity sum is greater than or equal to the demand $d_a$.\n4. The number of codons selected is the minimum required for amino acid $a$, which is $N_a$.\n5. If the sum of capacities of all available codons for $a$ is less than $d_a$, the subproblem is infeasible.\n\nThe optimality of this greedy strategy can be proven by an exchange argument. Assume a greedy solution $G$ is suboptimal and an optimal solution $O$ exists with fewer codons, $|O| < |G|$. Let the codons be ordered by decreasing capacity. The greedy choice ensures that for any $j \\le |O|$, the capacity of the $j$-th codon in the greedy sequence is greater than or equal to the capacity of the $j$-th codon in the optimal sequence. This implies that the cumulative capacity of the first $|O|$ codons chosen by the greedy algorithm is at least as large as the total capacity of the optimal solution, which itself must be $\\ge d_a$. Therefore, the greedy algorithm would have terminated with at most $|O|$ codons, contradicting the assumption that $|G| > |O|$. Thus, the greedy approach is optimal.\n\nThe overall algorithm is as follows:\n1. For each test case, first parse the input sequences $\\mathcal{S}$ to compute the total demand $d_a$ for each amino acid $a$.\n2. Construct the capacity map $k_c$ for all sense codons based on the base capacity $K_0$ and any specified overrides.\n3. For each amino acid $a$ with $d_a > 0$:\n    a. Identify the set of available codons $\\mathcal{C}(a) \\setminus \\mathcal{F}$ and their corresponding capacities.\n    b. If the total capacity of all available codons is less than $d_a$, the problem is infeasible. Mark the result as $-1$ and terminate for this case.\n    c. Otherwise, apply the greedy selection strategy described above to determine the minimum number of codons $N_a$.\n4. The total objective value is the sum of all $N_a$ over all amino acids with $d_a > 0$.\n\nThis principled, decomposition-based approach correctly and efficiently solves the given ILP.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the codon compression problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the Standard Genetic Code (DNA codons to amino acids)\n    # Stop codons (TAA, TAG, TGA) are excluded.\n    codon_to_aa = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'TAT': 'Y', 'TAC': 'Y', 'CAT': 'H', 'CAC': 'H',\n        'CAA': 'Q', 'CAG': 'Q', 'AAT': 'N', 'AAC': 'N',\n        'AAA': 'K', 'AAG': 'K', 'GAT': 'D', 'GAC': 'D',\n        'GAA': 'E', 'GAG': 'E', 'TGT': 'C', 'TGC': 'C',\n        'TGG': 'W', 'CGT': 'R', 'CGC': 'R', 'CGA': 'R', \n        'CGG': 'R', 'AGT': 'S', 'AGC': 'S', 'AGA': 'R', \n        'AGG': 'R', 'GGT': 'G', 'GGC': 'G', 'GGA': 'G', \n        'GGG': 'G'\n    }\n\n    # Pre-compute the mapping from amino acids to their codons\n    aa_to_codons = defaultdict(list)\n    for codon, aa in codon_to_aa.items():\n        aa_to_codons[aa].append(codon)\n\n    # All sense codons\n    all_sense_codons = list(codon_to_aa.keys())\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"S\": [\"ATGGCTGTTGGTTCTCGTCCTACTAAAGAA\", \"ATGCTTACCGCAGGCAGA\"],\n            \"K0\": 2,\n            \"overrides\": {},\n            \"F\": set()\n        },\n        {\n            \"S\": [\"ATGGGTGGTGGTGGTGGTGGTGGTGGT\"],\n            \"K0\": 3,\n            \"overrides\": {},\n            \"F\": {\"GGG\"}\n        },\n        {\n            \"S\": [\"ATGCTGCTGCTGCTGCTG\"],\n            \"K0\": 2,\n            \"overrides\": {\"CTG\": 4},\n            \"F\": {\"TTA\", \"TTG\", \"CTT\", \"CTC\", \"CTA\"}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        sequences = case[\"S\"]\n        k0 = case[\"K0\"]\n        overrides = case[\"overrides\"]\n        forbidden_codons = case[\"F\"]\n\n        # Step 1: Compute amino acid demands (d_a)\n        demands = defaultdict(int)\n        full_sequence = \"\".join(sequences)\n        for i in range(0, len(full_sequence), 3):\n            codon = full_sequence[i:i+3]\n            if codon in codon_to_aa:\n                aa = codon_to_aa[codon]\n                demands[aa] += 1\n        \n        # Step 2: Compute codon capacities (k_c)\n        capacities = {c: k0 for c in all_sense_codons}\n        capacities.update(overrides)\n\n        # Step 3: Solve subproblem for each amino acid\n        total_retained_codons = 0\n        is_infeasible = False\n        \n        for aa, demand in demands.items():\n            if demand == 0:\n                continue\n\n            # Get available codons and their capacities for the current amino acid\n            available_codon_capacities = []\n            for codon in aa_to_codons[aa]:\n                if codon not in forbidden_codons:\n                    available_codon_capacities.append(capacities[codon])\n            \n            # Check for instant infeasibility\n            if sum(available_codon_capacities)  demand:\n                is_infeasible = True\n                break\n            \n            # Sort capacities in descending order for greedy selection\n            available_codon_capacities.sort(reverse=True)\n            \n            # Greedily select codons\n            capacity_sum = 0\n            codons_for_aa = 0\n            for cap in available_codon_capacities:\n                capacity_sum += cap\n                codons_for_aa += 1\n                if capacity_sum >= demand:\n                    break\n            \n            total_retained_codons += codons_for_aa\n\n        if is_infeasible:\n            results.append(-1)\n        else:\n            results.append(total_retained_codons)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2772541"}, {"introduction": "Altering the genetic code can have unintended, system-wide consequences. One of the most critical is the effect on protein quality, as changes in codon usage can alter the dynamics of translation. This exercise explores the link between translation speed and co-translational protein folding using a simple kinetic model [@problem_id:2772556]. By quantifying how acceleration through formerly \"slow\" regions can increase the probability of misfolding, you will gain insight into the delicate balance between genetic design and the physical biology of protein maturation.", "problem": "You are modeling co-translational folding in the context of sense codon compression for genetic firewalling. Sense codon compression modifies transfer ribonucleic acid (tRNA) abundances and codon usage, which can accelerate translation through regions that previously contained slow codons. You will quantify how such acceleration changes the probability of misfolding using a minimal two-state kinetic model. The fundamental base is the Central Dogma of molecular biology (deoxyribonucleic acid to ribonucleic acid to protein), and the well-tested kinetic description that a first-order process with constant rate $k$ over a time $t$ has a transition probability $1 - e^{-kt}$.\n\nModel assumptions and definitions:\n- Consider a single critical slow-codon window of length $L$ codons where, during translation, the nascent chain can nucleate the correct native fold. Let the translation rate in this window be $r$ codons per second, so the dwell time in the window is $T = L / r$ seconds.\n- Within this window, formation of a productive folding nucleus is modeled as a Poisson process with rate $k_f$ in $\\text{s}^{-1}$, giving a probability $p_{\\text{nuc}} = 1 - e^{-k_f T}$ that the nucleus forms before the ribosome exits the window.\n- At the end of the window, if the nucleus formed, the protein still misfolds with a small probability $\\beta$ (dimensionless, between $0$ and $1$). If the nucleus did not form by the end of the window, the protein commits to a misfolded state with probability $\\alpha$ (dimensionless, between $0$ and $1$).\n- The misfolding probability at the end of translation for a single window under translation rate $r$ is therefore a function of $L$, $r$, $k_f$, $\\alpha$, and $\\beta$.\n\nYour task:\n- For each test case, compute the change in misfolding probability $\\Delta R$ due to accelerating translation through the formerly slow region, defined as $\\Delta R = R_{\\text{after}} - R_{\\text{before}}$, where $R_{\\text{before}}$ uses the original translation rate $r_{\\text{before}}$ in the window and $R_{\\text{after}}$ uses the accelerated translation rate $r_{\\text{after}}$. All rates $r$ are in codons per second, $k_f$ is in $\\text{s}^{-1}$, and $L$ is in codons. The output is dimensionless. Express each $\\Delta R$ as a decimal rounded to six places.\n\nInput parameters for each test case are given as a tuple $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta)$.\n\nTest suite:\n1. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (15, 5, 15, 0.3, 0.8, 0.02)$\n2. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (20, 10, 10, 0.25, 0.7, 0.05)$\n3. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (30, 3, 12, 0.4, 0.9, 0.01)$\n4. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (5, 8, 18, 0.05, 0.85, 0.02)$\n5. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (0, 6, 12, 0.5, 0.6, 0.0)$\n\nProgram requirements:\n- Implement a function that, for each test case, computes $R_{\\text{before}}$ and $R_{\\text{after}}$ under the two-state model described above, and returns $\\Delta R$ rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each result must have exactly six digits after the decimal point.\n\nNote: You must not read any input. Use the test suite defined above inside the program.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- A critical folding window of length $L$ codons.\n- Translation rate in the window: $r$ codons/s.\n- Dwell time in the window: $T = L / r$ seconds.\n- Folding nucleus formation rate: $k_f$ in $\\text{s}^{-1}$.\n- Probability of nucleation within time $T$: $p_{\\text{nuc}} = 1 - e^{-k_f T}$.\n- Misfolding probability if nucleus forms: $\\beta$.\n- Misfolding probability if nucleus does not form: $\\alpha$.\n- The task is to compute the change in misfolding probability, $\\Delta R = R_{\\text{after}} - R_{\\text{before}}$, where $R_{\\text{before}}$ and $R_{\\text{after}}$ are the total misfolding probabilities corresponding to translation rates $r_{\\text{before}}$ and $r_{\\text{after}}$.\n- Input parameters are provided as a tuple $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta)$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed against the criteria for validity.\n\n- **Scientifically Grounded:** The problem is valid. It uses a simplified but standard kinetic model based on first-order rate processes, which are fundamental to chemical and biological kinetics. The premise that translation speed (modulated by codon usage) affects co-translational protein folding is a well-established concept in molecular biology. The formula for a first-order process probability, $1 - e^{-kt}$, is correct.\n- **Well-Posed:** The problem is valid. All necessary parameters ($L$, $r_{\\text{before}}$, $r_{\\text{after}}$, $k_f$, $\\alpha$, $\\beta$) are provided for each test case. The objective is clearly defined, and a unique, stable, and meaningful numerical solution can be derived from the given model.\n- **Objective:** The problem is valid. It is formulated using precise, quantitative, and objective language, free of ambiguity or subjective claims.\n\nThe problem formulation is self-contained, consistent, and scientifically sound. The test cases, including the edge case of $L=0$ in test case 5, are valid and serve to test the robustness of the derived model.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. We proceed to the solution.\n\nThe objective is to derive an analytical expression for the total misfolding probability, $R$, as a function of the given parameters, and then use it to compute the change, $\\Delta R$.\n\nThe total misfolding probability, $R$, can be determined using the law of total probability. There are two mutually exclusive pathways to the final state: either the folding nucleus forms within the dwell time $T$, or it does not.\n\nLet $N$ be the event that the folding nucleus forms within time $T$. The probability of this event is given as $P(N) = p_{\\text{nuc}}$.\nLet $N^c$ be the complementary event that the nucleus does not form. Its probability is $P(N^c) = 1 - p_{\\text{nuc}}$.\n\nLet $M$ be the event that the protein misfolds. The problem provides the conditional probabilities:\n- The probability of misfolding given that the nucleus has formed is $P(M|N) = \\beta$.\n- The probability of misfolding given that the nucleus has not formed is $P(M|N^c) = \\alpha$.\n\nAccording to the law of total probability, the total probability of misfolding $R = P(M)$ is:\n$$R = P(M|N)P(N) + P(M|N^c)P(N^c)$$\nSubstituting the known probabilities:\n$$R = \\beta \\cdot p_{\\text{nuc}} + \\alpha \\cdot (1 - p_{\\text{nuc}})$$\nWe are given $p_{\\text{nuc}} = 1 - e^{-k_f T}$. Substituting this expression into the equation for $R$:\n$$R = \\beta(1 - e^{-k_f T}) + \\alpha(1 - (1 - e^{-k_f T}))$$\n$$R = \\beta(1 - e^{-k_f T}) + \\alpha(e^{-k_f T})$$\n$$R = \\beta - \\beta e^{-k_f T} + \\alpha e^{-k_f T}$$\nThis simplifies to:\n$$R = \\beta + (\\alpha - \\beta)e^{-k_f T}$$\nThe dwell time $T$ is defined as $T = L/r$. The total misfolding probability as a function of the primary parameters is therefore:\n$$R(L, r, k_f, \\alpha, \\beta) = \\beta + (\\alpha - \\beta)e^{-k_f L / r}$$\n\nWe are tasked with finding the change in misfolding probability, $\\Delta R = R_{\\text{after}} - R_{\\text{before}}$.\n$R_{\\text{before}}$ is the misfolding probability with the original translation rate $r_{\\text{before}}$:\n$$R_{\\text{before}} = \\beta + (\\alpha - \\beta)e^{-k_f L / r_{\\text{before}}}$$\n$R_{\\text{after}}$ is the misfolding probability with the accelerated translation rate $r_{\\text{after}}$:\n$$R_{\\text{after}} = \\beta + (\\alpha - \\beta)e^{-k_f L / r_{\\text{after}}}$$\n\nThe change, $\\Delta R$, is the difference:\n$$\\Delta R = \\left(\\beta + (\\alpha - \\beta)e^{-k_f L / r_{\\text{after}}}\\right) - \\left(\\beta + (\\alpha - \\beta)e^{-k_f L / r_{\\text{before}}}\\right)$$\nThe term $\\beta$ cancels out, yielding the final expression for $\\Delta R$:\n$$\\Delta R = (\\alpha - \\beta)\\left(e^{-k_f L / r_{\\text{after}}} - e^{-k_f L / r_{\\text{before}}}\\right)$$\n\nThis expression is physically intuitive. The sign of $\\Delta R$ depends on two factors: the sign of $(\\alpha - \\beta)$ and the sign of the term in parentheses. An accelerated translation rate means $r_{\\text{after}}  r_{\\text{before}}$. For a non-zero window length $L0$, this implies that the dwell time decreases, $L/r_{\\text{after}}  L/r_{\\text{before}}$. Because the argument of the exponential function is negative, this leads to $e^{-k_f L / r_{\\text{after}}}  e^{-k_f L / r_{\\text{before}}}$. Consequently, the term in parentheses is positive.\nTherefore, if $\\alpha  \\beta$ (misfolding is more probable when nucleation fails), accelerating translation increases the overall misfolding probability ($\\Delta R  0$). This is because less time is available for the protective folding nucleus to form. Conversely, if $\\alpha  \\beta$, acceleration would decrease misfolding. If $\\alpha=\\beta$, translation speed has no effect on the final misfolding outcome in this model.\n\nThe algorithm for the solution is to apply this final derived formula to each test case provided. For edge cases where $L=0$ or $r_{\\text{after}} = r_{\\text{before}}$, the term in parentheses becomes $e^0 - e^0 = 0$ or the terms are identical, resulting in $\\Delta R = 0$, which is correct.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the co-translational folding misfolding probability problem.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (L, r_before, r_after, k_f, alpha, beta)\n    test_cases = [\n        (15, 5, 15, 0.3, 0.8, 0.02),\n        (20, 10, 10, 0.25, 0.7, 0.05),\n        (30, 3, 12, 0.4, 0.9, 0.01),\n        (5, 8, 18, 0.05, 0.85, 0.02),\n        (0, 6, 12, 0.5, 0.6, 0.0)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, r_before, r_after, k_f, alpha, beta = case\n\n        # The change in misfolding probability is given by the formula:\n        # Delta_R = (alpha - beta) * (exp(-k_f * L / r_after) - exp(-k_f * L / r_before))\n        # This formula is derived from the total probability of misfolding R, which is:\n        # R = beta + (alpha - beta) * exp(-k_f * L / r)\n\n        # Handle edge cases for clarity and efficiency, although the general formula is robust.\n        # If L=0 or rates are the same, dwell times are equal or zero, so no change.\n        if L == 0 or r_before == r_after:\n            delta_R = 0.0\n        # The rates r must be non-zero for dwell time T = L/r to be meaningful.\n        # The problem statement givens do not include zero rates, so we don't need to handle DivisionByZeroError.\n        else:\n            term_alpha_beta_diff = alpha - beta\n            \n            exponent_before = -k_f * L / r_before\n            exponent_after = -k_f * L / r_after\n            \n            exp_diff = np.exp(exponent_after) - np.exp(exponent_before)\n            \n            delta_R = term_alpha_beta_diff * exp_diff\n\n        # Format the result to exactly six decimal places as a string.\n        results.append(f\"{delta_R:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2772556"}]}