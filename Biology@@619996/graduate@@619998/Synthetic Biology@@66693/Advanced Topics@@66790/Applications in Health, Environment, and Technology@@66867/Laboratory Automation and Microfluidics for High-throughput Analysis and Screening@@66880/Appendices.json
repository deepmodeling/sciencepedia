{"hands_on_practices": [{"introduction": "High-throughput screening platforms frequently rely on performing thousands of parallel reactions within miniaturized volumes, such as microfluidic droplets. In these systems, the overall rate of a biochemical process is often governed by the interplay between the intrinsic enzyme kinetics and the physical transport of molecules. This exercise challenges you to model such a coupled system by combining the classic Michaelis-Menten model for enzyme kinetics with film theory for diffusive mass transport [@problem_id:2748343]. Mastering this integration is crucial for accurately predicting and optimizing reaction outcomes in diffusion-limited microscale environments.", "problem": "A microfluidic droplet of volume $V$ contains a soluble substrate at a spatially uniform bulk concentration $C_b(t)$, and a single spherical microbead of exposed area $A$ coated with immobilized enzyme that converts the substrate to product. Under standard thin-film mass transfer theory, the liquid-side diffusive flux toward the bead is $J = k_L \\left(C_b - C_s\\right)$, where $k_L$ is the liquid-side mass transfer coefficient and $C_s$ is the substrate concentration at the bead surface. The surface reaction follows Michaelis–Menten kinetics with a maximum areal rate $V_{\\max}^\\prime$, so that the reaction rate per unit area is $r = \\dfrac{V_{\\max}^\\prime\\, C_s}{K_M + C_s}$, where $K_M$ is the Michaelis constant. Assuming quasi-steady mass transport in the film, mass conservation at the interface requires $J = r$. The droplet is well mixed so that the bulk mass balance is $\\,\\dfrac{d C_b}{dt} = -\\dfrac{A}{V}\\, J\\,$. All symbols denote nonnegative real quantities with appropriate dimensions: $V$ in $\\mathrm{m^3}$, $A$ in $\\mathrm{m^2}$, $k_L$ in $\\mathrm{m/s}$, $V_{\\max}^\\prime$ in $\\mathrm{mol/(m^2\\,s)}$, $K_M$ and $C_b$ in $\\mathrm{mol/m^3}$, and $t$ in $\\mathrm{s}$.\n\nStarting strictly from the stated definitions of diffusive flux, Michaelis–Menten kinetics, interfacial steady-state, and the well-mixed bulk mass balance, derive a closed-form algebraic relation for $C_s$ as a function of $C_b$, $k_L$, $V_{\\max}^\\prime$, and $K_M$ by eliminating the interfacial flux and imposing $J = r$. Use this to express the bulk concentration dynamics $\\,\\dfrac{d C_b}{dt}\\,$ as a scalar ordinary differential equation in $C_b(t)$ only. Then, by separation of variables, express the time $T_f$ required for $C_b(t)$ to decrease from an initial value $C_0$ at $t = 0$ to a target fraction $f$ of the initial concentration (that is, $C_b(T_f) = f\\, C_0$ with $0 < f < 1$) as a definite integral that is well-defined for the given parameters. Your program must evaluate this time $T_f$ numerically for each test case below.\n\nScientific assumptions to be used as the fundamental base:\n- Film theory for mass transport: $J = k_L \\left(C_b - C_s\\right)$.\n- Michaelis–Menten surface reaction: $r = \\dfrac{V_{\\max}^\\prime\\, C_s}{K_M + C_s}$.\n- Interfacial quasi-steady-state: $J = r$ at all times.\n- Well-mixed droplet bulk: $\\dfrac{d C_b}{dt} = -\\dfrac{A}{V}\\, J$.\n\nYour task is to:\n- Derive, implement, and apply the physically admissible interfacial concentration $C_s(C_b)$ implied by the above assumptions without introducing any additional empirical correlations.\n- Compute $T_f$ in seconds for each parameter set listed below by evaluating the exact separated-variable integral implied by the derived scalar dynamics.\n- Ensure numerical stability across transport-limited, reaction-limited, and intermediate regimes.\n\nTest suite (units shown in parentheses):\n- Case $1$ (reaction-limited regime, near saturation):\n  - $V = 1.0\\times 10^{-10}\\ \\mathrm{m^3}$, $A = 8.0\\times 10^{-7}\\ \\mathrm{m^2}$, $k_L = 1.0\\times 10^{-3}\\ \\mathrm{m/s}$,\n    $V_{\\max}^\\prime = 1.0\\times 10^{-8}\\ \\mathrm{mol/(m^2\\,s)}$, $K_M = 0.05\\ \\mathrm{mol/m^3}$,\n    $C_0 = 0.20\\ \\mathrm{mol/m^3}$, $f = 0.10$.\n- Case $2$ (transport-limited regime):\n  - $V = 1.0\\times 10^{-10}\\ \\mathrm{m^3}$, $A = 8.0\\times 10^{-7}\\ \\mathrm{m^2}$, $k_L = 5.0\\times 10^{-5}\\ \\mathrm{m/s}$,\n    $V_{\\max}^\\prime = 1.0\\times 10^{-5}\\ \\mathrm{mol/(m^2\\,s)}$, $K_M = 0.05\\ \\mathrm{mol/m^3}$,\n    $C_0 = 0.20\\ \\mathrm{mol/m^3}$, $f = 0.10$.\n- Case $3$ (intermediate regime):\n  - $V = 1.0\\times 10^{-10}\\ \\mathrm{m^3}$, $A = 8.0\\times 10^{-7}\\ \\mathrm{m^2}$, $k_L = 5.0\\times 10^{-5}\\ \\mathrm{m/s}$,\n    $V_{\\max}^\\prime = 2.0\\times 10^{-7}\\ \\mathrm{mol/(m^2\\,s)}$, $K_M = 0.05\\ \\mathrm{mol/m^3}$,\n    $C_0 = 0.20\\ \\mathrm{mol/m^3}$, $f = 0.10$.\n- Case $4$ (low-substrate limit, first-order kinetics relevant):\n  - $V = 1.0\\times 10^{-10}\\ \\mathrm{m^3}$, $A = 8.0\\times 10^{-7}\\ \\mathrm{m^2}$, $k_L = 5.0\\times 10^{-5}\\ \\mathrm{m/s}$,\n    $V_{\\max}^\\prime = 1.0\\times 10^{-8}\\ \\mathrm{mol/(m^2\\,s)}$, $K_M = 0.05\\ \\mathrm{mol/m^3}$,\n    $C_0 = 0.0020\\ \\mathrm{mol/m^3}$, $f = 0.50$.\n\nProgramming requirements:\n- Implement the physically valid root for $C_s(C_b)$ implied by the above relations and use it to evaluate the interfacial flux $J(C_b)$ exactly from either the transport or reaction side, ensuring numerical robustness in both reaction-limited and transport-limited regimes.\n- Compute $T_f$ in seconds as a floating-point number for each case by numerical quadrature of the separated-variable integral. Express each result in seconds, rounded to exactly $6$ decimal places.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, [result1,result2,result3]), with each time reported to exactly $6$ decimal places in seconds.", "solution": "The problem requires the derivation and numerical evaluation of the time, $T_f$, for the bulk substrate concentration in a microfluidic droplet, $C_b(t)$, to decrease from an initial value $C_0$ to a final value $f C_0$. The process is governed by diffusive mass transport to an enzyme-coated bead and a subsequent surface reaction. The derivation must proceed from the fundamental equations provided.\n\nThe scientific principles stated are:\n$1$. Film theory for mass transport: The diffusive flux $J$ towards the bead surface is given by\n$$J = k_L (C_b - C_s)$$\nwhere $k_L$ is the mass transfer coefficient, $C_b$ is the bulk concentration, and $C_s$ is the surface concentration.\n\n$2$. Michaelis–Menten surface reaction kinetics: The rate of reaction per unit area, $r$, is\n$$r = \\dfrac{V_{\\max}^\\prime\\, C_s}{K_M + C_s}$$\nwhere $V_{\\max}^\\prime$ is the maximum areal reaction rate and $K_M$ is the Michaelis constant.\n\n$3$. Interfacial quasi-steady-state: The flux of substrate to the surface equals the rate of consumption by the reaction at the surface.\n$$J = r$$\n\n$4$. Well-mixed bulk mass balance: The change in bulk concentration over time is due to the consumption at the bead surface.\n$$\\dfrac{d C_b}{dt} = -\\dfrac{A}{V}\\, J$$\nwhere $A$ is the bead's surface area and $V$ is the droplet volume.\n\nOur first step is to derive an expression for the surface concentration $C_s$ as a function of the bulk concentration $C_b$ by applying the quasi-steady-state assumption, $J=r$.\n$$k_L (C_b - C_s) = \\dfrac{V_{\\max}^\\prime\\, C_s}{K_M + C_s}$$\nThis equation must be solved for $C_s$. Rearranging the terms yields a quadratic equation in $C_s$:\n$$k_L (C_b - C_s)(K_M + C_s) = V_{\\max}^\\prime C_s$$\n$$k_L (C_b K_M + C_b C_s - K_M C_s - C_s^2) = V_{\\max}^\\prime C_s$$\n$$k_L C_s^2 + (V_{\\max}^\\prime + k_L K_M - k_L C_b) C_s - k_L C_b K_M = 0$$\nThis is a standard quadratic equation of the form $a x^2 + b x + c = 0$ with $x = C_s$, and coefficients:\n$a = k_L$\n$b = V_{\\max}^\\prime + k_L K_M - k_L C_b$\n$c = -k_L C_b K_M$\n\nThe solutions for $C_s$ are given by the quadratic formula, $C_s = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$. The product of the roots is $c/a = -C_b K_M$, which is non-positive since all parameters are non-negative. This implies that one root is non-negative and the other is non-positive. As concentration must be a non-negative quantity, we must select the non-negative root. The discriminant $\\Delta = b^2 - 4ac = (V_{\\max}^\\prime + k_L K_M - k_L C_b)^2 + 4k_L^2 C_b K_M$ is always non-negative. The term $\\sqrt{\\Delta}$ is greater than or equal to $|b|$. Thus, the physically valid root is:\n$$C_s(C_b) = \\dfrac{-(V_{\\max}^\\prime + k_L K_M - k_L C_b) + \\sqrt{(V_{\\max}^\\prime + k_L K_M - k_L C_b)^2 + 4 k_L^2 C_b K_M}}{2 k_L}$$\nThis equation provides the surface concentration $C_s$ for any given bulk concentration $C_b$. It can also be shown that this root satisfies the physical constraint $0 \\le C_s \\le C_b$.\n\nNext, we formulate the ordinary differential equation (ODE) for $C_b(t)$. The rate of change is $\\dfrac{d C_b}{dt} = -\\dfrac{A}{V}\\, J$. The flux $J$ can be expressed as a function of $C_b$ alone by using either the transport or reaction rate expression. For numerical stability, it is preferable to use the reaction rate expression, as it avoids the subtraction of potentially large, close numbers that can occur in the transport expression $J = k_L(C_b - C_s)$.\n$$J(C_b) = r(C_s(C_b)) = \\dfrac{V_{\\max}^\\prime\\, C_s(C_b)}{K_M + C_s(C_b)}$$\nSubstituting this into the bulk mass balance gives the desired scalar ODE:\n$$\\dfrac{d C_b}{dt} = -\\dfrac{A}{V} \\left( \\dfrac{V_{\\max}^\\prime\\, C_s(C_b)}{K_M + C_s(C_b)} \\right)$$\nThis is a first-order ODE with a separable variable $C_b(t)$. To find the time $T_f$ required for the concentration to fall from $C_0$ to $f C_0$, we separate the variables and integrate:\n$$dt = -\\dfrac{V}{A} \\dfrac{1}{J(C_b)} dC_b$$\n$$\\int_0^{T_f} dt = -\\dfrac{V}{A} \\int_{C_0}^{f C_0} \\dfrac{1}{J(C_b)} dC_b$$\nBy reversing the limits of integration to make the integral positive (since $f C_0 < C_0$ and $J(C_b) > 0$), we get the final expression for $T_f$:\n$$T_f = \\dfrac{V}{A} \\int_{f C_0}^{C_0} \\dfrac{1}{J(C_b)} dC_b$$\nwhere the integrand is\n$$\\dfrac{1}{J(C_b)} = \\dfrac{K_M + C_s(C_b)}{V_{\\max}^\\prime\\, C_s(C_b)}$$\nand $C_s(C_b)$ is the function of $C_b$ derived previously.\n\nThis integral does not have a simple closed-form analytical solution for the general case. Therefore, it must be evaluated numerically. The Python implementation will use the `scipy.integrate.quad` function for robust numerical quadrature to compute this definite integral for each set of parameters provided in the test suite. The program first defines a function for the integrand, $1/J(C_b)$, which itself calculates $C_s(C_b)$ for each value of $C_b$ supplied by the quadrature routine. The final time $T_f$ is then calculated by multiplying the integral's result by the geometric factor $V/A$.", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the time Tf for the substrate concentration to drop to a\n    fraction f of its initial value.\n    \"\"\"\n    \n    # Test cases defined in the problem statement.\n    # (V, A, kL, Vmax_prime, KM, C0, f)\n    # Units: V [m^3], A [m^2], kL [m/s], Vmax_prime [mol/(m^2 s)],\n    #        KM [mol/m^3], C0 [mol/m^3], f [dimensionless].\n    test_cases = [\n        (1.0e-10, 8.0e-7, 1.0e-3, 1.0e-8, 0.05, 0.20, 0.10),\n        (1.0e-10, 8.0e-7, 5.0e-5, 1.0e-5, 0.05, 0.20, 0.10),\n        (1.0e-10, 8.0e-7, 5.0e-5, 2.0e-7, 0.05, 0.20, 0.10),\n        (1.0e-10, 8.0e-7, 5.0e-5, 1.0e-8, 0.05, 0.0020, 0.50),\n    ]\n\n    results = []\n    for case in test_cases:\n        V, A, kL, Vmax_prime, KM, C0, f = case\n        Tf = compute_Tf(V, A, kL, Vmax_prime, KM, C0, f)\n        results.append(f\"{Tf:.6f}\")\n\n    # Print the results in the required comma-separated format.\n    print(f\"[{','.join(results)}]\")\n\ndef compute_Tf(V, A, kL, Vmax_prime, KM, C0, f):\n    \"\"\"\n    Computes the time Tf by numerically integrating the derived expression.\n    \"\"\"\n    \n    def integrand(Cb, kL, Vmax_prime, KM):\n        \"\"\"\n        Calculates the value of 1/J(Cb), the integrand for the time integral.\n        \n        Args:\n            Cb (float): The bulk concentration value.\n            kL (float): Liquid-side mass transfer coefficient.\n            Vmax_prime (float): Maximum areal reaction rate.\n            KM (float): Michaelis constant.\n            \n        Returns:\n            float: The value of 1/J(Cb).\n        \"\"\"\n        # The integration range [f*C0, C0] has Cb > 0, so no division by zero is expected.\n        if Cb <= 0:\n            # Should not be reached with valid inputs C0 > 0, f > 0.\n            return np.inf\n\n        # Solve the quadratic equation kL*Cs^2 + b*Cs + c = 0 for Cs.\n        a_quad = kL\n        b_quad = Vmax_prime + kL * KM - kL * Cb\n        c_quad = -kL * Cb * KM\n        \n        # The discriminant is mathematically guaranteed to be non-negative.\n        # Add a clip for numerical safety, though it's unlikely to be needed.\n        discriminant = max(0, b_quad**2 - 4 * a_quad * c_quad)\n        \n        # Physical root for surface concentration Cs\n        Cs = (-b_quad + np.sqrt(discriminant)) / (2 * a_quad)\n        \n        # Calculate flux J using the more numerically stable reaction-rate form.\n        # Denominator KM + Cs is always positive since KM > 0 and Cs >= 0.\n        J = (Vmax_prime * Cs) / (KM + Cs)\n        \n        # If flux is zero (only when Cb=0), time to change is infinite.\n        if J <= 0:\n             return np.inf\n\n        return 1.0 / J\n\n    # Numerically integrate the function 1/J(Cb) from f*C0 to C0.\n    integral_val, _ = integrate.quad(\n        integrand,\n        f * C0,\n        C0,\n        args=(kL, Vmax_prime, KM)\n    )\n    \n    # Calculate the total time Tf.\n    Tf = (V / A) * integral_val\n    return Tf\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2748343"}, {"introduction": "Beyond modeling individual reactions, the true power of laboratory automation lies in orchestrating complex workflows that involve multiple steps and shared resources. This practice shifts the focus from the physics of a single process to the logic of system-wide optimization, casting the challenge as a job-shop scheduling problem with constraints unique to microfluidics, like sequence-dependent setup times to manage cross-contamination. By tackling this problem, you will learn to formally model and seek optimal schedules to minimize the total experiment time, or makespan, a fundamental objective in maximizing the efficiency and throughput of automated platforms [@problem_id:2748359].", "problem": "You are designing an execution scheduler for a Lab-on-a-Chip (LOC) microfluidic platform that automates high-throughput biological workflows. Each biological workflow (a \"job\") is a sequence of operations that must be executed in order on specific microfluidic modules (resources), such as mixers, incubators, and detectors. The platform enforces laminar flow and uses per-resource flushing (setup) between different jobs to prevent cross-contamination. You must compute the minimal possible completion time (makespan) for several small instances of this scheduling problem, grounded in conservation of mass and deterministic processing times.\n\nFoundational base and definitions:\n- Deterministic transport and reaction time: For an operation that transports a volume $v$ on a resource with flow rate $q$ followed by a reaction (or hold) of latency $\\tau$, the operation processing time is\n$$\np \\;=\\; \\frac{v}{q} + \\tau,\n$$\nby conservation of mass and constant volumetric flow. All symbols $v$, $q$, $\\tau$, and $p$ are in coherent units.\n- Per-resource setup and compatibility: Each resource $r$ has a base setup (flush) time $s_r$ that must be paid before any operation using $r$. When two consecutive operations on the same resource belong to different jobs $a$ then $b$, an additional compatibility overhead $c_r(a,b)$ is required (beyond $s_r$) to model extra purge time due to reagent incompatibility. When a resource is initially clean, only the base setup $s_r$ applies for the first operation on that resource and $c_r$ does not apply.\n- Precedence constraints: Within each job $i$, operations must follow their defined sequence. If the $j$-th operation finishes at time $C_{i,j}$ and the $(j+1)$-th operation starts at time $S_{i,j+1}$, then\n$$\nS_{i,j+1} \\;\\ge\\; C_{i,j}.\n$$\n- Disjunctive resource capacity: Each resource can process at most one operation at a time, with setups occupying the resource immediately before the operation. If operations $a$ and $b$ both require the same resource $r$, then either $a$ is scheduled entirely before $b$ with the required setup chain, or vice versa. If $S_a$ and $C_a$ denote the start and completion of operation $a$, and similarly for $b$, then the feasible schedule must satisfy one of the disjunctive constraints\n$$\nS_a \\;\\ge\\; C_b + s_r + c_r(\\text{job}(b), \\text{job}(a)) \\quad\\text{or}\\quad\nS_b \\;\\ge\\; C_a + s_r + c_r(\\text{job}(a), \\text{job}(b)).\n$$\n- Objective: Minimize the makespan\n$$\nC_{\\max} \\;=\\; \\max_{i,j} C_{i,j}.\n$$\n\nScheduling model you must implement:\n- Represent $R$ resources, indexed by $r \\in \\{0,1,\\dots,R-1\\}$, each with base setup time $s_r$, flow rate $q_r$, and a compatibility overhead matrix $c_r(a,b)$ defined for job indices $a$ and $b$.\n- Represent $J$ jobs, indexed by $i \\in \\{0,1,\\dots,J-1\\}$, where each job is an ordered list of operations $(r, v, \\tau)$ meaning \"use resource $r$ to transport volume $v$ at flow $q_r$ and then hold/react for latency $\\tau$.\" All transport volumes $v$ are given in microliters $\\mu\\text{L}$, flow rates $q_r$ in $\\mu\\text{L}/\\text{s}$, and latencies $\\tau$ in $\\text{s}$. Consequently, operation processing time $p$ is in $\\text{s}$. Setups $s_r$ and $c_r(a,b)$ are in $\\text{s}$.\n- Resource setup policy: For any operation scheduled on resource $r$, let $t_r$ denote the time resource $r$ is free and $\\ell_r$ denote the last job that used $r$ (or \"none\" initially). The operation’s processing begins after a setup immediately preceding it. The setup duration is $s_r$ if $\\ell_r$ is \"none,\" otherwise $s_r + c_r(\\ell_r, i)$ if the operation belongs to job $i$. The operation start time is the maximum of the job’s readiness time and the resource’s availability time plus the required setup, and its completion time is the start time plus $p$. Setups cannot be performed in advance and occupy the resource immediately before processing. Jobs cannot be preempted.\n\nYour task:\n- For each test case below, compute the minimal makespan $C_{\\max}$ (in $\\text{s}$) under the above constraints, rounded to $3$ decimal places. Your algorithm should search the combinatorial space of feasible schedules to certify optimality on these small instances; heuristics alone without proof of optimality are not acceptable.\n\nTest suite:\n- Case $1$ (two resources: mixer and incubator; two jobs, each with two operations):\n    - Resources:\n        - Mixer $r=0$: $q_0 = 5\\;\\mu\\text{L}/\\text{s}$, $s_0 = 2\\;\\text{s}$, compatibility overheads $c_0(a,b)$ given by the matrix (jobs indexed $0$ and $1$):\n            - $c_0(0,0)=0$, $c_0(0,1)=4$, $c_0(1,0)=0$, $c_0(1,1)=0$ (all units $\\text{s}$).\n        - Incubator $r=1$: $q_1 = 10\\;\\mu\\text{L}/\\text{s}$, $s_1 = 1\\;\\text{s}$, compatibility overheads all zero, that is $c_1(a,b) = 0$ for all $a,b$.\n    - Jobs (each operation as $(r, v, \\tau)$ with $v$ in $\\mu\\text{L}$ and $\\tau$ in $\\text{s}$):\n        - Job $0$: $(0, 20, 10)$ then $(1, 10, 30)$.\n        - Job $1$: $(0, 25, 5)$ then $(1, 10, 25)$.\n- Case $2$ (two resources: mixer and detector; three jobs with two operations each):\n    - Resources:\n        - Mixer $r=0$: $q_0 = 6\\;\\mu\\text{L}/\\text{s}$, $s_0 = 2\\;\\text{s}$. Nonzero compatibility overheads (in $\\text{s}$): $c_0(0,1)=2$, $c_0(1,2)=3$, $c_0(2,0)=4$. All other $c_0(a,b)=0$.\n        - Detector $r=1$: $q_1 = 8\\;\\mu\\text{L}/\\text{s}$, $s_1 = 1\\;\\text{s}$. Nonzero compatibility overhead $c_1(1,0)=1$. All other $c_1(a,b)=0$.\n    - Jobs:\n        - Job $0$: $(0, 18, 4)$ then $(1, 5, 6)$.\n        - Job $1$: $(0, 12, 3)$ then $(1, 7, 5)$.\n        - Job $2$: $(0, 16, 6)$ then $(1, 6, 8)$.\n- Case $3$ (single resource: thermal cycler; three single-operation jobs; tests pure sequence-dependent setups):\n    - Resource:\n        - Thermal cycler $r=0$: $q_0 = 4\\;\\mu\\text{L}/\\text{s}$, $s_0 = 0.5\\;\\text{s}$. Nonzero compatibility overheads (in $\\text{s}$): $c_0(0,1)=2.0$, $c_0(1,2)=1.5$, $c_0(2,0)=1.0$. All other $c_0(a,b)=0$.\n    - Jobs:\n        - Job $0$: $(0, 8, 40)$.\n        - Job $1$: $(0, 6, 50)$.\n        - Job $2$: $(0, 10, 30)$.\n\nAngle units are not used. All final answers must be expressed in seconds. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and rounded to $3$ decimal places, for example, \"[x1,x2,x3]\".\n\nYour program must compute, for the above three cases in order, the minimal makespans $C_{\\max}$ in $\\text{s}$, each rounded to $3$ decimal places, and output them as \"[case1,case2,case3]\" on a single line with no additional text.", "solution": "The problem presented is a deterministic scheduling problem, specifically a version of the Job-Shop Scheduling Problem with sequence-dependent setup times. The goal is to find a schedule that minimizes the makespan, which is the completion time of the last operation. The problem is well-defined, scientifically grounded in principles of mass conservation and established scheduling theory, and all necessary parameters are provided for the given test cases. Therefore, the problem is deemed valid.\n\nThe problem can be modeled by considering all possible sequences of operations on each resource. Since the number of jobs and operations per job is small, we can find the optimal solution by an exhaustive search over the combinatorial space of all non-preemptive schedules.\n\nA schedule is defined by the sequence of operations on each of the $R$ resources. For a resource $r$ that is required by a set of operations $O_r$, any permutation of the operations in $O_r$ constitutes a feasible local sequence for that resource. The global schedule is determined by a combination of one such permutation for each resource. The total number of such combinations is the product of the factorials of the number of operations per resource. For the given small-scale problems, this number is computationally manageable.\n- Case 1: $2$ resources, each used by $2$ operations. The number of sequences to check is $(2!)^2 = 4$.\n- Case 2: $2$ resources, each used by $3$ operations. The number of sequences is $(3!)^2 = 36$.\n- Case 3: $1$ resource used by $3$ operations. The number of sequences is $(3!)^1 = 6$.\n\nFor each specific combination of sequences (one per resource), the problem reduces to finding the longest path an a directed acyclic graph (DAG). The nodes of the graph are the operations. The directed edges represent constraints:\n1.  **Precedence Constraints**: An edge exists from operation $(i, j)$ to $(i, j+1)$ for all jobs $i$ and operations $j$. This ensures that operations within a job are executed in the specified order.\n2.  **Resource Constraints**: For each resource $r$, an edge exists from each operation in its designated sequence to the next operation in that same sequence.\n\nThe makespan for a given schedule (a fixed set of sequences) can be calculated by computing the completion time for every operation. Let $C_{i,j}$ be the completion time of the $j$-th operation of job $i$. This operation is denoted by $Op_{i,j}$. Let $Op_{i,j}$ require resource $r$. Let $Op_{i',j'}$ be the operation immediately preceding $Op_{i,j}$ in the chosen sequence for resource $r$.\n\nThe start of the setup for $Op_{i,j}$, denoted $S'_{i,j}$, is constrained by two factors: the completion of the previous operation in the same job, $C_{i,j-1}$ (if $j>0$), and the completion of the previous operation on the same resource, $C_{i',j'}$. Thus:\n$$\nS'_{i,j} = \\max(C_{i,j-1}, C_{i',j'})\n$$\nwhere $C_{i,-1}$ and completion time of a non-existent preceding resource operation are taken as $0$.\n\nThe setup time, $\\Delta t_{\\text{setup}}$, for $Op_{i,j}$ depends on whether it is the first operation on resource $r$.\n- If $Op_{i,j}$ is first on resource $r$: $\\Delta t_{\\text{setup}} = s_r$.\n- If $Op_{i,j}$ follows $Op_{i',j'}$ (of job $i'$) on resource $r$: $\\Delta t_{\\text{setup}} = s_r + c_r(i', i)$.\n\nThe completion time $C_{i,j}$ is then calculated as the sum of the setup start time, the setup duration, and the operation's own processing time $p_{i,j}$:\n$$\nC_{i,j} = S'_{i,j} + \\Delta t_{\\text{setup}} + p_{i,j}\n$$\nThe processing time $p_{i,j}$ is given by the formula $p = v/q + \\tau$, where the parameters correspond to $Op_{i,j}$.\n\nThese completion times can be computed iteratively for all operations in an order consistent with the DAG's topology. After computing all completion times, the makespan for that schedule is the maximum completion time among all final operations of all jobs:\n$$\nC_{\\max} = \\max_{i} C_{i, |J_i|-1}\n$$\nwhere $|J_i|$ is the number of operations in job $i$.\n\nBy iterating through all possible schedule permutations and calculating the makespan for each, the minimum makespan across all schedules can be determined. This guarantees optimality.\n\nThe algorithm proceeds as follows:\n1.  For each test case, pre-calculate the processing time $p_{i,j}$ for each operation $(i,j)$.\n2.  Identify the set of operations that must be scheduled on each resource.\n3.  Generate all permutations of operation sequences for each resource.\n4.  Create the Cartesian product of these sets of permutations to get all possible complete schedules.\n5.  For each complete schedule:\n    a. Initialize all operation completion times to a marker value (e.g., $-1$).\n    b. Repeatedly iterate through all operations. In each pass, calculate the completion time for any operations whose precedence and resource dependencies have already been met (i.e., whose prerequisite operations have calculated completion times).\n    c. Continue until all completion times are calculated.\n    d. Determine the makespan for the schedule.\n6.  The minimal makespan found among all schedules is the solution. The final values are rounded to $3$ decimal places.", "answer": "```python\nimport numpy as np\nfrom itertools import permutations, product\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, solve them, and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1\n        {\n            \"num_jobs\": 2,\n            \"num_resources\": 2,\n            \"resources\": [\n                {\"q\": 5.0, \"s\": 2.0, \"c\": np.array([[0.0, 4.0], [0.0, 0.0]])},\n                {\"q\": 10.0, \"s\": 1.0, \"c\": np.array([[0.0, 0.0], [0.0, 0.0]])},\n            ],\n            \"jobs\": [\n                [(0, 20.0, 10.0), (1, 10.0, 30.0)], # Job 0\n                [(0, 25.0, 5.0), (1, 10.0, 25.0)], # Job 1\n            ],\n        },\n        # Case 2\n        {\n            \"num_jobs\": 3,\n            \"num_resources\": 2,\n            \"resources\": [\n                {\"q\": 6.0, \"s\": 2.0, \"c\": np.array([[0.0, 2.0, 0.0], [0.0, 0.0, 3.0], [4.0, 0.0, 0.0]])},\n                {\"q\": 8.0, \"s\": 1.0, \"c\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 0.0]])},\n            ],\n            \"jobs\": [\n                [(0, 18.0, 4.0), (1, 5.0, 6.0)], # Job 0\n                [(0, 12.0, 3.0), (1, 7.0, 5.0)], # Job 1\n                [(0, 16.0, 6.0), (1, 6.0, 8.0)], # Job 2\n            ],\n        },\n        # Case 3\n        {\n            \"num_jobs\": 3,\n            \"num_resources\": 1,\n            \"resources\": [\n                {\"q\": 4.0, \"s\": 0.5, \"c\": np.array([[0.0, 2.0, 0.0], [0.0, 0.0, 1.5], [1.0, 0.0, 0.0]])},\n            ],\n            \"jobs\": [\n                [(0, 8.0, 40.0)],      # Job 0\n                [(0, 6.0, 50.0)],      # Job 1\n                [(0, 10.0, 30.0)],     # Job 2\n            ],\n        },\n    ]\n\n    results = []\n    for case_data in test_cases:\n        solver = MakespanCalculator(case_data)\n        min_makespan = solver.solve()\n        results.append(f\"{min_makespan:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nclass MakespanCalculator:\n    \"\"\"\n    Calculates the minimal makespan for a given job-shop scheduling problem instance.\n    \"\"\"\n    def __init__(self, case_data):\n        self.num_jobs = case_data['num_jobs']\n        self.num_resources = case_data['num_resources']\n        self.jobs = case_data['jobs']\n        self.resources = case_data['resources']\n        \n        # Pre-calculate processing times and map operations to resources\n        self.ops_on_resource = [[] for _ in range(self.num_resources)]\n        self.op_info = {}\n        \n        max_ops_in_job = 0\n        for i in range(self.num_jobs):\n            if len(self.jobs[i]) > max_ops_in_job:\n                max_ops_in_job = len(self.jobs[i])\n            for j, op_spec in enumerate(self.jobs[i]):\n                r, v, tau = op_spec\n                q = self.resources[r]['q']\n                p = v / q + tau\n                \n                op_id = (i, j)\n                self.ops_on_resource[r].append(op_id)\n                self.op_info[op_id] = {'res': r, 'proc_time': p}\n        \n        self.max_ops_in_job = max_ops_in_job\n\n    def solve(self):\n        \"\"\"\n        Finds the minimum makespan by searching all resource-operation permutations.\n        \"\"\"\n        op_perms_by_resource = []\n        for r in range(self.num_resources):\n            op_perms_by_resource.append(list(permutations(self.ops_on_resource[r])))\n\n        min_makespan = float('inf')\n        \n        # Iterate over the Cartesian product of all resource sequence permutations\n        for schedule_perm in product(*op_perms_by_resource):\n            makespan = self._calculate_makespan_for_schedule(schedule_perm)\n            if makespan < min_makespan:\n                min_makespan = makespan\n        \n        return min_makespan\n        \n    def _calculate_makespan_for_schedule(self, schedule_perm):\n        \"\"\"\n        Calculates the makespan for a single, fully-defined schedule using a\n        DAG-based longest path approach.\n        \"\"\"\n        completion_times = np.full((self.num_jobs, self.max_ops_in_job), -1.0)\n        num_total_ops = len(self.op_info)\n        \n        op_to_res_pos = {op: pos for r_idx, op_seq in enumerate(schedule_perm) for pos, op in enumerate(op_seq)}\n        \n        calculated_ops = 0\n        while calculated_ops < num_total_ops:\n            progress_made = False\n            for op_id in self.op_info:\n                j_idx, op_idx_in_job = op_id\n                \n                if completion_times[j_idx, op_idx_in_job] != -1.0:\n                    continue\n\n                res_idx = self.op_info[op_id]['res']\n                proc_time = self.op_info[op_id]['proc_time']\n\n                # Dependency 1: Preceding operation in the same job\n                prec_job_completion = 0.0\n                if op_idx_in_job > 0:\n                    prec_job_completion = completion_times[j_idx, op_idx_in_job - 1]\n                    if prec_job_completion == -1.0:\n                        continue \n\n                # Dependency 2: Preceding operation on the same resource\n                prec_res_completion = 0.0\n                last_job_on_res = -1\n                res_op_pos = op_to_res_pos[op_id]\n                if res_op_pos > 0:\n                    prev_op_on_res = schedule_perm[res_idx][res_op_pos - 1]\n                    prev_op_j_idx, prev_op_op_idx = prev_op_on_res\n                    prec_res_completion = completion_times[prev_op_j_idx, prev_op_op_idx]\n                    if prec_res_completion == -1.0:\n                        continue\n                    last_job_on_res = prev_op_j_idx\n                \n                # All dependencies met, calculate completion time\n                s_r = self.resources[res_idx]['s']\n                c_r_matrix = self.resources[res_idx]['c']\n                \n                setup_time = s_r\n                if last_job_on_res != -1:\n                    setup_time += c_r_matrix[last_job_on_res, j_idx]\n                    \n                start_setup_time = max(prec_job_completion, prec_res_completion)\n                completion = start_setup_time + setup_time + proc_time\n                completion_times[j_idx, op_idx_in_job] = completion\n                calculated_ops += 1\n                progress_made = True\n            \n            if not progress_made and calculated_ops < num_total_ops:\n                # Should not happen in a valid DAG\n                raise RuntimeError(\"Stuck in calculation loop - likely a cycle or bug.\")\n\n        final_completion_times = [completion_times[i, len(self.jobs[i]) - 1] for i in range(self.num_jobs) if self.jobs[i]]\n        return max(final_completion_times) if final_completion_times else 0.0\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2748359"}]}