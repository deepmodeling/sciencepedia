{"hands_on_practices": [{"introduction": "This first practice challenges you to build a kinetic model of translation from fundamental principles. You will explore how the cellular pool of transfer RNAs ($tRNAs$) dictates not only the speed of protein synthesis but also its fidelity across an entire simplified proteome. By implementing this model, you will gain direct experience in connecting molecular-level parameters, like $tRNA$ concentrations, to system-level outcomes such as total protein production and error rates, a core skill in quantitative biology [@problem_id:2770659].", "problem": "You are asked to formalize and compute the effect of overexpressing a specific transfer RNA (tRNA) on global ribosome translation dynamics by applying a principled kinetic model of codon decoding. Your program must implement the following principled model, derive the required quantities from first principles, and produce numerical predictions for a provided test suite. All final outputs are dimensionless decimal numbers as floats.\n\nFundamental base and modeling assumptions:\n- The Central Dogma establishes that messenger RNA (mRNA) is translated by ribosomes, which decode codons using transfer RNA (tRNA) molecules carrying amino acids.\n- In a minimal kinetic model of decoding, the codon recognition step can be approximated by mass-action proportionality: the rate of successfully decoding a codon is proportional to the concentration (abundance) of cognate tRNA that can correctly pair with that codon. Near-cognate tRNA that can form non-Watson–Crick or wobble-like pairs may occasionally be (incorrectly) accepted with much lower probability.\n- We treat each codon’s decoding as an effective first-order process with an effective rate that is a weighted sum of cognate and near-cognate tRNA abundances. The near-cognate contribution is down-weighted by a penalty factor.\n\nDefinitions:\n- Let there be $N_c$ codon types indexed by $c \\in \\{0,1,\\dots,N_c-1\\}$ and $N_t$ tRNA species indexed by $t \\in \\{0,1,\\dots,N_t-1\\}$.\n- For each codon $c$, let $C_c$ be the set of cognate tRNA indices and $N_c$ be the set of near-cognate tRNA indices. Let $p \\in (0,1)$ be the near-cognate penalty, modeled as a multiplicative factor on near-cognate contributions.\n- Let $a \\in \\mathbb{R}_{+}^{N_t}$ be the baseline tRNA abundance vector. Overexpress a specific tRNA $t^\\star$ by a factor $f \\ge 1$ to obtain a modified vector $a'$. Two modes are considered:\n  - No normalization: $a'_t = a_t$ for $t \\ne t^\\star$ and $a'_{t^\\star} = f \\, a_{t^\\star}$.\n  - Normalization to conserve total tRNA mass: compute $\\tilde{a}$ as above and then rescale to conserve the total abundance, $a'' = \\tilde{a} \\cdot \\frac{\\sum_{t} a_t}{\\sum_{t} \\tilde{a}_t}$. Use $a''$ as the modified vector.\n- The effective decoding rate for codon $c$ under tRNA vector $x$ is\n  $$ r_c(x) = k_e \\left( \\sum_{t \\in C_c} x_t + p \\sum_{t \\in N_c} x_t \\right), $$\n  where $k_e$ is a constant kinetic proportionality factor. For this problem, set $k_e = 1$ in arbitrary units, so that rates and times are internally consistent but final outputs are dimensionless quantities.\n- The dwell time for codon $c$ is $\\tau_c(x) = 1 / r_c(x)$.\n- Consider $G$ genes, each gene $g \\in \\{1,\\dots,G\\}$ is a sequence of codon indices $\\{c_i^{(g)}\\}_{i=1}^{L_g}$, where $L_g$ is the number of codons in gene $g$. The elongation time for gene $g$ is\n  $$ T_g(x) = \\sum_{i=1}^{L_g} \\tau_{c_i^{(g)}}(x). $$\n- Gene $g$ has an initiation rate $k_{\\mathrm{init},g}$ (in $\\mathrm{s}^{-1}$). The initiation waiting time is $\\tau_{\\mathrm{init},g} = 1 / k_{\\mathrm{init},g}$. A simple cycle-time approximation gives the mean time per completed protein for gene $g$ as\n  $$ \\tau_{\\mathrm{cycle},g}(x) = \\tau_{\\mathrm{init},g} + T_g(x). $$\n  The mean synthesis rate for gene $g$ is then\n  $$ J_g(x) = \\frac{1}{\\tau_{\\mathrm{cycle},g}(x)}. $$\n- The total proteome synthesis flux under $x$ is\n  $$ S(x) = \\sum_{g=1}^{G} J_g(x). $$\n- The near-cognate incorporation probability for codon $c$ under $x$ is\n  $$ P_{\\mathrm{nc},c}(x) = \\frac{p \\sum_{t \\in N_c} x_t}{\\sum_{t \\in C_c} x_t + p \\sum_{t \\in N_c} x_t}, $$\n  with the convention that if the denominator is $0$ then $P_{\\mathrm{nc},c}(x) = 0$.\n- The expected near-cognate count per translation of gene $g$ is\n  $$ E_g(x) = \\sum_{i=1}^{L_g} P_{\\mathrm{nc},c_i^{(g)}}(x). $$\n- The proteome-weighted near-cognate fraction is\n  $$ F(x) = \\frac{\\sum_{g=1}^{G} J_g(x)\\, E_g(x)}{\\sum_{g=1}^{G} J_g(x)\\, L_g}. $$\n\nTask:\n- For each parameter set in the test suite below, compute the baseline metrics with $x = a$ and the perturbed metrics with $x =$ modified vector after overexpressing $t^\\star$ by factor $f$ under the specified normalization mode. Report the two fold-changes:\n  - $S$-fold-change $= S(x_{\\mathrm{pert}}) / S(x_{\\mathrm{base}})$.\n  - $F$-fold-change $= F(x_{\\mathrm{pert}}) / F(x_{\\mathrm{base}})$.\n- All outputs are dimensionless decimal floats.\n\nShared model constants and structures for all tests:\n- Number of codons $N_c = 5$ with indices $c \\in \\{0,1,2,3,4\\}$.\n- Number of tRNA species $N_t = 3$ with indices $t \\in \\{0,1,2\\}$.\n- Cognate and near-cognate sets by codon:\n  - $C_0 = \\{0\\}$, $N_0 = \\{1\\}$.\n  - $C_1 = \\{0\\}$, $N_1 = \\{1\\}$.\n  - $C_2 = \\{1\\}$, $N_2 = \\{0\\}$.\n  - $C_3 = \\{2\\}$, $N_3 = \\varnothing$.\n  - $C_4 = \\{2\\}$, $N_4 = \\{0\\}$.\n- Genes and initiation rates:\n  - $G = 3$ genes.\n  - Gene $1$: codon sequence $\\{0,1,2,0,1,2,3,4\\}$ of length $L_1 = 8$, with $k_{\\mathrm{init},1} = 0.5 \\ \\mathrm{s}^{-1}$.\n  - Gene $2$: codon sequence $\\{3,3,4,4,3,4\\}$ of length $L_2 = 6$, with $k_{\\mathrm{init},2} = 0.8 \\ \\mathrm{s}^{-1}$.\n  - Gene $3$: codon sequence $\\{2,2,2,0,1,0,1\\}$ of length $L_3 = 7$, with $k_{\\mathrm{init},3} = 0.3 \\ \\mathrm{s}^{-1}$.\n- Baseline tRNA abundance vector $a = [30, 15, 10]$ in arbitrary abundance units.\n\nTest suite (each test defines $(t^\\star, f, \\text{normalize}, p)$):\n- Test $1$: $t^\\star = 1$, $f = 1$, $\\text{normalize} = \\text{False}$, $p = 0.02$.\n- Test $2$: $t^\\star = 1$, $f = 3$, $\\text{normalize} = \\text{True}$, $p = 0.02$.\n- Test $3$: $t^\\star = 1$, $f = 3$, $\\text{normalize} = \\text{False}$, $p = 0.02$.\n- Test $4$: $t^\\star = 0$, $f = 10$, $\\text{normalize} = \\text{True}$, $p = 0.10$.\n\nYour program must:\n- Implement the model exactly as specified above.\n- For each test, compute the two fold-changes $S$-fold-change and $F$-fold-change relative to the baseline $x = a$ for that test’s $p$ and normalization setting (note that when $f=1$, the fold-changes should be exactly $1$).\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n  $$[S\\text{-fold}_1, F\\text{-fold}_1, S\\text{-fold}_2, F\\text{-fold}_2, S\\text{-fold}_3, F\\text{-fold}_3, S\\text{-fold}_4, F\\text{-fold}_4].$$\n- Each float should be rounded to $6$ decimal places.", "solution": "The problem statement presents a valid and well-posed challenge in computational systems biology. It requires the implementation of a kinetic model of ribosome translation to quantitatively assess the impact of tRNA overexpression on global protein synthesis efficiency and accuracy. The model is constructed from first principles commonly used in the field, such as mass-action kinetics for codon decoding and a simple cycle-time approximation for protein synthesis rates. All necessary parameters, definitions, and functions are provided without ambiguity or contradiction. The problem is scientifically grounded, objective, and self-contained, thus permitting a direct and rigorous solution.\n\nWe will proceed by first formalizing the calculation of all quantities defined in the model. The primary objective is to compute two metrics: the total proteome synthesis flux, denoted by $S(x)$, and the proteome-weighted near-cognate fraction, $F(x)$, where $x$ represents the vector of tRNA abundances. These metrics will be calculated for a baseline tRNA abundance vector $a$ and a perturbed vector $x_{\\text{pert}}$, which results from overexpressing a specific tRNA.\n\n**1. Foundational Quantities: Decoding Rate and Dwell Time**\nThe rate of decoding a codon $c$ depends on the concentrations of its cognate tRNAs (set $C_c$) and near-cognate tRNAs (set $N_c$). Given the kinetic proportionality constant $k_e = 1$ and near-cognate penalty $p$, the effective decoding rate $r_c(x)$ is:\n$$ r_c(x) = \\sum_{t \\in C_c} x_t + p \\sum_{t \\in N_c} x_t $$\nThe mean time required to decode codon $c$, which is the dwell time $\\tau_c(x)$, is the reciprocal of this rate, a standard assumption for a process following first-order kinetics:\n$$ \\tau_c(x) = \\frac{1}{r_c(x)} $$\nThe provided tRNA abundances are strictly positive, ensuring that $r_c(x) > 0$ and $\\tau_c(x)$ is a finite, positive value for all codons that have at least one cognate or near-cognate tRNA.\n\n**2. Gene-Level Metrics: Elongation Time and Synthesis Rate**\nFor a gene $g$, defined by a sequence of codons $\\{c_i^{(g)}\\}_{i=1}^{L_g}$, the total time for a ribosome to synthesize the polypeptide chain, known as the elongation time $T_g(x)$, is the sum of the dwell times for each codon in its sequence:\n$$ T_g(x) = \\sum_{i=1}^{L_g} \\tau_{c_i^{(g)}}(x) $$\nThe synthesis of a complete protein involves both initiation and elongation. The mean cycle time, $\\tau_{\\mathrm{cycle},g}(x)$, is the sum of the initiation waiting time, $\\tau_{\\mathrm{init},g} = 1/k_{\\mathrm{init},g}$, and the elongation time:\n$$ \\tau_{\\mathrm{cycle},g}(x) = \\tau_{\\mathrm{init},g} + T_g(x) $$\nThe rate of protein synthesis for gene $g$, $J_g(x)$, which represents the protein production flux, is the reciprocal of the cycle time:\n$$ J_g(x) = \\frac{1}{\\tau_{\\mathrm{cycle},g}(x)} $$\n\n**3. Proteome-Level Metrics: Total Flux and Error Fraction**\nThe total proteome synthesis flux, $S(x)$, is the aggregate of the synthesis rates from all genes in the system:\n$$ S(x) = \\sum_{g=1}^{G} J_g(x) $$\nTranslation is not perfectly accurate. The probability of incorporating an incorrect amino acid due to a near-cognate tRNA at codon $c$, $P_{\\mathrm{nc},c}(x)$, is the ratio of the near-cognate decoding rate to the total decoding rate:\n$$ P_{\\mathrm{nc},c}(x) = \\frac{p \\sum_{t \\in N_c} x_t}{\\sum_{t \\in C_c} x_t + p \\sum_{t \\in N_c} x_t} = p \\cdot \\tau_c(x) \\sum_{t \\in N_c} x_t $$\nThe expected number of such errors during a single translation of gene $g$, $E_g(x)$, is the sum of these probabilities across the gene's sequence:\n$$ E_g(x) = \\sum_{i=1}^{L_g} P_{\\mathrm{nc},c_i^{(g)}}(x) $$\nThe global measure of translation infidelity, the proteome-weighted near-cognate fraction $F(x)$, is the total rate of near-cognate incorporations across all genes divided by the total rate of all codon incorporations. This is formulated as:\n$$ F(x) = \\frac{\\sum_{g=1}^{G} J_g(x)\\, E_g(x)}{\\sum_{g=1}^{G} J_g(x)\\, L_g} $$\nThis quantity represents the average error probability per codon, weighted by the expression level and length of each gene.\n\n**4. tRNA Abundance Perturbation**\nThe problem analyzes the system's response to overexpressing a specific tRNA, $t^\\star$, by a factor $f \\ge 1$. The baseline state is defined by the tRNA abundance vector $x_{\\text{base}} = a$. The perturbed state vector, $x_{\\text{pert}}$, is generated in one of two ways:\n- **No Normalization:** The abundance of tRNA $t^\\star$ is increased, while others remain constant:\n  $$ (x_{\\text{pert}})_t = \\begin{cases} f \\cdot a_{t^\\star} & \\text{if } t = t^\\star \\\\ a_t & \\text{if } t \\ne t^\\star \\end{cases} $$\n- **Normalization:** An intermediate vector, $\\tilde{a}$, is first created as above. Then, all components are rescaled to conserve the total tRNA mass of the baseline state, $\\sum_t a_t$:\n  $$ x_{\\text{pert}} = \\tilde{a} \\cdot \\frac{\\sum_{t} a_t}{\\sum_{t} \\tilde{a}_t} $$\n\n**5. Computational Strategy**\nFor each test case specified by $(t^\\star, f, \\text{normalize}, p)$, the following steps are executed:\n1.  The baseline metrics, $S(x_{\\text{base}})$ and $F(x_{\\text{base}})$, are computed using $x_{\\text{base}} = a$ and the value of $p$ from the test case.\n2.  The perturbed tRNA vector, $x_{\\text{pert}}$, is calculated based on the given $t^\\star$, $f$, and normalization mode.\n3.  The perturbed metrics, $S(x_{\\text{pert}})$ and $F(x_{\\text{pert}})$, are computed using this new vector and the same $p$.\n4.  The final results are the fold-changes: $S\\text{-fold} = S(x_{\\text{pert}}) / S(x_{\\text{base}})$ and $F\\text{-fold} = F(x_{\\text{pert}}) / F(x_{\\text{base}})$. Division by zero is not an issue, as baseline metrics will be non-zero given the problem parameters.\n\nFor Test $1$, where $f=1$, the perturbation is null ($x_{\\text{pert}} = x_{\\text{base}}$), correctly yielding fold-changes of $1.0$. This provides a necessary sanity check for the implementation. The numerical results for all test cases are computed by the provided program.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the kinetic model of translation to compute the effects of tRNA overexpression.\n    \"\"\"\n    # --- Shared Model Constants and Structures ---\n    N_c = 5  # Number of codon types\n    N_t = 3  # Number of tRNA species\n    G = 3    # Number of genes\n\n    # Cognate and near-cognate sets (0-indexed)\n    cognate_sets = [[0], [0], [1], [2], [2]]\n    near_cognate_sets = [[1], [1], [0], [], [0]]\n\n    # Gene definitions\n    genes = [\n        {'seq': np.array([0, 1, 2, 0, 1, 2, 3, 4]), 'k_init': 0.5},\n        {'seq': np.array([3, 3, 4, 4, 3, 4]), 'k_init': 0.8},\n        {'seq': np.array([2, 2, 2, 0, 1, 0, 1]), 'k_init': 0.3}\n    ]\n    gene_lengths = np.array([len(g['seq']) for g in genes])\n    k_init_inv = np.array([1.0 / g['k_init'] for g in genes])\n    gene_sequences = [g['seq'] for g in genes]\n\n    # Baseline tRNA abundance vector\n    a_base = np.array([30.0, 15.0, 10.0])\n    total_trna_base = np.sum(a_base)\n\n    # --- Test Suite ---\n    test_cases = [\n        # (t_star, f, normalize, p)\n        (1, 1.0, False, 0.02),\n        (1, 3.0, True, 0.02),\n        (1, 3.0, False, 0.02),\n        (0, 10.0, True, 0.10)\n    ]\n\n    # Pre-calculate sums for cognate and near-cognate tRNA indices\n    # This avoids repeated lookups and allows for vectorized calculations\n    cognate_masks = np.zeros((N_c, N_t), dtype=bool)\n    near_cognate_masks = np.zeros((N_c, N_t), dtype=bool)\n    for c in range(N_c):\n        if cognate_sets[c]:\n            cognate_masks[c, cognate_sets[c]] = True\n        if near_cognate_sets[c]:\n            near_cognate_masks[c, near_cognate_sets[c]] = True\n    \n    def calculate_metrics(x, p):\n        \"\"\"\n        Calculates all model metrics for a given tRNA vector x and penalty p.\n        \"\"\"\n        # 1. Codon decoding rates and probabilities\n        cognate_sums = cognate_masks @ x\n        near_cognate_sums = near_cognate_masks @ x\n\n        r_c = cognate_sums + p * near_cognate_sums\n        \n        # Handle division by zero, although not expected here\n        tau_c = np.divide(1.0, r_c, out=np.zeros_like(r_c), where=r_c!=0)\n        \n        rate_of_nc_incorp = p * near_cognate_sums\n        p_nc_c = np.divide(rate_of_nc_incorp, r_c, out=np.zeros_like(r_c), where=r_c!=0)\n\n        # 2. Gene-level metrics\n        T_g = np.array([np.sum(tau_c[seq]) for seq in gene_sequences])\n        tau_cycle_g = k_init_inv + T_g\n        J_g = 1.0 / tau_cycle_g\n        E_g = np.array([np.sum(p_nc_c[seq]) for seq in gene_sequences])\n\n        # 3. Proteome-level metrics\n        S = np.sum(J_g)\n        \n        F_numerator = np.sum(J_g * E_g)\n        F_denominator = np.sum(J_g * gene_lengths)\n        \n        F = F_numerator / F_denominator if F_denominator != 0 else 0.0\n        \n        return S, F\n\n    results = []\n    \n    for t_star, f, normalize, p in test_cases:\n        # Calculate baseline metrics for the current test's p\n        S_base, F_base = calculate_metrics(a_base, p)\n\n        # Generate perturbed tRNA vector\n        x_pert = np.copy(a_base)\n        x_pert[t_star] *= f\n\n        if normalize:\n            total_trna_pert = np.sum(x_pert)\n            if total_trna_pert != 0:\n                x_pert *= (total_trna_base / total_trna_pert)\n        \n        # Calculate perturbed metrics\n        S_pert, F_pert = calculate_metrics(x_pert, p)\n\n        # Compute and append fold-changes\n        S_fold = S_pert / S_base if S_base != 0 else 0.0\n        F_fold = F_pert / F_base if F_base != 0 else 0.0\n        \n        results.extend([S_fold, F_fold])\n\n    # Format output to 6 decimal places and print\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "2770659"}, {"introduction": "Building upon the fundamentals of translation kinetics, this exercise delves into the dynamic regulation of protein synthesis in response to cellular stress. You will construct a multi-layered model that traces the effects of oxidative stress from the inhibition of a $tRNA$-modifying enzyme all the way to gene-specific changes in protein output. This practice illustrates how complex biological reprogramming can emerge from the interplay of fundamental kinetic principles, such as enzyme inhibition and the concept of a rate-limiting step in a multi-stage process [@problem_id:2770762].", "problem": "You are asked to construct and implement a minimal, principle-based quantitative model of how transfer RNA (tRNA) modification enzyme activity couples to oxidative stress to reprogram translation in a synthetic biology context. The model must use only foundational laws and well-tested facts: (i) mass-action and Michaelis–Menten-type kinetics for enzyme-modification dynamics, (ii) the Central Dogma stating that protein synthesis proceeds by ribosomal initiation and elongation, and (iii) ribosome throughput on a single messenger RNA (mRNA) being limited by the slowest of initiation and elongation.\n\nAssumptions and definitions grounded in fundamentals:\n- Oxidative stress is represented by a scalar level $S$ proportional to the concentration of Reactive Oxygen Species (ROS). Reactive Oxygen Species (ROS) reduce the active concentration of a tRNA-modification enzyme by a competitive-inhibition-like hyperbola. If $E_{\\mathrm{t}}$ is the total enzyme concentration and $K_{i}$ is the inhibition constant, then the active concentration is $E_{\\mathrm{act}}(S) = \\dfrac{E_{\\mathrm{t}}}{1 + S/K_{i}}$.\n- A fraction $m \\in [0,1]$ of a specific tRNA pool is modified. Modification is added by the enzyme at an effective first-order rate proportional to $E_{\\mathrm{act}}(S)$ and removed (demodified/turned over) at a first-order rate. Let $k_{\\mathrm{mod}}$ be the modification rate constant and $k_{\\mathrm{demod}}$ be the demodification rate constant. From mass-action kinetics, the fraction dynamics are\n  $$\\frac{dm}{dt} = k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S)\\,\\big(1 - m\\big) - k_{\\mathrm{demod}}\\,m.$$\n  At steady state, set $\\dfrac{dm}{dt} = 0$ and solve for the steady-state fraction $m^{\\ast}(S)$.\n- The modification fraction $m^{\\ast}(S)$ affects elongation at the ribosomal A-site for a subset of codons (“sensitive” codons). Let $v_{\\mathrm{s,low}}$ be the per-codon elongation rate when the specific tRNA is unmodified and $v_{\\mathrm{s,high}}$ be the rate when fully modified. A minimal interpolation consistent with occupancy is\n  $$v_{\\mathrm{sens}}(S) = v_{\\mathrm{s,low}} + \\big(v_{\\mathrm{s,high}} - v_{\\mathrm{s,low}}\\big)\\,m^{\\ast}(S).$$\n  Codons not reliant on this modification have a constant per-codon elongation rate $v_{\\mathrm{non}}$.\n- A transcript with $n_{\\mathrm{sens}}$ sensitive codons and $n_{\\mathrm{non}}$ non-sensitive codons has an expected total elongation time\n  $$T_{\\mathrm{el}}(S) = \\frac{n_{\\mathrm{sens}}}{v_{\\mathrm{sens}}(S)} + \\frac{n_{\\mathrm{non}}}{v_{\\mathrm{non}}}.$$\n- Initiation is downregulated by oxidative stress consistent with reduced availability of the eukaryotic initiation factor $2$ (eIF2) ternary complex. Using a hyperbolic inhibition with basal initiation $I_{0}$ and constant $K_{\\mathrm{init}}$, the initiation rate per mRNA is\n  $$I(S) = \\frac{I_{0}}{1 + S/K_{\\mathrm{init}}}.$$\n- The per-mRNA protein production rate is limited by the slowest stage, yielding\n  $$R(S) = \\min\\!\\left(I(S), \\frac{1}{T_{\\mathrm{el}}(S)}\\right).$$\n  Report $R(S)$ in proteins per second per mRNA.\n\nTask:\n1. Starting strictly from the definitions above, derive $m^{\\ast}(S)$ from the steady-state condition and then the dependent quantities $v_{\\mathrm{sens}}(S)$, $T_{\\mathrm{el}}(S)$, $I(S)$, and finally $R(S)$.\n2. Implement a program that evaluates $R(S)$ for each of the following test cases. All rates are in units of per second, stress $S$ is in arbitrary nonnegative units, and codon counts are dimensionless. Express the final protein production rate in proteins per second per mRNA as decimal floats rounded to six decimal places.\n\nTest suite (each case is a tuple in the order: $(S, E_{\\mathrm{t}}, K_{i}, k_{\\mathrm{mod}}, k_{\\mathrm{demod}}, I_{0}, K_{\\mathrm{init}}, v_{\\mathrm{non}}, v_{\\mathrm{s,low}}, v_{\\mathrm{s,high}}, n_{\\mathrm{non}}, n_{\\mathrm{sens}})$):\n- Case A (baseline, moderate sensitive codon content): $(S{=}\\,0.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,240,\\ n_{\\mathrm{sens}}{=}\\,60)$.\n- Case B (high stress, same gene): $(S{=}\\,2.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,240,\\ n_{\\mathrm{sens}}{=}\\,60)$.\n- Case C (high stress, all codons sensitive): $(S{=}\\,2.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,0,\\ n_{\\mathrm{sens}}{=}\\,300)$.\n- Case D (high stress, no codons sensitive): $(S{=}\\,2.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,300,\\ n_{\\mathrm{sens}}{=}\\,0)$.\n- Case E (low stress, very fast demodification, reduced enzyme pool, mixed codon content): $(S{=}\\,0.2,\\ E_{\\mathrm{t}}{=}\\,0.5,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,5.0,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,150,\\ n_{\\mathrm{sens}}{=}\\,150)$.\n- Case F (extreme stress, initiation-limited regime, sensitive-enriched): $(S{=}\\,10.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,120,\\ n_{\\mathrm{sens}}{=}\\,180)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[r_{A},r_{B},r_{C},r_{D},r_{E},r_{F}]$, where each $r_{\\cdot}$ is $R(S)$ for the corresponding case, rounded to six decimal places and expressed in proteins per second per mRNA.", "solution": "The problem statement has been subjected to rigorous validation against the specified criteria of scientific soundness, well-posedness, and objectivity. It is found to be self-contained, logically consistent, and grounded in established biophysical and biochemical principles. The model, although simplified, represents a valid formalization of the coupling between oxidative stress and translational regulation. Therefore, the problem is deemed valid and a complete solution will be derived.\n\nThe task is to derive an explicit analytical expression for the protein production rate per mRNA, denoted as $R(S)$, as a function of the oxidative stress level $S$, and then to compute this value for a given set of parameters. The derivation proceeds through a sequence of steps, as defined in the problem statement.\n\nFirst, we derive the steady-state fraction of modified tRNA, $m^{\\ast}(S)$. The dynamics of the modification fraction $m$ are given by the ordinary differential equation:\n$$\n\\frac{dm}{dt} = k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S)\\,\\big(1 - m\\big) - k_{\\mathrm{demod}}\\,m\n$$\nAt steady state, $\\frac{dm}{dt} = 0$. Let $m^{\\ast}$ be the steady-state fraction. We solve the resulting algebraic equation for $m^{\\ast}$:\n$$\nk_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S)\\,\\big(1 - m^{\\ast}\\big) - k_{\\mathrm{demod}}\\,m^{\\ast} = 0\n$$\n$$\nk_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S) = m^{\\ast} \\left( k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S) + k_{\\mathrm{demod}} \\right)\n$$\n$$\nm^{\\ast}(S) = \\frac{k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S)}{k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S) + k_{\\mathrm{demod}}}\n$$\nThe active enzyme concentration $E_{\\mathrm{act}}(S)$ is itself a function of stress $S$:\n$$\nE_{\\mathrm{act}}(S) = \\frac{E_{\\mathrm{t}}}{1 + S/K_{i}}\n$$\nSubstituting this into the expression for $m^{\\ast}(S)$:\n$$\nm^{\\ast}(S) = \\frac{k_{\\mathrm{mod}}\\,\\left(\\dfrac{E_{\\mathrm{t}}}{1 + S/K_{i}}\\right)}{k_{\\mathrm{mod}}\\,\\left(\\dfrac{E_{\\mathrm{t}}}{1 + S/K_{i}}\\right) + k_{\\mathrm{demod}}}\n$$\nMultiplying the numerator and denominator by $(1 + S/K_{i})$ simplifies the expression:\n$$\nm^{\\ast}(S) = \\frac{k_{\\mathrm{mod}}\\,E_{\\mathrm{t}}}{k_{\\mathrm{mod}}\\,E_{\\mathrm{t}} + k_{\\mathrm{demod}}\\,(1 + S/K_{i})}\n$$\nThis expression provides the steady-state fraction of modified tRNA as a function of stress $S$ and the relevant system parameters.\n\nSecond, we determine the effective elongation rate for sensitive codons, $v_{\\mathrm{sens}}(S)$. This rate is defined as a linear interpolation between the rates for unmodified ($v_{\\mathrm{s,low}}$) and fully modified ($v_{\\mathrm{s,high}}$) tRNAs, weighted by the fraction of modified tRNA, $m^{\\ast}(S)$:\n$$\nv_{\\mathrm{sens}}(S) = v_{\\mathrm{s,low}} + \\big(v_{\\mathrm{s,high}} - v_{\\mathrm{s,low}}\\big)\\,m^{\\ast}(S)\n$$\nSubstituting our derived expression for $m^{\\ast}(S)$:\n$$\nv_{\\mathrm{sens}}(S) = v_{\\mathrm{s,low}} + \\big(v_{\\mathrm{s,high}} - v_{\\mathrm{s,low}}\\big) \\, \\frac{k_{\\mathrm{mod}}\\,E_{\\mathrm{t}}}{k_{\\mathrm{mod}}\\,E_{\\mathrm{t}} + k_{\\mathrm{demod}}\\,(1 + S/K_{i})}\n$$\n\nThird, we calculate the total elongation time, $T_{\\mathrm{el}}(S)$, for a transcript containing $n_{\\mathrm{sens}}$ sensitive codons and $n_{\\mathrm{non}}$ non-sensitive codons. The total time is the sum of the times spent decoding each type of codon:\n$$\nT_{\\mathrm{el}}(S) = \\frac{n_{\\mathrm{sens}}}{v_{\\mathrm{sens}}(S)} + \\frac{n_{\\mathrm{non}}}{v_{\\mathrm{non}}}\n$$\nThe rate for non-sensitive codons, $v_{\\mathrm{non}}$, is constant. The overall elongation rate (in ribosomes per second) is the reciprocal of this time, $1/T_{\\mathrm{el}}(S)$.\n\nFourth, we consider the initiation rate, $I(S)$, which is also downregulated by oxidative stress:\n$$\nI(S) = \\frac{I_{0}}{1 + S/K_{\\mathrm{init}}}\n$$\nHere, $I_{0}$ is the basal initiation rate in the absence of stress, and $K_{\\mathrm{init}}$ is the inhibition constant for this process.\n\nFinally, the overall protein production rate, $R(S)$, is determined by the bottleneck of the translation process, which is the minimum of the initiation rate and the effective elongation rate:\n$$\nR(S) = \\min\\!\\left(I(S), \\frac{1}{T_{\\mathrm{el}}(S)}\\right)\n$$\nIn the case where the total number of codons is zero ($n_{\\mathrm{sens}} + n_{\\mathrm{non}} = 0$), the elongation time $T_{\\mathrm{el}}(S)$ would be zero, making the elongation rate infinite. In this scenario, the production rate is limited solely by initiation, i.e., $R(S) = I(S)$. However, all test cases provided have a non-zero number of codons.\nCombining all the derived pieces, the final computational procedure for a given set of parameters is as follows:\n$1$. Calculate $m^{\\ast}(S)$ using its derived formula.\n$2$. Calculate $v_{\\mathrm{sens}}(S)$ using the value of $m^{\\ast}(S)$.\n$3$. Calculate $T_{\\mathrm{el}}(S)$. Special care must be taken if $n_{\\mathrm{sens}}=0$ or $n_{\\mathrm{non}}=0$, where the corresponding term in the sum is zero.\n$4$. Calculate $I(S)$.\n$5$. Determine $R(S)$ as the minimum of $I(S)$ and $1 / T_{\\mathrm{el}}(S)$.\n\nThese steps are implemented in the provided program to calculate the protein production rate for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the protein production rate R(S) for each case\n    and prints the results in the specified format.\n    \"\"\"\n\n    # Test suite from the problem statement.\n    # Each tuple contains parameters in the order:\n    # (S, E_t, K_i, k_mod, k_demod, I_0, K_init, v_non, v_s_low, v_s_high, n_non, n_sens)\n    test_cases = [\n        # Case A (baseline, moderate sensitive codon content)\n        (0.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 240, 60),\n        # Case B (high stress, same gene)\n        (2.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 240, 60),\n        # Case C (high stress, all codons sensitive)\n        (2.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 0, 300),\n        # Case D (high stress, no codons sensitive)\n        (2.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 300, 0),\n        # Case E (low stress, very fast demodification, reduced enzyme pool, mixed codon content)\n        (0.2, 0.5, 0.5, 1.0, 5.0, 0.5, 0.5, 15.0, 4.0, 25.0, 150, 150),\n        # Case F (extreme stress, initiation-limited regime, sensitive-enriched)\n        (10.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 120, 180),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_production_rate(case)\n        results.append(result)\n\n    # Format the results as a comma-separated list of strings,\n    # each rounded to six decimal places, enclosed in brackets.\n    str_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(str_results)}]\")\n\ndef calculate_production_rate(params):\n    \"\"\"\n    Calculates the protein production rate R(S) based on the derived model.\n\n    Args:\n        params (tuple): A tuple of parameters for a single test case.\n\n    Returns:\n        float: The calculated protein production rate R(S).\n    \"\"\"\n    S, E_t, K_i, k_mod, k_demod, I_0, K_init, v_non, v_s_low, v_s_high, n_non, n_sens = params\n\n    # Step 1: Calculate the steady-state fraction of modified tRNA, m*(S)\n    # m_star = (k_mod * E_t) / (k_mod * E_t + k_demod * (1 + S / K_i))\n    if K_i == 0:\n        # Avoid division by zero; if K_i is 0, any S > 0 fully inhibits the enzyme.\n        m_star_numerator = k_mod * E_t\n        m_star_denominator = np.inf if S > 0 else (k_mod * E_t + k_demod)\n    else:\n        m_star_numerator = k_mod * E_t\n        m_star_denominator = k_mod * E_t + k_demod * (1.0 + S / K_i)\n\n    if m_star_denominator == 0:\n        m_star = 1.0 # This case should not happen with positive parameters\n    else:\n        m_star = m_star_numerator / m_star_denominator\n\n    # Step 2: Calculate the elongation rate for sensitive codons, v_sens(S)\n    # v_sens = v_s_low + (v_s_high - v_s_low) * m_star\n    v_sens = v_s_low + (v_s_high - v_s_low) * m_star\n\n    # Step 3: Calculate the total elongation time, T_el(S)\n    t_el_sens = 0.0\n    if n_sens > 0:\n        if v_sens > 0:\n            t_el_sens = n_sens / v_sens\n        else: # Should not happen with positive rates\n            return 0.0\n\n    t_el_non = 0.0\n    if n_non > 0:\n        if v_non > 0:\n            t_el_non = n_non / v_non\n        else: # Should not happen with positive rates\n            return 0.0\n    \n    T_el = t_el_sens + t_el_non\n\n    # Calculate the effective elongation rate, R_el(S)\n    if T_el > 0:\n        R_el = 1.0 / T_el\n    else:\n        # If there are no codons, elongation is instantaneous.\n        R_el = np.inf\n\n    # Step 4: Calculate the initiation rate, I(S)\n    # I_S = I_0 / (1 + S / K_init)\n    if K_init == 0:\n        I_S = 0.0 if S > 0 else I_0\n    else:\n        I_S = I_0 / (1.0 + S / K_init)\n\n    # Step 5: The overall production rate R(S) is the minimum of initiation and elongation rates\n    R_S = np.minimum(I_S, R_el)\n    \n    return R_S\n\n# Execute the main function\nsolve()\n```", "id": "2770762"}, {"introduction": "Having modeled the mechanics and regulation of translation, we now turn to synthetic design. This final practice moves beyond simply maximizing expression and introduces a more sophisticated design goal: engineering a \"smooth\" flow of ribosomes along an $mRNA$. You will develop an optimization algorithm to select synonymous codons that minimize the *variance* of elongation times across a gene, a strategy hypothesized to prevent ribosome traffic jams and improve translational efficiency, all while adhering to critical biophysical constraints [@problem_id:2770668].", "problem": "You are tasked with designing a program that, for a fixed amino acid sequence, selects one synonymous codon at each position to minimize the variability of ribosomal elongation times across the sequence, given a host Transfer Ribonucleic Acid (tRNA) pool and constraints on guanine-cytosine (GC) content. The program must compute the minimal achievable population variance of per-codon elongation times, in seconds squared, under the specified GC-content bounds.\n\nScientific foundation and modeling assumptions:\n- The Central Dogma of molecular biology implies that an amino acid sequence is encoded by a set of synonymous codons with differing kinetic properties.\n- Translation elongation time for a codon is inversely proportional to the effective decoding availability of its cognate tRNA species in the host. For each codon $c$, let the effective availability be $A(c)$ in $\\mathrm{s}^{-1}$. The elongation time is modeled as $t(c) = 1 / A(c)$ in $\\mathrm{s}$.\n- For a sequence of length $N$ codons, choosing codon $c_p$ at position $p \\in \\{1,\\dots,N\\}$ yields elongation times $t_p = t(c_p)$ and population variance\n$$\n\\mathrm{Var} = \\frac{1}{N} \\sum_{p=1}^{N} \\left(t_p - \\bar{t}\\right)^2, \\quad \\text{where } \\bar{t} = \\frac{1}{N} \\sum_{p=1}^{N} t_p.\n$$\n- The GC fraction constraint is applied to the entire coding sequence: if $\\mathrm{GC}(c)$ counts the occurrences of $G$ or $C$ in codon $c$ (an integer in $\\{0,1,2,3\\}$), then the total GC fraction is\n$$\nf_{\\mathrm{GC}} = \\frac{1}{3N} \\sum_{p=1}^{N} \\mathrm{GC}(c_p),\n$$\nand must satisfy $L \\le f_{\\mathrm{GC}} \\le U$, inclusive.\n\nAllowed codon sets and host-effective availabilities:\n- Amino acid Alanine ($\\mathrm{A}$): allowed codons and availabilities $A(c)$ in $\\mathrm{s}^{-1}$\n  - $\\mathrm{GCU}$: $9.0$\n  - $\\mathrm{GCC}$: $13.0$\n  - $\\mathrm{GCA}$: $8.0$\n  - $\\mathrm{GCG}$: $11.0$\n- Amino acid Lysine ($\\mathrm{K}$): allowed codons and availabilities $A(c)$ in $\\mathrm{s}^{-1}$\n  - $\\mathrm{AAA}$: $12.0$\n  - $\\mathrm{AAG}$: $8.0$\n- Amino acid Threonine ($\\mathrm{T}$): allowed codons and availabilities $A(c)$ in $\\mathrm{s}^{-1}$\n  - $\\mathrm{ACU}$: $7.0$\n  - $\\mathrm{ACC}$: $12.0$\n  - $\\mathrm{ACA}$: $6.0$\n  - $\\mathrm{ACG}$: $10.0$\n- Amino acid Glycine ($\\mathrm{G}$): allowed codons and availabilities $A(c)$ in $\\mathrm{s}^{-1}$\n  - $\\mathrm{GGU}$: $8.0$\n  - $\\mathrm{GGC}$: $14.0$\n  - $\\mathrm{GGA}$: $7.0$\n  - $\\mathrm{GGG}$: $12.0$\n\nFundamental base and constraints to use in your derivation and design:\n- Fixed amino acid sequence: the amino acid at position $p$ is given; you must choose one codon from the allowed set for that amino acid.\n- Elongation time per codon: $t(c) = 1/A(c)$, in $\\mathrm{s}$.\n- Objective: minimize the population variance $\\mathrm{Var}$ defined above.\n- Constraint: $L \\le f_{\\mathrm{GC}} \\le U$, where $f_{\\mathrm{GC}}$ is defined above.\n- If no assignment satisfies the GC constraint, report infeasibility by returning $-1.0$.\n\nAngle units are not involved. Physical units are required for times and variances. Express the output variances in $\\mathrm{s}^2$, each rounded to exactly $6$ decimal places.\n\nInput is embedded in the program; no external input is used. Your implementation must compute the minimal variance by exhaustive search over the finite discrete set of synonymous codon assignments that satisfy the GC constraint.\n\nTest suite:\nFor each test case, you are given an amino acid sequence (as a string over the alphabet $\\{\\mathrm{A},\\mathrm{K},\\mathrm{T},\\mathrm{G}\\}$), and GC bounds $[L,U]$.\n\n- Test case $1$:\n  - Amino acid sequence: $\\mathrm{\"AKTAGT\"}$ (length $N=6$).\n  - GC bounds: $L=0.45$, $U=0.60$.\n- Test case $2$:\n  - Amino acid sequence: $\\mathrm{\"KTTKTT\"}$ (length $N=6$).\n  - GC bounds: $L=0.50$, $U=0.50$.\n- Test case $3$:\n  - Amino acid sequence: $\\mathrm{\"ATAGTG\"}$ (length $N=6$).\n  - GC bounds: $L=0.70$, $U=0.75$.\n- Test case $4$:\n  - Amino acid sequence: $\\mathrm{\"AAGAGG\"}$ (length $N=6$).\n  - GC bounds: $L=0.20$, $U=0.30$.\n\nYour program should compute, for each test case, the minimal achievable population variance $\\mathrm{Var}$ in $\\mathrm{s}^2$ among all synonymous-codon assignments satisfying the GC constraint, or $-1.0$ if no feasible assignment exists. Round each result to exactly $6$ decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3},\\mathrm{result4}]$), where each result is a floating-point number formatted to exactly $6$ decimal places.\n\nImplementation notes:\n- Use the definitions above directly; do not introduce any other formulas.\n- The GC-count per codon $\\mathrm{GC}(c)$ is the number of characters in $\\{G,C\\}$ in the codon string $c$.\n- The computational method must be exact over the finite search space for these small test cases.", "solution": "The problem requires the minimization of the population variance of ribosomal elongation times for a given amino acid sequence, subject to a constraint on the overall guanine-cytosine (GC) content. This constitutes a constrained optimization problem over a discrete search space.\n\nLet the amino acid sequence be of length $N$. For each position $p \\in \\{1, \\dots, N\\}$, the amino acid $AA_p$ is specified. Let $C_p$ be the set of synonymous codons that encode $AA_p$. The task is to choose one codon $c_p \\in C_p$ for each position to form a coding sequence $(c_1, c_2, \\dots, c_N)$.\n\nThe objective function to be minimized is the population variance of elongation times, given by:\n$$\n\\mathrm{Var}(t_1, \\dots, t_N) = \\frac{1}{N} \\sum_{p=1}^{N} \\left(t_p - \\bar{t}\\right)^2\n$$\nwhere $t_p = 1/A(c_p)$ is the elongation time for the chosen codon $c_p$, and $\\bar{t} = \\frac{1}{N} \\sum_{p=1}^{N} t_p$ is the mean elongation time. $A(c_p)$ is the given effective availability of the cognate tRNA for codon $c_p$.\n\nThe optimization is subject to a constraint on the total GC fraction of the coding sequence:\n$$\nL \\le f_{\\mathrm{GC}} \\le U\n$$\nwhere $L$ and $U$ are the lower and upper bounds, respectively, and\n$$\nf_{\\mathrm{GC}} = \\frac{1}{3N} \\sum_{p=1}^{N} \\mathrm{GC}(c_p)\n$$\nThe term $\\mathrm{GC}(c_p)$ represents the number of guanine or cytosine bases in codon $c_p$. This constraint can be equivalently expressed in terms of the total GC count, $\\mathrm{GC}_{\\text{total}} = \\sum_{p=1}^{N} \\mathrm{GC}(c_p)$. Since $\\mathrm{GC}_{\\text{total}}$ must be an integer, the constraint becomes:\n$$\n\\lceil 3NL \\rceil \\le \\mathrm{GC}_{\\text{total}} \\le \\lfloor 3NU \\rfloor\n$$\nThis integer-based formulation avoids potential floating-point precision issues.\n\nThe search space is the set of all possible coding sequences, formed by the Cartesian product $C_1 \\times C_2 \\times \\dots \\times C_N$. The size of this space is $\\prod_{p=1}^{N} |C_p|$. For the given problem parameters, the sequence length is small ($N=6$) and the number of synonymous codons for any amino acid is also small ($|C_p| \\in \\{2, 4\\}$). This results in a search space size that is computationally tractable for an exhaustive search, as specified in the problem statement.\n\nThe algorithm proceeds as follows:\n1.  **Data Preparation**: For each amino acid specified in the problem ('A', 'K', 'T', 'G'), we tabulate the corresponding synonymous codons, their elongation times $t(c) = 1/A(c)$, and their GC counts $\\mathrm{GC}(c)$.\n2.  **Generate All Candidates**: An iterative process generates every possible combination of synonymous codons, one for each position in the input amino acid sequence. This is equivalent to exploring every element of the Cartesian product of the sets of synonymous codons.\n3.  **Constraint Filtering**: For each generated candidate codon sequence:\n    a. The total GC count $\\mathrm{GC}_{\\text{total}}$ is computed by summing the GC counts of the individual codons.\n    b. The candidate sequence is considered 'feasible' if and only if its $\\mathrm{GC}_{\\text{total}}$ lies within the pre-calculated integer bounds $[\\lceil 3NL \\rceil, \\lfloor 3NU \\rfloor]$.\n4.  **Optimization**:\n    a. For each feasible candidate sequence, the list of corresponding elongation times $(t_1, \\dots, t_N)$ is assembled.\n    b. The population variance of these times is computed. The formula $\\mathrm{Var} = E[t^2] - (E[t])^2$ is used, where $E[\\cdot]$ denotes the sample mean.\n    c. This variance is compared against the minimum variance found so far among all previously evaluated feasible candidates. The minimum is updated if the current variance is lower.\n5.  **Result Formulation**: After all candidate sequences have been evaluated, if one or more feasible sequences were found, the final result is the minimum variance recorded. If no candidate sequence satisfied the GC constraint, the problem is infeasible, and the result is reported as $-1.0$.\n\nThis exhaustive search guarantees finding the global minimum of the variance under the given constraints, as it evaluates every single valid configuration. The implementation will use Python's `itertools.product` to systematically generate all codon combinations and `numpy.var` for an efficient and accurate calculation of the population variance.", "answer": "```python\nimport numpy as np\nfrom itertools import product\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the codon optimization problem for a series of test cases.\n    \"\"\"\n\n    # Define codon data: {AA: [(codon, availability, gc_count), ...]}\n    # Elongation time t(c) = 1/A(c) will be calculated from availability.\n    CODON_DATA_RAW = {\n        'A': [('GCU', 9.0), ('GCC', 13.0), ('GCA', 8.0), ('GCG', 11.0)],\n        'K': [('AAA', 12.0), ('AAG', 8.0)],\n        'T': [('ACU', 7.0), ('ACC', 12.0), ('ACA', 6.0), ('ACG', 10.0)],\n        'G': [('GGU', 8.0), ('GGC', 14.0), ('GGA', 7.0), ('GGG', 12.0)],\n    }\n\n    def gc_count(codon_str):\n        return codon_str.count('G') + codon_str.count('C')\n\n    # Pre-process data into a more usable format: {AA: [(time, gc_count), ...]}\n    CODON_DATA = {\n        aa: [(1.0 / avail, gc_count(codon)) for codon, avail in codons]\n        for aa, codons in CODON_DATA_RAW.items()\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"seq\": \"AKTAGT\", \"L\": 0.45, \"U\": 0.60},\n        {\"seq\": \"KTTKTT\", \"L\": 0.50, \"U\": 0.50},\n        {\"seq\": \"ATAGTG\", \"L\": 0.70, \"U\": 0.75},\n        {\"seq\": \"AAGAGG\", \"L\": 0.20, \"U\": 0.30},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        seq = case[\"seq\"]\n        L = case[\"L\"]\n        U = case[\"U\"]\n        \n        N = len(seq)\n        total_bases = 3 * N\n\n        # Calculate integer GC count bounds.\n        # min_gc <= total_gc <= max_gc\n        min_gc_total = np.ceil(total_bases * L)\n        max_gc_total = np.floor(total_bases * U)\n\n        # Get the lists of (time, gc_count) tuples for each AA in the sequence.\n        codon_choices_per_pos = [CODON_DATA[aa] for aa in seq]\n\n        # Generate all possible combinations of codons for the sequence.\n        all_codon_combinations = product(*codon_choices_per_pos)\n\n        min_variance = float('inf')\n        found_feasible = False\n\n        for combo in all_codon_combinations:\n            # combo is a tuple of (time, gc_count) pairs for the whole sequence.\n            \n            # Calculate total GC count for the current combination.\n            total_gc = sum(item[1] for item in combo)\n\n            # Check if the GC content constraint is satisfied.\n            if min_gc_total <= total_gc <= max_gc_total:\n                found_feasible = True\n                \n                # Extract elongation times for the feasible combination.\n                times = [item[0] for item in combo]\n                \n                # Calculate population variance.\n                # numpy.var computes population variance by default (ddof=0).\n                variance = np.var(times)\n\n                # Update the minimum variance found so far.\n                if variance < min_variance:\n                    min_variance = variance\n\n        if found_feasible:\n            results.append(f\"{min_variance:.6f}\")\n        else:\n            results.append(f\"{-1.0:.6f}\")\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2770668"}]}