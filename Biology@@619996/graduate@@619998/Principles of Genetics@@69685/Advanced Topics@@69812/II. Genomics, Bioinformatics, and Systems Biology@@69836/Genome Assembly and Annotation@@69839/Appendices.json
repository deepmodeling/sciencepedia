{"hands_on_practices": [{"introduction": "Modern genome assembly pipelines heavily rely on De Bruijn graphs to piece together short sequencing reads into a coherent whole. This exercise provides a foundational look into how these graphs are constructed and, more importantly, how real biological complexity manifests within them. By modeling the k-mers from two distinct alleles of a gene, you will see firsthand how genetic variation, such as a Single Nucleotide Polymorphism (SNP), creates characteristic \"bubbles\" or alternative paths in the graph, which represent the core challenge of ambiguity that assemblers must resolve [@problem_id:1493761].", "problem": "A geneticist is analyzing a specific gene from a newly discovered diploid plant species. Through sequencing, they determine that the individual plant they are studying is heterozygous for this gene. The two alleles present in the plant are represented by the following short DNA sequences:\n\nAllele 1: `5'-GTACATTGAGGCT-3'`\nAllele 2: `5'-GTACATCGAGGCT-3'`\n\nTo assemble the gene from short-read sequencing data, a bioinformatician pools all the reads (which come from both alleles) and constructs a De Bruijn graph. The k-mer size chosen for the assembly is $k=5$. The graph is constructed such that each unique k-mer from the combined set of sequences corresponds to a directed edge, and each unique $(k-1)$-mer sequence forms a node. An edge corresponding to a k-mer connects the node representing its first $k-1$ bases to the node representing its last $k-1$ bases.\n\nCalculate the total number of unique nodes and the total number of unique edges that will be present in the resulting De Bruijn graph.\n\nPresent your answer as a 2-element row matrix `(Number of Nodes, Number of Edges)`.", "solution": "Let the allele sequences be length $L=13$ and the chosen $k$-mer size be $k=5$. In a De Bruijn graph, each unique $k$-mer is a directed edge, and each unique $(k-1)$-mer is a node.\n\nFor each allele, the number of $k$-mers is $L-k+1=13-5+1=9$. The two alleles differ by a single nucleotide (a SNP) at position $7$ (one-based indexing). A $5$-mer window $i,\\dots,i+4$ contains position $7$ if and only if $i\\in\\{3,4,5,6,7\\}$, which is $5$ windows. Therefore, of the $9$ $5$-mers in each allele, $5$ differ between the alleles and the remaining $9-5=4$ are identical. Hence, the number of unique edges (unique $5$-mers) in the pooled data is\n$$\n|E|=\\bigl|K_{1}\\cup K_{2}\\bigr|=|K_{1}|+|K_{2}|-\\bigl|K_{1}\\cap K_{2}\\bigr|=9+9-4=14.\n$$\n\nNodes correspond to unique $(k-1)$-mers with $k-1=4$. For each allele, the number of $4$-mers is $L-(k-1)+1=13-4+1=10$. A $4$-mer window $i,\\dots,i+3$ contains position $7$ if and only if $i\\in\\{4,5,6,7\\}$, which is $4$ windows. Therefore, of the $10$ $4$-mers in each allele, $4$ differ between the alleles and the remaining $10-4=6$ are identical. Hence, the number of unique nodes (unique $4$-mers) is\n$$\n|V|=\\bigl|N_{1}\\cup N_{2}\\bigr|=|N_{1}|+|N_{2}|-\\bigl|N_{1}\\cap N_{2}\\bigr|=10+10-6=14.\n$$\n\nTherefore, the De Bruijn graph has $14$ unique nodes and $14$ unique edges. As a check, explicit enumeration from the allele sequences confirms $14$ distinct $5$-mers and $14$ distinct $4$-mers.", "answer": "$$\\boxed{\\begin{pmatrix}14 & 14\\end{pmatrix}}$$", "id": "1493761"}, {"introduction": "Once a genome is assembled, a critical next step is to assess its quality. The N50 statistic is one of the most widely used metrics for quantifying the contiguity of an assembly, providing a more robust measure than a simple average contig length. This practice problem walks you through the standard procedure for calculating the N50 value, a fundamental skill required to interpret and compare the outputs of different assembly algorithms or sequencing projects [@problem_id:1493824].", "problem": "A bioinformatics team is working on the genome assembly of a newly discovered species of archaea. After sequencing, they use two different assembly algorithms, which result in two different sets of contiguous DNA sequences (contigs). To evaluate and compare the quality of the two assemblies, the team needs to calculate several metrics, one of the most important being the N50 statistic.\n\nThe N50 statistic is a measure of assembly contiguity. It is defined as the length of the shortest contig in the smallest set of contigs whose lengths sum to at least 50% of the total assembly length.\n\nYou are given the complete list of contig lengths for one of the outputs, \"Assembly Alpha\". The lengths of the contigs, in kilobases (kb), are:\n`110, 15, 95, 6, 25, 45, 70, 4`\n\nCalculate the N50 statistic for Assembly Alpha. Provide your answer as a single number in kilobases (kb).", "solution": "The goal is to calculate the N50 statistic for the given set of contig lengths from \"Assembly Alpha\". The provided contig lengths in kilobases (kb) are: `110, 15, 95, 6, 25, 45, 70, 4`.\n\nStep 1: Calculate the total length of the assembly.\nWe sum the lengths of all the contigs:\n$$ \\text{Total Length} = 110 + 15 + 95 + 6 + 25 + 45 + 70 + 4 $$\n$$ \\text{Total Length} = 370 \\text{ kb} $$\n\nStep 2: Determine the 50% threshold of the total assembly length.\nThis is the target value that our cumulative sum of contig lengths must reach or exceed.\n$$ 50\\% \\text{ of Total Length} = 0.5 \\times 370 \\text{ kb} = 185 \\text{ kb} $$\n\nStep 3: Sort the contig lengths in descending order.\nArranging the contigs from longest to shortest is essential for the N50 calculation.\nSorted list: `110, 95, 70, 45, 25, 15, 6, 4`\n\nStep 4: Calculate the cumulative sum of the sorted contig lengths.\nWe add the contig lengths one by one, starting from the largest, until the cumulative sum is greater than or equal to the 50% threshold calculated in Step 2.\n\n- Add the first (longest) contig:\n  Cumulative Sum = `110` kb. This is less than `185` kb.\n\n- Add the second longest contig:\n  Cumulative Sum = `110 + 95 = 205` kb.\n\nThis cumulative sum (`205` kb) is the first sum that is greater than or equal to the 50% threshold (`185` kb).\n\nStep 5: Identify the N50 value.\nThe N50 statistic is defined as the length of the shortest contig in the set that was summed to reach this threshold. In our case, the set of contigs is `{110, 95}`. The shortest contig in this set is `95` kb. Therefore, the N50 value is the length of this last contig we added.\n\nThe N50 for Assembly Alpha is `95` kb.", "answer": "$$\\boxed{95}$$", "id": "1493824"}, {"introduction": "Gene annotation is the process of identifying and describing functional elements within a genome, a task far more complex than simply finding start and stop codons. Modern annotation pipelines integrate multiple, often conflicting, lines of evidence—such as RNA transcript data, sequence conservation, and protein homology—to build the most accurate gene models possible. This advanced exercise challenges you to design a deterministic workflow using a weighted scoring scheme and dynamic programming to resolve these conflicts, simulating the sophisticated logic at the heart of state-of-the-art gene annotation software [@problem_id:2818203].", "problem": "You are given a simplified genomic locus model in which candidate exons and candidate introns must be integrated into a single highest-confidence gene model (a transcript) per locus by combining evidence from Ribonucleic Acid sequencing (RNA-seq), de novo transcript reconstruction, and protein homology alignments. The integration must be performed by a principled evidence weighting scheme and a conflict-resolution strategy that yields a single, maximally supported, non-overlapping, ordered chain of exons connected by allowed introns. The setting abstracts standard annotation practice: exons are genomic intervals, introns connect the end of one exon to the start of a downstream exon, and evidence sources provide quantitative support. The goal is to encode and execute a deterministic algorithm that constructs the optimal transcript under a defined scoring scheme, consistent with biological first principles.\n\nFundamental base and biological grounding: The Central Dogma of Molecular Biology asserts that Deoxyribonucleic Acid (DNA) is transcribed to messenger Ribonucleic Acid (mRNA), which is translated to protein. Therefore, in a steady-state cellular context, the presence of RNA-seq coverage over an exon, spliced junction reads supporting an intron, and homology of the predicted coding region to known proteins all provide converging evidence for the existence of a gene model. The following five axioms must be upheld by your evidence integration scheme: \n$1.$ Evidence additivity across independent features (exonic and intronic contributions sum to form a transcript score). \n$2.$ Monotonicity in each evidence dimension (more support never reduces confidence). \n$3.$ Diminishing returns for raw coverage counts (transform raw coverage with a concave increasing function). \n$4.$ Higher reliability assigned to protein homology than to RNA coverage or de novo transcript counts, reflecting that conservation of coding sequence is a strong indicator of true genes. \n$5.$ Conflicts must be resolved by selecting a non-overlapping, coordinate-ordered chain of exons that uses only allowed introns; among tied solutions, choose the lexicographically smallest exon-identifier sequence.\n\nYour program must implement the following precise scoring and selection rules to ensure testability:\n- Let each candidate exon $e_i$ have coordinates $[a_i,b_i]$ on a single positive strand locus, with features: RNA-seq mean coverage $c_i \\ge 0$, de novo transcript support count $t_i \\in \\{0,1,2,\\dots\\}$, and protein homology score $p_i \\ge 0$. Define the exon contribution\n$$\nS_{\\text{exon}}(e_i) \\;=\\; w_r \\cdot \\log_2(1 + c_i) \\;+\\; w_t \\cdot t_i \\;+\\; w_p \\cdot p_i.\n$$\n- Let each allowed intron $j_{u \\to v}$ connect exon $e_u$ to exon $e_v$ with $b_u < a_v$. Each intron has features: junction read count $r_{uv} \\ge 0$, de novo bridging count $d_{uv} \\ge 0$, and homology gap support $h_{uv} \\ge 0$. Define the intron contribution with a penalty for totally unsupported introns:\n$$\nS_{\\text{intron}}(j_{u \\to v}) \\;=\\; u_r \\cdot \\log_2(1 + r_{uv}) \\;+\\; u_t \\cdot d_{uv} \\;+\\; u_p \\cdot h_{uv} \\;-\\; \\lambda \\cdot \\mathbf{1}\\{r_{uv} = 0 \\wedge d_{uv} = 0 \\wedge h_{uv} = 0\\}.\n$$\n- A transcript is an ordered sequence of distinct exons $(e_{i_1}, e_{i_2}, \\dots, e_{i_m})$ with strictly increasing coordinates and no overlaps, where each adjacency is realized by an allowed intron $j_{i_k \\to i_{k+1}}$. Its score is \n$$\nS_{\\text{tx}} \\;=\\; \\sum_{k=1}^{m} S_{\\text{exon}}(e_{i_k}) \\;+\\; \\sum_{k=1}^{m-1} S_{\\text{intron}}(j_{i_k \\to i_{k+1}}).\n$$\n- Conflict resolution: Select the transcript with maximal $S_{\\text{tx}}$. If multiple transcripts achieve exactly the same maximal score, select the one whose sequence of exon identifiers is lexicographically smallest as an integer list.\n\nUse the following fixed weights and penalty for all loci: $w_r = 1.0$, $w_t = 0.5$, $w_p = 2.0$, $u_r = 1.5$, $u_t = 0.5$, $u_p = 2.0$, and $\\lambda = 3.0$. All logarithms are base $2$.\n\nInput model and test suite: There is no external input; your program must embed and solve the following loci, each defined by a set of exons and a set of introns. All coordinates are on a notional single contig, positive strand, and serve only to define ordering and non-overlap constraints. Exon identifiers are local to each locus and are positive integers.\n\n- Locus $1$:\n  - Exons:\n    - $e_1$: `[100,200]`, $c_1=20.0$, $t_1=1$, $p_1=5.0$.\n    - $e_2$: `[300,400]`, $c_2=25.0$, $t_2=1$, $p_2=6.0$.\n    - $e_3$: `[500,650]`, $c_3=30.0$, $t_3=1$, $p_3=7.0$.\n    - $e_4$: `[300,350]`, $c_4=10.0$, $t_4=1$, $p_4=1.0$ (an alternative to $e_2$).\n  - Introns:\n    - $j_{1 \\to 2}$: $r_{12}=50$, $d_{12}=1$, $h_{12}=5.0$.\n    - $j_{1 \\to 4}$: $r_{14}=5$, $d_{14}=1$, $h_{14}=1.0$.\n    - $j_{2 \\to 3}$: $r_{23}=45$, $d_{23}=1$, $h_{23}=6.0$.\n    - $j_{4 \\to 3}$: $r_{43}=10$, $d_{43}=1$, $h_{43}=1.0$.\n\n- Locus $2$:\n  - Exons:\n    - $e_1$: `[100,220]`, $c_1=1.0$, $t_1=0$, $p_1=20.0$.\n    - $e_2$: `[800,900]`, $c_2=0.5$, $t_2=0$, $p_2=18.0$.\n    - $e_3$: `[100,150]`, $c_3=10.0$, $t_3=0$, $p_3=0.0$ (a short alternative near the start).\n  - Introns:\n    - $j_{1 \\to 2}$: $r_{12}=0$, $d_{12}=0$, $h_{12}=15.0$.\n\n- Locus $3$:\n  - Exons:\n    - $e_1$: `[100,180]`, $c_1=8.0$, $t_1=0$, $p_1=0.0$.\n    - $e_2$: `[120,200]`, $c_2=2.0$, $t_2=2$, $p_2=0.0$ (overlaps $e_1$; cannot co-occur).\n  - Introns: none.\n\n- Locus $4$:\n  - Exons:\n    - $e_1$: `[100,150]`, $c_1=5.0$, $t_1=1$, $p_1=0.0$.\n    - $e_2$: `[300,350]`, $c_2=5.0$, $t_2=1$, $p_2=0.0$.\n  - Introns: none.\n\nComputational requirements:\n- Model the locus as a Directed Acyclic Graph (DAG), where nodes are exons and directed edges are allowed introns. A transcript is a path in this DAG possibly starting at any exon and ending at any exon, with no overlapping exons. If there are no introns given for a locus, the valid transcripts reduce to single-exon selections.\n- Your program must compute the optimal transcript per locus via dynamic programming over the DAG: for each exon, compute the best achievable transcript score ending at that exon considering all incoming edges, with the option to start at that exon. This must obey the non-overlap constraint implicitly enforced by intron definitions and coordinate ordering $b_u < a_v$.\n- Tie-breaking rule: If two transcripts have exactly equal total scores, choose the one with the lexicographically smallest sequence of exon identifiers (compare as integer lists).\n- Numerical stability: Implement $\\log_2(1+x)$ exactly as stated. There are no physical units to report.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, enclosed in square brackets, in which the $k$-th entry is the sequence of exon identifiers of the selected transcript for locus $k$ represented as a list of integers. No spaces must appear in the output. For the four loci above, the output must have the form \n$[\\,[\\dots],\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$ \nwith exact integer identifiers inside. For example, \n$[[1,2,3],[1,2],[1],[1]]$ \nis a valid format.", "solution": "The problem presented is a constrained optimization problem grounded in computational genomics, specifically the synthesis of a single, optimal gene model from multiple conflicting or corroborating sources of evidence. The problem is scientifically valid, well-posed, and all necessary parameters and constraints for a deterministic solution have been provided. We shall proceed with a formal solution.\n\nThe core task is to identify a single transcript, defined as a non-overlapping, coordinate-sorted sequence of exons connected by specified introns, which maximizes a given scoring function. This can be modeled as finding the highest-scoring path in a Directed Acyclic Graph (DAG).\n\nFirst, let us formalize the graph structure for a given locus. The candidate exons $\\{e_i\\}$ serve as the vertices of our graph. A directed edge exists from an exon $e_u$ to an exon $e_v$ if and only if an \"allowed intron\" $j_{u \\to v}$ is specified in the input. The problem states that an intron $j_{u \\to v}$ implies that the coordinates satisfy $b_u < a_v$, where $[a_u, b_u]$ are the coordinates of exon $e_u$. This condition ensures that any two exons connected by an edge are non-overlapping and are in the correct genomic order. By transitivity, any sequence of exons forming a path in this graph will consist of mutually non-overlapping exons whose coordinates are strictly increasing. Therefore, a valid transcript corresponds precisely to a path in this DAG. A transcript can also consist of a single exon, which corresponds to a path of length zero (a single vertex).\n\nThe objective is to find the path (transcript) with the maximum total score. The score of a transcript $(e_{i_1}, e_{i_2}, \\dots, e_{i_m})$ is defined as the sum of the scores of its constituent exons and introns:\n$$\nS_{\\text{tx}} \\;=\\; \\sum_{k=1}^{m} S_{\\text{exon}}(e_{i_k}) \\;+\\; \\sum_{k=1}^{m-1} S_{\\text{intron}}(j_{i_k \\to i_{k+1}})\n$$\nThis structure—finding a path of maximum weight in a DAG—is a classic problem that can be solved efficiently using dynamic programming.\n\nThe algorithm proceeds as follows for each locus:\n\n$1.$ **Initialization**: The set of exons must first be sorted based on their genomic coordinates to establish a topological ordering for the DP algorithm. We sort the exons primarily by their start coordinate ($a_i$) and secondarily by their end coordinate ($b_i$) as a tie-breaker. Let the sorted sequence of exons be $(E_1, E_2, \\dots, E_N)$.\n\n$2.$ **Dynamic Programming**: We will compute, for each exon $E_i$, the score and structure of the optimal transcript ending at that exon. Let $DP[i]$ be a pair $(\\text{score}_i, \\text{path}_i)$, where $\\text{score}_i$ is the maximum score of a transcript ending at exon $E_i$, and $\\text{path}_i$ is the corresponding sequence of exon identifiers.\n\nThe recurrence relation is derived by considering all possible predecessors of an exon $E_i$. A transcript ending at $E_i$ can either start at $E_i$ or be an extension of a transcript ending at a previous exon $E_j$ (where $j < i$) connected by an intron $j_{j \\to i}$.\n\nFor each exon $E_i$ in the sorted list (from $i=1$ to $N$):\n- The score contribution from the exon itself is $S_{\\text{exon}}(E_i)$.\n- We find the best preceding transcript to extend. We iterate through all preceding exons $E_j$ (where $j < i$). If an intron from $E_j$ to $E_i$ exists, we calculate the potential score of the extended path: $\\text{score}_j + S_{\\text{intron}}(j_{j \\to i})$.\n- We select the predecessor $E_j$ that maximizes this value. Let this maximum be $S_{\\text{max\\_prev}}$. If no valid predecessors exist, $S_{\\text{max\\_prev}} = 0$.\n- The score for the optimal transcript ending at $E_i$ is then $\\text{score}_i = S_{\\text{max\\_prev}} + S_{\\text{exon}}(E_i)$. If we are extending from an optimal path ending at $E_j$, the new path is $\\text{path}_i = \\text{path}_j \\oplus [id_i]$, where $\\oplus$ denotes concatenation and $id_i$ is the identifier of exon $E_i$. If there is no predecessor, the path is simply $[id_i]$.\n- To ensure a unique solution, the problem specifies a tie-breaking rule. If multiple preceding paths result in the same total score, we have not been instructed on how to break ties at this intermediate stage. A robust approach is to select the one whose path is lexicographically smallest. However, the problem states the tie-breaker is for the final maximal score. For simplicity and correctness with respect to the prompt, our DP will find the best score, and if multiple paths to an exon give the same score, any can be chosen. The final selection step will resolve any ties among the completed transcripts.\n\nThe base case for the recursion is a transcript starting at an exon $E_i$, which has score $S_{\\text{exon}}(E_i)$ and path $[id_i]$. Our formulation incorporates this by initializing the search for a predecessor with a score of $0$ and an empty path.\n\n$3.$ **Final Selection**: After computing $DP[i]$ for all $i=1, \\dots, N$, the optimal transcript for the locus is not necessarily the one ending at $E_N$. It could be any of the computed optimal paths ending at any $E_i$. We must therefore find the overall maximum score among all computed $\\text{score}_i$.\n- Let $S_{\\text{max}} = \\max_{i=1 \\dots N} \\{\\text{score}_i\\}$.\n- Identify the set of all transcripts $\\{ \\text{path}_k \\}$ whose score is equal to $S_{\\text{max}}$.\n- According to the tie-breaking rule, we select from this set the single transcript whose sequence of exon identifiers is lexicographically smallest.\n\nLet's apply this to Locus $1$.\nThe fixed weights are: $w_r = 1.0$, $w_t = 0.5$, $w_p = 2.0$, $u_r = 1.5$, $u_t = 0.5$, $u_p = 2.0$, $\\lambda = 3.0$.\n\n- **Exon Scores ($S_{\\text{exon}}$)**:\n  - $S(e_1) = \\log_2(1+20) + 0.5 \\cdot 1 + 2 \\cdot 5 = 4.392 + 0.5 + 10 = 14.892$\n  - $S(e_2) = \\log_2(1+25) + 0.5 \\cdot 1 + 2 \\cdot 6 = 4.700 + 0.5 + 12 = 17.200$\n  - $S(e_3) = \\log_2(1+30) + 0.5 \\cdot 1 + 2 \\cdot 7 = 4.954 + 0.5 + 14 = 19.454$\n  - $S(e_4) = \\log_2(1+10) + 0.5 \\cdot 1 + 2 \\cdot 1 = 3.459 + 0.5 + 2 = 5.959$\n\n- **Intron Scores ($S_{\\text{intron}}$)**:\n  - $S(j_{1\\to2}) = 1.5\\log_2(1+50) + 0.5 \\cdot 1 + 2 \\cdot 5 = 1.5 \\cdot 5.672 + 0.5 + 10 = 19.008$\n  - $S(j_{1\\to4}) = 1.5\\log_2(1+5) + 0.5 \\cdot 1 + 2 \\cdot 1 = 1.5 \\cdot 2.585 + 0.5 + 2 = 6.377$\n  - $S(j_{2\\to3}) = 1.5\\log_2(1+45) + 0.5 \\cdot 1 + 2 \\cdot 6 = 1.5 \\cdot 5.524 + 0.5 + 12 = 20.786$\n  - $S(j_{4\\to3}) = 1.5\\log_2(1+10) + 0.5 \\cdot 1 + 2 \\cdot 1 = 1.5 \\cdot 3.459 + 0.5 + 2 = 7.689$\n\n- **DP Execution**: Exons sorted by coordinate are $(e_1, e_4, e_2, e_3)$.\n  - **$DP(e_1)$**: Path starts here. Score = $S(e_1) = 14.892$. Path = $[1]$.\n  - **$DP(e_4)$**: Predecessor $e_1$ via $j_{1\\to4}$. Path $[1,4]$. Score = $S(e_1) + S(j_{1\\to4}) + S(e_4) = 14.892 + 6.377 + 5.959 = 27.228$. Compare to starting at $e_4$ (score $5.959$). Path $[1,4]$ is best.\n  - **$DP(e_2)$**: Predecessor $e_1$ via $j_{1\\to2}$. Path $[1,2]$. Score = $S(e_1) + S(j_{1\\to2}) + S(e_2) = 14.892 + 19.008 + 17.200 = 51.100$. Compare to starting at $e_2$ (score $17.200$). Path $[1,2]$ is best.\n  - **$DP(e_3)$**: Two possible predecessors, $e_2$ and $e_4$.\n    - Via $e_2$: Path $[1,2,3]$. Score = (Score of path $[1,2]$) $+ S(j_{2\\to3}) + S(e_3) = 51.100 + 20.786 + 19.454 = 91.340$.\n    - Via $e_4$: Path $[1,4,3]$. Score = (Score of path $[1,4]$) $+ S(j_{4\\to3}) + S(e_3) = 27.228 + 7.689 + 19.454 = 54.371$.\n    - The path through $e_2$ is superior. Final path is $[1,2,3]$ with score $91.340$.\n\n- **Final Selection for Locus 1**: Comparing all computed optimal path scores:\n  - Path $[1]$: $14.892$\n  - Path $[1,4]$: $27.228$\n  - Path $[1,2]$: $51.100$\n  - Path $[1,2,3]$: $91.340$\n  The maximum score is $91.340$, uniquely corresponding to the transcript $[1,2,3]$.\n\nThis procedure is repeated for all loci. For loci without introns, the set of valid transcripts reduces to single-exon models. The algorithm correctly handles this, as no extension steps will be possible, and the final selection will be among the individual exon scores. For Locus $4$, two transcripts $[1]$ and $[2]$ achieve the same maximal score, and the tie-breaker selects $[1]$ as it is lexicographically smaller.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gene model optimization problem for the four specified loci.\n    \"\"\"\n    \n    # Fixed weights and penalty\n    w_r, w_t, w_p = 1.0, 0.5, 2.0\n    u_r, u_t, u_p = 1.5, 0.5, 2.0\n    lambda_penalty = 3.0\n\n    def s_exon(c, t, p):\n        \"\"\"Calculates the score contribution of an exon.\"\"\"\n        return w_r * np.log2(1 + c) + w_t * t + w_p * p\n\n    def s_intron(r, d, h):\n        \"\"\"Calculates the score contribution of an intron.\"\"\"\n        penalty = lambda_penalty if r == 0 and d == 0 and h == 0 else 0\n        return u_r * np.log2(1 + r) + u_t * d + u_p * h - penalty\n\n    test_cases = [\n        # Locus 1\n        {\n            \"exons\": [\n                {\"id\": 1, \"coords\": [100, 200], \"c\": 20.0, \"t\": 1, \"p\": 5.0},\n                {\"id\": 2, \"coords\": [300, 400], \"c\": 25.0, \"t\": 1, \"p\": 6.0},\n                {\"id\": 3, \"coords\": [500, 650], \"c\": 30.0, \"t\": 1, \"p\": 7.0},\n                {\"id\": 4, \"coords\": [300, 350], \"c\": 10.0, \"t\": 1, \"p\": 1.0},\n            ],\n            \"introns\": [\n                {\"from\": 1, \"to\": 2, \"r\": 50, \"d\": 1, \"h\": 5.0},\n                {\"from\": 1, \"to\": 4, \"r\": 5, \"d\": 1, \"h\": 1.0},\n                {\"from\": 2, \"to\": 3, \"r\": 45, \"d\": 1, \"h\": 6.0},\n                {\"from\": 4, \"to\": 3, \"r\": 10, \"d\": 1, \"h\": 1.0},\n            ],\n        },\n        # Locus 2\n        {\n            \"exons\": [\n                {\"id\": 1, \"coords\": [100, 220], \"c\": 1.0, \"t\": 0, \"p\": 20.0},\n                {\"id\": 2, \"coords\": [800, 900], \"c\": 0.5, \"t\": 0, \"p\": 18.0},\n                {\"id\": 3, \"coords\": [100, 150], \"c\": 10.0, \"t\": 0, \"p\": 0.0},\n            ],\n            \"introns\": [\n                {\"from\": 1, \"to\": 2, \"r\": 0, \"d\": 0, \"h\": 15.0},\n            ],\n        },\n        # Locus 3\n        {\n            \"exons\": [\n                {\"id\": 1, \"coords\": [100, 180], \"c\": 8.0, \"t\": 0, \"p\": 0.0},\n                {\"id\": 2, \"coords\": [120, 200], \"c\": 2.0, \"t\": 2, \"p\": 0.0},\n            ],\n            \"introns\": [],\n        },\n        # Locus 4\n        {\n            \"exons\": [\n                {\"id\": 1, \"coords\": [100, 150], \"c\": 5.0, \"t\": 1, \"p\": 0.0},\n                {\"id\": 2, \"coords\": [300, 350], \"c\": 5.0, \"t\": 1, \"p\": 0.0},\n            ],\n            \"introns\": [],\n        },\n    ]\n\n    final_results = []\n    \n    for locus in test_cases:\n        exons_data = {e['id']: e for e in locus['exons']}\n        introns_data = {(i['from'], i['to']): i for i in locus['introns']}\n\n        # Sort exons by start coordinate, then end coordinate\n        sorted_exon_ids = sorted(exons_data.keys(), key=lambda eid: (exons_data[eid]['coords'][0], exons_data[eid]['coords'][1]))\n        \n        # DP state: dp[exon_id] = (score, path)\n        dp = {}\n\n        for i in range(len(sorted_exon_ids)):\n            current_exon_id = sorted_exon_ids[i]\n            current_exon = exons_data[current_exon_id]\n            \n            # Base case: transcript starts with this exon\n            best_score = s_exon(current_exon['c'], current_exon['t'], current_exon['p'])\n            best_path = [current_exon_id]\n\n            # DP step: check for predecessors\n            for j in range(i):\n                prev_exon_id = sorted_exon_ids[j]\n                \n                if (prev_exon_id, current_exon_id) in introns_data:\n                    intron = introns_data[(prev_exon_id, current_exon_id)]\n                    \n                    prev_score, prev_path = dp[prev_exon_id]\n                    \n                    current_s_intron = s_intron(intron['r'], intron['d'], intron['h'])\n                    path_score = prev_score + current_s_intron + s_exon(current_exon['c'], current_exon['t'], current_exon['p'])\n                    \n                    if path_score > best_score:\n                        best_score = path_score\n                        best_path = prev_path + [current_exon_id]\n                    # Intermediate tie-breaking (lexicographical) - though not strictly required by prompt, it's good practice\n                    elif path_score == best_score:\n                        new_path = prev_path + [current_exon_id]\n                        if new_path  best_path:\n                           best_path = new_path\n\n            dp[current_exon_id] = (best_score, best_path)\n\n        # Final selection across all possible transcripts (paths)\n        if not dp:\n            final_results.append([])\n            continue\n\n        max_score = -np.inf\n        best_transcripts = []\n\n        for exon_id in sorted_exon_ids:\n            score, path = dp[exon_id]\n            if score > max_score:\n                max_score = score\n                best_transcripts = [path]\n            elif score == max_score:\n                best_transcripts.append(path)\n        \n        # Apply the final tie-breaking rule\n        best_transcripts.sort()\n        final_results.append(best_transcripts[0])\n\n    # Format output\n    result_strings = []\n    for res in final_results:\n        result_strings.append(f\"[{','.join(map(str, res))}]\")\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2818203"}]}