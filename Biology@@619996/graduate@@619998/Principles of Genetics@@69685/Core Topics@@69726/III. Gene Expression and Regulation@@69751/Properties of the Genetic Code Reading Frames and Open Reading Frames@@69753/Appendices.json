{"hands_on_practices": [{"introduction": "To identify meaningful biological signals, such as protein-coding genes, we must first understand the properties of a random sequence. This exercise establishes a fundamental null model for gene finding by asking you to derive the expected length of an open reading frame (ORF) that would occur by chance. By applying basic probability theory to a sequence with a given nucleotide composition, you will develop a crucial baseline for distinguishing genuine genetic information from statistical noise [@problem_id:2843264].", "id": "2843264", "problem": "A single-stranded deoxyribonucleic acid (DNA) sequence is modeled as an infinite sequence of independent and identically distributed nucleotides with probabilities $\\{p_A, p_C, p_G, p_T\\}$, where $p_A, p_C, p_G, p_T \\in (0,1)$ and $p_A + p_C + p_G + p_T = 1$. Fix a reading frame and parse the sequence into non-overlapping codons (triplets) in that frame. In the standard genetic code, the in-frame stop codons (terminators) in DNA alphabet are $\\text{TAA}$, $\\text{TAG}$, and $\\text{TGA}$.\n\nDefine an open reading frame (ORF; open reading frame) in this stylized model as the maximal run of consecutive non-stop codons terminated by the next in-frame stop codon when scanning codons in the fixed frame. Let $L$ denote the total number of codons scanned from an arbitrary codon boundary until and including the first in-frame stop codon encountered in that frame.\n\nAssuming independence across nucleotides and across codon boundaries induced by the independent and identically distributed model, use only fundamental definitions of the standard genetic code and probability to:\n\n- Express the exact in-frame stop-codon probability $p_{\\text{stop}}$ in terms of $p_A, p_C, p_G, p_T$.\n- Then, treating successive codons in the fixed frame as independent trials with constant success probability $p_{\\text{stop}}$, recognize the implied distribution for $L$ and derive a closed-form analytic expression for the expectation $\\mathbb{E}[L]$ in terms of $p_A, p_C, p_G, p_T$ only.\n\nReport as your final answer the single closed-form analytic expression for $\\mathbb{E}[L]$ in terms of $p_A, p_C, p_G, p_T$. No numerical evaluation is required, and no units are involved. The answer must be a single expression (not an inequality or an equation).", "solution": "The problem statement submitted for consideration has been rigorously validated. The givens are as follows: a model of single-stranded DNA as an infinite sequence of independent and identically distributed (i.i.d.) nucleotides from the set $\\{A, C, G, T\\}$ with corresponding probabilities $\\{p_A, p_C, p_G, p_T\\}$. These probabilities are strictly positive and sum to unity: $p_A, p_C, p_G, p_T \\in (0,1)$ and $p_A + p_C + p_G + p_T = 1$. The sequence is parsed into non-overlapping codons in a fixed reading frame. The in-frame stop codons are specified as $\\text{TAA}$, $\\text{TAG}$, and $\\text{TGA}$. The random variable $L$ represents the number of codons inspected, starting from an arbitrary codon boundary, up to and including the first in-frame stop codon encountered. The task is to derive the expectation of $L$, denoted $\\mathbb{E}[L]$, in terms of the nucleotide probabilities.\n\nThe problem is scientifically grounded, well-posed, and objective. It employs a standard, albeit simplified, probabilistic model used in elementary bioinformatics. The definitions are precise, and no information is missing or contradictory. The problem is a formal exercise in probability theory applied to genetics, and is therefore valid. We may proceed with the solution.\n\nThe first step is to compute the probability of encountering an in-frame stop codon. We denote this probability as $p_{\\text{stop}}$. A codon is a triplet of nucleotides. Due to the assumption that the nucleotides are independent and identically distributed, the probability of any specific codon sequence, say $N_1N_2N_3$, is the product of the individual nucleotide probabilities: $P(N_1N_2N_3) = p_{N_1} p_{N_2} p_{N_3}$.\n\nThe set of in-frame stop codons is given as $\\{\\text{TAA}, \\text{TAG}, \\text{TGA}\\}$. These three codons are mutually exclusive events for any single codon position. Therefore, the total probability of a randomly selected codon being a stop codon is the sum of their individual probabilities:\n$$p_{\\text{stop}} = P(\\text{TAA}) + P(\\text{TAG}) + P(\\text{TGA})$$\nUsing the independence of nucleotides, we calculate each term:\n$P(\\text{TAA}) = p_T \\cdot p_A \\cdot p_A = p_T p_A^2$\n$P(\\text{TAG}) = p_T \\cdot p_A \\cdot p_G = p_T p_A p_G$\n$P(\\text{TGA}) = p_T \\cdot p_G \\cdot p_A = p_T p_G p_A$\n\nSumming these probabilities yields the expression for $p_{\\text{stop}}$:\n$$p_{\\text{stop}} = p_T p_A^2 + p_T p_A p_G + p_T p_G p_A = p_T p_A^2 + 2 p_T p_A p_G$$\nThis expression can be factored for conciseness:\n$$p_{\\text{stop}} = p_T p_A (p_A + 2p_G)$$\n\nThe second step is to determine the probability distribution of the random variable $L$. The problem defines $L$ as the total number of codons scanned until and including the first stop codon. The scanning process consists of examining successive, non-overlapping codons. Because the underlying nucleotides are i.i.d., each codon can be treated as an independent trial.\n\nEach trial has two outcomes:\n$1$. A \"success\", which corresponds to observing a stop codon. The probability of success is $p = p_{\\text{stop}}$.\n$2$. A \"failure\", which corresponds to observing any codon other than a stop codon. The probability of failure is $q = 1 - p_{\\text{stop}}$.\n\nThe random variable $L$ is the number of trials required to achieve the first success. This is the precise definition of a random variable following a geometric distribution. The probability mass function for $L$ is given by:\n$$P(L=k) = (1-p_{\\text{stop}})^{k-1} p_{\\text{stop}}, \\quad \\text{for } k = 1, 2, 3, \\dots$$\nThis represents the probability of $k-1$ consecutive failures (non-stop codons) followed by one success (a stop codon).\n\nThe expectation, or mean, of a geometrically distributed random variable with success probability $p$ is a standard result in probability theory:\n$$\\mathbb{E}[L] = \\frac{1}{p}$$\nIn our context, the success probability is $p = p_{\\text{stop}}$. Therefore, the expected number of codons until and including the first stop codon is:\n$$\\mathbb{E}[L] = \\frac{1}{p_{\\text{stop}}}$$\nSubstituting our derived expression for $p_{\\text{stop}}$ gives the final closed-form analytic expression for $\\mathbb{E}[L]$ in terms of the given nucleotide probabilities:\n$$\\mathbb{E}[L] = \\frac{1}{p_T p_A^2 + 2 p_T p_A p_G}$$\nAlternatively, using the factored form:\n$$\\mathbb{E}[L] = \\frac{1}{p_T p_A (p_A + 2p_G)}$$\nThis is the required expression. It is noted that the probability $p_C$ does not appear in the final formula, which is correct because the nucleotide Cytosine ($C$) is not part of any of the three standard stop codons TAA, TAG, or TGA.", "answer": "$$\\boxed{\\frac{1}{p_T p_A (p_A + 2p_G)}}$$"}, {"introduction": "Unlike random sequences, real genes are finely tuned by evolution, which often results in non-random patterns such as codon usage bias. This phenomenon, where some synonymous codons are preferred over others, has significant implications for translational efficiency and gene expression. This practice shifts our focus from abstract models to empirical data analysis, introducing the Relative Synonymous Codon Usage (RSCU) as a tool to quantify these preferences [@problem_id:2843258]. Calculating RSCU values from gene data is a standard technique that provides quantitative insights into the evolutionary forces shaping a genome.", "id": "2843258", "problem": "A coding sequence is translated in a fixed reading frame, partitioning the nucleotide string into non-overlapping triplet codons, and an open reading frame (ORF) is defined as a contiguous set of codons from a start codon to a stop codon without interruption in the same frame. In the validated longest open reading frame (ORF) of a bacterial gene (standard genetic code), codon counts for selected synonymous families were tabulated in the $+1$ reading frame as follows (codon families are listed with their observed counts in this ORF; all other amino acids and codons not listed can be ignored for this analysis):\n\n- Proline (CCN): CCT $6$, CCC $2$, CCA $4$, CCG $2$.\n- Alanine (GCN): GCT $3$, GCC $9$, GCA $2$, GCG $0$.\n- Glycine (GGN): GGT $5$, GGC $1$, GGA $4$, GGG $8$.\n- Valine (GTN): GTT $2$, GTC $10$, GTA $0$, GTG $4$.\n- Threonine (ACN): ACT $4$, ACC $4$, ACA $4$, ACG $0$.\n- Phenylalanine (TTT/TTC): TTT $7$, TTC $1$.\n- Isoleucine (ATT/ATC/ATA): ATT $3$, ATC $9$, ATA $0$.\n- Leucine (TTA/TTG/CTT/CTC/CTA/CTG): TTA $1$, TTG $5$, CTT $2$, CTC $7$, CTA $1$, CTG $14$.\n\nStarting from the degeneracy of the standard genetic code and the concept of a fixed reading frame and open reading frame, use the definition of Relative Synonymous Codon Usage (RSCU) as a normalization against the equal-usage null model within each synonymous family to compute RSCU values for every codon listed. Define a codon as overrepresented if its RSCU is strictly greater than $1$, underrepresented if strictly less than $1$, and neither if exactly equal to $1$.\n\nWhat is the total number of overrepresented codons across all the listed synonymous families, according to this criterion? Provide your answer as a single integer. No rounding is required.", "solution": "The problem statement is validated as scientifically grounded, well-posed, and objective. It provides a clear definition of Relative Synonymous Codon Usage (RSCU) and presents a complete set of codon count data for a series of synonymous families. The task is to compute the RSCU for each codon and determine how many are \"overrepresented,\" defined as having an RSCU value strictly greater than $1$. The problem is a direct and standard application of principles in bioinformatics and molecular genetics.\n\nThe Relative Synonymous Codon Usage (RSCU) for a specific codon $i$ within a synonymous family of $n$ codons is defined as the ratio of its observed count ($x_i$) to its expected count under a model of uniform usage. The total count for the amino acid is $\\sum_{j=1}^{n} x_j$, so the expected count for any given codon is $\\frac{1}{n} \\sum_{j=1}^{n} x_j$. The RSCU is therefore calculated as:\n$$\n\\text{RSCU}_i = \\frac{x_i}{\\frac{1}{n} \\sum_{j=1}^{n} x_j} = \\frac{n \\cdot x_i}{\\sum_{j=1}^{n} x_j}\n$$\nA codon is overrepresented if $\\text{RSCU}_i > 1$. We will systematically analyze each amino acid family provided.\n\nProline (Pro): This family has a degeneracy of $n=4$. The codons and their counts are: CCT ($6$), CCC ($2$), CCA ($4$), CCG ($2$).\nThe total count is $\\sum x_j = 6 + 2 + 4 + 2 = 14$.\nThe expected count per codon is $\\frac{14}{4} = 3.5$. A codon is overrepresented if its count is greater than $3.5$.\n- CCT: count is $6 > 3.5$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 6}{14} = \\frac{12}{7} > 1$)\n- CCC: count is $2 < 3.5$. Underrepresented.\n- CCA: count is $4 > 3.5$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 4}{14} = \\frac{8}{7} > 1$)\n- CCG: count is $2 < 3.5$. Underrepresented.\nNumber of overrepresented codons for Proline: $2$.\n\nAlanine (Ala): This family has a degeneracy of $n=4$. The codons and their counts are: GCT ($3$), GCC ($9$), GCA ($2$), GCG ($0$).\nThe total count is $\\sum x_j = 3 + 9 + 2 + 0 = 14$.\nThe expected count per codon is $\\frac{14}{4} = 3.5$.\n- GCT: count is $3 < 3.5$. Underrepresented.\n- GCC: count is $9 > 3.5$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 9}{14} = \\frac{18}{7} > 1$)\n- GCA: count is $2 < 3.5$. Underrepresented.\n- GCG: count is $0 < 3.5$. Underrepresented.\nNumber of overrepresented codons for Alanine: $1$.\n\nGlycine (Gly): This family has a degeneracy of $n=4$. The codons and their counts are: GGT ($5$), GGC ($1$), GGA ($4$), GGG ($8$).\nThe total count is $\\sum x_j = 5 + 1 + 4 + 8 = 18$.\nThe expected count per codon is $\\frac{18}{4} = 4.5$.\n- GGT: count is $5 > 4.5$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 5}{18} = \\frac{10}{9} > 1$)\n- GGC: count is $1 < 4.5$. Underrepresented.\n- GGA: count is $4 < 4.5$. Underrepresented.\n- GGG: count is $8 > 4.5$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 8}{18} = \\frac{16}{9} > 1$)\nNumber of overrepresented codons for Glycine: $2$.\n\nValine (Val): This family has a degeneracy of $n=4$. The codons and their counts are: GTT ($2$), GTC ($10$), GTA ($0$), GTG ($4$).\nThe total count is $\\sum x_j = 2 + 10 + 0 + 4 = 16$.\nThe expected count per codon is $\\frac{16}{4} = 4$. A codon is overrepresented if its count is strictly greater than $4$.\n- GTT: count is $2 < 4$. Underrepresented.\n- GTC: count is $10 > 4$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 10}{16} = 2.5 > 1$)\n- GTA: count is $0 < 4$. Underrepresented.\n- GTG: count is $4$. Not strictly greater, so it is not overrepresented. ($\\text{RSCU} = \\frac{4 \\times 4}{16} = 1$)\nNumber of overrepresented codons for Valine: $1$.\n\nThreonine (Thr): This family has a degeneracy of $n=4$. The codons and their counts are: ACT ($4$), ACC ($4$), ACA ($4$), ACG ($0$).\nThe total count is $\\sum x_j = 4 + 4 + 4 + 0 = 12$.\nThe expected count per codon is $\\frac{12}{4} = 3$.\n- ACT: count is $4 > 3$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 4}{12} = \\frac{4}{3} > 1$)\n- ACC: count is $4 > 3$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 4}{12} = \\frac{4}{3} > 1$)\n- ACA: count is $4 > 3$. Overrepresented. ($\\text{RSCU} = \\frac{4 \\times 4}{12} = \\frac{4}{3} > 1$)\n- ACG: count is $0 < 3$. Underrepresented.\nNumber of overrepresented codons for Threonine: $3$.\n\nPhenylalanine (Phe): This family has a degeneracy of $n=2$. The codons and their counts are: TTT ($7$), TTC ($1$).\nThe total count is $\\sum x_j = 7 + 1 = 8$.\nThe expected count per codon is $\\frac{8}{2} = 4$.\n- TTT: count is $7 > 4$. Overrepresented. ($\\text{RSCU} = \\frac{2 \\times 7}{8} = 1.75 > 1$)\n- TTC: count is $1 < 4$. Underrepresented.\nNumber of overrepresented codons for Phenylalanine: $1$.\n\nIsoleucine (Ile): This family has a degeneracy of $n=3$. The codons and their counts are: ATT ($3$), ATC ($9$), ATA ($0$).\nThe total count is $\\sum x_j = 3 + 9 + 0 = 12$.\nThe expected count per codon is $\\frac{12}{3} = 4$.\n- ATT: count is $3 < 4$. Underrepresented.\n- ATC: count is $9 > 4$. Overrepresented. ($\\text{RSCU} = \\frac{3 \\times 9}{12} = 2.25 > 1$)\n- ATA: count is $0 < 4$. Underrepresented.\nNumber of overrepresented codons for Isoleucine: $1$.\n\nLeucine (Leu): This family has a degeneracy of $n=6$. The codons and their counts are: TTA ($1$), TTG ($5$), CTT ($2$), CTC ($7$), CTA ($1$), CTG ($14$).\nThe total count is $\\sum x_j = 1 + 5 + 2 + 7 + 1 + 14 = 30$.\nThe expected count per codon is $\\frac{30}{6} = 5$. A codon is overrepresented if its count is strictly greater than $5$.\n- TTA: count is $1 < 5$. Underrepresented.\n- TTG: count is $5$. Not strictly greater, so it is not overrepresented. ($\\text{RSCU} = \\frac{6 \\times 5}{30} = 1$)\n- CTT: count is $2 < 5$. Underrepresented.\n- CTC: count is $7 > 5$. Overrepresented. ($\\text{RSCU} = \\frac{6 \\times 7}{30} = 1.4 > 1$)\n- CTA: count is $1 < 5$. Underrepresented.\n- CTG: count is $14 > 5$. Overrepresented. ($\\text{RSCU} = \\frac{6 \\times 14}{30} = 2.8 > 1$)\nNumber of overrepresented codons for Leucine: $2$.\n\nTo obtain the final answer, we sum the number of overrepresented codons from each family:\nTotal overrepresented codons = $2 (\\text{Pro}) + 1 (\\text{Ala}) + 2 (\\text{Gly}) + 1 (\\text{Val}) + 3 (\\text{Thr}) + 1 (\\text{Phe}) + 1 (\\text{Ile}) + 2 (\\text{Leu})$.\nTotal = $2 + 1 + 2 + 1 + 3 + 1 + 1 + 2 = 13$.", "answer": "$$\\boxed{13}$$"}, {"introduction": "The genetic code's structure allows for remarkable complexity, nowhere more apparent than in overlapping genes, where a single DNA sequence can encode multiple proteins in different reading frames. This \"data compression\" strategy, common in viral genomes, creates a profound evolutionary constraint: a single mutation can impact two or more distinct proteins. This final practice challenges you to translate these complex biological rules into a precise computational algorithm, a core skill in modern bioinformatics [@problem_id:2843175]. You will design a program to identify single-nucleotide substitutions that are \"safe,\" demonstrating the power of computation to explore the intertwined constraints of molecular evolution.", "id": "2843175", "problem": "Construct a complete, runnable program that, given a deoxyribonucleic acid (DNA) sequence and two reading frames on the same strand, enumerates all single-nucleotide synonymous substitutions in one frame that do not introduce a stop codon or a nonsynonymous change in the overlapping frame. The algorithm must be derived from fundamental definitions of the Central Dogma of Molecular Biology (DNA to messenger ribonucleic acid to protein), the standard genetic code, and the formal notion of a reading frame and an open reading frame.\n\nThe fundamental base comprises:\n- The DNA alphabet $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$.\n- Codons are consecutive triplets of nucleotides, and the standard nuclear genetic code is a mapping $g : \\Sigma^3 \\rightarrow \\mathcal{A} \\cup \\{\\ast\\}$ where $\\mathcal{A}$ is the set of amino acids and $\\ast$ denotes a stop signal.\n- A reading frame with offset $r \\in \\{0,1,2\\}$ on a sequence $S$ defines codon starts at indices $k$ such that $k \\equiv r \\pmod{3}$, and each codon is the triplet $S[k]S[k+1]S[k+2]$ when these indices lie within the region of interest.\n- An open reading frame (ORF) is a contiguous series of codons that encode amino acids without internal stop codons.\n- A single-nucleotide substitution at position $i$ replacing nucleotide $b \\in \\Sigma$ with $b' \\in \\Sigma \\setminus \\{b\\}$ is synonymous in a given frame if the amino acid encoded by the codon containing $i$ remains unchanged after the substitution.\n\nFormally, let the inputs be a DNA string $S$ over $\\Sigma$, a primary frame offset $p \\in \\{0,1,2\\}$, an overlapping frame offset $q \\in \\{0,1,2\\}$, and a half-open index interval $[s,e)$ with $s,e \\in \\mathbb{Z}$, $0 \\le s < e \\le |S|$. A position $i \\in \\{s,s+1,\\dots,e-1\\}$ participates in a valid codon in frame offset $r$ if there is a unique codon start $k$ with $k \\equiv r \\pmod{3}$, $k \\le i \\le k+2$, and $s \\le k$ and $k+2 < e$. For a candidate substitution $(i,b \\to b')$ to be included in the output set, all of the following must hold:\n- The primary-frame codon containing $i$ and the overlapping-frame codon containing $i$ both exist entirely within $[s,e)$.\n- The unmutated codon in the primary frame encodes $g(\\cdot) \\in \\mathcal{A}$ (not $\\ast$).\n- The unmutated codon in the overlapping frame encodes $g(\\cdot) \\in \\mathcal{A}$ (not $\\ast$).\n- After substituting $b$ with $b'$ at position $i$, the primary-frame codon’s amino acid is unchanged (synonymous in the primary frame).\n- After substituting $b$ with $b'$ at position $i$, the overlapping-frame codon’s amino acid is unchanged and is not a stop codon (no stop or nonsynonymous change is introduced in the overlapping frame).\n\nYour program must:\n- Implement the standard nuclear genetic code for $g$ explicitly.\n- Enumerate all valid single-nucleotide substitutions satisfying the above constraints.\n- Encode each substitution as a triple $[i', \\phi(b), \\phi(b')]$, where $i' = i - s$ is the $0$-based index within the region $[s,e)$, and $\\phi$ is the bijection $\\phi(\\text{A})=0$, $\\phi(\\text{C})=1$, $\\phi(\\text{G})=2$, $\\phi(\\text{T})=3$.\n- Sort the triples by increasing $i'$, breaking ties by increasing $\\phi(b')$.\n\nDesign your algorithm using only the definitions above, without shortcut formulas. Be careful to enforce codon completeness within $[s,e)$ and to exclude any site where the unmutated codon in either frame is a stop. Assume the sequence is on the same strand for both frames; do not consider reverse complement frames.\n\nTest Suite. Use the following test cases, each specified as a $5$-tuple $(S,p,q,s,e)$:\n- Case $1$: $S=\\text{\"GGTTATGGTTAT\"}$, $p=0$, $q=2$, $s=0$, $e=12$.\n- Case $2$: $S=\\text{\"GGTGGTGGTGGTGGTGGT\"}$, $p=0$, $q=1$, $s=0$, $e=18$.\n- Case $3$: $S=\\text{\"GGTTATGGT\"}$, $p=0$, $q=2$, $s=1$, $e=8$.\n- Case $4$: $S=\\text{\"GGTGAT\"}$, $p=0$, $q=2$, $s=0$, $e=6$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element is the list of encoded triples for the corresponding test case, in order. For example, a valid output has the form\n\"[list_for_case_1,list_for_case_2,list_for_case_3,list_for_case_4]\".", "solution": "The problem requires the enumeration of single-nucleotide substitutions that are simultaneously synonymous in a primary reading frame and a specified overlapping reading frame, without introducing stop codons. The problem is scientifically grounded, well-posed, and objective, based on fundamental principles of molecular genetics. It is therefore deemed valid and a reasoned solution can be constructed.\n\nThe algorithm is designed by directly implementing the formal definitions provided. The core of the solution is to iterate through every possible single-nucleotide substitution at each relevant position and test it against a set of strictly defined criteria.\n\nFirst, we must establish the necessary biological and mathematical context. The standard nuclear genetic code is a function $g: \\Sigma^3 \\rightarrow \\mathcal{A} \\cup \\{\\ast\\}$, where $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ is the DNA alphabet, $\\mathcal{A}$ is the set of amino acids, and $\\ast$ represents a stop signal. This mapping is implemented as a dictionary. A numerical encoding $\\phi$ for the nucleotides is also defined as $\\phi(\\text{A})=0$, $\\phi(\\text{C})=1$, $\\phi(\\text{G})=2$, $\\phi(\\text{T})=3$.\n\nThe overall algorithm processes a set of test cases. For each case, specified by a DNA sequence $S$, a primary frame offset $p \\in \\{0, 1, 2\\}$, an overlapping frame offset $q \\in \\{0, 1, 2\\}$, and a half-open index interval $[s, e)$, the following steps are performed:\n\n1.  **Iteration over Positions**: The algorithm iterates through each nucleotide position $i$ within the specified range, from $s$ to $e-1$. For each position $i$, we consider all possible substitutions of the original base $S[i]$ with a different base from $\\Sigma$.\n\n2.  **Codon Identification**: For a given position $i$, we must identify the codons in the primary frame ($p$) and overlapping frame ($q$) that contain this nucleotide. The starting position $k_r$ of a codon in a frame with offset $r$ that includes index $i$ is uniquely determined by the formula $k_r = i - (i-r) \\pmod{3}$. Using this, we find the start of the primary codon, $k_p = i - (i-p) \\pmod{3}$, and the start of the overlapping codon, $k_q = i - (i-q) \\pmod{3}$.\n\n3.  **Codon Validity Check**: A codon starting at index $k$ is considered valid within the region of interest $[s, e)$ only if it is fully contained within this region's boundaries. This is enforced by the two conditions: $s \\le k$ and $k+2 < e$. At each position $i$, we compute $k_p$ and $k_q$ and verify that both these conditions hold for both codon starts. If either codon is not fully contained, the position $i$ cannot host a valid substitution under the problem's rules, and we proceed to the next position.\n\n4.  **Initial State Verification**: Before considering any mutations, we must check the status of the unmutated codons. We extract the primary codon $C_p = S[k_p:k_p+3]$ and the overlapping codon $C_q = S[k_q:k_q+3]$. We then translate them using the genetic code map $g$ to find their corresponding amino acids, $A_p = g(C_p)$ and $A_q = g(C_q)$. The problem stipulates that a position is only a candidate for valid substitutions if neither of the original codons encodes a stop signal. Therefore, if $A_p = \\ast$ or $A_q = \\ast$, we discard position $i$ and continue to the next.\n\n5.  **Substitution Analysis**: If the position $i$ passes the validity and initial state checks, we proceed to test all three possible single-nucleotide substitutions. Let the original base be $b = S[i]$. We iterate through each alternative base $b' \\in \\Sigma \\setminus \\{b\\}$. For each potential substitution $(i, b \\to b')$:\n    a. We construct the two mutated codons, $C'_p$ and $C'_q$. The mutation occurs at position $i-k_p$ within the primary codon and $i-k_q$ within the overlapping codon.\n    b. We translate these mutated codons to get the new amino acids, $A'_p = g(C'_p)$ and $A'_q = g(C'_q)$.\n    c. We check the substitution against the required constraints:\n        i.  **Synonymy in Primary Frame**: The substitution must be synonymous, meaning the amino acid does not change. This is verified by checking if $A'_p = A_p$.\n        ii. **No Change in Overlapping Frame**: The substitution must not introduce a stop codon or a nonsynonymous change. Since we have already established that the original codon $C_q$ does not code for a stop, this condition simplifies to requiring that the substitution also be synonymous in the overlapping frame: $A'_q = A_q$.\n\n6.  **Result Compilation and Sorting**: If a substitution $(i, b \\to b')$ satisfies both conditions, it is deemed valid. It is then encoded into the specified output format: a triple $[i', \\phi(b), \\phi(b')]$, where $i' = i - s$ is the $0$-based index within the region $[s,e)$. These triples are collected for the current test case. After all positions $i$ have been processed, the resulting list of triples is sorted first by increasing $i'$ and then, as a tie-breaker, by increasing $\\phi(b')$.\n\n7.  **Final Output Generation**: The sorted list of triples for each test case is collected. The final output is a single string representing a list of these results, formatted compactly without spaces as per the implicit requirement for a machine-readable format.", "answer": "```python\nimport numpy as np\n# No scipy needed for this problem.\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding single-nucleotide synonymous substitutions\n    in overlapping reading frames as per the problem description.\n    \"\"\"\n\n    # The standard nuclear genetic code mapping codons to amino acids.\n    # '*' denotes a stop codon.\n    GENETIC_CODE = {\n        'ATA': 'I', 'ATC': 'I', 'ATT': 'I', 'ATG': 'M',\n        'ACA': 'T', 'ACC': 'T', 'ACG': 'T', 'ACT': 'T',\n        'AAC': 'N', 'AAT': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGC': 'S', 'AGT': 'S', 'AGA': 'R', 'AGG': 'R',\n        'CTA': 'L', 'CTC': 'L', 'CTG': 'L', 'CTT': 'L',\n        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCT': 'P',\n        'CAC': 'H', 'CAT': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGA': 'R', 'CGC': 'R', 'CGG': 'R', 'CGT': 'R',\n        'GTA': 'V', 'GTC': 'V', 'GTG': 'V', 'GTT': 'V',\n        'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCT': 'A',\n        'GAC': 'D', 'GAT': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGT': 'G',\n        'TCA': 'S', 'TCC': 'S', 'TCG': 'S', 'TCT': 'S',\n        'TTC': 'F', 'TTT': 'F', 'TTA': 'L', 'TTG': 'L',\n        'TAC': 'Y', 'TAT': 'Y', 'TAA': '*', 'TAG': '*',\n        'TGC': 'C', 'TGT': 'C', 'TGA': '*', 'TGG': 'W',\n    }\n    \n    # Mapping of nucleotides to integers as per the problem.\n    BASE_MAP = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    BASES = ['A', 'C', 'G', 'T']\n\n    def find_substitutions(S, p, q, s, e):\n        \"\"\"\n        Analyzes a single DNA sequence configuration.\n        \"\"\"\n        valid_substitutions = []\n        n = len(S)\n\n        for i in range(s, e):\n            # 1. Identify codons in both frames containing position i\n            # Primary frame codon start\n            k_p = i - (i - p) % 3\n            # Overlapping frame codon start\n            k_q = i - (i - q) % 3\n\n            # 2. Validate codon existence entirely within [s, e)\n            if not (s <= k_p and k_p + 2 < e):\n                continue\n            if not (s <= k_q and k_q + 2 < e):\n                continue\n\n            # 3. Extract original codons and check for initial stop codons\n            codon_p_str = S[k_p : k_p + 3]\n            codon_q_str = S[k_q : k_q + 3]\n\n            orig_aa_p = GENETIC_CODE.get(codon_p_str)\n            orig_aa_q = GENETIC_CODE.get(codon_q_str)\n\n            if orig_aa_p == '*' or orig_aa_q == '*':\n                continue\n\n            # 4. Iterate through all possible single-nucleotide substitutions at i\n            original_base = S[i]\n            \n            for new_base in BASES:\n                if new_base == original_base:\n                    continue\n\n                # Create mutated sequence as a list of characters for modification\n                mut_s_list = list(S)\n                mut_s_list[i] = new_base\n                \n                # Construct mutated codons\n                mut_codon_p_str = \"\".join(mut_s_list[k_p : k_p + 3])\n                mut_codon_q_str = \"\".join(mut_s_list[k_q : k_q + 3])\n                \n                # Translate mutated codons\n                mut_aa_p = GENETIC_CODE.get(mut_codon_p_str)\n                mut_aa_q = GENETIC_CODE.get(mut_codon_q_str)\n                \n                # 5. Check constraints\n                # Synonymous in primary frame\n                is_synonymous_p = (mut_aa_p == orig_aa_p)\n                # Synonymous (and not a stop) in overlapping frame\n                is_synonymous_q = (mut_aa_q == orig_aa_q)\n\n                if is_synonymous_p and is_synonymous_q:\n                    # Encode and store the valid substitution\n                    i_prime = i - s\n                    encoded_b = BASE_MAP[original_base]\n                    encoded_b_prime = BASE_MAP[new_base]\n                    valid_substitutions.append([i_prime, encoded_b, encoded_b_prime])\n        \n        # 6. Sort the results as required\n        valid_substitutions.sort(key=lambda x: (x[0], x[2]))\n        \n        return valid_substitutions\n\n    # Test cases from the problem statement\n    test_cases = [\n        (\"GGTTATGGTTAT\", 0, 2, 0, 12),\n        (\"GGTGGTGGTGGTGGTGGT\", 0, 1, 0, 18),\n        (\"GGTTATGGT\", 0, 2, 1, 8),\n        (\"GGTGAT\", 0, 2, 0, 6),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        S, p, q, s, e = case\n        result = find_substitutions(S, p, q, s, e)\n        all_results.append(result)\n\n    def format_list_compact(l):\n        \"\"\"Recursively formats lists and nested lists into a compact string.\"\"\"\n        if not isinstance(l, list):\n            return str(l)\n        return \"[\" + \",\".join(format_list_compact(item) for item in l) + \"]\"\n\n    # Final print statement in the exact required format.\n    print(format_list_compact(all_results))\n\nsolve()\n```"}]}