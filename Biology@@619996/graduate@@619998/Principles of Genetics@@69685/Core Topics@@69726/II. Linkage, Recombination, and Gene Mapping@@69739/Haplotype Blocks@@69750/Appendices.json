{"hands_on_practices": [{"introduction": "We begin with a foundational method for identifying historical recombination events from population data. The four-gamete test provides a simple but powerful rule to infer that a recombination must have occurred between two genetic markers under the infinite-sites model. This exercise gives you direct practice in applying this test to a small set of phased haplotypes, building an intuitive understanding of how recombination breaks down allelic associations along a chromosome. [@problem_id:2820834]", "problem": "A genomic region contains $4$ ordered single-nucleotide polymorphisms (SNPs), denoted $S_1, S_2, S_3, S_4$. Under the infinite-sites model with no recurrent mutation, no gene conversion, and random mating, you have phased haplotypes for $6$ sampled chromosomes across these SNPs, with alleles encoded as $0$ and $1$ in the order $(S_1,S_2,S_3,S_4)$:\n- $H_1 = (0,0,0,0)$\n- $H_2 = (0,1,0,0)$\n- $H_3 = (1,0,0,0)$\n- $H_4 = (1,1,0,0)$\n- $H_5 = (0,0,1,0)$\n- $H_6 = (0,1,1,1)$\n\nApply the four-gamete test to each adjacent SNP pair $(S_1,S_2)$, $(S_2,S_3)$, and $(S_3,S_4)$. A recombination breakpoint is defined here as the presence of at least one historical recombination event in the inter-SNP interval between adjacent markers. Identify the minimal set of inter-SNP intervals that must contain recombination breakpoints to be consistent with the observed phased haplotypes under the model assumptions.\n\nReport only the minimal number of distinct recombination breakpoints between adjacent SNPs. Provide the number only. No rounding is necessary.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It is based on fundamental principles of population genetics, specifically the infinite-sites model and the four-gamete test for detecting recombination. All necessary data and definitions are provided, and the problem is free of ambiguity or contradiction. It is a valid and solvable problem.\n\nThe core principle to be applied is the four-gamete test. Under the infinite-sites model, where each mutation arises at a unique position on the chromosome and never reverts, the genealogical history of a set of non-recombining sequences can be represented by a single perfect phylogeny (a tree). For any two biallelic single-nucleotide polymorphisms (SNPs), with alleles denoted as $0$ and $1$, there are four possible two-site haplotypes (gametes): $(0,0)$, $(0,1)$, $(1,0)$, and $(1,1)$. If there has been no recombination between the two SNP loci, only three of these four gametes can be present in a sample. The appearance of the fourth gamete can only be explained by a historical recombination event that brought together alleles from different ancestral backgrounds. Therefore, the observation of all four gametes between two sites is sufficient evidence to infer at least one recombination event in the interval separating them.\n\nWe are given $4$ ordered SNPs, $S_1, S_2, S_3, S_4$, and $6$ phased haplotypes:\n$H_1 = (0,0,0,0)$\n$H_2 = (0,1,0,0)$\n$H_3 = (1,0,0,0)$\n$H_4 = (1,1,0,0)$\n$H_5 = (0,0,1,0)$\n$H_6 = (0,1,1,1)$\n\nWe will apply the four-gamete test to each of the $3$ adjacent inter-SNP intervals.\n\n1.  Interval between $S_1$ and $S_2$:\n    We extract the two-site haplotypes for the pair $(S_1, S_2)$ from the $6$ given full haplotypes:\n    - From $H_1$: $(0,0)$\n    - From $H_2$: $(0,1)$\n    - From $H_3$: $(1,0)$\n    - From $H_4$: $(1,1)$\n    - From $H_5$: $(0,0)$\n    - From $H_6$: $(0,1)$\n    The set of unique two-site haplotypes observed is $\\{(0,0), (0,1), (1,0), (1,1)\\}$. Since all four possible gametes are present, we must conclude that at least one historical recombination event has occurred in the interval between $S_1$ and $S_2$. This interval must contain a recombination breakpoint.\n\n2.  Interval between $S_2$ and $S_3$:\n    We extract the two-site haplotypes for the pair $(S_2, S_3)$:\n    - From $H_1$: $(0,0)$\n    - From $H_2$: $(1,0)$\n    - From $H_3$: $(0,0)$\n    - From $H_4$: $(1,0)$\n    - From $H_5$: $(0,1)$\n    - From $H_6$: $(1,1)$\n    The set of unique two-site haplotypes observed is $\\{(0,0), (1,0), (0,1), (1,1)\\}$. Again, all four possible gametes are present. Therefore, we must infer that at least one recombination event has occurred in the interval between $S_2$ and $S_3$. This interval must also contain a recombination breakpoint.\n\n3.  Interval between $S_3$ and $S_4$:\n    We extract the two-site haplotypes for the pair $(S_3, S_4)$:\n    - From $H_1$: $(0,0)$\n    - From $H_2$: $(0,0)$\n    - From $H_3$: $(0,0)$\n    - From $H_4$: $(0,0)$\n    - From $H_5$: $(1,0)$\n    - From $H_6$: $(1,1)$\n    The set of unique two-site haplotypes observed is $\\{(0,0), (1,0), (1,1)\\}$. In this case, only three of the four possible gametes are present. The gamete $(0,1)$ is not observed in the sample. The absence of the fourth gamete means that the data are consistent with a history of no recombination between loci $S_3$ and $S_4$. Therefore, the four-gamete test does not provide evidence for, and does not require, a recombination breakpoint in this interval.\n\nBased on this systematic analysis, the minimal set of inter-SNP intervals that must contain recombination breakpoints to be consistent with the data comprises the interval between $S_1$ and $S_2$, and the interval between $S_2$ and $S_3$.\n\nThe minimal number of distinct recombination breakpoints between adjacent SNPs is therefore $2$.", "answer": "$$\\boxed{2}$$", "id": "2820834"}, {"introduction": "While the four-gamete test is a cornerstone of population genetics, its conclusions depend critically on its underlying assumptions, such as the infinite-sites mutation model. This thought experiment challenges you to probe the limits of the test by violating this assumption and allowing for recurrent mutation. By constructing a counterexample genealogy where four gametes arise without recombination, you will develop a more nuanced understanding of the complexities inherent in genetic inference. [@problem_id:2820883]", "problem": "A haplotype block is a genomic segment in which historical recombination is sufficiently rare that long-range correlations of alleles are observed. The classic four-gamete test states that, under the infinite-sites mutation model without recurrent mutation and in the absence of genotyping error, observing all four haplotypes for a pair of biallelic sites implies at least one historical recombination. However, with recurrent mutation permitted (finite-sites model), the same observation can arise without any recombination.\n\nConsider two tightly linked biallelic single-nucleotide polymorphisms (SNPs) $X \\in \\{X,x\\}$ and $Y \\in \\{Y,y\\}$ within a haplotype block. You sample $4$ chromosomes and observe all four gametes $\\{XY, Xy, xY, xy\\}$.\n\n1) Construct explicitly a recombination-free mutational history on a rooted binary genealogy of the $4$ sampled chromosomes that yields the observed $\\{XY, Xy, xY, xy\\}$ haplotypes. Your construction must:\n- Specify a binary tree topology on labeled leaves $\\{1,2,3,4\\}$.\n- Place directed point mutations $X \\to x$ and $Y \\to y$ on named branches so that the leaves carry $\\{XY, Xy, xY, xy\\}$ in some order, with no recombination events anywhere on the tree.\n\n2) Now suppose you plan to genotype $k$ additional SNPs inside the same haplotype block to resolve whether the four-gamete pattern between $X$ and $Y$ arose from recombination or from recurrent mutation. Assume the following experimental model:\n- Under the “true recombination” world (at least one historical crossover between $X$ and $Y$ in the ancestry of the sample), each additional SNP independently has probability $p$ (with $0<p<1$) of exhibiting a pairwise four-gamete incompatibility with at least one of $X$ or $Y$ (for example, because it lies on the opposite side of a breakpoint), and probability $1-p$ of being uninformative with respect to this criterion.\n- Under the “no recombination, recurrent mutation only at $X$ and/or $Y$” world, the additional SNPs obey the infinite-sites model on a single genealogy and therefore cannot by themselves create new pairwise four-gamete incompatibilities with $X$ or $Y$.\n\nYou will declare the ambiguity resolved the first time any additional SNP shows a pairwise four-gamete incompatibility with at least one of $X$ or $Y$. Given a tolerable risk level $\\varepsilon$ with $0<\\varepsilon<1$ of failing to resolve the ambiguity if recombination truly occurred, derive a closed-form expression for the minimal integer number of additional SNPs $k_{\\min}$ you must genotype so that the probability of remaining unresolved is at most $\\varepsilon$. Your final answer must be a single closed-form analytic expression in terms of $p$ and $\\varepsilon$. Do not substitute numerical values. Do not include any units. Do not round.", "solution": "The problem statement is valid. It is scientifically grounded in the principles of population genetics, specifically concerning the interpretation of haplotype data using the four-gamete test under different mutational models (infinite-sites vs. finite-sites). The problem is well-posed, providing a clear objective and all necessary parameters for both the constructive proof in the first part and the probabilistic derivation in the second part. There are no internal contradictions, factual errors, or ambiguities. We shall proceed to the solution.\n\nThe problem is divided into two parts. First, we must construct a mutational history on a single genealogy that produces all four gametic types, $\\{XY, Xy, xY, xy\\}$, without recombination. This demonstrates how recurrent mutation can mimic the signal of recombination under the four-gamete test. Second, we must derive the minimum number of additional genetic markers required to resolve this ambiguity with a given statistical confidence.\n\nFor the first part, we construct the recombination-free history. Let the four sampled chromosomes be denoted by the labels $\\{1, 2, 3, 4\\}$. We must specify a rooted binary tree topology and place mutations on its branches. A valid construction requires at least one recurrent mutation.\n\nConsider a symmetric rooted binary tree with the topology $((1,2),(3,4))$. Let the root of the tree, representing the most recent common ancestor of the four samples, have the ancestral haplotype $XY$. The tree has two main clades descending from the root.\n\n$1$. Let the mutation $X \\to x$ occur on the branch leading to the common ancestor of samples $3$ and $4$. The haplotype along this entire lineage is now $xY$. The other main lineage, leading to the ancestor of samples $1$ and $2$, retains the ancestral haplotype $XY$.\n\n$2$. Now consider the mutations at locus $Y$. To generate all four haplotypes, the mutation $Y \\to y$ must occur twice, independently, which is a case of recurrent mutation.\n   - On the branch leading directly to sample $2$ from the common ancestor of $\\{1,2\\}$, a mutation $Y \\to y$ occurs. The ancestral haplotype $XY$ of this minor clade is thus changed to $Xy$ for sample $2$. Sample $1$ inherits the haplotype $XY$ without further mutation.\n   - On the branch leading directly to sample $4$ from the common ancestor of $\\{3,4\\}$, a second, independent mutation $Y \\to y$ occurs. The ancestral haplotype $xY$ of this minor clade is thus changed to $xy$ for sample $4$. Sample $3$ inherits the haplotype $xY$ without further mutation.\n\nThe resulting haplotypes at the leaves of the tree are:\n- Sample $1$: $XY$\n- Sample $2$: $Xy$\n- Sample $3$: $xY$\n- Sample $4$: $xy$\n\nThis construction successfully produces all four gametes on a single genealogical tree with no recombination. It relies on one mutation $X \\to x$ and two recurrent mutations $Y \\to y$. The condition of the first part is satisfied.\n\nFor the second part, we derive the minimal number of additional SNPs, $k_{\\min}$, needed to resolve the ambiguity. The problem states a probabilistic framework under the assumption that the \"true recombination\" world holds.\n\nLet $k$ be the number of additional SNPs genotyped. For each SNP $i \\in \\{1, \\dots, k\\}$, let $E_i$ be the event that this SNP reveals a four-gamete incompatibility with either $X$ or $Y$. According to the problem, these events are independent, and the probability of any such event is $P(E_i) = p$.\n\nThe ambiguity between recombination and recurrent mutation is considered unresolved only if *none* of the $k$ additional SNPs are informative. Let $U$ be the event that the state remains unresolved after genotyping $k$ SNPs. This corresponds to the joint occurrence of the complementary events $E_i^c$ for all $i=1, \\dots, k$, where $E_i^c$ is the event that SNP $i$ is uninformative.\n\nThe probability of a single SNP being uninformative is $P(E_i^c) = 1 - P(E_i) = 1-p$.\n\nSince the events are independent, the probability of remaining unresolved is the product of the individual probabilities:\n$$P(U) = P(E_1^c \\cap E_2^c \\cap \\dots \\cap E_k^c) = \\prod_{i=1}^{k} P(E_i^c) = (1-p)^k$$\n\nThe problem imposes a constraint on this probability: the risk of failing to resolve the ambiguity, given that recombination is the true cause, must be no more than $\\varepsilon$. This translates to the inequality:\n$$P(U) \\le \\varepsilon$$\n$$(1-p)^k \\le \\varepsilon$$\n\nWe must find the minimal integer $k$ that satisfies this condition. To solve for $k$, we take the natural logarithm of both sides. Since $0 < p < 1$ and $0 < \\varepsilon < 1$, both $1-p$ and $\\varepsilon$ are between $0$ and $1$. Consequently, their natural logarithms, $\\ln(1-p)$ and $\\ln(\\varepsilon)$, are negative.\n\n$$k \\ln(1-p) \\le \\ln(\\varepsilon)$$\n\nWhen we divide by $\\ln(1-p)$, which is a negative quantity, we must reverse the direction of the inequality:\n$$k \\ge \\frac{\\ln(\\varepsilon)}{\\ln(1-p)}$$\n\nThe ratio $\\frac{\\ln(\\varepsilon)}{\\ln(1-p)}$ is positive because it is a ratio of two negative numbers. Since $k$ must be an integer, the minimal integer value for $k$, which we denote $k_{\\min}$, is the smallest integer that is greater than or equal to this ratio. This is given by the ceiling function.\n\nTherefore, the minimal number of additional SNPs to be genotyped is:\n$$k_{\\min} = \\left\\lceil \\frac{\\ln(\\varepsilon)}{\\ln(1-p)} \\right\\rceil$$\nThis is the closed-form analytical expression required.", "answer": "$$\\boxed{\\left\\lceil \\frac{\\ln(\\varepsilon)}{\\ln(1-p)} \\right\\rceil}$$", "id": "2820883"}, {"introduction": "In practice, haplotype blocks are not defined by absolute rules but by statistical thresholds applied to quantitative measures of linkage disequilibrium (LD). This computational exercise moves from qualitative inference to a quantitative framework by focusing on the normalized LD metric, $D'$. You will implement a complete analysis pipeline: calculating a point estimate of $D'$, using the bootstrap to construct a confidence interval that accounts for sampling variation, and applying established criteria to formally define strong LD. [@problem_id:2820833]", "problem": "You are given phased haplotype count data for pairs of biallelic single-nucleotide polymorphisms (SNPs) that reside within a candidate haplotype block. For each SNP pair, you must compute a nonparametric bootstrap confidence interval for the normalized linkage disequilibrium measure $D'$ and then decide whether the pair qualifies as being in strong linkage disequilibrium under the Gabriel criteria. Your program must implement the following, starting from core definitions and widely accepted procedures:\n\n- Consider two biallelic SNPs with alleles $A/a$ and $B/b$. Let the observed phased haplotype counts be the ordered quadruple $\\left[n_{AB}, n_{Ab}, n_{aB}, n_{ab}\\right]$, where each $n_{\\cdot}$ is a nonnegative integer count and the total number of chromosomes is $N = n_{AB} + n_{Ab} + n_{aB} + n_{ab}$. Define the haplotype frequencies as $f_{AB} = n_{AB}/N$, $f_{Ab} = n_{Ab}/N$, $f_{aB} = n_{aB}/N$, and $f_{ab} = n_{ab}/N$, which satisfy $f_{AB} + f_{Ab} + f_{aB} + f_{ab} = 1$.\n- Define the allele frequencies $p_A = f_{AB} + f_{Ab}$ and $p_B = f_{AB} + f_{aB}$. The linkage disequilibrium coefficient is $D = f_{AB} - p_A p_B$.\n- The normalized disequilibrium $D'$ is defined to be the magnitude of $D$ scaled by its theoretical maximum given the observed allele frequencies, namely\n  $$\n  D' = \\begin{cases}\n  \\dfrac{|D|}{\\min\\left(p_A\\left(1-p_B\\right),\\left(1-p_A\\right)p_B\\right)} & \\text{if } D \\ge 0, \\\\\n  \\dfrac{|D|}{\\min\\left(p_A p_B,\\left(1-p_A\\right)\\left(1-p_B\\right)\\right)} & \\text{if } D < 0,\n  \\end{cases}\n  $$\n  with the convention that if the denominator is $0$ then $D'$ is defined to be $0$. By construction $D'$ lies in the closed interval $[0,1]$.\n- To quantify sampling uncertainty, use a nonparametric bootstrap on chromosomes: resample $N$ haplotypes with replacement from the multiset containing each of the four haplotypes repeated according to $\\left[n_{AB}, n_{Ab}, n_{aB}, n_{ab}\\right]$, recompute $D'$ on the resampled data, and repeat this procedure for $R$ bootstrap replicates to obtain a bootstrap sample $\\{D'_1, D'_2, \\dots, D'_R\\}$. Use the percentile method to form a two-sided confidence interval with nominal coverage $1-\\alpha$ by taking the lower bound as the empirical $\\alpha/2$ quantile and the upper bound as the empirical $1-\\alpha/2$ quantile of the bootstrap sample of $D'$ values.\n- Apply the Gabriel criteria for strong linkage disequilibrium on the resulting interval: a SNP pair is classified as in strong linkage disequilibrium if the upper confidence bound on $D'$ is strictly greater than $0.98$ and the lower confidence bound on $D'$ is strictly greater than $0.7$.\n\nImplementation rules and required constants:\n- Use a fixed pseudo-random number generator seed $s = 1729$ for the bootstrap to ensure deterministic results.\n- Use $R = 5000$ bootstrap replicates and a two-sided nominal coverage of $1-\\alpha = 0.95$ (that is, $\\alpha = 0.05$ so the percentile quantiles are at $0.025$ and $0.975$).\n- Express all reported $D'$ values and confidence bounds as decimals rounded to exactly three digits after the decimal point. Do not use a percentage sign.\n\nTest suite:\n- You must compute results for the following five test cases, each specified by the haplotype count quadruple $\\left[n_{AB}, n_{Ab}, n_{aB}, n_{ab}\\right]$:\n  1. Case $\\mathrm{A}$: $\\left[40, 0, 0, 60\\right]$.\n  2. Case $\\mathrm{B}$: $\\left[35, 5, 5, 55\\right]$.\n  3. Case $\\mathrm{C}$: $\\left[25, 25, 25, 25\\right]$.\n  4. Case $\\mathrm{D}$: $\\left[9, 1, 1, 89\\right]$.\n  5. Case $\\mathrm{E}$: $\\left[49, 1, 1, 49\\right]$.\n\nOutput specification:\n- For each case, compute the point estimate $D'$ from the observed counts, the bootstrap lower and upper bounds at $\\alpha/2 = 0.025$ and $1-\\alpha/2 = 0.975$, and the boolean decision under the Gabriel criteria.\n- Your program should produce a single line of output containing a list of length $5$, where each element corresponds to one case in the order $\\mathrm{A}$ through $\\mathrm{E}$. Each element must itself be a list of the form $\\left[\\text{Dprime}, \\text{Lower}, \\text{Upper}, \\text{Strong}\\right]$ where $\\text{Dprime}$, $\\text{Lower}$, and $\\text{Upper}$ are decimals rounded to exactly three places, and $\\text{Strong}$ is a boolean. For example, a syntactically valid output for two hypothetical cases would look like $\\left[\\left[0.832, 0.701, 0.994, \\mathrm{True}\\right], \\left[0.412, 0.205, 0.673, \\mathrm{False}\\right]\\right]$. Your program must output exactly one such line with the results for all five specified cases in the order given.", "solution": "The problem presented requires the implementation of a statistical procedure to assess linkage disequilibrium (LD) between pairs of single-nucleotide polymorphisms (SNPs). The problem is scientifically valid, well-posed, and provides all necessary definitions and parameters for a unique, reproducible solution. The methods described—calculation of the normalized linkage disequilibrium coefficient $D'$, the use of nonparametric bootstrapping to estimate confidence intervals, and the application of the Gabriel criteria—are standard and well-established in the field of population genetics. I will proceed with a rigorous solution.\n\nThe solution is structured as follows. First, we define a function to compute the point estimate of the normalized linkage disequilibrium, $D'$, from a given set of four haplotype counts. Second, we implement the nonparametric bootstrap procedure to generate an empirical distribution of $D'$ values. Third, we use this distribution to construct a percentile-based confidence interval. Finally, we apply the specified Gabriel criteria to this interval to make a determination of strong LD. This entire process is then applied to each of the five test cases provided.\n\n**1. Mathematical Formulation**\n\nLet the observed phased haplotype counts for two biallelic loci with alleles ($A/a$, $B/b$) be given by the vector $\\mathbf{n} = [n_{AB}, n_{Ab}, n_{aB}, n_{ab}]$. The total number of chromosomes sampled is $N = \\sum_i n_i = n_{AB} + n_{Ab} + n_{aB} + n_{ab}$.\n\nThe frequencies of the four haplotypes are estimated as:\n$$\nf_{AB} = \\frac{n_{AB}}{N}, \\quad f_{Ab} = \\frac{n_{Ab}}{N}, \\quad f_{aB} = \\frac{n_{aB}}{N}, \\quad f_{ab} = \\frac{n_{ab}}{N}\n$$\nFrom these, the allele frequencies for allele $A$ at the first locus and allele $B$ at the second locus are:\n$$\np_A = f_{AB} + f_{Ab}\n$$\n$$\np_B = f_{AB} + f_{aB}\n$$\nThe linkage disequilibrium coefficient, $D$, measures the deviation of the observed haplotype frequency $f_{AB}$ from the frequency expected under linkage equilibrium, $p_A p_B$:\n$$\nD = f_{AB} - p_A p_B\n$$\nThe value of $D$ is constrained by the allele frequencies. To create a standardized measure, $D$ is normalized by its maximum possible absolute value, $D_{max}$, yielding $D'$. The value of $D_{max}$ depends on the sign of $D$:\n$$\nD_{max} = \\begin{cases}\n\\min(p_A(1-p_B), (1-p_A)p_B) & \\text{if } D \\ge 0, \\\\\n\\min(p_A p_B, (1-p_A)(1-p_B)) & \\text{if } D < 0.\n\\end{cases}\n$$\nThe normalized linkage disequilibrium, $D'$, is then defined as:\n$$\nD' = \\frac{|D|}{D_{max}}\n$$\nBy convention, if $D_{max} = 0$, then $D'$ is defined as $0$. By construction, $D' \\in [0, 1]$.\n\n**2. Algorithmic Implementation of the Statistical Analysis**\n\nA primary function, which we may call `compute_d_prime`, is designed to execute these calculations. For robustness and efficiency, this function is implemented using `NumPy` to support vectorized operations, allowing it to process a batch of haplotype count vectors simultaneously. This is particularly advantageous for the bootstrap procedure.\n\n**2.1. Point Estimate Calculation**\nFor each test case, we first compute the point estimate of $D'$ directly from the provided haplotype counts $[n_{AB}, n_{Ab}, n_{aB}, n_{ab}]$ using the `compute_d_prime` function.\n\n**2.2. Nonparametric Bootstrap**\nTo quantify the uncertainty in the point estimate of $D'$, we employ a nonparametric bootstrap. The procedure is as follows:\n- The set of $N$ observed chromosomes is treated as an empirical distribution. The probability of drawing each haplotype is given by its observed frequency, $\\mathbf{p} = [f_{AB}, f_{Ab}, f_{aB}, f_{ab}]$.\n- A bootstrap sample is generated by drawing $N$ chromosomes with replacement from this empirical distribution. This is computationally equivalent to drawing one sample of size $N$ from a multinomial distribution with parameters $N$ and probability vector $\\mathbf{p}$.\n- For each bootstrap sample of counts, we recompute the $D'$ value.\n- This process is repeated $R = 5000$ times, yielding a bootstrap distribution of $D'$ values: $\\{D'_1, D'_2, \\dots, D'_R\\}$.\n- To ensure reproducibility, the pseudo-random number generator is seeded with the specified value $s = 1729$.\n\nThe generation of all $R$ bootstrap samples is performed in a single, efficient operation using `numpy.random.default_rng().multinomial(N, p, size=R)`. The subsequent calculation of $D'$ for all $R$ replicates is then performed in a fully vectorized manner.\n\n**2.3. Confidence Interval Construction**\nThe percentile method is used to construct the $1 - \\alpha = 0.95$ confidence interval for $D'$. The lower and upper bounds of the confidence interval are the empirical $\\alpha/2 = 0.025$ and $1 - \\alpha/2 = 0.975$ quantiles of the sorted bootstrap distribution of $D'$ values. These are computed efficiently using `numpy.quantile`.\n\n**2.4. Gabriel Criteria for Strong Linkage Disequilibrium**\nFinally, the computed confidence interval, $[L, U]$, is evaluated against the Gabriel criteria. A SNP pair is classified as being in strong LD if both of the following conditions are met:\n- The lower confidence bound $L > 0.7$.\n- The upper confidence bound $U > 0.98$.\nThis results in a boolean decision (`True` or `False`).\n\n**3. Output Generation**\nThe final output is constructed by iterating through the five test cases. For each case, the point estimate of $D'$, the lower and upper confidence bounds, and the boolean strong LD decision are calculated. These four values are formatted into a list, where the floating-point numbers are represented as strings rounded to exactly three decimal places. The lists for all five cases are then aggregated into a single list, which is printed as a continuous line of text, strictly adhering to the specified format. The use of formatted strings (f-strings in Python) ensures the precise representation of the numerical results.", "answer": "```python\nimport numpy as np\n\ndef compute_d_prime(counts: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the normalized linkage disequilibrium D' in a vectorized manner.\n\n    Args:\n        counts: An ndarray of shape (k, 4) or (4,) containing haplotype counts\n                [n_AB, n_Ab, n_aB, n_ab].\n\n    Returns:\n        A scalar or an ndarray of shape (k,) with the D' values.\n    \"\"\"\n    is_scalar = counts.ndim == 1\n    if is_scalar:\n        counts = counts.reshape(1, 4)\n\n    # Initialize result array\n    d_prime_results = np.zeros(counts.shape[0])\n\n    # Calculate total counts and identify valid rows (N > 0)\n    total_counts = np.sum(counts, axis=1, keepdims=True)\n    valid_mask = (total_counts > 0).flatten()\n\n    if not np.any(valid_mask):\n        return d_prime_results[0] if is_scalar else d_prime_results\n    \n    # Perform calculations only on rows with data\n    valid_counts = counts[valid_mask]\n    valid_N = total_counts[valid_mask]\n    \n    freqs = valid_counts / valid_N\n    \n    p_A = freqs[:, 0] + freqs[:, 1]\n    p_B = freqs[:, 0] + freqs[:, 2]\n    \n    D = freqs[:, 0] - p_A * p_B\n    \n    # Calculate D_max based on the sign of D\n    d_max_pos = np.minimum(p_A * (1 - p_B), (1 - p_A) * p_B)\n    d_max_neg = np.minimum(p_A * p_B, (1 - p_A) * (1 - p_B))\n    d_max = np.where(D >= 0, d_max_pos, d_max_neg)\n\n    # Calculate D' avoiding division by zero\n    valid_d_primes = np.zeros_like(D)\n    # Use a small tolerance for floating point comparison to zero\n    nonzero_d_max_mask = d_max > 1e-12\n    valid_d_primes[nonzero_d_max_mask] = np.abs(D[nonzero_d_max_mask]) / d_max[nonzero_d_max_mask]\n    \n    d_prime_results[valid_mask] = valid_d_primes\n    \n    return d_prime_results[0] if is_scalar else d_prime_results\n\ndef process_case(counts: np.ndarray, R: int, alpha: float, rng: np.random.Generator) -> str:\n    \"\"\"\n    Processes a single case: computes D', bootstrap CI, and Gabriel criteria.\n\n    Args:\n        counts: A 1D numpy array of 4 haplotype counts.\n        R: Number of bootstrap replicates.\n        alpha: Significance level for the confidence interval.\n        rng: A numpy random number generator instance.\n\n    Returns:\n        A formatted string representing the results for the case.\n    \"\"\"\n    # 1. Point estimate of D'\n    point_d_prime = compute_d_prime(counts)\n    \n    # 2. Bootstrap procedure\n    N = np.sum(counts)\n    if N == 0:\n        return f\"[{0.0:.3f}, {0.0:.3f}, {0.0:.3f}, False]\"\n\n    haplotype_probs = counts / N\n    \n    # Generate R bootstrap samples of counts\n    bootstrap_counts = rng.multinomial(N, haplotype_probs, size=R)\n    \n    # 3. Calculate D' for all bootstrap replicates\n    bootstrap_d_primes = compute_d_prime(bootstrap_counts)\n    \n    # 4. Construct percentile confidence interval\n    lower_quantile = alpha / 2\n    upper_quantile = 1 - alpha / 2\n    lower_bound, upper_bound = np.quantile(bootstrap_d_primes, [lower_quantile, upper_quantile])\n\n    # 5. Apply Gabriel criteria\n    is_strong_ld = (lower_bound > 0.7) and (upper_bound > 0.98)\n    \n    # 6. Format output string\n    return f\"[{point_d_prime:.3f}, {lower_bound:.3f}, {upper_bound:.3f}, {is_strong_ld}]\"\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the final output.\n    \"\"\"\n    # Define problem constants and test cases\n    SEED = 1729\n    R_REPLICATES = 5000\n    ALPHA = 0.05\n    test_cases = [\n        np.array([40, 0, 0, 60]),   # Case A\n        np.array([35, 5, 5, 55]),   # Case B\n        np.array([25, 25, 25, 25]), # Case C\n        np.array([9, 1, 1, 89]),    # Case D\n        np.array([49, 1, 1, 49]),   # Case E\n    ]\n    \n    # Initialize the random number generator\n    rng = np.random.default_rng(seed=SEED)\n\n    results_as_strings = []\n    for counts in test_cases:\n        result_str = process_case(counts, R_REPLICATES, ALPHA, rng)\n        results_as_strings.append(result_str)\n        \n    # Print the final output in the specified single-line format\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2820833"}]}