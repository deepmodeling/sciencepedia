{"hands_on_practices": [{"introduction": "Optimal foraging theory provides a powerful framework for understanding the economic decisions animals make to maximize fitness-related currencies like energy intake. A core skill for a behavioral ecologist is the ability to derive predictive models from first principles. This practice challenges you to do just that by deriving the Marginal Value Theorem (MVT), a foundational concept that predicts how long a forager should stay in a depleting resource patch [@problem_id:2778870]. By working through the calculus, you will gain a deeper appreciation for how ultimate-level optimization shapes observable behavioral rules.", "problem": "A central question in behavioral ecology is how natural selection shapes decision rules that maximize fitness-related currencies. Consider a forager encountering identical resource patches where cumulative energetic gain as a function of time in a patch is given by a gain function $G(t)$ with $G(0)=0$, $G'(t)>0$, and $G''(t)<0$ for all $t>0$. Between patches, the forager incurs a fixed travel time $T \\ge 0$. Assume that Darwinian fitness over the relevant ecological time scale increases monotonically with the long-term average rate of energetic intake, and that the environment is stationary and ergodic so that time averages equal ensemble averages over repeated patch cycles.\n\n- Starting from first principles and the definition of long-term average rate as total energetic gain divided by total time over repeated patch cycles, derive the necessary optimality condition for the patch residence time $t^{*}$ that maximizes the long-term average rate. Your derivation must not invoke any pre-stated foraging rules. State clearly any regularity conditions you require on $G(t)$ to justify optimality.\n\n- Then, for a specific gain function of the form $G(t) = a \\left(1 - \\exp(-b t)\\right)$ with parameters $a>0$ and $b>0$ and fixed travel time $T \\ge 0$, compute an explicit closed-form expression for the optimal residence time $t^{*}$ in terms of $a$, $b$, and $T$. You may use special functions if needed, but you must clearly identify the branch that yields a biologically admissible solution $t^{*} \\ge 0$.\n\nExpress the final $t^{*}$ as a single analytic expression. No numerical approximation or rounding is required. Express time in the same units used for $t$ and $T$.", "solution": "The problem is first critically validated.\n\nGivens:\n$1$. The energetic gain function in a patch is $G(t)$, where $t$ is time spent in the patch.\n$2$. Properties of the gain function: $G(0)=0$; $G'(t) > 0$ for $t > 0$; $G''(t) < 0$ for $t > 0$.\n$3$. A fixed travel time $T \\ge 0$ exists between patches.\n$4$. The objective is to maximize the long-term average rate of energetic intake.\n$5$. Fitness is a monotonically increasing function of this rate.\n$6$. The environment is stationary and ergodic.\n$7. a.$ First task: derive the necessary optimality condition for the patch residence time $t^*$.\n$7. b.$ Second task: for $G(t) = a(1 - \\exp(-bt))$ with $a > 0$ and $b > 0$, compute a closed-form expression for $t^*$.\n\nValidation:\nThe problem is scientifically grounded, being a canonical formulation of the marginal value theorem in optimal foraging theory, a fundamental concept in behavioral ecology. The assumptions on $G(t)$ (monotonic increase with diminishing returns) are standard and represent a realistic scenario of resource depletion. The problem is well-posed, with a clearly defined objective function to be maximized under specified constraints. The language is objective and mathematically precise. The setup is self-contained and free of contradictions. The specific functional form for $G(t)$ is a standard saturating function widely used in biological modeling. The problem is non-trivial and requires a rigorous application of calculus and understanding of special functions.\n\nVerdict: The problem is valid.\n\nWe proceed with the solution.\n\nPart 1: Derivation of the general optimality condition.\n\nLet $t$ be the time spent foraging in a single patch, which we term the patch residence time. The total energetic gain from this patch is $G(t)$. The time elapsed for a complete foraging cycle (travel to a patch and foraging within it) is $T + t$. Given the stationary and ergodic nature of the environment, the long-term average rate of energetic intake, denoted by $R(t)$, can be expressed as the gain from a single cycle divided by the duration of that cycle:\n$$ R(t) = \\frac{G(t)}{T + t} $$\nOur objective is to find the patch residence time $t = t^*$ that maximizes this rate $R(t)$ for $t \\ge 0$. To find the extremum, we compute the derivative of $R(t)$ with respect to $t$ and set it to zero. Using the quotient rule for differentiation:\n$$ \\frac{dR}{dt} = \\frac{G'(t)(T + t) - G(t)(1)}{(T + t)^2} $$\nSetting $\\frac{dR}{dt} = 0$ requires the numerator to be zero (for $T+t > 0$):\n$$ G'(t)(T + t) - G(t) = 0 $$\nRearranging this equation gives the necessary condition for optimality at $t=t^*$:\n$$ G'(t^*) = \\frac{G(t^*)}{T + t^*} $$\nThis equation states that the optimal strategy is to leave the patch when the instantaneous rate of gain, $G'(t^*)$, equals the long-term average rate of gain, $R(t^*) = \\frac{G(t^*)}{T + t^*}$. This is the marginal value theorem.\n\nTo ensure this condition corresponds to a maximum, we must check the second derivative, $\\frac{d^2R}{dt^2}$, at $t=t^*$. A sufficient condition for a maximum is $\\frac{d^2R}{dt^2}|_{t=t^*} < 0$. Let $N(t) = G'(t)(T+t) - G(t)$. The first derivative is $R'(t) = N(t) / (T+t)^2$. The second derivative is:\n$$ R''(t) = \\frac{N'(t)(T+t)^2 - N(t) \\cdot 2(T+t)}{ (T+t)^4 } = \\frac{N'(t)(T+t) - 2N(t)}{ (T+t)^3 } $$\nAt the optimum $t^*$, $N(t^*) = 0$, so the expression simplifies to:\n$$ R''(t^*) = \\frac{N'(t^*)}{(T+t^*)^2} $$\nWe require $N'(t^*) < 0$. Let us compute $N'(t)$:\n$$ N'(t) = \\frac{d}{dt} \\left[ G'(t)(T+t) - G(t) \\right] = [G''(t)(T+t) + G'(t)(1)] - G'(t) = G''(t)(T+t) $$\nThe problem states that $G''(t) < 0$ for $t > 0$. Since $T \\ge 0$ and we are interested in non-trivial solutions where $t^* > 0$, the term $T+t^*$ is strictly positive. Therefore, $N'(t^*) = G''(t^*)(T+t^*) < 0$. This confirms that $R''(t^*) < 0$, and thus the condition $G'(t^*) = \\frac{G(t^*)}{T + t^*}$ yields a local maximum. The concavity of $G(t)$ ensures this is the unique global maximum for $t>0$. The required regularity condition is precisely the given one: $G''(t) < 0$.\n\nPart 2: Solution for the specific gain function.\n\nWe are given the gain function $G(t) = a(1 - \\exp(-bt))$, with parameters $a > 0$ and $b > 0$. The derivative is $G'(t) = ab\\exp(-bt)$. Both $G'(t)>0$ and $G''(t) = -ab^2\\exp(-bt)<0$ are satisfied. We substitute these into the optimality condition:\n$$ ab\\exp(-bt^*) = \\frac{a(1 - \\exp(-bt^*))}{T + t^*} $$\nThe parameter $a > 0$ cancels from both sides:\n$$ b\\exp(-bt^*) (T + t^*) = 1 - \\exp(-bt^*) $$\nWe rearrange the terms to solve for $t^*$:\n$$ bT\\exp(-bt^*) + bt^*\\exp(-bt^*) = 1 - \\exp(-bt^*) $$\n$$ (bT + 1 + bt^*)\\exp(-bt^*) = 1 $$\n$$ bT + 1 + bt^* = \\exp(bt^*) $$\nThis is a transcendental equation. To solve it, we use the Lambert W function, which is defined as the solution $W(z)$ to the equation $z = W(z)\\exp(W(z))$. We must rearrange our equation into this form. Let $u = bt^*$. The equation becomes $bT + 1 + u = \\exp(u)$.\nLet $X = -(bT + 1 + u)$. Then $u = -X - (bT+1)$. Substituting this into the equation:\n$$ -X = \\exp(-X - (bT+1)) $$\n$$ -X = \\exp(-X) \\exp(-(bT+1)) $$\n$$ X \\exp(X) = -\\exp(-(bT+1)) $$\nThis is of the form $W(z)\\exp(W(z)) = z$ with $z = -\\exp(-(bT+1))$. Thus, the solution for $X$ is $X = W(-\\exp(-(bT+1)))$.\nSubstituting back $X = -(bT+1+u)$:\n$$ u = -X - (bT+1) = -W(-\\exp(-(bT+1))) - (bT+1) $$\nAnd since $u = bt^*$, the solution for $t^*$ is:\n$$ t^* = \\frac{1}{b} \\left( -W(-\\exp(-(bT+1))) - (bT+1) \\right) $$\nThe argument of the Lambert W function, $z = -\\exp(-(bT+1))$, lies in the interval $[-\\exp(-1), 0)$ since $b > 0$ and $T \\ge 0$. In this interval, the Lambert W function has two real branches: the principal branch, $W_0(z)$, where $W_0(z) \\in [-1, 0)$, and the lower branch, $W_{-1}(z)$, where $W_{-1}(z) \\le -1$.\n\nWe must select the branch that yields a biologically admissible solution, i.e., $t^* \\ge 0$.\nThe solution corresponding to the principal branch $W_0$ is:\n$$ t_0^* = \\frac{1}{b} \\left( -W_0(-\\exp(-(bT+1))) - (bT+1) \\right) $$\nSince $-1 \\le W_0(z) < 0$, we have $0 < -W_0(z) \\le 1$. Since $bT+1 \\ge 1$, the term in the parenthesis is $(-W_0(z)) - (bT+1) \\le 1 - 1 = 0$, and is strictly negative for $T>0$. Thus, $t_0^* \\le 0$ (and $t_0^* < 0$ for $T>0$). This solution is not physically meaningful.\n\nThe solution corresponding to the lower branch $W_{-1}$ is:\n$$ t_{-1}^* = \\frac{1}{b} \\left( -W_{-1}(-\\exp(-(bT+1))) - (bT+1) \\right) $$\nFor $z \\in [-\\exp(-1), 0)$, we have $W_{-1}(z) \\le -1$. Therefore, $-W_{-1}(z) \\ge 1$.\nThe term in the parenthesis is $(-W_{-1}(z)) - (bT+1)$. An analysis of the function $h(u) = \\exp(u) - u - (bT+1)$ reveals it has a minimum at $u=0$ with value $h(0) = -bT \\le 0$, and tends to $+\\infty$ as $u \\to \\pm\\infty$. This implies two real roots for $u$ (when $T>0$), one positive and one negative. We have already shown that the $W_0$ branch corresponds to the negative root. Therefore, the $W_{-1}$ branch must provide the unique positive root. Thus, $t_{-1}^* \\ge 0$. This is the correct, biologically admissible solution.\n\nThe explicit closed-form expression for the optimal residence time $t^*$ is given by the $W_{-1}$ branch.", "answer": "$$ \\boxed{ \\frac{1}{b} \\left( -W_{-1}\\left(-\\exp\\left(-bT-1\\right)\\right) - bT - 1 \\right) } $$", "id": "2778870"}, {"introduction": "While optimality models predict what an animal should do, understanding the proximate mechanisms—the 'how' and 'why' at a physiological and molecular level—requires different tools. This exercise shifts our focus to the rigorous design of experiments meant to establish a causal link between a specific gene, a neural circuit, and a complex social behavior [@problem_id:2778896]. You will be tasked with designing a sophisticated gene-editing experiment using CRISPR, learning to navigate the critical challenges of off-target effects and behavioral confounds to cleanly test a hypothesis about proximate causation.", "problem": "You are asked to design a mechanistic test of the hypothesis that the vasopressin receptor gene *Avpr1a* (arginine vasopressin receptor $1$a) causally mediates pair-bond formation in prairie voles via its action in specific neural circuits, using Clustered Regularly Interspaced Short Palindromic Repeats (CRISPR) tools. The design must distinguish proximate causation (mechanisms within the individual) from ultimate causation (evolutionary function and fitness consequences) and must include controls that minimize or reveal off-target editing and non-specific behavioral confounds. You must also specify behavioral assays that test pair-bonding as a specific social attachment rather than general sociability, anxiety, locomotion, or olfactory deficits.\n\nFundamental bases you may assume include: (i) the Central Dogma of molecular biology linking gene sequence to messenger ribonucleic acid (mRNA) to protein, (ii) the definition of proximate causation as immediate physiological, developmental, and neural mechanisms producing behavior within an organism, and ultimate causation as the historical and fitness-related reasons a trait exists, (iii) ligand-receptor principles whereby receptor presence in a neural circuit is necessary for that ligand’s signaling in that circuit, and (iv) well-established behavioral assays in voles for partner preference and social attachment.\n\nWhich experimental design best isolates a proximate causal role of *Avpr1a* in pair-bonding while appropriately controlling for off-target effects and non-specific confounds?\n\nA. Generate global germline *Avpr1a* knockouts by zygotic CRISPR editing using a single guide ribonucleic acid (gRNA), breed to homozygosity, then assess pair-bonding using a partner preference test with a $3$-chamber apparatus after a cohabitation period. Include a Cas$9$-only control line. Confirm editing by Sanger sequencing of the target site and survey off-target effects using a mismatch-sensitive nuclease assay at the top predicted off-target site. Do not perform rescue. Do not include additional behavioral controls beyond the partner preference test, to avoid diluting statistical power.\n\nB. Perform adult, region-specific CRISPR-Cas$9$ edits of *Avpr1a* in the ventral pallidum using adeno-associated virus (AAV) vectors carrying Cas$9$ and one of two independent gRNAs targeting distinct *Avpr1a* exons. Verify spatial transduction and editing efficiency by a fluorescent reporter and deep sequencing of the edited locus in microdissected tissue. Confirm receptor loss with radioligand autoradiography and immunoblotting, and confirm transcriptional impact by quantitative polymerase chain reaction (qPCR). Control off-target effects by (i) including a scrambled gRNA control, (ii) repeating the experiment with the second independent gRNA and requiring convergent behavioral results, (iii) targeted amplicon sequencing of the top $k \\geq 10$ predicted off-target loci, and (iv) rescue in the same region via AAV delivery of a CRISPR-resistant *Avpr1a* complementary deoxyribonucleic acid (cDNA). Conduct blinded behavioral assays including a standardized partner preference test, social novelty preference, open-field locomotion, elevated plus maze for anxiety, and olfactory habituation/dishabituation to social odors. Balance sex, control estrous state, and use littermate controls. Analyze data with pre-registered primary outcomes focused on time huddling with partner versus stranger.\n\nC. Sample wild vole populations and genotype *Avpr1a* microsatellite length polymorphisms. Quantify pair-bonding by the proportion of individuals found in male-female pairs versus solitary states across habitats. Use regression to correlate microsatellite length with pair-bond frequency while controlling for habitat variables. Conclude causation if the correlation is significant at $p  0.05$.\n\nD. Use CRISPR to knock out the oxytocin receptor (*Oxtr*) in adult voles and administer a vasopressin receptor agonist systemically. If pair-bonding declines in *Oxtr* knockouts and is not rescued by agonist, conclude that *Avpr1a* is necessary for pair-bonding. Include an open-field test to rule out locomotor deficits; off-target evaluation is not necessary because pharmacology confirms receptor specificity.\n\nE. Use CRISPR interference (CRISPRi) to reduce *Avpr1a* transcription globally by introducing a catalytically dead Cas$9$ (dCas$9$)-Krüppel-associated box (KRAB) construct with a single gRNA at postnatal day $10$, then test adult pair-bonding after cohabitation. Assess off-targets solely by in silico prediction scores and measure serum vasopressin levels to control for endocrine changes. Include a social interaction assay with a novel conspecific but no additional control assays. No rescue is performed because CRISPRi is assumed reversible.\n\nSelect the option that most rigorously establishes proximate causation of *Avpr1a* for pair-bonding and appropriately addresses off-target and non-specific confounds without conflating ultimate causation.", "solution": "The problem statement asks for the identification of the most rigorous experimental design to test the proximate causal role of the arginine vasopressin receptor $1$a gene, denoted *Avpr1a*, in prairie vole pair-bonding. The design must employ CRISPR-based tools, isolate proximate from ultimate causation, and incorporate comprehensive controls for off-target genetic effects and non-specific behavioral confounds.\n\nFirst, a validation of the problem statement is in order.\n\n**Step 1: Extract Givens**\n- **Hypothesis:** The *Avpr1a* gene causally mediates pair-bond formation in prairie voles via its action in specific neural circuits.\n- **Objective:** Design a mechanistic test of this hypothesis using CRISPR tools.\n- **Constraint 1:** The design must distinguish proximate causation from ultimate causation.\n- **Constraint 2:** The design must include controls to minimize or reveal off-target editing.\n- **Constraint 3:** The design must include controls for non-specific behavioral confounds (e.g., general sociability, anxiety, locomotion, olfactory deficits).\n- **Tool:** Clustered Regularly Interspaced Short Palindromic Repeats (CRISPR).\n- **Assumed Principles:** (i) Central Dogma of molecular biology, (ii) definitions of proximate and ultimate causation, (iii) ligand-receptor principles, and (iv) existence of well-established vole behavioral assays.\n- **Question:** Identify the experimental design that best isolates the proximate causal role of *Avpr1a* for pair-bonding and addresses the specified confounds.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It concerns a classic topic in behavioral neurogenetics—the role of the vasopressin system in social bonding in prairie voles. The specified tools (CRISPR) and concepts (proximate/ultimate causation, experimental controls) are central to modern biological research. The problem is self-contained, with clear objectives and constraints. It asks for an evaluation of experimental methodologies, which is a standard scientific reasoning task. There are no violations of fundamental principles, no ambiguities, and no factual inaccuracies in the premises. The problem setup is valid.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. I will proceed to analyze the proposed experimental designs. A sound design to test for proximate causation must involve a direct, specific, and controlled manipulation of the putative causal element (*Avpr1a* gene product in a specific circuit) and measurement of the specific effect (pair-bonding behavior), while systematically ruling out alternative explanations.\n\n**Option-by-Option Analysis**\n\n**Option A: Generate global germline *Avpr1a* knockouts by zygotic CRISPR editing...**\nThis design proposes a global, constitutive knockout of the *Avpr1a* gene.\n- **Specificity:** The manipulation is global (whole-body) and lifelong (germline). This is a critical flaw. It cannot test the hypothesis that *Avpr1a* acts in *specific neural circuits*. Any observed behavioral phenotype could be the result of developmental compensations or the gene's function in peripheral tissues or other brain regions not involved in pair-bonding.\n- **Controls for Off-Targets:** The use of a single guide ribonucleic acid (gRNA) is not robust. The proposed off-target analysis—a mismatch-sensitive nuclease assay at a single predicted site—is profoundly inadequate by current standards. It fails to screen the genome with sufficient breadth or depth.\n- **Behavioral Controls:** The explicit omission of behavioral controls (\"Do not include additional behavioral controls...\") is scientifically indefensible. A deficit in the partner preference test could easily be a secondary consequence of locomotor impairment, heightened anxiety, or olfactory deficits, none of which are tested.\n- **Rescue Experiment:** The omission of a rescue experiment means the design cannot satisfy the criterion of sufficiency, a cornerstone of demonstrating causality. One cannot be certain the phenotype is due to the loss of *Avpr1a* and not an undetected, linked off-target mutation.\n- **Verdict:** **Incorrect**. This design is primitive, lacks spatial and temporal specificity, and its control strategies are grossly insufficient.\n\n**Option B: Perform adult, region-specific CRISPR-Cas$9$ edits of *Avpr1a* in the ventral pallidum...**\nThis design proposes a spatially and temporally controlled manipulation.\n- **Specificity:** The manipulation is restricted to adult animals, thus avoiding developmental confounds. It is targeted to a specific, relevant neural circuit (the ventral pallidum), directly addressing the hypothesis. This approach provides high spatial and temporal specificity.\n- **Controls for Off-Targets:** The control strategy is state-of-the-art and exceptionally rigorous. It includes: (i) a scrambled gRNA control for the procedure itself, (ii) using two independent gRNAs to ensure convergent evidence (a powerful method to rule out off-target-driven phenotypes), and (iii) empirical validation of off-target loci via targeted deep sequencing.\n- **Rescue Experiment:** A rescue experiment using a CRISPR-resistant complementary deoxyribonucleic acid (cDNA) is included. This is the gold standard for confirming that the observed phenotype is a direct result of the target gene's knockdown and not an artifact of the manipulation.\n- **Behavioral Controls:** The design includes a comprehensive battery of behavioral assays to distinguish a specific deficit in pair-bonding (partner preference test) from general changes in sociability (social novelty preference), locomotion (open-field), anxiety (elevated plus maze), and sensory function (olfactory habituation/dishabituation). This is essential for a clean interpretation of the results.\n- **Scientific Rigor:** The inclusion of molecular verification at multiple levels (transduction, editing, transcription, protein), blinded behavioral scoring, and control for key biological variables (sex, estrus, littermates) demonstrates a commitment to rigor that is absent in the other options.\n- **Verdict:** **Correct**. This design represents a textbook example of a rigorous, modern neurogenetic experiment. It directly tests the proximate causal hypothesis with outstanding specificity and a comprehensive set of controls that systematically eliminate alternative explanations.\n\n**Option C: Sample wild vole populations and genotype *Avpr1a* microsatellite length polymorphisms...**\nThis design proposes a correlational study.\n- **Causation:** This is a descriptive, correlational approach. It can identify an association between a genetic marker and a behavior, but it cannot establish causation. Correlation does not imply causation. Any observed association could be spurious, or due to a third, unmeasured variable (e.g., population substructure, linkage disequilibrium with the true causal locus).\n- **Proximate vs. Ultimate:** This analysis investigates patterns of natural variation and their association with behavioral traits in a population context. This is the domain of evolutionary genetics and addresses questions of ultimate causation (i.e., the evolutionary history and selective pressures that maintain this variation). It does not, and cannot, elucidate the proximate physiological mechanism by which the gene influences behavior within an individual.\n- **Verdict:** **Incorrect**. This design is inappropriate for testing a hypothesis about proximate causation.\n\n**Option D: Use CRISPR to knock out the oxytocin receptor (*Oxtr*)...**\nThis design is logically flawed.\n- **Target of Manipulation:** The hypothesis is about *Avpr1a*. This experiment manipulates the oxytocin receptor (*Oxtr*), a different gene entirely. To test a hypothesis about variable $X$, one must manipulate $X$, not variable $Y$. While the oxytocin and vasopressin systems interact, this design is indirect and cannot isolate the specific role of *Avpr1a*.\n- **Specificity:** Systemic administration of a vasopressin agonist lacks all spatial specificity, activating receptors throughout the brain and body. This fails to test the \"specific neural circuits\" part of the hypothesis.\n- **Controls:** The assertion that \"off-target evaluation is not necessary because pharmacology confirms receptor specificity\" is dangerously naive and scientifically unsound. It conflates the specificity of the drug with the specificity of the genetic modification. The CRISPR knockout of *Oxtr* absolutely requires off-target analysis.\n- **Verdict:** **Incorrect**. The experimental logic is fundamentally flawed and the controls are inadequate.\n\n**Option E: Use CRISPR interference (CRISPRi) to reduce *Avpr1a* transcription globally...**\nThis design uses a knockdown approach.\n- **Specificity:** Like option A, this manipulation is \"globally\" applied. Although timed postnatally, it still lacks the neural circuit specificity required by the hypothesis.\n- **Controls for Off-Targets:** Relying \"solely by in silico prediction scores\" is unacceptable. Experimental verification of off-target effects is mandatory for a rigorous study.\n- **Rescue Experiment:** The assumption that a rescue is unnecessary because CRISPRi is \"reversible\" is a poor substitute for an active, controlled rescue experiment. The extent and uniformity of reversal are not guaranteed.\n- **Behavioral Controls:** The behavioral component is weak, including only a general social interaction assay and omitting critical controls for locomotion, anxiety, and sensory function. A general social interaction test does not measure pair-bonding, which is a specific form of social attachment.\n- **Other Controls:** Measuring serum vasopressin is not the most relevant control for a manipulation of the receptor. The primary confirmation needed is the degree of *Avpr1a* mRNA or protein knockdown in the target tissue.\n- **Verdict:** **Incorrect**. This design suffers from a lack of spatial specificity and has critically deficient off-target and behavioral controls.\n\nIn summary, only Option B proposes an experimental strategy that is sufficiently specific, rigorous, and well-controlled to test the stated hypothesis about proximate causation according to modern scientific standards.", "answer": "$$\\boxed{B}$$", "id": "2778896"}, {"introduction": "Many of an animal's most important decisions, such as when to migrate or reproduce, depend on its internal state (e.g., energy reserves) and the time of year. Dynamic state variable modeling is a powerful computational approach that integrates these proximate state variables with ultimate fitness goals to predict optimal, state-dependent strategies. In this practice, you will implement a dynamic programming model to solve for the optimal migration timing policy of a bird, gaining hands-on experience with a method that is central to modern behavioral and evolutionary ecology [@problem_id:2778865].", "problem": "A migratory bird must decide on each day whether to depart immediately for the breeding grounds or to remain at a stopover site to forage. The proximate state at any decision time is two-dimensional, consisting of fat reserves and time. Let the state be $(f,t)$, where $f \\in \\{0,1,\\dots,F_{\\max}\\}$ denotes discrete energy reserves (in arbitrary energy units) and $t \\in \\{0,1,\\dots,T\\}$ denotes the day within a finite season. Remaining at the stopover (action $\\text{wait}$) leads to stochastic changes in energy reserves due to weather-driven foraging and to a daily survival probability, while departing (action $\\text{depart}$) yields an immediate probability of successful migration that depends on energy reserves and an arrival-time-dependent reproductive payoff. This setting formalizes the behavioral ecology distinction between proximate causation (physiological energy dynamics and survival within a day) and ultimate causation (expected reproductive success upon arrival). The objective is to compute the optimal migration timing policy that maximizes expected fitness.\n\nYou must implement a finite-horizon dynamic state variable model, as a Markov Decision Process (MDP), using the following foundational assumptions and definitions.\n\n1. State, actions, and horizon.\n   - State is $(f,t)$ with $f \\in \\{0,1,\\dots,F_{\\max}\\}$ and $t \\in \\{0,1,\\dots,T\\}$.\n   - Actions $a \\in \\{\\text{depart}, \\text{wait}\\}$.\n   - Horizon ends after day $T$. If the bird has not departed by $t=T$, any subsequent waiting yields zero fitness.\n\n2. Proximate dynamics under action $\\text{wait}$.\n   - Daily survival probability at the stopover is a constant $s \\in (0,1]$.\n   - Weather is stochastic and independent across days, with “good” day probability $p_G(t) \\in [0,1]$. On a good day, net fat change is $g_G$; on a bad day, net fat change is $g_B$. Both $g_G$ and $g_B$ are integers (energy units per day), with the next-state fat computed as $f'=\\min\\{\\max\\{f+\\Delta f,0\\},F_{\\max}\\}$, where $\\Delta f \\in \\{g_G,g_B\\}$.\n   - The expected continuation value from waiting is\n     $$ W(f,t) \\;=\\; s \\left[ p_G(t)\\,V\\!\\left(\\min\\{\\max\\{f+g_G,0\\},F_{\\max}\\},\\,t+1\\right) \\;+\\; \\left(1-p_G(t)\\right) V\\!\\left(\\min\\{\\max\\{f+g_B,0\\},F_{\\max}\\},\\,t+1\\right) \\right]. $$\n\n3. Ultimate payoff under action $\\text{depart}$.\n   - Probability of successful migration is a logistic function of fat:\n     $$ q(f) \\;=\\; \\frac{1}{1+\\exp\\!\\left(-\\alpha\\,(f - f_{50})\\right)}, $$\n     where $\\alpha  0$ is the slope and $f_{50}$ is the fat at which $q(f)=1/2$.\n   - Reproductive payoff on arrival declines with time:\n     $$ R(t) \\;=\\; \\max\\{0,\\, R_{\\max} - c_t \\, t\\}, $$\n     where $R_{\\max} \\ge 0$ and $c_t \\ge 0$ are constants.\n   - The expected value from departing is $D(f,t)=q(f)\\,R(t)$.\n\n4. Objective and Bellman recursion.\n   - Let $V(f,t)$ be the maximal expected fitness from state $(f,t)$. The Bellman equation is\n     $$ V(f,t) \\;=\\; \\max\\{ D(f,t),\\, W(f,t) \\}, \\quad \\text{with tie broken in favor of } \\text{depart}. $$\n   - Terminal condition: for all $f$, $V(f,T+1)=0$.\n\n5. Output and units.\n   - Energy units are arbitrary and dimensionless in this model. Time is in days. Probabilities must be provided as decimals (for example, $0.6$ rather than $60\\%$). The program must report expected fitness as a dimensionless real number rounded to six decimal places.\n\n6. Required final output format.\n   - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, “[result1,result2,result3]”).\n   - For each test case $i$, report two values in order: the optimal action at the specified initial state encoded as an integer ($0$ for wait, $1$ for depart), followed by the expected fitness $V(f_0,t_0)$ rounded to six decimals.\n   - With $N$ test cases, the final output must be a single list of length $2N$ in the order $[a_1,V_1,a_2,V_2,\\dots,a_N,V_N]$.\n\n7. Test suite.\n   Implement the model for each of the following $5$ test cases. Each test case specifies parameters and the initial state $(f_0,t_0)$. All numbers are given as decimals and must be used as-is.\n\n   - Case $1$ (happy path, early season, moderate fat):\n     - $F_{\\max}=20$, $T=10$.\n     - $g_G=+3$, $g_B=-2$.\n     - $s=0.98$.\n     - $\\alpha=1.2$, $f_{50}=8$.\n     - $R_{\\max}=10$, $c_t=0.5$.\n     - $p_G(t)=0.6$ for all $t$.\n     - Initial state $(f_0,t_0)=(5,0)$.\n\n   - Case $2$ (boundary: last day decision):\n     - $F_{\\max}=20$, $T=5$.\n     - $g_G=+3$, $g_B=-2$.\n     - $s=0.98$.\n     - $\\alpha=1.2$, $f_{50}=8$.\n     - $R_{\\max}=10$, $c_t=0.5$.\n     - $p_G(t)=0.5$ for all $t$.\n     - Initial state $(f_0,t_0)=(7,5)$.\n\n   - Case $3$ (high fat early; earlier arrival valuable):\n     - $F_{\\max}=20$, $T=10$.\n     - $g_G=+3$, $g_B=-2$.\n     - $s=0.98$.\n     - $\\alpha=1.2$, $f_{50}=8$.\n     - $R_{\\max}=10$, $c_t=0.5$.\n     - $p_G(t)=0.5$ for all $t$.\n     - Initial state $(f_0,t_0)=(15,2)$.\n\n   - Case $4$ (edge: hazardous stopover and poor bad-day foraging):\n     - $F_{\\max}=20$, $T=8$.\n     - $g_G=+2$, $g_B=-3$.\n     - $s=0.85$.\n     - $\\alpha=1.0$, $f_{50}=7$.\n     - $R_{\\max}=10$, $c_t=0.7$.\n     - $p_G(t)=0.5$ for all $t$.\n     - Initial state $(f_0,t_0)=(3,0)$.\n\n   - Case $5$ (time-varying environment; improving foraging later):\n     - $F_{\\max}=20$, $T=12$.\n     - $g_G=+4$, $g_B=-2$.\n     - $s=0.97$.\n     - $\\alpha=1.3$, $f_{50}=9$.\n     - $R_{\\max}=12$, $c_t=0.4$.\n     - $p_G(t)=0.3 + (0.8-0.3)\\,t/T$ for $t \\in \\{0,\\dots,T\\}$.\n     - Initial state $(f_0,t_0)=(6,3)$.\n\nYour program must compute the full optimal policy via dynamic programming for each test case and then output a single line containing the concatenated results $[a_1,V_1,a_2,V_2,a_3,V_3,a_4,V_4,a_5,V_5]$, where each $a_i \\in \\{0,1\\}$ and each $V_i$ is rounded to six decimals.", "solution": "The goal is to formalize a migration timing problem that separates proximate mechanisms from ultimate outcomes and then solve it via dynamic programming (DP). The proximate side captures state updates of energy reserves and survival across days, while the ultimate side is the expected reproductive success upon successful arrival, which depends on the departure day and fat-dependent success probability. The optimization principle in behavioral ecology that connects proximate and ultimate causation is that natural selection tends to favor decision rules that maximize expected reproductive success, subject to physiological and ecological constraints.\n\nFoundational base and modeling principles:\n- The Markov Decision Process (MDP) framework represents sequential decision-making under uncertainty, where the state satisfies the Markov property and the decision-maker maximizes expected cumulative (or terminal) reward.\n- In this problem, the state is $(f,t)$, the action is either $\\text{depart}$ or $\\text{wait}$, and all uncertainty (good or bad foraging day) is stochastic and independent between days (conditionally on time).\n- The fitness payoff is terminal and depends on the success of migration (probability $q(f)$, proximate function of fat reserve) and the day of arrival via $R(t)$ (ultimate fitness component that encodes seasonal decline in reproductive payoff).\n- The optimality principle leads to a Bellman recursion: optimal decisions today maximize the sum of immediate expected reward plus the expected value of optimally acting in the future.\n\nStep-by-step derivation of the Bellman recursion:\n1. Define the terminal condition. With a finite horizon ending after day $T$, if the individual has not departed by time $T$ and then waits, there is no time left for additional payoff: $V(f,T+1)=0$ for all $f$.\n2. Expected value of departing at $(f,t)$. The immediate expected fitness is the success probability multiplied by the arrival-time payoff:\n   $$ D(f,t)= q(f)\\,R(t), \\quad q(f)=\\frac{1}{1+\\exp(-\\alpha(f-f_{50}))}, \\quad R(t)=\\max\\{0,R_{\\max}-c_t t\\}. $$\n   This captures the ultimate side (reproductive payoff $R(t)$) weighted by a proximate mechanism (logistic dependence $q(f)$ on fat).\n3. Expected value of waiting one day. Waiting yields no immediate payoff but preserves the option to depart later, at the cost of daily mortality and stochastic foraging. The survival component $s$ (proximate) multiplies the expectation of the next day’s value:\n   $$ W(f,t)= s\\left[ p_G(t)\\,V\\!\\left(\\min\\{\\max\\{f+g_G,0\\},F_{\\max}\\},\\,t+1\\right) + (1-p_G(t))\\,V\\!\\left(\\min\\{\\max\\{f+g_B,0\\},F_{\\max}\\},\\,t+1\\right) \\right]. $$\n   The clipping $\\min\\{\\max\\{\\cdot,0\\},F_{\\max}\\}$ encodes physiological constraints and ensures the state remains within bounds.\n4. Optimality and tie-breaking. The value function satisfies\n   $$ V(f,t)=\\max\\{D(f,t),W(f,t)\\}, $$\n   with a tie broken in favor of departing, which induces a well-defined policy $\\pi(f,t)\\in\\{0,1\\}$, encoded as $1$ for depart and $0$ for wait.\n\nAlgorithmic design:\n- Use backward dynamic programming over time $t$ from $T$ down to $0$.\n- Represent $V$ as a $(F_{\\max}+1)\\times (T+2)$ array to include the terminal column at $T+1$.\n- For each $t$ and each $f$, compute $D(f,t)$ and $W(f,t)$ using the provided parameters, then set $V(f,t)$ to their maximum and record the corresponding action in a policy array of the same size.\n- The environment process $p_G(t)$ is either constant or time-varying (linear in $t$ for Case $5$), but only its expectation matters for the one-step transition because weather is independent across days and not part of the state.\n- After filling $V$ and the policy, read off the optimal action $\\pi(f_0,t_0)$ and the expected fitness $V(f_0,t_0)$ for each test case.\n\nCorrectness justification:\n- The MDP’s Markov property holds because the next state distribution depends only on $(f,t)$ and the chosen action, not on earlier history.\n- The Bellman equation is derived from the principle of optimality, which is valid for finite-horizon MDPs.\n- The backward induction algorithm converges exactly in finite time due to the finite state and action spaces and the terminal condition at $t=T+1$.\n- The policy computed maximizes expected terminal fitness by construction.\n\nComputational considerations:\n- Time complexity is $O\\!\\left(T \\cdot (F_{\\max}+1)\\right)$ per test case, since the inner computations are $O(1)$ per $(f,t)$.\n- The model handles boundary cases: at $t=T$, waiting yields $W(f,T)=s\\,\\mathbb{E}[V(\\cdot,T+1)]=0$, so departing dominates if $D(f,T)gt;0$. If fat is low, $q(f)$ reduces successful departure probability, which the DP compares against the benefits and risks of waiting.\n\nTest coverage rationale:\n- Case $1$ explores a typical scenario early in the season with moderate fat and modest foraging stochasticity.\n- Case $2$ forces a last-day decision where waiting cannot yield future benefits, validating boundary logic.\n- Case $3$ tests whether high fat early leads to an early departure due to high $q(f)$ and higher $R(t)$ for earlier times.\n- Case $4$ examines a hazardous stopover and poor foraging on bad days, potentially making early departure optimal even at low fat.\n- Case $5$ introduces a time-varying foraging environment where $p_G(t)$ improves over time, testing whether the model can recommend waiting to exploit better future foraging despite declining $R(t)$.\n\nImplementation details required by the output specification:\n- The program must hard-code the $5$ test cases, compute the policy and value function for each, and then output a single list with $10$ entries: $[a_1,V_1,a_2,V_2,a_3,V_3,a_4,V_4,a_5,V_5]$, where each $a_i\\in\\{0,1\\}$ and each $V_i$ is printed rounded to six decimal places. No additional text should be printed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef logistic_success_prob(f_vals, alpha, f50):\n    # q(f) = 1 / (1 + exp(-alpha * (f - f50)))\n    return 1.0 / (1.0 + np.exp(-alpha * (f_vals - f50)))\n\ndef compute_policy_and_value(case):\n    Fmax = int(case['Fmax'])\n    T = int(case['T'])\n    gG = int(case['gG'])\n    gB = int(case['gB'])\n    s = float(case['s'])\n    alpha = float(case['alpha'])\n    f50 = float(case['f50'])\n    Rmax = float(case['Rmax'])\n    ct = float(case['ct'])\n    pG_type = case['pG_type']\n\n    # Precompute q(f) for all f\n    f_grid = np.arange(Fmax + 1, dtype=float)\n    q = logistic_success_prob(f_grid, alpha, f50)\n\n    # Precompute R(t) for all t\n    t_grid = np.arange(T + 1, dtype=float)\n    R = np.maximum(0.0, Rmax - ct * t_grid)\n\n    # Initialize value and policy arrays\n    V = np.zeros((Fmax + 1, T + 2), dtype=float)  # includes terminal column at T+1\n    policy = np.zeros((Fmax + 1, T + 1), dtype=int)  # actions for t=0..T\n\n    # Helper to get pG(t)\n    if pG_type == 'const':\n        p_const = float(case['pG_const'])\n        def pG(t):\n            return p_const\n    elif pG_type == 'linear':\n        p0 = float(case['p0'])\n        pT = float(case['pT'])\n        def pG(t):\n            # linear in t from p0 at t=0 to pT at t=T\n            if T > 0:\n                return p0 + (pT - p0) * (t / T)\n            else:\n                return p0\n    else:\n        raise ValueError(\"Unknown pG_type\")\n\n    # Backward DP\n    for t in range(T, -1, -1):\n        p = pG(t)\n        # For each f, compute depart and wait values\n        for f in range(Fmax + 1):\n            # Depart value\n            depart_val = q[f] * R[t]\n\n            # Wait value\n            fG = int(np.clip(f + gG, 0, Fmax))\n            fB = int(np.clip(f + gB, 0, Fmax))\n\n            wait_val = s * (p * V[fG, t + 1] + (1.0 - p) * V[fB, t + 1])\n\n            # Optimal choice; tie broken in favor of depart\n            if depart_val = wait_val:\n                V[f, t] = depart_val\n                policy[f, t] = 1\n            else:\n                V[f, t] = wait_val\n                policy[f, t] = 0\n\n    # Initial state's action and value\n    f0 = int(case['init_f'])\n    t0 = int(case['init_t'])\n    a0 = int(policy[f0, t0])\n    v0 = float(V[f0, t0])\n    return a0, v0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            # Case 1\n            'Fmax': 20,\n            'T': 10,\n            'gG': 3,\n            'gB': -2,\n            's': 0.98,\n            'alpha': 1.2,\n            'f50': 8.0,\n            'Rmax': 10.0,\n            'ct': 0.5,\n            'pG_type': 'const',\n            'pG_const': 0.6,\n            'init_f': 5,\n            'init_t': 0\n        },\n        {\n            # Case 2\n            'Fmax': 20,\n            'T': 5,\n            'gG': 3,\n            'gB': -2,\n            's': 0.98,\n            'alpha': 1.2,\n            'f50': 8.0,\n            'Rmax': 10.0,\n            'ct': 0.5,\n            'pG_type': 'const',\n            'pG_const': 0.5,\n            'init_f': 7,\n            'init_t': 5\n        },\n        {\n            # Case 3\n            'Fmax': 20,\n            'T': 10,\n            'gG': 3,\n            'gB': -2,\n            's': 0.98,\n            'alpha': 1.2,\n            'f50': 8.0,\n            'Rmax': 10.0,\n            'ct': 0.5,\n            'pG_type': 'const',\n            'pG_const': 0.5,\n            'init_f': 15,\n            'init_t': 2\n        },\n        {\n            # Case 4\n            'Fmax': 20,\n            'T': 8,\n            'gG': 2,\n            'gB': -3,\n            's': 0.85,\n            'alpha': 1.0,\n            'f50': 7.0,\n            'Rmax': 10.0,\n            'ct': 0.7,\n            'pG_type': 'const',\n            'pG_const': 0.5,\n            'init_f': 3,\n            'init_t': 0\n        },\n        {\n            # Case 5\n            'Fmax': 20,\n            'T': 12,\n            'gG': 4,\n            'gB': -2,\n            's': 0.97,\n            'alpha': 1.3,\n            'f50': 9.0,\n            'Rmax': 12.0,\n            'ct': 0.4,\n            'pG_type': 'linear',\n            'p0': 0.3,\n            'pT': 0.8,\n            'init_f': 6,\n            'init_t': 3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        action, value = compute_policy_and_value(case)\n        results.append(action)\n        results.append(f\"{value:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2778865"}]}