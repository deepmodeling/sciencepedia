{"hands_on_practices": [{"introduction": "The presentation of antigens by Major Histocompatibility Complex (MHC) class I molecules begins with their transport into the endoplasmic reticulum by the TAP transporter. This exercise models TAP as an enzyme and uses the principles of Michaelis-Menten kinetics to explore a crucial aspect of this process: competition between different cytosolic peptides for transport. By calculating how a competing peptide affects the transport rate of a specific antigen, you will gain a quantitative understanding of how the cellular peptide pool directly influences immune visibility [@problem_id:2507781].", "problem": "A single-site Transporter Associated with Antigen Processing (TAP) in the endoplasmic reticulum (ER) translocates cytosolic peptides into the ER lumen, where they can bind Major Histocompatibility Complex class I (MHC I) molecules. Assume that TAP follows Michaelis–Menten kinetics under the quasi–steady-state approximation and that two cytosolic peptides, $A$ and $B$, compete for the same binding site on TAP. Peptide $A$ is a high-affinity epitope for an MHC I allele of interest (denoted MHC I–$A$) and can form stable surface complexes upon ER entry. Peptide $B$ does not bind this MHC I allele, but competes for TAP transport. Experimental measurements (per cell) provide a shared maximal transport rate $V_{\\max}$ and peptide-specific Michaelis constants $K_{m,A}$ and $K_{m,B}$.\n\nUse the following scientifically plausible parameters:\n- $V_{\\max} = 2.0 \\times 10^{5}\\ \\text{peptides}\\ \\text{s}^{-1}$,\n- $K_{m,A} = 0.50\\ \\mu\\text{M}$,\n- $K_{m,B} = 2.0\\ \\mu\\text{M}$,\n- cytosolic concentrations $[A] = 1.0\\ \\mu\\text{M}$ and $[B] = 3.0\\ \\mu\\text{M}$.\n\nAssume that a fixed fraction $\\alpha = 0.25$ of transported peptide $A$ successfully loads onto MHC I–$A$ and exits the ER, and that surface MHC I–$A$ complexes decay with a first-order rate constant $\\delta = 1/1800\\ \\text{s}^{-1}$. Adopt the standard single-site competition framework grounded in the quasi–steady-state and mass-action assumptions: the transporter cycles at rate proportional to the occupancy of its peptide-bound states, and mutually exclusive substrates $A$ and $B$ share the same catalytic turnover once bound.\n\nTasks:\n1. From first principles for a single-site, mutually exclusive binding scheme, derive expressions for the transport rates $v_{A}$ and $v_{B}$ as functions of $V_{\\max}$, $[A]$, $[B]$, $K_{m,A}$, and $K_{m,B}$.\n2. Evaluate $v_{A}$ when peptide $B$ is absent (i.e., $[B] = 0$) and when peptide $B$ is present at $[B] = 3.0\\ \\mu\\text{M}$. Express transport rates in $\\text{peptides}\\ \\text{s}^{-1}$.\n3. Using the steady-state balance $dN/dt = \\alpha\\,v_{A} - \\delta\\,N$ for the number $N$ of surface MHC I–$A$ complexes, compute the fold change $F \\equiv N_{\\text{with }B}/N_{\\text{without }B}$ caused by competition from peptide $B$.\n\nReport only the final value of $F$ as a unitless decimal fraction, rounded to $4$ significant figures. Do not include any other quantities in your final answer.", "solution": "The problem presented is chemically and biologically coherent, well-posed, and contains all necessary information for a unique solution. It is a standard application of competitive enzyme kinetics to a problem in immunology. I will therefore proceed with the solution.\n\nThe problem asks for the derivation of transport rates for two competing peptides, their numerical evaluation, and the subsequent calculation of a fold change in surface MHC I complex presentation.\n\n**Task 1: Derivation of Transport Rates**\n\nLet $E$ denote the free TAP transporter, and let $A$ and $B$ represent the two competing cytosolic peptides. The total concentration of the transporter is $[E]_T$. The system is described by the following reactions, based on a single-site, mutually exclusive binding mechanism:\n\n$$ E + A \\underset{k_{-1}}{\\stackrel{k_{1}}{\\rightleftharpoons}} EA \\stackrel{k_{\\text{cat}}}{\\longrightarrow} E + A_{\\text{transported}} $$\n$$ E + B \\underset{k_{-2}}{\\stackrel{k_{2}}{\\rightleftharpoons}} EB \\stackrel{k_{\\text{cat}}}{\\longrightarrow} E + B_{\\text{transported}} $$\n\nThe problem states a shared maximal transport rate $V_{\\max}$, which implies the catalytic turnover rate constant, $k_{\\text{cat}}$, is the same for both peptide-bound complexes.\n\nUnder the quasi–steady-state approximation (QSSA), the concentrations of the intermediate complexes $EA$ and $EB$ are assumed to be constant.\n$$ \\frac{d[EA]}{dt} = k_1 [E][A] - (k_{-1} + k_{\\text{cat}})[EA] \\approx 0 $$\n$$ \\frac{d[EB]}{dt} = k_2 [E][B] - (k_{-2} + k_{\\text{cat}})[EB] \\approx 0 $$\n\nThe Michaelis constants are defined as $K_{m,A} = \\frac{k_{-1} + k_{\\text{cat}}}{k_1}$ and $K_{m,B} = \\frac{k_{-2} + k_{\\text{cat}}}{k_2}$. Substituting these into the steady-state equations gives:\n$$ k_1 [E][A] = k_1 K_{m,A} [EA] \\implies [EA] = \\frac{[E][A]}{K_{m,A}} $$\n$$ k_2 [E][B] = k_2 K_{m,B} [EB] \\implies [EB] = \\frac{[E][B]}{K_{m,B}} $$\n\nThe total transporter concentration is the sum of the free and bound forms:\n$$ [E]_T = [E] + [EA] + [EB] $$\nSubstituting the expressions for $[EA]$ and $[EB]$:\n$$ [E]_T = [E] + \\frac{[E][A]}{K_{m,A}} + \\frac{[E][B]}{K_{m,B}} = [E] \\left( 1 + \\frac{[A]}{K_{m,A}} + \\frac{[B]}{K_{m,B}} \\right) $$\n\nThe concentration of the free transporter, $[E]$, is therefore:\n$$ [E] = \\frac{[E]_T}{1 + \\frac{[A]}{K_{m,A}} + \\frac{[B]}{K_{m,B}}} $$\n\nThe transport rate for peptide $A$, denoted $v_A$, is proportional to the concentration of the $EA$ complex: $v_A = k_{\\text{cat}}[EA]$. The maximal transport rate is $V_{\\max} = k_{\\text{cat}}[E]_T$.\n$$ v_A = k_{\\text{cat}} \\frac{[E][A]}{K_{m,A}} = k_{\\text{cat}} \\frac{[A]}{K_{m,A}} \\left( \\frac{[E]_T}{1 + \\frac{[A]}{K_{m,A}} + \\frac{[B]}{K_{m,B}}} \\right) $$\n$$ v_A = \\frac{k_{\\text{cat}}[E]_T \\frac{[A]}{K_{m,A}}}{1 + \\frac{[A]}{K_{m,A}} + \\frac{[B]}{K_{m,B}}} = \\frac{V_{\\max} \\frac{[A]}{K_{m,A}}}{1 + \\frac{[A]}{K_{m,A}} + \\frac{[B]}{K_{m,B}}} $$\nMultiplying the numerator and denominator by $K_{m,A}$ gives the standard form for competitive inhibition:\n$$ v_A = \\frac{V_{\\max} [A]}{K_{m,A} \\left( 1 + \\frac{[A]}{K_{m,A}} + \\frac{[B]}{K_{m,B}} \\right)} = \\frac{V_{\\max} [A]}{K_{m,A} + [A] + K_{m,A}\\frac{[B]}{K_{m,B}}} $$\nThe canonical expression is:\n$$ v_A = \\frac{V_{\\max} [A]}{[A] + K_{m,A} \\left( 1 + \\frac{[B]}{K_{m,B}} \\right)} $$\nBy symmetry, the transport rate for peptide $B$ is:\n$$ v_B = \\frac{V_{\\max} [B]}{[B] + K_{m,B} \\left( 1 + \\frac{[A]}{K_{m,A}} \\right)} $$\n\n**Task 2: Evaluation of Transport Rates**\n\nThe given parameters are:\n$V_{\\max} = 2.0 \\times 10^{5}\\ \\text{peptides}\\ \\text{s}^{-1}$\n$K_{m,A} = 0.50\\ \\mu\\text{M}$\n$K_{m,B} = 2.0\\ \\mu\\text{M}$\n$[A] = 1.0\\ \\mu\\text{M}$\n$[B] = 3.0\\ \\mu\\text{M}$\n\nFirst, we calculate the transport rate of peptide $A$ in the absence of peptide $B$, denoted $v_{A, \\text{without } B}$. Here, $[B] = 0$.\n$$ v_{A, \\text{without } B} = \\frac{V_{\\max} [A]}{[A] + K_{m,A}(1 + 0)} = \\frac{V_{\\max} [A]}{[A] + K_{m,A}} $$\nSubstituting the numerical values (note that concentration units of $\\mu\\text{M}$ cancel):\n$$ v_{A, \\text{without } B} = \\frac{(2.0 \\times 10^{5}) (1.0)}{1.0 + 0.50} = \\frac{2.0 \\times 10^{5}}{1.5} = \\frac{4}{3} \\times 10^{5}\\ \\text{peptides}\\ \\text{s}^{-1} $$\n$v_{A, \\text{without } B} \\approx 1.333 \\times 10^{5}\\ \\text{peptides}\\ \\text{s}^{-1}$.\n\nNext, we calculate the transport rate of peptide $A$ in the presence of peptide $B$, denoted $v_{A, \\text{with } B}$, where $[B] = 3.0\\ \\mu\\text{M}$.\n$$ v_{A, \\text{with } B} = \\frac{V_{\\max} [A]}{[A] + K_{m,A} \\left( 1 + \\frac{[B]}{K_{m,B}} \\right)} $$\nSubstituting the numerical values:\n$$ v_{A, \\text{with } B} = \\frac{(2.0 \\times 10^{5}) (1.0)}{1.0 + 0.50 \\left( 1 + \\frac{3.0}{2.0} \\right)} = \\frac{2.0 \\times 10^{5}}{1.0 + 0.50 (1 + 1.5)} = \\frac{2.0 \\times 10^{5}}{1.0 + 0.50 (2.5)} $$\n$$ v_{A, \\text{with } B} = \\frac{2.0 \\times 10^{5}}{1.0 + 1.25} = \\frac{2.0 \\times 10^{5}}{2.25} = \\frac{8}{9} \\times 10^{5}\\ \\text{peptides}\\ \\text{s}^{-1} $$\n$v_{A, \\text{with } B} \\approx 8.889 \\times 10^{4}\\ \\text{peptides}\\ \\text{s}^{-1}$.\n\n**Task 3: Computation of Fold Change**\n\nThe number of surface MHC I–$A$ complexes, $N$, is governed by the differential equation:\n$$ \\frac{dN}{dt} = \\alpha v_A - \\delta N $$\nAt steady state, $\\frac{dN}{dt} = 0$, which leads to:\n$$ \\alpha v_A - \\delta N = 0 \\implies N = \\frac{\\alpha v_A}{\\delta} $$\nThe number of steady-state complexes is directly proportional to the transport rate $v_A$. The constants $\\alpha = 0.25$ and $\\delta = 1/1800\\ \\text{s}^{-1}$ are common to both conditions (with and without peptide $B$).\n\nThe fold change $F$ is defined as the ratio of the number of complexes with peptide $B$ present, $N_{\\text{with }B}$, to the number of complexes without peptide $B$, $N_{\\text{without }B}$.\n$$ F = \\frac{N_{\\text{with }B}}{N_{\\text{without }B}} = \\frac{\\frac{\\alpha v_{A, \\text{with } B}}{\\delta}}{\\frac{\\alpha v_{A, \\text{without } B}}{\\delta}} = \\frac{v_{A, \\text{with } B}}{v_{A, \\text{without } B}} $$\n\nUsing the previously calculated rates:\n$$ F = \\frac{\\frac{8}{9} \\times 10^{5}}{\\frac{4}{3} \\times 10^{5}} = \\frac{8}{9} \\times \\frac{3}{4} = \\frac{24}{36} = \\frac{2}{3} $$\nThe exact value of the fold change is $2/3$. The problem requires a decimal fraction rounded to $4$ significant figures.\n$$ F = \\frac{2}{3} \\approx 0.666666... $$\nRounding to $4$ significant figures, we get $F = 0.6667$.", "answer": "$$\\boxed{0.6667}$$", "id": "2507781"}, {"introduction": "Once peptides enter the ER, they must bind to an MHC molecule, but each MHC allele has a unique preference for the peptides it binds, a concept captured by a \"binding motif.\" In this practice, you will act as a bioinformatician analyzing a hypothetical dataset of peptides eluted from a specific HLA allele. You will use the principles of information theory, specifically Shannon entropy, to quantify the binding specificity at each position and derive the allele's consensus motif [@problem_id:2507787]. This exercise transforms abstract sequence data into a concrete, quantitative model of molecular recognition.", "problem": "A set of $16$ non-redundant nine-mer peptide sequences was eluted from $HLA\\text{-}B^{\\ast}27{:}05$, a Major Histocompatibility Complex (MHC) class I molecule. The sequences (single-letter amino acid codes) are:\n1. YRANDCQEK\n2. WRNDCQEGK\n3. KRDCQEGHK\n4. ARCQEGHIK\n5. NRQEGHILK\n6. DREGHILMK\n7. CRGHILMFK\n8. QRHILMFPK\n9. YRILMFPSR\n10. WRLMFPSTR\n11. KRMFPSTVR\n12. ARFPSTVAR\n13. NRPSTVANR\n14. DRSTVANDR\n15. CRTVANDCR\n16. QRVANDCQR\n\nTreat positions as $1$ through $9$ from the N-terminus to the C-terminus. Starting from the definition of Shannon entropy and assuming positions contribute independently to binding under a uniform background usage of the $20$ standard amino acids in the source proteome, perform the following:\n\n- Infer a minimal consensus motif that captures the strongest constraints visible in these peptides (describe this qualitatively in your working, but the graded quantity is specified below).\n- From first principles, derive an expression for the per-position information content relative to the uniform background, and compute the total motif information content by summing over the $9$ positions for this dataset.\n\nExpress the final total information content as a single closed-form analytical expression in bits. Do not approximate or round; provide an exact expression. The graded answer is only the final total information content (a single expression).", "solution": "The problem requires the calculation of the total information content of a peptide binding motif from a given set of $N=16$ nine-mer sequences. This will be accomplished by first deriving the formula for per-position information content from fundamental principles of information theory, then applying it to the provided data, and finally summing the contributions from all nine positions, under the stated assumption of positional independence.\n\nThe information content of a sequence motif at a given position is a measure of the reduction in uncertainty at that position relative to a background distribution. It is formally defined as the Kullback-Leibler divergence, $D_{KL}$, between the observed probability distribution of amino acids at that position, $P_i = \\{p_i(a)\\}$, and the background probability distribution, $Q = \\{q(a)\\}$. The alphabet consists of $M=20$ standard amino acids. The problem specifies a uniform background distribution, thus $q(a) = \\frac{1}{M} = \\frac{1}{20}$ for any amino acid $a$.\n\nThe information content at position $i$, denoted $I_i$ and measured in bits, is given by:\n$$I_i = \\sum_{a=1}^{20} p_i(a) \\log_{2}\\left(\\frac{p_i(a)}{q(a)}\\right)$$\nSubstituting $q(a) = 1/20$:\n$$I_i = \\sum_{a=1}^{20} p_i(a) \\log_{2}(20 \\cdot p_i(a)) = \\sum_{a=1}^{20} p_i(a) \\log_{2}(20) + \\sum_{a=1}^{20} p_i(a) \\log_{2}(p_i(a))$$\nAs $\\sum_{a=1}^{20} p_i(a) = 1$, this expression simplifies to:\n$$I_i = \\log_{2}(20) + \\sum_{a=1}^{20} p_i(a) \\log_{2}(p_i(a))$$\nHere, the term $p_i(a) \\log_{2}(p_i(a))$ is taken to be $0$ if $p_i(a)=0$. The probabilities $p_i(a)$ are estimated from the provided sample of $N=16$ sequences as $p_i(a) = \\frac{n_i(a)}{N}$, where $n_i(a)$ is the count of amino acid $a$ at position $i$.\n\nThe total information content of the motif, $I_{total}$, is the sum of the per-position information contents, as positions are assumed to be independent:\n$$I_{total} = \\sum_{i=1}^{9} I_i$$\n\nFirst, we must tabulate the amino acid counts, $n_i(a)$, for each position $i \\in \\{1, \\dots, 9\\}$ from the $16$ given sequences.\n\n- **Position 1 (P1):** The amino acids observed are {Y, W, K, A, N, D, C, Q}. Each appears with a count of $n_1(a) = 2$. There are $8$ such amino acids. Thus, for these $8$ acids, the frequency is $p_1(a) = \\frac{2}{16} = \\frac{1}{8}$. For the other $12$ amino acids, $p_1(a) = 0$.\n- **Position 2 (P2):** The amino acid Arginine (R) is observed in all $16$ sequences. Thus, $n_2(R) = 16$ and $p_2(R) = \\frac{16}{16} = 1$. All other amino acids have $p_2(a) = 0$.\n- **Positions 3 through 8 (P3-P8):** For each of these six positions, analysis of the sequences reveals that $16$ distinct amino acids are present, each appearing exactly once. Thus, for each position $i \\in \\{3, 4, 5, 6, 7, 8\\}$, there are $16$ amino acids for which $n_i(a) = 1$ and hence $p_i(a) = \\frac{1}{16}$. For the remaining $4$ amino acids, $p_i(a) = 0$.\n- **Position 9 (P9):** The amino acids observed are Lysine (K) and Arginine (R). Each appears with a count of $n_9(a) = 8$. Thus, $p_9(K) = \\frac{8}{16} = \\frac{1}{2}$ and $p_9(R) = \\frac{8}{16} = \\frac{1}{2}$. For the other $18$ amino acids, $p_9(a) = 0$.\n\nThe consensus motif can be qualitatively described based on these frequencies. The strongest constraint is at position P2, which is invariably R. Position P9 is also strongly constrained to one of two basic residues, K or R. Position P1 shows a moderate preference for a set of $8$ amino acids. Positions P3 through P8 are highly variable within this dataset, showing no significant preference.\n\nNow, we compute the information content $I_i$ for each position.\nWe can simplify $\\log_{2}(20) = \\log_{2}(4 \\times 5) = \\log_{2}(2^2) + \\log_{2}(5) = 2 + \\log_{2}(5)$.\n\n- **For P1:**\nThe entropy term is $\\sum p_1(a) \\log_{2} p_1(a) = 8 \\times \\left(\\frac{1}{8} \\log_{2}\\left(\\frac{1}{8}\\right)\\right) = \\log_{2}(2^{-3}) = -3$.\n$I_1 = \\log_{2}(20) - 3 = (2 + \\log_{2}(5)) - 3 = \\log_{2}(5) - 1$.\n\n- **For P2:**\nThe entropy term is $\\sum p_2(a) \\log_{2} p_2(a) = 1 \\times \\log_{2}(1) = 0$.\n$I_2 = \\log_{2}(20) + 0 = 2 + \\log_{2}(5)$.\n\n- **For P3-P8:**\nThe calculation is identical for these six positions.\nThe entropy term is $\\sum p_i(a) \\log_{2} p_i(a) = 16 \\times \\left(\\frac{1}{16} \\log_{2}\\left(\\frac{1}{16}\\right)\\right) = \\log_{2}(2^{-4}) = -4$.\n$I_i = \\log_{2}(20) - 4 = (2 + \\log_{2}(5)) - 4 = \\log_{2}(5) - 2$ for $i \\in \\{3, \\dots, 8\\}$.\n\n- **For P9:**\nThe entropy term is $\\sum p_9(a) \\log_{2} p_9(a) = 2 \\times \\left(\\frac{1}{2} \\log_{2}\\left(\\frac{1}{2}\\right)\\right) = \\log_{2}(2^{-1}) = -1$.\n$I_9 = \\log_{2}(20) - 1 = (2 + \\log_{2}(5)) - 1 = \\log_{2}(5) + 1$.\n\nFinally, we sum the per-position information contents to find the total information content $I_{total}$.\n$$I_{total} = I_1 + I_2 + \\sum_{i=3}^{8} I_i + I_9$$\n$$I_{total} = I_1 + I_2 + 6 \\times (\\log_{2}(5) - 2) + I_9$$\n$$I_{total} = (\\log_{2}(5) - 1) + (2 + \\log_{2}(5)) + 6(\\log_{2}(5) - 2) + (\\log_{2}(5) + 1)$$\n$$I_{total} = \\log_{2}(5) - 1 + 2 + \\log_{2}(5) + 6\\log_{2}(5) - 12 + \\log_{2}(5) + 1$$\nGrouping the terms:\n$$I_{total} = (1 + 1 + 6 + 1)\\log_{2}(5) + (-1 + 2 - 12 + 1)$$\n$$I_{total} = 9\\log_{2}(5) - 10$$\nThis is the final, exact, closed-form analytical expression for the total information content of the motif in bits.", "answer": "$$\\boxed{9\\log_{2}(5) - 10}$$", "id": "2507787"}, {"introduction": "The immense diversity of HLA alleles in the human population presents a major challenge for vaccine design: an epitope that works for one person may not work for another. This final practice elevates our analysis from the single-cell level to the population scale, tackling the real-world problem of designing an epitope-based vaccine with maximum population coverage. You are tasked with formalizing this challenge as a computational optimization problem, deriving a formula for population coverage, and exploring algorithms to select a minimal set of epitopes to protect a target population [@problem_id:2507799]. This exercise provides a capstone experience, bridging fundamental immunology with the practicalities of computational public health.", "problem": "You are given the task of formalizing and solving a population coverage optimization problem arising from Major Histocompatibility Complex (MHC)-mediated antigen presentation. The goal is to select a minimal set of epitopes such that the fraction of individuals in a target population who have at least one Human Leukocyte Antigen (HLA) allele (at any of several loci) that can present at least one selected epitope is at least a specified threshold. You must encode this as an algorithmic problem and implement a program to solve a fixed test suite.\n\nFundamental base and assumptions:\n- Individuals are diploid at each HLA locus; thus, each locus contributes two alleles per individual.\n- Under Hardy–Weinberg equilibrium and random mating, genotype formation is modeled by independent sampling of two alleles at each locus from the population allele frequency distribution at that locus.\n- Loci are assumed independent (no linkage disequilibrium across loci for the purpose of this calculation).\n- For a chosen set of epitopes, an individual is considered covered if at least one allele at any locus can present at least one selected epitope (binary binding prediction).\n- Let the set of loci be denoted by $\\mathcal{L}$. For each locus $\\ell \\in \\mathcal{L}$, let $\\{(a, p_{\\ell,a})\\}$ denote the set of alleles and their frequencies, with $\\sum_{a} p_{\\ell,a} = 1$. For a selected epitope set $S$, let $C_{\\ell}(S)$ be the set of alleles at locus $\\ell$ that present at least one epitope in $S$; define $s_{\\ell}(S) = \\sum_{a \\in C_{\\ell}(S)} p_{\\ell,a}$ and $q_{\\ell}(S) = 1 - s_{\\ell}(S)$.\n\nYou must:\n1) Formulate the optimization problem using the above base: Choose a minimal-cardinality epitope set $S$ such that the population coverage $\\Phi(S)$ is at least a threshold $\\tau$, where coverage is defined from first principles as the probability that an individual has at least one presenting allele at any locus given the independence assumptions.\n2) Implement two solution methods:\n   - An exact minimal-cardinality search by increasing set size and lexicographic tie-breaking.\n   - A greedy method that iteratively adds the epitope with the largest marginal increase in coverage, using smallest-index tie-breaking when gains are equal.\n3) For each test case, use the specified method to select the indices of epitopes (sorted in ascending order). If no subset reaches the threshold, return the empty list.\n\nMathematical deliverables implicit in your implementation:\n- Derive the locus-wise no-presentation probability from allele frequencies and diploidy.\n- Derive the across-loci no-presentation probability under independence.\n- Construct the coverage $\\Phi(S)$ from these components.\n- Design algorithms consistent with the optimization criterion and tie-breaking rules.\n\nTest suite to implement inside your program (no user input):\n\nTest case 1 (multi-locus, exact search):\n- Loci and allele frequencies:\n  - A: A*01 with $0.25$, A*02 with $0.35$, A*03 with $0.40$.\n  - B: B*07 with $0.20$, B*08 with $0.30$, B*15 with $0.30$, B*44 with $0.20$.\n  - C: C*03 with $0.20$, C*04 with $0.30$, C*06 with $0.25$, C*07 with $0.25$.\n- Epitopes (index to allele bindings):\n  - $0$: A*02; B*08.\n  - $1$: A*03; C*04.\n  - $2$: B*15; C*07.\n  - $3$: A*01; B*07; C*06.\n  - $4$: B*44.\n  - $5$: C*03; C*04.\n  - $6$: A*02; B*15; C*07.\n  - $7$: A*03; B*44; C*06.\n- Threshold $\\tau = 0.90$.\n- Method: exact minimal-cardinality search with lexicographic tie-breaking on index tuples.\n\nTest case 2 (single locus boundary, exact search):\n- Loci and allele frequencies:\n  - DRB1: DRB1*01 with $0.50$, DRB1*03 with $0.30$, DRB1*04 with $0.20$.\n- Epitopes:\n  - $0$: DRB1*01.\n  - $1$: DRB1*03; DRB1*04.\n  - $2$: DRB1*04.\n- Threshold $\\tau = 0.75$.\n- Method: exact minimal-cardinality search with lexicographic tie-breaking.\n\nTest case 3 (single locus impossible, exact search):\n- Loci and allele frequencies:\n  - D: D*01 with $0.60$, D*02 with $0.40$.\n- Epitopes:\n  - $0$: D*01.\n- Threshold $\\tau = 0.85$.\n- Method: exact minimal-cardinality search. Since the maximum possible coverage with all epitopes is less than $\\tau$, return the empty list.\n\nTest case 4 (two loci, greedy search):\n- Loci and allele frequencies:\n  - X: X*01 with $0.60$, X*02 with $0.40$.\n  - Y: Y*01 with $0.50$, Y*02 with $0.50$.\n- Epitopes:\n  - $0$: X*01.\n  - $1$: Y*01.\n  - $2$: X*02; Y*02.\n- Threshold $\\tau = 0.90$.\n- Method: greedy; at each iteration add the epitope that maximizes marginal coverage gain; ties broken by smallest index.\n\nOutput specification:\n- For each test case, output the selected indices of epitopes as a list of integers in ascending order. If no feasible set reaches the threshold, output the empty list.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the same order as listed above. For example, if the results are lists $L_1, L_2, L_3, L_4$, the output must be formatted as “[L1,L2,L3,L4]” with no additional text.\n\nAll probabilities and thresholds must be treated as decimals (e.g., $0.90$) rather than percentages. No physical units are involved. Angles are not involved.", "solution": "The problem presented is a constrained optimization problem derived from the field of immunoinformatics, specifically concerning vaccine design. It asks for the selection of a minimal set of T-cell epitopes to achieve a specified level of population coverage, based on documented Human Leukocyte Antigen (HLA) allele frequencies. The problem statement is scientifically grounded, well-posed, and contains sufficient information and data for a rigorous mathematical and algorithmic treatment. It is therefore deemed valid. We shall proceed with the formal derivation and solution.\n\nFirst, we must formalize the population coverage function, $\\Phi(S)$, for a given set of epitopes $S$. The problem is built upon several foundational assumptions: individuals are diploid at each HLA locus, loci are genetically unlinked (segregate independently), and the population is in Hardy-Weinberg equilibrium.\n\nLet $\\mathcal{L}$ be the set of relevant HLA loci. For each locus $\\ell \\in \\mathcal{L}$, the allele frequencies are given as a set of pairs $\\{(a, p_{\\ell,a})\\}$, where $a$ is an allele and $p_{\\ell,a}$ is its frequency in the population, such that $\\sum_{a} p_{\\ell,a} = 1$.\n\nFor a chosen set of epitopes $S$, let $C_{\\ell}(S)$ be the set of alleles at locus $\\ell$ that are capable of presenting at least one epitope from $S$. The cumulative frequency of these presenting alleles at locus $\\ell$ is denoted by $s_{\\ell}(S)$:\n$$s_{\\ell}(S) = \\sum_{a \\in C_{\\ell}(S)} p_{\\ell,a}$$\nConsequently, the cumulative frequency of non-presenting alleles at locus $\\ell$ is:\n$$q_{\\ell}(S) = 1 - s_{\\ell}(S)$$\nUnder the assumption of Hardy-Weinberg equilibrium, the two alleles at a diploid locus of an individual represent independent draws from the population's allele pool. Therefore, the probability that an individual possesses two non-presenting alleles at locus $\\ell$ is the product of their frequencies:\n$$P(\\text{no presentation at locus } \\ell) = (q_{\\ell}(S))^2$$\nThe problem assumes independence across loci. Thus, the probability that an individual has no presenting alleles at *any* locus is the product of the probabilities of non-presentation at each locus:\n$$P(\\text{no presentation at any locus}) = \\prod_{\\ell \\in \\mathcal{L}} P(\\text{no presentation at locus } \\ell) = \\prod_{\\ell \\in \\mathcal{L}} (q_{\\ell}(S))^2$$\nPopulation coverage, $\\Phi(S)$, is defined as the probability that an individual has *at least one* presenting allele. This is the complement of the event that they have no presenting alleles.\n$$\\Phi(S) = 1 - P(\\text{no presentation at any locus})$$\nThus, the final expression for population coverage is:\n$$\\Phi(S) = 1 - \\prod_{\\ell \\in \\mathcal{L}} \\left(1 - \\sum_{a \\in C_{\\ell}(S)} p_{\\ell,a}\\right)^2$$\n\nWith the coverage function defined, the optimization problem is to find a set of epitopes $S$ that:\n$$\\text{minimizes } |S|$$\n$$\\text{subject to } \\Phi(S) \\ge \\tau$$\nwhere $\\tau$ is the specified minimum coverage threshold. This is a formulation of the set cover problem, which is known to be NP-hard. We are required to implement two distinct algorithms to find a solution.\n\n1.  **Exact Minimal-Cardinality Search**: This algorithm guarantees finding the true minimal set. It operates by iteratively checking all possible epitope subsets in increasing order of size.\n    - First, we calculate the maximum possible coverage $\\Phi_{max}$ by selecting all available epitopes. If $\\Phi_{max} < \\tau$, no solution is possible, and the procedure must terminate.\n    - We then iterate on the subset size $k$, starting from $k=1$ up to the total number of epitopes.\n    - For each $k$, we generate all unique combinations of epitope indices of size $k$. To satisfy the lexicographical tie-breaking rule, these combinations must be generated in lexicographical order.\n    - For each combination $S_k$, we compute $\\Phi(S_k)$. The first combination for which $\\Phi(S_k) \\ge \\tau$ is, by construction, a solution of minimal cardinality and the lexicographically smallest among all solutions of that size. This set is returned as the solution, and the search terminates.\n\n2.  **Greedy Algorithm**: This provides a computationally efficient but heuristic approximation. It may not find the globally minimal set.\n    - The algorithm initializes with an empty set of epitopes, $S = \\emptyset$. A pre-check is performed to ensure the threshold $\\tau$ is reachable at all.\n    - The algorithm proceeds iteratively. In each step, it evaluates every available epitope not yet in $S$. For each candidate epitope $e$, it calculates the marginal gain in coverage that would result from its addition:\n    $$\\Delta\\Phi(e|S) = \\Phi(S \\cup \\{e\\}) - \\Phi(S)$$\n    - The epitope $e^*$ that provides the maximum marginal gain is selected. In case of a tie in gain, the epitope with the smallest index is chosen.\n    - The selected epitope $e^*$ is added to $S$, and the process repeats.\n    - The algorithm terminates when the coverage $\\Phi(S)$ reaches or exceeds the threshold $\\tau$. The final set $S$ is the solution.\n\nThe implementation will apply these two precise methodologies to the provided test cases.", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the population coverage optimization problem for a fixed test suite.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            \"loci_freqs\": {\n                'A': {'A*01': 0.25, 'A*02': 0.35, 'A*03': 0.40},\n                'B': {'B*07': 0.20, 'B*08': 0.30, 'B*15': 0.30, 'B*44': 0.20},\n                'C': {'C*03': 0.20, 'C*04': 0.30, 'C*06': 0.25, 'C*07': 0.25},\n            },\n            \"epitopes\": {\n                0: {'A*02', 'B*08'},\n                1: {'A*03', 'C*04'},\n                2: {'B*15', 'C*07'},\n                3: {'A*01', 'B*07', 'C*06'},\n                4: {'B*44'},\n                5: {'C*03', 'C*04'},\n                6: {'A*02', 'B*15', 'C*07'},\n                7: {'A*03', 'B*44', 'C*06'},\n            },\n            \"threshold\": 0.90,\n            \"method\": \"exact\",\n        },\n        # Test case 2\n        {\n            \"loci_freqs\": {\n                'DRB1': {'DRB1*01': 0.50, 'DRB1*03': 0.30, 'DRB1*04': 0.20},\n            },\n            \"epitopes\": {\n                0: {'DRB1*01'},\n                1: {'DRB1*03', 'DRB1*04'},\n                2: {'DRB1*04'},\n            },\n            \"threshold\": 0.75,\n            \"method\": \"exact\",\n        },\n        # Test case 3\n        {\n            \"loci_freqs\": {\n                'D': {'D*01': 0.60, 'D*02': 0.40},\n            },\n            \"epitopes\": {\n                0: {'D*01'},\n            },\n            \"threshold\": 0.85,\n            \"method\": \"exact\",\n        },\n        # Test case 4\n        {\n            \"loci_freqs\": {\n                'X': {'X*01': 0.60, 'X*02': 0.40},\n                'Y': {'Y*01': 0.50, 'Y*02': 0.50},\n            },\n            \"epitopes\": {\n                0: {'X*01'},\n                1: {'Y*01'},\n                2: {'X*02', 'Y*02'},\n            },\n            \"threshold\": 0.90,\n            \"method\": \"greedy\",\n        }\n    ]\n\n    # Pre-process epitope data to map alleles to loci\n    allele_to_locus_maps = []\n    for case in test_cases:\n        allele_to_locus = {}\n        for locus, freqs in case[\"loci_freqs\"].items():\n            for allele in freqs:\n                allele_to_locus[allele] = locus\n        allele_to_locus_maps.append(allele_to_locus)\n\n    def calculate_coverage(epitope_indices, case_data, allele_to_locus):\n        \"\"\"\n        Calculates the population coverage for a given set of epitope indices.\n        \"\"\"\n        if not epitope_indices:\n            return 0.0\n\n        loci_freqs = case_data[\"loci_freqs\"]\n        all_epitopes = case_data[\"epitopes\"]\n        \n        presenting_alleles_by_locus = collections.defaultdict(set)\n        for epi_idx in epitope_indices:\n            for allele in all_epitopes[epi_idx]:\n                locus = allele_to_locus.get(allele)\n                if locus:\n                    presenting_alleles_by_locus[locus].add(allele)\n\n        no_presentation_prob_product = 1.0\n        for locus, freqs in loci_freqs.items():\n            presenting_alleles = presenting_alleles_by_locus[locus]\n            s_l = sum(freqs.get(allele, 0.0) for allele in presenting_alleles)\n            q_l = 1.0 - s_l\n            no_presentation_prob_product *= (q_l ** 2)\n        \n        return 1.0 - no_presentation_prob_product\n\n    def solve_exact(case_data, allele_to_locus):\n        \"\"\"\n        Solves the problem using an exact minimal-cardinality search.\n        \"\"\"\n        all_epi_indices = list(case_data[\"epitopes\"].keys())\n        threshold = case_data[\"threshold\"]\n\n        # Check if threshold is reachable at all\n        max_coverage = calculate_coverage(all_epi_indices, case_data, allele_to_locus)\n        if max_coverage < threshold:\n            return []\n\n        for k in range(1, len(all_epi_indices) + 1):\n            for epi_subset in combinations(all_epi_indices, k):\n                coverage = calculate_coverage(epi_subset, case_data, allele_to_locus)\n                if coverage >= threshold:\n                    return sorted(list(epi_subset))\n        return []\n\n    def solve_greedy(case_data, allele_to_locus):\n        \"\"\"\n        Solves the problem using a greedy approach.\n        \"\"\"\n        all_epi_indices = list(case_data[\"epitopes\"].keys())\n        threshold = case_data[\"threshold\"]\n        \n        # Check if threshold is reachable at all\n        max_coverage = calculate_coverage(all_epi_indices, case_data, allele_to_locus)\n        if max_coverage < threshold:\n            return []\n\n        selected_epitopes = set()\n        available_epitopes = set(all_epi_indices)\n        current_coverage = 0.0\n\n        while current_coverage < threshold and available_epitopes:\n            best_epitope = -1\n            max_gain = -1.0\n            \n            # Find epitope with the largest marginal gain, tie-breaking by smallest index\n            for epi_idx in sorted(list(available_epitopes)):\n                temp_set = selected_epitopes.union({epi_idx})\n                new_coverage = calculate_coverage(list(temp_set), case_data, allele_to_locus)\n                gain = new_coverage - current_coverage\n                if gain > max_gain:\n                    max_gain = gain\n                    best_epitope = epi_idx\n            \n            if best_epitope != -1:\n                selected_epitopes.add(best_epitope)\n                available_epitopes.remove(best_epitope)\n                current_coverage = calculate_coverage(list(selected_epitopes), case_data, allele_to_locus)\n            else: # No further gain possible\n                break\n\n        if current_coverage >= threshold:\n            return sorted(list(selected_epitopes))\n        else:\n            return []\n\n    results = []\n    for i, case in enumerate(test_cases):\n        allele_to_locus = allele_to_locus_maps[i]\n        if case[\"method\"] == \"exact\":\n            result = solve_exact(case, allele_to_locus)\n        elif case[\"method\"] == \"greedy\":\n            result = solve_greedy(case, allele_to_locus)\n        results.append(result)\n\n    # Format output as specified\n    output_str = f\"[{','.join(map(str, results))}]\".replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2507799"}]}