{"hands_on_practices": [{"introduction": "A protein's ability to function is predicated on its ability to maintain a stable, folded structure. This exercise provides hands-on practice in quantifying this stability by analyzing chemical denaturation data, a cornerstone experimental technique in biophysics [@problem_id:2765810]. You will fit experimental denaturation curves to the canonical two-state model to extract fundamental thermodynamic parameters such as the free energy of folding, $\\Delta G_{\\mathrm{H_2O}}$, and the $m$-value, developing critical data analysis skills.", "problem": "A two-state protein folding system at constant temperature is chemically denatured by a denaturant of concentration $[D]$ (in $\\mathrm{M}$). The observed quantity is the fraction of the native ensemble, $f_N([D])$, measured independently at each $[D]$. Start from the following fundamental base: (i) the thermodynamic definition of the equilibrium constant $K = \\exp(-\\Delta G / (R T))$ relating the Gibbs free energy difference $\\Delta G$ between unfolded and native ensembles to the equilibrium constant via the Boltzmann factor, (ii) the definition of state fractions in a two-state system from the partition function, and (iii) the empirical linear denaturant dependence $\\Delta G([D]) = \\Delta G_{\\mathrm{H_2O}} - m [D]$ at low to moderate denaturant. From these principles, derive the forward model that predicts $f_N([D])$ in terms of $\\Delta G_{\\mathrm{H_2O}}$ (in $\\mathrm{kJ/mol}$), $m$ (in $\\mathrm{kJ/mol/M}$), the gas constant $R$ (in $\\mathrm{kJ/(mol\\cdot K)}$), and the absolute temperature $T$ (in $\\mathrm{K}$). Formulate a nonlinear least-squares objective that estimates $\\Delta G_{\\mathrm{H_2O}}$ and $m$ by minimizing the sum of squared residuals between the measured $f_N([D])$ and the model prediction. Use equal weights for all data points. Estimate the uncertainties (standard errors) of the fitted parameters from residuals by linear error propagation around the optimum: compute the Jacobian of residuals with respect to parameters at the optimum, use the residual variance estimator $\\hat{\\sigma}^2 = \\mathrm{RSS}/(n - p)$ where $n$ is the number of data points and $p$ is the number of fitted parameters, and form the parameter covariance matrix $\\hat{\\sigma}^2 (J^\\top J)^{-1}$; if $J^\\top J$ is ill-conditioned, use the Moore–Penrose pseudoinverse. Report parameter standard errors as the square roots of the diagonal of this covariance matrix. Constrain $m \\ge 0$.\n\nAssume temperature $T = 298.15$ $\\mathrm{K}$ and gas constant $R = 0.008314462618$ $\\mathrm{kJ/(mol\\cdot K)}$. For each of the following three test cases, the denaturant concentrations $[D]$ (in $\\mathrm{M}$) and the measured fractions $f_N$ (dimensionless) are provided. All $f_N$ values are independent measurements.\n\n- Case A (broad transition):\n  $[D] = [0.0, 1.0, 2.0, 3.0, 4.0, 4.5, 5.0, 6.0, 7.0]$,\n  $f_N = [0.999, 0.999, 0.995, 0.946, 0.600, 0.310, 0.118, 0.012, 0.001]$.\n\n- Case B (mid-transition region):\n  $[D] = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]$,\n  $f_N = [0.885, 0.835, 0.770, 0.690, 0.600, 0.500, 0.400]$.\n\n- Case C (partially uninformative at low denaturant, sharp drop near midpoint):\n  $[D] = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0]$,\n  $f_N = [1.000, 1.000, 1.000, 0.983, 0.500, 0.017, 0.000]$.\n\nYour program must, for each case, fit $\\Delta G_{\\mathrm{H_2O}}$ (in $\\mathrm{kJ/mol}$) and $m$ (in $\\mathrm{kJ/mol/M}$) using nonlinear least squares under the two-state model derived from the base described above, and compute their standard errors using the residual-based covariance approximation described above. Produce the results rounded to three decimal places. Express $\\Delta G_{\\mathrm{H_2O}}$ in $\\mathrm{kJ/mol}$, $m$ in $\\mathrm{kJ/mol/M}$, and their standard errors in the same units as their corresponding parameters.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of lists, one inner list per test case, with each inner list ordered as $[\\Delta G_{\\mathrm{H_2O}}, m, s_{\\Delta G_{\\mathrm{H_2O}}}, s_m]$, for example $[[x_{A1},x_{A2},x_{A3},x_{A4}],[x_{B1},x_{B2},x_{B3},x_{B4}],[x_{C1},x_{C2},x_{C3},x_{C4}]]$, where each $x$ is a float rounded to three decimals.", "solution": "The problem statement poses a valid and well-defined task in the domain of biophysical chemistry and data analysis. It is scientifically grounded in the canonical two-state model of protein folding and the linear extrapolation method. The problem is self-contained, providing all necessary data, constants, and a clear description of the required mathematical and statistical procedures. It is free of contradictions, ambiguities, or factual errors. Therefore, a reasoned solution will be provided.\n\nThe task is to estimate the thermodynamic parameters $\\Delta G_{\\mathrm{H_2O}}$ and $m$ from protein denaturation data by fitting a two-state folding model using nonlinear least squares and to calculate the uncertainty of these estimates.\n\nFirst, we derive the forward model for the fraction of native protein, $f_N$, as a function of denaturant concentration, $[D]$. The system is described as a two-state equilibrium between the native ($N$) and unfolded ($U$) states:\n$$ N \\rightleftharpoons U $$\nThe equilibrium constant for this reaction, which represents unfolding, is given by the ratio of the concentrations of the states:\n$$ K = \\frac{[U]}{[N]} $$\nThe problem defines $\\Delta G$ as the Gibbs free energy difference between the unfolded and native ensembles, so $\\Delta G = G_U - G_N$. For a stable, folded protein in the absence of denaturant, $G_N < G_U$, which implies $\\Delta G > 0$. The relationship between the equilibrium constant and $\\Delta G$ is given by the fundamental thermodynamic equation:\n$$ K = \\exp\\left(-\\frac{\\Delta G}{RT}\\right) $$\nwhere $R$ is the gas constant and $T$ is the absolute temperature.\n\nThe observed quantity, $f_N$, is the fraction of the protein molecules in the native state. Expressed in terms of concentrations, this is:\n$$ f_N = \\frac{[N]}{[N] + [U]} $$\nBy dividing the numerator and denominator by $[N]$, we can express $f_N$ in terms of the equilibrium constant $K$:\n$$ f_N = \\frac{1}{1 + \\frac{[U]}{[N]}} = \\frac{1}{1 + K} $$\nSubstituting the expression for $K$ yields the relationship between $f_N$ and $\\Delta G$:\n$$ f_N = \\frac{1}{1 + \\exp\\left(-\\frac{\\Delta G}{RT}\\right)} $$\nThis equation is analogous in form to the Fermi-Dirac distribution.\n\nThe problem states that $\\Delta G$ has an empirical linear dependence on the denaturant concentration $[D]$:\n$$ \\Delta G([D]) = \\Delta G_{\\mathrm{H_2O}} - m[D] $$\nHere, $\\Delta G_{\\mathrm{H_2O}}$ is the Gibbs free energy of unfolding in pure water ($[D]=0$), and the $m$-value quantifies the sensitivity of $\\Delta G$ to the denaturant concentration. Substituting this linear relation into our expression for $f_N$ gives the final forward model:\n$$ f_N([D]; \\Delta G_{\\mathrm{H_2O}}, m) = \\frac{1}{1 + \\exp\\left(-\\frac{\\Delta G_{\\mathrm{H_2O}} - m[D]}{RT}\\right)} $$\nThis model predicts the fraction of native protein at any given denaturant concentration, given the parameters $\\theta = (\\Delta G_{\\mathrm{H_2O}}, m)$.\n\nNext, we formulate the nonlinear least-squares (NLLS) problem to estimate the parameters $\\theta$ from a set of $n$ experimental data points $([D_i], f_{N,i}^{\\text{obs}})$. The goal is to find the parameter values that minimize the sum of squared residuals (RSS) between the observed data and the model predictions. The residual for the $i$-th data point is:\n$$ r_i(\\theta) = f_{N,i}^{\\text{obs}} - f_N([D_i]; \\theta) $$\nThe objective function to minimize is the RSS:\n$$ \\text{RSS}(\\theta) = \\sum_{i=1}^n r_i(\\theta)^2 $$\nThe optimization is performed subject to the physically meaningful constraint that $m \\ge 0$, as denaturants are expected to destabilize the native state, thus decreasing $\\Delta G$.\n\nFinally, we address the estimation of parameter uncertainties. For a nonlinear model, the uncertainties can be approximated by linear error propagation around the optimal parameter set $\\hat{\\theta}$. This method relies on the Jacobian matrix of the residuals, $J$, evaluated at the optimum. The elements of the Jacobian are given by:\n$$ J_{ij} = \\frac{\\partial r_i}{\\partial \\theta_j} \\bigg|_{\\theta=\\hat{\\theta}} $$\nThe number of model parameters is $p=2$. The variance of the measurement error is estimated from the minimized RSS:\n$$ \\hat{\\sigma}^2 = \\frac{\\text{RSS}(\\hat{\\theta})}{n - p} $$\nwhere $n-p$ is the number of degrees of freedom. The parameter covariance matrix, $C$, is then approximated by:\n$$ C = \\hat{\\sigma}^2 (J^\\top J)^{-1} $$\nFor robustness against numerical instability, particularly if $J^\\top J$ is ill-conditioned (which can occur if the data do not sufficiently constrain all parameters), the Moore-Penrose pseudoinverse $(J^\\top J)^+$ is used instead of the standard inverse.\n$$ C = \\hat{\\sigma}^2 (J^\\top J)^+ $$\nThe standard errors (uncertainties) of the estimated parameters are the square roots of the diagonal elements of the covariance matrix:\n$$ s_{\\theta_j} = \\sqrt{C_{jj}} $$\nSpecifically, $s_{\\Delta G_{\\mathrm{H_2O}}} = \\sqrt{C_{11}}$ and $s_m = \\sqrt{C_{22}}$.\n\nThe implementation will utilize the `scipy.optimize.least_squares` function to perform the NLLS fit. This function conveniently provides the optimal parameters and the Jacobian matrix at the solution, which are then used to compute the covariance matrix and standard errors as described. The constants $T = 298.15 \\, \\mathrm{K}$ and $R = 0.008314462618 \\, \\mathrm{kJ/(mol\\cdot K)}$ are used throughout the calculations.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\nfrom scipy.linalg import pinv\n\ndef solve():\n    \"\"\"\n    Fits a two-state protein folding model to denaturation data and calculates parameter uncertainties.\n    \"\"\"\n    # Define constants as specified in the problem\n    T_K = 298.15  # Temperature in Kelvin\n    R_KJ_MOL_K = 0.008314462618  # Gas constant in kJ/(mol*K)\n    RT = R_KJ_MOL_K * T_K\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Case A (broad transition)\n        (np.array([0.0, 1.0, 2.0, 3.0, 4.0, 4.5, 5.0, 6.0, 7.0]),\n         np.array([0.999, 0.999, 0.995, 0.946, 0.600, 0.310, 0.118, 0.012, 0.001])),\n\n        # Case B (mid-transition region)\n        (np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]),\n         np.array([0.885, 0.835, 0.770, 0.690, 0.600, 0.500, 0.400])),\n        \n        # Case C (partially uninformative, sharp drop)\n        (np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0]),\n         np.array([1.000, 1.000, 1.000, 0.983, 0.500, 0.017, 0.000]))\n    ]\n    \n    all_results = []\n\n    for D_M, fN_obs in test_cases:\n        \n        def two_state_model(params, D):\n            \"\"\"\n            Calculates the fraction of native protein based on the two-state model.\n            params[0]: dG_H2O (in kJ/mol)\n            params[1]: m (in kJ/mol/M)\n            \"\"\"\n            dG_H2O, m_val = params\n            delta_G = dG_H2O - m_val * D\n            arg_exp = -delta_G / RT\n            # Use np.exp for vectorized operations\n            return 1.0 / (1.0 + np.exp(arg_exp))\n\n        def residuals(params, D, fN_obs):\n            \"\"\"\n            Calculates the residuals between observed and predicted fN.\n            \"\"\"\n            fN_pred = two_state_model(params, D)\n            return fN_obs - fN_pred\n\n        # Initial guess for parameters [dG_H2O, m].\n        # A positive dG_H2O indicates a stable native state at [D]=0.\n        # An m-value represents the slope of the transition.\n        x0 = np.array([10.0, 5.0]) \n\n        # Bounds for parameters: m must be non-negative.\n        bounds = ([-np.inf, 0], [np.inf, np.inf])\n\n        # Perform the non-linear least squares fit. 'trf' is a good choice for bounds.\n        fit_result = least_squares(residuals, x0, args=(D_M, fN_obs), bounds=bounds, method='trf')\n        \n        # Optimal parameters\n        dG_H2O_fit, m_fit = fit_result.x\n        \n        # Number of data points and parameters\n        n_points = len(D_M)\n        p_params = 2\n        \n        # Degrees of freedom must be positive to estimate variance\n        if n_points <= p_params:\n            s_dG, s_m = np.nan, np.nan\n        else:\n            # Calculate residual sum of squares (RSS)\n            # fit_result.cost is 0.5 * sum(residuals**2)\n            rss = 2 * fit_result.cost\n            \n            # Estimate variance of the error\n            sigma_sq = rss / (n_points - p_params)\n            \n            # Jacobian matrix at the solution\n            J = fit_result.jac\n            \n            # Calculate parameter covariance matrix\n            try:\n                # Use Moore-Penrose pseudoinverse for numerical stability\n                jtj_inv = pinv(J.T @ J)\n                cov_matrix = sigma_sq * jtj_inv\n                \n                # Standard errors are the sqrt of the diagonal elements\n                # Ensure diagonal elements are non-negative before taking sqrt\n                diag_cov = np.diag(cov_matrix)\n                if np.any(diag_cov < 0):\n                    # Should not happen with real data and a decent fit.\n                    # This indicates a severe numerical issue or a very poor model.\n                    std_errors = np.array([np.nan, np.nan])\n                else:\n                    std_errors = np.sqrt(diag_cov)\n                \n                s_dG, s_m = std_errors\n            except np.linalg.LinAlgError:\n                # Fallback in case of a singular matrix that pinv can't handle\n                s_dG, s_m = np.nan, np.nan\n\n        case_results = [\n            round(dG_H2O_fit, 3),\n            round(m_fit, 3),\n            round(s_dG, 3),\n            round(s_m, 3)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    # map(str, all_results) will convert each inner list to its string representation\n    # e.g., '[1.234, 5.678, ...]'\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "2765810"}, {"introduction": "While thermodynamic stability tells us if a protein will fold, kinetics tells us how it folds. This practice delves into the folding pathway by introducing $\\phi$-value analysis, an elegant method for characterizing the structure of the high-energy transition state [@problem_id:2765799]. By calculating $\\phi$-values from mutational kinetic data, you will learn to identify key residues that form the folding nucleus, providing a snapshot of the protein at the very peak of the folding energy barrier.", "problem": "In a synthetic biology design project aimed at engineering folding robustness, you are analyzing a small single-domain protein that folds by a two-state mechanism. You perform classical Transition State Theory (TST) analysis under isothermal conditions and quantify the effects of six alanine-to-glycine point mutations (one per site) on the folding and unfolding rates relative to wild type. Assume the following foundations: (i) classical Transition State Theory with a constant transmission coefficient so that relative rate changes reflect changes in activation free energies, and (ii) a two-state folding mechanism where the equilibrium stability is determined by the ratio of folding and unfolding rates. The temperature is fixed and identical for all measurements, and the wild-type rates are denoted by $k_{f}^{\\mathrm{WT}}$ and $k_{u}^{\\mathrm{WT}}$. For each mutation $i \\in \\{1,2,3,4,5,6\\}$, the observed rate changes are given as fold-change factors relative to wild type at the same temperature:\n- Mutation $1$: $k_{f}^{(1)} = k_{f}^{\\mathrm{WT}} \\,\\exp(-0.2)$, $k_{u}^{(1)} = k_{u}^{\\mathrm{WT}} \\,\\exp(0.8)$\n- Mutation $2$: $k_{f}^{(2)} = k_{f}^{\\mathrm{WT}} \\,\\exp(-1.0)$, $k_{u}^{(2)} = k_{u}^{\\mathrm{WT}} \\,\\exp(0.5)$\n- Mutation $3$: $k_{f}^{(3)} = k_{f}^{\\mathrm{WT}} \\,\\exp(-0.8)$, $k_{u}^{(3)} = k_{u}^{\\mathrm{WT}} \\,\\exp(0.2)$\n- Mutation $4$: $k_{f}^{(4)} = k_{f}^{\\mathrm{WT}} \\,\\exp(-0.6)$, $k_{u}^{(4)} = k_{u}^{\\mathrm{WT}} \\,\\exp(0.3)$\n- Mutation $5$: $k_{f}^{(5)} = k_{f}^{\\mathrm{WT}} \\,\\exp(-0.1)$, $k_{u}^{(5)} = k_{u}^{\\mathrm{WT}} \\,\\exp(0.9)$\n- Mutation $6$: $k_{f}^{(6)} = k_{f}^{\\mathrm{WT}} \\,\\exp(-0.3)$, $k_{u}^{(6)} = k_{u}^{\\mathrm{WT}} \\,\\exp(0.9)$\n\nHere $\\exp(\\cdot)$ denotes the exponential function, and all rate constants are at the same temperature so that the pre-exponential factors in Transition State Theory cancel in ratios. Define the $\\phi$-value for mutation $i$ as the ratio of the mutation-induced change in the folding activation free energy to the mutation-induced change in the equilibrium stability (native-state free energy), both in units of $RT$, where $R$ is the universal gas constant and $T$ is the absolute temperature.\n\nYou are also given a native-state residue-residue contact graph whose vertices are the six mutated sites $\\{1,2,3,4,5,6\\}$ and whose undirected edges indicate side-chain contacts within a $5 \\,\\mathrm{\\AA}$ cutoff in the native structure. The edges are:\n- $\\{1,2\\}$, $\\{2,3\\}$, $\\{3,4\\}$, $\\{4,5\\}$, $\\{5,6\\}$, $\\{2,4\\}$\n\nDefine a $\\phi$-threshold $\\theta = 0.5$. The folding nucleus is operationally defined as the largest connected component of the induced subgraph on the set of residues with $\\phi \\ge \\theta$.\n\nUsing only the above foundations and data, compute the $\\phi$-values for the six mutations, construct the induced subgraph at threshold $\\theta$, and determine the size (number of residues) of the folding nucleus. Report only this size as your final answer. No rounding is required, and the final answer should be an integer without units.", "solution": "The problem requires the determination of the size of a protein folding nucleus based on kinetic data from a series of point mutations. The analysis must be grounded in classical Transition State Theory (TST) and the principles of $\\phi$-value analysis.\n\nFirst, we must formalize the relationship between the given rate constants and the relevant thermodynamic quantities. According to TST, for a reaction with activation free energy $\\Delta G^{\\ddagger}$, the rate constant $k$ at temperature $T$ is given by:\n$$ k = \\kappa \\frac{k_B T}{h} \\exp\\left(-\\frac{\\Delta G^{\\ddagger}}{RT}\\right) $$\nwhere $\\kappa$ is the transmission coefficient, $k_B$ is the Boltzmann constant, and $h$ is the Planck constant. The problem states that $\\kappa$ is constant and all measurements are at the same temperature $T$. For a mutation $i$, the ratio of the mutant rate constant $k^{(i)}$ to the wild-type rate constant $k^{\\mathrm{WT}}$ is:\n$$ \\frac{k^{(i)}}{k^{\\mathrm{WT}}} = \\frac{\\exp\\left(-\\frac{\\Delta G^{\\ddagger, (i)}}{RT}\\right)}{\\exp\\left(-\\frac{\\Delta G^{\\ddagger, \\mathrm{WT}}}{RT}\\right)} = \\exp\\left(-\\frac{\\Delta G^{\\ddagger, (i)} - \\Delta G^{\\ddagger, \\mathrm{WT}}}{RT}\\right) = \\exp\\left(-\\frac{\\Delta \\Delta G^{\\ddagger, (i)}}{RT}\\right) $$\nHere, $\\Delta \\Delta G^{\\ddagger, (i)}$ represents the change in activation free energy due to mutation $i$. Taking the natural logarithm gives the change in activation free energy in units of $RT$:\n$$ \\frac{\\Delta \\Delta G^{\\ddagger, (i)}}{RT} = -\\ln\\left(\\frac{k^{(i)}}{k^{\\mathrm{WT}}}\\right) $$\nThis relation applies to both the folding ($k_f$) and unfolding ($k_u$) processes, with their respective activation free energies $\\Delta G_f^{\\ddagger}$ and $\\Delta G_u^{\\ddagger}$.\n\nThe problem defines the $\\phi$-value for a mutation $i$ as the ratio of the change in the folding activation free energy to the change in the equilibrium free energy of folding (stability), $\\Delta G_{N-U}$:\n$$ \\phi_i = \\frac{\\Delta \\Delta G_{f,i}^{\\ddagger}}{\\Delta \\Delta G_{N-U,i}} $$\nThe change in stability, $\\Delta \\Delta G_{N-U,i}$, can be related to the changes in activation energies. The free energy of folding is $\\Delta G_{N-U} = G_N - G_U$. The activation barriers are defined from the unfolded state $U$ and the native state $N$ to the transition state $TS$: $\\Delta G_f^{\\ddagger} = G_{TS} - G_U$ and $\\Delta G_u^{\\ddagger} = G_{TS} - G_N$. From these definitions, it follows that $\\Delta G_{N-U} = \\Delta G_f^{\\ddagger} - \\Delta G_u^{\\ddagger}$. The change in this quantity upon mutation is:\n$$ \\Delta \\Delta G_{N-U,i} = \\Delta \\Delta G_{f,i}^{\\ddagger} - \\Delta \\Delta G_{u,i}^{\\ddagger} $$\nTherefore, the $\\phi$-value, expressed in units of $RT$, is:\n$$ \\phi_i = \\frac{\\Delta \\Delta G_{f,i}^{\\ddagger}/RT}{\\Delta \\Delta G_{N-U,i}/RT} = \\frac{\\Delta \\Delta G_{f,i}^{\\ddagger}/RT}{\\Delta \\Delta G_{f,i}^{\\ddagger}/RT - \\Delta \\Delta G_{u,i}^{\\ddagger}/RT} $$\nUsing the relationships derived from TST:\n$$ \\frac{\\Delta \\Delta G_{f,i}^{\\ddagger}}{RT} = -\\ln\\left(\\frac{k_f^{(i)}}{k_f^{\\mathrm{WT}}}\\right) \\quad \\text{and} \\quad \\frac{\\Delta \\Delta G_{u,i}^{\\ddagger}}{RT} = -\\ln\\left(\\frac{k_u^{(i)}}{k_u^{\\mathrm{WT}}}\\right) $$\nThe problem provides the values of $\\ln(k_f^{(i)}/k_f^{\\mathrm{WT}})$ and $\\ln(k_u^{(i)}/k_u^{\\mathrm{WT}})$ directly within the exponential terms. Let these values be denoted by $X_i$ and $Y_i$ respectively. So, $k_f^{(i)}/k_f^{\\mathrm{WT}} = \\exp(X_i)$ and $k_u^{(i)}/k_u^{\\mathrm{WT}} = \\exp(Y_i)$.\nThen, $\\Delta \\Delta G_{f,i}^{\\ddagger}/RT = -X_i$ and $\\Delta \\Delta G_{u,i}^{\\ddagger}/RT = -Y_i$. Substituting these into the expression for $\\phi_i$ yields:\n$$ \\phi_i = \\frac{-X_i}{-X_i - (-Y_i)} = \\frac{-X_i}{Y_i - X_i} $$\nWe now compute the $\\phi$-value for each of the $6$ mutations.\n\n- **Mutation 1:** $X_1 = -0.2$, $Y_1 = 0.8$.\n  $$ \\phi_1 = \\frac{-(-0.2)}{0.8 - (-0.2)} = \\frac{0.2}{1.0} = 0.2 $$\n- **Mutation 2:** $X_2 = -1.0$, $Y_2 = 0.5$.\n  $$ \\phi_2 = \\frac{-(-1.0)}{0.5 - (-1.0)} = \\frac{1.0}{1.5} = \\frac{2}{3} $$\n- **Mutation 3:** $X_3 = -0.8$, $Y_3 = 0.2$.\n  $$ \\phi_3 = \\frac{-(-0.8)}{0.2 - (-0.8)} = \\frac{0.8}{1.0} = 0.8 $$\n- **Mutation 4:** $X_4 = -0.6$, $Y_4 = 0.3$.\n  $$ \\phi_4 = \\frac{-(-0.6)}{0.3 - (-0.6)} = \\frac{0.6}{0.9} = \\frac{2}{3} $$\n- **Mutation 5:** $X_5 = -0.1$, $Y_5 = 0.9$.\n  $$ \\phi_5 = \\frac{-(-0.1)}{0.9 - (-0.1)} = \\frac{0.1}{1.0} = 0.1 $$\n- **Mutation 6:** $X_6 = -0.3$, $Y_6 = 0.9$.\n  $$ \\phi_6 = \\frac{-(-0.3)}{0.9 - (-0.3)} = \\frac{0.3}{1.2} = \\frac{1}{4} = 0.25 $$\n\nThe folding nucleus is defined based on a $\\phi$-threshold of $\\theta = 0.5$. The residues that constitute the nucleus are those for which $\\phi_i \\ge \\theta$. We evaluate this condition for each residue:\n- $\\phi_1 = 0.2 < 0.5$\n- $\\phi_2 = 2/3 \\approx 0.667 \\ge 0.5$\n- $\\phi_3 = 0.8 \\ge 0.5$\n- $\\phi_4 = 2/3 \\approx 0.667 \\ge 0.5$\n- $\\phi_5 = 0.1 < 0.5$\n- $\\phi_6 = 0.25 < 0.5$\n\nThe set of residues with $\\phi$-values greater than or equal to the threshold is $S = \\{2, 3, 4\\}$.\nThe folding nucleus is the largest connected component of the induced subgraph on this set $S$. The original graph of residue contacts has vertices $V = \\{1, 2, 3, 4, 5, 6\\}$ and edges $E = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,5\\}, \\{5,6\\}, \\{2,4\\}\\}$.\nThe induced subgraph $G[S]$ contains the vertices $S = \\{2, 3, 4\\}$ and all edges from $E$ that connect pairs of vertices within $S$. We inspect the edge set $E$:\n- The edge $\\{2,3\\}$ connects two vertices in $S$. It is included.\n- The edge $\\{3,4\\}$ connects two vertices in $S$. It is included.\n- The edge $\\{2,4\\}$ connects two vertices in $S$. It is included.\n- All other edges in $E$ have at least one vertex not in $S$ and are therefore excluded.\n\nThe induced subgraph on $S$ consists of the vertices $\\{2, 3, 4\\}$ and the edges $\\{\\{2,3\\}, \\{3,4\\}, \\{2,4\\}\\}$. In this subgraph, every vertex is connected to every other vertex by an edge. Consequently, all three vertices belong to a single connected component.\nThe size of this component is the number of vertices it contains, which is $3$. This is the only component, and thus it is the largest.\nThe size of the folding nucleus is $3$.", "answer": "$$\n\\boxed{3}\n$$", "id": "2765799"}, {"introduction": "Protein folding in a living cell is intricately coupled to its synthesis on the ribosome. This advanced computational exercise explores the complex interplay between translation dynamics and folding outcomes by modeling the co-translational folding process [@problem_id:2765779]. You will implement a simulation based on continuous-time Markov chains to investigate how synonymous codon choices, which modulate the speed of ribosome elongation, can steer a nascent polypeptide towards either a correctly folded or a misfolded state.", "problem": "You are tasked with quantifying, from first principles, how synonymous codon changes that introduce translational pauses alter the probability that a single protein domain misfolds during its co-translational emergence. Formalize co-translational folding as a continuous-time birth-death process over a one-dimensional reaction coordinate representing the nascent chain’s progression toward either a productive native basin or a non-productive misfolded basin. You must implement a program that computes the misfolding probability for a given elongation-rate profile, and then reports the change in misfolding probability induced by introducing pauses at specified codons.\n\nAssumptions and foundational base:\n- Translation elongation by the ribosome is modeled as a sequence of codon additions. The waiting time to elongate any specific codon is exponentially distributed with rate parameter $r_i$ (units: $\\mathrm{s}^{-1}$) at codon index $i$. This is consistent with a Poissonian elongation mechanism where each step is a memoryless event.\n- Co-translational folding dynamics for the emergent domain at a fixed codon index $i$ are modeled as a continuous-time Markov chain (CTMC) with a tridiagonal birth-death generator $Q_i$ over discrete states $\\{0,1,\\dots,K\\}$, where $0$ is an absorbing native state and $K$ is an absorbing misfolded state. Non-absorbing states are $k \\in \\{1,\\dots,K-1\\}$.\n- For $k \\in \\{1,\\dots,K-1\\}$ at codon index $i$, the birth (toward misfold) and death (toward native) transition rates are denoted $\\lambda_i(k)$ and $\\mu_i(k)$, respectively, both in $\\mathrm{s}^{-1}$. The generator $Q_i$ has entries $[Q_i]_{k,k+1}=\\lambda_i(k)$, $[Q_i]_{k,k-1}=\\mu_i(k)$, $[Q_i]_{k,k}=-(\\lambda_i(k)+\\mu_i(k))$, with $[Q_i]_{0,\\cdot}=\\mathbf{0}$ and $[Q_i]_{K,\\cdot}=\\mathbf{0}$ (absorbing boundaries).\n- The codon-dependent bias in the local energy landscape is represented by a scalar weight $w_i>0$ that modulates the forward and reverse rates. The effect of a cytosolic chaperone is represented by a concentration $C$ (units: $\\mu\\mathrm{M}$) that increases the reverse rates $\\mu_i(k)$ according to a linear rescue term.\n\nRate parameterization to be used for all computations:\n- For $k \\in \\{1,\\dots,K-1\\}$ and codon $i$, define base coefficients $a_k$ and $b_k$ by\n  $$\n  a_k \\equiv a_0 \\left(1 + s\\,(k-1)\\right), \\quad b_k \\equiv b_0 \\left(1 + t\\,(K-1-k)\\right),\n  $$\n  with constants $a_0=0.5\\,\\mathrm{s}^{-1}$, $s=0.3$, $b_0=0.8\\,\\mathrm{s}^{-1}$, $t=0.2$.\n- Define the chaperone-rescue scaling as $(1+\\gamma C)$ with $\\gamma=0.06\\,\\mu\\mathrm{M}^{-1}$ and $C$ in $\\mu\\mathrm{M}$.\n- The codon-dependent weight $w_i$ is piecewise:\n  - For $i \\in \\{1,\\dots,24\\}$, set $w_i=0.7$.\n  - For $i \\in \\{25,\\dots,45\\}$, set $w_i=1.8$.\n  - For $i \\in \\{46,\\dots,60\\}$, set $w_i=1.2$.\n- Construct the position-specific rates as\n  $$\n  \\lambda_i(k) = w_i \\, a_k, \\qquad \\mu_i(k) = \\frac{(1+\\gamma C)\\, b_k}{w_i}.\n  $$\n\nElongation-rate profiles:\n- Let the domain length be $L=60$ codons. For each codon $i \\in \\{1,\\dots,L\\}$, the elongation waiting time is exponential with rate $r_i$ (units: $\\mathrm{s}^{-1}$). The baseline profile is constant for a given test case, and the paused profile equals the baseline except in specified windows where $r_i$ is reduced to represent synonymous codon pauses.\n\nFolding trajectory composition:\n- The nascent chain starts at state $k_0=3$ at $i=1$ in all test cases.\n- While the ribosome dwells at codon $i$ for a random time with exponential distribution of rate $r_i$, the CTMC with generator $Q_i$ evolves. After elongation proceeds to codon $i+1$, the generator changes to $Q_{i+1}$. This continues until $i=L$. The native and misfolded states ($0$ and $K$) are absorbing throughout.\n\nObjective:\n- For a given elongation-rate profile $\\{r_i\\}_{i=1}^L$ and chaperone concentration $C$, compute the exact misfolding probability at the end of translation, defined as the probability mass in the absorbing misfolded state $K$ after codon $L$.\n- For each test case, compute two misfolding probabilities: one using the baseline elongation-rate profile and one using the paused profile; report the difference as a float equal to $\\text{paused} - \\text{baseline}$.\n\nFundamental starting point for derivation:\n- Use only the following as starting points: the Central Dogma of Molecular Biology (DNA to RNA to protein), the definition of a continuous-time Markov chain with generator matrix, and the property that exponential waiting times generate memoryless switching of the generator when environments change at random exponential times. You must not assume any pre-derived shortcut formulas beyond these foundations.\n\nTest suite (all with $K=5$, $k_0=3$, $L=60$ codons and $w_i$ as specified above):\n- Case $1$: $C=1.0$. Baseline profile: $r_i=10.0$ for all $i$. Paused profile: $r_i=2.0$ for $i \\in \\{30,31,32,33,34,35\\}$ and $r_i=10.0$ otherwise.\n- Case $2$: $C=5.0$. Baseline profile: $r_i=10.0$ for all $i$. Paused profile: $r_i=2.0$ for $i \\in \\{30,\\dots,45\\}$ and $r_i=10.0$ otherwise.\n- Case $3$: $C=10.0$. Baseline profile: $r_i=10.0$ for all $i$. Paused profile: $r_i=2.0$ for $i \\in \\{30,\\dots,45\\}$ and $r_i=10.0$ otherwise.\n- Case $4$: $C=0.0$. Baseline profile: $r_i=20.0$ for all $i$. Paused profile: $r_i=0.5$ for $i \\in \\{25,\\dots,45\\}$ and $r_i=20.0$ otherwise.\n\nWhat your program must do:\n- Implement the birth-death CTMC with absorbing endpoints as specified.\n- Compose the full co-translational evolution across codons by correctly combining the within-codon dynamics under exponential dwell times and the switching of generators between codons.\n- For each case, compute the misfolding probability for the baseline and paused profiles and output the difference (paused minus baseline) as a float.\n\nAnswer specification and output format:\n- All outputs are dimensionless probabilities. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[x_1,x_2,x_3,x_4]$), where each $x_j$ is the misfolding probability difference for case $j$, rounded to exactly $6$ decimal places.", "solution": "The problem requires the calculation of the probability of protein misfolding under a co-translational folding model. The model is a continuous-time Markov chain (CTMC) for the folding state, whose governing parameters switch at random, exponentially distributed times corresponding to ribosome elongation steps. The solution must be derived from first principles.\n\nLet the state of the system be described by a probability vector $\\mathbf{p}(t) \\in \\mathbb{R}^{K+1}$, where $p_k(t)$ is the probability of the nascent chain being in folding state $k \\in \\{0, 1, \\dots, K\\}$ at time $t$. The states $k=0$ (native) and $k=K$ (misfolded) are absorbing.\n\nThe evolution of the system is partitioned into intervals corresponding to the ribosome dwelling at each codon $i \\in \\{1, \\dots, L\\}$. During the dwell time at codon $i$, denoted $T_i$, the folding dynamics are governed by a constant generator matrix $Q_i$. The probability vector $\\mathbf{p}(t)$ evolves according to the forward master equation:\n$$\n\\frac{d\\mathbf{p}(t)}{dt} = Q_i^T \\mathbf{p}(t)\n$$\nwhere $Q_i^T$ is the transpose of the generator matrix $Q_i$. The formal solution, given a distribution $\\mathbf{p}_{\\text{start}}$ at the beginning of the interval, is\n$$\n\\mathbf{p}(t) = e^{Q_i^T t} \\mathbf{p}_{\\text{start}}\n$$\n\nThe dwell time $T_i$ is not a fixed value but a random variable following an exponential distribution with rate parameter $r_i$, i.e., $T_i \\sim \\text{Exp}(r_i)$. The probability density function is $f_{T_i}(t) = r_i e^{-r_i t}$ for $t \\ge 0$. To find the probability distribution at the end of this random interval, one must average the solution over all possible values of $t$, weighted by this density.\n\nLet $\\mathbf{p}_i$ be the probability distribution vector at the precise moment the ribosome begins processing codon $i$. The distribution at the start of the subsequent codon, $\\mathbf{p}_{i+1}$, is the expectation of the evolved state over the random dwell time $T_i$:\n$$\n\\mathbf{p}_{i+1} = \\mathbb{E}_{T_i \\sim \\text{Exp}(r_i)} \\left[ e^{Q_i^T T_i} \\mathbf{p}_i \\right]\n$$\nBy the law of the unconscious statistician, this expectation is computed by the integral:\n$$\n\\mathbf{p}_{i+1} = \\int_{0}^{\\infty} \\left( e^{Q_i^T t} \\mathbf{p}_i \\right) (r_i e^{-r_i t}) dt\n$$\nSince $\\mathbf{p}_i$ is a constant with respect to the integration variable $t$, it can be factored out:\n$$\n\\mathbf{p}_{i+1} = \\left( r_i \\int_{0}^{\\infty} e^{-r_i t} e^{Q_i^T t} dt \\right) \\mathbf{p}_i\n$$\nThe integral expression is the definition of the Laplace transform of the matrix exponential $e^{Q_i^T t}$, evaluated at $s=r_i$. The Laplace transform of $e^{At}$ is $(sI - A)^{-1}$. Applying this fundamental property, we obtain:\n$$\n\\int_{0}^{\\infty} e^{-s t} e^{Q_i^T t} dt = (sI - Q_i^T)^{-1}\n$$\nSubstituting $s = r_i$, the update rule for the probability vector becomes:\n$$\n\\mathbf{p}_{i+1} = M_i \\mathbf{p}_i, \\quad \\text{where} \\quad M_i = r_i (r_i I - Q_i^T)^{-1}\n$$\nThe matrix $M_i$ acts as a propagator, mapping the probability distribution from the start of codon $i$ to the start of codon $i+1$.\n\nThe entire process of translation from codon $i=1$ to $i=L$ is a sequence of such propagation steps. The initial condition is given at the start of codon $1$: the nascent chain begins in state $k_0$. This corresponds to an initial probability vector $\\mathbf{p}_1$ where the entry at index $k_0$ is $1$ and all other entries are $0$.\nThe distribution at the start of codon $2$ is $\\mathbf{p}_2 = M_1 \\mathbf{p}_1$.\nThe distribution at the start of codon $3$ is $\\mathbf{p}_3 = M_2 \\mathbf{p}_2 = M_2 M_1 \\mathbf{p}_1$.\nThis iterative process continues for all $L$ codons. The final probability distribution, after the dwell time at codon $L$ has elapsed, is given by:\n$$\n\\mathbf{p}_{\\text{final}} = M_L M_{L-1} \\cdots M_2 M_1 \\mathbf{p}_1\n$$\nThe probability of misfolding is the component of this final vector corresponding to the absorbing misfolded state $K$. Let our states be indexed $\\{0, 1, \\dots, K\\}$. Then the misfolding probability $P_{\\text{misfold}}$ is the element of $\\mathbf{p}_{\\text{final}}$ at index $K$:\n$$\nP_{\\text{misfold}} = [\\mathbf{p}_{\\text{final}}]_K\n$$\n\nThe algorithm for the computation proceeds as follows:\n1.  Initialize constants as per the problem statement: $K=5$, $k_0=3$, $L=60$, and the biophysical parameters $a_0$, $s$, $b_0$, $t$, $\\gamma$.\n2.  Pre-compute the state-dependent but codon-independent rate coefficients $a_k$ and $b_k$ for $k \\in \\{1, \\dots, K-1\\}$.\n3.  For each test case (defined by a chaperone concentration $C$ and two elongation profiles, `baseline` and `paused`), execute the following computational loop twice, once for each profile.\n4.  For a given profile, initialize the probability vector $\\mathbf{p}$ of size $(K+1)$ with a $1$ at index $k_0=3$ and $0$ elsewhere.\n5.  Iterate through codons $i$ from $1$ to $L$. In each iteration:\n    a. Determine the codon-dependent weight $w_i$ and the elongation rate $r_i$ from the profile.\n    b. Calculate the folding rates $\\lambda_i(k) = w_i a_k$ and $\\mu_i(k) = (1+\\gamma C) b_k / w_i$.\n    c. Construct the $(K+1) \\times (K+1)$ generator matrix $Q_i$ for a birth-death process on states $\\{1, \\dots, K-1\\}$ with absorbing boundaries at $0$ and $K$. The non-zero off-diagonal elements are $[Q_i]_{k, k+1} = \\lambda_i(k)$ and $[Q_i]_{k, k-1} = \\mu_i(k)$ for states $k$ that are not boundaries. The diagonal elements are $[Q_i]_{k,k} = -(\\sum_{j \\ne k} Q_{k,j})$. The rows for states $0$ and $K$ are zero.\n    d. Compute the propagator matrix $M_i = r_i (r_i I - Q_i^T)^{-1}$ using numerical linear algebra, specifically matrix inversion.\n    e. Update the probability vector: $\\mathbf{p} \\leftarrow M_i \\mathbf{p}$.\n6.  After iterating through all $L$ codons, the final vector $\\mathbf{p}$ is obtained. The misfolding probability is the element $\\mathbf{p}[K]$.\n7.  After computing the misfolding probability for both `baseline` ($P_{\\text{base}}$) and `paused` ($P_{\\text{paused}}$) profiles, calculate the difference $\\Delta P = P_{\\text{paused}} - P_{\\text{base}}$.\n8.  The final output is a list of these differences for all test cases.\n\nThis procedure constitutes a complete and exact solution to the problem as formulated. It is derived directly from the definition of a continuous-time Markov chain and the properties of the exponential distribution, as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import inv\n\ndef solve():\n    \"\"\"\n    Computes the change in misfolding probability due to translational pauses\n    based on a co-translational folding model.\n    \"\"\"\n    \n    # Define problem constants and parameters\n    K = 5\n    k0 = 3\n    L = 60\n    a0 = 0.5\n    s = 0.3\n    b0 = 0.8\n    t = 0.2\n    gamma = 0.06\n\n    # Pre-calculate state-dependent but codon-independent rate coefficients\n    # k runs from 1 to K-1=4\n    k_vals = np.arange(1, K)\n    a_k_base = a0 * (1 + s * (k_vals - 1))\n    b_k_base = b0 * (1 + t * (K - 1 - k_vals))\n\n    def get_w(i):\n        \"\"\"Returns the codon-dependent weight w_i for codon i.\"\"\"\n        if 1 <= i <= 24:\n            return 0.7\n        elif 25 <= i <= 45:\n            return 1.8\n        elif 46 <= i <= 60:\n            return 1.2\n        else:\n            # This case should not be reached with L=60\n            raise ValueError(\"Codon index out of bounds\")\n\n    def calculate_misfolding_prob(C, r_profile):\n        \"\"\"\n        Calculates the final misfolding probability for a given chaperone\n        concentration and elongation rate profile.\n        \"\"\"\n        # Initialize probability vector p, with the system starting in state k0\n        p = np.zeros(K + 1)\n        p[k0] = 1.0\n\n        # Calculate chaperone rescue factor\n        chaperone_factor = 1 + gamma * C\n\n        # Iterate through all codons from 1 to L\n        for i in range(1, L + 1):\n            wi = get_w(i)\n            ri = r_profile[i - 1] # r_profile is 0-indexed\n\n            # Calculate position-specific rates lambda_i(k), mu_i(k)\n            # These are for k in {1, ..., K-1}\n            lambda_i = wi * a_k_base\n            mu_i = (chaperone_factor * b_k_base) / wi\n\n            # Build the generator matrix Q_i of size (K+1)x(K+1)\n            Q = np.zeros((K + 1, K + 1))\n            \n            # Populate Q for intermediate states k=1 to K-1 (indices 1 to 4)\n            for k_idx, k in enumerate(range(1, K)):\n                lam = lambda_i[k_idx]\n                mu = mu_i[k_idx]\n                \n                Q[k, k + 1] = lam  # Transition k -> k+1\n                Q[k, k - 1] = mu   # Transition k -> k-1\n                Q[k, k] = -(lam + mu) # Total rate out of k\n\n            # Propagator matrix M_i = r_i * inv(r_i * I - Q_i^T)\n            I = np.identity(K + 1)\n            Q_T = Q.T\n            M = ri * inv(ri * I - Q_T)\n\n            # Update probability vector: p_{i+1} = M_i * p_i\n            p = M @ p\n        \n        # Final misfolding probability is the probability in the last state, K\n        misfolding_prob = p[K]\n        return misfolding_prob\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case 1\n        {\"C\": 1.0, \"r_base_val\": 10.0, \"r_paused_val\": 2.0, \"pause_window\": (30, 35)},\n        # Case 2\n        {\"C\": 5.0, \"r_base_val\": 10.0, \"r_paused_val\": 2.0, \"pause_window\": (30, 45)},\n        # Case 3\n        {\"C\": 10.0, \"r_base_val\": 10.0, \"r_paused_val\": 2.0, \"pause_window\": (30, 45)},\n        # Case 4\n        {\"C\": 0.0, \"r_base_val\": 20.0, \"r_paused_val\": 0.5, \"pause_window\": (25, 45)},\n    ]\n\n    results = []\n    for case in test_cases:\n        C = case[\"C\"]\n        r_base_val = case[\"r_base_val\"]\n        r_paused_val = case[\"r_paused_val\"]\n        start, end = case[\"pause_window\"]\n        \n        # Create baseline and paused elongation rate profiles\n        r_base_profile = np.full(L, r_base_val)\n        \n        r_paused_profile = np.full(L, r_base_val)\n        # Apply pause (note: 1-based index from problem to 0-based Python slicing)\n        r_paused_profile[start - 1 : end] = r_paused_val\n\n        # Calculate misfolding probability for both profiles\n        prob_base = calculate_misfolding_prob(C, r_base_profile)\n        prob_paused = calculate_misfolding_prob(C, r_paused_profile)\n        \n        # The result is the difference: paused - baseline\n        diff = prob_paused - prob_base\n        results.append(diff)\n\n    # Format the final output string as specified\n    output_str = \",\".join([f\"{res:.6f}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2765779"}]}