{"hands_on_practices": [{"introduction": "The journey from gene to protein culminates in translation, where the nucleotide language of messenger RNA ($mRNA$) is read to build a polypeptide chain. This first exercise provides fundamental practice in this process. By following the rules of the genetic code, you will learn to identify the start of a message, parse it into three-letter \"words\" called codons, and translate them into the correct sequence of amino acids until a stop signal is reached.", "problem": "A molecular biologist has isolated a short fragment of a mature messenger Ribonucleic Acid (mRNA) from a novel thermophilic bacterium. The sequence of this mRNA fragment, read from the 5' to the 3' end, is:\n\n5'-GCAUGGUUAGCAGCACGUAG-3'\n\nTranslation of this mRNA into a polypeptide chain begins at the first start codon (AUG) and terminates upon reaching the first in-frame stop codon. Using the provided standard genetic code table, determine the correct amino acid sequence of the polypeptide synthesized from this mRNA fragment.\n\n**Genetic Code Table (Codon -> Amino Acid):**\n\n*   **Alanine (Ala):** GCU, GCC, GCA, GCG\n*   **Arginine (Arg):** CGU, CGC, CGA, CGG, AGA, AGG\n*   **Asparagine (Asn):** AAU, AAC\n*   **Aspartic acid (Asp):** GAU, GAC\n*   **Cysteine (Cys):** UGU, UGC\n*   **Glutamic acid (Glu):** GAA, GAG\n*   **Glutamine (Gln):** CAA, CAG\n*   **Glycine (Gly):** GGU, GGC, GGA, GGG\n*   **Histidine (His):** CAU, CAC\n*   **Isoleucine (Ile):** AUU, AUC, AUA\n*   **Leucine (Leu):** UUA, UUG, CUU, CUC, CUA, CUG\n*   **Lysine (Lys):** AAA, AAG\n*   **Methionine (Met) / START:** AUG\n*   **Phenylalanine (Phe):** UUU, UUC\n*   **Proline (Pro):** CCU, CCC, CCA, CCG\n*   **Serine (Ser):** UCU, UCC, UCA, UCG, AGU, AGC\n*   **Threonine (Thr):** ACU, ACC, ACA, ACG\n*   **Tryptophan (Trp):** UGG\n*   **Tyrosine (Tyr):** UAU, UAC\n*   **Valine (Val):** GUU, GUC, GUA, GUG\n*   **STOP:** UAA, UAG, UGA\n\nWhich of the following represents the correct polypeptide sequence?\n\nA. Ala-Trp-Leu-Ala-Ala-Arg\n\nB. Met-Val-Ser-Ser-Thr\n\nC. Ala-Gly-Ser-Ser-Thr\n\nD. Met-Val-Ser-Ser-Thr-Tyr\n\nE. Met-Gly-Ser-Ser-Thr-Arg", "solution": "Principles:\n- Translation of mRNA begins at the first start codon AUG encountered by the scanning ribosome from the 5' end and proceeds in that reading frame.\n- Codons are read in non-overlapping triplets from the start site until the first in-frame stop codon (UAA, UAG, or UGA).\n\nProcedure:\n1) The given mRNA (5' to 3') is GCAUGGUUAGCAGCACGUAG. Scan for the first AUG. The first AUG occurs starting at the third nucleotide, yielding the reading frame beginning with AUG.\n\n2) Partition the sequence into codons from that AUG:\nAUG GUU AGC AGC ACG UAG\n\n3) Translate each codon using the provided genetic code:\n- AUG → Methionine (Met), start\n- GUU → Valine (Val)\n- AGC → Serine (Ser)\n- AGC → Serine (Ser)\n- ACG → Threonine (Thr)\n- UAG → Stop\n\n4) The polypeptide sequence synthesized is Met-Val-Ser-Ser-Thr, terminating at the UAG stop codon.\n\n5) Match with the options: this corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1527156"}, {"introduction": "The genetic code is read in a specific, non-overlapping triplet frame, and maintaining this frame is critical for producing a functional protein [@problem_id:1527156]. This practice explores the dramatic consequences of frameshift mutations, which alter the reading frame and often lead to a completely nonfunctional protein. You will analyze how an initial 'plus-one' insertion mutation, a $+1$ shift, is 'rescued' by a subsequent deletion, a classic example of a suppressor mutation that restores the original reading frame and protein function.", "problem": "A geneticist is studying a hypothetical gene in *Escherichia coli*. The coding sequence of the Messenger Ribonucleic Acid (mRNA) transcribed from this gene begins as follows:\n\n`5'-AUG CCU GGC UAU GCA AGU UGU AAA GAG CUU UAG-3'`\n\nA spontaneous mutation occurs, causing the insertion of a single Guanine (G) nucleotide immediately after the 6th nucleotide (the Uracil of the second codon). This mutation results in a truncated, nonfunctional protein.\n\nTo recover a functional version of the protein, the geneticist screens for secondary \"suppressor\" mutations. Which of the following independent, secondary mutations in the already-mutated gene is most likely to restore the synthesis of a near-normal length and largely functional protein?\n\nFor your analysis, use the following partial codon table:\n- `AUG`: Methionine (Start)\n- `CCU`: Proline\n- `GGC`, `GGG`: Glycine\n- `UAU`: Tyrosine\n- `CAU`: Histidine\n- `CUA`: Leucine\n- `GCA`: Alanine\n- `AGU`: Serine\n- `UAA`, `UAG`: Stop\n\nA. A second insertion of a single Cytosine (C) nucleotide after the 12th nucleotide of the original sequence.\n\nB. A deletion of the single Uracil (U) nucleotide at the 10th position of the original sequence.\n\nC. A substitution of the Cytosine (C) at the 13th position of the original sequence with an Adenine (A).\n\nD. A deletion of the three consecutive nucleotides 'GGC' which correspond to positions 7, 8, and 9 of the original sequence.", "solution": "Interpret the original mRNA and its codons. The sequence is\n5'-AUG CCU GGC UAU GCA AGU UGU AAA GAG CUU UAG-3',\nwhich groups into codons as\nAUG | CCU | GGC | UAU | GCA | AGU | UGU | AAA | GAG | CUU | UAG.\nUsing the provided codon table, this translates as Met–Pro–Gly–Tyr–Ala–Ser–Cys–Lys–Glu–Leu–Stop.\n\nApply the first mutation: insertion of a single G immediately after the sixth nucleotide (after the U of CCU). To track positions, define the mapping from original positions $p$ to indices in the once-mutated sequence as\n$$\nf(p)=\\begin{cases}\np, & p\\leq 6,\\\\\np+1, & p\\geq 7.\n\\end{cases}\n$$\nThe once-mutated sequence becomes (indexing shown for clarity)\n1 A, 2 U, 3 G, 4 C, 5 C, 6 U, 7 G (inserted), 8 G (orig 7), 9 G (orig 8), 10 C (orig 9), 11 U (orig 10), 12 A (orig 11), 13 U (orig 12), 14 G (orig 13), 15 C (orig 14), 16 A (orig 15), 17 A (orig 16), 18 G (orig 17), 19 U (orig 18), 20 U (orig 19), 21 G (orig 20), 22 U (orig 21), 23 A (orig 22), 24 A (orig 23), 25 A (orig 24), 26 G (orig 25), 27 A (orig 26), 28 G (orig 27), 29 C (orig 28), 30 U (orig 29), 31 U (orig 30), 32 U (orig 31), 33 A (orig 32), 34 G (orig 33).\nReading from the start codon, the new codons are\nAUG | CCU | GGG | CUA | UGC | AAG | UUG | UAA | …\nThus, a premature stop $UAA$ appears at positions 22–24 in the mutated sequence, yielding a truncated protein.\n\nEvaluate each proposed secondary mutation on this already-mutated gene.\n\nA. Insert a single C after the 12th nucleotide of the original sequence. In the once-mutated sequence this is after index $f(12)=13$. A second single-nucleotide insertion gives a net frameshift of $+2$ (since $+1 + 1 \\equiv 2 \\pmod{3}$), which does not restore the original reading frame. Indeed, although this additional insertion can move the premature stop out of frame at that local region, the reading frame remains incorrect throughout, producing a largely altered amino acid sequence rather than a near-normal protein. Therefore, this does not plausibly restore a near-normal, largely functional protein.\n\nB. Delete the single U at the 10th position of the original sequence. In the once-mutated sequence, the nucleotide originally at position 10 is at index $f(10)=11$, so delete index 11. After deleting that U, the sequence realigns the reading frame because the net indel is $+1$ (first insertion) and $-1$ (this deletion), giving $+1 - 1 = 0$, i.e., no net frameshift. Explicitly, the codons then become\nAUG | CCU | GGG | CAU | GCA | AGU | UGU | AAA | GAG | CUU | UAG.\nRelative to the original, the third codon changes from GGC to GGG (both Gly; a synonymous change), and the fourth codon changes from UAU (Tyr) to CAU (His), after which all downstream codons exactly match the original through the stop. This yields a near-normal length protein with only a single amino acid substitution beyond a synonymous change, which is the hallmark of a frameshift suppressor restoring function.\n\nC. Substitute the nucleotide at original position 13 with A. In the once-mutated sequence this alters index $f(13)=14$. A single-nucleotide substitution does not change the frameshift; the reading frame remains $+1$ out of register, and the premature stop $UAA$ at positions 22–24 persists, so the truncation remains. Moreover, the option text refers to a cytosine at position 13, whereas the provided sequence has a guanine at that position; regardless, a substitution at this site cannot suppress the frameshift.\n\nD. Delete the three nucleotides GGC at original positions 7–9. In the once-mutated sequence this removes indices $f(7)=8$, $f(8)=9$, and $f(9)=10$. The net indel becomes $+1 - 3 = -2 \\equiv 1 \\pmod{3}$, so the reading frame remains shifted. Indeed, reading after this deletion produces an early $UAA$ stop and a truncated protein. Thus this does not restore a near-normal, largely functional protein.\n\nBy the principle of frameshift suppression, only an additional single-nucleotide deletion downstream of the original single-nucleotide insertion will restore the original reading frame and, if positioned early, will minimize amino acid changes. Option B does exactly this and yields a near-normal length, largely functional protein.", "answer": "$$\\boxed{B}$$", "id": "1527164"}, {"introduction": "To fully master the principles of the genetic code, it is powerful to model them computationally. This advanced practice challenges you to implement the process of translation as an algorithm, accounting for variables like reading frames, $f \\in \\{0, 1, 2\\}$, and the alternative genetic codes found in different organisms [@problem_id:1527164]. By building a flexible translation tool, you will gain a deeper, more systematic understanding of how the Central Dogma's rules are applied and how variations in the code impact the final protein product.", "problem": "Write a complete, runnable program that implements translation of a deoxyribonucleic acid (DNA) sequence into an amino acid sequence using an arbitrary genetic code table provided as a parameter. The design must follow from the Central Dogma of Molecular Biology and standard definitions: DNA is read in triplets called codons, and each codon maps to one amino acid or a stop signal according to a genetic code mapping (a function from the set of all $64$ possible codons over $\\{A,C,G,T\\}$ to the $20$ canonical amino acids plus a stop symbol, written as $*$). Translation proceeds sequentially in a specified reading frame offset $f \\in \\{0,1,2\\}$ and ignores any trailing nucleotides that do not form a complete triplet. The genetic code is not assumed to be the canonical nuclear code; instead, your program must accept an arbitrary code table, where unspecified codons default to the canonical Standard Genetic Code (National Center for Biotechnology Information (NCBI) Code $1$). The program must not read any input; it must internally define its test suite and print the required final output.\n\nYour translation procedure must implement two policies:\n- Given a boolean parameter $b_{\\text{truncate}}$, if $b_{\\text{truncate}} = \\text{True}$, translation stops at the first encountered stop codon and the stop is not included in the peptide sequence; if $b_{\\text{truncate}} = \\text{False}$, translation continues through the entire readable region and stop codons are represented conceptually by the symbol $*$ (but you will not output strings; see below for numeric outputs).\n- The reading frame is an integer $f \\in \\{0,1,2\\}$, so translation uses codons at indices $f, f+3, f+6, \\dots$ up to the last complete codon.\n\nFor each test case, compute and return a list of three integers $[L,S,D]$ defined as follows:\n- $L$: the number of amino acids produced by translation under the provided code table with the specified $b_{\\text{truncate}}$ and reading frame $f$. If $b_{\\text{truncate}} = \\text{True}$, $L$ counts the amino acids before the first stop codon (the stop is excluded). If $b_{\\text{truncate}} = \\text{False}$, $L$ counts the number of non-stop codons translated across the entire readable region (stop codons do not contribute to $L$).\n- $S$: the number of stop codons encountered. If $b_{\\text{truncate}} = \\text{True}$, then $S$ is $1$ if a stop codon occurs and $0$ otherwise. If $b_{\\text{truncate}} = \\text{False}$, then $S$ is the total number of stop codons encountered across the entire readable region.\n- $D$: the Hamming distance between the translation under the provided code table and the translation under the Standard Genetic Code (NCBI Code $1$), computed codon-by-codon across all complete codons in the reading frame (from the first complete codon at index $f$ to the last complete codon) with no truncation, treating stop as the symbol $*$. This means $D$ is the count of positions where the two translations differ, including differences where one code yields $*$ and the other yields an amino acid.\n\nBase facts you may assume:\n- A codon is a word of length $3$ over the alphabet $\\{A,C,G,T\\}$, thus there are $4^3 = 64$ possible codons.\n- The Standard Genetic Code (NCBI Code $1$) assigns each of the $64$ codons to one of the $20$ amino acids or to a stop signal $*$; it is well established and may be hard-coded.\n- A non-standard code table can be represented by a partial mapping that overrides some codon assignments; any codon not overridden follows the Standard Genetic Code.\n\nImplement and run your program on the following test suite (each test case is a tuple consisting of a DNA sequence, a code identifier string, a reading frame $f$, and the boolean $b_{\\text{truncate}}$):\n- Test $1$: sequence $=$ \"ATGACCTGAAGGAGATAG\", code $=$ \"vertebrate\\_mitochondrial\", $f = 0$, $b_{\\text{truncate}} = \\text{True}$. The vertebrate mitochondrial code overrides the Standard Genetic Code by assigning $ATA \\mapsto M$, $TGA \\mapsto W$, $AGA \\mapsto *$, and $AGG \\mapsto *$; all other codons follow the Standard Genetic Code.\n- Test $2$: sequence $=$ \"ATGACCTGAAGGAGATAG\", code $=$ \"vertebrate\\_mitochondrial\", $f = 0$, $b_{\\text{truncate}} = \\text{False}$.\n- Test $3$: sequence $=$ \"GCCATAACCTGACTAG\", code $=$ \"custom\\_engineered\", $f = 1$, $b_{\\text{truncate}} = \\text{False}$. The custom engineered code overrides the Standard Genetic Code by assigning $TAA \\mapsto Q$, $TAG \\mapsto Q$, $TGA \\mapsto E$, and $AGG \\mapsto *$; all other codons follow the Standard Genetic Code.\n- Test $4$: sequence $=$ \"A\", code $=$ \"custom\\_engineered\", $f = 0$, $b_{\\text{truncate}} = \\text{True}$.\n\nYour program must produce a single line of output containing the results for the tests in order as a comma-separated list of lists, with no extra whitespace and enclosed in square brackets. The required format is exactly:\n\"[[L_1,S_1,D_1],[L_2,S_2,D_2],[L_3,S_3,D_3],[L_4,S_4,D_4]]\"\nwhere $L_i, S_i, D_i$ are the integers defined above for test $i$ (for example, \"[[$L_1$,$S_1$,$D_1$],[$L_2$,$S_2$,$D_2$],[$L_3$,$S_3$,$D_3$],[$L_4$,$S_4$,$D_4$]]\").", "solution": "The core of this problem is to create a flexible translation algorithm. The provided Python code implements this by first establishing the genetic codes as dictionary data structures. A complete `STANDARD_CODE` dictionary maps all 64 codons to their corresponding amino acids or a stop symbol (`*`). Custom codes, like `vertebrate_mitochondrial`, are created by making a copy of this standard code and then applying the specified overrides. This modular approach ensures that any unspecified codon in a custom table correctly defaults to its standard meaning.\n\nThe main translation logic is encapsulated in the `calculate_metrics` function. It takes a DNA sequence, a code identifier, a reading frame `f`, and a truncation flag `b_truncate` as input.\n1.  **Codon Parsing:** It first parses the DNA sequence into a list of non-overlapping, three-nucleotide codons, starting from the offset specified by the reading frame `f`. Any trailing nucleotides that do not form a full codon are ignored.\n2.  **Metric Calculation:**\n    - **Hamming Distance (D):** This is calculated first, as it always processes the entire sequence without truncation. The function iterates through the list of codons, translates each one using both the custom code and the standard code, and increments a counter `d_val` every time the two translations differ. This includes differences between an amino acid and a stop symbol.\n    - **Peptide Length (L) and Stop Count (S):** The calculation of these metrics depends on `b_truncate`. If `True`, the function iterates through the codons, counting amino acids until it encounters a stop symbol, at which point it sets `s_val` to 1 and stops. If `False`, it iterates through all codons, tallying the total counts of amino acids (`l_val`) and stop symbols (`s_val`) separately.\n\nFinally, the program defines the test suite from the problem description, calls `calculate_metrics` for each case, and formats the collected results `[L, S, D]` for each test into the required string format. This structured approach correctly models the biological process of translation while providing the flexibility to handle different genetic codes and analysis rules.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other non-standard libraries are used.\n\ndef solve():\n    \"\"\"\n    Implements DNA to protein translation and calculates specified metrics.\n    \"\"\"\n    \n    # The Standard Genetic Code (NCBI Code 1)\n    STANDARD_CODE = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',\n        'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n    }\n\n    # Definitions for custom genetic codes as overrides\n    CUSTOM_CODE_OVERRIDES = {\n        \"vertebrate_mitochondrial\": {\n            \"ATA\": \"M\",  # I -> M\n            \"TGA\": \"W\",  # * -> W\n            \"AGA\": \"*\",  # R -> *\n            \"AGG\": \"*\",  # R -> *\n        },\n        \"custom_engineered\": {\n            \"TAA\": \"Q\",  # * -> Q\n            \"TAG\": \"Q\",  # * -> Q\n            \"TGA\": \"E\",  # * -> E\n            \"AGG\": \"*\",  # R -> *\n        },\n    }\n\n    def get_custom_code(code_id: str) -> dict:\n        \"\"\"\n        Generates a custom genetic code dictionary by overriding the standard code.\n        \"\"\"\n        if code_id not in CUSTOM_CODE_OVERRIDES:\n            return STANDARD_CODE.copy()\n        \n        custom_code = STANDARD_CODE.copy()\n        overrides = CUSTOM_CODE_OVERRIDES[code_id]\n        custom_code.update(overrides)\n        return custom_code\n\n    def calculate_metrics(dna_sequence, code_id, frame, b_truncate):\n        \"\"\"\n        Calculates L, S, and D for a single test case.\n        \"\"\"\n        custom_code = get_custom_code(code_id)\n\n        # Extract all codons for the given reading frame\n        codons = [\n            dna_sequence[i:i + 3]\n            for i in range(frame, len(dna_sequence) - 2, 3)\n        ]\n\n        if not codons:\n            return [0, 0, 0]\n\n        # --- Calculate D (Hamming Distance) ---\n        # D is always calculated untruncated over all codons.\n        d_val = 0\n        for codon in codons:\n            translation_custom = custom_code.get(codon, '?')\n            translation_standard = STANDARD_CODE.get(codon, '?')\n            if translation_custom != translation_standard:\n                d_val += 1\n        \n        # --- Calculate L (Length) and S (Stops) ---\n        l_val = 0\n        s_val = 0\n        if b_truncate:\n            for codon in codons:\n                symbol = custom_code.get(codon, '?')\n                if symbol == '*':\n                    s_val = 1\n                    break\n                else:\n                    l_val += 1\n            # If loop completes without break, no stop was found\n            else:\n                s_val = 0\n        else: # b_truncate is False\n            for codon in codons:\n                symbol = custom_code.get(codon, '?')\n                if symbol == '*':\n                    s_val += 1\n                else:\n                    l_val += 1\n        \n        return [l_val, s_val, d_val]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"ATGACCTGAAGGAGATAG\", \"vertebrate_mitochondrial\", 0, True),\n        (\"ATGACCTGAAGGAGATAG\", \"vertebrate_mitochondrial\", 0, False),\n        (\"GCCATAACCTGACTAG\", \"custom_engineered\", 1, False),\n        (\"A\", \"custom_engineered\", 0, True),\n    ]\n\n    results = []\n    for case in test_cases:\n        seq, code, f, b_trunc = case\n        result = calculate_metrics(seq, code, f, b_trunc)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., \"[[L1,S1,D1],[L2,S2,D2],...]\"\n    result_str = \",\".join(map(str, results)).replace(\" \", \"\")\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2435563"}]}