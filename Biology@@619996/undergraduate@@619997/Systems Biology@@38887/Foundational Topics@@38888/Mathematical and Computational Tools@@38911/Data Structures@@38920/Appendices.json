{"hands_on_practices": [{"introduction": "A fundamental task in computational biology is analyzing the composition of biological sequences. This exercise challenges you to think like a software developer by selecting the most efficient data structure for a common bioinformatics task: counting amino acid frequencies. By weighing the trade-offs between arrays, lists, and hash maps, you will develop a crucial skill in optimizing code for both speed and memory, a key consideration when dealing with large-scale biological data [@problem_id:1426309].", "problem": "A bioinformatician is developing a lightweight software tool to analyze protein sequences. A core function of this tool is to count the occurrences of each of the 20 standard amino acids within a given protein sequence. The protein sequence is represented as a string of single-letter codes, where each letter corresponds to an amino acid.\n\nConsider a protein sequence of length $N$. The task is to iterate through this sequence once and maintain a count for each of the 20 standard amino acids. Which of the following data structures is the most suitable choice for storing these counts, considering both time and space efficiency for this specific problem?\n\nA. A singly linked list, where each node contains a two-element record: an amino acid character and its integer count.\n\nB. A single fixed-size array of 20 integers, where each index from 0 to 19 is pre-assigned to a unique standard amino acid.\n\nC. A hash map (also known as a dictionary or associative array) where the keys are the amino acid characters and the values are their integer counts.\n\nD. A balanced binary search tree, where each node stores an amino acid character and its integer count. The tree is ordered alphabetically by amino acid character.", "solution": "Let the protein sequence have length $N$ and the alphabet of amino acids have fixed size $k=20$. The task is to perform a single pass over the sequence and increment a counter associated to each amino acid character.\n\nWe require a mapping from each amino acid character to a counter index and an increment operation per character.\n\n- Option A (singly linked list): For each character, locating its node requires a sequential search over up to $k$ nodes, yielding per-character cost $\\Theta(k)$ and total time $T_{A}(N)=\\Theta(Nk)$. The space is $S_{A}=\\Theta(k)$ plus pointer overhead, and the non-contiguous layout harms cache locality.\n\n- Option B (fixed-size array of $k$ integers): Preassign a bijection $f:\\Sigma\\to\\{0,1,\\dots,k-1\\}$ from amino acid characters to indices. For each character $c$, perform a direct increment $a[f(c)]\\mathrel{+}=1$ in worst-case $\\Theta(1)$ time. The total time is $T_{B}(N)=\\Theta(N)$ and space $S_{B}=\\Theta(k)$ with minimal constant factors and excellent cache locality.\n\n- Option C (hash map): With hashing, expected per-character update is $\\Theta(1)$, so total expected time $T_{C}(N)=\\Theta(N)$, but with larger constant factors due to hashing, collision handling, and key storage. Space is $S_{C}=\\Theta(k)$ with significant overhead, which is unnecessary for fixed small $k$.\n\n- Option D (balanced BST): Each update costs $\\Theta(\\log k)$, giving total time $T_{D}(N)=\\Theta(N\\log k)$ and space $S_{D}=\\Theta(k)$ with pointer and node overhead, which is strictly worse than direct indexing for fixed small $k$.\n\nAmong these, the single fixed-size array minimizes both time (worst-case $\\Theta(N)$ with the smallest constant factor) and space (contiguous $k$ integers, no key or pointer overhead) for a fixed alphabet of size $k=20$. Therefore, the most suitable choice is Option B.", "answer": "$$\\boxed{B}$$", "id": "1426309"}, {"introduction": "Systems biology is built upon understanding how different biological pathways and modules connect and interact. This practice introduces the use of sets as a powerful and intuitive way to represent collections of biological entities, such as metabolites in a pathway. You will apply the fundamental set operation of intersection to answer a biologically meaningful question: which molecules serve as bridges between the citric acid and urea cycles? [@problem_id:1426296].", "problem": "In metabolic network analysis, identifying shared molecules between different biochemical pathways is crucial for understanding how these pathways are interconnected. Consider two central metabolic pathways: the citric acid cycle (also known as the Krebs cycle) and the urea cycle.\n\nYou are given two lists of strings, where each string is the name of a metabolite participating in one of the pathways. Some metabolites may be involved in both.\n\nList of metabolites in the citric acid cycle and its immediate connections:\n`[\"Citrate\", \"Isocitrate\", \"alpha-Ketoglutarate\", \"Succinyl-CoA\", \"Succinate\", \"Fumarate\", \"Malate\", \"Oxaloacetate\", \"Aspartate\"]`\n\nList of metabolites in the urea cycle:\n`[\"Carbamoyl phosphate\", \"Ornithine\", \"Citrulline\", \"Aspartate\", \"Argininosuccinate\", \"Fumarate\", \"Arginine\"]`\n\nYour task is to determine the number of unique metabolites that are common to both the citric acid cycle and the urea cycle based on the provided lists.", "solution": "Let $C$ denote the set of unique metabolites listed for the citric acid cycle and its immediate connections, and let $U$ denote the set of unique metabolites listed for the urea cycle. From the problem:\n$$\nC = \\{\\text{Citrate}, \\text{Isocitrate}, \\text{alpha-Ketoglutarate}, \\text{Succinyl-CoA}, \\text{Succinate}, \\text{Fumarate}, \\text{Malate}, \\text{Oxaloacetate}, \\text{Aspartate}\\}\n$$\n$$\nU = \\{\\text{Carbamoyl phosphate}, \\text{Ornithine}, \\text{Citrulline}, \\text{Aspartate}, \\text{Argininosuccinate}, \\text{Fumarate}, \\text{Arginine}\\}\n$$\nWe are asked to determine the number of unique metabolites common to both pathways, which is the cardinality of the intersection $C \\cap U$:\n$$\nC \\cap U = \\{\\text{Fumarate}, \\text{Aspartate}\\}\n$$\nThus, the number of unique common metabolites is the cardinality:\n$$\n|C \\cap U| = 2\n$$", "answer": "$$\\boxed{2}$$", "id": "1426296"}, {"introduction": "Moving beyond simple collections, the true complexity of cellular logic lies in the intricate web of regulatory networks. This problem introduces graphs as the essential data structure for modeling these protein interaction networks. Your task is to implement an algorithm to detect three-protein feedback loops, a critical regulatory motif, from a list of pairwise interactions, demonstrating how computational methods can uncover dynamic control mechanisms from static network data [@problem_id:1426317].", "problem": "In systems biology, cellular processes are governed by complex gene and protein regulatory networks. These networks can be modeled as directed graphs where nodes represent proteins and edges represent regulatory interactions, such as activation or inhibition. A key regulatory motif in these networks is the feedback loop, where a protein, through a series of intermediaries, ultimately regulates its own activity.\n\nA three-protein feedback loop is a simple cycle of length three, represented by a path like `A → B → C → A`, where `A`, `B`, and `C` are distinct proteins and `→` denotes a directed regulatory interaction. Each interaction has a sign: '+' for activation and '-' for inhibition.\n\nThe overall character of a feedback loop is determined by the product of the signs of its constituent interactions. A loop is classified as a **Negative Feedback Loop** if the product of its signs is negative (i.e., it contains an odd number of inhibitory steps). Conversely, a loop is a **Positive Feedback Loop** if the product of its signs is positive (i.e., it contains an even number of inhibitory steps).\n\nYou are given an unordered list of experimentally observed, unique pairwise protein interactions. Your task is to analyze this network and determine the total number of unique three-protein **Negative Feedback Loops**. A loop is defined by the set of three proteins involved; thus, a cycle `A → B → C → A` is considered the same unique loop as `B → C → A → B`.\n\nThe list of observed interactions, specified as (Source Protein, Target Protein, Interaction Sign), is as follows:\n\n`[('P1', 'P2', '+'), ('P2', 'P3', '-'), ('P3', 'P1', '+'), ('P1', 'P4', '+'), ('P4', 'P5', '+'), ('P5', 'P1', '+'), ('P4', 'P2', '-'), ('P2', 'P5', '-'), ('P6', 'P7', '-'), ('P7', 'P8', '-'), ('P8', 'P6', '-'), ('P3', 'P5', '+'), ('P5', 'P7', '+'), ('P7', 'P3', '-'), ('P8', 'P1', '-'), ('P9', 'P1', '+'), ('P2', 'P9', '+'), ('P9', 'P4', '-')]`", "solution": "We model the network as a directed signed graph. A three-protein directed cycle on distinct proteins $A,B,C$ exists if and only if the directed edges $(A,B)$, $(B,C)$, and $(C,A)$ are all present. The sign of the cycle is the product $s(A,B)\\,s(B,C)\\,s(C,A)$, where each edge sign $s(\\cdot)$ is $+1$ for activation and $-1$ for inhibition. A Negative Feedback Loop is one with product $-1$, i.e., an odd number of inhibitory edges. A loop is counted uniquely by the set $\\{A,B,C\\}$; cyclic rotations are the same.\n\nFrom the given interactions, the outgoing signed neighbors are:\n- $P1$: $P1 \\to P2$ $(+)$, $P1 \\to P4$ $(+)$\n- $P2$: $P2 \\to P3$ $(-)$, $P2 \\to P5$ $(-)$, $P2 \\to P9$ $(+)$\n- $P3$: $P3 \\to P1$ $(+)$, $P3 \\to P5$ $(+)$\n- $P4$: $P4 \\to P5$ $(+)$, $P4 \\to P2$ $(-)$\n- $P5$: $P5 \\to P1$ $(+)$, $P5 \\to P7$ $(+)$\n- $P6$: $P6 \\to P7$ $(-)$\n- $P7$: $P7 \\to P8$ $(-)$, $P7 \\to P3$ $(-)$\n- $P8$: $P8 \\to P6$ $(-)$, $P8 \\to P1$ $(-)$\n- $P9$: $P9 \\to P1$ $(+)$, $P9 \\to P4$ $(-)$\n\nWe enumerate all directed 3-cycles by scanning paths of length two and checking closure:\n\n- $\\{P1,P2,P3\\}$ via $P1 \\to P2$ $(+)$, $P2 \\to P3$ $(-)$, $P3 \\to P1$ $(+)$ gives product $(+1)\\cdot(-1)\\cdot(+1)=-1$, so Negative.\n- $\\{P1,P2,P5\\}$ via $P1 \\to P2$ $(+)$, $P2 \\to P5$ $(-)$, $P5 \\to P1$ $(+)$ gives product $(+1)\\cdot(-1)\\cdot(+1)=-1$, so Negative.\n- $\\{P1,P2,P9\\}$ via $P1 \\to P2$ $(+)$, $P2 \\to P9$ $(+)$, $P9 \\to P1$ $(+)$ gives product $(+1)\\cdot(+1)\\cdot(+1)=+1$, so Positive.\n- $\\{P1,P4,P5\\}$ via $P1 \\to P4$ $(+)$, $P4 \\to P5$ $(+)$, $P5 \\to P1$ $(+)$ gives product $(+1)\\cdot(+1)\\cdot(+1)=+1$, so Positive.\n- $\\{P2,P4,P9\\}$ via $P2 \\to P9$ $(+)$, $P9 \\to P4$ $(-)$, $P4 \\to P2$ $(-)$ gives product $(+1)\\cdot(-1)\\cdot(-1)=+1$, so Positive.\n- $\\{P3,P5,P7\\}$ via $P3 \\to P5$ $(+)$, $P5 \\to P7$ $(+)$, $P7 \\to P3$ $(-)$ gives product $(+1)\\cdot(+1)\\cdot(-1)=-1$, so Negative.\n- $\\{P6,P7,P8\\}$ via $P6 \\to P7$ $(-)$, $P7 \\to P8$ $(-)$, $P8 \\to P6$ $(-)$ gives product $(-1)\\cdot(-1)\\cdot(-1)=-1$, so Negative.\n\nNo other combinations of three distinct proteins in the list complete a directed cycle, as verified by checking all possible length-two paths for closure $C \\to A$.\n\nTherefore, the unique three-protein Negative Feedback Loops (odd number of inhibitory edges) are exactly the four sets $\\{P1,P2,P3\\}$, $\\{P1,P2,P5\\}$, $\\{P3,P5,P7\\}$, and $\\{P6,P7,P8\\}$. Hence, the total count of unique Negative Feedback Loops is $4$.", "answer": "$$\\boxed{4}$$", "id": "1426317"}]}