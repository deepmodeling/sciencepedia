{"hands_on_practices": [{"introduction": "Experimentation is at the heart of systems biology research, but not every change leads to a breakthrough. This exercise explores a common scenario where modifications to a simulation script prove unsuccessful and need to be discarded [@problem_id:1477415]. Mastering the ability to cleanly revert a single file to its last known good state is a fundamental skill for efficient and risk-free development, protecting the integrity of your project.", "problem": "You are a systems biology researcher using Git for version control on your project. The project repository contains a Python script named `lv_simulation.py`, which models a Lotka-Volterra predator-prey system. The script is currently tracked by Git, and the working directory is clean, meaning it matches the latest commit.\n\nTo explore the system's dynamics, you directly edit `lv_simulation.py`, significantly altering several key parameters like the prey's reproduction rate and the predator's hunting efficiency. After running the modified script, you find that the new parameters lead to a biologically nonsensical scenario where both populations immediately collapse. You have not staged these changes using `git add`.\n\nYou decide to completely discard all the modifications you just made to `lv_simulation.py` and restore the file to the exact state it was in at the time of your last commit (`HEAD`). You want to perform this action on this single file without affecting any other files in your project.\n\nWhich of the following Git commands will accomplish this task?\n\nA. `git reset --hard HEAD`\n\nB. `git revert HEAD`\n\nC. `git commit -a -m \"Revert experimental parameter changes\"`\n\nD. `git checkout -- lv_simulation.py`\n\nE. `git clean -f lv_simulation.py`", "solution": "We start by identifying the repository state and the precise goal. The file `lv_simulation.py` is tracked, the repository was clean before editing, so the index (staging area) and `HEAD` both contain the last committed version of this file. After editing, we have unstaged modifications only in the working directory; the index still holds the pristine `HEAD` version for this file. The task is to discard only the working directory modifications for this single tracked file and restore it to the exact version recorded at `HEAD`, without affecting any other files.\n\nGiven this, the correct command must replace the working-tree copy of `lv_simulation.py` with the version from the index (which matches `HEAD`, since nothing was staged). We evaluate each option:\n\nA. `git reset --hard HEAD` updates both the index and the working tree to match `HEAD` for all tracked paths. This discards all uncommitted changes across the entire repository, not just the single file. It is too broad and risks unintended loss in other files.\n\nB. `git revert HEAD` creates a new commit that inverts the changes introduced by the last commit. It operates at the commit level, not at the level of unstaged working-directory changes, and requires a clean working tree. It does not discard the current unstaged edits to `lv_simulation.py` and is not file-specific.\n\nC. `git commit -a -m \"Revert experimental parameter changes\"` stages and commits all current changes to tracked files. This would preserve and record the undesired edits rather than discarding them.\n\nD. `git checkout -- lv_simulation.py` replaces the working-tree version of the specified path with the version from the index. Because no changes were staged, the index version equals the last committed version at `HEAD`. Hence this command discards the unstaged edits to `lv_simulation.py` and restores it to its last committed state, without affecting other files.\n\nE. `git clean -f lv_simulation.py` removes untracked files; it does not modify tracked files. Since `lv_simulation.py` is tracked, this command will not restore or change it.\n\nTherefore, the only command that accomplishes the stated goal—discarding unstaged changes to a single tracked file and restoring it to the `HEAD` version without touching other files—is option D.", "answer": "$$\\boxed{D}$$", "id": "1477415"}, {"introduction": "Scientific work is often interrupted by urgent tasks, requiring you to pause your current line of thought and switch contexts. This practice demonstrates a critical workflow for handling such interruptions gracefully using Git [@problem_id:1477434]. You will learn how to use `git stash` to temporarily save your unfinished work, address a separate issue, and then seamlessly return to your original task without losing progress or creating messy, temporary commits.", "problem": "A systems biology student is using Git to manage versions of a computational model for a gene regulatory network. The student is currently working on a branch named `feature-feedback-loop`. They have made several changes to a script, `simulation.py`, to implement a new negative feedback mechanism. These changes are saved in the working directory but are not yet staged or committed.\n\nSuddenly, an urgent report comes in: the code on the `main` branch has a critical bug that causes simulations to crash. The student needs to stop their current work, switch to the `main` branch to address the bug, and then return to their feature branch to continue their work exactly where they left off.\n\nThe plan is as follows:\n1.  Temporarily save the uncommitted work from the `feature-feedback-loop` branch.\n2.  Switch to the `main` branch.\n3.  Create a new branch named `hotfix-crash-fix` from `main` to work on the bug.\n4.  (After the bug is fixed, committed, and merged back into `main` by other commands not listed in the choices) Switch back to the `feature-feedback-loop` branch.\n5.  Restore the saved, uncommitted work to the working directory.\n\nWhich of the following sequences of Git commands represents the most standard and efficient way to accomplish this entire workflow (steps 1, 2, 3, 4, and 5)?\n\nA.\n`git commit -a -m \"WIP\"`\n`git checkout main`\n`git checkout -b hotfix-crash-fix`\n`git checkout feature-feedback-loop`\n`git reset HEAD~1`\n\nB.\n`git stash`\n`git checkout main`\n`git checkout -b hotfix-crash-fix`\n`git checkout feature-feedback-loop`\n`git stash pop`\n\nC.\n`git checkout -f main`\n`git checkout -b hotfix-crash-fix`\n`git checkout feature-feedback-loop`\n\nD.\n`git add .`\n`git checkout main`\n`git checkout -b hotfix-crash-fix`\n`git checkout feature-feedback-loop`\n`git checkout -- .`\n\nE.\n`git stash`\n`git stash branch temp-fix`\n`git checkout main`\n`git checkout -b hotfix-crash-fix`\n`git checkout feature-feedback-loop`\n`git merge temp-fix`", "solution": "We need to preserve uncommitted work on the current feature branch, switch to main, create a hotfix branch from main, later return to the feature branch, and restore the exact uncommitted working state.\n\nThe most standard and efficient Git workflow for temporarily setting aside uncommitted changes and restoring them later is to use the stash.\n\nAnalyze each option against the required steps:\n\n- Option B:\n  1) git stash temporarily saves the uncommitted changes from the working directory on the current branch (tracked modifications such as changes to simulation.py).\n  2) git checkout main switches to main with a clean working directory.\n  3) git checkout -b hotfix-crash-fix creates the hotfix branch from main to work on the bug.\n  4) git checkout feature-feedback-loop returns to the feature branch.\n  5) git stash pop restores the previously stashed changes into the working directory and drops the stash. This exactly matches the plan and is the standard approach.\n\n- Option A:\n  Commits a temporary WIP, then later uses git reset HEAD~1 to remove the commit and re-expose changes. Although it can work, it pollutes history and risks issues (e.g., push/pull conflicts, untracked files not included by git commit -a). It is not the most standard or efficient compared to stashing.\n\n- Option C:\n  git checkout -f main forces discarding local changes, which loses work. It does not save or restore the uncommitted changes.\n\n- Option D:\n  git add . stages changes and then attempts to switch branches. This can be blocked due to conflicts, and the final git checkout -- . discards changes rather than restoring them.\n\n- Option E:\n  Uses git stash branch temp-fix, which creates a new branch and applies the stash there, then later merges that branch back. This changes the nature of the saved work (turning it into commits and merges), not preserving the original uncommitted working state, and is unnecessary and inefficient for the stated goal.\n\nTherefore, the sequence that is both standard and efficient, and that precisely aligns with steps 1–5, is option B.", "answer": "$$\\boxed{B}$$", "id": "1477434"}, {"introduction": "Effective collaboration depends on clear communication, and in Git, your commit history is a crucial form of communication. This hands-on problem tackles the essential task of cleaning up a messy series of developmental commits before sharing them [@problem_id:1477440]. You will practice using interactive rebase to consolidate your work into a single, logical commit, a key step in preparing professional-quality contributions for a collaborative project, making your work easier for others to review and integrate.", "problem": "You are a systems biology researcher developing a new computational model for bacterial chemotaxis. You are working on a feature branch named `feature/chemotaxis-model`, which was created from the `main` branch of your project's repository. Over the past day, you have made a series of small, incremental commits to your local branch. Your commit history on this branch, as shown by `git log --oneline`, currently looks like this (from most to least recent):\n\n```\ne8a1b12 (HEAD -> feature/chemotaxis-model) fix: typo in parameter documentation\nc7f2d34 refactor: simplify signal processing loop\nb6e3c45 feat: add initial chemotaxis logic\na5d4b56 chore: setup model skeleton and dependencies\nf9c0a01 (origin/main, main) doc: update project readme\n```\n\nBefore creating a request to merge your work into the `main` branch, you want to clean up your branch's history. Your goal is to consolidate your four new commits (`a5d4b56` through `e8a1b12`) into a single, cohesive commit with a clean, descriptive message. You have already pushed the `feature/chemotaxis-model` branch with its messy history to the remote repository named `origin`.\n\nWhich of the following command sequences represents the most appropriate and standard method to accomplish this consolidation and update the remote branch?\n\nA. First, run `git rebase -i HEAD~4`. In the interactive editor that appears, change the action for the last three commits from `pick` to `squash`. After saving, write a new, single commit message when prompted. Finally, run `git push --force-with-lease origin feature/chemotaxis-model`.\n\nB. First, run `git reset --soft HEAD~4`. Then, run `git commit -m \"feat: Implement bacterial chemotaxis model\"`. Finally, run `git push --force-with-lease origin feature/chemotaxis-model`.\n\nC. First, run `git checkout main`. Then, run `git merge --squash feature/chemotaxis-model`. Finally, run `git commit -m \"feat: Implement bacterial chemotaxis model\"`.\n\nD. First, run `git rebase -i HEAD~4`. In the interactive editor, change the action for the last three commits from `pick` to `squash` and save. Write a new commit message. Finally, run `git push origin feature/chemotaxis-model`.\n\nE. First, run `git revert HEAD HEAD~1 HEAD~2 HEAD~3`. Then, run `git commit -m \"feat: Implement final chemotaxis model\"`. Finally, run `git push origin feature/chemotaxis-model`.", "solution": "We want to consolidate four recent commits on a feature branch into a single commit and update the already-pushed remote branch. Consolidating commits that have already been pushed requires rewriting history locally and then updating the remote with a non-fast-forward push. The most standard method for this is an interactive rebase to squash commits, followed by a push with force-with-lease to safely update the remote.\n\nStep-by-step reasoning:\n1. Use interactive rebase to rewrite the last four commits as one:\n   - Run: git rebase -i HEAD~4\n   - In the interactive editor, keep the oldest commit as pick and change the remaining three to squash (or fixup) so that they are combined into the first commit.\n   - Save and, when prompted, provide a clean, descriptive single commit message representing the combined changes.\n2. Because the branch has already been pushed, the rewritten history must be pushed with a non-fast-forward update. The safe standard is:\n   - Run: git push --force-with-lease origin feature/chemotaxis-model\n   - This updates the remote while protecting against clobbering new work pushed by others.\n\nEvaluation of options:\n- A matches the standard workflow precisely: interactive rebase to squash, then push with --force-with-lease.\n- B (git reset --soft HEAD~4, then commit, then force-with-lease) can technically achieve a single commit, but it is less standard for cleaning up public history and loses the opportunity to curate messages via rebase’s squash/fixup flow; interactive rebase is generally preferred.\n- C performs a squash merge into main rather than cleaning up the feature branch history, and it does not update the feature branch on remote; not aligned with the stated goal.\n- D omits the required force-with-lease when pushing rewritten history, which will fail on a non-fast-forward push to the remote.\n- E reverts commits, which undoes changes instead of consolidating them, and introduces extra revert commits; this is the opposite of the goal.\n\nTherefore, the most appropriate and standard method is option A.", "answer": "$$\\boxed{A}$$", "id": "1477440"}]}