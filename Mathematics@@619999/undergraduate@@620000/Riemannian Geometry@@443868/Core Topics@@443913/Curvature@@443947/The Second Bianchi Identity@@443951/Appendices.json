{"hands_on_practices": [{"introduction": "The most elegant proofs in geometry often exploit a clever choice of coordinates to simplify calculations. The standard proof of the second Bianchi identity is a prime example, relying on the properties of normal coordinates. This exercise challenges you to critically analyze a common but flawed argument, sharpening your understanding of how to correctly use coordinate-based proofs and the principle of covariance. Mastering this logical step [@problem_id:3077203] is crucial for building a solid conceptual foundation for why the identity holds.", "problem": "Let $(M,g)$ be a smooth Riemannian manifold with its Levi-Civita connection $\\nabla$. In local coordinates $\\{x^i\\}$, write the Christoffel symbols as $\\Gamma^{\\ell}{}_{ik}$ and the components of the Riemann curvature tensor as $R^{\\ell}{}_{\\,\\,\\,kij}$. An attempted proof of the second Bianchi identity argues as follows: choose normal coordinates, set $\\Gamma^{\\ell}{}_{ik}=0$ everywhere, and then drop all terms involving $\\Gamma^{\\ell}{}_{ik}$ in the covariant derivatives of $R^{\\ell}{}_{\\,\\,\\,kij}$ to conclude the identity. \n\nUsing only foundational facts and definitions from Riemannian geometry, analyze this argument. You may use the following standard base:\n- The Levi-Civita connection is torsion-free and metric-compatible.\n- In normal coordinates at a point $p\\in M$, one has $\\Gamma^{\\ell}{}_{ik}(p)=0$, but derivatives $\\partial_m\\Gamma^{\\ell}{}_{ik}(p)$ are not assumed to vanish.\n- The curvature tensor arises from the commutator of covariant derivatives, and in coordinates has the local expression\n$$\nR^{\\ell}{}_{\\,\\,\\,kij}=\\partial_i\\Gamma^{\\ell}{}_{kj}-\\partial_j\\Gamma^{\\ell}{}_{ki}+\\Gamma^{\\ell}{}_{im}\\Gamma^{m}{}_{kj}-\\Gamma^{\\ell}{}_{jm}\\Gamma^{m}{}_{ki}.\n$$\n- The covariant derivative of a tensor in coordinates equals the partial derivative plus terms linear in the Christoffel symbols.\n\nWhich option correctly explains why the above proof strategy is flawed and outlines a valid pointwise correction that yields the second Bianchi identity?\n\nA. The argument is valid because in normal coordinates $\\Gamma^{\\ell}{}_{ik}$ vanishes identically in a neighborhood, so $R^{\\ell}{}_{\\,\\,\\,kij}=0$ there and the identity is trivial. To correct the proof globally, choose harmonic coordinates that make $\\Gamma^{\\ell}{}_{ik}$ vanish everywhere.\n\nB. The argument is flawed because $\\Gamma^{\\ell}{}_{ik}=0$ is only guaranteed at a single point $p$ in normal coordinates, not on a neighborhood, and while $\\Gamma^{\\ell}{}_{ik}(p)=0$, the derivatives $\\partial_m\\Gamma^{\\ell}{}_{ik}(p)$ generally do not vanish. A correct pointwise proof evaluates $\\nabla_{\\lambda}R^{\\ell}{}_{\\,\\,\\,kij}$ at $p$ in normal coordinates, observes that at $p$ the covariant derivative reduces to a partial derivative, uses\n$$\nR^{\\ell}{}_{\\,\\,\\,kij}(p)=\\partial_i\\Gamma^{\\ell}{}_{kj}(p)-\\partial_j\\Gamma^{\\ell}{}_{ki}(p),\n$$\nand shows that the cyclic sum of the three partial derivatives\n$$\n\\partial_{\\lambda}R^{\\ell}{}_{\\,\\,\\,kij}+\\partial_{i}R^{\\ell}{}_{\\,\\,\\,kj\\lambda}+\\partial_{j}R^{\\ell}{}_{\\,\\,\\,k\\lambda i}\n$$\nvanishes by commutativity of mixed partial derivatives. Since the identity is tensorial and $p$ was arbitrary, it holds everywhere.\n\nC. The flaw is ignoring metric compatibility: one can choose coordinates so that both $\\Gamma^{\\ell}{}_{ik}(p)$ and $\\partial_m\\Gamma^{\\ell}{}_{ik}(p)$ vanish at $p$. The correct proof drops all terms with $\\Gamma^{\\ell}{}_{ik}$ and $\\partial_m\\Gamma^{\\ell}{}_{ik}$ and concludes the identity from the symmetry $R_{lijk}=R_{ljik}$.\n\nD. The flaw is neglecting torsion: normal coordinates force $\\Gamma^{\\ell}{}_{ik}$ to be antisymmetric in the lower indices, so setting $\\Gamma^{\\ell}{}_{ik}=0$ everywhere contradicts torsion-freeness. The correction is to assume torsion-free, which implies $R^{\\ell}{}_{\\,\\,\\,kij}=0$ and therefore proves the identity.\n\nE. The issue is that $\\Gamma^{\\ell}{}_{ik}$ transforms inhomogeneously, so a coordinate-based proof cannot work. The correction is to use parallel frames along geodesics to ensure $\\nabla R=0$ in all radial directions, which directly implies the second Bianchi identity.", "solution": "The problem statement is a valid exercise in differential geometry, asking to identify the flaw in a common but incorrect \"proof\" of the second Bianchi identity and to describe the correct, standard proof strategy.\n\nThe flawed argument presented is as follows:\n1.  Choose normal coordinates.\n2.  Set the Christoffel symbols $\\Gamma^{\\ell}{}_{ik}=0$ *everywhere*.\n3.  Use this to simplify the covariant derivative of the Riemann tensor, $\\nabla R$, and conclude the identity.\n\nThe primary and critical flaw in this argument is Step 2. In normal coordinates centered at a point $p \\in M$, the Christoffel symbols vanish *at that point*, i.e., $\\Gamma^{\\ell}{}_{ik}(p) = 0$. However, they do not, in general, vanish in an open neighborhood of $p$. For a general curved manifold, it is impossible to find a coordinate system where the Christoffel symbols vanish everywhere in an open set. If such coordinates existed, the Riemann curvature tensor would be identically zero in that set, implying the manifold is flat. The argument's premise is therefore false for any non-flat manifold.\n\nConsequently, Step 3 is also invalid. Since $\\Gamma^{\\ell}{}_{ik}$ are not zero away from $p$, their derivatives $\\partial_m \\Gamma^{\\ell}{}_{ik}$ are also generally non-zero, even at the point $p$. The proposed simplification incorrectly discards these crucial derivative terms.\n\nA valid proof leverages the properties of normal coordinates at a single, arbitrary point $p$. The principle of covariance states that if a tensor equation is true in one coordinate system, it is true in all. Therefore, proving the identity at an arbitrary point $p$ in a special coordinate system is sufficient to establish its validity everywhere.\n\nThe second Bianchi identity is a statement about the cyclic sum of covariant derivatives of the Riemann tensor:\n$$ \\nabla_\\lambda R^{\\ell}{}_{\\,\\,\\,kij} + \\nabla_i R^{\\ell}{}_{\\,\\,k j\\lambda} + \\nabla_j R^{\\ell}{}_{\\,\\,k\\lambda i} = 0 $$\nThe expression for the covariant derivative of the Riemann tensor is:\n$$ \\nabla_\\lambda R^{\\ell}{}_{\\,\\,\\,kij} = \\partial_\\lambda R^{\\ell}{}_{\\,\\,\\,kij} + \\Gamma^{\\ell}{}_{\\lambda m} R^{m}{}_{\\,\\,\\,kij} - \\Gamma^{m}{}_{\\lambda k} R^{\\ell}{}_{\\,\\,\\,mij} - \\Gamma^{m}{}_{\\lambda i} R^{\\ell}{}_{\\,\\,\\,kmj} - \\Gamma^{m}{}_{\\lambda j} R^{\\ell}{}_{\\,\\,\\,kim} $$\nIn normal coordinates at $p$, we have $\\Gamma^{\\beta}{}_{\\alpha \\gamma}(p) = 0$. Evaluating the above expression at $p$, all terms containing Christoffel symbols vanish:\n$$ (\\nabla_\\lambda R^{\\ell}{}_{\\,\\,\\,kij})(p) = (\\partial_\\lambda R^{\\ell}{}_{\\,\\,\\,kij})(p) $$\nThus, at the point $p$, the covariant derivative reduces to the partial derivative.\n\nNext, we examine the Riemann tensor itself at $p$. The full expression is:\n$$ R^{\\ell}{}_{\\,\\,\\,kij} = \\partial_i\\Gamma^{\\ell}{}_{kj}-\\partial_j\\Gamma^{\\ell}{}_{ki}+\\Gamma^{\\ell}{}_{im}\\Gamma^{m}{}_{kj}-\\Gamma^{\\ell}{}_{jm}\\Gamma^{m}{}_{ki} $$\nAt the point $p$, where $\\Gamma^{\\ell}{}_{ik}(p) = 0$, the quadratic terms vanish, leaving:\n$$ R^{\\ell}{}_{\\,\\,\\,kij}(p) = (\\partial_i\\Gamma^{\\ell}{}_{kj})(p) - (\\partial_j\\Gamma^{\\ell}{}_{ki})(p) $$\nThis shows that the curvature at $p$ depends on the *first derivatives* of the Christoffel symbols at $p$, which are generally non-zero.\n\nTo compute $(\\partial_\\lambda R^{\\ell}{}_{\\,\\,\\,kij})(p)$, we must first differentiate the full expression for $R^{\\ell}{}_{\\,\\,\\,kij}$ with respect to $x^\\lambda$ and *then* evaluate at $p$. Differentiating the quadratic $\\Gamma$ terms yields terms of the form $(\\partial \\Gamma)\\Gamma$, which vanish at $p$ because they contain an undifferentiated $\\Gamma$ factor. Therefore, at $p$:\n$$ (\\partial_\\lambda R^{\\ell}{}_{\\,\\,\\,kij})(p) = \\partial_\\lambda \\left( \\partial_i\\Gamma^{\\ell}{}_{kj} - \\partial_j\\Gamma^{\\ell}{}_{ki} \\right)(p) = (\\partial_\\lambda \\partial_i\\Gamma^{\\ell}{}_{kj})(p) - (\\partial_\\lambda \\partial_j\\Gamma^{\\ell}{}_{ki})(p) $$\nThe second Bianchi identity at point $p$ becomes the cyclic sum of these partial derivatives:\n$$ (\\nabla_\\lambda R^{\\ell}{}_{\\,\\,\\,kij} + \\nabla_i R^{\\ell}{}_{\\,\\,k j\\lambda} + \\nabla_j R^{\\ell}{}_{\\,\\,k\\lambda i})(p) = (\\partial_\\lambda R^{\\ell}{}_{\\,\\,\\,kij} + \\partial_i R^{\\ell}{}_{\\,\\,k j\\lambda} + \\partial_j R^{\\ell}{}_{\\,\\,k\\lambda i})(p) $$\nSubstituting our expressions for the partial derivatives of $R$:\n$$ = \\left[ (\\partial_\\lambda \\partial_i\\Gamma^{\\ell}{}_{kj})(p) - (\\partial_\\lambda \\partial_j\\Gamma^{\\ell}{}_{ki})(p) \\right] + \\left[ (\\partial_i \\partial_j\\Gamma^{\\ell}{}_{k\\lambda})(p) - (\\partial_i \\partial_\\lambda\\Gamma^{\\ell}{}_{kj})(p) \\right] + \\left[ (\\partial_j \\partial_\\lambda\\Gamma^{\\ell}{}_{ki})(p) - (\\partial_j \\partial_i\\Gamma^{\\ell}{}_{k\\lambda})(p) \\right] $$\nOn a smooth manifold, partial derivatives commute ($\\partial_a \\partial_b = \\partial_b \\partial_a$). Grouping terms, we see that they cancel in pairs:\n$$ [(\\partial_\\lambda \\partial_i\\Gamma^{\\ell}{}_{kj}) - (\\partial_i \\partial_\\lambda\\Gamma^{\\ell}{}_{kj})] + [(\\partial_i \\partial_j\\Gamma^{\\ell}{}_{k\\lambda}) - (\\partial_j \\partial_i\\Gamma^{\\ell}{}_{k\\lambda})] + [(\\partial_j \\partial_\\lambda\\Gamma^{\\ell}{}_{ki}) - (\\partial_\\lambda \\partial_j\\Gamma^{\\ell}{}_{ki})] = 0 + 0 + 0 = 0 $$\nThe identity holds at $p$. Since $p$ was an arbitrary point, the identity holds everywhere on $M$.\n\nNow we evaluate the given options.\n\n**A. The argument is valid because in normal coordinates $\\Gamma^{\\ell}{}_{ik}$ vanishes identically in a neighborhood, so $R^{\\ell}{}_{\\,\\,\\,kij}=0$ there and the identity is trivial. To correct the proof globally, choose harmonic coordinates that make $\\Gamma^{\\ell}{}_{ik}$ vanish everywhere.**\nThis is incorrect. The assertion that $\\Gamma^{\\ell}{}_{ik}$ vanishes in a neighborhood in normal coordinates is false. Harmonic coordinates do not make $\\Gamma^{\\ell}{}_{ik}$ vanish everywhere in general.\n\n**B. The argument is flawed because $\\Gamma^{\\ell}{}_{ik}=0$ is only guaranteed at a single point $p$ in normal coordinates, not on a neighborhood, and while $\\Gamma^{\\ell}{}_{ik}(p)=0$, the derivatives $\\partial_m\\Gamma^{\\ell}{}_{ik}(p)$ generally do not vanish. A correct pointwise proof evaluates $\\nabla_{\\lambda}R^{\\ell}{}_{\\,\\,\\,kij}$ at $p$ in normal coordinates, observes that at $p$ the covariant derivative reduces to a partial derivative, uses $R^{\\ell}{}_{\\,\\,\\,kij}(p)=\\partial_i\\Gamma^{\\ell}{}_{kj}(p)-\\partial_j\\Gamma^{\\ell}{}_{ki}(p)$, and shows that the cyclic sum of the three partial derivatives $\\partial_{\\lambda}R^{\\ell}{}_{\\,\\,\\,kij}+\\partial_{i}R^{\\ell}{}_{\\,\\,\\,kj\\lambda}+\\partial_{j}R^{\\ell}{}_{\\,\\,\\,k\\lambda i}$ vanishes by commutativity of mixed partial derivatives. Since the identity is tensorial and $p$ was arbitrary, it holds everywhere.**\nThis is correct. It precisely identifies the central flaw in the proposed argument (that $\\Gamma^{\\ell}{}_{ik}$ vanishes only at a point $p$, not in a neighborhood). It then correctly outlines the standard, valid proof method based on a pointwise calculation in normal coordinates, as detailed in the derivation above. All steps described are valid and lead to the desired conclusion.\n\n**C. The flaw is ignoring metric compatibility: one can choose coordinates so that both $\\Gamma^{\\ell}{}_{ik}(p)$ and $\\partial_m\\Gamma^{\\ell}{}_{ik}(p)$ vanish at $p$. The correct proof drops all terms with $\\Gamma^{\\ell}{}_{ik}$ and $\\partial_m\\Gamma^{\\ell}{}_{ik}$ and concludes the identity from the symmetry $R_{lijk}=R_{ljik}$.**\nThis is incorrect. It is generally not possible to make both $\\Gamma^{\\ell}{}_{ik}(p)$ and all their first derivatives $\\partial_m\\Gamma^{\\ell}{}_{ik}(p)$ vanish simultaneously. If it were, the Riemann tensor would be zero at $p$. Furthermore, concluding the *second* (differential) Bianchi identity from an algebraic symmetry of the Riemann tensor is a categorical error. The symmetry $R_{lijk}=R_{ljik}$ is also false.\n\n**D. The flaw is neglecting torsion: normal coordinates force $\\Gamma^{\\ell}{}_{ik}$ to be antisymmetric in the lower indices, so setting $\\Gamma^{\\ell}{}_{ik}=0$ everywhere contradicts torsion-freeness. The correction is to assume torsion-free, which implies $R^{\\ell}{}_{\\,\\,\\,kij}=0$ and therefore proves the identity.**\nThis is incorrect. For a torsion-free connection like the Levi-Civita connection, the Christoffel symbols are symmetric in their lower indices, $\\Gamma^{\\ell}{}_{ik} = \\Gamma^{\\ell}{}_{ki}$, not antisymmetric. Furthermore, being torsion-free does not imply zero curvature.\n\n**E. The issue is that $\\Gamma^{\\ell}{}_{ik}$ transforms inhomogeneously, so a coordinate-based proof cannot work. The correction is to use parallel frames along geodesics to ensure $\\nabla R=0$ in all radial directions, which directly implies the second Bianchi identity.**\nThis is incorrect. The statement that a coordinate-based proof cannot work is fundamentally false; the principle of covariance is precisely what makes such proofs valid. The suggested \"correction\" is also flawed; one cannot generally find frames where $\\nabla R=0$.", "answer": "$$\\boxed{B}$$", "id": "3077203"}, {"introduction": "After seeing the proof for the Riemann tensor $R$, a natural question arises: is the second Bianchi identity a universal property of all tensors, or is it special to curvature? This practice answers that question directly by having you perform a concrete calculation on an arbitrarily defined $(1,3)$-tensor field $T$. By discovering that the identity fails for this general tensor [@problem_id:3077216], you will gain a deeper appreciation for the unique and profound structure that the Levi-Civita connection imposes on its associated curvature tensor.", "problem": "Let $\\left(\\mathbb{R}^2,g\\right)$ be the Euclidean plane with the standard Euclidean metric $g$ and its Levi-Civita connection $\\nabla$. Work in global Cartesian coordinates $(x,y)$ with the coordinate frame $\\partial_x,\\partial_y$. Define a $(1,3)$-tensor field $T$ by specifying its action on the frame as follows:\n- $T(\\partial_x,\\partial_y)\\partial_x = f(x,y)\\,\\partial_x$ with $f(x,y)=x^2 y$,\n- $T(Y,Z)W=0$ for all other triples $(Y,Z,W)$ in the frame,\nand extend by multilinearity and smoothness to all vector fields.\n\nLet $X=\\partial_x$, $Y=\\partial_x$, $Z=\\partial_y$, and $W=\\partial_x$. Define the cyclic sum over the first three inputs by\n$$\n\\operatorname{cyc}_{X,Y,Z} S(X,Y,Z) \\;=\\; S(X,Y,Z) \\;+\\; S(Y,Z,X) \\;+\\; S(Z,X,Y),\n$$\nfor any trilinear map $S$. Using only the fundamental definitions of covariant derivative and tensor fields on $\\mathbb{R}^2$, compute the scalar\n$$\nS \\;=\\; g\\!\\left(\\operatorname{cyc}_{X,Y,Z}(\\nabla_X T)(Y,Z)W,\\;\\partial_x\\right)\n$$\nat the point $p=(1,2)$.\n\nFinally, briefly explain why, in contrast, the analogous cyclic sum vanishes when $T$ is the Riemann curvature tensor $R$ of the Levi-Civita connection.\n\nGive your final numerical value for $S$ as an exact real number. No rounding is required.", "solution": "The problem asks for the computation of a scalar value $S$ derived from a user-defined $(1,3)$-tensor field $T$ on the Euclidean plane $\\left(\\mathbb{R}^2, g\\right)$, and for an explanation regarding the analogous computation for the Riemann curvature tensor $R$.\n\nFirst, we compute the scalar $S$. The manifold is $\\mathbb{R}^2$ with the standard Euclidean metric $g$. We use global Cartesian coordinates $(x,y)$, so the coordinate basis vectors are $\\partial_x$ and $\\partial_y$. The Levi-Civita connection $\\nabla$ in these coordinates has all Christoffel symbols equal to zero: $\\Gamma^k_{ij}=0$. This implies that the covariant derivative of any basis vector is zero: $\\nabla_{\\partial_i} \\partial_j = 0$ for $i,j \\in \\{x,y\\}$.\n\nThe tensor field $T$ is of type $(1,3)$, interpreted as a map $T: (Y,Z,W) \\mapsto T(Y,Z,W)$ which is trilinear in its vector field arguments. The problem defines its action on the basis vectors $\\{\\partial_x, \\partial_y\\}$ as:\n$T(\\partial_x, \\partial_y, \\partial_x) = f(x,y)\\partial_x$, where $f(x,y) = x^2 y$.\n$T(Y,Z,W) = 0$ for all other triples of basis vectors.\nLet $\\partial_1 = \\partial_x$ and $\\partial_2 = \\partial_y$. The components $T^k_{ijl}$ of $T$ are defined by $T(\\partial_i, \\partial_j, \\partial_l) = T^k_{ijl} \\partial_k$. The given conditions imply that the only non-zero component function is $T^1_{121} = f(x,y) = x^2y$. All other components, such as $T^2_{121}$, $T^k_{211}$, $T^k_{111}$, etc., are identically zero.\n\nThe scalar to be computed is $S = g(\\operatorname{cyc}_{X,Y,Z}(\\nabla_X T)(Y,Z)W, \\partial_x)$ at the point $p=(1,2)$, with the vector fields given as $X=\\partial_x$, $Y=\\partial_x$, $Z=\\partial_y$, and $W=\\partial_x$.\n\nThe cyclic sum is defined as $\\operatorname{cyc}_{X,Y,Z} S(X,Y,Z) = S(X,Y,Z) + S(Y,Z,X) + S(Z,X,Y)$. Applied to the expression $(\\nabla_\\cdot T)(\\cdot,\\cdot)W$, this yields the vector field $V$:\n$$\nV = (\\nabla_X T)(Y,Z,W) + (\\nabla_Y T)(Z,X,W) + (\\nabla_Z T)(X,Y,W).\n$$\nSubstituting the given vector fields $X=\\partial_x$, $Y=\\partial_x$, $Z=\\partial_y$, and $W=\\partial_x$:\n$$\nV = (\\nabla_{\\partial_x} T)(\\partial_x, \\partial_y, \\partial_x) + (\\nabla_{\\partial_x} T)(\\partial_y, \\partial_x, \\partial_x) + (\\nabla_{\\partial_y} T)(\\partial_x, \\partial_x, \\partial_x).\n$$\nWe compute each term separately. The general definition of the covariant derivative of a $(1,3)$-tensor $T$ is:\n$$\n(\\nabla_A T)(B,C,D) = \\nabla_A(T(B,C,D)) - T(\\nabla_A B, C, D) - T(B, \\nabla_A C, D) - T(B, C, \\nabla_A D).\n$$\nSince we are using coordinate basis vectors in a flat geometry, $\\nabla_{\\partial_i} \\partial_j = 0$. The formula simplifies significantly to:\n$$\n(\\nabla_{\\partial_i} T)(\\partial_j, \\partial_l, \\partial_m) = \\nabla_{\\partial_i}(T(\\partial_j, \\partial_l, \\partial_m)).\n$$\nNow we compute the three terms for $V$:\n\nTerm 1: $(\\nabla_{\\partial_x} T)(\\partial_x, \\partial_y, \\partial_x) = \\nabla_{\\partial_x}(T(\\partial_x, \\partial_y, \\partial_x))$.\nFrom the definition of $T$, we have $T(\\partial_x, \\partial_y, \\partial_x) = f(x,y)\\partial_x = x^2 y \\partial_x$. So,\n$$\n\\nabla_{\\partial_x}(x^2 y \\partial_x) = (\\nabla_{\\partial_x} (x^2 y)) \\partial_x + (x^2 y) (\\nabla_{\\partial_x} \\partial_x).\n$$\nThe covariant derivative of a scalar function is its partial derivative, so $\\nabla_{\\partial_x} (x^2 y) = \\frac{\\partial}{\\partial x}(x^2 y) = 2xy$. The second term vanishes since $\\nabla_{\\partial_x} \\partial_x = 0$.\nThus, the first term is $(2xy)\\partial_x$.\n\nTerm 2: $(\\nabla_{\\partial_x} T)(\\partial_y, \\partial_x, \\partial_x) = \\nabla_{\\partial_x}(T(\\partial_y, \\partial_x, \\partial_x))$.\nThe triple of arguments is $(\\partial_y, \\partial_x, \\partial_x)$, which is not $(\\partial_x, \\partial_y, \\partial_x)$. By the problem definition, $T(\\partial_y, \\partial_x, \\partial_x) = 0$.\nThus, the second term is $\\nabla_{\\partial_x}(0) = 0$.\n\nTerm 3: $(\\nabla_{\\partial_y} T)(\\partial_x, \\partial_x, \\partial_x) = \\nabla_{\\partial_y}(T(\\partial_x, \\partial_x, \\partial_x))$.\nThe triple of arguments is $(\\partial_x, \\partial_x, \\partial_x)$, which is also not $(\\partial_x, \\partial_y, \\partial_x)$. By definition, $T(\\partial_x, \\partial_x, \\partial_x) = 0$.\nThus, the third term is $\\nabla_{\\partial_y}(0) = 0$.\n\nCombining the terms, the total vector field is $V = (2xy)\\partial_x + 0 + 0 = (2xy)\\partial_x$.\n\nThe scalar $S$ is obtained by taking the inner product of $V$ with $\\partial_x$:\n$$\nS = g(V, \\partial_x) = g((2xy)\\partial_x, \\partial_x).\n$$\nUsing the bilinearity of the metric $g$, we have $S = (2xy)g(\\partial_x, \\partial_x)$.\nIn the standard Euclidean metric with Cartesian coordinates, the basis $\\{\\partial_x, \\partial_y\\}$ is orthonormal, so $g(\\partial_x, \\partial_x) = 1$.\nTherefore, the scalar function is $S = 2xy$.\n\nWe must evaluate this at the point $p=(1,2)$, which means $x=1$ and $y=2$:\n$$\nS|_{p=(1,2)} = 2(1)(2) = 4.\n$$\n\nFinally, we address the question of why the analogous sum vanishes if $T$ were the Riemann curvature tensor $R$ of the Levi-Civita connection $\\nabla$. The sum in question would be:\n$$\n(\\nabla_X R)(Y,Z)W + (\\nabla_Y R)(Z,X)W + (\\nabla_Z R)(X,Y)W.\n$$\nThis expression is the subject of the **second Bianchi identity**. This identity is a fundamental property of the Riemann curvature tensor associated with any torsion-free connection, which includes the Levi-Civita connection. The identity states that this exact sum is identically zero for all vector fields $X, Y, Z, W$:\n$$\n(\\nabla_X R)(Y,Z)W + (\\nabla_Y R)(Z,X)W + (\\nabla_Z R)(X,Y)W = 0.\n$$\nThis identity holds because the Riemann tensor $R$ is not an arbitrary tensor field but is intrinsically defined by the connection $\\nabla$ itself, specifically through the relation $R(X,Y)Z = \\nabla_X\\nabla_Y Z - \\nabla_Y\\nabla_X Z - \\nabla_{[X,Y]}Z$. The second Bianchi identity can be derived from this definition and is equivalent to the Jacobi identity for the operators $[\\nabla_X, \\nabla_Y]$.\nIn contrast, the tensor $T$ in this problem is an artificially constructed field with no inherent relationship to the connection $\\nabla$. It does not possess the special symmetries and properties of the Riemann tensor, and thus there is no reason for it to satisfy the second Bianchi identity. Our calculation, yielding a non-zero result, explicitly demonstrates this fact. For the Euclidean plane, its Riemann tensor $R$ is identically zero, so the sum would trivially be zero, but the identity holds for any manifold, regardless of its curvature.", "answer": "$$\\boxed{4}$$", "id": "3077216"}, {"introduction": "While theoretical proofs establish universal truth, verifying these truths in practice can build powerful intuition, especially in non-trivial settings. This final exercise guides you from abstract definitions to a concrete computational tool. You will implement an algorithm to construct the connection, the Riemann tensor, and its covariant derivative from first principles, and then use it to verify the second Bianchi identity numerically for a family of curved spaces [@problem_id:3077229]. This practice demonstrates the identity's robustness and bridges the gap between symbolic manipulation and modern computational geometry.", "problem": "Consider a smooth manifold with a Riemannian metric and the associated Levi-Civita connection. The Riemann curvature tensor is defined from the connection, and its covariant derivative satisfies a fundamental identity known as the second Bianchi identity. Your task is to implement and test an algorithmic verification of the second Bianchi identity for a specific family of metrics by starting from core geometric definitions and constructing the relevant tensors step by step.\n\nStarting from the following foundational base:\n- A Riemannian metric assigns to each point a positive-definite symmetric bilinear form on the tangent space. In local coordinates, this is encoded by a symmetric matrix of functions $g_{ij}(x)$.\n- The Levi-Civita connection is the unique torsion-free metric-compatible connection. Its Christoffel symbols are given by the formula\n$$\n\\Gamma^{\\ell}{}_{ij} = \\tfrac{1}{2} g^{\\ell s} \\left(\\partial_i g_{js} + \\partial_j g_{is} - \\partial_s g_{ij}\\right),\n$$\nwhere $g^{\\ell s}$ is the inverse matrix to $g_{\\ell s}$, and $\\partial_i$ denotes the partial derivative with respect to the coordinate $x^i$.\n- The Riemann curvature tensor with one index raised is defined by\n$$\nR^{\\ell}{}_{ijk} = \\partial_j \\Gamma^{\\ell}{}_{ik} - \\partial_k \\Gamma^{\\ell}{}_{ij} + \\Gamma^{\\ell}{}_{js} \\Gamma^{s}{}_{ik} - \\Gamma^{\\ell}{}_{ks} \\Gamma^{s}{}_{ij},\n$$\nwith the summation convention over repeated indices.\n- The covariant derivative of a $(1,3)$-tensor $T^{\\ell}{}_{ijk}$ is given by\n$$\n(\\nabla_m T)^{\\ell}{}_{ijk} = \\partial_m T^{\\ell}{}_{ijk} + \\Gamma^{\\ell}{}_{ms} T^{s}{}_{ijk} - \\Gamma^{s}{}_{mi} T^{\\ell}{}_{sjk} - \\Gamma^{s}{}_{mj} T^{\\ell}{}_{isk} - \\Gamma^{s}{}_{mk} T^{\\ell}{}_{ijs}.\n$$\n\nYou must build a program that:\n1. Implements the computation of the Christoffel symbols from the metric via the above definition.\n2. Implements the computation of the Riemann curvature tensor via its definition in terms of the Christoffel symbols.\n3. Implements the computation of the covariant derivative of the Riemann curvature tensor by the above definition.\n4. Computes, for a given point $x$ and a given metric $g_{ij}(x)$, the cyclic sum\n$$\n(\\nabla_j R)^{\\ell}{}_{ikm} + (\\nabla_k R)^{\\ell}{}_{imj} + (\\nabla_m R)^{\\ell}{}_{ijk}\n$$\nand evaluates its maximum absolute component (the supremum norm over all free indices).\n\nVerification target:\n- The second Bianchi identity states that the above cyclic sum vanishes identically:\n$$\n(\\nabla_j R)^{\\ell}{}_{ikm} + (\\nabla_k R)^{\\ell}{}_{imj} + (\\nabla_m R)^{\\ell}{}_{ijk} = 0.\n$$\n\nMetric family to test:\n- Restrict to conformally flat metrics of the form\n$$\ng_{ij}(x) = e^{2\\phi(x)} \\delta_{ij},\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta and $\\phi$ is a smooth scalar function. You must implement a procedure that constructs all required objects from first principles using the above definitions. For these conformal metrics, it is permissible to exploit algebraic simplifications that follow from substituting $g_{ij}(x) = e^{2\\phi(x)} \\delta_{ij}$ into the core definitions, as long as you derive them from the stated base.\n\nTesting guidelines:\n- Implement the above for general dimension $n \\in \\{2,3\\}$.\n- For the conformal metric $g_{ij} = e^{2\\phi} \\delta_{ij}$, use the following choices for $\\phi$:\n  - Case A (flat): $\\phi(x) = 0$.\n  - Case B (linear): $\\phi(x) = a_1 x^1 + \\cdots + a_n x^n$ with prescribed constants.\n  - Case C (quadratic radial): $\\phi(x) = \\alpha \\sum_{i=1}^n (x^i)^2$ with prescribed constant $\\alpha$.\n\nYour program must, for each test case, compute the supremum norm of the cyclic sum above and return a boolean indicating whether it is smaller than a given tolerance. Use a tolerance of $10^{-10}$.\n\nTest suite:\n- Use the following dimensions, parameter values, and evaluation points:\n  1. $n=3$, $\\phi(x) = 0$, evaluate at $x = (0.12,-0.30,0.05)$.\n  2. $n=3$, $\\phi(x) = 0.2 x^1 - 0.1 x^2 + 0.05 x^3$, evaluate at $x = (0.3,-0.4,0.1)$.\n  3. $n=3$, $\\phi(x) = 0.2 \\sum_{i=1}^3 (x^i)^2$, evaluate at $x = (-0.2,0.5,0.4)$.\n  4. $n=2$, $\\phi(x) = -0.3 \\sum_{i=1}^2 (x^i)^2$, evaluate at $x = (0.6,-0.4)$.\n\nQuantifiable output specification:\n- For each test case, compute the maximum absolute value over all indices of the tensor\n$$\nB^{\\ell}{}_{ijkm} = (\\nabla_j R)^{\\ell}{}_{ikm} + (\\nabla_k R)^{\\ell}{}_{imj} + (\\nabla_m R)^{\\ell}{}_{ijk},\n$$\nand output a boolean equal to $\\mathrm{True}$ if this maximum is strictly less than $10^{-10}$, and $\\mathrm{False}$ otherwise.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4]$, where each $r_i$ is either $\\mathrm{True}$ or $\\mathrm{False}$ corresponding to the test cases in the order listed above. No other text should be printed.", "solution": "We begin from the foundational definitions for a Riemannian manifold. In coordinates, a metric is a symmetric positive-definite matrix of functions $g_{ij}(x)$. The Levi-Civita connection is characterized by being torsion-free and metric-compatible, which yields the Christoffel symbols\n$$\n\\Gamma^{\\ell}{}_{ij} = \\tfrac{1}{2} g^{\\ell s} \\left(\\partial_i g_{js} + \\partial_j g_{is} - \\partial_s g_{ij}\\right).\n$$\nThe Riemann curvature tensor with one index raised is constructed from $\\Gamma$ by\n$$\nR^{\\ell}{}_{ijk} = \\partial_j \\Gamma^{\\ell}{}_{ik} - \\partial_k \\Gamma^{\\ell}{}_{ij} + \\Gamma^{\\ell}{}_{js} \\Gamma^{s}{}_{ik} - \\Gamma^{\\ell}{}_{ks} \\Gamma^{s}{}_{ij}.\n$$\nFor a $(1,3)$-tensor $T^{\\ell}{}_{ijk}$, its covariant derivative is\n$$\n(\\nabla_m T)^{\\ell}{}_{ijk} = \\partial_m T^{\\ell}{}_{ijk} + \\Gamma^{\\ell}{}_{ms} T^{s}{}_{ijk} - \\Gamma^{s}{}_{mi} T^{\\ell}{}_{sjk} - \\Gamma^{s}{}_{mj} T^{\\ell}{}_{isk} - \\Gamma^{s}{}_{mk} T^{\\ell}{}_{ijs}.\n$$\n\nWe aim to verify the second Bianchi identity,\n$$\n(\\nabla_j R)^{\\ell}{}_{ikm} + (\\nabla_k R)^{\\ell}{}_{imj} + (\\nabla_m R)^{\\ell}{}_{ijk} = 0,\n$$\nfor conformally flat metrics\n$$\ng_{ij}(x) = e^{2\\phi(x)} \\delta_{ij}.\n$$\nTo do this algorithmically from first principles, we apply the above definitions and substitute the special form of the metric into them. For $g_{ij} = e^{2\\phi} \\delta_{ij}$, one can derive the following explicit expression for the Levi-Civita connection by direct substitution into the defining formula. First compute $\\partial_i g_{js} = 2 e^{2\\phi} (\\partial_i \\phi) \\delta_{js}$. Then $g^{\\ell s} = e^{-2\\phi} \\delta^{\\ell s}$. Substituting and simplifying yields\n$$\n\\Gamma^{\\ell}{}_{ij} = \\delta^{\\ell}{}_i \\, \\partial_j \\phi + \\delta^{\\ell}{}_j \\, \\partial_i \\phi - \\delta_{ij} \\, \\partial^\\ell \\phi,\n$$\nwhere $\\partial^\\ell \\phi = \\delta^{\\ell s} \\partial_s \\phi$. This follows entirely from the Levi-Civita formula specialized to the conformal metric and the algebraic properties of the Kronecker delta.\n\nWe next compute the curvature tensor using its definition in terms of the connection. The curvature depends on $\\partial_j \\Gamma^{\\ell}{}_{ik}$ and $\\Gamma \\Gamma$ products. For the conformal metric, $\\partial_m \\Gamma^{\\ell}{}_{ij}$ depends only on the Hessian $\\partial_i \\partial_j \\phi$:\n$$\n\\partial_m \\Gamma^{\\ell}{}_{ij} = \\delta^{\\ell}{}_i \\, \\partial_{jm} \\phi + \\delta^{\\ell}{}_j \\, \\partial_{im} \\phi - \\delta_{ij} \\, \\partial^{\\ell}{}_m \\phi,\n$$\nwith $\\partial^{\\ell}{}_m \\phi = \\delta^{\\ell s} \\partial_{sm} \\phi$ and $\\partial_{jm} \\phi = \\partial_j \\partial_m \\phi$.\n\nThus, for $R^{\\ell}{}_{ijk}$, we can evaluate\n$$\nR^{\\ell}{}_{ijk} = \\left(\\partial_j \\Gamma^{\\ell}{}_{ik} - \\partial_k \\Gamma^{\\ell}{}_{ij}\\right) + \\Gamma^{\\ell}{}_{js} \\Gamma^{s}{}_{ik} - \\Gamma^{\\ell}{}_{ks} \\Gamma^{s}{}_{ij},\n$$\nentirely in terms of the gradient $\\partial_i \\phi$ and Hessian $\\partial_{ij} \\phi$, without invoking any numerical differentiation.\n\nTo compute the covariant derivative $(\\nabla_m R)^{\\ell}{}_{ijk}$, we use its definition. The partial derivative part $\\partial_m R^{\\ell}{}_{ijk}$ contains two types of terms: derivatives of $\\partial_j \\Gamma^{\\ell}{}_{ik} - \\partial_k \\Gamma^{\\ell}{}_{ij}$, and derivatives of the $\\Gamma \\Gamma$ products. The former depend on third derivatives of $\\phi$ (derivatives of the Hessian), while the latter depend on the Hessian via $\\partial_m \\Gamma$. For the specific test family of functions $\\phi$ used here (constant, linear, quadratic), the third derivatives vanish:\n- For $\\phi(x) = 0$, all derivatives vanish.\n- For linear $\\phi(x)$, the Hessian vanishes, so the curvature is built purely from $\\Gamma \\Gamma$ terms and all second derivatives are zero.\n- For quadratic $\\phi(x)$, the Hessian is constant, so its derivatives vanish and $\\partial_m \\partial_j \\Gamma^{\\ell}{}_{ik} = 0$.\n\nTherefore, for our test suite, we have\n$$\n\\partial_m R^{\\ell}{}_{ijk} = \\partial_m\\left(\\Gamma^{\\ell}{}_{js} \\Gamma^{s}{}_{ik} - \\Gamma^{\\ell}{}_{ks} \\Gamma^{s}{}_{ij}\\right)\n= (\\partial_m \\Gamma^{\\ell}{}_{js}) \\Gamma^{s}{}_{ik} + \\Gamma^{\\ell}{}_{js} (\\partial_m \\Gamma^{s}{}_{ik})\n- (\\partial_m \\Gamma^{\\ell}{}_{ks}) \\Gamma^{s}{}_{ij} - \\Gamma^{\\ell}{}_{ks} (\\partial_m \\Gamma^{s}{}_{ij}),\n$$\nwith $\\partial_m \\Gamma^{\\ell}{}_{ij}$ given explicitly by the Hessian as above. This allows computing $\\partial_m R^{\\ell}{}_{ijk}$ exactly (up to floating-point arithmetic) for the chosen $\\phi$ without resorting to numerical differentiation.\n\nFinally, we assemble $(\\nabla_m R)^{\\ell}{}_{ijk}$ using the connection correction terms:\n$$\n(\\nabla_m R)^{\\ell}{}_{ijk} = \\partial_m R^{\\ell}{}_{ijk}\n+ \\Gamma^{\\ell}{}_{ms} R^{s}{}_{ijk} - \\Gamma^{s}{}_{mi} R^{\\ell}{}_{sjk} - \\Gamma^{s}{}_{mj} R^{\\ell}{}_{isk} - \\Gamma^{s}{}_{mk} R^{\\ell}{}_{ijs}.\n$$\nWe then compute the cyclic sum\n$$\nB^{\\ell}{}_{ijkm} = (\\nabla_j R)^{\\ell}{}_{ikm} + (\\nabla_k R)^{\\ell}{}_{imj} + (\\nabla_m R)^{\\ell}{}_{ijk}.\n$$\n\nAlgorithmic plan:\n1. Implement a routine to evaluate $\\phi$, its gradient $\\partial_i \\phi$, and its Hessian $\\partial_{ij} \\phi$ for the cases $\\phi(x)=0$, linear $\\phi$, and quadratic radial $\\phi$ in dimensions $n=2$ and $n=3$.\n2. Build the Kronecker delta $\\delta_{ij}$.\n3. Compute $\\Gamma^{\\ell}{}_{ij}$ from the gradient by the derived formula specialized to conformal metrics.\n4. Compute $\\partial_m \\Gamma^{\\ell}{}_{ij}$ from the Hessian.\n5. Compute $R^{\\ell}{}_{ijk}$ from $\\partial_j \\Gamma^{\\ell}{}_{ik}$, $\\partial_k \\Gamma^{\\ell}{}_{ij}$, and $\\Gamma \\Gamma$.\n6. Compute $\\partial_m R^{\\ell}{}_{ijk}$ using the product rule as above (third derivatives vanish for our test suite).\n7. Compute $(\\nabla_m R)^{\\ell}{}_{ijk}$ using its definition.\n8. Form the cyclic sum $B^{\\ell}{}_{ijkm}$ and take the supremum norm over all indices.\n9. Compare the supremum norm with the tolerance $10^{-10}$ to yield a boolean result for each test case.\n\nTest suite:\n- Case 1: $n=3$, $\\phi(x)=0$, at $x=(0.12,-0.30,0.05)$.\n- Case 2: $n=3$, $\\phi(x)=0.2 x^1 - 0.1 x^2 + 0.05 x^3$, at $x=(0.3,-0.4,0.1)$.\n- Case 3: $n=3$, $\\phi(x)=0.2 \\sum_{i=1}^3 (x^i)^2$, at $x=(-0.2,0.5,0.4)$.\n- Case 4: $n=2$, $\\phi(x)=-0.3 \\sum_{i=1}^2 (x^i)^2$, at $x=(0.6,-0.4)$.\n\nFor each case, the program computes the supremum norm of $B^{\\ell}{}_{ijkm}$ and returns $\\mathrm{True}$ if it is less than $10^{-10}$, confirming the second Bianchi identity to numerical precision. Because all computations are exact algebraic evaluations in terms of $\\partial_i \\phi$ and $\\partial_{ij} \\phi$ for these cases, the supremum norm should be at the level of floating-point roundoff, ensuring that the booleans are $\\mathrm{True}$ for all test cases. The final output will be a single line containing a Python list of booleans in the order of the test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef kronecker_delta(n):\n    return np.eye(n)\n\ndef phi_and_derivatives(n, phi_type, params, x):\n    \"\"\"\n    Returns phi, grad (shape (n,)), hess (shape (n,n)) for given phi_type.\n    Supported:\n      - 'zero': phi = 0\n      - 'linear': phi = sum_i coeffs[i] * x[i]\n      - 'quadratic': phi = alpha * sum_i x[i]^2\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    assert x.shape == (n,)\n    if phi_type == 'zero':\n        phi = 0.0\n        grad = np.zeros(n)\n        hess = np.zeros((n, n))\n    elif phi_type == 'linear':\n        coeffs = np.asarray(params.get('coeffs', np.zeros(n)), dtype=float)\n        assert coeffs.shape == (n,)\n        phi = float(np.dot(coeffs, x))\n        grad = coeffs.copy()\n        hess = np.zeros((n, n))\n    elif phi_type == 'quadratic':\n        alpha = float(params.get('alpha', 0.0))\n        phi = float(alpha * np.dot(x, x))\n        grad = 2.0 * alpha * x\n        hess = 2.0 * alpha * np.eye(n)\n    else:\n        raise ValueError(\"Unsupported phi_type\")\n    return phi, grad, hess\n\ndef gamma_from_grad(grad):\n    \"\"\"Compute Christoffel symbols Gamma^l_{ij} for conformal metric g=e^{2phi} delta.\"\"\"\n    n = grad.shape[0]\n    delta = kronecker_delta(n)\n    Gamma = np.zeros((n, n, n))  # l, i, j\n    for l in range(n):\n        for i in range(n):\n            for j in range(n):\n                Gamma[l, i, j] = (delta[l, i] * grad[j]\n                                  + delta[l, j] * grad[i]\n                                  - delta[i, j] * grad[l])\n    return Gamma\n\ndef dgamma_from_hess(hess):\n    \"\"\"Compute partial derivatives of Gamma: dGamma[p, l, i, j] = ∂_p Gamma^l_{ij}.\"\"\"\n    n = hess.shape[0]\n    delta = kronecker_delta(n)\n    dGamma = np.zeros((n, n, n, n))  # p, l, i, j\n    # ∂_p Γ^l_{ij} = δ^l_i φ_{jp} + δ^l_j φ_{ip} - δ_{ij} φ^l_p\n    # here φ^l_p = δ^{ls} φ_{sp} = φ_{lp}\n    for p in range(n):\n        for l in range(n):\n            for i in range(n):\n                for j in range(n):\n                    dGamma[p, l, i, j] = (delta[l, i] * hess[j, p]\n                                          + delta[l, j] * hess[i, p]\n                                          - delta[i, j] * hess[l, p])\n    return dGamma\n\ndef riemann_from_grad_hess(grad, hess):\n    \"\"\"Compute Riemann tensor R^l_{ijk} for conformal metric using grad and hess.\"\"\"\n    n = grad.shape[0]\n    Gamma = gamma_from_grad(grad)\n    dGamma = dgamma_from_hess(hess)\n    R = np.zeros((n, n, n, n))  # l, i, j, k\n    for l in range(n):\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    val = dGamma[j, l, i, k] - dGamma[k, l, i, j]\n                    # add Gamma-Gamma terms\n                    tmp = 0.0\n                    for s in range(n):\n                        tmp += Gamma[l, j, s] * Gamma[s, i, k] - Gamma[l, k, s] * Gamma[s, i, j]\n                    R[l, i, j, k] = val + tmp\n    return R, Gamma, dGamma\n\ndef dR_from_grad_hess(grad, hess, Gamma, dGamma):\n    \"\"\"\n    Compute partial derivatives of R: dR[m, l, i, j, k] = ∂_m R^l_{ijk}.\n    For phi up to quadratic, third derivatives vanish, so derivative of (∂_j Γ - ∂_k Γ) is zero.\n    Only derivatives of Gamma-Gamma products contribute.\n    \"\"\"\n    n = grad.shape[0]\n    dR = np.zeros((n, n, n, n, n))  # m, l, i, j, k\n    for m in range(n):\n        for l in range(n):\n            for i in range(n):\n                for j in range(n):\n                    for k in range(n):\n                        acc = 0.0\n                        for s in range(n):\n                            # derivative of Γ^l_{js} Γ^s_{ik}\n                            acc += dGamma[m, l, j, s] * Gamma[s, i, k] + Gamma[l, j, s] * dGamma[m, s, i, k]\n                            # subtract derivative of Γ^l_{ks} Γ^s_{ij}\n                            acc -= dGamma[m, l, k, s] * Gamma[s, i, j] + Gamma[l, k, s] * dGamma[m, s, i, j]\n                        dR[m, l, i, j, k] = acc\n    return dR\n\ndef covariant_derivative_of_R(m, R, dR, Gamma):\n    \"\"\"\n    Compute (nabla_m R)^l_{ijk} using:\n    (∇_m R)^l_{ijk} = ∂_m R^l_{ijk} + Γ^l_{ms} R^s_{ijk} - Γ^s_{mi} R^l_{sjk}\n                      - Γ^s_{mj} R^l_{isk} - Γ^s_{mk} R^l_{ijs}\n    Returns array of shape (l, i, j, k).\n    \"\"\"\n    n = Gamma.shape[0]\n    DmR = np.zeros((n, n, n, n))\n    for l in range(n):\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    val = dR[m, l, i, j, k]\n                    for s in range(n):\n                        val += Gamma[l, m, s] * R[s, i, j, k]\n                        val -= Gamma[s, m, i] * R[l, s, j, k]\n                        val -= Gamma[s, m, j] * R[l, i, s, k]\n                        val -= Gamma[s, m, k] * R[l, i, j, s]\n                    DmR[l, i, j, k] = val\n    return DmR\n\ndef bianchi_max_norm(grad, hess):\n    \"\"\"\n    Compute the maximum absolute value of the cyclic sum:\n    B^l_{ijkm} = (∇_j R)^l_{ikm} + (∇_k R)^l_{imj} + (∇_m R)^l_{ijk}\n    Returns the sup norm over all indices.\n    \"\"\"\n    R, Gamma, dGamma = riemann_from_grad_hess(grad, hess)\n    dR = dR_from_grad_hess(grad, hess, Gamma, dGamma)\n    n = grad.shape[0]\n    # Precompute DmR for all m\n    D = np.zeros((n, n, n, n, n))  # m, l, i, j, k\n    for m in range(n):\n        D[m] = covariant_derivative_of_R(m, R, dR, Gamma)\n    max_abs = 0.0\n    for l in range(n):\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    for m in range(n):\n                        val = D[j, l, i, k, m] + D[k, l, i, m, j] + D[m, l, i, j, k]\n                        absval = abs(val)\n                        if absval > max_abs:\n                            max_abs = absval\n    return max_abs\n\ndef run_test_case(n, phi_type, params, x, tol=1e-10):\n    _, grad, hess = phi_and_derivatives(n, phi_type, params, x)\n    max_norm = bianchi_max_norm(grad, hess)\n    return max_norm < tol\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: n=3, phi=0, x=(0.12,-0.30,0.05)\n        {'n': 3, 'phi_type': 'zero', 'params': {}, 'x': [0.12, -0.30, 0.05]},\n        # Case 2: n=3, phi=0.2 x1 - 0.1 x2 + 0.05 x3, x=(0.3,-0.4,0.1)\n        {'n': 3, 'phi_type': 'linear', 'params': {'coeffs': [0.2, -0.1, 0.05]}, 'x': [0.3, -0.4, 0.1]},\n        # Case 3: n=3, phi=0.2 (x1^2 + x2^2 + x3^2), x=(-0.2,0.5,0.4)\n        {'n': 3, 'phi_type': 'quadratic', 'params': {'alpha': 0.2}, 'x': [-0.2, 0.5, 0.4]},\n        # Case 4: n=2, phi=-0.3 (x1^2 + x2^2), x=(0.6,-0.4)\n        {'n': 2, 'phi_type': 'quadratic', 'params': {'alpha': -0.3}, 'x': [0.6, -0.4]},\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case['n']\n        phi_type = case['phi_type']\n        params = case['params']\n        x = case['x']\n        res = run_test_case(n, phi_type, params, x, tol=1e-10)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3077229"}]}