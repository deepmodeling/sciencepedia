{"hands_on_practices": [{"introduction": "The most direct way to understand the Lie bracket is to see it in action. This first exercise guides you through a foundational calculation in the familiar setting of the Euclidean plane, $\\mathbb{R}^2$. By applying the definition of the Lie bracket as a commutator of derivations on smooth functions, you will compute the bracket of two vector fields and determine if they commute, building essential computational skills. [@problem_id:3073904]", "problem": "Let $M=\\mathbb{R}^{2}$ with its standard smooth structure and the standard coordinate frame $\\{\\partial_{x},\\partial_{y}\\}$. Consider the smooth vector fields $X$ and $Y$ on $M$ given by $X=x^{2}\\,\\partial_{x}+x y\\,\\partial_{y}$ and $Y=y\\,\\partial_{x}+x\\,\\partial_{y}$. Using only the definition of the Lie bracket of vector fields as a commutator of derivations on smooth functions, namely that for any smooth function $f$ one has $[X,Y](f)=X\\big(Y(f)\\big)-Y\\big(X(f)\\big)$, compute the coordinate expression of $[X,Y]$ with respect to the frame $\\{\\partial_{x},\\partial_{y}\\}$. Then, based on your computation, determine whether $X$ and $Y$ commute on all of $M$. \n\nProvide as your final answer the pair of component functions of $[X,Y]$ in the order corresponding to $(\\partial_{x},\\partial_{y})$, written as a single row matrix. No numerical approximation is required.", "solution": "We begin from the definition of the Lie bracket of vector fields as a commutator of derivations on smooth functions: for any smooth function $f$, the Lie bracket is defined by $[X,Y](f)=X\\big(Y(f)\\big)-Y\\big(X(f)\\big)$. To identify the coordinate components of a vector field $Z=A\\,\\partial_{x}+B\\,\\partial_{y}$ in the frame $\\{\\partial_{x},\\partial_{y}\\}$, it suffices to evaluate $Z$ on the coordinate functions $x$ and $y$, since $Z(x)=A$ and $Z(y)=B$ follow from the facts $\\partial_{x}(x)=1$, $\\partial_{y}(x)=0$, $\\partial_{x}(y)=0$, and $\\partial_{y}(y)=1$.\n\nWe apply this to $[X,Y]$. First compute $[X,Y](x)$:\n- Compute $Y(x)$. Using $Y=y\\,\\partial_{x}+x\\,\\partial_{y}$ and that $\\partial_{x}(x)=1$, $\\partial_{y}(x)=0$, we obtain $Y(x)=y\\cdot 1+x\\cdot 0=y$.\n- Then compute $X\\big(Y(x)\\big)=X(y)$. Using $X=x^{2}\\,\\partial_{x}+x y\\,\\partial_{y}$ and that $\\partial_{x}(y)=0$, $\\partial_{y}(y)=1$, we obtain $X(y)=x^{2}\\cdot 0+x y\\cdot 1=x y$.\n- Next compute $X(x)$. Using $\\partial_{x}(x)=1$, $\\partial_{y}(x)=0$, we find $X(x)=x^{2}\\cdot 1+x y\\cdot 0=x^{2}$.\n- Then compute $Y\\big(X(x)\\big)=Y(x^{2})$. Using $Y=y\\,\\partial_{x}+x\\,\\partial_{y}$ and that $\\partial_{x}(x^{2})=2x$, $\\partial_{y}(x^{2})=0$, we obtain $Y(x^{2})=y\\cdot 2x+x\\cdot 0=2 x y$.\nTherefore,\n$$\n[X,Y](x)=X\\big(Y(x)\\big)-Y\\big(X(x)\\big)=x y-2 x y=-x y.\n$$\nHence the $\\partial_{x}$-component of $[X,Y]$ is $-x y$.\n\nNext compute $[X,Y](y)$:\n- Compute $Y(y)$. Using $\\partial_{x}(y)=0$, $\\partial_{y}(y)=1$, we find $Y(y)=y\\cdot 0+x\\cdot 1=x$.\n- Then $X\\big(Y(y)\\big)=X(x)$. From above, $X(x)=x^{2}$.\n- Compute $X(y)$. From above, $X(y)=x y$.\n- Then compute $Y\\big(X(y)\\big)=Y(x y)$. Using the product rule via derivations, or directly via coordinates, note that $\\partial_{x}(x y)=y$ and $\\partial_{y}(x y)=x$, so $Y(x y)=y\\cdot y+x\\cdot x=y^{2}+x^{2}$.\nTherefore,\n$$\n[X,Y](y)=X\\big(Y(y)\\big)-Y\\big(X(y)\\big)=x^{2}-(y^{2}+x^{2})=-y^{2}.\n$$\nHence the $\\partial_{y}$-component of $[X,Y]$ is $-y^{2}$.\n\nCollecting components, we have\n$$\n[X,Y]=-x y\\,\\partial_{x}-y^{2}\\,\\partial_{y}.\n$$\nThis vector field is not the zero field on $\\mathbb{R}^{2}$, for example at any point with $y\\neq 0$ it is nonzero. Consequently, the vector fields $X$ and $Y$ do not commute on all of $M$.\n\nThe requested coordinate components of $[X,Y]$ in the order $(\\partial_{x},\\partial_{y})$ are $(-x y,\\,-y^{2})$.", "answer": "$$\\boxed{\\begin{pmatrix}-x y & -y^{2}\\end{pmatrix}}$$", "id": "3073904"}, {"introduction": "Moving from local computations to global structures, this practice explores the Lie bracket on the $n$-torus, a classic example of a compact Lie group. You will demonstrate that the Lie bracket of any two left-invariant vector fields on the torus vanishes. This important result illustrates a deep connection: the algebraic properties of the Lie bracket reflect the geometric properties of the underlying space, in this case, the commutativity of the torus. [@problem_id:3073919]", "problem": "Let $T^n$ denote the $n$-torus realized as $(\\mathbb{R}/2\\pi \\mathbb{Z})^n$ with global angular coordinates $(\\theta^1,\\dots,\\theta^n)$, where angles are measured in radians. Consider the group structure on $T^n$ given by componentwise addition modulo $2\\pi$, so that $T^n$ is a compact Lie group. Endow $T^n$ with any Riemannian metric $g$ specified by a constant, symmetric, positive-definite matrix $G$ in the global coordinate frame $\\left\\{\\frac{\\partial}{\\partial \\theta^1},\\dots,\\frac{\\partial}{\\partial \\theta^n}\\right\\}$, so that $g\\left(\\frac{\\partial}{\\partial \\theta^i},\\frac{\\partial}{\\partial \\theta^j}\\right)=G_{ij}$ at every point.\n\nA vector field $X$ on $T^n$ is called left-invariant if its value is preserved under the pushforward by left translations in the group structure. In these global coordinates, a left-invariant vector field has constant coefficients and can be written as $X=\\sum_{i=1}^n a_i \\frac{\\partial}{\\partial \\theta^i}$ for constants $a_1,\\dots,a_n\\in\\mathbb{R}$. Similarly, let $Y=\\sum_{j=1}^n b_j \\frac{\\partial}{\\partial \\theta^j}$ be another left-invariant vector field with constants $b_1,\\dots,b_n\\in\\mathbb{R}$.\n\nUsing only foundational definitions and rules, and without invoking any pre-packaged identities other than the definition of the Lie bracket, compute the Lie bracket $[X,Y]$ as a vector field by evaluating $[X,Y](f)$ on an arbitrary smooth function $f:T^n\\to\\mathbb{R}$. Your derivation should start from the definition of the Lie bracket of vector fields $[X,Y]$ and standard properties of partial derivatives on smooth functions. Conclude whether $[X,Y]$ vanishes and explain why this reflects the structure of the Lie algebra of $T^n$.\n\nExpress your final answer as the single analytic expression for $[X,Y]$ in the global coordinate frame.", "solution": "The Lie bracket of two vector fields $X$ and $Y$ is a third vector field, $[X,Y]$, defined by its action on an arbitrary smooth function $f \\in C^\\infty(T^n)$. The definition is given by:\n$$[X,Y](f) = X(Y(f)) - Y(X(f))$$\nHere, $X(f)$ denotes the directional derivative of $f$ along the vector field $X$.\n\nThe given vector fields are expressed in the global coordinate basis $\\left\\{\\frac{\\partial}{\\partial \\theta^k}\\right\\}_{k=1}^n$ as:\n$$X = \\sum_{i=1}^n a_i \\frac{\\partial}{\\partial \\theta^i}$$\n$$Y = \\sum_{j=1}^n b_j \\frac{\\partial}{\\partial \\theta^j}$$\nwhere the coefficients $a_i$ and $b_j$ are real constants for all $i, j \\in \\{1, \\dots, n\\}$.\n\nFirst, we compute the action of $Y$ on $f$. By definition of a vector field acting on a function:\n$$Y(f) = \\left(\\sum_{j=1}^n b_j \\frac{\\partial}{\\partial \\theta^j}\\right)(f) = \\sum_{j=1}^n b_j \\frac{\\partial f}{\\partial \\theta^j}$$\nThis result is a new smooth function on $T^n$.\n\nNext, we apply the vector field $X$ to the function $Y(f)$:\n$$X(Y(f)) = X\\left(\\sum_{j=1}^n b_j \\frac{\\partial f}{\\partial \\theta^j}\\right) = \\left(\\sum_{i=1}^n a_i \\frac{\\partial}{\\partial \\theta^i}\\right)\\left(\\sum_{j=1}^n b_j \\frac{\\partial f}{\\partial \\theta^j}\\right)$$\nSince the partial derivative operator $\\frac{\\partial}{\\partial \\theta^i}$ is linear and the coefficients $a_i$ and $b_j$ are constants, we can distribute the operators:\n$$X(Y(f)) = \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j \\frac{\\partial}{\\partial \\theta^i}\\left(\\frac{\\partial f}{\\partial \\theta^j}\\right) = \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j \\frac{\\partial^2 f}{\\partial \\theta^i \\partial \\theta^j}$$\n\nNow, we perform the computation for the second term, $Y(X(f))$, in a symmetric manner. First, we compute $X(f)$:\n$$X(f) = \\left(\\sum_{i=1}^n a_i \\frac{\\partial}{\\partial \\theta^i}\\right)(f) = \\sum_{i=1}^n a_i \\frac{\\partial f}{\\partial \\theta^i}$$\n\nThen, we apply $Y$ to the function $X(f)$:\n$$Y(X(f)) = Y\\left(\\sum_{i=1}^n a_i \\frac{\\partial f}{\\partial \\theta^i}\\right) = \\left(\\sum_{j=1}^n b_j \\frac{\\partial}{\\partial \\theta^j}\\right)\\left(\\sum_{i=1}^n a_i \\frac{\\partial f}{\\partial \\theta^i}\\right)$$\nAgain, using linearity and the fact that the coefficients are constant:\n$$Y(X(f)) = \\sum_{j=1}^n \\sum_{i=1}^n b_j a_i \\frac{\\partial}{\\partial \\theta^j}\\left(\\frac{\\partial f}{\\partial \\theta^i}\\right) = \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j \\frac{\\partial^2 f}{\\partial \\theta^j \\partial \\theta^i}$$\n\nNow we substitute these two results into the definition of the Lie bracket:\n$$[X,Y](f) = \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j \\frac{\\partial^2 f}{\\partial \\theta^i \\partial \\theta^j} - \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j \\frac{\\partial^2 f}{\\partial \\theta^j \\partial \\theta^i}$$\n$$[X,Y](f) = \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j \\left( \\frac{\\partial^2 f}{\\partial \\theta^i \\partial \\theta^j} - \\frac{\\partial^2 f}{\\partial \\theta^j \\partial \\theta^i} \\right)$$\nSince $f$ is a smooth function (class $C^\\infty$, and certainly at least $C^2$), Clairaut's theorem on the symmetry of second partial derivatives holds. This theorem states that for a function with continuous second partial derivatives, the order of differentiation does not matter:\n$$\\frac{\\partial^2 f}{\\partial \\theta^i \\partial \\theta^j} = \\frac{\\partial^2 f}{\\partial \\theta^j \\partial \\theta^i}$$\nTherefore, the term in the parenthesis is zero for all $i$ and $j$:\n$$\\frac{\\partial^2 f}{\\partial \\theta^i \\partial \\theta^j} - \\frac{\\partial^2 f}{\\partial \\theta^j \\partial \\theta^i} = 0$$\nThis leads to the final result for the action of the bracket on $f$:\n$$[X,Y](f) = \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j (0) = 0$$\nSince $[X,Y](f) = 0$ for any arbitrary smooth function $f$ on $T^n$, the vector field $[X,Y]$ must be the zero vector field.\n$$[X,Y] = 0$$\n\n**Interpretation**\n\nThe set of all left-invariant vector fields on a Lie group $G$ forms a vector space which is isomorphic to the tangent space at the identity, $T_e G$. This vector space, when endowed with the Lie bracket operation, is defined as the Lie algebra of the group, denoted $\\mathfrak{g}$.\n\nOur calculation shows that for any two left-invariant vector fields $X$ and $Y$ on the torus $T^n$, their Lie bracket is the zero vector field: $[X,Y] = 0$. This means that the Lie algebra of $T^n$, denoted $\\mathfrak{t}^n$, is an abelian Lie algebra. This result is a direct reflection of the underlying group structure. The Lie group $T^n$ is an abelian (commutative) group because its operation is componentwise addition, which is commutative. A fundamental theorem in Lie theory states that a Lie group is abelian if and only if its Lie algebra is abelian. The calculation performed is an explicit verification of this principle for the specific case of the $n$-torus. The fact that vector fields with constant coefficients in a coordinate chart commute is a general result, and in this case, the global chart on $T^n$ allows this property to extend to all left-invariant fields.", "answer": "$$\\boxed{0}$$", "id": "3073919"}, {"introduction": "To master the Lie bracket, it is crucial to understand its coordinate representation and fundamental algebraic properties. This hands-on computational exercise tasks you with deriving the coordinate formula for the Lie bracket and implementing it numerically. By writing a program to verify bilinearity and antisymmetry, you will bridge the gap between abstract theory and concrete application, solidifying your understanding of the rules that govern vector field interactions. [@problem_id:2987430]", "problem": "You are to implement, from first principles, the coordinate computation of the Lie bracket for smooth vector fields on Euclidean space and numerically verify two of its defining algebraic properties. Work entirely in the setting of the smooth manifold $\\mathbb{R}^{n}$ with global Cartesian coordinates. A smooth vector field $X$ on $\\mathbb{R}^{n}$ assigns to each point $p \\in \\mathbb{R}^{n}$ a tangent vector $X(p) \\in T_{p}\\mathbb{R}^{n} \\cong \\mathbb{R}^{n}$ and acts as a derivation on smooth functions $f \\colon \\mathbb{R}^{n} \\to \\mathbb{R}$ via $X(f)$. The Lie bracket $[X,Y]$ of two smooth vector fields $X$ and $Y$ is defined by the commutator of derivations, namely $[X,Y](f) \\coloneqq X(Y(f)) - Y(X(f))$ for every smooth function $f$. Starting from these core definitions and the standard coordinate basis on $\\mathbb{R}^{n}$, derive the coordinate expression of $[X,Y]$ and implement a numerical procedure to evaluate it at specified points in $\\mathbb{R}^{n}$.\n\nYour program must:\n- Represent vector fields $X$ on $\\mathbb{R}^{n}$ by their component functions with polynomial coefficients in the standard coordinates.\n- Numerically evaluate the partial derivatives of component functions by a finite-difference scheme of your choice that is consistent with the smoothness of the data.\n- Use the derived coordinate expression of the Lie bracket $[X,Y]$ to evaluate $[X,Y](p)$ at given points $p \\in \\mathbb{R}^{n}$.\n- Verify numerically the bilinearity in each argument and antisymmetry of the Lie bracket on a fixed test suite, within a specified tolerance.\n\nUse the following fixed test suite, which you must implement exactly as stated:\n\n- Dimension: $n = 3$.\n- Evaluation points: $p_{1} = (0,0,0)$, $p_{2} = (1,-1,2)$, $p_{3} = \\left(\\tfrac{1}{2}, -2, 1\\right)$.\n- Vector fields on $\\mathbb{R}^{3}$:\n  - $X(x,y,z) = \\big(x^{2} y,\\,-y z,\\, x + 2\\big)$.\n  - $Y(x,y,z) = \\big(y^{2},\\, x z,\\, -x y\\big)$.\n  - $Z(x,y,z) = \\big(1,\\, x,\\, z^{2}\\big)$.\n  - The zero field $O(x,y,z) = (0,0,0)$.\n- Real scalars: $a = 2$, $b = -3$.\n- Finite-difference step: $h = 10^{-6}$.\n- Numerical tolerance for equality: $\\varepsilon = 10^{-9}$.\n\nUsing these data, your program must compute boolean results for the following five cases, each interpreted as a uniform bound over all three evaluation points $p_{1}, p_{2}, p_{3}$ using the maximum absolute componentwise difference:\n1. Antisymmetry: verify that $[X,Y] + [Y,X]$ equals the zero field within tolerance $\\varepsilon$ at each evaluation point.\n2. Bilinearity in the first slot: verify that $[a X + b Y, Z]$ equals $a[X,Z] + b[Y,Z]$ within tolerance $\\varepsilon$ at each evaluation point.\n3. Bilinearity in the second slot: verify that $[X, a Y + b Z]$ equals $a[X,Y] + b[X,Z]$ within tolerance $\\varepsilon$ at each evaluation point.\n4. Zero field: verify that $[O, Y]$ equals the zero field within tolerance $\\varepsilon$ at each evaluation point.\n5. Identical fields: verify that $[X, X]$ equals the zero field within tolerance $\\varepsilon$ at each evaluation point.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of tests $1$ through $5$. For example, the output format must be exactly like $[r_{1},r_{2},r_{3},r_{4},r_{5}]$, where each $r_{k}$ is either the literal $True$ or $False$. No physical units or angle units are involved in this problem, and no percentages are required. All computations must be self-contained and require no user input.", "solution": "### Derivation of the Coordinate Expression for the Lie Bracket\n\nLet the setting be the smooth manifold $\\mathbb{R}^{n}$ with global Cartesian coordinates $(x^1, x^2, \\ldots, x^n)$. The standard basis for the tangent space at any point is $\\{\\frac{\\partial}{\\partial x^1}, \\frac{\\partial}{\\partial x^2}, \\ldots, \\frac{\\partial}{\\partial x^n}\\}$. A smooth vector field $X$ can be written as a linear combination of these basis vectors with smooth component functions $X^i \\colon \\mathbb{R}^{n} \\to \\mathbb{R}$:\n$$\nX = \\sum_{i=1}^{n} X^i(x^1, \\ldots, x^n) \\frac{\\partial}{\\partial x^i}\n$$\nThe action of a vector field $X$ on a smooth function $f \\colon \\mathbb{R}^{n} \\to \\mathbb{R}$, denoted $X(f)$, is the directional derivative of $f$ along $X$:\n$$\nX(f) = \\sum_{i=1}^{n} X^i \\frac{\\partial f}{\\partial x^i}\n$$\nThe Lie bracket $[X,Y]$ of two smooth vector fields $X$ and $Y$ is defined by its action on any smooth function $f$ as the commutator of the derivations $X$ and $Y$:\n$$\n[X,Y](f) \\coloneqq X(Y(f)) - Y(X(f))\n$$\nTo find the components of the vector field $[X,Y]$, we expand this definition. Let $X = \\sum_i X^i \\frac{\\partial}{\\partial x^i}$ and $Y = \\sum_j Y^j \\frac{\\partial}{\\partial x^j}$.\n\nFirst, we compute $X(Y(f))$:\n$$\nY(f) = \\sum_{j=1}^{n} Y^j \\frac{\\partial f}{\\partial x^j}\n$$\nSince $Y^j$ and $\\frac{\\partial f}{\\partial x^j}$ are smooth functions, $Y(f)$ is a smooth function. Now we apply $X$ to this function:\n$$\nX(Y(f)) = X\\left( \\sum_{j=1}^{n} Y^j \\frac{\\partial f}{\\partial x^j} \\right) = \\sum_{i=1}^{n} X^i \\frac{\\partial}{\\partial x^i} \\left( \\sum_{j=1}^{n} Y^j \\frac{\\partial f}{\\partial x^j} \\right)\n$$\nUsing the product rule for derivatives, $\\frac{\\partial}{\\partial x^i}(ab) = (\\frac{\\partial a}{\\partial x^i})b + a(\\frac{\\partial b}{\\partial x^i})$, we get:\n$$\nX(Y(f)) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} X^i \\left( \\frac{\\partial Y^j}{\\partial x^i} \\frac{\\partial f}{\\partial x^j} + Y^j \\frac{\\partial^2 f}{\\partial x^i \\partial x^j} \\right)\n$$\n$$\nX(Y(f)) = \\sum_{j=1}^{n} \\left( \\sum_{i=1}^{n} X^i \\frac{\\partial Y^j}{\\partial x^i} \\right) \\frac{\\partial f}{\\partial x^j} + \\sum_{i,j=1}^{n} X^i Y^j \\frac{\\partial^2 f}{\\partial x^i \\partial x^j}\n$$\nBy symmetry, we can find $Y(X(f))$ by swapping the roles of $X$ and $Y$, and the indices $i$ and $j$:\n$$\nY(X(f)) = \\sum_{j=1}^{n} \\left( \\sum_{i=1}^{n} Y^i \\frac{\\partial X^j}{\\partial x^i} \\right) \\frac{\\partial f}{\\partial x^j} + \\sum_{i,j=1}^{n} Y^i X^j \\frac{\\partial^2 f}{\\partial x^i \\partial x^j}\n$$\nNow, we compute the commutator $[X,Y](f) = X(Y(f)) - Y(X(f))$. The terms involving second derivatives of $f$ are:\n$$\n\\sum_{i,j=1}^{n} X^i Y^j \\frac{\\partial^2 f}{\\partial x^i \\partial x^j} - \\sum_{i,j=1}^{n} Y^i X^j \\frac{\\partial^2 f}{\\partial x^i \\partial x^j}\n$$\nSince $f$ is smooth, its mixed partial derivatives are equal (Clairaut's theorem): $\\frac{\\partial^2 f}{\\partial x^i \\partial x^j} = \\frac{\\partial^2 f}{\\partial x^j \\partial x^i}$. By relabeling the summation indices in the second term ($i \\leftrightarrow j$), it becomes $\\sum_{j,i=1}^{n} Y^j X^i \\frac{\\partial^2 f}{\\partial x^j \\partial x^i} = \\sum_{i,j=1}^{n} X^i Y^j \\frac{\\partial^2 f}{\\partial x^i \\partial x^j}$. Thus, the second derivative terms cancel out.\n\nThe remaining terms give:\n$$\n[X,Y](f) = \\sum_{j=1}^{n} \\left( \\sum_{i=1}^{n} X^i \\frac{\\partial Y^j}{\\partial x^i} \\right) \\frac{\\partial f}{\\partial x^j} - \\sum_{j=1}^{n} \\left( \\sum_{i=1}^{n} Y^i \\frac{\\partial X^j}{\\partial x^i} \\right) \\frac{\\partial f}{\\partial x^j}\n$$\n$$\n[X,Y](f) = \\sum_{j=1}^{n} \\left( \\sum_{i=1}^{n} \\left( X^i \\frac{\\partial Y^j}{\\partial x^i} - Y^i \\frac{\\partial X^j}{\\partial x^i} \\right) \\right) \\frac{\\partial f}{\\partial x^j}\n$$\nThis expression is in the form $\\sum_j Z^j \\frac{\\partial f}{\\partial x^j}$, which shows that $[X,Y]$ is indeed a vector field. The $j$-th component of $[X,Y]$, denoted $([X,Y])^j$, is:\n$$\n([X,Y])^j = \\sum_{i=1}^{n} \\left( X^i \\frac{\\partial Y^j}{\\partial x^i} - Y^i \\frac{\\partial X^j}{\\partial x^i} \\right)\n$$\nThis can be compactly expressed using the Jacobian matrices of the vector fields. Let $X$ and $Y$ be represented as column vectors of their component functions. Let $J_X$ and $J_Y$ be their Jacobian matrices, where $(J_V)_{ji} = \\frac{\\partial V^j}{\\partial x^i}$. The expression $\\sum_i X^i \\frac{\\partial Y^j}{\\partial x^i}$ is the $j$-th component of the matrix-vector product $J_Y X$. Therefore, the vector $[X,Y]$ is given by:\n$$\n[X,Y] = J_Y X - J_X Y\n$$\nThis is the coordinate formula we will implement.\n\n### Numerical Implementation and Verification\n\nThe numerical procedure consists of three main parts:\n1.  **Representing Vector Fields**: The vector fields $X$, $Y$, and $Z$ on $\\mathbb{R}^3$ are implemented as functions that take a $3$-dimensional point (as a NumPy array) and return a $3$-dimensional vector (NumPy array) of their components evaluated at that point.\n2.  **Numerical Differentiation**: To compute the Jacobian matrices $J_X$ and $J_Y$ at a point $p$, we need the partial derivatives of their component functions. Since these functions are smooth (polynomials), we can use a second-order central finite-difference scheme, which offers a good balance between accuracy and simplicity. The partial derivative of a function $g$ with respect to $x^i$ at point $p$ is approximated by:\n    $$\n    \\frac{\\partial g}{\\partial x^i}(p) \\approx \\frac{g(p + h \\cdot e_i) - g(p - h \\cdot e_i)}{2h}\n    $$\n    where $e_i$ is the standard basis vector in the $i$-th direction and $h = 10^{-6}$ is a small step size. This formula is applied to each component of a vector field to construct its Jacobian matrix column by column.\n3.  **Evaluating the Lie Bracket**: With the ability to compute Jacobians and evaluate vector fields, the Lie bracket $[X,Y]$ at a point $p$ is computed directly using the derived formula $[X,Y](p) = J_Y(p)X(p) - J_X(p)Y(p)$.\n4.  **Verification of Properties**: The five specified algebraic properties are tested numerically. For each property, an identity of the form $LHS = RHS$ is checked. We compute the vectors corresponding to the left-hand side and right-hand side at each of the three evaluation points $p_1, p_2, p_3$. The identity is considered numerically verified for a given point if the maximum absolute difference between the components of the LHS and RHS vectors is less than the tolerance $\\varepsilon = 10^{-9}$. A property is confirmed as `True` only if this holds for all three points.\n\nThe five tests are:\n1.  **Antisymmetry**: $[X,Y] + [Y,X] = O$.\n2.  **Bilinearity (1st slot)**: $[aX+bY, Z] = a[X,Z] + b[Y,Z]$.\n3.  **Bilinearity (2nd slot)**: $[X, aY+bZ] = a[X,Y] + b[X,Z]$.\n4.  **Zero field property**: $[O,Y] = O$.\n5.  **Identical fields property**: $[X,X] = O$.\n\nThe numerical errors from the finite-difference approximation are of order $O(h^2) \\approx 10^{-12}$. The chosen tolerance $\\varepsilon = 10^{-9}$ is sufficiently large to account for these truncation errors and floating-point round-off errors, while being small enough to confirm the identities.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies properties of the Lie bracket for vector fields on R^3.\n    \"\"\"\n    # Define the test suite parameters from the problem statement.\n    n = 3\n    p1 = np.array([0.0, 0.0, 0.0])\n    p2 = np.array([1.0, -1.0, 2.0])\n    p3 = np.array([0.5, -2.0, 1.0])\n    evaluation_points = [p1, p2, p3]\n\n    a = 2.0\n    b = -3.0\n    h = 1e-6\n    epsilon = 1e-9\n\n    # --- Vector Field Definitions ---\n    # The vector fields are functions that take a point p (numpy array)\n    # and return a vector (numpy array).\n    def X_vf(p):\n        x, y, z = p\n        return np.array([x**2 * y, -y * z, x + 2.0])\n\n    def Y_vf(p):\n        x, y, z = p\n        return np.array([y**2, x * z, -x * y])\n\n    def Z_vf(p):\n        x, y, z = p\n        return np.array([1.0, x, z**2])\n\n    def O_vf(p):\n        return np.zeros(n)\n\n    # --- Core Numerical Functions ---\n    def numerical_jacobian(vf, p, h_step, dim):\n        \"\"\"\n        Computes the Jacobian matrix of a vector field vf at point p\n        using a central finite-difference scheme.\n        (J_vf)_ji = d(vf_j)/d(x_i)\n        \"\"\"\n        J = np.zeros((dim, dim))\n        for i in range(dim):\n            p_plus = p.copy()\n            p_minus = p.copy()\n            p_plus[i] += h_step\n            p_minus[i] -= h_step\n            \n            # The i-th column of the Jacobian is the partial derivative\n            # of the vector field with respect to the i-th coordinate.\n            J[:, i] = (vf(p_plus) - vf(p_minus)) / (2.0 * h_step)\n        return J\n\n    def lie_bracket(vf1, vf2, p, h_step, dim):\n        \"\"\"\n        Computes the Lie bracket [vf1, vf2] at point p using the formula\n        [vf1, vf2] = J_vf2 @ vf1 - J_vf1 @ vf2.\n        \"\"\"\n        J1 = numerical_jacobian(vf1, p, h_step, dim)\n        J2 = numerical_jacobian(vf2, p, h_step, dim)\n        \n        v1_p = vf1(p)\n        v2_p = vf2(p)\n        \n        return J2 @ v1_p - J1 @ v2_p\n\n    results = []\n\n    # --- Test 1: Antisymmetry: [X,Y] + [Y,X] = 0 ---\n    test1_valid = True\n    for p in evaluation_points:\n        lhs = lie_bracket(X_vf, Y_vf, p, h, n) + lie_bracket(Y_vf, X_vf, p, h, n)\n        rhs = O_vf(p)\n        if np.max(np.abs(lhs - rhs)) >= epsilon:\n            test1_valid = False\n            break\n    results.append(test1_valid)\n\n    # --- Test 2: Bilinearity in the first slot: [aX + bY, Z] = a[X,Z] + b[Y,Z] ---\n    test2_valid = True\n    # Define the combined vector field for the LHS\n    vf_ax_by = lambda p_vec: a * X_vf(p_vec) + b * Y_vf(p_vec)\n    for p in evaluation_points:\n        lhs = lie_bracket(vf_ax_by, Z_vf, p, h, n)\n        rhs = a * lie_bracket(X_vf, Z_vf, p, h, n) + b * lie_bracket(Y_vf, Z_vf, p, h, n)\n        if np.max(np.abs(lhs - rhs)) >= epsilon:\n            test2_valid = False\n            break\n    results.append(test2_valid)\n\n    # --- Test 3: Bilinearity in the second slot: [X, aY + bZ] = a[X,Y] + b[X,Z] ---\n    test3_valid = True\n    # Define the combined vector field for the LHS\n    vf_ay_bz = lambda p_vec: a * Y_vf(p_vec) + b * Z_vf(p_vec)\n    for p in evaluation_points:\n        lhs = lie_bracket(X_vf, vf_ay_bz, p, h, n)\n        rhs = a * lie_bracket(X_vf, Y_vf, p, h, n) + b * lie_bracket(X_vf, Z_vf, p, h, n)\n        if np.max(np.abs(lhs - rhs)) >= epsilon:\n            test3_valid = False\n            break\n    results.append(test3_valid)\n\n    # --- Test 4: Zero field: [O, Y] = 0 ---\n    test4_valid = True\n    for p in evaluation_points:\n        lhs = lie_bracket(O_vf, Y_vf, p, h, n)\n        rhs = O_vf(p)\n        if np.max(np.abs(lhs - rhs)) >= epsilon:\n            test4_valid = False\n            break\n    results.append(test4_valid)\n\n    # --- Test 5: Identical fields: [X, X] = 0 ---\n    test5_valid = True\n    for p in evaluation_points:\n        lhs = lie_bracket(X_vf, X_vf, p, h, n)\n        rhs = O_vf(p)\n        if np.max(np.abs(lhs - rhs)) >= epsilon:\n            test5_valid = False\n            break\n    results.append(test5_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2987430"}]}