{"hands_on_practices": [{"introduction": "This first practice provides a direct, hands-on opportunity to execute the Extended Euclidean Algorithm. By working through a concrete example with positive integers, you will master the mechanical steps of both finding the greatest common divisor and performing the back-substitution to find a pair of Bézout coefficients. This foundational skill is the bedrock upon which more complex applications are built [@problem_id:3082249].", "problem": "Let $a$ and $b$ be integers with $a=141$ and $b=96$. The greatest common divisor $\\gcd(a,b)$ is defined as the largest positive integer that divides both $a$ and $b$. A fundamental fact is that any common divisor of $a$ and $b$ divides every integer combination $ua+vb$ for integers $u$ and $v$, and conversely, the set of all integer combinations $\\{ua+vb: u,v \\in \\mathbb{Z}\\}$ consists precisely of the multiples of $\\gcd(a,b)$. The Euclidean algorithm is the procedure based on the well-tested identity $\\gcd(a,b)=\\gcd(b,a \\bmod b)$ that computes $\\gcd(a,b)$ by repeated division with remainder. Bézout’s identity asserts that there exist integers $x$ and $y$ such that $ax+by=\\gcd(a,b)$. The Extended Euclidean Algorithm (EEA) is the method that, alongside the Euclidean algorithm, tracks the integer coefficients yielding such a representation.\n\nStarting from these foundations, carry out the Extended Euclidean Algorithm (EEA) for $a=141$ and $b=96$ to compute explicit integers $x$ and $y$ satisfying $141x+96y=\\gcd(141,96)$. You must present the Euclidean algorithm divisions and either perform back-substitution through these equations or maintain iterative updates of the coefficients that express each remainder as an integer combination of $141$ and $96$. Your final answer must be the specific ordered pair $(x,y)$ that certifies Bézout’s identity for these inputs. No rounding is required.", "solution": "The problem as stated is valid. It is a well-posed, self-contained mathematical problem within the domain of number theory, based on established principles of the Euclidean algorithm and Bézout's identity. All necessary information is provided, and the objective is clear.\n\nThe task is to find integers $x$ and $y$ such that $141x + 96y = \\gcd(141, 96)$. We shall employ the Extended Euclidean Algorithm. The first phase is to compute the greatest common divisor, $\\gcd(141, 96)$, using the standard Euclidean algorithm, which proceeds by a sequence of divisions with remainder.\n\nLet $a = 141$ and $b = 96$.\n\nStep 1: Divide $141$ by $96$.\n$$141 = 1 \\cdot 96 + 45$$\nThe remainder is $r_1 = 45$.\n\nStep 2: Divide $96$ by the previous remainder, $45$.\n$$96 = 2 \\cdot 45 + 6$$\nThe remainder is $r_2 = 6$.\n\nStep 3: Divide $45$ by the previous remainder, $6$.\n$$45 = 7 \\cdot 6 + 3$$\nThe remainder is $r_3 = 3$.\n\nStep 4: Divide $6$ by the previous remainder, $3$.\n$$6 = 2 \\cdot 3 + 0$$\nThe remainder is $r_4 = 0$.\n\nThe last non-zero remainder is the greatest common divisor. Therefore, $\\gcd(141, 96) = 3$.\n\nThe second phase is to express this gcd, $3$, as an integer linear combination of $141$ and $96$. This is achieved by working backward through the steps of the Euclidean algorithm (a process known as back-substitution).\n\nWe start from the equation that yielded the gcd, which is the equation from Step 3, and solve for the remainder $3$:\n$$3 = 45 - 7 \\cdot 6$$\n\nNext, we use the equation from the preceding step (Step 2) to express the remainder $6$ in terms of $96$ and $45$:\n$$6 = 96 - 2 \\cdot 45$$\nWe substitute this expression for $6$ into our equation for $3$:\n$$3 = 45 - 7 \\cdot (96 - 2 \\cdot 45)$$\nNow, we distribute and collect terms with common factors of $45$ and $96$:\n$$3 = 45 - 7 \\cdot 96 + 14 \\cdot 45$$\n$$3 = (1 + 14) \\cdot 45 - 7 \\cdot 96$$\n$$3 = 15 \\cdot 45 - 7 \\cdot 96$$\n\nFinally, we use the equation from the first step (Step 1) to express the remainder $45$ in terms of the original numbers, $141$ and $96$:\n$$45 = 141 - 1 \\cdot 96$$\nWe substitute this expression for $45$ into our current equation for $3$:\n$$3 = 15 \\cdot (141 - 1 \\cdot 96) - 7 \\cdot 96$$\nAgain, we distribute and collect terms, this time with common factors of $141$ and $96$:\n$$3 = 15 \\cdot 141 - 15 \\cdot 96 - 7 \\cdot 96$$\n$$3 = 15 \\cdot 141 + (-15 - 7) \\cdot 96$$\n$$3 = 15 \\cdot 141 - 22 \\cdot 96$$\n\nThis final equation expresses the gcd, $3$, as an integer linear combination of $141$ and $96$. It is in the form $141x + 96y = 3$. By direct comparison, we identify the integer coefficients $x$ and $y$:\n$$x = 15$$\n$$y = -22$$\n\nAs a check, we can compute the value of the expression: $141(15) + 96(-22) = 2115 - 2112 = 3$. This confirms the correctness of the solution. The required ordered pair is $(x, y)$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n15 & -22\n\\end{pmatrix}\n}\n$$", "id": "3082249"}, {"introduction": "Building upon the basic algorithm, this exercise introduces two important complexities: handling negative inputs and exploring the full family of possible solutions. You will find that for a given pair of integers $(a, b)$, there are infinitely many valid Bézout coefficients. This practice challenges you to find the general form of these solutions and then select the specific pair that satisfies an additional condition, such as having the smallest possible absolute value for one of the coefficients [@problem_id:3082279].", "problem": "Let $a=-84$ and $b=30$. Recall that the greatest common divisor $\\gcd(a,b)$ is defined to be the unique positive generator of the ideal $\\{au+bv: u,v \\in \\mathbb{Z}\\}$, and that Bézout's identity asserts the existence of integers $x$ and $y$ such that $ax+by=\\gcd(a,b)$. Using only the definition of $\\gcd$ as a positive generator of the ideal and the Euclidean algorithm with back-substitution, determine integers $x$ and $y$ such that $ax+by=\\gcd(a,b)$, making sure that $\\gcd(a,b)>0$ even though $a0$. Among all such integer pairs, report the pair $(x,y)$ with $|x|$ minimized. Your final answer should be this ordered pair of integers.", "solution": "The problem requires finding integers $x$ and $y$ that satisfy the Bézout's identity for $a=-84$ and $b=30$, with the additional constraint that $|x|$ is minimized. The identity is given by the equation $ax+by=\\gcd(a,b)$.\n\nFirst, we determine the greatest common divisor, $\\gcd(a,b)$. The problem statement defines $\\gcd(a,b)$ as the unique positive generator of the ideal $\\{au+bv: u,v \\in \\mathbb{Z}\\}$. Therefore, $\\gcd(-84, 30)$ must be a positive integer. The greatest common divisor is invariant under changes of sign of its arguments, so $\\gcd(-84, 30) = \\gcd(84, 30)$. We apply the Euclidean algorithm to the positive integers $84$ and $30$:\n$$84 = 2 \\cdot 30 + 24$$\n$$30 = 1 \\cdot 24 + 6$$\n$$24 = 4 \\cdot 6 + 0$$\nThe last non-zero remainder is $6$. Thus, $\\gcd(-84, 30) = 6$.\n\nThe equation to be solved is $-84x + 30y = 6$.\n\nNext, we use the extended Euclidean algorithm (via back-substitution) to find a particular solution. We use the equations from the algorithm above, starting from the one that gives the gcd as a remainder:\n$$6 = 30 - 1 \\cdot 24$$\nFrom the first step of the algorithm, we have $24 = 84 - 2 \\cdot 30$. Substituting this expression for $24$ into the equation for $6$:\n$$6 = 30 - 1 \\cdot (84 - 2 \\cdot 30)$$\nDistributing the $-1$:\n$$6 = 30 - 1 \\cdot 84 + 2 \\cdot 30$$\nCollecting the terms with $30$ and $84$:\n$$6 = (1+2) \\cdot 30 - 1 \\cdot 84$$\n$$6 = 3 \\cdot 30 - 1 \\cdot 84$$\nThis gives the relation $84(-1) + 30(3) = 6$. This is a solution to the equation $84x' + 30y' = 6$, with $(x', y') = (-1, 3)$.\n\nOur target equation is $-84x + 30y = 6$. We can rewrite the identity $84(-1) + 30(3) = 6$ as:\n$$-84(1) + 30(3) = 6$$\nBy comparing this with $-84x + 30y = 6$, we identify a particular solution $(x_0, y_0) = (1, 3)$.\nLet's verify: $-84(1) + 30(3) = -84 + 90 = 6$. The solution is correct.\n\nNow, we find the general solution for the Diophantine equation $-84x + 30y = 6$. First, we can simplify the equation by dividing all terms by $\\gcd(-84, 30) = 6$:\n$$-14x + 5y = 1$$\nOur particular solution $(x_0, y_0) = (1, 3)$ satisfies this simplified equation as well: $-14(1) + 5(3) = -14 + 15 = 1$.\nThe associated homogeneous equation is $-14x + 5y = 0$, which can be written as $5y = 14x$. Since $\\gcd(5, 14)=1$, the general solution for the homogeneous equation must be of the form $x_h = 5k$ and $y_h = 14k$ for any integer $k \\in \\mathbb{Z}$.\n\nThe general solution to the non-homogeneous equation is the sum of a particular solution and the general homogeneous solution:\n$$x(k) = x_0 + x_h = 1 + 5k$$\n$$y(k) = y_0 + y_h = 3 + 14k$$\nwhere $k$ is any integer.\n\nThe problem requires us to find the pair $(x,y)$ for which $|x|$ is minimized. We need to find the integer $k$ that minimizes $|x(k)| = |1+5k|$.\nWe are looking for an integer $k$ such that the value of $1+5k$ is as close to $0$ as possible.\nTo find this $k$, we can analyze the expression. The minimum value of $|1+5k|$ will occur for the integer $k$ closest to the real number $t$ which makes $1+5t=0$, i.e., $t = -1/5 = -0.2$. The integers closest to $-0.2$ are $0$ and $-1$. We test these values:\nIf $k=0$, $x(0) = 1+5(0) = 1$, and $|x(0)|=1$.\nIf $k=-1$, $x(-1) = 1+5(-1) = -4$, and $|x(-1)|=4$.\nThe minimum absolute value for $x$ is $1$, which occurs uniquely at $k=0$.\n\nFinally, we substitute $k=0$ into the general solution for $(x,y)$ to find the required pair:\n$$x = 1 + 5(0) = 1$$\n$$y = 3 + 14(0) = 3$$\nThe resulting pair of integers is $(1, 3)$.\n\nWe verify this final answer. The pair is $(x,y)=(1,3)$. We have $|x|=1$, which is the minimum possible value from the set of all solutions $\\{\\dots, -9, -4, 1, 6, \\dots\\}$. The equation is satisfied: $-84(1) + 30(3) = -84+90 = 6 = \\gcd(-84, 30)$. The solution is consistent with all conditions.", "answer": "$$\\boxed{\\begin{pmatrix} 1  3 \\end{pmatrix}}$$", "id": "3082279"}, {"introduction": "This final practice transitions from manual calculation to computational implementation, a crucial step in applying number theory to modern problems in fields like cryptography. You are tasked with writing a program that not only performs the Extended Euclidean Algorithm but also robustly handles edge cases and large inputs. This exercise emphasizes the importance of careful implementation and consideration of computational constraints like integer overflow [@problem_id:3085685].", "problem": "You are to implement a complete, runnable program that computes Bézout coefficients for integer pairs via the extended Euclidean algorithm, together with the greatest common divisor and the least common multiple. The integers are bounded by $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$. Your approach must start from fundamental number-theoretic definitions and must not assume any pre-packaged results beyond these basics.\n\nFundamental base:\n- Definition of the greatest common divisor: For integers $a$ and $b$ not both zero, the greatest common divisor $\\gcd(a,b)$ is the unique nonnegative integer $g$ such that $g \\mid a$, $g \\mid b$, and for any integer $d$ with $d \\mid a$ and $d \\mid b$ we have $d \\le g$.\n- Division algorithm: For integers $x$ and $y \\ne 0$, there exist unique integers $q$ and $r$ with $x = y q + r$ and $0 \\le r  \\lvert y \\rvert$.\n- Euclidean algorithm: The sequence of remainders $r_0 = \\lvert a \\rvert$, $r_1 = \\lvert b \\rvert$, and $r_{k+1} = r_{k-1} - q_k r_k$ with $q_k = \\lfloor r_{k-1} / r_k \\rfloor$, terminates with $r_m = \\gcd(\\lvert a \\rvert, \\lvert b \\rvert)$.\n- Definition of Bézout coefficients: Integers $x$ and $y$ such that $ax + by = \\gcd(a,b)$.\n- Definition of least common multiple: The least common multiple $\\operatorname{lcm}(a,b)$ is the least nonnegative integer $L$ divisible by both $a$ and $b$; for $a$ and $b$ not both zero, $\\operatorname{lcm}(a,b) = \\lvert ab \\rvert / \\gcd(a,b)$ and $\\operatorname{lcm}(0,0) = 0$.\n\nTask:\n- Implement the extended Euclidean algorithm from the above principles to compute, for each test case, a quadruple $\\big(\\gcd(a,b), x, y, \\operatorname{lcm}(a,b)\\big)$ where $x$ and $y$ satisfy $ax + by = \\gcd(a,b)$ and $\\gcd(a,b) \\ge 0$, with the convention $\\gcd(0,0) = 0$ and any valid Bézout pair $x = 0$, $y = 0$ in that case.\n- Explain, in terms of the underlying integer arithmetic, how to avoid integer overflow in the coefficient updates (which follow recurrences like $s_{k+1} = s_{k-1} - q_k s_k$ and $t_{k+1} = t_{k-1} - q_k t_k$), and how to compute $\\operatorname{lcm}(a,b)$ in a way that avoids overflow.\n\nConstraints:\n- Inputs satisfy $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$.\n- The least common multiple is to be reported as a nonnegative integer, with $\\operatorname{lcm}(0,b) = 0$ for any integer $b$.\n\nTest suite:\nYour program must compute results for the following list of pairs $(a,b)$:\n- $(12,18)$\n- $(0,0)$\n- $(0,5)$\n- $(10^9,1)$\n- $(-10^9,10^9)$\n- $(832040,514229)$\n- $(-24,-18)$\n- $(123456789,987654321)$\n- $(0,-7)$\n- $(1,10^9)$\n- $(7,-3)$\n\nAnswer specification:\n- For each test case, output the list $[\\gcd(a,b), x, y, \\operatorname{lcm}(a,b)]$.\n- Aggregate all test case results, in the given order, into a single line that is a comma-separated list enclosed in square brackets, where each element is itself a list corresponding to one test case. For example, the overall format must be like $[[g_1,x_1,y_1,\\ell_1],[g_2,x_2,y_2,\\ell_2],\\dots]$.\n- The output must be a single line printed by the program. No additional commentary should be printed.\n\nYour submission must be a complete, runnable program as specified, with no user input.", "solution": "The problem is assessed to be valid. It is scientifically grounded in number theory, well-posed, and objective. It provides a complete set of definitions, constraints, and test cases, forming a self-contained and consistent specification for a computational task. We may proceed with the solution.\n\n### Mathematical Foundation\n\n1.  **Greatest Common Divisor (GCD) and Euclidean Algorithm**: The Euclidean algorithm is an efficient method for computing the greatest common divisor (GCD) of two integers. It is based on the principle that $\\gcd(a, b) = \\gcd(b, a \\pmod b)$. The algorithm iteratively applies this property. Given inputs $r_0 = a$ and $r_1 = b$, the sequence is defined by $r_{k+1} = r_{k-1} \\pmod{r_k}$, which is equivalent to $r_{k-1} = q_k r_k + r_{k+1}$ from the division algorithm. The last non-zero remainder, $r_m$, is the GCD. The GCD is defined as non-negative, so we conventionally use absolute values: $\\gcd(a,b) = \\gcd(\\lvert a \\rvert, \\lvert b \\rvert)$. By convention, $\\gcd(0,0)=0$.\n\n2.  **Extended Euclidean Algorithm and Bézout's Identity**: Bézout's identity states that for integers $a$ and $b$, there exist integers $x$ and $y$ (the Bézout coefficients) such that $ax + by = \\gcd(a,b)$. The extended Euclidean algorithm computes these coefficients alongside the GCD. It maintains two sequences, $s_k$ and $t_k$, such that at each step $k$, the identity $r_k = a s_k + b t_k$ holds.\n    Starting with $r_0=a$ and $r_1=b$, we have:\n    - $r_0 = a \\cdot 1 + b \\cdot 0 \\implies (s_0, t_0) = (1, 0)$\n    - $r_1 = a \\cdot 0 + b \\cdot 1 \\implies (s_1, t_1) = (0, 1)$\n    The recurrence for the remainders is $r_{k+1} = r_{k-1} - q_k r_k$. Substituting the Bézout expressions:\n    $$a s_{k+1} + b t_{k+1} = (a s_{k-1} + b t_{k-1}) - q_k (a s_k + b t_k)$$\n    $$a s_{k+1} + b t_{k+1} = a(s_{k-1} - q_k s_k) + b(t_{k-1} - q_k t_k)$$\n    This yields the recurrences for the coefficients:\n    - $s_{k+1} = s_{k-1} - q_k s_k$\n    - $t_{k+1} = t_{k-1} - q_k t_k$\n    The algorithm terminates when $r_{k+1}=0$, at which point $r_k = \\gcd(a,b)$, and the corresponding coefficients are $s_k$ and $t_k$.\n\n3.  **Least Common Multiple (LCM)**: The least common multiple is defined by the identity $\\operatorname{lcm}(a,b) = \\frac{\\lvert a b \\rvert}{\\gcd(a,b)}$ for non-zero $a, b$. The problem specifies that $\\operatorname{lcm}(a,0)=\\operatorname{lcm}(0,b)=0$ for any integer $b$.\n\n### Algorithmic Implementation\n\nThe implementation will consist of a primary function that handles all cases, including the edge cases where one or both inputs are zero. For the general case of non-zero inputs, it will use a helper function implementing the extended Euclidean algorithm.\n\n**Handling Special Cases**:\n- If $a = 0$ and $b = 0$: The problem states $\\gcd(0,0) = 0$ and we choose $x=0, y=0$, so $0 \\cdot 0 + 0 \\cdot 0 = 0$. $\\operatorname{lcm}(0,0)=0$. The result is $(0, 0, 0, 0)$.\n- If $a = 0, b \\ne 0$: $\\gcd(0,b) = \\lvert b \\rvert$. We need $0 \\cdot x + b \\cdot y = \\lvert b \\rvert$. This simplifies to $b \\cdot y = \\lvert b \\rvert$. A solution is $y = \\lvert b \\rvert / b = \\operatorname{sgn}(b)$ and we can choose $x=0$. $\\operatorname{lcm}(0,b)=0$. For example, for $(0,5)$, the result is $(5, 0, 1, 0)$. For $(0,-7)$, it's $(7, 0, -1, 0)$.\n- If $a \\ne 0, b = 0$: Symmetrically, $\\gcd(a,0) = \\lvert a \\rvert$. We need $a \\cdot x + 0 \\cdot y = \\lvert a \\rvert$. This gives $x = \\lvert a \\rvert / a = \\operatorname{sgn}(a)$ and we can choose $y=0$. $\\operatorname{lcm}(a,0)=0$.\n\n**General Case ($a \\ne 0, b \\ne 0$):**\nTo simplify the logic, the extended Euclidean algorithm is first applied to the absolute values of the inputs, $\\lvert a \\rvert$ and $\\lvert b \\rvert$. Let's say this yields $(g, x', y')$ such that $\\lvert a \\rvert x' + \\lvert b \\rvert y' = g$, where $g = \\gcd(\\lvert a \\rvert, \\lvert b \\rvert) = \\gcd(a,b)$. We need to find $x, y$ for the original $a, b$.\nWe can write $a = \\operatorname{sgn}(a) \\lvert a \\rvert$ and $b = \\operatorname{sgn}(b) \\lvert b \\rvert$, where we define $\\operatorname{sgn}(n)=1$ if $n \\ge 0$ and $\\operatorname{sgn}(n)=-1$ if $n  0$. Substituting these into the identity from the algorithm:\n$$\n\\begin{align*}\ng = \\lvert a \\rvert x' + \\lvert b \\rvert y' \\\\\n  = \\left(\\frac{a}{\\operatorname{sgn}(a)}\\right) x' + \\left(\\frac{b}{\\operatorname{sgn}(b)}\\right) y' \\\\\n  = a \\left(\\frac{x'}{\\operatorname{sgn}(a)}\\right) + b \\left(\\frac{y'}{\\operatorname{sgn}(b)}\\right) \\\\\ng = a (\\operatorname{sgn}(a)x') + b (\\operatorname{sgn}(b)y')\n\\end{align*}\n$$\nThus, we can set the final coefficients to be $x = \\operatorname{sgn}(a) x'$ and $y = \\operatorname{sgn}(b) y'$. This systematically handles all sign combinations.\n\n### Avoiding Integer Overflow\n\nThe problem requires an explanation of how to manage potential integer overflows, particularly relevant in languages with fixed-size integers (e.g., a 64-bit `long long` in C++). Python's arbitrary-precision integers abstract this away, but the underlying arithmetic principles are important.\n\n1.  **Bézout Coefficient Updates**: The update steps are $s_{\\text{new}} = s_{\\text{old}} - q \\cdot s$ and $t_{\\text{new}} = t_{\\text{old}} - q \\cdot t$. The coefficients $s$ and $t$ grow during the algorithm. It is a known result (from, e.g., Knuth's TAOCP, Vol. 2) that the final Bézout coefficients $x, y$ produced by the standard algorithm for positive $a, b$ satisfy $\\lvert x \\rvert \\le b/\\gcd(a,b)$ and $\\lvert y \\rvert \\le a/\\gcd(a,b)$. The intermediate coefficients are bounded by these final values. The quotient $q = \\lfloor r_{\\text{old}}/r \\rfloor$ can be large if $r$ is small. For instance, for inputs $(A, 1)$, the first quotient is $A$. One of the update products, e.g., $q \\cdot t$, could be as large as $A \\cdot 1 = A$. In a more complex case, the product $q \\cdot t$ can be approximated. We have $r_{\\text{old}} \\approx q \\cdot r$, and we know $r_{\\text{old}} = a \\cdot s_{\\text{old}} + b \\cdot t_{\\text{old}}$ and $r = a \\cdot s + b \\cdot t$. Thus, $a \\cdot s_{\\text{old}} + b \\cdot t_{\\text{old}} \\approx q(a \\cdot s + b \\cdot t)$. The maximum value of an intermediate product like $q \\cdot t$ is bounded by $\\frac{\\lvert ab \\rvert}{\\gcd(a,b)^2}$. For the given constraints $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$, the largest possible value arises for coprime numbers, where it could be on the order of $\\lvert ab \\rvert \\approx (10^9)^2 = 10^{18}$. This value fits within a standard $64$-bit signed integer (which has a maximum value of approximately $9 \\times 10^{18}$). Therefore, performing the calculations using a $64$-bit integer type is sufficient to prevent overflow in the coefficient updates. Python's standard integers meet this requirement.\n\n2.  **LCM Calculation**: The formula for the LCM is $\\operatorname{lcm}(a,b) = \\frac{\\lvert a \\cdot b \\rvert}{\\gcd(a,b)}$. A naive computation of the numerator $\\lvert a \\cdot b \\rvert$ could overflow if $a$ and $b$ are large. With $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$, the product can be up to $10^{18}$, which as noted, fits within a $64$-bit integer. However, for a general-purpose library function, it is best practice to avoid this intermediate product. Since $\\gcd(a,b)$ divides both $a$ and $b$, the division can be performed before the multiplication. This ensures the intermediate result does not grow unnecessarily large. The safe way to compute the LCM is:\n    $$\\operatorname{lcm}(a,b) = \\left( \\frac{\\lvert a \\rvert}{\\gcd(a,b)} \\right) \\cdot \\lvert b \\rvert$$\n    The division $\\lvert a \\rvert / \\gcd(a,b)$ yields an exact integer. The subsequent multiplication results in the final LCM, which for the given constraints also fits within a $64$-bit integer.\n\nThe provided Python code implements this logic.", "answer": "```python\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    def _compute_bezout_lcm(a, b):\n        \"\"\"\n        Computes the GCD, Bézout coefficients (x, y), and LCM for a pair of integers (a, b).\n        The result is a tuple (g, x, y, l) where:\n        - g = gcd(a, b) = 0\n        - ax + by = g\n        - l = lcm(a, b) = 0\n        \"\"\"\n        if a == 0 and b == 0:\n            return 0, 0, 0, 0\n\n        # Handle cases where one input is zero.\n        # gcd(a, 0) = |a|, lcm(a, 0) = 0.\n        # ax + 0y = |a| = x = |a|/a = sgn(a), y can be 0.\n        if b == 0:\n            g = abs(a)\n            x = 1 if a = 0 else -1\n            y = 0\n            lcm = 0\n            return g, x, y, lcm\n        \n        # gcd(0, b) = |b|, lcm(0, b) = 0.\n        # 0x + by = |b| = y = |b|/b = sgn(b), x can be 0.\n        if a == 0:\n            g = abs(b)\n            x = 0\n            y = 1 if b = 0 else -1\n            lcm = 0\n            return g, x, y, lcm\n\n        # General case (a!=0, b!=0)\n        # We run the extended Euclidean algorithm on |a| and |b|\n        # to ensure the gcd is non-negative and simplify the iteration.\n        sign_a = 1 if a  0 else -1\n        sign_b = 1 if b  0 else -1\n        abs_a = abs(a)\n        abs_b = abs(b)\n\n        # Extended Euclidean Algorithm\n        # Initializes such that old_r = old_s*abs_a + old_t*abs_b and r = s*abs_a + t*abs_b\n        s, old_s = 0, 1\n        t, old_t = 1, 0\n        r, old_r = abs_b, abs_a\n        \n        while r != 0:\n            quotient = old_r // r\n            old_r, r = r, old_r - quotient * r\n            old_s, s = s, old_s - quotient * s\n            old_t, t = t, old_t - quotient * t\n\n        # Result of algorithm on absolute values:\n        # g = gcd(|a|, |b|), x_abs = old_s, y_abs = old_t\n        # such that |a|*x_abs + |b|*y_abs = g\n        g = old_r\n        x_abs = old_s\n        y_abs = old_t\n\n        # Adjust coefficients for original signs of a and b.\n        # We want a*x + b*y = g.\n        # We have |a|*x_abs + |b|*y_abs = g.\n        # Substituting a = sgn(a)*|a| and b = sgn(b)*|b|:\n        # a/(sgn(a))*x_abs + b/(sgn(b))*y_abs = g\n        # a*(sgn(a)*x_abs) + b*(sgn(b)*y_abs) = g\n        # So x = sgn(a)*x_abs and y = sgn(b)*y_abs\n        x = x_abs * sign_a\n        y = y_abs * sign_b\n        \n        # Calculate LCM safely to avoid overflow\n        # lcm(a,b) = (|a| * |b|) / gcd(a,b)\n        # To avoid intermediate overflow, compute as (|a| / gcd) * |b|\n        lcm = (abs_a // g) * abs_b\n        \n        return g, x, y, lcm\n\n    test_cases = [\n        (12, 18),\n        (0, 0),\n        (0, 5),\n        (10**9, 1),\n        (-10**9, 10**9),\n        (832040, 514229),\n        (-24, -18),\n        (123456789, 987654321),\n        (0, -7),\n        (1, 10**9),\n        (7, -3),\n    ]\n\n    results = []\n    for a, b in test_cases:\n        g, x, y, l = _compute_bezout_lcm(a, b)\n        results.append(f\"[{g},{x},{y},{l}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3085685"}]}