{"hands_on_practices": [{"introduction": "The power of index arithmetic lies in its ability to transform complex multiplicative problems into simpler, linear ones. This first exercise provides direct practice in this core technique, converting an exponential congruence into an equivalent linear congruence for the exponent. By working through this problem [@problem_id:3086063], you will not only find the solutions but also gain a deep understanding of how the greatest common divisor, $d = \\gcd(u, p-1)$, governs both the existence and the number of distinct solutions.", "problem": "Let $p$ be the prime $79$, and let $g$ be a fixed primitive root modulo $p$. Consider the congruence\n$$\ng^{u x}\\equiv g^{v}\\pmod p\n$$\nwith $u=30$ and $v=42$. Using index arithmetic (discrete logarithms with respect to the base $g$), reduce this to a linear congruence for $x$ modulo $p-1$, and solve it completely. In your derivation, justify precisely how $\\gcd(u,p-1)$ controls the existence of solutions, the number of distinct solutions modulo $p-1$, and the spacing between them.\n\nProvide your final answer as the complete list of distinct residue classes $x$ modulo $p-1$ written as integers in the interval $[0,p-2]$ in increasing order.", "solution": "The problem is to solve the exponential congruence $g^{u x}\\equiv g^{v}\\pmod p$ for $x$, given the prime $p=79$, a primitive root $g$ modulo $p$, and the integers $u=30$ and $v=42$. The solution for $x$ must be found modulo $p-1$.\n\nSince $p=79$ is a prime number and $g$ is a primitive root modulo $p$, its powers generate all non-zero residue classes modulo $p$. The order of $g$ modulo $p$ is $\\phi(p) = p-1 = 78$. A fundamental property of primitive roots is that they allow the conversion of exponential congruences into linear congruences via index arithmetic. The index of an integer $a$ to the base $g$ modulo $p$, denoted $\\text{ind}_g(a)$, is the exponent $k$ such that $g^k \\equiv a \\pmod p$. The index $k$ is an integer defined modulo $p-1$.\n\nThe given congruence is $g^{u x}\\equiv g^{v}\\pmod p$. Taking the index of both sides with respect to the base $g$ transforms the congruence into one on the exponents. The modulus for this new congruence is the order of $g$, which is $p-1=78$.\n$$\n\\text{ind}_g(g^{u x}) \\equiv \\text{ind}_g(g^{v}) \\pmod{p-1}\n$$\nBy the definition of the index, $\\text{ind}_g(g^k) \\equiv k \\pmod{p-1}$. Applying this property, we obtain the linear congruence for $x$:\n$$\nux \\equiv v \\pmod{p-1}\n$$\nSubstituting the given values $u=30$, $v=42$, and $p-1=78$, we have:\n$$\n30x \\equiv 42 \\pmod{78}\n$$\nThis is a linear congruence of the general form $ax \\equiv b \\pmod n$. Let us analyze its properties as requested.\nA solution to $ax \\equiv b \\pmod n$ exists if and only if $d = \\gcd(a, n)$ is a divisor of $b$. If this condition is met, there are exactly $d$ incongruent solutions modulo $n$. The existence of solutions is thus controlled by the divisibility of $v$ by $d=\\gcd(u, p-1)$. The number of solutions is directly given by $d$.\n\nIn our specific case, $a=u=30$, $b=v=42$, and $n=p-1=78$. We first compute $d = \\gcd(30, 78)$.\nThe prime factorization of $30$ is $2 \\times 3 \\times 5$.\nThe prime factorization of $78$ is $2 \\times 3 \\times 13$.\nThe greatest common divisor is $d = \\gcd(30, 78) = 2 \\times 3 = 6$.\n\nNext, we check the solvability condition: does $d$ divide $v$? Here, $d=6$ and $v=42$. Since $42 = 6 \\times 7$, $d$ divides $v$. Therefore, solutions exist.\nThe number of distinct solutions for $x$ modulo $78$ is exactly $d=6$.\n\nTo find the solutions, we first simplify the congruence $30x \\equiv 42 \\pmod{78}$ by dividing all terms (the coefficient, the constant, and the modulus) by their common divisor $d=6$.\n$$\n\\frac{30}{6}x \\equiv \\frac{42}{6} \\pmod{\\frac{78}{6}}\n$$\nThis yields the reduced congruence:\n$$\n5x \\equiv 7 \\pmod{13}\n$$\nTo solve for $x$, we need to find the multiplicative inverse of $5$ modulo $13$. We seek an integer $y$ such that $5y \\equiv 1 \\pmod{13}$. We can use the Extended Euclidean Algorithm or inspection. By inspection, we find that $5 \\times 8 = 40$. Since $40 = 3 \\times 13 + 1$, we have $5 \\times 8 \\equiv 1 \\pmod{13}$. Thus, the inverse of $5$ modulo $13$ is $8$.\n\nMultiplying both sides of the reduced congruence by $8$:\n$$\n8 \\cdot (5x) \\equiv 8 \\cdot 7 \\pmod{13}\n$$\n$$\n(40)x \\equiv 56 \\pmod{13}\n$$\n$$\nx \\equiv 56 \\pmod{13}\n$$\nTo find the smallest non-negative residue, we reduce $56$ modulo $13$. Since $56 = 4 \\times 13 + 4$, we have $56 \\equiv 4 \\pmod{13}$.\nSo, one particular solution is $x_0 \\equiv 4 \\pmod{13}$. This means $x_0 = 4$ is the smallest non-negative solution to the reduced congruence.\n\nThis solution $x_0=4$ is one of the $6$ solutions to the original congruence modulo $78$. The full set of solutions is given by the formula:\n$$\nx_k = x_0 + k \\cdot \\frac{n}{d} \\quad \\text{for } k \\in \\{0, 1, 2, \\dots, d-1\\}\n$$\nIn our case, $x_0 = 4$, $n=78$, and $d=6$. The increment between solutions is $\\frac{n}{d} = \\frac{78}{6} = 13$. This spacing is a direct consequence of the algebraic structure of the solution set. If $x_0$ is a solution, then for any integer $k$, $u(x_0 + k \\frac{p-1}{d}) = ux_0 + k\\frac{u}{d}(p-1)$. Since $d=\\gcd(u, p-1)$, $\\frac{u}{d}$ is an integer, so $k\\frac{u}{d}(p-1)$ is a multiple of $p-1$. Consequently, $u(x_0 + k \\frac{p-1}{d}) \\equiv ux_0 \\equiv v \\pmod{p-1}$. The $d$ distinct solutions modulo $p-1$ are generated by taking $k$ from $0$ to $d-1$.\n\nThe $6$ distinct solutions for $x$ modulo $78$ are:\nFor $k=0$: $x_0 = 4 + (0)(13) = 4$\nFor $k=1$: $x_1 = 4 + (1)(13) = 17$\nFor $k=2$: $x_2 = 4 + (2)(13) = 30$\nFor $k=3$: $x_3 = 4 + (3)(13) = 43$\nFor $k=4$: $x_4 = 4 + (4)(13) = 56$\nFor $k=5$: $x_5 = 4 + (5)(13) = 69$\n\nThese are the complete list of distinct solutions in the interval $[0, p-2]$, which is $[0, 77]$. They are provided in increasing order as requested.", "answer": "$$\n\\boxed{\\begin{pmatrix} 4 & 17 & 30 & 43 & 56 & 69 \\end{pmatrix}}\n$$", "id": "3086063"}, {"introduction": "While many congruences yield solutions, it is equally important to understand when and why solutions do not exist. This practice [@problem_id:3086051] delves into a case of an unsolvable congruence of the form $x^n \\equiv a \\pmod{p}$. By applying index arithmetic, you will pinpoint the exact algebraic obstruction, which manifests as a failed divisibility condition, thereby turning an abstract theorem into a concrete, computable result.", "problem": "Let $p$ be a prime and let $g$ be a primitive root modulo $p$. For any $a$ with $1 \\le a \\le p-1$, define the index (discrete logarithm) $\\operatorname{ind}_{g}(a)$ to be the unique integer in $\\{0,1,\\dots,p-2\\}$ such that $g^{\\operatorname{ind}_{g}(a)} \\equiv a \\pmod{p}$. Consider the concrete instance with $p=29$, $g=2$, $n=12$, and $a=9$. Using only the group-theoretic structure of $\\left(\\mathbb{Z}/p\\mathbb{Z}\\right)^{\\times}$ and the definition of the index, determine whether the congruence $x^{n} \\equiv a \\pmod{p}$ has a solution. If it does not, compute the exact obstruction to solvability coming from index arithmetic, namely the residue\n$$\nr \\equiv \\operatorname{ind}_{g}(a) \\pmod{d},\n$$\nwhere $d=\\gcd(n,p-1)$ denotes the greatest common divisor (gcd) of $n$ and $p-1$. Report $r$ as an integer in $\\{0,1,\\dots,d-1\\}$. The final answer must be this integer $r$.", "solution": "The problem requires us to determine if the congruence $x^{n} \\equiv a \\pmod{p}$ has a solution for the specific values $p=29$, $g=2$, $n=12$, and $a=9$, and if not, to compute the residue $r \\equiv \\operatorname{ind}_{g}(a) \\pmod{d}$ where $d=\\gcd(n,p-1)$.\n\nFirst, we establish the theoretical criterion for the solvability of such a congruence. The group of units of the ring of integers modulo $p$, denoted $\\left(\\mathbb{Z}/p\\mathbb{Z}\\right)^{\\times}$, is a cyclic group of order $p-1$. A primitive root $g$ is a generator of this group. Any element $b \\in \\left(\\mathbb{Z}/p\\mathbb{Z}\\right)^{\\times}$ can be uniquely represented as $b \\equiv g^k \\pmod{p}$ for some integer $k$ in the range $\\{0, 1, \\dots, p-2\\}$. This integer $k$ is the index of $b$ with respect to the base $g$, denoted $\\operatorname{ind}_{g}(b)$.\n\nThe given congruence is $x^n \\equiv a \\pmod{p}$. Since $a=9$ and $p=29$, $a$ is not a multiple of $p$, so any solution $x$ cannot be a multiple of $p$ either. Thus, $x$ must be an element of $\\left(\\mathbb{Z}/29\\mathbb{Z}\\right)^{\\times}$. We can represent $x$ and $a$ using indices with respect to the primitive root $g=2$:\nLet $x \\equiv g^y \\pmod{p}$ for some unknown integer $y$. Then $x^n \\equiv (g^y)^n = g^{ny} \\pmod{p}$.\nLet $a \\equiv g^{\\operatorname{ind}_g(a)} \\pmod{p}$.\n\nSubstituting these into the congruence, we get:\n$$g^{ny} \\equiv g^{\\operatorname{ind}_g(a)} \\pmod{p}$$\nThis is equivalent to an equation in the exponents, modulo the order of the group, which is $p-1$:\n$$ny \\equiv \\operatorname{ind}_g(a) \\pmod{p-1}$$\nThis is a linear congruence in the variable $y$. According to the theory of linear congruences, a solution for $y$ exists if and only if the greatest common divisor of the coefficient of $y$ and the modulus divides the constant term. That is, a solution exists if and only if $\\gcd(n, p-1)$ divides $\\operatorname{ind}_g(a)$.\n\nLet $d = \\gcd(n, p-1)$. The condition for the solvability of $x^n \\equiv a \\pmod{p}$ is:\n$$\\operatorname{ind}_g(a) \\equiv 0 \\pmod{d}$$\n\nNow, we apply this to the given values:\n- $p = 29$ (a prime number)\n- $n = 12$\n- $a = 9$\n- $g = 2$ (given as a primitive root modulo $29$)\n\nFirst, we calculate $d$:\n$$p-1 = 29-1 = 28$$\n$$d = \\gcd(n, p-1) = \\gcd(12, 28)$$\nTo find the gcd, we can use the Euclidean algorithm or prime factorization.\nThe prime factorization of $12$ is $2^2 \\cdot 3$.\nThe prime factorization of $28$ is $2^2 \\cdot 7$.\nThe greatest common divisor is $d = 2^2 = 4$.\n\nNext, we calculate $\\operatorname{ind}_g(a) = \\operatorname{ind}_2(9)$. We need to find the integer $k \\in \\{0, 1, \\dots, 27\\}$ such that $2^k \\equiv 9 \\pmod{29}$. We compute the powers of $2$ modulo $29$:\n$2^1 \\equiv 2 \\pmod{29}$\n$2^2 \\equiv 4 \\pmod{29}$\n$2^3 \\equiv 8 \\pmod{29}$\n$2^4 \\equiv 16 \\pmod{29}$\n$2^5 \\equiv 32 \\equiv 3 \\pmod{29}$\nSince we need to find the power corresponding to $9$, and we have found that $2^5 \\equiv 3 \\pmod{29}$, we can square this congruence:\n$$(2^5)^2 \\equiv 3^2 \\pmod{29}$$\n$$2^{10} \\equiv 9 \\pmod{29}$$\nThus, the index of $9$ to the base $2$ is $10$.\n$$\\operatorname{ind}_2(9) = 10$$\n\nNow we check the solvability condition: $\\operatorname{ind}_2(9) \\equiv 0 \\pmod{d}$.\nWe test if $10 \\equiv 0 \\pmod{4}$.\n$$10 = 2 \\cdot 4 + 2$$\nSo, $10 \\equiv 2 \\pmod{4}$.\nSince $10 \\not\\equiv 0 \\pmod{4}$, the congruence $x^{12} \\equiv 9 \\pmod{29}$ does not have a solution.\n\nThe problem asks for the obstruction to solvability, which is the residue $r \\equiv \\operatorname{ind}_{g}(a) \\pmod{d}$, where $r$ is an integer in $\\{0, 1, \\dots, d-1\\}$.\nWe have already computed this residue:\n$$r \\equiv 10 \\pmod{4}$$\n$$r = 2$$\nThis value $r=2$ lies in the required set $\\{0, 1, 2, 3\\}$. This non-zero residue is the obstruction.", "answer": "$$\\boxed{2}$$", "id": "3086051"}, {"introduction": "True mastery of a mathematical concept often involves translating it into a working algorithm. This capstone exercise [@problem_id:3086068] challenges you to build a program that solves the general discrete logarithm problem $a^x \\equiv b \\pmod{m}$ for a composite modulus $m$. This practice requires synthesizing index arithmetic, the Chinese Remainder Theorem (CRT), and a detailed knowledge of the structure of unit groups modulo prime powers, offering a comprehensive test of your understanding.", "problem": "Design and implement a complete program that, for each input triple of integers $(a,b,m)$, computes the least nonnegative integer solution $x$ (if it exists) to the congruence\n$$\na^x \\equiv b \\pmod{m},\n$$\nby reducing the problem to prime-power moduli via the Chinese Remainder Theorem (CRT) and using index arithmetic on each prime-power component. Your implementation must be principled and must follow these steps derived from foundational number theory:\n\n- Use the Chinese Remainder Theorem (CRT) to reduce solving $a^x \\equiv b \\pmod{m}$ to simultaneous congruences modulo prime powers $p^k$ dividing $m$.\n- For each odd prime power $p^k$, use the fact that the multiplicative group of units modulo $p^k$ is cyclic of order $\\varphi(p^k) = (p-1)p^{k-1}$, where $\\varphi$ denotes Euler's totient function. Choose a generator $g$ (a primitive root modulo $p^k$) and define the index (discrete logarithm) $\\operatorname{ind}_g(u)$ by the relation $g^{\\operatorname{ind}_g(u)} \\equiv u \\pmod{p^k}$. Transform $a^x \\equiv b \\pmod{p^k}$ into a linear congruence in the exponent using indices and solve it using the extended Euclidean algorithm.\n- For $2$-power moduli $2^k$: use the structure of the multiplicative group of units. For $k=1$ and $k=2$, the group is cyclic, and you may proceed as with odd primes. For $k \\geq 3$, use that the group is isomorphic to $C_2 \\times C_{2^{k-2}}$, generated by $-1$ and $5$. Represent each odd unit $u$ uniquely as $u \\equiv (-1)^e 5^t \\pmod{2^k}$ with $e \\in \\{0,1\\}$ and $t \\in \\{0,\\dots,2^{k-2}-1\\}$, deduce the two congruences in $x$ arising from the two components, and solve them. Combine the two component congruences for $2^k$ using CRT.\n- Combine the solution classes in $x$ from each prime-power component using the Chinese Remainder Theorem, yielding a single arithmetic progression modulo the least common multiple of the component moduli. Select the least nonnegative $x$ in this progression as the answer.\n\nFundamental definitions and facts you may assume:\n- Euler's totient function $\\varphi(n)$ counts integers $1 \\leq k \\leq n$ that are coprime to $n$.\n- If $\\gcd(a,m)=1$, then $a$ is a unit modulo $m$, and the units modulo a prime power $p^k$ form a finite abelian group under multiplication. For odd primes $p$, this group is cyclic of order $\\varphi(p^k)$. For $2^k$ with $k \\geq 3$, the group is the direct product $C_2 \\times C_{2^{k-2}}$ generated by $-1$ and $5$.\n- The Chinese Remainder Theorem (CRT) asserts that solving a system of congruences modulo pairwise coprime moduli is equivalent to solving a single congruence modulo the product; more generally, CRT provides compatibility conditions and a method to combine congruences modulo not-necessarily-coprime moduli.\n\nConstraints and guarantees for the test suite in this problem:\n- Every test case satisfies $\\gcd(a,m) = 1$ and $\\gcd(b,m) = 1$ so that exponents are taken in the multiplicative group of units modulo $m$.\n- If no solution exists, output the integer $-1$ for that case.\n\nTest suite:\n- Case 1: $(a,b,m) = (3,23,77)$.\n- Case 2: $(a,b,m) = (2,20,27)$.\n- Case 3: $(a,b,m) = (5,21,32)$.\n- Case 4: $(a,b,m) = (3,9,40)$.\n- Case 5: $(a,b,m) = (2,3,7)$.\n- Case 6: $(a,b,m) = (3,5,16)$.\n\nAnswer specification:\n- For each test case, the answer must be an integer: the least nonnegative solution $x$ if it exists, or $-1$ if no solution exists.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, a valid output format is of the form $[r_1,r_2,r_3,r_4,r_5,r_6]$ where $r_i$ is the result for Case $i$.\n\nNo physical units are involved in this problem. No angles are involved. All numerical outputs must be integers as specified above.", "solution": "The problem of finding an integer $x$ that solves the congruence $a^x \\equiv b \\pmod{m}$ is known as the discrete logarithm problem. The problem statement prescribes a specific, principled algorithm for its solution, which is a variant of the Pohlig-Hellman algorithm. The core idea is to decompose the problem into smaller, more manageable subproblems using the Chinese Remainder Theorem (CRT) and then solve each subproblem using the algebraic structure of the multiplicative group of units modulo a prime power. The overall strategy can be broken down into the following steps.\n\n**Step 1: Decomposition via the Chinese Remainder Theorem**\n\nLet the prime factorization of the modulus $m$ be $m = p_1^{k_1} p_2^{k_2} \\cdots p_r^{k_r}$. The single congruence $a^x \\equiv b \\pmod{m}$ is equivalent to the system of simultaneous congruences:\n$$\n\\begin{cases}\n    a^x \\equiv b \\pmod{p_1^{k_1}} \\\\\n    a^x \\equiv b \\pmod{p_2^{k_2}} \\\\\n    \\vdots \\\\\n    a^x \\equiv b \\pmod{p_r^{k_r}}\n\\end{cases}\n$$\nWe solve for $x$ in each of these congruences independently. A solution to the original problem must satisfy all of these. Each congruence $a^x \\equiv b \\pmod{p^k}$ yields a solution for $x$ in the form of a congruence class, say $x \\equiv x_i \\pmod{n_i}$.\n\n**Step 2: Solving Congruences for Prime-Power Moduli $p^k$**\n\nThe method for solving $a^x \\equiv b \\pmod{p^k}$ depends on the prime $p$.\n\n**A. Odd Prime Powers ($p > 2$)**\nFor an odd prime $p$, the multiplicative group of units $(\\mathbb{Z}/p^k\\mathbb{Z})^*$ is a cyclic group of order $\\varphi(p^k) = (p-1)p^{k-1}$. This means there exists a generator (or primitive root) $g$ such that every element $u$ in the group can be expressed as a power of $g$. The exponent $j$ in $g^j \\equiv u \\pmod{p^k}$ is called the index or discrete logarithm of $u$ to the base $g$, denoted $\\operatorname{ind}_g(u)$.\n\nBy taking indices of both sides of the congruence $a^x \\equiv b \\pmod{p^k}$, we transform the exponential congruence into a linear congruence in the exponent:\n$$\nx \\cdot \\operatorname{ind}_g(a) \\equiv \\operatorname{ind}_g(b) \\pmod{\\varphi(p^k)}\n$$\nThis is a standard linear congruence of the form $Ax \\equiv B \\pmod{N}$, which can be solved for $x$ using the extended Euclidean algorithm. If $\\gcd(A, N)$ does not divide $B$, there is no solution. Otherwise, a solution of the form $x \\equiv x_0 \\pmod{N/\\gcd(A,N)}$ is found.\n\n**B. Powers of Two ($p = 2$)**\nThe structure of $(\\mathbb{Z}/2^k\\mathbb{Z})^*$ varies with $k$.\n- For $k=1$ ($m=2$) and $k=2$ ($m=4$), the groups are cyclic (of order $1$ and $2$ respectively) and can be handled like the odd prime case.\n- For $k \\geq 3$, the group is not cyclic but is isomorphic to the direct product of two cyclic groups, $C_2 \\times C_{2^{k-2}}$. The group is generated by the elements $-1$ and $5$. Any unit $u \\pmod{2^k}$ can be uniquely written as $u \\equiv (-1)^e 5^t \\pmod{2^k}$, where $e \\in \\{0,1\\}$ and $t \\in \\{0, 1, \\dots, 2^{k-2}-1\\}$.\n\nRepresenting $a$ and $b$ in this form, say $a \\equiv (-1)^{e_a} 5^{t_a} \\pmod{2^k}$ and $b \\equiv (-1)^{e_b} 5^{t_b} \\pmod{2^k}$, the congruence $a^x \\equiv b \\pmod{2^k}$ becomes:\n$$\n((-1)^{e_a} 5^{t_a})^x \\equiv (-1)^{e_b} 5^{t_b} \\pmod{2^k}\n$$\nThis single congruence decomposes into a system of two independent linear congruences for $x$, one for each generator's exponent:\n$$\n\\begin{cases}\n    x \\cdot e_a \\equiv e_b \\pmod{2} \\\\\n    x \\cdot t_a \\equiv t_b \\pmod{2^{k-2}}\n\\end{cases}\n$$\nEach of these is solved. If both have solutions, say $x \\equiv x_1 \\pmod{n_1}$ and $x \\equiv x_2 \\pmod{n_2}$, they must be combined to find an $x$ that satisfies both. This is another application of the CRT.\n\n**Step 3: Synthesis of the Final Solution**\n\nAfter solving for $x$ for each prime-power factor $p_i^{k_i}$ of $m$, we obtain a system of congruences:\n$$\n\\begin{cases}\n    x \\equiv x_1 \\pmod{n_1} \\\\\n    x \\equiv x_2 \\pmod{n_2} \\\\\n    \\vdots \\\\\n    x \\equiv x_r \\pmod{n_r}\n\\end{cases}\n$$\nThese congruences are combined pair-wise using the CRT. For a pair of congruences $x \\equiv c_1 \\pmod{m_1}$ and $x \\equiv c_2 \\pmod{m_2}$, a solution exists if and only if $c_1 \\equiv c_2 \\pmod{\\gcd(m_1, m_2)}$. If a solution exists, it is unique modulo $\\operatorname{lcm}(m_1, m_2)$. By iteratively combining the congruences, we arrive at a single solution of the form $x \\equiv X \\pmod{N}$, where $N = \\operatorname{lcm}(n_1, n_2, \\dots, n_r)$. The least non-negative integer solution is this $X$ taken modulo $N$. If at any stage a subproblem is found to have no solution, the original problem has no solution, and the result is $-1$.\n\nThe implemented program follows this structure, with helper functions for prime factorization, finding generators, computing indices (discrete logarithms), solving linear congruences, and applying the Chinese Remainder Theorem.", "answer": "```python\nimport math\nimport numpy as np\n\n# Note: numpy is imported to satisfy the environment specification, but its\n# functions are not strictly necessary for this number-theoretic problem.\n# Standard Python math and custom functions are used for core logic.\n\ndef _extended_gcd(a, b):\n    \"\"\"Returns (gcd, x, y) such that a*x + b*y = gcd(a, b).\"\"\"\n    if a == 0:\n        return b, 0, 1\n    gcd, x1, y1 = _extended_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return gcd, x, y\n\ndef _solve_linear_congruence(a, b, m):\n    \"\"\"Solves a*x = b (mod m), returns (solution, new_modulus).\"\"\"\n    g, _, _ = _extended_gcd(a, m)\n    if b % g != 0:\n        return -1, -1  # No solution\n    \n    a_prime = a // g\n    b_prime = b // g\n    m_prime = m // g\n    \n    g_prime, inv, _ = _extended_gcd(a_prime, m_prime) # g_prime will be 1\n    \n    solution = (b_prime * inv) % m_prime\n    return solution, m_prime\n\ndef _solve_crt(congruences):\n    \"\"\"Solves a system of congruences x = a_i (mod n_i) using iterative method.\"\"\"\n    if not congruences:\n        return 0, 1\n        \n    a1, n1 = congruences[0]\n    \n    for a2, n2 in congruences[1:]:\n        # System: x = a1 (mod n1), x = a2 (mod n2)\n        # x = a1 + k*n1  =>  a1 + k*n1 = a2 (mod n2) => k*n1 = a2 - a1 (mod n2)\n        k, m = _solve_linear_congruence(n1, a2 - a1, n2)\n        if k == -1:\n            return -1, -1  # Inconsistent system\n\n        # New solution: x = a1 + k*n1 (mod lcm(n1, n2))\n        a1 = a1 + k * n1\n        # m*n1 is lcm(n1, n2) because m = n2/gcd(n1,n2)\n        n1 = (n1 // math.gcd(n1, n2)) * n2 \n\n    return a1 % n1, n1\n\ndef _prime_factorize(n):\n    \"\"\"Returns a dictionary of prime factors {p: k}.\"\"\"\n    factors = {}\n    d = 2\n    temp_n = n\n    while d * d <= temp_n:\n        while temp_n % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            temp_n //= d\n        d += 1\n    if temp_n > 1:\n        factors[temp_n] = factors.get(temp_n, 0) + 1\n    return factors\n\ndef _get_generator(p, k):\n    \"\"\"Finds a generator for (Z/p^kZ)^* for odd prime p.\"\"\"\n    if p == 2: return -1 # Not cyclic for k>=3\n    phi = p - 1\n    phi_factors = list(_prime_factorize(phi).keys())\n    \n    g = 1\n    for i in range(2, p):\n        is_gen = True\n        for factor in phi_factors:\n            if pow(i, phi // factor, p) == 1:\n                is_gen = False\n                break\n        if is_gen:\n            g = i\n            break\n            \n    if k == 1:\n        return g\n    \n    # Lift generator from p to p^k\n    if pow(g, p - 1, p * p) == 1:\n        return g + p\n    return g\n\ndef _get_index(val, g, m, order):\n    \"\"\"Computes discrete logarithm (index) of val base g via brute-force search.\"\"\"\n    current = 1\n    for i in range(order):\n        if current == val:\n            return i\n        current = (current * g) % m\n    return -1\n\ndef _solve_mod_pk(a, b, p, k):\n    \"\"\"Solves a^x = b (mod p^k).\"\"\"\n    pk = pow(p, k)\n    \n    if p == 2:\n        if k == 1: return 0, 1\n        if k == 2: # Z_4^* is cyclic with generator 3\n            # a,b are 1 or 3 mod 4. Indices are 0 or 1.\n            ind_a = 0 if a % 4 == 1 else 1\n            ind_b = 0 if b % 4 == 1 else 1\n            return _solve_linear_congruence(ind_a, ind_b, 2)\n        else: # k >= 3, group is C_2 x C_{2^{k-2}}\n            a_mod, b_mod = a % pk, b % pk\n            mod_t = pow(2, k - 2)\n            \n            # Decompose a into (-1)^e_a * 5^t_a\n            e_a = 0 if a_mod % 4 == 1 else 1\n            a_prime = a_mod if e_a == 0 else (pk - a_mod) % pk\n            t_a = _get_index(a_prime, 5, pk, mod_t)\n            \n            # Decompose b into (-1)^e_b * 5^t_b\n            e_b = 0 if b_mod % 4 == 1 else 1\n            b_prime = b_mod if e_b == 0 else (pk - b_mod) % pk\n            t_b = _get_index(b_prime, 5, pk, mod_t)\n            \n            # Solve system: e_a*x=e_b (mod 2), t_a*x=t_b (mod 2^{k-2})\n            sol1 = _solve_linear_congruence(e_a, e_b, 2)\n            if sol1[0] == -1: return -1, -1\n            sol2 = _solve_linear_congruence(t_a, t_b, mod_t)\n            if sol2[0] == -1: return -1, -1\n            \n            return _solve_crt([sol1, sol2])\n    else: # p is odd\n        phi_pk = (p - 1) * pow(p, k - 1)\n        g = _get_generator(p, k)\n        \n        ind_a = _get_index(a % pk, g, pk, phi_pk)\n        ind_b = _get_index(b % pk, g, pk, phi_pk)\n        \n        if ind_a == -1 or ind_b == -1:\n            # val is not in the group, inconsistent with gcd(val,m)=1\n            # Or subgroup issue, handled by solve_linear_congruence.\n            return -1, -1\n            \n        return _solve_linear_congruence(ind_a, ind_b, phi_pk)\n\ndef solve_dlog(a, b, m):\n    \"\"\"Main function to solve a^x = b (mod m).\"\"\"\n    if m == 1:\n        return 0\n    \n    factors = _prime_factorize(m)\n    congruences = []\n    \n    for p, k in factors.items():\n        res = _solve_mod_pk(a, b, p, k)\n        if res[0] == -1:\n            return -1\n        congruences.append(res)\n    \n    final_sol, final_mod = _solve_crt(congruences)\n    \n    if final_sol == -1:\n        return -1\n    \n    return final_sol\n\ndef solve():\n    \"\"\"Main execution function to solve the given test suite.\"\"\"\n    test_cases = [\n        (3, 23, 77),\n        (2, 20, 27),\n        (5, 21, 32),\n        (3, 9, 40),\n        (2, 3, 7),\n        (3, 5, 16),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, b, m = case\n        result = solve_dlog(a, b, m)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3086068"}]}