{"hands_on_practices": [{"introduction": "Before applying any formula, it is crucial to understand its origin. This first exercise guides you through a foundational derivation of the divisor counting function, $\\tau(n)$, directly from the Fundamental Theorem of Arithmetic. By connecting the unique prime factorization of an integer to a simple combinatorial counting principle, you will see precisely why the number of divisors is the product of one more than the exponents of its prime factors [@problem_id:3090797].", "problem": "Let $n$ be a positive integer, and let $\\tau(n)$ denote the number of positive divisors of $n$. Using only the Fundamental Theorem of Arithmetic (FTA), which asserts that every positive integer $n \\geq 2$ can be written uniquely as a product of prime powers, explain from first principles why counting the positive divisors of $n$ reduces to counting allowable exponent choices in its prime power representation. Then apply this reasoning to determine $\\tau(360)$, given the prime factorization $360 = 2^{3} \\cdot 3^{2} \\cdot 5$. Express your final answer as a single integer.", "solution": "The problem asks for an explanation of the formula for the divisor counting function $\\tau(n)$ based on the Fundamental Theorem of Arithmetic (FTA), and then to apply this to calculate $\\tau(360)$.\n\nLet $n$ be a positive integer. The function $\\tau(n)$ denotes the number of positive divisors of $n$. The Fundamental Theorem of Arithmetic states that any integer $n \\geq 2$ can be uniquely represented as a product of prime powers. Let this unique prime factorization of $n$ be:\n$$n = p_1^{a_1} p_2^{a_2} \\cdots p_k^{a_k}$$\nwhere $p_1, p_2, \\ldots, p_k$ are distinct prime numbers and $a_1, a_2, \\ldots, a_k$ are positive integers. The case for $n=1$ is trivial; its only positive divisor is $1$, so $\\tau(1)=1$.\n\nNow, let $d$ be any positive divisor of $n$. By definition, this means that the ratio $n/d$ is an integer. Let us consider the prime factorization of $d$. A key consequence of the uniqueness part of the FTA is that any prime factor of $d$ must also be a prime factor of $n$. If $d$ had a prime factor $q$ that is not among $\\{p_1, p_2, \\ldots, p_k\\}$, then because $n = d \\cdot (n/d)$, $q$ would also be a prime factor of $n$. This would contradict the assumption that $p_1, \\ldots, p_k$ are the only prime factors of $n$. Therefore, the prime factors of $d$ must be a subset of the prime factors of $n$.\n\nThis means that any divisor $d$ of $n$ must be of the form:\n$$d = p_1^{b_1} p_2^{b_2} \\cdots p_k^{b_k}$$\nwhere the exponents $b_1, b_2, \\ldots, b_k$ are non-negative integers.\n\nFor $d$ to be a divisor of $n$, the quotient $n/d$ must be an integer. Let's write out this quotient using the prime factorizations:\n$$\\frac{n}{d} = \\frac{p_1^{a_1} p_2^{a_2} \\cdots p_k^{a_k}}{p_1^{b_1} p_2^{b_2} \\cdots p_k^{b_k}} = p_1^{a_1-b_1} p_2^{a_2-b_2} \\cdots p_k^{a_k-b_k}$$\nFor this expression to be an integer, all of the exponents in its prime factorization must be non-negative. This imposes a condition on each exponent $b_i$:\n$$a_i - b_i \\geq 0 \\quad \\text{for all } i \\in \\{1, 2, \\ldots, k\\}$$\nThis is equivalent to $b_i \\leq a_i$. Since we already established that the exponents $b_i$ must be non-negative, we have the complete set of constraints for the exponents of any divisor $d$:\n$$0 \\leq b_i \\leq a_i \\quad \\text{for all } i \\in \\{1, 2, \\ldots, k\\}$$\nThe uniqueness of prime factorization guarantees that each distinct choice of the sequence of exponents $(b_1, b_2, \\ldots, b_k)$ corresponds to a unique divisor $d$. Therefore, counting the number of positive divisors of $n$ is equivalent to counting the number of valid sequences of exponents $(b_1, b_2, \\ldots, b_k)$ that satisfy these constraints.\n\nFor each exponent $b_i$, the possible integer values are $0, 1, 2, \\ldots, a_i$. The number of possible values for $b_i$ is $(a_i - 0) + 1 = a_i + 1$.\nSince the choice for each exponent $b_i$ is independent of the choices for the other exponents, the total number of possible sequences of exponents is found by applying the multiplication principle of combinatorics. The total number of divisors is the product of the number of choices for each exponent:\n$$\\tau(n) = (a_1+1)(a_2+1)\\cdots(a_k+1)$$\nThis derivation explains from first principles, using only the FTA, why counting the divisors of $n$ reduces to counting the allowable exponent choices in its prime factorization.\n\nNow, we apply this reasoning to determine $\\tau(360)$. The problem provides the prime factorization of $360$:\n$$360 = 2^3 \\cdot 3^2 \\cdot 5^1$$\nThis corresponds to the general form $n = p_1^{a_1} p_2^{a_2} p_3^{a_3}$ with:\n- $p_1 = 2$ and $a_1 = 3$\n- $p_2 = 3$ and $a_2 = 2$\n- $p_3 = 5$ and $a_3 = 1$\n\nAny divisor $d$ of $360$ must be of the form $d = 2^{b_1} 3^{b_2} 5^{b_3}$. The constraints on the exponents are:\n- For $b_1$: $0 \\leq b_1 \\leq 3$. The possible values are $0, 1, 2, 3$. The number of choices is $3+1 = 4$.\n- For $b_2$: $0 \\leq b_2 \\leq 2$. The possible values are $0, 1, 2$. The number of choices is $2+1 = 3$.\n- For $b_3$: $0 \\leq b_3 \\leq 1$. The possible values are $0, 1$. The number of choices is $1+1 = 2$.\n\nUsing the derived formula, the total number of divisors is the product of the number of choices for each exponent:\n$$\\tau(360) = (a_1+1)(a_2+1)(a_3+1) = (3+1)(2+1)(1+1)$$\n$$\\tau(360) = 4 \\cdot 3 \\cdot 2$$\n$$\\tau(360) = 24$$\nThus, the number of positive divisors of $360$ is $24$.", "answer": "$$\\boxed{24}$$", "id": "3090797"}, {"introduction": "This practice challenges you to think like a number theorist by working in reverse. Instead of computing $\\tau(n)$ for a given integer $n$, you are tasked with finding the integers that produce a specific number of divisors. This inverse problem [@problem_id:3090807] transforms the $\\tau(n)$ formula into a Diophantine equation, requiring you to explore the factorizations of the target divisor count to reconstruct the exponents of the original number's prime factors.", "problem": "Let $n$ be a positive integer of the form $n=2^{a}3^{b}5^{c}$ with $a,b,c$ nonnegative integers. Define $\\tau(n)$ to be the number of positive divisors of $n$. Using only the Fundamental Theorem of Arithmetic (FTA) and the definition of a divisor, derive a formula for $\\tau(n)$ in terms of $a$, $b$, and $c$. Then determine how many distinct integers $n$ of the form $2^{a}3^{b}5^{c}$ satisfy $\\tau(n)=24$. Your final answer must be a single integer.", "solution": "The problem consists of two parts. First, we must derive a formula for the number of divisors function, $\\tau(n)$, for an integer $n$ of the form $n=2^{a}3^{b}5^{c}$. Second, we must use this formula to find the number of such integers $n$ for which $\\tau(n)=24$.\n\nLet $n$ be a positive integer with the specified prime factorization $n=2^{a}3^{b}5^{c}$, where $a, b, c$ are non-negative integers. The function $\\tau(n)$ represents the count of the positive divisors of $n$.\n\nBy the Fundamental Theorem of Arithmetic, every integer greater than $1$ has a unique prime factorization. Let $d$ be a positive divisor of $n$. The set of prime factors of $d$ must be a subset of the set of prime factors of $n$. Therefore, any divisor $d$ of $n$ must be of the form $d=2^{x}3^{y}5^{z}$ for some non-negative integers $x, y, z$.\n\nFor $d$ to be a divisor of $n$, the ratio $\\frac{n}{d}$ must be an integer. We have:\n$$\n\\frac{n}{d} = \\frac{2^{a}3^{b}5^{c}}{2^{x}3^{y}5^{z}} = 2^{a-x}3^{b-y}5^{c-z}\n$$\nFor this expression to be an integer, all of its exponents must be non-negative. This imposes the following constraints on the exponents $x, y, z$:\n$$\na-x \\ge 0 \\implies 0 \\le x \\le a\n$$\n$$\nb-y \\ge 0 \\implies 0 \\le y \\le b\n$$\n$$\nc-z \\ge 0 \\implies 0 \\le z \\le c\n$$\nThe number of possible integer values for the exponent $x$ is $(a-0)+1 = a+1$.\nThe number of possible integer values for the exponent $y$ is $(b-0)+1 = b+1$.\nThe number of possible integer values for the exponent $z$ is $(c-0)+1 = c+1$.\nSince each unique ordered triple of exponents $(x,y,z)$ corresponds to a unique divisor $d$ of $n$, the total number of divisors $\\tau(n)$ can be found by applying the multiplication principle of combinatorics. The total number of divisors is the product of the number of choices for each exponent:\n$$\n\\tau(n) = (a+1)(b+1)(c+1)\n$$\nThis is the desired formula for $\\tau(n)$ in terms of $a, b,$ and $c$.\n\nNow, for the second part of the problem, we need to find the number of distinct integers $n$ of the form $n=2^{a}3^{b}5^{c}$ that satisfy the condition $\\tau(n)=24$. Using the derived formula, we obtain the equation:\n$$\n(a+1)(b+1)(c+1) = 24\n$$\nSince $a, b, c$ are non-negative integers, the factors $(a+1), (b+1),$ and $(c+1)$ must be positive integers. Let us define new integer variables $A = a+1$, $B = b+1$, and $C = c+1$. With this substitution, we have $A \\ge 1$, $B \\ge 1$, $C \\ge 1$, and the equation becomes:\n$$\nA \\cdot B \\cdot C = 24\n$$\nWe need to determine the number of ordered triples of positive integers $(A, B, C)$ that satisfy this equation. Each such triple corresponds to a unique triple of exponents $(a,b,c)=(A-1, B-1, C-1)$. By the uniqueness of prime factorization, each distinct triple $(a,b,c)$ defines a unique integer $n=2^{a}3^{b}5^{c}$. Therefore, the number of distinct integers $n$ is equal to the number of ordered factorizations of $24$ into three positive integers.\n\nTo find this number, we can use a combinatorial method based on the prime factorization of $24$. First, we find the prime factorization of $24$:\n$$\n24 = 8 \\times 3 = 2^3 \\cdot 3^1\n$$\nLet the prime factorizations of $A, B,$ and $C$ be $A=2^{x_1}3^{y_1}$, $B=2^{x_2}3^{y_2}$, and $C=2^{x_3}3^{y_3}$, where $x_i, y_i$ are non-negative integers for $i \\in \\{1, 2, 3\\}$. The product is:\n$$\nA \\cdot B \\cdot C = (2^{x_1}3^{y_1}) (2^{x_2}3^{y_2}) (2^{x_3}3^{y_3}) = 2^{x_1+x_2+x_3} 3^{y_1+y_2+y_3}\n$$\nEquating this with $2^3 \\cdot 3^1$, by uniqueness of prime factorizations, we get a system of two independent linear Diophantine equations:\n$$\nx_1 + x_2 + x_3 = 3\n$$\n$$\ny_1 + y_2 + y_3 = 1\n$$\nThe number of non-negative integer solutions to an equation of the form $z_1 + z_2 + \\dots + z_k = m$ is given by the stars and bars formula, $\\binom{m+k-1}{k-1}$.\n\nFor the equation $x_1+x_2+x_3=3$, we have $m=3$ and $k=3$. The number of solutions is:\n$$\n\\binom{3+3-1}{3-1} = \\binom{5}{2} = \\frac{5 \\cdot 4}{2} = 10\n$$\nFor the equation $y_1+y_2+y_3=1$, we have $m=1$ and $k=3$. The number of solutions is:\n$$\n\\binom{1+3-1}{3-1} = \\binom{3}{2} = \\frac{3 \\cdot 2}{2} = 3\n$$\nSince the distribution of the powers of $2$ and the powers of $3$ among the factors $A, B, C$ are independent events, the total number of ordered triples $(A, B, C)$ is the product of the number of solutions for each equation.\nTotal number of solutions = (number of solutions for $x_i$) $\\times$ (number of solutions for $y_i$) $= 10 \\times 3 = 30$.\n\nThere are $30$ such ordered triples $(A, B, C)$. Each one corresponds to a unique set of exponents $(a,b,c)$ and thus to a unique integer $n$. Hence, there are $30$ distinct integers of the form $n=2^{a}3^{b}5^{c}$ satisfying $\\tau(n)=24$.", "answer": "$$\\boxed{30}$$", "id": "3090807"}, {"introduction": "While computing $\\tau(n)$ for a single integer is straightforward with its prime factorization, calculating it for a large range of integers one-by-one is highly inefficient. This practice introduces a powerful algorithmic paradigm shift: the sieve method. You will learn to compute $\\tau(n)$ for all integers up to a bound $N$ not by factoring each number, but by iterating through divisors and marking all their multiples, demonstrating an elegant approach that achieves a time complexity of $O(N\\log N)$ [@problem_id:3090793].", "problem": "You are given a positive integer bound $N \\in \\mathbb{N}$ and the divisor counting function $\\tau:\\mathbb{N}\\to\\mathbb{N}$ defined by $\\tau(n)=\\#\\{d\\in\\mathbb{N}: d \\mid n\\}$, where for $d,n\\in\\mathbb{N}$ the relation $d \\mid n$ means there exists $k\\in\\mathbb{N}$ with $n=dk$. Your task is to derive, justify, and implement a sieve that computes all values $\\tau(n)$ for $1 \\le n \\le N$ in $O(N\\log N)$ time using only the fundamental definition of divisibility and the fact that each divisor contributes exactly one count to $\\tau(n)$.\n\nConstraints and tasks:\n- Starting only from the definitions of divisor and the function $\\tau(n)$, explain why the following sieve-by-divisors procedure correctly computes $\\tau(n)$ for all $1 \\le n \\le N$: initialize an array $T[1..N]$ with zeros; for each $d$ from $1$ to $N$, iterate over the multiples $m$ of $d$ with $m \\le N$ and increment $T[m]$ by $1$. After the process stops, $T[n]$ equals $\\tau(n)$ for each $1 \\le n \\le N$.\n- Derive the time complexity of this procedure by expressing the total number of increments as $\\sum_{d=1}^{N} \\left\\lfloor \\frac{N}{d} \\right\\rfloor$ and bounding this sum asymptotically using the $N$-th harmonic number $H_N=\\sum_{d=1}^{N}\\frac{1}{d}$. Conclude that the running time is $O(N\\log N)$ and the memory usage is $O(N)$.\n- Implement a program that constructs $\\tau(n)$ for all $1 \\le n \\le N$ using this sieve and returns requested values for a set of test cases. You must not compute $\\tau(n)$ by factorizing $n$ individually or by per-$n$ trial division; the implementation must follow the divisor-additions sieve described above.\n\nTest suite:\n- Case $1$: $N=1$, queries $Q=[1]$.\n- Case $2$: $N=10$, queries $Q=[1,2,3,4,5,6,7,8,9,10]$.\n- Case $3$: $N=36$, queries $Q=[16,18,20,25,36]$.\n- Case $4$: $N=100000$, queries $Q=[1,9973,65521,100000]$.\n\nEach case requires you to build $\\tau(n)$ for all $1 \\le n \\le N$ and then report the list $[\\tau(q): q \\in Q]$ in the given order.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a bracketed, comma-separated list of integers. Do not include spaces. For the four cases above, the output must have the form\n$[[\\tau(1)], [\\tau(1),\\tau(2),\\dots,\\tau(10)], [\\tau(16),\\tau(18),\\tau(20),\\tau(25),\\tau(36)], [\\tau(1),\\tau(9973),\\tau(65521),\\tau(100000)]]$.", "solution": "#### Justification of the Sieve Algorithm\nThe goal is to demonstrate that at the termination of the procedure, the value stored in the array at index $n$, denoted $T[n]$, is equal to $\\tau(n)$ for all $1 \\le n \\le N$.\n\nLet us consider an arbitrary integer $n$ such that $1 \\le n \\le N$. The value $T[n]$ is initialized to $0$. According to the algorithm, $T[n]$ is incremented if and only if $n$ is a multiple of some integer $d$ that is being iterated over in the outer loop. The outer loop iterates through all integers $d$ from $1$ to $N$.\n\nFor a fixed $n$, the statement `T[n] += 1` is executed if and only if $n$ is a multiple of the current outer loop variable $d$. By the definition of divisibility, stating that $n$ is a multiple of $d$ is equivalent to stating that $d$ is a divisor of $n$, or $d \\mid n$.\n\nThe outer loop variable $d$ ranges from $1$ to $N$. Therefore, for a given $n$, the value of $T[n]$ is incremented for each integer $d \\in \\{1, 2, \\dots, N\\}$ that is a divisor of $n$.\n\nAny divisor $d$ of $n$ must satisfy the inequality $d \\le n$. Since we are considering $n \\le N$, any divisor of $n$ must also satisfy $d \\le N$. Thus, the set of all divisors of $n$ is a subset of $\\{1, 2, \\dots, N\\}$. The algorithm's outer loop, by iterating $d$ from $1$ to $N$, considers all possible divisors for any $n \\le N$.\n\nThe final value of $T[n]$ is the total count of increments it received. This count is precisely the number of integers $d \\in \\{1, 2, \\dots, N\\}$ that divide $n$. As established, this is the complete set of divisors of $n$.\nTherefore, the final value of $T[n]$ is the total number of divisors of $n$. By definition, this is $\\tau(n)$.\n\nFormally, we can write the final value of $T[n]$ as:\n$$ T[n] = \\sum_{d=1}^{N} \\mathbb{I}(d \\mid n) $$\nwhere $\\mathbb{I}(P)$ is the indicator function, which is $1$ if the proposition $P$ is true, and $0$ otherwise. Since $d \\mid n$ implies $d \\le n$, and our domain is $n \\le N$, the condition $d \\mid n$ implies $d \\le N$. Thus, the sum can be written without loss of information as:\n$$ T[n] = \\sum_{d=1}^{n} \\mathbb{I}(d \\mid n) = \\sum_{d \\mid n} 1 = \\#\\{d \\in \\mathbb{N} : d \\mid n\\} = \\tau(n) $$\nThis confirms that the algorithm correctly computes $\\tau(n)$ for all $n \\in \\{1, 2, \\dots, N\\}$.\n\n#### Time Complexity Analysis\nThe time complexity of the algorithm is determined by the total number of times the innermost statement, the increment operation, is executed. The initialization of the array $T$ takes $O(N)$ time.\n\nThe nested loops form the core of the computation. The outer loop runs for $d = 1, 2, \\dots, N$. For each value of $d$, the inner loop iterates over its multiples $m = kd$ for $k=1, 2, 3, \\dots$ as long as $m \\le N$. The number of such multiples for a given $d$ is the largest integer $k$ such that $kd \\le N$, which is precisely $k = \\left\\lfloor \\frac{N}{d} \\right\\rfloor$.\n\nThe total number of increment operations is the sum of the counts for each $d$:\n$$ \\text{Total Increments} = \\sum_{d=1}^{N} \\left\\lfloor \\frac{N}{d} \\right\\rfloor $$\nTo determine the asymptotic behavior of this sum, we use the property that for any real number $x$, $x-1 < \\lfloor x \\rfloor \\le x$. Applying the upper bound:\n$$ \\sum_{d=1}^{N} \\left\\lfloor \\frac{N}{d} \\right\\rfloor \\le \\sum_{d=1}^{N} \\frac{N}{d} = N \\sum_{d=1}^{N} \\frac{1}{d} $$\nThe sum $\\sum_{d=1}^{N} \\frac{1}{d}$ is the $N$-th harmonic number, denoted $H_N$. It is a standard result in analysis that $H_N$ can be approximated by the natural logarithm:\n$$ H_N = \\ln(N) + \\gamma + O\\left(\\frac{1}{N}\\right) $$\nwhere $\\gamma \\approx 0.577$ is the Euler-Mascheroni constant. Asymptotically, $H_N$ grows as $O(\\log N)$.\n\nTherefore, the total number of increments is bounded above by $N \\cdot H_N$, which is asymptotically $O(N \\log N)$.\nA tighter analysis using the lower bound $\\frac{N}{d} - 1$ still yields the same asymptotic complexity:\n$$ \\sum_{d=1}^{N} \\left( \\frac{N}{d} - 1 \\right) = N \\sum_{d=1}^{N} \\frac{1}{d} - \\sum_{d=1}^{N} 1 = N H_N - N $$\nSince $N H_N - N$ is also $O(N \\log N)$, the total number of operations is $\\Theta(N \\log N)$.\nThe total time complexity is the sum of the initialization time and the loop execution time, $O(N) + O(N \\log N)$, which is dominated by the second term. Thus, the time complexity is $O(N \\log N)$.\n\n#### Space Complexity Analysis\nThe algorithm's primary memory requirement is the array $T$ used to store the divisor counts. This array must hold a value for each integer from $1$ to $N$. The size of this array is $N$ (or $N+1$ for $1$-based indexing in a $0$-indexed language). Therefore, the space complexity of the algorithm is $O(N)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by first pre-computing all τ(n) values up to the\n    maximum N required by the test cases using the specified sieve method,\n    and then retrieving the queried values for each case.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, list_of_queries)\n    test_cases = [\n        (1, [1]),\n        (10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),\n        (36, [16, 18, 20, 25, 36]),\n        (100000, [1, 9973, 65521, 100000]),\n    ]\n\n    # Find the maximum N across all test cases to build the sieve just once.\n    # This is an efficient approach for handling multiple test cases in a single run.\n    if not test_cases:\n        max_n = 0\n    else:\n        max_n = max(case[0] for case in test_cases)\n\n    # The array will store tau(n) for n from 1 to max_n.\n    # We use a numpy array of size max_n + 1 for 1-based indexing (tau_values[n]).\n    # The problem defines τ for positive integers, so tau_values[0] is unused.\n    tau_values = np.zeros(max_n + 1, dtype=int)\n\n    # Justification for the sieve:\n    # The outer loop iterates through all possible divisors 'd'.\n    # The inner loop iterates through all numbers 'm' for which 'd' is a divisor.\n    # For each such occurrence, we increment the count for τ(m).\n    # After all d's are processed, tau_values[m] will contain the total count of its divisors.\n    # The time complexity is sum_{d=1 to N} floor(N/d) ~= N*H_N = O(N log N).\n    # The space complexity is O(N) for the tau_values array.\n    \n    # Sieve implementation\n    # The outer loop iterates d from 1 to max_n.\n    for d in range(1, max_n + 1):\n        # The inner loop iterates over multiples m of d up to max_n.\n        # This is equivalent to `for m in range(d, max_n + 1, d):`\n        # and correctly increments the divisor count for each multiple.\n        tau_values[d::d] += 1\n\n    all_results = []\n    for case in test_cases:\n        # N_case is the bound for this specific case, queries is the list of requested values.\n        N_case, queries = case\n        \n        # Retrieve the pre-computed tau values for the given queries.\n        # This assumes all q in queries are <= N_case, which is true for the given test suite.\n        case_results = [tau_values[q] for q in queries]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified:\n    # [[...],[...],...] without any spaces.\n    # 1. Convert each inner list of integers to a comma-separated string: \",\".join(map(str, res))\n    # 2. Enclose each of these strings in brackets: \"[\" + ... + \"]\"\n    # 3. Join the resulting strings for all cases with a comma: \",\".join(...)\n    # 4. Enclose the final string in brackets: \"[\" + ... + \"]\"\n    # Example: [[1,2],[3,4]] -> \"[[1,2],[3,4]]\"\n    output_str = \"[\" + \",\".join(\n        \"[\" + \",\".join(map(str, res)) + \"]\" for res in all_results\n    ) + \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3090793"}]}