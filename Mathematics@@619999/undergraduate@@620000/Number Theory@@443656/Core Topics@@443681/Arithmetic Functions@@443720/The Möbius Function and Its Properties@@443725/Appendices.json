{"hands_on_practices": [{"introduction": "The first step in mastering a new number-theoretic function is to become fluent in calculating its values. This practice focuses on applying the fundamental definition of the Möbius function, $\\mu(n)$, which is determined entirely by the prime factorization of an integer $n$. By working through these examples, you will solidify your understanding of how to identify square-free integers and apply the sign rule based on the number of distinct prime factors, a crucial skill for all further study. [@problem_id:3092142]", "problem": "Let $\\mu(n)$ denote the Möbius function, and let $n$ range over positive integers. Using only the prime factorizations of the given integers and fundamental properties that follow directly from the definition of $\\mu(n)$, determine the exact values of $\\mu(n)$ for $n \\in \\{330,756,385,2002\\}$. Justify each step of your evaluation by identifying whether $n$ is divisible by the square of a prime and, if not, by determining the number of distinct prime factors. Present your final answers in the order $\\mu(330), \\mu(756), \\mu(385), \\mu(2002)$ as a single row vector. No rounding is required.", "solution": "The Möbius function, denoted $\\mu(n)$, is defined for any positive integer $n$. Its definition is based on the prime factorization of $n$:\n1. $\\mu(1) = 1$.\n2. $\\mu(n) = 0$ if $n$ has a squared prime factor (i.e., $n$ is not square-free). This means there exists a prime $p$ such that $p^2$ divides $n$.\n3. $\\mu(n) = (-1)^k$ if $n$ is a product of $k$ distinct prime numbers (i.e., $n$ is square-free and has $k$ prime factors).\n\nWe will evaluate $\\mu(n)$ for each of the given integers $n \\in \\{330, 756, 385, 2002\\}$ by first determining their prime factorizations.\n\nEvaluation for $n = 330$:\nFirst, we find the prime factorization of $330$.\n$330 = 10 \\times 33 = (2 \\times 5) \\times (3 \\times 11)$.\nThe prime factorization is $330 = 2^1 \\times 3^1 \\times 5^1 \\times 11^1$.\nWe check if $330$ is divisible by the square of any prime. Since all exponents in the prime factorization are $1$, the number $330$ is square-free.\nNext, we determine the number of distinct prime factors, which we denote as $k$. The distinct prime factors are $2$, $3$, $5$, and $11$. Thus, $k=4$.\nAccording to the definition, $\\mu(330) = (-1)^k = (-1)^4 = 1$.\n\nEvaluation for $n = 756$:\nWe find the prime factorization of $756$.\n$756 = 2 \\times 378 = 2 \\times (2 \\times 189) = 2^2 \\times 189$.\n$189 = 3 \\times 63 = 3 \\times (3 \\times 21) = 3^2 \\times (3 \\times 7) = 3^3 \\times 7$.\nCombining these, the prime factorization is $756 = 2^2 \\times 3^3 \\times 7^1$.\nWe check if $756$ is divisible by the square of any prime. The factorization contains $2^2$ and $3^3 = 3^2 \\times 3$. Therefore, $756$ is divisible by $2^2=4$ and also by $3^2=9$. Since it is not square-free, we apply the second case of the definition.\nAccording to the definition, $\\mu(756) = 0$.\n\nEvaluation for $n = 385$:\nWe find the prime factorization of $385$. The number ends in $5$, so it is divisible by $5$.\n$385 = 5 \\times 77$.\nFactoring $77$, we get $77 = 7 \\times 11$.\nThe prime factorization is $385 = 5^1 \\times 7^1 \\times 11^1$.\nWe check if $385$ is divisible by the square of any prime. All exponents in the factorization are $1$, so $385$ is square-free.\nNext, we determine the number of distinct prime factors, $k$. The distinct prime factors are $5$, $7$, and $11$. Thus, $k=3$.\nAccording to the definition, $\\mu(385) = (-1)^k = (-1)^3 = -1$.\n\nEvaluation for $n = 2002$:\nWe find the prime factorization of $2002$.\n$2002 = 2 \\times 1001$.\nTo factor $1001$, we test small prime divisors. It is not divisible by $3$ (sum of digits is $2$). It is not divisible by $5$. For $7$, we have $1001 = 7 \\times 143$.\nTo factor $143$, we test primes. It is not divisible by $7$. For $11$, we have $143 = 11 \\times 13$.\nThe prime factorization is $2002 = 2^1 \\times 7^1 \\times 11^1 \\times 13^1$.\nWe check if $2002$ is divisible by the square of any prime. All exponents in the factorization are $1$, so $2002$ is square-free.\nNext, we determine the number of distinct prime factors, $k$. The distinct prime factors are $2$, $7$, $11$, and $13$. Thus, $k=4$.\nAccording to the definition, $\\mu(2002) = (-1)^k = (-1)^4 = 1$.\n\nThe values are $\\mu(330)=1$, $\\mu(756)=0$, $\\mu(385)=-1$, and $\\mu(2002)=1$. We present these in the required order as a single row vector.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 & 0 & -1 & 1\n\\end{pmatrix}\n}\n$$", "id": "3092142"}, {"introduction": "Beyond its point-wise definition, the true power of the Möbius function emerges from its relationships with other arithmetic functions via Dirichlet convolution. This exercise guides you to evaluate the convolution of the Möbius function with the natural logarithm, an expression written as $\\sum_{d|n} \\mu(d)\\ln(n/d)$. Solving this problem reveals a deep connection to the von Mangoldt function, $\\Lambda(n)$, and demonstrates how Möbius inversion can be used to isolate the core prime-power structure of an integer from a sum over its divisors. [@problem_id:3092134]", "problem": "Let $\\mu(n)$ denote the Möbius function, defined by $\\mu(1)=1$, $\\mu(n)=0$ if $n$ is divisible by the square of a prime, and $\\mu(n)=(-1)^{k}$ if $n$ is a product of $k$ distinct primes. For a fixed positive integer $n$ and an arithmetic function $f$, consider the divisor sum $S(n;f)=\\sum_{d\\mid n}\\mu(d)\\,f(n/d)$. Using only the foundational definitions of $\\mu(n)$, Dirichlet convolution, the Fundamental Theorem of Arithmetic (unique factorization), and basic properties of the natural logarithm, evaluate the exact value of\n$$\nS(81;\\ln)=\\sum_{d\\mid 81}\\mu(d)\\,\\ln\\!\\left(\\frac{81}{d}\\right),\n$$\nand interpret the result in terms of the prime power structure of $81$. Express your final answer exactly (no rounding). Use the natural logarithm throughout.", "solution": "The problem asks for the evaluation of the sum\n$$\nS(81; \\ln) = \\sum_{d\\mid 81}\\mu(d)\\,\\ln\\!\\left(\\frac{81}{d}\\right)\n$$\nwhere $\\mu(n)$ is the Möbius function. We are asked to evaluate this sum using fundamental principles and interpret the result.\n\nWe shall approach this problem in two ways: first, by direct computation based on the provided definitions, and second, by employing the more general framework of Dirichlet convolution to reveal the underlying structure and provide the requested interpretation.\n\n**Method 1: Direct Computation**\n\nFirst, we identify the components of the sum for the specific case $n=81$.\n\nThe number $n=81$ has the unique prime factorization $81 = 3^4$, according to the Fundamental Theorem of Arithmetic. The positive divisors $d$ of $81$ are the integers of the form $3^k$ for $k \\in \\{0, 1, 2, 3, 4\\}$. Thus, the set of divisors is $\\{1, 3, 9, 27, 81\\}$.\n\nNext, we evaluate the Möbius function $\\mu(d)$ for each of these divisors:\n\\begin{itemize}\n    \\item For $d=1$: By definition, $\\mu(1) = 1$.\n    \\item For $d=3$: Since $3$ is a product of $k=1$ distinct primes, $\\mu(3) = (-1)^1 = -1$.\n    \\item For $d=9=3^2$: Since $9$ is divisible by the square of the prime $3$, $\\mu(9)=0$.\n    \\item For $d=27=3^3$: Since $27$ is divisible by the square of the prime $3$ (as $27 = 3 \\cdot 3^2$), $\\mu(27)=0$.\n    \\item For $d=81=3^4$: Since $81$ is divisible by the square of the prime $3$, $\\mu(81)=0$.\n\\end{itemize}\nThe summation involves terms of the form $\\mu(d) \\ln(81/d)$. The terms for $d=9$, $d=27$, and $d=81$ are zero because $\\mu(d)=0$ for these divisors. We only need to consider the terms for $d=1$ and $d=3$.\n\nThe sum is:\n$$\nS(81; \\ln) = \\mu(1)\\ln\\left(\\frac{81}{1}\\right) + \\mu(3)\\ln\\left(\\frac{81}{3}\\right) + \\mu(9)\\ln\\left(\\frac{81}{9}\\right) + \\mu(27)\\ln\\left(\\frac{81}{27}\\right) + \\mu(81)\\ln\\left(\\frac{81}{81}\\right)\n$$\nSubstituting the values of $\\mu(d)$:\n$$\nS(81; \\ln) = (1) \\cdot \\ln(81) + (-1) \\cdot \\ln(27) + (0) \\cdot \\ln(9) + (0) \\cdot \\ln(3) + (0) \\cdot \\ln(1)\n$$\n$$\nS(81; \\ln) = \\ln(81) - \\ln(27)\n$$\nUsing the property of the natural logarithm that $\\ln(a) - \\ln(b) = \\ln(a/b)$, we have:\n$$\nS(81; \\ln) = \\ln\\left(\\frac{81}{27}\\right) = \\ln(3)\n$$\nAlternatively, using the property $\\ln(x^y) = y \\ln(x)$:\n$$\nS(81; \\ln) = \\ln(3^4) - \\ln(3^3) = 4\\ln(3) - 3\\ln(3) = (4-3)\\ln(3) = \\ln(3)\n$$\nThe direct computation yields the exact value $\\ln(3)$.\n\n**Method 2: Dirichlet Convolution and Interpretation**\n\nTo interpret this result in a broader context, we consider the structure of the summation. The given sum $S(n; f) = \\sum_{d \\mid n} \\mu(d) f(n/d)$ is the Dirichlet convolution of the Möbius function $\\mu$ and the arithmetic function $f$. We denote this by $(\\mu \\ast f)(n)$. The problem asks for the evaluation of $(\\mu \\ast \\ln)(81)$.\n\nThis expression is an instance of the Möbius inversion formula. Let us introduce the von Mangoldt function, $\\Lambda(n)$, defined as:\n$$\n\\Lambda(n) =\n\\begin{cases}\n\\ln(p) & \\text{if } n=p^k \\text{ for some prime } p \\text{ and integer } k \\ge 1 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nA fundamental identity in number theory relates the natural logarithm to the von Mangoldt function via a sum over divisors:\n$$\n\\sum_{d \\mid n} \\Lambda(d) = \\ln(n)\n$$\nIn the language of Dirichlet convolution, this identity is written as $(\\Lambda \\ast 1)(n) = \\ln(n)$, where $1(n)$ is the constant function $1(n)=1$ for all $n \\in \\mathbb{Z}^+$.\n\nThe sum we need to evaluate is $(\\mu \\ast \\ln)(n)$. Substituting the identity for $\\ln(n)$:\n$$\n(\\mu \\ast \\ln)(n) = (\\mu \\ast (\\Lambda \\ast 1))(n)\n$$\nDirichlet convolution is associative, so we can regroup the terms:\n$$\n(\\mu \\ast (\\Lambda \\ast 1))(n) = ((\\mu \\ast 1) \\ast \\Lambda)(n)\n$$\nA defining property of the Möbius function is that it is the Dirichlet inverse of the constant function $1(n)$. That is, their convolution yields the identity element $\\epsilon$ for Dirichlet convolution:\n$$\n(\\mu \\ast 1)(n) = \\epsilon(n) =\n\\begin{cases}\n1 & \\text{if } n=1 \\\\\n0 & \\text{if } n>1\n\\end{cases}\n$$\nSubstituting this back into our expression:\n$$\n((\\mu \\ast 1) \\ast \\Lambda)(n) = (\\epsilon \\ast \\Lambda)(n)\n$$\nThe convolution of any arithmetic function $f$ with the identity element $\\epsilon$ returns the function $f$ itself: $(\\epsilon \\ast f)(n) = f(n)$. Therefore:\n$$\n(\\epsilon \\ast \\Lambda)(n) = \\Lambda(n)\n$$\nWe have thus demonstrated the general identity:\n$$\nS(n; \\ln) = \\sum_{d\\mid n}\\mu(d)\\,\\ln\\!\\left(\\frac{n}{d}\\right) = \\Lambda(n)\n$$\nThe problem is reduced to evaluating the von Mangoldt function for $n=81$.\nSince $81=3^4$, it is a power of the prime $p=3$ with exponent $k=4 \\ge 1$. According to the definition of $\\Lambda(n)$, we have:\n$$\n\\Lambda(81) = \\ln(3)\n$$\nThis confirms the result from the direct computation.\n\n**Interpretation**\n\nThe identity $\\sum_{d\\mid n}\\mu(d)\\,\\ln(n/d) = \\Lambda(n)$ provides the required interpretation. The given summation is a formula for the von Mangoldt function. The von Mangoldt function $\\Lambda(n)$ is specifically designed to detect prime powers. It is non-zero only when its argument $n$ is a power of a single prime number, $p^k$. In such cases, its value is $\\ln(p)$, which isolates the logarithm of the prime base $p$.\n\nFor the specific case $n=81$, the number is a pure prime power, $3^4$. The summation, which is equivalent to $\\Lambda(81)$, correctly evaluates to $\\ln(3)$. This result precisely isolates and reveals the unique prime base of $81$. If $n$ were a number with multiple distinct prime factors (e.g., $n=12=2^2 \\cdot 3^1$), the sum would evaluate to $\\Lambda(12)=0$. Thus, the operation performs a fundamental analysis of the prime power structure of an integer, and the result $\\ln(3)$ signifies that $81$ is a power of the prime $3$.", "answer": "$$\n\\boxed{\\ln(3)}\n$$", "id": "3092134"}, {"introduction": "While calculating individual values of $\\mu(n)$ is instructive, number theory is often concerned with the collective or aggregate behavior of arithmetic functions over large ranges. This problem transitions from theoretical calculation to computational exploration by asking you to implement an efficient algorithm to compute the Mertens function, $M(x) = \\sum_{n \\le x} \\mu(n)$. By programming a sieve and analyzing the resulting data, you will gain a hands-on appreciation for the remarkable cancellations in the sum of $\\mu(n)$, a phenomenon deeply connected to the distribution of prime numbers and the celebrated Riemann Hypothesis. [@problem_id:3092145]", "problem": "You are asked to implement a program that computes the cumulative behavior of the Möbius function over initial segments of the positive integers and to quantify the resulting cancellations numerically. Work entirely from definitions and standard number-theoretic constructions.\n\nDefinitions to use as the sole conceptual base:\n- The Möbius function $\\,\\mu(n)\\,$ is defined for each positive integer $\\,n\\,$ by:\n  - $\\,\\mu(1)=1$,\n  - $\\,\\mu(n)=0\\,$ if there exists a prime $\\,p\\,$ such that $\\,p^2 \\mid n$,\n  - $\\,\\mu(n)=(-1)^k\\,$ if $\\,n\\,$ is a product of $\\,k\\,$ distinct primes.\n- The Mertens function $\\,M(x)\\,$ is the summatory function $\\,M(x)=\\sum_{n\\le x}\\mu(n)$ for positive integer $\\,x$.\n- Let $\\,Q(x)=\\sum_{n\\le x}|\\mu(n)|\\,$, which counts the squarefree integers up to $\\,x\\,$.\n\nYour tasks:\n- Starting from the above definitions, design and implement an algorithm that determines $\\,\\mu(n)\\,$ for all $\\,1\\le n\\le N\\,$ efficiently for a given $\\,N\\,$ by leveraging a sieve-style construction grounded in the definition of squarefreeness and the effect of multiplying by a new prime on the sign of $\\,\\mu(n)\\,$.\n- Using the computed values, form the cumulative arrays for $\\,M(x)\\,$ and $\\,Q(x)\\,$ for all $\\,1\\le x\\le N\\,$.\n- For each specified test value $\\,x\\,$, output the quintuple\n  $$[\\,x,\\;M(x),\\;Q(x),\\;M(x)/x,\\;Q(x)/x\\,],$$\n  where the two ratios are real numbers rounded to $\\,6\\,$ decimal places.\n\nTest suite:\n- Use the set of inputs $\\,\\{\\,1,\\,10,\\,100,\\,1000,\\,10000,\\,100000\\,\\}\\,$.\n\nDesign for coverage:\n- $\\,x=1\\,$ tests the boundary case.\n- $\\,x=10\\,$ and $\\,x=100\\,$ test small-scale behavior.\n- $\\,x=1000\\,$ and $\\,x=10000\\,$ test moderate ranges.\n- $\\,x=100000\\,$ tests a larger, but still tractable, range for performance and cumulative behavior.\n\nFinal output format:\n- Your program must produce a single line containing a list of lists, one inner list per test value in the order given, with each inner list equal to $[\\,x,M(x),Q(x),M(x)/x,Q(x)/x\\,]$ where the two ratios are rounded to $\\,6\\,$ decimal places. The entire output must be a single line in the form\n  $$[\\,[x_1,M(x_1),Q(x_1),M(x_1)/x_1,Q(x_1)/x_1],\\,[x_2,M(x_2),Q(x_2),M(x_2)/x_2,Q(x_2)/x_2],\\,\\dots\\,].$$\n\nYour implementation must be self-contained, must not read input, and must not write anything other than the single required line of output. No physical units or angles are involved. All reported ratios are pure real numbers and must be rounded to $\\,6\\,$ decimal places.", "solution": "The core of the problem is to compute the values of the Möbius function $\\,\\mu(n)\\,$ for all integers $\\,n\\,$ from $\\,1\\,$ up to a given maximum $\\,N$. A naive approach of factoring each integer $\\,n\\,$ to determine $\\,\\mu(n)\\,$ would be computationally expensive, with a complexity worse than $\\,O(N\\sqrt{N})$. A more efficient method, as suggested by the problem, is a sieve-style algorithm. We will develop a linear sieve, which computes $\\,\\mu(n)\\,$ for all $\\,n \\le N\\,$ in $\\,O(N)\\,$ time.\n\nLet $\\,N\\,$ be the maximum value required by the test suite, which is $\\,N=100000$.\n\n### Algorithm Design\n\n**1. Sieve for the Möbius Function $\\,\\mu(n)\\,$**\n\nWe will adapt a linear sieve algorithm, commonly used for finding prime numbers, to compute $\\,\\mu(n)\\,$ for $\\,n \\in [1, N]$. This algorithm ensures that each composite number is processed exactly once.\n\nThe algorithm requires three primary data structures:\n- An array `mu` of size $\\,N+1\\,$ to store the values of $\\,\\mu(n)$.\n- An array `lp` of size $\\,N+1\\,$ to store the least prime factor of each number $\\,n$.\n- A list `primes` to store the prime numbers found in increasing order.\n\nThe sieve proceeds as follows:\n- **Initialization**:\n  - Set $\\,\\mu[1] = 1$.\n  - Initialize the `lp` array with zeros.\n- **Iteration**: Iterate through integers $\\,i\\,$ from $\\,2\\,$ to $\\,N$.\n  - **Prime Case**: If $\\,lp[i]\\,$ is still $\\,0$, it means $\\,i\\,$ has no prime factors smaller than itself, so $\\,i\\,$ must be a prime number.\n    - We set its least prime factor $\\,lp[i] = i$.\n    - By definition, $\\,\\mu(i) = (-1)^1 = -1\\,$ for a prime $\\,i$.\n    - Add $\\,i\\,$ to our list of `primes`.\n  - **Composite Case**: For each prime $\\,p\\,$ in our list `primes`:\n    - Let $\\,j = i \\cdot p$. If $\\,j > N$, we can stop processing multiples for the current $\\,i\\,$ as they will exceed our bound.\n    - We mark the composite number $\\,j\\,$ by setting its least prime factor: $\\,lp[j] = p$.\n    - Now we determine $\\,\\mu(j)\\,$ based on $\\,\\mu(i)\\,$ and $\\,p$:\n      - **Case 1: $\\,p\\,$ divides $\\,i\\,$**. This occurs if and only if $\\,p\\,$ is the least prime factor of $\\,i$, i.e., $\\,p = lp[i]$. In this situation, the prime factorization of $\\,i\\,$ already contains at least one factor of $\\,p$. Multiplying by $\\,p\\,$ introduces a square factor ($\\,p^2\\,$) into $\\,j$. By definition, if an integer is divisible by a square of a prime, its Möbius function value is $\\,0$. Therefore, $\\,\\mu[j] = 0$. After handling this case, we break the inner loop over primes. This break is the key to the sieve's linear time complexity, as it ensures that any composite number $\\,j\\,$ is \"striked\" only by its least prime factor.\n      - **Case 2: $\\,p\\,$ does not divide $\\,i\\,$**. This occurs if $\\,p < lp[i]$. Here, $\\,p\\,$ is a new prime factor for $\\,j\\,$ that was not in the factorization of $\\,i$. The number of distinct prime factors of $\\,j\\,$ is one greater than that of $\\,i$. Therefore, the sign of the Möbius function is flipped: $\\,\\mu[j] = -\\mu[i]$. We continue to the next prime in the `primes` list.\n\nThis procedure correctly and efficiently populates the `mu` array for all integers up to $\\,N$.\n\n**2. Computation of Cumulative Functions $\\,M(x)\\,$ and $\\,Q(x)\\,$**\n\nOnce the `mu` array is computed, we can find the summatory functions $\\,M(x) = \\sum_{n \\le x} \\mu(n)\\,$ and $\\,Q(x) = \\sum_{n \\le x} |\\mu(n)|\\,$ by pre-calculating their values for all $\\,x \\in [1, N]$. This is done by computing the cumulative sums of the `mu` array and the `abs(mu)` array.\n\n- Let `M_cum` be an array of size $\\,N+1$. We can compute it iteratively:\n  $$ M_{\\text{cum}}[x] = M_{\\text{cum}}[x-1] + \\mu[x] $$\n  with the base case $\\,M_{\\text{cum}}[0] = 0$.\n\n- Similarly, for an array `Q_cum` of size $\\,N+1$:\n  $$ Q_{\\text{cum}}[x] = Q_{\\text{cum}}[x-1] + |\\mu[x]| $$\n  with the base case $\\,Q_{\\text{cum}}[0] = 0$.\n\nWith these cumulative sum arrays, we can retrieve $\\,M(x)\\,$ and $\\,Q(x)\\,$ for any test value $\\,x \\le N\\,$ in constant $\\,O(1)\\,$ time.\n\n**3. Generating the Final Output**\n\nFor each specified test value $\\,x\\,$ from the set $\\,\\{\\,1, 10, 100, 1000, 10000, 100000\\,\\}$:\n1. Retrieve $\\,M(x) = M_{\\text{cum}}[x]\\,$ and $\\,Q(x) = Q_{\\text{cum}}[x]$.\n2. Calculate the ratios $\\,M(x)/x\\,$ and $\\,Q(x)/x$.\n3. Round the two ratios to $\\,6\\,$ decimal places as required.\n4. Construct the quintuple list $\\,[\\,x, M(x), Q(x), M(x)/x, Q(x)/x\\,]$.\n5. Collect all such quintuples into a list and format it into the final output string.\n\nIt is worth noting the theoretical context for the quantities being computed. The function $\\,Q(x)\\,$ counts the number of squarefree integers up to $\\,x$. The density of squarefree integers is known to converge to $\\,1/\\zeta(2) = 6/\\pi^2 \\approx 0.607927$. We expect the ratio $\\,Q(x)/x\\,$ to approach this value as $\\,x\\,$ grows. The behavior of the Mertens function $\\,M(x)\\,$ is more mysterious and is deeply connected to the Riemann Hypothesis, which is equivalent to the assertion that $\\,M(x) = O(x^{1/2+\\epsilon})\\,$ for any $\\,\\epsilon > 0$. Our computations will provide a numerical glimpse into the complex cancellations captured by $\\,M(x)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes statistics related to the Möbius and Mertens functions for a given\n    set of test values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 10, 100, 1000, 10000, 100000]\n\n    # Set the upper bound for the sieve from the test cases.\n    N = max(test_cases)\n\n    # Step 1: Compute mu(n) for n up to N using a linear sieve.\n    # lp[i] stores the least prime factor of i.\n    # mu[i] stores the Mobius function value mu(i).\n    lp = np.zeros(N + 1, dtype=int)\n    mu = np.zeros(N + 1, dtype=int)\n    primes = []\n    \n    mu[1] = 1\n\n    for i in range(2, N + 1):\n        if lp[i] == 0:\n            # i is a prime\n            lp[i] = i\n            mu[i] = -1\n            primes.append(i)\n        \n        for p in primes:\n            # Conditions to break the inner loop:\n            # 1. The product exceeds our limit N.\n            # 2. The prime p is greater than the least prime factor of i.\n            #    This is part of the linear sieve optimization, preventing\n            #    re-processing of composites. For our mu calculation, we\n            #    only need to break when p equals lp[i].\n            if p > lp[i] and lp[i] != 0:\n                break\n            if i * p > N:\n                break\n\n            j = i * p\n            lp[j] = p\n            if p == lp[i]:\n                # p is a factor of i, so p^2 is a factor of j.\n                # mu(j) is 0 because j is not squarefree.\n                mu[j] = 0\n                break # Essential for linear time performance\n            else:\n                # p is not a factor of i, so it's a new prime factor for j.\n                # The sign of mu flips.\n                mu[j] = -mu[i]\n\n    # Step 2: Compute cumulative sum arrays for M(x) and Q(x).\n    # M(x) is the sum of mu(n) up to x.\n    # Q(x) is the sum of |mu(n)| up to x (count of squarefree integers).\n    # numpy.cumsum provides an efficient way to do this.\n    M_cum = np.cumsum(mu)\n    Q_cum = np.cumsum(np.abs(mu))\n\n    # Step 3: Generate results for each test case.\n    results = []\n    for x in test_cases:\n        # Retrieve pre-computed cumulative sums.\n        m_x = int(M_cum[x])  # M_cum is int64 by default, cast to Python int\n        q_x = int(Q_cum[x])  # Q_cum is int64 by default, cast to Python int\n        \n        # Calculate ratios and round to 6 decimal places.\n        m_ratio = round(m_x / x, 6)\n        q_ratio = round(q_x / x, 6)\n        \n        # Assemble the quintuple for this test case.\n        result_quintuple = [x, m_x, q_x, m_ratio, q_ratio]\n        results.append(result_quintuple)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    # e.g., [[x1, M1, ...], [x2, M2, ...]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3092145"}]}