{"hands_on_practices": [{"introduction": "Before diving into specific algorithms, it's crucial to understand how fundamental number theory theorems can simplify complex calculations. This practice demonstrates how to compute a large modular exponentiation by first breaking down the modulus using the Chinese Remainder Theorem (CRT), and then applying Euler's totient theorem to reduce the exponent, making an otherwise daunting problem manageable. [@problem_id:3087333]", "problem": "Let $m$ be a positive integer modulus and let $a,b \\in \\mathbb{Z}$. Recall the foundational facts of modular arithmetic: if $a \\equiv b \\pmod{m}$ then for any $c \\in \\mathbb{Z}$ one has $a+c \\equiv b+c \\pmod{m}$ and $ac \\equiv bc \\pmod{m}$, and repeated use of these rules justifies reducing intermediate sums and products modulo $m$ at every step of a computation. Using only these properties and any standard theorems from elementary number theory whose statements you can justify from first principles (for example, Eulerâ€™s theorem and the Chinese remainder theorem), compute the least nonnegative residue of $7^{123}$ modulo $1000$ by systematically reducing intermediate products modulo $1000$ and explaining why each reduction is valid. Your final answer must be a single integer in $\\{0,1,2,\\dots,999\\}$.", "solution": "The problem is to find the least non-negative residue of $7^{123}$ modulo $1000$. Let $x = 7^{123}$. We are asked to compute $x \\pmod{1000}$.\n\nThe modulus is $m = 1000$. We can factor the modulus as $1000 = 10^3 = (2 \\cdot 5)^3 = 2^3 \\cdot 5^3 = 8 \\cdot 125$. The factors $m_1=8$ and $m_2=125$ are relatively prime, i.e., $\\gcd(8, 125)=1$. This structure suggests the use of the Chinese Remainder Theorem (CRT). The CRT provides a method to solve a system of simultaneous congruences. Specifically, if we can find the residues of $7^{123}$ modulo $8$ and modulo $125$, we can combine them to find the unique solution modulo $1000$. The use of CRT is justified because it is a standard theorem of elementary number theory derivable from the basic properties of congruences provided in the problem statement.\n\nWe will solve the congruences $x \\equiv 7^{123} \\pmod{8}$ and $x \\equiv 7^{123} \\pmod{125}$ separately.\n\nFirst, let us compute $7^{123} \\pmod{8}$.\nThe base is $7$. We notice that $7 \\equiv -1 \\pmod{8}$. The problem states that if $a \\equiv b \\pmod{m}$, then $ac \\equiv bc \\pmod{m}$. By repeated application of this property for any positive integer exponent $k$, we can conclude that $a^k \\equiv b^k \\pmod{m}$. Applying this to our case:\n$$7^{123} \\equiv (-1)^{123} \\pmod{8}$$\nSince $123$ is an odd integer, $(-1)^{123} = -1$.\nTherefore,\n$$7^{123} \\equiv -1 \\equiv 7 \\pmod{8}$$\n\nSecond, let us compute $7^{123} \\pmod{125}$.\nThe modulus is $125 = 5^3$. Since $\\gcd(7, 125) = 1$, we can apply Euler's totient theorem. The theorem is justified as it is a direct consequence of Lagrange's theorem applied to the multiplicative group of integers modulo $m$, $(\\mathbb{Z}/m\\mathbb{Z})^\\times$, whose order is given by Euler's totient function, $\\phi(m)$. For any $a$ coprime to $m$, $a^{\\phi(m)} \\equiv 1 \\pmod{m}$.\nFor a prime power $p^k$, the totient function is given by $\\phi(p^k) = p^k - p^{k-1}$. In our case, $m=125=5^3$, so\n$$\\phi(125) = \\phi(5^3) = 5^3 - 5^{3-1} = 125 - 25 = 100$$\nAccording to Euler's theorem, we have $7^{\\phi(125)} \\equiv 7^{100} \\equiv 1 \\pmod{125}$.\nWe can use this result to simplify the exponent $123$.\n$$7^{123} = 7^{100} \\cdot 7^{23}$$\n$$7^{123} \\equiv 1 \\cdot 7^{23} \\equiv 7^{23} \\pmod{125}$$\nThis step is valid because we can reduce factors in a product modulo $m$.\nNow, we must compute $7^{23} \\pmod{125}$. We use the method of exponentiation by squaring, which systematically reduces intermediate products modulo $125$. The validity of reducing at each step is again justified by the property that if $a \\equiv b \\pmod m$ and $c \\equiv d \\pmod m$, then $ac \\equiv bd \\pmod m$.\nLet us compute the required powers of $7$ modulo $125$:\n$$7^1 \\equiv 7 \\pmod{125}$$\n$$7^2 = 49 \\equiv 49 \\pmod{125}$$\n$$7^4 = (7^2)^2 \\equiv 49^2 = 2401 \\pmod{125}$$\nSince $2401 = 19 \\cdot 125 + 26$, we have $7^4 \\equiv 26 \\pmod{125}$.\n$$7^8 = (7^4)^2 \\equiv 26^2 = 676 \\pmod{125}$$\nSince $676 = 5 \\cdot 125 + 51$, we have $7^8 \\equiv 51 \\pmod{125}$.\n$$7^{16} = (7^8)^2 \\equiv 51^2 = 2601 \\pmod{125}$$\nSince $2601 = 20 \\cdot 125 + 101$, we have $7^{16} \\equiv 101 \\pmod{125}$.\nTo compute $7^{23}$, we can decompose the exponent as $23 = 16+4+3$. A more direct path is to note $23=20+3$. Let's compute $7^{20}$:\n$$7^{20} = 7^{16} \\cdot 7^4 \\equiv 101 \\cdot 26 \\pmod{125}$$\nThe product is $101 \\cdot 26 = 2626$. Since $2626 = 21 \\cdot 125 + 1$, we have $7^{20} \\equiv 1 \\pmod{125}$.\nNow we can compute $7^{23}$ as follows:\n$$7^{23} = 7^{20} \\cdot 7^3 \\equiv 1 \\cdot 7^3 \\equiv 7^3 \\pmod{125}$$\nWe compute $7^3$:\n$$7^3 = 7 \\cdot 7^2 = 7 \\cdot 49 = 343$$\nSince $343 = 2 \\cdot 125 + 93$, we have $7^3 \\equiv 93 \\pmod{125}$.\nTherefore, $7^{23} \\equiv 93 \\pmod{125}$. This implies $7^{123} \\equiv 93 \\pmod{125}$.\n\nWe have now established the following system of congruences for $x = 7^{123}$:\n$$\n\\begin{cases}\nx \\equiv 7 \\pmod{8} \\\\\nx \\equiv 93 \\pmod{125}\n\\end{cases}\n$$\nFrom the second congruence, we know that $x$ must be of the form $x = 125k + 93$ for some integer $k$. We substitute this expression into the first congruence:\n$$125k + 93 \\equiv 7 \\pmod{8}$$\nTo solve for $k$, we first reduce the coefficients modulo $8$:\n$125 = 15 \\cdot 8 + 5 \\implies 125 \\equiv 5 \\pmod{8}$.\n$93 = 11 \\cdot 8 + 5 \\implies 93 \\equiv 5 \\pmod{8}$.\nThe congruence becomes:\n$$5k + 5 \\equiv 7 \\pmod{8}$$\nSubtracting $5$ from both sides:\n$$5k \\equiv 2 \\pmod{8}$$\nTo isolate $k$, we need to multiply by the multiplicative inverse of $5$ modulo $8$. By inspection, $5 \\cdot 5 = 25 = 3 \\cdot 8 + 1$, so $5^{-1} \\equiv 5 \\pmod{8}$. Multiplying both sides by $5$:\n$$5 \\cdot (5k) \\equiv 5 \\cdot 2 \\pmod{8}$$\n$$25k \\equiv 10 \\pmod{8}$$\n$$k \\equiv 2 \\pmod{8}$$\nThis means that $k$ can be written in the form $k = 8j + 2$ for some integer $j$. We substitute this back into our expression for $x$:\n$$x = 125(8j + 2) + 93$$\n$$x = 125 \\cdot 8j + 125 \\cdot 2 + 93$$\n$$x = 1000j + 250 + 93$$\n$$x = 1000j + 343$$\nThis implies that $x \\equiv 343 \\pmod{1000}$.\nThe least non-negative residue of $7^{123}$ modulo $1000$ is $343$, which is in the required set $\\{0,1,2,\\dots,999\\}$.", "answer": "$$\\boxed{343}$$", "id": "3087333"}, {"introduction": "The square-and-multiply method is a cornerstone of efficient modular exponentiation, turning the exponent's binary representation into a fixed sequence of squarings and multiplications. This exercise provides a concrete, step-by-step application of the left-to-right variant of this algorithm, helping you internalize the process and see how each bit of the exponent directs the computation. [@problem_id:3087367]", "problem": "In modular arithmetic, repeated exponentiation can be computed efficiently by processing the binary expansion of the exponent and combining modular squaring and modular multiplication. This approach rests on the definition of congruence modulo $n$ and the binary representation of integers, together with the closure of multiplication in the multiplicative group modulo $n$. Using the left-to-right square-and-multiply (LTR) method that scans the binary digits of the exponent from most significant to least significant, compute the residue of $3^{1001}$ modulo $437$. You must explicitly list each squaring and multiply step dictated by the bits of the binary expansion of $1001$, indicating at each step whether a multiply occurs. Express the final residue as an integer in the set $\\{0,1,2,\\dots,436\\}$. No rounding is required.", "solution": "The computation is based on two foundational facts: (i) for integers $a$, $b$, and $n$, if $a \\equiv b \\pmod{n}$ then $a \\cdot c \\equiv b \\cdot c \\pmod{n}$ and $a^{2} \\equiv b^{2} \\pmod{n}$, and (ii) every positive integer admits a unique binary expansion, which allows exponentiation to be decomposed into a sequence of squarings and conditional multiplications.\n\nWe apply the left-to-right square-and-multiply (LTR) method. Write the exponent $e = 1001$ in binary. Compute the binary expansion:\n$$\n1001_{10} = 1111101001_{2},\n$$\nwhose bits from most significant to least significant are $b_{9} = 1$, $b_{8} = 1$, $b_{7} = 1$, $b_{6} = 1$, $b_{5} = 1$, $b_{4} = 0$, $b_{3} = 1$, $b_{2} = 0$, $b_{1} = 0$, $b_{0} = 1$.\n\nThe LTR procedure initializes with the leading bit. Since $b_{9} = 1$, set\n$$\nc \\leftarrow 3 \\bmod 437.\n$$\nFor each subsequent bit $b_{i}$ from $i = 8$ down to $i = 0$, perform a modular squaring $c \\leftarrow c^{2} \\bmod 437$; if $b_{i} = 1$, then also perform a modular multiplication $c \\leftarrow c \\cdot 3 \\bmod 437$.\n\nWe list the steps explicitly:\n\n- Bit $b_{8} = 1$:\n  - Squaring: $c \\leftarrow 3^{2} \\bmod 437 = 9$.\n  - Multiply: $c \\leftarrow 9 \\cdot 3 \\bmod 437 = 27$.\n\n- Bit $b_{7} = 1$:\n  - Squaring: $c \\leftarrow 27^{2} \\bmod 437 = 729 \\bmod 437 = 292$ (since $729 - 437 = 292$).\n  - Multiply: $c \\leftarrow 292 \\cdot 3 \\bmod 437 = 876 \\bmod 437 = 2$ (since $876 - 2 \\cdot 437 = 2$).\n\n- Bit $b_{6} = 1$:\n  - Squaring: $c \\leftarrow 2^{2} \\bmod 437 = 4$.\n  - Multiply: $c \\leftarrow 4 \\cdot 3 \\bmod 437 = 12$.\n\n- Bit $b_{5} = 1$:\n  - Squaring: $c \\leftarrow 12^{2} \\bmod 437 = 144$.\n  - Multiply: $c \\leftarrow 144 \\cdot 3 \\bmod 437 = 432$.\n\n- Bit $b_{4} = 0$:\n  - Squaring: $c \\leftarrow 432^{2} \\bmod 437$. Note $432 \\equiv -5 \\pmod{437}$, so $432^{2} \\equiv (-5)^{2} = 25 \\pmod{437}$. Thus $c \\leftarrow 25$.\n  - No multiply.\n\n- Bit $b_{3} = 1$:\n  - Squaring: $c \\leftarrow 25^{2} \\bmod 437 = 625 \\bmod 437 = 188$ (since $625 - 437 = 188$).\n  - Multiply: $c \\leftarrow 188 \\cdot 3 \\bmod 437 = 564 \\bmod 437 = 127$ (since $564 - 437 = 127$).\n\n- Bit $b_{2} = 0$:\n  - Squaring: $c \\leftarrow 127^{2} \\bmod 437$. Compute $127^{2} = 16129$. Since $437 \\cdot 36 = 15732$, the remainder is $16129 - 15732 = 397$. Thus $c \\leftarrow 397$.\n  - No multiply.\n\n- Bit $b_{1} = 0$:\n  - Squaring: $c \\leftarrow 397^{2} \\bmod 437$. Note $397 \\equiv -40 \\pmod{437}$, so $397^{2} \\equiv (-40)^{2} = 1600 \\pmod{437}$. Since $437 \\cdot 3 = 1311$, the remainder is $1600 - 1311 = 289$. Thus $c \\leftarrow 289$.\n  - No multiply.\n\n- Bit $b_{0} = 1$:\n  - Squaring: $c \\leftarrow 289^{2} \\bmod 437$. Compute $289^{2} = 83521$. Since $437 \\cdot 191 = 83467$, the remainder is $83521 - 83467 = 54$. Thus $c \\leftarrow 54$.\n  - Multiply: $c \\leftarrow 54 \\cdot 3 \\bmod 437 = 162$.\n\nTherefore,\n$$\n3^{1001} \\bmod 437 = 162.\n$$\n\nAs a consistency check using the Chinese Remainder Theorem (CRT), note $437 = 19 \\cdot 23$, with $\\varphi(19) = 18$ and $\\varphi(23) = 22$, and $\\gcd(3,437) = 1$. Then\n$$\n3^{1001} \\equiv 3^{11} \\pmod{19} \\quad \\text{and} \\quad 3^{1001} \\equiv 3^{11} \\pmod{23},\n$$\nsince $1001 \\equiv 11 \\pmod{18}$ and $1001 \\equiv 11 \\pmod{22}$. One finds $3^{11} \\equiv 10 \\pmod{19}$ and $3^{11} \\equiv 1 \\pmod{23}$. Solving\n$$\nx \\equiv 10 \\pmod{19}, \\quad x \\equiv 1 \\pmod{23}\n$$\ngives $x = 162$, which matches the computed residue.\n\nThe LTR computation used $9$ modular squarings (one per non-leading bit) and $6$ modular multiplications (one per bit equal to $1$ among the non-leading bits), illustrating its efficiency tied to the bit-length and Hamming weight of the exponent.", "answer": "$$\\boxed{162}$$", "id": "3087367"}, {"introduction": "In cryptographic applications, not only correctness but also security against side-channel attacks is paramount. The Montgomery ladder is an elegant algorithm that ensures each bit of the exponent is processed using the exact same sequence of operations, thus preventing timing variations that could leak secret information. This advanced practice challenges you to implement this algorithm, highlighting the connection between number theory and secure software design. [@problem_id:3087330]", "problem": "Implement a complete, runnable program that computes the modular exponentiation $a^e \\bmod n$ in algorithmic constant time using the Montgomery ladder. The program must also record, for each processed bit of the exponent, which register was squared and which register received the mixed product. The computation must be performed from the most significant bit (MSB) to the least significant bit (LSB) of $e$.\n\nThe fundamental base for this task is the following set of well-tested facts and definitions from number theory and algorithms:\n- For any integers $a$, $e$, and $n$ with $n \\ge 2$, the value $a^e \\bmod n$ is defined as the residue class of $a^e$ modulo $n$ in the ring of integers modulo $n$.\n- The binary expansion of $e$ determines a sequence of squaring and multiply operations that can be organized to compute $a^e \\bmod n$ efficiently.\n- The Montgomery ladder is an algorithmic technique that processes each bit of $e$ using a fixed pattern of operations to achieve algorithmic constant-time behavior, which is a standard approach to mitigate timing leakage that would otherwise arise from data-dependent control flow. In this context, algorithmic constant-time means that for each bit of $e$, the algorithm performs the same categories and counts of arithmetic operations independent of the bitâ€™s value.\n\nYou must design and implement the Montgomery ladder variant for modular exponentiation that maintains two registers $R_0$ and $R_1$ with the invariant that after processing a prefix of bits, $R_0$ holds a power of $a$ corresponding to that prefix and $R_1$ holds the next power. For each bit of $e$ (from MSB to LSB), the algorithm must perform exactly one squaring and one mixed multiply (both are modular multiplications), in an arrangement that is independent of the bit value when viewed as an operation count. To avoid data-dependent branches, use an arithmetic or bitwise conditional swap that depends on the current bit and does not alter the number or type of arithmetic operations executed per bit.\n\nSequence recording requirement:\n- Use two registers $R_0$ and $R_1$ in every iteration. For each bit processed, append a two-element list $[s, m]$ to a per-bit sequence, where $s \\in \\{0,1\\}$ indicates which register was squared and $m \\in \\{0,1\\}$ indicates which register received the mixed product (the register updated to the product of the two registers). The register indices $0$ and $1$ refer to $R_0$ and $R_1$ as they stand at the beginning of that bitâ€™s iteration.\n- The sequence must be listed in the exact order the bits are processed, from the MSB to the LSB.\n\nTest suite:\nCompute and record results for the following parameter sets. Each test case is a triple $(a,e,n)$, and for each test case your program must output a list containing the integer result $a^e \\bmod n$ and the per-bit operation sequence as defined above.\n\n- Happy path: $(a,e,n) = (19, 2023, 65537)$.\n- Zero exponent boundary: $(a,e,n) = (19, 0, 65537)$.\n- Unit exponent boundary: $(a,e,n) = (19, 1, 65537)$.\n- Large base and all-ones exponent: $(a,e,n) = (123456789, 65535, 65537)$.\n- Power-of-two exponent: $(a,e,n) = (2, 65536, 65537)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test caseâ€™s result formatted as $[v, S]$ where $v$ is the integer $a^e \\bmod n$ and $S$ is the per-bit sequence (a list of $[s,m]$ pairs). For example, the overall shape must be $[[v_1,S_1],[v_2,S_2],\\dots]$ on one line. No additional text or whitespace-sensitive formatting requirements are imposed beyond this single-line constraint.\n\nNo physical units, angle units, or percentage units are required for this problem; all outputs are purely mathematical integers and lists as described.\n\nImplement the program so that it is self-contained and requires no user input, files, or network access. It must adhere to the specified environment in the final answer.", "solution": "The user-provided problem statement has been analyzed and is deemed **valid**. It is scientifically grounded in number theory and algorithm design, well-posed with clear objectives and constraints, and free of contradictions or ambiguities.\n\n### Principle-Based Design of the Montgomery Ladder Algorithm\n\nThe problem requires the implementation of the Montgomery ladder algorithm for modular exponentiation, specifically the variant that processes the exponent's bits from most significant (MSB) to least significant (LSB). The algorithm must exhibit algorithmic constant-time behavior and record the sequence of operations performed.\n\n#### 1. Mathematical Foundation and Invariant\n\nThe objective is to compute $a^e \\pmod{n}$, where $a$, $e$, and $n$ are integers and $n \\ge 2$. The algorithm leverages the binary representation of the exponent $e = (e_k e_{k-1} \\dots e_1 e_0)_2$.\n\nThe core of the Montgomery ladder is the maintenance of an invariant across two registers, which we denote as $R_0$ and $R_1$. After processing a prefix of the exponent's bits, say $P = (e_k e_{k-1} \\dots e_i)_2$, the registers hold the values:\n$$R_0 = a^P \\pmod{n}$$\n$$R_1 = a^{P+1} \\pmod{n}$$\n\n#### 2. Initialization\n\nBefore the loop begins, we consider an empty prefix of bits, which has a numerical value of $P=0$. To satisfy the invariant for this initial state, the registers must be initialized as:\n$$R_0 \\leftarrow a^0 \\pmod{n} = 1$$\n$$R_1 \\leftarrow a^{0+1} \\pmod{n} = a \\pmod{n}$$\n\n#### 3. Iterative Update Step\n\nThe algorithm iterates through the bits of the exponent $e$ from the MSB $e_k$ down to the LSB $e_0$. In each iteration, we consider the current bit $b$ and update the registers from the state corresponding to the prefix $P$ to the state for the new, longer prefix $P' = 2P + b$.\n\nLet the state before processing bit $b$ be $(R_0, R_1) = (a^P, a^{P+1})$, where all values are modulo $n$. The target state is $(a^{2P+b}, a^{2P+b+1})$. We derive the update rules by considering the two possible values of the bit $b$:\n\n- **Case 1: The bit $b=0$**\n  The new prefix is $P' = 2P$. The target state is $(a^{2P}, a^{2P+1})$. This can be computed from the current register values:\n  $$R'_0 = a^{2P} = (a^P)^2 = R_0^2 \\pmod{n}$$\n  $$R'_1 = a^{2P+1} = a^P \\cdot a^{P+1} = R_0 \\cdot R_1 \\pmod{n}$$\n\n- **Case 2: The bit $b=1$**\n  The new prefix is $P' = 2P+1$. The target state is $(a^{2P+1}, a^{2P+2})$. This is computed as:\n  $$R'_0 = a^{2P+1} = a^P \\cdot a^{P+1} = R_0 \\cdot R_1 \\pmod{n}$$\n  $$R'_1 = a^{2P+2} = (a^{P+1})^2 = R_1^2 \\pmod{n}$$\n\n#### 4. Algorithmic Constant-Time Implementation and Sequence Recording\n\nThe \"algorithmic constant-time\" constraint requires that the same number and type of arithmetic operations are performed for each bit, regardless of its value ($0$ or $1$). Observing the update rules, we see that for any bit, exactly two modular multiplications are needed: one squaring and one \"mixed\" multiplication of $R_0$ and $R_1$.\n\nThe specific operation performed depends on the bit $b$:\n- If $b=0$, we square the contents of $R_0$ and the mixed product updates $R_1$.\n- If $b=1$, we square the contents of $R_1$ and the mixed product updates $R_0$.\n\nThis observation directly informs the sequence recording. Let $s \\in \\{0, 1\\}$ be the index of the register being squared, and $m \\in \\{0, 1\\}$ be the index of the register receiving the mixed product. The operations for a given bit $b$ are:\n- The register to be squared is $R_b$. Thus, $s = b$.\n- The register to receive the mixed product is $R_{1-b}$. Thus, $m = 1-b$.\n\nThe per-bit operation sequence to be recorded is therefore $[s, m] = [b, 1-b]$.\n\nTo implement the updates, we must use the register values from the beginning of the iteration. A direct implementation is:\n1.  Let the current bit be $b$.\n2.  Preserve the initial values: $r_{0,\\text{orig}} \\leftarrow R_0$, $r_{1,\\text{orig}} \\leftarrow R_1$.\n3.  If $b=0$:\n    $R_0 \\leftarrow r_{0,\\text{orig}}^2 \\pmod{n}$\n    $R_1 \\leftarrow r_{0,\\text{orig}} \\cdot r_{1,\\text{orig}} \\pmod{n}$\n4.  If $b=1$:\n    $R_0 \\leftarrow r_{0,\\text{orig}} \\cdot r_{1,\\text{orig}} \\pmod{n}$\n    $R_1 \\leftarrow r_{1,\\text{orig}}^2 \\pmod{n}$\n\nThis structure performs one squaring and one mixed product per bit, fulfilling the problem's requirements.\n\n#### 5. Final Result\n\nAfter iterating through all bits of the exponent $e$, the final prefix processed is $e$ itself. According to the invariant, the register $R_0$ will hold the final result, $a^e \\pmod{n}$.\n\nFor the special case $e=0$, the binary representation is empty (or '0' depending on convention). The loop is not entered. The initial value $R_0 = 1$ is returned, which is the correct result for $a^0 \\pmod n$.", "answer": "```python\ndef compute_montgomery_ladder(a, e, n):\n    \"\"\"\n    Computes a^e mod n using the Montgomery ladder algorithm (MSB-to-LSB).\n\n    Args:\n        a (int): The base.\n        e (int): The exponent.\n        n (int): The modulus.\n\n    Returns:\n        tuple: A tuple containing the integer result (a^e mod n) and a list\n               representing the per-bit operation sequence.\n    \"\"\"\n    # The exponentiation a^0 mod n is always 1 for a > 0, n > 0.\n    # The algorithm naturally handles this: the loop over bits is empty,\n    # and the initial R0=1 is returned.\n    if e == 0:\n        return 1, []\n\n    # Get the binary representation of the exponent, excluding the '0b' prefix.\n    binary_exponent = bin(e)[2:]\n\n    # Initialize registers R0 and R1.\n    # The invariant is that after processing a prefix P of the exponent,\n    # R0 = a^P and R1 = a^(P+1).\n    # Initially, for an empty prefix (P=0), R0=a^0=1 and R1=a^1=a.\n    R0 = 1\n    R1 = a % n\n\n    op_sequence = []\n\n    # Iterate through each bit of the exponent from MSB to LSB.\n    for bit_char in binary_exponent:\n        bit = int(bit_char)\n\n        # Record the operation sequence for the current bit.\n        # For a bit 'b', we square register 'b' and the mixed product goes to register '1-b'.\n        # s: index of the register being squared.\n        # m: index of the register receiving the mixed product.\n        s_reg_index = bit\n        m_reg_index = 1 - bit\n        op_sequence.append([s_reg_index, m_reg_index])\n\n        # We must use the register values from the start of the iteration for both calculations.\n        # Storing them in temporary variables prevents data corruption from in-place updates.\n        r0_orig = R0\n        r1_orig = R1\n        \n        # This implementation adheres to the constant-time principle by performing\n        # exactly one squaring and one mixed product per bit, regardless of the bit's value.\n        if bit == 0:\n            # Update Rule for bit 0: R0_new = R0^2, R1_new = R0 * R1\n            square_op = (r0_orig * r0_orig) % n\n            multiply_op = (r0_orig * r1_orig) % n\n            R0 = square_op\n            R1 = multiply_op\n        else:  # bit == 1\n            # Update Rule for bit 1: R0_new = R0 * R1, R1_new = R1^2\n            multiply_op = (r0_orig * r1_orig) % n\n            square_op = (r1_orig * r1_orig) % n\n            R0 = multiply_op\n            R1 = square_op\n            \n    # After the loop, R0 holds the final result a^e mod n.\n    return R0, op_sequence\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, e, n)\n        (19, 2023, 65537),\n        (19, 0, 65537),\n        (19, 1, 65537),\n        (123456789, 65535, 65537),\n        (2, 65536, 65537),\n    ]\n\n    # The prompt's skeleton `print(f\"[{','.join(map(str, results))}]\")` implies\n    # that `results` should be a list of strings.\n    results = []\n    for a, e, n in test_cases:\n        v, S = compute_montgomery_ladder(a, e, n)\n        # Format the sequence S into a string with no whitespace.\n        S_str = str(S).replace(\" \", \"\")\n        # Format the result for this test case as a single string \"[v,S]\".\n        result_str = f\"[{v},{S_str}]\"\n        results.append(result_str)\n\n    # Print the final list of string results, joined by commas and enclosed in brackets.\n    # This precisely matches the structure implied by the prompt's `solve()` skeleton.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solution.\nsolve()\n\n```", "id": "3087330"}]}