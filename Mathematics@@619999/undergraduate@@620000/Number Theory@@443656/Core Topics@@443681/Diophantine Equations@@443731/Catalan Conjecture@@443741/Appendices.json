{"hands_on_practices": [{"introduction": "The Catalan Conjecture is fundamentally about the gaps between perfect powers. Before tackling the equation itself, it's valuable to get a direct feel for how these numbers are distributed. This first practice guides you to write a program that generates the set of perfect powers up to a given limit and then analyzes their properties, such as the minimum gap between them. By completing this exercise, you will gain a computational intuition for the rarity of consecutive perfect powers. [@problem_id:3082991]", "problem": "Let $x$, $y$, $a$, and $b$ be integers with $x \\ge 2$, $y \\ge 2$, $a \\ge 2$, and $b \\ge 2$. A positive integer $n$ is called a perfect power if there exist integers $u \\ge 2$ and $v \\ge 2$ such that $n = u^v$. Catalan's conjecture, proved as MihÄƒilescu's theorem, states that the only solution in positive integers to the exponential Diophantine equation $x^a - y^b = 1$ with $x \\ge 2$, $y \\ge 2$, $a \\ge 2$, and $b \\ge 2$ is $3^2 - 2^3 = 1$, or equivalently, the only pair of consecutive perfect powers is $\\{8,9\\}$.\n\nUsing only foundational definitions and well-tested facts, implement a program that performs small computational searches and case checking over perfect powers bounded above by a given integer $B$. For each test case, you will be given a pair $(B,m)$ where $B$ is the inclusive upper bound for the search and $m$ indicates the mode of the computation. For a given bound $B$, define the set\n$$\nS_B = \\{u^v \\mid u \\in \\mathbb{Z}, v \\in \\mathbb{Z}, u \\ge 2, v \\ge 2, u^v \\le B \\}.\n$$\nYour program must construct $S_B$ and then, depending on the mode $m$, compute one of the following:\n\n- Mode $m = 0$ (existence of non-Catalan consecutive perfect powers): Determine whether there exists a pair of distinct elements $p, q \\in S_B$ such that $|p - q| = 1$ and $\\{p,q\\} \\ne \\{8,9\\}$. Return a boolean value `True` if such a pair exists and `False` otherwise.\n\n- Mode $m = 1$ (minimal gap among perfect powers): Compute the minimal absolute difference $|p - q|$ among distinct elements $p, q \\in S_B$. If $S_B$ has fewer than two elements, return $-1$. Otherwise, return the smallest possible integer value of $|p - q|$ over all distinct pairs.\n\n- Mode $m = 2$ (count of consecutive perfect power pairs): Count the number of ordered pairs $(p,q)$ of distinct elements in $S_B$ with $p  q$ such that $q - p = 1$. Return this count as an integer. Note that this counts each ordered pair once; for example, the pair $\\{8,9\\}$ contributes exactly one to the count when both $8$ and $9$ are in $S_B$.\n\nTo ensure scientific realism and clarity, base your solution on the following fundamental components:\n- The definition of a perfect power as stated above.\n- Basic properties of integers and order: if a finite set of integers is sorted increasingly, then the minimal absolute difference between distinct elements occurs between adjacent elements in the sorted list.\n- The logarithmic bound for exponents: since $2^v \\le B$ for any exponent $v$ present in $S_B$, it follows that $v \\le \\lfloor \\log_2(B) \\rfloor$.\n\nImplement your program to process the following test suite of $(B,m)$ pairs:\n- Test case $1$: $(B,m) = (3,0)$.\n- Test case $2$: $(B,m) = (10,2)$.\n- Test case $3$: $(B,m) = (100,1)$.\n- Test case $4$: $(B,m) = (15,0)$.\n- Test case $5$: $(B,m) = (7,1)$.\n\nYour program should produce a single line of output containing the results for these test cases as a comma-separated list enclosed in square brackets, in the same order as the test suite (for example, $[result_1,result_2,result_3,result_4,result_5]$). All outputs must be of the specified fundamental types: boolean for mode $m=0$, integer for modes $m=1$ and $m=2$. No physical units are involved in this problem, and there are no angles or percentages to report.", "solution": "The problem has been validated and is determined to be a valid, well-posed computational problem in number theory. It is scientifically grounded in the definition of perfect powers and Catalan's conjecture, its components are clearly defined, and it is free of contradictions or ambiguities.\n\nThe core task is to implement an algorithm that, for a given integer bound $B$, constructs the set of perfect powers $S_B$ and then performs one of three computations based on a mode parameter $m$. The set is defined as:\n$$\nS_B = \\{u^v \\mid u \\in \\mathbb{Z}, v \\in \\mathbb{Z}, u \\ge 2, v \\ge 2, u^v \\le B \\}\n$$\nThe solution involves two main stages: first, the efficient generation of the set $S_B$, and second, the implementation of the logic for each specified mode $m \\in \\{0, 1, 2\\}$.\n\n**Stage 1: Generation of the set $S_B$**\n\nTo construct the set $S_B$ for a given bound $B$, we must find all integers of the form $u^v$ that are less than or equal to $B$, subject to the constraints $u \\ge 2$ and $v \\ge 2$. A direct search over all integers up to $B$ to check if they are perfect powers would be inefficient. A more systematic approach is to generate the powers by iterating through possible bases $u$ and exponents $v$.\n\nThe search space for the base $u$ and exponent $v$ can be constrained.\n1.  For the base $u$: Since $v \\ge 2$, the smallest power for any base $u$ is $u^2$. The condition $u^2 \\le B$ must hold, which implies $u \\le \\sqrt{B}$. Therefore, the base $u$ only needs to be checked in the range $2 \\le u \\le \\lfloor \\sqrt{B} \\rfloor$.\n2.  For the exponent $v$: For a given base $u$, we must find all exponents $v \\ge 2$ such that $u^v \\le B$.\n\nThe algorithm proceeds as follows:\n- Initialize an empty set data structure to store the perfect powers. A set is used to automatically handle duplicates, such as $64 = 8^2 = 4^3 = 2^6$.\n- Iterate through each possible base $u$ from $2$ up to $\\lfloor \\sqrt{B} \\rfloor$.\n- For each base $u$, compute its powers $u^v$ starting with $v=2$. We begin with the value $p = u^2$.\n- As long as $p \\le B$, we add $p$ to our set. Then, we update $p$ to the next power, $p \\leftarrow p \\cdot u$, and repeat the check.\n- If at any point $p > B$, all subsequent powers for that base $u$ will also exceed $B$, so we can terminate the inner loop and proceed to the next base, $u+1$.\n- After all valid bases have been processed, the resulting set contains all unique elements of $S_B$. For subsequent processing, it is highly advantageous to convert this set into a sorted list, let us call it $L_B$.\n\n**Stage 2: Mode-Specific Computations**\n\nOnce the sorted list of perfect powers $L_B$ is available, we can perform the required computation for each mode.\n\n- **Mode $m = 0$ (Existence of non-Catalan consecutive perfect powers):**\nThe goal is to determine if there exists a pair of distinct elements $p, q \\in S_B$ such that $|p - q| = 1$ and $\\{p,q\\} \\ne \\{8,9\\}$. Since $L_B$ is sorted, any such pair with a difference of $1$ must be adjacent in the list. The algorithm iterates through $L_B$ and examines each adjacent pair of elements $(L_B[i], L_B[i+1])$. For each pair, it checks if $L_B[i+1] - L_B[i] = 1$. If this condition is met, it further checks if the pair is $\\{8, 9\\}$. If a consecutive pair is found that is not $\\{8, 9\\}$, the function returns `True`. If the entire list is traversed without finding such a pair, the function returns `False`.\n\n- **Mode $m = 1$ (Minimal gap among perfect powers):**\nThe task is to find the minimal absolute difference $|p-q|$ between any two distinct elements $p, q \\in S_B$. The problem correctly notes that for a sorted list of numbers, this minimum difference will always occur between two adjacent elements.\nFirst, we handle the edge case: if $S_B$ contains fewer than two elements (i.e., the length of $L_B$ is less than $2$), no difference can be computed, and we must return $-1$.\nOtherwise, we initialize a variable, `min_gap`, to a large value (or to the difference between the first two elements, $L_B[1] - L_B[0]$). We then iterate through the adjacent pairs in $L_B$, from $(L_B[0], L_B[1])$ to $(L_B[k-2], L_B[k-1])$ where $k$ is the size of the list. In each step, we compute the difference $L_B[i+1] - L_B[i]$ and update `min_gap` if this new difference is smaller. The final value of `min_gap` is the result.\n\n- **Mode $m = 2$ (Count of consecutive perfect power pairs):**\nThis mode requires counting the number of ordered pairs $(p,q)$ of distinct elements in $S_B$ with $p  q$ such that $q - p = 1$. Again, working with the sorted list $L_B$ is optimal. Any such pair must be adjacent in $L_B$. We initialize a counter to $0$. We iterate through the adjacent elements of $L_B$ from the beginning. For each pair $(L_B[i], L_B[i+1])$, we check if $L_B[i+1] - L_B[i] = 1$. If it is, we increment the counter. The final value of the counter is returned. This correctly counts the pair $\\{8,9\\}$ exactly once if both $8$ and $9$ are present in $S_B$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other non-standard libraries are used.\n\ndef calculate_result(B, m):\n    \"\"\"\n    Calculates the result for a given test case (B, m).\n    \n    This function first generates the set S_B of perfect powers up to B,\n    then performs a computation based on the mode m.\n    \"\"\"\n\n    # Stage 1: Generate the set S_B of perfect powers\n    # A perfect power n = u^v with u>=2, v>=2.\n    # The smallest power is 2^2 = 4, so if B  4, the set is empty.\n    if B  4:\n        sorted_powers = []\n    else:\n        perfect_powers = set()\n        # The base u must satisfy u^2 = B, so u = sqrt(B).\n        u_limit = int(np.sqrt(B))\n        for u in range(2, u_limit + 1):\n            # Calculate powers of u starting from u^2.\n            power = u * u\n            while power = B:\n                perfect_powers.add(power)\n                # To prevent potential overflow on large numbers and for efficiency,\n                # check if the next multiplication would exceed B.\n                if B // u  power:\n                    break\n                power *= u\n        \n        sorted_powers = sorted(list(perfect_powers))\n\n    # Stage 2: Mode-specific computations\n    if m == 0:\n        # Mode 0: Check for existence of a non-Catalan consecutive pair.\n        for i in range(len(sorted_powers) - 1):\n            p = sorted_powers[i]\n            q = sorted_powers[i+1]\n            if q - p == 1:\n                # Catalan's pair is {8, 9}. We are looking for others.\n                if not (p == 8 and q == 9):\n                    return True\n        return False\n\n    elif m == 1:\n        # Mode 1: Find the minimal gap between distinct perfect powers.\n        if len(sorted_powers)  2:\n            return -1\n        \n        min_gap = np.inf\n        for i in range(len(sorted_powers) - 1):\n            gap = sorted_powers[i+1] - sorted_powers[i]\n            if gap  min_gap:\n                min_gap = gap\n        return int(min_gap)\n\n    elif m == 2:\n        # Mode 2: Count the number of consecutive perfect power pairs.\n        count = 0\n        for i in range(len(sorted_powers) - 1):\n            p = sorted_powers[i]\n            q = sorted_powers[i+1]\n            if q - p == 1:\n                count += 1\n        return count\n    \n    # Should not be reached with valid mode values.\n    return None\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 0),\n        (10, 2),\n        (100, 1),\n        (15, 0),\n        (7, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        B, m = case\n        result = calculate_result(B, m)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3082991"}, {"introduction": "Having explored the general landscape of perfect powers, the logical next step is to search for solutions to the specific equation at the heart of the conjecture: $x^a - y^b = 1$. This practice challenges you to implement an efficient algorithm to find all pairs of consecutive perfect powers below a certain bound. You will learn to use systematic enumeration and apply logical filters, such as parity arguments, to make your search more effective, providing a hands-on verification of the conjecture within a defined range. [@problem_id:3082993]", "problem": "Consider the set of perfect powers defined by integers of the form $x^a$ where $x \\in \\mathbb{Z}$, $x \\ge 2$, and $a \\in \\mathbb{Z}$, $a \\ge 2$. The classical statement known as Catalan's conjecture (proved as MihÄƒilescu's theorem) asserts the uniqueness of consecutive perfect powers in the integers. In this problem, you will design and implement a systematic enumeration and search strategy to find, for given bounds, all quadruples of integers $(x,a,y,b)$ with $x \\ge 2$, $y \\ge 2$, $a \\ge 2$, $b \\ge 2$ such that\n$$\nx^a - y^b = 1,\n$$\nsubject to the constraints $x^a \\le N$ and $y^b \\le N$ for a given upper bound $N \\in \\mathbb{Z}$, $N \\ge 1$.\n\nYour algorithm must be derived from first principles using the following fundamental bases:\n\n- Definition of a perfect power: an integer $n$ is a perfect power if $n = x^a$ for some integers $x \\ge 2$ and $a \\ge 2$.\n- Monotonicity of exponentiation for integers: for fixed $a \\ge 2$, the function $f(x) = x^a$ is strictly increasing for $x \\ge 2$, and for fixed $x \\ge 2$, the function $g(a) = x^a$ is strictly increasing for $a \\ge 2$.\n- Basic inequalities and bounding: for any fixed exponent $e \\ge 2$, the largest base satisfying $x^e \\le N$ is $x \\le \\lfloor N^{1/e} \\rfloor$.\n- Elementary parity and factorization facts:\n  - If $u$ and $v$ are integers, then $u^2 - v^2 = (u - v)(u + v)$.\n  - Squares modulo $4$ are congruent to $0$ or $1$.\n  - If both exponents $a$ and $b$ are even, then $x^a$ and $y^b$ are both squares, and the difference of two squares equal to $1$ with $x \\ge 2$, $y \\ge 2$ is impossible because $(x - y)(x + y) = 1$ has no solutions with $x + y  1$.\n\nUsing these bases, derive an enumeration and search strategy that:\n\n1. Generates all perfect powers $x^a$ with $x \\ge 2$, $a \\ge 2$ not exceeding a given bound $N$ by looping over feasible exponents and bases determined by the inequality $x \\le \\lfloor N^{1/a} \\rfloor$.\n2. Organizes the generated perfect powers in a data structure that allows efficient detection of consecutive integers, specifically pairs $(v+1, v)$ with both members perfect powers.\n3. For every detected consecutive pair, produces all quadruples $(x,a,y,b)$ such that $x^a = v+1$ and $y^b = v$, while rigorously applying the parity filter that eliminates candidates where both $a$ and $b$ are even.\n4. Deduplicates quadruples and outputs them in a deterministic, sorted order.\n\nDesign considerations:\n\n- Your enumeration must avoid unnecessary work by using the monotonicity and bounding principles to limit loops.\n- Your search should rely on the consecutive pairing idea: if $x^a - y^b = 1$ and both are at most $N$, then there exists a perfect power $v$ and its successor $v+1$ such that $y^b = v$ and $x^a = v+1$.\n- Multiple representations of the same perfect power (for example, $16 = 2^4 = 4^2$) must be preserved, since distinct representations may form distinct quadruples.\n\nInput and output:\n\n- There is no input. Your program should internally execute a fixed test suite.\n- For each $N$ in the test suite, compute the list of all quadruples $(x,a,y,b)$ satisfying the above conditions. Represent each quadruple as a list $[x,a,y,b]$.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each test case's result is a list of quadruples in the format $[x,a,y,b]$.\n\nTest suite:\n\n- Use the following four values of $N$:\n  - $N = 10$ (general \"happy path\" case containing a known pair of consecutive perfect powers),\n  - $N = 8$ (boundary condition where the upper bound includes only the lower member $y^b$ but not $x^a$),\n  - $N = 1$ (edge case with no perfect powers meeting $x \\ge 2$, $a \\ge 2$),\n  - $N = 100000$ (a larger bound to test efficiency and correctness of pruning and enumeration).\n\nAnswer specification:\n\n- For each $N$, the answer must be a list of quadruples $[x,a,y,b]$, possibly empty.\n- The final output must aggregate the results of all test cases into a single line in the exact format:\n$$\n[\\text{Case}_1,\\text{Case}_2,\\text{Case}_3,\\text{Case}_4],\n$$\nwhere each $\\text{Case}_i$ is itself a list of quadruples like $[[x,a,y,b],\\dots]$.\n\nNo physical units, angle units, or percentages are involved in this problem.", "solution": "We begin with the definition of perfect powers: an integer $n$ is a perfect power if $n = x^a$ with integers $x \\ge 2$ and $a \\ge 2$. Our goal is to find all quadruples $(x,a,y,b)$ with $x \\ge 2$, $y \\ge 2$, $a \\ge 2$, $b \\ge 2$ satisfying $x^a - y^b = 1$, subject to bounds $x^a \\le N$ and $y^b \\le N$.\n\nPrinciples guiding enumeration:\n\n1. For a fixed exponent $e \\ge 2$, the function $f(x) = x^e$ is strictly increasing for $x \\ge 2$. Therefore, for a given bound $N$, the feasible bases $x$ are $x \\in \\{2,3,\\dots,\\lfloor N^{1/e} \\rfloor\\}$. This yields a complete enumeration of perfect powers up to $N$ by looping $e$ over the range $e \\in \\{2,3,\\dots,\\lfloor \\log_2 N \\rfloor\\}$ and $x$ up to $\\lfloor N^{1/e} \\rfloor$.\n2. For each enumerated pair $(x,e)$, compute $v = x^e$ and store the representation $(x,e)$ in an association structure keyed by $v$. This structure is a map $M$ from values to lists of representations:\n   $$\n   M[v] = \\{(x,e) : x^e = v,\\ x \\ge 2,\\ e \\ge 2,\\ v \\le N\\}.\n   $$\n   This accommodates multiple representations like $16 = 2^4 = 4^2$.\n3. If $x^a - y^b = 1$ with both terms at most $N$, then $y^b = v$ and $x^a = v+1$ for some integer $v$. Thus, solutions correspond exactly to consecutive pairs $(v, v+1)$ with $v \\in \\operatorname{keys}(M)$ and $v+1 \\in \\operatorname{keys}(M)$. Therefore, scan the sorted keys of $M$, and for each $v$ such that $v+1$ is also a key, form all combinations $(x,a) \\in M[v+1]$ and $(y,b) \\in M[v]$.\n4. Parity-based pruning: If both exponents $a$ and $b$ are even, then $x^a$ and $y^b$ are squares, say $x^a = u^2$ and $y^b = v^2$. The identity\n   $$\n   u^2 - v^2 = (u - v)(u + v)\n   $$\n   shows that if $u^2 - v^2 = 1$ with $u \\ge 2$, $v \\ge 2$, then $(u - v)(u + v) = 1$, which is impossible because $u + v \\ge 4$. Hence, any pair with both exponents even cannot satisfy $x^a - y^b = 1$. Applying this filter removes such pairs a priori, improving efficiency without sacrificing correctness.\n5. Deduplication and ordering: Because multiple representations of the same perfect power are allowed, different combinations may arise. Store quadruples $(x,a,y,b)$ in a set to ensure uniqueness, then produce a deterministically sorted list (for example, lexicographic order).\n\nCorrectness argument:\n\n- Completeness: For each feasible exponent $e$ and base $x$, all perfect powers $x^e \\le N$ are enumerated because the base range is exactly $2 \\le x \\le \\lfloor N^{1/e} \\rfloor$, and exponents range $2 \\le e \\le \\lfloor \\log_2 N \\rfloor$, which suffices since any higher exponent with $x \\ge 2$ would exceed $N$ for $x^e$.\n- Necessity of consecutive scanning: If $x^a - y^b = 1$ with $x^a \\le N$ and $y^b \\le N$, then $y^b = v$ and $x^a = v+1$ for some integer $v$, so both $v$ and $v+1$ must be perfect powers within the enumerated set. Thus, iterating over pairs $(v, v+1)$ in the map keys captures all possibilities.\n- Pruning validity: The parity rule eliminating even-even exponent pairs is derived from factorization and is strictly valid. It discards no valid solutions and therefore preserves completeness.\n\nComplexity analysis:\n\nLet $E = \\lfloor \\log_2 N \\rfloor$. For each $e \\in \\{2,\\dots,E\\}$, the number of bases is $\\lfloor N^{1/e} \\rfloor$. The total count of enumerations is\n$$\n\\sum_{e=2}^{E} \\lfloor N^{1/e} \\rfloor.\n$$\nThis sum is dominated by the $e=2$ term, which is approximately $\\sqrt{N}$, and decreases rapidly with increasing $e$. Hence, the enumeration runs in time roughly $O(\\sqrt{N})$, which is efficient for the given test suite, including $N = 100000$.\n\nTest suite behavior:\n\n- For $N = 10$, enumeration includes $8 = 2^3$ and $9 = 3^2$, yielding the quadruple $[3,2,2,3]$ after parity filtering and adjacency detection.\n- For $N = 8$, $8$ is included but $9$ is excluded, so no consecutive perfect powers exist; the result is the empty list.\n- For $N = 1$, no perfect powers $x^a$ with $x \\ge 2$ and $a \\ge 2$ satisfy $x^a \\le 1$; the result is the empty list.\n- For $N = 100000$, despite the large bound, the only consecutive perfect powers remain $8$ and $9$, producing the same quadruple $[3,2,2,3]$ (multiple representations elsewhere do not create consecutive pairs). The parity filter eliminates even-even exponent combinations if any were to appear in adjacency checks.\n\nOutput format:\n\nThe program will construct and print a single line of the form\n$$\n[\\text{Case}_1,\\text{Case}_2,\\text{Case}_3,\\text{Case}_4],\n$$\nwhere each $\\text{Case}_i$ is a list of quadruples $[x,a,y,b]$ found for the corresponding $N$. For the specified test suite, this will be a list of four lists.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom typing import Dict, List, Tuple\n\ndef enumerate_perfect_powers(N: int) - Dict[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Enumerate all perfect powers x^e = N with x = 2 and e = 2.\n    Returns a dictionary mapping value - list of (base, exponent) representations.\n    \"\"\"\n    value_map: Dict[int, List[Tuple[int, int]]] = {}\n    if N  4:\n        return value_map  # Small N has no perfect powers with base=2 and exponent=2 (2^2=4 is minimal)\n\n    # Max exponent is floor(log2(N)), since 2^e = N = e = log2(N)\n    max_exp = int(math.log2(N))\n    for e in range(2, max_exp + 1):\n        # Compute the maximal base such that base**e = N using floating root, then correct by adjustment\n        # Use float power as initial estimate\n        max_base = int(N ** (1.0 / e))\n        # Adjust upwards if rounding down too much\n        while (max_base + 1) ** e = N:\n            max_base += 1\n        # Adjust downwards if rounding up too much\n        while max_base = 2 and (max_base) ** e  N:\n            max_base -= 1\n\n        for x in range(2, max_base + 1):\n            val = x ** e\n            # Store representation (x, e)\n            value_map.setdefault(val, []).append((x, e))\n    return value_map\n\ndef find_consecutive_power_quads(value_map: Dict[int, List[Tuple[int, int]]]) - List[Tuple[int, int, int, int]]:\n    \"\"\"\n    Given a map of perfect power values to representations, find all quadruples (x,a,y,b)\n    such that x^a - y^b = 1. Apply parity filter: skip cases where both a and b are even.\n    Return a sorted list of unique quadruples.\n    \"\"\"\n    quads_set = set()\n    keys = sorted(value_map.keys())\n    keys_set = set(keys)\n\n    for v in keys:\n        u = v + 1\n        if u in keys_set:\n            reps_u = value_map[u]  # (x, a) such that x^a = u\n            reps_v = value_map[v]  # (y, b) such that y^b = v\n            for (x, a) in reps_u:\n                for (y, b) in reps_v:\n                    # Parity filter: if both exponents are even, difference of squares cannot be 1\n                    if (a % 2 == 0) and (b % 2 == 0):\n                        continue\n                    quads_set.add((x, a, y, b))\n\n    # Sort lexicographically for deterministic output\n    quads = sorted(list(quads_set))\n    return quads\n\ndef solve():\n    # Define the test cases from the problem statement: values of N\n    test_cases = [10, 8, 1, 100000]\n\n    results: List[List[Tuple[int, int, int, int]]] = []\n    for N in test_cases:\n        value_map = enumerate_perfect_powers(N)\n        quads = find_consecutive_power_quads(value_map)\n        results.append(quads)\n\n    # Format output exactly: a single line with a comma-separated list enclosed in square brackets.\n    # Each test case's result is a list of quadruples, each quadruple formatted as [x,a,y,b].\n    def format_quad(quad: Tuple[int, int, int, int]) - str:\n        x, a, y, b = quad\n        return f\"[{x},{a},{y},{b}]\"\n\n    def format_case(case: List[Tuple[int, int, int, int]]) - str:\n        return f\"[{','.join(format_quad(q) for q in case)}]\"\n\n    output = f\"[{','.join(format_case(case) for case in results)}]\"\n    print(output)\n\nsolve()\n```", "id": "3082993"}, {"introduction": "Catalan's conjecture, which addresses the equation $x^a - y^b = 1$, is a special case of a more general question about the possible differences between two perfect powers. This broader inquiry is captured by Pillai's equation, $m^a - n^b = k$. In this final practice, you will generalize the search techniques learned previously to find solutions for various integer differences $k$. This exercise places Catalan's conjecture in a wider mathematical context and demonstrates how core algorithmic strategies can be adapted to solve a larger family of Diophantine problems. [@problem_id:3082995]", "problem": "Let $m$, $n$, $a$, $b$, and $k$ be integers with $m \\ge 2$, $n \\ge 2$, $a \\ge 2$, $b \\ge 2$, and $k \\ge 1$. Pillaiâ€™s equation is the Diophantine relation $m^a - n^b = k$. A perfect power is any integer of the form $x^y$ with integers $x \\ge 2$ and $y \\ge 2$. Catalanâ€™s conjecture, proven as MihÄƒilescuâ€™s theorem, states that the only consecutive perfect powers differing by $1$ are $3^2$ and $2^3$. In this problem, you will explore computational aspects of Pillaiâ€™s equation and its relation to Catalanâ€™s conjecture by enumerating solutions subject to finite bounds and aggregating them per test case.\n\nFundamental definitions and facts permitted for use:\n- Integer exponentiation: for integers $u \\ge 2$ and $v \\ge 2$, the perfect power $u^v$ is computed by repeated multiplication in the ring of integers.\n- Basic properties of inequalities and positivity: $m^a - n^b = k$ with $k \\ge 1$ implies $m^a  n^b$.\n\nYour task is to implement a program that, for each given test case, enumerates all quadruples of integers $[m,a,n,b]$ satisfying $m^a - n^b = k$ with $2 \\le m \\le M$, $2 \\le n \\le N$, $2 \\le a \\le A_{\\max}$, $2 \\le b \\le B_{\\max}$, and $k \\ge 1$. The enumeration must be exhaustive within the provided bounds. Each solution must be represented as the list $[m,a,n,b]$. For each test case, collect all solutions into a list, and then aggregate the lists for all test cases into a single outer list.\n\nTest suite (each test case is a tuple $(k,M,N,A_{\\max},B_{\\max})$):\n- Case $1$: $(1,20,20,10,10)$.\n- Case $2$: $(2,200,200,10,10)$.\n- Case $3$: $(5,50,50,10,10)$.\n- Case $4$: $(7,100,100,10,10)$.\n- Case $5$: $(15,100,100,10,10)$.\n- Case $6$: $(6,100,100,10,10)$.\n- Case $7$: $(32,100,100,10,10)$.\n- Case $8$: $(17,100,100,10,10)$.\n- Case $9$: $(65,100,100,10,10)$.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this outer list corresponds to one test case and is itself a list of $[m,a,n,b]$ solutions, in lexicographic order by $(m,a,n,b)$ for reproducibility. For example, the output should have the form $[[\\dots],[\\dots],\\dots]$ where each inner list contains solutions for the corresponding test case in the order listed above.", "solution": "The problem asks for an exhaustive search for solutions to Pillai's equation, $m^a - n^b = k$, within specified integer bounds for the variables $m, a, n, b$. A naive brute-force approach iterating through all four variables would have a time complexity of roughly $O(M \\cdot A_{\\max} \\cdot N \\cdot B_{\\max})$, which is too slow for the given constraints. A more efficient, principle-based strategy is required.\n\nThe core of the implemented algorithm is to rearrange the equation to $m^a - k = n^b$. This separates the variables $(m, a)$ from $(n, b)$, allowing for a two-stage \"pre-computation and lookup\" approach.\n\n**Stage 1: Pre-computation of Perfect Powers**\n\nFirst, we generate all possible perfect powers $n^b$ that can be formed within the given bounds ($2 \\le n \\le N$, $2 \\le b \\le B_{\\max}$). These values are stored in a hash map (a dictionary in Python) for efficient retrieval.\n- The keys of this map are the integer values of the perfect powers, e.g., $64$.\n- The values are lists of pairs $[n, b]$ that produce this power. For example, for the key $64$, the value would be a list containing $[2, 6]$, $[4, 3]$, and $[8, 2]$, as $2^6 = 4^3 = 8^2 = 64$.\n- To ensure the final output is lexicographically sorted, the list of pairs for each key is sorted by the base $n$.\n\nThis pre-computation step has a time complexity of approximately $O(N \\cdot B_{\\max})$.\n\n**Stage 2: Search and Lookup**\n\nNext, the algorithm iterates through all possible pairs of $(m, a)$ within their bounds ($2 \\le m \\le M$, $2 \\le a \\le A_{\\max}$).\n- For each pair, it calculates a `target` value: `target` $= m^a - k$.\n- It then performs a lookup for this `target` value in the pre-computed hash map. This lookup operation is, on average, an $O(1)$ operation.\n- If the `target` is found as a key in the map, it means we have found one or more solutions. For each $[n, b]$ pair associated with that key, a valid solution quadruple $[m, a, n, b]$ is formed and added to the results list.\n\n**Output Ordering and Complexity**\n\nBy iterating through $m$ from $2$ to $M$ and then through $a$ from $2$ to $A_{\\max}$ in nested loops, we naturally process pairs $(m, a)$ in lexicographical order. Since the $[n, b]$ lists in the hash map are also pre-sorted, the resulting solution quadruples are generated in the required lexicographical order without needing a final, expensive sorting step.\n\nThe overall time complexity of this optimized algorithm is dominated by the pre-computation and search stages, resulting in approximately $O(N \\cdot B_{\\max} + M \\cdot A_{\\max})$, which is highly efficient and well within the limits required to solve the test suite. Python's native support for arbitrary-precision integers is crucial, as intermediate power calculations can easily exceed the capacity of standard $64$-bit integers.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # (k, M, N, A_max, B_max)\n        (1, 20, 20, 10, 10),\n        (2, 200, 200, 10, 10),\n        (5, 50, 50, 10, 10),\n        (7, 100, 100, 10, 10),\n        (15, 100, 100, 10, 10),\n        (6, 100, 100, 10, 10),\n        (32, 100, 100, 10, 10),\n        (17, 100, 100, 10, 10),\n        (65, 100, 100, 10, 10),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        k, M, N, A_max, B_max = case\n        result_for_case = solve_one_case(k, M, N, A_max, B_max)\n        all_results.append(result_for_case)\n\n    # The output format requires a compact string representation of the list of lists.\n    # Python's str() function includes spaces, which we remove.\n    # e.g., str([[1, 2]]) -> '[[1, 2]]' -> '[[1,2]]'\n    final_output_str = str(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\ndef solve_one_case(k, M, N, A_max, B_max):\n    \"\"\"\n    Enumerates solutions for a single test case using a pre-computation approach.\n    \n    The method rearranges m^a - n^b = k to m^a - k = n^b. It pre-computes\n    all possible n^b values and stores them in a hash map for efficient lookup.\n    \n    Args:\n        k (int): The constant difference in Pillai's equation.\n        M (int): The upper bound for the base m.\n        N (int): The upper bound for the base n.\n        A_max (int): The upper bound for the exponent a.\n        B_max (int): The upper bound for the exponent b.\n        \n    Returns:\n        list: A list of all solution quadruples [m, a, n, b], sorted lexicographically.\n    \"\"\"\n    \n    # 1. Pre-computation phase: Store all n^b powers in a dictionary.\n    # The keys are the perfect power values, and the values are lists of [n, b] pairs.\n    nb_powers = {}\n    for n in range(2, N + 1):\n        # Using pow(n, b) is clean and efficient in Python for large integers.\n        for b in range(2, B_max + 1):\n            try:\n                val = pow(n, b)\n            except OverflowError:\n                # If a power exceeds system limits (unlikely in Python's arbitrary precision),\n                # we stop for this base n as further powers will also be too large.\n                break\n            \n            if val not in nb_powers:\n                nb_powers[val] = []\n            nb_powers[val].append([n, b])\n\n    # To ensure lexicographical output, sort the lists of [n, b] pairs by n.\n    # This matters when a single value has multiple representations (e.g., 64 = 8^2 = 4^3 = 2^6).\n    for val in nb_powers:\n        nb_powers[val].sort()\n        \n    # 2. Search and Lookup phase\n    solutions = []\n    for m in range(2, M + 1):\n        for a in range(2, A_max + 1):\n            # Calculate the target value m^a - k\n            try:\n                val_ma = pow(m, a)\n            except OverflowError:\n                break\n            \n            target = val_ma - k\n            \n            # Perform a fast lookup in the pre-computed dictionary.\n            if target in nb_powers:\n                # If the target is a known perfect power, we have found solutions.\n                for n_b_pair in nb_powers[target]:\n                    solutions.append([m, a] + n_b_pair)\n\n    # The solutions are naturally generated in lexicographical order due to:\n    # a) The loops for m and a being in increasing order.\n    # b) The lists in nb_powers being sorted by n.\n    # No final sort of `solutions` is needed.\n    return solutions\n\nsolve()\n```", "id": "3082995"}]}