{"hands_on_practices": [{"introduction": "Before we can compute the aliquot sum for any number, we must first understand its behavior on the fundamental building blocks of integers: prime powers. This foundational exercise guides you through a first-principles derivation of the formula for $s(p^k)$, the aliquot sum of a prime power, using the properties of geometric series. Mastering this derivation [@problem_id:3080650] is crucial, as it forms the basis for the efficient computation of $s(n)$ for any integer $n$ through its prime factorization.", "problem": "In the study of aliquot sequences and aliquot types, the aliquot sum function $s(n)$ assigns to a positive integer $n$ the sum of its proper divisors (all positive divisors strictly less than $n$). Let $\\sigma(n)$ denote the sum of all positive divisors of $n$. By definition, these functions satisfy $s(n)=\\sigma(n)-n$. Starting from these core definitions and elementary properties of divisors of prime powers, consider a general prime $p$ and an integer $k\\geq 1$. Derive a closed-form expression for the aliquot sum $s(p^{k})$ based only on first principles about the divisors of $p^{k}$ and standard facts about finite geometric series. Express your final result as a single analytic expression in $p$ and $k$, simplified in a form that explicitly uses $\\sigma(p^{k})$ via the relation $s(p^{k})=\\sigma(p^{k})-p^{k}$. No rounding is required.", "solution": "The problem requires the derivation of a closed-form expression for the aliquot sum of a prime power, $s(p^k)$, where $p$ is a prime number and $k$ is an integer greater than or equal to $1$. The derivation must be based on first principles and the properties of geometric series.\n\nBy definition, the aliquot sum $s(n)$ of a positive integer $n$ is the sum of its proper divisors, which are all positive divisors of $n$ strictly less than $n$. The sum of all positive divisors of $n$, including $n$ itself, is denoted by the function $\\sigma(n)$. The relationship between these two functions is given as:\n$$s(n) = \\sigma(n) - n$$\nWe are asked to find an expression for $s(p^k)$. To do this, we will first derive a closed-form expression for $\\sigma(p^k)$.\n\nAccording to the fundamental theorem of arithmetic, any integer greater than $1$ has a unique prime factorization. For a number of the form $p^k$, where $p$ is a prime, the structure of its divisors is simple. The positive divisors of $p^k$ are precisely the powers of $p$ from $p^0$ up to $p^k$.\nThe set of divisors of $p^k$ is $\\{p^0, p^1, p^2, \\dots, p^k\\}$.\n\nThe function $\\sigma(p^k)$ is the sum of all these divisors:\n$$\\sigma(p^k) = p^0 + p^1 + p^2 + \\dots + p^k$$\nThis sum is a finite geometric series with a first term $a = p^0 = 1$, a common ratio $r = p$, and a total of $k+1$ terms. The standard formula for the sum of a finite geometric series is $S_N = a \\frac{r^N - 1}{r - 1}$, where $N$ is the number of terms.\nApplying this formula to our sum for $\\sigma(p^k)$, with $a=1$, $r=p$, and $N=k+1$, we obtain:\n$$\\sigma(p^k) = 1 \\cdot \\frac{p^{k+1} - 1}{p - 1} = \\frac{p^{k+1} - 1}{p-1}$$\nThis is the closed-form expression for the sum of all divisors of $p^k$.\n\nNow, we use the given relation $s(n) = \\sigma(n) - n$ for the specific case $n=p^k$:\n$$s(p^k) = \\sigma(p^k) - p^k$$\nSubstituting the derived expression for $\\sigma(p^k)$, we arrive at the closed-form expression for the aliquot sum $s(p^k)$:\n$$s(p^k) = \\frac{p^{k+1} - 1}{p - 1} - p^k$$\nThis expression is a single analytic function of $p$ and $k$, and it is presented in a form that explicitly uses the derived formula for $\\sigma(p^k)$, as requested by the problem statement.\n\nFor completeness and as a consistency check, we can also derive $s(p^k)$ by directly summing the proper divisors of $p^k$. The proper divisors are $\\{p^0, p^1, p^2, \\dots, p^{k-1}\\}$. Their sum is:\n$$s(p^k) = p^0 + p^1 + p^2 + \\dots + p^{k-1}$$\nThis is another finite geometric series, this time with $k$ terms, a first term $a=1$, and a common ratio $r=p$. The sum is:\n$$s(p^k) = 1 \\cdot \\frac{p^k - 1}{p - 1} = \\frac{p^k - 1}{p-1}$$\nLet us verify that our primary result simplifies to this form:\n$$s(p^k) = \\frac{p^{k+1} - 1}{p - 1} - p^k = \\frac{p^{k+1} - 1 - p^k(p-1)}{p-1} = \\frac{p^{k+1} - 1 - (p^{k+1} - p^k)}{p-1} = \\frac{p^{k+1} - 1 - p^{k+1} + p^k}{p-1} = \\frac{p^k - 1}{p-1}$$\nThe two derivations yield the same result, confirming the correctness of our approach. However, the problem specifies that the final result should be expressed in a form that makes the relation to $\\sigma(p^k)$ explicit. Therefore, the unsimplified form is the required final answer.", "answer": "$$\\boxed{\\frac{p^{k+1} - 1}{p - 1} - p^k}$$", "id": "3080650"}, {"introduction": "With the formula for prime powers established, we can now construct a general algorithm to compute the aliquot sum $s(n)$ for any integer. This practice challenges you to translate number-theoretic principles—specifically the multiplicative property of the sum-of-divisors function—into a working computer program [@problem_id:3080697]. You will also classify numbers as deficient ($s(n) \\lt n$), perfect ($s(n) = n$), or abundant ($s(n) \\gt n$), taking a crucial step in analyzing their aliquot characteristics.", "problem": "You are to design and implement an algorithm to compute the aliquot sum function $s(n)$, defined for a positive integer $n$ as the sum of all positive divisors of $n$ that are strictly less than $n$. The algorithm must be based on the prime factorization of $n$ and derived from first principles: start from the definition of divisors, the concept of prime factorization, and the multiplicativity of the sum-of-divisors function. You must not assume any special-case shortcuts or precomputed tables. Your implementation should be general and correct for any positive integer input in the given test suite.\n\nYour program must:\n- Given a positive integer $n$, compute $s(n)$ using its prime factorization and the multiplicative structure of the sum-of-divisors function.\n- For each $n$, also compute its aliquot type code $t(n)$, defined as:\n  - $t(n)=-1$ if $s(n) &lt; n$ (deficient),\n  - $t(n)=0$ if $s(n)=n$ (perfect),\n  - $t(n)=1$ if $s(n) &gt; n$ (abundant).\n- Handle the boundary case $n=1$ according to the definition $s(1)=0$.\n\nThe foundational base you may use includes:\n- The definition of divisors and proper divisors of $n$.\n- The Fundamental Theorem of Arithmetic, which guarantees that every $n\\ge 2$ factors uniquely into a product of prime powers.\n- The multiplicativity of the sum-of-divisors function, deduced from the structure of divisors of coprime integers.\n- The finite geometric series identity for sums of powers of a prime in a single prime-power factor.\n\nYou must also reason about and state the time complexity of your algorithm in terms of the complexity of factoring $n$. In particular, suppose the time to factor $n$ is $T_{\\mathrm{fact}}(n)$. You must express the overall time complexity using $T_{\\mathrm{fact}}(n)$ and other relevant arithmetic parameters of $n$ that arise naturally from the factorization process, with clear justification grounded in the above foundational base. The reasoning belongs in your solution text; the program should only perform the computations.\n\nTest suite:\n- Inputs $n$ to evaluate: $[1,2,28,12,25,220,360,9973]$.\n- For each $n$ in the order given, output the pair $[s(n),t(n)]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of bracketed pairs, enclosed in square brackets, with no extra whitespace. For example, the output must look like $[[a\\_1,b\\_1],[a\\_2,b\\_2],\\dots]$ where each $a\\_i$ and $b\\_i$ are integers corresponding to $s(n)$ and $t(n)$ for the $i$-th test input.\n- The output must be a single line in exactly this format: a top-level list containing the $8$ ordered pairs in the same order as the test suite.\n\nYour program must be deterministic and must not require any input. No physical or angle units are involved; all outputs are pure integers. The final answers for the test suite must be integers and lists of integers as specified, aggregated into a single line as described.", "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It consists of a standard number theory task with all necessary definitions and constraints clearly specified.\n\nThe problem requires the computation of the aliquot sum $s(n)$ for a positive integer $n$. The aliquot sum is defined as the sum of the positive divisors of $n$ that are strictly less than $n$. These divisors are also known as the proper divisors of $n$. The sum of all positive divisors of $n$, including $n$ itself, is denoted by the sum-of-divisors function, $\\sigma(n)$. From these definitions, the aliquot sum is given by the relation $s(n) = \\sigma(n) - n$.\n\nThe problem also requires the classification of $n$ based on its aliquot sum. An integer $n$ is classified as deficient if $s(n) < n$, perfect if $s(n) = n$, and abundant if $s(n) > n$. These classifications correspond to aliquot type codes $t(n) = -1$, $t(n) = 0$, and $t(n) = 1$, respectively.\n\nThe derivation of the algorithm must be based on first principles, specifically using the prime factorization of $n$.\n\nFor the boundary case $n=1$, the only positive divisor is $1$. The set of proper divisors is empty. Therefore, the sum of proper divisors is $s(1) = 0$. Since $s(1) < 1$, the number $1$ is deficient, and its type code is $t(1)=-1$.\n\nFor any integer $n \\ge 2$, the Fundamental Theorem of Arithmetic states that $n$ has a unique prime factorization of the form:\n$$n = p_1^{a_1} p_2^{a_2} \\cdots p_k^{a_k} = \\prod_{i=1}^{k} p_i^{a_i}$$\nwhere $p_1, p_2, \\dots, p_k$ are distinct prime numbers and $a_1, a_2, \\dots, a_k$ are positive integers.\n\nAny divisor $d$ of $n$ must be of the form:\n$$d = p_1^{b_1} p_2^{b_2} \\cdots p_k^{b_k} = \\prod_{i=1}^{k} p_i^{b_i}$$\nwhere for each $i \\in \\{1, 2, \\dots, k\\}$, the exponent $b_i$ is an integer satisfying $0 \\le b_i \\le a_i$.\n\nThe sum-of-divisors function, $\\sigma(n)$, is the sum of all such divisors $d$. This can be expressed as a nested summation over all possible values of the exponents $b_i$:\n$$\\sigma(n) = \\sum_{b_1=0}^{a_1} \\sum_{b_2=0}^{a_2} \\cdots \\sum_{b_k=0}^{a_k} \\left( p_1^{b_1} p_2^{b_2} \\cdots p_k^{b_k} \\right)$$\nDue to the distributive property of multiplication over addition, this multi-dimensional sum can be factored into a product of one-dimensional sums:\n$$\\sigma(n) = \\left( \\sum_{b_1=0}^{a_1} p_1^{b_1} \\right) \\left( \\sum_{b_2=0}^{a_2} p_2^{b_2} \\right) \\cdots \\left( \\sum_{b_k=0}^{a_k} p_k^{b_k} \\right) = \\prod_{i=1}^{k} \\left( \\sum_{b_i=0}^{a_i} p_i^{b_i} \\right)$$\nThis expression reveals the multiplicative nature of the $\\sigma$ function. The term for each prime factor $p_i^{a_i}$ is $\\sigma(p_i^{a_i}) = \\sum_{b_i=0}^{a_i} p_i^{b_i}$. Thus, $\\sigma(n) = \\prod_{i=1}^{k} \\sigma(p_i^{a_i})$.\n\nEach sum $\\sum_{b=0}^{a} p^b = 1 + p + p^2 + \\dots + p^a$ is a finite geometric series. The sum of a geometric series is given by the formula $\\sum_{j=0}^{m} r^j = \\frac{r^{m+1}-1}{r-1}$. Applying this formula with $r=p$ and $m=a$, we get:\n$$\\sigma(p^a) = \\frac{p^{a+1}-1}{p-1}$$\nSubstituting this back into the product for $\\sigma(n)$, we obtain the complete formula based on prime factorization:\n$$\\sigma(n) = \\prod_{i=1}^{k} \\frac{p_i^{a_i+1}-1}{p_i-1}$$\n\nThe algorithm to compute $s(n)$ and $t(n)$ can be summarized as follows:\n1. Handle the boundary case: If $n=1$, return $s(1)=0$ and $t(1)=-1$.\n2. For $n \\ge 2$, find its prime factorization $n = \\prod_{i=1}^{k} p_i^{a_i}$. This yields a set of pairs $(p_i, a_i)$.\n3. Initialize the sum of divisors, $\\sigma_{val}$, to $1$.\n4. For each pair $(p_i, a_i)$ in the factorization, compute the term $\\sigma(p_i^{a_i}) = \\frac{p_i^{a_i+1}-1}{p_i-1}$.\n5. Multiply this term into the running product: $\\sigma_{val} = \\sigma_{val} \\times \\sigma(p_i^{a_i})$.\n6. After iterating through all prime factors, the final value is $\\sigma(n) = \\sigma_{val}$.\n7. Compute the aliquot sum: $s(n) = \\sigma(n) - n$.\n8. Determine the aliquot type code $t(n)$ by comparing $s(n)$ with $n$:\n   - If $s(n) < n$, $t(n) = -1$.\n   - If $s(n) = n$, $t(n) = 0$.\n   - If $s(n) > n$, $t(n) = 1$.\n\nThe time complexity of this algorithm is dominated by the prime factorization step. Let $T_{\\mathrm{fact}}(n)$ be the time required to find the prime factorization of $n$. The steps following factorization involve iterating through the $k$ distinct prime factors of $n$. For each factor $p_i^{a_i}$, we perform a constant number of arithmetic operations (exponentiation, subtraction, division). The number of distinct prime factors $k$ is at most $O(\\log n)$. The magnitude of the intermediate and final numbers is polynomially bounded in $n$. Specifically, the arithmetic operations on these numbers take time that is polynomial in their bit length, which is $O(\\log n)$. Therefore, the total time for the post-factorization computation is $O(\\text{poly}(\\log n))$. Since integer factorization is a computationally hard problem, with the best known algorithms having super-polynomial complexity in $\\log n$, $T_{\\mathrm{fact}}(n)$ is the dominant term. The overall time complexity of the algorithm is thus $O(T_{\\mathrm{fact}}(n))$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aliquot sum and aliquot type for a given list of integers,\n    as per the problem statement.\n    \"\"\"\n\n    def get_prime_factorization(n):\n        \"\"\"\n        Computes the prime factorization of a positive integer n.\n        Returns a dictionary mapping each prime factor to its exponent.\n        Uses trial division, which is efficient for the given test cases.\n        \"\"\"\n        if n < 1:\n            return {}\n        \n        factors = {}\n        # Handle factor 2\n        while n % 2 == 0:\n            factors[2] = factors.get(2, 0) + 1\n            n //= 2\n        \n        # Handle odd factors\n        d = 3\n        while d * d <= n:\n            while n % d == 0:\n                factors[d] = factors.get(d, 0) + 1\n                n //= d\n            d += 2\n            \n        # If n is still greater than 1, it must be a prime factor itself.\n        if n > 1:\n            factors[n] = factors.get(n, 0) + 1\n            \n        return factors\n\n    def compute_s_and_t(n):\n        \"\"\"\n        Computes the aliquot sum s(n) and aliquot type code t(n).\n        \"\"\"\n        if n == 1:\n            s_n = 0\n            t_n = -1  # Deficient\n            return [s_n, t_n]\n\n        factors = get_prime_factorization(n)\n        \n        sigma_n = 1\n        for p, a in factors.items():\n            # Using the geometric series sum formula: (p^(a+1) - 1) / (p - 1)\n            sigma_p_a = (p**(a + 1) - 1) // (p - 1)\n            sigma_n *= sigma_p_a\n            \n        s_n = sigma_n - n\n        \n        if s_n < n:\n            t_n = -1  # Deficient\n        elif s_n == n:\n            t_n = 0   # Perfect\n        else:\n            t_n = 1   # Abundant\n            \n        return [s_n, t_n]\n\n    test_cases = [1, 2, 28, 12, 25, 220, 360, 9973]\n    \n    results = []\n    for n in test_cases:\n        result = compute_s_and_t(n)\n        results.append(result)\n\n    # Format the output string exactly as specified, with no extra whitespace.\n    pair_strings = [f\"[{s},{t}]\" for s, t in results]\n    final_output = f\"[{','.join(pair_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3080697"}, {"introduction": "The true fascination with aliquot sequences lies in their long-term behavior: do they terminate, enter a repeating cycle, or perhaps grow indefinitely? This advanced practice moves from computing a single aliquot sum to tracing the entire sequence it generates [@problem_id:3080656]. By implementing standard computer science techniques for cycle detection, such as a hashing-based approach or Floyd's algorithm, you will gain the tools to computationally explore the ultimate fate of these mysterious sequences.", "problem": "You are to implement a complete, runnable program that computes aliquot sequences for given starting integers until either termination or entry into a cycle is detected. Begin from first principles by using the definition of the sum-of-proper-divisors function and the induced sequence. Derive and implement both a hashing-based detection and Floyd’s cycle-finding algorithm to ensure robustness. The program must compute specified numerical invariants that quantify the behavior of each aliquot sequence.\n\nDefinitions and fundamental base:\n- For any integer $n \\geq 0$, define the set of proper divisors of $n$ as all positive integers $d$ such that $d \\mid n$ and $0 < d < n$. Define the sum of proper divisors function $s(n)$ by $s(n) = \\sum_{d \\mid n, \\; 0 < d < n} d$, with the conventions $s(0) = 0$ and $s(1) = 0$.\n- The aliquot sequence $\\{a_k\\}_{k \\geq 0}$ starting at $a_0 = n$ is defined recursively by $a_{k+1} = s(a_k)$ for all $k \\geq 0$.\n- The sequence is said to terminate if it reaches $0$ at some finite index. The sequence is said to be cyclic if there exist integers $\\mu \\geq 0$ and $\\lambda \\geq 1$ such that $a_{\\mu} = a_{\\mu+\\lambda}$, and thereafter $a_{t+\\lambda} = a_t$ for all $t \\geq \\mu$. The integer $\\mu$ is the preperiod (also called tail length), and $\\lambda$ is the cycle length.\n- For canonical reporting of a cycle, define the cycle representative $c$ to be $0$ in the terminating case and the minimal element (with respect to the usual order on integers) among $\\{a_{\\mu}, a_{\\mu+1}, \\ldots, a_{\\mu+\\lambda-1}\\}$ in the cyclic case.\n\nTask requirements:\n- Implement a function to compute $s(n)$ from its definition, using only fundamental divisor properties (for example, if $d \\mid n$ with $1 < d \\leq \\sqrt{n}$, then both $d$ and $n/d$ are divisors).\n- Implement two independent cycle detection strategies for the sequence generated by $s(n)$:\n  1. A hashing-based method that records visited values and their first indices to detect the first repeat and determine $\\mu$ and $\\lambda$.\n  2. Floyd’s cycle-finding algorithm (also known as the tortoise-and-hare method) adapted to detect termination when $0$ is encountered and otherwise to recover $\\mu$ and $\\lambda$.\n- Define the output invariants for a starting value $n$ as the triple $[\\mu, \\lambda, c]$, where $c = 0$ if and only if the sequence terminates and otherwise $c$ is the minimal element of the eventual cycle.\n\nTest suite:\n- Your program must evaluate the starting values $n \\in \\{1, 6, 10, 13, 220, 12496\\}$ and compute the corresponding triples $[\\mu, \\lambda, c]$ for each.\n- These values cover a boundary case ($n = 1$), a perfect number that is a fixed point ($n = 6$), a general terminating case ($n = 10$), a prime that terminates via $1$ ($n = 13$), an amicable pair leading to a $2$-cycle ($n = 220$), and a sociable cycle of length $5$ ($n = 12496$).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is itself a triple in brackets. For the specified test suite, the output must have the form\n$[[\\mu_1,\\lambda_1,c_1],[\\mu_2,\\lambda_2,c_2],\\ldots,[\\mu_6,\\lambda_6,c_6]]$\nwith no spaces.", "solution": "The problem of computing aliquot sequence invariants is a well-defined computational task within the domain of number theory. It is scientifically grounded, objective, and contains all necessary definitions and constraints to proceed with a formal solution. The provided test cases are standard examples used to illustrate the diverse behaviors of aliquot sequences, including termination, fixed points (cycles of length $1$), amicable pairs (cycles of length $2$), and sociable cycles (cycles of length greater than $2$). The problem is therefore deemed **valid**.\n\nThe solution proceeds in three stages. First, we construct the sum-of-proper-divisors function, $s(n)$, which is the generator of the sequence. Second, we formalize the generation of the aliquot sequence and the definitions of the required numerical invariants: the preperiod length $\\mu$, the cycle length $\\lambda$, and the cycle representative $c$. Finally, we detail the implementation of two distinct algorithms for detecting cycles and termination—a hashing-based method and Floyd’s cycle-finding algorithm—to compute these invariants for any given starting integer $n$.\n\n### 1. The Sum-of-Proper-Divisors Function, $s(n)$\n\nThe core of the problem is the function $s(n)$, defined as the sum of the positive divisors of an integer $n$ excluding $n$ itself. The definition is $s(n) = \\sum_{d|n, 0 < d < n} d$. The conventions $s(0) = 0$ and $s(1) = 0$ are given.\n\nFor $n > 1$, we can compute $s(n)$ efficiently. The integer $1$ is always a proper divisor, so we may initialize a sum with $1$. We then search for other divisors. A key property of divisors is that they come in pairs. If $d$ is a divisor of $n$, then $n/d$ is also a divisor. We can exploit this by iterating a test divisor $d$ from $2$ up to the integer part of the square root of $n$, $\\lfloor\\sqrt{n}\\rfloor$.\n\nThe algorithm is as follows:\n1.  Handle the base cases as per the definition: if $n \\le 1$, return $0$.\n2.  For $n > 1$, initialize a variable `total_sum` to $1$, accounting for the divisor $d=1$.\n3.  Iterate with an integer $d$ from $2$ up to and including $\\lfloor\\sqrt{n}\\rfloor$.\n4.  In each iteration, if $d$ divides $n$ (i.e., $n \\pmod d = 0$), then $d$ is a proper divisor, so we add it to `total_sum`. Its corresponding paired divisor is $q = n/d$.\n5.  If $d$ is not equal to its pair $q$ (which occurs when $n$ is not a perfect square), then $q$ is another distinct divisor. We add $q$ to `total_sum` as well. If $d=q$ (i.e., $n=d^2$), we have already accounted for this single divisor $d$, so no further action is needed for the pair.\n6.  The final value of `total_sum` is $s(n)$.\n\nFor example, to compute $s(220)$: $\\sqrt{220} \\approx 14.8$.\n- Initialize sum = $1$.\n- Divisors up to $14$: $2, 4, 5, 10, 11$.\n- Pairs: $220/2=110$, $220/4=55$, $220/5=44$, $220/10=22$, $220/11=20$.\n- $s(220) = 1 + 2 + 4 + 5 + 10 + 11 + 20 + 22 + 44 + 55 + 110 = 284$.\n\n### 2. Aliquot Sequence Invariants: $[\\mu, \\lambda, c]$\n\nAn aliquot sequence is generated by iterating the $s(n)$ function, starting from an initial integer $a_0 = n$:\n$$ a_{k+1} = s(a_k) \\quad \\text{for } k \\geq 0 $$\nThis sequence, $\\{a_k\\}_{k \\geq 0}$, can either terminate by reaching $0$ or eventually repeat, entering a cycle. We are tasked with quantifying this behavior using three invariants:\n-   **Preperiod length ($\\mu$)**: The number of terms in the sequence before it becomes periodic or terminates. This is the length of the \"tail\".\n-   **Cycle length ($\\lambda$)**: The number of unique terms in the repeating cycle. For a terminating sequence, there is no cycle, so we adopt the convention $\\lambda = 0$.\n-   **Cycle representative ($c$)**: For a cyclic sequence, this is the minimal integer value within the cycle $\\{a_\\mu, a_{\\mu+1}, \\ldots, a_{\\mu+\\lambda-1}\\}$. For a terminating sequence, we set $c = 0$.\n\n### 3. Cycle and Termination Detection Algorithms\n\nWe implement two independent algorithms to find the invariants $[\\mu, \\lambda, c]$.\n\n#### Method 1: Hashing-Based Detection\n\nThis method relies on memory to keep track of every term generated in the sequence. A hash map (or dictionary) is used to store each unique term encountered and the index of its first appearance.\n1.  Initialize an empty sequence list, `seq`, and add the starting value $n$, so `seq = [n]`.\n2.  Initialize a hash map, `visited`, mapping the value $n$ to its index $0$: `visited = {n: 0}`.\n3.  Begin a loop to generate subsequent terms:\n    a.  Let `current_val` be the last term in `seq`. Compute `next_val = s(current_val)`.\n    b.  **Termination Check**: If `next_val` is $0$, the sequence terminates. The preperiod length is the count of all terms before $0$, so $\\mu = \\text{len(seq)}$. By convention, we set $\\lambda = 0$ and $c = 0$. The process for this starting value is complete.\n    c.  **Cycle Check**: If `next_val` is already a key in the `visited` map, a cycle has been detected. The first time we saw this value was at index $\\mu = \\text{visited[next_val]}$. The current number of terms generated is $\\text{len(seq)}$. The cycle length is therefore $\\lambda = \\text{len(seq)} - \\mu$. The elements of the cycle are given by the sub-sequence `seq[μ:]`. The cycle representative is $c = \\min(\\text{seq[μ:]})$. The process is complete.\n    d.  **Continuation**: If `next_val` is not $0$ and has not been visited, record it: add `next_val` to the `visited` map with its index, `visited[next_val] = len(seq)`, and append it to the `seq` list. Then, continue the loop.\n\nThis method is straightforward and directly yields all three invariants $\\mu$, $\\lambda$, and $c$.\n\n#### Method 2: Floyd's Cycle-Finding Algorithm (Tortoise and Hare)\n\nThis algorithm uses two pointers, a \"tortoise\" and a \"hare\", moving through the sequence at different speeds. It detects a cycle with constant space complexity, but requires additional steps to find the invariants.\n\n1.  **Phase 1: Detect Cycle or Termination**\n    a.  Initialize `tortoise = s(n)` and `hare = s(s(n))`. Handle the edge cases where these initial values might be $0$, indicating immediate termination.\n    b.  Advance the pointers in a loop: `tortoise = s(tortoise)` and `hare = s(s(hare))`.\n    c.  The loop terminates if either `tortoise == hare` (a cycle is detected) or if `tortoise` or `hare` becomes $0$ (termination is detected).\n\n2.  **Phase 2: Determine Invariants**\n    a.  **If Termination was Detected**: The sequence ends in $0$. To find $\\mu$, we must re-trace the sequence from the start: initialize `current_val = n` and a counter `mu_val = 0`. Step through the sequence (`current_val = s(current_val)`) until `current_val` becomes $0$, incrementing `mu_val` at each step. The final count is $\\mu$. The other invariants are $\\lambda=0$ and $c=0$.\n    b.  **If a Cycle was Detected**: The pointers met at a value `tortoise` which is an element within the cycle.\n        i.  **Find Preperiod Length ($\\mu$):** Initialize one pointer `ptr1` to the start, $n$, and another `ptr2` to the meeting point, `tortoise`. Advance both pointers one step at a time (`ptr1 = s(ptr1)`, `ptr2 = s(ptr2)`). The first point at which they become equal is the first element of the cycle, $a_\\mu$. The number of steps taken is the preperiod length, $\\mu$.\n        ii. **Find Cycle Length ($\\lambda$):** Starting from the first element of the cycle, $a_\\mu$, advance a pointer one step at a time (`ptr = s(ptr)`) until it returns to $a_\\mu$. The number of steps taken is the cycle length, $\\lambda$.\n        iii. **Find Cycle Representative ($c$):** Iterate through the $\\lambda$ elements of the cycle, starting from $a_\\mu$, and find their minimum value. This is $c$.\n\nBoth methods are implemented in the final program. The hashing-based approach is used to generate the final output due to its more direct computation of all three required invariants.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ... is not needed for this problem.\n\ndef s(n: int) -> int:\n    \"\"\"\n    Computes the sum of proper divisors of an integer n, s(n).\n    s(n) is the sum of all positive integers d such that d | n and 0 < d < n.\n    By convention, s(0) = 0 and s(1) = 0.\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    # Initialize sum with 1, as 1 is a proper divisor for all n > 1.\n    total = 1\n    \n    # Iterate from 2 up to the square root of n.\n    # np.sqrt is used as per the allowed library set.\n    limit = int(np.sqrt(n))\n    for d in range(2, limit + 1):\n        if n % d == 0:\n            total += d\n            quotient = n // d\n            # Add the paired divisor if it's not the same as d (for non-perfect squares).\n            if d != quotient:\n                total += quotient\n                \n    return total\n\ndef analyze_sequence_hash(n: int) -> list[int]:\n    \"\"\"\n    Analyzes the aliquot sequence starting at n using a hashing-based method.\n    \n    Returns:\n        A list [mu, lambda, c] representing the preperiod, cycle length,\n        and cycle representative.\n    \"\"\"\n    if n == 0:\n        return [0, 1, 0] # A fixed point, but often treated as termination.\n                         # The prompt definition s(0)=0 leads to [0, 1, 0].\n                         # Let's align with the termination definition.\n                         # Sequence 0 -> 0. Preperiod 0. Cycle length 1. rep 0.\n                         # But test cases imply 0 means termination. So we just need to handle s(a_k)=0.\n    \n    sequence = [n]\n    visited = {n: 0} # Maps value to its first index\n    k = 0\n    while True:\n        # We add a practical limit to prevent potential infinite loops on\n        # sequences whose behavior is unknown (e.g., Lehmer five), though not\n        # strictly needed for the given test cases.\n        if k > 2000:\n            # This case should not be reached for the provided inputs\n            raise RuntimeError(f\"Sequence starting at {n} did not resolve within the iteration limit.\")\n\n        current_val = sequence[-1]\n        next_val = s(current_val)\n        \n        # Termination check\n        if next_val == 0:\n            mu = len(sequence)\n            lam = 0\n            c = 0\n            return [mu, lam, c]\n        \n        # Cycle detection check\n        if next_val in visited:\n            mu = visited[next_val]\n            lam = len(sequence) - mu\n            cycle = sequence[mu:]\n            c = min(cycle)\n            return [mu, lam, c]\n            \n        # Continue sequence generation\n        visited[next_val] = len(sequence)\n        sequence.append(next_val)\n        k += 1\n\ndef analyze_sequence_floyd(n: int) -> list[int]:\n    \"\"\"\n    Analyzes the aliquot sequence starting at n using Floyd's cycle-finding algorithm.\n    This function is implemented to satisfy the problem requirement but is not\n    used to generate the final output. The hash-based method is more direct.\n    \n    Returns:\n        A list [mu, lambda, c].\n    \"\"\"\n    # Handle simple termination cases first\n    if n == 0:\n        return [0, 0, 0] # Terminating\n    val_s = s(n)\n    if val_s == 0:\n        return [1, 0, 0] # n -> 0\n    val_ss = s(val_s)\n    if val_ss == 0:\n        return [2, 0, 0] # n -> s(n) -> 0\n\n    tortoise = val_s\n    hare = val_ss\n    \n    # Phase 1: Find a meeting point or termination\n    while tortoise != hare:\n        tortoise = s(tortoise)\n        hare = s(s(hare))\n        if tortoise == 0 or hare == 0:\n            # Termination found\n            mu = 0\n            curr = n\n            while curr != 0:\n                curr = s(curr)\n                mu += 1\n            return [mu, 0, 0]\n\n    # Phase 2: Cycle found, now find invariants\n    # Find preperiod length (mu)\n    mu = 0\n    ptr1 = n\n    ptr2 = tortoise\n    while ptr1 != ptr2:\n        ptr1 = s(ptr1)\n        ptr2 = s(ptr2)\n        mu += 1\n    \n    # Find cycle length (lambda)\n    lam = 1\n    ptr2 = s(ptr1)\n    cycle_min = ptr1\n    while ptr1 != ptr2:\n        cycle_min = min(cycle_min, ptr2)\n        ptr2 = s(ptr2)\n        lam += 1\n        \n    c = cycle_min\n    \n    return [mu, lam, c]\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on the test suite and print the output.\n    \"\"\"\n    test_cases = [1, 6, 10, 13, 220, 12496]\n\n    results = []\n    # We use the hash-based method as it's more direct for finding all invariants.\n    # The problem requires implementing both methods; `analyze_sequence_floyd` is also provided.\n    for n in test_cases:\n        mu, lam, c = analyze_sequence_hash(n)\n        results.append(f\"[{mu},{lam},{c}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3080656"}]}