{"hands_on_practices": [{"introduction": "Euler's Pentagonal Number Theorem presents a remarkable identity connecting an infinite product to a sparse infinite sum. This first practice provides a direct, hands-on verification of this surprising result for the first few terms, allowing you to build intuition from the ground up by performing the expansion yourself. By multiplying out the factors of $(q;q)_\\infty$ and observing the resulting cancellations, you will see firsthand how the sparse structure of pentagonal numbers emerges [@problem_id:3084891].", "problem": "Let $q$ be an indeterminate and consider the formal power series ring $\\mathbb{Z}[[q]]$. Define the $q$-Pochhammer symbol by the infinite product $(q;q)_{\\infty} = \\prod_{n=1}^{\\infty} (1 - q^{n})$. Starting only from this definition and the distributive law for formal power series, perform a coefficient-by-coefficient expansion of $(q;q)_{\\infty}$ up to and including the $q^{15}$ term. In your computation, at each multiplication step, justify why discarding terms of degree greater than $15$ preserves correctness of all coefficients up to degree $15$.\n\nAfter obtaining the truncated expansion, independently identify, from first principles, the generalized pentagonal numbers not exceeding $15$ and the corresponding alternating sign pattern predicted by the classical structure underlying Eulerâ€™s pentagonal number theorem. Verify that your truncated product agrees with that structural prediction up to degree $15$.\n\nYour final answer must be the single closed-form analytic expression for the truncation of $(q;q)_{\\infty}$ up to $q^{15}$. No rounding is required.", "solution": "This problem requires a direct expansion of the infinite product $(q;q)_{\\infty} = \\prod_{n=1}^{\\infty} (1 - q^{n})$ up to terms of degree $15$ and a verification of this expansion against the structure described by Euler's Pentagonal Number Theorem.\n\n**Part 1: Justification for Truncation and Direct Expansion**\n\nWe are working in the ring of formal power series $\\mathbb{Z}[[q]]$. To find the coefficients of the infinite product up to degree $15$, we only need to consider the partial product $\\prod_{n=1}^{15} (1 - q^{n})$. Any factor $(1 - q^k)$ with $k > 15$ will not affect the coefficients of terms with degree $15$ or less. This is because multiplying a power series by $(1-q^k)$ only changes coefficients of degree $k$ and higher. Therefore, we can perform our calculations modulo $q^{16}$.\n\nLet $S_k(q) = \\prod_{i=1}^{k} (1-q^i) \\pmod{q^{16}}$. We compute these polynomials iteratively:\n*   $S_1(q) = 1-q$\n*   $S_2(q) = S_1(q)(1-q^2) = 1-q-q^2+q^3$\n*   $S_3(q) = S_2(q)(1-q^3) = 1-q-q^2+q^4+q^5-q^6$\n*   $S_4(q) = S_3(q)(1-q^4) = 1-q-q^2+2q^5-q^8-q^9+q^{10}$\n*   $S_5(q) = S_4(q)(1-q^5) = 1-q-q^2+q^5+q^6+q^7-q^8-q^9-q^{10}+q^{13}+q^{14}-q^{15}$\n*   $S_6(q) = S_5(q)(1-q^6) = 1-q-q^2+q^5+2q^7-q^9-q^{10}-q^{11}-q^{12}+2q^{14}$\n*   $S_7(q) = S_6(q)(1-q^7) = 1-q-q^2+q^5+q^7+q^8-q^{10}-q^{11}-2q^{12}$\n*   $S_8(q) = S_7(q)(1-q^8) = 1-q-q^2+q^5+q^7+q^9-q^{11}-2q^{12}-q^{13}-q^{15}$\n*   $S_9(q) = S_8(q)(1-q^9) = 1-q-q^2+q^5+q^7+q^{10}-2q^{12}-q^{13}-q^{14}-q^{15}$\n*   $S_{10}(q) = S_9(q)(1-q^{10}) = 1-q-q^2+q^5+q^7+q^{11}-q^{12}-q^{13}-q^{14}-2q^{15}$\n*   $S_{11}(q) = S_{10}(q)(1-q^{11}) = 1-q-q^2+q^5+q^7-q^{14}-2q^{15}$\n*   $S_{12}(q) = S_{11}(q)(1-q^{12}) = 1-q-q^2+q^5+q^7-q^{12}+q^{13}-2q^{15}$\n*   $S_{13}(q) = S_{12}(q)(1-q^{13}) = 1-q-q^2+q^5+q^7-q^{12}+q^{14}-q^{15}$\n*   $S_{14}(q) = S_{13}(q)(1-q^{14}) = 1-q-q^2+q^5+q^7-q^{12}$\n*   $S_{15}(q) = S_{14}(q)(1-q^{15}) = 1-q-q^2+q^5+q^7-q^{12}-q^{15}$\n\nAs established, $S_k(q) \\equiv S_{15}(q) \\pmod{q^{16}}$ for all $k > 15$. Thus, the expansion of $(q;q)_\\infty$ up to degree $15$ is:\n$$1 - q - q^2 + q^5 + q^7 - q^{12} - q^{15}$$\n\n**Part 2: Pentagonal Numbers and Theorem Verification**\n\nEuler's Pentagonal Number Theorem states that $(q;q)_{\\infty} = \\sum_{k=-\\infty}^{\\infty} (-1)^k q^{g_k}$, where $g_k = \\frac{k(3k-1)}{2}$ are the generalized pentagonal numbers. We identify these numbers for all $g_k \\le 15$:\n-   $k=0$: $g_0 = 0$. Term: $(-1)^0 q^0 = 1$.\n-   $k=1$: $g_1 = 1$. Term: $(-1)^1 q^1 = -q$.\n-   $k=-1$: $g_{-1} = 2$. Term: $(-1)^{-1} q^2 = -q^2$.\n-   $k=2$: $g_2 = 5$. Term: $(-1)^2 q^5 = q^5$.\n-   $k=-2$: $g_{-2} = 7$. Term: $(-1)^{-2} q^7 = q^7$.\n-   $k=3$: $g_3 = 12$. Term: $(-1)^3 q^{12} = -q^{12}$.\n-   $k=-3$: $g_{-3} = 15$. Term: $(-1)^{-3} q^{15} = -q^{15}$.\n-   The next pentagonal number is for $k=4$, $g_4 = 22$, which is greater than $15$.\n\nSumming the terms predicted by the theorem gives:\n$$1 - q - q^2 + q^5 + q^7 - q^{12} - q^{15}$$\nThis expression is identical to the one obtained by direct expansion. This verifies that the theorem holds up to degree 15.", "answer": "$$\n\\boxed{1 - q - q^2 + q^5 + q^7 - q^{12} - q^{15}}\n$$", "id": "3084891"}, {"introduction": "Beyond its elegance, the true power of Euler's theorem lies in its application to the theory of partitions, providing a highly efficient method for calculating $p(n)$, the number of ways to write an integer $n$ as a sum of positive integers. This exercise guides you through deriving the famous recurrence relation for $p(n)$ from the theorem. You will then apply this recurrence to compute a specific value, $p(10)$, demonstrating a computational power that far exceeds tedious direct enumeration [@problem_id:3084875].", "problem": "Let $p(n)$ denote the number of integer partitions of a nonnegative integer $n$, with the conventions $p(0)=1$ and $p(n)=0$ for $n0$. Begin from the foundational facts that the ordinary generating function of the partition function is the reciprocal of an infinite product and that Euler's pentagonal number theorem gives a series expansion for that product with support on generalized pentagonal numbers. Using only these foundational facts, first derive a linear recurrence for $p(n)$ whose terms are $p(n-m)$ with $m$ ranging over generalized pentagonal numbers and with a sign pattern determined by the parity of the indexing. Then use the derived recurrence to compute $p(10)$ exactly by explicitly listing all generalized pentagonal offsets $m$ that contribute nonzero terms to $p(10)$ and by verifying all intermediate values $p(k)$ that are required in the computation via the same recurrence, not by appeal to memorized values.\n\nYour final answer must be the exact integer value of $p(10)$.", "solution": "The problem requires the derivation of a recurrence relation for the integer partition function, $p(n)$, and its subsequent use to compute $p(10)$.\n\n**Part 1: Derivation of the Recurrence Relation**\n\nThe generating function for the partition function, $P(x)$, is given by:\n$$P(x) = \\sum_{n=0}^{\\infty} p(n)x^n = \\prod_{k=1}^{\\infty} \\frac{1}{1-x^k}$$\nEuler's Pentagonal Number Theorem gives an expansion for the product in the denominator:\n$$\\prod_{k=1}^{\\infty} (1-x^k) = \\sum_{j=-\\infty}^{\\infty} (-1)^j x^{m_j}$$\nwhere the exponents $m_j = \\frac{j(3j-1)}{2}$ are the generalized pentagonal numbers.\n\nCombining these two facts, we obtain the relation $P(x) \\cdot \\prod_{k=1}^{\\infty} (1-x^k) = 1$. Substituting the series expansions gives:\n$$\\left( \\sum_{n=0}^{\\infty} p(n)x^n \\right) \\left( \\sum_{j=-\\infty}^{\\infty} (-1)^j x^{m_j} \\right) = 1$$\nFor this equality to hold, the coefficient of $x^n$ on the left side must be $0$ for all $n>0$. Using the Cauchy product rule, the coefficient of $x^n$ is $\\sum_{j=-\\infty}^{\\infty} (-1)^j p(n-m_j)$. Setting this to zero for $n>0$:\n$$\\sum_{j=-\\infty}^{\\infty} (-1)^j p(n-m_j) = 0$$\nWe can isolate the term where $j=0$ (which corresponds to $m_0=0$ and $(-1)^0=1$):\n$$p(n) + \\sum_{j \\neq 0} (-1)^j p(n-m_j) = 0$$\nRearranging to solve for $p(n)$ yields the recurrence relation:\n$$p(n) = - \\sum_{j \\neq 0} (-1)^j p(n-m_j) = \\sum_{j \\neq 0} (-1)^{j-1} p(n-m_j)$$\nThe first few generalized pentagonal numbers for $j \\neq 0$ are $m_{\\pm 1} = 1, 2$, $m_{\\pm 2} = 5, 7$, $m_{\\pm 3} = 12, 15$, and so on. The recurrence can be written explicitly as:\n$$p(n) = p(n-1) + p(n-2) - p(n-5) - p(n-7) + p(n-12) + \\dots$$\n\n**Part 2: Computation of p(10)**\n\nWe use this recurrence to compute $p(k)$ for $k=1, \\dots, 10$, using the conventions $p(0)=1$ and $p(k)=0$ for $k0$.\n*   $p(1) = p(0) = 1$\n*   $p(2) = p(1) + p(0) = 1+1=2$\n*   $p(3) = p(2) + p(1) = 2+1=3$\n*   $p(4) = p(3) + p(2) = 3+2=5$\n*   $p(5) = p(4) + p(3) - p(0) = 5+3-1=7$\n*   $p(6) = p(5) + p(4) - p(1) = 7+5-1=11$\n*   $p(7) = p(6) + p(5) - p(2) - p(0) = 11+7-2-1=15$\n*   $p(8) = p(7) + p(6) - p(3) - p(1) = 15+11-3-1=22$\n*   $p(9) = p(8) + p(7) - p(4) - p(2) = 22+15-5-2=30$\n\nFinally, we compute $p(10)$. The generalized pentagonal numbers less than or equal to 10 are $1, 2, 5, 7$.\n$$p(10) = p(10-1) + p(10-2) - p(10-5) - p(10-7)$$\n$$p(10) = p(9) + p(8) - p(5) - p(3)$$\nSubstituting the values we have computed:\n$$p(10) = 30 + 22 - 7 - 3$$\n$$p(10) = 52 - 10 = 42$$\nThe exact value of $p(10)$ is $42$.", "answer": "$$\n\\boxed{42}\n$$", "id": "3084875"}, {"introduction": "Manually calculating partition numbers with the recurrence works well for small integers, but how does this method scale for larger values of $n$? This final practice challenges you to think like a computational mathematician by designing and analyzing an algorithm based on the pentagonal number recurrence. You will explore how to implement this recurrence efficiently using dynamic programming and analyze its time complexity, connecting a classical number theory result to modern algorithmic thinking [@problem_id:3084897].", "problem": "Let $p(n)$ denote the number of integer partitions of the nonnegative integer $n$, with the convention $p(0)=1$. The ordinary generating function for the partition function is defined by\n$$\n\\sum_{n\\ge 0} p(n)\\, q^n = \\prod_{k\\ge 1} \\frac{1}{1 - q^k}.\n$$\nStarting from this generating function identity and the product expansion for $\\prod_{k\\ge 1} (1 - q^k)$, derive a finite, sign-alternating recurrence for $p(n)$ whose terms are indexed by the generalized pentagonal numbers\n$$\ng_m = \\frac{m(3m-1)}{2}, \\quad m \\in \\mathbb{Z}\\setminus\\{0\\}.\n$$\nUse that recurrence to design an algorithm that computes $p(n)$ for all $n \\le N$ by dynamic programming, in ascending order of $n$, using only previously computed values. Ensure that your algorithm:\n- Generates the generalized pentagonal numbers in the natural order $m=1,-1,2,-2,3,-3,\\dots$, and for each $n$ uses only those $g_m$ that satisfy $g_m \\le n$.\n- Applies the appropriate sign pattern implied by your derivation to each term in the recurrence for $p(n)$.\n- Counts the total number of addition or subtraction operations performed while computing the entire table $\\{p(0),p(1),\\dots,p(N)\\}$; count each addition or subtraction as a single operation.\n\nAnalyze the time complexity symbolically in terms of $N$ and the function $G(N)$, the number of generalized pentagonal numbers that are less than or equal to $N$. Then, empirically instrument your implementation to report, for each chosen $N$, the following quantities:\n1. $p(N)$,\n2. $G(N)$, and\n3. $T(N)$, the total number of addition or subtraction operations used to compute $\\{p(n)\\}_{n=0}^{N}$ via your algorithm.\n\nTest Suite:\n- Use the following values of $N$: $0$, $1$, $5$, $50$, $100$, $200$.\n- For each $N$ in the suite, return the list $[N, p(N), G(N), T(N)]$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element is itself a list corresponding to a test case. For example, it should look like\n$$\n[\\,[N_1,p(N_1),G(N_1),T(N_1)],\\,[N_2,p(N_2),G(N_2),T(N_2)],\\,\\dots\\,].\n$$\nOnly integers should appear in the output list. No physical units, angles, or percentages are involved in this problem.", "solution": "We begin from the foundational generating function identity for partitions,\n$$\n\\sum_{n\\ge 0} p(n)\\, q^n = \\prod_{k\\ge 1} \\frac{1}{1 - q^k}.\n$$\nThe product $\\prod_{k\\ge 1} (1 - q^k)$ admits a classical signed expansion known as Eulerâ€™s pentagonal number theorem:\n$$\n\\prod_{k\\ge 1} (1 - q^k) = \\sum_{m\\in \\mathbb{Z}} (-1)^m \\, q^{\\frac{m(3m-1)}{2}}.\n$$\nThe integers\n$$\ng_m = \\frac{m(3m-1)}{2}, \\quad m\\in \\mathbb{Z},\n$$\nare called generalized pentagonal numbers; they come in a natural order by taking $m=1,-1,2,-2,3,-3,\\dots$, which yields the strictly increasing sequence $1,2,5,7,12,15,22,26,\\dots$.\n\nMultiplying the two series,\n$$\n\\left(\\sum_{n\\ge 0} p(n)\\, q^n\\right)\\left(\\sum_{m\\in \\mathbb{Z}} (-1)^m \\, q^{g_m}\\right) = 1,\n$$\nand comparing coefficients of $q^n$ for $n\\ge 1$ gives\n$$\n\\sum_{m\\in \\mathbb{Z}} (-1)^m \\, p(n - g_m) = 0,\n$$\nwhere we use $p(k)=0$ for $k0$ and $p(0)=1$. Solving for $p(n)$ yields the finite recurrence\n$$\np(n) = \\sum_{\\substack{m\\in \\mathbb{Z}\\setminus\\{0\\} \\\\ g_m \\le n}} (-1)^{m-1} \\, p(n - g_m).\n$$\nOrdering $m$ as $1,-1,2,-2,3,-3,\\dots$ shows the sign pattern repeats in blocks of two: $+,+,-,-,+,+,-,-,\\dots$, corresponding to $m=1,-1,2,-2,\\dots$.\n\nAlgorithmic design.\n- Precompute the list of generalized pentagonal numbers up to $N$ in the order $m=1,-1,2,-2,\\dots$ via the formulas\n$$\ng_{+k} = \\frac{k(3k-1)}{2}, \\quad g_{-k} = \\frac{k(3k+1)}{2}, \\quad k=1,2,3,\\dots,\n$$\nand stop when both exceed $N$.\n- Maintain a dynamic programming array $P$ of length $N+1$ with $P[0]=1$.\n- For each $n=1,2,\\dots,N$, compute\n$$\nP[n] = \\sum_{i=1}^{L(n)} s_i \\, P[n - g_i],\n$$\nwhere $\\{g_i\\}_{i\\ge 1}$ are the precomputed generalized pentagonal numbers, $L(n)$ is the largest index with $g_{L(n)} \\le n$, and $s_i \\in \\{+1,-1\\}$ follow the pattern $+,+,-,-,+,+,-,-,\\dots$. Each term is an addition or subtraction counted toward the operation tally. This yields all $p(n)$ for $n\\le N$.\n\nCorrectness follows from the coefficient extraction of the product of generating functions and the definition of generalized pentagonal numbers. Termination is guaranteed because for fixed $n$ only finitely many $g_m$ satisfy $g_m \\le n$.\n\nComplexity analysis.\nLet $G(n)$ be the number of generalized pentagonal numbers less than or equal to $n$. The inner loop for computing $p(n)$ performs exactly $G(n)$ additions or subtractions. Therefore the total number of operations to compute $\\{p(0),p(1),\\dots,p(N)\\}$ is\n$$\nT(N) = \\sum_{n=1}^{N} G(n).\n$$\nAsymptotically, since $g_{\\pm k}$ behaves like $\\frac{3}{2}k^2$, the largest $k$ such that $g_{\\pm k} \\le n$ satisfies $k \\approx \\sqrt{\\frac{2n}{3}}$, and there are about two generalized pentagonal numbers per $k$ (for the $\\pm k$ pair). Hence\n$$\nG(n) = \\Theta\\!\\left(\\sqrt{n}\\right),\n$$\nand\n$$\nT(N) = \\sum_{n=1}^{N} \\Theta\\!\\left(\\sqrt{n}\\right) = \\Theta\\!\\left(N^{3/2}\\right).\n$$\nIn Big O notation, this gives $T(N) = O\\!\\left(N\\cdot G(N)\\right)$ and $T(N) = O\\!\\left(N^{3/2}\\right)$.\n\nEmpirical reporting.\nFor each test case value of $N$, the program will:\n- Generate the generalized pentagonal numbers up to $N$ and count $G(N)$.\n- Compute $p(n)$ for all $n\\le N$ via the recurrence and count $T(N)$.\n- Output the quadruple $[N, p(N), G(N), T(N)]$.\n\nEdge cases.\n- For $N=0$, we have $p(0)=1$, $G(0)=0$, and $T(0)=0$.\n- For small $N$, the algorithm naturally uses only the initial generalized pentagonal numbers.\n- For larger $N$, the dynamic program relies on previously computed values and remains accurate due to integer arithmetic.\n\nThe final output aggregates these per-$N$ results into a single list on one line, matching the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_generalized_pentagonals(N: int):\n    \"\"\"\n    Generate generalized pentagonal numbers up to N in the order:\n    k=1,-1,2,-2,3,-3,...\n    Returns:\n        g_list: list of generalized pentagonal numbers = N in Euler order\n        s_list: corresponding signs [+,+,-,-,+,+,-,-,...]\n    \"\"\"\n    g_list = []\n    s_list = []\n    k = 1\n    # Sign pattern: +,+,-,-,+,+,-,-,... aligned with k=1,-1,2,-2,3,-3,...\n    # We'll append a_k then b_k for each positive k (if within bound).\n    while True:\n        a = k * (3 * k - 1) // 2  # g_{+k}\n        b = k * (3 * k + 1) // 2  # g_{-k}\n        added_any = False\n        if a = N:\n            g_list.append(a)\n            s_list.append(+1 if len(s_list) % 4 in (0, 1) else -1)  # ensure pattern holds\n            added_any = True\n        if b = N:\n            g_list.append(b)\n            s_list.append(+1 if len(s_list) % 4 in (0, 1) else -1)\n            added_any = True\n        if not added_any:\n            break\n        k += 1\n\n    # The sign assignment above depends on position; however, to guarantee\n    # exact +,+,-,-,... mapping regardless of branch conditions, we recompute signs:\n    # The pattern is periodic in blocks of two generalized pentagonals.\n    # Indices: 0,1 - +; 2,3 - -; 4,5 - +; 6,7 - -; ...\n    s_list = []\n    for i in range(len(g_list)):\n        # i mod 4 in {0,1} - +1; else -1\n        s_list.append(+1 if (i % 4) in (0, 1) else -1)\n    return g_list, s_list\n\ndef partitions_up_to(N: int):\n    \"\"\"\n    Compute p(n) for 0 = n = N using Euler's pentagonal recurrence.\n    Returns:\n        P: list of p(n) values for n=0..N\n        term_count: total number of additions/subtractions used\n        gp_count: G(N), number of generalized pentagonal numbers = N\n    \"\"\"\n    if N  0:\n        return [], 0, 0\n    gp, signs = generate_generalized_pentagonals(N)\n    P = [0] * (N + 1)\n    P[0] = 1\n    term_count = 0\n    for n in range(1, N + 1):\n        total = 0\n        for i, g in enumerate(gp):\n            if g  n:\n                break\n            total += signs[i] * P[n - g]\n            term_count += 1\n        P[n] = total\n    return P, term_count, len(gp)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1, 5, 50, 100, 200]\n\n    results = []\n    for N in test_cases:\n        P, term_count, gp_count = partitions_up_to(N)\n        results.append([N, P[N], gp_count, term_count])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3084897"}]}