{"hands_on_practices": [{"introduction": "This exercise explores the combinatorial structure of partitions where parts differ by at least two, which form one side of the first Rogers-Ramanujan identity. By using Ferrers diagrams and a clever transformation, you will discover a surprising connection between these special partitions and the fundamental $q$-binomial coefficients. This hands-on approach provides a deep, visual intuition for the \"sum side\" of the identity [@problem_id:3093195].", "problem": "Let $q$ be an indeterminate. A partition of a nonnegative integer $n$ is a nonincreasing finite sequence of positive integers whose sum is $n$. The Ferrers diagram of a partition is its representation by left-justified rows of dots, with the $i$-th row having as many dots as the $i$-th part. Consider the set $\\mathcal{R}_{N}$ of partitions $\\lambda$ such that the differences between consecutive parts satisfy $\\lambda_{i} - \\lambda_{i+1} \\ge 2$ for all applicable indices $i$, and the largest part satisfies $\\lambda_{1} \\le N$. Let $|\\lambda|$ denote the sum of the parts (the size) of $\\lambda$. Define the finite generating polynomial\n$$F_{N}(q) = \\sum_{\\lambda \\in \\mathcal{R}_{N}} q^{|\\lambda|}.$$\nStarting from the fundamental definitions of partitions, Ferrers diagrams, and the interpretation of generating functions as weighted counts, use Ferrers diagrams to derive a counting method for $\\mathcal{R}_{N}$ by removing a suitable staircase shape, and express $F_{N}(q)$ in terms of a sum over the number of parts and a standard $q$-analog counting polynomial. Then compute $F_{N}(q)$ explicitly for $N = 1,2,3,4,5,6$, expressing each $F_{N}(q)$ as a polynomial in $q$. Return your final answer as the ordered $6$-tuple $\\left(F_{1}(q),F_{2}(q),F_{3}(q),F_{4}(q),F_{5}(q),F_{6}(q)\\right)$.", "solution": "The problem is valid as it is scientifically grounded in the theory of integer partitions and generating functions, is well-posed, and uses objective, unambiguous mathematical language.\n\nLet $\\mathcal{R}_{N}$ be the set of partitions $\\lambda = (\\lambda_1, \\lambda_2, \\dots, \\lambda_k)$ such that the parts are positive integers satisfying $\\lambda_1 \\le N$ and $\\lambda_i - \\lambda_{i+1} \\ge 2$ for $i=1, \\dots, k-1$. The empty partition, $\\lambda=()$, is a partition of $0$ and vacuously satisfies the conditions, with its largest part considered to be $0$, so $0 \\le N$ for any $N \\ge 0$. The sum of its parts is $|\\lambda| = 0$.\n\nThe generating function $F_N(q)$ is defined as $F_{N}(q) = \\sum_{\\lambda \\in \\mathcal{R}_{N}} q^{|\\lambda|}$. We can partition the set $\\mathcal{R}_{N}$ by the number of parts, $k$. Let $\\mathcal{R}_{N,k}$ be the subset of partitions in $\\mathcal{R}_N$ with exactly $k$ parts. The generating function can be written as:\n$$F_N(q) = 1 + \\sum_{k=1}^{\\infty} \\sum_{\\lambda \\in \\mathcal{R}_{N,k}} q^{|\\lambda|}$$\nwhere the $1$ corresponds to the empty partition ($k=0$).\n\nThe problem suggests using Ferrers diagrams and removing a \"staircase shape\". Let $\\lambda = (\\lambda_1, \\lambda_2, \\dots, \\lambda_k) \\in \\mathcal{R}_{N,k}$. The conditions on its parts are:\n1. $N \\ge \\lambda_1$\n2. $\\lambda_i - \\lambda_{i+1} \\ge 2$ for $i=1, \\dots, k-1$\n3. $\\lambda_k \\ge 1$\n\nLet's define a new sequence of integers $\\mu = (\\mu_1, \\mu_2, \\dots, \\mu_k)$ from $\\lambda$ by \"removing a staircase\". A suitable choice for the staircase to remove from the Ferrers diagram of $\\lambda$ is the partition $(2k-1, 2k-3, \\dots, 3, 1)$, which has $k$ parts and size $k^2$. This corresponds to the transformation:\n$$\\mu_i = \\lambda_i - (2(k-i)+1) \\quad \\text{for } i=1, \\dots, k$$\nWe need to verify that this transformation maps $\\lambda \\in \\mathcal{R}_{N,k}$ to a standard partition $\\mu$ and that this map is a bijection.\n\nFirst, let's check the properties of $\\mu$:\n-   The condition $\\lambda_i - \\lambda_{i+1} \\ge 2$ implies:\n    $$(\\mu_i + (2k-2i+1)) - (\\mu_{i+1} + (2k-2(i+1)+1)) \\ge 2$$\n    $$\\mu_i - \\mu_{i+1} + (2k-2i+1) - (2k-2i-1) \\ge 2$$\n    $$\\mu_i - \\mu_{i+1} + 2 \\ge 2 \\implies \\mu_i \\ge \\mu_{i+1}$$\n    This shows that $\\mu_1 \\ge \\mu_2 \\ge \\dots \\ge \\mu_k$.\n-   The condition $\\lambda_k \\ge 1$ implies:\n    $$\\mu_k + (2(k-k)+1) \\ge 1 \\implies \\mu_k + 1 \\ge 1 \\implies \\mu_k \\ge 0$$\n    So, $\\mu$ is a partition into non-negative integers, meaning it is a standard integer partition which may have fewer than $k$ positive parts if some $\\mu_i$ are $0$.\n-   The condition $\\lambda_1 \\le N$ implies:\n    $$\\mu_1 + (2(k-1)+1) \\le N \\implies \\mu_1 + 2k - 1 \\le N \\implies \\mu_1 \\le N - 2k + 1$$\n    This transformation is a bijection. For any partition $\\mu$ satisfying $\\mu_1 \\ge \\dots \\ge \\mu_k \\ge 0$ and $\\mu_1 \\le N - 2k + 1$, we can uniquely recover a partition $\\lambda \\in \\mathcal{R}_{N,k}$ by setting $\\lambda_i = \\mu_i + (2(k-i)+1)$.\n\nThe sum of parts of $\\lambda$ is related to the sum of parts of $\\mu$:\n$$|\\lambda| = \\sum_{i=1}^k \\lambda_i = \\sum_{i=1}^k (\\mu_i + 2(k-i)+1) = \\sum_{i=1}^k \\mu_i + \\sum_{j=1}^k (2j-1) \\text{ where } j=k-i+1$$\nThe second sum is the sum of the first $k$ odd integers, which is $k^2$. Thus, $|\\lambda| = |\\mu| + k^2$.\n\nThe generating function for partitions in $\\mathcal{R}_{N,k}$ is:\n$$\\sum_{\\lambda \\in \\mathcal{R}_{N,k}} q^{|\\lambda|} = \\sum_{\\mu} q^{|\\mu| + k^2} = q^{k^2} \\sum_{\\mu} q^{|\\mu|}$$\nThe sum is over all partitions $\\mu$ such that:\n1. The number of parts is at most $k$ (i.e., its Ferrers diagram has at most $k$ rows).\n2. The largest part is at most $N - 2k + 1$ (i.e., its Ferrers diagram has at most $N - 2k + 1$ columns).\n\nThe generating function for partitions whose Ferrers diagram fits into a $k \\times m$ box (at most $k$ parts, largest part at most $m$) is given by the $q$-binomial coefficient (or Gaussian polynomial) $\\binom{k+m}{k}_q$.\nHere, $m = N - 2k + 1$. The generating function for $\\mu$ is therefore $\\binom{k + (N - 2k + 1)}{k}_q = \\binom{N-k+1}{k}_q$.\nThe sum over $\\mathcal{R}_{N,k}$ is non-empty only if a partition can be formed. The smallest such partition is $(2k-1, 2k-3, \\dots, 1)$, with largest part $\\lambda_1 = 2k-1$. We must have $2k-1 \\le N$, which implies $k \\le (N+1)/2$. This is consistent with the property of $q$-binomial coefficients that $\\binom{n}{k}_q=0$ if $k>n$, as $N-k+1 < k$ is equivalent to $N+1 < 2k$.\n\nSo, the total generating function is:\n$$F_N(q) = 1 + \\sum_{k=1}^{\\lfloor(N+1)/2\\rfloor} q^{k^2} \\binom{N-k+1}{k}_q$$\n\nWe now compute $F_N(q)$ for $N=1, \\dots, 6$. We use the formula $\\binom{n}{k}_q = \\frac{\\prod_{i=1}^n (1-q^i)}{\\left(\\prod_{i=1}^k (1-q^i)\\right)\\left(\\prod_{i=1}^{n-k} (1-q^i)\\right)}$.\nFor $k=1$, $\\binom{n}{1}_q = \\frac{1-q^n}{1-q} = 1+q+\\dots+q^{n-1}$. For $k=n$, $\\binom{n}{n}_q = 1$.\n\n-   **N = 1**: $k \\le 1$.\n    $F_1(q) = 1 + q^{1^2} \\binom{1-1+1}{1}_q = 1 + q \\binom{1}{1}_q = 1 + q(1) = 1+q$.\n\n-   **N = 2**: $k \\le 1.5$, so $k=1$.\n    $F_2(q) = 1 + q^{1^2} \\binom{2-1+1}{1}_q = 1 + q \\binom{2}{1}_q = 1 + q(1+q) = 1+q+q^2$.\n\n-   **N = 3**: $k \\le 2$.\n    $F_3(q) = 1 + q^{1^2} \\binom{3-1+1}{1}_q + q^{2^2} \\binom{3-2+1}{2}_q = 1 + q \\binom{3}{1}_q + q^4 \\binom{2}{2}_q = 1 + q(1+q+q^2) + q^4(1) = 1+q+q^2+q^3+q^4$.\n\n-   **N = 4**: $k \\le 2.5$, so $k=1, 2$.\n    $F_4(q) = 1 + q \\binom{4}{1}_q + q^4 \\binom{4-2+1}{2}_q = 1 + q \\binom{4}{1}_q + q^4 \\binom{3}{2}_q$.\n    $\\binom{4}{1}_q = 1+q+q^2+q^3$.\n    $\\binom{3}{2}_q = \\binom{3}{1}_q = 1+q+q^2$.\n    $F_4(q) = 1 + q(1+q+q^2+q^3) + q^4(1+q+q^2) = 1 + q+q^2+q^3+q^4 + q^4+q^5+q^6 = 1+q+q^2+q^3+2q^4+q^5+q^6$.\n\n-   **N = 5**: $k \\le 3$.\n    $F_5(q) = 1 + q \\binom{5}{1}_q + q^4 \\binom{5-2+1}{2}_q + q^9 \\binom{5-3+1}{3}_q = 1 + q \\binom{5}{1}_q + q^4 \\binom{4}{2}_q + q^9 \\binom{3}{3}_q$.\n    $\\binom{5}{1}_q = 1+q+q^2+q^3+q^4$.\n    $\\binom{4}{2}_q = \\frac{(1-q^4)(1-q^3)}{(1-q)(1-q^2)} = (1+q^2)(1+q+q^2) = 1+q+2q^2+q^3+q^4$.\n    $\\binom{3}{3}_q = 1$.\n    $F_5(q) = 1 + q(1+q+q^2+q^3+q^4) + q^4(1+q+2q^2+q^3+q^4) + q^9(1) = 1 + (q+q^2+q^3+q^4+q^5) + (q^4+q^5+2q^6+q^7+q^8) + q^9 = 1+q+q^2+q^3+2q^4+2q^5+2q^6+q^7+q^8+q^9$.\n\n-   **N = 6**: $k \\le 3.5$, so $k=1, 2, 3$.\n    $F_6(q) = 1 + q\\binom{6}{1}_q + q^4\\binom{6-2+1}{2}_q + q^9\\binom{6-3+1}{3}_q = 1 + q\\binom{6}{1}_q + q^4\\binom{5}{2}_q + q^9\\binom{4}{3}_q$.\n    $\\binom{6}{1}_q = 1+q+q^2+q^3+q^4+q^5$.\n    $\\binom{5}{2}_q = \\frac{(1-q^5)(1-q^4)}{(1-q)(1-q^2)} = (1+q+q^2+q^3+q^4)(1+q^2) = 1+q+2q^2+2q^3+2q^4+q^5+q^6$.\n    $\\binom{4}{3}_q = \\binom{4}{1}_q = 1+q+q^2+q^3$.\n    $F_6(q) = 1 + q(1+q+q^2+q^3+q^4+q^5) + q^4(1+q+2q^2+2q^3+2q^4+q^5+q^6) + q^9(1+q+q^2+q^3)$.\n    $F_6(q) = 1 + (q+q^2+q^3+q^4+q^5+q^6) + (q^4+q^5+2q^6+2q^7+2q^8+q^9+q^{10}) + (q^9+q^{10}+q^{11}+q^{12})$.\n    $F_6(q) = 1+q+q^2+q^3+2q^4+2q^5+3q^6+2q^7+2q^8+2q^9+2q^{10}+q^{11}+q^{12}$.\n\nThe 6-tuple of polynomials is:\n1. $F_1(q) = 1+q$\n2. $F_2(q) = 1+q+q^2$\n3. $F_3(q) = 1+q+q^2+q^3+q^4$\n4. $F_4(q) = 1+q+q^2+q^3+2q^4+q^5+q^6$\n5. $F_5(q) = 1+q+q^2+q^3+2q^4+2q^5+2q^6+q^7+q^8+q^9$\n6. $F_6(q) = 1+q+q^2+q^3+2q^4+2q^5+3q^6+2q^7+2q^8+2q^9+2q^{10}+q^{11}+q^{12}$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1+q, & 1+q+q^2, & 1+q+q^2+q^3+q^4, & 1+q+q^2+q^3+2q^4+q^5+q^6, & 1+q+q^2+q^3+2q^4+2q^5+2q^6+q^7+q^8+q^9, & 1+q+q^2+q^3+2q^4+2q^5+3q^6+2q^7+2q^8+2q^9+2q^{10}+q^{11}+q^{12}\n\\end{pmatrix}\n}\n$$", "id": "3093195"}, {"introduction": "We now shift our focus to the \"product side\" of the identity, which generates partitions with parts restricted by congruence conditions. This practice introduces the powerful analytical technique of logarithmic differentiation to unveil the structure hidden within the infinite product. By applying this method, you will derive a recurrence relation that allows for the systematic computation of the partition numbers [@problem_id:3093197].", "problem": "Let $q$ be an indeterminate and define the Rogers–Ramanujan function $R(q)$ by the infinite product\n$$\nR(q) \\;=\\; \\frac{1}{(q;q^{5})_{\\infty}\\,(q^{4};q^{5})_{\\infty}},\n$$\nwhere the $q$-Pochhammer symbol is $(a;q)_{\\infty} \\coloneqq \\prod_{n=0}^{\\infty} (1 - a\\,q^{n})$. By the Rogers–Ramanujan identities, this $R(q)$ also equals the series $\\sum_{n=0}^{\\infty} \\frac{q^{n^{2}}}{(q;q)_{n}}$, but for this problem you may take the product form as the starting point.\n\nWrite\n$$\nR(q) \\;=\\; \\sum_{n=0}^{\\infty} a_{n}\\,q^{n},\n$$\nand regard this as a formal power series with $a_{0}\\neq 0$.\n\nStarting only from the given infinite product definition and fundamental properties of formal power series and logarithmic differentiation, do the following:\n\n1) Derive a functional equation for $q\\,\\frac{R'(q)}{R(q)}$ and use it to deduce a recurrence that determines the coefficients $a_{n}$ in terms of earlier coefficients. Your recurrence must be explicit in terms of arithmetic data determined by residue classes modulo $5$.\n\n2) Use your recurrence to compute the first five coefficients $a_{0},a_{1},a_{2},a_{3},a_{4}$ exactly.\n\nYour final answer must consist only of these five coefficients presented in order as a single row matrix. No rounding is required.", "solution": "The problem asks for two main tasks related to the Rogers-Ramanujan function $R(q)$, defined by the infinite product $R(q) = \\frac{1}{(q;q^{5})_{\\infty}\\,(q^{4};q^{5})_{\\infty}}$. We are to work with its formal power series representation $R(q) = \\sum_{n=0}^{\\infty} a_{n}\\,q^{n}$.\n\nFirst, we validate the problem statement. The definitions for the Rogers-Ramanujan function and the $q$-Pochhammer symbol are standard in the theory of partitions and $q$-series. The tasks involve standard mathematical techniques like logarithmic differentiation and manipulation of formal power series. The problem is self-contained, scientifically grounded in number theory, and well-posed. Thus, the problem is valid, and we may proceed with the solution.\n\n**Part 1: Derivation of the recurrence relation**\n\nThe function $R(q)$ is given by:\n$$\nR(q) = \\frac{1}{(q;q^{5})_{\\infty}\\,(q^{4};q^{5})_{\\infty}}\n$$\nUsing the definition of the $q$-Pochhammer symbol, $(a;q)_{\\infty} = \\prod_{k=0}^{\\infty} (1 - a\\,q^{k})$, we can expand the denominator:\n$$\nR(q) = \\frac{1}{\\left(\\prod_{k=0}^{\\infty} (1 - q \\cdot (q^5)^k)\\right) \\left(\\prod_{k=0}^{\\infty} (1 - q^4 \\cdot (q^5)^k)\\right)} = \\frac{1}{\\prod_{k=0}^{\\infty} (1 - q^{5k+1}) (1 - q^{5k+4})}\n$$\nTo find the logarithmic derivative, we take the natural logarithm of $R(q)$:\n$$\n\\ln R(q) = \\ln \\left( \\left(\\prod_{k=0}^{\\infty} (1 - q^{5k+1}) (1 - q^{5k+4})\\right)^{-1} \\right) = - \\sum_{k=0}^{\\infty} \\left[\\ln(1 - q^{5k+1}) + \\ln(1 - q^{5k+4})\\right]\n$$\nDifferentiating with respect to $q$, we get $\\frac{R'(q)}{R(q)} = \\frac{d}{dq} \\ln R(q)$:\n$$\n\\frac{R'(q)}{R(q)} = - \\sum_{k=0}^{\\infty} \\left[ \\frac{-(5k+1)q^{5k}}{1 - q^{5k+1}} + \\frac{-(5k+4)q^{5k+3}}{1 - q^{5k+4}} \\right] = \\sum_{k=0}^{\\infty} \\left[ \\frac{(5k+1)q^{5k}}{1 - q^{5k+1}} + \\frac{(5k+4)q^{5k+3}}{1 - q^{5k+4}} \\right]\n$$\nThe problem requires a functional equation for $q\\,\\frac{R'(q)}{R(q)}$. Multiplying by $q$:\n$$\nq\\,\\frac{R'(q)}{R(q)} = \\sum_{k=0}^{\\infty} \\left[ \\frac{(5k+1)q^{5k+1}}{1 - q^{5k+1}} + \\frac{(5k+4)q^{5k+4}}{1 - q^{5k+4}} \\right]\n$$\nTo deduce a recurrence, we expand this expression into a power series. Using the geometric series expansion $\\frac{x}{1-x} = \\sum_{j=1}^{\\infty} x^j$ (valid for formal power series):\n$$\nq\\,\\frac{R'(q)}{R(q)} = \\sum_{k=0}^{\\infty} (5k+1) \\sum_{j=1}^{\\infty} (q^{5k+1})^j + \\sum_{k=0}^{\\infty} (5k+4) \\sum_{j=1}^{\\infty} (q^{5k+4})^j\n$$\n$$\nq\\,\\frac{R'(q)}{R(q)} = \\sum_{k=0}^{\\infty}\\sum_{j=1}^{\\infty} (5k+1)q^{j(5k+1)} + \\sum_{k=0}^{\\infty}\\sum_{j=1}^{\\infty} (5k+4)q^{j(5k+4)}\n$$\nLet this series be denoted by $C(q) = \\sum_{m=1}^{\\infty} c_m q^m$. The coefficient $c_m$ is the sum of contributions to the power $q^m$. The term $(5k+1)q^{j(5k+1)}$ contributes $5k+1$ to the coefficient of $q^m$ if $m = j(5k+1)$. This means $d = 5k+1$ is a divisor of $m$. Such a divisor satisfies $d \\equiv 1 \\pmod 5$. Similarly, the term $(5k+4)q^{j(5k+4)}$ contributes $5k+4$ if $d = 5k+4$ is a divisor of $m$. Such a divisor satisfies $d \\equiv 4 \\pmod 5$.\nThus, the coefficient $c_m$ is the sum of all divisors of $m$ which are congruent to $1$ or $4$ modulo $5$:\n$$\nc_m = \\sum_{d|m, \\, d \\equiv 1 \\pmod 5} d + \\sum_{d|m, \\, d \\equiv 4 \\pmod 5} d\n$$\nWe have the identity $q R'(q) = R(q) C(q)$. Substituting the power series for $R(q)$ and $C(q)$:\n$$\nq \\frac{d}{dq} \\left(\\sum_{n=0}^{\\infty} a_n q^n\\right) = \\left(\\sum_{k=0}^{\\infty} a_k q^k\\right) \\left(\\sum_{m=1}^{\\infty} c_m q^m\\right)\n$$\nThe left-hand side becomes:\n$$\nq \\sum_{n=1}^{\\infty} n a_n q^{n-1} = \\sum_{n=1}^{\\infty} n a_n q^n\n$$\nThe right-hand side is a Cauchy product. The coefficient of $q^n$ is $\\sum_{k=0}^{n-1} a_k c_{n-k}$.\nBy equating the coefficients of $q^n$ for $n \\ge 1$, we obtain the recurrence relation:\n$$\nn a_n = \\sum_{k=0}^{n-1} a_k c_{n-k}\n$$\nThis determines $a_n$ for $n \\ge 1$ in terms of previous coefficients $a_0, \\dots, a_{n-1}$ and the values $c_j$, which are the required arithmetic data.\n\n**Part 2: Computation of the first five coefficients**\n\nFirst, we find $a_0 = R(0)$. From the infinite product definition, setting $q=0$ gives $1$ in the denominator.\n$$\na_0 = R(0) = 1\n$$\nNext, we compute the necessary $c_m$ values:\n- $c_1$: The divisors of $1$ are $\\{1\\}$. $1 \\equiv 1 \\pmod 5$. So, $c_1 = 1$.\n- $c_2$: The divisors of $2$ are $\\{1, 2\\}$. $1 \\equiv 1 \\pmod 5$, $2 \\equiv 2 \\pmod 5$. So, $c_2 = 1$.\n- $c_3$: The divisors of $3$ are $\\{1, 3\\}$. $1 \\equiv 1 \\pmod 5$, $3 \\equiv 3 \\pmod 5$. So, $c_3 = 1$.\n- $c_4$: The divisors of $4$ are $\\{1, 2, 4\\}$. $1 \\equiv 1 \\pmod 5$, $2 \\equiv 2 \\pmod 5$, $4 \\equiv 4 \\pmod 5$. So, $c_4 = 1+4 = 5$.\n\nNow we apply the recurrence relation $n a_n = \\sum_{k=0}^{n-1} a_k c_{n-k}$ for $n=1, 2, 3, 4$.\n\n- For $n=1$:\n$$\n1 \\cdot a_1 = a_0 c_1 = 1 \\cdot 1 = 1 \\implies a_1 = 1\n$$\n- For $n=2$:\n$$\n2 \\cdot a_2 = a_0 c_2 + a_1 c_1 = 1 \\cdot 1 + 1 \\cdot 1 = 2 \\implies a_2 = 1\n$$\n- For $n=3$:\n$$\n3 \\cdot a_3 = a_0 c_3 + a_1 c_2 + a_2 c_1 = 1 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1 = 3 \\implies a_3 = 1\n$$\n- For $n=4$:\n$$\n4 \\cdot a_4 = a_0 c_4 + a_1 c_3 + a_2 c_2 + a_3 c_1 = 1 \\cdot 5 + 1 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1 = 8 \\implies a_4 = 2\n$$\nThe first five coefficients are $a_0=1$, $a_1=1$, $a_2=1$, $a_3=1$, and $a_4=2$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 & 1 & 1 & 1 & 2\n\\end{pmatrix}\n}\n$$", "id": "3093197"}, {"introduction": "This capstone exercise brings both sides of the Rogers-Ramanujan identities together through the lens of computation. You will design and compare two distinct algorithms—one based on the product definition and another on the sum definition—to generate the coefficients of the series. Verifying that these two fundamentally different computational processes yield identical results provides a powerful and concrete confirmation of these remarkable identities [@problem_id:3093186].", "problem": "Let $q$ be a formal variable and let $(a;q)_n$ denote the $q$-Pochhammer symbol defined by $(a;q)_0=1$ and $(a;q)_n=\\prod_{k=0}^{n-1}(1-aq^k)$ for every integer $n\\ge 1$. Consider integer partitions, where a partition of a nonnegative integer $n$ is a finite multiset of positive integers whose sum is $n$. The generating function for partitions whose allowed part sizes come from a subset $S\\subseteq \\mathbb{Z}_{\\ge 1}$ is the formal power series $\\prod_{s\\in S}\\frac{1}{1-q^s}$, where the coefficient of $q^n$ equals the number of ways to write $n$ as a sum of elements of $S$ with unlimited multiplicity, disregarding order.\n\nDefine two partition families:\n- For the first family, allowed part sizes are all positive integers congruent to $1$ or $4$ modulo $5$, that is, $S_1=\\{s\\in \\mathbb{Z}_{\\ge 1} : s\\equiv 1 \\text{ or } 4 \\pmod{5}\\}$.\n- For the second family, allowed part sizes are all positive integers congruent to $2$ or $3$ modulo $5$, that is, $S_2=\\{s\\in \\mathbb{Z}_{\\ge 1} : s\\equiv 2 \\text{ or } 3 \\pmod{5}\\}$.\n\nIndependently, consider the two formal power series defined by truncation-stable sums:\n- $S_1^{\\text{sum}}(q)=\\sum_{m\\ge 0} \\dfrac{q^{m^2}}{(q;q)_m}$,\n- $S_2^{\\text{sum}}(q)=\\sum_{m\\ge 0} \\dfrac{q^{m(m+1)}}{(q;q)_m}$,\nwhere $(q;q)_m=\\prod_{k=1}^{m}(1-q^k)$ and the reciprocal $\\dfrac{1}{(q;q)_m}$ is interpreted as the generating function for partitions whose allowed part sizes are the integers from $1$ through $m$ with unlimited multiplicity.\n\nYour task is to design and implement a dynamic programming algorithm that, given a nonnegative integer $N$, computes the coefficient arrays $\\{P_1(n)\\}_{n=0}^N$ and $\\{P_2(n)\\}_{n=0}^N$ for the product-side partition families (based on $S_1$ and $S_2$ respectively), and also computes the coefficient arrays $\\{A_1(n)\\}_{n=0}^N$ and $\\{A_2(n)\\}_{n=0}^N$ for the sum-side series $S_1^{\\text{sum}}(q)$ and $S_2^{\\text{sum}}(q)$ up to degree $N$.\n\nAlgorithmic requirements:\n- For the product-side arrays, use an unbounded coin-change dynamic programming recurrence to compute $\\{P_1(n)\\}_{n=0}^N$ and $\\{P_2(n)\\}_{n=0}^N$, where the allowed part sizes are restricted to the sets $S_1$ and $S_2$ intersected with $\\{1,2,\\dots,N\\}$.\n- For the sum-side arrays, compute $\\dfrac{1}{(q;q)_m}$ up to degree $N$ for all $m$ needed by building it incrementally via dynamic programming in $m$. Then, form $\\{A_1(n)\\}_{n=0}^N$ by summing the shifted arrays corresponding to $q^{m^2}\\dfrac{1}{(q;q)_m}$ over all integers $m$ with $m^2\\le N$, and form $\\{A_2(n)\\}_{n=0}^N$ by summing the shifted arrays corresponding to $q^{m(m+1)}\\dfrac{1}{(q;q)_m}$ over all integers $m$ with $m(m+1)\\le N$.\n- Analyze the asymptotic time complexity as a function of $N$ for both approaches, and state the dependence on the number of allowed part sizes.\n\nVerification requirement:\n- For each test $N$, verify the equalities $P_1(n)=A_1(n)$ and $P_2(n)=A_2(n)$ for all integers $n$ with $0\\le n\\le N$, and report this verification result as booleans.\n\nTest suite:\n- Use the following test values of $N$: $N\\in\\{0,1,12,25,60\\}$.\n- These test cases cover a trivial boundary case ($N=0$), the smallest nontrivial case ($N=1$), a small general case ($N=12$), a moderate case ($N=25$), and a larger case ($N=60$) that stresses both algorithms.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case $N$, output the list $[b_1,b_2]$ where $b_1$ is the boolean confirming $P_1(n)=A_1(n)$ for all $0\\le n\\le N$, and $b_2$ is the boolean confirming $P_2(n)=A_2(n)$ for all $0\\le n\\le N$. Thus the final line should look like $[[b_{1,1},b_{1,2}],[b_{2,1},b_{2,2}],\\dots]$.", "solution": "The problem requires the computational verification of the two Rogers-Ramanujan identities for a given integer range. These identities equate an infinite sum representation to an infinite product representation for two specific formal power series in a variable $q$.\n\nThe first identity is:\n$$\n\\sum_{m=0}^{\\infty} \\frac{q^{m^2}}{(q;q)_m} = \\prod_{k=0}^{\\infty} \\frac{1}{(1-q^{5k+1})(1-q^{5k+4})}\n$$\nThe second identity is:\n$$\n\\sum_{m=0}^{\\infty} \\frac{q^{m(m+1)}}{(q;q)_m} = \\prod_{k=0}^{\\infty} \\frac{1}{(1-q^{5k+2})(1-q^{5k+3})}\n$$\n\nHere, $(q;q)_m = \\prod_{k=1}^{m}(1-q^k)$ is the $q$-Pochhammer symbol for $a=q$. The left-hand sides are the \"sum-sides\" and the right-hand sides are the \"product-sides\".\n\nIn the language of integer partitions, the coefficient of $q^n$ in the product-side generating function $\\prod_{s \\in S} \\frac{1}{1-q^s}$ counts the number of partitions of the integer $n$ into parts taken from the set $S$.\nThus, the first identity states that the number of partitions of $n$ into parts that are congruent to $1$ or $4 \\pmod{5}$ (set $S_1$) is equal to the number of partitions of $n$ into parts where the difference between any two parts is at least $2$. The sum-side generating function corresponds to this second condition.\nThe second identity states that the number of partitions of $n$ into parts that are congruent to $2$ or $3 \\pmod{5}$ (set $S_2$) is equal to the number of partitions of $n$ into parts greater than $1$ where the difference between any two parts is at least $2$.\n\nThe task is to compute the coefficient arrays of these series up to a degree $N$ using two distinct dynamic programming algorithms—one for the product-side representation ($P_1(n)$, $P_2(n)$) and one for the sum-side representation ($A_1(n)$, $A_2(n)$)—and then to verify that they are equal for all $n \\in \\{0, 1, \\dots, N\\}$.\n\n**Algorithm 1: Product-Side Coefficient Calculation**\n\nTo compute the coefficients $\\{P_1(n)\\}_{n=0}^N$ and $\\{P_2(n)\\}_{n=0}^N$, we interpret the problem as a variation of the unbounded knapsack or coin change problem. The number of partitions of $n$ using parts from a set $S$, denoted $p_S(n)$, is the coefficient of $q^n$ in $\\prod_{s\\in S} \\frac{1}{1-q^s}$. We can compute this using dynamic programming.\n\nLet $dp[i]$ be the number of partitions of integer $i$ using parts from a given set of allowed sizes. We initialize $dp[0] = 1$ and $dp[i] = 0$ for $i > 0$. We then iterate through each allowed part size $s \\in S$ (up to $N$) and update the $dp$ table according to the recurrence:\n$dp_{new}[i] = dp_{old}[i] + dp_{new}[i-s]$.\nThis can be implemented with an in-place update for each part size $s$:\nFor each $s \\in S \\cap \\{1, \\dots, N\\}$:\n  For $n$ from $s$ to $N$:\n    $dp[n] \\leftarrow dp[n] + dp[n-s]$\n\nThis procedure is applied twice:\n1.  For $\\{P_1(n)\\}_{n=0}^N$, the set of parts is $S_1 = \\{s \\in \\mathbb{Z}_{\\ge 1} : s \\equiv 1 \\text{ or } 4 \\pmod{5}, s \\le N\\}$.\n2.  For $\\{P_2(n)\\}_{n=0}^N$, the set of parts is $S_2 = \\{s \\in \\mathbb{Z}_{\\ge 1} : s \\equiv 2 \\text{ or } 3 \\pmod{5}, s \\le N\\}$.\n\n**Complexity Analysis (Product-Side):** The algorithm involves an outer loop over the set of allowed part sizes, say $S_N = S \\cap \\{1, \\dots, N\\}$, and an inner loop that runs from $s$ to $N$. The number of part sizes in $S_1$ or $S_2$ up to $N$ is $|S_{i,N}| \\approx \\frac{2}{5}N$. The total number of operations is approximately $\\sum_{s \\in S_N} (N-s) \\approx \\int_0^N (N-x) \\frac{|S_N|}{N} dx$, which is proportional to $N^2$. Thus, the time complexity is $\\mathcal{O}(|S_N| \\cdot N)$, which is $\\mathcal{O}(N^2)$ for the given sets $S_1$ and $S_2$.\n\n**Algorithm 2: Sum-Side Coefficient Calculation**\n\nTo compute the coefficients $\\{A_1(n)\\}_{n=0}^N$ and $\\{A_2(n)\\}_{n=0}^N$, we must evaluate the sums $S_1^{\\text{sum}}(q) = \\sum_{m\\ge 0} \\frac{q^{m^2}}{(q;q)_m}$ and $S_2^{\\text{sum}}(q) = \\sum_{m\\ge 0} \\frac{q^{m(m+1)}}{(q;q)_m}$ up to degree $N$. The summation can be truncated at $m$ such that the exponent of $q$ in the numerator, $m^2$ or $m(m+1)$, exceeds $N$. This implies the sum runs up to $m \\approx \\sqrt{N}$.\n\nThe algorithm proceeds in two main stages:\n1.  **Compute coefficients of $D_m(q) = 1/(q;q)_m$**: We compute the coefficients for $D_m(q)$ incrementally. We start with $D_0(q)=1$, whose coefficient array is $[1, 0, \\dots]$. Then, for $m \\ge 1$, we use the relation $D_m(q) = D_{m-1}(q) \\cdot \\frac{1}{1-q^m}$. If $d_{k,n}$ is the coefficient of $q^n$ in $D_k(q)$, the coefficients $d_{m,n}$ can be computed from $d_{m-1,n}$ via the recurrence $d_{m,n} = d_{m-1,n} + d_{m,n-m}$. This is implemented as an in-place update on the coefficient array for each $m$.\n\n2.  **Sum the series terms**: We initialize the result arrays, $\\{A_1(n)\\}$, $\\{A_2(n)\\}$, to zeros. We loop $m$ from $0$ upwards. In each iteration $m$, we first compute the coefficient array for $D_m(q)$ as described above. Then, we add the contribution of the $m$-th term to the total sum:\n    - For $A_1$, we add the coefficients of $D_m(q)$ to the array $A_1$, shifted by an index of $m^2$. This corresponds to multiplying $D_m(q)$ by $q^{m^2}$.\n    - For $A_2$, we add the coefficients of $D_m(q)$ to the array $A_2$, shifted by an index of $m(m+1)$.\n    - The loop over $m$ terminates when $m^2 > N$, as no further terms can contribute to coefficients up to degree $N$.\n\n**Complexity Analysis (Sum-Side):** The main loop iterates $m$ from $1$ up to a maximum of $M \\approx \\sqrt{N}$. Inside the loop, updating the coefficient array for $D_m(q)$ takes $\\mathcal{O}(N)$ time. Adding the shifted coefficients to $A_1$ and $A_2$ also takes $\\mathcal{O}(N)$ time. Therefore, the total time complexity is $\\mathcal{O}(M \\cdot N) = \\mathcal{O}(N\\sqrt{N})$.\n\n**Verification**\nFor each test case $N$, after computing the four coefficient arrays $\\{P_1(n)\\}$, $\\{P_2(n)\\}$, $\\{A_1(n)\\}$, and $\\{A_2(n)\\}$ up to degree $N$, we perform a direct element-wise comparison. Two boolean values are produced: one for the equality $P_1(n) = A_1(n)$ for all $n \\in \\{0, \\dots, N\\}$, and one for $P_2(n) = A_2(n)$ for all $n \\in \\{0, \\dots, N\\}$. As the Rogers-Ramanujan identities are proven theorems, these equalities must hold.", "answer": "```python\nimport numpy as np\n\ndef compute_product_side(N):\n    \"\"\"\n    Computes coefficients for the product-side generating functions using dynamic programming.\n    This is equivalent to the unbounded coin change problem.\n    Time complexity: O(N^2)\n    \"\"\"\n    if N  0:\n        return [], []\n\n    # For P1: partitions with parts congruent to 1 or 4 (mod 5)\n    S1_parts = [s for s in range(1, N + 1) if s % 5 == 1 or s % 5 == 4]\n    P1 = [0] * (N + 1)\n    P1[0] = 1\n    for s in S1_parts:\n        for n in range(s, N + 1):\n            P1[n] += P1[n - s]\n\n    # For P2: partitions with parts congruent to 2 or 3 (mod 5)\n    S2_parts = [s for s in range(1, N + 1) if s % 5 == 2 or s % 5 == 3]\n    P2 = [0] * (N + 1)\n    P2[0] = 1\n    for s in S2_parts:\n        for n in range(s, N + 1):\n            P2[n] += P2[n - s]\n\n    return P1, P2\n\ndef compute_sum_side(N):\n    \"\"\"\n    Computes coefficients for the sum-side series using dynamic programming.\n    Time complexity: O(N*sqrt(N))\n    \"\"\"\n    if N  0:\n        return [], []\n    \n    A1 = [0] * (N + 1)\n    A2 = [0] * (N + 1)\n    \n    # The sums start from m=0. The term for m=0 is q^0/(q;q)_0 = 1 for both series.\n    if N >= 0:\n        A1[0] = 1\n        A2[0] = 1\n\n    # D_coeffs stores coefficients of 1/(q;q)_m.\n    # We initialize it for m=0, where 1/(q;q)_0 = 1.\n    D_coeffs = [0] * (N + 1)\n    D_coeffs[0] = 1\n    \n    m = 1\n    while True:\n        m_squared = m * m\n        # If m^2 > N, no higher-m terms can contribute to coefficients = N.\n        if m_squared > N:\n            break\n\n        # Update D_coeffs from representing 1/(q;q)_{m-1} to 1/(q;q)_m.\n        # This is done by multiplying by 1/(1-q^m), which corresponds to the\n        # recurrence d_m[n] = d_{m-1}[n] + d_m[n-m].\n        # The inner loop performs this update in-place.\n        if m = N:\n            for n in range(m, N + 1):\n                D_coeffs[n] += D_coeffs[n - m]\n        \n        # Now D_coeffs contains coefficients for 1/(q;q)_m.\n        \n        # Add contribution to A1: q^(m^2) * [1/(q;q)_m]\n        for n in range(m_squared, N + 1):\n            A1[n] += D_coeffs[n - m_squared]\n        \n        # Add contribution to A2: q^(m(m+1)) * [1/(q;q)_m]\n        m_m_p1 = m * (m + 1)\n        if m_m_p1 = N:\n            for n in range(m_m_p1, N + 1):\n                A2[n] += D_coeffs[n - m_m_p1]\n\n        m += 1\n            \n    return A1, A2\n\ndef solve():\n    \"\"\"\n    Main solver function to run verification for all test cases.\n    \"\"\"\n    test_cases = [0, 1, 12, 25, 60]\n\n    results = []\n    for N in test_cases:\n        # Compute coefficients using both methods\n        P1, P2 = compute_product_side(N)\n        A1, A2 = compute_sum_side(N)\n\n        # Verify that the resulting coefficient arrays are identical\n        # np.array_equal is efficient for this comparison.\n        b1 = np.array_equal(P1, A1)\n        b2 = np.array_equal(P2, A2)\n        \n        results.append([b1, b2])\n\n    # Format the final output as specified in the problem statement.\n    # Example: [[True,True],[True,True]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3093186"}]}