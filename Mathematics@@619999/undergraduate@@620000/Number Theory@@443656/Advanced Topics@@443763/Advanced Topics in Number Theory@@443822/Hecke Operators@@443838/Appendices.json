{"hands_on_practices": [{"introduction": "To truly understand Hecke operators, one must move beyond their abstract definition and see how they concretely act on modular forms. The most direct way to do this is by examining their effect on Fourier coefficients. This practice guides you through the fundamental process of deriving the coefficient-wise action of the Hecke operator $T_p$ from its definition on functions, providing a critical bridge between theory and computation. [@problem_id:3085846]", "problem": "Implement a program that computes the action of the Hecke operator at prime $2$ on truncated $q$-expansions of modular forms of integer weight $k \\ge 2$, derived from first principles, and verifies linearity. Work in the space of holomorphic modular forms on the full modular group. Begin from the core definition of the Hecke operator on weight $k$ modular forms,\n$$(T_n f)(z) \\;=\\; n^{k-1} \\sum_{ad = n} \\sum_{b \\,(\\mathrm{mod}\\, d)} d^{-k} \\, f\\!\\left(\\frac{a z + b}{d}\\right),$$\nwhich for prime $p$ specializes to\n$$(T_p f)(z) \\;=\\; p^{k-1} f(pz) \\;+\\; p^{-1} \\sum_{r=0}^{p-1} f\\!\\left(\\frac{z + r}{p}\\right).$$\nFrom this base, derive the explicit coefficient-wise action of $T_2$ on $q$-expansions. Let $q = e^{2 \\pi i z}$ and let $f(z)$ be given by a truncated $q$-expansion\n$$f(z) \\;=\\; \\sum_{n=0}^{10} a_n \\, q^n,$$\nwhere $a_n \\in \\mathbb{C}$ and the truncation means $a_n = 0$ for $n > 10$. Derive the formula for the $q$-expansion of $(T_2 f)(z)$ up to and including the $q^{10}$ term, expressed purely in terms of the given coefficients $(a_0,\\dots,a_{10})$ and the weight $k$. Your implementation must not assume any coefficient beyond $a_{10}$ is known, and must therefore treat any required $a_m$ with $m > 10$ as $0$. Use only the above definition and well-tested facts about exponential sums over roots of unity to derive the coefficient rule; do not rely on any pre-stated shortcut formula.\n\nThe program must implement this derived coefficient rule and also verify linearity of $T_2$, namely that for any scalars $\\alpha$ and $\\beta$ and any $f$ and $g$, one has\n$$T_2(\\alpha f + \\beta g) \\;=\\; \\alpha \\, T_2 f \\;+\\; \\beta \\, T_2 g,$$\ncoefficient-wise up to and including the $q^{10}$ term.\n\nTest Suite. Your program must carry out the following five test cases, each independent of the others. In all cases, compute or compare coefficients up to and including $q^{10}$.\n\n- Test $1$ (direct computation up to $q^{10}$): Let $k = 4$ and \n$f$ have coefficients $[a_0,\\dots,a_{10}] = [1,2,3,4,5,6,7,8,9,10,11]$. Output the list of coefficients $[c_0,\\dots,c_{10}]$ of $(T_2 f)(z)$.\n- Test $2$ (linearity, general case): Let $k = 6$, $f$ as in Test $1$, and $g$ have coefficients $[0,1,0,1,0,1,0,1,0,1,0]$. Let $\\alpha = 3$ and $\\beta = -2$. Output a boolean indicating whether $T_2(\\alpha f + \\beta g)$ equals $\\alpha T_2 f + \\beta T_2 g$ coefficient-wise up to $q^{10}$.\n- Test $3$ (constant form edge case): Let $k = 8$ and $f$ have coefficients $[5,0,0,0,0,0,0,0,0,0,0]$. Output the list of coefficients of $(T_2 f)(z)$.\n- Test $4$ (boundary handling where $2n > 10$): Let $k = 2$ and $f$ have coefficients $[1,1,1,1,1,1,1,1,1,1,1]$. Output the list of coefficients of $(T_2 f)(z)$.\n- Test $5$ (linearity, degenerate scalars): Let $k = 10$, $f$ have coefficients $[2,3,5,7,11,13,17,19,23,29,31]$, $g$ have coefficients $[1,0,1,0,1,0,1,0,1,0,1]$, and $\\alpha = 0$, $\\beta = 0$. Output a boolean indicating whether $T_2(\\alpha f + \\beta g) = \\alpha T_2 f + \\beta T_2 g$ coefficient-wise up to $q^{10}$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces anywhere. Each test case contributes exactly one element to this top-level list, in the order Tests $1$ through $5$. The element for a direct computation is the list of $11$ integers $[c_0,\\dots,c_{10}]$ and the element for a linearity check is a boolean. For example, the final output should look like\n$[[\\dots],\\mathrm{True},[\\dots],[\\dots],\\mathrm{False}]$\nwith no spaces. No physical units, angle units, or percentages are involved in this problem; all outputs are purely numeric or boolean as specified.", "solution": "Let the modular form be $f(z) = \\sum_{m=0}^{\\infty} a_m q^m$, where $q = e^{2\\pi i z}$. Let the resulting form be $(T_2 f)(z) = \\sum_{n=0}^{\\infty} c_n q^n$. We derive the formula for the coefficients $c_n$ from the given definition of the Hecke operator for a prime $p=2$:\n$$(T_2 f)(z) = 2^{k-1} f(2z) + \\frac{1}{2} \\sum_{r=0}^{1} f\\left(\\frac{z+r}{2}\\right)$$\n\nWe analyze each term's contribution to the final $q$-expansion.\n\n1.  **First term: $2^{k-1} f(2z)$**\n    Substituting $2z$ into the $q$-expansion of $f(z)$:\n    $$f(2z) = \\sum_{m=0}^{\\infty} a_m e^{2\\pi i m (2z)} = \\sum_{m=0}^{\\infty} a_m (e^{2\\pi i z})^{2m} = \\sum_{m=0}^{\\infty} a_m q^{2m}$$\n    The $q$-expansion of the first term is:\n    $$2^{k-1} f(2z) = 2^{k-1} \\sum_{m=0}^{\\infty} a_m q^{2m}$$\n    The coefficient of $q^n$ in this series is $2^{k-1}a_{n/2}$ if $n$ is even, and $0$ if $n$ is odd.\n\n2.  **Second term: $\\frac{1}{2} \\sum_{r=0}^{1} f\\left(\\frac{z+r}{2}\\right)$**\n    We expand this sum and substitute the series for $f(z)$:\n    $$\\frac{1}{2} \\left[ f\\left(\\frac{z}{2}\\right) + f\\left(\\frac{z+1}{2}\\right) \\right] = \\frac{1}{2} \\left[ \\sum_{m=0}^{\\infty} a_m e^{2\\pi i m (z/2)} + \\sum_{m=0}^{\\infty} a_m e^{2\\pi i m (z+1)/2} \\right]$$\n    Combining the sums and factoring:\n    $$= \\frac{1}{2} \\sum_{m=0}^{\\infty} a_m e^{\\pi i m z} (1 + e^{\\pi i m}) = \\frac{1}{2} \\sum_{m=0}^{\\infty} a_m q^{m/2} (1 + (-1)^m)$$\n    The term $(1 + (-1)^m)$ is $2$ if $m$ is even, and $0$ if $m$ is odd. The sum therefore only includes terms where $m$ is even. Let $m=2n$:\n    $$= \\frac{1}{2} \\sum_{n=0}^{\\infty} a_{2n} q^{(2n)/2} (1 + (-1)^{2n}) = \\frac{1}{2} \\sum_{n=0}^{\\infty} a_{2n} q^{n} (2) = \\sum_{n=0}^{\\infty} a_{2n} q^n$$\n    The coefficient of $q^n$ in this series is simply $a_{2n}$.\n\n3.  **Combining the terms to find $c_n$**\n    The total coefficient $c_n$ is the sum of the coefficients of $q^n$ from both parts:\n    $$c_n = (\\text{coeff of } q^n \\text{ from part 2}) + (\\text{coeff of } q^n \\text{ from part 1})$$\n    $$c_n = a_{2n} + \\begin{cases} 2^{k-1} a_{n/2} & \\text{if } n \\text{ is even} \\\\ 0 & \\text{if } n \\text{ is odd} \\end{cases}$$\n    This is the well-known formula for the action of $T_2$ on Fourier coefficients.\n\n4.  **Algorithm for truncated series**\n    Given that $f(z) = \\sum_{n=0}^{10} a_n q^n$, we treat $a_m = 0$ for $m > 10$. The coefficients $c_n$ for $n \\in \\{0, \\dots, 10\\}$ are computed as follows:\n    -   $c_0 = a_0 + 2^{k-1} a_0 = (1+2^{k-1})a_0$\n    -   $c_1 = a_2$\n    -   $c_2 = a_4 + 2^{k-1} a_1$\n    -   $c_3 = a_6$\n    -   $c_4 = a_8 + 2^{k-1} a_2$\n    -   $c_5 = a_{10}$\n    -   $c_6 = a_{12} + 2^{k-1} a_3 = 0 + 2^{k-1} a_3 = 2^{k-1} a_3$\n    -   $c_7 = a_{14} = 0$\n    -   $c_8 = a_{16} + 2^{k-1} a_4 = 0 + 2^{k-1} a_4 = 2^{k-1} a_4$\n    -   $c_9 = a_{18} = 0$\n    -   $c_{10} = a_{20} + 2^{k-1} a_5 = 0 + 2^{k-1} a_5 = 2^{k-1} a_5$\n\nThe program implements this logic. Linearity is verified by computing $T_2(\\alpha f + \\beta g)$ and $\\alpha T_2 f + \\beta T_2 g$ separately and comparing the resulting coefficient vectors. The formula for $c_n$ is linear in the coefficients $a_m$, so the operator $T_2$ is linear. This will be verified numerically by the program.", "answer": "```python\nimport numpy as np\n\ndef apply_T2(coeffs_a, k):\n    \"\"\"\n    Computes the action of the Hecke operator T_2 on a truncated q-expansion.\n\n    Args:\n        coeffs_a (np.ndarray): An array of 11 coefficients [a_0, ..., a_10].\n        k (int): The integer weight of the modular form, k >= 2.\n\n    Returns:\n        np.ndarray: An array of 11 coefficients for (T_2 f)(z).\n    \"\"\"\n    coeffs_c = np.zeros(11, dtype=np.int64)\n    p = 2\n    \n    # Pre-calculate a term that is used repeatedly\n    pk_minus_1 = p**(k - 1)\n\n    for n in range(11):\n        # Term a_{2n}\n        a_2n = 0\n        if 2 * n = 10:\n            a_2n = coeffs_a[2 * n]\n\n        # Term p^{k-1} * a_{n/p}\n        a_n_div_p = 0\n        if n % p == 0:\n            # For p=2, this means n is even\n            a_n_div_p = pk_minus_1 * coeffs_a[n // p]\n        \n        coeffs_c[n] = a_2n + a_n_div_p\n\n    return coeffs_c\n\ndef solve():\n    \"\"\"\n    Runs the five test cases specified in the problem statement and formats the output.\n    \"\"\"\n    results = []\n\n    # Test 1: Direct computation\n    k1 = 4\n    a1 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], dtype=np.int64)\n    c1 = apply_T2(a1, k1)\n    results.append(c1.tolist())\n\n    # Test 2: Linearity check, general case\n    k2 = 6\n    f_coeffs2 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], dtype=np.int64)\n    g_coeffs2 = np.array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], dtype=np.int64)\n    alpha2, beta2 = 3, -2\n    \n    lhs_coeffs = apply_T2(alpha2 * f_coeffs2 + beta2 * g_coeffs2, k2)\n    rhs_coeffs = alpha2 * apply_T2(f_coeffs2, k2) + beta2 * apply_T2(g_coeffs2, k2)\n    is_linear2 = np.array_equal(lhs_coeffs, rhs_coeffs)\n    results.append(is_linear2)\n    \n    # Test 3: Constant form edge case\n    k3 = 8\n    a3 = np.array([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.int64)\n    c3 = apply_T2(a3, k3)\n    results.append(c3.tolist())\n\n    # Test 4: Boundary handling\n    k4 = 2\n    a4 = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=np.int64)\n    c4 = apply_T2(a4, k4)\n    results.append(c4.tolist())\n\n    # Test 5: Linearity check, degenerate scalars\n    k5 = 10\n    f_coeffs5 = np.array([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31], dtype=np.int64)\n    g_coeffs5 = np.array([1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], dtype=np.int64)\n    alpha5, beta5 = 0, 0\n\n    lhs_coeffs5 = apply_T2(alpha5 * f_coeffs5 + beta5 * g_coeffs5, k5)\n    rhs_coeffs5 = alpha5 * apply_T2(f_coeffs5, k5) + beta5 * apply_T2(g_coeffs5, k5)\n    is_linear5 = np.array_equal(lhs_coeffs5, rhs_coeffs5)\n    results.append(is_linear5)\n    \n    # Format the final output string according to the problem specification (no spaces).\n    # Expected output: [[9,3,21,7,33,11,32,0,40,0,48],True,[645,0,0,0,0,0,0,0,0,0,0],[3,1,3,1,3,1,2,0,2,0,2],True]\n    formatted_results = []\n    for res in results:\n        if isinstance(res, list):\n            formatted_results.append(f\"[{','.join(map(str, res))}]\")\n        elif isinstance(res, np.bool_):\n            formatted_results.append(str(bool(res)))\n        else:\n            formatted_results.append(str(res))\n            \n    print(f\"[{','.join(formatted_results)}]\")\n\n# solve() # This function is defined but not called to prevent output generation in this context.\n# Expected output from calling solve():\n# [[9,3,21,7,33,11,32,0,40,0,48],True,[645,0,0,0,0,0,0,0,0,0,0],[3,1,3,1,3,1,2,0,2,0,2],True]\n```", "id": "3085846"}, {"introduction": "A central concept in the theory of modular forms is that of a Hecke eigenform—a form that is simply scaled by a number when acted upon by a Hecke operator. With the computational rule for the action of $T_p$ on Fourier coefficients in hand, we can now test this property on a canonical example. This exercise asks you to apply the formula to the famous Ramanujan $\\Delta$ function to explicitly verify that it is an eigenform of $T_2$ and to compute the corresponding eigenvalue. [@problem_id:3085786]", "problem": "Let $k$ be a positive integer and let $S_{k}(\\mathrm{SL}_{2}(\\mathbb{Z}))$ denote the space of cusp forms of weight $k$ for the full modular group $\\mathrm{SL}_{2}(\\mathbb{Z})$. The Ramanujan cusp form $\\Delta$ is the unique normalized cusp form of weight $12$ on $\\mathrm{SL}_{2}(\\mathbb{Z})$, characterized by its Fourier expansion\n$$\n\\Delta(z) \\;=\\; q \\prod_{n=1}^{\\infty} (1 - q^{n})^{24} \\;=\\; \\sum_{n=1}^{\\infty} \\tau(n)\\, q^{n}, \\quad q \\;=\\; \\exp(2\\pi i z),\n$$\nwhere $\\tau(n)$ is the Ramanujan tau function. The Hecke operator $T_{p}$ at a prime $p$ acting on $S_{k}(\\mathrm{SL}_{2}(\\mathbb{Z}))$ is defined by the double-coset action, and for level $1$ it can be represented on functions $f \\in S_{k}(\\mathrm{SL}_{2}(\\mathbb{Z}))$ as\n$$\n(T_{p} f)(z) \\;=\\; p^{k-1} f(pz) \\;+\\; \\frac{1}{p} \\sum_{a=0}^{p-1} f\\!\\left(\\frac{z+a}{p}\\right).\n$$\nStarting from this definition, derive the action of $T_{p}$ on the Fourier coefficients when $f(z) = \\sum_{n \\geq 1} a_{n}\\, q^{n}$, specialize to $p=2$ and $k=12$, and compute the first six coefficients of $T_{2}\\Delta$, that is, the coefficients of $q$, $q^{2}$, $q^{3}$, $q^{4}$, $q^{5}$, and $q^{6}$. Use only well-established facts about $\\Delta$, namely:\n- $\\tau(1) = 1$, $\\tau(2) = -24$, $\\tau(3) = 252$, and $\\tau(5) = 4830$,\n- multiplicativity for coprime arguments, $\\tau(mn) = \\tau(m)\\tau(n)$ if $\\gcd(m,n) = 1$,\n- the prime-power Hecke recurrence, $\\tau(p^{r+1}) = \\tau(p)\\tau(p^{r}) - p^{11}\\tau(p^{r-1})$ for any prime $p$ and integer $r \\geq 1$.\n\nConfirm that the resulting series equals $\\tau(2)\\Delta$ by matching these coefficients. As your final reported value, provide the coefficient of $q^{6}$ in $T_{2}\\Delta$. No rounding is required.", "solution": "Let $f(z) = \\sum_{n=1}^{\\infty} a_n q^n$ be a cusp form of weight $k$ and let $T_p f = \\sum_{n=1}^\\infty c_n q^n$.\nThe action of $T_p$ on the Fourier coefficients is given by the formula $c_n = a_{pn} + p^{k-1} a_{n/p}$, with the convention that $a_{x}=0$ if $x$ is not an integer.\nFor this problem, $f = \\Delta$, $a_n = \\tau(n)$, $k=12$, and $p=2$.\nThe formula for the coefficients $c_n$ of $T_2 \\Delta$ is:\n$$c_n = \\tau(2n) + 2^{11}\\tau(n/2)$$\n\nWe need to compute $c_n$ for $n=1, \\dots, 6$. To do this, we first need the values of $\\tau(m)$ for $m$ up to 12. We are given $\\tau(1), \\tau(2), \\tau(3), \\tau(5)$.\nWe compute the others using the given properties:\n-   $\\tau(4) = \\tau(2^2) = \\tau(2)\\tau(2^1) - 2^{11}\\tau(2^0) = \\tau(2)^2 - 2048\\tau(1) = (-24)^2 - 2048(1) = 576 - 2048 = -1472$.\n-   $\\tau(6) = \\tau(2)\\tau(3) = (-24)(252) = -6048$.\n-   $\\tau(7)$: Not needed for this problem.\n-   $\\tau(8) = \\tau(2^3) = \\tau(2)\\tau(2^2) - 2^{11}\\tau(2^1) = \\tau(2)\\tau(4) - 2048\\tau(2) = (-24)(-1472) - 2048(-24) = 35328 + 49152 = 84480$.\n-   $\\tau(9) = \\tau(3^2) = \\tau(3)^2 - 3^{11}\\tau(1) = (252)^2 - 177147(1) = 63504 - 177147 = -113643$.\n-   $\\tau(10) = \\tau(2)\\tau(5) = (-24)(4830) = -115920$.\n-   $\\tau(12) = \\tau(3 \\cdot 4) = \\tau(3)\\tau(4) = (252)(-1472) = -370944$.\n\nNow we compute the coefficients $c_n$ of $T_2\\Delta$:\n-   $c_1 = \\tau(2 \\cdot 1) + 2^{11}\\tau(1/2) = \\tau(2) + 0 = -24$.\n-   $c_2 = \\tau(2 \\cdot 2) + 2^{11}\\tau(2/2) = \\tau(4) + 2048\\tau(1) = -1472 + 2048(1) = 576$.\n-   $c_3 = \\tau(2 \\cdot 3) + 2^{11}\\tau(3/2) = \\tau(6) + 0 = -6048$.\n-   $c_4 = \\tau(2 \\cdot 4) + 2^{11}\\tau(4/2) = \\tau(8) + 2048\\tau(2) = 84480 + 2048(-24) = 84480 - 49152 = 35328$.\n-   $c_5 = \\tau(2 \\cdot 5) + 2^{11}\\tau(5/2) = \\tau(10) + 0 = -115920$.\n-   $c_6 = \\tau(2 \\cdot 6) + 2^{11}\\tau(6/2) = \\tau(12) + 2048\\tau(3) = -370944 + 2048(252) = -370944 + 516096 = 145152$.\n\nThe coefficients of $T_2\\Delta$ are $[-24, 576, -6048, 35328, -115920, 145152, \\dots]$.\nTo confirm this is $\\tau(2)\\Delta$, we compute the first six coefficients of $\\tau(2)\\Delta$, which are $\\tau(2)\\tau(n)$ for $n=1,\\dots,6$:\n-   $\\tau(2)\\tau(1) = (-24)(1) = -24$. (Matches $c_1$)\n-   $\\tau(2)\\tau(2) = (-24)(-24) = 576$. (Matches $c_2$)\n-   $\\tau(2)\\tau(3) = (-24)(252) = -6048$. (Matches $c_3$)\n-   $\\tau(2)\\tau(4) = (-24)(-1472) = 35328$. (Matches $c_4$)\n-   $\\tau(2)\\tau(5) = (-24)(4830) = -115920$. (Matches $c_5$)\n-   $\\tau(2)\\tau(6) = (-24)(-6048) = 145152$. (Matches $c_6$)\n\nThe coefficients match, confirming that $\\Delta$ is an eigenform of $T_2$ with eigenvalue $\\tau(2)$.\nThe final requested value is the coefficient of $q^6$ in $T_2\\Delta$, which is $c_6$.\n$c_6 = 145152$.", "answer": "$$ \\boxed{145152} $$", "id": "3085786"}, {"introduction": "The properties of Hecke eigenvalues—which for a normalized eigenform are its Fourier coefficients—lead to powerful algorithmic applications. A fundamental question is how one can determine if two eigenforms are identical, given that we can only ever compute a finite number of their coefficients. This practice introduces the Sturm bound, a deep theorem that astonishingly reduces this infinite problem to a finite check, showcasing the practical power of the theory you have learned. [@problem_id:3085771]", "problem": "Design and implement a program that, given pairs of normalized Hecke eigenforms in the space of cusp forms of weight $k$ on the congruence subgroup $\\Gamma_0(N)$, decides whether each pair shares all Hecke eigenvalues by checking only finitely many Hecke operators $T_n$. The decision must be justified by a principle-based algorithm derived from first definitions and the Sturm bound.\n\nDefinitions and fundamental facts available for use:\n- A modular form of weight $k$ and level $N$ has a Fourier expansion $f(z) = \\sum_{n \\ge 0} a_n q^n$ with $q = e^{2\\pi i z}$, and a cusp form has $a_0 = 0$. The space of cusp forms is denoted $S_k(\\Gamma_0(N))$.\n- For normalized Hecke eigenforms $f \\in S_k(\\Gamma_0(N))$, the action of the Hecke operator $T_n$ satisfies $T_n f = a_n f$ for all $n \\ge 1$, where $a_n$ is the $n$-th Fourier coefficient and normalization means $a_1 = 1$.\n- The Hecke algebra for level $N$ is generated by $T_n$ for $n \\ge 1$ (at primes $p \\mid N$ one often writes $U_p$, but its eigenvalue on a normalized eigenform is still the Fourier coefficient $a_p$).\n- Sturm bound: If $f, g \\in M_k(\\Gamma_0(N))$ are modular forms of the same weight and level with Fourier coefficients $a_n$ and $b_n$, respectively, and if $a_n = b_n$ for all $1 \\le n \\le B$, where\n$$\nB \\;=\\; \\left\\lfloor \\frac{k}{12} \\cdot \\left[ \\mathrm{SL}_2(\\mathbb{Z}) : \\Gamma_0(N) \\right] \\right\\rfloor,\n$$\nthen $f = g$. The index satisfies\n$$\n\\left[ \\mathrm{SL}_2(\\mathbb{Z}) : \\Gamma_0(N) \\right] \\;=\\; N \\prod_{p \\mid N} \\left(1 + \\frac{1}{p}\\right),\n$$\nwhere the product runs over the distinct prime divisors $p$ of $N$.\n\nTask:\n- Using only the above principles, derive an algorithm that decides whether two given normalized Hecke eigenforms in $S_k(\\Gamma_0(N))$ share all Hecke eigenvalues by checking finitely many $T_n$. Your algorithm must reduce the infinite verification problem to a finite check using the Sturm bound and the relationship between $T_n$-eigenvalues and $q$-expansion coefficients.\n- Implement this algorithm in a program. The program must be self-contained with no external input: it must carry an internal test suite of pairs of normalized eigenforms represented by their initial $q$-expansion coefficients, along with their corresponding levels $N$ and weights $k$, and output the decision for each case.\n\nTest suite:\nProvide the following four test cases inside your program. Each test case is a tuple consisting of $(N, k, \\text{coeffs}_f, \\text{coeffs}_g)$, where $\\text{coeffs}_f$ and $\\text{coeffs}_g$ are lists of the first several Fourier coefficients $(a_1, a_2, \\dots, a_L)$ and $(b_1, b_2, \\dots, b_L)$ of two normalized Hecke eigenforms $f$ and $g$ in $S_k(\\Gamma_0(N))$:\n1. $(N, k) = (\\,11,\\, 2\\,)$ with\n   $\\text{coeffs}_f = [\\,1,\\,-1,\\,-1,\\,1,\\,0,\\,-1,\\,1,\\,0,\\,-1,\\,1,\\,0,\\,-1\\,]$ and\n   $\\text{coeffs}_g = [\\,1,\\,-1,\\,-1,\\,1,\\,0,\\,-1,\\,1,\\,0,\\,-1,\\,1,\\,0,\\,-1\\,]$.\n2. $(N, k) = (\\,6,\\, 4\\,)$ with\n   $\\text{coeffs}_f = [\\,1,\\,0,\\,-2,\\,3,\\,0,\\,-1\\,]$ and\n   $\\text{coeffs}_g = [\\,1,\\,0,\\,5,\\,3,\\,0,\\,-1\\,]$.\n3. $(N, k) = (\\,6,\\, 2\\,)$ with\n   $\\text{coeffs}_f = [\\,1,\\,-1,\\,2,\\,0\\,]$ and\n   $\\text{coeffs}_g = [\\,1,\\,2,\\,2,\\,0\\,]$.\n4. $(N, k) = (\\,15,\\, 6\\,)$ with\n   $\\text{coeffs}_f = [\\,1,\\,1,\\,-1,\\,0,\\,2,\\,-2,\\,1,\\,0,\\,-1,\\,3,\\,-2,\\,0\\,]$ and\n   $\\textcoeffs}_g = [\\,1,\\,1,\\,-1,\\,0,\\,2,\\,-2,\\,1,\\,0,\\,-1,\\,3,\\,-2,\\,0\\,]$.\n\nAssumptions:\n- Each list $\\text{coeffs}_f$ and $\\text{coeffs}_g$ contains at least $B$ terms for its $(N, k)$, so the Sturm bound check is well-posed.\n- All forms are normalized Hecke eigenforms, so their $T_n$-eigenvalues equal their Fourier coefficients $a_n$ for all $n \\ge 1$ and satisfy $a_1 = 1$.\n\nRequired output:\n- For each test case, your program must output a boolean indicating whether the two forms share all Hecke eigenvalues, as certified by the Sturm-bound-based finite check.\n- Your program should produce a single line of output containing the results for the four test cases as a comma-separated list of booleans enclosed in square brackets, for example, \"[True,False,True,False]\". No spaces are permitted in the output.", "solution": "The objective is to determine if two normalized Hecke eigenforms, $f(z) = \\sum_{n=1}^\\infty a_n q^n$ and $g(z) = \\sum_{n=1}^\\infty b_n q^n$, both in the space of cusp forms $S_k(\\Gamma_0(N))$, are identical.\n\n1.  **Relating Hecke Eigenvalues to Fourier Coefficients**: The problem states that for a normalized Hecke eigenform, its eigenvalue under the Hecke operator $T_n$ is precisely its $n$-th Fourier coefficient. For $f$, the eigenvalues are the set $\\{a_n\\}_{n \\ge 1}$, and for $g$, they are $\\{b_n\\}_{n \\ge 1}$. Therefore, the two forms share all Hecke eigenvalues if and only if their Fourier coefficients are identical for all $n \\ge 1$, i.e., $a_n = b_n$ for all $n \\ge 1$.\n\n2.  **Equivalence of Forms**: If $a_n = b_n$ for all $n \\ge 1$, then their Fourier series are identical. This implies that the forms themselves are identical, $f = g$. Conversely, if $f = g$, their Fourier expansions must be the same, so $a_n = b_n$ for all $n \\ge 1$. The problem of checking if two forms share all Hecke eigenvalues is therefore equivalent to determining if the forms themselves are identical.\n\n3.  **Reducing an Infinite Check to a Finite One**: Checking if $a_n = b_n$ for all infinitely many integers $n$ is computationally impossible. The Sturm bound provides a remarkable solution to this problem. It states that for any two modular forms in the same space $M_k(\\Gamma_0(N))$ (which includes $S_k(\\Gamma_0(N))$), if their Fourier coefficients agree up to a specific, computable finite bound, then the forms must be identical.\n\n4.  **The Algorithm**: Based on these principles, the algorithm is as follows:\n    a.  For a given level $N$ and weight $k$, we first compute the Sturm bound $B$. This requires calculating the index $\\mu_N = \\left[ \\mathrm{SL}_2(\\mathbb{Z}) : \\Gamma_0(N) \\right]$.\n    b.  The index is calculated using the formula:\n       $$ \\mu_N = N \\prod_{p \\mid N} \\left(1 + \\frac{1}{p}\\right) $$\n       where the product is over the distinct prime divisors of $N$. This can be computed by finding the distinct prime factors of $N$ and then applying the formula.\n    c.  Once the index $\\mu_N$ is known, the Sturm bound $B$ is calculated as the floor of a quantity:\n       $$ B = \\left\\lfloor \\frac{k \\cdot \\mu_N}{12} \\right\\rfloor $$\n    d.  Next, we compare the given Fourier coefficients $a_n$ and $b_n$ for all integers $n$ from $1$ up to the computed bound $B$.\n    e.  If $a_n = b_n$ for all $n \\in \\{1, 2, \\dots, B\\}$, the Sturm bound theorem guarantees that $f = g$. As established in step 2, this means they share all Hecke eigenvalues. The algorithm returns `True`.\n    f.  If we find any integer $n_0 \\in \\{1, 2, \\dots, B\\}$ for which $a_{n_0} \\neq b_{n_0}$, then the forms $f$ and $g$ are distinct. This means they do not share all their Hecke eigenvalues, and the algorithm returns `False`.\n\nThis algorithm provides a definitive answer by performing a finite number of comparisons, directly implementing the principles given in the problem statement.", "answer": "```python\nimport numpy as np\n\ndef get_distinct_prime_factors(n):\n    \"\"\"\n    Computes the set of distinct prime factors of an integer n.\n    \"\"\"\n    factors = set()\n    d = 2\n    temp_n = n\n    while d * d = temp_n:\n        if temp_n % d == 0:\n            factors.add(d)\n            while temp_n % d == 0:\n                temp_n //= d\n        d += 1\n    if temp_n > 1:\n        factors.add(temp_n)\n    return factors\n\ndef are_hecke_eigenforms_identical(N, k, coeffs_f, coeffs_g):\n    \"\"\"\n    Determines if two normalized Hecke eigenforms are identical using the Sturm bound.\n\n    Args:\n        N (int): The level of the congruence subgroup Gamma_0(N).\n        k (int): The weight of the modular forms.\n        coeffs_f (list): The first Fourier coefficients of form f.\n        coeffs_g (list): The first Fourier coefficients of form g.\n\n    Returns:\n        bool: True if the forms are identical, False otherwise.\n    \"\"\"\n    # Step 1: Calculate the index [SL_2(Z) : Gamma_0(N)].\n    # The index is given by N * product_{p|N} (1 + 1/p).\n    # We use integer arithmetic to avoid floating point issues.\n    if N == 1:\n        index = 1\n    else:\n        prime_factors = get_distinct_prime_factors(N)\n        index = N\n        for p in prime_factors:\n            index = index * (p + 1) // p\n    \n    # Step 2: Calculate the Sturm bound B.\n    # B = floor(k/12 * index)\n    sturm_bound = (k * index) // 12\n    \n    # Step 3: Compare Fourier coefficients up to the Sturm bound.\n    # The problem assumes that the coefficient lists are long enough.\n    # We check coefficients a_n for n from 1 to B.\n    # In the 0-indexed list, this corresponds to indices 0 to B-1.\n    for i in range(sturm_bound):\n        if coeffs_f[i] != coeffs_g[i]:\n            return False # A mismatch implies the forms are different.\n            \n    # If all coefficients up to the bound match, the forms are identical.\n    return True\n\ndef solve():\n    \"\"\"\n    Solves the problem of determining if pairs of Hecke eigenforms are identical\n    by applying the Sturm bound.\n    \"\"\"\n    # Test suite as specified in the problem statement.\n    # Each case is a tuple: (N, k, coeffs_f, coeffs_g)\n    # coeffs are 1-indexed Fourier coefficients a_n, stored in 0-indexed lists.\n    test_cases = [\n        (11, 2, \n         [1, -1, -1, 1, 0, -1, 1, 0, -1, 1, 0, -1], \n         [1, -1, -1, 1, 0, -1, 1, 0, -1, 1, 0, -1]),\n        (6, 4, \n         [1, 0, -2, 3, 0, -1], \n         [1, 0, 5, 3, 0, -1]),\n        (6, 2, \n         [1, -1, 2, 0], \n         [1, 2, 2, 0]),\n        (15, 6, \n         [1, 1, -1, 0, 2, -2, 1, 0, -1, 3, -2, 0], \n         [1, 1, -1, 0, 2, -2, 1, 0, -1, 3, -2, 0])\n    ]\n\n    results = []\n    for N, k, coeffs_f, coeffs_g in test_cases:\n        decision = are_hecke_eigenforms_identical(N, k, coeffs_f, coeffs_g)\n        results.append(str(decision).lower().capitalize())\n\n    # Format the final output as a single-line string.\n    print(f\"[{','.join(results)}]\")\n\n# solve() # This function is defined but not called to prevent output generation in this context.\n# Expected output from calling solve():\n# [True,False,False,True]\n```", "id": "3085771"}]}