{"hands_on_practices": [{"introduction": "The proofs of Mertens' theorems, like much of analytic number theory, rely on replacing complex expressions with more tractable approximations and carefully bounding the resulting errors. This first practice focuses on the fundamental building block of Mertens' third theorem: the term $\\log(1 - 1/p)$. By using a Taylor series expansion, this exercise [@problem_id:3087063] challenges you to find the best possible constant $C$ in the error bound $|\\log(1 - 1/p) + 1/p| \\le C/p^2$, a crucial skill for making analytical arguments rigorous.", "problem": "In the study of products over prime numbers arising in Mertens' theorems, one frequently approximates the natural logarithm of factors of the form $1 - \\frac{1}{p}$, where $p$ is prime, by its first-order term. Let $p$ be any integer with $p \\geq 2$, and define the truncation error\n$$\nE(p) := \\log\\!\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p}.\n$$\nStarting only from the fundamental fact that the natural logarithm admits a convergent power series expansion around zero for inputs of absolute value less than one, and using basic properties of series with positive terms, derive a uniform bound of the form $|E(p)| \\leq \\frac{C}{p^{2}}$ that is valid for all integers $p \\geq 2$. Determine, in exact closed form, the smallest constant $C$ for which this inequality holds uniformly in $p$. Your final answer must be this exact minimal constant $C$ as a single analytic expression.", "solution": "The problem is to determine the smallest constant $C$ such that the inequality $|E(p)| \\leq \\frac{C}{p^{2}}$ holds for all integers $p \\geq 2$, where the error term $E(p)$ is defined as\n$$\nE(p) := \\log\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p}.\n$$\nThe derivation must start from the power series expansion of the natural logarithm.\n\nThe Maclaurin series for $\\log(1-x)$ is given by\n$$\n\\log(1-x) = -\\sum_{k=1}^{\\infty} \\frac{x^{k}}{k} = -x - \\frac{x^{2}}{2} - \\frac{x^{3}}{3} - \\dots\n$$\nThis series converges for $|x| < 1$.\n\nWe are interested in the case where $p$ is an integer such that $p \\geq 2$. Let us set $x = \\frac{1}{p}$. For $p \\geq 2$, we have $0 < \\frac{1}{p} \\leq \\frac{1}{2}$, so the condition $|x| < 1$ is satisfied, and the series expansion is valid. Substituting $x = \\frac{1}{p}$ into the series gives:\n$$\n\\log\\left(1 - \\frac{1}{p}\\right) = -\\sum_{k=1}^{\\infty} \\frac{1}{k p^{k}} = -\\frac{1}{p} - \\frac{1}{2p^{2}} - \\frac{1}{3p^{3}} - \\dots\n$$\nNow, we substitute this expression into the definition of $E(p)$:\n$$\nE(p) = \\left(-\\sum_{k=1}^{\\infty} \\frac{1}{k p^{k}}\\right) + \\frac{1}{p}\n$$\nWe can separate the first term of the sum:\n$$\nE(p) = \\left(-\\frac{1}{p} - \\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}}\\right) + \\frac{1}{p}\n$$\nThe terms $\\frac{1}{p}$ cancel out, leaving:\n$$\nE(p) = -\\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}} = -\\left(\\frac{1}{2p^{2}} + \\frac{1}{3p^{3}} + \\frac{1}{4p^{4}} + \\dots\\right)\n$$\nWe are looking for the smallest constant $C$ such that $|E(p)| \\leq \\frac{C}{p^{2}}$ for all integers $p \\geq 2$.\nFirst, let's find the expression for $|E(p)|$. Since $p \\geq 2$, every term in the series $\\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}}$ is positive. Therefore,\n$$\n|E(p)| = \\left|-\\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}}\\right| = \\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}}\n$$\nThe inequality we must satisfy is:\n$$\n\\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}} \\leq \\frac{C}{p^{2}}\n$$\nTo find the smallest $C$ that holds for all integers $p \\geq 2$, we should analyze the expression $p^{2}|E(p)|$. Let $f(p) = p^{2}|E(p)|$. We seek $C = \\sup_{p \\geq 2, p \\in \\mathbb{Z}} f(p)$.\n$$\nf(p) = p^{2} \\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}} = \\sum_{k=2}^{\\infty} \\frac{p^{2}}{k p^{k}} = \\sum_{k=2}^{\\infty} \\frac{1}{k p^{k-2}}\n$$\nLet's write out the first few terms of the series for $f(p)$:\n$$\nf(p) = \\frac{1}{2p^{2-2}} + \\frac{1}{3p^{3-2}} + \\frac{1}{4p^{4-2}} + \\dots = \\frac{1}{2} + \\frac{1}{3p} + \\frac{1}{4p^{2}} + \\frac{1}{5p^{3}} + \\dots\n$$\nEach term in this series, $\\frac{1}{k p^{k-2}}$ for $k \\geq 3$, is a positive and strictly decreasing function of $p$ for $p>0$. The first term, $\\frac{1}{2}$, is constant. Therefore, their sum, $f(p)$, is a strictly decreasing function of $p$ for $p > 0$.\nThe supremum of $f(p)$ over the set of integers $p \\geq 2$ must occur at the smallest integer in this set, which is $p=2$.\nSo, the smallest constant $C$ is given by the value of $f(2)$:\n$$\nC = f(2) = \\sum_{k=2}^{\\infty} \\frac{1}{k 2^{k-2}}\n$$\nTo evaluate this series, we can factor out a constant to make it resemble a known series:\n$$\nC = \\frac{1}{2 \\cdot 2^{0}} + \\frac{1}{3 \\cdot 2^{1}} + \\frac{1}{4 \\cdot 2^{2}} + \\dots = \\sum_{k=2}^{\\infty} \\frac{4}{k 2^{k}} = 4 \\sum_{k=2}^{\\infty} \\frac{(1/2)^{k}}{k}\n$$\nWe recall the Maclaurin series for $-\\log(1-x)$:\n$$\n-\\log(1-x) = \\sum_{k=1}^{\\infty} \\frac{x^{k}}{k}\n$$\nSetting $x = \\frac{1}{2}$, we obtain:\n$$\n-\\log\\left(1-\\frac{1}{2}\\right) = -\\log\\left(\\frac{1}{2}\\right) = \\log(2) = \\sum_{k=1}^{\\infty} \\frac{(1/2)^{k}}{k}\n$$\nWe can split the sum:\n$$\n\\log(2) = \\frac{(1/2)^{1}}{1} + \\sum_{k=2}^{\\infty} \\frac{(1/2)^{k}}{k} = \\frac{1}{2} + \\sum_{k=2}^{\\infty} \\frac{(1/2)^{k}}{k}\n$$\nFrom this, we can isolate the series we need to evaluate:\n$$\n\\sum_{k=2}^{\\infty} \\frac{(1/2)^{k}}{k} = \\log(2) - \\frac{1}{2}\n$$\nFinally, we substitute this result back into our expression for $C$:\n$$\nC = 4 \\left( \\log(2) - \\frac{1}{2} \\right) = 4\\log(2) - 2\n$$\nThis is the exact minimal constant $C$ for which the inequality $|E(p)| \\leq \\frac{C}{p^{2}}$ holds for all integers $p \\geq 2$.", "answer": "$$\\boxed{4\\log(2) - 2}$$", "id": "3087063"}, {"introduction": "After mastering the local approximation for each prime, we can assemble these pieces to understand the global behavior of the full product over primes. This exercise [@problem_id:3017428] guides you through a derivation of Mertens' third theorem from first principles, showing how summing the local terms reveals a deep connection to the Riemann zeta function and the Euler-Mascheroni constant, $\\gamma$. Performing this derivation solidifies the theoretical underpinnings of the theorem and demonstrates how changing the product's upper limit predictably rescales the asymptotic result.", "problem": "Let $\\alpha>0$ be fixed. Consider the partial Euler product over primes\n$$\nP(y)\\;=\\;\\prod_{p\\le y}\\left(1-\\frac{1}{p}\\right),\n$$\nand define the Euler–Mascheroni constant $\\gamma$ by\n$$\n\\gamma\\;=\\;\\lim_{n\\to\\infty}\\left(\\sum_{k=1}^{n}\\frac{1}{k}-\\log n\\right).\n$$\nStarting from first principles relevant to Mertens' theorems—namely, the Euler product for the Riemann zeta function $\\zeta(s)$, the Laurent expansion of $\\zeta(s)$ at $s=1$, and the absolutely convergent expansions of logarithms of Euler factors—derive the leading asymptotic behavior of $P(x^{\\alpha})$ as $x\\to\\infty$. Your derivation should explicitly exhibit how the cutoff $y=x^{\\alpha}$ rescales the leading term and should identify the persistent appearance of $\\exp(-\\gamma)$ in the constant factor. Provide the final leading asymptotic term for $P(x^{\\alpha})$ as a single closed-form expression in $x$ and $\\alpha$. Do not provide intermediate inequalities or estimates in the final answer; only the leading expression is required.", "solution": "The user wants to find the leading asymptotic behavior of the partial Euler product $P(x^{\\alpha}) = \\prod_{p\\le x^{\\alpha}}\\left(1-\\frac{1}{p}\\right)$ as $x\\to\\infty$. This is a direct application of Mertens' third theorem, which we will now derive from the specified first principles.\n\nLet $y > 1$ be a real number. We are interested in the asymptotic behavior of the product $P(y) = \\prod_{p\\le y}\\left(1-\\frac{1}{p}\\right)$ for large $y$. The problem asks for the case where $y=x^\\alpha$.\n\nWe begin by taking the natural logarithm of $P(y)$:\n$$\n\\log P(y) = \\log\\left(\\prod_{p\\le y}\\left(1-\\frac{1}{p}\\right)\\right) = \\sum_{p\\le y}\\log\\left(1-\\frac{1}{p}\\right).\n$$\nThe problem statement mentions using the absolutely convergent expansion for the logarithm. The Taylor series for $\\log(1-u)$ is $\\log(1-u) = -\\sum_{k=1}^{\\infty} \\frac{u^k}{k}$ for $|u|<1$. Applying this with $u=1/p$, we have:\n$$\n\\log\\left(1-\\frac{1}{p}\\right) = -\\frac{1}{p} - \\sum_{k=2}^{\\infty}\\frac{1}{k p^k}.\n$$\nSubstituting this into the expression for $\\log P(y)$:\n$$\n\\log P(y) = \\sum_{p\\le y}\\left(-\\frac{1}{p} - \\sum_{k=2}^{\\infty}\\frac{1}{k p^k}\\right) = -\\left(\\sum_{p\\le y}\\frac{1}{p}\\right) - \\sum_{p\\le y}\\sum_{k=2}^{\\infty}\\frac{1}{k p^k}.\n$$\nLet's analyze the two terms on the right-hand side.\n\nThe first term is the partial sum of the reciprocals of primes, $\\sum_{p\\le y}\\frac{1}{p}$. Its asymptotic behavior is given by Mertens' second theorem, which states:\n$$\n\\sum_{p\\le y}\\frac{1}{p} = \\log(\\log y) + M + o(1),\n$$\nwhere $M$ is the Meissel-Mertens constant.\n\nThe second term is $-\\sum_{p\\le y}\\sum_{k=2}^{\\infty}\\frac{1}{k p^k}$. As $y\\to\\infty$, this sum converges to a constant value, because the full sum over all primes $p$ is absolutely convergent. Let this constant be $C'$:\n$$\nC' = -\\sum_{p}\\sum_{k=2}^{\\infty}\\frac{1}{k p^k} = \\sum_{p}\\left(\\log\\left(1-\\frac{1}{p}\\right) + \\frac{1}{p}\\right).\n$$\nThe convergence follows from the fact that $\\log(1-1/p) + 1/p = O(1/p^2)$. Therefore, as $y\\to\\infty$:\n$$\n\\sum_{p\\le y}\\sum_{k=2}^{\\infty}\\frac{1}{k p^k} = -C' + o(1).\n$$\n\nCombining these results, the asymptotic behavior of $\\log P(y)$ is:\n$$\n\\log P(y) = -(\\log(\\log y) + M + o(1)) - (-C' + o(1)) = -\\log(\\log y) - M + C' + o(1).\n$$\n\nThe crucial step, as suggested by the problem's reference to the Laurent series of $\\zeta(s)$ and the Euler-Mascheroni constant $\\gamma$, is to relate the constant term $-M+C'$ to $-\\gamma$. A fundamental result in analytic number theory, derivable from the specified principles, is the identity:\n$$\nM - C' = \\gamma.\n$$\nThis identity connects the constants arising from sums over primes ($M$ and $C'$) to the constant $\\gamma$ arising from the sum over all integers (the harmonic series). We can outline the origin of this identity by considering the Dirichlet series generating functions for sums over primes versus sums over all integers. The Laurent expansion of the Riemann zeta function $\\zeta(s)=\\sum_{n=1}^\\infty n^{-s}$ at $s=1$ is given as $\\zeta(s) = \\frac{1}{s-1} + \\gamma + O(s-1)$. This explicitly introduces $\\gamma$. The behavior of $\\log \\zeta(s) = \\sum_p p^{-s} + \\text{regular terms}$ near $s=1$ provides the information about prime sums. A careful comparison of the asymptotic behavior of the partial sums ($\\sum_{n\\le y} 1/n$ vs. $\\sum_{p\\le y} 1/p$) and their generating functions near $s=1$ establishes the identity $M = \\gamma + C'$.\n\nSubstituting $M-C'=\\gamma$ into our expression for $\\log P(y)$:\n$$\n\\log P(y) = -\\log(\\log y) - (M-C') + o(1) = -\\log(\\log y) - \\gamma + o(1).\n$$\n\nTo find the asymptotic behavior of $P(y)$, we exponentiate the expression for $\\log P(y)$:\n$$\nP(y) = \\exp(-\\log(\\log y) - \\gamma + o(1)) = \\exp(-\\log(\\log y)) \\exp(-\\gamma) \\exp(o(1)).\n$$\nSince $\\exp(-\\log(\\log y)) = \\frac{1}{\\log y}$ and $\\exp(o(1)) = 1+o(1)$, we arrive at Mertens' third theorem:\n$$\nP(y) \\sim \\frac{e^{-\\gamma}}{\\log y}.\n$$\nThis derivation shows the persistent appearance of the factor $e^{-\\gamma}$, which originates from the constant term $\\gamma$ in the Laurent expansion of the Riemann zeta function at its pole.\n\nFinally, the problem asks for the leading asymptotic behavior of $P(x^{\\alpha})$. We substitute $y=x^{\\alpha}$ into the derived asymptotic formula. Since $\\alpha>0$, as $x\\to\\infty$, we also have $y\\to\\infty$.\nThe logarithm of the cutoff is $\\log y = \\log(x^{\\alpha}) = \\alpha \\log x$.\nSubstituting this into the asymptotic expression for $P(y)$:\n$$\nP(x^\\alpha) \\sim \\frac{e^{-\\gamma}}{\\log(x^\\alpha)} = \\frac{e^{-\\gamma}}{\\alpha \\log x}.\n$$\nThis expression demonstrates how the cutoff $y=x^{\\alpha}$ rescales the leading term by a factor of $1/\\alpha$ compared to the case with cutoff $x$. The constant factor $e^{-\\gamma}$ remains unaffected.\n\nThe leading asymptotic term for $P(x^{\\alpha})$ as $x\\to\\infty$ is therefore $\\frac{e^{-\\gamma}}{\\alpha \\log x}$.", "answer": "$$\n\\boxed{\\frac{\\exp(-\\gamma)}{\\alpha \\log(x)}}\n$$", "id": "3017428"}, {"introduction": "Theoretical results often describe behavior \"in the limit,\" but how do these asymptotics play out for finite, computable values? This final practice [@problem_id:3087061] transitions from theory to empirical verification, asking you to write a program to \"see\" Mertens' third theorem in action. By numerically computing the product $P(x) = \\prod_{p \\le x} (1 - 1/p)$ and observing the convergence of the quantity $(\\log x) P(x)$, you will gain a tangible intuition for the theorem's statement and the slow, subtle nature of convergence in number theory.", "problem": "You are asked to design and implement a complete program to numerically investigate properties connected to Mertens' theorems in number theory. Define the function $P(x)$ for real $x \\geq 1$ by extending it piecewise constantly as follows: for each integer $n \\geq 1$, let\n$$\nP(n) \\;=\\; \\prod_{p \\leq n} \\left( 1 - \\frac{1}{p} \\right),\n$$\nwhere the product ranges over all prime numbers $p \\leq n$, and for non-integers $x$ define $P(x)$ by $P(x) = P(\\lfloor x \\rfloor)$. Let $L(x)$ denote the scaled product\n$$\nL(x) \\;=\\; (\\log x)\\, P(x),\n$$\nwhere $\\log$ denotes the natural logarithm. Your goals are:\n- To test the monotonicity of $P(x)$ as $x$ increases over integers.\n- To quantify the near-constancy of $L(x)$ over prescribed sample sets.\n\nYou must base your reasoning and design on fundamental definitions and well-tested facts:\n- A prime number is a positive integer greater than $1$ that has no positive divisors other than $1$ and itself.\n- The product $P(n)$ is defined by multiplying factors $(1 - 1/p)$ for all primes $p \\leq n$.\n- The natural logarithm $\\log x$ is strictly increasing for $x > 0$.\n\nTasks to implement:\n1. Prime generation and cumulative product:\n   - Generate all prime numbers up to a maximum bound $N_{\\max}$ using a correct and efficient method based solely on the definition of a prime number (for example, a sieve).\n   - Compute the cumulative sequence $(P(n))_{n=1}^{N_{\\max}}$ by updating only when $n$ is prime, since for composite $n$ no new factor enters the product.\n\n2. Monotonicity test:\n   - For each bound $N$, check whether the sequence $(P(1),P(2),\\dots,P(N))$ is non-increasing. Because each new factor $(1 - 1/p)$ satisfies $0 < (1 - 1/p) < 1$, the ideal exact arithmetic would imply $P(n)$ is non-increasing in $n$. In floating-point arithmetic, allow a minimal numerical tolerance when comparing successive values.\n\n3. Near-constancy metric for $L(x)$:\n   - For a given bound $N$ and a specified sample set $S \\subseteq \\{2,3,\\dots,N\\}$, define the list of sampled values $\\{L(x) : x \\in S\\}$.\n   - Quantify near-constancy by the dimensionless ratio\n     $$\n     R(S) \\;=\\; \\frac{\\max_{x \\in S} L(x) \\;-\\; \\min_{x \\in S} L(x)}{\\mathrm{median}\\,\\{L(x) : x \\in S\\}},\n     $$\n     provided the median is positive; if the median is zero, set $R(S) = 0$ for that case.\n   - You must compute this ratio for two types of sample sets:\n     - The integer sample set $S_{\\mathrm{int}}(N) = \\{2,3,\\dots,N\\}$.\n     - The prime sample set $S_{\\mathrm{prime}}(N) = \\{p \\leq N : p \\text{ is prime}\\}$.\n   This metric tests the idea, suggested by Mertens' theorems, that $L(x)$ varies slowly with $x$; the computation should include small primes and moderate ranges.\n\nTest suite:\n- Your program must run with no input and compute results for the following six parameter sets $(N,\\mathrm{mode})$, where $\\mathrm{mode}$ indicates the sample set used in the near-constancy metric:\n  1. $(2,\\text{\"integers\"})$ using $S_{\\mathrm{int}}(2)$.\n  2. $(2,\\text{\"primes\"})$ using $S_{\\mathrm{prime}}(2)$.\n  3. $(30,\\text{\"integers\"})$ using $S_{\\mathrm{int}}(30)$.\n  4. $(30,\\text{\"primes\"})$ using $S_{\\mathrm{prime}}(30)$.\n  5. $(100000,\\text{\"integers\"})$ using $S_{\\mathrm{int}}(100000)$.\n  6. $(100000,\\text{\"primes\"})$ using $S_{\\mathrm{prime}}(100000)$.\n\nPer test case, your program must output a two-element list $[b, r]$, where $b$ is a boolean indicating whether $(P(n))_{n=1}^{N}$ is non-increasing, and $r$ is the floating-point value of $R(S)$ for the specified sample set.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the order listed above and is itself a two-element list $[b,r]$. For example, a syntactically valid format is\n  $$\n  [[\\text{True},0.0123],[\\text{True},0.0456],\\dots]\n  $$\n- There are no physical units or angles in this problem. All numerical answers are unitless real numbers.", "solution": "The user wants to write a solution for a computational number theory problem. Here is a breakdown of the solution.\n\n**1. Problem Validation**\nThe problem is deemed valid as it is scientifically grounded in number theory (specifically, concepts related to Mertens' theorems), well-posed with clear definitions and objectives, and free from ambiguities or contradictions. The computational tasks are feasible within the specified limits.\n\n**2. Solution Design**\nThe core of the solution is to first pre-compute necessary number-theoretic data up to the maximum required bound, $N_{\\max} = 100000$, and then iterate through the specified test cases to perform the required analyses.\n\n**2.1. Pre-computation Phase**\n- **Prime Number Generation**: All prime numbers up to $N_{\\max}$ are generated using the Sieve of Eratosthenes. This method is highly efficient. A boolean array, `is_prime`, of size $N_{\\max}+1$ is initialized to true. We then iterate from $i=2$ up to $\\sqrt{N_{\\max}}$. If $i$ is marked as prime, all its multiples (starting from $i^2$) are marked as composite (not prime). This populates the `is_prime` array, from which a list of primes can be extracted.\n\n- **Cumulative Product $P(n)$**: The sequence of products $(P(n))_{n=1}^{N_{\\max}}$ is computed iteratively. The problem defines $P(n) = \\prod_{p \\leq n} (1 - 1/p)$, where $p$ is prime. This implies that $P(n) = P(n-1)$ if $n$ is not a prime, and $P(n) = P(n-1) \\times (1 - 1/n)$ if $n$ is a prime. We create a floating-point array, `P_values`, of size $N_{\\max}+1$. We initialize $P(1) = 1$ (as the empty product). Then, for $n$ from $2$ to $N_{\\max}$, we set $P(n) = P(n-1)$ and, if $n$ is prime, multiply by the new factor:\n$$\nP(n) = \\begin{cases}\n    P(n-1) \\times \\left(1 - \\frac{1}{n}\\right) & \\text{if } n \\text{ is prime} \\\\\n    P(n-1) & \\text{if } n \\text{ is composite or } 1\n\\end{cases}\n$$\nwith the base case $P(1) = 1$. This directly implements the piecewise constant nature of the function for integer arguments.\n\n**2.2. Test Case Processing**\nFor each test case specified by a bound $N$ and a sample mode, we perform two main tasks:\n\n- **Monotonicity Test**: We must verify if the sequence $(P(1), P(2), \\dots, P(N))$ is non-increasing. This is done by iterating from $n=2$ to $N$ and checking if the condition $P(n) \\leq P(n-1)$ holds. Due to potential floating-point inaccuracies, the check is implemented as $P(n) \\leq P(n-1) + \\epsilon$, where $\\epsilon$ is a small positive tolerance (e.g., $10^{-12}$). If this inequality is violated for any $n$, a boolean flag $b$ is set to `False`. Otherwise, it remains `True`.\n\n- **Near-Constancy Metric $R(S)$**: This task quantifies the variation of $L(x) = (\\log x) P(x)$.\n    1.  **Construct Sample Set $S$**: Based on the mode, the sample set $S$ is either the set of all integers from $2$ to $N$, denoted $S_{\\mathrm{int}}(N) = \\{2, 3, \\dots, N\\}$, or the set of all prime numbers less than or equal to $N$, denoted $S_{\\mathrm{prime}}(N) = \\{p \\leq N : p \\text{ is prime}\\}$.\n    2.  **Evaluate $L(x)$**: For each integer $x \\in S$, we calculate $L(x) = (\\log x) P(x)$. As $x$ is an integer, $P(x)$ is simply the pre-computed value `P_values[x]`. This yields a list of values $\\{L(x) : x \\in S\\}$.\n    3.  **Calculate Metric $R(S)$**: The near-constancy ratio $R(S)$ is computed using the formula:\n        $$\n        R(S) = \\frac{\\max_{x \\in S} L(x) - \\min_{x \\in S} L(x)}{\\mathrm{median}\\,\\{L(x) : x \\in S\\}}\n        $$\n        The maximum, minimum, and median of the list of $L(x)$ values are efficiently computed using `numpy` functions. If the sample set $S$ is empty or contains only one element, the numerator is $0$, so $R(S) = 0$. The special case of a zero median is also handled as per the problem, though it does not occur for $N \\ge 2$.\n\n**3. Implementation and Final Output**\nThe entire logic is encapsulated in a Python script using the `numpy` library for numerical operations. The script iterates through the six predefined test cases, computes the pair $[b, r]$ for each, and stores them. Finally, the results are formatted into a single string representing a list of lists, e.g., `[[True,0.123],[False,4.56]]`, and printed to standard output. This formatting is constructed carefully to match the required output specification, without extraneous whitespace.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes results for a numerical investigation of Mertens' theorems.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, \"integers\"),\n        (2, \"primes\"),\n        (30, \"integers\"),\n        (30, \"primes\"),\n        (100000, \"integers\"),\n        (100000, \"primes\"),\n    ]\n\n    # Determine the maximum N required across all test cases for pre-computation.\n    N_max = 0\n    if test_cases:\n        N_max = max(n for n, mode in test_cases)\n\n    # Pre-computation Phase\n    # This block will only run if there are test cases to process.\n    if N_max > 0:\n        # 1. Prime generation using Sieve of Eratosthenes\n        is_prime = np.ones(N_max + 1, dtype=bool)\n        if N_max >= 0:\n            is_prime[0] = False\n        if N_max >= 1:\n            is_prime[1] = False\n        for i in range(2, int(np.sqrt(N_max)) + 1):\n            if is_prime[i]:\n                is_prime[i*i::i] = False\n        \n        prime_numbers = np.where(is_prime)[0]\n\n        # 2. Cumulative product P(n)\n        # P(n) = product_{p<=n} (1 - 1/p)\n        P_values = np.zeros(N_max + 1, dtype=np.float64)\n        if N_max >= 1:\n            P_values[1] = 1.0\n        \n        for n in range(2, N_max + 1):\n            P_values[n] = P_values[n-1]\n            if is_prime[n]:\n                P_values[n] *= (1.0 - 1.0 / n)\n\n    results = []\n    # Process each test case\n    for N, mode in test_cases:\n        # Task 2: Monotonicity test of P(n)\n        is_non_increasing = True\n        tolerance = 1e-12  # Numerical tolerance for float comparison\n        for n in range(2, N + 1):\n            if P_values[n] > P_values[n-1] + tolerance:\n                is_non_increasing = False\n                break\n        \n        # Task 3: Near-constancy metric R(S)\n        sample_set = np.array([], dtype=int)\n        if mode == \"integers\":\n            if N >= 2:\n                sample_set = np.arange(2, N + 1)\n        elif mode == \"primes\":\n            # Filter pre-computed primes to include only those <= N\n            sample_set = prime_numbers[prime_numbers <= N]\n        \n        r_metric = 0.0\n        if sample_set.size > 0:\n            # Calculate L(x) = log(x) * P(x) for x in the sample set.\n            # For integer x in sample set, P(x) = P_values[x].\n            L_values = np.log(sample_set) * P_values[sample_set]\n            \n            if L_values.size > 0:\n                L_median = np.median(L_values)\n                if L_median > 0:\n                    L_max = np.max(L_values)\n                    L_min = np.min(L_values)\n                    r_metric = (L_max - L_min) / L_median\n        \n        results.append([is_non_increasing, r_metric])\n\n    # Final print statement in the exact required format.\n    # Format: [[b1,r1],[b2,r2],...] with no spaces inside inner lists.\n    inner_strings = [f\"[{b},{r}]\" for b, r in results]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```", "id": "3087061"}]}