{"hands_on_practices": [{"introduction": "Before diving into complex proofs, it is often insightful to explore a mathematical statement by hand. This first practice invites you to become an empirical number theorist by verifying Bertrand's Postulate for small values of $n$. By constructing a table of primes in the interval $(n, 2n)$, you will not only confirm the postulate holds in these cases but also observe key patterns in the distribution of primes that hint at why a general proof is non-trivial [@problem_id:3081805].", "problem": "Let $a(n)$ denote the number of prime numbers strictly between $n$ and $2n$, that is, the cardinality of the set $\\{\\,p \\text{ prime} : n  p  2n\\,\\}$ for integer $n$. For each integer $n$ with $2 \\le n \\le 30$, construct the table of the primes in $(n,2n)$ and record $a(n)$. Based solely on the fundamental definitions of prime numbers and the prime counting function $\\pi(x)$, and on well-tested general facts such as the monotonicity of $\\pi(x)$, discuss any qualitative patterns you observe in $a(n)$ that are relevant to the proof strategy for Bertrand’s postulate (without attempting to prove the postulate or invoking unproved claims). Finally, compute the aggregate quantity\n$$\nS \\;=\\; \\sum_{n=2}^{30} a(n).\n$$\nExpress the final value of $S$ as an exact integer. No rounding is required.", "solution": "The problem requires a three-part analysis for the integer-valued function $a(n)$, which counts the number of prime numbers $p$ in the open interval $(n, 2n)$. The analysis is to be performed for integers $n$ in the range $2 \\le n \\le 30$. First, we must construct a table of values for $a(n)$. Second, we are to discuss qualitative patterns in the behavior of $a(n)$ relevant to the proof of Bertrand's postulate, using only elementary definitions and facts. Third, we must compute the sum $S = \\sum_{n=2}^{30} a(n)$.\n\nFirst, we list the prime numbers required for the intervals $(n, 2n)$ where $n$ ranges up to $30$. The maximum value of $2n$ is $2 \\times 30 = 60$. The primes less than $60$ are:\n$2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59$.\n\nUsing this list, we construct a table for each integer $n$ from $2$ to $30$, detailing the interval $(n, 2n)$, the set of primes within that interval, and the count $a(n)$.\n\n| $n$ | Interval $(n, 2n)$ | Set of Primes in $(n,2n)$ | $a(n)$ |\n|:---:|:---:|:---|:---:|\n| $2$ | $(2, 4)$ | $\\{3\\}$ | $1$ |\n| $3$ | $(3, 6)$ | $\\{5\\}$ | $1$ |\n| $4$ | $(4, 8)$ | $\\{5, 7\\}$ | $2$ |\n| $5$ | $(5, 10)$ | $\\{7\\}$ | $1$ |\n| $6$ | $(6, 12)$ | $\\{7, 11\\}$ | $2$ |\n| $7$ | $(7, 14)$ | $\\{11, 13\\}$ | $2$ |\n| $8$ | $(8, 16)$ | $\\{11, 13\\}$ | $2$ |\n| $9$ | $(9, 18)$ | $\\{11, 13, 17\\}$ | $3$ |\n| $10$ | $(10, 20)$ | $\\{11, 13, 17, 19\\}$ | $4$ |\n| $11$ | $(11, 22)$ | $\\{13, 17, 19\\}$ | $3$ |\n| $12$ | $(12, 24)$ | $\\{13, 17, 19, 23\\}$ | $4$ |\n| $13$ | $(13, 26)$ | $\\{17, 19, 23\\}$ | $3$ |\n| $14$ | $(14, 28)$ | $\\{17, 19, 23\\}$ | $3$ |\n| $15$ | $(15, 30)$ | $\\{17, 19, 23, 29\\}$ | $4$ |\n| $16$ | $(16, 32)$ | $\\{17, 19, 23, 29, 31\\}$ | $5$ |\n| $17$ | $(17, 34)$ | $\\{19, 23, 29, 31\\}$ | $4$ |\n| $18$ | $(18, 36)$ | $\\{19, 23, 29, 31\\}$ | $4$ |\n| $19$ | $(19, 38)$ | $\\{23, 29, 31, 37\\}$ | $4$ |\n| $20$ | $(20, 40)$ | $\\{23, 29, 31, 37\\}$ | $4$ |\n| $21$ | $(21, 42)$ | $\\{23, 29, 31, 37, 41\\}$ | $5$ |\n| $22$ | $(22, 44)$ | $\\{23, 29, 31, 37, 41, 43\\}$ | $6$ |\n| $23$ | $(23, 46)$ | $\\{29, 31, 37, 41, 43\\}$ | $5$ |\n| $24$ | $(24, 48)$ | $\\{29, 31, 37, 41, 43, 47\\}$ | $6$ |\n| $25$ | $(25, 50)$ | $\\{29, 31, 37, 41, 43, 47\\}$ | $6$ |\n| $26$ | $(26, 52)$ | $\\{29, 31, 37, 41, 43, 47\\}$ | $6$ |\n| $27$ | $(27, 54)$ | $\\{29, 31, 37, 41, 43, 47, 53\\}$ | $7$ |\n| $28$ | $(28, 56)$ | $\\{29, 31, 37, 41, 43, 47, 53\\}$ | $7$ |\n| $29$ | $(29, 58)$ | $\\{31, 37, 41, 43, 47, 53\\}$ | $6$ |\n| $30$ | $(30, 60)$ | $\\{31, 37, 41, 43, 47, 53, 59\\}$ | $7$ |\n\nNext, we discuss the qualitative patterns in $a(n)$. Bertrand's postulate states that for any integer $n  1$, $a(n) \\ge 1$.\n1.  **Empirical Verification**: The table shows that for every integer $n$ in the range $2 \\le n \\le 30$, the value of $a(n)$ is at least $1$. This provides empirical evidence for the postulate in this limited range.\n2.  **Relation to the Prime-Counting Function**: The function $a(n)$ is precisely related to the prime-counting function, $\\pi(x)$, which gives the number of primes less than or equal to $x$. The number of primes $p$ strictly between $n$ and $2n$ is the number of primes less than or equal to $2n-1$ minus the number of primes less than or equal to $n$. Thus, we can write $a(n) = \\pi(2n-1) - \\pi(n)$. Since $n \\ge 2$, $2n$ is composite, so this is equivalent to $a(n) = \\pi(2n) - \\pi(n)$.\n3.  **Local Fluctuations**: The sequence $a(n)$ is not monotonic. For example, $a(4)=2$ while $a(5)=1$. We can precisely characterize this behavior. Let's examine the change $a(n+1) - a(n)$:\n$$\na(n+1) - a(n) = (\\pi(2(n+1)-1) - \\pi(n+1)) - (\\pi(2n-1) - \\pi(n))\n$$\n$$\na(n+1) - a(n) = (\\pi(2n+1) - \\pi(2n-1)) - (\\pi(n+1) - \\pi(n))\n$$\nThe term $\\pi(n+1) - \\pi(n)$ counts the number of primes $p$ satisfying $n  p \\le n+1$. This count is $1$ if $n+1$ is prime, and $0$ otherwise.\nThe term $\\pi(2n+1) - \\pi(2n-1)$ counts primes $p$ with $2n-1  p \\le 2n+1$. The integers in this interval are $2n$ and $2n+1$. For $n \\ge 2$, $2n$ is composite. Thus, this count is $1$ if $2n+1$ is prime, and $0$ otherwise.\nLet $\\mathbb{I}(C)$ be an indicator function which is $1$ if condition $C$ is true and $0$ otherwise. Then,\n$$\na(n+1) - a(n) = \\mathbb{I}(2n+1 \\text{ is prime}) - \\mathbb{I}(n+1 \\text{ is prime}).\n$$\nThis relation explains the observed fluctuations. For instance, for $n=10$, $n+1=11$ is prime and $2n+1=21$ is not, so $a(11) - a(10) = 0 - 1 = -1$, consistent with $a(11)=3$ and $a(10)=4$. The fact that $a(n)$ can decrease means that a simple inductive proof of Bertrand's postulate (i.e., showing $a(n) \\ge 1 \\implies a(n+1) \\ge 1$) is not viable. A successful proof strategy must overcome this non-monotonicity, for example by establishing a sufficiently strong lower bound on $a(n)$ that cannot be breached by these local decrements. The famous proof by Erdős, which analyzes the prime factorization of the central binomial coefficient $\\binom{2n}{n}$, is an example of such a global argument.\n4.  **Global Trend**: Despite the local fluctuations, the values of $a(n)$ in the table exhibit a clear increasing trend. The values range from $1$ to $7$. This growth is consistent with heuristic arguments derived from the Prime Number Theorem, which suggests $\\pi(x) \\approx x/\\ln(x)$. This implies $a(n) = \\pi(2n) - \\pi(n) \\approx \\frac{2n}{\\ln(2n)} - \\frac{n}{\\ln(n)} \\approx \\frac{n}{\\ln(n)}$. This approximate form suggests that $a(n)$ not only remains positive but grows with $n$. This reinforces the idea that a proof strategy should focus on the overall density and distribution of primes rather than just their sequential properties.\n\nFinally, we compute the aggregate quantity $S$.\n$$\nS \\;=\\; \\sum_{n=2}^{30} a(n)\n$$\nUsing the values from the table:\n$a(2)$ to $a(5)$: $1, 1, 2, 1$. Sum = $5$.\n$a(6)$ to $a(10)$: $2, 2, 2, 3, 4$. Sum = $13$.\n$a(11)$ to $a(15)$: $3, 4, 3, 3, 4$. Sum = $17$.\n$a(16)$ to $a(20)$: $5, 4, 4, 4, 4$. Sum = $21$.\n$a(21)$ to $a(25)$: $5, 6, 5, 6, 6$. Sum = $28$.\n$a(26)$ to $a(30)$: $6, 7, 7, 6, 7$. Sum = $33$.\n\nThe total sum $S$ is the sum of these partial sums:\n$$\nS = 5 + 13 + 17 + 21 + 28 + 33\n$$\n$$\nS = 18 + 17 + 21 + 28 + 33 = 35 + 21 + 28 + 33 = 56 + 28 + 33 = 84 + 33 = 117\n$$\nThe value of the sum is $117$.", "answer": "$$\\boxed{117}$$", "id": "3081805"}, {"introduction": "The celebrated proof of Bertrand's Postulate by Paul Erdős hinges on a clever analysis of the central binomial coefficient, $\\binom{2n}{n}$. This exercise provides a hands-on look at the analytical machinery behind the proof by examining a fundamental inequality, $\\binom{2n}{n} \\ge \\frac{4^n}{2n+1}$. By justifying this bound and testing its strength for small $n$, you will gain a concrete understanding of the powerful tools used to control the size of this crucial combinatorial quantity [@problem_id:3081802].", "problem": "In the study of existence of prime numbers between $n$ and $2n$ (Bertrand's postulate), a common approach is to control the central binomial coefficient $\\binom{2n}{n}$. One inequality that underpins several arguments is the lower bound $\\binom{2n}{n} \\ge \\frac{4^{n}}{2n+1}$. Starting only from the binomial theorem and the definition of binomial coefficients, justify why $\\binom{2n}{n}$ must satisfy a lower bound of the form $\\binom{2n}{n} \\ge \\frac{4^{n}}{2n+1}$. Then, to evaluate how strong this bound is for small inputs and to confirm that it is adequate for base checks in arguments related to Bertrand's postulate, define the ratio\n$$\nR(n) = \\frac{(2n+1)\\binom{2n}{n}}{4^{n}}\n$$\nand compute $R(n)$ for $n=1,2,\\ldots,10$. Determine the exact minimum value of $R(n)$ over this range. Express your final answer as a single simplified rational number. No rounding is required.", "solution": "We begin from the binomial theorem, a fundamental identity stating that for any nonnegative integer $m$,\n$$\n(1+1)^{m} = \\sum_{k=0}^{m} \\binom{m}{k}.\n$$\nSetting $m=2n$ yields\n$$\n\\sum_{k=0}^{2n} \\binom{2n}{k} = 2^{2n} = 4^{n}.\n$$\nNext, we establish that the central term $\\binom{2n}{n}$ is the largest among the $\\binom{2n}{k}$. Consider the ratio of consecutive terms for $0 \\le k \\le 2n-1$:\n$$\n\\frac{\\binom{2n}{k+1}}{\\binom{2n}{k}} = \\frac{2n-k}{k+1}.\n$$\nFor $0 \\le k \\le n-1$, we have $2n-k \\ge n+1$ and $k+1 \\le n$, thus\n$$\n\\frac{2n-k}{k+1} \\ge \\frac{n+1}{n}  1,\n$$\nwhich shows $\\binom{2n}{k}$ increases up to $k=n$. By symmetry $\\binom{2n}{k} = \\binom{2n}{2n-k}$, the sequence is unimodal with maximum at $k=n$. Therefore,\n$$\n\\binom{2n}{n} \\ge \\frac{1}{2n+1} \\sum_{k=0}^{2n} \\binom{2n}{k} = \\frac{4^{n}}{2n+1}.\n$$\nThis establishes the inequality $\\binom{2n}{n} \\ge \\frac{4^{n}}{2n+1}$ using only the binomial theorem and elementary properties of binomial coefficients. Equivalently, the ratio\n$$\nR(n) = \\frac{(2n+1)\\binom{2n}{n}}{4^{n}}\n$$\nsatisfies $R(n) \\ge 1$ for all $n \\in \\mathbb{N}$.\n\nTo evaluate the strength of this bound for small $n$, we compute $R(n)$ explicitly for $n=1,2,\\ldots,10$. We will use the exact values of the central binomial coefficients $\\binom{2n}{n}$ and powers $4^{n}$.\n\n- For $n=1$: $\\binom{2}{1} = 2$, $4^{1} = 4$, $2n+1 = 3$, hence\n$$\nR(1) = \\frac{3 \\cdot 2}{4} = \\frac{6}{4} = \\frac{3}{2}.\n$$\n\n- For $n=2$: $\\binom{4}{2} = 6$, $4^{2} = 16$, $2n+1 = 5$, hence\n$$\nR(2) = \\frac{5 \\cdot 6}{16} = \\frac{30}{16} = \\frac{15}{8}.\n$$\n\n- For $n=3$: $\\binom{6}{3} = 20$, $4^{3} = 64$, $2n+1 = 7$, hence\n$$\nR(3) = \\frac{7 \\cdot 20}{64} = \\frac{140}{64} = \\frac{35}{16}.\n$$\n\n- For $n=4$: $\\binom{8}{4} = 70$, $4^{4} = 256$, $2n+1 = 9$, hence\n$$\nR(4) = \\frac{9 \\cdot 70}{256} = \\frac{630}{256} = \\frac{315}{128}.\n$$\n\n- For $n=5$: $\\binom{10}{5} = 252$, $4^{5} = 1024$, $2n+1 = 11$, hence\n$$\nR(5) = \\frac{11 \\cdot 252}{1024} = \\frac{2772}{1024} = \\frac{693}{256}.\n$$\n\n- For $n=6$: $\\binom{12}{6} = 924$, $4^{6} = 4096$, $2n+1 = 13$, hence\n$$\nR(6) = \\frac{13 \\cdot 924}{4096} = \\frac{12012}{4096} = \\frac{3003}{1024}.\n$$\n\n- For $n=7$: $\\binom{14}{7} = 3432$, $4^{7} = 16384$, $2n+1 = 15$, hence\n$$\nR(7) = \\frac{15 \\cdot 3432}{16384} = \\frac{51480}{16384} = \\frac{6435}{2048}.\n$$\n\n- For $n=8$: $\\binom{16}{8} = 12870$, $4^{8} = 65536$, $2n+1 = 17$, hence\n$$\nR(8) = \\frac{17 \\cdot 12870}{65536} = \\frac{218790}{65536} = \\frac{109395}{32768}.\n$$\n\n- For $n=9$: $\\binom{18}{9} = 48620$, $4^{9} = 262144$, $2n+1 = 19$, hence\n$$\nR(9) = \\frac{19 \\cdot 48620}{262144} = \\frac{923780}{262144} = \\frac{230945}{65536}.\n$$\n\n- For $n=10$: $\\binom{20}{10} = 184756$, $4^{10} = 1048576$, $2n+1 = 21$, hence\n$$\nR(10) = \\frac{21 \\cdot 184756}{1048576} = \\frac{3879876}{1048576} = \\frac{969969}{262144}.\n$$\n\nEach $R(n)$ computed is strictly greater than $1$, confirming that the bound $\\binom{2n}{n} \\ge \\frac{4^{n}}{2n+1}$ holds and is not merely tight at $1$ for small $n$. Among the listed values, the smallest occurs at $n=1$ with $R(1) = \\frac{3}{2}$. Therefore, the minimum of $R(n)$ for $n=1,2,\\ldots,10$ is\n$$\n\\min_{1 \\le n \\le 10} R(n) = \\frac{3}{2}.\n$$\nThis demonstrates that even in the smallest cases relevant to base checks in arguments for Bertrand's postulate, the inequality is robust, with the ratio bounded away from $1$.", "answer": "$$\\boxed{\\frac{3}{2}}$$", "id": "3081802"}, {"introduction": "A mathematical theorem's guarantee can be the foundation for a practical algorithm. Bertrand's Postulate assures us that a prime always exists between $n$ and $2n$, but how do we actually find it? This practice challenges you to translate this theoretical certainty into a computational reality by designing a deterministic algorithm to locate such a prime and analyzing its performance [@problem_id:3081808]. This exercise bridges the gap between abstract existence and concrete construction.", "problem": "Design and justify a deterministic algorithm that, given an integer $n \\ge 2$, finds a prime number in the open interval $(n,2n)$ using trial division bounded by $\\lfloor \\sqrt{2n} \\rfloor$. The algorithm must operate under the following fundamental base and constraints:\n\n- Start from the definition that an integer $m \\ge 2$ is prime if and only if there is no integer divisor $d$ with $2 \\le d \\le \\lfloor \\sqrt{m} \\rfloor$ such that $d$ divides $m$.\n- Use Bertrand's postulate (Chebyshev's theorem): for every integer $n \\ge 1$, there exists a prime $p$ with $n  p \\le 2n$. This ensures that, for $n \\ge 2$, there exists at least one prime in $(n,2n)$.\n- Implement trial division bounded by $\\lfloor \\sqrt{2n} \\rfloor$ in a way that maintains correctness: for each candidate $m$ in $(n,2n)$, perform divisibility checks by integers $d$ starting at $2$ and increasing, stopping the divisibility loop as soon as $d^2  m$ or a divisor is found. This early stopping is justified by the fundamental property that any composite $m$ has a factor at most $\\lfloor \\sqrt{m} \\rfloor$.\n\nYour program must:\n1. Systematically test consecutive integers $m$ with $n  m  2n$, in increasing order, applying trial division as specified, and return the first prime found. This determinism refers to scanning in strictly increasing order and stopping at the earliest prime.\n2. Instrument its execution to record:\n   - The prime found $p$.\n   - The number of candidate integers tested before finding $p$.\n   - The total number of trial divisions performed (that is, the total count of modulo operations $m \\bmod d$ actually attempted across all candidates tested).\n   - A worst-case upper bound on the number of trial divisions for the given $n$, taken as $(n-1)\\lfloor \\sqrt{2n} \\rfloor$, which arises from testing all $n-1$ integers in $(n,2n)$ and, for each, potentially attempting up to $\\lfloor \\sqrt{2n} \\rfloor$ trial divisions.\n\nAnalyze, within your solution, why the algorithm terminates for each $n \\ge 2$ and derive the worst-case time complexity in terms of $n$ using asymptotic notation, treating a single trial division as the unit cost.\n\nTest suite and output specification:\n- Use the following test suite of inputs $n$: $2$, $3$, $20$, $64$, $1000$, $4096$, $100000$.\n- For each $n$, produce the quadruple $[p,\\text{candidates},\\text{divisions},\\text{upper\\_bound}]$, where $p$ is the prime found in $(n,2n)$, $\\text{candidates}$ is the integer count of candidates tested, $\\text{divisions}$ is the integer count of trial divisions performed, and $\\text{upper\\_bound}$ is the integer value $(n-1)\\lfloor \\sqrt{2n} \\rfloor$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, and each test case result formatted as its own bracketed list. For example: $[[p_1,c_1,d_1,u_1],[p_2,c_2,d_2,u_2],\\dots]$.", "solution": "### Algorithmic Design and Justification\n\nThe objective is to construct a deterministic algorithm that, for any integer $n \\ge 2$, finds a prime number $p$ such that $n  p  2n$. The existence of such a prime is guaranteed by Bertrand's postulate, which states that for any integer $n \\ge 1$, the interval $(n, 2n]$ contains at least one prime. For $n \\ge 2$, the integer $2n$ is composite, thus the interval $(n, 2n)$ must contain a prime.\n\nThe algorithm proceeds as follows:\n1.  Initialize a search integer $m$ to $n+1$.\n2.  Iterate through consecutive integers $m = n+1, n+2, n+3, \\dots, 2n-1$. This strict, increasing sequence ensures the algorithm is deterministic; it will always find the smallest prime in the specified interval.\n3.  For each candidate integer $m$, determine if it is prime. This is accomplished using a primality test sub-procedure.\n4.  The first integer $m$ identified as prime is the desired result, $p$. The algorithm terminates and returns $p$, along with the specified performance metrics.\n\nThe core of the algorithm is the primality test. As specified, this test is based on the fundamental definition of a prime number: an integer $m \\ge 2$ is prime if and only if it is not divisible by any integer $d$ in the range $2 \\le d \\le \\sqrt{m}$.\n\nThe primality test for a candidate $m$ is implemented via trial division:\n1.  Initialize a divisor $d$ to $2$.\n2.  Iterate through divisors $d = 2, 3, 4, \\dots$ as long as the condition $d^2 \\le m$ holds.\n3.  In each iteration, perform the modulo operation $m \\bmod d$.\n4.  If $m \\bmod d = 0$ for any $d$, then $m$ is composite. The primality test for $m$ concludes, and the main algorithm proceeds to the next candidate, $m+1$.\n5.  If the loop completes without finding any divisor (i.e., $d^2$ becomes greater than $m$), then $m$ has no divisors in the range $[2, \\sqrt{m}]$, and is therefore prime.\n\nTo fulfill the instrumentation requirements, two counters are maintained:\n-   `candidates`: This counter is incremented for each integer $m$ that is tested for primality. It begins at $1$ for $m=n+1$ and stops when the first prime is found. If the found prime is $p$, the value of this counter will be $p - n$.\n-   `divisions`: This counter is incremented each time a modulo operation ($m \\bmod d$) is performed within the trial division loop.\n\nFinally, a worst-case upper bound on the number of divisions is calculated as $(n-1)\\lfloor \\sqrt{2n} \\rfloor$. This figure represents the product of the total number of candidates in the interval $(n, 2n)$, which is $n-1$, and a uniform upper bound for the number of trial divisions for any single candidate in that interval, which is $\\lfloor \\sqrt{2n} \\rfloor$.\n\n### Termination and Complexity Analysis\n\n**Termination Guarantee:** The algorithm is guaranteed to terminate for any input $n \\ge 2$. Bertrand's postulate ensures that for any such $n$, there is at least one prime number $p$ in the interval $(n, 2n)$. Since the algorithm systematically tests every integer in this interval in increasing order, it is inevitable that it will encounter and identify the first of these primes, at which point it terminates.\n\n**Worst-Case Time Complexity:** The computational cost is dominated by the number of trial division operations. Let the unit of cost be a single modulo operation.\n\nThe algorithm consists of an outer loop over candidate integers $m$ and an inner loop for trial division.\n-   The outer loop iterates from $m=n+1$ up to the first prime $p$. In the worst-case scenario, the first prime $p$ is close to $2n$. This means the number of candidates tested is approximately $(2n-1) - (n+1) + 1 = n-1$. Therefore, the number of iterations of the outer loop is of the order $O(n)$.\n-   The inner loop performs trial divisions for a given candidate $m$. It tests divisors $d$ from $2$ up to $\\lfloor \\sqrt{m} \\rfloor$. The number of divisions is therefore approximately $\\sqrt{m}$. Since all candidates satisfy $n  m  2n$, the cost of testing a single candidate $m$ is bounded by $O(\\sqrt{2n}) = O(\\sqrt{n})$.\n\nThe total worst-case time complexity, $T(n)$, is the product of the number of candidates tested and the maximum cost per candidate.\n$$ T(n) = (\\text{Number of candidates}) \\times (\\text{Cost per candidate}) $$\n$$ T(n) \\approx O(n) \\times O(\\sqrt{n}) = O(n\\sqrt{n}) = O(n^{3/2}) $$\n\nMore formally, the total number of divisions in the worst case is bounded by the sum of divisions for all candidates from $n+1$ to $2n-1$:\n$$ \\text{Total Divisions} \\le \\sum_{m=n+1}^{2n-1} \\lfloor \\sqrt{m} \\rfloor $$\nWe can bound this sum:\n$$ \\sum_{m=n+1}^{2n-1} \\lfloor \\sqrt{m} \\rfloor  \\sum_{m=n+1}^{2n-1} \\sqrt{2n} = (n-1)\\sqrt{2n} $$\nThis expression is dominated by the $n \\cdot \\sqrt{n}$ term, confirming that the worst-case time complexity of the algorithm is $O(n^{3/2})$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Finds the first prime in (n, 2n) and reports performance metrics.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [2, 3, 20, 64, 1000, 4096, 100000]\n\n    results = []\n    for n in test_cases:\n        # Initialize instrumentation variables for the current n\n        prime_found = 0\n        candidates_tested = 0\n        total_divisions = 0\n\n        # Calculate the worst-case upper bound as specified\n        # Note: 2n is a non-inclusive upper bound for the interval (n, 2n)\n        upper_bound = (n - 1) * int(np.sqrt(2 * n))\n\n        # Iterate through candidates m in the open interval (n, 2n)\n        for m in range(n + 1, 2 * n):\n            candidates_tested += 1\n            is_m_prime = True\n\n            # Primality test using trial division bounded by sqrt(m)\n            # The loop for divisor d runs as long as d*d = m\n            d = 2\n            while d * d = m:\n                total_divisions += 1\n                if m % d == 0:\n                    is_m_prime = False\n                    break\n                d += 1\n            \n            if is_m_prime:\n                prime_found = m\n                # Found the first prime, so we can stop searching.\n                break\n\n        # Store the result for this test case\n        results.append([prime_found, candidates_tested, total_divisions, upper_bound])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, with no spaces. str() adds spaces, so we remove them.\n    print(str(results).replace(' ', ''))\n\nsolve()\n```", "id": "3081808"}]}