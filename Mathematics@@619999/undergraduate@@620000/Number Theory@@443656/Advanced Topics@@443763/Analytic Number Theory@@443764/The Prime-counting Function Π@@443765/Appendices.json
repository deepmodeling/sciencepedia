{"hands_on_practices": [{"introduction": "Before exploring the sophisticated theory of the prime-counting function, it is essential to build an intuition from first principles. This exercise grounds your understanding of $\\pi(x)$ in the concrete process of identifying and counting primes for small values of $x$. By comparing your exact counts with the simple approximation $x / \\ln(x)$, you will gain a direct, hands-on appreciation for the remarkable pattern captured by the Prime Number Theorem. [@problem_id:3092893]", "problem": "Let $p$ denote a prime number. Define the prime-counting function $\\pi(x)$ as the number of primes less than or equal to a real number $x$. Starting from the fundamental definition of primality (an integer greater than $1$ with no positive divisors other than $1$ and itself), compute $\\pi(x)$ exactly for the benchmark values $x=10$, $x=100$, and $x=1000$ by systematic enumeration grounded in this definition.\n\nThen, define the aggregate quantity\n$$A=\\pi(10)+\\pi(100)+\\pi(1000).$$\nReport $A$ as your final answer, exactly (no rounding).\n\nIn addition, using only foundational facts and definitions (such as the Sieve of Eratosthenes and basic properties of the natural logarithm), briefly discuss the qualitative pattern you observe by considering the differences\n$$E(10)=\\pi(10)-\\frac{10}{\\ln 10},\\quad E(100)=\\pi(100)-\\frac{100}{\\ln 100},\\quad E(1000)=\\pi(1000)-\\frac{1000}{\\ln 1000},$$\nwithout relying on any unproven shortcuts. Your discussion does not affect the single-number final answer you must provide for $A$.", "solution": "We begin from the core definitions. An integer $n \\geq 2$ is prime if its only positive divisors are $1$ and $n$. The function $\\pi(x)$ counts the number of primes $p$ with $p \\leq x$.\n\nTo compute exact counts, one can use trial division to test primality or, equivalently, the Sieve of Eratosthenes to systematically eliminate composites. We proceed case by case.\n\nFor $x=10$, enumerate primes $\\leq 10$:\n- The primes are $2$, $3$, $5$, $7$.\nTherefore,\n$$\\pi(10)=4.$$\n\nFor $x=100$, a sieve or careful testing yields the primes $\\leq 100$. Listing them explicitly:\n$$2,\\,3,\\,5,\\,7,\\,11,\\,13,\\,17,\\,19,\\,23,\\,29,\\,31,\\,37,\\,41,\\,43,\\,47,\\,53,\\,59,\\,61,\\,67,\\,71,\\,73,\\,79,\\,83,\\,89,\\,97.$$\nCounting, we obtain\n$$\\pi(100)=25.$$\n\nFor $x=1000$, executing a Sieve of Eratosthenes on the integers from $2$ through $1000$ yields the exact count of primes up to $1000$. A convenient way to summarize the sieve outcome is to record cumulative counts at each hundred:\n$$\\pi(100)=25,\\quad \\pi(200)=46,\\quad \\pi(300)=62,\\quad \\pi(400)=78,\\quad \\pi(500)=95,$$\n$$\\pi(600)=109,\\quad \\pi(700)=125,\\quad \\pi(800)=139,\\quad \\pi(900)=154,\\quad \\pi(1000)=168.$$\nThus,\n$$\\pi(1000)=168.$$\n\nWith these exact values, we form\n$$A=\\pi(10)+\\pi(100)+\\pi(1000)=4+25+168=197.$$\n\nWe now briefly discuss the qualitative pattern of $\\pi(x)$ relative to the heuristic $x/\\ln x$ by considering the differences\n$$E(10)=\\pi(10)-\\frac{10}{\\ln 10},\\quad E(100)=\\pi(100)-\\frac{100}{\\ln 100},\\quad E(1000)=\\pi(1000)-\\frac{1000}{\\ln 1000}.$$\nFrom the sieve counts, we know $\\pi(100)=25$ and $\\pi(1000)=168$. Observe that $\\ln 10>2$, hence $\\ln 100=2\\ln 10>4$, so\n$$\\frac{100}{\\ln 100}<\\frac{100}{4}=25,$$\nwhich implies\n$$E(100)=25-\\frac{100}{\\ln 100}>0.$$\nSimilarly, since $\\ln 1000=3\\ln 10>6$, we have\n$$\\frac{1000}{\\ln 1000}<\\frac{1000}{6}=\\frac{500}{3},$$\nand consequently\n$$E(1000)=168-\\frac{1000}{\\ln 1000}>168-\\frac{500}{3}.$$\nBecause $\\frac{500}{3}<167$, this shows $E(1000)>1$, so the heuristic $x/\\ln x$ underestimates $\\pi(x)$ at $x=100$ and $x=1000$. For $x=10$, one finds\n$$E(10)=4-\\frac{10}{\\ln 10},$$\nand, while we have not relied on numerical approximation here, it is known that $\\frac{10}{\\ln 10}$ exceeds $4$, so $E(10)<0$, illustrating that at very small $x$ the heuristic can overestimate or underestimate due to fluctuations. Overall, as $x$ grows, the relative error $|\\pi(x)-x/\\ln x|/(x/\\ln x)$ decreases, consistent with the qualitative behavior suggested by the prime number theorem, while finite-size fluctuations can produce varying signs in the difference for small $x$.\n\nThe requested final quantity is the exact integer $A=197$.", "answer": "$$\\boxed{197}$$", "id": "3092893"}, {"introduction": "While manual counting is instructive, it quickly becomes infeasible. This practice transitions you from brute-force enumeration to elegant algorithmic thinking by implementing the Sieve of Eratosthenes, a cornerstone of computational number theory. You will not only write code to compute $\\pi(x)$ efficiently but also derive the algorithm's correctness and analyze its performance, revealing the deep connection between theoretical insights and practical problem-solving. [@problem_id:3092903]", "problem": "Implement a complete program that computes the prime-counting function $\\pi(x)$ using the sieve of Eratosthenes and, within the accompanying written solution, derives its correctness and analyzes its time and space complexity in terms of $x$ starting from core definitions. The prime-counting function $\\pi(x)$ is defined as the number of primes less than or equal to $x$. A prime is a positive integer greater than $1$ that has no positive integer divisors other than $1$ and itself. The sieve of Eratosthenes is a classical algorithm that identifies primes by iteratively marking composite integers starting from the smallest prime. Your derivation must strictly begin from these definitions and well-tested facts, and must not assume or state ready-made complexity formulas without justification. The algorithmic procedure that your program implements should adhere to the following mathematically faithful steps: initialize a boolean array that represents primality for all integers from $0$ through $x$, set all entries for integers at least $2$ to true, and for each integer $p$ from $2$ up to $\\lfloor \\sqrt{x} \\rfloor$, if $p$ is currently marked as prime, mark every multiple of $p$ from $p^2$ through $x$ as composite. Once the loop finishes, compute $\\pi(x)$ by counting the entries corresponding to primes (true) from $2$ through $x$. Ensure the program handles edge cases $x = 0$ and $x = 1$ correctly.\n\nTest suite specification:\n- Use the following fixed test inputs for $x$: $0$, $1$, $2$, $10$, $100$, $10^6$.\n- For each $x$ in the test suite, output the value of $\\pi(x)$ as an integer.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the test suite in order, as a comma-separated list enclosed in square brackets, with no spaces. For example, for three results $a$, $b$, $c$, the output should be formatted as $[a,b,c]$.", "solution": "The task is to implement the prime-counting function $\\pi(x)$ using the sieve of Eratosthenes algorithm, and to provide a rigorous derivation of the algorithm's correctness and complexity. The function $\\pi(x)$ is defined as the number of prime integers less than or equal to a non-negative real number $x$. A prime number is a positive integer greater than $1$ that has no positive integer divisors other than $1$ and itself.\n\nThe problem is first validated.\n\n**Step 1: Extract Givens**\n- **Function definition**: $\\pi(x)$, the number of primes $p \\le x$.\n- **Prime definition**: A positive integer greater than $1$ with no positive integer divisors other than $1$ and itself.\n- **Algorithm**: Sieve of Eratosthenes.\n- **Algorithmic Steps**:\n    1. Initialize a boolean array representing primality for integers from $0$ to $x$. Let us denote this array `is_prime`.\n    2. Set `is_prime[i]` to true for all $i \\ge 2$.\n    3. For each integer $p$ from $2$ up to $\\lfloor \\sqrt{x} \\rfloor$:\n    4. If $p$ is marked as prime (i.e., `is_prime[p]` is true):\n    5. Mark every multiple of $p$ from $p^2$ through $x$ as composite (i.e., set `is_prime[j]` to false for $j = p^2, p^2+p, \\dots \\le x$).\n    6. After the loop, compute $\\pi(x)$ by counting the number of indices $i$ from $2$ to $x$ for which `is_prime[i]` is true.\n- **Edge Cases**: Handle $x=0$ and $x=1$.\n- **Test Suite**: $x \\in \\{0, 1, 2, 10, 100, 10^6\\}$.\n- **Output Format**: A single line `[r1,r2,r3,r4,r5,r6]` where $r_i$ is the result for the $i$-th test case.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is mathematically and algorithmically well-defined. It is grounded in fundamental concepts of number theory. The definitions of prime numbers, the prime-counting function, and the steps for the sieve of Eratosthenes are all standard and correct. The problem is self-contained, consistent, and provides a clear path to a unique, verifiable solution. The computational requirements for the given test suite are feasible. The problem is therefore deemed **valid**.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n### Derivation of Correctness and Complexity Analysis\n\n**Algorithm Specification**\n\nLet $x$ be a non-negative integer. We seek to compute $\\pi(x)$.\n1.  Create a boolean array `is_prime` of size $x+1$.\n2.  Initialize `is_prime[i] = \\text{false}` for $i \\in \\{0, 1\\}$ and `is_prime[i] = \\text{true}` for $i \\in \\{2, 3, \\dots, x\\}$.\n3.  For $p$ from $2$ to $\\lfloor \\sqrt{x} \\rfloor$:\n    a. If `is_prime[p]` is true:\n    b. For $j$ from $p^2$ to $x$ in steps of $p$:\n       Set `is_prime[j] = \\text{false}`.\n4.  Compute $\\pi(x) = \\sum_{i=2}^{x} \\mathbb{I}(\\text{is\\_prime}[i])$, where $\\mathbb{I}$ is the indicator function (1 if true, 0 if false).\n\n**Derivation of Correctness**\n\nThe algorithm's correctness hinges on the property that every composite number can be factored, and specifically, that it has a small prime factor. This follows from the Fundamental Theorem of Arithmetic, which states that every integer greater than $1$ is either a prime number itself or can be represented as a product of prime numbers, and this representation is unique up to the order of the factors.\n\n**Lemma:** Every composite integer $n > 1$ has at least one prime factor $p$ such that $p \\le \\sqrt{n}$.\n\n**Proof of Lemma:** Let $n$ be a composite number. By definition, $n$ can be written as a product $n = a \\cdot b$ for integers $a, b$ with $1 < a \\le b < n$. Suppose, for the sake of contradiction, that all prime factors of $n$ are greater than $\\sqrt{n}$. Since $a$ is a divisor of $n$, its prime factors are a subset of the prime factors of $n$. Hence, all prime factors of $a$ must also be greater than $\\sqrt{n}$. As $a > 1$, $a$ must have at least one prime factor, let's call it $p_a$. Then $a \\ge p_a > \\sqrt{n}$. Similarly, $b > 1$, so it must have a prime factor $p_b > \\sqrt{n}$, which implies $b \\ge p_b > \\sqrt{n}$. This leads to the contradiction $n = a \\cdot b > \\sqrt{n} \\cdot \\sqrt{n} = n$. Therefore, the initial assumption must be false. At least one factor, say $a$, must satisfy $a \\le \\sqrt{n}$. If $a$ is prime, we have found our prime factor $p=a \\le \\sqrt{n}$. If $a$ is composite, it has a prime factor $p'$ which must be less than $a$, so $p' < a \\le \\sqrt{n}$. In all cases, $n$ has a prime factor $p \\le \\sqrt{n}$.\n\n**Main Proof of Correctness:**\nThe algorithm works by elimination. It starts by assuming all numbers from $2$ to $x$ are prime and then iteratively marks composite numbers. A number $i \\le x$ remains marked as prime if and only if it is not marked as composite during any iteration.\n\nLet $c$ be any composite number such that $2 \\le c \\le x$. According to the lemma, $c$ must have a prime factor $p' \\le \\sqrt{c}$. Since $c \\le x$, it follows that $\\sqrt{c} \\le \\sqrt{x}$, and thus $p' \\le \\sqrt{x}$.\n\nThe algorithm's outer loop iterates through integers $p$ from $2$ up to $\\lfloor \\sqrt{x} \\rfloor$. This range of $p$ is guaranteed to include the smallest prime factor, $p'$, of any composite number $c \\le x$. When the loop variable $p$ takes the value of this prime $p'$, the condition `is_prime[p]` will be true (because $p'$ is the *smallest* prime factor of any composite number it divides, it cannot have been eliminated by a smaller prime). The inner loop will then execute and mark all multiples of $p'$ as composite. Since $c$ is a multiple of $p'$, `is_prime[c]` will be set to false.\n\nThis demonstrates that every composite number $c \\in \\{2, \\dots, x\\}$ is correctly identified and marked as non-prime. Consequently, any number $i \\in \\{2, \\dots, x\\}$ that remains marked as true has no prime factors less than or equal to $\\sqrt{i}$, which, by the contrapositive of our lemma, implies $i$ cannot be composite. Thus, $i$ must be prime.\n\n**Justification for starting at $p^2$**: The inner loop, which marks multiples of a prime $p$, starts at $p^2$ instead of $2p$. Consider any composite number $m = k \\cdot p$ where $k < p$. The number $k$ must have a prime factor $q \\le k$. Since $k < p$, it follows that $q < p$. When the outer loop processed the prime $q$ (which happens before it processes $p$), it would have already marked all multiples of $q$, including $m$. Therefore, by the time the algorithm considers prime $p$, all composite numbers smaller than $p^2$ that have $p$ as a factor have already been eliminated. This optimization is correct and improves performance.\n\nFinally, since the `is_prime` array correctly identifies all primes up to $x$, summing the true values from $2$ to $x$ yields the total count of primes, which is the definition of $\\pi(x)$.\n\n**Complexity Analysis**\n\n**Space Complexity:**\nThe dominant data structure is the boolean array `is_prime` of size $x+1$. The space required is directly proportional to $x$. Therefore, the space complexity is $O(x)$.\n\n**Time Complexity:**\nThe algorithm's total runtime is the sum of three parts: initialization, sieving, and counting.\n1.  **Initialization**: Creating and initializing the boolean array of size $x+1$ takes $O(x)$ time.\n2.  **Sieving Loop**: The outer loop runs from $p=2$ to $\\lfloor \\sqrt{x} \\rfloor$. For each prime $p$ in this range, the inner loop performs marking operations. The number of operations for a given prime $p$ is the count of its multiples from $p^2$ to $x$, which is $\\lfloor x/p \\rfloor - (p-1)$. For large $x$, this is approximately $x/p$. The total number of marking operations is therefore the sum over all primes $p \\le \\sqrt{x}$:\n    $$ T_{sieve}(x) \\approx \\sum_{p \\le \\sqrt{x}, p \\text{ is prime}} \\frac{x}{p} $$\n    We can factor out $x$:\n    $$ T_{sieve}(x) \\approx x \\sum_{p \\le \\sqrt{x}} \\frac{1}{p} $$\n    A well-established result in analytic number theory, Mertens' Second Theorem, states that the sum of the reciprocals of primes up to a number $N$ is asymptotically described by:\n    $$ \\sum_{p \\le N} \\frac{1}{p} \\approx \\ln(\\ln N) + M $$\n    where $M$ is the Meissel-Mertens constant. For our case, $N = \\sqrt{x}$. The sum is therefore:\n    $$ \\sum_{p \\le \\sqrt{x}} \\frac{1}{p} \\approx \\ln(\\ln \\sqrt{x}) = \\ln(\\frac{1}{2}\\ln x) = \\ln(\\ln x) - \\ln 2 $$\n    The asymptotic behavior of this sum is $O(\\log \\log x)$.\n    Substituting this back into the expression for the sieving time, we get:\n    $$ T_{sieve}(x) = O(x \\log \\log x) $$\n3.  **Counting**: The final step involves iterating through the array from $2$ to $x$ to count the primes. This takes $O(x)$ time.\n\n**Total Time Complexity**: The total time complexity is the sum of the complexities of these parts: $O(x) + O(x \\log \\log x) + O(x)$. The dominant term is $O(x \\log \\log x)$. Thus, the overall time complexity of the Sieve of Eratosthenes is $O(x \\log \\log x)$.\n\nThis completes the derivation of correctness and complexity analysis. The implementation will follow based on this validated algorithm.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes pi(x) for a list of test cases and prints the results.\n    \"\"\"\n\n    def pi_sieve(x: int) -> int:\n        \"\"\"\n        Calculates the prime-counting function pi(x) using the Sieve of Eratosthenes.\n\n        Args:\n            x: An integer specifying the upper bound (inclusive).\n\n        Returns:\n            The number of prime numbers less than or equal to x.\n        \"\"\"\n        # Handle edge cases for x < 2, where there are no primes.\n        if x < 2:\n            return 0\n\n        # Step 1 & 2: Initialize a boolean array 'is_prime' for integers up to x.\n        # Assume all numbers from 2 to x are prime initially.\n        # We use numpy for efficient array operations.\n        is_prime = np.ones(x + 1, dtype=bool)\n        is_prime[0] = is_prime[1] = False\n\n        # Step 3: Iterate from p = 2 up to sqrt(x).\n        # We only need to check for factors up to sqrt(x) based on the principle that\n        # any composite number n has a prime factor p <= sqrt(n).\n        limit = int(np.sqrt(x))\n        for p in range(2, limit + 1):\n            # Step 4: If p is still marked as prime.\n            if is_prime[p]:\n                # Step 5: Mark all multiples of p from p^2 up to x as not prime.\n                # We start from p*p as an optimization, because any smaller multiple\n                # k*p (with k < p) would have already been marked by a prime factor of k.\n                is_prime[p*p::p] = False\n\n        # Step 6: Count the number of primes remaining in the array.\n        # np.sum() on a boolean array counts the number of True values.\n        return int(np.sum(is_prime))\n\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1, 2, 10, 100, 10**6]\n\n    results = []\n    for x_val in test_cases:\n        pi_val = pi_sieve(x_val)\n        results.append(pi_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3092903"}, {"introduction": "The ultimate test of a theoretical model is its performance against reality. In this capstone exercise, you will act as a computational number theorist, designing an experiment to compare the accuracy of the classic approximation $\\frac{x}{\\ln x}$ with more refined models like the logarithmic integral $\\operatorname{Li}(x)$ and the Riemann function $R(x)$. By generating exact data with your sieve and quantifying approximation errors, you will empirically verify the hierarchy of these famous formulas and synthesize your analytical and computational skills. [@problem_id:3092945]", "problem": "Design and implement a complete, runnable program that conducts a principled computational experiment comparing three classical approximations to the prime-counting function across logarithmically spaced inputs, and quantifies their errors against exact counts. The prime-counting function is defined by $\\,\\pi(x)\\,$ to be the number of prime numbers less than or equal to a real input $\\,x\\,$; for non-integer inputs, define $\\,\\pi(x) := \\pi(\\lfloor x \\rfloor)\\,$. The three approximations are:\n- $\\,\\dfrac{x}{\\log x}\\,$, justified by the Prime Number Theorem.\n- The logarithmic integral $\\,\\operatorname{Li}(x)\\,$, defined as the Cauchy principal value integral $\\,\\operatorname{Li}(x) = \\mathrm{PV} \\int_{2}^{x} \\dfrac{dt}{\\log t}\\,$.\n- The Riemann $\\,R$ function $\\,R(x)\\,$, defined by the series $\\,R(x) = \\displaystyle\\sum_{n=1}^{\\infty} \\dfrac{\\mu(n)}{n}\\,\\operatorname{Li}\\!\\left(x^{1/n}\\right)\\,$, where $\\,\\mu(n)\\,$ is the Möbius function.\n\nStarting from these definitions and well-tested facts of analytic number theory, your program must:\n1. Generate logarithmically spaced input points $\\,x_i\\,$ in each specified range, where logarithmic spacing means equal spacing in $\\,\\log_{10}(x)\\,$. Formally, for a range with parameters $\\,x_{\\min}, x_{\\max}, m\\,$, construct $\\,m\\,$ points\n$$\nx_i \\;=\\; 10^{\\,\\log_{10}(x_{\\min}) \\;+\\; i\\,\\frac{\\log_{10}(x_{\\max}) - \\log_{10}(x_{\\min})}{m-1}}\\quad\\text{for}\\quad i=0,1,\\dots,m-1.\n$$\n2. Compute $\\,\\pi(\\lfloor x_i \\rfloor)\\,$ exactly for every sample point using a correct prime sieve and cumulative counting.\n3. Compute for each sample point the three approximations $\\,\\dfrac{x_i}{\\log x_i}$, $\\,\\operatorname{Li}(x_i)$, and a truncated $\\,R(x_i)$ defined by\n$$\nR_N(x) \\;=\\; \\sum_{n=1}^{N(x)} \\frac{\\mu(n)}{n}\\,\\operatorname{Li}\\!\\left(x^{1/n}\\right),\n$$\nwith truncation index $\\,N(x) = \\left\\lfloor \\dfrac{\\log x}{\\log 2} \\right\\rfloor\\,,$ which includes all terms for which $\\,x^{1/n} \\ge 2\\,$.\n4. For each approximation $\\,A(x)\\,$ over a set of $\\,m\\,$ sampled points, compute the following error metrics relative to the exact $\\,\\pi(\\lfloor x \\rfloor)\\,$:\n   - Maximum absolute error\n     $$\n     E_{\\max} \\;=\\; \\max_{i} \\left|\\,A(x_i) - \\pi(\\lfloor x_i \\rfloor)\\,\\right|.\n     $$\n   - Root mean square absolute error\n     $$\n     E_{\\mathrm{rms}} \\;=\\; \\sqrt{ \\frac{1}{m} \\sum_{i=1}^{m} \\left( A(x_i) - \\pi(\\lfloor x_i \\rfloor) \\right)^2 }.\n     $$\n   - Maximum relative error\n     $$\n     R_{\\max} \\;=\\; \\max_{i} \\frac{\\left|\\,A(x_i) - \\pi(\\lfloor x_i \\rfloor)\\,\\right|}{\\pi(\\lfloor x_i \\rfloor)}.\n     $$\n   - Mean relative error\n     $$\n     R_{\\mathrm{mean}} \\;=\\; \\frac{1}{m} \\sum_{i=1}^{m} \\frac{\\left|\\,A(x_i) - \\pi(\\lfloor x_i \\rfloor)\\,\\right|}{\\pi(\\lfloor x_i \\rfloor)}.\n     $$\n5. Aggregate the metrics for each approximation in the order $\\,\\left[ \\dfrac{x}{\\log x},\\,\\operatorname{Li}(x),\\,R(x) \\right]\\,$, with each approximation contributing the ordered list $\\,\\left[E_{\\max},\\,E_{\\mathrm{rms}},\\,R_{\\max},\\,R_{\\mathrm{mean}}\\right]\\,$.\n\nUse the following test suite of ranges, each parameterized by $\\,\\left(x_{\\min}, x_{\\max}, m\\right)\\,$:\n- Case 1 (general, wide range): $\\,\\left(10,\\,10^6,\\,64\\right)\\,$.\n- Case 2 (small-$x$ behavior): $\\,\\left(3,\\,10^3,\\,50\\right)\\,$.\n- Case 3 (moderate range, finer sampling): $\\,\\left(10^2,\\,10^5,\\,100\\right)\\,$.\n- Case 4 (near-boundary behavior): $\\,\\left(2,\\,10^2,\\,25\\right)\\,$.\n\nFinal output format specification:\n- Your program should produce a single line of output containing the results as a nested, comma-separated list of lists with no spaces. The outer list contains one entry per test case, in the order given above. Each test case entry is itself a list of three sublists, corresponding to $\\,\\left[ \\dfrac{x}{\\log x},\\,\\operatorname{Li}(x),\\,R(x) \\right]\\,$, and each of those sublists contains four floating-point numbers in the order $\\,\\left[E_{\\max},\\,E_{\\mathrm{rms}},\\,R_{\\max},\\,R_{\\mathrm{mean}}\\right]\\,$. For example, the structure must look like\n$$\n\\big[\\,[\\,[e_{11},e_{12},e_{13},e_{14}],\\,[e_{21},e_{22},e_{23},e_{24}],\\,[e_{31},e_{32},e_{33},e_{34}]\\,],\\,\\dots\\,\\big]\n$$\nprinted as a single line with no spaces, where all $\\,e_{jk}\\,$ are decimal numbers.", "solution": "The experiment is grounded in the standard definitions and facts surrounding the prime-counting function and its analytic approximations. We outline the principles and algorithmic steps that connect these mathematical constructs to a robust computational design.\n\n1. Fundamental definitions and facts.\n   - The prime-counting function $\\,\\pi(x)\\,$ counts the number of primes less than or equal to $\\,x\\,$. For non-integer $\\,x\\,$, defining $\\,\\pi(x) := \\pi(\\lfloor x \\rfloor)\\,$ ensures unambiguous numerical evaluation on real inputs while preserving the monotonic nature of the count function.\n   - By the Prime Number Theorem, $\\,\\pi(x) \\sim \\dfrac{x}{\\log x}\\,$, which motivates $\\,\\dfrac{x}{\\log x}\\,$ as a baseline approximation.\n   - The logarithmic integral $\\,\\operatorname{Li}(x)\\,$ is defined as the Cauchy principal value integral $\\,\\mathrm{PV}\\int_{2}^{x}\\dfrac{dt}{\\log t}\\,$. This avoids the singularity at $\\,t=1\\,$ and yields a numerically stable object that is known to track $\\,\\pi(x)\\,$ more closely in practice.\n   - The Riemann $\\,R(x)\\,$ function is given by the Möbius-weighted series $\\,R(x) = \\sum_{n=1}^{\\infty}\\dfrac{\\mu(n)}{n}\\,\\operatorname{Li}(x^{1/n})\\,$. Truncating the series at $\\,N(x) = \\left\\lfloor \\dfrac{\\log x}{\\log 2} \\right\\rfloor\\,$ includes all terms for which the inner argument $\\,x^{1/n}\\ge 2\\,$; this truncation is natural because $\\,\\operatorname{Li}(y)\\,$ is defined via an integral anchored at $\\,2\\,$, and contributions with $\\,y<2\\,$ are typically small and alternating due to the behavior of $\\,\\mu(n)\\,$.\n\n2. Exact evaluation of $\\,\\pi(\\lfloor x \\rfloor)\\,$ via sieving.\n   - We compute primes up to the largest $\\,x_{\\max}\\,$ in the test suite using the sieve of Eratosthenes, an algorithm justified by the fundamental property that a composite number has a prime factor less than or equal to its square root. Concretely:\n     - Initialize a boolean array $\\,\\texttt{is\\_prime}[0..N]\\,$ as true except for $\\,0\\,$ and $\\,1\\,$.\n     - For each integer $\\,p\\,$ from $\\,2\\,$ up to $\\,\\lfloor \\sqrt{N} \\rfloor\\,$, if $\\,p\\,$ is marked prime, mark all multiples $\\,kp$ with $\\,k\\ge p\\,$ as non-prime.\n     - Form the prefix sum $\\,\\pi(n) = \\sum_{k=2}^{n} \\mathbf{1}_{\\text{prime}(k)}\\,$ to obtain exact counts for all $\\,n\\le N\\,$. This yields $\\,\\pi(\\lfloor x \\rfloor)\\,$ immediately by indexing.\n\n3. Logarithmically spaced sampling.\n   - To probe approximation behavior across scales, we sample points $\\,x_i\\,$ equally spaced in $\\,\\log_{10}(x)\\,$. This captures both small-scale and large-scale behavior without overemphasizing any particular magnitude. Using $\\,m\\,$ samples per range, we form\n     $$\n     x_i \\;=\\; 10^{\\,\\log_{10}(x_{\\min}) \\;+\\; i\\,\\frac{\\log_{10}(x_{\\max}) - \\log_{10}(x_{\\min})}{m-1}}.\n     $$\n   - We then evaluate $\\,\\pi(\\lfloor x_i \\rfloor)\\,$ and the approximations at these points.\n\n4. Numerical evaluation of $\\,\\operatorname{Li}(x)\\,$.\n   - The integral definition $\\,\\mathrm{PV} \\int_{2}^{x} \\dfrac{dt}{\\log t}\\,$ can be evaluated via established special functions. Specifically, one uses the identity\n     $$\n     \\operatorname{Li}(x) \\;=\\; \\operatorname{Ei}(\\log x) \\;-\\; \\operatorname{Ei}(\\log 2),\n     $$\n     where $\\,\\operatorname{Ei}\\,$ is the exponential integral function. This representation follows from the substitution $\\,t = e^{u}\\,$ and transforms the integrand $\\,\\frac{1}{\\log t}\\,$ to $\\,\\frac{1}{u}\\,$, with the principal value handling the logarithmic singularity appropriately. This identity is standard and numerically stable for $\\,x>0\\,$.\n\n5. Möbius function $\\,\\mu(n)\\,$ and truncation for $\\,R(x)\\,$.\n   - The Möbius function is defined by $\\,\\mu(1)=1\\,$, $\\,\\mu(n)=0\\,$ if $\\,n\\,$ is divisible by a square, and otherwise $\\,\\mu(n)=(-1)^{k}\\,$ where $\\,k\\,$ is the number of distinct prime factors of $\\,n\\,$. For small $\\,n\\,$, we can compute $\\,\\mu(n)\\,$ by trial division since the truncation index $\\,N(x)\\,$ is modest for the ranges considered. The truncated sum\n     $$\n     R_N(x) \\;=\\; \\sum_{n=1}^{N(x)} \\frac{\\mu(n)}{n}\\,\\operatorname{Li}\\!\\left(x^{1/n}\\right)\n     $$\n     retains the principal contributions while keeping computation tractable.\n\n6. Error metrics.\n   - For each approximation $\\,A(x)\\,$ over $\\,m\\,$ sample points, we quantify deviations from exact counts with four metrics:\n     - Maximum absolute error $E_{\\max} = \\max \\left|A(x_i)-\\pi(\\lfloor x_i \\rfloor)\\right|$ captures worst-case deviation.\n     - Root mean square absolute error $E_{\\mathrm{rms}} = \\sqrt{\\frac{1}{m}\\sum \\left(A(x_i)-\\pi(\\lfloor x_i \\rfloor)\\right)^2}$ summarizes typical error magnitude penalizing large deviations.\n     - Maximum relative error $R_{\\max} = \\max \\frac{\\left|A(x_i)-\\pi(\\lfloor x_i \\rfloor)\\right|}{\\pi(\\lfloor x_i \\rfloor)}$ contextualizes worst-case error relative to the scale of $\\,\\pi(x)\\,$.\n     - Mean relative error $R_{\\mathrm{mean}} = \\frac{1}{m}\\sum \\frac{\\left|A(x_i)-\\pi(\\lfloor x_i \\rfloor)\\right|}{\\pi(\\lfloor x_i \\rfloor)}$ provides an average relative discrepancy.\n\n7. Test suite design.\n   - Case 1 $\\,\\left(10,\\,10^6,\\,64\\right)\\,$ is a wide-range \"happy path\" testing both small and large $\\,x\\,$.\n   - Case 2 $\\,\\left(3,\\,10^3,\\,50\\right)\\,$ focuses on small $\\,x\\,$ where approximations are less accurate and singular behavior near $\\,x=2\\,$ matters.\n   - Case 3 $\\,\\left(10^2,\\,10^5,\\,100\\right)\\,$ uses finer sampling over a moderate range to test stability and convergence of metrics.\n   - Case 4 $\\,\\left(2,\\,10^2,\\,25\\right)\\,$ examines near-boundary behavior starting at the anchor of the logarithmic integral.\n\n8. Output aggregation.\n   - For each case, we return the three approximation metric lists in the fixed order $\\,\\left[ \\dfrac{x}{\\log x},\\,\\operatorname{Li}(x),\\,R(x) \\right]\\,$, with each list containing $\\,\\left[E_{\\max},\\,E_{\\mathrm{rms}},\\,R_{\\max},\\,R_{\\mathrm{mean}}\\right]\\,$. The program prints a single line containing the nested list for all cases, with elements comma-separated and no spaces, in the exact order specified.\n\nThis design adheres to the mathematical foundations of the prime-counting function and its approximations, employs numerically sound evaluation techniques, and provides comprehensive error quantification across carefully chosen test scenarios. The sieve ensures exact counts, special functions handle the integral reliably, and the truncation of $\\,R(x)\\,$ balances accuracy and computational efficiency. The final output specification enables deterministic validation by automated test harnesses.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special as spsp\n\ndef logarithmic_space(x_min: float, x_max: float, m: int) -> np.ndarray:\n    \"\"\"Create m points spaced equally in log10 between x_min and x_max.\"\"\"\n    return np.logspace(np.log10(x_min), np.log10(x_max), num=m)\n\ndef prime_pi_array(N: int) -> np.ndarray:\n    \"\"\"\n    Compute pi(n) for all n <= N using the sieve of Eratosthenes and prefix sums.\n    Returns an array pi where pi[n] = number of primes <= n.\n    \"\"\"\n    if N < 2:\n        # Handle trivial case\n        pi = np.zeros(N + 1, dtype=int)\n        return pi\n    is_prime = np.ones(N + 1, dtype=bool)\n    is_prime[:2] = False\n    limit = int(np.sqrt(N))\n    for p in range(2, limit + 1):\n        if is_prime[p]:\n            start = p * p\n            is_prime[start:N + 1:p] = False\n    pi = np.cumsum(is_prime.astype(int))\n    return pi\n\ndef li_offset(x: float) -> float:\n    \"\"\"\n    Compute Li(x) defined as PV ∫_2^x dt / log t via special function:\n    Li(x) = Ei(log x) - Ei(log 2). This is valid for x > 0.\n    \"\"\"\n    return float(spsp.expi(np.log(x)) - spsp.expi(np.log(2.0)))\n\ndef mobius_values_up_to(K: int) -> np.ndarray:\n    \"\"\"\n    Compute the Möbius function mu(n) for n = 1..K using trial division.\n    mu(1) = 1; mu(n) = 0 if n has a squared prime factor; otherwise mu(n) = (-1)^k\n    where k is the number of distinct prime factors.\n    \"\"\"\n    mu = np.zeros(K + 1, dtype=int)\n    if K >= 1:\n        mu[1] = 1\n    for n in range(2, K + 1):\n        num = n\n        parity = 0\n        square_free = True\n        p = 2\n        while p * p <= num:\n            if num % p == 0:\n                cnt = 0\n                while num % p == 0:\n                    num //= p\n                    cnt += 1\n                if cnt > 1:\n                    square_free = False\n                    break\n                parity ^= 1\n            p = 3 if p == 2 else p + 2  # move to next odd after 2\n        if square_free:\n            # Remaining factor if >1 is prime\n            if num > 1:\n                parity ^= 1\n            mu[n] = -1 if parity == 1 else 1\n        else:\n            mu[n] = 0\n    return mu\n\ndef riemann_R_truncated(x: float, mu: np.ndarray) -> float:\n    \"\"\"\n    Compute truncated R(x) = sum_{n=1}^{N(x)} mu(n)/n * Li(x^{1/n}),\n    with N(x) = floor(log(x)/log(2)), N >= 1.\n    \"\"\"\n    if x <= 1.0:\n        # For completeness; Li is not used below 2 in our test suite, but handle gracefully.\n        return 0.0\n    N = int(np.floor(np.log(x) / np.log(2.0)))\n    if N < 1:\n        N = 1\n    # Ensure mu array is large enough\n    if len(mu) - 1 < N:\n        mu = mobius_values_up_to(N)\n    total = 0.0\n    for n in range(1, N + 1):\n        term_arg = x ** (1.0 / n)\n        total += (mu[n] / n) * li_offset(term_arg)\n    return float(total)\n\ndef compute_metrics(approx_values: np.ndarray, exact_values: np.ndarray) -> list:\n    \"\"\"\n    Compute [E_max, E_rms, R_max, R_mean] for a set of approximations vs exact values.\n    \"\"\"\n    errors = approx_values - exact_values\n    abs_errors = np.abs(errors)\n    E_max = float(np.max(abs_errors))\n    E_rms = float(np.sqrt(np.mean(abs_errors ** 2)))\n    # Relative errors: exact_values are pi(x) >= 1 for x >= 2 in our test sets\n    rel_errors = abs_errors / exact_values\n    R_max = float(np.max(rel_errors))\n    R_mean = float(np.mean(rel_errors))\n    return [E_max, E_rms, R_max, R_mean]\n\ndef serialize_no_spaces(obj) -> str:\n    \"\"\"\n    Serialize nested lists of numbers into a string with no spaces, e.g., [[1.0,2.0],[3.0,4.0]] -> '[[1.0,2.0],[3.0,4.0]]'\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(serialize_no_spaces(el) for el in obj) + \"]\"\n    elif isinstance(obj, (int, np.integer)):\n        return str(int(obj))\n    elif isinstance(obj, (float, np.floating)):\n        # Use repr to avoid scientific notation edge cases; keep concise\n        return str(float(obj))\n    else:\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement: (x_min, x_max, m)\n    test_cases = [\n        (10.0, 1_000_000.0, 64),  # Case 1\n        (3.0, 1_000.0, 50),       # Case 2\n        (100.0, 100_000.0, 100),  # Case 3\n        (2.0, 100.0, 25),         # Case 4\n    ]\n\n    # Precompute pi(n) up to the largest x_max across all test cases (floor)\n    max_x = int(max(case[1] for case in test_cases))\n    pi_prefix = prime_pi_array(max_x)\n\n    results_all_cases = []\n\n    # Precompute a sufficiently large Möbius table for worst-case truncation.\n    # For max_x, N(x) ~ floor(log(max_x)/log(2))\n    max_N = int(np.floor(np.log(max_x) / np.log(2.0)))\n    mu_table = mobius_values_up_to(max_N)\n\n    for (x_min, x_max, m) in test_cases:\n        xs = logarithmic_space(x_min, x_max, m)\n        floors = np.floor(xs).astype(int)\n        floors = np.clip(floors, 0, max_x)  # safety\n        exact = pi_prefix[floors]\n\n        # Compute approximations\n        # A1: x / log x\n        with np.errstate(divide='ignore', invalid='ignore'):\n            approx_x_over_log = xs / np.log(xs)\n\n        # A2: Li(x)\n        approx_li = np.array([li_offset(float(x)) for x in xs], dtype=float)\n\n        # A3: R(x) truncated\n        approx_R = np.array([riemann_R_truncated(float(x), mu_table) for x in xs], dtype=float)\n\n        # Compute metrics for each approximation\n        metrics_x_over_log = compute_metrics(approx_x_over_log, exact)\n        metrics_li = compute_metrics(approx_li, exact)\n        metrics_R = compute_metrics(approx_R, exact)\n\n        case_results = [metrics_x_over_log, metrics_li, metrics_R]\n        results_all_cases.append(case_results)\n\n    # Final print statement in the exact required format (no spaces).\n    print(serialize_no_spaces(results_all_cases))\n\nsolve()\n```", "id": "3092945"}]}