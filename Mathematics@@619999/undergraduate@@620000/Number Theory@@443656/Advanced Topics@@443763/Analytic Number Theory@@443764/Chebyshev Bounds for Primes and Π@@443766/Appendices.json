{"hands_on_practices": [{"introduction": "The journey into Chebyshev's bounds begins with a simple reality check. Before diving into complex proofs, it is valuable to see how the prime-counting function, $\\pi(x)$, compares to its famous approximation, $\\frac{x}{\\log x}$, for familiar values of $x$. This exercise provides a direct, hands-on feel for the relationship, allowing you to build intuition by calculating the difference between the true count of primes and its celebrated estimate [@problem_id:3083101].", "problem": "Let $\\pi(x)$ denote the prime-counting function that equals the number of primes less than or equal to $x$, let $\\lfloor \\,\\cdot\\, \\rfloor$ denote the floor function, and let $\\log$ denote the natural logarithm. Consider the quantitative comparison suggested by Chebyshev-type bounds between $\\pi(x)$ and $x/\\log x$.\n\nCompute the integer differences\n$$\\Delta(x) \\coloneqq \\pi(x) - \\left\\lfloor \\frac{x}{\\log x} \\right\\rfloor$$\nfor $x \\in \\{10, 100, 1000\\}$, using the standard values of $\\pi(10)$, $\\pi(100)$, and $\\pi(1000)$ that can be obtained by direct counting. Provide your final answer as the row matrix $\\bigl[\\Delta(10)\\ \\Delta(100)\\ \\Delta(1000)\\bigr]$.\n\nThen, starting from the definitions of $\\pi(x)$, $\\lfloor \\,\\cdot\\, \\rfloor$, and the natural logarithm, and using only the qualitative content of Chebyshev’s bounds (that $\\pi(x)$ is trapped between constant multiples of $x/\\log x$ for sufficiently large $x$), discuss the numerical trend suggested by your computations. No rounding instruction is needed for the final answer since it is integral.", "solution": "We recall the definitions: $\\pi(x)$ counts primes up to $x$, $\\lfloor y \\rfloor$ is the greatest integer less than or equal to $y$, and $\\log$ is the natural logarithm. Chebyshev’s bounds assert that there exist absolute constants $A$ and $B$ and a threshold $x_{0}$ such that for all $x \\ge x_{0}$ one has\n$$A \\frac{x}{\\log x} \\le \\pi(x) \\le B \\frac{x}{\\log x}.$$\nThis situates $\\pi(x)$ on the same scale as $x/\\log x$, motivating numerical comparison for specific $x$.\n\nStep 1: Evaluate $\\pi(10)$, $\\pi(100)$, and $\\pi(1000)$ by direct counting of primes. These are standard values:\n- The primes up to $10$ are $2,3,5,7$, hence $\\pi(10)=4$.\n- It is a classical computation (by enumeration or sieve) that $\\pi(100)=25$.\n- Similarly, one finds $\\pi(1000)=168$.\n\nStep 2: Compute $\\left\\lfloor \\dfrac{x}{\\log x} \\right\\rfloor$ for $x \\in \\{10, 100, 1000\\}$. We use that $\\log(100)=2\\log(10)$ and $\\log(1000)=3\\log(10)$, together with a sufficiently accurate evaluation of $\\log(10)$ to determine the floors unambiguously.\n- For $x=10$: $\\log(10) \\approx 2.302585093$, hence\n$$\\frac{10}{\\log(10)} \\approx \\frac{10}{2.302585093} \\approx 4.342944819,$$\nso $\\left\\lfloor \\dfrac{10}{\\log(10)} \\right\\rfloor = 4$.\n- For $x=100$: $\\log(100)=2\\log(10) \\approx 4.605170186$, hence\n$$\\frac{100}{\\log(100)} \\approx \\frac{100}{4.605170186} \\approx 21.71472410,$$\nso $\\left\\lfloor \\dfrac{100}{\\log(100)} \\right\\rfloor = 21$.\n- For $x=1000$: $\\log(1000)=3\\log(10) \\approx 6.907755279$, hence\n$$\\frac{1000}{\\log(1000)} \\approx \\frac{1000}{6.907755279} \\approx 144.7648273,$$\nso $\\left\\lfloor \\dfrac{1000}{\\log(1000)} \\right\\rfloor = 144$.\n\nStep 3: Form the differences $\\Delta(x)=\\pi(x)-\\left\\lfloor \\dfrac{x}{\\log x} \\right\\rfloor$.\n- For $x=10$: $\\Delta(10)=\\pi(10)-\\left\\lfloor \\dfrac{10}{\\log(10)} \\right\\rfloor = 4-4=0$.\n- For $x=100$: $\\Delta(100)=\\pi(100)-\\left\\lfloor \\dfrac{100}{\\log(100)} \\right\\rfloor = 25-21=4$.\n- For $x=1000$: $\\Delta(1000)=\\pi(1000)-\\left\\lfloor \\dfrac{1000}{\\log(1000)} \\right\\rfloor = 168-144=24$.\n\nThus the requested row matrix is $\\bigl[0\\ 4\\ 24\\bigr]$.\n\nDiscussion of the trend: The values show that $\\pi(x)$ and $x/\\log x$ are on the same scale already for moderate $x$, consistent with Chebyshev’s bounds. The differences $\\Delta(x)$ are nonnegative in these cases and grow as $x$ increases from $10$ to $1000$. Since the floor function subtracts at most $1$, the sign and magnitude of $\\Delta(x)$ primarily reflect the sign and magnitude of $\\pi(x)-(x/\\log x)$. Chebyshev’s bounds do not prescribe the exact sign of $\\pi(x)-(x/\\log x)$, but they do indicate that both quantities grow like $x/\\log x$. The observed growth of $\\Delta(x)$ is therefore compatible with the qualitative statement that $\\pi(x)$ and $x/\\log x$ remain comparable and that their absolute difference can increase with $x$ while staying small relative to $x/\\log x$.", "answer": "$$\\boxed{\\begin{bmatrix}0 & 4 & 24\\end{bmatrix}}$$", "id": "3083101"}, {"introduction": "While theoretical proofs guarantee that $\\pi(x)$ is bounded by multiples of $\\frac{x}{\\log x}$, a natural question arises: what is the 'best' constant we can find empirically? This computational practice challenges you to move beyond verifying given inequalities and instead find the minimal constant $B(N)$ that makes the upper bound $\\pi(x) \\le B(N) \\frac{x}{\\log x}$ hold true across a large range of integers [@problem_id:3083099]. By implementing this search, you will gain insight into the subtle fluctuations of the primes and the behavior of the bounding constant itself.", "problem": "You are tasked with constructing and analyzing an empirical upper bound for the prime-counting function using Chebyshev-style bounds. Let the prime-counting function be defined by $\\,\\pi(x)\\,$ as the number of prime numbers less than or equal to $\\,x\\,$, and let $\\,\\log x\\,$ denote the natural logarithm (base $\\,e\\,$). Chebyshev showed, using arguments based on factorials and properties of binomial coefficients, that $\\,\\pi(x)\\,$ is bounded above and below by constant multiples of $\\,x/\\log x\\,$ for sufficiently large $\\,x\\,$. In this problem you will compute, for finite ranges, the minimal empirical constant that works for all integers up to a given bound.\n\nDefine, for a given integer $\\,N \\ge 2\\,$, the empirical minimal constant\n$$\nB(N) \\;=\\; \\max_{\\,2 \\le x \\le N}\\; \\frac{\\pi(x)\\,\\log x}{x}.\n$$\nObserve that $\\,B(N)\\,$ is the least constant such that\n$$\n\\pi(x) \\;\\le\\; B(N)\\,\\frac{x}{\\log x}\n$$\nholds for all integers $\\,x\\,$ with $\\,2 \\le x \\le N\\,$. Your task is to implement a program that:\n\n- Computes $\\,\\pi(x)\\,$ for all integers $\\,x\\,$ in $[2,N]$ using a correct and efficient method grounded in fundamental number-theoretic definitions.\n- Computes $\\,B(N)\\,$ as the maximum of $\\,\\pi(x)\\log x/x\\,$ over $\\,x = 2,3,\\dots,N\\,$.\n- Produces results for a test suite of values $\\,N\\,$.\n\nUse the following scientific bases and constraints:\n\n- Fundamental definitions: $\\,\\pi(x)\\,$ counts primes $\\,\\le x\\,$, primality is determined by divisibility, and $\\,\\log x\\,$ is the natural logarithm.\n- Well-tested facts: The Sieve of Eratosthenes correctly identifies primes up to a bound $\\,N\\,$ and runs in time $\\,O(N\\log\\log N)\\,$.\n- Angle units and physical units do not apply; ensure $\\,\\log\\,$ is the natural logarithm.\n- The inequality domain is integer $\\,x\\,$ with $\\,2 \\le x \\le N\\,$ to avoid the singularity at $\\,\\log 1 = 0\\,$.\n\nImplement the computation for the following test suite of bounds:\n- $\\,N \\in \\{\\,10,\\,100,\\,1000,\\,10000,\\,100000,\\,1000000\\,\\}\\,$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is $\\,B(N)\\,$ rounded to exactly six decimal places, in the same order as the test suite. For example, the output format must be\n$$\n[\\,B(10),B(100),B(1000),B(10000),B(100000),B(1000000)\\,]\n$$\nwith each $\\,B(N)\\,$ printed to six decimal places and no additional characters or spaces.", "solution": "The problem is valid as it is mathematically well-defined, scientifically grounded in established number theory, and contains all necessary information for a unique solution. The task is to compute the empirical minimal constant $B(N)$ for several values of $N$, where $B(N)$ is defined as\n$$\nB(N) \\;=\\; \\max_{\\,2 \\le x \\le N}\\; \\frac{\\pi(x)\\,\\log x}{x}.\n$$\nHere, $\\pi(x)$ is the prime-counting function, and $\\log x$ is the natural logarithm. The constant $B(N)$ provides the tightest upper bound of the form $\\pi(x) \\le C \\cdot \\frac{x}{\\log x}$ for all integers $x$ in the range $[2, N]$.\n\nThe solution proceeds algorithmically, leveraging principles of computational number theory for efficiency. The test cases are $N \\in \\{10, 100, 1000, 10000, 100000, 1000000\\}$. Since these values of $N$ are nested, we can optimize the computation by performing the most intensive calculations only once for the maximum value, $N_{\\max} = 1000000$.\n\n**Step 1: Prime Number Generation**\nThe foundation for computing $\\pi(x)$ is an efficient method for identifying all prime numbers up to $N_{\\max}$. The Sieve of Eratosthenes is the specified and most appropriate algorithm for this task.\nWe initialize a boolean array, `is_prime`, of size $N_{\\max} + 1$, with all entries from index $2$ onwards set to true, representing that all numbers are initially considered potentially prime. The entries for $0$ and $1$ are marked as false.\nWe then iterate through numbers $p$ starting from $2$ up to $\\sqrt{N_{\\max}}$. If a number $p$ remains marked as prime, we iterate through its multiples ($p^2, p^2+p, p^2+2p, \\dots$) and mark them as not prime. This process correctly eliminates all composite numbers. The time complexity of this step is $O(N_{\\max}\\log\\log N_{\\max})$.\n\n**Step 2: Computation of the Prime-Counting Function $\\pi(x)$**\nThe prime-counting function $\\pi(x)$ is the number of primes less than or equal to $x$. It can be formally defined as:\n$$\n\\pi(x) = \\sum_{p \\le x, p \\text{ is prime}} 1\n$$\nHaving the `is_prime` boolean array from Step 1, we can compute the values of $\\pi(x)$ for all $x \\in [0, N_{\\max}]$ efficiently. We construct an integer array, `pi_values`, where `pi_values[x]` will store $\\pi(x)$. This is achieved by taking the cumulative sum of the `is_prime` array. That is, for $x > 0$,\n$$\n\\text{pi\\_values}[x] = \\text{pi\\_values}[x-1] + (\\text{1 if } x \\text{ is prime, 0 otherwise}).\n$$\nThis provides all necessary $\\pi(x)$ values in a single pass with linear time complexity, $O(N_{\\max})$.\n\n**Step 3: Computation of the Bounding Constant $B(N)$**\nWith the `pi_values` array, we can now compute the function $f(x) = \\frac{\\pi(x)\\log x}{x}$ for every integer $x$ in the specified domain $[2, N_{\\max}]$. Let us denote this sequence of values as $f_x$.\nThe constant $B(N)$ is the maximum value of this function over the interval $[2, N]$.\n$$\nB(N) = \\max\\{f_2, f_3, \\dots, f_N\\}\n$$\nTo efficiently find $B(N)$ for each $N$ in the test suite, we first compute an array of the function values $f_x$ for $x \\in [2, N_{\\max}]$. Then, we can compute the running maximum of this array. Let $B_x = \\max\\{f_2, f_3, \\dots, f_x\\}$. The sequence $B_x$ can be computed iteratively: $B_2 = f_2$ and $B_x = \\max(B_{x-1}, f_x)$ for $x > 2$.\nFor each given $N$ from the test suite, the required value $B(N)$ is simply the pre-computed entry $B_N$ from our running maximum sequence.\n\n**Step 4: Implementation and Final Result Formatting**\nThe described algorithm is implemented in Python using the `numpy` library for efficient array operations. The Sieve, the cumulative sum for $\\pi(x)$, the computation of $f(x)$, and the running maximum are all vectorized operations. The final computed values of $B(N)$ for each $N$ in the test suite $\\{10, 100, 1000, 10000, 100000, 1000000\\}$ are collected and formatted into a single string as specified, with each value rounded to six decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the empirical minimal constant B(N) for a suite of N values.\n    B(N) is the maximum of pi(x)*log(x)/x for integers x in [2, N].\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [10, 100, 1000, 10000, 100000, 1000000]\n    \n    # Set the maximum limit for primate generation from the largest test case.\n    N_max = test_cases[-1]\n\n    # Step 1: Generate primes up to N_max using the Sieve of Eratosthenes.\n    # is_prime[i] will be True if i is prime, False otherwise.\n    is_prime = np.ones(N_max + 1, dtype=bool)\n    is_prime[0:2] = False  # 0 and 1 are not prime.\n    for p in range(2, int(np.sqrt(N_max)) + 1):\n        if is_prime[p]:\n            # Mark all multiples of p as not prime. Start from p*p.\n            is_prime[p*p::p] = False\n\n    # Step 2: Compute the prime-counting function pi(x) for all x <= N_max.\n    # pi_values[x] = pi(x). This is the cumulative sum of the is_prime array.\n    pi_values = np.cumsum(is_prime)\n\n    # Step 3: Compute the function f(x) = pi(x) * log(x) / x for x in [2, N_max].\n    # We create a range for x starting from 2.\n    x_range = np.arange(2, N_max + 1, dtype=np.float64)\n    # Get the corresponding pi(x) values from our precomputed array.\n    pi_of_x = pi_values[2:]\n    # Compute the natural logarithm of x.\n    log_x = np.log(x_range)\n    # Calculate f(x) values.\n    f_values = pi_of_x * log_x / x_range\n\n    # Step 4: Compute the running maximum of f(x). The value at index i will be\n    # the maximum of f(x) for x from 2 up to i+2. This corresponds to B(i+2).\n    running_max_f = np.maximum.accumulate(f_values)\n    \n    # Step 5: Extract the B(N) values for each N in the test suite.\n    results = []\n    for n_val in test_cases:\n        # The index for a given N in the running_max_f array is N-2,\n        # because the array starts its indexing from x=2.\n        b_n = running_max_f[n_val - 2]\n        results.append(b_n)\n\n    # Final print statement in the exact required format.\n    # Each result is rounded to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3083099"}, {"introduction": "The study of prime numbers is rich with connections between different arithmetic functions. This advanced practice explores the fundamental identity linking the prime-counting function $\\pi(x)$ to Chebyshev's first function, $\\theta(x) = \\sum_{p \\le x} \\log p$, via an integral relationship derived from Abel summation [@problem_id:3083112]. By designing and implementing a numerical method to estimate $\\theta(x)$ from the values of $\\pi(x)$, you will apply concepts from calculus to a core problem in number theory, deepening your understanding of the analytical tools used to study primes.", "problem": "You are given the prime counting function $\\pi(x)$ and the first Chebyshev function $\\theta(x)$ defined by $\\pi(x) = \\#\\{p \\text{ prime} : p \\le x\\}$ and $\\theta(x) = \\sum_{p \\le x} \\log p$. A fundamental identity linking these functions, obtained by summation by parts (also known as Abel summation) and the Riemann–Stieltjes integral, is the exact relation\n$$\n\\theta(x) = \\pi(x)\\log x - \\int_{2}^{x} \\frac{\\pi(t)}{t}\\,dt.\n$$\nDesign a numerical method to estimate $\\theta(x)$ using only values of $\\pi(t)$ on a partition of the interval $[2,x]$. The method must be derived from first principles and must produce rigorous lower and upper bounds on the integral based on monotonicity, as well as a point estimate and a computable error bound. Specifically, let $2 = t_{0} < t_{1} < \\cdots < t_{m} = x$ be a partition of $[2,x]$. Use the facts that $\\pi(t)$ is nondecreasing and the integrand $\\pi(t)/t$ is piecewise constant except at prime jump points to justify the bounds\n$$\n\\sum_{k=0}^{m-1} \\pi(t_{k}) \\log\\!\\left(\\frac{t_{k+1}}{t_{k}}\\right) \\le \\int_{2}^{x} \\frac{\\pi(t)}{t}\\,dt \\le \\sum_{k=0}^{m-1} \\pi(t_{k+1}) \\log\\!\\left(\\frac{t_{k+1}}{t_{k}}\\right).\n$$\nFrom these, derive corresponding lower and upper bounds for $\\theta(x)$, and define a midpoint estimator $\\widehat{\\theta}(x)$ together with an explicit error bound. Explain why, when the partition consists of all integers $2,3,\\dots,x$, the method yields the exact value of $\\theta(x)$.\n\nYour program must implement this estimator and evaluate it on the following test suite. In all cases, treat $\\log$ as the natural logarithm and all quantities are pure numbers without physical units.\n\n- Test case $1$ (happy path, fine partition): $x = 200$, partition $t_{k} = k$ for $k \\in \\{2,3,\\dots,200\\}$.\n- Test case $2$ (coarse geometric partition): $x = 1000$, geometric partition defined by $t_{0} = 2$ and $t_{k+1} = \\min(x, \\max(t_{k}+1, \\lfloor r\\, t_{k} \\rfloor))$ with ratio $r = 1.5$, until $t_{m} = x$.\n- Test case $3$ (boundary case): $x = 2$, trivial partition $t_{0} = 2$, $t_{1} = 2$.\n\nFor each test case, compute:\n- The midpoint estimate $\\widehat{\\theta}(x)$ from the partition and $\\pi(t)$ values,\n- The exact $\\theta(x)$ by enumerating primes $\\le x$ and summing $\\log p$,\n- The absolute error $|\\widehat{\\theta}(x) - \\theta(x)|$.\n\nAdditionally, to connect with Chebyshev-type bounds, for $x = 1000$ and $x = 100$, compute whether the inequalities $0.8\\,x \\le \\theta(x) \\le 1.2\\,x$ hold (output a boolean for each $x$). These checks do not assert a theorem; they simply report the truth value for the specified $x$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n$[E_{1},E_{2},E_{3},B_{1000},B_{100}]$,\nwhere $E_{j}$ is the absolute error for test case $j$ as a floating-point number, $B_{1000}$ is the boolean for $x=1000$, and $B_{100}$ is the boolean for $x=100$. No other text should be printed.", "solution": "The problem requires the design and implementation of a numerical method to estimate the first Chebyshev function, $\\theta(x) = \\sum_{p \\le x, p \\text{ prime}} \\log p$, using the exact identity $\\theta(x) = \\pi(x)\\log x - \\int_{2}^{x} \\frac{\\pi(t)}{t}\\,dt$. The method is to be based on a partition of the integration interval $[2,x]$ and must yield rigorous bounds and a point estimate.\n\nLet the partition of the interval $[2,x]$ be $2 = t_{0} < t_{1} < \\cdots < t_{m} = x$. The integral $I = \\int_{2}^{x} \\frac{\\pi(t)}{t}\\,dt$ can be decomposed as a sum over the subintervals:\n$$\nI = \\sum_{k=0}^{m-1} \\int_{t_{k}}^{t_{k+1}} \\frac{\\pi(t)}{t}\\,dt\n$$\n\n**1. Derivation of Integral Bounds**\n\nThe prime-counting function $\\pi(t)$ is a step function that is constant between primes and increases by $1$ at each prime. Consequently, $\\pi(t)$ is a non-decreasing function of $t$. For any subinterval $[t_k, t_{k+1}]$, it holds that for all $t \\in [t_k, t_{k+1}]$,\n$$\n\\pi(t_k) \\le \\pi(t) \\le \\pi(t_{k+1})\n$$\nSince the factor $1/t$ is positive for $t \\in [2, x]$, we can multiply the inequality by $1/t$ without changing the direction of the inequalities:\n$$\n\\frac{\\pi(t_k)}{t} \\le \\frac{\\pi(t)}{t} \\le \\frac{\\pi(t_{k+1})}{t}\n$$\nIntegrating this inequality over the subinterval $[t_k, t_{k+1}]$ yields:\n$$\n\\int_{t_{k}}^{t_{k+1}} \\frac{\\pi(t_k)}{t}\\,dt \\le \\int_{t_{k}}^{t_{k+1}} \\frac{\\pi(t)}{t}\\,dt \\le \\int_{t_{k}}^{t_{k+1}} \\frac{\\pi(t_{k+1})}{t}\\,dt\n$$\nSince $\\pi(t_k)$ and $\\pi(t_{k+1})$ are constants with respect to the integration variable $t$, we can factor them out:\n$$\n\\pi(t_k) \\int_{t_{k}}^{t_{k+1}} \\frac{1}{t}\\,dt \\le \\int_{t_{k}}^{t_{k+1}} \\frac{\\pi(t)}{t}\\,dt \\le \\pi(t_{k+1}) \\int_{t_{k}}^{t_{k+1}} \\frac{1}{t}\\,dt\n$$\nThe integral of $1/t$ is $\\log t$. Thus, $\\int_{t_k}^{t_{k+1}} \\frac{1}{t}\\,dt = \\log(t_{k+1}) - \\log(t_k) = \\log\\left(\\frac{t_{k+1}}{t_k}\\right)$. Substituting this back gives:\n$$\n\\pi(t_k) \\log\\left(\\frac{t_{k+1}}{t_k}\\right) \\le \\int_{t_{k}}^{t_{k+1}} \\frac{\\pi(t)}{t}\\,dt \\le \\pi(t_{k+1}) \\log\\left(\\frac{t_{k+1}}{t_k}\\right)\n$$\nSumming these inequalities over all subintervals from $k=0$ to $k=m-1$, we obtain the required bounds for the total integral $I$:\n$$\n\\underbrace{\\sum_{k=0}^{m-1} \\pi(t_{k}) \\log\\left(\\frac{t_{k+1}}{t_{k}}\\right)}_{I_L} \\le I \\le \\underbrace{\\sum_{k=0}^{m-1} \\pi(t_{k+1}) \\log\\left(\\frac{t_{k+1}}{t_{k}}\\right)}_{I_U}\n$$\nHere, $I_L$ is the lower bound and $I_U$ is the upper bound for the integral $I$.\n\n**2. Derivation of Bounds for $\\theta(x)$**\n\nThe identity connecting $\\theta(x)$ and the integral $I$ is $\\theta(x) = \\pi(x)\\log x - I$. We can use the bounds on $I$ to establish bounds on $\\theta(x)$.\nFrom $I_L \\le I \\le I_U$, we multiply by $-1$ to get $-I_U \\le -I \\le -I_L$. Adding the term $\\pi(x)\\log x$ to all parts of the inequality gives:\n$$\n\\pi(x)\\log x - I_U \\le \\pi(x)\\log x - I \\le \\pi(x)\\log x - I_L\n$$\nThis provides the lower bound $\\theta_L(x)$ and upper bound $\\theta_U(x)$ for $\\theta(x)$:\n$$\n\\theta_L(x) = \\pi(x)\\log x - I_U \\le \\theta(x) \\le \\pi(x)\\log x - I_L = \\theta_U(x)\n$$\n\n**3. Midpoint Estimator and Error Bound**\n\nA natural choice for a point estimate of the integral $I$ is the midpoint of its bounding interval $[I_L, I_U]$, which we denote as $\\widehat{I}$:\n$$\n\\widehat{I} = \\frac{I_L + I_U}{2}\n$$\nSubstituting this estimate into the identity for $\\theta(x)$ gives the midpoint estimator $\\widehat{\\theta}(x)$:\n$$\n\\widehat{\\theta}(x) = \\pi(x)\\log x - \\widehat{I} = \\pi(x)\\log x - \\frac{I_L + I_U}{2}\n$$\nThe value of $\\widehat{\\theta}(x)$ is the midpoint of the interval $[\\theta_L(x), \\theta_U(x)]$. The absolute error of this estimate, $|\\widehat{\\theta}(x) - \\theta(x)|$, is bounded by half the width of this interval. The width is:\n$$\n\\theta_U(x) - \\theta_L(x) = (\\pi(x)\\log x - I_L) - (\\pi(x)\\log x - I_U) = I_U - I_L\n$$\nTherefore, the error is bounded by:\n$$\n|\\widehat{\\theta}(x) - \\theta(x)| \\le \\frac{\\theta_U(x) - \\theta_L(x)}{2} = \\frac{I_U - I_L}{2}\n$$\nThis provides an explicit, computable error bound for the midpoint estimator:\n$$\n\\text{Error Bound} = \\frac{1}{2} \\sum_{k=0}^{m-1} \\left(\\pi(t_{k+1}) - \\pi(t_k)\\right) \\log\\left(\\frac{t_{k+1}}{t_k}\\right)\n$$\nThe term $\\pi(t_{k+1}) - \\pi(t_k)$ counts the number of primes in the interval $(t_k, t_{k+1}]$. The error bound is thus determined by the density of primes and the width of the partition intervals on a logarithmic scale.\n\n**4. Analysis of the Integer Partition Case**\n\nConsider the special case where $x$ is an integer and the partition consists of all integers from $2$ to $x$: $t_k = k+2$ for $k=0, \\dots, x-2$. The intervals are of the form $[k, k+1]$ for $k=2, \\dots, x-1$.\n\nWithin any such interval $[k, k+1)$ for $t$, the function $\\pi(t)$ is constant and equal to $\\pi(k)$, since no integer between $k$ and $k+1$ can be prime. Therefore, the integral over this subinterval is:\n$$\n\\int_{k}^{k+1} \\frac{\\pi(t)}{t}\\,dt = \\int_{k}^{k+1} \\frac{\\pi(k)}{t}\\,dt = \\pi(k) \\int_{k}^{k+1} \\frac{1}{t}\\,dt = \\pi(k) \\log\\left(\\frac{k+1}{k}\\right)\n$$\nThe lower sum for the integral, $I_L$, for this partition is:\n$$\nI_L = \\sum_{k=2}^{x-1} \\pi(k) \\log\\left(\\frac{k+1}{k}\\right)\n$$\nThis sum exactly matches the sum of the exact integrals over each subinterval. Thus, for the integer partition, the lower bound $I_L$ is identical to the true value of the integral $I$:\n$$\nI_L = \\sum_{k=2}^{x-1} \\int_{k}^{k+1} \\frac{\\pi(t)}{t} dt = \\int_{2}^{x} \\frac{\\pi(t)}{t} dt = I\n$$\nConsequently, the upper bound for $\\theta(x)$, $\\theta_U(x) = \\pi(x)\\log x - I_L$, becomes exact:\n$$\n\\theta_U(x) = \\pi(x)\\log x - I = \\theta(x)\n$$\nThis means that \"the method\"—the proposed framework of computing bounds—yields the exact value of $\\theta(x)$ as its upper bound estimate, $\\theta_U(x)$, when an integer partition is used. The midpoint estimator $\\widehat{\\theta}(x)$ will not be exact unless $I_U = I_L$, which requires no primes in $(2, x]$, an absurdity. The absolute error of the midpoint estimate is $|\\widehat{\\theta}(x) - \\theta(x)| = |\\frac{\\theta_L(x)+\\theta_U(x)}{2} - \\theta_U(x)| = \\frac{\\theta_U(x)-\\theta_L(x)}{2} = \\frac{I_U-I_L}{2}$, which is precisely the a priori error bound.\n\n**5. Numerical Algorithm**\nThe implementation will follow these steps:\n1.  Generate all prime numbers up to the maximum required value of $x$ (which is $1000$) using a sieve.\n2.  Create a function `pi(t)` that, given a number $t$, efficiently finds the number of primes less than or equal to $t$. This can be done using binary search on the list of pre-computed primes.\n3.  For each test case $(x, \\text{partition})$:\n    a. Generate the specified partition array $T = [t_0, t_1, \\dots, t_m]$.\n    b. Compute an array of $\\pi$ values: $P = [\\pi(t_0), \\pi(t_1), \\dots, \\pi(t_m)]$.\n    c. Compute the lower and upper integral bounds $I_L$ and $I_U$ using vector operations on $P$ and $T$.\n    d. Calculate the midpoint estimate $\\widehat{\\theta}(x) = \\pi(x)\\log x - (I_L + I_U)/2$.\n    e. Calculate the exact value $\\theta(x)$ by summing the logarithms of primes up to $x$.\n    f. Compute the absolute error $E = |\\widehat{\\theta}(x) - \\theta(x)|$.\n4.  For the Chebyshev bound checks, compute $\\theta(1000)$ and $\\theta(100)$ and evaluate the given inequalities.\n5.  Format all results into the specified final output string.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing the numerical method for theta(x),\n    evaluating it on the test cases, and performing the required checks.\n    \"\"\"\n\n    # Step 1: Generate primes using a sieve up to the max required value.\n    MAX_N = 1000\n    primes = _sieve_of_eratosthenes(MAX_N)\n\n    # Step 2: Create a pi(x) function.\n    def pi(x, precomputed_primes):\n        \"\"\"Counts primes less than or equal to x using binary search.\"\"\"\n        if x < 2:\n            return 0\n        return np.searchsorted(precomputed_primes, x, side='right')\n\n    # Step 3: Implement the numerical estimation method.\n    def estimate_theta(x, partition, _pi_func, precomputed_primes):\n        \"\"\"\n        Estimates theta(x) using the midpoint rule derived from integral bounds.\n        \"\"\"\n        if x < 2:\n            return 0.0, 0.0\n\n        t = np.array(partition, dtype=float)\n        \n        # Handle trivial partition (e.g., [2, 2])\n        if len(t) < 2 or t[0] == t[-1]:\n            I_L, I_U = 0.0, 0.0\n        else:\n            pi_vals = np.array([_pi_func(val, precomputed_primes) for val in t])\n            log_ratios = np.log(t[1:] / t[:-1])\n            I_L = np.sum(pi_vals[:-1] * log_ratios)\n            I_U = np.sum(pi_vals[1:] * log_ratios)\n        \n        I_hat = (I_L + I_U) / 2.0\n        pi_x = _pi_func(x, precomputed_primes)\n        \n        # Guard against log(x) for x < 1, though problem constraints make this safe.\n        log_x = np.log(x) if x > 0 else -np.inf \n        theta_hat = pi_x * log_x - I_hat\n        \n        return theta_hat\n\n    # Helper for exact theta(x)\n    def theta_exact(x, precomputed_primes):\n        \"\"\"Calculates the exact value of theta(x).\"\"\"\n        if x < 2:\n            return 0.0\n        primes_le_x = precomputed_primes[precomputed_primes <= x]\n        if primes_le_x.size == 0:\n            return 0.0\n        return np.sum(np.log(primes_le_x))\n\n    results = []\n    \n    # === Test Case 1 ===\n    x1 = 200.0\n    partition1 = np.arange(2, int(x1) + 1)\n    theta_hat_1 = estimate_theta(x1, partition1, pi, primes)\n    theta_exact_1 = theta_exact(x1, primes)\n    error_1 = np.abs(theta_hat_1 - theta_exact_1)\n    results.append(error_1)\n\n    # === Test Case 2 ===\n    x2 = 1000.0\n    r = 1.5\n    partition2 = [2.0]\n    while partition2[-1] < x2:\n        next_t = min(x2, max(partition2[-1] + 1, np.floor(r * partition2[-1])))\n        partition2.append(next_t)\n    theta_hat_2 = estimate_theta(x2, partition2, pi, primes)\n    theta_exact_2 = theta_exact(x2, primes)\n    error_2 = np.abs(theta_hat_2 - theta_exact_2)\n    results.append(error_2)\n\n    # === Test Case 3 ===\n    x3 = 2.0\n    partition3 = [2.0, 2.0]\n    theta_hat_3 = estimate_theta(x3, partition3, pi, primes)\n    theta_exact_3 = theta_exact(x3, primes)\n    error_3 = np.abs(theta_hat_3 - theta_exact_3)\n    results.append(error_3)\n    \n    # === Chebyshev Bound Checks ===\n    # For x = 1000\n    theta_1000 = theta_exact_2\n    B_1000 = (0.8 * 1000 <= theta_1000 <= 1.2 * 1000)\n    results.append(B_1000)\n    \n    # For x = 100\n    theta_100 = theta_exact(100, primes)\n    B_100 = (0.8 * 100 <= theta_100 <= 1.2 * 100)\n    results.append(B_100)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]},{results[4]}]\")\n\n\ndef _sieve_of_eratosthenes(n):\n    \"\"\"\n    Generates prime numbers up to n using the Sieve of Eratosthenes.\n    Returns a numpy array of primes.\n    \"\"\"\n    if n < 2:\n        return np.array([], dtype=int)\n    primes_bool = np.ones(n + 1, dtype=bool)\n    primes_bool[0:2] = False\n    for i in range(2, int(np.sqrt(n)) + 1):\n        if primes_bool[i]:\n            primes_bool[i*i::i] = False\n    return np.where(primes_bool)[0]\n\nsolve()\n```", "id": "3083112"}]}