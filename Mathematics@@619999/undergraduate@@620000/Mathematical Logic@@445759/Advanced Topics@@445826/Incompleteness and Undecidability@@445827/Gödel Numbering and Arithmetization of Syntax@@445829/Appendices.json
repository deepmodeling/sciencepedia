{"hands_on_practices": [{"introduction": "The first step in arithmetizing syntax is to translate abstract structural properties of formulas into concrete number-theoretic predicates. This exercise challenges you to formalize one of the most fundamental of these properties: determining whether a specific occurrence of a variable is bound. By working through this problem, you will gain hands-on experience with how the abstract parse tree of a formula can be navigated using primitive recursive functions to decide logical properties like variable binding [@problem_id:3043163].", "problem": "In a fixed first-order language with variables $v_0, v_1, v_2, \\dots$, suppose we have a standard Gödel numbering that assigns to each well-formed formula a natural number code $x$. Positions in the parse tree of the coded formula are represented by finite sequences of child indices, encoded by the prime-power scheme: the sequence $\\langle a_0, a_1, \\dots, a_{n-1} \\rangle$ is coded as $\\prod_{k < n} p_k^{a_k + 1}$, where $p_k$ is the $k$-th prime. For such codings, it is a standard fact that the basic sequence operations (length, element at index, concatenation, prefix) and the syntactic predicates that check whether a node at a given address is a particular symbol (for example, a variable $v_i$ or a quantifier $(\\forall v_i)$ or $(\\exists v_i)$) are primitive recursive.\n\nAssume that in the parse tree, a quantifier node $(Q v_i)$, with $Q \\in \\{\\forall, \\exists\\}$, is labeled by the pair $\\langle Q, i \\rangle$ and has exactly one child, which is the root of its scope. The label of a variable node is the pair $\\langle \\mathrm{var}, i \\rangle$. Let $\\mathrm{IsVar}(x,p,i)$ be the primitive recursive predicate that holds if and only if the node of the parse tree of the formula coded by $x$ at address $p$ is labeled $\\langle \\mathrm{var}, i \\rangle$. Let $\\mathrm{IsQuant}(x,q,i)$ be the primitive recursive predicate that holds if and only if the node at address $q$ is labeled $\\langle Q, i \\rangle$ for some $Q \\in \\{\\forall, \\exists\\}$. Let $\\mathrm{Prefix}(q,p)$ be the primitive recursive predicate that holds if and only if the address $q$ is a prefix of the address $p$ (so the node at $q$ is an ancestor of the node at $p$).\n\nWe want a primitive recursive predicate $\\mathrm{BoundAt}(x,i,p)$ that is intended to hold if and only if the occurrence of $v_i$ at address $p$ in the parse tree of the formula coded by $x$ is bound, in the usual sense of first-order logic, namely that along the unique path from that node to the root there appears a quantifier $(\\forall v_i)$ or $(\\exists v_i)$ whose scope contains the occurrence.\n\nWhich of the following is a correct primitive recursive specification of $\\mathrm{BoundAt}(x,i,p)$ using a path through the parse tree?\n\nA. $\\mathrm{BoundAt}(x,i,p)$ is defined to hold if and only if $\\mathrm{IsVar}(x,p,i)$ and there exists $q \\le p$ such that $\\mathrm{Prefix}(q,p)$ and $\\mathrm{IsQuant}(x,q,i)$.\n\nB. $\\mathrm{BoundAt}(x,i,p)$ is defined to hold if and only if $\\mathrm{IsVar}(x,p,i)$ and the parent of $p$ (i.e., the unique $q$ with $\\mathrm{Prefix}(q,p)$ and $\\mathrm{len}(q) = \\mathrm{len}(p) - 1$) satisfies $\\mathrm{IsQuant}(x,q,i)$.\n\nC. $\\mathrm{BoundAt}(x,i,p)$ is defined to hold if and only if $\\mathrm{IsVar}(x,p,i)$ and for all $q \\preceq p$ (i.e., all $q$ with $\\mathrm{Prefix}(q,p)$) we have $\\lnot \\mathrm{IsQuant}(x,q,i)$.\n\nD. $\\mathrm{BoundAt}(x,i,p)$ is defined to hold if and only if $\\mathrm{IsVar}(x,p,i)$ and there exists $q \\preceq p$ such that $\\mathrm{IsQuant}(x,q,j)$ for some $j$ (possibly $j \\ne i$).\n\nHere, $\\le$ is the usual order on $\\mathbb{N}$ and $\\preceq$ abbreviates the $\\mathrm{Prefix}$ relation. Assume all auxiliary notions mentioned are encoded in the usual primitive recursive way via the chosen Gödel numbering and sequence coding.", "solution": "We begin from the fundamental definitions of primitive recursive functions and predicates: they are generated from the zero function, successor function, and projections by composition and primitive recursion, and are closed under bounded search (bounded existential and universal quantification) when the bounding term is primitive recursive. It is a standard result in arithmetization of syntax that, for a fixed Gödel numbering of first-order formulas and a fixed coding of finite sequences, the following are primitive recursive: the set of codes of well-formed formulas, the relation that a sequence code $p$ is a valid address in the parse tree of the formula with code $x$, the function retrieving the label at a node, and the predicates $\\mathrm{IsVar}(x,p,i)$ and $\\mathrm{IsQuant}(x,q,i)$. Furthermore, for prime-power sequence coding, sequence operations such as length, prefix, and element access are primitive recursive. Therefore, conjunctions and bounded quantifications over such relations stay within the primitive recursive class.\n\nThe intended meaning of $\\mathrm{BoundAt}(x,i,p)$ is: the node at address $p$ is a variable $v_i$, and somewhere along the path from that node up to the root there appears a quantifier binding $v_i$. In our tree model, a quantifier node $(Q v_i)$, with $Q \\in \\{\\forall, \\exists\\}$, has exactly one child, which is the root of its scope. Thus, an occurrence of $v_i$ at address $p$ is in the scope of a quantifier $(Q v_i)$ at address $q$ if and only if $q$ is a prefix of $p$. Hence the natural formalization is:\n$$\n\\mathrm{BoundAt}(x,i,p) \\;\\equiv\\; \\mathrm{IsVar}(x,p,i) \\,\\wedge\\, \\exists q \\text{ with } \\mathrm{Prefix}(q,p) \\text{ and } \\mathrm{IsQuant}(x,q,i).\n$$\nTo ensure primitive recursiveness, we express the existential quantifier as bounded. One simple bound is the numerical inequality $q \\le p$, which is sufficient because any code $q$ of a prefix of $p$ is a divisor of $p$ in the prime-power scheme and therefore satisfies $q \\le p$; scanning all $q \\le p$ and testing $\\mathrm{Prefix}(q,p)$ is a bounded search over a primitive recursive predicate. Alternatively, one could bound by the length of $p$, viewing $q$ as the code of some prefix of length at most $\\mathrm{len}(p)$; both bounds are primitive recursive. The key point is that the search over all ancestors is finite and primitive recursive because the number of prefixes of $p$ is at most $\\mathrm{len}(p) + 1$.\n\nWe now evaluate each option.\n\nOption A: $\\mathrm{BoundAt}(x,i,p)$ holds iff $\\mathrm{IsVar}(x,p,i)$ and there exists $q \\le p$ with $\\mathrm{Prefix}(q,p)$ and $\\mathrm{IsQuant}(x,q,i)$. This exactly captures the intended condition: the variable at $p$ is $v_i$, and there is some ancestor $q$ labeled by a quantifier over $v_i$. The existential quantification is bounded by $q \\le p$ and the inner test $\\mathrm{Prefix}(q,p) \\wedge \\mathrm{IsQuant}(x,q,i)$ is primitive recursive. Therefore, this definition is both correct in meaning and primitive recursive. Verdict: Correct.\n\nOption B: $\\mathrm{BoundAt}(x,i,p)$ holds iff the parent of $p$ is a quantifier over $v_i$. This is too restrictive. In general, a bound occurrence of $v_i$ need not be immediately under a quantifier node; it can be nested under connectives or function symbols within the quantifier’s scope. For example, in the formula $(\\forall v_i)\\,(R(f(v_i)) \\wedge S)$, the occurrence of $v_i$ inside $f(v_i)$ is bound by the quantifier at some ancestor address $q$ strictly above the parent of the variable occurrence. Option B would incorrectly return false in such cases. Verdict: Incorrect.\n\nOption C: $\\mathrm{BoundAt}(x,i,p)$ holds iff the node at $p$ is $v_i$ and there is no ancestor quantifier over $v_i$. This contradicts the usual definition: it asserts the exact opposite of being bound. The absence of such a quantifier characterizes free occurrences of $v_i$, not bound ones. Verdict: Incorrect.\n\nOption D: $\\mathrm{BoundAt}(x,i,p)$ holds iff the node at $p$ is $v_i$ and there exists an ancestor quantifier over some variable $v_j$ (possibly $j \\ne i$). This condition is too weak: it would classify as bound any occurrence of $v_i$ that happens to lie within the scope of some quantifier, even a quantifier over a different variable. For example, in $(\\forall v_7)\\,P(v_3)$, the occurrence of $v_3$ is free, yet there is an ancestor quantifier over $v_7$, so Option D would incorrectly return true. Verdict: Incorrect.\n\nTherefore, the only correct specification among the options is Option A. It uses a path through the parse tree to check whether there exists an ancestor quantifier binding the same variable index, and the resulting predicate is primitive recursive by closure under bounded search and the primitive recursiveness of the syntactic and sequence-coding predicates.", "answer": "$$\\boxed{A}$$", "id": "3043163"}, {"introduction": "Beyond analyzing static formulas, we must also arithmetize their transformations. The most crucial transformation in logic is substitution, but it comes with a subtle danger: variable capture. This practice guides you through the technical requirements for constructing a robust, capture-avoiding substitution function, $\\mathrm{Sub}(x,i,y)$, demonstrating how the algorithmic process of detecting potential conflicts and renaming bound variables can be formalized as a primitive recursive function [@problem_id:3043154].", "problem": "Consider a fixed language of First-Order Logic (FOL) with variables $v_0, v_1, v_2, \\dots$ and a fixed Gödel numbering that assigns to each finite string over the language’s alphabet a natural number such that the decoding functions for position, length, and symbol recognition are all primitive recursive. Assume a standard prime-power coding of finite sequences based on the Fundamental Theorem of Arithmetic (FTA), and that the predicates “$x$ codes a term,” “$x$ codes a formula,” and “$x$ has a bound occurrence of variable $v_i$” are decidable by primitive recursive means. Let $\\mathrm{Free}(x,i)$ be the primitive recursive predicate stating that the formula coded by $x$ has a free occurrence of $v_i$, and let $\\mathrm{Vars}(y)$ denote the finite set of variable indices that occur in the term coded by $y$; both are given by arithmetization of syntax using the fixed Gödel numbering. We aim to construct the capture-avoiding substitution function $\\mathrm{Sub}(x,i,y)$ that outputs the Gödel code of the formula obtained from the formula coded by $x$ by substituting the term coded by $y$ for the variable $v_i$, while avoiding variable capture.\n\nStarting from these foundational assumptions and definitions, analyze the arithmetization of capture-avoiding substitution and the necessity of bound-variable renaming in order to prevent variable capture. In particular, consider how $\\mathrm{Sub}(x,i,y)$ must treat quantifiers and binding constructs to preserve free variables of the substituted term. Based solely on first principles, select all statements below that are correct.\n\nA. If $y$ codes a variable $v_j$ and the formula coded by $x$ contains a quantifier that binds $v_j$ within the scope where $v_i$ is to be replaced, then naive substitution can turn a free occurrence of $v_j$ from $y$ into a bound occurrence in the result. Therefore, capture-avoiding $\\mathrm{Sub}(x,i,y)$ must detect such conflicts and perform a systematic renaming (alpha-conversion) of bound variables in $x$ to fresh variables before substitution.\n\nB. The function $\\mathrm{Sub}(x,i,y)$ can be defined as a primitive recursive function by recursion on the syntactic structure of the code $x$, provided one uses a primitive recursive “fresh-variable” selector such as $1+\\max(\\mathrm{Vars}(x)\\cup \\mathrm{Vars}(y))$ to handle renaming under quantifiers. No appeal to the Axiom of Choice (AC) is required for this arithmetization.\n\nC. If $y$ codes a term whose variables are all distinct from every variable that occurs bound anywhere in the formula coded by $x$, then naive substitution of $y$ for $v_i$ in $x$ cannot cause variable capture.\n\nD. The need to handle renaming of bound variables can be entirely avoided by reserving infinitely many variable symbols and stipulating that $y$ never uses any of the variable symbols that occur bound in $x$, so $\\mathrm{Sub}(x,i,y)$ need not check for bound-variable conflicts.\n\nChoose all that apply.", "solution": "The problem asks for an analysis of the arithmetization of the capture-avoiding substitution function, denoted $\\mathrm{Sub}(x,i,y)$, in first-order logic. This function takes the Gödel number $x$ of a formula $\\phi$, an index $i$ for a variable $v_i$, and the Gödel number $y$ of a term $t$, and it should return the Gödel number of the formula $\\phi[t/v_i]$ where all free occurrences of $v_i$ in $\\phi$ are replaced by $t$, and no free variables in $t$ become bound in the process.\n\nLet $\\phi_x$ denote the formula with Gödel number $x$, $v_i$ the variable with index $i$, and $t_y$ the term with Gödel number $y$. The operation is the substitution of $t_y$ for $v_i$ in $\\phi_x$.\n\nThe central issue is \"variable capture\". A variable $v_j$ is captured if it is free in $t_y$ and the substitution places $t_y$ into the scope of a quantifier that binds $v_j$ (i.e., $\\forall v_j$ or $\\exists v_j$).\nFor example, consider the formula $\\phi_x \\equiv \\exists v_j (v_i = v_j)$ and the term $t_y \\equiv v_j$. The set of free variables in $t_y$ is $\\{v_j\\}$. If we naively substitute $t_y$ for $v_i$ in $\\phi_x$, we get the formula $\\exists v_j (v_j = v_j)$. In the original formula $\\phi_x$, the variable $v_i$ is free. After substituting the term $t_y$, which contains the free variable $v_j$, the meaning of the formula has changed drastically because the free variable $v_j$ from $t_y$ has been \"captured\" by the quantifier $\\exists v_j$.\n\nA correct capture-avoiding substitution procedure must prevent this. The standard method is to rename the bound variable in the quantifier. In the example, we would first rename the bound variable $v_j$ in $\\phi_x$ to a fresh variable, say $v_k$, where $v_k$ does not occur in $\\phi_x$ and does not occur in $t_y$. The formula $\\phi_x$ is logically equivalent to $\\phi'_{x} \\equiv \\exists v_k (v_i = v_k)$. Now, substituting $t_y$ for $v_i$ in $\\phi'_{x}$ yields $\\exists v_k (v_j = v_k)$, which correctly preserves the logical structure. The free variable $v_j$ from the term remains free in the resulting formula.\n\nThe problem states that primitive recursive functions and predicates are available for basic syntactic operations on Gödel numbers, such as parsing, identifying terms and formulas ($\\mathrm{Free}(x,i)$, $\\mathrm{Vars}(y)$, etc.). We must analyze the properties of the full capture-avoiding substitution function $\\mathrm{Sub}(x,i,y)$ based on these assumptions.\n\n**Option-by-Option Analysis**\n\n**A. If $y$ codes a variable $v_j$ and the formula coded by $x$ contains a quantifier that binds $v_j$ within the scope where $v_i$ is to be replaced, then naive substitution can turn a free occurrence of $v_j$ from $y$ into a bound occurrence in the result. Therefore, capture-avoiding $\\mathrm{Sub}(x,i,y)$ must detect such conflicts and perform a systematic renaming (alpha-conversion) of bound variables in $x$ to fresh variables before substitution.**\n\nThis statement accurately describes the canonical scenario of variable capture. Let $\\phi_x$ be the formula coded by $x$, and let's assume it has the structure $\\dots \\forall v_j (\\dots v_i \\dots) \\dots$. The term to be substituted (coded by $y$) is the variable $v_j$. The substitution is for $v_i$. A naive replacement would result in $\\dots \\forall v_j (\\dots v_j \\dots) \\dots$. The substituted $v_j$ (which was free, as it was the entire term being substituted) becomes bound by the quantifier $\\forall v_j$. This is precisely what variable capture is. The remedy described, detecting such conflicts and performing a renaming of the bound variable (a process known as alpha-conversion or alpha-equivalence), is the standard and necessary procedure to implement capture-avoiding substitution correctly. The function $\\mathrm{Sub}(x,i,y)$ must implement this logic.\n\n**Verdict:** Correct.\n\n**B. The function $\\mathrm{Sub}(x,i,y)$ can be defined as a primitive recursive function by recursion on the syntactic structure of the code $x$, provided one uses a primitive recursive “fresh-variable” selector such as $1+\\max(\\mathrm{Vars}(x)\\cup \\mathrm{Vars}(y))$ to handle renaming under quantifiers. No appeal to the Axiom of Choice (AC) is required for this arithmetization.**\n\nThis statement makes two claims: that $\\mathrm{Sub}(x,i,y)$ is primitive recursive, and that its construction is constructive (does not require AC).\n1.  **Primitive Recursiveness:** The function $\\mathrm{Sub}(x,i,y)$ is defined by recursion on the structure of the formula $\\phi_x$. This corresponds to a course-of-values recursion on the Gödel number $x$.\n    *   Base cases (atomic formulas): Substitution is a simple replacement, which is arithmetically a primitive recursive operation on Gödel numbers.\n    *   Recursive steps (connectives): For $\\phi_x = \\neg \\psi_z$ or $\\phi_x = \\psi_{z_1} \\land \\psi_{z_2}$, the result is built from the results of the recursive calls, e.g., $\\mathrm{Sub}(z_1, i, y)$ and $\\mathrm{Sub}(z_2, i, y)$. These compositions are primitive recursive.\n    *   Recursive step (quantifiers): For $\\phi_x = \\forall v_k \\psi_z$.\n        *   If $i=k$, $v_i$ is the bound variable, so no free occurrences exist to be substituted within the scope of this quantifier. The formula is unchanged.\n        *   If $i \\neq k$, we must check for conflict. A conflict occurs if $v_k$ is a free variable in the term $t_y$. This check is $\\exists j \\in \\mathrm{Vars}(y) \\text{ such that } j=k$, which is primitive recursive given the assumptions.\n        *   If there is no conflict, the result is $\\forall v_k (\\text{result of } \\mathrm{Sub}(z, i, y))$. This is a primitive recursive construction.\n        *   If there is a conflict, we must rename $v_k$. We need a \"fresh\" variable index $m$. The proposed selector $m = 1+\\max(\\mathrm{Vars}(x)\\cup \\mathrm{Vars}(y))$ provides such an index. $\\mathrm{Vars}(x)$ and $\\mathrm{Vars}(y)$ are finite sets of indices, so their union is finite and the max and successor operations are primitive recursive. Finding this $m$ is a primitive recursive procedure. Then, we perform two substitutions: first, rename $v_k$ to $v_m$ in $\\psi_z$ to get $\\psi'_{z'}$ (this is a recursive call to $\\mathrm{Sub}(z, k, \\text{code of } v_m)$), and then substitute $t_y$ for $v_i$ in $\\psi'_{z'}$.\n    Since all operations (case analysis, checking for conflicts, selecting a fresh variable, and composing Gödel numbers) are primitive recursive, and the recursion is on the structure of the formula (a well-founded order), the entire function $\\mathrm{Sub}(x,i,y)$ is indeed primitive recursive.\n2.  **Axiom of Choice:** AC is needed when one must make an infinite number of arbitrary choices for which no rule can be given. Here, the choice of a fresh variable is entirely constructive and deterministic. The rule $m = 1+\\max(\\mathrm{Vars}(x)\\cup \\mathrm{Vars}(y))$ provides a specific, computable index $m$. No \"arbitrary choice\" is made. Therefore, the Axiom of Choice is not required.\n\nBoth claims in the statement are correct.\n\n**Verdict:** Correct.\n\n**C. If $y$ codes a term whose variables are all distinct from every variable that occurs bound anywhere in the formula coded by $x$, then naive substitution of $y$ for $v_i$ in $x$ cannot cause variable capture.**\n\nLet $t_y$ be the term coded by $y$ and $\\phi_x$ be the formula coded by $x$. Let $\\mathrm{FreeVars}(t_y)$ be the set of indices of free variables in $t_y$, and $\\mathrm{BoundVars}(\\phi_x)$ be the set of indices of variables bound anywhere in $\\phi_x$. The condition given is $\\mathrm{FreeVars}(t_y) \\cap \\mathrm{BoundVars}(\\phi_x) = \\emptyset$.\nVariable capture occurs when we substitute $t_y$ for a free occurrence of $v_i$ that is within the scope of a quantifier, say $\\forall v_k$, and $v_k \\in \\mathrm{FreeVars}(t_y)$. The variable $v_k$ is, by definition, a bound variable in $\\phi_x$, so $k \\in \\mathrm{BoundVars}(\\phi_x)$. The premise explicitly states that for any such $k$, $k \\notin \\mathrm{FreeVars}(t_y)$. Therefore, the condition for variable capture is never met. A naive substitution, which directly replaces all free occurrences of $v_i$ with $t_y$ without any checks or renaming, would be safe under this strong assumption.\n\n**Verdict:** Correct.\n\n**D. The need to handle renaming of bound variables can be entirely avoided by reserving infinitely many variable symbols and stipulating that $y$ never uses any of the variable symbols that occur bound in $x$, so $\\mathrm{Sub}(x,i,y)$ need not check for bound-variable conflicts.**\n\nThis statement proposes a convention to sidestep the problem of variable capture. The convention is that for any substitution operation $\\mathrm{Sub}(x,i,y)$, the inputs must satisfy the condition $\\mathrm{FreeVars}(t_y) \\cap \\mathrm{BoundVars}(\\phi_x) = \\emptyset$. While following this convention would indeed make naive substitution safe (as established in Option C), it does not \"entirely avoid\" the need to handle renaming in a general-purpose substitution function.\nA formal system often requires substitutions where this condition is not met. For example, in a proof, one might need to instantiate a universally quantified formula $\\forall v_i \\phi$ with a term $t$, yielding $\\phi[t/v_i]$. The choice of $t$ is determined by the logic of the proof, not by a convenient convention. For instance, one might need to substitute $t_y \\equiv v_j$ into a formula $\\phi_x$ which contains $\\forall v_j$ as a subformula. A general substitution function must be powerful enough to handle this case correctly, which requires renaming.\nThe statement makes two problematic claims:\n1.  The need is \"entirely avoided\": This is false. A fully general $\\mathrm{Sub}$ function, as is required for the arithmetization of metamathematics (e.g., for proving Gödel's theorems), must be able to handle all valid inputs $x, i, y$, including those that violate the proposed stipulation. The need is only avoided for a *restricted class* of substitutions.\n2.  $\\mathrm{Sub}(x,i,y)$ \"need not check\": This is also incorrect. To enforce the stipulation, the function would need to check if the condition is met and perhaps halt with an error if it isn't. This is still a check. A true capture-avoiding function does not halt; it performs a renaming. Therefore, the internal logic to detect the conflict must exist, contradicting the claim that it need not check.\nThe existence of infinitely many variables is a prerequisite for renaming, not a way to avoid it. The core problem is algorithmic, not one of resource limitation.\n\n**Verdict:** Incorrect.\n\nFinal summary: Options A, B, and C are correct descriptions of the properties and requirements of capture-avoiding substitution, while Option D proposes an unrealistic convention that fails to solve the general problem.", "answer": "$$\\boxed{ABC}$$", "id": "3043154"}, {"introduction": "The ultimate power of Gödel numbering lies in its ability to represent the very concept of provability within arithmetic. This final practice focuses on the arithmetization of the proof predicate, $\\mathrm{Prf}_T(x,y)$, which asserts that $y$ is the code of a proof of the formula with code $x$. This exercise will help you understand the crucial insight that while finding a proof may be difficult, *verifying* a given proof is a mechanical, finite process, which is why $\\mathrm{Prf}_T$ is primitive recursive and, consequently, the provability predicate $\\mathrm{Prov}_T(x)$ is a $\\Sigma_1$ formula [@problem_id:3043156].", "problem": "Let $L$ be a computable First-Order (FO) language with a fixed Gödel numbering (GN) that assigns to each expression of $L$ a natural number. Let $T$ be an Effectively Axiomatized (EA) theory in $L$, meaning there is a primitive recursive predicate $Ax_T(u)$ that decides whether $u$ is the code of an axiom of $T$. Fix a coding of finite sequences and finite trees by natural numbers using primitive recursive pairing and sequence-decoding functions. For a chosen proof calculus, define the binary predicate $\\mathrm{Prf}_T(x,y)$ to express that $y$ is the code of a $T$-proof of the formula with code $x$, and define the unary predicate $\\mathrm{Prov}_T(x)$ by\n$$\n\\mathrm{Prov}_T(x) \\;\\equiv\\; \\exists y\\, \\mathrm{Prf}_T(x,y).\n$$\nConsider two standard proof calculi for first-order logic over $L$: a Hilbert-style calculus (few inference rules with many axiom schemas) and a natural deduction calculus (tree-shaped derivations with discharged assumptions). Both calculi use only finitely many rule schemas, and each rule applies to a finite tuple of earlier lines or subproofs.\n\nWhich of the following statements are correct?\n\nA. For any EA theory $T$, the predicate $\\mathrm{Prf}_T(x,y)$, defined using either the Hilbert calculus or the natural deduction calculus, is primitive recursive because verifying each proof line or inference is a bounded, syntactic check built from primitive recursive operations; consequently, $\\mathrm{Prov}_T(x)$ is $\\Sigma_1$ in either calculus.\n\nB. The classification of $\\mathrm{Prov}_T(x)$ as a $\\Sigma_1$ formula depends on the Completeness Theorem and therefore can fail for the natural deduction calculus unless one restricts to maximally compact rule sets.\n\nC. There is a primitive recursive function $f$ such that, for any code $y$ of a natural deduction proof of a formula with code $x$, the number $f(y)$ is the code of a Hilbert-style proof of the same formula; hence the two versions of $\\mathrm{Prf}_T$ are extensionally equivalent up to a primitive recursive translation of proof codes.\n\nD. Because natural deduction has rule schemas with infinitely many instances (e.g., quantifier rules that can apply to any formula), $\\mathrm{Prf}_T(x,y)$ cannot be primitive recursive in that system and requires a $\\mu$-recursive check.\n\nE. If $T$ is not decidable as a set of theorems, then $\\mathrm{Prov}_T(x)$ cannot be arithmetized as a $\\Sigma_1$ formula, since deciding whether $y$ codes a valid proof of $x$ requires universal quantification over all lines of the putative proof.", "solution": "The problem statement is a valid exercise in mathematical logic, specifically the arithmetization of syntax and recursion theory. All terms used are standard and well-defined, and the premises are consistent and sufficient for a rigorous analysis.\n\nThe core of the problem revolves around the computability class of the predicates $\\mathrm{Prf}_T(x,y)$ and $\\mathrm{Prov}_T(x)$. Let us analyze this first.\n\nThe predicate $\\mathrm{Prf}_T(x,y)$ formalizes the statement \"$y$ is the Gödel number of a valid proof in theory $T$ of the formula with Gödel number $x$\". To determine if $\\mathrm{Prf}_T(x,y)$ is true for a given pair of natural numbers $(x, y)$, we must perform an algorithmic check on $y$.\n\nThe process of verifying a proof, whether it is a sequence of formulas in a Hilbert-style system or a tree of formulas in a natural deduction system, consists of a finite number of mechanical steps. We are given that the coding of proofs (as sequences or trees) is done using primitive recursive functions. This means that decoding $y$ into its constituent parts (the sequence or tree of formulas) is a primitive recursive operation.\n\nLet's consider the verification procedure for each type of calculus:\n\n1.  **Hilbert-style Calculus:** A proof is a finite sequence of formulas, say $(\\phi_1, \\phi_2, \\ldots, \\phi_n)$. The number $y$ codes this sequence.\n    *   First, we decode $y$ to get the Gödel numbers of $\\phi_1, \\ldots, \\phi_n$. This is a primitive recursive operation.\n    *   We check if the Gödel number of the last formula, $\\phi_n$, is equal to $x$. This is a primitive recursive check.\n    *   We then iterate from $i=1$ to $n$. For each formula $\\phi_i$, we must check if it is valid at that step. This means $\\phi_i$ must be:\n        a.  A logical axiom. There are a finite number of axiom schemas. Checking if a formula is an instance of a given schema is a purely syntactic pattern-matching operation, which is primitive recursive.\n        b.  An axiom of the theory $T$. We are given that $T$ is Effectively Axiomatized, meaning the predicate $Ax_T(u)$ (which checks if $u$ is the code of an axiom of $T$) is primitive recursive.\n        c.  Derived from previous formulas in the sequence using an inference rule (e.g., Modus Ponens). For Modus Ponens, we would check if there exist $j, k < i$ such that $\\phi_k$ is the formula $(\\phi_j \\to \\phi_i)$. This requires searching through a finite number of previous pairs, which is a bounded search. This operation is primitive recursive.\n    *   Since the loop runs for a finite number of steps (the length of the proof, $n$, is determined by $y$), and each check inside the loop is primitive recursive, the entire predicate $\\mathrm{Prf}_T(x,y)$ is primitive recursive. A bounded universal quantifier ($\\forall i < n$) over a primitive recursive relation yields a primitive recursive relation.\n\n2.  **Natural Deduction Calculus:** A proof is a finite tree of formulas. The number $y$ codes this tree.\n    *   We decode $y$ to get the tree structure and the formulas at each node. This is a primitive recursive operation.\n    *   We check that the formula at the root of the tree has Gödel number $x$.\n    *   We verify recursively over the tree structure. For each node, we check that the formula at that node is correctly derived from the formulas at its child nodes according to one of the finite number of inference rule schemas. This involves checking the syntactic form of the formulas and the rule names, which is primitive recursive. We must also manage discharged assumptions correctly, which involves checking annotations on the tree structure, also a primitive recursive task.\n    *   The leaves of the tree must be either axioms of $T$ (checked with the primitive recursive $Ax_T$) or assumptions that are correctly discharged by a rule application higher up in the tree.\n    *   This verification can be defined by recursion on the structure of the proof tree coded by $y$. Since the coding functions are primitive recursive, this corresponds to a course-of-values recursion on $y$, which is a primitive recursive procedure.\n\nIn both cases, the verification of a proof is a finite, syntactic process that can be carried out by an algorithm that always terminates. This algorithm can be constructed using only primitive recursive functions and bounded recursion/iteration. Therefore, the predicate $\\mathrm{Prf}_T(x,y)$ is primitive recursive for any standard proof calculus.\n\nConsequently, the provability predicate, defined as $\\mathrm{Prov}_T(x) \\equiv \\exists y\\, \\mathrm{Prf}_T(x,y)$, involves an unbounded existential quantifier over a primitive recursive predicate. By the definition of the arithmetical hierarchy, this makes $\\mathrm{Prov}_T(x)$ a $\\Sigma_1$ predicate.\n\nNow we evaluate the given options.\n\n**A. For any EA theory $T$, the predicate $\\mathrm{Prf}_T(x,y)$, defined using either the Hilbert calculus or the natural deduction calculus, is primitive recursive because verifying each proof line or inference is a bounded, syntactic check built from primitive recursive operations; consequently, $\\mathrm{Prov}_T(x)$ is $\\Sigma_1$ in either calculus.**\nThis statement is a precise summary of the analysis above. The reasoning that proof-checking is a bounded syntactic check is correct. The conclusion that this makes $\\mathrm{Prf}_T(x,y)$ primitive recursive is correct. The final consequence, that $\\mathrm{Prov}_T(x)$ is therefore $\\Sigma_1$, follows directly from the definition.\n**Verdict: Correct.**\n\n**B. The classification of $\\mathrm{Prov}_T(x)$ as a $\\Sigma_1$ formula depends on the Completeness Theorem and therefore can fail for the natural deduction calculus unless one restricts to maximally compact rule sets.**\nThis statement is incorrect. The classification of $\\mathrm{Prov}_T(x)$ is a result of the arithmetization of *syntax* and computability theory. It concerns the algorithmic complexity of checking proofs. The Completeness Theorem ($\\phi$ is a logical consequence of $T$ if and only if $\\phi$ is provable from $T$) connects syntax to *semantics* (truth in models). The arithmetization of provability does not rely on this connection. The claim about \"maximally compact rule sets\" is an unfounded distraction; standard natural deduction systems are perfectly amenable to arithmetization leading to a $\\Sigma_1$ provability predicate.\n**Verdict: Incorrect.**\n\n**C. There is a primitive recursive function $f$ such that, for any code $y$ of a natural deduction proof of a formula with code $x$, the number $f(y)$ is the code of a Hilbert-style proof of the same formula; hence the two versions of $\\mathrm{Prf}_T$ are extensionally equivalent up to a primitive recursive translation of proof codes.**\nThis statement is correct. It is a standard result in proof theory that common formal systems for first-order logic (like Hilbert-style, Natural Deduction, and Sequent Calculus) prove the same set of theorems and that there are effective algorithms to translate proofs from one system to another. The algorithms for these translations are purely syntactic manipulations. For example, translating a natural deduction proof to a Hilbert-style proof involves systematically eliminating rules like Conditional Proof by using the constructive proof of the Deduction Theorem. This process can be defined by recursion on the structure of the natural deduction proof tree. Such a recursive transformation on Gödel numbers can be formalized as a primitive recursive function. Therefore, there exists a primitive recursive function $f$ that maps the code of an ND proof to the code of an equivalent Hilbert-style proof.\n**Verdict: Correct.**\n\n**D. Because natural deduction has rule schemas with infinitely many instances (e.g., quantifier rules that can apply to any formula), $\\mathrm{Prf}_T(x,y)$ cannot be primitive recursive in that system and requires a $\\mu$-recursive check.**\nThis statement is founded on a misunderstanding. Hilbert-style systems also have axiom schemas with infinitely many instances. The crucial point is that there is a *finite number of schemas*. To check if a given formula is an instance of a schema, one performs a finite, syntactic pattern-matching procedure. This procedure is decidable and, in fact, primitive recursive. It does not require an unbounded search (a $\\mu$-operator). The existence of infinitely many possible instances does not prevent the check for a *given* formula from being primitive recursive.\n**Verdict: Incorrect.**\n\n**E. If $T$ is not decidable as a set of theorems, then $\\mathrm{Prov}_T(x)$ cannot be arithmetized as a $\\Sigma_1$ formula, since deciding whether $y$ codes a valid proof of $x$ requires universal quantification over all lines of the putative proof.**\nThis statement is incorrect for two main reasons. First, the premise does not lead to the conclusion. For any sufficiently strong, consistent, effectively axiomatized theory $T$ (like Peano Arithmetic), the set of its theorems is not decidable (this is a consequence of Gödel's First Incompleteness Theorem). However, its provability predicate $\\mathrm{Prov}_T(x)$ is the canonical example of a $\\Sigma_1$-complete set. So, being undecidable is consistent with being $\\Sigma_1$. Undecidable simply means it is not recursive (i.e., not decidable by an algorithm that halts for all inputs). Second, the reasoning provided is flawed. The \"universal quantification over all lines of the putative proof\" is a *bounded* quantification, because the proof being checked (coded by $y$) is a finite object of a specific length. A bounded universal quantifier over a primitive recursive predicate yields a primitive recursive predicate. It does not make the predicate more complex in the arithmetical hierarchy.\n**Verdict: Incorrect.**\n\nIn summary, statements A and C are correct descriptions of fundamental results in the arithmetization of logic.", "answer": "$$\\boxed{AC}$$", "id": "3043156"}]}