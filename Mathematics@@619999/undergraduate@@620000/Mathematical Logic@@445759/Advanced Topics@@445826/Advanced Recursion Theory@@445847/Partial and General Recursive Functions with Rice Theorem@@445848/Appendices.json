{"hands_on_practices": [{"introduction": "The theory of computation begins by asking a fundamental question: what does it mean for a function to be \"computable\"? This exercise [@problem_id:3048525] takes you back to first principles, demonstrating how familiar arithmetic operations like addition, multiplication, and exponentiation can be rigorously constructed from a very small set of basic functions and rules. By building these functions from the ground up, you will gain a concrete understanding of the class of primitive recursive functions, a cornerstone of computability theory.", "problem": "Work throughout with the standard natural numbers $\\mathbb{N}=\\{0,1,2,\\ldots\\}$ and the class of primitive recursive functions. The class of primitive recursive functions is the smallest class of total functions on $\\mathbb{N}$ that contains the following initial functions and is closed under the following operations:\n- Initial functions:\n  - The zero function $Z:\\mathbb{N}\\to\\mathbb{N}$ defined by $Z(x)=0$.\n  - The successor function $S:\\mathbb{N}\\to\\mathbb{N}$ defined by $S(x)=x+1$.\n  - The projection functions $U_i^n:\\mathbb{N}^n\\to\\mathbb{N}$ defined by $U_i^n(x_1,\\ldots,x_n)=x_i$ for each $n\\in\\mathbb{N}$ and $1\\leq i\\leq n$.\n- Closure under composition: if $g:\\mathbb{N}^m\\to\\mathbb{N}$ and $h_1,\\ldots,h_m:\\mathbb{N}^n\\to\\mathbb{N}$ are in the class, then so is the composition $f:\\mathbb{N}^n\\to\\mathbb{N}$ given by $f(\\vec{x})=g(h_1(\\vec{x}),\\ldots,h_m(\\vec{x}))$.\n- Closure under primitive recursion: if $g:\\mathbb{N}^k\\to\\mathbb{N}$ and $h:\\mathbb{N}^{k+2}\\to\\mathbb{N}$ are in the class, then the function $f:\\mathbb{N}^{k+1}\\to\\mathbb{N}$ obtained by primitive recursion on the last argument, determined uniquely by the equations\n$$\nf(\\vec{x},0)=g(\\vec{x}),\\qquad f(\\vec{x},y+1)=h(\\vec{x},y,f(\\vec{x},y)),\n$$\nis also in the class.\n\nUsing only these initial functions and closure operations, carry out the following tasks from first principles:\n- Precisely specify the scheme of primitive recursion on $\\mathbb{N}$ as used above, including the roles and arities of the functions involved, and argue why it generates a unique total function for each choice of $g$ and $h$.\n- Define the addition function $add:\\mathbb{N}^2\\to\\mathbb{N}$, the multiplication function $mul:\\mathbb{N}^2\\to\\mathbb{N}$, and the exponentiation function $exp:\\mathbb{N}^2\\to\\mathbb{N}$ within the primitive recursive class by exhibiting their construction using only $Z$, $S$, the $U_i^n$, composition, and primitive recursion. Your definitions must not assume any of these functions a priori.\n- Using your constructions, evaluate the expression\n$$\nE \\;=\\; exp(2,3)\\;+\\; mul(3,\\, add(2,2)).\n$$\nGive your final answer as an exact integer with no rounding.", "solution": "The problem as stated is valid. It is a well-posed problem in the field of computability theory, a sub-discipline of mathematical logic. The definitions provided for the class of primitive recursive functions are standard and correct. The tasks are specified clearly, are logically consistent, and require a rigorous application of the provided definitions. The problem is self-contained and free of scientific or factual unsoundness, ambiguity, or subjective elements. We may therefore proceed with a solution.\n\nThe problem asks for three tasks to be completed from first principles, based on the provided definition of primitive recursive functions.\n\n### Part 1: The Scheme of Primitive Recursion\n\nThe scheme of primitive recursion is an operation that defines a new function $f$ from two already-defined functions, $g$ and $h$.\n\n**Specification of the Scheme:**\nLet $k \\in \\mathbb{N}$ be a natural number representing the number of parameters.\n1.  **Input Functions**: The scheme takes two functions, $g$ and $h$, which are assumed to be in the class of primitive recursive functions (and are therefore total functions on their domains).\n    -   $g: \\mathbb{N}^k \\to \\mathbb{N}$ is a function of $k$ arguments. It provides the base case for the recursion. If $k=0$, $g$ is a constant, i.e., an element of $\\mathbb{N}$.\n    -   $h: \\mathbb{N}^{k+2} \\to \\mathbb{N}$ is a function of $k+2$ arguments. It provides the recursive step.\n\n2.  **Output Function**: The scheme generates a new function $f: \\mathbb{N}^{k+1} \\to \\mathbb{N}$. The arguments of $f$ are a vector of $k$ parameters, denoted $\\vec{x} = (x_1, \\ldots, x_k)$, and one recursion variable, $y$.\n\n3.  **Defining Equations**: The function $f$ is uniquely determined by the following two equations for all $\\vec{x} \\in \\mathbb{N}^k$ and $y \\in \\mathbb{N}$:\n    $$\n    f(\\vec{x}, 0) = g(\\vec{x}) \\quad (\\text{Base Case})\n    $$\n    $$\n    f(\\vec{x}, y+1) = h(\\vec{x}, y, f(\\vec{x}, y)) \\quad (\\text{Recursive Step})\n    $$\n    The arguments to $h$ are the parameter vector $\\vec{x}$, the current value of the recursion variable $y$, and the value of the function $f$ at step $y$, namely $f(\\vec{x},y)$.\n\n**Argument for Uniqueness and Totality of $f$**:\nWe must argue that for any choice of primitive recursive (and thus total) functions $g$ and $h$, the function $f$ is a unique, total function on its domain $\\mathbb{N}^{k+1}$. The argument proceeds by mathematical induction on the recursion variable $y$.\n\nLet $\\vec{x} \\in \\mathbb{N}^k$ be any fixed vector of parameters. We will show that $f(\\vec{x}, y)$ is uniquely defined for all $y \\in \\mathbb{N}$.\n\n-   **Base Case ($y=0$)**: The value of $f(\\vec{x}, 0)$ is given by the equation $f(\\vec{x}, 0) = g(\\vec{x})$. Since $g$ is a total function by hypothesis, $g(\\vec{x})$ evaluates to a unique natural number for any given $\\vec{x}$. Therefore, $f(\\vec{x}, 0)$ is uniquely defined.\n\n-   **Inductive Step**: Assume for some $y \\in \\mathbb{N}$ that the value $f(\\vec{x}, y)$ is uniquely defined. We must show that $f(\\vec{x}, y+1)$ is also uniquely defined. The recursive step equation is $f(\\vec{x}, y+1) = h(\\vec{x}, y, f(\\vec{x}, y))$. The arguments to the function $h$ are the triplet $(\\vec{x}, y, f(\\vec{x}, y))$.\n    -   $\\vec{x}$ is our fixed parameter vector.\n    -   $y$ is a natural number.\n    -   $f(\\vec{x}, y)$ is a unique natural number by the inductive hypothesis.\n    Since $h$ is a total function by hypothesis, it produces a unique natural number as output for any valid input tuple. Thus, $h(\\vec{x}, y, f(\\vec{x}, y))$ is uniquely defined. This implies that $f(\\vec{x}, y+1)$ is uniquely defined.\n\n-   **Conclusion**: By the principle of mathematical induction on $y$, $f(\\vec{x}, y)$ is uniquely defined for all $y \\in \\mathbb{N}$ and for all $\\vec{x} \\in \\mathbb{N}^k$. This establishes that $f$ is a total function on $\\mathbb{N}^{k+1}$ and that its definition is unambiguous.\n\n### Part 2: Construction of `add`, `mul`, and `exp`\n\nWe construct these functions using only the initial functions ($Z$, $S$, $U_i^n$) and the operations of composition and primitive recursion.\n\n**1. Addition: $add(x,y) = x+y$**\nAddition is defined by primitive recursion on $y$. The parameter is $x$ ($k=1$).\n-   Base case: $add(x, 0) = x$.\n-   Recursive step: $add(x, y+1) = S(add(x, y))$.\n\nTo formalize this:\n-   The base case function is $g(x) = x$. This is the projection function $U_1^1$. So, $g = U_1^1$.\n-   The recursive step function is $h(x, y, z) = S(z)$, where $z = add(x,y)$. The function $h$ must formally be a function of three variables. We achieve this by composition: $h(x,y,z) = S(U_3^3(x,y,z))$. Since $S$ and $U_3^3$ are initial functions, $h$ is primitive recursive by composition.\n-   Thus, $add: \\mathbb{N}^2 \\to \\mathbb{N}$ is defined by:\n    $$add(x,0) = U_1^1(x)$$\n    $$add(x,y+1) = S(U_3^3(x,y,add(x,y)))$$\n\n**2. Multiplication: $mul(x,y) = x \\cdot y$**\nMultiplication is defined by primitive recursion on $y$, using addition. The parameter is $x$ ($k=1$).\n-   Base case: $mul(x, 0) = 0$.\n-   Recursive step: $mul(x, y+1) = mul(x,y) + x = add(mul(x,y), x)$.\n\nTo formalize this:\n-   The base case function is $g(x) = 0$. This is the zero function, $Z(x)$. To be fully formal, we can write $g(x) = Z(U_1^1(x))$.\n-   The recursive step function is $h(x,y,z) = add(z,x)$, where $z = mul(x,y)$. We construct $h$ using composition with projection functions: $h(x,y,z) = add(U_3^3(x,y,z), U_1^3(x,y,z))$. Since $add$, $U_1^3$, and $U_3^3$ are primitive recursive, $h$ is primitive recursive.\n-   Thus, $mul: \\mathbb{N}^2 \\to \\mathbb{N}$ is defined by:\n    $$mul(x,0) = Z(U_1^1(x))$$\n    $$mul(x,y+1) = add(U_3^3(x,y,mul(x,y)), U_1^3(x,y,mul(x,y)))$$\n\n**3. Exponentiation: $exp(x,y) = x^y$**\nBy convention in this context, $0^0=1$. Exponentiation is defined by primitive recursion on $y$, using multiplication. The parameter is $x$ ($k=1$).\n-   Base case: $exp(x, 0) = 1$.\n-   Recursive step: $exp(x, y+1) = exp(x,y) \\cdot x = mul(exp(x,y), x)$.\n\nTo formalize this:\n-   The base case function is $g(x) = 1$. This constant function can be constructed as $S(Z(x))$, or more formally, $g(x) = S(Z(U_1^1(x)))$.\n-   The recursive step function is $h(x,y,z) = mul(z,x)$, where $z = exp(x,y)$. This is constructed as $h(x,y,z) = mul(U_3^3(x,y,z), U_1^3(x,y,z))$. Since $mul$, $U_1^3$, and $U_3^3$ are primitive recursive, $h$ is primitive recursive.\n-   Thus, $exp: \\mathbb{N}^2 \\to \\mathbb{N}$ is defined by:\n    $$exp(x,0) = S(Z(U_1^1(x)))$$\n    $$exp(x,y+1) = mul(U_3^3(x,y,exp(x,y)), U_1^3(x,y,exp(x,y)))$$\n\n### Part 3: Evaluation of the Expression\n\nWe evaluate $E = exp(2,3) + mul(3, add(2,2))$, which translates to $add(exp(2,3), mul(3, add(2,2)))$, using the definitions derived above. We proceed from the innermost expression outward.\n\n**1. Calculate $add(2,2)$:**\n$add(x,y+1) = S(add(x,y))$\n-   $add(2,0) = 2$\n-   $add(2,1) = add(2,0+1) = S(add(2,0)) = S(2) = 3$\n-   $add(2,2) = add(2,1+1) = S(add(2,1)) = S(3) = 4$\nSo, $add(2,2) = 4$.\n\n**2. Calculate $mul(3, add(2,2)) = mul(3,4)$:**\n$mul(x,y+1) = add(mul(x,y), x)$\n-   $mul(3,0) = 0$\n-   $mul(3,1) = mul(3,0+1) = add(mul(3,0), 3) = add(0,3) = S(S(S(add(0,0)))) = S(S(S(0))) = 3$\n-   $mul(3,2) = mul(3,1+1) = add(mul(3,1), 3) = add(3,3) = S(S(S(add(3,0)))) = S(S(S(3))) = 6$\n-   $mul(3,3) = mul(3,2+1) = add(mul(3,2), 3) = add(6,3) = S(S(S(add(6,0)))) = S(S(S(6))) = 9$\n-   $mul(3,4) = mul(3,3+1) = add(mul(3,3), 3) = add(9,3) = S(S(S(add(9,0)))) = S(S(S(9))) = 12$\nSo, $mul(3,4) = 12$.\n\n**3. Calculate $exp(2,3)$:**\n$exp(x,y+1) = mul(exp(x,y), x)$\n-   $exp(2,0) = S(Z(2)) = S(0) = 1$\n-   $exp(2,1) = exp(2,0+1) = mul(exp(2,0), 2) = mul(1,2)$.\n    -   $mul(1,0) = 0$\n    -   $mul(1,1) = add(mul(1,0), 1) = add(0,1) = 1$\n    -   $mul(1,2) = add(mul(1,1), 1) = add(1,1) = S(add(1,0)) = S(1) = 2$.\n    So $exp(2,1) = 2$.\n-   $exp(2,2) = exp(2,1+1) = mul(exp(2,1), 2) = mul(2,2)$.\n    -   We already calculated $add(2,2)=4$. From the definition of multiplication, $mul(2,2)=add(mul(2,1),2)=add(add(mul(2,0),2),2)=add(add(0,2),2)=add(2,2)=4$.\n    So $exp(2,2) = 4$.\n-   $exp(2,3) = exp(2,2+1) = mul(exp(2,2), 2) = mul(4,2)$.\n    -   $mul(4,0) = 0$\n    -   $mul(4,1) = add(mul(4,0),4) = add(0,4)=4$\n    -   $mul(4,2) = add(mul(4,1),4) = add(4,4) = S(S(S(S(add(4,0))))) = S(S(S(S(4)))) = 8$.\nSo, $exp(2,3) = 8$.\n\n**4. Final Calculation: $add(exp(2,3), mul(3,4)) = add(8,12)$:**\n-   $add(8,0) = 8$\n-   $add(8,1) = S(8) = 9$\n-   ...\n-   $add(8,12) = S^{12}(add(8,0)) = S^{12}(8)$\nApplying the successor function $12$ times to $8$ yields $8+12 = 20$.\nSo, $add(8,12) = 20$.\n\nThe value of the expression $E$ is $20$.", "answer": "$$\n\\boxed{20}\n$$", "id": "3048525"}, {"introduction": "While primitive recursion generates a vast class of total functions, true computational universality requires a more powerful mechanism: search. This exercise [@problem_id:3048531] explores the crucial difference between a bounded search, which is guaranteed to terminate, and an unbounded search, which may run forever. You will see how the unbounded minimization operator, $\\mu$, gives rise to partial computable functions and directly connects to fundamental undecidable problems like the Halting Problem, setting the stage for Rice's Theorem.", "problem": "Let $\\{\\varphi_{e}\\}_{e \\in \\mathbb{N}}$ be a fixed standard enumeration of all partial computable functions $\\varphi_{e} : \\mathbb{N} \\to \\mathbb{N}$ induced by a Gödel numbering of Turing machines (TM). For $e, x, t \\in \\mathbb{N}$, let $H(e,x,t)$ be the primitive recursive predicate that holds if and only if the $e$-th TM on input $x$ halts within $t$ computation steps (equivalently, there exists some $y$ such that the $e$-th TM on input $x$ halts within $t$ steps with output $y$). Using only foundational definitions from the theory of partial and general recursive functions and Rice’s theorem, address the following.\n\n1. Define the function $f : \\mathbb{N} \\to \\mathbb{N}$ by bounded minimization\n$$\nf(n) \\;=\\; \\mu y \\leq n \\;\\big[y^{2} \\geq n\\big],\n$$\nthat is, $f(n)$ is the least $y \\in \\mathbb{N}$ with $y \\leq n$ and $y^{2} \\geq n$ (and is undefined if no such $y$ exists within the bound). Starting from core definitions, justify why bounded minimization in this case yields a total computable function. Identify $f(n)$ in more familiar analytic terms by deriving a closed-form characterization from first principles of order and squares.\n\n2. Define the function $g : \\mathbb{N} \\rightharpoonup \\mathbb{N}$ by unbounded minimization\n$$\ng(e) \\;=\\; \\mu t \\;\\big[ H(e,0,t) \\big],\n$$\nthat is, $g(e)$ is the least computation time $t$ such that the $e$-th TM halts on input $0$ within $t$ steps, if such a $t$ exists; otherwise $g(e)$ is undefined. Explain, using only the fundamental definitions of unbounded minimization and partial computability, how $g$ can fail to be total. Exhibit a specific, concrete machine description whose index $e_{\\mathrm{loop}}$ causes $g(e_{\\mathrm{loop}})$ to be undefined, and justify this claim.\n\n3. Using Rice’s theorem, rigorously argue why the index set\n$$\nD \\;=\\; \\{\\, e \\in \\mathbb{N} : g(e) \\text{ is defined} \\,\\}\n$$\nis not decidable. Your argument should start from the statement of Rice’s theorem and explain why the property in question is semantic and nontrivial.\n\nProvide, as your final answer, the exact integer value of $f(2024)$ with no rounding and no units. Your final answer must be a single number. Do not include any explanation in your final answer.", "solution": "This problem consists of three parts related to the theory of computable functions. We address each part sequentially based on the provided definitions.\n\n1. Analysis of the function $f(n) = \\mu y \\leq n \\;[y^{2} \\geq n]$.\n\nFirst, we justify why this function is total computable. The function $f$ is defined by bounded minimization. The general form of a function defined by bounded minimization is $h(\\vec{x}) = \\mu y \\leq z \\; [P(\\vec{x}, y)]$, where $P$ is a predicate. A fundamental theorem of computability theory states that if the predicate $P$ is total computable, then the function $h$ is also total computable, provided that for every input $\\vec{x}$, there exists at least one $y$ in the search range $[0, z]$ that makes the predicate $P(\\vec{x}, y)$ true.\n\nIn our case, the function is $f(n)$, the predicate is $P(n, y) \\equiv (y^2 \\geq n)$, and the bound is $z=n$. The predicate $P(n,y)$ is primitive recursive, and thus total computable, because it involves only squaring an integer and comparing it to another integer, both of which are primitive recursive operations.\n\nTo establish that $f(n)$ is total, we must show that for any given $n \\in \\mathbb{N}$, there exists at least one integer $y$ such that $0 \\leq y \\leq n$ and $y^2 \\geq n$.\nLet's consider two cases for $n$:\nCase $1$: $n=0$. The definition becomes $f(0) = \\mu y \\leq 0 \\; [y^{2} \\geq 0]$. The search is limited to $y=0$. For $y=0$, the predicate is $0^2 \\geq 0$, which is true. Thus, the minimization procedure finds $y=0$ and terminates. So, $f(0) = 0$.\nCase $2$: $n > 0$. We need to find a $y$ in the range $\\{0, 1, \\dots, n\\}$ satisfying $y^2 \\geq n$. Let us test the value $y=n$. Since $n \\in \\mathbb{N}$ and $n > 0$, we have $n \\geq 1$. Multiplying both sides by $n$ (which is positive) gives $n^2 \\geq n$. Therefore, the choice $y=n$ always satisfies the predicate $y^2 \\geq n$. Since this choice is within the search bound $\\{0, 1, \\dots, n\\}$, the bounded minimization procedure is guaranteed to find a value (it will find the *least* such $y$, which is less than or equal to $n$) and halt.\n\nSince for every $n \\in \\mathbb{N}$, a suitable $y$ exists within the bound, and the predicate is total computable, the function $f(n)$ is a total computable function.\n\nNext, we derive a closed-form characterization for $f(n)$. The definition states that $f(n)$ is the least non-negative integer $y$ such that $y^2 \\geq n$. (The constraint $y \\leq n$ is redundant, as shown that for $y_{min} = \\lceil\\sqrt{n}\\rceil$, we have $y_{min} \\leq n$ for $n \\geq 1$, and for $n=0$ it holds trivially). Taking the square root of both sides of the inequality $y^2 \\geq n$ yields $|y| \\geq \\sqrt{n}$. Since we are considering $y \\in \\mathbb{N}$, $y$ is non-negative, so the condition simplifies to $y \\geq \\sqrt{n}$.\nThus, $f(n)$ is the least integer $y$ that is greater than or equal to the real number $\\sqrt{n}$. This is the definition of the ceiling function.\nTherefore, the closed-form characterization of $f(n)$ is\n$$\nf(n) = \\lceil \\sqrt{n} \\rceil.\n$$\n\n2. Analysis of the function $g(e) = \\mu t \\;[ H(e,0,t) ]$.\n\nFirst, we explain why $g$ can fail to be total. The function $g(e)$ is defined by unbounded minimization. The expression $g(e) = \\mu t \\;[P(e,t)]$, where $P(e,t) \\equiv H(e,0,t)$, gives the smallest $t \\in \\mathbb{N}$ for which the predicate $P(e,t)$ is true. If no such $t$ exists, the function is undefined for that input $e$.\nThe predicate $H(e,0,t)$ is true if and only if the $e$-th Turing machine on input $0$ halts within $t$ steps. The function $g(e)$ is therefore defined if and only if there exists some finite time $t$ at which the $e$-th TM halts on input $0$. This is equivalent to saying that the computation $\\varphi_e(0)$ halts, or $\\varphi_e(0) \\downarrow$.\nThe Halting Problem, a cornerstone result of computability theory, states that it is undecidable whether an arbitrary TM halts on an arbitrary input. A direct consequence is that there must exist Turing machines that do not halt on some inputs. In particular, there exist TMs that do not halt on input $0$.\nLet $e_{\\mathrm{loop}}$ be the Gödel number of a TM that is designed to never halt on input $0$. For this index $e_{\\mathrm{loop}}$, the statement \"the TM halts on input $0$\" is false. This implies that there is no number of steps $t$ for which the predicate $H(e_{\\mathrm{loop}},0,t)$ is true. The unbounded minimization procedure $\\mu t \\;[H(e_{\\mathrm{loop}},0,t)]$ will search for such a $t$ indefinitely, starting from $t=0, 1, 2, \\dots$, and will never find one. By the definition of unbounded minimization, $g(e_{\\mathrm{loop}})$ is undefined.\nSince there exists at least one input $e_{\\mathrm{loop}}$ for which $g(e_{\\mathrm{loop}})$ is undefined, the function $g$ is a partial function, not a total one.\n\nAs a specific, concrete example, consider a Turing machine $M$ with a single state $q_0$ which is the start state, and a transition function $\\delta$ defined as follows: for any symbol $a$ on the tape, $\\delta(q_0, a) = (q_0, a, R)$. This rule signifies that when in state $q_0$, the machine reads the symbol $a$, writes back the same symbol $a$, moves its head one position to the right ($R$), and remains in state $q_0$. This machine has no halting state. When started on any input, including input $0$, it will endlessly move its head to the right, never halting. Let $e_{\\mathrm{loop}}$ be the index (Gödel number) of this machine $M$. Then, by its construction, $\\varphi_{e_{\\mathrm{loop}}}(0)$ is undefined. This means that for all $t \\in \\mathbb{N}$, the predicate $H(e_{\\mathrm{loop}}, 0, t)$ is false. Consequently, $g(e_{\\mathrm{loop}})$ is undefined.\n\n3. Undecidability of the set $D = \\{\\, e \\in \\mathbb{N} : g(e) \\text{ is defined} \\,\\}$.\n\nWe use Rice's theorem to prove that $D$ is undecidable. Rice's theorem states that for any non-trivial semantic property $\\mathcal{P}$ of partial computable functions, the index set $I_{\\mathcal{P}} = \\{ e \\in \\mathbb{N} \\mid \\varphi_e \\in \\mathcal{P} \\}$ is undecidable. To apply the theorem, we must show that $D$ is an index set for a property that is both semantic and non-trivial.\n\nStep 1: Identify the property.\nThe set $D$ is defined as $\\{ e \\in \\mathbb{N} \\mid g(e) \\text{ is defined}\\}$. As established in part 2, $g(e)$ is defined if and only if the computation $\\varphi_e(0)$ halts. Therefore, $D$ is the index set for the property of a partial computable function being defined at input $0$. Let this property be $\\mathcal{P}$.\n$$\n\\mathcal{P} = \\{ h : \\mathbb{N} \\rightharpoonup \\mathbb{N} \\mid h \\text{ is partial computable and } h(0) \\text{ is defined} \\}\n$$\nThe set $D$ is precisely the index set $I_{\\mathcal{P}}$, since $e \\in D \\iff \\varphi_e \\in \\mathcal{P}$.\n\nStep 2: Show the property is semantic.\nA property is semantic if it depends only on the function's behavior (i.e., its graph), not its specific implementation (i.e., its index). This means that if two indices $e_1$ and $e_2$ compute the same function ($\\varphi_{e_1} = \\varphi_{e_2}$), then they must either both have the property or neither have it.\nSuppose $\\varphi_{e_1} = \\varphi_{e_2}$. This equality means they have the same domain and produce the same output for every input in that domain. The property $\\mathcal{P}$ is that the function is defined at input $0$. If $\\varphi_{e_1} \\in \\mathcal{P}$, then $\\varphi_{e_1}(0)$ is defined. Because $\\varphi_{e_1} = \\varphi_{e_2}$, it must be that $\\varphi_{e_2}(0)$ is also defined, which means $\\varphi_{e_2} \\in \\mathcal{P}$. Conversely, if $\\varphi_{e_1} \\notin \\mathcal{P}$, then $\\varphi_{e_1}(0)$ is undefined, which implies $\\varphi_{e_2}(0)$ is also undefined, so $\\varphi_{e_2} \\notin \\mathcal{P}$. The property of being defined at input $0$ depends only on the function itself, so the property is semantic.\n\nStep 3: Show the property is non-trivial.\nA property is non-trivial if it is not universal and not empty. That is, there must be at least one partial computable function that has the property and at least one that does not.\nTo show $\\mathcal{P}$ is not empty, we must exhibit a function in $\\mathcal{P}$. Consider the total computable function $c(x) = 0$ for all $x \\in \\mathbb{N}$. This function is defined for all inputs, including $x=0$. Thus, $c \\in \\mathcal{P}$.\nTo show $\\mathcal{P}$ is not the set of all partial computable functions, we must exhibit a function not in $\\mathcal{P}$. This was done in part 2. The function $\\varphi_{e_{\\mathrm{loop}}}$ corresponding to the TM that always moves right is undefined for all inputs, including $x=0$. Thus, $\\varphi_{e_{\\mathrm{loop}}} \\notin \\mathcal{P}$.\nSince $\\mathcal{P}$ is neither empty nor universal, it is a non-trivial property.\n\nStep 4: Conclusion.\nThe set $D$ is the index set of a semantic, non-trivial property of partial computable functions. By Rice's theorem, $D$ is an undecidable set.\n\nFinally, we calculate the required value of $f(2024)$.\nUsing the derived closed-form expression, we need to compute $f(2024) = \\lceil \\sqrt{2024} \\rceil$.\nWe can find integers whose squares bound $2024$.\nWe know $40^2 = 1600$ and $50^2 = 2500$.\nLet's try $45^2$: $45^2 = 2025$.\nLet's try $44^2$: $44^2 = (45 - 1)^2 = 45^2 - 2 \\cdot 45 + 1 = 2025 - 90 + 1 = 1936$.\nWe have the inequality $1936 < 2024 < 2025$, which is equivalent to $44^2 < 2024 < 45^2$.\nTaking the square root of all parts gives $44 < \\sqrt{2024} < 45$.\nThe ceiling function $\\lceil x \\rceil$ yields the smallest integer greater than or equal to $x$. For a value $x$ strictly between two consecutive integers $k$ and $k+1$, $\\lceil x \\rceil = k+1$.\nSince $44 < \\sqrt{2024} < 45$, we have $\\lceil \\sqrt{2024} \\rceil = 45$.\nThus, $f(2024)=45$.", "answer": "$$\n\\boxed{45}\n$$", "id": "3048531"}, {"introduction": "Rice's Theorem delivers a powerful message: almost any interesting semantic property of programs is undecidable. This can feel daunting, suggesting that we can know very little about program behavior. This exercise [@problem_id:3048534] provides a crucial counterpoint by exploring *intensional*, or syntactic, properties of program codes. You will learn to identify properties that are decidable precisely because they concern the program's structure rather than its behavior, thereby sharpening your understanding of the true scope of Rice's Theorem.", "problem": "Fix a standard effective enumeration $e \\mapsto \\varphi_{e}$ of all partial recursive (partial computable) functions from $\\mathbb{N}$ to $\\mathbb{N}$, where each natural number $e \\in \\mathbb{N}$ encodes a Turing machine (TM) that computes the partial function $\\varphi_{e}$. A property of program codes is any subset $S \\subseteq \\mathbb{N}$. Such a property is called extensional if for all $e, e' \\in \\mathbb{N}$, the equality $\\varphi_{e} = \\varphi_{e'}$ implies $e \\in S$ if and only if $e' \\in S$. Otherwise, it is intensional. A property $S \\subseteq \\mathbb{N}$ is decidable if there exists a total recursive (general recursive) characteristic function $\\chi_{S} \\colon \\mathbb{N} \\to \\{0,1\\}$ with $\\chi_{S}(e) = 1$ if and only if $e \\in S$ and $\\chi_{S}(e) = 0$ otherwise. Rice’s theorem states that any nontrivial extensional property of partial computable functions has an undecidable index set.\n\nSelect all options below that describe a decidable intensional property of program codes, and, for your selections, explain why Rice’s theorem does not forbid their decidability.\n\nA. $E_{\\mathrm{even}} = \\{e \\in \\mathbb{N} : e \\text{ is even}\\}$.\n\nB. $T = \\{e \\in \\mathbb{N} : \\varphi_{e} \\text{ is total}\\}$.\n\nC. $H_{10} = \\{e \\in \\mathbb{N} : \\text{the TM with code } e \\text{ halts on input } 0 \\text{ within at most } 10 \\text{ steps}\\}$.\n\nD. $Z = \\{e \\in \\mathbb{N} : \\exists x \\in \\mathbb{N} \\text{ with } \\varphi_{e}(x) = 0\\}$.\n\nE. $S_{01} = \\{e \\in \\mathbb{N} : \\text{the binary encoding of } e \\text{ contains the substring } 01\\}$.", "solution": "The problem statement is a valid exercise in computability theory. All definitions provided—partial recursive functions, effective enumeration, extensional and intensional properties, decidability, and Rice's theorem—are standard and correctly stated. The problem is self-contained, scientifically grounded in mathematical logic, and well-posed. We may proceed with the solution.\n\nThe task is to identify which of the given properties $S \\subseteq \\mathbb{N}$ are both decidable and intensional. Let us recall the definitions.\nA property $S$ is **decidable** if its characteristic function $\\chi_S$ is a total computable function. This means there is an algorithm that, for any input $e \\in \\mathbb{N}$, halts and outputs $1$ if $e \\in S$ and $0$ if $e \\notin S$.\nA property $S$ is **extensional** if it is a property of the function computed, not the program code itself. Formally, for any two codes $e, e' \\in \\mathbb{N}$, if they compute the same function (i.e., $\\varphi_e = \\varphi_{e'}$), then it must hold that $e \\in S$ if and only if $e' \\in S$.\nA property $S$ is **intensional** if it is not extensional. This means there exist at least two codes $e, e' \\in \\mathbb{N}$ such that $\\varphi_e = \\varphi_{e'}$ but one code is in $S$ and the other is not.\n**Rice's Theorem** states that any non-trivial (i.e., not $\\emptyset$ and not $\\mathbb{N}$) extensional property is undecidable. A direct consequence is that any decidable non-trivial property must be intensional.\n\nWe now analyze each option.\n\n**A. $E_{\\mathrm{even}} = \\{e \\in \\mathbb{N} : e \\text{ is even}\\}$**\n\n*   **Decidability:** This property is decidable. To determine if a given natural number $e$ is in $E_{\\mathrm{even}}$, we can simply compute $e \\pmod 2$. If the result is $0$, then $e \\in E_{\\mathrm{even}}$; otherwise, $e \\notin E_{\\mathrm{even}}$. This is a simple, terminating algorithm. Thus, the characteristic function $\\chi_{E_{\\mathrm{even}}}$ is total computable. The property is **decidable**.\n*   **Intensionality:** To check if the property is intensional, we must determine if there exist two codes $e_1, e_2$ such that $\\varphi_{e_1} = \\varphi_{e_2}$, but one is even and the other is odd. By the Padding Lemma (or more informally, the ability to add redundant instructions to a Turing machine), any partial computable function has infinitely many distinct codes (indices). This infinite set of codes for any given function cannot consist solely of even numbers or solely of odd numbers. Therefore, for any partial computable function $f$, we can find an even index $e_1$ and an odd index $e_2$ such that $\\varphi_{e_1} = f$ and $\\varphi_{e_2} = f$. In this case, $\\varphi_{e_1} = \\varphi_{e_2}$, but $e_1 \\in E_{\\mathrm{even}}$ and $e_2 \\notin E_{\\mathrm{even}}$. This violates the condition for being extensional. Thus, the property is **intensional**.\n*   **Conclusion:** The property is both decidable and intensional. Rice's theorem does not forbid its decidability because the theorem only applies to extensional properties, and $E_{\\mathrm{even}}$ is an intensional property. It describes a syntactic feature of the code $e$ itself, not a semantic feature of the function $\\varphi_e$.\n*   **Verdict:** **Correct**.\n\n**B. $T = \\{e \\in \\mathbb{N} : \\varphi_{e} \\text{ is total}\\}$**\n\n*   **Decidability:** The property of a function being total is a classic undecidable problem. To show this using Rice's theorem, we first check the conditions.\n*   **Intensionality:** The property is **extensional**. If $\\varphi_e = \\varphi_{e'}$, then the two functions are identical. They must have the same domain. Therefore, $\\varphi_e$ is total if and only if $\\varphi_{e'}$ is total.\n*   **Triviality:** The property is non-trivial. There exists a total function (e.g., the constant zero function, $f(x)=0$), so $T \\neq \\emptyset$. There also exists a function that is not total (e.g., the function which is undefined everywhere), so $T \\neq \\mathbb{N}$.\n*   **Conclusion:** Since $T$ is a non-trivial, extensional property, by Rice's theorem, it is **undecidable**.\n*   **Verdict:** **Incorrect**.\n\n**C. $H_{10} = \\{e \\in \\mathbb{N} : \\text{the TM with code } e \\text{ halts on input } 0 \\text{ within at most } 10 \\text{ steps}\\}$**\n\n*   **Decidability:** This property is decidable. Given an index $e$, we can simulate the Turing machine it encodes on input $0$. We run the simulation for at most $10+1$ steps. If the machine halts within $10$ steps, we accept $e$ (output $1$). If the machine has not halted after $10$ steps, we stop the simulation and reject $e$ (output $0$). Since the simulation is time-bounded, this procedure always terminates for any input $e$. Therefore, the property is **decidable**.\n*   **Intensionality:** This property is **intensional**. It depends on a specific operational behavior (number of steps) of the machine $e$, not just the function $\\varphi_e$ it computes. To prove this, consider the constant function $f(x) = 0$. We can construct a very efficient Turing machine $M_1$ with code $e_1$ that computes this function and halts on input $0$ in, say, $5$ steps. Hence, $e_1 \\in H_{10}$. We can also construct another Turing machine $M_2$ with code $e_2$ that computes the same function $f(x)=0$, but first performs $20$ useless, time-wasting operations (like moving its head back and forth) before proceeding to the main computation. This machine $M_2$ would halt on input $0$ in more than $10$ steps, so $e_2 \\notin H_{10}$. Since $\\varphi_{e_1} = \\varphi_{e_2}$ but $e_1 \\in H_{10}$ and $e_2 \\notin H_{10}$, the property is not extensional.\n*   **Conclusion:** The property is both decidable and intensional. Rice's theorem does not apply because the property is intensional. It concerns the performance of a specific program, not a property of the mathematical function it computes.\n*   **Verdict:** **Correct**.\n\n**D. $Z = \\{e \\in \\mathbb{N} : \\exists x \\in \\mathbb{N} \\text{ with } \\varphi_{e}(x) = 0\\}$**\n\n*   **Decidability:** This property asks whether the number $0$ is in the range of the function $\\varphi_e$.\n*   **Intensionality:** This property is **extensional**. If $\\varphi_e = \\varphi_{e'}$, they are the same function and thus have the same range. If there is an $x$ such that $\\varphi_e(x)=0$, then it is also true that $\\varphi_{e'}(x)=0$. So, $e \\in Z$ if and only if $e' \\in Z$.\n*   **Triviality:** The property is non-trivial. The constant zero function has $0$ in its range, so $Z \\neq \\emptyset$. The constant one function ($f(x)=1$) does not have $0$ in its range, so $Z \\neq \\mathbb{N}$.\n*   **Conclusion:** Since $Z$ is a non-trivial, extensional property, by Rice's theorem, it is **undecidable**.\n*   **Verdict:** **Incorrect**.\n\n**E. $S_{01} = \\{e \\in \\mathbb{N} : \\text{the binary encoding of } e \\text{ contains the substring } 01\\}$**\n\n*   **Decidability:** This property is decidable. Given a number $e$, we can convert it to its binary string representation and then perform a simple string search for the substring `$01$`. This algorithm always terminates. Therefore, the property is **decidable**.\n*   **Intensionality:** This property is **intensional**. It is purely syntactic, depending only on the representation of the integer $e$. As explained for option A, any partial computable function has infinitely many indices. We can always find two indices, $e_1$ and $e_2$, for the same function such that the binary representation of $e_1$ contains the substring `$01$` and the binary representation of $e_2$ does not. For instance, the set of numbers whose binary form does *not* contain `$01$` is the set of numbers of the form $2^k-1$ followed by any number of zeros (i.e., numbers of the form $(2^k-1) \\cdot 2^j = \\underbrace{11\\dots1}_{k}\\underbrace{00\\dots0}_{j}$ in binary). This set is infinite. The set of indices for any function is also infinite. It is not possible for the infinite set of indices for a function to be a subset of the numbers whose binary form lacks `$01$`. Thus, there must exist an index $e_1$ in $S_{01}$ and an index $e_2$ not in $S_{01}$ that compute the same function.\n*   **Conclusion:** The property is both decidable and intensional. Rice's theorem is not applicable because the property is intensional, concerning only the syntax of the index, not the semantics of the function.\n*   **Verdict:** **Correct**.", "answer": "$$\\boxed{ACE}$$", "id": "3048534"}]}