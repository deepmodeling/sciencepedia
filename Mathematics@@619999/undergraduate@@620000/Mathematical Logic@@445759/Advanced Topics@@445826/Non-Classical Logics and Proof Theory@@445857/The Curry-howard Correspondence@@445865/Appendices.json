{"hands_on_practices": [{"introduction": "The Curry-Howard correspondence provides a powerful method for verifying logical statements through computation. This first practice invites you to act as a constructive logician by building a \"proof\" for a given \"proposition.\" Your task is to construct a lambda term that inhabits a specific type, demonstrating that the type corresponds to a valid logical principle—in this case, one that is fundamental to both function composition in programming and rules of inference in logic.", "problem": "Work in the simply typed lambda calculus (STLC) under the Curry–Howard correspondence, where propositions are types and proofs are typed lambda terms. Using only the core typing rules for function types, namely implication introduction and elimination for arrows, and the standard definition of capture-avoiding substitution and $\\beta$-reduction, carry out the following.\n\n1. Construct a closed lambda term $t$ that inhabits the type $(A \\to B) \\to (C \\to A) \\to (C \\to B)$.\n2. Derive the type of $t$ from first principles by a formal typing argument using only the typing rules for function introduction and elimination.\n3. Let $f : A \\to B$, $g : C \\to A$, and $x : C$ be variables. Compute the $\\beta$-normal form of the fully applied term $(t\\ f\\ g\\ x)$ by an explicit sequence of $\\beta$-reductions, justifying each step by the definition of $\\beta$-reduction and capture-avoiding substitution.\n4. Express your final answer as a single closed-form analytic expression for the $\\beta$-normal form of $(t\\ f\\ g\\ x)$.\n\nNo numerical computation is required. The final answer must be a single symbolic expression in standard lambda calculus application notation. Do not include any units. Do not write an equation; give only the final expression.", "solution": "The problem is valid as it is well-posed, scientifically grounded in the formal system of the simply typed lambda calculus, and internally consistent. We proceed with the solution, which is divided into three parts as requested by the problem statement: construction of the term, formal typing derivation, and computation of the normal form.\n\n### 1. Construction of the Lambda Term\n\nThe objective is to construct a closed lambda term $t$ that inhabits, or has, the type $(A \\to B) \\to (C \\to A) \\to (C \\to B)$. This type represents a function that takes three arguments in a curried fashion. We can construct the term by analyzing the structure of the type.\n\nThe type is $(A \\to B) \\to ((C \\to A) \\to (C \\to B))$. This is a function type, so the term $t$ must be a lambda abstraction. We introduce a bound variable, let's call it $f$, for the first argument, which has type $A \\to B$.\n$$t = \\lambda f : A \\to B . \\text{body}_1$$\nThe body of this abstraction, $\\text{body}_1$, must have the type $(C \\to A) \\to (C \\to B)$. This is also a function type, so $\\text{body}_1$ must be another lambda abstraction. We introduce a bound variable $g$ for its argument, which has type $C \\to A$.\n$$t = \\lambda f : A \\to B . \\lambda g : C \\to A . \\text{body}_2$$\nThe next body, $\\text{body}_2$, must have the type $C \\to B$. This is again a function type, requiring a third lambda abstraction. We introduce a bound variable $x$ for its argument of type $C$.\n$$t = \\lambda f : A \\to B . \\lambda g : C \\to A . \\lambda x : C . \\text{body}_3$$\nAt this point, the final body, $\\text{body}_3$, must have type $B$. To construct this term, we can use the variables available in the context:\n- $f : A \\to B$\n- $g : C \\to A$\n- $x : C$\n\nOur goal is to produce an expression of type $B$. The only variable that can produce a value of type $B$ is $f$, through an application. The function $f$ requires an argument of type $A$. We can produce a term of type $A$ by applying the function $g : C \\to A$ to an argument of type $C$. We have such an argument, the variable $x : C$.\nThe application $(g\\ x)$ is well-typed and results in a term of type $A$.\nNow, we can provide this term, $(g\\ x)$, as the argument to $f$. The application $(f\\ (g\\ x))$ is well-typed and results in a term of type $B$. This is exactly what is required for $\\text{body}_3$.\n\nSubstituting this back into our structure, we get the complete closed lambda term:\n$$t = \\lambda f : A \\to B . \\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))$$\nThis term represents the composition of two functions.\n\n### 2. Formal Typing Derivation\n\nWe now derive the type of the constructed term $t$ using the core typing rules for implication introduction ($\\to_I$) and implication elimination ($\\to_E$). The rules are:\n- Implication Elimination ($\\to_E$ Rule, or Application): \n$$ \\frac{\\Gamma \\vdash M : T_1 \\to T_2 \\quad \\Gamma \\vdash N : T_1}{\\Gamma \\vdash (M\\ N) : T_2} $$\n- Implication Introduction ($\\to_I$ Rule, or Abstraction): \n$$ \\frac{\\Gamma, v:T_1 \\vdash M : T_2}{\\Gamma \\vdash (\\lambda v:T_1 . M) : T_1 \\to T_2} $$\n\nLet us define the sequence of typing contexts:\n- $\\Gamma_0 = \\emptyset$ (the empty context)\n- $\\Gamma_1 = \\{ f : A \\to B \\}$\n- $\\Gamma_2 = \\{ f : A \\to B, g : C \\to A \\}$\n- $\\Gamma_3 = \\{ f : A \\to B, g : C \\to A, x : C \\}$\n\nThe derivation proceeds as follows, starting from the variables in the innermost context $\\Gamma_3$:\n1. From the context $\\Gamma_3$, we can deduce the types of our variables (by the variable rule, or axiom):\n   - $\\Gamma_3 \\vdash f : A \\to B$\n   - $\\Gamma_3 \\vdash g : C \\to A$\n   - $\\Gamma_3 \\vdash x : C$\n2. Using the $\\to_E$ rule on the terms $g$ and $x$ from step $1$:\n   $$ \\frac{\\Gamma_3 \\vdash g : C \\to A \\quad \\Gamma_3 \\vdash x : C}{\\Gamma_3 \\vdash (g\\ x) : A} $$\n3. Using the $\\to_E$ rule again, this time on the terms $f$ from step $1$ and $(g\\ x)$ from step $2$:\n   $$ \\frac{\\Gamma_3 \\vdash f : A \\to B \\quad \\Gamma_3 \\vdash (g\\ x) : A}{\\Gamma_3 \\vdash (f\\ (g\\ x)) : B} $$\n4. Now, we apply the $\\to_I$ rule to abstract over $x$, discharging the assumption $x:C$ and moving from context $\\Gamma_3$ to $\\Gamma_2$:\n   $$ \\frac{\\Gamma_3 \\vdash (f\\ (g\\ x)) : B}{\\Gamma_2 \\vdash (\\lambda x : C . (f\\ (g\\ x))) : C \\to B} $$\n5. We apply the $\\to_I$ rule again to abstract over $g$, discharging the assumption $g:C \\to A$ and moving from context $\\Gamma_2$ to $\\Gamma_1$:\n   $$ \\frac{\\Gamma_2 \\vdash (\\lambda x : C . (f\\ (g\\ x))) : C \\to B}{\\Gamma_1 \\vdash (\\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))) : (C \\to A) \\to (C \\to B)} $$\n6. Finally, we apply the $\\to_I$ rule one last time to abstract over $f$, discharging the assumption $f:A \\to B$ and moving from context $\\Gamma_1$ to the empty context $\\Gamma_0$:\n   $$ \\frac{\\Gamma_1 \\vdash (\\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))) : (C \\to A) \\to (C \\to B)}{\\Gamma_0 \\vdash (\\lambda f : A \\to B . \\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))) : (A \\to B) \\to (C \\to A) \\to (C \\to B)} $$\nThis completes the formal proof that the term $t$ has the specified type.\n\n### 3. Computation of the $\\beta$-Normal Form\n\nWe are asked to compute the $\\beta$-normal form of the term $(t\\ f\\ g\\ x)$, where $t$ is the term we constructed, and $f : A \\to B$, $g : C \\to A$, and $x : C$ are given variables.\n\nTo avoid confusion between the bound variables in $t$ and the free variables $f$, $g$, and $x$ we are applying, we will write $t$ with primed bound variables:\n$$t = \\lambda f' : A \\to B . \\lambda g' : C \\to A . \\lambda x' : C . (f'\\ (g'\\ x'))$$\nThe term to be reduced is $(((t\\ f)\\ g)\\ x)$, since application is left-associative.\n\nThe definition of $\\beta$-reduction is $(\\lambda v. E)\\ M \\to_\\beta E[v \\leftarrow M]$, where $E[v \\leftarrow M]$ denotes the capture-avoiding substitution of $M$ for all free occurrences of $v$ in $E$.\n\n**Step 1: First $\\beta$-reduction**\nThe outermost term is $(t\\ f)$, which is a $\\beta$-redex:\n$$(t\\ f) = (\\lambda f' : A \\to B . \\lambda g' : C \\to A . \\lambda x' : C . (f'\\ (g'\\ x')))\\ f$$\nWe substitute $f$ for $f'$ in the body of the abstraction:\n$$ \\to_\\beta (\\lambda g' : C \\to A . \\lambda x' : C . (f'\\ (g'\\ x')))[f' \\leftarrow f] $$\n$$ = \\lambda g' : C \\to A . \\lambda x' : C . (f\\ (g'\\ x')) $$\nThe substitution is valid as the variable $f$ has no free variables that could be captured by the binders $\\lambda g'$ or $\\lambda x'$.\nAfter this step, the full expression becomes:\n$$(((\\lambda g' . \\lambda x' . (f\\ (g'\\ x')))\\ g)\\ x)$$\n\n**Step 2: Second $\\beta$-reduction**\nThe next redex is the application to $g$:\n$$((\\lambda g' : C \\to A . \\lambda x' : C . (f\\ (g'\\ x')))\\ g)$$\nWe substitute $g$ for $g'$ in the body $\\lambda x' : C . (f\\ (g'\\ x'))$:\n$$ \\to_\\beta (\\lambda x' : C . (f\\ (g'\\ x')))[g' \\leftarrow g] $$\n$$ = \\lambda x' : C . (f\\ (g\\ x')) $$\nAgain, the substitution is capture-avoiding as $g$ has no free variables to be captured by $\\lambda x'$.\nThe full expression is now:\n$$(\\lambda x' : C . (f\\ (g\\ x')))\\ x$$\n\n**Step 3: Third and Final $\\beta$-reduction**\nThe final expression is a redex:\n$$(\\lambda x' : C . (f\\ (g\\ x')))\\ x$$\nWe substitute $x$ for $x'$ in the body $(f\\ (g\\ x'))$:\n$$ \\to_\\beta (f\\ (g\\ x'))[x' \\leftarrow x] $$\n$$ = (f\\ (g\\ x)) $$\nThe substitution is safe. The resulting term is $(f\\ (g\\ x))$. This term is in $\\beta$-normal form because it is an application whose head, $f$, is a variable, not a lambda abstraction. Therefore, no more $\\beta$-reductions are possible.\n\nThe explicit sequence of reductions is:\n$$((( \\lambda f' . \\lambda g' . \\lambda x' . (f'\\ (g'\\ x')) )\\ f )\\ g )\\ x$$\n$$ \\to_\\beta ((\\lambda g' . \\lambda x' . (f\\ (g'\\ x')))\\ g)\\ x $$\n$$ \\to_\\beta (\\lambda x' . (f\\ (g\\ x')))\\ x $$\n$$ \\to_\\beta (f\\ (g\\ x)) $$\nThe final, $\\beta$-normal form of $(t\\ f\\ g\\ x)$ is $(f\\ (g\\ x))$, which intuitively corresponds to applying the composition of $f$ and $g$ to the argument $x$.", "answer": "$$\\boxed{(f\\ (g\\ x))}$$", "id": "3056165"}, {"introduction": "Once a proof is constructed, we can treat it as a program and \"run\" it. In the lambda calculus, this computational process is called normalization, where a term is simplified to its most basic form through a series of $\\beta$-reductions. This exercise provides a hands-on opportunity to perform this proof simplification, taking a complex term and methodically reducing it to its final, normal form, thereby revealing the computational content of a logical proof.", "problem": "In the simply typed lambda calculus (STLC), the Curry-Howard correspondence identifies function types $A \\to B$ with logical implication $A \\Rightarrow B$, and lambda terms with proofs. A basic operational principle of STLC is $\\beta$-reduction, which performs computation by substituting arguments into function bodies. Using this principle as the fundamental base, normalize a closed computation that encodes a proof transformation. Work in a context with a single base type $A$ and a single variable $a$ of type $A$.\n\nConsider the term\n$$\nt \\;=\\; (\\lambda h^{A\\to A\\to A}.\\,\\lambda f^{A\\to A}.\\,\\lambda x^{A}.\\,h\\,(f\\,x)\\,x)\\,(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)\\,(\\lambda w^{A}.\\,w)\\,a.\n$$\nHere $(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)$ is a selector that returns its first argument (the typed version of the $\\mathbf{K}$ combinator), $(\\lambda w^{A}.\\,w)$ is the identity function on $A$, and $a$ is a variable of type $A$.\n\nTask: Using only the fundamental definitions of STLC typing and $\\beta$-reduction, compute a complete sequence of $\\beta$-reductions that takes $t$ to its normal form. Express your final answer as the fully normalized lambda term. No rounding is required and no physical units are involved.", "solution": "The problem requires the normalization of a given term in the simply typed lambda calculus (STLC) using $\\beta$-reduction. The problem is well-defined, scientifically sound, and all necessary components are provided. The STLC is strongly normalizing, which guarantees that any sequence of $\\beta$-reductions will terminate in a unique normal form. We will proceed by applying a sequence of $\\beta$-reductions, following the normal-order strategy (reducing the leftmost-outermost redex at each step), until no redexes remain. A $\\beta$-redex is a term of the form $(\\lambda x^T.\\,M)\\,N$, and its reduction is the term $M[x:=N]$, which denotes the substitution of all free occurrences of the variable $x$ in the term $M$ with the term $N$.\n\nThe initial term to be normalized is:\n$$t_0 \\;=\\; (\\lambda h^{A\\to A\\to A}.\\,\\lambda f^{A\\to A}.\\,\\lambda x^{A}.\\,h\\,(f\\,x)\\,x)\\,(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)\\,(\\lambda w^{A}.\\,w)\\,a$$\n\nBy the left-associativity of application, this term is parsed as:\n$$ t_0 \\;=\\; (((\\lambda h^{A\\to A\\to A}.\\,\\lambda f^{A\\to A}.\\,\\lambda x^{A}.\\,h\\,(f\\,x)\\,x)\\,(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u))\\,(\\lambda w^{A}.\\,w))\\,a $$\n\nStep $1$: The leftmost-outermost redex is the application of the first abstraction $(\\lambda h^{A\\to A\\to A}.\\dots)$ to the term $(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)$. We substitute $(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)$ for $h$ in the body of the first abstraction.\n$$ t_0 \\rightarrow_{\\beta} ((\\lambda f^{A\\to A}.\\,\\lambda x^{A}.\\,(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)\\,(f\\,x)\\,x)\\,(\\lambda w^{A}.\\,w))\\,a $$\nLet us call this new term $t_1$.\n\nStep $2$: The leftmost-outermost redex in $t_1$ is the application of the term $(\\lambda f^{A\\to A}.\\dots)$ to $(\\lambda w^{A}.\\,w)$. We substitute $(\\lambda w^{A}.\\,w)$ for $f$ in the body of the main abstraction.\n$$ t_1 \\rightarrow_{\\beta} (\\lambda x^{A}.\\,(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)\\,((\\lambda w^{A}.\\,w)\\,x)\\,x)\\,a $$\nLet us call this new term $t_2$.\n\nStep $3$: The leftmost-outermost redex in $t_2$ is the application of the term $(\\lambda x^{A}.\\dots)$ to $a$. We substitute $a$ for $x$ in the body of the abstraction.\n$$ t_2 \\rightarrow_{\\beta} (\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)\\,((\\lambda w^{A}.\\,w)\\,a)\\,a $$\nLet us call this new term $t_3$.\n\nStep $4$: The term $t_3$ is parsed as $((\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)\\,((\\lambda w^{A}.\\,w)\\,a))\\,a$. The leftmost-outermost redex is the application of the selector combinator $(\\lambda u^{A}.\\,\\lambda v^{A}.\\,u)$ to its first argument, which is the term $((\\lambda w^{A}.\\,w)\\,a)$. The reduction substitutes this argument for $u$ in the body $\\lambda v^{A}.\\,u$.\n$$ t_3 \\rightarrow_{\\beta} (\\lambda v^{A}.\\,((\\lambda w^{A}.\\,w)\\,a))\\,a $$\nLet us call this new term $t_4$. Note that the substitution does not cause variable capture, as $v$ is not free in the term being substituted.\n\nStep $5$: The term $t_4$ is itself a redex. We substitute $a$ for $v$ in the body $((\\lambda w^{A}.\\,w)\\,a)$. Since $v$ does not appear free in the body, the substitution effectively discards the argument $a$ and returns the body itself.\n$$ t_4 \\rightarrow_{\\beta} (\\lambda w^{A}.\\,w)\\,a $$\nLet us call this new term $t_5$.\n\nStep $6$: The term $t_5$ is a redex, corresponding to the application of the identity function to the term $a$. We substitute $a$ for $w$ in the body $w$.\n$$ t_5 \\rightarrow_{\\beta} a $$\nThe resulting term, $a$, is a variable. It contains no $\\beta$-redexes and is therefore in normal form.\n\nThe sequence of reductions has terminated. The Curry-Howard correspondence allows for an interpretation of this normalization as a proof transformation. The initial term $t_0$ is a complex proof of proposition $A$, constructed from an assumption that $A$ is true (represented by the variable $a:A$). The process of $\\beta$-reduction simplifies this proof step by step, ultimately revealing that the entire construction reduces to the original assumption. The normalized term, $a$, is the simplest possible proof of $A$ in this context.", "answer": "$$\\boxed{a}$$", "id": "3056182"}, {"introduction": "The integrity of the Curry-Howard correspondence rests on the bedrock of type safety, which guarantees that computations are always meaningful and well-behaved. This final practice serves as a \"stress test\" to reveal why these formal rules are so critical. By intentionally introducing a rule that violates type preservation, you will discover how the system breaks down, leading to \"stuck\" states and demonstrating firsthand the importance of the progress and preservation theorems that underpin reliable typed systems.", "problem": "Consider a fragment of the simply typed lambda calculus under the Curry-Howard correspondence (CHC), where types correspond to propositions and terms correspond to proofs. The language has base types $\\mathsf{Bool}$ and $\\mathsf{Nat}$, constants $0$, $\\mathsf{true}$, $\\mathsf{false}$, and a unary constructor $\\mathsf{succ}\\, t$ for natural numbers. Typing rules include $\\Gamma \\vdash 0 : \\mathsf{Nat}$, $\\Gamma \\vdash \\mathsf{true} : \\mathsf{Bool}$, $\\Gamma \\vdash \\mathsf{false} : \\mathsf{Bool}$, and if $\\Gamma \\vdash t : \\mathsf{Nat}$ then $\\Gamma \\vdash \\mathsf{succ}\\, t : \\mathsf{Nat}$. Small-step operational semantics includes the standard evaluation context rule for the successor: if $t \\to t'$, then $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$. Values are defined inductively by $v ::= 0 \\mid \\mathsf{succ}\\, v \\mid \\mathsf{true} \\mid \\mathsf{false}$.\n\nAugment the reduction system with a single extra rule that is not type-preserving:\n$$\n0 \\to \\mathsf{true}.\n$$\nUsing only the fundamental definitions above and the widely accepted facts of progress and preservation for the unmodified system as the foundational base, construct a closed, well-typed term that, under the augmented reduction system, reduces to a term that is neither a value nor reducible by any rule (a stuck term). Explain precisely what fails under the CHC and the typing discipline when this non type-preserving rule is added, starting from first principles, and derive the explicit stuck term that results from a single-context-step driven by the added rule. Your final answer must be the explicit stuck term as a single symbolic mathematical expression. No rounding or physical units are required.", "solution": "The problem statement is evaluated as valid. It presents a well-defined formal system based on the simply typed lambda calculus and asks for an analysis of the consequences of augmenting it with a specific, non-type-preserving reduction rule. The problem is scientifically grounded in the principles of type theory and operational semantics, is internally consistent, and requires a rigorous derivation based on the provided definitions.\n\nThe foundation of a reliable typed calculus, and by extension the Curry-Howard correspondence (CHC), rests upon the property of type safety. Type safety is typically established by two key theorems: preservation and progress. The problem posits a system where the standard simply typed lambda calculus, known to possess these properties, is augmented with a rule that undermines this foundation.\n\nLet's state the key principles formally:\n1.  **Preservation (Subject Reduction):** If a term $t$ is well-typed with type $T$ in a context $\\Gamma$ (denoted $\\Gamma \\vdash t : T$) and it reduces in one step to a term $t'$ (denoted $t \\to t'$), then $t'$ must also be well-typed with the same type $T$ (i.e., $\\Gamma \\vdash t' : T$). This theorem ensures that computation preserves the type of an expression.\n2.  **Progress:** For any closed, well-typed term $t$ (i.e., $\\emptyset \\vdash t : T$ for some type $T$), either $t$ is a value or there exists a term $t'$ such that $t \\to t'$. This theorem ensures that a well-typed program never gets \"stuck\" in a non-terminal state.\n\nThe problem introduces the reduction rule $0 \\to \\mathsf{true}$. Let's analyze this rule in the context of the preservation property.\nAccording to the given typing rules:\n-   The term $0$ has the type $\\mathsf{Nat}$, formally $\\Gamma \\vdash 0 : \\mathsf{Nat}$.\n-   The term $\\mathsf{true}$ has the type $\\mathsf{Bool}$, formally $\\Gamma \\vdash \\mathsf{true} : \\mathsf{Bool}$.\n\nThe reduction $0 \\to \\mathsf{true}$ transforms a term of type $\\mathsf{Nat}$ into a term of type $\\mathsf{Bool}$. Since $\\mathsf{Nat} \\neq \\mathsf{Bool}$, this rule explicitly violates the preservation theorem. A single reduction step changes the term's type, which is forbidden in a type-safe system.\n\nThe core of the problem is to demonstrate how this violation of preservation leads to a violation of the progress theorem. We need to construct a closed, well-typed term that reduces to a \"stuck\" state—a term that is not a value and to which no reduction rules apply.\n\nWe can exploit the context-sensitive nature of the given reduction semantics. The problem provides a constructor $\\mathsf{succ}$ and a corresponding evaluation context rule: if $t \\to t'$, then $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$. This rule allows reduction to occur on the term immediately inside the $\\mathsf{succ}$ constructor. For a term $\\mathsf{succ}\\, t$ to be well-typed, its argument $t$ must have the type $\\mathsf{Nat}$.\n\nLet us construct a term using this structure.\n1.  Begin with the simplest term of type $\\mathsf{Nat}$: the constant $0$. From the given typing rules, we have $\\emptyset \\vdash 0 : \\mathsf{Nat}$.\n2.  Apply the $\\mathsf{succ}$ constructor to this term. The typing rule for $\\mathsf{succ}$ states that if $\\Gamma \\vdash t : \\mathsf{Nat}$, then $\\Gamma \\vdash \\mathsf{succ}\\, t : \\mathsf{Nat}$. Applying this, since we have $\\emptyset \\vdash 0 : \\mathsf{Nat}$, we can derive $\\emptyset \\vdash \\mathsf{succ}\\, 0 : \\mathsf{Nat}$.\n3.  The term $\\mathsf{succ}\\, 0$ is therefore a closed, well-typed term.\n\nNow, we analyze the reduction of this term in the augmented system.\n-   Our starting term is $\\mathsf{succ}\\, 0$.\n-   The system includes the evaluation context rule for $\\mathsf{succ}$: if $t \\to t'$, then $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$.\n-   The system also includes the non-type-preserving rule $0 \\to \\mathsf{true}$.\n-   We can apply the context rule by letting $t = 0$ and $t' = \\mathsf{true}$. The premise of the context rule, $0 \\to \\mathsf{true}$, is satisfied.\n-   Therefore, we derive the one-step reduction: $\\mathsf{succ}\\, 0 \\to \\mathsf{succ}\\, \\mathsf{true}$.\n\nThe well-typed term $\\mathsf{succ}\\, 0$ reduces to the term $\\mathsf{succ}\\, \\mathsf{true}$. Let us now analyze this resulting term to determine if it is stuck.\n1.  **Is $\\mathsf{succ}\\, \\mathsf{true}$ a value?** The definition of values is given as $v ::= 0 \\mid \\mathsf{succ}\\, v \\mid \\mathsf{true} \\mid \\mathsf{false}$. For a term of the form $\\mathsf{succ}\\, t$ to be a value, $t$ itself must be a value of the form $0$ or $\\mathsf{succ}\\, v'$. In our case, the argument to $\\mathsf{succ}$ is $\\mathsf{true}$. While $\\mathsf{true}$ is a value, it is not a natural number value according to the inductive structure of natural numbers ($v_{nat} ::= 0 \\mid \\mathsf{succ}\\, v_{nat}$). Thus, the term $\\mathsf{succ}\\, \\mathsf{true}$ does not match the pattern for values. It is not a value.\n\n2.  **Can $\\mathsf{succ}\\, \\mathsf{true}$ be reduced?** We must check if any reduction rule applies.\n    -   The only rule applicable to terms beginning with $\\mathsf{succ}$ is the context rule: if $t \\to t'$, then $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$. For this rule to apply to $\\mathsf{succ}\\, \\mathsf{true}$, the inner term $\\mathsf{true}$ must be able to take a reduction step.\n    -   However, $\\mathsf{true}$ is a value. By definition, values are terminal forms of computation and have no further reductions.\n    -   Since the inner term $\\mathsf{true}$ cannot be reduced, the premise of the context rule is not met.\n    -   No other reduction rules are defined that would match the structure $\\mathsf{succ}\\, \\mathsf{true}$.\n\nThe term $\\mathsf{succ}\\, \\mathsf{true}$ is not a value and no reduction rule can be applied to it. By definition, it is a stuck term.\n\nIn summary, the well-typed term $\\mathsf{succ}\\,0$ reduces to the stuck term $\\mathsf{succ}\\,\\mathsf{true}$. This constitutes a violation of the progress theorem. This failure is a direct consequence of the violation of the preservation theorem by the rule $0 \\to \\mathsf{true}$. Under the Curry-Howard correspondence, this implies a breakdown of logical consistency. The \"proof\" $\\mathsf{succ}\\,0$ of proposition $\\mathsf{Nat}$ is transformed into $\\mathsf{succ}\\,\\mathsf{true}$, which is a nonsensical construction that corresponds to neither a valid proof nor a proposition in the original system. It represents a failure in the proof normalization process, which is the logical counterpart to computation. The derived stuck term is the explicit artifact of this systemic failure.", "answer": "$$\n\\boxed{\\mathsf{succ}\\,\\mathsf{true}}\n$$", "id": "3056147"}]}