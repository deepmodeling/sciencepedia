{"hands_on_practices": [{"introduction": "This first exercise provides a guided walkthrough of a successful unification. By systematically applying the rules of decomposition and variable elimination to a set of simple equations, you will compute a Most General Unifier (MGU). This practice is foundational for understanding how automated reasoners solve symbolic equations and is the first step towards mastering the unification algorithm [@problem_id:3059956].", "problem": "Consider a single-sorted first-order signature with a binary function symbol $f$, a unary function symbol $g$, a constant symbol $a$, and variables $x$ and $y$. A substitution $\\sigma$ maps variables to terms and extends homomorphically to all terms, and a substitution $\\sigma$ is a unifier of a set of equations if, when applied to both sides of every equation, it makes them syntactically identical. A most general unifier (MGU) is a unifier $\\sigma$ such that every other unifier $\\tau$ factors through $\\sigma$ via some substitution $\\rho$ with $\\tau = \\rho \\circ \\sigma$.\n\nApply Robinson’s unification algorithm with the occurs check to the equation set $\\{\\, f(x,a) \\doteq f(g(y),a),\\; y \\doteq a \\,\\}$, starting from the core definitions of substitution, unifier, and the primitive transformation rules of the unification algorithm (orientation, decomposition, elimination, clash detection, and occurs check). Perform the algorithm step-by-step, showing each transformation and the propagation of substitutions, and determine whether an MGU exists. If it exists, prove it is most general by appealing to the fundamental definitions.\n\nExpress your final answer as the images of $x$ and $y$ under the computed MGU $\\sigma$ in the fixed variable order $(x,y)$, using the row matrix form $\\begin{pmatrix}\\sigma(x) & \\sigma(y)\\end{pmatrix}$. No rounding is required.", "solution": "The goal is to find a substitution $\\sigma$ that unifies the given set of equations $E_{0} = \\{\\, f(x,a) \\doteq f(g(y),a),\\; y \\doteq a \\,\\}$, using Robinson’s unification algorithm with the occurs check.\n\nWe recall the primitive transformation rules:\n\n- Orientation: rewrite $t \\doteq x$ as $x \\doteq t$ where $x$ is a variable.\n- Decomposition: from $f(t_{1},\\dots,t_{n}) \\doteq f(s_{1},\\dots,s_{n})$, replace by the set $\\{\\, t_{1} \\doteq s_{1},\\dots,t_{n} \\doteq s_{n} \\,\\}$.\n- Clash detection: if the top function symbols or arities differ, fail.\n- Elimination: from $x \\doteq t$ where $x$ is a variable, $x \\not= t$, and $x$ does not occur in $t$ (occurs check), apply the substitution $\\{ x \\mapsto t \\}$ to all remaining equations and accumulate it.\n- Occurs check: reject $x \\doteq t$ when $x$ occurs in $t$.\n\nStep-by-step execution:\n\n1. Start with $E_{0} = \\{\\, f(x,a) \\doteq f(g(y),a),\\; y \\doteq a \\,\\}$ and the current substitution set $\\Sigma = \\emptyset$.\n\n2. Apply decomposition to the equation $f(x,a) \\doteq f(g(y),a)$ since the top symbol $f$ and arity match. This produces the pairwise equations:\n   $$x \\doteq g(y), \\quad a \\doteq a.$$\n   The equation $a \\doteq a$ is trivially satisfied and can be dropped. The set becomes:\n   $$E_{1} = \\{\\, x \\doteq g(y),\\; y \\doteq a \\,\\}, \\quad \\Sigma = \\emptyset.$$\n\n3. Choose elimination on $y \\doteq a$. The occurs check passes because $y$ does not occur in $a$. Apply the substitution $\\sigma_{1} = \\{ y \\mapsto a \\}$ to the remaining equations and accumulate it:\n   - Applying $\\sigma_{1}$ to $x \\doteq g(y)$ yields $x \\doteq g(a)$.\n   Now we have:\n   $$E_{2} = \\{\\, x \\doteq g(a) \\,\\}, \\quad \\Sigma = \\{ y \\mapsto a \\}.$$\n\n4. Perform elimination on $x \\doteq g(a)$. The occurs check passes because $x$ does not occur in $g(a)$. Apply the substitution $\\sigma_{2} = \\{ x \\mapsto g(a) \\}$ to the remaining equations (there are none), and accumulate:\n   $$E_{3} = \\emptyset, \\quad \\Sigma = \\{ y \\mapsto a,\\; x \\mapsto g(a) \\}.$$\n\nSince the equation set is empty, the algorithm terminates successfully. The computed substitution is:\n$$\\sigma = \\{ y \\mapsto a,\\; x \\mapsto g(a) \\}.$$\n\nVerification that $\\sigma$ is a unifier:\n- Apply $\\sigma$ to $f(x,a) \\doteq f(g(y),a)$:\n  $$f(\\sigma(x),a) = f(g(a),a), \\quad f(g(\\sigma(y)),a) = f(g(a),a),$$\n  which are identical.\n- Apply $\\sigma$ to $y \\doteq a$:\n  $$\\sigma(y) = a,$$\n  which matches $a$.\n\nProof of most generality:\nLet $\\tau$ be any unifier of $E_{0}$. Because $\\tau$ must satisfy $y \\doteq a$, it follows that $\\tau(y) = a$. From the decomposition of $f(x,a) \\doteq f(g(y),a)$, $\\tau$ must also satisfy $x \\doteq g(y)$, hence:\n$$\\tau(x) = g(\\tau(y)) = g(a).$$\nTherefore, every unifier $\\tau$ must map $y \\mapsto a$ and $x \\mapsto g(a)$. Any additional action of $\\tau$ beyond these bindings can be captured by a further substitution $\\rho$ that acts on variables not in the domain of $\\sigma$ or on variables within the images in a way consistent with $\\sigma$, giving $\\tau = \\rho \\circ \\sigma$. Hence $\\sigma$ is a most general unifier (MGU) by the fundamental definition.\n\nIn the requested variable order $(x,y)$, the images under $\\sigma$ are:\n$$\\sigma(x) = g(a), \\quad \\sigma(y) = a.$$\nThus the final row matrix is $\\begin{pmatrix} g(a)  a \\end{pmatrix}$.", "answer": "$$\\boxed{\\begin{pmatrix} g(a)  a \\end{pmatrix}}$$", "id": "3059956"}, {"introduction": "Not all sets of equations can be unified, and this practice explores a crucial failure condition known as the \"occurs-check.\" This rule prevents a variable from being unified with a term that contains that same variable, thus avoiding infinite structures. By tracing an algorithm that fails this check, you will understand why standard unification is restricted to finite terms and how this safeguard prevents logical inconsistencies [@problem_id:3059943].", "problem": "Consider the first-order term algebra over a signature with unary function symbols $f$ and $g$, and variables $x$ and $y$. A unification problem is a finite set of equations of the form $s \\doteq t$ between terms, where $\\doteq$ denotes the constraint that $s$ and $t$ must be made identical by a substitution. The Martelli–Montanari Unification Algorithm (MMUA) with the occurs-check proceeds by repeatedly applying the following rules to an ordered list of equations, subject to the occurs-check: Delete (remove $s \\doteq s$), Decompose (replace $f(s_{1},\\dots,s_{n}) \\doteq f(t_{1},\\dots,t_{n})$ by the set $\\{s_{1} \\doteq t_{1},\\dots,s_{n} \\doteq t_{n}\\}$), Orient (swap $t \\doteq x$ to $x \\doteq t$), and Eliminate (replace $x \\doteq t$ with $x \\mapsto t$ applied to all remaining equations), provided the occurs-check $x \\notin \\mathrm{Vars}(t)$ succeeds. Here $\\mathrm{Vars}(t)$ denotes the set of variables occurring in term $t$. The algorithm terminates immediately upon any occurs-check failure.\n\nStarting from the ordered set of equations\n$$\n\\{\\,x \\doteq f(x),\\; g(y) \\doteq g(f(y))\\,\\},\n$$\nexecute a step-by-step failure trace under the deterministic control strategy: at each step select the leftmost equation in the current list and apply the first applicable rule in the priority order Delete, Decompose, Orient, Eliminate (with the occurs-check performed immediately before Eliminate). Explain at the point(s) where the occurs-check triggers and justify why no most general unifier (MGU) exists under first-order unification with the occurs-check.\n\nFinally, report the total number of occurs-check invocations performed before the algorithm terminates under this control strategy. Provide your final answer as a single exact number.", "solution": "The problem requires executing the Martelli–Montanari Unification Algorithm (MMUA) with a specific control strategy on a given set of equations to determine the point of failure and the total number of occurs-check invocations.\n\nThe initial ordered list of equations is $E_0 = [\\,x \\doteq f(x),\\; g(y) \\doteq g(f(y))\\,]$. The algorithm proceeds by selecting the leftmost equation at each step and applying the first applicable rule from the priority list: Delete, Decompose, Orient, Eliminate. The occurs-check, $v \\notin \\mathrm{Vars}(t)$, is a precondition for the Eliminate rule ($v \\doteq t$).\n\n**Execution Trace:**\n\n**Step 1:**\nThe algorithm begins with the equation list $E_0 = [\\,x \\doteq f(x),\\; g(y) \\doteq g(f(y))\\,]$.\n\n*   **Selection:** According to the deterministic control strategy, the leftmost equation is selected: $e_1 = (x \\doteq f(x))$.\n*   **Rule Application:** The algorithm checks for the first applicable rule for $e_1$ from the priority list:\n    1.  **Delete** ($s \\doteq s$): This rule is not applicable because the term $x$ is not syntactically identical to the term $f(x)$.\n    2.  **Decompose** ($h(s_1, \\dots) \\doteq h(t_1, \\dots)$): This rule is not applicable because the left-hand side, $x$, is a variable, not a compound term with a function symbol at its root.\n    3.  **Orient** ($t \\doteq x$ where $t$ is not a variable): This rule is not applicable because the variable $x$ is already on the left-hand side.\n    4.  **Eliminate** ($x \\doteq t$ where $x$ is a variable): This rule's form matches the equation $x \\doteq f(x)$, with the variable being $x$ and the term $t$ being $f(x)$.\n\n*   **Occurs-Check:** Before applying the Eliminate rule, the mandatory occurs-check must be performed. The condition is $x \\notin \\mathrm{Vars}(t)$.\n    *   Here, $t$ is the term $f(x)$.\n    *   The set of variables in $t$, denoted $\\mathrm{Vars}(t)$, is $\\mathrm{Vars}(f(x)) = \\{x\\}$.\n    *   The check is therefore $x \\notin \\{x\\}$, which is false.\n    *   This is the **first and only invocation** of the occurs-check in this execution trace.\n\n*   **Termination:** The occurs-check has failed. The problem statement specifies, \"The algorithm terminates immediately upon any occurs-check failure.\" Therefore, the unification process halts at this point. The second equation, $g(y) \\doteq g(f(y))$, is never processed.\n\n**Justification for the Non-existence of a Most General Unifier (MGU):**\n\nThe failure of the occurs-check on the equation $x \\doteq f(x)$ indicates that this equation is not unifiable in the standard theory of first-order logic, which deals with finite terms. A unifier is a substitution $\\sigma$ that makes two terms syntactically identical after application. For the original set of equations to have a unifier, such a unifier must satisfy all equations in the set, including $x \\doteq f(x)$.\n\nLet $\\sigma$ be a hypothetical unifier. Applying $\\sigma$ to $x \\doteq f(x)$ must yield an identity:\n$$\n\\sigma(x) \\equiv \\sigma(f(x))\n$$\nBy the definition of substitution application on terms, $\\sigma(f(x))$ is equivalent to $f(\\sigma(x))$. Thus, the condition becomes:\n$$\n\\sigma(x) \\equiv f(\\sigma(x))\n$$\nLet $T = \\sigma(x)$. The equation required for unification is $T \\equiv f(T)$. This asserts that a term $T$ is syntactically identical to the term $f(T)$. However, in the standard algebra of finite terms (represented as finite trees), a term cannot be identical to one of its proper subterms. The term $f(T)$ always contains $T$ as a direct subterm and has a structural depth that is strictly greater than the depth of $T$. No finite term $T$ can satisfy this identity. Because no substitution $\\sigma$ can satisfy the equation $x \\doteq f(x)$, no unifier exists for the initial set of equations. A most general unifier (MGU) is, by definition, a unifier. Since no unifiers exist, no MGU can exist.\n\nIn summary, the algorithm correctly terminates and reports failure because the equation $x \\doteq f(x)$ has no solution in the domain of finite-term unification.\n\n**Total Occurs-Check Invocations:**\n\nThe algorithm performed exactly one operation that required an occurs-check: the consideration of the Eliminate rule for the equation $x \\doteq f(x)$. This check failed, causing immediate termination. Therefore, the total number of occurs-check invocations performed is $1$.", "answer": "$$\\boxed{1}$$", "id": "3059943"}, {"introduction": "Unification is more than a theoretical curiosity; it is a core mechanism in fields like logic programming and type inference. This final exercise demonstrates its practical power by modeling list data structures as first-order terms, using constructors like $\\mathrm{cons}$ and $\\mathrm{nil}$. You will unify two list patterns to extract sub-structures and bind variables, simulating a common operation in symbolic computation and pattern matching [@problem_id:3059832].", "problem": "Consider the first-order signature for lists built from the constructors $\\mathrm{nil}/0$ and $\\mathrm{cons}/2$. Let $a/0$ be a constant symbol and let $x$, $y$, and $z$ be variables. A substitution is a mapping from variables to terms extended homomorphically to all terms; the application of a substitution $\\sigma$ to a term $t$ is written $t\\sigma$. A unifier of two terms $s$ and $t$ is a substitution $\\sigma$ such that $s\\sigma = t\\sigma$. A most general unifier (MGU) is a unifier $\\sigma$ such that any other unifier $\\tau$ factors through $\\sigma$, that is, there exists a substitution $\\theta$ with $\\tau = \\sigma \\circ \\theta$, where $\\circ$ denotes substitution composition.\n\nUsing only the foundational definitions above and the standard Robinson unification algorithm with the occurs-check (decomposition on identical function symbols, variable elimination when a variable does not occur in the term it is equated with, and symmetry), determine an MGU for the equation\n$$\n\\mathrm{cons}(x,\\mathrm{cons}(a,\\mathrm{nil})) \\doteq \\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}),z).\n$$\nJustify each step of your reasoning from the stated foundational rules and verify that your unifier is most general by establishing the required factorization property.\n\nAnswer specification: As your final boxed answer, provide the single closed-form term obtained by applying your computed MGU $\\sigma$ to the variable $z$, namely $z\\sigma$. No numerical rounding is required, and no units apply. Do not include any additional text in the final boxed answer beyond the term itself.", "solution": "The objective is to find a most general unifier (MGU) for the equation $\\mathrm{cons}(x,\\mathrm{cons}(a,\\mathrm{nil})) \\doteq \\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}),z)$. We will use the Robinson unification algorithm, which operates on a set of equations to be solved.\n\nLet the initial set of equations be $E_0 = \\{ \\mathrm{cons}(x,\\mathrm{cons}(a,\\mathrm{nil})) \\doteq \\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}),z) \\}$.\n\n**Step 1: Decomposition**\nThe root symbol on both sides of the equation in $E_0$ is the same function symbol, $\\mathrm{cons}/2$. We apply the **decomposition** rule, which states that an equation $f(s_1, \\dots, s_n) \\doteq f(t_1, \\dots, t_n)$ can be replaced by the set of equations $\\{ s_1 \\doteq t_1, \\dots, s_n \\doteq t_n \\}$.\nApplying this rule to the single equation in $E_0$, we obtain a new set of equations, $E_1$:\n$$ E_1 = \\{ x \\doteq \\mathrm{cons}(y,\\mathrm{nil}), \\quad \\mathrm{cons}(a,\\mathrm{nil}) \\doteq z \\} $$\nThe unification algorithm has not yet generated any substitution components.\n\n**Step 2: Variable Elimination**\nWe select an equation from $E_1$ of the form $v \\doteq t$ where $v$ is a variable. Let us select the first equation, $x \\doteq \\mathrm{cons}(y,\\mathrm{nil})$.\nWe apply the **variable elimination** rule, which requires an **occurs-check**. The variable $x$ does not occur in the term $\\mathrm{cons}(y,\\mathrm{nil})$. Therefore, we can proceed.\nWe generate the substitution component $\\sigma_1 = \\{ x \\mapsto \\mathrm{cons}(y,\\mathrm{nil}) \\}$.\nWe apply this substitution to the remaining equations in the set. The only remaining equation is $\\mathrm{cons}(a,\\mathrm{nil}) \\doteq z$. Since $x$ does not appear in this equation, applying $\\sigma_1$ has no effect.\nThe new set of equations is $E_2 = \\{ \\mathrm{cons}(a,\\mathrm{nil}) \\doteq z \\}$, and our accumulated substitution is $\\sigma_1$.\n\n**Step 3: Symmetry and Variable Elimination**\nWe now process the single equation in $E_2$, which is $\\mathrm{cons}(a,\\mathrm{nil}) \\doteq z$.\nThis is of the form $t \\doteq v$. We first apply the **symmetry** rule to transform it into the form $v \\doteq t$:\n$$ z \\doteq \\mathrm{cons}(a,\\mathrm{nil}) $$\nNow we apply **variable elimination**. The **occurs-check** is satisfied, as the variable $z$ does not occur in the term $\\mathrm{cons}(a,\\mathrm{nil})$.\nWe generate the substitution component $\\sigma_2 = \\{ z \\mapsto \\mathrm{cons}(a,\\mathrm{nil}) \\}$.\nWe must apply $\\sigma_2$ to the range of our previously accumulated substitution, $\\sigma_1$. The range of $\\sigma_1$ is the term $\\mathrm{cons}(y,\\mathrm{nil})$. Since $z$ does not appear in this term, applying $\\sigma_2$ has no effect. The set of remaining equations is now empty.\nThe algorithm terminates successfully.\n\n**Step 4: Compose Substitutions**\nThe final MGU, $\\sigma$, is the composition of the substitutions generated: $\\sigma = \\sigma_1 \\circ \\sigma_2$.\nTo compose $\\sigma_1 = \\{ x \\mapsto \\mathrm{cons}(y,\\mathrm{nil}) \\}$ and $\\sigma_2 = \\{ z \\mapsto \\mathrm{cons}(a,\\mathrm{nil}) \\}$, we apply $\\sigma_2$ to the range of $\\sigma_1$ and then take the union of the resulting bindings with $\\sigma_2$.\nApplying $\\sigma_2$ to $\\mathrm{cons}(y,\\mathrm{nil})$ gives $\\mathrm{cons}(y,\\mathrm{nil})$ itself, as $z$ is not present.\nThus, the final MGU is:\n$$ \\sigma = \\{ x \\mapsto \\mathrm{cons}(y,\\mathrm{nil}), \\quad z \\mapsto \\mathrm{cons}(a,\\mathrm{nil}) \\} $$\nThe variable $y$ remains uninstantiated, which is expected as it parameterizes the family of all possible unifiers.\n\n### Verification of the MGU\nFirst, we verify that $\\sigma$ is a unifier by applying it to both sides of the original equation.\nLeft-hand side:\n$ (\\mathrm{cons}(x,\\mathrm{cons}(a,\\mathrm{nil})))\\sigma = \\mathrm{cons}(x\\sigma, (\\mathrm{cons}(a,\\mathrm{nil}))\\sigma) = \\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}), \\mathrm{cons}(a,\\mathrm{nil})) $\nRight-hand side:\n$ (\\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}),z))\\sigma = \\mathrm{cons}((\\mathrm{cons}(y,\\mathrm{nil}))\\sigma, z\\sigma) = \\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}), \\mathrm{cons}(a,\\mathrm{nil})) $\nSince both sides yield the same term, $\\sigma$ is a unifier.\n\nSecond, we must verify that $\\sigma$ is a *most general* unifier. Let $\\tau$ be any other unifier for the original equation. We must show there exists a substitution $\\theta$ such that $\\tau = \\sigma \\circ \\theta$.\nSince $\\tau$ is a unifier, we have $(\\mathrm{cons}(x,\\mathrm{cons}(a,\\mathrm{nil})))\\tau = (\\mathrm{cons}(\\mathrm{cons}(y,\\mathrm{nil}),z))\\tau$.\nExpanding this equality, we get $\\mathrm{cons}(x\\tau, \\mathrm{cons}(a,\\mathrm{nil})) = \\mathrm{cons}(\\mathrm{cons}(y\\tau,\\mathrm{nil}), z\\tau)$.\nBy decomposition, this implies two identities:\n1. $x\\tau = \\mathrm{cons}(y\\tau,\\mathrm{nil})$\n2. $z\\tau = \\mathrm{cons}(a,\\mathrm{nil})$\n\nThe relation $\\tau = \\sigma \\circ \\theta$ means that for any variable $v$, $v\\tau = (v\\sigma)\\theta$. Let's examine this for all relevant variables.\n- For the variable $x$: We need $x\\tau = (x\\sigma)\\theta$. We have $x\\sigma = \\mathrm{cons}(y,\\mathrm{nil})$. So we need $x\\tau = (\\mathrm{cons}(y,\\mathrm{nil}))\\theta = \\mathrm{cons}(y\\theta,\\mathrm{nil})$. From identity (1), we know $x\\tau = \\mathrm{cons}(y\\tau, \\mathrm{nil})$. Comparing these, we require $y\\theta = y\\tau$.\n- For the variable $z$: We need $z\\tau = (z\\sigma)\\theta$. We have $z\\sigma = \\mathrm{cons}(a,\\mathrm{nil})$. So we need $z\\tau = (\\mathrm{cons}(a,\\mathrm{nil}))\\theta = \\mathrm{cons}(a,\\mathrm{nil})$. Identity (2) confirms that this is true.\n- For the variable $y$: We need $y\\tau = (y\\sigma)\\theta$. Since $y$ is not in the domain of $\\sigma$, $y\\sigma = y$. So we need $y\\tau = y\\theta$. This is the same constraint we found for $x$.\n- For any other variable $w \\notin \\{x, y, z\\}$: We need $w\\tau = (w\\sigma)\\theta = w\\theta$.\n\nWe can construct the required substitution $\\theta$ as follows. Let the set of variables not in the domain of $\\sigma$, $D(\\sigma) = \\{x, z\\}$, be $V' = V \\setminus D(\\sigma)$. We define $\\theta$ such that for every variable $v \\in V'$, $v\\theta = v\\tau$.\nThis definition satisfies $y\\theta=y\\tau$ and $w\\theta=w\\tau$ for any other variable $w$. This construction of $\\theta$ is always possible. Therefore, we have shown that $\\tau$ factors through $\\sigma$, confirming that $\\sigma$ is a most general unifier.\n\n### Final Answer Formulation\nThe problem asks for the term $z\\sigma$. From our MGU $\\sigma = \\{ x \\mapsto \\mathrm{cons}(y,\\mathrm{nil}), z \\mapsto \\mathrm{cons}(a,\\mathrm{nil}) \\}$, we can directly find this term:\n$$ z\\sigma = \\mathrm{cons}(a,\\mathrm{nil}) $$\nThis is the final answer.", "answer": "$$\\boxed{\\mathrm{cons}(a,\\mathrm{nil})}$$", "id": "3059832"}]}