{"hands_on_practices": [{"introduction": "The power of first-order resolution lies in its ability to work with variables, generalizing proofs that would otherwise require exploring many specific ground instances. This first practice [@problem_id:3050842] illuminates the connection between concrete, ground-level reasoning and abstract, first-order deduction. By first constructing a simple proof with specific constants and then \"lifting\" it, you will gain a hands-on understanding of how the Most General Unifier (MGU) enables a single, elegant proof at the first-order level.", "problem": "Consider the following clause set over a first-order language with predicate symbols $P$, $Q$, and $R$, a constant symbol $a$, and a unary function symbol $g$:\n$$\nS \\;=\\; \\{\\;\\lnot P(x)\\,\\lor\\,Q(g(x)),\\;\\lnot R(y)\\,\\lor\\,P(y),\\;R(a)\\;\\}.\n$$\nUse only the binary resolution rule for first-order logic with most general unification (MGU). Begin from the fundamental definitions of a clause, a literal, a substitution, and the binary resolution inference rule for first-order logic. \n\nTasks:\n- Produce a ground derivation of the ground clause $Q(g(a))$ from $S$ by instantiating variables with ground terms and applying binary resolution at the ground level.\n- Then explicitly give a lifted derivation that mirrors your ground derivation, identifying at each lifted resolution step the most general unifier used. You may also present an equivalent single lifted step that first resolves $\\lnot P(x)\\lor Q(g(x))$ with $\\lnot R(y)\\lor P(y)$ to obtain a non-ground resolvent, and then resolves that resolvent with $R(a)$.\n- Your final reported quantity must be the minimal number of binary resolution steps required to derive $Q(g(a))$ from $S$. Report this number as your final answer. No rounding is required and do not include any units.", "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- Predicate symbols: $P$, $Q$, $R$.\n- Constant symbol: $a$.\n- Unary function symbol: $g$.\n- Clause set $S = \\{\\lnot P(x)\\,\\lor\\,Q(g(x)),\\;\\lnot R(y)\\,\\lor\\,P(y),\\;R(a)\\}$.\n- Inference rule: Binary resolution with most general unification (MGU).\n- Task 1: Produce a ground derivation of the ground clause $Q(g(a))$.\n- Task 2: Produce a lifted derivation that mirrors the ground derivation, identifying MGUs. An alternative lifted derivation path is also suggested.\n- Task 3: Report the minimal number of binary resolution steps required to derive $Q(g(a))$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed for validity.\n- **Scientifically Grounded:** The problem is a standard exercise in computational logic, a well-established subfield of mathematical logic and computer science. The concepts of first-order logic, clauses, resolution, and unification are fundamental and rigorously defined. The problem is scientifically sound.\n- **Well-Posed:** The problem provides a complete set of clauses and a specific goal. The rules of inference are explicitly stated. The question of finding the minimal number of steps has a unique, well-defined answer. The problem is unambiguous and well-posed.\n- **Objective:** The problem is stated using the formal language of mathematical logic. There are no subjective, opinion-based, or ambiguous terms.\n- **Other Flaws:** The problem does not exhibit any of the defined flaws (e.g., incompleteness, contradiction, factual unsoundness). It is a formal, self-contained, and solvable problem.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution\nThe solution begins with the fundamental definitions as requested, followed by the derivations.\n\n**Fundamental Definitions:**\n- **Literal:** A literal is an atomic formula (a positive literal) or the negation of an atomic formula (a negative literal). For example, $P(x)$ and $\\lnot R(y)$ are literals.\n- **Clause:** A clause is a finite set of literals, which is implicitly understood as the universal closure of the disjunction of those literals. For instance, the clause $\\{\\lnot P(x), Q(g(x))\\}$ represents the formula $\\forall x (\\lnot P(x) \\lor Q(g(x)))$.\n- **Substitution:** A substitution $\\theta$ is a finite mapping of variables to terms, e.g., $\\theta = \\{x/a, y/g(z)\\}$. Applying a substitution $\\theta$ to an expression $E$, denoted $E\\theta$, replaces every free occurrence of a variable $v$ in the domain of $\\theta$ with the term $\\theta(v)$.\n- **Unification:** Two expressions $E_1$ and $E_2$ are unifiable if there exists a substitution $\\theta$, called a unifier, such that $E_1\\theta = E_2\\theta$.\n- **Most General Unifier (MGU):** A unifier $\\theta$ for a set of expressions is a most general unifier if for any other unifier $\\sigma$, there exists a substitution $\\lambda$ such that $\\sigma$ is the composition $\\theta\\lambda$. The MGU is unique up to variable renaming.\n- **Binary Resolution Rule:** Given two parent clauses $C_1$ and $C_2$ that are standardized apart (i.e., they share no variables). Let $L_1 \\in C_1$ and $L_2 \\in C_2$ be two literals such that their atoms are unifiable with an MGU $\\theta$, and one literal is positive while the other is negative. The binary resolvent of $C_1$ and $C_2$ is the clause $( (C_1 \\setminus \\{L_1\\}) \\cup (C_2 \\setminus \\{L_2\\}) )\\theta$.\n\nLet the initial set of clauses be denoted:\n- $C_1 = \\{\\lnot P(x), Q(g(x))\\}$\n- $C_2 = \\{\\lnot R(y), P(y)\\}$\n- $C_3 = \\{R(a)\\}$\n\n**Ground Derivation**\nTo produce a ground derivation, we first instantiate the clauses in $S$ with ground terms. The only ground term available is $a$.\n1.  Instantiate $C_1$ with the substitution $\\{x/a\\}$ to get $C'_1 = \\{\\lnot P(a), Q(g(a))\\}$.\n2.  Instantiate $C_2$ with the substitution $\\{y/a\\}$ to get $C'_2 = \\{\\lnot R(a), P(a)\\}$.\n3.  $C_3 = \\{R(a)\\}$ is already a ground clause.\n\nNow we apply propositional resolution on the ground clauses $C'_1, C'_2, C_3$:\n- **Step 1:** Resolve $C'_2 = \\{\\lnot R(a), P(a)\\}$ with $C_3 = \\{R(a)\\}$. The complementary literals are $\\lnot R(a)$ and $R(a)$. The resolvent is $C'_4 = \\{P(a)\\}$.\n- **Step 2:** Resolve $C'_1 = \\{\\lnot P(a), Q(g(a))\\}$ with the newly derived clause $C'_4 = \\{P(a)\\}$. The complementary literals are $\\lnot P(a)$ and $P(a)$. The resolvent is $C'_5 = \\{Q(g(a))\\}$.\n\nThis derivation produces the goal clause $Q(g(a))$ in $2$ ground resolution steps.\n\n**Lifted Derivation (Mirroring the Ground Derivation)**\nThis derivation applies resolution directly to the first-order clauses without prior instantiation.\n- **Step 1:** Resolve $C_2 = \\{\\lnot R(y), P(y)\\}$ with $C_3 = \\{R(a)\\}$.\n  - The literals to resolve are $\\lnot R(y)$ and $R(a)$.\n  - The atoms $R(y)$ and $R(a)$ are unified.\n  - The most general unifier (MGU) is $\\theta_1 = \\{y/a\\}$.\n  - The resolvent is $C_4 = ( (C_2 \\setminus \\{\\lnot R(y)\\}) \\cup (C_3 \\setminus \\{R(a)\\}) )\\theta_1 = (\\{P(y)\\} \\cup \\emptyset)\\{y/a\\} = \\{P(a)\\}$.\n\n- **Step 2:** Resolve $C_1 = \\{\\lnot P(x), Q(g(x))\\}$ with the new clause $C_4 = \\{P(a)\\}$.\n  - The literals to resolve are $\\lnot P(x)$ and $P(a)$.\n  - The atoms $P(x)$ and $P(a)$ are unified.\n  - The MGU is $\\theta_2 = \\{x/a\\}$.\n  - The resolvent is $C_5 = ( (C_1 \\setminus \\{\\lnot P(x)\\}) \\cup (C_4 \\setminus \\{P(a)\\}) )\\theta_2 = (\\{Q(g(x))\\} \\cup \\emptyset)\\{x/a\\} = \\{Q(g(a))\\}$.\n\nThis lifted derivation also produces the goal clause $Q(g(a))$ in $2$ resolution steps.\n\n**Alternative Lifted Derivation**\nAs suggested in the problem statement, we can first resolve $C_1$ and $C_2$. The variables in the clauses, $x$ and $y$, are already disjoint (standardized apart).\n- **Step 1:** Resolve $C_1 = \\{\\lnot P(x), Q(g(x))\\}$ with $C_2 = \\{\\lnot R(y), P(y)\\}$.\n  - The literals to resolve are $\\lnot P(x)$ and $P(y)$.\n  - The atoms $P(x)$ and $P(y)$ are unified.\n  - The MGU is $\\theta_1 = \\{x/y\\}$ (or equivalently, $\\{y/x\\}$).\n  - The resolvent is $C_6 = (\\{Q(g(x))\\} \\cup \\{\\lnot R(y)\\})\\theta_1 = \\{\\lnot R(y), Q(g(y))\\}$.\n\n- **Step 2:** Resolve the new clause $C_6 = \\{\\lnot R(y), Q(g(y))\\}$ with $C_3 = \\{R(a)\\}$.\n  - The literals to resolve are $\\lnot R(y)$ and $R(a)$.\n  - The atoms $R(y)$ and $R(a)$ are unified.\n  - The MGU is $\\theta_2 = \\{y/a\\}$.\n  - The resolvent is $C_7 = (\\{Q(g(y))\\} \\cup \\emptyset)\\theta_2 = \\{Q(g(a))\\}$.\n\nThis alternative derivation likewise requires $2$ resolution steps.\n\n**Minimal Number of Steps**\nTo derive $Q(g(a))$, we require a clause containing $Q(...)` or $Q(g(...))$. Only $C_1 = \\{\\lnot P(x), Q(g(x))\\}$ contains the $Q$ predicate. Thus, any derivation of a clause containing $Q(g(a))$ must involve $C_1$ at some step. To obtain the singleton clause $\\{Q(g(a))\\}$, the literal $\\lnot P(x)$ must be resolved away. This requires resolving $C_1$ with a clause containing a positive literal of the form $P(t)$ for some term $t$. No such clause exists in the initial set $S$. The only way to generate a clause like $\\{P(t)\\}$ is by resolving $C_2 = \\{\\lnot R(y), P(y)\\}$ with $C_3 = \\{R(a)\\}$, which produces $\\{P(a)\\}$. This is one resolution step. Then, resolving $\\{P(a)\\}$ with $C_1$ is a second step. Therefore, a minimum of $2$ steps is required. A single step is impossible as no two clauses in $S$ can resolve to produce $\\{Q(g(a))\\}$ directly.\n\nThe minimal number of binary resolution steps required to derive $Q(g(a))$ from $S$ is $2$.", "answer": "$$\n\\boxed{2}\n$$", "id": "3050842"}, {"introduction": "At the heart of every resolution step is the unification algorithm, which finds the \"right\" substitutions to make two literals complementary. This process, however, is governed by a crucial constraint known as the \"occurs check.\" This exercise [@problem_id:3050868] challenges you with a classic case where unification fails, forcing you to step through the process and see precisely why a variable cannot be unified with a term that contains it, preventing infinite loops and ensuring the logical soundness of the procedure.", "problem": "In first-order logic with function symbols and variables, resolution depends on the ability to unify terms. Unification attempts to find a substitution that makes two terms syntactically identical, subject to the occurs check, which prohibits assigning a variable to a term that contains that variable. Consider the set of terms $\\{f(x,x), f(g(y), y)\\}$ over a language with unary function symbol $g$ and binary function symbol $f$, and variables $x$ and $y$. Determine whether these two terms are unifiable under the occurs check by systematically attempting to solve the induced equations between their corresponding subterms and identifying any violation of the occurs check. If they are unifiable, provide the most general unifier (Most General Unifier (MGU)) as a single substitution written in set notation of the form $\\{x \\mapsto t_{x}, y \\mapsto t_{y}\\}$. If they are not unifiable under the occurs check, your final answer must be the empty set $\\varnothing$ to indicate that the set of unifiers is empty. The final answer must be a single symbolic mathematical expression.", "solution": "The problem requires determining whether the two terms $f(x,x)$ and $f(g(y), y)$ are unifiable, subject to the occurs check. Unification is the process of finding a substitution for variables that makes two logical expressions syntactically identical. If such a substitution exists, the terms are unifiable; otherwise, they are not. The most general unifier (MGU) is a substitution that is more general than any other unifier.\n\nWe begin by setting up an equation between the two terms:\n$$f(x,x) = f(g(y), y)$$\n\nThe unification algorithm proceeds by decomposing the initial equation. Since the outermost function symbols on both sides are identical (both are $f$), we can equate their respective arguments. This yields a set of two simultaneous equations:\n1. $$x = g(y)$$\n2. $$x = y$$\n\nThis set of equations, $\\{x = g(y), x = y\\}$, must be solved to find a consistent substitution. We can attempt to solve this system by using one equation to substitute into the other.\n\nLet's use the second equation, $x = y$. This equation suggests a substitution where either $x$ is replaced by $y$ or $y$ is replaced by $x$. Let's choose the substitution $\\sigma_1 = \\{x \\mapsto y\\}$. We apply this substitution to the first equation, $x = g(y)$.\n\nApplying $\\sigma_1$ to the left side of the first equation, $x$, results in $y$.\nApplying $\\sigma_1$ to the right side, $g(y)$, results in $g(y)$ (since the variable $x$ does not appear).\n\nThis transforms the first equation into:\n$$y = g(y)$$\n\nWe now have a new equation to solve. According to the rules of unification, an equation of the form $V = T$, where $V$ is a variable and $T$ is a term, can be resolved by the substitution $\\{V \\mapsto T\\}$. However, this is only permissible if the variable $V$ does not occur within the term $T$. This condition is known as the **occurs check**.\n\nIn our derived equation, $y = g(y)$, the variable to be substituted is $y$, and the term is $g(y)$. We must perform the occurs check: does the variable $y$ appear in the term $g(y)$? Yes, it clearly does.\n\nThe substitution $\\{y \\mapsto g(y)\\}$ would lead to an infinite regress. Substituting $y$ with $g(y)$ would yield $g(y) = g(g(y))$, which simplifies to $y = g(y)$ after applying the substitution again, and so on. This represents an attempt to unify a variable with a term that contains that same variable, creating an infinite term, which is disallowed in standard first-order logic.\n\nBecause the variable $y$ occurs in the term $g(y)$, the occurs check fails. The failure of the occurs check at this step implies that there is no finite substitution that can make the original set of equations consistent.\n\nTherefore, the unification process terminates in failure. The terms $f(x,x)$ and $f(g(y), y)$ are not unifiable. Consequently, the set of unifiers is the empty set.", "answer": "$$\\boxed{\\varnothing}$$", "id": "3050868"}, {"introduction": "Having explored the link between ground and lifted proofs and the mechanics of unification, you are now ready to conduct a full resolution refutation. This practice [@problem_id:3050890] provides an unsatisfiable set of clauses and tasks you with finding the sequence of resolution steps that leads to the empty clause, thereby proving unsatisfiability. Successfully completing this exercise is akin to simulating an automated theorem prover and solidifies your ability to apply the resolution principle to derive a contradiction from first principles.", "problem": "Let $\\mathcal{L}$ be a first-order language with a constant symbol $a$, a unary function symbol $f$, and a unary predicate symbol $P$. Consider the following set of clauses in clausal form:\n- $C_{1}: P(a)$,\n- $C_{2}: \\lnot P(x) \\lor P(f(x))$,\n- $C_{3}: \\lnot P(f(f(a)))$.\n\nTasks:\n1. Using the first-order resolution rule with standard unification, construct a complete resolution refutation that derives the empty clause $\\Box$ from $\\{C_{1}, C_{2}, C_{3}\\}$.\n2. Let a binary resolution inference be defined as resolving exactly one pair of complementary literals between two clauses to produce their resolvent (no factoring, paramodulation, or other inference rules are allowed). Count only such binary resolution inferences as steps. What is the minimal number of binary resolution inferences required to refute $\\{C_{1}, C_{2}, C_{3}\\}$?\n\nProvide your reasoning from first principles of clauses, unification, and the resolution rule. The final answer must be a single integer giving the minimal number of binary resolution inferences. No rounding is needed.", "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- First-order language with constant `a`, function `f`, predicate `P`.\n- Clause set: $C_1 = \\{P(a)\\}$, $C_2 = \\{\\lnot P(x) \\lor P(f(x))\\}$, $C_3 = \\{\\lnot P(f(f(a)))\\}$.\n- Inference rule: Binary resolution with MGU.\n- Task 1: Construct a complete resolution refutation.\n- Task 2: Find the minimal number of binary resolution inferences.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed for validity.\n- **Scientifically Grounded:** The problem is a classic refutation exercise in automated reasoning, a core topic in computational logic. All terms and rules are standard. The problem is scientifically sound.\n- **Well-Posed:** The set of clauses is unsatisfiable, and a refutation exists. The question of minimality is well-defined. The problem is unambiguous.\n- **Objective:** The problem is formal and objective.\n- **Other Flaws:** No flaws are present.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution\nWe are given the following set of clauses:\n- $C_1 = \\{P(a)\\}$\n- $C_2 = \\{\\lnot P(x) \\lor P(f(x))\\}$\n- $C_3 = \\{\\lnot P(f(f(a)))\\}$\n\nOur goal is to derive the empty clause ($\\Box$) using binary resolution, thereby proving the set is unsatisfiable.\n\n**Task 1: Resolution Refutation**\n\nThe derivation proceeds as follows:\n\n- **Step 1:** Resolve $C_1$ with $C_2$.\n  - Parent clauses: $\\{P(a)\\}$ and $\\{\\lnot P(x) \\lor P(f(x))\\}$.\n  - Literals to resolve: $P(a)$ and $\\lnot P(x)$.\n  - The Most General Unifier (MGU) for the atoms $P(a)$ and $P(x)$ is $\\theta_1 = \\{x/a\\}$.\n  - The resolvent is formed by combining the remaining literals and applying the substitution: $(\\emptyset \\cup \\{P(f(x))\\})\\theta_1 = \\{P(f(a))\\}$.\n  - Let's call this new clause $C_4 = \\{P(f(a))\\}$.\n\n- **Step 2:** Resolve the newly generated clause $C_4$ with $C_2$.\n  - To avoid variable capture, we use a variant of $C_2$ with a fresh variable, say $C'_2 = \\{\\lnot P(y) \\lor P(f(y))\\}$.\n  - Parent clauses: $\\{P(f(a))\\}$ and $\\{\\lnot P(y) \\lor P(f(y))\\}$.\n  - Literals to resolve: $P(f(a))$ and $\\lnot P(y)$.\n  - The MGU for the atoms $P(f(a))$ and $P(y)$ is $\\theta_2 = \\{y/f(a)\\}$.\n  - The resolvent is $(\\emptyset \\cup \\{P(f(y))\\})\\theta_2 = \\{P(f(f(a)))\\}$.\n  - Let's call this new clause $C_5 = \\{P(f(f(a)))\\}$.\n\n- **Step 3:** Resolve $C_5$ with $C_3$.\n  - Parent clauses: $\\{P(f(f(a)))\\}$ and $\\{\\lnot P(f(f(a)))\\}$.\n  - Literals to resolve: $P(f(f(a)))$ and $\\lnot P(f(f(a)))$.\n  - These are direct complements. The atoms are identical, so the MGU is the empty substitution.\n  - The resolvent is the union of the remaining literals, which is the empty set: $\\emptyset \\cup \\emptyset = \\emptyset$. This is the **empty clause**, $\\Box$.\n\nHaving derived the empty clause, we have successfully refuted the initial set of clauses.\n\n**Task 2: Minimal Number of Inferences**\n\nWe have found a refutation in 3 steps. We must argue that this is minimal.\n\n- To derive the empty clause, we must eventually use clause $C_3 = \\{\\lnot P(f(f(a)))\\}$. This is because it is the only clause containing a negative literal that can resolve against a clause leading to the contradiction.\n- The final resolution step must, therefore, be between $\\{\\lnot P(f(f(a)))\\}$ and a clause $\\{P(f(f(a)))\\}$.\n- Let's trace how to derive $\\{P(f(f(a)))\\}$. This clause contains the term $f(f(a))$, which has two applications of the function symbol $f$.\n- The only clause that can introduce the function symbol $f$ into a term is $C_2 = \\{\\lnot P(x) \\lor P(f(x))\\}$.\n- The only ground fact we start with is $C_1 = \\{P(a)\\}$.\n- To generate a term with one application of $f$, we must resolve $C_1$ with $C_2$. This is our Step 1, which yields $\\{P(f(a))\\}$. This step is necessary.\n- To generate a term with two applications of $f$, we must resolve $\\{P(f(a))\\}$ with $C_2$. This is our Step 2, which yields $\\{P(f(f(a)))\\}$. This step is also necessary.\n- Finally, to derive the empty clause, we must resolve $\\{P(f(f(a)))\\}$ with $C_3$. This is our Step 3.\n- This shows a necessary path of 3 steps. No two clauses from the original set $\\{C_1, C_2, C_3\\}$ can resolve to produce the empty clause in a single step. A 2-step refutation is also not possible as it would require bypassing one of the necessary term-building steps.\n\nTherefore, the minimal number of binary resolution inferences required is 3.", "answer": "$$ \\boxed{3} $$", "id": "3050890"}]}