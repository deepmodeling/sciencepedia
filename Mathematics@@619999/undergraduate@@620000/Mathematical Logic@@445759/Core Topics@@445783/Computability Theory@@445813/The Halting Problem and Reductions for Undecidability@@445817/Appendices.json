{"hands_on_practices": [{"introduction": "The theory of undecidability is a practical tool for classifying the limits of computation, and reduction is its primary instrument. To prove a new problem $P$ is unsolvable, we can show that a known unsolvable problem, like the Halting Problem ($H_{TM}$), reduces to it ($H_{TM} \\le_T P$). This exercise [@problem_id:1468148] provides a classic scenario to practice this fundamental proof technique, which establishes that $P$ must be at least as hard as the Halting Problem and, therefore, undecidable.", "problem": "In computability theory, a problem $A$ is said to be Turing-reducible to a problem $B$, denoted $A \\le_T B$, if an algorithm for problem $A$ can be constructed assuming the existence of a hypothetical subroutine, known as an oracle, which can solve any instance of problem $B$ in a single step. This means that if we had a way to solve $B$, we could also solve $A$.\n\nA cornerstone of this theory is the Halting Problem for Turing Machines (TMs), which we denote as $H_{TM}$. This is the problem of determining, from a description of an arbitrary TM and an input, whether the machine will eventually halt or continue to run forever. It is a foundational result that $H_{TM}$ is an undecidable problem; no algorithm exists that can solve all instances of the Halting Problem.\n\nSuppose a computer scientist is studying a new, esoteric problem related to database query optimization, which we will call problem $P$. After a significant breakthrough, they manage to prove that the Halting Problem is Turing-reducible to problem $P$. That is, they have formally shown that $H_{TM} \\le_T P$.\n\nBased solely on this proven reduction, what is the most precise conclusion that can be drawn about the decidability of problem $P$?\n\nA. Problem $P$ is decidable.\n\nB. Problem $P$ is undecidable.\n\nC. The decidability of problem $P$ cannot be determined; it could be either decidable or undecidable.\n\nD. The scenario is impossible, as the undecidable Halting Problem cannot be Turing-reducible to any other problem.", "solution": "By definition, $A \\le_T B$ means there exists an oracle Turing machine that decides $A$ when given an oracle for $B$. Formally, given $H_{TM} \\le_T P$, there exists an oracle Turing machine $M^{P}$ such that, with access to an oracle for $P$, $M^{P}$ decides $H_{TM}$.\n\nAssume, for the sake of contradiction, that $P$ is decidable. Then there exists a standard (non-oracle) Turing machine $D_{P}$ that decides $P$, i.e., $D_{P}$ halts on all inputs and correctly answers membership in $P$.\n\nConstruct a standard Turing machine $N$ that decides $H_{TM}$ by simulating $M^{P}$ and, whenever $M^{P}$ would make an oracle query to $P$, $N$ instead runs $D_{P}$ on that query and uses the result in place of the oracle’s answer. Because $D_{P}$ halts on all inputs, every simulated oracle query returns in finite time, so $N$ halts if and only if $M^{P}$ would halt with the oracle. Therefore $N$ decides $H_{TM}$.\n\nThis yields the implication\n$$\nH_{TM} \\le_T P \\land \\text{$P$ decidable} \\implies \\text{$H_{TM}$ decidable}.\n$$\nHowever, it is a known fact that $H_{TM}$ is undecidable, which contradicts the conclusion. Hence the assumption that $P$ is decidable must be false, and $P$ is undecidable.\n\nTherefore, the most precise conclusion is that $P$ is undecidable. The scenario is not impossible: many problems have $H_{TM}$ Turing-reducible to them.", "answer": "$$\\boxed{B}$$", "id": "1468148"}, {"introduction": "In mathematical proofs, the direction of an argument is everything, and this is especially true for reductions. A common mistake when trying to prove a problem $P$ is undecidable is to show that $P$ reduces to a known undecidable problem $U$ (i.e., $P \\le_m U$), which unfortunately proves nothing about the difficulty of $P$. This practice problem [@problem_id:1457073] challenges you to identify and explain this critical error in reasoning, an essential step toward mastering the logic of undecidability proofs.", "problem": "A student in a theory of computation course, Alice, is tasked with proving that a particular language, $\\text{TOTAL\\_TM}$, is undecidable. The language is defined as $\\text{TOTAL\\_TM} = \\{ \\langle M \\rangle \\mid M \\text{ is a Turing Machine (TM) that halts on all possible input strings} \\}$.\n\nAlice knows that the standard halting problem, $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM that halts on input } w \\}$, is a famous undecidable language.\n\nTo prove her claim, she correctly constructs a computable function $f$ that transforms any instance $\\langle M \\rangle$ of $\\text{TOTAL\\_TM}$ into an instance $\\langle M', w' \\rangle = f(\\langle M \\rangle)$ of $A_{TM}$, such that $\\langle M \\rangle \\in \\text{TOTAL\\_TM}$ if and only if $\\langle M', w' \\rangle \\in A_{TM}$. This establishes a mapping reduction from $\\text{TOTAL\\_TM}$ to $A_{TM}$ (denoted as $\\text{TOTAL\\_TM} \\le_m A_{TM}$).\n\nAlice then concludes her proof: \"Since I have shown that $\\text{TOTAL\\_TM}$ is reducible to $A_{TM}$, and we know that $A_{TM}$ is undecidable, it logically follows that $\\text{TOTAL\\_TM}$ must also be undecidable.\"\n\nWhich of the following statements best explains the fundamental flaw in Alice's reasoning?\n\nA. To prove a language $P$ is undecidable via reduction, one must reduce a known undecidable language $U$ *to* $P$ (i.e., show $U \\le_m P$), not the other way around. Alice's reduction direction is incorrect for her stated purpose.\n\nB. The language $\\text{TOTAL\\_TM}$ is not Turing-recognizable, whereas $A_{TM}$ is. A mapping reduction is only valid between languages that are in the same class of recognizability (i.e., both are recognizable or both are not).\n\nC. Alice's argument is circular. In order to construct the computable function $f$, she must have implicitly assumed a method for deciding $\\text{TOTAL\\_TM}$, which contradicts the claim she is trying to prove.\n\nD. The reduction is invalid because $\\text{TOTAL\\_TM}$ is known to be a \"harder\" problem than $A_{TM}$. It is a foundational theorem of computability theory that one cannot reduce a computationally harder problem to an easier one.\n\nE. Any reduction from a language that takes a single encoding $\\langle M \\rangle$ as input to a language that takes a pair $\\langle M, w \\rangle$ as input is inherently flawed because it requires manufacturing information (the string $w$) that was not present in the original input.", "solution": "We are given the language $\\text{TOTAL\\_TM} = \\{ \\langle M \\rangle \\mid M \\text{ halts on all inputs} \\}$ and the halting problem $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ halts on } w \\}$, where $A_{TM}$ is known to be undecidable. Alice shows a mapping reduction $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$ and concludes that $\\text{TOTAL\\_TM}$ is undecidable.\n\nRecall the definition: For languages $A$ and $B$, $A \\le_{m} B$ means there exists a total computable function $f$ such that for all strings $x$, \n$$x \\in A \\iff f(x) \\in B.$$\n\nKey property of mapping reductions:\n- If $A \\le_{m} B$ and $B$ is decidable, then $A$ is decidable. Proof: Given a decider for $B$, decide $A$ on input $x$ by computing $f(x)$ and running the decider for $B$; accept iff it accepts. \n- The contrapositive of this statement is: If $A$ is undecidable and $A \\le_{m} B$, then $B$ is undecidable.\n\nTherefore, to prove that a target language $P$ is undecidable by reduction, one must reduce a known undecidable language $U$ to $P$, that is, show $U \\le_{m} P$. Then, if $P$ were decidable, $U$ would be decidable, contradicting the known undecidability of $U$.\n\nAlice instead showed $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$. From the fundamental property above, this implication only yields:\n$$\\text{If } A_{TM} \\text{ were decidable, then } \\text{TOTAL\\_TM} \\text{ would be decidable.}$$\nBut since $A_{TM}$ is undecidable, this conditional tells us nothing about the decidability of $\\text{TOTAL\\_TM}$. Hence Alice’s conclusion does not follow.\n\nA concrete illustration that such a reduction direction does not prove undecidability: Let $L$ be any decidable language. Let $D$ be its decider. Define a computable $f$ that, on input $x$, runs $D(x)$ and outputs a fixed pair $\\langle M_{halt}, w_{halt} \\rangle \\in A_{TM}$ if $D$ accepts, and a fixed pair $\\langle M_{loop}, w_{loop} \\rangle \\notin A_{TM}$ if $D$ rejects. Then $x \\in L \\iff f(x) \\in A_{TM}$, so $L \\le_{m} A_{TM}$, yet $L$ is decidable. Thus, showing $P \\le_{m} A_{TM}$ does not establish that $P$ is undecidable.\n\nTherefore, the fundamental flaw is the direction of the reduction. This corresponds to option A. The other options are incorrect because: mapping reductions do not require equal recognizability status (B is false), constructing $f$ does not assume a decider for $\\text{TOTAL\\_TM}$ (C is false), the “harder to easier” phrasing is not the formal criterion at play (D is misleading), and producing pairs from singles is standard via computable padding or hardcoding (E is false).", "answer": "$$\\boxed{A}$$", "id": "1457073"}, {"introduction": "Not all problems that resemble the Halting Problem are undecidable. The scope of a problem's definition—specifically, whether it applies to a finite or an infinite set of objects—is a crucial detail that can change its nature from undecidable to decidable. This exercise [@problem_id:1457046] explores this important distinction by contrasting the undecidable $HALT_{\\epsilon}$ with a version restricted to a finite set of Turing machines, clarifying why undecidability arises from the infinite domain of the general problem.", "problem": "In the theory of computation, a Turing Machine (TM) is a mathematical model of computation described by a set of states, a tape alphabet, and a transition function. The encoding of a Turing machine, denoted as $\\langle M \\rangle$, is a finite string that represents the machine $M$. The empty string is denoted by $\\epsilon$.\n\nA central problem in this field is the halting problem on the empty input, which corresponds to the language $HALT_{\\epsilon}$. This language is defined as:\n$$HALT_{\\epsilon} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM that halts on input } \\epsilon \\}$$\nIt is a well-established theorem that $HALT_{\\epsilon}$ is an undecidable language. This means no algorithm exists that can correctly determine for any arbitrary TM whether it halts on the empty input.\n\nNow, consider a different language, which we will call $L_{20}$. This language is defined for Turing machines that use a fixed tape alphabet $\\Gamma = \\{0, 1, \\text{blank}\\}$ and is given by:\n$$L_{20} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM with at most 20 states that halts on input } \\epsilon \\}$$\nIt is a fact that, unlike $HALT_{\\epsilon}$, the language $L_{20}$ is decidable. This may seem paradoxical, as $L_{20}$ appears to be a specific case of the halting problem.\n\nWhich of the following statements provides the most accurate and fundamental explanation for why $L_{20}$ is decidable, and why this fact does not contradict the undecidability of $HALT_{\\epsilon}$?\n\nA. A universal Turing machine can simulate any TM with at most 20 states until it halts. This simulation is only guaranteed to terminate for machines with a small, finite number of states.\n\nB. The undecidability of $HALT_{\\epsilon}$ is proven by a reduction from the general halting problem $A_{TM}$. This reduction technique is invalid if the target machines are restricted to have at most 20 states.\n\nC. Any TM with 20 or fewer states that does not halt on input $\\epsilon$ must enter a simple, repeating loop of configurations on the tape. A decider can detect this loop, a feat which is impossible for TMs with more states.\n\nD. The property \"halts on input $\\epsilon$\" is a non-trivial property of TMs. According to Rice's Theorem, this implies undecidability. However, Rice's Theorem has an exception for machines with a small number of states.\n\nE. The set of all distinct Turing machines with a fixed alphabet and a bounded number of states is finite. A decider can therefore be constructed with a hardcoded list of all such machines that are known to halt on $\\epsilon$. This approach is impossible for $HALT_{\\epsilon}$ because the set of all possible TMs is infinite.", "solution": "We are given $HALT_{\\epsilon}=\\{\\langle M\\rangle\\mid M\\text{ halts on }\\epsilon\\}$, which is undecidable, and $L_{20}=\\{\\langle M\\rangle\\mid M\\text{ uses }\\Gamma=\\{0,1,\\text{blank}\\}\\text{, has at most }20\\text{ states, and halts on }\\epsilon\\}$, which is decidable. We must explain why $L_{20}$ is decidable without contradicting the undecidability of $HALT_{\\epsilon}$.\n\nStep 1 (Finiteness of the set of machines with bounded states and fixed alphabet): Fix the tape alphabet $\\Gamma=\\{0,1,\\text{blank}\\}$ and a state set $Q$ with $1\\leq |Q|\\leq 20$. For a deterministic single-tape Turing machine, the transition function is a partial function $\\delta:Q\\times\\Gamma\\to\\Gamma\\times\\{L,R\\}\\times(Q\\cup\\{\\text{halt-accept},\\text{halt-reject}\\})$. For each pair $(q,a)\\in Q\\times\\Gamma$, the number of choices for $\\delta(q,a)$ is finite because:\n- the write symbol comes from the finite set $\\Gamma$,\n- the head move comes from the finite set $\\{L,R\\}$,\n- the next control is chosen from the finite set $Q\\cup\\{\\text{halt-accept},\\text{halt-reject}\\}$.\nHence, for fixed $Q$ and $\\Gamma$, the set of possible transition tables is a finite product of finite sets, therefore finite. Taking the union over all $|Q|\\leq 20$ still yields a finite set. Consequently, the set of all TMs with $\\Gamma=\\{0,1,\\text{blank}\\}$ and at most $20$ states is finite. If the encoding $\\langle\\cdot\\rangle$ is fixed and injective, the set of valid encodings of such machines is also finite.\n\nStep 2 (Decidability from finiteness): Let $S$ be the finite set of encodings of all TMs with $\\Gamma=\\{0,1,\\text{blank}\\}$ and at most $20$ states. Then $L_{20}\\subseteq S$ and $L_{20}$ itself is finite. Any finite language is decidable: a decider can be built that, on input $x$, first checks whether $x\\in S$ (reject if not), and if $x\\in S$, accepts if and only if $x$ is in the finite hardcoded subset $H\\subseteq S$ consisting of exactly those encodings that are known to halt on input $\\epsilon$. Equivalently, one can implement a finite lookup table for $H$.\n\nStep 3 (No contradiction with the undecidability of $HALT_{\\epsilon}$): The undecidability of $HALT_{\\epsilon}$ concerns an infinite domain of machines with unbounded numbers of states and transition possibilities. Restricting attention to a finite subset of machines (those with at most $20$ states over a fixed alphabet) yields a finite language, which is trivially decidable. Undecidability results such as those proved via reductions or Rice’s Theorem do not apply to a finite restriction of the input domain; there is no paradox.\n\nAssessment of the options:\n- A is false: simulation does not guarantee termination for non-halting machines, regardless of having at most $20$ states.\n- B is misleading: while standard reductions target unrestricted machines, this does not explain decidability; the core reason is finiteness.\n- C is false: a non-halting TM need not enter a simple repeating loop of configurations; it can write fresh tape symbols indefinitely without repeating a configuration.\n- D is false: Rice’s Theorem has no “small number of states” exception; rather, it does not apply to a finite restriction of the machine set.\n- E is correct: the set of such machines is finite, so one can decide by finite lookup, and this does not contradict the undecidability of $HALT_{\\epsilon}$ because the latter ranges over an infinite set.", "answer": "$$\\boxed{E}$$", "id": "1457046"}]}