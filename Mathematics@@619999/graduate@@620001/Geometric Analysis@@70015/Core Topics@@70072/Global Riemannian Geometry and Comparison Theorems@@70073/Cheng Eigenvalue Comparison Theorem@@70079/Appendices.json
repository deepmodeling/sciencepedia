{"hands_on_practices": [{"introduction": "The foundation of comparison geometry in Riemannian manifolds rests on understanding the geometry of model spaces with constant sectional curvature. This practice focuses on the essential radial functions, $s_k(r)$, which describe the radius of geodesic spheres in these model spaces. Calculating their derivatives and logarithmic derivatives is a crucial first step, as these quantities appear directly in the Laplacian Comparison Theorem and govern the behavior of volumes and distances [@problem_id:3026917]. Mastering these fundamental calculations provides the necessary toolkit for tackling more advanced problems in spectral geometry.", "problem": "Let $\\left(M^{n},g\\right)$ be a complete Riemannian manifold and recall that in the proof of Cheng's eigenvalue comparison theorem one compares radial objects on $\\left(M^{n},g\\right)$ with those on the simply connected space forms of constant sectional curvature $k \\in \\mathbb{R}$. For $r>0$, define the model radial function $s_{k}(r)$ by\n$$\ns_{k}(r)=\n\\begin{cases}\nr, & \\text{if } k=0,\\\\[6pt]\n\\frac{\\sin(\\sqrt{k}\\,r)}{\\sqrt{k}}, & \\text{if } k>0,\\\\[6pt]\n\\frac{\\sinh(\\sqrt{-k}\\,r)}{\\sqrt{-k}}, & \\text{if } k0.\n\\end{cases}\n$$\nSet $c_{k}(r)=s_{k}'(r)$ and consider the logarithmic derivative $\\dfrac{s_{k}'(r)}{s_{k}(r)}$. Starting only from the above definition and the elementary differentiation rules for the trigonometric and hyperbolic functions, compute closed-form expressions for $c_{k}(r)$ and for $\\dfrac{s_{k}'(r)}{s_{k}(r)}$ as functions of $k$ and $r$ that are valid in each of the cases $k=0$, $k>0$, and $k0$. You may assume $r>0$, and in the case $k>0$ assume $r \\in \\left(0,\\pi/\\sqrt{k}\\right)$ so that $s_{k}(r)\\neq 0$.\n\nProvide your final result by listing the two expressions in a single row matrix in the order $\\left(c_{k}(r),\\,\\dfrac{s_{k}'(r)}{s_{k}(r)}\\right)$. No numerical approximation is required.", "solution": "The problem requires the computation of the derivative $c_{k}(r) = s_{k}'(r)$ and the logarithmic derivative $\\frac{s_{k}'(r)}{s_{k}(r)}$ for the model radial function $s_{k}(r)$. The function $s_{k}(r)$ is defined piecewise based on the sign of the curvature parameter $k \\in \\mathbb{R}$. We will analyze each case separately using elementary rules of calculus.\n\nThe function $s_k(r)$ is given by:\n$$\ns_{k}(r)=\n\\begin{cases}\nr,  \\text{if } k=0,\\\\[6pt]\n\\frac{\\sin(\\sqrt{k}\\,r)}{\\sqrt{k}},  \\text{if } k>0,\\\\[6pt]\n\\frac{\\sinh(\\sqrt{-k}\\,r)}{\\sqrt{-k}},  \\text{if } k0.\n\\end{cases}\n$$\nThe problem specifies the domain $r>0$. For the case $k>0$, we are given the additional constraint $r \\in (0, \\pi/\\sqrt{k})$. For the case $k0$, with $r0$, we have $\\sqrt{-k}r > 0$. For the case $k=0$, with $r0$, $s_0(r)$ is non-zero. These conditions ensure that $s_k(r) \\neq 0$ for all cases under consideration, which is necessary for the logarithmic derivative to be well-defined.\n\nWe proceed by differentiating $s_k(r)$ with respect to $r$ in each of the three cases.\n\nCase 1: $k > 0$\nFor $k>0$, the function is $s_{k}(r) = \\frac{\\sin(\\sqrt{k}\\,r)}{\\sqrt{k}}$.\nTo find $c_{k}(r) = s_{k}'(r)$, we differentiate with respect to $r$. Using the chain rule, where $\\frac{d}{dr}(\\sin(u)) = \\cos(u) \\frac{du}{dr}$, with $u = \\sqrt{k}r$, so $\\frac{du}{dr} = \\sqrt{k}$:\n$$\nc_{k}(r) = s_{k}'(r) = \\frac{d}{dr}\\left(\\frac{\\sin(\\sqrt{k}\\,r)}{\\sqrt{k}}\\right) = \\frac{1}{\\sqrt{k}} \\cdot \\cos(\\sqrt{k}\\,r) \\cdot \\frac{d}{dr}(\\sqrt{k}\\,r) = \\frac{1}{\\sqrt{k}} \\cos(\\sqrt{k}\\,r) \\cdot \\sqrt{k} = \\cos(\\sqrt{k}\\,r).\n$$\nThe logarithmic derivative is the ratio of $s_{k}'(r)$ to $s_{k}(r)$:\n$$\n\\frac{s_{k}'(r)}{s_{k}(r)} = \\frac{\\cos(\\sqrt{k}\\,r)}{\\frac{\\sin(\\sqrt{k}\\,r)}{\\sqrt{k}}} = \\sqrt{k} \\frac{\\cos(\\sqrt{k}\\,r)}{\\sin(\\sqrt{k}\\,r)} = \\sqrt{k}\\cot(\\sqrt{k}\\,r).\n$$\n\nCase 2: $k  0$\nFor $k0$, we have $-k0$. The function is $s_{k}(r) = \\frac{\\sinh(\\sqrt{-k}\\,r)}{\\sqrt{-k}}$.\nTo find $c_{k}(r) = s_{k}'(r)$, we differentiate with respect to $r$. Using the chain rule, where $\\frac{d}{dr}(\\sinh(u)) = \\cosh(u) \\frac{du}{dr}$, with $u = \\sqrt{-k}r$, so $\\frac{du}{dr} = \\sqrt{-k}$:\n$$\nc_{k}(r) = s_{k}'(r) = \\frac{d}{dr}\\left(\\frac{\\sinh(\\sqrt{-k}\\,r)}{\\sqrt{-k}}\\right) = \\frac{1}{\\sqrt{-k}} \\cdot \\cosh(\\sqrt{-k}\\,r) \\cdot \\frac{d}{dr}(\\sqrt{-k}\\,r) = \\frac{1}{\\sqrt{-k}} \\cosh(\\sqrt{-k}\\,r) \\cdot \\sqrt{-k} = \\cosh(\\sqrt{-k}\\,r).\n$$\nThe logarithmic derivative is the ratio of $s_{k}'(r)$ to $s_{k}(r)$:\n$$\n\\frac{s_{k}'(r)}{s_{k}(r)} = \\frac{\\cosh(\\sqrt{-k}\\,r)}{\\frac{\\sinh(\\sqrt{-k}\\,r)}{\\sqrt{-k}}} = \\sqrt{-k} \\frac{\\cosh(\\sqrt{-k}\\,r)}{\\sinh(\\sqrt{-k}\\,r)} = \\sqrt{-k}\\coth(\\sqrt{-k}\\,r).\n$$\n\nCase 3: $k = 0$\nFor $k=0$, the function simplifies to $s_{0}(r) = r$.\nThe derivative is straightforward:\n$$\nc_{0}(r) = s_{0}'(r) = \\frac{d}{dr}(r) = 1.\n$$\nThe logarithmic derivative is:\n$$\n\\frac{s_{0}'(r)}{s_{0}(r)} = \\frac{1}{r}.\n$$\n\nCombining these results, we can write the closed-form expressions for $c_k(r)$ and $\\frac{s_k'(r)}{s_k(r)}$ as piecewise functions of $k$ and $r$.\n\nThe expression for $c_k(r) = s_k'(r)$ is:\n$$\nc_k(r) =\n\\begin{cases}\n1,  \\text{if } k=0, \\\\\n\\cos(\\sqrt{k}\\,r),  \\text{if } k>0, \\\\\n\\cosh(\\sqrt{-k}\\,r),  \\text{if } k0.\n\\end{cases}\n$$\n\nThe expression for the logarithmic derivative $\\frac{s_k'(r)}{s_k(r)}$ is:\n$$\n\\frac{s_k'(r)}{s_k(r)} =\n\\begin{cases}\n\\frac{1}{r},  \\text{if } k=0, \\\\\n\\sqrt{k}\\cot(\\sqrt{k}\\,r),  \\text{if } k>0, \\\\\n\\sqrt{-k}\\coth(\\sqrt{-k}\\,r),  \\text{if } k0.\n\\end{cases}\n$$\nThese expressions provide the required closed forms for the specified quantities in all three cases for the curvature parameter $k$.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\begin{cases} 1,  k=0 \\\\ \\cos(\\sqrt{k} r),  k0 \\\\ \\cosh(\\sqrt{-k} r),  k0 \\end{cases}  \\begin{cases} \\frac{1}{r},  k=0 \\\\ \\sqrt{k}\\cot(\\sqrt{k}r),  k0 \\\\ \\sqrt{-k}\\coth(\\sqrt{-k}r),  k0 \\end{cases} \\end{pmatrix}}\n$$", "id": "3026917"}, {"introduction": "Cheng's Eigenvalue Comparison Theorem provides a powerful link between geometry (curvature) and analysis (the spectrum of the Laplacian). This exercise grounds the abstract theorem in its most fundamental setting: the Euclidean space, which serves as the model for manifolds with non-negative Ricci curvature. By explicitly solving the eigenvalue problem on a Euclidean ball, you will derive a classic result involving Bessel functions [@problem_id:3026907]. This hands-on calculation not only yields a concrete formula but also demonstrates why the comparison theorem becomes a sharp equality for the model space itself, offering deep insight into its structure.", "problem": "Let $n \\ge 2$ be an integer and let $B_{\\mathbb{R}^{n}}(R) \\subset \\mathbb{R}^{n}$ denote the geodesic ball of radius $R0$ centered at the origin with the standard Euclidean metric. Consider the Dirichlet eigenvalue problem for the Laplace–Beltrami operator $\\Delta$,\n$$\n\\begin{cases}\n\\Delta u + \\lambda u = 0  \\text{in } B_{\\mathbb{R}^{n}}(R),\\\\\nu = 0  \\text{on } \\partial B_{\\mathbb{R}^{n}}(R),\n\\end{cases}\n$$\nand let $\\lambda_{1}(B_{\\mathbb{R}^{n}}(R))$ denote its smallest (first) eigenvalue. \n\nStarting only from the definitions of the Laplace–Beltrami operator in Euclidean polar coordinates and the Dirichlet boundary condition, derive a closed-form expression for $\\lambda_{1}(B_{\\mathbb{R}^{n}}(R))$ in terms of the first positive zero of the Bessel function of the first kind of order $\\nu = \\frac{n}{2}-1$. Denote this zero by $j_{\\nu,1}$. Your expression should be exact and simplify all scaling with respect to $R$. \n\nThen, using only the foundational principle that a lower bound on Ricci curvature controls comparison geometry for geodesic balls, explain why in the setting of a Riemannian manifold with nonnegative Ricci curvature (i.e., $\\mathrm{Ric} \\ge 0$, corresponding to $k=0$ in the constant curvature model), the abstract eigenvalue comparison statement specialized to $k=0$ reduces to the identity when the manifold is the Euclidean model space itself. Conclude by giving the exact analytic expression you obtained for $\\lambda_{1}(B_{\\mathbb{R}^{n}}(R))$.\n\nYour final answer must be a single closed-form analytic expression. No numerical rounding is required.", "solution": "The problem consists of two main parts. First, we must derive the first Dirichlet eigenvalue for the Laplacian on a Euclidean ball. Second, we must explain the context of this result in relation to Cheng's eigenvalue comparison theorem.\n\nPart 1: Derivation of the First Dirichlet Eigenvalue\n\nWe are asked to find the smallest eigenvalue $\\lambda_1$ for the problem\n$$\n\\begin{cases}\n\\Delta u + \\lambda u = 0  \\text{in } B_{\\mathbb{R}^{n}}(R),\\\\\nu = 0  \\text{on } \\partial B_{\\mathbb{R}^{n}}(R).\n\\end{cases}\n$$\nThe domain $B_{\\mathbb{R}^{n}}(R)$ is a ball of radius $R$ in $n$-dimensional Euclidean space, which is radially symmetric. It is a classical result that the first eigenfunction $u_1$ of the Dirichlet Laplacian on a ball is radially symmetric. Therefore, we seek solutions of the form $u(x) = f(r)$, where $r = |x| = \\sqrt{x_1^2 + \\dots + x_n^2}$ is the radial coordinate.\n\nIn $n$-dimensional Euclidean polar coordinates $(r, \\theta_1, \\dots, \\theta_{n-1})$, the Laplace–Beltrami operator is given by\n$$\n\\Delta = \\frac{\\partial^2}{\\partial r^2} + \\frac{n-1}{r}\\frac{\\partial}{\\partial r} + \\frac{1}{r^2}\\Delta_{S^{n-1}},\n$$\nwhere $\\Delta_{S^{n-1}}$ is the Laplace–Beltrami operator on the unit $(n-1)$-sphere. For a radial function $u(x) = f(r)$, the angular part vanishes, i.e., $\\Delta_{S^{n-1}}f(r) = 0$. The eigenvalue equation $\\Delta u + \\lambda u = 0$ thus reduces to an ordinary differential equation (ODE) for the radial part $f(r)$:\n$$\nf''(r) + \\frac{n-1}{r} f'(r) + \\lambda f(r) = 0.\n$$\nThe boundary conditions are:\n1. $f(R) = 0$, from the Dirichlet condition $u=0$ on $\\partial B_{\\mathbb{R}^{n}}(R)$.\n2. The solution must be regular at the origin $r=0$. For a smooth radial function, this implies $f'(0) = 0$.\n\nThis ODE is a form of Bessel's differential equation. To transform it into the standard form, we perform a change of variables. Let $s = \\sqrt{\\lambda}r$. Then $r = s/\\sqrt{\\lambda}$ and $\\frac{d}{dr} = \\sqrt{\\lambda}\\frac{d}{ds}$. Letting $F(s) = f(r)$, we have $f'(r) = \\sqrt{\\lambda}F'(s)$ and $f''(r) = \\lambda F''(s)$. Substituting these into the ODE gives:\n$$\n\\lambda F''(s) + \\frac{n-1}{s/\\sqrt{\\lambda}} (\\sqrt{\\lambda}F'(s)) + \\lambda F(s) = 0.\n$$\nA standard substitution to solve this equation is $f(r) = r^{-\\nu} g(r)$ with $\\nu = \\frac{n}{2}-1$. This transforms the ODE into the standard Bessel's differential equation:\n$$\nr^2 g''(r) + r g'(r) + (\\lambda r^2 - \\nu^2)g(r) = 0.\n$$\nThis is Bessel's differential equation with parameter $\\nu = \\frac{n}{2}-1$. The general solution is\n$$\ng(r) = C_1 J_{\\nu}(\\sqrt{\\lambda}r) + C_2 Y_{\\nu}(\\sqrt{\\lambda}r),\n$$\nwhere $J_{\\nu}$ and $Y_{\\nu}$ are the Bessel functions of the first and second kind, respectively.\nThe solution for $f(r)$ is then\n$$\nf(r) = r^{-\\nu} \\left( C_1 J_{\\nu}(\\sqrt{\\lambda}r) + C_2 Y_{\\nu}(\\sqrt{\\lambda}r) \\right).\n$$\nThe function $u$ must be regular at $r=0$. As $z \\to 0$, $Y_{\\nu}(z)$ is unbounded. Since $\\nu = \\frac{n}{2}-1 \\ge 0$ for $n \\ge 2$, the term containing $Y_\\nu$ would cause $f(r)$ to be singular at the origin. Thus, we must have $C_2=0$. The physically acceptable solution is\n$$\nf(r) = C_1 r^{-\\nu} J_{\\nu}(\\sqrt{\\lambda}r).\n$$\nApplying the Dirichlet boundary condition $f(R)=0$:\n$$\nC_1 R^{-\\nu} J_{\\nu}(\\sqrt{\\lambda}R) = 0.\n$$\nFor a non-trivial solution ($C_1 \\ne 0$), this requires $J_{\\nu}(\\sqrt{\\lambda}R) = 0$. The smallest eigenvalue $\\lambda_1$ corresponds to the first positive zero of the Bessel function $J_\\nu(z)$. Let this zero be denoted by $j_{\\nu,1}$. Then we must have:\n$$\n\\sqrt{\\lambda_1}R = j_{\\nu,1}.\n$$\nSolving for $\\lambda_1$ and substituting $\\nu = \\frac{n}{2}-1$:\n$$\n\\lambda_1(B_{\\mathbb{R}^n}(R)) = \\left(\\frac{j_{\\nu,1}}{R}\\right)^2 = \\frac{j_{\\frac{n}{2}-1, 1}^2}{R^2}.\n$$\n\nPart 2: Relation to Cheng's Eigenvalue Comparison Theorem\n\nCheng's eigenvalue comparison theorem provides an inequality for the first Dirichlet eigenvalue $\\lambda_1$ on a geodesic ball in a Riemannian manifold by comparing it to a ball of the same radius in a space of constant sectional curvature.\n\nThe theorem states: Let $(M, g)$ be a complete $n$-dimensional Riemannian manifold with Ricci curvature bounded below by $\\mathrm{Ric}_M \\ge (n-1)kg$ for some constant $k$. Let $B_p(R) \\subset M$ be a geodesic ball of radius $R$. Let $M_k^n$ denote the $n$-dimensional simply connected space of constant sectional curvature $k$, and let $B_k(R)$ be a geodesic ball of radius $R$ in $M_k^n$. Then,\n$$\n\\lambda_1(B_p(R)) \\le \\lambda_1(B_k(R)).\n$$\nThe problem asks us to consider the case of a manifold with nonnegative Ricci curvature, which means $\\mathrm{Ric}_M \\ge 0$. This corresponds to setting the comparison curvature constant $k=0$. The model space $M_0^n$ is the $n$-dimensional Euclidean space $\\mathbb{R}^n$. The comparison theorem, specialized to $k=0$, reads:\nIf $\\mathrm{Ric}_M \\ge 0$, then $\\lambda_1(B_p(R)) \\le \\lambda_1(B_{\\mathbb{R}^n}(R))$.\n\nThe problem then asks us to consider the specific case where the manifold $(M,g)$ is the Euclidean space $(\\mathbb{R}^n, g_{\\text{eucl}})$ itself. The Ricci curvature of Euclidean space is identically zero, so the condition $\\mathrm{Ric}_{\\mathbb{R}^n} \\ge 0$ is satisfied. In this case, the geodesic ball $B_p(R)$ on the left-hand side of the comparison inequality is a geodesic ball in $\\mathbb{R}^n$, i.e., $B_p(R) = B_{\\mathbb{R}^n}(R)$.\n\nSubstituting this into the inequality, we get:\n$$\n\\lambda_1(B_{\\mathbb{R}^n}(R)) \\le \\lambda_1(B_{\\mathbb{R}^n}(R)).\n$$\nThis inequality is trivially true. Since any quantity is equal to itself, this inequality holds as an equality. This is what is meant by the statement \"reduces to the identity\". The comparison theorem is comparing the Euclidean ball with itself, and correctly predicts that the eigenvalue of the ball is less than or equal to its own eigenvalue, which can only be true if they are equal. The foundational principle is that a lower Ricci curvature bound constrains the geometry, with the model space representing the \"limit\" or \"boundary\" case for that constraint. When the manifold being studied is the model space itself, it naturally satisfies the equality condition of the comparison theorem.\n\nThus, the abstract theorem, when applied to the model space on which it is based, simply makes a self-referential statement of equality.\n\nConclusion: Analytic Expression for the Eigenvalue\n\nAs derived in the first part, the exact analytic expression for the first Dirichlet eigenvalue on the Euclidean ball $B_{\\mathbb{R}^n}(R)$ is given by the square of the first positive zero of the Bessel function of the first kind of order $\\nu = \\frac{n}{2}-1$, scaled by the inverse square of the radius $R$.", "answer": "$$\\boxed{\\frac{j_{\\frac{n}{2}-1, 1}^2}{R^2}}$$", "id": "3026907"}, {"introduction": "While analytical proofs provide certainty, numerical experiments offer invaluable intuition and a tangible connection to theoretical results. This practice challenges you to verify the core prediction of comparison theory by computing the first eigenvalues for geodesic balls in spherical ($k=1$), Euclidean ($k=0$), and hyperbolic ($k=-1$) spaces. By implementing a numerical solver for the underlying radial ODEs, you will directly observe how an increase in curvature leads to a decrease in the first eigenvalue [@problem_id:3026913]. This exercise bridges the gap between abstract theorems and computational reality, solidifying your understanding of how geometry shapes the spectrum.", "problem": "Design and implement a program that numerically computes and compares the first Dirichlet eigenvalues of the Laplace–Beltrami operator on geodesic balls in the $n$-dimensional simply connected constant sectional curvature model spaces $M_k^n$ for $k \\in \\{-1,0,1\\}$ at a fixed radius $R$. The goal is to verify, by direct numerical computation, the ordering predicted by the Laplacian comparison and Cheng's eigenvalue comparison theorem for these model spaces, and to connect the observed ordering to the comparison of the radial coefficients.\n\nFundamental base and setup. In geodesic polar coordinates centered at the ball center, the Laplace–Beltrami operator on $M_k^n$ acting on a radial function $u(r)$ can be written in divergence form as\n$$\n\\Delta u(r) = \\frac{1}{S_k(r)^{n-1}} \\frac{d}{dr}\\left(S_k(r)^{n-1}\\frac{du}{dr}\\right),\n$$\nwhere $S_k(r)$ is defined by\n$$\nS_k(r) = \\begin{cases}\n\\frac{1}{\\sqrt{k}} \\sin(\\sqrt{k}\\,r)  \\text{if } k>0,\\\\[6pt]\nr  \\text{if } k=0,\\\\[6pt]\n\\frac{1}{\\sqrt{-k}} \\sinh(\\sqrt{-k}\\,r)  \\text{if } k0.\n\\end{cases}\n$$\nThe first Dirichlet eigenvalue $\\lambda_1(B_{M_k^n}(R))$ is the smallest real number $\\lambda0$ for which there exists a nontrivial radial solution $u(r)$ of the ordinary differential equation (ODE) eigenvalue problem\n$$\n-\\Delta u(r) = \\lambda u(r), \\quad r\\in(0,R),\n$$\nwith boundary conditions\n$$\nu'(0)=0 \\quad \\text{(regularity at the center)}, \\qquad u(R)=0 \\quad \\text{(Dirichlet condition at the boundary)}.\n$$\nEquivalently, $u$ satisfies the Sturm–Liouville equation\n$$\n\\frac{d}{dr}\\left(S_k(r)^{n-1}\\frac{du}{dr}\\right) + \\lambda S_k(r)^{n-1} u(r) = 0,\n$$\nsubject to $u'(0)=0$ and $u(R)=0$. For numerical purposes, use the local Taylor expansion consistent with regularity to initialize the solution at a small $r=\\varepsilon$:\n$$\nu(\\varepsilon) \\approx 1 - \\frac{\\lambda}{2n}\\,\\varepsilon^2, \\qquad u'(\\varepsilon) \\approx -\\frac{\\lambda}{n}\\,\\varepsilon,\n$$\nwhich follows from substituting a quadratic ansatz into the divergence form and matching the leading order terms as $r\\to 0$.\n\nTask. For each specified test case $(n,R)$, do the following:\n- For each $k\\in\\{-1,0,1\\}$, numerically compute $\\lambda_1(B_{M_k^n}(R))$ by solving the above boundary value problem via a shooting method: integrate the initial value problem from $r=\\varepsilon$ up to $r=R$ for a trial $\\lambda$ and adjust $\\lambda$ so that $u(R)=0$. Use a robust bracketing and bisection strategy to isolate the smallest positive root in $\\lambda$.\n- Using the three computed eigenvalues for $k=-1,0,1$, evaluate the strict ordering statement\n$$\n\\lambda_1(B_{M_{-1}^n}(R)) > \\lambda_1(B_{M_{0}^n}(R)) > \\lambda_1(B_{M_{1}^n}(R)),\n$$\nup to a numerical tolerance, and record a Boolean value indicating whether the ordering holds.\n\nScientific realism notes. You must ensure $R\\in(0,\\pi)$ for $k=1$ so that the model ball is well-defined and $S_1(r)0$ on $[0,R]$. No physical units are involved.\n\nTest suite. Your program must evaluate the following four test cases, which together probe small radius, moderate radius, and higher dimension behavior:\n- $(n,R) = (2,\\,0.5)$,\n- $(n,R) = (2,\\,1.0)$,\n- $(n,R) = (5,\\,1.0)$,\n- $(n,R) = (5,\\,1.5)$.\n\nAnswer specification and final output format. For each test case, output a Boolean indicating whether the numerically computed eigenvalues satisfy the strict ordering stated above, using a fixed absolute tolerance of $10^{-5}$ when comparing real numbers. Aggregate the four Booleans into a single line containing a comma-separated list enclosed in square brackets, for example: \"[True,False,True,True]\". Your program must produce exactly one line of output in this format and must not read any input from the user or files.\n\nYour implementation must be a complete, runnable program.", "solution": "### Principle-Based Solution Design\n\nThe core task is to find the smallest positive value $\\lambda$ that solves the eigenvalue problem for the Laplace-Beltrami operator on a geodesic ball of radius $R$. For a radial eigenfunction $u(r)$, the problem reduces to the following ordinary differential equation (ODE) on the interval $r \\in (0, R)$:\n$$\n-\\Delta u(r) = -\\frac{1}{S_k(r)^{n-1}} \\frac{d}{dr}\\!\\left(S_k(r)^{n-1}\\,\\frac{du}{dr}\\right) = \\lambda u(r)\n$$\nwith boundary conditions $u'(0)=0$ (regularity) and $u(R)=0$ (Dirichlet). This is a Sturm-Liouville eigenvalue problem.\n\n**1. Conversion to a First-Order System**\n\nNumerical ODE solvers typically operate on systems of first-order equations. We expand the derivative and rearrange the equation:\n$$\n\\frac{d}{dr}\\!\\left(S_k(r)^{n-1}\\,\\frac{du}{dr}\\right) = (n-1)S_k(r)^{n-2}S_k'(r)\\frac{du}{dr} + S_k(r)^{n-1}\\frac{d^2u}{dr^2} = -\\lambda S_k(r)^{n-1} u(r)\n$$\nDividing by $S_k(r)^{n-1}$ (which is non-zero for $r \\in (0,R)$) yields:\n$$\n\\frac{d^2u}{dr^2} + (n-1)\\frac{S_k'(r)}{S_k(r)}\\frac{du}{dr} + \\lambda u(r) = 0\n$$\nLet $y_0(r) = u(r)$ and $y_1(r) = u'(r)$. The second-order ODE is equivalent to the first-order system:\n$$\n\\frac{d}{dr} \\begin{pmatrix} y_0 \\\\ y_1 \\end{pmatrix} = \\begin{pmatrix} y_1 \\\\ -(n-1)\\frac{S_k'(r)}{S_k(r)} y_1 - \\lambda y_0 \\end{pmatrix}\n$$\nThe coefficient $\\frac{S_k'(r)}{S_k(r)}$ depends on the curvature $k$:\n- For $k=1$ (sphere): $S_1(r) = \\sin(r)$, so $\\frac{S_1'(r)}{S_1(r)} = \\cot(r)$.\n- For $k=0$ (Euclidean space): $S_0(r) = r$, so $\\frac{S_0'(r)}{S_0(r)} = \\frac{1}{r}$.\n- For $k=-1$ (hyperbolic space): $S_{-1}(r) = \\sinh(r)$, so $\\frac{S_{-1}'(r)}{S_{-1}(r)} = \\coth(r)$.\n\nThe ordering of eigenvalues is directly linked to the comparison of these radial coefficients. For $r \\in (0, \\pi)$, it is a known inequality that $\\coth(r)  \\frac{1}{r}  \\cot(r)$. The term $-(n-1)\\frac{S_k'(r)}{S_k(r)} y_1$ acts as a damping term in the oscillator equation for $u$. Stronger damping (more negative coefficient for a given positive $y_1$) forces the solution to curve down more rapidly, leading to a zero at a smaller $r$ for a fixed $\\lambda$, or equivalently, requiring a higher frequency (larger $\\lambda$) to have the first zero at a fixed $R$. Since the damping coefficient's magnitude follows the order $k=-1  k=0  k=1$, this provides a heuristic justification for the expected eigenvalue ordering $\\lambda_1(-1)  \\lambda_1(0)  \\lambda_1(1)$.\n\n**2. The Shooting Method**\n\nThe boundary value problem (BVP) is solved using a shooting method. Instead of directly solving the BVP, we solve an initial value problem (IVP) for a trial value of $\\lambda$ and then adjust $\\lambda$ until the boundary condition at $r=R$ is met.\n\n- **Objective Function:** We define a function $F(\\lambda) = u(R; \\lambda)$, which is the value of the solution at $r=R$ obtained by solving the IVP with the given $\\lambda$. The eigenvalues are the roots of the equation $F(\\lambda)=0$.\n\n- **Initial Conditions:** The term $\\frac{S_k'(r)}{S_k(r)}$ is singular at $r=0$. We therefore start the numerical integration at a small positive radius $r=\\varepsilon$. The required initial values $u(\\varepsilon)$ and $u'(\\varepsilon)$ are derived from a Taylor series expansion of the solution around the regular point $r=0$, consistent with $u'(0)=0$. As specified, normalizing with $u(0)=1$, we get:\n$$\nu(\\varepsilon) \\approx 1 - \\frac{\\lambda}{2n}\\,\\varepsilon^2, \\qquad u'(\\varepsilon) \\approx -\\frac{\\lambda}{n}\\,\\varepsilon\n$$\n\n- **Root Finding:** To find the smallest positive root $\\lambda_1$, we use a bisection algorithm. This requires finding a bracket $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$ such that $F(\\lambda_{\\text{low}})$ and $F(\\lambda_{\\text{high}})$ have opposite signs. The first eigenfunction is positive on $(0, R)$. Thus, for any $\\lambda  \\lambda_1$, the corresponding solution $u(r; \\lambda)$ will remain positive, so $F(\\lambda)  0$. At $\\lambda=\\lambda_1$, $F(\\lambda_1)=0$. For $\\lambda$ slightly greater than $\\lambda_1$, the solution will cross the axis before $R$, so $F(\\lambda)  0$. We can therefore start with a small $\\lambda_{\\text{low}}  0$ (which should yield $F(\\lambda_{\\text{low}})  0$) and progressively increase a test value $\\lambda_{\\text{high}}$ until $F(\\lambda_{\\text{high}})  0$, which establishes the desired bracket.\n\n**3. Implementation**\n\nThe overall algorithm for each test case $(n, R)$ is:\n1.  Initialize an empty list to store computed eigenvalues for the current test case.\n2.  Iterate through $k \\in \\{-1, 0, 1\\}$.\n3.  For each $k$, use a bisection solver (e.g., `scipy.optimize.root_scalar`) combined with an IVP solver (e.g., `scipy.integrate.solve_ivp`) to find the smallest positive root $\\lambda_1$ of the objective function $F(\\lambda)$.\n4.  Store the computed eigenvalue $\\lambda_1(B_{M_k^n}(R))$.\n5.  After computing the three eigenvalues, verify if the strict inequality $\\lambda_1(k=-1)  \\lambda_1(k=0)  \\lambda_1(k=1)$ holds, subject to a numerical tolerance of $10^{-5}$.\n6.  Record the Boolean result for the test case.\n7.  After processing all test cases, format the list of Booleans into the required output string.\n\nThis systematic approach translates the geometric problem into a well-defined numerical task that can be implemented reliably using standard scientific computing libraries.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Main function to compute and compare eigenvalues for the specified test cases.\n    \"\"\"\n    test_cases = [\n        (2, 0.5),\n        (2, 1.0),\n        (5, 1.0),\n        (5, 1.5),\n    ]\n\n    # Numerical parameters\n    EPSILON = 1e-8  # Small radius to start integration, avoiding singularity at r=0.\n    TOLERANCE = 1e-5 # Tolerance for eigenvalue comparison.\n    \n    # ODE solver options for high accuracy\n    IVP_TOL = 1e-12 \n\n    # Bisection solver options for high accuracy\n    ROOT_TOL = 1e-12\n\n    results = []\n    for n, R in test_cases:\n        eigenvalues = {}\n        for k in [-1, 0, 1]:\n            # The ODE system dy/dr = f(r, y, ...)\n            # y[0] = u(r), y[1] = u'(r)\n            def ode_system(r, y, lambda_val):\n                y0, y1 = y\n                \n                # Coefficient (n-1) * S_k'(r) / S_k(r)\n                if k == 1:\n                    # S_1'(r)/S_1(r) = cot(r)\n                    coeff = (n - 1) / np.tan(r)\n                elif k == 0:\n                    # S_0'(r)/S_0(r) = 1/r\n                    coeff = (n - 1) / r\n                else: # k == -1\n                    # S_{-1}'(r)/S_{-1}(r) = coth(r)\n                    coeff = (n - 1) / np.tanh(r)\n                \n                dy0_dr = y1\n                dy1_dr = -coeff * y1 - lambda_val * y0\n                return [dy0_dr, dy1_dr]\n\n            # Objective function for the shooting method: u(R) for a given lambda\n            def objective_u_at_R(lambda_val):\n                if lambda_val = 0:\n                    return np.inf\n\n                # Initial conditions at r = epsilon\n                u_eps = 1.0 - (lambda_val / (2.0 * n)) * EPSILON**2\n                du_eps = -(lambda_val / n) * EPSILON\n                y_initial = [u_eps, du_eps]\n\n                # Solve the IVP from epsilon to R\n                sol = solve_ivp(\n                    fun=lambda r, y: ode_system(r, y, lambda_val),\n                    t_span=[EPSILON, R],\n                    y0=y_initial,\n                    dense_output=True,\n                    rtol=IVP_TOL,\n                    atol=IVP_TOL\n                )\n                \n                # Return the value u(R) at the end of the interval\n                return sol.y[0, -1]\n\n            # Find a bracket [lam_low, lam_high] for the first eigenvalue\n            # For lam  lam_1, u(R)  0. For lam  lam_1, u(R)  0.\n            lam_low = 0.1\n            lam_high = 1.0\n\n            # Ensure lam_low gives a positive result\n            if objective_u_at_R(lam_low) = 0:\n                # This should not happen for a reasonably small lam_low\n                raise RuntimeError(\"Failed to find a valid low bracket lambda.\")\n\n            # Exponentially search for lam_high that gives a negative result\n            while objective_u_at_R(lam_high)  0:\n                lam_high *= 2.0\n                if lam_high  1e6: # Safety break\n                     raise RuntimeError(\"Failed to find a valid high bracket lambda.\")\n\n            # Find the root (eigenvalue) using bisection\n            sol = root_scalar(\n                f=objective_u_at_R,\n                bracket=[lam_low, lam_high],\n                method='bisect',\n                xtol=ROOT_TOL\n            )\n            \n            eigenvalues[k] = sol.root\n\n        # Verify the ordering predicted by Cheng's theorem\n        lam_m1 = eigenvalues[-1]\n        lam_0 = eigenvalues[0]\n        lam_1 = eigenvalues[1]\n        \n        ordering_holds = (lam_m1 > lam_0 + TOLERANCE) and (lam_0 > lam_1 + TOLERANCE)\n        results.append(str(ordering_holds))\n\n    # Print the final list of booleans\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3026913"}]}