{"hands_on_practices": [{"introduction": "Understanding primitive recursive functions begins with appreciating how they are built from a minimal set of initial functions and operations. This exercise guides you through the process of constructing fundamental arithmetic functions, such as maximum and minimum, using only the basic tools of primitive recursion [@problem_id:2979433]. By building these functions from the ground up, you will gain a deeper intuition for the constructive nature of this important class of computable functions.", "problem": "Work in the standard natural numbers $\\,\\mathbb{N}=\\{0,1,2,\\dots\\}\\,$ with the class of primitive recursive (PR) functions generated from the initial functions and closed under composition and primitive recursion. The initial functions are the zero function $Z(x)=0$, the successor function $S(x)=x+1$, and the projection functions $P_{i}^{n}(x_{1},\\dots,x_{n})=x_{i}$. The closure properties are: if $g$ and $h$ are PR, then any composition of PR functions is PR; if $g$ and $h$ are PR, then the function $f$ defined by primitive recursion by\n$$\nf(\\vec{x},0)=g(\\vec{x}),\\qquad f(\\vec{x},S(y))=h(\\vec{x},y,f(\\vec{x},y))\n$$\nis PR. The class of PR functions is a subclass of the class of $\\mu$-recursive (minimization) functions; here you must avoid the minimization (denoted by $\\mu$) operator and use only the PR schema.\n\nDefine the predecessor function $\\mathrm{pred}(x)$ and the truncated subtraction $x\\dot{-}y$ using only the initial functions and the primitive recursion schema. Then, using only $x\\dot{-}y$, define $\\max(x,y)$ and $\\min(x,y)$ and prove from first principles (using only the PR closure properties, case analyses on the order relation, and basic arithmetic in $\\mathbb{N}$) that both $\\max$ and $\\min$ are PR. Finally, establish the usual algebraic laws for $\\max$ and $\\min$ on $\\mathbb{N}$: commutativity, idempotence, associativity, absorption, monotonicity, and the decomposition identity\n$$\n\\max(x,y)+\\min(x,y)=x+y.\n$$\nYour final answer must be the closed-form analytic expressions you obtain for $\\max(x,y)$ and $\\min(x,y)$ written only in terms of $x$, $y$, addition, and $\\,\\dot{-}\\,$. No rounding is required.", "solution": "The problem requires the construction of the predecessor, truncated subtraction, maximum, and minimum functions within the framework of primitive recursive (PR) functions, followed by a proof of their algebraic properties. All constructions must be justified from first principles using only the initial functions and the schemas of composition and primitive recursion.\n\nFirst, we establish that the addition function, $A(x,y) = x+y$, is primitive recursive. It can be defined by recursion on $y$ as follows:\n$$\nA(x,0) = x\n$$\n$$\nA(x, S(y)) = S(A(x,y))\n$$\nThis fits the primitive recursion schema $f(\\vec{x}, 0) = g(\\vec{x})$ and $f(\\vec{x}, S(y)) = h(\\vec{x}, y, f(\\vec{x}, y))$ with $\\vec{x}$ being the single variable $x$. We identify $g(x) = P_1^1(x)$ and $h(x, y, z) = S(P_3^3(x,y,z))$. Since $P_1^1$, $P_3^3$, and $S$ are initial functions, and the definition uses composition and primitive recursion, $A(x,y)$ is a PR function.\n\nWe now proceed with the tasks as outlined in the problem.\n\nStep 1: The Predecessor Function, $\\mathrm{pred}(x)$\nThe predecessor function is defined as $\\mathrm{pred}(x) = x-1$ for $x > 0$ and $\\mathrm{pred}(0) = 0$. We define it using the schema for primitive recursion on a single variable $x$:\n$$\n\\mathrm{pred}(0) = 0\n$$\n$$\n\\mathrm{pred}(S(x)) = x\n$$\nThis definition corresponds to the unary primitive recursion schema $f(0) = c$ and $f(S(x)) = h(x, f(x))$.\nThe base case is a constant, which can be represented by the zero function $Z(x)$. So, we set the base value to be $0$.\nThe recursive step can be written as $h(x, \\mathrm{pred}(x)) = x$. The function $h(u,v) = P_1^2(u,v) = u$ satisfies this.\nSince the base value is derived from an initial function ($Z$) and the recursive step's function $h$ is an initial function ($P_1^2$), the function $\\mathrm{pred}(x)$ is primitive recursive.\n\nStep 2: Truncated Subtraction, $x \\dot{-} y$\nTruncated subtraction (or monus) is defined as $x \\dot{-} y = \\max(0, x-y)$. We define it using primitive recursion on the variable $y$:\n$$\nx \\dot{-} 0 = x\n$$\n$$\nx \\dot{-} S(y) = \\mathrm{pred}(x \\dot{-} y)\n$$\nThis definition fits the general primitive recursion schema $f(x,0) = g(x)$ and $f(x, S(y)) = h(x, y, f(x,y))$.\nFor the base case, $f(x,0) = x \\dot{-} 0 = x$, we take $g(x) = P_1^1(x)$, which is an initial function.\nFor the recursive step, $f(x, S(y)) = \\mathrm{pred}(f(x,y))$, we take $h(x,y,z) = \\mathrm{pred}(z)$. This function can be written as a composition of PR functions: $h(x,y,z) = \\mathrm{pred}(P_3^3(x,y,z))$. Since $\\mathrm{pred}$ has been shown to be PR and $P_3^3$ is an initial function, $h$ is PR by the closure property of composition.\nTherefore, the function for truncated subtraction, $x \\dot{-} y$, is primitive recursive.\n\nStep 3: Maximum and Minimum Functions, $\\max(x,y)$ and $\\min(x,y)$\nUsing the truncated subtraction function, we can define $\\max(x,y)$ and $\\min(x,y)$ as follows:\n$$\n\\max(x,y) = x + (y \\dot{-} x)\n$$\n$$\n\\min(x,y) = x \\dot{-} (x \\dot{-} y)\n$$\nTo verify these definitions, we consider two cases based on the order of $x$ and $y$.\nCase 1: $x \\le y$. In this case, $y \\dot{-} x = y-x$ and $x \\dot{-} y = 0$.\n$\\max(x,y) = x + (y-x) = y$.\n$\\min(x,y) = x \\dot{-} (0) = x$.\nCase 2: $x > y$. In this case, $y \\dot{-} x = 0$ and $x \\dot{-} y = x-y$.\n$\\max(x,y) = x + 0 = x$.\n$\\min(x,y) = x \\dot{-} (x-y) = x-(x-y) = y$.\nIn both cases, the formulas correctly yield the maximum and minimum of $x$ and $y$.\n\nStep 4: Proof that $\\max$ and $\\min$ are Primitive Recursive\nThe functions $\\max(x,y)$ and $\\min(x,y)$ are defined by composition of functions that are already established as primitive recursive.\n- The function $\\max(x,y) = x + (y \\dot{-} x)$ is a composition of addition $A(u,v)$, truncated subtraction $M(u,v)$, and projection functions $P_1^2(x,y)=x$ and $P_2^2(x,y)=y$. Specifically, $\\max(x,y) = A(P_1^2(x,y), M(P_2^2(x,y), P_1^2(x,y)))$. Since $A$, $M$, and the projection functions are all PR, $\\max(x,y)$ is PR by closure under composition.\n- The function $\\min(x,y) = x \\dot{-} (x \\dot{-} y)$ is also a composition of PR functions. Specifically, $\\min(x,y) = M(P_1^2(x,y), M(P_1^2(x,y), P_2^2(x,y)))$. Since $M$ and projection functions are PR, $\\min(x,y)$ is PR by closure under composition.\n\nStep 5: Algebraic Laws for $\\max$ and $\\min$\nWe now establish the standard algebraic properties. The proofs rely on case analysis of the order relation between $x$ and $y$.\n\n- Commutativity: $\\max(x,y) = \\max(y,x)$ and $\\min(x,y) = \\min(y,x)$.\n  If $x \\le y$, $\\max(x,y)=y$ and $\\max(y,x)=y$. If $x > y$, $\\max(x,y)=x$ and $\\max(y,x)=x$.\n  If $x \\le y$, $\\min(x,y)=x$ and $\\min(y,x)=x$. If $x > y$, $\\min(x,y)=y$ and $\\min(y,x)=y$.\n  Both properties hold.\n\n- Idempotence: $\\max(x,x) = x$ and $\\min(x,x) = x$.\n  Using the case $x \\le x$, we have $\\max(x,x)=x$ and $\\min(x,x)=x$.\n\n- Associativity: $\\max(x,\\max(y,z)) = \\max(\\max(x,y),z)$ and $\\min(x,\\min(y,z)) = \\min(\\min(x,y),z)$.\n  Both expressions correspond to finding the maximum (or minimum) of the set $\\{x,y,z\\}$. The result is independent of the order of operations. For any permutation of ordering of $x, y, z$, the equality holds. For instance, if $x \\le y \\le z$:\n  $\\max(x,\\max(y,z)) = \\max(x,z) = z$. $\\max(\\max(x,y),z) = \\max(y,z) = z$.\n  $\\min(x,\\min(y,z)) = \\min(x,y) = x$. $\\min(\\min(x,y),z) = \\min(x,z) = x$.\n\n- Absorption: $\\max(x,\\min(x,y)) = x$ and $\\min(x,\\max(x,y)) = x$.\n  If $x \\le y$, $\\min(x,y)=x$. Then $\\max(x,\\min(x,y)) = \\max(x,x) = x$.\n  If $x > y$, $\\min(x,y)=y$. Then $\\max(x,\\min(x,y)) = \\max(x,y) = x$.\n  If $x \\le y$, $\\max(x,y)=y$. Then $\\min(x,\\max(x,y)) = \\min(x,y) = x$.\n  If $x > y$, $\\max(x,y)=x$. Then $\\min(x,\\max(x,y)) = \\min(x,x) = x$.\n\n- Monotonicity: If $x \\le y$, then $\\max(x,z) \\le \\max(y,z)$ and $\\min(x,z) \\le \\min(y,z)$ for any $z$.\n  We prove this by cases on $z$.\n  For $\\max$: Let $x \\le y$.\n  Case 1: $z \\le x$. Then $z \\le x \\le y$. $\\max(x,z)=x$ and $\\max(y,z)=y$. Since $x \\le y$, the property holds.\n  Case 2: $x < z \\le y$. $\\max(x,z)=z$ and $\\max(y,z)=y$. Since $z \\le y$, the property holds.\n  Case 3: $z > y$. Then $x \\le y < z$. $\\max(x,z)=z$ and $\\max(y,z)=z$. The property holds.\n  For $\\min$: Let $x \\le y$.\n  Case 1: $z \\le x$. Then $z \\le x \\le y$. $\\min(x,z)=z$ and $\\min(y,z)=z$. The property holds.\n  Case 2: $x < z \\le y$. $\\min(x,z)=x$ and $\\min(y,z)=z$. Since $x < z$, the property holds.\n  Case 3: $z > y$. Then $x \\le y < z$. $\\min(x,z)=x$ and $\\min(y,z)=y$. Since $x \\le y$, the property holds.\n\n- Decomposition Identity: $\\max(x,y)+\\min(x,y)=x+y$.\n  Proof by case analysis:\n  Case 1: $x \\le y$. Then $\\max(x,y) = y$ and $\\min(x,y) = x$. The identity becomes $y+x=x+y$, which is true.\n  Case 2: $x > y$. Then $\\max(x,y) = x$ and $\\min(x,y) = y$. The identity becomes $x+y=x+y$, which is true.\n  The identity holds in all cases.\n\n  Alternatively, we can prove this identity algebraically. First, we establish the lemma $(a \\dot{-} b) + b = \\max(a,b)$.\n  Proof of lemma: If $a \\ge b$, $(a \\dot{-} b) + b = (a-b)+b = a = \\max(a,b)$. If $a < b$, $(a \\dot{-} b) + b = 0+b = b = \\max(a,b)$. The lemma is proven.\n  Now, using the definitions:\n  $\\max(x,y)+\\min(x,y) = \\max(x,y) + (x \\dot{-} (x \\dot{-} y))$.\n  We also know $(x \\dot{-} y)+y = \\max(x,y)$.\n  From $\\min(x,y) = x \\dot{-} (x \\dot{-} y)$, we add $(x \\dot{-} y)$ to both sides:\n  $\\min(x,y) + (x \\dot{-} y) = (x \\dot{-} (x \\dot{-} y)) + (x \\dot{-} y)$.\n  Applying the lemma to the right side with $a=x$ and $b=x \\dot{-} y$, we get $\\max(x, x \\dot{-} y)$. Since $x \\ge x \\dot{-} y$, this simplifies to $x$.\n  So, $\\min(x,y) + (x \\dot{-} y) = x$.\n  Add $y$ to both sides: $\\min(x,y) + (x \\dot{-} y) + y = x+y$.\n  Using the lemma again, $(x \\dot{-} y) + y = \\max(x,y)$.\n  Substituting this gives $\\min(x,y) + \\max(x,y) = x+y$, which completes the proof.\n\nThe required tasks have been completed. The final answer requires the expressions for $\\max(x,y)$ and $\\min(x,y)$.\n$\\max(x,y) = x + (y \\dot{-} x)$\n$\\min(x,y) = x \\dot{-} (x \\dot{-} y)$\nWhile other equivalent forms exist, such as $\\min(x,y)=y \\dot{-} (y \\dot{-} x)$, the derived expressions fulfill the problem's requirements.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nx + (y \\dot{-} x) & x \\dot{-} (x \\dot{-} y)\n\\end{pmatrix}\n}\n$$", "id": "2979433"}, {"introduction": "To formalize computation, we need a way for functions to operate on complex data structures like sequences, which can be elegantly achieved through Gödel coding. This practice challenges you to work with a prime-power encoding scheme to build a function that searches a coded sequence for a specific value [@problem_id:2979414]. This task demonstrates the power of primitive recursion to manipulate and analyze data, a cornerstone for proving more advanced results in computability theory.", "problem": "Let $N$ denote the set of natural numbers (including $0$). Work in the class of primitive recursive (PR) functions, starting only from the standard PR base functions (the zero function $Z(n)=0$, the successor function $S(n)=n+1$, and the projections $P^{k}_{i}(n_{0},\\dots,n_{k-1})=n_{i}$), together with closure under composition and primitive recursion. You may use as foundational facts the PR definability of addition, multiplication, bounded sums, bounded products, truncated subtraction, and order/equality predicates, and the classical number-theoretic fact known as Bertrand’s postulate (for every $m \\geq 1$ there exists a prime strictly between $m$ and $2m$).\n\nConsider the canonical prime-power coding of finite sequences: for a finite sequence $\\langle a_{0},a_{1},\\dots,a_{\\ell-1} \\rangle$ with $a_{i} \\in N$, its code is the natural number\n$$\n\\mathrm{code}(\\langle a_{0},\\dots,a_{\\ell-1} \\rangle)\\;=\\;\\prod_{i=0}^{\\ell-1} p_{i}^{\\,a_{i}+1},\n$$\nwhere $p_{i}$ is the $i$-th prime with index starting at $p_{0}=2,p_{1}=3,p_{2}=5,\\dots$.\n\nDefine a PR function $F(c,b)$ that, given a code $c \\in N$ and a bound $b \\in N$, scans the coded sequence for the first zero within the bound and returns its position. Concretely, $F(c,b)$ must return the least $i<b$ such that the $i$-th component of the coded sequence is $0$, and if no such position exists for $i<b$, it must return $b$. Your definition must be given explicitly in terms of PR building blocks (no unbounded minimization), and you must prove that $F$ is PR total by reducing each ingredient of your construction to base PR functions via composition and primitive recursion.\n\nFinally, evaluate your $F$ on the specific input $c=525000$ and $b=4$. The number $525000$ is to be interpreted as a prime-power code under the above scheme. Express your final answer as a single integer. No rounding is required.", "solution": "The problem asks for the definition of a primitive recursive (PR) function $F(c,b)$ that finds the position of the first zero in a coded sequence, and to evaluate it for a specific input. The solution proceeds in two main parts: first, a formal construction of $F(c,b)$ from the ground up to prove it is primitive recursive; second, the evaluation of $F(525000, 4)$.\n\nA function is primitive recursive if it is one of the base functions (Zero $Z$, Successor $S$, Projections $P^k_i$) or can be obtained from them by a finite number of applications of composition and primitive recursion. We are given that addition, multiplication, truncated subtraction ($x \\dot{-} y = \\max(0, x-y)$), bounded sums, bounded products, and order/equality predicates are PR.\n\nAn important tool is the bounded $\\mu$-operator. If $P(i, \\vec{x})$ is a PR predicate (i.e., its characteristic function $\\chi_P(i, \\vec{x})$ which is $1$ if $P$ is true and $0$ if false, is PR), then the function $f(y, \\vec{x}) = (\\mu i < y)[P(i, \\vec{x})]$ is also PR. This function returns the smallest $i<y$ for which $P(i, \\vec{x})$ holds, or $y$ if no such $i$ exists. Its primitive recursiveness is demonstrated by the construction:\n$$ f(y, \\vec{x}) = \\sum_{k=0}^{y-1} \\left( \\prod_{j=0}^{k} (1 - \\chi_P(j, \\vec{x})) \\right) $$\nSince $\\chi_P$, subtraction, bounded sums, and bounded products are PR, $f$ is PR. We will use this operator to construct our function.\n\nThe construction of $F(c,b)$ requires several intermediate PR functions.\n\n1.  **The function $p(i)$ returning the $i$-th prime, $p_i$**:\n    - We need to define a function $\\mathrm{IsPrime}(n)$ that returns $1$ if $n$ is prime, and $0$ otherwise. A number $n>1$ is prime if it has no divisors other than $1$ and $n$.\n    - The predicate $d|n$ (d divides n) is PR. Its characteristic function, $\\chi_{|}(d, n)$, can be constructed using the given PR building blocks. For $d>0$, $d|n \\iff \\exists k \\le n (d \\cdot k = n)$. Using the PR equality predicate $\\chi_=(a,b)$, we have $\\chi_{|}(d,n) = 1 \\dot{-} \\prod_{k=0}^{n} (1 \\dot{-} \\chi_=(d \\cdot k, n))$.\n    - The characteristic function for primality is then $\\chi_{\\mathrm{IsPrime}}(n) = \\chi_{>}(n,1) \\cdot \\prod_{d=2}^{n-1} (1 \\dot{-} \\chi_{|}(d,n))$. Since this is built from PR functions and operations, $\\mathrm{IsPrime}(n)$ is PR.\n    - The function $p(i)$ is defined by primitive recursion:\n        - Base case: $p(0) = 2$.\n        - Recursive step: $p(i+1)$ is the smallest prime number strictly greater than $p(i)$. An unbounded search for this prime is not PR. However, Bertrand's postulate states that for any $m \\ge 1$, there exists a prime $p$ such that $m < p < 2m$. This guarantees that $p(i) < p(i+1) < 2p(i)$. So we can use a bounded search.\n        - $p(i+1) = (\\mu y < 2 p(i)) [y > p(i) \\land \\mathrm{IsPrime}(y)]$.\n        - The predicate $P(y,i) \\equiv y > p(i) \\land \\mathrm{IsPrime}(y)$ is PR. Thus, the function for $p(i+1)$ is defined as $h(p(i))$, where $h(z) = (\\mu y < 2z)[y > z \\land \\mathrm{IsPrime}(y)]$ is a PR function.\n        - Therefore, $p(i)$ defined by $p(0)=2$ and $p(i+1) = h(p(i))$ is a primitive recursive function.\n\n2.  **The exponent function $\\mathrm{exp}(c, i)$**:\n    - This function computes the exponent of the $i$-th prime $p_i$ in the prime factorization of $c$.\n    - This is the largest integer $k$ such that $(p(i))^k$ divides $c$. Equivalently, it is the smallest integer $k$ such that $(p(i))^{k+1}$ does not divide $c$.\n    - We can define this using the bounded $\\mu$-operator. A safe upper bound for the exponent $k$ is $c$ itself, since if $p_i \\geq 2$, then $2^k \\leq p_i^k \\leq c$ implies $k \\leq c$.\n    - $\\mathrm{exp}(c, i) = (\\mu k < c+1) [1 \\dot{-} \\chi_{|}(p(i)^{k+1}, c) = 1]$. This predicate checks if $p(i)^{k+1}$ does not divide $c$.\n    - The power function $\\mathrm{pow}(b,e)=b^e$ is PR. The predicate involves PR functions $p(i)$, $\\mathrm{pow}$, and $\\chi_{|}$. Thus, the predicate is PR.\n    - Therefore, $\\mathrm{exp}(c, i)$ is a primitive recursive function.\n    - As a note, if $p(i)$ does not divide $c$, then for $k=0$, $p(i)^1$ does not divide $c$, so the $\\mu$-operator returns $0$. This is correct.\n\n3.  **The decoding function $\\mathrm{decode}(c, i)$**:\n    - The problem defines the code of a sequence $\\langle a_0, a_1, \\dots, a_{\\ell-1} \\rangle$ as $c = \\prod_{i=0}^{\\ell-1} p_i^{\\,a_i+1}$.\n    - This implies that the exponent of $p_i$ in the factorization of $c$ is $a_i+1$. That is, $\\mathrm{exp}(c,i) = a_i+1$.\n    - Solving for $a_i$, we get $a_i = \\mathrm{exp}(c, i) - 1$.\n    - Since the components $a_i$ must be natural numbers ($a_i \\in N$), we use truncated subtraction.\n    - $\\mathrm{decode}(c, i) = \\mathrm{exp}(c, i) \\dot{-} 1$.\n    - If for some $j$, $p_j$ is not a prime factor of $c$, then $\\mathrm{exp}(c,j) = 0$, and $\\mathrm{decode}(c,j) = 0 \\dot{-} 1 = 0$. This correctly models sequences that are implicitly padded with zeros.\n    - Since $\\mathrm{exp}(c,i)$ and truncated subtraction are PR, $\\mathrm{decode}(c,i)$ is PR by composition.\n\n4.  **The function $F(c, b)$**:\n    - The function $F(c,b)$ must return the least $i < b$ such that the $i$-th component of the coded sequence is $0$. If no such position exists for $i<b$, it must return $b$.\n    - This is a direct application of the bounded $\\mu$-operator.\n    - $F(c, b) = (\\mu i < b) [\\mathrm{decode}(c, i) = 0]$.\n    - The predicate is $P(i, c) \\equiv (\\mathrm{decode}(c, i) = 0)$. Its characteristic function is $\\chi_=( \\mathrm{decode}(c,i), 0)$, which is a composition of PR functions and hence is PR.\n    - As established, applying the bounded $\\mu$-operator to a PR predicate yields a PR function. Therefore, $F(c,b)$ is a primitive recursive function. This completes the proof of its PR nature.\n\nNow we evaluate $F(c,b)$ for the given inputs $c=525000$ and $b=4$.\nThe function is $F(c,b) = (\\mu i < b) [\\mathrm{decode}(c, i) = 0]$.\nWe need to find the smallest $i \\in \\{0, 1, 2, 3\\}$ such that $\\mathrm{decode}(525000, i) = 0$.\nThe decoding is based on the prime factorization of $c = 525000$.\n$$ c = 525000 = 525 \\times 1000 = 525 \\times 10^3 $$\n$$ c = (5^2 \\times 21) \\times (2 \\times 5)^3 = (5^2 \\times 3 \\times 7) \\times (2^3 \\times 5^3) $$\n$$ c = 2^3 \\times 3^1 \\times 5^5 \\times 7^1 $$\nThe sequence of primes starts with $p_0=2$, $p_1=3$, $p_2=5$, $p_3=7$.\nThe components $a_i$ are given by $a_i = \\mathrm{decode}(c,i) = \\mathrm{exp}(c,i) \\dot{-} 1$.\n\nWe check the condition for $i=0, 1, 2, 3$:\n\n- For $i=0$:\n  $p_0 = 2$. The exponent of $2$ in the factorization of $c$ is $3$.\n  $\\mathrm{exp}(c, 0) = 3$.\n  $\\mathrm{decode}(c, 0) = 3 \\dot{-} 1 = 2$. This is not $0$.\n\n- For $i=1$:\n  $p_1 = 3$. The exponent of $3$ in the factorization of $c$ is $1$.\n  $\\mathrm{exp}(c, 1) = 1$.\n  $\\mathrm{decode}(c, 1) = 1 \\dot{-} 1 = 0$. This is $0$.\n\nThe function $F(c,b)$ returns the least $i < b$ for which the condition is met. We have found that for $i=1$, the condition $\\mathrm{decode}(c,i)=0$ is satisfied. Since $1 < b=4$, this is a valid position. As this is the first such integer starting from $i=0$, the search terminates.\n\nThus, the value of $F(525000, 4)$ is $1$.", "answer": "$$\\boxed{1}$$", "id": "2979414"}, {"introduction": "The boundary between primitive recursive and general computable functions is defined by the unbounded minimization operator, $\\mu$. This exercise explores that boundary by asking you to define a function using an apparently unbounded search and then analyze its properties [@problem_id:2979409]. You will discover that by proving the search is always finite—and can be bounded—the function is in fact primitive recursive, revealing a crucial technique for classifying the complexity of computable functions.", "problem": "Let $\\mathbb{N}=\\{0,1,2,\\dots\\}$. Work within the standard framework of computability and definability over $\\mathbb{N}$ using the initial functions (zero, successor, projections), closure under composition and primitive recursion, and the (unbounded) minimization operator $\\mu$ as the fundamental construction rules. The factorial function is to be taken in its standard form, defined from first principles by primitive recursion: $!\\,(0)=1$ and $!\\,(y+1)=(y+1)\\cdot !\\,(y)$ for all $y\\in\\mathbb{N}$. Consider the total relation on $\\mathbb{N}^{2}$ given by $R(x,y)$ if and only if $!\\,(y)\\ge x$.\n\nConstruct the partial recursive function $f$ obtained by unbounded minimization of $R$:\n$$\nf(x)=\\mu y\\,\\big(R(x,y)\\big)=\\mu y\\,\\big(!\\,(y)\\ge x\\big).\n$$\nStarting solely from the fundamental closure properties and definitions just stated (initial functions, composition, primitive recursion, and minimization), carry out the following:\n\n- Give a rigorous construction that $R(x,y)$ is a total computable predicate obtained from primitive recursion and composition. \n- Prove that $f$ is partial recursive by an application of minimization to $R$.\n- Prove that $f$ is in fact total by establishing, from first principles about the factorial function, that for every input $x\\in\\mathbb{N}$ there exists a witness $y\\in\\mathbb{N}$ with $!\\,(y)\\ge x$. Then sharpen this to a primitive recursive bound $b(x)$ such that whenever $R(x,y)$ holds for some $y$, it holds for some $y\\le b(x)$. Use this bound to conclude, by a bounded search construction, that $f$ is primitive recursive.\n- Characterize precisely the domain of definition of $f$ and its divergence behavior.\n\nFinally, compute the exact value of $f(10)$. Give your final answer as a single exact integer. No rounding is required, and no units apply.", "solution": "First, we will construct the predicate $R(x,y)$ and show it is primitive recursive. A predicate is primitive recursive if its characteristic function is a primitive recursive function. We will use the convention that for a predicate $P$, its characteristic function $\\chi_P$ has value $1$ if $P$ is true, and $0$ if $P$ is false.\n\nThe fundamental (initial) primitive recursive functions are the zero function $Z(x)=0$, the successor function $S(x)=x+1$, and the projection functions $P_i^n(x_1, \\dots, x_n) = x_i$. New primitive recursive functions are built from these using composition and the scheme of primitive recursion.\n\n1.  **Addition and Multiplication are Primitive Recursive:**\n    Addition, $add(a,b)=a+b$, is defined by primitive recursion:\n    $$add(a, 0) = a = P_1^1(a)$$\n    $$add(a, b+1) = S(add(a,b)) = (S \\circ P_3^3)(a, b, add(a,b))$$\n    Multiplication, $mul(a,b)=a \\cdot b$, is also defined by primitive recursion using addition:\n    $$mul(a, 0) = 0 = Z(a)$$\n    $$mul(a, b+1) = add(a, mul(a,b)) = (add \\circ (P_1^3, P_3^3))(a, b, mul(a,b))$$\n    Since addition is primitive recursive, so is multiplication.\n\n2.  **The Factorial Function is Primitive Recursive:**\n    The factorial function, $!\\,(y)$, is defined as:\n    $$!\\,(0) = 1$$\n    $$!\\,(y+1) = (y+1) \\cdot !\\,(y)$$\n    This fits the schema of primitive recursion for a function of one variable, $f(0)=k$ and $f(y+1)=h(y, f(y))$.\n    The base case is $!\\,(0)=1$. The constant $1$ can be obtained from initial functions, for example, as $S(Z(y))$ evaluated at $y=0$.\n    The recursive step is defined by the function $h(y,z) = (y+1) \\cdot z = mul(S(y), z)$. Since $S$ is an initial function and $mul$ is primitive recursive, $h(y,z) = (mul \\circ (S \\circ P_1^2, P_2^2))(y,z)$ is primitive recursive by composition.\n    Therefore, the factorial function $!\\,(y)$ is primitive recursive.\n\n3.  **The Predicate `a >= b` is Primitive Recursive:**\n    To show this, we first define the \"monus\" or \"limited subtraction\" function, $a \\dot{-} b = \\max(0, a-b)$. This can be defined via primitive recursion on $b$. First, the predecessor function $pred(y)$ is primitive recursive: $pred(0)=0$ and $pred(y+1)=y=P_1^2(y, pred(y))$.\n    Then, monus is defined as:\n    $$a \\dot{-} 0 = a = P_1^1(a)$$\n    $$a \\dot{-} (b+1) = pred(a \\dot{-} b)$$\n    Thus $a \\dot{-} b$ is primitive recursive.\n    The characteristic function of the predicate $a \\le b$, denoted $\\chi_{\\le}(a,b)$, can be expressed using monus: $\\chi_{\\le}(a,b) = 1 \\dot{-} (1 \\dot{-} (b \\dot{-} a))$. If $a \\le b$, then $b \\dot{-} a \\ge 0$. The characteristic function for `a >= b` is $\\chi_{\\ge}(a,b) = 1 \\dot{-} (1 \\dot{-} (a \\dot{-} b))$; it is 1 if $a \\ge b$ and 0 otherwise. A simpler form for the characteristic function of $a \\le b$ is based on testing if $a \\dot{-} b$ is zero: $\\chi_{\\le}(a,b) = 1 \\dot{-} \\text{sg}(a \\dot{-} b)$, where $\\text{sg}(0)=0$ and $\\text{sg}(x)=1$ for $x>0$. Since $\\text{sg}$ and monus are primitive recursive, $\\chi_{\\le}$ is primitive recursive.\n    The predicate $R(x,y)$ is $!\\,(y) \\ge x$, which is equivalent to $x \\le !\\,(y)$. Its characteristic function is $\\chi_R(x,y) = \\chi_{\\le}(x, !\\,(y))$.\n    This is the composition of primitive recursive functions: $\\chi_R(x,y) = (\\chi_{\\le} \\circ (P_1^2, ! \\circ P_2^2))(x,y)$.\n    Thus, $R(x,y)$ is a primitive recursive predicate. As all primitive recursive functions are total and computable, $R(x,y)$ is a total computable predicate.\n\nNext, we prove that $f(x)=\\mu y\\,\\big(R(x,y)\\big)$ is partial recursive.\nThe class of partial recursive functions is the smallest class containing the initial functions and closed under composition, primitive recursion, and the unbounded minimization operator $\\mu$. The operator $\\mu$ is typically applied to a function $g(\\vec{z}, y)$ and produces the smallest $y$ for which $g(\\vec{z}, y)=0$.\nTo align with this definition, we consider the characteristic function of the complement of $R(x,y)$, which we denote $g(x,y)$.\nLet $g(x,y) = 1 \\dot{-} \\chi_R(x,y)$.\nSince $\\chi_R$ is primitive recursive, and monus is primitive recursive, $g(x,y)$ is a primitive recursive function.\nBy construction, $g(x,y)=0$ if and only if $\\chi_R(x,y)=1$, which is true if and only if $R(x,y)$ holds (i.e., $!\\,(y) \\ge x$).\nThe function $f(x)$ is defined as the smallest $y$ for which $R(x,y)$ holds. This is precisely $f(x) = \\mu y \\, [g(x,y)=0]$.\nSince $g(x,y)$ is a primitive recursive (and hence total recursive) function, the function $f(x)$ obtained by applying the $\\mu$-operator is, by definition, a partial recursive function.\n\nNow, we prove that $f$ is a total function, and subsequently that it is primitive recursive.\nTo prove $f$ is total, we must show that for every $x \\in \\mathbb{N}$, the search for a $y$ such that $!\\,(y) \\ge x$ terminates. This requires showing that for every $x \\in \\mathbb{N}$, there exists at least one $y \\in \\mathbb{N}$ satisfying the relation $R(x,y)$.\nLet's consider an arbitrary $x \\in \\mathbb{N}$.\n- If $x=0$, we can choose $y=0$. Then $!\\,(0)=1$, and $1 \\ge 0$. So a witness exists.\n- If $x > 0$, we can choose $y=x$. We must check if $!\\,(x) \\ge x$ for $x > 0$.\n  - For $x=1$, $!\\,(1)=1 \\ge 1$.\n  - For $x \\ge 2$, the factorial $!\\,(x)$ is a product $x \\cdot (x-1) \\cdot \\dots \\cdot 2 \\cdot 1$. We can write $!\\,(x) = x \\cdot (!(x-1))$. Since $x \\ge 2$, we have $x-1 \\ge 1$, so $!(x-1) \\ge 1$. Thus, $!\\,(x) = x \\cdot (!(x-1)) \\ge x \\cdot 1 = x$.\nSo, for any $x \\in \\mathbb{N}$, a witness $y$ exists. For $x \\ge 1$, $y=x$ is a witness.\nSince for every input $x$ a witness $y$ exists, the search $\\mu y \\, [!\\,(y) \\ge x]$ always terminates. Therefore, $f(x)$ is a total function.\n\nTo prove that $f$ is primitive recursive, we use the fact that a total function defined by a minimization operator is primitive recursive if the search can be bounded by a primitive recursive function.\nAs shown above, for any $x \\in \\mathbb{N}$, a witness $y$ can be found such that $y \\le x$.\n- For $x=0$, $f(0)=0$, and $0 \\le 0$.\n- For $x=1$, $f(1) = \\mu y [!\\,(y) \\ge 1]$. For $y=0$, $!\\,(0)=1 \\ge 1$, so $f(1)=0$. We have $0 \\le 1$.\n- For $x \\ge 2$, we proved that $!\\,(x) \\ge x$. This means that in the search for the minimal $y$, a solution is guaranteed to be found at or before $y=x$. Thus, $f(x) \\le x$.\nIn all cases, for any $x \\in \\mathbb{N}$, we have $f(x) \\le x$.\nThis means the unbounded search can be replaced by a bounded search:\n$$f(x) = \\mu y_{\\le x} \\, [!\\,(y) \\ge x]$$\nThe search bound is given by the function $b(x)=x$, which is the identity function $P_1^1(x)$, an initial function and therefore primitive recursive.\nA function defined by bounded minimization on a primitive recursive predicate is itself primitive recursive. We can show this constructively. Let $g(x,y)=1 \\dot{-} \\chi_R(x,y)$ as before.\nThen $f(x)$ can be written as:\n$$f(x) = \\sum_{k=0}^{x} \\left( \\prod_{i=0}^{k} g(x,i) \\right)$$\nThis formula works because the product term $\\prod_{i=0}^{k} g(x,i)$ is $1$ if $g(x,i)=1$ for all $i \\le k$, and $0$ otherwise. The sum counts how many initial consecutive values of $y$ fail the condition. For the first $y$ that satisfies the condition, say $y_0$, $g(x, y_0)=0$, and the product term for $k \\ge y_0$ becomes $0$. The sum will be $\\sum_{k=0}^{y_0-1} 1 = y_0$.\nSince $g(x,y)$ is primitive recursive, and primitive recursive functions are closed under bounded sums and bounded products, this construction shows that $f(x)$ is primitive recursive.\n\nCharacterization of the domain of definition and divergence behavior:\nWe have established that for every $x \\in \\mathbb{N}$, there exists a $y \\in \\mathbb{N}$ such that $!\\,(y) \\ge x$. This implies that the minimization process always terminates.\n- The domain of definition of $f$ is the set of all natural numbers, $\\mathbb{N}$.\n- The function $f(x)$ is total, which means it is defined for every input $x \\in \\mathbb{N}$. Consequently, there are no values of $x$ for which $f(x)$ diverges. The set of points where $f$ diverges is the empty set, $\\emptyset$.\n\nFinally, we compute the exact value of $f(10)$.\nThe function is $f(x) = \\mu y \\, [!\\,(y) \\ge x]$. For $x=10$, we need to find the smallest natural number $y$ such that $!\\,(y) \\ge 10$.\nWe test values of $y$ starting from $0$:\n- For $y=0$: $!\\,(0) = 1$. The condition $1 \\ge 10$ is false.\n- For $y=1$: $!\\,(1) = 1$. The condition $1 \\ge 10$ is false.\n- For $y=2$: $!\\,(2) = 2$. The condition $2 \\ge 10$ is false.\n- For $y=3$: $!\\,(3) = 6$. The condition $6 \\ge 10$ is false.\n- For $y=4$: $!\\,(4) = 24$. The condition $24 \\ge 10$ is true.\nSince $y=4$ is the smallest natural number for which the condition holds, we have $f(10)=4$.", "answer": "$$\\boxed{4}$$", "id": "2979409"}]}