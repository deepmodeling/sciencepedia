{"hands_on_practices": [{"introduction": "The Turing machine serves as the bedrock model of computation, providing a formal definition for what it means to be \"computable\". This first practice [@problem_id:2970583] brings this abstract concept to life by tasking you with the construction of a Turing machine that performs unary addition. By manually designing the state transitions for a specific algorithm, you will gain a deep, hands-on understanding of how these simple machines can execute concrete computational tasks and lay the groundwork for the Church-Turing thesis.", "problem": "A deterministic single-tape Turing Machine (TM) is given formally as a $7$-tuple $(Q,\\Sigma,\\Gamma,\\delta,q_{0},q_{\\mathrm{acc}},q_{\\mathrm{rej}})$, where $Q$ is a finite set of states, $\\Sigma \\subseteq \\Gamma \\setminus \\{\\sqcup\\}$ is the input alphabet, $\\Gamma$ is the tape alphabet, $\\delta: Q \\times \\Gamma \\to Q \\times \\Gamma \\times \\{L,N,R\\}$ is the transition function mapping a current state and scanned symbol to a next state, a symbol to write, and a head move left ($L$), no move ($N$), or right ($R$), $q_{0} \\in Q$ is the start state, and $q_{\\mathrm{acc}}, q_{\\mathrm{rej}} \\in Q$ are halting accept and reject states. Unary representation encodes a natural number $k$ as the string $1^k$, and we encode a pair $(m,n)$ as the concatenation $1^m 0 1^n$ on the tape, surrounded by blanks $\\sqcup$.\n\nStarting from the foundational definitions of Turing computability and the unary encoding above, construct a deterministic single-tape TM that computes the total function $f(m,n) = m + n$ by transforming an input with tape contents $\\sqcup^\\omega 1^m 0 1^n \\sqcup^\\omega$ into an output $\\sqcup^\\omega 1^{m+n} \\sqcup^\\omega$ and then halting in the accept state. The head initially scans the leftmost nonblank symbol of the input. Your construction must implement addition via a move-and-erase strategy: first eliminate the separator $0$ by writing a blank $\\sqcup$, thereby creating a single-cell gap, and then shift the right block of $1$-symbols left by one cell using a loop that repeatedly moves and erases a single $1$ from immediately to the right of the gap into the gap until the gap reaches the right end of the block.\n\nExplicitly provide:\n- The tape alphabet $\\Gamma$, input alphabet $\\Sigma$, blank symbol, and the set of named states in $Q$.\n- The transition function $\\delta$ entries for all state-symbol pairs that occur during correct computation on inputs of the form $1^m 0 1^n$, covering the phases that scan to the separator, erase the separator, inspect the symbol immediately to the right of the gap, write $1$ into the gap when appropriate, erase the moved $1$, and decide to halt.\n- A brief invariant-based argument from first principles that this TM computes $f(m,n) = m+n$ as specified by the Church–Turing thesis, namely that the informal algorithm of eliminating the separator and shifting the right block is realized by the formal transition system and halts on all inputs of the specified form with the correct output.\n\nFinally, derive the exact number of head moves, denoted $T(m,n)$, executed by your TM from the initial configuration on input $1^m 0 1^n$ until halting. Express $T(m,n)$ as a single closed-form analytic expression in terms of $m$ and $n$. No rounding is required, and no units apply. The final answer must be a single expression.", "solution": "### Turing Machine Construction\n\nBased on the specified algorithm, we can design the components of the Turing Machine.\n\n**TM Components**\n\n*   **Set of States ($Q$)**: We define the set of states as $Q = \\{q_0, q_{\\text{find1}}, q_{\\text{carry1}}, q_{\\text{write1}}, q_{\\text{acc}}, q_{\\text{rej}}\\}$.\n    *   $q_0$: The initial state, used to scan rightward to the separator $0$.\n    *   $q_{\\text{find1}}$: Scans for the next $1$ in the right-hand block to be shifted.\n    *   $q_{\\text{carry1}}$: \"Carries\" a $1$ leftward to fill the current gap.\n    *   $q_{\\text{write1}}$: Has just written a $1$ into the gap and needs to move to the new gap.\n    *   $q_{\\text{acc}}$: The halting accept state.\n    *   $q_{\\text{rej}}$: The halting reject state (not used for valid inputs).\n*   **Input Alphabet ($\\Sigma$)**: $\\Sigma = \\{0, 1\\}$.\n*   **Tape Alphabet ($\\Gamma$)**: $\\Gamma = \\{0, 1, \\sqcup\\}$. The blank symbol is $\\sqcup$.\n\n**Transition Function ($\\delta$)**\n\nThe transition function is defined by the following rules, which implement the phases of the specified algorithm.\n\n1.  **Phase 1: Scan to the separator.**\n    In state $q_0$, the machine moves right over the initial block of $m$ ones.\n    $$ \\delta(q_0, 1) = (q_0, 1, R) $$\n\n2.  **Phase 2: Erase the separator and begin the shift.**\n    When the separator $0$ is found, it is replaced with a blank $\\sqcup$, and the head moves right to the start of the second block of ones, entering the main loop state $q_{\\text{find1}}$.\n    $$ \\delta(q_0, 0) = (q_{\\text{find1}}, \\sqcup, R) $$\n\n3.  **Phase 3: The shifting loop and termination.**\n    This set of transitions implements the shuttle-like motion to shift the block $1^n$ one cell to the left.\n    *   In state $q_{\\text{find1}}$, the machine is looking for the next $1$ to move. If a $1$ is found, it is \"picked up\" by writing a $\\sqcup$, and the machine transitions to state $q_{\\text{carry1}}$ to move this $1$ left.\n        $$ \\delta(q_{\\text{find1}}, 1) = (q_{\\text{carry1}}, \\sqcup, L) $$\n    *   If state $q_{\\text{find1}}$ encounters a $\\sqcup$, it signifies that all $n$ ones have been shifted. The computation is complete, and the machine halts.\n        $$ \\delta(q_{\\text{find1}}, \\sqcup) = (q_{\\text{acc}}, \\sqcup, N) $$\n    *   In state $q_{\\text{carry1}}$, the machine's head is on the gap (a $\\sqcup$) created in the previous step. It writes a $1$ into the gap, enters state $q_{\\text{write1}}$, and moves right.\n        $$ \\delta(q_{\\text{carry1}}, \\sqcup) = (q_{\\text{write1}}, 1, R) $$\n    *   In state $q_{\\text{write1}}$, the machine has just filled the old gap. The head is now positioned on the newly created gap. It moves right to begin searching for the next $1$, re-entering state $q_{\\text{find1}}$.\n        $$ \\delta(q_{\\text{write1}}, \\sqcup) = (q_{\\text{find1}}, \\sqcup, R) $$\n\n### Invariant-Based Argument for Correctness\n\nWe argue that the constructed TM correctly computes $f(m,n)=m+n$.\n\n*   **Initialization**: The TM starts with the tape configuration $\\sqcup^\\omega 1^m 0 1^n \\sqcup^\\omega$ and the head on the leftmost $1$.\n*   **Pre-Loop**: The transitions for state $q_0$ move the head across the $m$ ones and then replace the separator $0$ with a $\\sqcup$. At the end of this phase, the tape configuration is $\\sqcup^\\omega 1^m \\sqcup 1^n \\sqcup^\\omega$, and the machine is in state $q_{\\text{find1}}$ with its head on the first $1$ of the $1^n$ block (or on a $\\sqcup$ if $n=0$).\n*   **Loop Invariant**: Let's define the invariant for the start of the $k$-th iteration of the main loop (for $k \\in \\{1, 2, \\dots, n\\}$).\n    *   **Invariant**: The tape holds the string $1^{m+k-1} \\sqcup 1^{n-(k-1)}$, the machine is in state $q_{\\text{find1}}$, and the head scans the leftmost $1$ of the block $1^{n-(k-1)}$.\n    *   **Base Case ($k=1$):** After the pre-loop phase, the tape is $1^m \\sqcup 1^n$, the state is $q_{\\text{find1}}$, and the head is on the first $1$ of $1^n$. This matches the invariant for $k=1$.\n    *   **Inductive Step:** Assume the invariant holds for iteration $k$. The three transitions for states $q_{\\text{find1}}$, $q_{\\text{carry1}}$, and $q_{\\text{write1}}$ execute a single shift. They take the leftmost $1$ of the right block, move it into the $\\sqcup$ gap, thus transforming the tape from $1^{m+k-1} \\sqcup 1^{n-(k-1)}$ to $1^{m+k} \\sqcup 1^{n-k}$. The head is repositioned on the leftmost $1$ of the new right block ($1^{n-k}$), and the state returns to $q_{\\text{find1}}$. This re-establishes the invariant for iteration $k+1$.\n*   **Termination**: The loop executes exactly $n$ times. After the $n$-th iteration, the tape holds the string $1^{m+n} \\sqcup$. The machine, in state $q_{\\text{find1}}$, then searches for the next $1$ to move. It finds a $\\sqcup$ (the one at the position where the $(n+1)$-th one would have been). According to the transition $\\delta(q_{\\text{find1}}, \\sqcup) = (q_{\\text{acc}}, \\sqcup, N)$, the machine transitions to the accept state and halts. The final tape configuration is $\\sqcup^\\omega 1^{m+n} \\sqcup^\\omega$, as required. This provides a constructive proof that addition is a computable function, in accordance with the Church-Turing thesis.\n\n### Derivation of Head Moves $T(m,n)$\n\nWe now calculate the total number of head moves, $T(m,n)$, as a function of $m$ and $n$.\n\n1.  **Phase 1 (Scan to separator)**: The head starts on the first of $m$ ones and moves right until it reaches the $0$. This requires $m$ right moves ($R$).\n    *   Moves: $m$.\n\n2.  **Phase 2 (Erase separator)**: The transition $\\delta(q_0, 0)$ involves one right move ($R$).\n    *   Moves: $1$.\n\n3.  **Phase 3 (Shifting loop)**: The loop executes $n$ times, once for each $1$ in the $1^n$ block. We count the moves for a single iteration:\n    *   $\\delta(q_{\\text{find1}}, 1)$: one left move ($L$).\n    *   $\\delta(q_{\\text{carry1}}, \\sqcup)$: one right move ($R$).\n    *   $\\delta(q_{\\text{write1}}, \\sqcup)$: one right move ($R$).\n    Each iteration of the loop thus requires $1+1+1=3$ moves. Since there are $n$ iterations, this phase takes $3n$ moves in total.\n    *   Moves: $3n$.\n\n4.  **Phase 4 (Termination)**: After the loop completes, the machine is in state $q_{\\text{find1}}$ and reads a $\\sqcup$. The transition to $q_{\\text{acc}}$ involves no head movement ($N$).\n    *   Moves: $0$.\n\nThe total number of head moves is the sum of moves from all phases:\n$$ T(m,n) = (\\text{Phase 1}) + (\\text{Phase 2}) + (\\text{Phase 3}) + (\\text{Phase 4}) $$\n$$ T(m,n) = m + 1 + 3n + 0 $$\n$$ T(m,n) = m + 3n + 1 $$\nThis closed-form expression holds for all non-negative integers $m, n \\ge 0$.", "answer": "$$\\boxed{m+3n+1}$$", "id": "2970583"}, {"introduction": "While Turing machines provide a mechanical model of computation, the theory of recursive functions offers a more abstract, mathematical perspective. This exercise [@problem_id:2970603] guides you through the construction of primitive recursive functions, a powerful class of total computable functions. You will build a pairing function and its inverses, a fundamental tool that demonstrates how structured data like pairs and tuples can be encoded as single natural numbers, a key insight for both theoretical computer science and mathematical logic.", "problem": "Let $\\mathbb{N}=\\{0,1,2,\\dots\\}$ and recall the foundational scheme for defining primitive recursive (PR) functions on $\\mathbb{N}$: the initial functions are the zero function $Z(x)=0$, the successor function $S(x)=x+1$, and the projection functions $P^{n}_{i}(x_{1},\\dots,x_{n})=x_{i}$ for $1\\leq i\\leq n$. The class of PR functions is the smallest class containing the initial functions and closed under composition and primitive recursion. Using only this base, complete the following tasks.\n\n1. Construct an explicit pairing function $\\langle x,y\\rangle:\\mathbb{N}^{2}\\to\\mathbb{N}$ and prove that it is primitive recursive. Construct explicit inverse functions $\\pi_{1},\\pi_{2}:\\mathbb{N}\\to\\mathbb{N}$ such that for all $x,y\\in\\mathbb{N}$, $\\pi_{1}(\\langle x,y\\rangle)=x$ and $\\pi_{2}(\\langle x,y\\rangle)=y$, and prove that $\\pi_{1}$ and $\\pi_{2}$ are primitive recursive.\n\n2. Using your pairing function, define by primitive recursion on $k\\geq 2$ a uniform family of coding functions $C_{k}:\\mathbb{N}^{k}\\to\\mathbb{N}$ for finite tuples by setting $C_{2}(x_{1},x_{2})=\\langle x_{1},x_{2}\\rangle$ and $C_{k+1}(x_{1},\\dots,x_{k+1})=\\langle x_{1},C_{k}(x_{2},\\dots,x_{k+1})\\rangle$. Explain why, for each fixed $k$, $C_{k}$ is primitive recursive, and define corresponding primitive recursive decoding functions $D^{(k)}_{i}:\\mathbb{N}\\to\\mathbb{N}$ for $1\\leq i\\leq k$ satisfying $D^{(k)}_{i}(C_{k}(x_{1},\\dots,x_{k}))=x_{i}$.\n\n3. Using the specific constructions you chose in parts $1$ and $2$, compute the single natural number $C_{5}(3,1,4,1,5)$. Provide this integer as your final answer. No rounding is required and no units are involved; report the exact integer.", "solution": "A function is primitive recursive if it is one of the initial functions (Zero $Z(x)=0$, Successor $S(x)=x+1$, Projections $P^{n}_{i}(\\vec{x})=x_{i}$), or if it is obtained by applying the operations of composition or primitive recursion to already established PR functions.\n\nFirst, we establish some essential PR functions:\n1.  **Addition**: $add(x,y)=x+y$. $add(x,0) = x = P^1_1(x)$. $add(x,S(y)) = S(add(x,y))$. This is defined by primitive recursion on $y$. The recursion step is $h(x,y,z) = S(P^3_3(x,y,z))$. Thus, addition is PR.\n2.  **Multiplication**: $mult(x,y)=x \\cdot y$. $mult(x,0) = 0 = Z(x)$. $mult(x,S(y)) = add(mult(x,y), x)$. This is defined by primitive recursion on $y$. The recursion step is $h(x,y,z) = add(P^3_3(x,y,z), P^3_1(x,y,z))$. Thus, multiplication is PR.\n3.  **Predecessor**: $pred(x)$. $pred(0) = 0$. $pred(S(y)) = y$. This is defined by primitive recursion on $x$ (with dummy variable $y$). The recursion step is $h(y,z) = P^2_1(y,z)$. Thus, predecessor is PR.\n4.  **Proper Subtraction (Monus)**: $x \\dot{-} y = \\max(0, x-y)$. $x \\dot{-} 0 = x$. $x \\dot{-} S(y) = pred(x \\dot{-} y)$. This is defined by primitive recursion on $y$. The recursion step is $h(x,y,z) = pred(P^3_3(x,y,z))$. Thus, monus is PR.\n5.  **Comparison Predicates**: The characteristic functions for relations like $x=y$, $x<y$, $x \\le y$ are PR. For example, $\\chi_{=}(x,y) = 1 \\dot{-} ((x \\dot{-} y) + (y \\dot{-} x))$.\n6.  **Bounded Minimization**: It is a standard result that if $P(\\vec{x}, y)$ is a PR predicate (its characteristic function is PR), then the function $f(\\vec{x}, z) = \\mu y \\le z [P(\\vec{x}, y)]$, which gives the smallest $y \\le z$ for which $P$ is true (or $z+1$ if no such $y$ exists), is PR. This allows for bounded search.\n7.  **Integer Division by a Constant**: For any constant $k \\in \\mathbb{N}, k > 0$, the function $div_k(n) = \\lfloor n/k \\rfloor$ is PR. It can be defined using bounded minimization: $\\lfloor n/k \\rfloor = (\\mu y \\le n)[(y+1) \\cdot k > n]$. The predicate $(y+1) \\cdot k > n$ involves addition, multiplication, and comparison, which are PR.\n\n### Part 1: Pairing Function and Inverses\n\nWe choose the Cantor pairing function, a bijective map from $\\mathbb{N}^2$ to $\\mathbb{N}$:\n$$ \\langle x,y\\rangle = \\frac{1}{2}(x+y)(x+y+1)+y $$\nThis can be written as $\\langle x,y\\rangle = div_2((x+y) \\cdot (x+y+1)) + y$.\n\n**Proof that $\\langle x,y\\rangle$ is Primitive Recursive:**\nThe function $\\langle x,y\\rangle$ is constructed by composing PR functions. Let's denote $f_1(x,y)=x+y$, $f_2(z)=z+1$, $f_3(w,v)=w \\cdot v$, $f_4(u)=\\lfloor u/2 \\rfloor$, and $f_5(a,b)=a+b$.\nAll of these are PR:\n-   $f_1$ and $f_5$ are addition.\n-   $f_2$ is the successor function composed with projections.\n-   $f_3$ is multiplication.\n-   $f_4$ is integer division by the constant $2$, which we established is PR.\n\nThe pairing function can be expressed as a composition:\n$\\langle x,y\\rangle = f_5( f_4( f_3(f_1(x,y), f_2(f_1(x,y))) ), y )$.\nSince the class of PR functions is closed under composition, $\\langle x,y\\rangle$ is a primitive recursive function.\n\n**Construction of Inverse Functions $\\pi_1, \\pi_2$:**\nLet $z = \\langle x,y\\rangle$. Let $w = x+y$. The triangular number function $T(w) = \\frac{1}{2}w(w+1)$ is the first part of the pairing function. The key properties are $T(w) \\le z < T(w+1)$. Since $T(w)$ is strictly increasing for $w \\ge 0$, we can uniquely find $w$ from $z$.\n\nWe define a function $W(z)$ that computes $w = x+y$ from $z$.\n$W(z) = (\\mu w' \\le z)[ T(w'+1) > z ]$.\nSince $T(w') = \\lfloor (w' \\cdot (w'+1))/2 \\rfloor$ is PR, the predicate $T(w'+1)>z$ is PR. By closure under bounded minimization, $W(z)$ is a PR function.\n\nOnce $w$ is found, we can find $y$ and then $x$:\n$y = z - T(w) = z - \\frac{1}{2}w(w+1)$.\nSo, we define the first inverse function $\\pi_2(z)$:\n$$ \\pi_2(z) = z \\dot{-} T(W(z)) = z \\dot{-} \\lfloor (W(z) \\cdot (W(z)+1))/2 \\rfloor $$\nThis is a composition of PR functions (monus, $W(z)$, multiplication, addition, division by $2$), so $\\pi_2(z)$ is PR.\n\nFinally, since $w=x+y$, we have $x = w-y$. We define the second inverse function $\\pi_1(z)$:\n$$ \\pi_1(z) = W(z) \\dot{-} \\pi_2(z) $$\nThis is a composition of PR functions ($W(z)$, $\\pi_2(z)$, monus), so $\\pi_1(z)$ is also PR.\n\nBy construction, for any $x,y \\in \\mathbb{N}$, we have $\\pi_1(\\langle x,y\\rangle)=x$ and $\\pi_2(\\langle x,y\\rangle)=y$.\n\n### Part 2: Tuple Coding and Decoding\n\nThe problem defines a family of coding functions $C_k:\\mathbb{N}^k \\to \\mathbb{N}$ for $k \\ge 2$ as:\n$C_2(x_1, x_2) = \\langle x_1, x_2 \\rangle$\n$C_{k+1}(x_1, \\dots, x_{k+1}) = \\langle x_1, C_k(x_2, \\dots, x_{k+1}) \\rangle$\n\n**Proof that $C_k$ is Primitive Recursive:**\nWe prove by induction on $k \\ge 2$ that $C_k$ is PR.\n-   **Base Case ($k=2$):** $C_2(x_1, x_2) = \\langle x_1, x_2 \\rangle$. As shown in Part 1, the pairing function is PR.\n-   **Inductive Step:** Assume that for a fixed $k \\ge 2$, the function $C_k(y_1, \\dots, y_k)$ is PR. We must show that $C_{k+1}(x_1, \\dots, x_{k+1})$ is PR.\n    By definition, $C_{k+1}(x_1, \\dots, x_{k+1}) = \\langle x_1, C_k(x_2, \\dots, x_{k+1}) \\rangle$.\n    This is a composition of functions:\n    1.  The pairing function $\\langle \\cdot, \\cdot \\rangle$, which is PR.\n    2.  The projection function $P^{k+1}_1(x_1, \\dots, x_{k+1}) = x_1$, which is an initial PR function.\n    3.  The function $C_k$ applied to the last $k$ arguments. This can be written as $C_k(P^{k+1}_2(\\vec{x}), \\dots, P^{k+1}_{k+1}(\\vec{x}))$. By the inductive hypothesis, $C_k$ is PR, and composing it with projections (which are PR) yields a PR function.\n    Since $C_{k+1}$ is a composition of PR functions, it is itself PR.\nBy induction, $C_k$ is a primitive recursive function for every fixed integer $k \\ge 2$.\n\n**Definition of Decoding Functions $D^{(k)}_i$:**\nThe decoding functions $D^{(k)}_i:\\mathbb{N} \\to \\mathbb{N}$ must satisfy $D^{(k)}_i(C_k(x_1, \\dots, x_k)) = x_i$ for $1 \\le i \\le k$. Let $z = C_k(x_1, \\dots, x_k)$. The structure of the encoding is nested:\n$z = \\langle x_1, \\langle x_2, \\dots, \\langle x_{k-1}, x_k \\rangle \\dots \\rangle \\rangle$.\nWe can define the decoding functions using the inverse pairing functions $\\pi_1$ and $\\pi_2$:\n-   $x_1 = \\pi_1(z)$\n-   $x_2 = \\pi_1(\\pi_2(z))$\n-   $x_3 = \\pi_1(\\pi_2(\\pi_2(z)))$\n-   ...\n-   $x_i = \\pi_1(\\pi_2^{i-1}(z))$ for $i < k$, where $\\pi_2^j(z)$ is the $j$-fold composition of $\\pi_2$.\n-   $x_k = \\pi_2^{k-1}(z)$.\n\nFormally, for $z \\in \\mathbb{N}$ and for a fixed $k \\ge 2$:\n$$ D^{(k)}_i(z) = \\begin{cases} \\pi_1(\\pi_2^{i-1}(z)) & \\text{if } 1 \\le i < k \\\\ \\pi_2^{k-1}(z) & \\text{if } i=k \\end{cases} $$\nwhere $\\pi_2^0(z) = z$ and $\\pi_2^{j+1}(z) = \\pi_2(\\pi_2^j(z))$.\n\n**Proof that $D^{(k)}_i$ is Primitive Recursive:**\nFor any fixed integers $k \\ge 2$ and $1 \\le i \\le k$:\n-   The functions $\\pi_1$ and $\\pi_2$ are PR, as shown in Part 1.\n-   The iterated function $\\pi_2^j(z)$ for any fixed $j \\ge 0$ is a finite composition of a PR function with itself, and thus is PR.\n-   The functions $D^{(k)}_i(z)$ are defined as a finite composition of the PR functions $\\pi_1$ and $\\pi_2$. For instance, $D^{(k)}_3(z) = \\pi_1(\\pi_2(\\pi_2(z)))$.\nTherefore, for any fixed $k$ and $i$, the decoding function $D^{(k)}_i$ is primitive recursive.\n\n### Part 3: Calculation\n\nWe must compute $C_5(3,1,4,1,5)$ using the pairing function $\\langle x,y\\rangle = \\frac{1}{2}(x+y)(x+y+1)+y$.\n$C_5(3,1,4,1,5) = \\langle 3, C_4(1,4,1,5) \\rangle$\n$C_4(1,4,1,5) = \\langle 1, C_3(4,1,5) \\rangle$\n$C_3(4,1,5) = \\langle 4, C_2(1,5) \\rangle$\n$C_2(1,5) = \\langle 1,5 \\rangle$\n\nWe compute from the inside out:\n1.  $C_2(1,5) = \\langle 1,5 \\rangle$. Here $x=1, y=5$.\n    $$ \\langle 1,5 \\rangle = \\frac{1}{2}(1+5)(1+5+1) + 5 = \\frac{1}{2}(6)(7) + 5 = 21 + 5 = 26 $$\n\n2.  $C_3(4,1,5) = \\langle 4, C_2(1,5) \\rangle = \\langle 4, 26 \\rangle$. Here $x=4, y=26$.\n    $$ \\langle 4,26 \\rangle = \\frac{1}{2}(4+26)(4+26+1) + 26 = \\frac{1}{2}(30)(31) + 26 = 15 \\cdot 31 + 26 = 465 + 26 = 491 $$\n\n3.  $C_4(1,4,1,5) = \\langle 1, C_3(4,1,5) \\rangle = \\langle 1, 491 \\rangle$. Here $x=1, y=491$.\n    $$ \\langle 1,491 \\rangle = \\frac{1}{2}(1+491)(1+491+1) + 491 = \\frac{1}{2}(492)(493) + 491 $$\n    $$ = 246 \\cdot 493 + 491 = 121278 + 491 = 121769 $$\n\n4.  $C_5(3,1,4,1,5) = \\langle 3, C_4(1,4,1,5) \\rangle = \\langle 3, 121769 \\rangle$. Here $x=3, y=121769$.\n    $$ \\langle 3,121769 \\rangle = \\frac{1}{2}(3+121769)(3+121769+1) + 121769 $$\n    $$ = \\frac{1}{2}(121772)(121773) + 121769 $$\n    $$ = 60886 \\cdot 121773 + 121769 $$\n    The multiplication gives $60886 \\cdot 121773 = 7414270878$.\n    Adding the final term: $7414270878 + 121769 = 7414392647$.\n\nThe final result is the integer $7414392647$.", "answer": "$$ \\boxed{7414392647} $$", "id": "2970603"}, {"introduction": "Having seen how data can be encoded as numbers, we can now take the final step and recognize that programs themselves can be encoded as numbers. This profound idea, where programs become data for other programs to manipulate, leads to remarkable results. In this culminating practice [@problem_id:2970608], you will use the $s$-$m$-$n$ theorem and the logic behind Kleene's Recursion Theorem to construct a \"quine\"—a program that outputs its own index. This exercise reveals the deep structure of computability and the surprising power of self-reference.", "problem": "Fix an acceptable Gödel numbering of partial computable functions so that for each $e \\in \\mathbb{N}$, the index $e$ names a unary partial computable function $y \\mapsto \\varphi_{e}(y)$, and for each $e \\in \\mathbb{N}$, the index $e$ also names a binary partial computable function $(x,y) \\mapsto \\varphi_{e}^{(2)}(x,y)$ (obtained by any standard uniform pairing of inputs). Assume the following foundational facts.\n\n1. There exists a total primitive recursive pairing function $\\langle \\cdot,\\cdot \\rangle : \\mathbb{N}^{2} \\to \\mathbb{N}$ that is bijective with primitive recursive projections.\n2. There exists a universal index $U$ for the binary enumeration such that for all $e,a,y \\in \\mathbb{N}$, one has $\\varphi_{U}^{(2)}(\\langle e,a \\rangle, y) = \\varphi_{e}^{(2)}(a,y)$.\n3. (Kleene $s$-$m$-$n$) There exists a total primitive recursive function $s : \\mathbb{N}^{2} \\to \\mathbb{N}$ such that for all $e,a,y \\in \\mathbb{N}$, one has $\\varphi_{s(e,a)}(y) = \\varphi_{e}^{(2)}(a,y)$.\n4. Fix an index $p$ for the binary “print” program, defined by $\\varphi_{p}^{(2)}(x,y) = x$ for all $x,y \\in \\mathbb{N}$.\n\nDefine the binary partial computable function $D : \\mathbb{N}^{2} \\rightrightarrows \\mathbb{N}$ by\n$$\nD(x,y) \\;=\\; \\varphi_{s(p,\\,s(x,x))}(y),\n$$\nand fix any index $d$ satisfying $\\varphi_{d}^{(2)}(x,y) = D(x,y)$ for all $x,y \\in \\mathbb{N}$.\n\nUsing only the fundamental facts above (especially the Kleene Recursion Theorem and the $s$-$m$-$n$ theorem), construct a unary self-referential program (a “quine”) that on any input $y$ outputs its own index. Your construction must proceed from first principles by explicitly building the index as a computable expression from the given primitives $s$, $p$, and the chosen index $d$. In the course of your derivation, explain the conceptual role that the $s$-$m$-$n$ theorem plays in enabling the self-reference.\n\nWhat is a single closed-form expression, in terms of the symbols $s$ and $d$ introduced above, for the index $e^{\\star}$ of such a quine? Provide your final answer as a single symbolic expression. No numerical approximation or rounding is required.", "solution": "The objective is to find an index $e^{\\star} \\in \\mathbb{N}$ such that for all inputs $y \\in \\mathbb{N}$, the partial computable function $\\varphi_{e^{\\star}}$ halts and outputs its own index: $\\varphi_{e^{\\star}}(y) = e^{\\star}$.\n\nThe construction relies fundamentally on the Kleene $s$-$m$-$n$ theorem. This theorem provides a total primitive recursive function $s: \\mathbb{N}^2 \\to \\mathbb{N}$ such that for any index $e$ of a binary partial computable function $\\varphi_e^{(2)}(x,y)$, and any value $a \\in \\mathbb{N}$ for the first input, we can compute a new index $s(e,a)$ for the resulting unary function. That is, $\\varphi_{s(e,a)}(y) = \\varphi_e^{(2)}(a,y)$. Conceptually, the $s$-$m$-$n$ theorem formalizes the process of specialization or partial evaluation: it provides a computable way to transform a general-purpose program (index $e$) into a specialized program (index $s(e,a)$) by fixing one of its inputs. This ability for programs to mechanically generate indices for other programs is the essential mechanism that enables the self-reference required for a quine, as demonstrated by the constructive proof of Kleene's Recursion Theorem.\n\nThe construction proceeds by first analyzing the function $D(x,y)$ provided in the problem statement. This function is defined as $D(x,y) = \\varphi_{s(p, s(x,x))}(y)$. We are given that $d$ is an index for this function, meaning $\\varphi_d^{(2)}(x,y) = D(x,y)$ for all $x,y \\in \\mathbb{N}$.\n\nLet us simplify the expression for $D(x,y)$.\nBy the definition of the $s$-$m$-$n$ theorem, we can state that for any $e, a, y \\in \\mathbb{N}$:\n$$\n\\varphi_{s(e,a)}(y) = \\varphi_{e}^{(2)}(a,y)\n$$\nIn the expression for $D(x,y)$, we can identify $e=p$ and $a=s(x,x)$. Applying the theorem gives:\n$$\n\\varphi_{s(p, s(x,x))}(y) = \\varphi_{p}^{(2)}(s(x,x), y)\n$$\nThe problem defines the index $p$ as corresponding to the binary \"print\" program, such that $\\varphi_{p}^{(2)}(z,y) = z$ for all $z, y \\in \\mathbb{N}$. Substituting $z = s(x,x)$, we get:\n$$\n\\varphi_{p}^{(2)}(s(x,x), y) = s(x,x)\n$$\nCombining these results, we find the simplified form of $D(x,y)$:\n$$\nD(x,y) = \\varphi_{s(p, s(x,x))}(y) = s(x,x)\n$$\nSince $d$ is the index for $D(x,y)$, we have established a crucial property of the program with index $d$:\n$$\n\\varphi_{d}^{(2)}(x,y) = s(x,x)\n$$\nThis means that the binary program with index $d$ takes two inputs, $x$ and $y$, ignores the second input $y$, and returns the value $s(x,x)$.\n\nWe now employ a construction that mirrors the proof of Kleene's Recursion Theorem to find the desired fixed point. The theorem's constructive proof suggests that for a function like $\\varphi_d^{(2)}$, a fixed point can often be found by applying the $s$-function to the index of the function itself. Let us propose the candidate index $e^{\\star}$ for our quine as:\n$$\ne^{\\star} = s(d,d)\n$$\nTo verify that this index corresponds to a quine, we must evaluate the function $\\varphi_{e^{\\star}}(y)$ for an arbitrary input $y \\in \\mathbb{N}$.\n\nBy definition of $e^{\\star}$, we have:\n$$\n\\varphi_{e^{\\star}}(y) = \\varphi_{s(d,d)}(y)\n$$\nWe apply the $s$-$m$-$n$ theorem to the right-hand side, with $e=d$ and $a=d$:\n$$\n\\varphi_{s(d,d)}(y) = \\varphi_{d}^{(2)}(d,y)\n$$\nNow, we use our previously derived property of the function $\\varphi_d^{(2)}$, which states that $\\varphi_d^{(2)}(x,y) = s(x,x)$ for all $x,y$. We substitute $x=d$:\n$$\n\\varphi_{d}^{(2)}(d,y) = s(d,d)\n$$\nBy stringing these equalities together, we obtain:\n$$\n\\varphi_{e^{\\star}}(y) = \\varphi_{s(d,d)}(y) = \\varphi_{d}^{(2)}(d,y) = s(d,d)\n$$\nSince we defined $e^{\\star} = s(d,d)$, we have demonstrated that for any input $y$,\n$$\n\\varphi_{e^{\\star}}(y) = e^{\\star}\n$$\nThis confirms that the index $e^{\\star} = s(d,d)$ is indeed the index of a quine. The expression is built solely from the given primitives $s$ and $d$, as required.", "answer": "$$\n\\boxed{s(d,d)}\n$$", "id": "2970608"}]}