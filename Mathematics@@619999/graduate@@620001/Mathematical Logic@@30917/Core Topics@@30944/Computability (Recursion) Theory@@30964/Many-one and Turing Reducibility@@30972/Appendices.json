{"hands_on_practices": [{"introduction": "Understanding the hierarchy of computational problems begins with mastering the tools used to compare them: reducibilities. This first exercise serves as a comprehensive check-in on the core definitions of one-one ($\\le_1$), many-one ($\\le_m$), and Turing ($\\le_T$) reducibility. By evaluating a series of fundamental propositions, you will solidify your understanding of their relationships and how they interact with key concepts like recursive and recursively enumerable sets [@problem_id:2981118].", "problem": "Let $A,B \\subseteq \\mathbb{N}$. Recall the following foundational definitions from computability theory:\n- A set $S \\subseteq \\mathbb{N}$ is recursive (decidable) if its characteristic function is total computable.\n- A set $S \\subseteq \\mathbb{N}$ is recursively enumerable (r.e.) if there is a Turing machine that enumerates exactly the elements of $S$, or equivalently, a Turing machine that halts on input $x$ if and only if $x \\in S$.\n- Many-one reducibility (also called mapping reducibility) is defined by $A \\leq_{m} B$ if there exists a total computable function $f:\\mathbb{N} \\to \\mathbb{N}$ such that for all $x \\in \\mathbb{N}$,\n$$\nx \\in A \\iff f(x) \\in B.\n$$\n- One-one reducibility is defined by $A \\leq_{1} B$ if there exists a total computable injective function $f:\\mathbb{N} \\to \\mathbb{N}$ such that for all $x \\in \\mathbb{N}$,\n$$\nx \\in A \\iff f(x) \\in B.\n$$\n- Turing reducibility is defined by $A \\leq_{T} B$ if there exists an oracle Turing machine with oracle for $B$ that decides membership in $A$.\n\nLet $K = \\{ e \\in \\mathbb{N} : \\varphi_{e}(e) \\downarrow \\}$ be the classical halting set on self-input, where $(\\varphi_{e})_{e \\in \\mathbb{N}}$ is a standard numbering of partial computable functions.\n\nSelect all statements that are true. Each selection should be justified from these core definitions and general facts of computability theory.\n\nA. If $A \\leq_{1} B$, then $A \\leq_{m} B$, and if $A \\leq_{m} B$, then $A \\leq_{T} B$.\n\nB. If $A \\leq_{m} B$ and $B$ is recursive, then $A$ is recursive.\n\nC. If $A \\leq_{T} B$ and $B$ is recursive, then $A$ is recursive.\n\nD. For every recursively enumerable set $A$, there exists a total computable injective function $f$ such that for all $x \\in \\mathbb{N}$, $x \\in A \\iff f(x) \\in K$. Equivalently, every r.e. set $A$ satisfies $A \\leq_{1} K$.\n\nE. There exist recursively enumerable sets $A,B$ with $A \\leq_{m} B$ but $A \\not\\leq_{1} B$.\n\nF. If $A \\leq_{m} B$ and $B$ is co-recursively enumerable, then $A$ is co-recursively enumerable.\n\nG. If $A \\leq_{m} B$ and $B$ is recursively enumerable and many-one complete (that is, for every r.e. set $C$, $C \\leq_{m} B$), then $A$ is recursively enumerable and many-one complete.\n\nH. If $A \\leq_{T} B$ and $B \\leq_{T} A$, then $A$ and $B$ are many-one equivalent (that is, $A \\leq_{m} B$ and $B \\leq_{m} A$).", "solution": "The problem statement provides standard definitions from computability theory and asks to evaluate the truth of eight statements based on these definitions. The problem is well-defined, scientifically sound, and internally consistent.\n\nA. **If $A \\leq_{1} B$, then $A \\leq_{m} B$, and if $A \\leq_{m} B$, then $A \\leq_{T} B$.**\n\nThis statement makes two claims.\n\n1.  If $A \\leq_{1} B$, then $A \\leq_{m} B$.\n    By definition, $A \\leq_{1} B$ means there exists a total computable injective function $f: \\mathbb{N} \\to \\mathbb{N}$ such that for all $x \\in \\mathbb{N}$, $x \\in A \\iff f(x) \\in B$.\n    By definition, $A \\leq_{m} B$ means there exists a total computable function $g: \\mathbb{N} \\to \\mathbb{N}$ such that for all $x \\in \\mathbb{N}$, $x \\in A \\iff g(x) \\in B$.\n    Since any injective function is, by definition, a function, the existence of the total computable injective function $f$ for the $1$-reduction immediately implies the existence of a total computable function for an $m$-reduction (we can simply take $g=f$). Thus, this implication is true.\n\n2.  If $A \\leq_{m} B$, then $A \\leq_{T} B$.\n    By definition, $A \\leq_{m} B$ means there exists a total computable function $f$ such that $x \\in A \\iff f(x) \\in B$.\n    By definition, $A \\leq_{T} B$ means there exists an oracle Turing machine with an oracle for $B$ that decides membership in $A$.\n    We can construct such an oracle machine, $M^B$, to decide $A$. On any input $x \\in \\mathbb{N}$:\n    a. Compute $y = f(x)$. Since $f$ is a total computable function, this step always halts.\n    b. Query the oracle for $B$ on the input $y$. The oracle, by definition, halts and returns `true` if $y \\in B$ and `false` if $y \\notin B$.\n    c. If the oracle returns `true`, then $y \\in B$, which implies $x \\in A$. The machine $M^B$ halts and accepts.\n    d. If the oracle returns `false`, then $y \\notin B$, which implies $x \\notin A$. The machine $M^B$ halts and rejects.\n    This procedure is a total algorithm that uses oracle $B$ to decide membership in $A$. Therefore, $A \\leq_{T} B$. This implication is also true.\n\nSince both claims are true, the statement is **Correct**.\n\nB. **If $A \\leq_{m} B$ and $B$ is recursive, then $A$ is recursive.**\n\nGiven $A \\leq_{m} B$, there exists a total computable function $f$ such that $x \\in A \\iff f(x) \\in B$.\nGiven $B$ is recursive, its characteristic function, $\\chi_B(y)$, is a total computable function where $\\chi_B(y) = 1$ if $y \\in B$ and $\\chi_B(y) = 0$ if $y \\notin B$.\nTo prove $A$ is recursive, we must show that its characteristic function, $\\chi_A(x)$, is total computable.\nFrom the reduction, the condition $x \\in A$ is equivalent to $f(x) \\in B$. This means $\\chi_A(x) = 1$ if and only if $\\chi_B(f(x)) = 1$. Similarly, $\\chi_A(x) = 0$ if and only if $\\chi_B(f(x)) = 0$.\nTherefore, $\\chi_A(x) = \\chi_B(f(x))$ for all $x \\in \\mathbb{N}$.\nThe function $\\chi_A$ is defined as the composition of two total computable functions, $f$ and $\\chi_B$. The class of total computable functions is closed under composition. Hence, $\\chi_A$ is a total computable function.\nThis proves that $A$ is a recursive set.\nThe statement is **Correct**.\n\nC. **If $A \\leq_{T} B$ and $B$ is recursive, then $A$ is recursive.**\n\nGiven $A \\leq_{T} B$, there exists an oracle Turing machine $M^B$ that decides membership in $A$. This means $M^B$ halts on all inputs $x \\in \\mathbb{N}$, accepting if $x \\in A$ and rejecting if $x \\notin A$.\nGiven $B$ is recursive, there exists a standard (non-oracle) Turing machine $M_B$ that decides membership in $B$. That is, for any input $y$, $M_B$ halts and accepts if $y \\in B$ and halts and rejects if $y \\notin B$.\nWe can construct a standard Turing machine $M_A$ that decides $A$. $M_A$ will simulate the execution of $M^B$. Whenever $M^B$ makes an oracle query \"Is $y \\in B$?\", the simulation is paused. $M_A$ then runs the decider $M_B$ on input $y$. Since $M_B$ is a decider, it is guaranteed to halt. $M_A$ uses the result of $M_B$'s computation to provide the answer to $M^B$'s oracle query and then resumes the simulation.\nSince $M^B$ is guaranteed to halt on all inputs, and each oracle call within its computation is replaced by a computation that is also guaranteed to halt (the execution of $M_B$), the overall machine $M_A$ will halt on all inputs. It correctly decides membership in $A$.\nTherefore, $A$ is a recursive set.\nThe statement is **Correct**.\n\nD. **For every recursively enumerable set $A$, there exists a total computable injective function $f$ such that for all $x \\in \\mathbb{N}$, $x \\in A \\iff f(x) \\in K$. Equivalently, every r.e. set $A$ satisfies $A \\leq_{1} K$.**\n\nThis statement claims that the halting set $K$ is $1$-complete for the class of recursively enumerable (r.e.) sets.\nLet $A$ be any r.e. set. By definition, $A$ is the domain of some partial computable function. Let this function be $\\varphi_a$ for some index $a$, so $A = \\text{dom}(\\varphi_a) = \\{x \\in \\mathbb{N} \\mid \\varphi_a(x) \\downarrow\\}$.\nWe want to show $A \\leq_{1} K$. To do this, we must construct a total computable injective function $f$ such that $x \\in A \\iff f(x) \\in K$.\nConsider the function $\\psi(x, y)$ which, on any input $y$, simulates the computation of $\\varphi_a(x)$. If the simulation of $\\varphi_a(x)$ halts, then $\\psi(x, y)$ halts. If it does not halt, $\\psi(x, y)$ does not halt. Note that the behavior of $\\psi(x,y)$ does not depend on $y$.\nSo, $\\text{dom}(\\psi(x, \\cdot)) = \\mathbb{N}$ if $x \\in A$, and $\\text{dom}(\\psi(x, \\cdot)) = \\emptyset$ if $x \\notin A$.\nThe S-m-n theorem (in its effective version, also related to the Padding Lemma) states that there exists a total computable *injective* function $f(x)$ such that for all $x$ and $y$, $\\varphi_{f(x)}(y) \\simeq \\psi(x, y)$. The injective property is key; it ensures that different inputs $x$ produce different program indices $f(x)$, typically by adding useless instructions (\"padding\") to the program code.\nWith this function $f$, we have:\n$x \\in A \\iff \\varphi_a(x) \\downarrow \\iff$ for all $y$, $\\psi(x,y) \\downarrow \\iff$ for all $y$, $\\varphi_{f(x)}(y) \\downarrow$.\nThe halting set is defined as $K = \\{e \\mid \\varphi_e(e) \\downarrow\\}$. We need to relate our condition to self-application.\nA slightly different construction is more direct. For each $x$, define a program $P_x$ that on any input $z$ does the following: it first runs the computation of $\\varphi_a(x)$ and, if that halts, it then halts. The Padding Lemma guarantees that the index of this program, let's call it $f(x)$, can be given by a total computable injective function of $x$.\nThus, for any $z$, $\\varphi_{f(x)}(z)$ halts if and only if $\\varphi_a(x)$ halts.\nIn particular, we can choose $z = f(x)$. So, $\\varphi_{f(x)}(f(x))$ halts if and only if $\\varphi_a(x)$ halts.\nThis gives the equivalence: $x \\in A \\iff \\varphi_a(x) \\downarrow \\iff \\varphi_{f(x)}(f(x)) \\downarrow \\iff f(x) \\in K$.\nSince $f$ is a total computable injective function, we have shown that $A \\leq_{1} K$. As $A$ was an arbitrary r.e. set, the statement holds.\nThe statement is **Correct**.\n\nE. **There exist recursively enumerable sets $A,B$ with $A \\leq_{m} B$ but $A \\not\\leq_{1} B$.**\n\nThis statement claims that many-one reducibility is strictly weaker than one-one reducibility. Let's find a counterexample to $A \\leq_{m} B \\implies A \\leq_{1} B$.\nLet $A = \\mathbb{N} = \\{0, 1, 2, \\dots\\}$ and $B = \\{0\\}$.\nBoth $A$ and $B$ are recursive (their characteristic functions are trivially computable), and therefore they are also recursively enumerable.\n1.  Show $A \\leq_{m} B$. We need a total computable function $f$ such that $x \\in A \\iff f(x) \\in B$.\n    Since $A = \\mathbb{N}$, the condition $x \\in A$ is always true. Thus, we need $f(x) \\in B$ to be always true. This means $f(x)$ must always be $0$.\n    Let $f(x) = 0$ for all $x \\in \\mathbb{N}$. This is a constant function, which is total computable. The equivalence `true <=> true` holds for all $x$. Thus, $\\mathbb{N} \\leq_{m} \\{0\\}$.\n2.  Show $A \\not\\leq_{1} B$. We need to show that there is no total computable *injective* function $g$ such that $x \\in A \\iff g(x) \\in B$.\n    Suppose such a function $g$ exists. As before, $x \\in A$ is always true, so we must have $g(x) \\in B$ for all $x \\in \\mathbb{N}$. This means $g(x) = 0$ for all $x$.\n    However, for $g$ to be injective, we must have $g(x_1) \\neq g(x_2)$ whenever $x_1 \\neq x_2$.\n    Let $x_1 = 0$ and $x_2 = 1$. Then $g(0)=0$ and $g(1)=0$, which violates injectivity.\n    Therefore, no such injective function $g$ can exist. So $A \\not\\leq_{1} B$.\nWe have found r.e. sets $A$ and $B$ that satisfy the condition.\nThe statement is **Correct**.\n\nF. **If $A \\leq_{m} B$ and $B$ is co-recursively enumerable, then $A$ is co-recursively enumerable.**\n\nGiven $A \\leq_{m} B$, there is a total computable function $f$ where $x \\in A \\iff f(x) \\in B$.\nTaking the negation of both sides, we get $x \\notin A \\iff f(x) \\notin B$.\nLet $\\bar{A} = \\mathbb{N} \\setminus A$ and $\\bar{B} = \\mathbb{N} \\setminus B$ be the complements of $A$ and $B$. The equivalence can be written as $x \\in \\bar{A} \\iff f(x) \\in \\bar{B}$.\nThis shows that $\\bar{A} \\leq_{m} \\bar{B}$ via the same total computable function $f$.\nWe are given that $B$ is co-recursively enumerable (co-r.e.). By definition, this means its complement $\\bar{B}$ is recursively enumerable (r.e.).\nNow we have $\\bar{A} \\leq_{m} \\bar{B}$ and $\\bar{B}$ is r.e. We need to show that this implies $\\bar{A}$ is r.e.\nSince $\\bar{B}$ is r.e., there is a Turing machine $M_{\\bar{B}}$ that halts on input $y$ if and only if $y \\in \\bar{B}$.\nWe can construct a Turing machine $M_{\\bar{A}}$ to recognize $\\bar{A}$:\nOn input $x$:\n1. Compute $y = f(x)$. This halts as $f$ is total computable.\n2. Run $M_{\\bar{B}}$ on input $y$.\n$M_{\\bar{A}}$ halts if and only if $M_{\\bar{B}}$ halts on $y=f(x)$. This is true if and only if $f(x) \\in \\bar{B}$, which is true if and only if $x \\in \\bar{A}$.\nThus, $M_{\\bar{A}}$ is a recognizer for $\\bar{A}$, which means $\\bar{A}$ is r.e.\nIf $\\bar{A}$ is r.e., then by definition, $A$ is co-r.e.\nThe statement is **Correct**.\n\nG. **If $A \\leq_{m} B$ and $B$ is recursively enumerable and many-one complete (that is, for every r.e. set $C$, $C \\leq_{m} B$), then $A$ is recursively enumerable and many-one complete.**\n\nThis statement claims that m-completeness is inherited by sets that reduce to an m-complete set. This is false. A reduction $A \\leq_m B$ means $A$ is \"no harder than\" $B$. It does not imply $A$ is \"as hard as\" $B$.\nLet's construct a counterexample.\nLet $B = K$, the halting set. $K$ is r.e. and m-complete.\nLet $A = \\emptyset$. The empty set is recursive, so it is also r.e.\nDoes $A \\leq_{m} B$? That is, is $\\emptyset \\leq_{m} K$? We need a total computable function $f$ such that $x \\in \\emptyset \\iff f(x) \\in K$.\nThe left side, $x \\in \\emptyset$, is always false. So we need the right side, $f(x) \\in K$, to be always false. This means the range of $f$ must be a subset of $\\bar{K}$.\nThe set $\\bar{K}$ is not r.e., but it is non-empty (in fact, it's infinite). Let $k_0$ be any element in $\\bar{K}$ (e.g., the index of a program that loops forever).\nDefine $f(x) = k_0$ for all $x \\in \\mathbb{N}$. This is a total computable function.\nThe reduction condition becomes `false <=> false`, which is true for all $x$. Thus, $\\emptyset \\leq_{m} K$.\nSo we have $A = \\emptyset$, $B = K$. The premises are satisfied: $A \\leq_m B$ and $B$ is m-complete.\nIs the conclusion true? Is $A = \\emptyset$ r.e. and m-complete?\n$A$ is r.e. But is it m-complete? For $A$ to be m-complete, every r.e. set $C$ must satisfy $C \\leq_m A$.\nLet's choose a non-empty r.e. set, for instance $C=\\{0\\}$.\nIf $\\{0\\} \\leq_m \\emptyset$, there must be a total computable function $g$ such that for all $x$, $x \\in \\{0\\} \\iff g(x) \\in \\emptyset$.\nThe right side, $g(x) \\in \\emptyset$, is always false.\nFor the equivalence to hold, the left side, $x \\in \\{0\\}$, must also be always false.\nBut for $x=0$, $x \\in \\{0\\}$ is true. For $x=0$, we get the contradiction `true <=> false`.\nThus, no such function $g$ exists. So $\\{0\\} \\not\\leq_m \\emptyset$.\nTherefore, $\\emptyset$ is not m-complete. The conclusion is false.\nThe statement is **Incorrect**.\n\nH. **If $A \\leq_{T} B$ and $B \\leq_{T} A$, then $A$ and $B$ are many-one equivalent (that is, $A \\leq_{m} B$ and $B \\leq_{m} A$).**\n\nThis statement claims that Turing equivalence ($A \\equiv_T B$) implies many-one equivalence ($A \\equiv_m B$). This is known to be false; Turing reducibility is a strictly coarser equivalence relation than many-one reducibility.\nLet's find a counterexample. Consider $A = K$ (the halting set) and $B = \\bar{K}$ (its complement).\n1.  Show $A \\leq_T B$ and $B \\leq_T A$.\n    To show $K \\leq_T \\bar{K}$, we need an oracle machine with an oracle for $\\bar{K}$ to decide $K$. On input $x$, query the oracle: \"is $x \\in \\bar{K}$?\". If the oracle answers yes, then $x \\notin K$, so reject. If it answers no, then $x \\in K$, so accept. This is a decider for $K$. So $K \\leq_T \\bar{K}$.\n    Symmetrically, to show $\\bar{K} \\leq_T K$, we use an oracle for $K$. On input $x$, query: \"is $x \\in K$?\". If yes, then $x \\notin \\bar{K}$, so reject. If no, then $x \\in \\bar{K}$, so accept. This is a decider for $\\bar{K}$. So $\\bar{K} \\leq_T K$.\n    Thus, $K \\equiv_T \\bar{K}$.\n2.  Show that it is not the case that $A \\equiv_m B$. We will show that $K \\not\\leq_m \\bar{K}$.\n    Assume for contradiction that $K \\leq_m \\bar{K}$.\n    $K$ is an r.e. set. By definition, $\\bar{K}$ is a co-r.e. set.\n    We proved in statement F that if $X \\leq_m Y$ and $Y$ is co-r.e., then $X$ is co-r.e.\n    Applying this result with $X=K$ and $Y=\\bar{K}$: since $K \\leq_m \\bar{K}$ (by assumption) and $\\bar{K}$ is co-r.e., it follows that $K$ must be co-r.e.\n    So, $K$ would be both r.e. (which it is by definition) and co-r.e.\n    By Post's Theorem, a set is recursive if and only if it is both r.e. and co-r.e. This would imply that $K$ is recursive.\n    However, it is a fundamental result of computability theory that the halting set $K$ is not recursive. This is a contradiction.\n    Therefore, our initial assumption must be false. So, $K \\not\\leq_m \\bar{K}$.\n    Since $K \\not\\leq_m \\bar{K}$, the sets $K$ and $\\bar{K}$ are not many-one equivalent.\nWe have found sets $A, B$ such that $A \\equiv_T B$ but $A \\not\\equiv_m B$.\nThe statement is **Incorrect**.\n\nSummary of results:\nA: Correct\nB: Correct\nC: Correct\nD: Correct\nE: Correct\nF: Correct\nG: Incorrect\nH: Incorrect\n\nThe true statements are A, B, C, D, E, and F.", "answer": "$$\\boxed{ABCDEF}$$", "id": "2981118"}, {"introduction": "Reducibility relations like $\\le_m$ impose a structure on the universe of all languages, allowing us to group them into equivalence classes based on computational difficulty. This practice problem investigates the nature of this structure by asking a critical question: is the relation antisymmetric? Through a clever construction, you will demonstrate that two distinct languages can be many-one reducible to each other, revealing that many-one equivalence does not imply equality and that $\\le_m$ defines a preorder, not a partial order [@problem_id:1349294].", "problem": "Let $\\Sigma = \\{0, 1\\}$ be an alphabet. A language over $\\Sigma$ is any set of finite-length strings whose symbols are drawn from $\\Sigma$. The set of all finite-length strings over $\\Sigma$ is denoted $\\Sigma^*$. A function $f: \\Sigma^* \\to \\Sigma^*$ is said to be a total computable function if there exists a Turing Machine that, for any input string $w \\in \\Sigma^*$, halts and produces the output string $f(w)$.\n\nA language $L_1$ is said to be many-one reducible to a language $L_2$, denoted $L_1 \\le_m L_2$, if there exists a total computable function $f: \\Sigma^* \\to \\Sigma^*$ such that for every string $w \\in \\Sigma^*$, the condition ($w \\in L_1$) is true if and only if the condition ($f(w) \\in L_2$) is true.\n\nThe relation $\\le_m$ is known to be reflexive ($L \\le_m L$ for any language $L$) and transitive (if $L_1 \\le_m L_2$ and $L_2 \\le_m L_3$, then $L_1 \\le_m L_3$).\n\nNow, for any non-empty language $A \\subseteq \\Sigma^*$, define two new languages:\n$L_0(A) = \\{ 0s \\mid s \\in A \\}$\n$L_1(A) = \\{ 1s \\mid s \\in A \\}$\nHere, $0s$ denotes the string formed by concatenating the symbol '0' with the string $s$.\n\nLet $U$ be a specific non-empty, undecidable language (a language for which no Turing machine exists that halts and correctly decides membership for all strings). Let $L_U^0 = L_0(U)$ and $L_U^1 = L_1(U)$ be the languages constructed from $U$.\n\nConsider the following four statements:\n(I) $L_U^0 \\le_m L_U^1$.\n(II) $L_U^1 \\le_m L_U^0$.\n(III) $L_U^0 = L_U^1$.\n(IV) The relation $\\le_m$, when considered on the set of all languages over $\\Sigma$, is antisymmetric. (A relation $R$ on a set $S$ is antisymmetric if for all $x, y \\in S$, if $x R y$ and $y R x$, then $x=y$).\n\nWhich of the following options correctly identifies all the true statements from the list above?\n\nA. I only\n\nB. I and II only\n\nC. I, II, and III only\n\nD. IV only\n\nE. None of the above statements are true.", "solution": "We work over $\\Sigma=\\{0,1\\}$. For any non-empty language $U \\subseteq \\Sigma^{*}$, define $L_{U}^{0}=\\{0s \\mid s \\in U\\}$ and $L_{U}^{1}=\\{1s \\mid s \\in U\\}$.\n\nTo establish (I) $L_{U}^{0} \\le_{m} L_{U}^{1}$, define a total computable function $f:\\Sigma^{*}\\to\\Sigma^{*}$ by\n$$\nf(w)=\n\\begin{cases}\n1s & \\text{if } w=0s \\text{ for some } s \\in \\Sigma^{*},\\\\\n0 & \\text{otherwise.}\n\\end{cases}\n$$\nThis $f$ is computable because checking whether $w$ begins with $0$ and modifying the first symbol is a simple, effective procedure, and the constant map to $0$ is computable. For correctness, consider any $w \\in \\Sigma^{*}$:\n- If $w=0s$, then\n$$\nw \\in L_{U}^{0} \\iff s \\in U \\iff 1s \\in L_{U}^{1} \\iff f(w) \\in L_{U}^{1}.\n$$\n- If $w$ is not of the form $0s$, then $w \\notin L_{U}^{0}$ by definition, and $f(w)=0 \\notin L_{U}^{1}$ because every string in $L_{U}^{1}$ begins with $1$ while $0$ begins with $0$. Hence\n$$\nw \\in L_{U}^{0} \\iff f(w) \\in L_{U}^{1}\n$$\nstill holds (both sides are false). Therefore (I) is true.\n\nTo establish (II) $L_{U}^{1} \\le_{m} L_{U}^{0}$, define a total computable function $g:\\Sigma^{*}\\to\\Sigma^{*}$ by\n$$\ng(w)=\n\\begin{cases}\n0s & \\text{if } w=1s \\text{ for some } s \\in \\Sigma^{*},\\\\\n1 & \\text{otherwise.}\n\\end{cases}\n$$\nThis $g$ is computable by the same reasoning. For correctness, consider any $w \\in \\Sigma^{*}$:\n- If $w=1s$, then\n$$\nw \\in L_{U}^{1} \\iff s \\in U \\iff 0s \\in L_{U}^{0} \\iff g(w) \\in L_{U}^{0}.\n$$\n- If $w$ is not of the form $1s$, then $w \\notin L_{U}^{1}$, and $g(w)=1 \\notin L_{U}^{0}$ because every string in $L_{U}^{0}$ begins with $0$ while $1$ begins with $1$. Thus\n$$\nw \\in L_{U}^{1} \\iff g(w) \\in L_{U}^{0}\n$$\nholds (both sides are false). Therefore (II) is true.\n\nFor (III) $L_{U}^{0}=L_{U}^{1}$, observe that every string in $L_{U}^{0}$ begins with $0$ and every string in $L_{U}^{1}$ begins with $1$. Since $U \\neq \\varnothing$, there exists $s \\in U$, hence $0s \\in L_{U}^{0}$ but $0s \\notin L_{U}^{1}$. Therefore $L_{U}^{0} \\neq L_{U}^{1}$, so (III) is false.\n\nFor (IV), antisymmetry would require that for all languages $A,B$, if $A \\le_{m} B$ and $B \\le_{m} A$, then $A=B$. However, taking $A=L_{U}^{0}$ and $B=L_{U}^{1}$, we have established $A \\le_{m} B$ and $B \\le_{m} A$, yet $A \\neq B$. Hence $\\le_{m}$ is not antisymmetric on the set of all languages, and (IV) is false.\n\nTherefore, the true statements are (I) and (II) only.", "answer": "$$\\boxed{B}$$", "id": "1349294"}, {"introduction": "While many-one and Turing reducibilities are related, they are not interchangeable, and understanding their differences is crucial for a nuanced view of undecidability. This exercise provides a concrete setting to explore this distinction by examining two cornerstones of computability theory: the Halting Problem ($A_{TM}$) and the Emptiness Problem ($EMPTY_{TM}$). You will construct reductions to show why these problems are equivalent under the more powerful Turing reducibility, yet provably distinct under the stricter constraints of many-one reducibility [@problem_id:1457107].", "problem": "In the theory of computation, we analyze the limits of what can be solved by algorithms. Central to this are undecidable problems, for which no algorithm can provide a correct yes-or-no answer for all inputs. Two fundamental undecidable problems are the Halting Problem and the Emptiness Problem for Turing Machines.\n\nLet a Turing Machine (TM) be denoted by $M$, and its encoding as a string be $\\langle M \\rangle$. The language accepted by $M$, denoted $L(M)$, is the set of all input strings that cause $M$ to halt in an accepting state.\n\nThe Halting Problem is the language $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM that halts on input string } w \\}$.\nThe Emptiness Problem is the language $EMPTY_{TM} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM and } L(M) = \\emptyset \\}$.\n\nA language $L_1$ is Turing-reducible to a language $L_2$, written $L_1 \\le_T L_2$, if one can decide $L_1$ using an oracle (a black-box solver) for $L_2$.\nA language $L_1$ is many-one reducible to a language $L_2$, written $L_1 \\le_m L_2$, if there is a computable function $f$ such that for any string $x$, $x \\in L_1$ if and only if $f(x) \\in L_2$.\n\nConsider the following statements about the relationship between these languages and their complements, where $\\overline{L}$ denotes the complement of a language $L$. A language is called recognizable if there is a TM that halts and accepts every string in the language, and either rejects or loops on strings not in the language.\n\nWhich of the following statements are true?\n\nA. $EMPTY_{TM}$ is Turing-reducible to $A_{TM}$.\n\nB. $EMPTY_{TM}$ is many-one reducible to $A_{TM}$.\n\nC. The complement of the Emptiness Problem, $\\overline{EMPTY_{TM}}$, is a recognizable language.\n\nD. The complement of the Halting Problem, $\\overline{A_{TM}}$, is a recognizable language.\n\nE. $A_{TM}$ is Turing-reducible to $EMPTY_{TM}$.", "solution": "We analyze each statement using standard constructions and definitions.\n\nFirst, recall the definitions:\n- $A_{TM} = \\{\\langle M,w\\rangle \\mid M \\text{ halts on input } w\\}$.\n- $EMPTY_{TM} = \\{\\langle M\\rangle \\mid L(M) = \\emptyset\\}$.\n- A language is recognizable if some TM halts and accepts exactly the strings in the language.\n\nA. $EMPTY_{TM} \\le_{T} A_{TM}$.\nConstruct, for any given $\\langle M\\rangle$, a TM $N_{M}$ that ignores its input $d$ and operates as follows: dovetail over all strings $x$ and simulate $M(x)$ step by step; if any simulation reaches an accepting state, then $N_{M}$ halts (and, say, accepts) on $d$. Then\n$$\n\\langle M\\rangle \\in \\overline{EMPTY_{TM}} \\iff \\langle N_{M}, d\\rangle \\in A_{TM},\n$$\nhence\n$$\n\\langle M\\rangle \\in EMPTY_{TM} \\iff \\langle N_{M}, d\\rangle \\notin A_{TM}.\n$$\nWith one query to the $A_{TM}$ oracle on $\\langle N_{M},d\\rangle$ and negating the answer, we decide $EMPTY_{TM}$, proving $EMPTY_{TM} \\le_{T} A_{TM}$. Thus A is true.\n\nB. $EMPTY_{TM} \\le_{m} A_{TM}$.\nSuppose, for contradiction, that there is a computable $f$ with\n$$\n\\langle M\\rangle \\in EMPTY_{TM} \\iff f(\\langle M\\rangle) \\in A_{TM}.\n$$\nSince $A_{TM}$ is recognizable, composing a recognizer for $A_{TM}$ with $f$ would recognize $EMPTY_{TM}$. But $EMPTY_{TM}$ is not recognizable (by Rice’s theorem or standard results on TM properties), yielding a contradiction. Therefore B is false.\n\nC. $\\overline{EMPTY_{TM}}$ is recognizable.\nWe have\n$$\n\\langle M\\rangle \\in \\overline{EMPTY_{TM}} \\iff \\exists x\\,\\exists t\\ \\big[M \\text{ accepts } x \\text{ within } t \\text{ steps}\\big].\n$$\nA recognizer can dovetail over all pairs $(x,t)$, simulate $M(x)$ for $t$ steps, and accept if an accepting computation is found. Hence $\\overline{EMPTY_{TM}}$ is recognizable. Thus C is true.\n\nD. $\\overline{A_{TM}}$ is recognizable.\nSince $A_{TM}$ is recognizable and undecidable, if $\\overline{A_{TM}}$ were also recognizable, then $A_{TM}$ would be decidable by dovetailing both recognizers, which is impossible. Therefore $\\overline{A_{TM}}$ is not recognizable, and D is false.\n\nE. $A_{TM} \\le_{T} EMPTY_{TM}$.\nGiven $\\langle M,w\\rangle$, build a TM $N_{M,w}$ that on any input $y$ simulates $M(w)$; if $M(w)$ halts, then $N_{M,w}$ immediately accepts $y$; otherwise it loops forever. Then\n$$\n\\langle M,w\\rangle \\in A_{TM} \\iff L(N_{M,w}) = \\Sigma^{*} \\iff \\langle N_{M,w}\\rangle \\notin EMPTY_{TM}.\n$$\nThus $A_{TM} \\le_{m} \\overline{EMPTY_{TM}}$, which implies $A_{TM} \\le_{T} EMPTY_{TM}$. Hence E is true.\n\nCollecting the truths: A, C, and E are true; B and D are false.", "answer": "$$\\boxed{ACE}$$", "id": "1457107"}]}