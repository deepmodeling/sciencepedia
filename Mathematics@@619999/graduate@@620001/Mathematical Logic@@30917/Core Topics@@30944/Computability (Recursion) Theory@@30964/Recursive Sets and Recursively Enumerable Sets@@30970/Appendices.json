{"hands_on_practices": [{"introduction": "The relationship between computation and formal logic is a cornerstone of computability theory. This exercise provides a foundational practice in arithmetization, the process of representing computational concepts using formulas in first-order arithmetic. By formalizing the quintessential undecidable problem—the Halting Problem—you will directly see how the property of being recursively enumerable corresponds to a specific logical structure, a $\\Sigma_1$ formula, and why its complement is fundamentally different [@problem_id:2986081]. This hands-on construction is key to understanding the basis of the arithmetical hierarchy.", "problem": "Let $N$ denote the set of natural numbers and work in the language of first-order arithmetic with symbols for $0$, successor, addition, and multiplication. Fix any effective Gödel coding of deterministic Turing machines such that each machine and configuration is represented by a number in $N$. Assume the following foundational facts of computability theory and arithmetization, which you may use without proof:\n\n- There is a primitive recursive relation $R(e,x,t,y)$ that holds exactly when $y$ is the code of the complete computation history (for example, a finite tableau or sequence of configurations) of the machine coded by $e$ on input $x$ for exactly $t$ steps, and this history is correct with respect to the machine’s transition function.\n- There is a primitive recursive relation $H_{\\mathrm{fin}}(e,x,t,y)$ that holds exactly when $R(e,x,t,y)$ holds and the last configuration coded within $y$ is halting (i.e., the machine has entered a designated halting state by time $t$).\n- A formula whose matrix is a primitive recursive relation and whose quantifiers range over $N$ can be put into prenex normal form; its level in the arithmetical hierarchy is determined by the pattern of leading unbounded quantifiers: a $\\Sigma_{n}$-formula has a leading block of existential quantifiers followed by $n-1$ alternations, and a $\\Pi_{n}$-formula has a leading block of universal quantifiers followed by $n-1$ alternations, all with a decidable (primitive recursive) matrix.\n\nUsing only these bases:\n\n1. Construct a first-order formula of arithmetic $H(e,x)$ that expresses “the machine coded by $e$ halts on input $x$,” using $R$ and $H_{\\mathrm{fin}}$ as your decidable matrix. Place your formula into prenex normal form and explicitly state its leading quantifier block and matrix.\n\n2. Construct a first-order formula of arithmetic $NH(e,x)$ that expresses “the machine coded by $e$ does not halt on input $x$,” again using only quantification over $N$ and a decidable matrix built from $R$ and $H_{\\mathrm{fin}}$. Place your formula into prenex normal form and explicitly state its leading quantifier block and matrix.\n\n3. For each of $H(e,x)$ and $NH(e,x)$, determine the minimal arithmetical hierarchy level $L(\\cdot)$, defined as follows: if a formula is equivalent (over the standard model of arithmetic) to a $\\Sigma_{n}$-formula with no fewer than $n$ alternations, take $L$ to be $n$; if it is equivalent to a $\\Pi_{n}$-formula with no fewer than $n$ alternations, take $L$ to be $n$. Justify your classification by analyzing the quantifier structure and the decidability of the matrix.\n\n4. Compute the exact integer value of $L(H)+L(NH)$. Report your final answer as an exact integer. No rounding is required.", "solution": "The problem requires the construction and classification of first-order arithmetic formulas for the halting problem and its complement, based on provided primitive recursive relations.\n\n**Problem Validation**\n\nA validation of the problem statement is performed first.\n\n*   **Step 1: Extract Givens**\n    *   Domain of discourse: The set of natural numbers, $N$.\n    *   Language: First-order arithmetic with symbols for $0$, successor, addition, and multiplication.\n    *   Gödel Coding: An effective coding scheme maps Turing machines and their configurations to numbers in $N$.\n    *   Primitive Recursive Relation $R(e,x,t,y)$: Holds iff $y$ is the code for the correct computation history of machine $e$ on input $x$ for exactly $t$ steps.\n    *   Primitive Recursive Relation $H_{\\mathrm{fin}}(e,x,t,y)$: Holds iff $R(e,x,t,y)$ is true and the computation is in a halting state at step $t$.\n    *   Arithmetical Hierarchy Definitions: A formula is $\\Sigma_n$ if it has a leading block of existential quantifiers and $n-1$ quantifier alternations over a decidable matrix. A formula is $\\Pi_n$ if it has a leading block of universal quantifiers and $n-1$ quantifier alternations over a decidable matrix.\n    *   Level $L(\\cdot)$: The minimal $n \\in N, n \\ge 1$ such that a formula is equivalent to a $\\Sigma_n$ or $\\Pi_n$ formula.\n\n*   **Step 2: Validate Using Extracted Givens**\n    The problem is a standard exercise in computability theory and mathematical logic. It is scientifically grounded in the formalization of computation (Church-Turing thesis) and its relationship to formal arithmetic (as established by Gödel, Kleene, and others). All terms are precisely defined, and the premises are standard results in the field. The problem is well-posed, objective, and self-contained, with no apparent logical contradictions, ambiguities, or factual unsoundness.\n\n*   **Step 3: Verdict and Action**\n    The problem is deemed valid. A full solution is warranted.\n\n**Part 1: Construction of the Formula $H(e,x)$**\n\nThe assertion \"the machine coded by $e$ halts on input $x$\" is true if there exists a time $t \\in N$ and a corresponding computation history $y \\in N$ that represents a valid, halting computation. The predicate $H_{\\mathrm{fin}}(e,x,t,y)$ captures this for a specific time $t$ and history $y$. To express that a halt occurs at *some* time, we existentially quantify over $t$ and $y$.\n\nThe formula $H(e,x)$ is therefore:\n$$H(e,x) \\equiv \\exists t \\exists y \\, H_{\\mathrm{fin}}(e,x,t,y)$$\nThis formula is in prenex normal form.\n*   **Leading Quantifier Block:** $\\exists t \\exists y$. This is a single block of existential quantifiers.\n*   **Matrix:** $H_{\\mathrm{fin}}(e,x,t,y)$. The problem states that this relation is primitive recursive. A primitive recursive relation is, by definition, decidable by a Turing machine. Thus, the matrix is decidable.\n\n**Part 2: Construction of the Formula $NH(e,x)$**\n\nThe assertion \"the machine coded by $e$ does not halt on input $x$\" is the logical negation of $H(e,x)$.\n$$NH(e,x) \\equiv \\neg H(e,x)$$\nWe substitute the expression for $H(e,x)$ and convert the resulting formula to prenex normal form by applying quantifier duality rules ($\\neg \\exists z P(z) \\equiv \\forall z \\neg P(z)$).\n$$NH(e,x) \\equiv \\neg (\\exists t \\exists y \\, H_{\\mathrm{fin}}(e,x,t,y))$$\n$$\\equiv \\forall t \\, \\neg (\\exists y \\, H_{\\mathrm{fin}}(e,x,t,y))$$\n$$\\equiv \\forall t \\forall y \\, \\neg H_{\\mathrm{fin}}(e,x,t,y)$$\nThe formula $NH(e,x)$ in prenex normal form is:\n$$NH(e,x) \\equiv \\forall t \\forall y \\, \\neg H_{\\mathrm{fin}}(e,x,t,y)$$\n*   **Leading Quantifier Block:** $\\forall t \\forall y$. This is a single block of universal quantifiers.\n*   **Matrix:** $\\neg H_{\\mathrm{fin}}(e,x,t,y)$. Since $H_{\\mathrm{fin}}$ is a decidable relation, its negation $\\neg H_{\\mathrm{fin}}$ is also decidable.\n\n**Part 3: Arithmetical Hierarchy Classification**\n\nWe determine the minimal level $L(\\cdot)$ for each formula.\n\n**Classification of $H(e,x)$:**\nThe formula $H(e,x)$ has a leading block of existential quantifiers and a decidable matrix. This structure corresponds to a $\\Sigma_1$-formula. The set of pairs $(e,x)$ satisfying $H(e,x)$ is the halting set, which is known to be undecidable. A set is decidable if and only if it is definable by a $\\Delta_1$ formula (equivalent to both a $\\Sigma_1$ and a $\\Pi_1$ formula), which in turn is equivalent to having a quantifier-free definition (a $\\Sigma_0$ or $\\Pi_0$ formula over a decidable language). Since the halting set is undecidable, it cannot be defined by a $\\Sigma_0$ formula. Therefore, its minimal classification is $\\Sigma_1$.\nThis means $L(H) = 1$.\n\n**Classification of $NH(e,x)$:**\nThe formula $NH(e,x)$ has a leading block of universal quantifiers and a decidable matrix. This structure corresponds to a $\\Pi_1$-formula. The set of pairs $(e,x)$ satisfying $NH(e,x)$ is the complement of the halting set.\n1.  This set is not decidable, because if it were, its complement (the halting set) would also be decidable, which is a known falsehood. Thus, it cannot be a $\\Sigma_0$ or $\\Pi_0$ set.\n2.  We must also show it is not a $\\Sigma_1$ set. A set is definable by a $\\Sigma_1$ formula if and only if it is recursively enumerable. The halting set (defined by $H(e,x)$) is a $\\Sigma_1$-set, so it is recursively enumerable. By Post's theorem, a set is decidable (recursive) if and only if both the set and its complement are recursively enumerable. If the complement of the halting set were also recursively enumerable (i.e., $\\Sigma_1$), then the halting set would be decidable. This is a contradiction.\nTherefore, the set defined by $NH(e,x)$ is not $\\Sigma_1$. Its simplest classification is $\\Pi_1$.\nThis means $L(NH) = 1$.\n\n**Part 4: Final Calculation**\n\nThe problem asks for the value of $L(H) + L(NH)$. Using the results from Part 3:\n$$L(H) = 1$$\n$$L(NH) = 1$$\nThe sum is:\n$$L(H) + L(NH) = 1 + 1 = 2$$", "answer": "$$\\boxed{2}$$", "id": "2986081"}, {"introduction": "Understanding the algebraic properties of a class of sets is crucial for working with them effectively. Whereas recursive sets are closed under all Boolean operations, recursively enumerable (r.e.) sets are not, a fact with profound implications. This exercise [@problem_id:1399650] challenges you to explore the nuances of these closure properties, specifically by investigating the conditions under which the difference of two r.e. sets remains r.e. Successfully navigating these scenarios deepens your intuition for the computational nature of these fundamental objects.", "problem": "In computability theory, a set of natural numbers is called **recursively enumerable (r.e.)** if there exists a Turing machine that halts on input $n$ if and only if $n$ is a member of the set. A set is called **recursive** if there exists a Turing machine that halts on every input, accepting inputs that are in the set and rejecting inputs that are not. Every recursive set is r.e., but there exist r.e. sets that are not recursive.\n\nLet $A$ and $B$ be two distinct, non-recursive, recursively enumerable sets of natural numbers. The set difference $A \\setminus B$ is not guaranteed to be recursively enumerable. Which of the following additional conditions, if true, would guarantee that the set difference $A \\setminus B$ is also a recursively enumerable set? Select all that apply.\n\nA. $A \\subseteq B$\n\nB. $B \\subseteq A$\n\nC. $A \\cap B = \\emptyset$\n\nD. $A \\cap B$ is a recursive set.\n\nE. $A \\cup B$ is a recursive set.", "solution": "We recall the definitions and basic closure properties. A set $S \\subseteq \\mathbb{N}$ is recursively enumerable (r.e.) if there exists a Turing machine that halts on input $n$ if and only if $n \\in S$. If $R$ is recursive, then both $R$ and its complement $R^{c}$ are recursive. The r.e. sets are closed under union and under intersection, and are also closed under intersection with recursive sets. In general, if $X$ is r.e. and $Y$ is r.e., then $X \\setminus Y = X \\cap Y^{c}$ need not be r.e. because $Y^{c}$ need not be r.e.\n\nWe analyze each option using the identity\n$$\nA \\setminus B \\;=\\; A \\cap B^{c}.\n$$\n\nOption A: $A \\subseteq B$. Then\n$$\nA \\setminus B \\;=\\; \\emptyset,\n$$\nand $\\emptyset$ is recursive and hence r.e. Therefore, under this condition, $A \\setminus B$ is r.e. So A is sufficient.\n\nOption B: $B \\subseteq A$. Then\n$$\nA \\setminus B \\;=\\; A \\cap B^{c}.\n$$\nHere $B$ is r.e. and non-recursive, so $B^{c}$ is co-r.e. and not necessarily r.e. The class of r.e. sets is not closed under intersection with co-r.e. sets, hence there is no general guarantee that $A \\setminus B$ is r.e. Therefore B is not sufficient.\n\nOption C: $A \\cap B = \\emptyset$. Then\n$$\nA \\setminus B \\;=\\; A,\n$$\nwhich is r.e. by assumption. Therefore C is sufficient.\n\nOption D: $A \\cap B$ is recursive. Using\n$$\nA \\setminus B \\;=\\; A \\setminus (A \\cap B),\n$$\nand writing this as\n$$\nA \\setminus (A \\cap B) \\;=\\; A \\cap (A \\cap B)^{c},\n$$\nwe see that $(A \\cap B)^{c}$ is recursive (the complement of a recursive set), and the intersection of an r.e. set with a recursive set is r.e. Hence $A \\setminus B$ is r.e. Therefore D is sufficient.\n\nOption E: $A \\cup B$ is recursive. We can write\n$$\nA \\setminus B \\;=\\; (A \\cup B) \\setminus B.\n$$\nEven when $(A \\cup B)$ is recursive and $B$ is r.e. and non-recursive, the difference of a recursive set and an r.e. set need not be r.e. (it is, in general, only co-r.e.). Therefore there is no general guarantee that $A \\setminus B$ is r.e. under this condition. Thus E is not sufficient.\n\nCombining the above, the conditions that guarantee $A \\setminus B$ is r.e. are A, C, and D.", "answer": "$$\\boxed{ACD}$$", "id": "1399650"}, {"introduction": "Beyond the properties of individual sets, computability theory also investigates the global structure formed by all recursively enumerable (r.e.) sets under the partial order of set inclusion. This exercise invites you to explore this structure by constructing an infinite antichain—an infinite family of r.e. sets where no set is a subset of another [@problem_id:1357463]. This construction demonstrates a key feature of the r.e. lattice: its immense complexity and non-linear nature. Mastering this concept is a stepping stone to appreciating the intricate landscape of computability.", "problem": "A partially ordered set (poset) is a set $P$ together with a binary relation $\\le$ that is reflexive ($a \\le a$ for all $a \\in P$), antisymmetric (if $a \\le b$ and $b \\le a$, then $a = b$), and transitive (if $a \\le b$ and $b \\le c$, then $a \\le c$). In this problem, the set $P$ is the collection of all recursively enumerable subsets of the natural numbers $\\mathbb{N}=\\{0, 1, 2, \\dots\\}$, and the partial order relation is set inclusion, $\\subseteq$.\n\nTwo elements $a, b$ in a poset are called incomparable if neither $a \\le b$ nor $b \\le a$. An antichain is a subset of the poset in which any two distinct elements are incomparable. An infinite antichain is an antichain containing infinitely many elements.\n\nAll sets defined in the options below are recursively enumerable. Which of the following families of sets $\\{S_k\\}_{k \\in \\mathbb{N}}$ constitutes an infinite antichain with respect to the partial order of set inclusion?\n\nA. $S_k = \\{n \\in \\mathbb{N} \\mid n > k\\}$, for $k \\in \\mathbb{N}$.\n\nB. $S_k = \\{kn \\mid n \\in \\mathbb{N}, n \\ge 1\\}$, for $k \\in \\mathbb{N}$. We adopt the convention that $S_0 = \\emptyset$.\n\nC. $S_k = \\{n \\mid n \\in \\mathbb{N} \\text{ and } 0 < n \\le k\\}$, for $k \\in \\mathbb{N}$.\n\nD. $S_k = \\{2k\\} \\cup \\{2n+1 \\mid n \\in \\mathbb{N} \\text{ and } n > k\\}$, for $k \\in \\mathbb{N}$.\n\nE. $S_k = \\{n^k \\mid n \\in \\mathbb{N}, n \\ge 2\\}$, for $k \\in \\mathbb{N}$. We adopt the convention that $n^0 = 1$ for all $n$.", "solution": "We need a family $\\{S_{k}\\}_{k \\in \\mathbb{N}}$ such that for all distinct $k,\\ell$, neither $S_{k} \\subseteq S_{\\ell}$ nor $S_{\\ell} \\subseteq S_{k}$, i.e., an infinite antichain under $\\subseteq$.\n\nOption A: $S_{k}=\\{n \\in \\mathbb{N} \\mid n>k\\}$. If $k<\\ell$, then for every $n \\in S_{\\ell}$ we have $n>\\ell>k$, so $S_{\\ell} \\subseteq S_{k}$, and the inclusion is strict because $\\ell+1 \\in S_{k}$ but $\\ell+1 \\notin S_{\\ell}$. Hence $\\{S_{k}\\}$ is a descending chain, not an antichain.\n\nOption B: $S_{k}=\\{kn \\mid n \\in \\mathbb{N}, n \\ge 1\\}$ with $S_{0}=\\emptyset$. For $a,b \\in \\mathbb{N}$,\n$$\nS_{a} \\subseteq S_{b} \\iff \\text{every multiple of } a \\text{ is a multiple of } b \\iff b \\mid a.\n$$\nProof: If $b \\mid a$ then $a=bm$ and any $an$ equals $b(mn)$, so $S_{a} \\subseteq S_{b}$. Conversely, if $S_{a} \\subseteq S_{b}$, then $a \\in S_{a}$ implies $a \\in S_{b}$, hence $b \\mid a$. Therefore many pairs are comparable, for instance $2 \\mid 4$ gives $S_{4} \\subseteq S_{2}$, and $S_{0}=\\emptyset$ is contained in all $S_{k}$. This family is not an antichain.\n\nOption C: $S_{k}=\\{n \\mid 0<n \\le k\\}$. If $k<\\ell$, then $S_{k} \\subset S_{\\ell}$. Thus this is an ascending chain, not an antichain.\n\nOption D: $S_{k}=\\{2k\\} \\cup \\{2n+1 \\mid n \\in \\mathbb{N}, n>k\\}$. Fix distinct $k,\\ell$ and assume without loss of generality $k<\\ell$. Then:\n- $2\\ell \\in S_{\\ell}$ but $2\\ell \\notin S_{k}$, since the even part of $S_{k}$ is exactly $\\{2k\\}$ and $2\\ell \\neq 2k$. Hence $S_{\\ell} \\nsubseteq S_{k}$.\n- Also $2k+3 \\in S_{k}$ because it is the odd number with $n=k+1>k$. But $2k+3 \\notin S_{\\ell}$, since the odd part of $S_{\\ell}$ is $\\{2n+1 \\mid n>\\ell\\}$, i.e., all odd integers strictly greater than $2\\ell+1$, and for $k<\\ell$ we have $2k+3 \\le 2\\ell+1$, so $2k+3$ is not in that odd tail, nor is it equal to the even element $2\\ell$. Hence $S_{k} \\nsubseteq S_{\\ell}$.\nTherefore $S_{k}$ and $S_{\\ell}$ are incomparable for all $k \\neq \\ell$, and the family is an infinite antichain.\n\nOption E: $S_{k}=\\{n^{k} \\mid n \\ge 2\\}$. Note $S_{1}=\\{n \\in \\mathbb{N} \\mid n \\ge 2\\}$, so for every $k \\ge 2$, $S_{k} \\subseteq S_{1}$, making the family not an antichain. More generally, if $a \\mid b$ then every $b$th power is an $a$th power, so $S_{b} \\subseteq S_{a}$, giving further comparabilities.\n\nOnly Option D yields an infinite antichain.", "answer": "$$\\boxed{D}$$", "id": "1357463"}]}