{"hands_on_practices": [{"introduction": "This first exercise provides a concrete entry point into the mechanics of cut-elimination. By manually transforming a proof that uses the `cut` rule into an equivalent cut-free proof [@problem_id:484256], you will directly observe the central algorithm at work. This practice demystifies the procedure, showing how a single `cut` on a compound formula is pushed upwards and replaced by cuts on its simpler constituents, illustrating the constructive heart of Gentzen's Hauptsatz in the familiar setting of propositional logic.", "problem": "In the context of propositional logic using the sequent calculus, we define sequents, axioms, and rules of inference as follows.\n\nA sequent is an expression of the form $\\Gamma \\vdash \\Delta$, where $\\Gamma$ (the antecedent) and $\\Delta$ (the succedent) are finite multisets of propositional formulas. Formulas are constructed using atomic propositions (e.g., $A, B, C$) and the implication connective ($\\to$).\n\nThe calculus consists of the following rules:\n\n1.  **Axiom (Identity)**: For any formula $A$, the sequent below is an axiom.\n    $$A \\vdash A$$\n\n2.  **Implication Right Rule**:\n    $$(\\rightarrow R): \\frac{A, \\Gamma \\vdash B, \\Delta}{\\Gamma \\vdash A \\to B, \\Delta}$$\n\n3.  **Implication Left Rule**: This is the multiplicative version.\n    $$(\\rightarrow L): \\frac{\\Gamma \\vdash A, \\Delta \\quad \\Pi, B \\vdash \\Sigma}{\\Gamma, \\Pi, A \\to B \\vdash \\Delta, \\Sigma}$$\n\n4.  **Cut Rule**:\n    $$(Cut): \\frac{\\Gamma \\vdash A, \\Delta \\quad A, \\Pi \\vdash \\Sigma}{\\Gamma, \\Pi \\vdash \\Delta, \\Sigma}$$\n\nA proof tree is a tree of sequents where each leaf is an instance of the Axiom (Identity) rule, and every non-leaf node (an inference) is a conclusion derived from its children (the premises) by one of the rules. An \"axiom leaf\" is a leaf of a proof tree.\n\nConsider the following proof tree $\\mathcal{D}$ for the sequent $\\vdash (A \\to B) \\to ((B \\to C) \\to (A \\to C))$, which represents the transitivity of implication.\n\n$$\n\\mathcal{D} =\n\\frac{\n  \\frac{\n    \\frac{\n      \\frac{A \\vdash A \\quad B \\vdash B}{A, A \\to B \\vdash B} (\\rightarrow L) \\quad \\frac{B \\vdash B \\quad C \\vdash C}{B, B \\to C \\vdash C} (\\rightarrow L)\n    }{A, A \\to B, B \\to C \\vdash C} (Cut)\n  }{A \\to B, B \\to C \\vdash A \\to C} (\\rightarrow R)\n}{(A \\to B) \\vdash (B \\to C) \\to (A \\to C)} (\\rightarrow R)\n}{\\vdash (A \\to B) \\to ((B \\to C) \\to (A \\to C))} (\\rightarrow R)\n$$\n\nThis proof contains a single application of the $(Cut)$ rule with the cut formula $B$. The cut-elimination procedure is a central result in proof theory that shows how to transform any proof containing cuts into a cut-free proof of the same end-sequent.\n\nApply the standard cut-elimination algorithm to the single $(Cut)$ inference in the proof $\\mathcal{D}$. This procedure will yield a new, cut-free proof tree $\\mathcal{D}'$. Your task is to determine the total number of axiom leaves in this resulting proof tree $\\mathcal{D}'$.", "solution": "We eliminate the single $(Cut)$ on $B$ in the derivation of \n$$\\vdash (A\\to B)\\to((B\\to C)\\to(A\\to C)).$$\nThe critical subproof was\n$$A,\\,A\\to B,\\,B\\to C\\;\\vdash\\;C$$\nobtained by cutting on $B$.  We replace it by a cut-free derivation:\n\n1. Identity axioms for atomic formulas:\n   $$A\\;\\vdash\\;A\n   \\quad\n   B\\;\\vdash\\;B\n   \\quad\n   C\\;\\vdash\\;C.$$\n\n2. Apply $(\\to L)$ to $B\\to C$:\n   $$\\frac{B\\vdash B\\quad C\\vdash C}\n         {B,\\,B\\to C\\;\\vdash\\;C}\n     \\;(\\to L).$$\n\n3. Apply $(\\to L)$ to $A\\to B$:\n   $$\\frac{A\\vdash A\\quad B,\\,B\\to C\\vdash C}\n         {A,\\,B\\to C,\\,A\\to B\\;\\vdash\\;C}\n     \\;(\\to L).$$\n\n4. Rebuild the right-implication introductions:\n   $$\\frac{A,\\,B\\to C,\\,A\\to B\\vdash C}\n         {B\\to C,\\,A\\to B\\vdash A\\to C}\n     \\;(\\to R),$$\n   $$\\frac{B\\to C,\\,A\\to B\\vdash A\\to C}\n         {A\\to B\\;\\vdash\\;(B\\to C)\\to(A\\to C)}\n     \\;(\\to R),$$\n   $$\\frac{A\\to B\\vdash(B\\to C)\\to(A\\to C)}\n         {\\vdash(A\\to B)\\to((B\\to C)\\to(A\\to C))}\n     \\;(\\to R).$$\n\nThis cut-free proof has exactly three axiom leaves.", "answer": "$$\\boxed{3}$$", "id": "484256"}, {"introduction": "Building on the propositional case, this practice extends the reduction procedure to the more complex domain of first-order logic [@problem_id:2979668]. The primary challenge here lies in handling quantifiers, which requires a delicate treatment of variables and substitutions. This exercise focuses on a crucial \"principal case\" for the universal quantifier, forcing you to carefully manage eigenvariables to ensure the validity of the transformation, a key technical skill for understanding the full power of the cut-elimination theorem.", "problem": "Consider Gentzen's sequent calculus for classical first-order logic (LK) with the usual structural rules and the quantifier rules for the universal quantifier. The universal quantifier rules are:\n$$\n\\frac{\\Gamma \\vdash \\Delta, A(y)}{\\Gamma \\vdash \\Delta, \\forall x\\,A(x)}\\;(\\forall\\text{-}R)\n$$\nwith the eigenvariable condition that $y$ is not free in $\\Gamma$ or $\\Delta$.\n$$\n\\frac{\\Pi, A(t) \\vdash \\Lambda}{\\Pi, \\forall x\\,A(x) \\vdash \\Lambda}\\;(\\forall\\text{-}L)\n$$\nfor any term $t$. The cut rule is:\n$$\n\\frac{\\Gamma \\vdash \\Delta, \\varphi \\quad\\quad \\Pi, \\varphi \\vdash \\Lambda}{\\Gamma, \\Pi \\vdash \\Delta, \\Lambda}\\;(\\mathrm{cut})\n$$\n\nWork in a first-order language with a constant symbol $a$, a unary function symbol $f$, and unary predicate symbols $P$ and $Q$. Let $A(x)$ be the formula $P(x) \\rightarrow Q(f(x))$. Suppose you have a derivation of the following shape in which the formula $\\forall x\\,A(x)$ is cut:\n$$\n\\frac{\n  \\frac{\\Gamma \\vdash \\Delta, A(y)}{\\Gamma \\vdash \\Delta, \\forall x\\,A(x)}\\;(\\forall\\text{-}R)\n  \\quad\\quad\n  \\frac{\\Pi, A(f(a)) \\vdash \\Lambda}{\\Pi, \\forall x\\,A(x) \\vdash \\Lambda}\\;(\\forall\\text{-}L)\n}{\\Gamma, \\Pi \\vdash \\Delta, \\Lambda}\\;(\\mathrm{cut})\n}\n$$\nwhere the subproof for the left premise of the cut derives $\\Gamma \\vdash \\Delta, A(y)$ and the subproof for the right premise derives $\\Pi, A(f(a)) \\vdash \\Lambda$. The variable $y$ is an eigenvariable for the $\\forall$-right inference.\n\nStarting from the fundamental definitions of the LK rules above, perform a detailed cut-reduction eliminating the cut on $\\forall x\\,A(x)$ by producing a cut on the instance $A(f(a))$. In your reduction, you must explicitly show how the eigenvariable condition is preserved, including any renaming of $y$ and the subsequent capture-avoiding substitution needed to align the cut formula instances.\n\nFor the purpose of quantifying the complexity of the cut, define the rank $\\mathrm{rk}(\\cdot)$ of formulas inductively by:\n- $\\mathrm{rk}(P(t)) = 0$ and $\\mathrm{rk}(Q(t)) = 0$ for any term $t$ (atomic formulas have rank $0$),\n- $\\mathrm{rk}(B \\rightarrow C) = \\max\\{\\mathrm{rk}(B), \\mathrm{rk}(C)\\} + 1$,\n- $\\mathrm{rk}(\\forall x\\,B) = \\mathrm{rk}(B) + 1$.\n\nAfter your cut-reduction is complete, determine the rank of the new cut formula $A(f(a))$ according to the above definition. Your final answer must be the single numerical value of this rank. No rounding is required.", "solution": "The problem presents a specific instance of a cut in Gentzen's sequent calculus LK and asks for the application of the cut-reduction procedure, followed by a calculation of the rank of the resulting cut formula. The problem is well-defined, scientifically grounded in proof theory, and contains all necessary information. We may therefore proceed with the solution.\n\nThe initial derivation to be transformed is:\n$$\n\\frac{\n  \\frac{\\Gamma \\vdash \\Delta, A(y)}{\\Gamma \\vdash \\Delta, \\forall x\\,A(x)}\\;(\\forall\\text{-}R)\n  \\quad\\quad\n  \\frac{\\Pi, A(f(a)) \\vdash \\Lambda}{\\Pi, \\forall x\\,A(x) \\vdash \\Lambda}\\;(\\forall\\text{-}L)\n}{\\Gamma, \\Pi \\vdash \\Delta, \\Lambda}\\;(\\mathrm{cut})\n}\n$$\nThe cut formula is $\\forall x\\,A(x)$. This configuration, where the cut formula is the principal formula of the inferences immediately preceding the cut on both sides, is known as a principal case. The goal of cut-reduction is to replace this cut with one or more cuts on formulas of lower complexity.\n\nThe left premise of the cut is derived using the rule for introducing a universal quantifier on the left side of a sequent, $(\\forall\\text{-}L)$, by instantiating the quantified variable $x$ with the term $f(a)$. The right premise is derived using the rule for introducing a universal quantifier on the right, $(\\forall\\text{-}R)$, using an eigenvariable $y$. The eigenvariable condition for the $(\\forall\\text{-}R)$ rule is that the variable $y$ must not appear free in the conclusion of the rule, which means $y$ is not a free variable in any formula in $\\Gamma$ or $\\Delta$.\n\nThe core of the cut-reduction step is to use the derivation of the right premise, let's call it $\\pi_R'$, to obtain a derivation of a sequent that can be cut directly with the premise of the $(\\forall\\text{-}L)$ rule.\nThe derivation $\\pi_R'$ proves the sequent $\\Gamma \\vdash \\Delta, A(y)$. Because $y$ is an eigenvariable for the $(\\forall\\text{-}R)$ inference, it does not have any free occurrences in $\\Gamma$ or $\\Delta$. This property is crucial as it allows us to substitute any term for the free occurrences of $y$ throughout the entire derivation $\\pi_R'$ without invalidating the derivation's structure or the formulas in $\\Gamma$ and $\\Delta$.\n\nWe perform a substitution of the term $f(a)$ (from the $(\\forall\\text{-}L)$ inference) for all free occurrences of the eigenvariable $y$ in the derivation $\\pi_R'$. Let's denote this substitution as $[f(a)/y]$. Applying this substitution to the derivation $\\pi_R'$ yields a new derivation, which we can call $\\pi_R'' = \\pi_R'[f(a)/y]$. The conclusion of this new derivation is the result of applying the substitution to the sequent $\\Gamma \\vdash \\Delta, A(y)$:\n$$\n(\\Gamma \\vdash \\Delta, A(y))[f(a)/y]\n$$\nSince $y$ is not free in $\\Gamma$ or $\\Delta$, this becomes:\n$$\n\\Gamma \\vdash \\Delta, A(y)[f(a)/y]\n$$\nThe formula $A(x)$ is given as $P(x) \\rightarrow Q(f(x))$. Therefore, $A(y)$ is $P(y) \\rightarrow Q(f(y))$. Applying the substitution to $A(y)$:\n$$\nA(y)[f(a)/y] = (P(y) \\rightarrow Q(f(y)))[f(a)/y] = P(f(a)) \\rightarrow Q(f(f(a)))\n$$\nThis resulting formula is precisely $A(f(a))$. Thus, the new derivation $\\pi_R''$ proves the sequent $\\Gamma \\vdash \\Delta, A(f(a))$.\n\nThe validity of this substitution process must be confirmed. A potential issue is variable capture, where a free variable in the term $t$ becomes bound by a quantifier in the formulas of the proof. In our case, the term being substituted is $f(a)$. This term contains no variables, only the constant symbol $a$ and the function symbol $f$. Consequently, no variable capture can occur. The problem also mentions renaming $y$. This would be necessary if the term $f(a)$ contained variables that could clash with eigenvariables used within the derivation $\\pi_R'$. As $f(a)$ is a ground term (variable-free), this is not an issue. The substitution is therefore valid and safe.\n\nWe now have two derivations:\n1. $\\pi_R''$, which proves $\\Gamma \\vdash \\Delta, A(f(a))$.\n2. $\\pi_L'$, which proves $\\Pi, A(f(a)) \\vdash \\Lambda$.\n\nThese two derivations can be combined using the cut rule, with $A(f(a))$ as the new cut formula:\n$$\n\\frac{\n  \\pi_R'': \\Gamma \\vdash \\Delta, A(f(a))\n  \\quad\\quad\n  \\pi_L': \\Pi, A(f(a)) \\vdash \\Lambda\n}\n{\\Gamma, \\Pi \\vdash \\Delta, \\Lambda}\\;(\\mathrm{cut})\n$$\nThis new derivation has the same conclusion, $\\Gamma, \\Pi \\vdash \\Delta, \\Lambda$, as the original one, but the cut is now on the formula $A(f(a))$ instead of $\\forall x\\,A(x)$. This constitutes the elimination of the original cut. The rank of the cut formula has been reduced, as $\\mathrm{rk}(A(f(a))) < \\mathrm{rk}(\\forall x\\,A(x))$.\n\nThe second part of the task is to calculate the rank of the new cut formula, $A(f(a))$, based on the provided definition.\nThe formula $A(f(a))$ is $P(f(a)) \\rightarrow Q(f(f(a)))$.\nThe rank function $\\mathrm{rk}(\\cdot)$ is defined as:\n- $\\mathrm{rk}(P(t)) = 0$ and $\\mathrm{rk}(Q(t)) = 0$ for any term $t$.\n- $\\mathrm{rk}(B \\rightarrow C) = \\max\\{\\mathrm{rk}(B), \\mathrm{rk}(C)\\} + 1$.\n- $\\mathrm{rk}(\\forall x\\,B) = \\mathrm{rk}(B) + 1$.\n\nLet's compute the rank of $A(f(a))$.\nThe formula has the structure $B \\rightarrow C$, where $B$ is $P(f(a))$ and $C$ is $Q(f(f(a)))$.\nFirst, we find the ranks of $B$ and $C$.\nThe formula $P(f(a))$ is atomic, as it is an application of a predicate symbol $P$ to a term $f(a)$. According to the definition, its rank is $0$:\n$$\n\\mathrm{rk}(P(f(a))) = 0\n$$\nThe formula $Q(f(f(a)))$ is also atomic, being an application of a predicate symbol $Q$ to a term $f(f(a))$. Its rank is also $0$:\n$$\n\\mathrm{rk}(Q(f(f(a)))) = 0\n$$\nNow, we use the rule for implication to find the rank of $A(f(a))$:\n$$\n\\mathrm{rk}(A(f(a))) = \\mathrm{rk}(P(f(a)) \\rightarrow Q(f(f(a)))) = \\max\\{\\mathrm{rk}(P(f(a))), \\mathrm{rk}(Q(f(f(a))))\\} + 1\n$$\nSubstituting the ranks of the atomic components:\n$$\n\\mathrm{rk}(A(f(a))) = \\max\\{0, 0\\} + 1 = 0 + 1 = 1\n$$\nThe rank of the new cut formula $A(f(a))$ is $1$.\nFor completeness, we can verify that this is a reduction in rank. The rank of the original cut formula $\\forall x\\,A(x)$ is $\\mathrm{rk}(A(x)) + 1$. The rank of $A(x) = P(x) \\rightarrow Q(f(x))$ is $\\max\\{\\mathrm{rk}(P(x)), \\mathrm{rk}(Q(f(x)))\\} + 1 = \\max\\{0,0\\} + 1 = 1$. Therefore, $\\mathrm{rk}(\\forall x\\,A(x)) = 1 + 1 = 2$. The rank has indeed been reduced from $2$ to $1$, which is the objective of the cut-reduction procedure.", "answer": "$$\\boxed{1}$$", "id": "2979668"}, {"introduction": "Our final practice confronts the most profound question of the cut-elimination theorem: how can we be certain the reduction process always terminates? This exercise guides you through a simulation of the termination proof, which lies at the foundation of ordinal analysis [@problem_id:2978413]. By assigning an ordinal measure to a proof and verifying that this measure strictly decreases after a reduction step, you will gain a computational understanding of the well-foundedness argument that guarantees any proof can ultimately be made cut-free, a truly foundational result in mathematical logic.", "problem": "You are asked to formalize a single-cut reduction step in the Gentzen-style sequent calculus for Peano Arithmetic (PA) and to verify the strict decrease of the assigned ordinal measure under this reduction. Work entirely within the well-founded ordinal notation system below the ordinal $\\varepsilon_{0}$, using Cantor Normal Form.\n\nThe fundamental base consists of:\n- Definitions of ordinal arithmetic below $\\varepsilon_{0}$ via Cantor Normal Form: every ordinal $\\alpha < \\varepsilon_{0}$ is uniquely written as\n$$ \\alpha = \\omega^{\\alpha_{1}} \\cdot c_{1} + \\omega^{\\alpha_{2}} \\cdot c_{2} + \\cdots + \\omega^{\\alpha_{k}} \\cdot c_{k} $$\nwith $k \\in \\mathbb{N}$, $c_{i} \\in \\mathbb{N}$, and $\\alpha_{1} \\geq \\alpha_{2} \\geq \\cdots \\geq \\alpha_{k}$, and each exponent $\\alpha_{i}$ is itself an ordinal below $\\varepsilon_{0}$.\n- The cut rule in the sequent calculus for PA and the notion of a single cut on a formula of rank $r \\in \\mathbb{N}$.\n- The requirement that ordinal measures assigned to proofs must strictly decrease under a cut-reduction step to ensure termination of cut elimination.\n\nTasks:\n1. Construct an explicit reduction procedure, denoted $\\mathrm{CutReduce}$, which transforms a proof containing a single cut on a formula of rank $r$ into a proof with either no cut at rank $r$ or cuts only at ranks strictly less than $r$. Your design should capture the combinatorial effect of duplicating subderivations on the measure but must ensure that the leading ordinal term associated to rank $r$ is removed or strictly reduced.\n2. Define an ordinal measure $\\mu(P)$ for such a proof $P$ of the form $$\\mu(P) = \\omega^{r} \\cdot h + \\sigma,$$ where $h \\in \\mathbb{N}$ reflects the combined heights of the left and right derivations whose cut is being reduced, and $\\sigma$ is a background ordinal strictly less than $\\omega^{r}$ capturing the contribution of lower-rank structure. Your assignment must be consistent with Cantor Normal Form and must map to ordinals below $\\varepsilon_{0}$.\n3. Prove that the reduction procedure $\\mathrm{CutReduce}$ strictly decreases the ordinal measure: $$\\mu\\bigl(\\mathrm{CutReduce}(P)\\bigr) < \\mu(P).$$\n\nImplementation requirements:\n- Represent ordinals below $\\varepsilon_{0}$ in Cantor Normal Form, with recursive exponents and positive integer coefficients. Use a data structure that enforces decreasing exponents and merges adjacent terms with equal exponents.\n- Implement comparison on ordinals in Cantor Normal Form that realizes the standard well-ordering: compare leading exponents lexicographically and, when equal, compare coefficients, proceeding to lower terms thereafter.\n- Implement the measure constructor $$\\mu(r, h_{L}, h_{R}, \\sigma) = \\omega^{r} \\cdot (h_{L} + h_{R}) + \\sigma,$$ with $\\sigma$ given in Cantor Normal Form and all its exponents strictly less than $r$. Here $h_{L}, h_{R} \\in \\mathbb{N}$.\n- Implement the reduction step $\\mathrm{CutReduce}$ that outputs a new measure $$\\mu'(r, h_{L}, h_{R}, \\sigma) = \\begin{cases}\n\\sigma & \\text{if } r = 0,\\\\\n\\omega^{r-1} \\cdot k + \\sigma & \\text{if } r \\geq 1,\n\\end{cases}$$ with $k \\in \\mathbb{N}$ determined by the combinatorics of duplicating subderivations. Choose a concrete $k$ that depends monotonically on $h_{L}$ and $h_{R}$ and is positive whenever the cut is nontrivial, for example $k = h_{L} \\cdot h_{R} + h_{L} + h_{R} + 1$.\n- Verify programmatically, for a small test suite, that the measure strictly decreases under this reduction.\n\nTest suite:\nFor each test case, the input is $(r, h_{L}, h_{R}, \\sigma)$, where $\\sigma$ is a list of pairs $(e_{i}, c_{i})$ encoding $\\omega^{e_{i}} \\cdot c_{i}$ with $e_{i} \\in \\mathbb{N}$ and $c_{i} \\in \\mathbb{N}$, sorted by decreasing $e_{i}$, and with $e_{i} < r$. The program must compute whether\n$$\\mu'(r, h_{L}, h_{R}, \\sigma) < \\mu(r, h_{L}, h_{R}, \\sigma)$$\nholds, returning a boolean for each case.\n\nUse the following test cases:\n- Case A (general case): $r = 3$, $h_{L} = 2$, $h_{R} = 3$; $\\sigma$ is represented by the list `[(2, 1), (1, 4)]`.\n- Case B (boundary case for smallest nontrivial rank): $r = 1$, $h_{L} = 1$, $h_{R} = 1$; $\\sigma$ is represented by the empty list `[]`.\n- Case C (higher rank, nontrivial background): $r = 5$, $h_{L} = 4$, $h_{R} = 1$; $\\sigma$ is represented by the list `[(3, 2), (2, 1), (1, 7)]`.\n- Case D (edge case with zero height on one side, finite tail): $r = 2$, $h_{L} = 0$, $h_{R} = 5$; $\\sigma$ is represented by the list `[(1, 1), (0, 10)]`.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is a boolean indicating whether the measure strictly decreases for the corresponding test case. No additional text should be printed.", "solution": "The problem is valid. It is a well-posed and scientifically grounded exercise in proof theory, a subfield of mathematical logic. It asks for the formalization and verification of a key step in Gentzen's cut-elimination proof for Peano Arithmetic, specifically demonstrating the decrease of an ordinal measure, which is the cornerstone of the termination argument for the procedure. All definitions and parameters are provided, and the problem is self-contained and objective.\n\nHere is the reasoned solution:\n\nThis problem concerns the ordinal analysis of proofs in a Gentzen-style sequent calculus for Peano Arithmetic ($PA$). The central result in this area is Gentzen's cut-elimination theorem, which states that any proof using the `cut` rule can be transformed into a cut-free proof of the same end-sequent. The proof of this theorem is constructive: it provides an explicit algorithm that systematically removes cuts. To prove that this algorithm terminates, one assigns an ordinal from a well-ordered set to each proof. Each step of the reduction algorithm must correspond to a strict decrease in this assigned ordinal. Since there are no infinite descending chains of ordinals, the process must terminate. For $PA$, the required set of ordinals is the segment below the ordinal $\\varepsilon_0$.\n\n**1. Ordinal Representation and Comparison**\n\nOrdinals below $\\varepsilon_0$ are represented using Cantor Normal Form (CNF). An ordinal $\\alpha < \\varepsilon_0$ has a unique representation as a finite sum:\n$$ \\alpha = \\omega^{\\alpha_1} \\cdot c_1 + \\omega^{\\alpha_2} \\cdot c_2 + \\dots + \\omega^{\\alpha_k} \\cdot c_k $$\nwhere $k$ is a non-negative integer, the coefficients $c_i$ are positive integers, and the exponents $\\alpha_i$ are themselves ordinals satisfying $\\alpha > \\alpha_1 \\geq \\alpha_2 \\geq \\dots \\geq \\alpha_k \\geq 0$.\n\nThe problem simplifies this general structure by specifying that all exponents ($r$ and the $e_i$ in $\\sigma$) are natural numbers, i.e., $r, e_i \\in \\mathbb{N}$. This restricts our focus to ordinals below $\\omega^\\omega$, which is a proper initial segment of the ordinals below $\\varepsilon_0$.\n\nOrdinal comparison is lexicographical. Given two ordinals in CNF,\n$$ \\alpha = \\omega^{a_1} \\cdot c_1 + \\omega^{a_2} \\cdot c_2 + \\dots $$\n$$ \\beta = \\omega^{b_1} \\cdot d_1 + \\omega^{b_2} \\cdot d_2 + \\dots $$\nwe say $\\beta < \\alpha$ if, at the first index $i$ where the terms differ, we have either $b_i < a_i$, or $b_i = a_i$ and $d_i < c_i$. If the sequence of terms for $\\beta$ is a proper prefix of the sequence for $\\alpha$, then $\\beta < \\alpha$.\n\n**2. Ordinal Measures for Proofs**\n\nThe problem defines an ordinal measure $\\mu(P)$ for a proof $P$ containing a specific cut. The cut is on a formula of logical complexity, or rank, $r \\in \\mathbb{N}$. The premises for the cut rule are derived by sub-proofs of heights $h_L, h_R \\in \\mathbb{N}$. The measure is:\n$$ \\mu(P) \\equiv \\mu(r, h_L, h_R, \\sigma) = \\omega^r \\cdot (h_L + h_R) + \\sigma $$\nHere, $\\sigma$ is an ordinal representing the complexity contribution from all other parts of the proof. A crucial condition is that all exponents in the CNF of $\\sigma$ are strictly less than $r$. This ensures that $\\omega^r \\cdot (h_L + h_R)$ is the leading term of $\\mu(P)$ whenever $h_L+h_R > 0$.\n\n**3. The Cut-Reduction Step**\n\nThe core of Gentzen's procedure is to reduce a cut on a formula of rank $r$ to one or more cuts on formulas of rank strictly less than $r$. The problem models the effect of this reduction, $\\mathrm{CutReduce}$, on the ordinal measure. The new measure, $\\mu'$, is given by:\n$$ \\mu'(r, h_L, h_R, \\sigma) = \\begin{cases} \\sigma & \\text{if } r = 0 \\\\ \\omega^{r-1} \\cdot k + \\sigma & \\text{if } r \\ge 1 \\end{cases} $$\nwhere $k = h_L \\cdot h_R + h_L + h_R + 1$. The integer $k$ combinatorially reflects the number and complexity of the new, lower-rank cuts that are introduced. When reducing a cut of rank $r \\ge 1$, the principal formula is broken down, and the sub-derivations are duplicated, leading to multiple cuts of rank $r-1$. The value of $k$ bounds the complexity of this new configuration.\n\n**4. Verification of Ordinal Decrease**\n\nWe must prove that $\\mu' < \\mu$. We analyze the two cases for $r$.\n\n**Case 1: $r \\ge 1$.**\nIn this case, the measures are:\n$$ \\mu = \\omega^r \\cdot (h_L + h_R) + \\sigma $$\n$$ \\mu' = \\omega^{r-1} \\cdot k + \\sigma $$\nA non-trivial cut implies that the derivations of its premises are not empty, meaning at least one of $h_L$ or $h_R$ is positive. All test cases satisfy $h_L+h_R > 0$. Under this condition, the coefficient $(h_L+h_R)$ of the $\\omega^r$ term in $\\mu$ is a positive integer.\n\nThe CNF of $\\mu$ is $\\mu = \\omega^r \\cdot (h_L + h_R) + (\\text{terms with exponents} < r)$. Its leading exponent is $r$.\nThe measure $\\mu'$ is the ordinal sum of $\\omega^{r-1} \\cdot k$ and $\\sigma$. The exponents in $\\sigma$ are all less than $r$. Therefore, after performing the addition and normalizing to CNF, the largest possible exponent in $\\mu'$ is $\\max(r-1, \\text{exponents of } \\sigma)$. Since all exponents in $\\sigma$ are less than $r$, this maximum is $r-1$.\nSo, the leading exponent of $\\mu$ is $r$, and the leading exponent of $\\mu'$ is $r-1$.\nBy the definition of ordinal comparison, since $r-1 < r$, it immediately follows that $\\mu' < \\mu$.\n\n**Case 2: $r = 0$.**\nA rank-$0$ cut is a cut on an atomic formula. This is the base case for the reduction. The rule for $\\mu'$ specifies that the cut is completely removed:\n$$ \\mu = \\omega^0 \\cdot (h_L + h_R) + \\sigma = 1 \\cdot (h_L + h_R) + \\sigma = (h_L+h_R) + \\sigma $$\n$$ \\mu' = \\sigma $$\nGiven a non-trivial cut, $h_L+h_R > 0$. Since ordinal addition is not commutative in general, we must be precise. The term $(h_L+h_R)$ is an ordinal of the form $\\omega^0 \\cdot (h_L+h_R)$. Since the condition is $e_i < r$, for $r=0$ this implies $\\sigma$ must be $0$. In this case, $\\mu=h_L+h_R$ and $\\mu'=0$. Clearly $\\mu' < \\mu$ for $h_L+h_R>0$. More generally, if we relax the condition so that $\\sigma$ could be non-zero (e.g., if we were only considering integer ranks), adding a positive integer $(h_L+h_R)$ to an ordinal $\\sigma$ from the left strictly increases it, so $\\sigma < (h_L+h_R) + \\sigma$. Thus $\\mu' < \\mu$.\n\nIn all valid reduction scenarios, the ordinal measure strictly decreases. This guarantees that repeated application of the reduction procedure must terminate, establishing the cut-elimination result. The programmatic implementation below will verify this inequality for the specific test cases provided.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying ordinal decrease in a simulated\n    cut-elimination step for Peano Arithmetic.\n    \"\"\"\n\n    class Ordinal:\n        \"\"\"\n        Represents an ordinal below omega^omega in Cantor Normal Form.\n        The ordinal is stored as a list of (exponent, coefficient) tuples,\n        sorted in descending order of exponents. Exponents are integers.\n        \"\"\"\n        def __init__(self, terms=None):\n            \"\"\"\n            Initializes an Ordinal object.\n            Args:\n                terms (list, optional): A list of (exponent, coefficient) tuples.\n                                        Defaults to an empty list, representing the ordinal 0.\n            \"\"\"\n            if terms is None:\n                self.terms = []\n            else:\n                self.terms = self._normalize(terms)\n\n        @staticmethod\n        def _normalize(terms):\n            \"\"\"\n            Normalizes a list of terms into Cantor Normal Form:\n            1. Filters out terms with zero or negative coefficients.\n            2. Sorts terms by exponent in descending order.\n            3. Merges terms with identical exponents by summing their coefficients.\n            \"\"\"\n            # Filter terms with positive coefficients\n            filtered_terms = [t for t in terms if t[1] > 0]\n            if not filtered_terms:\n                return []\n\n            # Sort by exponent, descending\n            filtered_terms.sort(key=lambda t: t[0], reverse=True)\n\n            # Merge terms with same exponent\n            if len(filtered_terms) = 1:\n                return filtered_terms\n\n            merged = []\n            current_exp, current_coeff = filtered_terms[0]\n\n            for next_exp, next_coeff in filtered_terms[1:]:\n                if next_exp == current_exp:\n                    current_coeff += next_coeff\n                else:\n                    merged.append((current_exp, current_coeff))\n                    current_exp, current_coeff = next_exp, next_coeff\n            \n            merged.append((current_exp, current_coeff))\n            return merged\n\n        def __add__(self, other):\n            \"\"\"\n            Implements ordinal addition.\n            \"\"\"\n            if not isinstance(other, Ordinal):\n                return NotImplemented\n            # Concatenate term lists and re-normalize\n            new_terms = self.terms + other.terms\n            return Ordinal(new_terms)\n\n        def __lt__(self, other):\n            \"\"\"\n            Implements strict less-than comparison () for ordinals.\n            \"\"\"\n            if not isinstance(other, Ordinal):\n                return NotImplemented\n            \n            terms1 = self.terms\n            terms2 = other.terms\n            \n            i, j = 0, 0\n            while i  len(terms1) and j  len(terms2):\n                exp1, coef1 = terms1[i]\n                exp2, coef2 = terms2[j]\n\n                if exp1  exp2:\n                    return True  # self is smaller\n                if exp1 > exp2:\n                    return False  # self is larger\n\n                # Exponents are equal, compare coefficients\n                if coef1  coef2:\n                    return True  # self is smaller\n                if coef1 > coef2:\n                    return False  # self is larger\n\n                # Terms are identical, move to the next\n                i += 1\n                j += 1\n            \n            # One list is exhausted. If self is exhausted but other is not, self is smaller.\n            if i == len(terms1) and j  len(terms2):\n                return True\n            \n            # If other is exhausted, or both are, self is not strictly smaller.\n            return False\n\n        def __eq__(self, other):\n            \"\"\"\n            Implements equality comparison (==) for ordinals.\n            \"\"\"\n            if not isinstance(other, Ordinal):\n                return NotImplemented\n            return self.terms == other.terms\n\n        def __repr__(self):\n            \"\"\"\n            Provides a string representation for debugging purposes.\n            \"\"\"\n            if not self.terms:\n                return \"0\"\n            return \" + \".join([f\"w^{e}*{c}\" for e, c in self.terms])\n\n    def construct_mu(r, hL, hR, sigma_list):\n        \"\"\"\n        Constructs the ordinal measure mu = omega^r * (hL + hR) + sigma.\n        \"\"\"\n        h_sum = hL + hR\n        sigma_ord = Ordinal(sigma_list)\n        \n        if h_sum > 0:\n            term_r = Ordinal([(r, h_sum)])\n            return term_r + sigma_ord\n        else:\n            return sigma_ord\n\n    def construct_mu_prime(r, hL, hR, sigma_list):\n        \"\"\"\n        Constructs the reduced ordinal measure mu'.\n        \"\"\"\n        sigma_ord = Ordinal(sigma_list)\n\n        if r == 0:\n            # For r=0, the cut is removed, the measure becomes sigma.\n            # The prompt condition e_i  r means sigma_list should be empty.\n            # We follow the formula mu' = sigma.\n            return sigma_ord\n        \n        # For r >= 1\n        k = hL * hR + hL + hR + 1\n        \n        if k > 0:\n            term_r_minus_1 = Ordinal([(r - 1, k)])\n            return term_r_minus_1 + sigma_ord\n        else:\n            # k is only 0 if hL, hR are not non-negative integers.\n            # For hL, hR in N, k >= 1.\n            return sigma_ord\n\n    test_cases = [\n        # Case A: r=3, hL=2, hR=3, sigma=[(2,1), (1,4)]\n        (3, 2, 3, [(2, 1), (1, 4)]),\n        # Case B: r=1, hL=1, hR=1, sigma=[]\n        (1, 1, 1, []),\n        # Case C: r=5, hL=4, hR=1, sigma=[(3,2), (2,1), (1,7)]\n        (5, 4, 1, [(3, 2), (2, 1), (1, 7)]),\n        # Case D: r=2, hL=0, hR=5, sigma=[(1,1), (0,10)]\n        (2, 0, 5, [(1, 1), (0, 10)]),\n    ]\n\n    results = []\n    for r, hL, hR, sigma_list in test_cases:\n        mu = construct_mu(r, hL, hR, sigma_list)\n        mu_prime = construct_mu_prime(r, hL, hR, sigma_list)\n        results.append(mu_prime  mu)\n\n    # Format output as a single line: [result1,result2,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2978413"}]}