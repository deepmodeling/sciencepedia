{"hands_on_practices": [{"introduction": "The most fundamental connection in the Curry-Howard correspondence is between logical implication ($A \\to B$) and function types. This practice explores this core idea: constructing a proof of an implication is equivalent to defining a function, and simplifying a proof corresponds to computing with that function. This exercise [@problem_id:2985657] provides a concrete look at how the computational process of $\\beta$-reduction directly mirrors the logical process of eliminating a \"detour\" in a natural deduction proof, grounding the abstract isomorphism in a simple, hands-on calculation.", "problem": "Consider the simply typed lambda calculus (STLC), where types are built from base types and the function type constructor $\\,\\to\\,$, and terms are built from variables, abstractions $\\lambda x.\\,t$, and applications $t\\,s$. The Curry-Howard correspondence (CHC) identifies types with propositions and terms with proofs; in particular, a term of type $A \\to B$ is a proof that from proposition $A$ one can derive proposition $B$. The introduction rule for implication corresponds to forming an abstraction $\\lambda x.\\,t$ under a discharged assumption $x:A$, and the elimination rule corresponds to application $t\\,s$ when $t:A\\to B$ and $s:A$. The computational content is governed by $\\beta$-reduction, where application of an abstraction to an argument reduces by substitution: $(\\lambda x.\\,t)\\,s \\to_{\\beta} t[x:=s]$. A term is in normal form if no $\\beta$-reductions are applicable.\n\nLet $A$ and $B$ be fixed types. Assume variables $u:A$ and $v:B$, and consider the term $t \\equiv (\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$. Using only the fundamental rules described above for typing, abstraction, application, and $\\beta$-reduction, compute the $\\beta$-normal form of $t$. Then, explain which proof detour in natural deduction for the proposition $A \\to B \\to A$ this elimination step corresponds to under the Curry-Howard correspondence, starting from first principles of introduction and elimination of implication.\n\nYour final answer must be a single closed-form symbolic expression representing the normal form of $t$. No rounding is required and no units apply.", "solution": "The problem statement will first be validated according to the specified criteria.\n\n### Step 1: Extract Givens\n- **System**: Simply typed lambda calculus (STLC).\n- **Type Formation**: Types are built from base types and the function type constructor $\\to$.\n- **Term Formation**: Terms are built from variables, abstraction ($\\lambda x.\\,t$), and application ($t\\,s$).\n- **Curry-Howard Correspondence (CHC)**:\n    - Types are identified with propositions.\n    - Terms are identified with proofs.\n    - A term of type $A \\to B$ is a proof that proposition $A$ implies proposition $B$.\n    - Implication introduction ($\\to I$) corresponds to abstraction ($\\lambda x.\\,t$).\n    - Implication elimination ($\\to E$) corresponds to application ($t\\,s$).\n- **Computation Rule**: $\\beta$-reduction is defined as $(\\lambda x.\\,t)\\,s \\to_{\\beta} t[x:=s]$, where $t[x:=s]$ is the substitution of all free occurrences of $x$ in $t$ with $s$.\n- **Normal Form**: A term is in normal form if no $\\beta$-reductions can be applied.\n- **Given Types**: $A$ and $B$ are fixed types.\n- **Given Variables**: $u$ is a variable of type $A$ (i.e., $u:A$), and $v$ is a variable of type $B$ (i.e., $v:B$).\n- **Term to Analyze**: $t \\equiv (\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation:\n- **Scientifically Grounded**: The problem is entirely situated within mathematical logic and theoretical computer science, specifically dealing with the simply typed lambda calculus and the Curry-Howard correspondence. These are well-established, foundational topics. The concepts of $\\beta$-reduction, normal form, and natural deduction are rigorously defined. The problem does not violate any scientific or mathematical principles.\n- **Well-Posed**: The problem asks for a specific computation (finding the $\\beta$-normal form of a given term) and a specific conceptual explanation based on the provided framework. The rules for computation ($\\beta$-reduction) are explicit and deterministic, ensuring that a unique normal form exists (due to the strong normalization property of STLC). The structure is clear, and a unique, meaningful solution can be derived.\n- **Objective**: The language is formal and precise. The terms \"$\\beta$-normal form,\" \"proof detour,\" and \"natural deduction\" have unambiguous meanings in this context. There are no subjective or opinion-based statements.\n- **Completeness**: The problem provides all necessary information: the term to be reduced, the types of the variables involved, and the fundamental rules of the system (typing, reduction). It is self-contained.\n- **Other Flaws**: The problem is not metaphorical, trivial, contradictory, or unverifiable. It is a standard exercise in its field.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution Derivation\nThe problem requires two parts: first, to compute the $\\beta$-normal form of the term $t \\equiv (\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$, and second, to explain the corresponding logical phenomenon under the Curry-Howard correspondence.\n\n#### Part 1: Computation of the $\\beta$-Normal Form\nThe term to be reduced is $t \\equiv (\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$. Application in lambda calculus is left-associative, so this term is parsed as $((\\lambda x.\\,\\lambda y.\\,x)\\,u)\\,v$.\n\nThe reduction proceeds in two steps, applying the rule $(\\lambda z.\\,M)\\,N \\to_{\\beta} M[z:=N]$.\n\n**Step 1:** The first reduction applies to the sub-term $(\\lambda x.\\,\\lambda y.\\,x)\\,u$.\nHere, the abstraction is $\\lambda x.\\,(\\lambda y.\\,x)$ and the argument is $u$. Following the $\\beta$-reduction rule, we substitute the term $u$ for every free occurrence of the variable $x$ in the body of the abstraction, which is $\\lambda y.\\,x$.\n$$ (\\lambda x.\\,\\lambda y.\\,x)\\,u \\to_{\\beta} (\\lambda y.\\,x)[x:=u] $$\nThe substitution yields the term $\\lambda y.\\,u$. In this new term, $u$ is a term of type $A$, and the abstraction is over a variable $y$ which does not appear free in $u$.\n\nAfter the first reduction, the original term $t$ becomes:\n$$ t \\to_{\\beta} (\\lambda y.\\,u)\\,v $$\n\n**Step 2:** The second reduction applies to the resulting term $(\\lambda y.\\,u)\\,v$.\nHere, the abstraction is $\\lambda y.\\,u$ and the argument is $v$. We substitute the term $v$ for every free occurrence of the variable $y$ in the body of the abstraction, which is $u$.\n$$ (\\lambda y.\\,u)\\,v \\to_{\\beta} u[y:=v] $$\nAccording to the problem statement, $u$ is a variable of type $A$. The variable $y$ does not appear free in the term $u$. Therefore, the substitution $u[y:=v]$ results in the term $u$ itself.\n$$ u[y:=v] \\equiv u $$\n\nCombining the steps, the full reduction sequence is:\n$$ t \\equiv ((\\lambda x.\\,\\lambda y.\\,x)\\,u)\\,v \\to_{\\beta} (\\lambda y.\\,u)\\,v \\to_{\\beta} u $$\nThe term $u$ contains no redexes (i.e., no sub-terms of the form $(\\lambda z.\\,M)\\,N$), so it is in $\\beta$-normal form.\n\n#### Part 2: Explanation via Curry-Howard Correspondence\nThe Curry-Howard correspondence establishes an isomorphism between propositions in intuitionistic logic and types in typed lambda calculus. Proofs correspond to terms.\n\n**Typing the Term**: Let's determine the type of the term $t$.\n1.  The sub-term $\\lambda x.\\,\\lambda y.\\,x$ is a proof of the proposition $A \\to (B \\to A)$. To see this, we construct its proof in natural deduction:\n    - Assume $x:A$ (a proof of $A$). This is assumption $[A]^1$.\n    - Assume $y:B$ (a proof of $B$). This is assumption $[B]^2$.\n    - Under these assumptions, we have $x$, which is a proof of $A$. So we have derived $A$.\n    - By implication introduction ($\\to I$), we discharge the assumption $[B]^2$ to conclude $B \\to A$. The proof term is $\\lambda y.\\,x$.\n    - By implication introduction ($\\to I$) again, we discharge the assumption $[A]^1$ to conclude $A \\to (B \\to A)$. The proof term is $\\lambda x.\\,\\lambda y.\\,x$.\n\n2.  The term is $(\\lambda x.\\,\\lambda y.\\,x)\\,u\\,v$. We have the following proofs (terms) and propositions (types):\n    - $(\\lambda x.\\,\\lambda y.\\,x) : A \\to (B \\to A)$\n    - $u : A$\n    - $v : B$\n\n3.  The application $(\\lambda x.\\,\\lambda y.\\,x)\\,u$ corresponds to implication elimination ($\\to E$, or Modus Ponens). We have a proof of $A \\to (B \\to A)$ and a proof of $A$, so we can conclude $B \\to A$. The resulting proof term is $(\\lambda x.\\,\\lambda y.\\,x)\\,u$.\n\n4.  The final application $((\\lambda x.\\,\\lambda y.\\,x)\\,u)\\,v$ is another use of $\\to E$. We have a proof of $B \\to A$ from the previous step and a proof of $B$ (the term $v$), so we conclude $A$. Thus, the type of the entire term $t$ is $A$. This is consistent with our computational result, as the normal form is $u$, which has type $A$.\n\n**The Proof Detour**: A \"proof detour\" (or \"cut\") in natural deduction occurs when a connective is introduced and then immediately eliminated. The process of $\\beta$-reduction on the proof term corresponds precisely to the process of eliminating these detours in the associated proof, a procedure known as normalization or cut-elimination.\n\n1.  **First Detour and its Elimination**: The application $(\\lambda x.\\,\\lambda y.\\,x)\\,u$ represents the elimination of the outermost implication in $A \\to (B \\to A)$, which was just introduced via the abstraction $\\lambda x$.\n    - **Introduction**: We assumed a hypothetical proof $x$ of $A$ to construct a proof of $B \\to A$, and then generalized to $A \\to (B \\to A)$.\n    - **Elimination**: We immediately apply this general proof to a concrete proof of $A$, which is $u$.\n    - **Detour**: The detour is the path: assume $A \\to$ construct a function $\\to$ apply the function to a proof of $A$.\n    - **Reduction**: The $\\beta$-reduction $(\\lambda x.\\,\\lambda y.\\,x)\\,u \\to_{\\beta} \\lambda y.\\,u$ eliminates this detour. In the proof, this corresponds to replacing every instance of the placeholder assumption $x$ with the actual proof $u$. The resulting proof object $\\lambda y.\\,u$ is a direct proof of $B \\to A$ built from $u$.\n\n2.  **Second Detour and its Elimination**: The subsequent application $(\\lambda y.\\,u)\\,v$ represents a second detour.\n    - **Introduction**: The term $\\lambda y.\\,u$ constructs a proof of $B \\to A$. This was done by assuming a proof $y$ of $B$ and then proving $A$. However, the proof of $A$ (which is $u$) did not depend on the assumption $y:B$ at all. This is called a vacuous discharge.\n    - **Elimination**: We then immediately apply this construction to a concrete proof of $B$, which is $v$.\n    - **Detour**: The detour is: vacuously assume $B \\to$ construct a proof of $B \\to A \\to$ apply this to a proof of $B$.\n    - **Reduction**: The $\\beta$-reduction $(\\lambda y.\\,u)\\,v \\to_{\\beta} u$ eliminates this detour. Logically, if the proof of a conclusion $A$ from an assumption $B$ never actually used the assumption $B$, then being given a concrete proof of $B$ is irrelevant. The proof simplifies to the original proof of $A$, which is exactly what the term $u$ represents. The supplied proof $v$ is discarded.\n\nIn summary, the sequence of $\\beta$-reductions mirrors the simplification of the corresponding natural deduction proof. The initial proof corresponding to $t$ is a complex and indirect way to prove $A$. It involves creating general rules ($A \\to (B \\to A)$) and then applying them. The normalization process removes these intermediate introduction-elimination steps, showing that the most direct proof of $A$ given the initial data ($u:A$, $v:B$) is simply $u$ itself.", "answer": "$$ \\boxed{u} $$", "id": "2985657"}, {"introduction": "Building on the link between implication and functions, we now extend the correspondence to another essential logical connective: conjunction ($A \\land B$). In the programming world, this idea is captured by product types, often seen as pairs or records. A proof of a conjunction is simply a package containing a proof for each conjunct. This practice [@problem_id:2985694] reinforces the isomorphism by having you simplify a term that first packages two proofs together and then immediately discards one, demonstrating a direct parallel with the logical simplification of an unnecessary conjunction introduction-elimination step.", "problem": "Work in the Simply Typed Lambda Calculus (STLC) with binary products, where product introduction is written $\\langle u,v\\rangle$ and product elimination is written $\\pi_{1}$ and $\\pi_{2}$ for first and second projection, respectively. Under the Curry–Howard correspondence (CH), types correspond to propositions, terms correspond to proofs, function types $A \\to B$ correspond to implication, and product types $A \\times B$ correspond to conjunction. Let $A$ be any type and let $t$ be a variable of type $A$. Consider the typed term\n$$\n(\\lambda x\\!:\\!A.\\,\\pi_{1}\\langle x, x\\rangle)\\,t.\n$$\nCompute its $\\beta$-normal form using the standard computational rules of the STLC with products, and then explain, under the Curry–Howard correspondence, why this computation corresponds to the elimination of a redundant introduction–elimination pair for conjunction in logic. Your final answer must be a single closed-form symbolic expression.", "solution": "The problem is valid as it is well-posed within the established formalisms of the Simply Typed Lambda Calculus (STLC) and the Curry–Howard correspondence.\n\nThe task consists of two parts: first, to compute the $\\beta$-normal form of the given typed term, and second, to explain the logical significance of this computation under the Curry–Howard correspondence.\n\nFirst, we compute the normal form of the term $(\\lambda x\\!:\\!A.\\,\\pi_{1}\\langle x, x\\rangle)\\,t$. This expression is an application of a lambda abstraction to a term, which constitutes a $\\beta$-redex. The standard rule for $\\beta$-reduction is $(\\lambda v\\!:\\!T.\\,M)\\,N \\to_{\\beta} M[N/v]$, where $M[N/v]$ denotes the capture-avoiding substitution of the term $N$ for all free occurrences of the variable $v$ in the term $M$.\n\nApplying this rule to the given term:\nLet the body of the lambda abstraction be $M = \\pi_{1}\\langle x, x\\rangle$ and the argument be $N = t$.\nThe reduction proceeds as follows:\n$$\n(\\lambda x\\!:\\!A.\\,\\pi_{1}\\langle x, x\\rangle)\\,t \\to_{\\beta} (\\pi_{1}\\langle x, x\\rangle)[t/x]\n$$\nThe substitution of $t$ for $x$ in the expression $\\pi_{1}\\langle x, x\\rangle$ yields:\n$$\n(\\pi_{1}\\langle x, x\\rangle)[t/x] = \\pi_{1}\\langle t, t\\rangle\n$$\nThe resulting term, $\\pi_{1}\\langle t, t\\rangle$, involves the elimination of a product (via the projection $\\pi_{1}$) that is applied to a product introduction (the pair construction $\\langle \\cdot, \\cdot \\rangle$). This is a redex for the product reduction rules. The computational rules for projections in STLC are:\n$1$. $\\pi_{1}\\langle u, v \\rangle \\to u$\n$2$. $\\pi_{2}\\langle u, v \\rangle \\to v$\n\nApplying the first rule to our term, where $u$ is $t$ and $v$ is also $t$:\n$$\n\\pi_{1}\\langle t, t \\rangle \\to t\n$$\nThe term $t$ is a variable and contains no further redexes. Therefore, it is in normal form. The complete reduction sequence is:\n$$\n(\\lambda x\\!:\\!A.\\,\\pi_{1}\\langle x, x\\rangle)\\,t \\to_{\\beta} \\pi_{1}\\langle t, t\\rangle \\to t\n$$\nThe $\\beta$-normal form of the given term is $t$.\n\nSecond, we explain the logical meaning of this computation under the Curry–Howard correspondence. This correspondence establishes a direct isomorphism between formal proof systems (like natural deduction) and models of computation (like the lambda calculus).\nUnder this correspondence:\n- A type, such as $A$, corresponds to a logical proposition, also denoted $A$.\n- A term of a given type, such as the variable $t$ of type $A$, corresponds to a proof of that proposition. Thus, $t:A$ represents a proof of $A$. In this context, $t$ can be seen as an axiom or an undischarged assumption that $A$ is true.\n- A product type $A \\times B$ corresponds to the logical conjunction $A \\wedge B$.\n- The product introduction term $\\langle u, v \\rangle$ corresponds to the conjunction introduction rule ($\\wedge$-intro). If $u$ is a proof of $A$ and $v$ is a proof of $B$, then $\\langle u, v \\rangle$ is a proof of $A \\wedge B$.\n- The product elimination terms $\\pi_{1}$ and $\\pi_{2}$ correspond to the conjunction elimination rules ($\\wedge$-elim). If $w$ is a proof of $A \\wedge B$, then $\\pi_{1}w$ is a proof of $A$, and $\\pi_{2}w$ is a proof of $B$.\n\nLet us analyze the local reduction step $\\pi_{1}\\langle t, t \\rangle \\to t$ in this logical context.\n$1$. The term $t$ represents a given proof of proposition $A$.\n$2$. The term $\\langle t, t \\rangle$ has type $A \\times A$. Logically, it represents a proof of the proposition $A \\wedge A$. This proof is constructed by applying the $\\wedge$-introduction rule to two copies of the proof $t$ of $A$.\n$3$. The term $\\pi_{1}\\langle t, t \\rangle$ has type $A$. It corresponds to applying the left $\\wedge$-elimination rule to the proof $\\langle t, t \\rangle$ of $A \\wedge A$ to derive a proof of the first conjunct, $A$.\n\nThe sequence of logical steps is as follows:\n- We start with a proof $t$ of $A$:\n$$ t \\vdash A $$\n- We use $\\wedge$-introduction to construct a proof of $A \\wedge A$:\n$$ \\frac{t \\vdash A \\quad t \\vdash A}{ \\langle t, t \\rangle \\vdash A \\wedge A } \\quad (\\wedge\\text{-intro}) $$\n- We then immediately use $\\wedge$-elimination to obtain a proof of $A$ again:\n$$ \\frac{ \\langle t, t \\rangle \\vdash A \\wedge A }{ \\pi_{1}\\langle t, t \\rangle \\vdash A } \\quad (\\wedge\\text{-elim}) $$\n\nThis sequence of an introduction rule immediately followed by the corresponding elimination rule for the same logical connective is known in proof theory as a \"detour\" or a redundant step. The proof normalization process simplifies proofs by removing such detours. The resulting proof of $A$, $\\pi_{1}\\langle t, t \\rangle$, is unnecessarily complex, since the original proof $t$ was already available.\n\nThe computational reduction $\\pi_{1}\\langle t, t \\rangle \\to t$ is the direct analogue of this proof normalization step. It eliminates the redundant introduction-elimination pair for conjunction, simplifying the convoluted proof $\\pi_{1}\\langle t, t \\rangle$ to the original, direct proof $t$. The full computation $(\\lambda x\\!:\\!A.\\,\\pi_{1}\\langle x, x\\rangle)\\,t \\to t$ embeds this principle within a functional context, where the $\\beta$-reduction first substitutes the specific proof $t$ into a general proof schema, after which the core simplification of the connective introduction/elimination occurs.", "answer": "$$\n\\boxed{t}\n$$", "id": "2985694"}, {"introduction": "This practice elevates the correspondence from simple propositional logic into the more expressive realm of predicate logic, where we can reason about properties of objects. Here, universal quantification ($\\forall x:A. P(x)$) is shown to correspond to the powerful concept of dependent function types ($\\Pi_{x:A} P(x)$). In this exercise [@problem_id:2985606], you will construct a term that serves as a formal proof for a distributive law of quantifiers over conjunction, seeing firsthand how a complex logical argument is precisely encoded as a well-typed program in a dependently typed system.", "problem": "In the setting of the Curry–Howard correspondence, dependent function types $\\Pi_{x:A}B(x)$ correspond to universal quantification $\\forall x:A.\\,B(x)$, binary product types $B \\times C$ correspond to conjunction $B \\land C$, and ordinary function types $B \\to C$ correspond to implication $B \\Rightarrow C$. Working in a dependent type theory where products and dependent products are primitive, proceed as follows:\n\n1. Using only the introduction and elimination rules for products and dependent products, construct explicitly (as a fully typed $\\lambda$-term) the canonical forward map that witnesses the type\n$$\n\\bigl(\\Pi_{x:A}\\,\\bigl(P(x) \\times Q(x)\\bigr)\\bigr) \\to \\bigl(\\Pi_{x:A}P(x)\\bigr) \\times \\bigl(\\Pi_{x:A}Q(x)\\bigr).\n$$\nYour construction must be justified from first principles of the typing rules.\n\n2. Explain, via the Curry–Howard correspondence, why the term you constructed realizes the logical implication\n$$\n\\forall x.\\,\\bigl(P \\land Q\\bigr) \\;\\Rightarrow\\; \\bigl(\\forall x.\\,P\\bigr) \\land \\bigl(\\forall x.\\,Q\\bigr).\n$$\nYour explanation should reference only the fundamental identifications of the correspondence and the formation, introduction, and elimination principles of the types involved.\n\n3. Now interpret the types in the standard set-theoretic model where types are sets, terms are elements, $B \\times C$ is the Cartesian product, and $\\Pi_{x \\in A}B(x)$ is the set of choice functions $f$ with $f(x) \\in B(x)$ for each $x \\in A$. Let $A = \\{a_1,a_2,a_3\\}$ be a finite set with three elements, and suppose the fibers have the following cardinalities:\n$$\n|P(a_1)| = 2,\\quad |P(a_2)| = 1,\\quad |P(a_3)| = 5,\\qquad |Q(a_1)| = 3,\\quad |Q(a_2)| = 4,\\quad |Q(a_3)| = 2.\n$$\nCompute the exact cardinality of the dependent function space\n$$\n\\Pi_{x \\in A}\\bigl(P(x) \\times Q(x)\\bigr).\n$$\nProvide your final answer as a single integer. Do not round.", "solution": "The problem is valid as it is scientifically grounded in established principles of mathematical logic and dependent type theory, is well-posed, objective, and internally consistent.\n\nThe problem is divided into three parts. We will address each in sequence.\n\n### Part 1: Construction of the $\\lambda$-term\n\nWe are asked to construct a term that inhabits the type\n$$\n\\bigl(\\Pi_{x:A}\\,\\bigl(P(x) \\times Q(x)\\bigr)\\bigr) \\to \\bigl(\\Pi_{x:A}P(x)\\bigr) \\times \\bigl(\\Pi_{x:A}Q(x)\\bigr).\n$$\nThis is a function type, specifically a non-dependent function type of the form $B \\to C$, where $B = \\Pi_{x:A}(P(x) \\times Q(x))$ and $C = (\\Pi_{x:A}P(x)) \\times (\\Pi_{x:A}Q(x))$.\n\nThe introduction rule for the function type $B \\to C$ is $\\lambda$-abstraction. To construct a term of this type, we assume a variable, say $f$, of the domain type $B$ and construct a term in the codomain type $C$.\nLet $f$ be a variable of type $\\Pi_{x:A}\\,(P(x) \\times Q(x))$. Our goal is to construct a term of type $(\\Pi_{x:A}P(x)) \\times (\\Pi_{x:A}Q(x))$.\n$$\n\\lambda f : \\Pi_{x:A}\\,(P(x) \\times Q(x)).\\; (\\text{goal term of type } (\\Pi_{x:A}P(x)) \\times (\\Pi_{x:A}Q(x)))\n$$\nThe target type is a product type. The introduction rule for a product type $C_1 \\times C_2$ is to form a pair $\\langle t_1, t_2 \\rangle$, where $t_1$ has type $C_1$ and $t_2$ has type $C_2$. Here, $C_1 = \\Pi_{x:A}P(x)$ and $C_2 = \\Pi_{x:A}Q(x)$.\nSo, our goal term must have the form $\\langle \\text{term}_1, \\text{term}_2 \\rangle$, where:\n- $\\text{term}_1$ has type $\\Pi_{x:A}P(x)$.\n- $\\text{term}_2$ has type $\\Pi_{x:A}Q(x)$.\n\nLet's construct $\\text{term}_1$. The type $\\Pi_{x:A}P(x)$ is a dependent function type. The introduction rule for this type is again $\\lambda$-abstraction. We must construct a function that, given a term $x$ of type $A$, returns a term of type $P(x)$.\nLet $x$ be a variable of type $A$. Our goal is to construct a term of type $P(x)$ using our available assumption, $f : \\Pi_{x:A}\\,(P(x) \\times Q(x))$.\n$$\n\\text{term}_1 = \\lambda x:A.\\; (\\text{goal term of type } P(x))\n$$\nThe elimination rule for the dependent function type $\\Pi$ is function application. Since $f$ has type $\\Pi_{x:A}\\,(P(x) \\times Q(x))$ and $x$ has type $A$, we can apply $f$ to $x$. The resulting term, let's denote it $f(x)$ or $f\\,x$, has type $P(x) \\times Q(x)$.\nThe type $P(x) \\times Q(x)$ is a product type. The elimination rules for products are the projections, $\\pi_1$ and $\\pi_2$.\nApplying the first projection, $\\pi_1$, to the term $f(x)$ gives a term $\\pi_1(f(x))$ of type $P(x)$. This is exactly what we need for the body of our inner lambda.\nThus, $\\text{term}_1 = \\lambda x:A.\\; \\pi_1(f(x))$.\n\nNow, let's construct $\\text{term}_2$. The process is symmetric. The type is $\\Pi_{x:A}Q(x)$. We again use $\\lambda$-introduction. Let $x$ be a variable of type $A$. We need to construct a term of type $Q(x)$.\n$$\n\\text{term}_2 = \\lambda x:A.\\; (\\text{goal term of type } Q(x))\n$$\nAs before, we have $f : \\Pi_{x:A}\\,(P(x) \\times Q(x))$ and $x : A$, so $f(x)$ has type $P(x) \\times Q(x)$. Applying the second projection, $\\pi_2$, to $f(x)$ gives a term $\\pi_2(f(x))$ of type $Q(x)$.\nThus, $\\text{term}_2 = \\lambda x:A.\\; \\pi_2(f(x))$.\n\nCombining these pieces, the final $\\lambda$-term is constructed by pairing $\\text{term}_1$ and $\\text{term}_2$ inside the initial $\\lambda$-abstraction for $f$.\nThe complete term is:\n$$\n\\lambda f : \\Pi_{x:A}\\,(P(x) \\times Q(x)).\\; \\langle \\lambda x:A.\\; \\pi_1(f(x)), \\lambda x:A.\\; \\pi_2(f(x)) \\rangle\n$$\nThis term has the required type, constructed solely from the specified introduction and elimination rules.\n\n### Part 2: Logical Explanation via Curry–Howard Correspondence\n\nThe Curry–Howard correspondence establishes a direct isomorphism between propositions in intuitionistic logic and types in a suitable type theory. Under this correspondence:\n- A type is inhabited if and only if the corresponding proposition is provable.\n- A term inhabiting a type is a proof of the corresponding proposition.\n- Function type $B \\to C$ corresponds to logical implication $B \\Rightarrow C$.\n- Product type $B \\times C$ corresponds to logical conjunction $B \\land C$.\n- Dependent function type $\\Pi_{x:A}B(x)$ corresponds to universal quantification $\\forall x:A.\\,B(x)$.\n\nLet's translate the type from Part 1 into a logical proposition.\n- The type of the argument, $\\Pi_{x:A}\\,(P(x) \\times Q(x))$, corresponds to the proposition $\\forall x:A.\\,(P(x) \\land Q(x))$.\n- The type of the first component of the result, $\\Pi_{x:A}P(x)$, corresponds to $\\forall x:A.\\,P(x)$.\n- The type of the second component of the result, $\\Pi_{x:A}Q(x)$, corresponds to $\\forall x:A.\\,Q(x)$.\n- The product of these two, $(\\Pi_{x:A}P(x)) \\times (\\Pi_{x:A}Q(x))$, corresponds to the conjunction $(\\forall x:A.\\,P(x)) \\land (\\forall x:A.\\,Q(x))$.\n- Finally, the full function type from Part 1 corresponds to the implication:\n$$\n\\bigl(\\forall x:A.\\,(P(x) \\land Q(x))\\bigr) \\Rightarrow \\bigl((\\forall x:A.\\,P(x)) \\land (\\forall x:A.\\,Q(x))\\bigr).\n$$\nThis matches the logical formula provided. The $\\lambda$-term constructed in Part 1 is a proof object for this proposition. Let's trace the proof steps mirrored by the term's structure.\n\n1.  **Implication Introduction ($\\Rightarrow_I$)**: The outermost `λf : ...` corresponds to assuming the antecedent of the implication. We assume we have a proof $f$ of $\\forall x:A.\\,(P(x) \\land Q(x))$.\n\n2.  **Conjunction Introduction ($\\land_I$)**: The pair constructor $\\langle \\dots, \\dots \\rangle$ corresponds to the goal of proving a conjunction. To prove the main consequent, we must prove its two conjuncts separately: (i) $\\forall x:A.\\,P(x)$ and (ii) $\\forall x:A.\\,Q(x)$.\n\n3.  **Proving the first conjunct, $\\forall x:A.\\,P(x)$**:\n    - **Universal Introduction ($\\forall_I$)**: The term $\\lambda x:A.\\; \\dots$ corresponds to introducing an arbitrary element $x$ from the domain $A$ and proving $P(x)$ for it.\n    - **Universal Elimination ($\\forall_E$)**: The term $f(x)$ corresponds to applying our initial assumption (the proof $f$ of $\\forall x:A.\\,(P(x) \\land Q(x))$) to the specific arbitrary element $x$. This gives us a proof of $P(x) \\land Q(x)$.\n    - **Conjunction Elimination ($\\land_E$)**: The term $\\pi_1(f(x))$ corresponds to eliminating the conjunction $P(x) \\land Q(x)$ to obtain a proof of its left-hand side, $P(x)$. This concludes the proof for the arbitrary $x$.\n\n4.  **Proving the second conjunct, $\\forall x:A.\\,Q(x)$**:\n    - The reasoning is symmetric. The term $\\lambda x:A.\\; \\pi_2(f(x))$ corresponds to a proof of $\\forall x:A.\\,Q(x)$ by assuming an arbitrary $x:A$, instantiating the universal hypothesis to get $P(x) \\land Q(x)$, and then eliminating the conjunction to get $Q(x)$.\n\nThe structure of the $\\lambda$-term is a formal encoding of a natural deduction proof of the logical implication. Each type-theoretic rule (introduction/elimination) used in the construction of the term corresponds precisely to a logical rule of inference.\n\n### Part 3: Cardinality Calculation\n\nIn the set-theoretic model:\n- A type is interpreted as a set.\n- The product type $B \\times C$ is interpreted as the Cartesian product of the sets $B$ and $C$. The cardinality is $|B \\times C| = |B| \\times |C|$.\n- The dependent function type $\\Pi_{x \\in A} B(x)$ is interpreted as the set of all functions $f$ with domain $A$ such that for each $x \\in A$, $f(x) \\in B(x)$. This is the generalized Cartesian product of the family of sets $\\{B(x)\\}_{x \\in A}$.\n\nThe cardinality of such a dependent function space (or generalized Cartesian product) is the product of the cardinalities of the individual sets in the family:\n$$\n\\left| \\Pi_{x \\in A} B(x) \\right| = \\prod_{x \\in A} |B(x)|.\n$$\nWe are asked to compute the cardinality of the type $\\Pi_{x \\in A}(P(x) \\times Q(x))$. In the set-theoretic model, this corresponds to the set of choice functions where the fiber over each $x \\in A$ is the set $P(x) \\times Q(x)$.\n\nThe cardinality is therefore:\n$$\n\\left| \\Pi_{x \\in A}\\bigl(P(x) \\times Q(x)\\bigr) \\right| = \\prod_{x \\in A} |P(x) \\times Q(x)|.\n$$\nUsing the rule for the cardinality of a Cartesian product, we have $|P(x) \\times Q(x)| = |P(x)| \\times |Q(x)|$. So, the total cardinality is:\n$$\n\\prod_{x \\in A} \\bigl(|P(x)| \\times |Q(x)|\\bigr).\n$$\nThe set $A$ is given as $A = \\{a_1, a_2, a_3\\}$. The product expands over the elements of $A$:\n$$\n\\bigl(|P(a_1)| \\times |Q(a_1)|\\bigr) \\times \\bigl(|P(a_2)| \\times |Q(a_2)|\\bigr) \\times \\bigl(|P(a_3)| \\times |Q(a_3)|\\bigr).\n$$\nWe are given the following cardinalities:\n- $|P(a_1)| = 2$, $|Q(a_1)| = 3$\n- $|P(a_2)| = 1$, $|Q(a_2)| = 4$\n- $|P(a_3)| = 5$, $|Q(a_3)| = 2$\n\nSubstituting these values into the expression:\n- For $x = a_1$: $|P(a_1)| \\times |Q(a_1)| = 2 \\times 3 = 6$.\n- For $x = a_2$: $|P(a_2)| \\times |Q(a_2)| = 1 \\times 4 = 4$.\n- For $x = a_3$: $|P(a_3)| \\times |Q(a_3)| = 5 \\times 2 = 10$.\n\nThe total cardinality is the product of these results:\n$$\n6 \\times 4 \\times 10 = 24 \\times 10 = 240.\n$$\nThe cardinality of the dependent function space $\\Pi_{x \\in A}(P(x) \\times Q(x))$ is $240$.", "answer": "$$\\boxed{240}$$", "id": "2985606"}]}