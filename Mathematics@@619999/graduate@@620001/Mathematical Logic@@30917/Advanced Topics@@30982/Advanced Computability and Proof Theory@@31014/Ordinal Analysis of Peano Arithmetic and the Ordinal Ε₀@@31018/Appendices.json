{"hands_on_practices": [{"introduction": "The theory of ordinals can feel abstract, but its power is revealed in concrete applications. This first exercise provides a fascinating entry point through Goodstein's theorem, which concerns sequences of integers that, despite their explosive growth, are guaranteed to terminate. By mapping a Goodstein sequence to a corresponding sequence of ordinals below $\\varepsilon_0$, you will perform the calculations that demonstrate the strictly decreasing nature of this ordinal counterpart, providing a tangible intuition for the well-foundedness arguments central to ordinal analysis [@problem_id:2978410].", "problem": "Consider the Goodstein process and its ordinal interpretation below, which are standard tools in the ordinal analysis of Peano Arithmetic via the ordinal $\\varepsilon_{0}$.\n\nDefinitions and setup:\n- For each base $b \\geq 2$, the hereditary base-$b$ representation $H_{b}(n)$ of a natural number $n$ is obtained by writing $n$ in base $b$ as a finite sum $\\sum_{i} c_{i} b^{e_{i}}$ with coefficients $0 \\leq c_{i} < b$, and then recursively writing each exponent $e_{i}$ in hereditary base-$b$ form.\n- Given a hereditary base-$b$ term, its ordinal interpretation $\\Phi(H_{b}(n))$ is defined by replacing every occurrence of $b$ by the first infinite ordinal $\\omega$, interpreting addition and multiplication as ordinal operations, and exponents as ordinal exponentiation. The result is an ordinal in Cantor normal form below $\\varepsilon_{0}$.\n- Define the Goodstein sequence $(G(k))_{k \\in \\mathbb{N}}$ with base function $b(k) \\coloneqq k+2$ by:\n  1. Fix $G(0)$ via its hereditary base-$2$ representation\n     $$H_{2}(G(0)) \\;=\\; 2^{2^{1}} \\;+\\; 2^{2^{1}} \\;+\\; 1.$$\n     Equivalently, numerically $G(0)=9$.\n  2. For each $k \\geq 0$, obtain $G(k+1)$ by first replacing every $b(k)$ by $b(k+1)$ in $H_{b(k)}(G(k))$, evaluating this as a natural number, and then subtracting $1$.\n- For each $k$, define the ordinal measure\n  $$\\alpha_{k} \\;\\coloneqq\\; \\Phi\\!\\big(H_{b(k)}(G(k))\\big),$$\n  which is an ordinal $<\\varepsilon_{0}$ in Cantor normal form. It is known that $\\alpha_{k+1} < \\alpha_{k}$.\n\nTasks:\n1. Compute $G(1)$, $G(2)$, and $G(3)$ by explicitly carrying out the base change and subtraction steps, and express each $G(k)$ in hereditary base-$b(k)$ form.\n2. For each of $k=0,1,2,3$, compute $\\alpha_{k}$ in Cantor normal form by replacing the base $b(k)$ by $\\omega$ in $H_{b(k)}(G(k))$.\n3. Verify explicitly that $\\alpha_{0} > \\alpha_{1} > \\alpha_{2} > \\alpha_{3}$ and that all $\\alpha_{k}$ lie below $\\varepsilon_{0}$.\n\nWhat is the explicit Cantor normal form expression of $\\alpha_{3}$? Provide your final answer as a single closed-form expression. No rounding is required.", "solution": "The problem statement has been validated and found to be self-contained, scientifically grounded in mathematical logic, and well-posed. The initial representation provided for $G(0)$, while non-canonical, is given as a definition for the starting state of the Goodstein process, which is a valid way to specify a problem. The subsequent steps are all well-defined.\n\nThe problem asks for the explicit Cantor normal form of the ordinal $\\alpha_3$, which is derived from a Goodstein-like sequence. I will carry out the calculations for $k=0, 1, 2, 3$ as requested by the tasks to derive the final answer. The base for step $k$ is $b(k) = k+2$.\n\n**Step $k=0$:**\nThe base is $b(0) = 2$. The initial state is defined by the hereditary base-$2$ representation:\n$$H_{2}(G(0)) = 2^{2^{1}} + 2^{2^{1}} + 1$$\nThe numerical value is $G(0) = 2^{2} + 2^{2} + 1 = 4+4+1=9$.\nThe corresponding ordinal $\\alpha_0$ is found by replacing the base $2$ with $\\omega$ and interpreting the expression using ordinal arithmetic.\n$$\\alpha_0 = \\Phi(H_{2}(G(0))) = \\omega^{\\omega^{1}} + \\omega^{\\omega^{1}} + 1 = \\omega^{\\omega} \\cdot 2 + 1$$\nThis is an ordinal in Cantor normal form (CNF).\n\n**Step $k=1$:**\nThe base is $b(1) = 1+2 = 3$. To compute $G(1)$, we first change the base from $2$ to $3$ in the expression for $H_2(G(0))$:\n$$2^{2^{1}} + 2^{2^{1}} + 1 \\quad \\xrightarrow{\\text{base } 2 \\to 3} \\quad 3^{3^{1}} + 3^{3^{1}} + 1$$\nEvaluating this new expression numerically gives $3^3 + 3^3 + 1 = 27 + 27 + 1 = 55$.\nThe Goodstein process then requires subtracting $1$:\n$$G(1) = 55 - 1 = 54$$\nNext, we find the hereditary base-$3$ representation of $G(1)=54$.\n$$G(1) = 54 = 2 \\times 27 = 2 \\times 3^3$$\nSince the exponent $3$ is equal to the base, it must also be written in base-$3$: $3 = 1 \\cdot 3^1$. So, the hereditary base-$3$ representation is:\n$$H_{3}(G(1)) = 2 \\cdot 3^{3^{1}}$$\nThe corresponding ordinal $\\alpha_1$ is found by applying the mapping $\\Phi$. The term $c \\cdot b^{e}$ maps to $\\omega^{\\Phi(e)} \\cdot c$.\n$$\\alpha_1 = \\Phi(2 \\cdot 3^{3^{1}}) = \\omega^{\\Phi(3^1)} \\cdot 2$$\nThe exponent's representation $3^1$ maps to $\\omega^1 = \\omega$. Therefore:\n$$\\alpha_1 = \\omega^{\\omega} \\cdot 2$$\n\n**Step $k=2$:**\nThe base is $b(2) = 2+2 = 4$. We take $H_{3}(G(1)) = 2 \\cdot 3^{3^{1}}$ and change the base from $3$ to $4$:\n$$2 \\cdot 3^{3^{1}} \\quad \\xrightarrow{\\text{base } 3 \\to 4} \\quad 2 \\cdot 4^{4^{1}}$$\nEvaluating this numerically gives $2 \\cdot 4^4 = 2 \\cdot 256 = 512$.\nSubtracting $1$ gives $G(2)$:\n$$G(2) = 512 - 1 = 511$$\nNow, we find the hereditary base-$4$ representation of $G(2)=511$. We can derive this from the expression $2\\cdot4^4-1$:\n$$2\\cdot4^4 - 1 = 1\\cdot4^4 + (1\\cdot4^4 - 1)$$\nUsing the identity $b^n-1 = \\sum_{i=0}^{n-1} (b-1)b^i$, we have $4^4-1 = 3\\cdot4^3 + 3\\cdot4^2 + 3\\cdot4^1 + 3$.\nThus, the base-$4$ representation of $G(2)$ is:\n$$G(2) = 1\\cdot4^4 + 3\\cdot4^3 + 3\\cdot4^2 + 3\\cdot4^1 + 3$$\nFor the hereditary representation, the exponents must be in base-$4$. The exponent $4$ is written as $1 \\cdot 4^1$. The exponents $3, 2, 1$ are less than the base $4$, so they are already in the correct form.\n$$H_{4}(G(2)) = 1 \\cdot 4^{4^{1}} + 3 \\cdot 4^3 + 3 \\cdot 4^2 + 3 \\cdot 4^1 + 3$$\nThe corresponding ordinal $\\alpha_2$ is:\n$$\\alpha_2 = \\Phi(H_{4}(G(2))) = \\omega^{\\Phi(4^1)} \\cdot 1 + \\omega^{\\Phi(3)} \\cdot 3 + \\omega^{\\Phi(2)} \\cdot 3 + \\omega^{\\Phi(1)} \\cdot 3 + \\Phi(3)$$\n$$\\alpha_2 = \\omega^{\\omega} + \\omega^{3} \\cdot 3 + \\omega^{2} \\cdot 3 + \\omega \\cdot 3 + 3$$\n\n**Step $k=3$:**\nThe base is $b(3) = 3+2 = 5$. We take $H_{4}(G(2))$ and change the base from $4$ to $5$:\n$$1 \\cdot 4^{4^{1}} + 3 \\cdot 4^3 + 3 \\cdot 4^2 + 3 \\cdot 4^1 + 3 \\quad \\xrightarrow{\\text{base } 4 \\to 5} \\quad 1 \\cdot 5^{5^{1}} + 3 \\cdot 5^3 + 3 \\cdot 5^2 + 3 \\cdot 5^1 + 3$$\nEvaluating numerically:\n$$5^5 + 3\\cdot5^3 + 3\\cdot5^2 + 3\\cdot5^1 + 3 = 3125 + 3\\cdot125 + 3\\cdot25 + 3\\cdot5 + 3 = 3125 + 375 + 75 + 15 + 3 = 3593$$\nSubtracting $1$ gives $G(3)$:\n$$G(3) = 3593 - 1 = 3592$$\nTo find $H_5(G(3))$, we subtract $1$ from the base-$5$ expression for $3593$. This only affects the last term:\n$$H_{5}(G(3)) = 1 \\cdot 5^{5^{1}} + 3 \\cdot 5^3 + 3 \\cdot 5^2 + 3 \\cdot 5^1 + 2$$\nThis is already in hereditary base-$5$ form, as all coefficients are less than $5$ and the exponent $5$ is written as $5^1$.\nFinally, we compute the ordinal $\\alpha_3$, which is the answer to the problem:\n$$\\alpha_3 = \\Phi(H_{5}(G(3))) = \\omega^{\\Phi(5^1)} \\cdot 1 + \\omega^{\\Phi(3)} \\cdot 3 + \\omega^{\\Phi(2)} \\cdot 3 + \\omega^{\\Phi(1)} \\cdot 3 + \\Phi(2)$$\n$$\\alpha_3 = \\omega^{\\omega} + \\omega^{3} \\cdot 3 + \\omega^{2} \\cdot 3 + \\omega \\cdot 3 + 2$$\n\n**Verification:**\nThe sequence of ordinals is:\n$\\alpha_0 = \\omega^{\\omega} \\cdot 2 + 1$\n$\\alpha_1 = \\omega^{\\omega} \\cdot 2$\n$\\alpha_2 = \\omega^{\\omega} + \\omega^{3} \\cdot 3 + \\omega^{2} \\cdot 3 + \\omega \\cdot 3 + 3$\n$\\alpha_3 = \\omega^{\\omega} + \\omega^{3} \\cdot 3 + \\omega^{2} \\cdot 3 + \\omega \\cdot 3 + 2$\nWe can verify that $\\alpha_0 > \\alpha_1 > \\alpha_2 > \\alpha_3$.\n$\\alpha_1  \\alpha_0$ because $\\omega^\\omega \\cdot 2  \\omega^\\omega \\cdot 2+1$.\n$\\alpha_2  \\alpha_1$ because $\\alpha_1 = \\omega^\\omega + \\omega^\\omega$, and the tail $\\omega^3 \\cdot 3 + \\omega^2 \\cdot 3 + \\omega \\cdot 3 + 3$ is less than $\\omega^\\omega$.\n$\\alpha_3  \\alpha_2$ because they only differ in the final term, where $2  3$.\nAll ordinals are below $\\varepsilon_0 = \\sup\\{\\omega, \\omega^\\omega, \\omega^{\\omega^\\omega}, \\dots\\}$ since their largest term is $\\omega^\\omega$.\n\nThe explicit Cantor normal form of $\\alpha_3$ is $\\omega^{\\omega} + \\omega^{3} \\cdot 3 + \\omega^{2} \\cdot 3 + \\omega \\cdot 3 + 2$.", "answer": "$$\n\\boxed{\\omega^{\\omega} + \\omega^{3} \\cdot 3 + \\omega^{2} \\cdot 3 + \\omega \\cdot 3 + 2}\n$$", "id": "2978410"}, {"introduction": "We now move from a number-theoretic analogy to the heart of proof theory: Gentzen's cut-elimination procedure. The 'cut' rule is a powerful tool for structuring proofs, but its presence can obscure the direct constructive path from axioms to conclusion. This practice guides you through the process of constructing a formal proof in Peano Arithmetic, applying a non-trivial cut, and then methodically reducing it, tracking the corresponding decrease in the proof's assigned ordinal measure [@problem_id:2978411]. This exercise makes the abstract mechanism of consistency proofs tangible and explicit.", "problem": "Consider Peano Arithmetic (PA) in Gentzen-style first-order sequent calculus with equality and the usual language of arithmetic containing the constant $0$, the unary function $S(\\cdot)$ for successor, and the binary function symbols $+,\\times$. Work within the classical sequent calculus (often denoted LK) augmented by the induction schema for PA. The structural and logical rules are standard, including the cut rule. Recall the cut rule: from $\\Gamma \\vdash \\Delta, A$ and $A, \\Sigma \\vdash \\Pi$, infer $\\Gamma, \\Sigma \\vdash \\Delta, \\Pi$. We will track cut elimination by assigning ordinals below the epsilon number $\\varepsilon_{0}$ to proofs in such a way that a local cut-reduction strictly decreases the assigned ordinal.\n\nUse the following fundamental definitions.\n\n- Define the logical rank $r(A)$ of a formula $A$ by recursion: for atomic $A$ (including $t=s$), $r(A)=0$; for $A \\vee B$ or $A \\wedge B$, $r(A \\circ B)=\\max\\{r(A),r(B)\\}$; for $A \\rightarrow B$, $r(A \\rightarrow B)=\\max\\{r(A),r(B)\\}$; for $\\forall x\\,A$ or $\\exists x\\,A$, $r(Qx\\,A)=r(A)+1$.\n- Define the logical size $s(A)$ of a formula $A$ by the number of logical symbols: for atomic $A$, $s(A)=0$; for $A \\vee B$, $s(A \\vee B)=s(A)+s(B)+1$; similarly for $A \\wedge B$ and $A \\rightarrow B$; for $Qx\\,A$ with $Q\\in\\{\\forall,\\exists\\}$, $s(Qx\\,A)=s(A)+1$.\n- For a cut-containing proof $\\mathcal{P}$, define its initial ordinal weight\n$$\nW(\\mathcal{P}) \\;=\\; \\sum_{A \\in \\mathsf{Cuts}(\\mathcal{P})} \\omega^{r(A)} \\cdot s(A),\n$$\nwhere the sum is taken in Cantor normal form, and $\\omega$ is the first infinite ordinal. For the purposes of this task, disregard any finite height contribution from non-cut inferences; focus solely on $W(\\mathcal{P})$.\n\nTask. Construct explicitly a PA sequent derivation of the arithmetical fact that every natural number is either zero or a successor, and use it via a nontrivial cut to derive the sequent\n$$\n\\vdash \\forall x\\,\\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big).\n$$\nSpecifically:\n- First, derive the lemma sequent $\\vdash \\forall x\\,\\big(x=0 \\,\\vee\\, \\exists y\\, S(y)=x\\big)$ within PA by using the induction schema on the predicate $P(x) \\equiv \\big(x=0 \\,\\vee\\, \\exists y\\, S(y)=x\\big)$.\n- Second, derive the sequent $x=0 \\,\\vee\\, \\exists y\\, S(y)=x \\;\\vdash\\; \\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$ by a case analysis on the disjunction and appropriate uses of the existential-right rule with explicit witnesses.\n- Third, combine these two derivations with a single nontrivial cut on the formula $C(x) \\equiv x=0 \\,\\vee\\, \\exists y\\, S(y)=x$ to obtain a derivation of $\\vdash \\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$, and then generalize to $\\vdash \\forall x\\,\\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$.\n\nUsing the definitions of $r(\\cdot)$ and $s(\\cdot)$, compute the initial ordinal weight $W(\\mathcal{P})$ of your cut-containing proof $\\mathcal{P}$, and then perform the standard cut-reduction steps for the cut on $C(x)$, tracking the decrease of the ordinal weight at each reduction:\n- First reduce a cut on a disjunction to cuts on its components.\n- Then reduce a cut on an existential formula to a cut on its matrix with a term witness, and finally eliminate the resulting atomic cut.\n\nVerify at each step that the ordinal weight strictly decreases and that the sequence of ordinal weights is bounded below by $0$ and lies beneath $\\varepsilon_{0}$. Conclude with the cut-free derivation. Your final reported quantity must be the explicit Cantor normal form of the initial ordinal weight $W(\\mathcal{P})$ computed from your constructed proof. Express your final answer as a single closed-form ordinal expression. No rounding is required. No physical units are involved. Angles and percentages are not applicable.", "solution": "The problem statement has been validated and is deemed sound. It presents a well-posed task within the established field of mathematical logic, specifically proof theory and ordinal analysis. All definitions and conditions are provided, and no scientific, logical, or factual inconsistencies have been identified.\n\nThe task is to construct a specific proof in Peano Arithmetic (PA) within a Gentzen-style sequent calculus, and then to compute the initial ordinal weight associated with a specified cut in that proof. The proof will establish the sequent $\\vdash \\forall x\\,\\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$.\n\nLet the formula $P(x)$ be defined as $P(x) \\equiv x=0 \\,\\vee\\, \\exists y\\, S(y)=x$. For brevity, we will also denote this formula as $C(x)$ when it serves as the cut formula.\n\n**Part 1: Derivation of the Lemma $\\vdash \\forall x\\,P(x)$**\n\nThe derivation proceeds by using the induction schema of PA. In sequent calculus, this can be formulated as a rule: if one can derive $\\vdash P(0)$ and $P(x) \\vdash P(S(x))$, one can infer $\\vdash \\forall x\\,P(x)$. We will construct derivations for these two premises.\n\n**Base Case: Derivation of $\\vdash P(0)$**\n$P(0)$ is the formula $0=0 \\vee \\exists y\\, S(y)=0$.\n1. $\\vdash 0=0$ (Logical axiom, $t=t$)\n2. $\\vdash 0=0, \\exists y\\, S(y)=0$ (Weakening Right on line 1)\n3. $\\vdash 0=0 \\vee \\exists y\\, S(y)=0$ ($\\vee$-Right on line 2)\nThis concludes the derivation of $\\vdash P(0)$.\n\n**Inductive Step: Derivation of $P(x) \\vdash P(S(x))$**\n$P(S(x))$ is the formula $S(x)=0 \\vee \\exists y\\, S(y)=S(x)$. We first derive $\\vdash P(S(x))$ directly.\n1. $\\vdash S(x)=S(x)$ (Logical axiom, $t=t$)\n2. $\\vdash \\exists y\\, S(y)=S(x)$ ($\\exists$-Right on line 1, with witness $t=x$)\n3. $\\vdash S(x)=0, \\exists y\\, S(y)=S(x)$ (Weakening Right on line 2)\n4. $\\vdash S(x)=0 \\vee \\exists y\\, S(y)=S(x)$ ($\\vee$-Right on line 3)\nThis is a derivation of $\\vdash P(S(x))$. From this, we can obtain the required sequent for the inductive step by weakening on the left:\n5. $P(x) \\vdash P(S(x))$ (Weakening Left on line 4, adding $P(x)$ to the antecedent)\n\nWith derivations for $\\vdash P(0)$ and $P(x) \\vdash P(S(x))$, the PA induction rule allows the inference of $\\vdash \\forall x\\,P(x)$. Let us denote this complete derivation of the lemma as $\\mathcal{D}_{lemma}$.\n\n**Part 2: Derivation of $P(x) \\vdash \\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$**\n\nThis derivation proceeds by case analysis on the formula $P(x) \\equiv x=0 \\vee \\exists y\\, S(y)=x$, which corresponds to the $\\vee$-Left rule in sequent calculus. Let $\\Pi(x,y)$ denote the formula $x=0 \\vee S(y)=x$.\n\n**Case 1: $x=0 \\vdash \\exists y\\,\\Pi(x,y)$**\n1. $x=0 \\vdash x=0$ (Logical axiom)\n2. $x=0 \\vdash x=0, S(0)=x$ (Weakening Right on line 1)\n3. $x=0 \\vdash x=0 \\vee S(0)=x$ ($\\vee$-Right on line 2)\n4. $x=0 \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$ ($\\exists$-Right on line 3, with witness $t=0$)\n\n**Case 2: $\\exists y\\, S(y)=x \\vdash \\exists y\\,\\Pi(x,y)$**\nThis sub-derivation uses the $\\exists$-Left rule. We assume $S(a)=x$ for a fresh eigenvariable $a$.\n1. $S(a)=x \\vdash S(a)=x$ (Logical axiom)\n2. $S(a)=x \\vdash x=0, S(a)=x$ (Weakening Right on line 1)\n3. $S(a)=x \\vdash x=0 \\vee S(a)=x$ ($\\vee$-Right on line 2)\n4. $S(a)=x \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$ ($\\exists$-Right on line 3, with witness $t=a$)\nApplying the $\\exists$-Left rule to line 4 (discharging the assumption $S(a)=x$):\n5. $\\exists y\\, S(y)=x \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$\n\n**Combining Cases:** Using the results from Case 1 and Case 2 with the $\\vee$-Left rule:\nFrom $x=0 \\vdash \\exists y\\,\\Pi(x,y)$ and $\\exists y\\, S(y)=x \\vdash \\exists y\\,\\Pi(x,y)$, we infer:\n$x=0 \\vee \\exists y\\, S(y)=x \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$.\nThis concludes the derivation, which we denote $\\mathcal{D}_{R}$.\n\n**Part 3: The Cut and Final Proof Construction**\n\nWe now assemble the final proof $\\mathcal{P}$, which involves a single specified cut on the formula $C(x) \\equiv P(x)$.\nFirst, from the lemma $\\vdash \\forall x\\,C(x)$ derived in Part 1, we obtain a derivation of $\\vdash C(x)$. This can be formally done via a cut with the axiom $\\forall x\\,C(x) \\vdash C(x)$, but for the purpose of this problem, we treat the derivation of $\\vdash C(x)$ from the lemma as a preliminary step, leading to the left premise for our main cut. Let us denote this derivation of $\\vdash C(x)$ as $\\mathcal{D}_{L}$.\n\nThe final proof construction for $\\vdash \\forall x\\,\\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$ is as follows:\n1. Apply the Cut rule with the cut formula $C(x)$:\n   - Left Premise: The derivation $\\mathcal{D}_{L}$ of $\\vdash C(x)$.\n   - Right Premise: The derivation $\\mathcal{D}_{R}$ of $C(x) \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$.\n   The conclusion is the sequent $\\vdash \\exists y\\,(x=0 \\vee S(y)=x)$. Let this cut-containing proof be $\\mathcal{P}$.\n2. Apply the $\\forall$-Right rule to generalize on the free variable $x$:\n   $\\vdash \\forall x\\,\\exists y\\,(x=0 \\vee S(y)=x)$. The variable $x$ is not free in the context (which is empty), so this step is valid.\n\nThe problem asks for the ordinal weight of the proof $\\mathcal{P}$ before this final generalization step. The only cut we are instructed to consider is the one on $C(x)$.\n\n**Computation of the Initial Ordinal Weight $W(\\mathcal{P})$**\n\nThe initial weight is given by $W(\\mathcal{P}) = \\sum_{A \\in \\mathsf{Cuts}(\\mathcal{P})} \\omega^{r(A)} \\cdot s(A)$.\nIn our construction, there is a single cut on the formula $A = C(x) = x=0 \\vee \\exists y\\, S(y)=x$. Thus, the weight is $W(\\mathcal{P}) = \\omega^{r(C(x))} \\cdot s(C(x))$.\n\nWe compute the rank $r(C(x))$ and size $s(C(x))$ using the provided definitions.\nLet $C_1 \\equiv x=0$ and $C_2 \\equiv \\exists y\\, S(y)=x$.\nThe formula $S(y)=x$ is atomic. Per the definitions:\n- $r(S(y)=x) = 0$\n- $s(S(y)=x) = 0$\n\nFor $C_1 \\equiv x=0$, which is atomic:\n- $r(C_1) = 0$\n- $s(C_1) = 0$\n\nFor $C_2 \\equiv \\exists y\\, S(y)=x$:\n- $r(C_2) = r(S(y)=x) + 1 = 0 + 1 = 1$\n- $s(C_2) = s(S(y)=x) + 1 = 0 + 1 = 1$\n\nFor the cut formula $C(x) = C_1 \\vee C_2$:\n- $r(C(x)) = \\max\\{r(C_1), r(C_2)\\} = \\max\\{0, 1\\} = 1$\n- $s(C(x)) = s(C_1) + s(C_2) + 1 = 0 + 1 + 1 = 2$\n\nThe initial ordinal weight of the proof $\\mathcal{P}$ is therefore:\n$W(\\mathcal{P}) = \\omega^{r(C(x))} \\cdot s(C(x)) = \\omega^{1} \\cdot 2 = \\omega \\cdot 2$.\n\n**Analysis of Cut-Elimination and Ordinal Decrease**\n\nThe cut-elimination procedure systematically reduces the complexity of cuts, strictly decreasing the assigned ordinal at each step until a cut-free proof is obtained.\n\n1.  **Initial State:** The proof has one cut on $C(x) = (x=0) \\vee (\\exists y\\,S(y)=x)$. The ordinal weight is $W_0 = \\omega \\cdot 2$.\n\n2.  **First Reduction:** The cut formula is a disjunction. The right premise of the cut, $C(x) \\vdash \\exists y\\,\\Pi(x,y)$, was derived principally using the $\\vee$-Left rule. The cut on the disjunction is reduced to two new cuts on its components, $C_1 \\equiv x=0$ and $C_2 \\equiv \\exists y\\,S(y)=x$. The ordinal weight of the new proof is the ordinal sum of the weights of these new cuts:\n    $W_1 = (\\omega^{r(C_1)} \\cdot s(C_1)) + (\\omega^{r(C_2)} \\cdot s(C_2))$\n    $W_1 = (\\omega^0 \\cdot 0) + (\\omega^1 \\cdot 1) = 0 + \\omega = \\omega$.\n    We verify the strict decrease: $W_1 = \\omega  \\omega \\cdot 2 = W_0$.\n\n3.  **Second Reduction:** The proof now contains two cuts.\n    - The cut on the atomic formula $C_1 \\equiv x=0$ is eliminated directly (as any such cut must ultimately trace back to an axiom $A \\vdash A$). Its contribution to the ordinal weight becomes $0$.\n    - The remaining cut is on the formula $C_2 \\equiv \\exists y\\,S(y)=x$. The right premise of this cut (from Part 2, Case 2) was derived using $\\exists$-Left. The reduction replaces this cut on an existential formula with a cut on its matrix, $S(y)=x$, where the eigenvariable is substituted by the witness from the corresponding $\\exists$-Right rule in the left premise. The resulting cut formula is atomic. The new weight is:\n    $W_2 = \\omega^{r(S(t)=x)} \\cdot s(S(t)=x) = \\omega^0 \\cdot 0 = 0$.\n    We verify the strict decrease: $W_2 = 0  \\omega = W_1$.\n\n4.  **Final State:** After the second reduction, any remaining cuts are on atomic formulas, which are then eliminated. The final proof is cut-free, and its ordinal weight is $0$.\n\nThe sequence of ordinal weights is $\\omega \\cdot 2 \\rightarrow \\omega \\rightarrow 0$. This confirms a strict decrease at each reduction step. All ordinals in this sequence are less than $\\varepsilon_0$, as required.\n\nThe final answer requested is the initial ordinal weight of the constructed proof $\\mathcal{P}$.", "answer": "$$\n\\boxed{\\omega \\cdot 2}\n$$", "id": "2978411"}, {"introduction": "The termination of cut-elimination is not a coincidence but a deep structural property of logical deduction. This final practice moves from a single example to the general principle by asking you to formalize the ordinal reduction step as an algorithm. You will implement a representation of ordinals and model the transformation of a proof's complexity measure, programmatically verifying that every cut-reduction step necessarily leads to a strictly smaller ordinal [@problem_id:2978413]. This computational approach solidifies the understanding that the well-ordering of ordinals is the ultimate guarantor of consistency.", "problem": "You are asked to formalize a single-cut reduction step in the Gentzen-style sequent calculus for Peano Arithmetic (PA, Peano Arithmetic) and to verify the strict decrease of the assigned ordinal measure under this reduction. Work entirely within the well-founded ordinal notation system below the ordinal $\\varepsilon_{0}$, using Cantor Normal Form.\n\nThe fundamental base consists of:\n- Definitions of ordinal arithmetic below $\\varepsilon_{0}$ via Cantor Normal Form: every ordinal $\\alpha lt; \\varepsilon_{0}$ is uniquely written as $$\\alpha = \\omega^{\\alpha_{1}} \\cdot c_{1} + \\omega^{\\alpha_{2}} \\cdot c_{2} + \\cdots + \\omega^{\\alpha_{k}} \\cdot c_{k},$$ with $k \\in \\mathbb{N}$, $c_{i} \\in \\mathbb{N}$, and $\\alpha_{1} \\geq \\alpha_{2} \\geq \\cdots \\geq \\alpha_{k}$, and each exponent $\\alpha_{i}$ is itself an ordinal below $\\varepsilon_{0}$.\n- The cut rule in the sequent calculus for PA and the notion of a single cut on a formula of rank $r \\in \\mathbb{N}$.\n- The requirement that ordinal measures assigned to proofs must strictly decrease under a cut-reduction step to ensure termination of cut elimination.\n\nTasks:\n1. Construct an explicit reduction procedure, denoted $\\mathrm{CutReduce}$, which transforms a proof containing a single cut on a formula of rank $r$ into a proof with either no cut at rank $r$ or cuts only at ranks strictly less than $r$. Your design should capture the combinatorial effect of duplicating subderivations on the measure but must ensure that the leading ordinal term associated to rank $r$ is removed or strictly reduced.\n2. Define an ordinal measure $\\mu(P)$ for such a proof $P$ of the form $$\\mu(P) = \\omega^{r} \\cdot h + \\sigma,$$ where $h \\in \\mathbb{N}$ reflects the combined heights of the left and right derivations whose cut is being reduced, and $\\sigma$ is a background ordinal strictly less than $\\omega^{r}$ capturing the contribution of lower-rank structure. Your assignment must be consistent with Cantor Normal Form and must map to ordinals below $\\varepsilon_{0}$.\n3. Prove that the reduction procedure $\\mathrm{CutReduce}$ strictly decreases the ordinal measure: $$\\mu\\bigl(\\mathrm{CutReduce}(P)\\bigr) lt; \\mu(P).$$\n\nImplementation requirements:\n- Represent ordinals below $\\varepsilon_{0}$ in Cantor Normal Form, with recursive exponents and positive integer coefficients. Use a data structure that enforces decreasing exponents and merges adjacent terms with equal exponents.\n- Implement comparison on ordinals in Cantor Normal Form that realizes the standard well-ordering: compare leading exponents lexicographically and, when equal, compare coefficients, proceeding to lower terms thereafter.\n- Implement the measure constructor $$\\mu(r, h_{L}, h_{R}, \\sigma) = \\omega^{r} \\cdot (h_{L} + h_{R}) + \\sigma,$$ with $\\sigma$ given in Cantor Normal Form and all its exponents strictly less than $r$. Here $h_{L}, h_{R} \\in \\mathbb{N}$.\n- Implement the reduction step $\\mathrm{CutReduce}$ that outputs a new measure $$\\mu'(r, h_{L}, h_{R}, \\sigma) = \\begin{cases}\n\\sigma  \\text{if } r = 0,\\\\\n\\omega^{r-1} \\cdot k + \\sigma  \\text{if } r \\geq 1,\n\\end{cases}$$ with $k \\in \\mathbb{N}$ determined by the combinatorics of duplicating subderivations. Choose a concrete $k$ that depends monotonically on $h_{L}$ and $h_{R}$ and is positive whenever the cut is nontrivial, for example $k = h_{L} \\cdot h_{R} + h_{L} + h_{R} + 1$.\n- Verify programmatically, for a small test suite, that the measure strictly decreases under this reduction.\n\nTest suite:\nFor each test case, the input is $(r, h_{L}, h_{R}, \\sigma)$, where $\\sigma$ is a list of pairs $(e_{i}, c_{i})$ encoding $\\omega^{e_{i}} \\cdot c_{i}$ with $e_{i} \\in \\mathbb{N}$ and $c_{i} \\in \\mathbb{N}$, sorted by decreasing $e_{i}$, and with $e_{i} lt; r$. The program must compute whether\n$$\\mu'(r, h_{L}, h_{R}, \\sigma) lt; \\mu(r, h_{L}, h_{R}, \\sigma)$$\nholds, returning a boolean for each case.\n\nUse the following test cases:\n- Case A (general case): $r = 3$, $h_{L} = 2$, $h_{R} = 3$, $\\sigma = [\\, (2, 1), (1, 4) \\,]$.\n- Case B (boundary case for smallest nontrivial rank): $r = 1$, $h_{L} = 1$, $h_{R} = 1$, $\\sigma = [\\, ]$.\n- Case C (higher rank, nontrivial background): $r = 5$, $h_{L} = 4$, $h_{R} = 1$, $\\sigma = [\\, (3, 2), (2, 1), (1, 7) \\,]$.\n- Case D (edge case with zero height on one side, finite tail): $r = 2$, $h_{L} = 0$, $h_{R} = 5$, $\\sigma = [\\, (1, 1), (0, 10) \\,]$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is a boolean indicating whether the measure strictly decreases for the corresponding test case. No additional text should be printed.", "solution": "The problem is valid. It is a well-posed and scientifically grounded exercise in proof theory, a subfield of mathematical logic. It asks for the formalization and verification of a key step in Gentzen's cut-elimination proof for Peano Arithmetic, specifically demonstrating the decrease of an ordinal measure, which is the cornerstone of the termination argument for the procedure. All definitions and parameters are provided, and the problem is self-contained and objective.\n\nHere is the reasoned solution:\n\nThis problem concerns the ordinal analysis of proofs in a Gentzen-style sequent calculus for Peano Arithmetic ($PA$). The central result in this area is Gentzen's cut-elimination theorem, which states that any proof using the `cut` rule can be transformed into a cut-free proof of the same end-sequent. The proof of this theorem is constructive: it provides an explicit algorithm that systematically removes cuts. To prove that this algorithm terminates, one assigns an ordinal from a well-ordered set to each proof. Each step of the reduction algorithm must correspond to a strict decrease in this assigned ordinal. Since there are no infinite descending chains of ordinals, the process must terminate. For $PA$, the required set of ordinals is the segment below the ordinal $\\varepsilon_0$.\n\n**1. Ordinal Representation and Comparison**\n\nOrdinals below $\\varepsilon_0$ are represented using Cantor Normal Form (CNF). An ordinal $\\alpha  \\varepsilon_0$ has a unique representation as a finite sum:\n$$ \\alpha = \\omega^{\\alpha_1} \\cdot c_1 + \\omega^{\\alpha_2} \\cdot c_2 + \\dots + \\omega^{\\alpha_k} \\cdot c_k $$\nwhere $k$ is a non-negative integer, the coefficients $c_i$ are positive integers, and the exponents $\\alpha_i$ are themselves ordinals satisfying $\\alpha  \\alpha_1 \\geq \\alpha_2 \\geq \\dots \\geq \\alpha_k \\geq 0$.\n\nThe problem simplifies this general structure by specifying that all exponents ($r$ and the $e_i$ in $\\sigma$) are natural numbers, i.e., $r, e_i \\in \\mathbb{N}$. This restricts our focus to ordinals below $\\omega^\\omega$, which is a proper initial segment of the ordinals below $\\varepsilon_0$.\n\nOrdinal comparison is lexicographical. Given two ordinals in CNF,\n$$ \\alpha = \\omega^{a_1} \\cdot c_1 + \\omega^{a_2} \\cdot c_2 + \\dots $$\n$$ \\beta = \\omega^{b_1} \\cdot d_1 + \\omega^{b_2} \\cdot d_2 + \\dots $$\nwe say $\\beta  \\alpha$ if, at the first index $i$ where the terms differ, we have either $b_i  a_i$, or $b_i = a_i$ and $d_i  c_i$. If the sequence of terms for $\\beta$ is a proper prefix of the sequence for $\\alpha$, then $\\beta  \\alpha$.\n\n**2. Ordinal Measures for Proofs**\n\nThe problem defines an ordinal measure $\\mu(P)$ for a proof $P$ containing a specific cut. The cut is on a formula of logical complexity, or rank, $r \\in \\mathbb{N}$. The premises for the cut rule are derived by sub-proofs of heights $h_L, h_R \\in \\mathbb{N}$. The measure is:\n$$ \\mu(P) \\equiv \\mu(r, h_L, h_R, \\sigma) = \\omega^r \\cdot (h_L + h_R) + \\sigma $$\nHere, $\\sigma$ is an ordinal representing the complexity contribution from all other parts of the proof. A crucial condition is that all exponents in the CNF of $\\sigma$ are strictly less than $r$. This ensures that $\\omega^r \\cdot (h_L + h_R)$ is the leading term of $\\mu(P)$ whenever $h_L+h_R  0$.\n\n**3. The Cut-Reduction Step**\n\nThe core of Gentzen's procedure is to reduce a cut on a formula of rank $r$ to one or more cuts on formulas of rank strictly less than $r$. The problem models the effect of this reduction, $\\mathrm{CutReduce}$, on the ordinal measure. The new measure, $\\mu'$, is given by:\n$$ \\mu'(r, h_L, h_R, \\sigma) = \\begin{cases} \\sigma  \\text{if } r = 0 \\\\ \\omega^{r-1} \\cdot k + \\sigma  \\text{if } r \\ge 1 \\end{cases} $$\nwhere $k = h_L \\cdot h_R + h_L + h_R + 1$. The integer $k$ combinatorially reflects the number and complexity of the new, lower-rank cuts that are introduced. When reducing a cut of rank $r \\ge 1$, the principal formula is broken down, and the sub-derivations are duplicated, leading to multiple cuts of rank $r-1$. The value of $k$ bounds the complexity of this new configuration.\n\n**4. Verification of Ordinal Decrease**\n\nWe must prove that $\\mu'  \\mu$. We analyze the two cases for $r$.\n\n**Case 1: $r \\ge 1$.**\nIn this case, the measures are:\n$$ \\mu = \\omega^r \\cdot (h_L + h_R) + \\sigma $$\n$$ \\mu' = \\omega^{r-1} \\cdot k + \\sigma $$\nA non-trivial cut implies that the derivations of its premises are not empty, meaning at least one of $h_L$ or $h_R$ is positive. All test cases satisfy $h_L+h_R  0$. Under this condition, the coefficient $(h_L+h_R)$ of the $\\omega^r$ term in $\\mu$ is a positive integer.\n\nThe CNF of $\\mu$ is $\\mu = \\omega^r \\cdot (h_L + h_R) + (\\text{terms with exponents}  r)$. Its leading exponent is $r$.\nThe measure $\\mu'$ is the ordinal sum of $\\omega^{r-1} \\cdot k$ and $\\sigma$. The exponents in $\\sigma$ are all less than $r$. Therefore, after performing the addition and normalizing to CNF, the largest possible exponent in $\\mu'$ is $\\max(r-1, \\text{exponents of } \\sigma)$. Since all exponents in $\\sigma$ are less than $r$, this maximum is $r-1$.\nSo, the leading exponent of $\\mu$ is $r$, and the leading exponent of $\\mu'$ is $r-1$.\nBy the definition of ordinal comparison, since $r-1  r$, it immediately follows that $\\mu'  \\mu$.\n\n**Case 2: $r = 0$.**\nA rank-$0$ cut is a cut on an atomic formula. This is the base case for the reduction. The rule for $\\mu'$ specifies that the cut is completely removed:\n$$ \\mu = \\omega^0 \\cdot (h_L + h_R) + \\sigma = 1 \\cdot (h_L + h_R) + \\sigma = (h_L+h_R) + \\sigma $$\n$$ \\mu' = \\sigma $$\nGiven a non-trivial cut, $h_L+h_R  0$. Since ordinal addition is not commutative in general, we must be precise. The term $(h_L+h_R)$ is an ordinal of the form $\\omega^0 \\cdot (h_L+h_R)$. Since the smallest exponent in $\\sigma$ can be $0$ (but less than $r=0$ is impossible, so $\\sigma=0$ if we strictly follow $e_ir$), let's assume the problem allows $e_i \\geq 0$ within $\\sigma$ as long as $e_i  r$. For $r=0$, this implies $\\sigma$ must be $0$. In this case, $\\mu=h_L+h_R$ and $\\mu'=0$. Clearly $\\mu'  \\mu$ for $h_L+h_R0$. More generally, if $\\sigma$ could be non-zero, adding a positive integer $(h_L+h_R)$ to an ordinal $\\sigma$ strictly increases it, so $\\sigma  (h_L+h_R) + \\sigma$. Thus $\\mu'  \\mu$.\n\nIn all valid reduction scenarios, the ordinal measure strictly decreases. This guarantees that repeated application of the reduction procedure must terminate, establishing the cut-elimination result. The programmatic implementation below will verify this inequality for the specific test cases provided.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying ordinal decrease in a simulated\n    cut-elimination step for Peano Arithmetic.\n    \"\"\"\n\n    class Ordinal:\n        \"\"\"\n        Represents an ordinal below omega^omega in Cantor Normal Form.\n        The ordinal is stored as a list of (exponent, coefficient) tuples,\n        sorted in descending order of exponents. Exponents are integers.\n        \"\"\"\n        def __init__(self, terms=None):\n            \"\"\"\n            Initializes an Ordinal object.\n            Args:\n                terms (list, optional): A list of (exponent, coefficient) tuples.\n                                        Defaults to an empty list, representing the ordinal 0.\n            \"\"\"\n            if terms is None:\n                self.terms = []\n            else:\n                self.terms = self._normalize(terms)\n\n        @staticmethod\n        def _normalize(terms):\n            \"\"\"\n            Normalizes a list of terms into Cantor Normal Form:\n            1. Filters out terms with zero or negative coefficients.\n            2. Sorts terms by exponent in descending order.\n            3. Merges terms with identical exponents by summing their coefficients.\n            \"\"\"\n            # Filter terms with positive coefficients\n            filtered_terms = [t for t in terms if t[1] > 0]\n            if not filtered_terms:\n                return []\n\n            # Sort by exponent, descending\n            filtered_terms.sort(key=lambda t: t[0], reverse=True)\n\n            # Merge terms with same exponent\n            if len(filtered_terms) = 1:\n                return filtered_terms\n\n            merged = []\n            current_exp, current_coeff = filtered_terms[0]\n\n            for next_exp, next_coeff in filtered_terms[1:]:\n                if next_exp == current_exp:\n                    current_coeff += next_coeff\n                else:\n                    merged.append((current_exp, current_coeff))\n                    current_exp, current_coeff = next_exp, next_coeff\n            \n            merged.append((current_exp, current_coeff))\n            return merged\n\n        def __add__(self, other):\n            \"\"\"\n            Implements ordinal addition.\n            \"\"\"\n            if not isinstance(other, Ordinal):\n                return NotImplemented\n            # Concatenate term lists and re-normalize\n            new_terms = self.terms + other.terms\n            return Ordinal(new_terms)\n\n        def __lt__(self, other):\n            \"\"\"\n            Implements strict less-than comparison () for ordinals.\n            \"\"\"\n            if not isinstance(other, Ordinal):\n                return NotImplemented\n            \n            terms1 = self.terms\n            terms2 = other.terms\n            \n            i, j = 0, 0\n            while i  len(terms1) and j  len(terms2):\n                exp1, coef1 = terms1[i]\n                exp2, coef2 = terms2[j]\n\n                if exp1  exp2:\n                    return True  # self is smaller\n                if exp1  exp2:\n                    return False  # self is larger\n\n                # Exponents are equal, compare coefficients\n                if coef1  coef2:\n                    return True  # self is smaller\n                if coef1  coef2:\n                    return False  # self is larger\n\n                # Terms are identical, move to the next\n                i += 1\n                j += 1\n            \n            # One list is exhausted. If self is exhausted but other is not, self is smaller.\n            if i == len(terms1) and j  len(terms2):\n                return True\n            \n            # If other is exhausted, or both are, self is not strictly smaller.\n            return False\n\n        def __eq__(self, other):\n            \"\"\"\n            Implements equality comparison (==) for ordinals.\n            \"\"\"\n            if not isinstance(other, Ordinal):\n                return NotImplemented\n            return self.terms == other.terms\n\n        def __repr__(self):\n            \"\"\"\n            Provides a string representation for debugging purposes.\n            \"\"\"\n            if not self.terms:\n                return \"0\"\n            return \" + \".join([f\"w^{e}*{c}\" for e, c in self.terms])\n\n    def construct_mu(r, hL, hR, sigma_list):\n        \"\"\"\n        Constructs the ordinal measure mu = omega^r * (hL + hR) + sigma.\n        \"\"\"\n        h_sum = hL + hR\n        sigma_ord = Ordinal(sigma_list)\n        \n        if h_sum  0:\n            term_r = Ordinal([(r, h_sum)])\n            return term_r + sigma_ord\n        else:\n            return sigma_ord\n\n    def construct_mu_prime(r, hL, hR, sigma_list):\n        \"\"\"\n        Constructs the reduced ordinal measure mu'.\n        \"\"\"\n        sigma_ord = Ordinal(sigma_list)\n\n        if r == 0:\n            # For r=0, the cut is removed, the measure becomes sigma.\n            # The prompt condition e_i  r means sigma_list should be empty.\n            # We follow the formula mu' = sigma.\n            return sigma_ord\n        \n        # For r = 1\n        k = hL * hR + hL + hR + 1\n        \n        if k  0:\n            term_r_minus_1 = Ordinal([(r - 1, k)])\n            return term_r_minus_1 + sigma_ord\n        else:\n            # k is only 0 if hL, hR are not non-negative integers.\n            # For hL, hR in N, k = 1.\n            return sigma_ord\n\n    test_cases = [\n        # Case A: r=3, hL=2, hR=3, sigma=[(2,1), (1,4)]\n        (3, 2, 3, [(2, 1), (1, 4)]),\n        # Case B: r=1, hL=1, hR=1, sigma=[]\n        (1, 1, 1, []),\n        # Case C: r=5, hL=4, hR=1, sigma=[(3,2), (2,1), (1,7)]\n        (5, 4, 1, [(3, 2), (2, 1), (1, 7)]),\n        # Case D: r=2, hL=0, hR=5, sigma=[(1,1), (0,10)]\n        (2, 0, 5, [(1, 1), (0, 10)]),\n    ]\n\n    results = []\n    for r, hL, hR, sigma_list in test_cases:\n        mu = construct_mu(r, hL, hR, sigma_list)\n        mu_prime = construct_mu_prime(r, hL, hR, sigma_list)\n        results.append(mu_prime  mu)\n\n    # Format output as a single line: [result1,result2,...]\n    print(f\"[{','.join(map(str, results)).lower()}]\")\n\nsolve()\n```", "id": "2978413"}]}