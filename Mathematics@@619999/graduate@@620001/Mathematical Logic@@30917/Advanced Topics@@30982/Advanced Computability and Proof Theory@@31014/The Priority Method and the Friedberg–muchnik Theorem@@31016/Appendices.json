{"hands_on_practices": [{"introduction": "The priority method comes to life through a step-by-step simulation. This exercise guides you through the first few stages of a simplified Friedberg-Muchnik construction, allowing you to directly observe the interplay between requirements, restraints, and injuries. By manually tracking the evolving sets $A$ and $B$, you will gain a concrete, working understanding of the core mechanics that power this elegant proof technique. [@problem_id:2986940]", "problem": "Consider the classical Friedberg–Muchnik construction of two incomparable computably enumerable (c.e.) sets, focusing only on the two lowest-priority diagonalization requirements $R_{0}^{A}$ and $R_{0}^{B}$. For this problem, fix a concrete enumeration of Turing functionals $\\left(\\Phi_{e}\\right)_{e \\in \\mathbb{N}}$ as follows, where $\\Phi_{e}^{X}$ denotes the $e$th partial functional acting with oracle $X$:\n\n1. $\\Phi_{0}^{X}(y)$: on input $y$, query $X(0), X(1), \\ldots, X(y)$ and output $X(y)$. Its use is $u_{0}(y) = y$.\n2. $\\Phi_{1}^{X}(y)$: on input $y$, query $X(0), X(1), \\ldots, X(y)$ and output $\\left(\\sum_{i=0}^{y} X(i)\\right) \\bmod 2$. Its use is $u_{1}(y) = y$.\n\nIn the diagonalization requirements, $R_{0}^{B}$ attempts to ensure that $\\Phi_{0}^{B} \\neq A$ (pointwise inequality of characteristic functions) and $R_{0}^{A}$ attempts to ensure that $\\Phi_{1}^{A} \\neq B$. To make the stage simulation concrete and to expose the mechanism of restraints and injuries, assume each of $R_{0}^{B}$ and $R_{0}^{A}$ aims to meet a stronger version of its requirement by forcing disagreement at infinitely many inputs, choosing at each of its stages the least fresh witness above currently known restraints.\n\nAdopt the following stage schedule and priority discipline:\n\n- Priority order: $R_{0}^{B} \\succ R_{0}^{A}$.\n- Stages $s \\in \\mathbb{N}$ proceed alternately by requirement: if $s$ is even, act for $R_{0}^{B}$; if $s$ is odd, act for $R_{0}^{A}$.\n- At its stage, $R_{0}^{B}$ chooses the least fresh $y$ not yet used by $R_{0}^{B}$, and attempts to satisfy $\\Phi_{0}^{B}(y) \\neq A(y)$ by enumerating into $A(y)$ if necessary. It then sets or updates its restraint on $B$ to $r_{0}^{B} := \\max\\{r_{0}^{B}, u_{0}(y)\\}$.\n- At its stage, $R_{0}^{A}$ chooses the least fresh $y$ strictly greater than the current restraint $r_{0}^{B}$ and attempts to satisfy $\\Phi_{1}^{A}(y) \\neq B(y)$ by enumerating into $B(y)$ if necessary. It then sets or updates its restraint on $A$ to $r_{0}^{A} := \\max\\{r_{0}^{A}, u_{1}(y)\\}$.\n- Lower-priority actions must respect higher-priority restraints: $R_{0}^{A}$ never enumerates into $B(z)$ for $z \\leq r_{0}^{B}$. Likewise, any action that changes $A(z)$ with $z \\leq r_{0}^{A}$ constitutes an injury to $R_{0}^{A}$’s current computation; any action that changes $B(z)$ with $z \\leq r_{0}^{B}$ would constitute an injury to $R_{0}^{B}$’s current computation. For this two-requirement simulation, only actions by $R_{0}^{B}$ can injure $R_{0}^{A}$, since $R_{0}^{B}$ has higher priority.\n\nInitialize at stage $s = 0$ with $A = \\emptyset$, $B = \\emptyset$, $r_{0}^{B} = -1$, and $r_{0}^{A} = -1$. For stages $s = 0, 1, 2, 3, 4, 5$, carry out the construction exactly as dictated above, tracking the computations, uses, restraints, and whether an injury occurs.\n\nQuestion. Let $I_{0}^{A}$ be the total number of injuries suffered by $R_{0}^{A}$ by the end of stage $s = 5$, and let $I_{0}^{B}$ be the total number of injuries suffered by $R_{0}^{B}$ by the end of stage $s = 5$. Compute the row matrix $\\begin{pmatrix} I_{0}^{A} & I_{0}^{B} \\end{pmatrix}$.", "solution": "The problem asks for a detailed simulation of the first six stages ($s=0, \\ldots, 5$) of a simplified Friedberg-Muchnik construction for two computably enumerable sets, $A$ and $B$. We must track the state of the construction—the sets $A$ and $B$, the restraints $r_{0}^{A}$ and $r_{0}^{B}$, and the number of injuries to each requirement—to determine the total injuries $I_{0}^{A}$ and $I_{0}^{B}$.\n\nWe are given two requirements:\n1.  $R_{0}^{B}: \\Phi_{0}^{B} \\neq A$ with priority over $R_{0}^{A}$.\n2.  $R_{0}^{A}: \\Phi_{1}^{A} \\neq B$.\n\nThe Turing functionals are defined as:\n- $\\Phi_{0}^{X}(y) = X(y)$, with use $u_{0}(y) = y$.\n- $\\Phi_{1}^{X}(y) = \\left(\\sum_{i=0}^{y} X(i)\\right) \\bmod 2$, with use $u_{1}(y) = y$.\n\nAn injury to requirement $R_{0}^{Q}$ (for $Q \\in \\{A, B\\}$) occurs if the oracle set for the other requirement is modified on an input less than or equal to the restraint imposed by $R_0^Q$. Specifically:\n- An injury to $R_{0}^{A}$ occurs if $A(z)$ is changed for some $z \\leq r_{0}^{A}$.\n- An injury to $R_{0}^{B}$ occurs if $B(z)$ is changed for some $z \\leq r_{0}^{B}$.\n\nThe lower-priority requirement $R_{0}^{A}$ must respect the restraint of the higher-priority requirement $R_{0}^{B}$. Thus, $R_{0}^{A}$ can never enumerate a number $z \\leq r_{0}^{B}$ into $B$. This implies that $R_{0}^{A}$ can never injure $R_{0}^{B}$. Therefore, we can immediately conclude that $I_{0}^{B} = 0$. We will verify this through the simulation.\n\nThe initial state at the beginning of stage $s=0$ is:\n- $A_0 = \\emptyset$ (characteristic function is $0$ everywhere)\n- $B_0 = \\emptyset$ (characteristic function is $0$ everywhere)\n- $r_{0,0}^{A} = -1$\n- $r_{0,0}^{B} = -1$\n- $I_{0}^{A} = 0$, $I_{0}^{B} = 0$\n- $W_A = \\emptyset$, $W_B = \\emptyset$ (sets of witnesses used by each requirement)\n\nWe proceed stage by stage. For any set $S$, we denote its state at the beginning of stage $s$ as $S_s$.\n\n**Stage $s=0$ (Action for $R_{0}^{B}$)**\n- $R_{0}^{B}$ acts. It chooses the least fresh witness $y$ not yet used. The least such $y$ is $0$.\n- We check if $\\Phi_{0}^{B_0}(0) \\neq A_0(0)$.\n- $\\Phi_{0}^{B_0}(0) = B_0(0) = 0$.\n- $A_0(0) = 0$.\n- Since $\\Phi_{0}^{B_0}(0) = A_0(0)$, $R_{0}^{B}$ acts to create a disagreement. It enumerates $0$ into $A$. The resulting set is $A_1 = \\{0\\}$.\n- An injury to $R_{0}^{A}$ would occur if we changed $A(z)$ for $z \\leq r_{0,0}^{A}$. Here, $z=0$ and $r_{0,0}^{A} = -1$. Since $0 \\not\\leq -1$, no injury occurs.\n- $R_{0}^{B}$ updates its restraint: $r_{0,1}^{B} = \\max(r_{0,0}^{B}, u_{0}(0)) = \\max(-1, 0) = 0$.\n- State at end of stage $0$: $A_1 = \\{0\\}$, $B_1 = \\emptyset$, $r_{0,1}^{A} = -1$, $r_{0,1}^{B} = 0$, $I_{0}^{A} = 0$, $I_{0}^{B} = 0$.\n\n**Stage $s=1$ (Action for $R_{0}^{A}$)**\n- $R_{0}^{A}$ acts. It chooses the least fresh witness $y$ such that $y > r_{0,1}^{B}$. The current restraint is $r_{0,1}^{B} = 0$. The least fresh witness for $R_0^A$ greater than $0$ is $y=1$.\n- We check if $\\Phi_{1}^{A_1}(1) \\neq B_1(1)$.\n- $\\Phi_{1}^{A_1}(1) = (A_1(0) + A_1(1)) \\bmod 2 = (1 + 0) \\bmod 2 = 1$.\n- $B_1(1) = 0$.\n- Since $\\Phi_{1}^{A_1}(1) \\neq B_1(1)$, the requirement is already satisfied for this witness. No action is taken.\n- $R_{0}^{A}$ updates its restraint: $r_{0,2}^{A} = \\max(r_{0,1}^{A}, u_{1}(1)) = \\max(-1, 1) = 1$.\n- State at end of stage $1$: $A_2 = \\{0\\}$, $B_2 = \\emptyset$, $r_{0,2}^{A} = 1$, $r_{0,2}^{B} = 0$, $I_{0}^{A} = 0$, $I_{0}^{B} = 0$.\n\n**Stage $s=2$ (Action for $R_{0}^{B}$)**\n- $R_{0}^{B}$ acts. It chooses the least fresh witness, which is $y=1$.\n- We check if $\\Phi_{0}^{B_2}(1) \\neq A_2(1)$.\n- $\\Phi_{0}^{B_2}(1) = B_2(1) = 0$.\n- $A_2(1) = 0$.\n- Since $\\Phi_{0}^{B_2}(1) = A_2(1)$, $R_{0}^{B}$ acts by enumerating $1$ into $A$. The resulting set is $A_3 = \\{0, 1\\}$.\n- We check for injury to $R_{0}^{A}$. We changed $A(1)$. The current restraint for $R_{0}^{A}$ is $r_{0,2}^{A} = 1$. Since $1 \\leq r_{0,2}^{A}$, an **injury occurs**. We increment the injury count: $I_{0}^{A} = 1$. An injury invalidates the computation that established the restraint, so $r_0^A$ is reset to its initial value, $-1$.\n- $R_{0}^{B}$ updates its restraint: $r_{0,3}^{B} = \\max(r_{0,2}^{B}, u_{0}(1)) = \\max(0, 1) = 1$.\n- State at end of stage $2$: $A_3 = \\{0, 1\\}$, $B_3 = \\emptyset$, $r_{0,3}^{A} = -1$ (reset), $r_{0,3}^{B} = 1$, $I_{0}^{A} = 1$, $I_{0}^{B} = 0$.\n\n**Stage $s=3$ (Action for $R_{0}^{A}$)**\n- $R_{0}^{A}$ acts. It chooses the least fresh witness $y$ such that $y > r_{0,3}^{B}$. The restraint is $r_{0,3}^{B} = 1$. The least fresh witness greater than $1$ is $y=2$.\n- We check if $\\Phi_{1}^{A_3}(2) \\neq B_3(2)$.\n- $\\Phi_{1}^{A_3}(2) = (A_3(0) + A_3(1) + A_3(2)) \\bmod 2 = (1 + 1 + 0) \\bmod 2 = 0$.\n- $B_3(2) = 0$.\n- Since $\\Phi_{1}^{A_3}(2) = B_3(2)$, $R_{0}^{A}$ acts. It must respect $r_{0,3}^{B}=1$, so it can only enumerate into $B$ at positions $z > 1$. It enumerates $2$ into $B$. The resulting set is $B_4 = \\{2\\}$.\n- We check for injury to $R_{0}^{B}$. We changed $B(2)$. The restraint is $r_{0,3}^{B} = 1$. Since $2 \\not\\leq 1$, no injury occurs.\n- $R_{0}^{A}$ updates its restraint: $r_{0,4}^{A} = \\max(r_{0,3}^{A}, u_{1}(2)) = \\max(-1, 2) = 2$.\n- State at end of stage $3$: $A_4 = \\{0, 1\\}$, $B_4 = \\{2\\}$, $r_{0,4}^{A} = 2$, $r_{0,4}^{B} = 1$, $I_{0}^{A} = 1$, $I_{0}^{B} = 0$.\n\n**Stage $s=4$ (Action for $R_{0}^{B}$)**\n- $R_{0}^{B}$ acts. It chooses the least fresh witness, which is $y=2$.\n- We check if $\\Phi_{0}^{B_4}(2) \\neq A_4(2)$.\n- $\\Phi_{0}^{B_4}(2) = B_4(2) = 1$.\n- $A_4(2) = 0$.\n- Since $\\Phi_{0}^{B_4}(2) \\neq A_4(2)$, the requirement is already satisfied. No action is taken.\n- $R_{0}^{B}$ updates its restraint: $r_{0,5}^{B} = \\max(r_{0,4}^{B}, u_{0}(2)) = \\max(1, 2) = 2$.\n- State at end of stage $4$: $A_5 = \\{0, 1\\}$, $B_5 = \\{2\\}$, $r_{0,5}^{A} = 2$, $r_{0,5}^{B} = 2$, $I_{0}^{A} = 1$, $I_{0}^{B} = 0$.\n\n**Stage $s=5$ (Action for $R_{0}^{A}$)**\n- $R_{0}^{A}$ acts. It chooses the least fresh witness $y$ such that $y > r_{0,5}^{B}$. The restraint is $r_{0,5}^{B}=2$. The least fresh witness greater than $2$ is $y=3$.\n- We check if $\\Phi_{1}^{A_5}(3) \\neq B_5(3)$.\n- $\\Phi_{1}^{A_5}(3) = (A_5(0) + A_5(1) + A_5(2) + A_5(3)) \\bmod 2 = (1 + 1 + 0 + 0) \\bmod 2 = 0$.\n- $B_5(3) = 0$.\n- Since $\\Phi_{1}^{A_5}(3) = B_5(3)$, $R_{0}^{A}$ acts. It must respect $r_{0,5}^{B}=2$. It enumerates $3$ into $B$. The resulting set is $B_6 = \\{2, 3\\}$.\n- We check for injury to $R_{0}^{B}$. We changed $B(3)$. The restraint is $r_{0,5}^{B} = 2$. Since $3 \\not\\leq 2$, no injury occurs.\n- $R_{0}^{A}$ updates its restraint: $r_{0,6}^{A} = \\max(r_{0,5}^{A}, u_{1}(3)) = \\max(2, 3) = 3$.\n- State at end of stage $5$: $A_6 = \\{0, 1\\}$, $B_6 = \\{2, 3\\}$, $r_{0,6}^{A} = 3$, $r_{0,6}^{B} = 2$, $I_{0}^{A} = 1$, $I_{0}^{B} = 0$.\n\nAfter simulating stages $s=0$ through $s=5$, the total number of injuries suffered by $R_{0}^{A}$ is $I_{0}^{A} = 1$, and the total number of injuries suffered by $R_{0}^{B}$ is $I_{0}^{B} = 0$.\n\nThe question asks for the row matrix $\\begin{pmatrix} I_{0}^{A} & I_{0}^{B} \\end{pmatrix}$. This is $\\begin{pmatrix} 1 & 0 \\end{pmatrix}$.", "answer": "$$\\boxed{\\begin{pmatrix} 1 & 0 \\end{pmatrix}}$$", "id": "2986940"}, {"introduction": "A successful priority construction requires carefully navigating a landscape of constraints imposed by higher-priority requirements. This problem presents a snapshot of a construction in progress and challenges you to act as the strategist for a lower-priority requirement. You must analyze the active restraints and use bounds to determine which actions are \"safe\" and which would cause injury, reinforcing the fundamental rules that ensure the construction's success. [@problem_id:2986970]", "problem": "Consider a finite-injury priority construction for the Friedberg–Muchnik theorem asserting the existence of two computably enumerable (c.e.) sets with incomparable Turing degrees. The construction proceeds by meeting requirements of the form $$R_{e}:\\ A \\neq \\Phi_{e}^{B} \\quad \\text{and} \\quad S_{e}:\\ B \\neq \\Psi_{e}^{A},$$ where $\\Phi_{e}$ and $\\Psi_{e}$ are Turing functionals, and $\\Phi_{e}^{B}$ and $\\Psi_{e}^{A}$ denote computations using $B$ and $A$ as oracles, respectively. A requirement $R_{e}$ is met by ensuring a disagreement on some witness $x$; to protect higher-priority computations, each higher-priority strategy maintains numerical restraints and preserved use bounds.\n\nAt a current stage $s$, suppose the following higher-priority protective parameters are active:\n- A restraint on $A$ equal to $$r_{A} = 30.$$\n- A restraint on $B$ equal to $$r_{B} = 22.$$\n- A preserved use bound involving $A$ equal to $$u_{A}^{\\mathrm{HP}} = 28.$$\n- A preserved use bound involving $B$ equal to $$u_{B}^{\\mathrm{HP}} = 19.$$\n\nYou are addressing the requirement $R_{2}$ with a current witness $$x = 10,$$ and you have observed that the computation $$\\Phi_{2}^{B}(x)$$ converges at stage $s$ using only oracle queries to $B$ below the bound $$u_{B}^{(2)} = 21.$$ You are considering two proposed actions:\n- Proposal into $A$: enumerate the number $$a_{A} = 27$$ into $A$.\n- Proposal into $B$: enumerate the number $$b_{B} = 20$$ into $B$.\n\nIn this construction, a lower-priority action enumerating a number $n$ into a set $S \\in \\{A, B\\}$ injures a protected computation or restraint if $n$ is not strictly greater than every active restraint and relevant use bound on $S$. That is, to avoid injury, an enumeration $n$ into $S$ must satisfy $$n > r_{S} \\quad \\text{and} \\quad n > u_{S}^{\\mathrm{HP}}.$$\n\nUsing only the stated parameters and this injury-avoidance rule, determine whether each proposed action injures a higher-priority requirement. Then, compute the least natural number $$n_{A}$$ such that enumerating $$n_{A}$$ into $A$ at stage $s$ would avoid unnecessary injury while still allowing you to meet $R_{2}$ by diagonalizing against $$\\Phi_{2}^{B}(x)$$ at the current stage. Your final answer must be the single number $$n_{A}.$$", "solution": "We begin by recalling the foundational setup of a priority construction for the Friedberg–Muchnik theorem. We aim to build two computably enumerable (c.e.) sets $A$ and $B$ satisfying requirements $$R_{e}:\\ A \\neq \\Phi_{e}^{B} \\quad \\text{and} \\quad S_{e}:\\ B \\neq \\Psi_{e}^{A}.$$ At any stage $s$, higher-priority strategies ensure preservation of certain computations by imposing restraints $r_{A}$ and $r_{B}$ and by maintaining preserved use bounds $u_{A}^{\\mathrm{HP}}$ and $u_{B}^{\\mathrm{HP}}$. Lower-priority strategies must act without violating these restraints or uses. In particular, enumerating into $S \\in \\{A,B\\}$ a number $n$ is safe only if $$n > r_{S} \\quad \\text{and} \\quad n > u_{S}^{\\mathrm{HP}}.$$ This guarantees that no protected computation reading oracle bits below the use is disturbed, and no restraint is violated.\n\nAt stage $s$, the given parameters are:\n- $r_{A} = 30$ and $u_{A}^{\\mathrm{HP}} = 28$ for set $A$,\n- $r_{B} = 22$ and $u_{B}^{\\mathrm{HP}} = 19$ for set $B$,\n- the target requirement is $R_{2}$ with witness $x = 10$, and the current computation $\\Phi_{2}^{B}(x)$ converges using oracle bits of $B$ strictly below $u_{B}^{(2)} = 21$.\n\nWe first evaluate the safety of the two proposed actions.\n\n1. Proposal into $A$: enumerate $a_{A} = 27$ into $A$.\n   To be safe, we require $$a_{A} > r_{A} \\quad \\text{and} \\quad a_{A} > u_{A}^{\\mathrm{HP}}.$$ Substituting the given values, we check $$27 > 30 \\quad \\text{and} \\quad 27 > 28.$$ Both inequalities fail. Hence, enumerating $27$ into $A$ would violate the restraint on $A$ and injure a preserved computation depending on $A$ below the use $u_{A}^{\\mathrm{HP}}$.\n\n2. Proposal into $B$: enumerate $b_{B} = 20$ into $B$.\n   To be safe, we require $$b_{B} > r_{B} \\quad \\text{and} \\quad b_{B} > u_{B}^{\\mathrm{HP}}.$$ Substituting the given values, we check $$20 > 22 \\quad \\text{and} \\quad 20 > 19.$$ The first inequality fails, while the second holds. Therefore, enumerating $20$ into $B$ would violate the restraint on $B$ and thus injure a higher-priority requirement that protects the portion of $B$ below $22$.\n\nBoth proposed actions injure higher-priority protections.\n\nNext, we compute the least number $n_{A}$ such that enumerating $n_{A}$ into $A$ would avoid injury. By the injury-avoidance rule, $n_{A}$ must satisfy $$n_{A} > r_{A} \\quad \\text{and} \\quad n_{A} > u_{A}^{\\mathrm{HP}}.$$ With $r_{A} = 30$ and $u_{A}^{\\mathrm{HP}} = 28$, the strict inequalities imply that $$n_{A} > \\max\\{30, 28\\} = 30.$$ Therefore, the least natural number satisfying both constraints is $$n_{A} = 31.$$\n\nFinally, we verify that acting on $A$ with $n_{A} = 31$ is suitable for meeting $R_{2}$ at the current stage. The requirement $R_{2}$ aims to diagonalize against $\\Phi_{2}^{B}(x)$. Since we have observed that $\\Phi_{2}^{B}(x)$ converges with use $u_{B}^{(2)} = 21$, changing $A$ at $31$ does not affect the oracle $B$ and thus does not interfere with that computation. Moreover, because $31$ exceeds both $r_{A}$ and $u_{A}^{\\mathrm{HP}}$, no protected computation involving $A$ is injured. Thus, enumerating $31$ into $A$ avoids unnecessary injury and permits meeting $R_{2}$.\n\nTherefore, the least safe choice is $$n_{A} = 31.$$", "answer": "$$\\boxed{31}$$", "id": "2986970"}, {"introduction": "At its heart, the priority method is a solution to a difficult strategic dilemma: a requirement must act to ensure its success, but acting hastily can injure other requirements. This exercise moves beyond mechanics to the core logic of the strategy itself, asking you to evaluate different rules for when to act. By considering concepts like \"expansionary stages,\" you will appreciate the subtlety required to balance the risk of losing an opportunity against the need to maintain order in the construction. [@problem_id:2986980]", "problem": "You are constructing two computably enumerable (c.e.) sets $A$ and $B$ to witness incomparability of Turing degrees in the sense of the Friedberg–Muchnik theorem, by meeting requirements of the form $R_e$: ensure $A \\not\\le_T B$ by defeating the $e$-th Turing functional. The general framework is as follows.\n\n- A set $X \\subseteq \\mathbb{N}$ is computably enumerable (c.e.) if there exists a Turing machine that enumerates its elements without repetition. The $s$-stage approximation to $X$ is denoted $X_s$, with $X = \\lim_s X_s$ in the sense that $X_s \\subseteq X_{s+1}$ and $X = \\bigcup_s X_s$.\n\n- For a Turing functional (i.e., an oracle machine) $\\Phi_e$, the computation $\\Phi_e^{B}(x)$ on input $x$ with oracle $B$ may converge or diverge, and if it converges at stage $s$ relative to $B_s$, it has a finite use $u_{e,s}(x)$ indicating the largest oracle bit of $B$ examined.\n\n- A strategy for $R_e$ selects a current witness $x_e$ and monitors the computation $\\Phi_e^{B_s}(x_e)$. If $\\Phi_e^{B_s}(x_e)\\downarrow$ with use $u_{e,s}(x_e)$ below all higher-priority restraints on $B$, the strategy may enumerate $x_e$ into $A$ to force disagreement, thereby satisfying $R_e$. Enumerating into $A$ or $B$ at or below a use can injure lower-priority strategies whose computations depend on those oracle bits; higher-priority strategies place restraint functions on $A$ or $B$ to prevent injury.\n\n- Injury is controlled by restraint: each higher-priority requirement $R_k$ (for $k<e$) maintains a restraint $r_k(s)$ on the oracle set it protects, preventing lower-priority actions from changing bits below $r_k(s)$. The combined higher-priority restraint on $B$ seen by $R_e$ at stage $s$ is denoted $r^{\\ast}_B(e,s) = \\max\\{r_k(s) : k<e \\text{ and $R_k$ protects $B$}\\}$, and similarly for $A$.\n\nIn this construction, $R_e$ faces a trade-off. If it delays diagonalizing on $x_e$ until it is completely safe relative to higher-priority restraints, it risks losing the witness because $\\Phi_e^{B}(x_e)$ may later diverge, making the opportunity vanish. If it acts too hastily, it risks injuring higher-priority strategies or causing cascading injuries to lower-priority ones. An established way to balance these risks uses stage-based concepts of agreement and expansion.\n\nLet the length-of-agreement function for $R_e$ at stage $s$ be the largest $n$ such that, for all $y<n$, the current approximation of the computation $\\Phi_e^{B_s}(y)$ agrees with the current approximation of $A_s(y)$ in whichever sense $R_e$ monitors to detect potential reducibility (for example, agreement that would witness $\\Phi_e^{B}$ computing $A$ up to $n$). Call stage $s$ expansionary for $R_e$ if this length strictly exceeds its previous record.\n\nWhich of the following rules for $R_e$ best balances delaying diagonalization to avoid injury against the risk of losing a witness due to divergence, while guaranteeing a finite-injury priority construction that meets all requirements?\n\nA. Act at the first expansionary stage for $R_e$: if there is $x_e$ with $\\Phi_e^{B_s}(x_e)\\downarrow$ with use $u_{e,s}(x_e) < r^{\\ast}_B(e,s)$, and the length-of-agreement $\\ell_e(s)$ strictly exceeds its previous record, enumerate $x_e$ into $A$, set the $R_e$-restraint $r_e(s{+}1)$ on $A$ and $B$ to $u_{e,s}(x_e)$ as appropriate, and retain $x_e$ thereafter unless injured.\n\nB. Wait until you can verify that $\\Phi_e^{B}(x_e)$ is permanently convergent and that its use will never exceed any higher-priority restraint, then enumerate $x_e$ into $A$; if such verification fails, keep waiting until it succeeds.\n\nC. Fix a global timeout $t \\in \\mathbb{N}$ independent of $e$. If $\\Phi_e^{B_s}(x_e)$ has not converged within $t$ stages, abandon $x_e$ and pick a fresh witness; if it does converge, enumerate $x_e$ into $A$ immediately regardless of the current higher-priority restraints.\n\nD. Defer all diagonalizations for $R_e$ until every lower-priority requirement $R_k$ with $k>e$ has stabilized its witnesses and restraints; then enumerate $x_e$ into $A$ at the next stage where $\\Phi_e^{B_s}(x_e)\\downarrow$.", "solution": "The user has provided a problem statement concerning the construction of computably enumerable sets in the context of the Friedberg–Muchnik theorem.\n\n### Step 1: Extract Givens\n-   **Goal:** Construct two computably enumerable (c.e.) sets, $A$ and $B$, to witness the incomparability of Turing degrees.\n-   **Focus:** The strategy for meeting a single requirement $R_e$ of the form $A \\not\\le_T B$, which is equivalent to ensuring $A \\neq \\Phi_e^B$, where $\\Phi_e$ is the $e$-th Turing functional.\n-   **Notation and Definitions:**\n    -   $X_s$: The finite approximation of a c.e. set $X$ at stage $s$. $X = \\bigcup_s X_s$.\n    -   $\\Phi_e^B(x)$: Computation of the $e$-th functional on input $x$ with oracle $B$.\n    -   $\\Phi_e^{B_s}(x)\\downarrow$: The computation converges at stage $s$ using the finite oracle $B_s$.\n    -   $u_{e,s}(x)$: The use of the computation $\\Phi_e^{B_s}(x)$, i.e., the largest integer queried in the oracle $B_s$.\n    -   **Priority and Restraint:** Requirements $R_k$ with $k < e$ have higher priority. A higher-priority requirement can impose a restraint $r_k(s)$ on a set to prevent lower-priority requirements from making changes below this bound.\n    -   $r^{\\ast}_B(e,s) = \\max\\{r_k(s) : k<e \\text{ and } R_k \\text{ protects } B\\}$. This is the combined restraint on set $B$ from requirements with priority higher than $R_e$.\n    -   **Strategy:** For a witness $x_e$, if $\\Phi_e^{B_s}(x_e)\\downarrow = 0$ (and $x_e \\notin A_s$), the strategy for $R_e$ may enumerate $x_e$ into $A$ to establish a disagreement, $A(x_e) = 1 \\neq \\Phi_e^B(x_e) = 0$. This action must preserve the computation, which requires restraining $B$ up to the use $u_{e,s}(x_e)$.\n    -   **Length-of-Agreement:** $\\ell_e(s)$ is the largest integer $n$ such that for all $y < n$, $\\Phi_e^{B_s}(y)$ agrees with $A_s(y)$.\n    -   **Expansionary Stage:** A stage $s$ where $\\ell_e(s)$ is strictly greater than its maximum value over all previous stages $t<s$.\n-   **Question:** Identify the rule for requirement $R_e$ that best balances the risk of delaying action (and losing the opportunity) against acting hastily (and causing injury), while guaranteeing a finite-injury construction.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is a well-formulated conceptual question from computability theory, a branch of mathematical logic.\n\n-   **Scientifically Grounded:** The problem is firmly based on the established principles of the priority method, a cornerstone of computability theory used to prove the Friedberg–Muchnik theorem and many other results. All terms used ($c.e.$ set, Turing functional, use, restraint, injury, etc.) are standard and precisely defined in this field.\n-   **Well-Posed:** The problem is well-posed. It describes a fundamental dilemma in priority constructions and asks for the strategic principle that resolves it. The existence of such a principle is a major result in the field.\n-   **Objective:** The problem is stated in precise, objective, technical language, free of ambiguity or subjective claims.\n\nThe problem is valid. It accurately presents a non-trivial challenge in constructing c.e. degrees and asks the student to identify the key strategic element from among several options.\n\n### Step 3: Derivation and Option Analysis\nThe core of a finite-injury priority argument is ensuring that each requirement $R_e$ is acted upon and then subsequently injured only a finite number of times. After its final injury, a requirement must be able to successfully complete its objective. This requires a careful, priority-based protocol for actions. The question asks for the best such protocol among the choices.\n\nLet's evaluate each option based on the principles of computability theory.\n\n**Option B: Wait until you can verify that $\\Phi_e^{B}(x_e)$ is permanently convergent and that its use will never exceed any higher-priority restraint, then enumerate $x_e$ into $A$; if such verification fails, keep waiting until it succeeds.**\n\nThis strategy is algorithmically impossible. The sets $A$ and $B$ are the final outputs of the entire infinite construction. Whether a computation $\\Phi_e^B(x_e)$ is \"permanently convergent\" or whether its \"true\" use relative to the final oracle $B$ will have a certain property are questions about the completed infinite objects. A constructive algorithm, which is what a priority argument is, must make its decisions at each finite stage $s$ based only on the information available at stage $s$ (i.e., on $A_s$ and $B_s$). It cannot query properties of the final sets $A$ and $B$. Doing so would require solving the Halting Problem or having access to a higher-degree oracle, which defeats the purpose of the construction. Therefore, this strategy is not effective and cannot be implemented.\n\n**Verdict for B: Incorrect.**\n\n**Option C: Fix a global timeout $t \\in \\mathbb{N}$ independent of $e$. If $\\Phi_e^{B_s}(x_e)$ has not converged within $t$ stages, abandon $x_e$ and pick a fresh witness; if it does converge, enumerate $x_e$ into $A$ immediately regardless of the current higher-priority restraints.**\n\nThis strategy is flawed in two fundamental ways.\n1.  **Global Timeout:** The time it takes for a Turing machine computation $\\Phi_e^{B_s}(x_e)$ to converge (if it does) is not bounded by any a priori constant $t$. For any such $t$, there will be functionals $\\Phi_e$ and inputs $x_e$ that require more than $t$ steps or stages to converge. This strategy would wrongly abandon valid witnesses and thus fail to satisfy the corresponding requirements.\n2.  **Ignoring Restraints:** The most critical error is to act \"regardless of the current higher-priority restraints\". The entire priority method is founded on a strict hierarchy where lower-priority requirements MUST respect the restraints imposed by higher-priority ones. Violating this principle leads to uncontrolled, potentially infinite, injury. For example, $R_e$ could injure $R_{e-1}$, which would then act again, potentially injuring $R_e$ back. This can prevent the construction from ever stabilizing for any requirement.\n\n**Verdict for C: Incorrect.**\n\n**Option D: Defer all diagonalizations for $R_e$ until every lower-priority requirement $R_k$ with $k>e$ has stabilized its witnesses and restraints; then enumerate $x_e$ into $A$ at the next stage where $\\Phi_e^{B_s}(x_e)\\downarrow$.**\n\nThis strategy reverses the logic of the priority ordering. In a priority argument, higher-priority requirements ($k<e$) have precedence over lower-priority ones ($k>e$). A requirement $R_e$ may need to injure requirements $R_k$ where $k>e$. Consequently, a lower-priority requirement $R_k$ cannot \"stabilize\" until all higher-priority requirements, including $R_e$, have stabilized. This rule creates a logical deadlock: $R_e$ waits for $R_{e+1}$ to stabilize, but $R_{e+1}$ must wait for $R_e$ to stabilize. No requirement would ever be able to act.\n\n**Verdict for D: Incorrect.**\n\n**Option A: Act at the first expansionary stage for $R_e$: if there is $x_e$ with $\\Phi_e^{B_s}(x_e)\\downarrow$ with use $u_{e,s}(x_e) < r^{\\ast}_B(e,s)$, and the length-of-agreement $\\ell_e(s)$ strictly exceeds its previous record, enumerate $x_e$ into $A$, set the $R_e$-restraint $r_e(s{+}1)$ on $A$ and $B$ to $u_{e,s}(x_e)$ as appropriate, and retain $x_e$ thereafter unless injured.**\n\nThis option presents the most sophisticated and correct strategy.\n1.  **Expansionary Stage:** The use of \"expansionary stages\" is a key insight in modern priority arguments (e.g., those of Sacks). A requirement $R_e$ only needs to act if it appears that $\\Phi_e^B=A$ might be true. The sign of this is that the length of agreement, $\\ell_e(s)$, tends to infinity. Acting at an expansionary stage means acting precisely when we see new evidence for this threatening agreement. If the agreement length is bounded, $\\ell_e(s) \\le N$ for all $s$, then $R_e$ is satisfied passively (a disagreement must exist), and no action is ever needed. This elegantly handles one of the two cases. If $\\ell_e(s) \\to \\infty$, there will be infinitely many expansionary stages, providing infinitely many opportunities to act.\n2.  **Balancing Risks:** This strategy directly addresses the trade-off. It delays action until there is a meaningful sign of danger (the expanding agreement), but it acts on that sign, preventing indefinite delay that might lose the witness.\n3.  **Finite Injury:** Combined with the priority ordering (where only the highest-priority requirement requiring attention acts at a given stage), this strategy ensures finite injury. $R_e$ can only be injured by $R_k$ for $k<e$. Each $R_k$ acts finitely many times by induction. Thus, $R_e$ is injured finitely often. After its last injury, higher-priority restraints stabilize. Since there are infinitely many expansionary stages (in the case that requires action), $R_e$ will eventually find an opportunity to act and will not be injured again.\n4.  **The Restraint Condition:** The condition $u_{e,s}(x_e) < r^{\\ast}_B(e,s)$ is non-standard and potentially problematic. It requires that the oracle portion needed for the computation is already under a restraint imposed by a higher-priority requirement. This is a very strong condition for safety, and one might not be able to guarantee it is ever met. However, given that options B, C, and D are fundamentally and fatally flawed, option A is the only one that presents a coherent and largely correct approach. The central and most important concept it employs—acting at expansionary stages—is the correct principle for this type of construction. Among the given options, it is unequivocally the \"best\" rule.\n\n**Verdict for A: Correct.**", "answer": "$$\\boxed{A}$$", "id": "2986980"}]}