{"hands_on_practices": [{"introduction": "Understanding the properties of a set of connectives often benefits from an algebraic perspective. One of the most powerful tools in this domain is the Algebraic Normal Form (ANF), which provides a unique polynomial representation for any Boolean function over the field of two elements, $\\mathbb{F}_2$. This practice challenges you to compute the ANF for several connectives and use it to determine membership in the affine clone, one of the five maximal clones that preclude functional completeness [@problem_id:2968168]. Mastering this conversion is a key skill for analyzing the expressive power of logical systems.", "problem": "Let $\\{0,1\\}$ be identified with the finite field of two elements $\\mathbb{F}_{2}$, writing logical exclusive-or as addition $\\oplus$ in $\\mathbb{F}_{2}$ and logical conjunction as multiplication. A Boolean function $f \\colon \\{0,1\\}^{n} \\to \\{0,1\\}$ has an algebraic normal form (ANF) expansion over $\\mathbb{F}_{2}$ of the shape\n$$\nf(x_{1},\\dots,x_{n}) \\;=\\; a_{\\varnothing} \\;\\oplus\\; \\bigoplus_{i} a_{\\{i\\}} x_{i} \\;\\oplus\\; \\bigoplus_{i<j} a_{\\{i,j\\}} x_{i} x_{j} \\;\\oplus\\; \\cdots \\;\\oplus\\; a_{\\{1,\\dots,n\\}} x_{1} \\cdots x_{n},\n$$\nwith coefficients $a_{S} \\in \\{0,1\\}$. The algebraic degree of $f$ is the maximum cardinality $|S|$ for which $a_{S} = 1$. A Boolean function is called affine if its algebraic degree is at most $1$. The affine clone is the set of all affine Boolean functions, and is closed under superposition (composition), identification of variables, and introduction of dummy variables.\n\nConsider the candidate set of primitive connectives $\\mathcal{C} = \\{f,g,h\\}$, where\n- $f(x,y,z) := (x \\leftrightarrow y) \\oplus z$ for ternary inputs $x,y,z \\in \\{0,1\\}$, with $x \\leftrightarrow y$ the logical equivalence,\n- $g(x,y,z) := (x \\lor y) \\land \\neg z$ for ternary inputs, using logical disjunction and negation,\n- $h(t) := \\neg t$ for unary input $t \\in \\{0,1\\}$.\n\nCompute the algebraic normal form (ANF) of each primitive connective in $\\mathcal{C}$, determine their algebraic degrees, and use this information to decide whether the clone $Cl(\\mathcal{C})$ generated by $\\mathcal{C}$ is contained in the affine clone. Report your decision as the indicator\n$$\n\\Delta \\;=\\; \\begin{cases}\n1 & \\text{if } Cl(\\mathcal{C}) \\text{ is contained in the affine clone},\\\\\n0 & \\text{otherwise.}\n\\end{cases}\n$$\n\nYour final answer must be the single number $\\Delta$. No rounding is required.", "solution": "We begin from first principles. Over $\\mathbb{F}_{2}$, logical exclusive-or corresponds to addition $\\oplus$, logical conjunction to multiplication, and logical negation to the map $x \\mapsto 1 \\oplus x$. The algebraic normal form (ANF) of a Boolean function is its unique polynomial representation over $\\mathbb{F}_{2}$ in the variables $x_{i}$ with each $x_{i}^{2} = x_{i}$.\n\nStep 1: Compute the ANF of $f(x,y,z) := (x \\leftrightarrow y) \\oplus z$.\n\nWe recall the identity $x \\leftrightarrow y = \\neg(x \\oplus y)$ and the fundamental property of negation in $\\mathbb{F}_{2}$: $\\neg u = 1 \\oplus u$. Therefore,\n$$\nx \\leftrightarrow y \\;=\\; 1 \\oplus (x \\oplus y) \\;=\\; 1 \\oplus x \\oplus y.\n$$\nIt follows that\n$$\nf(x,y,z) \\;=\\; (x \\leftrightarrow y) \\oplus z \\;=\\; (1 \\oplus x \\oplus y) \\oplus z \\;=\\; 1 \\oplus x \\oplus y \\oplus z.\n$$\nThus, the ANF of $f$ is\n$$\nf(x,y,z) \\;=\\; 1 \\oplus x \\oplus y \\oplus z,\n$$\nwhich has algebraic degree $1$, hence $f$ is affine.\n\nStep 2: Compute the ANF of $g(x,y,z) := (x \\lor y) \\land \\neg z$.\n\nWe use the known ANF identity for disjunction:\n$$\nx \\lor y \\;=\\; x \\oplus y \\oplus x y,\n$$\nwhich can be verified from the truth table by noting $x \\lor y = x + y - xy$ over the integers and then reducing modulo $2$, or directly via the Boolean ring representation.\n\nNegation is $\\neg z = 1 \\oplus z$. Conjunction is multiplication of polynomials over $\\mathbb{F}_{2}$. Therefore,\n$$\ng(x,y,z) \\;=\\; (x \\lor y) \\land \\neg z \\;=\\; (x \\oplus y \\oplus x y)(1 \\oplus z).\n$$\nExpanding in $\\mathbb{F}_{2}$,\n\\begin{align*}\ng(x,y,z)\n&= (x \\oplus y \\oplus x y) \\oplus (x \\oplus y \\oplus x y) z \\\\\n&= x \\oplus y \\oplus x y \\oplus x z \\oplus y z \\oplus x y z.\n\\end{align*}\nHence, the ANF of $g$ is\n$$\ng(x,y,z) \\;=\\; x \\oplus y \\oplus x y \\oplus x z \\oplus y z \\oplus x y z.\n$$\nThe algebraic degree of $g$ is $3$ because the monomial $x y z$ appears with coefficient $1$. Therefore $g$ is not affine.\n\nStep 3: Compute the ANF of $h(t) := \\neg t$.\n\nUsing negation in $\\mathbb{F}_{2}$,\n$$\nh(t) \\;=\\; 1 \\oplus t.\n$$\nThis is affine with algebraic degree $1$.\n\nStep 4: Decide whether $Cl(\\mathcal{C})$ is contained in the affine clone.\n\nBy definition, $Cl(\\mathcal{C})$ is the smallest clone containing the primitive connectives in $\\mathcal{C}$; in particular, it contains each primitive as an element. The affine clone is the set of all Boolean functions whose ANF has algebraic degree at most $1$. We have found:\n- $f$ is affine (degree $1$),\n- $g$ is not affine (degree $3$),\n- $h$ is affine (degree $1$).\n\nSince $g \\in \\mathcal{C} \\subseteq Cl(\\mathcal{C})$ and $g$ is not affine, it follows immediately that $Cl(\\mathcal{C})$ is not contained in the affine clone. There is no need to appeal to composition closure beyond the observation that a non-affine generator already witnesses non-containment.\n\nTherefore, the requested indicator is\n$$\n\\Delta \\;=\\; 0.\n$$", "answer": "$$\\boxed{0}$$", "id": "2968168"}, {"introduction": "To systematically apply Post's theorem, we must be able to algorithmically verify whether a function belongs to any of the five maximal clones. This exercise focuses on the four clones defined by combinatorial properties: preserving constants ($\\mathsf{T}_0$ and $\\mathsf{T}_1$), preserving order ($\\mathsf{M}$), and possessing a specific symmetry (self-duality, $\\mathsf{S}$). By translating these abstract definitions into concrete checks on a function's truth table, you will build the foundational components of a universal adequacy tester [@problem_id:2968171]. This deepens your understanding of the structural properties that limit a connective's expressive power.", "problem": "You are given a finite set of Boolean connectives, each represented by its arity and a truth table. A Boolean connective is an $n$-ary Boolean function $f:\\{0,1\\}^n \\to \\{0,1\\}$. A set $\\mathcal{C}$ of Boolean connectives is called adequate (also called functionally complete) if the smallest clone (that is, the smallest set of Boolean functions closed under composition and containing all projections) containing $\\mathcal{C}$ is the set of all Boolean functions on $\\{0,1\\}$. The known classification of maximal clones on the Boolean domain identifies five precomplete classes (also called maximal clones) whose inclusion prevents adequacy: the monotone functions, the affine (linear over $\\mathbb{F}_2$) functions, the self-dual functions, the $0$-preserving functions, and the $1$-preserving functions. Your task is to implement a decision procedure that, given a finite $\\mathcal{C}$, algorithmically decides whether $\\mathcal{C}$ is adequate by checking non-inclusion in each of these five maximal clones, and to ensure the decision is correct by relying only on fundamental definitions and well-established results in Boolean clone theory.\n\nRepresentation. Each connective is specified by its arity $n \\in \\mathbb{N}$ and a truth table vector of length $2^n$ with entries in $\\{0,1\\}$. The $i$-th entry of the vector, for $i \\in \\{0,\\dots,2^n-1\\}$, equals $f(\\mathbf{a})$ for the unique $\\mathbf{a}=(a_1,\\dots,a_n)\\in\\{0,1\\}^n$ such that for each $k \\in \\{1,\\dots,n\\}$, $a_k$ is the $(k-1)$-th bit of $i$ in binary (that is, $a_k$ is the coefficient of $2^{k-1}$ in the binary expansion of $i$). For example, for $n=2$, the input order is $(0,0)$ at index $0$, $(1,0)$ at index $1$, $(0,1)$ at index $2$, and $(1,1)$ at index $3$.\n\nDefinitions of the five maximal clones to be checked for inclusion:\n- $0$-preserving class $\\mathsf{T}_0$: A function $f$ is in $\\mathsf{T}_0$ if $f(0,\\dots,0)=0$.\n- $1$-preserving class $\\mathsf{T}_1$: A function $f$ is in $\\mathsf{T}_1$ if $f(1,\\dots,1)=1$.\n- Monotone class $\\mathsf{M}$: A function $f$ is in $\\mathsf{M}$ if for all $\\mathbf{x},\\mathbf{y}\\in\\{0,1\\}^n$ with $\\mathbf{x}\\le \\mathbf{y}$ coordinatewise, $f(\\mathbf{x}) \\le f(\\mathbf{y})$.\n- Self-dual class $\\mathsf{S}$: A function $f$ is in $\\mathsf{S}$ if for all $\\mathbf{x}\\in\\{0,1\\}^n$, $f(\\mathbf{x}) = 1 - f(\\neg \\mathbf{x})$, where $\\neg \\mathbf{x}$ denotes bitwise negation.\n- Affine class $\\mathsf{L}$: A function $f$ is in $\\mathsf{L}$ if there exist coefficients $a_0,\\dots,a_n\\in\\{0,1\\}$ such that for all $\\mathbf{x}\\in\\{0,1\\}^n$, $f(\\mathbf{x}) = a_0 \\oplus (a_1 x_1) \\oplus \\cdots \\oplus (a_n x_n)$, where $\\oplus$ is addition modulo $2$.\n\nDecision requirement. For a finite set $\\mathcal{C}$, decide whether it is adequate by verifying that $\\mathcal{C}$ is not contained in any one of the five classes above. Concretely, you must compute five boolean flags indicating whether all functions in $\\mathcal{C}$ satisfy, respectively, $0$-preservation, $1$-preservation, monotonicity, self-duality, and affineness; the set $\\mathcal{C}$ is adequate if and only if none of these five flags is true.\n\nImplement this decision procedure and apply it to the following test suite, where each case is a finite set of connectives, given as $(n,\\text{tt})$ with $n$ the arity and $\\text{tt}$ the truth vector in the ordering described above:\n- Case $1$: $\\{ \\text{NAND}_2 \\}$ with $n=2$ and $\\text{tt} = [1,1,1,0]$.\n- Case $2$: $\\{ \\text{NOR}_2 \\}$ with $n=2$ and $\\text{tt} = [1,0,0,0]$.\n- Case $3$: $\\{ \\text{AND}_2, \\text{NOT}_1 \\}$ with $\\text{AND}_2$ given by $n=2$, $\\text{tt}=[0,0,0,1]$ and $\\text{NOT}_1$ given by $n=1$, $\\text{tt}=[1,0]$.\n- Case $4$: $\\{ \\text{OR}_2, \\text{NOT}_1 \\}$ with $\\text{OR}_2$ given by $n=2$, $\\text{tt}=[0,1,1,1]$ and $\\text{NOT}_1$ as above.\n- Case $5$: $\\{ \\text{AND}_2 \\}$ with $n=2$, $\\text{tt}=[0,0,0,1]$.\n- Case $6$: $\\{ \\text{XOR}_2 \\}$ with $n=2$, $\\text{tt}=[0,1,1,0]$.\n- Case $7$: $\\{ \\text{IMPLIES}_2 \\}$ where $\\text{IMPLIES}_2(x_1,x_2)$ is $1$ unless $x_1=1$ and $x_2=0$, so $n=2$, $\\text{tt}=[1,0,1,1]$.\n- Case $8$: $\\{ \\text{NOT}_1 \\}$ with $n=1$, $\\text{tt}=[1,0]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets (for example, $[\\text{True},\\text{False}]$), corresponding in order to Cases $1$ through $8$. No physical units, angle units, or percentages are involved, so no unit specification is required.", "solution": "The problem of determining whether a finite set of Boolean connectives is adequate, or functionally complete, is a well-defined question in mathematical logic. The solution rests upon a seminal result by Emil Post, known as Post's criterion or Post's lattice theorem. This theorem provides a complete classification of all clones on the two-element set $\\{0,1\\}$. A set of Boolean functions $\\mathcal{C}$ is functionally complete if and only if it is not a subset of any of the five maximal (or precomplete) clones. The decision procedure therefore involves testing the given set of connectives $\\mathcal{C}$ for inclusion in each of these five specific classes of functions. If $\\mathcal{C}$ is not entirely contained within any single one of these five classes, it is adequate. Otherwise, it is not.\n\nThe five maximal clones are:\n1.  The class of $0$-preserving functions, denoted $\\mathsf{T}_0$. A function $f$ is in $\\mathsf{T}_0$ if $f(0, 0, \\dots, 0) = 0$.\n2.  The class of $1$-preserving functions, denoted $\\mathsf{T}_1$. A function $f$ is in $\\mathsf{T}_1$ if $f(1, 1, \\dots, 1) = 1$.\n3.  The class of self-dual functions, denoted $\\mathsf{S}$. A function $f$ is in $\\mathsf{S}$ if it is its own dual up to negation, i.e., $f(x_1, \\dots, x_n) = \\neg f(\\neg x_1, \\dots, \\neg x_n)$, where $\\neg x = 1-x$.\n4.  The class of monotone functions, denoted $\\mathsf{M}$. A function $f$ is in $\\mathsf{M}$ if it preserves the natural partial order on $\\{0,1\\}^n$. That is, for any two input vectors $\\mathbf{x}=(x_1, \\dots, x_n)$ and $\\mathbf{y}=(y_1, \\dots, y_n)$, if $\\mathbf{x} \\le \\mathbf{y}$ (meaning $x_k \\le y_k$ for all $k \\in \\{1, \\dots, n\\}$), then $f(\\mathbf{x}) \\le f(\\mathbf{y})$.\n5.  The class of affine functions, denoted $\\mathsf{L}$. A function $f$ is in $\\mathsf{L}$ if it can be expressed as a linear polynomial over the finite field $\\mathbb{F}_2$. That is, there exist coefficients $a_0, a_1, \\dots, a_n \\in \\{0, 1\\}$ such that for all $\\mathbf{x} \\in \\{0, 1\\}^n$, $f(\\mathbf{x}) = a_0 \\oplus a_1 x_1 \\oplus \\cdots \\oplus a_n x_n$, where $\\oplus$ denotes addition modulo $2$ (XOR).\n\nTo implement the decision procedure for a given set of connectives $\\mathcal{C}$, we must first develop an algorithmic test for each of these five properties. For each connective $f \\in \\mathcal{C}$, represented by its arity $n$ and its truth table vector $\\mathbf{t}$ of length $2^n$, we perform the following checks. The input vector $(x_1, \\dots, x_n)$ corresponds to the index $i = \\sum_{k=1}^n x_k 2^{k-1}$ in the truth table, so that $f(x_1, \\dots, x_n) = \\mathbf{t}[i]$.\n\n**1. Test for $0$-preservation ($\\mathsf{T}_0$)**\nA function $f$ is $0$-preserving if $f(0, \\dots, 0) = 0$. The input vector $(0, \\dots, 0)$ corresponds to index $i=0$. Thus, the check is simply $\\mathbf{t}[0] = 0$.\n\n**2. Test for $1$-preservation ($\\mathsf{T}_1$)**\nA function $f$ is $1$-preserving if $f(1, \\dots, 1) = 1$. The input vector $(1, \\dots, 1)$ corresponds to index $i = \\sum_{k=1}^n 1 \\cdot 2^{k-1} = 2^n - 1$. The check is $\\mathbf{t}[2^n-1] = 1$.\n\n**3. Test for self-duality ($\\mathsf{S}$)**\nA function $f$ is self-dual if $f(\\mathbf{x}) = 1 - f(\\neg\\mathbf{x})$ for all $\\mathbf{x} \\in \\{0,1\\}^n$. If the input vector $\\mathbf{x}$ corresponds to index $i$, its bitwise negation $\\neg\\mathbf{x}$ corresponds to index $(2^n-1)-i$. The condition becomes $\\mathbf{t}[i] = 1 - \\mathbf{t}[2^n-1-i]$ for all $i \\in \\{0, \\dots, 2^n-1\\}$. We must verify this for all indices $i$.\n\n**4. Test for monotonicity ($\\mathsf{M}$)**\nA function $f$ is monotone if $\\mathbf{x} \\le \\mathbf{y}$ implies $f(\\mathbf{x}) \\le f(\\mathbf{y})$. Let $\\mathbf{x}$ and $\\mathbf{y}$ correspond to indices $i$ and $j$ respectively. The condition $\\mathbf{x} \\le \\mathbf{y}$ is equivalent to the bitwise condition $(i \\text{ AND } j) = i$. Therefore, we must verify that for all pairs of indices $(i, j)$ in $\\{0, \\dots, 2^n-1\\}$, if $(i \\text{ AND } j) = i$, then $\\mathbf{t}[i] \\le \\mathbf{t}[j]$.\n\n**5. Test for affineness ($\\mathsf{L}$)**\nA function $f$ is affine if $f(\\mathbf{x}) = a_0 \\oplus \\bigoplus_{k=1}^n a_k x_k$. The coefficients can be uniquely determined from the function's behavior on the zero vector and the standard basis vectors.\n-   The constant term is $a_0 = f(0, \\dots, 0) = \\mathbf{t}[0]$.\n-   For $k \\in \\{1, \\dots, n\\}$, let $\\mathbf{e}_k$ be the vector with $x_k=1$ and all other components $0$. The index for $\\mathbf{e}_k$ is $2^{k-1}$. Then $f(\\mathbf{e}_k) = a_0 \\oplus a_k$, which implies $a_k = f(\\mathbf{e}_k) \\oplus a_0 = \\mathbf{t}[2^{k-1}] \\oplus \\mathbf{t}[0]$.\nAfter finding these candidate coefficients $a_0, a_1, \\dots, a_n$, we must verify that they correctly reproduce the entire truth table. We iterate through all $2^n$ inputs $\\mathbf{x}$, compute the value of the affine form $a_0 \\oplus \\bigoplus_{k=1}^n a_k x_k$, and check if it matches $f(\\mathbf{x}) = \\mathbf{t}[i]$. If this holds for all inputs, the function is affine.\n\n**Final Decision Logic:**\nFor a given set of connectives $\\mathcal{C}$, we determine if $\\mathcal{C} \\subseteq \\mathsf{P}$ for each property $\\mathsf{P} \\in \\{\\mathsf{T}_0, \\mathsf{T}_1, \\mathsf{M}, \\mathsf{S}, \\mathsf{L}\\}$. This is done by checking if *every* function in $\\mathcal{C}$ has the property $\\mathsf{P}$. Let $C_P$ be the boolean flag indicating whether $\\mathcal{C} \\subseteq \\mathsf{P}$. The set $\\mathcal{C}$ is adequate if and only if none of these flags are true, i.e., $\\neg(C_{\\mathsf{T}_0} \\lor C_{\\mathsf{T}_1} \\lor C_{\\mathsf{M}} \\lor C_{\\mathsf{S}} \\lor C_{\\mathsf{L}})$.\nThe implementation will apply this logic to each of the provided test cases.", "answer": "[True,True,True,True,False,False,False,False]", "id": "2968171"}, {"introduction": "With the ability to test for membership in each of Post's maximal clones, you can now construct a complete decision procedure for functional adequacy. This final practice brings everything together, using the property checks developed previously—for constant-preservation, monotonicity, self-duality, and affineness—to implement the full criterion of Post's theorem. You will apply this comprehensive algorithm to analyze several common sets of connectives, providing a definitive answer to whether they are adequate and solidifying your practical command of this fundamental result in logic [@problem_id:2968171].", "problem": "You are given a finite set of Boolean connectives, each represented by its arity and a truth table. A Boolean connective is an $n$-ary Boolean function $f:\\{0,1\\}^n \\to \\{0,1\\}$. A set $\\mathcal{C}$ of Boolean connectives is called adequate (also called functionally complete) if the smallest clone (that is, the smallest set of Boolean functions closed under composition and containing all projections) containing $\\mathcal{C}$ is the set of all Boolean functions on $\\{0,1\\}$. The known classification of maximal clones on the Boolean domain identifies five precomplete classes (also called maximal clones) whose inclusion prevents adequacy: the monotone functions, the affine (linear over $\\mathbb{F}_2$) functions, the self-dual functions, the $0$-preserving functions, and the $1$-preserving functions. Your task is to implement a decision procedure that, given a finite $\\mathcal{C}$, algorithmically decides whether $\\mathcal{C}$ is adequate by checking non-inclusion in each of these five maximal clones, and to ensure the decision is correct by relying only on fundamental definitions and well-established results in Boolean clone theory.\n\nRepresentation. Each connective is specified by its arity $n \\in \\mathbb{N}$ and a truth table vector of length $2^n$ with entries in $\\{0,1\\}$. The $i$-th entry of the vector, for $i \\in \\{0,\\dots,2^n-1\\}$, equals $f(\\mathbf{a})$ for the unique $\\mathbf{a}=(a_1,\\dots,a_n)\\in\\{0,1\\}^n$ such that for each $k \\in \\{1,\\dots,n\\}$, $a_k$ is the $(k-1)$-th bit of $i$ in binary (that is, $a_k$ is the coefficient of $2^{k-1}$ in the binary expansion of $i$). For example, for $n=2$, the input order is $(0,0)$ at index $0$, $(1,0)$ at index $1$, $(0,1)$ at index $2$, and $(1,1)$ at index $3$.\n\nDefinitions of the five maximal clones to be checked for inclusion:\n- $0$-preserving class $\\mathsf{T}_0$: A function $f$ is in $\\mathsf{T}_0$ if $f(0,\\dots,0)=0$.\n- $1$-preserving class $\\mathsf{T}_1$: A function $f$ is in $\\mathsf{T}_1$ if $f(1,\\dots,1)=1$.\n- Monotone class $\\mathsf{M}$: A function $f$ is in $\\mathsf{M}$ if for all $\\mathbf{x},\\mathbf{y}\\in\\{0,1\\}^n$ with $\\mathbf{x}\\le \\mathbf{y}$ coordinatewise, $f(\\mathbf{x}) \\le f(\\mathbf{y})$.\n- Self-dual class $\\mathsf{S}$: A function $f$ is in $\\mathsf{S}$ if for all $\\mathbf{x}\\in\\{0,1\\}^n$, $f(\\mathbf{x}) = 1 - f(\\neg \\mathbf{x})$, where $\\neg \\mathbf{x}$ denotes bitwise negation.\n- Affine class $\\mathsf{L}$: A function $f$ is in $\\mathsf{L}$ if there exist coefficients $a_0,\\dots,a_n\\in\\{0,1\\}$ such that for all $\\mathbf{x}\\in\\{0,1\\}^n$, $f(\\mathbf{x}) = a_0 \\oplus (a_1 x_1) \\oplus \\cdots \\oplus (a_n x_n)$, where $\\oplus$ is addition modulo $2$.\n\nDecision requirement. For a finite set $\\mathcal{C}$, decide whether it is adequate by verifying that $\\mathcal{C}$ is not contained in any one of the five classes above. Concretely, you must compute five boolean flags indicating whether all functions in $\\mathcal{C}$ satisfy, respectively, $0$-preservation, $1$-preservation, monotonicity, self-duality, and affineness; the set $\\mathcal{C}$ is adequate if and only if none of these five flags is true.\n\nImplement this decision procedure and apply it to the following test suite, where each case is a finite set of connectives, given as $(n,\\text{tt})$ with $n$ the arity and $\\text{tt}$ the truth vector in the ordering described above:\n- Case $1$: $\\{ \\text{NAND}_2 \\}$ with $n=2$ and $\\text{tt} = [1,1,1,0]$.\n- Case $2$: $\\{ \\text{NOR}_2 \\}$ with $n=2$ and $\\text{tt} = [1,0,0,0]$.\n- Case $3$: $\\{ \\text{AND}_2, \\text{NOT}_1 \\}$ with $\\text{AND}_2$ given by $n=2$, $\\text{tt}=[0,0,0,1]$ and $\\text{NOT}_1$ given by $n=1$, $\\text{tt}=[1,0]$.\n- Case $4$: $\\{ \\text{OR}_2, \\text{NOT}_1 \\}$ with $\\text{OR}_2$ given by $n=2$, $\\text{tt}=[0,1,1,1]$ and $\\text{NOT}_1$ as above.\n- Case $5$: $\\{ \\text{AND}_2 \\}$ with $n=2$, $\\text{tt}=[0,0,0,1]$.\n- Case $6$: $\\{ \\text{XOR}_2 \\}$ with $n=2$, $\\text{tt}=[0,1,1,0]$.\n- Case $7$: $\\{ \\text{IMPLIES}_2 \\}$ where $\\text{IMPLIES}_2(x_1,x_2)$ is $1$ unless $x_1=1$ and $x_2=0$, so $n=2$, $\\text{tt}=[1,0,1,1]$.\n- Case $8$: $\\{ \\text{NOT}_1 \\}$ with $n=1$, $\\text{tt}=[1,0]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets (for example, $[\\text{True},\\text{False}]$), corresponding in order to Cases $1$ through $8$. No physical units, angle units, or percentages are involved, so no unit specification is required.", "solution": "The problem of determining whether a finite set of Boolean connectives is adequate, or functionally complete, is a well-defined question in mathematical logic. The solution rests upon a seminal result by Emil Post, known as Post's criterion or Post's lattice theorem. This theorem provides a complete classification of all clones on the two-element set $\\{0,1\\}$. A set of Boolean functions $\\mathcal{C}$ is functionally complete if and only if it is not a subset of any of the five maximal (or precomplete) clones. The decision procedure therefore involves testing the given set of connectives $\\mathcal{C}$ for inclusion in each of these five specific classes of functions. If $\\mathcal{C}$ is not entirely contained within any single one of these five classes, it is adequate. Otherwise, it is not.\n\nThe five maximal clones are:\n1.  The class of $0$-preserving functions, denoted $\\mathsf{T}_0$. A function $f$ is in $\\mathsf{T}_0$ if $f(0, 0, \\dots, 0) = 0$.\n2.  The class of $1$-preserving functions, denoted $\\mathsf{T}_1$. A function $f$ is in $\\mathsf{T}_1$ if $f(1, 1, \\dots, 1) = 1$.\n3.  The class of self-dual functions, denoted $\\mathsf{S}$. A function $f$ is in $\\mathsf{S}$ if it is its own dual up to negation, i.e., $f(x_1, \\dots, x_n) = \\neg f(\\neg x_1, \\dots, \\neg x_n)$, where $\\neg x = 1-x$.\n4.  The class of monotone functions, denoted $\\mathsf{M}$. A function $f$ is in $\\mathsf{M}$ if it preserves the natural partial order on $\\{0,1\\}^n$. That is, for any two input vectors $\\mathbf{x}=(x_1, \\dots, x_n)$ and $\\mathbf{y}=(y_1, \\dots, y_n)$, if $\\mathbf{x} \\le \\mathbf{y}$ (meaning $x_k \\le y_k$ for all $k \\in \\{1, \\dots, n\\}$), then $f(\\mathbf{x}) \\le f(\\mathbf{y})$.\n5.  The class of affine functions, denoted $\\mathsf{L}$. A function $f$ is in $\\mathsf{L}$ if it can be expressed as a linear polynomial over the finite field $\\mathbb{F}_2$. That is, there exist coefficients $a_0, a_1, \\dots, a_n \\in \\{0, 1\\}$ such that for all $\\mathbf{x} \\in \\{0, 1\\}^n$, $f(\\mathbf{x}) = a_0 \\oplus a_1 x_1 \\oplus \\cdots \\oplus a_n x_n$, where $\\oplus$ denotes addition modulo $2$ (XOR).\n\nTo implement the decision procedure for a given set of connectives $\\mathcal{C}$, we must first develop an algorithmic test for each of these five properties. For each connective $f \\in \\mathcal{C}$, represented by its arity $n$ and its truth table vector $\\mathbf{t}$ of length $2^n$, we perform the following checks. The input vector $(x_1, \\dots, x_n)$ corresponds to the index $i = \\sum_{k=1}^n x_k 2^{k-1}$ in the truth table, so that $f(x_1, \\dots, x_n) = \\mathbf{t}[i]$.\n\n**1. Test for $0$-preservation ($\\mathsf{T}_0$)**\nA function $f$ is $0$-preserving if $f(0, \\dots, 0) = 0$. The input vector $(0, \\dots, 0)$ corresponds to index $i=0$. Thus, the check is simply $\\mathbf{t}[0] = 0$.\n\n**2. Test for $1$-preservation ($\\mathsf{T}_1$)**\nA function $f$ is $1$-preserving if $f(1, \\dots, 1) = 1$. The input vector $(1, \\dots, 1)$ corresponds to index $i = \\sum_{k=1}^n 1 \\cdot 2^{k-1} = 2^n - 1$. The check is $\\mathbf{t}[2^n-1] = 1$.\n\n**3. Test for self-duality ($\\mathsf{S}$)**\nA function $f$ is self-dual if $f(\\mathbf{x}) = 1 - f(\\neg\\mathbf{x})$ for all $\\mathbf{x} \\in \\{0,1\\}^n$. If the input vector $\\mathbf{x}$ corresponds to index $i$, its bitwise negation $\\neg\\mathbf{x}$ corresponds to index $(2^n-1)-i$. The condition becomes $\\mathbf{t}[i] = 1 - \\mathbf{t}[2^n-1-i]$ for all $i \\in \\{0, \\dots, 2^n-1\\}$. We must verify this for all indices $i$.\n\n**4. Test for monotonicity ($\\mathsf{M}$)**\nA function $f$ is monotone if $\\mathbf{x} \\le \\mathbf{y}$ implies $f(\\mathbf{x}) \\le f(\\mathbf{y})$. Let $\\mathbf{x}$ and $\\mathbf{y}$ correspond to indices $i$ and $j$ respectively. The condition $\\mathbf{x} \\le \\mathbf{y}$ is equivalent to the bitwise condition $(i \\text{ AND } j) = i$. Therefore, we must verify that for all pairs of indices $(i, j)$ in $\\{0, \\dots, 2^n-1\\}$, if $(i \\text{ AND } j) = i$, then $\\mathbf{t}[i] \\le \\mathbf{t}[j]$.\n\n**5. Test for affineness ($\\mathsf{L}$)**\nA function $f$ is affine if $f(\\mathbf{x}) = a_0 \\oplus \\bigoplus_{k=1}^n a_k x_k$. The coefficients can be uniquely determined from the function's behavior on the zero vector and the standard basis vectors.\n-   The constant term is $a_0 = f(0, \\dots, 0) = \\mathbf{t}[0]$.\n-   For $k \\in \\{1, \\dots, n\\}$, let $\\mathbf{e}_k$ be the vector with $x_k=1$ and all other components $0$. The index for $\\mathbf{e}_k$ is $2^{k-1}$. Then $f(\\mathbf{e}_k) = a_0 \\oplus a_k$, which implies $a_k = f(\\mathbf{e}_k) \\oplus a_0 = \\mathbf{t}[2^{k-1}] \\oplus \\mathbf{t}[0]$.\nAfter finding these candidate coefficients $a_0, a_1, \\dots, a_n$, we must verify that they correctly reproduce the entire truth table. We iterate through all $2^n$ inputs $\\mathbf{x}$, compute the value of the affine form $a_0 \\oplus \\bigoplus_{k=1}^n a_k x_k$, and check if it matches $f(\\mathbf{x}) = \\mathbf{t}[i]$. If this holds for all inputs, the function is affine.\n\n**Final Decision Logic:**\nFor a given set of connectives $\\mathcal{C}$, we determine if $\\mathcal{C} \\subseteq \\mathsf{P}$ for each property $\\mathsf{P} \\in \\{\\mathsf{T}_0, \\mathsf{T}_1, \\mathsf{M}, \\mathsf{S}, \\mathsf{L}\\}$. This is done by checking if *every* function in $\\mathcal{C}$ has the property $\\mathsf{P}$. Let $C_P$ be the boolean flag indicating whether $\\mathcal{C} \\subseteq \\mathsf{P}$. The set $\\mathcal{C}$ is adequate if and only if none of these flags are true, i.e., $\\neg(C_{\\mathsf{T}_0} \\lor C_{\\mathsf{T}_1} \\lor C_{\\mathsf{M}} \\lor C_{\\mathsf{S}} \\lor C_{\\mathsf{L}})$.\nThe implementation will apply this logic to each of the provided test cases.", "answer": "[True,True,True,True,False,False,False,False]", "id": "2968171"}]}