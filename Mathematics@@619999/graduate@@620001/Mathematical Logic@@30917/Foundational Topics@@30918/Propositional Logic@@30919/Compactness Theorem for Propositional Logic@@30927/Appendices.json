{"hands_on_practices": [{"introduction": "The Compactness Theorem is a powerful tool for establishing the existence of models for infinite theories. This practice problem guides you through a classic application, where you construct a model for a theory containing an infinite chain of implications, such as $p_{n+1} \\to p_n$ for all $n \\in \\mathbb{N}$ [@problem_id:2970273]. By first proving that every finite subset is satisfiable and then invoking the theorem, you will directly experience how compactness bridges the gap from finite, local consistency to global, infinite satisfiability.", "problem": "Consider countably many propositional variables $\\{p_{n} : n \\in \\mathbb{N}\\}$ and the theory $T$ given by\n$$T \\;=\\; \\{\\, p_{n+1} \\to p_{n} : n \\in \\mathbb{N} \\,\\} \\;\\cup\\; \\{\\, \\neg p_{0} \\,\\}.$$\nWork in classical propositional semantics where a valuation $v$ assigns each propositional variable a truth value in $\\{0,1\\}$, with $1$ denoting truth and $0$ denoting falsity, and extends to all formulas in the usual way: $v(\\neg \\varphi) = 1 - v(\\varphi)$, $v(\\varphi \\land \\psi) = \\min\\{v(\\varphi),v(\\psi)\\}$, $v(\\varphi \\lor \\psi) = \\max\\{v(\\varphi),v(\\psi)\\}$, and $v(\\varphi \\to \\psi) = \\max\\{1 - v(\\varphi), v(\\psi)\\}$.\n\nYour tasks are:\n- Build the theory $T$ above and prove that every finite subset of $T$ is satisfiable by explicitly constructing a valuation for an arbitrary finite subset.\n- Using the Compactness Theorem for Propositional Logic (CTPL), deduce that $T$ is satisfiable, and derive a specific global satisfying valuation $v$ that satisfies all formulas in $T$.\n- Prove that any satisfying valuation for $T$ must assign $v(p_{n}) = 0$ for all $n \\in \\mathbb{N}$.\n- Define the real number\n$$S \\;=\\; \\sum_{n=0}^{\\infty} 2^{-n-1} \\, v\\!\\big(p_{n+1} \\to p_{n}\\big),$$\nand evaluate $S$ exactly. No rounding is required.", "solution": "The problem statement is analyzed and found to be valid. It is a well-posed problem in mathematical logic, grounded in standard definitions of classical propositional semantics and the Compactness Theorem. All terms are defined, and the tasks are clear and logically sequential.\n\nThe problem will be solved by addressing each of the four tasks in order.\n\n**Task 1: Prove that every finite subset of $T$ is satisfiable.**\n\nLet $T = \\{\\, p_{n+1} \\to p_{n} : n \\in \\mathbb{N} \\,\\} \\;\\cup\\; \\{\\, \\neg p_{0} \\,\\}$. Let $S$ be an arbitrary finite subset of $T$. We need to construct a valuation $v_S$ that satisfies all formulas in $S$. We consider two cases based on the membership of $\\neg p_0$ in $S$.\n\nCase 1: $\\neg p_0 \\notin S$.\nIn this case, $S$ consists of a finite number of formulas of the form $p_{k+1} \\to p_k$. Let's define a valuation $v_1$ such that $v_1(p_n) = 1$ for all $n \\in \\mathbb{N}$.\nFor any formula $(p_{k+1} \\to p_k) \\in S$, the truth value under $v_1$ is:\n$$v_1(p_{k+1} \\to p_k) = \\max\\{1 - v_1(p_{k+1}), v_1(p_k)\\} = \\max\\{1-1, 1\\} = 1.$$\nThus, $v_1$ satisfies every formula in $S$. Therefore, $S$ is satisfiable.\n\nCase 2: $\\neg p_0 \\in S$.\nIn this case, $S$ contains the formula $\\neg p_0$ and a finite number of formulas of the form $p_{k+1} \\to p_k$.\nLet's define a valuation $v_0$ such that $v_0(p_n) = 0$ for all $n \\in \\mathbb{N}$.\nWe check if this valuation $v_0$ satisfies all formulas in $S$.\nFirst, consider the formula $\\neg p_0$:\n$$v_0(\\neg p_0) = 1 - v_0(p_0) = 1 - 0 = 1.$$\nSo, $\\neg p_0$ is satisfied by $v_0$.\nNext, consider any formula $(p_{k+1} \\to p_k) \\in S$:\n$$v_0(p_{k+1} \\to p_k) = \\max\\{1 - v_0(p_{k+1}), v_0(p_k)\\} = \\max\\{1-0, 0\\} = 1.$$\nSo, any implication in $S$ is also satisfied by $v_0$.\nThus, $v_0$ satisfies every formula in $S$. Therefore, $S$ is satisfiable.\n\nSince in both cases we found a satisfying valuation, every finite subset $S$ of $T$ is satisfiable.\n\n**Task 2: Using CTPL, deduce that $T$ is satisfiable, and derive a specific global satisfying valuation.**\n\nThe Compactness Theorem for Propositional Logic (CTPL) states that a set of propositional formulas is satisfiable if and only if every finite subset of it is satisfiable.\nFrom Task 1, we have established that every finite subset of $T$ is satisfiable. By the CTPL, we can deduce that the entire infinite set of formulas $T$ is satisfiable.\nThis means there exists a valuation $v$ such that $v(\\phi) = 1$ for all $\\phi \\in T$. Let's determine the properties of such a valuation $v$.\n\n1.  From $\\neg p_0 \\in T$, we must have $v(\\neg p_0) = 1$. This implies $1 - v(p_0) = 1$, which means $v(p_0) = 0$.\n2.  For every $n \\in \\mathbb{N}$, the formula $(p_{n+1} \\to p_n) \\in T$ must be satisfied. So, $v(p_{n+1} \\to p_n) = 1$. This is equivalent to $\\max\\{1 - v(p_{n+1}), v(p_n)\\} = 1$. This condition is violated only if $1 - v(p_{n+1}) = 0$ and $v(p_n) = 0$, which means $v(p_{n+1}) = 1$ and $v(p_n) = 0$. Therefore, the condition $v(p_{n+1} \\to p_n) = 1$ is equivalent to stating that we cannot have $v(p_{n+1})=1$ and $v(p_n)=0$. Because the variables can only take values in $\\{0,1\\}$, this is equivalent to the inequality $v(p_{n+1}) \\le v(p_n)$.\n\nCombining these conditions, we have a chain of inequalities for the truth values:\n$$ \\ldots \\le v(p_{n+1}) \\le v(p_n) \\le \\ldots \\le v(p_1) \\le v(p_0) $$\nSince we already established that $v(p_0) = 0$, the chain becomes:\n$$ \\ldots \\le v(p_{n+1}) \\le v(p_n) \\le \\ldots \\le v(p_1) \\le v(p_0) = 0 $$\nAs truth values are non-negative, for any $n \\in \\mathbb{N}$, we have $0 \\le v(p_n)$.\nCombining these, we get $0 \\le v(p_n) \\le 0$ for all $n \\in \\mathbb{N}$.\nSince $v(p_n)$ must be in $\\{0, 1\\}$, the only possibility is $v(p_n) = 0$ for all $n \\in \\mathbb{N}$.\n\nThe specific global satisfying valuation $v$ is therefore given by $v(p_n) = 0$ for all $n \\in \\mathbb{N}$. We have already verified in Task 1 (Case 2) that this valuation indeed satisfies all formulas in $T$.\n\n**Task 3: Prove that any satisfying valuation for $T$ must assign $v(p_n) = 0$ for all $n \\in \\mathbb{N}$.**\n\nThis task is to formally prove the uniqueness of the satisfying valuation derived in Task 2. We use mathematical induction on $n$.\nLet $v$ be an arbitrary valuation that satisfies the theory $T$.\n\nBase Case: For $n=0$.\nSince $\\neg p_0 \\in T$, it must be the case that $v(\\neg p_0) = 1$. By the definition of the semantics for negation, $1 - v(p_0) = 1$, which implies $v(p_0) = 0$. The base case holds.\n\nInductive Hypothesis: Assume that for some integer $k \\ge 0$, $v(p_k) = 0$.\n\nInductive Step: We must prove that $v(p_{k+1}) = 0$.\nThe theory $T$ contains the formula $p_{k+1} \\to p_k$. Since $v$ satisfies $T$, we have $v(p_{k+1} \\to p_k) = 1$.\nThe semantics for implication gives $\\max\\{1 - v(p_{k+1}), v(p_k)\\} = 1$.\nSubstituting the inductive hypothesis $v(p_k) = 0$ into this equation, we get:\n$$ \\max\\{1 - v(p_{k+1}), 0\\} = 1 $$\nThis equality can only hold if $1 - v(p_{k+1}) = 1$.\nThis implies $v(p_{k+1}) = 0$.\n\nConclusion: By the principle of mathematical induction, we have proven that $v(p_n) = 0$ for all $n \\in \\mathbb{N}$. This shows that the valuation $v(p_n)=0$ for all $n$ is the *only* possible satisfying valuation for the theory $T$.\n\n**Task 4: Evaluate the sum $S$.**\n\nThe real number $S$ is defined as:\n$$ S \\;=\\; \\sum_{n=0}^{\\infty} 2^{-n-1} \\, v\\!\\big(p_{n+1} \\to p_{n}\\big) $$\nThe valuation $v$ in this expression must be a satisfying valuation for the theory $T$. As proven in Task 3, there is only one such valuation, where $v(p_n) = 0$ for all $n \\in \\mathbb{N}$.\nWe must first evaluate the term $v(p_{n+1} \\to p_n)$ using this unique valuation. For any $n \\in \\mathbb{N}$:\n$$ v(p_{n+1} \\to p_n) = \\max\\{1 - v(p_{n+1}), v(p_n)\\} = \\max\\{1 - 0, 0\\} = 1. $$\nSo, for every term in the summation, the factor $v(p_{n+1} \\to p_n)$ is equal to $1$.\nSubstituting this result into the expression for $S$:\n$$ S = \\sum_{n=0}^{\\infty} 2^{-n-1} \\cdot 1 = \\sum_{n=0}^{\\infty} \\frac{1}{2^{n+1}} $$\nThis is a geometric series. We can write out the terms:\n$$ S = \\frac{1}{2^1} + \\frac{1}{2^2} + \\frac{1}{2^3} + \\ldots $$\nThis series has a first term $a = \\frac{1}{2}$ and a common ratio $r = \\frac{1}{2}$. Since $|r| < 1$, the sum converges to:\n$$ S = \\frac{a}{1-r} = \\frac{\\frac{1}{2}}{1 - \\frac{1}{2}} = \\frac{\\frac{1}{2}}{\\frac{1}{2}} = 1. $$\nAlternatively, we can shift the index of summation. Let $k = n+1$. As $n$ goes from $0$ to $\\infty$, $k$ goes from $1$ to $\\infty$:\n$$ S = \\sum_{k=1}^{\\infty} \\left(\\frac{1}{2}\\right)^k = \\left(\\sum_{k=0}^{\\infty} \\left(\\frac{1}{2}\\right)^k\\right) - \\left(\\frac{1}{2}\\right)^0 = \\left(\\frac{1}{1-\\frac{1}{2}}\\right) - 1 = 2 - 1 = 1. $$\nThe value of $S$ is exactly $1$.", "answer": "$$\\boxed{1}$$", "id": "2970273"}, {"introduction": "This exercise connects the abstract Compactness Theorem to the concrete and computationally vital concept of an unsatisfiable core. The theorem's contrapositive states that if a theory $\\Gamma$ is unsatisfiable, a finite subset $\\Delta \\subseteq \\Gamma$ must be the cause, which implies the existence of an inclusion-minimal finite unsatisfiable subset (MUS). This problem challenges you to both prove the existence of an MUS and devise an algorithm to find one, linking theoretical insight directly to practical automated reasoning [@problem_id:2970266].", "problem": "Let $\\mathcal{L}$ be a countable set of propositional variables $\\{p_1,p_2,\\dots\\}$ and let a literal be either $p_k$ or $\\neg p_k$. A clause is a finite disjunction of literals, and a Conjunctive Normal Form (CNF) theory is a finite or infinite set of clauses, interpreted as their conjunction. A CNF theory $\\Gamma$ is satisfiable if there exists a truth assignment $\\sigma:\\mathcal{L}\\to\\{\\text{True},\\text{False}\\}$ such that every clause in $\\Gamma$ is true under $\\sigma$, and unsatisfiable otherwise. The compactness theorem for propositional logic states that a CNF theory is satisfiable if and only if every finite subset is satisfiable. Equivalently, if $\\Gamma$ is unsatisfiable, then some finite subset $\\Delta\\subseteq\\Gamma$ is unsatisfiable.\n\nTask Part I (theoretical): Starting from the compactness theorem for propositional logic and the core definitions above, prove that for any unsatisfiable CNF theory $\\Gamma$, there exists a minimal finite unsatisfiable subset (Minimal Unsatisfiable Subset (MUS)) $\\Sigma\\subseteq\\Gamma$ such that $\\Sigma$ is unsatisfiable and every proper subset of $\\Sigma$ is satisfiable. Explain why this follows from the existence of a finite unsatisfiable subset and elementary finiteness arguments. Then, explain two principled ways to locate such a core: (i) using the resolution rule and the existence of a resolution refutation, and (ii) using hitting set duality between MUS and Minimal Correction Sets (MCS), where an MCS is a minimal subset of clauses whose removal makes the theory satisfiable.\n\nTask Part II (algorithmic): Implement a program that, given several CNF theories encoded over $\\{p_1,p_2,\\dots\\}$, computes one MUS per unsatisfiable input and returns the indices of the clauses constituting that MUS with respect to the input ordering. If the input CNF theory is satisfiable, return the empty list for that test case. The program may use any sound and complete satisfiability procedure for propositional CNF (e.g., the Davis–Putnam–Logemann–Loveland (DPLL) algorithm) to test satisfiability and then perform deletion-based shrinking to a MUS. While the theoretical part may rely on resolution or hitting set duality, the implementation may use a satisfiability checker with iterative deletion to ensure minimality.\n\nRepresentation and input encoding for the test suite:\n- A CNF theory is represented as a Python list of clauses.\n- Each clause is a Python list of integers. A positive integer $k$ represents the literal $p_k$, and a negative integer $-k$ represents the literal $\\neg p_k$.\n- The empty clause is represented by the empty list $[\\ ]$, which is unsatisfiable by itself.\n- For example, the CNF theory with clauses $(p_1)$, $(\\neg p_1)$, $(p_1\\lor p_2)$ is represented as $\\big[[1],[-1],[1,2]\\big]$.\n\nTest suite (five cases covering distinct facets):\n1. Happy path unsatisfiable with an obvious core:\n   - $\\Gamma_1 = \\big[[1],[-1],[1,2]\\big]$. This is unsatisfiable since it contains $(p_1)$ and $(\\neg p_1)$. A MUS has indices $[0,1]$.\n2. Nontrivial unsatisfiable where every clause is required:\n   - $\\Gamma_2 = \\big[[1,2],[-1],[-2]\\big]$. This is unsatisfiable, and removing any single clause makes it satisfiable. A MUS has indices $[0,1,2]$.\n3. Unsatisfiable with a tautology present:\n   - $\\Gamma_3 = \\big[[1,-1],[1],[-1]\\big]$, where $[1,-1]$ encodes $(p_1\\lor\\neg p_1)$, a tautology. A MUS is obtained by dropping the tautology, yielding indices $[1,2]$.\n4. Satisfiable CNF (boundary condition):\n   - $\\Gamma_4 = \\big[[1,2],[-1,2],[1,-2]\\big]$. This is satisfiable (e.g., $p_1=\\text{True}$, $p_2=\\text{True}$). The output must be the empty list $[\\ ]$.\n5. Edge case with the empty clause:\n   - $\\Gamma_5 = \\big[[],[1]\\big]$. This is unsatisfiable because of the empty clause alone; a MUS is the empty clause, with indices $[0]$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is the list of clause indices forming one MUS for the corresponding test case (or the empty list if the CNF is satisfiable). For the five test cases above, the output must have the form $\\big[[i\\_1^{(1)},\\dots],[i\\_1^{(2)},\\dots],[\\dots],[\\dots],[\\dots]\\big]$ with no spaces, for example, $\\big[[0,1],[0,1,2],[1,2],[],[0]\\big]$.\n\nYour program must be self-contained, not read any input, and strictly compute and print the specified output line using the test cases above. No physical units, angle units, or percentages are involved in this problem; all answers are integer indices encoded as specified. The algorithm should be principled, sound, and complete for the small test suite provided, reflecting the theoretical basis outlined in Part I.", "solution": "The analysis of the problem proceeds in two parts as requested: a theoretical proof and explanation, followed by an algorithmic implementation strategy.\n\n### Part I: Theoretical Foundation\n\n#### Proof of the Existence of a Minimal Unsatisfiable Subset (MUS)\n\nLet $\\Gamma$ be an unsatisfiable Conjunctive Normal Form (CNF) theory over a countable set of propositional variables $\\mathcal{L} = \\{p_1, p_2, \\dots\\}$. A clause is a finite disjunction of literals (e.g., $p_k$ or $\\neg p_k$), and $\\Gamma$ is a set of such clauses.\n\n1.  **Application of the Compactness Theorem**: The compactness theorem for propositional logic states that a theory is satisfiable if and only if every finite subset of it is satisfiable. The contrapositive form, which is more useful here, states that if a theory $\\Gamma$ is unsatisfiable, then there must exist a finite subset $\\Delta \\subseteq \\Gamma$ that is also unsatisfiable.\n\n2.  **Argument from Finiteness**: Since $\\Gamma$ is unsatisfiable, we are guaranteed the existence of at least one finite unsatisfiable subset $\\Delta \\subseteq \\Gamma$. Let us consider the set $\\mathcal{F}$ of all finite unsatisfiable subsets of $\\Gamma$.\n    $$\n    \\mathcal{F} = \\{S \\mid S \\subseteq \\Gamma, |S| < \\infty, \\text{ and } S \\text{ is unsatisfiable}\\}\n    $$\n    By the compactness theorem, $\\mathcal{F}$ is non-empty. We are searching for a minimal element in this set, where minimality is defined with respect to the subset relation $\\subseteq$. An element $\\Sigma \\in \\mathcal{F}$ is minimal if no proper subset of $\\Sigma$ is also in $\\mathcal{F}$. That is, for every $\\Sigma' \\subset \\Sigma$, $\\Sigma'$ is satisfiable. This is precisely the definition of a Minimal Unsatisfiable Subset (MUS).\n\n3.  **Constructive Existence via Minimization**: We can show such a minimal element $\\Sigma$ must exist. Let's start with any element $\\Delta \\in \\mathcal{F}$. $\\Delta$ is a finite set of clauses.\n    - If $\\Delta$ is already a minimal unsatisfiable subset, we have found our MUS, and we are done. Let $\\Sigma = \\Delta$.\n    - If $\\Delta$ is not minimal, then by definition there exists a proper subset $\\Delta' \\subset \\Delta$ such that $\\Delta'$ is also unsatisfiable. Since $\\Delta$ is finite, $\\Delta'$ must also be finite, which implies $\\Delta' \\in \\mathcal{F}$. We can now replace $\\Delta$ with $\\Delta'$ and repeat the process.\n\n    This procedure generates a sequence of finite unsatisfiable sets $\\Delta_0, \\Delta_1, \\Delta_2, \\dots$ such that $\\Delta_0 = \\Delta$ and $\\Delta_{i+1} \\subset \\Delta_i$. Since each set is a *proper* subset of the previous one, their cardinalities must be strictly decreasing: $|\\Delta_0| > |\\Delta_1| > |\\Delta_2| > \\dots$. Because $\\Delta_0$ is a finite set, its cardinality $|\\Delta_0|$ is a non-negative integer. A strictly decreasing sequence of non-negative integers must be finite. Therefore, this process of finding smaller unsatisfiable subsets must terminate in a finite number of steps. It terminates when we reach a finite unsatisfiable set $\\Sigma$ for which no proper subset is unsatisfiable. Such a set $\\Sigma$ is an MUS.\n\nThis argument demonstrates that for any unsatisfiable theory $\\Gamma$, at least one MUS exists within it.\n\n#### Principled Methods for Locating an MUS\n\n1.  **(i) Resolution Rule and Refutation**: The resolution principle is a sound and complete inference rule for CNF theories. The rule states that from two clauses $(A \\lor x)$ and $(B \\lor \\neg x)$, where $A$ and $B$ are disjunctions of literals and $x$ is a literal, one can infer the resolvent clause $(A \\lor B)$. A CNF theory is unsatisfiable if and only if the empty clause, denoted $\\bot$, can be derived from it using a sequence of resolution steps. Such a sequence (or more generally, a directed acyclic graph of derivations) is called a resolution refutation.\n\n    A resolution refutation for an unsatisfiable theory $\\Gamma$ only uses a finite number of clauses from $\\Gamma$. The set of clauses from $\\Gamma$ used as leaves in the refutation proof graph constitutes a finite unsatisfiable subset. To find an MUS, one can seek a *minimal* resolution refutation, where removing any of the initial clauses used in the proof would make it impossible to derive $\\bot$. The set of clauses from $\\Gamma$ used in such a minimal proof forms an MUS. While finding a minimal refutation is computationally hard, the existence of a refutation provides a concrete \"witness\" to the unsatisfiability of a particular subset of clauses, thereby grounding the concept of an unsatisfiable core. Algorithmically, one can start with a finite unsatisfiable set $\\Delta$ and its refutation, then iteratively try to remove clauses and see if a refutation can still be found for the remainder.\n\n2.  **(ii) Hitting Set Duality with Minimal Correction Sets (MCS)**: This approach relates MUSes to another concept, Minimal Correction Sets (MCS). An MCS of an unsatisfiable theory $\\Gamma$ is a minimal subset of clauses $C \\subseteq \\Gamma$ such that removing it makes the theory satisfiable (i.e., $\\Gamma \\setminus C$ is satisfiable).\n\n    The duality principle states that the set of all MUSes and the set of all MCSes of a theory are hitting set duals of each other. Specifically:\n    - A subset $\\Sigma \\subseteq \\Gamma$ is an MUS if and only if it is a minimal hitting set of the collection of all MCSs of $\\Gamma$.\n    - A subset $C \\subseteq \\Gamma$ is an MCS if and only if it is a minimal hitting set of the collection of all MUSes of $\\Gamma$.\n\n    A set $H$ is a *hitting set* for a collection of sets $\\mathcal{S}$ if $H$ has a non-empty intersection with every set in $\\mathcal{S}$ (i.e., $\\forall S \\in \\mathcal{S}, H \\cap S \\ne \\emptyset$).\n\n    This duality provides a principled, albeit often computationally expensive, way to find an MUS. The algorithm would be:\n    1.  Enumerate all MCSs of the theory $\\Gamma$. This can be done using a SAT solver by repeatedly finding a minimal set of clauses to remove to achieve satisfiability.\n    2.  Let the collection of all MCSs be $\\mathcal{C} = \\{M_1, M_2, \\dots\\}$.\n    3.  Formulate and solve the minimal hitting set problem for $\\mathcal{C}$. The solution to this problem is a set of clauses $\\Sigma$ that is guaranteed to be an MUS of $\\Gamma$.\n\n### Part II: Algorithmic Strategy\n\nThe implementation will find an MUS using a deletion-based shrinking algorithm, which relies on an oracle for satisfiability checking (a SAT solver).\n\n1.  **SAT Solver**: A SAT solver is required to determine whether a given CNF theory is satisfiable. We will implement a basic DPLL (Davis-Putnam-Logemann-Loveland) algorithm. This algorithm recursively explores the space of truth assignments. Its core components are:\n    - **Unit Propagation**: If a clause contains only one literal (a \"unit clause\" $[l]$), that literal must be assigned True. This assignment can simplify the formula, potentially creating new unit clauses. This process is repeated until no unit clauses remain. If this process generates an empty clause, the formula is unsatisfiable.\n    - **Pure Literal Elimination**: If a variable $p_k$ appears in the formula only in its positive form ($p_k$) or only in its negative form ($\\neg p_k$), it is a \"pure literal\". We can safely assign it a truth value that satisfies all clauses it appears in, simplifying the formula.\n    - **Splitting (Branching)**: If no further simplifications are possible, an unassigned variable is chosen, and the algorithm recursively checks for satisfiability by assigning it first True, then False. If either branch leads to a satisfying assignment, the formula is satisfiable.\n\n2.  **MUS Extraction (Deletion-Based Shrinking)**: Given an unsatisfiable CNF theory $\\Gamma$, this algorithm identifies one MUS as follows:\n    1.  Start with a candidate set of clauses, initially the entire theory $\\Gamma$. Let the set of indices of these clauses be $I$.\n    2.  Iterate through each clause $c_i$ in the candidate set (with index $i \\in I$).\n    3.  For each clause $c_i$, temporarily remove it from the candidate set.\n    4.  Use the SAT solver to check if the remaining set of clauses is still unsatisfiable.\n    5.  - If the remaining set is **satisfiable**, it means the clause $c_i$ is essential for the unsatisfiability of the current set. The clause $c_i$ must be part of the final MUS, so it is kept in the candidate set.\n        - If the remaining set is still **unsatisfiable**, the clause $c_i$ is redundant. It can be permanently removed from the candidate set $I$.\n    6.  After checking every clause once, the final set of clauses remaining in the candidate set constitutes one MUS. Iterating backwards over the indices (from largest to smallest) is a simple way to implement this without issues from modifying the list of indices during iteration.", "answer": "```python\nclass SATSolver:\n    \"\"\"\n    A simple DPLL-based SAT solver with memoization.\n    It uses recursion to perform unit propagation, pure literal elimination,\n    and branching.\n    \"\"\"\n    def __init__(self):\n        self.memo = {}\n\n    def check_sat(self, clauses):\n        \"\"\"\n        Checks if a CNF formula, given as a list of clauses, is satisfiable.\n        \"\"\"\n        # A canonical key for the formula for memoization.\n        key = tuple(sorted(tuple(sorted(c)) for c in clauses))\n        if key in self.memo:\n            return self.memo[key]\n\n        # Base cases: empty formula is SAT, formula with empty clause is UNSAT.\n        if not clauses:\n            self.memo[key] = True\n            return True\n        if any(not c for c in clauses):\n            self.memo[key] = False\n            return False\n\n        # Unit Propagation: Find one unit clause and simplify.\n        for clause in clauses:\n            if len(clause) == 1:\n                literal = clause[0]\n                simplified_clauses = []\n                is_unsat = False\n                for c in clauses:\n                    if literal in c:\n                        continue\n                    if -literal in c:\n                        new_c = [l for l in c if l != -literal]\n                        if not new_c:\n                            is_unsat = True\n                            break\n                        simplified_clauses.append(new_c)\n                    else:\n                        simplified_clauses.append(c)\n                \n                if is_unsat:\n                    self.memo[key] = False\n                    return False\n\n                # Recurse on the simplified formula.\n                res = self.check_sat(simplified_clauses)\n                self.memo[key] = res\n                return res\n\n        # Pure Literal Elimination: Find one pure literal and simplify.\n        all_lits = {l for c in clauses for l in c}\n        for pure_lit in all_lits:\n            if -pure_lit not in all_lits:\n                simplified_clauses = [c for c in clauses if pure_lit not in c]\n                res = self.check_sat(simplified_clauses)\n                self.memo[key] = res\n                return res\n\n        # Branching (Splitting Rule): Pick a variable and try both assignments.\n        var = clauses[0][0]\n        \n        # Try var = True by adding a unit clause [var].\n        res1 = self.check_sat(clauses + [[var]])\n        if res1:\n            self.memo[key] = True\n            return True\n        \n        # Try var = False if the first branch failed.\n        res2 = self.check_sat(clauses + [[-var]])\n        self.memo[key] = res2\n        return res2\n\ndef find_mus(cnf):\n    \"\"\"\n    Finds a Minimal Unsatisfiable Subset (MUS) of a CNF formula.\n    Returns a list of indices of the clauses in the MUS.\n    If the formula is satisfiable, returns an empty list.\n    \"\"\"\n    solver = SATSolver()\n    if solver.check_sat(cnf):\n        return []\n\n    mus_indices = list(range(len(cnf)))\n    # Iterate backwards through the original clause indices.\n    for i in range(len(cnf) - 1, -1, -1):\n        # Check if clause 'i' is still a candidate.\n        if i not in mus_indices:\n            continue\n\n        # Temporarily remove clause 'i' and check satisfiability.\n        temp_indices = [idx for idx in mus_indices if idx != i]\n\n        # If removing 'i' results in an empty formula, it must be SAT.\n        # This means 'i' is essential. We can't remove it.\n        # This check is implicitly handled by the SAT solver on an empty list.\n        \n        temp_cnf = [cnf[idx] for idx in temp_indices]\n        \n        # Use a fresh solver for each subproblem to ensure no memoization conflicts.\n        temp_solver = SATSolver()\n        if not temp_solver.check_sat(temp_cnf):\n            # If the formula is still UNSAT, clause 'i' is redundant.\n            mus_indices.remove(i)\n            \n    return sorted(mus_indices)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # 1. Happy path unsatisfiable with an obvious core\n        [[1], [-1], [1, 2]],\n        # 2. Nontrivial unsatisfiable where every clause is required\n        [[1, 2], [-1], [-2]],\n        # 3. Unsatisfiable with a tautology present\n        [[1, -1], [1], [-1]],\n        # 4. Satisfiable CNF (boundary condition)\n        [[1, 2], [-1, 2], [1, -2]],\n        # 5. Edge case with the empty clause\n        [[], [1]],\n    ]\n\n    results = []\n    for cnf in test_cases:\n        mus = find_mus(cnf)\n        results.append(mus)\n\n    # Format the output string to be a single line with no spaces.\n    # e.g., [[0,1],[0,1,2],[1,2],[],[0]]\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2970266"}, {"introduction": "This final practice session operationalizes the Compactness Theorem to extract finite proofs from infinite premise sets. It is based on the principle that an entailment $\\Gamma \\models \\varphi$ holds if and only if the set $\\Gamma \\cup \\{\\neg \\varphi\\}$ is unsatisfiable, which by compactness reduces to a finite, unsatisfiable core. You will implement a procedure that mechanically finds a finite witness $\\Delta \\subseteq \\Gamma$ for the entailment, reinforcing a cornerstone of modern logic-based systems: the link between semantic consequence and finite, verifiable certificates [@problem_id:2970291].", "problem": "You are given a countable set of propositional premises $\\Gamma$ and a target formula $\\varphi$ such that $\\Gamma \\models \\varphi$. Using only fundamental facts of propositional logic, design and implement a mechanical procedure that, from $\\Gamma$ and $\\varphi$, extracts a finite subset $\\Delta \\subseteq \\Gamma$ that witnesses the entailment, in the sense that $\\Delta \\models \\varphi$. Your procedure must rely only on the following foundational basis and must not assume any additional shortcut facts.\n\nFundamental basis:\n- Semantics of propositional logic: a valuation assigns truth values to variables and extends to formulas in the usual way. A set of formulas $\\Sigma$ is satisfiable if there exists a valuation that makes every formula in $\\Sigma$ true. Entailment $\\Gamma \\models \\varphi$ means every valuation that satisfies $\\Gamma$ also satisfies $\\varphi$.\n- Completeness theorem for propositional logic: for a sound and complete proof system, $\\Gamma \\models \\varphi$ if and only if $\\Gamma \\vdash \\varphi$.\n- Compactness theorem for propositional logic: if every finite subset of a set of formulas $\\Sigma$ is satisfiable, then $\\Sigma$ is satisfiable; equivalently, if $\\Sigma$ is unsatisfiable, then there exists a finite subset $\\Sigma_0 \\subseteq \\Sigma$ that is unsatisfiable.\n\nDesign requirements for the mechanical method:\n- Reduce the entailment $\\Gamma \\models \\varphi$ to unsatisfiability of $\\Gamma \\cup \\{\\neg \\varphi\\}$, and then use compactness to extract a finite unsatisfiable subset. From that subset, return the finite witness $\\Delta \\subseteq \\Gamma$ such that $\\Delta \\cup \\{\\neg \\varphi\\}$ is unsatisfiable, hence $\\Delta \\models \\varphi$.\n- Implement satisfiability checking using a complete decision procedure for propositional logic on formulas in Conjunctive Normal Form (CNF). You may use the Davis–Putnam–Logemann–Loveland (DPLL) procedure for this purpose.\n- Implement unsatisfiable core extraction by iterative clause deletion: given an unsatisfiable CNF $\\Sigma$, repeatedly try removing a clause and check satisfiability; if the remainder stays unsatisfiable, keep the clause removed. This yields a finite subset minimal by inclusion.\n\nRepresentation and constraints:\n- Variables are represented by positive integers. For example, the variable $p$ can be encoded as $1$, the variable $q$ as $2$, and so on.\n- Literals are represented by signed integers: a positive integer $k$ encodes the literal corresponding to variable $k$, and a negative integer $-k$ encodes its negation.\n- Clauses are represented as lists of integers, encoding disjunctions (logical \"or\") of literals. For example, the clause $p \\lor \\neg q$ is encoded as $[1,-2]$.\n- A CNF formula (a conjunction of clauses) is represented as a list of clauses. For example, $(p) \\land (\\neg p \\lor q)$ is encoded as $[[1],[-1,2]]$.\n- The target formula $\\varphi$ must be one of the following restricted forms to ensure that $\\neg \\varphi$ has a direct CNF representation:\n    1. A single literal $l$ (type \"literal\"), encoded as an integer. Then $\\neg \\varphi$ is the unit clause $[-l]$.\n    2. A single clause $C$ (type \"clause\"), encoded as a list of integers. Then $\\neg \\varphi$ is the conjunction of unit clauses obtained by negating each literal in $C$.\n    3. A conjunction of literals $L$ (type \"conjunction\"), encoded as a list of integers. Then $\\neg \\varphi$ is the single clause consisting of the negation of each literal in $L$.\n\nYour program must:\n- Construct $\\Sigma = \\Gamma \\cup \\{\\neg \\varphi\\}$ using the above representation rules.\n- Check that $\\Sigma$ is unsatisfiable using a complete CNF decision procedure.\n- Extract a finite unsatisfiable core $S \\subseteq \\Sigma$ minimal by inclusion via iterative deletion.\n- Output $\\Delta = S \\setminus \\{\\neg \\varphi\\}$ (multiset difference with respect to clause multiplicities), which is a finite subset of $\\Gamma$ witnessing $\\Delta \\models \\varphi$.\n\nTest suite:\nProvide a program that runs the following test cases and prints the finite witnesses $\\Delta$ for each case.\n\n- Test case $1$ (happy path; literal target): $\\Gamma = [[1],[-1,2]]$, target type \"literal\", $\\varphi = 2$.\n  Interpretation: $p$ is $1$, $q$ is $2$. The premises assert $p$ and $\\neg p \\lor q$. The target is $q$.\n- Test case $2$ (clause target; disjunction): $\\Gamma = [[1]]$, target type \"clause\", $\\varphi = [1,2]$.\n  Interpretation: Premise asserts $p$. The target is $p \\lor q$.\n- Test case $3$ (conjunction target; both literals): $\\Gamma = [[1],[2]]$, target type \"conjunction\", $\\varphi = [1,2]$.\n  Interpretation: Premises assert $p$ and $q$. The target is $p \\land q$.\n- Test case $4$ (boundary; tautological target with empty $\\Gamma$): $\\Gamma = []$, target type \"clause\", $\\varphi = [1,-1]$.\n  Interpretation: The target is $p \\lor \\neg p$, a tautology, hence entailed by the empty set.\n\nAnswer specification:\n- For each test case, the answer is the finite witness subset $\\Delta \\subseteq \\Gamma$, represented as a list of clauses (each a list of integers).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each $\\Delta$ serialized as its nested list representation. For example, the output format must be exactly of the form $[r_1,r_2,r_3,r_4]$, where each $r_i$ is the nested list for the corresponding test case.\n\nNo physical units, angle units, or percentages are involved in this problem; all outputs are purely logical and must be printed in the specified single-line format.", "solution": "The problem requires the design and implementation of a procedure to find a finite set of premises $\\Delta \\subseteq \\Gamma$ that logically entails a conclusion $\\varphi$, given that such an entailment $\\Gamma \\models \\varphi$ holds for a countable set of premises $\\Gamma$. The procedure must be constructed from first principles of propositional logic, namely the semantics of entailment, the completeness theorem, and the compactness theorem.\n\nThe solution is founded upon a key relationship in propositional logic: the deduction theorem in its semantic form. The entailment $\\Gamma \\models \\varphi$ holds if and only if the set of formulas $\\Sigma = \\Gamma \\cup \\{\\neg\\varphi\\}$ is unsatisfiable.\n\nLet us establish this equivalence.\n1. Assume $\\Gamma \\models \\varphi$. This means that any valuation (truth assignment to variables) that makes every formula in $\\Gamma$ true must also make $\\varphi$ true. Let $v$ be such a valuation. Then $v(\\gamma) = \\text{true}$ for all $\\gamma \\in \\Gamma$, which implies $v(\\varphi) = \\text{true}$. Consequently, $v(\\neg\\varphi) = \\text{false}$. This shows that no valuation $v$ can simultaneously satisfy all formulas in $\\Gamma$ and also satisfy $\\neg\\varphi$. Therefore, the set $\\Sigma = \\Gamma \\cup \\{\\neg\\varphi\\}$ is unsatisfiable.\n\n2. Assume $\\Gamma \\cup \\{\\neg\\varphi\\}$ is unsatisfiable. This means there is no valuation that makes all formulas in $\\Gamma$ true and also makes $\\neg\\varphi$ true. Consider any valuation $v$ that satisfies all of $\\Gamma$ (i.e., $v(\\gamma) = \\text{true}$ for all $\\gamma \\in \\Gamma$). For such a $v$, it must be the case that $v(\\neg\\varphi) = \\text{false}$, otherwise $v$ would be a satisfying valuation for $\\Gamma \\cup \\{\\neg\\varphi\\}$. If $v(\\neg\\varphi) = \\text{false}$, then it must be that $v(\\varphi) = \\text{true}$. This holds for any valuation $v$ that satisfies $\\Gamma$, which is precisely the definition of entailment, $\\Gamma \\models \\varphi$.\n\nGiven that $\\Gamma \\models \\varphi$, we have established that $\\Sigma = \\Gamma \\cup \\{\\neg\\varphi\\}$ is an unsatisfiable set of formulas. The problem specifies that $\\Gamma$ is countable, but possibly infinite. The compactness theorem for propositional logic states that if a set of formulas is unsatisfiable, then there must exist a finite subset of it that is also unsatisfiable.\n\nApplying the compactness theorem to $\\Sigma$, there must exist a finite subset $S \\subseteq \\Sigma$ such that $S$ is unsatisfiable. Since $S$ is a finite subset of $\\Gamma \\cup \\{\\neg\\varphi\\}$, we can partition it into two parts: one part from $\\Gamma$ and one part from $\\{\\neg\\varphi\\}$. Let us define $\\Delta = S \\cap \\Gamma$. The other part is $S \\cap \\{\\neg\\varphi\\}$. Thus, $S = \\Delta \\cup (S \\cap \\{\\neg\\varphi\\})$.\n\nSince $S$ is unsatisfiable, the entailment $\\Delta \\models \\varphi$ must hold. To see this, note that $S$ being unsatisfiable is equivalent to $\\Delta \\cup (S \\cap \\{\\neg\\varphi\\}) \\models \\bot$ (where $\\bot$ is a contradiction). This implies that for any valuation $v$ that satisfies $\\Delta$, it must not satisfy $S \\cap \\{\\neg\\varphi\\}$. As $S \\cap \\{\\neg\\varphi\\} \\subseteq \\{\\neg\\varphi\\}$, this means $v$ must make $\\neg\\varphi$ false, and thus make $\\varphi$ true. Therefore, any valuation satisfying $\\Delta$ must also satisfy $\\varphi$, which is the definition of $\\Delta \\models \\varphi$. Since $S$ is finite, its subset $\\Delta$ is also finite. Thus, $\\Delta$ is the finite witness we seek.\n\nThe mechanical procedure to implement this constructive proof is as follows:\n\n**Step 1: Formula Representation and Construction of $\\Sigma$**\nAll formulas are represented in Conjunctive Normal Form (CNF). A formula is a list of clauses, where each clause is a list of literals, and each literal is a signed integer. The premises $\\Gamma$ are provided in this form. The target formula $\\varphi$ is restricted to forms whose negation $\\neg\\varphi$ has a direct CNF representation.\n- If $\\varphi$ is a literal $l$ (e.g., variable $k$ is $k$, $\\neg k$ is $-k$), then $\\neg\\varphi$ is the literal $\\neg l$, which corresponds to the unit clause $[-l]$.\n- If $\\varphi$ is a clause $C = [l_1, l_2, \\ldots, l_m]$, then $\\neg\\varphi = \\neg(l_1 \\lor \\ldots \\lor l_m) \\equiv (\\neg l_1 \\land \\ldots \\land \\neg l_m)$. This is a conjunction of unit clauses $\\{[-l_1], [-l_2], \\ldots, [-l_m]\\}$.\n- If $\\varphi$ is a conjunction of literals $L = [l_1, l_2, \\ldots, l_m]$, then $\\varphi \\equiv l_1 \\land \\ldots \\land l_m$. Thus $\\neg\\varphi = \\neg(l_1 \\land \\ldots \\land l_m) \\equiv (\\neg l_1 \\lor \\ldots \\lor \\neg l_m)$. This is a single clause $[-l_1, -l_2, \\ldots, -l_m]$.\nThe set of clauses $\\Sigma$ is formed by taking the union of the clauses in $\\Gamma$ and the clauses derived from $\\neg\\varphi$.\n\n**Step 2: Satisfiability Checking**\nTo check if a set of clauses is unsatisfiable, a complete decision procedure is required. The Davis-Putnam-Logemann-Loveland (DPLL) algorithm is such a procedure. DPLL is a recursive, backtracking-based search for a satisfying assignment. Its core components are:\n- **Unit Propagation:** If a clause is a unit clause (contains only one literal), that literal must be assigned a truth value that makes it true. This assignment may simplify other clauses, potentially creating new unit clauses. This process is repeated until no more unit clauses can be found. If an empty clause is generated (e.g., from a clause $[p]$ and another clause $[\\neg p]$), a contradiction is found, and the formula is unsatisfiable.\n- **Branching (Splitting Rule):** If unit propagation does not resolve the formula, an unassigned variable is chosen. The algorithm recursively calls itself twice: once with the variable assigned true, and once with it assigned false. If either branch finds a satisfying assignment, the formula is satisfiable. If both branches lead to contradictions, the formula is unsatisfiable.\n\n**Step 3: Unsatisfiable Core Extraction**\nThe compactness theorem guarantees the existence of a finite unsatisfiable subset $S$. The initial set $\\Sigma = \\Gamma \\cup \\{\\neg\\varphi\\}$ is itself a candidate, which is guaranteed to be unsatisfiable by the problem premise. The goal is to find an inclusion-minimal unsatisfiable core. The specified method is iterative deletion:\n1. Start with the full set of clauses $S = \\Sigma$.\n2. Iterate through each clause $C \\in S$.\n3. Temporarily remove $C$, forming a new set $S' = S \\setminus \\{C\\}$.\n4. Use the DPLL solver to check if $S'$ is satisfiable.\n5. If $S'$ is still unsatisfiable, it means clause $C$ was not essential for the contradiction. It can be permanently removed from the working set.\n6. If $S'$ is satisfiable, clause $C$ is essential for the contradiction and must be kept.\nAfter iterating through all clauses, the remaining set is a minimal unsatisfiable core. Note that the result may depend on the order of deletion, but any such core is valid.\n\n**Step 4: Witness Extraction**\nLet the minimal unsatisfiable core be $S_{core}$. This core consists of clauses originating from $\\Gamma$ and clauses originating from $\\neg\\varphi$. To isolate the witness set $\\Delta \\subseteq \\Gamma$, we perform a multiset difference: $\\Delta = S_{core} \\setminus \\text{clauses}(\\neg\\varphi)$. The resulting set $\\Delta$ contains only clauses from the original premises $\\Gamma$ and is the required finite witness for the entailment $\\Gamma \\models \\varphi$. To implement this correctly, one must track the origin of each clause throughout the core extraction process.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\"gamma\": [[1], [-1, 2]], \"phi_type\": \"literal\", \"phi\": 2},\n        {\"gamma\": [[1]], \"phi_type\": \"clause\", \"phi\": [1, 2]},\n        {\"gamma\": [[1], [2]], \"phi_type\": \"conjunction\", \"phi\": [1, 2]},\n        {\"gamma\": [], \"phi_type\": \"clause\", \"phi\": [1, -1]},\n    ]\n\n    results = []\n    for case in test_cases:\n        witness = find_witness(case[\"gamma\"], case[\"phi_type\"], case[\"phi\"])\n        results.append(witness)\n\n    # Serialize results to the specified string format\n    # str([[1],[-1,2]]) -> \"[[1], [-1, 2]]\", so we remove spaces.\n    results_str = [str(res).replace(\" \", \"\") for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\ndef find_witness(gamma, phi_type, phi):\n    \"\"\"\n    Constructs Sigma, extracts the unsatisfiable core, and returns the witness Delta.\n    \"\"\"\n    neg_phi_clauses = []\n    if phi_type == \"literal\":\n        neg_phi_clauses.append([-phi])\n    elif phi_type == \"clause\":\n        for literal in phi:\n            neg_phi_clauses.append([-literal])\n    elif phi_type == \"conjunction\":\n        neg_phi_clauses.append([-literal for literal in phi])\n    \n    # Label clauses by origin to extract Delta later\n    gamma_labeled = [(tuple(sorted(c)), 'gamma') for c in gamma]\n    neg_phi_labeled = [(tuple(sorted(c)), 'neg_phi') for c in neg_phi_clauses]\n    \n    sigma_labeled = gamma_labeled + neg_phi_labeled\n\n    # The problem guarantees Sigma is unsatisfiable.\n    unsat_core_labeled = extract_unsat_core_iterative(sigma_labeled)\n\n    # Witness Delta is the set of clauses from the core that originated from Gamma.\n    # Convert back from sorted tuples to original lists by finding them in input Gamma.\n    # Since Gamma might have duplicate clauses, we handle it as a multiset.\n    gamma_copy = list(gamma)\n    delta = []\n    \n    core_gamma_tuples = [c_tuple for c_tuple, origin in unsat_core_labeled if origin == 'gamma']\n    \n    # To reconstruct the original unsorted clauses from gamma\n    gamma_tuples = [tuple(sorted(c)) for c in gamma_copy]\n    \n    # This reconstruction handles multisets properly.\n    for core_tuple in core_gamma_tuples:\n        for i, gamma_tuple in enumerate(gamma_tuples):\n            if core_tuple == gamma_tuple:\n                delta.append(gamma_copy.pop(i))\n                gamma_tuples.pop(i)\n                break\n                \n    return delta\n\ndef extract_unsat_core_iterative(sigma_labeled):\n    \"\"\"\n    Extracts an inclusion-minimal unsatisfiable core by iterative clause deletion.\n    \"\"\"\n    unsat_core = list(sigma_labeled)\n    i = 0\n    while i  len(unsat_core):\n        # Create a candidate core by removing the i-th clause\n        candidate_core = unsat_core[:i] + unsat_core[i+1:]\n        \n        # is_sat_labeled expects list of tuples (clause_tuple, origin)\n        if not is_sat_labeled(candidate_core):\n            # If still unsatisfiable, the clause was redundant.\n            # The removal is permanent. Update the core.\n            unsat_core = candidate_core\n            # Do not increment i, as the list has shrunk and the new\n            # element at index i must be checked.\n        else:\n            # If it becomes satisfiable, the clause is essential.\n            # Keep it and move to the next one.\n            i += 1\n    return unsat_core\n\n\ndef is_sat_labeled(labeled_clauses):\n    \"\"\"\n    Wrapper for DPLL that takes labeled clauses.\n    \"\"\"\n    if not labeled_clauses:\n        return True\n    clauses = [list(c_tuple) for c_tuple, _ in labeled_clauses]\n    return is_sat(clauses)\n\ndef is_sat(clauses):\n    \"\"\"\n    Top-level DPLL SAT solver function.\n    \"\"\"\n    return dpll(clauses, set())\n\ndef dpll(clauses, assignment):\n    \"\"\"\n    Recursive DPLL algorithm implementation.\n    'assignment' is a set of literals assumed to be true.\n    \"\"\"\n    # 1. Simplify clauses based on the current assignment\n    simplified_clauses = []\n    \n    for c in clauses:\n        new_clause = []\n        is_clause_satisfied = False\n        for literal in c:\n            if literal in assignment:\n                is_clause_satisfied = True\n                break\n            if -literal not in assignment:\n                new_clause.append(literal)\n        \n        if not is_clause_satisfied:\n            if not new_clause:\n                # Contradiction: an empty clause was generated\n                return False\n            simplified_clauses.append(new_clause)\n\n    if not simplified_clauses:\n        # All clauses were satisfied\n        return True\n\n    # 2. Iterative Unit Propagation\n    unit_literals = {c[0] for c in simplified_clauses if len(c) == 1}\n    if unit_literals:\n        # If a literal and its negation are both units, it's a contradiction.\n        if any(-l in unit_literals for l in unit_literals):\n            return False\n        \n        new_assignment = assignment.union(unit_literals)\n        # Recurse with the new assignment due to unit propagation\n        if len(new_assignment) > len(assignment): # New information was added\n            return dpll(simplified_clauses, new_assignment)\n\n    # 3. Branching (Splitting)\n    # Find an unassigned variable to branch on.\n    remaining_vars = set()\n    for c in simplified_clauses:\n        for literal in c:\n            remaining_vars.add(abs(literal))\n            \n    if not remaining_vars:\n        # This state is unexpected if clauses are not empty.\n        # It would mean non-empty clauses with no variables.\n        # However, if all variables are assigned and clauses are not all satisfied, it's unsat.\n        return False\n        \n    # Pick a variable to branch on\n    var_to_branch = remaining_vars.pop()\n\n    # Try assigning the variable to be true\n    if dpll(simplified_clauses, assignment.union({var_to_branch})):\n        return True\n    \n    # If that fails, try assigning it to be false\n    return dpll(simplified_clauses, assignment.union({-var_to_branch}))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2970291"}]}