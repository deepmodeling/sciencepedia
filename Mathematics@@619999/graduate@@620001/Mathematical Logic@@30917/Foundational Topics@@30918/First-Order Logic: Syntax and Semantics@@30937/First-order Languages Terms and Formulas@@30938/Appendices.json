{"hands_on_practices": [{"introduction": "In first-order logic, terms are the foundational expressions that refer to objects, much like nouns in a natural language. Before we can assign them meaning, we must ensure they are constructed according to the strict grammatical rules of the language. This practice [@problem_id:2972885] challenges you to act as a parser, applying the recursive formation rules to identify strings that fail to be valid terms due to a common but subtle error: an arity mismatch.", "problem": "Consider the abstract syntax formation rules for terms in first-order logic over a signature $L$. A signature $L$ consists of a finite set of function symbols (each with a specified nonnegative integer arity, where $0$-ary function symbols are constants) and a finite set of predicate symbols (each with a specified positive integer arity). Let the set of variables be countably infinite, e.g., $\\{x,y,z,u,v,w,\\dots\\}$. The formation rules for terms are as follows: (i) every variable is a term; (ii) every constant symbol is a term; (iii) if $f$ is an $n$-ary function symbol in $L$ and $t_1,\\dots,t_n$ are terms, then $f(t_1,\\dots,t_n)$ is a term; and (iv) nothing else is a term. Predicate symbols and logical connectives form formulas and are not allowed to appear inside terms.\n\nSelect the option that specifies a finite signature $L$ and exhibits a concrete string built from the symbols of $L$ which fails to be an $L$-term solely because of an arity mismatch at a function application, with no other violations of the formation rules (that is, the string uses only symbols from $L$, does not insert any predicate application or logical connective in place of a term, and uses standard parentheses and commas for function application).\n\nA. $L$ has the unary function symbol $f$, the ternary function symbol $g$, the constant $c$, and the binary predicate symbol $R$. The string is $f(g(x,y),c)$.\n\nB. $L$ has the unary function symbol $f$, the binary function symbol $g$, the constant $c$, and the unary predicate symbol $R$. The string is $f(g(x,R(x)))$.\n\nC. $L$ has the unary function symbol $f$, the binary function symbol $g$, and the constant $c$. The string is $f(g(x,y,z))$.\n\nD. $L$ has the function symbols $f_n$ for every $n \\in \\mathbb{N}$, where $f_n$ is $n$-ary, and the constant $c$. The string is $f_2(x,y,z)$.\n\nE. $L$ has the binary predicate symbol $p$ and the constant $c$. The string is $p(c,c)$.", "solution": "The problem statement is first validated for correctness and solvability.\n\n### Step 1: Extract Givens\nThe problem provides the following definitions and conditions for terms in a first-order language over a signature $L$:\n-   A signature $L$ consists of a finite set of function symbols and a finite set of predicate symbols.\n-   Each function symbol has a specified non-negative integer arity. $0$-ary function symbols are constants.\n-   Each predicate symbol has a specified positive integer arity.\n-   The set of variables is countably infinite, e.g., $\\{x,y,z,u,v,w,\\dots\\}$.\n-   The formation rules for terms are:\n    1.  Every variable is a term.\n    2.  Every constant symbol is a term.\n    3.  If $f$ is an $n$-ary function symbol in $L$ and $t_1,\\dots,t_n$ are terms, then $f(t_1,\\dots,t_n)$ is a term.\n    4.  Nothing else is a term.\n-   A constraint is given: Predicate symbols and logical connectives form formulas and are not allowed to appear inside terms.\n-   The task is to select the option that specifies a finite signature $L$ and exhibits a string that fails to be an $L$-term *solely* because of an arity mismatch at a function application, with no other violations.\n-   Other specified conditions for the failure are that the string uses only symbols from $L$ and variables, does not use predicate applications or connectives in place of terms, and uses standard syntax for function application.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is well-defined within the standard framework of mathematical logic, specifically the syntax of first-order languages.\n-   **Scientifically Grounded**: The definitions for signature, term, arity, and formation rules are standard and fundamental to first-order logic. The problem is scientifically sound.\n-   **Well-Posed**: The question is precise. It asks to identify a specific type of syntactic error—an arity mismatch—as the sole reason for an expression's failure to be a term, under a given signature. The criteria are clear, implying a unique correct option should exist.\n-   **Objective**: The problem is stated in formal, objective language without ambiguity or subjective elements.\n-   **Completeness and Consistency**: The rules for term formation are provided, and the nature of the required error is specified in detail. The problem is self-contained. One option (D) proposes an infinite signature, which contradicts the problem's global definition of $L$ as having a \"finite set of function symbols\". However, the question asks to \"Select the option that specifies a **finite signature** $L$\". This makes option D an invalid choice according to the question's own criteria, but it does not invalidate the problem statement itself. The problem remains a valid exercise in applying the given definitions.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is a standard exercise in applying the syntactic rules of first-order logic. The solution process may proceed.\n\n### Solution Derivation\nThe task is to identify an option where a string fails to be a term due to one and only one reason: a single arity mismatch at a function application. All other syntactic rules must be respected up to the point of that specific error. We will analyze each option based on the recursive definition of a term.\n\nA term is either a variable, a constant, or an application of an $n$-ary function symbol $f$ to $n$ other, already-formed terms $t_1, \\dots, t_n$. An arity mismatch occurs when an $n$-ary function symbol is applied to $k \\neq n$ arguments. The error is \"sole\" if the arguments themselves are well-formed terms and no other rules are broken (e.g., using a predicate where a term is required).\n\n**Option A. $L$ has the unary function symbol $f$, the ternary function symbol $g$, the constant $c$, and the binary predicate symbol $R$. The string is $f(g(x,y),c)$.**\n\nLet's parse the string $f(g(x,y),c)$.\n1.  The outermost part is an application of the function symbol $f$. $f$ is defined as a unary function, meaning it takes exactly $1$ argument. The string provides $2$ arguments: $g(x,y)$ and $c$. This is an arity mismatch.\n2.  Let's inspect the first argument, $g(x,y)$. The symbol $g$ is a ternary function, meaning it takes $3$ arguments. It is given $2$ arguments, $x$ and $y$ (which are valid terms, being variables). This is also an arity mismatch.\nThe string thus contains two distinct arity mismatches. The failure to be a term is not due to \"an arity mismatch\" (singular), but at least two. Therefore, this option does not meet the \"solely because of an arity mismatch\" criterion in the sense of a single point of failure.\n\nVerdict for Option A: **Incorrect**.\n\n**Option B. $L$ has the unary function symbol $f$, the binary function symbol $g$, the constant $c$, and the unary predicate symbol $R$. The string is $f(g(x,R(x)))$.**\n\nLet's parse the string $f(g(x,R(x)))$.\n1.  The innermost part is $R(x)$. The symbol $R$ is a unary predicate symbol. Its application to a term (the variable $x$) results in an atomic formula, not a term.\n2.  The formation rules explicitly state that terms are only variables, constants, or function applications. The problem further clarifies that \"Predicate symbols ... are not allowed to appear inside terms\".\n3.  The expression $g(x,R(x))$ attempts to use the formula $R(x)$ as the second argument to the function $g$. This violates the definition of a term (rule (iii)), which requires all arguments to a function to be terms themselves.\nThe failure of the string to be a term is due to the illegal use of a predicate application in a position where a term is required. This is a different kind of syntactic violation from an arity mismatch.\n\nVerdict for Option B: **Incorrect**.\n\n**Option C. $L$ has the unary function symbol $f$, the binary function symbol $g$, and the constant $c$. The string is $f(g(x,y,z))$.**\n\nLet's parse the string $f(g(x,y,z))$.\n1.  The outermost part is an application of the function symbol $f$. $f$ is unary, and it is given exactly $1$ argument, which is the expression $g(x,y,z)$. The arity at the application of $f$ is correct ($1$ argument for a unary function).\n2.  For $f(g(x,y,z))$ to be a term, its argument, $g(x,y,z)$, must be a term.\n3.  Let's analyze $g(x,y,z)$. The function symbol $g$ is binary, meaning it requires $2$ arguments. Here, it is applied to $3$ arguments: $x$, $y$, and $z$.\n4.  The arguments $x$, $y$, and $z$ are all variables, which are valid terms. No predicate symbols are used. The syntax is otherwise standard.\n5.  The application of $g$ to $3$ arguments is an arity mismatch. Because of this, $g(x,y,z)$ is not a well-formed term.\n6.  Since $g(x,y,z)$ is not a term, the full expression $f(g(x,y,z))$ is also not a term. The fundamental error that prevents the string from being a term is the single arity mismatch in the application of $g$. All other aspects of the string-building process are correct up to that point. This fits the problem's description perfectly.\n\nVerdict for Option C: **Correct**.\n\n**Option D. $L$ has the function symbols $f_n$ for every $n \\in \\mathbb{N}$, where $f_n$ is $n$-ary, and the constant $c$. The string is $f_2(x,y,z)$.**\n\nThe problem statement establishes a global condition that \"A signature $L$ consists of a **finite** set of function symbols...\". The signature proposed in this option contains the set of function symbols $\\{f_n | n \\in \\mathbb{N}\\}$, which is a countably infinite set. Therefore, this option specifies a signature that is not finite, violating a premise of the question. The question asks to select an option that \"specifies a finite signature $L$\". This option fails to do so.\n\nEven if we were to disregard this violation, the string $f_2(x,y,z)$ applies a binary function symbol $f_2$ to $3$ arguments, which is an arity mismatch. This part of the option would be correct, but the initial premise about the signature is flawed.\n\nVerdict for Option D: **Incorrect**.\n\n**Option E. $L$ has the binary predicate symbol $p$ and the constant $c$. The string is $p(c,c)$.**\n\nLet's analyze the string $p(c,c)$.\n1.  The symbol $p$ is a binary predicate symbol.\n2.  The symbol $c$ is a constant, and therefore a valid term.\n3.  The string $p(c,c)$ is an application of a binary predicate symbol to $2$ terms. This is the definition of a well-formed atomic formula.\n4.  The question asks for a string that *fails to be a term*. The string $p(c,c)$ is a formula, not a term. So it does fail to be a term.\n5.  However, the reason for this failure must be \"solely because of an arity mismatch at a function application\". The symbol $p$ is a predicate, not a function. There is no function application, and therefore no arity mismatch at a function application. The string is not a term because it is a formula. This is a categorical difference, not a malformation of a term.\n\nVerdict for Option E: **Incorrect**.\n\n**Conclusion**\nOnly option C provides a finite signature and a string that is malformed as a term due to a single, localized arity mismatch at a function application, with no other syntactic errors.", "answer": "$$\\boxed{C}$$", "id": "2972885"}, {"introduction": "A syntactically correct term is merely a string of symbols until we assign it a concrete meaning within a mathematical structure, or 'model'. This exercise [@problem_id:2972859] makes the abstract concrete by guiding you through the recursive evaluation of a complex term within a specified finite structure, a process central to model theory. By computing the term's value step-by-step, you gain hands-on experience with the fundamental link between the syntax of a language and its semantics.", "problem": "Let $\\mathcal{L}$ be a first-order language with one constant symbol $c$, one unary function symbol $f$, one binary function symbol $g$, and one ternary function symbol $h$. Consider the finite $\\mathcal{L}$-structure $\\mathcal{M}$ whose domain is $M = \\{0,1,2,3,4,5,6\\}$, with all arithmetic performed modulo $7$, and with symbols interpreted as follows:\n- $c^{\\mathcal{M}} = 5$,\n- $f^{\\mathcal{M}}(u) = 3u^{2} + 1$ (computed modulo $7$),\n- $g^{\\mathcal{M}}(u,v) = 2u + 4v + 3$ (computed modulo $7$),\n- $h^{\\mathcal{M}}(u,v,w) = u \\cdot v - 2w$ (computed modulo $7$).\n\nLet $\\alpha$ be a variable assignment with $\\alpha(x) = 3$ and $\\alpha(y) = 6$. Consider the $\\mathcal{L}$-term\n$$t := h\\big(f(g(x, f(c))),\\ g(f(x), h(c, x, y)),\\ f(f(y))\\big).$$\n\nUsing only the foundational recursive clauses for the interpretation of terms in first-order logic (FOL)—namely, the clauses for constant symbols, variables, and function applications—compute the value of $\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha} \\in M$ and verify each clause step by step in your derivation. Express the final answer as an exact element of $M$. No rounding is required, and no units are involved.", "solution": "The problem statement is a well-posed exercise in mathematical logic, specifically within the domain of model theory. It provides a first-order language $\\mathcal{L}$, a finite $\\mathcal{L}$-structure $\\mathcal{M}$ with a clearly defined domain and interpretations for all non-logical symbols, a well-formed $\\mathcal{L}$-term $t$, and a variable assignment $\\alpha$ that covers all free variables in $t$. The task is to compute the interpretation of the term $t$ in the structure $\\mathcal{M}$ with respect to the assignment $\\alpha$, denoted $\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha}$. All components are formally defined and self-consistent. The problem is scientifically grounded, objective, and contains sufficient information for a unique solution. Therefore, the problem is valid.\n\nThe interpretation of a term $\\tau$ in a structure $\\mathcal{M}$ under a variable assignment $\\alpha$, denoted $\\llbracket \\tau \\rrbracket^{\\mathcal{M},\\alpha}$, is defined recursively by the following foundational clauses of first-order logic:\n$1$. If $\\tau$ is a variable $v$, then $\\llbracket v \\rrbracket^{\\mathcal{M},\\alpha} = \\alpha(v)$.\n$2$. If $\\tau$ is a constant symbol $c$, then $\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha} = c^{\\mathcal{M}}$.\n$3$. If $\\tau$ is a term of the form $F(t_1, ..., t_n)$, where $F$ is an $n$-ary function symbol and $t_1, ..., t_n$ are terms, then $\\llbracket F(t_1, ..., t_n) \\rrbracket^{\\mathcal{M},\\alpha} = F^{\\mathcal{M}}(\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}, ..., \\llbracket t_n \\rrbracket^{\\mathcal{M},\\alpha})$.\n\nWe are asked to compute the value of the term\n$$t := h\\big(f(g(x, f(c))),\\ g(f(x), h(c, x, y)),\\ f(f(y))\\big)$$\nin the structure $\\mathcal{M}$ with domain $M = \\{0,1,2,3,4,5,6\\}$ and assignment $\\alpha(x) = 3$, $\\alpha(y) = 6$. We will proceed by recursively evaluating the sub-terms of $t$ from the innermost parts outward. All arithmetic will be performed modulo $7$.\n\nLet the three main arguments of the outermost function $h$ be denoted as:\n- $t_1 := f(g(x, f(c)))$\n- $t_2 := g(f(x), h(c, x, y))$\n- $t_3 := f(f(y))$\n\nOur goal is to compute $\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha} = h^{\\mathcal{M}}(\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha})$.\n\n**Step 1: Evaluation of $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}$**\nTo find $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha} = \\llbracket f(g(x, f(c))) \\rrbracket^{\\mathcal{M},\\alpha}$, we must first evaluate its argument, $\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha}$. This in turn requires the evaluation of $\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha}$ and $\\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha}$.\n\n- Evaluation of $\\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha}$:\n    - By clause $2$, the interpretation of the constant symbol $c$ is $\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha} = c^{\\mathcal{M}} = 5$.\n    - By clause $3$, $\\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(5)$.\n    - Using the definition $f^{\\mathcal{M}}(u) = 3u^2 + 1$, we compute:\n    $$f^{\\mathcal{M}}(5) = 3 \\cdot 5^2 + 1 = 3 \\cdot 25 + 1 \\pmod{7}$$\n    - Since $25 \\equiv 4 \\pmod{7}$, we have:\n    $$3 \\cdot 4 + 1 = 12 + 1 = 13 \\equiv 6 \\pmod{7}$$\n    - Thus, $\\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha} = 6$.\n\n- Evaluation of $\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha}$:\n    - By clause $1$, the interpretation of the variable $x$ is $\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha} = \\alpha(x) = 3$.\n    - By clause $3$, using the results above:\n    $$\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha} = g^{\\mathcal{M}}(\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket f(c) \\rrbracket^{\\mathcal{M},\\alpha}) = g^{\\mathcal{M}}(3, 6)$$\n    - Using the definition $g^{\\mathcal{M}}(u,v) = 2u + 4v + 3$, we compute:\n    $$g^{\\mathcal{M}}(3, 6) = 2 \\cdot 3 + 4 \\cdot 6 + 3 = 6 + 24 + 3 = 33 \\pmod{7}$$\n    - Since $33 = 4 \\cdot 7 + 5$, we have $33 \\equiv 5 \\pmod{7}$.\n    - Thus, $\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha} = 5$.\n\n- Final evaluation of $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}$:\n    - By clause $3$, $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket g(x, f(c)) \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(5)$.\n    - We have already computed $f^{\\mathcal{M}}(5) = 6$.\n    - Therefore, $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha} = 6$.\n\n**Step 2: Evaluation of $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha}$**\nTo find $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha} = \\llbracket g(f(x), h(c, x, y)) \\rrbracket^{\\mathcal{M},\\alpha}$, we must evaluate its arguments $\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha}$ and $\\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha}$.\n\n- Evaluation of $\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha}$:\n    - We have $\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha} = 3$.\n    - By clause $3$, $\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(3)$.\n    - Computation: $f^{\\mathcal{M}}(3) = 3 \\cdot 3^2 + 1 = 3 \\cdot 9 + 1 = 27 + 1 = 28 \\pmod{7}$.\n    - Since $28 = 4 \\cdot 7 + 0$, we have $28 \\equiv 0 \\pmod{7}$.\n    - Thus, $\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha} = 0$.\n\n- Evaluation of $\\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha}$:\n    - We have $\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha} = 5$, $\\llbracket x \\rrbracket^{\\mathcal{M},\\alpha} = 3$, and $\\llbracket y \\rrbracket^{\\mathcal{M},\\alpha} = \\alpha(y) = 6$.\n    - By clause $3$: $\\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha} = h^{\\mathcal{M}}(\\llbracket c \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket x \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket y \\rrbracket^{\\mathcal{M},\\alpha}) = h^{\\mathcal{M}}(5, 3, 6)$.\n    - Using the definition $h^{\\mathcal{M}}(u,v,w) = u \\cdot v - 2w$, we compute:\n    $$h^{\\mathcal{M}}(5, 3, 6) = 5 \\cdot 3 - 2 \\cdot 6 = 15 - 12 = 3 \\pmod{7}$$\n    - Thus, $\\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha} = 3$.\n\n- Final evaluation of $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha}$:\n    - By clause $3$, $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha} = g^{\\mathcal{M}}(\\llbracket f(x) \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket h(c, x, y) \\rrbracket^{\\mathcal{M},\\alpha}) = g^{\\mathcal{M}}(0, 3)$.\n    - Computation: $g^{\\mathcal{M}}(0, 3) = 2 \\cdot 0 + 4 \\cdot 3 + 3 = 0 + 12 + 3 = 15 \\pmod{7}$.\n    - Since $15 = 2 \\cdot 7 + 1$, we have $15 \\equiv 1 \\pmod{7}$.\n    - Therefore, $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha} = 1$.\n\n**Step 3: Evaluation of $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha}$**\nTo find $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha} = \\llbracket f(f(y)) \\rrbracket^{\\mathcal{M},\\alpha}$, we first evaluate the inner term $\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha}$.\n\n- Evaluation of $\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha}$:\n    - We have $\\llbracket y \\rrbracket^{\\mathcal{M},\\alpha} = 6$.\n    - By clause $3$, $\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket y \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(6)$.\n    - Computation: $f^{\\mathcal{M}}(6) = 3 \\cdot 6^2 + 1 \\pmod{7}$.\n    - Since $6 \\equiv -1 \\pmod{7}$, we have $6^2 \\equiv (-1)^2 = 1 \\pmod{7}$.\n    - $f^{\\mathcal{M}}(6) = 3 \\cdot 1 + 1 = 4 \\pmod{7}$.\n    - Thus, $\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha} = 4$.\n\n- Final evaluation of $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha}$:\n    - By clause $3$, $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha} = f^{\\mathcal{M}}(\\llbracket f(y) \\rrbracket^{\\mathcal{M},\\alpha}) = f^{\\mathcal{M}}(4)$.\n    - Computation: $f^{\\mathcal{M}}(4) = 3 \\cdot 4^2 + 1 = 3 \\cdot 16 + 1 \\pmod{7}$.\n    - Since $16 \\equiv 2 \\pmod{7}$, we have:\n    $$f^{\\mathcal{M}}(4) = 3 \\cdot 2 + 1 = 6 + 1 = 7 \\equiv 0 \\pmod{7}$$\n    - Therefore, $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha} = 0$.\n\n**Step 4: Final Computation of $\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha}$**\nWe now have the interpretations of the three arguments of the main term $t$:\n- $\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha} = 6$\n- $\\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha} = 1$\n- $\\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha} = 0$\n\nUsing clause $3$ one last time for the full term $t$:\n$$\\llbracket t \\rrbracket^{\\mathcal{M},\\alpha} = h^{\\mathcal{M}}(\\llbracket t_1 \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket t_2 \\rrbracket^{\\mathcal{M},\\alpha}, \\llbracket t_3 \\rrbracket^{\\mathcal{M},\\alpha}) = h^{\\mathcal{M}}(6, 1, 0)$$\n- Computation using $h^{\\mathcal{M}}(u,v,w) = u \\cdot v - 2w$:\n$$h^{\\mathcal{M}}(6, 1, 0) = 6 \\cdot 1 - 2 \\cdot 0 = 6 - 0 = 6 \\pmod{7}$$\n\nThe value of the term $t$ in the structure $\\mathcal{M}$ under the assignment $\\alpha$ is $6$.", "answer": "$$\\boxed{6}$$", "id": "2972859"}, {"introduction": "As we advance from terms to formulas, quantifiers like $\\forall$ and $\\exists$ introduce new syntactic challenges. The seemingly simple act of substituting a term for a variable becomes fraught with peril, potentially leading to a critical error known as 'variable capture' that alters the formula's meaning. This practice [@problem_id:2972882] provides a crucial workout in navigating this pitfall, requiring you to apply the rigorous procedure of capture-avoiding substitution by systematically renaming bound variables.", "problem": "Consider first-order logic (FOL) over a language $\\mathcal{L}$ that has a binary predicate symbol $R$, a unary predicate symbol $P$, variables $x$, $y$, $z$, $w$, and the usual logical connectives and quantifiers. Use only the core definitions of free and bound variables, syntactic substitution, and renaming of bound variables (also called $\\alpha$-conversion). Let\n$$\n\\varphi(x) \\;=\\; \\forall y \\,\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big).\n$$\nWe intend to substitute the term $y$ for the free variable $x$ in $\\varphi$, written $\\varphi[x := y]$. According to the definition of capture-avoiding substitution, whenever a substitution would place a free variable of the substituting term under a quantifier binding that same variable name, a systematic renaming of the bound variable must first be performed to a variable that is fresh with respect to the substituting term.\n\nWhich of the following candidate formulas are correct results of the capture-avoiding substitution of $y$ for $x$ in $\\varphi(x)$, up to $\\alpha$-equivalence? Select all that apply. The incorrect choices are plausible but fail due to variable capture or incorrect renaming.\n\nA. $\\forall y \\,\\Big( R(y,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,y) \\big) \\Big)$\n\nB. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,y) \\big) \\Big)$\n\nC. $\\forall y \\,\\Big( R(y,y) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$\n\nD. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$\n\nE. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big) \\Big)$\n\nYour reasoning should start from the formal definitions: a variable occurrence is bound if it lies in the scope of a quantifier that binds it; otherwise it is free. The set of free variables $FV(\\psi)$ of a formula $\\psi$ is defined inductively on formulas. Substitution $\\psi[x := t]$ is defined inductively on the structure of $\\psi$, with the proviso that, before substituting $t$ into the scope of a quantifier that binds a variable occurring free in $t$, the bound variable is renamed to a variable that does not occur free in $t$ (and is fresh relative to the context) to prevent variable capture. Do not use any ad hoc shortcuts; justify each conclusion directly from these definitions.", "solution": "The user wants to find the correct result of a capture-avoiding substitution in first-order logic.\n\n### Step 1: Extract Givens\n-   **Language $\\mathcal{L}$**: Contains a binary predicate symbol $R$, a unary predicate symbol $P$, and variables $x$, $y$, $z$, $w$.\n-   **Formula $\\varphi(x)$**: Defined as $\\varphi(x) \\;=\\; \\forall y \\,\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)$.\n-   **Task**: Perform the capture-avoiding substitution of the term $y$ for the free variable $x$ in $\\varphi(x)$, denoted as $\\varphi(x)[x := y]$.\n-   **Core Definitions**: The reasoning must be based on the formal definitions of free and bound variables, syntactic substitution, and $\\alpha$-conversion (renaming of bound variables). The rule for capture avoidance is explicitly stated: \"whenever a substitution would place a free variable of the substituting term under a quantifier binding that same variable name, a systematic renaming of the bound variable must first be performed to a variable that is fresh with respect to the substituting term.\"\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientific Groundedness**: The problem is a standard exercise in mathematical logic, specifically first-order predicate logic. The concepts of free/bound variables, substitution, and variable capture are fundamental to the syntax and semantics of FOL. The problem is scientifically sound.\n-   **Well-Posedness**: The formula $\\varphi(x)$ is syntactically well-formed, even with the nested quantifiers binding the same variable name $y$. In formal logic, the scope of the inner quantifier $\\exists y$ is nested within the scope of the outer quantifier $\\forall y$, and the binding is resolved to the innermost applicable quantifier. The task is to perform a specific, well-defined operation ($\\varphi(x)[x := y]$) according to specified rules. A unique result, up to $\\alpha$-equivalence, exists. The problem is well-posed.\n-   **Objectivity**: The problem is stated in the formal language of logic and mathematics, free from any subjective or ambiguous terminology.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is a well-posed, standard problem in an established formal system. I will proceed with the derivation and solution.\n\n### Derivation of the Correct Substitution\n\nThe task is to compute $\\varphi(x)[x := y]$, where the term being substituted is $t=y$ and the formula is:\n$$\n\\varphi(x) \\;=\\; \\forall y \\,\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)\n$$\n\nFirst, we identify the free variables of the formula $\\varphi(x)$ and the term $t=y$.\n-   In $\\varphi(x)$, the variable $x$ has two occurrences, both of which are free, as they are not within the scope of a quantifier binding $x$. All occurrences of the variable $y$ are bound by either the outer $\\forall y$ or the inner $\\exists y$. Thus, the set of free variables of $\\varphi(x)$ is $FV(\\varphi(x)) = \\{x\\}$.\n-   The term to be substituted is $t = y$. The set of free variables in this term is $FV(t) = \\{y\\}$.\n\nThe substitution $\\psi[v := t]$ is defined recursively. For a quantified formula of the form $\\forall u \\, \\chi$ or $\\exists u \\, \\chi$, the substitution $(\\forall u \\, \\chi)[v := t]$ will cause variable capture if $v \\neq u$ and $u \\in FV(t)$. In such a case, the bound variable $u$ must first be renamed to a fresh variable $u'$ that is not in $FV(\\chi) \\cup FV(t)$.\n\nWe will now perform the substitution $\\varphi(x)[x := y]$ step-by-step.\n\n1.  **Outer Quantifier $\\forall y$**: The formula is of the form $(\\forall y \\, \\psi)[x := y]$, where $\\psi$ is $\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)$. The variable being substituted is $x$, and the bound variable is $y$. The term is $t=y$. Since the bound variable $y$ is a free variable in the term $t=y$ (i.e., $y \\in FV(y)$), a direct substitution would cause the term's variable $y$ to be captured by the $\\forall y$ quantifier.\n    To avoid this capture, we must rename the bound variable $y$ in the outer quantifier to a fresh variable. The available variables are specified as $x, y, z, w$. A variable is fresh if it does not introduce new conflicts. Let's choose the variable $z$. The variable $z$ is not in $FV(\\varphi(x)) = \\{x\\}$ and not in $FV(y) = \\{y\\}$. So, we perform an $\\alpha$-conversion on $\\varphi(x)$, renaming the outer bound $y$ to $z$:\n    $$\n    \\varphi(x) \\equiv_\\alpha \\varphi'(x) = \\forall z \\,\\Big( \\big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\dots \\big)[y := z] \\Big)\n    $$\n    The substitution $[y := z]$ applies only to the free occurrences of $y$ in the scope of the outer $\\forall y$. In the subformula $\\Big( R(x,y) \\;\\rightarrow\\; \\exists y \\,\\dots \\Big)$, the $y$ in $R(x,y)$ is free, but the $y$'s in $\\exists y \\,\\dots$ are bound by the inner quantifier and are thus not affected. The result of the renaming is:\n    $$\n    \\varphi'(x) = \\forall z \\,\\Big( R(x,z) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)\n    $$\n\n2.  **Substitution into the Renamed Formula**: We now compute $\\varphi'(x)[x := y]$. Since the new bound variable $z$ is not in $FV(y) = \\{y\\}$, we can push the substitution inside the quantifier:\n    $$\n    \\varphi'(x)[x := y] = \\forall z \\,\\left( \\Big( R(x,z) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\Big)[x := y] \\right)\n    $$\n    The substitution distributes over the implication $\\rightarrow$:\n    $$\n    = \\forall z \\,\\left( R(x,z)[x := y] \\;\\rightarrow\\; \\Big(\\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big)\\Big)[x := y] \\right)\n    $$\n    The first part is straightforward: $R(x,z)[x := y] = R(y,z)$.\n\n3.  **Inner Quantifier $\\exists y$**: We now focus on the second part: $\\Big(\\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big)\\Big)[x := y]$. This is again a substitution into a quantified formula. The variable being substituted is $x$, the bound variable is $y$, and the term is $t=y$. Since the bound variable $y$ is in $FV(t) = \\{y\\}$, this is another case of variable capture.\n    To avoid capture, we must rename the inner bound variable $y$ to a variable that is fresh in this context. The context is the substitution $\\big(\\exists y \\, \\chi\\big)[x := y]$ where $\\chi = P(y) \\land R(y,x)$. A fresh variable must not be in $FV(\\chi) = \\{x\\}$ or $FV(t) = \\{y\\}$. So, the new variable cannot be $x$ or $y$. Let's choose the variable $w$ (which is available and satisfies this condition). We perform an $\\alpha$-conversion on the subformula:\n    $$\n    \\exists y \\,\\big( P(y) \\,\\land\\, R(y,x) \\big) \\equiv_\\alpha \\exists w \\,\\Big(\\big( P(y) \\,\\land\\, R(y,x) \\big)[y := w] \\Big) = \\exists w \\,\\big( P(w) \\,\\land\\, R(w,x) \\big)\n    $$\n    Now, we can safely perform the substitution $[x := y]$ on this renamed subformula:\n    $$\n    \\Big(\\exists w \\,\\big( P(w) \\,\\land\\, R(w,x) \\big)\\Big)[x := y] = \\exists w \\,\\Big(\\big( P(w) \\,\\land\\, R(w,x) \\big)[x := y]\\Big)\n    $$\n    This simplifies to:\n    $$\n    = \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big)\n    $$\n\n4.  **Final Assembly**: Combining the results from steps 2 and 3, we get the final formula:\n    $$\n    \\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)\n    $$\n    This formula corresponds to option D.\n\nThe problem asks for all correct results up to $\\alpha$-equivalence. Let's analyze if other choices of fresh variables lead to other options. When renaming the inner bound variable $y$, we chose $w$. What if we had chosen $z$? The variable $z$ is not in $FV(\\chi) \\cup FV(t) = \\{x, y\\}$, so it is also a valid choice for a fresh variable. Renaming the inner $y$ to $z$ yields $\\exists z \\big( P(z) \\land R(z,x) \\big)$. Substituting $[x:=y]$ then gives $\\exists z \\big( P(z) \\land R(z,y) \\big)$.\nPlacing this back into the main formula (from step 2) results in:\n$$\n\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big) \\Big)\n$$\nThis formula corresponds to option E. Although it is confusing to reuse the bound variable name $z$, it is syntactically valid and a correct result of the substitution procedure. The inner quantifier $\\exists z$ 'shadows' the outer $\\forall z$, so they bind different occurrences of $z$.\n\nFinally, we must check if options D and E are $\\alpha$-equivalent.\nLet $F_D = \\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$.\nLet $F_E = \\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big) \\Big)$.\nThe two formulas differ only in the name of the bound variable in the existential quantifier. The subformula $\\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big)$ in $F_E$ can be obtained from $\\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big)$ in $F_D$ by renaming the bound variable $w$ to $z$. This is a valid $\\alpha$-conversion because $z$ is not a free variable in the scope of the existential quantifier, $P(w) \\land R(w,y)$, whose only free variable is $y$. Therefore, $F_D \\equiv_\\alpha F_E$.\nSince both D and E are valid outcomes of the substitution procedure (depending on the choice of fresh variable names), and they are $\\alpha$-equivalent to each other, they are both correct answers.\n\n### Option-by-Option Analysis\n\n*   **A. $\\forall y \\,\\Big( R(y,y) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,y) \\big) \\Big)$**\n    This formula is the result of a naive substitution of $y$ for every free occurrence of $x$ without renaming any bound variables. The $y$ substituted for $x$ in $R(x,y)$ is captured by the outer $\\forall y$. The $y$ substituted for $x$ in $R(y,x)$ is captured by the inner $\\exists y$. This violates the definition of capture-avoiding substitution.\n    **Verdict: Incorrect.**\n\n*   **B. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists y \\,\\big( P(y) \\,\\land\\, R(y,y) \\big) \\Big)$**\n    This formula correctly renames the outer bound variable $y$ to $z$, avoiding capture in the first part of the implication, yielding $R(y,z)$. However, it fails to rename the inner bound variable $y$. The substitution of $y$ for $x$ in the subformula $\\exists y \\, (P(y) \\land R(y,x))$ naively produces $\\exists y \\, (P(y) \\land R(y,y))$, where the new $y$ is captured by the existential quantifier. This is an incorrect application of the substitution rule.\n    **Verdict: Incorrect.**\n\n*   **C. $\\forall y \\,\\Big( R(y,y) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$**\n    This formula correctly renames the inner bound variable $y$ to $w$ before substitution, leading to the correct consequent $\\exists w \\, (P(w) \\land R(w,y))$. However, it fails to rename the outer bound variable $y$. The substitution of $y$ for $x$ in $R(x,y)$ leads to $R(y,y)$, where the new $y$ is captured by the universal quantifier. This violates the substitution rule.\n    **Verdict: Incorrect.**\n\n*   **D. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists w \\,\\big( P(w) \\,\\land\\, R(w,y) \\big) \\Big)$**\n    This formula is the result of applying the capture-avoiding substitution correctly. The outer bound variable $y$ is renamed to $z$. The inner bound variable $y$ is renamed to $w$. Both renamings are necessary to prevent variable capture. As shown in the derivation, this is a correct result.\n    **Verdict: Correct.**\n\n*   **E. $\\forall z \\,\\Big( R(y,z) \\;\\rightarrow\\; \\exists z \\,\\big( P(z) \\,\\land\\, R(z,y) \\big) \\Big)$**\n    This formula is another possible result of applying the capture-avoiding substitution correctly. The outer bound variable $y$ is renamed to $z$. The inner bound variable $y$ is also renamed to $z$. This is a valid choice for a fresh variable in the local context of the inner substitution, as it is not one of the free variables $\\{x, y\\}$ involved. The resulting formula, while potentially confusing due to the nested quantifiers using the same variable name, is formally correct. Furthermore, it is $\\alpha$-equivalent to the formula in option D.\n    **Verdict: Correct.**", "answer": "$$\\boxed{DE}$$", "id": "2972882"}]}