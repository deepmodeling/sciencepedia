{"hands_on_practices": [{"introduction": "Before diving into the recursive machinery of Tarski's definition, it is crucial to understand its guiding principle: Convention T. This exercise [@problem_id:2983809] challenges you to apply this principle, which demands that any adequate definition of truth must entail, for every sentence $S$, a biconditional of the form \"`S` is true if and only if $p$\". Mastering this requires a sharp distinction between the object language (where $S$ is a string of symbols) and the metalanguage (where $p$ is a statement about the world), a cornerstone of modern logic.", "problem": "Fix a first-order language $L$ containing equality $=$, a constant symbol $0$, and a binary function symbol $+$. Let $\\mathcal{N}$ be the standard $L$-structure with domain $\\mathbb{N}$ that interprets $0$ as $0 \\in \\mathbb{N}$ and $+$ as ordinary addition on $\\mathbb{N}$. Consider the $L$-sentence $\\forall x\\, (x+0=x)$. Your task is to instantiate Convention T (Tarski’s schema for truth) for this sentence by selecting the correct metalanguage biconditional that carefully separates use from mention and renders, in the metalanguage, what the object-language sentence says about the structure $\\mathcal{N}$.\n\nWhich of the following is the correct instance of Convention T for the given sentence in the given structure?\n\nA. \"$\\forall x\\,(x+0=x)$ is true in $\\mathcal{N}$ if and only if $\\forall x\\,(x+0=x)$.\"\n\nB. \"‘$\\forall x\\,(x+0=x)$’ is true in $\\mathcal{N}$ if and only if for every $n \\in \\mathbb{N}$, $+^{\\mathcal{N}}(n,0^{\\mathcal{N}})=n$.\"\n\nC. \"‘$\\forall x\\,(x+0=x)$’ is true in $L$ if and only if for all $n \\in \\mathbb{N}$, $n+0=n$.\"\n\nD. \"‘$\\forall x\\,(x+0=x)$’ is true if and only if for all assignments $s$, $\\mathcal{N} \\models x+0=x$.\"\n\nE. \"‘$\\forall x\\,(x+0=x)$’ is true in $\\mathcal{N}$ if and only if $\\mathcal{N} \\models \\forall x\\,(x+0=x)$.\"", "solution": "The problem statement is a valid exercise in mathematical logic. It is well-posed, scientifically grounded in model theory, and all terms and conditions are specified with sufficient precision to determine a unique, correct answer.\n\nThe task is to correctly instantiate Alfred Tarski's Convention T for a given sentence in a specific structure. Convention T, also known as the material adequacy condition, demands that any satisfactory definition of truth for a language $L$ must allow for the derivation of a biconditional statement for every sentence $\\phi$ in $L$. This biconditional takes the form:\n$$ \\text{\"}\\phi\\text{\" is true if and only if } P $$\nwhere \"$\\phi$\" on the left-hand side is the *name* of the sentence (a mentioned expression) and $P$ on the right-hand side is the sentence itself *used* in the metalanguage, or rather, a *translation* of $\\phi$ into the metalanguage that describes the state of affairs asserted by $\\phi$. When truth is defined relative to a structure (model-theoretic truth), the schema becomes:\n$$ \\text{\"}\\phi\\text{\" is true in } \\mathcal{M} \\text{ if and only if } P_{\\mathcal{M}} $$\nwhere $\\mathcal{M}$ is the structure and $P_{\\mathcal{M}}$ is the metalanguage statement describing the condition that $\\phi$ asserts about the domain and interpretations of $\\mathcal{M}$.\n\nLet us apply this to the given problem.\nThe object language is $L$, containing symbols $=$, $0$, and $+$.\nThe sentence is $\\phi \\equiv \\forall x\\,(x+0=x)$.\nThe structure is $\\mathcal{N}$, with domain $\\mathbb{N}$, where the constant symbol $0$ is interpreted as the number $0 \\in \\mathbb{N}$ (denoted $0^{\\mathcal{N}}$) and the function symbol $+$ is interpreted as standard addition on $\\mathbb{N}$ (denoted $+^{\\mathcal{N}}$).\n\nThe left-hand side of the T-biconditional must be a statement predicating truth of the sentence $\\phi$ with respect to the structure $\\mathcal{N}$. This must correctly use quotation marks to *mention* the sentence. The proper form is:\n`‘$\\forall x\\,(x+0=x)$’ is true in $\\mathcal{N}$ ...`\n\nThe right-hand side must be the metalanguage translation of what $\\phi$ asserts about the structure $\\mathcal{N}$. We derive this by recursively applying the Tarskian definition of truth:\n1. The sentence is of the form $\\forall x \\, \\psi(x)$, where $\\psi(x)$ is the formula $x+0=x$. The truth definition for a universal quantifier states that $\\mathcal{N} \\models \\forall x \\, \\psi(x)$ if and only if for every element $d$ in the domain of $\\mathcal{N}$, the formula $\\psi(x)$ is satisfied when $x$ is assigned the value $d$. The domain of $\\mathcal{N}$ is $\\mathbb{N}$. So, this translates to: \"for every $n \\in \\mathbb{N}$, the condition corresponding to $x+0=x$ holds for $n$.\"\n\n2. Now we translate the atomic formula $x+0=x$ for an element $n \\in \\mathbb{N}$. The formula is an equality between two terms, $t_1 \\equiv x+0$ and $t_2 \\equiv x$. The formula is satisfied if the interpretations of these terms are equal.\n    - The interpretation of the term $t_1 \\equiv x+0$ involves applying the interpretation of the function symbol $+$, which is the function $+^{\\mathcal{N}}$, to the interpretations of the variable $x$ and the constant symbol $0$. For an element $n \\in \\mathbb{N}$, the variable $x$ evaluates to $n$, and the constant symbol $0$ evaluates to its interpretation $0^{\\mathcal{N}}$. Thus, the term $x+0$ evaluates to $+^{\\mathcal{N}}(n, 0^{\\mathcal{N}})$.\n    - The interpretation of the term $t_2 \\equiv x$ is simply the element $n$ assigned to the variable $x$.\n    - Therefore, the condition that $x+0=x$ holds for $n$ translates to the metalanguage equality: $+^{\\mathcal{N}}(n, 0^{\\mathcal{N}}) = n$.\n\n3. Combining these steps, the full metalanguage translation $P_{\\mathcal{N}}$ is: \"for every $n \\in \\mathbb{N}$, $+^{\\mathcal{N}}(n, 0^{\\mathcal{N}}) = n$.\"\n\nPutting both sides together, the correct T-biconditional is:\n`‘$\\forall x\\,(x+0=x)$’ is true in $\\mathcal{N}$ if and only if for every $n \\in \\mathbb{N}$, $+^{\\mathcal{N}}(n,0^{\\mathcal{N}})=n$.`\n\nNow we evaluate the given options.\n\n**A. \"$\\forall x\\,(x+0=x)$ is true in $\\mathcal{N}$ if and only if $\\forall x\\,(x+0=x)$.\"**\nThis option has a fatal use-mention confusion. The phrase `$\\forall x\\,(x+0=x)$` on the left is used as a subject, but it is not placed in quotes, failing to properly name the sentence. More fundamentally, the right-hand side simply repeats the object-language sentence. Convention T requires a translation into the metalanguage that describes the conditions on the model's domain, not a repetition of the object-language syntax. This biconditional is uninformative.\n**Verdict: Incorrect.**\n\n**B. \"‘$\\forall x\\,(x+0=x)$’ is true in $\\mathcal{N}$ if and only if for every $n \\in \\mathbb{N}$, $+^{\\mathcal{N}}(n,0^{\\mathcal{N}})=n$.\"**\nThis option perfectly matches our derivation.\n- The left side correctly mentions the sentence `‘$\\forall x\\,(x+0=x)$’` and predicates its truth in the structure $\\mathcal{N}$.\n- The right side provides a precise metalanguage translation of the sentence's meaning, describing a property of the elements in the domain $\\mathbb{N}$ and the interpretations of the symbols, $+^{\\mathcal{N}}$ and $0^{\\mathcal{N}}$. It correctly unpacks the universal quantifier and the interpretation of the terms.\n**Verdict: Correct.**\n\n**C. \"‘$\\forall x\\,(x+0=x)$’ is true in $L$ if and only if for all $n \\in \\mathbb{N}$, $n+0=n$.\"**\nThis option contains a critical error on the left side. Truth is not defined for a language $L$, but for a sentence *in a structure* (or interpretation) $\\mathcal{N}$ for that language. A sentence can be true in one structure and false in another. The phrase \"true in $L$\" is syntactically an error and conceptually meaningless in model theory. While the right side is a correct, though slightly less formal, metalanguage translation, the error on the left side invalidates the entire statement.\n**Verdict: Incorrect.**\n\n**D. \"‘$\\forall x\\,(x+0=x)$’ is true if and only if for all assignments $s$, $\\mathcal{N} \\models x+0=x$.\"**\nThis option is flawed for multiple reasons. First, the left side is incomplete, omitting \"in $\\mathcal{N}$\". Second, and more importantly, the right-hand side does not provide the required translation into a statement about the domain objects. Instead, it couches the condition in semantic terms by using the satisfaction relation `$\\models$`. This is circular. The statement `$\\mathcal{N} \\models \\forall x \\psi(x)$` is *defined* in terms of satisfaction for all assignments (or, more accurately, for all domain elements substituted for $x$). Convention T requires the elimination of semantic predicates like `$\\models$` from the right-hand side, replacing them with the actual conditions in the domain.\n**Verdict: Incorrect.**\n\n**E. \"‘$\\forall x\\,(x+0=x)$’ is true in $\\mathcal{N}$ if and only if $\\mathcal{N} \\models \\forall x\\,(x+0=x)$.\"**\nThis statement is a tautology. The English phrase \"`‘\\phi’` is true in $\\mathcal{N}$\" is simply the natural language reading of the formal notation `$\\mathcal{N} \\models \\phi$`. Thus, this option asserts that a statement is true if and only if it is true. This does not provide the required translation of the object-language sentence into a non-semantic assertion about the domain, and is therefore not a correct instantiation of Convention T.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{B}$$", "id": "2983809"}, {"introduction": "The elegance of Tarski's definition lies in its compositional structure, defining truth by recursion on the complexity of formulas. This practice [@problem_id:2983810] focuses on the essential ground floor of this construction: the evaluation of terms and the satisfaction of atomic formulas. By working through the mechanics of how function symbols, constants, and predicate symbols are interpreted, you will build a solid foundation for understanding how the entire semantic edifice is constructed piece by piece.", "problem": "Consider a first-order language $\\mathcal{L}$ with constant symbols, function symbols of various arities, and predicate symbols. Under Tarski’s semantics for First-Order Logic (FOL), a structure $\\mathcal{M}$ for $\\mathcal{L}$ consists of a nonempty domain $M$ together with an interpretation that assigns to each constant symbol $c$ an element $c^{\\mathcal{M}} \\in M$, to each $n$-ary function symbol $f$ a function $f^{\\mathcal{M}}: M^n \\to M$, and to each $n$-ary predicate symbol $P$ a relation $P^{\\mathcal{M}} \\subseteq M^n$. A variable assignment $s$ is a map from the set of variables to $M$. Term evaluation in $\\mathcal{M}$ under $s$ is defined by structural recursion on terms, and the satisfaction relation $\\mathcal{M}, s \\models \\varphi$ is defined compositionally from atomic formulas upward.\n\nWhich of the following statements are correct in standard Tarskian semantics? Select all that apply.\n\nA. In any structure $\\mathcal{M}$ for $\\mathcal{L}$, every $n$-ary function symbol $f$ is interpreted as a total function $f^{\\mathcal{M}}: M^n \\to M$.\n\nB. Given a variable assignment $s$, the term evaluation function $\\mathrm{val}^{\\mathcal{M}}_{s}$ is defined compositionally by $\\mathrm{val}^{\\mathcal{M}}_{s}(x) = s(x)$ for variables $x$, $\\mathrm{val}^{\\mathcal{M}}_{s}(c) = c^{\\mathcal{M}}$ for constant symbols $c$, and $\\mathrm{val}^{\\mathcal{M}}_{s}(f(t_1,\\dots,t_n)) = f^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\dots,\\mathrm{val}^{\\mathcal{M}}_{s}(t_n))$ for compound terms.\n\nC. For any binary function symbol $g$ and terms $t_1,t_2$, one has $\\mathrm{val}^{\\mathcal{M}}_{s}(g(t_1,t_2)) = g^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_2),\\mathrm{val}^{\\mathcal{M}}_{s}(t_1))$.\n\nD. In standard FOL semantics, term evaluation may be undefined if a function symbol is not explicitly assigned a table of values in $\\mathcal{M}$.\n\nE. For any substitution $\\sigma$ mapping variables to terms, define $s_{\\sigma}(x) = \\mathrm{val}^{\\mathcal{M}}_{s}(\\sigma(x))$; then for all terms $t$, one has $\\mathrm{val}^{\\mathcal{M}}_{s}(t[\\sigma]) = \\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(t)$.\n\nF. For any $n$-ary predicate symbol $P$ and terms $t_1,\\dots,t_n$, $\\mathcal{M}, s \\models P(t_1,\\dots,t_n)$ if and only if $(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\dots,\\mathrm{val}^{\\mathcal{M}}_{s}(t_n)) \\in P^{\\mathcal{M}}$.\n\nG. For equality, $\\mathcal{M}, s \\models t = u$ if and only if $t$ and $u$ are syntactically identical terms.\n\nH. For any unary function symbol $f$ and binary function symbol $g$, and terms $t_1,t_2$, the composition property holds: $\\mathrm{val}^{\\mathcal{M}}_{s}\\big(f(g(t_1,t_2))\\big) = f^{\\mathcal{M}}\\!\\big(g^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\mathrm{val}^{\\mathcal{M}}_{s}(t_2))\\big)$.\n\nI. The satisfiability of a set of ground atomic formulas depends only on the syntactic form of the terms involved and is independent of the particular interpretations $c^{\\mathcal{M}}$, $f^{\\mathcal{M}}$, and $P^{\\mathcal{M}}$.", "solution": "The problem statement provides a standard definition of the syntax and semantics for a first-order language $\\mathcal{L}$ according to Tarski's model-theoretic semantics. The definitions are mathematically sound, internally consistent, and complete for the purpose of evaluating the propositions that follow. The problem is therefore valid. We shall proceed to analyze each statement individually.\n\nThe definitions provided are:\n- A structure $\\mathcal{M}$ for a language $\\mathcal{L}$ comprises a non-empty domain $M$ and an interpretation function.\n- For a constant symbol $c$, its interpretation is an element $c^{\\mathcal{M}} \\in M$.\n- For an $n$-ary function symbol $f$, its interpretation is a function $f^{\\mathcal{M}}: M^n \\to M$.\n- For an $n$-ary predicate symbol $P$, its interpretation is a relation $P^{\\mathcal{M}} \\subseteq M^n$.\n- A variable assignment $s$ maps variables to elements of $M$.\n- The satisfaction relation $\\mathcal{M}, s \\models \\varphi$ is defined compositionally.\n\nWe will evaluate each option against these fundamental definitions.\n\n**A. In any structure $\\mathcal{M}$ for $\\mathcal{L}$, every $n$-ary function symbol $f$ is interpreted as a total function $f^{\\mathcal{M}}: M^n \\to M$.**\nThe problem states that an interpretation assigns to each $n$-ary function symbol $f$ a function $f^{\\mathcal{M}}: M^n \\to M$. In standard mathematical parlance, a function from a set $A$ to a set $B$, denoted $g: A \\to B$, is by definition a total function on its domain $A$. This means that for every element $a \\in A$, there exists a unique element $b \\in B$ such that $g(a) = b$. Partial functions, which might be undefined for some elements in their domain, would require a different notation, such as $g: A \\rightharpoonup B$, and a modified semantic framework. Since the problem specifies standard Tarskian semantics and uses the standard notation $f^{\\mathcal{M}}: M^n \\to M$, the interpretation of a function symbol must be a total function.\n**Verdict: Correct.**\n\n**B. Given a variable assignment $s$, the term evaluation function $\\mathrm{val}^{\\mathcal{M}}_{s}$ is defined compositionally by $\\mathrm{val}^{\\mathcal{M}}_{s}(x) = s(x)$ for variables $x$, $\\mathrm{val}^{\\mathcal{M}}_{s}(c) = c^{\\mathcal{M}}$ for constant symbols $c$, and $\\mathrm{val}^{\\mathcal{M}}_{s}(f(t_1,\\dots,t_n)) = f^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\dots,\\mathrm{val}^{\\mathcal{M}}_{s}(t_n))$ for compound terms.**\nThis statement presents the standard, structurally recursive definition of the value of a term in a structure $\\mathcal{M}$ under a variable assignment $s$.\n- **Base Case (Variables):** The value of a variable $x$ is given directly by the assignment, $\\mathrm{val}^{\\mathcal{M}}_{s}(x) = s(x)$.\n- **Base Case (Constants):** The value of a constant symbol $c$ is its interpretation in the structure, $\\mathrm{val}^{\\mathcal{M}}_{s}(c) = c^{\\mathcal{M}}$. (Note: A constant can be seen as a $0$-ary function).\n- **Recursive Step:** The value of a compound term $f(t_1,\\dots,t_n)$ is found by first recursively finding the values of the sub-terms $t_1, \\dots, t_n$ in the domain $M$, and then applying the interpretation of the function symbol, $f^{\\mathcal{M}}$, to this tuple of values.\nThe statement accurately describes this entire definition.\n**Verdict: Correct.**\n\n**C. For any binary function symbol $g$ and terms $t_1,t_2$, one has $\\mathrm{val}^{\\mathcal{M}}_{s}(g(t_1,t_2)) = g^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_2),\\mathrm{val}^{\\mathcal{M}}_{s}(t_1))$.**\nFrom the correct definition in B, we have $\\mathrm{val}^{\\mathcal{M}}_{s}(g(t_1,t_2)) = g^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\mathrm{val}^{\\mathcal{M}}_{s}(t_2))$. The statement in option C swaps the arguments in the application of $g^{\\mathcal{M}}$, asserting that $g^{\\mathcal{M}}(v_1, v_2) = g^{\\mathcal{M}}(v_2, v_1)$ where $v_1 = \\mathrm{val}^{\\mathcal{M}}_{s}(t_1)$ and $v_2 = \\mathrm{val}^{\\mathcal{M}}_{s}(t_2)$. This is the property of commutativity. However, there is no general requirement in first-order logic for the interpretation of a function symbol to be commutative. For instance, in the structure of natural numbers $\\mathbb{N}$, the function symbol for subtraction would be interpreted as the non-commutative subtraction operation. Thus, this statement is false in general.\n**Verdict: Incorrect.**\n\n**D. In standard FOL semantics, term evaluation may be undefined if a function symbol is not explicitly assigned a table of values in $\\mathcal{M}$.**\nThis statement is incorrect for two reasons. First, the definition of a structure $\\mathcal{M}$ for a language $\\mathcal{L}$ requires that *every* function symbol in $\\mathcal{L}$ be assigned an interpretation $f^{\\mathcal{M}}$. There is no such thing as a function symbol that is not assigned an interpretation within a given structure for the language. Second, as established in A, the interpretation $f^{\\mathcal{M}}$ must be a total function. This guarantees that for any tuple of arguments from the domain, the function yields a value. Since term evaluation is defined recursively and all base cases and recursive steps yield a defined value, the evaluation of any term is always defined. The notion of a \"table of values\" is also misleading; for infinite domains, functions like addition on $\\mathbb{R}$ cannot be represented by a finite table, but they are perfectly well-defined functions.\n**Verdict: Incorrect.**\n\n**E. For any substitution $\\sigma$ mapping variables to terms, define $s_{\\sigma}(x) = \\mathrm{val}^{\\mathcal{M}}_{s}(\\sigma(x))$; then for all terms $t$, one has $\\mathrm{val}^{\\mathcal{M}}_{s}(t[\\sigma]) = \\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(t)$.**\nThis is a standard and crucial result in model theory, often called the Substitution Lemma (for terms). It connects the syntactic operation of substitution ($t[\\sigma]$, replacing variables in $t$ according to $\\sigma$) with the semantic operation of evaluation. The proof is by structural induction on the term $t$.\n- **Base Case ($t=x$ is a variable):** $\\mathrm{val}^{\\mathcal{M}}_{s}(x[\\sigma]) = \\mathrm{val}^{\\mathcal{M}}_{s}(\\sigma(x))$. By definition, $\\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(x) = s_{\\sigma}(x) = \\mathrm{val}^{\\mathcal{M}}_{s}(\\sigma(x))$. The equality holds.\n- **Base Case ($t=c$ is a constant):** $\\mathrm{val}^{\\mathcal{M}}_{s}(c[\\sigma]) = \\mathrm{val}^{\\mathcal{M}}_{s}(c) = c^{\\mathcal{M}}$. Also, $\\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(c) = c^{\\mathcal{M}}$. The equality holds.\n- **Inductive Step ($t=f(t_1, \\dots, t_n)$):** Assuming the property holds for $t_1, \\dots, t_n$.\n$\\mathrm{val}^{\\mathcal{M}}_{s}(t[\\sigma]) = \\mathrm{val}^{\\mathcal{M}}_{s}(f(t_1[\\sigma], \\dots, t_n[\\sigma])) = f^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1[\\sigma]), \\dots, \\mathrm{val}^{\\mathcal{M}}_{s}(t_n[\\sigma]))$.\nBy the induction hypothesis, this is $f^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(t_1), \\dots, \\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(t_n))$.\nBy the definition of term evaluation, this is equal to $\\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(f(t_1, \\dots, t_n)) = \\mathrm{val}^{\\mathcal{M}}_{s_{\\sigma}}(t)$. The equality holds.\nThe statement is therefore correct.\n**Verdict: Correct.**\n\n**F. For any $n$-ary predicate symbol $P$ and terms $t_1,\\dots,t_n$, $\\mathcal{M}, s \\models P(t_1,\\dots,t_n)$ if and only if $(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\dots,\\mathrm{val}^{\\mathcal{M}}_{s}(t_n)) \\in P^{\\mathcal{M}}$.**\nThis statement is the precise definition of satisfaction for an atomic formula (that is not an equality) in Tarskian semantics. An atomic sentence of the form $P(t_1, \\dots, t_n)$ is considered true in the model $\\mathcal{M}$ (with assignment $s$) if the tuple formed by evaluating each term $t_i$ belongs to the relation $P^{\\mathcal{M}}$ which is the interpretation of the predicate symbol $P$. This is the fundamental bridge between the syntax of atomic formulas and the set-theoretic semantics of relations on the domain.\n**Verdict: Correct.**\n\n**G. For equality, $\\mathcal{M}, s \\models t = u$ if and only if $t$ and $u$ are syntactically identical terms.**\nThis statement fundamentally misunderstands the semantics of equality. Equality ($=$) is a logical symbol whose meaning is fixed across all structures. The satisfaction condition for an equality formula is semantic, not syntactic: $\\mathcal{M}, s \\models t = u$ if and only if $\\mathrm{val}^{\\mathcal{M}}_{s}(t) = \\mathrm{val}^{\\mathcal{M}}_{s}(u)$. This means the two terms must evaluate to the *same element* of the domain $M$. Syntactically distinct terms can easily evaluate to the same element. For example, in a structure for arithmetic, the terms $2+2$ and $4$ are syntactically different, but they evaluate to the same element, so the formula $2+2 = 4$ is true. The statement in the option describes syntactic identity, not semantic equality.\n**Verdict: Incorrect.**\n\n**H. For any unary function symbol $f$ and binary function symbol $g$, and terms $t_1,t_2$, the composition property holds: $\\mathrm{val}^{\\mathcal{M}}_{s}\\big(f(g(t_1,t_2))\\big) = f^{\\mathcal{M}}\\!\\big(g^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\mathrm{val}^{\\mathcal{M}}_{s}(t_2))\\big)$.**\nThis property is a direct consequence of the compositional definition of term evaluation stated in B. Let's trace the evaluation:\n1. Start with the term $f(g(t_1,t_2))$. To evaluate it, we apply the rule for the outermost function symbol, $f$:\n   $\\mathrm{val}^{\\mathcal{M}}_{s}\\big(f(g(t_1,t_2))\\big) = f^{\\mathcal{M}}\\big(\\mathrm{val}^{\\mathcal{M}}_{s}(g(t_1,t_2))\\big)$.\n2. Now, we evaluate the argument term $g(t_1,t_2)$:\n   $\\mathrm{val}^{\\mathcal{M}}_{s}(g(t_1,t_2)) = g^{\\mathcal{M}}\\big(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1), \\mathrm{val}^{\\mathcal{M}}_{s}(t_2)\\big)$.\n3. Substituting the result of step 2 into step 1, we obtain:\n   $\\mathrm{val}^{\\mathcal{M}}_{s}\\big(f(g(t_1,t_2))\\big) = f^{\\mathcal{M}}\\!\\big(g^{\\mathcal{M}}(\\mathrm{val}^{\\mathcal{M}}_{s}(t_1),\\mathrm{val}^{\\mathcal{M}}_{s}(t_2))\\big)$.\nThis matches the statement exactly. It is a simple illustration of the recursive nature of term evaluation.\n**Verdict: Correct.**\n\n**I. The satisfiability of a set of ground atomic formulas depends only on the syntactic form of the terms involved and is independent of the particular interpretations $c^{\\mathcal{M}}$, $f^{\\mathcal{M}}$, and $P^{\\mathcal{M}}$.**\nThis statement is the antithesis of Tarskian semantics. Satisfiability is a semantic notion: a set of formulas is satisfiable if there exists at least one structure $\\mathcal{M}$ that makes all formulas in the set true. Whether a formula, such as a ground atomic formula $P(c)$, is true in a given structure $\\mathcal{M}$ depends entirely on the interpretations within that structure. Specifically, you must check if $c^{\\mathcal{M}} \\in P^{\\mathcal{M}}$. Changing the interpretation of $c$ or $P$ can change the truth value of the formula. For example, the formula `IsEven(3)` is false in the standard model of arithmetic but could be made true in a different structure where the constant symbol `3` is interpreted as the number $4$ or the predicate `IsEven` is interpreted as the set of odd numbers. Therefore, satisfiability is fundamentally dependent on the interpretations.\n**Verdict: Incorrect.**\n\nIn summary, the correct statements are A, B, E, F, and H.", "answer": "$$\\boxed{ABEFH}$$", "id": "2983810"}, {"introduction": "The true power of first-order logic lies in quantification, and Tarski's genius was in providing a rigorous semantics for it. This practice [@problem_id:2983816] delves into the core mechanism for handling variables: the variable assignment. You will explore how assignments provide context for free variables and how the quantifier clauses systematically modify these assignments to check every relevant element of the domain, thereby giving precise meaning to expressions like $\\forall x$ and $\\exists x$.", "problem": "Consider a language $L$ of First-Order Logic (FOL), an $L$-structure $\\mathcal{M}$ with domain $M$ and interpretation function, and a variable assignment $s\\colon \\mathrm{Var}\\to M$. The Tarskian satisfaction relation $\\mathcal{M}\\models \\varphi[s]$ is determined by the structure $\\mathcal{M}$ and the assignment $s$, and term evaluation is written $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s}$. Select all statements that correctly characterize the role of the assignment $s$ in Tarskian semantics and correctly formalize the update notation $s[x\\mapsto a]$ together with its algebraic properties.\n\nA. For any $s\\colon \\mathrm{Var}\\to M$ and $a\\in M$, the update $s[x\\mapsto a]$ is the assignment $t\\colon \\mathrm{Var}\\to M$ defined by $t(x)=a$ and $t(y)=s(y)$ for all $y\\neq x$.\n\nB. For any $x,y\\in \\mathrm{Var}$ with $x\\neq y$ and any $a,b\\in M$, the updates commute: $s[x\\mapsto a][y\\mapsto b]=s[y\\mapsto b][x\\mapsto a]$.\n\nC. For any formula $\\varphi$, modifying $s$ at a variable $x$ that is bound in $\\varphi$ can change the truth value of $\\mathcal{M}\\models \\varphi[s]$.\n\nD. If $s,s'\\colon \\mathrm{Var}\\to M$ agree on the set of free variables of a formula $\\varphi$, then $\\mathcal{M}\\models \\varphi[s]$ if and only if $\\mathcal{M}\\models \\varphi[s']$.\n\nE. For any term $t$, if $x$ does not occur among the variables of $t$, then $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s}=\\llbracket t\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$ for all $a\\in M$.\n\nF. For any formula $\\varphi$ and any $a\\in M$, one has $\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ if and only if there exists $a\\in M$ such that $\\mathcal{M}\\models \\varphi[s[x\\mapsto a]]$.", "solution": "The problem statement is a standard exercise in first-order logic, specifically pertaining to Tarski's definition of truth (or satisfaction). The concepts presented—first-order language $L$, $L$-structure $\\mathcal{M}$, domain $M$, variable assignment $s$, satisfaction relation $\\mathcal{M}\\models \\varphi[s]$, term evaluation $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s}$, and assignment update $s[x\\mapsto a]$—are all standard and well-defined. The question is a well-posed inquiry into the formal properties of these concepts.\n\nTherefore, the problem statement is valid. We will proceed to analyze each option.\n\nThe core of Tarskian semantics relies on a recursive definition of satisfaction. A variable assignment $s\\colon \\mathrm{Var}\\to M$ maps each variable in the set of all variables $\\mathrm{Var}$ to an element of the domain $M$. The truth of a formula $\\varphi$ is evaluated relative to a structure $\\mathcal{M}$ and such an assignment $s$.\n\nLet's evaluate each statement.\n\n**A. For any $s\\colon \\mathrm{Var}\\to M$ and $a\\in M$, the update $s[x\\mapsto a]$ is the assignment $t\\colon \\mathrm{Var}\\to M$ defined by $t(x)=a$ and $t(y)=s(y)$ for all $y\\neq x$.**\n\nThis statement provides the formal definition of the notation $s[x\\mapsto a]$. It represents a new assignment, let's call it $s'$, which is a slight modification of the original assignment $s$. The new assignment $s'$ maps the variable $x$ to the specific domain element $a$, and for every other variable $y$ (where $y$ is a variable symbol different from $x$), it agrees with the original assignment, i.e., $s'(y) = s(y)$. This is the standard, universally accepted definition of assignment modification used in the semantics of quantified formulas.\n\nVerdict: **Correct**.\n\n**B. For any $x,y\\in \\mathrm{Var}$ with $x\\neq y$ and any $a,b\\in M$, the updates commute: $s[x\\mapsto a][y\\mapsto b]=s[y\\mapsto b][x\\mapsto a]$.**\n\nTo verify this, we must check if the two resulting assignments are the same function. Two functions are equal if and only if they have the same domain and codomain and map each element in the domain to the same element in thecodomain. Let $s_1 = s[x\\mapsto a][y\\mapsto b]$ and $s_2 = s[y\\mapsto b][x\\mapsto a]$. We need to show that $s_1(z) = s_2(z)$ for an arbitrary variable $z \\in \\mathrm{Var}$.\n\nLet's consider the possible cases for $z$:\n1.  Case $z = x$:\n    - $s_1(x) = (s[x\\mapsto a][y\\mapsto b])(x)$. The \"outer\" update is with respect to $y$, and since $x \\neq y$, the value at $x$ is determined by the \"inner\" assignment $s[x\\mapsto a]$. Thus, $s_1(x) = (s[x\\mapsto a])(x) = a$.\n    - $s_2(x) = (s[y\\mapsto b][x\\mapsto a])(x)$. The outer update is with respect to $x$, which by definition maps $x$ to $a$. Thus, $s_2(x) = a$.\n    So, $s_1(x) = s_2(x)$.\n\n2.  Case $z = y$:\n    - $s_1(y) = (s[x\\mapsto a][y\\mapsto b])(y)$. The outer update is with respect to $y$, which by definition maps $y$ to $b$. Thus, $s_1(y) = b$.\n    - $s_2(y) = (s[y\\mapsto b][x\\mapsto a])(y)$. The outer update is with respect to $x$, and since $y \\neq x$, the value at $y$ is determined by the inner assignment $s[y\\mapsto b]$. Thus, $s_2(y) = (s[y\\mapsto b])(y) = b$.\n    So, $s_1(y) = s_2(y)$.\n\n3.  Case $z \\neq x$ and $z \\neq y$:\n    - $s_1(z) = (s[x\\mapsto a][y\\mapsto b])(z)$. The outer update does not affect $z$, so the value is $(s[x\\mapsto a])(z)$. The inner update also does not affect $z$, so the value is $s(z)$.\n    - $s_2(z) = (s[y\\mapsto b][x\\mapsto a])(z)$. The outer update does not affect $z$, so the value is $(s[y\\mapsto b])(z)$. The inner update also does not affect $z$, so the value is $s(z)$.\n    So, $s_1(z) = s_2(z)$.\n\nSince $s_1$ and $s_2$ agree on all variables, they are the same assignment. The condition $x \\neq y$ is crucial, as $s[x\\mapsto a][x\\mapsto b]$ would map $x$ to $b$, whereas $s[x\\mapsto b][x\\mapsto a]$ would map $x$ to $a$.\n\nVerdict: **Correct**.\n\n**C. For any formula $\\varphi$, modifying $s$ at a variable $x$ that is bound in $\\varphi$ can change the truth value of $\\mathcal{M}\\models \\varphi[s]$.**\n\nThe truth value of a formula depends only on the values assigned to its *free* variables. Bound variables are placeholders for quantification. For example, consider the formula $\\varphi = \\forall x P(x)$. The satisfaction condition is $\\mathcal{M} \\models \\forall x P(x)[s]$ if and only if for all $a \\in M$, we have $\\mathcal{M} \\models P(x)[s[x\\mapsto a]]$. The original value $s(x)$ plays no role in this evaluation; the evaluation depends on testing the subformula $P(x)$ for *all* possible values for $x$ from the domain. Therefore, changing $s(x)$ to some other value $s'(x)$ has no effect on the truth of $\\mathcal{M} \\models \\forall x P(x)[s]$. This principle generalizes to all quantified formulas and any bound variable. The statement claims the opposite.\n\nVerdict: **Incorrect**.\n\n**D. If $s,s'\\colon \\mathrm{Var}\\to M$ agree on the set of free variables of a formula $\\varphi$, then $\\mathcal{M}\\models \\varphi[s]$ if and only if $\\mathcal{M}\\models \\varphi[s']$.**\n\nThis is a fundamental result in model theory, often called the **Coincidence Lemma** or **Relevance Lemma**. It formalizes the intuition that the satisfaction of a formula depends only on the what the assignment does to the variables that actually appear free in the formula. The proof is a straightforward structural induction on the complexity of the formula $\\varphi$. The base cases for atomic formulas are clear, as their truth values depend only on the evaluation of their terms, which in turn depend only on the variables within them (all of which are free). The inductive steps for logical connectives and quantifiers preserve the property. We sketched the proof for the universal quantifier in the analysis of option C. This statement is a correct and central theorem of Tarskian semantics.\n\nVerdict: **Correct**.\n\n**E. For any term $t$, if $x$ does not occur among the variables of $t$, then $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s}=\\llbracket t\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$ for all $a\\in M$.**\n\nThis is the analogue of the Coincidence Lemma (Option D) for terms. The value of a term $\\llbracket t \\rrbracket^{\\mathcal{M}}_{s}$ is determined by the interpretation of constants and function symbols, and by the values assigned by $s$ to the variables appearing in $t$. If a variable $x$ does not appear in $t$, then changing the value of $s(x)$ via the update $s[x\\mapsto a]$ will not affect the evaluation of $t$. A formal proof proceeds by induction on the structure of the term $t$.\n- Base case ($t$ is a constant $c$): $\\llbracket c\\rrbracket^{\\mathcal{M}}_{s} = c^{\\mathcal{M}} = \\llbracket c\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$.\n- Base case ($t$ is a variable $y$): Since $x$ does not occur in $t$, $y \\neq x$. Then $\\llbracket y\\rrbracket^{\\mathcal{M}}_{s} = s(y)$ and $\\llbracket y\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]} = (s[x\\mapsto a])(y) = s(y)$. They are equal.\n- Inductive step ($t$ is $f(t_1, \\ldots, t_k)$): Since $x$ does not occur in $t$, it does not occur in any subterm $t_i$. By the induction hypothesis, $\\llbracket t_i\\rrbracket^{\\mathcal{M}}_{s} = \\llbracket t_i\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$ for all $i$. Then $\\llbracket t\\rrbracket^{\\mathcal{M}}_{s} = f^{\\mathcal{M}}(\\llbracket t_1\\rrbracket^{\\mathcal{M}}_{s}, \\ldots, \\llbracket t_k\\rrbracket^{\\mathcal{M}}_{s}) = f^{\\mathcal{M}}(\\llbracket t_1\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}, \\ldots, \\llbracket t_k\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}) = \\llbracket t\\rrbracket^{\\mathcal{M}}_{s[x\\mapsto a]}$.\n\nThe statement is correct.\n\nVerdict: **Correct**.\n\n**F. For any formula $\\varphi$ and any $a\\in M$, one has $\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ if and only if there exists $a\\in M$ such that $\\mathcal{M}\\models \\varphi[s[x\\mapsto a]]$.**\n\nThis statement fundamentally misrepresents the semantics of the universal quantifier. The Tarskian definition of satisfaction for a universally quantified formula is:\n$\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ if and only if for **all** elements $b\\in M$, it is the case that $\\mathcal{M}\\models \\varphi[s[x\\mapsto b]]$.\n\nThe statement given is:\n$\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ if and only if there **exists** an element $a\\in M$ such that $\\mathcal{M}\\models \\varphi[s[x\\mapsto a]]$.\n\nThe right-hand side of the equivalence in the statement is the definition for the *existential quantifier*: $\\mathcal{M}\\models \\exists x\\,\\varphi[s]$. The statement incorrectly equates the meaning of \"for all\" with \"there exists\". These are only equivalent in the trivial and uninteresting case where the domain $M$ contains exactly one element (assuming it's non-empty). In general, this is false. For example, in the integers, \"for all $x$, $x>0$\" is false, but \"there exists $x$ such that $x>0$\" is true. The extraneous \"and any $a \\in M$\" at the beginning of the proposition is ill-formed and adds confusion, but does not salvage the core logical error.\n\nVerdict: **Incorrect**.\n\nSummary of correct statements: A, B, D, E.", "answer": "$$\\boxed{ABDE}$$", "id": "2983816"}]}