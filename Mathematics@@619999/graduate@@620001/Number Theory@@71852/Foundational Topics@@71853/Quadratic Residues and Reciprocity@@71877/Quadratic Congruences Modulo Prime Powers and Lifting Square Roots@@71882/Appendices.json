{"hands_on_practices": [{"introduction": "The ability to lift a solution from a simple prime modulus to a prime power modulus is a cornerstone of modern number theory. This practice [@problem_id:3021640] provides a concrete exercise in this technique, known as Hensel's Lemma. By first reducing a general quadratic congruence to the form $y^2 \\equiv \\Delta \\pmod{p^k}$ and then systematically lifting a solution from modulo $p$ up to $p^4$, you will gain firsthand experience with the iterative process that underpins many advanced results and algorithms.", "problem": "Let $p$ be an odd prime and consider congruences modulo prime powers in the ring $\\mathbb{Z}/p^{k}\\mathbb{Z}$. For given integers $b$ and $c$, the quadratic congruence $x^{2} - b x + c \\equiv 0 \\pmod{p^{k}}$ can be analyzed via its discriminant $\\Delta = b^{2} - 4 c$. Starting from the foundational definitions of congruences modulo prime powers, quadratic residues modulo a prime, and the existence and uniqueness criteria for lifting solutions via Hensel’s lemma, carry out the following program:\n- Determine whether $\\Delta$ is a square modulo $p$.\n- If so, lift an appropriate square root of $\\Delta$ modulo $p$ to a square root modulo $p^{k}$.\n- Express the solutions to $x^{2} - b x + c \\equiv 0 \\pmod{p^{k}}$ in terms of the lifted square roots, justifying each step from first principles.\n\nConcretely, take $p = 19$, $k = 4$, $b = 34$, and $c = 17$. Compute a square root $y$ of $\\Delta = b^{2} - 4 c$ modulo $19^{4}$ that lifts a chosen square root modulo $19$, and then determine the two solutions\n$$\nx \\equiv \\frac{b \\pm y}{2} \\pmod{19^{4}}.\n$$\nAmong all solutions congruent modulo $19^{4}$ to integers in the interval $[0, 19^{4} - 1]$, report the least nonnegative solution as your final answer. No rounding is required, and you must express the final answer as a single integer.", "solution": "The problem requires us to solve the quadratic congruence $x^{2} - b x + c \\equiv 0 \\pmod{p^{k}}$ for the specific values $p = 19$, $k = 4$, $b = 34$, and $c = 17$. The solution process involves finding the square roots of the discriminant $\\Delta = b^2 - 4c$ modulo $p^k$ and then using them to determine the values of $x$.\n\nThe given congruence is $x^2 - 34x + 17 \\equiv 0 \\pmod{19^4}$. Since the modulus $19^4$ is a power of an odd prime $p=19$, we can complete the square. Multiplying the congruence by $4$, which is invertible modulo $19^4$, we get:\n$$4x^2 - 4bx + 4c \\equiv 0 \\pmod{p^k}$$\n$$(2x - b)^2 - b^2 + 4c \\equiv 0 \\pmod{p^k}$$\n$$(2x - b)^2 \\equiv b^2 - 4c \\pmod{p^k}$$\nLet $\\Delta = b^2 - 4c$ be the discriminant. The congruence becomes $(2x - b)^2 \\equiv \\Delta \\pmod{p^k}$. To solve for $x$, we must first find the square roots of $\\Delta$ modulo $p^k$. Let $y$ be such a square root, i.e., $y^2 \\equiv \\Delta \\pmod{p^k}$. Then we have:\n$$2x - b \\equiv \\pm y \\pmod{p^k}$$\n$$2x \\equiv b \\pm y \\pmod{p^k}$$\nSince $p=19$ is odd, $2$ has a multiplicative inverse modulo $p^k$. Thus, the two solutions for $x$ are given by:\n$$x \\equiv 2^{-1}(b \\pm y) \\pmod{p^k}$$\n\nFirst, we compute the discriminant $\\Delta$ with the given values $b=34$ and $c=17$:\n$$\\Delta = 34^2 - 4(17) = 1156 - 68 = 1088$$\nSo we need to solve $y^2 \\equiv 1088 \\pmod{19^4}$. The procedure is to first find a square root modulo $p=19$, and then lift this root sequentially to moduli $19^2$, $19^3$, and $19^4$ using Hensel's Lemma.\n\nStep 1: Find square roots of $\\Delta$ modulo $p=19$.\nWe need to solve $y_1^2 \\equiv 1088 \\pmod{19}$.\n$1088 = 57 \\times 19 + 5$, so $1088 \\equiv 5 \\pmod{19}$.\nWe need to find $y_1$ such that $y_1^2 \\equiv 5 \\pmod{19}$. We can test values: $1^2 \\equiv 1$, $2^2 \\equiv 4$, ..., $9^2 = 81 = 4 \\times 19 + 5 \\equiv 5 \\pmod{19}$.\nSo, one square root is $y_1 = 9$. The other is $-y_1 \\equiv -9 \\equiv 10 \\pmod{19}$. We choose $y_1 = 9$ to begin the lifting process.\n\nStep 2: Lift the root from modulo $19$ to modulo $19^2$.\nLet $f(y) = y^2 - \\Delta$. We have a root $y_1 = 9$ of $f(y) \\equiv 0 \\pmod{19}$. We seek a root $y_2$ modulo $19^2$ of the form $y_2 = y_1 + 19t_1$.\nAccording to Hensel's Lemma, the correction term $t_1$ is found by solving the linear congruence:\n$$f(y_1) + f'(y_1) (19 t_1) \\equiv 0 \\pmod{19^2}$$\n$$(y_1^2 - \\Delta) + (2y_1)(19t_1) \\equiv 0 \\pmod{19^2}$$\nDividing by $19$ (since $y_1^2 - \\Delta$ is a multiple of $19$):\n$$\\frac{y_1^2 - \\Delta}{19} + 2y_1 t_1 \\equiv 0 \\pmod{19}$$\n$$t_1 \\equiv -\\frac{y_1^2 - \\Delta}{19} (2y_1)^{-1} \\pmod{19}$$\nWe calculate the components:\n$y_1^2 - \\Delta = 9^2 - 1088 = 81 - 1088 = -1007$.\n$\\frac{y_1^2 - \\Delta}{19} = \\frac{-1007}{19} = -53$.\n$-53 \\equiv -53 + 3 \\times 19 = -53 + 57 = 4 \\pmod{19}$.\n$f'(y_1) = 2y_1 = 2(9) = 18 \\equiv -1 \\pmod{19}$. The inverse is $(f'(y_1))^{-1} \\equiv (-1)^{-1} \\equiv -1 \\pmod{19}$.\nSo, $t_1 \\equiv - (4) \\cdot (-1) \\equiv 4 \\pmod{19}$.\nThe lifted root is $y_2 = y_1 + 19t_1 = 9 + 19(4) = 9 + 76 = 85$.\nCheck: $y_2^2 = 85^2 = 7225$. $y_2^2 - \\Delta = 7225 - 1088 = 6137$. And $6137 = 17 \\times 361 = 17 \\times 19^2$. So $y_2^2 \\equiv 1088 \\pmod{19^2}$.\n\nStep 3: Lift the root from modulo $19^2$ to modulo $19^3$.\nWe seek a root $y_3$ modulo $19^3$ of the form $y_3 = y_2 + 19^2 t_2$. The correction $t_2$ is given by:\n$$t_2 \\equiv -\\frac{y_2^2 - \\Delta}{19^2} (2y_2)^{-1} \\pmod{19}$$\nWe have $y_2^2 - \\Delta = 6137$.\n$\\frac{y_2^2 - \\Delta}{19^2} = \\frac{6137}{361} = 17$.\n$2y_2 = 2(85) = 170$. Modulo $19$, $170 = 8 \\times 19 + 18 \\equiv 18 \\equiv -1 \\pmod{19}$.\nSo $(2y_2)^{-1} \\equiv -1 \\pmod{19}$.\n$t_2 \\equiv - (17) \\cdot (-1) \\equiv 17 \\pmod{19}$.\nThe lifted root is $y_3 = y_2 + 19^2 t_2 = 85 + 361(17) = 85 + 6137 = 6222$.\n\nStep 4: Lift the root from modulo $19^3$ to modulo $19^4$.\nWe seek a root $y_4$ modulo $19^4$ of the form $y_4 = y_3 + 19^3 t_3$. The correction $t_3$ is:\n$$t_3 \\equiv -\\frac{y_3^2 - \\Delta}{19^3} (2y_3)^{-1} \\pmod{19}$$\n$y_3^2 = 6222^2 = 38713284$.\n$y_3^2 - \\Delta = 38713284 - 1088 = 38712196$.\n$\\frac{y_3^2 - \\Delta}{19^3} = \\frac{38712196}{6859} = 5644$.\nModulo $19$, $5644 = 297 \\times 19 + 1 \\equiv 1 \\pmod{19}$.\n$2y_3 = 2(6222) = 12444$. Modulo $19$, $6222 = 327 \\times 19 + 9 \\equiv 9 \\pmod{19}$. So $2y_3 \\equiv 2(9) = 18 \\equiv -1 \\pmod{19}$.\nThus $(2y_3)^{-1} \\equiv -1 \\pmod{19}$.\n$t_3 \\equiv - (1) \\cdot (-1) \\equiv 1 \\pmod{19}$.\nThe final lifted root is $y = y_4 = y_3 + 19^3 t_3 = 6222 + 6859(1) = 13081$.\nSo, one square root of $\\Delta = 1088$ modulo $19^4 = 130321$ is $y = 13081$. The other is $-y \\equiv -13081 \\equiv 130321 - 13081 = 117240 \\pmod{130321}$.\n\nStep 5: Compute the solutions for $x$.\nThe solutions are found by solving $2x \\equiv b \\pm y \\pmod{19^4}$. We have $b = 34$ and $y = 13081$, and the modulus is $m=19^4 = 130321$.\n\nSolution 1: $2x_1 \\equiv b + y = 34 + 13081 = 13115 \\pmod{130321}$.\nSince $13115$ is odd and the modulus $130321$ is odd, we can write $2x_1 \\equiv 13115 + 130321 \\pmod{130321}$, which makes the right-hand side even.\n$2x_1 \\equiv 143436 \\pmod{130321}$.\n$x_1 \\equiv \\frac{143436}{2} = 71718 \\pmod{130321}$.\n\nSolution 2: $2x_2 \\equiv b - y = 34 - 13081 = -13047 \\pmod{130321}$.\nWe can write $2x_2 \\equiv -13047 + 130321 \\pmod{130321}$ to make the right-hand side positive and even.\n$2x_2 \\equiv 117274 \\pmod{130321}$.\n$x_2 \\equiv \\frac{117274}{2} = 58637 \\pmod{130321}$.\n\nThe two solutions for $x$ in the interval $[0, 19^4-1]$ are $71718$ and $58637$.\n\nStep 6: Final Answer.\nThe problem asks for the least nonnegative solution. Comparing the two solutions, $58637  71718$.\nTherefore, the least nonnegative solution is $58637$.", "answer": "$$\n\\boxed{58637}\n$$", "id": "3021640"}, {"introduction": "While lifting solutions modulo prime powers is powerful, many real-world problems involve composite moduli. This exercise [@problem_id:3021642] demonstrates how to tackle such congruences using the Chinese Remainder Theorem (CRT) as a bridge. You will solve the congruence $x^2 \\equiv 1 \\pmod n$ by first solving it for each prime power factor of $n$—including the special case of powers of 2—and then synthesizing these partial solutions into a complete solution set modulo $n$.", "problem": "Let $n = 2^{4} \\cdot 3^{3} \\cdot 5$ and $a = 1$. Consider the quadratic congruence $x^{2} \\equiv a \\pmod{n}$. Work from first principles about quadratic residues modulo prime powers together with the Chinese Remainder Theorem (CRT). Specifically:\n\n1. Determine all solutions to $x^{2} \\equiv 1 \\pmod{2^{4}}$, $x^{2} \\equiv 1 \\pmod{3^{3}}$, and $x^{2} \\equiv 1 \\pmod{5}$ by appropriate lifting from prime moduli to prime powers where needed, and then use the Chinese Remainder Theorem (CRT) explicitly to synthesize the complete set of solutions modulo $n$.\n\n2. Let $S$ denote the sum of the distinct solution representatives in the standard residue system $0 \\leq x  n$. Compute $S$ as an exact integer.\n\nThe final answer must be the single integer value of $S$.", "solution": "The problem asks for the sum of all distinct solutions to the quadratic congruence $x^{2} \\equiv 1 \\pmod{n}$ in the range $0 \\leq x  n$, where $n = 2^{4} \\cdot 3^{3} \\cdot 5$.\nFirst, we compute the value of $n$:\n$$n = 2^{4} \\cdot 3^{3} \\cdot 5 = 16 \\cdot 27 \\cdot 5 = 16 \\cdot 135 = 2160$$\nThe congruence to be solved is $x^{2} \\equiv 1 \\pmod{2160}$.\nBy the Chinese Remainder Theorem, solving this congruence is equivalent to solving the following system of congruences:\n1. $x^{2} \\equiv 1 \\pmod{16}$\n2. $x^{2} \\equiv 1 \\pmod{27}$\n3. $x^{2} \\equiv 1 \\pmod{5}$\n\nWe will solve each of these congruences individually, as requested by the problem statement.\n\n**Solving $x^{2} \\equiv 1 \\pmod{5}$**\nSince $5$ is a prime number, the congruence $x^{2} - 1 \\equiv 0 \\pmod{5}$, or $(x-1)(x+1) \\equiv 0 \\pmod{5}$, implies that either $x-1 \\equiv 0 \\pmod{5}$ or $x+1 \\equiv 0 \\pmod{5}$. This gives two distinct solutions:\n$x \\equiv 1 \\pmod{5}$\n$x \\equiv -1 \\equiv 4 \\pmod{5}$\nSo, there are $2$ solutions modulo $5$.\n\n**Solving $x^{2} \\equiv 1 \\pmod{27}$**\nWe must solve $x^{2} \\equiv 1 \\pmod{3^3}$. We start with the base case $x^{2} \\equiv 1 \\pmod{3}$. As with modulus $5$, the solutions are $x \\equiv \\pm 1 \\pmod{3}$.\nFor an odd prime $p$, solutions to $x^2 \\equiv 1 \\pmod{p^k}$ can be found by lifting the solutions from modulo $p$. Let $f(x) = x^2 - 1$. Then $f'(x) = 2x$. For a solution $x_0$ to $f(x) \\equiv 0 \\pmod{p}$, it can be lifted to a unique solution modulo $p^k$ for any $k \\geq 1$ if $f'(x_0) \\not\\equiv 0 \\pmod{p}$.\nThe solutions to $x^2 \\equiv 1 \\pmod 3$ are $x_0 = 1$ and $x_0 = -1$.\nFor $x_0 = \\pm 1$, we have $f'(x_0) = 2(\\pm 1) = \\pm 2 \\not\\equiv 0 \\pmod{3}$.\nThus, each solution lifts uniquely. The solution $x \\equiv 1 \\pmod{3}$ lifts to $x \\equiv 1 \\pmod{3^k}$ for any $k \\geq 1$. Similarly, $x \\equiv -1 \\pmod{3}$ lifts to $x \\equiv -1 \\pmod{3^k}$.\nTherefore, for $k=3$, the solutions to $x^{2} \\equiv 1 \\pmod{27}$ are:\n$x \\equiv 1 \\pmod{27}$\n$x \\equiv -1 \\equiv 26 \\pmod{27}$\nSo, there are $2$ solutions modulo $27$.\n\n**Solving $x^{2} \\equiv 1 \\pmod{16}$**\nThe case of $p=2$ is special. The lifting argument is different. It is a known result that for $k \\ge 3$, the congruence $x^2 \\equiv 1 \\pmod{2^k}$ has exactly four solutions. These solutions are $x \\equiv \\pm 1 \\pmod{2^k}$ and $x \\equiv \\pm(1+2^{k-1}) \\pmod{2^k}$.\nFor our problem, we have $k=4$. The solutions to $x^{2} \\equiv 1 \\pmod{16}$ are:\n$x \\equiv 1 \\pmod{16}$\n$x \\equiv -1 \\equiv 15 \\pmod{16}$\n$x \\equiv 1+2^{4-1} = 1+8 = 9 \\pmod{16}$\n$x \\equiv -(1+2^{4-1}) = -9 \\equiv 7 \\pmod{16}$\nLet's verify these: $1^2 \\equiv 1 \\pmod{16}$, $15^2 = (-1)^2 \\equiv 1 \\pmod{16}$, $9^2=81 = 5 \\cdot 16 + 1 \\equiv 1 \\pmod{16}$, and $7^2=49 = 3 \\cdot 16 + 1 \\equiv 1 \\pmod{16}$.\nThe four solutions are $x \\in \\{1, 7, 9, 15\\}$. So, there are $4$ solutions modulo $16$.\n\n**Synthesizing the solutions and computing their sum $S$**\nBy the CRT, for any combination of solutions $(s_1, s_2, s_3)$ from the individual congruences, where $s_1 \\in \\{1, 7, 9, 15\\}$, $s_2 \\in \\{1, 26\\}$, and $s_3 \\in \\{1, 4\\}$, there is a unique solution $x$ modulo $n=2160$.\nThe total number of solutions is the product of the number of solutions for each modulus: $4 \\times 2 \\times 2 = 16$.\nLet $X$ be the set of these $16$ distinct solutions in the standard residue system $0 \\leq x  n$. We are asked to compute $S = \\sum_{x \\in X} x$.\n\nIf $x$ is a solution to $x^2 \\equiv 1 \\pmod n$, then $(-x)^2 = x^2 \\equiv 1 \\pmod n$, so $-x$ is also a solution. In the residue system $\\{0, 1, \\dots, n-1\\}$, the representative for $-x$ is $n-x$ (for $x \\neq 0$).\nSince $1 \\not\\equiv 0 \\pmod n$, $x=0$ is not a solution. Thus, for every solution $x$, $n-x$ is also a potential solution.\nThe solutions can be grouped into pairs $\\{x, n-x\\}$, provided that $x \\neq n-x$. If $x = n-x$, then $2x=n$, which implies $x = n/2$. We must check if $x=n/2$ is a solution to the congruence.\nHere, $n=2160$, so $n/2 = 1080$. We check if $x=1080$ satisfies $x^2 \\equiv 1 \\pmod{2160}$.\n$1080^2 = (1080)(1080) = \\frac{2160}{2} \\cdot 1080 = 2160 \\cdot 540$\nSo, $1080^2 \\equiv 0 \\pmod{2160}$.\nSince $0 \\not\\equiv 1 \\pmod{2160}$, $x=1080$ is not a solution.\nThis confirms that for every solution $x \\in X$, $n-x$ is also a solution and $x \\neq n-x$. Therefore, the $16$ solutions can be partitioned into $16/2 = 8$ distinct pairs of the form $\\{x_i, n-x_i\\}$.\n\nThe sum of the elements in each such pair is $x_i + (n-x_i) = n$.\nThe total sum $S$ is the sum of these $8$ pairs:\n$$S = \\sum_{i=1}^{8} (x_i + (n-x_i)) = \\sum_{i=1}^{8} n = 8n$$\nNow, we calculate the numerical value of $S$:\n$$n = 2160$$\n$$S = 8 \\times 2160 = 17280$$\n\nThe sum of all distinct solutions is $17280$.", "answer": "$$\\boxed{17280}$$", "id": "3021642"}, {"introduction": "Translating abstract mathematical algorithms into functional code is a crucial skill for any computational mathematician. This practice [@problem_id:3021637] challenges you to implement the two-stage process for finding square roots modulo a prime power: first finding an initial root modulo $p$ with the Tonelli-Shanks algorithm, and then applying Hensel's Lemma in an iterative loop to lift this root to a high power. This exercise solidifies your procedural understanding and highlights the computational nature of number theory.", "problem": "Let $p$ be an odd prime, let $k$ be a positive integer, and let $a$ be a unit in the ring of integers modulo $p^{k}$. A unit in $\\mathbb{Z}/p^{k}\\mathbb{Z}$ is an equivalence class represented by an integer $a$ such that $\\gcd(a,p)=1$. The multiplicative group of units modulo a prime $p$ is cyclic, and quadratic residues modulo $p$ are those $a$ such that $x^{2}\\equiv a\\pmod{p}$ has a solution. The standard way to decide quadratic residuosity modulo $p$ is Euler’s criterion, which uses the Legendre symbol $\\left(\\frac{a}{p}\\right)$ defined by $\\left(\\frac{a}{p}\\right)\\equiv a^{\\frac{p-1}{2}}\\pmod{p}$, where $\\left(\\frac{a}{p}\\right)=1$ if $a$ is a quadratic residue modulo $p$, and $\\left(\\frac{a}{p}\\right)=-1$ if $a$ is a quadratic non-residue modulo $p$, with $\\left(\\frac{a}{p}\\right)=0$ if $p\\mid a$.\n\nA computational pathway for solving $x^{2}\\equiv a\\pmod{p^{k}}$ when $p$ is odd and $a$ is a unit with $a$ a quadratic residue modulo $p$ is:\n- find a square root modulo $p$ using a method that exploits the cyclic structure of $(\\mathbb{Z}/p\\mathbb{Z})^{\\times}$ (for example, the algorithm that decomposes $p-1$ into $Q\\cdot 2^{S}$ with $Q$ odd and uses a quadratic non-residue to iteratively correct a candidate root), and\n- lift that root to higher powers of $p$ using a theorem guaranteeing uniqueness of lifts under a non-degeneracy condition on the derivative of $f(x)=x^{2}-a$ at the root, thereby obtaining a sequence of solutions modulo $p^{n}$ for $n=2,3,\\ldots,k$.\n\nYour task is to implement, for each test case below, a computation of a square root of a specific unit $a$ modulo $p^{10}$ by:\n1. computing a square root modulo $p$ using the above-described group-structure-based method for odd primes, and\n2. applying exactly $9$ successive lifts based on the derivative condition to reach modulo $p^{10}$, avoiding any ad hoc closed-form shortcuts.\n\nAssumptions:\n- $p$ is an odd prime.\n- $a$ is coprime to $p$ and $a$ is a quadratic residue modulo $p$ (so a square root modulo $p$ exists).\n- The non-degeneracy condition $p\\nmid 2x$ holds for the starting root $x$ modulo $p$ (this is automatic for odd $p$ and unit $a$).\n\nTest suite (each case is a pair $(p,a)$ with $a$ being the reduction of an explicit square modulo $p$ to ensure quadratic residuosity):\n- Case $1$: $p=101$, $a\\equiv 12^{2}\\equiv 144\\equiv 43\\pmod{101}$, so use $a=43$.\n- Case $2$: $p=97$, $a\\equiv 5^{2}\\equiv 25\\pmod{97}$, so use $a=25$.\n- Case $3$: $p=3$, $a\\equiv 1^{2}\\equiv 1\\pmod{3}$, so use $a=1$.\n- Case $4$: $p=5$, $a\\equiv 2^{2}\\equiv 4\\pmod{5}$, so use $a=4$.\n\nDesign for coverage:\n- Case $1$ tests a general odd prime with $p-1$ having a moderate power of $2$ in its factorization.\n- Case $2$ tests an odd prime $p$ with $p-1$ having a larger power of $2$ in its factorization.\n- Case $3$ tests the smallest odd prime $p=3$ where the factorization of $p-1$ has a minimal power of $2$.\n- Case $4$ tests $p=5$ with $p-1$ having power $2$ equal to $2$.\n\nFor each case, your program must produce the integer representative $x$ in the range $0\\leq xp^{10}$ that satisfies $x^{2}\\equiv a\\pmod{p^{10}}$, and which reduces to the chosen square root modulo $p$ obtained in step $1$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry being the computed integer $x$ modulo $p^{10}$ for the corresponding case, ordered as listed above (for example, $\\left[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4}\\right]$). No units are involved; each answer is a plain integer.", "solution": "The task is to find a solution to the quadratic congruence $x^2 \\equiv a \\pmod{p^{10}}$ for several pairs of an odd prime $p$ and a unit $a$. The problem specifies a two-step method:\n1.  Find a square root $r_1$ of $a$ modulo $p$ using the Tonelli-Shanks algorithm.\n2.  Lift this root $r_1$ successively nine times using Hensel's Lemma to find a root modulo $p^{10}$.\n\n### Principle-Based Algorithmic Design\n\n**Step 1: Finding a Square Root Modulo a Prime $p$ (Tonelli-Shanks Algorithm)**\n\nThe congruence $x^2 \\equiv a \\pmod p$ is solvable if and only if $a$ is a quadratic residue modulo $p$. This is equivalent to the Legendre symbol condition $\\left(\\frac{a}{p}\\right) = 1$, or by Euler's criterion, $a^{(p-1)/2} \\equiv 1 \\pmod p$. The problem guarantees this condition holds for all test cases.\n\nThe Tonelli-Shanks algorithm is a standard method for finding such a root $x$. Its core idea is to work within the cyclic multiplicative group $(\\mathbb{Z}/p\\mathbb{Z})^\\times$.\nFirst, we decompose $p-1$ as $Q \\cdot 2^S$, where $Q$ is odd and $S \\ge 1$.\n- If $S=1$, i.e., $p \\equiv 3 \\pmod 4$, a root can be computed directly as $x \\equiv a^{(p+1)/4} \\pmod p$.\n- If $S  1$, i.e., $p \\equiv 1 \\pmod 4$, a more general procedure is needed. We find a quadratic non-residue $z$ modulo $p$ (i.e., $z^{(p-1)/2} \\equiv -1 \\pmod p$). The algorithm then initializes a candidate root $R = a^{(Q+1)/2} \\pmod p$ and an error-tracking term $t = a^Q \\pmod p$. The order of $t$ must be a power of $2$. The algorithm iteratively multiplies $R$ by carefully chosen powers of $c=z^Q$ to reduce the order of $t$, until $t \\equiv 1 \\pmod p$. At termination, $R$ is a square root of $a$.\n\n**Step 2: Lifting the Solution to Modulo $p^k$ (Hensel's Lemma)**\n\nHensel's Lemma provides a method to lift a solution of a polynomial congruence from modulo $p^n$ to modulo $p^{n+1}$, provided the solution is non-singular. For our problem, the polynomial is $f(x) = x^2 - a$.\n\nLet $r_n$ be an integer solution to $x^2 \\equiv a \\pmod{p^n}$. This means $r_n^2 - a = c_n p^n$ for some integer $c_n$. We seek a new solution $r_{n+1}$ modulo $p^{n+1}$ of the form $r_{n+1} = r_n + t p^n$ for some integer $t \\in \\{0, 1, \\ldots, p-1\\}$.\n\nWe require $f(r_{n+1}) \\equiv 0 \\pmod{p^{n+1}}$. Substituting the form of $r_{n+1}$:\n$$ (r_n + t p^n)^2 - a \\equiv 0 \\pmod{p^{n+1}} $$\n$$ r_n^2 + 2r_n t p^n + t^2 p^{2n} - a \\equiv 0 \\pmod{p^{n+1}} $$\n$$ (r_n^2 - a) + 2r_n t p^n + t^2 p^{2n} \\equiv 0 \\pmod{p^{n+1}} $$\n\nSince $n \\ge 1$, the term $t^2 p^{2n}$ is divisible by $p^{n+1}$ and can be ignored. We substitute $r_n^2 - a = c_n p^n$:\n$$ c_n p^n + 2r_n t p^n \\equiv 0 \\pmod{p^{n+1}} $$\n\nDividing the congruence by $p^n$, we obtain a linear congruence for $t$ modulo $p$:\n$$ c_n + 2r_n t \\equiv 0 \\pmod p $$\n$$ 2r_n t \\equiv -c_n \\pmod p $$\n\nSince $p$ is an odd prime and $a$ is a unit, the initial root $r_1$ is not divisible by $p$. Thus, $2r_1 \\not\\equiv 0 \\pmod p$, and its multiplicative inverse $(2r_1)^{-1} \\pmod p$ exists. As $r_n \\equiv r_1 \\pmod p$, the inverse $(2r_n)^{-1} \\pmod p$ also exists and is equal to $(2r_1)^{-1} \\pmod p$. We can solve for $t$:\n$$ t \\equiv -c_n \\cdot (2r_n)^{-1} \\pmod p $$\nwhere the integer $c_n$ is computed as $c_n = (r_n^2 - a) / p^n$.\n\nThe lifting process is as follows:\n1.  Start with the root $r_1$ from Tonelli-Shanks, which is a solution modulo $p^1=p$.\n2.  For $n$ from $1$ to $9$:\n    a. Let the current root be $r_n$ and the modulus be $p^n$.\n    b. Compute the error coefficient $c_n = (r_n^2 - a) // p^n$.\n    c. Compute the correction term $t \\equiv -c_n \\cdot (2r_1)^{-1} \\pmod p$.\n    d. The new root is $r_{n+1} = r_n + t \\cdot p^n$.\n3.  After $9$ iterations, the final integer $r_{10}$ is a solution to $x^2 \\equiv a \\pmod{p^{10}}$. The integer arithmetic capabilities of Python are sufficient to handle the large numbers involved. The resulting integer $r_{10}$ will be in the required range $[0, p^{10}-1]$ if we start with $r_1 \\in [0, p-1]$ and always choose $t \\in [0, p-1]$.\n\nThis two-step procedure will be implemented for each test case to produce the required results.", "answer": "```python\nimport numpy as np\n\n# Note: The problem requires numpy to be imported, but it is not used as\n# Python's built-in arbitrary-precision integers are sufficient.\n\ndef solve():\n    \"\"\"\n    Solves the main problem by iterating through test cases and applying\n    the required number theory algorithms.\n    \"\"\"\n\n    def _tonelli_shanks(n, p):\n        \"\"\"\n        Implements the Tonelli-Shanks algorithm to find a square root of n mod p.\n        _tonelli_shanks(n: int, p: int) - int\n        \n        Args:\n            n: An integer which is a quadratic residue modulo p.\n            p: An odd prime.\n            \n        Returns:\n            An integer x such that x^2 = n (mod p).\n        \"\"\"\n        # Euler's criterion check (guaranteed by problem statement)\n        if pow(n, (p - 1) // 2, p) != 1:\n            raise ValueError(\"n is not a quadratic residue modulo p\")\n\n        # Simple case for p = 3 (mod 4)\n        if p % 4 == 3:\n            return pow(n, (p + 1) // 4, p)\n\n        # Factor p-1 = Q * 2^S\n        Q = p - 1\n        S = 0\n        while Q % 2 == 0:\n            Q //= 2\n            S += 1\n\n        # Find a quadratic non-residue z\n        z = 2\n        while pow(z, (p - 1) // 2, p) == 1:\n            z += 1\n\n        # Initialize for the main loop\n        M = S\n        c = pow(z, Q, p)\n        t = pow(n, Q, p)\n        R = pow(n, (Q + 1) // 2, p)\n\n        # Main loop\n        while t != 1:\n            if t == 0:\n                return 0\n            \n            # Find the smallest i  0 such that t^(2^i) == 1 mod p\n            i = 0\n            temp_t = t\n            while temp_t != 1:\n                temp_t = (temp_t * temp_t) % p\n                i += 1\n            \n            # This should not happen if n is a valid quadratic residue\n            if i = M:\n                raise RuntimeError(\"Tonelli-Shanks failed, algorithm error.\")\n\n            # Update variables for the next iteration\n            b = pow(c, pow(2, M - i - 1), p)\n            M = i\n            c = (b * b) % p\n            t = (t * c) % p\n            R = (R * b) % p\n        \n        return R\n\n    def _lift_root(p, a):\n        \"\"\"\n        Computes the square root of a modulo p^10 using Tonelli-Shanks\n        and Hensel's Lemma for lifting.\n        _lift_root(p: int, a: int) - int\n\n        Args:\n            p: An odd prime.\n            a: An integer that is a unit and quadratic residue mod p.\n\n        Returns:\n            An integer x in [0, p^10 - 1] such that x^2 = a (mod p^10).\n        \"\"\"\n        # Step 1: Find a square root modulo p\n        r1 = _tonelli_shanks(a, p)\n\n        # Step 2: Lift the root from p to p^10 (9 lifts)\n        k = 10\n        \n        # Precompute the inverse of the derivative f'(x)=2x at r1 mod p.\n        # This inverse is used in every lifting step.\n        inv_2r1 = pow(2 * r1, -1, p)\n        \n        r_current = r1\n        p_power = p\n        \n        # Perform 9 successive lifts.\n        for _ in range(1, k):\n            # Let r_current be a root mod p_power. r_current^2 - a = c * p_power.\n            # We seek a new root r_new = r_current + t * p_power mod (p_power * p).\n            # The correction term t is found by solving:\n            # t = -((r_current^2 - a) / p_power) * (2*r_current)^-1 mod p\n            \n            c = (r_current * r_current - a) // p_power\n            t = (-c * inv_2r1) % p\n            \n            # Update the root and the modulus for the next iteration.\n            r_current = r_current + t * p_power\n            p_power *= p\n            \n        return r_current\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (101, 43),  # Case 1\n        (97, 25),   # Case 2\n        (3, 1),     # Case 3\n        (5, 4),     # Case 4\n    ]\n\n    results = []\n    for p, a in test_cases:\n        result = _lift_root(p, a)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3021637"}]}