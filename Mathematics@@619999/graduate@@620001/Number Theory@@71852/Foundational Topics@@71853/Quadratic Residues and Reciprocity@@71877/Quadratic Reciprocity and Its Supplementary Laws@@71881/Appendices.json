{"hands_on_practices": [{"introduction": "The supplementary laws for quadratic reciprocity provide elegant, explicit formulas for the Legendre symbols $\\left(\\frac{-1}{p}\\right)$ and $\\left(\\frac{2}{p}\\right)$. Before applying these powerful theoretical results, it is a valuable exercise to build confidence in them through numerical verification. This practice guides you to compare the predictions of the supplementary laws against direct computation using Euler's criterion, confirming their consistency across a range of prime numbers [@problem_id:3021697].", "id": "3021697", "problem": "Let $p$ be an odd prime. The Legendre symbol $(a/p)$ is defined for integers $a$ as $(a/p)=1$ if $a$ is a quadratic residue modulo $p$ and $a \\not\\equiv 0 \\pmod{p}$, $(a/p)=-1$ if $a$ is a quadratic nonresidue modulo $p$, and $(a/p)=0$ if $p$ divides $a$. A computationally useful characterization is Euler's criterion: for an integer $a$ with $p \\nmid a$, one has $a^{(p-1)/2} \\equiv (a/p) \\pmod{p}$, so $a^{(p-1)/2} \\equiv 1 \\pmod{p}$ if and only if $(a/p)=1$, and $a^{(p-1)/2} \\equiv -1 \\pmod{p}$ if and only if $(a/p)=-1$.\n\nThe goal is to numerically verify the supplementary laws associated with Quadratic Reciprocity for the specific integers $a=-1$ and $a=2$ by comparing two independently computed values of $(a/p)$ across all odd primes $p<200$:\n- A direct computation of $(a/p)$ via Euler's criterion.\n- A predicted sign of $(a/p)$ derived from a congruence-class analysis that follows from counting arguments based on the parity of certain sets of residues modulo $p$, as obtained from Gauss's lemma.\n\nTo make the verification robust and to test consistency of these laws, the program should also include a third check for $a=-2$, using the fact that $(ab/p)=(a/p)(b/p)$ for integers $a$ and $b$ with $p \\nmid ab$, so that the behavior for $a=-2$ can be deduced from the behaviors for $a=-1$ and $a=2$.\n\nYour task is to:\n- Generate all odd primes $p$ with $3 \\le p < 200$.\n- For each such prime $p$, compute $(a/p)$ using Euler's criterion for $a=-1$, $a=2$, and $a=-2$.\n- For each such prime $p$, compute a predicted value for $(a/p)$ using a congruence-class rule that arises from the parity analysis of residues given by Gauss's lemma (without using the direct computation for $(a/p)$ to generate the prediction).\n- For each of the three values of $a$, return a single boolean indicating whether the directly computed value of $(a/p)$ agrees with the predicted value for all odd primes $p<200$.\n\nTest suite and coverage:\n- Case $a=-1$: This tests the first supplementary law across all odd primes, including the boundary primes $p=3$ and $p=199$.\n- Case $a=2$: This tests the second supplementary law across all odd primes, and distinguishes primes by residue classes modulo $8$.\n- Case $a=-2$: This tests a consistency check derived from multiplicativity, providing additional coverage across residue classes modulo $8$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be in the order $[R_{-1},R_{2},R_{-2}]$, where each $R_{a}$ is the boolean result for the corresponding $a$. For example, an output might look like $[{\\rm True},{\\rm True},{\\rm True}]$ if all three verifications succeed across the test suite of all odd primes $p<200$.", "solution": "We begin from the definitions and fundamental tools. For an odd prime $p$ and integer $a$ with $p \\nmid a$, the Legendre symbol $(a/p)$ indicates whether $a$ is a quadratic residue modulo $p$. Euler's criterion states\n$$\na^{(p-1)/2} \\equiv (a/p) \\pmod{p}.\n$$\nThus, to compute $(a/p)$ numerically, we can reduce $a$ modulo $p$, compute $a^{(p-1)/2}$ modulo $p$, and map the result to $1$ or $-1$.\n\nTo predict $(a/p)$ for particular $a$ without direct exponentiation, we use Gauss's lemma. Gauss's lemma asserts that for $p$ odd and $a$ with $p \\nmid a$, if we consider the set $\\{a,2a,\\dots,((p-1)/2)a\\}$ modulo $p$ and count how many of these have least positive residues greater than $p/2$, say $n(a)$, then\n$$\n(a/p) = (-1)^{n(a)}.\n$$\nApplying this counting argument to the special integers $a=-1$ and $a=2$ yields congruence-class characterizations for $(a/p)$ in terms of $p$ modulo small moduli.\n\nFirst, for $a=-1$: the set of residues is $\\{-1,-2,\\dots,-(p-1)/2\\}$; exactly $(p-1)/2$ of them are greater than $p/2$ when taken as least positive residues, and the parity of this count is determined by whether $p \\equiv 1 \\pmod{4}$ or $p \\equiv 3 \\pmod{4}$. One derives the formula\n$$\n(-1/p) = (-1)^{(p-1)/2},\n$$\nwhich equivalently is $(-1/p)=1$ if $p \\equiv 1 \\pmod{4}$ and $(-1/p)=-1$ if $p \\equiv 3 \\pmod{4}$.\n\nSecond, for $a=2$: examining the residues $2,4,\\dots,p-1$ and counting how many land in $(p/2,p)$ leads to the established characterization\n$$\n(2/p) = (-1)^{(p^2-1)/8},\n$$\nwhich equivalently is $(2/p)=1$ if $p \\equiv 1 \\text{ or } 7 \\pmod{8}$ and $(2/p)=-1$ if $p \\equiv 3 \\text{ or } 5 \\pmod{8}$.\n\nBy multiplicativity of the Legendre symbol, for $a=-2$ we have\n$$\n(-2/p) = (-1/p)\\,(2/p) = (-1)^{(p-1)/2}\\,(-1)^{(p^2-1)/8} = (-1)^{(p-1)/2 + (p^2-1)/8}.\n$$\nEquivalently, $(-2/p)=1$ if $p \\equiv 1 \\text{ or } 3 \\pmod{8}$ and $(-2/p)=-1$ if $p \\equiv 5 \\text{ or } 7 \\pmod{8}$.\n\nAlgorithmic plan:\n1. Generate all odd primes $p$ with $3 \\le p < 200$. A sieve of Eratosthenes up to $199$ suffices, followed by filtering out $p=2$.\n2. Implement a function to compute $(a/p)$ using Euler's criterion: reduce $a$ modulo $p$ to $a \\bmod p$, compute $a^{(p-1)/2} \\bmod p$, and map the result $1 \\mapsto 1$, $p-1 \\mapsto -1$. For the chosen $a \\in \\{-1,2,-2\\}$ and odd primes $p$, the value cannot be $0$.\n3. Implement a function that computes the predicted value for $(a/p)$ using the congruence-class rules derived above:\n   - For $a=-1$, return $1$ if $p \\equiv 1 \\pmod{4}$ and $-1$ otherwise.\n   - For $a=2$, return $1$ if $p \\equiv 1 \\text{ or } 7 \\pmod{8}$ and $-1$ otherwise.\n   - For $a=-2$, return the product of the predictions for $a=-1$ and $a=2$ (equivalently, use the modulo $8$ rule above).\n4. For each $a \\in \\{-1,2,-2\\}$, verify that for all odd primes $p<200$, the Euler-computed $(a/p)$ equals the predicted value. Record one boolean per $a$ indicating whether the law holds for every prime in the set.\n5. Output the three booleans in the order $[R_{-1},R_{2},R_{-2}]$ as a single line in the required format.\n\nThis procedure verifies numerically that the supplementary laws for $(-1/p)$ and $(2/p)$, together with the consistency for $(-2/p)$ via multiplicativity, hold across the entire specified test suite of odd primes less than $200$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sieve_primes_upto(n: int):\n    \"\"\"Return list of all primes <= n using a simple sieve.\"\"\"\n    if n < 2:\n        return []\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    p = 2\n    while p * p <= n:\n        if is_prime[p]:\n            step = p\n            start = p * p\n            is_prime[start:n+1:step] = [False] * (((n - start) // step) + 1)\n        p += 1\n    return [i for i, flag in enumerate(is_prime) if flag]\n\ndef legendre_symbol(a: int, p: int) -> int:\n    \"\"\"\n    Compute (a/p) for odd prime p using Euler's criterion.\n    Returns 1 if a is a quadratic residue mod p, -1 if not.\n    Assumes p does not divide a for given a in {-1,2,-2} and odd primes p.\n    \"\"\"\n    a_mod = a % p\n    # Euler's criterion: a^{(p-1)/2} ≡ (a/p) (mod p)\n    val = pow(a_mod, (p - 1) // 2, p)\n    if val == 1:\n        return 1\n    elif val == p - 1:\n        return -1\n    else:\n        # For completeness; should not happen for a in {-1,2,-2} and odd primes p\n        return 0\n\ndef predicted_legendre(a: int, p: int) -> int:\n    \"\"\"\n    Predicted value of (a/p) using supplementary laws:\n    - (-1/p) = 1 if p ≡ 1 (mod 4), else -1\n    - (2/p) = 1 if p ≡ 1 or 7 (mod 8), else -1\n    - (-2/p) = (-1/p)*(2/p)\n    \"\"\"\n    if a == -1:\n        return 1 if (p % 4) == 1 else -1\n    elif a == 2:\n        return 1 if (p % 8) in (1, 7) else -1\n    elif a == -2:\n        # Use multiplicativity: (-2/p) = (-1/p)*(2/p)\n        return predicted_legendre(-1, p) * predicted_legendre(2, p)\n    else:\n        raise ValueError(\"Unsupported a\")\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # We verify for a in {-1, 2, -2} across all odd primes p < 200.\n    test_cases = [-1, 2, -2]\n\n    # Generate odd primes less than 200\n    primes = [p for p in sieve_primes_upto(199) if p % 2 == 1]\n\n    results = []\n    for a in test_cases:\n        all_match = True\n        for p in primes:\n            ls = legendre_symbol(a, p)\n            pred = predicted_legendre(a, p)\n            if ls != pred:\n                all_match = False\n                break\n        results.append(all_match)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "The Legendre symbol is defined only for prime moduli, but its definition can be extended to composite odd moduli via the Jacobi symbol. While the Jacobi symbol shares many properties with the Legendre symbol, there is one crucial difference that this exercise explores. This problem asks you to find a concrete example demonstrating that a Jacobi symbol $\\left(\\frac{a}{n}\\right)$ can equal $1$ even when the congruence $x^2 \\equiv a \\pmod n$ has no solution, a subtlety that is fundamental to understanding its proper use and limitations [@problem_id:3021694].", "id": "3021694", "problem": "Let $n=15$ and let $\\left(\\frac{a}{n}\\right)$ denote the Jacobi symbol. Identify the least positive integer $a$ with $\\gcd(a,15)=1$ such that $\\left(\\frac{a}{15}\\right)=1$ but the congruence $x^{2}\\equiv a \\pmod{15}$ has no solution. Your justification must proceed from the fundamental definitions of the Legendre symbol $\\left(\\frac{a}{p}\\right)$ for odd primes $p$, the Jacobi symbol $\\left(\\frac{a}{n}\\right)$ for odd composite $n$, and the law of quadratic reciprocity together with its supplementary laws, and must include an argument that no solution exists to $x^{2}\\equiv a \\pmod{15}$ despite $\\left(\\frac{a}{15}\\right)=1$. Report the value of $a$ only. No rounding is required.", "solution": "The problem has been validated and is determined to be a well-posed, scientifically grounded problem in number theory.\n\nThe objective is to find the least positive integer $a$ such that $\\gcd(a, 15) = 1$, the Jacobi symbol $\\left(\\frac{a}{15}\\right) = 1$, and the congruence $x^2 \\equiv a \\pmod{15}$ has no solution.\n\nThe integer $n$ is given as $n=15$. The prime factorization of $n$ is $15 = 3 \\times 5$.\n\nBy definition, for an odd composite integer $n = p_1 p_2 \\cdots p_k$, the Jacobi symbol $\\left(\\frac{a}{n}\\right)$ is defined as the product of the Legendre symbols for each prime factor:\n$$\n\\left(\\frac{a}{n}\\right) = \\left(\\frac{a}{p_1}\\right) \\left(\\frac{a}{p_2}\\right) \\cdots \\left(\\frac{a}{p_k}\\right)\n$$\nFor $n=15$, this becomes:\n$$\n\\left(\\frac{a}{15}\\right) = \\left(\\frac{a}{3}\\right) \\left(\\frac{a}{5}\\right)\n$$\nWe are given the condition $\\left(\\frac{a}{15}\\right) = 1$. This implies that the product of the Legendre symbols $\\left(\\frac{a}{3}\\right)\\left(\\frac{a}{5}\\right)$ must equal $1$. This can occur in two ways:\n1. $\\left(\\frac{a}{3}\\right) = 1$ and $\\left(\\frac{a}{5}\\right) = 1$.\n2. $\\left(\\frac{a}{3}\\right) = -1$ and $\\left(\\frac{a}{5}\\right) = -1$.\n\nNext, we consider the solvability of the quadratic congruence $x^2 \\equiv a \\pmod{15}$. According to the Chinese Remainder Theorem, this congruence has a solution if and only if the system of congruences\n\\begin{align*}\nx^2 &\\equiv a \\pmod{3} \\\\\nx^2 &\\equiv a \\pmod{5}\n\\end{align*}\nis simultaneously solvable.\n\nFor an odd prime $p$, the congruence $x^2 \\equiv a \\pmod{p}$ has a solution if and only if $a$ is a quadratic residue modulo $p$ (assuming $\\gcd(a,p)=1$), which is equivalent to the condition that the Legendre symbol $\\left(\\frac{a}{p}\\right) = 1$.\n\nThe problem states that $x^2 \\equiv a \\pmod{15}$ has no solution. This means that at least one of the congruences $x^2 \\equiv a \\pmod{3}$ or $x^2 \\equiv a \\pmod{5}$ has no solution. In terms of Legendre symbols, this is equivalent to the condition that $\\left(\\frac{a}{3}\\right) = -1$ or $\\left(\\frac{a}{5}\\right) = -1$.\n\nWe must now combine the two main conditions on $a$:\n1. $\\left(\\frac{a}{3}\\right)\\left(\\frac{a}{5}\\right) = 1$\n2. $\\left(\\frac{a}{3}\\right) = -1$ or $\\left(\\frac{a}{5}\\right) = -1$\n\nIf we had $\\left(\\frac{a}{3}\\right) = 1$ and $\\left(\\frac{a}{5}\\right) = 1$, the first condition would be satisfied, but the second would be violated. Furthermore, this case corresponds to $x^2 \\equiv a \\pmod{15}$ having a solution, which contradicts the problem statement.\nTherefore, the only way to satisfy both conditions is for both Legendre symbols to be $-1$:\n$$\n\\left(\\frac{a}{3}\\right) = -1 \\quad \\text{and} \\quad \\left(\\frac{a}{5}\\right) = -1\n$$\nThis arrangement satisfies $\\left(\\frac{a}{3}\\right)\\left(\\frac{a}{5}\\right) = (-1)(-1) = 1$, and it also satisfies the condition that at least one of the symbols is $-1$, ensuring that $x^2 \\equiv a \\pmod{15}$ has no solution.\n\nThe problem is now reduced to finding the smallest positive integer $a$ with $\\gcd(a, 15)=1$ that is a quadratic non-residue modulo $3$ and a quadratic non-residue modulo $5$.\n\nFirst, we determine the quadratic non-residues modulo $3$. The integers coprime to $3$ are congruent to $1$ or $2$ modulo $3$.\n$1^2 \\equiv 1 \\pmod{3}$, so $\\left(\\frac{1}{3}\\right)=1$.\n$2^2 \\equiv 4 \\equiv 1 \\pmod{3}$. The non-residues are integers not congruent to a square. The only non-residue modulo $3$ is $2$.\nSo, $\\left(\\frac{2}{3}\\right)=-1$. This requires $a \\equiv 2 \\pmod{3}$.\n\nSecond, we determine the quadratic non-residues modulo $5$. The integers coprime to $5$ are congruent to $1, 2, 3,$ or $4$ modulo $5$.\n$1^2 \\equiv 1 \\pmod{5}$\n$2^2 \\equiv 4 \\pmod{5}$\n$3^2 \\equiv 9 \\equiv 4 \\pmod{5}$\n$4^2 \\equiv 16 \\equiv 1 \\pmod{5}$\nThe quadratic residues modulo $5$ are $1$ and $4$. The quadratic non-residues are $2$ and $3$.\nSo, $\\left(\\frac{2}{5}\\right)=-1$ and $\\left(\\frac{3}{5}\\right)=-1$. This requires $a \\equiv 2 \\pmod{5}$ or $a \\equiv 3 \\pmod{5}$.\n\nWe seek the smallest positive integer $a$ such that $\\gcd(a,15)=1$ and it satisfies the system of congruences arising from our conditions:\n$$\na \\equiv 2 \\pmod{3} \\quad \\text{and} \\quad (a \\equiv 2 \\pmod{5} \\text{ or } a \\equiv 3 \\pmod{5})\n$$\nWe can now test positive integers $a$, starting from $1$, that are coprime to $15$.\nThe integers are $1, 2, 4, 7, 8, 11, 13, 14, \\dots$\n\n- Let $a=1$. $\\gcd(1,15)=1$. But $1 \\equiv 1 \\pmod{3}$, which violates $a \\equiv 2 \\pmod{3}$. So $a=1$ is not the solution.\n\n- Let $a=2$. $\\gcd(2,15)=1$.\n  - We check the condition $a \\equiv 2 \\pmod{3}$: $2 \\equiv 2 \\pmod{3}$. This is satisfied.\n  - We check the condition $a \\equiv 2 \\pmod{5}$ or $a \\equiv 3 \\pmod{5}$: $2 \\equiv 2 \\pmod{5}$. This is satisfied.\n\nSince $a=2$ is the first integer after $a=1$ that satisfies the necessary conditions, it is the least positive integer.\n\nTo confirm according to the problem statement, we use the second supplementary law of quadratic reciprocity, which states $\\left(\\frac{2}{p}\\right) = (-1)^{(p^2-1)/8}$.\nFor $p=3$: $\\left(\\frac{2}{3}\\right) = (-1)^{(3^2-1)/8} = (-1)^1 = -1$.\nFor $p=5$: $\\left(\\frac{2}{5}\\right) = (-1)^{(5^2-1)/8} = (-1)^3 = -1$.\nBoth conditions are met for $a=2$.\n\nLet us verify that $a=2$ fulfills all requirements of the original problem:\n- It is the least positive integer found.\n- $\\gcd(2, 15)=1$.\n- $\\left(\\frac{2}{15}\\right) = \\left(\\frac{2}{3}\\right)\\left(\\frac{2}{5}\\right) = (-1)(-1) = 1$.\n- The congruence $x^2 \\equiv 2 \\pmod{15}$ has no solution because $x^2 \\equiv 2 \\pmod{3}$ has no solution, as $\\left(\\frac{2}{3}\\right)=-1$.\n\nThus, the least positive integer $a$ satisfying all given conditions is $2$.", "answer": "$$\\boxed{2}$$"}, {"introduction": "The laws of quadratic reciprocity are not just theoretical curiosities; they provide the foundation for a highly efficient algorithm to compute Legendre and Jacobi symbols. This practice challenges you to design and implement this algorithm, which cleverly mirrors the structure of the Euclidean algorithm to reduce the size of the arguments at each step. By translating the abstract laws into a computational procedure, you will gain a deeper appreciation for their practical power in number theory and cryptography [@problem_id:3021663].", "id": "3021663", "problem": "Design and implement a program that computes the Legendre symbol $\\left(\\frac{a}{p}\\right)$ for an integer $a$ and an odd prime $p$ using an iterative algorithm based solely on the Quadratic Reciprocity Theorem and the supplementary laws. Your algorithm must iteratively transform the pair $(a,p)$ into a new pair $(a',p')$ so that the evaluation of $\\left(\\frac{a}{p}\\right)$ is reduced to the evaluation of $\\left(\\frac{a'}{p'}\\right)$, multiplied by a sign determined entirely by the parity conditions mandated by the Quadratic Reciprocity Theorem and the supplementary laws. The algorithm must include the following features:\n\n- It reduces $a$ modulo $p$ at each stage to ensure $0 \\le a < p$.\n- It accounts for negative inputs $a$ by an appropriate sign factor derived from the supplementary law for $-1$.\n- It removes powers of $2$ from $a$ at each stage and accumulates the sign factor contributed by each extracted factor of $2$ using the supplementary law for $2$.\n- After removing the factor of $2$, it invokes the reciprocity step to swap the roles of $a$ and $p$, subject to the reciprocity sign determined by their congruence classes modulo $4$, and then reduces the new top entry by taking $p \\bmod a$.\n\nYour task has three parts:\n\n$1.$ Specify the algorithm precisely in words and implement it in code. You may take as given the Quadratic Reciprocity Theorem and the supplementary laws for $-1$ and $2$ as foundational inputs, but you must not assume or invoke any other result that directly computes $\\left(\\frac{a}{p}\\right)$.\n\n$2.$ Prove that your algorithm terminates for all integer inputs $a$ and all odd primes $p$.\n\n$3.$ Prove that the algorithm is correct, namely that the accumulated sign and reduction steps preserve the value of the Legendre symbol, so that the returned output is exactly $\\left(\\frac{a}{p}\\right) \\in \\{-1,0,1\\}$.\n\nYour program must produce the Legendre symbol for each of the following test cases:\n- $(a,p) = (0,3)$\n- $(a,p) = (1,5)$\n- $(a,p) = (2,7)$\n- $(a,p) = (10,11)$\n- $(a,p) = (-3,11)$\n- $(a,p) = (22,11)$\n- $(a,p) = (1024,17)$\n- $(a,p) = (123456789,31)$\n- $(a,p) = (97,13)$\n- $(a,p) = (45,23)$\n- $(a,p) = (2,3)$\n- $(a,p) = (8,5)$\n- $(a,p) = (4,29)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, the output format must be exactly of the form\n$[r_1,r_2,\\dots,r_{13}]$\nwhere each $r_i \\in \\{-1,0,1\\}$ is the value of $\\left(\\frac{a}{p}\\right)$ for the corresponding test case in the order listed above. No additional text or formatting should be printed.", "solution": "The problem requires the design, implementation, and analysis of an iterative algorithm to compute the Legendre symbol $\\left(\\frac{a}{p}\\right)$ for an integer $a$ and an odd prime $p$. The algorithm must be based solely on the properties of the Legendre symbol, namely the law of quadratic reciprocity and its two supplementary laws.\n\nThe Legendre symbol $\\left(\\frac{a}{p}\\right)$ is defined for an integer $a$ and an odd prime $p$. Its value is $1$ if $a$ is a quadratic residue modulo $p$ and $a \\not\\equiv 0 \\pmod p$; $-1$ if $a$ is a quadratic non-residue modulo $p$; and $0$ if $a \\equiv 0 \\pmod p$.\n\nThe algorithm relies on the following foundational properties:\n$1.$ If $a \\equiv b \\pmod p$, then $\\left(\\frac{a}{p}\\right) = \\left(\\frac{b}{p}\\right)$.\n$2.$ $\\left(\\frac{ab}{p}\\right) = \\left(\\frac{a}{p}\\right)\\left(\\frac{b}{p}\\right)$ (multiplicativity).\n$3.$ First Supplementary Law: $\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}}$. This is $1$ if $p \\equiv 1 \\pmod 4$ and $-1$ if $p \\equiv 3 \\pmod 4$.\n$4.$ Second Supplementary Law: $\\left(\\frac{2}{p}\\right) = (-1)^{\\frac{p^2-1}{8}}$. This is $1$ if $p \\equiv 1, 7 \\pmod 8$ and $-1$ if $p \\equiv 3, 5 \\pmod 8$.\n$5.$ Law of Quadratic Reciprocity: For distinct odd primes $p$ and $q$, $\\left(\\frac{p}{q}\\right) = \\left(\\frac{q}{p}\\right)(-1)^{\\frac{p-1}{2}\\frac{q-1}{2}}$. The sign factor is $-1$ if and only if both $p$ and $q$ are congruent to $3$ modulo $4$. This law can be extended via the Jacobi symbol to hold for any pair of odd integers $p, q > 1$.\n\n### $1.$ Algorithm Specification\n\nThe algorithm computes $\\left(\\frac{a}{p}\\right)$ by iteratively reducing the pair $(a, p)$ to a simpler pair while keeping track of a sign multiplier. Let the state of the computation be represented by the triplet $(k, n, d)$, where we seek to compute the value $k \\cdot \\left(\\frac{n}{d}\\right)$. Initially, this state is $(1, a, p)$. The algorithm terminates when $n$ becomes $0$ or $1$.\n\n**Initialization:**\n$1.$ Set the initial accumulated sign $k = 1$.\n$2.$ The initial numerator is the input integer $a$. The initial denominator is the odd prime $p$.\n$3.$ Apply the property $\\left(\\frac{a}{p}\\right) = \\left(\\frac{a \\pmod p}{p}\\right)$. Replace $a$ with $a \\pmod p$. After this step, we have $0 \\le a < p$.\n\n**Iteration:**\nThe core of the algorithm is a loop that continues as long as $a \\neq 0$.\n\n**Step $1$: Base Cases.**\n- If $a = 0$, the Legendre symbol is $0$. The algorithm terminates and returns $0$.\n- If $a = 1$, the symbol is $1$. The value is determined by the accumulated sign $k$. The algorithm terminates and returns $k$.\n\n**Step $2$: Factoring out powers of $2$.**\nThe numerator $a$ is factored into $a = 2^s \\cdot m$, where $m$ is odd. Using multiplicativity, we have $\\left(\\frac{a}{p}\\right) = \\left(\\frac{2^s m}{p}\\right) = \\left(\\frac{2}{p}\\right)^s \\left(\\frac{m}{p}\\right)$.\n- Find the number of factors of $2$ in $a$. Let this be $s$.\n- If $s$ is odd, the accumulated sign $k$ must be multiplied by $\\left(\\frac{2}{p}\\right) = (-1)^{\\frac{p^2-1}{8}}$. This is equivalent to flipping the sign of $k$ if $p \\equiv 3 \\pmod 8$ or $p \\equiv 5 \\pmod 8$.\n- After accounting for the sign change, replace $a$ with its odd part, $m$.\n- After this step, $a$ is odd. We must re-check the base case $a=1$, as the original $a$ could have been a power of $2$. If $a=1$, terminate and return the current sign $k$.\n\n**Step $3$: Applying Quadratic Reciprocity.**\nAt this point, $a$ is an odd integer such that $1 < a < p$.\n- We have $\\left(\\frac{a}{p}\\right) = \\left(\\frac{p}{a}\\right) (-1)^{\\frac{a-1}{2}\\frac{p-1}{2}}$.\n- The sign $k$ is updated by multiplying it by the reciprocity factor $(-1)^{\\frac{a-1}{2}\\frac{p-1}{2}}$. This is equivalent to flipping the sign of $k$ if and only if both $a \\equiv 3 \\pmod 4$ and $p \\equiv 3 \\pmod 4$.\n- The problem of computing $\\left(\\frac{a}{p}\\right)$ is swapped for computing $\\left(\\frac{p}{a}\\right)$. The roles of numerator and denominator are interchanged.\n- The new pair becomes $(p, a)$. To continue the iteration in a manner that ensures termination, we reduce the new numerator modulo the new denominator. The new state for the next iteration is defined by the pair $(p \\pmod a, a)$. So we set the new $a$ to be $p \\pmod a$ and the new $p$ to be the old $a$. The loop then continues from Step $1$.\n\n### $2.$ Proof of Termination\n\nThe algorithm's termination is guaranteed by the fact that one of the integer arguments strictly decreases at each reciprocity step.\n\nLet the pair of integers being processed at the start of an iteration of the main loop be $(a_i, p_i)$.\n$1.$ The initial step reduces the input $a_{in}$ to $a_0 = a_{in} \\pmod p$, so $0 \\le a_0 < p$. The initial denominator is $p_0=p$.\n$2.$ Inside the loop, $a_i$ is first processed to extract factors of $2$, resulting in an odd integer $a'_i \\le a_i$. The denominator $p_i$ is unchanged.\n$3.$ The reciprocity step transforms the pair $(a'_i, p_i)$ into a new pair for the next iteration, $(a_{i+1}, p_{i+1})$, where $a_{i+1} = p_i \\pmod{a'_i}$ and $p_{i+1} = a'_i$.\n$4. $ Since $a'_i$ is odd and $1 < a'_i < p_i$ (if $a'_i > 1$), we have $0 \\le p_i \\pmod{a'_i} < a'_i$.\n$5.$ The sequence of denominators is $p_0, p_1, p_2, \\ldots$. From the update rule, $p_{i+1} = a'_i$. Since $a'_i \\le a_i < p_i$, we have $p_{i+1} < p_i$.\n$6.$ The sequence of denominators $\\{p_i\\}$ is a strictly decreasing sequence of positive integers.\n$7.$ Any strictly decreasing sequence of positive integers must be finite. It must eventually reach a state where the loop terminates. The loop terminates if $a_i$ becomes $0$ or $1$.\n\nThis argument structure is analogous to the proof of termination for the Euclidean algorithm. The values of the denominators form a strictly decreasing sequence of positive integers, which guarantees the process will end.\n\n### $3.$ Proof of Correctness\n\nThe correctness of the algorithm is established by showing that the value $V = k \\cdot \\left(\\frac{a}{p}\\right)$ is an invariant throughout the execution of the loop, where $k$ is the accumulated sign and $(a, p)$ is the current pair of numerator and denominator.\n\n**Initial State:**\nInitially, $k=1$, and the pair is $(a_{in}, p_{in})$. The first step computes $a_0 = a_{in} \\pmod{p_{in}}$. The invariant at this point is $V_0 = 1 \\cdot \\left(\\frac{a_0}{p_{in}}\\right)$. By the property of the Legendre symbol, $\\left(\\frac{a_{in}}{p_{in}}\\right) = \\left(\\frac{a_{in} \\pmod{p_{in}}}{p_{in}}\\right) = \\left(\\frac{a_0}{p_{in}}\\right)$. So the invariant holds. Note that this initial reduction correctly handles negative $a_{in}$ due to the definition of the modulo operator.\n\n**Loop Invariant:**\nLet the state at the beginning of an iteration be $(k_i, a_i, p_i)$, with the invariant value $V_i = k_i \\left(\\frac{a_i}{p_i}\\right)$.\n\n$1.$ **Factoring out $2$s:** Let $a_i = 2^s \\cdot m$, where $m$ is odd. The algorithm updates $k_{i+1} = k_i \\cdot \\left(\\frac{2}{p_i}\\right)^s$ and $a_{i+1} = m$. The denominator $p_{i+1} = p_i$ is unchanged for this step.\nThe new invariant value is $V_{i+1} = k_{i+1} \\left(\\frac{a_{i+1}}{p_{i+1}}\\right) = \\left(k_i \\cdot \\left(\\frac{2}{p_i}\\right)^s\\right) \\left(\\frac{m}{p_i}\\right) = k_i \\left(\\frac{2^s m}{p_i}\\right) = k_i \\left(\\frac{a_i}{p_i}\\right) = V_i$. The value is preserved.\n\n$2.$ **Reciprocity Step:** After factoring out $2$s, we have a state $(k_j, a_j, p_j)$ where $a_j$ is odd. The algorithm updates the sign to $k_{j+1} = k_j \\cdot (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}}$. It then sets the new pair for the next loop iteration to $(a_{j+1}, p_{j+1}) = (p_j \\pmod{a_j}, a_j)$. The value we want to preserve is $V_j = k_j \\left(\\frac{a_j}{p_j}\\right)$.\nBy the law of quadratic reciprocity, $\\left(\\frac{a_j}{p_j}\\right) = \\left(\\frac{p_j}{a_j}\\right) (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}}$.\nSo, $V_j = k_j \\left(\\frac{p_j}{a_j}\\right) (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}}$.\nThe value represented by the next state is $V_{next} = k_{j+1} \\left(\\frac{a_{j+1}}{p_{j+1}}\\right) = \\left( k_j (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}} \\right) \\left(\\frac{p_j \\pmod{a_j}}{a_j}\\right)$.\nUsing the property $\\left(\\frac{p_j \\pmod{a_j}}{a_j}\\right) = \\left(\\frac{p_j}{a_j}\\right)$, we have $V_{next} = k_j (-1)^{\\frac{a_j-1}{2}\\frac{p_j-1}{2}} \\left(\\frac{p_j}{a_j}\\right)$.\nThis is exactly equal to $V_j$. The invariant is preserved across the reciprocity step.\n\n**Termination:**\nThe algorithm terminates when $a$ becomes $0$ or $1$.\n- If $a=0$, the algorithm returns $0$. The invariant value at this point would be $k \\cdot \\left(\\frac{0}{p}\\right) = k \\cdot 0 = 0$. This is correct.\n- If $a=1$, the algorithm returns the accumulated sign $k$. The invariant value is $k \\cdot \\left(\\frac{1}{p}\\right) = k \\cdot 1 = k$. This is also correct.\n\nSince the invariant $V$ is preserved at every step of the algorithm and the final value computed at termination is correct, the initial value $\\left(\\frac{a}{p}\\right)$ is correctly computed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the Legendre symbol for a list of test cases.\n    \"\"\"\n\n    def legendre_symbol(a: int, p: int) -> int:\n        \"\"\"\n        Computes the Legendre symbol (a/p) using an iterative algorithm based\n        on quadratic reciprocity and supplementary laws.\n\n        Args:\n            a: An integer.\n            p: An odd prime number.\n\n        Returns:\n            The value of the Legendre symbol, which is -1, 0, or 1.\n        \"\"\"\n        if p <= 2 or p % 2 == 0:\n            raise ValueError(\"p must be an odd prime.\")\n            \n        # Step 1: Reduce a modulo p. This also handles negative a correctly,\n        # as a % p in Python for a<0 results in a number with the same sign as p.\n        # Since p is positive, the result is in [0, p-1].\n        # For example, -3 % 11 = 8. (a/p) = (a mod p / p).\n        a = a % p\n\n        # Initialize the accumulated sign.\n        sign = 1\n\n        # Main loop: continues until a is 0 or 1.\n        while a != 0:\n            # Base case: if a is 1, the result is the accumulated sign.\n            if a == 1:\n                return sign\n\n            # Step 2: Factor out powers of 2 from a.\n            # Let a = 2^k * m, where m is odd.\n            # (a/p) = (2^k * m / p) = (2/p)^k * (m/p).\n            k = 0\n            while a % 2 == 0:\n                a //= 2\n                k += 1\n\n            # Update sign based on the supplementary law for 2: (2/p) = (-1)^((p^2-1)/8).\n            # We multiply the sign by (2/p) for each factor of 2. An even number of\n            # factors has no effect. An odd number of factors contributes a (2/p) term.\n            if k % 2 == 1:\n                # (2/p) is -1 if p = 3 or 5 (mod 8).\n                p_mod_8 = p % 8\n                if p_mod_8 == 3 or p_mod_8 == 5:\n                    sign = -sign\n\n            # After removing factors of 2, a might be 1.\n            # E.g., if original a was 4, it becomes 1 here.\n            if a == 1:\n                return sign\n\n            # Step 3: Apply the Law of Quadratic Reciprocity.\n            # At this point, a is odd, and 1 < a < p.\n            # (a/p) = (p/a) * (-1)^(((a-1)/2)*((p-1)/2)).\n            # The sign factor is -1 iff both a and p are 3 (mod 4).\n            if (a % 4 == 3) and (p % 4 == 3):\n                sign = -sign\n\n            # Swap roles and reduce. The task to compute (a/p) is replaced\n            # by computing (p/a), which is equivalent to (p mod a / a).\n            # This is the core of the reduction, similar to the Euclidean algorithm.\n            old_a = a\n            a = p % old_a\n            p = old_a\n        \n        # If the loop terminates because a is 0, then the original a was a multiple of p.\n        return 0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 3),\n        (1, 5),\n        (2, 7),\n        (10, 11),\n        (-3, 11),\n        (22, 11),\n        (1024, 17),\n        (123456789, 31),\n        (97, 13),\n        (45, 23),\n        (2, 3),\n        (8, 5),\n        (4, 29),\n    ]\n\n    results = []\n    for a, p in test_cases:\n        result = legendre_symbol(a, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}