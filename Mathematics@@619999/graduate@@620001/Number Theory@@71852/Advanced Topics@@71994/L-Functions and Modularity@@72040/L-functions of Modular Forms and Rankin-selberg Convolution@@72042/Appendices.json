{"hands_on_practices": [{"introduction": "The arithmetic soul of an L-function associated with a Hecke eigenform is its Euler product decomposition, which translates the action of Hecke operators into a product over primes. The structure of each local factor, $L_p(s,f)$, depends critically on whether the prime $p$ divides the level $N$ of the form. This exercise ([@problem_id:3016760]) provides essential practice in applying the foundational rules for constructing these local factors for a newform, distinguishing between primes of good and bad reduction.", "problem": "Let $f$ be the unique normalized newform in the space of weight $2$ cusp forms $S_{2}(\\Gamma_{0}(11))$ with trivial nebentypus, so that $a_{1}=1$ and the Hecke operators act diagonally on $f$. Denote by $a_{n}$ the $n$-th Fourier coefficient of $f$, and let $L(s,f)=\\sum_{n\\geq 1}a_{n}n^{-s}$ be its standard Dirichlet series. It is known that $a_{2}=-2$ and that the eigenvalue of the Atkin–Lehner operator at $p=11$ (equivalently, the $U_{11}$-eigenvalue in the new subspace) is $a_{11}=-1$, and that the level $N=11$ is squarefree.\n\nUsing only the axiomatic Euler product decomposition induced by Hecke multiplicativity at primes not dividing the level and the local classification at primes dividing the level, determine the local Euler factors $L_{2}(s,f)$ and $L_{11}(s,f)$ as functions of the complex variable $s$. Express your final answer as a row matrix whose first entry is $L_{2}(s,f)$ and whose second entry is $L_{11}(s,f)$, in exact symbolic form.", "solution": "The problem is first subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\nThe explicit data and definitions provided in the problem statement are:\n-   $f$: The unique normalized newform in the space of weight $2$ cusp forms $S_{2}(\\Gamma_{0}(11))$.\n-   Nebentypus: Trivial.\n-   Weight: $k=2$.\n-   Level: $N=11$.\n-   Normalization: The first Fourier coefficient is $a_{1}=1$.\n-   $f$ is a Hecke eigenform.\n-   $a_{n}$: The $n$-th Fourier coefficient of $f$.\n-   $L(s,f) = \\sum_{n\\geq 1} a_{n}n^{-s}$: The standard L-function (Dirichlet series) of $f$.\n-   Fourier coefficient at prime $2$: $a_{2}=-2$.\n-   Fourier coefficient at prime $11$: $a_{11}=-1$. This is specified as the eigenvalue of the $U_{11}$ operator.\n-   The level $N=11$ is squarefree.\n-   Objective: Determine the local Euler factors $L_{2}(s,f)$ and $L_{11}(s,f)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed based on the established criteria.\n-   **Scientifically Grounded:** The problem is firmly rooted in the theory of modular forms and L-functions, a central topic in number theory. The existence and uniqueness of a normalized newform in $S_{2}(\\Gamma_{0}(11))$ is a standard result; the dimension of this space is $1$. The concepts of Hecke operators, Euler products, and local factors are all fundamental to the field. The provided values for $a_2$ and $a_{11}$ are consistent with the known properties of the specific modular form associated with the elliptic curve $y^2+y = x^3-x^2-10x-20$, which has conductor $11$.\n-   **Well-Posed:** The problem provides all necessary information—weight, level, and the relevant Fourier coefficients—to uniquely determine the requested local factors. The question is precise and has a unique, stable solution based on established theory.\n-   **Objective:** The problem is stated using precise, unambiguous mathematical terminology. There are no subjective or opinion-based elements.\n-   **Completeness and Consistency:** The problem is self-contained. The data provided are sufficient and not contradictory. For instance, the property that $N=11$ is squarefree is crucial for determining the form of the local factor at $p=11$.\n-   **Other Flaws:** The problem does not violate any other validation criteria. It is not trivial, metaphorical, or unverifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be derived.\n\n### Solution Derivation\n\nThe L-function $L(s,f)$ associated with a newform $f$ that is an eigenform for all Hecke operators admits an Euler product decomposition over all prime numbers $p$:\n$$L(s,f) = \\prod_{p} L_{p}(s,f)$$\nThe functional form of the local Euler factor $L_{p}(s,f)$ depends on whether the prime $p$ divides the level $N$. We analyze the two required cases separately.\n\n**Case 1: Local Factor at a prime $p$ not dividing the level $N$**\n\nFor a prime $p$ such that $p \\nmid N$, the local Euler factor for a newform $f$ of weight $k$ and trivial nebentypus is given by a quadratic polynomial in $p^{-s}$:\n$$L_{p}(s,f) = \\left(1 - a_{p} p^{-s} + p^{k-1-2s}\\right)^{-1}$$\nIn this problem, the weight is $k=2$. The formula simplifies to:\n$$L_{p}(s,f) = \\left(1 - a_{p} p^{-s} + p^{2-1-2s}\\right)^{-1} = \\left(1 - a_{p} p^{-s} + p^{1-2s}\\right)^{-1}$$\nWe need to determine $L_{2}(s,f)$. The level is $N=11$, and since $2$ does not divide $11$, this case applies. We are given the Fourier coefficient $a_{2}=-2$.\nSubstituting $p=2$ and $a_{2}=-2$ into the formula yields:\n$$L_{2}(s,f) = \\left(1 - (-2) \\cdot 2^{-s} + 2^{1-2s}\\right)^{-1}$$\n$$L_{2}(s,f) = \\left(1 + 2 \\cdot 2^{-s} + 2^{1-2s}\\right)^{-1}$$\n\n**Case 2: Local Factor at a prime $p$ dividing the level $N$**\n\nFor a prime $p$ that divides a squarefree level $N$, the local Euler factor for a newform $f$ is given by a linear polynomial in $p^{-s}$:\n$$L_{p}(s,f) = \\left(1 - a_{p} p^{-s}\\right)^{-1}$$\nHere, the coefficient $a_p$ is the eigenvalue of the Hecke operator $U_p$ acting on the newform $f$, i.e., $U_p(f) = a_p f$.\nWe need to determine $L_{11}(s,f)$. The level is $N=11$, so the prime $p=11$ divides the level. Since $N=11$ is squarefree, this case applies. The problem statement provides that the $U_{11}$-eigenvalue is $a_{11}=-1$.\nSubstituting $p=11$ and $a_{11}=-1$ into the formula yields:\n$$L_{11}(s,f) = \\left(1 - (-1) \\cdot 11^{-s}\\right)^{-1}$$\n$$L_{11}(s,f) = \\left(1 + 11^{-s}\\right)^{-1}$$\n\nThe two requested local Euler factors are therefore determined.\n$L_{2}(s,f) = \\left(1 + 2 \\cdot 2^{-s} + 2^{1-2s}\\right)^{-1}$\n$L_{11}(s,f) = \\left(1 + 11^{-s}\\right)^{-1}$\nThe final answer is presented as a row matrix containing these two expressions.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left(1 + 2 \\cdot 2^{-s} + 2^{1-2s}\\right)^{-1} & \\left(1 + 11^{-s}\\right)^{-1}\n\\end{pmatrix}\n}\n$$", "id": "3016760"}, {"introduction": "While the Euler product reveals the arithmetic data encoded in an L-function, its profound analytic properties—namely, its analytic continuation and functional equation—are revealed by studying its completed version. This exercise ([@problem_id:3016800]) demonstrates the pivotal connection between a modular form and its L-function via the Mellin transform. By performing this integral transformation, you will derive the crucial archimedean \"gamma factor\" that is essential for formulating the functional equation.", "problem": "Let $\\Delta(z)$ denote the Ramanujan cusp form, the normalized holomorphic cusp form of weight $12$ for the full modular group $\\mathrm{SL}_{2}(\\mathbb{Z})$, with Fourier expansion\n$$\n\\Delta(z) \\;=\\; \\sum_{n=1}^{\\infty} \\tau(n)\\,\\exp(2\\pi i n z),\n$$\nwhere $\\tau(n)$ are its Fourier coefficients. Define the Dirichlet series (the $L$-function attached to $\\Delta$) by\n$$\nL(s,\\Delta) \\;=\\; \\sum_{n=1}^{\\infty} \\frac{\\tau(n)}{n^{s}},\n$$\nfor complex $s$ in a half-plane where the series converges. Consider the Mellin transform\n$$\nM(s) \\;=\\; \\int_{0}^{\\infty} \\Delta(iy)\\,y^{s-1}\\,dy,\n$$\nfor $\\Re(s)$ sufficiently large to justify termwise integration and absolute convergence. Starting only from the definitions above and the integral characterization of the Euler gamma function\n$$\n\\Gamma(s) \\;=\\; \\int_{0}^{\\infty} \\exp(-t)\\,t^{s-1}\\,dt \\quad\\text{for}\\quad \\Re(s)>0,\n$$\nevaluate $M(s)$ as a single closed-form analytic expression in $s$ that explicitly exhibits the archimedean gamma factor expected in the completed $L$-function of $\\Delta$. Your final answer must be a single expression in $s$ written using standard special functions. Do not provide an inequality or an equation; provide the expression itself. No rounding is required.", "solution": "The problem asks for the evaluation of the Mellin transform $M(s)$ of the Ramanujan cusp form $\\Delta(z)$ evaluated along the imaginary axis. The givens are:\nThe Ramanujan cusp form $\\Delta(z)$ with its Fourier expansion:\n$$ \\Delta(z) = \\sum_{n=1}^{\\infty} \\tau(n)\\,\\exp(2\\pi i n z) $$\nThe L-function associated with $\\Delta(z)$:\n$$ L(s,\\Delta) = \\sum_{n=1}^{\\infty} \\frac{\\tau(n)}{n^{s}} $$\nThe Mellin transform to be evaluated:\n$$ M(s) = \\int_{0}^{\\infty} \\Delta(iy)\\,y^{s-1}\\,dy $$\nAnd the integral definition of the Euler gamma function:\n$$ \\Gamma(s) = \\int_{0}^{\\infty} \\exp(-t)\\,t^{s-1}\\,dt $$\nThe problem states that the calculation is to be performed for values of the complex variable $s$ where $\\Re(s)$ is sufficiently large to ensure all operations, particularly the interchange of summation and integration, are justified by absolute convergence.\n\nWe begin by substituting the Fourier expansion of $\\Delta(z)$ into the definition of the Mellin transform $M(s)$. We evaluate $\\Delta(z)$ at $z = iy$ for $y > 0$:\n$$ \\Delta(iy) = \\sum_{n=1}^{\\infty} \\tau(n)\\,\\exp(2\\pi i n (iy)) = \\sum_{n=1}^{\\infty} \\tau(n)\\,\\exp(-2\\pi n y) $$\nSubstituting this series into the integral for $M(s)$:\n$$ M(s) = \\int_{0}^{\\infty} \\left( \\sum_{n=1}^{\\infty} \\tau(n)\\,\\exp(-2\\pi n y) \\right) y^{s-1}\\,dy $$\nAs stipulated by the problem statement, we assume $\\Re(s)$ is large enough to justify the interchange of the summation and the integral. This is permissible due to the absolute convergence of the series and the integral in the specified domain. Performing the interchange yields:\n$$ M(s) = \\sum_{n=1}^{\\infty} \\tau(n) \\int_{0}^{\\infty} \\exp(-2\\pi n y)\\,y^{s-1}\\,dy $$\nNow, we focus on evaluating the integral for each term in the series. Let the integral be denoted by $I_n(s)$:\n$$ I_n(s) = \\int_{0}^{\\infty} \\exp(-2\\pi n y)\\,y^{s-1}\\,dy $$\nTo relate this to the definition of the Gamma function, we perform a change of variables. Let $t = 2\\pi n y$. This implies $y = \\frac{t}{2\\pi n}$, and the differential is $dy = \\frac{1}{2\\pi n} dt$. The limits of integration for $t$ are from $2\\pi n(0) = 0$ to $\\lim_{y\\to\\infty} 2\\pi n y = \\infty$, so the integration range remains $(0, \\infty)$.\nSubstituting these into the integral $I_n(s)$:\n$$ I_n(s) = \\int_{0}^{\\infty} \\exp(-t) \\left(\\frac{t}{2\\pi n}\\right)^{s-1} \\left(\\frac{1}{2\\pi n}\\right) dt $$\nWe can factor out the terms that do not depend on the integration variable $t$:\n$$ I_n(s) = \\left(\\frac{1}{2\\pi n}\\right)^{s-1} \\left(\\frac{1}{2\\pi n}\\right) \\int_{0}^{\\infty} \\exp(-t)\\,t^{s-1}\\,dt $$\n$$ I_n(s) = \\left(\\frac{1}{2\\pi n}\\right)^{s} \\int_{0}^{\\infty} \\exp(-t)\\,t^{s-1}\\,dt $$\nThe remaining integral is precisely the definition of the Euler gamma function, $\\Gamma(s)$. Therefore,\n$$ I_n(s) = \\left(\\frac{1}{2\\pi n}\\right)^{s} \\Gamma(s) = (2\\pi)^{-s} n^{-s} \\Gamma(s) $$\nNow, we substitute this result back into the expression for $M(s)$:\n$$ M(s) = \\sum_{n=1}^{\\infty} \\tau(n) \\left[ (2\\pi)^{-s} n^{-s} \\Gamma(s) \\right] $$\nWe can factor the terms $(2\\pi)^{-s}$ and $\\Gamma(s)$ out of the summation, as they are independent of the index $n$:\n$$ M(s) = (2\\pi)^{-s} \\Gamma(s) \\sum_{n=1}^{\\infty} \\tau(n) n^{-s} $$\nThe remaining summation is, by definition, the L-function associated with the cusp form $\\Delta(z)$:\n$$ \\sum_{n=1}^{\\infty} \\frac{\\tau(n)}{n^{s}} = L(s,\\Delta) $$\nThus, the Mellin transform $M(s)$ is given by the expression:\n$$ M(s) = (2\\pi)^{-s} \\Gamma(s) L(s,\\Delta) $$\nThis expression is the completed L-function, often denoted $\\Lambda(s, \\Delta)$. It is an analytic function of $s$ and explicitly contains the factor $(2\\pi)^{-s} \\Gamma(s)$, which is the archimedean gamma factor associated with the L-function of a modular form of weight $k=12$ (where the general factor is $(2\\pi)^{-s}\\Gamma(s)$). The expression is considered a closed form in the context of analytic number theory, where L-functions are standard special functions.", "answer": "$$\\boxed{(2\\pi)^{-s} \\Gamma(s) L(s,\\Delta)}$$", "id": "3016800"}, {"introduction": "The true power of the functional equation becomes apparent when we wish to study the L-function inside its critical strip, where the defining Dirichlet series fails to converge. A prime example is the central value $L(k/2, f)$, a number that conjecturally holds deep arithmetic secrets. This advanced exercise ([@problem_id:3016774]) guides you through the implementation of the \"approximate functional equation,\" a sophisticated computational tool derived directly from the functional equation, to calculate an accurate approximation of $L(1/2,f)$ for a specific modular form.", "problem": "Let $f$ be the unique normalized newform in the cusp form space $S_{2}(\\Gamma_{0}(11))$, equivalently the modular form attached to the elliptic curve $E \\colon y^{2} + y = x^{3} - x^{2}$ over the rational numbers. Let $a_{n}$ denote its Hecke eigenvalues, so that the $L$-function is defined for complex $s$ with $\\operatorname{Re}(s) > 1$ by the Dirichlet series $L(s,f) = \\sum_{n \\geq 1} a_{n} n^{-s}$, and admits analytic continuation to all complex $s$. The completed $L$-function is given by the standard formula for weight $2$:\n$$\n\\Lambda(s,f) = N^{s/2} (2\\pi)^{-s} \\Gamma(s) L(s,f),\n$$\nwhere $N=11$ is the conductor and $\\Gamma(s)$ is the Euler gamma function. This completed $L$-function satisfies the functional equation $\\Lambda(s,f) = \\varepsilon \\Lambda(2-s,f)$, with global root number $\\varepsilon \\in \\{+1,-1\\}$. For the specific newform $f$ above, assume $\\varepsilon = +1$.\n\nFundamental base facts to use:\n- The Hecke eigenvalues $a_{n}$ are multiplicative and satisfy the prime-power recurrence for primes $p \\nmid N$: $a_{p^{m+1}} = a_{p} a_{p^{m}} - p a_{p^{m-1}}$ for $m \\geq 1$, with $a_{1}=1$. For primes $p \\mid N$ with multiplicative reduction, one has $a_{p^{m}} = a_{p}^{m}$.\n- For primes $p \\nmid N$, $a_{p} = p+1 - \\#E(\\mathbb{F}_{p})$, where $\\#E(\\mathbb{F}_{p})$ is the number of $\\mathbb{F}_{p}$-points on the reduction of $E$ modulo $p$ including the point at infinity.\n- For $E \\colon y^{2} + y = x^{3} - x^{2}$ and an odd prime $p$, the number of $y$ for a given $x \\in \\mathbb{F}_{p}$ solving $y^{2} + y = r$ with $r = x^{3} - x^{2}$ equals $1 + \\chi_{p}(1 + 4r)$, where $\\chi_{p}$ is the quadratic character (the Legendre symbol) modulo $p$; for $p=2$, count solutions directly.\n\nTask:\n- Starting from the functional equation and the Mellin transform representation of $\\Gamma(s)$, derive and implement a numerically stable approximate functional equation to compute $L(1/2,f)$. Use smooth weights obtained by splitting the gamma integral, which leads to normalized upper incomplete gamma weights. Let the smooth weight for the first sum be $W_{s}(z)$ and for the dual sum be $W_{2-s}(z)$, chosen as the normalized upper incomplete gamma function with an argument scaled by the analytic conductor. Concretely, take\n$$\nW_{s}\\!\\left(\\frac{n}{A}\\right) = \\frac{\\Gamma\\!\\big(s, 2\\pi \\frac{n}{A}\\big)}{\\Gamma(s)}, \\qquad W_{2-s}\\!\\left(\\frac{n}{A}\\right) = \\frac{\\Gamma\\!\\big(2-s, 2\\pi \\frac{n}{A}\\big)}{\\Gamma(2-s)},\n$$\nwhere $\\Gamma(s,z)$ denotes the upper incomplete gamma function and $A$ is a positive scaling parameter proportional to the square root of the conductor.\n- Express $L(1/2,f)$ as the sum of two truncated, smoothly weighted series whose lengths are determined by a truncation parameter $M$ and a scale $A$. Let $M = \\lceil c \\sqrt{N} \\rceil$ for a given positive real $c$, and let $A = \\alpha \\sqrt{N}$ for a given positive real $\\alpha$. Implement the following numerical approximation:\n$$\nL\\!\\left(\\tfrac{1}{2},f\\right) \\approx \\sum_{n=1}^{M} a_{n} n^{-1/2} W_{1/2}\\!\\left(\\tfrac{n}{A}\\right) \\;+\\; X\\!\\left(\\tfrac{1}{2}\\right) \\sum_{n=1}^{M} a_{n} n^{-3/2} W_{3/2}\\!\\left(\\tfrac{n}{A}\\right),\n$$\nwhere\n$$\nX(s) = \\varepsilon \\, N^{1 - s} (2\\pi)^{2s - 2} \\frac{\\Gamma(2 - s)}{\\Gamma(s)}.\n$$\n- Compute the coefficients $a_{n}$ needed up to $n \\leq M$ using the rules above, with $a_{11} = -1$ for the bad prime and $a_{p} = p+1 - \\#E(\\mathbb{F}_{p})$ for $p \\neq 11$, and $a_{p^{m}}$ determined by the recurrence relations. Ensure that the counting of $\\#E(\\mathbb{F}_{p})$ for odd primes $p$ uses the quadratic character criterion per $x \\in \\mathbb{F}_{p}$, and for $p=2$ uses direct enumeration over $\\mathbb{F}_{2}$.\n- For numerical stability, use floating-point arithmetic with the normalized upper incomplete gamma function to define the smooth weights, and the Euler gamma function for $X(s)$.\n\nTest suite:\n- Use the following parameter pairs $(c,\\alpha)$:\n    1. $(4.0, 1.0)$ as a general case,\n    2. $(1.0, 1.0)$ as a boundary case with minimal truncation,\n    3. $(8.0, 1.0)$ as a longer truncation case,\n    4. $(4.0, 0.5)$ as a case probing sensitivity to the scale in the weight.\nFor each case, set $M = \\lceil c \\sqrt{N} \\rceil$ and $A = \\alpha \\sqrt{N}$ with $N=11$, and compute the approximation to $L(1/2,f)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each entry corresponding to a test case should itself be a list of the form $[L\\_{{\\rm approx}},M,A]$ where $L\\_{{\\rm approx}}$ is a floating-point number, $M$ is an integer, and $A$ is a floating-point number. For example: $[[0.123,5,3.31662479],[\\dots]]$.\n\nNo physical units are involved. Angles are not applicable. Express all numerical answers as plain decimal numbers. The computation must be fully self-contained and based only on the mathematical principles and definitions stated above.", "solution": "The user wants to compute an approximation for the central value $L(1/2,f)$ of the L-function associated with the modular form $f$ corresponding to the elliptic curve $E: y^2+y=x^3-x^2$. The conductor of this curve is $N=11$. The problem provides a specific formula for this approximation, which is a variant of the approximate functional equation.\n\nThe solution requires three main components:\n1.  A method to compute the Hecke eigenvalues $a_n$ for $n$ up to a certain limit $M$.\n2.  An implementation of the special functions involved, namely the normalized upper incomplete gamma function $W_s(z) = \\Gamma(s, 2\\pi z) / \\Gamma(s)$.\n3.  The evaluation of the given approximation formula using the computed coefficients and functions for a specified set of parameters.\n\n**Step 1: Computation of Hecke Eigenvalues $a_n$**\n\nThe Hecke eigenvalues $a_n$ are multiplicative, meaning if $n=mk$ with $\\gcd(m,k)=1$, then $a_n = a_m a_k$. This property allows us to compute $a_n$ for any $n$ if we know the values for prime powers, $a_{p^k}$.\n\nThe problem provides the rules for computing $a_{p^k}$:\n-   For the prime of bad reduction $p=11$, we are given $a_{11}=-1$. The reduction is multiplicative, so $a_{11^k} = (a_{11})^k = (-1)^k$.\n-   For primes $p \\neq 11$ (good reduction), the value $a_p$ is determined by the number of points on the elliptic curve over the finite field $\\mathbb{F}_p$: $a_p = p+1 - \\#E(\\mathbb{F}_p)$.\n    -   For $p=2$, a direct point counting on $y^2+y=x^3-x^2$ over $\\mathbb{F}_2$ is performed.\n        -   For $x=0$, $y^2+y=0 \\implies y(y+1)=0$, giving solutions $y=0,1$.\n        -   For $x=1$, $y^2+y=1^3-1^2=0$, also giving $y=0,1$.\n        -   This yields $4$ affine points. Including the point at infinity, $\\#E(\\mathbb{F}_2)=5$. Thus, $a_2 = 2+1-5=-2$.\n    -   For an odd prime $p$, the number of solutions for $y$ to $y^2+y=r$ is $1+\\chi_p(1+4r)$, where $\\chi_p$ is the Legendre symbol. Summing over all $x \\in \\mathbb{F}_p$ for $r=x^3-x^2$ and adding the point at infinity gives $\\#E(\\mathbb{F}_p)$. This leads to the formula $a_p = -\\sum_{x \\in \\mathbb{F}_p} \\chi_p(1+4(x^3-x^2))$.\n-   For prime powers $p^k$ with $p \\neq 11$ and $k \\geq 2$, the eigenvalues satisfy the recurrence relation: $a_{p^k} = a_p a_{p^{k-1}} - p a_{p^{k-2}}$, starting with $a_{p^0}=a_1=1$ and $a_{p^1}=a_p$.\n\nTo efficiently compute all $a_n$ up to a limit $M$, we employ a sieve-like method:\n1.  Use a sieve to find the smallest prime factor (SPF) for all integers up to $M$. This also identifies all primes up to $M$.\n2.  Iterate through primes $p \\le M$. Compute and store $a_p$ using the appropriate formula. Then, use the recurrence relation to compute and store $a_{p^k}$ for all powers $p^k \\le M$.\n3.  Iterate through all integers $n$ from $2$ to $M$. If $a_n$ has not been computed (i.e., $n$ is not a prime power), use the SPF of $n$ to find its prime factorization $n=p^k \\cdot m$ where $p^k$ is the highest power of $p$ dividing $n$. Then use multiplicativity $a_n = a_{p^k} a_m$. Since $m<n$, $a_m$ will have already been computed.\n\n**Step 2: Implementation of the Approximate Functional Equation**\n\nThe problem specifies the numerical approximation formula for $L(1/2, f)$:\n$$ L(\\tfrac{1}{2},f) \\approx \\sum_{n=1}^{M} a_n n^{-1/2} W_{1/2}\\!\\left(\\tfrac{n}{A}\\right) + X(\\tfrac{1}{2}) \\sum_{n=1}^{M} a_n n^{-3/2} W_{3/2}\\!\\left(\\tfrac{n}{A}\\right) $$\nThe parameters $M$ and $A$ are given by $M = \\lceil c \\sqrt{N} \\rceil$ and $A = \\alpha \\sqrt{N}$ for pairs of $(c, \\alpha)$.\n\nThe factor $X(s)$ is given by $X(s) = \\varepsilon N^{1-s} (2\\pi)^{2s-2} \\frac{\\Gamma(2-s)}{\\Gamma(s)}$.\nFor $s=1/2$, with $\\varepsilon=+1$ and $N=11$:\n$X(\\tfrac{1}{2}) = (+1) \\cdot 11^{1/2} \\cdot (2\\pi)^{-1} \\cdot \\frac{\\Gamma(3/2)}{\\Gamma(1/2)}$.\nUsing $\\Gamma(z+1) = z\\Gamma(z)$, we have $\\Gamma(3/2) = \\frac{1}{2}\\Gamma(1/2)$.\nTherefore, $X(\\tfrac{1}{2}) = \\sqrt{11} \\frac{1}{2\\pi} \\frac{1}{2} = \\frac{\\sqrt{11}}{4\\pi}$.\n\nThe smooth weight function $W_s(z)$ is defined as the normalized upper incomplete gamma function:\n$$ W_s(z) = \\frac{\\Gamma(s, 2\\pi z)}{\\Gamma(s)} $$\nThis function is available in `scipy.special` as `gammaincc(s, x)`, which computes $\\Gamma(s,x)/\\Gamma(s)$. Thus, the weight needed is $W_s(n/A) = \\text{gammaincc}(s, 2\\pi n / A)$.\n\n**Step 3: Numerical Evaluation**\n\nThe overall algorithm proceeds as follows:\n1.  Determine the maximum value of $M$ required across all test cases.\n2.  Pre-compute all Hecke eigenvalues $a_n$ up to this maximum $M$.\n3.  For each test case pair $(c, \\alpha)$:\n    a. Calculate the specific values of $M = \\lceil c \\sqrt{11} \\rceil$ and $A = \\alpha \\sqrt{11}$.\n    b. Initialize two sums, one for the main term and one for the dual term.\n    c. Loop from $n=1$ to $M$:\n        i. Retrieve the pre-computed value of $a_n$.\n        ii. Calculate the term for the first sum: $a_n n^{-1/2} \\cdot \\text{gammaincc}(1/2, 2\\pi n/A)$.\n        iii. Calculate the term for the second sum: $a_n n^{-3/2} \\cdot \\text{gammaincc}(3/2, 2\\pi n/A)$.\n        iv. Add each to its respective running sum.\n    d. Combine the sums: $L_{\\text{approx}} = \\text{sum}_1 + X(\\frac{1}{2}) \\cdot \\text{sum}_2$.\n    e. Store the resulting triplet $[L_{\\text{approx}}, M, A]$.\n4.  Finally, format the collected results into a single string as specified in the problem description, ensuring no extraneous characters or spaces.\n\nThis structured approach ensures correctness by separating the distinct mathematical tasks and implementing them robustly, leveraging efficient algorithms for coefficient generation and standard scientific libraries for special functions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaincc\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as per the statement.\n    It computes an approximation for L(1/2, f) for a set of parameters.\n    \"\"\"\n    N = 11\n\n    def legendre_symbol(a, p):\n        \"\"\"Computes the Legendre symbol (a/p) for an odd prime p.\"\"\"\n        if a % p == 0:\n            return 0\n        ls = pow(a, (p - 1) // 2, p)\n        if ls == p - 1:\n            return -1\n        return ls\n\n    ap_cache = {}\n    def get_ap(p):\n        \"\"\"Computes or retrieves from cache the Hecke eigenvalue a_p for a prime p.\"\"\"\n        if p in ap_cache:\n            return ap_cache[p]\n\n        if p == 2:\n            # For y^2+y = x^3-x^2 over F_2, #E(F_2) = 5.\n            # a_2 = 2 + 1 - 5 = -2\n            result = -2\n        elif p == N:\n            # Given value for the prime of bad reduction\n            result = -1\n        else:\n            # For odd primes p != N, use a_p = -sum_{x in F_p} chi_p(1 + 4(x^3 - x^2))\n            s = 0\n            for x in range(p):\n                # Calculations are modulo p\n                r = (pow(x, 3, p) - pow(x, 2, p) + p) % p\n                val = (1 + 4 * r) % p\n                s += legendre_symbol(val, p)\n            result = -s\n        \n        ap_cache[p] = result\n        return result\n\n    def compute_an(limit):\n        \"\"\"Computes Hecke eigenvalues a_n for n up to limit.\"\"\"\n        if limit < 1:\n            return np.array([])\n\n        an = np.zeros(limit + 1, dtype=np.int64)\n        spf = np.arange(limit + 1)\n        an[1] = 1\n\n        # Sieve to find smallest prime factors\n        for i in range(2, int(np.sqrt(limit)) + 1):\n            if spf[i] == i:\n                for j in range(i * i, limit + 1, i):\n                    if spf[j] == j:\n                        spf[j] = i\n        \n        # Compute a_{p^k}\n        for p in range(2, limit + 1):\n            if spf[p] == p: # p is a prime\n                ap = get_ap(p)\n                an[p] = ap\n                \n                if p > limit / p: continue\n\n                # Recurrence: a_{p^k} = a_p*a_{p^{k-1}} - p*a_{p^{k-2}}\n                # k=2\n                pk = p * p\n                if p == N:\n                    an[pk] = ap * ap\n                else:\n                    an[pk] = ap * ap - p * 1 # a_1=1\n                \n                # k > 2\n                pk_prev = pk # p^2\n                pk_prev_val = an[p] # a_p\n                pk_curr_val = an[pk] # a_{p^2}\n                \n                while pk <= limit / p:\n                    pk_next = pk * p\n                    if p == N:\n                        an[pk_next] = pk_curr_val * ap\n                    else:\n                        an[pk_next] = ap * pk_curr_val - p * pk_prev_val\n                    \n                    pk_prev_val = pk_curr_val\n                    pk_curr_val = an[pk_next]\n                    pk = pk_next\n\n        # Compute a_n for composite n using multiplicativity\n        for n in range(2, limit + 1):\n            if an[n] == 0:\n                p = int(spf[n])\n                pk = p\n                m = n // p\n                while m % p == 0:\n                    pk *= p\n                    m //= p\n                an[n] = an[pk] * an[m]\n        return an\n\n    def calculate_L_approx(an, M, A):\n        \"\"\"Computes the approximation of L(1/2, f) using the given formula.\"\"\"\n        X_half = np.sqrt(N) / (4 * np.pi)\n        \n        sum1 = 0.0\n        sum2 = 0.0\n        s1 = 0.5\n        s2 = 1.5\n\n        for n in range(1, M + 1):\n            weight_arg = (2 * np.pi * n) / A\n            \n            W1 = gammaincc(s1, weight_arg)\n            sum1 += an[n] * (n ** -s1) * W1\n            \n            W2 = gammaincc(s2, weight_arg)\n            sum2 += an[n] * (n ** -s2) * W2\n            \n        return sum1 + X_half * sum2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4.0, 1.0),\n        (1.0, 1.0),\n        (8.0, 1.0),\n        (4.0, 0.5),\n    ]\n\n    if not test_cases:\n        print(\"[]\")\n        return\n        \n    max_c = max(c for c, alpha in test_cases)\n    max_M = int(np.ceil(max_c * np.sqrt(N)))\n    \n    an = compute_an(max_M)\n\n    results = []\n    for c, alpha in test_cases:\n        M = int(np.ceil(c * np.sqrt(N)))\n        A = alpha * np.sqrt(N)\n        \n        L_approx = calculate_L_approx(an, M, A)\n        results.append([L_approx, M, A])\n        \n    # Final print statement in the exact required format.\n    output_parts = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in results]\n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3016774"}]}