{"hands_on_practices": [{"introduction": "To truly grasp the mechanics of Baker's Theorem, it is essential to work through a concrete example. This first exercise guides you through a direct, step-by-step application of an explicit bound, such as one derived from Matveev's work, to a simple linear form in two logarithms. By manually identifying and calculating each parameter—the field degree $D$, the absolute logarithmic heights $h(\\alpha_i)$, and the coefficient bound $B$—you will gain a tangible understanding of how these theoretical components combine to produce a quantitative result. [@problem_id:3008823]", "problem": "Let $K$ be the number field $\\mathbb{Q}$ and consider the linear form in logarithms $\\Lambda = \\ln 2 - 2 \\ln 3$. Using the absolute logarithmic Weil height on $\\mathbb{Q}$, and the general explicit lower bound provided by Matveev’s theorem for linear forms in logarithms of algebraic numbers, proceed as follows:\n\n- Identify the field degree $D = [K : \\mathbb{Q}]$.\n- Compute the absolute logarithmic heights $h(2)$ and $h(3)$.\n- Determine the quantities $|\\ln 2|$ and $|\\ln 3|$.\n- Set $B$ to be the maximum of the absolute values of the integer coefficients in the linear form.\n- From these, select the parameters $A_{1}$ and $A_{2}$ according to the standard hypothesis for Matveev’s bound (i.e., each $A_{i}$ must dominate the degree-weighted height, the absolute logarithm, and a fixed positive lower threshold).\n- Apply Matveev’s explicit bound for $|\\Lambda|$ with these choices, using the standard constant for two logarithms.\n\nYour task is to compute a concrete explicit lower bound for $|\\ln 2 - 2 \\ln 3|$ and present it as a single closed-form analytic expression. Do not simplify the linear form itself, and do not use any cancellation identities. Express the final bound using $\\ln$ for the natural logarithm. No rounding is required.", "solution": "The user has provided a problem requesting the computation of a lower bound for a linear form in logarithms using Matveev's theorem.\n\n### Step 1: Problem Validation\n\nThe problem statement asks for the application of a specific theorem from number theory (Matveev's theorem) to a given linear form in logarithms, $\\Lambda = \\ln 2 - 2 \\ln 3$.\n\n-   **Extraction of Givens:**\n    -   Number field: $K = \\mathbb{Q}$.\n    -   Linear form: $\\Lambda = \\ln 2 - 2 \\ln 3$.\n    -   Method: Matveev's theorem for linear forms in logarithms.\n    -   Height function: Absolute logarithmic Weil height, $h(\\cdot)$.\n    -   The problem provides a sequence of steps to follow: identify the degree $D$, compute heights $h(\\alpha_i)$, determine $|\\ln \\alpha_i|$, find the coefficient bound $B$, select parameters $A_i$, and apply the bound.\n\n-   **Validation Using Extracted Givens:**\n    1.  **Scientifically Grounded:** The problem is firmly rooted in transcendental number theory and involves the direct application of a major, established result (Matveev's theorem). The concepts of number fields, logarithmic heights, and linear forms in logarithms are standard in this domain.\n    2.  **Well-Posed:** The problem is well-posed. It provides a specific linear form, a defined context (the field $\\mathbb{Q}$), and a clear procedure for applying a specific theorem. The goal is to compute a single, concrete value (an analytic expression for the bound). The condition $\\Lambda \\neq 0$ is essential for the non-triviality of the bound and is satisfied, as $\\ln 2 - 2 \\ln 3 = \\ln (2/9) \\neq \\ln 1 = 0$.\n    3.  **Objective:** The problem is stated in precise, objective, and formal mathematical language.\n    4.  **Completeness:** The problem is self-contained. It specifies all necessary components: the numbers, the coefficients, the field, and the theorem to be used. While the phrase \"the standard constant for two logarithms\" could be seen as slightly ambiguous, a reasonable interpretation is to specialize the constant from Matveev's general theorem to the case of $n=2$, which is a standard procedure.\n\n-   **Verdict:**\n    The problem is valid. It is a well-defined exercise in applying a key theorem in number theory.\n\n### Step 2: Solution\n\nWe proceed by following the steps outlined in the problem statement to compute a lower bound for $|\\Lambda|$, where $\\Lambda = \\ln 2 - 2 \\ln 3$.\n\nThe linear form is of the type $\\Lambda = b_1 \\ln \\alpha_1 + b_2 \\ln \\alpha_2$, with $n=2$ logarithms.\nBy comparison with the given form, we identify the components:\n-   Algebraic numbers: $\\alpha_1 = 2$ and $\\alpha_2 = 3$.\n-   Integer coefficients: $b_1 = 1$ and $b_2 = -2$.\n\n**Field Degree $D$**\nThe number field $K$ is specified as $\\mathbb{Q}$. The algebraic numbers $\\alpha_1 = 2$ and $\\alpha_2 = 3$ are rational numbers, so the field they generate is $\\mathbb{Q}(2, 3) = \\mathbb{Q}$. The degree of this field over $\\mathbb{Q}$ is:\n$$D = [K : \\mathbb{Q}] = [\\mathbb{Q} : \\mathbb{Q}] = 1$$\n\n**Absolute Logarithmic Heights**\nThe absolute logarithmic Weil height $h(\\alpha)$ for a rational number $\\alpha = p/q$ where $p, q$ are coprime integers is given by $h(\\alpha) = \\ln(\\max\\{|p|, |q|\\})$.\n-   For $\\alpha_1 = 2 = 2/1$: The integers $p=2, q=1$ are coprime.\n    $$h(2) = \\ln(\\max\\{|2|, |1|\\}) = \\ln 2$$\n-   For $\\alpha_2 = 3 = 3/1$: The integers $p=3, q=1$ are coprime.\n    $$h(3) = \\ln(\\max\\{|3|, |1|\\}) = \\ln 3$$\n\n**Absolute Values of Logarithms**\nSince $2 > 1$ and $3 > 1$, their natural logarithms are positive.\n-   $|\\ln \\alpha_1| = |\\ln 2| = \\ln 2$.\n-   $|\\ln \\alpha_2| = |\\ln 3| = \\ln 3$.\n\n**Coefficient Bound $B$**\nThe bound $B$ is the maximum of the absolute values of the integer coefficients $b_i$.\n$$B = \\max\\{|b_1|, |b_2|\\} = \\max\\{|1|, |-2|\\} = 2$$\n\n**Parameters $A_1$ and $A_2$**\nFor each $i \\in \\{1, 2\\}$, we must choose $A_i$ such that $A_i \\ge \\max\\{D h(\\alpha_i), |\\ln \\alpha_i|, 0.16\\}$.\n-   For $\\alpha_1 = 2$:\n    We need $A_1 \\ge \\max\\{D h(2), |\\ln 2|, 0.16\\} = \\max\\{1 \\cdot \\ln 2, \\ln 2, 0.16\\}$.\n    Since $\\ln 2 \\approx 0.6931$, which is greater than $0.16$, the maximum is $\\ln 2$. We choose the minimal valid value:\n    $$A_1 = \\ln 2$$\n-   For $\\alpha_2 = 3$:\n    We need $A_2 \\ge \\max\\{D h(3), |\\ln 3|, 0.16\\} = \\max\\{1 \\cdot \\ln 3, \\ln 3, 0.16\\}$.\n    Since $\\ln 3 \\approx 1.0986$, which is greater than $0.16$, the maximum is $\\ln 3$. We choose the minimal valid value:\n    $$A_2 = \\ln 3$$\n\n**Application of Matveev's Theorem**\nWe use the general explicit lower bound from Matveev's work (2000). A commonly cited formulation of this result states that for a non-zero linear form $\\Lambda$,\n$$\\ln|\\Lambda| > -C(n) D^2 (1+\\ln D) (1+\\ln B) A_1 \\cdots A_n$$\nwhere the constant $C(n)$ is given by $C(n) = 1.4 \\cdot 30^{n+3} \\cdot n^{4.5}$.\nWe substitute the parameters determined above:\n-   $n = 2$\n-   $D = 1$\n-   $B = 2$\n-   $A_1 = \\ln 2$\n-   $A_2 = \\ln 3$\n\nFirst, we calculate the multiplicative constant factor, which depends on $n$ and $D$. The phrase \"standard constant for two logarithms\" is interpreted as specializing the general constant to $n=2$.\nThe term $(1+\\ln D)$ becomes $(1+\\ln 1) = 1+0 = 1$.\nThe constant part of the bound is:\n$$C(2) D^2 (1+\\ln D) = (1.4 \\cdot 30^{2+3} \\cdot 2^{4.5}) \\cdot 1^2 \\cdot (1+\\ln 1) = 1.4 \\cdot 30^5 \\cdot 2^{4.5}$$\nNote that $2^{4.5} = 2^{9/2}$.\n\nNow, we assemble the full inequality for $\\ln|\\Lambda|$:\n$$\\ln|\\Lambda| > -(1.4 \\cdot 30^5 \\cdot 2^{9/2}) \\cdot (1+\\ln B) \\cdot A_1 \\cdot A_2$$\nSubstituting $B=2$, $A_1=\\ln 2$, and $A_2=\\ln 3$:\n$$\\ln|\\ln 2 - 2 \\ln 3| > -(1.4 \\cdot 30^5 \\cdot 2^{9/2}) \\cdot (1+\\ln 2) \\cdot (\\ln 2) \\cdot (\\ln 3)$$\n\nTo find the lower bound for $|\\Lambda|$, we exponentiate both sides of the inequality:\n$$|\\ln 2 - 2 \\ln 3| > \\exp\\left( -(1.4 \\cdot 30^5 \\cdot 2^{9/2}) (1+\\ln 2) (\\ln 2) (\\ln 3) \\right)$$\n\nThe question asks for the concrete explicit lower bound, which is the value on the right-hand side of this inequality. This is the final expression.", "answer": "$$\\boxed{\\exp\\left(-1.4 \\cdot 30^5 \\cdot 2^{9/2} (1+\\ln 2) (\\ln 2)(\\ln 3)\\right)}$$", "id": "3008823"}, {"introduction": "Manual calculations are instructive, but the real power of effective methods in number theory is unlocked through computation. This practice challenges you to elevate your understanding by translating the theoretical formula for a lower bound into a functioning algorithm. You will not only implement the bound itself but also incorporate a crucial preliminary check for the \"degenerate\" case where the linear form is exactly zero, a distinction that is fundamental to the correct application of the theorem. [@problem_id:3029876]", "problem": "Design and implement a complete, runnable program that, given positive rational algebraic inputs $\\alpha_1$ and $\\alpha_2$ and integers $b_1$ and $b_2$, outputs an explicit numerical lower bound for the absolute value of the linear form in logarithms $|b_1 \\log \\alpha_1 + b_2 \\log \\alpha_2|$, using degree and height data in the sense of transcendental number theory. The program must adhere to the following specifications.\n\n1. Foundational definitions to use:\n   - An algebraic number $\\alpha$ has a degree $D$ equal to the degree of its minimal polynomial over $\\mathbb{Q}$. For rational $\\alpha \\in \\mathbb{Q}$, the degree is $D=1$.\n   - For a rational $\\alpha = \\frac{p}{q} \\in \\mathbb{Q}$ in lowest terms with integers $p$ and $q$ and $q \\neq 0$, the absolute logarithmic height is defined by $h(\\alpha) = \\log \\max\\{|p|,|q|\\}$, where $\\log$ denotes the natural logarithm.\n   - Use the natural logarithm for all $\\log$ computations.\n   - The linear form in logarithms is $b_1 \\log \\alpha_1 + b_2 \\log \\alpha_2$ taken with the principal real logarithm, requiring $\\alpha_1 > 0$ and $\\alpha_2 > 0$.\n\n2. Scientific base to build on:\n   - Use a well-tested explicit lower bound for linear forms in logarithms of algebraic numbers (for example the theorem of Matveev), specialized to the case $n=2$ and rational inputs, thereby expressing the bound in terms of $D$, a bound on the coefficients $b_i$, and the height data of $\\alpha_i$. Your algorithm should first verify the degeneracy condition $\\alpha_1^{b_1}\\alpha_2^{b_2} = 1$ exactly in $\\mathbb{Q}$; when this holds the linear form equals zero and the correct lower bound is $0$.\n\n3. Algorithmic requirements:\n   - Inputs: $\\alpha_1 = \\frac{p_1}{q_1}$ and $\\alpha_2 = \\frac{p_2}{q_2}$ encoded by integer pairs $(p_1,q_1)$ and $(p_2,q_2)$ with $q_1 \\neq 0$ and $q_2 \\neq 0$, and integers $b_1,b_2$. Assume $\\alpha_1 > 0$ and $\\alpha_2 > 0$ and that each is in lowest terms.\n   - Compute $D=1$ for rational inputs.\n   - Let $B = \\max\\{3,|b_1|,|b_2|\\}$.\n   - Compute the absolute logarithmic heights $h(\\alpha_i) = \\log \\max\\{|p_i|,|q_i|\\}$.\n   - Form $A_i = \\max\\{h(\\alpha_i), |\\log \\alpha_i|, 0.1\\}$.\n   - Apply a standard explicit bound for $|b_1 \\log \\alpha_1 + b_2 \\log \\alpha_2|$ that depends on $D$, $B$, and the $A_i$, specialized to two logarithms and rational inputs as described above. This bound must be nontrivial only when $\\alpha_1^{b_1}\\alpha_2^{b_2} \\neq 1$.\n\n4. Output specification:\n   - For each test case, output a single floating-point number representing the lower bound for $|b_1 \\log \\alpha_1 + b_2 \\log \\alpha_2|$ computed by your algorithm. If the exact degeneracy condition $\\alpha_1^{b_1}\\alpha_2^{b_2} = 1$ holds in $\\mathbb{Q}$, output $0$ for that case.\n   - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$). No units are involved. All angles are in radians by default through the use of the natural logarithm.\n\n5. Test suite:\n   - Use the following test suite of inputs to exercise different facets of correctness:\n     - Case 1 (generic nondegenerate): $\\alpha_1 = 2 = \\frac{2}{1}$, $\\alpha_2 = 3 = \\frac{3}{1}$, $b_1 = 7$, $b_2 = -5$.\n     - Case 2 (near cancellation but nondegenerate): $\\alpha_1 = \\frac{15}{14}$, $\\alpha_2 = \\frac{9}{10}$, $b_1 = 1$, $b_2 = 1$.\n     - Case 3 (exact degeneracy): $\\alpha_1 = \\frac{8}{27}$, $\\alpha_2 = \\frac{2}{3}$, $b_1 = 1$, $b_2 = -3$.\n     - Case 4 (moderate coefficients): $\\alpha_1 = 2 = \\frac{2}{1}$, $\\alpha_2 = \\frac{5}{4}$, $b_1 = 1$, $b_2 = 1$.\n     - Case 5 (mixed signs and moderately sized rationals): $\\alpha_1 = \\frac{7}{5}$, $\\alpha_2 = \\frac{9}{7}$, $b_1 = -2$, $b_2 = 3$.\n   - Your program must encode and run exactly these five cases and aggregate the results into the specified single-line output format.", "solution": "The problem requires the design and implementation of an algorithm to compute an explicit numerical lower bound for the absolute value of a linear form in two logarithms, $\\Lambda = b_1 \\log \\alpha_1 + b_2 \\log \\alpha_2$, where $\\alpha_1, \\alpha_2$ are positive rational numbers and $b_1, b_2$ are integers. The computation must be based on the principles of transcendental number theory.\n\n### Theoretical Foundation\n\nThe core of the solution lies in applying a theorem that provides an explicit lower bound for $|\\Lambda|$ when $\\Lambda \\neq 0$. Such bounds are fundamental results in transcendental number theory, stemming from the work of Alan Baker. We will use a modern, explicit version of these results derived from a theorem by Matveev, as it is a standard and powerful tool for such problems.\n\nSpecifically, we will use the version presented by Bugeaud, Mignotte, and Siksek (Annals of Mathematics, 2006), which is well-suited for practical applications. For a linear form $\\Lambda = \\sum_{i=1}^{n} b_i \\log \\alpha_i$ with algebraic numbers $\\alpha_i$ and integers $b_i$, their theorem provides a lower bound on $|\\Lambda|$. We must specialize this theorem to the conditions of the problem: $n=2$ logarithms of rational numbers $\\alpha_1, \\alpha_2$.\n\nFor rational numbers, the containing number field is $\\mathbb{Q}$, so the degree $D$ is $1$. The general theorem simplifies considerably under these conditions. The theorem states that if $\\Lambda \\neq 0$:\n$$\n\\log |\\Lambda| > -C(n, D) \\cdot (1 + \\log B) \\cdot A_1 \\cdots A_n\n$$\nwhere the parameters $A_i$ relate to the heights of $\\alpha_i$, $B$ is a bound on the coefficients $|b_i|$, and $C(n, D)$ is a computable constant.\n\nFollowing the problem's specifications, we define the parameters as follows:\n- The number of logarithms is $n=2$.\n- The degree is $D=1$, as $\\alpha_1, \\alpha_2 \\in \\mathbb{Q}$.\n- The coefficients are $b_1, b_2 \\in \\mathbb{Z}$.\n- The rational numbers are $\\alpha_1 = p_1/q_1$ and $\\alpha_2 = p_2/q_2$, given to be in lowest terms and positive.\n- The absolute logarithmic height of a rational $\\alpha = p/q$ is $h(\\alpha) = \\log \\max\\{|p|,|q|\\}$.\n- The quantities $A_i$ are defined as $A_i = \\max\\{h(\\alpha_i), |\\log \\alpha_i|, 0.1\\}$ for $i=1,2$.\n- The bound for the coefficients is $B = \\max\\{3, |b_1|, |b_2|\\}$.\n\nThe constant from the specialized Matveev theorem (for $D=1, n=2$) is $C_0 = 1.4 \\cdot 30^{n+3} \\cdot n^{4.5} \\cdot D^2 (1+\\log D)$. With $n=2$ and $D=1$, the term $(1+\\log D)$ becomes $(1+\\log 1) = 1$, and we have:\n$$\nC_0 = 1.4 \\cdot 30^{2+3} \\cdot 2^{4.5} = 1.4 \\cdot 30^5 \\cdot 2^{4.5} \\approx 7.704 \\times 10^8\n$$\nCombining these elements, the lower bound for a non-zero $\\Lambda$ is given by:\n$$\n|\\Lambda| > \\exp\\left( -C_0 \\cdot (1 + \\log B) \\cdot A_1 \\cdot A_2 \\right)\n$$\n\n### Degeneracy Condition\n\nThe above bound is valid only if $\\Lambda \\neq 0$. The case $\\Lambda = 0$ corresponds to the degeneracy condition $\\alpha_1^{b_1} \\alpha_2^{b_2} = 1$. This occurs if and only if $b_1 \\log \\alpha_1 + b_2 \\log \\alpha_2 = \\log(\\alpha_1^{b_1}\\alpha_2^{b_2}) = \\log(1) = 0$.\n\nTo check this condition without precision loss from floating-point arithmetic, we must use exact integer computations. Let $b_i = b_i^+ - b_i^-$ where $b_i^+ = \\max(b_i, 0)$ and $b_i^- = \\max(-b_i, 0)$ are non-negative integers. The condition $\\alpha_1^{b_1} \\alpha_2^{b_2} = 1$ is equivalent to:\n$$\n\\left(\\frac{p_1}{q_1}\\right)^{b_1} \\left(\\frac{p_2}{q_2}\\right)^{b_2} = 1 \\iff p_1^{b_1^+} q_1^{b_1^-} p_2^{b_2^+} q_2^{b_2^-} = q_1^{b_1^+} p_1^{b_1^-} q_2^{b_2^+} p_2^{b_2^-}\n$$\nThis equality involves only integer powers of integers and can be verified exactly. If this identity holds, the lower bound for $|\\Lambda|$ is $0$.\n\n### Algorithmic Procedure\n\nThe algorithm proceeds in two main stages for each test case $(\\alpha_1, \\alpha_2, b_1, b_2)$:\n\n1.  **Check for Degeneracy**:\n    - Given inputs $(p_1, q_1)$, $(p_2, q_2)$, $b_1$, and $b_2$.\n    - Compute the left-hand side and right-hand side of the integer identity derived above using arbitrary-precision integers.\n    - If they are equal, the linear form $\\Lambda$ is zero. The result is $0.0$.\n\n2.  **Compute the Lower Bound**:\n    - If the form is non-degenerate, calculate the required parameters for the bound:\n        a. $B = \\max\\{3, |b_1|, |b_2|\\}$.\n        b. For $i \\in \\{1, 2\\}$, compute $\\alpha_i = p_i/q_i$.\n        c. Compute the heights $h(\\alpha_1) = \\log(\\max\\{p_1, q_1\\})$ and $h(\\alpha_2) = \\log(\\max\\{p_2, q_2\\})$. Note that since $\\alpha_i > 0$ and are in lowest terms, $p_i$ and $q_i$ are positive.\n        d. Compute $A_1 = \\max\\{h(\\alpha_1), |\\log \\alpha_1|, 0.1\\}$ and $A_2 = \\max\\{h(\\alpha_2), |\\log \\alpha_2|, 0.1\\}$.\n        e. The constant is $C_0 = 1.4 \\cdot 30^5 \\cdot 2^{4.5}$.\n        f. The final numerical lower bound is calculated as $\\exp(-C_0 \\cdot (1 + \\log B) \\cdot A_1 \\cdot A_2)$.\n\nThis procedure provides a rigorous and explicit lower bound for $|\\Lambda|$, adhering to the provided definitions and leveraging a standard result from transcendental number theory. The implementation will process the given test suite and format the output as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_bound(p1: int, q1: int, p2: int, q2: int, b1: int, b2: int) -> float:\n    \"\"\"\n    Computes a lower bound for |b1*log(alpha1) + b2*log(alpha2)|.\n    \n    Args:\n        p1, q1: Numerator and denominator of alpha1 = p1/q1.\n        p2, q2: Numerator and denominator of alpha2 = p2/q2.\n        b1, b2: Integer coefficients of the linear form.\n    \n    Returns:\n        A floating-point lower bound for the absolute value of the linear form.\n    \"\"\"\n    # Step 1: Degeneracy check using exact integer arithmetic.\n    # The condition alpha_1^b1 * alpha_2^b2 = 1 must be checked with care.\n    # Let b_i = b_i^+ - b_i^-, where b_i^+ = max(b_i, 0) and b_i^- = max(-b_i, 0).\n    # The condition is equivalent to:\n    # (p1/q1)^b1 * (p2/q2)^b2 = 1\n    # p1^b1 * p2^b2 = q1^b1 * q2^b2\n    # p1^(b1+) * q1^(b1-) * p2^(b2+) * q2^(b2-) = p1^(b1-) * q1^(b1+) * p2^(b2-) * q2^(b2+)\n    b1_pos = max(0, b1)\n    b1_neg = max(0, -b1)\n    b2_pos = max(0, b2)\n    b2_neg = max(0, -b2)\n\n    # Python's integers have arbitrary precision, preventing overflow.\n    lhs = pow(p1, b1_pos) * pow(p2, b2_pos) * pow(q1, b1_neg) * pow(q2, b2_neg)\n    rhs = pow(p1, b1_neg) * pow(p2, b2_neg) * pow(q1, b1_pos) * pow(q2, b2_pos)\n\n    if lhs == rhs:\n        return 0.0\n\n    # Step 2: Compute the lower bound if not degenerate.\n    # We use a specialized version of Matveev's theorem for n=2, D=1 (rationals).\n    \n    # B = max{3, |b1|, |b2|}\n    B = float(max(3, abs(b1), abs(b2)))\n\n    alpha1 = float(p1) / float(q1)\n    alpha2 = float(p2) / float(q2)\n\n    # h(alpha_i) = log(max{|p_i|, |q_i|})\n    # Since alpha_i > 0 and in lowest terms, p_i and q_i are positive.\n    h_alpha1 = np.log(float(max(p1, q1)))\n    h_alpha2 = np.log(float(max(p2, q2)))\n\n    # A_i = max{h(alpha_i), |log alpha_i|, 0.1}\n    A1 = max(h_alpha1, abs(np.log(alpha1)), 0.1)\n    A2 = max(h_alpha2, abs(np.log(alpha2)), 0.1)\n\n    # Matveev's theorem constant C0 for n=2, D=1\n    # C0 = 1.4 * 30^(n+3) * n^4.5 * D^2 * (1+log D) for D>=1\n    # With n=2, D=1, this is C0 = 1.4 * 30^5 * 2^4.5\n    n = 2.0\n    C0 = 1.4 * (30**(n + 3.0)) * (n**4.5)\n\n    # The bound for log|Lambda| is:\n    # log|Lambda| > -C0 * (1 + log B) * A1 * A2\n    log_abs_Lambda_lower_bound = -C0 * (1.0 + np.log(B)) * A1 * A2\n\n    # Return the lower bound for |Lambda|\n    lower_bound = np.exp(log_abs_Lambda_lower_bound)\n\n    return lower_bound\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Format: (p1, q1, p2, q2, b1, b2)\n    test_cases = [\n        (2, 1, 3, 1, 7, -5),      # Case 1\n        (15, 14, 9, 10, 1, 1),    # Case 2\n        (8, 27, 2, 3, 1, -3),     # Case 3\n        (2, 1, 5, 4, 1, 1),       # Case 4\n        (7, 5, 9, 7, -2, 3)      # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        p1, q1, p2, q2, b1, b2 = case\n        result = calculate_bound(p1, q1, p2, q2, b1, b2)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3029876"}, {"introduction": "Why are lower bounds for linear forms in logarithms so important? This final practice provides a compelling answer by applying the theory to a classic problem: finding integer solutions to exponential Diophantine equations. This exercise provides a hypothetical, pre-computed lower bound, allowing you to focus on a strategy that combines this theoretical tool with practical computational techniques like modular arithmetic. You will see firsthand how an abstract result from transcendental number theory can be used to dramatically reduce an infinite search space to a finite, manageable one, making it possible to systematically hunt for solutions. [@problem_id:3008764]", "problem": "Let $a$, $b$, and $c$ be fixed integers with $a \\geq 2$, $b \\geq 2$, and $c \\in \\mathbb{Z}$. Consider the exponential Diophantine equation\n$$\na^{x} - b^{y} = c\n$$\nin integers $x \\geq 1$ and $y \\geq 1$. The objective is to implement a practical strategy that uses effective lower bounds for linear forms in logarithms together with modular constraints and targeted enumeration to rule out or confirm the existence of small-exponent solutions. The strategy must start from the following fundamental base and well-tested facts:\n\n- Define the linear form in logarithms\n$$\n\\Lambda(x,y) = x \\log a - y \\log b,\n$$\nwhere $\\log$ denotes the natural logarithm (base $e$). If $a$ and $b$ are multiplicatively independent (that is, there do not exist nonzero integers $u$ and $v$ such that $a^{u} = b^{v}$), then $\\Lambda(x,y) \\neq 0$ for all integer pairs $(x,y)$ except when $a^{x} = b^{y}$.\n- From the equation $a^{x} - b^{y} = c$, rearrange to obtain $a^{x} / b^{y} = 1 + c / b^{y}$, hence\n$$\n\\Lambda(x,y) = \\log\\!\\left(1 + \\frac{c}{b^{y}}\\right).\n$$\n- For real $t$ with $|t| \\leq \\tfrac{1}{2}$, the inequality\n$$\n\\left|\\log(1+t)\\right| \\leq 2|t|\n$$\nis valid and provides a well-tested upper bound on the right-hand side.\n- Assume that an explicit lower bound from the theory of linear forms in logarithms (for example, via work of Alan Baker or the stronger bounds of Mahler and Matveev) has been computed for the given pair $(a,b)$. Concretely, suppose we are given positive parameters $U$ and $K$ such that for all integers $x,y$ with $1 \\leq x,y \\leq U$ and $\\Lambda(x,y) \\neq 0$, one has\n$$\n|\\Lambda(x,y)| \\geq U^{-K}.\n$$\nThis is an input to your algorithm and is treated as an explicitly available bound.\n- Combining the previous two bullets, whenever $\\left|\\frac{c}{b^{y}}\\right| \\leq \\tfrac{1}{2}$ (equivalently $b^{y} \\geq 2|c|$), any solution must satisfy\n$$\nU^{-K} \\leq |\\Lambda(x,y)| = \\left|\\log\\!\\left(1 + \\frac{c}{b^{y}}\\right)\\right| \\leq \\frac{2|c|}{b^{y}},\n$$\nand therefore\n$$\nb^{y} \\leq \\frac{2|c|}{U^{-K}} = 2|c|\\,U^{K}.\n$$\nThis yields a computable upper bound on $y$, namely\n$$\ny \\leq \\left\\lfloor \\log_{b}\\!\\big(2|c|\\,U^{K}\\big) \\right\\rfloor,\n$$\nwhenever $b^{y} \\geq 2|c|$. For the remaining finitely many cases with $b^{y} < 2|c|$, direct enumeration suffices.\n\nIn addition to the lower bound argument, modular constraints can often prune the search space. For a fixed modulus $m \\in \\mathbb{Z}_{\\geq 2}$, the congruence\n$$\na^{x} \\equiv b^{y} + c \\pmod{m}\n$$\nmust hold for any solution. For each fixed $y$, one can compute the residue $r_{m}(y) \\equiv b^{y} + c \\pmod{m}$, and then check whether $r_{m}(y)$ lies in the subset of $\\mathbb{Z}/m\\mathbb{Z}$ reachable by $a^{x} \\pmod{m}$ as $x$ varies over the positive integers. If there exists a modulus $m$ for which $r_{m}(y)$ is not reachable, then that $y$ can be ruled out entirely.\n\nYour task is to implement the following algorithm:\n\n1. For each test case $(a,b,c)$, you are also given enumeration bound $B_{\\mathrm{enum}}$, and explicit lower bound parameters $(U,K)$ as above. Compute $L = U^{-K}$.\n2. Compute the threshold\n$$\ny_{\\tfrac{1}{2}} = \\left\\lceil \\log_{b}\\!\\big(2|c|\\big) \\right\\rceil,\n$$\nwhich guarantees $\\left|\\frac{c}{b^{y}}\\right| \\leq \\tfrac{1}{2}$ for all $y \\geq y_{\\tfrac{1}{2}}$.\n3. Use the lower bound to deduce\n$$\ny \\leq Y_{\\mathrm{Baker}} := \\left\\lfloor \\log_{b}\\!\\big(2|c|/L\\big) \\right\\rfloor = \\left\\lfloor \\log_{b}\\!\\big(2|c|\\,U^{K}\\big) \\right\\rfloor.\n$$\n4. Set the maximum $y$ to enumerate as\n$$\ny_{\\max} = \\min\\!\\big(B_{\\mathrm{enum}},\\,\\max(1,\\,\\max(Y_{\\mathrm{Baker}},\\,y_{\\tfrac{1}{2}}-1))\\big).\n$$\n5. For each $y$ in $1 \\leq y \\leq y_{\\max}$, apply modular pruning with a small suite of moduli (for example $m \\in \\{4,5,7,8,9,11,13\\}$). If any modulus rules out $y$, skip it. Otherwise, perform targeted enumeration of $x$:\n   - If $y < y_{\\tfrac{1}{2}}$, enumerate all $x$ with $1 \\leq x \\leq B_{\\mathrm{enum}}$.\n   - If $y \\geq y_{\\tfrac{1}{2}}$, use the inequality\n     $$\n     \\big|x - y \\tfrac{\\log b}{\\log a}\\big| \\leq \\frac{2|c|}{b^{y}\\log a}\n     $$\n     to restrict $x$ to a narrow interval around $y \\frac{\\log b}{\\log a}$, and only enumerate integer $x$ within a small safety margin of that interval (you may expand the interval by a small fixed integer margin to account for coarse constants).\n   - For each candidate $x$ in the narrowed interval, check whether $a^{x} - b^{y} = c$ holds in exact integer arithmetic.\n6. If any $(x,y)$ pair satisfies the equation, then small-exponent solutions have not been ruled out; return a boolean value of $\\mathrm{False}$ for that test case. Otherwise, return $\\mathrm{True}$ indicating that, with the given explicit bound and modular constraints, small-exponent solutions up to the prescribed range are ruled out.\n\nTest Suite and required final output:\n\nUse the following six test cases, each given as $(a,b,c,B_{\\mathrm{enum}},U,K)$ with $\\log$ as the natural logarithm:\n\n- Case $1$: $(2,3,5,50,1000,6)$.\n- Case $2$: $(3,2,7,50,1000,6)$.\n- Case $3$: $(5,3,2,30,1000,6)$.\n- Case $4$: $(7,2,3,40,1000,6)$.\n- Case $5$: $(2,3,-1,50,1000,6)$.\n- Case $6$: $(2,3,4,50,1000,6)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_{1},r_{2},\\dots,r_{6}]$), where each $r_{i}$ is a boolean indicating whether small-exponent solutions have been ruled out for that case by the described strategy. No physical units or angle units are involved; all logarithms are natural logarithms, and the output must be in the exact specified list format.", "solution": "The problem provides a detailed algorithm for finding or ruling out small-exponent integer solutions $(x,y)$ to the exponential Diophantine equation $a^x - b^y = c$. The approach combines a theoretical bound derived from Baker's theory of linear forms in logarithms with practical computational search techniques, namely modular arithmetic and targeted enumeration.\n\n### Problem Validation\n\nFirst, a critical validation of the problem statement is performed.\n\n1.  **Givens Extraction**:\n    -   The equation is $a^x - b^y = c$ for integers $x \\geq 1$, $y \\geq 1$.\n    -   Constants are integers $a \\geq 2$, $b \\geq 2$, and $c \\in \\mathbb{Z}$.\n    -   The algorithm is defined by a sequence of computational steps involving:\n        -   An enumeration bound $B_{\\mathrm{enum}}$.\n        -   Parameters $U, K$ for an explicit lower bound $|\\Lambda(x,y)| \\geq U^{-K}$ on the linear form in logarithms $\\Lambda(x,y) = x \\log a - y \\log b$.\n        -   A threshold $y_{\\tfrac{1}{2}} = \\lceil \\log_{b}(2|c|) \\rceil$.\n        -   An upper bound $Y_{\\mathrm{Baker}} = \\lfloor \\log_{b}(2|c|\\,U^{K}) \\rfloor$.\n        -   A search limit $y_{\\max} = \\min(B_{\\mathrm{enum}}, \\max(1, \\max(Y_{\\mathrm{Baker}}, y_{\\tfrac{1}{2}}-1)))$.\n        -   Modular pruning using moduli $m \\in \\{4,5,7,8,9,11,13\\}$.\n        -   Targeted enumeration for $x$, with the search interval for $y \\ge y_{\\tfrac{1}{2}}$ given by $|x - y\\frac{\\log b}{\\log a}| \\le \\frac{2|c|}{b^y \\log a}$.\n    -   The test suite consists of six tuples $(a,b,c,B_{\\mathrm{enum}},U,K)$.\n\n2.  **Validation Check**:\n    -   **Scientific Grounding**: The problem is well-grounded in number theory. The use of linear forms in logarithms is a standard and powerful technique for solving Diophantine equations. The inequalities presented are mathematically correct consequences of the theory.\n    -   **Well-Posedness**: The problem specifies a deterministic algorithm with clear inputs and a uniquely defined output format. The computational steps are unambiguous, leading to a single, verifiable result for each test case.\n    -   **Objectivity**: The problem is stated in precise, objective mathematical language, free from any subjectivity.\n    -   **Completeness and Consistency**: All required constants, formulas, and test cases are provided. The theoretical underpinnings are consistent with the algorithmic steps. The minor ambiguity of a \"small safety margin\" is a practical detail in implementation and can be resolved by choosing a reasonable fixed integer, such as $2$. The assumption $c \\neq 0$ is implicit in the formulas involving $\\log|c|$ and holds for all test cases. The multiplicative independence of $(a,b)$ pairs is also satisfied for all test cases, ensuring $\\Lambda(x,y) \\neq 0$.\n\n3.  **Verdict**: The problem is deemed valid as it is scientifically sound, well-posed, objective, and self-contained.\n\n### Solution Derivation\n\nThe solution involves implementing the algorithm as described. A function is designed to process each test case, returning `True` if no solution is found within the specified search space (i.e., solutions are ruled out) and `False` if a solution is found.\n\nThe main steps for a given test case $(a,b,c,B_{\\mathrm{enum}},U,K)$ are as follows:\n\n1.  **Initialization and Pre-computation**:\n    -   The set of moduli for pruning is $M = \\{4,5,7,8,9,11,13\\}$.\n    -   To apply modular constraints efficiently, for each modulus $m \\in M$, we pre-compute the set of residues $R_m = \\{a^x \\pmod m \\mid x \\ge 1\\}$. This set is finite since the sequence of powers is periodic.\n\n2.  **Compute Search Bounds for $y$**:\n    -   The threshold $y_{\\tfrac{1}{2}}$ is computed. For $y \\ge y_{\\tfrac{1}{2}}$, the inequality $|\\log(1 + c/b^y)| \\le 2|c|/b^y$ is valid.\n        $y_{\\tfrac{1}{2}} = \\max(1, \\lceil \\log_b(2|c|) \\rceil)$.\n    -   The theoretical upper bound on $y$ from Baker's method is computed:\n        $Y_{\\mathrm{Baker}} = \\lfloor \\log_b(2|c|\\,U^K) \\rfloor = \\lfloor \\frac{\\log(2|c|) + K\\log U}{\\log b} \\rfloor$.\n    -   The final effective search limit for $y$ is determined by combining these with the given enumeration bound $B_{\\mathrm{enum}}$:\n        $y_{\\max} = \\min(B_{\\mathrm{enum}}, \\max(1, Y_{\\mathrm{Baker}}, y_{\\tfrac{1}{2}}-1))$.\n\n3.  **Iterative Search**: The algorithm iterates through each integer $y$ from $1$ to $y_{\\max}$. For each $y$:\n\n    -   **Modular Pruning**: Each modulus $m \\in M$ is used to test for the possibility of a solution. For a given $y$, we compute the right-hand side of the congruence $a^x \\equiv b^y+c \\pmod m$. If this value, $(b^y+c) \\pmod m$, is not in the pre-computed set of residues $R_m$, then no integer $x \\ge 1$ can satisfy the congruence. Thus, this value of $y$ is ruled out, and the algorithm proceeds to the next $y$.\n\n    -   **Targeted Enumeration of $x$**: If $y$ survives the modular pruning, a search for $x$ is conducted.\n        -   If $y < y_{\\tfrac{1}{2}}$, the linear form approximation is not guaranteed. A direct search for $x$ is performed from $1$ to $B_{\\mathrm{enum}}$.\n        -   If $y \\ge y_{\\tfrac{1}{2}}$, we use the inequality $|x \\log a - y \\log b| \\le \\frac{2|c|}{b^y}$, which implies $|x - y\\frac{\\log b}{\\log a}| \\le \\frac{2|c|}{b^y\\log a}$. This confines $x$ to a very small interval around the real number $y \\frac{\\log b}{\\log a}$. We enumerate integers $x$ in this interval, expanded by a small safety margin (e.g., $2$ on each side) to account for approximations.\n\n    -   **Solution Check**: For each candidate pair $(x,y)$ generated, the equation $a^x - b^y = c$ is checked using exact integer arithmetic. Python's arbitrary-precision integers are suitable for this, as the powers can become very large. If a solution is found, the function immediately returns `False`.\n\n4.  **Final Result**: If the entire loop over $y$ from $1$ to $y_{\\max}$ completes without finding any solution, the function returns `True`, indicating that small-exponent solutions have been ruled out under the given constraints.\n\nAs an example, for Case 6, $2^x - 3^y = 4$, the algorithm will quickly determine that no solutions exist. The modular constraint with $m=4$ is $2^x - (-1)^y \\equiv 0 \\pmod 4$. If $x=1$, this is $2 - (-1)^y \\not\\equiv 0$. If $x \\ge 2$, this is $0 - (-1)^y \\not\\equiv 0$. Since this holds for no combination of $x,y \\ge 1$, the modular check will rule out every $y$, and the algorithm will correctly return `True`. For the other cases, small solutions will be found, resulting in a `False` output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the exponential Diophantine equation a^x - b^y = c for small integer solutions\n    using the specified algorithm.\n    \"\"\"\n\n    test_cases = [\n        # (a, b, c, B_enum, U, K)\n        (2, 3, 5, 50, 1000, 6),\n        (3, 2, 7, 50, 1000, 6),\n        (5, 3, 2, 30, 1000, 6),\n        (7, 2, 3, 40, 1000, 6),\n        (2, 3, -1, 50, 1000, 6),\n        (2, 3, 4, 50, 1000, 6),\n    ]\n\n    MODULI = [4, 5, 7, 8, 9, 11, 13]\n    SAFETY_MARGIN = 2\n\n    def get_residues(base, mod):\n        \"\"\"Computes the set of residues {base^x mod mod} for x >= 1.\"\"\"\n        if mod == 1:\n            return {0}\n        residues = set()\n        val = base % mod\n        while val not in residues:\n            residues.add(val)\n            val = (val * base) % mod\n            if val == 0 and 0 in residues: # Handle cycles that hit 0\n                break\n        return residues\n\n    def check_case(a, b, c, B_enum, U, K):\n        \"\"\"\n        Implements the specified algorithm for a single test case.\n        Returns True if solutions are ruled out, False if a solution is found.\n        \"\"\"\n        # Pre-compute modular residues for a^x for each modulus\n        ax_residues = {m: get_residues(a, m) for m in MODULI}\n\n        # The problem formulation implies c != 0, which is true for all test cases.\n        # If c were 0, log(2*abs(c)) would be undefined.\n        \n        # Calculate bounds on y\n        log_b = np.log(b)\n        \n        # y_1/2: threshold for the validity of the log inequality\n        # This is ceil(log_b(2*|c|))\n        if 2 * abs(c) <= 1:\n            y_one_half = 1\n        else:\n            y_one_half = math.ceil(np.log(2 * abs(c)) / log_b)\n        y_one_half = max(1, y_one_half)\n        \n        # Y_Baker: upper bound on y from Baker's theory\n        # This is floor(log_b(2*|c|*U^K))\n        log_U = np.log(U)\n        y_baker = math.floor((np.log(2 * abs(c)) + K * log_U) / log_b)\n        \n        # y_max: final enumeration bound for y\n        y_max = min(B_enum, max(1, y_baker, y_one_half - 1))\n\n        # Main search loop over y\n        for y in range(1, y_max + 1):\n            # 1. Modular Pruning\n            is_ruled_out = False\n            for m in MODULI:\n                rhs_mod = (pow(b, y, m) + c) % m\n                if rhs_mod not in ax_residues[m]:\n                    is_ruled_out = True\n                    break\n            if is_ruled_out:\n                continue\n            \n            # 2. Targeted Enumeration of x\n            if y < y_one_half:\n                # For small y, enumerate x up to B_enum\n                for x in range(1, B_enum + 1):\n                    if pow(a, x) - pow(b, y) == c:\n                        return False\n            else: # y >= y_one_half\n                # For large y, use inequality to narrow down search for x\n                log_a = np.log(a)\n                x_center = y * log_b / log_a\n                x_delta = (2 * abs(c)) / (pow(b, y) * log_a)\n                \n                x_min = max(1, math.floor(x_center - x_delta) - SAFETY_MARGIN)\n                x_max = math.ceil(x_center + x_delta) + SAFETY_MARGIN\n                \n                for x in range(x_min, x_max + 1):\n                    if pow(a, x) - pow(b, y) == c:\n                        return False\n                        \n        return True\n\n    results = []\n    for case in test_cases:\n        result = check_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b), results))}]\")\n\nsolve()\n```", "id": "3008764"}]}