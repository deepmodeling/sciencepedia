{"hands_on_practices": [{"introduction": "Before we can explore the properties and implications of the Riemann Hypothesis, we need a practical method to compute the zeta function on the critical line, where its defining series $\\sum n^{-s}$ fails to converge. This practice introduces the powerful approximate functional equation [@problem_id:3031521], which allows us to estimate $\\zeta(\\frac{1}{2}+it)$ using finite sums and the complex Gamma function. By implementing this algorithm, you will gain hands-on experience with the fundamental tools used in the computational study of the zeta function.", "problem": "Let $s = \\sigma + i t$ and consider the Riemann zeta function $\\zeta(s)$ together with its functional equation, which can be expressed in terms of the completed zeta function $\\xi(s) = \\pi^{-s/2} \\Gamma\\!\\left(\\frac{s}{2}\\right) \\zeta(s)$ as $\\xi(s) = \\xi(1-s)$. On the critical line $\\sigma = \\tfrac{1}{2}$, one obtains an approximate functional equation for $\\zeta\\!\\left(\\tfrac{1}{2}+i t\\right)$ involving two finite Dirichlet-type sums of comparable length and a remainder term that can be bounded using asymptotic analysis and Stirling-type estimates for the Gamma function. Your task is to implement a numerical evaluation of $\\zeta\\!\\left(\\tfrac{1}{2}+i t\\right)$ using such an approximate functional equation, with symmetric truncation and an explicit, conservative bound on the remainder.\n\nImplement a program that, for a given real parameter $t$, performs the following steps:\n\n1. Define $s = \\tfrac{1}{2} + i t$ and the factor\n   $$\\chi(s) = \\pi^{s - \\frac{1}{2}} \\frac{\\Gamma\\!\\left(\\frac{1 - s}{2}\\right)}{\\Gamma\\!\\left(\\frac{s}{2}\\right)}.$$\n2. Choose a symmetric truncation parameter\n   $$N = \\max\\!\\left(1, \\left\\lceil \\sqrt{\\frac{t}{2 \\pi}} \\right\\rceil\\right).$$\n3. Compute the truncated sums\n   $$A_N(s) = \\sum_{n=1}^{N} n^{-s}, \\quad B_N(s) = \\sum_{n=1}^{N} n^{s-1}.$$\n4. Form the approximation\n   $$\\widetilde{\\zeta}(s; N) = A_N(s) + \\chi(s)\\, B_N(s).$$\n5. Provide a conservative numerical bound for the remainder term\n   $$R(s; N) = \\zeta(s) - \\widetilde{\\zeta}(s; N),$$\n   using the scale of the classical Riemann–Siegel theory. Specifically, bound the magnitude by\n   $$\\lvert R(s; N) \\rvert \\leq B(t, N), \\quad \\text{where} \\quad B(t, N) = 4\\, (t + 1)^{-1/4} + N^{-1/2}.$$\n   This bound reflects the generic $t^{-1/4}$ scale from the Riemann–Siegel formula on the critical line together with a conservative correction term $N^{-1/2}$ to cover small values of $t$ and coarse truncations $N$.\n\nYou must implement the above using complex arithmetic and an accurate evaluation of the complex Gamma function via the Lanczos approximation. You are not permitted to call any special zeta-function routines; the evaluation must be based on steps 1–4, together with step 5 for the bound.\n\nTest suite:\n- Case 1 (boundary case): $t = 0$.\n- Case 2 (moderate case near the first nontrivial zero): $t = 14.134725141$.\n- Case 3 (larger case): $t = 100$.\n\nFor each test case, produce the triplet\n$$\\left[\\operatorname{Re}\\left(\\widetilde{\\zeta}\\!\\left(\\tfrac{1}{2}+i t; N\\right)\\right),\\ \\operatorname{Im}\\left(\\widetilde{\\zeta}\\!\\left(\\tfrac{1}{2}+i t; N\\right)\\right),\\ B(t, N)\\right],$$\nwhere the first two entries are real numbers giving the real and imaginary parts of the approximation, and the third entry is a real number giving the remainder bound as specified.\n\nFinal output format:\nYour program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, with each result itself given as a list in the order specified above. For example,\n$$\\big[\\,[\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot]\\,\\big].$$\nNo physical units are involved. All angles are implicitly handled in radians through the complex exponential and logarithm, which you must use consistently in your implementation.", "solution": "The problem requires the numerical evaluation of the Riemann zeta function, $\\zeta(s)$, on the critical line $s = \\frac{1}{2} + i t$ for a given real parameter $t$. The evaluation is to be performed using a specific form of an approximate functional equation, which provides an estimate $\\widetilde{\\zeta}(s; N)$ for $\\zeta(s)$. The structure of this approximation is given by:\n$$\n\\widetilde{\\zeta}(s; N) = \\sum_{n=1}^{N} n^{-s} + \\chi(s) \\sum_{n=1}^{N} n^{s-1}\n$$\nwhere $N$ is a truncation parameter dependent on $t$, and $\\chi(s)$ is a phase factor derived from the exact functional equation for $\\zeta(s)$:\n$$\n\\chi(s) = \\pi^{s - \\frac{1}{2}} \\frac{\\Gamma\\left(\\frac{1 - s}{2}\\right)}{\\Gamma\\left(\\frac{s}{2}\\right)}\n$$\nHere, $\\Gamma(z)$ is the complex Gamma function. The problem also specifies a formula for a conservative bound on the magnitude of the remainder term, $R(s; N) = \\zeta(s) - \\widetilde{\\zeta}(s; N)$. The core of the task is to implement these formulas numerically.\n\nA crucial component is the accurate evaluation of the Gamma function for complex arguments, $\\Gamma(z)$. As stipulated, pre-existing special function libraries for this purpose are disallowed. Instead, the implementation is based on the Lanczos approximation, a highly accurate method for this purpose. The chosen Lanczos formula approximates $\\Gamma(z+1)$ as:\n$$\n\\Gamma(z+1) = \\sqrt{2\\pi}(z+g+1/2)^{z+1/2} e^{-(z+g+1/2)} \\left( p_0 + \\sum_{k=1}^{N_p-1} \\frac{p_k}{z+k} \\right)\n$$\nwhere $g$ is a freely chosen constant and $\\{p_k\\}$ are pre-computed coefficients. We use the standard high-precision values $g=7$ and a set of $N_p=9$ coefficients $\\{p_k\\}_{k=0}^8$. To compute $\\Gamma(s)$ for some argument $s$, we set $z = s-1$ and apply the formula. This approximation is valid for $\\operatorname{Re}(z) > 0$, or equivalently $\\operatorname{Re}(s) > 1$. The problem requires evaluation of $\\Gamma$ at arguments like $s/2 = \\frac{1}{4} + i\\frac{t}{2}$, where the real part is less than $1$. To handle arguments $s$ with $\\operatorname{Re}(s) \\le 1$, we can use recurrence relations. Specifically, for an argument $s$ with $\\operatorname{Re}(s) < 1/2$, we employ the Euler reflection formula:\n$$\n\\Gamma(s) = \\frac{\\pi}{\\sin(\\pi s) \\Gamma(1-s)}\n$$\nThis reduces the computation of $\\Gamma(s)$ to that of $\\Gamma(1-s)$. Since $\\operatorname{Re}(s) < 1/2$, the real part of the new argument, $\\operatorname{Re}(1-s)=1-\\operatorname{Re}(s)$, is greater than $1/2$. Our implementation therefore has two cases: if $\\operatorname{Re}(s) < 1/2$, we apply the reflection formula; otherwise, we apply the Lanczos formula directly by setting $z=s-1$.\n\nFor each test case value of $t$, the full computation follows these steps:\nLet $s = \\frac{1}{2} + i t$.\n\nFirst, the truncation parameter $N$ is determined:\n$$\nN = \\max\\left(1, \\left\\lceil \\sqrt{\\frac{t}{2 \\pi}} \\right\\rceil\\right)\n$$\nThis choice is standard and ensures that the two sums in the approximation have comparable \"analytic length\". For $t=0$, this gives $N=1$.\n\nSecond, the two finite Dirichlet series, $A_N(s)$ and $B_N(s)$, are computed:\n$$\nA_N(s) = \\sum_{n=1}^{N} n^{-s} = \\sum_{n=1}^{N} n^{-1/2} e^{-it\\ln n}\n$$\n$$\nB_N(s) = \\sum_{n=1}^{N} n^{s-1} = \\sum_{n=1}^{N} n^{-1/2} e^{+it\\ln n}\n$$\nIt is evident from these expressions that $B_N(s)$ is the complex conjugate of $A_N(s)$, i.e., $B_N(s) = \\overline{A_N(s)}$, since $s = \\frac{1}{2}+it$ and $n$ is real.\n\nThird, the phase factor $\\chi(s)$ is calculated. With $s = \\frac{1}{2} + i t$, the factor becomes:\n$$\n\\chi(s) = \\pi^{it} \\frac{\\Gamma\\left(\\frac{1/2 - it}{2}\\right)}{\\Gamma\\left(\\frac{1/2 + it}{2}\\right)} = e^{it \\ln \\pi} \\frac{\\Gamma\\left(\\frac{1}{4} - i\\frac{t}{2}\\right)}{\\Gamma\\left(\\frac{1}{4} + i\\frac{t}{2}\\right)}\n$$\nThe two arguments to the Gamma function, $\\frac{1}{4} \\pm i\\frac{t}{2}$, are complex conjugates. The Schwarz reflection principle for the Gamma function states that $\\Gamma(\\bar{z}) = \\overline{\\Gamma(z)}$. Therefore, $\\Gamma(\\frac{1}{4} - i\\frac{t}{2}) = \\overline{\\Gamma(\\frac{1}{4} + i\\frac{t}{2})}$. This implies that $\\chi(s)$ is a complex number of modulus $1$, representing a rotation.\n\nFourth, the approximation $\\widetilde{\\zeta}(s;N)$ is assembled:\n$$\n\\widetilde{\\zeta}(s; N) = A_N(s) + \\chi(s) B_N(s)\n$$\nUsing the relation $B_N(s) = \\overline{A_N(s)}$, we could write this as $\\widetilde{\\zeta}(s; N) = A_N(s) + \\chi(s)\\overline{A_N(s)}$, which shows how the approximation is constructed from one sum and a rotation.\n\nFinally, the conservative error bound $B(t, N)$ is computed according to the given formula:\n$$\nB(t, N) = 4 (t+1)^{-1/4} + N^{-1/2}\n$$\nThis value provides an upper limit on the magnitude of the difference between our approximation and the true value of $\\zeta(s)$.\n\nThe provided solution is implemented in Python using the `numpy` library for its robust handling of complex numbers and mathematical functions. A standalone function, `gamma(z)`, encapsulates the Lanczos approximation for the complex Gamma function and the reflection formula. The main function, `solve()`, iterates through the test cases for $t$, constructs $s$, calculates $N$, the sums $A_N(s)$ and $B_N(s)$, the factor $\\chi(s)$, and finally the approximation $\\widetilde{\\zeta}(s; N)$ and the error bound $B(t, N)$. The resulting triplet $[\\operatorname{Re}(\\widetilde{\\zeta}), \\operatorname{Im}(\\widetilde{\\zeta}), B(t,N)]$ is stored for each case and printed in the specified format.", "answer": "```python\nimport numpy as np\n\n# Coefficients for the Lanczos approximation of the Gamma function.\n# These are for g=7, N_p=9 from a standard implementation by Paul Godfrey.\nLANCZOS_G = 7\nLANCZOS_P = [\n    0.99999999999980993,\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7,\n]\n\ndef gamma(z: complex) -> complex:\n    \"\"\"\n    Computes the complex Gamma function using the Lanczos approximation.\n    Handles Re(z) < 0.5 via the reflection formula.\n    \"\"\"\n    if z.real < 0.5:\n        # Use Euler's reflection formula: Gamma(z) * Gamma(1-z) = pi / sin(pi*z)\n        # This calls gamma(1-z) where Re(1-z) > 0.5, ensuring termination.\n        return np.pi / (np.sin(np.pi * z) * gamma(1 - z))\n    else:\n        # Apply the Lanczos approximation for Re(z) >= 0.5\n        # The formula is for Gamma(z+1), so we shift the argument.\n        z -= 1\n        x = LANCZOS_P[0]\n        for i in range(1, len(LANCZOS_P)):\n            x += LANCZOS_P[i] / (z + i)\n        \n        t = z + LANCZOS_G + 0.5\n        \n        # Compute Gamma(z+1). Using np.power handles complex base and exponent.\n        # Gamma(z+1) = sqrt(2*pi) * t^(z+0.5) * exp(-t) * x\n        gamma_z_plus_1 = np.sqrt(2 * np.pi) * np.power(t, z + 0.5) * np.exp(-t) * x\n        \n        return gamma_z_plus_1\n\n\ndef solve():\n    \"\"\"\n    Main function to compute and print the zeta function approximations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        14.134725141,\n        100.0,\n    ]\n\n    results = []\n    for t in test_cases:\n        # Step 1: Define s = 1/2 + i*t\n        s = 0.5 + 1j * t\n\n        # Step 2: Choose a symmetric truncation parameter N\n        # N = max(1, ceil(sqrt(t / (2*pi))))\n        if t <= 0:\n            N = 1\n        else:\n            N = int(np.ceil(np.sqrt(t / (2 * np.pi))))\n            N = max(1, N)\n\n        # Step 3: Compute the truncated sums A_N(s) and B_N(s)\n        n_vals = np.arange(1, N + 1, dtype=np.float64)\n        A_N = np.sum(np.power(n_vals, -s))\n        B_N = np.sum(np.power(n_vals, s - 1))\n        \n        # Sanity check: on the critical line, B_N(s) should be the conjugate of A_N(s)\n        # assert np.isclose(B_N, np.conj(A_N))\n\n        # First, compute the factor chi(s)\n        # chi(s) = pi^(s - 1/2) * Gamma((1-s)/2) / Gamma(s/2)\n        s_minus_half = s - 0.5  # This is purely imaginary: i*t\n        pi_factor = np.power(np.pi, s_minus_half)\n        \n        arg1_gamma = (1 - s) / 2\n        arg2_gamma = s / 2\n        \n        gamma_factor = gamma(arg1_gamma) / gamma(arg2_gamma)\n        \n        chi_s = pi_factor * gamma_factor\n        \n        # Step 4: Form the approximation tilde_zeta\n        tilde_zeta = A_N + chi_s * B_N\n        \n        # Step 5: Provide a conservative numerical bound for the remainder\n        # B(t, N) = 4*(t+1)^(-1/4) + N^(-1/2)\n        bound = 4.0 * np.power(t + 1.0, -0.25) + np.power(N, -0.5)\n\n        # Store the triplet [Re(zeta), Im(zeta), Bound]\n        result_triplet = [tilde_zeta.real, tilde_zeta.imag, bound]\n        results.append(result_triplet)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python includes spaces,\n    # which matches the format example's style.\n    formatted_results = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3031521"}, {"introduction": "The profound importance of the zeta function's zeros stems from their deep connection to the distribution of prime numbers. This practice brings that connection to life through the explicit formula [@problem_id:3031529], which links the prime-counting Chebyshev function $\\psi(x)$ directly to a sum over the nontrivial zeros $\\rho$. By computing the main oscillatory terms in this formula, you will witness firsthand how the zeros 'conspire' to create the intricate fluctuations in the density of primes, offering a tangible glimpse into what is often called the \"music of the primes.\"", "problem": "Let $x$ be a real number with $x &gt; 1$ and let $\\psi(x)$ denote the Chebyshev function $\\psi(x) = \\sum_{n \\le x} \\Lambda(n)$, where $\\Lambda(n)$ is the von Mangoldt function. Consider the explicit formula that expresses $\\psi(x)$ in terms of the nontrivial zeros of the Riemann zeta function $\\zeta(s)$, where each nontrivial zero is denoted by $\\rho = \\beta + i \\gamma$ with $0 &lt; \\beta &lt; 1$. For $x$ that is not an exact prime power, a classical formulation of the explicit formula is\n$$\n\\psi(x) \\;=\\; x \\;-\\; \\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr),\n$$\nwhere the sum ranges over all nontrivial zeros $\\rho$ of $\\zeta(s)$, counted with multiplicity. In this problem, you will compute a truncated version of the explicit formula to estimate $\\psi(x) - x$ at $x = 10^{6}$, using a finite list of known zero ordinates and assuming that for the zeros used, the Riemann Hypothesis (RH) holds so that $\\beta = \\tfrac{1}{2}$ for those zeros. You will also assess the sensitivity of the estimate to small perturbations in the locations of these zeros.\n\nYou must adhere to the following algorithmic and mathematical requirements:\n- Use $x = 10^{6}$.\n- Let the set of available zero ordinates be the first ten positive ordinates $\\gamma_{k}$ of the nontrivial zeros of $\\zeta(s)$ on the critical line $\\operatorname{Re}(s) = \\tfrac{1}{2}$, listed below:\n  - $\\gamma_{1} = 14.134725141734693$,\n  - $\\gamma_{2} = 21.022039638771555$,\n  - $\\gamma_{3} = 25.010857580145688$,\n  - $\\gamma_{4} = 30.424876125859513$,\n  - $\\gamma_{5} = 32.935061587739189$,\n  - $\\gamma_{6} = 37.586178158825671$,\n  - $\\gamma_{7} = 40.918719012147495$,\n  - $\\gamma_{8} = 43.327073280914999$,\n  - $\\gamma_{9} = 48.005150881167159$,\n  - $\\gamma_{10} = 49.773832477672302$.\n- For a truncation level $N \\in \\{0,1,\\dots,10\\}$, approximate\n$$\n\\psi(x) - x \\;\\approx\\; - \\sum_{k=1}^{N} \\left( \\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}} \\right) \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr),\n$$\nwhere $\\rho_{k} = \\tfrac{1}{2} + i \\gamma_{k}$ and $\\overline{\\rho_{k}} = \\tfrac{1}{2} - i \\gamma_{k}$. Note that for real $x$, each pair contributes a real value, and the pairwise sum simplifies to\n$$\n\\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}}\n\\;=\\;\n2\\, x^{1/2}\\, \\frac{\\tfrac{1}{2}\\cos(\\gamma_{k}\\log x) + \\gamma_{k}\\sin(\\gamma_{k}\\log x)}{\\tfrac{1}{4} + \\gamma_{k}^{2}}.\n$$\n- To assess sensitivity of the estimate to the location of a zero, introduce a perturbation to a chosen ordinate: for a given index $j \\in \\{1,\\dots,N\\}$ and a small real perturbation $\\delta$, replace $\\gamma_{j}$ by $\\gamma_{j} + \\delta$ and recompute the truncated estimate. Define the sensitivity measure as the absolute difference between the perturbed and unperturbed estimates.\n\nAll computations are purely mathematical and unitless; use the natural logarithm for all logarithms. You should implement the algorithm with real arithmetic and the trigonometric simplification given above.\n\nTest suite:\n- Use $x = 10^{6}$ and the list of $\\gamma_{k}$ above. Compute the following five outputs:\n  1) The truncated estimate with $N = 0$ (edge case, no zeros used).\n  2) The truncated estimate with $N = 5$ (baseline partial sum).\n  3) The truncated estimate with $N = 10$ (larger partial sum).\n  4) The sensitivity for $N = 10$ when perturbing the $j = 5$ ordinate by $\\delta = 10^{-6}$.\n  5) The sensitivity for $N = 10$ when perturbing the $j = 1$ ordinate by $\\delta = 10^{-6}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results of the five computations as a comma-separated list enclosed in square brackets, in the order listed above. For example, an output line must look like\n$[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4},\\text{result}_{5}]$\nwith each $\\text{result}_{k}$ a real number written in standard decimal notation.", "solution": "The user wants to compute a truncated version of the explicit formula for the Chebyshev function $\\psi(x)$ and assess its sensitivity to perturbations in the locations of the zeros of the Riemann zeta function.\n\n### Principle-Based Design\n\nThe problem revolves around the explicit formula from analytic number theory, which relates the prime-counting function $\\psi(x)$ to the nontrivial zeros $\\rho$ of the Riemann zeta function $\\zeta(s)$. The formula provided is:\n$$\n\\psi(x) \\;=\\; x \\;-\\; \\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr)\n$$\nThis can be rearranged to express the deviation of $\\psi(x)$ from $x$:\n$$\n\\psi(x) - x \\;=\\; -\\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr)\n$$\nThe sum is over all nontrivial zeros $\\rho$. These zeros come in complex conjugate pairs. If $\\rho = \\beta + i\\gamma$ is a zero, then so is its conjugate $\\overline{\\rho} = \\beta - i\\gamma$. The problem assumes the Riemann Hypothesis for the given zeros, meaning their real part is $\\beta = \\frac{1}{2}$. Under this assumption, a pair of zeros is given by $\\rho_k = \\frac{1}{2} + i\\gamma_k$ and $\\overline{\\rho_k} = \\frac{1}{2} - i\\gamma_k$ for a positive ordinate $\\gamma_k > 0$.\n\nThe core of the algorithm is to compute a truncated approximation for $\\psi(x) - x$ by summing over the first $N$ pairs of zeros. The approximation, which we will denote as $E(x, N, \\{\\gamma_k\\})$, is:\n$$\nE(x, N, \\{\\gamma_k\\}) \\;\\approx\\; - \\sum_{k=1}^{N} \\left( \\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}} \\right) \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr)\n$$\nThe contribution from each conjugate pair of zeros is a real-valued term. As stated in the problem, this term simplifies to:\n$$\n\\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}}\n\\;=\\;\n2\\, x^{1/2}\\, \\frac{\\tfrac{1}{2}\\cos(\\gamma_{k}\\log x) + \\gamma_{k}\\sin(\\gamma_{k}\\log x)}{\\tfrac{1}{4} + \\gamma_{k}^{2}}\n$$\nOur algorithm implements a function, `compute_psi_minus_x`, that calculates this truncated estimate $E(x, N, \\{\\gamma_k\\})$.\n\n**Algorithmic Steps:**\n\n1.  **Define Inputs and Constants:** The value of $x$ is set to $10^6$. The list of the first $10$ positive ordinates $\\{\\gamma_k\\}$ is stored.\n\n2.  **Modular Function:** A function `compute_psi_minus_x(x, gammas_list)` is designed to compute the estimate. It takes $x$ and a list of ordinates as input, where the length of the list corresponds to the truncation level $N$.\n\n3.  **Constant Term Calculation:** The function first computes the zero-independent part of the expression: $C(x) = \\log(2\\pi) + \\frac{1}{2}\\log(1 - x^{-2})$. The total estimate is $-S - C(x)$, where $S$ is the sum over zeros. For numerical stability with large $x$, the term $\\log(1 - x^{-2})$ is computed as `np.log1p(-x**-2)`, which is more accurate for arguments close to $0$.\n\n4.  **Summation over Zeros:** The function then iterates through the provided `gammas_list`. For each $\\gamma_k$, it calculates the contribution from the corresponding zero pair using the simplified real-valued formula. These contributions are summed up to obtain the total sum $S = \\sum_{k=1}^{N} \\left( \\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}} \\right)$.\n\n5.  **Final Estimate:** The function returns the final estimate $-S - C(x)$.\n\n6.  **Test Case Computations:**\n    -   The estimates for $N=0$, $N=5$, and $N=10$ are computed by calling `compute_psi_minus_x` with the appropriate slice of the `gammas` list. For $N=0$, an empty list is passed, resulting in a sum $S=0$.\n    -   The baseline estimate for $N=10$ is stored for the sensitivity analysis.\n\n7.  **Sensitivity Analysis:** To assess sensitivity, a perturbed estimate is calculated. A copy of the full `gammas` list (for $N=10$) is made. The chosen ordinate $\\gamma_j$ is modified by adding a small perturbation $\\delta = 10^{-6}$. The `compute_psi_minus_x` function is called with this perturbed list. The sensitivity is then computed as the absolute difference between this perturbed estimate and the baseline $N=10$ estimate. This process is performed for $j=1$ and $j=5$.\n\n8.  **Output Formatting:** The five required numerical results are collected into a list and formatted into a single output string as specified.\n\nThis structured approach ensures correctness by directly implementing the established mathematical formulas and provides robust numerical results by leveraging appropriate functions from the `numpy` library.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_psi_minus_x(x, gammas_list):\n    \"\"\"\n    Computes the truncated explicit formula approximation for psi(x) - x.\n\n    Args:\n        x (float): The value at which to evaluate the function. Must be > 1.\n        gammas_list (list of float): A list of the positive ordinates of the\n                                     nontrivial zeros of the Riemann zeta function.\n\n    Returns:\n        float: The approximated value of psi(x) - x.\n    \"\"\"\n    log_x = np.log(x)\n    x_sqrt = np.sqrt(x)\n\n    # Calculate the constant terms: -log(2*pi) - 0.5*log(1 - x**-2)\n    # Using np.log1p(y) = log(1+y) for better precision when y is close to 0.\n    # Here, y = -x**-2, which is very close to 0 for x=10^6.\n    const_term = -(np.log(2 * np.pi) + 0.5 * np.log1p(-x**-2))\n\n    # Calculate the sum over the nontrivial zeros.\n    sum_zeros = 0.0\n    for gamma in gammas_list:\n        arg = gamma * log_x\n        # Contribution from the pair of zeros (1/2 + i*gamma, 1/2 - i*gamma)\n        numerator = 0.5 * np.cos(arg) + gamma * np.sin(arg)\n        denominator = 0.25 + gamma**2\n        term = 2 * x_sqrt * numerator / denominator\n        sum_zeros += term\n    \n    # The full formula is -sum_zeros + const_term\n    return -sum_zeros + const_term\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    \"\"\"\n    # Define the parameters and test cases from the problem statement.\n    x = 10.0**6\n    gammas = [\n        14.134725141734693,\n        21.022039638771555,\n        25.010857580145688,\n        30.424876125859513,\n        32.935061587739189,\n        37.586178158825671,\n        40.918719012147495,\n        43.327073280914999,\n        48.005150881167159,\n        49.773832477672302\n    ]\n    delta = 1e-6\n\n    # 1) Compute the truncated estimate with N = 0 (no zeros used)\n    est_N0 = compute_psi_minus_x(x, [])\n    \n    # 2) Compute the truncated estimate with N = 5\n    est_N5 = compute_psi_minus_x(x, gammas[:5])\n\n    # 3) Compute the truncated estimate with N = 10\n    est_N10 = compute_psi_minus_x(x, gammas)\n\n    # 4) Compute the sensitivity for N = 10 when perturbing gamma_5\n    gammas_pert_j5 = gammas[:]  # Create a copy\n    gammas_pert_j5[4] += delta   # j=5 corresponds to index 4\n    est_pert_j5 = compute_psi_minus_x(x, gammas_pert_j5)\n    sens_j5 = abs(est_pert_j5 - est_N10)\n\n    # 5) Compute the sensitivity for N = 10 when perturbing gamma_1\n    gammas_pert_j1 = gammas[:]  # Create a copy\n    gammas_pert_j1[0] += delta   # j=1 corresponds to index 0\n    est_pert_j1 = compute_psi_minus_x(x, gammas_pert_j1)\n    sens_j1 = abs(est_pert_j1 - est_N10)\n\n    results = [est_N0, est_N5, est_N10, sens_j5, sens_j1]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3031529"}, {"introduction": "The distribution of the zeta zeros along the critical line exhibits remarkable statistical regularities. Gram's Law is a famous heuristic that predicts the approximate locations of the zeros, suggesting a surprisingly regular pattern. This exercise [@problem_id:3031532] challenges you to computationally test this 'law' and discover a concrete instance where it fails. By finding a \"Gram block\"—a region where the law is violated—you will gain a deeper appreciation for the complex and subtle patterns governing the spacing of zeros, a central theme in modern research on the Riemann Hypothesis.", "problem": "Let $\\zeta(s)$ denote the Riemann zeta function, defined for $\\Re(s) &gt; 1$ by the series $\\zeta(s) = \\sum_{n=1}^{\\infty} n^{-s}$ and extended to the complex plane by analytic continuation except for a simple pole at $s=1$. Define the Hardy $Z$-function by $Z(t) = e^{i \\theta(t)} \\zeta\\!\\left(\\tfrac{1}{2} + i t\\right)$, where $\\theta(t)$ is the Riemann–Siegel theta function given by\n$$\n\\theta(t) = \\arg \\Gamma\\!\\left(\\tfrac{1}{4} + \\tfrac{i t}{2}\\right) - \\tfrac{t}{2} \\log \\pi,\n$$\nwith the branch of the argument chosen continuously for $t \\ge 0$. The Gram points $\\{g_n\\}_{n \\ge 0}$ are defined implicitly by $\\theta(g_n) = n \\pi$ for integers $n \\ge 0$. Gram’s law asserts that, heuristically, the values $Z(g_n)$ should alternate in sign at successive Gram points. A failure of Gram’s law is observed when two successive values $Z(g_n)$ and $Z(g_{n+1})$ have the same sign (or one is zero), so that the alternation property is violated.\n\nStarting from the following fundamental base:\n- The functional equation for the Riemann zeta function, equivalently expressed through the Hardy $Z$-function $Z(t)$ being real-valued for real $t$.\n- The Riemann–Siegel theta function asymptotics for large $t$ derived from Stirling’s approximation for the gamma function:\n$$\n\\theta(t) \\approx \\tfrac{t}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{t}{2} - \\tfrac{\\pi}{8} + \\tfrac{1}{48 t} + \\tfrac{7}{5760 t^3} + \\tfrac{31}{80640 t^5},\n$$\nwith derivative\n$$\n\\theta'(t) \\approx \\tfrac{1}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{1}{48 t^2} - \\tfrac{7}{1920 t^4} - \\tfrac{31}{16128 t^6}.\n$$\n- The Riemann–Siegel approximate functional equation for $Z(t)$, which yields the truncated main sum\n$$\nZ(t) \\approx 2 \\sum_{n=1}^{N} n^{-1/2} \\cos\\!\\big(\\theta(t) - t \\log n\\big), \\quad \\text{where } N = \\left\\lfloor \\sqrt{\\tfrac{t}{2\\pi}} \\right\\rfloor,\n$$\nand the neglected remainder is of lower order for moderate to large $t$.\n\nYour task is to construct a program that demonstrates a concrete failure of Gram’s law by computing successive Gram points $g_n$ in chosen index ranges, evaluating $Z(g_n)$ via the truncated Riemann–Siegel main sum, and checking whether the signs of $Z(g_n)$ alternate. Use the asymptotic expansion above to compute $\\theta(t)$ and $\\theta'(t)$, and solve $\\theta(t) = n \\pi$ for $t$ numerically using a stable root-finding method (such as Newton’s method with a robust fallback to bisection if needed). Then evaluate the truncated sum for $Z(t)$ and determine its sign. Treat values where $Z(t)$ is numerically indistinguishable from zero (within a small absolute tolerance) as breaking alternation.\n\nDesign the program to process the following test suite of index ranges $(n_{\\text{start}}, n_{\\text{end}})$:\n- Case 1 (happy path): $(10, 30)$.\n- Case 2 (targeted failure search): $(120, 140)$.\n- Case 3 (larger index window): $(500, 520)$.\n\nFor each case, scan $n$ from $n_{\\text{start}}$ to $n_{\\text{end}}-1$, compute $g_n$ and $g_{n+1}$, and determine the smallest integer $n$ in the interval such that $Z(g_n)$ and $Z(g_{n+1})$ do not alternate signs. If the alternation holds throughout the interval, return $-1$ for that case. The required outputs for the three cases are thus integers.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). No physical units or angle units are required. The numerical algorithms you implement must be scientifically sound and consistent with the stated base formulas, and your numerical tolerances must be chosen plausibly to reflect the approximations involved.", "solution": "The posed problem is a well-defined computational exercise in number theory, requiring the numerical investigation of Gram's law for the Riemann zeta function. The problem provides all necessary mathematical definitions and approximations to proceed. It is scientifically grounded, internally consistent, and requires no information beyond what is supplied. Therefore, the problem is deemed valid and a solution will be presented.\n\nThe core of the task is to find the smallest integer index $n$ within specified ranges $(n_{\\text{start}}, n_{\\text{end}})$ for which Gram's law fails. Gram's law heuristically predicts that the sign of the Hardy $Z$-function, $Z(t)$, alternates at consecutive Gram points, $g_n$ and $g_{n+1}$. A failure occurs if $Z(g_n)$ and $Z(g_{n+1})$ have the same sign, or if one is zero. This is equivalent to testing the condition $\\text{sign}(Z(g_n)) \\cdot \\text{sign}(Z(g_{n+1})) \\neq -1$.\n\nThe solution is constructed through a sequence of methodical steps:\n$1$. Implementing the provided asymptotic formulas for the Riemann-Siegel theta function $\\theta(t)$ and its derivative $\\theta'(t)$.\n$2$. Developing a numerical procedure to find the Gram points $g_n$ by solving the equation $\\theta(g_n) = n\\pi$.\n$3$. Implementing the provided truncated Riemann-Siegel main sum to approximate the Hardy $Z$-function, $Z(t)$.\n$4$. Systematically scanning the given index ranges to detect the first failure of sign alternation.\n\n**1. Implementation of Asymptotic Formulas**\n\nThe problem supplies specific asymptotic expansions for the Riemann-Siegel theta function $\\theta(t)$ and its derivative $\\theta'(t)$. These functions are fundamental to the calculation.\n\n- The function $\\theta(t)$ is implemented using the expansion:\n$$\n\\theta(t) \\approx \\tfrac{t}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{t}{2} - \\tfrac{\\pi}{8} + \\tfrac{1}{48 t} + \\tfrac{7}{5760 t^3} + \\tfrac{31}{80640 t^5}\n$$\nThis approximation is valid for large $t$.\n\n- The derivative, $\\theta'(t)$, required for the root-finding algorithm, is implemented using its corresponding expansion:\n$$\n\\theta'(t) \\approx \\tfrac{1}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{1}{48 t^2} - \\tfrac{7}{1920 t^4} - \\tfrac{31}{16128 t^6}\n$$\n\n**2. Computation of Gram Points**\n\nThe Gram points, $\\{g_n\\}$, are defined as the solutions to the equation $\\theta(t) = n\\pi$ for non-negative integers $n$. This is a root-finding problem for the function $f(t) = \\theta(t) - n\\pi$. Given the availability of the analytic derivative $f'(t) = \\theta'(t)$, Newton's method is an efficient and appropriate choice as suggested. The iterative update rule is:\n$$\nt_{k+1} = t_k - \\frac{f(t_k)}{f'(t_k)} = t_k - \\frac{\\theta(t_k) - n\\pi}{\\theta'(t_k)}\n$$\nTo ensure convergence, a good initial guess $t_0$ for $g_n$ is required. By inverting the dominant term of the $\\theta(t)$ expansion, $\\theta(t) \\approx \\frac{t}{2} \\log(\\frac{t}{2\\pi})$, we can derive a suitable starting value. Setting $n\\pi \\approx \\frac{t}{2}\\log(\\frac{t}{2\\pi})$, we arrive at the approximate relation $t \\approx 2\\pi n / \\log(n)$. This provides a robust initial guess for the Newton-Raphson iteration for sufficiently large $n$. The implementation will use the `scipy.optimize.newton` function, which provides a reliable a pre-built solver.\n\n**3. Evaluation of the Hardy Z-function**\n\nThe Hardy $Z$-function is evaluated using the provided truncated Riemann-Siegel main sum:\n$$\nZ(t) \\approx 2 \\sum_{k=1}^{N} k^{-1/2} \\cos\\!\\big(\\theta(t) - t \\log k\\big)\n$$\nwhere the number of terms in the sum, $N$, is given by $N = \\lfloor \\sqrt{t/(2\\pi)} \\rfloor$. The value of $\\theta(t)$ required in the cosine term is computed using the same asymptotic formula from Step $1$. This approximation for $Z(t)$ is accurate for moderately large values of $t$, which corresponds to the index ranges being investigated.\n\n**4. Detection of Gram's Law Failures**\n\nThe final stage of the algorithm is to test for failures. For each integer $n$ in a given range $[n_{\\text{start}}, n_{\\text{end}}-1]$, the following procedure is executed:\n$a$. Compute the Gram points $g_n$ and $g_{n+1}$ using the Newton's method procedure from Step $2$.\n$b$. Evaluate the corresponding $Z$-function values, $Z(g_n)$ and $Z(g_{n+1})$, using the formula from Step $3$.\n$c$. Determine the signs of these two values. A value $v$ is considered to be zero if $|v| < \\epsilon$ for a small tolerance, $\\epsilon = 10^{-9}$. The sign is defined as:\n$$\n\\text{sign}(v) = \\begin{cases} 1 & \\text{if } v > \\epsilon \\\\ -1 & \\text{if } v < -\\epsilon \\\\ 0 & \\text{if } |v| \\le \\epsilon \\end{cases}\n$$\n$d$. Check if the signs fail to alternate. A failure is registered if $\\text{sign}(Z(g_n)) \\cdot \\text{sign}(Z(g_{n+1})) \\neq -1$. This condition correctly captures cases where the signs are identical (product is $1$) or where one of the values is numerically zero (product is $0$).\n$e$. If a failure is found for index $n$, that value is recorded as the result for the given range, and the search for that range terminates. If the loop completes without finding any failures, the result is recorded as $-1$.\n\nThis complete algorithmic design is implemented in the accompanying Python script, which processes the specified test cases and produces the required output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Computes the smallest index n of a Gram's law failure in given ranges.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10, 30),\n        (120, 140),\n        (500, 520),\n    ]\n\n    # Numerical tolerance for treating a value as zero\n    ZERO_TOLERANCE = 1e-9\n\n    memoized_theta = {}\n    \n    def theta(t: float) -> float:\n        \"\"\"\n        Asymptotic expansion for the Riemann-Siegel theta function.\n        \"\"\"\n        if t in memoized_theta:\n            return memoized_theta[t]\n        \n        if t <= 0:\n            return 0.0\n            \n        # Per the problem statement\n        t_inv = 1.0 / t\n        t_inv_3 = t_inv**3\n        t_inv_5 = t_inv**5\n        \n        term1 = t / 2.0 * np.log(t / (2.0 * np.pi))\n        term2 = -t / 2.0\n        term3 = -np.pi / 8.0\n        term4 = 1.0 / 48.0 * t_inv\n        term5 = 7.0 / 5760.0 * t_inv_3\n        term6 = 31.0 / 80640.0 * t_inv_5\n        \n        result = term1 + term2 + term3 + term4 + term5 + term6\n        memoized_theta[t] = result\n        return result\n\n    def theta_prime(t: float) -> float:\n        \"\"\"\n        Derivative of the asymptotic expansion for theta(t).\n        \"\"\"\n        if t <= 0:\n            return np.inf  # Avoid division by zero, effectively pushing solver away\n\n        t_inv_2 = 1.0 / (t * t)\n        t_inv_4 = t_inv_2 * t_inv_2\n        t_inv_6 = t_inv_4 * t_inv_2\n\n        term1 = 0.5 * np.log(t / (2.0 * np.pi))\n        term2 = -1.0 / (48.0) * t_inv_2\n        term3 = -7.0 / (1920.0) * t_inv_4\n        term4 = -31.0 / (16128.0) * t_inv_6\n        \n        return term1 + term2 + term3 + term4\n\n    memoized_gram_points = {}\n    \n    def find_gram_point(n: int) -> float:\n        \"\"\"\n        Finds the n-th Gram point g_n by solving theta(t) = n*pi.\n        \"\"\"\n        if n in memoized_gram_points:\n            return memoized_gram_points[n]\n\n        # Objective function for root finding: f(t) = theta(t) - n*pi\n        func = lambda t: theta(t) - n * np.pi\n        \n        # Derivative of the objective function\n        fprime = theta_prime\n        \n        # Initial guess from inverting the leading term of theta(t)\n        # t/2*log(t/(2*pi)) ~ n*pi => x*log(x) ~ n where x=t/(2*pi)\n        # For large n, t ~ 2*pi*n / log(n)\n        if n > 1:\n            t_guess = 2 * np.pi * n / np.log(n)\n        else: # Heuristic for small n where log(n) is problematic\n            t_guess = 20.0 \n\n        # Use Scipy's Newton-Raphson solver\n        gram_point = newton(func, t_guess, fprime=fprime, tol=1e-12, maxiter=100)\n        memoized_gram_points[n] = gram_point\n        return gram_point\n\n    memoized_z_values = {}\n\n    def Z_func(t: float) -> float:\n        \"\"\"\n        Approximates the Hardy Z-function using the truncated Riemann-Siegel main sum.\n        \"\"\"\n        if t in memoized_z_values:\n            return memoized_z_values[t]\n\n        N = int(np.sqrt(t / (2.0 * np.pi)))\n        if N == 0:\n            return 0.0\n\n        theta_val = theta(t)\n        \n        k_vals = np.arange(1, N + 1)\n        \n        terms = (1.0 / np.sqrt(k_vals)) * np.cos(theta_val - t * np.log(k_vals))\n        total_sum = np.sum(terms)\n        \n        result = 2.0 * total_sum\n        memoized_z_values[t] = result\n        return result\n\n    def get_sign(value: float) -> int:\n        \"\"\"\n        Determines the sign of a value, treating small values as zero.\n        \"\"\"\n        if value > ZERO_TOLERANCE:\n            return 1\n        elif value < -ZERO_TOLERANCE:\n            return -1\n        else:\n            return 0\n\n    results = []\n    for n_start, n_end in test_cases:\n        found_failure_index = -1\n        for n in range(n_start, n_end):\n            # We need to evaluate Z at g_n and g_{n+1}\n            g_n = find_gram_point(n)\n            g_n_plus_1 = find_gram_point(n + 1)\n\n            z_n = Z_func(g_n)\n            z_n_plus_1 = Z_func(g_n_plus_1)\n\n            sign_n = get_sign(z_n)\n            sign_n_plus_1 = get_sign(z_n_plus_1)\n\n            # A failure occurs if signs do not alternate\n            if sign_n * sign_n_plus_1 != -1:\n                found_failure_index = n\n                break\n        \n        results.append(found_failure_index)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3031532"}]}