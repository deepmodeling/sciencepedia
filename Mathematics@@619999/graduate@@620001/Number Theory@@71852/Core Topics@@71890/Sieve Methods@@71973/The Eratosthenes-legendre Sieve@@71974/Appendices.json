{"hands_on_practices": [{"introduction": "To truly grasp the Eratosthenes-Legendre sieve, we must first move beyond abstract formulas and see it in action. This practice grounds the theory in a concrete, manageable calculation, revealing the core inclusion-exclusion mechanism. By manually sifting the integers up to $x=50$ and comparing the result with the formal sum involving the Möbius function, you will build a foundational intuition for how the sieve operates on a tangible set of numbers [@problem_id:3025971].", "problem": "Let $\\mathcal{A} = \\{n \\in \\mathbb{N} : 1 \\leq n \\leq x\\}$ and let $\\mathcal{P}$ denote the set of prime numbers. For a real parameter $z > 1$, define the Eratosthenes–Legendre sieve quantity\n$$\nS(\\mathcal{A}, \\mathcal{P}, z) := \\left|\\left\\{n \\in \\mathcal{A} : p \\nmid n \\text{ for all primes } p \\in \\mathcal{P} \\text{ with } p < z \\right\\}\\right|.\n$$\nStarting from fundamental definitions of divisibility and the Möbius function $\\mu(n)$ (defined by $\\mu(1) = 1$, $\\mu(n) = 0$ if $n$ is divisible by a square, and $\\mu(n) = (-1)^{\\omega(n)}$ if $n$ is squarefree with $\\omega(n)$ distinct prime factors), derive a first-principles expression for $S(\\mathcal{A}, \\mathcal{P}, z)$ when $\\mathcal{A} = \\{1,2,\\dots,x\\}$ in terms of an inclusion–exclusion sum over the squarefree divisors of the product of the primes less than $z$. Then, evaluate $S(\\mathcal{A}, \\mathcal{P}, z)$ for the specific values $x = 50$ and $z = 7$, and explicitly list the integers in $\\{1,2,\\dots,50\\}$ that are counted by $S(\\mathcal{A}, \\mathcal{P}, 7)$. Your final reported quantity should be the exact value of $S(\\mathcal{A}, \\mathcal{P}, 7)$. No rounding is required.", "solution": "We first restate the quantity of interest. For $\\mathcal{A} = \\{1,2,\\dots,x\\}$ and $z > 1$, the set counted by $S(\\mathcal{A}, \\mathcal{P}, z)$ consists of those $n \\leq x$ which are not divisible by any prime strictly less than $z$. Let\n$$\nM(z) := \\prod_{p \\in \\mathcal{P},\\, p < z} p,\n$$\nthe product of the primes below $z$. Then the condition “no prime $p < z$ divides $n$” is equivalent to $\\gcd(n, M(z)) = 1$.\n\nA standard sieve identity stemming from the inclusion–exclusion principle and Möbius inversion expresses the coprimality indicator in terms of the Möbius function:\n$$\n\\mathbf{1}_{\\gcd(n, M(z)) = 1} = \\sum_{d \\mid \\gcd(n, M(z))} \\mu(d) = \\sum_{\\substack{d \\mid M(z) \\\\ d \\mid n}} \\mu(d).\n$$\nThis follows from the multiplicativity of the Möbius function and the identity\n$$\n\\sum_{d \\mid m} \\mu(d) =\n\\begin{cases}\n1 & \\text{if } m = 1, \\\\\n0 & \\text{if } m > 1,\n\\end{cases}\n$$\ncombined with $m = \\gcd(n, M(z))$. Summing over $n \\leq x$ yields\n$$\nS(\\mathcal{A}, \\mathcal{P}, z) = \\sum_{n \\leq x} \\sum_{\\substack{d \\mid M(z) \\\\ d \\mid n}} \\mu(d)\n= \\sum_{d \\mid M(z)} \\mu(d) \\sum_{\\substack{n \\leq x \\\\ d \\mid n}} 1\n= \\sum_{d \\mid M(z)} \\mu(d) \\left\\lfloor \\frac{x}{d} \\right\\rfloor.\n$$\nThis is the Eratosthenes–Legendre sieve’s inclusion–exclusion evaluation of the sifted set size at level $z$ for the interval $\\{1,\\dots,x\\}$.\n\nWe now specialize to $x = 50$ and $z = 7$. The primes strictly less than $z = 7$ are $2$, $3$, and $5$, so\n$$\nM(7) = 2 \\cdot 3 \\cdot 5 = 30.\n$$\nThe squarefree divisors $d$ of $30$ are $1$, $2$, $3$, $5$, $6$, $10$, $15$, and $30$. Their Möbius values are\n$$\n\\mu(1) = 1,\\quad \\mu(2) = -1,\\quad \\mu(3) = -1,\\quad \\mu(5) = -1,\\quad \\mu(6) = 1,\\quad \\mu(10) = 1,\\quad \\mu(15) = 1,\\quad \\mu(30) = -1.\n$$\nTherefore,\n\\begin{align*}\nS(\\mathcal{A}, \\mathcal{P}, 7)\n&= \\mu(1)\\left\\lfloor \\frac{50}{1} \\right\\rfloor\n+ \\mu(2)\\left\\lfloor \\frac{50}{2} \\right\\rfloor\n+ \\mu(3)\\left\\lfloor \\frac{50}{3} \\right\\rfloor\n+ \\mu(5)\\left\\lfloor \\frac{50}{5} \\right\\rfloor \\\\\n&\\quad + \\mu(6)\\left\\lfloor \\frac{50}{6} \\right\\rfloor\n+ \\mu(10)\\left\\lfloor \\frac{50}{10} \\right\\rfloor\n+ \\mu(15)\\left\\lfloor \\frac{50}{15} \\right\\rfloor\n+ \\mu(30)\\left\\lfloor \\frac{50}{30} \\right\\rfloor \\\\\n&= 1 \\cdot 50\n+ (-1) \\cdot 25\n+ (-1) \\cdot 16\n+ (-1) \\cdot 10\n+ 1 \\cdot 8\n+ 1 \\cdot 5\n+ 1 \\cdot 3\n+ (-1) \\cdot 1 \\\\\n&= 50 - 25 - 16 - 10 + 8 + 5 + 3 - 1 \\\\\n&= 14.\n\\end{align*}\n\nTo interpret this and explicitly list the counted integers, observe that the condition is “no divisibility by $2$, $3$, or $5$,” i.e., being coprime to $30$. The residues modulo $30$ that are coprime to $30$ are $1$, $7$, $11$, $13$, $17$, $19$, $23$, and $29$, and hence the integers in $\\{1,\\dots,50\\}$ counted by $S(\\mathcal{A}, \\mathcal{P}, 7)$ are\n$$\n1,\\, 7,\\, 11,\\, 13,\\, 17,\\, 19,\\, 23,\\, 29,\\, 31,\\, 37,\\, 41,\\, 43,\\, 47,\\, 49,\n$$\nwhich confirms that there are exactly $14$ such integers.\n\nThus, the exact value is $S(\\mathcal{A}, \\mathcal{P}, 7) = 14$ for $x = 50$.", "answer": "$$\\boxed{14}$$", "id": "3025971"}, {"introduction": "While manual calculation is instructive, the true power of sieve methods lies in their application to large numbers, which demands computational efficiency. This exercise confronts the scaling problem head-on by contrasting a naive, brute-force summation with a more elegant and powerful recursive algorithm [@problem_id:3025969]. By quantifying the dramatic reduction in complexity, you will appreciate why algorithmic advances are essential for turning sieve theory from a combinatorial curiosity into a practical instrument for research in number theory.", "problem": "Let $x$ and $z$ be positive integers. Let $P(z)$ denote the product of all prime numbers $p$ with $p \\leq z$. Define $S(x,z)$ to be the number of integers $n$ with $1 \\leq n \\leq x$ such that $\\gcd(n,P(z)) = 1$, where $\\gcd$ denotes the greatest common divisor. The Eratosthenes–Legendre sieve counts $S(x,z)$ by systematically excluding multiples of primes up to $z$.\n\nFrom fundamental combinatorial principles, the inclusion–exclusion principle counts $S(x,z)$ by summing over squarefree divisors of $P(z)$, weighted by the Möbius function $\\mu(d)$, and using the integer part $\\lfloor x/d \\rfloor$. A direct or naive implementation iterates over all divisors $d$ with $d \\mid P(z)$ and checks the contribution of each $d$.\n\nAn alternative method uses a recursion over primes. Let the primes up to $z$ be ordered as $p_1 < p_2 < \\cdots < p_a$, where $a = \\pi(z)$ is the prime-counting function restricted to $z$. Define the function $\\phi(x,a)$ to count integers $n$ with $1 \\leq n \\leq x$ not divisible by any of $p_1,\\dots,p_a$. The recursive method computes $\\phi(x,a)$ by descending on $a$ and reducing $x$ by division by primes, thereby avoiding terms that would contribute $\\lfloor x/d \\rfloor = 0$ and enabling pruning.\n\nYour task is to implement and compare two computational strategies that both produce $S(x,z)$, but whose measured complexity differs:\n\n1. A naive inclusion–exclusion iteration over all $d$ with $d \\mid P(z)$. As a complexity proxy for this method, define $C_{\\mathrm{naive}}(x,z)$ to be the number of squarefree divisors of $P(z)$ iterated over in the naive process. For this task, you should compute $C_{\\mathrm{naive}}(x,z)$ exactly as the number of distinct squarefree $d$ that divide $P(z)$.\n\n2. A recursion over primes as in the Eratosthenes–Legendre sieve. As a complexity proxy for this method, define $C_{\\mathrm{rec}}(x,z)$ to be the number of distinct recursive states $\\phi(t,b)$ that are evaluated during the computation of $\\phi(x,a)$, where $t$ is a nonnegative integer and $b$ is an integer with $0 \\leq b \\leq a$. Count each distinct pair $(t,b)$ exactly once, with memoization ensuring no repeated evaluation of identical states.\n\nQuantify the reduction in computational complexity by computing the ratio\n$$\nR(x,z) = \\frac{C_{\\mathrm{naive}}(x,z)}{C_{\\mathrm{rec}}(x,z)}.\n$$\nThis ratio is a real number and indicates how many times fewer distinct states the recursive method visits compared to the naive enumeration of all $d \\mid P(z)$.\n\nImplement a program that:\n- Generates all primes up to $z$ using the classical sieve of Eratosthenes.\n- Computes $C_{\\mathrm{naive}}(x,z)$ as the number of squarefree divisors of $P(z)$.\n- Computes $C_{\\mathrm{rec}}(x,z)$ as the number of distinct states $(t,b)$ evaluated in the recursive computation of $\\phi(x,a)$, using memoization to avoid repeated work.\n- Returns the ratio $R(x,z)$ as a floating-point number for each test case.\n\nUse the following test suite of $(x,z)$ pairs:\n- $(x,z) = (10^6, 50)$: a general case with large $x$ and moderately large $z$.\n- $(x,z) = (100, 50)$: a case where pruning should be significant due to small $x$ and large $z$.\n- $(x,z) = (100, 5)$: a case with small $x$ and small $z$.\n- $(x,z) = (1, 50)$: an extreme edge case where recursion should prune almost immediately.\n- $(x,z) = (10^4, 30)$: a balanced intermediate case.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order of the test suite listed above, that is,\n$$\n[R(10^6,50), R(100,50), R(100,5), R(1,50), R(10^4,30)].\n$$\nAll outputs must be real numbers with no units. No angles or physical units are involved in this problem.", "solution": "The problem asks for a quantitative comparison of the computational complexity of two methods for calculating $S(x,z)$, which is the count of integers $n$ in the range $1 \\leq n \\leq x$ that are coprime to $P(z)$, the product of all primes $p \\leq z$. The comparison is formulated as the ratio $R(x,z) = C_{\\mathrm{naive}}(x,z) / C_{\\mathrm{rec}}(x,z)$, where $C_{\\mathrm{naive}}$ and $C_{\\mathrm{rec}}$ are complexity proxies for a naive inclusion-exclusion method and a recursive method, respectively.\n\nLet the set of prime numbers less than or equal to $z$ be $\\{p_1, p_2, \\dots, p_a\\}$, where $a = \\pi(z)$ is the prime-counting function. The condition $\\gcd(n, P(z)) = 1$ is equivalent to stating that $n$ is not divisible by any prime $p_i$ for $1 \\leq i \\leq a$.\n\n### Method 1: Naive Inclusion-Exclusion and its Complexity $C_{\\mathrm{naive}}(x,z)$\n\nThe principle of inclusion-exclusion provides a direct formula for $S(x,z)$. The total number of integers in $[1, x]$ is $\\lfloor x \\rfloor$. From this, we subtract the counts of integers divisible by each prime $p_i$, add back the counts of integers divisible by each product $p_i p_j$, and so on. This can be expressed compactly using the Möbius function $\\mu(d)$:\n$$\nS(x,z) = \\sum_{d \\mid P(z)} \\mu(d) \\left\\lfloor \\frac{x}{d} \\right\\rfloor\n$$\nThe divisors $d$ of $P(z) = p_1 p_2 \\cdots p_a$ are precisely the squarefree integers whose prime factors are a subset of $\\{p_1, \\dots, p_a\\}$. A naive implementation would iterate through all such divisors $d$.\n\nThe problem defines the complexity proxy $C_{\\mathrm{naive}}(x,z)$ as the total number of squarefree divisors of $P(z)$. Each such divisor is formed by choosing a subset of the $a$ primes $\\{p_1, \\dots, p_a\\}$ and taking their product. The number of subsets of a set of size $a$ is $2^a$. Therefore, the number of terms in the sum, and thus the complexity proxy, is:\n$$\nC_{\\mathrm{naive}}(x,z) = 2^a = 2^{\\pi(z)}\n$$\nNote that this complexity measure is independent of the value of $x$. It depends only on $z$.\n\n### Method 2: Recursive Sieve (Eratosthenes-Legendre) and its Complexity $C_{\\mathrm{rec}}(x,z)$\n\nAn alternative approach is to define a function $\\phi(t, k)$ that counts the integers $n$ with $1 \\leq n \\leq t$ that are not divisible by any of the first $k$ primes $\\{p_1, \\dots, p_k\\}$. With this definition, $S(x,z) = \\phi(x, a)$, where $a = \\pi(z)$.\n\nThe function $\\phi(t,k)$ can be defined by the following recurrence relation:\n$$\n\\phi(t, k) = \\phi(t, k-1) - \\phi\\left(\\left\\lfloor \\frac{t}{p_k} \\right\\rfloor, k-1\\right)\n$$\nThe logic is as follows: $\\phi(t, k-1)$ counts integers up to $t$ not divisible by the first $k-1$ primes. From this count, we must subtract those that are divisible by $p_k$. An integer divisible by $p_k$ is of the form $m \\cdot p_k$. For $m \\cdot p_k \\leq t$, we must have $m \\leq \\lfloor t/p_k \\rfloor$. The number of such integers $m \\cdot p_k$ that are not divisible by any of $\\{p_1, \\dots, p_{k-1}\\}$ is equivalent to the number of integers $m \\leq \\lfloor t/p_k \\rfloor$ that are not divisible by any of $\\{p_1, \\dots, p_{k-1}\\}$. This count is precisely $\\phi(\\lfloor t/p_k \\rfloor, k-1)$.\n\nThe base cases for the recursion are:\n-   $\\phi(t, 0) = \\lfloor t \\rfloor$: When sieving with zero primes, all integers up to $t$ are counted. Since $t$ is an integer in this context, this is simply $t$.\n-   $\\phi(0, k) = 0$: There are no integers in the range $[1, 0]$. This case provides a crucial termination condition for the recursion. When $\\lfloor t/p_k \\rfloor$ becomes $0$, the corresponding recursive branch is pruned.\n\nThe complexity proxy $C_{\\mathrm{rec}}(x,z)$ is defined as the number of distinct states $(t, k)$ evaluated during the computation of $\\phi(x, a)$. To avoid re-computing for the same state, memoization is used. $C_{\\mathrm{rec}}(x,z)$ is therefore the number of entries stored in the memoization table. Each state $(t, k)$ corresponds to a unique node in the directed acyclic graph of the computation. The value of $t$ is always of the form $\\lfloor x/d \\rfloor$ for some squarefree $d$. The pruning mechanism is effective when many divisors $d$ of $P(z)$ exceed $x$, as the terms $\\lfloor x/d \\rfloor$ become $0$, and the recursive calls terminate immediately.\n\n### Implementation Plan\n\nThe overall algorithm proceeds as follows for each test case $(x,z)$:\n1.  Generate all primes up to the maximum $z$ value in the test suite using a sieve of Eratosthenes. For a given $z$, select the primes $p \\leq z$.\n2.  Calculate $a = \\pi(z)$, the number of primes up to $z$.\n3.  Compute $C_{\\mathrm{naive}}(x,z) = 2^a$.\n4.  Implement the recursive function $\\phi(t,k)$ with memoization. The state will be represented by a pair $(t, k)$. A set will be used to track all unique states encountered.\n5.  Initiate the recursive computation with the call $\\phi(x, a)$.\n6.  Compute $C_{\\mathrm{rec}}(x,z)$ as the final size of the set of visited states.\n7.  Calculate the ratio $R(x,z) = C_{\\mathrm{naive}}(x,z) / C_{\\mathrm{rec}}(x,z)$.\n\nThis procedure is repeated for all provided test cases, and the resulting ratios are collected.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares two computational strategies for counting integers\n    coprime to a product of primes, based on the Eratosthenes-Legendre sieve.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10**6, 50),\n        (100, 50),\n        (100, 5),\n        (1, 50),\n        (10**4, 30),\n    ]\n\n    # Find the maximum z to generate all necessary primes at once.\n    max_z = 0\n    if test_cases:\n        max_z = max(case[1] for case in test_cases)\n\n    def sieve(n):\n        \"\"\"Generates a list of prime numbers up to n using the Sieve of Eratosthenes.\"\"\"\n        primes = []\n        is_prime = [True] * (n + 1)\n        if n >= 0:\n            is_prime[0] = False\n        if n >= 1:\n            is_prime[1] = False\n        for p in range(2, n + 1):\n            if is_prime[p]:\n                primes.append(p)\n                for i in range(p * p, n + 1, p):\n                    is_prime[i] = False\n        return primes\n\n    all_primes = sieve(max_z)\n    \n    results = []\n    \n    for x, z in test_cases:\n        # Filter primes for the current z value\n        primes_for_z = [p for p in all_primes if p = z]\n        a = len(primes_for_z)\n\n        # 1. Compute C_naive(x, z)\n        # This is the number of squarefree divisors of P(z), which is 2^pi(z).\n        # We use integer exponentiation to avoid float issues.\n        c_naive = 1  a\n\n        # 2. Compute C_rec(x, z)\n        memo = {}\n        visited_states = set()\n\n        def phi(t, k):\n            \"\"\"\n            Recursive function for Legendre's sieve.\n            t: upper bound of integers to count.\n            k: number of primes to sieve by (from the first k primes).\n            \"\"\"\n            state = (t, k)\n            visited_states.add(state)\n\n            if state in memo:\n                return memo[state]\n\n            if k == 0:\n                return t\n            \n            # This pruning is a natural consequence of the recursion:\n            # phi(0, k) will call phi(0, k-1) - phi(0, k-1) = 0\n            # but memoizing it after the first call is efficient.\n            if t == 0:\n                memo[state] = 0\n                return 0\n\n            # Recurrence relation: phi(t, k) = phi(t, k-1) - phi(t/p_k, k-1)\n            # primes_for_z is 0-indexed, so p_k is primes_for_z[k-1].\n            res = phi(t, k - 1) - phi(t // primes_for_z[k - 1], k - 1)\n            memo[state] = res\n            return res\n\n        # Initial call to compute phi(x, a)\n        phi(x, a)\n        c_rec = len(visited_states)\n\n        # 3. Compute the ratio R(x, z)\n        # c_rec will not be 0 as long as a>=0 and x>=1. The state (x,a) is always visited.\n        ratio = float(c_naive) / float(c_rec)\n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3025969"}, {"introduction": "In analytic number theory, we often approximate exact counts with continuous densities, and a key computational challenge lies in evaluating the resulting sums efficiently. This practice explores how the fundamental property of multiplicativity transforms a seemingly intractable sum over divisors into a simple, elegant product over primes [@problem_id:3025989]. Mastering this technique is not just an exercise in algebraic manipulation; it is an essential step toward understanding the Euler product formulas that are ubiquitous in the study of prime numbers and their distribution.", "problem": "Let $z$ be a positive integer and let $P(z)$ denote the product of all prime numbers less than or equal to $z$, i.e., $P(z)=\\prod_{p\\le z}p$. Consider the arithmetic function $\\mu$, the Möbius function, defined on the positive integers by $\\mu(1)=1$, $\\mu(n)=0$ if $n$ has a squared prime divisor, and $\\mu(n)=(-1)^k$ if $n$ is a product of $k$ distinct primes. Define the sum\n$$\nS(z)=\\sum_{d\\mid P(z)}\\frac{\\mu(d)}{d}.\n$$\nThis sum arises naturally in the combinatorial formulation of the Eratosthenes-Legendre sieve (ELS) when reweighting contributions of residue classes to estimate the count of integers not divisible by small primes.\n\nStarting from the following fundamental base:\n- The Möbius function $\\mu$ is multiplicative, meaning $\\mu(ab)=\\mu(a)\\mu(b)$ whenever $\\gcd(a,b)=1$.\n- The function $f(n)=\\mu(n)/n$ is multiplicative, since the quotient of two multiplicative functions is multiplicative at arguments that are coprime.\n- If $f$ is multiplicative, then for any finite set of pairwise coprime integers $\\{n_i\\}$, one has $\\sum_{d\\mid \\prod_i n_i} f(d)=\\prod_i \\left(\\sum_{e\\mid n_i} f(e)\\right)$, which is a restatement of multiplicativity over divisor sums.\n- If $p$ is prime then the only divisors of $p$ are $1$ and $p$, hence $\\sum_{e\\mid p} f(e)=f(1)+f(p)$.\n\nYour tasks are:\n1. Derive, from first principles using only the stated base, an identity for $S(z)$ that expresses $S(z)$ as a finite product over the primes less than or equal to $z$. The derivation must be purely mathematical and explain clearly what the identity is, why it holds, and how it follows from multiplicativity and the structure of $P(z)$.\n2. Explain how the derived identity eliminates the need to iterate over all divisors $d$ of $P(z)$, and why this leads to a computationally efficient algorithm within the Eratosthenes-Legendre sieve framework.\n3. Implement a complete, runnable program that:\n   - Generates all primes less than or equal to $z$ using the classical sieve of Eratosthenes.\n   - Computes $S(z)$ using the product identity over primes derived in Task 1, without iterating over all divisors $d$.\n   - Produces floating-point results rounded to $12$ decimal places, expressed as decimal fractions.\n\nTest suite and output specification:\n- Use the following test suite of input values for $z$: $z\\in\\{1,2,10,1000,100000\\}$.\n- For each $z$ in the test suite, output the value of $S(z)$ as a float rounded to $12$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4,r_5]$), where $r_i$ corresponds to the result for the $i$-th test case in the order specified above.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in number theory, well-posed, and objective. The provided definitions and fundamental principles are sufficient to derive the requested identity and implement the corresponding algorithm.\n\nThe problem asks for a derivation of an identity for the sum $S(z) = \\sum_{d\\mid P(z)}\\frac{\\mu(d)}{d}$, an explanation of its computational utility, and an implementation of an algorithm based on this identity. Here, $z$ is a positive integer, $P(z) = \\prod_{p \\le z} p$ is the primorial of $z$, and $\\mu$ is the Möbius function.\n\n### Task 1: Derivation of the Identity for $S(z)$\n\nThe starting point is the definition of the sum:\n$$\nS(z) = \\sum_{d\\mid P(z)}\\frac{\\mu(d)}{d}\n$$\nLet us define an arithmetic function $f(n) = \\frac{\\mu(n)}{n}$. The problem statement correctly identifies this function as multiplicative. This is because both the Möbius function $\\mu(n)$ and the identity function $g(n)=n$ are multiplicative, and the quotient of two multiplicative functions is itself multiplicative. With this definition, the sum becomes:\n$$\nS(z) = \\sum_{d\\mid P(z)} f(d)\n$$\nThe number $P(z)$ is the product of all distinct primes less than or equal to $z$. Let these primes be denoted by $p_1, p_2, \\dots, p_k$, where $p_i \\le z$ for all $i=1, \\dots, k$. Thus, $P(z) = p_1 p_2 \\cdots p_k$. The primes $p_1, \\dots, p_k$ are, by definition, pairwise coprime.\n\nThe problem provides a fundamental property of sums of multiplicative functions over divisors: if $f$ is a multiplicative function and $\\{n_i\\}$ is a finite set of pairwise coprime integers, then\n$$\n\\sum_{d\\mid \\prod_i n_i} f(d)=\\prod_i \\left(\\sum_{e\\mid n_i} f(e)\\right)\n$$\nWe apply this property to our sum $S(z)$, where the set of pairwise coprime integers is the set of primes less than or equal to $z$. This yields:\n$$\nS(z) = \\sum_{d\\mid \\prod_{p\\le z} p} f(d) = \\prod_{p\\le z} \\left(\\sum_{e\\mid p} f(e)\\right)\n$$\nThe next step is to evaluate the inner sum, $\\sum_{e\\mid p} f(e)$, for a single prime $p$. The divisors of a prime number $p$ are precisely $1$ and $p$. Therefore, the sum over these divisors is:\n$$\n\\sum_{e\\mid p} f(e) = f(1) + f(p)\n$$\nWe now evaluate $f(1)$ and $f(p)$ using the definition $f(n) = \\mu(n)/n$ and the properties of the Möbius function:\n1. For $n=1$, $\\mu(1) = 1$. Thus, $f(1) = \\frac{\\mu(1)}{1} = \\frac{1}{1} = 1$.\n2. For a prime $n=p$, $p$ is a product of $k=1$ distinct primes. By definition, $\\mu(p) = (-1)^1 = -1$. Thus, $f(p) = \\frac{\\mu(p)}{p} = \\frac{-1}{p}$.\n\nSubstituting these values back into the expression for the sum over the divisors of $p$:\n$$\n\\sum_{e\\mid p} f(e) = 1 + \\left(-\\frac{1}{p}\\right) = 1 - \\frac{1}{p}\n$$\nFinally, we substitute this result for the inner sum back into the product expression for $S(z)$. This gives the desired identity:\n$$\nS(z) = \\prod_{p\\le z} \\left(1 - \\frac{1}{p}\\right)\n$$\nThis identity expresses $S(z)$ as a finite product over the primes less than or equal to $z$, as required. This is a specific instance of an Euler product.\n\n### Task 2: Computational Efficiency Analysis\n\nThe derived identity $S(z) = \\prod_{p \\le z} \\left(1 - \\frac{1}{p}\\right)$ provides a profound computational advantage over the direct evaluation of the sum $S(z) = \\sum_{d \\mid P(z)} \\frac{\\mu(d)}{d}$.\n\nLet $\\pi(z)$ denote the number of primes less than or equal to $z$.\nThe original formulation requires summing over all divisors $d$ of $P(z) = \\prod_{p \\le z} p$. Since $P(z)$ is the product of $\\pi(z)$ distinct primes, any divisor of $P(z)$ is formed by choosing a subset of these primes and multiplying them. The number of such subsets is $2^{\\pi(z)}$, which is therefore the number of divisors of $P(z)$.\nEvaluating the sum directly would involve an algorithm with the following structure:\n1. Find all $\\pi(z)$ primes up to $z$.\n2. Generate all $2^{\\pi(z)}$ divisors of $P(z)$.\n3. For each divisor $d$, compute $\\mu(d)$, perform the division $\\frac{\\mu(d)}{d}$, and add to a running total.\nThe number of terms, $2^{\\pi(z)}$, grows exponentially with the number of primes. For $z=1000$, $\\pi(1000) = 168$, leading to $2^{168} \\approx 3.7 \\times 10^{50}$ terms, which is computationally infeasible.\n\nIn contrast, the product identity leads to a much more efficient algorithm:\n1. Generate all $\\pi(z)$ primes $p$ less than or equal to $z$. This can be done efficiently using the Sieve of Eratosthenes, with a time complexity of approximately $O(z \\log \\log z)$.\n2. Initialize a product variable to $1.0$.\n3. Iterate through the list of $\\pi(z)$ primes. For each prime $p$, calculate the term $1 - \\frac{1}{p}$ and multiply it with the running product. This involves $\\pi(z)$ subtractions, $\\pi(z)$ divisions, and $\\pi(z)-1$ multiplications.\nThe complexity of the calculation, after the initial prime generation, is proportional to $\\pi(z)$, which is approximately $z/\\ln z$ by the Prime Number Theorem. This is a dramatic improvement from exponential complexity $O(2^{\\pi(z)})$ to a complexity that is essentially linear in the number of primes. For $z=100000$, with $\\pi(100000) = 9592$, the product involves fewer than $10000$ multiplications, a trivial task for a modern computer.\n\nThis transformation from an exponential-time summation to a near-linear-time product is a classic example of the power of number-theoretic identities in designing efficient algorithms. It is this efficiency that makes sieve methods like the Eratosthenes-Legendre sieve practical for counting primes or other similar sets of numbers.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes S(z) for a suite of test cases and prints the results.\n    S(z) is defined as the sum of mu(d)/d over divisors d of P(z),\n    where P(z) is the product of primes = z.\n    The computation uses the derived product identity: S(z) = product_{p=z} (1 - 1/p).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 10, 1000, 100000]\n\n    def sieve_of_eratosthenes(n: int) - list[int]:\n        \"\"\"\n        Generates all prime numbers up to n using the Sieve of Eratosthenes.\n        Uses numpy for efficient boolean array operations.\n\n        Args:\n            n: The upper limit for prime generation (inclusive).\n\n        Returns:\n            A list of prime numbers less than or equal to n.\n        \"\"\"\n        if n  2:\n            return []\n        \n        # Create a boolean array `is_prime` of size n+1, initialized to True.\n        # is_prime[i] will be False if i is not a prime, and True otherwise.\n        is_prime = np.ones(n + 1, dtype=bool)\n        \n        # 0 and 1 are not prime numbers.\n        is_prime[0:2] = False\n        \n        # Iterate from p = 2 up to sqrt(n).\n        for p in range(2, int(np.sqrt(n)) + 1):\n            if is_prime[p]:\n                # If p is prime, then all its multiples are not prime.\n                # We can start marking from p*p, as smaller multiples\n                # would have been marked by smaller primes.\n                is_prime[p*p::p] = False\n        \n        # Return the indices where is_prime is True.\n        return np.where(is_prime)[0].tolist()\n\n    def calculate_S_z(z: int) - float:\n        \"\"\"\n        Calculates S(z) using the product identity over primes.\n\n        Args:\n            z: The integer parameter defining the product range.\n\n        Returns:\n            The computed value of S(z) as a float.\n        \"\"\"\n        # For z  2, the set of primes is empty. The empty product is defined as 1.\n        if z  2:\n            return 1.0\n        \n        # Generate primes up to z.\n        primes = sieve_of_eratosthenes(z)\n        \n        # Compute the product S(z) = product_{p=z} (1 - 1/p).\n        s_z = 1.0\n        for p in primes:\n            s_z *= (1.0 - 1.0 / p)\n            \n        return s_z\n\n    results = []\n    for z in test_cases:\n        # Calculate S(z) for the current test case.\n        result = calculate_S_z(z)\n        \n        # Round the result to 12 decimal places as specified.\n        rounded_result = round(result, 12)\n        results.append(rounded_result)\n\n    # Format the final output as a single-line, comma-separated list in brackets.\n    # The map(str, ...) converts each float to its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3025989"}]}