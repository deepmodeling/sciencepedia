{"hands_on_practices": [{"introduction": "The Margulis lemma is often stated for manifolds with sectional curvature normalized, for instance, between $-1$ and $0$. This exercise explores the crucial relationship between the geometry of an arbitrary negatively curved manifold and its normalized counterpart. It demonstrates how fundamental geometric thresholds, like the Margulis constant defining the thin part, transform under a simple rescaling of the metric. By working through this calculation, you will gain a concrete understanding of how the curvature scale directly impacts the geometric size of the thick-thin decomposition, a vital skill for applying abstract theorems to specific geometric contexts.", "problem": "Let $(M,g)$ be a complete, connected, $n$-dimensional Riemannian manifold with sectional curvature $K_{g}$ satisfying $-b^{2} \\leq K_{g} \\leq 0$ for some fixed $b>0$. Consider the constant rescaling of the metric $\\bar{g}=\\frac{1}{b^{2}}\\,g$. Recall the following foundational facts:\n\n1. If a Riemannian metric is multiplied by a positive constant $c>0$, then lengths and distances scale by the factor $\\sqrt{c}$; that is, for any points $p,q \\in M$, one has $d_{c g}(p,q)=\\sqrt{c}\\,d_{g}(p,q)$.\n\n2. Under constant rescaling $g \\mapsto c g$, the sectional curvature scales by $K_{c g}=\\frac{1}{c}\\,K_{g}$.\n\n3. The Margulis lemma (in its nonpositive curvature form) guarantees the existence of a positive constant (a “Margulis constant”) for a given metric that controls the small-displacement part of the fundamental group: for any point $x \\in M$, the subgroup generated by deck transformations whose displacement at $x$ is below that constant is virtually nilpotent, and this gives rise to the thick-thin decomposition threshold. Concretely, let $\\mu_{\\bar{g}}>0$ denote any valid Margulis constant for $(M,\\bar{g})$, meaning that for each $x \\in M$ the subgroup generated by elements $\\gamma$ with $d^{\\bar{g}}_{x}(\\gamma):=d_{\\bar{g}}(x,\\gamma x)<\\mu_{\\bar{g}}$ is virtually nilpotent.\n\nUsing only the above scaling facts and the definition of the Margulis constant as a small-displacement threshold, derive the explicit closed-form analytic expression for the effective thin-part threshold $\\varepsilon_{g}$ for $(M,g)$ in terms of $b$ and $\\mu_{\\bar{g}}$. Your final answer must be a single expression and should not include any inequalities or units. No numerical rounding is required.", "solution": "The problem requires us to derive the expression for the thin-part threshold, denoted $\\varepsilon_{g}$, for a Riemannian manifold $(M,g)$ in terms of parameters related to a rescaled metric $\\bar{g} = \\frac{1}{b^2} g$. The derivation will rely solely on the provided scaling laws and the definition of the Margulis constant.\n\nLet $(M,g)$ be a complete, connected, $n$-dimensional Riemannian manifold with sectional curvature $K_{g}$ satisfying $-b^{2} \\leq K_{g} \\leq 0$ for a constant $b>0$.\nA new metric $\\bar{g}$ is defined by scaling the original metric $g$:\n$$\\bar{g} = \\frac{1}{b^{2}} g$$\nThis is a constant rescaling of the form $\\bar{g} = c g$, where the scaling constant is $c = \\frac{1}{b^{2}}$.\n\nThe problem introduces the Margulis constant for the rescaled metric, $\\mu_{\\bar{g}} > 0$. This constant defines the threshold for the \"thin part\" of the manifold with respect to the metric $\\bar{g}$. A point $x \\in M$ is in the thin part if there exists a non-trivial deck transformation $\\gamma \\in \\pi_{1}(M)$ such that its displacement at $x$ is less than $\\mu_{\\bar{g}}$. Mathematically, this condition is:\n$$d_{\\bar{g}}(x, \\gamma x) < \\mu_{\\bar{g}}$$\nHere, $d_{\\bar{g}}(p,q)$ represents the distance between points $p$ and $q$ in the metric $\\bar{g}$. The value $\\mu_{\\bar{g}}$ is the displacement threshold defining the thin region for the manifold $(M, \\bar{g})$.\n\nOur goal is to find the corresponding threshold, $\\varepsilon_{g}$, for the original manifold $(M,g)$. This means we must find the value $\\varepsilon_{g}$ such that the condition $d_{g}(x, \\gamma x) < \\varepsilon_{g}$ is equivalent to the condition $d_{\\bar{g}}(x, \\gamma x) < \\mu_{\\bar{g}}$.\n\nTo relate the two conditions, we use the given scaling law for distances (Fact 1): for any positive constant $c > 0$, the distance functions for the metrics $g$ and $cg$ are related by:\n$$d_{c g}(p,q) = \\sqrt{c} \\, d_{g}(p,q)$$\nIn our case, the scaling constant is $c = \\frac{1}{b^2}$. Applying this rule to our metrics $\\bar{g}$ and $g$, we get:\n$$d_{\\bar{g}}(p,q) = d_{\\frac{1}{b^2} g}(p,q) = \\sqrt{\\frac{1}{b^2}} \\, d_{g}(p,q)$$\nSince it is given that $b > 0$, we can simplify the square root:\n$$\\sqrt{\\frac{1}{b^2}} = \\frac{1}{|b|} = \\frac{1}{b}$$\nThis gives us a direct relationship between the two distance functions:\n$$d_{\\bar{g}}(p,q) = \\frac{1}{b} d_{g}(p,q)$$\nThis relation is valid for any two points, including $x$ and $\\gamma x$. Thus, for the displacement of a deck transformation $\\gamma$ at point $x$, we have:\n$$d_{\\bar{g}}(x, \\gamma x) = \\frac{1}{b} d_{g}(x, \\gamma x)$$\nNow we can substitute this expression into the thin-part condition for the metric $\\bar{g}$:\n$$d_{\\bar{g}}(x, \\gamma x) < \\mu_{\\bar{g}} \\implies \\frac{1}{b} d_{g}(x, \\gamma x) < \\mu_{\\bar{g}}$$\nTo find the condition in terms of the displacement $d_{g}(x, \\gamma x)$, we multiply both sides of the inequality by $b$. Since $b > 0$, the inequality direction is preserved:\n$$d_{g}(x, \\gamma x) < b \\mu_{\\bar{g}}$$\nThis inequality, $d_{g}(x, \\gamma x) < b \\mu_{\\bar{g}}$, defines the thin-part condition with respect to the original metric $g$. The problem asks for the effective thin-part threshold $\\varepsilon_{g}$ for $(M,g)$. By comparing our derived inequality with the general form $d_{g}(x, \\gamma x) < \\varepsilon_{g}$, we can directly identify $\\varepsilon_{g}$.\nThus, the threshold for the metric $g$ is:\n$$\\varepsilon_{g} = b \\mu_{\\bar{g}}$$\nThis is the explicit closed-form analytic expression for the thin-part threshold for $(M,g)$ in terms of the given quantities $b$ and $\\mu_{\\bar{g}}$.", "answer": "$$\\boxed{b \\mu_{\\bar{g}}}$$", "id": "3000746"}, {"introduction": "The Margulis lemma predicts that the thin parts of a hyperbolic manifold consist of cusp regions and tubular neighborhoods around short closed geodesics. This practice guides you through deriving the precise geometry of such a tube from first principles, using the powerful tool of Jacobi fields in a constant curvature setting. This exercise is fundamental for building a tangible intuition for the structure of thin parts, moving from an abstract statement to a concrete metric. Calculating the lengths of the core curves—the meridian and longitude—on the boundary torus reveals the anisotropic stretching of space near a short geodesic, a hallmark of hyperbolic geometry.", "problem": "Let $(M,g)$ be a complete orientable hyperbolic $3$–manifold of constant sectional curvature $-1$. Let $\\gamma \\subset M$ be a closed geodesic of length $\\ell > 0$, and fix a radius $r > 0$ smaller than the Margulis constant of $M$ so that the embedded Margulis tube $T_{r}(\\gamma) = \\{ p \\in M \\mid d(p,\\gamma) \\leq r \\}$ is well-defined. Denote by $S_{r}(\\gamma) = \\partial T_{r}(\\gamma)$ the boundary torus at hyperbolic distance $r$ from $\\gamma$. Assume that the holonomy along $\\gamma$ is purely hyperbolic (i.e., there is no rotational component about the axis of $\\gamma$), so that the local model around $\\gamma$ is given by a geodesic axis without twist.\n\nStarting from the definitions of the Riemannian exponential map, Fermi coordinates around a geodesic, and the Jacobi equation in constant curvature $-1$, derive the induced Riemannian metric on $S_{r}(\\gamma)$ by expressing it in the coordinates given by angular parameter $\\theta$ about the normal circle to $\\gamma$ and arclength parameter $t$ along $\\gamma$. Then, using only the resulting geometric structure, compute the exact lengths of the following two simple closed curves on $S_{r}(\\gamma)$:\n\n1. The meridian, defined as the loop obtained by fixing $t$ and letting $\\theta$ run once around the full angular range.\n2. The longitude, defined as the loop obtained by fixing $\\theta$ and letting $t$ run once along $\\gamma$.\n\nExpress the two lengths as closed-form analytic expressions in terms of $r$ and $\\ell$. No numerical approximation is required for the final answer.", "solution": "The problem requires the derivation of the induced metric on the boundary of a Margulis tube around a closed geodesic in a hyperbolic $3$-manifold, followed by the computation of the lengths of its meridian and longitude. The manifold $(M,g)$ has constant sectional curvature $K=-1$. Its universal cover is hyperbolic space, $\\mathbb{H}^3$. A closed geodesic $\\gamma \\subset M$ of length $\\ell$ lifts to a geodesic line $\\tilde{\\gamma} \\subset \\mathbb{H}^3$, and the tubular neighborhood $T_r(\\gamma)$ lifts to a tubular neighborhood of $\\tilde{\\gamma}$.\n\nWe can determine the metric by working in a coordinate system adapted to the geodesic $\\tilde{\\gamma}$. We use Fermi coordinates, generalized to a cylindrical-type system $(t, r, \\theta)$. Here, $t$ is the arclength parameter along the geodesic $\\tilde{\\gamma}$, $r$ is the geodesic distance from a point to $\\tilde{\\gamma}$, and $\\theta$ is the angular coordinate in the normal plane at a point on $\\tilde{\\gamma}$. A point $p \\in \\mathbb{H}^3$ in the neighborhood of $\\tilde{\\gamma}$ can be parametrized by\n$$p(t, r, \\theta) = \\exp_{\\tilde{\\gamma}(t)}(r N(t, \\theta))$$\nwhere $\\tilde{\\gamma}(t)$ is a unit-speed parametrization of the geodesic, and $N(t, \\theta)$ is a unit normal vector at $\\tilde{\\gamma}(t)$. The problem states that the holonomy around $\\gamma$ is purely hyperbolic, which implies there is no rotational twist. This allows us to define a parallel orthonormal frame $\\{E_1(t), E_2(t)\\}$ for the normal bundle along $\\tilde{\\gamma}$. Thus, we can write $N(t, \\theta) = \\cos(\\theta)E_1(t) + \\sin(\\theta)E_2(t)$.\n\nThe metric tensor $g$ is determined by the inner products of the tangent vectors to the coordinate curves: $\\frac{\\partial p}{\\partial t}$, $\\frac{\\partial p}{\\partial r}$, and $\\frac{\\partial p}{\\partial \\theta}$. These vectors can be analyzed using the theory of Jacobi fields. A Jacobi field $J(s)$ along a geodesic $\\alpha(s)$ measures the infinitesimal variation of a family of geodesics. For a space of constant sectional curvature $K=-1$, a Jacobi field $J(s)$ satisfies the Jacobi equation:\n$$J''(s) - J(s) = 0$$\nwhere the differentiation is with respect to the arclength parameter $s$ of the geodesic.\n\nLet's analyze the tangent vectors along a radial geodesic emanating from $\\tilde{\\gamma}(t)$, parametrized as $\\alpha(s) = \\exp_{\\tilde{\\gamma}(t)}(s N(t, \\theta))$ for $s \\in [0, r]$.\n\n1.  The vector $\\frac{\\partial p}{\\partial r}$ is the tangent vector to this radial geodesic $\\alpha(s)$ at $s=r$. By definition, it is a unit vector. Thus, $\\|\\frac{\\partial p}{\\partial r}\\|^2 = 1$. It is orthogonal to $\\frac{\\partial p}{\\partial t}$ and $\\frac{\\partial p}{\\partial \\theta}$ by Gauss's Lemma.\n\n2.  The vector $\\frac{\\partial p}{\\partial \\theta}$ at $p(t, r, \\theta)$ is a Jacobi field $J_\\theta(s)$ along $\\alpha(s)$. Its initial conditions at $s=0$ (i.e., at $\\tilde{\\gamma}(t)$) are:\n    $$J_\\theta(0) = \\frac{\\partial}{\\partial \\theta} \\exp_{\\tilde{\\gamma}(t)}(0 \\cdot N(t, \\theta)) = 0$$\n    $$J_\\theta'(0) = \\frac{D}{d\\theta} \\left(\\frac{d}{ds} \\exp_{\\tilde{\\gamma}(t)}(s N(t, \\theta))\\right)\\Big|_{s=0} = \\frac{\\partial N(t, \\theta)}{\\partial \\theta} = -\\sin(\\theta)E_1(t) + \\cos(\\theta)E_2(t)$$\n    The general solution to $J'' - J = 0$ is $J(s) = A \\cosh(s) + B \\sinh(s)$. The condition $J_\\theta(0)=0$ implies $A=0$. The condition $J_\\theta'(0) = B \\cosh(0) = B$ means $B = \\frac{\\partial N}{\\partial \\theta}$. So, $J_\\theta(s) = \\frac{\\partial N}{\\partial \\theta} \\sinh(s)$. At $s=r$, the norm is:\n    $$\\left\\|\\frac{\\partial p}{\\partial \\theta}\\right\\|^2 = \\|J_\\theta(r)\\|^2 = \\left\\| \\frac{\\partial N}{\\partial \\theta} \\sinh(r) \\right\\|^2 = \\sinh^2(r) \\left\\| \\frac{\\partial N}{\\partial \\theta} \\right\\|^2 = \\sinh^2(r)$$\n    since $\\|\\frac{\\partial N}{\\partial \\theta}\\| = \\|-\\sin(\\theta)E_1(t) + \\cos(\\theta)E_2(t)\\| = 1$.\n\n3.  The vector $\\frac{\\partial p}{\\partial t}$ at $p(t, r, \\theta)$ is a Jacobi field $J_t(s)$ along $\\alpha(s)$. Its initial conditions are:\n    $$J_t(0) = \\frac{\\partial}{\\partial t} \\exp_{\\tilde{\\gamma}(t)}(0 \\cdot N(t, \\theta)) = \\frac{d\\tilde{\\gamma}}{dt}(t) = \\tilde{\\gamma}'(t)$$\n    $$J_t'(0) = \\frac{D}{dt} \\left(\\frac{d}{ds} \\exp_{\\tilde{\\gamma}(t)}(s N(t, \\theta))\\right)\\Big|_{s=0} = \\frac{D}{dt} N(t, \\theta) = \\frac{D}{dt}(\\cos(\\theta)E_1(t) + \\sin(\\theta)E_2(t)) = 0$$\n    The condition $J_t'(0)=0$ holds because the frame $\\{E_1(t), E_2(t)\\}$ is parallel transported along $\\tilde{\\gamma}$ (this is the consequence of the \"no twist\" holonomy). The solution to $J'' - J = 0$ with $J_t(0)=\\tilde{\\gamma}'(t)$ and $J_t'(0)=0$ is $J_t(s) = \\tilde{\\gamma}'(t) \\cosh(s)$. At $s=r$, the norm is:\n    $$\\left\\|\\frac{\\partial p}{\\partial t}\\right\\|^2 = \\|J_t(r)\\|^2 = \\|\\tilde{\\gamma}'(t) \\cosh(r)\\|^2 = \\cosh^2(r) \\|\\tilde{\\gamma}'(t)\\|^2 = \\cosh^2(r)$$\n    since $\\tilde{\\gamma}(t)$ is a unit-speed geodesic.\n\nThe tangent vectors are mutually orthogonal. $\\langle \\frac{\\partial p}{\\partial r}, \\frac{\\partial p}{\\partial \\theta} \\rangle = 0$ and $\\langle \\frac{\\partial p}{\\partial r}, \\frac{\\partial p}{\\partial t} \\rangle = 0$ by Gauss's Lemma. The orthogonality $\\langle \\frac{\\partial p}{\\partial t}, \\frac{\\partial p}{\\partial \\theta} \\rangle = 0$ follows because the initial vectors $J_t(0)=\\tilde{\\gamma}'(t)$ and $J_\\theta'(0)=\\frac{\\partial N}{\\partial \\theta}$ are orthogonal, and their respective Jacobi evolutions preserve this orthogonality in this coordinate system.\n\nThe metric in the tubular neighborhood coordinates $(t,r,\\theta)$ is therefore diagonal:\n$$ds^2 = \\left\\|\\frac{\\partial p}{\\partial t}\\right\\|^2 dt^2 + \\left\\|\\frac{\\partial p}{\\partial r}\\right\\|^2 dr^2 + \\left\\|\\frac{\\partial p}{\\partial \\theta}\\right\\|^2 d\\theta^2 = \\cosh^2(r) dt^2 + dr^2 + \\sinh^2(r) d\\theta^2$$\nThe boundary of the Margulis tube $S_r(\\gamma)$ is the surface defined by holding the radius $r$ constant. The induced metric on this surface is obtained by setting $dr=0$:\n$$g_{S_r(\\gamma)} = \\cosh^2(r) dt^2 + \\sinh^2(r) d\\theta^2$$\nThis is the metric on the torus $S_r(\\gamma)$ with coordinates $t \\in [0, \\ell]$ and $\\theta \\in [0, 2\\pi]$.\n\nWe now compute the lengths of the specified curves.\n\n1.  **Length of the meridian ($L_m$)**: The meridian is defined by fixing $t$ (e.g., $t=t_0$) and letting $\\theta$ range from $0$ to $2\\pi$. The curve is parametrized by $c_m(\\theta) = (t_0, \\theta)$ for $\\theta \\in [0, 2\\pi]$. The tangent vector is $\\dot{c}_m(\\theta) = (0, 1)$ in $(t, \\theta)$ coordinates. The differential arclength is:\n    $$ds_m = \\sqrt{\\cosh^2(r) \\left(\\frac{dt}{d\\theta}\\right)^2 + \\sinh^2(r) \\left(\\frac{d\\theta}{d\\theta}\\right)^2} d\\theta = \\sqrt{\\cosh^2(r) \\cdot 0^2 + \\sinh^2(r) \\cdot 1^2} d\\theta = \\sinh(r) d\\theta$$\n    The total length is the integral:\n    $$L_m = \\int_{0}^{2\\pi} \\sinh(r) d\\theta = \\sinh(r) [\\theta]_{0}^{2\\pi} = 2\\pi\\sinh(r)$$\n\n2.  **Length of the longitude ($L_l$)**: The longitude is defined by fixing $\\theta$ (e.g., $\\theta=\\theta_0$) and letting $t$ range from $0$ to $\\ell$. The curve is parametrized by $c_l(t) = (t, \\theta_0)$ for $t \\in [0, \\ell]$. The tangent vector is $\\dot{c}_l(t) = (1, 0)$. The differential arclength is:\n    $$ds_l = \\sqrt{\\cosh^2(r) \\left(\\frac{dt}{dt}\\right)^2 + \\sinh^2(r) \\left(\\frac{d\\theta}{dt}\\right)^2} dt = \\sqrt{\\cosh^2(r) \\cdot 1^2 + \\sinh^2(r) \\cdot 0^2} dt = \\cosh(r) dt$$\n    The total length is the integral:\n    $$L_l = \\int_{0}^{\\ell} \\cosh(r) dt = \\cosh(r) [t]_{0}^{\\ell} = \\ell\\cosh(r)$$\n\nThus, the lengths of the meridian and longitude are $2\\pi\\sinh(r)$ and $\\ell\\cosh(r)$, respectively.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2\\pi\\sinh(r) & \\ell\\cosh(r)\n\\end{pmatrix}\n}\n$$", "id": "3000729"}, {"introduction": "While the theory of the thick-thin decomposition is elegant, its application often involves discrete data, such as a triangulated manifold from a computer simulation. This problem bridges the gap between continuous geometric theory and discrete computational practice. You will design an algorithm that applies the standard, simplified models for the injectivity radius within cusp and tubular neighborhoods to classify regions of a manifold. This computational exercise simulates a common task in modern geometric topology, translating the theoretical formulas for thin part geometry into a practical problem-solving tool for analyzing complex spaces.", "problem": "You are given a simplified discrete model of a triangulated complete hyperbolic $3$-manifold and asked to design and implement an algorithm to compute the $\\epsilon$-thick-thin decomposition based on the Margulis lemma. The decomposition splits the manifold into a thin part, where the injectivity radius is small, and a thick part, where the injectivity radius is bounded below. The fundamental base for this task consists of: (i) the definition of injectivity radius at a point of a Riemannian manifold as half the length of the shortest nontrivial geodesic loop based at that point, and (ii) the qualitative structure of thin components as predicted by the Margulis lemma, namely that for sufficiently small $\\epsilon$, the $\\epsilon$-thin part consists of neighborhoods of cusps and tubes around short closed geodesics. The model geometry for a cusp region is the product of a Euclidean $2$-torus with a ray, and the model geometry for a tubular neighborhood around a closed geodesic consists of a solid torus with hyperbolic metric, each providing lower bounds on the injectivity radius estimates via the geometry of horospherical cross-sections and meridional loops, respectively.\n\nInput model and algorithmic task:\n1. A triangulation is specified by a finite list of tetrahedra with vertex indices, and a list of vertex attributes. Each vertex has:\n   - Either a cusp attribute or none. The cusp attribute is modeled by a nonnegative height $h \\in \\mathbb{R}_{\\ge 0}$ measured along the cusp ray. The cusp cross-section at height $h$ is a Euclidean $2$-torus obtained from a base torus by exponential scaling in the ray direction.\n   - A list of distances to each short closed geodesic axis. For the $j$-th geodesic, the distance is $d_j \\in \\mathbb{R}_{\\ge 0}$.\n2. A base shortest slope length for the cusp cross-section at reference height $0$, denoted $L_0 \\in \\mathbb{R}_{>0}$.\n3. A list of lengths of short closed geodesics, denoted $\\ell_j \\in \\mathbb{R}_{>0}$ for $j=1,\\dots,k$.\n4. A positive parameter $\\epsilon \\in \\mathbb{R}_{>0}$.\n\nYour algorithm must, for each vertex, derive a lower bound estimate on the injectivity radius using:\n- The cusp model at height $h$ together with the base slope length $L_0$; the horospherical cross-section is a flat torus whose shortest primitive slope length scales with height, and the injectivity radius at the corresponding cusp point is half that shortest slope length.\n- The tubular model around a geodesic of length $\\ell_j$; the neighborhood at distance $d_j$ from the axis has a meridional loop, and also the loop obtained by projecting to the closed geodesic along the axis; the injectivity radius at such a point is half the length of the shortest of these relevant loops.\n\nBy combining these model-based lower bounds appropriately, define a per-vertex injectivity radius estimate. A vertex is classified as $\\epsilon$-thin if its injectivity radius is strictly less than $\\epsilon/2$, and otherwise as $\\epsilon$-thick. A tetrahedron is classified as $\\epsilon$-thin if at least one of its vertices is $\\epsilon$-thin, and otherwise as $\\epsilon$-thick.\n\nYour program must implement this classification on the following test suite, with explicit numerical parameters. In each case, report the list of indices of tetrahedra that are $\\epsilon$-thin, sorted in ascending order.\n\nTest Suite:\n- Case 1:\n  - $\\epsilon = 0.2$, $L_0 = 1.0$, one geodesic with length $\\ell_1 = 0.3$.\n  - Vertices (indexed $0$ through $6$):\n    - $v_0$: cusp height $h = 2.0$, distances $[d_1] = [0.3]$.\n    - $v_1$: cusp height $h = 0.5$, distances $[d_1] = [0.01]$.\n    - $v_2$: no cusp, distances $[d_1] = [0.4]$.\n    - $v_3$: no cusp, distances $[d_1] = [0.0]$.\n    - $v_4$: cusp height $h = 1.0$, distances $[d_1] = [1.0]$.\n    - $v_5$: no cusp, distances $[d_1] = [2.0]$.\n    - $v_6$: no cusp, distances $[d_1] = [3.0]$.\n  - Tetrahedra:\n    - $t_0 = [0,1,2,3]$, $t_1 = [1,2,4,3]$, $t_2 = [2,4,1,0]$, $t_3 = [2,4,5,6]$.\n\n- Case 2: Same triangulation and vertex data as Case 1, but $\\epsilon = 0.3$ and $L_0 = 1.0$.\n\n- Case 3:\n  - $\\epsilon = 0.08$, $L_0 = 1.2$, two geodesics with lengths $\\ell_1 = 0.2$, $\\ell_2 = 0.5$.\n  - Vertices (indexed $0$ through $7$):\n    - $v_0$: cusp height $h = 3.0$, distances $[d_1,d_2] = [0.2,2.0]$.\n    - $v_1$: no cusp, distances $[d_1,d_2] = [0.01,0.5]$.\n    - $v_2$: no cusp, distances $[d_1,d_2] = [0.3,0.3]$.\n    - $v_3$: no cusp, distances $[d_1,d_2] = [0.0,0.0]$.\n    - $v_4$: cusp height $h = 0.2$, distances $[d_1,d_2] = [1.0,0.7]$.\n    - $v_5$: no cusp, distances $[d_1,d_2] = [1.5,1.5]$.\n    - $v_6$: cusp height $h = 4.0$, distances $[d_1,d_2] = [0.5,0.5]$.\n    - $v_7$: no cusp, distances $[d_1,d_2] = [3.0,3.0]$.\n  - Tetrahedra:\n    - $t_0 = [0,1,2,3]$, $t_1 = [1,2,4,5]$, $t_2 = [2,4,5,3]$, $t_3 = [2,4,5,6]$, $t_4 = [2,4,5,7]$.\n\n- Case 4:\n  - $\\epsilon = 0.1$, $L_0 = 1.0$, no geodesics.\n  - Vertices (indexed $0$ through $3$): $v_0,v_1,v_2,v_3$ each have no cusp and an empty distance list.\n  - Tetrahedra:\n    - $t_0 = [0,1,2,3]$, $t_1 = [0,2,3,1]$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is the list of thin tetrahedron indices for the corresponding test case. For example, a valid output looks like $[[0,1],[2],[]]$ with no spaces in inner lists. Angles, if any, must be treated in radians; there are no physical units to report.", "solution": "The problem requires designing an algorithm to classify tetrahedra of a simplified hyperbolic 3-manifold model into an $\\epsilon$-thick or $\\epsilon$-thin part. The classification depends on an estimate of the injectivity radius at each vertex.\n\n**1. Injectivity Radius Estimation**\n\nThe injectivity radius, $r_{inj}$, is defined as half the length of the shortest non-trivial geodesic loop from a point. Our estimate, $r_{est}$, will be an upper bound on the true $r_{inj}$ by considering only a few families of loops based on the simplified model. A vertex $v$ is classified as $\\epsilon$-thin if $r_{est}(v) < \\epsilon/2$.\n\nThe estimate $r_{est}(v)$ for a vertex $v$ is the minimum of contributions from cusp and tubular neighborhood models:\n\n*   **Cusp Contribution**: For a vertex with cusp attribute height $h$, the shortest loop on the horospherical cross-section has length $L_{cusp}(h) = L_0 e^{-h}$. The corresponding radius estimate is:\n    $$r_{cusp} = \\frac{1}{2} L_0 e^{-h}$$\n    If a vertex has no cusp attribute, this contribution is effectively infinite.\n\n*   **Geodesic Contribution**: For a vertex at distance $d_j$ from a geodesic axis of length $\\ell_j$, we consider two types of loops: the loop homotopic to the geodesic axis and the shortest meridional loop. Their lengths in a constant curvature $-1$ model are $\\ell_j \\cosh(d_j)$ and $2\\pi \\sinh(d_j)$, respectively. The radius estimate contribution from this geodesic is:\n    $$r_{geo,j} = \\frac{1}{2} \\min(\\ell_j \\cosh(d_j), 2\\pi \\sinh(d_j))$$\n\nThe overall estimate for a vertex $v$ is the minimum of all possible contributions:\n$$r_{est}(v) = \\min\\left( r_{cusp}(v), \\min_{j} \\{ r_{geo,j}(v) \\} \\right)$$\n\n**2. Classification Algorithm**\n\n1.  For each vertex, calculate its injectivity radius estimate $r_{est}(v)$ using the formulas above.\n2.  Classify the vertex as $\\epsilon$-thin if $r_{est}(v) < \\epsilon/2$; otherwise, classify it as $\\epsilon$-thick.\n3.  Create a set of all indices of $\\epsilon$-thin vertices.\n4.  For each tetrahedron, check if any of its vertex indices are in the set of thin vertices.\n5.  If a tetrahedron contains at least one thin vertex, classify it as $\\epsilon$-thin.\n6.  Collect the indices of all $\\epsilon$-thin tetrahedra for each test case and sort them.\n\n**3. Test Case Results**\n\nApplying this algorithm to the provided test cases yields the following results:\n\n*   **Case 1 ($\\epsilon=0.2$, threshold=0.1):** Vertices 0, 1, and 3 are thin ($r_{est}(v_0) \\approx 0.068$, $r_{est}(v_1) \\approx 0.031$, $r_{est}(v_3) = 0$). Tetrahedra $t_0, t_1, t_2$ contain at least one of these vertices.\n    *   Thin tetrahedra: `[0, 1, 2]`\n*   **Case 2 ($\\epsilon=0.3$, threshold=0.15):** The same vertices (0, 1, 3) remain thin. All other vertices have $r_{est} > 0.15$.\n    *   Thin tetrahedra: `[0, 1, 2]`\n*   **Case 3 ($\\epsilon=0.08$, threshold=0.04):** Vertices 0, 1, 3, and 6 are thin ($r_{est}(v_0) \\approx 0.030$, $r_{est}(v_1) \\approx 0.031$, $r_{est}(v_3) = 0$, $r_{est}(v_6) \\approx 0.011$). Tetrahedra $t_0, t_1, t_2, t_3$ all contain at least one thin vertex.\n    *   Thin tetrahedra: `[0, 1, 2, 3]`\n*   **Case 4 ($\\epsilon=0.1$, threshold=0.05):** No vertices have cusp attributes or geodesic distances. Their $r_{est}$ is effectively infinite, making them thick.\n    *   Thin tetrahedra: `[]`\n\nThe final output is the collection of these lists.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"epsilon\": 0.2,\n            \"L0\": 1.0,\n            \"geodesic_lengths\": [0.3],\n            \"vertices\": [\n                {\"h\": 2.0, \"d\": [0.3]},\n                {\"h\": 0.5, \"d\": [0.01]},\n                {\"h\": None, \"d\": [0.4]},\n                {\"h\": None, \"d\": [0.0]},\n                {\"h\": 1.0, \"d\": [1.0]},\n                {\"h\": None, \"d\": [2.0]},\n                {\"h\": None, \"d\": [3.0]},\n            ],\n            \"tetrahedra\": [\n                [0, 1, 2, 3],\n                [1, 2, 4, 3],\n                [2, 4, 1, 0],\n                [2, 4, 5, 6],\n            ]\n        },\n        # Case 2\n        {\n            \"epsilon\": 0.3,\n            \"L0\": 1.0,\n            \"geodesic_lengths\": [0.3],\n            \"vertices\": [\n                {\"h\": 2.0, \"d\": [0.3]},\n                {\"h\": 0.5, \"d\": [0.01]},\n                {\"h\": None, \"d\": [0.4]},\n                {\"h\": None, \"d\": [0.0]},\n                {\"h\": 1.0, \"d\": [1.0]},\n                {\"h\": None, \"d\": [2.0]},\n                {\"h\": None, \"d\": [3.0]},\n            ],\n            \"tetrahedra\": [\n                [0, 1, 2, 3],\n                [1, 2, 4, 3],\n                [2, 4, 1, 0],\n                [2, 4, 5, 6],\n            ]\n        },\n        # Case 3\n        {\n            \"epsilon\": 0.08,\n            \"L0\": 1.2,\n            \"geodesic_lengths\": [0.2, 0.5],\n            \"vertices\": [\n                {\"h\": 3.0, \"d\": [0.2, 2.0]},\n                {\"h\": None, \"d\": [0.01, 0.5]},\n                {\"h\": None, \"d\": [0.3, 0.3]},\n                {\"h\": None, \"d\": [0.0, 0.0]},\n                {\"h\": 0.2, \"d\": [1.0, 0.7]},\n                {\"h\": None, \"d\": [1.5, 1.5]},\n                {\"h\": 4.0, \"d\": [0.5, 0.5]},\n                {\"h\": None, \"d\": [3.0, 3.0]},\n            ],\n            \"tetrahedra\": [\n                 [0, 1, 2, 3],\n                 [1, 2, 4, 5],\n                 [2, 4, 5, 3],\n                 [2, 4, 5, 6],\n                 [2, 4, 5, 7],\n            ]\n        },\n        # Case 4\n        {\n            \"epsilon\": 0.1,\n            \"L0\": 1.0,\n            \"geodesic_lengths\": [],\n            \"vertices\": [\n                {\"h\": None, \"d\": []},\n                {\"h\": None, \"d\": []},\n                {\"h\": None, \"d\": []},\n                {\"h\": None, \"d\": []},\n            ],\n            \"tetrahedra\": [\n                [0, 1, 2, 3],\n                [0, 2, 3, 1],\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = classify_tetrahedra(\n            case[\"epsilon\"],\n            case[\"L0\"],\n            case[\"geodesic_lengths\"],\n            case[\"vertices\"],\n            case[\"tetrahedra\"]\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    formatted_results = [str(res).replace(' ', '') for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef classify_tetrahedra(epsilon, L0, geodesic_lengths, vertices, tetrahedra):\n    \"\"\"\n    Computes the thick-thin decomposition for a single test case.\n    \"\"\"\n    thin_vertices = set()\n    epsilon_threshold = epsilon / 2.0\n\n    for i, v_attr in enumerate(vertices):\n        h = v_attr.get(\"h\")\n        distances = v_attr.get(\"d\", [])\n\n        r_est = float('inf')\n\n        # Cusp contribution\n        if h is not None:\n            r_cusp = 0.5 * L0 * np.exp(-h)\n            r_est = min(r_est, r_cusp)\n\n        # Geodesic contributions\n        for j, dist in enumerate(distances):\n            l_j = geodesic_lengths[j]\n            \n            # Length of loop homotopic to the geodesic axis\n            l_axis = l_j * np.cosh(dist)\n            # Length of meridional loop\n            l_meridian = 2 * np.pi * np.sinh(dist)\n            \n            r_geo = 0.5 * min(l_axis, l_meridian)\n            r_est = min(r_est, r_geo)\n        \n        if r_est < epsilon_threshold:\n            thin_vertices.add(i)\n\n    thin_tet_indices = []\n    for i, tet_verts in enumerate(tetrahedra):\n        is_thin = False\n        for v_idx in tet_verts:\n            if v_idx in thin_vertices:\n                is_thin = True\n                break\n        if is_thin:\n            thin_tet_indices.append(i)\n    \n    # The problem requires the list of indices to be sorted.\n    thin_tet_indices.sort()\n    return thin_tet_indices\n\nsolve()\n```", "id": "3000754"}]}