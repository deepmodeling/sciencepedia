{
    "hands_on_practices": [
        {
            "introduction": "在开始分析图像之前，我们必须确保已经捕获了显微镜提供的所有信息。本练习将探讨显微镜光学分辨率与相机像素尺寸之间的关键联系。我们将学习如何应用奈奎斯特采样定理，以确定您的成像系统是否配置得当，从而避免丢失精细的样本细节，这是任何定量成像的第一步。",
            "id": "4911193",
            "problem": "一个组织学和胚胎学实验室的活细胞落射荧光成像装置使用一个$60\\times$、数值孔径为$1.40$的油浸物镜来记录发射波长$\\lambda = 520\\ \\mathrm{nm}$的绿色荧光。相机是一个互补金属氧化物半导体（CMOS）探测器，其传感器上的物理像素间距为$6.5\\ \\mathrm{\\mu m}$。在高等本科显微学中，空间奈奎斯特采样指的是对像平面进行采样，使得离散采样频率至少是光学系统形成的连续图像中所存在的最高空间频率成分的两倍。\n\n从香农-奈奎斯特采样定理和傅里叶光学中非相干荧光成像的光学传递函数截止频率的定义出发，用采样间隔和最高透射空间频率来定义像平面中的空间奈奎斯特采样。然后，利用物平面和像平面之间的放大倍率缩放关系，推导保证奈奎斯特采样的相机传感器像素间距所需满足的条件。最后，根据给定的物镜和发射波长，计算传感器上允许的最大像素间距。将最终数值答案以微米为单位表示在传感器上，并四舍五入到四位有效数字。",
            "solution": "对于小视场，显微镜可以被建模为一个线性移不变系统，其中传感器平面上的图像是物体与点扩散函数的卷积。在傅里叶域中，这对应于物体的频谱与光学传递函数（OTF）的乘积，该函数具有有限支撑，其截止空间频率由成像模式和数值孔径决定。\n\n对于非相干成像（如落射荧光），光学系统透射的最高物平面空间频率由OTF截止频率给出：\n$$\nf_{\\mathrm{c,object}} = \\frac{2\\,\\mathrm{NA}}{\\lambda},\n$$\n其中$\\mathrm{NA}$是数值孔径，$\\lambda$是发射波长。这个$f_{\\mathrm{c,object}}$以物平面上每单位长度的周期数来衡量。\n\n放大倍率$M$将物平面坐标$x_{\\mathrm{o}}$映射到像平面（传感器）坐标$x_{\\mathrm{i}}$，其关系为$x_{\\mathrm{i}} = M\\,x_{\\mathrm{o}}$。在这种缩放关系下，空间频率反向变换：\n$$\nf_{\\mathrm{c,image}} = \\frac{f_{\\mathrm{c,object}}}{M} = \\frac{1}{M}\\,\\frac{2\\,\\mathrm{NA}}{\\lambda}.\n$$\n\n香农-奈奎斯特采样定理要求像平面中的采样频率$f_{\\mathrm{s,image}}$满足\n$$\nf_{\\mathrm{s,image}} \\geq 2\\, f_{\\mathrm{c,image}}.\n$$\n如果相机以像素间距$p_{\\mathrm{sensor}}$（采样间隔）对像平面进行采样，则$f_{\\mathrm{s,image}} = \\frac{1}{p_{\\mathrm{sensor}}}$。将这些结合起来得到\n$$\n\\frac{1}{p_{\\mathrm{sensor}}} \\geq 2\\, \\frac{f_{\\mathrm{c,object}}}{M} \\quad \\Longrightarrow \\quad p_{\\mathrm{sensor}} \\leq \\frac{M}{2\\, f_{\\mathrm{c,object}}}.\n$$\n代入$f_{\\mathrm{c,object}} = \\frac{2\\,\\mathrm{NA}}{\\lambda}$，得到传感器像素间距的奈奎斯特条件：\n$$\np_{\\mathrm{sensor}} \\leq \\frac{M}{2 \\cdot \\left(\\frac{2\\,\\mathrm{NA}}{\\lambda}\\right)} = \\frac{M\\,\\lambda}{4\\,\\mathrm{NA}}.\n$$\n\n该表达式通过将采样间隔$p_{\\mathrm{sensor}}$与光学系统通过的最高像平面空间频率$f_{\\mathrm{c,image}}$联系起来，定义了像平面中的空间奈奎斯特采样。它表明，满足奈奎斯特采样要求传感器像素间距不大于$\\frac{M\\,\\lambda}{4\\,\\mathrm{NA}}$。\n\n现在，根据给定参数$M = 60$，$\\mathrm{NA} = 1.40$和$\\lambda = 520\\ \\mathrm{nm} = 0.520\\ \\mathrm{\\mu m}$计算允许的最大像素间距：\n$$\np_{\\mathrm{sensor,max}} = \\frac{M\\,\\lambda}{4\\,\\mathrm{NA}} = \\frac{60 \\times 0.520\\ \\mathrm{\\mu m}}{4 \\times 1.40} = \\frac{31.2\\ \\mathrm{\\mu m}}{5.6} \\approx 5.57142857\\ \\mathrm{\\mu m}.\n$$\n\n四舍五入到四位有效数字，并以微米为单位表示在传感器上，所需的最大像素间距为\n$$\n5.571\\ \\mathrm{\\mu m}.\n$$\n\n作为参考，给定的相机像素间距$6.5\\ \\mathrm{\\mu m}$超过了$5.571\\ \\mathrm{\\mu m}$，因此在$60\\times$放大倍率下，相对于$\\lambda=520\\ \\mathrm{nm}$和$\\mathrm{NA}=1.40$的奈奎斯特准则，它会轻微欠采样；需要增加放大倍率或使用更小的像素才能满足奈奎斯特条件。然而，题目要求的最终答案是计算出的最大允许像素间距。",
            "answer": "$$\\boxed{5.571}$$"
        },
        {
            "introduction": "获得一幅正确采样的图像只是第一步，其质量最终取决于信号与噪声之间的平衡。本练习将深入探讨信噪比（$SNR$）这一基本概念，它是衡量测量质量的通用指标。我们将剖析荧光显微成像中的主要噪声来源——光子散粒噪声和相机读出噪声，并为一个真实的成像场景计算$SNR$。",
            "id": "4911253",
            "problem": "正在对活体胚胎组织切片进行延时荧光显微镜实验，以量化细胞周期进程中的核信号动态。显微镜配备了科学级互补金属氧化物半导体（sCMOS）相机。在相机平面上进行的校准表明，对于包含单个像素的感兴趣区域，来自荧光标记细胞核（所需信号）的入射光子通量为 $6.0 \\times 10^{4}\\ \\mathrm{photons}\\ \\mathrm{s}^{-1}\\ \\mathrm{pixel}^{-1}$，而来自离焦光和组织自发荧光（背景）的入射光子通量为 $1.5 \\times 10^{4}\\ \\mathrm{photons}\\ \\mathrm{s}^{-1}\\ \\mathrm{pixel}^{-1}$。相机在发射波长下的量子效率（QE）为 $0.75$，曝光时间为 $50\\ \\mathrm{ms}$。相机每像素每帧的读出噪声为 $1.2\\ \\mathrm{electrons}$ 均方根（RMS）。假设每个检测到的光子在传感器中恰好产生一个光电子，光子到达遵循泊松过程，并且读出噪声独立于光子散粒噪声和背景。\n\n仅使用这些物理前提和定义，计算在 $50\\ \\mathrm{ms}$ 曝光期间由信号和背景产生的光电子数量，然后估计在单个帧中测量该像素信号的信噪比（SNR），包括背景和读出噪声的贡献。仅报告信噪比作为您的最终答案。将最终的信噪比四舍五入到四位有效数字。将最终答案表示为无单位的数字。",
            "solution": "该问题要求计算在延时显微镜实验中，sCMOS相机单个像素的测量信噪比（SNR）。问题陈述是有效的，因为它具有科学依据，问题提出得很好，并提供了所有必要的定量信息。\n\n首先，我们确定给定的参数：\n- 入射信号光子通量, $\\Phi_S = 6.0 \\times 10^{4}\\ \\mathrm{photons}\\ \\mathrm{s}^{-1}\\ \\mathrm{pixel}^{-1}$。\n- 入射背景光子通量, $\\Phi_B = 1.5 \\times 10^{4}\\ \\mathrm{photons}\\ \\mathrm{s}^{-1}\\ \\mathrm{pixel}^{-1}$。\n- 曝光时间, $t_{exp} = 50\\ \\mathrm{ms} = 5.0 \\times 10^{-2}\\ \\mathrm{s}$。\n- 量子效率, $QE = 0.75$。\n- 读出噪声, $\\sigma_{read} = 1.2\\ \\mathrm{electrons}$ (RMS)。\n\n我们感兴趣的信号，记为 $S$，是由来自荧光标记细胞核的光子产生的光电子数量。它的计算方法是将入射信号光子通量乘以曝光时间和量子效率。\n$$S = \\Phi_S \\times t_{exp} \\times QE$$\n代入给定值：\n$$S = (6.0 \\times 10^{4}\\ \\mathrm{s}^{-1}) \\times (5.0 \\times 10^{-2}\\ \\mathrm{s}) \\times 0.75$$\n$$S = 3000 \\times 0.75 = 2250\\ \\mathrm{electrons}$$\n\n同样地，由背景产生的光电子数量，记为 $B$，由入射背景光子通量计算得出：\n$$B = \\Phi_B \\times t_{exp} \\times QE$$\n代入给定值：\n$$B = (1.5 \\times 10^{4}\\ \\mathrm{s}^{-1}) \\times (5.0 \\times 10^{-2}\\ \\mathrm{s}) \\times 0.75$$\n$$B = 750 \\times 0.75 = 562.5\\ \\mathrm{electrons}$$\n\n测量中的总噪声来自三个独立的来源：信号的散粒噪声、背景的散粒噪声和相机的读出噪声。\n\n$1$。**信号散粒噪声**：光子的到达是一个泊松过程。光子的检测，以及因此产生的光电子，也遵循泊松分布。泊松分布的方差等于其均值。因此，信号光电子的方差是 $S$，信号散粒噪声 $\\sigma_S$ 是其标准差。\n$$\\sigma_S^2 = S$$\n$$\\sigma_S = \\sqrt{S}$$\n\n$2$。**背景散粒噪声**：同样，背景光电子也表现出散粒噪声，其方差等于背景光电子的平均数 $B$。背景散粒噪声 $\\sigma_B$ 是：\n$$\\sigma_B^2 = B$$\n$$\\sigma_B = \\sqrt{B}$$\n\n$3$。**读出噪声**：这是一个固有的电子噪声源，来自于相机传感器和读出电路，给定为 $\\sigma_{read}$。其方差为 $\\sigma_{read}^2$。\n\n由于这些噪声源是独立的，它们的方差相加。总噪声方差 $\\sigma_{total}^2$ 是各个方差之和：\n$$\\sigma_{total}^2 = \\sigma_S^2 + \\sigma_B^2 + \\sigma_{read}^2 = S + B + \\sigma_{read}^2$$\n总噪声 $\\sigma_{total}$ 是总方差的平方根：\n$$\\sigma_{total} = \\sqrt{S + B + \\sigma_{read}^2}$$\n\n信噪比（SNR）定义为感兴趣信号（$S$）与总噪声（$\\sigma_{total}$）的比值：\n$$SNR = \\frac{S}{\\sigma_{total}} = \\frac{S}{\\sqrt{S + B + \\sigma_{read}^2}}$$\n\n现在，我们将计算出的和给定的数值代入SNR公式：\n- $S = 2250$\n- $B = 562.5$\n- $\\sigma_{read} = 1.2$，所以 $\\sigma_{read}^2 = (1.2)^2 = 1.44$\n\n$$SNR = \\frac{2250}{\\sqrt{2250 + 562.5 + 1.44}}$$\n$$SNR = \\frac{2250}{\\sqrt{2813.94}}$$\n$$SNR \\approx \\frac{2250}{53.046583}$$\n$$SNR \\approx 42.41505$$\n\n问题要求将最终答案四舍五入到四位有效数字。\n$$SNR \\approx 42.42$$\n这是一个无单位的量，因为分子（以电子为单位的信号）和分母（以电子为单位的噪声）具有相同的单位。",
            "answer": "$$\\boxed{42.42}$$"
        },
        {
            "introduction": "真实的成像系统并非完美；不均匀的光照和探测器灵敏度差异会扭曲我们的测量结果。最后的这个练习提供了一种关键校准程序的计算实践：平场校正。我们将通过设计并实施一种算法，来测量和校正这些空间不均匀性，从而将原始的、失真的图像转变为定量准确的数据。",
            "id": "4911240",
            "problem": "您的任务是实现一个基于第一性原理的方法，使用均匀荧光参考载玻片来测量整个视场的照明均匀性，并计算平场校正图。这是组织学和胚胎学中活细胞成像和延时显微成像的一项标准校准。\n\n假设一个宽场荧光成像系统，其观测到的图像强度来自一个带有加性噪声的乘性成像过程。设观测强度模型为 $I_{\\mathrm{obs}}(x,y,t) = I_{\\mathrm{true}}(x,y,t)\\,K(x,y) + \\eta(x,y,t)$，其中 $I_{\\mathrm{true}}(x,y,t)$ 是物体真实的荧光强度，$K(x,y)$ 是空间变化的照明和探测增益的组合，而 $\\eta(x,y,t)$ 是噪声。当对均匀荧光参考载玻片成像时，设 $I_{\\mathrm{true}}(x,y,t) = I_0$ 在整个视场 (FOV) 上为常数，从而产生参考图像 $R(x,y) \\approx I_0\\,K(x,y) + \\eta(x,y)$。\n\n您的任务是使用均匀参考图像 $R(x,y)$ 从第一性原理推导出一个校正图 $C(x,y)$。当该校正图以乘法方式应用时，能够使乘性非均匀性变得平坦，从而使校正后的参考图像 $R_{\\mathrm{corr}}(x,y) = C(x,y)\\,R(x,y)$ 在空间上尽可能均匀。该方法必须基于从 $R(x,y)$ 中估计缓慢变化的乘性因子 $K(x,y)$，并稳定该估计值以避免被过小的值除。您必须使用两个无量纲度量来量化均匀性：\n- 变异系数 (CV)，定义为 $CV = \\sigma / \\mu$，其中 $\\mu$ 是图像上的平均强度，$\\sigma$ 是强度的标准差。\n- 最小-最大比 $U = m / M$，其中 $m$ 是图像上的最小强度，$M$ 是最大强度。\n\n强度值必须以任意单位 (a.u.) 处理。所有输出必须是小数（而不是百分比）。角度不属于本问题的一部分，不得使用。\n\n您必须实现以下算法设计选择：\n- 通过对参考图像 $R(x,y)$ 应用空间低通滤波器（表示为 $S(R)(x,y)$）来估计 $K(x,y)$ 的平滑近似，以抑制高频噪声，同时保留低频的明暗变化。\n- 在任何出现除以 $S(R)(x,y)$ 的地方，在分母中加入一个严格为正的正则化常数 $\\epsilon$，以防止任何像素值接近零时出现不稳定性。\n- 通过将 $C(x,y)$ 裁剪到一个最大值 $C_{\\max}$ 来限制过大的校正。\n\n您将以数学上受控的方式合成参考图像 $R(x,y)$ 以构成一个测试套件。使用图像尺寸 $N \\times N$，其中 $N = 64$ 像素。设真实参考强度为 $I_0 = 1.0$ a.u.。在归一化坐标网格上构建 $K(x,y)$，其中 $x,y \\in [-1,1]$ 且 $r = \\sqrt{x^2 + y^2}$，以模拟渐晕以及可选的灰尘遮挡：\n- 渐晕因子，使用高斯形状建模为一个具有振幅参数 $a \\in [0,1]$ 的平滑径向场。使用固定的宽度参数 $s = 0.6$（在归一化网格上是无单位的）。定义 $K_{\\mathrm{vig}}(x,y) = (1 - a) + a\\,\\exp\\left(-\\frac{r^2}{2s^2}\\right)$。\n- 可选的灰尘遮挡，作为一个透射率降低的圆形区域。在以 $(x_d,y_d)$ 为中心、半径为 $r_d$ 的圆盘内，将 $K_{\\mathrm{vig}}(x,y)$ 乘以一个灰尘透射因子 $d \\in (0,1)$；在圆盘外，$K_{\\mathrm{vig}}(x,y)$ 保持不变。\n\n生成 $R(x,y) = I_0\\,K(x,y) + \\eta(x,y)$，其中包含加性高斯噪声 $\\eta \\sim \\mathcal{N}(0,\\sigma_n^2)$。每个测试用例使用带有固定种子的独立伪随机噪声以保证可复现性。\n\n使用平滑后的图像 $S(R)(x,y)$、正则化常数 $\\epsilon > 0$ 和最大校正值 $C_{\\max}$，根据您的推导来定义 $C(x,y)$。然后计算校正后的参考图像 $R_{\\mathrm{corr}}(x,y) = C(x,y)\\,R(x,y)$，并评估校正前后的均匀性度量 $CV$ 和 $U$。\n\n实现您的程序以评估以下三个测试用例并汇总结果。对于每个用例，报告一个包含四个浮点数的列表：$[CV_{\\mathrm{before}}, CV_{\\mathrm{after}}, U_{\\mathrm{before}}, U_{\\mathrm{after}}]$，顺序完全一致。使用指定的参数值：\n\n- 测试用例 1 (正常路径): $a = 0.3$, $\\sigma_n = 0.01$, 无灰尘遮挡 ($d = 1.0$), $S(R)$ 的平滑尺度为 $\\sigma_s = 1.5$ 像素, 正则化 $\\epsilon = 0.001$, 且 $C_{\\max} = 2.0$。\n- 测试用例 2 (近乎均匀照明的边界情况): $a = 0.0$, $\\sigma_n = 0.005$, 无灰尘遮挡 ($d = 1.0$), 平滑尺度 $\\sigma_s = 1.0$ 像素, 正则化 $\\epsilon = 0.001$, 且 $C_{\\max} = 2.0$。\n- 测试用例 3 (带有严重渐晕和灰尘斑点的边缘情况): $a = 0.5$, $\\sigma_n = 0.01$, 灰尘透射率 $d = 0.05$ (在以 $(x_d,y_d) = (0.3,-0.2)$ 为中心、半径为 $r_d = 0.15$ 的圆盘内), 平滑尺度 $\\sigma_s = 2.0$ 像素, 正则化 $\\epsilon = 0.002$, 且 $C_{\\max} = 3.0$。\n\n您的程序必须生成单行输出，其中包含一个由三个子列表组成的逗号分隔列表，每个子列表对应一个测试用例，并按上述指定顺序排列。确切格式为：\n\"[[c1,c2,c3,c4],[c1,c2,c3,c4],[c1,c2,c3,c4]]\"\n其中每个 $c_i$ 是一个十进制数。强度单位为任意单位 (a.u.)，度量值为无量纲。\n\n您的程序必须完全自包含，不得需要任何外部输入或文件，并且必须确定性地运行。每个测试用例使用一个固定的随机种子，例如分别为种子 $0$、$1$ 和 $2$。",
            "solution": "平场校正问题是定量显微技术中的一个基本校准程序。其目的在于校正由非均匀照明和探测引起的伪影，这些伪影被建模为一个乘性增益场。解决方案将遵循所提供的模型和约束，从第一性原理进行推导。\n\n**1. 理论阐述**\n\n在荧光显微镜中，观测到的强度 $I_{\\mathrm{obs}}(x,y,t)$ 被建模为物体真实荧光强度 $I_{\\mathrm{true}}(x,y,t)$ 与一个空间相关的增益场 $K(x,y)$ 的乘积，再加上加性噪声 $\\eta(x,y,t)$:\n$$\nI_{\\mathrm{obs}}(x,y,t) = I_{\\mathrm{true}}(x,y,t)\\,K(x,y) + \\eta(x,y,t)\n$$\n增益场 $K(x,y)$ 包含了所有乘性的非均匀性来源，例如照明轮廓（如渐晕）和探测器的非均匀量子效率。\n\n为了校正这一点，我们寻求一个校正图 $C(x,y)$，当它与观测图像相乘时，能恢复与真实强度的比例关系。校正后的图像 $I_{\\mathrm{corr}}(x,y,t)$ 由下式给出：\n$$\nI_{\\mathrm{corr}}(x,y,t) = C(x,y) \\, I_{\\mathrm{obs}}(x,y,t) = C(x,y) \\, [I_{\\mathrm{true}}(x,y,t) \\, K(x,y) + \\eta(x,y,t)]\n$$\n理想情况下，我们希望 $C(x,y)K(x,y)$ 是一个常数，从而使 $I_{\\mathrm{corr}}$ 在一个噪声项的范围内与 $I_{\\mathrm{true}}$ 成正比。因此，理想的校正图是增益场的倒数，即 $C(x,y) \\propto 1/K(x,y)$。\n\n为了估计 $K(x,y)$，我们对一个均匀的参考样本进行成像，其 $I_{\\mathrm{true}}(x,y,t)$ 是一个已知的常数 $I_0$。这个获取的参考图像，我们记为 $R(x,y)$，它不随时间变化，其模型为：\n$$\nR(x,y) = I_0\\,K(x,y) + \\eta(x,y)\n$$\n根据这个方程，$I_0\\,K(x,y)$ 的一个朴素估计就是参考图像 $R(x,y)$ 本身。然而，$R(x,y)$ 被噪声 $\\eta(x,y)$ 所污染。问题指出 $K(x,y)$ 是一个缓变场，这意味着其空间频率含量较低。相比之下，噪声通常以高空间频率为特征。这种区别为使用空间低通滤波器（用算子 $S$ 表示）来抑制噪声并获得对潜在信号的鲁棒估计提供了理由。将该滤波器应用于参考图像可得：\n$$\nS(R)(x,y) \\approx I_0\\,K(x,y)\n$$\n这个平滑后的图像 $S(R)(x,y)$ 是我们对平场照明分量的最佳估计。\n\n标准做法是定义一个对图像强度进行归一化的校正图。我们可以通过将平滑后的参考图像除以其平均值 $\\mu_{S(R)} = \\mathrm{mean}(S(R))$ 来构建一个归一化增益估计 $\\hat{K}_{\\mathrm{norm}}(x,y)$:\n$$\n\\hat{K}_{\\mathrm{norm}}(x,y) = \\frac{S(R)(x,y)}{\\mu_{S(R)}}\n$$\n校正图 $C(x,y)$ 是这个归一化增益的倒数:\n$$\nC(x,y) = \\frac{1}{\\hat{K}_{\\mathrm{norm}}(x,y)} = \\frac{\\mu_{S(R)}}{S(R)(x,y)}\n$$\n将此校正应用于平滑后的参考图像将得到一个强度等于 $\\mu_{S(R)}$ 的完全平坦的图像，这证明了其原理。\n\n为处理实际问题，强制要求进行两项修改：\n1.  **正则化**：为防止 $S(R)(x,y)$ 中出现除以零或接近零的值（这可能发生在非常暗的区域或由于传感器缺陷），在分母中加入一个小的、严格为正的正则化常数 $\\epsilon$。\n2.  **裁剪**：为防止在暗区（校正因子可能变得非常大）对噪声进行极端放大，将校正图裁剪到最大允许值 $C_{\\max}$。\n\n综合这些要素，校正图的最终、基于原理的表达式为：\n$$\nC(x,y) = \\min\\left( \\frac{\\mu_{S(R)}}{S(R)(x,y) + \\epsilon}, C_{\\max} \\right)\n$$\n校正后的参考图像则计算为 $R_{\\mathrm{corr}}(x,y) = C(x,y) \\, R(x,y)$。\n\n**2. 图像合成与评估度量**\n\n问题要求合成测试图像以验证该方法。图像尺寸为 $N \\times N$，其中 $N = 64$。在 $x, y \\in [-1, 1]$ 上定义归一化坐标网格。增益场 $K(x,y)$ 由渐晕分量和可选的灰尘遮挡构成。渐晕因子为 $K_{\\mathrm{vig}}(x,y) = (1 - a) + a\\,\\exp\\left(-\\frac{r^2}{2s^2}\\right)$，其中 $r = \\sqrt{x^2 + y^2}$，$a$ 是渐晕振幅，$s=0.6$ 是固定的宽度参数。通过在指定的圆形区域内将 $K_{\\mathrm{vig}}(x,y)$ 乘以一个透射因子 $d \\in (0,1)$ 来模拟灰尘遮挡。然后，合成的参考图像为 $R(x,y) = I_0\\,K(x,y) + \\eta(x,y)$，其中 $I_0 = 1.0$ a.u.，$\\eta$ 是高斯噪声，$\\eta \\sim \\mathcal{N}(0, \\sigma_n^2)$。\n\n均匀性由两个度量来量化：\n- **变异系数 (CV)**：$CV = \\sigma / \\mu$，其中 $\\mu$ 和 $\\sigma$ 分别是图像像素强度的平均值和标准差。较低的 $CV$ 表示较高的均匀性。\n- **最小-最大比 (U)**：$U = m / M$，其中 $m$ 和 $M$ 是最小和最大像素强度。$U$ 的值越接近 1 表示均匀性越高。\n\n算法的流程是：首先为每个测试用例生成合成参考图像 $R(x,y)$，计算'校正前'的度量（$CV_{\\mathrm{before}}$, $U_{\\mathrm{before}}$）；然后使用高斯滤波器进行平滑操作 $S$ 来计算校正图 $C(x,y)$；接着应用校正得到 $R_{\\mathrm{corr}}(x,y)$；最后计算'校正后'的度量（$CV_{\\mathrm{after}}$, $U_{\\mathrm{after}}$）。\n\n**3. 实现的算法步骤**\n对于每个具有其特定参数的测试用例：\n1.  在 $[-1,1] \\times [-1,1]$ 上生成一个 $N \\times N$ 的坐标网格 $(x,y)$。\n2.  根据渐晕和灰尘参数 ($a, s, d, x_d, y_d, r_d$) 构建增益场 $K(x,y)$。\n3.  设置随机种子以保证可复现性。生成一个标准差为 $\\sigma_n$ 的 $N \\times N$ 高斯噪声数组 $\\eta$。\n4.  合成参考图像：$R(x,y) = 1.0 \\cdot K(x,y) + \\eta(x,y)$。\n5.  从 $R(x,y)$ 计算并存储 $CV_{\\mathrm{before}}$ 和 $U_{\\mathrm{before}}$。\n6.  使用标准差为 $\\sigma_s$ 的高斯滤波器平滑 $R(x,y)$ 以获得 $S(R)(x,y)$。\n7.  计算平滑后图像的平均值 $\\mu_{S(R)}$。\n8.  计算校正图 $C(x,y) = \\min\\left( \\frac{\\mu_{S(R)}}{S(R)(x,y) + \\epsilon}, C_{\\max} \\right)$。\n9.  计算校正后的图像 $R_{\\mathrm{corr}}(x,y) = C(x,y) \\cdot R(x,y)$。\n10. 从 $R_{\\mathrm{corr}}(x,y)$ 计算并存储 $CV_{\\mathrm{after}}$ 和 $U_{\\mathrm{after}}$。\n11. 将四个度量组合成一个列表作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import gaussian_filter\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n\n    def compute_correction_metrics(\n        N, a, s, sigma_n, d, x_d, y_d, r_d, sigma_s, epsilon, C_max, seed\n    ):\n        \"\"\"\n        Computes flat-field correction and evaluates uniformity for a single test case.\n        \n        Args:\n            N (int): Image size (N x N).\n            a (float): Vignetting amplitude.\n            s (float): Vignetting width parameter.\n            sigma_n (float): Standard deviation of additive Gaussian noise.\n            d (float): Dust transmission factor.\n            x_d (float): Dust center x-coordinate.\n            y_d (float): Dust center y-coordinate.\n            r_d (float): Dust radius.\n            sigma_s (float): Smoothing scale for Gaussian filter (in pixels).\n            epsilon (float): Regularization constant for division.\n            C_max (float): Maximum value for the correction map.\n            seed (int): Random seed for noise generation.\n\n        Returns:\n            list: A list of four floats [CV_before, CV_after, U_before, U_after].\n        \"\"\"\n        \n        # 1. Generate Coordinate Grid\n        I0 = 1.0  # True reference intensity in arbitrary units (a.u.)\n        coords = np.linspace(-1.0, 1.0, N)\n        x_grid, y_grid = np.meshgrid(coords, coords)\n        \n        # 2. Synthesize Gain Field K(x,y)\n        r_sq = x_grid**2 + y_grid**2\n        K_vig = (1.0 - a) + a * np.exp(-r_sq / (2.0 * s**2))\n        \n        K = K_vig\n        if d  1.0:\n            dust_mask = (x_grid - x_d)**2 + (y_grid - y_d)**2  r_d**2\n            K = np.where(dust_mask, K_vig * d, K_vig)\n            \n        # 3. Synthesize Reference Image R(x,y)\n        rng = np.random.default_rng(seed)\n        noise = rng.normal(loc=0.0, scale=sigma_n, size=(N, N))\n        R = I0 * K + noise\n        \n        # 4. Calculate 'Before' Metrics\n        mu_before = np.mean(R)\n        sigma_before = np.std(R)\n        m_before = np.min(R)\n        M_before = np.max(R)\n        \n        CV_before = sigma_before / mu_before\n        U_before = m_before / M_before\n        \n        # 5. Compute Correction Map C(x,y)\n        # Smooth the reference image to estimate the gain field\n        S_R = gaussian_filter(R, sigma=sigma_s)\n        \n        # Calculate the mean of the smoothed image for normalization\n        mu_SR = np.mean(S_R)\n        \n        # Calculate the correction map with regularization\n        C_raw = mu_SR / (S_R + epsilon)\n        \n        # Clip the correction map to C_max\n        C = np.minimum(C_raw, C_max)\n        \n        # 6. Apply Correction\n        R_corr = C * R\n        \n        # 7. Calculate 'After' Metrics\n        mu_after = np.mean(R_corr)\n        sigma_after = np.std(R_corr)\n        m_after = np.min(R_corr)\n        M_after = np.max(R_corr)\n        \n        CV_after = sigma_after / mu_after\n        U_after = m_after / M_after\n        \n        return [CV_before, CV_after, U_before, U_after]\n\n    test_cases = [\n        # Test Case 1 (happy path)\n        {\n            'a': 0.3, 'sigma_n': 0.01, 'd': 1.0, 'x_d': 0.0, 'y_d': 0.0, 'r_d': 0.0,\n            'sigma_s': 1.5, 'epsilon': 0.001, 'C_max': 2.0, 'seed': 0\n        },\n        # Test Case 2 (boundary case of nearly uniform illumination)\n        {\n            'a': 0.0, 'sigma_n': 0.005, 'd': 1.0, 'x_d': 0.0, 'y_d': 0.0, 'r_d': 0.0,\n            'sigma_s': 1.0, 'epsilon': 0.001, 'C_max': 2.0, 'seed': 1\n        },\n        # Test Case 3 (edge case with severe vignetting and a dust spot)\n        {\n            'a': 0.5, 'sigma_n': 0.01, 'd': 0.05, 'x_d': 0.3, 'y_d': -0.2, 'r_d': 0.15,\n            'sigma_s': 2.0, 'epsilon': 0.002, 'C_max': 3.0, 'seed': 2\n        },\n    ]\n    \n    # Common parameters\n    common_params = {'N': 64, 's': 0.6}\n    \n    results = []\n    for params in test_cases:\n        case_params = {**common_params, **params}\n        result = compute_correction_metrics(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Using str() and .replace() is a robust way to match the required format\n    # without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        }
    ]
}