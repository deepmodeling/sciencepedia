{
    "hands_on_practices": [
        {
            "introduction": "在比较不同人群的健康状况时，一个关键的挑战是控制年龄等混杂因素的影响。标准化死亡比（$SMR$）是一种基础而重要的流行病学工具，它允许我们在调整了年龄结构差异后比较观察到的死亡人数与预期死亡人数。通过这个练习，你将学习如何计算 $SMR$，并更深入地探讨当弱势群体的潜在健康需求与标准人群存在系统性差异时，该指标的解释陷阱。",
            "id": "4595794",
            "problem": "一个公共卫生团队正在评估一个弱势城市社区集群的死亡率，该社区集群的慢性病负担加重且预防性保健服务有限。为了研究健康不平等问题，他们决定采用间接年龄标化法与国家标准进行比较。假设观察期为一年，随访完整，迁入和迁出人口可忽略不计，因此每位居民贡献约 $1$ 个人年。国家标准年龄别死亡率为：\n\n- 年龄 $0$–$44$ 岁：$1.2$ / $1{,}000$ 人年\n- 年龄 $45$–$64$ 岁：$5.6$ / $1{,}000$ 人年\n- 年龄 $65$–$74$ 岁：$14.0$ / $1{,}000$ 人年\n- 年龄 $75$–$84$ 岁：$40.0$ / $1{,}000$ 人年\n- 年龄 $\\ge 85$ 岁：$110.0$ / $1{,}000$ 人年\n\n该弱势群体在基线时的年龄分布为：\n\n- 年龄 $0$–$44$ 岁：$12{,}500$ 名居民\n- 年龄 $45$–$64$ 岁：$8{,}400$ 名居民\n- 年龄 $65$–$74$ 岁：$2{,}900$ 名居民\n- 年龄 $75$–$84$ 岁：$1{,}100$ 名居民\n- 年龄 $\\ge 85$ 岁：$270$ 名居民\n\n在这一年中，该弱势群体总共发生 $223$ 例观察死亡（所有原因）。仅使用死亡率、间接标化和比率测量的基本定义，计算该弱势群体相对于国家标准的标化死亡比。将最终的标化死亡比表示为无单位的小数，并将答案四舍五入至四位有效数字。\n\n然后，解释当弱势群体的潜在健康需求与标准人口存在系统性差异时（例如，由于更高的基线发病率、环境暴露或医疗服务可及性障碍），标化死亡比在解释上可能存在的陷阱。你的解释应侧重于为什么该比率可能会将需求与表现或其他结构性因素混为一谈，以及进行公平比较需要哪些假设。\n\n注意：标化死亡比（SMR）应解释为比较观察死亡人数与标准率下预期死亡人数的无量纲比率。",
            "solution": "该问题要求计算一个弱势群体的标化死亡比（SMR），并解释在健康差异背景下该指标的解释陷阱。解答分为两部分：首先，SMR的量化计算；其次，对其假设和局限性的定性分析。\n\n**第一部分：计算标化死亡比（SMR）**\n\n标化死亡比定义为研究人群中观察到的总死亡人数与预期总死亡人数之比。预期死亡人数是通过将标准人口的年龄别死亡率应用于研究人口的年龄结构来计算的。\n\nSMR的公式为：\n$$ \\text{SMR} = \\frac{\\text{观察死亡人数}}{\\text{预期死亡人数}} = \\frac{D_O}{D_E} $$\n\n观察到的总死亡人数 $D_O$ 已给出，为 $223$。\n\n预期的总死亡人数 $D_E$ 是每个年龄分层 $i$ 中预期死亡人数的总和。给定分层 $i$ 的预期死亡人数 $d_{E,i}$ 是通过将研究人群中该分层的人数 $N_i$ 乘以来自标准人群的相应年龄别死亡率 $M_i$ 来计算的。\n$$ D_E = \\sum_i d_{E,i} = \\sum_i (N_i \\times M_i) $$\n\n我们已知以下数据：\n\n研究人群 ($N_i$):\n- 年龄 $0$–$44$ 岁: $N_1 = 12,500$\n- 年龄 $45$–$64$ 岁: $N_2 = 8,400$\n- 年龄 $65$–$74$ 岁: $N_3 = 2,900$\n- 年龄 $75$–$84$ 岁: $N_4 = 1,100$\n- 年龄 $\\ge 85$ 岁: $N_5 = 270$\n\n标准死亡率 ($M_i$), 从每 $1,000$ 人年换算为小数率：\n- 年龄 $0$–$44$ 岁: $M_1 = 1.2 / 1000 = 0.0012$\n- 年龄 $45$–$64$ 岁: $M_2 = 5.6 / 1000 = 0.0056$\n- 年龄 $65$–$74$ 岁: $M_3 = 14.0 / 1000 = 0.0140$\n- 年龄 $75–84$ 岁: $M_4 = 40.0 / 1000 = 0.0400$\n- 年龄 $\\ge 85$ 岁: $M_5 = 110.0 / 1000 = 0.1100$\n\n现在，我们计算每个年龄分层的预期死亡人数：\n- 分层 $1$ (年龄 $0$–$44$ 岁): $d_{E,1} = N_1 \\times M_1 = 12,500 \\times 0.0012 = 15.0$\n- 分层 $2$ (年龄 $45$–$64$ 岁): $d_{E,2} = N_2 \\times M_2 = 8,400 \\times 0.0056 = 47.04$\n- 分层 $3$ (年龄 $65$–$74$ 岁): $d_{E,3} = N_3 \\times M_3 = 2,900 \\times 0.0140 = 40.6$\n- 分层 $4$ (年龄 $75$–$84$ 岁): $d_{E,4} = N_4 \\times M_4 = 1,100 \\times 0.0400 = 44.0$\n- 分层 $5$ (年龄 $\\ge 85$ 岁): $d_{E,5} = N_5 \\times M_5 = 270 \\times 0.1100 = 29.7$\n\n预期的总死亡人数 $D_E$ 是这些值的总和：\n$$ D_E = 15.0 + 47.04 + 40.6 + 44.0 + 29.7 = 176.34 $$\n\n已知 $D_O = 223$ 且 $D_E = 176.34$，我们现在可以计算SMR：\n$$ \\text{SMR} = \\frac{D_O}{D_E} = \\frac{223}{176.34} \\approx 1.2645967... $$\n\n四舍五入到四位有效数字，我们得到：\n$$ \\text{SMR} \\approx 1.265 $$\nSMR为 $1.265$ 表示，如果该弱势群体具有与国家标准人口相同的年龄别死亡率，其死亡人数比预期多出约 $26.5\\%$。\n\n**第二部分：SMR的解释陷阱**\n\nSMR的计算基于一个关键但通常未明说的假设：一旦考虑了年龄因素，标准人口的年龄别死亡率 ($M_i$) 就是研究人群中应有的预期率。为了使比较公平，必须假设在每个年龄分层内，研究人群和标准人群在潜在健康状况和风险方面是可比的。这被称为各人群间年龄别率比具有可比性的假设。\n\n在健康差异的背景下，这个假设从根本上就是不成立的。问题陈述本身就指明了研究群体是“弱势城市社区”，存在“加重的慢性病负担和有限的预防性保健服务”。这导致了重大的解释陷阱：\n\n1.  **将需求、结构性因素和表现混为一谈**：升高的SMR并不能清晰地分离出单一原因。超额死亡率（本例中为 $26.5\\%$）是多种纠缠因素的综合效应：\n    *   **更高的健康需求**：与全国平均水平相比，弱势人群在任何给定年龄的发病率和疾病严重程度可能都更高。例如，该群体中一个 $50$ 岁的人其健康状况可能更像标准人群中一个 $60$ 岁的人。将 $50$ 岁年龄组的标准死亡率应用于该群体，会低估基于他们实际健康状况的“预期”死亡率。\n    *   **结构性劣势**：诸如更高程度的环境污染暴露、社会经济困难带来的慢性压力、食物荒漠和不安全的住房等因素，会直接增加死亡风险，而这与医疗服务的可及性或质量无关。这些因素在标准人群中不存在同样的程度，而SMR并未对此进行调整。\n    *   **医疗系统表现**：“有限的预防性保健服务”和可能较低的治疗性护理质量导致许多疾病的病死率更高。这是医疗系统未能满足人群需求的失败表现。\n\n2.  **“预期”死亡人数的误导性**：“预期死亡人数”是一个技术术语。它并不代表对一个疾病负担沉重的人群的现实期望。它代表的是一个假设情景：“如果这个人群，尽管处于劣势，却奇迹般地拥有更健康、资源更充足的标准人群的死亡风险，会怎么样？”SMR衡量的是观察到的现实与这个反事实理想之间的差距。将整个差距归因于单一原因，例如“医院质量差”，是一种生态谬误。它忽略了该人群从一开始就病情更重的事实。\n\n为了使SMR成为一个公平的比较工具，例如比较两个地区医疗保健的质量，就必须假设这些人群具有相似的潜在疾病负担和风险因素概况，唯一的不同在于他们接受的医疗保健。在健康不平等的研究中，这个假设根据定义就是无效的。因此，SMR是一个有用的工具，用于*量化*不平等的程度，但若无更多信息，它不是一个用于*解释*其原因的工具。它表明了问题的存在，但其本身并不能诊断问题的病因。",
            "answer": "$$ \\boxed{1.265} $$"
        },
        {
            "introduction": "量化健康差异之后，下一步是探究其根本原因。Kitagawa分解法是一种强大的分析技术，可以将两个人群之间总体率的差异（例如，死亡率或发病率）精确地分解为两个部分：一部分归因于人口构成的差异，另一部分归因于特定亚组率的差异。这项实践将指导你通过编程实现这一方法，从而从简单的“测量”差异，转向深入的“解释”差异来源。",
            "id": "4595822",
            "problem": "给定两个总体，每个总体都被划分为有限个互斥且完备的亚组。对于每个总体，您已知其亚组构成（各亚组比例组成的向量，其和为$1$）以及特定亚组率（可解释为介于$0$和$1$之间的概率，以小数形式表示，不使用百分号）。一个总体的总体（粗）率定义为使用亚组构成作为权重，对特定亚组率进行的加权和。仅从这些基本定义出发，推导并实现一个精确、对称的分解方法，将两个总体之间粗率的差异分解为两个可加性分量：一个归因于各亚组间总体构成的差异，另一个归因于特定亚组率的差异。该分解必须在构造上无残差，并且对于两个总体是对称的。\n\n形式上，对于总体$A$，其亚组比例为$\\{p_{A,i}\\}_{i=1}^{k}$，亚组率为$\\{r_{A,i}\\}_{i=1}^{k}$；对于总体$B$，其亚组比例为$\\{p_{B,i}\\}_{i=1}^{k}$，亚组率为$\\{r_{B,i}\\}_{i=1}^{k}$，则粗率分别为\n$$\nR_A = \\sum_{i=1}^{k} p_{A,i} \\, r_{A,i}, \\quad R_B = \\sum_{i=1}^{k} p_{B,i} \\, r_{B,i}.\n$$\n令 $\\Delta = R_A - R_B$。将$\\Delta$分解为两个分量之和，即一个构成部分$C$和一个率部分$S$，使得$\\Delta = C + S$精确成立。其中，$C$仅捕捉$\\{p_{A,i}\\}$与$\\{p_{B,i}\\}$之间差异的贡献，而$S$仅捕捉$\\{r_{A,i}\\}$与$\\{r_{B,i}\\}$之间差异的贡献，且处理两个总体的方式是对称的。\n\n您的任务是编写一个完整的程序，为每个提供的测试用例计算三元组$[\\Delta, C, S]$，结果为保留六位小数的实数。所有输入已在程序中提供，不得从标准输入读取。所有亚组比例必须为非负数，且在每个总体内部和为$1$，所有亚组率必须在区间$[0,1]$内（小数形式，无百分号）。\n\n测试套件：\n- 案例1（一般三亚组情况）：\n  - $p_A = [0.2, 0.3, 0.5]$, $r_A = [0.1, 0.15, 0.25]$\n  - $p_B = [0.3, 0.3, 0.4]$, $r_B = [0.05, 0.20, 0.35]$\n- 案例2（构成相同；仅特定亚组率不同）：\n  - $p_A = [0.4, 0.6]$, $r_A = [0.1, 0.2]$\n  - $p_B = [0.4, 0.6]$, $r_B = [0.15, 0.25]$\n- 案例3（特定亚组率相同；仅构成不同）：\n  - $p_A = [0.2, 0.8]$, $r_A = [0.1, 0.3]$\n  - $p_B = [0.8, 0.2]$, $r_B = [0.1, 0.3]$\n- 案例4（含零亚组率和零亚组比例的边界情况）：\n  - $p_A = [0.5, 0.0, 0.5]$, $r_A = [0.0, 0.2, 0.4]$\n  - $p_B = [0.2, 0.3, 0.5]$, $r_B = [0.0, 0.1, 0.5]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例对应一个包含三个数字$[\\Delta, C, S]$的子列表。输出行中任何地方都不得有空格。例如：$[[a_1,b_1,c_1],[a_2,b_2,c_2],\\ldots]$。\n- 所有数字必须四舍五入到小数点后六位。",
            "solution": "我们从粗率和亚组分层的基本定义开始。假设有$k$个不相交的亚组，索引为 $i \\in \\{1,\\ldots,k\\}$。对于每个总体$A$和$B$，用$\\{p_{A,i}\\}$和$\\{p_{B,i}\\}$表示亚组构成，其中$\\sum_{i=1}^{k} p_{A,i} = 1$和$\\sum_{i=1}^{k} p_{B,i} = 1$，且所有$p_{\\cdot,i} \\ge 0$。分别用$\\{r_{A,i}\\}$和$\\{r_{B,i}\\}$表示特定亚组率（例如，介于$0$和$1$之间的风险率或发病率）。粗率由以下公式给出：\n$$\nR_A = \\sum_{i=1}^{k} p_{A,i} \\, r_{A,i}, \\quad R_B = \\sum_{i=1}^{k} p_{B,i} \\, r_{B,i}.\n$$\n我们寻求将$\\Delta = R_A - R_B$进行精确、对称的分解，分解为一个构成部分$C$和一个率部分$S$，且无残差。\n\n从\n$$\n\\Delta = \\sum_{i=1}^{k} \\big(p_{A,i} r_{A,i} - p_{B,i} r_{B,i}\\big),\n$$\n开始，我们以对称的方式加上和减去对跨总体构成和率进行平均的项。具体来说，在求和式内部加上并减去$\\tfrac{1}{2} p_{A,i} r_{B,i}$和$\\tfrac{1}{2} p_{B,i} r_{A,i}$，以在总体之间建立等权重的桥梁。然后重新组合各项，以分离出仅与构成有关和仅与率有关的对比项：\n$$\n\\Delta = \\sum_{i=1}^{k} \\left[\\frac{(p_{A,i} - p_{B,i})(r_{A,i} + r_{B,i})}{2}\\right] + \\sum_{i=1}^{k} \\left[\\frac{(r_{A,i} - r_{B,i})(p_{A,i} + p_{B,i})}{2}\\right].\n$$\n定义构成部分\n$$\nC = \\sum_{i=1}^{k} \\frac{(p_{A,i} - p_{B,i})(r_{A,i} + r_{B,i})}{2},\n$$\n和率部分\n$$\nS = \\sum_{i=1}^{k} \\frac{(r_{A,i} - r_{B,i})(p_{A,i} + p_{B,i})}{2}.\n$$\n根据构造，$C$仅依赖于由亚组率的平均值调节的构成差异，$S$仅依赖于由亚组构成的平均值调节的率差异。这就是经典的Kitagawa分解法，它是精确且对称的，可得到$\\Delta = C + S$，且无残差。\n\n每个测试用例的算法步骤：\n- 输入等长为$k$且具有有效构成和率的向量$p_A, r_A, p_B, r_B$。\n- 计算 $R_A = \\sum_i p_{A,i} r_{A,i}$ 和 $R_B = \\sum_i p_{B,i} r_{B,i}$，然后计算 $\\Delta = R_A - R_B$。\n- 计算 $C = \\sum_i \\big((p_{A,i} - p_{B,i}) \\cdot (r_{A,i} + r_{B,i}) / 2\\big)$。\n- 计算 $S = \\sum_i \\big((r_{A,i} - r_{B,i}) \\cdot (p_{A,i} + p_{B,i}) / 2\\big)$。\n- (可选) 在数值上验证$|\\Delta - (C + S)|$是可忽略的（在浮点舍入误差范围内）。\n- 将$\\Delta, C, S$四舍五入至六位小数，并按规定格式输出。\n\n现在我们为每个测试用例计算所需的值。\n\n案例1：\n- $p_A = [0.2, 0.3, 0.5]$, $r_A = [0.1, 0.15, 0.25]$; $p_B = [0.3, 0.3, 0.4]$, $r_B = [0.05, 0.20, 0.35]$.\n- $R_A = 0.2 \\cdot 0.1 + 0.3 \\cdot 0.15 + 0.5 \\cdot 0.25 = 0.02 + 0.045 + 0.125 = 0.19$。\n- $R_B = 0.3 \\cdot 0.05 + 0.3 \\cdot 0.20 + 0.4 \\cdot 0.35 = 0.015 + 0.06 + 0.14 = 0.215$。\n- $\\Delta = 0.19 - 0.215 = -0.025$。\n- $C = \\sum_i (p_{A,i} - p_{B,i}) \\cdot (r_{A,i} + r_{B,i}) / 2 = (-0.1)\\cdot 0.075 + 0.0 \\cdot 0.175 + 0.1 \\cdot 0.30 = -0.0075 + 0 + 0.03 = 0.0225$。\n- $S = \\sum_i (r_{A,i} - r_{B,i}) \\cdot (p_{A,i} + p_{B,i}) / 2 = 0.05 \\cdot 0.25 + (-0.05)\\cdot 0.30 + (-0.10)\\cdot 0.45 = 0.0125 - 0.015 - 0.045 = -0.0475$。\n- 检验：$C + S = 0.0225 - 0.0475 = -0.025 = \\Delta$。\n\n案例2：\n- $p_A = [0.4, 0.6]$, $r_A = [0.1, 0.2]$; $p_B = [0.4, 0.6]$, $r_B = [0.15, 0.25]$.\n- $R_A = 0.4 \\cdot 0.1 + 0.6 \\cdot 0.2 = 0.04 + 0.12 = 0.16$。\n- $R_B = 0.4 \\cdot 0.15 + 0.6 \\cdot 0.25 = 0.06 + 0.15 = 0.21$。\n- $\\Delta = 0.16 - 0.21 = -0.05$。\n- $C = 0$ 因为 $p_A = p_B$。\n- $S = -0.05$。\n- 检验：$C + S = -0.05 = \\Delta$。\n\n案例3：\n- $p_A = [0.2, 0.8]$, $r_A = [0.1, 0.3]$; $p_B = [0.8, 0.2]$, $r_B = [0.1, 0.3]$.\n- $R_A = 0.2 \\cdot 0.1 + 0.8 \\cdot 0.3 = 0.02 + 0.24 = 0.26$。\n- $R_B = 0.8 \\cdot 0.1 + 0.2 \\cdot 0.3 = 0.08 + 0.06 = 0.14$。\n- $\\Delta = 0.26 - 0.14 = 0.12$。\n- $C = (-0.6)\\cdot 0.1 + 0.6 \\cdot 0.3 = -0.06 + 0.18 = 0.12$。\n- $S = 0$ 因为 $r_A = r_B$。\n- 检验：$C + S = 0.12 = \\Delta$。\n\n案例4：\n- $p_A = [0.5, 0.0, 0.5]$, $r_A = [0.0, 0.2, 0.4]$; $p_B = [0.2, 0.3, 0.5]$, $r_B = [0.0, 0.1, 0.5]$.\n- $R_A = 0.5 \\cdot 0.0 + 0.0 \\cdot 0.2 + 0.5 \\cdot 0.4 = 0.2$。\n- $R_B = 0.2 \\cdot 0.0 + 0.3 \\cdot 0.1 + 0.5 \\cdot 0.5 = 0.28$。\n- $\\Delta = 0.2 - 0.28 = -0.08$。\n- $C = (0.3)\\cdot 0 + (-0.3)\\cdot 0.15 + (0.0)\\cdot 0.45 = -0.045$。\n- $S = (0.0)\\cdot 0.35 + (0.1)\\cdot 0.15 + (-0.1)\\cdot 0.5 = -0.035$。\n- 检验：$C + S = -0.08 = \\Delta$。\n\n程序将通用地实现这些计算，以适用于任何有效的输入向量，并将为提供的测试套件打印结果，结果为单行、无空格、由方括号括起来的三元组列表，其中数字四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef kitagawa_decomposition(pA, rA, pB, rB):\n    \"\"\"\n    Compute the Kitagawa decomposition for two populations:\n    - pA, rA: compositions and subgroup rates for population A\n    - pB, rB: compositions and subgroup rates for population B\n\n    Returns:\n        delta, comp_effect, rate_effect as floats.\n    \"\"\"\n    pA = np.asarray(pA, dtype=float)\n    rA = np.asarray(rA, dtype=float)\n    pB = np.asarray(pB, dtype=float)\n    rB = np.asarray(rB, dtype=float)\n\n    if not (pA.shape == rA.shape == pB.shape == rB.shape):\n        raise ValueError(\"All input vectors must have the same shape.\")\n\n    # Crude rates\n    RA = float(np.sum(pA * rA))\n    RB = float(np.sum(pB * rB))\n    delta = RA - RB\n\n    # Kitagawa components (symmetric, exact)\n    comp_effect = float(np.sum((pA - pB) * (rA + rB) / 2.0))\n    rate_effect = float(np.sum((rA - rB) * (pA + pB) / 2.0))\n\n    return delta, comp_effect, rate_effect\n\ndef format_float(x, places=6, zero_eps=5e-13):\n    \"\"\"Format a float to a fixed number of decimal places, avoiding negative zero.\"\"\"\n    if abs(x)  zero_eps:\n        x = 0.0\n    return f\"{x:.{places}f}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (pA, rA, pB, rB)\n    test_cases = [\n        # Case 1\n        ([0.2, 0.3, 0.5], [0.1, 0.15, 0.25],\n         [0.3, 0.3, 0.4], [0.05, 0.20, 0.35]),\n        # Case 2\n        ([0.4, 0.6], [0.1, 0.2],\n         [0.4, 0.6], [0.15, 0.25]),\n        # Case 3\n        ([0.2, 0.8], [0.1, 0.3],\n            [0.8, 0.2], [0.1, 0.3]),\n        # Case 4\n        ([0.5, 0.0, 0.5], [0.0, 0.2, 0.4],\n         [0.2, 0.3, 0.5], [0.0, 0.1, 0.5]),\n    ]\n\n    results_str_parts = []\n    for pA, rA, pB, rB in test_cases:\n        delta, comp, rate = kitagawa_decomposition(pA, rA, pB, rB)\n\n        # Round and format to six decimal places as required.\n        delta_s = format_float(delta, 6)\n        comp_s = format_float(comp, 6)\n        rate_s = format_float(rate, 6)\n\n        triple_str = f\"[{delta_s},{comp_s},{rate_s}]\"\n        results_str_parts.append(triple_str)\n\n    # Final print statement in the exact required format: no spaces.\n    print(f\"[[{','.join(results_str_parts)}]]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "随着预测算法在医疗健康领域的广泛应用，确保这些工具不会加剧现有的健康不平等变得至关重要。本练习将带你进入算法公平性的前沿领域，通过计算和比较“均等化赔率”和“预测均等性”等关键指标，来评估风险分层算法在不同人群中的表现。你将亲身体会到，当不同群体间的疾病基线率存在差异时，在算法设计中会面临固有的权衡与挑战。",
            "id": "4595755",
            "problem": "您正在评估一种用于慢性病的二元风险分层算法在两个人口群体（标记为 A 组和 B 组）中的表现。对于每个组，您会得到一个 $2 \\times 2$ 列联表中的计数，该表比较了算法的预测标签 $\\hat{Y} \\in \\{0,1\\}$ 与真实结果 $Y \\in \\{0,1\\}$。令 $TP$ 为真阳性（true positives）的计数，$FP$ 为假阳性（false positives）的计数，$TN$ 为真阴性（true negatives）的计数，$FN$ 为假阴性（false negatives）的计数。\n\n您的任务是实现一个程序，为每个测试用例，计算两个组的以下指标：\n- 每个组 $g \\in \\{\\text{A},\\text{B}\\}$ 的正类患病率（基准率）$\\pi_g = \\dfrac{TP_g + FN_g}{TP_g + FP_g + TN_g + FN_g}$。\n- 分别计算每个组的真阳性率（TPR）$=\\dfrac{TP_g}{TP_g + FN_g}$，假阳性率（FPR）$=\\dfrac{FP_g}{FP_g + TN_g}$，以及阳性预测值（PPV）$=\\dfrac{TP_g}{TP_g + FP_g}$。\n- 一个布尔值，指示两组之间是否满足均等化赔率（Equalized Odds, EO），其定义为 $|\\text{TPR}_{\\text{A}} - \\text{TPR}_{\\text{B}}| \\le \\epsilon$ 和 $|\\text{FPR}_{\\text{A}} - \\text{FPR}_{\\text{B}}| \\le \\epsilon$ 同时成立，容差 $\\epsilon = 10^{-6}$。\n- 一个布尔值，指示两组之间是否满足预测均等（Predictive Parity, PP），其定义为 $|\\text{PPV}_{\\text{A}} - \\text{PPV}_{\\text{B}}| \\le \\epsilon$，容差 $\\epsilon = 10^{-6}$。\n\n处理未定义量：\n- 如果某个组中计算某个比率的分母为零，则该比率在该组中被视为未定义。对于均等性检查，将两个未定义的比率（每个组中针对同一指标）视作相等；如果一个比率未定义而另一个已定义，则视作不相等。对于下文要求的差异摘要，如果两个 PPV 均未定义，则将 PPV 的绝对差值设为 $0.0$。\n\n对于每个测试用例，您的程序必须按以下顺序输出一个包含四个条目的列表：\n- 一个表示 EO 是否成立的布尔值（$\\text{True}$ 或 $\\text{False}$）。\n- 一个表示 PP 是否成立的布尔值（$\\text{True}$ 或 $\\text{False}$）。\n- 基准率的绝对差值 $|\\pi_{\\text{A}} - \\pi_{\\text{B}}|$，四舍五入到六位小数。\n- PPV 的绝对差值 $|\\text{PPV}_{\\text{A}} - \\text{PPV}_{\\text{B}}|$，四舍五入到六位小数，并且如上所述，在两个 PPV 均未定义的情况下设为 $0.0$。\n\n您的程序应生成单行输出，其中包含一个由每个案例的列表组成的逗号分隔列表，并用方括号括起来，例如：$[[\\text{True},\\text{False},0.125000,0.031250],[\\dots]]$。所有小数结果必须以十进制形式表示；不要使用百分号。\n\n使用以下四个案例的测试套件。每个案例提供八个非负整数 $(TP_{\\text{A}},FP_{\\text{A}},TN_{\\text{A}},FN_{\\text{A}},TP_{\\text{B}},FP_{\\text{B}},TN_{\\text{B}},FN_{\\text{B}})$：\n\n- 案例 1（错误率相同但基准率不同；预期均等化赔率成立而预测均等不成立）：\n  - $(TP_{\\text{A}},FP_{\\text{A}},TN_{\\text{A}},FN_{\\text{A}}) = (80, 20, 80, 20)$\n  - $(TP_{\\text{B}},FP_{\\text{B}},TN_{\\text{B}},FN_{\\text{B}}) = (40, 30, 120, 10)$\n\n- 案例 2（PPV 相等但错误率不同；预期预测均等成立而均等化赔率不成立）：\n  - $(TP_{\\text{A}},FP_{\\text{A}},TN_{\\text{A}},FN_{\\text{A}}) = (50, 50, 50, 50)$\n  - $(TP_{\\text{B}},FP_{\\text{B}},TN_{\\text{B}},FN_{\\text{B}}) = (30, 30, 120, 20)$\n\n- 案例 3（两组中均为退化的始终为负的分类器；将两个 PPV 均视为未定义且相等，因此两种均等性都成立）：\n  - $(TP_{\\text{A}},FP_{\\text{A}},TN_{\\text{A}},FN_{\\text{A}}) = (0, 0, 90, 10)$\n  - $(TP_{\\text{B}},FP_{\\text{B}},TN_{\\text{B}},FN_{\\text{B}}) = (0, 0, 80, 20)$\n\n- 案例 4（基准率和错误率均相同；预期两种均等性都成立）：\n  - $(TP_{\\text{A}},FP_{\\text{A}},TN_{\\text{A}},FN_{\\text{A}}) = (42, 28, 112, 18)$\n  - $(TP_{\\text{B}},FP_{\\text{B}},TN_{\\text{B}},FN_{\\text{B}}) = (21, 14, 56, 9)$\n\n您的程序必须按此顺序硬编码上述测试用例和容差 $\\epsilon = 10^{-6}$。它必须输出单行内容：一个包含四个子列表的列表（每个案例一个），严格按照案例的顺序排列，其中每个子列表为 $[\\text{EO},\\text{PP},|\\pi_{\\text{A}} - \\pi_{\\text{B}}|,|\\text{PPV}_{\\text{A}} - \\text{PPV}_{\\text{B}}|]$，并且两个浮点数条目按规定四舍五入到六位小数。",
            "solution": "对于所提供的测试用例，该问题定义明确，并在流行病学和算法公平性领域具有科学依据。它要求计算一个二元分类器在两个人口群体中的标准性能和公平性指标。\n\n分析首先需要根据为每个组 $g \\in \\{\\text{A}, \\text{B}\\}$ 提供的 $2 \\times 2$ 列联表中的计数来定义必要的量：真阳性（$TP_g$）、假阳性（$FP_g$）、真阴性（$TN_g$）和假阴性（$FN_g$）。\n\n为每个组 $g$ 计算的核心量是：\n1.  **状况为阳性的总数**：真正患有该状况的个体数量。\n    $$P_g = TP_g + FN_g$$\n2.  **状况为阴性的总数**：真正未患有该状况的个体数量。\n    $$N'_g = FP_g + TN_g$$\n3.  **预测为阳性的总数**：被算法预测为患有该状况的个体数量。\n    $$\\hat{P}_g = TP_g + FP_g$$\n4.  **总人口**：该组中的个体总数。\n    $$N_{total, g} = TP_g + FP_g + TN_g + FN_g = P_g + N'_g$$\n\n基于这些，我们可以为每个组 $g$ 定义所需的比率：\n-   **正类患病率（基准率）**，$\\pi_g$：组中患有该状况的个体比例。\n    $$\\pi_g = \\frac{P_g}{N_{total, g}} = \\frac{TP_g + FN_g}{TP_g + FP_g + TN_g + FN_g}$$\n-   **真阳性率（TPR）**，也称为灵敏度（sensitivity）或召回率（recall）：患有该状况的个体中被算法正确识别的比例。\n    $$\\text{TPR}_g = \\frac{TP_g}{P_g} = \\frac{TP_g}{TP_g + FN_g}$$\n    如果分母 $P_g = 0$，则该值未定义。\n-   **假阳性率（FPR）**：未患有该状况的个体中被算法错误识别的比例。\n    $$\\text{FPR}_g = \\frac{FP_g}{N'_g} = \\frac{FP_g}{FP_g + TN_g}$$\n    如果分母 $N'_g = 0$，则该值未定义。\n-   **阳性预测值（PPV）**，也称为精确率（precision）：在被预测为患有该状况的个体中，真正患有该状况的比例。\n    $$\\text{PPV}_g = \\frac{TP_g}{\\hat{P}_g} = \\frac{TP_g}{TP_g + FP_g}$$\n    如果分母 $\\hat{P}_g = 0$，则该值未定义。\n\n接下来，我们使用容差 $\\epsilon = 10^{-6}$ 来评估 A 组和 B 组之间的公平性标准。\n\n-   **均等化赔率（EO）**：如果分类器在两个组中具有相等的 TPR 和 FPR，则满足此标准。需要对未定义的比率进行特殊处理：两个未定义的比率（例如 $\\text{TPR}_\\text{A}$ 和 $\\text{TPR}_\\text{B}$）被视为相等，而一个已定义的比率和一个未定义的比率被视为不相等。形式上，如果以下两个条件都满足，则 EO 成立：\n    1.  TPR 被视为相等：$|\\text{TPR}_{\\text{A}} - \\text{TPR}_{\\text{B}}| \\le \\epsilon$，或者两个比率都未定义。\n    2.  FPR 被视为相等：$|\\text{FPR}_{\\text{A}} - \\text{FPR}_{\\text{B}}| \\le \\epsilon$，或者两个比率都未定义。\n\n-   **预测均等（PP）**：如果分类器在两个组中具有相等的 PPV，并且遵循相同的未定义比率处理规则，则满足此标准。形式上，如果满足以下条件，则 PP 成立：\n    1.  PPV 被视为相等：$|\\text{PPV}_{\\text{A}} - \\text{PPV}_{\\text{B}}| \\le \\epsilon$，或者两个比率都未定义。\n\n最后，对于每个测试用例，我们必须组合一个包含四个值的列表：\n1.  一个指示 EO 是否成立的布尔值（$\\text{True}$ 或 $\\text{False}$）。\n2.  一个指示 PP 是否成立的布尔值（$\\text{True}$ 或 $\\text{False}$）。\n3.  基准率的绝对差值， $|\\pi_{\\text{A}} - \\pi_{\\text{B}}|$。\n4.  PPV 的绝对差值， $|\\text{PPV}_{\\text{A}} - \\text{PPV}_{\\text{B}}|$。根据问题规范，如果 $\\text{PPV}_{\\text{A}}$ 和 $\\text{PPV}_{\\text{B}}$ 都未定义，则此差值设为 $0.0$。\n\n总体算法如下：\n1.  对于每个测试用例，检索八个输入值： $(TP_{\\text{A}}, FP_{\\text{A}}, TN_{\\text{A}}, FN_{\\text{A}}, TP_{\\text{B}}, FP_{\\text{B}}, TN_{\\text{B}}, FN_{\\text{B}})$。\n2.  定义一个过程，该过程以 $(TP, FP, TN, FN)$ 作为输入并计算比率 $(\\pi, \\text{TPR}, \\text{FPR}, \\text{PPV})$，对于分母为零的任何比率，返回一个特殊值（例如 Python 中的 `None`）。\n3.  将此过程应用于 A 组和 B 组的数据，以获得它们各自的比率。\n4.  实现一个比较函数，该函数接收两个比率和容差 $\\epsilon$，并根据问题的规则（即绝对差值在容差范围内，或两者都未定义）返回 `True`（如果它们被视为相等）。\n5.  使用此比较函数检查 EO（比较 TPR 和 FPR）和 PP（比较 PPV）。\n6.  计算基准率的绝对差值， $|\\pi_{\\text{A}} - \\pi_{\\text{B}}|$。\n7.  计算 PPV 的绝对差值， $|\\text{PPV}_{\\text{A}} - \\text{PPV}_{\\text{B}}|$，应用两者都未定义时的特殊规则。\n8.  将四个结果值格式化为一个列表，将浮点数四舍五入到六位小数。\n9.  将所有测试用例的列表收集到一个最终列表中，并将其格式化为所需的字符串输出。\n\n**示例演练：案例 1**\n-   A 组： $(TP_{\\text{A}}, FP_{\\text{A}}, TN_{\\text{A}}, FN_{\\text{A}}) = (80, 20, 80, 20)$\n    -   $P_A = 80+20=100$, $N'_A = 20+80=100$, $\\hat{P}_A = 80+20=100$, $N_{total,A} = 200$。\n    -   $\\pi_A = 100/200 = 0.5$, $\\text{TPR}_A = 80/100 = 0.8$, $\\text{FPR}_A = 20/100 = 0.2$, $\\text{PPV}_A = 80/100=0.8$。\n-   B 组： $(TP_{\\text{B}}, FP_{\\text{B}}, TN_{\\text{B}}, FN_{\\text{B}}) = (40, 30, 120, 10)$\n    -   $P_B = 40+10=50$, $N'_B = 30+120=150$, $\\hat{P}_B = 40+30=70$, $N_{total,B} = 200$。\n    -   $\\pi_B = 50/200 = 0.25$, $\\text{TPR}_B = 40/50 = 0.8$, $\\text{FPR}_B = 30/150 = 0.2$, $\\text{PPV}_B = 40/70 \\approx 0.571429$。\n-   **EO 检查**：$|\\text{TPR}_A - \\text{TPR}_B| = |0.8 - 0.8| = 0 \\le \\epsilon$。$|\\text{FPR}_A - \\text{FPR}_B| = |0.2 - 0.2| = 0 \\le \\epsilon$。两者都通过。EO 为 $\\text{True}$。\n-   **PP 检查**：$|\\text{PPV}_A - \\text{PPV}_B| = |0.8 - 40/70| \\approx 0.228571 > \\epsilon$。未通过。PP 为 $\\text{False}$。\n-   **差值**：\n    -   $|\\pi_A - \\pi_B| = |0.5 - 0.25| = 0.25$。\n    -   $|\\text{PPV}_A - \\text{PPV}_B| \\approx 0.228571$。\n-   **结果**：$[\\text{True}, \\text{False}, 0.250000, 0.228571]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted.\n\ndef solve():\n    \"\"\"\n    Computes fairness metrics and differences for a binary classifier\n    across two groups for a given suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (80, 20, 80, 20, 40, 30, 120, 10),\n        # Case 2\n        (50, 50, 50, 50, 30, 30, 120, 20),\n        # Case 3\n        (0, 0, 90, 10, 0, 0, 80, 20),\n        # Case 4\n        (42, 28, 112, 18, 21, 14, 56, 9),\n    ]\n\n    epsilon = 1e-6\n    all_results = []\n\n    def calculate_metrics(tp, fp, tn, fn):\n        \"\"\"\n        Calculates prevalence and performance metrics. Returns None for undefined rates.\n        \"\"\"\n        total_pop = tp + fp + tn + fn\n        \n        # Denominators\n        p_cond = tp + fn      # Condition Positive\n        n_cond = fp + tn      # Condition Negative\n        p_pred = tp + fp      # Predicted Positive\n\n        pi = p_cond / total_pop if total_pop > 0 else 0.0\n        tpr = tp / p_cond if p_cond > 0 else None\n        fpr = fp / n_cond if n_cond > 0 else None\n        ppv = tp / p_pred if p_pred > 0 else None\n\n        return pi, tpr, fpr, ppv\n\n    def are_rates_equal(rate_a, rate_b, tol):\n        \"\"\"\n        Compares two rates according to the problem's rules for undefined values.\n        \"\"\"\n        if rate_a is None and rate_b is None:\n            return True\n        if rate_a is None or rate_b is None:\n            return False\n        return abs(rate_a - rate_b) = tol\n\n    for case in test_cases:\n        tp_a, fp_a, tn_a, fn_a, tp_b, fp_b, tn_b, fn_b = case\n\n        pi_a, tpr_a, fpr_a, ppv_a = calculate_metrics(tp_a, fp_a, tn_a, fn_a)\n        pi_b, tpr_b, fpr_b, ppv_b = calculate_metrics(tp_b, fp_b, tn_b, fn_b)\n\n        # Evaluate Equalized Odds (EO)\n        eo_holds = are_rates_equal(tpr_a, tpr_b, epsilon) and \\\n                   are_rates_equal(fpr_a, fpr_b, epsilon)\n\n        # Evaluate Predictive Parity (PP)\n        pp_holds = are_rates_equal(ppv_a, ppv_b, epsilon)\n\n        # Calculate absolute difference in base rates\n        pi_diff = abs(pi_a - pi_b)\n\n        # Calculate absolute difference in PPVs with special handling\n        if ppv_a is None and ppv_b is None:\n            ppv_diff = 0.0\n        # The case where one is None and the other is not is not in the test data,\n        # so a simple calculation is sufficient for the valid test cases.\n        else:\n            ppv_diff = abs(ppv_a - ppv_b)\n\n        # Append formatted results for the current case\n        all_results.append([eo_holds, pp_holds, pi_diff, ppv_diff])\n\n    # Format the final output string exactly as required, avoiding extra spaces.\n    formatted_results = []\n    for res in all_results:\n        # Format: [bool,bool,float,float] without spaces\n        # Python's str(True) is 'True', which is correct.\n        # f-string formatting handles rounding to 6 decimal places.\n        formatted_str = f\"[{str(res[0])},{str(res[1])},{res[2]:.6f},{res[3]:.6f}]\"\n        formatted_results.append(formatted_str)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}