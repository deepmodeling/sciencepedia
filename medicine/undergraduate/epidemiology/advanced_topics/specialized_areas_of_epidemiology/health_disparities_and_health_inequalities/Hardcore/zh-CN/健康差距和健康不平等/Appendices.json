{
    "hands_on_practices": [
        {
            "introduction": "为了有意义地比较不同人群的健康结果，我们必须首先校正年龄等混杂因素。本练习将介绍间接标准化法，这是一种用于计算标准化死亡比（SMR）的基础流行病学技术。通过完成此练习 ，您将学会如何量化特定群体相对于标准人群的超额死亡率，并批判性地评估此类比较背后的假设。",
            "id": "4595794",
            "problem": "一个公共卫生团队正在评估一个弱势城市社区集群的死亡率，该社区集群的慢性病负担加重，且预防性保健服务的可及性有限。为了研究健康不平等，他们决定以国家标准为参照，进行间接年龄标化。假设观察期为一年，随访完整，人口迁入和迁出可忽略不计，因此每位居民大约贡献 $1$ 个人年。国家标准的年龄别死亡率如下：\n\n- 年龄 $0$–$44$ 岁：$1.2$ / $1{,}000$ 人年\n- 年龄 $45$–$64$ 岁：$5.6$ / $1{,}000$ 人年\n- 年龄 $65$–$74$ 岁：$14.0$ / $1{,}000$ 人年\n- 年龄 $75$–$84$ 岁：$40.0$ / $1{,}000$ 人年\n- 年龄 $\\ge 85$ 岁：$110.0$ / $1{,}000$ 人年\n\n该弱势群体在基线时的年龄分布如下：\n\n- 年龄 $0$–$44$ 岁：$12{,}500$ 名居民\n- 年龄 $45$–$64$ 岁：$8{,}400$ 名居民\n- 年龄 $65$–$74$ 岁：$2{,}900$ 名居民\n- 年龄 $75$–$84$ 岁：$1{,}100$ 名居民\n- 年龄 $\\ge 85$ 岁：$270$ 名居民\n\n在这一年中，该弱势群体总共经历了 $223$ 例观察到的死亡（所有原因）。仅使用死亡率、间接标化和比率测量的基本定义，计算该弱势群体相对于国家标准的标化死亡比。将最终的标化死亡比表示为一个无单位小数，并将您的答案四舍五入到四位有效数字。\n\n然后，解释当弱势群体的潜在健康需求与标准人口存在系统性差异时（例如，由于更高的基线发病率、环境暴露或医疗服务可及性障碍），标化死亡比在解释上可能存在的陷阱。您的解释应侧重于为什么该比率可能将需求与表现或其他结构性因素混为一谈，以及进行公平比较需要哪些假设。\n\n注意：标化死亡比（SMR）应被解释为一个无量纲比率，用于比较在标准率下观察到的死亡人数与预期死亡人数。",
            "solution": "该问题要求计算一个弱势群体的标化死亡比（SMR），并解释在健康差异背景下该指标的解释陷阱。解决方案分两部分进行：首先是SMR的定量计算，其次是对其假设和局限性的定性分析。\n\n**第一部分：标化死亡比（SMR）的计算**\n\n标化死亡比的定义是研究人群中观察到的总死亡人数与预期总死亡人数之比。预期死亡人数是通过将标准人口的年龄别死亡率应用于研究人群的年龄结构来计算的。\n\nSMR的公式为：\n$$ \\text{SMR} = \\frac{\\text{观察死亡人数}}{\\text{预期死亡人数}} = \\frac{D_O}{D_E} $$\n\n给定的观察死亡总人数 $D_O$ 为 $223$。\n\n预期死亡总人数 $D_E$ 是每个年龄分层 $i$ 中预期死亡人数的总和。给定分层 $d_{E,i}$ 的预期死亡人数是通过将该分层中研究人群的人数 $N_i$ 乘以标准人口中相应的年龄别死亡率 $M_i$ 来计算的。\n$$ D_E = \\sum_i d_{E,i} = \\sum_i (N_i \\times M_i) $$\n\n我们有以下数据：\n\n研究人群 ($N_i$):\n- 年龄 $0$–$44$ 岁: $N_1 = 12,500$\n- 年龄 $45$–$64$ 岁: $N_2 = 8,400$\n- 年龄 $65$–$74$ 岁: $N_3 = 2,900$\n- 年龄 $75$–$84$ 岁: $N_4 = 1,100$\n- 年龄 $\\ge 85$ 岁: $N_5 = 270$\n\n标准死亡率 ($M_i$)，从每 $1,000$ 人年转换为小数率：\n- 年龄 $0$–$44$ 岁: $M_1 = 1.2 / 1000 = 0.0012$\n- 年龄 $45$–$64$ 岁: $M_2 = 5.6 / 1000 = 0.0056$\n- 年龄 $65$–$74$ 岁: $M_3 = 14.0 / 1000 = 0.0140$\n- 年龄 $75–84$ 岁: $M_4 = 40.0 / 1000 = 0.0400$\n- 年龄 $\\ge 85$ 岁: $M_5 = 110.0 / 1000 = 0.1100$\n\n现在，我们计算每个年龄分层的预期死亡人数：\n- 分层 $1$ (年龄 $0$–$44$ 岁): $d_{E,1} = N_1 \\times M_1 = 12,500 \\times 0.0012 = 15.0$\n- 分层 $2$ (年龄 $45$–$64$ 岁): $d_{E,2} = N_2 \\times M_2 = 8,400 \\times 0.0056 = 47.04$\n- 分层 $3$ (年龄 $65$–$74$ 岁): $d_{E,3} = N_3 \\times M_3 = 2,900 \\times 0.0140 = 40.6$\n- 分层 $4$ (年龄 $75$–$84$ 岁): $d_{E,4} = N_4 \\times M_4 = 1,100 \\times 0.0400 = 44.0$\n- 分层 $5$ (年龄 $\\ge 85$ 岁): $d_{E,5} = N_5 \\times M_5 = 270 \\times 0.1100 = 29.7$\n\n预期死亡总人数 $D_E$ 是这些值的总和：\n$$ D_E = 15.0 + 47.04 + 40.6 + 44.0 + 29.7 = 176.34 $$\n\n已知 $D_O = 223$ 和 $D_E = 176.34$，我们现在可以计算SMR：\n$$ \\text{SMR} = \\frac{D_O}{D_E} = \\frac{223}{176.34} \\approx 1.2645967... $$\n\n四舍五入到四位有效数字，我们得到：\n$$ \\text{SMR} \\approx 1.265 $$\n$1.265$ 的SMR表明，如果该弱势群体的年龄别死亡率与国家标准人口相同，那么他们经历的死亡人数比预期多出约 $26.5\\%$。\n\n**第二部分：SMR的解释陷阱**\n\nSMR的计算基于一个关键但通常未明说的假设：在考虑了年龄因素后，标准人口的年龄别死亡率 ($M_i$) 是研究人群中应有的预期率。为使比较公平，必须假设在每个年龄分层内，研究人群和标准人群在潜在的健康状况和风险方面是可比的。这被称为年龄别率比在各人群间具有可比性的假设。\n\n在健康差异的背景下，这个假设被根本性地违反了。问题陈述本身就指明研究群体是一个“弱势城市社区”，具有“加重的慢性病负担和有限的预防性保健服务可及性”。这导致了重大的解释陷阱：\n\n1.  **将需求、结构性因素和表现混为一谈：** 升高的SMR并不能清晰地分离出单一原因。超额死亡率（本例中为 $26.5\\%$）是多个相互纠缠的因素的综合效应：\n    *   **更高的健康需求：** 与全国平均水平相比，弱势人群在任何给定年龄的发病（疾病）患病率和严重程度可能都更高。例如，这个群体中一个 $50$ 岁的人的健康状况可能更类似于标准人口中一个 $60$ 岁的人。将 $50$ 岁人群的标准死亡率应用于这个群体，会低估基于他们实际健康状况的“预期”死亡率。\n    *   **结构性劣势：** 诸如更高的环境污染暴露、社会经济困境带来的慢性压力、食物沙漠和不安全的住房等因素，可以独立于医疗保健的可及性或质量，直接增加死亡风险。这些因素在标准人口中不存在于同等程度上，而SMR并未对它们进行校正。\n    *   **医疗保健系统表现：** “有限的预防性保健服务可及性”以及可能较低质量的治疗性保健，导致许多疾病的病死率更高。这是医疗保健系统未能满足人群需求的失败。\n\n2.  **“预期”死亡人数的误导性：** “预期死亡人数”是一个技术性术语。它不代表一个具有高疾病负担的人群的现实期望。它代表一个假设情景：“如果这个人群，尽管存在劣势，却神奇地拥有了更健康、资源更丰富的标准人口的死亡风险，会怎么样？” SMR衡量的是观察到的现实与这个反事实理想之间的差距。将整个差距归因于单一原因，例如“医院质量差”，是一种生态谬误。它忽略了该人群从一开始就病得更重的事实。\n\n为了使SMR成为公平比较（例如，两个地区之间医疗保健质量）的工具，必须假设这些人群具有相似的潜在疾病负担和风险因素概况，仅在他们接受的医疗保健方面有所不同。在健康不平等的研究中，这个假设根据定义就是无效的。因此，SMR是一个有用的工具，用于*量化*不平等的程度，但在没有更多信息的情况下，它不是一个*解释*其原因的工具。它表明存在一个问题，但本身并不能诊断该问题的病因。",
            "answer": "$$ \\boxed{1.265} $$"
        },
        {
            "introduction": "计算出的差异的可靠性取决于其测量数据的质量。在健康差异研究中，测量误差可能在不同群体间存在系统性差异，这个问题被称为差异性错分。本练习  将演示如何通过数学推导来量化此类误差所引入的偏倚，揭示它们如何扭曲我们对真实健康结果差距的理解。",
            "id": "4595786",
            "problem": "一项城市队列研究调查了两个种族或族裔群体 $A$ 和 $B$ 中的一个二元健康结局 $Y$（$12$ 个月内未控制的高血压），以评估健康差异。令 $p_{A} = P(Y=1 \\mid A)$ 和 $p_{B} = P(Y=1 \\mid B)$ 表示真实风险。该差异由风险差 $RD = p_{A} - p_{B}$ 和风险比 $RR = \\frac{p_{A}}{p_{B}}$ 来概括。在该调查中，结局是通过一种算法来确定的，该算法由于在就医途径和测量保真度上的差异，在不同群体间表现出差异性错分。对于群体 $g \\in \\{A,B\\}$，令灵敏度为 $Se_{g} = P(Y^{*}=1 \\mid Y=1, g)$，特异度为 $Sp_{g} = P(Y^{*}=0 \\mid Y=0, g)$，其中 $Y^{*}$ 是算法记录的错分结局。假设组内误差为非差异性的（即算法的 $Se_{g}$ 和 $Sp_{g}$ 不依赖于协变量），并且在真实结局的条件下，错分是独立的。\n\n给定经临床判定的真实风险 $p_{A} = 0.15$ 和 $p_{B} = 0.10$，以及算法性能 $Se_{A} = 0.85$，$Sp_{A} = 0.95$，$Se_{B} = 0.70$ 和 $Sp_{B} = 0.98$，请完成以下任务：\n\n1. 仅使用灵敏度和特异度的基本定义，推导每个群体中观测风险 $p^{*}_{g} = P(Y^{*}=1 \\mid g)$ 作为 $p_{g}$、$Se_{g}$ 和 $Sp_{g}$ 函数的表达式。\n\n2. 使用您推导的表达式来求得观测差异指标 $RD^{*} = p^{*}_{A} - p^{*}_{B}$ 和 $RR^{*} = \\frac{p^{*}_{A}}{p^{*}_{B}}$。\n\n3. 推导每个差异指标中由于差异性错分而产生的偏倚，其加性定义为 $RD^{*} - RD$ 和 $RR^{*} - RR$。确定每个指标的偏倚方向（即观测指标是高估还是低估了真实指标），并计算偏倚的大小。\n\n报告两个数值偏倚量 $RD^{*} - RD$ 和 $RR^{*} - RR$，四舍五入到四位有效数字。将数字表示为不带单位的小数。",
            "solution": "该问题经评估为有效。它在科学上基于流行病学的原理，特别是关于测量误差及其对关联度量的影响。该问题提法明确，提供了所有必要的数据和定义，可以得出一个唯一的、有意义的解。它没有歧义、矛盾和主观断言。\n\n按要求，解答过程分为三个部分。\n\n### 第1部分：观测风险 $p^{*}_{g}$ 的推导\n群体 $g$ 的观测风险，记为 $p^{*}_{g}$，是测试结果为阳性的概率，即 $P(Y^{*}=1 \\mid g)$。我们可以通过对真实疾病状态 $Y$ 进行条件化，使用全概率定律来推导这个量的表达式。\n\n对于任何群体 $g \\in \\{A, B\\}$，总体可以划分为真正患有该病症的人（$Y=1$）和没有患该病症的人（$Y=0$）。因此，我们可以写出：\n$$\np^{*}_{g} = P(Y^{*}=1 \\mid g) = P(Y^{*}=1, Y=1 \\mid g) + P(Y^{*}=1, Y=0 \\mid g)\n$$\n使用条件概率的定义 $P(X,Z \\mid W) = P(X \\mid Z,W)P(Z \\mid W)$，我们可以展开每一项：\n$$\np^{*}_{g} = P(Y^{*}=1 \\mid Y=1, g) P(Y=1 \\mid g) + P(Y^{*}=1 \\mid Y=0, g) P(Y=0 \\mid g)\n$$\n我们从问题陈述中可以识别出此表达式中的各项：\n-   $P(Y=1 \\mid g)$ 是真实风险，$p_{g}$。\n-   $P(Y=0 \\mid g) = 1 - P(Y=1 \\mid g) = 1 - p_{g}$。\n-   $P(Y^{*}=1 \\mid Y=1, g)$ 是群体 $g$ 的测试灵敏度，$Se_{g}$。\n-   $P(Y^{*}=1 \\mid Y=0, g)$ 是假阳性率。这与特异度 $Sp_{g} = P(Y^{*}=0 \\mid Y=0, g)$ 通过关系 $P(Y^{*}=1 \\mid Y=0, g) = 1 - Sp_{g}$ 相关联。\n\n将这些定义代入方程，得到观测风险的期望表达式：\n$$\np^{*}_{g} = (Se_{g} \\cdot p_{g}) + (1 - Sp_{g}) \\cdot (1 - p_{g})\n$$\n该公式表明，观测患病率是测试检测到的真阳性数和测试产生的假阳性数的总和。\n\n### 第2部分：观测差异指标 $RD^{*}$ 和 $RR^{*}$ 的计算\n首先，我们使用给定的真实风险 $p_{A}=0.15$ 和 $p_{B}=0.10$ 计算真实差异指标 $RD$ 和 $RR$。\n$$\nRD = p_{A} - p_{B} = 0.15 - 0.10 = 0.05\n$$\n$$\nRR = \\frac{p_{A}}{p_{B}} = \\frac{0.15}{0.10} = 1.5\n$$\n接下来，我们应用第1部分中推导的公式，使用给定的灵敏度和特异度计算观测风险 $p^{*}_{A}$ 和 $p^{*}_{B}$。\n\n对于群体 A：$p_{A} = 0.15$，$Se_{A} = 0.85$，$Sp_{A} = 0.95$。\n$$\np^{*}_{A} = (Se_{A} \\cdot p_{A}) + (1 - Sp_{A}) \\cdot (1 - p_{A})\n$$\n$$\np^{*}_{A} = (0.85 \\cdot 0.15) + (1 - 0.95) \\cdot (1 - 0.15)\n$$\n$$\np^{*}_{A} = (0.1275) + (0.05) \\cdot (0.85) = 0.1275 + 0.0425 = 0.1700\n$$\n对于群体 B：$p_{B} = 0.10$，$Se_{B} = 0.70$，$Sp_{B} = 0.98$。\n$$\np^{*}_{B} = (Se_{B} \\cdot p_{B}) + (1 - Sp_{B}) \\cdot (1 - p_{B})\n$$\n$$\np^{*}_{B} = (0.70 \\cdot 0.10) + (1 - 0.98) \\cdot (1 - 0.10)\n$$\n$$\np^{*}_{B} = (0.07) + (0.02) \\cdot (0.90) = 0.07 + 0.018 = 0.0880\n$$\n现在，我们可以计算观测差异指标 $RD^{*}$ 和 $RR^{*}$。\n$$\nRD^{*} = p^{*}_{A} - p^{*}_{B} = 0.1700 - 0.0880 = 0.0820\n$$\n$$\nRR^{*} = \\frac{p^{*}_{A}}{p^{*}_{B}} = \\frac{0.1700}{0.0880} \\approx 1.931818...\n$$\n\n### 第3部分：偏倚的计算\n每个指标的加性偏倚是观测指标与真实指标之差。\n\n对于风险差（$RD$）：\n$$\n\\text{Bias}_{RD} = RD^{*} - RD = 0.0820 - 0.05 = 0.0320\n$$\n由于偏倚为正，差异性错分导致对真实风险差的**高估**。偏倚的大小，四舍五入到四位有效数字，是 $0.03200$。\n\n对于风险比（$RR$）：\n$$\n\\text{Bias}_{RR} = RR^{*} - RR = \\frac{0.1700}{0.0880} - 1.5 = \\frac{170}{88} - \\frac{3}{2} = \\frac{85}{44} - \\frac{66}{44} = \\frac{19}{44}\n$$\n$$\n\\text{Bias}_{RR} \\approx 0.431818...\n$$\n由于该偏倚也为正，差异性错分同样导致对真实风险比的**高估**。偏倚的大小，四舍五入到四位有效数字，是 $0.4318$。\n\n两个数值偏倚量分别为：风险差为 $0.03200$，风险比为 $0.4318$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.03200  0.4318 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在识别出健康差异后，下一个关键步骤是理解其潜在驱动因素。Kitagawa分解法是一种强大的工具，可将两个人群之间总体率的差异分解为两个关键部分：人口结构差异和亚组特定率差异。这个编程练习  将让您掌握一个分析工具，用以确定一个差异主要是由人群构成（“who”）所驱动，还是由每个亚组内部经历的不同结果（“what”）所驱动。",
            "id": "4595822",
            "problem": "给定两个总体，每个总体都被划分为有限数量的互斥且穷尽的子组。对于每个总体，您已知其子组构成（加总为 $1$ 的子组比例向量）和子组特定率（可解释为介于 $0$ 和 $1$ 之间的小数，不使用百分号）。一个总体的总（粗）率定义为使用子组构成权重对子组特定率进行的加权和。仅从这些基本定义出发，推导并实现一个精确、对称的分解方法，将两个总体粗率之差分解为两个可加分量：一个归因于子组间总体构成的差异，另一个归因于子组特定率的差异。该分解必须在构造上无残差，并且相对于两个总体是对称的。\n\n形式上，对于总体 $A$（其子组比例为 $\\{p_{A,i}\\}_{i=1}^{k}$，子组率为 $\\{r_{A,i}\\}_{i=1}^{k}$）和总体 $B$（其子组比例为 $\\{p_{B,i}\\}_{i=1}^{k}$，子组率为 $\\{r_{B,i}\\}_{i=1}^{k}$），粗率分别为\n$$\nR_A = \\sum_{i=1}^{k} p_{A,i} \\, r_{A,i}, \\quad R_B = \\sum_{i=1}^{k} p_{B,i} \\, r_{B,i}.\n$$\n令 $\\Delta = R_A - R_B$。将 $\\Delta$ 分解为两个分量之和，即构成部分 $C$ 和率部分 $S$，使得 $\\Delta = C + S$ 精确成立。其中，$C$ 仅捕捉 $\\{p_{A,i}\\}$ 与 $\\{p_{B,i}\\}$ 之间差异的贡献，而 $S$ 仅捕捉 $\\{r_{A,i}\\}$ 与 $\\{r_{B,i}\\}$ 之间差异的贡献，并且处理方式对两个总体是对称的。\n\n您的任务是编写一个完整的程序，对每个提供的测试用例，计算三元组 $[\\Delta, C, S]$，结果为四舍五入到六位小数的实数。所有输入都已在程序中提供，不得从标准输入读取。所有子组比例必须为非负数，且在每个总体内总和为 $1$；所有子组率必须在区间 $[0,1]$ 内（小数形式，不带百分号）。\n\n测试套件：\n- 案例 1（一般三子组情况）：\n  - $p_A = [0.2, 0.3, 0.5]$, $r_A = [0.1, 0.15, 0.25]$\n  - $p_B = [0.3, 0.3, 0.4]$, $r_B = [0.05, 0.20, 0.35]$\n- 案例 2（构成相同；仅子组率不同）：\n  - $p_A = [0.4, 0.6]$, $r_A = [0.1, 0.2]$\n  - $p_B = [0.4, 0.6]$, $r_B = [0.15, 0.25]$\n- 案例 3（子组率相同；仅构成不同）：\n  - $p_A = [0.2, 0.8]$, $r_A = [0.1, 0.3]$\n  - $p_B = [0.8, 0.2]$, $r_B = [0.1, 0.3]$\n- 案例 4（含零子组率和零子组比例的边缘情况）：\n  - $p_A = [0.5, 0.0, 0.5]$, $r_A = [0.0, 0.2, 0.4]$\n  - $p_B = [0.2, 0.3, 0.5]$, $r_B = [0.0, 0.1, 0.5]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个包含三个数字 $[\\Delta, C, S]$ 的子列表。输出行中不得有任何空格。例如：$[[a_1,b_1,c_1],[a_2,b_2,c_2],\\ldots]$。\n- 所有数字必须四舍五入到六位小数。",
            "solution": "我们从粗率和子组分层的基本定义开始。假设有 $k$ 个不相交的子组，索引为 $i \\in \\{1,\\ldots,k\\}$。对于每个总体 $A$ 和 $B$，用 $\\{p_{A,i}\\}$ 和 $\\{p_{B,i}\\}$ 表示子组构成，其中 $\\sum_{i=1}^{k} p_{A,i} = 1$ 且 $\\sum_{i=1}^{k} p_{B,i} = 1$，所有 $p_{\\cdot,i} \\ge 0$。分别用 $\\{r_{A,i}\\}$ 和 $\\{r_{B,i}\\}$ 表示子组特定率（例如，介于 $0$ 和 $1$ 之间的风险或发病率）。粗率由以下公式给出\n$$\nR_A = \\sum_{i=1}^{k} p_{A,i} \\, r_{A,i}, \\quad R_B = \\sum_{i=1}^{k} p_{B,i} \\, r_{B,i}.\n$$\n我们寻求将 $\\Delta = R_A - R_B$ 进行精确、对称的分解，分解为一个构成部分 $C$ 和一个率部分 $S$，且无残差。\n\n从\n$$\n\\Delta = \\sum_{i=1}^{k} \\big(p_{A,i} r_{A,i} - p_{B,i} r_{B,i}\\big),\n$$\n开始，我们以对称的方式加上和减去对跨总体构成和率进行平均的项。具体来说，在求和内部加上并减去 $\\tfrac{1}{2} p_{A,i} r_{B,i}$ 和 $\\tfrac{1}{2} p_{B,i} r_{A,i}$，以在总体之间建立等权重的桥梁。然后重新组合，以分离仅与构成相关的对比和仅与率相关的对比：\n$$\n\\Delta = \\sum_{i=1}^{k} \\left[\\frac{(p_{A,i} - p_{B,i})(r_{A,i} + r_{B,i})}{2}\\right] + \\sum_{i=1}^{k} \\left[\\frac{(r_{A,i} - r_{B,i})(p_{A,i} + p_{B,i})}{2}\\right].\n$$\n定义构成部分\n$$\nC = \\sum_{i=1}^{k} \\frac{(p_{A,i} - p_{B,i})(r_{A,i} + r_{B,i})}{2},\n$$\n和率部分\n$$\nS = \\sum_{i=1}^{k} \\frac{(r_{A,i} - r_{B,i})(p_{A,i} + p_{B,i})}{2}.\n$$\n根据构造，$C$ 仅依赖于由子组率的平均值调制的构成差异，而 $S$ 仅依赖于由子组构成的平均值调制的率差异。这就是经典的 Kitagawa 分解法，它是精确且对称的，得到 $\\Delta = C + S$，残差为零。\n\n每个测试用例的算法步骤：\n- 输入等长为 $k$ 的向量 $p_A, r_A, p_B, r_B$，包含有效的构成和率。\n- 计算 $R_A = \\sum_i p_{A,i} r_{A,i}$ 和 $R_B = \\sum_i p_{B,i} r_{B,i}$，然后计算 $\\Delta = R_A - R_B$。\n- 计算 $C = \\sum_i \\big((p_{A,i} - p_{B,i}) \\cdot (r_{A,i} + r_{B,i}) / 2\\big)$。\n- 计算 $S = \\sum_i \\big((r_{A,i} - r_{B,i}) \\cdot (p_{A,i} + p_{B,i}) / 2\\big)$。\n- （可选）数值上验证 $|\\Delta - (C + S)|$ 是可忽略的（在浮点舍入误差范围内）。\n- 将 $\\Delta, C, S$ 四舍五入到六位小数，并按规定格式输出。\n\n现在我们为每个测试用例计算所要求的值。\n\n案例 1：\n- $p_A = [0.2, 0.3, 0.5]$, $r_A = [0.1, 0.15, 0.25]$; $p_B = [0.3, 0.3, 0.4]$, $r_B = [0.05, 0.20, 0.35]$。\n- $R_A = 0.2 \\cdot 0.1 + 0.3 \\cdot 0.15 + 0.5 \\cdot 0.25 = 0.02 + 0.045 + 0.125 = 0.19$。\n- $R_B = 0.3 \\cdot 0.05 + 0.3 \\cdot 0.20 + 0.4 \\cdot 0.35 = 0.015 + 0.06 + 0.14 = 0.215$。\n- $\\Delta = 0.19 - 0.215 = -0.025$。\n- $C = \\sum_i (p_{A,i} - p_{B,i}) \\cdot (r_{A,i} + r_{B,i}) / 2 = (-0.1)\\cdot 0.075 + 0.0 \\cdot 0.175 + 0.1 \\cdot 0.30 = -0.0075 + 0 + 0.03 = 0.0225$。\n- $S = \\sum_i (r_{A,i} - r_{B,i}) \\cdot (p_{A,i} + p_{B,i}) / 2 = 0.05 \\cdot 0.25 + (-0.05)\\cdot 0.30 + (-0.10)\\cdot 0.45 = 0.0125 - 0.015 - 0.045 = -0.0475$。\n- 检验: $C + S = 0.0225 - 0.0475 = -0.025 = \\Delta$。\n\n案例 2：\n- $p_A = [0.4, 0.6]$, $r_A = [0.1, 0.2]$; $p_B = [0.4, 0.6]$, $r_B = [0.15, 0.25]$。\n- $R_A = 0.4 \\cdot 0.1 + 0.6 \\cdot 0.2 = 0.04 + 0.12 = 0.16$。\n- $R_B = 0.4 \\cdot 0.15 + 0.6 \\cdot 0.25 = 0.06 + 0.15 = 0.21$。\n- $\\Delta = 0.16 - 0.21 = -0.05$。\n- $C = 0$ 因为 $p_A = p_B$。\n- $S = -0.05$。\n- 检验: $C + S = -0.05 = \\Delta$。\n\n案例 3：\n- $p_A = [0.2, 0.8]$, $r_A = [0.1, 0.3]$; $p_B = [0.8, 0.2]$, $r_B = [0.1, 0.3]$。\n- $R_A = 0.2 \\cdot 0.1 + 0.8 \\cdot 0.3 = 0.02 + 0.24 = 0.26$。\n- $R_B = 0.8 \\cdot 0.1 + 0.2 \\cdot 0.3 = 0.08 + 0.06 = 0.14$。\n- $\\Delta = 0.26 - 0.14 = 0.12$。\n- $C = (-0.6)\\cdot 0.1 + 0.6 \\cdot 0.3 = -0.06 + 0.18 = 0.12$。\n- $S = 0$ 因为 $r_A = r_B$。\n- 检验: $C + S = 0.12 = \\Delta$。\n\n案例 4：\n- $p_A = [0.5, 0.0, 0.5]$, $r_A = [0.0, 0.2, 0.4]$; $p_B = [0.2, 0.3, 0.5]$, $r_B = [0.0, 0.1, 0.5]$。\n- $R_A = 0.5 \\cdot 0.0 + 0.0 \\cdot 0.2 + 0.5 \\cdot 0.4 = 0.2$。\n- $R_B = 0.2 \\cdot 0.0 + 0.3 \\cdot 0.1 + 0.5 \\cdot 0.5 = 0.28$。\n- $\\Delta = 0.2 - 0.28 = -0.08$。\n- $C = (0.3)\\cdot 0 + (-0.3)\\cdot 0.15 + (0.0)\\cdot 0.45 = -0.045$。\n- $S = (0.0)\\cdot 0.35 + (0.1)\\cdot 0.15 + (-0.1)\\cdot 0.5 = -0.035$。\n- 检验: $C + S = -0.08 = \\Delta$。\n\n程序将以通用方式实现这些计算，适用于任何有效的输入向量，并将为所提供的测试套件打印结果。结果为单行输出，包含一个由三元组列表构成的方括号列表，无空格，且数字四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef kitagawa_decomposition(pA, rA, pB, rB):\n    \"\"\"\n    Compute the Kitagawa decomposition for two populations:\n    - pA, rA: compositions and subgroup rates for population A\n    - pB, rB: compositions and subgroup rates for population B\n\n    Returns:\n        delta, comp_effect, rate_effect as floats.\n    \"\"\"\n    pA = np.asarray(pA, dtype=float)\n    rA = np.asarray(rA, dtype=float)\n    pB = np.asarray(pB, dtype=float)\n    rB = np.asarray(rB, dtype=float)\n\n    if not (pA.shape == rA.shape == pB.shape == rB.shape):\n        raise ValueError(\"All input vectors must have the same shape.\")\n\n    # Crude rates\n    RA = float(np.sum(pA * rA))\n    RB = float(np.sum(pB * rB))\n    delta = RA - RB\n\n    # Kitagawa components (symmetric, exact)\n    comp_effect = float(np.sum((pA - pB) * (rA + rB) / 2.0))\n    rate_effect = float(np.sum((rA - rB) * (pA + pB) / 2.0))\n\n    return delta, comp_effect, rate_effect\n\ndef format_float(x, places=6, zero_eps=5e-13):\n    \"\"\"Format a float to a fixed number of decimal places, avoiding negative zero.\"\"\"\n    if abs(x)  zero_eps:\n        x = 0.0\n    return f\"{x:.{places}f}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (pA, rA, pB, rB)\n    test_cases = [\n        # Case 1\n        ([0.2, 0.3, 0.5], [0.1, 0.15, 0.25],\n         [0.3, 0.3, 0.4], [0.05, 0.20, 0.35]),\n        # Case 2\n        ([0.4, 0.6], [0.1, 0.2],\n         [0.4, 0.6], [0.15, 0.25]),\n        # Case 3\n        ([0.2, 0.8], [0.1, 0.3],\n            [0.8, 0.2], [0.1, 0.3]),\n        # Case 4\n        ([0.5, 0.0, 0.5], [0.0, 0.2, 0.4],\n         [0.2, 0.3, 0.5], [0.0, 0.1, 0.5]),\n    ]\n\n    results_str_parts = []\n    for pA, rA, pB, rB in test_cases:\n        delta, comp, rate = kitagawa_decomposition(pA, rA, pB, rB)\n\n        # Round and format to six decimal places as required.\n        delta_s = format_float(delta, 6)\n        comp_s = format_float(comp, 6)\n        rate_s = format_float(rate, 6)\n\n        triple_str = f\"[{delta_s},{comp_s},{rate_s}]\"\n        results_str_parts.append(triple_str)\n\n    # Final print statement in the exact required format: no spaces.\n    print(f\"[{','.join(results_str_parts)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}