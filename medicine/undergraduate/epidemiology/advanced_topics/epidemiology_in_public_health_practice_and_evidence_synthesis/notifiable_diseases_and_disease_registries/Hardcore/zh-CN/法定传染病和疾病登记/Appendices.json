{
    "hands_on_practices": [
        {
            "introduction": "准确的病例分类是任何可靠的疾病登记系统的基石。本练习旨在通过从灵敏度（sensitivity）和特异性（specificity）等基本原则出发，推导阳性预测值（Positive Predictive Value, $PPV$）的计算公式，从而让你深入理解我们如何衡量一个病例定义的表现 。通过探究$PPV$如何随疾病患病率变化，你将揭示一个在解读监测数据时至关重要的原则，尤其是在疫情动态变化的环境中。",
            "id": "4614606",
            "problem": "一个省级法定传染病登记系统使用标准化的病例定义来评估疑似病例，当筛查测试呈阳性时会触发报告。在可能爆发疫情的某个日历周，应用于目标人群的病例定义中使用的测试，其灵敏度为 $Se$，特异性为 $Sp$。该周的真实患病率为 $\\pi$。阳性预测值（PPV）定义为在病例定义触发条件为阳性的情况下，个体确实患有该疾病的概率。仅从以下核心定义出发：\n- 灵敏度为 $Se = \\mathbb{P}(\\text{test} {+} \\mid \\text{disease})$，\n- 特异性为 $Sp = \\mathbb{P}(\\text{test} {-} \\mid \\text{no disease})$，\n- 患病率为 $\\pi = \\mathbb{P}(\\text{disease})$，\n以及全概率定律（并根据需要使用贝叶斯定理），推导阳性预测值 $PPV = \\mathbb{P}(\\text{disease} \\mid \\text{test} {+})$ 作为 $Se$、$Sp$ 和 $\\pi$ 函数的封闭式表达式。然后，根据您推导的表达式，在不使用数值的情况下，论证在非退化测试性能（即 $0  Se \\leq 1$ 和 $0 \\leq Sp  1$）下，当疫情期间 $\\pi$ 增加时，$PPV$ 是增加还是减少，并用文字简要证明您的结论。\n\n您的最终答案必须是 $PPV$ 关于 $Se$、$Sp$ 和 $\\pi$ 的单个封闭式解析表达式。最终答案框中请勿包含任何解释性文字、不等式或方程式。无需四舍五入，也无需报告单位。",
            "solution": "对问题陈述进行验证。\n\n### 第1步：提取已知条件\n- 灵敏度: $Se = \\mathbb{P}(\\text{test} {+} \\mid \\text{disease})$\n- 特异性: $Sp = \\mathbb{P}(\\text{test} {-} \\mid \\text{no disease})$\n- 患病率: $\\pi = \\mathbb{P}(\\text{disease})$\n- 目标量: 阳性预测值, $PPV = \\mathbb{P}(\\text{disease} \\mid \\text{test} {+})$\n- 任务1：推导 $PPV$ 作为 $Se$、$Sp$ 和 $\\pi$ 函数的封闭式表达式。\n- 任务2：确定当 $\\pi$ 增加时，$PPV$ 是增加还是减少。\n- 任务2的约束条件：非退化测试性能，$0  Se \\leq 1$ 和 $0 \\leq Sp  1$。\n\n### 第2步：使用提取的已知条件进行验证\n1.  **科学性：** 该问题基于概率论的基本原理及其在流行病学中评估诊断测试的标准应用。灵敏度、特异性、患病率和阳性预测值的定义是正确的，并且是该领域的核心。该问题在科学上是合理的。\n2.  **适定性：** 该问题是适定的。它提供了所有必要的定义和约束，以推导 $PPV$ 的唯一解析表达式，并分析其相对于 $\\pi$ 的单调行为。\n3.  **客观性：** 该问题以精确、客观和形式化的数学语言陈述。它不含任何主观或基于观点的论断。\n4.  **完整性与一致性：** 该问题是自洽的且内部一致。所提供的定义足以进行推导。约束条件 $0  Se \\leq 1$ 和 $0 \\leq Sp  1$ 是现实且不矛盾的。$Se > 0$ 意味着测试对于患病个体并非完全无用，$Sp  1$ 意味着测试可能产生假阳性，这是现实世界中筛查测试的普遍特征。\n5.  **无其他缺陷：** 该问题没有表现出任何其他缺陷，例如非形式化、不切实际、不适定或同义反复。\n\n### 第3步：结论与行动\n该问题有效。将提供一个完整的、有理有据的解答。\n\n主要目标是推导阳性预测值 ($PPV$) 的表达式，其定义为在测试结果为阳性的条件下患病的条件概率，$PPV = \\mathbb{P}(\\text{disease} \\mid \\text{test} {+})$。\n\n我们从应用贝叶斯定理开始，该定理指出对于事件 $A$ 和 $B$，$\\mathbb{P}(A \\mid B) = \\frac{\\mathbb{P}(B \\mid A) \\mathbb{P}(A)}{\\mathbb{P}(B)}$。\n设‘患病’事件为 $D$，‘测试阳性’事件为 $T{+}$。那么 $PPV$ 的定义为 $PPV = \\mathbb{P}(D \\mid T{+})$。\n应用贝叶斯定理：\n$$\nPPV = \\frac{\\mathbb{P}(T{+} \\mid D) \\mathbb{P}(D)}{\\mathbb{P}(T{+})}\n$$\n\n分子中的各项在问题陈述中已直接给出：\n- 给定患病情况下测试呈阳性的概率即为灵敏度，$\\mathbb{P}(T{+} \\mid D) = Se$。\n- 患病的先验概率即为患病率，$\\mathbb{P}(D) = \\pi$。\n\n分母中的项 $\\mathbb{P}(T{+})$ 是测试呈阳性的总概率。这可以使用全概率定律求得。人群被划分为两个不相交的组：患病者 ($D$) 和未患病者 (非 $D$，记作 $D^c$)。\n$$\n\\mathbb{P}(T{+}) = \\mathbb{P}(T{+} \\mid D) \\mathbb{P}(D) + \\mathbb{P}(T{+} \\mid D^c) \\mathbb{P}(D^c)\n$$\n我们可以将已知项代入此表达式中：\n- $\\mathbb{P}(T{+} \\mid D) = Se$\n- $\\mathbb{P}(D) = \\pi$\n- $\\mathbb{P}(D^c) = 1 - \\mathbb{P}(D) = 1 - \\pi$\n\n项 $\\mathbb{P}(T{+} \\mid D^c)$ 是在未患病情况下测试呈阳性的概率（假阳性率）。这与特异性相关，$Sp = \\mathbb{P}(T{-} \\mid D^c)$，其中 $T{-}$ 表示测试阴性。由于未患病个体测试结果或为阳性或为阴性，我们有 $\\mathbb{P}(T{+} \\mid D^c) + \\mathbb{P}(T{-} \\mid D^c) = 1$。\n因此，假阳性率为：\n$$\n\\mathbb{P}(T{+} \\mid D^c) = 1 - \\mathbb{P}(T{-} \\mid D^c) = 1 - Sp\n$$\n将所有这些部分代回 $\\mathbb{P}(T{+})$ 的表达式中：\n$$\n\\mathbb{P}(T{+}) = (Se)(\\pi) + (1 - Sp)(1 - \\pi)\n$$\n最后，将分子和分母的表达式代入 $PPV$ 的贝叶斯定理公式中，我们得到封闭式表达式：\n$$\nPPV = \\frac{Se \\cdot \\pi}{Se \\cdot \\pi + (1 - Sp)(1 - \\pi)}\n$$\n\n任务的第二部分是确定在给定约束条件 $0  Se \\leq 1$ 和 $0 \\leq Sp  1$ 的情况下，当 $\\pi$ 增加时，$PPV$ 是增加还是减少。我们通过考察 $PPV$ 相对于 $\\pi$ 的导数来分析这个问题。设 $f(\\pi) = PPV(\\pi)$。我们使用导数的商法则，$\\frac{d}{d\\pi}\\left(\\frac{u}{v}\\right) = \\frac{u'v - uv'}{v^2}$，其中：\n- $u(\\pi) = Se \\cdot \\pi$\n- $v(\\pi) = Se \\cdot \\pi + (1 - Sp)(1 - \\pi) = (Se - (1 - Sp))\\pi + (1 - Sp) = (Se + Sp - 1)\\pi + 1 - Sp$\n\n$u$ 和 $v$ 相对于 $\\pi$ 的导数是：\n- $u'(\\pi) = Se$\n- $v'(\\pi) = Se + Sp - 1$\n\n应用商法则：\n$$\n\\frac{d(PPV)}{d\\pi} = \\frac{(Se)[(Se + Sp - 1)\\pi + 1 - Sp] - (Se \\cdot \\pi)(Se + Sp - 1)}{[(Se + Sp - 1)\\pi + 1 - Sp]^2}\n$$\n展开分子：\n$$\n\\text{Numerator} = Se(Se + Sp - 1)\\pi + Se(1 - Sp) - Se(Se + Sp - 1)\\pi\n$$\n包含 $\\pi$ 的项相互抵消，分子简化为：\n$$\n\\text{Numerator} = Se(1 - Sp)\n$$\n所以导数变为：\n$$\n\\frac{d(PPV)}{d\\pi} = \\frac{Se(1 - Sp)}{[Se \\cdot \\pi + (1 - Sp)(1 - \\pi)]^2}\n$$\n现在我们在给定的约束条件下分析这个导数的符号。\n- 分母 $[Se \\cdot \\pi + (1 - Sp)(1 - \\pi)]^2$ 是 $\\mathbb{P}(T{+})$ 的平方。由于概率必须为非负数，其平方也为非负数。要使分母为零，$\\mathbb{P}(T{+})$ 必须为零。这种情况只在 $Se=0$ 且 $Sp=1$ 时发生，但这已被问题约束条件排除。因此，分母严格为正。\n- 分子是乘积 $Se(1 - Sp)$。约束条件规定 $0  Se \\leq 1$ 和 $0 \\leq Sp  1$。\n  - 由 $Se > 0$ 可知，第一个因子为正。\n  - 由 $Sp  1$ 可知，第二个因子 $(1 - Sp)$ 为正。\n- 两个正数的乘积为正，所以分子 $Se(1 - Sp)$ 严格为正。\n\n由于导数的分子和分母都严格为正，所以 $\\frac{d(PPV)}{d\\pi} > 0$。一阶导数为正表示函数 $PPV(\\pi)$ 是关于患病率 $\\pi$ 的单调递增函数。\n\n因此，当疫情期间患病率 $\\pi$ 增加时，阳性预测值 ($PPV$) 也随之增加。这是因为，随着疾病变得越来越普遍，任何一个阳性测试结果在统计上都更有可能是一个来自更大的患病群体的“真阳性”，而不太可能是一个来自日益缩小的未患病群体的“假阳性”。因此，真阳性在所有阳性测试中所占的比例会上升。",
            "answer": "$$\\boxed{\\frac{Se \\cdot \\pi}{Se \\cdot \\pi + (1 - Sp)(1 - \\pi)}}$$"
        },
        {
            "introduction": "在掌握了诊断测试性能评估的基础上，本练习将展示诊断方法和流程中的不完美之处如何为关键的流行病学指标引入偏倚 。你将扮演监测分析师的角色，在一个现实的场景中量化病例误分类对登记系统报告的发病率（incidence）的影响。这项实践计算将理论上的测试特性与其对公共卫生数据的实际影响联系起来，凸显了数据质量评估的重要性。",
            "id": "4614601",
            "problem": "一种国家法定报告的呼吸道传染病在疾病登记系统 (DR) 中进行追踪。监测系统使用临床病例定义来识别疑似病例，如果缺乏或实验室检测结果为阴性，则归类为“可能病例”；如果实验室检测结果为阳性，则归类为“确诊病例”。实验室检测是一种聚合酶链式反应 (PCR) 检测，其诊断性能不完善。该登记系统的年度发病率估计值仅使用确诊病例数除以总风险人时计算。\n\n在某一年，风险人群贡献了 $5{,}000{,}000$ 人年。有 $1{,}500$ 例真实新发感染病例，他们都符合临床病例定义，并被监测系统捕获为疑似病例。此外，临床评估产生了 $1{,}000$ 名没有感染的疑似个体（无病疑似者）。所有疑似个体中有一部分（比例为 $f = 0.80$）接受了实验室检测。PCR 检测的灵敏度 $Se = 0.92$，特异度 $Sp = 0.98$，其中灵敏度定义为真实感染者检测结果为阳性的概率，特异度定义为未感染者检测结果为阴性的概率。\n\n仅使用这些基本定义和“每人时病例数”的发病率概念，推导登记系统发病率估计值中偏差的解析表达式。该偏差源于不完善的灵敏度、特异度和不完全的检测导致的“可能病例”与“确诊病例”类别之间的错误分类。偏差定义为 $I_{\\text{obs}} - I_{\\text{true}}$，其中 $I_{\\text{obs}}$ 是基于确诊病例的观测发病率，$I_{\\text{true}}$ 是基于真实感染病例的真实发病率。然后，根据给定的参数对此偏差进行数值计算。请将您的最终数值答案以每 $100{,}000$ 人年的病例数表示，并四舍五入至三位有效数字。",
            "solution": "问题陈述具有科学依据，提法严谨，并包含了得出唯一解所需的所有信息。所提供的参数和定义在流行病学领域是标准的。因此，该问题是有效的，我们继续进行求解。\n\n目标是推导发病率估计值中偏差的表达式，然后计算其数值。偏差定义为观测发病率 ($I_{\\text{obs}}$) 与真实发病率 ($I_{\\text{true}}$) 之间的差值。\n\n首先，我们定义问题陈述中的变量：\n- 被捕获为疑似病例的真实新发感染病例数：$D^+ = 1{,}500$。\n- 被捕获为疑似病例的无病个体数：$D^- = 1{,}000$。\n- 总风险人时：$PT = 5{,}000{,}000$ 人年。\n- 接受实验室检测的疑似个体比例：$f = 0.80$。\n- PCR 检测的灵敏度：$Se = P(T^+|D^+) = 0.92$。\n- PCR 检测的特异度：$Sp = P(T^-|D^-) = 0.98$。\n\n真实发病率 $I_{\\text{true}}$ 是真实新发感染病例数除以总风险人时。\n$$I_{\\text{true}} = \\frac{D^+}{PT}$$\n\n观测发病率 $I_{\\text{obs}}$ 是基于“确诊”病例的数量。如果一个疑似个体的实验室检测结果为阳性 ($T^+$)，则该病例被确诊。确诊病例的总数，我们记作 $C_{\\text{conf}}$，是接受检测的个体中真阳性 (TP) 和假阳性 (FP) 的总和。\n\n疑似病例总数为 $D^+ + D^-$。\n接受检测的真实感染者人数为 $f \\times D^+$。\n接受检测的未感染者人数为 $f \\times D^-$。\n\n真阳性 (TP) 的数量是接受检测且结果为阳性的感染者人数。\n$$TP = (f \\cdot D^+) \\cdot Se$$\n\n假阳性 (FP) 的数量是接受检测且结果为阳性的未感染者人数。未感染者检测结果为阳性的概率是 $P(T^+|D^-) = 1 - P(T^-|D^-) = 1 - Sp$。\n$$FP = (f \\cdot D^-) \\cdot (1 - Sp)$$\n\n确诊病例总数是这两组的和。\n$$C_{\\text{conf}} = TP + FP = f \\cdot D^+ \\cdot Se + f \\cdot D^- \\cdot (1 - Sp)$$\n\n观测发病率 $I_{\\text{obs}}$ 是确诊病例数除以总风险人时。\n$$I_{\\text{obs}} = \\frac{C_{\\text{conf}}}{PT} = \\frac{f \\cdot D^+ \\cdot Se + f \\cdot D^- \\cdot (1 - Sp)}{PT}$$\n\n偏差定义为 $Bias = I_{\\text{obs}} - I_{\\text{true}}$。代入 $I_{\\text{obs}}$ 和 $I_{\\text{true}}$ 的表达式，我们得到偏差的解析表达式：\n$$Bias = \\frac{f \\cdot D^+ \\cdot Se + f \\cdot D^- \\cdot (1 - Sp)}{PT} - \\frac{D^+}{PT}$$\n这个表达式可以简化为：\n$$Bias = \\frac{1}{PT} \\left[ f \\cdot D^+ \\cdot Se + f \\cdot D^- \\cdot (1 - Sp) - D^+ \\right]$$\n这就是所要求的偏差的解析表达式。\n\n现在，我们使用给定的参数对该表达式进行数值计算。\n$D^+ = 1500$，$D^- = 1000$，$PT = 5{,}000{,}000$，$f = 0.80$，$Se = 0.92$，$Sp = 0.98$。\n\n首先，我们计算确诊病例总数 $C_{\\text{conf}}$：\n$$C_{\\text{conf}} = (0.80 \\times 1500 \\times 0.92) + (0.80 \\times 1000 \\times (1 - 0.98))$$\n$$C_{\\text{conf}} = (1200 \\times 0.92) + (800 \\times 0.02)$$\n$$C_{\\text{conf}} = 1104 + 16$$\n$$C_{\\text{conf}} = 1120$$\n\n登记系统计数的“确诊病例”为 $1120$ 例，而真实的新发病例数为 $1500$ 例。病例数的差异为 $1120 - 1500 = -380$。这表明病例存在净低估。\n\n发病率的偏差是这个病例数差异除以人时。\n$$Bias = \\frac{C_{\\text{conf}} - D^+}{PT} = \\frac{1120 - 1500}{5{,}000{,}000} = \\frac{-380}{5{,}000{,}000} \\text{ 病例/人年}$$\n$$Bias = -0.000076 \\text{ 病例/人年}$$\n\n问题要求答案以每 $100{,}000$ 人年的病例数表示。我们转换单位：\n$$Bias_{\\text{per } 100k} = \\frac{-380}{5{,}000{,}000} \\times 100{,}000$$\n$$Bias_{\\text{per } 100k} = -380 \\times \\frac{100{,}000}{5{,}000{,}000} = -380 \\times \\frac{1}{50}$$\n$$Bias_{\\text{per } 100k} = -7.6$$\n\n最后，我们将结果四舍五入到三位有效数字。\n$$Bias_{\\text{per } 100k} = -7.60$$\n负号表示登记系统的发病率估计值低于真实发病率，即存在低估。",
            "answer": "$$\\boxed{-7.60}$$"
        },
        {
            "introduction": "疾病监测的最终目的是采取行动。最后的这个练习将带你从数据质量转向实际应用，任务是构建一个简化的自动暴发探测系统 。通过使用时间序列建模技术，你将学习如何建立疾病计数的预期基线，并识别出具有统计学意义的异常。这个编程练习将让你亲身体验如何将原始的登记数据转化为可用于公共卫生干预的行动信号。",
            "id": "4614619",
            "problem": "一个卫生部门维护着一种法定传染病的每日登记册。令 $y_t$ 表示第 $t$ 天的观测计数，其中 $t \\in \\{1,2,\\dots,N\\}$。假设 $y_t \\mid \\mu_t \\sim \\mathrm{Poisson}(\\mu_t)$，采用标准对数连接，其系统性部分使用已知周期 $P$（天）和最多 $K$ 个谐波的谐波（正弦和余弦）项来模拟季节性模式，并可选择性地包含线性时间趋势。具体来说，对每一天 $t$，按行定义设计矩阵 $X \\in \\mathbb{R}^{N \\times p}$ 如下：\n- 一个等于 $1$ 的截距项。\n- 一个可选的线性时间趋势项，如果包含，则其值等于 $t$。\n- 对于每个谐波 $k \\in \\{1,\\dots,K\\}$，包含项 $\\sin\\!\\big(2\\pi k t / P\\big)$ 和 $\\cos\\!\\big(2\\pi k t / P\\big)$。\n\n令 $\\beta \\in \\mathbb{R}^p$ 为回归系数，$\\eta_t = x_t^\\top \\beta$ 为 $X$ 的行向量 $x_t$ 的线性预测变量。期望计数遵循 $\\mu_t = \\exp(\\eta_t)$。对于独立观测，似然函数为\n$$\nL(\\beta) = \\prod_{t=1}^{N} \\frac{\\mu_t^{y_t} e^{-\\mu_t}}{y_t!}, \\quad \\text{且} \\quad \\ell(\\beta) = \\sum_{t=1}^{N} \\left( y_t \\log \\mu_t - \\mu_t - \\log(y_t!) \\right),\n$$\n其中 $\\log \\mu_t = \\eta_t = x_t^\\top \\beta$。估计过程通过最大似然法进行，使用广义线性模型理论中的迭代重加权最小二乘算法。在获得最大似然估计 $\\hat{\\beta}$ 后，定义 $\\hat{\\mu}_t = \\exp(x_t^\\top \\hat{\\beta})$。令 $W = \\mathrm{diag}(\\hat{\\mu}_1,\\dots,\\hat{\\mu}_N)$ 表示收敛时的对角权重矩阵，并定义“帽子”矩阵\n$$\nH = W^{1/2} X \\left( X^\\top W X \\right)^{-1} X^\\top W^{1/2}.\n$$\n令 $h_t$ 表示 $H$ 的第 $t$ 个对角元素。第 $t$ 天的杠杆调整的标准化 Pearson 残差为\n$$\nr_t^\\ast = \\frac{y_t - \\hat{\\mu}_t}{\\sqrt{\\hat{\\mu}_t \\, (1 - h_t)}}.\n$$\n在广义线性模型的标准正则性条件和正确的模型设定下，对于较大的 $N$，$r_t^\\ast$ 近似服从标准正态分布。对于目标日 $t^\\ast$ 的前瞻性暴发信号检测，如果 $r_{t^\\ast}^\\ast > z$，单侧超限规则将宣告一个信号，其中 $z$ 是一个预设阈值（例如，$z = 2.5$ 对应于近似正态性下的上尾事件）。\n\n任务。编写一个完整的程序，对于每个测试用例，根据指定的 $P$、$K$ 和趋势包含标志构建设计矩阵 $X$；通过迭代重加权最小二乘法进行最大似然拟合泊松广义线性模型；计算指定目标日 $t^\\ast$ 的 $\\hat{\\mu}_t$、帽子对角线元素 $h_t$ 和杠杆调整的标准化 Pearson 残差 $r_t^\\ast$；并返回 $\\hat{\\mu}_{t^\\ast}$ 和 $r_{t^\\ast}^\\ast$，以及一个布尔型暴发信号指示器，如果 $r_{t^\\ast}^\\ast > z$ 则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。报告浮点数结果，四舍五入到 $6$ 位小数。\n\n使用以下确定性案例的测试套件，这些案例模拟具有周季节性的每日法定传染病计数：\n\n- 案例 A（带有明显尖峰的理想路径）：$N = 30$，$P = 7$，$K = 1$，包含线性趋势，目标日 $t^\\ast = 28$，阈值 $z = 2.5$，以及观测到的每日计数\n$$\n\\{7,9,10,11,12,11,9,7,9,10,11,12,11,9,7,9,10,11,12,11,9,7,9,10,11,12,11,30,7,9\\}.\n$$\n\n- 案例 B（没有尖峰的较长序列）：$N = 35$，$P = 7$，$K = 2$，不包含线性趋势，目标日 $t^\\ast = 35$，阈值 $z = 2.5$，以及观测到的每日计数\n$$\n\\{4,5,6,6,6,5,4,4,5,6,6,6,5,4,4,5,6,6,6,5,4,4,5,6,6,6,5,4,4,5,6,6,6,5,4\\}.\n$$\n\n- 案例 C（带有零作为边界条件的小计数）：$N = 14$，$P = 7$，$K = 1$，包含线性趋势，目标日 $t^\\ast = 14$，阈值 $z = 2.5$，以及观测到的每日计数\n$$\n\\{0,1,0,2,1,3,1,0,1,0,2,1,3,1\\}.\n$$\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，其本身是一个形式为 $[\\hat{\\mu}_{t^\\ast}, r_{t^\\ast}^\\ast, \\text{signal}]$ 的列表。浮点值必须四舍五入到 $6$ 位小数，布尔值必须不带引号。例如，一个包含三个测试用例的输出应如下所示\n$$\n[[\\hat{\\mu}_A, r_A^\\ast, \\mathrm{True/False}],[\\hat{\\mu}_B, r_B^\\ast, \\mathrm{True/False}],[\\hat{\\mu}_C, r_C^\\ast, \\mathrm{True/False}]].\n$$\n计数不需要单位；残差报告为无量纲值。三角函数内的角度通过 $2\\pi$ 因子构造，单位为弧度，不需要用户提供角度单位。所有计算必须是确定性的，并在程序内部自包含。",
            "solution": "该问题是有效的，因为它具有科学依据、问题明确且客观。它描述了使用既定统计方法的标准流行病学监测任务。我们接下来提供一个完整的解决方案。\n\n该解决方案实现了一种基于泊松广义线性模型 (GLM) 的前瞻性暴发检测算法。该方法包括四个主要阶段：模型设定、参数估计、残差计算和信号检测。\n\n1.  **模型设定与设计矩阵构建**\n假设第 $t$ 天的每日疾病观测计数 $y_t$（$t \\in \\{1, 2, \\dots, N\\}$）服从泊松分布，$y_t \\sim \\mathrm{Poisson}(\\mu_t)$。期望计数 $\\mu_t$ 通过对数线性模型与一组预测变量相关联：\n$$\n\\log(\\mu_t) = \\eta_t = x_t^\\top \\beta\n$$\n在这里，$\\eta_t$ 是线性预测变量，$x_t$ 是第 $t$ 天的预测变量行向量，$\\beta$ 是回归系数向量。设计矩阵 $X \\in \\mathbb{R}^{N \\times p}$ 是通过堆叠行向量 $x_t$ 构建的。每个 $x_t$ 由以下部分组成：\n- 一个截距项，其值恒为 $1$。\n- 一个可选的线性时间趋势，其值为 $t$。\n- $K$ 对谐波项，用于模拟周期为 $P$ 的季节性。对于每个谐波 $k \\in \\{1, \\dots, K\\}$，这些项是 $\\sin(2\\pi k t / P)$ 和 $\\cos(2\\pi k t / P)$。\n因此，系数向量 $\\beta$ 的维度 $p$ 为 $p = 1 + \\mathbb{I}(\\text{trend}) + 2K$，其中 $\\mathbb{I}(\\cdot)$ 是指示函数。\n\n2.  **通过迭代重加权最小二乘法 (IRLS) 进行参数估计**\n未知系数 $\\beta$ 通过最大化泊松对数似然函数来估计：\n$$\n\\ell(\\beta) = \\sum_{t=1}^{N} \\left( y_t \\eta_t - \\exp(\\eta_t) - \\log(y_t!) \\right)\n$$\n此最大化过程使用迭代重加权最小二乘 (IRLS) 算法完成。对于使用标准对数连接的泊松模型，IRLS 等价于 Newton-Raphson 方法。从 $\\beta$ 的一个初始猜测（例如 $\\beta^{(0)} = \\mathbf{0}$）开始，系数被迭代更新：\n$$\n\\beta^{(i+1)} = \\beta^{(i)} + \\left( X^\\top W^{(i)} X \\right)^{-1} X^\\top (y - \\mu^{(i)})\n$$\n其中：\n- $\\mu^{(i)} = \\exp(X\\beta^{(i)})$ 是第 $i$ 次迭代时的估计平均计数。\n- $W^{(i)} = \\mathrm{diag}(\\mu_1^{(i)}, \\dots, \\mu_N^{(i)})$ 是一个对角权重矩阵。\n项 $(X^\\top W^{(i)} X)$ 是 Fisher 信息矩阵。迭代持续进行，直到 $\\beta$ 的变化量低于预定义的容差，从而得出最大似然估计 $\\hat{\\beta}$。\n\n3.  **杠杆值与残差计算**\n在 $\\hat{\\beta}$ 处收敛后，最终的拟合值为 $\\hat{\\mu} = \\exp(X\\hat{\\beta})$，最终的权重矩阵为 $W = \\mathrm{diag}(\\hat{\\mu})$。每个观测值对其自身拟合值的影响由其杠杆值量化，即帽子矩阵 $H$ 对应的对角元素 $h_t$：\n$$\nH = W^{1/2} X \\left( X^\\top W X \\right)^{-1} X^\\top W^{1/2}\n$$\n一种计算上更高效的、无需构造完整 $N \\times N$ 矩阵 $H$ 即可找到对角元素的方法是：\n$$\nh_t = H_{tt} = \\hat{\\mu}_t x_t \\left( X^\\top W X \\right)^{-1} x_t^\\top\n$$\n利用这些量，我们计算每个观测值的杠杆调整的标准化 Pearson 残差。Pearson 残差 $r_t^P = (y_t - \\hat{\\mu}_t) / \\sqrt{\\hat{\\mu}_t}$，通过其近似标准差 $\\sqrt{1 - h_t}$ 进行标准化，得到：\n$$\nr_t^\\ast = \\frac{y_t - \\hat{\\mu}_t}{\\sqrt{\\hat{\\mu}_t (1 - h_t)}}\n$$\n在正确的模型设定下，对于较大的 $N$，这些残差近似服从标准正态变量分布。\n\n4.  **暴发检测**\n对于特定的目标日 $t^\\ast$，监测算法计算残差 $r_{t^\\ast}^\\ast$。如果该值超过一个预设的临界阈值 $z$，则宣告发生暴发信号，该阈值对应于标准正态分布的上尾分位数。警报的条件是：\n$$\nr_{t^\\ast}^\\ast > z\n$$\n程序为每个测试用例实现这些步骤，报告估计的均值 $\\hat{\\mu}_{t^\\ast}$、残差 $r_{t^\\ast}^\\ast$ 和布尔信号指示器。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required for this solution.\n\ndef fit_poisson_glm(y, X, max_iter=50, tol=1e-8):\n    \"\"\"\n    Fits a Poisson GLM using Iteratively Reweighted Least Squares (IRLS).\n\n    Args:\n        y (np.ndarray): The observed counts (response variable).\n        X (np.ndarray): The design matrix.\n        max_iter (int): Maximum number of iterations for the IRLS algorithm.\n        tol (float): Tolerance for convergence based on the change in coefficients.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The estimated regression coefficients (beta_hat).\n            - np.ndarray: The fitted mean values (mu_hat).\n    \"\"\"\n    n_params = X.shape[1]\n    beta = np.zeros(n_params)\n\n    for _ in range(max_iter):\n        eta = X @ beta\n        mu = np.exp(eta)\n        \n        W = np.diag(mu)\n        \n        # Newton-Raphson update step: beta_new = beta + (X'WX)^-1 * X'(y-mu)\n        score = X.T @ (y - mu)\n        fisher_info = X.T @ W @ X\n        \n        try:\n            # np.linalg.solve is numerically more stable than inverting the matrix\n            delta = np.linalg.solve(fisher_info, score)\n        except np.linalg.LinAlgError:\n            # Fallback to pseudo-inverse if matrix is singular or ill-conditioned\n            delta = np.linalg.pinv(fisher_info) @ score\n            \n        beta_new = beta + delta\n        \n        # Check for convergence\n        if np.sum((beta_new - beta)**2)  tol:\n            beta = beta_new\n            break\n        \n        beta = beta_new\n    \n    # After convergence, calculate final mean from the final beta\n    final_eta = X @ beta\n    final_mu = np.exp(final_eta)\n    \n    return beta, final_mu\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"y\": [7,9,10,11,12,11,9,7,9,10,11,12,11,9,7,9,10,11,12,11,9,7,9,10,11,12,11,30,7,9],\n            \"P\": 7, \"K\": 1, \"include_trend\": True, \"t_star\": 28, \"z\": 2.5\n        },\n        {\n            \"y\": [4,5,6,6,6,5,4,4,5,6,6,6,5,4,4,5,6,6,6,5,4,4,5,6,6,6,5,4,4,5,6,6,6,5,4],\n            \"P\": 7, \"K\": 2, \"include_trend\": False, \"t_star\": 35, \"z\": 2.5\n        },\n        {\n            \"y\": [0,1,0,2,1,3,1,0,1,0,2,1,3,1],\n            \"P\": 7, \"K\": 1, \"include_trend\": True, \"t_star\": 14, \"z\": 2.5\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        y_obs = case[\"y\"]\n        P, K, include_trend, t_star, z = case[\"P\"], case[\"K\"], case[\"include_trend\"], case[\"t_star\"], case[\"z\"]\n\n        y = np.array(y_obs, dtype=np.float64)\n        N = len(y)\n        t = np.arange(1, N + 1)\n\n        # 1. Construct the design matrix X\n        columns = [np.ones(N)] # Intercept\n        if include_trend:\n            columns.append(t)\n        for k in range(1, K + 1):\n            angle = 2 * np.pi * k * t / P\n            columns.append(np.sin(angle))\n            columns.append(np.cos(angle))\n        X = np.column_stack(columns)\n\n        # 2. Fit the Poisson GLM\n        beta_hat, mu_hat = fit_poisson_glm(y, X)\n        W_hat = np.diag(mu_hat)\n        \n        # 3. Compute hat matrix diagonals (leverages)\n        fisher_info_final = X.T @ W_hat @ X\n        try:\n            info_inv = np.linalg.inv(fisher_info_final)\n        except np.linalg.LinAlgError:\n            info_inv = np.linalg.pinv(fisher_info_final)\n        \n        # Vectorized calculation of h_t = mu_t * x_t * (X'WX)^-1 * x_t'\n        leverage_component = np.sum((X @ info_inv) * X, axis=1)\n        h_diagonals = mu_hat * leverage_component\n\n        # 4. Calculate residual and signal for the target day t_star\n        idx_star = t_star - 1\n        \n        y_t_star = y[idx_star]\n        mu_t_star_hat = mu_hat[idx_star]\n        h_t_star = h_diagonals[idx_star]\n        \n        # Avoid division by zero or sqrt of negative if h_t_star >= 1\n        denominator_val = mu_t_star_hat * (1 - h_t_star)\n        if denominator_val > 0:\n            denominator = np.sqrt(denominator_val)\n            r_t_star_adj = (y_t_star - mu_t_star_hat) / denominator\n        elif y_t_star == mu_t_star_hat : # Denominator is 0, but so is numerator\n            r_t_star_adj = 0.0\n        else: # Denominator is 0, numerator is not. Residual is infinite.\n            r_t_star_adj = np.inf if (y_t_star > mu_t_star_hat) else -np.inf\n\n        signal = r_t_star_adj > z\n        \n        all_results.append([\n            round(mu_t_star_hat, 6),\n            round(r_t_star_adj, 6),\n            bool(signal)\n        ])\n\n    # Final print statement in the exact required format.\n    output_parts = []\n    for res in all_results:\n        # Format as \"[val1,val2,BoolVal]\" without spaces\n        formatted_part = f\"[{res[0]},{res[1]},{str(res[2])}]\"\n        output_parts.append(formatted_part)\n    \n    final_string = f\"[{','.join(output_parts)}]\"\n    print(final_string)\n\nsolve()\n```"
        }
    ]
}