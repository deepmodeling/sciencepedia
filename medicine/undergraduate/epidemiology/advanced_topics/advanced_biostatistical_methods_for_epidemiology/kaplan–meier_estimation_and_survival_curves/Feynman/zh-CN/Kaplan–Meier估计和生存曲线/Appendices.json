{
    "hands_on_practices": [
        {
            "introduction": "理论知识只有通过实践才能真正掌握。本练习将带你从一个小型队列研究的原始数据出发，一步步手动计算Kaplan-Meier生存估计值及其标准误。通过这个过程，你将加深对生存函数乘积极限公式和Greenwood公式的理解，并学会处理事件时间平局这一常见情况 。",
            "id": "4605693",
            "problem": "一项流行病学中的队列研究跟踪了 $8$ 名个体，从基线开始，直至发生失败事件（例如，疾病发作）或被删失。时间以月为单位记录。对于每个个体 $j$，$t_j$ 表示观察到的随访时间，$\\delta_j$ 是一个指示变量，其中如果$t_j$时刻发生失败事件，则 $\\delta_j = 1$，如果观察在 $t_j$ 时刻被删失，则 $\\delta_j = 0$。观察到的数据如下：\n- 个体 $1$：$t_1 = 2$，$\\delta_1 = 1$。\n- 个体 $2$：$t_2 = 4$，$\\delta_2 = 1$。\n- 个体 $3$：$t_3 = 4$，$\\delta_3 = 1$。\n- 个体 $4$：$t_4 = 5$，$\\delta_4 = 0$。\n- 个体 $5$：$t_5 = 6$，$\\delta_5 = 1$。\n- 个体 $6$：$t_6 = 7$，$\\delta_6 = 1$。\n- 个体 $7$：$t_7 = 7$，$\\delta_7 = 0$。\n- 个体 $8$：$t_8 = 9$，$\\delta_8 = 0$。\n\n假设遵循以下科学标准约定：\n- 生存时间 $T$ 是一个非负随机变量，生存函数 $S(t)$ 定义为 $S(t) = \\mathbb{P}(T > t)$。\n- 使用 Kaplan-Meier 乘积极限估计量从右删失数据中非参数地估计生存函数。\n- 当失败和删失发生在同一观察时间 $t$ 时，在构建风险集和更新生存估计时，先处理时间 $t$ 的所有失败，再处理时间 $t$ 的删失（事件优先约定）。\n\n仅使用生存分析中的标准定义，对不同的失败时间点 $t = 2$，$t = 4$，$t = 6$ 和 $t = 7$ 执行以下任务：\n1. 计算每个不同失败时间点 $t_i$ 之前的风险人数 $n_i$ 和在 $t_i$ 时的失败数 $d_i$。\n2. 计算每个不同失败时间点之后的 Kaplan-Meier 估计值 $\\hat{S}(t)$。\n3. 计算每个不同失败时间点处 $\\hat{S}(t)$ 的 Greenwood 标准误 (SE)。\n\n最后，将 $t=7$ 时 Kaplan-Meier 估计量的 Greenwood 标准误报告为一个数值。将您的答案四舍五入到四位有效数字。最终答案中不要包含单位。",
            "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n提供了 $8$ 名个体的数据，包括随访时间 $t_j$（以月为单位）和事件指示变量 $\\delta_j$。\n-   个体 $1$：$t_1 = 2$，$\\delta_1 = 1$\n-   个体 $2$：$t_2 = 4$，$\\delta_2 = 1$\n-   个体 $3$：$t_3 = 4$，$\\delta_3 = 1$\n-   个体 $4$：$t_4 = 5$，$\\delta_4 = 0$\n-   个体 $5$：$t_5 = 6$，$\\delta_5 = 1$\n-   个体 $6$：$t_6 = 7$，$\\delta_6 = 1$\n-   个体 $7$：$t_7 = 7$，$\\delta_7 = 0$\n-   个体 $8$：$t_8 = 9$，$\\delta_8 = 0$\n$\\delta_j = 1$ 表示失败事件，$\\delta_j = 0$ 表示删失。\n生存函数定义为 $S(t) = \\mathbb{P}(T > t)$。\n分析要求使用 Kaplan-Meier 乘积极限估计量。\n陈述了处理失败和删失时间并列情况的特定约定：在同一时间点，先处理事件，再处理删失（事件优先约定）。\n任务是计算不同失败时间点 $t = 2, 4, 6, 7$ 的风险人数 ($n_i$)、失败数 ($d_i$)、Kaplan-Meier 估计值 ($\\hat{S}(t)$) 和 Greenwood 标准误 (SE)，并报告 $t=7$ 时的最终 SE，四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题是生存分析的标准应用，生存分析是流行病学和生物统计学中的核心方法。Kaplan-Meier 估计量及其方差的 Greenwood 公式是分析右删失事件时间数据的基本且普遍接受的工具。该问题在科学上是合理的。\n-   **适定性**：数据、定义和明确的“事件优先”约定为计算提供了一个完整且明确的框架。存在一个唯一的、稳定的、有意义的解。\n-   **客观性**：问题陈述使用了生存分析中精确、标准的术语，没有主观或含糊的语言。\n-   该问题不违反任何其他有效性标准。它是完整的、一致的、现实的，并且与指定主题直接相关。\n\n### 步骤 3：结论与行动\n问题有效。将提供一个完整的、有理有据的解答。\n\nKaplan-Meier 估计量 $\\hat{S}(t)$ 是一种非参数统计量，用于从事件时间数据中估计生存函数。它是在每个不同失败时间点计算的条件生存概率的乘积。公式为：\n$$\n\\hat{S}(t) = \\prod_{i: t_i \\le t} \\left( 1 - \\frac{d_i}{n_i} \\right)\n$$\n其中 $t_i$ 是不同的失败时间点，$d_i$ 是时间 $t_i$ 时的失败数，$n_i$ 是恰好在时间 $t_i$ 之前处于风险中（存活且未删失）的个体数量。按照惯例，$\\hat{S}(0) = 1$。\n\nGreenwood 公式用于估计 Kaplan-Meier 估计量的方差。$\\hat{S}(t)$ 的方差由下式给出：\n$$\n\\text{Var}(\\hat{S}(t)) = [\\hat{S}(t)]^2 \\sum_{i: t_i \\le t} \\frac{d_i}{n_i(n_i - d_i)}\n$$\n标准误 (SE) 是方差的平方根：\n$$\n\\text{SE}(\\hat{S}(t)) = \\sqrt{\\text{Var}(\\hat{S}(t))} = |\\hat{S}(t)| \\sqrt{\\sum_{i: t_i \\le t} \\frac{d_i}{n_i(n_i - d_i)}}\n$$\n\n首先，我们按时间对所有观察值进行排序，并确定不同的失败时间点。\n观察时间点为 $t = 2, 4, 4, 5, 6, 7, 7, 9$。\n不同的失败时间点为 $t_{(1)} = 2$，$t_{(2)} = 4$，$t_{(3)} = 6$ 和 $t_{(4)} = 7$。\n\n我们构建一个生存表来逐步进行计算。\n研究开始时的总个体数为 $N=8$。\n\n**1. 时间 $t_{(1)} = 2$**\n-   恰好在 $t=2$ 之前的风险人数是研究中的所有人。因此，$n_1 = 8$。\n-   在 $t=2$ 时，一个个体发生失败事件。因此，$d_1 = 1$。\n-   恰好在 $t=2$ 之后的生存率的 Kaplan-Meier 估计值为：\n    $$\n    \\hat{S}(2) = \\hat{S}(0) \\times \\left(1 - \\frac{d_1}{n_1}\\right) = 1 \\times \\left(1 - \\frac{1}{8}\\right) = \\frac{7}{8}\n    $$\n-   为了计算 SE，我们首先找到这个时间点的方差项：\n    $$\n    \\frac{d_1}{n_1(n_1 - d_1)} = \\frac{1}{8(8 - 1)} = \\frac{1}{56}\n    $$\n-   $\\hat{S}(2)$ 的方差为：\n    $$\n    \\text{Var}(\\hat{S}(2)) = [\\hat{S}(2)]^2 \\left(\\frac{d_1}{n_1(n_1 - d_1)}\\right) = \\left(\\frac{7}{8}\\right)^2 \\times \\frac{1}{56} = \\frac{49}{64} \\times \\frac{1}{56} = \\frac{7}{64 \\times 8} = \\frac{7}{512}\n    $$\n-   $\\hat{S}(2)$ 的 Greenwood SE 为：\n    $$\n    \\text{SE}(\\hat{S}(2)) = \\sqrt{\\frac{7}{512}}\n    $$\n-   此时间点之后，风险集中还剩下 $n_1 - d_1 = 7$ 名个体。\n\n**2. 时间 $t_{(2)} = 4$**\n-   恰好在 $t=4$ 之前的风险人数为 $n_2 = 7$。\n-   在 $t=4$ 时，两个个体发生失败事件。因此，$d_2 = 2$。\n-   恰好在 $t=4$ 之后的生存率的 Kaplan-Meier 估计值为：\n    $$\n    \\hat{S}(4) = \\hat{S}(2) \\times \\left(1 - \\frac{d_2}{n_2}\\right) = \\frac{7}{8} \\times \\left(1 - \\frac{2}{7}\\right) = \\frac{7}{8} \\times \\frac{5}{7} = \\frac{5}{8}\n    $$\n-   这个时间点的方差项为：\n    $$\n    \\frac{d_2}{n_2(n_2 - d_2)} = \\frac{2}{7(7 - 2)} = \\frac{2}{35}\n    $$\n-   方差计算的累加和为：\n    $$\n    \\sum_{i=1}^{2} \\frac{d_i}{n_i(n_i - d_i)} = \\frac{1}{56} + \\frac{2}{35} = \\frac{5 + 16}{280} = \\frac{21}{280} = \\frac{3}{40}\n    $$\n-   $\\hat{S}(4)$ 的方差为：\n    $$\n    \\text{Var}(\\hat{S}(4)) = [\\hat{S}(4)]^2 \\sum_{i=1}^{2} \\frac{d_i}{n_i(n_i - d_i)} = \\left(\\frac{5}{8}\\right)^2 \\times \\frac{3}{40} = \\frac{25}{64} \\times \\frac{3}{40} = \\frac{5}{64} \\times \\frac{3}{8} = \\frac{15}{512}\n    $$\n-   $\\hat{S}(4)$ 的 Greenwood SE 为：\n    $$\n    \\text{SE}(\\hat{S}(4)) = \\sqrt{\\frac{15}{512}}\n    $$\n-   此时间点之后，还剩下 $n_2 - d_2 = 5$ 名个体。在 $t=5$ 时，一名个体被删失，风险集中剩下 $4$ 人。\n\n**3. 时间 $t_{(3)} = 6$**\n-   恰好在 $t=6$ 之前的风险人数为 $n_3 = 4$。\n-   在 $t=6$ 时，一个个体发生失败事件。因此，$d_3 = 1$。\n-   恰好在 $t=6$ 之后的生存率的 Kaplan-Meier 估计值为：\n    $$\n    \\hat{S}(6) = \\hat{S}(4) \\times \\left(1 - \\frac{d_3}{n_3}\\right) = \\frac{5}{8} \\times \\left(1 - \\frac{1}{4}\\right) = \\frac{5}{8} \\times \\frac{3}{4} = \\frac{15}{32}\n    $$\n-   这个时间点的方差项为：\n    $$\n    \\frac{d_3}{n_3(n_3 - d_3)} = \\frac{1}{4(4 - 1)} = \\frac{1}{12}\n    $$\n-   方差计算的累加和为：\n    $$\n    \\sum_{i=1}^{3} \\frac{d_i}{n_i(n_i - d_i)} = \\frac{3}{40} + \\frac{1}{12} = \\frac{9 + 10}{120} = \\frac{19}{120}\n    $$\n-   $\\hat{S}(6)$ 的方差为：\n    $$\n    \\text{Var}(\\hat{S}(6)) = [\\hat{S}(6)]^2 \\sum_{i=1}^{3} \\frac{d_i}{n_i(n_i - d_i)} = \\left(\\frac{15}{32}\\right)^2 \\times \\frac{19}{120} = \\frac{225}{1024} \\times \\frac{19}{120} = \\frac{15 \\times 19}{1024 \\times 8} = \\frac{285}{8192}\n    $$\n-   $\\hat{S}(6)$ 的 Greenwood SE 为：\n    $$\n    \\text{SE}(\\hat{S}(6)) = \\sqrt{\\frac{285}{8192}}\n    $$\n-   此时间点之后，风险集中还剩下 $n_3 - d_3 = 3$ 名个体。\n\n**4. 时间 $t_{(4)} = 7$**\n-   恰好在 $t=7$ 之前的风险人数为 $n_4 = 3$。\n-   在 $t=7$ 时，有一次失败和一次删失。根据事件优先约定，我们使用 $n_4=3$ 的风险集处理失败。所以，$d_4 = 1$。\n-   恰好在 $t=7$ 之后的生存率的 Kaplan-Meier 估计值为：\n    $$\n    \\hat{S}(7) = \\hat{S}(6) \\times \\left(1 - \\frac{d_4}{n_4}\\right) = \\frac{15}{32} \\times \\left(1 - \\frac{1}{3}\\right) = \\frac{15}{32} \\times \\frac{2}{3} = \\frac{30}{96} = \\frac{5}{16}\n    $$\n-   这个时间点的方差项为：\n    $$\n    \\frac{d_4}{n_4(n_4 - d_4)} = \\frac{1}{3(3 - 1)} = \\frac{1}{6}\n    $$\n-   方差计算的累加和为：\n    $$\n    \\sum_{i=1}^{4} \\frac{d_i}{n_i(n_i - d_i)} = \\frac{19}{120} + \\frac{1}{6} = \\frac{19 + 20}{120} = \\frac{39}{120} = \\frac{13}{40}\n    $$\n-   $\\hat{S}(7)$ 的方差为：\n    $$\n    \\text{Var}(\\hat{S}(7)) = [\\hat{S}(7)]^2 \\sum_{i=1}^{4} \\frac{d_i}{n_i(n_i - d_i)} = \\left(\\frac{5}{16}\\right)^2 \\times \\frac{13}{40} = \\frac{25}{256} \\times \\frac{13}{40} = \\frac{5}{256} \\times \\frac{13}{8} = \\frac{65}{2048}\n    $$\n-   $\\hat{S}(7)$ 的 Greenwood SE 为：\n    $$\n    \\text{SE}(\\hat{S}(7)) = \\sqrt{\\frac{65}{2048}}\n    $$\n\n最后，我们计算 $t=7$ 时 SE 的数值，并四舍五入到四位有效数字。\n$$\n\\text{SE}(\\hat{S}(7)) = \\sqrt{\\frac{65}{2048}} \\approx \\sqrt{0.03173828...} \\approx 0.1781524...\n$$\n四舍五入到四位有效数字，我们得到 $0.1782$。",
            "answer": "$$\\boxed{0.1782}$$"
        },
        {
            "introduction": "在掌握了手动计算之后，下一步是学习如何将这一过程自动化，以处理更大数据集和更复杂的情况，例如延迟入组（左截断）。本练习要求你设计并实现一个算法，从包含入组时间、退出时间和事件状态的个体记录中，准确地构建风险集并计算Kaplan-Meier估计所需的关键量。这不仅能巩固你对风险集动态变化的理解，也是将理论应用于实际数据分析的关键一步 。",
            "id": "4605689",
            "problem": "您的任务是设计并实现一个基于生存分析原理的算法，该算法用于构建风险集函数并计算 Kaplan-Meier 估计量所需的量。每个个体由进入时间、退出时间和事件指示符组成的三元组表示。时间以天为单位，所有输出必须酌情以天或无单位计数表示。您编写的程序必须实现以下定义和约定，并为指定的测试套件生成输出。\n\n定义和约定：\n- 设有 $N$ 个个体，索引为 $j \\in \\{1,2,\\dots,N\\}$。每个个体的记录包含 $(e_j, x_j, \\delta_j)$，其中 $e_j$ 是进入时间（左截断），$x_j$ 是退出时间，$\\delta_j \\in \\{0,1\\}$ 是事件指示符，$\\delta_j = 1$ 表示在时间 $x_j$ 发生事件，$\\delta_j = 0$ 表示在时间 $x_j$ 发生删失。\n- 在时间 $t$ 的风险集，记为 $R(t)$，是满足 $e_j \\le t \\le x_j$ 的索引 $j$ 的集合。此约定确保了在时间 $t$ 发生事件或被删失的个体，在被移除之前，被计为在时间 $t$ 处于风险中。\n- 不同事件时间是 $\\{x_j : \\delta_j = 1\\}$ 的排序后唯一值。将这些时间记为 $\\{t_i\\}_{i=1}^m$，其中 $m$ 是不同事件时间的数量。\n- 对于每个事件时间 $t_i$，将风险集大小定义为 $n_i = |R(t_i)|$，将在该时间的事件数定义为 $d_i = \\sum_{j=1}^N \\mathbf{1}\\{x_j = t_i, \\delta_j = 1\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n- 所有时间都必须以天为单位处理。输出 $t_i$ 的单位是天（在此测试套件中为整数），而 $n_i$ 和 $d_i$ 是无单位的计数（整数）。\n\n您的程序必须：\n- 对于每个测试用例，根据上述定义计算事件时间列表 $\\{t_i\\}$、相应的风险集大小列表 $\\{n_i\\}$ 和事件计数列表 $\\{d_i\\}$。\n- 使用包含规则 $e_j \\le t_i \\le x_j$ 来确定 $R(t_i)$ 的成员。\n- 将事件视为在时间 $t_i$ 发生，将在时间 $t_i$ 删失的观测值视为在时间 $t_i$ 仍处于风险集中，但不计入 $d_i$。\n\n测试套件：\n为以下五个测试用例提供输出。在每个用例中，输入是一个记录列表 $(e_j, x_j, \\delta_j)$，所有时间都以天为单位。\n\n- 测试用例 1（包含交错进入、同时事件和删失的常规路径）：\n  - 记录：$[(0,5,1), (0,7,0), (2,5,1), (4,6,1), (3,10,0), (5,8,1)]$。\n  - 预期的不同事件时间：$[5,6,8]$（单位：天）。\n\n- 测试用例 2（无事件；全部删失）：\n  - 记录：$[(0,4,0), (1,3,0), (2,2,0)]$。\n  - 预期的不同事件时间：$[]$。\n\n- 测试用例 3（左截断，在事件时间存在并列情况，包括恰好在事件时间进入）：\n  - 记录：$[(0,4,1), (4,4,0), (2,6,1), (5,6,0), (6,6,1)]$。\n  - 预期的不同事件时间：$[4,6]$（单位：天）。\n\n- 测试用例 4（边界情况，事件发生在时间 0）：\n  - 记录：$[(0,0,1), (0,1,0), (0,2,1)]$。\n  - 预期的不同事件时间：$[0,2]$（单位：天）。\n\n- 测试用例 5（同时事件，伴有恰好在事件时间延迟进入和早期删失）：\n  - 记录：$[(1,3,1), (2,3,1), (3,3,0), (0,1,0)]$。\n  - 预期的不同事件时间：$[3]$（单位：天）。\n\n最终输出格式规范：\n- 对于每个测试用例，您的程序必须生成一个包含三个列表的列表：事件时间列表 $[t_1,\\dots,t_m]$、相应的列表 $[n_1,\\dots,n_m]$ 和相应的列表 $[d_1,\\dots,d_m]$。\n- 将所有测试用例的结果汇总为单行打印输出，其中包含一个由这些按用例排列的列表组成的逗号分隔列表，并用方括号括起来。例如，通用格式为 $[[[t_{1}^{(1)},\\dots],[n_{1}^{(1)},\\dots],[d_{1}^{(1)},\\dots]],[[t_{1}^{(2)},\\dots],[n_{1}^{(2)},\\dots],[d_{1}^{(2)},\\dots]],\\dots]$。\n- 由于此输出用于自动检查，请确保它只有一行，不含任何额外文本。\n\n您的任务是实现此算法并用 Python 生成指定的输出。不需要用户输入；测试用例必须硬编码在程序中。时间和计数的答案必须是整数。程序必须是一个完整的、可运行的实现，遵循上述约定，并为测试套件准确地生成指定格式的输出。",
            "solution": "该问题是有效的。它在计算生物统计学领域提出了一个清晰、明确定义的任务，特别是在存在左截断（交错进入）和右删失生存数据的情况下，计算 Kaplan-Meier 估计量所需的量。所提供的关于风险集、事件时间、风险人数和事件数的定义是生存分析中的标准定义，并且在科学上是合理的、内部一致的。\n\n目标是开发一个算法来处理一系列个体记录，每个记录由一个三元组 $(e_j, x_j, \\delta_j)$ 表示，其中 $e_j$ 是进入时间，$x_j$ 是退出时间，$\\delta_j$ 是事件指示符。对于给定的数据，我们必须计算不同事件时间的集合 $\\{t_i\\}_{i=1}^m$，以及对于每个事件时间 $t_i$，计算相应的风险个体数 $n_i$ 和事件数 $d_i$。这些量是构建 Kaplan-Meier 生存曲线的基础。\n\n该算法主要分两个阶段进行：\n1.  识别不同事件时间。\n2.  对每个事件时间，计算相关的事件数和风险集的大小。\n\n设个体总数为 $N$，索引为 $j \\in \\{1, 2, \\dots, N\\}$。\n\n**1. 识别不同事件时间 $\\{t_i\\}$**\n\n第一步是确定感兴趣的事件发生的具体时间点。事件由 $\\delta_j = 1$ 指示。个体 $j$ 的事件时间是其退出时间 $x_j$。我们从数据集中收集所有此类时间：$\\{x_j \\mid \\delta_j = 1\\}$。由于多个事件可能在同一时间发生，此集合可能包含重复值。为获得不同事件时间的集合，我们从此集合中提取唯一值并按时间升序排序。将这些排序后的唯一事件时间记为 $t_1, t_2, \\dots, t_m$，其中 $m$ 是不同事件时间的总数。如果数据集中没有事件发生（即，对所有 $j$ 都有 $\\delta_j = 0$），则此集合为空，因此 $m=0$。\n\n**2. 计算事件计数 $\\{d_i\\}$ 和风险集大小 $\\{n_i\\}$**\n\n对于第一步中识别出的每个不同事件时间 $t_i$，我们必须计算两个量：$d_i$ 和 $n_i$。\n\n-   **事件数 ($d_i$)**：数量 $d_i$ 是在时间 $t_i$ 精确发生事件的个体总数。通过遍历所有 $N$ 个个体，并计算满足两个条件的个体数量来计算：他们的退出时间 $x_j$ 等于 $t_i$ 并且他们的事件指示符 $\\delta_j$ 为 1。\n    $$d_i = \\sum_{j=1}^N \\mathbf{1}\\{x_j = t_i \\text{ and } \\delta_j = 1\\}$$\n    其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，如果条件为真则为 $1$，否则为 $0$。\n\n-   **风险集大小 ($n_i$)**：数量 $n_i$ 代表在时间 $t_i$ 处于事件风险中的个体数量。问题将时间 $t$ 的风险集 $R(t)$ 定义为 $e_j \\le t \\le x_j$ 的个体 $j$ 的集合。此定义正确地包括了在时间 $t$ 或之前进入研究并且在时间 $t$ 仍处于观察中的个体。在时间 $t$ 退出（由于事件或删失）的个体被认为在其退出前瞬间处于风险中，因此被包含在风险集 $R(t)$ 中。因此，在事件时间 $t_i$ 的风险集大小，记为 $n_i$，是 $R(t_i)$ 的基数：\n    $$n_i = |R(t_i)| = \\sum_{j=1}^N \\mathbf{1}\\{e_j \\le t_i \\le x_j\\}$$\n\n通过遍历不同事件时间的排序列表中的每个 $t_i$ 并执行这两项计算，我们可以构建所需的列表 $\\{t_i\\}$、$\\{n_i\\}$ 和 $\\{d_i\\}$。\n\n**示例演练：测试用例 1**\n\n让我们将此算法应用于第一个测试用例。\n记录为 $[(0,5,1), (0,7,0), (2,5,1), (4,6,1), (3,10,0), (5,8,1)]$。\n\n**步骤 1：找到事件时间 $\\{t_i\\}$**\n-   发生事件的个体 ($\\delta_j=1$) 为 $(0,5,1)$、$(2,5,1)$、$(4,6,1)$ 和 $(5,8,1)$。\n-   相应的事件时间为 $\\{5, 5, 6, 8\\}$。\n-   排序后的唯一事件时间为 $\\{t_i\\} = [5, 6, 8]$。因此，$t_1=5$，$t_2=6$，$t_3=8$。\n\n**步骤 2：计算 $\\{d_i\\}$ 和 $\\{n_i\\}$**\n\n-   **对于 $t_1 = 5$**：\n    -   $d_1$：时间 $5$ 的事件计数。记录为 $(0,5,1)$ 和 $(2,5,1)$。所以，$d_1 = 2$。\n    -   $n_1$：时间 $5$ 处于风险中的个体计数（条件：$e_j \\le 5 \\le x_j$）。\n        -   $(0,5,1)$: $0 \\le 5 \\le 5$ (是)\n        -   $(0,7,0)$: $0 \\le 5 \\le 7$ (是)\n        -   $(2,5,1)$: $2 \\le 5 \\le 5$ (是)\n        -   $(4,6,1)$: $4 \\le 5 \\le 6$ (是)\n        -   $(3,10,0)$: $3 \\le 5 \\le 10$ (是)\n        -   $(5,8,1)$: $5 \\le 5 \\le 8$ (是)\n    -   总计数为 $n_1 = 6$。\n\n-   **对于 $t_2 = 6$**：\n    -   $d_2$：时间 $6$ 的事件计数。记录为 $(4,6,1)$。所以，$d_2 = 1$。\n    -   $n_2$：时间 $6$ 处于风险中的个体计数（条件：$e_j \\le 6 \\le x_j$）。\n        -   $(0,7,0)$: $0 \\le 6 \\le 7$ (是)\n        -   $(4,6,1)$: $4 \\le 6 \\le 6$ (是)\n        -   $(3,10,0)$: $3 \\le 6 \\le 10$ (是)\n        -   $(5,8,1)$: $5 \\le 6 \\le 8$ (是)\n    -   个体 $(0,5,1)$ 和 $(2,5,1)$ 不再处于风险中，因为它们的 $x_j=5  6$。\n    -   总计数为 $n_2 = 4$。\n\n-   **对于 $t_3 = 8$**：\n    -   $d_3$：时间 $8$ 的事件计数。记录为 $(5,8,1)$。所以，$d_3 = 1$。\n    -   $n_3$：时间 $8$ 处于风险中的个体计数（条件：$e_j \\le 8 \\le x_j$）。\n        -   $(3,10,0)$: $3 \\le 8 \\le 10$ (是)\n        -   $(5,8,1)$: $5 \\le 8 \\le 8$ (是)\n    -   个体 $(0,7,0)$、$(4,6,1)$ 不再处于风险中，因为它们的 $x_j  8$。\n    -   总计数为 $n_3 = 2$。\n\n此测试用例的最终结果是三个列表：$t = [5, 6, 8]$，$n = [6, 4, 2]$ 和 $d = [2, 1, 1]$。实现将把这个确切的逻辑应用于所有提供的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes distinct event times, risk set sizes, and event counts for survival data,\n    then formats the results for all test cases into a single-line string.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        [(0,5,1), (0,7,0), (2,5,1), (4,6,1), (3,10,0), (5,8,1)],\n        # Test case 2\n        [(0,4,0), (1,3,0), (2,2,0)],\n        # Test case 3\n        [(0,4,1), (4,4,0), (2,6,1), (5,6,0), (6,6,1)],\n        # Test case 4\n        [(0,0,1), (0,1,0), (0,2,1)],\n        # Test case 5\n        [(1,3,1), (2,3,1), (3,3,0), (0,1,0)],\n    ]\n\n    all_results = []\n    for records in test_cases:\n        # If there are no records, handle as a special case.\n        if not records:\n            all_results.append([[], [], []])\n            continue\n            \n        # Convert records to a NumPy array for efficient vectorized operations.\n        # Columns: 0=entry_time (e_j), 1=exit_time (x_j), 2=event_indicator (delta_j)\n        data = np.array(records, dtype=int)\n\n        # 1. Identify distinct event times (t_i)\n        # Filter for records where an event occurred (delta_j = 1).\n        event_mask = data[:, 2] == 1\n        # Extract the exit times (x_j) for these events.\n        event_times = data[event_mask, 1]\n        # Find the unique, sorted event times. np.unique conveniently sorts the result.\n        distinct_event_times = np.unique(event_times).tolist()\n\n        # If there are no events, the result is three empty lists.\n        if not distinct_event_times:\n            all_results.append([[], [], []])\n            continue\n\n        risk_set_sizes = []\n        event_counts = []\n        \n        # 2. For each distinct event time, calculate n_i and d_i\n        for t_i in distinct_event_times:\n            # Calculate d_i: number of events at t_i.\n            # This is the count of records where exit_time is t_i AND an event occurred.\n            d_i = np.sum((data[:, 1] == t_i)  (data[:, 2] == 1))\n            event_counts.append(int(d_i)) # Ensure it's a standard Python int\n\n            # Calculate n_i: number of individuals at risk at t_i.\n            # This is the count of records where entry_time = t_i = exit_time.\n            n_i = np.sum((data[:, 0] = t_i)  (t_i = data[:, 1]))\n            risk_set_sizes.append(int(n_i)) # Ensure it's a standard Python int\n            \n        all_results.append([\n            distinct_event_times,\n            risk_set_sizes,\n            event_counts\n        ])\n\n    # 3. Format the final output string exactly as specified.\n    # The output must be a single line, with no spaces between list elements.\n    case_strings = []\n    for res in all_results:\n        # res is a list of three lists: [[t_i...], [n_i...], [d_i...]]\n        t_str = f\"[{','.join(map(str, res[0]))}]\"\n        n_str = f\"[{','.join(map(str, res[1]))}]\"\n        d_str = f\"[{','.join(map(str, res[2]))}]\"\n        case_str = f\"[{t_str},{n_str},{d_str}]\"\n        case_strings.append(case_str)\n        \n    final_output_str = f\"[{','.join(case_strings)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "计算生存曲线只是分析的第一步，更重要的是如何正确解读结果并与他人沟通。本练习模拟了一个在临床试验中经常遇到的挑战：当其中一组的Kaplan-Meier曲线在研究期间未降至 $0.5$ 以下时，中位生存时间无法估计。你需要评估不同的解决方案，并选择最科学、最稳健的替代总结指标，从而培养在真实研究场景下进行批判性思考和解决问题的能力 。",
            "id": "4605656",
            "problem": "一项流行病学领域的随机试验比较了两组——新疗法组（T组）和标准治疗组（C组）——在复合不良结局发生时间上的差异。所有参与者的随访在 $36$ 个月时被行政删失。生存经验通过 Kaplan-Meier 估计量进行总结，这是在右删失情况下生存函数 $S(t) = \\mathbb{P}(T  t)$ 的非参数乘积极限估计量。Kaplan-Meier 曲线显示，C组的估计生存曲线在大约 $21$ 个月时下降到 $0.5$ 以下，而T组的估计生存曲线在整个 $36$ 个月的随访窗口内一直保持在 $0.5$ 以上。研究人员最初计划报告两组中位生存时间的差异。\n\n鉴于其中一组的 Kaplan-Meier 曲线在观测窗口内未穿过 $0.5$，哪个选项最能解释这种情况并提出一个适当且科学合理的非参数总结方法？\n\nA. 报告中位数差异，用 $36$ 个月替代T组的中位数，将行政删失时间视为中位数的保守估计，因为至少有一半的T组参与者存活时间超过了 $36$ 个月。\n\nB. 结论是T组的中位生存期在 $36$ 个月内未达到，因此无法从观测数据中估计中位数差异；应改为使用截至预先设定的截断时间（例如 $\\tau = 36$ 个月）的限制性平均生存时间差异，并比较特定时间点的生存概率（例如 $S(12)$、$S(24)$、$S(36)$）来总结组间差异。\n\nC. 拟合 Cox 比例风险模型并报告风险比作为主要总结，因为风险比不需要估计中位数，从而避免了 Kaplan-Meier 曲线未穿过 $0.5$ 的问题。\n\nD. 通过将两条 Kaplan-Meier 曲线在 $36$ 个月后线性外推至 $0$ 来估计和比较平均生存时间，因为曲线下面积可以估计平均生存时间，而线性外推提供了一种简单的尾部补全方法。\n\nE. 比较各组的 $25$ 百分位数生存时间（即 $25\\%$ 的个体发生事件的时间），因为两条曲线都在 $36$ 个月内穿过了 $0.75$，使得在这种情况下，较低的分位数成为中位数的更好替代品。",
            "solution": "这个问题探讨了生存分析中一个常见的挑战：当至少有一组的中位生存时间在随访期内未达到时，如何总结和比较生存分布。\n\n中位生存时间是生存概率 $S(t)$ 等于 $0.5$ 的时间点 $t$。对于右删失数据，中位数被估计为 Kaplan-Meier 曲线 $\\hat{S}(t)$ 穿过 $0.5$ 水平线的时间。在这个情景中，对于C组，中位数可以估计为大约 $21$ 个月。然而，对于T组，Kaplan-Meier 曲线 $\\hat{S}_T(t)$ 在整个 $36$ 个月的研究期间都保持在 $0.5$ 以上。这意味着在研究结束时，T组中发生事件的参与者少于 $50\\%$。因此，T组的中位生存时间长于 $36$ 个月，但在不对超过最长随访时间的生存分布做强且无法检验的假设的情况下，无法从观测数据中估计出来。\n\n**选项验证：**\n\nA. 错误。用最后的观察时间（$36$ 个月）替代中位数是一种临时的插补方法，已知这会给治疗效果的估计带来偏倚。它人为地将中位数设定为 $36$，而真实中位数已知是大于 $36$ 的。这低估了真实中位数，从而低估了组间差异。\n\nB. 正确。这是最恰当且统计学上最可靠的方法。它正确地认识到T组的中位数无法从数据中估计。它没有强行进行估计，而是提出了两种有效的非参数替代方案。（1）限制性平均生存时间（RMST）是生存曲线下截至特定时间点 $\\tau$（例如 $36$ 个月）的面积。两组之间 RMST 的差异提供了一个稳健且具有临床可解释性的度量，衡量了在区间 $[0, \\tau]$ 内获得的平均生存时间。它使用了截至 $\\tau$ 的所有可用数据，而无需外推。（2）在特定的、具有临床意义的时间点（例如，$S(12)$、$S(24)$、$S(36)$）比较生存概率是另一种标准的、易于解释的总结曲线差异的方法。\n\nC. 错误。虽然 Cox 模型及其产生的风险比（HR）在生存分析中非常普遍，但转换到此模型并非对观测到的 Kaplan-Meier 曲线的直接非参数总结。HR 是一个相对效应度量，并依赖于可能不成立的比例风险假设。报告 HR 是一种有效的分析策略，但当未达到中位数时，它并不是*总结非参数曲线*的最佳方式。选项B提供了直接基于非参数 Kaplan-Meier 估计本身的总结指标（RMST，特定时间点生存率）。\n\nD. 错误。将生存曲线外推到观测数据范围之外是高度推测性的，并且依赖于假设。线性外推尤其简单幼稚，并且通常是不合理的，因为生存曲线通常不是线性的。这种方法可能导致估计的平均生存时间出现严重偏倚。\n\nE. 错误。比较较低的分位数（如 $25$ 百分位数）是一种可能的策略，并且对两组来说都是可以估计的。然而，与 RMST 相比，这是一个不太全面的总结。它只关注早期事件（前 $25\\%$ 的失败），而忽略了其余 $75\\%$ 的参与者在剩余随访期内的生存经验。虽然比强行估计中位数要好，但它不如B中提出的方法信息量大。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}