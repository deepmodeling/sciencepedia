{
    "hands_on_practices": [
        {
            "introduction": "这第一个练习将重点关注任何生存分析的基础步骤：处理原始的事件时间数据。你将设计一个算法，以正确识别事件时间点，并在每个时间点上构建风险集（risk set），同时处理例如左截断（left truncation）或交错进入（staggered entry）和右删失（right censoring）等复杂情况。在进行任何估计之前，掌握这一数据整理步骤至关重要。",
            "id": "4605689",
            "problem": "您的任务是设计并实现一个算法，该算法基于生存分析原理，用于构建风险集函数并计算 Kaplan-Meier 估计量所需的各种量。每个个体由进入时间、退出时间和事件指示符组成的三元组表示。时间以天为单位，所有输出必须酌情以天或无单位的计数表示。您编写的程序必须实现以下定义和约定，并为指定的测试套件生成输出。\n\n定义和约定：\n- 假设有 $N$ 个个体，索引为 $j \\in \\{1,2,\\dots,N\\}$。每个个体的记录由 $(e_j, x_j, \\delta_j)$ 组成，其中 $e_j$ 是进入时间（左截断），$x_j$ 是退出时间，$\\delta_j \\in \\{0,1\\}$ 是事件指示符，$\\delta_j = 1$ 表示在时间 $x_j$ 发生事件，$\\delta_j = 0$ 表示在时间 $x_j$ 发生删失。\n- 时间 $t$ 的风险集，记为 $R(t)$，是满足 $e_j \\le t \\le x_j$ 的索引 $j$ 的集合。此约定确保了在时间 $t$ 发生事件或在时间 $t$ 被删失的个体，在被移除前的一刻仍被计为在时间 $t$ 处于风险中。\n- 不同事件时间是 $\\{x_j : \\delta_j = 1\\}$ 的排序后唯一值。将这些时间记为 $\\{t_i\\}_{i=1}^m$，其中 $m$ 是不同事件时间的数量。\n- 对于每个事件时间 $t_i$，将风险集大小定义为 $n_i = |R(t_i)|$，将在该时间的事件数定义为 $d_i = \\sum_{j=1}^N \\mathbf{1}\\{x_j = t_i, \\delta_j = 1\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n- 所有时间都必须以天为单位处理。输出 $t_i$ 以天为单位（在此测试套件中为整数），$n_i$ 和 $d_i$ 是无单位的计数（整数）。\n\n您的程序必须：\n- 对于每个测试用例，根据上述定义计算事件时间列表 $\\{t_i\\}$、相应的风险集大小 $\\{n_i\\}$ 和事件计数 $\\{d_i\\}$。\n- 使用纳入规则 $e_j \\le t_i \\le x_j$ 来判断是否为 $R(t_i)$ 的成员。\n- 将事件视为在时间 $t_i$ 发生，将在时间 $t_i$ 的删失观测值视为保留在时间 $t_i$ 的风险集中，但不计入 $d_i$。\n\n测试套件：\n为以下五个测试用例提供输出。在每个用例中，输入是记录列表 $(e_j, x_j, \\delta_j)$，所有时间均以天为单位。\n\n- 测试用例 1（理想情况，包含交错进入、同时事件和删失）：\n  - 记录：$[(0,5,1), (0,7,0), (2,5,1), (4,6,1), (3,10,0), (5,8,1)]$。\n  - 预期不同事件时间：$[5,6,8]$（天）。\n\n- 测试用例 2（无事件；全部删失）：\n  - 记录：$[(0,4,0), (1,3,0), (2,2,0)]$。\n  - 预期不同事件时间：$[]$。\n\n- 测试用例 3（左截断，在事件时间存在并列情况，包括恰好在事件时间进入）：\n  - 记录：$[(0,4,1), (4,4,0), (2,6,1), (5,6,0), (6,6,1)]$。\n  - 预期不同事件时间：$[4,6]$（天）。\n\n- 测试用例 4（边界情况，事件发生在时间 $0$）：\n  - 记录：$[(0,0,1), (0,1,0), (0,2,1)]$。\n  - 预期不同事件时间：$[0,2]$（天）。\n\n- 测试用例 5（同时事件，存在恰好在事件时间较晚进入和早期删失的情况）：\n  - 记录：$[(1,3,1), (2,3,1), (3,3,0), (0,1,0)]$。\n  - 预期不同事件时间：$[3]$（天）。\n\n最终输出格式规范：\n- 对于每个测试用例，您的程序必须生成一个包含三个列表的列表：事件时间列表 $[t_1,\\dots,t_m]$、相应的列表 $[n_1,\\dots,n_m]$ 和相应的列表 $[d_1,\\dots,d_m]$。\n- 将所有测试用例的结果聚合为单行打印输出，其中包含一个由这些按用例划分的列表组成的逗号分隔列表，并用方括号括起来。例如，通用格式为 $[[[t_{1}^{(1)},\\dots],[n_{1}^{(1)},\\dots],[d_{1}^{(1)},\\dots]],[[t_{1}^{(2)},\\dots],[n_{1}^{(2)},\\dots],[d_{1}^{(2)},\\dots]],\\dots]$。\n- 由于此输出用于自动检查，请确保它只有一行，不含任何额外文本。\n\n您的任务是实现此算法并用 Python 生成指定的输出。不需要用户输入；测试用例必须硬编码在程序中。时间和计数的答案必须是整数。程序必须是一个完整的、可运行的实现，遵循上述约定，并为测试套件准确生成指定格式的输出。",
            "solution": "该问题是有效的。它提出了一个计算生物统计学中清晰明确的任务，特别是在存在左截断（交错进入）和右删失生存数据的情况下，计算 Kaplan-Meier 估计量所需的各种量。问题中为风险集、事件时间、风险人数和事件数提供的定义是生存分析中的标准定义，并且在科学上是合理且内部一致的。\n\n目标是开发一个算法，处理一个个体记录列表，每个记录由三元组 $(e_j, x_j, \\delta_j)$ 表示，其中 $e_j$ 是进入时间，$x_j$ 是退出时间，$\\delta_j$ 是事件指示符。对于给定的数据，我们必须计算不同事件时间的集合 $\\{t_i\\}_{i=1}^m$，并为每个事件时间 $t_i$ 计算相应的风险个体数 $n_i$ 和事件数 $d_i$。这些量是构建 Kaplan-Meier 生存曲线的基础。\n\n该算法主要分两个阶段进行：\n1.  识别不同事件时间。\n2.  对每个事件时间，计算相关的事件数和风险集的大小。\n\n设个体总数为 $N$，索引为 $j \\in \\{1, 2, \\dots, N\\}$。\n\n**1. 识别不同事件时间, $\\{t_i\\}$**\n\n第一步是识别发生目标事件的具体时间点。事件由 $\\delta_j = 1$ 指示。个体 $j$ 的事件时间是其退出时间 $x_j$。我们从数据集中收集所有此类时间：$\\{x_j \\mid \\delta_j = 1\\}$。由于多个事件可能在同一时间发生，此集合可能包含重复值。为了获得不同事件时间的集合，我们从此集合中提取唯一值并按时间升序排列。将这些排序后的唯一事件时间记为 $t_1, t_2, \\dots, t_m$，其中 $m$ 是不同事件时间的总数。如果数据集中没有事件发生（即，对所有 $j$ 都有 $\\delta_j = 0$），则此集合为空，因此 $m=0$。\n\n**2. 计算事件计数 $\\{d_i\\}$ 和风险集大小 $\\{n_i\\}$**\n\n对于第一步中识别出的每个不同事件时间 $t_i$，我们必须计算两个量：$d_i$ 和 $n_i$。\n\n-   **事件数 ($d_i$)**：量 $d_i$ 是指在时间 $t_i$ 精确发生事件的个体总数。计算方法是遍历所有 $N$ 个个体，并统计满足以下两个条件的个体数量：其退出时间 $x_j$ 等于 $t_i$ 且其事件指示符 $\\delta_j$ 为 $1$。\n    $$d_i = \\sum_{j=1}^N \\mathbf{1}\\{x_j = t_i \\text{ and } \\delta_j = 1\\}$$\n    其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，如果条件为真则为 $1$，否则为 $0$。\n\n-   **风险集大小 ($n_i$)**：量 $n_i$ 表示在时间 $t_i$ 处于事件风险中的个体数量。问题将时间 $t$ 的风险集 $R(t)$ 定义为满足 $e_j \\le t \\le x_j$ 的个体 $j$ 的集合。此定义正确地包括了在时间 $t$ 或之前进入研究且在时间 $t$ 仍处于观察中的个体。在时间 $t$ 退出（由于事件或删失）的个体被认为在其退出前一刻处于风险中，因此被包含在风险集 $R(t)$ 中。因此，事件时间 $t_i$ 的风险集大小，记为 $n_i$，是 $R(t_i)$ 的基数：\n    $$n_i = |R(t_i)| = \\sum_{j=1}^N \\mathbf{1}\\{e_j \\le t_i \\le x_j\\}$$\n\n通过遍历排序后的不同事件时间列表中的每个 $t_i$ 并执行这两项计算，我们可以构建所需的列表 $\\{t_i\\}$, $\\{n_i\\}$ 和 $\\{d_i\\}$。\n\n**示例演练：测试用例 1**\n\n让我们将此算法应用于第一个测试用例。\n记录为 $[(0,5,1), (0,7,0), (2,5,1), (4,6,1), (3,10,0), (5,8,1)]$。\n\n**步骤 1：寻找事件时间 $\\{t_i\\}$**\n-   发生事件的个体 ($\\delta_j=1$) 是 $(0,5,1)$, $(2,5,1)$, $(4,6,1)$ 和 $(5,8,1)$。\n-   相应的事件时间是 $\\{5, 5, 6, 8\\}$。\n-   排序后的唯一事件时间是 $\\{t_i\\} = [5, 6, 8]$。因此，$t_1=5$，$t_2=6$，$t_3=8$。\n\n**步骤 2：计算 $\\{d_i\\}$ 和 $\\{n_i\\}$**\n\n-   **对于 $t_1 = 5$**：\n    -   $d_1$：时间 $5$ 的事件计数。记录为 $(0,5,1)$ 和 $(2,5,1)$。所以，$d_1 = 2$。\n    -   $n_1$：时间 $5$ 处于风险中的个体计数（条件：$e_j \\le 5 \\le x_j$）。\n        -   $(0,5,1)$: $0 \\le 5 \\le 5$ (是)\n        -   $(0,7,0)$: $0 \\le 5 \\le 7$ (是)\n        -   $(2,5,1)$: $2 \\le 5 \\le 5$ (是)\n        -   $(4,6,1)$: $4 \\le 5 \\le 6$ (是)\n        -   $(3,10,0)$: $3 \\le 5 \\le 10$ (是)\n        -   $(5,8,1)$: $5 \\le 5 \\le 8$ (是)\n    -   总计数为 $n_1 = 6$。\n\n-   **对于 $t_2 = 6$**：\n    -   $d_2$：时间 $6$ 的事件计数。记录为 $(4,6,1)$。所以，$d_2 = 1$。\n    -   $n_2$：时间 $6$ 处于风险中的个体计数（条件：$e_j \\le 6 \\le x_j$）。\n        -   $(0,7,0)$: $0 \\le 6 \\le 7$ (是)\n        -   $(4,6,1)$: $4 \\le 6 \\le 6$ (是)\n        -   $(3,10,0)$: $3 \\le 6 \\le 10$ (是)\n        -   $(5,8,1)$: $5 \\le 6 \\le 8$ (是)\n    -   个体 $(0,5,1)$ 和 $(2,5,1)$ 不再处于风险中，因为它们的 $x_j=5  6$。\n    -   总计数为 $n_2 = 4$。\n\n-   **对于 $t_3 = 8$**：\n    -   $d_3$：时间 $8$ 的事件计数。记录为 $(5,8,1)$。所以，$d_3 = 1$。\n    -   $n_3$：时间 $8$ 处于风险中的个体计数（条件：$e_j \\le 8 \\le x_j$）。\n        -   $(3,10,0)$: $3 \\le 8 \\le 10$ (是)\n        -   $(5,8,1)$: $5 \\le 8 \\le 8$ (是)\n    -   个体 $(0,7,0)$ 和 $(4,6,1)$ 不再处于风险中，因为它们的 $x_j  8$。\n    -   总计数为 $n_3 = 2$。\n\n此测试用例的最终结果是三个列表：$t = [5, 6, 8]$，$n = [6, 4, 2]$ 和 $d = [2, 1, 1]$。实现将对所有提供的测试用例应用完全相同的逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes distinct event times, risk set sizes, and event counts for survival data,\n    then formats the results for all test cases into a single-line string.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        [(0,5,1), (0,7,0), (2,5,1), (4,6,1), (3,10,0), (5,8,1)],\n        # Test case 2\n        [(0,4,0), (1,3,0), (2,2,0)],\n        # Test case 3\n        [(0,4,1), (4,4,0), (2,6,1), (5,6,0), (6,6,1)],\n        # Test case 4\n        [(0,0,1), (0,1,0), (0,2,1)],\n        # Test case 5\n        [(1,3,1), (2,3,1), (3,3,0), (0,1,0)],\n    ]\n\n    all_results = []\n    for records in test_cases:\n        # If there are no records, handle as a special case.\n        if not records:\n            all_results.append([[], [], []])\n            continue\n            \n        # Convert records to a NumPy array for efficient vectorized operations.\n        # Columns: 0=entry_time (e_j), 1=exit_time (x_j), 2=event_indicator (delta_j)\n        data = np.array(records, dtype=int)\n\n        # 1. Identify distinct event times (t_i)\n        # Filter for records where an event occurred (delta_j = 1).\n        event_mask = data[:, 2] == 1\n        # Extract the exit times (x_j) for these events.\n        event_times = data[event_mask, 1]\n        # Find the unique, sorted event times. np.unique conveniently sorts the result.\n        distinct_event_times = np.unique(event_times).tolist()\n\n        # If there are no events, the result is three empty lists.\n        if not distinct_event_times:\n            all_results.append([[], [], []])\n            continue\n\n        risk_set_sizes = []\n        event_counts = []\n        \n        # 2. For each distinct event time, calculate n_i and d_i\n        for t_i in distinct_event_times:\n            # Calculate d_i: number of events at t_i.\n            # This is the count of records where exit_time is t_i AND an event occurred.\n            d_i = np.sum((data[:, 1] == t_i)  (data[:, 2] == 1))\n            event_counts.append(int(d_i)) # Ensure it's a standard Python int\n\n            # Calculate n_i: number of individuals at risk at t_i.\n            # This is the count of records where entry_time = t_i = exit_time.\n            n_i = np.sum((data[:, 0] = t_i)  (t_i = data[:, 1]))\n            risk_set_sizes.append(int(n_i)) # Ensure it's a standard Python int\n            \n        all_results.append([\n            distinct_event_times,\n            risk_set_sizes,\n            event_counts\n        ])\n\n    # 3. Format the final output string exactly as specified.\n    # The output must be a single line, with no spaces between list elements.\n    case_strings = []\n    # Expected results from manual calculation:\n    # TC1: [[5,6,8],[6,4,2],[2,1,1]]\n    # TC2: [[],[],[]]\n    # TC3: [[4,6],[3,3],[1,2]]\n    # TC4: [[0,2],[3,1],[1,1]]\n    # TC5: [[3],[3],[2]]\n    \n    # This block generates the output string from the calculated results.\n    for res in all_results:\n        # res is a list of three lists: [[t_i...], [n_i...], [d_i...]]\n        t_str = f\"[{','.join(map(str, res[0]))}]\"\n        n_str = f\"[{','.join(map(str, res[1]))}]\"\n        d_str = f\"[{','.join(map(str, res[2]))}]\"\n        case_str = f\"[{t_str},{n_str},{d_str}]\"\n        case_strings.append(case_str)\n        \n    final_output_str = f\"[{','.join(case_strings)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了如何从数据中提取风险集和事件数之后，我们现在可以进入Kaplan-Meier估计的核心计算环节。本练习提供一个小型假设数据集，引导你逐步使用乘积极限公式（product-limit formula）计算生存概率 $\\hat{S}(t)$，并使用Greenwood公式计算其标准误。这项实践将巩固你对生存曲线背后计算机制的理解。",
            "id": "4605693",
            "problem": "一项流行病学队列研究跟踪了 $8$ 名个体，从基线开始，直至发生失败事件（例如，疾病发作）或删失。时间以月为单位记录。对于每个个体 $j$，令 $t_j$ 表示观察到的随访时间，$\\delta_j$ 是一个指示符，其中如果 $t_j$ 时刻发生了失败事件，则 $\\delta_j = 1$，如果观察在 $t_j$ 时刻被删失，则 $\\delta_j = 0$。观察到的数据如下：\n- 个体 $1$：$t_1 = 2$，$\\delta_1 = 1$。\n- 个体 $2$：$t_2 = 4$，$\\delta_2 = 1$。\n- 个体 $3$：$t_3 = 4$，$\\delta_3 = 1$。\n- 个体 $4$：$t_4 = 5$，$\\delta_4 = 0$。\n- 个体 $5$：$t_5 = 6$，$\\delta_5 = 1$。\n- 个体 $6$：$t_6 = 7$，$\\delta_6 = 1$。\n- 个体 $7$：$t_7 = 7$，$\\delta_7 = 0$。\n- 个体 $8$：$t_8 = 9$，$\\delta_8 = 0$。\n\n假设遵循以下科学标准惯例：\n- 生存时间 $T$ 是一个非负随机变量，生存函数 $S(t)$ 定义为 $S(t) = \\mathbb{P}(T  t)$。\n- 使用 Kaplan–Meier 乘积极限估计量从右删失数据中非参数地估计生存函数。\n- 当失败和删失发生在同一观察时间 $t$ 时，在构建风险集和更新生存估计时，先处理时间 $t$ 的所有失败，再处理时间 $t$ 的删失（事件优先惯例）。\n\n仅使用生存分析中的标准定义，对不同的失败时间 $t = 2$、$t = 4$、$t = 6$ 和 $t = 7$ 执行以下任务：\n1. 计算每个不同失败时间 $t_i$ 之前的风险人数 $n_i$ 和在 $t_i$ 时的失败数 $d_i$。\n2. 计算每个不同失败时间点之后的 Kaplan–Meier 估计值 $\\hat{S}(t)$。\n3. 计算每个不同失败时间点的 $\\hat{S}(t)$ 的 Greenwood 标准误 (SE)。\n\n最后，将 $t=7$ 时 Kaplan–Meier 估计量的 Greenwood 标准误报告为单个数值。答案四舍五入至四位有效数字。最终答案中不要包含单位。",
            "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n提供了 $8$ 名个体的数据，包括随访时间 $t_j$（单位：月）和事件指示符 $\\delta_j$。\n-   个体 $1$：$t_1 = 2$，$\\delta_1 = 1$\n-   个体 $2$：$t_2 = 4$，$\\delta_2 = 1$\n-   个体 $3$：$t_3 = 4$，$\\delta_3 = 1$\n-   个体 $4$：$t_4 = 5$，$\\delta_4 = 0$\n-   个体 $5$：$t_5 = 6$，$\\delta_5 = 1$\n-   个体 $6$：$t_6 = 7$，$\\delta_6 = 1$\n-   个体 $7$：$t_7 = 7$，$\\delta_7 = 0$\n-   个体 $8$：$t_8 = 9$，$\\delta_8 = 0$\n$\\delta_j = 1$ 的值表示失败事件，$\\delta_j = 0$ 的值表示删失。\n生存函数定义为 $S(t) = \\mathbb{P}(T  t)$。\n分析要求使用 Kaplan–Meier 乘积极限估计量。\n规定了处理失败和删失时间之间结点的特定惯例：在同一时间点，先处理事件，后处理删失（事件优先惯例）。\n任务是计算不同失败时间 $t = 2, 4, 6, 7$ 的风险人数 ($n_i$)、失败数 ($d_i$)、Kaplan–Meier 估计值 ($\\hat{S}(t)$) 和 Greenwood 标准误 (SE)，并报告 $t=7$ 时的最终 SE，四舍五入至四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题是生存分析的标准应用，生存分析是流行病学和生物统计学的核心方法论。Kaplan–Meier 估计量及其方差的 Greenwood 公式是分析右删失事件时间数据的基本且被普遍接受的工具。该问题在科学上是合理的。\n-   **良态问题**：数据、定义以及明确的“事件优先”惯例为计算提供了一个完整且明确的框架。存在唯一、稳定且有意义的解。\n-   **客观性**：该问题使用生存分析中精确、标准的术语进行陈述，没有主观或含糊不清的语言。\n-   该问题不违反任何其他有效性标准。它是完整的、一致的、现实的，并与指定主题直接相关。\n\n### 步骤 3：结论与行动\n该问题有效。将提供一个完整、合理的解决方案。\n\nKaplan-Meier 估计量 $\\hat{S}(t)$ 是一种非参数统计量，用于根据事件时间数据估计生存函数。它通过在每个不同失败时间点的条件生存概率的乘积来计算。其公式为：\n$$\n\\hat{S}(t) = \\prod_{i: t_i \\le t} \\left( 1 - \\frac{d_i}{n_i} \\right)\n$$\n其中 $t_i$ 是不同的失败时间，$d_i$ 是时间 $t_i$ 的失败数，$n_i$ 是恰好在时间 $t_i$ 之前的风险个体数（存活且未删失）。根据惯例，$\\hat{S}(0) = 1$。\n\nGreenwood 公式用于估计 Kaplan-Meier 估计量的方差。$\\hat{S}(t)$ 的方差由下式给出：\n$$\n\\text{Var}(\\hat{S}(t)) = [\\hat{S}(t)]^2 \\sum_{i: t_i \\le t} \\frac{d_i}{n_i(n_i - d_i)}\n$$\n标准误 (SE) 是方差的平方根：\n$$\n\\text{SE}(\\hat{S}(t)) = \\sqrt{\\text{Var}(\\hat{S}(t))} = |\\hat{S}(t)| \\sqrt{\\sum_{i: t_i \\le t} \\frac{d_i}{n_i(n_i - d_i)}}\n$$\n\n首先，我们按时间对所有观察值进行排序，并确定不同的失败时间。\n观察时间为 $t = 2, 4, 4, 5, 6, 7, 7, 9$。\n不同的失败时间为 $t_{(1)} = 2$, $t_{(2)} = 4$, $t_{(3)} = 6$ 和 $t_{(4)} = 7$。\n\n我们构建一个生存表来逐步进行计算。\n研究开始时的总个体数为 $N=8$。\n\n**1. 时间 $t_{(1)} = 2$**\n-   在 $t=2$ 之前，风险个体数是研究中的所有人。因此，$n_1 = 8$。\n-   在 $t=2$ 时，有一个个体发生失败事件。因此，$d_1 = 1$。\n-   在 $t=2$ 之后的 Kaplan-Meier 生存估计值为：\n    $$\n    \\hat{S}(2) = \\hat{S}(0) \\times \\left(1 - \\frac{d_1}{n_1}\\right) = 1 \\times \\left(1 - \\frac{1}{8}\\right) = \\frac{7}{8}\n    $$\n-   为了计算 SE，我们首先找到该时间点的方差项：\n    $$\n    \\frac{d_1}{n_1(n_1 - d_1)} = \\frac{1}{8(8 - 1)} = \\frac{1}{56}\n    $$\n-   $\\hat{S}(2)$ 的方差为：\n    $$\n    \\text{Var}(\\hat{S}(2)) = [\\hat{S}(2)]^2 \\left(\\frac{d_1}{n_1(n_1 - d_1)}\\right) = \\left(\\frac{7}{8}\\right)^2 \\times \\frac{1}{56} = \\frac{49}{64} \\times \\frac{1}{56} = \\frac{7}{64 \\times 8} = \\frac{7}{512}\n    $$\n-   $\\hat{S}(2)$ 的 Greenwood SE 为：\n    $$\n    \\text{SE}(\\hat{S}(2)) = \\sqrt{\\frac{7}{512}}\n    $$\n-   此时间点后，风险集中剩下 $n_1 - d_1 = 7$ 名个体。\n\n**2. 时间 $t_{(2)} = 4$**\n-   在 $t=4$ 之前，风险个体数为 $n_2 = 7$。\n-   在 $t=4$ 时，有两个个体发生失败事件。因此，$d_2 = 2$。\n-   在 $t=4$ 之后的 Kaplan-Meier 生存估计值为：\n    $$\n    \\hat{S}(4) = \\hat{S}(2) \\times \\left(1 - \\frac{d_2}{n_2}\\right) = \\frac{7}{8} \\times \\left(1 - \\frac{2}{7}\\right) = \\frac{7}{8} \\times \\frac{5}{7} = \\frac{5}{8}\n    $$\n-   该时间点的方差项为：\n    $$\n    \\frac{d_2}{n_2(n_2 - d_2)} = \\frac{2}{7(7 - 2)} = \\frac{2}{35}\n    $$\n-   方差计算的累加和为：\n    $$\n    \\sum_{i=1}^{2} \\frac{d_i}{n_i(n_i - d_i)} = \\frac{1}{56} + \\frac{2}{35} = \\frac{5 + 16}{280} = \\frac{21}{280} = \\frac{3}{40}\n    $$\n-   $\\hat{S}(4)$ 的方差为：\n    $$\n    \\text{Var}(\\hat{S}(4)) = [\\hat{S}(4)]^2 \\sum_{i=1}^{2} \\frac{d_i}{n_i(n_i - d_i)} = \\left(\\frac{5}{8}\\right)^2 \\times \\frac{3}{40} = \\frac{25}{64} \\times \\frac{3}{40} = \\frac{5}{64} \\times \\frac{3}{8} = \\frac{15}{512}\n    $$\n-   $\\hat{S}(4)$ 的 Greenwood SE 为：\n    $$\n    \\text{SE}(\\hat{S}(4)) = \\sqrt{\\frac{15}{512}}\n    $$\n-   此时间点后，剩下 $n_2 - d_2 = 5$ 名个体。在 $t=5$ 时，一个个体被删失，风险集中剩下 $4$ 人。\n\n**3. 时间 $t_{(3)} = 6$**\n-   在 $t=6$ 之前，风险个体数为 $n_3 = 4$。\n-   在 $t=6$ 时，有一个个体发生失败事件。因此，$d_3 = 1$。\n-   在 $t=6$ 之后的 Kaplan-Meier 生存估计值为：\n    $$\n    \\hat{S}(6) = \\hat{S}(4) \\times \\left(1 - \\frac{d_3}{n_3}\\right) = \\frac{5}{8} \\times \\left(1 - \\frac{1}{4}\\right) = \\frac{5}{8} \\times \\frac{3}{4} = \\frac{15}{32}\n    $$\n-   该时间点的方差项为：\n    $$\n    \\frac{d_3}{n_3(n_3 - d_3)} = \\frac{1}{4(4 - 1)} = \\frac{1}{12}\n    $$\n-   方差计算的累加和为：\n    $$\n    \\sum_{i=1}^{3} \\frac{d_i}{n_i(n_i - d_i)} = \\frac{3}{40} + \\frac{1}{12} = \\frac{9 + 10}{120} = \\frac{19}{120}\n    $$\n-   $\\hat{S}(6)$ 的方差为：\n    $$\n    \\text{Var}(\\hat{S}(6)) = [\\hat{S}(6)]^2 \\sum_{i=1}^{3} \\frac{d_i}{n_i(n_i - d_i)} = \\left(\\frac{15}{32}\\right)^2 \\times \\frac{19}{120} = \\frac{225}{1024} \\times \\frac{19}{120} = \\frac{15 \\times 19}{1024 \\times 8} = \\frac{285}{8192}\n    $$\n-   $\\hat{S}(6)$ 的 Greenwood SE 为：\n    $$\n    \\text{SE}(\\hat{S}(6)) = \\sqrt{\\frac{285}{8192}}\n    $$\n-   此时间点后，风险集中剩下 $n_3 - d_3 = 3$ 名个体。\n\n**4. 时间 $t_{(4)} = 7$**\n-   在 $t=7$ 之前，风险个体数为 $n_4 = 3$。\n-   在 $t=7$ 时，有一个失败和一个删失。根据事件优先惯例，我们使用 $n_4=3$ 的风险集来处理失败事件。所以，$d_4 = 1$。\n-   在 $t=7$ 之后的 Kaplan-Meier 生存估计值为：\n    $$\n    \\hat{S}(7) = \\hat{S}(6) \\times \\left(1 - \\frac{d_4}{n_4}\\right) = \\frac{15}{32} \\times \\left(1 - \\frac{1}{3}\\right) = \\frac{15}{32} \\times \\frac{2}{3} = \\frac{30}{96} = \\frac{5}{16}\n    $$\n-   该时间点的方差项为：\n    $$\n    \\frac{d_4}{n_4(n_4 - d_4)} = \\frac{1}{3(3 - 1)} = \\frac{1}{6}\n    $$\n-   方差计算的累加和为：\n    $$\n    \\sum_{i=1}^{4} \\frac{d_i}{n_i(n_i - d_i)} = \\frac{19}{120} + \\frac{1}{6} = \\frac{19 + 20}{120} = \\frac{39}{120} = \\frac{13}{40}\n    $$\n-   $\\hat{S}(7)$ 的方差为：\n    $$\n    \\text{Var}(\\hat{S}(7)) = [\\hat{S}(7)]^2 \\sum_{i=1}^{4} \\frac{d_i}{n_i(n_i - d_i)} = \\left(\\frac{5}{16}\\right)^2 \\times \\frac{13}{40} = \\frac{25}{256} \\times \\frac{13}{40} = \\frac{5}{256} \\times \\frac{13}{8} = \\frac{65}{2048}\n    $$\n-   $\\hat{S}(7)$ 的 Greenwood SE 为：\n    $$\n    \\text{SE}(\\hat{S}(7)) = \\sqrt{\\frac{65}{2048}}\n    $$\n\n最后，我们计算 $t=7$ 时 SE 的数值，并四舍五入至四位有效数字。\n$$\n\\text{SE}(\\hat{S}(7)) = \\sqrt{\\frac{65}{2048}} \\approx \\sqrt{0.03173828...} \\approx 0.1781524...\n$$\n四舍五入至四位有效数字，我们得到 $0.1782$。",
            "answer": "$$\\boxed{0.1782}$$"
        },
        {
            "introduction": "生成生存曲线只是工作的一半；为了得出有效的科学结论，正确解读曲线至关重要。这最后一个练习呈现了一个临床试验中的常见情景：一个组的标准汇总指标——中位生存时间——因为生存曲线未降至 $0.5$ 以下而无法被估计。你将学习如何批判性地评估这种情况，并确定合适的替代指标，如限制性平均生存时间（restricted mean survival time），来总结和比较各组的生存经验。",
            "id": "4605656",
            "problem": "一项流行病学领域的随机试验比较了两组——新疗法组（T组）和标准治疗组（C组）——发生复合不良结局的时间。所有参与者的随访在 $36$ 个月时被行政删失。生存经验采用 Kaplan–Meier 估计量进行总结，该估计量是在右删失情况下生存函数 $S(t) = \\mathbb{P}(T  t)$ 的非参数乘积极限估计量。Kaplan–Meier 曲线显示，C组的估计生存曲线在大约 $21$ 个月时下降到 $0.5$ 以下，而T组的估计生存曲线在整个 $36$ 个月的随访窗口内保持在 $0.5$ 以上。研究者最初计划报告两组中位生存时间的差异。\n\n鉴于其中一组的 Kaplan–Meier 曲线在观测窗口内未跨越 $0.5$，哪个选项最能解释这种情况并提出一个适当、科学合理的非参数总结方法？\n\nA. 报告中位数差异，将 $36$ 个月替换为T组的中位数，并将行政删失时间视为中位数的保守估计，因为至少一半的T组参与者存活时间超过了 $36$ 个月。\n\nB. 结论是T组的中位生存时间在 $36$ 个月内未达到，因此无法从观测数据中估计中位数的差异；应改用截至预先指定的截断时间（例如 $\\tau = 36$ 个月）的限制性平均生存时间的差异来总结组间差异，并比较特定时间的生存概率（例如 $S(12)$, $S(24)$, $S(36)$）。\n\nC. 拟合 Cox 比例风险模型并报告风险比作为主要总结，因为风险比不需要估计中位数，从而避免了 Kaplan–Meier 曲线未跨越 $0.5$ 的问题。\n\nD. 通过将两条 Kaplan–Meier 曲线在 $36$ 个月后线性外推至 $0$ 来估计和比较平均生存时间，因为曲线下面积可以估计平均生存时间，而线性外推提供了一种简单的尾部补全方法。\n\nE. 比较各组的第 $25$ 百分位生存时间（即 $25\\%$ 的参与者发生事件的时间），因为两条曲线都在 $36$ 个月内跨越了 $0.75$，使得在这种情况下较低的分位数成为中位数的更好替代品。",
            "solution": "这个问题考察的是当由于删失导致无法从 Kaplan–Meier 曲线中估计一个或多个组的中位数时，如何总结和比较生存分布的理解。\n\n关键情况是，T组的估计生存概率 $\\hat{S}_T(t)$ 在 $36$ 个月的随访期内从未降至或低于 $0.5$。这意味着T组的中位生存时间大于 $36$ 个月，但无法根据现有数据精确估计。正式地说，中位数是“未达到”。\n\n让我们评估每个选项：\n\nA. 错误。用最后的随访时间（$36$ 个月）代替中位数是一种没有统计学依据的临时插补方法。真实的中位数可能是 $36.1$ 个月或 $100$ 个月。这种方法武断地设定了数值，会导致对差异的估计不正确且有偏。\n\nB. 正确。该选项正确地指出T组的中位数无法从数据中估计。然后它提出了两种标准的、科学合理的替代方案。限制性平均生存时间 (RMST) 是截至指定时间点 $\\tau$ （此处为 $\\tau=36$ 个月）的预期生存时间。它计算为从 $0$ 到 $\\tau$ 的生存曲线下的面积，即 $\\int_0^\\tau S(t) dt$。两组之间 RMST 的差异是在时间窗口 $[0, \\tau]$ 内治疗效果的一个稳健且具有临床可解释性的度量。它不要求达到中位数。比较特定时间点（例如，1年、2年、3年生存率）的生存概率也是一种总结组间非参数差异的标准且有效的方法。\n\nC. 错误。虽然拟合 Cox 模型并报告风险比 (HR) 是分析生存数据的常用方法，但它不是问题所要求的对生存曲线的*非参数总结*。Cox 模型是半参数模型，并且依赖于可能不成立的比例风险假设。HR 是一种相对效应度量，而问题最初的计划是报告时间上的差异（中位数），这表明对绝对度量感兴趣。RMST 提供了时间上的绝对差异，使其成为中位数差异更直接的替代方案。\n\nD. 错误。将生存曲线外推到观测数据范围之外是高度推测性的，并且依赖于假设。线性外推尤其简单幼稚，不太可能反映生存分布的真实尾部行为。这可能导致对估计的平均生存时间的严重偏倚。\n\nE. 错误。比较一个较低的分位数，如第25百分位数（即25%的患者发生事件的时间，此时生存率为 $0.75$），是一种有效的比较方法。然而，它不是*最佳*的解释或总结。它丢弃了第25百分位数之后发生的情况的信息，可能无法捕捉到治疗效果的全部范围，而治疗效果可能在后期变得更加显著。相比之下，RMST 总结了整个选定窗口内的生存经验，通常是比单个分位数更全面的总结度量。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}