{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的巩固方式就是通过计算来亲身体验。这个练习将引导你从一个具体的流行病学场景出发，在给定未暴露组基线风险（$p_0$）和风险比（$RR$）的情况下，计算出对应的优势比（$OR$）。通过直接比较 $OR$ 和 $RR$ 的数值，你将量化 $OR$ 对 $RR$ 的高估程度，从而初步理解这两种效应度量指标之间的重要差异。",
            "id": "4645154",
            "problem": "一位研究者正在研究两组人群（暴露组和非暴露组）中的一个二元健康结局。设非暴露组的风险为 $p_{0}$，暴露组的风险为 $p_{1}$。风险比 (RR) 定义为 $\\mathrm{RR} = \\frac{p_{1}}{p_{0}}$，比值比 (OR) 定义为 $\\mathrm{OR} = \\frac{\\frac{p_{1}}{1 - p_{1}}}{\\frac{p_{0}}{1 - p_{0}}}$。假设一个乘法风险模型，即暴露通过一个恒定因子来缩放风险，意味着 $p_{1} = \\mathrm{RR} \\cdot p_{0}$。\n\n从这些定义出发，在乘法风险模型下，推导用 $\\mathrm{RR}$ 和 $p_{0}$ 表示 $\\mathrm{OR}$ 的解析表达式。然后，在 $p_{0} = 0.05$ 和 $\\mathrm{RR} = 3$ 的条件下，计算 $\\mathrm{OR}$ 的数值。最后，量化 $\\mathrm{OR}$ 相对于 $\\mathrm{RR}$ 的百分比夸大程度 $E$，其定义为小数形式\n$$E = \\frac{\\mathrm{OR} - \\mathrm{RR}}{\\mathrm{RR}},$$\n并给出其数值。将 $E$ 表示为小数（不带百分号）。将你的最终数值结果四舍五入到四位有效数字。",
            "solution": "该问题是有效的，因为它在流行病学原理上有科学依据，问题阐述清晰，客观且内部一致。\n\n第一步是推导用风险比 ($\\mathrm{RR}$) 和非暴露组的基线风险 ($p_{0}$) 来表示比值比 ($\\mathrm{OR}$) 的解析表达式。比值比的定义如下：\n$$ \\mathrm{OR} = \\frac{\\frac{p_{1}}{1 - p_{1}}}{\\frac{p_{0}}{1 - p_{0}}} $$\n其中 $p_{1}$ 是暴露组的风险。这可以重新整理为：\n$$ \\mathrm{OR} = \\frac{p_{1}(1 - p_{0})}{p_{0}(1 - p_{1})} $$\n问题陈述了一个乘法风险模型，其中暴露组的风险由 $p_{1} = \\mathrm{RR} \\cdot p_{0}$ 给出。我们将这个 $p_{1}$ 的表达式代入 $\\mathrm{OR}$ 的方程中：\n$$ \\mathrm{OR} = \\frac{(\\mathrm{RR} \\cdot p_{0})(1 - p_{0})}{p_{0}(1 - \\mathrm{RR} \\cdot p_{0})} $$\n分子和分母中的 $p_{0}$ 项可以消去，前提是 $p_{0} \\neq 0$。鉴于 $p_0=0.05$，此条件成立。\n$$ \\mathrm{OR} = \\frac{\\mathrm{RR}(1 - p_{0})}{1 - \\mathrm{RR} \\cdot p_{0}} $$\n这就是所要求的用 $\\mathrm{RR}$ 和 $p_{0}$ 表示 $\\mathrm{OR}$ 的解析表达式。该公式表明，$\\mathrm{OR}$ 等于 $\\mathrm{RR}$ 乘以因子 $\\frac{1 - p_{0}}{1 - p_{1}}$。\n\n接下来，我们需要在给定 $p_{0} = 0.05$ 和 $\\mathrm{RR} = 3$ 的情况下计算 $\\mathrm{OR}$ 的数值。我们首先计算暴露组的风险 $p_{1}$：\n$$ p_{1} = \\mathrm{RR} \\cdot p_{0} = 3 \\cdot 0.05 = 0.15 $$\n这是一个有效的概率，因为它介于 $0$ 和 $1$ 之间。现在，我们将 $\\mathrm{RR}$ 和 $p_{0}$ 的值代入我们推导出的 $\\mathrm{OR}$ 表达式中：\n$$ \\mathrm{OR} = \\frac{3(1 - 0.05)}{1 - 3 \\cdot 0.05} = \\frac{3(0.95)}{1 - 0.15} = \\frac{2.85}{0.85} $$\n为了找到精确值，我们可以用分数进行计算：\n$$ \\mathrm{OR} = \\frac{2.85}{0.85} = \\frac{285}{85} = \\frac{57 \\cdot 5}{17 \\cdot 5} = \\frac{57}{17} $$\n作为小数，这大约是 $3.352941...$。四舍五入到四位有效数字，我们得到：\n$$ \\mathrm{OR} \\approx 3.353 $$\n\n最后，我们需要计算 $\\mathrm{OR}$ 相对于 $\\mathrm{RR}$ 的相对夸大程度 $E$。其定义如下：\n$$ E = \\frac{\\mathrm{OR} - \\mathrm{RR}}{\\mathrm{RR}} $$\n使用 $\\mathrm{OR} = \\frac{57}{17}$ 和 $\\mathrm{RR} = 3$ 的精确值：\n$$ E = \\frac{\\frac{57}{17} - 3}{3} = \\frac{\\frac{57}{17} - \\frac{51}{17}}{3} = \\frac{\\frac{6}{17}}{3} = \\frac{6}{17 \\cdot 3} = \\frac{2}{17} $$\n作为小数，这大约是 $0.117647...$。四舍五入到四位有效数字，我们得到：\n$$ E \\approx 0.1176 $$\n这表明，对于 $5\\%$ 的基线风险，$3.353$ 的比值比大约高估了真实风险比 $3$ 约 $11.76\\%$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3.353  0.1176\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在第一个练习中，我们看到了在特定条件下 $OR$ 如何高估 $RR$。现在，让我们从具体计算走向普适的理论。这个练习要求你推导出一个表示近似误差的通用公式，该公式仅用基线风险 $p_0$ 和风险比 $RR$ 来表达。这个推导过程将揭示近似误差的数学本质，并从根本上解释为何在“罕见病假设”下，$OR$ 可以作为 $RR$ 的一个良好近似。",
            "id": "4645201",
            "problem": "在一项关于非传染性疾病的前瞻性队列研究中，设 $p_{0}$ 表示非暴露组中出现结局的概率，$p_{1}$ 表示暴露组中出现结局的概率。风险比 (RR) 定义为 $\\mathrm{RR} = \\frac{p_{1}}{p_{0}}$，比值比 (OR) 定义为 $\\mathrm{OR} = \\frac{\\frac{p_{1}}{1 - p_{1}}}{\\frac{p_{0}}{1 - p_{0}}}$。仅使用这些核心定义，推导使用比值比近似风险比的相对误差（定义为 $\\frac{\\mathrm{OR}}{\\mathrm{RR}} - 1$）的闭式表达式，该表达式仅用 $p_{0}$ 和 $\\mathrm{RR}$ 表示。你的最终答案必须是一个单一的解析表达式。无需进行数值计算，也无需四舍五入。在你的推导过程中，请简要地将你的表达式与当 $p_{0} \\to 0$ 且 $\\mathrm{RR}$ 保持不变时，近似误差的行为联系起来。",
            "solution": "经评估，该问题陈述具有科学依据、提法恰当、客观且自洽。所提供的风险比（$\\mathrm{RR}$）和比值比（$\\mathrm{OR}$）的定义在流行病学和生物统计学中是标准的。该任务是基于这些定义的形式化数学推导。因此，该问题是有效的，我们可以继续进行解答。\n\n设 $p_{0}$ 为非暴露组中出现结局的概率，$p_{1}$ 为暴露组中出现结局的概率。风险比（$\\mathrm{RR}$）和比值比（$\\mathrm{OR}$）定义如下：\n$$\n\\mathrm{RR} = \\frac{p_{1}}{p_{0}}\n$$\n$$\n\\mathrm{OR} = \\frac{\\frac{p_{1}}{1 - p_{1}}}{\\frac{p_{0}}{1 - p_{0}}}\n$$\n目标是推导使用 $\\mathrm{OR}$ 近似 $\\mathrm{RR}$ 的相对误差（定义为 $\\frac{\\mathrm{OR}}{\\mathrm{RR}} - 1$）的表达式。最终表达式必须只用 $p_{0}$ 和 $\\mathrm{RR}$ 表示。\n\n首先，我们通过代入给定的定义来简化比率 $\\frac{\\mathrm{OR}}{\\mathrm{RR}}$。\n$$\n\\frac{\\mathrm{OR}}{\\mathrm{RR}} = \\frac{\\left( \\frac{p_{1}}{1 - p_{1}} \\cdot \\frac{1 - p_{0}}{p_{0}} \\right)}{\\left( \\frac{p_{1}}{p_{0}} \\right)}\n$$\n我们可以重新排列各项并消去公因式：\n$$\n\\frac{\\mathrm{OR}}{\\mathrm{RR}} = \\frac{p_{1}}{1 - p_{1}} \\cdot \\frac{1 - p_{0}}{p_{0}} \\cdot \\frac{p_{0}}{p_{1}}\n$$\n分子和分母中的项 $p_{0}$ 可以消去，项 $p_{1}$ 也是如此。化简后得到：\n$$\n\\frac{\\mathrm{OR}}{\\mathrm{RR}} = \\frac{1 - p_{0}}{1 - p_{1}}\n$$\n目标是仅用 $p_{0}$ 和 $\\mathrm{RR}$ 来表示这个量。我们有一个包含 $p_{0}$ 和 $p_{1}$ 的表达式。我们必须消去 $p_{1}$。根据风险比的定义 $\\mathrm{RR} = \\frac{p_{1}}{p_{0}}$，我们可以用 $p_{0}$ 和 $\\mathrm{RR}$ 来表示 $p_{1}$：\n$$\np_{1} = \\mathrm{RR} \\cdot p_{0}\n$$\n现在，将这个 $p_{1}$ 的表达式代入我们简化的 $\\frac{\\mathrm{OR}}{\\mathrm{RR}}$ 公式中：\n$$\n\\frac{\\mathrm{OR}}{\\mathrm{RR}} = \\frac{1 - p_{0}}{1 - (\\mathrm{RR} \\cdot p_{0})}\n$$\n该表达式现在已经是用所要求的变量表示了。我们可以继续计算相对误差。\n$$\n\\text{相对误差} = \\frac{\\mathrm{OR}}{\\mathrm{RR}} - 1 = \\frac{1 - p_{0}}{1 - \\mathrm{RR} \\cdot p_{0}} - 1\n$$\n为了简化这个表达式，我们通分：\n$$\n\\frac{\\mathrm{OR}}{\\mathrm{RR}} - 1 = \\frac{(1 - p_{0}) - (1 - \\mathrm{RR} \\cdot p_{0})}{1 - \\mathrm{RR} \\cdot p_{0}}\n$$\n展开分子：\n$$\n\\frac{\\mathrm{OR}}{\\mathrm{RR}} - 1 = \\frac{1 - p_{0} - 1 + \\mathrm{RR} \\cdot p_{0}}{1 - \\mathrm{RR} \\cdot p_{0}}\n$$\n分子中的常数项相互抵消：\n$$\n\\frac{\\mathrm{OR}}{\\mathrm{RR}} - 1 = \\frac{\\mathrm{RR} \\cdot p_{0} - p_{0}}{1 - \\mathrm{RR} \\cdot p_{0}}\n$$\n从分子中提取公因式 $p_{0}$，得到相对误差的最终闭式表达式：\n$$\n\\frac{\\mathrm{OR}}{\\mathrm{RR}} - 1 = \\frac{p_{0}(\\mathrm{RR} - 1)}{1 - \\mathrm{RR} \\cdot p_{0}}\n$$\n这个表达式表明，相对误差同时取决于基线风险 $p_{0}$ 和风险比 $\\mathrm{RR}$ 的大小。\n\n最后，我们分析当 $p_{0} \\to 0$ 且 $\\mathrm{RR}$ 保持不变时，此误差的行为。这种情况对应于罕见病的研究，即非暴露人群中出现结局的概率非常小。我们对相对误差表达式求极限：\n$$\n\\lim_{p_{0} \\to 0} \\left( \\frac{p_{0}(\\mathrm{RR} - 1)}{1 - \\mathrm{RR} \\cdot p_{0}} \\right) = \\frac{0 \\cdot (\\mathrm{RR} - 1)}{1 - \\mathrm{RR} \\cdot 0} = \\frac{0}{1} = 0\n$$\n当 $p_{0}$ 趋近于 $0$ 时，相对误差表达式的分子趋近于 $0$，而分母趋近于 $1$。因此，整个表达式趋近于 $0$。这个结果表明，当疾病罕见时（即 $p_{0}$ 很小），相对误差也非常小。因此，比值比（$\\mathrm{OR}$）可以作为风险比（$\\mathrm{RR}$）的一个非常好的近似。这在流行病学中通常被称为“罕见病假设”，它为使用来自病例-对照研究的比值比作为本可以从队列研究中获得的风险比的估计值提供了理由。对于小的 $p_0$，误差约等于 $p_{0}(\\mathrm{RR} - 1)$，这表明它大致与基线风险成正比。",
            "answer": "$$\n\\boxed{\\frac{p_{0}(\\mathrm{RR} - 1)}{1 - p_{0} \\cdot \\mathrm{RR}}}\n$$"
        },
        {
            "introduction": "我们已经通过理论推导理解了近似误差的来源，现在是时候通过模拟数据来“眼见为实”了。这个练习提供了一系列具有不同基线风险的亚组队列数据，你需要为每个亚组计算 $RR$ 和 $OR$，并评估其近似误差。通过观察误差如何随基线风险的增加而系统性地变化，你将对“罕见病假设”的实际应用门槛和 $OR$ 作为 $RR$ 近似的局限性有更深刻、更直观的认识。",
            "id": "4645133",
            "problem": "给定一个大型队列，该队列被细分为多个独立的亚组，每个亚组由一个 $2 \\times 2$ 计数表表示，表中包含了按患病状态分类的暴露和未暴露个体。请使用风险 (risk) 和比值 (odds) 的基本定义，计算每个亚组的风险比 (RR) 和比值比 (OR)，并根据基线风险的变化，凭经验评估比值比在多大程度上近似于风险比。\n\n用作基本依据的定义：\n- 对于任何患病概率为 $p$ 的组，将比值 (odds) 定义为 $p/(1 - p)$。\n- 设暴露组有 $a$ 个病例和 $b$ 个非病例，未暴露组有 $c$ 个病例和 $d$ 个非病例。暴露组的风险为 $p_1 = a/(a + b)$，未暴露组的基线风险为 $p_0 = c/(c + d)$。\n\n任务：\n1. 对于每个亚组，使用 $p_1$ 和 $p_0$ 计算风险比 (RR)，并使用从上述定义中推导出的暴露组和未暴露组的比值来计算比值比 (OR)。\n2. 对于每个亚组，计算 $OR$ 和 $RR$ 之间的绝对相对误差，其定义为 $|OR - RR|/RR$，并将结果四舍五入到 $6$ 位小数。\n3. 使用固定的可接受性阈值 $T = 0.1$，为每个亚组确定其近似是否可接受，即 $|OR - RR|/RR \\leq T$ 是否成立。\n4. 凭经验验证近似误差是否随着各亚组基线风险 $p_0$ 的增加而单调非递减。这需要检查当亚组按 $p_0$ 递增排序时，绝对相对误差序列在任何一步都不会减小。\n\n测试套件（每个亚组由 $(a,b,c,d)$ 指定，按 $p_0$ 递增的顺序排列）：\n- 亚组 $1$：$(a,b,c,d) = (200, 99800, 100, 99900)$，对应于 $p_0 = 100/100000 = 0.001$ 和一个包含 $100000$ 名暴露个体及 $100000$ 名未暴露个体的大型队列。\n- 亚组 $2$：$(a,b,c,d) = (200, 9800, 100, 9900)$，对应于 $p_0 = 100/10000 = 0.01$ 和一个包含 $10000$ 名暴露个体及 $10000$ 名未暴露个体的大型队列。\n- 亚组 $3$：$(a,b,c,d) = (1000, 9000, 500, 9500)$，对应于 $p_0 = 500/10000 = 0.05$ 和一个包含 $10000$ 名暴露个体及 $10000$ 名未暴露个体的大型队列。\n- 亚组 $4$：$(a,b,c,d) = (2000, 8000, 1000, 9000)$，对应于 $p_0 = 1000/10000 = 0.1$ 和一个包含 $10000$ 名暴露个体及 $10000$ 名未暴露个体的大型队列。\n- 亚组 $5$：$(a,b,c,d) = (4000, 6000, 2000, 8000)$，对应于 $p_0 = 2000/10000 = 0.2$ 和一个包含 $10000$ 名暴露个体及 $10000$ 名未暴露个体的大型队列。\n- 亚组 $6$：$(a,b,c,d) = (8000, 2000, 4000, 6000)$，对应于 $p_0 = 4000/10000 = 0.4$ 和一个包含 $10000$ 名暴露个体及 $10000$ 名未暴露个体的大型队列。\n\n您的程序应计算所有亚组的绝对相对误差，使用 $T = 0.1$ 确定每个亚组的可接受性，并评估误差相对于递增的 $p_0$ 的单调性。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其结构如下：\n- 第一个元素是各亚组的绝对相对误差列表，四舍五入到 $6$ 位小数。\n- 第二个元素是一个布尔值列表，指示每个亚组的近似是否可接受（使用 $T = 0.1$）。\n- 第三个元素是一个单一的布尔值，指示在排序后的亚组中，绝对相对误差是否随 $p_0$ 单调非递减。\n\n例如，输出应类似于 $[[e_1,e_2,e_3,e_4,e_5,e_6],[b_1,b_2,b_3,b_4,b_5,b_6],m]$，其中每个 $e_i$ 是一个四舍五入到 $6$ 位小数的浮点数，每个 $b_i$ 是一个布尔值，$m$ 也是一个布尔值。",
            "solution": "该问题被评估为有效。它在科学上植根于流行病学原理，问题阐述清晰，具有完整且一致的数据和定义，并且其表述是客观的。任务定义明确，并能导出一个唯一的、可验证的解决方案。\n\n该问题要求使用来自多个亚组的数据，对风险比 ($RR$) 和比值比 ($OR$) 之间的关系进行实证研究。我们将从提供的基本定义中推导出必要的公式，并将其应用于给定的测试套件。\n\n一个 $2 \\times 2$ 列联表总结了每个亚组的数据，其中包含暴露和未暴露人群中病例和非病例的计数。设这些计数为：\n- $a$：暴露组中的病例数。\n- $b$：暴露组中的非病例数。\n- $c$：未暴露组中的病例数。\n- $d$：未暴露组中的非病例数。\n\n暴露组的总人数为 $N_1 = a + b$，未暴露组的总人数为 $N_0 = c + d$。\n\n根据提供的定义：\n- 暴露组的风险（患病概率）为 $p_1 = a / (a + b)$。\n- 未暴露组的风险（基线风险）为 $p_0 = c / (c + d)$。\n\n**任务1：计算风险比 (RR) 和比值比 (OR)**\n\n风险比 ($RR$) 是暴露组风险与未暴露组风险的比值。\n$$RR = \\frac{p_1}{p_0} = \\frac{a / (a + b)}{c / (c + d)}$$\n\n对于任何患病概率为 $p$ 的组，其比值 (odds) 定义为 $O = p / (1 - p)$。\n暴露组的患病比值为：\n$$O_1 = \\frac{p_1}{1 - p_1} = \\frac{a / (a + b)}{1 - a / (a + b)} = \\frac{a / (a + b)}{b / (a + b)} = \\frac{a}{b}$$\n未暴露组的患病比值为：\n$$O_0 = \\frac{p_0}{1 - p_0} = \\frac{c / (c + d)}{1 - c / (c + d)} = \\frac{c / (c + d)}{d / (c + d)} = \\frac{c}{d}$$\n\n比值比 ($OR$) 是这两个比值的比率。\n$$OR = \\frac{O_1}{O_0} = \\frac{a / b}{c / d} = \\frac{ad}{bc}$$\n这就是众所周知的 $OR$ 的交叉乘积公式。\n\n$OR$ 和 $RR$ 之间的关系可以表示为：\n$$OR = \\frac{ad}{bc} = \\frac{a}{c} \\frac{d}{b} = \\frac{a/(a+b)}{c/(c+d)} \\cdot \\frac{d/(c+d)}{b/(a+b)} = RR \\cdot \\frac{1 - p_0}{1 - p_1}$$\n这个方程表明，当因子 $(1 - p_0) / (1 - p_1)$ 接近 $1$ 时，$OR$ 近似于 $RR$。这种情况发生在 $p_1$ 和 $p_0$ 都很小的时候，这个条件通常被称为“罕见病假设”。随着基线风险 $p_0$（以及在给定 $RR > 1$ 的情况下的 $p_1$）的增加，近似的精确度会下降。\n\n**任务2和3：计算绝对相对误差并评估可接受性**\n\n绝对相对误差 $E$ 定义为：\n$$E = \\frac{|OR - RR|}{RR}$$\n如果 $E \\leq T$（其中阈值 $T = 0.1$），则认为近似是可接受的。\n\n现在我们将这些公式应用于提供的测试套件。\n\n**亚组 1：** $(a,b,c,d) = (200, 99800, 100, 99900)$\n- $p_1 = 200 / (200 + 99800) = 0.002$\n- $p_0 = 100 / (100 + 99900) = 0.001$\n- $RR = 0.002 / 0.001 = 2.0$\n- $OR = (200 \\times 99900) / (99800 \\times 100) \\approx 2.002004$\n- $E_1 = |2.002004 - 2.0| / 2.0 \\approx 0.001002$。四舍五入到6位小数，结果是 $0.001002$。\n- 可接受性：$0.001002 \\leq 0.1$，即 `True`。\n\n**亚组 2：** $(a,b,c,d) = (200, 9800, 100, 9900)$\n- $p_1 = 200 / (200 + 9800) = 0.02$\n- $p_0 = 100 / (100 + 9900) = 0.01$\n- $RR = 0.02 / 0.01 = 2.0$\n- $OR = (200 \\times 9900) / (9800 \\times 100) \\approx 2.020408$\n- $E_2 = |2.020408 - 2.0| / 2.0 \\approx 0.010204$。四舍五入到6位小数，结果是 $0.010204$。\n- 可接受性：$0.010204 \\leq 0.1$，即 `True`。\n\n**亚组 3：** $(a,b,c,d) = (1000, 9000, 500, 9500)$\n- $p_1 = 1000 / (1000 + 9000) = 0.1$\n- $p_0 = 500 / (500 + 9500) = 0.05$\n- $RR = 0.1 / 0.05 = 2.0$\n- $OR = (1000 \\times 9500) / (9000 \\times 500) = 95/45 \\approx 2.111111$\n- $E_3 = |2.111111 - 2.0| / 2.0 \\approx 0.055556$。四舍五入到6位小数，结果是 $0.055556$。\n- 可接受性：$0.055556 \\leq 0.1$，即 `True`。\n\n**亚组 4：** $(a,b,c,d) = (2000, 8000, 1000, 9000)$\n- $p_1 = 2000 / (2000 + 8000) = 0.2$\n- $p_0 = 1000 / (1000 + 9000) = 0.1$\n- $RR = 0.2 / 0.1 = 2.0$\n- $OR = (2000 \\times 9000) / (8000 \\times 1000) = 18/8 = 2.25$\n- $E_4 = |2.25 - 2.0| / 2.0 = 0.125$。四舍五入到6位小数，结果是 $0.125000$。\n- 可接受性：$0.125000 \\leq 0.1$，即 `False`。\n\n**亚组 5：** $(a,b,c,d) = (4000, 6000, 2000, 8000)$\n- $p_1 = 4000 / (4000 + 6000) = 0.4$\n- $p_0 = 2000 / (2000 + 8000) = 0.2$\n- $RR = 0.4 / 0.2 = 2.0$\n- $OR = (4000 \\times 8000) / (6000 \\times 2000) = 32/12 \\approx 2.666667$\n- $E_5 = |2.666667 - 2.0| / 2.0 \\approx 0.333333$。四舍五入到6位小数，结果是 $0.333333$。\n- 可接受性：$0.333333 \\leq 0.1$，即 `False`。\n\n**亚组 6：** $(a,b,c,d) = (8000, 2000, 4000, 6000)$\n- $p_1 = 8000 / (8000 + 2000) = 0.8$\n- $p_0 = 4000 / (4000 + 6000) = 0.4$\n- $RR = 0.8 / 0.4 = 2.0$\n- $OR = (8000 \\times 6000) / (2000 \\times 4000) = 48/8 = 6.0$\n- $E_6 = |6.0 - 2.0| / 2.0 = 2.0$。四舍五入到6位小数，结果是 $2.000000$。\n- 可接受性：$2.000000 \\leq 0.1$，即 `False`。\n\n**任务4：验证单调性**\n\n我们检查与按基线风险 $p_0$ 递增排序的亚组相对应的绝对相对误差序列 $E_1, E_2, \\ldots, E_6$。\n误差序列为：\n$E = [0.001002, 0.010204, 0.055556, 0.125000, 0.333333, 2.000000]$\n\n我们检查对于所有从 $1$ 到 $5$ 的 $i$，$E_i \\leq E_{i+1}$ 是否成立：\n- $E_1 (0.001002) \\leq E_2 (0.010204)$: True\n- $E_2 (0.010204) \\leq E_3 (0.055556)$: True\n- $E_3 (0.055556) \\leq E_4 (0.125000)$: True\n- $E_4 (0.125000) \\leq E_5 (0.333333)$: True\n- $E_5 (0.333333) \\leq E_6 (2.000000)$: True\n\n由于该条件在所有步骤中都成立，因此误差随着基线风险 $p_0$ 的增加而单调非递减。前面提到的解析关系 $OR = RR \\cdot (1-p_0)/(1-p_1)$ 支持这一经验性发现：随着基线风险 $p_0$ 的增加，偏差因子 $(1-p_0)/(1-p_1)$ 会进一步偏离 $1$，从而增大了误差。\n\n**最终汇总结果**：\n- 绝对相对误差列表：$[0.001002, 0.010204, 0.055556, 0.125000, 0.333333, 2.000000]$\n- 可接受性布尔值列表：$[True, True, True, False, False, False]$\n- 单调性检查：`True`",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes RR, OR, and the approximation error for a series of subgroups,\n    and verifies the monotonicity of the error with baseline risk.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (a, b, c, d)\n    test_cases = [\n        (200, 99800, 100, 99900),  # p0 = 0.001\n        (200, 9800, 100, 9900),     # p0 = 0.01\n        (1000, 9000, 500, 9500),   # p0 = 0.05\n        (2000, 8000, 1000, 9000),  # p0 = 0.1\n        (4000, 6000, 2000, 8000),  # p0 = 0.2\n        (8000, 2000, 4000, 6000)    # p0 = 0.4\n    ]\n\n    T = 0.1\n    errors = []\n    acceptability = []\n\n    for case in test_cases:\n        a, b, c, d = case\n\n        # Ensure all inputs are converted to float for division\n        a, b, c, d = float(a), float(b), float(c), float(d)\n\n        # Basic check for invalid counts, although not present in the test data\n        if (a + b) == 0 or (c + d) == 0 or b == 0 or c == 0 or d == 0:\n            # Handle division by zero cases if they were to occur\n            # For this problem's data, this block is not reached.\n            # Depending on the convention, could be NaN, infinity, or an error.\n            # Skipping for this specific problem.\n            continue\n        \n        # Calculate risks\n        p1 = a / (a + b)\n        p0 = c / (c + d)\n\n        # Calculate Risk Ratio (RR)\n        if p0 == 0:\n            # Handle division by zero for RR calculation\n            # Not reached with current data\n            continue\n        rr = p1 / p0\n\n        # Calculate Odds Ratio (OR)\n        # Formula is (a*d) / (b*c)\n        or_val = (a * d) / (b * c)\n        \n        # Calculate absolute relative error\n        if rr == 0:\n             # Handle division by zero for error calculation\n             # Not reached with current data\n            continue\n        error = abs(or_val - rr) / rr\n        errors.append(error)\n        \n        # Determine acceptability\n        is_acceptable = error = T\n        acceptability.append(is_acceptable)\n    \n    # Verify if the error is monotonically non-decreasing\n    # The condition is errors[i] = errors[i+1] for all valid i\n    is_monotonic = all(errors[i] = errors[i+1] for i in range(len(errors) - 1))\n\n    # Format the final output string as specified\n    # The first list contains errors rounded to 6 decimal places.\n    # The second list contains the boolean acceptability results.\n    # The third element is the single boolean for monotonicity.\n    errors_str_list = [f\"{e:.6f}\" for e in errors]\n    errors_part = f\"[[{','.join(errors_str_list)}]]\"\n    \n    acceptability_str_list = [str(b).lower() for b in acceptability] # Use lower() for 'true'/'false'\n    acceptability_part = f\"[{','.join(acceptability_str_list)}]\"\n    \n    monotonicity_part = str(is_monotonic).lower()\n    \n    # Per example output format [[e1,...],[b1,...],m]\n    final_output_str = f\"[{errors_part},{acceptability_part},{monotonicity_part}]\"\n\n    # The problem description's example output shows Python's default `True/False` capitalization\n    # Let's revert to that for maximum compliance.\n    acceptability_str_list = [str(b) for b in acceptability]\n    acceptability_part = f\"[{','.join(acceptability_str_list)}]\"\n    monotonicity_part = str(is_monotonic)\n    final_output_str = f\"[{errors_part},{acceptability_part},{monotonicity_part}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}