{
    "hands_on_practices": [
        {
            "introduction": "流行病学研究的精髓在于将理论应用于实践。本章提供了一系列动手实践练习，旨在通过计算和批判性思维，巩固您对传染性、致病性和毒力等核心概念的理解。这些练习将引导您从构建传播模型，到识别和量化测量偏差，再到应用高级统计方法来获得更准确的估计。\n\n平均传染性（如基本再生数 $R$）并不能完全描绘疫情传播的全貌。本练习  探讨了传播异质性的概念，即少数感染者可能导致绝大多数的二次传播。我们将通过一个数学模型来探究这种“超级传播”现象是如何产生的，以及在平均二次感染人数不变的情况下，它如何影响疫情爆发的动态。",
            "id": "4602129",
            "problem": "在一个离散时间的 Galton-Watson 分支过程中，假设每个感染个体在下一代中独立产生随机数量 $X$ 的二代感染。传染性的异质性通过引入一个潜在的个体传播率 $\\Lambda$ 来建模，其中在给定 $\\Lambda$ 的条件下，有 $X \\mid \\Lambda \\sim \\text{Poisson}(\\Lambda)$，并且在不同个体之间 $\\Lambda$ 是独立同分布的。假设以下基本设定：\n- 条件泊松机制：对于 $x \\in \\{0,1,2,\\dots\\}$，$P(X=x \\mid \\Lambda=\\lambda) = e^{-\\lambda} \\lambda^{x} / x!$。\n- Gamma 异质性机制：$\\Lambda \\sim \\text{Gamma}(\\text{形状}=k, \\text{尺度}=\\theta)$，其密度函数为 $f_{\\Lambda}(\\lambda) = \\lambda^{k-1} e^{-\\lambda/\\theta} / (\\Gamma(k)\\,\\theta^{k})$，对于 $\\lambda>0$。\n- 平均传染性约束：选择尺度 $\\theta$ 使得 $\\mathbb{E}[\\Lambda] = R$，其中 $R>0$ 是每个感染个体的平均二代感染数。\n\n仅使用这些设定，推导出用 $R$ 和 $k$ 表示的 $X$ 的诱导子代分布，并论证当 $R$ 保持固定时，改变 $k$ 如何影响疫情爆发的变异性。然后选择唯一一个选项，该选项正确给出了 $X$ 的概率质量函数（包括其定义域），正确陈述了其均值和方差，并正确地定性解释了在不改变平均传染性的情况下，减小 $k$ 如何影响疫情爆发的变异性。\n\nA. 对于 $x \\in \\{0,1,2,\\dots\\}$，$P(X=x) = \\dfrac{\\Gamma(x+k)}{\\Gamma(k)\\,x!} \\left(\\dfrac{k}{k+R}\\right)^{k} \\left(\\dfrac{R}{k+R}\\right)^{x}$；$\\mathbb{E}[X]=R$ 且 $\\mathrm{Var}(X)=R+R^{2}/k$。减小 $k$（在固定的 $R$ 下）会增加 $X$ 的方差，产生更多的零膨胀和更重的右尾（超级传播），这使得疫情爆发更具变异性：当 $R \\lesssim 1$ 时，早期灭绝的可能性更大，并且在存活的条件下，大规模爆发的规模变得更有可能，而平均传染性保持为 $\\mathbb{E}[X]=R$。",
            "solution": "题目要求在一个传染性具有异质性的 Galton-Watson 过程中推导子代分布 $X$。这是一个泊松-伽马混合模型的设定。我们必须找到 $X$ 的概率质量函数（PMF）、其均值和方差，并分析异质性参数 $k$ 的影响。\n\n首先，我们验证问题陈述的有效性。问题提供了一个清晰的分层模型：\n1.  $X \\mid \\Lambda \\sim \\text{Poisson}(\\Lambda)$，其 PMF 为 $P(X=x \\mid \\Lambda=\\lambda) = e^{-\\lambda} \\lambda^{x} / x!$，对于 $x \\in \\{0, 1, 2, \\ldots\\}$。\n2.  $\\Lambda \\sim \\text{Gamma}(k, \\theta)$，其 PDF 为 $f_{\\Lambda}(\\lambda) = \\lambda^{k-1} e^{-\\lambda/\\theta} / (\\Gamma(k)\\,\\theta^{k})$，对于 $\\lambda>0$。\n3.  一个约束 $\\mathbb{E}[\\Lambda] = R$，它将模型参数与基本再生数 $R$ 联系起来。\n\n对于形状为 $k$、尺度为 $\\theta$ 的 Gamma 分布，其均值为 $\\mathbb{E}[\\Lambda] = k\\theta$。约束 $\\mathbb{E}[\\Lambda] = R$ 意味着 $k\\theta = R$，因此尺度参数为 $\\theta = R/k$。对于 $R>0$ 和 $k>0$，这是一个定义良好的关系。该问题具有科学依据、是适定的、客观的，并包含得出唯一解所需的所有必要信息。问题陈述是有效的。\n\n我们接着推导 $X$ 的边际分布。$X$ 的 PMF，$P(X=x)$，是通过将给定 $\\Lambda$ 的 $X$ 的条件 PMF 对 $\\Lambda$ 的分布进行积分得到的。这是连续随机变量的全概率定律的应用：\n$$P(X=x) = \\int_{0}^{\\infty} P(X=x \\mid \\Lambda=\\lambda) f_{\\Lambda}(\\lambda) \\, d\\lambda$$\n代入给定的泊松分布的 PMF 和 Gamma 分布的 PDF：\n$$P(X=x) = \\int_{0}^{\\infty} \\left( \\frac{e^{-\\lambda} \\lambda^x}{x!} \\right) \\left( \\frac{\\lambda^{k-1} e^{-\\lambda/\\theta}}{\\Gamma(k) \\theta^k} \\right) d\\lambda$$\n我们可以将不依赖于 $\\lambda$ 的项移到积分符号外：\n$$P(X=x) = \\frac{1}{x! \\Gamma(k) \\theta^k} \\int_{0}^{\\infty} \\lambda^{x+k-1} e^{-\\lambda(1 + 1/\\theta)} d\\lambda$$\n该积分是与 Gamma 函数相关的标准形式。一个通用的 Gamma 积分为 $\\int_{0}^{\\infty} t^{a-1} e^{-ct} dt = \\Gamma(a)/c^a$。在我们的例子中，$\\lambda$ 的指数是 $(x+k)-1$，所以 $a = x+k$。指数中的系数是 $c = 1 + 1/\\theta = (1+\\theta)/\\theta$。\n因此，积分的计算结果为：\n$$\\int_{0}^{\\infty} \\lambda^{(x+k)-1} e^{-\\lambda \\left(\\frac{1+\\theta}{\\theta}\\right)} d\\lambda = \\frac{\\Gamma(x+k)}{\\left(\\frac{1+\\theta}{\\theta}\\right)^{x+k}} = \\Gamma(x+k) \\left(\\frac{\\theta}{1+\\theta}\\right)^{x+k}$$\n将此结果代回到 $P(X=x)$ 的表达式中：\n$$P(X=x) = \\frac{1}{x! \\Gamma(k) \\theta^k} \\Gamma(x+k) \\left(\\frac{\\theta}{1+\\theta}\\right)^{x+k}$$\n重新整理各项可得：\n$$P(X=x) = \\frac{\\Gamma(x+k)}{\\Gamma(k) x!} \\frac{1}{\\theta^k} \\frac{\\theta^{x+k}}{(1+\\theta)^{x+k}} = \\frac{\\Gamma(x+k)}{\\Gamma(k) x!} \\frac{\\theta^x}{(1+\\theta)^{x+k}}$$\n我们可以将其重写为：\n$$P(X=x) = \\frac{\\Gamma(x+k)}{\\Gamma(k) x!} \\left(\\frac{1}{1+\\theta}\\right)^k \\left(\\frac{\\theta}{1+\\theta}\\right)^x$$\n这是负二项分布的 PMF。现在我们代入 $\\theta = R/k$ 以用 $R$ 和 $k$ 表示 PMF：\n概率参数 $p$ 是 $\\frac{1}{1+\\theta} = \\frac{1}{1+R/k} = \\frac{k}{k+R}$。\n另一个概率参数 $1-p$ 是 $\\frac{\\theta}{1+\\theta} = \\frac{R/k}{1+R/k} = \\frac{R}{k+R}$。\n将这些代入 PMF 中：\n$$P(X=x) = \\frac{\\Gamma(x+k)}{\\Gamma(k) x!} \\left(\\frac{k}{k+R}\\right)^k \\left(\\frac{R}{k+R}\\right)^x \\quad \\text{for } x \\in \\{0, 1, 2, \\ldots\\}$$\n\n接下来，我们使用全期望定律和全方差定律计算 $X$ 的均值和方差。\n$X$ 的均值为：\n$$\\mathbb{E}[X] = \\mathbb{E}[\\mathbb{E}[X \\mid \\Lambda]]$$\n由于 $X \\mid \\Lambda \\sim \\text{Poisson}(\\Lambda)$，其条件均值为 $\\mathbb{E}[X \\mid \\Lambda] = \\Lambda$。\n因此，$\\mathbb{E}[X] = \\mathbb{E}[\\Lambda]$。根据问题的约束，$\\mathbb{E}[\\Lambda] = R$。所以，$\\mathbb{E}[X] = R$。\n\n$X$ 的方差为：\n$$\\mathrm{Var}(X) = \\mathbb{E}[\\mathrm{Var}(X \\mid \\Lambda)] + \\mathrm{Var}(\\mathbb{E}[X \\mid \\Lambda])$$\n对于泊松分布，方差等于均值，所以 $\\mathrm{Var}(X \\mid \\Lambda) = \\Lambda$。第一项是 $\\mathbb{E}[\\Lambda] = R$。\n第二项是 $\\mathrm{Var}(\\mathbb{E}[X \\mid \\Lambda]) = \\mathrm{Var}(\\Lambda)$。对于形状为 $k$、尺度为 $\\theta$ 的 Gamma 分布，其方差为 $\\mathrm{Var}(\\Lambda) = k\\theta^2$。代入 $\\theta = R/k$：\n$$\\mathrm{Var}(\\Lambda) = k \\left(\\frac{R}{k}\\right)^2 = k \\frac{R^2}{k^2} = \\frac{R^2}{k}$$\n合并这两项，$X$ 的方差为：\n$$\\mathrm{Var}(X) = R + \\frac{R^2}{k}$$\n这个表达式表明，子代分布的方差比其均值（$R$）大一个项 $R^2/k$，这被称为过度离散。\n\n最后，我们分析在保持 $R$ 固定的情况下减小 $k$ 的影响。参数 $k$ 是离散参数。\n方差为 $\\mathrm{Var}(X) = R + R^2/k$。由于 $R > 0$，项 $R^2/k$ 总是正的。随着 $k$ 减小，$R^2/k$ 增加，因此 $\\mathrm{Var}(X)$ 增加。在极限 $k \\to \\infty$ 时，$\\mathrm{Var}(X) \\to R$，这对应于同质情况 $X \\sim \\text{Poisson}(R)$。在极限 $k \\to 0^+$ 时，$\\mathrm{Var}(X) \\to \\infty$。\n对于固定的均值，较大的方差意味着分布更偏斜，具有更重的右尾。这对应于“超级传播”现象，即一小部分个体导致了大部分的二代感染。\n同时，为了保持均值 $R$，尾部增加的概率必须由低值（特别是 $X=0$）处增加的概率质量来平衡。零二代感染的概率是 $P(X=0) = (1+R/k)^{-k}$。当 $k \\to 0^+$ 时，$P(X=0) \\to 1$。因此，减小 $k$ 会导致更多的“零膨胀”。\n这种增加的变异性具有显著的流行病学后果。零子代的概率更高意味着病原体的许多引入将无法建立传播链，从而导致早期疫情灭绝的机会更高。然而，如果疫情确实得以确立（例如，通过超级传播事件），重尾意味着它有潜力爆炸性增长。因此，减小 $k$ 会增加疫情爆发结果的变异性。\n\n（编者注：原稿中的选项B、C、D因内容损坏已被移除，仅保留了正确的选项A。）\n我们评估选项A：\n\n**A. 对于 $x \\in \\{0,1,2,\\dots\\}$，$P(X=x) = \\dfrac{\\Gamma(x+k)}{\\Gamma(k)\\,x!} \\left(\\dfrac{k}{k+R}\\right)^{k} \\left(\\dfrac{R}{k+R}\\right)^{x}$；$\\mathbb{E}[X]=R$ 且 $\\mathrm{Var}(X)=R+R^{2}/k$。减小 $k$（在固定的 $R$ 下）会增加 $X$ 的方差，产生更多的零膨胀和更重的右尾（超级传播），这使得疫情爆发更具变异性：当 $R \\lesssim 1$ 时，早期灭绝的可能性更大，并且在存活的条件下，大规模爆发的规模变得更有可能，而平均传染性保持为 $\\mathbb{E}[X]=R$。**\n- PMF：这与我们推导的负二项分布的 PMF 相匹配。正确。\n- 均值和方差：$\\mathbb{E}[X]=R$ 和 $\\mathrm{Var}(X)=R+R^2/k$。两者都与我们的推导相符。正确。\n- 定性解释：这个解释准确地描述了减小 $k$ 对方差、分布形状（零膨胀、重尾/超级传播）以及流行病学后果（增加的疫情爆发变异性）的影响。正确。\n- 结论：**正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在探讨了传染性之后，我们转向毒力。准确测量毒力常常因数据收集方法的限制而充满挑战。本练习  模拟了一个常见情景：利用医院数据来估算病原体的毒力。通过具体计算，我们将揭示这种方法如何导致一种被称为“伯克森偏倚 (Berkson's bias)”的选择偏倚，它会显著高估病原体的真实严重性。",
            "id": "4602164",
            "problem": "在一项病原体监测研究中，使用基于医院的数据来估计毒力。此处，毒力定义为受感染个体中出现重症的概率，记为 $P(S=1 \\mid I=1)$。考虑一种在人群中传播的传染性病原体，受感染个体中存在共病指示变量 $C \\in \\{0,1\\}$。住院情况由 $H \\in \\{0,1\\}$ 表示。该研究仅招募经确诊感染的住院患者，因此是在 $I=1$ 和 $H=1$ 的条件下观察其严重程度。\n\n假设存在以下科学上合理的结构：\n- 在受感染个体中，共病的患病率为 $P(C=1 \\mid I=1) = 0.3$，$P(C=0 \\mid I=1) = 0.7$。\n- 基础毒力（受感染者中出现重症的概率）取决于共病情况：$P(S=1 \\mid I=1, C=1) = 0.4$，$P(S=1 \\mid I=1, C=0) = 0.1$。\n- 住院概率取决于严重程度和共病情况：$P(H=1 \\mid I=1, S=1, C=1) = 0.9$，$P(H=1 \\mid I=1, S=1, C=0) = 0.7$，$P(H=1 \\mid I=1, S=0, C=1) = 0.3$ 以及 $P(H=1 \\mid I=1, S=0, C=0) = 0.05$。\n\n请仅使用条件概率的基本定义、全概率定律和科学上一致的选择机制，首先推导出真实毒力 $P(S=1 \\mid I=1)$ 和基于医院的毒力 $P(S=1 \\mid I=1, H=1)$ 的表达式。然后，计算关于毒力的 Berkson 偏倚因子，定义为\n$$\nB \\equiv \\frac{P(S=1 \\mid I=1, H=1)}{P(S=1 \\mid I=1)}.\n$$\n解释：$B$ 值大于 $1$ 表示由于基于医院的选择（$H=1$）而导致向上偏倚，$B$ 值小于 $1$ 表示向下偏倚。\n\n报告 $B$ 的单个数值，并将您的答案四舍五入到四位有效数字。无需单位。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它以流行病学原理为科学基础，内部一致，问题良定，并包含推导唯一解所需的所有信息。该问题描述了一个经典的选择偏倚案例，特别是 Berkson 偏倚，它在以两个或多个独立或相关原因的共同效应（一个“对撞因子”）为条件时出现。在此，住院（$H$）是疾病严重程度（$S$）和共病（$C$）的对撞因子。\n\n目标是计算 Berkson 偏倚因子 $B$，其定义为基于医院的毒力与真实毒力之比：\n$$\nB \\equiv \\frac{P(S=1 \\mid I=1, H=1)}{P(S=1 \\mid I=1)}\n$$\n问题中提供的所有概率都是以个体被感染（$I=1$）为条件的。为了在推导过程中简化符号，我们将暂时省略对 $I=1$ 的显式条件，并理解为所有概率都是在受感染个体的子群体内计算的。偏倚因子的表达式变为：\n$$\nB = \\frac{P(S=1 \\mid H=1)}{P(S=1)}\n$$\n\n首先，我们计算分母，它代表真实毒力 $P(S=1 \\mid I=1)$，此处记为 $P(S=1)$。我们应用全概率定律，对共病状态 $C$ 进行边缘化：\n$$\nP(S=1) = P(S=1, C=1) + P(S=1, C=0)\n$$\n使用条件概率的定义 $P(A,B) = P(A \\mid B)P(B)$，我们得到：\n$$\nP(S=1) = P(S=1 \\mid C=1)P(C=1) + P(S=1 \\mid C=0)P(C=0)\n$$\n代入给定值：\n$$\nP(S=1) = (0.4)(0.3) + (0.1)(0.7) = 0.12 + 0.07 = 0.19\n$$\n因此，受感染人群中的真实毒力为 $0.19$。\n\n接下来，我们计算分子，即基于医院的毒力 $P(S=1 \\mid H=1)$。使用贝叶斯定理：\n$$\nP(S=1 \\mid H=1) = \\frac{P(S=1, H=1)}{P(H=1)}\n$$\n我们必须计算联合概率 $P(S=1, H=1)$ 和边缘概率 $P(H=1)$。\n\n为了求联合概率 $P(S=1, H=1)$，我们再次应用全概率定律，对共病状态 $C$ 进行边缘化：\n$$\nP(S=1, H=1) = P(S=1, H=1, C=1) + P(S=1, H=1, C=0)\n$$\n使用概率的链式法则 $P(A, B, C) = P(A \\mid B, C)P(B \\mid C)P(C)$：\n$$\nP(S=1, H=1) = P(H=1 \\mid S=1, C=1)P(S=1 \\mid C=1)P(C=1) + P(H=1 \\mid S=1, C=0)P(S=1 \\mid C=0)P(C=0)\n$$\n代入给定值：\n$$\nP(S=1, H=1) = (0.9)(0.4)(0.3) + (0.7)(0.1)(0.7) = 0.108 + 0.049 = 0.157\n$$\n\n为了求住院的边缘概率 $P(H=1)$，我们对严重程度 $S$ 和共病 $C$ 的所有可能状态进行边缘化：\n$$\nP(H=1) = \\sum_{s \\in \\{0,1\\}} \\sum_{c \\in \\{0,1\\}} P(H=1, S=s, C=c)\n$$\n再次使用链式法则：\n$$\nP(H=1) = \\sum_{s \\in \\{0,1\\}} \\sum_{c \\in \\{0,1\\}} P(H=1 \\mid S=s, C=c)P(S=s \\mid C=c)P(C=c)\n$$\n我们可以将这个和整理为四项：\n第1项 ($S=1, C=1$): $P(H=1 \\mid S=1, C=1)P(S=1 \\mid C=1)P(C=1) = (0.9)(0.4)(0.3) = 0.108$\n第2项 ($S=1, C=0$): $P(H=1 \\mid S=1, C=0)P(S=1 \\mid C=0)P(C=0) = (0.7)(0.1)(0.7) = 0.049$\n第3项 ($S=0, C=1$): $P(H=1 \\mid S=0, C=1)P(S=0 \\mid C=1)P(C=1) = (0.3)(1-0.4)(0.3) = (0.3)(0.6)(0.3) = 0.054$\n第4项 ($S=0, C=0$): $P(H=1 \\mid S=0, C=0)P(S=0 \\mid C=0)P(C=0) = (0.05)(1-0.1)(0.7) = (0.05)(0.9)(0.7) = 0.0315$\n将这些项相加，得到一个受感染个体的总住院概率：\n$$\nP(H=1) = 0.108 + 0.049 + 0.054 + 0.0315 = 0.2425\n$$\n现在我们可以计算基于医院的毒力：\n$$\nP(S=1 \\mid H=1) = \\frac{P(S=1, H=1)}{P(H=1)} = \\frac{0.157}{0.2425}\n$$\n最后，我们计算偏倚因子 $B$：\n$$\nB = \\frac{P(S=1 \\mid H=1)}{P(S=1)} = \\frac{0.157 / 0.2425}{0.19} = \\frac{0.157}{0.2425 \\times 0.19} = \\frac{0.157}{0.046075}\n$$\n进行除法运算：\n$$\nB \\approx 3.4074883342...\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\nB \\approx 3.407\n$$\n这个值远大于1，表明当毒力估计仅基于住院患者时，存在显著的向上偏倚。这是符合预期的，因为重症个体更有可能住院，导致他们在研究样本中被过度代表。",
            "answer": "$$\\boxed{3.407}$$"
        },
        {
            "introduction": "基于前一个练习中关于测量挑战的讨论，我们来考虑一个更动态和真实的情境。在一个真实的感染者队列中，结局（如死亡或康复）会随时间推移而发生，并且一些患者可能会失访（删失）。本练习  介绍了一种更先进、更准确的方法，它使用生存分析技术来估算毒力，能够妥善处理这些竞争性结局和数据删失问题。",
            "id": "4602051",
            "problem": "给你一个受感染个体的生存型队列，存在两种竞争性终末结局：“死亡”和“康复”，以及因失访或管理性观察终止导致的右删失。在流行病学中，毒力通常被概念化为在感染后导致严重结局的倾向。在本问题中，将时间 $t$ 时的毒力定义为：在时间 $t$ 前已终结（即经历了“死亡”或“康复”）的感染中，终结事件为“死亡”的概率。假设采用标准的竞争风险框架和非信息性右删失。你的任务是，对于每个给定的测试用例，在指定的评估时间 $t$ 计算以下两个量：\n- 时间 $t$ 时的毒力，定义为在时间 $t$ 评估的死亡累积发生率函数与死亡和康复累积发生率函数之和的比值。\n- 时间 $t$ 时的朴素病死率，定义为在时间 $t$ 前发生的所有已观测到的终结结局（死亡加康复）中，观测到的死亡数所占的比例，忽略除时间 $t$ 截断之外的删失。\n\n然后，为了比较这两者，计算差值\n$$\nD(t) = V(t) - \\mathrm{CFR}_{\\text{naive}}(t),\n$$\n其中 $V(t)$ 是基于累积发生率函数的毒力比，$\\mathrm{CFR}_{\\text{naive}}(t)$ 是上面定义的朴素病死率。如果在时间 $t$ 前没有终结结局（即，在时间 $t$ 累积发生率函数和观测到的终结计数均为零），则定义 $V(t) = 0$ 和 $\\mathrm{CFR}_{\\text{naive}}(t) = 0$，因此 $D(t) = 0$。所有时间都以天为单位；你的输出是无量纲的，并且必须以小数形式报告。\n\n基本原理和假设：\n- 令 $T$ 表示类型为 $J \\in \\{1,2\\}$ 的首次事件发生时间，其中 $J=1$ 表示“死亡”，$J=2$ 表示“康复”。右删失由 $J=0$ 表示。\n- 令 $S(t)$ 表示相对于两种事件类型的总生存率（到时间 $t$ 尚未发生任何事件），令类型 $k \\in \\{1,2\\}$ 在时间 $t$ 的原因别累积发生率函数表示为 $F_k(t)$。\n- 假设非信息性右删失且无左截断。\n\n你必须使用一个适用于右删失竞争风险数据的、有原则的估计量来计算 $F_1(t)$ 和 $F_2(t)$，然后构成\n$$\nV(t) = \\frac{F_1(t)}{F_1(t) + F_2(t)}.\n$$\n时间 $t$ 时的朴素病死率计算如下\n$$\n\\mathrm{CFR}_{\\text{naive}}(t) = \\frac{\\#\\{\\text{deaths observed by } t\\}}{\\#\\{\\text{deaths observed by } t\\} + \\#\\{\\text{recoveries observed by } t\\}},\n$$\n并约定 $0/0 = 0$。\n\n输入和观测值编码：\n- 每个数据集是一个对偶列表 $(t_i, s_i)$，其中 $i \\in \\{1,\\dots,n\\}$，$t_i$ 是观测时间（天），$s_i \\in \\{0,1,2\\}$ 是状态码，$s_i=0$ 表示右删失，$s_i=1$ 表示死亡，$s_i=2$ 表示康复。\n\n要求输出：\n- 对于每个测试用例，计算 $D(t)$ 并四舍五入到 $6$ 位小数。\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如 $[d_1,d_2,d_3,d_4]$，其中每个 $d_k$ 是第 $k$ 个测试用例的 $D(t)$。\n\n测试套件：\n- 测试用例 1（一般情况，混合事件带删失）：\n  - 评估时间 $t = 8$。\n  - 数据：$(1,2)$、$(2,1)$、$(3,0)$、$(4,2)$、$(4,1)$、$(5,2)$、$(6,1)$、$(7,0)$、$(8,1)$、$(9,2)$、$(10,0)$、$(12,2)$。\n- 测试用例 2（无删失，所有事件在 $t$ 前终结）：\n  - 评估时间 $t = 7$。\n  - 数据：$(2,1)$、$(3,2)$、$(4,2)$、$(5,1)$、$(6,1)$、$(7,2)$。\n- 测试用例 3（无死亡事件）：\n  - 评估时间 $t = 10$。\n  - 数据：$(2,2)$、$(4,2)$、$(6,0)$、$(7,2)$、$(8,0)$。\n- 测试用例 4（边界情况，在 $t$ 前无事件）：\n  - 评估时间 $t = 0$。\n  - 数据：$(5,2)$、$(7,1)$、$(9,0)$。\n\n实现要求：\n- 使用一个适用于带右删失的竞争风险的、有原则的 $F_k(t)$ 估计量，并通过使用每个唯一事件时间点之前的风险集来确保正确处理时间平局。\n- 不涉及角度。时间单位为天，但输出是无量纲的，并且必须是小数。\n- 你的程序必须生成单行输出，包含如上所述的 4 个四舍五入后的差值，格式必须为 $[d_1,d_2,d_3,d_4]$，其中每个 $d_k$ 四舍五入到 6 位小数，且不含任何额外文本。",
            "solution": "该问题要求在一个竞争风险生存分析框架内，计算并比较两个毒力指标。第一个我们记为 $V(t)$，是基于原因别累积发生率函数的毒力正式定义。第二个记为 $\\mathrm{CFR}_{\\text{naive}}(t)$，是一个忽略了删失的朴素病死率。我们的任务是在指定时间 $t$ 为几个数据集计算它们的差值 $D(t) = V(t) - \\mathrm{CFR}_{\\text{naive}}(t)$。\n\n这个问题属于生存分析领域，这是统计学的一个分支，处理事件发生时间数据，尤其是在存在删失和竞争风险的情况下。竞争风险是一种事件，它要么妨碍了对主要关注事件的观测，要么完全阻止了其发生。在此背景下，“死亡”（类型 $1$）和“康复”（类型 $2$）是竞争风险；其中一个的发生会阻止另一个在该个体上发生。当一个受试者的事件发生时间仅部分已知时，就会发生右删失，例如，由于失访或在观测到任何事件之前研究期就已结束。\n\n朴素估计量 $\\mathrm{CFR}_{\\text{naive}}(t)$ 是通过计算到时间 $t$ 为止所有观测事件（死亡和康复）中死亡所占的简单比例得出的。该估计量被认为是“朴素的”，因为它含蓄地将删失个体视为与仍在观察中的个体具有相同的事件分布。这一假设通常是不正确的，并会导致有偏估计，尤其是在删失严重或与事件过程不独立的情况下（尽管这里我们假设为非信息性删失）。例如，如果死亡风险较高的受试者更有可能被删失（例如，失访），那么朴素的病死率（CFR）将会人为地偏低。\n\n一种更严谨的方法需要使用能恰当处理删失的估计量。毒力指标 $V(t)$ 基于原因别累积发生率函数 (CIF)，记为 $F_k(t)$。原因 $k$ 的 CIF 是指一个个体在时间 $t$ 前经历类型 $k$ 事件的概率，定义为 $F_k(t) = P(T \\le t, J=k)$，其中 $T$ 是事件时间，$J$ 是事件类型。所有原因的 CIF 之和 $\\sum_k F_k(t)$ 给出了在时间 $t$ 前经历任何事件的概率。毒力指标被定义为在时间 $t$ 前已发生事件的条件下，事件为死亡的条件概率：\n$$\nV(t) = P(J=1 | T \\le t) = \\frac{P(T \\le t, J=1)}{P(T \\le t)} = \\frac{F_1(t)}{F_1(t) + F_2(t)}\n$$\n从右删失数据中非参数地估计 $F_k(t)$ 的标准、有原则的方法是 Aalen-Johansen 估计量。该估计量源于 CIF、总生存函数 $S(t) = P(T>t)$ 以及原因别风险率函数 $\\lambda_k(t) = \\lim_{\\Delta t \\to 0} \\frac{P(t \\le T  t+\\Delta t, J=k | T \\ge t)}{\\Delta t}$ 之间的关系。CIF 可以表示为一个积分：\n$$\nF_k(t) = \\int_0^t S(u^-) \\lambda_k(u) du\n$$\n其中 $S(u^-)$ 是在时间 $u$ 之前的瞬时生存概率。Aalen-Johansen 估计量是一个离散和，作为该积分的经验对应物。\n\n计算 Aalen-Johansen 估计值 $\\hat{F}_1(t)$ 和 $\\hat{F}_2(t)$ 的算法如下：\n$1$. 识别数据中直至评估时间 $t$ 观测到的所有唯一事件时间，记为 $\\tau_1  \\tau_2  \\dots  \\tau_m$，其中 $m$ 是此类唯一时间的数量。\n$2$. 对于此序列中的每个唯一事件时间 $\\tau_j$，我们确定：\n    - $n_j$：在时间 $\\tau_j$ 之前瞬间处于事件风险中的个体数量。这是所有观测时间（事件或删失）大于或等于 $\\tau_j$ 的受试者总数。\n    - $d_{1j}$：在时间 $\\tau_j$ 发生的死亡（类型 1 事件）数量。\n    - $d_{2j}$：在时间 $\\tau_j$ 发生的康复（类型 2 事件）数量。\n    - $d_j = d_{1j} + d_{2j}$：在时间 $\\tau_j$ 发生的事件总数。\n$3$. 原因 $k \\in \\{1,2\\}$ 的 CIF 估计量由以下和式给出：\n$$\n\\hat{F}_k(t) = \\sum_{j: \\tau_j \\le t} \\hat{S}(\\tau_j^-) \\frac{d_{kj}}{n_j}\n$$\n此处，$\\hat{S}(\\tau_j^-)$ 是在时间 $\\tau_j$ 之前瞬间的总生存概率的 Kaplan-Meier 估计。它通过对所有先前的事件时间 $\\tau_i  \\tau_j$ 进行乘积计算得出：\n$$\n\\hat{S}(\\tau_j^-) = \\hat{S}(\\tau_{j-1}) = \\prod_{i=1}^{j-1} \\left(1 - \\frac{d_i}{n_i}\\right)\n$$\n并约定 $\\hat{S}(\\tau_1^-) = \\hat{S}(0) = 1$。此计算可以迭代实现。我们初始化 $\\hat{S}_{\\text{prev}} = 1$，$\\hat{F}_1 = 0$ 和 $\\hat{F}_2 = 0$。然后，按顺序对每个唯一事件时间 $\\tau_j$，我们使用当前的 $\\hat{S}_{\\text{prev}}$ 更新 CIFs，然后为下一次迭代更新 $\\hat{S}_{\\text{prev}}$：$\\hat{S}_{\\text{new}} = \\hat{S}_{\\text{prev}} \\left(1 - \\frac{d_j}{n_j}\\right)$。\n\n一旦计算出 $\\hat{F}_1(t)$ 和 $\\hat{F}_2(t)$，毒力就计算为 $V(t) = \\hat{F}_1(t) / (\\hat{F}_1(t) + \\hat{F}_2(t))$。朴素率 $\\mathrm{CFR}_{\\text{naive}}(t)$ 通过简单地对截至时间 $t$ 的观测事件进行计数来求得。最终的量是它们的差值 $D(t)$。分母为零（即到时间 $t$ 没有事件发生）的特殊情况，通过将两个指标都设置为 $0$ 来处理，从而得到 $D(t)=0$。这个计算过程能正确处理右删失和时间平局，为与朴素估计量进行比较提供了统计上可靠的基础。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solving process for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"t\": 8,\n            \"data\": [(1, 2), (2, 1), (3, 0), (4, 2), (4, 1), (5, 2), (6, 1), \n                     (7, 0), (8, 1), (9, 2), (10, 0), (12, 2)]\n        },\n        {\n            \"t\": 7,\n            \"data\": [(2, 1), (3, 2), (4, 2), (5, 1), (6, 1), (7, 2)]\n        },\n        {\n            \"t\": 10,\n            \"data\": [(2, 2), (4, 2), (6, 0), (7, 2), (8, 0)]\n        },\n        {\n            \"t\": 0,\n            \"data\": [(5, 2), (7, 1), (9, 0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        eval_time = case[\"t\"]\n        data = case[\"data\"]\n        \n        # Calculate the required quantities using a helper function\n        diff = calculate_difference(data, eval_time)\n        results.append(f\"{diff:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_difference(data, eval_time):\n    \"\"\"\n    Computes V(t), CFR_naive(t), and their difference D(t).\n    \n    Args:\n        data (list of tuple): List of (time, status) pairs.\n        eval_time (float): The time t at which to evaluate the quantities.\n\n    Returns:\n        float: The difference D(t) = V(t) - CFR_naive(t).\n    \"\"\"\n\n    # Handle the boundary case where t=0, as per the problem description.\n    if eval_time == 0:\n        return 0.0\n\n    # 1. Compute the naive Case Fatality Rate (CFR_naive)\n    observed_deaths = 0\n    observed_recoveries = 0\n    for t_i, s_i in data:\n        if t_i <= eval_time:\n            if s_i == 1:  # Death\n                observed_deaths += 1\n            elif s_i == 2:  # Recovery\n                observed_recoveries += 1\n    \n    total_resolved = observed_deaths + observed_recoveries\n    if total_resolved == 0:\n        cfr_naive = 0.0\n    else:\n        cfr_naive = observed_deaths / total_resolved\n\n    # 2. Compute virulence V(t) using the Aalen-Johansen estimator for CIFs\n    \n    # Identify unique event times (status 1 or 2) up to the evaluation time\n    unique_event_times = sorted(list(set([t_i for t_i, s_i in data if s_i in [1, 2] and t_i <= eval_time])))\n\n    if not unique_event_times:\n        # No events by eval_time, so V(t) is 0\n        v_t = 0.0\n    else:\n        # Initialize estimates\n        s_hat_prev = 1.0  # Kaplan-Meier survival estimate before current event time\n        f1_hat = 0.0      # Aalen-Johansen estimate for CIF of death\n        f2_hat = 0.0      # Aalen-Johansen estimate for CIF of recovery\n\n        for t_j in unique_event_times:\n            # Number of subjects at risk just before time t_j\n            n_j = sum(1 for t_i, s_i in data if t_i >= t_j)\n            \n            if n_j == 0:\n                continue\n\n            # Number of events of each type at time t_j\n            d_1j = sum(1 for t_i, s_i in data if t_i == t_j and s_i == 1)\n            d_2j = sum(1 for t_i, s_i in data if t_i == t_j and s_i == 2)\n            d_j = d_1j + d_2j\n            \n            # Increment CIFs using S(t_j^-)\n            f1_hat += s_hat_prev * (d_1j / n_j)\n            f2_hat += s_hat_prev * (d_2j / n_j)\n            \n            # Update the survival estimate for the next iteration\n            s_hat_prev *= (1.0 - d_j / n_j)\n            \n        # Calculate V(t)\n        total_cif = f1_hat + f2_hat\n        if total_cif == 0:\n            v_t = 0.0\n        else:\n            v_t = f1_hat / total_cif\n\n    # 3. Compute the final difference D(t)\n    return v_t - cfr_naive\n\nsolve()\n```"
        }
    ]
}