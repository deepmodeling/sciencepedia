{
    "hands_on_practices": [
        {
            "introduction": "要准确衡量疾病发病率的长期（或称“世俗”）趋势，我们必须首先排除人口年龄结构变化等混杂因素的干扰。本练习  提供了实施直接年龄标化法的实践机会，这是一种基础的流行病学工具，用于在不同时间段之间进行公平比较。通过动手操作，您将学会如何从原始数据中分离出真实的长期趋势。",
            "id": "4642214",
            "problem": "一个基于人群的疾病监测项目旨在量化长时间跨度内的发病率长期趋势，同时消除因年龄结构变化引起的混杂。该项目将对多个数据集使用直接年龄标化法，跨越两个十年期，每个数据集都有一个固定的标准人口。请从流行病学的基本定义和加权平均的基本性质出发，推导一个算法，该算法为每个数据集计算两个十年期中每个时期的年龄标化发病率以及它们之间的长期变化。\n\n使用以下基础定义，不要在问题陈述中引入任何快捷公式。对于年龄组索引 $i \\in \\{1,\\dots,k\\}$ 和时间索引 $t \\in \\{t_1,t_2\\}$：\n- 年龄别发病率定义为 $r_{i,t} = c_{i,t}/N_{i,t}$，其中 $c_{i,t}$ 是新发病例数，而 $N_{i,t}$ 是同一时期和年龄组的人时数或风险人口。\n- 一个固定的标准人口通过归一化提供权重：使用一个非负计数向量 $S = (S_1,\\dots,S_k)$ 来构建总和为1的归一化权重 $w_i$。\n- 最终的年龄标化率以每$10^5$人年表示。设 $m = 10^5$ 为乘数。\n\n你的任务是：\n1. 从这些定义出发，推导如何计算两个十年期中每个时期的直接年龄标化发病率，对两个十年期使用相同的固定标准人口以分离出长期趋势。\n2. 将长期变化定义为两个十年期间年龄标化发病率的绝对差值。\n3. 实现一个程序，为每个测试用例计算一个三元组，包括两个年龄标化率及其绝对差值，所有值均以每$10^5$人年表示并四舍五入到小数点后$2$位。\n\n科学真实性：以下数据集内部一致，并且对于传染病或慢性病监测项目是合理的。由于数据汇总跨越数十年，因此不考虑季节性；重点在于长期趋势。每个测试用例中的所有年龄组在两个十年期中均使用相同的固定标准人口。\n\n单位：所有率必须以每$10^5$人年为单位报告。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n测试套件和参数说明（每个向量都按五个年龄组的顺序排列为 $(G_1,G_2,G_3,G_4,G_5)$）：\n- 测试用例 $1$（正常路径；中度老龄化和中度发病率变化）：\n  - 标准人口 $S^{(1)} = (300000, 320000, 200000, 140000, 40000)$。\n  - 十年期 $t_1$：病例数 $C^{(1)}_{t_1} = (180, 450, 720, 980, 500)$，人口数 $N^{(1)}_{t_1} = (200000, 180000, 120000, 70000, 20000)$。\n  - 十年期 $t_2$：病例数 $C^{(1)}_{t_2} = (160, 400, 800, 1100, 600)$，人口数 $N^{(1)}_{t_2} = (180000, 160000, 130000, 90000, 30000)$。\n- 测试用例 $2$（边缘情况；年轻年龄组病例为零，较老年龄组变化显著）：\n  - 标准人口 $S^{(2)} = (400000, 300000, 180000, 100000, 20000)$。\n  - 十年期 $t_1$：病例数 $C^{(2)}_{t_1} = (0, 200, 500, 600, 150)$，人口数 $N^{(2)}_{t_1} = (250000, 200000, 100000, 40000, 5000)$。\n  - 十年期 $t_2$：病例数 $C^{(2)}_{t_2} = (0, 210, 600, 700, 350)$，人口数 $N^{(2)}_{t_2} = (240000, 220000, 120000, 60000, 10000)$。\n- 测试用例 $3$（边界情况；十年间年龄结构发生巨大变化但年龄别发病率恒定）：\n  - 标准人口 $S^{(3)} = (500000, 250000, 150000, 80000, 20000)$。\n  - 十年期 $t_1$：病例数 $C^{(3)}_{t_1} = (50, 100, 400, 1000, 2000)$，人口数 $N^{(3)}_{t_1} = (100000, 100000, 100000, 100000, 100000)$。\n  - 十年期 $t_2$：病例数 $C^{(3)}_{t_2} = (200, 200, 480, 600, 400)$，人口数 $N^{(3)}_{t_2} = (400000, 200000, 120000, 60000, 20000)$。\n- 测试用例 $4$（小人口；检查罕见事件下的数值稳定性和舍入）：\n  - 标准人口 $S^{(4)} = (200000, 300000, 250000, 200000, 50000)$。\n  - 十年期 $t_1$：病例数 $C^{(4)}_{t_1} = (2, 9, 15, 30, 12)$，人口数 $N^{(4)}_{t_1} = (20000, 30000, 25000, 20000, 5000)$。\n  - 十年期 $t_2$：病例数 $C^{(4)}_{t_2} = (3, 12, 20, 45, 25)$，人口数 $N^{(4)}_{t_2} = (20000, 30000, 25000, 20000, 5000)$。\n\n程序输出格式：\n- 对每个测试用例，按顺序计算三个值：十年期 $t_1$ 的年龄标化发病率，十年期 $t_2$ 的年龄标化发病率，以及绝对长期变化 $|R_{t_2} - R_{t_1}|$，所有值均以每$10^5$人年表示并四舍五入到小数点后$2$位。\n- 将所有测试用例的结果按测试用例的顺序汇总到一个扁平列表中：$[R^{(1)}_{t_1}, R^{(1)}_{t_2}, |R^{(1)}_{t_2} - R^{(1)}_{t_1}|, R^{(2)}_{t_1}, R^{(2)}_{t_2}, |R^{(2)}_{t_2} - R^{(2)}_{t_1}|, R^{(3)}_{t_1}, R^{(3)}_{t_2}, |R^{(3)}_{t_2} - R^{(3)}_{t_1}|, R^{(4)}_{t_1}, R^{(4)}_{t_2}, |R^{(4)}_{t_2} - R^{(4)}_{t_1}|]$。\n- 你的程序应生成单行输出，其中包含此列表，形式为用方括号括起来的逗号分隔序列，例如 $[x_1,x_2,\\dots,x_{12}]$。",
            "solution": "该问题要求推导并实现一个算法，用以计算两个不同时期（十年期）的直接年龄标化发病率以及它们之间的长期变化。该方法是流行病学中的基础方法，用于在控制不同年龄结构混杂效应的同时，比较不同时间或人群间的率。推导将从所提供的基础定义开始。\n\n设年龄组索引为 $i \\in \\{1, 2, \\dots, k\\}$，两个十年期的索引为 $t \\in \\{t_1, t_2\\}$。每个测试用例给出的量如下：\n- $C_{t} = (c_{1,t}, c_{2,t}, \\dots, c_{k,t})$：给定十年期 $t$ 的新发病例数向量。\n- $N_{t} = (N_{1,t}, N_{2,t}, \\dots, N_{k,t})$：相应年龄组和十年期的人时数或风险人口计数向量。\n- $S = (S_1, S_2, \\dots, S_k)$：固定标准人口的人口数向量。\n- $m = 10^5$：用于将率表示为每$10^5$人年的乘数。\n\n**1. 年龄别发病率的推导**\n\n特定亚群中疾病频率的基础测量指标是年龄别发病率。根据问题中的定义，对于年龄组 $i$ 和十年期 $t$，此率（表示为 $r_{i,t}$）是新发病例数与总风险人时数的比率。\n$$r_{i,t} = \\frac{c_{i,t}}{N_{i,t}}$$\n对每个年龄组 $i$ 以及两个十年期 $t_1$ 和 $t_2$ 中的每一个都执行此计算。\n\n**2. 标化权重的推导**\n\n直接标化的核心是将一个共同的年龄结构应用于被比较的人群。这个共同的结构由标准人口 $S$ 提供。我们必须推导出一组归一化权重 $w_i$，这些权重代表标准人口中每个年龄组 $i$ 的比例。\n\n标准人口的总规模是其各年龄组计数的总和：\n$$S_{total} = \\sum_{j=1}^{k} S_j$$\n年龄组 $i$ 的权重 $w_i$ 是该总人口中属于组 $i$ 的比例：\n$$w_i = \\frac{S_i}{S_{total}} = \\frac{S_i}{\\sum_{j=1}^{k} S_j}$$\n根据此构造，权重是非负的（因为 $S_i \\ge 0$）并且总和为1，这是加权平均的一个必要属性：\n$$\\sum_{i=1}^{k} w_i = \\sum_{i=1}^{k} \\frac{S_i}{\\sum_{j=1}^{k} S_j} = \\frac{\\sum_{i=1}^{k} S_i}{\\sum_{j=1}^{k} S_j} = 1$$\n\n**3. 年龄标化发病率（ASR）的推导**\n\n给定十年期 $t$ 的直接年龄标化发病率，我们将其表示为 $R_t$，是年龄别发病率 $r_{i,t}$ 的加权平均值。使用的权重是上面推导出的标准人口权重 $w_i$。如果研究人口具有与标准人口相同的年龄结构，此过程将得出在该研究人口中观察到的总发病率。\n\n原始标化率 $R_{t, \\text{raw}}$ 计算如下：\n$$R_{t, \\text{raw}} = \\sum_{i=1}^{k} w_i \\cdot r_{i,t}$$\n代入先前推导的 $w_i$ 和 $r_{i,t}$ 的表达式：\n$$R_{t, \\text{raw}} = \\sum_{i=1}^{k} \\left( \\frac{S_i}{\\sum_{j=1}^{k} S_j} \\right) \\cdot \\left( \\frac{c_{i,t}}{N_{i,t}} \\right)$$\n问题要求最终的率以每 $m = 10^5$ 人年表示。因此，我们用这个乘数来缩放原始率：\n$$R_t = m \\cdot R_{t, \\text{raw}} = 10^5 \\cdot \\sum_{i=1}^{k} \\left( \\frac{S_i}{\\sum_{j=1}^{k} S_j} \\right) \\left( \\frac{c_{i,t}}{N_{i,t}} \\right)$$\n对十年期 $t_1$ 和十年期 $t_2$ 都执行此计算，使用各自的病例和人口计数（$c_{i,t_1}, N_{i,t_1}$ 和 $c_{i,t_2}, N_{i,t_2}$），但关键的是，两者都使用*相同*的标准人口权重 $w_i$。这确保了 $R_{t_1}$ 和 $R_{t_2}$ 之间的任何观察到的差异不是由两个十年期间研究人口的年龄构成变化引起的。\n\n**4. 长期变化的定义**\n\n长期变化量化了发病率的长期趋势。根据规定，我们将其定义为两个十年期间年龄标化率的绝对差值：\n$$\\Delta R = |R_{t_2} - R_{t_1}|$$\n该值表示在十年期 $t_1$ 和 $t_2$ 之间年龄调整后发病率变化的幅度，以每$10^5$人年表示。\n\n**5. 算法总结**\n\n要实现的完整算法如下：\n对于提供的每个测试用例：\n1.  接收标准人口 $S$、病例数 $C_{t_1}$ 和 $C_{t_2}$ 以及研究人口 $N_{t_1}$ 和 $N_{t_2}$ 的输入向量。\n2.  计算标准人口总数 $S_{total} = \\sum_{i=1}^{k} S_i$。\n3.  计算标准权重向量 $W = (w_1, \\dots, w_k)$，其中 $w_i = S_i / S_{total}$。\n4.  对于十年期 $t_1$：\n    a. 计算年龄别发病率向量 $R'_{t_1} = (r_{1,t_1}, \\dots, r_{k,t_1})$，其中 $r_{i,t_1} = c_{i,t_1} / N_{i,t_1}$。\n    b. 计算标化率 $R_{t_1} = 10^5 \\cdot \\sum_{i=1}^{k} w_i \\cdot r_{i,t_1}$。\n5.  对于十年期 $t_2$：\n    a. 计算年龄别发病率向量 $R'_{t_2} = (r_{1,t_2}, \\dots, r_{k,t_2})$，其中 $r_{i,t_2} = c_{i,t_2} / N_{i,t_2}$。\n    b. 计算标化率 $R_{t_2} = 10^5 \\cdot \\sum_{i=1}^{k} w_i \\cdot r_{i,t_2}$。\n6.  计算长期变化 $\\Delta R = |R_{t_2} - R_{t_1}|$。\n7.  将计算出的三个值 $R_{t_1}$、$R_{t_2}$ 和 $\\Delta R$ 四舍五入到小数点后两位。\n8.  存储得到的三元组值。\n\n该过程将对所有测试用例执行，并且结果将被汇总到一个扁平列表中以供输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements an algorithm for direct age standardization to compute\n    age-standardized incidence rates and their secular change for multiple test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        (\n            (300000, 320000, 200000, 140000, 40000),  # Standard population S^(1)\n            (180, 450, 720, 980, 500),                # Cases C^(1)_t1\n            (200000, 180000, 120000, 70000, 20000),  # Population N^(1)_t1\n            (160, 400, 800, 1100, 600),                # Cases C^(1)_t2\n            (180000, 160000, 130000, 90000, 30000)   # Population N^(1)_t2\n        ),\n        # Test case 2\n        (\n            (400000, 300000, 180000, 100000, 20000),  # Standard population S^(2)\n            (0, 200, 500, 600, 150),                   # Cases C^(2)_t1\n            (250000, 200000, 100000, 40000, 5000),   # Population N^(2)_t1\n            (0, 210, 600, 700, 350),                   # Cases C^(2)_t2\n            (240000, 220000, 120000, 60000, 10000)   # Population N^(2)_t2\n        ),\n        # Test case 3\n        (\n            (500000, 250000, 150000, 80000, 20000),  # Standard population S^(3)\n            (50, 100, 400, 1000, 2000),                # Cases C^(3)_t1\n            (100000, 100000, 100000, 100000, 100000), # Population N^(3)_t1\n            (200, 200, 480, 600, 400),                 # Cases C^(3)_t2\n            (400000, 200000, 120000, 60000, 20000)    # Population N^(3)_t2\n        ),\n        # Test case 4\n        (\n            (200000, 300000, 250000, 200000, 50000),  # Standard population S^(4)\n            (2, 9, 15, 30, 12),                       # Cases C^(4)_t1\n            (20000, 30000, 25000, 20000, 5000),     # Population N^(4)_t1\n            (3, 12, 20, 45, 25),                      # Cases C^(4)_t2\n            (20000, 30000, 25000, 20000, 5000)      # Population N^(4)_t2\n        )\n    ]\n\n    results = []\n    multiplier = 1e5\n\n    for s_pop, c_t1, n_t1, c_t2, n_t2 in test_cases:\n        # Convert tuples to numpy arrays for vectorized operations, ensuring float division.\n        s_pop_arr = np.array(s_pop, dtype=float)\n        c_t1_arr = np.array(c_t1, dtype=float)\n        n_t1_arr = np.array(n_t1, dtype=float)\n        c_t2_arr = np.array(c_t2, dtype=float)\n        n_t2_arr = np.array(n_t2, dtype=float)\n\n        # Step 1: Calculate standard weights\n        total_s_pop = np.sum(s_pop_arr)\n        weights = s_pop_arr / total_s_pop\n\n        # Step 2: Calculate age-specific rates for each decade\n        age_specific_rates_t1 = c_t1_arr / n_t1_arr\n        age_specific_rates_t2 = c_t2_arr / n_t2_arr\n\n        # Step 3: Calculate age-standardized rates (ASR)\n        # The ASR is the weighted average of age-specific rates, scaled by the multiplier.\n        # np.sum(weights * rates) is equivalent to the dot product.\n        asr_t1 = np.sum(weights * age_specific_rates_t1) * multiplier\n        asr_t2 = np.sum(weights * age_specific_rates_t2) * multiplier\n\n        # Step 4: Calculate secular change\n        secular_change = np.abs(asr_t2 - asr_t1)\n\n        # Step 5: Round results to 2 decimal places\n        asr_t1_rounded = np.round(asr_t1, 2)\n        asr_t2_rounded = np.round(asr_t2, 2)\n        secular_change_rounded = np.round(secular_change, 2)\n\n        results.extend([asr_t1_rounded, asr_t2_rounded, secular_change_rounded])\n\n    # Format results to always show two decimal places and create the final output string\n    formatted_results = [f\"{x:.2f}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在分离出趋势后，我们还需要量化季节性的周期性模式。本练习  将引导您计算季节性指数，这是一个关键指标，用于显示特定季节的疾病发病率相对于年平均水平的高低程度。这有助于我们理解季节性高峰和低谷的强度与时间点。",
            "id": "4642118",
            "problem": "某市卫生部门监测了连续$5$年内一种呼吸道感染的月度病例数。设时间$t$的观测值为$Y_t$，并假设该时间序列可以进行乘法分解，分解为长期趋势、季节性和残差项，即$Y_t = T_t \\times S_{m(t)} \\times R_t$，其中$T_t$是缓慢变化的成分，$S_{m(t)}$是特定月份$m(t) \\in \\{1,2,\\dots,12\\}$的季节性成分，$R_t$是随时间均值为$1$的残差项。假设长期趋势在这$5$年窗口期内近似稳定，因此特定月份的平均值是相对季节性水平的有意义的估计量。\n\n现提供每个日历月份在$5$年内的月度病例数的算术平均值：\n- 一月：$450$\n- 二月：$400$\n- 三月：$300$\n- 四月：$300$\n- 五月：$250$\n- 六月：$180$\n- 七月：$200$\n- 八月：$225$\n- 九月：$240$\n- 十月：$360$\n- 十一月：$375$\n- 十二月：$500$\n\n仅使用上述定义和“在一个完整的季节性周期内，季节性成分总体上应是中性的”这一原则，推导一个特定月份的季节性指数估计量。该估计量基于将每个月的平均值除以所有月份和年份的总平均值，然后施加一个乘法中性约束，使得$12$个月度指数的乘积等于$1$。然后，使用给定数据计算二月的归一化季节性指数。请将最终答案以无单位小数形式给出，并四舍五入至四位有效数字。",
            "solution": "乘法分解$Y_t = T_t \\times S_{m(t)} \\times R_t$假定存在一个特定月份的季节性乘数$S_{m}$，它对长期水平$T_t$进行缩放。对于月份$m$的相对季节性，一个自然的代入估计量是将其该月份的平均值与所有月份和年份的总平均值进行比较。设$\\bar{Y}_m$表示在$5$年内限于月份$m$的$Y_t$的算术平均值，并设$\\bar{Y}$表示所有月份和年份的总平均值。由于每个月贡献的观测数量相同（$5$个），$\\bar{Y}$等于$12$个特定月份平均值的算术平均值：\n$$\n\\bar{Y} \\;=\\; \\frac{1}{12}\\sum_{m=1}^{12} \\bar{Y}_m.\n$$\n那么，月份$m$的未归一化相对季节性因子为\n$$\ns_m \\;=\\; \\frac{\\bar{Y}_m}{\\bar{Y}}.\n$$\n在乘法框架下，一个完整的周期内的标准中性要求是归一化季节性指数的乘积等于$1$：\n$$\n\\prod_{m=1}^{12} I_m \\;=\\; 1.\n$$\n为了满足此约束，我们通过未归一化因子的几何平均值进行归一化。定义\n$$\nG \\;=\\; \\left( \\prod_{m=1}^{12} s_m \\right)^{\\frac{1}{12}},\n$$\n并设\n$$\nI_m \\;=\\; \\frac{s_m}{G}.\n$$\n根据构造，\n$$\n\\prod_{m=1}^{12} I_m \\;=\\; \\frac{\\prod_{m=1}^{12} s_m}{G^{12}} \\;=\\; 1.\n$$\n\n我们现在为所提供的数据计算这些量。首先，计算总平均值$\\bar{Y}$，即$12$个月度平均值的算术平均值：\n\n$$\n\\sum_{m=1}^{12} \\bar{Y}_m \\;=\\; 450 + 400 + 300 + 300 + 250 + 180 + 200 + 225 + 240 + 360 + 375 + 500 \\;=\\; 3780,\n$$\n\n所以\n\n$$\n\\bar{Y} \\;=\\; \\frac{3780}{12} \\;=\\; 315.\n$$\n\n二月的未归一化因子是\n\n$$\ns_{\\text{Feb}} \\;=\\; \\frac{\\bar{Y}_{\\text{Feb}}}{\\bar{Y}} \\;=\\; \\frac{400}{315}.\n$$\n\n\n接下来，计算归一化因子$G$：\n\n$$\nG \\;=\\; \\left( \\prod_{m=1}^{12} \\frac{\\bar{Y}_m}{\\bar{Y}} \\right)^{\\frac{1}{12}}\n\\;=\\; \\left( \\frac{\\prod_{m=1}^{12} \\bar{Y}_m}{\\bar{Y}^{12}} \\right)^{\\frac{1}{12}}\n\\;=\\; \\frac{\\left( \\prod_{m=1}^{12} \\bar{Y}_m \\right)^{\\frac{1}{12}}}{\\bar{Y}}.\n$$\n\n观察到月度平均值可以配对以揭示其乘积结构：\n- $(450, 200)$: $450 \\times 200 = 90{,}000 = 300^2$,\n- $(400, 225)$: $400 \\times 225 = 90{,}000 = 300^2$,\n- $(360, 250)$: $360 \\times 250 = 90{,}000 = 300^2$,\n- $(375, 240)$: $375 \\times 240 = 90{,}000 = 300^2$,\n- $(300, 300)$: $300 \\times 300 = 90{,}000 = 300^2$,\n- $(500, 180)$: $500 \\times 180 = 90{,}000 = 300^2$.\n因此，\n\n$$\n\\prod_{m=1}^{12} \\bar{Y}_m \\;=\\; (300^2)^6 \\;=\\; 300^{12}.\n$$\n\n所以，\n\n$$\nG \\;=\\; \\frac{(300^{12})^{\\frac{1}{12}}}{315} \\;=\\; \\frac{300}{315} \\;=\\; \\frac{20}{21}.\n$$\n\n\n二月的归一化季节性指数是\n\n$$\nI_{\\text{Feb}} \\;=\\; \\frac{s_{\\text{Feb}}}{G} \\;=\\; \\frac{\\frac{400}{315}}{\\frac{300}{315}} \\;=\\; \\frac{400}{300} \\;=\\; \\frac{4}{3}.\n$$\n\n表示为小数并四舍五入至四位有效数字，\n\n$$\nI_{\\text{Feb}} \\;\\approx\\; 1.333.\n$$\n\n\n解释：在一个$12$个月内乘积中性的乘法季节性结构下，归一化的季节性指数$I_{\\text{Feb}} \\approx 1.333$表明，在控制了$5$年窗口期内任何稳定的长期水平后，二月的预期病例数大约是中性月度水平（指数等于$1$）的$1.333$倍，这反映了与呼吸道感染的冬季季节性相符的相对升高。该指数是无量纲的，并传达了乘法季节性效应的大小。",
            "answer": "$$\\boxed{1.333}$$"
        },
        {
            "introduction": "将时间序列分解为趋势和季节性成分，需要选择一个能描述它们如何组合的模型——是加法模型 ($Y_t = T_t + S_t + R_t$) 还是乘法模型 ($Y_t = T_t \\times S_t \\times R_t$) 。这个选择取决于数据的内在结构，特别是数据的波动性如何随其平均水平变化。本练习  提供了一种数据驱动的诊断方法来做出这一关键决策，以确保后续分解的恰当性和意义。",
            "id": "4642189",
            "problem": "您的任务是在流行病学时间序列的背景下，通过使用对数变换作为诊断工具，对加性与乘性季节性-趋势分解法（STL）进行操作性比较。考虑一个代表新发病例的非负计数单变量月度时间序列，按时间 $t = 1, 2, \\dots, N$ 索引，其季节性周期为 $m$ 个月，共有 $K$ 个完整年份，因此 $N = mK$。两种典型模型是加性季节-趋势-噪声模型 $Y_t = T_t + S_t + R_t$ 和乘性季节-趋势-噪声模型 $Y_t = T_t \\times S_t \\times R_t$，其中 $T_t$ 是趋势分量，$S_t$ 是周期为 $m$ 的季节性因子（即 $S_{t+m} = S_t$），而 $R_t$ 是残差项，在乘性模型中其均值为 $1$，在加性模型中其均值为 $0$。一个广泛应用的事实是，在具有随均值增加的异方差性（这在计数数据中很常见）的乘性结构下，对数变换 $Y'_t = \\log(Y_t + \\varepsilon)$（其中 $\\varepsilon > 0$ 是一个用于处理零值的小偏移量）能将乘性模型转换为加性模型 $Y'_t \\approx \\log T_t + \\log S_t + \\log R_t$，并且当条件方差 $\\operatorname{Var}(Y_t \\mid \\text{season})$ 与季节性均值的平方成正比增长时，它能近似地稳定方差。将使用以下原理：如果 $\\operatorname{Var}(Y \\mid \\text{season } j) \\propto \\mu_j^2$，其中 $\\mu_j = \\mathbb{E}[Y \\mid \\text{season } j]$，那么根据delta方法，对于较小的变异系数，$\\operatorname{Var}(\\log Y \\mid \\text{season } j) \\approx \\operatorname{Var}(Y \\mid \\text{season } j)/\\mu_j^2 \\approx \\text{constant}$（对于不同的 $j$ 值）。\n\n您的程序必须实现以下决策规则，仅使用季节内均值-标准差关系来选择加性或乘性STL：\n\n1. 给定 $m$、$K$ 和数据 $\\{Y_t\\}_{t=1}^N$（其中 $N = mK$），定义季节索引 $j \\in \\{1, 2, \\dots, m\\}$ 和年份索引 $k \\in \\{1, 2, \\dots, K\\}$，使得 $Y_{j,k}$ 表示第 $k$ 年第 $j$ 个月的观测值。对于每个季节 $j$，计算 $\\{Y_{j,k}\\}_{k=1}^K$ 的样本均值 $\\hat{\\mu}_j$ 和样本标准差 $\\hat{s}_j$。使用常规的样本相关系数公式计算向量 $(\\hat{\\mu}_1, \\dots, \\hat{\\mu}_m)$ 和 $(\\hat{s}_1, \\dots, \\hat{s}_m)$ 之间的皮尔逊相关系数 $r_{\\text{raw}}$\n$$\nr(x,y) = \\frac{\\sum_{i=1}^m (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^m (x_i - \\bar{x})^2}\\sqrt{\\sum_{i=1}^m (y_i - \\bar{y})^2}}.\n$$\n\n2. 定义 $Y'_t = \\log(Y_t + \\varepsilon)$，其中 $\\varepsilon = 0.5$。对经过对数变换的数据重复上述步骤，以获得 $\\hat{\\mu}'_j$、$\\hat{s}'_j$ 和 $r_{\\log}$。\n\n3. 当且仅当 $r_{\\text{raw}} - r_{\\log} \\ge \\tau$ 且 $r_{\\text{raw}} \\ge \\rho_{\\min}$（阈值 $\\tau = 0.3$ 和 $\\rho_{\\min} = 0.3$）时，判定为乘性STL（即在对数尺度上应用STL）。否则，判定为加性STL（即在原始尺度上应用STL）。\n\n为使任务在没有外部数据的情况下完全可测试，请使用以下参数化族，在科学上合理的数据生成机制下生成合成的流行病学时间序列。对于 $t = 1, 2, \\dots, N$（其中 $N = mK$），令 $j = 1 + \\big((t-1) \\bmod m\\big)$ 表示年内季节（月份）。按如下方式定义趋势和季节性因子：\n\n- 加性趋势：$T^{\\text{add}}_t = b + \\alpha (t-1)$，其中 $b > 0$ 且斜率 $\\alpha \\ge 0$。\n- 乘性（指数）趋势：$T^{\\text{mult}}_t = b \\times \\exp\\big(\\gamma (t-1)/N\\big)$，其中 $b > 0$ 且增长参数 $\\gamma \\ge 0$。\n- 加性季节：$S^{\\text{add}}_j = A \\sin\\left(2\\pi j/m\\right)$，其中振幅 $A \\ge 0$。\n- 乘性季节（正值）：$S^{\\text{mult}}_j = 1 + A \\sin\\left(2\\pi j/m\\right)$，其中振幅 $A \\in [0,1)$ 以保持 $S^{\\text{mult}}_j > 0$。\n\n噪声机制：\n\n- 加性高斯噪声：$E^{\\text{add}}_t \\sim \\mathcal{N}(0, \\sigma^2)$，在 $t$ 上独立。\n- 乘性对数正态噪声：$E^{\\text{mult}}_t \\sim \\operatorname{LogNormal}(0, \\sigma_{\\log}^2)$，在 $t$ 上独立。\n- 泊松抽样噪声：$Y_t \\sim \\operatorname{Poisson}(\\lambda_t)$，其中均值为 $\\lambda_t$。\n\n根据以下模型之一构建观测值 $Y_t$：\n- 加性模型：$Y_t = T^{\\text{add}}_t + S^{\\text{add}}_j + E^{\\text{add}}_t$，通过参数的构造约束其为非负。\n- 带对数正态噪声的乘性模型：$Y_t = T^{\\text{mult}}_t \\times S^{\\text{mult}}_j \\times E^{\\text{mult}}_t$。\n- 泊松计数：$Y_t \\sim \\operatorname{Poisson}\\left(T^{\\text{mult}}_t \\times S^{\\text{mult}}_j\\right)$。\n\n使用固定的随机种子实现确定性生成，然后应用决策规则。您的程序必须解决以下参数值测试套件，每个参数值都指定为一个元组并用文字描述。对于每种情况，生成一个布尔值，指示是选择乘性STL（对数尺度）（true）还是选择加性STL（原始尺度）（false）：\n\n- 情况1（乘性模型的理想路径）：($m, K, b, \\gamma, A, \\sigma_{\\log}, \\text{noise}, \\text{seed}$) = ($12, 8, 20.0, 0.5, 0.5, 0.25, \\text{multiplicative\\_lognormal}, 123$)。使用 $T^{\\text{mult}}_t$、$S^{\\text{mult}}_j$ 和对数正态噪声。\n- 情况2（加性模型的理想路径）：($m, K, b, \\alpha, A, \\sigma, \\text{noise}, \\text{seed}$) = ($12, 8, 20.0, 0.2, 5.0, 3.0, \\text{additive\\_gaussian}, 456$)。使用 $T^{\\text{add}}_t$、$S^{\\text{add}}_j$ 和加性高斯噪声。\n- 情况3（边界近似常数）：($m, K, b, \\alpha, A, \\sigma, \\text{noise}, \\text{seed}$) = ($12, 6, 15.0, 0.0, 0.0, 0.1, \\text{additive\\_gaussian}, 789$)。使用 $T^{\\text{add}}_t$、$S^{\\text{add}}_j$ 和加性高斯噪声，产生近似恒定的序列。\n- 情况4（通过泊松分布产生零值的边缘情况）：($m, K, b, \\gamma, A, \\text{noise}, \\text{seed}$) = ($12, 10, 1.2, 0.3, 0.8, \\text{poisson}, 321$)。使用 $T^{\\text{mult}}_t$、$S^{\\text{mult}}_j$ 和泊松抽样。\n\n角度单位不适用。无需报告物理单位，因为输出是布尔值的选项。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[true,false,true,true]”，但使用Python的布尔值大写形式），顺序为情况1到情况4。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于时间序列分析的原理，特别是关于在加性和乘性分解模型之间进行选择的原理。该问题是适定的、客观的，并为确定性计算任务提供了完整、自包含的规范。所有参数、模型和决策标准都以足够的精度定义，以确保存在唯一的解。合成数据生成过程基于流行病学及相关领域中使用的标准、合理的模型。\n\n问题的核心是实现一个诊断测试，以判断一个流行病学时间序列是由加性模型 $Y_t = T_t + S_t + R_t$ 还是由乘性模型 $Y_t = T_t \\times S_t \\times R_t$ 更好地描述。这里，$Y_t$ 是在时间 $t$ 的观测数据，$T_t$ 是趋势，$S_t$ 是季节性分量，$R_t$ 是残差或噪声项。这个选择是根本性的，因为它决定了合适的分解方法，例如在原始数据上使用季节性-趋势分解法（STL）（加性）或在对数变换后的数据上使用（乘性）。\n\n指导原则是基于序列均值和方差之间的关系。许多生成计数数据的过程，例如由泊松分布或对数正态分布建模的过程，都表现出异方差性，即观测值的方差随均值水平的增加而增加。在乘性模型中，季节性和噪声分量作为趋势的缩放因子，特定季节内数据的标准差往往与该季节的均值水平成正比。也就是说，如果 $\\mu_j$ 是季节 $j$ 的期望值，那么 $\\operatorname{StdDev}(Y \\mid \\text{season } j) \\propto \\mu_j$。这意味着 $\\operatorname{Var}(Y \\mid \\text{season } j) \\propto \\mu_j^2$。相反，一个带有同方差噪声（即 $R_t$ 具有恒定方差）的简单加性模型，在季节性均值和季节性标准差之间不会显示出系统性关系。\n\n对数变换 $Y'_t = \\log(Y_t + \\varepsilon)$（其中 $\\varepsilon > 0$ 是一个小偏移量）通常用于稳定乘性模型中的方差。根据delta方法，如果 $\\operatorname{Var}(Y) \\propto (\\mathbb{E}[Y])^2$，那么 $\\operatorname{Var}(\\log Y)$ 将近似为常数。这种变换将乘性结构转换为加性结构：$\\log(T_t \\times S_t \\times R_t) = \\log T_t + \\log S_t + \\log R_t$。\n\n指定的决策规则将此原理操作化。它使用季节性均值和季节性标准差之间的皮尔逊相关系数作为衡量均值-方差关系强度的度量。算法如下：\n\n1.  对于给定的时间序列 $\\{Y_t\\}_{t=1}^N$（季节周期为 $m$，共有 $K$ 年），数据按季节分组。对每个季节 $j \\in \\{1, 2, \\dots, m\\}$，计算 $K$ 年间的样本均值 $\\hat{\\mu}_j$ 和样本标准差 $\\hat{s}_j$。\n2.  计算配对集合 $\\{(\\hat{\\mu}_j, \\hat{s}_j)\\}_{j=1}^m$ 的皮尔逊相关系数，记为 $r_{\\text{raw}}$。强正相关表明存在乘性结构。\n3.  使用 $Y'_t = \\log(Y_t + \\varepsilon)$（其中 $\\varepsilon = 0.5$）对数据进行变换。重复此过程以计算新的季节性均值 $\\hat{\\mu}'_j$ 和标准差 $\\hat{s}'_j$，以及它们的相关性 $r_{\\log}$。\n4.  如果对数变换成功稳定了方差，$r_{\\log}$ 应远小于 $r_{\\text{raw}}$。在满足以下两个条件时，选择乘性模型：\n    a. 原始尺度上的相关性足够高，表明初始存在强的均值-方差关系：$r_{\\text{raw}} \\ge \\rho_{\\min}$，其中 $\\rho_{\\min} = 0.3$。\n    b. 对数变换显著降低了此相关性，表明方差稳定化成功：$r_{\\text{raw}} - r_{\\log} \\ge \\tau$，其中 $\\tau = 0.3$。\n    如果两个条件都成立，则选择乘性模型。否则，默认选择加性模型。\n\n实现将首先根据四个指定的测试用例生成合成时间序列。每个用例使用趋势、季节和噪声模型的不同组合来模拟合理的场景。对于每个生成的序列，执行诊断程序以获得布尔决策。\n\n`calculate_correlation` 函数将以时间序列数据、$m$ 和 $K$ 作为输入。它会将 $N$ 点序列重塑为一个 $K \\times m$ 矩阵，其中行代表年份，列代表季节。然后，它将为每列（季节）计算均值和样本标准差（使用自由度差为 $1$）。最后，它将使用 `numpy.corrcoef` 计算得到的均值和标准差向量之间的皮尔逊相关系数，并返回该值。\n\n主函数将为每个测试用例协调此过程，应用决策规则，并使用给定的阈值参数 $\\tau = 0.3$ 和 $\\rho_{\\min} = 0.3$ 以及对数变换偏移量 $\\varepsilon = 0.5$。结果将被收集并按指定格式化。为保证可复现性，随机种子是固定的。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_correlation(data: np.ndarray, m: int, K: int) -> float:\n    \"\"\"\n    Calculates the Pearson correlation between seasonal means and standard deviations.\n\n    Args:\n        data: A 1D numpy array representing the time series.\n        m: The seasonal period.\n        K: The number of complete years.\n\n    Returns:\n        The Pearson correlation coefficient.\n    \"\"\"\n    if data.ndim != 1 or len(data) != m * K:\n        raise ValueError(\"Data must be a 1D array of length m*K.\")\n\n    # Reshape data into a (K, m) matrix [years x seasons]\n    series_matrix = data.reshape(K, m)\n\n    # Calculate mean and standard deviation for each season (column)\n    # ddof=1 for sample standard deviation\n    seasonal_means = np.mean(series_matrix, axis=0)\n    seasonal_stds = np.std(series_matrix, axis=0, ddof=1)\n    \n    # If all standard deviations are zero, correlation is undefined (NaN).\n    # This can happen if the series is constant within each season.\n    # np.corrcoef handles this by returning NaN.\n    if np.all(seasonal_stds == 0):\n        return 0.0 # Define as 0 to avoid NaN propagation issues in comparisons\n\n    # Calculate Pearson correlation coefficient\n    # np.corrcoef returns a 2x2 matrix, we need the off-diagonal element\n    # It returns nan if one of the inputs is constant, which is desired.\n    corr_matrix = np.corrcoef(seasonal_means, seasonal_stds)\n    \n    correlation = corr_matrix[0, 1]\n    \n    # If correlation is NaN (due to constant stds or means), treat it as 0.\n    if np.isnan(correlation):\n        return 0.0\n        \n    return correlation\n\ndef apply_decision_rule(Y: np.ndarray, m: int, K: int, epsilon: float, tau: float, rho_min: float) -> bool:\n    \"\"\"\n    Applies the decision rule to choose between additive and multiplicative models.\n\n    Args:\n        Y: The time series data.\n        m: The seasonal period.\n        K: The number of years.\n        epsilon: Offset for log transform.\n        tau: Threshold for correlation reduction.\n        rho_min: Threshold for raw correlation.\n\n    Returns:\n        True if multiplicative is chosen, False otherwise.\n    \"\"\"\n    # 1. Compute correlation for raw data\n    r_raw = calculate_correlation(Y, m, K)\n\n    # 2. Compute correlation for log-transformed data\n    Y_prime = np.log(Y + epsilon)\n    r_log = calculate_correlation(Y_prime, m, K)\n\n    # 3. Apply the decision rule\n    is_multiplicative = (r_raw - r_log >= tau) and (r_raw >= rho_min)\n    return is_multiplicative\n\ndef generate_series(params: dict):\n    \"\"\"\n    Generates a synthetic time series based on the provided parameters.\n    \"\"\"\n    np.random.seed(params['seed'])\n    \n    m = params['m']\n    K = params['K']\n    N = m * K\n    t_idx = np.arange(N)\n    j_idx = t_idx % m\n    \n    model_type = params['model']\n    \n    if model_type == 'additive_gaussian':\n        b = params['b']\n        alpha = params['alpha']\n        A = params['A']\n        sigma = params['sigma']\n        \n        trend = b + alpha * t_idx\n        seasonality = A * np.sin(2 * np.pi * (j_idx + 1) / m)\n        noise = np.random.normal(0, sigma, N)\n        \n        Y = trend + seasonality + noise\n        # As per problem, data represent non-negative counts.\n        # Although parameters are chosen to make negative values unlikely,\n        # we enforce this for robustness.\n        Y = np.maximum(0, Y)\n\n    elif model_type == 'multiplicative_lognormal':\n        b = params['b']\n        gamma = params['gamma']\n        A = params['A']\n        sigma_log = params['sigma_log']\n\n        trend = b * np.exp(gamma * t_idx / N)\n        seasonality = 1 + A * np.sin(2 * np.pi * (j_idx + 1) / m)\n        noise = np.random.lognormal(0, sigma_log, N)\n        \n        Y = trend * seasonality * noise\n\n    elif model_type == 'poisson':\n        b = params['b']\n        gamma = params['gamma']\n        A = params['A']\n        \n        trend = b * np.exp(gamma * t_idx / N)\n        seasonality = 1 + A * np.sin(2 * np.pi * (j_idx + 1) / m)\n        \n        lambda_t = trend * seasonality\n        # Ensure lambda is non-negative, although parameters should guarantee this.\n        lambda_t = np.maximum(0, lambda_t)\n        Y = np.random.poisson(lambda_t)\n\n    else:\n        raise ValueError(f\"Unknown model type: {model_type}\")\n        \n    return Y, m, K\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: Multiplicative model with lognormal noise\n        {'model': 'multiplicative_lognormal', 'm': 12, 'K': 8, 'b': 20.0, 'gamma': 0.5, 'A': 0.5, 'sigma_log': 0.25, 'seed': 123},\n        # Case 2: Additive model with Gaussian noise\n        {'model': 'additive_gaussian', 'm': 12, 'K': 8, 'b': 20.0, 'alpha': 0.2, 'A': 5.0, 'sigma': 3.0, 'seed': 456},\n        # Case 3: Additive model, nearly constant\n        {'model': 'additive_gaussian', 'm': 12, 'K': 6, 'b': 15.0, 'alpha': 0.0, 'A': 0.0, 'sigma': 0.1, 'seed': 789},\n        # Case 4: Multiplicative mean structure with Poisson noise\n        {'model': 'poisson', 'm': 12, 'K': 10, 'b': 1.2, 'gamma': 0.3, 'A': 0.8, 'seed': 321}\n    ]\n\n    # Decision rule parameters\n    epsilon = 0.5\n    tau = 0.3\n    rho_min = 0.3\n\n    results = []\n    for params in test_cases:\n        Y, m, K = generate_series(params)\n        is_multiplicative = apply_decision_rule(Y, m, K, epsilon, tau, rho_min)\n        results.append(is_multiplicative)\n\n    # Format the output as specified: [True,False,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}