{
    "hands_on_practices": [
        {
            "introduction": "磁共振指纹技术（MRF）的核心在于每个组织都产生独特的信号演化。这项练习将通过基础的布洛赫方程（Bloch equations）来模拟这些信号，让您亲手构建一个指纹。我们将实现一种在磁共振成像中常用且强大的序列——平衡稳态自由进动（bSSFP），并观察其信号如何依赖于组织参数（$T_1$, $T_2$）和离共振频率。通过编写这个模拟程序（），您将直接了解指纹是如何生成的，并发现一个被称为“模糊性”（ambiguity）的关键挑战，即不同组织可能产生极其相似的信号，特别是在bSSFP带状伪影等效应下。",
            "id": "4902016",
            "problem": "你必须编写一个完整、可运行的程序，构建一个平衡稳态自由进动 (bSSFP) 磁共振指纹技术 (MRF) 模拟，并演示一个具体的模糊性场景，其中两个不同的参数集由于近失谐的条带效应而产生高度相关的指纹。该程序必须为恒定重复时间的序列实现一个基于离散时间布洛赫方程的模拟，并计算两个指纹之间的皮尔逊相关性以量化模糊性。\n\n使用的基本原理是包含纵向和横向弛豫的布洛赫方程、用于射频激励和失谐进动的刚体旋转，以及在重复时间中点处的 bSSFP 回波。磁共振 (MR) 指纹技术 (MRF) 是指生成一个时变激励序列，以产生一个依赖于组织参数的独特时间相关信号（指纹）的过程。平衡稳态自由进动 (bSSFP) 是一种序列，其中梯度在每个重复时间内达到平衡，从而使梯度引起的失相被抵消，并在重复时间的一半处形成回波。bSSFP 中的条带效应发生在失谐相位累积接近 $\\pi$ 时，这会显著衰减横向信号。你的程序必须从 MR 物理学的第一性原理（旋转和弛豫）推导出磁化演化过程，并据此执行指纹模拟。\n\n序列规格：\n- 重复时间是恒定的，等于 $TR = 0.004\\,\\mathrm{s}$。\n- 回波时间是中点，即 $TE = TR/2 = 0.002\\,\\mathrm{s}$。\n- 帧数为 $N = 300$。\n- 对于帧索引 $n \\in \\{0,1,\\dots,N-1\\}$，翻转角序列（单位：度）由下式定义\n$$\n\\alpha_n = 10^\\circ + 45^\\circ \\sin^2\\!\\left(\\frac{2\\pi n}{57}\\right).\n$$\n- 射频脉冲是绕 $x$ 轴旋转 $\\alpha_n$。\n- 失谐频率为 $\\Delta f$（单位：$\\mathrm{Hz}$）。在时间 $\\Delta t$ 内累积的失谐相位为 $\\phi = 2\\pi \\,\\Delta f\\, \\Delta t$（单位：弧度）。\n- 纵向和横向弛豫时间分别为 $T_1$ 和 $T_2$（单位：$\\mathrm{s}$）。\n- 平衡磁化强度为 $M_0 = 1$（无单位）。\n\n每帧的磁化演化必须按以下方式建模：\n1. 从初始化为 $[0, 0, M_0]^\\top$ 的磁化矢量 $\\mathbf{M} = [M_x, M_y, M_z]^\\top$ 开始。\n2. 应用绕 $x$ 轴旋转 $\\alpha_n$ 的射频旋转，得到 $\\mathbf{M}' = \\mathbf{R}_x(\\alpha_n)\\,\\mathbf{M}$，其中 $\\mathbf{R}_x(\\alpha)$ 是绕 $x$ 轴旋转角度 $\\alpha$（单位：弧度）的 $3 \\times 3$ 旋转矩阵。\n3. 在 $\\Delta t = TR/2$ 的时间内，使用失谐进动和弛豫演化至回波时间：\n   - 通过 $\\mathbf{R}_z(\\phi_{\\text{half}})$ 将横向分量绕 $z$ 轴旋转 $\\phi_{\\text{half}} = 2\\pi\\,\\Delta f\\,(TR/2)$。\n   - 应用弛豫：横向分量以 $e^{-\\Delta t/T_2}$ 的速率衰减，纵向磁化通过 $M_z \\leftarrow M_z\\,e^{-\\Delta t/T_1} + M_0\\left(1 - e^{-\\Delta t/T_1}\\right)$ 向 $M_0$ 恢复。\n4. 在回波时间记录指纹样本 $S_n = \\sqrt{M_x^2 + M_y^2}$。\n5. 在剩余的 $\\Delta t = TR/2$ 时间内，使用相同的旋转和弛豫操作进行演化，以达到下一次重复的开始。\n\n相关性和模糊性量化：\n- 给定两个长度为 $N$ 的指纹 $\\mathbf{s}^{(A)}$ 和 $\\mathbf{s}^{(B)}$，计算皮尔逊相关系数\n$$\n\\rho = \\frac{\\sum_{n=0}^{N-1} \\left(s^{(A)}_n - \\bar{s}^{(A)}\\right)\\left(s^{(B)}_n - \\bar{s}^{(B)}\\right)}{\\sqrt{\\sum_{n=0}^{N-1}\\left(s^{(A)}_n - \\bar{s}^{(A)}\\right)^2}\\,\\sqrt{\\sum_{n=0}^{N-1}\\left(s^{(B)}_n - \\bar{s}^{(B)}\\right)^2}},\n$$\n其中 $\\bar{s}^{(A)}$ 和 $\\bar{s}^{(B)}$ 分别是各自指纹的平均值。\n- 将模糊性定义为相关性严格超过阈值，即如果 $\\rho > \\rho_{\\mathrm{thr}}$ 为真，则声明为模糊。如果相关公式中的分母对两个指纹都为零（零方差），当两个指纹是相同的序列时定义 $\\rho = 1$，否则定义 $\\rho = 0$。\n\n构建以下参数对的测试套件 $\\left((T_1^{(A)},T_2^{(A)},\\Delta f^{(A)}),(T_1^{(B)},T_2^{(B)},\\Delta f^{(B)}),\\rho_{\\mathrm{thr}}\\right)$，所有时间单位为 $\\mathrm{s}$，频率单位为 $\\mathrm{Hz}$：\n1. 情况 1（恒定 $TR$ 下因条带效应引起的模糊性）：$\\left((1.2,0.08,125),(0.6,0.06,375),0.95\\right)$。注意，对于 $TR = 0.004\\,\\mathrm{s}$，$\\Delta f = 125\\,\\mathrm{Hz}$ 给出 $\\phi = \\pi$，而 $\\Delta f = 375\\,\\mathrm{Hz}$ 给出 $\\phi = 3\\pi$，这在模 $2\\pi$ 意义下等价于 $\\pi$，从而对两者都引起条带效应，并尽管 $(T_1,T_2)$ 不同也促成了高相关性。\n2. 情况 2（非模糊场景）：$\\left((1.2,0.08,0),(0.6,0.06,50),0.95\\right)$。\n3. 情况 3（近条带但失谐有偏移）：$\\left((1.0,0.1,125),(0.7,0.07,360),0.95\\right)$。\n4. 情况 4（阈值边界检查）：$\\left((1.0,0.1,125),(1.0,0.1,125),1.0\\right)$。\n\n$\\alpha_n$ 的角度单位是度；失谐 $\\Delta f$ 必须以 $\\mathrm{Hz}$ 为单位；弛豫时间 $T_1,T_2$ 必须以 $\\mathrm{s}$ 为单位；$TR$ 必须以 $\\mathrm{s}$ 为单位；相位以弧度为单位。指纹样本的输出单位是无单位的。\n\n你的程序应该生成单行输出，其中包含上述四种情况的模糊性判定结果，形式为一个逗号分隔的布尔值列表，并用方括号括起来，例如，当且仅当每种情况下的相关性严格超过指定阈值时，输出 $[{\\text{True}},{\\text{False}},{\\text{False}},{\\text{True}}]$。不允许有其他输出。",
            "solution": "该问题要求构建一个基于平衡稳态自由进动 (bSSFP) 序列的磁共振指纹技术 (MRF) 数值模拟。该模拟必须演示一个模糊性场景，其中两组不同的组织参数（$T_1$、$T_2$）和失谐频率（$\\Delta f$）产生高度相关的信号演化，即指纹。解决方案涉及实现一个离散时间的布洛赫方程模型，为指定的参数集生成指纹，并使用皮尔逊相关系数来量化它们的相似性。\n\n该模拟遵循以下核磁共振物理学的第一性原理和指定的序列结构。\n\n**1. 布洛赫方程模型**\n\n宏观磁化矢量 $\\mathbf{M} = [M_x, M_y, M_z]^\\top$ 的演化由布洛赫方程控制。在此问题中，我们使用每个重复时间 ($TR$) 内的一系列离散操作来模拟其演化：射频 (RF) 激励、由失谐引起的自由进动，以及纵向和横向弛豫。平衡磁化强度给定为 $M_0 = 1$。系统的初始状态是热平衡，$\\mathbf{M}(0) = [0, 0, M_0]^\\top$。\n\n**2. 射频 (RF) 激励**\n\nRF 脉冲作用于磁化矢量，使其发生旋转。对于此问题，脉冲沿 $x$ 轴施加，导致矢量按一个翻转角 $\\alpha_n$ 旋转。该变换由旋转矩阵 $\\mathbf{R}_x(\\alpha_n)$ 描述：\n$$\n\\mathbf{M}_{\\text{post-RF}} = \\mathbf{R}_x(\\alpha_n) \\mathbf{M}_{\\text{pre-RF}}\n$$\n其中 $\\alpha_n$ 以弧度为单位，矩阵由下式给出：\n$$\n\\mathbf{R}_x(\\alpha) = \\begin{pmatrix} 1  0  0 \\\\ 0  \\cos\\alpha  -\\sin\\alpha \\\\ 0  \\sin\\alpha  \\cos\\alpha \\end{pmatrix}\n$$\n翻转角序列定义为帧索引 $n \\in \\{0, 1, \\dots, N-1\\}$，其中 $N=300$：\n$$\n\\alpha_n = 10^\\circ + 45^\\circ \\sin^2\\!\\left(\\frac{2\\pi n}{57}\\right)\n$$\n这些以度为单位给出的角度，在使用于旋转矩阵前必须转换为弧度。\n\n**3. 自由进动与弛豫**\n\n在 RF 脉冲之间，磁化由于两种效应而演化：围绕主磁场轴（$z$ 轴）以失谐频率 $\\Delta f$ 进行的进动，以及使磁化返回热平衡状态的弛豫过程。此演化发生在一个时间间隔 $\\Delta t$ 内。\n\n进动是横向磁化分量 ($M_x, M_y$) 围绕 $z$ 轴旋转一个角度 $\\phi = 2\\pi \\Delta f \\Delta t$。这由旋转矩阵 $\\mathbf{R}_z(\\phi)$ 表示：\n$$\n\\mathbf{M}_{\\text{precessed}} = \\mathbf{R}_z(\\phi) \\mathbf{M}_{\\text{initial}} \\quad \\text{其中} \\quad \\mathbf{R}_z(\\phi) = \\begin{pmatrix} \\cos\\phi  -\\sin\\phi  0 \\\\ \\sin\\phi  \\cos\\phi  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n同时，磁化分量向其平衡值弛豫。横向分量 ($M_x, M_y$) 以时间常数 $T_2$ 衰减至零，纵向分量 ($M_z$) 以时间常数 $T_1$ 恢复至 $M_0$。对于在时间 $\\Delta t$ 内的演化，弛豫过程描述如下：\n$$\nM_{x,y}(t+\\Delta t) = M_{x,y}(t) \\, e^{-\\Delta t/T_2}\n$$\n$$\nM_z(t+\\Delta t) = M_z(t) \\, e^{-\\Delta t/T_1} + M_0(1 - e^{-\\Delta t/T_1})\n$$\n问题规定，这些操作（进动和弛豫）需在每个半 $TR$ 间隔内依次应用。\n\n**4. bSSFP-MRF 序列模拟**\n\n模拟对 $N=300$ 帧进行迭代。在每一帧 $n$ 中，对应于单个重复时间 $TR = 0.004\\,\\mathrm{s}$，执行以下步骤：\n1.  **RF 激励**：当前的磁化矢量 $\\mathbf{M}$ 绕 $x$ 轴旋转 $\\alpha_n$。\n2.  **演化至回波时间**：磁化在 $\\Delta t = TR/2 = 0.002\\,\\mathrm{s}$ 的持续时间内演化。这包括应用失谐进动旋转 $\\mathbf{R}_z(2\\pi \\Delta f (TR/2))$，然后是该时段的弛豫变换。\n3.  **信号采样**：在回波时间 $TE = TR/2$ 时，横向磁化的幅度被记录为指纹的第 $n$ 个样本：$S_n = \\sqrt{M_x^2 + M_y^2}$。\n4.  **演化至 TR 结束**：磁化继续在另一个 $\\Delta t = TR/2$ 的时间内演化，经历相同的进动和弛豫操作。得到的磁化矢量将作为第 $n+1$ 帧中下一个 RF 脉冲的输入。\n\n所有样本 $\\{S_n\\}_{n=0}^{N-1}$ 的集合构成了 MR 指纹 $\\mathbf{s}$，这是一个对于给定参数集 $(T_1, T_2, \\Delta f)$ 的唯一时间相关信号。\n\n**5. 模糊性量化**\n\n当不同的参数集产生高度相似的指纹时，就会出现模糊性，使得区分它们变得困难。这种相似性通过两个指纹 $\\mathbf{s}^{(A)}$ 和 $\\mathbf{s}^{(B)}$ 之间的皮尔逊相关系数 $\\rho$ 来量化：\n$$\n\\rho = \\frac{\\sum_{n=0}^{N-1} \\left(s^{(A)}_n - \\bar{s}^{(A)}\\right)\\left(s^{(B)}_n - \\bar{s}^{(B)}\\right)}{\\sqrt{\\sum_{n=0}^{N-1}\\left(s^{(A)}_n - \\bar{s}^{(A)}\\right)^2}\\,\\sqrt{\\sum_{n=0}^{N-1}\\left(s^{(B)}_n - \\bar{s}^{(B)}\\right)^2}}\n$$\n其中 $\\bar{s}$ 表示指纹信号的平均值。为具有零方差的指纹（即恒定信号）定义了一个特例：如果两个指纹相同，则 $\\rho = 1$；否则 $\\rho = 0$。\n\n如果相关性 $\\rho$ 严格大于指定阈值，即 $\\rho > \\rho_{\\mathrm{thr}}$，则声明存在模糊性。情况 1 中参数的选择旨在演示 bSSFP 成像中一个已知的模糊性。对于 $TR=0.004\\,\\mathrm{s}$，失谐频率 $\\Delta f = 125\\,\\mathrm{Hz}$ 和 $\\Delta f = 375\\,\\mathrm{Hz}$ 都会导致在一个 $TR$ 内累积的相位是 $\\pi$ 的奇数倍（$2\\pi \\cdot 125 \\cdot 0.004 = \\pi$ 和 $2\\pi \\cdot 375 \\cdot 0.004 = 3\\pi$），这会导致 bSSFP “条带” 特有的相消干涉和信号损失。尽管底层组织属性不同，这种共同的物理行为可能导致它们的指纹高度相关。\n\n提供的 Python 代码实现了这整个流程。它定义了执行模拟和相关性计算的函数，遍历测试用例，为每个用例评估模糊性条件，并将最终结果格式化为布尔值列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the MRF simulation for all test cases and print the results.\n    \"\"\"\n    \n    # --- Sequence and Simulation Constants ---\n    TR = 0.004  # Repetition Time in seconds\n    N = 300     # Number of frames\n    M0 = 1.0    # Equilibrium magnetization (unitless)\n    \n    # --- Pre-calculate Flip Angle Schedule ---\n    def get_flip_angle_schedule(num_frames):\n        \"\"\"Calculates the flip angle schedule in radians.\"\"\"\n        n = np.arange(num_frames)\n        alpha_deg = 10.0 + 45.0 * np.sin(2.0 * np.pi * n / 57.0)**2\n        return np.radians(alpha_deg)\n\n    FLIP_ANGLES_RAD = get_flip_angle_schedule(N)\n\n    # --- Core Simulation Functions ---\n    def get_rx_matrix(angle_rad):\n        \"\"\"Returns the 3x3 rotation matrix for a rotation about the x-axis.\"\"\"\n        c, s = np.cos(angle_rad), np.sin(angle_rad)\n        return np.array([\n            [1.0, 0.0, 0.0],\n            [0.0, c,  -s],\n            [0.0, s,   c]\n        ])\n\n    def get_rz_matrix(angle_rad):\n        \"\"\"Returns the 3x3 rotation matrix for a rotation about the z-axis.\"\"\"\n        c, s = np.cos(angle_rad), np.sin(angle_rad)\n        return np.array([\n            [c,  -s,   0.0],\n            [s,   c,   0.0],\n            [0.0, 0.0, 1.0]\n        ])\n\n    def evolve_state(M, dt, T1, T2, df):\n        \"\"\"\n        Evolves the magnetization state over a time interval dt, applying\n        off-resonance precession and T1/T2 relaxation.\n        \"\"\"\n        # 1. Off-resonance precession\n        phi = 2.0 * np.pi * df * dt\n        Rz = get_rz_matrix(phi)\n        M_precessed = Rz @ M\n\n        # 2. Relaxation\n        E1 = np.exp(-dt / T1)\n        E2 = np.exp(-dt / T2)\n        \n        M_out = np.zeros(3)\n        M_out[0] = M_precessed[0] * E2\n        M_out[1] = M_precessed[1] * E2\n        M_out[2] = M_precessed[2] * E1 + M0 * (1.0 - E1)\n        \n        return M_out\n\n    def simulate_fingerprint(T1, T2, df):\n        \"\"\"\n        Simulates the bSSFP MRF signal (fingerprint) for a given set of parameters.\n        \"\"\"\n        M = np.array([0.0, 0.0, M0])\n        fingerprint = np.zeros(N)\n        dt_half = TR / 2.0\n\n        for i in range(N):\n            # 1. RF pulse (rotation about x-axis)\n            alpha_rad = FLIP_ANGLES_RAD[i]\n            Rx = get_rx_matrix(alpha_rad)\n            M = Rx @ M\n\n            # 2. Evolve for the first half of TR (to echo time)\n            M_at_te = evolve_state(M, dt_half, T1, T2, df)\n\n            # 3. Record fingerprint sample (magnitude of transverse magnetization)\n            fingerprint[i] = np.sqrt(M_at_te[0]**2 + M_at_te[1]**2)\n            \n            # 4. Evolve for the second half of TR (to end of TR)\n            M = evolve_state(M_at_te, dt_half, T1, T2, df)\n            \n        return fingerprint\n\n    # --- Ambiguity Quantification Function ---\n    def pearson_correlation(s_a, s_b):\n        \"\"\"\n        Computes the Pearson correlation coefficient between two signals,\n        with special handling for zero-variance signals as per the problem spec.\n        \"\"\"\n        mean_a, mean_b = np.mean(s_a), np.mean(s_b)\n        dev_a, dev_b = s_a - mean_a, s_b - mean_b\n        \n        sum_sq_dev_a = np.sum(dev_a**2)\n        sum_sq_dev_b = np.sum(dev_b**2)\n        \n        # Use np.isclose for robust floating-point comparison to zero\n        is_a_const = np.isclose(sum_sq_dev_a, 0)\n        is_b_const = np.isclose(sum_sq_dev_b, 0)\n\n        # Handle special cases for zero variance as per problem description\n        if is_a_const and is_b_const:\n            return 1.0 if np.allclose(s_a, s_b) else 0.0\n        \n        if is_a_const or is_b_const:\n            # Denominator is zero, so correlation is ill-defined.\n            # In this context, it implies no linear relationship.\n            return 0.0\n            \n        # Standard Pearson correlation calculation\n        numerator = np.sum(dev_a * dev_b)\n        denominator = np.sqrt(sum_sq_dev_a * sum_sq_dev_b)\n        \n        return numerator / denominator\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1: Ambiguity due to banding\n        ((1.2, 0.08, 125), (0.6, 0.06, 375), 0.95),\n        # Case 2: Non-ambiguous scenario\n        ((1.2, 0.08, 0), (0.6, 0.06, 50), 0.95),\n        # Case 3: Near-band but offset off-resonance\n        ((1.0, 0.1, 125), (0.7, 0.07, 360), 0.95),\n        # Case 4: Threshold boundary check (identity)\n        ((1.0, 0.1, 125), (1.0, 0.1, 125), 1.0)\n    ]\n\n    results = []\n    for params_A, params_B, rho_thr in test_cases:\n        # Generate fingerprint for parameter set A\n        fp_A = simulate_fingerprint(T1=params_A[0], T2=params_A[1], df=params_A[2])\n        \n        # Generate fingerprint for parameter set B\n        fp_B = simulate_fingerprint(T1=params_B[0], T2=params_B[1], df=params_B[2])\n        \n        # Compute correlation and check for ambiguity\n        corr = pearson_correlation(fp_A, fp_B)\n        is_ambiguous = corr > rho_thr\n        results.append(is_ambiguous)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生成指纹后，下一步是将测量的信号与预先计算的字典进行匹配。测量数据的统计特性对这一步至关重要。本练习（）探讨了匹配包含相位信息的复数值数据（受高斯噪声影响）与仅使用幅度的信号（服从更复杂的莱斯噪声分布）之间的差异。理解这些噪声模型对于设计稳健的匹配算法和解释结果至关重要，因为在幅值和复数匹配之间的选择对MRF的准确性和可靠性有着深远的影响。",
            "id": "4902005",
            "problem": "一项先进的单体素磁共振指纹成像（Magnetic Resonance Fingerprinting, MRF）实验采集了一系列复数测量值的时间序列 $y_t \\in \\mathbb{C}$（$t = 1,\\dots,T$），其模型为 $y_t = s_t + n_t$，其中 $s_t$ 是由组织参数和序列设计决定的真实复数信号演变，而 $n_t$ 是加性接收器噪声。在磁共振（Magnetic Resonance, MR）系统中，一个公认的事实是，在形成模值之前，同相和正交通道中的噪声近似独立、零均值、等方差的高斯噪声，因此 $n_t$ 是循环对称的复高斯噪声，其协方差为 $\\sigma^2 I$（对于某个 $\\sigma > 0$）。模值重建在每个时间点上形成 $m_t = |y_t|$。一个由模拟时间信号组成的字典 $\\{d^{(k)}\\}_{k=1}^K$ 是可用的，其中每个 $d^{(k)}$ 要么是复数值（保留相位），要么是非负实数值（仅模值），并通过归一化内积（余弦相似度）计算相似性得分。具体来说，对于仅模值匹配，一个常用的得分是\n$$\nc^{(k)}_{\\text{mag}} = \\frac{\\sum_{t=1}^T m_t\\, d^{(k)}_t}{\\left(\\sum_{t=1}^T m_t^2\\right)^{1/2} \\left(\\sum_{t=1}^T \\left(d^{(k)}_t\\right)^2\\right)^{1/2}},\n$$\n而对于保留相位的复数匹配，一个常用的得分是\n$$\nc^{(k)}_{\\text{cplx}} = \\frac{\\left|\\sum_{t=1}^T y_t \\,\\overline{d^{(k)}_t}\\right|}{\\left(\\sum_{t=1}^T |y_t|^2\\right)^{1/2} \\left(\\sum_{t=1}^T |d^{(k)}_t|^2\\right)^{1/2}}.\n$$\n假设噪声在时间点之间独立，噪声方差在时间上恒定，且数据经过白化，因此协方差为 $\\sigma^2 I$。信噪比（Signal-to-Noise Ratio, SNR）被理解为逐点的 $|s_t|/\\sigma$。\n\n根据复高斯噪声模型和模值运算的基本原理，定义 $m_t$ 的分布（它属于哪个分布族及其参数），并论证其对 $m_t$ 的期望和方差作为 $|s_t|$ 的函数所产生的影响。然后，解释在使用仅模值数据 $m_t$ 与使用带白高斯噪声的保留相位的复数数据 $y_t$ 时，这对基于相关的指纹匹配有何影响。特别地，比较噪声模型如何与归一化内积相似性相互作用，以及其与最大似然（Maximum Likelihood, ML）决策规则的关系。\n\n以下哪个选项最准确地捕捉了正确的定义和关键影响？\n\nA. 当 $y_t$ 具有标准差为 $\\sigma$ 的循环复高斯噪声时，$m_t = |y_t|$ 的边际分布是莱斯分布（Rician distribution），其非中心性参数为 $\\nu_t = |s_t|$，尺度参数为 $\\sigma$。这在低信噪比时会引起正向偏差 $E[m_t] > |s_t|$，并导致 $m_t$ 的方差依赖于 $|s_t|$。这可能会夸大与具有非零基线幅度的字典条目之间的归一化相关性。相比之下，对于保留相位的复数数据和白高斯噪声，最大化白化内积或最小化平方误差与最大似然（ML）规则一致，使得 $c^{(k)}_{\\text{cplx}}$ 与一个最优统计量密切相关。\n\nB. $m_t$ 中的莱斯噪声是零均值且关于零对称的，因此使用模值数据的余弦相似性是无偏的。复高斯噪声否定了这一特性，因为随机相位会使 $y_t$ 的符号波动，从而向下偏置 $c^{(k)}_{\\text{cplx}}$。\n\nC. 在莱斯噪声下，$m_t$ 的方差与真实幅度 $|s_t|$ 无关，因此余弦相似性的分布在不同指纹间是不变的；在复高斯噪声下，方差依赖于 $|s_t|$，因此仅对保留相位的数据需要进行白化。\n\nD. 对于带有莱斯噪声的模值数据，精确的最大似然（ML）匹配简化为最大化未加权的归一化内积 $c^{(k)}_{\\text{mag}}$，因此基于相关的匹配是最优的；对于复高斯数据，欧几里得距离匹配相对于相关性而言是严格次优的。\n\nE. 因为模值运算去除了相位，所以模值时间序列完全不能用于指纹成像；无论噪声模型如何，只有保留相位的复数数据才允许有意义的匹配。",
            "solution": "该问题要求分析在磁共振指纹成像（MRF）背景下，仅模值数据与保留相位的复数数据在统计特性上的差异，并评估这对基于相关的字典匹配的影响。\n\n### 步骤1：从基本原理推导\n\n**复数数据模型分析**\n\n单个时间点 $t$ 的测量模型为：\n$$ y_t = s_t + n_t $$\n其中 $y_t \\in \\mathbb{C}$ 是测量的复数信号，$s_t \\in \\mathbb{C}$ 是真实的复数信号，$n_t \\in \\mathbb{C}$ 是加性噪声。\n\n噪声 $n_t$ 被描述为循环对称复高斯噪声。这意味着它的实部和虚部（我们称之为 $n_{I,t}$ 和 $n_{Q,t}$）是独立同分布（i.i.d.）的零均值高斯随机变量。设它们的方差为 $\\sigma^2$。\n$$ n_{I,t} \\sim \\mathcal{N}(0, \\sigma^2) $$\n$$ n_{Q,t} \\sim \\mathcal{N}(0, \\sigma^2) $$\n\n让我们用实部（同相, $I$）和虚部（正交, $Q$）分量来表示信号：\n$s_t = s_{I,t} + i s_{Q,t}$\n$y_t = y_{I,t} + i y_{Q,t} = (s_{I,t} + n_{I,t}) + i (s_{Q,t} + n_{Q,t})$\n\n因此，测量信号 $y_t$ 的分量是具有非零均值的独立高斯随机变量：\n$$ y_{I,t} \\sim \\mathcal{N}(s_{I,t}, \\sigma^2) $$\n$$ y_{Q,t} \\sim \\mathcal{N}(s_{Q,t}, \\sigma^2) $$\n\n复数域中的噪声是加性的，其统计特性（即其方差）与信号 $s_t$ 无关。\n\n**使用复数数据的最大似然 (ML) 估计**\n\n对于一个时间序列 $\\mathbf{y} = [y_1, \\dots, y_T]^T$ 和一个由可能的真实信号组成的字典 $\\{\\mathbf{d}^{(k)}\\}_{k=1}^K$，最大似然（ML）决策规则是选择使观察到 $\\mathbf{y}$ 的概率最大化的字典条目 $\\mathbf{d}^{(k)}$。假设噪声 $n_t$ 在时间上是独立同分布的（白噪声），对数似然函数为：\n$$ \\mathcal{L}(k | \\mathbf{y}) = \\log P(\\mathbf{y} | \\mathbf{d}^{(k)}) = \\log \\prod_{t=1}^T P(y_t | d^{(k)}_t) $$\n对于复高斯噪声，$P(y_t | d^{(k)}_t) \\propto \\exp\\left(-\\frac{|y_t - d^{(k)}_t|^2}{2\\sigma^2_{total}}\\right)$，其中 $\\sigma^2_{total}$ 是复噪声的总方差（此处为 $2\\sigma^2$）。\n$$ \\mathcal{L}(k | \\mathbf{y}) = C - \\sum_{t=1}^T \\frac{|y_t - d^{(k)}_t|^2}{2\\sigma^2_{total}} $$\n其中 $C$ 是一个与 $k$ 无关的常数。最大化似然等价于最小化欧几里得距离的平方和：\n$$ \\hat{k}_{\\text{ML}} = \\arg \\min_k \\sum_{t=1}^T |y_t - d^{(k)}_t|^2 $$\n展开平方距离：\n$$ \\sum_{t=1}^T |y_t - d^{(k)}_t|^2 = \\sum_{t=1}^T |y_t|^2 - 2 \\text{Re}\\left\\{\\sum_{t=1}^T y_t \\overline{d^{(k)}_t}\\right\\} + \\sum_{t=1}^T |d^{(k)}_t|^2 $$\n由于 $\\sum |y_t|^2$ 与 $k$ 无关，最小化平方距离等价于最大化 $2 \\text{Re}\\left\\{\\sum y_t \\overline{d^{(k)}_t}\\right\\} - \\sum |d^{(k)}_t|^2$。如果所有字典条目都经过归一化，使得 $\\sum |d^{(k)}_t|^2$ 为常数，则这简化为最大化内积 $\\sum y_t \\overline{d^{(k)}_t}$ 的实部。\n\n相似性得分 $c^{(k)}_{\\text{cplx}}$ 使用了内积的模值 $\\left|\\sum y_t \\overline{d^{(k)}_t}\\right|$，并对其进行归一化。这是一个微小的修改，使得匹配对于测量和字典之间的未知全局相位偏移具有鲁棒性，这是一个常见的实际问题。因为它直接源于内积，而内积是加性白高斯噪声的最大似然估计量的核心（它是一个匹配滤波器），所以 $c^{(k)}_{\\text{cplx}}$ 是一个统计上合理且接近最优的统计量。\n\n**模值数据模型分析**\n\n模值重建为 $m_t = |y_t| = \\sqrt{y_{I,t}^2 + y_{Q,t}^2}$。两个独立、方差为 $\\sigma^2$、均值分别为 $s_{I,t}$ 和 $s_{Q,t}$ 的高斯随机变量的平方和的平方根的分布是**莱斯分布（Rician distribution）**。\n该分布的参数为：\n- **非中心性参数 $\\nu_t$**：这是均值向量的模，$\\nu_t = \\sqrt{s_{I,t}^2 + s_{Q,t}^2} = |s_t|$。\n- **尺度参数 $\\sigma$**：这是底层高斯分量的标准差，即 $\\sigma$。\n\n因此，测量模值的分布为 $m_t \\sim \\text{Rice}(|s_t|, \\sigma)$。\n\n**莱斯分布的性质**\n1.  **期望 $E[m_t]$**：莱斯变量的期望值不等于非中心性参数 $|s_t|$。\n    -   在低信噪比（SNR）极限下，当 $|s_t|/\\sigma \\to 0$ 时，莱斯分布趋近于瑞利分布（Rayleigh distribution），其均值趋近于 $E[m_t] \\to \\sigma\\sqrt{\\pi/2}$。由于 $|s_t| \\approx 0$，这意味着 $E[m_t] > |s_t|$。这产生了一个**正向偏差**；噪声不会平均到零，而是产生一个正的模值“噪声基底”。\n    -   在高信噪比极限下，当 $|s_t|/\\sigma \\to \\infty$ 时，莱斯分布趋近于均值为 $|s_t|$ 的高斯分布，因此 $E[m_t] \\to |s_t|$。偏差减小但仍然为正。\n\n2.  **方差 $\\text{Var}(m_t)$**：莱斯变量的方差由 $\\text{Var}(m_t) = 2\\sigma^2 + |s_t|^2 - (E[m_t])^2$ 给出。这个表达式清楚地表明，方差**依赖于真实信号幅度 $|s_t|$**。因此，模值信号上的噪声不是加性的，其方差也不是恒定的。\n\n**使用模值数据的最大似然 (ML) 估计**\n给定一个字典条目 $\\{d^{(k)}_t\\}$，观察到模值序列 $\\{m_t\\}$ 的对数似然为：\n$$ \\mathcal{L}(k | \\mathbf{m}) = \\sum_{t=1}^T \\log\\left( f(m_t\\big||d^{(k)}_t|, \\sigma) \\right) $$\n其中 $f(x|\\nu,\\sigma) = \\frac{x}{\\sigma^2} \\exp\\left(-\\frac{x^2+\\nu^2}{2\\sigma^2}\\right) I_0\\left(\\frac{x\\nu}{\\sigma^2}\\right)$ 是莱斯概率密度函数，$I_0$ 是第一类修正贝塞尔函数。这个对数似然函数很复杂，并不能简化为归一化内积 $c^{(k)}_{\\text{mag}}$。因此，使用 $c^{(k)}_{\\text{mag}}$ 是一种启发式方法，而不是最大似然估计量。莱斯噪声的信号相关偏差和方差意味着简单的余弦相似性度量在统计上不是最优的，并且可能具有误导性。例如，正向偏差可能会夸大与那些在整个采集中都具有低幅度信号的错误字典条目之间的相关性得分，因为测量中的噪声基底会与字典的非零基线相关。\n\n### 步骤2：逐项分析\n\n**A. 当 $y_t$ 具有标准差为 $\\sigma$ 的循环复高斯噪声时，$m_t = |y_t|$ 的边际分布是莱斯分布（Rician distribution），其非中心性参数为 $\\nu_t = |s_t|$，尺度参数为 $\\sigma$。这在低信噪比时会引起正向偏差 $E[m_t] > |s_t|$，并导致 $m_t$ 的方差依赖于 $|s_t|$。这可能会夸大与具有非零基线幅度的字典条目之间的归一化相关性。相比之下，对于保留相位的复数数据和白高斯噪声，最大化白化内积或最小化平方误差与最大似然（ML）规则一致，使得 $c^{(k)}_{\\text{cplx}}$ 与一个最优统计量密切相关。**\n- 此选项正确地将 $m_t$ 的分布确定为具有正确参数的莱斯分布。\n- 它正确地指出，这种分布在低信噪比时会导致正向偏差和信号相关的方差。\n- 它正确地推断出一个有效的影响：该偏差会夸大相关性，从而降低匹配性能。\n- 它正确地将其与复数数据的情况进行了对比，即对于白高斯噪声，最小化平方误差是最大似然原则，而基于内积的得分 $c^{(k)}_{\\text{cplx}}$ 与这种最优方法密切相关。\n- **结论：正确。**\n\n**B. $m_t$ 中的莱斯噪声是零均值且关于零对称的，因此使用模值数据的余弦相似性是无偏的。复高斯噪声否定了这一特性，因为随机相位会使 $y_t$ 的符号波动，从而向下偏置 $c^{(k)}_{\\text{cplx}}$。**\n- 莱斯分布是针对模值的，而模值总是非负的（$m_t \\ge 0$），所以它不可能是零均值或关于零对称的。这个前提根本上是错误的。\n- 复高斯噪声 $n_t$ 是零均值的，$E[n_t]=0$，因此不会在内积计算中引入系统性偏差，因为 $E[\\sum (s_t+n_t) \\overline{d^{(k)}_t}] = \\sum s_t \\overline{d^{(k)}_t}$。该陈述不正确。\n- **结论：错误。**\n\n**C. 在莱斯噪声下，$m_t$ 的方差与真实幅度 $|s_t|$ 无关，因此余弦相似性的分布在不同指纹间是不变的；在复高斯噪声下，方差依赖于 $|s_t|$，因此仅对保留相位的数据需要进行白化。**\n- 如推导所示，莱斯分布变量的方差 $\\text{Var}(m_t)$ 明确依赖于 $|s_t|$。陈述的第一部分是错误的。\n- 对于带有加性复高斯噪声的复数数据，测量值 $y_t$ 的方差是噪声的方差，它与信号 $s_t$ 无关。陈述的第二部分也是错误的。该选项的陈述与事实正好相反。\n- **结论：错误。**\n\n**D. 对于带有莱斯噪声的模值数据，精确的最大似然（ML）匹配简化为最大化未加权的归一化内积 $c^{(k)}_{\\text{mag}}$，因此基于相关的匹配是最优的；对于复高斯数据，欧几里得距离匹配相对于相关性而言是严格次优的。**\n- 莱斯噪声的最大似然估计量涉及贝塞尔函数 $I_0$，并且不能简化为归一化内积。因此，$c^{(k)}_{\\text{mag}}$ 不是最优的最大似然估计量。第一部分是错误的。\n- 对于复高斯数据，最小化欧几里得距离等价于最大似然规则。因此它是最优的，而不是“严格次优的”。第二部分是错误的。\n- **结论：错误。**\n\n**E. 因为模值运算去除了相位，所以模值时间序列完全不能用于指纹成像；无论噪声模型如何，只有保留相位的复数数据才允许有意义的匹配。**\n- 这是一个夸大其词且事实上不正确的说法。使用模值数据的MRF是一种广泛应用的技术。虽然它在统计上可能不是最优的，并且会丢失信号相位中包含的信息，但模值演变曲线通常包含足够的信息来区分不同的组织。因此，这是一种“有意义的”即使不是最优的方法。\n- **结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}