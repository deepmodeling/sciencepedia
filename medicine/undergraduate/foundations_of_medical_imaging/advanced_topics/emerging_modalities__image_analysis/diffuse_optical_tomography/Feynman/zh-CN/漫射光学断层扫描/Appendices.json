{
    "hands_on_practices": [
        {
            "introduction": "本练习是模拟组织中光传输的理论基础。我们将把描述光传播的扩散方程，转化为计算机可以求解的矩阵形式。通过对一个具有可变组织特性的一维简化案例进行手动计算，你将迈出理解如何对复杂生物结构进行数值建模的关键第一步。",
            "id": "4876878",
            "problem": "考虑在漫射光学断层成像 (Diffuse Optical Tomography, DOT) 中使用的稳态扩散近似，其中非均匀介质中的光子注量率场 $\\Phi(\\mathbf{r})$ 满足偏微分方程\n$$\n-\\nabla \\cdot \\left( D(\\mathbf{r}) \\nabla \\Phi(\\mathbf{r}) \\right) + \\mu_{a}(\\mathbf{r}) \\, \\Phi(\\mathbf{r}) = q(\\mathbf{r}),\n$$\n其中 $D(\\mathbf{r})$ 是扩散系数，$\\mu_{a}(\\mathbf{r})$ 是吸收系数，$q(\\mathbf{r})$ 是一个体源。假设一个一维平板几何结构，空间坐标为 $x \\in [0, L]$，因此 $\\mathbf{r} \\mapsto x$，并假设边界条件为：在 $x=0$ 处为无通量（齐次诺伊曼）边界，\n$$\n-D(0) \\, \\frac{d \\Phi}{dx}(0) = 0,\n$$\n在 $x=L$ 处为罗宾边界条件，模拟组织-空气界面处的部分电流，\n$$\n-D(L) \\, \\frac{d \\Phi}{dx}(L) + \\alpha \\, \\Phi(L) = 0,\n$$\n其中 $\\alpha > 0$ 是一个给定的边界系数。设 $D(x) = D_{0} \\left( 1 + \\beta \\, \\frac{x}{L} \\right)$ 和 $\\mu_{a}(x) = \\mu_{0} \\left( 1 + \\gamma \\, \\frac{x}{L} \\right)$，其中 $D_{0} > 0$，$\\mu_{0} > 0$，以及无量纲参数 $\\beta$、$\\gamma$。\n\n从控制方程和边界条件出发，使用标准的 Galerkin 方法和检验函数 $w \\in H^{1}(0,L)$ 推导弱（变分）形式，确保边界项得到正确处理。然后，使用连续分段线性有限元在网格上离散化弱形式，该网格的节点位于 $x_{1} = 0$、$x_{2} = \\frac{L}{2}$ 和 $x_{3} = L$，这定义了两个线性单元：$e_{1} = [0, \\frac{L}{2}]$ 和 $e_{2} = [\\frac{L}{2}, L]$。令 $\\{ N_{1}(x), N_{2}(x), N_{3}(x) \\}$ 表示与这些节点相关的标准节点基函数，并令 $\\Phi(x) \\approx \\sum_{i=1}^{3} \\phi_{i} \\, N_{i}(x)$ 为有限元近似。\n\n使用 Galerkin 方法，当 $D(x)$ 和 $\\mu_{a}(x)$ 如给定那样空间变化时，推导两个单元 $e_{1}$ 和 $e_{2}$ 的单元级刚度矩阵 $\\mathbf{K}^{(e)}$ 和质量矩阵 $\\mathbf{M}^{(e)}$。从单元贡献中组装全局刚度矩阵 $\\mathbf{K}$ 和全局质量矩阵 $\\mathbf{M}$（尺寸为 $3 \\times 3$），并确定与位于 $x = \\frac{L}{2}$ 的内部节点相关的组装后矩阵元素 $K_{22}$ 和 $M_{22}$。\n\n定义标量\n$$\nS \\equiv K_{22} + M_{22}.\n$$\n将您对 $S$ 的最终答案表示为关于 $D_{0}$、$\\beta$、$\\mu_{0}$、$\\gamma$ 和 $L$ 的单个闭式解析表达式。不要进行任何数值代入。无需四舍五入。由于在此一维公式中 $S$ 是无量纲的，因此答案中无需包含单位。",
            "solution": "起点是在定义域 $x \\in [0, L]$ 上的一维稳态扩散方程：\n$$\n-\\frac{d}{dx} \\left( D(x) \\frac{d\\Phi}{dx} \\right) + \\mu_{a}(x) \\, \\Phi(x) = q(x)\n$$\n为了推导弱（变分）形式，我们将控制微分方程乘以一个足够光滑的检验函数 $w(x) \\in H^{1}(0,L)$ 并在定义域 $[0, L]$ 上积分：\n$$\n\\int_{0}^{L} \\left( -\\frac{d}{dx} \\left( D(x) \\frac{d\\Phi}{dx} \\right) w(x) + \\mu_{a}(x) \\, \\Phi(x) \\, w(x) \\right) dx = \\int_{0}^{L} q(x) \\, w(x) dx\n$$\n对第一项应用分部积分法得到：\n$$\n\\int_{0}^{L} D(x) \\frac{d\\Phi}{dx} \\frac{dw}{dx} dx - \\left[ D(x) \\frac{d\\Phi}{dx} w(x) \\right]_{0}^{L} + \\int_{0}^{L} \\mu_{a}(x) \\, \\Phi(x) \\, w(x) dx = \\int_{0}^{L} q(x) \\, w(x) dx\n$$\n边界项为 $- [ D(L) \\frac{d\\Phi}{dx}(L) w(L) - D(0) \\frac{d\\Phi}{dx}(0) w(0) ]$。根据给定的边界条件：\n1.  在 $x=0$ 处：齐次诺伊曼（无通量）条件，$-D(0) \\frac{d\\Phi}{dx}(0) = 0$，即 $D(0) \\frac{d\\Phi}{dx}(0) = 0$。\n2.  在 $x=L$ 处：罗宾条件，$-D(L) \\frac{d\\Phi}{dx}(L) + \\alpha \\, \\Phi(L) = 0$，即 $D(L) \\frac{d\\Phi}{dx}(L) = \\alpha \\, \\Phi(L)$。\n\n将这些代入边界项表达式中，得到 $- [ (\\alpha \\, \\Phi(L)) w(L) - 0 ] = -\\alpha \\, \\Phi(L) w(L)$。\n代回原方程，我们得到弱形式：求 $\\Phi \\in H^1(0,L)$，使得对于所有 $w \\in H^1(0,L)$：\n$$\n\\int_{0}^{L} \\left( D(x) \\frac{d\\Phi}{dx} \\frac{dw}{dx} + \\mu_{a}(x) \\, \\Phi(x) \\, w(x) \\right) dx - \\alpha \\, \\Phi(L) w(L) = \\int_{0}^{L} q(x) \\, w(x) dx\n$$\n注意，此处的罗宾边界条件 $-D\\Phi'+\\alpha\\Phi=0$ 对应于一个内向通量（$J_x(L) = -D\\Phi'(L)=-\\alpha\\Phi(L)$），这在物理上可能不常见，但数学上是明确的。\n\n我们使用 Galerkin 方法进行离散化。令 $\\Phi(x) \\approx \\Phi_h(x) = \\sum_{j=1}^{3} \\phi_j N_j(x)$，并选择检验函数 $w(x)$ 为基函数 $N_i(x)$。这产生一个线性方程组 $\\mathbf{A\\phi} = \\mathbf{f}$。系统矩阵的元素为 $A_{ij} = K_{ij} + M_{ij}$，其中：\n$K_{ij} = \\int_{0}^{L} D(x) \\frac{dN_j}{dx}\\frac{dN_i}{dx} dx$。\n$M_{ij} = \\int_{0}^{L} \\mu_a(x) N_j(x) N_i(x) dx$。\n注意，罗宾边界项只影响与边界节点 $x_3=L$ 相关的矩阵元素，不影响我们关心的 $K_{22}$ 和 $M_{22}$。\n\n我们需要计算全局矩阵元素 $K_{22}$ 和 $M_{22}$。它们由单元级贡献组装而成。节点 $2$（在 $x=L/2$ 处）是单元 $e_1 = [0, L/2]$ 的右节点，也是单元 $e_2 = [L/2, L]$ 的左节点。因此，$K_{22} = K_{22}^{(1)} + K_{11}^{(2)}$ 且 $M_{22} = M_{22}^{(1)} + M_{11}^{(2)}$，其中上标表示单元，下标表示该单元内的局部节点编号。\n\n对于一个在 $[x_a, x_b]$ 上长度为 $h$ 的一般线性单元，局部基函数的导数是 $\\frac{dN_a}{dx} = -1/h$ 和 $\\frac{dN_b}{dx} = 1/h$。\n\n**单元 1: $e_1 = [0, L/2]$**\n单元长度为 $h_1 = L/2$。\n$K_{22}^{(1)} = \\int_0^{L/2} D(x) \\left(\\frac{dN_2^{(1)}}{dx}\\right)^2 dx = \\frac{1}{h_1^2} \\int_0^{L/2} D_0\\left(1+\\beta\\frac{x}{L}\\right) dx = \\frac{4}{L^2} D_0 \\left[x + \\frac{\\beta x^2}{2L}\\right]_0^{L/2} = \\frac{D_0}{L}\\left(2+\\frac{\\beta}{2}\\right)$。\n\n$M_{22}^{(1)} = \\int_0^{L/2} \\mu_a(x) (N_2^{(1)}(x))^2 dx = \\int_0^{L/2} \\mu_0\\left(1+\\gamma\\frac{x}{L}\\right) \\left(\\frac{x}{L/2}\\right)^2 dx = \\mu_0 \\frac{4}{L^2} \\left[\\frac{x^3}{3}+\\frac{\\gamma x^4}{4L}\\right]_0^{L/2} = \\mu_0 L \\left(\\frac{1}{6} + \\frac{\\gamma}{16}\\right)$。\n\n**单元 2: $e_2 = [L/2, L]$**\n单元长度为 $h_2 = L/2$。\n$K_{11}^{(2)} = \\int_{L/2}^L D(x) \\left(\\frac{dN_1^{(2)}}{dx}\\right)^2 dx = \\frac{1}{h_2^2} \\int_{L/2}^L D_0\\left(1+\\beta\\frac{x}{L}\\right) dx = \\frac{4}{L^2} D_0 \\left[x + \\frac{\\beta x^2}{2L}\\right]_{L/2}^L = \\frac{D_0}{L}\\left(2+\\frac{3\\beta}{2}\\right)$。\n\n$M_{11}^{(2)} = \\int_{L/2}^L \\mu_a(x) (N_1^{(2)}(x))^2 dx = \\int_{L/2}^L \\mu_0\\left(1+\\gamma\\frac{x}{L}\\right) \\left(\\frac{L-x}{L/2}\\right)^2 dx$。\n令 $u=x-L/2$，则 $x=u+L/2$。\n$M_{11}^{(2)} = \\int_0^{L/2} \\mu_0\\left(1+\\gamma\\frac{u+L/2}{L}\\right) \\left(\\frac{L/2-u}{L/2}\\right)^2 du = \\mu_0 \\int_0^{L/2} \\left(1+\\frac{\\gamma}{2}+\\frac{\\gamma u}{L}\\right) \\left(1-\\frac{2u}{L}\\right)^2 du$。\n积分后得到：$M_{11}^{(2)} = \\mu_0 L \\left(\\frac{1}{6} + \\frac{5\\gamma}{48}\\right)$。\n\n**全局元素的组装**\n$K_{22} = K_{22}^{(1)} + K_{11}^{(2)} = \\frac{D_0}{L}\\left(2+\\frac{\\beta}{2}\\right) + \\frac{D_0}{L}\\left(2+\\frac{3\\beta}{2}\\right) = \\frac{D_0}{L}(4 + 2\\beta) = \\frac{2D_0}{L}(2+\\beta)$。\n$M_{22} = M_{22}^{(1)} + M_{11}^{(2)} = \\mu_0 L \\left(\\frac{1}{6} + \\frac{\\gamma}{16}\\right) + \\mu_0 L \\left(\\frac{1}{6} + \\frac{5\\gamma}{48}\\right) = \\mu_0 L \\left(\\frac{1}{3} + \\frac{3\\gamma+5\\gamma}{48}\\right) = \\mu_0 L \\left(\\frac{1}{3} + \\frac{\\gamma}{6}\\right) = \\frac{\\mu_0 L}{6}(2+\\gamma)$。\n\n**$S$ 的最终计算**\n标量 $S$ 定义为和 $S = K_{22} + M_{22}$。\n$$\nS = \\frac{2D_0(2+\\beta)}{L} + \\frac{\\mu_0 L(2+\\gamma)}{6}\n$$\n该表达式为最终答案，表示与中心节点相关的系统矩阵 $(\\mathbf{K}+\\mathbf{M})$ 的组装后对角元素。",
            "answer": "$$\n\\boxed{\\frac{2 D_{0} (2 + \\beta)}{L} + \\frac{\\mu_{0} L (2 + \\gamma)}{6}}\n$$"
        },
        {
            "introduction": "在推导出理论部分之后，下一步是建立一个可运行的仿真程序。本练习将指导你用代码实现有限元方法，处理真实的物理边界条件，更重要的是，通过与已知的解析解进行比较来验证你的代码的准确性。这种实现与验证的过程是任何计算科学家的核心技能，它确保了我们的工具在用于解决复杂问题之前的可靠性。",
            "id": "4876870",
            "problem": "考虑在漫射光学断层成像 (DOT) 中使用的稳态扩散近似，它将光子注量率建模为标量场 $u(x)$，该标量场在区间 $[0,L]$ 上满足一维扩散方程：\n$$- \\frac{d}{dx}\\left(D \\frac{du}{dx}\\right) + \\mu_a u = 0 \\quad \\text{for} \\quad x \\in (0,L),$$ \n其中 $D>0$ 是扩散系数，$\\mu_a>0$ 是吸收系数。在边界 $x=0$ 处施加一个具有物理动机的 Robin 边界条件来表示部分内反射，\n$$-D \\frac{du}{dx}(0) + \\sigma u(0) = s,$$\n其中 $\\sigma \\ge 0$ 且 $s \\ge 0$，并强制 $u(L) = 0$ 以近似 $x \\to \\infty$ 时 $u(x) \\to 0$。参数 $D$、$\\mu_a$、$\\sigma$、$s$、$L$ 均为实值常数。\n\n任务：\n- 从强形式和 Green 恒等式出发，使用满足在 $x=L$ 处的齐次 Dirichlet 条件的任意光滑测试函数 $v(x)$，推导弱形式。明确写出双线性形式 $a(u,v)$ 和线性泛函 $F(v)$。\n- 通过证明存在一个仅依赖于 $D$、$\\mu_a$ 和 $\\sigma$ 的常数 $c>0$，使得对于所有容许函数 $u$，双线性形式具有能量稳定性（矫顽性），\n$$a(u,u) \\ge c \\|u\\|_{H^1(0,L)}^2,$$\n其中 $\\|u\\|_{H^1(0,L)}^2 = \\int_0^L \\left( |u'(x)|^2 + |u(x)|^2 \\right) dx$。\n- 在一维有限元方法 (FEM) 中实现 Robin 边界条件，该方法在 $[0,L]$ 上的 $N$ 个单元的均匀网格上使用连续分段线性基函数，并组装与弱形式一致的线性系统 $A \\mathbf{u} = \\mathbf{b}$。\n- 在相同的左边界条件和 $u(\\infty)=0$ 的条件下，获得在 $[0,\\infty)$ 上的解析半无限解，并将其用作参考，以评估在 $[0,L]$ 上且 $u(L)=0$ 的有限元解的数值收敛性。计算有限元解 $u_h(x)$ 和解析解 $u(x)$ 之间误差的 $L^2$ 范数，\n$$\\|u_h - u\\|_{L^2(0,L)} = \\left( \\int_0^L |u_h(x) - u(x)|^2 \\, dx \\right)^{1/2}.$$\n- 通过计算观测到的收敛阶来验证收敛性\n$$p = \\frac{\\log\\left(E_{h_1}/E_{h_2}\\right)}{\\log\\left(h_1/h_2\\right)},$$\n其中 $E_{h_i}$ 是网格尺寸为 $h_i$ 时的 $L^2$ 误差，且 $h_2 = h_1/2$（细化网格）。\n- 通过检查组装的刚度矩阵 $A$ 是否为对称正定（对于施加在 $x=L$ 处的 Dirichlet 边界条件后的自由度）来数值验证能量稳定性。\n\n您的程序必须实现这些步骤，并为每个测试用例生成以下输出：\n- 从两个连续的均匀网格（$N$ 和 $2N$）计算出的观测收敛阶 $p$。\n- 一个布尔值，指示组装的矩阵 $A$ 是否为对称正定。\n\n最终输出中不需要参数的物理单位。所有输出必须是用于收敛阶的数值小数和用于定性检查的布尔值。\n\n测试套件：\n使用三组参数来测试不同的情况：\n- 情况 1（一般情况）：$D = 0.01$, $\\mu_a = 0.10$, $\\sigma = 0.50$, $s = 1.00$, $L = 1.00$, $N_1 = 50$, $N_2 = 100$。\n- 情况 2（近 Neumann 边界，小 $\\sigma$）：$D = 0.02$, $\\mu_a = 0.05$, $\\sigma = 10^{-6}$, $s = 1.00$, $L = 2.00$, $N_1 = 80$, $N_2 = 160$。\n- 情况 3（高吸收和强 Robin 条件）：$D = 0.01$, $\\mu_a = 0.50$, $\\sigma = 2.00$, $s = 1.00$, $L = 0.50$, $N_1 = 60$, $N_2 = 120$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是一个列表 $[p,\\text{is\\_SPD}]$。例如，对于三个用例，输出必须是以下确切形式\n$$[[p_1,\\text{is\\_SPD}_1],[p_2,\\text{is\\_SPD}_2],[p_3,\\text{is\\_SPD}_3]].$$",
            "solution": "该问题要求使用有限元方法 (FEM) 对一维稳态扩散方程进行分析和数值求解。验证证实了该问题在科学上基于漫射光学断层成像的原理，在数学上是适定的，并提供了一套完整且一致的数据和目标。我们开始进行求解。\n\n### 1. 弱形式的推导\n边值问题的强形式由下式给出：\n$$ - \\frac{d}{dx}\\left(D \\frac{du}{dx}\\right) + \\mu_a u = 0 \\quad \\text{for} \\quad x \\in (0,L) $$\n边界条件为：\n$$ -D \\frac{du}{dx}(0) + \\sigma u(0) = s \\quad (x=0 \\text{ 处的 Robin 条件}) $$\n$$ u(L) = 0 \\quad (x=L \\text{ 处的 Dirichlet 条件}) $$\n此处，$D, \\mu_a, s, L$ 是正常数，且 $\\sigma \\ge 0$。\n\n为了推导弱形式，我们将偏微分方程 (PDE) 乘以一个满足问题对应齐次 Dirichlet 条件（即 $v(L)=0$）的光滑测试函数 $v(x)$。然后我们在域 $[0, L]$ 上进行积分：\n$$ \\int_0^L \\left( - \\frac{d}{dx}\\left(D \\frac{du}{dx}\\right) v(x) + \\mu_a u(x) v(x) \\right) dx = 0 $$\n我们对第一项应用分部积分法（即 Green 第一恒等式的一维形式）：\n$$ \\int_0^L - \\frac{d}{dx}\\left(D \\frac{du}{dx}\\right) v(x) \\, dx = - \\left[ D \\frac{du}{dx} v(x) \\right]_0^L + \\int_0^L D \\frac{du}{dx} \\frac{dv}{dx} \\, dx $$\n计算边界项：\n$$ - \\left[ D \\frac{du}{dx}(L) v(L) - D \\frac{du}{dx}(0) v(0) \\right] $$\n由于测试函数 $v$ 必须满足 $v(L)=0$，因此 $x=L$ 处的项消失。边界项简化为：\n$$ D \\frac{du}{dx}(0) v(0) $$\n根据 $x=0$ 处的 Robin 边界条件，我们有 $-D \\frac{du}{dx}(0) = s - \\sigma u(0)$，这意味着 $D \\frac{du}{dx}(0) = \\sigma u(0) - s$。将其代入边界项表达式得到：\n$$ (\\sigma u(0) - s) v(0) $$\n将分部积分的结果代回积分后的 PDE：\n$$ \\int_0^L D \\frac{du}{dx} \\frac{dv}{dx} \\, dx + \\int_0^L \\mu_a u(x) v(x) \\, dx + (\\sigma u(0) - s) v(0) = 0 $$\n我们重排方程，将包含未知解 $u$ 的项归到左侧，将已知量归到右侧。这就得到了标准的弱形式：找到 $u \\in V$，使得对于所有 $v \\in V$：\n$$ \\int_0^L \\left( D u'(x) v'(x) + \\mu_a u(x) v(x) \\right) dx + \\sigma u(0) v(0) = s v(0) $$\n其中适当的函数空间为 $V = \\{ w \\in H^1(0,L) \\mid w(L) = 0 \\}$。\n\n该方程的形式为 $a(u,v) = F(v)$，其中：\n- 双线性形式为 $a(u,v) = \\int_0^L \\left( D u'(x) v'(x) + \\mu_a u(x) v(x) \\right) dx + \\sigma u(0) v(0)$。\n- 线性泛函为 $F(v) = s v(0)$。\n\n### 2. 矫顽性（能量稳定性）证明\n为了证明矫顽性，我们必须证明存在一个常数 $c>0$，使得对于所有 $u \\in V$，都有 $a(u,u) \\ge c \\|u\\|_{H^1(0,L)}^2$。$H^1$-范数的平方定义为 $\\|u\\|_{H^1(0,L)}^2 = \\int_0^L \\left( |u'(x)|^2 + |u(x)|^2 \\right) dx$。\n\n我们来计算 $v=u$ 时的双线性形式：\n$$ a(u,u) = \\int_0^L \\left( D (u'(x))^2 + \\mu_a (u(x))^2 \\right) dx + \\sigma (u(0))^2 $$\n已知 $D > 0$、$\\mu_a > 0$ 且 $\\sigma \\ge 0$，因此 $a(u,u)$ 表达式中的每一项都是非负的。我们可以建立一个下界：\n$$ a(u,u) \\ge \\int_0^L D (u'(x))^2 dx + \\int_0^L \\mu_a (u(x))^2 dx $$\n令 $c_0 = \\min(D, \\mu_a)$。由于 $D>0$ 且 $\\mu_a>0$，所以 $c_0 > 0$。\n$$ a(u,u) \\ge c_0 \\int_0^L (u'(x))^2 dx + c_0 \\int_0^L (u(x))^2 dx $$\n$$ a(u,u) \\ge c_0 \\left( \\int_0^L (u'(x))^2 dx + \\int_0^L (u(x))^2 dx \\right) $$\n$$ a(u,u) \\ge c_0 \\|u\\|_{H^1(0,L)}^2 $$\n因此，我们找到了一个常数 $c = c_0 = \\min(D, \\mu_a) > 0$ 满足矫顽性条件。这保证了能量稳定性，并通过 Lax-Milgram 定理保证了弱问题解的存在性和唯一性。\n\n### 3. FEM 实现与系统组装\n我们将域 $[0,L]$ 离散化为一个包含 $N$ 个单元和 $N+1$ 个节点 $x_i = i h$（$i=0, \\dots, N$）的均匀网格，其中 $h=L/N$。我们使用连续的分段线性基函数 $\\phi_i(x)$。FEM 解为 $u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x)$，其中 $U_j$ 是节点值。条件 $u(L)=0$ 意味着 $U_N=0$。我们求解 $N$ 个未知数 $U_0, \\dots, U_{N-1}$。线性系统为 $A \\mathbf{U} = \\mathbf{b}$，其中 $A_{ij} = a(\\phi_j, \\phi_i)$，$b_i = F(\\phi_i)$，且 $\\mathbf{U}=[U_0, \\dots, U_{N-1}]^T$。\n\n矩阵项是通过对标准单元刚度矩阵和质量矩阵的贡献以及边界项求和来计算的。\n长度为 $h$ 的单元的单元刚度矩阵是 $\\frac{D}{h}\\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n单元质量矩阵是 $\\frac{\\mu_a h}{6}\\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}$。\n结合这些，组装后的系统矩阵 $A$ 是一个对称三对角的 $N \\times N$ 矩阵：\n- 对角线元素：\n$$ A_{ii} = \\frac{2D}{h} + \\frac{2\\mu_a h}{3} \\quad \\text{for } i=1, \\dots, N-1 $$\n$$ A_{00} = \\frac{D}{h} + \\frac{\\mu_a h}{3} + \\sigma $$\n- 非对角线元素：\n$$ A_{i,i+1} = A_{i+1,i} = -\\frac{D}{h} + \\frac{\\mu_a h}{6} \\quad \\text{for } i=0, \\dots, N-2 $$\n右端向量 $\\mathbf{b}$ 是：\n$$ b_i = F(\\phi_i) = s \\phi_i(0) $$\n该项仅在 $i=0$ 时非零：$b_0 = s$，而对于 $i > 0$ 则 $b_i = 0$。\n\n### 4. 解析解与误差计算\n通过在半无限域 $[0,\\infty)$ 上求解 ODE 并满足 $u(\\infty)=0$ 来找到解析解。对于 $-Du''+\\mu_a u = 0$，特征方程为 $-Dr^2 + \\mu_a = 0$，其根为 $r = \\pm\\sqrt{\\mu_a/D}$。令 $\\alpha = \\sqrt{\\mu_a/D}$。通解为 $u(x) = C_1 e^{\\alpha x} + C_2 e^{-\\alpha x}$。衰减条件 $u(\\infty)=0$ 要求 $C_1=0$。\n剩余的常数 $C_2$ 由 $x=0$ 处的 Robin 边界条件确定：\n$$ -D(-\\alpha C_2) + \\sigma C_2 = s \\implies (D\\alpha + \\sigma)C_2 = s \\implies C_2 = \\frac{s}{D\\sqrt{\\mu_a/D} + \\sigma} = \\frac{s}{\\sqrt{D\\mu_a} + \\sigma} $$\n解析解为：\n$$ u(x) = \\frac{s}{\\sqrt{D\\mu_a} + \\sigma} e^{-x\\sqrt{\\mu_a/D}} $$\n$L^2$ 误差 $\\|u_h - u\\|_{L^2(0,L)}$ 是通过对单元积分求和来计算的。每个积分 $\\int_{x_i}^{x_{i+1}} |u_h(x) - u(x)|^2 dx$ 都使用 3 点 Gauss-Legendre 求积法来精确计算。然后使用公式 $p = \\log(E_{h_1}/E_{h_2}) / \\log(h_1/h_2)$ 计算观测到的收敛阶 $p$，其中 $h_2=h_1/2$。\n\n### 5. 数值稳定性验证\n能量稳定性已通过矫顽性在理论上得到证明，其数值验证则通过检查组装的矩阵 $A$（针对自由度 $U_0, \\dots, U_{N-1}$）是否为对称正定 (SPD) 来进行。对称性是该公式所固有的。正定性通过计算 $A$ 的特征值并验证它们是否全部严格为正来检查。\n\n以下程序为给定的测试用例实现了这些步骤。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_case(D, mu_a, sigma, s, L, N):\n    \"\"\"\n    Solves the 1D diffusion problem for one case and returns the L2 error and SPD status.\n    \"\"\"\n    # 1. FEM System Assembly\n    h = L / N\n    \n    # Assemble the N x N tridiagonal system matrix A for unknowns U_0, ..., U_{N-1}\n    # Main diagonal\n    diag_vals = np.full(N, 2 * D / h + 2 * mu_a * h / 3)\n    diag_vals[0] = D / h + mu_a * h / 3 + sigma\n    \n    # Off-diagonals\n    off_diag_val = -D / h + mu_a * h / 6\n    \n    # Assemble the full matrix A for the SPD check\n    A = np.diag(diag_vals) + np.diag(np.full(N - 1, off_diag_val), 1) + np.diag(np.full(N - 1, off_diag_val), -1)\n\n    # 2. Assemble right-hand side vector b\n    b = np.zeros(N)\n    b[0] = s\n    \n    # 3. Solve the linear system A*U = b\n    # For efficiency with tridiagonal systems, we use solve_banded\n    ab = np.zeros((3, N))\n    ab[0, 1:] = off_diag_val   # Upper diagonal\n    ab[1, :] = diag_vals     # Main diagonal\n    ab[2, :-1] = off_diag_val  # Lower diagonal\n    U = solve_banded((1, 1), ab, b)\n    \n    # Append the known boundary value U_N = 0\n    U_full = np.append(U, 0)\n    \n    # 4. Check for Symmetric Positive Definite (SPD) property\n    is_symmetric = np.allclose(A, A.T)\n    is_pd = False\n    if is_symmetric:\n        try:\n            eigenvalues = np.linalg.eigvalsh(A)\n            # Check if all eigenvalues are strictly positive (with a small tolerance)\n            is_pd = np.all(eigenvalues > 1e-12)\n        except np.linalg.LinAlgError:\n            is_pd = False\n    is_spd = is_symmetric and is_pd\n\n    # 5. Calculate L2 error against the analytic solution\n    # Analytic solution for semi-infinite domain\n    alpha = np.sqrt(mu_a / D)\n    C2 = s / (np.sqrt(D * mu_a) + sigma)\n    def u_analytic(x):\n        return C2 * np.exp(-alpha * x)\n\n    # L2 error calculation using 3-point Gauss-Legendre quadrature\n    nodes = np.linspace(0, L, N + 1)\n    z_gauss = np.array([-np.sqrt(3/5), 0, np.sqrt(3/5)])\n    w_gauss = np.array([5/9, 8/9, 5/9])\n    \n    l2_error_sq = 0.0\n    for i in range(N):\n        x_i = nodes[i]\n        x_i_plus_1 = nodes[i+1]\n        \n        # Map Gauss points from [-1, 1] to [x_i, x_{i+1}]\n        xq = (x_i_plus_1 - x_i) / 2 * z_gauss + (x_i_plus_1 + x_i) / 2\n        \n        # Evaluate FEM solution at quadrature points\n        uh_vals = U_full[i] * (x_i_plus_1 - xq) / h + U_full[i+1] * (xq - x_i) / h\n        \n        # Evaluate analytic solution at quadrature points\n        u_vals = u_analytic(xq)\n        \n        # Accumulate squared error integral\n        integrand_vals = (uh_vals - u_vals)**2\n        integral_on_element = (x_i_plus_1 - x_i) / 2 * np.sum(w_gauss * integrand_vals)\n        l2_error_sq += integral_on_element\n        \n    l2_error = np.sqrt(l2_error_sq)\n    \n    return l2_error, is_spd\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # D, mu_a, sigma, s, L, N1, N2\n        (0.01, 0.10, 0.50, 1.00, 1.00, 50, 100),\n        (0.02, 0.05, 1e-6, 1.00, 2.00, 80, 160),\n        (0.01, 0.50, 2.00, 1.00, 0.50, 60, 120),\n    ]\n\n    results = []\n    for D, mu_a, sigma, s, L, N1, N2 in test_cases:\n        # Run FEM for mesh size h1 = L/N1\n        E_h1, is_spd1 = run_case(D, mu_a, sigma, s, L, N1)\n        \n        # Run FEM for mesh size h2 = L/N2\n        E_h2, is_spd2 = run_case(D, mu_a, sigma, s, L, N2)\n        \n        # Calculate the observed order of convergence\n        h1 = L / N1\n        h2 = L / N2\n        \n        # The ratio h1/h2 is N2/N1 = 2 for all test cases\n        if E_h1 > 1e-15 and E_h2 > 1e-15:\n            p = np.log2(E_h1 / E_h2)\n        else:\n            p = np.inf # If error is virtually zero, convergence is extremely fast\n\n        # The SPD property is independent of N, so is_spd1 and is_spd2 should be identical.\n        # We report the result for the N1 mesh as requested.\n        results.append([p, is_spd1])\n    \n    # Format the final output string as specified: [[p1,is_SPD1],[p2,is_SPD2],...]\n    # Booleans are converted to lowercase 'true'/'false' for standard data representation.\n    list_of_results_str = []\n    for p_val, spd_val in results:\n        spd_str = 'true' if spd_val else 'false'\n        list_of_results_str.append(f\"[{p_val:.10f},{spd_str}]\")\n\n    print(f\"[{','.join(list_of_results_str)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "拥有一个经过验证的正向模型后，我们现在可以解决DOT的核心目标：从边界测量中重建图像。本练习介绍了贝叶斯框架，这是一种解决反问题的强大方法，它不仅能提供图像，还能量化我们在每个体素上重建结果的可信度。通过计算后验方差，我们可以深入了解图像的可靠性，这是临床诊断中的一个关键方面。",
            "id": "4876921",
            "problem": "考虑漫射光学断层成像（DOT），其中边界光强度的测量变化在​​一阶 Born 近似下通过带有加性高斯噪声的线性正演模型进行建模。令 $x \\in \\mathbb{R}^n$ 表示吸收系数（单位为 $\\mathrm{mm}^{-1}$）的体素级未知扰动，令 $y \\in \\mathbb{R}^m$ 表示测量向量。线性模型为 $y = J x + e$，其中 $J \\in \\mathbb{R}^{m \\times n}$ 是灵敏度（雅可比）矩阵， $e$ 是均值为零、协方差矩阵为 $\\Sigma_e \\in \\mathbb{R}^{m \\times m}$ 的高斯噪声。假设 $x$ 服从均值为 $0$、协方差矩阵为 $\\Sigma_0 \\in \\mathbb{R}^{n \\times n}$ 的高斯先验，其中 $\\Sigma_0$ 为严格正定矩阵。从贝叶斯法则和多元正态分布的性质出发，推导在给定 $y$ 的条件下 $x$ 的后验协方差的解析表达式。然后，对于给定的数值矩阵，计算体素级边际方差，即后验协方差的对角线元素。所有方差必须以普通十进制数的形式报告，单位为 $\\mathrm{mm}^{-2}$。\n\n您的程序必须为以下每个测试用例实现体素级边际方差的计算。使用给定的灵敏度矩阵、噪声精度矩阵和先验协方差矩阵。噪声精度矩阵定义为 $W = \\Sigma_e^{-1}$，并已直接提供。\n\n测试用例 A（一般情况，中等先验和异构噪声）：\n$$\nJ_A = \\begin{bmatrix}\n0.9  0.1  0.0 \\\\\n0.4  0.6  0.2 \\\\\n0.0  0.3  0.7 \\\\\n0.2  0.0  0.5\n\\end{bmatrix},\\quad\nW_A = \\operatorname{diag}\\left(25.0, 11.1111111111, 6.25, 4.0\\right),\\quad\n\\Sigma_{0,A} = \\operatorname{diag}\\left(1.0, 1.0, 1.0\\right).\n$$\n\n测试用例 B（无信息先验，测量值与 A 相同）：\n$$\nJ_B = J_A,\\quad\nW_B = W_A,\\quad\n\\Sigma_{0,B} = \\operatorname{diag}\\left(1000.0, 1000.0, 1000.0\\right).\n$$\n\n测试用例 C（强先验，测量值与 A 相同）：\n$$\nJ_C = J_A,\\quad\nW_C = W_A,\\quad\n\\Sigma_{0,C} = \\operatorname{diag}\\left(0.01, 0.02, 0.03\\right).\n$$\n\n测试用例 D（单次测量，两个体素）：\n$$\nJ_D = \\begin{bmatrix}\n1.5  -0.5\n\\end{bmatrix},\\quad\nW_D = \\begin{bmatrix}\n100.0\n\\end{bmatrix},\\quad\n\\Sigma_{0,D} = \\operatorname{diag}\\left(2.0, 0.5\\right).\n$$\n\n测试用例 E（病态灵敏度，信息先验）：\n$$\nJ_E = \\begin{bmatrix}\n1.0  0.99  0.0 \\\\\n0.0  0.01  1.0 \\\\\n0.5  0.495  0.0\n\\end{bmatrix},\\quad\nW_E = \\operatorname{diag}\\left(10.0, 10.0, 10.0\\right),\\quad\n\\Sigma_{0,E} = \\operatorname{diag}\\left(10.0, 10.0, 10.0\\right).\n$$\n\n您的程序必须：\n- 对于每个测试用例，构建对称矩阵 $A = J^\\top W J + \\Sigma_0^{-1}$，并在不显式构造完整逆矩阵的情况下计算 $A^{-1}$ 的对角线。这些对角线元素即为体素级边际方差，单位为 $\\mathrm{mm}^{-2}$。\n- 将每个方差四舍五入到 $6$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，其本身也是一个用方括号括起来的逗号分隔列表，包含该用例四舍五入后的体素级边际方差。例如，格式必须类似于 $[ [v_{A,1}, v_{A,2}, \\dots], [v_{B,1}, v_{B,2}, \\dots], \\dots ]$，逗号后无空格。请注意，您必须只打印这一行，且格式必须完全一致。\n\n不需要外部输入；矩阵已如上文指定，必须嵌入到您的程序中。",
            "solution": "本问题要求在贝叶斯框架下，从线性正演模型中推导后验协方差，并计算体素级边际方差。\n\n### 后验协方差推导\n根据贝叶斯定理，后验概率密度 $p(x|y)$ 正比于似然函数 $p(y|x)$ 和先验概率密度 $p(x)$ 的乘积：\n$$p(x|y) \\propto p(y|x)p(x)$$\n似然函数 $p(y|x)$ 源于正演模型 $y = Jx + e$，其中噪声 $e$ 服从多元正态分布 $e \\sim \\mathcal{N}(0, \\Sigma_e)$。这意味着对于给定的 $x$，测量值 $y$ 的分布为 $y \\sim \\mathcal{N}(Jx, \\Sigma_e)$。其概率密度为：\n$$p(y|x) \\propto \\exp\\left(-\\frac{1}{2}(y-Jx)^\\top \\Sigma_e^{-1} (y-Jx)\\right)$$\n$x$ 的先验分布为 $x \\sim \\mathcal{N}(0, \\Sigma_0)$，其密度为：\n$$p(x) \\propto \\exp\\left(-\\frac{1}{2}x^\\top \\Sigma_0^{-1} x\\right)$$\n将它们代入后验分布的表达式中：\n$$p(x|y) \\propto \\exp\\left(-\\frac{1}{2}\\left[ (y-Jx)^\\top \\Sigma_e^{-1} (y-Jx) + x^\\top \\Sigma_0^{-1} x \\right]\\right)$$\n后验分布也是一个多元正态分布，其密度具有一般形式 $p(x|y) \\propto \\exp\\left(-\\frac{1}{2}(x-\\mu_{\\text{post}})^\\top \\Sigma_{\\text{post}}^{-1} (x-\\mu_{\\text{post}})\\right)$。为了确定后验协方差 $\\Sigma_{\\text{post}}$，我们检查指数中关于 $x$ 的二次项。展开指数中的项：\n$$ (y-Jx)^\\top \\Sigma_e^{-1} (y-Jx) + x^\\top \\Sigma_0^{-1} x = (y^\\top - x^\\top J^\\top)\\Sigma_e^{-1}(y - Jx) + x^\\top \\Sigma_0^{-1} x $$\n$$ = y^\\top\\Sigma_e^{-1}y - 2x^\\top J^\\top\\Sigma_e^{-1}y + x^\\top J^\\top \\Sigma_e^{-1} Jx + x^\\top \\Sigma_0^{-1} x $$\n合并关于 $x$ 的二次项得到 $x^\\top (J^\\top \\Sigma_e^{-1} J + \\Sigma_0^{-1}) x$。通过与正态分布的一般二次项 $x^\\top \\Sigma_{\\text{post}}^{-1} x$ 进行比较，我们确定后验协方差矩阵的逆为：\n$$\\Sigma_{\\text{post}}^{-1} = J^\\top \\Sigma_e^{-1} J + \\Sigma_0^{-1}$$\n使用噪声精度矩阵 $W = \\Sigma_e^{-1}$，该表达式变为：\n$$\\Sigma_{\\text{post}}^{-1} = J^\\top W J + \\Sigma_0^{-1}$$\n因此，后验协方差为：\n$$\\Sigma_{\\text{post}} = (J^\\top W J + \\Sigma_0^{-1})^{-1}$$\n这正是我们需要计算的矩阵。\n\n### 边际方差计算方法\n体素级边际方差是后验协方差矩阵 $\\Sigma_{\\text{post}}$ 的对角元素 $(\\Sigma_{\\text{post}})_{ii}$。直接计算矩阵的逆 $\\Sigma_{\\text{post}}$ 在计算上可能成本很高。一种更有效的方法是逐个计算对角元素。令 $A = \\Sigma_{\\text{post}}^{-1} = J^\\top W J + \\Sigma_0^{-1}$。$\\Sigma_{\\text{post}}$ 的第 $i$ 个对角元素 $(\\Sigma_{\\text{post}})_{ii}$ 等于 $A^{-1}$ 的第 $i$ 个对角元素。该元素可以表示为 $e_i^\\top A^{-1} e_i$，其中 $e_i$ 是第 $i$ 个标准基向量（一个在第 $i$ 个位置为 1、其他位置为零的列向量）。\n如果我们令 $x_i = A^{-1} e_i$，则这等价于求解线性方程组 $A x_i = e_i$。所求的对角元素就是解向量 $x_i$ 的第 $i$ 个分量：$(\\Sigma_{\\text{post}})_{ii} = (x_i)_i$。\n\n下面的 Python 代码实现了这一计算过程，并为所有测试用例生成了所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DOT posterior variance problem for the given test cases.\n    \"\"\"\n\n    def compute_marginal_variances(J, W_diag, Sigma0_diag):\n        \"\"\"\n        Computes the voxel-wise marginal variances.\n\n        Args:\n            J (np.ndarray): The sensitivity matrix.\n            W_diag (np.ndarray): The diagonal elements of the noise precision matrix W.\n            Sigma0_diag (np.ndarray): The diagonal elements of the prior covariance matrix Sigma0.\n\n        Returns:\n            list: A list of the computed marginal variances, rounded to 6 decimal places.\n        \"\"\"\n        n_voxels = J.shape[1]\n        \n        W = np.diag(W_diag)\n        \n        # The prior covariance Sigma0 is diagonal, so its inverse is also diagonal\n        # with reciprocal elements on the diagonal.\n        Sigma0_inv = np.diag(1.0 / Sigma0_diag)\n        \n        # Form the matrix A = J^T * W * J + Sigma0_inv\n        A = J.T @ W @ J + Sigma0_inv\n        \n        # To find the diagonal of A_inv without computing the full inverse,\n        # we solve the system A * x = e_i for each standard basis vector e_i.\n        # The i-th diagonal element of A_inv is then the i-th component of the solution vector x.\n        variances = np.zeros(n_voxels)\n        for i in range(n_voxels):\n            e_i = np.zeros(n_voxels)\n            e_i[i] = 1.0\n            \n            # Solve A * x_i = e_i\n            x_i = np.linalg.solve(A, e_i)\n            \n            # The i-th diagonal element of A_inv is x_i[i]\n            variances[i] = x_i[i]\n            \n        # Round each variance to 6 decimal places\n        rounded_variances = np.round(variances, 6).tolist()\n        \n        return rounded_variances\n\n    # Define the test cases from the problem statement.\n    J_A = np.array([\n        [0.9, 0.1, 0.0],\n        [0.4, 0.6, 0.2],\n        [0.0, 0.3, 0.7],\n        [0.2, 0.0, 0.5]\n    ])\n    W_A_diag = np.array([25.0, 100.0/9.0, 6.25, 4.0])\n    Sigma0_A_diag = np.array([1.0, 1.0, 1.0])\n\n    test_cases = [\n        # Case A: general, moderate prior and heterogeneous noise\n        (J_A, W_A_diag, Sigma0_A_diag),\n        # Case B: uninformative prior\n        (J_A, W_A_diag, np.array([1000.0, 1000.0, 1000.0])),\n        # Case C: strong prior\n        (J_A, W_A_diag, np.array([0.01, 0.02, 0.03])),\n        # Case D: single measurement, two voxels\n        (np.array([[1.5, -0.5]]), np.array([100.0]), np.array([2.0, 0.5])),\n        # Case E: ill-conditioned sensitivity, informative prior\n        (np.array([[1.0, 0.99, 0.0], [0.0, 0.01, 1.0], [0.5, 0.495, 0.0]]),\n         np.array([10.0, 10.0, 10.0]), \n         np.array([10.0, 10.0, 10.0]))\n    ]\n\n    all_results = []\n    for J, W_diag, Sigma0_diag in test_cases:\n        variances = compute_marginal_variances(J, W_diag, Sigma0_diag)\n        all_results.append(variances)\n    \n    # Format the output string precisely as required: [[v1,v2,...],[v1,v2,...],...]\n    # No spaces after commas.\n    sublist_strings = []\n    for result_list in all_results:\n        sublist_strings.append(f\"[{','.join(map(str, result_list))}]\")\n    \n    final_output = f\"[{','.join(sublist_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}