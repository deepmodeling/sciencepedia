{
    "hands_on_practices": [
        {
            "introduction": "为了形成一个相干的超声波束并将其引导到所需方向，我们必须对阵列中每个元件发射的信号施加精确的时间延迟。第一个练习将挑战您从波传播的基本物理原理推导出这些延迟。通过计算必要的时间和相位偏移，您将对电子波束偏转的工作原理建立起基础性的理解。",
            "id": "4882907",
            "problem": "一个均匀线性超声阵列沿 $x$ 轴放置，其阵元间距为 $p = 0.3\\ \\text{mm}$。介质是均匀的软组织，声速为 $c = 1540\\ \\text{m/s}$。考虑将中心频率为 $f = 5\\ \\text{MHz}$ 的窄带发射波束通过电子方式偏转到相对于阵列法线（$z$ 轴）$\\theta = 20^{\\circ}$ 的角度。利用平面波传播和时谐场相位的基本原理进行推导，求出产生偏转到角度 $\\theta$ 的平面波所需的相邻阵元时间延迟增量 $\\Delta t$，以及在窄带（相移）近似下的相应相邻阵元相位差 $\\phi$。然后，根据推导出的 $\\phi$ 值，判断是否需要进行相位回卷（即判断 $\\phi \\geq 2\\pi$ 是否成立）。\n\n您的推导必须从时谐平面波的表示形式 $p(\\mathbf{r},t) \\propto \\exp\\!\\big(i(\\mathbf{k}\\cdot \\mathbf{r} - \\omega t)\\big)$、关系式 $\\omega = 2\\pi f$ 和 $\\lVert \\mathbf{k} \\rVert = k = \\omega/c$ 开始。不要假设任何聚焦定律；相反，应使用平面波偏转的基本几何原理来获得所需的阵元间延迟定律。\n\n使用以上参数计算 $\\Delta t$ 和 $\\phi$ 的数值。将您的数值答案四舍五入到四位有效数字。将 $\\Delta t$ 以纳秒表示，$\\phi$ 以弧度表示。以双元行向量 $\\big[\\Delta t,\\ \\phi\\big]$ 的形式提供您的最终答案。并在您的推理中说明是否需要相位回卷。",
            "solution": "该问题具有科学依据，提法明确，客观，并包含了推导唯一解所需的所有信息。这是医学成像和声学领域的一个标准问题。因此，该问题是有效的。\n\n我们从基本原理开始推导。超声阵列是一个沿 $x$ 轴放置的均匀线性阵列，阵元间距为 $p$。我们希望形成一个相对于阵列法线（即 $z$ 轴）以角度 $\\theta$ 传播的平面波。\n\n设阵元由整数 $n$ 索引，其中 $n=0$ 的阵元位于原点 $(x,z)=(0,0)$。第 $n$ 个阵元的位置由向量 $\\mathbf{r}_n = (np, 0, 0)$ 给出。\n\n平面波的特征是其波前，即等相位面。要使平面波相对于 $z$ 轴以角度 $\\theta$ 偏转，波前必须是平面的，并且垂直于传播方向。\n\n考虑一个在时间 $t=0$ 时通过原点 $(0,0)$ 的平面波前。为了使该波前以角度 $\\theta$ 传播，不同阵元发射的信号必须有适当的时间安排。我们来分析几何路径长度差。位于 $x=p$ （即 $n=1$）的阵元与位于 $x=0$ 的阵元处于不同位置。对于一个在半空间 $z>0$ 中相对于 $z$ 轴以角度 $\\theta$ 传播的波前，从位于 $x=p$ 的阵元到该波前的路径长度比从位于 $x=0$ 的阵元到该波前的路径长度短一个量 $\\Delta L$。这个路径长度差由几何关系给出：\n$$ \\Delta L = p \\sin(\\theta) $$\n这是从原点阵元发出的波要到达与从 $x=p$ 处阵元发出的波相同的波前所必须传播的额外距离。为确保这两个阵元的信号对同​​一波前产生相长干涉，来自 $x=p$ 处阵元的信号必须相对于来自 $x=0$ 处阵元的信号进行时间延迟。这个时间延迟，我们记为相邻阵元时间延迟增量 $\\Delta t$，必须精确补偿传播路径差 $\\Delta L$ 所需的时间。\n因此，时间延迟为：\n$$ \\Delta t = \\frac{\\Delta L}{c} $$\n其中 $c$ 是介质中的声速。代入 $\\Delta L$ 的表达式，我们得到相邻阵元之间所需的时间延迟增量的公式：\n$$ \\Delta t = \\frac{p \\sin(\\theta)}{c} $$\n对于位置在 $x_n = np$ 的第 $n$ 个阵元，相对于原点阵元的总延迟为 $t_n = n \\Delta t$。\n\n在窄带近似下，发射信号是时谐波，其复数形式可以表示为与 $\\exp(-i\\omega t)$ 成正比，其中 $\\omega$ 是角频率。$\\Delta t$ 的时间延迟对应于 $\\phi$ 的相移。延迟 $\\Delta t$ 的信号表示为 $\\exp(-i\\omega(t-\\Delta t)) = \\exp(-i\\omega t)\\exp(i\\omega \\Delta t)$。项 $\\exp(i\\omega \\Delta t)$ 表示一个相位移 $\\phi$。\n因此，相邻阵元的相位差 $\\phi$ 为：\n$$ \\phi = \\omega \\Delta t $$\n角频率 $\\omega$ 与中心频率 $f$ 的关系为 $\\omega = 2\\pi f$。代入此关系式和 $\\Delta t$ 的表达式：\n$$ \\phi = (2\\pi f) \\left( \\frac{p \\sin(\\theta)}{c} \\right) = \\frac{2\\pi f p \\sin(\\theta)}{c} $$\n我们也可以用波数 $k = \\omega/c = 2\\pi f / c = 2\\pi/\\lambda$ 来表示，其中 $\\lambda$ 是波长。\n$$ \\phi = k p \\sin(\\theta) $$\n这样就完成了所需公式的推导。\n\n现在，我们使用给定参数计算数值：\n- 阵元间距: $p = 0.3\\ \\text{mm} = 0.3 \\times 10^{-3}\\ \\text{m}$\n- 声速: $c = 1540\\ \\text{m/s}$\n- 中心频率: $f = 5\\ \\text{MHz} = 5 \\times 10^6\\ \\text{Hz}$\n- 偏转角: $\\theta = 20^{\\circ}$\n\n首先，我们计算相邻阵元时间延迟增量 $\\Delta t$：\n$$ \\Delta t = \\frac{(0.3 \\times 10^{-3}\\ \\text{m}) \\sin(20^{\\circ})}{1540\\ \\text{m/s}} $$\n使用 $\\sin(20^{\\circ}) \\approx 0.34202$：\n$$ \\Delta t \\approx \\frac{(0.3 \\times 10^{-3}) \\times 0.34202}{1540}\\ \\text{s} \\approx 6.6627 \\times 10^{-8}\\ \\text{s} $$\n问题要求答案以纳秒（$1\\ \\text{ns} = 10^{-9}\\ \\text{s}$）为单位。\n$$ \\Delta t \\approx 66.627\\ \\text{ns} $$\n四舍五入到四位有效数字，我们得到 $\\Delta t = 66.63\\ \\text{ns}$。\n\n接下来，我们计算相应的相邻阵元相位差 $\\phi$：\n$$ \\phi = \\omega \\Delta t = 2\\pi f \\Delta t $$\n$$ \\phi = 2\\pi (5 \\times 10^6\\ \\text{Hz}) (6.6627 \\times 10^{-8}\\ \\text{s}) $$\n$$ \\phi = 10\\pi \\times 10^6 \\times 6.6627 \\times 10^{-8}\\ \\text{rad} = 0.66627\\pi\\ \\text{rad} \\approx 2.0931\\ \\text{rad} $$\n四舍五入到四位有效数字，我们得到 $\\phi = 2.093\\ \\text{rad}$。\n\n最后，我们必须确定是否需要相位回卷。当计算出的相移 $\\phi$ 大于或等于 $2\\pi$ 时，就需要进行相位回卷，因为移相器可以施加的相移范围通常是 $[0, 2\\pi)$ 或 $(-\\pi, \\pi]$。\n我们将计算出的相移 $\\phi$ 与 $2\\pi$进行比较：\n$$ \\phi \\approx 2.093\\ \\text{rad} $$\n$$ 2\\pi \\approx 2 \\times 3.14159 = 6.283\\ \\text{rad} $$\n由于 $2.093  6.283$，我们有 $\\phi  2\\pi$。因此，对于这个偏转角和这组参数，不需要进行相位回卷。",
            "answer": "$$\\boxed{\\begin{pmatrix} 66.63  2.093 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在动态接收聚焦中，通过调整有效孔径大小来接收来自不同深度的回波，可以优化图像质量。一个关键目标是保持恒定的F数（$F$-number），这有助于在不同深度上获得一致的横向分辨率。这个设计练习要求您创建一个“孔径增长律”，以确定在任何给定深度应使用的活动元件数量，从而在理想性能与换能器的物理约束之间取得平衡。",
            "id": "4882934",
            "problem": "一个超声成像系统使用一个一维线性阵列，该阵列共有 $128$ 个相同的元件，中心到中心的间距（pitch）为 $p = 0.3\\ \\text{mm}$。在动态接收聚焦中，有效接收孔径随成像深度 $z$ 的增加而增大，以在 $z = 10\\ \\text{mm}$ 到 $z = 60\\ \\text{mm}$ 的深度范围内，目标是保持一个近似恒定的 $F$ 数 $F \\approx 1.5$。假设以下基于物理原理的基础：\n- $F$ 数定义为 $F = z/D$，其中 $z$ 是焦深（成像深度），$D$ 是有效接收孔径宽度。\n- 对于均匀加权、中心对称的子孔径，在一个均匀线性阵列上，当切缝（kerf）可忽略不计且元件宽度与间距相当时，有效孔径宽度可近似为 $D \\approx N p$，其中 $N$ 是活动元件的数量，$p$ 是间距。\n- 子孔径必须使用整数个元件，并且不能超过整个阵列的大小 $N \\leq 128$。\n\n从这些基础出发，推导一个动态接收孔径增长律 $N(z)$，该定律根据深度 $z$ 选择活动元件的数量，以在指定范围内保持 $F \\approx 1.5$，同时满足整数和最大尺寸的约束。您的定律应该选择与 $F = z/D$ 所隐含的理想连续值最接近的整数 $N$，并且在需要时应在全孔径极限处饱和。将 $z$ 视为以毫米为单位表示。\n\n请以仅含 $z$ 的单个闭式表达式 $N(z)$ 的形式提供您的最终结果，其中所有常数都经过数值简化。以 $N(z)$ 的解析表达式形式陈述您的答案；最终表达式中不要包含物理单位。",
            "solution": "该问题要求推导一个动态接收孔径增长律，用函数 $N(z)$ 表示，该函数指定活动元件数量 $N$ 作为成像深度 $z$ 的函数。推导过程必须满足几个条件：保持近似恒定的 $F$ 数，尊重换能器元件的离散特性，并遵守阵列的物理尺寸限制。\n\n首先，对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 元件总数：$128$\n- 中心间距：$p = 0.3\\ \\text{mm}$\n- 目标 $F$ 数：$F \\approx 1.5$\n- 成像深度范围：$z = 10\\ \\text{mm}$ 到 $z = 60\\ \\text{mm}$\n- $F$ 数的定义：$F = z/D$，其中 $D$ 是有效接收孔径宽度。\n- 孔径宽度的近似值：$D \\approx N p$，其中 $N$ 是活动元件数量。\n- 对 $N$ 的约束：$N$ 必须是整数。\n- 最大孔径约束：$N \\le 128$。\n- 离散化规则：$N$ 应选择与理想连续值最接近的整数。\n- 饱和条件：该定律必须在全孔径极限处饱和。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它基于超声波束形成的基本原理，包括 $F$ 数和孔径大小的定义，这些都是医学成像物理学的核心。所有给定的值和参数对于临床超声探头都是物理上现实的。该问题是适定的；它提供了足够的信息和清晰、一致的约束来推导出一个唯一的函数 $N(z)$。语言客观而精确。该问题没有违反任何无效性标准。\n\n**步骤3：结论与行动**\n问题有效。将提供一个合理的解决方案。\n\n**求解推导**\n\n问题的核心是保持恒定的 $F$ 数。$F$ 数 $F$、成像深度 $z$ 和孔径宽度 $D$ 之间的关系由下式给出：\n$$F = \\frac{z}{D}$$\n\n有效孔径宽度 $D$ 通过近似关系与活动元件数量 $N$ 和间距 $p$ 相关联：\n$$D \\approx N p$$\n\n为了找到一个理想的、连续的元件数量 $N_{\\text{ideal}}$，以完美地保持目标 $F$ 数，我们可以合并这两个方程。将 $D$ 的表达式代入 $F$ 数方程，得到：\n$$F \\approx \\frac{z}{N p}$$\n\n求解 $N$ 得到理想元件数量作为深度 $z$ 的函数：\n$$N_{\\text{ideal}}(z) = \\frac{z}{F p}$$\n\n现在，我们代入 $F$ 和 $p$ 的给定数值。目标 $F$ 数为 $F = 1.5$，间距为 $p = 0.3\\ \\text{mm}$。输入 $z$ 被理解为以毫米为单位。\n$$N_{\\text{ideal}}(z) = \\frac{z}{1.5 \\times 0.3} = \\frac{z}{0.45}$$\n\n为了将常数表示为有理数，我们可以写成：\n$$N_{\\text{ideal}}(z) = \\frac{1}{0.45}z = \\frac{100}{45}z = \\frac{20}{9}z$$\n\n这个表达式给出了理想的元件数量，它是一个连续的实数。然而，物理系统有两个约束必须纳入 $N(z)$ 的最终定律中：\n1. 元件数量 $N$ 必须是整数。问题指定使用“最接近的整数选择”。这在数学上等同于一个四舍五入函数。将非负数 $x$ 四舍五入到最接近的整数的标准实现是 $\\lfloor x + 0.5 \\rfloor$。\n2. 元件数量 $N$ 不能超过阵列中可用的元件总数，即 $128$。这对 $N$ 施加了一个上限，即饱和。\n\n我们依次应用这两个约束。首先，我们将最接近整数规则应用于 $N_{\\text{ideal}}(z)$：\n$$N_{\\text{rounded}}(z) = \\left\\lfloor N_{\\text{ideal}}(z) + \\frac{1}{2} \\right\\rfloor = \\left\\lfloor \\frac{20}{9}z + \\frac{1}{2} \\right\\rfloor$$\n\n接下来，我们应用饱和约束。活动元件的数量不能超过 $128$。这意味着如果计算出的四舍五入元件数量超过 $128$，则必须将其限制在 $128$。这可以用最小值函数表示：\n$$N(z) = \\min\\left(N_{\\text{rounded}}(z), 128\\right)$$\n\n代入 $N_{\\text{rounded}}(z)$ 的表达式，我们得到动态接收孔径增长律的最终闭式表达式：\n$$N(z) = \\min\\left(\\left\\lfloor \\frac{20}{9}z + \\frac{1}{2} \\right\\rfloor, 128\\right)$$\n\n这个 $N(z)$ 表达式为任何给定的深度 $z$（以毫米为单位）提供了活动元件的数量，满足了问题陈述中指定的所有条件。元件数量随深度线性增长（以阶梯式整数方式），直到孔径在 $128$ 个元件的全阵列尺寸处饱和。",
            "answer": "$$\\boxed{\\min\\left(\\left\\lfloor \\frac{20}{9}z + \\frac{1}{2} \\right\\rfloor, 128\\right)}$$"
        },
        {
            "introduction": "诸如相干复合成像等先进成像技术可以通过抑制伪影来显著提高图像质量。该方法结合来自多个发射角度的数据，最终生成旁瓣更少、对比度更高的图像。在最后一个练习中，您将编写一个程序来模拟这一过程，直接比较复合成像波束与单角度波束的点扩散函数，并量化旁瓣抑制的改善程度。",
            "id": "4882937",
            "problem": "考虑一个在一维均匀介质中执行电子发射偏转和动态接收聚焦的一维线性超声阵列。使用以下经过充分检验的物理定律和定义作为唯一的建模基础：(i) 对于距离 $r$ 和声速 $c$，传播时间为 $t = r/c$；(ii) 中心频率为 $f_0$ 的窄带正弦波在传播延迟 $t$ 后的基带响应为 $\\exp(-j 2 \\pi f_0 t)$；以及 (iii) 动态接收聚焦是通过使用到每个波束形成点的假设传播时间进行匹配滤波（相位共轭）来实现的。一个单位振幅的点散射体位于 $(x_s, z_s) = (0, z_0)$，其中 $z_0  0$。换能器沿 $x$ 轴放置在 $z = 0$ 处。$N$ 个阵元以原点为中心，间距为 $p$ 均匀分布，因此对于整数 $m \\in \\{0,1,\\dots,N-1\\}$，第 $m$ 个阵元的横向坐标为 $x_m = \\left(m - \\frac{N-1}{2}\\right) p$。在 $t=0$ 时，从阵列平面发射两个偏转角为 $\\theta = \\pm 10^\\circ$（度）的平面波。偏转角为 $\\theta$ 的平面波到达空间位置 $(x,z)$ 的时间与 $(x,z)$ 在平面波传播方向上的投影成正比，即，使用传播时间模型 $t_{\\mathrm{tx}}^{(\\theta)}(x,z) = \\left(x \\sin \\theta + z \\cos \\theta\\right)/c$，忽略一个不重要的加性常数。从 $(x,z)$ 到阵元 $m$ 的接收时间为 $t_{\\mathrm{rx}}(x,z;x_m) = \\sqrt{(x_m - x)^2 + z^2}/c$。假设衰减和角度灵敏度可以忽略不计，并且所有阵元具有相同的灵敏度。对于给定的发射角 $\\theta$，由位于 $(0,z_0)$ 的实际散射体引起的阵元 $m$ 上的复基带信号为 $s_m^{(\\theta)} = \\exp\\left(-j 2 \\pi f_0 \\left[t_{\\mathrm{tx}}^{(\\theta)}(0,z_0) + t_{\\mathrm{rx}}(0,z_0;x_m)\\right]\\right)$。为了在横向测试位置 $x$（深度为 $z_0$）处形成动态聚焦的波束形成输出，应用与相同发射角 $\\theta$ 下到 $(x,z_0)$ 的假设传播时间相对应的匹配滤波延迟，得到 $b^{(\\theta)}(x) = \\sum_{m=0}^{N-1} s_m^{(\\theta)} \\exp\\left(+j 2 \\pi f_0 \\left[t_{\\mathrm{tx}}^{(\\theta)}(x,z_0) + t_{\\mathrm{rx}}(x,z_0;x_m)\\right]\\right)$。将双角度相干复合输出定义为 $b^{\\mathrm{comp}}(x) = \\sum_{\\theta \\in \\{-10^\\circ,+10^\\circ\\}} b^{(\\theta)}(x)$。点扩散函数 (PSF) 是在固定深度 $z_0$ 下，作为横向位置 $x$ 的函数的波束形成输出的幅度 $|b(x)|$。将每个 PSF 通过其在评估的 $x$ 范围内的最大值进行归一化。将峰值周围的主瓣区域定义为归一化 PSF 幅度的全局最大值左右两侧第一个局部最小值之间的区间。将峰值旁瓣电平 (PSL) 定义为归一化 PSF 幅度在主瓣区域外的最大值。为了与单角度聚焦进行比较，仅使用 $\\theta = +10^\\circ$ 作为单角度情况。\n\n任务：编写一个程序，计算 $\\theta = +10^\\circ$ 时的归一化单角度 PSF，以及 $\\theta \\in \\{-10^\\circ,+10^\\circ\\}$ 时的归一化相干复合 PSF，然后通过计算单角度 PSL 和复合 PSL 之间的分贝差来量化由复合引起的旁瓣降低，即 $20 \\log_{10}(\\mathrm{PSL}_{\\mathrm{single}}) - 20 \\log_{10}(\\mathrm{PSL}_{\\mathrm{comp}})$。在输出中将最终答案以分贝为单位表示为浮点数。在发射模型中，角度必须以度为单位解释，并且物理量必须使用国际单位制：$x$ 和 $z$ 以 $\\mathrm{m}$ 为单位， $c$ 以 $\\mathrm{m/s}$ 为单位， $f_0$ 以 $\\mathrm{Hz}$ 为单位， $p$ 以 $\\mathrm{m}$ 为单位。横向评估网格必须在指定范围内均匀分布。程序应实现上述定义，不得引入任何替代的波束图样公式或近似。\n\n测试套件：您的程序必须按顺序执行以下三组参数，并为每组输出旁瓣降低值：\n\n- 情况 1（典型孔径和深度）：$N = 128$， $p = 0.0003\\,\\mathrm{m}$， $f_0 = 5.0 \\times 10^6\\,\\mathrm{Hz}$， $c = 1540\\,\\mathrm{m/s}$， $z_0 = 0.040\\,\\mathrm{m}$，横向网格 $x \\in [-0.015\\,\\mathrm{m}, 0.015\\,\\mathrm{m}]$，步长 $\\Delta x = 0.00005\\,\\mathrm{m}$。\n- 情况 2（较小孔径，较浅目标）：$N = 64$， $p = 0.0003\\,\\mathrm{m}$， $f_0 = 5.0 \\times 10^6\\,\\mathrm{Hz}$， $c = 1540\\,\\mathrm{m/s}$， $z_0 = 0.020\\,\\mathrm{m}$，横向网格 $x \\in [-0.015\\,\\mathrm{m}, 0.015\\,\\mathrm{m}]$，步长 $\\Delta x = 0.00005\\,\\mathrm{m}$。\n- 情况 3（更密集间距，更高频率，更深目标）：$N = 128$， $p = 0.0002\\,\\mathrm{m}$， $f_0 = 7.5 \\times 10^6\\,\\mathrm{Hz}$， $c = 1540\\,\\mathrm{m/s}$， $z_0 = 0.050\\,\\mathrm{m}$，横向网格 $x \\in [-0.010\\,\\mathrm{m}, 0.010\\,\\mathrm{m}]$，步长 $\\Delta x = 0.00005\\,\\mathrm{m}$。\n\n输出规格：您的程序应生成一行输出，其中包含三个情况的旁瓣降低值（以分贝为单位，四舍五入到三位小数），格式为方括号括起来的逗号分隔列表，例如 $[a_1,a_2,a_3]$，其中每个 $a_k$ 是一个浮点数。不应打印任何其他文本。",
            "solution": "用户提供的问题被评估为科学上合理、内容完整且定义明确。所有物理模型、数学定义和数值参数都已明确给出，并且与医学超声成像领域的既定原则一致。任务是基于这些第一性原理实现直接模拟。\n\n解决方案的步骤是：首先构建波束形成信号的数学模型，然后定义计算点扩散函数 (PSF) 和峰值旁瓣电平 (PSL) 的过程，最后将此过程应用于指定的测试用例。\n\n首先，我们确定几何和物理参数。该系统由一个包含 $N$ 个换能器阵元的线性阵列组成。对于 $m \\in \\{0, 1, \\dots, N-1\\}$，第 $m$ 个阵元的位置由 $x_m = \\left(m - \\frac{N-1}{2}\\right) p$ 给出，其中 $p$ 是阵元间距。单个点散射体位于 $(x_s, z_s) = (0, z_0)$。介质的声速 $c$ 是恒定的。换能器的工作中心频率为 $f_0$。为方便起见，定义声波数 $k = \\frac{2\\pi f_0}{c}$。\n\n成像过程包括两个阶段：发射和接收。\n1.  **发射阶段**：一个平面波被电子偏转，与 $z$ 轴成 $\\theta$ 角。该波前从阵列平面 ($z=0$) 传播到点 $(x, z)$ 所需的时间由 $t_{\\mathrm{tx}}^{(\\theta)}(x,z) = (x \\sin\\theta + z \\cos\\theta)/c$ 给出。对于位于 $(0, z_0)$ 的散射体，发射传播时间为 $t_{\\mathrm{tx}}^{(\\theta)}(0, z_0) = (z_0 \\cos\\theta)/c$。\n\n2.  **接收阶段**：散射后，超声波从位于 $(0, z_0)$ 的散射体传播到位于 $(x_m, 0)$ 的每个阵元 $m$。这是一个球面波，到阵元 $m$ 的传播时间由欧几里得距离决定：$t_{\\mathrm{rx}}(0, z_0; x_m) = \\frac{\\sqrt{(x_m - 0)^2 + (0 - z_0)^2}}{c} = \\frac{\\sqrt{x_m^2 + z_0^2}}{c}$。\n\n对于给定的发射角 $\\theta$，从发射到阵元 $m$ 接收的总传播时间是发射和接收时间之和：$T_m^{(\\theta)} = t_{\\mathrm{tx}}^{(\\theta)}(0, z_0) + t_{\\mathrm{rx}}(0, z_0; x_m)$。在阵元 $m$ 处接收到的复基带信号被建模为与此总延迟相对应的相位旋转：\n$$s_m^{(\\theta)} = \\exp(-j 2\\pi f_0 T_m^{(\\theta)}) = \\exp\\left(-j k \\left[z_0 \\cos\\theta + \\sqrt{x_m^2 + z_0^2}\\right]\\right)$$\n\n为了重建图像，接收到的信号使用一种称为动态接收聚焦的技术进行相干求和。这个过程等效于匹配滤波，它对来自每个阵元的信号施加一个共轭相移，该相移对应于从焦点 $(x, z_0)$ 到该阵元的*假设*传播时间。对于给定的发射角 $\\theta$，从发射到焦点 $(x, z_0)$ 然后再到阵元 $m$ 的总假设传播时间是 $T_{m,\\text{focus}}^{(\\theta)}(x, z_0) = t_{\\mathrm{tx}}^{(\\theta)}(x, z_0) + t_{\\mathrm{rx}}(x, z_0; x_m)$。阵元 $m$ 的聚焦相移是 $\\exp(+j 2\\pi f_0 T_{m,\\text{focus}}^{(\\theta)}(x, z_0))$。\n\n对于发射角 $\\theta$，波束形成输出是在已知深度 $z_0$ 的横向测试位置 $x$ 处对所有阵元进行相干求和：\n$$b^{(\\theta)}(x) = \\sum_{m=0}^{N-1} s_m^{(\\theta)} \\exp\\left(+j 2\\pi f_0 \\left[t_{\\mathrm{tx}}^{(\\theta)}(x, z_0) + t_{\\mathrm{rx}}(x, z_0; x_m)\\right]\\right)$$\n代入信号和聚焦延迟的表达式，以及传播时间的定义：\n$$b^{(\\theta)}(x) = \\sum_{m=0}^{N-1} \\exp\\left(-j k \\left[z_0 \\cos\\theta + \\sqrt{x_m^2 + z_0^2}\\right]\\right) \\exp\\left(+j k \\left[x \\sin\\theta + z_0 \\cos\\theta + \\sqrt{(x_m - x)^2 + z_0^2}\\right]\\right)$$\n项 $j k z_0 \\cos\\theta$ 被抵消，表达式简化为：\n$$b^{(\\theta)}(x) = \\sum_{m=0}^{N-1} \\exp\\left(j k \\left[x \\sin\\theta + \\sqrt{(x_m - x)^2 + z_0^2} - \\sqrt{x_m^2 + z_0^2}\\right]\\right)$$\n这是需要实现的基本方程。\n\n问题要求在单角度情况和相干复合情况之间进行比较。\n-   单角度波束形成输出使用 $\\theta = +10^\\circ$：$b^{\\mathrm{single}}(x) = b^{(+10^\\circ)}(x)$。\n-   相干复合输出将来自 $\\theta = +10^\\circ$ 和 $\\theta = -10^\\circ$ 的结果相加：$b^{\\mathrm{comp}}(x) = b^{(+10^\\circ)}(x) + b^{(-10^\\circ)}(x)$。\n\n点扩散函数 (PSF) 是复波束形成输出的幅度，并归一化到其最大值。对于单角度情况：\n$$\\mathrm{PSF}_{\\mathrm{single}}(x) = \\frac{|b^{\\mathrm{single}}(x)|}{\\max_x |b^{\\mathrm{single}}(x)|}$$\n对于复合情况，类似地：\n$$\\mathrm{PSF}_{\\mathrm{comp}}(x) = \\frac{|b^{\\mathrm{comp}}(x)|}{\\max_x |b^{\\mathrm{comp}}(x)|}$$\n\n峰值旁瓣电平 (PSL) 是归一化 PSF 在主瓣外的最大值。主瓣被定义为全局最大值左右两侧第一个局部最小值之间的区域。查找 PSL 的算法如下：\n1.  在指定的横向网格 $x$ 上计算归一化 PSF。\n2.  定位全局最大值的索引（主瓣的峰值）。\n3.  识别 PSF 的所有局部最小值。这可以通过查找负 PSF 的峰值来实现。\n4.  找到全局最大值左右两侧第一个局部最小值的索引。这些索引定义了主瓣的边界。\n5.  旁瓣区域由主瓣区间之外的所有点组成。\n6.  PSL 是旁瓣区域中 PSF 的最大值。\n\n最后，由复合引起的旁瓣降低被量化为 PSL 值在分贝 (dB) 标度上的差值：\n$$\\Delta_{\\mathrm{PSL}} [\\text{dB}] = 20 \\log_{10}(\\mathrm{PSL}_{\\mathrm{single}}) - 20 \\log_{10}(\\mathrm{PSL}_{\\mathrm{comp}})$$\n\n将此过程应用于问题陈述中提供的三个测试用例中的每一个。实现将使用 `numpy` 进行高效的数组计算，并使用 `scipy.signal.find_peaks` 来识别 PSF 的局部最小值。以度为单位给出的角度必须转换为弧度才能在三角函数中使用。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the Point Spread Functions (PSFs) for single-angle and \n    coherently compounded plane-wave imaging, calculates the Peak Sidelobe Level (PSL) \n    for each, and determines the sidelobe reduction in decibels.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"N\": 128, \"p\": 0.0003, \"f0\": 5.0e6, \"c\": 1540, \"z0\": 0.040,\n            \"x_range\": [-0.015, 0.015], \"dx\": 0.00005\n        },\n        {\n            \"N\": 64, \"p\": 0.0003, \"f0\": 5.0e6, \"c\": 1540, \"z0\": 0.020,\n            \"x_range\": [-0.015, 0.015], \"dx\": 0.00005\n        },\n        {\n            \"N\": 128, \"p\": 0.0002, \"f0\": 7.5e6, \"c\": 1540, \"z0\": 0.050,\n            \"x_range\": [-0.010, 0.010], \"dx\": 0.00005\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        p = case[\"p\"]\n        f0 = case[\"f0\"]\n        c = case[\"c\"]\n        z0 = case[\"z0\"]\n        x_min, x_max = case[\"x_range\"]\n        dx = case[\"dx\"]\n\n        # 1. Define Geometry and Grid\n        k = 2 * np.pi * f0 / c\n        thetas_deg = [-10.0, 10.0]\n        thetas_rad = np.deg2rad(thetas_deg)\n        x_m = (np.arange(N) - (N - 1) / 2) * p\n        x_grid = np.arange(x_min, x_max + dx, dx)\n\n        # 2. Calculate Beamformed Outputs\n        \n        # Reshape for broadcasting\n        # x_m: (N,) - (N, 1)\n        # x_grid: (M,) - (1, M) where M is number of grid points\n        x_m_bc = x_m[:, np.newaxis]\n        x_grid_bc = x_grid[np.newaxis, :]\n\n        # Term for actual scatterer at (0, z0)\n        rx_dist_scatterer = np.sqrt(x_m_bc**2 + z0**2)\n        \n        # Term for hypothesized scatterer at (x, z0)\n        rx_dist_focus = np.sqrt((x_m_bc - x_grid_bc)**2 + z0**2)\n        \n        # Calculate b_theta for each steering angle\n        b_thetas = []\n        for theta in thetas_rad:\n            phase = k * (x_grid_bc * np.sin(theta) + rx_dist_focus - rx_dist_scatterer)\n            b_theta = np.sum(np.exp(1j * phase), axis=0)\n            b_thetas.append(b_theta)\n\n        # 3. Form Single-Angle and Compounded Outputs\n        b_single = b_thetas[1]  # Using theta = +10 degrees\n        b_comp = b_thetas[0] + b_thetas[1]\n\n        # 4. Calculate Normalized PSFs\n        psf_single = np.abs(b_single)\n        psf_single_norm = psf_single / np.max(psf_single)\n\n        psf_comp = np.abs(b_comp)\n        psf_comp_norm = psf_comp / np.max(psf_comp)\n\n        # 5. Calculate PSL for each PSF\n        def find_psl(psf):\n            \"\"\"\n            Calculates the Peak Sidelobe Level (PSL) for a given normalized PSF.\n            \"\"\"\n            # Find the mainlobe peak\n            peak_idx = np.argmax(psf)\n            \n            # Find all local minima by finding peaks of the inverted PSF\n            minima_indices, _ = signal.find_peaks(-psf)\n            \n            # Find the first minima to the left and right of the main peak\n            left_minima = minima_indices[minima_indices  peak_idx]\n            right_minima = minima_indices[minima_indices  peak_idx]\n            \n            if left_minima.size == 0 or right_minima.size == 0:\n                # Fallback if no minima found on one side, which is unlikely for these PSFs.\n                # In this case, we cannot define the sidelobe region properly as per the problem.\n                # Returning NaN would indicate an issue with the PSF shape or grid extent.\n                return np.nan\n\n            first_left_min_idx = np.max(left_minima)\n            first_right_min_idx = np.min(right_minima)\n            \n            # The sidelobe regions are everything outside the mainlobe,\n            # including the minima themselves.\n            sidelobe_values = np.concatenate((psf[:first_left_min_idx + 1], psf[first_right_min_idx:]))\n            \n            if sidelobe_values.size == 0:\n                return 0.0 # No sidelobes present\n            \n            return np.max(sidelobe_values)\n\n        psl_single = find_psl(psf_single_norm)\n        psl_comp = find_psl(psf_comp_norm)\n        \n        # 6. Calculate Sidelobe Reduction in dB\n        # Ensure PSL values are  0 to avoid log(0) issues.\n        # Given the nature of diffraction, PSL will be  0.\n        db_diff = 20 * np.log10(psl_single) - 20 * np.log10(psl_comp)\n        results.append(db_diff)\n\n    # Final print statement in the exact required format.\n    # The problem asks for rounding to three decimal places.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}