{
    "hands_on_practices": [
        {
            "introduction": "SPECT成像的核心目标是测量放射性示踪剂的分布，而这一切始于探测单个光子。本练习将指导您从第一性原理出发，推导连接源活度与探测器计数率的基础方程。通过这个过程，您将理解几何效率和内在探测效率等关键概念，它们共同决定了我们最终能“看到”多少信号，为定量SPECT分析奠定基础。",
            "id": "4927588",
            "problem": "一个单光子发射计算机断层成像（SPECT）系统由一个平行孔准直器和一个闪烁探测器组成，用于记录来自放射性示踪剂源的入射伽马光子。考虑一个位于空气中、相对于探测器位置固定的点源，其活度 $A(t)$ 随时间变化，定义为单位时间内核衰变的期望数。假设光子发射是各向同性的，源与探测器之间的衰减和散射可忽略不计，且没有系统死时间或堆积效应。令 $p_{\\gamma}$ 表示一次核衰变发射一个在感兴趣光峰内的光子的概率（即每次衰变以概率 $p_{\\gamma}$ 产生一个光子），并令准直器-探测器系统接收探测器轴周围一个确定立体角 $\\Omega$ 内的光子。将几何效率 $\\eta_{g}$ 定义为各向同性发射的光子中，进入接收立体角并穿过准直几何结构到达探测器有效区域的光子所占的比例；将内在探测效率 $\\eta_{d}$ 定义为被接收且在探测器中发生相互作用的光子在光峰中产生一个计数的概率。\n\n从基本原理和上述定义出发，推导探测器记录的期望计数率 $R(t)$ 作为 $A(t)$、$p_{\\gamma}$、$\\eta_{g}$ 和 $\\eta_{d}$ 的函数。将您的最终答案表示为单个闭式解析表达式。如果您选择将 $\\eta_{g}$ 与立体角接收联系起来，您可以假设对于一个理想的准直器，它接收 $\\Omega$ 内的所有光子并拒绝所有其他光子，$\\eta_{g} = \\Omega/(4\\pi)$，但您的最终表达式必须只用 $A(t)$、$p_{\\gamma}$、$\\eta_{g}$ 和 $\\eta_{d}$ 来表示。不要提供任何数值计算。",
            "solution": "该问题陈述经评估有效。它在科学上基于核医学成像的原理，问题提出得很好，术语定义清晰，结果可推导且唯一，语言客观。所提供的假设，如可忽略的衰减和无死时间，是进行基本原理推导时的标准理想化条件。提供了所有必需的变量，且不存在矛盾。\n\n目标是推导SPECT探测器从一个活度随时间变化的 $A(t)$ 点源记录到的期望计数率 $R(t)$。推导过程通过系统地考虑将初始核衰变数减少到最终探测计数的连续概率和几何因素来进行。\n\n1.  **源活度**：过程始于放射源本身。活度 $A(t)$ 定义为单位时间内核衰变的期望数。\n    $$\n    \\text{Rate of decays} = A(t)\n    $$\n\n2.  **光子发射**：并非每次核衰变都会产生用于成像的特定能量的光子（即光峰内的光子）。题目给出了单次衰变发射这样一个光子的概率 $p_{\\gamma}$。假设每次衰变是独立事件，则光峰光子的期望发射率是衰变率与此概率的乘积。\n    $$\n    \\text{Rate of photopeak photon emission} = A(t) p_{\\gamma}\n    $$\n\n3.  **几何接收**：源各向同性地发射光子，意味着在 $4\\pi$ 球面度的总立体角内向所有方向均匀发射。准直器-探测器系统只能“看到”或接收在特定立体角和轨迹内发射的光子。几何效率 $\\eta_{g}$ 定义为所有各向同性发射的光子中，成功穿过准直器并入射到探测器有效区域的光子所占的比例。因此，为了求出到达探测器的光子速率，我们将光峰光子的总发射率乘以这个几何分数。\n    $$\n    \\text{Rate of photons incident on detector} = (A(t) p_{\\gamma}) \\eta_{g}\n    $$\n    这一步根据发射光子的行进方向有效地对其进行过滤。如题目所述，对于一个接收立体角 $\\Omega$ 内光子的理想化系统，该效率为 $\\eta_{g} = \\frac{\\Omega}{4\\pi}$。然而，最终表达式需用 $\\eta_g$ 表示。\n\n4.  **内在探测**：入射到探测器上的光子不保证被计数。它必须与闪烁晶体相互作用，并且产生的信号必须落在与光峰对应的预设能量窗内。内在探测效率 $\\eta_{d}$ 是一个已穿过准直器的入射光子被成功探测并记录为一个计数的概率。最终的期望计数率 $R(t)$ 是通过将入射光子速率乘以这个探测概率得到的。\n    $$\n    \\text{Expected count rate} = R(t) = (A(t) p_{\\gamma} \\eta_{g}) \\eta_{d}\n    $$\n\n综合这些步骤，我们得到期望计数率的最终表达式。每一项都代表对初始衰变率的连续过滤：$A(t)$ 是事件的初始速率；$p_{\\gamma}$ 过滤出正确的事件类型（光子发射）；$\\eta_{g}$ 过滤出正确的几何形状（方向）；$\\eta_{d}$ 过滤出成功的探测。无死时间或堆积的假设至关重要，因为它确保了系统响应是线性的，并且可以直接将概率相乘，而无需考虑探测器饱和效应。\n\n期望计数率 $R(t)$ 作为给定参数的函数的最终闭式解析表达式是所有贡献因素的乘积。",
            "answer": "$$\n\\boxed{R(t) = A(t) p_{\\gamma} \\eta_{g} \\eta_{d}}\n$$"
        },
        {
            "introduction": "在上一个练习中，我们了解了总计数率如何受到几何效率 ($\\eta_g$) 的影响。现在，我们将深入探讨如何通过优化准直器的设计来提升这一关键参数。本练习聚焦于准直器孔的几何排列方式，您将通过计算证明，在其他条件相同时，为何六边形排列比正方形排列能提供更高的探测灵敏度。这个实践清晰地揭示了工程设计选择如何直接影响SPECT系统的核心性能。",
            "id": "4927633",
            "problem": "一个单光子发射计算机断层成像 (SPECT) 平行孔准直器具有直径为 $d$、长度为 $L$ 的圆形孔，它被制造成两种在其他方面完全相同的方案。在方案 A 中，孔的中心位于方形点阵上；在方案 B 中，孔的中心位于三角形（六边形）点阵上。在两种方案中，相邻孔之间的中心间距 $p$ 相同，隔片材料和厚度也均匀，因此几何比较是有效的。假设准直器表面足够大，以至于边缘效应可以忽略不计，且排列是完全周期性的。\n\n从以下基础开始：\n- 开孔率 $\\phi$ 定义为总开孔面积与总表面积之比。对于每个原胞含有一个孔的周期性阵列，$\\phi$ 等于孔面积与原胞面积之比。\n- 对于近乎垂直入射到表面的光子，平行孔准直器的几何灵敏度 $S$ 与开孔率 $\\phi$ 以及一个仅取决于 $d$ 和 $L$ 的角度接收因子成线性比例关系。在固定的 $d$ 和 $L$ 条件下，这个角度接收因子对于两种点阵是相同的。\n\n仅使用这些定义和初等平面几何，推导每种点阵的原胞面积，然后推导出相应的开孔率 $\\phi_{\\mathrm{sq}}$ 和 $\\phi_{\\mathrm{hex}}$。最后，在 $d$ 和 $L$ 固定且中心间距 $p$ 相同的条件下，推导出灵敏度增益因子\n$$G \\equiv \\frac{S_{\\mathrm{hex}}}{S_{\\mathrm{sq}}}。$$\n\n将 $G$ 的最终答案表示为单个精确的解析表达式。不需要四舍五入，最终答案中不应包含单位。",
            "solution": "对于每个原胞含有一个孔的周期性阵列，其开孔率 $\\phi$ 为\n$$\\phi = \\frac{A_{\\mathrm{hole}}}{A_{\\mathrm{cell}}},$$\n其中 $A_{\\mathrm{hole}}$ 是一个孔的面积，$A_{\\mathrm{cell}}$ 是与一个点阵点（一个孔）相关联的原胞面积。对于直径为 $d$ 的圆形孔，孔面积为\n$$A_{\\mathrm{hole}} = \\pi \\left(\\frac{d}{2}\\right)^{2} = \\frac{\\pi d^{2}}{4}。$$\n\n我们现在确定每种点阵的 $A_{\\mathrm{cell}}$。\n\n方形点阵：\n原胞是边长为 $p$ 的正方形，所以\n$$A_{\\mathrm{cell,\\,sq}} = p^{2}。$$\n因此，方形点阵的开孔率为\n$$\\phi_{\\mathrm{sq}} = \\frac{A_{\\mathrm{hole}}}{A_{\\mathrm{cell,\\,sq}}} = \\frac{\\pi d^{2}/4}{p^{2}} = \\frac{\\pi d^{2}}{4 p^{2}}。$$\n\n三角形（六边形）点阵：\n孔的中心形成一个三角形点阵，由两个长度为 $p$、夹角为 $60^{\\circ}$ 的向量生成。原胞（由这两个向量张成的平行四边形）的面积是点阵基向量叉积的模，\n$$A_{\\mathrm{cell,\\,hex}} = p \\cdot p \\cdot \\sin\\!\\left(60^{\\circ}\\right) = p^{2} \\cdot \\frac{\\sqrt{3}}{2} = \\frac{\\sqrt{3}}{2}\\,p^{2}。$$\n因此，六边形堆积的开孔率为\n$$\\phi_{\\mathrm{hex}} = \\frac{A_{\\mathrm{hole}}}{A_{\\mathrm{cell,\\,hex}}} = \\frac{\\pi d^{2}/4}{(\\sqrt{3}/2)\\,p^{2}} = \\frac{\\pi}{2\\sqrt{3}}\\;\\frac{d^{2}}{p^{2}}。$$\n\n物理解释：\n与方形堆积相比，六边形（三角形）堆积能更有效地放置孔中心，减少了孔之间的浪费面积。这增加了孔所占表面的比例，即开孔率。\n\n在 $d$ 和 $L$ 固定时的灵敏度增益：\n几何灵敏度 $S$ 的比例关系为\n$$S \\propto \\phi \\times f(d,L),$$\n其中 $f(d,L)$ 是仅由 $d$ 和 $L$ 决定的角度接收因子。因为在两种方案中 $d$ 和 $L$ 是固定且相同的，所以 $f(d,L)$ 也相同，在比率中被消去。因此，灵敏度增益因子是开孔率之比：\n$$G \\equiv \\frac{S_{\\mathrm{hex}}}{S_{\\mathrm{sq}}} = \\frac{\\phi_{\\mathrm{hex}}}{\\phi_{\\mathrm{sq}}} = \\frac{\\left(\\frac{\\pi}{2\\sqrt{3}}\\frac{d^{2}}{p^{2}}\\right)}{\\left(\\frac{\\pi}{4}\\frac{d^{2}}{p^{2}}\\right)} = \\frac{4}{2\\sqrt{3}} = \\frac{2}{\\sqrt{3}}。$$\n\n因此，当 $d$ 和 $L$ 固定且中心间距 $p$ 相同时，相对于方形堆积，六边形堆积将开孔率以及相应的灵敏度提高了 $\\frac{2}{\\sqrt{3}}$ 倍。",
            "answer": "$$\\boxed{\\frac{2}{\\sqrt{3}}}$$"
        },
        {
            "introduction": "真实的SPECT成像总是在各种性能指标之间进行权衡取舍，其中最著名的就是灵敏度与分辨率之间的矛盾。本练习将让您扮演一名医学物理师，综合运用前面学到的知识来解决一个系统级的优化问题。您需要在一个包含多种准直器、扫描半径和角度采样方案的参数空间中，寻找能同时满足给定分辨率和噪声要求的最佳采集方案，从而深刻体会真实世界中SPECT系统设计的复杂性与精妙之处。",
            "id": "4927587",
            "problem": "您需要实现一个程序，该程序将单光子发射计算机断层扫描（SPECT）中噪声-分辨率权衡的简化第一性原理模型形式化并求解，该模型是角度采样、旋转半径和探测器-准直器属性的函数。目标是提出能够同时满足指定分辨率和噪声目标的采集参数选择。\n\n从以下广泛接受的定义和物理关系的基础开始：\n\n- 对于源到准直器距离为 $z$（单位 $\\mathrm{mm}$）的平行孔准直器，其几何分辨率被建模为半高全宽（FWHM），由 $R_{\\mathrm{coll}}(z) = d \\cdot \\dfrac{L + z}{L}$ 给出，其中 $d$ 是孔径（单位 $\\mathrm{mm}$），$L$ 是孔长（单位 $\\mathrm{mm}$）。\n- 探测器的固有分辨率（包括固有模糊和像素采样）由 FWHM $R_{\\mathrm{int}}$（单位 $\\mathrm{mm}$）建模。\n- 不考虑角度采样效应的系统分辨率 FWHM 被建模为独立模糊分量的平方和的平方根：$R_{\\mathrm{sys,0}}(z) = \\sqrt{R_{\\mathrm{int}}^{2} + R_{\\mathrm{coll}}(z)^{2}}$。\n- 角度采样引入了额外的有效切向模糊。使用感兴趣物体半径 $r$（单位 $\\mathrm{mm}$）和 $N$ 个均匀覆盖整个旋转的投影角度，定义角度步长 $\\Delta \\theta = \\dfrac{2\\pi}{N}$（单位 $\\mathrm{radians}$）。角度采样模糊被建模为 $R_{\\mathrm{ang}} = r \\, \\Delta \\theta$（单位 $\\mathrm{mm}$）。\n- 将独立模糊分量进行正交叠加（in quadrature）以获得有效 FWHM：$R_{\\mathrm{eff}} = \\sqrt{R_{\\mathrm{sys,0}}(z)^{2} + R_{\\mathrm{ang}}^{2}}$。\n- 准直器灵敏度被建模为几何填充因子与开放面积缩放的乘积，与一个比例常数成正比：$S_{\\mathrm{rel}} = \\left(\\dfrac{d}{d + t}\\right)^{2} \\cdot \\dfrac{d^{2}}{L^{2}}$，其中 $t$ 是隔片厚度（单位 $\\mathrm{mm}$）。这是一个无量纲单位的相对灵敏度。\n- 对于持续时间为 $T$（单位 $\\mathrm{s}$）、注射活度为 $A$（单位 $\\mathrm{MBq}$）的扫描，总探测计数被建模为 $C = k \\, A \\, T \\, S_{\\mathrm{rel}}$，其中 $k$ 是一个固定的比例常数，其单位为 $\\mathrm{counts \\cdot s^{-1} \\cdot MBq^{-1}}$，将在下面设定。噪声度量取为均匀区域的变异系数，$\\eta = \\dfrac{1}{\\sqrt{C}}$（无量纲，报告时使用小数形式，不带百分号）。\n\n几何与距离约定：\n\n- 使用旋转半径（ROR）作为从系统旋转中心到准直器表面的距离。在计算分辨率时，于平均距离 $z = \\mathrm{ROR}$ 处评估 $z$，这是对围绕旋转中心进行全角度采样的点的标准近似。\n\n对于每个测试用例，您的程序必须从离散的允许集合中选择参数，以同时满足有效分辨率目标和噪声限制：\n\n- 从允许集合 $\\{60, 90, 120, 180\\}$ 中选择投影数 $N$。\n- 从允许集合 $\\{140\\,\\mathrm{mm}, 180\\,\\mathrm{mm}\\}$ 中选择旋转半径 $\\mathrm{ROR}$。\n- 从三个准直器中选择一个，其特征由 $(d, L, t)$（单位 $\\mathrm{mm}$）描述：\n  1. 低能高分辨率（LEHR）：$(d, L, t) = (1.5, 35, 0.2)$。\n  2. 低能通用型（LEGP）：$(d, L, t) = (1.9, 25, 0.2)$。\n  3. 高灵敏度（HS）：$(d, L, t) = (2.4, 20, 0.2)$。\n\n使用固定的计数比例常数 $k = 100\\,\\mathrm{counts \\cdot s^{-1} \\cdot MBq^{-1}}$。所有角度计算均使用弧度（$\\mathrm{radians}$）。\n\n对于给定的测试用例参数 $(A, T, R_{\\mathrm{int}}, r, R_{\\mathrm{target}}, \\eta_{\\max})$，候选三元组 $(N, \\mathrm{ROR}, \\text{collimator})$ 的可行性标准如下：\n\n- 计算所选准直器的 $S_{\\mathrm{rel}}$。\n- 计算 $C = k \\, A \\, T \\, S_{\\mathrm{rel}}$ 和 $\\eta = \\dfrac{1}{\\sqrt{C}}$。\n- 计算 $R_{\\mathrm{coll}}(\\mathrm{ROR})$，然后计算 $R_{\\mathrm{sys,0}}(\\mathrm{ROR})$，接着使用 $\\Delta \\theta = \\dfrac{2\\pi}{N}$ 计算 $R_{\\mathrm{ang}}$，最后计算 $R_{\\mathrm{eff}}$。\n- 如果 $R_{\\mathrm{eff}} \\le R_{\\mathrm{target}}$ 且 $\\eta \\le \\eta_{\\max}$，则该候选者是可行的。\n\n每个测试用例在可行候选者中的选择规则：\n\n- 首要标准：最小化 $\\eta$。\n- 次要标准（若 $\\eta$ 值在 $10^{-12}$ 范围内相等，则作为决胜条件）：选择最大的 $\\mathrm{ROR}$。\n- 第三标准（若仍有平局）：选择最小的 $N$。\n- 如果没有可行的候选者，则该测试用例被声明为不可行。\n\n单位与报告：\n\n- 距离必须以 $\\mathrm{mm}$ 为单位，时间以 $\\mathrm{s}$ 为单位，活度以 $\\mathrm{MBq}$ 为单位，角度以 $\\mathrm{radians}$ 为单位。\n- 您的程序必须使用上述单位和模型进行计算。\n- 对于每个测试用例，您的程序必须输出以下之一：\n  - 如果存在可行的候选者，则按顺序输出四个数字 $(N, \\mathrm{ROR}, d, L)$，或\n  - 如果不可行，则输出单个整数 $-1$。\n- 将所有测试用例的输出聚合到一个扁平列表中，按测试用例顺序排列，以逗号分隔，并用方括号括起来，放在一行中。例如，如果有五个测试用例，第一个产生一个可行的四元组，而第二个不可行，则输出以类似 $[N_{1}, \\mathrm{ROR}_{1}, d_{1}, L_{1}, -1, \\dots]$ 的形式开始。\n- 输出中的数值必须是不带单位的原始数字。\n\n测试套件：\n\n对于以下所有测试用例，请严格按照上述说明使用候选集合和常数 $k$。\n\n- 测试用例 1（顺利路径，分辨率受限）：\n  - $A = 150\\,\\mathrm{MBq}$，$T = 600\\,\\mathrm{s}$，$R_{\\mathrm{int}} = 3.5\\,\\mathrm{mm}$，$r = 100\\,\\mathrm{mm}$，\n  - $R_{\\mathrm{target}} = 10.0\\,\\mathrm{mm}$，$\\eta_{\\max} = 0.02$。\n- 测试用例 2（低活度下噪声受限）：\n  - $A = 20\\,\\mathrm{MBq}$，$T = 600\\,\\mathrm{s}$，$R_{\\mathrm{int}} = 3.5\\,\\mathrm{mm}$，$r = 100\\,\\mathrm{mm}$，\n  - $R_{\\mathrm{target}} = 20.0\\,\\mathrm{mm}$，$\\eta_{\\max} = 0.01$。\n- 测试用例 3（较大半径下角度采样受限）：\n  - $A = 80\\,\\mathrm{MBq}$，$T = 300\\,\\mathrm{s}$，$R_{\\mathrm{int}} = 3.5\\,\\mathrm{mm}$，$r = 150\\,\\mathrm{mm}$，\n  - $R_{\\mathrm{target}} = 12.0\\,\\mathrm{mm}$，$\\eta_{\\max} = 0.02$。\n- 测试用例 4（权衡倾向于更高灵敏度同时仍满足分辨率要求）：\n  - $A = 100\\,\\mathrm{MBq}$，$T = 200\\,\\mathrm{s}$，$R_{\\mathrm{int}} = 3.5\\,\\mathrm{mm}$，$r = 50\\,\\mathrm{mm}$，\n  - $R_{\\mathrm{target}} = 17.0\\,\\mathrm{mm}$，$\\eta_{\\max} = 0.015$。\n- 测试用例 5（目标分辨率不可行）：\n  - $A = 500\\,\\mathrm{MBq}$，$T = 600\\,\\mathrm{s}$，$R_{\\mathrm{int}} = 3.5\\,\\mathrm{mm}$，$r = 100\\,\\mathrm{mm}$，\n  - $R_{\\mathrm{target}} = 8.0\\,\\mathrm{mm}$，$\\eta_{\\max} = 0.02$。\n\n最终输出格式：\n\n- 您的程序应生成一行输出，其中包含一个用逗号分隔并用方括号括起来的结果列表，按顺序连接每个测试用例的结果。例如：$[N_{1}, \\mathrm{ROR}_{1}, d_{1}, L_{1}, N_{2}, \\mathrm{ROR}_{2}, d_{2}, L_{2}, \\dots]$，任何不可行的测试用例则用单个 $-1$ 代替四个数字。",
            "solution": "该问题是有效的。它基于单光子发射计算机断层扫描（SPECT）的既定原理，提出了一个有科学依据、良构且客观的任务。所提供的分辨率和灵敏度的物理模型是医学成像物理学中使用的标准（尽管是简化的）表示方法。所有参数、约束、选择集和选择标准都得到了明确无误的定义，确保了每个测试用例都存在唯一且可计算的解。\n\n该问题要求在离散参数空间上进行约束优化，以设计一个SPECT采集协议。目标是找到一组采集参数——投影角度数（$N$）、旋转半径（$\\mathrm{ROR}$）和准直器类型——以满足指定的有效分辨率（$R_{\\mathrm{eff}} \\le R_{\\mathrm{target}}$）和统计噪声（$\\eta \\le \\eta_{\\max}$）目标。\n\n其核心科学原理是SPECT中系统分辨率和灵敏度之间固有的权衡。具有较高几何分辨率的准直器（例如，孔更小、孔道更长，如LEHR）灵敏度较低，导致探测到的光子（$C$）更少，从而产生更高的统计噪声（$\\eta = 1/\\sqrt{C}$）。相反，高灵敏度准直器（例如，HS）以牺牲较差的空间分辨率为代价来提供更低的噪声。任务是在这种权衡以及其他几何因素中进行抉择，以找到一个最优的可行协议。\n\n该算法解决方案通过系统地评估每个测试用例的所有可能参数组合来推进。每个采集协议的参数空间是 $N$、$\\mathrm{ROR}$ 和准直器类型的允许集合的笛卡尔积，导致每个测试用例需要评估 $4 \\times 2 \\times 3 = 24$ 个候选协议。\n\n对于每个由三元组 $(N, \\mathrm{ROR}, \\text{collimator})$ 表征的候选协议，以及测试用例给定的条件 ($A, T, R_{\\mathrm{int}}, r, R_{\\mathrm{target}}, \\eta_{\\max}$)，执行以下步骤：\n\n1.  **计算噪声**：噪声度量 $\\eta$ 取决于总探测计数 $C$，而 $C$ 与准直器的相对灵敏度 $S_{\\mathrm{rel}}$ 成正比。使用常数 $k = 100\\,\\mathrm{counts \\cdot s^{-1} \\cdot MBq^{-1}}$。\n    $$S_{\\mathrm{rel}} = \\left(\\frac{d}{d + t}\\right)^{2} \\cdot \\frac{d^{2}}{L^{2}}$$\n    $$C = k \\, A \\, T \\, S_{\\mathrm{rel}}$$\n    $$\\eta = \\frac{1}{\\sqrt{C}}$$\n    这里，($d, L, t$) 是所选准直器的参数。对于给定的测试用例（固定的 $A, T$），$\\eta$ 仅由准直器的选择决定。\n\n2.  **计算有效分辨率**：有效分辨率 $R_{\\mathrm{eff}}$ 是通过将多个独立模糊分量进行正交叠加（in quadrature）来计算的。\n    - 准直器的几何分辨率 $R_{\\mathrm{coll}}$ 在距离 $z = \\mathrm{ROR}$ 处进行评估。\n      $$R_{\\mathrm{coll}}(\\mathrm{ROR}) = d \\cdot \\frac{L + \\mathrm{ROR}}{L}$$\n    - 这与探测器的固有分辨率 $R_{\\mathrm{int}}$ 相结合。\n      $$R_{\\mathrm{sys,0}}(\\mathrm{ROR}) = \\sqrt{R_{\\mathrm{int}}^{2} + R_{\\mathrm{coll}}(\\mathrm{ROR})^{2}}$$\n    - 由角度采样引起的模糊 $R_{\\mathrm{ang}}$ 根据投影数 $N$ 和物体半径 $r$ 计算。\n      $$\\Delta \\theta = \\frac{2\\pi}{N}$$\n      $$R_{\\mathrm{ang}} = r \\, \\Delta \\theta$$\n    - 最终的有效分辨率 $R_{\\mathrm{eff}}$ 结合了这些分量。\n      $$R_{\\mathrm{eff}} = \\sqrt{R_{\\mathrm{sys,0}}(\\mathrm{ROR})^{2} + R_{\\mathrm{ang}}^{2}}$$\n\n3.  **可行性检查**：如果一个候选协议同时满足两个性能目标，则被视为可行：\n    $$R_{\\mathrm{eff}} \\le R_{\\mathrm{target}} \\quad \\text{且} \\quad \\eta \\le \\eta_{\\max}$$\n\n4.  **最优选择**：在为每个测试用例识别出所有可行候选者之后，根据指定的分层标准选择唯一的最佳协议：\n    - **首要标准**：最小化噪声度量 $\\eta$。\n    - **次要标准**：对于 $\\eta$ 值并列（或在 $10^{-12}$ 容差内相等，尽管此处每种准直器类型的 $\\eta$ 值是不同的）的候选者，选择具有最大 $\\mathrm{ROR}$ 的一个。\n    - **第三标准**：如果仍然并列，选择具有最小 $N$ 的候选者。\n\n    如果可行候选者的集合为空，则该测试用例被声明为不可行，输出为整数 $-1$。否则，输出为所选最优协议的四元组 $(N, \\mathrm{ROR}, d, L)$。对每个提供的测试用例重复此整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Formalizes and solves a simplified model of the noise-resolution trade-off\n    in SPECT to select optimal acquisition parameters.\n    \"\"\"\n    \n    # Global constants and parameter choices as per the problem statement\n    K_CONST = 100.0  # counts * s^-1 * MBq^-1\n    N_CHOICES = [60, 90, 120, 180]\n    ROR_CHOICES = [140.0, 180.0]  # in mm\n    \n    COLLIMATORS = {\n        'LEHR': {'d': 1.5, 'L': 35.0, 't': 0.2},  # Low-Energy High-Resolution\n        'LEGP': {'d': 1.9, 'L': 25.0, 't': 0.2},  # Low-Energy General-Purpose\n        'HS':   {'d': 2.4, 'L': 20.0, 't': 0.2}   # High-Sensitivity\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'A': 150, 'T': 600, 'R_int': 3.5, 'r': 100, 'R_target': 10.0, 'eta_max': 0.02},\n        {'A': 20,  'T': 600, 'R_int': 3.5, 'r': 100, 'R_target': 20.0, 'eta_max': 0.01},\n        {'A': 80,  'T': 300, 'R_int': 3.5, 'r': 150, 'R_target': 12.0, 'eta_max': 0.02},\n        {'A': 100, 'T': 200, 'R_int': 3.5, 'r': 50,  'R_target': 17.0, 'eta_max': 0.015},\n        {'A': 500, 'T': 600, 'R_int': 3.5, 'r': 100, 'R_target': 8.0,  'eta_max': 0.02},\n    ]\n\n    # Pre-calculate relative sensitivity for each collimator\n    s_rels = {}\n    for name, params in COLLIMATORS.items():\n        d, L, t = params['d'], params['L'], params['t']\n        s_rels[name] = (d / (d + t))**2 * (d**2 / L**2)\n\n    final_results = []\n    \n    for case in test_cases:\n        A, T, R_int, r, R_target, eta_max = case.values()\n        \n        # Calculate noise metric eta for each collimator type for the current test case.\n        # Eta depends on A and T, so it is specific to the test case.\n        etas = {}\n        for name, s_rel in s_rels.items():\n            C = K_CONST * A * T * s_rel\n            if C > 0:\n                etas[name] = 1.0 / np.sqrt(C)\n            else:\n                etas[name] = float('inf')\n\n        feasible_candidates = []\n\n        # Iterate through all possible parameter combinations\n        for N in N_CHOICES:\n            for ROR in ROR_CHOICES:\n                for coll_name, coll_params in COLLIMATORS.items():\n                    \n                    # 1. Calculate and check noise\n                    eta = etas[coll_name]\n                    if eta > eta_max:\n                        continue  # This choice is too noisy\n\n                    # 2. Calculate effective resolution\n                    d, L = coll_params['d'], coll_params['L']\n                    \n                    R_coll = d * (L + ROR) / L\n                    R_sys0 = np.sqrt(R_int**2 + R_coll**2)\n                    \n                    delta_theta = 2 * np.pi / N\n                    R_ang = r * delta_theta\n                    \n                    R_eff = np.sqrt(R_sys0**2 + R_ang**2)\n                    \n                    # 3. Check resolution constraint\n                    if R_eff = R_target:\n                        # Candidate is feasible, store its parameters and metrics\n                        candidate_data = {\n                            'N': N, 'ROR': ROR, 'd': d, 'L': L, 'eta': eta\n                        }\n                        feasible_candidates.append(candidate_data)\n        \n        # 4. Select the best candidate or declare infeasible\n        if not feasible_candidates:\n            final_results.append(-1)\n        else:\n            # Sort the feasible candidates based on the hierarchical criteria:\n            # 1. Minimize eta (ascending)\n            # 2. Maximize ROR (descending, hence the negative sign)\n            # 3. Minimize N (ascending)\n            feasible_candidates.sort(key=lambda c: (c['eta'], -c['ROR'], c['N']))\n            \n            best_candidate = feasible_candidates[0]\n            final_results.extend([\n                best_candidate['N'], \n                best_candidate['ROR'], \n                best_candidate['d'], \n                best_candidate['L']\n            ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}