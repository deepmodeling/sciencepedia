{
    "hands_on_practices": [
        {
            "introduction": "伽玛相机的第一项任务是精确测量入射伽玛光子的能量。这对于区分来自放射性药物的有用信号与来自患者体内的散射光子至关重要。本练习将引导您逐步分析从单次伽玛射线相互作用到产生电子信号的整个过程，揭示决定相机能量分辨率的根本统计限制。通过这个练习，您将亲手计算一个典型探测器系统产生的预期光电子数量和最终的能量分辨率，从而深入理解决定探测器性能的关键物理参数。",
            "id": "4888105",
            "problem": "一台基于铊激活碘化钠闪烁体（NaI(Tl)）和光电倍增管（PMT）的伽马相机，通过将闪烁光转换为电信号来测量入射伽马射线的能量。考虑一次能量为$140\\,\\mathrm{keV}$的伽马射线相互作用，在晶体中产生了 $N_{ph}=5320$ 个闪烁光子。每个光子以 $0.80$ 的收集效率被传输到光电倍增管，如果它到达光电阴极，则有 $0.25$ 的量子效率产生一个光电子。光电倍增管的倍增过程会引入增益涨落，其特征为一个等于 $F=1.2$ 的过剩噪声因子。\n\n从 (i) 将量子效率和收集效率定义为光子探测概率，(ii) 光电子计数的泊松统计，以及 (iii) 能量分辨率定义为高斯响应的半高全宽（FWHM）与平均值之比出发，推导此事件中探测到的光电子的期望数 $N_{pe}$ 和预测的分数能量分辨率 $R_E$。将 $R_E$ 表示为一个无量纲小数，并四舍五入到四位有效数字。以有序对 $\\left(N_{pe}, R_E\\right)$ 的形式给出最终答案。",
            "solution": "该问题要求推导在闪烁探测器中一次伽马射线相互作用所产生的探测到的光电子的期望数 $\\bar{N}_{pe}$ 和分数能量分辨率 $R_E$。\n\n首先，我们确定光电子的期望数 $\\bar{N}_{pe}$。\n该过程始于一次伽马射线相互作用，它产生平均数量为 $\\bar{N}_{ph} = 5320$ 的闪烁光子。这些光子行进到光电倍增管（PMT）的光电阴极。问题陈述，收集效率 $\\eta_c = 0.80$ 可以被解释为任意一个光子到达光电阴极的概率。到达光电阴极后，每个光子有 $\\eta_q = 0.25$ 的量子效率（即概率）来产生一个光电子。\n\n因此，单个闪烁光子成功产生一个光电子的总概率 $p$ 是这些独立概率的乘积：\n$$p = \\eta_c \\times \\eta_q$$\n由初始的 $\\bar{N}_{ph}$ 个光子所产生的光电子的期望数 $\\bar{N}_{pe}$，由光子数与每个光子的转换概率的乘积给出：\n$$\\bar{N}_{pe} = \\bar{N}_{ph} \\times p = \\bar{N}_{ph} \\eta_c \\eta_q$$\n代入给定值：\n$$\\bar{N}_{pe} = 5320 \\times 0.80 \\times 0.25$$\n$$\\bar{N}_{pe} = 5320 \\times 0.20$$\n$$\\bar{N}_{pe} = 1064$$\n这是在光电阴极处产生的光电子的期望数。\n\n接下来，我们推导分数能量分辨率 $R_E$。\n能量分辨率定义为探测到的能量峰的半高全宽（FWHM）与平均能量 $\\bar{E}$（或等效地，平均信号 $\\bar{S}$）之比：\n$$R_E = \\frac{\\text{FWHM}}{\\bar{S}}$$\n问题指明探测器响应是高斯的。对于高斯分布，FWHM 与分布的标准差 $\\sigma_S$ 的关系为：\n$$\\text{FWHM} = 2\\sqrt{2\\ln 2} \\ \\sigma_S$$\n将此代入 $R_E$ 的定义中：\n$$R_E = 2\\sqrt{2\\ln 2} \\frac{\\sigma_S}{\\bar{S}}$$\n量 $\\frac{\\sigma_S}{\\bar{S}}$ 是输出信号的分数标准差。我们的任务是将其与探测器中的统计涨落联系起来。\n\n信号生成涉及两个主要的统计过程：光电子的产生以及它们随后在光电倍增管中的倍增。\n1.  **光电子统计**：按照指示，我们将光电子的生成建模为泊松过程。对于平均光电子数为 $\\bar{N}_{pe}$，其方差为 $\\sigma_{N_{pe}}^2 = \\bar{N}_{pe}$。光电子的信噪比平方为 $(\\text{S/N})^2_{\\text{in}} = \\frac{\\bar{N}_{pe}^2}{\\sigma_{N_{pe}}^2} = \\frac{\\bar{N}_{pe}^2}{\\bar{N}_{pe}} = \\bar{N}_{pe}$。\n\n2.  **光电倍增管倍增**：光电倍增管中的倍增过程也是统计性的，并会引入额外的噪声。过剩噪声因子 $F$ 量化了信噪比的这种劣化。它定义为输入端（光电阴极）的信噪比平方与输出端（阳极）的信噪比平方之比：\n$$F = \\frac{(\\text{S/N})^2_{\\text{in}}}{(\\text{S/N})^2_{\\text{out}}}$$\n输出端的信噪比平方为 $(\\text{S/N})^2_{\\text{out}} = \\frac{\\bar{S}^2}{\\sigma_S^2}$。\n\n将输入和输出信噪比平方的表达式代入 $F$ 的定义中，我们可以求解输出信号的分数方差：\n$$F = \\frac{\\bar{N}_{pe}}{\\bar{S}^2 / \\sigma_S^2} = \\bar{N}_{pe} \\left(\\frac{\\sigma_S}{\\bar{S}}\\right)^2$$\n重新整理此方程可得：\n$$\\left(\\frac{\\sigma_S}{\\bar{S}}\\right)^2 = \\frac{F}{\\bar{N}_{pe}}$$\n因此，分数标准差为：\n$$\\frac{\\sigma_S}{\\bar{S}} = \\sqrt{\\frac{F}{\\bar{N}_{pe}}}$$\n现在，我们将此结果代回到能量分辨率 $R_E$ 的表达式中：\n$$R_E = 2\\sqrt{2\\ln 2} \\sqrt{\\frac{F}{\\bar{N}_{pe}}}$$\n使用计算出的值 $\\bar{N}_{pe} = 1064$ 和给定的值 $F = 1.2$：\n$$R_E = 2\\sqrt{2\\ln 2} \\sqrt{\\frac{1.2}{1064}}$$\n$$R_E \\approx 2.35482 \\sqrt{0.0011278195...}$$\n$$R_E \\approx 2.35482 \\times 0.03358302...$$\n$$R_E \\approx 0.0790803...$$\n问题要求结果四舍五入到四位有效数字。\n$$R_E \\approx 0.07908$$\n\n最终答案是有序对 $(\\bar{N}_{pe}, R_E)$。\n计算出的值为 $\\bar{N}_{pe} = 1064$ 和 $R_E = 0.07908$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1064 & 0.07908\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在确定了光子能量之后，伽玛相机必须确定光子来自何处，这决定了图像的空间分辨率或清晰度。系统的空间分辨率不是由单一组件决定的，而是由多个组件的模糊效应叠加而成，其中最主要的是闪烁晶体自身的“固有分辨率”和准直器的“几何分辨率”。本练习将让您探索如何将这两个独立的模糊分量（假设为高斯分布）进行合成，以预测最终的系统分辨率。掌握正交相加的原理是理解和评估任何成像系统性能的基础。",
            "id": "4888042",
            "problem": "一台配备平行孔准直器的伽马相机用于对一个点源进行成像，该点源位于源到准直器距离$z=10\\,\\mathrm{cm}$处。相机的测量内在点扩散函数（PSF）可以很好地用一个高斯函数来近似，其标准差为$\\sigma_{int}=1.5\\,\\mathrm{mm}$。在$z=10\\,\\mathrm{cm}$处测得的准直器模糊的半峰全宽（FWHM）为$R_{col}=8\\,\\mathrm{mm}$。在系统是线性移不变、内在模糊和准直器模糊是相互独立且均为高斯分布的假设下，从第一性原理推导在$z=10\\,\\mathrm{cm}$处预期的系统PSF宽度，并以半峰全宽表示。最终答案以毫米为单位表示，并四舍五入到四位有效数字。",
            "solution": "首先将对问题陈述的科学合理性、完整性和客观性进行验证。\n\n**步骤1：提取已知条件**\n- 成像系统：配备平行孔准直器的伽马相机。\n- 源到准直器距离：$z=10\\,\\mathrm{cm}$。\n- 内在点扩散函数（PSF）标准差：$\\sigma_{int}=1.5\\,\\mathrm{mm}$。\n- 在指定距离 $z$ 处的准直器模糊半峰全宽（FWHM）：$R_{col}=8\\,\\mathrm{mm}$。\n- 系统假设：\n    1. 系统是线性移不变（LSI）的。\n    2. 内在模糊和准直器模糊是独立过程。\n    3. 内在PSF和准直器PSF均为高斯形状。\n- 要求输出：系统PSF宽度，以FWHM表示，单位为毫米，四舍五入到四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估。\n- **科学依据：** 该问题牢固地植根于医学成像物理学的基本原理，特别是伽马相机的分辨率理论。内在分辨率、准直器分辨率、点扩散函数（PSF）、半峰全宽（FWHM）以及LSI系统模型等概念在该领域都是标准内容。高斯模糊分量的假设是一种常见且有效的近似。\n- **适定性：** 该问题是适定的。它提供了确定唯一解所需的所有必要信息。给定的条件（$\\sigma_{int}$, $R_{col}$）足以计算系统分辨率（$FWHM_{sys}$）。距离 $z=10\\,\\mathrm{cm}$ 正确地将给定的准直器模糊 $R_{col}$ 置于上下文中，因为准直器分辨率是与距离相关的。通过提供在这个特定距离下的 $R_{col}$，问题避免了从准直器几何结构计算它的需要，从而使其自成体系。\n- **客观性：** 问题以精确、客观的语言陈述。数据是定量的，假设是明确的。\n- **一致性与可行性：** 对于临床伽马相机而言，给定的值是物理上现实的。内在标准差为 $1.5\\,\\mathrm{mm}$ 和在 $10\\,\\mathrm{cm}$ 距离处的准直器FWHM为 $8\\,\\mathrm{mm}$ 是典型值。内部没有矛盾。\n\n**步骤3：结论与行动**\n该问题被认为是**有效的**，因为它是科学合理的、适定的，并且其所有组成部分都是一致且明确定义的。现在将推导解答。\n\n**解题推导**\n对于一个LSI系统，其基本原理是整个系统的响应是其独立分量响应的卷积。在这种情况下，系统点扩散函数 $PSF_{sys}$ 是内在PSF ($PSF_{int}$) 和准直器PSF ($PSF_{col}$) 的卷积。\n$$PSF_{sys} = PSF_{int} * PSF_{col}$$\n其中 $*$ 表示卷积算子。\n\n问题陈述中说明 $PSF_{int}$ 和 $PSF_{col}$ 都是高斯函数。高斯函数的一个关键特性是两个高斯函数的卷积结果仍然是另一个高斯函数。如果分量高斯函数的方差分别为 $\\sigma_1^2$ 和 $\\sigma_2^2$，那么卷积后得到的高斯函数的方差 $\\sigma_{sys}^2$ 将是各分量方差之和。\n$$\\sigma_{sys}^2 = \\sigma_{int}^2 + \\sigma_{col}^2$$\n这个关系是解题的基石。我们的目标是求出系统PSF的半峰全宽 $FWHM_{sys}$。为此，我们必须首先建立高斯分布的标准差 $\\sigma$ 和FWHM之间的关系。\n\n一个以原点为中心的一维高斯函数可以写成：\n$$G(x) = A \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)$$\n其中 $A$ 是最大振幅。FWHM是函数值为其最大值一半的两个点 $x$ 之间的距离，即 $G(x) = A/2$。\n$$\\frac{A}{2} = A \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)$$\n两边同除以 $A$ 并取自然对数：\n$$\\ln\\left(\\frac{1}{2}\\right) = -\\frac{x^2}{2\\sigma^2}$$\n$$-\\ln(2) = -\\frac{x^2}{2\\sigma^2}$$\n$$x^2 = 2\\sigma^2\\ln(2)$$\n$$x = \\pm \\sigma \\sqrt{2\\ln(2)}$$\n这两个点是 $x_1 = -\\sigma\\sqrt{2\\ln(2)}$ 和 $x_2 = +\\sigma\\sqrt{2\\ln(2)}$。FWHM是这两点之差：\n$$FWHM = x_2 - x_1 = 2\\sigma\\sqrt{2\\ln(2)} = \\sigma\\sqrt{8\\ln(2)}$$\n这给出了 $\\sigma$ 和FWHM之间的转换因子。将此关系平方得到：\n$$FWHM^2 = \\sigma^2(8\\ln(2))$$\n这意味着 $\\sigma^2 = \\frac{FWHM^2}{8\\ln(2)}$。\n\n我们可以将此应用于我们的方差相加公式：\n$$\\sigma_{sys}^2 = \\sigma_{int}^2 + \\sigma_{col}^2$$\n将基于FWHM的表达式代入每个方差项：\n$$\\frac{FWHM_{sys}^2}{8\\ln(2)} = \\frac{FWHM_{int}^2}{8\\ln(2)} + \\frac{FWHM_{col}^2}{8\\ln(2)}$$\n将整个方程乘以 $8\\ln(2)$，得到一个简化的用于组合高斯分量FWHM的关系：\n$$FWHM_{sys}^2 = FWHM_{int}^2 + FWHM_{col}^2$$\n这表明，独立高斯模糊分量的FWHM以平方和的形式相加，得到系统FWHM的平方。\n\n现在，我们使用给定的值来计算 $FWHM_{sys}$。\n我们已知：\n- 准直器FWHM，$FWHM_{col} = R_{col} = 8\\,\\mathrm{mm}$。\n- 内在标准差，$\\sigma_{int} = 1.5\\,\\mathrm{mm}$。\n\n首先，我们必须根据其标准差计算内在FWHM，$FWHM_{int}$：\n$$FWHM_{int} = \\sigma_{int}\\sqrt{8\\ln(2)} = 1.5\\sqrt{8\\ln(2)}\\,\\mathrm{mm}$$\n\n现在我们将已知的FWHM值代入平方和方程：\n$$FWHM_{sys}^2 = (1.5\\sqrt{8\\ln(2)})^2 + (8)^2$$\n$$FWHM_{sys}^2 = (1.5^2 \\cdot 8\\ln(2)) + 64$$\n$$FWHM_{sys}^2 = (2.25 \\cdot 8\\ln(2)) + 64$$\n$$FWHM_{sys}^2 = 18\\ln(2) + 64$$\n系统FWHM是该值的平方根：\n$$FWHM_{sys} = \\sqrt{18\\ln(2) + 64}$$\n为了获得数值结果，我们使用 $2$ 的自然对数值，$\\ln(2) \\approx 0.693147$。\n$$FWHM_{sys} \\approx \\sqrt{18(0.693147) + 64}$$\n$$FWHM_{sys} \\approx \\sqrt{12.476646 + 64}$$\n$$FWHM_{sys} \\approx \\sqrt{76.476646}$$\n$$FWHM_{sys} \\approx 8.745092\\,\\mathrm{mm}$$\n问题要求答案四舍五入到四位有效数字。\n$$FWHM_{sys} \\approx 8.745\\,\\mathrm{mm}$$",
            "answer": "$$\\boxed{8.745}$$"
        },
        {
            "introduction": "理论上，我们可以通过增加放射性药物的剂量来获得更高质量的图像，但实际上，探测器系统处理事件的速度是有限的。这个限制被称为“死时间”(dead time)，在高计数率下，它会导致事件丢失，从而严重影响定量分析的准确性。本练习挑战您通过编程来模拟这一关键效应，比较两种经典的死时间模型（非瘫痪型和可瘫痪型），并量化因使用错误的校正模型而引入的系统性偏差。这项实践对于确保临床定量测量的准确性至关重要，并揭示了系统表征在核医学中的核心作用。",
            "id": "4888059",
            "problem": "用于平面核医学成像的伽玛相机由准直器、闪烁晶体和光电倍增管 (PMT) 阵列组成。电子处理流程在每次记录事件后会施加一个全局恢复时间，称为死时间。系统表征中使用了两种经典的死时间模型：可瘫痪模型和不可瘫痪模型。在均匀活度分布下的平面定量中，探测器上真实光子的到达过程可以看作是跨像素的一组空间变化的独立泊松过程，这些过程聚合成一个驱动电子学系统的单一全局泊松过程。当全系统范围的死时间作用于此全局数据流时，其造成的损失会按比例影响所有来源像素，比例取决于各像素对全局通量的贡献。\n\n从速率为 $n$ 的泊松到达过程的基本定义以及死时间 $\\tau$ 作为系统无法记录额外事件的时间区间的意义出发，推导两种死时间模型的期望全局测量率，并反演这些关系以从测量率估计真实率。使用以下假设构建一个确定性模拟，并计算当平面定量使用基于错误模型的死时间校正时引入的定量偏差：\n- 场景是一个均匀活度场，但探测器单元的灵敏度在视场内呈确定性变化，产生每像素的真实率 $n_i$，由 $n_i = r_0 s_i$ 给出，其中 $r_0$ 是每像素的基线率，$s_i$ 是一个已知的在 $[s_{\\min}, s_{\\max}]$ 范围内的无量纲灵敏度因子。\n- 全局真实率是 $N_{\\text{true}} = \\sum_i n_i$，而期望的全局测量率 $M_{\\text{meas}}$ 完全由系统的死时间模型和参数 $\\tau_{\\text{true}}$ 决定，作用于速率为 $N_{\\text{true}}$ 的聚合过程。\n- 由于死时间是全局性的，期望的每像素测量率满足 $m_i = M_{\\text{meas}} \\frac{n_i}{N_{\\text{true}}}$。\n- 平面定量通过使用测量到的 $m_i$ 和假定的参数 $\\tau_{\\text{assumed}}$ 来反演假定的死时间模型，从而估计出校正后的每像素真实率 $\\hat{n}_i$，然后形成校正后的总率 $N_{\\text{corr}} = \\sum_i \\hat{n}_i$ 和在采集时间 $T$ 内的校正后计数 $C_{\\text{corr}} = N_{\\text{corr}} T$，而真实计数为 $C_{\\text{true}} = N_{\\text{true}} T$。\n- 将偏差定义为 $b = \\frac{C_{\\text{corr}} - C_{\\text{true}}}{C_{\\text{true}}}$，并以小数（无量纲）形式报告。\n\n所有率以每秒计数 (cps) 表示，所有时间以秒 ($\\mathrm{s}$) 表示，并将 $b$ 报告为小数。不使用角度。您的程序必须确定性地（无随机抽样）实现上述逻辑，按如下规定生成灵敏度图，并为每个测试用例计算 $b$。\n\n对于一个尺寸为 $P_x \\times P_y$ 像素、坐标为 $(x,y)$（其中 $x \\in \\{0,1,\\dots,P_x-1\\}$ 且 $y \\in \\{0,1,\\dots,P_y-1\\}$）的探测器，其灵敏度图构建规则如下：\n- 均匀模式：$s(x,y) = s_{\\min}$ （当 $s_{\\min} = s_{\\max}$ 时）。\n- 梯度模式：$s(x,y) = s_{\\min} + (s_{\\max} - s_{\\min}) \\frac{x}{P_x - 1}$。\n- 中心高模式：令 $x_c = \\frac{P_x - 1}{2}$，$y_c = \\frac{P_y - 1}{2}$，以及 $\\sigma = 0.35 \\max(P_x, P_y)$。定义 $r^2 = (x - x_c)^2 + (y - y_c)^2$ 和 $g(x,y) = \\exp\\left(-\\frac{r^2}{\\sigma^2}\\right)$。则 $s(x,y) = s_{\\min} + (s_{\\max} - s_{\\min}) g(x,y)$，并裁剪至 $[s_{\\min}, s_{\\max}]$ 范围内。\n\n测试套件。对于每个用例，使用指定的参数计算偏差 $b$。对真实系统使用指定的可瘫痪或不可瘫痪模型，对假定的校正则使用相反的模型。所有数值均按其指定单位处理。基线率 $r_0$ 是每像素的。采集时间为 $T$。\n- 用例 1（理想路径，中等速率）：$P_x = 10$，$P_y = 10$，梯度模式，$s_{\\min} = 0.9$，$s_{\\max} = 1.1$，$r_0 = 3000\\,\\mathrm{cps}$，$T = 10\\,\\mathrm{s}$，真实模型为可瘫痪模型，$\\tau_{\\text{true}} = 1.0 \\times 10^{-6}\\,\\mathrm{s}$，假定模型为不可瘫痪模型，$\\tau_{\\text{assumed}} = 1.0 \\times 10^{-6}\\,\\mathrm{s}$。\n- 用例 2（低速率边界）：$P_x = 10$，$P_y = 10$，均匀模式，$s_{\\min} = 1.0$，$s_{\\max} = 1.0$，$r_0 = 100\\,\\mathrm{cps}$，$T = 10\\,\\mathrm{s}$，真实模型为可瘫痪模型，$\\tau_{\\text{true}} = 2.0 \\times 10^{-6}\\,\\mathrm{s}$，假定模型为不可瘫痪模型，$\\tau_{\\text{assumed}} = 2.0 \\times 10^{-6}\\,\\mathrm{s}$。\n- 用例 3（高速率，接近可瘫痪模型吞吐量峰值但可逆）：$P_x = 20$，$P_y = 20$，中心高模式，$s_{\\min} = 0.7$，$s_{\\max} = 1.3$，$r_0 = 1200\\,\\mathrm{cps}$，$T = 30\\,\\mathrm{s}$，真实模型为可瘫痪模型，$\\tau_{\\text{true}} = 2.0 \\times 10^{-6}\\,\\mathrm{s}$，假定模型为不可瘫痪模型，$\\tau_{\\text{assumed}} = 2.0 \\times 10^{-6}\\,\\mathrm{s}$。\n- 用例 4（真实模型为不可瘫痪，假定模型为可瘫痪）：$P_x = 10$，$P_y = 10$，梯度模式，$s_{\\min} = 0.8$，$s_{\\max} = 1.2$，$r_0 = 10000\\,\\mathrm{cps}$，$T = 5\\,\\mathrm{s}$，真实模型为不可瘫痪模型，$\\tau_{\\text{true}} = 1.0 \\times 10^{-6}\\,\\mathrm{s}$，假定模型为可瘫痪模型，$\\tau_{\\text{assumed}} = 1.0 \\times 10^{-6}\\,\\mathrm{s}$。\n- 用例 5（$\\tau$ 值不匹配）：$P_x = 8$，$P_y = 8$，中心高模式，$s_{\\min} = 0.85$，$s_{\\max} = 1.25$，$r_0 = 8000\\,\\mathrm{cps}$，$T = 20\\,\\mathrm{s}$，真实模型为可瘫痪模型，$\\tau_{\\text{true}} = 1.5 \\times 10^{-6}\\,\\mathrm{s}$，假定模型为不可瘫痪模型，$\\tau_{\\text{assumed}} = 0.8 \\times 10^{-6}\\,\\mathrm{s}$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述用例的顺序排列结果，例如 $[b_1,b_2,b_3,b_4,b_5]$。每个 $b_k$ 必须是一个浮点数（小数），代表之前定义的无量纲偏差。",
            "solution": "该问题要求评估在平面核医学成像中应用不正确的死时间校正模型所导致的定量偏差。此分析将通过基于所提供的物理假设和参数构建确定性模拟来执行。第一步是验证问题陈述。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **系统组件与过程**：一个具有全局死时间 $\\tau$ 的伽玛相机系统。真实光子到达过程是一个速率为 $N_{\\text{true}}$ 的全局泊松过程。\n*   **死时间模型**：可瘫痪和不可瘫痪。\n*   **每像素真实率**：$n_i = r_0 s_i$，其中 $r_0$ 是基线率，$s_i$ 是灵敏度因子。\n*   **全局真实率**：$N_{\\text{true}} = \\sum_i n_i$。\n*   **测量得到的全局率**：$M_{\\text{meas}}$ 由 $N_{\\text{true}}$、$\\tau_{\\text{true}}$ 及真实死时间模型推导得出。\n*   **测量得到的每像素率**：$m_i = M_{\\text{meas}} \\frac{n_i}{N_{\\text{true}}}$。\n*   **校正后的每像素率**：$\\hat{n}_i$ 是通过对测量率 $m_i$ 应用假定的死时间模型的反演（使用参数 $\\tau_{\\text{assumed}}$）获得的。\n*   **校正后的总率**：$N_{\\text{corr}} = \\sum_i \\hat{n}_i$。\n*   **真实计数与校正后计数**：在采集时间 $T$ 内，$C_{\\text{true}} = N_{\\text{true}} T$，$C_{\\text{corr}} = N_{\\text{corr}} T$。\n*   **偏差定义**：$b = \\frac{C_{\\text{corr}} - C_{\\text{true}}}{C_{\\text{true}}}$。\n*   **灵敏度图公式**：为尺寸为 $P_x \\times P_y$ 的探测器提供了“梯度”和“中心高”模式的规则。\n    *   梯度：$s(x,y) = s_{\\min} + (s_{\\max} - s_{\\min}) \\frac{x}{P_x - 1}$。\n    *   中心高：$s(x,y) = s_{\\min} + (s_{\\max} - s_{\\min}) g(x,y)$，其中 $g(x,y) = \\exp\\left(-\\frac{(x-x_c)^2 + (y-y_c)^2}{\\sigma^2}\\right)$，并指定了 $x_c$、$y_c$ 和 $\\sigma$。\n*   **测试用例**：提供了五个用例，包含 $P_x, P_y, s_{\\min}, s_{\\max}$、模式、$r_0, T, \\tau_{\\text{true}}, \\tau_{\\text{assumed}}$ 以及真实/假定模型类型的具体参数。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n*   **科学依据充分**：该问题基于核医学物理学的基本原理，包括放射性衰变的泊松统计以及探测器死时间的标准可瘫痪和不可瘫痪模型。这些都是已确立的有效概念。\n*   **问题定义明确**：该问题为计算偏差提供了一个完整、分步的确定性程序。每个用例的输入都被完全指定。死时间模型方程，包括可瘫痪模型的非代数反演，都有明确定义。可瘫痪模型的反演需要朗伯W函数，它在物理相关的分支（$N\\tau \\le 1$）上提供唯一解，测试用例参数满足此条件。尽管从物理学角度来看可能不是最优的，但在每像素基础上进行校正的指令是问题定义中明确的一部分，并不会使其无效；相反，它定义了需要评估其偏差的特定量化方法。\n*   **客观性**：问题以精确、定量且无偏见的语言陈述。所有术语都有数学定义。\n*   **完整性与一致性**：提供了所有必要的参数和公式。单位一致（率用cps，时间用s）。已知条件中没有矛盾。\n*   **现实性与可行性**：速率和死时间的数值在现代伽玛相机的现实范围内。这些场景旨在探究不同的操作区间，这是系统分析中的标准做法。\n\n**步骤 3：结论与行动**\n\n该问题科学上合理、定义明确且完整。所有有效性条件均已满足。因此，我将继续提供完整的解决方案。\n\n### 基于原理的解法推导\n\n解决方案需要对成像和定量过程进行确定性模拟。这涉及应用正向死时间模型来计算测量率，然后应用一个可能不同的模型的反演来估计校正后的率。\n\n**1. 死时间模型**\n\n设 $N$ 为真实事件率（单位 cps），$\\tau$ 为死时间（单位 s）。期望的测量率为 $M$（单位 cps）。\n\n*   **不可瘫痪模型**：在此模型中，死时间段内到达的事件被直接忽略，不影响系统状态。系统每秒“死”掉的总时间为 $M\\tau$。系统“活”着的时间比例为 $1 - M\\tau$。测量率是真实率乘以这个活时间比例：\n    $$M = N(1 - M\\tau)$$\n    解出 $M$ 得到正向关系：\n    $$M = \\frac{N}{1 + N\\tau}$$\n    解出 $N$ 得到反向关系，用于校正：\n    $$N = \\frac{M}{1 - M\\tau}$$\n    此反演在 $M\\tau < 1$ 时有效。\n\n*   **可瘫痪模型**：在此模型中，任何在死时间段内到达的事件（无论是否被探测到）都会将死时间延长一个 $\\tau$ 的时间间隔。只有在前一个持续时间为 $\\tau$ 的间隔内没有其他真实事件发生时，事件才会被记录。对于速率为 $N$ 的泊松过程，在 $\\tau$ 间隔内发生零个事件的概率由泊松概率质量函数给出：$P(k=0, \\lambda=N\\tau) = e^{-N\\tau}$。因此，测量率是真实率乘以该概率：\n    $$M = N e^{-N\\tau}$$\n    反解该方程以从 $M$ 求出 $N$ 是非代数的。我们可以写成：\n    $$-M\\tau = (-N\\tau)e^{-N\\tau}$$\n    令 $z = -N\\tau$，我们有 $ze^z = -M\\tau$。$z$ 的解由朗伯W函数给出，$z = W(-M\\tau)$。物理上有意义的解，对应于 $N\\tau \\le 1$ 的低速率区，由函数的主分支 $W_0$ 给出。因此，反向关系是：\n    $$N = -\\frac{W_0(-M\\tau)}{\\tau}$$\n    此反演在 $N\\tau \\le 1$ 时是唯一的，这对应于 $M\\tau \\le 1/e$。\n\n**2. 模拟算法**\n\n对于每个测试用例，我们遵循以下步骤：\n\n1.  **构建灵敏度图**：根据指定的模式（‘gradient’ 或 ‘center-high’）和参数 $s_{\\min}, s_{\\max}$，生成 $P_y \\times P_x$ 的灵敏度图，记为矩阵 $\\mathbf{s}$。对于均匀模式，$\\mathbf{s}$ 的所有元素均等于 $s_{\\min}$。坐标为 $(x, y)$，其中 $x \\in \\{0, 1, \\dots, P_x-1\\}$ 且 $y \\in \\{0, 1, \\dots, P_y-1\\}$。\n\n2.  **计算真实率**：使用基线率 $r_0$ 计算每像素真实率矩阵 $\\mathbf{n}$：\n    $$\\mathbf{n} = r_0 \\mathbf{s}$$\n    全局真实率 $N_{\\text{true}}$ 是 $\\mathbf{n}$ 中所有元素的总和：\n    $$N_{\\text{true}} = \\sum_{i,j} n_{ij}$$\n\n3.  **模拟测量**：将带有参数 $\\tau_{\\text{true}}$ 的真实死时间模型（可瘫痪或不可瘫痪）应用于全局真实率 $N_{\\text{true}}$，以求得期望的全局测量率 $M_{\\text{meas}}$。\n    *   若真实模型为不可瘫痪：$M_{\\text{meas}} = \\frac{N_{\\text{true}}}{1 + N_{\\text{true}} \\tau_{\\text{true}}}$。\n    *   若真实模型为可瘫痪：$M_{\\text{meas}} = N_{\\text{true}} e^{-N_{\\text{true}} \\tau_{\\text{true}}}$。\n\n4.  **确定每像素测量率**：由于死时间损失是全局效应，它会按比例降低所有像素的计数率。每像素测量率矩阵 $\\mathbf{m}$ 为：\n    $$\\mathbf{m} = M_{\\text{meas}} \\frac{\\mathbf{n}}{N_{\\text{true}}}$$\n\n5.  **执行死时间校正**：将带有参数 $\\tau_{\\text{assumed}}$ 的假定死时间模型的反演应用于测量率矩阵 $\\mathbf{m}$ 的每个元素，以获得校正后的每像素率矩阵 $\\hat{\\mathbf{n}}$。\n    *   若假定模型为不可瘫痪：$\\hat{n}_{ij} = \\frac{m_{ij}}{1 - m_{ij} \\tau_{\\text{assumed}}}$。\n    *   若假定模型为可瘫痪：$\\hat{n}_{ij} = -\\frac{W_0(-m_{ij} \\tau_{\\text{assumed}})}{\\tau_{\\text{assumed}}}$。\n\n6.  **计算校正后的总率**：将校正后率矩阵 $\\hat{\\mathbf{n}}$ 的所有元素求和，以得到校正后的总率 $N_{\\text{corr}}$：\n    $$N_{\\text{corr}} = \\sum_{i,j} \\hat{n}_{ij}$$\n\n7.  **计算偏差**：定量偏差 $b$ 是校正后总计数与真实总计数之间的分数差。由于计数与率成正比（$C=NT$），偏差可以直接从率计算得出：\n    $$b = \\frac{C_{\\text{corr}} - C_{\\text{true}}}{C_{\\text{true}}} = \\frac{N_{\\text{corr}} - N_{\\text{true}}}{N_{\\text{true}}}$$\n\n对五个测试用例中的每一个实施此程序，以找到相应的偏差值 $b_1, \\dots, b_5$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import lambertw\n\ndef generate_sensitivity_map(Px, Py, s_min, s_max, pattern):\n    \"\"\"\n    Generates a sensitivity map based on specified parameters.\n    \"\"\"\n    x = np.arange(Px)\n    y = np.arange(Py)\n    xv, yv = np.meshgrid(x, y, indexing='xy')\n\n    if pattern == 'uniform' or s_min == s_max:\n        return np.full((Py, Px), s_min)\n    \n    if pattern == 'gradient':\n        # Px-1 can be 0 if Px=1, handle this edge case.\n        if Px > 1:\n            s_map = s_min + (s_max - s_min) * (xv / (Px - 1))\n        else:\n            s_map = np.full((Py, Px), s_min)\n        return s_map\n    \n    if pattern == 'center-high':\n        xc = (Px - 1) / 2.0\n        yc = (Py - 1) / 2.0\n        sigma = 0.35 * max(Px, Py)\n        \n        # Avoid division by zero if sigma is zero (max(Px, Py) is 0)\n        if sigma == 0:\n            sigma = 1.0\n\n        r_sq = (xv - xc)**2 + (yv - yc)**2\n        g = np.exp(-r_sq / (sigma**2))\n        s_map = s_min + (s_max - s_min) * g\n        # Clipping is technically redundant based on the formula but specified.\n        np.clip(s_map, s_min, s_max, out=s_map)\n        return s_map\n        \n    raise ValueError(\"Unknown sensitivity map pattern specified.\")\n\ndef apply_forward_model(N_true, tau, model):\n    \"\"\"\n    Calculates measured rate M from true rate N using a dead time model.\n    \"\"\"\n    if model == 'nonparalyzable':\n        return N_true / (1.0 + N_true * tau)\n    elif model == 'paralyzable':\n        return N_true * np.exp(-N_true * tau)\n    else:\n        raise ValueError(f\"Unknown forward model: {model}\")\n\ndef apply_inverse_model(m_map, tau, model):\n    \"\"\"\n    Calculates corrected rate N_hat from measured rate m using a dead time model.\n    \"\"\"\n    if model == 'nonparalyzable':\n        # Avoid division by zero or negative denominator\n        denominator = 1.0 - m_map * tau\n        # Problem setup ensures m*tau  1, so no bad values expected\n        return m_map / denominator\n    elif model == 'paralyzable':\n        arg = -m_map * tau\n        # Problem setup ensures we are on the principal branch where Lambert W is real.\n        # lambertw can return complex numbers, so we take the real part.\n        return -np.real(lambertw(arg)) / tau\n    else:\n        raise ValueError(f\"Unknown inverse model: {model}\")\n\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'Px': 10, 'Py': 10, 'pattern': 'gradient', 's_min': 0.9, 's_max': 1.1, 'r0': 3000, 'T': 10, 'true_model': 'paralyzable', 'tau_true': 1.0e-6, 'assumed_model': 'nonparalyzable', 'tau_assumed': 1.0e-6},\n        # Case 2\n        {'Px': 10, 'Py': 10, 'pattern': 'uniform', 's_min': 1.0, 's_max': 1.0, 'r0': 100, 'T': 10, 'true_model': 'paralyzable', 'tau_true': 2.0e-6, 'assumed_model': 'nonparalyzable', 'tau_assumed': 2.0e-6},\n        # Case 3\n        {'Px': 20, 'Py': 20, 'pattern': 'center-high', 's_min': 0.7, 's_max': 1.3, 'r0': 1200, 'T': 30, 'true_model': 'paralyzable', 'tau_true': 2.0e-6, 'assumed_model': 'nonparalyzable', 'tau_assumed': 2.0e-6},\n        # Case 4\n        {'Px': 10, 'Py': 10, 'pattern': 'gradient', 's_min': 0.8, 's_max': 1.2, 'r0': 10000, 'T': 5, 'true_model': 'nonparalyzable', 'tau_true': 1.0e-6, 'assumed_model': 'paralyzable', 'tau_assumed': 1.0e-6},\n        # Case 5\n        {'Px': 8, 'Py': 8, 'pattern': 'center-high', 's_min': 0.85, 's_max': 1.25, 'r0': 8000, 'T': 20, 'true_model': 'paralyzable', 'tau_true': 1.5e-6, 'assumed_model': 'nonparalyzable', 'tau_assumed': 0.8e-6},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Construct Sensitivity Map\n        s_map = generate_sensitivity_map(case['Px'], case['Py'], case['s_min'], case['s_max'], case['pattern'])\n        \n        # Step 2: Calculate True Rates\n        n_map = case['r0'] * s_map\n        N_true = np.sum(n_map)\n\n        # Step 3: Simulate Measurement (Forward Model)\n        M_meas = apply_forward_model(N_true, case['tau_true'], case['true_model'])\n        \n        # Step 4: Determine Measured Per-Pixel Rates\n        # Avoid division by zero if N_true is 0\n        if N_true > 0:\n            m_map = M_meas * (n_map / N_true)\n        else:\n            m_map = np.zeros_like(n_map)\n            \n        # Step 5: Perform Dead Time Correction (Inverse Model)\n        n_hat_map = apply_inverse_model(m_map, case['tau_assumed'], case['assumed_model'])\n        \n        # Step 6: Calculate Corrected Total Rate\n        N_corr = np.sum(n_hat_map)\n        \n        # Step 7: Compute Bias\n        # Avoid division by zero if N_true is 0\n        if N_true > 0:\n            bias = (N_corr - N_true) / N_true\n        else:\n            bias = 0.0 # No events, no bias\n            \n        results.append(bias)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}