{
    "hands_on_practices": [
        {
            "introduction": "Reducing an image's bit depth is a common strategy for data compression, but it is not without consequences. This practice challenges you to quantify the cost of this compression by deriving the change in Signal-to-Noise Ratio ($SNR$) and analyzing its downstream effects on statistical image features. By completing this exercise , you will gain a first-principles understanding of how quantization noise is introduced and how it systematically biases important radiomic measurements.",
            "id": "4536956",
            "problem": "A three-dimensional medical image volume is represented by voxel intensities forming a wide-sense stationary signal with zero mean and variance $\\sigma_{s}^{2}$. The image is initially stored using a $16$-bit uniform quantizer over a fixed dynamic range of width $R$ (i.e., the minimum and maximum representable intensities are unchanged when bit depth changes). The image is subsequently requantized to a $12$-bit uniform quantizer over the same dynamic range. Assume the high-resolution quantization-noise model holds, with quantization error that is independent of the signal, uniformly distributed within one quantization step, and with zero mean.\n\nStarting from fundamental definitions of bit depth, quantization step size, and the Signal-to-Noise Ratio (SNR), derive the change in SNR introduced by the $16$-bit to $12$-bit requantization. Express the SNR change as a single scalar value in decibels (dB), rounded to three significant figures.\n\nThen, using first principles, reason about the impact of this bit-depth reduction on first-order radiomics statistics computed from the voxel intensity histogram over $N$ voxels, including the sample mean, sample variance, energy (sum of squared intensities), Shannon entropy of the discrete histogram, skewness, and kurtosis. Focus your reasoning on bias and variability under the stated quantization-noise assumptions.\n\nProvide only the SNR change as your final numeric answer, rounded to three significant figures and expressed in decibels (dB).",
            "solution": "The problem statement is evaluated as scientifically grounded, well-posed, objective, and internally consistent. It is based on standard principles of digital signal processing and medical image analysis. The provided information is sufficient to derive the required quantities and support a reasoned analysis. The problem is therefore deemed valid.\n\nThe solution is presented in two parts as requested: first, the derivation of the change in Signal-to-Noise Ratio (SNR), and second, the reasoning about the impact on first-order radiomics statistics.\n\n**Part 1: Derivation of SNR Change**\n\nThe Signal-to-Noise Ratio (SNR) is defined as the ratio of the signal power to the noise power. In decibels (dB), this is given by:\n$$\nSNR_{dB} = 10 \\log_{10}\\left(\\frac{P_{signal}}{P_{noise}}\\right)\n$$\nThe problem states that the signal, representing voxel intensities, is a wide-sense stationary process with zero mean and variance $\\sigma_{s}^{2}$. For a zero-mean signal, the signal power $P_{signal}$ is equal to its variance.\n$$\nP_{signal} = E[s^2] = \\text{Var}(s) + (E[s])^2 = \\sigma_{s}^{2} + 0^2 = \\sigma_{s}^{2}\n$$\nThis signal power is independent of the quantization process.\n\nThe noise is introduced by the uniform quantization process. For a uniform quantizer with a bit depth of $B$ bits over a dynamic range of width $R$, the number of quantization levels is $L = 2^B$. The quantization step size, $\\Delta$, is the distance between adjacent quantization levels:\n$$\n\\Delta = \\frac{R}{L} = \\frac{R}{2^B}\n$$\nThe problem specifies a high-resolution quantization model, where the quantization error $q_e$ is a random variable uniformly distributed over the interval $[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}]$. The probability density function (PDF) of the error is:\n$$\nf(q_e) = \\begin{cases} \\frac{1}{\\Delta} & \\text{if } -\\frac{\\Delta}{2} \\le q_e \\le \\frac{\\Delta}{2} \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\nThe noise is assumed to have zero mean, which is consistent with this symmetric distribution. The noise power, $P_{noise}$, is the variance of the quantization error, $\\sigma_q^2$, which for a zero-mean error is equal to the mean squared error.\n$$\nP_{noise} = \\sigma_q^2 = E[q_e^2] = \\int_{-\\infty}^{\\infty} q_e^2 f(q_e) dq_e = \\int_{-\\Delta/2}^{\\Delta/2} q_e^2 \\frac{1}{\\Delta} dq_e\n$$\n$$\nP_{noise} = \\frac{1}{\\Delta} \\left[ \\frac{q_e^3}{3} \\right]_{-\\Delta/2}^{\\Delta/2} = \\frac{1}{3\\Delta} \\left( \\left(\\frac{\\Delta}{2}\\right)^3 - \\left(-\\frac{\\Delta}{2}\\right)^3 \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{8} + \\frac{\\Delta^3}{8} \\right) = \\frac{\\Delta^2}{12}\n$$\nNow, we can express the SNR as a function of the bit depth $B$:\n$$\nSNR(B) = \\frac{P_{signal}}{P_{noise}} = \\frac{\\sigma_{s}^{2}}{\\Delta^2/12} = \\frac{12\\sigma_{s}^{2}}{(R/2^B)^2} = \\frac{12\\sigma_{s}^{2} (2^B)^2}{R^2} = \\frac{12\\sigma_{s}^{2}}{R^2} 2^{2B}\n$$\nWe are asked for the change in SNR in dB when moving from an initial bit depth $B_1 = 16$ to a final bit depth $B_2 = 12$. The change, $\\Delta SNR_{dB}$, is:\n$$\n\\Delta SNR_{dB} = SNR_{dB}(B_2) - SNR_{dB}(B_1) = 10 \\log_{10}(SNR(B_2)) - 10 \\log_{10}(SNR(B_1))\n$$\n$$\n\\Delta SNR_{dB} = 10 \\log_{10}\\left(\\frac{SNR(B_2)}{SNR(B_1)}\\right)\n$$\nThe ratio of the SNRs is:\n$$\n\\frac{SNR(B_2)}{SNR(B_1)} = \\frac{\\frac{12\\sigma_{s}^{2}}{R^2} 2^{2B_2}}{\\frac{12\\sigma_{s}^{2}}{R^2} 2^{2B_1}} = \\frac{2^{2B_2}}{2^{2B_1}} = 2^{2(B_2 - B_1)}\n$$\nSubstituting $B_1 = 16$ and $B_2 = 12$:\n$$\n\\frac{SNR(12)}{SNR(16)} = 2^{2(12 - 16)} = 2^{2(-4)} = 2^{-8}\n$$\nThe change in SNR in dB is therefore:\n$$\n\\Delta SNR_{dB} = 10 \\log_{10}(2^{-8}) = -80 \\log_{10}(2)\n$$\nUsing the value $\\log_{10}(2) \\approx 0.30103$:\n$$\n\\Delta SNR_{dB} \\approx -80 \\times 0.30103 = -24.0824\n$$\nRounding to three significant figures, the change in SNR is $-24.1$ dB.\n\n**Part 2: Impact on First-Order Radiomics Statistics**\n\nLet the true, continuous voxel intensity be $X$ and the quantized intensity be $Y$. From the problem statement, we can model the quantized signal as $Y = X + \\epsilon$, where $\\epsilon$ is the quantization error. The error $\\epsilon$ is assumed to be independent of $X$ with $E[\\epsilon]=0$ and $\\text{Var}(\\epsilon) = \\sigma_q^2 = \\Delta^2/12$. The requantization from $B_1=16$ bits to $B_2=12$ bits implies a significant increase in the quantization step size ($\\Delta_2 = 2^{16-12}\\Delta_1 = 16\\Delta_1$) and thus a large increase in noise power ($\\sigma_{q2}^2 = (16)^2 \\sigma_{q1}^2 = 256\\sigma_{q1}^2$). We analyze the impact on first-order statistics computed from a sample of $N$ voxels.\n\n1.  **Sample Mean ($\\bar{Y}$)**: The sample mean of the quantized signal is $\\bar{Y} = \\frac{1}{N}\\sum(X_i + \\epsilon_i) = \\bar{X} + \\bar{\\epsilon}$.\n    *   **Bias**: The expected value is $E[\\bar{Y}] = E[\\bar{X}] + E[\\bar{\\epsilon}] = \\mu_X$. Since $E[\\epsilon_i]=0$ for all $i$, the sample mean remains an unbiased estimator of the true signal mean. Bit-depth reduction does not introduce a bias in the sample mean.\n    *   **Variability**: The variance of the sample mean is $\\text{Var}(\\bar{Y}) = \\text{Var}(\\bar{X}) + \\text{Var}(\\bar{\\epsilon}) = \\frac{\\sigma_s^2}{N} + \\frac{\\sigma_q^2}{N}$. Since $\\sigma_{q2}^2 > \\sigma_{q1}^2$, the variance of the sample mean is higher for the $12$-bit image. The estimate is less stable.\n\n2.  **Sample Variance ($s_Y^2$)**: The variance of the quantized signal is $\\sigma_Y^2 = \\text{Var}(X+\\epsilon) = \\text{Var}(X) + \\text{Var}(\\epsilon) = \\sigma_s^2 + \\sigma_q^2$, due to independence.\n    *   **Bias**: The sample variance $s_Y^2$ is an unbiased estimator of $\\sigma_Y^2$, not $\\sigma_s^2$. Its expectation is $E[s_Y^2] = \\sigma_s^2 + \\sigma_q^2$. It is therefore a biased estimator of the true signal variance, with a positive bias of $\\sigma_q^2$. This bias is substantially larger for the $12$-bit image ($\\sigma_{q2}^2$) than for the $16$-bit image ($\\sigma_{q1}^2$).\n    *   **Variability**: The variability of the $s_Y^2$ estimator depends on the higher-order moments of $Y$. As the variance of $Y$ increases with lower bit depth, the variability of its sample variance estimate is also expected to increase.\n\n3.  **Energy ($\\sum Y^2$)**: The energy is the sum of squared voxel intensities.\n    *   **Bias**: The expected energy is $E[\\sum Y_i^2] = \\sum E[(X_i+\\epsilon_i)^2] = \\sum(E[X_i^2] + 2E[X_i]E[\\epsilon_i] + E[\\epsilon_i^2])$. With $E[X_i]=0$ and $E[\\epsilon_i]=0$, this simplifies to $\\sum(\\sigma_s^2 + \\sigma_q^2) = N(\\sigma_s^2 + \\sigma_q^2)$. The energy is biased upward by $N\\sigma_q^2$. This positive bias is significantly larger for the $12$-bit image.\n\n4.  **Shannon Entropy ($H$)**: Entropy is computed from the discrete voxel intensity histogram, $H = -\\sum p_k \\log p_k$.\n    *   **Bias**: Reducing the bit depth from $16$ to $12$ reduces the number of possible intensity levels from $2^{16}$ to $2^{12}$. This coarsens the intensity histogram, mapping multiple finer bins into single coarser bins. This process is a form of data processing which, by the data processing inequality, reduces information. The number of non-empty bins decreases, and their probabilities $p_k$ tend to increase. This almost invariably leads to a lower computed entropy value. The entropy estimate is biased downwards, and this bias is substantially more pronounced for the lower-bit-depth $12$-bit representation.\n    *   **Variability**: While more biased, an entropy estimate from a coarser histogram (fewer bins, more counts per bin) is often more robust to sampling noise, meaning it can have lower variability. This represents a classic bias-variance trade-off.\n\n5.  **Skewness**: Skewness measures the asymmetry of the distribution. The skewness of $Y$ is $\\gamma_1(Y) = E[((Y-\\mu_Y)/\\sigma_Y)^3]$.\n    *   **Bias**: Because the quantization error $\\epsilon$ has a symmetric distribution ($E[\\epsilon^3]=0$) and is independent of the signal $X$, the third central moment is preserved: $E[(Y-\\mu_Y)^3] = E[(X-\\mu_X)^3]$. However, the variance is increased: $\\sigma_Y^2 = \\sigma_s^2 + \\sigma_q^2$. Thus, the skewness of the quantized signal is $\\gamma_1(Y) = \\gamma_1(X) (\\frac{\\sigma_s^2}{\\sigma_s^2+\\sigma_q^2})^{3/2}$. The measured skewness is biased towards zero, meaning the distribution appears more symmetric. Since $\\sigma_q^2$ is much larger for the $12$-bit case, this attenuation of skewness is far more severe.\n\n6.  **Kurtosis**: Kurtosis measures the \"tailedness\" of the distribution.\n    *   **Bias**: The uniform distribution of the quantization error $\\epsilon$ is platykurtic (its excess kurtosis is $-1.2$). Convolving the signal's distribution with this error distribution pulls the resulting kurtosis towards that of the uniform noise. The fourth central moment of $Y$ is $E[(Y-\\mu_Y)^4] = E[(X-\\mu_X)^4] + 6\\sigma_s^2\\sigma_q^2 + E[\\epsilon^4]$. The kurtosis of $Y$ becomes a complex mixture of the signal and noise kurtosis. The effect is a bias in the measured kurtosis, and this bias is much stronger for the $12$-bit image due to its substantially larger $\\sigma_q^2$. The kurtosis of the $12$-bit image will be more heavily influenced by the platykurtic nature of the quantization noise.",
            "answer": "$$\n\\boxed{-24.1}\n$$"
        },
        {
            "introduction": "The raw numbers stored in a digital image file are meaningless without a scale that connects them to physical reality. This exercise  delves into the DICOM standard's method for this calibration, asking you to re-quantize a CT image to a lower bit depth while ensuring the new digital values still correctly map to Hounsfield Units (HU) within a clinically important window. This is a core skill for preparing medical images for analysis or processing on specialized hardware.",
            "id": "4878156",
            "problem": "A computed tomography system stores raw pixel intensities as integer codes with $12$-bit quantization, so that the digital code $I_{12}$ takes values in $\\{0,1,\\dots,4095\\}$. The Digital Imaging and Communications in Medicine (DICOM) standard defines a linear physical calibration mapping from stored code to Hounsfield Units (HU) via $HU = s\\,I_{12} + b$, where the rescale slope $s$ and rescale intercept $b$ are fixed per series. In this scenario, assume $s = 1.00$ $\\mathrm{HU}$ per level and $b = -1024$ $\\mathrm{HU}$.\n\nFor a downstream Graphics Processing Unit (GPU)-based oncology segmentation pipeline, you plan to re-quantize the image to $10$-bit integer codes $I_{10} \\in \\{0,1,\\dots,1023\\}$ for efficient texture storage, while preserving the physical interpretability of pixel values in Hounsfield Units. You will do this by defining a new linear calibration $HU = s'\\,I_{10} + b'$ that maps a clinically relevant HU window $[L,U] = [-1000,3000]$ exactly onto the available $10$-bit code range, with $I_{10} = 0$ corresponding to $HU = L$ and $I_{10} = 1023$ corresponding to $HU = U$.\n\nStarting from fundamental definitions of uniform quantization and linear calibration, determine the new rescale slope $s'$ (the HU-per-level step size) that preserves units under this $10$-bit re-quantization of the $[-1000,3000]$ HU window. Round your answer to four significant figures. Express the final value in Hounsfield Units per level (HU per level).",
            "solution": "The user has submitted a problem for validation and solution.\n\n**Problem Validation**\n\n**Step 1: Extract Givens**\n-   Original quantization bit depth: $12$-bit\n-   Original integer codes: $I_{12} \\in \\{0, 1, \\dots, 4095\\}$\n-   Original calibration equation: $HU = s \\cdot I_{12} + b$\n-   Original rescale slope: $s = 1.00$ HU per level\n-   Original rescale intercept: $b = -1024$ HU\n-   New quantization bit depth: $10$-bit\n-   New integer codes: $I_{10} \\in \\{0, 1, \\dots, 1023\\}$\n-   New calibration equation: $HU = s' \\cdot I_{10} + b'$\n-   Clinically relevant HU window lower bound: $L = -1000$ HU\n-   Clinically relevant HU window upper bound: $U = 3000$ HU\n-   Mapping condition 1: $I_{10} = 0$ corresponds to $HU = L = -1000$ HU\n-   Mapping condition 2: $I_{10} = 1023$ corresponds to $HU = U = 3000$ HU\n-   Objective: Determine the new rescale slope, $s'$.\n-   Required precision: Round to four significant figures.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed against the required criteria:\n-   **Scientifically Grounded**: The problem is based on the established DICOM standard for medical imaging. The concepts of Hounsfield Units (HU), bit depth, quantization, rescale slope, and rescale intercept are fundamental and accurately represented concepts in computed tomography (CT). The numerical values provided for the original calibration ($s=1$, $b=-1024$) are standard, and the HU window of interest ($[-1000, 3000]$) is clinically realistic for encompassing tissues from air to dense bone. The practice of re-quantizing data for specific processing pipelines (like GPU-based segmentation) is a common task in medical image analysis. The problem is scientifically sound.\n-   **Well-Posed**: The problem asks for the slope ($s'$) of a new linear transformation. It provides two distinct points on the line: $(I_{10}, HU) = (0, -1000)$ and $(1023, 3000)$. Two points uniquely define a straight line, so its parameters ($s'$ and $b'$) can be uniquely determined. The problem is well-posed and has a unique, meaningful solution.\n-   **Objective**: The problem is stated in precise, quantitative, and technical language. It is free of ambiguity, subjectivity, or opinion-based claims.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is scientifically grounded, well-posed, and objective. There are no identifiable flaws. The solution process will now proceed.\n\n**Problem Solution**\n\nThe re-quantization process involves defining a new linear relationship between the $10$-bit integer codes, $I_{10}$, and the physical values in Hounsfield Units, $HU$. This relationship is given by the equation:\n$$HU = s' \\cdot I_{10} + b'$$\nwhere $s'$ is the new rescale slope and $b'$ is the new rescale intercept.\n\nThe problem specifies that the range of clinically relevant HU values, $[L, U]$, must map exactly to the full range of the new $10$-bit integer codes, $\\{0, 1, \\dots, 1023\\}$. This provides two specific points on the line defined by the calibration equation:\n1.  The minimum integer code, $I_{10,min} = 0$, maps to the lower bound of the HU window, $L = -1000$ HU.\n2.  The maximum integer code, $I_{10,max} = 1023$, maps to the upper bound of the HU window, $U = 3000$ HU.\n\nWe can express these two conditions as a system of two linear equations:\n1.  For the point $(I_{10}, HU) = (0, -1000)$:\n    $$-1000 = s' \\cdot 0 + b'$$\n2.  For the point $(I_{10}, HU) = (1023, 3000)$:\n    $$3000 = s' \\cdot 1023 + b'$$\n\nFrom the first equation, we can immediately determine the new rescale intercept, $b' = -1000$ HU.\n\nThe rescale slope, $s'$, represents the change in HU for each single-unit increment of the integer code $I_{10}$. It is, by definition, the slope of the line. The slope of a line passing through two points $(x_1, y_1)$ and $(x_2, y_2)$ is given by the formula $m = \\frac{y_2 - y_1}{x_2 - x_1}$. In our context, $y$ corresponds to $HU$ and $x$ corresponds to $I_{10}$.\n\nUsing the two specified mapping points, $(I_{10,min}, L)$ and $(I_{10,max}, U)$, we can calculate $s'$:\n$$s' = \\frac{\\Delta HU}{\\Delta I_{10}} = \\frac{U - L}{I_{10,max} - I_{10,min}}$$\n\nSubstituting the given values:\n$$L = -1000 \\, \\mathrm{HU}$$\n$$U = 3000 \\, \\mathrm{HU}$$\n$$I_{10,min} = 0$$\n$$I_{10,max} = 1023$$\n\nThe calculation for $s'$ is as follows:\n$$s' = \\frac{3000 - (-1000)}{1023 - 0} = \\frac{3000 + 1000}{1023} = \\frac{4000}{1023}$$\n\nThe problem requires a final numerical answer rounded to four significant figures. We perform the division:\n$$s' = \\frac{4000}{1023} \\approx 3.910068426...$$\n\nTo round this value to four significant figures, we examine the first four non-zero digits, which are $3$, $9$, $1$, and $0$. The fifth significant digit is $0$. Therefore, we do not round up the fourth significant digit. The resulting value is $3.910$.\n\nThe units of the slope are the units of the vertical axis (HU) divided by the units of the horizontal axis (levels or integer code increments), so the units are HU per level.\n\nThus, the new rescale slope is $s' \\approx 3.910$ HU per level.",
            "answer": "$$\n\\boxed{3.910}\n$$"
        },
        {
            "introduction": "How much can we compress an image before it loses its diagnostic value? This hands-on coding challenge  explores this critical question by modeling quantization as the removal of an image's least significant bitplanes. You will implement a program to quantify how this progressive loss of information impacts the Contrast-to-Noise Ratio ($CNR$), a key metric of lesion detectability, and determine the minimum bit depth required to maintain diagnostic integrity.",
            "id": "4878152",
            "problem": "You are given a precise formulation task grounded in the fundamentals of digital image representation and quantization as used in the foundations of medical imaging. Consider a grayscale image with $8$-bit uniform scalar quantization, so that each pixel intensity $I(x,y)$ is an integer in $\\{0,\\dots,255\\}$. A bitplane decomposition expresses $I(x,y)$ as a sum of weighted bits $b_j(x,y) \\in \\{0,1\\}$ for $j \\in \\{0,\\dots,7\\}$ with weights $2^j$. Retaining only the $k$ most significant bitplanes (that is, preserving bitplanes $j \\in \\{8-k,\\dots,7\\}$ and setting the remaining lower bitplanes to zero) yields a reconstructed image $\\tilde{I}_k$ that is equivalent to a uniform quantizer with step size $\\Delta_k = 2^{8-k}$ applied by truncation:\n$$\n\\tilde{I}_k(x,y) = \\left\\lfloor \\frac{I(x,y)}{2^{8-k}} \\right\\rfloor \\cdot 2^{8-k}.\n$$\nFor a specified pair of disjoint regions of interest (ROIs)â€”a background region $\\mathcal{R}_\\mathrm{B}$ and a lesion region $\\mathcal{R}_\\mathrm{L}$â€”define, for any image $J$, the background mean $\\mu_\\mathrm{B}(J)$ and lesion mean $\\mu_\\mathrm{L}(J)$ as the arithmetic means of $J$ over $\\mathcal{R}_\\mathrm{B}$ and $\\mathcal{R}_\\mathrm{L}$, respectively. Define the unbiased sample standard deviations $s_\\mathrm{B}(J)$ and $s_\\mathrm{L}(J)$ using denominator $n-1$ within each region. To reflect that practical detection is limited by both intrinsic texture and instrument baseline noise, define the diagnostic contrast-to-noise ratio (CNR) as\n$$\n\\mathrm{CNR}(J) = \\frac{\\left|\\mu_\\mathrm{L}(J) - \\mu_\\mathrm{B}(J)\\right|}{\\sqrt{s_\\mathrm{L}(J)^2 + s_\\mathrm{B}(J)^2 + 2\\delta^2}},\n$$\nwhere $\\delta$ is a fixed baseline noise in gray levels. In this problem, take $\\delta = 0.5$.\n\nFor a given original image $I$ and threshold $f \\in (0,1]$, define $k^\\star$ as the smallest integer $k \\in \\{1,\\dots,8\\}$ such that\n$$\n\\frac{\\mathrm{CNR}(\\tilde{I}_k)}{\\mathrm{CNR}(I)} \\ge f.\n$$\nYour task is to write a program that, for each of the following test cases, computes $k^\\star$.\n\nUse the following three test cases. In each test case, the image $I$ is of size $4 \\times 4$, the background mask $M_\\mathrm{B}$ selects the top two rows (entries equal to $1$ indicate membership) and the lesion mask $M_\\mathrm{L}$ selects the bottom two rows. The images and masks are as follows.\n\n- Test Case $1$:\n  - Image $I^{(1)}$:\n    $\n    \\begin{bmatrix}\n    129 & 131 & 133 & 135 \\\\\n    130 & 132 & 134 & 136 \\\\\n    149 & 151 & 153 & 155 \\\\\n    150 & 152 & 154 & 152\n    \\end{bmatrix}\n    $\n  - Background mask $M_\\mathrm{B}^{(1)}$:\n    $\n    \\begin{bmatrix}\n    1 & 1 & 1 & 1 \\\\\n    1 & 1 & 1 & 1 \\\\\n    0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0\n    \\end{bmatrix}\n    $\n  - Lesion mask $M_\\mathrm{L}^{(1)}$:\n    $\n    \\begin{bmatrix}\n    0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 \\\\\n    1 & 1 & 1 & 1 \\\\\n    1 & 1 & 1 & 1\n    \\end{bmatrix}\n    $\n  - Threshold $f^{(1)} = 0.70$.\n\n- Test Case $2$:\n  - Image $I^{(2)}$:\n    $\n    \\begin{bmatrix}\n    170 & 171 & 173 & 174 \\\\\n    172 & 173 & 175 & 171 \\\\\n    190 & 191 & 193 & 194 \\\\\n    192 & 193 & 195 & 191\n    \\end{bmatrix}\n    $\n  - Background mask $M_\\mathrm{B}^{(2)}$:\n    $\n    \\begin{bmatrix}\n    1 & 1 & 1 & 1 \\\\\n    1 & 1 & 1 & 1 \\\\\n    0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0\n    \\end{bmatrix}\n    $\n  - Lesion mask $M_\\mathrm{L}^{(2)}$:\n    $\n    \\begin{bmatrix}\n    0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 \\\\\n    1 & 1 & 1 & 1 \\\\\n    1 & 1 & 1 & 1\n    \\end{bmatrix}\n    $\n  - Threshold $f^{(2)} = 1.00$.\n\n- Test Case $3$:\n  - Image $I^{(3)}$:\n    $\n    \\begin{bmatrix}\n    92 & 95 & 98 & 101 \\\\\n    94 & 97 & 100 & 103 \\\\\n    220 & 225 & 230 & 235 \\\\\n    222 & 228 & 232 & 238\n    \\end{bmatrix}\n    $\n  - Background mask $M_\\mathrm{B}^{(3)}$:\n    $\n    \\begin{bmatrix}\n    1 & 1 & 1 & 1 \\\\\n    1 & 1 & 1 & 1 \\\\\n    0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0\n    \\end{bmatrix}\n    $\n  - Lesion mask $M_\\mathrm{L}^{(3)}$:\n    $\n    \\begin{bmatrix}\n    0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 \\\\\n    1 & 1 & 1 & 1 \\\\\n    1 & 1 & 1 & 1\n    \\end{bmatrix}\n    $\n  - Threshold $f^{(3)} = 0.70$.\n\nRequirements:\n- Use $\\delta = 0.5$.\n- Use the unbiased sample standard deviation with denominator $n-1$ within each ROI.\n- Evaluate $k$ from $1$ to $8$ and select the smallest $k$ that satisfies the inequality.\n- Your program should produce a single line of output containing the three resulting integers as a comma-separated list enclosed in square brackets, for example $[a,b,c]$ where $a$, $b$, and $c$ are the answers for Test Cases $1$, $2$, and $3$, respectively.\n\nYour program must be self-contained and must not read any external input. The only allowed output is the single-line list in the format specified above.",
            "solution": "## Problem Validation\n\n### Step 1: Extract Givens\n- **Image Representation**: Grayscale image with $8$-bit uniform scalar quantization. Pixel intensity $I(x,y)$ is an integer in $\\{0, \\dots, 255\\}$.\n- **Bitplane Decomposition**: $I(x,y)$ is a sum of weighted bits $b_j(x,y) \\in \\{0,1\\}$ for $j \\in \\{0, \\dots, 7\\}$ with weights $2^j$.\n- **Reconstructed Image $\\tilde{I}_k$**: An image reconstructed by retaining the $k$ most significant bitplanes ($j \\in \\{8-k, \\dots, 7\\}$). This is equivalent to uniform quantization with step size $\\Delta_k = 2^{8-k}$ applied by truncation.\n- **Quantization Formula**: \n$$\n\\tilde{I}_k(x,y) = \\left\\lfloor \\frac{I(x,y)}{2^{8-k}} \\right\\rfloor \\cdot 2^{8-k}\n$$\n- **Regions of Interest (ROIs)**: A background region $\\mathcal{R}_\\mathrm{B}$ and a lesion region $\\mathcal{R}_\\mathrm{L}$, which are disjoint.\n- **ROI Statistics**:\n    - Background mean $\\mu_\\mathrm{B}(J)$: Arithmetic mean of image $J$ over $\\mathcal{R}_\\mathrm{B}$.\n    - Lesion mean $\\mu_\\mathrm{L}(J)$: Arithmetic mean of image $J$ over $\\mathcal{R}_\\mathrm{L}$.\n    - Unbiased sample standard deviations $s_\\mathrm{B}(J)$ and $s_\\mathrm{L}(J)$ calculated with denominator $n-1$ for each region.\n- **Contrast-to-Noise Ratio (CNR)**:\n$$\n\\mathrm{CNR}(J) = \\frac{\\left|\\mu_\\mathrm{L}(J) - \\mu_\\mathrm{B}(J)\\right|}{\\sqrt{s_\\mathrm{L}(J)^2 + s_\\mathrm{B}(J)^2 + 2\\delta^2}}\n$$\n- **Baseline Noise**: $\\delta = 0.5$.\n- **Target Value $k^\\star$**: The smallest integer $k \\in \\{1, \\dots, 8\\}$ such that the following condition is met for a given threshold $f \\in (0, 1]$:\n$$\n\\frac{\\mathrm{CNR}(\\tilde{I}_k)}{\\mathrm{CNR}(I)} \\ge f\n$$\n- **Test Cases**: Three test cases are provided, each with a $4 \\times 4$ image $I$, a background mask $M_\\mathrm{B}$ (top two rows), a lesion mask $M_\\mathrm{L}$ (bottom two rows), and a threshold $f$.\n    - **Test Case 1**: $I^{(1)}$, $M_\\mathrm{B}^{(1)}$, $M_\\mathrm{L}^{(1)}$, $f^{(1)} = 0.70$.\n    - **Test Case 2**: $I^{(2)}$, $M_\\mathrm{B}^{(2)}$, $M_\\mathrm{L}^{(2)}$, $f^{(2)} = 1.00$.\n    - **Test Case 3**: $I^{(3)}$, $M_\\mathrm{B}^{(3)}$, $M_\\mathrm{L}^{(3)}$, $f^{(3)} = 0.70$.\n    - The specific matrices for images and masks are provided in the problem statement.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is well-grounded in the fundamental principles of digital image processing and medical physics. Concepts like bitplane decomposition, quantization, mean, standard deviation, and Contrast-to-Noise Ratio (CNR) are standard and correctly formulated. The inclusion of a baseline noise term $\\delta$ in the CNR denominator is a physically realistic refinement.\n2.  **Well-Posed**: The problem is mathematically precise and self-contained. All functions, variables, and constants are explicitly defined. The task is to find the minimum integer $k$ within a finite set $\\{1, \\dots, 8\\}$ that satisfies a well-defined inequality. This structure ensures that a unique and meaningful solution exists for each test case.\n3.  **Objective**: The problem is stated using objective, formal language. The inputs are numerical arrays and parameters, and the required output is a numerical result derived from unambiguous calculations. There are no subjective or opinion-based elements.\n4.  **Flaw Checklist**:\n    - **Scientific or Factual Unsoundness**: None. The formulas and concepts are standard.\n    - **Non-Formalizable or Irrelevant**: None. The problem is a formal exercise in medical image analysis.\n    - **Incomplete or Contradictory Setup**: None. All necessary data, including images, masks, and parameters, are provided. The ROI masks are disjoint as required.\n    - **Unrealistic or Infeasible**: None. The image values are within the specified $8$-bit range, and the calculations are computationally feasible.\n    - **Ill-Posed or Poorly Structured**: None. The logic is straightforward, and the search for a minimal integer solution is a well-defined procedure.\n    - **Pseudo-Profound, Trivial, or Tautological**: None. The problem requires a multi-step calculation that demonstrates an understanding of quantization effects on image statistics, which is a non-trivial concept.\n    - **Outside Scientific Verifiability**: None. The entire calculation is deterministic and can be independently verified.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a clear, self-contained, and scientifically sound exercise in quantitative image analysis. I will proceed with a full solution.\n\n## Solution\n\nThe solution requires implementing a procedure to calculate the integer $k^\\star$ for each of the three test cases. This involves a systematic application of the provided definitions. The overall algorithm for each test case is as follows:\n\n1.  **Define a function to calculate the CNR.** This function, let's call it `calculate_cnr`, will take an image $J$, a background mask $M_\\mathrm{B}$, a lesion mask $M_\\mathrm{L}$, and the baseline noise $\\delta$ as input.\n    - It first extracts the pixel values for the background region $\\mathcal{R}_\\mathrm{B}$ and the lesion region $\\mathcal{R}_\\mathrm{L}$ using the masks.\n    - It then calculates the arithmetic mean ($\\mu_\\mathrm{B}(J)$, $\\mu_\\mathrm{L}(J)$) and the unbiased sample standard deviation ($s_\\mathrm{B}(J)$, $s_\\mathrm{L}(J)$ with a denominator of $n-1$) for each region.\n    - Finally, it computes the CNR using the given formula: $\\mathrm{CNR}(J) = \\frac{|\\mu_\\mathrm{L}(J) - \\mu_\\mathrm{B}(J)|}{\\sqrt{s_\\mathrm{L}(J)^2 + s_\\mathrm{B}(J)^2 + 2\\delta^2}}$. The term $2\\delta^2 = 2(0.5)^2 = 0.5$ is a positive constant, which prevents a division by zero in cases where both regions have zero variance.\n\n2.  **Calculate the reference CNR for the original image.** For each test case, apply the `calculate_cnr` function to the original image $I$ to obtain the reference value $\\mathrm{CNR}(I)$.\n\n3.  **Iterate through $k$ to find $k^\\star$.** For each test case, loop through the integer values of $k$ from $1$ to $8$. In each iteration:\n    - **Reconstruct the image.** Generate the quantized image $\\tilde{I}_k$ from the original image $I$ using the formula $\\tilde{I}_k = \\lfloor I / 2^{8-k} \\rfloor \\cdot 2^{8-k}$. The term $\\Delta_k = 2^{8-k}$ is the quantization step size. This operation can be efficiently performed using integer division on the image array.\n    - **Calculate the CNR of the reconstructed image.** Apply the `calculate_cnr` function to $\\tilde{I}_k$ to get $\\mathrm{CNR}(\\tilde{I}_k)$.\n    - **Check the condition.** Evaluate the inequality $\\frac{\\mathrm{CNR}(\\tilde{I}_k)}{\\mathrm{CNR}(I)} \\ge f$. If $\\mathrm{CNR}(I)$ is non-zero, this is a simple division. If $\\mathrm{CNR}(I)$ were zero, the ratio would be undefined or infinite, but for the given test data, the region means are different, so $\\mathrm{CNR}(I)$ is positive.\n    - **Determine $k^\\star$.** The first value of $k$ (starting from $k=1$) for which the inequality holds is the solution $k^\\star$ for that test case. Once found, we record this value and proceed to the next test case.\n\n4.  **Consolidate and format the results.** Collect the values of $k^\\star$ for all three test cases and format them into the required output string.\n\nThis entire procedure will be encapsulated in a Python script using the NumPy library for efficient numerical and array operations. `numpy.mean` and `numpy.std(ddof=1)` are the appropriate functions for calculating the required statistics.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the medical imaging quantization problem for the three given test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"image\": np.array([\n                [129, 131, 133, 135],\n                [130, 132, 134, 136],\n                [149, 151, 153, 155],\n                [150, 152, 154, 152]\n            ], dtype=np.int32),\n            \"mask_b\": np.array([\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [0, 0, 0, 0],\n                [0, 0, 0, 0]\n            ], dtype=np.int32),\n            \"mask_l\": np.array([\n                [0, 0, 0, 0],\n                [0, 0, 0, 0],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1]\n            ], dtype=np.int32),\n            \"f\": 0.70\n        },\n        {\n            \"image\": np.array([\n                [170, 171, 173, 174],\n                [172, 173, 175, 171],\n                [190, 191, 193, 194],\n                [192, 193, 195, 191]\n            ], dtype=np.int32),\n            \"mask_b\": np.array([\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [0, 0, 0, 0],\n                [0, 0, 0, 0]\n            ], dtype=np.int32),\n            \"mask_l\": np.array([\n                [0, 0, 0, 0],\n                [0, 0, 0, 0],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1]\n            ], dtype=np.int32),\n            \"f\": 1.00\n        },\n        {\n            \"image\": np.array([\n                [92, 95, 98, 101],\n                [94, 97, 100, 103],\n                [220, 225, 230, 235],\n                [222, 228, 232, 238]\n            ], dtype=np.int32),\n            \"mask_b\": np.array([\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [0, 0, 0, 0],\n                [0, 0, 0, 0]\n            ], dtype=np.int32),\n            \"mask_l\": np.array([\n                [0, 0, 0, 0],\n                [0, 0, 0, 0],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1]\n            ], dtype=np.int32),\n            \"f\": 0.70\n        }\n    ]\n\n    delta = 0.5\n    results = []\n\n    def calculate_cnr(image, mask_b, mask_l, delta_noise):\n        \"\"\"Calculates the CNR for a given image and ROIs.\"\"\"\n        # Convert 0/1 masks to boolean masks for indexing\n        bool_mask_b = mask_b.astype(bool)\n        bool_mask_l = mask_l.astype(bool)\n\n        pixels_b = image[bool_mask_b]\n        pixels_l = image[bool_mask_l]\n\n        # Calculate means\n        mu_b = np.mean(pixels_b)\n        mu_l = np.mean(pixels_l)\n\n        # Calculate unbiased sample standard deviations (ddof=1)\n        # If all pixels in a region are the same, std will be 0, which is correct.\n        s_b = np.std(pixels_b, ddof=1)\n        s_l = np.std(pixels_l, ddof=1)\n        \n        # Calculate CNR\n        numerator = np.abs(mu_l - mu_b)\n        denominator = np.sqrt(s_l**2 + s_b**2 + 2 * delta_noise**2)\n        \n        # Denominator is guaranteed to be non-zero since delta is non-zero\n        return numerator / denominator\n\n    for case in test_cases:\n        I = case[\"image\"]\n        M_B = case[\"mask_b\"]\n        M_L = case[\"mask_l\"]\n        f = case[\"f\"]\n        \n        cnr_original = calculate_cnr(I, M_B, M_L, delta)\n\n        k_star = -1 # Should be replaced in the loop\n\n        if cnr_original == 0 and f > 0:\n            # If original CNR is 0, any non-zero reconstructed CNR would yield\n            # an infinite ratio. Or if reconstructed CNR is also 0, ratio could be 1.\n            # We must carefully check this. For the given problems, cnr_original is not 0.\n            # However, for completeness, we search for the first k that gives non-zero CNR.\n            for k in range(1, 9):\n                delta_k = 2**(8 - k)\n                I_k = (I // delta_k) * delta_k\n                cnr_k = calculate_cnr(I_k, M_B, M_L, delta)\n                if cnr_k > 0:\n                    k_star = k\n                    break\n        else:\n            for k in range(1, 9):\n                # Calculate the quantization step size\n                delta_k = 2**(8 - k)\n                \n                # Apply the quantization by truncation\n                I_k = (I // delta_k) * delta_k\n                \n                # Calculate CNR of the reconstructed image\n                cnr_k = calculate_cnr(I_k, M_B, M_L, delta)\n                \n                # Check the condition\n                ratio = cnr_k / cnr_original\n                if ratio >= f:\n                    k_star = k\n                    break\n        \n        results.append(k_star)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}