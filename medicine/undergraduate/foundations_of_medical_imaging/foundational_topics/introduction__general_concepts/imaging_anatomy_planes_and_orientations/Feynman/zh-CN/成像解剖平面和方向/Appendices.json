{
    "hands_on_practices": [
        {
            "introduction": "在神经影像学中，为了在不同受试者之间进行比较，标准化大脑方向至关重要。这通常通过将图像与基于关键解剖标志点的模板对齐来完成。本练习将演示如何从三个不共线的点推导出一个唯一的刚性变换（旋转和平移），通过解决这个问题，你将具体理解像AC-PC连线这样的抽象解剖平面如何转化为精确的数学坐标系，这是图像配准中的一项基本技能。",
            "id": "4894133",
            "problem": "一个脑部磁共振成像 (MRI) 容积数据需要与一个由前联合 (AC)、后联合 (PC) 和一个上中矢状点定义的标准图谱坐标系进行刚性对齐。图谱坐标系的构建方式如下：AC 为原点，AC–PC 连线定义 $y$ 轴正方向，上中线点定义 $z$ 轴正方向，最终形成的坐标系为右手坐标系。在这个标准图谱坐标系中，界标点由下式给出\n$\\mathbf{a}_{\\mathrm{AC}} = (0, 0, 0)$ mm，$\\mathbf{a}_{\\mathrm{PC}} = (0, 25, 0)$ mm，以及 $\\mathbf{a}_{\\mathrm{MS}} = (0, 0, 30)$ mm。\n在患者的 MRI 图像中，测得相应的界标点位于\n$\\mathbf{p}_{\\mathrm{AC}} = (10, -5, 2)$ mm，$\\mathbf{p}_{\\mathrm{PC}} = (35, -5, 2)$ mm，以及 $\\mathbf{p}_{\\mathrm{MS}} = (10, 25, 2)$ mm。\n假设图谱和患者的界标点不共线，并按照标准的神经解剖学方向通过界标点的直线连接来定义各自的局部坐标轴：AC–PC 向量定义 $y$ 轴，AC–MS 向量定义 $z$ 轴，并通过向量叉积选择 $x$ 轴以构成一个右手正交归一三轴架。仅使用这些定义以及旋转和平移的刚性约束，推导唯一的刚性变换 $(\\mathbf{R}, \\mathbf{t})$，该变换将患者界标点映射到图谱界标点，其中 $\\mathbf{R}$ 是一个 $3 \\times 3$ 旋转矩阵，$\\mathbf{t}$ 是一个 $3 \\times 1$ 平移向量，并且 $\\mathbf{R}\\mathbf{p} + \\mathbf{t}$ 将患者坐标 $\\mathbf{p}$ 映射到图谱坐标系中。\n\n为了进行质量控制，在图谱中确定了第四个解剖点，其位置为 $\\mathbf{a}_{4} = (12, 8, 15)$ mm。相应的患者测量值为 $\\mathbf{p}_{4} = (18.6, 9.6, 14.3)$ mm。将推导出的刚性变换应用于所有四个患者点后，计算这四个界标点对应关系的均方根 (RMS) 残余误差，\n$$E_{\\mathrm{RMS}} = \\left( \\frac{\\sum_{i=1}^{4} \\|\\mathbf{R}\\mathbf{p}_{i} + \\mathbf{t} - \\mathbf{a}_{i}\\|^{2}}{4} \\right)^{1/2},$$\n其中 $\\|\\cdot\\|$ 表示欧几里得范数，$(\\mathbf{p}_{i}, \\mathbf{a}_{i})$ 表示 AC、PC、MS 和第四个点的患者-图谱界标点对。将您计算出的 $E_{\\mathrm{RMS}}$ 最终数值结果四舍五入至四位有效数字，并以毫米为单位表示。",
            "solution": "目标是找到一个刚性变换 $(\\mathbf{R}, \\mathbf{t})$，该变换将患者坐标中的点 $\\mathbf{p}$ 映射到图谱坐标中的点 $\\mathbf{a}$，使得 $\\mathbf{a} = \\mathbf{R}\\mathbf{p} + \\mathbf{t}$。此变换通过对齐两个坐标系来确定：一个由患者界标点定义，另一个由图谱界标点定义。\n\n首先，我们为图谱坐标系构建标准正交基，记为 $A$。原点为 $\\mathbf{O}_A = \\mathbf{a}_{\\mathrm{AC}} = (0, 0, 0)$。基向量 $(\\mathbf{u}_{xA}, \\mathbf{u}_{yA}, \\mathbf{u}_{zA})$ 的构建如下：\n$y$ 轴由从 $\\mathbf{a}_{\\mathrm{AC}}$ 到 $\\mathbf{a}_{\\mathrm{PC}}$ 的向量定义。\n$$ \\mathbf{v}_{yA} = \\mathbf{a}_{\\mathrm{PC}} - \\mathbf{a}_{\\mathrm{AC}} = \\begin{pmatrix} 0 \\\\ 25 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 25 \\\\ 0 \\end{pmatrix} $$\n单位向量为 $\\mathbf{u}_{yA} = \\frac{\\mathbf{v}_{yA}}{\\|\\mathbf{v}_{yA}\\|} = \\frac{1}{25}\\begin{pmatrix} 0 \\\\ 25 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}$。\n$z$ 轴由从 $\\mathbf{a}_{\\mathrm{AC}}$ 到 $\\mathbf{a}_{\\mathrm{MS}}$ 的向量定义。\n$$ \\mathbf{v}_{zA} = \\mathbf{a}_{\\mathrm{MS}} - \\mathbf{a}_{\\mathrm{AC}} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 30 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 30 \\end{pmatrix} $$\n单位向量为 $\\mathbf{u}_{zA} = \\frac{\\mathbf{v}_{zA}}{\\|\\mathbf{v}_{zA}\\|} = \\frac{1}{30}\\begin{pmatrix} 0 \\\\ 0 \\\\ 30 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$。\n$x$ 轴构成右手标准正交系：\n$$ \\mathbf{u}_{xA} = \\mathbf{u}_{yA} \\times \\mathbf{u}_{zA} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} \\times \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n图谱坐标系的基矩阵 $\\mathbf{M}_A = [\\mathbf{u}_{xA} \\ \\mathbf{u}_{yA} \\ \\mathbf{u}_{zA}]$ 是单位矩阵 $\\mathbf{I}$。\n$$ \\mathbf{M}_A = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} $$\n\n接下来，我们为患者坐标系 $P$ 构建标准正交基。原点为 $\\mathbf{O}_P = \\mathbf{p}_{\\mathrm{AC}} = (10, -5, 2)$。根据问题描述构建基向量 $(\\mathbf{u}_{xP}, \\mathbf{u}_{yP}, \\mathbf{u}_{zP})$。\n$y$ 轴由从 $\\mathbf{p}_{\\mathrm{AC}}$ 到 $\\mathbf{p}_{\\mathrm{PC}}$ 的向量定义。\n$$ \\mathbf{v}_{yP} = \\mathbf{p}_{\\mathrm{PC}} - \\mathbf{p}_{\\mathrm{AC}} = \\begin{pmatrix} 35 \\\\ -5 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 10 \\\\ -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 25 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n单位向量为 $\\mathbf{u}_{yP} = \\frac{\\mathbf{v}_{yP}}{\\|\\mathbf{v}_{yP}\\|} = \\frac{1}{25}\\begin{pmatrix} 25 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n$z$ 轴的初始向量是从 $\\mathbf{p}_{\\mathrm{AC}}$ 到 $\\mathbf{p}_{\\mathrm{MS}}$。\n$$ \\mathbf{v}_{zP} = \\mathbf{p}_{\\mathrm{MS}} - \\mathbf{p}_{\\mathrm{AC}} = \\begin{pmatrix} 10 \\\\ 25 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 10 \\\\ -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 30 \\\\ 0 \\end{pmatrix} $$\n我们检查 $\\mathbf{v}_{yP}$ 和 $\\mathbf{v}_{zP}$ 之间的正交性：$\\mathbf{v}_{yP} \\cdot \\mathbf{v}_{zP} = (25)(0) + (0)(30) + (0)(0) = 0$。这两个向量已经正交，因此不需要进行格拉姆-施密特正交化。我们只需将 $\\mathbf{v}_{zP}$ 归一化。\n$$ \\mathbf{u}_{zP} = \\frac{\\mathbf{v}_{zP}}{\\|\\mathbf{v}_{zP}\\|} = \\frac{1}{30}\\begin{pmatrix} 0 \\\\ 30 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} $$\n$x$ 轴构成右手标准正交系：\n$$ \\mathbf{u}_{xP} = \\mathbf{u}_{yP} \\times \\mathbf{u}_{zP} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\times \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\n患者坐标系的基矩阵为 $\\mathbf{M}_P = [\\mathbf{u}_{xP} \\ \\mathbf{u}_{yP} \\ \\mathbf{u}_{zP}]$。\n$$ \\mathbf{M}_P = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 1  0  0 \\end{pmatrix} $$\n\n刚性变换 $(\\mathbf{R}, \\mathbf{t})$ 关联了患者和图谱的坐标系。一个点 $\\mathbf{p}$ 是相对于其坐标系的原点和基来表示的。该变换对齐了这些基和原点。旋转矩阵 $\\mathbf{R}$ 将患者基映射到图谱基上：$\\mathbf{R}\\mathbf{M}_P = \\mathbf{M}_A$。因此，$\\mathbf{R} = \\mathbf{M}_A \\mathbf{M}_P^{-1} = \\mathbf{M}_A \\mathbf{M}_P^T$。\n由于 $\\mathbf{M}_A = \\mathbf{I}$，我们有 $\\mathbf{R} = \\mathbf{M}_P^T$。\n$$ \\mathbf{R} = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 1  0  0 \\end{pmatrix}^T = \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix} $$\n平移向量 $\\mathbf{t}$ 在旋转后对齐原点：$\\mathbf{R}\\mathbf{O}_P + \\mathbf{t} = \\mathbf{O}_A$。\n$$ \\mathbf{t} = \\mathbf{O}_A - \\mathbf{R}\\mathbf{O}_P = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix} \\begin{pmatrix} 10 \\\\ -5 \\\\ 2 \\end{pmatrix} = - \\begin{pmatrix} 2 \\\\ 10 \\\\ -5 \\end{pmatrix} = \\begin{pmatrix} -2 \\\\ -10 \\\\ 5 \\end{pmatrix} $$\n\n现在我们计算均方根 (RMS) 误差。公式为：\n$$ E_{\\mathrm{RMS}} = \\left( \\frac{\\sum_{i=1}^{4} \\|\\mathbf{R}\\mathbf{p}_{i} + \\mathbf{t} - \\mathbf{a}_{i}\\|^{2}}{4} \\right)^{1/2} $$\n对于前三个界标点（$i=1,2,3$ 分别对应 AC, PC, MS），根据变换的构造，误差为零。\n$\\|\\mathbf{R}\\mathbf{p}_1 + \\mathbf{t} - \\mathbf{a}_1\\|^2 = \\|\\mathbf{R}\\mathbf{p}_{\\mathrm{AC}} + \\mathbf{t} - \\mathbf{a}_{\\mathrm{AC}}\\|^2 = 0$。\n$\\|\\mathbf{R}\\mathbf{p}_2 + \\mathbf{t} - \\mathbf{a}_2\\|^2 = \\|\\mathbf{R}\\mathbf{p}_{\\mathrm{PC}} + \\mathbf{t} - \\mathbf{a}_{\\mathrm{PC}}\\|^2 = 0$。\n$\\|\\mathbf{R}\\mathbf{p}_3 + \\mathbf{t} - \\mathbf{a}_3\\|^2 = \\|\\mathbf{R}\\mathbf{p}_{\\mathrm{MS}} + \\mathbf{t} - \\mathbf{a}_{\\mathrm{MS}}\\|^2 = 0$。\n求和简化为仅含第四个点 $\\mathbf{p}_4 = (18.6, 9.6, 14.3)$ 和 $\\mathbf{a}_4 = (12, 8, 15)$ 的项。\n首先，变换 $\\mathbf{p}_4$：\n$$ \\mathbf{a}'_4 = \\mathbf{R}\\mathbf{p}_4 + \\mathbf{t} = \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix} \\begin{pmatrix} 18.6 \\\\ 9.6 \\\\ 14.3 \\end{pmatrix} + \\begin{pmatrix} -2 \\\\ -10 \\\\ 5 \\end{pmatrix} $$\n$$ \\mathbf{a}'_4 = \\begin{pmatrix} 14.3 \\\\ 18.6 \\\\ 9.6 \\end{pmatrix} + \\begin{pmatrix} -2 \\\\ -10 \\\\ 5 \\end{pmatrix} = \\begin{pmatrix} 12.3 \\\\ 8.6 \\\\ 14.6 \\end{pmatrix} $$\n第四个点的残余误差平方为 $\\|\\mathbf{a}'_4 - \\mathbf{a}_4\\|^2$。\n$$ \\mathbf{a}'_4 - \\mathbf{a}_4 = \\begin{pmatrix} 12.3 \\\\ 8.6 \\\\ 14.6 \\end{pmatrix} - \\begin{pmatrix} 12 \\\\ 8 \\\\ 15 \\end{pmatrix} = \\begin{pmatrix} 0.3 \\\\ 0.6 \\\\ -0.4 \\end{pmatrix} $$\n$$ \\|\\mathbf{a}'_4 - \\mathbf{a}_4\\|^2 = (0.3)^2 + (0.6)^2 + (-0.4)^2 = 0.09 + 0.36 + 0.16 = 0.61 $$\n现在我们计算 RMS 误差：\n$$ E_{\\mathrm{RMS}} = \\left( \\frac{0 + 0 + 0 + 0.61}{4} \\right)^{1/2} = \\left( \\frac{0.61}{4} \\right)^{1/2} = \\sqrt{0.1525} $$\n$$ E_{\\mathrm{RMS}} \\approx 0.39051248... $$\n四舍五入到四位有效数字，我们得到 $0.3905$。",
            "answer": "$$\\boxed{0.3905}$$"
        },
        {
            "introduction": "CT扫描的理想几何结构假定切片是完全平行的。然而，机械限制可能导致机架倾斜，从而在重建的体数据中引入剪切伪影。本实践将探讨如何通过分析DICOM元数据中提供的切片间位置向量来量化这种倾斜，这个编码练习提供了一个实际的例子，说明了方向向量如何用于质量控制和校正，将一个真实的采集问题转化为一个可解的几何难题。",
            "id": "4894114",
            "problem": "您需要实现一个完整的、可运行的程序，该程序使用医学数字成像和通信（DICOM）元数据检测计算机断层扫描（CT）中的机架倾斜，并计算一个经过剪切校正的方向矩阵，以确保重建的体积具有正交的切片。该程序必须为预定义的测试套件生成结果，而无需任何外部输入。\n\n使用的基本原理和定义：\n- 医学数字成像和通信（DICOM）为每个切片提供元数据，包括图像方向（患者）和图像位置（患者）。\n- 设图像方向（患者）由两个单位向量给出：行方向向量 $r \\in \\mathbb{R}^3$ 和列方向向量 $c \\in \\mathbb{R}^3$。切片法向量为 $n = r \\times c$，其中 $\\times$ 表示向量叉积。\n- 设第 $k$ 个切片的图像位置（患者）为 $p_k \\in \\mathbb{R}^3$，并为连续切片定义切片间平移向量 $\\Delta p_k = p_{k+1} - p_k$。\n- 像素间距由两个正实数给出：$\\Delta_r$（行间距，单位mm）和 $\\Delta_c$（列间距，单位mm）。所有几何量均以毫米（mm）为单位。\n- $r$ 和 $c$ 的标准正交性意味着 $r \\cdot r = 1$, $c \\cdot c = 1$, 以及 $r \\cdot c = 0$，其中 $\\cdot$ 表示点积。\n\n科学原理：\n- 在没有机架倾斜的情况下，切片间平移 $\\Delta p_k$ 沿 $r$ 或 $c$ 没有平面内分量，纯粹沿 $n$ 方向，因此 $\\Delta p_k \\approx s_k n$，其中 $s_k \\in \\mathbb{R}$ 是某个标量。当存在机架倾斜时，$\\Delta p_k$ 会获得平面内分量，即可以分解为 $\\Delta p_k = a_k r + b_k c + s_k n$，其中 $a_k$ 和 $b_k$ 非零。\n- 倾斜角 $\\theta$ 可以通过平面内运动幅值与穿透平面运动幅值的比率来量化。定义 $a_k = \\Delta p_k \\cdot r$，$b_k = \\Delta p_k \\cdot c$，和 $s_k = \\Delta p_k \\cdot n$。稳健的汇总值 $a$，$b$ 和 $s$ 作为各切片 $\\{a_k\\}$，$\\{b_k\\}$ 和 $\\{s_k\\}$ 的中位数计算。平面内幅值为 $m = \\sqrt{a^2 + b^2}$，倾斜角为 $\\theta = \\arctan2(m, |s|)$。\n- 经过剪切校正的方向矩阵必须保留平面内几何形状，并将切片轴设置为法线方向，其间距等于穿透平面分量的幅值。$3 \\times 3$ 的方向矩阵 $M$（列向量）为 $M = [R \\; C \\; Z]$，其中 $R = r \\, \\Delta_c$，$C = c \\, \\Delta_r$，以及 $Z = n \\, |s|$。\n\n任务要求：\n1. 实现一个函数，给定 $r$、$c$、一个切片位置列表 $\\{p_k\\}$ 和像素间距 $(\\Delta_r, \\Delta_c)$：\n   - 计算 $n = r \\times c$。\n   - 为所有连续切片计算 $\\Delta p_k = p_{k+1} - p_k$。\n   - 计算 $a_k = \\Delta p_k \\cdot r$，$b_k = \\Delta p_k \\cdot c$ 和 $s_k = \\Delta p_k \\cdot n$。\n   - 使用所有切片的中位数 $a$、$b$ 和 $s$。\n   - 计算倾斜角 $\\theta = \\arctan2(\\sqrt{a^2 + b^2}, |s|)$，以度为单位。\n   - 如果 $\\theta \\ge \\theta_{\\text{thr}}$，则检测到倾斜，阈值 $\\theta_{\\text{thr}} = 0.5$ 度。\n   - 计算经过剪切校正的方向矩阵 $M = [r \\, \\Delta_c,\\; c \\, \\Delta_r,\\; n \\, |s|]$。\n2. 角度必须以度表示。距离必须以毫米（mm）为单位。输出中的倾斜角必须四舍五入到六位小数。\n\n测试套件：\n在您的程序中直接提供以下测试用例。对于每个用例，程序必须使用指定的 $r$、$c$、$n$、初始位置 $p_0$、沿 $n$ 的切片间距 $s$ 以及模拟倾斜的任何平面内分量来构建切片位置列表 $\\{p_k\\}$。使用 $N$ 个切片，索引为 $k = 0, 1, \\dots, N-1$，并遵循以下公式\n$$\np_k = p_0 + k \\, (s \\, n + t_r \\, r + t_c \\, c),\n$$\n其中 $t_r$ 和 $t_c$ 是沿 $r$ 和 $c$ 的每切片平面内位移（单位mm）。如果一个用例没有倾斜，则 $t_r = 0$ 且 $t_c = 0$。如果一个用例指定了绕平面内轴的倾斜角 $\\theta$，则将相应的平面内位移设置为沿该轴的 $t = s \\, \\tan(\\theta)$。\n\n- 用例1（理想情况，无倾斜）：\n  - $r = [1, 0, 0]$，$c = [0, 1, 0]$，$\\Delta_r = 0.8$ mm，$\\Delta_c = 0.8$ mm，$s = 1.5$ mm，$p_0 = [0, 0, 0]$，$N = 5$，$t_r = 0$，$t_c = 0$。\n- 用例2（沿 $c$ 的机架倾斜）：\n  - $r = [1, 0, 0]$，$c = [0, 1, 0]$，$\\Delta_r = 0.7$ mm，$\\Delta_c = 0.7$ mm，$s = 1.2$ mm，$\\theta = 15$ 度，$p_0 = [0, 0, 0]$，$N = 5$，$t_r = 0$，$t_c = s \\, \\tan(\\theta)$。\n- 用例3（沿 $r$ 的机架倾斜）：\n  - $r = [1, 0, 0]$，$c = [0, 1, 0]$，$\\Delta_r = 0.5$ mm，$\\Delta_c = 0.5$ mm，$s = 1.0$ mm，$\\theta = 10$ 度，$p_0 = [0, 0, 0]$，$N = 6$，$t_r = s \\, \\tan(\\theta)$，$t_c = 0$。\n- 用例4（倾斜非常小，低于检测阈值）：\n  - $r = [1, 0, 0]$，$c = [0, 1, 0]$，$\\Delta_r = 0.9$ mm，$\\Delta_c = 0.9$ mm，$s = 2.0$ mm，$\\theta = 0.2$ 度，$p_0 = [0, 0, 0]$，$N = 5$，$t_r = 0$，$t_c = s \\, \\tan(\\theta)$。\n- 用例5（斜向，无机架倾斜）：\n  - $r = [1/\\sqrt{2}, 1/\\sqrt{2}, 0]$，$c = [0, 0, 1]$，$\\Delta_r = 1.0$ mm，$\\Delta_c = 1.0$ mm，$s = 1.0$ mm，$p_0 = [10, 20, 30]$，$N = 4$，$t_r = 0$，$t_c = 0$。\n\n输出规范：\n- 对于每个测试用例，输出一个三元素列表：$[\\text{tilt\\_detected}, \\theta, \\text{flattened\\_matrix}]$，其中 $\\text{tilt\\_detected}$ 是一个布尔值，$\\theta$ 是以度为单位、四舍五入到六位小数的倾斜角，而 $\\text{flattened\\_matrix}$ 是经过剪切校正的 $3 \\times 3$ 方向矩阵 $M$ 按列主序展平为一个包含9个浮点数的列表，每个浮点数四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号内以逗号分隔的列表，例如：$[[\\text{case1\\_result}$],[$\\text{case2\\_result}$],\\dots]$。\n\n角度单位要求：\n- 角度必须以度为单位进行计算和打印。\n\n距离单位要求：\n- 所有长度和间距均以毫米（mm）为单位。\n\n设计约束：\n- 仅使用线性代数定义（点积、叉积）、归一化和向量分解；不要使用超出已定义范围的任何快捷公式。\n- 通过归一化 $r$ 和 $c$、必要时对 $c$ 相对于 $r$ 进行重新正交化以及归一化 $n$ 来确保数值稳健性。",
            "solution": "用户提供的问题已经过严格验证，被确定为一个有效且定义明确的科学编程任务。它在科学上基于医学成像和线性代数的原理，包含完整且一致的设置，并定义了一个清晰、可验证的目标。\n\n### 基于原则的解决方案设计\n\n该解决方案涉及开发一种算法，用于检测计算机断层扫描（CT）数据中的机架倾斜，并计算相应的经过剪切校正的方向矩阵。该方法基于向量代数和坐标变换的基本原理，这些原理适用于医学数字成像和通信（DICOM）标准。\n\n#### 1. 坐标系定义与归一化\n\nCT 图像切片在三维患者坐标系中由 DICOM 元数据提供的一组向量定义。这些向量是行方向向量 $r \\in \\mathbb{R}^3$ 和列方向向量 $c \\in \\mathbb{R}^3$。对于有效的切片几何，这些向量必须是标准正交的，即它们是单位向量并且相互垂直 ($r \\cdot c = 0$)。\n\n第三个基向量，即切片法向量 $n \\in \\mathbb{R}^3$，使用向量叉积计算：\n$$n = r \\times c$$\n如果 $r$ 和 $c$ 是标准正交的，$n$ 也将是单位向量，并且集合 $\\{r, c, n\\}$ 构成一个右手标准正交基。\n\n为了保证数值稳健性，实现将明确强制执行这些属性。输入的向量 $r$ 和 $c$ 将被归一化。随后，将使用 Gram-Schmidt 过程对 $c$ 相对于 $r$ 进行重新正交化，然后再次归一化。这确保了用于所有后续计算的基是完全标准正交的，以防止潜在的浮点数不准确性。\n$$r_{\\text{norm}} = \\frac{r}{\\|r\\|}$$\n$$c_{\\text{ortho}} = c - (c \\cdot r_{\\text{norm}}) r_{\\text{norm}}$$\n$$c_{\\text{norm}} = \\frac{c_{\\text{ortho}}}{\\|c_{\\text{ortho}}\\|}$$\n$$n = r_{\\text{norm}} \\times c_{\\text{norm}}$$\n\n#### 2. 切片间运动分析\n\n每个切片在患者坐标系中的位置由图像位置（患者）标签给出，我们将其表示为第 $k$ 个切片的向量 $p_k \\in \\mathbb{R}^3$。连续切片之间的几何关系由切片间平移向量 $\\Delta p_k$ 描述：\n$$\\Delta p_k = p_{k+1} - p_k$$\n在没有机架倾斜的理想采集中，扫描仪的移动完全垂直于切片平面。因此，平移向量 $\\Delta p_k$ 应平行于切片法向量 $n$：\n$$\\Delta p_k \\approx s_k n$$\n其中 $s_k$ 是移动的距离，即切片厚度或间距。\n\n当存在机架倾斜时，切片之间的平移包含切片平面内的分量（平面内运动）。向量 $\\Delta p_k$ 可以分解为其沿基向量 $r$、$c$ 和 $n$ 的分量：\n$$\\Delta p_k = a_k r + b_k c + s_k n$$\n标量分量通过使用点积将 $\\Delta p_k$ 投影到每个基向量上来找到：\n$$a_k = \\Delta p_k \\cdot r \\quad (\\text{沿行方向的平面内分量})$$\n$$b_k = \\Delta p_k \\cdot c \\quad (\\text{沿列方向的平面内分量})$$\n$$s_k = \\Delta p_k \\cdot n \\quad (\\text{穿透平面分量})$$\n$a_k$ 或 $b_k$ 的非零值表示存在机架倾斜。\n\n#### 3. 稳健的倾斜量化\n\n在真实世界的数据中，切片位置可能会有微小变化。为了获得整个序列的单一、稳健的倾斜度量，问题指定使用所有切片分量值的中位数。设 $a$、$b$ 和 $s$ 分别是集合 $\\{a_k\\}$、$\\{b_k\\}$ 和 $\\{s_k\\}$ 的中位数。\n\n平均平面内位移的幅值 $m$ 由以下公式给出：\n$$m = \\sqrt{a^2 + b^2}$$\n倾斜角 $\\theta$ 是实际切片间运动向量与切片法线之间的角度。它可以根据平面内运动幅值与穿透平面运动幅值的比率计算得出：\n$$\\theta = \\arctan2(m, |s|)$$\n结果从弧度转换为度。如果此角度超过指定的阈值 $\\theta_{\\text{thr}} = 0.5^\\circ$，则正式检测到倾斜。\n\n#### 4. 剪切校正的方向矩阵\n\n为确保重建的三维体积具有正交切片，会计算一个新的方向矩阵 $M$。该矩阵定义了体积体素的几何形状。该矩阵由三个列向量 $R$、$C$ 和 $Z$ 构成，它们分别表示沿图像网格每个轴移动一个体素时在患者坐标系中的位移。\n\n遵循问题的定义，该定义与 DICOM 约定一致：\n- $R = r \\cdot \\Delta_c$：第一列将行向量 $r$ 乘以列像素间距 $\\Delta_c$。\n- $C = c \\cdot \\Delta_r$：第二列将列向量 $c$ 乘以行像素间距 $\\Delta_r$。\n- $Z = n \\cdot |s|$：第三列，代表“切片轴”，将法向量 $n$ 乘以中值穿透平面间距的幅值 $|s|$。这有效地从采集几何中移除了剪切分量。\n\n最终的剪切校正方向矩阵 $M$ 为：\n$$M = \\begin{bmatrix} |  |  | \\\\ R  C  Z \\\\ |  |  | \\end{bmatrix} = \\begin{bmatrix} r_x \\Delta_c  c_x \\Delta_r  n_x |s| \\\\ r_y \\Delta_c  c_y \\Delta_r  n_y |s| \\\\ r_z \\Delta_c  c_z \\Delta_r  n_z |s| \\end{bmatrix}$$\n程序将把这个 $3 \\times 3$ 矩阵按列主序展平为一个包含9个元素的列表，用于最终输出。\n\n#### 5. 测试用例模拟\n\n测试套件是以编程方式生成的。对于每个用例，使用以下公式创建一系列 $N$ 个切片位置 $\\{p_k\\}_{k=0}^{N-1}$：\n$$p_k = p_0 + k \\, (s_{\\text{spacing}} \\, n + t_r \\, r + t_c \\, c)$$\n其中 $p_0$ 是初始位置，$s_{\\text{spacing}}$ 是标称切片间距，$t_r$ 和 $t_c$ 是用户指定的用于模拟机架倾斜的平面内位移。如果测试用例指定了倾斜角 $\\theta_{\\text{in}}$，则相应的平面内位移计算为 $t = s_{\\text{spacing}} \\cdot \\tan(\\theta_{\\text{in}})$。该模型确保了在单个测试用例中，所有切片的切片间向量 $\\Delta p_k$ 是恒定的，为验证算法的正确性提供了一个清晰的场景。\n\n该实现将把整个逻辑封装到一个 Python 程序中，使用 `numpy` 库进行高效准确的向量和矩阵运算，并完全按照指定格式输出结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analyze_ct_series(r, c, slice_positions, delta_r, delta_c, theta_thr):\n    \"\"\"\n    Analyzes a series of CT slices to detect gantry tilt and compute a\n    shear-corrected orientation matrix.\n\n    Args:\n        r (np.ndarray): The row direction vector (3,).\n        c (np.ndarray): The column direction vector (3,).\n        slice_positions (list[np.ndarray]): A list of slice position vectors.\n        delta_r (float): The row pixel spacing (in-plane, along c).\n        delta_c (float): The column pixel spacing (in-plane, along r).\n        theta_thr (float): The tilt detection threshold in degrees.\n\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if tilt is detected, False otherwise.\n            - float: The computed tilt angle in degrees.\n            - np.ndarray: The 3x3 shear-corrected orientation matrix.\n    \"\"\"\n    # 1. Ensure orthonormal basis {r, c, n} for robustness.\n    # Normalize r\n    r = r / np.linalg.norm(r)\n    # Re-orthogonalize c with respect to r (Gram-Schmidt) and normalize\n    c = c - np.dot(c, r) * r\n    c = c / np.linalg.norm(c)\n    # Compute the normal vector n\n    n = np.cross(r, c)\n    # n should be a unit vector, but normalize for safety\n    n = n / np.linalg.norm(n)\n\n    # 2. Compute inter-slice translation vectors\n    if len(slice_positions) < 2:\n        # Not enough slices to compute motion, assume no tilt.\n        s_median = np.sqrt(delta_r**2 + delta_c**2) # A reasonable default\n        return False, 0.0, np.stack([r * delta_c, c * delta_r, n * s_median], axis=-1)\n\n    delta_p_list = [slice_positions[k + 1] - slice_positions[k] for k in range(len(slice_positions) - 1)]\n\n    # 3. Decompose inter-slice vectors into in-plane and through-plane components\n    a_k = [np.dot(dp, r) for dp in delta_p_list]\n    b_k = [np.dot(dp, c) for dp in delta_p_list]\n    s_k = [np.dot(dp, n) for dp in delta_p_list]\n\n    # 4. Use medians for robust estimation\n    a_median = np.median(a_k)\n    b_median = np.median(b_k)\n    s_median = np.median(s_k)\n\n    # 5. Compute tilt angle\n    in_plane_magnitude = np.sqrt(a_median**2 + b_median**2)\n    # arctan2(y, x) where y is in-plane and x is through-plane component\n    tilt_angle_rad = np.arctan2(in_plane_magnitude, np.abs(s_median))\n    tilt_angle_deg = np.rad2deg(tilt_angle_rad)\n\n    # 6. Detect tilt\n    is_tilted = tilt_angle_deg >= theta_thr\n\n    # 7. Compute the shear-corrected orientation matrix M = [R, C, Z]\n    # R = r * delta_c, C = c * delta_r, Z = n * |s_median|\n    R_col = r * delta_c\n    C_col = c * delta_r\n    Z_col = n * np.abs(s_median)\n    M = np.stack([R_col, C_col, Z_col], axis=-1)\n\n    return is_tilted, tilt_angle_deg, M\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Tilt detection threshold\n    theta_thr = 0.5  # degrees\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, no tilt)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.8, 'delta_c': 0.8, 's': 1.5, 'p0': [0, 0, 0], 'N': 5, 'tilt_deg': 0.0, 'tilt_axis': None},\n        # Case 2 (gantry tilt along c)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.7, 'delta_c': 0.7, 's': 1.2, 'p0': [0, 0, 0], 'N': 5, 'tilt_deg': 15.0, 'tilt_axis': 'c'},\n        # Case 3 (gantry tilt along r)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.5, 'delta_c': 0.5, 's': 1.0, 'p0': [0, 0, 0], 'N': 6, 'tilt_deg': 10.0, 'tilt_axis': 'r'},\n        # Case 4 (very small tilt below detection threshold)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.9, 'delta_c': 0.9, 's': 2.0, 'p0': [0, 0, 0], 'N': 5, 'tilt_deg': 0.2, 'tilt_axis': 'c'},\n        # Case 5 (oblique orientation, no gantry tilt)\n        {'r': [1/np.sqrt(2), 1/np.sqrt(2), 0], 'c': [0, 0, 1], 'delta_r': 1.0, 'delta_c': 1.0, 's': 1.0, 'p0': [10, 20, 30], 'N': 4, 'tilt_deg': 0.0, 'tilt_axis': None},\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        # Prepare inputs for this test case\n        r_vec = np.array(case['r'], dtype=float)\n        c_vec = np.array(case['c'], dtype=float)\n        p0 = np.array(case['p0'], dtype=float)\n        s_spacing = case['s']\n        N = case['N']\n        delta_r = case['delta_r']\n        delta_c = case['delta_c']\n\n        # Normalize basis vectors for generating slice positions\n        r_norm = r_vec / np.linalg.norm(r_vec)\n        c_ortho = c_vec - np.dot(c_vec, r_norm) * r_norm\n        c_norm = c_ortho / np.linalg.norm(c_ortho)\n        n_norm = np.cross(r_norm, c_norm)\n\n        # Calculate in-plane shifts based on tilt angle\n        t_r, t_c = 0.0, 0.0\n        if case['tilt_axis']:\n            tilt_rad = np.deg2rad(case['tilt_deg'])\n            shift = s_spacing * np.tan(tilt_rad)\n            if case['tilt_axis'] == 'r':\n                t_r = shift\n            elif case['tilt_axis'] == 'c':\n                t_c = shift\n        \n        # Generate the list of slice positions\n        # p_k = p_0 + k * (s * n + t_r * r + t_c * c)\n        inter_slice_vec = s_spacing * n_norm + t_r * r_norm + t_c * c_norm\n        slice_positions = [p0 + k * inter_slice_vec for k in range(N)]\n\n        # Analyze the generated slice data\n        is_tilted, angle_deg, matrix = analyze_ct_series(\n            r_vec, c_vec, slice_positions, delta_r, delta_c, theta_thr\n        )\n        \n        # Format the results for this case\n        is_tilted_str = str(is_tilted).lower()\n        angle_str = f\"{angle_deg:.6f}\"\n        matrix_flat_col_major = matrix.flatten('F')\n        matrix_str = \"[\" + \",\".join(f\"{val:.6f}\" for val in matrix_flat_col_major) + \"]\"\n        case_result_str = f\"[{is_tilted_str},{angle_str},{matrix_str}]\"\n        \n        all_results_str.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "中矢状面（MSP）是大脑中最重要的解剖参考平面，但其精确位置通常必须根据图像数据本身来估计。这个问题利用了大脑固有的双侧对称性，将MSP估计构建为一个优化问题：寻找能使解剖标志点镜像对称性最大化的平面。这项高级练习旨在挑战你设计一种算法，以计算方式定义一个基本的解剖学概念，并分析估计误差如何影响后续分析，从而弥合解剖学知识与稳健的图像处理之间的差距。",
            "id": "4894093",
            "problem": "给定一个符合标准神经解剖学惯例的三维坐标系：左右轴是 $x$ 轴，前后轴是 $y$ 轴，上下轴是 $z$ 轴。中矢状面是一个理想情况下分隔左右半球的几何平面，在解剖学对齐的图像中，它是过原点且单位法向量与左右轴正方向对齐的平面。逻辑任务是利用解剖学对称性，通过双侧标志点对来估计中矢状面，然后量化该估计中的误差如何作为方向误差传播到下游的向量分析中。您的程序必须仅使用向量几何以及三维空间中反射和旋转的定义来实现以下步骤。\n\n要使用的基本原理和定义：\n- 使用欧几里得内积和范数：对于任意向量 $\\mathbf{a}, \\mathbf{b} \\in \\mathbb{R}^3$，内积为 $\\mathbf{a} \\cdot \\mathbf{b}$，范数为 $\\|\\mathbf{a}\\| = \\sqrt{\\mathbf{a} \\cdot \\mathbf{a}}$。\n- 一个过原点、单位法向量为 $\\mathbf{n}$ 的平面，其反射算子可以将任意点映射到其关于该平面的镜像点。请使用过原点平面反射的形式化向量定义。\n- 三维空间中的旋转由通过经过充分测试的旋转构造方法得到的正交矩阵表示。请使用关于标准坐标轴的旋转矩阵的形式化定义以及旋转的复合。\n- 非零向量 $\\mathbf{u}$ 和 $\\mathbf{v}$ 之间的夹角 $\\alpha$ 满足 $\\cos \\alpha = \\dfrac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\|\\mathbf{v}\\|}$。\n\n算法目标：\n1. 给定双侧标志点集 $\\{\\mathbf{L}_i\\}$（左侧）和 $\\{\\mathbf{R}_i\\}$（右侧），通过搜索由偏航角 $\\theta$（绕 $z$ 轴旋转）和俯仰角 $\\psi$（绕 $y$ 轴旋转）参数化的单位法向量来估计中矢状面，这些旋转应用于左右轴正方向。对于每个候选单位法向量，通过将每个左侧标志点反射到候选平面并与相应的右侧标志点进行比较（反之亦然），使用基于范数的差异来计算对称性残差。选择使所有标志点对的总残差最小的偏航角和俯仰角。该平面被约束为通过原点。为消除符号模糊性（因为 $\\mathbf{n}$ 和 $-\\mathbf{n}$ 代表同一个平面），定义估计的单位法向量，使其与左右轴正方向的点积为非负。\n2. 对于下游分析，定义一个对齐旋转，它以最小的旋转角将估计的单位法向量映射到左右轴正方向。将此对齐旋转应用于给定的下游单位方向向量 $\\mathbf{v}$，并计算使用真实平面校准的向量与使用估计平面校准的向量之间的夹角（以度为单位），此夹角即为方向误差。\n\n角度单位要求：\n- 所有输入参数和输出结果中的角度都必须以度为单位表示。您的程序必须输出以度为单位的角度，并四舍五入到三位小数。\n\n测试套件：\n在以下四个测试用例上实现该算法。对于所有测试用例，平面都通过原点。\n\n- 测试用例 $1$（理想路径，完全对称，无旋转）：\n    - 基础双侧标志点（左侧集和右侧集是关于平面 $x=0$ 的精确镜像）：\n        - 左侧标志点 $\\mathbf{L}_i$：$(-50,0,0)$, $(-40,20,10)$, $(-30,-15,30)$, $(-45,5,-25)$。\n        - 右侧标志点 $\\mathbf{R}_i$：$(50,0,0)$, $(40,20,10)$, $(30,-15,30)$, $(45,5,-25)$。\n    - 真实偏航角 $\\theta_{\\text{true}} = 0$ 度，真实俯仰角 $\\psi_{\\text{true}} = 0$ 度。\n    - 下游单位方向向量 $\\mathbf{v} = (0,1,0)$。\n    - 估计的搜索域：$\\theta \\in [-20,20]$ 度和 $\\psi \\in [-20,20]$ 度，两个角度的均匀网格步长均为 $0.5$ 度。\n\n- 测试用例 $2$（绕 $z$ 轴的偏航旋转）：\n    - 通过将测试用例1的左右标志点集绕 $z$ 轴旋转 $+10$ 度来构造标志点。\n    - 真实偏航角 $\\theta_{\\text{true}} = 10$ 度，真实俯仰角 $\\psi_{\\text{true}} = 0$ 度。\n    - 下游单位方向向量 $\\mathbf{v} = (0,1,0)$。\n    - 使用与测试用例1相同的搜索域和网格步长。\n\n- 测试用例 $3$（边界情况，原点附近有轻微不对称的小幅度标志点）：\n    - 左侧标志点 $\\mathbf{L}_i$：$(-5,1,0.5)$, $(-4,-1,0.2)$, $(-6,0.5,-0.4)$, $(-5.5,-0.2,0.1)$。\n    - 右侧标志点 $\\mathbf{R}_i$：$(5,1.1,0.55)$, $(4,-0.9,0.25)$, $(6,0.45,-0.35)$, $(5.5,-0.15,0.05)$。\n    - 真实偏航角 $\\theta_{\\text{true}} = 0$ 度，真实俯仰角 $\\psi_{\\text{true}} = 0$ 度。\n    - 下游单位方向向量 $\\mathbf{v} = (0.3,0.8,0.5)$。\n    - 使用与测试用例1相同的搜索域和网格步长。\n\n- 测试用例 $4$（绕 $y$ 轴的俯仰旋转）：\n    - 通过将测试用例1的左右标志点集绕 $y$ 轴旋转 $-15$ 度来构造标志点。\n    - 真实偏航角 $\\theta_{\\text{true}} = 0$ 度，真实俯仰角 $\\psi_{\\text{true}} = -15$ 度。\n    - 下游单位方向向量 $\\mathbf{v} = (0,0,1)$。\n    - 使用与测试用例1相同的搜索域和网格步长。\n\n输出规范：\n- 对于每个测试用例，输出以度为单位的估计偏航角 $\\theta_{\\text{est}}$、以度为单位的估计俯仰角 $\\psi_{\\text{est}}$，以及为指定的 $\\mathbf{v}$、真实平面与估计平面计算出的下游方向误差角（以度为单位）。\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表，列表被方括号括起。每个测试用例对应一个包含三个浮点数的子列表，这些浮点数以度为单位，四舍五入到三位小数，顺序为 $[\\theta_{\\text{est}},\\psi_{\\text{est}},\\text{orientation\\_error}]$。例如，最后一行应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，不含任何额外文本。",
            "solution": "中矢状面的估计以及错误估计向下游方向误差的传播，源自三维欧几里得空间的核心几何原理。\n\n首先，我们形式化由对称性驱动的平面估计。考虑一个过原点、单位法向量为 $\\mathbf{n} \\in \\mathbb{R}^3$ 的平面，以及双侧标志点 $\\{\\mathbf{L}_i\\}$ 和 $\\{\\mathbf{R}_i\\}$。关于该平面的反射将任意向量 $\\mathbf{x}$ 映射为\n$$\n\\mathbf{x}' = \\mathbf{x} - 2(\\mathbf{n} \\cdot \\mathbf{x}) \\mathbf{n},\n$$\n这直接来自于将 $\\mathbf{x}$ 分解为平行于平面和垂直于平面的分量。具体来说，记 $\\mathbf{x} = \\mathbf{x}_{\\parallel} + \\mathbf{x}_{\\perp}$，其中 $\\mathbf{x}_{\\perp} = (\\mathbf{n} \\cdot \\mathbf{x}) \\mathbf{n}$ 且 $\\mathbf{x}_{\\parallel} = \\mathbf{x} - (\\mathbf{n} \\cdot \\mathbf{x}) \\mathbf{n}$。反射会反转垂直分量而保持平行分量不变，得到 $\\mathbf{x}' = \\mathbf{x}_{\\parallel} - \\mathbf{x}_{\\perp} = \\mathbf{x} - 2(\\mathbf{n} \\cdot \\mathbf{x}) \\mathbf{n}$。\n\n在完美的双侧对称情况下，将一个左侧标志点关于真实中矢状面进行反射，会得到相应的右侧标志点，反之亦然。对于一个候选法向量 $\\mathbf{n}$，定义残差\n$$\nD(\\mathbf{n}) = \\sum_i \\left\\| \\left( \\mathbf{L}_i - 2(\\mathbf{n} \\cdot \\mathbf{L}_i)\\mathbf{n} \\right) - \\mathbf{R}_i \\right\\|^2 + \\sum_i \\left\\| \\left( \\mathbf{R}_i - 2(\\mathbf{n} \\cdot \\mathbf{R}_i)\\mathbf{n} \\right) - \\mathbf{L}_i \\right\\|^2.\n$$\n估计的中矢状面法向量 $\\mathbf{n}_{\\text{est}}$ 是在受限搜索空间内使 $D(\\mathbf{n})$ 最小化的单位向量。由于平面的法向量没有方向性，$\\mathbf{n}$ 和 $-\\mathbf{n}$ 代表同一个平面。为了与解剖学上的左右轴方向保持一致，我们强制要求 $\\mathbf{n} \\cdot \\mathbf{e}_x \\ge 0$，其中 $\\mathbf{e}_x = (1,0,0)$。\n\n为参数化候选法向量，我们从 $\\mathbf{e}_x$ 开始，先施加绕 $z$ 轴的偏航角 $\\theta$，再施加绕 $y$ 轴的俯仰角 $\\psi$。这些旋转由经过充分测试的轴旋转矩阵表示。绕 $z$ 轴旋转角度 $\\theta$ 的旋转矩阵为\n$$\n\\mathbf{R}_z(\\theta) =\n\\begin{pmatrix}\n\\cos \\theta  -\\sin \\theta  0 \\\\\n\\sin \\theta  \\cos \\theta  0 \\\\\n0  0  1\n\\end{pmatrix},\n$$\n绕 $y$ 轴旋转角度 $\\psi$ 的旋转矩阵为\n$$\n\\mathbf{R}_y(\\psi) =\n\\begin{pmatrix}\n\\cos \\psi  0  \\sin \\psi \\\\\n0  1  0 \\\\\n- \\sin \\psi  0  \\cos \\psi\n\\end{pmatrix}.\n$$\n先应用偏航再应用俯仰，得到候选法向量\n$$\n\\mathbf{n}(\\theta,\\psi) = \\mathbf{R}_y(\\psi)\\,\\mathbf{R}_z(\\theta)\\,\\mathbf{e}_x.\n$$\n我们在 $\\theta \\in [-20,20]$ 度和 $\\psi \\in [-20,20]$ 度的范围内，以 $0.5$ 度为步长进行网格搜索，计算 $D(\\mathbf{n}(\\theta,\\psi))$，并选择使其最小化的 $(\\theta_{\\text{est}}, \\psi_{\\text{est}})$。相关的 $\\mathbf{n}_{\\text{est}}$ 会被归一化（由于旋转矩阵的性质，它已经是单位长度了）并进行符号校正，以保证 $\\mathbf{n}_{\\text{est}} \\cdot \\mathbf{e}_x \\ge 0$。\n\n接下来，我们量化方向误差向下游单位方向向量 $\\mathbf{v}$ 的传播。正确的对齐使用真实法向量 $\\mathbf{n}_{\\text{true}}$，以及将 $\\mathbf{n}_{\\text{true}}$ 映射到 $\\mathbf{e}_x$ 的最小角度旋转。估计的对齐则使用从 $\\mathbf{n}_{\\text{est}}$ 到 $\\mathbf{e}_x$ 的类似旋转。设 $\\mathbf{a}$ 是一个待对齐的单位向量，$\\mathbf{u}$ 是单位源轴，$\\mathbf{w}$ 是单位目标轴。将 $\\mathbf{u}$ 映射到 $\\mathbf{w}$ 的最小旋转是绕单位轴旋转，旋转角度为\n$$\n\\alpha = \\arccos\\left( \\max\\left(-1, \\min\\left(1, \\mathbf{u} \\cdot \\mathbf{w} \\right) \\right) \\right),\n$$\n旋转轴为单位轴\n$$\n\\mathbf{k} = \\frac{\\mathbf{u} \\times \\mathbf{w}}{\\|\\mathbf{u} \\times \\mathbf{w}\\|},\n$$\n此情况在 $\\|\\mathbf{u} \\times \\mathbf{w}\\| \\ne 0$ 时成立；如果 $\\|\\mathbf{u} \\times \\mathbf{w}\\| = 0$，则要么 $\\mathbf{u} = \\mathbf{w}$（单位旋转），要么 $\\mathbf{u} = -\\mathbf{w}$（绕任何与 $\\mathbf{u}$ 正交的轴旋转 $\\pi$）。我们通过在必要时翻转法向量的符号，使得 $\\mathbf{n}_{\\text{true}}$ 和 $\\mathbf{n}_{\\text{est}}$ 都满足 $\\mathbf{n} \\cdot \\mathbf{e}_x \\ge 0$，从而避免了这种模糊的 $\\pi$ 旋转情况。一个向量 $\\mathbf{a}$ 绕轴 $\\mathbf{k}$ 旋转角度 $\\alpha$ 的结果可由罗德里格斯旋转公式 (Rodrigues rotation formula) 得到：\n$$\n\\mathbf{R}(\\mathbf{k},\\alpha)\\,\\mathbf{a} = \\mathbf{a}\\cos\\alpha + (\\mathbf{k} \\times \\mathbf{a})\\sin\\alpha + \\mathbf{k}(\\mathbf{k} \\cdot \\mathbf{a})(1-\\cos\\alpha).\n$$\n因此，\n- 正确对齐的下游向量是 $\\mathbf{v}_{\\text{true}} = \\mathbf{R}(\\mathbf{k}_{\\text{true}},\\alpha_{\\text{true}})\\,\\mathbf{v}$，其中 $\\mathbf{k}_{\\text{true}}$ 和 $\\alpha_{\\text{true}}$ 是根据 $\\mathbf{u}=\\mathbf{n}_{\\text{true}}$ 和 $\\mathbf{w}=\\mathbf{e}_x$ 计算得出的。\n- 估计对齐的下游向量是 $\\mathbf{v}_{\\text{est}} = \\mathbf{R}(\\mathbf{k}_{\\text{est}},\\alpha_{\\text{est}})\\,\\mathbf{v}$，类似地使用 $\\mathbf{n}_{\\text{est}}$。\n\n方向误差是 $\\mathbf{v}_{\\text{true}}$ 和 $\\mathbf{v}_{\\text{est}}$ 之间的夹角：\n$$\n\\beta = \\arccos\\left( \\max\\left(-1, \\min\\left(1, \\frac{\\mathbf{v}_{\\text{true}} \\cdot \\mathbf{v}_{\\text{est}}}{\\|\\mathbf{v}_{\\text{true}}\\| \\|\\mathbf{v}_{\\text{est}}\\|} \\right) \\right) \\right),\n$$\n以度表示。我们在应用旋转之前将 $\\mathbf{v}$ 归一化为单位长度，以确保比较是纯方向性的。\n\n算法流程：\n1. 对于每个测试用例，按规定构造 $\\{\\mathbf{L}_i\\}$ 和 $\\{\\mathbf{R}_i\\}$。当需要旋转时（测试用例2和测试用例4），分别对所有标志点应用 $\\mathbf{R}_z(\\theta_{\\text{true}})$ 或 $\\mathbf{R}_y(\\psi_{\\text{true}})$。计算真实法向量 $\\mathbf{n}_{\\text{true}} = \\mathbf{R}_y(\\psi_{\\text{true}})\\,\\mathbf{R}_z(\\theta_{\\text{true}})\\,\\mathbf{e}_x$，并在必要时翻转其符号以满足 $\\mathbf{n}_{\\text{true}} \\cdot \\mathbf{e}_x \\ge 0$。\n2. 在 $(\\theta,\\psi)$ 上进行网格搜索以最小化 $D(\\mathbf{n}(\\theta,\\psi))$，并记录最小化时的角度 $(\\theta_{\\text{est}},\\psi_{\\text{est}})$ 和相应的 $\\mathbf{n}_{\\text{est}}$（强制其与 $\\mathbf{e}_x$ 的点积为非负）。\n3. 归一化下游向量 $\\mathbf{v}$，计算从 $\\mathbf{n}_{\\text{true}}$ 和 $\\mathbf{n}_{\\text{est}}$ 到 $\\mathbf{e}_x$ 的对齐旋转，将它们应用于 $\\mathbf{v}$ 以获得 $\\mathbf{v}_{\\text{true}}$ 和 $\\mathbf{v}_{\\text{est}}$，并计算 $\\beta$（以度为单位）。\n4. 对每个测试用例，报告 $[\\theta_{\\text{est}},\\psi_{\\text{est}},\\beta]$，四舍五入到三位小数。\n\n科学真实性和边界情况：\n- 测试用例1代表一个理想的对称场景，应得到 $\\theta_{\\text{est}} \\approx 0$ 和 $\\psi_{\\text{est}} \\approx 0$ 以及可忽略的方向误差。\n- 测试用例2引入一个已知的偏航；算法应恢复一个接近 $10$ 度的角，并且如果估计值偏离真实值，对于给定的 $\\mathbf{v}$ 将显示一个非零的方向误差。\n- 测试用例3的标志点在原点附近且有轻微不对称；残差曲面可能很平坦，揭示了敏感性和可能的估计抖动。方向误差量化了其实际影响。\n- 测试用例4引入俯仰；算法应恢复一个接近 $-15$ 度的角。\n\n输出为单行，包含四个子列表，每个测试用例一个，每个子列表包含三个以度为单位、四舍五入到三位小数的浮点数，格式为 $[[\\theta_{\\text{est}},\\psi_{\\text{est}},\\beta],\\dots]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rot_z(theta_deg: float) -> np.ndarray:\n    \"\"\"Rotation matrix for yaw about z-axis by theta_deg degrees.\"\"\"\n    t = np.deg2rad(theta_deg)\n    c, s = np.cos(t), np.sin(t)\n    return np.array([[c, -s, 0.0],\n                     [s,  c, 0.0],\n                     [0.0, 0.0, 1.0]])\n\ndef rot_y(psi_deg: float) -> np.ndarray:\n    \"\"\"Rotation matrix for pitch about y-axis by psi_deg degrees.\"\"\"\n    t = np.deg2rad(psi_deg)\n    c, s = np.cos(t), np.sin(t)\n    return np.array([[ c, 0.0,  s],\n                     [0.0, 1.0, 0.0],\n                     [-s, 0.0,  c]])\n\ndef reflect_point(x: np.ndarray, n: np.ndarray) -> np.ndarray:\n    \"\"\"Reflect point x across plane through origin with unit normal n.\"\"\"\n    return x - 2.0 * np.dot(n, x) * n\n\ndef symmetry_residual(n: np.ndarray, L_points: np.ndarray, R_points: np.ndarray) -> float:\n    \"\"\"Sum of squared distances between reflected left to right and reflected right to left.\"\"\"\n    # Reflect left points and compare to right\n    res1 = R_points - np.array([reflect_point(p, n) for p in L_points])\n    # Reflect right points and compare to left\n    res2 = L_points - np.array([reflect_point(p, n) for p in R_points])\n    return float(np.sum(res1**2) + np.sum(res2**2))\n\ndef estimate_normal_grid(L_points: np.ndarray, R_points: np.ndarray,\n                         yaw_range=(-20.0, 20.0), pitch_range=(-20.0, 20.0),\n                         step=0.5):\n    \"\"\"Grid search over yaw (theta) and pitch (psi) to minimize symmetry residual.\"\"\"\n    ex = np.array([1.0, 0.0, 0.0])\n    best_cost = np.inf\n    best_theta = 0.0\n    best_psi = 0.0\n    best_n = ex.copy()\n    # Create ranges inclusive\n    yaw_vals = np.arange(yaw_range[0], yaw_range[1] + 1e-9, step)\n    pitch_vals = np.arange(pitch_range[0], pitch_range[1] + 1e-9, step)\n    for psi in pitch_vals:\n        Ry = rot_y(psi)\n        for theta in yaw_vals:\n            Rz = rot_z(theta)\n            n = Ry @ (Rz @ ex)\n            # Enforce nonnegative dot with ex to break sign ambiguity\n            if np.dot(n, ex) < 0:\n                n = -n\n            cost = symmetry_residual(n, L_points, R_points)\n            if cost < best_cost:\n                best_cost = cost\n                best_theta = float(theta)\n                best_psi = float(psi)\n                best_n = n\n    return best_theta, best_psi, best_n\n\ndef align_rotation_to_x(n: np.ndarray) -> np.ndarray:\n    \"\"\"Compute rotation matrix that minimally rotates unit vector n to ex = (1,0,0).\"\"\"\n    ex = np.array([1.0, 0.0, 0.0])\n    n = n / np.linalg.norm(n)\n    # Flip sign to avoid 180-degree ambiguity\n    if np.dot(n, ex) < 0:\n        n = -n\n    # Axis and angle\n    k = np.cross(n, ex)\n    s = np.linalg.norm(k)\n    c = float(np.clip(np.dot(n, ex), -1.0, 1.0))\n    if s < 1e-12:\n        # n is parallel to ex -> either identity or 180 deg; due to flip above, c>=0 so identity or near-identity\n        return np.eye(3)\n    k_unit = k / s\n    alpha = float(np.arccos(c))\n    Kx = np.array([[0.0,       -k_unit[2],  k_unit[1]],\n                   [k_unit[2],  0.0,       -k_unit[0]],\n                   [-k_unit[1], k_unit[0],  0.0      ]])\n    I = np.eye(3)\n    # Rodrigues formula\n    R = I * np.cos(alpha) + Kx * np.sin(alpha) + np.outer(k_unit, k_unit) * (1.0 - np.cos(alpha))\n    return R\n\ndef normalize(v: np.ndarray) -> np.ndarray:\n    n = np.linalg.norm(v)\n    if n == 0:\n        return v.copy()\n    return v / n\n\ndef construct_test_cases():\n    # Base symmetric landmarks\n    L0 = np.array([\n        [-50.0,  0.0,   0.0],\n        [-40.0, 20.0,  10.0],\n        [-30.0,-15.0,  30.0],\n        [-45.0,  5.0, -25.0],\n    ])\n    R0 = np.array([\n        [ 50.0,  0.0,   0.0],\n        [ 40.0, 20.0,  10.0],\n        [ 30.0,-15.0,  30.0],\n        [ 45.0,  5.0, -25.0],\n    ])\n    # Test Case 1: identity\n    tc1 = {\n        \"L\": L0.copy(),\n        \"R\": R0.copy(),\n        \"theta_true\": 0.0,\n        \"psi_true\": 0.0,\n        \"v\": np.array([0.0, 1.0, 0.0])\n    }\n    # Test Case 2: yaw +10 deg\n    theta2 = 10.0\n    Rz2 = rot_z(theta2)\n    L2 = (Rz2 @ L0.T).T\n    R2 = (Rz2 @ R0.T).T\n    tc2 = {\n        \"L\": L2,\n        \"R\": R2,\n        \"theta_true\": theta2,\n        \"psi_true\": 0.0,\n        \"v\": np.array([0.0, 1.0, 0.0])\n    }\n    # Test Case 3: small-magnitude, slight asymmetry\n    L3 = np.array([\n        [-5.0,   1.0,   0.5 ],\n        [-4.0,  -1.0,   0.2 ],\n        [-6.0,   0.5,  -0.4 ],\n        [-5.5,  -0.2,   0.1 ],\n    ])\n    R3 = np.array([\n        [ 5.0,   1.1,   0.55],\n        [ 4.0,  -0.9,   0.25],\n        [ 6.0,   0.45, -0.35],\n        [ 5.5,  -0.15,  0.05],\n    ])\n    tc3 = {\n        \"L\": L3,\n        \"R\": R3,\n        \"theta_true\": 0.0,\n        \"psi_true\": 0.0,\n        \"v\": normalize(np.array([0.3, 0.8, 0.5]))\n    }\n    # Test Case 4: pitch -15 deg\n    psi4 = -15.0\n    Ry4 = rot_y(psi4)\n    L4 = (Ry4 @ L0.T).T\n    R4 = (Ry4 @ R0.T).T\n    tc4 = {\n        \"L\": L4,\n        \"R\": R4,\n        \"theta_true\": 0.0,\n        \"psi_true\": psi4,\n        \"v\": np.array([0.0, 0.0, 1.0])\n    }\n    return [tc1, tc2, tc3, tc4]\n\ndef true_normal(theta_true: float, psi_true: float) -> np.ndarray:\n    ex = np.array([1.0, 0.0, 0.0])\n    n_true = rot_y(psi_true) @ (rot_z(theta_true) @ ex)\n    # Enforce nonnegative dot with ex\n    if np.dot(n_true, ex) < 0:\n        n_true = -n_true\n    return n_true\n\ndef orientation_error_deg(n_true: np.ndarray, n_est: np.ndarray, v: np.ndarray) -> float:\n    \"\"\"Compute orientation error between correctly and incorrectly aligned downstream vector v.\"\"\"\n    R_true = align_rotation_to_x(n_true)\n    R_est = align_rotation_to_x(n_est)\n    v_unit = normalize(v)\n    v_true = R_true @ v_unit\n    v_est = R_est @ v_unit\n    # Angle between v_true and v_est\n    num = float(np.dot(v_true, v_est))\n    den = float(np.linalg.norm(v_true) * np.linalg.norm(v_est))\n    if den == 0.0:\n        # Should not occur with proper rotations and nonzero v\n        return 0.0\n    cosang = max(-1.0, min(1.0, num / den))\n    ang_rad = float(np.arccos(cosang))\n    return np.rad2deg(ang_rad)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = construct_test_cases()\n\n    results = []\n    for tc in test_cases:\n        L = tc[\"L\"]\n        R = tc[\"R\"]\n        theta_true = tc[\"theta_true\"]\n        psi_true = tc[\"psi_true\"]\n        v = tc[\"v\"]\n        # Estimate normal via grid search\n        theta_est, psi_est, n_est = estimate_normal_grid(L, R,\n                                                         yaw_range=(-20.0, 20.0),\n                                                         pitch_range=(-20.0, 20.0),\n                                                         step=0.5)\n        # True normal from parameters\n        n_true = true_normal(theta_true, psi_true)\n        # Orientation error\n        err_deg = orientation_error_deg(n_true, n_est, v)\n        # Round to three decimals for output\n        results.append([theta_est, psi_est, err_deg])\n\n    # Format the final output: nested list with floats rounded to three decimals\n    formatted = []\n    for triple in results:\n        formatted.append(\"[\" + \",\".join(f\"{x:.3f}\" for x in triple) + \"]\")\n    print(\"[\" + \",\".join(formatted) + \"]\")\n\nsolve()\n```"
        }
    ]
}