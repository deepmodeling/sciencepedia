{
    "hands_on_practices": [
        {
            "introduction": "Medical images are typically acquired slice by slice. To build an accurate three-dimensional volume, we must understand the precise geometric relationship between these slices. This first exercise  addresses a common issue in computed tomography (CT) known as gantry tilt. You will learn to use the standardized DICOM metadata to detect this acquisition artifact and subsequently compute a shear-corrected orientation matrix, a crucial step in transforming a skewed stack of slices into a geometrically sound, orthogonal volume ready for analysis.",
            "id": "4894114",
            "problem": "You are to implement a complete, runnable program that detects gantry tilt in computed tomography (CT) using Digital Imaging and Communications in Medicine (DICOM) metadata and computes a shear-corrected orientation matrix to ensure reconstructed volumes have orthogonal slices. The program must produce results for a predefined test suite without requiring any external input.\n\nFundamental base and definitions to be used:\n- Digital Imaging and Communications in Medicine (DICOM) provides per-slice metadata including Image Orientation (Patient) and Image Position (Patient).\n- Let the Image Orientation (Patient) be given by two unit vectors: the row direction vector $r \\in \\mathbb{R}^3$ and the column direction vector $c \\in \\mathbb{R}^3$. The slice normal vector is $n = r \\times c$, where $\\times$ denotes the vector cross product.\n- Let the $k$-th slice’s Image Position (Patient) be $p_k \\in \\mathbb{R}^3$, and define the inter-slice translation vector $\\Delta p_k = p_{k+1} - p_k$ for consecutive slices.\n- Pixel Spacing is given by two positive real numbers: $\\Delta_r$ (row spacing, in mm) and $\\Delta_c$ (column spacing, in mm). All geometric quantities are in millimeters (mm).\n- The orthonormality of $r$ and $c$ implies $r \\cdot r = 1$, $c \\cdot c = 1$, and $r \\cdot c = 0$, where $\\cdot$ denotes the dot product.\n\nScientific rationale:\n- In the absence of gantry tilt, the inter-slice translation $\\Delta p_k$ has no in-plane components along $r$ or $c$, and lies purely along $n$, so $\\Delta p_k \\approx s_k n$ for some scalar $s_k \\in \\mathbb{R}$. With gantry tilt, $\\Delta p_k$ acquires in-plane components, i.e., it can be decomposed as $\\Delta p_k = a_k r + b_k c + s_k n$, where $a_k$ and $b_k$ are nonzero.\n- The tilt angle $\\theta$ can be quantified from the ratio of in-plane motion magnitude to through-plane motion magnitude. Define $a_k = \\Delta p_k \\cdot r$, $b_k = \\Delta p_k \\cdot c$, and $s_k = \\Delta p_k \\cdot n$. Robust summary values $a$, $b$, and $s$ are computed as the medians of $\\{a_k\\}$, $\\{b_k\\}$, and $\\{s_k\\}$ across slices. The in-plane magnitude is $m = \\sqrt{a^2 + b^2}$, and the tilt angle is $\\theta = \\arctan2(m, |s|)$.\n- The shear-corrected orientation matrix defines the volume's voxel geometry. The first column corresponds to a step along the row direction (vector $r$, scaled by row spacing $\\Delta_r$), the second to a step along the column direction (vector $c$, scaled by column spacing $\\Delta_c$), and the third to the inter-slice direction (vector $n$, scaled by the effective spacing $|s|$). The $3 \\times 3$ orientation matrix $M$ is thus $M = [r \\, \\Delta_r,\\; c \\, \\Delta_c,\\; n \\, |s|]$.\n\nTask requirements:\n1. Implement a function that, given $r$, $c$, a list of slice positions $\\{p_k\\}$, and pixel spacings $(\\Delta_r, \\Delta_c)$:\n   - Computes $n = r \\times c$.\n   - Computes $\\Delta p_k = p_{k+1} - p_k$ for all consecutive slices.\n   - Computes $a_k = \\Delta p_k \\cdot r$, $b_k = \\Delta p_k \\cdot c$, and $s_k = \\Delta p_k \\cdot n$.\n   - Uses medians $a$, $b$, and $s$ across slices.\n   - Computes the tilt angle $\\theta = \\arctan2(\\sqrt{a^2 + b^2}, |s|)$ in degrees.\n   - Detects tilt if $\\theta \\ge \\theta_{\\text{thr}}$ with threshold $\\theta_{\\text{thr}} = 0.5$ degrees.\n   - Computes the shear-corrected orientation matrix $M = [r \\, \\Delta_r,\\; c \\, \\Delta_c,\\; n \\, |s|]$.\n2. Angles must be expressed in degrees. Distances must be in millimeters (mm). The tilt angle in the output must be rounded to six decimal places.\n\nTest suite:\nProvide the following test cases directly inside your program. For each case, the program must construct the list of slice positions $\\{p_k\\}$ using the specified $r$, $c$, $n$, an initial position $p_0$, a slice spacing $s$ along $n$, and any in-plane component that simulates tilt. Use $N$ slices indexed $k = 0, 1, \\dots, N-1$ with\n$$\np_k = p_0 + k \\, (s \\, n + t_r \\, r + t_c \\, c),\n$$\nwhere $t_r$ and $t_c$ are the per-slice in-plane shifts (in mm) along $r$ and $c$. If a case has no tilt, then $t_r = 0$ and $t_c = 0$. If a case specifies a tilt angle $\\theta$ about an in-plane axis, set the corresponding in-plane shift to $t = s \\, \\tan(\\theta)$ along that axis.\n\n- Case $1$ (happy path, no tilt):\n  - $r = [1, 0, 0]$, $c = [0, 1, 0]$, $\\Delta_r = 0.8$ mm, $\\Delta_c = 0.8$ mm, $s = 1.5$ mm, $p_0 = [0, 0, 0]$, $N = 5$, $t_r = 0$, $t_c = 0$.\n- Case $2$ (gantry tilt along $c$):\n  - $r = [1, 0, 0]$, $c = [0, 1, 0]$, $\\Delta_r = 0.7$ mm, $\\Delta_c = 0.7$ mm, $s = 1.2$ mm, $\\theta = 15$ degrees, $p_0 = [0, 0, 0]$, $N = 5$, $t_r = 0$, $t_c = s \\, \\tan(\\theta)$.\n- Case $3$ (gantry tilt along $r$):\n  - $r = [1, 0, 0]$, $c = [0, 1, 0]$, $\\Delta_r = 0.5$ mm, $\\Delta_c = 0.5$ mm, $s = 1.0$ mm, $\\theta = 10$ degrees, $p_0 = [0, 0, 0]$, $N = 6$, $t_r = s \\, \\tan(\\theta)$, $t_c = 0$.\n- Case $4$ (very small tilt below detection threshold):\n  - $r = [1, 0, 0]$, $c = [0, 1, 0]$, $\\Delta_r = 0.9$ mm, $\\Delta_c = 0.9$ mm, $s = 2.0$ mm, $\\theta = 0.2$ degrees, $p_0 = [0, 0, 0]$, $N = 5$, $t_r = 0$, $t_c = s \\, \\tan(\\theta)$.\n- Case $5$ (oblique orientation, no gantry tilt):\n  - $r = [1/\\sqrt{2}, 1/\\sqrt{2}, 0]$, $c = [0, 0, 1]$, $\\Delta_r = 1.0$ mm, $\\Delta_c = 1.0$ mm, $s = 1.0$ mm, $p_0 = [10, 20, 30]$, $N = 4$, $t_r = 0$, $t_c = 0$.\n\nOutput specification:\n- For each test case, output a three-element list: $[\\text{tilt\\_detected}, \\theta, \\text{flattened\\_matrix}]$, where $\\text{tilt\\_detected}$ is a boolean, $\\theta$ is the tilt angle in degrees rounded to six decimal places, and $\\text{flattened\\_matrix}$ is the shear-corrected $3 \\times 3$ orientation matrix $M$ flattened in column-major order as a list of $9$ floats rounded to six decimal places.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, for example:\n$[[$\\text{case1\\_result}$],[$\\text{case2\\_result}$],\\dots]$.\n\nAngle unit requirement:\n- Angles must be computed and printed in degrees.\n\nDistance unit requirement:\n- All lengths and spacings are in millimeters (mm).\n\nDesign constraints:\n- Use only linear algebra definitions (dot product, cross product), normalization, and vector decomposition; do not use any shortcut formulas beyond those defined.\n- Ensure numerical robustness by normalizing $r$ and $c$, re-orthogonalizing $c$ against $r$ if needed, and normalizing $n$.",
            "solution": "The user-provided problem has been rigorously validated and is determined to be a valid, well-posed scientific programming task. It is scientifically grounded in the principles of medical imaging and linear algebra, contains a complete and consistent setup, and defines a clear, verifiable objective.\n\n### Principle-Based Solution Design\n\nThe solution involves developing an algorithm to detect gantry tilt in Computed Tomography (CT) data and to compute a corresponding shear-corrected orientation matrix. The approach is based on fundamental principles of vector algebra and coordinate transformations as they apply to DICOM (Digital Imaging and Communications in Medicine) standards.\n\n#### 1. Coordinate System Definition and Normalization\n\nA CT image slice is defined in a 3D patient coordinate system by a set of vectors provided in the DICOM metadata. These are the row direction vector $r \\in \\mathbb{R}^3$ and the column direction vector $c \\in \\mathbb{R}^3$. For a valid slice geometry, these vectors must be orthonormal, i.e., they are unit vectors and are perpendicular to each other ($r \\cdot c = 0$).\n\nThe third basis vector, the slice normal $n \\in \\mathbb{R}^3$, is computed using the vector cross product:\n$$n = r \\times c$$\nIf $r$ and $c$ are orthonormal, $n$ will also be a unit vector, and the set $\\{r, c, n\\}$ forms a right-handed orthonormal basis.\n\nFor numerical robustness, the implementation will explicitly enforce these properties. The input vectors $r$ and $c$ will be normalized. Subsequently, $c$ will be re-orthogonalized with respect to $r$ using the Gram-Schmidt process, and then re-normalized. This ensures that the basis used for all subsequent calculations is perfectly orthonormal, protecting against potential floating-point inaccuracies.\n$$r_{\\text{norm}} = \\frac{r}{\\|r\\|}$$\n$$c_{\\text{ortho}} = c - (c \\cdot r_{\\text{norm}}) r_{\\text{norm}}$$\n$$c_{\\text{norm}} = \\frac{c_{\\text{ortho}}}{\\|c_{\\text{ortho}}\\|}$$\n$$n = r_{\\text{norm}} \\times c_{\\text{norm}}$$\n\n#### 2. Analysis of Inter-Slice Motion\n\nThe position of each slice in the patient coordinate system is given by the Image Position (Patient) tag, which we denote as a vector $p_k \\in \\mathbb{R}^3$ for the $k$-th slice. The geometric relationship between consecutive slices is described by the inter-slice translation vector, $\\Delta p_k$:\n$$\\Delta p_k = p_{k+1} - p_k$$\nIn an ideal acquisition without gantry tilt, the scanner moves perfectly perpendicularly to the slice plane. Therefore, the translation vector $\\Delta p_k$ should be parallel to the slice normal $n$:\n$$\\Delta p_k \\approx s_k n$$\nwhere $s_k$ is the distance moved, i.e., the slice thickness or spacing.\n\nWhen gantry tilt is present, the translation between slices includes components within the slice plane (in-plane motion). The vector $\\Delta p_k$ can be decomposed into its components along the basis vectors $r$, $c$, and $n$:\n$$\\Delta p_k = a_k r + b_k c + s_k n$$\nThe scalar components are found by projecting $\\Delta p_k$ onto each basis vector using the dot product:\n$$a_k = \\Delta p_k \\cdot r \\quad (\\text{in-plane component along row direction})$$\n$$b_k = \\Delta p_k \\cdot c \\quad (\\text{in-plane component along column direction})$$\n$$s_k = \\Delta p_k \\cdot n \\quad (\\text{through-plane component})$$\nNon-zero values for $a_k$ or $b_k$ indicate the presence of gantry tilt.\n\n#### 3. Robust Tilt Quantification\n\nIn real-world data, slice positions can have minor variations. To obtain a single, robust measure of tilt for the entire series, the problem specifies using the median of the component values across all slices. Let $a$, $b$, and $s$ be the respective medians of the sets $\\{a_k\\}$, $\\{b_k\\}$, and $\\{s_k\\}$.\n\nThe magnitude of the average in-plane shift, $m$, is given by:\n$$m = \\sqrt{a^2 + b^2}$$\nThe tilt angle, $\\theta$, is the angle between the actual inter-slice motion vector and the slice normal. It can be calculated from the ratio of the in-plane motion magnitude to the through-plane motion magnitude:\n$$\\theta = \\arctan2(m, |s|)$$\nThe result is converted from radians to degrees. A tilt is formally detected if this angle exceeds a specified threshold, $\\theta_{\\text{thr}} = 0.5^\\circ$.\n\n#### 4. Shear-Corrected Orientation Matrix\n\nTo ensure that the reconstructed 3D volume has orthogonal slices, a new orientation matrix $M$ is computed. This matrix defines the geometry of the volume's voxels. The matrix is constructed from three column vectors which represent the displacement in the patient coordinate system corresponding to a one-voxel step along each axis of the image grid.\n\nFollowing standard DICOM conventions and the corrected problem statement:\n- The first column corresponds to a step along the image's row direction, scaling the row vector $r$ by the row pixel spacing $\\Delta_r$.\n- The second column corresponds to a step along the image's column direction, scaling the column vector $c$ by the column pixel spacing $\\Delta_c$.\n- The third column, representing the \"slice axis,\" scales the normal vector $n$ by the magnitude of the median through-plane spacing, $|s|$.\n\nThe final shear-corrected orientation matrix $M$ is:\n$$M = \\begin{bmatrix} | & | & | \\\\ r\\Delta_r & c\\Delta_c & n|s| \\\\ | & | & | \\end{bmatrix} = \\begin{pmatrix} r_x \\Delta_r & c_x \\Delta_c & n_x |s| \\\\ r_y \\Delta_r & c_y \\Delta_c & n_y |s| \\\\ r_z \\Delta_r & c_z \\Delta_c & n_z |s| \\end{pmatrix}$$\nThe program will flatten this $3 \\times 3$ matrix into a $9$-element list in column-major order for the final output.\n\n#### 5. Test Case Simulation\n\nThe test suite is generated programmatically. For each case, a series of $N$ slice positions $\\{p_k\\}_{k=0}^{N-1}$ is created using the formula:\n$$p_k = p_0 + k \\, (s_{\\text{spacing}} \\, n + t_r \\, r + t_c \\, c)$$\nwhere $p_0$ is the initial position, $s_{\\text{spacing}}$ is the nominal slice spacing, and $t_r$ and $t_c$ are user-specified in-plane shifts that simulate gantry tilt. If a tilt angle $\\theta_{\\text{in}}$ is specified for a test case, the corresponding in-plane shift is calculated as $t = s_{\\text{spacing}} \\cdot \\tan(\\theta_{\\text{in}})$. This model ensures that the inter-slice vector $\\Delta p_k$ is constant for all slices within a test case, providing a clean scenario for validating the algorithm's correctness.\n\nThe implementation will wrap this entire logic into a Python program, using the `numpy` library for efficient and accurate vector and matrix operations, and will format the output exactly as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analyze_ct_series(r, c, slice_positions, delta_r, delta_c, theta_thr):\n    \"\"\"\n    Analyzes a series of CT slices to detect gantry tilt and compute a\n    shear-corrected orientation matrix.\n\n    Args:\n        r (np.ndarray): The row direction vector (3,).\n        c (np.ndarray): The column direction vector (3,).\n        slice_positions (list[np.ndarray]): A list of slice position vectors.\n        delta_r (float): The row pixel spacing (in-plane, along r).\n        delta_c (float): The column pixel spacing (in-plane, along c).\n        theta_thr (float): The tilt detection threshold in degrees.\n\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if tilt is detected, False otherwise.\n            - float: The computed tilt angle in degrees.\n            - np.ndarray: The 3x3 shear-corrected orientation matrix.\n    \"\"\"\n    # 1. Ensure orthonormal basis {r, c, n} for robustness.\n    # Normalize r\n    r = r / np.linalg.norm(r)\n    # Re-orthogonalize c with respect to r (Gram-Schmidt) and normalize\n    c = c - np.dot(c, r) * r\n    c = c / np.linalg.norm(c)\n    # Compute the normal vector n\n    n = np.cross(r, c)\n    # n should be a unit vector, but normalize for safety\n    n = n / np.linalg.norm(n)\n\n    # 2. Compute inter-slice translation vectors\n    if len(slice_positions) < 2:\n        # Not enough slices to compute motion, assume no tilt.\n        s_median = np.sqrt(delta_r**2 + delta_c**2) # A reasonable default\n        return False, 0.0, np.stack([r * delta_r, c * delta_c, n * s_median], axis=-1)\n\n    delta_p_list = [slice_positions[k + 1] - slice_positions[k] for k in range(len(slice_positions) - 1)]\n\n    # 3. Decompose inter-slice vectors into in-plane and through-plane components\n    a_k = [np.dot(dp, r) for dp in delta_p_list]\n    b_k = [np.dot(dp, c) for dp in delta_p_list]\n    s_k = [np.dot(dp, n) for dp in delta_p_list]\n\n    # 4. Use medians for robust estimation\n    a_median = np.median(a_k)\n    b_median = np.median(b_k)\n    s_median = np.median(s_k)\n\n    # 5. Compute tilt angle\n    in_plane_magnitude = np.sqrt(a_median**2 + b_median**2)\n    # arctan2(y, x) where y is in-plane and x is through-plane component\n    tilt_angle_rad = np.arctan2(in_plane_magnitude, np.abs(s_median))\n    tilt_angle_deg = np.rad2deg(tilt_angle_rad)\n\n    # 6. Detect tilt\n    is_tilted = tilt_angle_deg >= theta_thr\n\n    # 7. Compute the shear-corrected orientation matrix M = [col1, col2, col3]\n    # Corrected formula: col1=r*delta_r, col2=c*delta_c, col3=n*|s_median|\n    col1 = r * delta_r\n    col2 = c * delta_c\n    col3 = n * np.abs(s_median)\n    M = np.stack([col1, col2, col3], axis=-1)\n\n    return is_tilted, tilt_angle_deg, M\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Tilt detection threshold\n    theta_thr = 0.5  # degrees\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, no tilt)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.8, 'delta_c': 0.8, 's': 1.5, 'p0': [0, 0, 0], 'N': 5, 'tilt_deg': 0.0, 'tilt_axis': None},\n        # Case 2 (gantry tilt along c)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.7, 'delta_c': 0.7, 's': 1.2, 'p0': [0, 0, 0], 'N': 5, 'tilt_deg': 15.0, 'tilt_axis': 'c'},\n        # Case 3 (gantry tilt along r)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.5, 'delta_c': 0.5, 's': 1.0, 'p0': [0, 0, 0], 'N': 6, 'tilt_deg': 10.0, 'tilt_axis': 'r'},\n        # Case 4 (very small tilt below detection threshold)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.9, 'delta_c': 0.9, 's': 2.0, 'p0': [0, 0, 0], 'N': 5, 'tilt_deg': 0.2, 'tilt_axis': 'c'},\n        # Case 5 (oblique orientation, no gantry tilt)\n        {'r': [1/np.sqrt(2), 1/np.sqrt(2), 0], 'c': [0, 0, 1], 'delta_r': 1.0, 'delta_c': 1.0, 's': 1.0, 'p0': [10, 20, 30], 'N': 4, 'tilt_deg': 0.0, 'tilt_axis': None},\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        # Prepare inputs for this test case\n        r_vec = np.array(case['r'], dtype=float)\n        c_vec = np.array(case['c'], dtype=float)\n        p0 = np.array(case['p0'], dtype=float)\n        s_spacing = case['s']\n        N = case['N']\n        delta_r = case['delta_r']\n        delta_c = case['delta_c']\n\n        # Normalize basis vectors for generating slice positions\n        r_norm = r_vec / np.linalg.norm(r_vec)\n        c_ortho = c_vec - np.dot(c_vec, r_norm) * r_norm\n        c_norm = c_ortho / np.linalg.norm(c_ortho)\n        n_norm = np.cross(r_norm, c_norm)\n\n        # Calculate in-plane shifts based on tilt angle\n        t_r, t_c = 0.0, 0.0\n        if case['tilt_axis']:\n            tilt_rad = np.deg2rad(case['tilt_deg'])\n            shift = s_spacing * np.tan(tilt_rad)\n            if case['tilt_axis'] == 'r':\n                t_r = shift\n            elif case['tilt_axis'] == 'c':\n                t_c = shift\n        \n        # Generate the list of slice positions\n        # p_k = p_0 + k * (s * n + t_r * r + t_c * c)\n        inter_slice_vec = s_spacing * n_norm + t_r * r_norm + t_c * c_norm\n        slice_positions = [p0 + k * inter_slice_vec for k in range(N)]\n\n        # Analyze the generated slice data\n        is_tilted, angle_deg, matrix = analyze_ct_series(\n            r_vec, c_vec, slice_positions, delta_r, delta_c, theta_thr\n        )\n        \n        # Format the results for this case\n        is_tilted_str = str(is_tilted).lower()\n        angle_str = f\"{angle_deg:.6f}\"\n        matrix_flat_col_major = matrix.flatten('F')\n        matrix_str = \"[\" + \",\".join(f\"{val:.6f}\" for val in matrix_flat_col_major) + \"]\"\n        case_result_str = f\"[{is_tilted_str},{angle_str},{matrix_str}]\"\n        \n        all_results_str.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once a valid 3D volume is constructed, we can begin to identify its internal anatomical structure. A fundamental task in neuroimaging is locating the mid-sagittal plane, the surface that ideally separates the brain into its left and right hemispheres. This practice  guides you through estimating this plane by leveraging the brain's inherent bilateral symmetry. You will implement an optimization algorithm to find the plane of maximum symmetry and quantify how even small estimation errors can propagate and affect the accuracy of subsequent analyses.",
            "id": "4894093",
            "problem": "You are given a three-dimensional coordinate system consistent with standard neuroanatomical convention: the left-right axis is the $x$-axis, the anterior-posterior axis is the $y$-axis, and the superior-inferior axis is the $z$-axis. The mid-sagittal plane is a geometric plane that ideally separates the left and right hemispheres and, in an anatomically aligned image, is the plane through the origin with a unit normal aligned with the positive left-right axis. The logical task is to estimate the mid-sagittal plane from bilateral landmark pairs by exploiting anatomical symmetry, and then quantify how errors in this estimation propagate as orientation errors in downstream vector analyses. Your program must implement the steps below using only vector geometry and the definitions of reflection and rotation in three dimensions.\n\nFundamental base and definitions to use:\n- Use the Euclidean inner product and norm: for any vectors $\\mathbf{a}, \\mathbf{b} \\in \\mathbb{R}^3$, the inner product is $\\mathbf{a} \\cdot \\mathbf{b}$ and the norm is $\\|\\mathbf{a}\\| = \\sqrt{\\mathbf{a} \\cdot \\mathbf{a}}$.\n- A plane through the origin with unit normal $\\mathbf{n}$ admits a reflection operator that maps any point to its mirror across the plane. Use the formal vector definition of reflection across a plane through the origin.\n- Rotations in three dimensions are represented by orthogonal matrices obtained from well-tested rotation constructions. Use the formal definition of rotation matrices about canonical axes and the composition of rotations.\n- The angle $\\alpha$ between nonzero vectors $\\mathbf{u}$ and $\\mathbf{v}$ satisfies $\\cos \\alpha = \\dfrac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\|\\mathbf{v}\\|}$.\n\nAlgorithmic goal:\n1. Given bilateral landmark sets $\\{\\mathbf{L}_i\\}$ (left) and $\\{\\mathbf{R}_i\\}$ (right), estimate the mid-sagittal plane by searching over unit normals parameterized by a yaw angle $\\theta$ (rotation about the $z$-axis) and a pitch angle $\\psi$ (rotation about the $y$-axis), applied to the positive left-right axis. For each candidate unit normal, compute a symmetry residual by reflecting each left landmark across the candidate plane and comparing it to the corresponding right landmark, and vice versa, using a norm-based discrepancy. Select the yaw and pitch that minimize the total residual over all landmark pairs. The plane is constrained to pass through the origin. To eliminate sign ambiguity (since $\\mathbf{n}$ and $-\\mathbf{n}$ represent the same plane), define the estimated unit normal so that its dot product with the positive left-right axis is nonnegative.\n2. For downstream analyses, define the alignment rotation that maps the estimated unit normal to the positive left-right axis with the smallest rotation angle. Apply this alignment rotation to a given downstream unit direction vector $\\mathbf{v}$, and compute the orientation error as the angle, in degrees, between the vector aligned using the true plane and the vector aligned using the estimated plane.\n\nAngle unit requirement:\n- All angles in input parameters and output results must be expressed in degrees. Your program must output angles in degrees rounded to three decimal places.\n\nTest suite:\nImplement the algorithm on the following four test cases. For all test cases, the plane is through the origin.\n\n- Test Case $1$ (happy path, perfectly symmetric, no rotation):\n    - Base bilateral landmarks (left set and right set are exact mirrors across the plane $x=0$):\n        - Left landmarks $\\mathbf{L}_i$: $(-50,0,0)$, $(-40,20,10)$, $(-30,-15,30)$, $(-45,5,-25)$.\n        - Right landmarks $\\mathbf{R}_i$: $(50,0,0)$, $(40,20,10)$, $(30,-15,30)$, $(45,5,-25)$.\n    - True yaw $\\theta_{\\text{true}} = 0$ degrees and true pitch $\\psi_{\\text{true}} = 0$ degrees.\n    - Downstream unit direction vector $\\mathbf{v} = (0,1,0)$.\n    - Search domain for estimation: $\\theta \\in [-20,20]$ degrees and $\\psi \\in [-20,20]$ degrees with a uniform grid step of $0.5$ degrees for both angles.\n\n- Test Case $2$ (yaw rotation about $z$-axis):\n    - Construct the landmarks by rotating the Test Case $1$ left and right sets by $+10$ degrees about the $z$-axis.\n    - True yaw $\\theta_{\\text{true}} = 10$ degrees and true pitch $\\psi_{\\text{true}} = 0$ degrees.\n    - Downstream unit direction vector $\\mathbf{v} = (0,1,0)$.\n    - Use the same search domain and grid step as Test Case $1$.\n\n- Test Case $3$ (edge case, small-magnitude landmarks near the origin with slight asymmetry):\n    - Left landmarks $\\mathbf{L}_i$: $(-5,1,0.5)$, $(-4,-1,0.2)$, $(-6,0.5,-0.4)$, $(-5.5,-0.2,0.1)$.\n    - Right landmarks $\\mathbf{R}_i$: $(5,1.1,0.55)$, $(4,-0.9,0.25)$, $(6,0.45,-0.35)$, $(5.5,-0.15,0.05)$.\n    - True yaw $\\theta_{\\text{true}} = 0$ degrees and true pitch $\\psi_{\\text{true}} = 0$ degrees.\n    - Downstream unit direction vector $\\mathbf{v} = (0.3,0.8,0.5)$.\n    - Use the same search domain and grid step as Test Case $1$.\n\n- Test Case $4$ (pitch rotation about $y$-axis):\n    - Construct the landmarks by rotating the Test Case $1$ left and right sets by $-15$ degrees about the $y$-axis.\n    - True yaw $\\theta_{\\text{true}} = 0$ degrees and true pitch $\\psi_{\\text{true}} = -15$ degrees.\n    - Downstream unit direction vector $\\mathbf{v} = (0,0,1)$.\n    - Use the same search domain and grid step as Test Case $1$.\n\nOutput specification:\n- For each test case, output the estimated yaw $\\theta_{\\text{est}}$ in degrees, the estimated pitch $\\psi_{\\text{est}}$ in degrees, and the downstream orientation error angle in degrees computed for the specified $\\mathbf{v}$ and the true plane versus the estimated plane.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sub-list of three floats in degrees rounded to three decimal places, in the order $[\\theta_{\\text{est}},\\psi_{\\text{est}},\\text{orientation\\_error}]$. For example, the final line should look like $[[\\dots],[\\dots],[\\dots],[\\dots]]$ with no additional text.",
            "solution": "The estimation of the mid-sagittal plane and the propagation of misestimation to downstream orientation errors are derived from core geometric principles in three-dimensional Euclidean space.\n\nFirst, we formalize the symmetry-driven plane estimation. Consider a plane through the origin with unit normal $\\mathbf{n} \\in \\mathbb{R}^3$ and bilateral landmarks $\\{\\mathbf{L}_i\\}$ and $\\{\\mathbf{R}_i\\}$. A plane reflection across this plane maps any vector $\\mathbf{x}$ to\n$$\n\\mathbf{x}' = \\mathbf{x} - 2(\\mathbf{n} \\cdot \\mathbf{x}) \\mathbf{n},\n$$\nwhich follows directly from decomposing $\\mathbf{x}$ into components parallel and orthogonal to the plane. Specifically, write $\\mathbf{x} = \\mathbf{x}_{\\parallel} + \\mathbf{x}_{\\perp}$ where $\\mathbf{x}_{\\perp} = (\\mathbf{n} \\cdot \\mathbf{x}) \\mathbf{n}$ and $\\mathbf{x}_{\\parallel} = \\mathbf{x} - (\\mathbf{n} \\cdot \\mathbf{x}) \\mathbf{n}$. Reflection flips the orthogonal component and leaves the parallel component unchanged, giving $\\mathbf{x}' = \\mathbf{x}_{\\parallel} - \\mathbf{x}_{\\perp} = \\mathbf{x} - 2(\\mathbf{n} \\cdot \\mathbf{x}) \\mathbf{n}$.\n\nUnder perfect bilateral symmetry, reflecting a left landmark across the true mid-sagittal plane yields the corresponding right landmark, and reflecting a right landmark yields the left landmark. For a candidate $\\mathbf{n}$, define the residual\n$$\nD(\\mathbf{n}) = \\sum_i \\left\\| \\left( \\mathbf{L}_i - 2(\\mathbf{n} \\cdot \\mathbf{L}_i)\\mathbf{n} \\right) - \\mathbf{R}_i \\right\\|^2 + \\sum_i \\left\\| \\left( \\mathbf{R}_i - 2(\\mathbf{n} \\cdot \\mathbf{R}_i)\\mathbf{n} \\right) - \\mathbf{L}_i \\right\\|^2.\n$$\nThe estimated mid-sagittal plane normal $\\mathbf{n}_{\\text{est}}$ is the unit vector minimizing $D(\\mathbf{n})$ over the constrained search space. Because the plane is undirected in its normal, both $\\mathbf{n}$ and $-\\mathbf{n}$ represent the same plane. To fix orientation consistently with the anatomical left-right axis, we enforce $\\mathbf{n} \\cdot \\mathbf{e}_x \\ge 0$, where $\\mathbf{e}_x = (1,0,0)$.\n\nTo parameterize the candidate normals, we begin with $\\mathbf{e}_x$ and apply yaw $\\theta$ about the $z$-axis, followed by pitch $\\psi$ about the $y$-axis. These rotations are represented by well-tested axis rotation matrices. A rotation by angle $\\theta$ about the $z$-axis is\n$$\n\\mathbf{R}_z(\\theta) =\n\\begin{pmatrix}\n\\cos \\theta & -\\sin \\theta & 0 \\\\\n\\sin \\theta & \\cos \\theta & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix},\n$$\nand a rotation by angle $\\psi$ about the $y$-axis is\n$$\n\\mathbf{R}_y(\\psi) =\n\\begin{pmatrix}\n\\cos \\psi & 0 & \\sin \\psi \\\\\n0 & 1 & 0 \\\\\n- \\sin \\psi & 0 & \\cos \\psi\n\\end{pmatrix}.\n$$\nApplying yaw then pitch yields the candidate normal\n$$\n\\mathbf{n}(\\theta,\\psi) = \\mathbf{R}_y(\\psi)\\,\\mathbf{R}_z(\\theta)\\,\\mathbf{e}_x.\n$$\nWe perform a grid search over $\\theta \\in [-20,20]$ degrees and $\\psi \\in [-20,20]$ degrees with a step of $0.5$ degrees, compute $D(\\mathbf{n}(\\theta,\\psi))$, and select the minimizing $(\\theta_{\\text{est}}, \\psi_{\\text{est}})$. The associated $\\mathbf{n}_{\\text{est}}$ is normalized (it is already unit length due to rotation matrices) and sign-corrected so that $\\mathbf{n}_{\\text{est}} \\cdot \\mathbf{e}_x \\ge 0$.\n\nNext, we quantify orientation error propagation to a downstream unit direction vector $\\mathbf{v}$. The correct alignment uses the true normal $\\mathbf{n}_{\\text{true}}$ with the minimal-angle rotation that maps $\\mathbf{n}_{\\text{true}}$ to $\\mathbf{e}_x$. The estimated alignment uses the analogous rotation from $\\mathbf{n}_{\\text{est}}$ to $\\mathbf{e}_x$. Let $\\mathbf{a}$ be a unit vector to align and let $\\mathbf{u}$ be the unit source axis and $\\mathbf{w}$ the unit target axis. The minimal rotation mapping $\\mathbf{u}$ to $\\mathbf{w}$ is the rotation by angle\n$$\n\\alpha = \\arccos\\left( \\max\\left(-1, \\min\\left(1, \\mathbf{u} \\cdot \\mathbf{w} \\right) \\right) \\right),\n$$\nabout the unit axis\n$$\n\\mathbf{k} = \\frac{\\mathbf{u} \\times \\mathbf{w}}{\\|\\mathbf{u} \\times \\mathbf{w}\\|},\n$$\nwhen $\\|\\mathbf{u} \\times \\mathbf{w}\\| \\ne 0$; if $\\|\\mathbf{u} \\times \\mathbf{w}\\| = 0$, then either $\\mathbf{u} = \\mathbf{w}$ (identity rotation) or $\\mathbf{u} = -\\mathbf{w}$ (rotation by $\\pi$ about any axis orthogonal to $\\mathbf{u}$). We avoid the ambiguous $\\pi$ case by flipping the sign of the normal if necessary so that both $\\mathbf{n}_{\\text{true}}$ and $\\mathbf{n}_{\\text{est}}$ satisfy $\\mathbf{n} \\cdot \\mathbf{e}_x \\ge 0$. The rotation of a vector $\\mathbf{a}$ by angle $\\alpha$ about axis $\\mathbf{k}$ is obtained from the Rodrigues rotation formula:\n$$\n\\mathbf{R}(\\mathbf{k},\\alpha)\\,\\mathbf{a} = \\mathbf{a}\\cos\\alpha + (\\mathbf{k} \\times \\mathbf{a})\\sin\\alpha + \\mathbf{k}(\\mathbf{k} \\cdot \\mathbf{a})(1-\\cos\\alpha).\n$$\nThus,\n- The correctly aligned downstream vector is $\\mathbf{v}_{\\text{true}} = \\mathbf{R}(\\mathbf{k}_{\\text{true}},\\alpha_{\\text{true}})\\,\\mathbf{v}$ where $\\mathbf{k}_{\\text{true}}$ and $\\alpha_{\\text{true}}$ are computed from $\\mathbf{u}=\\mathbf{n}_{\\text{true}}$ and $\\mathbf{w}=\\mathbf{e}_x$.\n- The estimated aligned downstream vector is $\\mathbf{v}_{\\text{est}} = \\mathbf{R}(\\mathbf{k}_{\\text{est}},\\alpha_{\\text{est}})\\,\\mathbf{v}$ analogously using $\\mathbf{n}_{\\text{est}}$.\n\nThe orientation error is the angle between $\\mathbf{v}_{\\text{true}}$ and $\\mathbf{v}_{\\text{est}}$:\n$$\n\\beta = \\arccos\\left( \\max\\left(-1, \\min\\left(1, \\frac{\\mathbf{v}_{\\text{true}} \\cdot \\mathbf{v}_{\\text{est}}}{\\|\\mathbf{v}_{\\text{true}}\\| \\|\\mathbf{v}_{\\text{est}}\\|} \\right) \\right) \\right),\n$$\nexpressed in degrees. We normalize $\\mathbf{v}$ to unit length before applying the rotations so that the comparison is purely directional.\n\nAlgorithmic procedure:\n1. For each test case, construct $\\{\\mathbf{L}_i\\}$ and $\\{\\mathbf{R}_i\\}$ as specified. When rotations are required (Test Case $2$ and Test Case $4$), apply $\\mathbf{R}_z(\\theta_{\\text{true}})$ or $\\mathbf{R}_y(\\psi_{\\text{true}})$ respectively to all landmark points. Compute the true normal $\\mathbf{n}_{\\text{true}} = \\mathbf{R}_y(\\psi_{\\text{true}})\\,\\mathbf{R}_z(\\theta_{\\text{true}})\\,\\mathbf{e}_x$ and flip its sign if necessary to satisfy $\\mathbf{n}_{\\text{true}} \\cdot \\mathbf{e}_x \\ge 0$.\n2. Grid-search over $(\\theta,\\psi)$ to minimize $D(\\mathbf{n}(\\theta,\\psi))$ and record the minimizing angles $(\\theta_{\\text{est}},\\psi_{\\text{est}})$ and the corresponding $\\mathbf{n}_{\\text{est}}$ with enforced nonnegative dot product with $\\mathbf{e}_x$.\n3. Normalize the downstream vector $\\mathbf{v}$, compute the alignment rotations from $\\mathbf{n}_{\\text{true}}$ and $\\mathbf{n}_{\\text{est}}$ to $\\mathbf{e}_x$, apply them to $\\mathbf{v}$ to obtain $\\mathbf{v}_{\\text{true}}$ and $\\mathbf{v}_{\\text{est}}$, and compute $\\beta$ in degrees.\n4. Report $[\\theta_{\\text{est}},\\psi_{\\text{est}},\\beta]$ for each test case, rounded to three decimal places.\n\nScientific realism and edge cases:\n- Test Case $1$ represents an ideal symmetric scenario and should yield $\\theta_{\\text{est}} \\approx 0$ and $\\psi_{\\text{est}} \\approx 0$ with negligible orientation error.\n- Test Case $2$ introduces a known yaw; the algorithm should recover an angle close to $10$ degrees and demonstrate a nonzero orientation error for the given $\\mathbf{v}$ if the estimate deviates from the truth.\n- Test Case $3$ has landmarks near the origin with slight asymmetry; the residual landscape can be shallow, revealing sensitivity and possible estimation jitter. The orientation error quantifies its practical impact.\n- Test Case $4$ introduces pitch; the algorithm should recover an angle close to $-15$ degrees.\n\nThe output is a single line containing four sub-lists, one per test case, each with three floats in degrees rounded to three decimal places, in the format $[[\\theta_{\\text{est}},\\psi_{\\text{est}},\\beta],\\dots]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rot_z(theta_deg: float) -> np.ndarray:\n    \"\"\"Rotation matrix for yaw about z-axis by theta_deg degrees.\"\"\"\n    t = np.deg2rad(theta_deg)\n    c, s = np.cos(t), np.sin(t)\n    return np.array([[c, -s, 0.0],\n                     [s,  c, 0.0],\n                     [0.0, 0.0, 1.0]])\n\ndef rot_y(psi_deg: float) -> np.ndarray:\n    \"\"\"Rotation matrix for pitch about y-axis by psi_deg degrees.\"\"\"\n    t = np.deg2rad(psi_deg)\n    c, s = np.cos(t), np.sin(t)\n    return np.array([[ c, 0.0,  s],\n                     [0.0, 1.0, 0.0],\n                     [-s, 0.0,  c]])\n\ndef reflect_point(x: np.ndarray, n: np.ndarray) -> np.ndarray:\n    \"\"\"Reflect point x across plane through origin with unit normal n.\"\"\"\n    return x - 2.0 * np.dot(n, x) * n\n\ndef symmetry_residual(n: np.ndarray, L_points: np.ndarray, R_points: np.ndarray) -> float:\n    \"\"\"Sum of squared distances between reflected left to right and reflected right to left.\"\"\"\n    # Reflect left points and compare to right\n    res1 = R_points - np.array([reflect_point(p, n) for p in L_points])\n    # Reflect right points and compare to left\n    res2 = L_points - np.array([reflect_point(p, n) for p in R_points])\n    return float(np.sum(res1**2) + np.sum(res2**2))\n\ndef estimate_normal_grid(L_points: np.ndarray, R_points: np.ndarray,\n                         yaw_range=(-20.0, 20.0), pitch_range=(-20.0, 20.0),\n                         step=0.5):\n    \"\"\"Grid search over yaw (theta) and pitch (psi) to minimize symmetry residual.\"\"\"\n    ex = np.array([1.0, 0.0, 0.0])\n    best_cost = np.inf\n    best_theta = 0.0\n    best_psi = 0.0\n    best_n = ex.copy()\n    # Create ranges inclusive\n    yaw_vals = np.arange(yaw_range[0], yaw_range[1] + 1e-9, step)\n    pitch_vals = np.arange(pitch_range[0], pitch_range[1] + 1e-9, step)\n    for psi in pitch_vals:\n        Ry = rot_y(psi)\n        for theta in yaw_vals:\n            Rz = rot_z(theta)\n            n = Ry @ (Rz @ ex)\n            # Enforce nonnegative dot with ex to break sign ambiguity\n            if np.dot(n, ex) < 0:\n                n = -n\n            cost = symmetry_residual(n, L_points, R_points)\n            if cost < best_cost:\n                best_cost = cost\n                best_theta = float(theta)\n                best_psi = float(psi)\n                best_n = n\n    return best_theta, best_psi, best_n\n\ndef align_rotation_to_x(n: np.ndarray) -> np.ndarray:\n    \"\"\"Compute rotation matrix that minimally rotates unit vector n to ex = (1,0,0).\"\"\"\n    ex = np.array([1.0, 0.0, 0.0])\n    n = n / np.linalg.norm(n)\n    # Flip sign to avoid 180-degree ambiguity\n    if np.dot(n, ex) < 0:\n        n = -n\n    # Axis and angle\n    k = np.cross(n, ex)\n    s = np.linalg.norm(k)\n    c = float(np.clip(np.dot(n, ex), -1.0, 1.0))\n    if s < 1e-12:\n        # n is parallel to ex -> either identity or 180 deg; due to flip above, c>=0 so identity or near-identity\n        return np.eye(3)\n    k_unit = k / s\n    alpha = float(np.arccos(c))\n    Kx = np.array([[0.0,       -k_unit[2],  k_unit[1]],\n                   [k_unit[2],  0.0,       -k_unit[0]],\n                   [-k_unit[1], k_unit[0],  0.0      ]])\n    I = np.eye(3)\n    # Rodrigues formula\n    R = I * np.cos(alpha) + Kx * np.sin(alpha) + np.outer(k_unit, k_unit) * (1.0 - np.cos(alpha))\n    return R\n\ndef normalize(v: np.ndarray) -> np.ndarray:\n    n = np.linalg.norm(v)\n    if n == 0:\n        return v.copy()\n    return v / n\n\ndef construct_test_cases():\n    # Base symmetric landmarks\n    L0 = np.array([\n        [-50.0,  0.0,   0.0],\n        [-40.0, 20.0,  10.0],\n        [-30.0,-15.0,  30.0],\n        [-45.0,  5.0, -25.0],\n    ])\n    R0 = np.array([\n        [ 50.0,  0.0,   0.0],\n        [ 40.0, 20.0,  10.0],\n        [ 30.0,-15.0,  30.0],\n        [ 45.0,  5.0, -25.0],\n    ])\n    # Test Case 1: identity\n    tc1 = {\n        \"L\": L0.copy(),\n        \"R\": R0.copy(),\n        \"theta_true\": 0.0,\n        \"psi_true\": 0.0,\n        \"v\": np.array([0.0, 1.0, 0.0])\n    }\n    # Test Case 2: yaw +10 deg\n    theta2 = 10.0\n    Rz2 = rot_z(theta2)\n    L2 = (Rz2 @ L0.T).T\n    R2 = (Rz2 @ R0.T).T\n    tc2 = {\n        \"L\": L2,\n        \"R\": R2,\n        \"theta_true\": theta2,\n        \"psi_true\": 0.0,\n        \"v\": np.array([0.0, 1.0, 0.0])\n    }\n    # Test Case 3: small-magnitude, slight asymmetry\n    L3 = np.array([\n        [-5.0,   1.0,   0.5 ],\n        [-4.0,  -1.0,   0.2 ],\n        [-6.0,   0.5,  -0.4 ],\n        [-5.5,  -0.2,   0.1 ],\n    ])\n    R3 = np.array([\n        [ 5.0,   1.1,   0.55],\n        [ 4.0,  -0.9,   0.25],\n        [ 6.0,   0.45, -0.35],\n        [ 5.5,  -0.15,  0.05],\n    ])\n    tc3 = {\n        \"L\": L3,\n        \"R\": R3,\n        \"theta_true\": 0.0,\n        \"psi_true\": 0.0,\n        \"v\": normalize(np.array([0.3, 0.8, 0.5]))\n    }\n    # Test Case 4: pitch -15 deg\n    psi4 = -15.0\n    Ry4 = rot_y(psi4)\n    L4 = (Ry4 @ L0.T).T\n    R4 = (Ry4 @ R0.T).T\n    tc4 = {\n        \"L\": L4,\n        \"R\": R4,\n        \"theta_true\": 0.0,\n        \"psi_true\": psi4,\n        \"v\": np.array([0.0, 0.0, 1.0])\n    }\n    return [tc1, tc2, tc3, tc4]\n\ndef true_normal(theta_true: float, psi_true: float) -> np.ndarray:\n    ex = np.array([1.0, 0.0, 0.0])\n    n_true = rot_y(psi_true) @ (rot_z(theta_true) @ ex)\n    # Enforce nonnegative dot with ex\n    if np.dot(n_true, ex) < 0:\n        n_true = -n_true\n    return n_true\n\ndef orientation_error_deg(n_true: np.ndarray, n_est: np.ndarray, v: np.ndarray) -> float:\n    \"\"\"Compute orientation error between correctly and incorrectly aligned downstream vector v.\"\"\"\n    R_true = align_rotation_to_x(n_true)\n    R_est = align_rotation_to_x(n_est)\n    v_unit = normalize(v)\n    v_true = R_true @ v_unit\n    v_est = R_est @ v_unit\n    # Angle between v_true and v_est\n    num = float(np.dot(v_true, v_est))\n    den = float(np.linalg.norm(v_true) * np.linalg.norm(v_est))\n    if den == 0.0:\n        # Should not occur with proper rotations and nonzero v\n        return 0.0\n    cosang = max(-1.0, min(1.0, num / den))\n    ang_rad = float(np.arccos(cosang))\n    return np.rad2deg(ang_rad)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = construct_test_cases()\n\n    results = []\n    for tc in test_cases:\n        L = tc[\"L\"]\n        R = tc[\"R\"]\n        theta_true = tc[\"theta_true\"]\n        psi_true = tc[\"psi_true\"]\n        v = tc[\"v\"]\n        # Estimate normal via grid search\n        theta_est, psi_est, n_est = estimate_normal_grid(L, R,\n                                                         yaw_range=(-20.0, 20.0),\n                                                         pitch_range=(-20.0, 20.0),\n                                                         step=0.5)\n        # True normal from parameters\n        n_true = true_normal(theta_true, psi_true)\n        # Orientation error\n        err_deg = orientation_error_deg(n_true, n_est, v)\n        # Round to three decimals for output\n        results.append([theta_est, psi_est, err_deg])\n\n    # Format the final output: nested list with floats rounded to three decimals\n    formatted = []\n    for triple in results:\n        formatted.append(\"[\" + \",\".join(f\"{x:.3f}\" for x in triple) + \"]\")\n    print(\"[\" + \",\".join(formatted) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "To meaningfully compare brain anatomy across different individuals or against a standardized anatomical atlas, we must first align them into a common coordinate system. This final practice  introduces you to landmark-based rigid registration, a cornerstone technique in medical image analysis. By identifying key neuroanatomical landmarks such as the anterior and posterior commissures, you will derive the precise rotation and translation transform required to align a patient's brain scan to a canonical atlas, a critical procedure for both clinical diagnosis and research.",
            "id": "4894133",
            "problem": "A brain Magnetic Resonance Imaging (MRI) volume is to be rigidly aligned to a canonical atlas frame defined by the anterior commissure (AC), posterior commissure (PC), and a superior mid-sagittal point. The atlas frame is constructed so that the AC is the origin, the AC–PC line defines the positive $y$-axis, the superior midline point defines the positive $z$-axis, and the resulting coordinate system is right-handed. In this canonical atlas frame, the landmarks are given by\n$\\mathbf{a}_{\\mathrm{AC}} = (0, 0, 0)$ mm, $\\mathbf{a}_{\\mathrm{PC}} = (0, 25, 0)$ mm, and $\\mathbf{a}_{\\mathrm{MS}} = (0, 0, 30)$ mm.\nIn the patient MRI, the corresponding landmarks are measured at\n$\\mathbf{p}_{\\mathrm{AC}} = (10, -5, 2)$ mm, $\\mathbf{p}_{\\mathrm{PC}} = (35, -5, 2)$ mm, and $\\mathbf{p}_{\\mathrm{MS}} = (10, 25, 2)$ mm.\nAssume the atlas and patient landmarks are non-collinear and define their respective local axes by straight-line connections of the landmarks as in standard neuroanatomical orientation: the AC–PC vector defines the $y$-axis, the AC–MS vector defines the $z$-axis, and the $x$-axis is chosen to complete a right-handed orthonormal triad via the vector cross product. Using only these definitions and the rigidity constraints of rotation and translation, derive the unique rigid transform $(\\mathbf{R}, \\mathbf{t})$ that maps the patient landmarks to the atlas landmarks, where $\\mathbf{R}$ is a $3 \\times 3$ rotation matrix and $\\mathbf{t}$ is a $3 \\times 1$ translation vector, and $\\mathbf{R}\\mathbf{p} + \\mathbf{t}$ maps patient coordinates $\\mathbf{p}$ into the atlas frame.\n\nFor quality control, a fourth anatomical point is identified in the atlas at $\\mathbf{a}_{4} = (12, 8, 15)$ mm. The corresponding patient measurement is $\\mathbf{p}_{4} = (18.6, 9.6, 14.3)$ mm. After applying the derived rigid transform to all four patient points, compute the root-mean-square (RMS) residual error across the four landmark correspondences,\n$$E_{\\mathrm{RMS}} = \\left( \\frac{\\sum_{i=1}^{4} \\|\\mathbf{R}\\mathbf{p}_{i} + \\mathbf{t} - \\mathbf{a}_{i}\\|^{2}}{4} \\right)^{1/2},$$\nwhere $\\|\\cdot\\|$ denotes the Euclidean norm, and $(\\mathbf{p}_{i}, \\mathbf{a}_{i})$ denote the patient–atlas landmark pairs for $\\mathrm{AC}$, $\\mathrm{PC}$, $\\mathrm{MS}$, and the fourth point. Round your final numerical answer for $E_{\\mathrm{RMS}}$ to four significant figures and express it in millimeters.",
            "solution": "The problem asks for a rigid transformation $(\\mathbf{R}, \\mathbf{t})$ that maps points from a patient's MRI coordinate system to a canonical atlas system. The transformation is defined by aligning coordinate frames constructed from three corresponding landmarks. The final goal is to compute the Root-Mean-Square (RMS) error for this transformation using a fourth validation landmark.\n\nFirst, we construct the orthonormal basis for the atlas coordinate frame, $A$. The origin is $\\mathbf{O}_A = \\mathbf{a}_{\\mathrm{AC}} = (0, 0, 0)$. The basis vectors $(\\mathbf{u}_{xA}, \\mathbf{u}_{yA}, \\mathbf{u}_{zA})$ are defined as follows:\n\nThe $y$-axis is defined by the vector from $\\mathbf{a}_{\\mathrm{AC}}$ to $\\mathbf{a}_{\\mathrm{PC}}$.\n$$ \\mathbf{v}_{yA} = \\mathbf{a}_{\\mathrm{PC}} - \\mathbf{a}_{\\mathrm{AC}} = \\begin{pmatrix} 0 \\\\ 25 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 25 \\\\ 0 \\end{pmatrix} $$\nThe unit vector is $\\mathbf{u}_{yA} = \\frac{\\mathbf{v}_{yA}}{\\|\\mathbf{v}_{yA}\\|} = \\frac{1}{25}\\begin{pmatrix} 0 \\\\ 25 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}$.\n\nThe $z$-axis is defined by the vector from $\\mathbf{a}_{\\mathrm{AC}}$ to $\\mathbf{a}_{\\mathrm{MS}}$.\n$$ \\mathbf{v}_{zA} = \\mathbf{a}_{\\mathrm{MS}} - \\mathbf{a}_{\\mathrm{AC}} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 30 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 30 \\end{pmatrix} $$\nThe unit vector is $\\mathbf{u}_{zA} = \\frac{\\mathbf{v}_{zA}}{\\|\\mathbf{v}_{zA}\\|} = \\frac{1}{30}\\begin{pmatrix} 0 \\\\ 0 \\\\ 30 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$.\n\nThe $x$-axis completes the right-handed orthonormal system:\n$$ \\mathbf{u}_{xA} = \\mathbf{u}_{yA} \\times \\mathbf{u}_{zA} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} \\times \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\nThe basis matrix for the atlas frame, $\\mathbf{M}_A = [\\mathbf{u}_{xA} \\ \\mathbf{u}_{yA} \\ \\mathbf{u}_{zA}]$, is the identity matrix $\\mathbf{I}$.\n$$ \\mathbf{M}_A = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} $$\n\nNext, we construct the orthonormal basis for the patient coordinate frame, $P$. The origin is $\\mathbf{O}_P = \\mathbf{p}_{\\mathrm{AC}} = (10, -5, 2)$. The basis vectors are constructed similarly.\n\nThe $y$-axis is defined by the vector from $\\mathbf{p}_{\\mathrm{AC}}$ to $\\mathbf{p}_{\\mathrm{PC}}$.\n$$ \\mathbf{v}_{yP} = \\mathbf{p}_{\\mathrm{PC}} - \\mathbf{p}_{\\mathrm{AC}} = \\begin{pmatrix} 35 \\\\ -5 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 10 \\\\ -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 25 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\nThe unit vector is $\\mathbf{u}_{yP} = \\frac{\\mathbf{v}_{yP}}{\\|\\mathbf{v}_{yP}\\|} = \\frac{1}{25}\\begin{pmatrix} 25 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$.\n\nThe initial vector for the $z$-axis is from $\\mathbf{p}_{\\mathrm{AC}}$ to $\\mathbf{p}_{\\mathrm{MS}}$.\n$$ \\mathbf{v}_{zP} = \\mathbf{p}_{\\mathrm{MS}} - \\mathbf{p}_{\\mathrm{AC}} = \\begin{pmatrix} 10 \\\\ 25 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 10 \\\\ -5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 30 \\\\ 0 \\end{pmatrix} $$\nWe check for orthogonality: $\\mathbf{v}_{yP} \\cdot \\mathbf{v}_{zP} = (25)(0) + (0)(30) + (0)(0) = 0$. The vectors are already orthogonal, so we only need to normalize $\\mathbf{v}_{zP}$.\n$$ \\mathbf{u}_{zP} = \\frac{\\mathbf{v}_{zP}}{\\|\\mathbf{v}_{zP}\\|} = \\frac{1}{30}\\begin{pmatrix} 0 \\\\ 30 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} $$\nThe $x$-axis completes the right-handed system:\n$$ \\mathbf{u}_{xP} = \\mathbf{u}_{yP} \\times \\mathbf{u}_{zP} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\times \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\nThe basis matrix for the patient frame is $\\mathbf{M}_P = [\\mathbf{u}_{xP} \\ \\mathbf{u}_{yP} \\ \\mathbf{u}_{zP}]$.\n$$ \\mathbf{M}_P = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 1 & 0 & 0 \\end{pmatrix} $$\n\nThe rotation matrix $\\mathbf{R}$ maps the patient basis onto the atlas basis: $\\mathbf{R}\\mathbf{M}_P = \\mathbf{M}_A$. Thus, $\\mathbf{R} = \\mathbf{M}_A \\mathbf{M}_P^{-1} = \\mathbf{M}_A \\mathbf{M}_P^T$. Since $\\mathbf{M}_A = \\mathbf{I}$, we have $\\mathbf{R} = \\mathbf{M}_P^T$.\n$$ \\mathbf{R} = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 1 & 0 & 0 \\end{pmatrix}^T = \\begin{pmatrix} 0 & 0 & 1 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix} $$\nThe translation vector $\\mathbf{t}$ aligns the origins after rotation: $\\mathbf{R}\\mathbf{O}_P + \\mathbf{t} = \\mathbf{O}_A$.\n$$ \\mathbf{t} = \\mathbf{O}_A - \\mathbf{R}\\mathbf{O}_P = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0 & 0 & 1 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} 10 \\\\ -5 \\\\ 2 \\end{pmatrix} = - \\begin{pmatrix} 2 \\\\ 10 \\\\ -5 \\end{pmatrix} = \\begin{pmatrix} -2 \\\\ -10 \\\\ 5 \\end{pmatrix} $$\n\nNow, we calculate the RMS error using all four landmark pairs.\n$$ E_{\\mathrm{RMS}} = \\left( \\frac{\\sum_{i=1}^{4} \\|\\mathbf{R}\\mathbf{p}_{i} + \\mathbf{t} - \\mathbf{a}_{i}\\|^{2}}{4} \\right)^{1/2} $$\nThe error for the first three landmarks is zero by construction. We only need to compute the error for the fourth point, where $\\mathbf{p}_4 = (18.6, 9.6, 14.3)$ and $\\mathbf{a}_4 = (12, 8, 15)$.\nFirst, we transform $\\mathbf{p}_4$ to the atlas frame:\n$$ \\mathbf{a}'_4 = \\mathbf{R}\\mathbf{p}_4 + \\mathbf{t} = \\begin{pmatrix} 0 & 0 & 1 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} 18.6 \\\\ 9.6 \\\\ 14.3 \\end{pmatrix} + \\begin{pmatrix} -2 \\\\ -10 \\\\ 5 \\end{pmatrix} $$\n$$ \\mathbf{a}'_4 = \\begin{pmatrix} 14.3 \\\\ 18.6 \\\\ 9.6 \\end{pmatrix} + \\begin{pmatrix} -2 \\\\ -10 \\\\ 5 \\end{pmatrix} = \\begin{pmatrix} 12.3 \\\\ 8.6 \\\\ 14.6 \\end{pmatrix} $$\nThe residual error vector for the fourth point is $\\mathbf{e}_4 = \\mathbf{a}'_4 - \\mathbf{a}_4$:\n$$ \\mathbf{e}_4 = \\begin{pmatrix} 12.3 \\\\ 8.6 \\\\ 14.6 \\end{pmatrix} - \\begin{pmatrix} 12 \\\\ 8 \\\\ 15 \\end{pmatrix} = \\begin{pmatrix} 0.3 \\\\ 0.6 \\\\ -0.4 \\end{pmatrix} $$\nThe squared Euclidean norm of the residual is:\n$$ \\|\\mathbf{e}_4\\|^2 = (0.3)^2 + (0.6)^2 + (-0.4)^2 = 0.09 + 0.36 + 0.16 = 0.61 $$\nFinally, we compute the RMS error:\n$$ E_{\\mathrm{RMS}} = \\left( \\frac{0 + 0 + 0 + 0.61}{4} \\right)^{1/2} = \\left( \\frac{0.61}{4} \\right)^{1/2} = \\sqrt{0.1525} \\approx 0.39051248... $$\nRounding to four significant figures, the RMS error is $0.3905$ mm.",
            "answer": "$$\\boxed{0.3905}$$"
        }
    ]
}