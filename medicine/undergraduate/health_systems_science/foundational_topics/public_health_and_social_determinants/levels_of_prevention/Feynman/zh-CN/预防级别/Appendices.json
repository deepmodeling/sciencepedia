{
    "hands_on_practices": [
        {
            "introduction": "一级预防旨在通过消除风险因素来从源头上防止疾病的发生。为了有效规划和评估这些干预措施，我们需要一个量化指标来估算其潜在影响。本练习将引导您推导和计算人群归因分数（$PAF$），这是一个关键的流行病学工具，用于衡量特定风险因素在多大程度上导致了人群中的疾病负担。",
            "id": "4380187",
            "problem": "一个地区卫生部门正在评估一项旨在消除当前吸烟行为的一级预防策略对心血管疾病（CVD）发病率的影响。在所研究的成年人群中，当前吸烟的流行率为 $p_e = 0.25$，吸烟者相对于非吸烟者的心血管疾病新发相对风险（RR）为 $RR = 2.0$。假设以下基本条件成立：相对风险是因果性的，并且可推广至目标人群；不存在混杂或选择偏倚；消除吸烟行为会将每个个体的风险设定为反事实未暴露风险。\n\n仅使用发病率、暴露流行率和相对风险的核心流行病学定义，从第一性原理出发，推导人群归因分数（PAF）的表达式（PAF被定义为如果移除暴露因素，人群发病率将会出现的成比例下降），然后使用给定的 $p_e$ 和 $RR$ 计算 $PAF$ 的数值。\n\n最后，用文字说明一个完全消除吸烟的一级预防项目如何将计算出的 $PAF$ 与人群发病率的变化联系起来，并根据其作用层面，区分此一级预防机制与二级和三级预防。\n\n最终答案仅报告 $PAF$ 的数值。请以小数（而非百分比）形式表示，并四舍五入至三位有效数字。",
            "solution": "经评估，该问题是有效的，因为它科学地基于已确立的流行病学原理，问题设定良好，数据充分且一致，并以客观、正式的语言表述。因此，我们可以着手求解。\n\n目标是从第一性原理出发推导人群归因分数（$PAF$）的表达式，然后计算其值。\n\n设 $I_{total}$ 代表人群中心血管疾病（CVD）的总发病率。\n设 $I_e$ 为暴露组（当前吸烟者）的CVD发病率。\n设 $I_u$ 为非暴露组（非吸烟者）的CVD发病率。\n设 $p_e$ 为人群中暴露（吸烟）的流行率。因此，非暴露的流行率为 $1 - p_e$。\n\n根据第一性原理，人群的总发病率是暴露亚群和非暴露亚群发病率的加权平均值：\n$$I_{total} = I_e \\cdot p_e + I_u \\cdot (1 - p_e)$$\n\n相对风险（$RR$）定义为暴露组发病率与非暴露组发病率之比：\n$$RR = \\frac{I_e}{I_u}$$\n这个定义使我们能够用非暴露组的发病率和相对风险来表示暴露组的发病率：\n$$I_e = RR \\cdot I_u$$\n\n人群归因分数（$PAF$）定义为如果消除暴露，总人群发病率将发生的成比例减少。如果暴露被消除，一个先前暴露的个体将获得未暴露个体的风险。根据问题的假设，整个人群的发病率将变为 $I_u$。\n\n发病率的绝对降低量是当前总发病率与反事实总发病率之间的差值：$I_{total} - I_u$。\n$PAF$ 是这个降低量表示为当前总发病率的一部分：\n$$PAF = \\frac{I_{total} - I_u}{I_{total}}$$\n\n为了推导出一个可计算的公式，我们将所有项表示为 $p_e$、$RR$ 和基线发病率 $I_u$ 的函数。\n首先，将 $I_e = RR \\cdot I_u$ 代入 $I_{total}$ 的方程：\n$$I_{total} = (RR \\cdot I_u) \\cdot p_e + I_u \\cdot (1 - p_e)$$\n提取公因子 $I_u$ 得：\n$$I_{total} = I_u (RR \\cdot p_e + 1 - p_e)$$\n这可以重排为 $I_{total} = I_u (1 + p_e(RR - 1))$。\n\n现在，我们将这个 $I_{total}$ 的表达式代入 $PAF$ 的定义中：\n$$PAF = \\frac{I_u (1 + p_e(RR - 1)) - I_u}{I_u (1 + p_e(RR - 1))}$$\n假设 $I_u > 0$，我们可以从分子和分母中约去 $I_u$：\n$$PAF = \\frac{(1 + p_e(RR - 1)) - 1}{1 + p_e(RR - 1)}$$\n这简化为人群归因分数的标准公式：\n$$PAF = \\frac{p_e(RR - 1)}{1 + p_e(RR - 1)}$$\n\n现在，我们使用给定的数据计算 $PAF$ 的数值：\n暴露流行率，$p_e = 0.25$。\n相对风险，$RR = 2.0$。\n\n将这些值代入推导出的公式中：\n$$PAF = \\frac{0.25(2.0 - 1)}{1 + 0.25(2.0 - 1)}$$\n$$PAF = \\frac{0.25(1.0)}{1 + 0.25(1.0)}$$\n$$PAF = \\frac{0.25}{1.25}$$\n$$PAF = \\frac{1/4}{5/4} = \\frac{1}{5} = 0.2$$\n按照要求四舍五入到三位有效数字，该值为 $0.200$。\n\n最后，问题要求解释这与预防级别之间的关系。计算出的 $PAF$ 为 $0.200$ 意味着该人群中 $20.0\\%$ 的CVD发病率可归因于吸烟。一个完全消除吸烟的一级预防项目，在给定的理想假设下，将导致总人群CVD发病率降低 $20.0\\%$。这是一级预防的标志：它在疾病发生*之前*采取行动，通过消除或减轻对致病风险因素的暴露来防止新病例的发生。\n\n这种机制与其他级别的预防措施不同：\n- **二级预防** 在疾病的早期、通常无症状的阶段进行检测和治疗，以减缓或阻止其进展。对于CVD，这可能涉及筛查和治疗高血压或高胆固醇血症等病症。它不能防止最初的病理过程，但旨在避免其临床表现。\n- **三级预防** 在疾病出现临床表现和症状*之后*采取行动。其目标是减少并发症、最小化残疾并预防死亡。对于CVD，这包括为心脏病发作后的患者提供的心脏康复计划。它侧重于管理已确诊的疾病。\n\n因此，$PAF$ 直接量化了针对特定因果暴露的一级预防策略的最大潜在影响。",
            "answer": "$$\\boxed{0.200}$$"
        },
        {
            "introduction": "二级预防的核心是通过筛查在疾病早期阶段进行检测和干预，从而改善预后。然而，一个筛查测试的有效性不仅取决于其固有的准确性（灵敏度和特异性），还受到疾病在人群中流行程度的影响。本练习将通过推导阳性预测值（$PPV$）和阴性预测值（$NPV$），帮助您理解和量化疾病流行率如何影响筛查测试在实际应用中的表现。",
            "id": "4606787",
            "problem": "一个公共卫生部门正在评估一项针对某种慢性病的筛查项目，该项目是综合预防策略中二级预防的一部分。筛查性能由灵敏度、特异度、阳性预测值和阴性预测值来表征。考虑二元疾病状态 $D \\in \\{0,1\\}$ 和二元检测结果 $T \\in \\{-,+\\}$，并设疾病患病率为 $\\pi = P(D=1)$。请根据核心概率定义和贝叶斯定理，推导阳性预测值 $P(D=1 \\mid T=+)$ 和阴性预测值 $P(D=0 \\mid T=-)$ 的群体水平表达式。使用以下核心定义：\n- 灵敏度为 $P(T=+ \\mid D=1)$。\n- 特异度为 $P(T=- \\mid D=0)$。\n- 阳性预测值为 $P(D=1 \\mid T=+)$。\n- 阴性预测值为 $P(D=0 \\mid T=-)$。\n假设该检测的灵敏度为 $0.95$，特异度为 $0.90$。计算当患病率 $\\pi = 0.01$ 和 $\\pi = 0.10$ 时的阳性预测值。将预测值表示为小数或分数；不要使用百分号。请按给定顺序，仅提供 $\\pi = 0.01$ 和 $\\pi = 0.10$ 这两种情况下的阳性预测值的最终数值结果。",
            "solution": "所述问题在形式上是合理的、自洽的，并且科学上基于概率论和流行病学的原理。所有术语都有明确定义，并为得出唯一解提供了必要的数据。因此，该问题是有效的。\n\n我们被要求推导阳性预测值（$PPV$）和阴性预测值（$NPV$）的群体水平表达式，然后为一组给定的参数计算 $PPV$。设二元疾病状态由 $D$ 表示，其中 $D=1$ 表示患病，$D=0$ 表示未患病。设二元检测结果由 $T$ 表示，其中 $T=+$ 为阳性结果，$T=-$ 为阴性结果。\n\n提供的核心定义如下：\n患病率：$\\pi = P(D=1)$\n灵敏度：$S_{ens} = P(T=+ \\mid D=1)$\n特异度：$S_{pec} = P(T=- \\mid D=0)$\n阳性预测值：$PPV = P(D=1 \\mid T=+)$\n阴性预测值：$NPV = P(D=0 \\mid T=-)$\n\n由此，我们可以陈述其互补概率：\n$P(D=0) = 1 - P(D=1) = 1 - \\pi$\n$P(T=- \\mid D=1) = 1 - P(T=+ \\mid D=1) = 1 - S_{ens}$\n$P(T=+ \\mid D=0) = 1 - P(T=- \\mid D=0) = 1 - S_{pec}$\n\n$PPV$ 和 $NPV$ 的推导源于贝叶斯定理。\n\n首先，我们推导 $PPV$ 的表达式。根据定义，$PPV = P(D=1 \\mid T=+)$。应用贝叶斯定理，即 $P(A \\mid B) = \\frac{P(B \\mid A)P(A)}{P(B)}$，我们得到：\n$$PPV = \\frac{P(T=+ \\mid D=1)P(D=1)}{P(T=+)}$$\n分母中的项 $P(T=+)$ 是检测结果为阳性的边际概率。我们可以使用全概率定律，以疾病状态 $D$ 为条件对其进行展开：\n$$P(T=+) = P(T=+ \\mid D=1)P(D=1) + P(T=+ \\mid D=0)P(D=0)$$\n代入已定义的术语及其互补项：\n$$P(T=+) = (S_{ens})(\\pi) + (1 - S_{pec})(1 - \\pi)$$\n将此结果代回 $PPV$ 的表达式中，我们得到通用公式：\n$$PPV = \\frac{S_{ens} \\cdot \\pi}{S_{ens} \\cdot \\pi + (1 - S_{pec})(1 - \\pi)}$$\n\n接下来，我们推导 $NPV$ 的表达式。根据定义，$NPV = P(D=0 \\mid T=-)$。应用贝叶斯定理：\n$$NPV = \\frac{P(T=- \\mid D=0)P(D=0)}{P(T=-)}$$\n分母 $P(T=-)$ 是检测结果为阴性的边际概率，我们使用全概率定律将其展开：\n$$P(T=-) = P(T=- \\mid D=0)P(D=0) + P(T=- \\mid D=1)P(D=1)$$\n代入已定义的术语：\n$$P(T=-) = (S_{pec})(1 - \\pi) + (1 - S_{ens})(\\pi)$$\n将此结果代回 $NPV$ 的表达式中，我们得到通用公式：\n$$NPV = \\frac{S_{pec} \\cdot (1 - \\pi)}{S_{pec} \\cdot (1 - \\pi) + (1 - S_{ens}) \\cdot \\pi}$$\n\n现在，我们需要为特定的参数值计算 $PPV$：灵敏度 $S_{ens} = 0.95$ 和特异度 $S_{pec} = 0.90$。我们将针对两种不同的患病率 $\\pi = 0.01$ 和 $\\pi = 0.10$ 进行此计算。\n\n情况1：患病率 $\\pi = 0.01$。\n我们将这些值代入推导出的 $PPV$ 公式中：\n$$PPV = \\frac{0.95 \\cdot 0.01}{0.95 \\cdot 0.01 + (1 - 0.90)(1 - 0.01)}$$\n$$PPV = \\frac{0.0095}{0.0095 + (0.10)(0.99)}$$\n$$PPV = \\frac{0.0095}{0.0095 + 0.0990}$$\n$$PPV = \\frac{0.0095}{0.1085} = \\frac{95}{1085} = \\frac{19}{217}$$\n\n情况2：患病率 $\\pi = 0.10$。\n我们再次将这些值代入 $PPV$ 公式中：\n$$PPV = \\frac{0.95 \\cdot 0.10}{0.95 \\cdot 0.10 + (1 - 0.90)(1 - 0.10)}$$\n$$PPV = \\frac{0.095}{0.095 + (0.10)(0.90)}$$\n$$PPV = \\frac{0.095}{0.095 + 0.090}$$\n$$PPV = \\frac{0.095}{0.185} = \\frac{95}{185} = \\frac{19}{37}$$\n\n这些计算表明，预测值严重依赖于受检人群中该疾病的患病率。尽管该检测具有恒定的灵敏度和特异度，但随着患病率从 $1\\%$ 增加到 $10\\%$，阳性结果正确指示疾病的概率（$PPV$）从大约 $8.8\\%$ 大幅增加到大约 $51.4\\%$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{19}{217} & \\frac{19}{37} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在复杂的公共卫生情景中，不同层级的预防措施（一级、二级和三级）并非孤立存在，它们的综合效果决定了最终的健康结果。为了更全面地比较这些策略的有效性，我们采用动态系统模型。本综合练习将指导您构建一个传染病传播模型，以模拟和量化疫苗接种（一级）、筛查隔离（二级）和临床治疗改进（三级）在控制疫情、减少死亡方面的相对贡献。",
            "id": "4380236",
            "problem": "你需要构建一个完整的、可运行的程序，用于校准和模拟一个房室传染病模型，以量化三种预防级别对减少某种呼吸道病原体所致死亡的相对影响。该程序必须编码一个易感-暴露-感染-康复 (SEIR) 框架，该框架扩展了无传播能力的隔离状态和死亡计数器，并且必须分别实现以下每个预防级别：一级预防（在零时刻进行疫苗接种）、二级预防（通过筛查进行隔离以减少传播）和三级预防（改善重症监护以降低死亡率而不改变传染性）。\n\n使用以下基本基础，这是人口健康动态学中一个被广泛接受的起点：\n- 一个确定性房室模型，具有质量作用传播，其中发病项为 $\\beta S I$，并且各房室是人口的比例，满足 $S + E + I + Q + R + D = 1$。其中 $S$ 代表易感者， $E$ 代表暴露者（已感染但无传染性）， $I$ 代表感染者（有传染性）， $Q$ 代表隔离者（无传染性）， $R$ 代表康复者（免疫）， $D$ 代表累计死亡人数。\n- 时间单位为天。令 $\\sigma$ 为从暴露态到感染态的速率（因此平均潜伏期为 $1/\\sigma$），令 $\\tau$ 为从感染态的总移除率（因此平均感染期为 $1/\\tau$）。将 $\\tau$ 分解为康复和死亡部分，即 $\\tau = \\gamma + \\delta$，其中 $\\gamma$ 是康复率，$\\delta$ 是从感染态或隔离态的死亡率。令感染致死率 (IFR) 为 $f = \\delta / (\\gamma + \\delta)$，这意味着 $\\gamma = (1 - f)\\tau$ 和 $\\delta = f \\tau$。\n- 对于这个具有非感染性暴露态的 SEIR 结构，基线基本再生数（有时称为基本繁殖比）为 $\\mathcal{R}_0 = \\beta / \\tau$。通过 $\\beta = \\mathcal{R}_0 \\, \\tau$ 来校准传播率。\n- 通过筛查进行隔离的二级预防被建模为从 $I$ 到 $Q$ 的一个额外流，速率为 $\\eta$。在 $Q$ 中的个体不传播，并以速率 $\\tau$ 离开 $Q$，同样根据与 $I$ 中相同的 $\\gamma$ 和 $\\delta$ 分为康复和死亡。这保留了感染致死率 $f$ 和临床病程，但通过缩短在传播状态下花费的时间来减少传播。\n- 在零时刻通过疫苗接种进行的一级预防，通过有效比例 $v = c \\times \\varepsilon$ 降低了易感性，其中 $c$ 是覆盖率，$\\varepsilon$ 是疫苗对感染的效力。通过在模拟前将 $S(0)$ 的比例 $v$ 移动到 $R(0)$ 来实现这一点，因此 $S(0)$ 变为 $S(0)\\,(1 - v)$，而 $R(0)$ 增加 $S(0)\\,v$。对于一级预防情景，没有其他参数改变。\n- 通过改善重症监护进行的三级预防，使感染致死率降低一个比例 $m$，同时保持临床移除时间恒定（因此传播不被改变）。通过设置 $f' = f (1 - m)$ 并保持 $\\tau$ 不变来实现这一点，然后重新计算 $\\gamma' = (1 - f')\\tau$ 和 $\\delta' = f' \\tau$。对于三级预防情景，不要改变 $\\beta$，以便 $\\mathcal{R}_0$ 保持为 $\\beta / \\tau$。\n\n模拟以下以总人口比例表示的连续时间常微分方程组 (ODEs)：\n- $S'(t) = -\\beta \\, S(t) \\, I(t)$\n- $E'(t) = \\beta \\, S(t) \\, I(t) - \\sigma \\, E(t)$\n- $I'(t) = \\sigma \\, E(t) - (\\tau + \\eta) \\, I(t)$\n- $Q'(t) = \\eta \\, I(t) - \\tau \\, Q(t)$\n- $R'(t) = \\gamma \\, I(t) + \\gamma \\, Q(t)$\n- $D'(t) = \\delta \\, I(t) + \\delta \\, Q(t)$\n\n使用给定的目标基本再生数和选择的 $\\tau$ 来校准 $\\beta$。对于基线情景，设置 $\\eta = 0$，并且不应用疫苗接种或三级预防的更改。对于每个干预情景，只更改该级别指定的内容，并将其他设置保持在基线水平。\n\n使用固定步长的前向欧拉法进行数值积分，时间步长为 $\\Delta t = 0.1$ 天，在指定的时间范围内进行。将总人口视为固定大小 $N$，通过在输入时除以 $N$ 并在输出时乘以 $N$ 来在计数和比例之间转换。对于每个测试用例，计算到时间 $T$ 时的基线累计死亡人数，并分别计算在单独应用每种干预措施下的累计死亡人数。将每种干预措施避免的死亡人数报告为基线死亡人数减去干预死亡人数。所有最终输出均以人数表示，并四舍五入到小数点后两位。\n\n你的程序必须硬编码并运行以下测试套件。每个测试用例提供：\n- 人口规模 $N$（单位：人）。\n- 初始计数 $I_0$, $E_0$, $R_0$（用于康复房室），且 $Q_0 = 0$ 和 $D_0 = 0$。初始易感者计数为 $S_0 = N - I_0 - E_0 - R_0 - Q_0 - D_0$。\n- 潜伏期（单位：天），因此 $\\sigma = 1 / \\text{incubation\\_days}$。\n- 感染期（单位：天），因此 $\\tau = 1 / \\text{infectious\\_days}$。\n- 基线感染致死率 $f$。\n- 基线基本再生数 $\\mathcal{R}_0$。\n- 时间范围 $T$（单位：天）。\n- 疫苗接种覆盖率 $c$ 和疫苗效力 $\\varepsilon$。\n- 筛查检测/隔离率 $\\eta$（单位：每天）。\n- 三级预防死亡率降低比例 $m$。\n\n测试用例：\n- 案例 A（理想情况）：$N = 1000000$, $I_0 = 100$, $E_0 = 200$, $R_0 = 0$, 潜伏期 $= 3$ 天，因此 $\\sigma = 1/3$, 感染期 $= 5$ 天，因此 $\\tau = 1/5$, 基线 $f = 0.01$, $\\mathcal{R}_0 = 2.5$, $T = 180$, $c = 0.6$, $\\varepsilon = 0.8$, $\\eta = 0.2$, $m = 0.5$。\n- 案例 B（一级预防零覆盖率边界）：与案例 A 相同，但 $c = 0.0$。\n- 案例 C（无初始感染边界）：$N = 500000$, $I_0 = 0$, $E_0 = 0$, $R_0 = 0$, 潜伏期 $= 3$ 天，因此 $\\sigma = 1/3$, 感染期 $= 5$ 天，因此 $\\tau = 1/5$, 基线 $f = 0.02$, $\\mathcal{R}_0 = 2.2$, $T = 120$, $c = 0.3$, $\\varepsilon = 0.9$, $\\eta = 0.1$, $m = 0.3$。\n- 案例 D（三级预防极端边界）：$N = 200000$, $I_0 = 50$, $E_0 = 50$, $R_0 = 0$, 潜伏期 $= 3$ 天，因此 $\\sigma = 1/3$, 感染期 $= 5$ 天，因此 $\\tau = 1/5$, 基线 $f = 0.02$, $\\mathcal{R}_0 = 1.8$, $T = 120$, $c = 0.4$, $\\varepsilon = 0.7$, $\\eta = 0.15$, $m = 1.0$。\n\n对于每个测试用例，你的程序必须计算一个包含三个值的列表 [primary_averted, secondary_averted, tertiary_averted]，每个值都是以人数表示的浮点数，并四舍五入到小数点后两位。最终的程序输出必须是单行，该行是按 A、B、C、D 顺序排列的各案例列表的列表。也就是说，你的程序应该生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如：\"[[a,b,c],[d,e,f],...]\"），其中每个数值都以人数表示，并四舍五入到小数点后两位。",
            "solution": "用户提供了一个问题，要求开发一个计算模型来模拟传染病爆发，并评估不同公共卫生干预措施的影响。该模型基于标准的易感-暴露-感染-康复（SEIR）框架，并扩展以包括隔离（无传播能力）个体和累计死亡的房室。\n\n### **问题验证**\n\n**第一步：提取已知条件**\n\n问题提供了以下数据和定义：\n\n*   **模型结构**：一个确定性房室模型，包含六个状态：易感（$S$）、暴露（$E$）、感染（$I$）、隔离（$Q$）、康复（$R$）和死亡（$D$）。状态变量代表总人口的比例，满足 $S + E + I + Q + R + D = 1$。\n*   **传播动力学**：质量作用发病项指定为 $\\beta S I$。\n*   **常微分方程组 (ODEs)**：\n    *   $S'(t) = -\\beta \\, S(t) \\, I(t)$\n    *   $E'(t) = \\beta \\, S(t) \\, I(t) - \\sigma \\, E(t)$\n    *   $I'(t) = \\sigma \\, E(t) - (\\tau + \\eta) \\, I(t)$\n    *   $Q'(t) = \\eta \\, I(t) - \\tau \\, Q(t)$\n    *   $R'(t) = \\gamma \\, I(t) + \\gamma \\, Q(t)$\n    *   $D'(t) = \\delta \\, I(t) + \\delta \\, Q(t)$\n*   **参数定义**：\n    *   $\\sigma$：从暴露态到感染态的速率，平均潜伏期为 $1/\\sigma$。\n    *   $\\tau$：从感染/隔离状态的总移除率，平均临床病程持续时间为 $1/\\tau$。\n    *   $\\tau = \\gamma + \\delta$，其中 $\\gamma$ 是康复率，$\\delta$ 是死亡率。\n    *   $f$：感染致死率（IFR），定义为 $f = \\delta / (\\gamma + \\delta) = \\delta / \\tau$。\n    *   $\\beta$：传播率。\n    *   $\\mathcal{R}_0$：基线基本再生数，定义为 $\\mathcal{R}_0 = \\beta / \\tau$。\n    *   $\\eta$：从状态 $I$ 到 $Q$ 的筛查/隔离率。\n*   **干预情景**：\n    1.  **基线**：$\\eta = 0$ 且未应用其他干预措施。\n    2.  **一级预防（疫苗接种）**：初始易感人群的一部分（比例为 $v = c \\times \\varepsilon$）转移到康复房室，其中 $c$ 是覆盖率，$\\varepsilon$ 是效力。初始条件变为 $S_{new}(0) = S(0)\\,(1 - v)$ 和 $R_{new}(0) = R(0) + S(0)\\,v$。\n    3.  **二级预防（隔离）**：筛查率 $\\eta$ 被设置为一个非零值。\n    4.  **三级预防（改善护理）**：IFR 降低一个比例 $m$，得到新的 IFR $f' = f (1 - m)$。这导致重新计算速率 $\\delta' = f' \\tau$ 和 $\\gamma' = (1 - f')\\tau$，而 $\\tau$ 和 $\\beta$ 保持不变。\n*   **数值积分**：\n    *   方法：固定步长的前向欧拉法。\n    *   时间步长：$\\Delta t = 0.1$ 天。\n*   **人口和输出**：\n    *   总人口规模 $N$。模型使用比例，最终输出为计数（人数）。\n    *   输出：对每个测试用例，输出一个包含三个值的列表：[primary\\_averted, secondary\\_averted, tertiary\\_averted]，四舍五入到小数点后两位。避免的死亡人数 = (基线死亡人数) - (干预死亡人数)。\n*   **初始条件**：$Q_0 = 0$, $D_0 = 0$。$S_0$ 从 $S_0 = N - I_0 - E_0 - R_0$ 推导得出。\n*   **测试用例**：提供了四个具体的测试用例（A、B、C、D），包含所有必需的参数。\n\n**第二步：使用提取的已知条件进行验证**\n\n*   **科学基础**：该问题牢固地植根于数学流行病学。SEIR 模型及其扩展（SEIQRD）是该领域的经典工具。对干预措施的建模——疫苗接种降低易感性、隔离减少传播、改善护理降低死亡率——是标准的、科学上有效的表述。$\\mathcal{R}_0$、$\\sigma$ 和 $\\tau$ 等参数的定义与其既定含义一致。\n*   **适定性**：该问题描述了一个常微分方程组的初值问题（IVP）。ODE 系统的右侧由状态变量的多项式组成，这些多项式在感兴趣的定义域（状态变量非负且总和为1的单纯形）上是利普希茨连续的。这保证了对于给定的一组初始条件和参数，解的存在性和唯一性。为每个测试用例提供了所有必要的参数和初始条件，使问题自洽且适定。\n*   **客观性**：问题以精确、定量的术语陈述，没有主观或偏颇的语言。\n*   **缺陷分析**：\n    1.  **科学/事实上不健全**：未检测到缺陷。该模型是一个标准的表示方法。\n    2.  **非形式化/不相关**：问题高度形式化，并直接关系到量化卫生系统科学中的预防策略。\n    3.  **不完整/矛盾的设置**：问题是完整的。为每次模拟指定了所有必要的条件和参数。\n    4.  **不切实际/不可行**：使用前向欧拉法是一种数值近似，但对于教学或基础建模目的是一个有效且标准的选择。指定的时间步长 $\\Delta t=0.1$ 足够小，可以为给定的动力学系统提供稳定且合理准确的结果。参数值在呼吸道疾病的合理范围内。\n    5.  **不适定/结构不良**：问题结构良好，定义了一个可解的 IVP。案例 C（$I_0=0, E_0=0$）代表一个有效的边界情况，即疾病不传播，导致一个平凡但正确的结果：零死亡和零避免死亡人数。\n    6.  **伪深刻/琐碎**：问题需要对数值求解器进行非平凡的实现，并仔细应用特定情景的参数更改。这是一项实质性的计算任务。\n    7.  **超出科学可验证性**：结果是计算上可复现的，因此是可验证的。\n\n**第三步：结论与行动**\n\n该问题是**有效的**，因为它是科学上合理的、适定的、客观的和完整的。将开发一个解决方案。\n\n### **基于原则的解决方案设计**\n\n该解决方案将作为一个 Python 程序实现，系统地为每个测试用例执行所需的模拟。程序的核心是一个数值 ODE 求解器，它实现前向欧拉法来近似 SEIQRD 系统随时间的演变。\n\n**1. 模型核心：ODE 求解器函数**\n\n将设计一个核心函数 `run_simulation`，用于为给定的一组参数和初始条件求解 ODE 系统。\n*   **输入**：该函数将接受初始状态比例 $(s_0, e_0, i_0, q_0, r_0, d_0)$、时间范围 $T$、时间步长 $\\Delta t$ 和模型参数 $(\\beta, \\sigma, \\tau, \\gamma, \\delta, \\eta)$。\n*   **状态表示**：系统在任何时间 $t$ 的状态，即比例向量 $[S(t), E(t), I(t), Q(t), R(t), D(t)]$，将存储在 `numpy` 数组中，以实现高效的向量运算。\n*   **积分循环**：函数将以 $\\Delta t$ 为步长从 $t=0$ 迭代到 $t=T$。在每一步中，它将：\n    a. 使用提供的 ODE 和当前状态向量计算当前时间步的导数 $(S', E', I', Q', R', D')$。\n    b. 使用前向欧拉公式更新状态向量：$\\text{state}_{k+1} = \\text{state}_k + \\Delta t \\times \\text{derivatives}_k$。为确保正确性，在更新状态向量的任何分量到第 k+1 步之前，所有导数都基于第 k 步的状态进行计算。\n*   **输出**：函数将返回最终的累计死亡比例 $D(T)$。\n\n**2. 情景模拟逻辑**\n\n对于每个测试用例，我们必须模拟四个情景：基线、一级预防、二级预防和三级预防。\n\n*   **参数校准**：首先，将根据测试用例的输入计算基本参数。\n    *   $\\sigma = 1 / \\text{incubation\\_days}$\n    *   $\\tau = 1 / \\text{infectious\\_days}$\n    *   基线传播率 $\\beta$ 使用提供的基本再生数进行校准：$\\beta = \\mathcal{R}_0 \\tau$。\n    *   基线康复率和死亡率从 IFR $f$ 推导得出：$\\delta = f \\tau$ 和 $\\gamma = (1-f)\\tau$。\n\n*   **初始条件**：初始计数 $(S_0, E_0, I_0, Q_0, R_0, D_0)$ 通过除以总人口 $N$ 转换为比例。\n\n*   **基线模拟**：使用基线参数调用 `run_simulation` 函数，特别是隔离率 $\\eta=0$。将得到的最终死亡比例存储为 $D_{baseline}$。\n\n*   **一级预防（疫苗接种）**：根据疫苗接种策略调整初始比例。疫苗诱导的有效免疫比例为 $v = c \\times \\varepsilon$。初始易感比例减少为 $s_{0, \\text{new}} = s_0 (1-v)$，初始康复比例增加为 $r_{0, \\text{new}} = r_0 + s_0 v$。然后使用这些修改后的初始条件进行模拟，但所有其他参数保持基线值。结果是 $D_{primary}$。\n\n*   **二级预防（隔离）**：使用原始的基线初始条件和参数运行模拟，但使用测试用例中指定的非零筛查率 $\\eta$。结果是 $D_{secondary}$。\n\n*   **三级预防（改善护理）**：IFR 被修改为 $f' = f(1-m)$。这需要重新计算死亡率和康复率：$\\delta' = f'\\tau$ 和 $\\gamma' = (1-f')\\tau$。注意 $\\tau$ 和 $\\beta$ 保持不变。使用基线初始条件和这些新速率 $\\delta'$ 和 $\\gamma'$ 运行模拟。结果是 $D_{tertiary}$。\n\n**3. 最终输出计算**\n\n通过将比例乘以 $N$ 获得所有四种情景的最终死亡人数后，计算每种干预措施避免的死亡人数：\n*   `primary_averted` = $(D_{baseline} - D_{primary}) \\times N$\n*   `secondary_averted` = $(D_{baseline} - D_{secondary}) \\times N$\n*   `tertiary_averted` = $(D_{baseline} - D_{tertiary}) \\times N$\n\n然后将这些值四舍五入到小数点后两位，并按规定编译成最终的输出格式。程序将按顺序处理所有测试用例，并打印包含一个列表的列表的单行。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(initial_proportions, T, dt, beta, sigma, tau, gamma, delta, eta):\n    \"\"\"\n    Simulates the SEIQRD model using the forward-Euler method.\n    \n    Args:\n        initial_proportions (tuple): Initial proportions (s0, e0, i0, q0, r0, d0).\n        T (float): Time horizon in days.\n        dt (float): Time step for numerical integration.\n        beta (float): Transmission rate.\n        sigma (float): Rate from Exposed to Infectious.\n        tau (float): Removal rate from Infectious/Isolated.\n        gamma (float): Recovery rate.\n        delta (float): Death rate.\n        eta (float): Isolation rate.\n        \n    Returns:\n        float: Final cumulative death proportion at time T.\n    \"\"\"\n    s, e, i, q, r, d = initial_proportions\n    state = np.array([s, e, i, q, r, d], dtype=np.float64)\n    \n    num_steps = int(T / dt)\n    \n    for _ in range(num_steps):\n        s_curr, e_curr, i_curr, q_curr, _, _ = state\n        \n        # Calculate derivatives based on current state\n        ds_dt = -beta * s_curr * i_curr\n        de_dt = beta * s_curr * i_curr - sigma * e_curr\n        di_dt = sigma * e_curr - (tau + eta) * i_curr\n        dq_dt = eta * i_curr - tau * q_curr\n        dr_dt = gamma * i_curr + gamma * q_curr\n        dd_dt = delta * i_curr + delta * q_curr\n        \n        derivatives = np.array([ds_dt, de_dt, di_dt, dq_dt, dr_dt, dd_dt])\n        \n        # Update state using forward-Euler method\n        state += dt * derivatives\n        \n        # Ensure proportions do not go negative due to numerical error\n        state[state  0] = 0\n        # Optional: re-normalize to 1, though for small dt it should be close\n        # state /= np.sum(state)\n\n    return state[5] # Return final death proportion\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path)\n        {'N': 1000000, 'I0': 100, 'E0': 200, 'R0': 0, 'inc_days': 3, 'inf_days': 5, \n         'f': 0.01, 'R0_val': 2.5, 'T': 180, 'c': 0.6, 'eps': 0.8, 'eta': 0.2, 'm': 0.5},\n        # Case B (primary zero coverage boundary)\n        {'N': 1000000, 'I0': 100, 'E0': 200, 'R0': 0, 'inc_days': 3, 'inf_days': 5, \n         'f': 0.01, 'R0_val': 2.5, 'T': 180, 'c': 0.0, 'eps': 0.8, 'eta': 0.2, 'm': 0.5},\n        # Case C (no initial infections edge)\n        {'N': 500000, 'I0': 0, 'E0': 0, 'R0': 0, 'inc_days': 3, 'inf_days': 5,\n         'f': 0.02, 'R0_val': 2.2, 'T': 120, 'c': 0.3, 'eps': 0.9, 'eta': 0.1, 'm': 0.3},\n        # Case D (tertiary extreme boundary)\n        {'N': 200000, 'I0': 50, 'E0': 50, 'R0': 0, 'inc_days': 3, 'inf_days': 5,\n         'f': 0.02, 'R0_val': 1.8, 'T': 120, 'c': 0.4, 'eps': 0.7, 'eta': 0.15, 'm': 1.0},\n    ]\n\n    all_results = []\n    dt = 0.1\n\n    for case in test_cases:\n        N = case['N']\n        I0, E0, R0 = case['I0'], case['E0'], case['R0']\n        Q0, D0 = 0, 0\n        S0 = N - I0 - E0 - R0 - Q0 - D0\n\n        s0, e0, i0, q0, r0, d0 = S0/N, E0/N, I0/N, Q0/N, R0/N, D0/N\n        \n        # Calculate baseline parameters\n        sigma = 1 / case['inc_days']\n        tau = 1 / case['inf_days']\n        f_base = case['f']\n        R0_base = case['R0_val']\n        \n        beta = R0_base * tau\n        gamma_base = (1 - f_base) * tau\n        delta_base = f_base * tau\n\n        # --- Baseline Scenario ---\n        final_d_base = run_simulation((s0, e0, i0, q0, r0, d0), case['T'], dt,\n                                      beta, sigma, tau, gamma_base, delta_base, eta=0)\n        deaths_base = final_d_base * N\n\n        # --- 1. Primary Prevention (Vaccination) ---\n        v = case['c'] * case['eps']\n        s0_primary = s0 * (1 - v)\n        r0_primary = r0 + s0 * v\n        initial_props_primary = (s0_primary, e0, i0, q0, r0_primary, d0)\n        final_d_primary = run_simulation(initial_props_primary, case['T'], dt,\n                                         beta, sigma, tau, gamma_base, delta_base, eta=0)\n        deaths_primary = final_d_primary * N\n        primary_averted = deaths_base - deaths_primary\n\n        # --- 2. Secondary Prevention (Isolation) ---\n        eta_interv = case['eta']\n        final_d_secondary = run_simulation((s0, e0, i0, q0, r0, d0), case['T'], dt,\n                                           beta, sigma, tau, gamma_base, delta_base, eta=eta_interv)\n        deaths_secondary = final_d_secondary * N\n        secondary_averted = deaths_base - secondary_averted\n\n        # --- 3. Tertiary Prevention (Improved Care) ---\n        m = case['m']\n        f_tertiary = f_base * (1 - m)\n        gamma_tertiary = (1 - f_tertiary) * tau\n        delta_tertiary = f_tertiary * tau\n        final_d_tertiary = run_simulation((s0, e0, i0, q0, r0, d0), case['T'], dt,\n                                          beta, sigma, tau, gamma_tertiary, delta_tertiary, eta=0)\n        deaths_tertiary = final_d_tertiary * N\n        tertiary_averted = deaths_base - deaths_tertiary\n\n        case_results = [\n            round(primary_averted, 2),\n            round(secondary_averted, 2),\n            round(tertiary_averted, 2)\n        ]\n        all_results.append(case_results)\n    \n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{res[0]:.2f},{res[1]:.2f},{res[2]:.2f}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}