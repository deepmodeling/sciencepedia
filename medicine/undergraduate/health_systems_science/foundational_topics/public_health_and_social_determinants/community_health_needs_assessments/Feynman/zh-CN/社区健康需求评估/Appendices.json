{
    "hands_on_practices": [
        {
            "introduction": "在比较不同社区（例如，一个以退休人员为主的社区和一个大学城）的健康指标时，原始率（或粗率）可能会产生误导，因为这些社区的人口年龄结构截然不同。为了进行公平的比较，我们需要消除年龄作为混杂因素的影响。本练习将指导您完成直接年龄标化的计算 ，这是一项在社区健康需求评估中用于准确比较健康结果的核心流行病学技能，它能让我们创建一个“公平的竞争环境”来揭示潜在的健康风险差异。",
            "id": "4364090",
            "problem": "某市卫生部门的一项社区健康需求评估 (CHNA) 旨在比较各社区间哮喘相关急诊科 (ED) 就诊的负担，同时考虑年龄结构的差异。为分离出与年龄分布无关的潜在风险，请使用直接法和2000年美国标准人口数据，计算该市的直接年龄标化哮喘急诊就诊率。使用以下信息：\n\n- 年龄组、城市人口分母以及年度哮喘急诊就诊次数：\n  - 年龄 $0$–$17$岁：人口 $= 52{,}000$，急诊就诊 $= 780$。\n  - 年龄 $18$–$44$岁：人口 $= 95{,}000$，急诊就诊 $= 600$。\n  - 年龄 $45$–$64$岁：人口 $= 61{,}000$，急诊就诊 $= 500$。\n  - 年龄 $\\ge 65$岁：人口 $= 28{,}000$，急诊就诊 $= 420$。\n\n- 使用汇总至上述年龄组的2000年美国标准人口权重：\n  - 年龄 $0$–$17$岁：权重 $w_1 = 0.26$。\n  - 年龄 $18$–$44$岁：权重 $w_2 = 0.39$。\n  - 年龄 $45$–$64$岁：权重 $w_3 = 0.23$。\n  - 年龄 $\\ge 65$岁：权重 $w_4 = 0.12$。\n\n从核心定义出发，计算每 $10{,}000$ 人口的直接年龄标化年度哮喘急诊就诊率。然后，在急诊就诊次数服从大样本泊松分布且各年龄分层相互独立的假设下，为该直接标化率构建一个 $95\\%$ 的置信区间 (CI)。\n\n说明：\n- 以每 $10,000$ 人口为单位，表示最终的年龄标化率以及 $95\\%$ 置信区间的下限和上限。\n- 将报告的三个数字全部四舍五入至四位有效数字。\n- 按以下顺序报告你的最终结果：标化率、下限、上限。",
            "solution": "该问题被评估为可解。它在科学上基于标准的流行病学方法（直接年龄标化），提法明确，提供了所有必要信息，并且表述客观。提供的标准人口权重总和为 $1$ ($0.26 + 0.39 + 0.23 + 0.12 = 1.00$)，所有数据都一致且符合实际。所要求的计算是生物统计学中的标准程序。\n\n设索引 $i$ 代表年龄分层，其中 $i \\in \\{1, 2, 3, 4\\}$。\n给定数据如下：\n- 对于分层 $i=1$ (年龄 $0$–$17$岁)：计数 $C_1 = 780$，人口 $N_1 = 52,000$，标准权重 $w_1 = 0.26$。\n- 对于分层 $i=2$ (年龄 $18$–$44$岁)：计数 $C_2 = 600$，人口 $N_2 = 95,000$，标准权重 $w_2 = 0.39$。\n- 对于分层 $i=3$ (年龄 $45$–$64$岁)：计数 $C_3 = 500$，人口 $N_3 = 61,000$，标准权重 $w_3 = 0.23$。\n- 对于分层 $i=4$ (年龄 $\\ge 65$岁)：计数 $C_4 = 420$，人口 $N_4 = 28,000$，标准权重 $w_4 = 0.12$。\n\n任务是计算直接年龄标化率 (DASR) 及其 $95\\%$ 置信区间 (CI)。\n\n首先，我们计算每个分层 $i$ 的年龄别率 $r_i$。年龄别率是该分层中的事件数（急诊就诊次数）除以该分层的人口规模。\n$$r_i = \\frac{C_i}{N_i}$$\n四个分层的率如下：\n$$r_1 = \\frac{780}{52,000} = 0.015$$\n$$r_2 = \\frac{600}{95,000} \\approx 0.00631579$$\n$$r_3 = \\frac{500}{61,000} \\approx 0.00819672$$\n$$r_4 = \\frac{420}{28,000} = 0.015$$\n\n直接年龄标化率是各年龄别率的加权平均值，其中权重来自标准人口。DASR 的计算公式为：\n$$\\text{DASR} = \\sum_{i=1}^{4} w_i r_i$$\n代入数值：\n$$\\text{DASR} = (0.26)(0.015) + (0.39)\\left(\\frac{600}{95,000}\\right) + (0.23)\\left(\\frac{500}{61,000}\\right) + (0.12)(0.015)$$\n$$\\text{DASR} \\approx (0.26)(0.015) + (0.39)(0.00631579) + (0.23)(0.00819672) + (0.12)(0.015)$$\n$$\\text{DASR} \\approx 0.0039 + 0.00246316 + 0.00188525 + 0.0018$$\n$$\\text{DASR} \\approx 0.01004841$$\n为将此率表示为每 $10,000$ 人口的比率，我们乘以 $10,000$：\n$$\\text{DASR}_{\\text{per } 10,000} = 0.01004841 \\times 10,000 = 100.4841$$\n\n接下来，我们为 DASR 构建 $95\\%$ 的置信区间。在事件数 $C_i$ 服从泊松分布的假设下，年龄别率 $r_i$ 的方差估计为：\n$$\\text{Var}(r_i) \\approx \\frac{C_i}{N_i^2}$$\n由于各年龄分层是独立的，DASR（即 $r_i$ 的线性组合）的方差是加权方差之和：\n$$\\text{Var}(\\text{DASR}) = \\sum_{i=1}^{4} w_i^2 \\text{Var}(r_i) \\approx \\sum_{i=1}^{4} \\frac{w_i^2 C_i}{N_i^2}$$\n我们逐项计算这个和：\n$$\\text{Var}(\\text{DASR}) \\approx \\frac{0.26^2 \\times 780}{52,000^2} + \\frac{0.39^2 \\times 600}{95,000^2} + \\frac{0.23^2 \\times 500}{61,000^2} + \\frac{0.12^2 \\times 420}{28,000^2}$$\n$$\\text{Var}(\\text{DASR}) \\approx \\frac{52.728}{2,704,000,000} + \\frac{91.26}{9,025,000,000} + \\frac{26.45}{3,721,000,000} + \\frac{6.048}{784,000,000}$$\n$$\\text{Var}(\\text{DASR}) \\approx 1.9485 \\times 10^{-8} + 1.0112 \\times 10^{-8} + 0.7108 \\times 10^{-8} + 0.7714 \\times 10^{-8}$$\n$$\\text{Var}(\\text{DASR}) \\approx 4.4419 \\times 10^{-8}$$\nDASR 的标准误 (SE) 是其方差的平方根：\n$$\\text{SE}(\\text{DASR}) = \\sqrt{\\text{Var}(\\text{DASR})} \\approx \\sqrt{4.4419 \\times 10^{-8}} \\approx 2.1076 \\times 10^{-4}$$\n\n对于大样本，使用正态近似构建 $95\\%$ 置信区间：\n$$\\text{CI} = \\text{DASR} \\pm Z_{1-\\alpha/2} \\times \\text{SE}(\\text{DASR})$$\n对于 $95\\%$ 的置信区间，$\\alpha=0.05$，临界值为 $Z_{0.975} = 1.96$。\n误差范围 (ME) 是：\n$$\\text{ME} = 1.96 \\times \\text{SE}(\\text{DASR}) \\approx 1.96 \\times 2.1076 \\times 10^{-4} \\approx 4.1309 \\times 10^{-4}$$\nDASR 置信区间的下限和上限为：\n$$\\text{Lower Bound} = \\text{DASR} - \\text{ME} \\approx 0.01004841 - 0.00041309 = 0.00963532$$\n$$\\text{Upper Bound} = \\text{DASR} + \\text{ME} \\approx 0.01004841 + 0.00041309 = 0.01046150$$\n\n为将这些界限表示为每 $10,000$ 人口的比率，我们乘以 $10,000$：\n$$\\text{Lower Bound}_{\\text{per } 10,000} = 0.00963532 \\times 10,000 = 96.3532$$\n$$\\text{Upper Bound}_{\\text{per } 10,000} = 0.01046150 \\times 10,000 = 104.6150$$\n\n最后，我们按照要求将标化率和置信区间界限四舍五入到四位有效数字：\n- 标化率：$100.4841 \\to 100.5$\n- 下限：$96.3532 \\to 96.35$\n- 上限：$104.6150 \\to 104.6$\n\n所要求的三个数字分别是标化率、下限和上限，均以每 $10,000$ 人口计。",
            "answer": "$$\\boxed{\\begin{pmatrix} 100.5  96.35  104.6 \\end{pmatrix}}$$"
        },
        {
            "introduction": "社区健康需求评估不仅依赖于数字，也同样依赖于来自访谈、焦点小组和开放式调查问卷的定性数据。为了确保这些叙述性数据的可信度，我们必须证明不同的研究人员能以一致的方式对其进行解释和编码。本练习将向您介绍科恩卡帕系数（Cohen's Kappa） ，这是一个衡量评分者间信度的黄金标准，它可以量化超出偶然一致性之外的真实一致性程度，从而确保我们定性分析的严谨性。",
            "id": "4364053",
            "problem": "一个医院系统进行了一项社区健康需求评估 (CHNA)，并对社区提交的关于心理健康服务可及性的评论进行定性编码。两名独立的编码员将每条评论分配到两个类别之一：“高优先级”或“非高优先级”。没有缺失的编码。由此产生的编码员决策的 $2 \\times 2$ 列联表总结如下：\n- 两名编码员都标记为“高优先级”：$68$。\n- 编码员 $1$ 标记为“高优先级”，编码员 $2$ 标记为“非高优先级”：$22$。\n- 编码员 $1$ 标记为“非高优先级”，编码员 $2$ 标记为“高优先级”：$14$。\n- 两名编码员都标记为“非高优先级”：$96$。\n\n使用科恩卡帕系数（Cohen's kappa）作为超出偶然性的一致性的核心定义，其中偶然一致性是根据独立性模型下边际类别比例的乘积计算的，请计算此编码任务的评估者间一致性的科恩卡帕系数。将您的最终答案表示为无单位小数，并四舍五入到 $4$ 位有效数字。",
            "solution": "该问题要求计算两位编码员之间评估者间一致性的科恩卡帕系数 ($\\kappa$)。科恩卡帕系数的计算公式为：\n$$ \\kappa = \\frac{P_o - P_e}{1 - P_e} $$\n其中 $P_o$ 是观察到的一致性比例，$P_e$ 是偶然预期的一致性比例。\n\n首先，我们将提供的数据整理成一个 $2 \\times 2$ 列联表。令“高优先级”表示为 HP，“非高优先级”表示为 NHP。单元格计数如下：\n- $a$: 两名编码员都评为 HP。$a=68$。\n- $b$: 编码员 $1$ 评为 HP，编码员 $2$ 评为 NHP。$b=22$。\n- $c$: 编码员 $1$ 评为 NHP，编码员 $2$ 评为 HP。$c=14$。\n- $d$: 两名编码员都评为 NHP。$d=96$。\n\n被评级的项目总数 $N$ 是所有单元格计数的总和：\n$$ N = a + b + c + d = 68 + 22 + 14 + 96 = 200 $$\n\n接下来，我们计算观察到的一致性比例 $P_o$。这是编码员达成一致的项目的比例。一致性出现在单元格 $a$ 和 $d$ 中。\n$$ P_o = \\frac{a + d}{N} = \\frac{68 + 96}{200} = \\frac{164}{200} = 0.82 $$\n\n现在，我们计算偶然预期的一致性 $P_e$。这是在假设两位编码员的评级相互独立的情况下计算的。我们首先需要每位编码员对每个类别的边际总计。\n- 编码员 $1$ 评为 HP 的数量：$N_{\\text{HP1}} = a + b = 68 + 22 = 90$。\n- 编码员 $1$ 评为 NHP 的数量：$N_{\\text{NHP1}} = c + d = 14 + 96 = 110$。\n- 编码员 $2$ 评为 HP 的数量：$N_{\\text{HP2}} = a + c = 68 + 14 = 82$。\n- 编码员 $2$ 评为 NHP 的数量：$N_{\\text{NHP2}} = b + d = 22 + 96 = 118$。\n\n两名编码员偶然将一个项目评为 HP 的概率是他们各自将一个项目评为 HP 的概率的乘积：\n$$ P_e(\\text{HP}) = \\left(\\frac{N_{\\text{HP1}}}{N}\\right) \\times \\left(\\frac{N_{\\text{HP2}}}{N}\\right) = \\left(\\frac{90}{200}\\right) \\times \\left(\\frac{82}{200}\\right) $$\n两名编码员偶然将一个项目评为 NHP 的概率是：\n$$ P_e(\\text{NHP}) = \\left(\\frac{N_{\\text{NHP1}}}{N}\\right) \\times \\left(\\frac{N_{\\text{NHP2}}}{N}\\right) = \\left(\\frac{110}{200}\\right) \\times \\left(\\frac{118}{200}\\right) $$\n\n总的预期一致性 $P_e$ 是这些概率的总和：\n$$ P_e = P_e(\\text{HP}) + P_e(\\text{NHP}) = \\frac{(90 \\times 82) + (110 \\times 118)}{200^2} $$\n$$ P_e = \\frac{7380 + 12980}{40000} = \\frac{20360}{40000} = 0.509 $$\n\n最后，我们将 $P_o$ 和 $P_e$ 的值代入科恩卡帕系数的公式中：\n$$ \\kappa = \\frac{P_o - P_e}{1 - P_e} = \\frac{0.82 - 0.509}{1 - 0.509} = \\frac{0.311}{0.491} $$\n进行除法运算：\n$$ \\kappa \\approx 0.63340122199... $$\n问题要求结果四舍五入到 $4$ 位有效数字。\n$$ \\kappa \\approx 0.6334 $$",
            "answer": "$$\\boxed{0.6334}$$"
        },
        {
            "introduction": "社区健康需求评估的最终目标是确定优先事项，但这往往是一个复杂的决策过程，因为需要权衡多个相互冲突的标准。多标准决策分析（MCDA）提供了一个结构化、透明的方法，用于系统地权衡不同因素（如问题规模、严重性、可行性、社区偏好等），并对健康需求进行合乎逻辑的排序。在本练习  中，您将构建一个实用的MCDA模型，以模拟如何利用多源数据做出明智的优先级决策。",
            "id": "4364052",
            "problem": "一个卫生系统必须使用多标准决策分析框架来确定社区健康需求的优先级。每个健康需求由五个标准来表征：影响范围、严重性、差异性、可行性和社区偏好。决策的基础是植根于效用理论的价值函数模型：当各属性相互之间偏好独立时，存在一个可加性多属性价值函数，可以合理地聚合特定标准的价值。\n\n该模型的定义和假设如下：\n- 影响范围 ($x_{\\text{mag}}$)：受影响的人数，单位为人。\n- 严重性 ($x_{\\text{sev}}$)：专家在 $0$ 到 $10$ 的有界量表上的评分。\n- 差异性 ($x_{\\text{disp}}$)：目标亚群体的比率与参照群体的比率之比，为一个无量纲比率，且 $x_{\\text{disp}} \\ge 1$。\n- 可行性 ($x_{\\text{feas}}$)：成功实施的估计概率，在 $[0,1]$ 区间内，以小数表示。\n- 社区偏好 ($x_{\\text{pref}}$)：在被调查的受访者中，支持优先考虑该项需求的人数比例，在 $[0,1]$ 区间内，以小数表示。\n\n设 $v_j(\\cdot)$ 表示特定标准的价值转换函数，它将原始测量值映射到一个在 $[0,1]$ 区间内的统一标度上，并具有单调递增的偏好（值越大越好）。需求 $i$ 的总价值（优先级得分）建模为\n$$\nU_i = \\sum_{j=1}^{5} w_j \\, v_j\\!\\left(x_{ij}\\right),\n$$\n其中 $w_j \\ge 0$ 是标准权重，满足 $\\sum_{j=1}^{5} w_j = 1$。\n\n您必须构建以下归一化方案以实现可比性：\n- 对于影响范围，使用对数调整的最小-最大变换来处理重尾计数：\n$$\nv_{\\text{mag}}(x) = \n\\begin{cases}\n\\dfrac{\\log(1+x) - \\log(1+x_{\\min})}{\\log(1+x_{\\max}) - \\log(1+x_{\\min})}  \\text{if } \\log(1+x_{\\max}) \\neq \\log(1+x_{\\min}) \\\\\n0.5  \\text{otherwise}\n\\end{cases}\n$$\n其中 $x_{\\min}$ 和 $x_{\\max}$ 是在给定测试用例中观测到的影响范围值的最小值和最大值。\n- 对于严重性，对其已知边界使用线性缩放：\n$$\nv_{\\text{sev}}(s) = \\dfrac{s}{10}.\n$$\n- 对于差异性，使用对数调整的最小-最大变换来考虑乘法差异：\n$$\nv_{\\text{disp}}(r) = \n\\begin{cases}\n\\dfrac{\\log(r) - \\log(r_{\\min})}{\\log(r_{\\max}) - \\log(r_{\\min})}  \\text{if } \\log(r_{\\max}) \\neq \\log(r_{\\min}) \\\\\n0.5  \\text{otherwise}\n\\end{cases}\n$$\n其中 $r_{\\min}$ 和 $r_{\\max}$ 是在给定测试用例中观测到的差异性比率的最小值和最大值。\n- 对于可行性，在 $[0,1]$ 上使用恒等变换：\n$$\nv_{\\text{feas}}(f) = f.\n$$\n- 对于社区偏好，在 $[0,1]$ 上使用恒等变换：\n$$\nv_{\\text{pref}}(p) = p.\n$$\n\n当任何最小-最大变换的分母为零时（即在某个测试用例中，该标准的所有观测值都相等），则将该标准下所有备选项的归一化值定义为 $0.5$。对需求使用基于 $0$ 的索引，并通过选择最小的索引来打破平局。\n\n您的任务是实现此归一化方案，并计算以下测试套件中每个需求的 $U_i$。对于每个测试用例，输出具有最高优先级的单个需求的索引。\n\n测试套件：\n- 测试用例 1 （权重 $w = [0.3, 0.25, 0.2, 0.15, 0.1]$）：\n  - 影响范围（人）：$[8500, 12000, 3000, 9500]$\n  - 严重性（$0$–$10$）：$[7.5, 6.0, 5.5, 8.0]$\n  - 差异性比率（$\\ge 1$）：$[1.8, 1.2, 2.5, 1.4]$\n  - 可行性（小数）：$[0.7, 0.9, 0.6, 0.5]$\n  - 偏好（小数）：$[0.65, 0.55, 0.80, 0.60]$\n- 测试用例 2 （权重 $w = [0.25, 0.20, 0.30, 0.15, 0.10]$）：\n  - 影响范围（人）：$[50000, 900, 2500, 4000]$\n  - 严重性（$0$–$10$）：$[9.0, 4.0, 6.5, 7.0]$\n  - 差异性比率（$\\ge 1$）：$[1.1, 2.0, 3.2, 1.5]$\n  - 可行性（小数）：$[0.4, 0.8, 0.6, 0.7]$\n  - 偏好（小数）：$[0.50, 0.70, 0.60, 0.55]$\n- 测试用例 3 （权重 $w = [0.2, 0.2, 0.2, 0.2, 0.2]$）：\n  - 影响范围（人）：$[2000, 2000, 2000, 2000]$\n  - 严重性（$0$–$10$）：$[5.0, 5.0, 5.0, 5.0]$\n  - 差异性比率（$\\ge 1$）：$[1.0, 1.0, 1.0, 1.0]$\n  - 可行性（小数）：$[0.2, 0.4, 0.6, 0.8]$\n  - 偏好（小数）：$[0.1, 0.2, 0.3, 0.4]$\n- 测试用例 4 （权重 $w = [0.35, 0.25, 0.20, 0.10, 0.10]$）：\n  - 影响范围（人）：$[0, 750, 1500]$\n  - 严重性（$0$–$10$）：$[8.5, 7.0, 3.0]$\n  - 差异性比率（$\\ge 1$）：$[1.7, 1.3, 2.1]$\n  - 可行性（小数）：$[0.3, 0.9, 0.2]$\n  - 偏好（小数）：$[0.0, 0.6, 0.4]$\n\n您的程序必须计算归一化的标准值，通过加权求和将其聚合以获得每个测试用例中每个需求的 $U_i$，然后报告每个测试用例中最高 $U_i$ 的索引。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[0,2,1,3]$）。不需要用户输入。",
            "solution": "该问题提出了一个用于确定社区健康需求优先级的多标准决策分析（MCDA）框架。该方法基于可加性多属性价值函数，这是当标准之间满足相互偏好独立性假设时决策理论中的一种标准技术。我们的任务是实现这个模型，计算几个测试用例中每个健康需求的优先级得分，并找出每个案例中得分最高的需求。\n\n对于给定的健康需求 $i$，其总价值或优先级得分 $U_i$ 是通过其在五个标准上表现的加权和来计算的：\n$$\nU_i = \\sum_{j=1}^{5} w_j \\, v_j\\!\\left(x_{ij}\\right)\n$$\n在这里，$x_{ij}$ 是需求 $i$ 在标准 $j$ 上的原始得分，$v_j(\\cdot)$ 是一个特定标准的价值函数，它将原始得分归一化到 $[0, 1]$ 的通用标度上，$w_j$ 是标准 $j$ 的权重，其中 $w_j \\ge 0$ 且 $\\sum_j w_j = 1$。这些标准是影响范围 ($x_{\\text{mag}}$)、严重性 ($x_{\\text{sev}}$)、差异性 ($x_{\\text{disp}}$)、可行性 ($x_{\\text{feas}}$) 和社区偏好 ($x_{\\text{pref}}$)。\n\n对于每个测试用例，该过程包括三个主要步骤：\n1.  应用指定的价值函数 $v_j(\\cdot)$ 对所有相互竞争的健康需求在每个标准上的原始数据进行归一化。\n2.  使用提供的权重聚合每个需求的归一化值，以计算总优先级得分 $U_i$。\n3.  识别具有最大得分 $U_i$ 的健康需求的索引，使用最小索引作为平局决胜规则。\n\n价值函数 $v_j(\\cdot)$ 的定义如下：\n\n**1. 影响范围 ($v_{\\text{mag}}$)：**\n对于受影响的人数 $x$，采用对数调整的最小-最大归一化方法。使用变换 $x \\to \\log(1+x)$ 来处理潜在的重尾分布计数，并确保在 $x=0$ 时对数有定义。\n价值函数为：\n$$\nv_{\\text{mag}}(x) = \\frac{\\log(1+x) - \\log(1+x_{\\min})}{\\log(1+x_{\\max}) - \\log(1+x_{\\min})}\n$$\n其中 $x_{\\min}$ 和 $x_{\\max}$ 是在待比较的需求集合中观测到的影响范围值的最小值和最大值。如果所有需求的影响范围都相同 ($x_{\\min} = x_{\\max}$)，则分母变为零。在这种情况下，所有需求的归一化值都定义为 $0.5$，表示该标准做出了中性或平均的贡献。\n\n**2. 严重性 ($v_{\\text{sev}}$)：**\n严重性 $s$ 是专家在 $0$ 到 $10$ 的固定量表上的评分。它使用相对于其理论边界的线性缩放进行归一化：\n$$\nv_{\\text{sev}}(s) = \\frac{s}{10}\n$$\n这将得分转换到所需的 $[0, 1]$ 区间。\n\n**3. 差异性 ($v_{\\text{disp}}$)：**\n差异性 $r$ 是一个比率，其乘法差异比加法差异更有意义。因此，使用对数最小-最大归一化：\n$$\nv_{\\text{disp}}(r) = \\frac{\\log(r) - \\log(r_{\\min})}{\\log(r_{\\max}) - \\log(r_{\\min})}\n$$\n其中 $r_{\\min}$ 和 $r_{\\max}$ 是观测到的差异性比率的最小值和最大值。由于 $r \\ge 1$，$\\log(r)$ 是良定义且非负的。与影响范围类似，如果所有差异性值都相等 ($r_{\\min} = r_{\\max}$)，则归一化值设为 $0.5$。\n\n**4. 可行性 ($v_{\\text{feas}}$) 和社区偏好 ($v_{\\text{pref}}$)：**\n可行性 $f$ 和社区偏好 $p$ 都以 $[0,1]$ 区间内的值给出（分别是一个概率和一个分数）。由于它们已经处于所需的通用标度上，因此使用恒等函数进行其价值转换：\n$$\nv_{\\text{feas}}(f) = f \\\\\nv_{\\text{pref}}(p) = p\n$$\n\n**计算流程：**\n对于每个测试用例，为了提高效率，我们将使用向量化操作执行以下计算。\n假设 $N$ 个需求和 $5$ 个标准的原始数据由一个 $N \\times 5$ 的原始得分矩阵表示。我们将生成一个 $N \\times 5$ 的归一化值矩阵 $V$，其中每个元素 $V_{ij} = v_j(x_{ij})$。\n1.  对于 `magnitude` 列，确定 $x_{\\min}$ 和 $x_{\\max}$。应用 $v_{\\text{mag}}$ 公式以获得 $V$ 的第一列。\n2.  对于 `severity` 列，应用 $v_{\\text{sev}}$ 公式以获得 $V$ 的第二列。\n3.  对于 `disparity` 列，确定 $r_{\\min}$ 和 $r_{\\max}$。应用 $v_{\\text{disp}}$ 公式以获得 $V$ 的第三列。\n4.  `feasibility` 和 `preference` 列直接构成 $V$ 的第四和第五列。\n5.  然后，通过计算归一化值矩阵 $V$ 和权重向量 $w$ 的矩阵-向量乘积，在单次操作中计算所有需求的优先级得分：\n    $$\n    \\mathbf{U} = V \\mathbf{w}\n    $$\n    其中 $\\mathbf{U}$ 是一个 $N \\times 1$ 的优先级得分向量。\n6.  最后，我们找到向量 $\\mathbf{U}$ 中最大值的基于 $0$ 的索引。`argmax` 函数返回最大值首次出现的索引，自然地处理了指定的平局决胜规则。对于问题陈述中提供的每个测试用例，重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the multi-criteria decision analysis model to prioritize\n    community health needs based on the specified value functions and weights.\n    \"\"\"\n    test_cases = [\n        {\n            \"weights\": [0.3, 0.25, 0.2, 0.15, 0.1],\n            \"data\": {\n                \"mag\": [8500, 12000, 3000, 9500],\n                \"sev\": [7.5, 6.0, 5.5, 8.0],\n                \"disp\": [1.8, 1.2, 2.5, 1.4],\n                \"feas\": [0.7, 0.9, 0.6, 0.5],\n                \"pref\": [0.65, 0.55, 0.80, 0.60],\n            }\n        },\n        {\n            \"weights\": [0.25, 0.20, 0.30, 0.15, 0.10],\n            \"data\": {\n                \"mag\": [50000, 900, 2500, 4000],\n                \"sev\": [9.0, 4.0, 6.5, 7.0],\n                \"disp\": [1.1, 2.0, 3.2, 1.5],\n                \"feas\": [0.4, 0.8, 0.6, 0.7],\n                \"pref\": [0.50, 0.70, 0.60, 0.55],\n            }\n        },\n        {\n            \"weights\": [0.2, 0.2, 0.2, 0.2, 0.2],\n            \"data\": {\n                \"mag\": [2000, 2000, 2000, 2000],\n                \"sev\": [5.0, 5.0, 5.0, 5.0],\n                \"disp\": [1.0, 1.0, 1.0, 1.0],\n                \"feas\": [0.2, 0.4, 0.6, 0.8],\n                \"pref\": [0.1, 0.2, 0.3, 0.4],\n            }\n        },\n        {\n            \"weights\": [0.35, 0.25, 0.20, 0.10, 0.10],\n            \"data\": {\n                \"mag\": [0, 750, 1500],\n                \"sev\": [8.5, 7.0, 3.0],\n                \"disp\": [1.7, 1.3, 2.1],\n                \"feas\": [0.3, 0.9, 0.2],\n                \"pref\": [0.0, 0.6, 0.4],\n            }\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        weights = np.array(case[\"weights\"])\n        data = case[\"data\"]\n        \n        mag = np.array(data[\"mag\"], dtype=float)\n        sev = np.array(data[\"sev\"], dtype=float)\n        disp = np.array(data[\"disp\"], dtype=float)\n        feas = np.array(data[\"feas\"], dtype=float)\n        pref = np.array(data[\"pref\"], dtype=float)\n\n        num_needs = len(mag)\n        \n        # 1. Normalize Magnitude\n        mag_min, mag_max = np.min(mag), np.max(mag)\n        if np.isclose(mag_min, mag_max):\n            v_mag = np.full(num_needs, 0.5)\n        else:\n            log_mag = np.log(1 + mag)\n            log_min = np.log(1 + mag_min)\n            log_max = np.log(1 + mag_max)\n            v_mag = (log_mag - log_min) / (log_max - log_min)\n\n        # 2. Normalize Severity\n        v_sev = sev / 10.0\n        \n        # 3. Normalize Disparity\n        disp_min, disp_max = np.min(disp), np.max(disp)\n        if np.isclose(disp_min, disp_max):\n            v_disp = np.full(num_needs, 0.5)\n        else:\n            log_disp = np.log(disp)\n            log_min = np.log(disp_min)\n            log_max = np.log(disp_max)\n            v_disp = (log_disp - log_min) / (log_max - log_min)\n\n        # 4. Feasibility (Identity)\n        v_feas = feas\n\n        # 5. Preference (Identity)\n        v_pref = pref\n\n        # Assemble the normalized value matrix V\n        V = np.stack([v_mag, v_sev, v_disp, v_feas, v_pref], axis=1)\n\n        # Calculate priority scores U\n        U = V @ weights\n\n        # Find the index of the highest score\n        highest_priority_idx = np.argmax(U)\n        results.append(highest_priority_idx)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}