{
    "hands_on_practices": [
        {
            "introduction": "评估任何人口健康干预措施的第一步是量化其效果。本练习将通过一个结直肠癌筛查项目的假设场景，引导您计算和解释关键的流行病学指标。通过实践计算风险比（$RR$）、比值比（$OR$）和风险差（$RD$），您将学会如何从不同角度衡量干预措施的影响力，并理解这些指标在卫生资源配置决策中的独特价值。",
            "id": "4389588",
            "problem": "一个卫生系统科学团队正在评估一项群体健康管理策略：在一个特定队列中实施的有组织的结直肠癌筛查项目。对两个可比较的人群进行了一年的随访：受邀参加筛查的人群（干预组）和未受邀的人群（对照组）。关注的结局是一年内诊断为晚期结直肠癌。\n\n干预组队列有 $12{,}000$ 人，其中有 $180$ 例晚期诊断。对照组队列有 $8{,}000$ 人，其中有 $240$ 例晚期诊断。仅使用概率（风险）和比值的基本原理定义，计算干预组相对于对照组的晚期诊断风险比（RR）、比值比（OR）和风险差（RD）。对于比率指标，将“相对于”解释为干预组的指标除以对照组的指标；对于差异指标，则解释为干预组的指标减去对照组的指标。将每个数值结果四舍五入至四位有效数字，并以小数形式表示，不带百分号。\n\n最后，从基本原理出发，解释在何种情境下，每种指标（RR、OR、RD）最适合用于群体健康管理决策，需考虑研究设计、可解释性以及资源分配决策。",
            "solution": "首先对问题陈述进行验证。\n\n### 步骤1：提取已知信息\n- 干预组队列规模：$12{,}000$ 人。\n- 干预组中的晚期诊断数：$180$。\n- 对照组队列规模：$8{,}000$ 人。\n- 对照组中的晚期诊断数：$240$。\n- 结局：一年内诊断为晚期结直肠癌。\n- 要求计算：风险比（RR）、比值比（OR）和风险差（RD）。\n- RR的定义：干预组的风险除以对照组的风险。\n- OR的定义：干预组的比值除以对照组的比值。\n- RD的定义：干预组的风险减去对照组的风险。\n- 要求精度：将每个结果四舍五入至四位有效数字，以小数表示。\n- 要求解释：RR、OR和RD在何种情境下最适合用于群体健康管理决策。\n\n### 步骤2：使用提取的已知信息进行验证\n该问题具有科学依据。它呈现了一个标准的流行病学情景（队列研究），并要求计算基本的关联性度量指标（RR、OR、RD）。风险、比值以及它们各自的比率和差异是流行病学和卫生系统科学的基石。该问题提法明确，因为计算所需的所有数据均已提供，并且所需指标的定义也已明确说明。语言客观而精确。该问题是自洽的，没有违反任何科学或数学原理。数据值对于大规模的群体健康研究是合理的。\n\n### 步骤3：结论与行动\n该问题有效。将提供完整的解答。\n\n### 解答\n我们来定义两个队列的变量。\n对于干预组（下标 `int`）：\n- 总人数：$N_{int} = 12000$\n- 晚期诊断数（事件）：$D_{int} = 180$\n- 无晚期诊断数（非事件）：$H_{int} = N_{int} - D_{int} = 12000 - 180 = 11820$\n\n对于对照组（下标 `comp`）：\n- 总人数：$N_{comp} = 8000$\n- 晚期诊断数（事件）：$D_{comp} = 240$\n- 无晚期诊断数（非事件）：$H_{comp} = N_{comp} - D_{comp} = 8000 - 240 = 7760$\n\n根据基本原理，风险是群体中发生某一事件的概率。\n干预组的风险：\n$$R_{int} = P(\\text{Diagnosis} | \\text{Intervention}) = \\frac{D_{int}}{N_{int}} = \\frac{180}{12000} = 0.015$$\n对照组的风险：\n$$R_{comp} = P(\\text{Diagnosis} | \\text{Comparison}) = \\frac{D_{comp}}{N_{comp}} = \\frac{240}{8000} = 0.03$$\n\n根据基本原理，比值是事件发生的概率与不发生的概率之比。\n干预组的比值：\n$$O_{int} = \\frac{P(\\text{Diagnosis} | \\text{Intervention})}{1 - P(\\text{Diagnosis} | \\text{Intervention})} = \\frac{R_{int}}{1 - R_{int}} = \\frac{D_{int}}{H_{int}} = \\frac{180}{11820}$$\n对照组的比值：\n$$O_{comp} = \\frac{P(\\text{Diagnosis} | \\text{Comparison})}{1 - P(\\text{Diagnosis} | \\text{Comparison})} = \\frac{R_{comp}}{1 - R_{comp}} = \\frac{D_{comp}}{H_{comp}} = \\frac{240}{7760}$$\n\n现在，我们计算所需的指标：风险比（RR）、比值比（OR）和风险差（RD）。\n\n**1. 风险比（RR）**\n风险比是干预组的风险与对照组的风险之比。\n$$RR = \\frac{R_{int}}{R_{comp}} = \\frac{0.015}{0.03} = 0.5$$\n四舍五入至四位有效数字得到 $0.5000$。\n\n**2. 比值比（OR）**\n比值比是干预组的比值与对照组的比值之比。\n$$OR = \\frac{O_{int}}{O_{comp}} = \\frac{D_{int} / H_{int}}{D_{comp} / H_{comp}} = \\frac{180 / 11820}{240 / 7760} = \\frac{180 \\times 7760}{11820 \\times 240} = \\frac{1396800}{2836800} \\approx 0.4923857...$$\n四舍五入至四位有效数字得到 $0.4924$。\n\n**3. 风险差（RD）**\n风险差是干预组和对照组之间风险的绝对差异。\n$$RD = R_{int} - R_{comp} = 0.015 - 0.03 = -0.015$$\n四舍五入至四位有效数字得到 $-0.01500$。\n\n### 各指标的适用性\nRR、OR 和 RD 之间的选择取决于研究设计、期望的解释以及群体健康管理中要解决的具体问题。\n\n**风险比（RR）**\n- **情境：** RR最适用于队列研究和随机对照试验（RCTs），在这些研究中，可以在暴露组（干预组）和非暴露组（对照组）中直接测量结局的发生率。\n- **可解释性：** RR 非常直观且易于沟通。$RR = 0.5000$ 意味着“参加筛查项目的个体患晚期诊断的风险是未参加项目个体的一半”。它量化了干预对风险的乘法效应。在向患者或公众解释干预的相对有效性时，通常首选此指标。\n- **群体健康决策：** RR 可用于评估关联的强度。RR值与1的较大偏离表明干预措施效果显著，如果同时具有成本效益，可以优先实施。\n\n**比值比（OR）**\n- **情境：** OR是病例-对照研究中主要的关联度量指标，在这类研究中，研究人员根据疾病状态进行抽样，因此无法直接计算发病率或风险。它也是逻辑回归模型的自然输出，逻辑回归是流行病学中用于调整混杂变量的普遍工具。在像本题这样的队列研究中，OR是一个有效的度量，但通常因为它在疾病罕见时能近似于RR而被使用。此处，风险（$1.5\\%$ 和 $3\\%$）较低，因此OR（$0.4924$）是RR（$0.5000$）的良好近似值。\n- **可解释性：** OR不如RR直观。$OR = 0.4924$ 解释为“筛查组中发生晚期诊断的比值大约是未筛查组中比值的 $49\\%$”。对许多非统计学专业人士来说，‘比值’（odds）的概念不如‘风险’（risk）清晰。\n- **群体健康决策：** 其主要价值在于其数学特性，这对于统计建模非常有利。对于决策者来说，在审查来自高级统计分析或病例-对照研究（常用于研究罕见病）的结果时，OR最为相关。\n\n**风险差（RD）**\n- **情境：** 与RR一样，RD用于队列研究和RCTs。它是一种绝对效应的度量，与RR和OR的相对性形成对比。\n- **可解释性：** RD直接衡量了干预措施对公共卫生的影响。$RD = -0.01500$ 意味着筛查项目使晚期诊断的绝对风险降低了 $1.5$ 个百分点。这可以转化为，每邀请 $1000$ 人参加筛查，就可预防 $15$ 例晚期诊断。由此可以得出“需治疗人数”（Number Needed to Treat，在本例中是需筛查人数）来预防一例不良事件，即 $1/|RD| = 1/0.015 \\approx 67$。每邀请 $67$ 人参加筛查项目，就可预防一例晚期诊断。\n- **群体健康决策：** RD可以说是资源分配和政策制定中最关键的指标。虽然一个很大的RR可能看起来很引人注目，但如果基线风险非常低，预防的绝对病例数（即RD）可能太小，不足以证明一个昂贵的大规模项目是合理的。卫生系统规划者使用RD来权衡干预措施的绝对益处与其成本和危害，使其成为预算和资源分配决策的基础。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.5000  0.4924  -0.01500 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在确定一项干预措施有效后，下一个关键问题是：它是否物有所值？本练习将带您进入卫生经济学评估的核心，通过一个戒烟项目的案例来量化其成本效益。您将学习如何计算质量调整生命年（$QALY$）和增量成本效果比（$ICER$），这两个工具对于在有限的医疗资源下，比较不同健康策略的价值并做出明智决策至关重要。",
            "id": "4389597",
            "problem": "一个卫生系统正在评估一项人群层面的戒烟策略，作为其人群健康管理的一部分。使用以死亡为$0$、完美健康为$1$的健康相关生命质量框架，简要陈述质量调整生命年 (QALY) 的正式定义。然后，使用期望值和贴现的基本原理，推导并计算新方案相对于常规护理的增量成本效果比。\n\n假设一个成年吸烟者队列被随访$3$年。在此期间，死亡率差异可以忽略不计，因此所有个体在所有$3$年中的存活率均为$1$。健康状态效用在每一年内保持不变，当前吸烟者的效用为 $u_{S} = 0.78$，持续戒烟者的效用为 $u_{E} = 0.85$。所有个体在第$1$年均为吸烟者；戒烟状态在第$2$年初实现。\n\n戒烟与复吸动态：\n- 在常规护理下：在第$2$年初成为持续戒烟者的概率为 $p_{0} = 0.10$。从第$2$年到第$3$年保持戒烟者状态的概率为 $k_{0} = 0.80$。\n- 在新方案下：在第$2$年初成为持续戒烟者的概率为 $p_{1} = 0.25$。从第$2$年到第$3$年保持戒烟者状态的概率为 $k_{1} = 0.85$。\n\n每位参与者的成本（均以美元计）在每年年初产生：\n- 常规护理：第$1$年成本 $= 50$，第$2$年成本 $= 50$，第$3$年成本 $= 50$。\n- 新方案：第$1$年成本 $= 200$，第$2$年成本 $= 60$，第$3$年成本 $= 60$。\n\n使用恒定的年贴现率 $r = 0.03$，并在基线（第$1$年初）评估现值。采用时间约定，即第$t$年的成本和年度QALY流量均在该年年初（时间 $t-1$）发生，因此第$1$、第$2$和第$3$年的流量分别以 $(1+r)^{0}$、$(1+r)^{1}$ 和 $(1+r)^{2}$ 的因子进行贴现。计算新方案相对于常规护理的增量成本效果比，即每获得一个增量QALY所增加的成本。以每质量调整生命年的美元数表示您的最终结果，并将答案四舍五入到四位有效数字。任何地方都不要使用百分号；所有概率都用小数或分数表示。",
            "solution": "问题陈述已经过验证，被认为是科学可靠、问题明确且客观的。它包含一套完整且一致的数据和约束条件，可以推导出一个唯一且有意义的解。\n\n质量调整生命年 (QALY) 是一个将生命的数量和质量综合成单一数值指标的度量单位。它在卫生经济学中用于量化健康结果的价值。一个QALY代表在完美健康状态下生活一年，其效用值为$1$。被认为不完美的健康状态被赋予一个介于$0$（等同于死亡的状态）和$1$之间的效用值$u$。对于给定的时间段，获得的QALY是该时间段的持续时间与该期间健康状态效用的乘积。为分析目的，未来的QALY和成本会被贴现为其现值，以反映时间偏好。\n\n增量成本效果比 (ICER) 是一个用于总结医疗保健干预措施成本效果的统计量。它被定义为两种竞争策略的成本差异与健康效果差异之比。在此，健康效果以QALY衡量。设策略$0$表示常规护理，策略$1$表示新方案。ICER由下式给出：\n$$\nICER = \\frac{\\Delta C}{\\Delta Q} = \\frac{C_1 - C_0}{Q_1 - Q_0}\n$$\n其中 $C_i$ 和 $Q_i$ 分别是策略 $i$ 的总期望贴现成本和总期望贴现QALY。\n\n我们首先推导给定策略 $i \\in \\{0, 1\\}$ 的总期望贴现成本 $C_i$ 的表达式。成本在每年年初产生。根据指定的时间约定，第 $t \\in \\{1, 2, 3\\}$ 年的成本在时间 $j = t-1$ 产生，并以 $(1+r)^{-(t-1)}$ 的因子进行贴现。\n总贴现成本为：\n$$\nC_i = \\frac{C_{i,1}}{(1+r)^0} + \\frac{C_{i,2}}{(1+r)^1} + \\frac{C_{i,3}}{(1+r)^2}\n$$\n对于常规护理（策略$0$），成本为 $C_{0,1} = 50$ 美元，$C_{0,2} = 50$ 美元，以及 $C_{0,3} = 50$ 美元。贴现率为 $r=0.03$。\n$$\nC_0 = 50 + \\frac{50}{1+0.03} + \\frac{50}{(1+0.03)^2} = 50 \\left( 1 + \\frac{1}{1.03} + \\frac{1}{1.03^2} \\right)\n$$\n对于新方案（策略$1$），成本为 $C_{1,1} = 200$ 美元，$C_{1,2} = 60$ 美元，以及 $C_{1,3} = 60$ 美元。\n$$\nC_1 = 200 + \\frac{60}{1+0.03} + \\frac{60}{(1+0.03)^2} = 200 + 60 \\left( \\frac{1}{1.03} + \\frac{1}{1.03^2} \\right)\n$$\n因此，增量成本 $\\Delta C = C_1 - C_0$ 为：\n$$\n\\Delta C = (200-50) + (60-50)\\left(\\frac{1}{1.03}\\right) + (60-50)\\left(\\frac{1}{1.03^2}\\right)\n$$\n$$\n\\Delta C = 150 + \\frac{10}{1.03} + \\frac{10}{1.0609}\n$$\n数值上，$\\Delta C \\approx 150 + 9.708738 + 9.425959 = 169.134697$ 美元。\n\n接下来，我们推导总期望贴现QALY $Q_i$ 的表达式。第$t$年的年度QALY流量也发生在年初（时间 $t-1$），因此也以相同的因子进行贴现。总期望贴现QALY为：\n$$\nQ_i = \\frac{E[u_{i,1}]}{(1+r)^0} + \\frac{E[u_{i,2}]}{(1+r)^1} + \\frac{E[u_{i,3}]}{(1+r)^2}\n$$\n其中 $E[u_{i,t}]$ 是策略 $i$ 下第 $t$ 年的期望效用。健康状态为当前吸烟者 (S)，效用为 $u_S = 0.78$，以及持续戒烟者 (E)，效用为 $u_E = 0.85$。\n\n第$1$年：所有个体都是吸烟者。对于两种策略，$E[u_{i,1}] = 1 \\cdot u_S + 0 \\cdot u_E = u_S = 0.78$。\n\n第$2$年：戒烟在第$2$年初实现。成为戒烟者的概率为 $p_i$。处于状态E的概率为 $p_i$。处于状态S的概率为 $1-p_i$。$E[u_{i,2}] = p_i u_E + (1-p_i) u_S$。\n\n第$3$年：在第$2$年初是戒烟者的个体，以概率 $k_i$ 保持戒烟者状态。在第$2$年初是吸烟者的个体，则仍然是吸烟者。处于状态E的概率是在第$2$年是戒烟者并且在第$3$年仍然是戒烟者的概率：$P(\\text{E in year 3}) = p_i k_i$。处于状态S的概率为 $P(\\text{S in year 3}) = 1 - p_i k_i$。$E[u_{i,3}] = (p_i k_i) u_E + (1-p_i k_i) u_S$。\n\n现在可以计算增量QALY $\\Delta Q = Q_1 - Q_0$。第$1$年的项相互抵消，因为 $E[u_{1,1}] = E[u_{0,1}]$。\n$$\n\\Delta Q = \\frac{E[u_{1,2}] - E[u_{0,2}]}{1+r} + \\frac{E[u_{1,3}] - E[u_{0,3}]}{(1+r)^2}\n$$\n第$2$年的期望效用差异为：\n$E[u_{1,2}] - E[u_{0,2}] = [p_1 u_E + (1-p_1) u_S] - [p_0 u_E + (1-p_0) u_S] = (p_1-p_0)u_E - (p_1-p_0)u_S = (p_1-p_0)(u_E-u_S)$。\n\n第$3$年的期望效用差异为：\n$E[u_{1,3}] - E[u_{0,3}] = [(p_1 k_1) u_E + (1-p_1 k_1) u_S] - [(p_0 k_0) u_E + (1-p_0 k_0) u_S] = (p_1k_1-p_0k_0)(u_E-u_S)$。\n\n将这些代入 $\\Delta Q$ 的表达式中：\n$$\n\\Delta Q = (u_E - u_S) \\left[ \\frac{p_1 - p_0}{1+r} + \\frac{p_1k_1 - p_0k_0}{(1+r)^2} \\right]\n$$\n给定条件为：$u_E = 0.85$, $u_S = 0.78$；$p_0 = 0.10$, $k_0 = 0.80$；$p_1 = 0.25$, $k_1 = 0.85$；$r = 0.03$。\n$u_E - u_S = 0.85 - 0.78 = 0.07$。\n$p_1 - p_0 = 0.25 - 0.10 = 0.15$。\n$p_1k_1 - p_0k_0 = (0.25)(0.85) - (0.10)(0.80) = 0.2125 - 0.08 = 0.1325$。\n$$\n\\Delta Q = 0.07 \\left[ \\frac{0.15}{1.03} + \\frac{0.1325}{1.03^2} \\right] = 0.07 \\left[ \\frac{0.15}{1.03} + \\frac{0.1325}{1.0609} \\right]\n$$\n数值上，$\\Delta Q \\approx 0.07 [0.145631 + 0.124894] = 0.07 [0.270525] = 0.01893675$。\n\n最后，我们计算ICER：\n$$\nICER = \\frac{\\Delta C}{\\Delta Q} \\approx \\frac{169.134697}{0.01893675} \\approx 8931.528\n$$\n问题要求将结果四舍五入到四位有效数字。\n$ICER \\approx 8932$ 美元/每质量调整生命年。",
            "answer": "$$\n\\boxed{8932}\n$$"
        },
        {
            "introduction": "除了评估现有策略，人口健康管理还包括前瞻性地设计和优化医疗服务系统。本练习要求您构建一个离散事件模拟模型，以分析诊所的运营流程。通过模拟患者到达、就诊和失约等动态过程，您将亲身体验如何使用系统建模来预测策略变更（例如引入预约提醒系统）对服务吞吐量的影响，这对于在投入实际资源前测试和完善改进方案非常有帮助。",
            "id": "4389599",
            "problem": "您的任务是设计并实现一个离散事件模拟，以研究作为人口健康管理策略的诊所流程，重点关注预约提醒系统对吞吐量的影响。该模拟必须包含到达、服务时间和未就诊情况，并且必须估计当提醒系统降低未就诊概率时吞吐量的变化。吞吐量定义为每日完成的就诊次数。您必须为指定的测试套件生成结果，且程序必须将所有测试用例的结果以列表形式单行输出。\n\n使用的基本定义：\n- 诊所流程被建模为一个采用先入先出 (FIFO) 准则的多服务器队列，其中有 $c$ 个并行的相同服务器和一个容量無限的等候室。当有服务器可用且患者已到达时，服务开始。\n- 在整个诊所工作日内，患者被确定性地安排在固定的预约时段。对于在时间 $t_i$ 安排的预约 $i$，其实际到达时间为 $a_i = t_i + L_i$，其中 $L_i$ 是迟到时间。迟到时间 $L_i$ 是一个非负随机变量。\n- 患者可能以概率 $p$ 未就诊，此事件在患者间相互独立。如果患者未就诊，他们将永远不会进入系统。如果患者就诊，他们的迟到时间和服务时间将被实现。\n- 服务时间是独立同分布的非负随机变量。\n- 模拟遵循无加班政策：只有当患者的服务能在诊所工作日结束前完成时，服务才能开始。具体来说，如果一个患者的服务将在时间 $s_i$ 开始，持续时间为 $X_i$，则当且仅当 $s_i + X_i \\le T$ 时，该患者才被接诊，其中 $T$ 是诊所单日工作时长。\n- 提醒系统的效果被建模为在其他所有条件相等的情况下，将未就诊概率从基准值 $p_b$ 降低到提醒值 $p_r$。\n- 在比较基准情景与提醒情景时，使用公共随机数 (CRN) 方法来减少方差。在每次复现中，对于每个已安排的预约索引 $i$，对两种策略使用相同的基础随机数来确定迟到时间 $L_i$ 和服务时间 $X_i$，并使用相同的均匀分布随机变量 $U_i$ 以及不同的阈值 $1 - p_b$ 和 $1 - p_r$ 来决定是否就诊。\n\n构建所依据的科学基础：\n- 先入先出 (FIFO) 排队准则和并行服务器操作是卫生系统科学中用于分析诊所流程的核心抽象。\n- 到达、服务时间和未就诊事件的独立性是基于排队论的离散事件模拟中的一个标准建模假设。\n- 大数定律证明了，通过多次独立复现得到的样本均值可以近似期望吞吐量。\n\n模拟的数学规范：\n- 设诊所单日工作时长为 $T$（单位：分钟）。\n- 设预约时段长度为 $s$（单位：分钟）。已安排的时间为 $t_i = i \\cdot s$，其中 $i = 0, 1, \\dots, n-1$，$n = \\lfloor T / s \\rfloor$。\n- 对于每个已安排的索引 $i$，迟到时间 $L_i$ 从均值为 $\\bar{\\ell}$ 分钟的指数分布中抽取，服务时间 $X_i$ 从均值为 $\\bar{x}$ 分钟的指数分布中抽取。\n- 对于基准情景，如果 $U_i  1 - p_b$，患者就诊；对于提醒情景，如果 $U_i  1 - p_r$，患者就诊。其中 $U_i \\sim \\text{Uniform}(0,1)$。\n- 对于每种策略，构建就诊患者的到达列表 $\\{(a_i, X_i)\\}$，其中 $a_i = t_i + L_i$。按 $a_i$ 升序排序。设服务器可用时间的向量初始化为 $\\mathbf{v} = (0, 0, \\dots, 0) \\in \\mathbb{R}^c$。\n- 按顺序处理到达：对于每个到达的 $(a_i, X_i)$，找到索引为 $j^\\star = \\arg \\min_j v_j$ 的最早可用服务器。开始时间为 $s_i = \\max(a_i, v_{j^\\star})$，完成时间为 $c_i = s_i + X_i$。如果 $c_i \\le T$，则设置 $v_{j^\\star} = c_i$ 并增加吞吐量；否则，根据无加班政策拒绝接诊该患者。\n\n估计目标：\n- 对每个测试用例，运行 $R$ 次独立复现（使用提供的种子和确定性重置种子规则），计算基准情景下的平均吞吐量、提醒情景下的平均吞吐量，以及对吞吐量的影响，定义为 $\\Delta = \\mathbb{E}[\\text{throughput}_{\\text{reminder}}] - \\mathbb{E}[\\text{throughput}_{\\text{baseline}}]$。报告 $\\Delta$。\n\n实现要求：\n- 您必须通过服务器可用时间进行下一事件更新，严格按照规范实现模拟，并遵守无加班政策。\n- 迟到和服务时间分布必须均为指数分布，其均值分别为 $\\bar{\\ell}$ 和 $\\bar{x}$。如果 $\\bar{\\ell} = 0$，则将迟到时间解释为恒等于零。\n- 复现必须使用给定的整数种子 $z$ 作为基础种子，并确定性地派生特定于复现的种子为 $z + r$，其中 $r \\in \\{0,1,\\dots,R-1\\}$。在每次复现中，如上所述，在两种策略间使用公共随机数。\n\n单位和输出：\n- 所有时间输入单位均为分钟。\n- 吞吐量必须表示为每日完成的就诊次数（单位：patients/day），并以浮点数报告。\n- 概率必须表示为小数（例如，20% 表示为 $0.2$）。\n\n测试套件：\n对于下面的每一行，参数以 $(T, s, c, \\bar{x}, p_b, p_r, \\bar{\\ell}, R, z)$ 的形式给出。\n- 案例 A (理想路径): $(480, 15, 3, 20, 0.25, 0.10, 5, 2000, 202311)$\n- 案例 B (边界，零未就诊): $(480, 20, 2, 20, 0.0, 0.0, 2, 1500, 555)$\n- 案例 C (高未就诊率，经提醒改善): $(240, 10, 2, 12, 0.50, 0.20, 1, 3000, 777)$\n- 案例 D (拥堵的诊所，中度改善): $(300, 10, 1, 11, 0.15, 0.05, 4, 2500, 9999)$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须为每个测试用例包含一个浮点数，顺序与上述测试套件相同。每个浮点数必须是估计的 $\\Delta$ 值，四舍五入到三位小数。例如，一个有四个案例的输出必须看起来像 $[\\text{d}_A,\\text{d}_B,\\text{d}_C,\\text{d}_D]$，其中每个 $\\text{d}_\\cdot$ 的格式都精确到小数点后三位。",
            "solution": "该问题是有效的。它以排队論和离散事件模拟为科学基础，这些是卫生系统科学中用于分析诊所流程的标准方法论。该问题提法恰当，为模拟模型、参数和估计目标提供了完整且一致的规范。所有术语都有客观和正式的定义。不存在矛盾、歧义或信息缺失的情况。给定的参数对于临床环境是现实的，并且计算任务虽然非平凡但可行。\n\n解决方案将是一个用 Python 实现的离散事件模拟，严格遵守所提供的数学和程序规范。模拟的目标是估计由于预约提醒系统降低了患者未就诊概率而导致的每日患者吞吐量的变化，该变化定义为 $\\Delta = \\mathbb{E}[\\text{throughput}_{\\text{reminder}}] - \\mathbb{E}[\\text{throughput}_{\\text{baseline}}]$。\n\n解决方案的核心包括对每个测试用例执行以下步骤：\n1.  **复现循环**：我们执行 $R$ 次独立的模拟复现以收集统计数据。为确保可复现性和受控的随机性，对于复现 $r \\in \\{0, 1, \\dots, R-1\\}$，其种子被确定性地设置为 $z + r$，其中 $z$ 是基础种子。\n\n2.  **公共随机数 (CRN)**：在每次复现中，我们应用 CRN 方差缩减技术。这意味着我们为每个已安排的预约时段的所有潜在事件（未就诊决策、迟到、服务时间）预先生成一组唯一的随机数。这组随机数随后用于基准情景（未就诊概率 $p_b$）和提醒情景（未就诊概率 $p_r$）。这确保了两种策略之间的比较是在相同的随机条件下进行的，从而隔离了未就诊概率变化的影响，并减小了估计差异 $\\Delta$ 的方差。\n\n3.  **患者生成与到达**：对于一个持续时间为 $T$、预约时段长度为 $s$ 的诊所工作日，共有 $n = \\lfloor T/s \\rfloor$ 个已安排的预约。对于每个预约索引 $i \\in \\{0, \\dots, n-1\\}$：\n    - 一个均匀分布的随机变量值 $U_i \\sim \\text{Uniform}(0,1)$ 决定患者是否就诊。对于基准情景，如果 $U_i  1-p_b$，患者就诊；对于提醒情景，如果 $U_i  1-p_r$，患者就诊。\n    - 对于每个潜在患者 $i$，我们从均值为 $\\bar{\\ell}$ 的指数分布中生成一个迟到值 $L_i$，并从均值为 $\\bar{x}$ 的指数分布中生成一个服务时间 $X_i$。\n    - 如果患者就诊，他们的到达时间为 $a_i = t_i + L_i$，其中 $t_i = i \\cdot s$ 是预定时间。\n\n4.  **队列处理**：对于每种策略（基准和提醒），我们获得一个到达患者的列表，每个患者由一个元组 $(a_i, X_i)$ 表征。该列表按到达时间 $a_i$ 排序。然后我们使用以下逻辑处理此队列：\n    - 我们维护一个记录 $c$ 个并行服务器可用时间的数组，并将其初始化为 $0$。\n    - 对于已排序的到达列表中的每个患者，我们找到最早可用的服务器。\n    - 患者的服务可以在时间 $s_i = \\max(a_i, v_{j^\\star})$ 开始，其中 $a_i$ 是他们的到达时间，$v_{j^\\star}$ 是最早的服务器空闲时间。\n    - 服务将在 $c_i = s_i + X_i$ 完成。\n    - **无加班政策**被强制执行：只有当 $c_i \\le T$ 时，患者才会被接诊。\n    - 如果被接诊，吞吐量计数器增加，并且服务器的可用时间更新为 $v_{j^\\star} = c_i$。否则，患者被拒绝。\n\n5.  **估计**：在运行单次复现后，我们计算吞吐量的差异，$\\delta_r = \\text{throughput}_{\\text{reminder}, r} - \\text{throughput}_{\\text{baseline}, r}$。在所有 $R$ 次复现完成后，最终的影响估计值通过样本均值 $\\hat{\\Delta} = \\frac{1}{R} \\sum_{r=0}^{R-1} \\delta_r$ 计算得出。大数定律确保了该样本均值是真实期望差异 $\\Delta$ 的一个一致估计量。\n\n这种结构化的方法保证了模拟能准确反映指定的模型，并且使用 CRN 能为干预措施的影响提供一个统计上有效的估计。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Parameters are given as (T, s, c, x_bar, p_b, p_r, l_bar, R, z).\n    # T: clinic day length (minutes)\n    # s: appointment slot length (minutes)\n    # c: number of servers\n    # x_bar: mean service time (minutes)\n    # p_b: baseline no-show probability\n    # p_r: reminder no-show probability\n    # l_bar: mean lateness (minutes)\n    # R: number of replications\n    # z: base seed\n    test_cases = [\n        # Case A (happy path)\n        (480, 15, 3, 20, 0.25, 0.10, 5, 2000, 202311),\n        # Case B (boundary, zero no-shows)\n        (480, 20, 2, 20, 0.0, 0.0, 2, 1500, 555),\n        # Case C (high no-shows improved by reminders)\n        (240, 10, 2, 12, 0.50, 0.20, 1, 3000, 777),\n        # Case D (congested clinic, moderate improvement)\n        (300, 10, 1, 11, 0.15, 0.05, 4, 2500, 9999),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        # Unpack parameters and run the simulation for one case\n        T, s, c, x_bar, p_b, p_r, l_bar, R, z = case_params\n        delta = _estimate_throughput_impact(T, s, c, x_bar, p_b, p_r, l_bar, R, z)\n        results.append(delta)\n\n    # Format the final results to three decimal places and print in the required format.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _estimate_throughput_impact(T, s, c, x_bar, p_b, p_r, l_bar, R, z):\n    \"\"\"\n    Estimates the change in throughput for a single test case by running R replications.\n    \"\"\"\n    replication_deltas = []\n    for r in range(R):\n        # Each replication uses a deterministic seed derived from the base seed.\n        replication_seed = z + r\n        delta = _run_single_replication(T, s, c, x_bar, p_b, p_r, l_bar, replication_seed)\n        replication_deltas.append(delta)\n    \n    # The final estimate is the average of the deltas from all replications,\n    # justified by the Law of Large Numbers.\n    estimated_delta = np.mean(replication_deltas)\n    return estimated_delta\n\ndef _run_single_replication(T, s, c, x_bar, p_b, p_r, l_bar, seed):\n    \"\"\"\n    Performs one full replication (baseline and reminder) using Common Random Numbers (CRN).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Determine the number of scheduled appointment slots.\n    num_appointments = int(T // s)\n    if num_appointments == 0:\n        return 0.0\n\n    # Generate all random variates for the replication using CRN.\n    # These will be shared between the baseline and reminder scenarios.\n    show_no_show_variates = rng.uniform(size=num_appointments)\n    lateness_variates = rng.exponential(scale=l_bar, size=num_appointments) if l_bar > 0 else np.zeros(num_appointments)\n    service_time_variates = rng.exponential(scale=x_bar, size=num_appointments)\n    scheduled_times = np.arange(num_appointments) * s\n\n    # --- Baseline Scenario ---\n    arrivals_baseline = []\n    for i in range(num_appointments):\n        # A patient shows up if their random variate is less than the show probability (1 - p).\n        if show_no_show_variates[i]  (1.0 - p_b):\n            arrival_time = scheduled_times[i] + lateness_variates[i]\n            service_time = service_time_variates[i]\n            arrivals_baseline.append((arrival_time, service_time))\n    throughput_baseline = _process_queue(arrivals_baseline, c, T)\n\n    # --- Reminder Scenario ---\n    arrivals_reminder = []\n    for i in range(num_appointments):\n        # The same logic and CRN are applied, but with the reminder no-show probability.\n        if show_no_show_variates[i]  (1.0 - p_r):\n            arrival_time = scheduled_times[i] + lateness_variates[i]\n            service_time = service_time_variates[i]\n            arrivals_reminder.append((arrival_time, service_time))\n    throughput_reminder = _process_queue(arrivals_reminder, c, T)\n    \n    # The result for this replication is the difference in throughput.\n    return throughput_reminder - throughput_baseline\n\ndef _process_queue(arrivals, num_servers, clinic_duration):\n    \"\"\"\n    Simulates the queueing process for a given list of arrivals and system parameters.\n    Implements the multi-server FIFO queue with a no-overtime policy.\n    \"\"\"\n    if not arrivals:\n        return 0\n\n    # Patients are processed in the order they arrive (First In First Out based on arrival time).\n    sorted_arrivals = sorted(arrivals, key=lambda x: x[0])\n    \n    # Initialize server availability times. All servers are free at time 0.\n    server_availability_times = np.zeros(num_servers)\n    completed_visits = 0\n\n    for arrival_time, service_time in sorted_arrivals:\n        # Find the server that becomes free the earliest.\n        earliest_server_idx = np.argmin(server_availability_times)\n        earliest_free_time = server_availability_times[earliest_server_idx]\n        \n        # Service can only start after the patient has arrived AND a server is free.\n        start_time = max(arrival_time, earliest_free_time)\n        completion_time = start_time + service_time\n        \n        # Apply the no-overtime policy: service must finish by clinic closing time.\n        if completion_time = clinic_duration:\n            completed_visits += 1\n            # Update the availability time of the server that took this patient.\n            server_availability_times[earliest_server_idx] = completion_time\n        # Else, the patient is rejected and does not contribute to throughput.\n            \n    return completed_visits\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}