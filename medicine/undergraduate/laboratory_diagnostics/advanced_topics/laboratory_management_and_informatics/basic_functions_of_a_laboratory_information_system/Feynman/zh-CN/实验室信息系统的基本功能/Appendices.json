{
    "hands_on_practices": [
        {
            "introduction": "在临床实验室中，确保患者安全始于对样本的正确识别。本练习旨在揭示样本标签要求的深层逻辑，不仅仅是记忆规则，而是从第一性原理出发，结合监管要求和量化风险模型来理解其必要性。通过这个实践，你将学会如何评估不同标识符组合的安全性，从而理解实验室信息系统（LIS）在配置标签规则时为何扮演着至关重要的安全角色。",
            "id": "5209954",
            "problem": "一家医院正在配置其实验室信息系统 (LIS)，以定义必须出现在样本标签上的最低数据元素。其目标是满足监管要求，并使用第一性原理来控制患者身份错误识别的风险。请使用以下基本事实和假设。\n\n- 监管可追溯性要求：广泛采用的标准，如《临床实验室改进修正案》(CLIA) 和国际标准化组织 (ISO) 的 ISO 15189 标准，要求样本标签至少支持：通过至少两个独立的标识符进行患者身份识别、一个能链接到LIS中医嘱的唯一样本标识符、在与检测相关时标明样本类型或来源，以及采集日期和时间以支持稳定性和分析前解释。\n- 错误识别的概率模型：如果使用两个独立的患者标识符，且这些标识符的每对碰撞概率分别为 $p_1$ 和 $p_2$，则在独立性假设下，两个不同患者共享这两个标识符的概率近似为 $p_1 p_2$。\n- 机构可接受的风险阈值：医院设定，对每个样本向错误患者发布结果的最大可接受概率为 $p_{\\max} = 10^{-6}$。\n- 该人群的标识符碰撞假设：两个不同的活跃患者共享相同全名的概率为 $p_{\\text{name}} = 10^{-4}$。假设出生日期在日历上均匀分布，两个不同患者共享相同出生日期的概率为 $p_{\\text{dob}} = 1/365$。病历号 (MRN) 在该机构内部设计上是唯一的，并且在使用时未经转换直接编码和打印。\n\n在这些约束条件下，选择LIS应对每个样本标签要求的最小数据元素集，以同时 (i) 满足上述监管要求，并且 (ii) 将建模的错误识别概率保持在 $p_{\\max}$ 以下，同时不添加非必要元素。\n\nA. 患者全名；出生日期；唯一的条形码登录号；采集日期和时间；样本类型或来源。\n\nB. 患者全名；唯一的条形码登录号；样本类型或来源；开单医生。\n\nC. 患者全名；病历号；唯一的条形码登录号；采集日期和时间；样本类型或来源；采集者标识符；检验医嘱标识符。\n\nD. 仅病历号；唯一的条形码登录号；采集日期和时间；样本类型或来源。",
            "solution": "问题陈述已经过验证，被确定为是合理的。它有科学依据，提法得当且客观，提供了一套自洽的约束条件以得出合乎逻辑的结论。\n\n任务是确定样本标签的最小数据元素集，该集合需同时满足两组要求：(i) 监管标准和 (ii) 定量的患者身份错误识别风险阈值。\n\n首先，让我们将这些要求形式化为评估标准。\n\n**标准1：法规遵从性**\n根据所提供的文本，监管标准（如CLIA和ISO 15189）对样本标签所要求的最小元素集是：\n1.  至少两个独立的患者标识符。\n2.  一个能链接到实验室医嘱的唯一样本标识符（例如，登录号）。\n3.  在相关时，标明样本类型或来源。\n4.  采集日期和时间。\n\n**标准2：错误识别风险阈值**\n由于患者标识符碰撞导致的错误识别概率必须小于最大可接受概率 $p_{\\max} = 10^{-6}$。\n给定的标识符是：\n-   患者全名，碰撞概率为 $p_{\\text{name}} = 10^{-4}$。\n-   出生日期 (DOB)，碰撞概率为 $p_{\\text{dob}} = 1/365$。\n-   病历号 (MRN)，其设计上是唯一的，因此碰撞概率为 $p_{\\text{mrn}} = 0$。\n\n一对独立标识符的错误识别概率是它们各自碰撞概率的乘积。让我们根据风险阈值评估有效的标识符对：\n\n-   **组合（患者全名，出生日期）：**\n    碰撞概率为 $p_{1} = p_{\\text{name}} \\times p_{\\text{dob}}$。\n    $$p_{1} = 10^{-4} \\times \\frac{1}{365} \\approx 10^{-4} \\times 0.00274 = 2.74 \\times 10^{-7}$$\n    与阈值比较：$2.74 \\times 10^{-7}  10^{-6}$。这对标识符满足风险阈值。\n\n-   **组合（患者全名，病历号）：**\n    碰撞概率为 $p_{2} = p_{\\text{name}} \\times p_{\\text{mrn}}$。\n    $$p_{2} = 10^{-4} \\times 0 = 0$$\n    这显然满足风险阈值，因为 $0  10^{-6}$。\n\n-   **组合（出生日期，病历号）：**\n    碰撞概率为 $p_{3} = p_{\\text{dob}} \\times p_{\\text{mrn}}$。\n    $$p_{3} = \\frac{1}{365} \\times 0 = 0$$\n    这也显然满足风险阈值。\n\n单个非唯一标识符，如全名 ($p_{\\text{name}} = 10^{-4} > 10^{-6}$) 或出生日期 (DOB) ($p_{\\text{dob}} = 1/365 \\approx 2.74 \\times 10^{-3} > 10^{-6}$) 单独不足以满足风险阈值。单个唯一标识符如病历号 (MRN) ($p_{\\text{mrn}}=0  10^{-6}$) 会满足风险阈值，但会违反要求使用*两个*标识符的监管规定。\n\n因此，一个有效的解决方案必须包含来自标准1的所有四个元素，其中两个患者标识符是从上面展示的组合中选择的，以满足标准2。该解决方案还必须是*最小化的*，意味着它不应包含超出这些核心要求之外的元素。\n\n现在，我们将评估每个选项。\n\n**A. 患者全名；出生日期；唯一的条形码登录号；采集日期和时间；样本类型或来源。**\n\n1.  **法规遵从性 (标准1)：**\n    -   两个患者标识符：提供了“患者全名”和“出生日期”。此项满足。\n    -   唯一样本标识符：提供了“唯一的条形码登录号”。此项满足。\n    -   样本类型/来源：提供了“样本类型或来源”。此项满足。\n    -   采集日期/时间：提供了“采集日期和时间”。此项满足。\n    所有四个监管要点均已满足。\n\n2.  **风险阈值 (标准2)：**\n    -   患者标识符是姓名和出生日期。如上计算，碰撞概率约为 $2.74 \\times 10^{-7}$，低于所要求的最大值 $10^{-6}$。此项满足。\n\n3.  **最小化：**\n    -   此选项仅包含满足问题中规定的综合监管和风险标准所必需的元素。它不包含多余的元素。\n\n**结论：正确**。此选项满足所有规定要求并且是最小化的。\n\n**B. 患者全名；唯一的条形码登录号；样本类型或来源；开单医生。**\n\n1.  **法规遵从性 (标准1)：**\n    -   两个患者标识符：只列出了“患者全名”作为一个患者标识符。这不符合要求*两个*标识符的规定。\n    -   采集日期/时间：缺少此元素。这不符合要求。\n\n2.  **风险阈值 (标准2)：**\n    -   只有一个患者标识符（姓名），碰撞风险为 $p_{\\text{name}} = 10^{-4}$，超过了阈值 $p_{\\max} = 10^{-6}$。\n\n3.  **最小化：**\n    -   此选项引入了“开单医生”，这在问题陈述中未被列为样本标签的最低要求。\n\n**结论：不正确**。此选项在三方面不合格：患者标识符不足，缺少采集时间，以及包含非必要元素。\n\n**C. 患者全名；病历号；唯一的条形码登录号；采集日期和时间；样本类型或来源；采集者标识符；检验医嘱标识符。**\n\n1.  **法规遵从性 (标准1)：**\n    -   所有四个基本要求都存在：(1) “患者全名”和“病历号”作为两个标识符，(2) “唯一的条形码登录号”，(3) “样本类型或来源”，以及 (4) “采集日期和时间”。此项满足。\n\n2.  **风险阈值 (标准2)：**\n    -   患者标识符是姓名和病历号。碰撞概率为 $0$，低于阈值 $10^{-6}$。此项满足。\n\n3.  **最小化：**\n    -   此选项包括“采集者标识符”和“检验医嘱标识符”。这些不属于问题监管要求所定义的最小集的一部分。唯一的登录号是链接到医嘱（其中包含如检验项目和采集者等更多细节）所要求的；根据问题的约束，这些额外的数据点*在标签本身上*是非必要的。由于问题要求*最小集*，因此该选项不是最小化的。\n\n**结论：不正确**。尽管它满足安全性和核心监管要求，但它不是最小集。\n\n**D. 仅病历号；唯一的条形码登录号；采集日期和时间；样本类型或来源。**\n\n1.  **法规遵从性 (标准1)：**\n    -   两个患者标识符：该选项明确说明“仅病历号”，只提供了一个患者标识符。这不符合“至少两个独立标识符”的监管要求。\n\n2.  **风险阈值 (标准2)：**\n    -   单独使用病历号 (MRN) 导致的碰撞概率为 $p_{\\text{mrn}} = 0$，满足了定量风险阈值。然而，满足风险模型并不能免除对两个标识符的明确监管要求。\n\n3.  **最小化：**\n    -   该集合是最小化的，但不完整。\n\n**结论：不正确**。此选项未能满足对两个患者标识符的监管要求。\n\n根据分析，只有选项A正确地确定了一组既满足所述要求又完整且最小化的数据元素。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "自动审核是现代LIS的一项核心功能，它能够根据预设标准自动放行检验结果，从而显著提高实验室效率。本练习将展示LIS如何内置科学模型（如此处的一级反应动力学）来执行分析前的质量控制规则。你将亲手计算一个在真实世界中至关重要的参数——葡萄糖样本在离心前的最大允许延迟时间，这个参数将直接用于LIS系统，以防止因样本不当处理而报告可能错误的检验结果。",
            "id": "5209983",
            "problem": "一家医院的实验室信息系统（LIS）正在进行配置，以实施一项自动审核规则，如果从静脉抽血到离心的分析前延迟超过了分析上合理的限值，该规则将对血浆葡萄糖结果进行标记。内部验证表明，在室温下，储存在不含糖酵解抑制剂的肝素锂抗凝管中的全血，在细胞分离前，其葡萄糖浓度会根据一级动力学规律下降。该系统的模型为描述葡萄糖浓度 $\\,C(t)\\,$ 的微分方程 $\\,\\frac{dC}{dt}=-k\\,C\\,$，其中速率常数为 $\\,k\\,$。实验室对分析前损失所允许的相对偏倚分数为 $\\,b_{\\mathrm{a}}\\,$（无量纲），这意味着在 LIS 的时间限制阈值下，预期的相对损失 $\\,\\frac{C(0)-C(t)}{C(0)}\\,$ 不得超过 $\\,b_{\\mathrm{a}}\\,$。\n\n配置时，使用经验确定的室温下速率常数 $\\,k=0.060\\,\\text{h}^{-1}\\,$ 和允许的相对偏倚分数 $\\,b_{\\mathrm{a}}=0.10\\,$。从所述的一级动力学模型和相对偏倚的定义出发，推导出使预期相对损失等于 $\\,b_{\\mathrm{a}}\\,$ 的最大允许延迟 $\\,t_{\\max}\\,$，然后进行数值计算 $\\,t_{\\max}\\,$。将您的最终答案以分钟为单位表示，并四舍五入至三位有效数字。仅供参考（最终答案无需额外计算），许多实验室采用 $\\,120\\,$ 分钟的操作限值；如果计算出的 $\\,t_{\\max}\\,$ 比 $\\,120\\,$ 分钟更严格，LIS 将采用该值作为葡萄糖的自动审核截止时间。",
            "solution": "该问题要求基于葡萄糖降解的一级动力学模型，推导并计算血浆葡萄糖测量的最大允许分析前延迟 $t_{\\max}$。\n\n首先，对给定信息进行验证。\n问题提供了：\n1.  描述葡萄糖浓度 $C(t)$ 的微分方程：$\\frac{dC}{dt} = -kC$。\n2.  经验确定的速率常数：$k = 0.060\\,\\text{h}^{-1}$。\n3.  允许的相对偏倚分数：$b_{\\mathrm{a}} = 0.10$。\n4.  时间 $t$ 时的相对损失定义：$\\frac{C(0)-C(t)}{C(0)}$。\n5.  最大允许延迟 $t_{\\max}$ 的条件：相对损失必须等于 $b_{\\mathrm{a}}$，即 $\\frac{C(0)-C(t_{\\max})}{C(0)} = b_{\\mathrm{a}}$。\n6.  要求将 $t_{\\max}$ 的最终答案以分钟为单位表示，并四舍五入至三位有效数字。\n\n该问题具有科学依据，因为它使用标准的动力学模型来模拟一个已知的生化过程（糖酵解）。问题阐述清晰，提供了求解唯一 $t_{\\max}$ 值所需的所有信息。语言客观而精确。因此，该问题被认为是有效的，可以制定解决方案。\n\n推导过程首先从求解一级微分方程 $\\frac{dC}{dt} = -kC$ 开始。这是一个可分离变量的方程：\n$$\n\\frac{dC}{C} = -k\\,dt\n$$\n我们对两边进行积分。左边从初始浓度 $C(0)$（时间 $t=0$ 时）积分到一般时间 $t$ 时的浓度 $C(t)$。右边从 $0$ 积分到 $t$：\n$$\n\\int_{C(0)}^{C(t)} \\frac{1}{C'} \\,dC' = \\int_{0}^{t} -k \\,dt'\n$$\n积分得到：\n$$\n[\\ln|C'|]_{C(0)}^{C(t)} = [-kt']_{0}^{t}\n$$\n由于浓度 $C$ 必须为非负值，绝对值可以去掉。计算定积分得到：\n$$\n\\ln(C(t)) - \\ln(C(0)) = -kt\n$$\n利用对数性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$：\n$$\n\\ln\\left(\\frac{C(t)}{C(0)}\\right) = -kt\n$$\n为了求解比值 $\\frac{C(t)}{C(0)}$，我们对两边取指数：\n$$\n\\frac{C(t)}{C(0)} = \\exp(-kt)\n$$\n这样就得到了任意时间 $t$ 的浓度为 $C(t) = C(0)\\exp(-kt)$。\n\n接下来，我们使用允许的相对偏倚分数 $b_{\\mathrm{a}}$ 的定义。问题陈述，在最大允许延迟 $t_{\\max}$ 时，相对损失等于 $b_{\\mathrm{a}}$：\n$$\n\\frac{C(0) - C(t_{\\max})}{C(0)} = b_{\\mathrm{a}}\n$$\n该表达式可以简化为：\n$$\n1 - \\frac{C(t_{\\max})}{C(0)} = b_{\\mathrm{a}}\n$$\n现在，我们代入从动力学模型推导出的、在 $t=t_{\\max}$ 时的表达式 $\\frac{C(t)}{C(0)}$：\n$$\n1 - \\exp(-kt_{\\max}) = b_{\\mathrm{a}}\n$$\n我们现在必须解这个方程求出 $t_{\\max}$。整理各项，我们得到：\n$$\n\\exp(-kt_{\\max}) = 1 - b_{\\mathrm{a}}\n$$\n对两边取自然对数：\n$$\n\\ln(\\exp(-kt_{\\max})) = \\ln(1 - b_{\\mathrm{a}})\n$$\n$$\n-kt_{\\max} = \\ln(1 - b_{\\mathrm{a}})\n$$\n最后，解出 $t_{\\max}$，我们得到最大允许延迟的符号表达式：\n$$\nt_{\\max} = -\\frac{1}{k}\\ln(1 - b_{\\mathrm{a}})\n$$\n现在，我们代入给定的数值：$k=0.060\\,\\text{h}^{-1}$ 和 $b_{\\mathrm{a}}=0.10$。\n$$\nt_{\\max} = -\\frac{1}{0.060\\,\\text{h}^{-1}}\\ln(1 - 0.10)\n$$\n$$\nt_{\\max} = -\\frac{1}{0.060}\\ln(0.90)\\,\\text{h}\n$$\n$\\ln(0.90)$ 的值约等于 $-0.1053605$。\n$$\nt_{\\max} \\approx -\\frac{1}{0.060}(-0.1053605)\\,\\text{h}\n$$\n$$\nt_{\\max} \\approx 1.756008\\,\\text{h}\n$$\n问题要求答案以分钟为单位。我们使用换算因子 $1\\,\\text{h} = 60\\,\\text{min}$ 将小时转换为分钟。\n$$\nt_{\\max} \\approx 1.756008\\,\\text{h} \\times \\frac{60\\,\\text{min}}{1\\,\\text{h}}\n$$\n$$\nt_{\\max} \\approx 105.3605\\,\\text{min}\n$$\n最后一步是按要求将结果四舍五入到三位有效数字。前三位有效数字是 $1$、$0$ 和 $5$。第四位数字是 $3$，小于 $5$，所以我们向下舍入。\n$$\nt_{\\max} \\approx 105\\,\\text{min}\n$$\n这个计算出的 $105$ 分钟的值比问题背景中提到的 $120$ 分钟的操作限值更为严格，这证明了将其用作 LIS 截止时间的合理性。",
            "answer": "$$\n\\boxed{105}\n$$"
        },
        {
            "introduction": "LIS的一个关键角色是作为分析仪器与实验室工作人员之间的智能中介，它需要能够解析仪器产生的各种状态和错误代码。本练习让你扮演系统设计者的角色，运用概率论来建模不同类型的错误及其对实验室工作流程的影响。通过计算预期的手动干预次数，你将深入理解LIS的错误处理逻辑是如何直接影响操作效率和人员工作负荷的。",
            "id": "5209966",
            "problem": "您正在一个实验室信息系统 (LIS) 中实现一个核心错误处理函数，该函数将分析仪状态码映射到 LIS 异常，并量化预期的人工干预率。该场景基于以下从基础概率论和标准系统设计实践中得出的科学假设进行建模：a) 分析仪处理的每个测试最多只发出一个状态码（互斥性），b) 每个测试的每个状态码事件都是一个已知概率的伯努利试验，c) 从状态码到 LIS 异常类的映射决定了是需要人工干预，还是可以通过自动恢复（例如，重试）来避免。您必须使用全期望定律和伯努利试验属性作为基本依据。\n\n分类和操作语义的定义：\n- 严重异常一旦发生，需要人工干预的概率为 $1$。\n- 主要异常尝试通过重复重试进行自动恢复。如果每次尝试的成功概率为 $q$，并且系统执行 $r$ 次独立重试，则发生该异常后需要人工干预的概率是所有重试都失败的概率。\n- 警告和信息性异常不需要人工干预。\n\n根据这些定义，您的任务是为几个独立的测试用例计算每 $10,000$ 个测试中预期的人工干预次数，每个测试用例由一组状态码及其参数来表征。对于每个状态码，您会得到：\n- 一个代码标识符（字符串），\n- 每个测试的发生概率 $p$，其中 $0 \\le p \\le 1$，\n- 一个严重性等级，属于 {\"critical\", \"major\", \"warning\", \"info\"} 之一，\n- 仅对于 \"major\"：每次重试的成功概率 $q$（其中 $0 \\le q \\le 1$）和重试次数 $r$（非负整数）。\n\n应用的假设：\n- 对于单个测试，状态码是互斥的结果。\n- $N$ 个测试的预期人工干预次数等于由每个代码贡献的预期人工干预次数的总和。\n- 对于 \"major\" 异常，重试是独立同分布的，因此所有 $r$ 次重试都失败的概率是 $(1 - q)^r$。\n\n将所有最终答案表示为实数（浮点数），代表每 $10,000$ 次测试的预期人工干预次数。将每个结果四舍五入到 $6$ 位小数。除了“每 $10,000$ 次测试”外，不需要其他单位。\n\n实现一个程序来处理以下参数集的测试套件。每个测试用例提供一个状态码列表，每个状态码都有其参数 $(p,\\ \\text{severity},\\ q,\\ r)$，其中 $q$ 和 $r$ 仅为 \"major\" 严重性等级提供。\n\n测试用例 A（一般混合严重性和概率）：\n- HEMOLYSIS: $p=0.004$, 严重性 \"critical\"。\n- REAGENT_LOW: $p=0.0025$, 严重性 \"major\", $q=0.9$, $r=2$。\n- COMM_TIMEOUT: $p=0.006$, 严重性 \"major\", $q=0.8$, $r=3$。\n- CLOT_DETECTED: $p=0.0005$, 严重性 \"critical\"。\n- QC_FAIL: $p=0.0008$, 严重性 \"critical\"。\n- CALIB_REQUIRED: $p=0.001$, 严重性 \"major\", $q=0.7$, $r=1$。\n- TEMP_HIGH: $p=0.003$, 严重性 \"warning\"。\n\n测试用例 B（接近零的失败率）：\n- COMM_TIMEOUT: $p=0.00001$, 严重性 \"major\", $q=0.7$, $r=5$。\n- TEMP_HIGH: $p=0.0002$, 严重性 \"warning\"。\n\n测试用例 C（高频主要事件和一些严重事件）：\n- REAGENT_LOW: $p=0.15$, 严重性 \"major\", $q=0.95$, $r=1$。\n- COMM_TIMEOUT: $p=0.2$, 严重性 \"major\", $q=0.6$, $r=2$。\n- QC_FAIL: $p=0.005$, 严重性 \"critical\"。\n\n测试用例 D（概率总和为 $1$ 的饱和工作负载）：\n- CLOT_DETECTED: $p=0.05$, 严重性 \"critical\"。\n- REAGENT_LOW: $p=0.25$, 严重性 \"major\", $q=0.9$, $r=3$。\n- COMM_TIMEOUT: $p=0.35$, 严重性 \"major\", $q=0.7$, $r=1$。\n- QC_FAIL: $p=0.1$, 严重性 \"critical\"。\n- TEMP_HIGH: $p=0.25$, 严重性 \"warning\"。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[resultA,resultB,resultC,resultD]\"），其中每个结果是每 $10,000$ 次测试的预期人工干预次数，四舍五入到 $6$ 位小数。",
            "solution": "### 问题验证\n\n#### 第 1 步：提取已知信息\n\n问题提供了以下数据、定义和约束：\n- **系统模型**：对于每个测试，最多发出一个状态码（互斥性）。每个状态码事件都是一个已知概率的伯努利试验。\n- **基本原理**：解决方案必须基于全期望定律和伯努利试验的性质。\n- **总测试数**：目标计算是针对 $N = 10,000$ 次测试。\n- **分类定义**：\n    - **Critical（严重）**：发生后需要人工干预的概率为 $1$。\n    - **Major（主要）**：尝试通过 $r$ 次独立重试进行自动恢复。每次尝试的成功概率为 $q$。如果所有 $r$ 次重试都失败，则需要人工干预。\n    - **Warning/Informational（警告/信息性）**：发生后需要人工干预的概率为 $0$。\n- **计算假设**：\n    - $N$ 次测试的预期人工干预次数是所有状态码各自贡献的预期干预次数之和。\n    - 对于“major”异常，所有 $r$ 次重试都失败的概率为 $(1 - q)^r$。\n- **每个状态码的输入参数**：\n    - 代码标识符（字符串）。\n    - 每个测试的发生概率，$p \\in [0, 1]$。\n    - 严重性等级：`{\"critical\", \"major\", \"warning\", \"info\"}` 之一。\n    - 对于“major”严重性等级：每次重试的成功概率 $q \\in [0, 1]$ 和重试次数 $r$（非负整数）。\n- **输出格式**：每 $10,000$ 次测试的预期人工干预次数，表示为浮点数，四舍五入到 $6$ 位小数。\n- **测试用例**：\n    - **测试用例 A**：\n        - HEMOLYSIS: $p=0.004$, 严重性 \"critical\"。\n        - REAGENT_LOW: $p=0.0025$, 严重性 \"major\", $q=0.9$, $r=2$。\n        - COMM_TIMEOUT: $p=0.006$, 严重性 \"major\", $q=0.8$, $r=3$。\n        - CLOT_DETECTED: $p=0.0005$, 严重性 \"critical\"。\n        - QC_FAIL: $p=0.0008$, 严重性 \"critical\"。\n        - CALIB_REQUIRED: $p=0.001$, 严重性 \"major\", $q=0.7$, $r=1$。\n        - TEMP_HIGH: $p=0.003$, 严重性 \"warning\"。\n    - **测试用例 B**：\n        - COMM_TIMEOUT: $p=0.00001$, 严重性 \"major\", $q=0.7$, $r=5$。\n        - TEMP_HIGH: $p=0.0002$, 严重性 \"warning\"。\n    - **测试用例 C**：\n        - REAGENT_LOW: $p=0.15$, 严重性 \"major\", $q=0.95$, $r=1$。\n        - COMM_TIMEOUT: $p=0.2$, 严重性 \"major\", $q=0.6$, $r=2$。\n        - QC_FAIL: $p=0.005$, 严重性 \"critical\"。\n    - **测试用例 D**：\n        - CLOT_DETECTED: $p=0.05$, 严重性 \"critical\"。\n        - REAGENT_LOW: $p=0.25$, 严重性 \"major\", $q=0.9$, $r=3$。\n        - COMM_TIMEOUT: $p=0.35$, 严重性 \"major\", $q=0.7$, $r=1$。\n        - QC_FAIL: $p=0.1$, 严重性 \"critical\"。\n        - TEMP_HIGH: $p=0.25$, 严重性 \"warning\"。\n\n#### 第 2 步：使用提取的已知信息进行验证\n- **科学性**：该问题本质上是概率论的应用，特别是伯努利试验、条件概率和全期望定律。这些是成熟的数学原理。应用场景——在实验室信息系统中建模系统错误——是系统工程和可靠性分析中的一种现实且标准的做法。模型的假设（每个测试的状态码互斥、概率性故障模式）是此类分析中使用的标准简化方法。该问题没有违反任何科学或数学原理。\n- **良构性**：问题定义清晰。它提供了所有必要的输入（概率、分类、重试参数），并指定了精确的输出（每 $10,000$ 次测试的预期干预次数）。给定输入，模型是确定性的，从而为每个测试用例得出一个唯一且稳定的解。\n- **客观性**：问题以客观、正式的语言陳述。它使用了概率论和计算机科学中的精确术语。没有主观、模糊或基于意见的陈述。分类标准和计算规则是明确和定量的。\n\n该问题没有表现出验证清单中列出的任何缺陷（例如，科学上不健全、不完整、模糊不清）。\n\n#### 第 3 步：结论和行动\n该问题是有效的。将提供一个合理的解决方案。\n\n### 解决方案\n\n任务是计算一批 $N = 10,000$ 次实验室测试的预期人工干预次数。这可以通过应用期望的线性性和全概率定律来解决。\n\n设 $M$ 为表示 $N$ 次测试中总人工干预次数的随机变量。我们需要找到 $M$ 的期望值，记作 $E[M]$。\n\n设 $I_k$ 为第 $k$ 次测试（其中 $k$ 从 $1$ 到 $N$）的指示随机变量。如果第 $k$ 次测试导致人工干预，则 $I_k=1$，否则 $I_k=0$。总干预次数是这些指示变量的总和：\n$$\nM = \\sum_{k=1}^{N} I_k\n$$\n根据期望的线性性，预期的总干預次数为：\n$$\nE[M] = E\\left[\\sum_{k=1}^{N} I_k\\right] = \\sum_{k=1}^{N} E[I_k]\n$$\n由于每次测试都是独立同分布的试验，因此所有测试的期望值 $E[I_k]$ 都是相同的。我们将这个共同的期望值表示为 $E[I]$。因此：\n$$\nE[M] = N \\cdot E[I]\n$$\n指示变量的期望值是它所指示事件的概率。因此，$E[I]$ 是单次测试需要人工干预的概率，即 $P(I=1)$。\n\n为了求 $P(I=1)$，我们使用全概率定律。任何可能的状态码都可能触发人工干预。设所有状态码的集合为 $\\mathcal{C}$。对于每个代码 $i \\in \\mathcal{C}$，设 $E_i$ 是单次测试中发出状态码 $i$ 的事件。问题陈述这些事件是互斥的。我们已知概率 $P(E_i) = p_i$。\n\n事件 $\\{I=1\\}$（发生一次人工干预）可以按照发出的状态码进行划分。\n$$\nP(I=1) = \\sum_{i \\in \\mathcal{C}} P(I=1 \\cap E_i)\n$$\n使用条件概率的定义，$P(A \\cap B) = P(A|B)P(B)$，我们得到：\n$$\nP(I=1) = \\sum_{i \\in \\mathcal{C}} P(I=1 | E_i) \\cdot P(E_i)\n$$\n我们把给定代码 $i$ 发生时需要干预的条件概率记为 $P_{\\text{int}|i} = P(I=1|E_i)$。单次测试需要干预的概率公式变为：\n$$\nE[I] = P(I=1) = \\sum_{i \\in \\mathcal{C}} p_i \\cdot P_{\\text{int}|i}\n$$\n$N$ 次测试的预期人工干预总次数为：\n$$\nE[M] = N \\sum_{i \\in \\mathcal{C}} p_i \\cdot P_{\\text{int}|i}\n$$\n现在，我们必须根据问题中的定义，确定每个严重性等级的 $P_{\\text{int}|i}$ 值。\n\n1.  **Critical（严重）严重性**：问题指出需要人工干预的概率为 $1$。\n    因此，对于任何严重状态码 $i$，$P_{\\text{int}|i} = 1$。\n\n2.  **Major（主要）严重性**：只有在所有 $r$ 次自动恢复尝试都失败时才需要人工干预。单次恢复尝试成功的概率是 $q$。因此，单次尝试失败的概率是 $(1-q)$。由于 $r$ 次重试是独立的，所有 $r$ 次都失败的概率是它们各自失败概率的乘积。\n    因此，对于任何具有参数 $q_j$ 和 $r_j$ 的主要状态码 $j$，$P_{\\text{int}|j} = (1 - q_j)^{r_j}$。\n\n3.  **Warning（警告）和 Info（信息性）严重性**：这些不需要人工干预。\n    因此，对于任何警告或信息状态码 $k$，$P_{\\textint|k} = 0$。\n\n综合这些，预期人工干预次数的最终公式是：\n$$\nE[M] = N \\left( \\sum_{i \\in \\text{critical}} p_i \\cdot 1 + \\sum_{j \\in \\text{major}} p_j \\cdot (1-q_j)^{r_j} \\right)\n$$\n其中 $N=10,000$。\n\n我们现在可以将此公式应用于每个测试用例。\n\n**测试用例 A 的示例计算**：\n$N=10,000$。状态码如下：\n- HEMOLYSIS (critical): $p=0.004$。贡献项：$0.004 \\cdot 1 = 0.004$。\n- REAGENT_LOW (major): $p=0.0025, q=0.9, r=2$。贡献项：$0.0025 \\cdot (1-0.9)^2 = 0.0025 \\cdot (0.1)^2 = 0.0025 \\cdot 0.01 = 0.000025$。\n- COMM_TIMEOUT (major): $p=0.006, q=0.8, r=3$。贡献项：$0.006 \\cdot (1-0.8)^3 = 0.006 \\cdot (0.2)^3 = 0.006 \\cdot 0.008 = 0.000048$。\n- CLOT_DETECTED (critical): $p=0.0005$。贡献项：$0.0005 \\cdot 1 = 0.0005$。\n- QC_FAIL (critical): $p=0.0008$。贡献项：$0.0008 \\cdot 1 = 0.0008$。\n- CALIB_REQUIRED (major): $p=0.001, q=0.7, r=1$。贡献项：$0.001 \\cdot (1-0.7)^1 = 0.001 \\cdot 0.3 = 0.0003$。\n- TEMP_HIGH (warning): $p=0.003$。贡献项为 $0$。\n\n这些贡献项的总和是：\n$0.004 + 0.000025 + 0.000048 + 0.0005 + 0.0008 + 0.0003 = 0.005673$。\n\n$N=10,000$ 次测试的预期总干预次数是：\n$E[M_A] = 10000 \\cdot 0.005673 = 56.73$。\n\n对所有其他测试用例遵循相同的步骤。\n- **测试用例 B**：$E[M_B] = 10000 \\cdot (0.00001 \\cdot (1-0.7)^5) = 0.1 \\cdot (0.3)^5 = 0.1 \\cdot 0.00243 = 0.000243$。\n- **测试用例 C**：$E[M_C] = 10000 \\cdot (0.15 \\cdot (1-0.95)^1 + 0.2 \\cdot (1-0.6)^2 + 0.005 \\cdot 1) = 10000 \\cdot (0.15 \\cdot 0.05 + 0.2 \\cdot 0.16 + 0.005) = 10000 \\cdot (0.0075 + 0.032 + 0.005) = 10000 \\cdot (0.0445) = 445.0$。\n- **测试用例 D**：$E[M_D] = 10000 \\cdot (0.05 \\cdot 1 + 0.25 \\cdot (1-0.9)^3 + 0.35 \\cdot (1-0.7)^1 + 0.1 \\cdot 1) = 10000 \\cdot (0.05 + 0.25 \\cdot 0.001 + 0.35 \\cdot 0.3 + 0.1) = 10000 \\cdot (0.05 + 0.00025 + 0.105 + 0.1) = 10000 \\cdot (0.25525) = 2552.5$。\n\n将这些结果四舍五入到 $6$ 位小数，得到：$56.730000$、$0.000243$、$445.000000$ 和 $2552.500000$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Calculates the expected number of manual interventions per 10,000 tests\n    for a suite of test cases based on LIS error handling models.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each test case is a list of dictionaries, where each dictionary\n    # represents a status code with its parameters.\n    test_suite = {\n        \"A\": [\n            {'p': 0.004, 'severity': 'critical'},\n            {'p': 0.0025, 'severity': 'major', 'q': 0.9, 'r': 2},\n            {'p': 0.006, 'severity': 'major', 'q': 0.8, 'r': 3},\n            {'p': 0.0005, 'severity': 'critical'},\n            {'p': 0.0008, 'severity': 'critical'},\n            {'p': 0.001, 'severity': 'major', 'q': 0.7, 'r': 1},\n            {'p': 0.003, 'severity': 'warning'}\n        ],\n        \"B\": [\n            {'p': 0.00001, 'severity': 'major', 'q': 0.7, 'r': 5},\n            {'p': 0.0002, 'severity': 'warning'}\n        ],\n        \"C\": [\n            {'p': 0.15, 'severity': 'major', 'q': 0.95, 'r': 1},\n            {'p': 0.2, 'severity': 'major', 'q': 0.6, 'r': 2},\n            {'p': 0.005, 'severity': 'critical'}\n        ],\n        \"D\": [\n            {'p': 0.05, 'severity': 'critical'},\n            {'p': 0.25, 'severity': 'major', 'q': 0.9, 'r': 3},\n            {'p': 0.35, 'severity': 'major', 'q': 0.7, 'r': 1},\n            {'p': 0.1, 'severity': 'critical'},\n            {'p': 0.25, 'severity': 'warning'}\n        ]\n    }\n\n    # Number of tests for which to calculate the expectation.\n    N_TESTS = 10000.0\n    \n    results = []\n    \n    # Process test cases in a sorted order of their keys to ensure consistent output.\n    for case_name in sorted(test_suite.keys()):\n        status_codes = test_suite[case_name]\n        \n        # This variable holds the expected number of interventions for a single test.\n        # It is the sum of probabilities of intervention for each mutually exclusive status code.\n        expected_interventions_per_test = 0.0\n        \n        for code in status_codes:\n            p = code['p']\n            severity = code['severity']\n            \n            intervention_prob_given_occurrence = 0.0\n            \n            if severity == 'critical':\n                # Intervention probability is 1 for critical errors.\n                intervention_prob_given_occurrence = 1.0\n            elif severity == 'major':\n                # Intervention occurs if all retries fail.\n                q = code['q']\n                r = code['r']\n                prob_retry_failure = 1.0 - q\n                intervention_prob_given_occurrence = math.pow(prob_retry_failure, r)\n            # For 'warning' and 'info', the probability is 0, so no addition is needed.\n\n            # Contribution of this status code to the total probability of intervention\n            # for a single test, using the law of total probability.\n            expected_interventions_per_test += p * intervention_prob_given_occurrence\n            \n        # Total expected interventions for N tests is N * (expected interventions per test)\n        # by linearity of expectation.\n        total_expected_interventions = N_TESTS * expected_interventions_per_test\n        \n        # Round the final result to 6 decimal places as required.\n        rounded_result = round(total_expected_interventions, 6)\n        results.append(f\"{rounded_result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}