{
    "hands_on_practices": [
        {
            "introduction": "$t$检验是生物统计学中的一块基石，但真正掌握它远不止于将数字代入公式。本练习将引导你深入剖析一个配对$t$检验的每一个核心步骤，从构建原假设和备择假设，到选择合适的检验统计量并理解其在原假设下的分布。通过这个实践，你不仅将计算一个$p$值，还将探索其概念性定义，甚至思考当零分布不对称时，“双侧”检验的普适性原则，从而建立对假设检验的深刻理解。",
            "id": "4954547",
            "problem": "一项随机交叉研究评估了一种新的膳食干预是否能改变成年人的空腹低密度脂蛋白胆固醇水平。对于每位参与者，记录其在干预期和对照期间的空腹低密度脂蛋白胆固醇的差异。假设配对差异是独立的，并且服从一个方差未知的正态分布。给定样本量 $n = 27$，样本均值差异 $\\bar{d} = 10$ (单位：mg/dL)，以及样本标准差 $s = 10\\sqrt{\\frac{27}{26}}$ (单位：mg/dL)。\n\n从生物统计学中假设检验的核心定义出发，按以下步骤进行：为双边均值差异检验定义原假设和备择假设；指定一个适用于正态性下方差未知情况的检验统计量，并证明其零分布；根据给定的样本统计数据计算检验统计量的观测值；陈述双边 $p$ 值的概念性含义以及如何从零分布中计算它；并阐明当所选检验统计量的零分布为非对称（即，关于零不对称）时，“双边性”的定义如何推广。\n\n最后，将本研究的双边 $p$ 值表示为一个单一的、精确的、闭式解析表达式，该表达式使用正则化不完全贝塔函数 $I_{x}(a,b)$，并代入所有数值参数。请勿进行数值计算。您的最终答案必须只是一个单一的解析表达式，不带单位。",
            "solution": "首先对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n-   研究类型：随机交叉研究。\n-   测量指标：每位参与者在干预期和对照期间的空腹低密度脂蛋白胆固醇差异。\n-   假设：配对差异是独立的，并服从一个方差未知的正态分布。\n-   样本量：$n = 27$。\n-   样本均值差异：$\\bar{d} = 10$ mg/dL。\n-   样本标准差：$s = 10\\sqrt{\\frac{27}{26}}$ mg/dL。\n-   任务1：为双边均值差异检验定义原假设和备择假设。\n-   任务2：指定一个适用于正态性下方差未知情况的检验统计量，并证明其零分布。\n-   任务3：计算检验统计量的观测值。\n-   任务4：陈述双边 $p$ 值的概念性含义以及如何从零分布中计算它。\n-   任务5：阐明当所选检验统计量的零分布为非对称时，“双边性”的定义如何推广。\n-   任务6：将双边 $p$ 值表示为一个使用正则化不完全贝塔函数 $I_{x}(a,b)$ 的单一、精确、闭式解析表达式。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，在现实情境（胆固醇的交叉试验）中采用了标准的生物统计学方法（配对t检验）。问题陈述清晰，提供了执行所要求的假设检验和推导相关量所需的所有数据（$n$, $\\bar{d}$, $s$）和假设（正态性、独立性）。语言客观、精确。数据是自洽且一致的；$s$ 的具体形式在数学上是有效的，并且似乎是为了简化检验统计量的计算而设计的，这并未使问题无效，反而使其成为一个结构良好的学术练习。该问题不是不适定、琐碎或不可验证的。它直接考察了假设检验的基础知识。\n\n### 步骤3：结论与行动\n该问题有效。将提供完整的解答。\n\n***\n\n解答过程将按问题陈述中列出的各项任务依次进行。\n\n**1. 原假设与备择假设**\n\n假设检验始于构建两个相互竞争的假设。令 $\\mu_d$ 代表空腹低密度脂蛋白胆固醇配对差异的真实总体均值，其中差异计算为（干预组）-（对照组）。\n\n-   **原假设 ($H_0$)** 是关于无效果的陈述。它假定新的膳食干预对平均胆固醇水平没有影响，即真实均值差异为零。\n    $$H_0: \\mu_d = 0$$\n-   对于双边检验，**备择假设 ($H_A$)** 是关于存在效果的陈述。它假定干预确实有影响，导致真实均值差异不为零，但未指明变化的方向。\n    $$H_A: \\mu_d \\neq 0$$\n\n**2. 检验统计量与零分布**\n\n问题陈述指出，配对差异是从一个方差未知的正态分布中抽取的。样本量为 $n = 27$。对于检验一个方差未知的正态分布总体的均值，合适的检验统计量是单样本 Student's t-statistic。\n\n该统计量定义为：\n$$T = \\frac{\\bar{d} - \\mu_{d,0}}{S_E}$$\n其中 $\\bar{d}$ 是样本均值差异，$\\mu_{d,0}$ 是在 $H_0$ 下假设的总体均值差异，而 $S_E$ 是样本均值的标准误。标准误计算公式为 $S_E = \\frac{s}{\\sqrt{n}}$，其中 $s$ 是样本标准差，$n$ 是样本量。\n\n在原假设 ($H_0: \\mu_d = 0$) 下，该统计量变为：\n$$T = \\frac{\\bar{d}}{s / \\sqrt{n}}$$\n根据 Student t 分布的定义，该统计量 $T$ 服从自由度为 $\\nu = n-1$ 的 t 分布。对于本研究，自由度为 $\\nu = 27 - 1 = 26$。使用此分布是合适的，因为它考虑了通过样本数据估计总体方差所引入的额外不确定性。\n\n**3. 检验统计量的观测值**\n\n使用给定的样本统计数据，我们计算检验统计量的观测值，记为 $t_{obs}$。\n-   样本量：$n = 27$。\n-   样本均值差异：$\\bar{d} = 10$。\n-   样本标准差：$s = 10\\sqrt{\\frac{27}{26}}$。\n\n首先，我们计算均值的标准误：\n$$S_E = \\frac{s}{\\sqrt{n}} = \\frac{10\\sqrt{\\frac{27}{26}}}{\\sqrt{27}} = \\frac{10 \\cdot \\frac{\\sqrt{27}}{\\sqrt{26}}}{\\sqrt{27}} = \\frac{10}{\\sqrt{26}}$$\n现在，我们计算观测到的 t 统计量：\n$$t_{obs} = \\frac{\\bar{d}}{S_E} = \\frac{10}{10/\\sqrt{26}} = \\sqrt{26}$$\n\n**4. 双边 $p$ 值的概念含义与计算**\n\n从概念上讲，**$p$ 值**是在原假设为真的前提下，观测到至少与实际观测到的检验统计量一样极端或更极端的检验统计量的概率。“极端”的定义由备择假设决定。\n\n对于**双边检验**，“极端”意味着在任一方向（正向或负向）上远离零分布的中心。t 分布的中心是 $0$。因此，双边 $p$ 值是在零分布 ($T \\sim t_{26}$) 下，检验统计量的绝对值大于或等于观测到的检验统计量绝对值 ($|t_{obs}|$) 的概率。\n$$p\\text{-value} = P(|T| \\ge |t_{obs}| \\mid H_0)$$\n由于 t 分布关于 $0$ 对称，这个概率可以通过计算一侧尾部的概率然后乘以 2 来得到：\n$$p\\text{-value} = P(T \\ge |t_{obs}|) + P(T \\le -|t_{obs}|) = 2 \\times P(T \\ge |t_{obs}|)$$\n对于本研究，当 $t_{obs} = \\sqrt{26}$ 时，$p$ 值为 $2 \\times P(T \\ge \\sqrt{26})$，其中 $T \\sim t_{26}$。\n\n**5. “双边性”在非对称分布中的推广**\n\n对于零分布关于 $0$ 对称（例如，正态分布、t 分布）的检验统计量，“等尾”法 ($2 \\times P(T \\ge |t_{obs}|)$) 是明确的。然而，对于非对称的零分布（例如，卡方分布、F 分布），“双边性”的概念没有统一的定义。核心原则保持不变：$p$ 值是所有至少与观测结果同样不可能的事件的概率之和。\n\n最符合原则的推广是**概率密度法**。设 $f(x)$ 是原假设下检验统计量 $X$ 的概率密度函数 (PDF)，并设 $x_{obs}$ 是观测值。比 $x_{obs}$ “同样极端或更极端”的结果集合被定义为所有满足其概率密度小于或等于观测值处概率密度的 $x$ 值的集合，即 $\\{x \\mid f(x) \\le f(x_{obs})\\}$。$p$ 值是概率密度函数在该集合上的积分：\n$$p\\text{-value} = \\int_{\\{x \\mid f(x) \\le f(x_{obs})\\}} f(x) \\, dx$$\n对于单峰分布，这个集合通常由两个不相交的尾部组成，从而保留了检验的“双边”性质。这个定义确保了任何发生概率相等或更小的结果都会对 $p$ 值做出贡献。\n\n**6. 使用正则化不完全贝塔函数表示 $p$ 值**\n\n最后的任务是将双边 $p$ 值，$p = 2 \\times P(T \\ge \\sqrt{26})$ 其中 $T \\sim t_{26}$，用正则化不完全贝塔函数 $I_{x}(a,b)$ 来表示。\n\n对于一个正值 $t$，自由度为 $\\nu$ 的 Student t 分布的累积分布函数 (CDF) 与 $I_{x}(a,b)$ 通过以下公式相关联：\n$$P(T_\\nu \\le t) = 1 - \\frac{1}{2} I_{z}\\left(\\frac{\\nu}{2}, \\frac{1}{2}\\right)$$\n其中 $z = \\frac{\\nu}{\\nu + t^2}$。\n\n因此，上尾的概率为：\n$$P(T_\\nu \\ge t) = 1 - P(T_\\nu \\le t) = 1 - \\left(1 - \\frac{1}{2} I_{z}\\left(\\frac{\\nu}{2}, \\frac{1}{2}\\right)\\right) = \\frac{1}{2} I_{z}\\left(\\frac{\\nu}{2}, \\frac{1}{2}\\right)$$\n双边 $p$ 值是这个尾部概率的两倍：\n$$p = 2 \\times P(T_\\nu \\ge t) = 2 \\times \\left(\\frac{1}{2} I_{z}\\left(\\frac{\\nu}{2}, \\frac{1}{2}\\right)\\right) = I_{z}\\left(\\frac{\\nu}{2}, \\frac{1}{2}\\right)$$\n我们将此问题的具体数值代入：\n-   自由度：$\\nu = 26$。\n-   观测统计量：$t_{obs} = \\sqrt{26}$。\n-   贝塔函数的参数：$a = \\frac{\\nu}{2} = \\frac{26}{2} = 13$ 以及 $b = \\frac{1}{2}$。\n-   贝塔函数的自变量：$z = \\frac{\\nu}{\\nu + t_{obs}^2} = \\frac{26}{26 + (\\sqrt{26})^2} = \\frac{26}{26 + 26} = \\frac{26}{52} = \\frac{1}{2}$。\n\n将这些值代入 $p$ 值的表达式，得到最终的解析形式。\n$$p = I_{\\frac{1}{2}}\\left(13, \\frac{1}{2}\\right)$$",
            "answer": "$$\\boxed{I_{\\frac{1}{2}}\\left(13, \\frac{1}{2}\\right)}$$"
        },
        {
            "introduction": "假设检验并不总是依赖于理论上的概率分布。本练习介绍了一种强大且假设要求极少的非参数方法——随机化检验。与依赖正态性等假设的传统检验不同，随机化检验利用研究设计本身的随机分配机制，直接从观测数据中生成原假设下的零分布。通过完成这个动手编程练习，你将从第一性原理出发构建一个假设检验，深刻体会到检验逻辑与随机化试验设计之间的直接联系。",
            "id": "4954539",
            "problem": "给定一个完全随机化设计的随机试验：$n$ 名参与者中，恰好有 $m$ 名被分配到处理组，其余 $n-m$ 名被分配到对照组。在无处理效应的尖锐零假设（Sharp Null Hypothesis of No Treatment Effect）下，每位参与者在处理条件下的结果等于其在对照条件下的结果。任务是实现并执行一个随机化检验，该检验利用已知的分配机制来生成均值差异的零分布，然后计算双边 $p$ 值。\n\n起点和核心定义：\n- 该试验有 $n$ 个单元，索引为 $i \\in \\{1,\\dots,n\\}$，具有观测结果 $Y_i$ 和一个二元分配指示变量 $Z_i \\in \\{0,1\\}$，其中 $Z_i=1$ 表示接受处理。\n- 无处理效应的尖锐零假设陈述为：对所有 $i$，$Y_i(1)=Y_i(0)$。这意味着在零假设下，观测结果 $Y_i$ 对于重新分配是不变的。\n- 在完全随机化设计中，分配机制通过从 $\\binom{n}{m}$ 个可能的、恰好包含 $m$ 个 1 的二元分配向量 $\\mathbf{Z}$ 中均匀随机地选择一个来分配处理标签。\n- 检验统计量是均值差异，\n$$\nT(\\mathbf{Z}, \\mathbf{Y}) \\;=\\; \\overline{Y}_{\\text{treated}} - \\overline{Y}_{\\text{control}} \\;=\\; \\frac{1}{m}\\sum_{i:Z_i=1}Y_i \\;-\\; \\frac{1}{n-m}\\sum_{i:Z_i=0}Y_i.\n$$\n- 在零假设下，$T(\\mathbf{Z}, \\mathbf{Y})$ 的随机化分布是通过从分配机制中枚举（或抽样）分配向量 $\\mathbf{Z}'$，并使用固定的观测结果 $\\mathbf{Y}$ 计算 $T(\\mathbf{Z}', \\mathbf{Y})$ 来生成的。\n- 双边 $p$ 值是在零分布下观测到至少与观测到的检验统计量一样极端的检验统计量的尾部概率，计算为满足 $\\left|T(\\mathbf{Z}', \\mathbf{Y})\\right| \\ge \\left|T(\\mathbf{Z}, \\mathbf{Y})\\right|$ 的分配所占的比例。为确保蒙特卡洛近似的有效性，请使用加一调整：如果使用了 $B$ 次零假设下的抽样，则报告 $\\frac{c+1}{B+1}$，其中 $c$ 是极端性至少与观测统计量相当的抽样次数。\n\n实现假设检验的以下步骤：\n1. 陈述假设：$H_0$ (尖锐零假设) 对 $H_1$ (存在至少一个单元满足 $Y_i(1)\\ne Y_i(0)$)。\n2. 选择上文定义的检验统计量 $T(\\mathbf{Z}, \\mathbf{Y})$。\n3. 当精确枚举在计算上不可行时，通过对所有 $\\binom{n}{m}$ 种分配进行精确枚举，或通过对 $B$ 个分配进行蒙特卡洛抽样，来利用分配机制构建 $T$ 的零分布。\n4. 使用零分布计算双边 $p$ 值，并在使用抽样时应用加一调整。\n5. 以小数形式（而非百分比）报告 $p$ 值。不涉及物理单位。\n\n您的程序必须实现此过程，并将其应用于下面的测试套件。对于每种情况，生成双边随机化检验的 $p$ 值。如果指定了精确枚举，则枚举完全随机化设计中的所有分配；如果指定了蒙特卡洛抽样，则使用提供的 $B$ 和随机种子。\n\n测试套件：\n- 情况 1 (精确，小 $n$)：\n  - $Y = [5.1, 4.9, 5.0, 5.3, 5.2, 5.4]$\n  - $Z = [1, 1, 1, 0, 0, 0]$\n  - 方法：精确\n- 情况 2 (蒙特卡洛，大 $n$)：\n  - $Y = [10.2, 9.8, 10.0, 9.5, 10.4, 9.7, 10.3, 9.6, 10.1, 9.9, 8.8, 9.0, 9.2, 8.9, 9.1, 8.7, 9.3, 8.6, 9.4, 8.5]$\n  - $Z = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$\n  - 方法：蒙特卡洛，使用 $B=20000$ 次抽样和种子 $123$\n- 情况 3 (精确，零差异边界)：\n  - $Y = [1.0, 2.0, 1.0, 2.0]$\n  - $Z = [1, 0, 0, 1]$\n  - 方法：精确\n- 情况 4 (精确，非均衡分配)：\n  - $Y = [12.0, 10.0, 11.0, 9.0, 8.0, 13.0, 7.0]$\n  - $Z = [1, 1, 0, 0, 0, 0, 0]$\n  - 方法：精确\n- 情况 5 (精确，强效应)：\n  - $Y = [20.0, 21.0, 19.0, 22.0, 5.0, 6.0, 7.0, 4.0]$\n  - $Z = [1, 1, 1, 1, 0, 0, 0, 0]$\n  - 方法：精确\n\n输出规范：\n- 计算每种情况的双边随机化检验 $p$ 值。\n- 将每个 $p$ 值表示为小数并四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[p_1, p_2, p_3, p_4, p_5]$，其中 $p_j$ 表示上面所列顺序中第 $j$ 种情况的 $p$ 值。",
            "solution": "该问题要求实现一个随机化检验，以计算在完全随机化试验中，针对无处理效应的尖锐零假设（Sharp Null Hypothesis）的双边 $p$ 值。解决方案涉及定义统计框架、计算观测到的检验统计量、在指定的分配机制下生成该统计量的零分布，并最终计算 $p$ 值。\n\n### 基于原则的设计\n\n**1. 假设和形式化设定**\n\n实验设置包括 $n$ 个单元，我们为这些单元观测到一个结果向量 $\\mathbf{Y} = (Y_1, \\dots, Y_n)$ 和一个处理分配向量 $\\mathbf{Z} = (Z_1, \\dots, Z_n)$。如果单元 $i$ 在处理组中，则分配指示变量 $Z_i$ 为 $1$，如果在对照组中，则为 $0$。在一个有 $m$ 个处理单元的完全随机化设计中，分配向量 $\\mathbf{Z}$ 是从所有长度为 $n$ 且恰好包含 $m$ 个 1 的二元向量集合中随机抽取的一个。此类分配的总数为 $\\binom{n}{m}$。\n\n潜在结果框架为每个单元 $i$ 定义了两个结果：$Y_i(1)$（如果接受处理时的结果）和 $Y_i(0)$（如果不接受处理时的结果）。观测到的结果是 $Y_i = Z_i Y_i(1) + (1-Z_i)Y_i(0)$。\n\n待检验的假设是：\n- **零假设 ($H_0$)**：无处理效应的尖锐零假设，该假设陈述对于每个单元 $i$，处理均无效果。形式上，$H_0: Y_i(1) = Y_i(0)$ 对所有 $i \\in \\{1, \\dots, n\\}$ 成立。\n- **备择假设 ($H_1$)**：尖锐零假设的否定，该假设假定至少存在一个单元 $i$，处理对其有效果。形式上，$H_1: \\exists i \\text{ 使得 } Y_i(1) \\neq Y_i(0)$。\n\n尖锐零假设的一个关键推论是，观测结果 $Y_i$ 是固定的，并且无论处理分配如何，它们都将保持不变。也就是说，在 $H_0$ 下，$Y_i = Y_i(1) = Y_i(0)$。这种不变性使我们能够在评估不同假设分配的效果时，将向量 $\\mathbf{Y}$ 视为一组固定的数字。\n\n**2. 检验统计量**\n\n所选的检验统计量是处理组和对照组之间平均结果的差异：\n$$\nT(\\mathbf{Z}, \\mathbf{Y}) = \\overline{Y}_{\\text{treated}} - \\overline{Y}_{\\text{control}} = \\frac{\\sum_{i:Z_i=1} Y_i}{m} - \\frac{\\sum_{i:Z_i=0} Y_i}{n-m}\n$$\n其中 $m = \\sum_{i=1}^n Z_i$ 是处理单元的数量，$n-m$ 是对照单元的数量。我们首先使用每个测试用例中提供的数据计算此统计量的观测值 $T_{\\text{obs}} = T(\\mathbf{Z}_{\\text{obs}}, \\mathbf{Y}_{\\text{obs}})$。\n\n**3. 零分布的构建**\n\n随机化检验的核心逻辑是在零假设下生成检验统计量 $T$ 的分布。由于 $H_0$ 意味着结果 $\\mathbf{Y}$ 是固定的，唯一的随机性来源是分配向量 $\\mathbf{Z}$。因此，零分布由所有可能通过分配机制实现的分配向量 $\\mathbf{Z}'$ 所对应的 $T(\\mathbf{Z}', \\mathbf{Y})$ 值组成。\n\n根据问题规定，构建此分布有两种方法：\n\n- **精确枚举**：如果可能分配的数量 $\\binom{n}{m}$ 在计算上是可处理的，我们可以枚举所有这些分配。对于每个可能的分配向量 $\\mathbf{Z}'$，我们计算相应的统计量 $T' = T(\\mathbf{Z}', \\mathbf{Y})$。所有这些值 $\\{T'\\}$ 的集合构成了精确的零分布。这涉及生成所有从 $n$ 个索引中选取 $m$ 个来代表处理组的组合。\n\n- **蒙特卡洛抽样**：当 $\\binom{n}{m}$ 对于完全枚举而言过大时，我们通过从所有可能的分配集合中抽取大量的（$B$ 个）随机分配 $\\mathbf{Z}'_1, \\mathbf{Z}'_2, \\dots, \\mathbf{Z}'_B$ 来近似零分布。对于每次抽样 $\\mathbf{Z}'_j$，我们计算统计量 $T'_j = T(\\mathbf{Z}'_j, \\mathbf{Y})$。这 $B$ 个统计量的经验分布可作为真实零分布的近似。通过获取观测到的分配向量 $\\mathbf{Z}_{\\text{obs}}$ 并随机排列其元素来生成一个随机分配。使用随机种子确保了可复现性。\n\n**4. P 值计算**\n\n双边 $p$ 值是在零假设下，观测到至少与实际观测到的检验统计量一样极端的检验统计量的概率。“极端”由绝对值来衡量。\n\n对于**精确方法**，$p$ 值是零分布中检验统计量的绝对值至少与观测统计量一样大的分配所占的比例：\n$$\np = \\frac{\\left| \\{ \\mathbf{Z}' : |T(\\mathbf{Z}', \\mathbf{Y})| \\ge |T_{\\text{obs}}| \\} \\right|}{\\binom{n}{m}}\n$$\n其中 $|\\cdot|$ 表示集合的基数。\n\n对于**蒙特卡洛方法**，$p$ 值是使用 $B$ 个模拟统计量来估计的。我们计算模拟统计量至少与观测统计量一样极端的模拟次数 $c$：$c = \\sum_{j=1}^B \\mathbb{I}(|T'_j| \\ge |T_{\\text{obs}}|)$，其中 $\\mathbb{I}(\\cdot)$ 是指示函数。问题指定使用加一调整（或连续性校正），以避免报告 $p$ 值为 $0$，并改善统计特性，特别是对于较小的 $B$：\n$$\np = \\frac{c+1}{B+1}\n$$\n\n整个过程在一个 Python 函数中实现，该函数将观测数据和过程参数作为输入，并返回按规定四舍五入的计算出的 $p$ 值。\n\n```python\nimport numpy as np\nimport itertools\n\ndef compute_statistic(Y, Z):\n    \"\"\"\n    Computes the difference in means between treated and control groups.\n    Y: array of observed outcomes.\n    Z: binary assignment vector (1=treatment, 0=control).\n    \"\"\"\n    m = np.sum(Z)\n    n = len(Y)\n    \n    # The problem constraints ensure that m > 0 and n-m > 0.\n    mean_treated = np.sum(Y * Z) / m\n    mean_control = np.sum(Y * (1 - Z)) / (n - m)\n    \n    return mean_treated - mean_control\n\ndef calculate_p_value(Y, Z_obs, method, B=None, seed=None):\n    \"\"\"\n    Calculates the randomization test p-value for the sharp null hypothesis.\n    \"\"\"\n    n = len(Y)\n    m = int(np.sum(Z_obs))\n    \n    t_obs = compute_statistic(Y, Z_obs)\n    abs_t_obs = np.abs(t_obs)\n\n    if method == 'exact':\n        indices = np.arange(n)\n        null_stats = []\n        \n        # Generate all combinations of m indices for the treatment group\n        for treat_indices in itertools.combinations(indices, m):\n            Z_prime = np.zeros(n, dtype=int)\n            Z_prime[list(treat_indices)] = 1\n            t_prime = compute_statistic(Y, Z_prime)\n            null_stats.append(t_prime)\n            \n        null_stats = np.array(null_stats)\n        # To handle potential floating point inaccuracies, a small tolerance is used.\n        # abs_t_obs - 1e-9 ensures that values equal to abs_t_obs are included.\n        count_extreme = np.sum(np.abs(null_stats) >= abs_t_obs - 1e-9)\n        p_value = count_extreme / len(null_stats)\n        \n    elif method == 'Monte Carlo':\n        # Legacy random number generation for reproducibility as per common practice\n        # when a simple seed is specified.\n        np.random.seed(seed)\n        count_extreme = 0\n        \n        for _ in range(B):\n            # A new random assignment is a random permutation of the observed one.\n            Z_prime = np.random.permutation(Z_obs)\n            t_prime = compute_statistic(Y, Z_prime)\n            if np.abs(t_prime) >= abs_t_obs - 1e-9:\n                count_extreme += 1\n        \n        p_value = (count_extreme + 1) / (B + 1)\n        \n    return p_value\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (exact, small n)\n        {'Y': np.array([5.1, 4.9, 5.0, 5.3, 5.2, 5.4]),\n         'Z': np.array([1, 1, 1, 0, 0, 0]),\n         'method': 'exact', 'B': None, 'seed': None},\n        # Case 2 (Monte Carlo, larger n)\n        {'Y': np.array([10.2, 9.8, 10.0, 9.5, 10.4, 9.7, 10.3, 9.6, 10.1, 9.9,\n                        8.8, 9.0, 9.2, 8.9, 9.1, 8.7, 9.3, 8.6, 9.4, 8.5]),\n         'Z': np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n         'method': 'Monte Carlo', 'B': 20000, 'seed': 123},\n        # Case 3 (exact, zero difference boundary)\n        {'Y': np.array([1.0, 2.0, 1.0, 2.0]),\n         'Z': np.array([1, 0, 0, 1]),\n         'method': 'exact', 'B': None, 'seed': None},\n        # Case 4 (exact, unbalanced allocation)\n        {'Y': np.array([12.0, 10.0, 11.0, 9.0, 8.0, 13.0, 7.0]),\n         'Z': np.array([1, 1, 0, 0, 0, 0, 0]),\n         'method': 'exact', 'B': None, 'seed': None},\n        # Case 5 (exact, strong effect)\n        {'Y': np.array([20.0, 21.0, 19.0, 22.0, 5.0, 6.0, 7.0, 4.0]),\n         'Z': np.array([1, 1, 1, 1, 0, 0, 0, 0]),\n         'method': 'exact', 'B': None, 'seed': None}\n    ]\n\n    results = []\n    for case in test_cases:\n        p_value = calculate_p_value(case['Y'], case['Z'], case['method'], case['B'], case['seed'])\n        results.append(f\"{p_value:.6f}\")\n\n    # This function is not called in the final output, but is used to generate the answer.\n    # The final answer is the string printed by this function.\n    # print(f\"[{','.join(results)}]\")\n\n```",
            "answer": "[0.100000,0.000050,1.000000,0.285714,0.028571]"
        },
        {
            "introduction": "在现代临床试验中，研究者常常评估一种新疗法对多个终点的影响，以获得对其临床效益的全面认识。然而，进行多重检验会增加仅凭偶然性就得出阳性结论的风险，即“多重性问题”。本练习将带你运用Holm方法这一强大的工具来控制族错误率（FWER），确保在面对多个假设时，我们所得结论的统计严谨性。这是一个在真实科研场景中至关重要的实践技能。",
            "id": "4954555",
            "problem": "一项随机、平行分组的临床试验，通过评估新疗法相对于标准治疗在多个共同主要终点上的效果，来评定其总体临床获益。该试验有 $5$ 个终点：C-反应蛋白降低、疼痛评分降低、6分钟步行距离增加、疾病活动指数降低以及医生总体评估改善。对每个终点，都进行了一项有效的双侧假设检验，以比较新疗法与标准治疗的效果，得到了以下未经校正的 $p$ 值：C-反应蛋白降低 $p=0.048$，疼痛评分降低 $p=0.004$，6分钟步行距离 $p=0.041$，疾病活动指数 $p=0.013$，医生总体评估 $p=0.22$。该研究的科学目标是在这 $5$ 个检验中，将家族谬误率（FWER）控制在 $\\alpha=0.05$ 的水平。\n\n请根据基于核心定义的假设检验步骤，按如下方式进行：\n- 明确陈述每个终点的原假设和备择假设，即无治疗效应与有治疗效应的对比。\n- 指出被控制的相关错误率，并论证在多终点的情况下进行多重性校正的必要性。\n- 用定性的术语描述 Holm 序贯拒绝法的决策框架，并相应地对给定的未经校正的 $p$ 值进行排序。\n- 计算 6 分钟步行距离终点的 Holm 校正 $p$ 值，确保校正后 $p$ 值的单调性属性得到遵守。\n- 用文字解释，在控制 FWER 的前提下，对于 $\\alpha=0.05$ 水平，这个校正后的 $p$ 值对 6 分钟步行距离终点意味着是拒绝还是不拒绝其原假设。\n\n只报告 6 分钟步行距离终点的 Holm 校正 $p$ 值，四舍五入到四位有效数字。报告的数字中不要包含任何单位。",
            "solution": "该问题展示了一个来自生物统计学的有效场景，涉及对具有多个终点的临床试验的分析。它具有科学依据，提法得当且客观。所有必要的数据均已提供，任务是应用一个标准的统计程序，即 Holm-Bonferroni 方法，来控制家族谬误率（FWER）。\n\n问题陈述要求进行涉及多个步骤的结构化分析，我们将系统地遵循这些步骤。\n\n**1. 原假设和备择假设**\n\n对于一项在 $m=5$ 个终点上比较新疗法和标准治疗的临床试验，我们为每个终点建立一对假设。设索引 $i$ 代表 $5$ 个终点中的每一个。原假设 $H_{0,i}$ 假定新疗法和标准治疗之间没有效果差异。备择假设 $H_{A,i}$ 假定存在差异。\n\n-   $H_{0,i}$：终点 $i$ 没有治疗效应。（例如，新疗法组 6 分钟步行距离的真实平均变化量等于标准治疗组的真实平均变化量）。\n-   $H_{A,i}$：终点 $i$ 有治疗效应。（例如，新疗法组 6 分钟步行距离的真实平均变化量不等于标准治疗组的真实平均变化量）。这是一个双侧备择假设，这是标准做法，除非有强有力的理由预先指定了方向性效应。\n\n该表述适用于所有五个终点：C-反应蛋白、疼痛评分、6分钟步行距离、疾病活动指数和医生总体评估。\n\n**2. 家族谬误率（FWER）与多重性校正的必要性**\n\n家族谬误率（FWER）是在一系列假设检验中，犯下至少一个 I 类错误（假阳性，即拒绝了真实的原假设）的概率。当同时检验多个假设时，如果每个检验都简单地以名义显著性水平 $\\alpha$ 进行评估，那么犯下至少一个此类错误的概率会膨胀。\n\n如果我们进行 $m$ 个独立的检验，每个检验的显著性水平为 $\\alpha$，并且所有 $m$ 个原假设都为真，那么正确地不拒绝单个原假设的概率是 $1 - \\alpha$。正确地不拒绝所有 $m$ 个原假设的概率是 $(1 - \\alpha)^m$。因此，FWER 由下式给出：\n\n$$ \\text{FWER} = 1 - (1 - \\alpha)^m $$\n\n在本问题中，有 $m=5$ 个终点，期望的控制水平为 $\\alpha = 0.05$，未经校正的 FWER 将是：\n\n$$ \\text{FWER} = 1 - (1 - 0.05)^5 = 1 - (0.95)^5 \\approx 1 - 0.77378 \\approx 0.2262 $$\n\n这个约 $22.6\\%$ 的 FWER 显著高于可接受的 $5\\%$ 的比率。为了将假阳性结论的总体概率维持在期望的 $\\alpha=0.05$ 或以下，需要进行多重性校正程序。Holm-Bonferroni 方法就是一种设计用来控制 FWER 的程序。\n\n**3. Holm 序贯拒绝法与 p 值的排序**\n\nHolm 方法是一种降步法，可以对 FWER 提供强控制。它比经典的 Bonferroni 校正功效更强。该过程操作如下：\n\n1.  将 $m$ 个未经校正的 $p$ 值从小到大排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。令 $H_{0,(j)}$ 为与第 $j$ 个排序的 $p$ 值 $p_{(j)}$ 相对应的原假设。\n2.  从最小的 $p$ 值 $p_{(1)}$ 开始。将其与校正后的显著性水平 $\\frac{\\alpha}{m}$ 进行比较。如果 $p_{(1)} \\le \\frac{\\alpha}{m}$，则拒绝 $H_{0,(1)}$ 并进入下一步。否则，不拒绝 $H_{0,(1)}$ 及所有后续的原假设，并停止。\n3.  依次进行。对于每一步 $j=2, \\dots, m$，如果上一步拒绝了假设 $H_{0,(j-1)}$，则将 $p_{(j)}$ 与校正后的显著性水平 $\\frac{\\alpha}{m - j + 1}$ 进行比较。如果 $p_{(j)} \\le \\frac{\\alpha}{m - j + 1}$，则拒绝 $H_{0,(j)}$ 并继续。否则，不拒绝 $H_{0,(j)}$ 及所有后续的假设（$H_{0,(j+1)}, \\dots, H_{0,(m)}$），并停止。\n\n给定的未经校正的 $p$ 值为：\n-   C-反应蛋白: $p=0.048$\n-   疼痛评分: $p=0.004$\n-   6分钟步行距离: $p=0.041$\n-   疾病活动指数: $p=0.013$\n-   医生总体评估: $p=0.22$\n\n对这 $m=5$ 个 p 值进行排序：\n-   $p_{(1)} = 0.004$ (疼痛评分)\n-   $p_{(2)} = 0.013$ (疾病活动指数)\n-   $p_{(3)} = 0.041$ (6分钟步行距离)\n-   $p_{(4)} = 0.048$ (C-反应蛋白)\n-   $p_{(5)} = 0.22$ (医生总体评估)\n\n**4. Holm 校正 p 值的计算**\n\n第 $j$ 个排序假设的 Holm 校正 $p$ 值，记为 $\\tilde{p}_{\\text{Holm},(j)}$，其计算方法是强制其单调不减。中间校正值的公式为 $\\tilde{p}_{(j)}' = (m-j+1)p_{(j)}$。最终的校正 $p$ 值是这些中间值的累积最大值。\n\n$$ \\tilde{p}_{\\text{Holm},(j)} = \\max_{k=1,\\dots,j} \\{ (m-k+1)p_{(k)} \\} $$\n或者，这可以递归地表示为：\n$$ \\tilde{p}_{\\text{Holm},(j)} = \\max( \\tilde{p}_{\\text{Holm},(j-1)}, (m-j+1)p_{(j)} ) $$\n其中 $\\tilde{p}_{\\text{Holm},(0)} = 0$。\n\n我们需要计算“6分钟步行距离”终点的校正 $p$ 值，它对应于第三个排序的原始 $p$ 值，$p_{(3)} = 0.041$。\n\n-   对于 $j=1$：$p_{(1)} = 0.004$。\n    $$ \\tilde{p}_{\\text{Holm},(1)} = (5-1+1)p_{(1)} = 5 \\times 0.004 = 0.020 $$\n\n-   对于 $j=2$：$p_{(2)} = 0.013$。\n    $$ \\tilde{p}_{\\text{Holm},(2)} = \\max(\\tilde{p}_{\\text{Holm},(1)}, (5-2+1)p_{(2)}) = \\max(0.020, 4 \\times 0.013) = \\max(0.020, 0.052) = 0.052 $$\n\n-   对于 $j=3$：$p_{(3)} = 0.041$。这是目标值。\n    $$ \\tilde{p}_{\\text{Holm},(3)} = \\max(\\tilde{p}_{\\text{Holm},(2)}, (5-3+1)p_{(3)}) = \\max(0.052, 3 \\times 0.041) = \\max(0.052, 0.123) = 0.123 $$\n\n6分钟步行距离终点的 Holm 校正 $p$ 值为 $0.123$。问题要求四舍五入到四位有效数字，得到 $0.1230$。\n\n**5. 校正后 p 值的解释**\n\n计算得出的 6 分钟步行距离终点的 Holm 校正 $p$ 值为 $\\tilde{p}_{\\text{walk}} = 0.1230$。决策规则是将此校正后的 $p$ 值与预先指定的家族显著性水平 $\\alpha=0.05$ 进行比较。\n\n由于 $\\tilde{p}_{\\text{walk}} = 0.1230 > \\alpha = 0.05$，我们未能拒绝此终点 ($H_{0,(3)}$) 的原假设。\n\n在实际意义上，这意味着在为了将假阳性发现的总体概率控制在 $5\\%$ 而考虑了对五个共同主要终点的检验后，6分钟步行距离的观察结果（未经校正的 $p$ 值为 $0.041$）在统计学上不显著。没有足够的证据断定新疗法对 6 分钟步行距离有影响。对于前两个假设（疼痛评分和疾病活动指数），决策是：疼痛评分的原假设被拒绝，因为其校正后 $p$ 值 $0.020 \\le \\alpha$；而疾病活动指数的原假设不被拒绝，因为其校正后 $p$ 值 $\\tilde{p}_{\\text{Holm},(2)}=0.052 > 0.05$。因此，Holm 过程只拒绝了第一个假设。然而，校正后 p 值本身的解释独立于序贯检验。一个校正后的 p 值是该假设将被拒绝的最小 FWER 水平 $\\alpha$。由于 $0.1230 > 0.05$，我们未能拒绝。",
            "answer": "$$\n\\boxed{0.1230}\n$$"
        }
    ]
}