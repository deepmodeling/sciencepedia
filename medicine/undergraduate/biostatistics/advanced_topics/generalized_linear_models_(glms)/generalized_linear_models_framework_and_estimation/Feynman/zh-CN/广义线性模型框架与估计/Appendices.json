{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握广义线性模型，理解其估计过程的数学原理至关重要。本练习将带您深入逻辑斯蒂回归的“引擎盖下”，从第一性原理出发，为最常见的GLM之一推导其核心估计组件。通过亲手推导对数似然函数 $\\ell(\\beta)$、梯度向量 $\\nabla \\ell(\\beta)$ 和Hessian矩阵 $\\nabla^{2} \\ell(\\beta)$，您将清晰地看到诸如牛顿-拉弗森等优化算法是如何利用这些量来迭代寻找最大似然估计值的 。这项基础性练习将为您理解所有GLM的参数估计机制打下坚实的基础。",
            "id": "4914224",
            "problem": "一项生物统计学研究记录了血样中某种特定生物标志物存在的二元结果。对于每个受试者 $i$（其中 $i \\in \\{1,\\dots,n\\}$），结果 $Y_{i} \\in \\{0,1\\}$ 表示该生物标志物的不存在或存在，而单个连续协变量 $X_{i} \\in \\mathbb{R}$ 记录了一个标准化的暴露得分。假设受试者是独立的，并且在给定 $X_{i}$ 的条件下，$Y_{i}$ 服从均值为 $\\mu_{i} = \\mathbb{E}(Y_{i} \\mid X_{i})$ 的伯努利模型。考虑一个广义线性模型 (GLM)，其伯努利分布使用规范 logit 连接函数，因此连接函数满足 $\\ln\\!\\big(\\mu_{i}/(1-\\mu_{i})\\big) = \\beta_{0} + \\beta_{1} X_{i}$，其中 $\\beta = (\\beta_{0},\\beta_{1})^{\\top}$ 是一个包含截距和单个斜率的未知参数向量。仅从独立性假设、伯努利概率质量函数和规范连接的定义出发，推导以下量作为 $\\beta$ 和观测数据 $\\{(y_{i},x_{i})\\}_{i=1}^{n}$ 的显式函数：\n\n1. 对数似然函数 $\\ell(\\beta)$。\n2. 梯度（得分）向量 $\\nabla \\ell(\\beta)$。\n3. 海森矩阵 $\\nabla^{2} \\ell(\\beta)$。\n\n使用关于 $i$ 的求和以及 $\\beta$ 和数据的初等函数来表示每个量。您的最终表达式必须仅依赖于 $\\beta_{0}$、$\\beta_{1}$、$\\{x_{i}\\}_{i=1}^{n}$ 和 $\\{y_{i}\\}_{i=1}^{n}$，不得引入任何未定义的简写。最终答案应将这三个推导出的表达式作为一个单一的解析表达式一起呈现。不需要进行数值计算，也不需要四舍五入。",
            "solution": "该问题陈述是关于二元数据的广义线性模型（GLM）背景下的一个标准推导练习，并已被验证为具有科学依据、问题适定、客观且完整。没有缺陷。我们接下来推导对数似然函数、其梯度及其海森矩阵。\n\n该模型是为 $n$ 个独立受试者指定的，索引为 $i=1, \\dots, n$。对于每个受试者，我们有一个二元结果 $Y_i \\in \\{0, 1\\}$ 和一个连续协变量 $X_i \\in \\mathbb{R}$。\n给定 $X_i=x_i$ 时，$Y_i$ 的条件分布是均值为 $\\mu_i = \\mathbb{E}(Y_i \\mid X_i)$ 的伯努利分布。单个观测值 $y_i$ 的概率质量函数（PMF）为：\n$$ P(Y_i = y_i \\mid X_i=x_i) = \\mu_i^{y_i} (1-\\mu_i)^{1-y_i} $$\n该模型使用一个 logit 连接函数，它将均值 $\\mu_i$ 连接到一个线性预测变量 $\\eta_i$：\n$$ \\eta_i = \\ln\\left(\\frac{\\mu_i}{1-\\mu_i}\\right) = \\beta_0 + \\beta_1 x_i $$\n其中 $\\beta = (\\beta_0, \\beta_1)^\\top$ 是参数向量。\n\n为了用 $\\beta$ 表示似然函数，我们必须首先将 $\\mu_i$ 表示为 $\\eta_i$ 的函数。对 logit 连接函数求逆可得：\n$$ \\frac{\\mu_i}{1-\\mu_i} = \\exp(\\eta_i) \\implies \\mu_i = \\exp(\\eta_i) - \\mu_i \\exp(\\eta_i) \\implies \\mu_i(1+\\exp(\\eta_i)) = \\exp(\\eta_i) $$\n$$ \\mu_i = \\frac{\\exp(\\eta_i)}{1+\\exp(\\eta_i)} = \\frac{1}{1+\\exp(-\\eta_i)} $$\n同样，我们求出 $1-\\mu_i$ 的表达式：\n$$ 1 - \\mu_i = 1 - \\frac{\\exp(\\eta_i)}{1+\\exp(\\eta_i)} = \\frac{1+\\exp(\\eta_i)-\\exp(\\eta_i)}{1+\\exp(\\eta_i)} = \\frac{1}{1+\\exp(\\eta_i)} $$\n\n在将 $\\mu_i$ 用 $\\eta_i = \\beta_0 + \\beta_1 x_i$ 定义后，我们现在可以推导所需的量。观测数据表示为 $\\{(y_i, x_i)\\}_{i=1}^n$。\n\n**1. 对数似然函数 $\\ell(\\beta)$**\n\n由于受试者的独立性，总似然函数 $L(\\beta)$ 是各个概率的乘积：\n$$ L(\\beta) = \\prod_{i=1}^n P(Y_i=y_i \\mid X_i=x_i) = \\prod_{i=1}^n \\mu_i^{y_i} (1-\\mu_i)^{1-y_i} $$\n对数似然函数 $\\ell(\\beta)$ 是 $L(\\beta)$ 的自然对数：\n$$ \\ell(\\beta) = \\ln(L(\\beta)) = \\sum_{i=1}^n \\ln(\\mu_i^{y_i} (1-\\mu_i)^{1-y_i}) = \\sum_{i=1}^n \\left[ y_i \\ln(\\mu_i) + (1-y_i)\\ln(1-\\mu_i) \\right] $$\n使用 $\\ln(\\mu_i) = \\ln(\\exp(\\eta_i)) - \\ln(1+\\exp(\\eta_i)) = \\eta_i - \\ln(1+\\exp(\\eta_i))$ 和 $\\ln(1-\\mu_i) = -\\ln(1+\\exp(\\eta_i))$，我们将这些代入 $\\ell(\\beta)$ 的表达式中：\n$$ \\ell(\\beta) = \\sum_{i=1}^n \\left[ y_i (\\eta_i - \\ln(1+\\exp(\\eta_i))) + (1-y_i)(-\\ln(1+\\exp(\\eta_i))) \\right] $$\n$$ \\ell(\\beta) = \\sum_{i=1}^n \\left[ y_i \\eta_i - y_i \\ln(1+\\exp(\\eta_i)) - \\ln(1+\\exp(\\eta_i)) + y_i \\ln(1+\\exp(\\eta_i)) \\right] $$\n$$ \\ell(\\beta) = \\sum_{i=1}^n \\left[ y_i \\eta_i - \\ln(1+\\exp(\\eta_i)) \\right] $$\n代入 $\\eta_i = \\beta_0 + \\beta_1 x_i$：\n$$ \\ell(\\beta) = \\sum_{i=1}^{n} \\left[ y_{i}(\\beta_{0} + \\beta_{1}x_{i}) - \\ln(1 + \\exp(\\beta_{0} + \\beta_{1}x_{i})) \\right] $$\n\n**2. 梯度（得分）向量 $\\nabla \\ell(\\beta)$**\n\n梯度向量包含 $\\ell(\\beta)$ 关于 $\\beta_0$ 和 $\\beta_1$ 的偏导数。我们来计算关于一个通用参数 $\\beta_j$ 的偏导数，其中 $j \\in \\{0, 1\\}$。\n使用链式法则，$\\frac{\\partial \\ell}{\\partial \\beta_j} = \\sum_{i=1}^n \\frac{\\partial \\ell_i}{\\partial \\eta_i} \\frac{\\partial \\eta_i}{\\partial \\beta_j}$，其中 $\\ell_i$ 是对数似然和中的第 $i$ 项。\n$$ \\frac{\\partial \\ell_i}{\\partial \\eta_i} = \\frac{\\partial}{\\partial \\eta_i} \\left[ y_i \\eta_i - \\ln(1+\\exp(\\eta_i)) \\right] = y_i - \\frac{\\exp(\\eta_i)}{1+\\exp(\\eta_i)} = y_i - \\mu_i $$\n线性预测变量的导数为 $\\frac{\\partial \\eta_i}{\\partial \\beta_0} = 1$ 和 $\\frac{\\partial \\eta_i}{\\partial \\beta_1} = x_i$。\n\n对于 $\\beta_0$：\n$$ \\frac{\\partial \\ell}{\\partial \\beta_0} = \\sum_{i=1}^n (y_i - \\mu_i) \\frac{\\partial \\eta_i}{\\partial \\beta_0} = \\sum_{i=1}^n (y_i - \\mu_i) \\cdot 1 = \\sum_{i=1}^{n} \\left( y_{i} - \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{1+\\exp(\\beta_{0}+\\beta_{1}x_{i})} \\right) $$\n对于 $\\beta_1$：\n$$ \\frac{\\partial \\ell}{\\partial \\beta_1} = \\sum_{i=1}^n (y_i - \\mu_i) \\frac{\\partial \\eta_i}{\\partial \\beta_1} = \\sum_{i=1}^n (y_i - \\mu_i) x_i = \\sum_{i=1}^{n} x_{i} \\left( y_{i} - \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{1+\\exp(\\beta_{0}+\\beta_{1}x_{i})} \\right) $$\n梯度向量为：\n$$ \\nabla \\ell(\\beta) = \\begin{pmatrix} \\frac{\\partial \\ell}{\\partial \\beta_0} \\\\ \\frac{\\partial \\ell}{\\partial \\beta_1} \\end{pmatrix} = \\begin{pmatrix} \\sum_{i=1}^{n} \\left( y_{i} - \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{1+\\exp(\\beta_{0}+\\beta_{1}x_{i})} \\right) \\\\ \\sum_{i=1}^{n} x_{i} \\left( y_{i} - \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{1+\\exp(\\beta_{0}+\\beta_{1}x_{i})} \\right) \\end{pmatrix} $$\n\n**3. 海森矩阵 $\\nabla^2 \\ell(\\beta)$**\n\n海森矩阵由二阶偏导数组成。我们计算 $\\frac{\\partial^2 \\ell}{\\partial \\beta_j \\partial \\beta_k}$，其中 $j,k \\in \\{0, 1\\}$。\n$$ \\frac{\\partial^2 \\ell}{\\partial \\beta_j \\partial \\beta_k} = \\frac{\\partial}{\\partial \\beta_k} \\left( \\frac{\\partial \\ell}{\\partial \\beta_j} \\right) = \\frac{\\partial}{\\partial \\beta_k} \\sum_{i=1}^n (y_i - \\mu_i) \\frac{\\partial \\eta_i}{\\partial \\beta_j} = \\sum_{i=1}^n \\left( -\\frac{\\partial \\mu_i}{\\partial \\beta_k} \\right) \\frac{\\partial \\eta_i}{\\partial \\beta_j} $$\n我们需要 $\\mu_i$ 关于 $\\beta_k$ 的导数：\n$$ \\frac{\\partial \\mu_i}{\\partial \\beta_k} = \\frac{\\partial \\mu_i}{\\partial \\eta_i} \\frac{\\partial \\eta_i}{\\partial \\beta_k} $$\n导数 $\\frac{\\partial \\mu_i}{\\partial \\eta_i}$ 是：\n$$ \\frac{\\partial \\mu_i}{\\partial \\eta_i} = \\frac{\\partial}{\\partial \\eta_i}\\left(\\frac{\\exp(\\eta_i)}{1+\\exp(\\eta_i)}\\right) = \\frac{\\exp(\\eta_i)(1+\\exp(\\eta_i)) - \\exp(\\eta_i)\\exp(\\eta_i)}{(1+\\exp(\\eta_i))^2} = \\frac{\\exp(\\eta_i)}{(1+\\exp(\\eta_i))^2} $$\n这可以写成 $\\mu_i (1-\\mu_i)$。因此，$\\frac{\\partial \\mu_i}{\\partial \\beta_k} = \\mu_i(1-\\mu_i) \\frac{\\partial \\eta_i}{\\partial \\beta_k}$。\n将此代入二阶导数表达式中：\n$$ \\frac{\\partial^2 \\ell}{\\partial \\beta_j \\partial \\beta_k} = - \\sum_{i=1}^n \\left(\\mu_i (1-\\mu_i) \\frac{\\partial \\eta_i}{\\partial \\beta_k}\\right) \\frac{\\partial \\eta_i}{\\partial \\beta_j} = - \\sum_{i=1}^n \\mu_i (1-\\mu_i) \\frac{\\partial \\eta_i}{\\partial \\beta_j} \\frac{\\partial \\eta_i}{\\partial \\beta_k} $$\n令 $x_{i0}=1$ 和 $x_{i1}=x_i$，则 $\\frac{\\partial \\eta_i}{\\partial \\beta_j} = x_{ij}$。\n$$ \\frac{\\partial^2 \\ell}{\\partial \\beta_j \\partial \\beta_k} = - \\sum_{i=1}^n x_{ij} x_{ik} \\mu_i(1-\\mu_i) $$\n其中 $\\mu_i(1-\\mu_i) = \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{(1+\\exp(\\beta_{0}+\\beta_{1}x_{i}))^{2}}$。\n\n海森矩阵的四个元素是：\n$$ \\frac{\\partial^2 \\ell}{\\partial \\beta_0^2} = - \\sum_{i=1}^n (1)^2 \\mu_i(1-\\mu_i) = -\\sum_{i=1}^{n} \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{(1+\\exp(\\beta_{0}+\\beta_{1}x_{i}))^{2}} $$\n$$ \\frac{\\partial^2 \\ell}{\\partial \\beta_0 \\partial \\beta_1} = \\frac{\\partial^2 \\ell}{\\partial \\beta_1 \\partial \\beta_0} = - \\sum_{i=1}^n (1)(x_i) \\mu_i(1-\\mu_i) = -\\sum_{i=1}^{n} x_{i} \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{(1+\\exp(\\beta_{0}+\\beta_{1}x_{i}))^{2}} $$\n$$ \\frac{\\partial^2 \\ell}{\\partial \\beta_1^2} = - \\sum_{i=1}^n (x_i)^2 \\mu_i(1-\\mu_i) = -\\sum_{i=1}^{n} x_{i}^{2} \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{(1+\\exp(\\beta_{0}+\\beta_{1}x_{i}))^{2}} $$\n因此，海森矩阵为：\n$$ \\nabla^2 \\ell(\\beta) = \\begin{pmatrix} -\\sum_{i=1}^{n} \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{(1+\\exp(\\beta_{0}+\\beta_{1}x_{i}))^{2}}  -\\sum_{i=1}^{n} x_{i} \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{(1+\\exp(\\beta_{0}+\\beta_{1}x_{i}))^{2}} \\\\ -\\sum_{i=1}^{n} x_{i} \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{(1+\\exp(\\beta_{0}+\\beta_{1}x_{i}))^{2}}  -\\sum_{i=1}^{n} x_{i}^{2} \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{(1+\\exp(\\beta_{0}+\\beta_{1}x_{i}))^{2}} \\end{pmatrix} $$",
            "answer": "$$\n\\boxed{\n\\begin{gathered}\n\\ell(\\beta) = \\sum_{i=1}^{n} \\left[ y_{i}(\\beta_{0} + \\beta_{1}x_{i}) - \\ln(1 + \\exp(\\beta_{0} + \\beta_{1}x_{i})) \\right] \\\\\n\\nabla \\ell(\\beta) = \\begin{pmatrix} \\sum_{i=1}^{n} \\left( y_{i} - \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{1+\\exp(\\beta_{0}+\\beta_{1}x_{i})} \\right) \\\\ \\sum_{i=1}^{n} x_{i} \\left( y_{i} - \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{1+\\exp(\\beta_{0}+\\beta_{1}x_{i})} \\right) \\end{pmatrix} \\\\\n\\nabla^2 \\ell(\\beta) = \\begin{pmatrix} -\\sum_{i=1}^{n} \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{(1+\\exp(\\beta_{0}+\\beta_{1}x_{i}))^{2}}  -\\sum_{i=1}^{n} x_{i} \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{(1+\\exp(\\beta_{0}+\\beta_{1}x_{i}))^{2}} \\\\ -\\sum_{i=1}^{n} x_{i} \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{(1+\\exp(\\beta_{0}+\\beta_{1}x_{i}))^{2}}  -\\sum_{i=1}^{n} x_{i}^{2} \\frac{\\exp(\\beta_{0}+\\beta_{1}x_{i})}{(1+\\exp(\\beta_{0}+\\beta_{1}x_{i}))^{2}} \\end{pmatrix}\n\\end{gathered}\n}\n$$"
        },
        {
            "introduction": "在推导出模型估计的理论基础后，下一步是将其应用于实际场景并解释其结果。本练习将理论付诸实践，让您使用一个已拟合的泊松回归模型来分析一个生物统计学队列研究中的数据 。您将根据给定的协变量和系数值，计算不同站点的拟合发生率 $\\hat{\\lambda}_i$ 和预期事件数 $\\hat{\\mu}_i$，并在此过程中深入理解“偏移量”（offset）在建率模（rate model）中的关键作用。这项练习能够有效提升您解释和运用GLM分析结果的实际能力。",
            "id": "4914209",
            "problem": "生物统计学中的一项队列研究测量了三个地点的某种病症的发病计数，其暴露量以人年为单位记录。该计数使用泊松广义线性模型（GLM）进行建模，其中地点 $i$ 的响应是一个计数 $Y_i$，假定其服从均值为 $E(Y_i)=\\mu_i$ 的泊松分布。该模型使用自然对数连接函数，并通过偏移量纳入暴露量，使得线性预测子是协变量和暴露量的加性形式。\n\n协变量向量为 $x_i=\\begin{pmatrix}1  a_i  z_i\\end{pmatrix}^{\\top}$，其中 $a_i$ 是以50岁为基线的年龄偏差（以十年为单位），$z_i$ 是一个表示是否接受治疗的二元指示变量。假设GLM已被拟合，得到的估计系数向量为 $\\hat{\\beta}=\\begin{pmatrix}-3.2  0.4  0.6\\end{pmatrix}^{\\top}$。对于三个地点，观测到的协变量和暴露量如下：\n- 地点 1：$x_1=\\begin{pmatrix}1  1.0  0\\end{pmatrix}^{\\top}$，暴露量 $t_1=180$ 人年。\n- 地点 2：$x_2=\\begin{pmatrix}1  -0.5  1\\end{pmatrix}^{\\top}$，暴露量 $t_2=320$ 人年。\n- 地点 3：$x_3=\\begin{pmatrix}1  2.0  1\\end{pmatrix}^{\\top}$，暴露量 $t_3=140$ 人年。\n\n从泊松分布和带有对数连接及暴露偏移量的GLM框架的核心定义出发，推导拟合发病率 $\\hat{\\lambda}_i$ 和期望计数 $\\hat{\\mu}_i$ 关于 $x_i$、$t_i$ 和 $\\hat{\\beta}$ 的表达式。然后，使用上述数值计算 $i=1,2,3$ 时 $\\hat{\\lambda}_i$ 和 $\\hat{\\mu}_i$ 的数值，并验证率和计数的单位是一致的。将所有数值结果保留四位有效数字。将你的最终答案表示为一个单行矩阵，按顺序包含 $\\hat{\\lambda}_1$、$\\hat{\\lambda}_2$、$\\hat{\\lambda}_3$、$\\hat{\\mu}_1$、$\\hat{\\mu}_2$、$\\hat{\\mu}_3$。最终矩阵中不应出现单位。",
            "solution": "该问题是有效的，因为它基于标准的生物统计建模，具有科学依据，问题陈述清晰且包含了所有必要信息，并且是客观陈述的。我们可以开始求解。\n\n该问题描述了一个用于处理地点 $i$（其中 $i \\in \\{1, 2, 3\\}$）的计数数据 $Y_i$ 的泊松广义线性模型（GLM）。GLM的核心组成部分如下：\n1. **随机部分**指定了响应变量的概率分布。此处，计数 $Y_i$ 假定服从均值为 $\\mu_i$ 的泊松分布：\n$$Y_i \\sim \\text{Poisson}(\\mu_i)$$\n其期望值为 $E[Y_i] = \\mu_i$。\n\n2. **系统部分**是线性预测子 $\\eta_i$，它是协变量 $x_i$ 和系数 $\\beta$ 的线性组合：\n$$\\eta_i = x_i^{\\top}\\beta$$\n\n3. **连接函数** $g$ 将响应的期望值 $\\mu_i$ 与线性预测子 $\\eta_i$ 联系起来。题目说明使用自然对数连接函数，$g(\\cdot) = \\ln(\\cdot)$。此外，模型将暴露量 $t_i$（以人年为单位）作为偏移量纳入。在泊松GLM中，这通过对率 $\\lambda_i = \\mu_i / t_i$ 建模来正式表达。连接函数应用于均值，因此模型方程为：\n$$g(\\mu_i) = \\eta_i + \\text{offset}_i$$\n使用对数连接和对数暴露偏移量，该方程变为：\n$$\\ln(\\mu_i) = x_i^{\\top}\\beta + \\ln(t_i)$$\n这种结构等价于直接对发病率 $\\lambda_i$ 的对数进行建模。为证明这一点，我们代入 $\\mu_i = \\lambda_i t_i$：\n$$\\ln(\\lambda_i t_i) = x_i^{\\top}\\beta + \\ln(t_i)$$\n根据对数的性质 $\\ln(a b) = \\ln(a) + \\ln(b)$，我们得到：\n$$\\ln(\\lambda_i) + \\ln(t_i) = x_i^{\\top}\\beta + \\ln(t_i)$$\n$$\\ln(\\lambda_i) = x_i^{\\top}\\beta$$\n这证实了该模型是针对对数发病率的。\n\n题目给出了估计的系数向量 $\\hat{\\beta}$。我们用它来求拟合值。地点 $i$ 的拟合线性预测子是 $\\hat{\\eta}_i = x_i^{\\top}\\hat{\\beta}$。\n\n拟合发病率 $\\hat{\\lambda}_i$ 的表达式通过对对数率的拟合模型取指数得到：\n$$\\ln(\\hat{\\lambda}_i) = x_i^{\\top}\\hat{\\beta}$$\n$$\\hat{\\lambda}_i = \\exp(x_i^{\\top}\\hat{\\beta})$$\n$\\hat{\\lambda}_i$ 的单位是 事件/人年，由暴露量 $t_i$ 的单位决定。\n\n拟合期望计数 $\\hat{\\mu}_i$ 的表达式由关系式 $\\hat{\\mu}_i = \\hat{\\lambda}_i t_i$ 导出：\n$$\\hat{\\mu}_i = t_i \\hat{\\lambda}_i = t_i \\exp(x_i^{\\top}\\hat{\\beta})$$\n单位是一致的：$\\hat{\\mu}_i$（一个无量纲的计数）是 $t_i$（人年）和 $\\hat{\\lambda}_i$（事件/人年）的乘积。\n\n给定的数据是：\n- 估计的系数向量：$\\hat{\\beta}=\\begin{pmatrix}-3.2  0.4  0.6\\end{pmatrix}^{\\top}$。\n- 地点 1：$x_1=\\begin{pmatrix}1  1.0  0\\end{pmatrix}^{\\top}$，$t_1=180$ 人年。\n- 地点 2：$x_2=\\begin{pmatrix}1  -0.5  1\\end{pmatrix}^{\\top}$，$t_2=320$ 人年。\n- 地点 3：$x_3=\\begin{pmatrix}1  2.0  1\\end{pmatrix}^{\\top}$，$t_3=140$ 人年。\n\n现在我们为每个地点计算数值。\n\n**对于地点 1:**\n线性预测子是：\n$$\\hat{\\eta}_1 = x_1^{\\top}\\hat{\\beta} = (1)(-3.2) + (1.0)(0.4) + (0)(0.6) = -3.2 + 0.4 = -2.8$$\n拟合的发病率是：\n$$\\hat{\\lambda}_1 = \\exp(-2.8) \\approx 0.06081006$$\n保留四位有效数字，$\\hat{\\lambda}_1 = 0.06081$。\n拟合的期望计数是：\n$$\\hat{\\mu}_1 = t_1 \\hat{\\lambda}_1 = 180 \\times \\exp(-2.8) \\approx 10.94581$$\n保留四位有效数字，$\\hat{\\mu}_1 = 10.95$。\n\n**对于地点 2:**\n线性预测子是：\n$$\\hat{\\eta}_2 = x_2^{\\top}\\hat{\\beta} = (1)(-3.2) + (-0.5)(0.4) + (1)(0.6) = -3.2 - 0.2 + 0.6 = -2.8$$\n拟合的发病率是：\n$$\\hat{\\lambda}_2 = \\exp(-2.8) \\approx 0.06081006$$\n保留四位有效数字，$\\hat{\\lambda}_2 = 0.06081$。\n拟合的期望计数是：\n$$\\hat{\\mu}_2 = t_2 \\hat{\\lambda}_2 = 320 \\times \\exp(-2.8) \\approx 19.45922$$\n保留四位有效数字，$\\hat{\\mu}_2 = 19.46$。\n\n**对于地点 3:**\n线性预测子是：\n$$\\hat{\\eta}_3 = x_3^{\\top}\\hat{\\beta} = (1)(-3.2) + (2.0)(0.4) + (1)(0.6) = -3.2 + 0.8 + 0.6 = -1.8$$\n拟合的发病率是：\n$$\\hat{\\lambda}_3 = \\exp(-1.8) \\approx 0.16529888$$\n保留四位有效数字，$\\hat{\\lambda}_3 = 0.1653$。\n拟合的期望计数是：\n$$\\hat{\\mu}_3 = t_3 \\hat{\\lambda}_3 = 140 \\times \\exp(-1.8) \\approx 23.14184$$\n保留四位有效数字，$\\hat{\\mu}_3 = 23.14$。\n\n最终结果，保留四位有效数字，如下：\n$\\hat{\\lambda}_1 = 0.06081$\n$\\hat{\\lambda}_2 = 0.06081$\n$\\hat{\\lambda}_3 = 0.1653$\n$\\hat{\\mu}_1 = 10.95$\n$\\hat{\\mu}_2 = 19.46$\n$\\hat{\\mu}_3 = 23.14$\n\n按要求将这些结果合并为一个单行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.06081  0.06081  0.1653  10.95  19.46  23.14\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "统计推断的目标不仅是获得一个点估计，更关键的是量化其不确定性。这项高级练习旨在让您通过理论推导和计算模拟，批判性地评估和比较两种构建置信区间方法的性能：基于大样本正态近似的Wald区间，以及更为稳健的基于得分检验的Score区间（Wilson区间）。通过亲手编程计算和比较它们在小样本或极端概率情况下的真实覆盖概率和区间长度，您将深刻体会到渐近理论的局限性，并理解为何在实践中选择合适的推断方法至关重要。",
            "id": "4914180",
            "problem": "考虑一个仅含截距项的二项广义线性模型，使用典则逻辑斯蒂连接。设 $Y \\sim \\operatorname{Binomial}(n,p)$ 是 $n$ 次独立伯努利试验中的成功次数，成功概率为 $p \\in (0,1)$。在具有逻辑斯蒂连接的广义线性模型框架中，典则参数为 $\\theta = \\log\\left(\\frac{p}{1-p}\\right)$，其反连接函数为 $p = \\frac{e^\\theta}{1+e^\\theta}$。在概率尺度上，最大似然估计为 $\\hat{p} = \\frac{Y}{n}$。\n\n根据基于似然的估计和渐近理论，瓦尔德（Wald）置信区间是通过应用最大似然估计的近似正态性得出的：对于大的 $n$，$\\hat{p}$ 近似服从均值为 $p$、方差为 $p(1-p)/n$ 的正态分布，或者等价地，典则参数估计 $\\hat{\\theta}$ 近似服从方差为费雪信息（Fisher information）逆的正态分布。在小样本和 $p$ 接近 $0$ 或 $1$ 的极端概率情况下，已知瓦尔德区间的覆盖率较差，并且可能退化或超出参数空间。另一种方法是通过反演得分检验来构造基于得分的区间，从而在概率尺度上得到威尔逊（Wilson）区间。\n\n严格从二项模型和广义线性模型的定义出发，不使用任何预先推导的置信区间公式，推导以下内容：\n\n1. 使用最大似然估计的渐近分布和费雪信息，从基本原理出发，推导 $p$ 在置信水平为 $1-\\alpha$ 时的瓦尔德区间。明确说明所需的假设以及从费雪信息到 $p$ 的区间的推导路径。\n\n2. 通过反演得分检验，推导 $p$ 在置信水平为 $1-\\alpha$ 时的基于得分的区间。即，定义二项模型在逻辑斯蒂连接下的得分函数，为作为候选参数的零值 $p$ 构建标准化得分检验，并证明反演接受域会产生一个关于 $p$ 的二次不等式。解此不等式，以 $\\hat{p}$、$n$ 和标准正态分位数 $z_{1-\\alpha/2}$ 表示威尔逊区间的端点。\n\n完成这些推导后，实现一个程序，对于每个测试用例 $(n,p,\\alpha)$，计算以下五个在概率尺度上的量：\n\n- 在名义水平 $1-\\alpha$ 下，瓦尔德区间的精确覆盖概率，定义为 $\\sum_{y=0}^{n} \\mathbf{1}\\{p \\in [L_{\\text{Wald}}(y),U_{\\text{Wald}}(y)]\\} \\cdot \\Pr(Y=y)$，其中 $L_{\\text{Wald}}(y)$ 和 $U_{\\text{Wald}}(y)$ 是根据 $\\hat{p}=y/n$ 计算的瓦尔德区间端点，$\\Pr(Y=y)$ 是具有真实 $p$ 值的二项概率质量函数。\n- 在相同水平下，基于得分的（威尔逊）区间的精确覆盖概率，其定义与瓦尔德区间类似，其中 $L_{\\text{Score}}(y)$ 和 $U_{\\text{Score}}(y)$ 是根据 $\\hat{p}=y/n$ 计算的威尔逊区间端点。\n- 瓦尔德区间的期望区间长度，计算为 $\\sum_{y=0}^{n} \\left(U_{\\text{Wald}}(y)-L_{\\text{Wald}}(y)\\right)\\Pr(Y=y)$。\n- 基于得分的区间的期望区间长度，计算为 $\\sum_{y=0}^{n} \\left(U_{\\text{Score}}(y)-L_{\\text{Score}}(y)\\right)\\Pr(Y=y)$。\n- 由 $\\hat{p} \\in \\{0,1\\}$ 导致的退化瓦尔德区间（长度为零）的概率，计算为 $\\Pr(Y=0)+\\Pr(Y=n)$。\n\n为了数值稳定性和科学现实性，计算后将所有区间端点截断到参数空间 $[0,1]$ 内。所有覆盖概率和期望长度均表示为小数。不允许使用百分号。\n\n您的程序必须为以下每个测试用例计算这五个量，这些测试用例旨在探究典型性能、小样本行为和极端概率下的边缘情况：\n\n- 测试用例 1：$(n,p,\\alpha) = (10, 0.5, 0.05)$。\n- 测试用例 2：$(n,p,\\alpha) = (10, 0.05, 0.05)$。\n- 测试用例 3：$(n,p,\\alpha) = (5, 0.1, 0.05)$。\n- 测试用例 4：$(n,p,\\alpha) = (20, 0.95, 0.05)$。\n- 测试用例 5：$(n,p,\\alpha) = (50, 0.5, 0.10)$。\n\n最终输出格式：您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是一个方括号括起来的逗号分隔列表，顺序为 $[$覆盖率$_{\\text{Wald}}$，覆盖率$_{\\text{Score}}$，平均长度$_{\\text{Wald}}$，平均长度$_{\\text{Score}}$，退化瓦尔德区间比例$]$。例如：$[[a_1,b_1,c_1,d_1,e_1],[a_2,b_2,c_2,d_2,e_2],\\dots]$。在输出前，将报告的每个小数四舍五入到 $4$ 位。",
            "solution": "我们从具有典则逻辑斯蒂连接的二项广义线性模型开始。设 $Y \\sim \\operatorname{Binomial}(n,p)$，其概率质量函数为 $\\Pr(Y=y) = \\binom{n}{y} p^y (1-p)^{n-y}$，其中 $y \\in \\{0,1,\\dots,n\\}$。在广义线性模型框架中，典则（自然）参数是 $\\theta = \\log\\left(\\frac{p}{1-p}\\right)$，其反连接函数可恢复 $p = \\frac{e^\\theta}{1+e^\\theta}$。\n\n对于典则参数，对数似然函数（除去一个加性常数）为\n$$\n\\ell(\\theta; y) = y \\theta - n \\log\\left(1 + e^\\theta\\right).\n$$\n得分函数是对数似然函数关于 $\\theta$ 的导数，\n$$\nU(\\theta) = \\frac{\\partial \\ell(\\theta;y)}{\\partial \\theta} = y - n \\frac{e^\\theta}{1 + e^\\theta} = y - n p(\\theta),\n$$\n其中 $p(\\theta) = \\frac{e^\\theta}{1 + e^\\theta}$。$\\theta$ 的费雪信息为\n$$\nI(\\theta) = -\\mathbb{E}\\left[\\frac{\\partial^2 \\ell(\\theta;Y)}{\\partial \\theta^2}\\right] = n \\frac{e^\\theta}{\\left(1 + e^\\theta\\right)^2} = n p(\\theta)\\left(1 - p(\\theta)\\right).\n$$\n\n瓦尔德（Wald）区间的推导。在概率尺度上，最大似然估计为 $\\hat{p} = y/n$，通过德尔塔（delta）方法或直接计算可知，对于大的 $n$，$\\hat{p}$ 近似服从正态分布：\n$$\n\\hat{p} \\approx \\mathcal{N}\\left(p, \\frac{p(1-p)}{n}\\right).\n$$\n用其插件估计 $\\hat{p}(1-\\hat{p})/n$ 替换未知方差，得到概率尺度上的瓦尔德置信区间\n$$\n\\left[\\,\\hat{p} - z_{1-\\alpha/2}\\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}}\\,,\\, \\hat{p} + z_{1-\\alpha/2}\\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}}\\,\\right],\n$$\n其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$ 分位数。此近似依赖于 $\\hat{p}$ 的大样本正态性以及在标准误中用 $\\hat{p}$ 替换 $p$ 的有效性。对于小的 $n$ 或极端的 $p$，这可能不准确；当 $\\hat{p} \\in \\{0,1\\}$ 时，该区间也可能延伸到 $[0,1]$ 之外或发生退化。\n\n通过反演得分检验推导基于得分的区间。对于一个候选参数值 $p$ 的得分检验，评估标准化的得分统计量\n$$\nZ(p) = \\frac{U(\\theta(p))}{\\sqrt{I(\\theta(p))}} = \\frac{y - n p}{\\sqrt{n p(1-p)}}.\n$$\n在候选 $p$ 的零假设下，对于中等样本量，$Z(p)$ 近似服从标准正态分布。双侧置信水平为 $1-\\alpha$ 的检验的接受域是\n$$\n\\left|\\,\\frac{y - n p}{\\sqrt{n p(1-p)}}\\,\\right| \\le z_{1-\\alpha/2}.\n$$\n为了获得置信区间，我们反演此检验：对于固定的数据 $y$，我们找到所有满足该不等式的 $p \\in [0,1]$。两边平方得到\n$$\n\\frac{(y - n p)^2}{n p(1-p)} \\le z_{1-\\alpha/2}^2.\n$$\n两边乘以 $n p(1-p)$ 并重新整理，得到一个关于 $p$ 的二次不等式：\n$$\n(y - n p)^2 \\le z_{1-\\alpha/2}^2 \\, n \\, p(1-p).\n$$\n设 $\\hat{p} = y/n$ 和 $z = z_{1-\\alpha/2}$。两边除以 $n$ 得到\n$$\nn (p - \\hat{p})^2 \\le z^2 p(1-p).\n$$\n展开并整理，我们有\n$$\nn(p^2 - 2 p \\hat{p} + \\hat{p}^2) \\le z^2(p - p^2),\n$$\n这可以写成\n$$\n(n + z^2) p^2 - 2 n \\hat{p} \\, p + n \\hat{p}^2 - z^2 p \\le 0,\n$$\n或者等价地\n$$\n(n + z^2) p^2 - 2 n \\hat{p} \\, p - z^2 p + n \\hat{p}^2 \\le 0.\n$$\n对 $p$ 的项进行分组，得到二次不等式\n$$\n(n + z^2) p^2 - \\left(2 n \\hat{p} + z^2\\right) p + n \\hat{p}^2 \\le 0.\n$$\n解相应的二次等式以求 $p$，即可得到区间的端点。使用二次公式，其根为\n$$\np = \\frac{2 n \\hat{p} + z^2 \\pm z \\sqrt{4 n \\hat{p}(1-\\hat{p}) + z^2}}{2(n + z^2)}.\n$$\n对分子和分母进行适当的除法运算，可简化为威尔逊（Wilson）区间的形式。一种常见的等价形式将其中心和半径表示为\n$$\n\\text{中心} = \\frac{\\hat{p} + \\frac{z^2}{2n}}{1 + \\frac{z^2}{n}}, \\quad\n\\text{半径} = \\frac{z}{1 + \\frac{z^2}{n}} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n} + \\frac{z^2}{4 n^2}},\n$$\n因此，基于得分的（威尔逊）区间为\n$$\n\\left[\\,\\max\\left\\{0,\\, \\text{中心} - \\text{半径}\\right\\},\\, \\min\\left\\{1,\\, \\text{中心} + \\text{半径}\\right\\}\\,\\right].\n$$\n截断到 $[0,1]$ 强制了参数空间，对于概率参数而言是自然的；在大多数情况下，威尔逊区间的端点已经位于 $[0,1]$ 之内。\n\n精确覆盖率和期望长度的计算。对于固定的 $(n,p,\\alpha)$，定义二项概率质量函数权重 $w_y = \\Pr(Y=y) = \\binom{n}{y} p^y (1-p)^{n-y}$，其中 $y=0,1,\\dots,n$。对于每个 $y$，计算 $\\hat{p}=y/n$，瓦尔德区间端点\n$$\nL_{\\text{Wald}}(y) = \\max\\left\\{0,\\, \\hat{p} - z \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}} \\right\\}, \\quad\nU_{\\text{Wald}}(y) = \\min\\left\\{1,\\, \\hat{p} + z \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}} \\right\\},\n$$\n以及如上所述的威尔逊区间端点。精确覆盖概率为\n$$\n\\text{覆盖率}_{\\text{Wald}} = \\sum_{y=0}^{n} \\mathbf{1}\\left\\{p \\in [L_{\\text{Wald}}(y),U_{\\text{Wald}}(y)]\\right\\} \\, w_y,\n$$\n$$\n\\text{覆盖率}_{\\text{Score}} = \\sum_{y=0}^{n} \\mathbf{1}\\left\\{p \\in [L_{\\text{Score}}(y),U_{\\text{Score}}(y)]\\right\\} \\, w_y.\n$$\n期望长度为\n$$\n\\mathbb{E}[\\text{长度}_{\\text{Wald}}] = \\sum_{y=0}^{n} \\left(U_{\\text{Wald}}(y) - L_{\\text{Wald}}(y)\\right) w_y, \\quad\n\\mathbb{E}[\\text{长度}_{\\text{Score}}] = \\sum_{y=0}^{n} \\left(U_{\\text{Score}}(y) - L_{\\text{Score}}(y)\\right) w_y.\n$$\n瓦尔德区间的退化概率为\n$$\n\\Pr(\\text{退化瓦尔德}) = \\Pr(Y=0) + \\Pr(Y=n) = (1-p)^n + p^n,\n$$\n因为当 $y=0$ 或 $y=n$ 时，插件标准误 $\\sqrt{\\hat{p}(1-\\hat{p})/n}$ 等于 $0$。\n\n算法设计。对于每个测试用例 $(n,p,\\alpha)$：\n- 从标准正态分布计算 $z = z_{1-\\alpha/2}$。\n- 对 $y$ 从 $0$ 到 $n$，计算 $\\hat{p} = y/n$，二项概率 $w_y$，截断到 $[0,1]$ 的瓦尔德区间端点，以及截断到 $[0,1]$ 的威尔逊区间端点。\n- 将由 $w_y$ 加权的覆盖指示符累加以获得精确覆盖概率，累加长度以获得期望长度，并计算退化概率为 $w_0 + w_n$。\n- 将每个结果四舍五入到 $4$ 位小数以进行输出格式化。\n\n测试套件和输出。该程序为五个指定的测试用例实现上述步骤：$(10, 0.5, 0.05)$、$(10, 0.05, 0.05)$、$(5, 0.1, 0.05)$、$(20, 0.95, 0.05)$、$(50, 0.5, 0.10)$。最终输出是单行文本，包含一个方括号括起来的列表，其中每个测试用例的结果以 $[$覆盖率$_{\\text{Wald}}$，覆盖率$_{\\text{Score}}$，平均长度$_{\\text{Wald}}$，平均长度$_{\\text{Score}}$，退化瓦尔德区间比例$]$ 的顺序列出，每个小数四舍五入到 $4$ 位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, binom\n\ndef wald_interval(n, y, alpha):\n    \"\"\"\n    Wald interval on the probability scale for Binomial(n, p), using p_hat = y/n.\n    Endpoints are truncated to [0,1].\n    \"\"\"\n    p_hat = y / n\n    z = norm.ppf(1 - alpha / 2.0)\n    se = np.sqrt(p_hat * (1 - p_hat) / n)\n    lower = p_hat - z * se\n    upper = p_hat + z * se\n    # truncate to [0,1]\n    lower = max(0.0, lower)\n    upper = min(1.0, upper)\n    return lower, upper\n\ndef wilson_interval(n, y, alpha):\n    \"\"\"\n    Score-based (Wilson) interval on the probability scale for Binomial(n, p),\n    using p_hat = y/n and z = z_{1 - alpha/2}.\n    Endpoints are truncated to [0,1].\n    \"\"\"\n    p_hat = y / n\n    z = norm.ppf(1 - alpha / 2.0)\n    denom = 1.0 + (z**2) / n\n    center = (p_hat + (z**2) / (2.0 * n)) / denom\n    rad_term = p_hat * (1 - p_hat) / n + (z**2) / (4.0 * n**2)\n    radius = z * np.sqrt(rad_term) / denom\n    lower = center - radius\n    upper = center + radius\n    # truncate to [0,1]\n    lower = max(0.0, lower)\n    upper = min(1.0, upper)\n    return lower, upper\n\ndef exact_metrics(n, p, alpha):\n    \"\"\"\n    Compute exact coverage and expected length metrics by summing over y=0..n.\n    Returns:\n    coverage_wald, coverage_wilson, mean_length_wald, mean_length_wilson, degenerate_wald_fraction\n    \"\"\"\n    coverage_wald = 0.0\n    coverage_wilson = 0.0\n    mean_len_wald = 0.0\n    mean_len_wilson = 0.0\n\n    # Degenerate Wald interval occurs when y=0 or y=n (p_hat in {0,1} -> SE=0)\n    degenerate = binom.pmf(0, n, p) + binom.pmf(n, n, p)\n\n    # Iterate over all possible counts\n    ys = np.arange(n + 1)\n    pmf = binom.pmf(ys, n, p)\n\n    for y, w in zip(ys, pmf):\n        lw, uw = wald_interval(n, y, alpha)\n        ls, us = wilson_interval(n, y, alpha)\n\n        mean_len_wald += (uw - lw) * w\n        mean_len_wilson += (us - ls) * w\n\n        if (p >= lw) and (p = uw):\n            coverage_wald += w\n        if (p >= ls) and (p = us):\n            coverage_wilson += w\n\n    return coverage_wald, coverage_wilson, mean_len_wald, mean_len_wilson, degenerate\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (n, p_true, alpha)\n    test_cases = [\n        (10, 0.5, 0.05),   # Typical moderate sample, central p\n        (10, 0.05, 0.05),  # Small n, rare event probability\n        (5, 0.1, 0.05),    # Very small n, rare event\n        (20, 0.95, 0.05),  # Moderate n, near-certain success\n        (50, 0.5, 0.10)    # Larger n, different alpha level\n    ]\n\n    results = []\n    for n, p_true, alpha in test_cases:\n        cw, cs, lw, ls, dw = exact_metrics(n, p_true, alpha)\n        # Round to 4 decimal places for output\n        res = [round(cw, 4), round(cs, 4), round(lw, 4), round(ls, 4), round(dw, 4)]\n        results.append(res)\n\n    # Build the exact required nested list format as a single line string.\n    def format_case(case_list):\n        return \"[\" + \",\".join(f\"{v:.4f}\" for v in case_list) + \"]\"\n\n    output = \"[\" + \",\".join(format_case(case) for case in results) + \"]\"\n    print(output)\n\nsolve()\n```"
        }
    ]
}