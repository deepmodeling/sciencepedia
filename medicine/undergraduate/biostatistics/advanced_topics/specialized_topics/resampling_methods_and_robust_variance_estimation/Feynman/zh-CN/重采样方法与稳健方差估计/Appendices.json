{
    "hands_on_practices": [
        {
            "introduction": "样本中位数是衡量数据中心趋势的稳健统计量，但其标准误的解析表达式通常很复杂。本练习将通过自助法（Bootstrap）这一强大的计算工具，以非参数的方式来估计样本中位数的标准误 。通过亲手实现该算法，你将掌握自助法的核心思想——即通过从原始样本中有放回地重复抽样来模拟真实的抽样分布，并由此估计统计量的不确定性。",
            "id": "4948755",
            "problem": "给定以毫米汞柱（mmHg）为单位测量的独立同分布（IID）的收缩压观测值。设样本表示为 $\\{X_1,\\dots,X_n\\}$，其中 $n=20$。样本中位数 $\\hat{m}$ 是一个稳健的中心位置估计量，它从样本的顺序统计量中获得。对于偶数 $n$，定义为两个中心顺序统计量的平均值。一位研究者希望通过自助法（bootstrap principle）来近似 $\\hat{m}$ 的抽样变异性，从而得到其稳健的方差估计。具体方法是：从观测数据的经验分布中进行有放回的重抽样，并在多个自助法重复样本中重新计算中位数。然后，使用中位数的经验自助法分布来估计 $\\hat{m}$ 的标准误（SE）。\n\n从以下核心定义出发：\n- 经验分布 $\\hat{F}_n$ 将 $1/n$ 的概率质量赋给 $\\{X_i\\}_{i=1}^n$ 中的每个观测值。\n- 根据 $\\hat{F}_n$，通过从 $\\{X_i\\}_{i=1}^n$ 中有放回地抽样，生成一个大小为 $n$ 的自助法重抽样样本。\n- 样本中位数的自助法标准误估计量是自助法中位数集合的经验标准差。\n\n编写一个程序，该程序：\n- 对每个提供的测试用例，使用从观测数据中有放回地抽取的 $B=1000$ 个大小为 $n=20$ 的独立同分布自助法重抽样样本，计算样本中位数的自助法标准误估计值。\n- 为了可复现性，使用一个固定的伪随机数生成器种子，其值为 $s=20231111$。\n- 以 mmHg 为单位，将 $B$ 个自助法中位数的经验标准差报告为浮点数。\n\n所有结果均以 mmHg 明确表示。最终输出应为浮点数，在程序中四舍五入到六位小数。\n\n测试套件（每个都是一个包含 $n=20$ 个收缩压值的列表，单位为 mmHg）：\n1. 一般变异性，典型成人值：\n   $\\{118,122,135,128,150,142,130,125,138,145,132,129,140,136,127,133,149,121,137,134\\}$\n2. 存在高值异常点：\n   $\\{110,115,120,125,130,135,140,145,150,155,160,165,170,175,180,185,190,195,200,240\\}$\n3. 多个相同值（重复测量）：\n   $\\{130,130,130,130,135,135,135,140,140,140,145,145,145,150,150,150,155,155,160,160\\}$\n4. 退化情况（所有值相等）：\n   $\\{130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130\\}$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”）。每个“result”是对应测试用例的自助法标准误（mmHg），格式化为六位小数。不涉及角度。不涉及百分比。",
            "solution": "经评估，该问题是有效的。它在科学上基于已建立的自助法重抽样统计理论，问题陈述清晰，并为获得唯一且可复现的解提供了所有必要参数，且以客观、正式的语言表述。因此，我们可以着手求解。\n\n该问题要求为四个不同的收缩压测量数据集计算样本中位数的标准误（SE）的自助法估计值。统计量的标准误是衡量该统计量抽样分布变异性的指标；它量化了样本统计量作为相应总体参数估计值的精确度。当抽样分布的理论形式未知或难以推导时，自助法是一种强大且广泛使用的计算方法，用于近似该分布。\n\n由 Efron 提出的自助法的基本原理是，使用观测样本本身作为对真实底层数据生成分布的近似。经验分布函数 $\\hat{F}_n$ 为样本 $\\{X_1, \\dots, X_n\\}$ 中的每个观测数据点 $X_i$ 分配 $1/n$ 的概率质量，并以此作为近似。\n\n步骤如下：\n$1$. 生成大量的（$B$ 个）自助法样本。每个自助法样本，记为 $\\{X_{b,1}^*, \\dots, X_{b,n}^*\\}$（其中 $b \\in \\{1, \\dots, B\\}$），是一个从原始数据 $\\{X_1, \\dots, X_n\\}$ 中*有放回地*抽取的、大小为 $n$ 的随机样本。从原始样本中有放回地抽样等价于从经验分布 $\\hat{F}_n$ 中抽取一个独立同分布样本。对于本问题，样本大小为 $n=20$，自助法重复次数为 $B=1000$。\n\n$2$. 对每个自助法样本，计算我们感兴趣的统计量——在本例中为样本中位数。设 $\\hat{m}_b^*$ 为第 $b$ 个自助法样本的中位数。对于大小为偶数 $n$ 的样本，样本中位数定义为两个中心顺序统计量的算术平均值，即排序后样本中位置为 $n/2$ 和 $(n/2)+1$ 的值的平均值。对于 $n=20$，即第 10 个和第 11 个排序后值的平均值。\n\n$3$. 这 $B$ 个自助法中位数的集合 $\\{\\hat{m}_1^*, \\hat{m}_2^*, \\dots, \\hat{m}_B^*\\}$，构成了样本中位数 $\\hat{m}$ 抽样分布的一个经验近似。\n\n$4$. 样本中位数的自助法标准误估计值 $\\text{SE}_{\\text{boot}}(\\hat{m})$，则计算为这组自助法中位数的样本标准差：\n$$ \\text{SE}_{\\text{boot}}(\\hat{m}) = \\sqrt{ \\frac{1}{B-1} \\sum_{b=1}^{B} (\\hat{m}_b^* - \\bar{m}^*)^2 } $$\n其中 $\\bar{m}^* = \\frac{1}{B} \\sum_{b=1}^{B} \\hat{m}_b^*$ 是 $B$ 个自助法中位数的均值。使用 $B-1$ 作为分母（贝塞尔校正）是从样本估计总体标准差的标准做法，这与我们当前从自助法生成的中位数样本来估计抽样分布标准差的任务是类似的。\n\n为确保可复现性，整个过程使用一个以固定种子 $s=20231111$ 初始化的伪随机数生成器来执行。这保证了每次执行时自助法样本的序列都是相同的，从而得到一个确定性的最终结果。\n\n对每个测试用例，要实现的算法如下：\na. 使用指定的种子 $s=20231111$ 初始化一个伪随机数生成器。为了确保所有测试用例共享一个连续的随机数流，整个脚本只执行一次初始化。\nb. 对于一个大小为 $n=20$ 的给定数据样本，创建一个数组来存储 $B=1000$ 个自助法中位数的值。\nc. 循环 $B$ 次：\n    i. 通过从原始样本中有放回地选择元素，生成一个大小为 $n=20$ 的自助法重抽样样本。\n    ii. 计算该重抽样样本的中位数。\n    iii. 存储计算出的中位数。\nd. 循环结束后，使用上述公式（即分母为 $B-1$）计算存储的 $B$ 个中位数的样本标准差。\ne. 将得到的标准误四舍五入到 6 位小数。\nf. 对所有四个测试用例重复以上步骤，并按规定格式化结果。\n整个过程在提供的 Python 代码中实现，利用 `numpy` 库进行高效的数组操作、随机抽样和统计计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the bootstrap estimate of the standard error of the sample median\n    for four given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. General variability, typical adult values\n        [118, 122, 135, 128, 150, 142, 130, 125, 138, 145, 132, 129, 140, 136, 127, 133, 149, 121, 137, 134],\n        # 2. Presence of a high outlier\n        [110, 115, 120, 125, 130, 135, 140, 145, 150, 155, 160, 165, 170, 175, 180, 185, 190, 195, 200, 240],\n        # 3. Multiple ties (repeated measurements)\n        [130, 130, 130, 130, 135, 135, 135, 140, 140, 140, 145, 145, 145, 150, 150, 150, 155, 155, 160, 160],\n        # 4. Degenerate case (all equal)\n        [130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130]\n    ]\n\n    # Parameters from the problem statement\n    n = 20  # Sample size\n    B = 1000 # Number of bootstrap replicates\n    seed = 20231111 # RNG seed\n\n    # Initialize the pseudorandom number generator once for reproducibility\n    rng = np.random.default_rng(seed)\n\n    results = []\n    for data in test_cases:\n        # Convert data to a NumPy array for efficient computation\n        original_sample = np.array(data)\n        \n        # Array to store the median from each bootstrap replicate\n        bootstrap_medians = np.empty(B, dtype=np.float64)\n\n        # Main bootstrap loop\n        for i in range(B):\n            # Generate a bootstrap resample of size n by sampling with replacement\n            resample = rng.choice(original_sample, size=n, replace=True)\n            \n            # Compute and store the median of the resample\n            bootstrap_medians[i] = np.median(resample)\n\n        # Compute the bootstrap estimate of the standard error of the median.\n        # This is the empirical standard deviation of the distribution of bootstrap medians.\n        # ddof=1 is used for sample standard deviation (Bessel's correction).\n        se_median = np.std(bootstrap_medians, ddof=1)\n        \n        # Round the result to six decimal places\n        rounded_result = round(se_median, 6)\n        \n        results.append(rounded_result)\n\n    # Format the final list of results into the specified output string.\n    # The f-string format specifier ensures each float is printed with six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "估计标准误是量化不确定性的第一步，而构建置信区间则能提供对总体参数的更完整的区间估计。本练习将介绍如何使用自助法分布的经验分位数来构建百分位（percentile）置信区间 。我们将把这一方法应用于一个常见的生物统计学问题——估计感染率，并将其结果与经典的稳健标准误估计进行比较，从而加深对不同不确定性量化方法的理解。",
            "id": "4948632",
            "problem": "给定一个由 $n=50$ 个独立结果 $Y_i \\in \\{0,1\\}$（其中 $i=1,\\dots,n$）组成的二元感染状态数据集。目标参数是总体感染比例 $p \\in [0,1]$。所考虑的估计量是样本比例，定义为样本均值 $\\hat{p} = \\frac{1}{n}\\sum_{i=1}^{n} Y_i$。请使用非参数重抽样，通过百分位法构建 $\\hat{p}$ 的 bootstrap 置信区间，并通过稳健方差估计量来估计其变异性。\n\n从基本原理出发，假设在观测数据的经验分布下，结果是独立同分布的。Bootstrap 方法通过从观测到的二元结果中有放回地重复重抽样，并对每个重抽样样本重新计算 $\\hat{p}$，来近似 $\\hat{p}$ 的抽样分布。百分位法使用 $\\hat{p}$ 的 bootstrap 分布的经验分位数来形成置信区间。另外，可以通过关于 $\\hat{p}$ 的 $Y_i$ 的经验二阶矩，并以 $n$ 进行适当缩放，得到 $\\hat{p}$ 的一个稳健方差估计量，这反映了 Eicker-Huber-White 类型的样本均值方差估计风格。\n\n您的任务是，完全以数学和算法术语实现以下内容：\n\n1. 对于每个数据集，通过从观测到的 $Y_i$ 中有放回抽样，生成 $B=2000$ 个大小为 $n=50$ 的非参数 bootstrap 重抽样样本，对每个重抽样样本重新计算 $\\hat{p}$，并使用百分位法获得名义水平为 $1-\\alpha=0.95$（因此 $\\alpha=0.05$）的双侧置信区间。使用水平为 $\\alpha/2$ 和 $1-\\alpha/2$ 的经验分位数。\n2. 计算基于关于 $\\hat{p}$ 的经验二阶矩除以 $n$ 的稳健标准误，然后取平方根得到标准误。\n3. 计算 $\\hat{p}$ 的 bootstrap 标准误，即 $B$ 个 bootstrap 估计值的样本标准差。\n\n使用固定的伪随机种子 $\\text{seed}=2025$ 来确保 bootstrap 过程的可复现性。\n\n测试套件：\n考虑 $4$ 个感染数据集，每个数据集长度为 $n=50$：\n- 数据集 1：$25$ 个 1 和 $25$ 个 0。\n- 数据集 2：$5$ 个 1 和 $45$ 个 0。\n- 数据集 3：$0$ 个 1 和 $50$ 个 0。\n- 数据集 4：$50$ 个 1 和 $0$ 个 0。\n\n对于每个数据集，计算并返回一个包含 $5$ 个浮点数的列表，顺序如下：\n$[\\hat{p}, \\text{CI}_{\\text{lower}}, \\text{CI}_{\\text{upper}}, \\text{SE}_{\\text{robust}}, \\text{SE}_{\\text{bootstrap}}]$，\n其中 $\\hat{p}$ 是样本比例，$\\text{CI}_{\\text{lower}}$ 和 $\\text{CI}_{\\text{upper}}$ 是在水平 $\\alpha/2$ 和 $1-\\alpha/2$ 处的百分位 bootstrap 置信区间界限，$\\text{SE}_{\\text{robust}}$ 是从经验二阶矩除以 $n$ 推导出的稳健标准误，$\\text{SE}_{\\text{bootstrap}}$ 是计算为 $B$ 个 bootstrap 估计值的样本标准差的 bootstrap 标准误。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含 $4$ 个数据集的结果，形式为用方括号括起来的逗号分隔列表，每个数据集的结果本身是一个包含 $5$ 个浮点数的列表，每个浮点数四舍五入到六位小数。例如，输出必须是 $[\\,[r_{11},r_{12},r_{13},r_{14},r_{15}],\\,[r_{21},r_{22},r_{23},r_{24},r_{25}],\\,[r_{31},r_{32},r_{33},r_{34},r_{35}],\\,[r_{41},r_{42},r_{43},r_{44},r_{45}]\\,]$ 的形式，其中每个 $r_{jk}$ 都是一个表示为六位小数的浮点数。",
            "solution": "已对用户提供的问题进行分析，认定其有效。该问题在科学上是合理的、提法明确且客观的。所有必要的数据和定义均已提供，且无矛盾之处。该问题是基本生物统计学方法的标准应用。\n\n任务是使用非参数 bootstrap 和稳健方差估计技术来分析四个不同的二元结果数据集。对于每个数据集，我们必须计算五个量：样本比例（$\\hat{p}$）、一个 $95\\%$ 百分位 bootstrap 置信区间（$[\\text{CI}_{\\text{lower}}, \\text{CI}_{\\text{upper}}]$）、一个稳健标准误（$\\text{SE}_{\\text{robust}}$）和一个 bootstrap 标准误（$\\text{SE}_{\\text{bootstrap}}$）。\n\n设一个给定的数据集是 $n$ 个独立同分布的二元结果 $Y = \\{Y_1, Y_2, \\dots, Y_n\\}$ 的集合，其中 $Y_i \\in \\{0, 1\\}$。样本量给定为 $n=50$。\n\n**1. 样本比例（$\\hat{p}$）**\n总体比例 $p$ 的估计量是样本比例 $\\hat{p}$，即观测结果的算术平均值。\n$$\n\\hat{p} = \\frac{1}{n} \\sum_{i=1}^{n} Y_i\n$$\n\n**2. 非参数 Bootstrap 和百分位置信区间**\nBootstrap 方法用于近似估计量 $\\hat{p}$ 的抽样分布。\n过程如下：\na. 生成 $B=2000$ 个 bootstrap 样本。每个 bootstrap 样本，记为 $Y_j^* = \\{Y_{j,1}^*, \\dots, Y_{j,n}^*\\}$（其中 $j \\in \\{1, \\dots, B\\}$），是通过从原始数据集 $Y$ 中有放回地抽取 $n$ 个观测值来创建的。\nb. 对于每个 bootstrap 样本 $Y_j^*$，计算样本比例：\n$$\n\\hat{p}_j^* = \\frac{1}{n} \\sum_{i=1}^{n} Y_{j,i}^*\n$$\n这会产生一个包含 $B$ 个 bootstrap 估计值的集合 $\\{\\hat{p}_1^*, \\hat{p}_2^*, \\dots, \\hat{p}_B^*\\}$。\nc. 百分位置信区间由 bootstrap 分布的经验分位数构成。对于名义置信水平 $1-\\alpha = 0.95$，我们有 $\\alpha=0.05$。置信区间的下界和上界分别是排序后的 bootstrap 估计值的第 $100(\\alpha/2)$ 百分位数和第 $100(1-\\alpha/2)$ 百分位数。\n设 $\\hat{q}_{\\tau}$ 是集合 $\\{\\hat{p}_j^*\\}$ 的第 $\\tau$ 分位数。置信区间为：\n$$\n[\\text{CI}_{\\text{lower}}, \\text{CI}_{\\text{upper}}] = [\\hat{q}_{\\alpha/2}, \\hat{q}_{1-\\alpha/2}] = [\\hat{q}_{0.025}, \\hat{q}_{0.975}]\n$$\n所有 bootstrap 重抽样都将使用一个以固定种子 $\\text{seed}=2025$ 初始化的伪随机数生成器来执行，以保证可复现性。\n\n**3. 稳健标准误（$\\text{SE}_{\\text{robust}}$）**\n稳健标准误源自样本均值的 Eicker-Huber-White 方差估计量。$\\hat{p}$ 的方差估计如下：\n$$\n\\widehat{\\text{Var}}_{\\text{robust}}(\\hat{p}) = \\frac{1}{n^2} \\sum_{i=1}^{n} (Y_i - \\hat{p})^2\n$$\n该公式表示数据的样本方差（分母使用 $n$）除以 $n$。对于二元数据 $Y_i \\in \\{0, 1\\}$，平方偏差之和显著简化：\n$$\n\\sum_{i=1}^{n} (Y_i - \\hat{p})^2 = n\\hat{p}(1-\\hat{p})\n$$\n将此代入方差公式可得：\n$$\n\\widehat{\\text{Var}}_{\\text{robust}}(\\hat{p}) = \\frac{n\\hat{p}(1-\\hat{p})}{n^2} = \\frac{\\hat{p}(1-\\hat{p})}{n}\n$$\n稳健标准误是此方差的平方根：\n$$\n\\text{SE}_{\\text{robust}} = \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}}\n$$\n\n**4. Bootstrap 标准误（$\\text{SE}_{\\text{bootstrap}}$）**\nBootstrap 标准误是 $\\hat{p}$ 变异性的另一种度量。它通过 $B$ 个 bootstrap 估计值 $\\{\\hat{p}_1^*, \\dots, \\hat{p}_B^*\\}$ 的样本标准差来估计。\n$$\n\\text{SE}_{\\text{bootstrap}} = \\sqrt{\\frac{1}{B-1} \\sum_{j=1}^{B} (\\hat{p}_j^* - \\bar{p}^*)^2}\n$$\n其中 $\\bar{p}^* = \\frac{1}{B} \\sum_{j=1}^{B} \\hat{p}_j^*$ 是 bootstrap 估计值的均值。\n\n**5. 应用于测试数据集**\n上述过程将应用于四个指定的数据集中的每一个：\n- **数据集 1：** $n=50$，有 $25$ 个 1 和 $25$ 个 0。因此，$\\hat{p} = 25/50 = 0.5$。\n- **数据集 2：** $n=50$，有 $5$ 个 1 和 $45$ 个 0。因此，$\\hat{p} = 5/50 = 0.1$。\n- **数据集 3：** $n=50$，有 $0$ 个 1 和 $50$ 个 0。因此，$\\hat{p} = 0/50 = 0.0$。\n- **数据集 4：** $n=50$，有 $50$ 个 1 和 $0$ 个 0。因此，$\\hat{p} = 50/50 = 1.0$。\n\n对于数据集 3 和 4，原始数据缺乏变异性。因此，任何 bootstrap 重抽样样本都将与原始样本相同。这导致一个退化的 bootstrap 分布，其中所有 $\\hat{p}_j^*$ 都等于原始的 $\\hat{p}$。因此，百分位置信区间的宽度将为零（例如，对于数据集 3，为 $[0,0]$），并且 bootstrap 标准误将为 $0$。稳健标准误也将为 $0$，因为当 $\\hat{p}=0$ 或 $\\hat{p}=1$ 时，$\\hat{p}(1-\\hat{p})=0$。算法实现将自然地处理这些情况。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes statistical measures for binary infection datasets using\n    nonparametric bootstrap and robust variance estimation.\n    \"\"\"\n\n    def analyze_dataset(y_obs, n_obs, b_resamples, alpha_level, rng):\n        \"\"\"\n        Performs the full analysis for a single dataset.\n        \n        Args:\n            y_obs (np.ndarray): The observed binary data.\n            n_obs (int): The sample size.\n            b_resamples (int): The number of bootstrap resamples.\n            alpha_level (float): The significance level for the confidence interval.\n            rng (np.random.Generator): The random number generator.\n            \n        Returns:\n            list: A list of 5 floats: [p_hat, ci_lower, ci_upper, se_robust, se_bootstrap].\n        \"\"\"\n        # 1. Sample Proportion\n        p_hat = np.mean(y_obs)\n\n        # 2. Nonparametric Bootstrap\n        p_hat_bootstrap_dist = np.zeros(b_resamples)\n        for j in range(b_resamples):\n            y_resample = rng.choice(y_obs, size=n_obs, replace=True)\n            p_hat_bootstrap_dist[j] = np.mean(y_resample)\n            \n        # 3. Percentile Confidence Interval\n        ci_lower = np.quantile(p_hat_bootstrap_dist, alpha_level / 2.0)\n        ci_upper = np.quantile(p_hat_bootstrap_dist, 1.0 - alpha_level / 2.0)\n        \n        # 4. Robust Standard Error\n        var_robust = (p_hat * (1.0 - p_hat)) / n_obs\n        se_robust = np.sqrt(var_robust) if var_robust = 0 else 0.0\n\n        # 5. Bootstrap Standard Error\n        # Use ddof=1 for sample standard deviation.\n        se_bootstrap = np.std(p_hat_bootstrap_dist, ddof=1)\n        \n        return [p_hat, ci_lower, ci_upper, se_robust, se_bootstrap]\n\n    # --- Problem Parameters ---\n    n = 50\n    B = 2000\n    alpha = 0.05\n    seed = 2025\n\n    # --- Test Suite ---\n    test_cases = [\n        # Dataset 1: 25 ones, 25 zeros\n        np.concatenate([np.ones(25, dtype=np.int8), np.zeros(25, dtype=np.int8)]),\n        # Dataset 2: 5 ones, 45 zeros\n        np.concatenate([np.ones(5, dtype=np.int8), np.zeros(45, dtype=np.int8)]),\n        # Dataset 3: 0 ones, 50 zeros\n        np.zeros(50, dtype=np.int8),\n        # Dataset 4: 50 ones, 0 zeros\n        np.ones(50, dtype=np.int8),\n    ]\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    all_results = []\n    for y_data in test_cases:\n        result = analyze_dataset(y_data, n, B, alpha, rng)\n        all_results.append(result)\n\n    # --- Final Output Formatting ---\n    # Construct the final output string to match the required format:\n    # [[r11,r12,...],[r21,r22,...],...] with 6 decimal places.\n    # No spaces after commas.\n    list_of_lists_str = []\n    for res_list in all_results:\n        formatted_numbers = [f\"{num:.6f}\" for num in res_list]\n        list_str = f\"[{','.join(formatted_numbers)}]\"\n        list_of_lists_str.append(list_str)\n        \n    final_output = f\"[{','.join(list_of_lists_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在许多生物统计学应用中，线性回归模型的误差方差并非恒定，即存在异方差性（heteroskedasticity），这使得普通最小二乘法（OLS）的标准误估计变得不可靠。本练习将介绍一种专门为解决此问题而设计的先进重抽样技术——狂野自助法（wild bootstrap）。通过实现这一方法，你将学会如何调整自助法框架以应对更复杂的数据结构，从而获得对回归系数更准确的方差估计。",
            "id": "4948717",
            "problem": "考虑一个适用于生物统计学应用的简单线性回归模型，其中条件误差方差随生物标志物水平的增加而增加。设观测值由 $i \\in \\{1,\\dots,n\\}$ 索引，其中标量预测变量（生物标志物）为 $x_i$，结果为 $y_i$。假设数据由以下数据生成过程生成：\n$$\ny_i \\;=\\; \\beta_0 \\;+\\; \\beta_1 x_i \\;+\\; \\varepsilon_i,\n$$\n其中 $(\\varepsilon_i \\mid x_i)$ 的条件均值为 $E[\\varepsilon_i \\mid x_i] = 0$，条件方差为 $\\mathrm{Var}(\\varepsilon_i \\mid x_i) = \\sigma_0^2 \\, \\bigl(1 + \\alpha x_i\\bigr)^2$，且 $\\sigma_0  0$ 和 $\\alpha \\ge 0$。方差随 $x_i$ 递增会引起异方差性。普通最小二乘估计量 $\\hat{\\beta} = (\\hat{\\beta}_0, \\hat{\\beta}_1)^\\top$ 是使残差平方和 $\\sum_{i=1}^n \\bigl(y_i - \\beta_0 - \\beta_1 x_i\\bigr)^2$ 最小化的值。\n\n您必须使用 Mammen 乘子通过狂野自助法（wild bootstrap）计算异方差稳健的不确定性。狂野自助法使用残差 $\\hat{e}_i = y_i - \\hat{\\beta}_0 - \\hat{\\beta}_1 x_i$ 并生成自举伪响应 $y_i^{\\ast} = \\hat{\\beta}_0 + \\hat{\\beta}_1 x_i + \\hat{e}_i v_i$，其中 $v_i$ 在不同 $i$ 之间是独立同分布的，服从由下式定义的 Mammen 两点分布：\n$$\nv_i \\;=\\; \\frac{1 - \\sqrt{5}}{2} \\quad \\text{概率为} \\quad \\frac{\\sqrt{5} + 1}{2\\sqrt{5}}, \n\\qquad\nv_i \\;=\\; \\frac{1 + \\sqrt{5}}{2} \\quad \\text{概率为} \\quad \\frac{\\sqrt{5} - 1}{2\\sqrt{5}}.\n$$\n对每个自举样本，对 $\\{(x_i, y_i^\\ast)\\}_{i=1}^n$ 重新拟合普通最小二乘法以获得 $\\hat{\\beta}^{\\ast} = (\\hat{\\beta}^{\\ast}_0, \\hat{\\beta}^{\\ast}_1)^\\top$。将此过程重复 $B$ 次自举复制，并将 $\\hat{\\beta}$ 各分量的狂野自助法标准误估计为 $B$ 个自举估计值的样本标准差。使用 $B = 2000$。\n\n您的程序必须实现此过程，并为多个按如下方式构建的合成测试数据集返回截距和斜率的狂野自助法标准误。对于每个测试用例，从指定区间上的连续均匀分布中独立生成 $x_i$，然后从均值为 $0$、标准差为 $\\sigma_0 (1 + \\alpha x_i)$ 的正态分布中独立生成 $\\varepsilon_i$，最后设置 $y_i = \\beta_0 + \\beta_1 x_i + \\varepsilon_i$。所有随机性必须由每个测试用例的固定种子控制，以确保可复现性。\n\n使用以下四个测试用例组成的测试套件，每个测试用例由 $(\\text{seed}, n, \\beta_0, \\beta_1, \\sigma_0, \\alpha, x_{\\min}, x_{\\max})$ 指定：\n- 测试用例 1：$(\\,123,\\, 60,\\, 0.5,\\, 1.2,\\, 1.0,\\, 0.5,\\, 0,\\, 5\\,)$。\n- 测试用例 2：$(\\,42,\\, 30,\\, -0.3,\\, 2.0,\\, 0.5,\\, 1.0,\\, 0,\\, 3\\,)$。\n- 测试用例 3：$(\\,777,\\, 200,\\, 0.0,\\, 0.8,\\, 0.8,\\, 0.2,\\, 0,\\, 10\\,)$。\n- 测试用例 4：$(\\,999,\\, 40,\\, 1.0,\\, -0.5,\\, 1.2,\\, 0.0,\\, 0,\\, 4\\,)$。\n\n对于每个测试用例：\n- 使用给定的 $\\text{seed}$ 设置伪随机数生成器。\n- 对于 $i \\in \\{1,\\dots,n\\}$，独立地从 $\\mathrm{Uniform}(x_{\\min}, x_{\\max})$ 中抽取 $x_i$。\n- 在不同 $i$ 之间独立地从 $\\mathcal{N}\\!\\left(0, \\bigl[\\sigma_0 (1 + \\alpha x_i)\\bigr]^2\\right)$ 中抽取 $\\varepsilon_i$。\n- 构建 $y_i = \\beta_0 + \\beta_1 x_i + \\varepsilon_i$。\n- 拟合带截距项的普通最小二乘法以获得 $\\hat{\\beta}$ 和残差 $\\hat{e}_i$。\n- 使用 Mammen 乘子和 $B = 2000$ 执行狂野自助法，以获得 $\\hat{\\beta}_0$ 和 $\\hat{\\beta}_1$ 的自举标准误。\n\n最终输出格式要求：\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。\n- 对于每个测试用例 $k \\in \\{1,2,3,4\\}$，该列表必须按顺序首先包含截距 $\\hat{\\beta}_0$ 的狂野自助法标准误，然后是斜率 $\\hat{\\beta}_1$ 的狂野自助法标准误。\n- 因此总共有 $8$ 个数字。\n- 每个数字必须四舍五入到 $6$ 位小数。\n- 所需格式示例（使用占位符）：$[\\text{se}_{0,1},\\text{se}_{1,1},\\text{se}_{0,2},\\text{se}_{1,2},\\text{se}_{0,3},\\text{se}_{1,3},\\text{se}_{0,4},\\text{se}_{1,4}]$。",
            "solution": "该问题要求使用带 Mammen 乘子的狂野自助法（wild bootstrap method）来计算简单线性回归模型系数的异方差稳健标准误。\n\n### 步骤 1：问题验证\n\n第一步是验证问题陈述。\n\n#### 1.1. 提取已知信息\n问题提供了以下信息：\n- **模型**：一个简单线性回归模型 $y_i = \\beta_0 + \\beta_1 x_i + \\varepsilon_i$。\n- **数据生成过程 (DGP)**：\n    - 误差项的条件均值为 $E[\\varepsilon_i \\mid x_i] = 0$。\n    - 误差项的条件方差是异方差的：$\\mathrm{Var}(\\varepsilon_i \\mid x_i) = \\sigma_0^2 (1 + \\alpha x_i)^2$，其中 $\\sigma_0  0$ 且 $\\alpha \\ge 0$。\n    - 为进行模拟，协变量 $x_i$ 从连续均匀分布 $x_i \\sim \\mathrm{Uniform}(x_{\\min}, x_{\\max})$ 中独立抽取。\n    - 误差项 $\\varepsilon_i$ 从正态分布 $\\varepsilon_i \\sim \\mathcal{N}(0, [\\sigma_0 (1 + \\alpha x_i)]^2)$ 中独立抽取。\n- **估计量**：普通最小二乘 (OLS) 估计量 $\\hat{\\beta} = (\\hat{\\beta}_0, \\hat{\\beta}_1)^\\top$，它最小化残差平方和。\n- **不确定性估计方法**：带 Mammen 乘子的狂野自助法。\n    - 残差计算为 $\\hat{e}_i = y_i - \\hat{\\beta}_0 - \\hat{\\beta}_1 x_i$。\n    - 自举伪响应生成为 $y_i^{\\ast} = \\hat{\\beta}_0 + \\hat{\\beta}_1 x_i + \\hat{e}_i v_i$。\n    - 乘子 $v_i$ 从 Mammen 两点分布中独立抽取：\n        - $v_i = \\frac{1 - \\sqrt{5}}{2}$，概率为 $p_1 = \\frac{\\sqrt{5} + 1}{2\\sqrt{5}}$。\n        - $v_i = \\frac{1 + \\sqrt{5}}{2}$，概率为 $p_2 = \\frac{\\sqrt{5} - 1}{2\\sqrt{5}}$。\n    - 对每个自举样本，重新拟合一个 OLS 模型以获得 $\\hat{\\beta}^{\\ast} = (\\hat{\\beta}^{\\ast}_0, \\hat{\\beta}^{\\ast}_1)^\\top$。\n    - 自举复制次数为 $B = 2000$。\n    - 每个系数的标准误是 $B$ 个自举估计值的样本标准差。\n- **测试用例**：提供了四组特定的参数 $(\\text{seed}, n, \\beta_0, \\beta_1, \\sigma_0, \\alpha, x_{\\min}, x_{\\max})$。\n    1. $(123, 60, 0.5, 1.2, 1.0, 0.5, 0, 5)$\n    2. $(42, 30, -0.3, 2.0, 0.5, 1.0, 0, 3)$\n    3. $(777, 200, 0.0, 0.8, 0.8, 0.2, 0, 10)$\n    4. $(999, 40, 1.0, -0.5, 1.2, 0.0, 0, 4)$\n- **输出格式**：一个包含 8 个数字（4 个用例的截距 SE 和斜率 SE）的单一列表，四舍五入到 6 位小数。\n\n#### 1.2. 依据标准进行验证\n- **科学依据**：该问题基于成熟的统计理论。线性回归、异方差性以及狂野自助法是生物统计学和计量经济学中的标准课题。所指定的方差结构是一个合理的模型，可用于描述变异性随生物标志物水平增加而增加的现象。Mammen 分布是在狂野自助法中对乘子进行选择的标准且理论上合理的选项。\n- **适定性**：该问题是适定的。它提供了所有必要的参数、一个清晰的逐步过程以及用于可复现性的特定随机种子。这确保了存在一个唯一且有意义的数值解。\n- **客观性**：该问题以精确、客观和数学化的语言陈述。没有主观或含糊不清的术语。\n\n问题陈述未违反任何无效性标准。它是科学合理的、可形式化的、完整的、可行的且结构良好。\n\n#### 1.3. 结论\n该问题是**有效的**。\n\n### 步骤 2：求解推导\n\n求解过程涉及实现一个计算统计学算法。核心任务是在存在异方差的情况下估计 OLS 系数的标准误。\n\n#### 2.1. 理论框架\n假设的模型是 $y_i = \\beta_0 + \\beta_1 x_i + \\varepsilon_i$。写成矩阵形式为 $\\mathbf{y} = \\mathbf{X}\\beta + \\varepsilon$，其中 $\\mathbf{y}$ 是 $n \\times 1$ 的结果向量，$\\mathbf{X}$ 是 $n \\times 2$ 的设计矩阵，其一列为全 1，另一列为预测变量值 $x_i$，$\\beta = (\\beta_0, \\beta_1)^\\top$ 是系数向量，$\\varepsilon$ 是误差向量。\n\nOLS 估计量由 $\\hat{\\beta} = (\\mathbf{X}^\\top\\mathbf{X})^{-1}\\mathbf{X}^\\top\\mathbf{y}$ 给出。在标准的同方差性假设下（即对所有 $i$，$\\mathrm{Var}(\\varepsilon_i \\mid x_i) = \\sigma^2$），$\\hat{\\beta}$ 的方差为 $\\mathrm{Var}(\\hat{\\beta}) = \\sigma^2(\\mathbf{X}^\\top\\mathbf{X})^{-1}$。然而，问题指定了异方差误差，$\\mathrm{Var}(\\varepsilon_i \\mid x_i) = \\sigma_i^2 = \\sigma_0^2 (1 + \\alpha x_i)^2$。在这种情况下，$\\hat{\\beta}$ 的真实方差是夹心估计量形式：$\\mathrm{Var}(\\hat{\\beta}) = (\\mathbf{X}^\\top\\mathbf{X})^{-1}(\\mathbf{X}^\\top\\mathbf{\\Omega}\\mathbf{X})(\\mathbf{X}^\\top\\mathbf{X})^{-1}$，其中 $\\mathbf{\\Omega}$ 是一个对角矩阵，其对角线元素为 $\\sigma_i^2$。\n\n由于 $\\mathbf{\\Omega}$ 是未知的，我们需要估计这个方差。狂野自助法是一种特别适用于此的重抽样方法。它通过一种能够保留原始数据中发现的异方差结构的方式来生成自举样本。\n\n过程如下：\n1. 将 OLS 模型拟合到原始数据 $(\\mathbf{y}, \\mathbf{X})$ 以获得估计值 $\\hat{\\beta}$ 和残差 $\\hat{e}_i = y_i - \\hat{y}_i = y_i - (\\hat{\\beta}_0 + \\hat{\\beta}_1 x_i)$。\n2. 生成 $B$ 个自举样本。对于每个自举复制 $b \\in \\{1, \\dots, B\\}$：\n    a. 对于每个观测值 $i \\in \\{1, \\dots, n\\}$，从一个均值为 $0$、方差为 $1$ 的分布中抽取一个随机值 $v_i$。问题指定了 Mammen 两点分布。\n    b. 构建一个自举伪响应 $y_i^{\\ast} = \\hat{y}_i + \\hat{e}_i v_i$。这相当于创建一个自举误差项 $\\varepsilon_i^{\\ast} = \\hat{e}_i v_i$。\n    c. 使用原始预测变量 $x_i$ 和新的响应变量 $y_i^{\\ast}$ 拟合一个 OLS 模型，以得到自举系数估计 $\\hat{\\beta}^{\\ast,b}$。\n3. 自举估计的集合 $\\{\\hat{\\beta}^{\\ast,1}, \\dots, \\hat{\\beta}^{\\ast,B}\\}$ 形成了一个经验分布，该分布近似于 $\\hat{\\beta}$ 的真实抽样分布。\n4. 每个系数的自举标准误是相应自举估计值的样本标准差。对于 $\\hat{\\beta}_j$，标准误为 $\\mathrm{SE}(\\hat{\\beta}_j) = \\sqrt{\\frac{1}{B-1} \\sum_{b=1}^B (\\hat{\\beta}_j^{\\ast,b} - \\bar{\\beta}_j^{\\ast})^2}$，其中 $\\bar{\\beta}_j^{\\ast} = \\frac{1}{B}\\sum_{b=1}^B \\hat{\\beta}_j^{\\ast,b}$。\n\n选择 Mammen 分布作为 $v_i$ 是有意的。它具有 $E[v_i] = 0$，$E[v_i^2] = 1$ 和 $E[v_i^3] = 1$ 的性质。前两阶矩确保了在自举世界中，以原始数据为条件，有 $E^{\\ast}[\\varepsilon_i^{\\ast} \\mid x_i] = \\hat{e}_i E[v_i] = 0$ 和 $\\mathrm{Var}^{\\ast}(\\varepsilon_i^{\\ast} \\mid x_i) = \\hat{e}_i^2 E[v_i^2] = \\hat{e}_i^2$。由于 $\\hat{e}_i^2$ 是真实误差方差 $\\sigma_i^2$ 的特定于观测的估计，此过程生成的自举数据具有模仿原始数据异方差性的方差结构。第三阶矩性质有助于获得置信区间的高阶修正，尽管它对于标准误估计并非严格必要。\n\n#### 2.2. 算法实现\n对于由 $(\\text{seed}, n, \\beta_0, \\beta_1, \\sigma_0, \\alpha, x_{\\min}, x_{\\max})$ 定义的每个测试用例：\n1. **初始化随机数生成器**：为保证可复现性，设置伪随机数生成器的种子。\n2. **生成数据**：\n    - 从 $\\mathrm{Uniform}(x_{\\min}, x_{\\max})$ 中抽取 $n$ 个预测变量值 $x_i$。\n    - 对于每个 $x_i$，计算其特定的标准差 $\\sigma_i = \\sigma_0 (1 + \\alpha x_i)$。\n    - 从 $\\mathcal{N}(0, \\sigma_i^2)$ 中抽取 $n$ 个误差项 $\\varepsilon_i$。\n    - 构建结果变量 $y_i = \\beta_0 + \\beta_1 x_i + \\varepsilon_i$。\n3. **初始 OLS 拟合**：\n    - 构建一个大小为 $n \\times 2$ 的设计矩阵 $\\mathbf{X}$，其第一列全为 1，第二列为 $x_i$ 的向量。\n    - 通过求解正规方程计算 OLS 估计 $\\hat{\\beta} = (\\hat{\\beta}_0, \\hat{\\beta}_1)^\\top$，例如，在 $\\mathbf{y}$ 和 $\\mathbf{X}$ 上使用最小二乘求解器。\n    - 计算拟合值 $\\hat{\\mathbf{y}} = \\mathbf{X}\\hat{\\beta}$。\n    - 计算残差 $\\hat{\\mathbf{e}} = \\mathbf{y} - \\hat{\\mathbf{y}}$。\n4. **狂野自助法循环**：\n    - 初始化一个用于存储自举系数的矩阵，例如，一个 $B \\times 2$ 的 NumPy 数组，其中 $B=2000$。\n    - 定义 Mammen 乘子的值和概率：\n        - $v_1 = (1 - \\sqrt{5})/2$，$p_1 = (\\sqrt{5} + 1)/(2\\sqrt{5})$。\n        - $v_2 = (1 + \\sqrt{5})/2$，$p_2 = 1 - p_1$。\n    - 循环 $B$ 次：\n        a. 通过从 Mammen 分布中抽样，生成一个 $n \\times 1$ 的乘子向量 $\\mathbf{v}$。\n        b. 创建自举响应向量 $\\mathbf{y}^{\\ast} = \\hat{\\mathbf{y}} + \\hat{\\mathbf{e}} \\odot \\mathbf{v}$，其中 $\\odot$ 表示逐元素相乘。\n        c. 通过为 $\\mathbf{y}^{\\ast}$ 和 $\\mathbf{X}$ 求解最小二乘问题，计算自举 OLS 估计 $\\hat{\\beta}^{\\ast}$。\n        d. 将 $\\hat{\\beta}^{\\ast}$ 作为一行存储在存储矩阵中。\n5. **计算标准误**：\n    - 循环结束后，为存储矩阵的每一列计算样本标准差（使用 $1$ 的自由度校正，即 `ddof=1`）。这些就是 $\\hat{\\beta}_0$ 和 $\\hat{\\beta}_1$ 的狂野自助法标准误。\n6. **存储和格式化结果**：将计算出的两个标准误附加到一个列表中，该列表汇总了所有测试用例的结果。最终列表根据问题规范格式化为字符串。\n\n此过程将对所有四个测试用例重复执行。",
            "answer": "```python\nimport numpy as np\n\ndef compute_wild_bootstrap_se(seed, n, beta0, beta1, sigma0, alpha, x_min, x_max, B=2000):\n    \"\"\"\n    Computes heteroskedasticity-robust standard errors using the wild bootstrap.\n\n    Args:\n        seed (int): The seed for the random number generator.\n        n (int): Sample size.\n        beta0 (float): True intercept.\n        beta1 (float): True slope.\n        sigma0 (float): Baseline standard deviation parameter.\n        alpha (float): Heteroskedasticity parameter.\n        x_min (float): Minimum of the uniform distribution for x.\n        x_max (float): Maximum of the uniform distribution for x.\n        B (int): Number of bootstrap replicates.\n\n    Returns:\n        tuple: A tuple containing the bootstrap standard errors for the intercept and slope.\n    \"\"\"\n    # 1. Initialize RNG and Generate Data\n    rng = np.random.default_rng(seed)\n    \n    # Generate predictors x_i\n    x = rng.uniform(x_min, x_max, size=n)\n    \n    # Generate heteroskedastic errors\n    true_sd = sigma0 * (1 + alpha * x)\n    epsilon = rng.normal(0, true_sd)\n    \n    # Generate outcomes y_i\n    y = beta0 + beta1 * x + epsilon\n    \n    # 2. Initial OLS Fit\n    # Construct design matrix X with an intercept\n    X = np.c_[np.ones(n), x]\n    \n    # Compute OLS estimates beta_hat\n    beta_hat = np.linalg.lstsq(X, y, rcond=None)[0]\n    \n    # Compute fitted values and residuals\n    y_hat = X @ beta_hat\n    e_hat = y - y_hat\n    \n    # 3. Wild Bootstrap Loop\n    beta_boot_samples = np.zeros((B, 2))\n    \n    # Define Mammen multipliers\n    sqrt5 = np.sqrt(5)\n    v1 = (1 - sqrt5) / 2\n    v2 = (1 + sqrt5) / 2\n    p1 = (sqrt5 + 1) / (2 * sqrt5)\n    p2 = 1 - p1\n    mammen_values = [v1, v2]\n    mammen_probs = [p1, p2]\n    \n    for i in range(B):\n        # Generate multipliers v_i\n        v = rng.choice(mammen_values, size=n, p=mammen_probs)\n        \n        # Create bootstrap responses y_star\n        y_star = y_hat + e_hat * v\n        \n        # Fit OLS on bootstrap sample\n        beta_star = np.linalg.lstsq(X, y_star, rcond=None)[0]\n        beta_boot_samples[i, :] = beta_star\n        \n    # 4. Compute Standard Errors\n    # The sample standard deviation of the bootstrap estimates\n    se_beta0 = np.std(beta_boot_samples[:, 0], ddof=1)\n    se_beta1 = np.std(beta_boot_samples[:, 1], ddof=1)\n    \n    return se_beta0, se_beta1\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Test suite: (seed, n, beta0, beta1, sigma0, alpha, x_min, x_max)\n    test_cases = [\n        (123, 60, 0.5, 1.2, 1.0, 0.5, 0, 5),\n        (42, 30, -0.3, 2.0, 0.5, 1.0, 0, 3),\n        (777, 200, 0.0, 0.8, 0.8, 0.2, 0, 10),\n        (999, 40, 1.0, -0.5, 1.2, 0.0, 0, 4),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        seed, n, beta0, beta1, sigma0, alpha, x_min, x_max = case\n        se0, se1 = compute_wild_bootstrap_se(seed, n, beta0, beta1, sigma0, alpha, x_min, x_max)\n        all_results.extend([se0, se1])\n\n    # Format the results as required\n    formatted_results = [f\"{res:.6f}\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}