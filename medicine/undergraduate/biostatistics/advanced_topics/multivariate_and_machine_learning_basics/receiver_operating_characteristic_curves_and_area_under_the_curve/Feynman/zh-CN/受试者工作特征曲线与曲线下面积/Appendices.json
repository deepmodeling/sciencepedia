{
    "hands_on_practices": [
        {
            "introduction": "在我们深入研究从真实数据中计算 $AUC$ 之前，在一个清晰的数学模型中理解其基本属性是至关重要的。这项练习将推导经典“双正态”情况下的 $AUC$，其中正类和负类的分数分别服从正态分布。通过这个推导，你将把 $AUC$ 的几何定义（$ROC$ 曲线下的面积）与其深刻的概率解释联系起来，为更复杂的应用打下坚实的理论基础。",
            "id": "3167105",
            "problem": "一个二元分类器从输入特征 $X$ 中产生一个实值分数 $S$，用于区分类别 $Y \\in \\{0,1\\}$。假设以类别标签为条件的得分分布是等方差的高斯分布：$S \\mid Y=1 \\sim \\mathcal{N}(\\mu_{1}, \\sigma^{2})$ 和 $S \\mid Y=0 \\sim \\mathcal{N}(\\mu_{0}, \\sigma^{2})$，其中 $\\mu_{1}, \\mu_{0} \\in \\mathbb{R}$ 且 $\\sigma > 0$。考虑一个阈值规则，即当且仅当 $S \\geq t$ 时预测 $Y=1$，其中 $t \\in \\mathbb{R}$ 是一个阈值。\n\n仅使用真正率 (TPR)、假正率 (FPR)、受试者工作特征 (ROC) 曲线和曲线下面积 (AUC) 的基本定义，完成以下任务：\n- 推导受试者工作特征 (ROC) 曲线的参数形式，即将由阈值 $t$ 引起的真正率表示为假正率的函数。\n- 然后，推导该模型曲线下面积 (AUC) 的一个闭式解析表达式，该表达式是 $\\mu_{1}、\\mu_{0}$ 和 $\\sigma$ 的函数。\n\n为清楚起见，受试者工作特征 (ROC) 曲线是随着阈值 $t$ 变化的真正率 (TPR) 对假正率 (FPR) 的曲线图，而曲线下面积 (AUC) 是该曲线下的面积。将最终答案表示为 AUC 的单个闭式解析表达式。无需四舍五入。",
            "solution": "用户希望得到该问题的详细推导。我将遵循我在思考过程中概述的计划。\n\n**1. 问题验证**\n\n问题陈述按如下方式进行验证：\n\n*   **步骤 1：提取已知条件**\n    *   分类器：二元，类别为 $Y \\in \\{0, 1\\}$。\n    *   分数：实值分数 $S$。\n    *   条件分布：$S \\mid Y=1 \\sim \\mathcal{N}(\\mu_{1}, \\sigma^{2})$ 和 $S \\mid Y=0 \\sim \\mathcal{N}(\\mu_{0}, \\sigma^{2})$。\n    *   参数：$\\mu_{1}, \\mu_{0} \\in \\mathbb{R}$ 和 $\\sigma > 0$。\n    *   决策规则：当且仅当 $S \\geq t$ 时预测 $Y=1$，其中 $t \\in \\mathbb{R}$ 为阈值。\n    *   定义：真正率 (TPR)、假正率 (FPR)、受试者工作特征 (ROC) 曲线、曲线下面积 (AUC)。\n    *   任务：\n        1. 推导 ROC 曲线的参数形式（TPR 作为 FPR 的函数）。\n        2. 推导 AUC 作为 $\\mu_{1}$、$\\mu_{0}$ 和 $\\sigma$ 的函数的闭式解析表达式。\n\n*   **步骤 2：使用提取的已知条件进行验证**\n    *   该问题具有科学依据，植根于标准的统计决策理论和机器学习原理。使用高斯分布来表示类别条件得分是一种常见且易于理解的模型（例如，线性判别分析的基础）。\n    *   该问题是适定的。提供了所有必要信息，术语是标准的且定义清晰，存在唯一且有意义的解。\n    *   该问题是客观的，使用精确的数学语言，没有主观或含糊的陈述。\n    *   该问题不存在说明中列出的任何无效性缺陷。它是其领域内一个标准的可解问题。\n\n*   **步骤 3：结论和行动**\n    *   该问题是有效的。将继续进行求解过程。\n\n**2. 解答推导**\n\n解答需要两部分：首先，推导 ROC 曲线方程；其次，计算其曲线下面积 (AUC)。\n\n令 $\\Phi(z)$ 为标准正态分布 $\\mathcal{N}(0, 1)$ 的累积分布函数 (CDF)，定义为 $\\Phi(z) = \\int_{-\\infty}^{z} \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{u^2}{2}\\right) du$。\n\n**第 1 部分：ROC 曲线的推导**\n\nROC 曲线是对于变化的决策阈值 $t$，真正率 (TPR) 对假正率 (FPR) 的图。\n\n真正率 $\\text{TPR}(t)$ 是正确分类一个正例 ($Y=1$) 的概率。分类规则是 $S \\ge t$。\n$$\n\\text{TPR}(t) = P(S \\ge t \\mid Y=1)\n$$\n给定 $S \\mid Y=1 \\sim \\mathcal{N}(\\mu_{1}, \\sigma^{2})$，我们可以对随机变量 $S$ 进行标准化：\n$$\n\\text{TPR}(t) = P\\left(\\frac{S-\\mu_1}{\\sigma} \\ge \\frac{t-\\mu_1}{\\sigma} \\mid Y=1\\right)\n$$\n项 $\\frac{S-\\mu_1}{\\sigma}$ 是一个标准正态随机变量。我们称之为 $Z$。\n$$\n\\text{TPR}(t) = P\\left(Z \\ge \\frac{t-\\mu_1}{\\sigma}\\right) = 1 - P\\left(Z  \\frac{t-\\mu_1}{\\sigma}\\right) = 1 - \\Phi\\left(\\frac{t-\\mu_1}{\\sigma}\\right)\n$$\n利用标准正态分布的对称性 $1 - \\Phi(z) = \\Phi(-z)$，我们得到：\n$$\n\\text{TPR}(t) = \\Phi\\left(-\\frac{t-\\mu_1}{\\sigma}\\right) = \\Phi\\left(\\frac{\\mu_1-t}{\\sigma}\\right)\n$$\n\n假正率 $\\text{FPR}(t)$ 是将一个负例 ($Y=0$) 错误分类为正例的概率。\n$$\n\\text{FPR}(t) = P(S \\ge t \\mid Y=0)\n$$\n给定 $S \\mid Y=0 \\sim \\mathcal{N}(\\mu_{0}, \\sigma^{2})$，我们同样进行标准化：\n$$\n\\text{FPR}(t) = P\\left(\\frac{S-\\mu_0}{\\sigma} \\ge \\frac{t-\\mu_0}{\\sigma} \\mid Y=0\\right)\n$$\n$$\n\\text{FPR}(t) = P\\left(Z \\ge \\frac{t-\\mu_0}{\\sigma}\\right) = 1 - \\Phi\\left(\\frac{t-\\mu_0}{\\sigma}\\right) = \\Phi\\left(\\frac{\\mu_0-t}{\\sigma}\\right)\n$$\n\n为了找到 ROC 曲线，我们必须将 TPR 表示为 FPR 的函数。令 $y = \\text{TPR}$ 和 $x = \\text{FPR}$。\n我们有参数方程：\n$y(t) = \\Phi\\left(\\frac{\\mu_1-t}{\\sigma}\\right)$\n$x(t) = \\Phi\\left(\\frac{\\mu_0-t}{\\sigma}\\right)$\n\n从 $x$ 的方程中，我们可以使用标准正态分布的反累积分布函数 $\\Phi^{-1}$（概率单位函数）将 $t$ 表示为 $x$ 的函数。\n$$\n\\Phi^{-1}(x) = \\frac{\\mu_0-t}{\\sigma}\n$$\n求解 $t$：\n$$\n\\sigma \\Phi^{-1}(x) = \\mu_0-t \\implies t = \\mu_0 - \\sigma \\Phi^{-1}(x)\n$$\n现在，将这个 $t$ 的表达式代入 $y$ 的方程中：\n$$\ny = \\Phi\\left(\\frac{\\mu_1 - (\\mu_0 - \\sigma \\Phi^{-1}(x))}{\\sigma}\\right)\n$$\n$$\ny = \\Phi\\left(\\frac{\\mu_1 - \\mu_0 + \\sigma \\Phi^{-1}(x)}{\\sigma}\\right)\n$$\n$$\ny = \\Phi\\left(\\frac{\\mu_1 - \\mu_0}{\\sigma} + \\Phi^{-1}(x)\\right)\n$$\n因此，ROC 曲线的参数形式是：\n$$\n\\text{TPR} = \\Phi\\left(\\frac{\\mu_1 - \\mu_0}{\\sigma} + \\Phi^{-1}(\\text{FPR})\\right)\n$$\n\n**第 2 部分：曲线下面积 (AUC) 的推导**\n\nAUC 是 ROC 函数从 $\\text{FPR}=0$到 $\\text{FPR}=1$ 的积分。\n$$\n\\text{AUC} = \\int_{0}^{1} \\text{TPR}(\\text{FPR}) \\, d(\\text{FPR})\n$$\n虽然可以直接计算这个积分，但一个更有洞察力的方法是使用 AUC 的概率解释。AUC 等价于一个随机选择的正例的得分高于一个随机选择的负例的得分的概率。设 $S_1$ 是来自正例 ($Y=1$) 的随机得分，$S_0$ 是来自负例 ($Y=0$) 的随机得分。那么：\n$$\n\\text{AUC} = P(S_1  S_0)\n$$\n这里，$S_1 \\sim \\mathcal{N}(\\mu_{1}, \\sigma^{2})$ 和 $S_0 \\sim \\mathcal{N}(\\mu_{0}, \\sigma^{2})$，并且它们是独立的。\n我们关心的是概率 $P(S_1 - S_0  0)$。\n我们定义一个新的随机变量 $D = S_1 - S_0$。由于 $S_1$ 和 $S_0$ 是独立的服从正态分布的随机变量，它们的差 $D$ 也服从正态分布。\n\n$D$ 的均值是：\n$$\nE[D] = E[S_1 - S_0] = E[S_1] - E[S_0] = \\mu_1 - \\mu_0\n$$\n$D$ 的方差是（由于独立性）：\n$$\n\\text{Var}(D) = \\text{Var}(S_1 - S_0) = \\text{Var}(S_1) + \\text{Var}(-S_0) = \\text{Var}(S_1) + (-1)^2 \\text{Var}(S_0) = \\sigma^2 + \\sigma^2 = 2\\sigma^2\n$$\n所以，差的分布是 $D \\sim \\mathcal{N}(\\mu_1 - \\mu_0, 2\\sigma^2)$。\n\n现在我们可以计算概率 $P(D  0)$。我们对变量 $D$ 进行标准化：\n$$\nP(D0) = P\\left(\\frac{D - E[D]}{\\sqrt{\\text{Var}(D)}}  \\frac{0 - E[D]}{\\sqrt{\\text{Var}(D)}}\\right)\n$$\n$$\nP(D0) = P\\left(Z  \\frac{0 - (\\mu_1 - \\mu_0)}{\\sqrt{2\\sigma^2}}\\right)\n$$\n其中 $Z \\sim \\mathcal{N}(0, 1)$。\n$$\nP(D0) = P\\left(Z  -\\frac{\\mu_1 - \\mu_0}{\\sigma\\sqrt{2}}\\right)\n$$\n使用对称性 $P(Z  -z) = P(Z  z) = \\Phi(z)$，我们发现：\n$$\nP(D0) = \\Phi\\left(\\frac{\\mu_1 - \\mu_0}{\\sigma\\sqrt{2}}\\right)\n$$\n因此，AUC 的闭式解析表达式是：\n$$\n\\text{AUC} = \\Phi\\left(\\frac{\\mu_1 - \\mu_0}{\\sigma\\sqrt{2}}\\right)\n$$\n推导完毕。",
            "answer": "$$\\boxed{\\Phi\\left(\\frac{\\mu_1 - \\mu_0}{\\sigma\\sqrt{2}}\\right)}$$"
        },
        {
            "introduction": "在掌握了理论推导之后，我们转向处理经验数据。这项练习旨在巩固 $AUC$ 最重要的解释：它代表了一个随机选择的正例分数高于一个随机选择的负例分数的概率。你将通过编写一个程序，用两种不同的方法来计算 $AUC$——一种是基于 $ROC$ 曲线的几何方法（梯形法则），另一种是通过成对比较的概率方法——并亲自验证它们之间的等价性。",
            "id": "3167097",
            "problem": "构建一个独立的程序，用于对几个指定的测试用例，比较通过二元分类得分经验性计算得出的两个量：接收者操作特征（ROC）曲线下的几何面积，以及正例与负例之间的直接成对超越概率。此任务的基本依据是接收者操作特征（ROC）曲线及其曲线下面积（AUC）的定义，以及概率作为相对频率极限的定义。您必须严格遵循这些核心定义进行操作。\n\n设一个二元分类问题由一个应用于实例的实值得分函数 $S:\\mathbb{R}^d\\to\\mathbb{R}$ 表示，其真实标签为 $Y\\in\\{0,1\\}$，其中 $Y=1$ 表示正类，$Y=0$ 表示负类。对于任意阈值 $t\\in\\mathbb{R}$，定义真正率（TPR）和假正率（FPR）如下：\n$$\n\\mathrm{TPR}(t) = \\frac{\\#\\{i:\\,Y_i=1,\\,S_i\\ge t\\}}{\\#\\{i:\\,Y_i=1\\}},\\quad\n\\mathrm{FPR}(t) = \\frac{\\#\\{i:\\,Y_i=0,\\,S_i\\ge t\\}}{\\#\\{i:\\,Y_i=0\\}}.\n$$\n接收者操作特征（ROC）曲线是当 $t$ 遍历所有可能的阈值时，所描绘出的参数曲线 $\\big(\\mathrm{FPR}(t),\\mathrm{TPR}(t)\\big)$。曲线下面积（AUC）定义为在此曲线上 $\\mathrm{TPR}$ 相对于 $\\mathrm{FPR}$ 的黎曼积分：\n$$\n\\mathrm{AUC} = \\int \\mathrm{TPR}\\,d(\\mathrm{FPR}),\n$$\n几何上解释为单位正方形内 ROC 曲线下方的面积。\n\n独立地，考虑通过分别根据正例和负例得分的经验分布抽样一个正例和一个负例而获得的两个随机得分 $S^+$ 和 $S^-$。定义直接成对超越概率为\n$$\np_{} = \\mathbb{P}\\big(S^+  S^-\\big),\n$$\n以及考虑了平局情况调整后的超越概率为\n$$\np_{\\text{half}} = \\mathbb{P}\\big(S^+  S^-\\big) + \\frac{1}{2}\\,\\mathbb{P}\\big(S^+ = S^-\\big).\n$$\n您的程序必须根据 ROC 定义，使用梯形法则对经验 ROC 点进行积分，从而经验性地估计 $\\mathrm{AUC}$，并独立地通过计算所有正-负得分对来估计 $p_{}$ 和 $p_{\\text{half}}$。然后，对于每个测试用例，计算两个浮点数：绝对差 $|\\mathrm{AUC} - p_{}|$ 和绝对差 $|\\mathrm{AUC} - p_{\\text{half}}|$。\n\n实现要求：\n- 对于每个测试用例，根据指定的分布和参数生成正例得分和负例得分，使用固定的随机种子 $42$ 以确保可复现性。\n- 计算 $\\mathrm{AUC}$ 的步骤如下：\n  - 将所有得分按降序排序。\n  - 在每个唯一的得分值处扫描阈值，以构建经验 ROC 点 $\\big(\\mathrm{FPR},\\mathrm{TPR}\\big)$。\n  - 在这些点上（包括端点 $(0,0)$ 和 $(1,1)$）通过梯形法则对 $\\mathrm{TPR}$ 相对于 $\\mathrm{FPR}$ 进行积分。\n- 通过计算所有正-负对来计算 $p_{}$ 和 $p_{\\text{half}}$：\n  - 对于 $p_{}$：计算严格大于的比较次数。\n  - 对于 $p_{\\text{half}}$：对于平局（得分相等）的情况，加上一半的计数值。\n\n测试套件：\n- 案例 $1$（连续，中等分离度）：正例得分 $S^+$ 从均值为 $\\mu_+=1$、标准差为 $\\sigma_+=1$ 的正态分布中抽样；负例得分 $S^-$ 从均值为 $\\mu_-=0$、标准差为 $\\sigma_-=1$ 的正态分布中抽样；样本量 $n^+=1000$，$n^-=1000$。\n- 案例 $2$（连续，分布相同）：$S^+$ 和 $S^-$ 均来自 $\\mu=0$、$\\sigma=1$ 的正态分布；$n^+=2000$，$n^-=2000$。\n- 案例 $3$（连续，强分离度）：$S^+$ 从均值为 $\\mu_+=3$、标准差为 $\\sigma_+=0.5$ 的正态分布中抽样；$S^-$ 从均值为 $\\mu_-=0$、标准差为 $\\sigma_-=0.5$ 的正态分布中抽样；$n^+=1000$，$n^-=1000$。\n- 案例 $4$（离散，有平局）：$S^+$ 从成功概率为 $p_+=0.6$ 的伯努利分布中抽样；$S^-$ 从成功概率为 $p_-=0.4$ 的伯努利分布中抽样；$n^+=5000$，$n^-=5000$。\n- 案例 $5$（连续，小样本，边界方差）：$S^+$ 从均值为 $\\mu_+=0.2$、标准差为 $\\sigma_+=1$ 的正态分布中抽样；$S^-$ 从均值为 $\\mu_-=0$、标准差为 $\\sigma_-=1$ 的正态分布中抽样；$n^+=10$，$n^-=10$。\n- 案例 $6$（连续，偏态分布）：$S^+$ 从率参数为 $\\lambda_+=1$（尺度参数 $1/\\lambda_+=1$）的指数分布中抽样；$S^-$ 从率参数为 $\\lambda_-=2$（尺度参数 $1/\\lambda_-=0.5$）的指数分布中抽样；$n^+=2000$，$n^-=2000$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按以下顺序排列：\n$$\n[\\Delta_1^{},\\Delta_1^{\\text{half}},\\Delta_2^{},\\Delta_2^{\\text{half}},\\dots,\\Delta_6^{},\\Delta_6^{\\text{half}}],\n$$\n其中 $\\Delta_k^{}=|\\mathrm{AUC}-p_{}|$ 和 $\\Delta_k^{\\text{half}}=|\\mathrm{AUC}-p_{\\text{half}}|$ 分别是案例 $k$ 的结果。每个浮点数应四舍五入到 $6$ 位小数。",
            "solution": "用户提供了一个在科学和数学上都合理的问题。我现在将着手解决。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n\n*   **问题领域**：二元分类、接收者操作特征（ROC）曲线、曲线下面积（AUC）。\n*   **定义**：\n    *   正类标签 $Y=1$，负类标签 $Y=0$。\n    *   得分函数 $S:\\mathbb{R}^d\\to\\mathbb{R}$。\n    *   真正率：$\\mathrm{TPR}(t) = \\frac{\\#\\{i:\\,Y_i=1,\\,S_i\\ge t\\}}{\\#\\{i:\\,Y_i=1\\}}$。\n    *   假正率：$\\mathrm{FPR}(t) = \\frac{\\#\\{i:\\,Y_i=0,\\,S_i\\ge t\\}}{\\#\\{i:\\,Y_i=0\\}}$。\n    *   ROC 曲线：当 $t$ 变化时，参数曲线 $(\\mathrm{FPR}(t),\\mathrm{TPR}(t))$。\n    *   AUC：$\\mathrm{AUC} = \\int \\mathrm{TPR}\\,d(\\mathrm{FPR})$，解释为 ROC 曲线下的面积。\n    *   直接成对超越概率：$p_{} = \\mathbb{P}(S^+  S^-)$，其中 $S^+$ 和 $S^-$ 分别是从随机选择的正例和负例中获得的得分。\n    *   考虑平局调整的超越概率：$p_{\\text{half}} = \\mathbb{P}(S^+  S^-) + \\frac{1}{2}\\,\\mathbb{P}(S^+ = S^-)$。\n*   **计算要求**：\n    *   使用固定的随机种子 $42$。\n    *   通过在唯一得分值处扫描阈值来构建经验 ROC 点，并使用梯形法则进行积分来估计 $\\mathrm{AUC}$。必须包括端点 $(0,0)$ 和 $(1,1)$。\n    *   通过枚举所有正负得分对并计数结果来估计 $p_{}$ 和 $p_{\\text{half}}$。\n*   **输出**：对于每个测试用例，计算两个绝对差：$\\Delta^{} = |\\mathrm{AUC} - p_{}|$ 和 $\\Delta^{\\text{half}} = |\\mathrm{AUC} - p_{\\text{half}}|$。最终输出必须是所有测试用例的这些差异的单个逗号分隔列表，每个值四舍五入到 $6$ 位小数。\n*   **测试用例**：\n    1.  $S^+ \\sim N(\\mu=1, \\sigma=1)$，$S^- \\sim N(\\mu=0, \\sigma=1)$；$n^+=1000, n^-=1000$。\n    2.  $S^+ \\sim N(\\mu=0, \\sigma=1)$，$S^- \\sim N(\\mu=0, \\sigma=1)$；$n^+=2000, n^-=2000$。\n    3.  $S^+ \\sim N(\\mu=3, \\sigma=0.5)$，$S^- \\sim N(\\mu=0, \\sigma=0.5)$；$n^+=1000, n^-=1000$。\n    4.  $S^+ \\sim \\text{Bernoulli}(p=0.6)$，$S^- \\sim \\text{Bernoulli}(p=0.4)$；$n^+=5000, n^-=5000$。\n    5.  $S^+ \\sim N(\\mu=0.2, \\sigma=1)$，$S^- \\sim N(\\mu=0, \\sigma=1)$；$n^+=10, n^-=10$。\n    6.  $S^+ \\sim \\text{Exponential}(\\lambda=1)$，$S^- \\sim \\text{Exponential}(\\lambda=2)$；$n^+=2000, n^-=2000$。\n\n**1.2. 验证与结论**\n\n根据验证标准对问题进行审查：\n*   **科学依据充分**：TPR、FPR、ROC 和 AUC 的定义在统计学和机器学习中是标准的。AUC 与概率 $\\mathbb{P}(S^+  S^-)$（更准确地说是与 $p_{\\text{half}}$ 等价的 Mann-Whitney U 统计量）之间的关系是一个基本且公认的定理。该问题要求使用指定的数值方法对该定理进行经验性验证。所有概念在科学上都是合理的。\n*   **问题定义明确**：问题定义明确。输入（分布和样本大小）、计算过程（梯形法则、成对计数）和期望的输出都得到了明确的规定。使用固定的随机种子确保了唯一且可复现的解决方案。\n*   **客观性**：语言正式、精确，没有任何主观性或偏见。\n*   **完整且一致**：问题陈述是自包含的。它提供了所有必要的定义、数据生成参数和计算指令。没有矛盾之处。\n*   **可行性**：指定的样本大小导致的计算量很大，但在现代硬件上是完全可行的（例如，$5000 \\times 5000 = 25 \\times 10^6$ 次成对比较）。\n\n**结论**：该问题是**有效的**。\n\n### 步骤 2：解决方案设计\n\n该任务要求实现两种不同的方法来量化正负得分分布之间的分离度，然后比较它们的结果。\n\n**2.1. 通过梯形法则计算 AUC**\n\n经验 ROC 曲线是在不同分类阈值下评估的 $(\\mathrm{FPR}, \\mathrm{TPR})$ 对的图。一个关键的洞见是，ROC 曲线是分段常数，并且仅在与观察到的得分值相对应的阈值处发生变化。构建曲线并计算其面积的最直接方法如下：\n\n1.  将所有正例得分（标记为 $1$）和负例得分（标记为 $0$）合并到一个 $(score, label)$ 对的集合中。设 $n^+$ 为正例总数，$n^-$ 为负例总数。\n2.  根据得分按降序对这些对进行排序。如果得分出现平局，标签的顺序不会影响最终的 AUC 计算，因为它们将被作为一个整体处理。\n3.  用点 $(0,0)$ 初始化 ROC 曲线，这对应于一个 $t \\to \\infty$ 的阈值，此时没有实例被分类为正例。将真正例计数 $(TP)$ 和假正例计数 $(FP)$ 初始化为 $0$。\n4.  遍历排序后的对。对于每个对 $(s_i, y_i)$：\n    *   更新计数：如果 $y_i=1$，则增加 $TP$；如果 $y_i=0$，则增加 $FP$。\n    *   为了构建经验 ROC 点，我们仅在阈值有效改变时才添加新点。这发生在处理完一组具有相同值的得分之后。因此，我们检查当前得分 $s_i$ 是否与下一个得分 $s_{i+1}$ 不同（或者我们是否在列表的末尾）。\n    *   当发生这种变化时，ROC 曲线上的一个新点由 $(\\frac{FP}{n^-}, \\frac{TP}{n^+})$ 定义。将此点添加到我们的 ROC 点列表中。\n5.  遍历所有得分后，最终的点将是 $(1,1)$。从 $(0,0)$ 开始生成的点的完整列表定义了经验 ROC 曲线的顶点。\n6.  然后通过对这些顶点应用梯形法则来计算曲线下面积（AUC）。对于每对连续的点 $(x_i, y_i)$ 和 $(x_{i+1}, y_{i+1})$，其下方的梯形面积由 $\\frac{1}{2}(y_i + y_{i+1})(x_{i+1} - x_i)$ 给出。将所有这些线段的面积相加即可得到总 AUC。\n\n**2.2. 计算成对超越概率**\n\n概率 $p_{}$ 和 $p_{\\text{half}}$ 通过经验计数直接从其定义中估算。\n\n1.  给定正例得分集合 $\\{S^+_1, \\dots, S^+_{n^+}\\}$ 和负例得分集合 $\\{S^-_1, \\dots, S^-_{n^-}\\}$，我们总共形成 $N = n^+ \\times n^-$ 个对。\n2.  初始化两个计数器：`greater_count = 0` 和 `equal_count = 0`。\n3.  遍历每个可能的对 $(S^+_i, S^-_j)$：\n    *   如果 $S^+_i  S^-_j$，则增加 `greater_count`。\n    *   如果 $S^+_i = S^-_j$，则增加 `equal_count`。\n4.  然后，经验概率计算如下：\n    *   $p_{} = \\frac{\\text{greater\\_count}}{N}$\n    *   $p_{\\text{half}} = \\frac{\\text{greater\\_count} + 0.5 \\times \\text{equal\\_count}}{N}$\n\n此方法在计算上等同于计算 Mann-Whitney U 统计量，已知该统计量等于 AUC。因此，该问题建立了一个对此统计定理的数值验证。\n\n**2.3. 程序实现**\n\n将构建一个 Python 程序，为六个测试用例中的每一个执行这些计算。\n*   将使用一个带有指定种子（$42$）的集中式随机数生成器（`numpy.random.default_rng`）以保证可复现性。\n*   将定义用于生成得分、计算 AUC 和计算成对概率的辅助函数，以确保代码的清晰性和模块化。\n*   主循环将遍历测试用例参数，调用辅助函数，计算所需的绝对差，并存储四舍五入后的结果。\n*   最后，程序将以指定格式打印收集到的结果。对于指数分布，我们注意到 `numpy` 库的 `exponential` 函数是以尺度参数 $\\beta$ 为参数的，它是率参数 $\\lambda$ 的倒数（即 $\\beta = 1/\\lambda$）。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_auc(pos_scores, neg_scores):\n    \"\"\"\n    Computes the Area Under the ROC Curve using the trapezoidal rule.\n    \"\"\"\n    n_pos = len(pos_scores)\n    n_neg = len(neg_scores)\n    \n    if n_pos == 0 or n_neg == 0:\n        return 0.5\n\n    # Combine scores and labels, then sort by score descending.\n    labels = [1] * n_pos + [0] * n_neg\n    scores = list(pos_scores) + list(neg_scores)\n    \n    sorted_pairs = sorted(zip(scores, labels), key=lambda x: x[0], reverse=True)\n    \n    # Initialize ROC points starting at (0,0).\n    roc_points = [(0.0, 0.0)]\n    tp_count, fp_count = 0, 0\n    \n    # Iterate through sorted scores to define ROC curve vertices.\n    for i in range(len(sorted_pairs)):\n        score, label = sorted_pairs[i]\n        \n        if label == 1:\n            tp_count += 1\n        else:\n            fp_count += 1\n            \n        # A new vertex is formed when the score value changes, or at the end.\n        is_last_element = (i == len(sorted_pairs) - 1)\n        is_score_change = not is_last_element and (score != sorted_pairs[i+1][0])\n        \n        if is_last_element or is_score_change:\n            tpr = tp_count / n_pos\n            fpr = fp_count / n_neg\n            roc_points.append((fpr, tpr))\n            \n    # Calculate area using the trapezoidal rule.\n    auc = 0.0\n    for i in range(len(roc_points) - 1):\n        x1, y1 = roc_points[i]\n        x2, y2 = roc_points[i+1]\n        auc += (x2 - x1) * (y1 + y2) / 2.0\n        \n    return auc\n\ndef calculate_probabilities(pos_scores, neg_scores):\n    \"\"\"\n    Computes p_> and p_half by direct pairwise comparison.\n    \"\"\"\n    n_pos = len(pos_scores)\n    n_neg = len(neg_scores)\n    total_pairs = n_pos * n_neg\n\n    if total_pairs == 0:\n        return 0.5, 0.5\n\n    gt_count = 0\n    eq_count = 0\n\n    for s_pos in pos_scores:\n        for s_neg in neg_scores:\n            if s_pos > s_neg:\n                gt_count += 1\n            elif s_pos == s_neg:\n                eq_count += 1\n                \n    p_gt = gt_count / total_pairs\n    p_half = (gt_count + 0.5 * eq_count) / total_pairs\n    \n    return p_gt, p_half\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    rng = np.random.default_rng(seed=42)\n    \n    test_cases = [\n        {'type': 'normal', 'params_pos': {'loc': 1, 'scale': 1, 'size': 1000}, 'params_neg': {'loc': 0, 'scale': 1, 'size': 1000}},\n        {'type': 'normal', 'params_pos': {'loc': 0, 'scale': 1, 'size': 2000}, 'params_neg': {'loc': 0, 'scale': 1, 'size': 2000}},\n        {'type': 'normal', 'params_pos': {'loc': 3, 'scale': 0.5, 'size': 1000}, 'params_neg': {'loc': 0, 'scale': 0.5, 'size': 1000}},\n        {'type': 'bernoulli', 'params_pos': {'n': 1, 'p': 0.6, 'size': 5000}, 'params_neg': {'n': 1, 'p': 0.4, 'size': 5000}},\n        {'type': 'normal', 'params_pos': {'loc': 0.2, 'scale': 1, 'size': 10}, 'params_neg': {'loc': 0, 'scale': 1, 'size': 10}},\n        {'type': 'exponential', 'params_pos': {'scale': 1.0, 'size': 2000}, 'params_neg': {'scale': 0.5, 'size': 2000}} # rate=1/scale\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        if case['type'] == 'normal':\n            pos_scores = rng.normal(**case['params_pos'])\n            neg_scores = rng.normal(**case['params_neg'])\n        elif case['type'] == 'bernoulli':\n            pos_scores = rng.binomial(**case['params_pos'])\n            neg_scores = rng.binomial(**case['params_neg'])\n        elif case['type'] == 'exponential':\n            pos_scores = rng.exponential(**case['params_pos'])\n            neg_scores = rng.exponential(**case['params_neg'])\n\n        # 1. Compute AUC using the trapezoidal rule on the empirical ROC curve\n        auc = calculate_auc(pos_scores, neg_scores)\n        \n        # 2. Compute probabilities by pairwise counting\n        p_gt, p_half = calculate_probabilities(pos_scores, neg_scores)\n        \n        # 3. Calculate absolute differences\n        delta_gt = abs(auc - p_gt)\n        delta_half = abs(auc - p_half)\n        \n        results.append(round(delta_gt, 6))\n        results.append(round(delta_half, 6))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在现实世界的生物统计学应用中，仅仅给出一个 $AUC$ 的点估计值是不够的；我们还必须量化其不确定性。最后的这项实践将介绍 bootstrap，一种强大的重采样技术，用于构建 $AUC$ 的置信区间。你将编写一个程序来执行此分析，并研究样本量等因素如何影响我们对 $AUC$ 估计的可靠性，从而掌握评估模型性能稳定性的关键技能。",
            "id": "3167079",
            "problem": "您的任务是构建一个完整、可运行的程序，用于在二元分类场景中，评估受试者工作特征（ROC）曲线下面积（AUC）的 bootstrap 置信区间的性能，并将其作为正负样本大小的函数。您必须从 ROC 曲线和 AUC 的基本定义出发，而不是使用预先推导出的简化公式。\n\n考虑一个为每个实例分配实值分数的评分模型。设正类分数为独立同分布（i.i.d.）的 $X^{+} \\sim \\mathcal{N}(\\mu_{+}, \\sigma^{2})$，负类分数为独立同分布的 $X^{-} \\sim \\mathcal{N}(\\mu_{-}, \\sigma^{2})$，其中 $\\sigma = 1$，$\\mu_{-} = 0$，且选择 $\\mu_{+}$ 使得真实 AUC 等于 $0.8$。对于具有指定正态分布和相等方差的两个独立随机变量 $X^{+}$ 和 $X^{-}$，请从受试者工作特征（ROC）曲线和 AUC（ROC 曲线下面积）的基本定义出发，推导 AUC 代表的量。利用此推导，纯粹从 ROC 的定义和观测样本的经验分布出发，设计一个 AUC 的经验估计量。\n\n您必须实现一个非参数 bootstrap 程序，以计算 AUC 在置信水平为 $0.95$ 时的双侧置信区间。具体方法是：对正类分数和负类分数分别在各自类别内进行有放回的重采样，并为每个 bootstrap 复制样本重新计算经验 AUC。使用从 bootstrap AUC 值的经验分布中构建的百分位数 bootstrap 区间。\n\n对于给定的样本大小对 $(n_{+}, n_{-})$，将覆盖概率定义为 bootstrap 置信区间包含真实 AUC 的独立模拟数据集所占的比例（以小数表示）。将 AUC 估计量的偏差定义为所有模拟数据集的平均经验 AUC 与真实 AUC 之间的差值。对于测试套件中的每个样本大小对，都必须计算覆盖率和偏差。\n\n您必须从以下基本定义出发：\n- 受试者工作特征（ROC）曲线的定义：通过改变决策阈值 $t \\in \\mathbb{R}$ 并映射到假阳性率和真阳性率而获得的参数曲线，其中假阳性率为 $FPR(t) = \\mathbb{P}(X^{-} \\ge t)$，真阳性率为 $TPR(t) = \\mathbb{P}(X^{+} \\ge t)$。\n- 曲线下面积（AUC）的定义：ROC 曲线在假阳性率轴上的勒贝格积分。\n- 由观测样本定义的经验分布以及相应的 $FPR(t)$ 和 $TPR(t)$ 的经验估计。\n\n模拟和参数规格：\n- 使用固定的随机种子 $12345$ 以确保可复现性。\n- 将目标真实 AUC 设置为 $0.8$，并选择 $\\mu_{+}$ 使得正态模型下的真实 AUC 满足 $AUC = \\Phi\\!\\left(\\dfrac{\\mu_{+} - \\mu_{-}}{\\sqrt{2}\\,\\sigma}\\right)$，其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。\n- 对每个数据集，从 $\\mathcal{N}(\\mu_{+}, 1)$ 中抽取 $n_{+}$ 个独立同分布的正类分数，从 $\\mathcal{N}(0, 1)$ 中抽取 $n_{-}$ 个独立同分布的负类分数。\n- 对每个数据集，从第一性原理（根据 ROC/AUC 定义推导）计算经验 AUC，然后使用 $B = 250$ 个 bootstrap 复制样本在置信水平 $0.95$ 下计算百分位数 bootstrap 置信区间。\n- 对于每个样本大小对，重复数据集模拟和 bootstrap 估计 $S = 250$ 次，以估计覆盖率和偏差。\n\n测试套件：\n- 四个样本大小对 $(n_{+}, n_{-})$：\n  1. $(10, 10)$\n  2. $(50, 50)$\n  3. $(10, 100)$\n  4. $(5, 50)$\n\n输出要求：\n- 对于四个测试用例中的每一个，计算覆盖率（以小数表示）和偏差（以带符号的小数表示）。将报告的每个值四舍五入到 $3$ 位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个包含两个元素 $[coverage, bias]$ 的列表。例如：$[[0.940,-0.010],[0.900,-0.015],[\\dots],[\\dots]]$。\n- 不涉及物理单位。将覆盖率和偏差表示为小数，不要使用百分号。\n\n最终答案必须是一个完整、可运行的程序，该程序遵循指定的执行环境，并精确打印所需的单行输出格式。",
            "solution": "问题陈述已经过分析，并被确定为有效。它在科学上基于成熟的统计理论，问题阐述清晰，提供了所有必要的参数和定义，并且表述客观。该问题要求对 ROC 曲线下面积（AUC）的 bootstrap 置信区间进行模拟研究，这是统计学习中一项标准且有意义的任务。\n\n### 理论基础\n\n该问题建立在一个二元分类模型之上，其中为来自正类和负类的实例分配分数。正类的分数被建模为独立同分布（i.i.d.）的随机变量 $X^{+} \\sim \\mathcal{N}(\\mu_{+}, \\sigma^{2})$，负类的分数被建模为 $X^{-} \\sim \\mathcal{N}(\\mu_{-}, \\sigma^{2})$。问题指定 $\\sigma = 1$，$\\mu_{-} = 0$，并要求选择 $\\mu_{+}$ 以使真实 AUC 为 $0.8$。\n\n**1. 确定正类的均值 $\\mu_{+}$**\n\n问题给出了两个具有相等方差的正态分布下 AUC 的计算公式：\n$$ AUC = \\Phi\\left(\\frac{\\mu_{+} - \\mu_{-}}{\\sqrt{\\sigma^2 + \\sigma^2}}\\right) = \\Phi\\left(\\frac{\\mu_{+} - \\mu_{-}}{\\sqrt{2}\\,\\sigma}\\right) $$\n其中 $\\Phi(\\cdot)$ 是标准正态分布 $\\mathcal{N}(0, 1)$ 的累积分布函数（CDF）。\n给定参数 $AUC = 0.8$，$\\mu_{-} = 0$ 和 $\\sigma = 1$，我们可以解出 $\\mu_{+}$：\n$$ 0.8 = \\Phi\\left(\\frac{\\mu_{+} - 0}{\\sqrt{2} \\cdot 1}\\right) = \\Phi\\left(\\frac{\\mu_{+}}{\\sqrt{2}}\\right) $$\n为了求出 $\\mu_{+}$，我们应用标准正态分布的逆累积分布函数，也称为分位数函数或概率单位函数，记为 $\\Phi^{-1}(\\cdot)$：\n$$ \\frac{\\mu_{+}}{\\sqrt{2}} = \\Phi^{-1}(0.8) $$\n$$ \\mu_{+} = \\sqrt{2} \\cdot \\Phi^{-1}(0.8) $$\n使用标准统计库，$\\Phi^{-1}(0.8)$ 的值约为 $0.841621$。因此，\n$$ \\mu_{+} \\approx \\sqrt{2} \\cdot 0.841621 \\approx 1.19022 $$\n\n**2. AUC 概率解释的推导**\n\n问题要求从 AUC 的基本定义（即受试者工作特征（ROC）曲线的积分）推导其含义。ROC 曲线是真阳性率（$TPR$）对假阳性率（$FPR$）的参数图，其中阈值 $t \\in \\mathbb{R}$ 不断变化。\n\n率的定义如下：\n- $FPR(t) = \\mathbb{P}(X^{-} \\ge t)$\n- $TPR(t) = \\mathbb{P}(X^{+} \\ge t)$\n\n令 $F_{-}(t) = \\mathbb{P}(X^{-}  t)$ 和 $f_{-}(t)$ 分别为 $X^{-}$ 的累积分布函数（CDF）和概率密度函数（PDF）。则 $FPR(t) = 1 - F_{-}(t)$。FPR 对阈值 $t$ 的微分为：\n$$ \\frac{d(FPR(t))}{dt} = \\frac{d(1 - F_{-}(t))}{dt} = -f_{-}(t) $$\nAUC 是 $TPR$ 在 $FPR$ 定义域（范围从 $0$ 到 $1$）上的积分。当阈值 $t$ 从 $+\\infty$ 扫到 $-\\infty$ 时，$FPR(t)$ 从 $0$ 扫到 $1$。我们可以将 AUC 表示为关于 $t$ 的积分：\n$$ AUC = \\int_{FPR=0}^{FPR=1} TPR \\, d(FPR) = \\int_{t=+\\infty}^{t=-\\infty} TPR(t) \\frac{d(FPR(t))}{dt} dt $$\n$$ AUC = \\int_{t=+\\infty}^{t=-\\infty} TPR(t) (-f_{-}(t)) dt = \\int_{t=-\\infty}^{t=+\\infty} TPR(t) f_{-}(t) dt $$\n现在，我们代入 $TPR(t)$ 的定义：\n$$ AUC = \\int_{t=-\\infty}^{t=+\\infty} \\mathbb{P}(X^{+} \\ge t) f_{-}(t) dt $$\n这个积分表示 $\\mathbb{P}(X^{+} \\ge t)$ 的期望值，其中 $t$ 是随机变量 $X^{-}$ 的一个实现。根据全期望定律，以 $X^{-} = t$ 为条件，我们有：\n$$ AUC = \\mathbb{E}_{X^{-}}[\\mathbb{P}(X^{+} \\ge X^{-} | X^{-})] $$\n由于 $X^{+}$ 和 $X^{-}$ 是独立的，$\\mathbb{P}(X^{+} \\ge X^{-} | X^{-}) = \\mathbb{P}(X^{+} \\ge X^{-})$。表达式简化为：\n$$ AUC = \\mathbb{P}(X^{+} \\ge X^{-}) $$\n由于分数是从连续分布（正态分布）中抽取的，出现平局的概率 $\\mathbb{P}(X^{+} = X^{-})$ 为零。因此，这等价于：\n$$ AUC = \\mathbb{P}(X^{+}  X^{-}) $$\n这个结果表明，AUC 正是随机抽取一个正类实例的分数高于随机抽取一个负类实例的分数的概率。\n\n### 经验估计与模拟设计\n\n**1. 经验 AUC 估计量**\n\n根据 $AUC = \\mathbb{P}(X^{+}  X^{-})$ 的推导，可以从 $n_{+}$ 个正类分数样本 $\\{x^{+}_1, \\dots, x^{+}_{n_{+}}\\}$ 和 $n_{-}$ 个负类分数样本 $\\{x^{-}_1, \\dots, x^{-}_{n_{-}}\\}$ 构建一个自然且无偏的 AUC 经验估计量。该估计量记为 $\\widehat{AUC}$，是正类分数大于负类分数的配对 $(x^{+}_i, x^{-}_j)$ 所占的比例：\n$$ \\widehat{AUC} = \\frac{1}{n_{+} n_{-}} \\sum_{i=1}^{n_{+}} \\sum_{j=1}^{n_{-}} I(x^{+}_i  x^{-}_j) $$\n其中 $I(\\cdot)$ 是指示函数。该估计量等价于 Mann-Whitney U 统计量除以样本大小的乘积 $n_{+}n_{-}$。这就是模拟中使用的估计量。\n\n**2. 模拟过程**\n\n总体目标是评估 AUC 的 bootstrap 置信区间的覆盖率和偏差。对于测试套件中给定的每个样本大小对 $(n_{+}, n_{-})$，模拟遵循以下步骤：\n\n1.  **外循环（数据集模拟）**：重复 $S=250$ 次：\n    a.  通过从 $\\mathcal{N}(\\mu_{+}, 1)$ 中抽取 $n_{+}$ 个分数和从 $\\mathcal{N}(0, 1)$ 中抽取 $n_{-}$ 个分数来生成一个合成数据集，使用先前推导的 $\\mu_{+}$ 值。\n    b.  使用成对比较公式计算该数据集的经验 AUC，即 $\\widehat{AUC}_{obs}$。存储此值以便后续计算偏差。\n    c.  **内循环（Bootstrap 重采样）**：通过重复 $B=250$ 次来执行非参数 bootstrap：\n        i.  通过从原始正类分数中进行 $n_{+}$ 次有放回抽样和从原始负类分数中进行 $n_{-}$ 次有放回抽样来创建一个 bootstrap 样本。\n        ii. 计算此 bootstrap 样本的 AUC，即 $\\widehat{AUC}_{boot}$。存储此值。\n    d.  **置信区间构建**：生成 $B$ 个 bootstrap AUC 值后，构建一个 $95\\%$ 的百分位数置信区间。这是通过找到 $B$ 个 bootstrap AUC 值的经验分布的第 $2.5$ 和第 $97.5$ 个百分位数来完成的。设区间为 $[L, U]$。\n    e.  **覆盖率检查**：检查真实 AUC（$0.8$）是否落在此区间内：$L \\le 0.8 \\le U$。如果是，则将覆盖率计数器加一。\n\n2.  **性能指标计算**：在 $S$ 次重复之后：\n    a.  **覆盖概率**：估计的覆盖率是在 $S$ 次模拟中，置信区间包含真实 AUC 的次数所占的比例。\n    $$ \\text{Coverage} = \\frac{\\text{Coverage Counter}}{S} $$\n    b.  **偏差**：估计量的偏差是 $S$ 次模拟中观测到的经验 AUC 的平均值减去真实 AUC。\n    $$ \\text{Bias} = \\left(\\frac{1}{S} \\sum_{s=1}^{S} \\widehat{AUC}_{obs, s}\\right) - AUC_{true} $$\n\n所有随机数生成都使用固定的种子值 $12345$ 以确保可复现性。每个测试用例的最终结果（覆盖率和偏差）都四舍五入到 $3$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Evaluates bootstrap confidence intervals for AUC via simulation.\n    \"\"\"\n    # --- Simulation and Parameter Specifications ---\n    RANDOM_SEED = 12345\n    TRUE_AUC = 0.8\n    MU_NEG = 0.0\n    SIGMA = 1.0\n    CONF_LEVEL = 0.95\n    B_REPLICATES = 250  # Number of bootstrap replicates\n    S_SIMULATIONS = 250  # Number of simulation runs per case\n\n    # Use a single Random Number Generator instance for reproducibility\n    rng = np.random.default_rng(RANDOM_SEED)\n\n    # --- Theoretical Calculations ---\n    # Derive mu_pos from the true AUC\n    # AUC = Phi((mu_pos - mu_neg) / sqrt(2)*sigma)\n    # mu_pos = sqrt(2)*sigma*Phi_inv(AUC) + mu_neg\n    mu_pos = np.sqrt(2) * SIGMA * norm.ppf(TRUE_AUC) + MU_NEG\n\n    # --- Test Suite ---\n    test_cases = [\n        (10, 10),\n        (50, 50),\n        (10, 100),\n        (5, 50)\n    ]\n\n    # --- Helper Function for AUC Calculation ---\n    def calculate_auc(pos_scores, neg_scores):\n        \"\"\"\n        Calculates the empirical AUC using the probabilistic definition P(X+ > X-).\n        This is equivalent to the Mann-Whitney U statistic divided by n_pos * n_neg.\n        \"\"\"\n        n_pos = len(pos_scores)\n        n_neg = len(neg_scores)\n        if n_pos == 0 or n_neg == 0:\n            return 0.5\n        \n        # Using broadcasting for efficient pairwise comparison\n        # This calculates sum(I(pos_score > neg_score)) / (n_pos * n_neg)\n        # Note: This does not handle ties, which is appropriate for continuous data\n        # as P(X+ = X-) = 0.\n        return np.mean(pos_scores[:, np.newaxis] > neg_scores)\n\n    # --- Main Simulation Loop ---\n    final_results = []\n    for n_pos, n_neg in test_cases:\n        coverage_counter = 0\n        observed_aucs = []\n\n        for _ in range(S_SIMULATIONS):\n            # 1. Generate a single dataset\n            pos_data = rng.normal(loc=mu_pos, scale=SIGMA, size=n_pos)\n            neg_data = rng.normal(loc=MU_NEG, scale=SIGMA, size=n_neg)\n\n            # 2. Compute observed AUC for this dataset\n            auc_observed = calculate_auc(pos_data, neg_data)\n            observed_aucs.append(auc_observed)\n\n            # 3. Perform bootstrap procedure\n            bootstrap_aucs = []\n            for _ in range(B_REPLICATES):\n                # Resample with replacement, separately for each class\n                pos_resampled = rng.choice(pos_data, size=n_pos, replace=True)\n                neg_resampled = rng.choice(neg_data, size=n_neg, replace=True)\n                \n                auc_boot = calculate_auc(pos_resampled, neg_resampled)\n                bootstrap_aucs.append(auc_boot)\n            \n            # 4. Construct percentile confidence interval\n            alpha = 1.0 - CONF_LEVEL\n            lower_bound = np.percentile(bootstrap_aucs, 100 * (alpha / 2))\n            upper_bound = np.percentile(bootstrap_aucs, 100 * (1 - alpha / 2))\n\n            # 5. Check for coverage\n            if lower_bound = TRUE_AUC = upper_bound:\n                coverage_counter += 1\n\n        # 6. Calculate summary metrics for the test case\n        coverage = coverage_counter / S_SIMULATIONS\n        bias = np.mean(observed_aucs) - TRUE_AUC\n\n        final_results.append([round(coverage, 3), round(bias, 3)])\n\n    # --- Final Output Formatting ---\n    # Convert list of lists to the required string format: [[c1,b1],[c2,b2],...]\n    output_str = f\"[{','.join(str(res) for res in final_results)}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}