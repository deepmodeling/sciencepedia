{
    "hands_on_practices": [
        {
            "introduction": "健康数据，尤其是来自临床观察的数据，常常包含噪音和错误。在进行任何可靠的数据分析之前，评估和清理数据是至关重要的第一步。本练习将教你如何使用基于生理学知识的规则和稳健的统计方法，系统地识别生物学上不合理的值和统计学上的离群值。",
            "id": "4856383",
            "problem": "给定您四个测试用例，每个测试用例包含一小部分结构化的临床观察数据，代表从患者就诊中收集的生命体征。每条记录包含患者的年龄（单位：年）、性别（编码为字符串“M”或“F”）、心率（单位：次/分钟，bpm）、收缩压（单位：毫米汞柱，mmHg）和体温（单位：摄氏度，°C）。所有输入测量值都必须按其指定的物理单位作为数值处理。任务是使用特定于年龄和性别的界限计算生物学不可能性率，并通过稳健 z-分数实现稳健的离群值检测。输出纯为数值且无单位；它必须遵循指定的格式。该场景设定在医学信息学领域，主题为健康数据的来源和类型，重点关注源自临床测量过程的观察性数值数据。\n\n基本原理：\n- 临床观察数据是由测量过程产生的数值测量值，该过程可能存在误差。观察值将根据随年龄和性别变化的保守参考范围来评估其生物学合理性。\n- 稳健的离群值检测使用对极值不太敏感的统计量。设 $x_1,\\dots,x_n$ 表示一个生命体征的一组观察值。定义样本中位数为 $m = \\operatorname{median}(x_1,\\dots,x_n)$，中位数绝对偏差 (MAD) 为 $\\operatorname{MAD} = \\operatorname{median}(|x_1 - m|,\\dots,|x_n - m|)$。对于一个观察值 $x_i$，其稳健 z-分数为 $z_i = \\dfrac{x_i - m}{c \\cdot \\operatorname{MAD}}$，其中 $c = 1.4826$ 是一个缩放因子，用于使 MAD 在高斯模型下成为标准差的一致估计量。一个常见的稳健阈值为 $\\tau = 3.5$，如果 $|z_i| > \\tau$，则将 $x_i$ 分类为离群值。\n\n年龄分组和包含性规则：\n- 使用以下包含性边界定义年龄组：\n  - 组 $1$：$0 \\le a \\le 1$。\n  - 组 $2$：$1  a \\le 5$。\n  - 组 $3$：$5  a \\le 12$。\n  - 组 $4$：$12  a \\le 64$。\n  - 组 $5$：$a > 64$。\n- 界限是包含性的：如果一个值位于相应年龄组和性别的下界和上界之间（含边界），则该值在生物学上是合理的。\n\n各生命体征、年龄组和性别的生物学合理范围（根据广泛使用的临床参考文献保守估算）：\n- 心率 (bpm)：\n  - 组 $1$：“M” 和 “F”：$[70, 190]$。\n  - 组 $2$：“M” 和 “F”：$[70, 150]$。\n  - 组 $3$：“M” 和 “F”：$[60, 130]$。\n  - 组 $4$：“M”：$[50, 110]$，“F”：$[55, 115]$。\n  - 组 $5$：“M”：$[50, 120]$，“F”：$[55, 125]$。\n- 收缩压 (mmHg)：\n  - 组 $1$：“M” 和 “F”：$[50, 100]$。\n  - 组 $2$：“M” 和 “F”：$[70, 110]$。\n  - 组 $3$：“M” 和 “F”：$[80, 120]$。\n  - 组 $4$：“M”：$[90, 140]$，“F”：$[90, 135]$。\n  - 组 $5$：“M”：$[100, 160]$，“F”：$[95, 155]$。\n- 体温 (°C)：\n  - 组 $1$：“M” 和 “F”：$[35.5, 38.5]$。\n  - 组 $2$：“M” 和 “F”：$[35.0, 38.2]$。\n  - 组 $3$：“M” 和 “F”：$[35.0, 38.0]$。\n  - 组 $4$：“M”：$[35.0, 37.8]$，“F”：$[35.0, 37.9]$。\n  - 组 $5$：“M” 和 “F”：$[35.0, 37.8]$。\n\n需要实现的定义：\n- 对于一个包含 $n$ 条记录的给定数据集，一个生命体征的不可能性率是分数 $\\dfrac{\\text{值超出特定年龄和性别界限的记录数}}{n}$，四舍五入到四位小数。\n- 对一个生命体征的稳健离群值检测是在数据集中的所有记录上进行的（无论其是否合理），使用上面定义的稳健 z-分数和阈值 $\\tau = 3.5$。计算满足 $|z_i|  \\tau$ 的记录数。如果 $\\operatorname{MAD} = 0$，则定义所有 $z_i = 0$，因此该生命体征的离群值为零。\n\n要求的单位和表示：\n- 年龄 $a$ 的单位是年。\n- 心率的单位是次/分钟 (bpm)。\n- 收缩压的单位是毫米汞柱 (mmHg)。\n- 体温的单位是摄氏度 (°C)。\n- 输出值为无量纲数字（比率为浮点数，计数为整数），程序必须将比率四舍五入到四位小数。\n\n测试套件：\n- 测试用例 $1$（混合了合理和不合理的值）：\n  - 记录：\n    - $(30,\\ \"M\",\\ 72,\\ 118,\\ 36.8)$。\n    - $(4,\\ \"F\",\\ 140,\\ 95,\\ 37.5)$。\n    - $(75,\\ \"F\",\\ 130,\\ 170,\\ 36.0)$。\n    - $(0.5,\\ \"M\",\\ 200,\\ 45,\\ 39.0)$。\n    - $(12,\\ \"M\",\\ 65,\\ 125,\\ 38.1)$。\n    - $(50,\\ \"F\",\\ 30,\\ 85,\\ 34.5)$。\n    - $(7,\\ \"F\",\\ 95,\\ 100,\\ 37.0)$。\n    - $(68,\\ \"M\",\\ 55,\\ 155,\\ 37.5)$。\n- 测试用例 $2$（值恰好在边界上）：\n  - 记录：\n    - $(1,\\ \"F\",\\ 70,\\ 100,\\ 38.5)$。\n    - $(5,\\ \"M\",\\ 70,\\ 110,\\ 38.2)$。\n    - $(12,\\ \"F\",\\ 60,\\ 120,\\ 38.0)$。\n    - $(64,\\ \"M\",\\ 110,\\ 140,\\ 37.8)$。\n    - $(65,\\ \"F\",\\ 125,\\ 95,\\ 37.8)$。\n    - $(0.0,\\ \"M\",\\ 190,\\ 50,\\ 35.5)$。\n- 测试用例 $3$（中位数绝对偏差等于零）：\n  - 记录：\n    - $(30,\\ \"M\",\\ 80,\\ 120,\\ 37.0)$。\n    - $(40,\\ \"F\",\\ 80,\\ 120,\\ 37.0)$。\n    - $(60,\\ \"M\",\\ 80,\\ 120,\\ 37.0)$。\n    - $(20,\\ \"F\",\\ 80,\\ 120,\\ 37.0)$。\n    - $(13,\\ \"M\",\\ 80,\\ 120,\\ 37.0)$。\n- 测试用例 $4$（所有值都不合理，测量值极端）：\n  - 记录：\n    - $(30,\\ \"M\",\\ 0,\\ 300,\\ 20.0)$。\n    - $(2,\\ \"F\",\\ 10,\\ 200,\\ 45.0)$。\n    - $(80,\\ \"M\",\\ 300,\\ 10,\\ 10.0)$。\n    - $(10,\\ \"F\",\\ 5,\\ 10,\\ 50.0)$。\n\n最终输出规范：\n- 对于每个测试用例，计算一个列表 $[r_{\\text{HR}}, r_{\\text{SBP}}, r_{\\text{TEMP}}, o_{\\text{HR}}, o_{\\text{SBP}}, o_{\\text{TEMP}}]$，其中 $r_{\\cdot}$ 是四舍五入到四位小数的不可能性率，$o_{\\cdot}$ 是整数离群值计数。\n- 您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，格式为无空格的 JSON 风格数组，例如 $[[r_1,r_2,r_3,o_1,o_2,o_3],\\dots]$。\n- 程序必须完全独立，无需外部输入，并遵守所提供的界限和定义。",
            "solution": "该问题要求为结构化的临床观察数据实现两种不同的数据质量评估算法：生物学合理性检查和稳健的离群值检测。解决方案涉及处理一组给定的测试用例，每个用例包含患者生命体征的记录，并计算指定的指标。\n\n**问题形式化与数据结构**\n每个患者记录是一个包含五个字段的元组：年龄（$a$，单位：年）、性别（$s$，编码为“M”或“F”）、心率（$HR$，单位：bpm）、收缩压（$SBP$，单位：mmHg）和体温（$TEMP$，单位：°C）。问题的核心在于根据这些输入定义和应用规则。\n\n生物学合理性范围以结构化方式提供，取决于年龄和性别。存储这些范围的合适数据结构是一个嵌套字典，将生命体征键映射到另一个字典，该字典将年龄组映射到特定性别的下界和上界。例如，`bounds[vital][age_bin][sex]` 将返回一个对 `(lower, upper)`。\n\n**1. 生物学合理性评估**\n\n该模块检查观察到的生命体征测量值是否落在生物学上可信的范围内。这些范围取决于患者的年龄和性别。\n\n**1.1. 年龄分组**\n首先将患者年龄（$a$）归入五个互斥的组别之一，这些组别由包含性边界定义：\n- 组 1：$0 \\le a \\le 1$\n- 组 2：$1  a \\le 5$\n- 组 3：$5  a \\le 12$\n- 组 4：$12  a \\le 64$\n- 组 5：$a > 64$\n\n一个输入年龄将被分配到它满足条件的第一个组别。\n\n**1.2. 合理性检查**\n对于每条记录 $(a, s, HR, SBP, TEMP)$，我们确定相应的年龄组。利用这个组别和性别 $s$，我们检索每个生命体征的下界（$L$）和上界（$U$）。如果一个测量值 $x$ 满足 $L \\le x \\le U$，则认为它在生物学上是合理的。如果 $x  L$ 或 $x > U$，则标记为不合理。\n\n**1.3. 不可能性率计算**\n对于一个包含 $n$ 条记录的给定数据集和每个生命体征，不可能性率 $r$ 是包含该生命体征不合理值的记录所占的比例。\n$$\nr = \\frac{\\text{不合理记录的数量}}{\\text{记录总数 } n}\n$$\n该比率必须四舍五入到四位小数。例如，值 $0.375$ 将表示为 $0.3750$。\n\n**2. 稳健的离群值检测**\n\n该模块使用一种能够抵抗离群值自身影响的方法，来识别相对于数据其余部分在统计上极端的观察值。分析是在一个测试用例中所有记录的每个生命体征的完整测量值集合 $\\{x_1, \\dots, x_n\\}$ 上进行的。\n\n**2.1. 稳健 Z-分数**\n此方法的核心是每个观察值 $x_i$ 的稳健 z-分数 $z_i$：\n$$\nz_i = \\frac{x_i - m}{c \\cdot \\text{MAD}}\n$$\n其中：\n- $m = \\operatorname{median}(x_1, \\dots, x_n)$ 是观察值的样本中位数。\n- $\\text{MAD} = \\operatorname{median}(|x_1 - m|, \\dots, |x_n - m|)$ 是中位数绝对偏差，即每个观察值与样本中位数 $m$ 之间绝对差值的中位数。\n- $c = 1.4826$ 是一个缩放常数。该常数使 MAD 成为正态分布标准差的一致估计量。它源自标准正态累积分布函数的反函数，具体为 $c = 1 / \\Phi^{-1}(0.75)$。\n\n**2.2. 离群值识别**\n如果一个观察值 $x_i$ 的稳健 z-分数的绝对值超过指定的阈值 $\\tau = 3.5$，则将其分类为稳健离群值。\n$$\n|z_i| > 3.5 \\implies x_i \\text{ 是一个离群值}\n$$\n离群值的总数 $o$ 是针对给定生命体征满足此条件的观察值计数。\n\n针对 $\\text{MAD} = 0$ 的情况定义了一个特殊条件。如果至少一半的数据点与中位数相同，就会发生这种情况。在这种情况下，所有稳健 z-分数 $z_i$ 都被定义为 $0$，从而导致离群值计数 $o=0$。\n\n**3. 算法实现**\n\n对于每个测试用例，总体算法按以下步骤进行：\n1. 将 $HR$、$SBP$ 和 $TEMP$ 的不可能性计数器初始化为 $0$。提取每个生命体征的完整值列表。设 $n$ 为记录数。\n2. 遍历每条记录 $(a, s, HR_{val}, SBP_{val}, TEMP_{val})$：\n    a. 确定年龄 $a$ 所属的年龄组。\n    b. 根据年龄组和性别 $s$ 检索每个生命体征的合理性界限 $(L, U)$。\n    c. 对于每个生命体征，检查其值是否在 $[L, U]$ 之外。如果是，则增加相应的不可能性计数器。\n3. 通过将计数器除以 $n$ 并四舍五入到四位小数来计算不可能性率 $r_{HR}$、$r_{SBP}$、$r_{TEMP}$。\n4. 对于每个生命体征的值列表（例如，所有 $HR$ 值）：\n    a. 计算中位数 $m$ 和 MAD。\n    b. 如果 $\\text{MAD} = 0$，则离群值计数 $o$ 为 $0$。\n    c. 否则，为每个值 $x_i$ 计算稳健 z-分数 $z_i$，并计算满足 $|z_i|  3.5$ 的数量。此计数即为 $o$。\n5. 组装该测试用例的最终列表：$[r_{HR}, r_{SBP}, r_{TEMP}, o_{HR}, o_{SBP}, o_{TEMP}]$。\n6. 处理完所有测试用例后，将收集到的结果格式化为单个无空格的 JSON 风格数组字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by processing clinical data test cases for biological\n    implausibility and robust outlier detection.\n    \"\"\"\n\n    # Define biological plausibility bounds: vital - age_bin - sex - (lower, upper)\n    bounds = {\n        \"HR\": {\n            1: {\"M\": (70, 190), \"F\": (70, 190)},\n            2: {\"M\": (70, 150), \"F\": (70, 150)},\n            3: {\"M\": (60, 130), \"F\": (60, 130)},\n            4: {\"M\": (50, 110), \"F\": (55, 115)},\n            5: {\"M\": (50, 120), \"F\": (55, 125)},\n        },\n        \"SBP\": {\n            1: {\"M\": (50, 100), \"F\": (50, 100)},\n            2: {\"M\": (70, 110), \"F\": (70, 110)},\n            3: {\"M\": (80, 120), \"F\": (80, 120)},\n            4: {\"M\": (90, 140), \"F\": (90, 135)},\n            5: {\"M\": (100, 160), \"F\": (95, 155)},\n        },\n        \"TEMP\": {\n            1: {\"M\": (35.5, 38.5), \"F\": (35.5, 38.5)},\n            2: {\"M\": (35.0, 38.2), \"F\": (35.0, 38.2)},\n            3: {\"M\": (35.0, 38.0), \"F\": (35.0, 38.0)},\n            4: {\"M\": (35.0, 37.8), \"F\": (35.0, 37.9)},\n            5: {\"M\": (35.0, 37.8), \"F\": (35.0, 37.8)},\n        }\n    }\n\n    test_cases = [\n        # Test Case 1\n        [\n            (30, \"M\", 72, 118, 36.8), (4, \"F\", 140, 95, 37.5),\n            (75, \"F\", 130, 170, 36.0), (0.5, \"M\", 200, 45, 39.0),\n            (12, \"M\", 65, 125, 38.1), (50, \"F\", 30, 85, 34.5),\n            (7, \"F\", 95, 100, 37.0), (68, \"M\", 55, 155, 37.5)\n        ],\n        # Test Case 2\n        [\n            (1, \"F\", 70, 100, 38.5), (5, \"M\", 70, 110, 38.2),\n            (12, \"F\", 60, 120, 38.0), (64, \"M\", 110, 140, 37.8),\n            (65, \"F\", 125, 95, 37.8), (0.0, \"M\", 190, 50, 35.5)\n        ],\n        # Test Case 3\n        [\n            (30, \"M\", 80, 120, 37.0), (40, \"F\", 80, 120, 37.0),\n            (60, \"M\", 80, 120, 37.0), (20, \"F\", 80, 120, 37.0),\n            (13, \"M\", 80, 120, 37.0)\n        ],\n        # Test Case 4\n        [\n            (30, \"M\", 0, 300, 20.0), (2, \"F\", 10, 200, 45.0),\n            (80, \"M\", 300, 10, 10.0), (10, \"F\", 5, 10, 50.0)\n        ]\n    ]\n\n    def get_age_bin(age):\n        if age = 1: return 1\n        elif age = 5: return 2\n        elif age = 12: return 3\n        elif age = 64: return 4\n        return 5\n\n    def calculate_outliers(data, c=1.4826, tau=3.5):\n        data_arr = np.array(data)\n        median_val = np.median(data_arr)\n        abs_devs = np.abs(data_arr - median_val)\n        mad = np.median(abs_devs)\n\n        if mad == 0:\n            return 0\n        \n        robust_z_scores = abs_devs / (c * mad)\n        outlier_count = np.sum(robust_z_scores > tau)\n        return int(outlier_count)\n\n    all_results = []\n    for case_data in test_cases:\n        n = len(case_data)\n        \n        implausibility_counts = {\"HR\": 0, \"SBP\": 0, \"TEMP\": 0}\n        \n        all_hr = []\n        all_sbp = []\n        all_temp = []\n\n        for record in case_data:\n            age, sex, hr_val, sbp_val, temp_val = record\n            all_hr.append(hr_val)\n            all_sbp.append(sbp_val)\n            all_temp.append(temp_val)\n\n            age_bin = get_age_bin(age)\n            \n            hr_bounds = bounds[\"HR\"][age_bin][sex]\n            if not (hr_bounds[0] = hr_val = hr_bounds[1]):\n                implausibility_counts[\"HR\"] += 1\n\n            sbp_bounds = bounds[\"SBP\"][age_bin][sex]\n            if not (sbp_bounds[0] = sbp_val = sbp_bounds[1]):\n                implausibility_counts[\"SBP\"] += 1\n            \n            temp_bounds = bounds[\"TEMP\"][age_bin][sex]\n            if not (temp_bounds[0] = temp_val = temp_bounds[1]):\n                implausibility_counts[\"TEMP\"] += 1\n\n        r_hr = round(implausibility_counts[\"HR\"] / n, 4) if n > 0 else 0\n        r_sbp = round(implausibility_counts[\"SBP\"] / n, 4) if n > 0 else 0\n        r_temp = round(implausibility_counts[\"TEMP\"] / n, 4) if n > 0 else 0\n\n        o_hr = calculate_outliers(all_hr)\n        o_sbp = calculate_outliers(all_sbp)\n        o_temp = calculate_outliers(all_temp)\n\n        all_results.append([r_hr, r_sbp, r_temp, o_hr, o_sbp, o_temp])\n\n    # Format the final output string as a JSON-style array with no spaces\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "原始的电子健康记录（EHR）数据通常由离散的测量值组成，为了解患者的临床过程，我们需要将这些原始数据转化为有意义的纵向表征。本练习将指导你处理结构化的EHR数据，构建患者血压的时间变化轨迹，这涉及到单位归一化、数据聚合和应用临床公式等基本技能。",
            "id": "4856328",
            "problem": "给定一个电子健康记录 (EHR) 数据的简化关系视图，这是医学信息学中结构化健康数据的典型示例。该数据由三个表组成，代表不同来源和类型的健康数据：就诊记录 (encounters, 行政/就诊记录)、观察项 (observations, 生命体征和测量值) 和用药记录 (medications, 医嘱)。您的任务是编写一个程序，通过转换和聚合观察项，计算患者的时变血压轨迹，将其转化为临床上有意义的标量时间序列，并严格遵守单位归一化和处理每次就诊多次测量的既定策略。\n\n基本基础。使用以下基本定义和经过充分检验的事实作为您推导和算法设计的基础：\n- 结构化 EHR 数据代表离散的、编码的字段，如生命体征测量值和时间戳；这些是源于临床就诊的核心健康数据类型。\n- 血压通常记录为收缩压 ($SBP$) 和舒张压 ($DBP$)。脉压定义为 $PP = SBP - DBP$。\n- 平均动脉压 (MAP) 是一种广泛使用的动脉压标量摘要，可通过 $MAP = DBP + \\frac{1}{3} \\cdot (SBP - DBP)$ 近似计算。该公式是经过充分检验的临床近似值。\n- 不同来源的单位可能有所不同；对于血压，常见的单位转换是 $1 \\mathrm{kPa} = 7.500616 \\mathrm{mmHg}$，这是一种线性变换。\n\n模式。请考虑以下简化模式：\n- Encounters 表，其行格式为 $(enc\\_id, patient\\_id, start\\_time)$，其中 $start\\_time$ 是以秒为单位的整数 Unix 纪元时间。\n- Observations 表，其行格式为 $(enc\\_id, patient\\_id, concept, value, unit, obs\\_time)$，其中 $concept \\in \\{\\text{\"SBP\"}, \\text{\"DBP\"}\\}$，$value$ 是数值，$unit \\in \\{\\text{\"mmHg\"}, \\text{\"kPa\"}\\}$，$obs\\_time$ 是以秒为单位的整数 Unix 纪元时间。\n- Medications 表，其行格式为 $(enc\\_id, patient\\_id, med\\_code, dose, dose\\_unit)$；包含用药记录是为了反映多个数据源，但在计算中不使用。\n\n必需的计算和策略。\n1. 单位归一化。将所有观察值转换为 $\\mathrm{mmHg}$。如果 $unit = \\text{\"kPa\"}$，则计算 $value\\_{\\mathrm{mmHg}} = value\\_{\\mathrm{kPa}} \\times c$，其中 $c = 7.500616$。如果 $unit = \\text{\"mmHg\"}$，则保持原值不变。\n2. 每次就诊的多次测量。对于每次就诊，通过中位数聚合所有归一化的 $SBP$ 值，以获得每次就诊的 $SBP$ 摘要；同样，通过中位数聚合所有归一化的 $DBP$ 值，以获得每次就诊的 $DBP$ 摘要。如果某次就诊缺少 $SBP$ 或 $DBP$ 中任何一个，则将该次就诊从轨迹中排除，因为无法计算 $MAP$。\n3. 轨迹定义。对于每次同时具有 $SBP$ 和 $DBP$ 的就诊，计算 $MAP = DBP + \\frac{1}{3}(SBP - DBP)$（单位为 $\\mathrm{mmHg}$），并将结果四舍五入到 $2$ 位小数。轨迹是这些 $MAP$ 值的列表，按时间排序。\n4. 时间排序。按 $start\\_time$ 升序对患者的就诊进行排序。如果出现平局（$start\\_time$ 相同），则按 $enc\\_id$ 的字典升序来打破平局。\n5. 最终输出。对于下面的每个测试用例，将患者的 $MAP$ 轨迹输出为一个浮点数列表（单位为 $\\mathrm{mmHg}$，四舍五入到 $2$ 位小数）。程序应生成单行输出，其中包含一个由这些列表组成的列表，并用方括号括起来（例如，$[\\,[x\\_1,x\\_2],\\,[y\\_1]\\,]$）。不应打印任何其他文本。\n\n角度单位不适用。如果遇到百分比，请将其表示为小数，但本问题不要求处理百分比。\n\n测试套件。您的程序必须为以下四个测试用例计算结果，每个测试用例都明确指定了表的行。所有时间均为以秒为单位的整数 Unix 纪元，所有血压输出必须以 $\\mathrm{mmHg}$ 为单位并四舍五入到 $2$ 位小数。\n\n- 测试用例 $1$（正常路径，单位为 $\\mathrm{mmHg}$ 的多次测量）：\n  - Encounters:\n    - $(\"e1\",\"P1\",1000)$\n    - $(\"e2\",\"P1\",2000)$\n  - Observations:\n    - $(\"e1\",\"P1\",\"SBP\",120.0,\"mmHg\",1001)$\n    - $(\"e1\",\"P1\",\"SBP\",124.0,\"mmHg\",1002)$\n    - $(\"e1\",\"P1\",\"DBP\",80.0,\"mmHg\",1001)$\n    - $(\"e1\",\"P1\",\"DBP\",78.0,\"mmHg\",1003)$\n    - $(\"e2\",\"P1\",\"SBP\",130.0,\"mmHg\",2002)$\n    - $(\"e2\",\"P1\",\"SBP\",128.0,\"mmHg\",2003)$\n    - $(\"e2\",\"P1\",\"DBP\",85.0,\"mmHg\",2001)$\n  - Medications: 可能非空，但在计算中被忽略。\n  - 预期行为：每次就诊的中位数产生有效的 $MAP$ 值，并按 $start\\_time$ 排序。\n\n- 测试用例 $2$（混合单位 $\\mathrm{kPa}$ 和 $\\mathrm{mmHg}$，排序敏感性）：\n  - Encounters:\n    - $(\"f2\",\"P2\",1400)$\n    - $(\"f1\",\"P2\",1500)$\n  - Observations:\n    - $(\"f1\",\"P2\",\"SBP\",16.0,\"kPa\",1502)$\n    - $(\"f1\",\"P2\",\"DBP\",10.5,\"kPa\",1501)$\n    - $(\"f2\",\"P2\",\"SBP\",125.0,\"mmHg\",1404)$\n    - $(\"f2\",\"P2\",\"DBP\",82.0,\"mmHg\",1401)$\n  - Medications: 任意行；在计算中被忽略。\n\n- 测试用例 $3$（边界情况：一次就诊中缺少舒张压）：\n  - Encounters:\n    - $(\"g1\",\"P3\",3000)$\n    - $(\"g2\",\"P3\",3100)$\n  - Observations:\n    - $(\"g1\",\"P3\",\"SBP\",110.0,\"mmHg\",3001)$\n    - $(\"g2\",\"P3\",\"SBP\",118.0,\"mmHg\",3103)$\n    - $(\"g2\",\"P3\",\"DBP\",76.0,\"mmHg\",3101)$\n    - $(\"g2\",\"P3\",\"DBP\",78.0,\"mmHg\",3102)$\n  - Medications: 任意行；在计算中被忽略。\n\n- 测试用例 $4$（边界条件：多次就诊的 $start\\_time$ 相同，仅使用 $\\mathrm{kPa}$，中位数的奇数和偶数计数）：\n  - Encounters:\n    - $(\"h1\",\"P4\",5000)$\n    - $(\"h2\",\"P4\",5000)$\n  - Observations:\n    - $(\"h1\",\"P4\",\"SBP\",18.0,\"kPa\",5001)$\n    - $(\"h1\",\"P4\",\"SBP\",17.0,\"kPa\",5002)$\n    - $(\"h1\",\"P4\",\"SBP\",19.0,\"kPa\",5003)$\n    - $(\"h1\",\"P4\",\"DBP\",12.0,\"kPa\",5001)$\n    - $(\"h1\",\"P4\",\"DBP\",13.0,\"kPa\",5002)$\n    - $(\"h2\",\"P4\",\"SBP\",17.0,\"kPa\",5004)$\n    - $(\"h2\",\"P4\",\"DBP\",11.0,\"kPa\",5004)$\n  - Medications: 任意行；在计算中被忽略。\n  - 打破平局：$enc\\_id$ 的字典序将 $\"h1\"$ 排在 $\"h2\"$ 之前。\n\n您的程序必须精确实现上述逻辑，并生成单行输出，该行包含一个包含 $4$ 个元素的列表，每个元素都是为相应测试用例计算出的 $MAP$ 值列表（单位为 $\\mathrm{mmHg}$，四舍五入到 $2$ 位小数），并按所述策略排序。",
            "solution": "该问题陈述已经过验证，被认为是科学上合理、定义明确且完整的。所有必要的数据、公式和处理策略都已提供，以构建一个唯一且可验证的解决方案。\n\n任务是从结构化的电子健康记录 (EHR) 数据中计算患者的时变血压轨迹。这涉及多个数据转换、聚合和计算步骤，并遵循指定的临床和数据处理策略。该过程从原始观察项开始，最终生成一个按时间排序的平均动脉压 ($MAP$) 值序列。\n\n算法流程如下：\n\n1.  **数据结构化与分组：** 初始步骤是组织原始观察项。`Observations` 表提供了一个扁平的测量值列表。为了进行每次就诊的计算，逻辑上应首先按相关的就诊标识符 `enc_id` 对这些观察项进行分组。字典是实现此目的的合适数据结构，其中每个键是 `enc_id`，值是另一个包含该次就诊的收缩压 ($SBP$) 和舒张压 ($DBP$) 测量值列表的结构。\n\n2.  **单位归一化：** 问题陈述指出，血压值可以有两种单位之一：毫米汞柱 ($\\mathrm{mmHg}$) 或千帕 ($\\mathrm{kPa}$)。为确保后续计算的一致性，所有测量值必须转换为单一标准单位，即指定的 $\\mathrm{mmHg}$。给定的转换因子是 $1 \\mathrm{kPa} = 7.500616 \\mathrm{mmHg}$。对每个观察项，我们应用此线性变换：\n    $$\n    \\text{value}_{\\mathrm{mmHg}} = \n    \\begin{cases} \n    \\text{value}   \\text{if unit} = \\text{\"mmHg\"} \\\\\n    \\text{value} \\times 7.500616  \\text{if unit} = \\text{\"kPa\"}\n    \\end{cases}\n    $$\n    在数据录入和分组时执行此归一化，以确保后续步骤中使用的所有值都以 $\\mathrm{mmHg}$ 为单位。\n\n3.  **每次就诊的聚合与筛选：** 临床就诊可能包含多次血压测量。策略 #2 规定，对于每次就诊，应将这些多次测量值聚合成一个代表性的 $SBP$ 值和一个代表性的 $DBP$ 值。指定的聚合函数是中位数。对于每次就诊 $i$，我们计算汇总统计量：\n    $$\n    SBP_{\\text{summary}, i} = \\mathrm{median}(\\{ SBP_{i,1}, SBP_{i,2}, \\dots \\})\n    $$\n    $$\n    DBP_{\\text{summary}, i} = \\mathrm{median}(\\{ DBP_{i,1}, DBP_{i,2}, \\dots \\})\n    $$\n    一个关键规则是，如果一次就诊不同时拥有至少一次 $SBP$ 测量和至少一次 $DBP$ 测量，则该次就诊对于 $MAP$ 计算无效，必须从最终轨迹中排除。\n\n4.  **平均动脉压 (MAP) 计算：** 对于每个有效的就诊（即同时具有 $SBP$ 和 $DBP$ 汇总值的就诊），我们计算 $MAP$。问题提供了标准的临床近似公式：\n    $$\n    MAP = DBP_{\\text{summary}} + \\frac{1}{3} (SBP_{\\text{summary}} - DBP_{\\text{summary}})\n    $$\n    此公式也可以写作 $MAP = \\frac{1}{3} SBP_{\\text{summary}} + \\frac{2}{3} DBP_{\\text{summary}}$。此计算的结果以 $\\mathrm{mmHg}$ 为单位，并必须根据策略 #3 四舍五入到 $2$ 位小数。\n\n5.  **时间轨迹排序：** 计算出的 $MAP$ 值集合构成了患者的轨迹，但必须按时间顺序排列。策略 #4 指定了一个两级排序过程。主排序键是就诊的 `start_time`，按升序排列。在出现平局的情况下，即两次或多次就诊具有相同的 `start_time`，则通过按 `enc_id` 的字典升序来打破平局。这个复合键确保了最终轨迹的确定性和唯一排序。为实现这一点，我们为所有有效就诊创建一个元组列表，每个元组包含排序键和计算出的 $MAP$ 值，例如 `(start_time, enc_id, MAP_value)`。对此列表进行排序后，我们提取 `MAP_value` 部分以形成最终的有序列表。\n\n通过对每个测试用例执行这些步骤，我们可以生成所需的输出，即一个包含每个患者计算出的轨迹的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    \n    # Conversion constant from kPa to mmHg\n    KPA_TO_MMHG = 7.500616\n\n    # Test suite as defined in the problem statement\n    test_cases = [\n        # Test case 1\n        (\n            [(\"e1\", \"P1\", 1000), (\"e2\", \"P1\", 2000)],\n            [\n                (\"e1\", \"P1\", \"SBP\", 120.0, \"mmHg\", 1001),\n                (\"e1\", \"P1\", \"SBP\", 124.0, \"mmHg\", 1002),\n                (\"e1\", \"P1\", \"DBP\", 80.0, \"mmHg\", 1001),\n                (\"e1\", \"P1\", \"DBP\", 78.0, \"mmHg\", 1003),\n                (\"e2\", \"P1\", \"SBP\", 130.0, \"mmHg\", 2002),\n                (\"e2\", \"P1\", \"SBP\", 128.0, \"mmHg\", 2003),\n                (\"e2\", \"P1\", \"DBP\", 85.0, \"mmHg\", 2001),\n            ]\n        ),\n        # Test case 2\n        (\n            [(\"f2\", \"P2\", 1400), (\"f1\", \"P2\", 1500)],\n            [\n                (\"f1\", \"P2\", \"SBP\", 16.0, \"kPa\", 1502),\n                (\"f1\", \"P2\", \"DBP\", 10.5, \"kPa\", 1501),\n                (\"f2\", \"P2\", \"SBP\", 125.0, \"mmHg\", 1404),\n                (\"f2\", \"P2\", \"DBP\", 82.0, \"mmHg\", 1401),\n            ]\n        ),\n        # Test case 3\n        (\n            [(\"g1\", \"P3\", 3000), (\"g2\", \"P3\", 3100)],\n            [\n                (\"g1\", \"P3\", \"SBP\", 110.0, \"mmHg\", 3001),\n                (\"g2\", \"P3\", \"SBP\", 118.0, \"mmHg\", 3103),\n                (\"g2\", \"P3\", \"DBP\", 76.0, \"mmHg\", 3101),\n                (\"g2\", \"P3\", \"DBP\", 78.0, \"mmHg\", 3102),\n            ]\n        ),\n        # Test case 4\n        (\n            [(\"h1\", \"P4\", 5000), (\"h2\", \"P4\", 5000)],\n            [\n                (\"h1\", \"P4\", \"SBP\", 18.0, \"kPa\", 5001),\n                (\"h1\", \"P4\", \"SBP\", 17.0, \"kPa\", 5002),\n                (\"h1\", \"P4\", \"SBP\", 19.0, \"kPa\", 5003),\n                (\"h1\", \"P4\", \"DBP\", 12.0, \"kPa\", 5001),\n                (\"h1\", \"P4\", \"DBP\", 13.0, \"kPa\", 5002),\n                (\"h2\", \"P4\", \"SBP\", 17.0, \"kPa\", 5004),\n                (\"h2\", \"P4\", \"DBP\", 11.0, \"kPa\", 5004),\n            ]\n        )\n    ]\n\n    def process_case(encounters, observations):\n        \"\"\"\n        Processes a single test case to compute the MAP trajectory.\n        \"\"\"\n        \n        # 1. Structure data: map enc_id to start_time and group observations by enc_id\n        enc_info = {enc_id: start_time for enc_id, _, start_time in encounters}\n        \n        obs_by_enc = {}\n        for enc_id, _, concept, value, unit, _ in observations:\n            if enc_id not in obs_by_enc:\n                obs_by_enc[enc_id] = {\"SBP\": [], \"DBP\": []}\n            \n            # 2. Unit normalization to mmHg\n            normalized_value = value\n            if unit == \"kPa\":\n                normalized_value *= KPA_TO_MMHG\n            \n            if concept in obs_by_enc[enc_id]:\n                obs_by_enc[enc_id][concept].append(normalized_value)\n\n        results_to_sort = []\n        for enc_id, pressures in obs_by_enc.items():\n            sbp_values = pressures[\"SBP\"]\n            dbp_values = pressures[\"DBP\"]\n\n            # 3. Filter encounters without both SBP and DBP\n            if not sbp_values or not dbp_values:\n                continue\n\n            # 3. Per-encounter aggregation using median\n            sbp_median = np.median(sbp_values)\n            dbp_median = np.median(dbp_values)\n\n            # 4. MAP Calculation\n            map_val = dbp_median + (sbp_median - dbp_median) / 3.0\n            \n            rounded_map = round(map_val, 2)\n\n            start_time = enc_info[enc_id]\n            results_to_sort.append((start_time, enc_id, rounded_map))\n        \n        # 5. Temporal Ordering\n        # Sort by start_time (primary) and enc_id (secondary)\n        results_to_sort.sort(key=lambda x: (x[0], x[1]))\n        \n        # Extract the sorted MAP values to form the trajectory\n        trajectory = [item[2] for item in results_to_sort]\n        \n        return trajectory\n\n    # Process all test cases\n    final_results = [process_case(enc, obs) for enc, obs in test_cases]\n    \n    # 6. Format final output string as per specifications\n    # e.g., [[93.33,99.67],[96.33,92.51],...]\n    results_as_strings = []\n    for trajectory in final_results:\n        trajectory_str = f\"[{','.join(map(str, trajectory))}]\"\n        results_as_strings.append(trajectory_str)\n        \n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "识别具有特定疾病的患者队列（即“计算表型”）是临床研究和医疗运营的基石，这通常需要整合诊断、药物和实验室结果等多种数据源。在这个综合性练习中，你将构建并评估多种表型算法，学习如何结合不同类型的数据，并使用灵敏度、阳性预测值和 F-score 等指标来量化算法的性能。",
            "id": "4856368",
            "problem": "您将获得一个小型、合成的电子健康记录 (EHR) 数据集，该数据集由医学信息学中使用的标准来源和类型的健康数据构建而成：国际疾病分类 (ICD) 诊断代码、抗糖尿病药物处方以及实验室测量值（空腹血糖和糖化血红蛋白 A1c）。您的任务是为 $2$ 型糖尿病实现四种可计算的表型分析算法，并根据病历审查金标准评估每种算法的灵敏度和阳性预测值 (PPV)，然后计算 F-score 以支持算法选择。所有计算必须使用集合成员关系、事件计数和阈值比较，以纯数学和逻辑术语表示。\n\n使用的基本原理：\n- 基于频率概率的混淆矩阵定义：灵敏度和阳性预测值 (PPV)。灵敏度即召回率，PPV 即精确率。F-score 是精确率和召回率的调和平均数。\n- 适用于计算的标准 $2$ 型糖尿病临床实验室阈值：糖化血红蛋白 A1c 阈值 $t_{\\text{A1c}} = 0.065$（A1c 以小数形式表示，不带百分号），以及空腹血糖阈值 $t_{\\text{FPG}} = 126$ mg/dL。\n\n核心定义：\n- 灵敏度（召回率）$S = \\dfrac{\\text{TP}}{\\text{TP} + \\text{FN}}$，其中 $\\text{TP}$ 是真阳性，$\\text{FN}$ 是假阴性。\n- 阳性预测值（PPV，精确率）$P = \\dfrac{\\text{TP}}{\\text{TP} + \\text{FP}}$，其中 $\\text{FP}$ 是假阳性。\n- F-score $F = \\dfrac{2 \\cdot P \\cdot S}{P + S}$，当 $P + S > 0$ 时，否则 $F = 0$。\n- 边界情况约定：如果 $\\text{TP} + \\text{FN} = 0$，则设灵敏度 $S = 0$。如果 $\\text{TP} + \\text{FP} = 0$，则设 PPV $P = 0$。\n\n数据模型和来源类型：\n- 诊断事件：一个由配对 $(c_i, d_i)$ 组成的列表，其中 $c_i$ 是一个 ICD 代码，$d_i$ 是一个日期索引（整数）。$2$ 型糖尿病代码列表为 $\\mathcal{C}_{\\text{T2D}} = \\{\\text{\"E11\"}, \\text{\"E11.9\"}, \\text{\"250.00\"}\\}$。\n- 用药事件：一个由配对 $(m_j, d_j)$ 组成的列表，其中 $m_j$ 是一个药物代码，$d_j$ 是一个日期索引。抗糖尿病药物列表为 $\\mathcal{M}_{\\text{T2D}} = \\{\\text{\"MET\"}, \\text{\"SULF\"}, \\text{\"INS\"}, \\text{\"GLP1\"}\\}$。\n- 实验室测量值：两个列表，A1c 值以配对 $(a_k, d_k)$ 的形式给出，其中 $a_k$ 为小数形式；空腹血糖值以配对 $(g_\\ell, d_\\ell)$ 的形式给出，其中 $g_\\ell$ 单位为 mg/dL。\n- 病历审查金标准：每个患者的布尔标签 $y \\in \\{0,1\\}$，表示是否存在 ($1$) 或不存在 ($0$) $2$ 型糖尿病。\n\n要实现的表型分析算法：\n- 算法 $\\mathcal{A}$ (包容性)：如果满足以下任一条件，则预测为阳性：\n  1. 至少有一个诊断事件的 $c_i \\in \\mathcal{C}_{\\text{T2D}}$。\n  2. 在 $180$ 天内至少有两个抗糖尿病药物事件：存在 $(m_{j_1}, d_{j_1})$ 和 $(m_{j_2}, d_{j_2})$ 满足 $m_{j_1}, m_{j_2} \\in \\mathcal{M}_{\\text{T2D}}$ 且 $|d_{j_2} - d_{j_1}| \\le 180$。\n  3. 任何 A1c 值 $a_k$ 满足 $a_k \\ge t_{\\text{A1c}}$。\n  4. 在不同日期至少有两个空腹血糖值 $g_{\\ell}$ 满足 $g_{\\ell} \\ge t_{\\text{FPG}}$。\n- 算法 $\\mathcal{B}$ (特异性)：如果满足以下任一条件，则预测为阳性：\n  1. 在不同日期至少有两个诊断事件的 $c_i \\in \\mathcal{C}_{\\text{T2D}}$。\n  2. 至少有一个抗糖尿病药物事件 ($m_j \\in \\mathcal{M}_{\\text{T2D}}$) 并且至少有一个实验室标准为阳性：$(\\exists k: a_k \\ge t_{\\text{A1c}})$ 或 $(\\exists \\ell: g_{\\ell} \\ge t_{\\text{FPG}})$。\n  3. 两种实验室类型均为阳性：$(\\exists k: a_k \\ge t_{\\text{A1c}})$ 且 $(\\exists \\ell: g_{\\ell} \\ge t_{\\text{FPG}})$。\n- 算法 $\\mathcal{C}$ (最小化)：如果存在任何单一信号，则预测为阳性：\n  1. 至少有一个诊断事件的 $c_i \\in \\mathcal{C}_{\\text{T2D}}$。\n  2. 至少有一个抗糖尿病药物事件的 $m_j \\in \\mathcal{M}_{\\text{T2D}}$。\n  3. $(\\exists k: a_k \\ge t_{\\text{A1c}})$。\n  4. $(\\exists \\ell: g_{\\ell} \\ge t_{\\text{FPG}})$。\n- 算法 $\\mathcal{D}$ (严格合取)：仅当以下所有条件同时满足时，才预测为阳性：\n  1. 在不同日期至少有两个诊断事件的 $c_i \\in \\mathcal{C}_{\\text{T2D}}$。\n  2. 在 $180$ 天内至少有两个抗糖尿病药物事件。\n  3. $(\\exists k: a_k \\ge t_{\\text{A1c}})$。\n  4. 在不同日期至少有两个空腹血糖值 $g_{\\ell}$ 满足 $g_{\\ell} \\ge t_{\\text{FPG}}$。\n\n测试套件 (患者 1 至 12)：\n对于每位患者，数据以事件和标签集的形式给出。所有日期索引均为整数；所有 A1c 值均为小数形式；空腹血糖值单位为 mg/dL。\n\n- 患者 $1$, $y=1$:\n  - 诊断: $(\\text{\"E11\"}, 10)$, $(\\text{\"E11.9\"}, 80)$.\n  - 用药: $(\\text{\"MET\"}, 15)$.\n  - A1c: $(0.072, 12)$.\n  - FPG: $(145, 11)$, $(150, 85)$.\n- 患者 $2$, $y=1$:\n  - 诊断: 无。\n  - 用药: $(\\text{\"MET\"}, 5)$, $(\\text{\"MET\"}, 100)$.\n  - A1c: $(0.062, 30)$.\n  - FPG: $(130, 35)$.\n- 患者 $3$, $y=0$:\n  - 诊断: 无。\n  - 用药: 无。\n  - A1c: $(0.058, 25)$.\n  - FPG: $(110, 27)$.\n- 患者 $4$, $y=1$:\n  - 诊断: 无。\n  - 用药: 无。\n  - A1c: $(0.068, 44)$.\n  - FPG: $(118, 46)$.\n- 患者 $5$, $y=0$:\n  - 诊断: $(\\text{\"E11\"}, 200)$.\n  - 用药: 无。\n  - A1c: $(0.059, 210)$.\n  - FPG: $(115, 212)$.\n- 患者 $6$, $y=1$:\n  - 诊断: 无。\n  - 用药: 无。\n  - A1c: 无。\n  - FPG: $(128, 60)$, $(130, 190)$.\n- 患者 $7$, $y=0$:\n  - 诊断: 无。\n  - 用药: $(\\text{\"MET\"}, 300)$.\n  - A1c: $(0.060, 302)$.\n  - FPG: $(100, 303)$.\n- 患者 $8$, $y=1$:\n  - 诊断: $(\\text{\"E11\"}, 120)$.\n  - 用药: 无。\n  - A1c: $(0.070, 121)$.\n  - FPG: $(125, 119)$.\n- 患者 $9$, $y=1$:\n  - 诊断: $(\\text{\"E11.9\"}, 50)$.\n  - 用药: $(\\text{\"INS\"}, 51)$, $(\\text{\"MET\"}, 200)$.\n  - A1c: $(0.066, 52)$.\n  - FPG: $(140, 53)$.\n- 患者 $10$, $y=0$:\n  - 诊断: $(\\text{\"E11\"}, 160)$, $(\\text{\"E11.9\"}, 161)$.\n  - 用药: 无。\n  - A1c: $(0.061, 162)$.\n  - FPG: $(120, 163)$.\n- 患者 $11$, $y=1$:\n  - 诊断: 无。\n  - 用药: $(\\text{\"SULF\"}, 70)$.\n  - A1c: $(0.067, 71)$.\n  - FPG: $(129, 72)$.\n- 患者 $12$, $y=0$:\n  - 诊断: 无。\n  - 用药: 无。\n  - A1c: $(0.064, 15)$.\n  - FPG: $(125, 16)$.\n\n要求：\n1. 使用给定的代码列表和实验室阈值 $t_{\\text{A1c}} = 0.065$ 和 $t_{\\text{FPG}} = 126$ mg/dL，严格按照上述定义实现四个算法 $\\mathcal{A}$、$\\mathcal{B}$、$\\mathcal{C}$ 和 $\\mathcal{D}$。\n2. 对于每个算法，根据 $12$ 位患者的病历审查金标准，计算其灵敏度 $S$、PPV $P$ 和 F-score $F$。应用上述针对分母为零的边界情况约定。\n3. 将每个 $S$、$P$ 和 $F$ 四舍五入到 $3$ 位小数。\n4. 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。第 $i$ 个元素必须是算法 $i$ 的结果列表 $[S_i,P_i,F_i]$，顺序为 $\\mathcal{A}, \\mathcal{B}, \\mathcal{C}, \\mathcal{D}$。例如，输出必须类似于 $[[S_{\\mathcal{A}},P_{\\mathcal{A}},F_{\\mathcal{A}}],[S_{\\mathcal{B}},P_{\\mathcal{B}},F_{\\mathcal{B}}],[S_{\\mathcal{C}},P_{\\mathcal{C}},F_{\\mathcal{C}}],[S_{\\mathcal{D}},P_{\\mathcal{D}},F_{\\mathcal{D}}]]$。",
            "solution": "用户提供的问题陈述内部一致，在医学信息学领域有科学依据，且定义明确。唯一解所需的所有数据、定义、阈值和逻辑规则都已明确提供。该问题是实现和评估可计算表型分析算法的有效练习。因此，有必要提供完整的解决方案。\n\n任务是为 2 型糖尿病实现四种不同的可计算表型分析算法（$\\mathcal{A}$、$\\mathcal{B}$、$\\mathcal{C}$ 和 $\\mathcal{D}$），将它们应用于一个包含 $12$ 名合成患者的数据集，并根据金标准评估其性能。待计算的性能指标包括灵敏度（$S$）、阳性预测值（$P$）和 F-score（$F$）。\n\n首先，我们形式化给定的参数和定义。\n实验室阈值为 $t_{\\text{A1c}} = 0.065$ 和 $t_{\\text{FPG}} = 126$ mg/dL。\n相关 ICD 代码集为 $\\mathcal{C}_{\\text{T2D}} = \\{\\text{\"E11\"}, \\text{\"E11.9\"}, \\text{\"250.00\"}\\}$。\n相关抗糖尿病药物集为 $\\mathcal{M}_{\\text{T2D}} = \\{\\text{\"MET\"}, \\text{\"SULF\"}, \\text{\"INS\"}, \\text{\"GLP1\"}\\}$。\n患者 $p$ 的金标准表示为 $y_p \\in \\{0, 1\\}$。算法的预测为 $\\hat{y}_p \\in \\{0, 1\\}$。\n\n评估指标定义如下：\n- 灵敏度：$S = \\dfrac{\\text{TP}}{\\text{TP} + \\text{FN}}$\n- 阳性预测值 (PPV)：$P = \\dfrac{\\text{TP}}{\\text{TP} + \\text{FP}}$\n- F-score：$F = \\dfrac{2 \\cdot P \\cdot S}{P + S}$\n\n这里，$\\text{TP}$ 是真阳性（$\\hat{y}_p = 1, y_p = 1$）的数量，$\\text{FP}$ 是假阳性（$\\hat{y}_p = 1, y_p = 0$）的数量，$\\text{FN}$ 是假阴性（$\\hat{y}_p = 0, y_p = 1$）的数量。边界情况通过以下方式处理：如果 $\\text{TP} + \\text{FN} = 0$，则设 $S=0$；如果 $\\text{TP} + \\text{FP} = 0$，则设 $P=0$；如果 $P+S=0$，则设 $F=0$。\n\n为了系统地应用这些算法，我们根据每个患者的数据定义一组二元特征指标：\n1.  $f_{\\text{dx1}}(p)$: 如果患者至少有一个诊断在 $\\mathcal{C}_{\\text{T2D}}$ 中，则为真。\n2.  $f_{\\text{dx2}}(p)$: 如果患者在不同日期至少有两个诊断在 $\\mathcal{C}_{\\text{T2D}}$ 中，则为真。\n3.  $f_{\\text{med1}}(p)$: 如果患者至少有一种药物在 $\\mathcal{M}_{\\text{T2D}}$ 中，则为真。\n4.  $f_{\\text{med2}}(p)$: 如果患者至少有两种药物在 $\\mathcal{M}_{\\text{T2D}}$ 中，且其处方日期 $d_{j_1}, d_{j_2}$ 满足 $|d_{j_2} - d_{j_1}| \\le 180$，则为真。\n5.  $f_{\\text{a1c}}(p)$: 如果患者有任何 A1c 测量值 $a_k \\ge t_{\\text{A1c}}$，则为真。\n6.  $f_{\\text{fpg1}}(p)$: 如果患者有任何空腹血糖测量值 $g_\\ell \\ge t_{\\text{FPG}}$，则为真。\n7.  $f_{\\text{fpg2}}(p)$: 如果患者在不同日期至少有两个空腹血糖测量值 $g_\\ell \\ge t_{\\text{FPG}}$，则为真。\n\n使用这些指标，算法定义如下：\n-   $\\mathcal{A}(p) = f_{\\text{dx1}}(p) \\lor f_{\\text{med2}}(p) \\lor f_{\\text{a1c}}(p) \\lor f_{\\text{fpg2}}(p)$\n-   $\\mathcal{B}(p) = f_{\\text{dx2}}(p) \\lor (f_{\\text{med1}}(p) \\land (f_{\\text{a1c}}(p) \\lor f_{\\text{fpg1}}(p))) \\lor (f_{\\text{a1c}}(p) \\land f_{\\text{fpg1}}(p))$\n-   $\\mathcal{C}(p) = f_{\\text{dx1}}(p) \\lor f_{\\text{med1}}(p) \\lor f_{\\text{a1c}}(p) \\lor f_{\\text{fpg1}}(p)$\n-   $\\mathcal{D}(p) = f_{\\text{dx2}}(p) \\land f_{\\text{med2}}(p) \\land f_{\\text{a1c}}(p) \\land f_{\\text{fpg2}}(p)$\n\n我们为 12 位患者中的每一位评估这些特征：\n\n| 患者 ($p$) | $y_p$ | $f_{\\text{dx1}}$ | $f_{\\text{dx2}}$ | $f_{\\text{med1}}$ | $f_{\\text{med2}}$ | $f_{\\text{a1c}}$ | $f_{\\text{fpg1}}$ | $f_{\\text{fpg2}}$ |\n|:-------------:|:-----:|:----------------:|:----------------:|:-----------------:|:-----------------:|:----------------:|:------------------:|:------------------:|\n| 1             | 1     | T                | T                | T                 | F                 | T                | T                  | T                  |\n| 2             | 1     | F                | F                | T                 | T                 | F                | T                  | F                  |\n| 3             | 0     | F                | F                | F                 | F                 | F                | F                  | F                  |\n| 4             | 1     | F                | F                | F                 | F                 | T                | F                  | F                  |\n| 5             | 0     | T                | F                | F                 | F                 | F                | F                  | F                  |\n| 6             | 1     | F                | F                | F                 | F                 | F                | T                  | T                  |\n| 7             | 0     | F                | F                | T                 | F                 | F                | F                  | F                  |\n| 8             | 1     | T                | F                | F                 | F                 | T                | F                  | F                  |\n| 9             | 1     | T                | F                | T                 | T                 | T                | T                  | F                  |\n| 10            | 0     | T                | T                | F                 | F                 | F                | F                  | F                  |\n| 11            | 1     | F                | F                | T                 | F                 | T                | T                  | F                  |\n| 12            | 0     | F                | F                | F                 | F                 | F                | F                  | F                  |\n\n金标准中的阳性病例总数为 $N_P = \\text{TP} + \\text{FN} = 7$。\n阴性病例总数为 $N_N = \\text{FP} + \\text{TN} = 5$。\n\n接下来，我们确定每个算法对每位患者的预测 $\\hat{y}_p$，然后计算混淆矩阵的元素。\n\n**算法 $\\mathcal{A}$ 评估：**\n- 预测 ($\\hat{y}_{\\mathcal{A}}$): P1(1), P2(1), P3(0), P4(1), P5(1), P6(1), P7(0), P8(1), P9(1), P10(1), P11(1), P12(0).\n- $\\text{TP} = 7$ (P1, P2, P4, P6, P8, P9, P11)\n- $\\text{FP} = 2$ (P5, P10)\n- $\\text{TN} = 3$ (P3, P7, P12)\n- $\\text{FN} = 0$\n- $S = \\frac{7}{7+0} = 1.0$\n- $P = \\frac{7}{7+2} = \\frac{7}{9} \\approx 0.778$\n- $F = \\frac{2 \\cdot 0.778 \\cdot 1.0}{0.778 + 1.0} = \\frac{1.556}{1.778} \\approx 0.875$\n\n**算法 $\\mathcal{B}$ 评估：**\n- 预测 ($\\hat{y}_{\\mathcal{B}}$): P1(1), P2(1), P3(0), P4(0), P5(0), P6(0), P7(0), P8(0), P9(1), P10(1), P11(1), P12(0).\n- $\\text{TP} = 4$ (P1, P2, P9, P11)\n- $\\text{FP} = 1$ (P10)\n- $\\text{TN} = 4$ (P3, P5, P7, P12)\n- $\\text{FN} = 3$ (P4, P6, P8)\n- $S = \\frac{4}{4+3} = \\frac{4}{7} \\approx 0.571$\n- $P = \\frac{4}{4+1} = \\frac{4}{5} = 0.8$\n- $F = \\frac{2 \\cdot 0.8 \\cdot 0.571}{0.8 + 0.571} = \\frac{0.9136}{1.371} \\approx 0.667$\n\n**算法 $\\mathcal{C}$ 评估：**\n- 预测 ($\\hat{y}_{\\mathcal{C}}$): P1(1), P2(1), P3(0), P4(1), P5(1), P6(1), P7(1), P8(1), P9(1), P10(1), P11(1), P12(0).\n- $\\text{TP} = 7$ (P1, P2, P4, P6, P8, P9, P11)\n- $\\text{FP} = 3$ (P5, P7, P10)\n- $\\text{TN} = 2$ (P3, P12)\n- $\\text{FN} = 0$\n- $S = \\frac{7}{7+0} = 1.0$\n- $P = \\frac{7}{7+3} = \\frac{7}{10} = 0.7$\n- $F = \\frac{2 \\cdot 0.7 \\cdot 1.0}{0.7 + 1.0} = \\frac{1.4}{1.7} \\approx 0.824$\n\n**算法 $\\mathcal{D}$ 评估：**\n- 预测 ($\\hat{y}_{\\mathcal{D}}$): P1(0), P2(0), P3(0), P4(0), P5(0), P6(0), P7(0), P8(0), P9(0), P10(0), P11(0), P12(0).\n- $\\text{TP} = 0$\n- $\\text{FP} = 0$\n- $\\text{TN} = 5$ (P3, P5, P7, P10, P12)\n- $\\text{FN} = 7$ (P1, P2, P4, P6, P8, P9, P11)\n- $S = \\frac{0}{0+7} = 0.0$\n- $P = \\frac{0}{0+0} = 0.0$ (根据边界情况规则)\n- $F = 0.0$ (因为 $P+S=0$)\n\n最终结果，四舍五入到 3 位小数，如下：\n- 算法 $\\mathcal{A}$: $[S, P, F] = [1.000, 0.778, 0.875]$\n- 算法 $\\mathcal{B}$: $[S, P, F] = [0.571, 0.800, 0.667]$\n- 算法 $\\mathcal{C}$: $[S, P, F] = [1.000, 0.700, 0.824]$\n- 算法 $\\mathcal{D}$: $[S, P, F] = [0.000, 0.000, 0.000]$\n\n这些结果将被格式化为最终输出所需的列表之列表。",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Implements and evaluates four computable phenotyping algorithms for Type 2 Diabetes.\n    \"\"\"\n    \n    # Define constants and code lists\n    C_T2D = {\"E11\", \"E11.9\", \"250.00\"}\n    M_T2D = {\"MET\", \"SULF\", \"INS\", \"GLP1\"}\n    T_A1C = 0.065\n    T_FPG = 126\n\n    # Test suite data for 12 patients\n    test_cases = [\n        {\"id\": 1, \"y\": 1, \"dx\": [(\"E11\", 10), (\"E11.9\", 80)], \"med\": [(\"MET\", 15)], \"a1c\": [(0.072, 12)], \"fpg\": [(145, 11), (150, 85)]},\n        {\"id\": 2, \"y\": 1, \"dx\": [], \"med\": [(\"MET\", 5), (\"MET\", 100)], \"a1c\": [(0.062, 30)], \"fpg\": [(130, 35)]},\n        {\"id\": 3, \"y\": 0, \"dx\": [], \"med\": [], \"a1c\": [(0.058, 25)], \"fpg\": [(110, 27)]},\n        {\"id\": 4, \"y\": 1, \"dx\": [], \"med\": [], \"a1c\": [(0.068, 44)], \"fpg\": [(118, 46)]},\n        {\"id\": 5, \"y\": 0, \"dx\": [(\"E11\", 200)], \"med\": [], \"a1c\": [(0.059, 210)], \"fpg\": [(115, 212)]},\n        {\"id\": 6, \"y\": 1, \"dx\": [], \"med\": [], \"a1c\": [], \"fpg\": [(128, 60), (130, 190)]},\n        {\"id\": 7, \"y\": 0, \"dx\": [], \"med\": [(\"MET\", 300)], \"a1c\": [(0.060, 302)], \"fpg\": [(100, 303)]},\n        {\"id\": 8, \"y\": 1, \"dx\": [(\"E11\", 120)], \"med\": [], \"a1c\": [(0.070, 121)], \"fpg\": [(125, 119)]},\n        {\"id\": 9, \"y\": 1, \"dx\": [(\"E11.9\", 50)], \"med\": [(\"INS\", 51), (\"MET\", 200)], \"a1c\": [(0.066, 52)], \"fpg\": [(140, 53)]},\n        {\"id\": 10, \"y\": 0, \"dx\": [(\"E11\", 160), (\"E11.9\", 161)], \"med\": [], \"a1c\": [(0.061, 162)], \"fpg\": [(120, 163)]},\n        {\"id\": 11, \"y\": 1, \"dx\": [], \"med\": [(\"SULF\", 70)], \"a1c\": [(0.067, 71)], \"fpg\": [(129, 72)]},\n        {\"id\": 12, \"y\": 0, \"dx\": [], \"med\": [], \"a1c\": [(0.064, 15)], \"fpg\": [(125, 16)]},\n    ]\n\n    # --- Helper functions for algorithm conditions ---\n    def f_dx1(p): return any(c in C_T2D for c, d in p[\"dx\"])\n    def f_dx2(p):\n        t2d_dx_days = {d for c, d in p[\"dx\"] if c in C_T2D}\n        return len(t2d_dx_days) >= 2\n    def f_med1(p): return any(m in M_T2D for m, d in p[\"med\"])\n    def f_med2(p):\n        t2d_meds = [(m, d) for m, d in p[\"med\"] if m in M_T2D]\n        if len(t2d_meds)  2: return False\n        return any(abs(d1 - d2) = 180 for (_, d1), (_, d2) in combinations(t2d_meds, 2))\n    def f_a1c(p): return any(a >= T_A1C for a, d in p[\"a1c\"])\n    def f_fpg1(p): return any(g >= T_FPG for g, d in p[\"fpg\"])\n    def f_fpg2(p):\n        high_fpg_days = {d for g, d in p[\"fpg\"] if g >= T_FPG}\n        return len(high_fpg_days) >= 2\n\n    # --- Phenotyping Algorithms ---\n    def algo_A(p): return f_dx1(p) or f_med2(p) or f_a1c(p) or f_fpg2(p)\n    def algo_B(p): return f_dx2(p) or (f_med1(p) and (f_a1c(p) or f_fpg1(p))) or (f_a1c(p) and f_fpg1(p))\n    def algo_C(p): return f_dx1(p) or f_med1(p) or f_a1c(p) or f_fpg1(p)\n    def algo_D(p): return f_dx2(p) and f_med2(p) and f_a1c(p) and f_fpg2(p)\n\n    algorithms = [algo_A, algo_B, algo_C, algo_D]\n    all_results = []\n\n    for algo in algorithms:\n        tp, fp, tn, fn = 0, 0, 0, 0\n        for patient in test_cases:\n            y_true = patient[\"y\"]\n            y_pred = 1 if algo(patient) else 0\n            \n            if y_pred == 1 and y_true == 1:\n                tp += 1\n            elif y_pred == 1 and y_true == 0:\n                fp += 1\n            elif y_pred == 0 and y_true == 0:\n                tn += 1\n            elif y_pred == 0 and y_true == 1:\n                fn += 1\n\n        # Calculate metrics with edge-case handling\n        sensitivity = tp / (tp + fn) if (tp + fn) > 0 else 0.0\n        ppv = tp / (tp + fp) if (tp + fp) > 0 else 0.0\n        f_score = (2 * ppv * sensitivity) / (ppv + sensitivity) if (ppv + sensitivity) > 0 else 0.0\n        \n        # Round to 3 decimal places\n        s_rounded = round(sensitivity, 3)\n        p_rounded = round(ppv, 3)\n        f_rounded = round(f_score, 3)\n        \n        # Ensure floating point representation\n        all_results.append([float(s_rounded), float(p_rounded), float(f_rounded)])\n\n    # Format the final output string\n    # Using a nested list comprehension and str.format for precise output\n    result_str = '[' + ','.join([f'[{s},{p},{f}]' for s, p, f in all_results]) + ']'\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}