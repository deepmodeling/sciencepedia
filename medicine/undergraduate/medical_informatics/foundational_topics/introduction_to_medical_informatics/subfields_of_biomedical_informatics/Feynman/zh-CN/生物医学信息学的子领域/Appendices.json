{
    "hands_on_practices": [
        {
            "introduction": "生物医学信息学的核心挑战之一是实现数据的互操作性。临床数据通常以各种本地或计费代码（如ICD-10-CM）记录，这阻碍了数据在不同系统间的共享和聚合分析。本实践将带您进入临床术语和标准的世界，您将亲手将电子健康记录（EHR）中的诊断和实验室代码映射到国际标准术语SNOMED CT和LOINC。通过计算精确率（precision）、召回率（recall）和$F_1$分数，您不仅能掌握数据标准化的基本技术，还能学会如何定量评估映射的质量，这是确保数据可靠性的关键一步。",
            "id": "4857505",
            "problem": "您将处理一个来自临床术语和标准映射的场景，这是生物医学信息学的一个子领域，专注于临床概念的可互操作表示。一份电子健康记录 (EHR) 包含一个以国际疾病分类第十次修订临床修订版 (ICD-10-CM) 编码的问题列表，以及一个以本地实验室代码编码的实验室检查组合。您的任务是设计一个程序，使用提供的交叉映射字典将这些源编码映射到用于问题的系统化医学术语-临床术语 (SNOMED CT) 和用于实验室检查的逻辑观察标识符名称和代码 (LOINC)，然后根据提供的金标准概念对齐来评估映射质量。\n\n评估的基本原理源于集合论和信息检索：给定一个预测的对齐集 $P$ 和一个金标准的对齐集 $G$，各项计数定义为真阳性 $TP = |P \\cap G|$、假阳性 $FP = |P \\setminus G|$ 和假阴性 $FN = |G \\setminus P|$。精确率、召回率和调和平均数 $F_1$ 随后定义如下\n$$\\text{precision} = \\begin{cases}\n\\frac{TP}{|P|}  \\text{if } |P| > 0 \\\\\n0  \\text{if } |P| = 0\n\\end{cases},\\quad\n\\text{recall} = \\begin{cases}\n\\frac{TP}{|G|}  \\text{if } |G| > 0 \\\\\n0  \\text{if } |G| = 0\n\\end{cases},\\quad\nF_1 = \\begin{cases}\n\\frac{2 \\cdot \\text{precision} \\cdot \\text{recall}}{\\text{precision} + \\text{recall}}  \\text{if } \\text{precision} + \\text{recall} > 0 \\\\\n0  \\text{otherwise}\n\\end{cases}.$$\n\n设计假设和约束：\n- 使用提供的交叉映射进行精确代码等效映射：\n  - ICD-10-CM 到 SNOMED CT 的映射函数 $f_{\\text{diag}}$ 是一个从 ICD-10-CM 代码到 SNOMED CT 概念标识符的字典。\n  - 本地实验室到 LOINC 的映射函数 $f_{\\text{lab}}$ 是一个从本地实验室代码到 LOINC 代码的字典。\n- 对于在相应交叉映射中不存在的源编码，不产生预测的对齐。\n- 金标准下的概念等效性取决于目标代码的完全相等。如果对于同一源，预测的目标代码与金标准的目标代码不同，它将在总计数中贡献一个 $FP$ 和一个 $FN$（因为不正确的预测对不在 $G$ 中，而正确的金标准对不在 $P$ 中）。\n- 所有 EHR 项目均被独立处理；预测的对齐集 $P$ 是由 $f_{\\text{diag}}$ 和 $f_{\\text{lab}}$ 为该案例的 EHR 输入所产生的所有对的并集。\n\n提供用于所有测试用例的全局交叉映射字典：\n- ICD-10-CM 到 SNOMED CT ($f_{\\text{diag}}$):\n  - $ \\texttt{I10} \\mapsto \\texttt{59621000} $ (原发性高血压)\n  - $ \\texttt{E11.9} \\mapsto \\texttt{44054006} $ (2型糖尿病)\n  - $ \\texttt{J45.909} \\mapsto \\texttt{195967001} $ (哮喘)\n  - $ \\texttt{R79.9} \\mapsto \\texttt{165346000} $ (血液化学异常)\n  - $ \\texttt{M54.5} \\mapsto \\texttt{279039007} $ (下背痛)\n- 本地实验室到 LOINC ($f_{\\text{lab}}$):\n  - $ \\texttt{LIPID\\_PANEL} \\mapsto \\texttt{24331-1} $\n  - $ \\texttt{GLU\\_FAST} \\mapsto \\texttt{1557-8} $\n  - $ \\texttt{A1C} \\mapsto \\texttt{4548-4} $\n  - $ \\texttt{CREA\\_SER} \\mapsto \\texttt{2160-0} $\n\n测试套件：\n- 案例1（一般情况，包含一个故意过度映射的模糊诊断）：\n  - EHR 问题： $[\\texttt{I10}, \\texttt{E11.9}, \\texttt{J45.909}, \\texttt{R79.9}]$\n  - EHR 实验室检查： $[\\texttt{LIPID\\_PANEL}, \\texttt{A1C}, \\texttt{CREA\\_SER}]$\n  - 金标准对齐 $G$:\n    - 问题： $(\\texttt{I10}, \\texttt{59621000})$, $(\\texttt{E11.9}, \\texttt{44054006})$, $(\\texttt{J45.909}, \\texttt{195967001})$\n    - 实验室检查： $(\\texttt{LIPID\\_PANEL}, \\texttt{24331-1})$, $(\\texttt{A1C}, \\texttt{4548-4})$, $(\\texttt{CREA\\_SER}, \\texttt{2160-0})$\n- 案例2（空输入）：\n  - EHR 问题： $[\\ ]$\n  - EHR 实验室检查： $[\\ ]$\n  - 金标准对齐 $G$：空集\n- 案例3（部分覆盖和一个空腹血糖的单位系统不匹配）：\n  - EHR 问题： $[\\texttt{I10}, \\texttt{E11.65}, \\texttt{M54.5}]$\n  - EHR 实验室检查： $[\\texttt{GLU\\_FAST}, \\texttt{A1C}]$\n  - 金标准对齐 $G$:\n    - 问题： $(\\texttt{I10}, \\texttt{59621000})$, $(\\texttt{E11.65}, \\texttt{237599002})$, $(\\texttt{M54.5}, \\texttt{279039007})$\n    - 实验室检查： $(\\texttt{GLU\\_FAST}, \\texttt{1558-6})$, $(\\texttt{A1C}, \\texttt{4548-4})$\n- 案例4（交叉映射中无可用映射，但金标准期望一个）：\n  - EHR 问题： $[\\texttt{E11.65}]$\n  - EHR 实验室检查： $[\\ ]$\n  - 金标准对齐 $G$: $(\\texttt{E11.65}, \\texttt{237599002})$\n- 案例5（金标准排除了模糊或依赖上下文项目的映射）：\n  - EHR 问题： $[\\texttt{R79.9}]$\n  - EHR 实验室检查： $[\\texttt{LIPID\\_PANEL}]$\n  - 金标准对齐 $G$：空集\n- 案例6（完美映射）：\n  - EHR 问题： $[\\texttt{I10}, \\texttt{E11.9}]$\n  - EHR 实验室检查： $[\\texttt{A1C}]$\n  - 金标准对齐 $G$: $(\\texttt{I10}, \\texttt{59621000})$, $(\\texttt{E11.9}, \\texttt{44054006})$, $(\\texttt{A1C}, \\texttt{4548-4})$\n\n编程要求：\n- 通过将 $f_{\\text{diag}}$ 应用于问题列表并将 $f_{\\text{lab}}$ 应用于实验室检查列表来实现映射，忽略任何没有交叉映射条目的源编码。预测的对齐集 $P$ 是该案例中来自两个领域的所有对的并集。\n- 对于每个案例，根据上述定义计算 $\\text{precision}$、$\\text{recall}$ 和 $F_1$。\n- 最终输出格式：您的程序应生成一行输出，其中包含案例1到6的 $F_1$ 值，按顺序排列，每个值四舍五入到4位小数，以逗号分隔的列表形式并用方括号括起来，例如 $[\\ldots]$。\n- 此任务中不涉及物理单位或角度。",
            "solution": "该问题是有效的。这是一个在生物医学信息学领域中定义明确、有科学依据的问题，具体涉及术语映射的评估。所有必要的数据，包括映射函数（交叉映射）和用于评估的金标准集，都已提供。评估指标——精确率、召回率和 $F_1$ 分数——是标准的且定义清晰。该过程是确定性的并且是可计算验证的。\n\n任务是将电子健康记录 (EHR) 中的源编码映射到标准术语，并评估此映射的质量。源术语是用于问题的 ICD-10-CM 和用于实验室检查的本地代码。目标术语分别是 SNOMED CT 和 LOINC。\n\n方法论的核心涉及对预测的对齐集 $P$ 和金标准对齐集 $G$ 进行集合论比较。$P$ 和 $G$ 都是形式为 $(\\text{source\\_code, target\\_code})$ 的对偶集合。\n\n每个案例的预测集 $P$ 是通过将提供的交叉映射字典（$f_{\\text{diag}}$ 用于问题，$f_{\\text{lab}}$ 用于实验室检查）应用于输入的 EHR 数据而生成的。\n- $f_{\\text{diag}} = \\{ \\texttt{I10}: \\texttt{59621000}, \\texttt{E11.9}: \\texttt{44054006}, \\texttt{J45.909}: \\texttt{195967001}, \\texttt{R79.9}: \\texttt{165346000}, \\texttt{M54.5}: \\texttt{279039007} \\}$\n- $f_{\\text{lab}} = \\{ \\texttt{LIPID\\_PANEL}: \\texttt{24331-1}, \\texttt{GLU\\_FAST}: \\texttt{1557-8}, \\texttt{A1C}: \\texttt{4548-4}, \\texttt{CREA\\_SER}: \\texttt{2160-0} \\}$\n\n如果来自 EHR 的源编码不是相应字典中的键，则不会为其预测任何对齐。\n\n评估指标基于真阳性 ($TP$)、假阳性 ($FP$) 和假阴性 ($FN$) 的计数：\n$$ TP = |P \\cap G| $$\n$$ FP = |P \\setminus G| $$\n$$ FN = |G \\setminus P| $$\n\n根据这些计数，精确率、召回率和 $F_1$ 分数的计算如下：\n$$ \\text{precision} = \\frac{TP}{|P|} = \\frac{TP}{TP + FP} \\quad (\\text{if } |P| > 0) $$\n$$ \\text{recall} = \\frac{TP}{|G|} = \\frac{TP}{TP + FN} \\quad (\\text{if } |G| > 0) $$\n$$ F_1 = \\frac{2 \\cdot \\text{precision} \\cdot \\text{recall}}{\\text{precision} + \\text{recall}} \\quad (\\text{if } \\text{precision} + \\text{recall} > 0) $$\n如果这些表达式中的任何一个分母为零，则该指标的值定义为 $0$。\n\n每个测试用例的分析如下：\n\n**案例 1:**\n- EHR 输入：问题 $[\\texttt{I10}, \\texttt{E11.9}, \\texttt{J45.909}, \\texttt{R79.9}]$，实验室检查 $[\\texttt{LIPID\\_PANEL}, \\texttt{A1C}, \\texttt{CREA\\_SER}]$\n- 预测集 $P = \\{(\\texttt{I10}, \\texttt{59621000}), (\\texttt{E11.9}, \\texttt{44054006}), (\\texttt{J45.909}, \\texttt{195967001}), (\\texttt{R79.9}, \\texttt{165346000}), (\\texttt{LIPID\\_PANEL}, \\texttt{24331-1}), (\\texttt{A1C}, \\texttt{4548-4}), (\\texttt{CREA\\_SER}, \\texttt{2160-0})\\}$。因此 $|P|=7$。\n- 金标准集 $G = \\{(\\texttt{I10}, \\texttt{59621000}), (\\texttt{E11.9}, \\texttt{44054006}), (\\texttt{J45.909}, \\texttt{195967001}), (\\texttt{LIPID\\_PANEL}, \\texttt{24331-1}), (\\texttt{A1C}, \\texttt{4548-4}), (\\texttt{CREA\\_SER}, \\texttt{2160-0})\\}$。因此 $|G|=6$。\n- $TP = |P \\cap G| = 6$。\n- $FP = |P \\setminus G| = 1$，对应于对 $(\\texttt{R79.9}, \\texttt{165346000})$。\n- $FN = |G \\setminus P| = 0$。\n- $\\text{precision} = 6/7$，$\\text{recall} = 6/6=1$。\n- $F_1 = (2 \\cdot (6/7) \\cdot 1) / (6/7 + 1) = (12/7) / (13/7) = 12/13 \\approx 0.9231$。\n\n**案例 2:**\n- EHR 输入：问题 $[\\ ]$，实验室检查 $[\\ ]$。\n- 预测集 $P = \\emptyset$，因此 $|P|=0$。\n- 金标准集 $G = \\emptyset$，因此 $|G|=0$。\n- $TP = 0, FP = 0, FN = 0$。\n- 因为 $|P|=0$，所以 $\\text{precision}=0$。因为 $|G|=0$，所以 $\\text{recall}=0$。\n- $F_1 = 0$。\n\n**案例 3:**\n- EHR 输入：问题 $[\\texttt{I10}, \\texttt{E11.65}, \\texttt{M54.5}]$，实验室检查 $[\\texttt{GLU\\_FAST}, \\texttt{A1C}]$\n- 预测集 $P = \\{(\\texttt{I10}, \\texttt{59621000}), (\\texttt{M54.5}, \\texttt{279039007}), (\\texttt{GLU\\_FAST}, \\texttt{1557-8}), (\\texttt{A1C}, \\texttt{4548-4})\\}$。因此 $|P|=4$。\n- 金标准集 $G = \\{(\\texttt{I10}, \\texttt{59621000}), (\\texttt{E11.65}, \\texttt{237599002}), (\\texttt{M54.5}, \\texttt{279039007}), (\\texttt{GLU\\_FAST}, \\texttt{1558-6}), (\\texttt{A1C}, \\texttt{4548-4})\\}$。因此 $|G|=5$。\n- $TP = |P \\cap G| = 3$。正确的对偶是针对 $\\texttt{I10}$、$\\texttt{M54.5}$ 和 $\\texttt{A1C}$ 的。\n- $FP = |P \\setminus G| = 1$，对应于对 $(\\texttt{GLU\\_FAST}, \\texttt{1557-8})$。\n- $FN = |G \\setminus P| = 2$，对应于对 $(\\texttt{E11.65}, \\texttt{237599002})$ 和 $(\\texttt{GLU\\_FAST}, \\texttt{1558-6})$。\n- $\\text{precision} = 3/4 = 0.75$，$\\text{recall} = 3/5 = 0.6$。\n- $F_1 = (2 \\cdot 0.75 \\cdot 0.6) / (0.75 + 0.6) = 0.9 / 1.35 = 2/3 \\approx 0.6667$。\n\n**案例 4:**\n- EHR 输入：问题 $[\\texttt{E11.65}]$，实验室检查 $[\\ ]$。\n- 预测集 $P = \\emptyset$（因为 $\\texttt{E11.65}$ 不在 $f_{\\text{diag}}$ 中）。因此 $|P|=0$。\n- 金标准集 $G = \\{(\\texttt{E11.65}, \\texttt{237599002})\\}$。因此 $|G|=1$。\n- $TP = 0, FP = 0, FN = 1$。\n- $\\text{precision}=0$，$\\text{recall}=0/1=0$。\n- $F_1 = 0$。\n\n**案例 5:**\n- EHR 输入：问题 $[\\texttt{R79.9}]$，实验室检查 $[\\texttt{LIPID\\_PANEL}]$。\n- 预测集 $P = \\{(\\texttt{R79.9}, \\texttt{165346000}), (\\texttt{LIPID\\_PANEL}, \\texttt{24331-1})\\}$。因此 $|P|=2$。\n- 金标准集 $G = \\emptyset$。因此 $|G|=0$。\n- $TP = 0, FP = 2, FN = 0$。\n- $\\text{precision}=0/2=0$，$\\text{recall}=0$。\n- $F_1 = 0$。\n\n**案例 6:**\n- EHR 输入：问题 $[\\texttt{I10}, \\texttt{E11.9}]$，实验室检查 $[\\texttt{A1C}]$。\n- 预测集 $P = \\{(\\texttt{I10}, \\texttt{59621000}), (\\texttt{E11.9}, \\texttt{44054006}), (\\texttt{A1C}, \\texttt{4548-4})\\}$。因此 $|P|=3$。\n- 金标准集 $G = \\{(\\texttt{I10}, \\texttt{59621000}), (\\texttt{E11.9}, \\texttt{44054006}), (\\texttt{A1C}, \\texttt{4548-4})\\}$。因此 $|G|=3$。\n- $P$ 和 $G$ 是相同的。\n- $TP = 3, FP = 0, FN = 0$。\n- $\\text{precision} = 3/3=1$，$\\text{recall} = 3/3=1$。\n- $F_1 = (2 \\cdot 1 \\cdot 1) / (1+1) = 1.0$。\n\n$F_1$ 分数总结：\n- 案例 1: $0.9231$\n- 案例 2: $0.0000$\n- 案例 3: $0.6667$\n- 案例 4: $0.0000$\n- 案例 5: $0.0000$\n- 案例 6: $1.0000$",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the clinical terminology mapping evaluation problem for all test cases.\n    \"\"\"\n\n    # Global crosswalk dictionaries as defined in the problem\n    f_diag = {\n        'I10': '59621000',\n        'E11.9': '44054006',\n        'J45.909': '195967001',\n        'R79.9': '165346000',\n        'M54.5': '279039007',\n    }\n    f_lab = {\n        'LIPID_PANEL': '24331-1',\n        'GLU_FAST': '1557-8',\n        'A1C': '4548-4',\n        'CREA_SER': '2160-0',\n    }\n\n    # Test suite data\n    test_cases = [\n        {\n            \"ehr_problems\": ['I10', 'E11.9', 'J45.909', 'R79.9'],\n            \"ehr_labs\": ['LIPID_PANEL', 'A1C', 'CREA_SER'],\n            \"gold_alignments\": {\n                ('I10', '59621000'), ('E11.9', '44054006'), ('J45.909', '195967001'),\n                ('LIPID_PANEL', '24331-1'), ('A1C', '4548-4'), ('CREA_SER', '2160-0')\n            }\n        },\n        {\n            \"ehr_problems\": [],\n            \"ehr_labs\": [],\n            \"gold_alignments\": set()\n        },\n        {\n            \"ehr_problems\": ['I10', 'E11.65', 'M54.5'],\n            \"ehr_labs\": ['GLU_FAST', 'A1C'],\n            \"gold_alignments\": {\n                ('I10', '59621000'), ('E11.65', '237599002'), ('M54.5', '279039007'),\n                ('GLU_FAST', '1558-6'), ('A1C', '4548-4')\n            }\n        },\n        {\n            \"ehr_problems\": ['E11.65'],\n            \"ehr_labs\": [],\n            \"gold_alignments\": {('E11.65', '237599002')}\n        },\n        {\n            \"ehr_problems\": ['R79.9'],\n            \"ehr_labs\": ['LIPID_PANEL'],\n            \"gold_alignments\": set()\n        },\n        {\n            \"ehr_problems\": ['I10', 'E11.9'],\n            \"ehr_labs\": ['A1C'],\n            \"gold_alignments\": {\n                ('I10', '59621000'), ('E11.9', '44054006'), ('A1C', '4548-4')\n            }\n        }\n    ]\n\n    f1_results = []\n\n    for case in test_cases:\n        # Step 1: Generate the predicted alignment set, P\n        predicted_alignments = set()\n        for prob_code in case[\"ehr_problems\"]:\n            if prob_code in f_diag:\n                predicted_alignments.add((prob_code, f_diag[prob_code]))\n        for lab_code in case[\"ehr_labs\"]:\n            if lab_code in f_lab:\n                predicted_alignments.add((lab_code, f_lab[lab_code]))\n\n        # Step 2: Get the gold standard alignment set, G\n        gold_alignments = case[\"gold_alignments\"]\n\n        # Step 3: Calculate TP, FP, FN using set operations\n        tp = len(predicted_alignments.intersection(gold_alignments))\n        fp = len(predicted_alignments.difference(gold_alignments))\n        fn = len(gold_alignments.difference(predicted_alignments))\n\n        # Step 4: Calculate precision, recall, and F1 score\n        # Precision = TP / |P| = TP / (TP + FP)\n        if (tp + fp) > 0:\n            precision = tp / (tp + fp)\n        else:\n            precision = 0.0\n\n        # Recall = TP / |G| = TP / (TP + FN)\n        if (tp + fn) > 0:\n            recall = tp / (tp + fn)\n        else:\n            recall = 0.0\n\n        # F1 = 2 * (precision * recall) / (precision + recall)\n        if (precision + recall) > 0:\n            f1_score = 2 * (precision * recall) / (precision + recall)\n        else:\n            f1_score = 0.0\n            \n        f1_results.append(f1_score)\n\n    # Format the final output as specified\n    formatted_results = [f\"{score:.4f}\" for score in f1_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "在数据标准化之后，我们便可以利用这些高质量的数据进行临床研究和发现。一个常见的任务是从庞大的EHR数据中准确识别出具有特定疾病或特征的患者群体，这一过程被称为“可计算表型构建”。本实践将指导您根据美国糖尿病协会（ADA）的指南，结合诊断代码、实验室检查结果和药物信息，设计并实现一个用于识别2型糖尿病（T2DM）患者的算法。通过计算阳性预测值（PPV）、阴性预测值（NPV）、灵敏度（sensitivity）和特异性（specificity），您将体验到如何将临床知识转化为可执行的计算机程序，并严格评估其性能。",
            "id": "4857553",
            "problem": "您正在临床信息学（生物医学信息学的一个子领域）领域工作，任务是利用结构化电子健康记录 (EHR) 数据为 $2$ 型糖尿病 (T2DM) 设计一个可计算表型。您必须利用公认的诊断标准和二元分类逻辑，形式化一个算法，该算法能根据诊断代码、实验室测量值和用药情况将患者分类为预测的 T2DM 病例状态，然后根据病历审阅的金标准计算性能指标。\n\n使用的基本依据：\n- 来自美国糖尿病协会 (American Diabetes Association, ADA) 的广泛接受的糖尿病诊断阈值，此处表述为经过充分检验的事实：\n  - 糖化血红蛋白 (HbA1c) 标准：HbA1c 分数 $\\geq 0.065$（分数形式，非百分比）。\n  - 空腹血糖 (FPG) 标准：FPG $\\geq 126$ mg/dL。\n  - 随机血糖 (RPG) 标准：RPG $\\geq 200$ mg/dL。\n- 基于混淆矩阵的核心二元分类定义：\n  - 真阳性 ($TP$)、假阳性 ($FP$)、真阴性 ($TN$)、假阴性 ($FN$)。\n  - 阳性预测值 (PPV)、阴性预测值 (NPV)、敏感性、特异性。\n\n任务：\n1. 定义一个可计算表型函数，该函数使用以下规则集将每个患者的结构化记录映射到一个预测的病例标签 $\\hat{Y} \\in \\{0,1\\}$。该规则集以科学上真实的方式整合了诊断代码、实验室检查和药物信息：\n   - 令 $C$ 表示指示 T2DM 的国际疾病分类 (ICD) 诊断代码的数量。\n   - 令 $A$ 表示 HbA1c 分数（无单位，以分数形式表示，如 $0.072$），$F$ 表示空腹血糖（单位 mg/dL），$R$ 表示随机血糖（单位 mg/dL）。\n   - 令 $M$ 表示是否存在主要用于治疗 T2DM 的药物的布尔指标。\n   - 定义实验室阳性指标\n     $$L := (A \\geq 0.065) \\lor (F \\geq 126) \\lor (R \\geq 200).$$\n   - 预测的病例标签为\n     $$\\hat{Y} := \\begin{cases}\n     1  \\text{if } (C \\geq 2) \\lor L \\lor (M \\land (C \\geq 1)) \\\\\n     0  \\text{otherwise.}\n     \\end{cases}$$\n   这个规则集反映了临床信息学的实践：结合诊断代码、标准实验室阈值和药物来平衡敏感性和特异性。\n\n2. 使用上述 $\\hat{Y}$，对照所提供的病历审阅金标准标签 $Y \\in \\{0,1\\}$ 计算 $TP$、$FP$、$TN$ 和 $FN$，然后计算：\n   - $$\\mathrm{PPV} = \\frac{TP}{TP + FP},\\quad \\mathrm{NPV} = \\frac{TN}{TN + FN},$$\n   - $$\\text{sensitivity} = \\frac{TP}{TP + FN},\\quad \\text{specificity} = \\frac{TN}{TN + FP}.$$\n   将每个指标表示为十进制数。不允许使用百分号。\n\n测试集（每条记录是一个元组 $(C, A, F, R, M, Y)$）：\n- 记录 $1$：$(3, 0.072, 160, 210, \\text{True}, 1)$\n- 记录 $2$：$(0, 0.050, 95, 100, \\text{False}, 0)$\n- 记录 $3$：$(0, 0.065, 110, 170, \\text{False}, 1)$\n- 记录 $4$：$(0, 0.060, 100, 150, \\text{True}, 0)$\n- 记录 $5$：$(1, 0.058, 100, 130, \\text{False}, 1)$\n- 记录 $6$：$(0, 0.062, 110, 200, \\text{False}, 1)$\n- 记录 $7$：$(0, 0.064, 125, 180, \\text{False}, 0)$\n- 记录 $8$：$(0, 0.060, 130, 160, \\text{False}, 1)$\n- 记录 $9$：$(1, 0.055, 95, 100, \\text{True}, 0)$\n- 记录 $10$：$(2, 0.055, 100, 120, \\text{False}, 1)$\n\n覆盖理由：\n- 处于精确阈值的边界情况：$A = 0.065$（记录 $3$），$R = 200$（记录 $6$），$F = 130 \\geq 126$（记录 $8$）。\n- 仅用药情景（记录 $4$）。\n- 无实验室检查或药物的单代码情景（记录 $5$）。\n- 实验室检查正常的多代码情景（记录 $10$）。\n- 明确阴性（记录 $2$ 和 $7$）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\mathrm{PPV}, \\mathrm{NPV}, \\text{sensitivity}, \\text{specificity}]$，每项结果四舍五入到三位小数。例如，一个输出行可能看起来像 $[0.833,0.750,0.833,0.750]$。\n- 输出中不需要单位，因为这些性能指标是无量纲的。",
            "solution": "该问题是有效的。这是临床信息学领域一个适定的、有科学依据的、客观的任务。问题为可计算表型提供了一个清晰的、确定性的算法，一套完整的测试数据，以及待计算性能指标的标准定义。输入是一致的，所要求的输出也定义明确。\n\n目标是操作化一个用于 $2$ 型糖尿病 (T2DM) 的可计算表型，并对照金标准评估其性能。这是一个二元分类问题，每个患者被分为病例（$\\hat{Y}=1$）或非病例（$\\hat{Y}=0$）。\n\n分类规则基于结构化电子健康记录 (EHR) 数据：\n- $C$：T$2$DM 特异性国际疾病分类 (ICD) 代码的数量。\n- $A$：糖化血红蛋白 (HbA1c) 值，以分数形式表示。\n- $F$：空腹血糖水平，单位 mg/dL。\n- $R$：随机血糖水平，单位 mg/dL。\n- $M$：是否开具 T$2$DM 特异性药物的布尔指标。\n\n首先，我们根据美国糖尿病协会 (American Diabetes Association, ADA) 的诊断阈值定义一个实验室阳性指标 $L$。如果满足以下任一条件，则认为患者的实验室标准为阳性：\n$$L := (A \\geq 0.065) \\lor (F \\geq 126) \\lor (R \\geq 200)$$\n逻辑运算符 $\\lor$ 代表“或”。\n\n最终的预测病例状态 $\\hat{Y}$ 由一个整合了诊断代码、实验室结果和药物的复合规则确定：\n$$\\hat{Y} := \\begin{cases}\n1  \\text{if } (C \\geq 2) \\lor L \\lor (M \\land (C \\geq 1)) \\\\\n0  \\text{otherwise.}\n\\end{cases}$$\n这里，逻辑运算符 $\\land$ 代表“与”。此规则将患者分类为 T$2$DM 病例，如果他们满足以下条件之一：至少有两个相关诊断代码，或至少有一个阳性实验室值，或至少有一个相关诊断代码且正在使用 T$2$DM 药物。\n\n我们将此规则应用于 $10$ 个患者记录中的每一个。对于每条记录，我们将预测标签 $\\hat{Y}$ 与金标准病历审阅标签 $Y$ 进行比较，以确定分类结果：\n- 真阳性 ($TP$)：$\\hat{Y}=1$ 且 $Y=1$。\n- 假阳性 ($FP$)：$\\hat{Y}=1$ 且 $Y=0$。\n- 真阴性 ($TN$)：$\\hat{Y}=0$ 且 $Y=0$。\n- 假阴性 ($FN$)：$\\hat{Y}=0$ 且 $Y=1$。\n\n下表详细列出了每条记录的分类结果：\n- **记录 1**：$(3, 0.072, 160, 210, \\text{True}, 1)$。条件 $(C \\geq 2)$ 为真，因为 $C=3$。因此，$\\hat{Y}=1$。由于 $Y=1$，这是一个 $TP$。\n- **记录 2**：$(0, 0.050, 95, 100, \\text{False}, 0)$。条件 $L$ 为假 ($A  0.065, F  126, R  200$)。所有其他条件均为假。因此，$\\hat{Y}=0$。由于 $Y=0$，这是一个 $TN$。\n- **记录 3**：$(0, 0.065, 110, 170, \\text{False}, 1)$。条件 $L$ 为真，因为 $A=0.065$。因此，$\\hat{Y}=1$。由于 $Y=1$，这是一个 $TP$。\n- **记录 4**：$(0, 0.060, 100, 150, \\text{True}, 0)$。条件 $L$ 为假。条件 $(M \\land (C \\geq 1))$ 为假，因为 $C=0$。因此，$\\hat{Y}=0$。由于 $Y=0$，这是一个 $TN$。\n- **记录 5**：$(1, 0.058, 100, 130, \\text{False}, 1)$。条件 $L$ 为假。条件 $(M \\land (C \\geq 1))$ 为假，因为 $M$ 是 False。条件 $(C \\geq 2)$ 为假。因此，$\\hat{Y}=0$。由于 $Y=1$，这是一个 $FN$。\n- **记录 6**：$(0, 0.062, 110, 200, \\text{False}, 1)$。条件 $L$ 为真，因为 $R=200$。因此，$\\hat{Y}=1$。由于 $Y=1$，这是一个 $TP$。\n- **记录 7**：$(0, 0.064, 125, 180, \\text{False}, 0)$。条件 $L$ 为假 ($A  0.065, F  126, R  200$)。所有其他条件均为假。因此，$\\hat{Y}=0$。由于 $Y=0$，这是一个 $TN$。\n- **记录 8**：$(0, 0.060, 130, 160, \\text{False}, 1)$。条件 $L$ 为真，因为 $F=130 \\geq 126$。因此，$\\hat{Y}=1$。由于 $Y=1$，这是一个 $TP$。\n- **记录 9**：$(1, 0.055, 95, 100, \\text{True}, 0)$。条件 $L$ 为假。条件 $(M \\land (C \\geq 1))$ 为真，因为 $M$ 是 True 且 $C=1$。因此，$\\hat{Y}=1$。由于 $Y=0$，这是一个 $FP$。\n- **记录 10**：$(2, 0.055, 100, 120, \\text{False}, 1)$。条件 $(C \\geq 2)$ 为真，因为 $C=2$。因此，$\\hat{Y}=1$。由于 $Y=1$，这是一个 $TP$。\n\n汇总这些结果得出混淆矩阵的计数：\n- $TP = 5$\n- $FP = 1$\n- $TN = 3$\n- $FN = 1$\n\n最后，我们计算标准的性能指标。\n1. 阳性预测值 (PPV) 或精确率：\n   $$\\mathrm{PPV} = \\frac{TP}{TP + FP} = \\frac{5}{5 + 1} = \\frac{5}{6} \\approx 0.833$$\n\n2. 阴性预测值 (NPV)：\n   $$\\mathrm{NPV} = \\frac{TN}{TN + FN} = \\frac{3}{3 + 1} = \\frac{3}{4} = 0.750$$\n\n3. 敏感性或召回率：\n   $$\\text{sensitivity} = \\frac{TP}{TP + FN} = \\frac{5}{5 + 1} = \\frac{5}{6} \\approx 0.833$$\n\n4. 特异性：\n   $$\\text{specificity} = \\frac{TN}{TN + FP} = \\frac{3}{3 + 1} = \\frac{3}{4} = 0.750$$\n\n这四个指标（四舍五入到三位小数）对给定数据集上可计算表型的性能提供了定量评估。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are necessary for this problem.\n\ndef classify_patient(C, A, F, R, M):\n    \"\"\"\n    Applies the computable phenotype rule to classify a patient.\n\n    Args:\n        C (int): Count of T2DM ICD codes.\n        A (float): HbA1c fraction.\n        F (float): Fasting plasma glucose in mg/dL.\n        R (float): Random plasma glucose in mg/dL.\n        M (bool): Indicator for T2DM medications.\n\n    Returns:\n        int: Predicted case label (1 for case, 0 for non-case).\n    \"\"\"\n    lab_positive = (A >= 0.065) or (F >= 126) or (R >= 200)\n    \n    # The rule for predicting the case label Y_hat\n    # Y_hat = 1 if (C >= 2) or L or (M and (C >= 1))\n    if (C >= 2) or lab_positive or (M and (C >= 1)):\n        return 1\n    else:\n        return 0\n\ndef solve():\n    \"\"\"\n    Solves the problem by classifying patients and calculating performance metrics.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each record is a tuple (C, A, F, R, M, Y)\n    test_cases = [\n        (3, 0.072, 160, 210, True, 1),\n        (0, 0.050, 95, 100, False, 0),\n        (0, 0.065, 110, 170, False, 1),\n        (0, 0.060, 100, 150, True, 0),\n        (1, 0.058, 100, 130, False, 1),\n        (0, 0.062, 110, 200, False, 1),\n        (0, 0.064, 125, 180, False, 0),\n        (0, 0.060, 130, 160, False, 1),\n        (1, 0.055, 95, 100, True, 0),\n        (2, 0.055, 100, 120, False, 1),\n    ]\n\n    # Initialize confusion matrix counters\n    tp, fp, tn, fn = 0, 0, 0, 0\n\n    for case in test_cases:\n        C, A, F, R, M, Y_true = case\n        Y_pred = classify_patient(C, A, F, R, M)\n\n        if Y_pred == 1 and Y_true == 1:\n            tp += 1\n        elif Y_pred == 1 and Y_true == 0:\n            fp += 1\n        elif Y_pred == 0 and Y_true == 0:\n            tn += 1\n        elif Y_pred == 0 and Y_true == 1:\n            fn += 1\n            \n    # Calculate performance metrics\n    # Handle division by zero for robustness, though not strictly required by this problem's data\n    ppv = tp / (tp + fp) if (tp + fp) > 0 else 0.0\n    npv = tn / (tn + fn) if (tn + fn) > 0 else 0.0\n    sensitivity = tp / (tp + fn) if (tp + fn) > 0 else 0.0\n    specificity = tn / (tn + fp) if (tn + fp) > 0 else 0.0\n\n    # Format results to three decimal places\n    results = [round(ppv, 3), round(npv, 3), round(sensitivity, 3), round(specificity, 3)]\n    \n    # Final print statement in the exact required format.\n    # The format requirement of \"0.750\" means we need to format the float.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生物医学信息学的最终目标是利用数据和知识改善临床决策和患者健康。本实践将向您展示如何将已知的医学知识（如药物相互作用风险）转化为能在临床工作流程中实时提供帮助的“临床决策支持”（CDS）系统。您将模拟一个基于CDS Hooks标准的服务，在医生开具新药时自动检查潜在的药物-药物相互作用（DDI）并发出警报。更重要的是，您将超越简单的警报触发，学习使用决策曲线分析（Decision Curve Analysis, DCA）等高级方法来评估该CDS干预的临床净效益（net benefit），从而回答一个核心问题：“这个警报带来的好处是否大于其潜在的‘警报疲劳’等坏处？”。",
            "id": "4857560",
            "problem": "要求您在代码中实现一个简化的临床决策支持 (CDS) 挂钩服务逻辑，用于药物-药物相互作用 (DDI) 检查，然后计算评估指标和决策分析量。本练习涉及生物医学信息学中的临床决策支持和药学信息学子领域。该问题纯粹以数学和逻辑术语定义，抽象掉了任何网络或外部服务方面的内容，并要求根据给定的输入以编程方式计算指标。\n\n您将实现一个函数，以下列方式模拟 CDS 挂钩的行为：给定当前的一组药物和一组新开的药物，以及一个将药物对映射到相互作用风险概率（区间 $[0,1]$ 内的一个值）的知识库，该服务会对任何相互作用风险概率大于或等于服务阈值 $p_s$ 的药物对生成警报。然后，您将计算评估指标，并通过决策曲线分析量化净收益。\n\n在您的推理和实现中将使用的基本依据和定义包括：\n- 基于 $[0,1]$ 区间内风险评分的阈值的分类决策规则的定义。\n- 真阳性、假阳性的定义，以及从有限实例群体的计数中得出的比率。\n- 使用阈值概率来权衡净收益中真阳性与假阳性相对价值的决策曲线分析 (DCA) 概念。\n\n在代码中实现以下步骤：\n1. 创建一个警报生成函数，该函数为每个新开的药物检查所有现有药物，并为每个风险概率大于或等于 $p_s$ 的药物对创建警报。只考虑知识库映射中出现的笛卡尔积对；知识库中没有的药物对被视为在任何阈值下都没有可警报的相互作用。\n2. 根据已触发警报中的真阳性和假阳性计数，使用标准定义计算警报精确度。如果已触发的警报为零，则将精确度定义为 $0$。\n3. 计算撤销率，定义为被撤销的已触发警报数除以已触发警报总数。如果已触发的警报为零，则将撤销率定义为 $0$。所有比率必须表示为小数（例如，$0.25$），而不是百分比。\n4. 对一组给定的阈值概率执行决策曲线分析。对于每个阈值概率 $p_t$，将任何风险概率大于或等于 $p_t$ 的实例视为阳性决策，然后计算净收益。明确使用阈值概率 $p_t$ 来权衡假阳性相对于真阳性的危害。总群体大小 $N$ 是所检查的候选药物对的总数（即知识库中存在的当前药物和新开药物的完整笛卡尔积）。在本练习中，您将计算在每个给定的阈值概率下服务决策规则的净收益并返回这些值。\n5. 您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。要求的格式是列表的列表，每个测试用例对应一个内部列表。每个内部列表必须按顺序包含警报精确度、撤销率以及针对所提供阈值的净收益值，所有值均为十进制浮点数。例如，您的输出应类似于 $[[\\dots],[\\dots],[\\dots]]$，其中每个内部列表的值按 $[\\text{precision},\\text{override\\_rate},\\text{NB}_{p_{t1}},\\text{NB}_{p_{t2}},\\text{NB}_{p_{t3}}]$ 的顺序排列。\n\n使用以下测试套件。每个测试用例都指定了：\n- 一组现有药物。\n- 一组新开具的医嘱。\n- 知识库风险概率 $r_{ij}$，用于所考虑的笛卡尔积对。\n- 真实标签，指示每对药物是否是具有临床意义的真实相互作用 ($1$) 或不是 ($0$)。\n- 针对已触发警报的撤销决定映射 ($\\text{True}$ 表示已撤销，$\\text{False}$ 表示未撤销)。\n- 用于生成警报的固定 CDS 服务阈值 $p_s$。\n- 用于决策曲线分析的阈值概率列表。\n\n测试用例 1 (一般情况)：\n- 现有药物： $\\{\\text{warfarin},\\ \\text{simvastatin}\\}$。\n- 新开具的医嘱： $\\{\\text{trimethoprim},\\ \\text{clarithromycin}\\}$。\n- 知识库风险概率 $r_{ij}$：\n  - $(\\text{warfarin},\\ \\text{trimethoprim}) \\mapsto 0.72$\n  - $(\\text{warfarin},\\ \\text{clarithromycin}) \\mapsto 0.40$\n  - $(\\text{simvastatin},\\ \\text{clarithromycin}) \\mapsto 0.85$\n  - $(\\text{simvastatin},\\ \\text{trimethoprim}) \\mapsto 0.12$\n- 真实标签 $y_{ij}$：\n  - $(\\text{warfarin},\\ \\text{trimethoprim}) \\mapsto 1$\n  - $(\\text{warfarin},\\ \\text{clarithromycin}) \\mapsto 0$\n  - $(\\text{simvastatin},\\ \\text{clarithromycin}) \\mapsto 1$\n  - $(\\text{simvastatin},\\ \\text{trimethoprim}) \\mapsto 0$\n- 针对已触发警报的撤销决定 $o_{ij}$：\n  - $(\\text{warfarin},\\ \\text{trimethoprim}) \\mapsto \\text{False}$\n  - $(\\text{warfarin},\\ \\text{clarithromycin}) \\mapsto \\text{True}$\n  - $(\\text{simvastatin},\\ \\text{clarithromycin}) \\mapsto \\text{True}$\n  - $(\\text{simvastatin},\\ \\text{trimethoprim}) \\mapsto \\text{False}$\n- CDS 服务阈值：$p_s = 0.50$。\n- DCA 阈值：$[0.20,\\ 0.50,\\ 0.80]$。\n\n测试用例 2 (零警报边界情况)：\n- 现有药物： $\\{\\text{metformin}\\}$。\n- 新开具的医嘱： $\\{\\text{amoxicillin}\\}$。\n- 知识库风险概率 $r_{ij}$：\n  - $(\\text{metformin},\\ \\text{amoxicillin}) \\mapsto 0.10$\n- 真实标签 $y_{ij}$：\n  - $(\\text{metformin},\\ \\text{amoxicillin}) \\mapsto 0$\n- 撤销决定 $o_{ij}$：\n  - $(\\text{metformin},\\ \\text{amoxicillin}) \\mapsto \\text{True}$\n- CDS 服务阈值：$p_s = 0.50$。\n- DCA 阈值：$[0.20,\\ 0.50,\\ 0.80]$。\n\n测试用例 3 (等于阈值和极端概率的边缘情况)：\n- 现有药物： $\\{\\text{lisinopril},\\ \\text{spironolactone}\\}$。\n- 新开具的医嘱： $\\{\\text{potassium\\_chloride},\\ \\text{ibuprofen}\\}$。\n- 知识库风险概率 $r_{ij}$：\n  - $(\\text{lisinopril},\\ \\text{potassium\\_chloride}) \\mapsto 0.50$\n  - $(\\text{lisinopril},\\ \\text{ibuprofen}) \\mapsto 0.30$\n   - $(\\text{spironolactone},\\ \\text{potassium\\_chloride}) \\mapsto 0.95$\n  - $(\\text{spironolactone},\\ \\text{ibuprofen}) \\mapsto 0.20$\n- 真实标签 $y_{ij}$：\n  - $(\\text{lisinopril},\\ \\text{potassium\\_chloride}) \\mapsto 1$\n  - $(\\text{lisinopril},\\ \\text{ibuprofen}) \\mapsto 0$\n  - $(\\text{spironolactone},\\ \\text{potassium\\_chloride}) \\mapsto 1$\n  - $(\\text{spironolactone},\\ \\text{ibuprofen}) \\mapsto 0$\n- 撤销决定 $o_{ij}$：\n  - $(\\text{lisinopril},\\ \\text{potassium\\_chloride}) \\mapsto \\text{False}$\n  - $(\\text{lisinopril},\\ \\text{ibuprofen}) \\mapsto \\text{True}$\n  - $(\\text{spironolactone},\\ \\text{potassium\\_chloride}) \\mapsto \\text{False}$\n  - $(\\text{spironolactone},\\ \\text{ibuprofen}) \\mapsto \\text{True}$\n- CDS 服务阈值：$p_s = 0.50$。\n- DCA 阈值：$[0.20,\\ 0.50,\\ 0.80]$。\n\n附加要求：\n- 与阈值的比较必须使用“大于或等于”关系（即 $r_{ij} \\ge p$）。\n- 如果比率的分母为 $0$，则将该比率定义为 $0$。\n- 所有比率必须是小数（例如，$0.25$），而不是百分比。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顶层列表为每个测试用例包含一个内部列表。每个内部列表必须按 $[\\text{precision},\\ \\text{override\\_rate},\\ \\text{NB}_{0.20},\\ \\text{NB}_{0.50},\\ \\text{NB}_{0.80}]$ 的顺序排列。",
            "solution": "该问题定义明确且在科学上是合理的，要求实现并评估一个简化的用于药物-药物相互作用（DDI）的临床决策支持（CDS）逻辑。评估涉及计算标准分类指标和执行决策曲线分析（DCA）。整个过程是完全确定性的，并基于所提供的数据集和形式化定义。\n\n我们将首先对计算进行形式化，然后将该逻辑应用于每个测试用例。\n\n**形式化定义**\n-   **群体 ($P$)**: 所有已定义风险的药物对 $(i, j)$ 的集合。群体大小为 $N = |P|$。\n-   **警报**: 对于给定的服务阈值 $p_s$，当药物对的风险概率 $r_{ij} \\ge p_s$ 时，系统会生成警报。已触发警报的集合为 $A = \\{ (i, j) \\in P \\mid r_{ij} \\ge p_s \\}$。\n-   **警报精确度**: 已触发警报中真实相互作用的比例。\n    $$ \\text{Precision} = \\frac{|\\{ (i, j) \\in A \\mid y_{ij} = 1 \\}|}{|A|} \\quad (\\text{if } |A| > 0, \\text{else } 0) $$\n-   **撤销率**: 被临床医生撤销的已触发警报的比例。\n    $$ \\text{Override Rate} = \\frac{|\\{ (i, j) \\in A \\mid o_{ij} = \\text{True} \\}|}{|A|} \\quad (\\text{if } |A| > 0, \\text{else } 0) $$\n-   **决策曲线分析 (DCA)**: 对于每个给定的阈值概率 $p_t$，我们根据规则 $r_{ij} \\ge p_t$ 将整个群体中的每个对分类为阳性或阴性。\n    -   $TP(p_t) = |\\{ (i, j) \\in P \\mid r_{ij} \\ge p_t \\text{ and } y_{ij} = 1 \\}|$\n    -   $FP(p_t) = |\\{ (i, j) \\in P \\mid r_{ij} \\ge p_t \\text{ and } y_{ij} = 0 \\}|$\n    -   净收益 $\\text{NB}(p_t)$ 的计算公式为：\n        $$ \\text{NB}(p_t) = \\frac{TP(p_t)}{N} - \\frac{FP(p_t)}{N} \\times \\frac{p_t}{1-p_t} $$\n\n**测试用例分析**\n\n**测试用例 1:**\n-   群体 $P$ 包含4对药物 ($N=4$)。服务阈值 $p_s = 0.50$。\n-   **警报**: 风险 $\\ge 0.50$ 的对是 (warfarin, trimethoprim) [0.72] 和 (simvastatin, clarithromycin) [0.85]。因此，已触发的警报 $|A|=2$。\n-   **警报精确度**: 两个被警报的对的真实标签都是1。因此 $TP_{alert}=2$。精确度 = $2/2 = 1.0$。\n-   **撤销率**: 在两个警报中，(simvastatin, clarithromycin) 被撤销。因此，被撤销的警报数是1。撤销率 = $1/2 = 0.5$。\n-   **DCA**:\n    -   对于 $p_t = 0.20$: 风险 $\\ge 0.20$ 的对有3个。其中，$TP(0.20)=2$，$FP(0.20)=1$。$\\text{NB}(0.20) = \\frac{2}{4} - \\frac{1}{4} \\times \\frac{0.20}{0.80} = 0.5 - 0.25 \\times 0.25 = 0.4375$。\n    -   对于 $p_t = 0.50$: 风险 $\\ge 0.50$ 的对有2个。其中，$TP(0.50)=2$，$FP(0.50)=0$。$\\text{NB}(0.50) = \\frac{2}{4} - \\frac{0}{4} \\times \\frac{0.50}{0.50} = 0.5$。\n    -   对于 $p_t = 0.80$: 风险 $\\ge 0.80$ 的对有1个。其中，$TP(0.80)=1$，$FP(0.80)=0$。$\\text{NB}(0.80) = \\frac{1}{4} - \\frac{0}{4} \\times \\frac{0.80}{0.20} = 0.25$。\n-   结果: $[1.0, 0.5, 0.4375, 0.5, 0.25]$\n\n**测试用例 2:**\n-   群体 $P$ 包含1对药物 ($N=1$)。服务阈值 $p_s = 0.50$。\n-   **警报**: 唯一的对 (metformin, amoxicillin) 的风险是 $0.10  0.50$。没有触发警报，所以 $|A|=0$。\n-   **警报精确度**: 0.0。\n-   **撤销率**: 0.0。\n-   **DCA**:\n    -   对于 $p_t = 0.20, 0.50, 0.80$: 没有对的风险达到或超过这些阈值。因此，$TP$ 和 $FP$ 在所有情况下都为0。净收益始终为0。\n-   结果: $[0.0, 0.0, 0.0, 0.0, 0.0]$\n\n**测试用例 3:**\n-   群体 $P$ 包含4对药物 ($N=4$)。服务阈值 $p_s = 0.50$。\n-   **警报**: 风险 $\\ge 0.50$ 的对是 (lisinopril, potassium_chloride) [0.50] 和 (spironolactone, potassium_chloride) [0.95]。因此 $|A|=2$。\n-   **警报精确度**: 两个被警报的对的真实标签都是1。$TP_{alert}=2$。精确度 = $2/2 = 1.0$。\n-   **撤销率**: 两个警报都未被撤销。被撤销的警报数是0。撤销率 = $0/2 = 0.0$。\n-   **DCA**:\n    -   对于 $p_t = 0.20$: 所有4对的风险都 $\\ge 0.20$。其中，$TP(0.20)=2$，$FP(0.20)=2$。$\\text{NB}(0.20) = \\frac{2}{4} - \\frac{2}{4} \\times \\frac{0.20}{0.80} = 0.5 - 0.5 \\times 0.25 = 0.375$。\n    -   对于 $p_t = 0.50$: 风险 $\\ge 0.50$ 的对有2个。其中，$TP(0.50)=2$，$FP(0.50)=0$。$\\text{NB}(0.50) = \\frac{2}{4} - \\frac{0}{4} \\times \\frac{0.50}{0.50} = 0.5$。\n    -   对于 $p_t = 0.80$: 风险 $\\ge 0.80$ 的对有1个。其中，$TP(0.80)=1$，$FP(0.80)=0$。$\\text{NB}(0.80) = \\frac{1}{4} - \\frac{0}{4} \\times \\frac{0.80}{0.20} = 0.25$。\n-   结果: $[1.0, 0.0, 0.375, 0.5, 0.25]$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the required metrics.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1 (general case)\n        {\n            \"existing_meds\": {\"warfarin\", \"simvastatin\"},\n            \"new_orders\": {\"trimethoprim\", \"clarithromycin\"},\n            \"kb_risks\": {\n                (\"warfarin\", \"trimethoprim\"): 0.72,\n                (\"warfarin\", \"clarithromycin\"): 0.40,\n                (\"simvastatin\", \"clarithromycin\"): 0.85,\n                (\"simvastatin\", \"trimethoprim\"): 0.12,\n            },\n            \"ground_truth\": {\n                (\"warfarin\", \"trimethoprim\"): 1,\n                (\"warfarin\", \"clarithromycin\"): 0,\n                (\"simvastatin\", \"clarithromycin\"): 1,\n                (\"simvastatin\", \"trimethoprim\"): 0,\n            },\n            \"overrides\": {\n                (\"warfarin\", \"trimethoprim\"): False,\n                (\"warfarin\", \"clarithromycin\"): True,\n                (\"simvastatin\", \"clarithromycin\"): True,\n                (\"simvastatin\", \"trimethoprim\"): False,\n            },\n            \"p_s\": 0.50,\n            \"dca_thresholds\": [0.20, 0.50, 0.80],\n        },\n        # Test case 2 (boundary with zero alerts)\n        {\n            \"existing_meds\": {\"metformin\"},\n            \"new_orders\": {\"amoxicillin\"},\n            \"kb_risks\": {\n                (\"metformin\", \"amoxicillin\"): 0.10,\n            },\n            \"ground_truth\": {\n                (\"metformin\", \"amoxicillin\"): 0,\n            },\n            \"overrides\": {\n                (\"metformin\", \"amoxicillin\"): True,\n            },\n            \"p_s\": 0.50,\n            \"dca_thresholds\": [0.20, 0.50, 0.80],\n        },\n        # Test case 3 (edge with equality to threshold)\n        {\n            \"existing_meds\": {\"lisinopril\", \"spironolactone\"},\n            \"new_orders\": {\"potassium_chloride\", \"ibuprofen\"},\n            \"kb_risks\": {\n                (\"lisinopril\", \"potassium_chloride\"): 0.50,\n                (\"lisinopril\", \"ibuprofen\"): 0.30,\n                (\"spironolactone\", \"potassium_chloride\"): 0.95,\n                (\"spironolactone\", \"ibuprofen\"): 0.20,\n            },\n            \"ground_truth\": {\n                (\"lisinopril\", \"potassium_chloride\"): 1,\n                (\"lisinopril\", \"ibuprofen\"): 0,\n                (\"spironolactone\", \"potassium_chloride\"): 1,\n                (\"spironolactone\", \"ibuprofen\"): 0,\n            },\n            \"overrides\": {\n                (\"lisinopril\", \"potassium_chloride\"): False,\n                (\"lisinopril\", \"ibuprofen\"): True,\n                (\"spironolactone\", \"potassium_chloride\"): False,\n                (\"spironolactone\", \"ibuprofen\"): True,\n            },\n            \"p_s\": 0.50,\n            \"dca_thresholds\": [0.20, 0.50, 0.80],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(process_case(case))\n\n    # Format the final output as a string representing a list of lists.\n    # e.g., [[1.0,0.5,0.4375,0.5,0.25],[0.0,0.0,0.0,0.0,0.0],...]\n    output_str = \"[\" + \",\".join([\"[\" + \",\".join(map(str, res)) + \"]\" for res in results]) + \"]\"\n    print(output_str)\n\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case to compute precision, override rate, and net benefits.\n    \"\"\"\n    kb_risks = case_data[\"kb_risks\"]\n    ground_truth = case_data[\"ground_truth\"]\n    overrides = case_data[\"overrides\"]\n    p_s = case_data[\"p_s\"]\n    dca_thresholds = case_data[\"dca_thresholds\"]\n\n    population_pairs = list(kb_risks.keys())\n    N = len(population_pairs)\n\n    # 1. Alert Generation and associated metrics (Precision, Override Rate)\n    fired_alerts = []\n    for pair in population_pairs:\n        risk = kb_risks[pair]\n        if risk >= p_s:\n            fired_alerts.append(pair)\n    \n    num_fired_alerts = len(fired_alerts)\n    \n    if num_fired_alerts == 0:\n        precision = 0.0\n        override_rate = 0.0\n    else:\n        # Calculate True Positives among fired alerts\n        tp_alerts = sum(1 for pair in fired_alerts if ground_truth[pair] == 1)\n        precision = tp_alerts / num_fired_alerts\n        \n        # Calculate Overridden alerts\n        overridden_alerts = sum(1 for pair in fired_alerts if overrides[pair] is True)\n        override_rate = overridden_alerts / num_fired_alerts\n        \n    # 2. Decision Curve Analysis (DCA)\n    net_benefits = []\n    for p_t in dca_thresholds:\n        if N == 0:\n            net_benefits.append(0.0)\n            continue\n            \n        tp_dca = 0\n        fp_dca = 0\n        \n        for pair in population_pairs:\n            risk = kb_risks[pair]\n            if risk >= p_t:\n                if ground_truth[pair] == 1:\n                    tp_dca += 1\n                else:\n                    fp_dca += 1\n        \n        # NB = (TP/N) - (FP/N) * (pt / (1-pt))\n        # The problem states pt is in [0,1], but the formula is undefined for pt=1.\n        # Test cases do not include pt=1, so we don't need to handle that edge case.\n        if p_t == 1.0:\n            # Net benefit for \"treat none\" is 0 if prevalence is > 0.\n            # If we decide based on risk >= 1, we get TP and FP.\n            # The weight becomes infinite, so any FP leads to -inf NB.\n            # This is not a standard case, but for completeness, we can set NB to a value.\n            # For this problem, we assume p_t  1 based on test data.\n            pass\n\n        weight = p_t / (1 - p_t)\n        nb = (tp_dca / N) - (fp_dca / N) * weight\n        net_benefits.append(nb)\n\n    return [precision, override_rate] + net_benefits\n\nsolve()\n```"
        }
    ]
}