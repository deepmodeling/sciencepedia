{
    "hands_on_practices": [
        {
            "introduction": "Before we can measure the quality of care, we must first precisely define the patient population being evaluated. This foundational step, known as defining the denominator, ensures that we are making fair and consistent comparisons. This practice  challenges you to implement the logic for a measure's denominator using rules common in healthcare analytics, such as age criteria and continuous insurance enrollment, which requires careful handling of date-based logic and intervals from administrative data.",
            "id": "4844551",
            "problem": "You are given a preventive care measure for adults and must implement a denominator computation under a continuous enrollment criterion with allowable gaps up to a fixed threshold. Adopt the following index date policy: use the fixed end-of-year date, so the index date is $t_{\\mathrm{index}} = \\mathrm{December\\ }31$ of the measurement year $Y$. The denominator consists of members who satisfy the age criterion and the continuous enrollment criterion over the measurement window corresponding to the measurement year.\n\nFundamental base definitions to use:\n- Let the measurement window be $W = [t_{\\mathrm{start}}, t_{\\mathrm{end}}]$ where $t_{\\mathrm{start}} = \\mathrm{January\\ }1\\ \\text{of year}\\ Y$ and $t_{\\mathrm{end}} = \\mathrm{December\\ }31\\ \\text{of year}\\ Y$.\n- Let the allowed cumulative gap threshold be $\\Gamma = 30$ days. A member satisfies continuous enrollment over $W$ if the total count of uncovered days within $W$ does not exceed $\\Gamma$.\n- A member’s age at $t_{\\mathrm{index}}$ is the count of completed years since the date of birth. This is computed using calendar arithmetic as the number of full years elapsed by $t_{\\mathrm{index}}$.\n- The age inclusion band for the preventive care measure is $[18, 64]$ years inclusive, evaluated at $t_{\\mathrm{index}}$.\n\nData model:\n- Each test case specifies $Y$ and a list of members.\n- Each member record consists of a unique identifier, a date of birth, and a list of enrollment intervals. Each enrollment interval is a pair $[\\mathrm{start}, \\mathrm{end}]$ of calendar dates, inclusive, asserted to be valid and with $\\mathrm{start} \\le \\mathrm{end}$.\n- Intervals outside the measurement window $W$ do not count towards coverage; only the intersection of each interval with $W$ is considered for coverage.\n- If a member has multiple intervals, overlapping or adjacent intervals within $W$ must be merged before computing covered days.\n\nRequired computation for each test case:\n1. Compute $t_{\\mathrm{index}}$ from $Y$ as above.\n2. For each member, compute age in completed years at $t_{\\mathrm{index}}$ and check $18 \\le \\text{age} \\le 64$.\n3. Restrict each enrollment interval to $W$, merge overlaps and adjacencies, and compute the total covered days $C$ over $W$ by summing merged interval lengths (inclusive).\n4. Let $L$ be the total number of days in $W$ (inclusive; $L=365$ for a non-leap year and $L=366$ for a leap year). Compute the cumulative uncovered days $G = L - C$.\n5. A member satisfies continuous enrollment if $G \\le \\Gamma$.\n6. The denominator count is the number of members who satisfy both the age band and $G \\le \\Gamma$.\n\nYour program must produce a single line of output containing the denominator counts for the test cases as a comma-separated list enclosed in square brackets (for example, \"[2,3,4]\").\n\nUse the following test suite. Dates are in ISO format \"YYYY-MM-DD\".\n\nTest case $1$:\n- $Y = 2023$.\n- Members:\n  - id: \"A\", dob: \"1990-06-15\", enrollments: [[\"2023-01-01\",\"2023-05-31\"], [\"2023-07-01\",\"2023-12-31\"]].\n  - id: \"B\", dob: \"1959-12-30\", enrollments: [[\"2023-01-01\",\"2023-09-30\"], [\"2023-11-01\",\"2023-12-31\"]].\n  - id: \"C\", dob: \"2006-12-31\", enrollments: [[\"2023-01-01\",\"2023-12-31\"]].\n  - id: \"D\", dob: \"2005-12-31\", enrollments: [[\"2023-01-01\",\"2023-06-30\"], [\"2023-07-30\",\"2023-12-31\"]].\n  - id: \"E\", dob: \"1980-01-01\", enrollments: [].\n\nTest case $2$:\n- $Y = 2020$.\n- Members:\n  - id: \"F\", dob: \"1980-02-29\", enrollments: [[\"2020-01-01\",\"2020-03-31\"], [\"2020-05-01\",\"2020-12-31\"]].\n  - id: \"G\", dob: \"1956-12-31\", enrollments: [[\"2020-01-01\",\"2020-03-01\"], [\"2020-04-02\",\"2020-12-31\"]].\n  - id: \"H\", dob: \"2002-01-01\", enrollments: [[\"2020-01-01\",\"2020-06-01\"], [\"2020-05-15\",\"2020-12-31\"]].\n  - id: \"I\", dob: \"1970-07-01\", enrollments: [[\"2019-01-01\",\"2019-12-31\"]].\n  - id: \"J\", dob: \"1999-12-31\", enrollments: [[\"2020-01-01\",\"2020-02-28\"], [\"2020-03-31\",\"2020-12-31\"]].\n\nTest case $3$:\n- $Y = 2023$.\n- Members:\n  - id: \"K\", dob: \"1958-12-31\", enrollments: [[\"2023-01-01\",\"2023-12-31\"]].\n  - id: \"L\", dob: \"2005-01-01\", enrollments: [[\"2023-01-31\",\"2023-12-31\"]].\n  - id: \"M\", dob: \"1990-07-01\", enrollments: [[\"2023-01-01\",\"2023-01-21\"], [\"2023-02-01\",\"2023-11-10\"], [\"2023-12-01\",\"2023-12-31\"]].\n  - id: \"N\", dob: \"1999-12-31\", enrollments: [[\"2023-01-01\",\"2023-06-30\"], [\"2023-08-01\",\"2023-12-31\"]].\n  - id: \"O\", dob: \"1988-06-15\", enrollments: [[\"2023-01-01\",\"2023-12-31\"]].\n\nOutput specification:\n- For each test case, compute the integer denominator count according to the rules above.\n- Your program should produce exactly one line of output in the format \"[d1,d2,d3]\" where $d1$, $d2$, and $d3$ are the denominator counts for test cases $1$, $2$, and $3$, respectively.",
            "solution": "The problem is valid. It presents a well-defined computational task from the field of healthcare quality measurement, a sub-discipline of medical informatics. All terms are specified with sufficient precision, the provided data is consistent, and the required computations adhere to logical and mathematical principles. No scientific, logical, or factual flaws were detected.\n\nThe task is to compute the denominator for a preventive care quality measure. The denominator comprises members who meet both an age criterion and a continuous enrollment criterion within a specified measurement year, $Y$. We will formalize the procedure in two parts: determining eligibility based on age, and then based on continuous enrollment.\n\nLet the measurement year be denoted by $Y$. The measurement window, $W$, is the interval of days from January $1$ to December $31$ of year $Y$, inclusive. We define this as $W = [t_{\\mathrm{start}}, t_{\\mathrm{end}}]$, where $t_{\\mathrm{start}} = Y\\text{-01-01}$ and $t_{\\mathrm{end}} = Y\\text{-12-31}$. The index date for all calculations is fixed as $t_{\\mathrm{index}} = t_{\\mathrm{end}} = Y\\text{-12-31}$.\n\n**1. Age Criterion**\n\nA member is eligible by age if their age falls within the inclusive band of $[18, 64]$ years on the index date, $t_{\\mathrm{index}}$. The age is defined as the number of completed years elapsed since the member's date of birth (DOB). Given a DOB $= Y_{\\mathrm{dob}}\\text{-}M_{\\mathrm{dob}}\\text{-}D_{\\mathrm{dob}}$ and an index date $t_{\\mathrm{index}} = Y\\text{-12-31}$, the age is calculated as:\n$$\n\\text{age} = Y - Y_{\\mathrm{dob}}\n$$\nThis simplification is valid because the index date is always the last day of the year. Therefore, for any DOB, the member's birthday in year $Y$ has already passed or falls on the index date itself, meaning they have completed $Y - Y_{\\mathrm{dob}}$ years of life. The age criterion is satisfied if:\n$$\n18 \\le (Y - Y_{\\mathrm{dob}}) \\le 64\n$$\n\n**2. Continuous Enrollment Criterion**\n\nA member satisfies the continuous enrollment criterion if their total number of uncovered days within the measurement window $W$ does not exceed a specified threshold, $\\Gamma = 30$ days. The calculation involves three sequential steps:\n\n**2.1. Enrollment Interval Processing**\n\nEach member has a history of enrollment periods, given as a list of inclusive intervals $[s_i, e_i]$. These intervals must first be restricted to the measurement window $W = [t_{\\mathrm{start}}, t_{\\mathrm{end}}]$. The intersection of an enrollment interval $[s_i, e_i]$ with $W$ yields a new interval $[s'_i, e'_i]$:\n$$\ns'_i = \\max(s_i, t_{\\mathrm{start}})\n$$\n$$\ne'_i = \\min(e_i, t_{\\mathrm{end}})\n$$\nIf $s'_i > e'_i$, the enrollment interval lies entirely outside the measurement window, and it is disregarded. Otherwise, the interval $[s'_i, e'_i]$ represents a period of coverage within the year $Y$.\n\n**2.2. Merging of Coverage Intervals**\n\nAfter restricting all of a member's enrollment intervals to $W$, the resulting set of valid coverage intervals must be merged to resolve overlaps and adjacencies. This creates a minimal set of disjoint intervals that represents the total unique periods of coverage. The merging algorithm is as follows:\n1. Sort the set of clipped intervals $\\{[s'_i, e'_i]\\}$ by their start dates, $s'_i$.\n2. Initialize a list of merged intervals with the first sorted interval.\n3. Iterate through the remaining sorted intervals. For each interval, compare it to the last interval in the merged list. If it overlaps or is adjacent (i.e., its start date is on or one day after the end date of the last merged interval), update the end date of the last merged interval to encompass the current interval.\n4. If it does not overlap or adjoin, add it as a new interval to the list of merged intervals.\n\n**2.3. Calculation of Uncovered Days**\n\nLet the final set of merged, disjoint coverage intervals be $\\{[\\hat{s}_j, \\hat{e}_j]\\}$. The total number of covered days, $C$, is the sum of the lengths of these intervals. The length of a single inclusive interval $[\\hat{s}_j, \\hat{e}_j]$ is $(\\hat{e}_j - \\hat{s}_j) + 1\\ \\text{day}$.\n$$\nC = \\sum_j \\left( (\\hat{e}_j - \\hat{s}_j) \\cdot \\text{days} + 1 \\right)\n$$\nLet $L$ be the total number of days in the measurement year $Y$ ($L=365$ for a non-leap year, $L=366$ for a leap year). The total number of uncovered days, $G$, is given by:\n$$\nG = L - C\n$$\nThe continuous enrollment criterion is met if $G \\le \\Gamma$, where $\\Gamma = 30$.\n\n**Denominator Computation**\n\nThe final denominator count for a given test case is the total number of members who satisfy both the age criterion and the continuous enrollment criterion. The algorithmic procedure is to iterate through each member, apply these two checks, and increment a counter if both are fulfilled. This process is repeated for each test case.",
            "answer": "```python\nimport datetime\n\ndef solve():\n    \"\"\"\n    Computes the denominator for a preventive care measure based on age and continuous enrollment criteria.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"Y\": 2023,\n            \"members\": [\n                {\"id\": \"A\", \"dob\": \"1990-06-15\", \"enrollments\": [[\"2023-01-01\", \"2023-05-31\"], [\"2023-07-01\", \"2023-12-31\"]]},\n                {\"id\": \"B\", \"dob\": \"1959-12-30\", \"enrollments\": [[\"2023-01-01\", \"2023-09-30\"], [\"2023-11-01\", \"2023-12-31\"]]},\n                {\"id\": \"C\", \"dob\": \"2006-12-31\", \"enrollments\": [[\"2023-01-01\", \"2023-12-31\"]]},\n                {\"id\": \"D\", \"dob\": \"2005-12-31\", \"enrollments\": [[\"2023-01-01\", \"2023-06-30\"], [\"2023-07-30\", \"2023-12-31\"]]},\n                {\"id\": \"E\", \"dob\": \"1980-01-01\", \"enrollments\": []},\n            ]\n        },\n        {\n            \"Y\": 2020,\n            \"members\": [\n                {\"id\": \"F\", \"dob\": \"1980-02-29\", \"enrollments\": [[\"2020-01-01\", \"2020-03-31\"], [\"2020-05-01\", \"2020-12-31\"]]},\n                {\"id\": \"G\", \"dob\": \"1956-12-31\", \"enrollments\": [[\"2020-01-01\", \"2020-03-01\"], [\"2020-04-02\", \"2020-12-31\"]]},\n                {\"id\": \"H\", \"dob\": \"2002-01-01\", \"enrollments\": [[\"2020-01-01\", \"2020-06-01\"], [\"2020-05-15\", \"2020-12-31\"]]},\n                {\"id\": \"I\", \"dob\": \"1970-07-01\", \"enrollments\": [[\"2019-01-01\", \"2019-12-31\"]]},\n                {\"id\": \"J\", \"dob\": \"1999-12-31\", \"enrollments\": [[\"2020-01-01\", \"2020-02-28\"], [\"2020-03-31\", \"2020-12-31\"]]},\n            ]\n        },\n        {\n            \"Y\": 2023,\n            \"members\": [\n                {\"id\": \"K\", \"dob\": \"1958-12-31\", \"enrollments\": [[\"2023-01-01\", \"2023-12-31\"]]},\n                {\"id\": \"L\", \"dob\": \"2005-01-01\", \"enrollments\": [[\"2023-01-31\", \"2023-12-31\"]]},\n                {\"id\": \"M\", \"dob\": \"1990-07-01\", \"enrollments\": [[\"2023-01-01\", \"2023-01-21\"], [\"2023-02-01\", \"2023-11-10\"], [\"2023-12-01\", \"2023-12-31\"]]},\n                {\"id\": \"N\", \"dob\": \"1999-12-31\", \"enrollments\": [[\"2023-01-01\", \"2023-06-30\"], [\"2023-08-01\", \"2023-12-31\"]]},\n                {\"id\": \"O\", \"dob\": \"1988-06-15\", \"enrollments\": [[\"2023-01-01\", \"2023-12-31\"]]},\n            ]\n        }\n    ]\n\n    results = []\n    \n    GAMMA = 30\n    AGE_MIN = 18\n    AGE_MAX = 64\n\n    def is_leap(year):\n        return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\n    for case in test_cases:\n        Y = case[\"Y\"]\n        members = case[\"members\"]\n        denominator_count = 0\n\n        # Define measurement window and index date\n        w_start = datetime.date(Y, 1, 1)\n        w_end = datetime.date(Y, 12, 31)\n        \n        # Total days in the measurement year\n        L = 366 if is_leap(Y) else 365\n\n        for member in members:\n            # 1. Age Criterion Check\n            dob = datetime.date.fromisoformat(member[\"dob\"])\n            age = Y - dob.year\n            \n            if not (AGE_MIN = age = AGE_MAX):\n                continue\n            \n            # 2. Continuous Enrollment Criterion Check\n            enroll_intervals = member[\"enrollments\"]\n            \n            # 2a. Intersect enrollment intervals with the measurement window\n            clipped_intervals = []\n            for start_str, end_str in enroll_intervals:\n                start_date = datetime.date.fromisoformat(start_str)\n                end_date = datetime.date.fromisoformat(end_str)\n                \n                intersect_start = max(start_date, w_start)\n                intersect_end = min(end_date, w_end)\n                \n                if intersect_start = intersect_end:\n                    clipped_intervals.append([intersect_start, intersect_end])\n            \n            covered_days = 0\n            if clipped_intervals:\n                # 2b. Merge overlapping and adjacent intervals\n                clipped_intervals.sort(key=lambda x: x[0])\n                \n                merged = [clipped_intervals[0]]\n                for i in range(1, len(clipped_intervals)):\n                    current_start, current_end = clipped_intervals[i]\n                    last_merged_start, last_merged_end = merged[-1]\n                    \n                    # Merge if intervals overlap or are adjacent (end of one is the day before start of next)\n                    if current_start = last_merged_end + datetime.timedelta(days=1):\n                        merged[-1][1] = max(last_merged_end, current_end)\n                    else:\n                        merged.append([current_start, current_end])\n                \n                # 2c. Calculate total covered days from merged intervals\n                for start, end in merged:\n                    covered_days += (end - start).days + 1\n            \n            # 2d. Calculate uncovered days\n            uncovered_days = L - covered_days\n            \n            # 2e. Check against the allowed gap threshold\n            if uncovered_days = GAMMA:\n                denominator_count += 1\n                \n        results.append(denominator_count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a clear denominator, the next step is to determine which of those patients met the quality goal—the numerator—and calculate the final measure rate. This exercise  simulates the complete, end-to-end construction of a blood pressure control measure by synthesizing multiple types of structured patient data. You will apply logic inspired by the Clinical Quality Language (CQL) to data representing diagnoses, encounters, and observations, gaining hands-on experience in how modern informatics translates clinical guidelines into computable measures.",
            "id": "4844528",
            "problem": "You will write a complete program that evaluates a blood pressure control quality measure using a fixed set of sample Fast Healthcare Interoperability Resources (FHIR) resources and Clinical Quality Language (CQL) semantics, then returns the measure rate for multiple measurement windows. The task is to start from core definitions in informatics and set theory and implement the logic exactly as stated, without relying on any external CQL engine. The problem is self-contained.\n\nFundamental base and definitions to use:\n- A patient’s age in years at a reference date is the floor of the elapsed time in years between the date of birth and the reference date. For a birth date at $d_{\\text{birth}}$ and reference date at $d_{\\text{ref}}$, define age as $A = \\left\\lfloor \\frac{d_{\\text{ref}} - d_{\\text{birth}}}{\\text{one year}} \\right\\rfloor$, where one year is computed by calendrical difference of years followed by month and day comparison.\n- A time interval is a closed interval $[t_{\\min}, t_{\\max}]$ of dates. An event at date $t$ occurs within the interval if $t_{\\min} \\le t \\le t_{\\max}$.\n- The measure denominator is a set of patients defined by set membership predicates; the measure numerator is a subset defined by further predicates; the measure rate is the ratio $R = \\frac{|\\text{Numerator}|}{|\\text{Denominator}|}$, with the convention $R = 0.0$ if $|\\text{Denominator}| = 0$.\n- The logic follows Clinical Quality Language (CQL) semantics expressed in set and predicate terms. You will implement the predicates described below.\n\nData provided and to be used by your program:\n- Sample International Classification of Diseases, Tenth Revision, Clinical Modification (ICD-10-CM) code for hypertension: “I10”.\n- Sample Logical Observation Identifiers Names and Codes (LOINC) codes:\n  - Blood pressure panel code: “$85354$-$9$”.\n  - Systolic blood pressure component: “$8480$-$6$”.\n  - Diastolic blood pressure component: “$8462$-$4$”.\n\nYou must embed the following fixed cohort of sample FHIR-like resources directly in your program. Representations are abstract; only the stated attributes are relevant.\n\n- Patient $P1$:\n  - birthDate: $1967$-$05$-$20$.\n  - Conditions: one hypertension condition (“I10”), onset at $2010$-$01$-$01$.\n  - Encounters: one encounter with period date $2022$-$06$-$01$ in $[t_{\\min}, t_{\\max}]$ if that date lies in the interval.\n  - Observations (blood pressure, code “$85354$-$9$”):\n    - $2022$-$06$-$01$: systolic (“$8480$-$6$”) $138$ mmHg, diastolic (“$8462$-$4$”) $88$ mmHg.\n    - $2022$-$09$-$01$: systolic $142$ mmHg, diastolic $85$ mmHg.\n- Patient $P2$:\n  - birthDate: $1955$-$02$-$10$.\n  - Conditions: one hypertension condition (“I10”), onset at $2015$-$01$-$01$.\n  - Encounters: one encounter on $2022$-$11$-$01$.\n  - Observations:\n    - $2022$-$03$-$03$: systolic $139$ mmHg, diastolic $91$ mmHg.\n    - $2022$-$11$-$01$: systolic $134$ mmHg, diastolic $88$ mmHg.\n- Patient $P3$:\n  - birthDate: $1977$-$08$-$01$.\n  - Conditions: one hypertension condition (“I10”), onset at $2020$-$06$-$01$.\n  - Encounters: one encounter on $2022$-$05$-$10$.\n  - Observations:\n    - $2021$-$12$-$30$: systolic $130$ mmHg, diastolic $80$ mmHg.\n- Patient $P4$:\n  - birthDate: $1938$-$01$-$01$.\n  - Conditions: one hypertension condition (“I10”), onset at $2000$-$01$-$01$.\n  - Encounters: one encounter on $2022$-$12$-$31$.\n  - Observations:\n    - $2022$-$12$-$31$: systolic $140$ mmHg, diastolic $90$ mmHg.\n- Patient $P5$:\n  - birthDate: $1992$-$09$-$15$.\n  - Conditions: none.\n  - Encounters: one encounter on $2022$-$10$-$10$.\n  - Observations:\n    - $2022$-$10$-$10$: systolic $120$ mmHg, diastolic $70$ mmHg.\n- Patient $P6$:\n  - birthDate: $2004$-$12$-$31$.\n  - Conditions: one hypertension condition (“I10”), onset at $2022$-$06$-$01$.\n  - Encounters: one encounter on $2022$-$07$-$01$.\n  - Observations:\n    - $2022$-$08$-$01$: systolic $138$ mmHg, diastolic $89$ mmHg.\n\nCQL-style predicates to implement precisely from first principles:\n- Adult cohort: a patient qualifies as adult at the measurement period end date $t_{\\max}$ if age in years at $t_{\\max}$ satisfies $18 \\le A \\le 85$.\n- Hypertension diagnosis: a patient has hypertension if there exists a Condition with code “I10” whose onset date is $\\le t_{\\max}$.\n- Encounter during measurement period: a patient meets the encounter requirement if there exists at least one Encounter whose date $t_{\\text{enc}}$ satisfies $t_{\\min} \\le t_{\\text{enc}} \\le t_{\\max}$.\n- Denominator membership: patient is in the denominator if and only if all three predicates above are true.\n- Blood pressure controlled numerator: among a patient’s blood pressure Observations (code “$85354$-$9$”) with both systolic (“$8480$-$6$”) and diastolic (“$8462$-$4$”) components, consider those with effective date $t_{\\text{obs}}$ satisfying $t_{\\min} \\le t_{\\text{obs}} \\le t_{\\max}$. If none exist, the patient is not in the numerator. Otherwise, take the most recent observation, i.e., the one with maximal $t_{\\text{obs}}$; the patient is in the numerator if and only if systolic $ 140$ and diastolic $ 90$ for that most recent observation. Values equal to $140$ systolic or $90$ diastolic are not considered controlled.\n\nMeasure rate computation:\n- For a given measurement period $[t_{\\min}, t_{\\max}]$, define the denominator count $D$ and numerator count $N$ as above. The measure rate $R$ is the decimal $R = \\frac{N}{D}$ if $D  0$, else $R = 0.0$. Report $R$ rounded to three decimal places using conventional rounding half away from zero when the fourth decimal digit is $\\ge 5$.\n\nTest suite:\nYour program must compute $R$ for each of the following measurement periods, in the order listed:\n1. Case $1$: $t_{\\min} = 2022$-$01$-$01$, $t_{\\max} = 2022$-$12$-$31$.\n2. Case $2$: $t_{\\min} = 2022$-$09$-$02$, $t_{\\max} = 2022$-$12$-$31$.\n3. Case $3$: $t_{\\min} = 2022$-$01$-$01$, $t_{\\max} = 2022$-$06$-$30$.\n4. Case $4$: $t_{\\min} = 2023$-$01$-$01$, $t_{\\max} = 2023$-$12$-$31$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of the four decimal rates, each formatted to exactly three decimal places, enclosed in square brackets, with no spaces. For example, a valid output shape is “[$0.123$,$0.456$,$0.000$,$1.000$]” but with the values that result from this problem’s data and rules.\n\nAll dates are calendar dates. No external input is required; the program must embed the data above and strictly implement the logic as stated. All blood pressure values are in millimeters of mercury (mmHg). All reported rates must be decimals in $[0, 1]$.",
            "solution": "The problem requires the implementation of a clinical quality measure for blood pressure control, based on a predefined set of patient data and logical predicates inspired by the Clinical Quality Language (CQL). The solution involves a rigorous, step-by-step application of set theory and predicate logic to a fixed dataset for multiple time periods.\n\nThe core of the problem is to determine, for a given measurement period, the membership of two sets: the Denominator set, $D$, and the Numerator set, $N$. The universal set, $\\mathcal{P}$, consists of the six provided patients, $\\{P1, P2, P3, P4, P5, P6\\}$. The measurement period is defined by a closed interval of dates, $[t_{\\min}, t_{\\max}]$.\n\nThe final measure rate, $R$, is the ratio of the cardinalities of these sets:\n$$R = \\begin{cases} \\frac{|N|}{|D|}  \\text{if } |D|  0 \\\\ 0.0  \\text{if } |D| = 0 \\end{cases}$$\nThe rate $R$ must be rounded to three decimal places, with the rule that a value is rounded up if the fourth decimal digit is $5$ or greater.\n\nThe membership of the Denominator and Numerator sets is determined by a series of logical predicates.\n\n**1. Denominator ($D$) Predicates**\n\nA patient $p \\in \\mathcal{P}$ is a member of the denominator set $D$ if and only if they satisfy three conditions simultaneously:\n$p \\in D \\iff \\text{IsAdult}(p, t_{\\max}) \\land \\text{HasHypertension}(p, t_{\\max}) \\land \\text{HadEncounter}(p, [t_{\\min}, t_{\\max}])$\n\nLet us define each predicate:\n\n- $\\text{IsAdult}(p, t_{\\max})$: This predicate is true if the patient's age, $A$, on the measurement period end date, $t_{\\max}$, falls within the range $[18, 85]$. The age is calculated as $A = \\left\\lfloor \\frac{t_{\\max} - d_{\\text{birth}}}{\\text{one year}} \\right\\rfloor$, where $d_{\\text{birth}}$ is the patient's birth date. The calculation follows a calendrical difference: first the difference in years is taken, and then one year is subtracted if the month and day of $t_{\\max}$ precede the month and day of $d_{\\text{birth}}$.\n\n- $\\text{HasHypertension}(p, t_{\\max})$: This predicate is true if the patient has a recorded Condition with the ICD-10-CM code `“I10”` and the onset date of this condition is on or before $t_{\\max}$.\n\n- $\\text{HadEncounter}(p, [t_{\\min}, t_{\\max}])$: This predicate is true if the patient has at least one Encounter record whose date, $t_{\\text{enc}}$, occurs within the measurement period, i.e., $t_{\\min} \\le t_{\\text{enc}} \\le t_{\\max}$.\n\n**2. Numerator ($N$) Predicate**\n\nThe Numerator, $N$, is a subset of the Denominator, $D$. A patient $p \\in D$ is a member of the numerator set $N$ if they meet the blood pressure control criteria.\n$p \\in N \\iff p \\in D \\land \\text{IsControlled}(p, [t_{\\min}, t_{\\max}])$\n\n- $\\text{IsControlled}(p, [t_{\\min}, t_{\\max}])$: This predicate's evaluation involves several steps:\n    1. Identify all Blood Pressure Observations for patient $p$ that occurred within the measurement period $[t_{\\min}, t_{\\max}]$. An observation is valid only if it has both a systolic (`“8480-6”`) and a diastolic (`“8462-4”`) component.\n    2. If no such observations exist within the period, the predicate is false.\n    3. If one or more such observations exist, select the most recent one (the one with the maximum observation date, $t_{\\text{obs}}$).\n    4. For this most recent observation, the predicate is true if and only if its systolic value is less than $140$ mmHg and its diastolic value is less than $90$ mmHg. Note the strict inequalities: values of $140$ or $90$ are not considered controlled.\n\n**3. Algorithmic Implementation**\n\nThe solution is implemented by creating a computational workflow that processes each patient against the predicates for each of the four specified test cases (measurement periods).\n\nFirst, the patient data is stored in a structured format, such as a list of dictionaries, to facilitate access to attributes like `birthDate`, `conditions`, `encounters`, and `observations`.\n\nFor each test case $[t_{\\min}, t_{\\max}]$:\n1. Initialize a denominator count $D_{count} = 0$ and a numerator count $N_{count} = 0$.\n2. Iterate through each patient $p \\in \\mathcal{P}$.\n3. For each patient, evaluate the three denominator predicates: $\\text{IsAdult}$, $\\text{HasHypertension}$, and $\\text{HadEncounter}$.\n4. If all three are true, increment $D_{count}$ by $1$. Then, proceed to evaluate the numerator predicate $\\text{IsControlled}$ for this patient.\n5. If $\\text{IsControlled}$ is also true, increment $N_{count}$ by $1$.\n6. After iterating through all patients, calculate the rate $R$. If $D_{count}  0$, $R = N_{count} / D_{count}$. Otherwise, $R = 0.0$.\n7. The calculated rate $R$ is rounded to $3$ decimal places. For a non-negative number $x$, this is achieved by computing $\\frac{\\lfloor x \\cdot 10^3 + 0.5 \\rfloor}{10^3}$.\n8. The final formatted string is generated for each rate, ensuring three decimal places are always displayed (e.g., $0.5$ becomes $0.500$). The results from all test cases are compiled into the required list format. This entire process is deterministic and produces a unique, verifiable result.",
            "answer": "```python\nimport numpy as np\nfrom datetime import date\n\ndef solve():\n    \"\"\"\n    Evaluates a blood pressure control quality measure for a fixed cohort of patients\n    across multiple measurement windows, based on specified CQL-like semantics.\n    \"\"\"\n    \n    # --- Data Representation ---\n    # The fixed cohort of sample FHIR-like resources, embedded directly.\n    patients = [\n        {\n            \"id\": \"P1\", \"birthDate\": \"1967-05-20\",\n            \"conditions\": [{\"code\": \"I10\", \"onset\": \"2010-01-01\"}],\n            \"encounters\": [{\"date\": \"2022-06-01\"}],\n            \"observations\": [\n                {\"date\": \"2022-06-01\", \"systolic\": 138, \"diastolic\": 88},\n                {\"date\": \"2022-09-01\", \"systolic\": 142, \"diastolic\": 85},\n            ],\n        },\n        {\n            \"id\": \"P2\", \"birthDate\": \"1955-02-10\",\n            \"conditions\": [{\"code\": \"I10\", \"onset\": \"2015-01-01\"}],\n            \"encounters\": [{\"date\": \"2022-11-01\"}],\n            \"observations\": [\n                {\"date\": \"2022-03-03\", \"systolic\": 139, \"diastolic\": 91},\n                {\"date\": \"2022-11-01\", \"systolic\": 134, \"diastolic\": 88},\n            ],\n        },\n        {\n            \"id\": \"P3\", \"birthDate\": \"1977-08-01\",\n            \"conditions\": [{\"code\": \"I10\", \"onset\": \"2020-06-01\"}],\n            \"encounters\": [{\"date\": \"2022-05-10\"}],\n            \"observations\": [\n                {\"date\": \"2021-12-30\", \"systolic\": 130, \"diastolic\": 80},\n            ],\n        },\n        {\n            \"id\": \"P4\", \"birthDate\": \"1938-01-01\",\n            \"conditions\": [{\"code\": \"I10\", \"onset\": \"2000-01-01\"}],\n            \"encounters\": [{\"date\": \"2022-12-31\"}],\n            \"observations\": [\n                {\"date\": \"2022-12-31\", \"systolic\": 140, \"diastolic\": 90},\n            ],\n        },\n        {\n            \"id\": \"P5\", \"birthDate\": \"1992-09-15\",\n            \"conditions\": [],\n            \"encounters\": [{\"date\": \"2022-10-10\"}],\n            \"observations\": [\n                {\"date\": \"2022-10-10\", \"systolic\": 120, \"diastolic\": 70},\n            ],\n        },\n        {\n            \"id\": \"P6\", \"birthDate\": \"2004-12-31\",\n            \"conditions\": [{\"code\": \"I10\", \"onset\": \"2022-06-01\"}],\n            \"encounters\": [{\"date\": \"2022-07-01\"}],\n            \"observations\": [\n                {\"date\": \"2022-08-01\", \"systolic\": 138, \"diastolic\": 89},\n            ],\n        },\n    ]\n\n    # Test cases defined by measurement periods [t_min, t_max].\n    test_cases = [\n        (\"2022-01-01\", \"2022-12-31\"),\n        (\"2022-09-02\", \"2022-12-31\"),\n        (\"2022-01-01\", \"2022-06-30\"),\n        (\"2023-01-01\", \"2023-12-31\"),\n    ]\n\n    # --- Predicate Implementations ---\n\n    def calculate_age(birth_date_obj, ref_date_obj):\n        \"\"\"Calculates age in years based on calendrical difference.\"\"\"\n        age = ref_date_obj.year - birth_date_obj.year\n        if (ref_date_obj.month, ref_date_obj.day)  (birth_date_obj.month, birth_date_obj.day):\n            age -= 1\n        return age\n\n    def is_adult(patient, t_max_obj):\n        \"\"\"Checks if patient is between 18 and 85 years old.\"\"\"\n        birth_date_obj = date.fromisoformat(patient[\"birthDate\"])\n        age = calculate_age(birth_date_obj, t_max_obj)\n        return 18 = age = 85\n\n    def has_hypertension(patient, t_max_obj):\n        \"\"\"Checks for an active hypertension diagnosis.\"\"\"\n        for condition in patient[\"conditions\"]:\n            if condition[\"code\"] == \"I10\":\n                onset_date_obj = date.fromisoformat(condition[\"onset\"])\n                if onset_date_obj = t_max_obj:\n                    return True\n        return False\n\n    def had_encounter_in_period(patient, t_min_obj, t_max_obj):\n        \"\"\"Checks for an encounter within the measurement period.\"\"\"\n        for encounter in patient[\"encounters\"]:\n            encounter_date_obj = date.fromisoformat(encounter[\"date\"])\n            if t_min_obj = encounter_date_obj = t_max_obj:\n                return True\n        return False\n\n    def is_in_numerator(patient, t_min_obj, t_max_obj):\n        \"\"\"Checks if the patient's blood pressure is controlled.\"\"\"\n        valid_obs = []\n        for obs in patient[\"observations\"]:\n            obs_date_obj = date.fromisoformat(obs[\"date\"])\n            if t_min_obj = obs_date_obj = t_max_obj:\n                valid_obs.append(obs)\n        \n        if not valid_obs:\n            return False\n            \n        # Find the most recent observation by sorting\n        most_recent_obs = sorted(valid_obs, key=lambda x: x[\"date\"], reverse=True)[0]\n        \n        return most_recent_obs[\"systolic\"]  140 and most_recent_obs[\"diastolic\"]  90\n\n    # --- Main Calculation Loop ---\n    \n    results = []\n    for t_min_str, t_max_str in test_cases:\n        t_min_obj = date.fromisoformat(t_min_str)\n        t_max_obj = date.fromisoformat(t_max_str)\n        \n        denominator_count = 0\n        numerator_count = 0\n        \n        for p in patients:\n            in_denominator = (\n                is_adult(p, t_max_obj) and\n                has_hypertension(p, t_max_obj) and\n                had_encounter_in_period(p, t_min_obj, t_max_obj)\n            )\n            \n            if in_denominator:\n                denominator_count += 1\n                if is_in_numerator(p, t_min_obj, t_max_obj):\n                    numerator_count += 1\n        \n        if denominator_count == 0:\n            rate = 0.0\n        else:\n            rate = numerator_count / denominator_count\n        \n        # Round to 3 decimal places (half away from zero)\n        # Using np.floor(x * 10**dp + 0.5) / 10**dp for positive numbers achieves this\n        rounded_rate = np.floor(rate * 1000 + 0.5) / 1000\n        results.append(f\"{rounded_rate:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Quality improvement is a dynamic process that goes beyond simply calculating a performance score; it requires continuous monitoring to see if our changes are making a difference. This final practice  introduces you to the world of Statistical Process Control (SPC) by having you implement a Cumulative Sum (CUSUM) chart. You will use log-likelihood ratios to detect statistically significant shifts in postoperative complication rates, learning how to use data to actively manage quality and rapidly identify the impact of improvement interventions.",
            "id": "4844492",
            "problem": "You are tasked with implementing a one-sided cumulative sum (CUSUM) procedure to monitor postoperative complication rates and detect sustained improvements following a Quality Improvement (QI) intervention. The monitoring is based on binary observations for individual postoperative cases, where each case is an independent Bernoulli trial. Your program must compute decision interval thresholds, construct the CUSUM using the log-likelihood ratio, detect the earliest improvement signal after the QI intervention, and determine whether the improvement is sustained.\n\nFoundational base:\n\n- Let $x_i \\in \\{0,1\\}$ denote the outcome of case $i$, where $x_i = 1$ indicates a complication and $x_i = 0$ indicates no complication. The outcomes are modeled as independent Bernoulli random variables with parameter $p$, where $p$ is the complication rate.\n- Under the null hypothesis of no improvement, $H_0: p = p_0$, and under the alternative hypothesis of improvement, $H_1: p = p_1$, with $p_1  p_0$. All rates must be expressed as decimals (e.g., $0.15$ for $15$ out of $100$).\n- The Bernoulli probability mass function is $f(x \\mid p) = p^x (1-p)^{1-x}$.\n- The Sequential Probability Ratio Test (SPRT) uses the log-likelihood ratio increment $$w_i = \\log\\left(\\frac{f(x_i \\mid p_1)}{f(x_i \\mid p_0)}\\right) = x_i \\log\\left(\\frac{p_1}{p_0}\\right) + (1-x_i)\\log\\left(\\frac{1-p_1}{1-p_0}\\right).$$\n- Page’s CUSUM statistic for improvement is defined recursively by $$S_t = \\max\\left(0, S_{t-1} + w_t\\right), \\quad S_0 = 0,$$ where the recursion is applied starting at the QI intervention index $t_{\\mathrm{QI}}$ and proceeding forward.\n- Decision interval thresholds derived from SPRT error control are $$h_+ = \\log\\left(\\frac{1-\\beta}{\\alpha}\\right) \\quad \\text{and} \\quad h_- = \\log\\left(\\frac{\\beta}{1-\\alpha}\\right),$$ where $\\alpha$ is the Type I error (false signal probability) under $H_0$ and $\\beta$ is the Type II error (missed detection probability) under $H_1$. For one-sided improvement detection, $h_+$ is used as the alarm threshold.\n\nDetection and sustained improvement criteria:\n\n- Define the earliest improvement signal time $t^\\star$ as the smallest $t \\ge t_{\\mathrm{QI}}$ such that $S_t \\ge h_+$. If no such $t$ exists, set $t^\\star = -1$.\n- Sustained improvement is declared if and only if $t^\\star \\neq -1$, there are at least $w$ observations after $t^\\star$, and the empirical mean complication rate in the next $w$ observations, $$\\hat{p} = \\frac{1}{w}\\sum_{i=t^\\star+1}^{t^\\star+w} x_i,$$ satisfies $\\hat{p} \\le p_1$.\n\nImplementation requirements:\n\n- Input data for each test case consists of $(p_0, p_1, \\alpha, \\beta, t_{\\mathrm{QI}}, w, \\{x_i\\}_{i=0}^{n-1})$. All complication rates $p_0$ and $p_1$ must be decimals. The QI index $t_{\\mathrm{QI}}$ is the $0$-based index in the sequence at which the intervention begins, and the CUSUM should be accumulated starting at $t_{\\mathrm{QI}}$.\n- Your program should compute $h_+$ and $h_-$, the earliest detection index $t^\\star$, and the sustained improvement boolean for each test case.\n- For each test case, output a list of the form $[t^\\star, \\text{sustained}, h_+, h_-]$, where $t^\\star$ is an integer, `sustained` is a boolean, and $h_+, h_-$ are floats rounded to six decimal places.\n\nTest suite:\n\nUse the following four test cases to exercise different scenarios. For each case, the sequence $\\{x_i\\}$ is provided explicitly and the QI index $t_{\\mathrm{QI}}$ indicates where to start the CUSUM accumulation.\n\n- Case A (happy path with sustained improvement):\n    - $p_0 = 0.15$, $p_1 = 0.07$, $\\alpha = 0.20$, $\\beta = 0.20$, $t_{\\mathrm{QI}} = 20$, $w = 15$,\n    - $\\{x_i\\}$ (length $60$): $[0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,\\; 0,0,0,0,0,0,1,\\; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]$.\n- Case B (improvement too weak, no signal):\n    - $p_0 = 0.15$, $p_1 = 0.10$, $\\alpha = 0.10$, $\\beta = 0.20$, $t_{\\mathrm{QI}} = 20$, $w = 10$,\n    - $\\{x_i\\}$ (length $50$): $[0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,\\; 0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0]$.\n- Case C (no complications after QI, strong sustained improvement):\n    - $p_0 = 0.25$, $p_1 = 0.10$, $\\alpha = 0.10$, $\\beta = 0.10$, $t_{\\mathrm{QI}} = 10$, $w = 20$,\n    - $\\{x_i\\}$ (length $45$): $[0,1,0,0,1,0,0,0,1,0,\\; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]$.\n- Case D (signal occurs but insufficient follow-up for sustained improvement):\n    - $p_0 = 0.20$, $p_1 = 0.05$, $\\alpha = 0.15$, $\\beta = 0.15$, $t_{\\mathrm{QI}} = 30$, $w = 25$,\n    - $\\{x_i\\}$ (length $50$): $[0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,\\; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing a list of the per-case results in order Case A, Case B, Case C, Case D, as a comma-separated list enclosed in square brackets. Each per-case result must be a list in the form $[t^\\star, \\text{sustained}, h_+, h_-]$, with $h_+$ and $h_-$ rounded to six decimal places. For example: $[[t^\\star_A,\\text{sustained}_A,h_{+,A},h_{-,A}], [t^\\star_B,\\text{sustained}_B,h_{+,B},h_{-,B}], [\\dots], [\\dots]]$.",
            "solution": "The problem statement is deemed valid. It is scientifically grounded in the established statistical theory of Sequential Probability Ratio Tests (SPRT) and Cumulative Sum (CUSUM) charts, which are standard methodologies in statistical process control and healthcare quality improvement. The problem is well-posed, providing all necessary definitions, data, and unambiguous criteria for a unique solution. The parameters and scenarios are realistic. A minor discrepancy was noted in the descriptive text for Test Case C, which states a data sequence length of $45$ while providing a sequence of length $36$. This is interpreted as a non-fatal typographical error, and the solution will proceed using the explicitly provided data sequence, as its structure is complete and sufficient for the analysis.\n\nThe solution is implemented by following the defined statistical procedure. We analyze a series of postoperative outcomes, $\\{x_i\\}_{i=0}^{n-1}$, where each outcome is a Bernoulli trial. An outcome $x_i=1$ represents a complication, and $x_i=0$ represents no complication. The historical complication rate is $p_0$, and the target rate following a Quality Improvement (QI) intervention is $p_1$, with $p_1  p_0$. The QI intervention is initiated at case index $t_{\\mathrm{QI}}$.\n\nThe core of the CUSUM procedure is the log-likelihood ratio, which quantifies the evidence provided by each observation in favor of the alternative hypothesis $H_1: p=p_1$ (improvement) against the null hypothesis $H_0: p=p_0$ (no improvement). The probability mass function of a Bernoulli random variable is $f(x \\mid p) = p^x (1-p)^{1-x}$. The log-likelihood ratio for a single observation $x_i$ is given by:\n$$w_i = \\log\\left(\\frac{f(x_i \\mid p_1)}{f(x_i \\mid p_0)}\\right) = x_i \\log\\left(\\frac{p_1}{p_0}\\right) + (1-x_i)\\log\\left(\\frac{1-p_1}{1-p_0}\\right)$$\nSince $p_1  p_0$, the term $\\log(p_1/p_0)$ is negative, and $\\log((1-p_1)/(1-p_0))$ is positive. Thus, a complication ($x_i=1$) decreases the cumulative sum, providing evidence against improvement, while no complication ($x_i=0$) increases it, providing evidence for improvement.\n\nThe CUSUM statistic, $S_t$, is accumulated sequentially for each case $t$ at or after the intervention ($t \\ge t_{\\mathrm{QI}}$). It is defined by the recursion:\n$$S_t = \\max(0, S_{t-1} + w_t)$$\nThe CUSUM process is initialized with $S_{t_{\\mathrm{QI}}-1} = 0$. The $\\max(0, \\cdot)$ operation ensures the CUSUM resets to $0$ if the cumulative evidence trends against improvement, making it a one-sided test for improvement.\n\nA signal for improvement is triggered when the CUSUM statistic $S_t$ crosses a predefined upper decision threshold, $h_+$. This threshold is derived from the Type I error rate $\\alpha$ (the probability of a false signal) and the Type II error rate $\\beta$ (the probability of missing a true improvement). The upper and lower thresholds for a two-sided SPRT are:\n$$h_+ = \\log\\left(\\frac{1-\\beta}{\\alpha}\\right)$$\n$$h_- = \\log\\left(\\frac{\\beta}{1-\\alpha}\\right)$$\nFor this one-sided test for improvement, a signal occurs only when $S_t \\ge h_+$. The problem requires the calculation of both $h_+$ and $h_-$.\n\nThe algorithmic procedure for each test case is as follows:\n\n1.  **Initialization**: Given the parameters $(p_0, p_1, \\alpha, \\beta, t_{\\mathrm{QI}}, w, \\{x_i\\}_{i=0}^{n-1})$, first calculate the constant values for the decision thresholds $h_+$ and $h_-$ using the natural logarithm. Also, pre-calculate the two possible values for the log-likelihood increment: $w_0$ for $x_i=0$ and $w_1$ for $x_i=1$.\n\n2.  **CUSUM Monitoring**: Initialize the CUSUM statistic $S=0$ and the signal time $t^\\star = -1$. Iterate through the patient outcomes from the index $t = t_{\\mathrm{QI}}$ to the end of the data series, $n-1$. In each step:\n    a.  Determine the log-likelihood increment $w_t$ based on the outcome $x_t$.\n    b.  Update the CUSUM statistic: $S \\leftarrow \\max(0, S + w_t)$.\n    c.  Check for an improvement signal: If $S \\ge h_+$ and $t^\\star$ has not yet been set (i.e., $t^\\star = -1$), record the current index as the signal time: $t^\\star \\leftarrow t$.\n\n3.  **Sustained Improvement Assessment**: After iterating through all available data, evaluate if the detected improvement is sustained. This requires three conditions to be met:\n    a.  An improvement signal must have been detected, i.e., $t^\\star \\neq -1$.\n    b.  There must be sufficient follow-up data. Specifically, the analysis window requires $w$ observations following the signal, so the data must extend at least to index $t^\\star + w$. This check is formally $t^\\star + w \\le n-1$, where $n$ is the total number of observations.\n    c.  The empirical complication rate, $\\hat{p}$, in the $w$ cases immediately following the signal must be no greater than the target rate $p_1$. The empirical rate is calculated as:\n    $$\\hat{p} = \\frac{1}{w}\\sum_{i=t^\\star+1}^{t^\\star+w} x_i$$\n    If all three conditions are true, the improvement is declared sustained. Otherwise, it is not.\n\n4.  **Output Formulation**: Combine the results for the test case into a list of the form $[t^\\star, \\text{sustained}, \\text{round}(h_+, 6), \\text{round}(h_-, 6)]$, where `sustained` is a boolean value. This process is repeated for all provided test cases.\n\nThis structured approach ensures that the CUSUM chart is correctly implemented and that the criteria for signal detection and sustained improvement are rigorously applied according to the problem specification.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the one-sided CUSUM procedure to monitor postoperative\n    complication rates and detect sustained improvements.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"p0\": 0.15, \"p1\": 0.07, \"alpha\": 0.20, \"beta\": 0.20,\n            \"t_qi\": 20, \"w\": 15,\n            \"x\": [0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0, 0,0,0,0,0,0,1, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        },\n        {\n            \"id\": \"B\",\n            \"p0\": 0.15, \"p1\": 0.10, \"alpha\": 0.10, \"beta\": 0.20,\n            \"t_qi\": 20, \"w\": 10,\n            \"x\": [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0, 0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0]\n        },\n        {\n            \"id\": \"C\",\n            \"p0\": 0.25, \"p1\": 0.10, \"alpha\": 0.10, \"beta\": 0.10,\n            \"t_qi\": 10, \"w\": 20,\n            \"x\": [0,1,0,0,1,0,0,0,1,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        },\n        {\n            \"id\": \"D\",\n            \"p0\": 0.20, \"p1\": 0.05, \"alpha\": 0.15, \"beta\": 0.15,\n            \"t_qi\": 30, \"w\": 25,\n            \"x\": [0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        p0 = case[\"p0\"]\n        p1 = case[\"p1\"]\n        alpha = case[\"alpha\"]\n        beta = case[\"beta\"]\n        t_qi = case[\"t_qi\"]\n        w_sustained = case[\"w\"]\n        x_seq = case[\"x\"]\n        n = len(x_seq)\n\n        # 1. Calculate thresholds and log-likelihood increments\n        h_plus = np.log((1 - beta) / alpha)\n        h_minus = np.log(beta / (1 - alpha))\n\n        w_comp = np.log(p1 / p0) # Increment for x_i = 1\n        w_no_comp = np.log((1 - p1) / (1 - p0)) # Increment for x_i = 0\n        \n        # 2. CUSUM monitoring\n        s_cusum = 0.0\n        t_star = -1\n        \n        for t in range(t_qi, n):\n            w_t = w_comp if x_seq[t] == 1 else w_no_comp\n            s_cusum = max(0, s_cusum + w_t)\n            \n            if s_cusum >= h_plus and t_star == -1:\n                t_star = t\n\n        # 3. Sustained improvement assessment\n        sustained = False\n        if t_star != -1:\n            # Check for sufficient follow-up data: the window must end at or before the last data point\n            if t_star + w_sustained  n:\n                window_start = t_star + 1\n                window_end = t_star + w_sustained + 1\n                complications_in_window = sum(x_seq[window_start:window_end])\n                p_hat = complications_in_window / w_sustained\n                \n                if p_hat = p1:\n                    sustained = True\n\n        # 4. Format output\n        case_result = [\n            t_star,\n            sustained,\n            round(h_plus, 6),\n            round(h_minus, 6)\n        ]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    per_case_strings = []\n    for res in all_results:\n        sustained_str = 'true' if res[1] else 'false'\n        h_plus_str = f\"{res[2]:.6f}\"\n        h_minus_str = f\"{res[3]:.6f}\"\n        s = f\"[{res[0]},{sustained_str},{h_plus_str},{h_minus_str}]\"\n        per_case_strings.append(s)\n    final_output_string = f\"[{','.join(per_case_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}