{
    "hands_on_practices": [
        {
            "introduction": "现实世界的数据往往是杂乱无章的。电子健康记录 (EHR) 中的一个常见问题是，同一项化验检查可能以不同的单位记录。本练习将向您展示如何执行一个关键的数据清洗步骤——单位统一化，并亲眼见证如果不这样做，会如何严重扭曲如估算肾小球滤过率 (eGFR) 这类临床计算的结果 ()。",
            "id": "4862785",
            "problem": "电子健康记录 (EHR) 数据经常包含在不同时间、地点或仪器上记录的、单位不同的实验室测量值。为了生成关于肾功能的真实世界证据，这些测量值必须在应用临床验证的公式之前，统一到一个通用单位。本问题要求您实现单位统一，并使用慢性肾脏病流行病学合作组织 (CKD-EPI) 2021年基于肌酐的公式计算估算肾小球滤过率 (eGFR)，然后量化单位统一对分布的影响。\n\n基本原理：\n- 质量浓度和物质的量浓度之间的测量单位转换是一条经过充分检验的规则。对于血清肌酐，公认的换算关系是 $1\\ \\mathrm{mg/dL} = 88.4\\ \\mathrm{\\mu mol/L}$，这意味着 $$\\mathrm{mg/dL} = \\frac{\\mathrm{\\mu mol/L}}{88.4}.$$\n- CKD-EPI 公式是一个经过充分检验的临床公式，它将血清肌酐、年龄和性别映射到以 $\\mathrm{mL/min/1.73\\,m^2}$ 为单位的 eGFR；使用该公式时，血清肌酐必须以 $\\mathrm{mg/dL}$ 为单位。\n- 两个经验分布之间的 Kolmogorov–Smirnov (KS) 距离定义为 $$D = \\sup_x \\left|F_n(x) - G_m(x)\\right|,$$ 其中 $F_n$ 和 $G_m$ 分别是大小为 $n$ 和 $m$ 的样本的经验累积分布函数。\n\n任务：\n- 对于每个数据集，计算两种版本的 eGFR（单位为 $\\mathrm{mL/min/1.73\\,m^2}$）：\n    1. 一个“朴素”版本，其中无论记录的单位是什么，每个记录的肌酐值都被视为以 $\\mathrm{mg/dL}$ 为单位。\n    2. 一个“统一”版本，其中记录为 $\\mathrm{\\mu mol/L}$ 的值在计算 eGFR 之前，使用 $\\mathrm{mg/dL} = \\mathrm{\\mu mol/L} / 88.4$ 转换为 $\\mathrm{mg/dL}$。\n- 使用适用于成人的 CKD-EPI 2021 肌酐公式，不含种族系数。按照该公式的定义，实现标准的性别特异性常数和年龄依赖性。血清肌酐必须以 $\\mathrm{mg/dL}$ 为单位处理。\n- 对于每个数据集，计算以下汇总统计数据，以比较朴素 eGFR 分布和统一 eGFR 分布：\n    1. 平均 eGFR 的差异，定义为 $\\overline{eGFR}_{\\text{naive}} - \\overline{eGFR}_{\\text{harmonized}}$（以 $\\mathrm{mL/min/1.73\\,m^2}$ 表示）。\n    2. eGFR 中位数的差异，定义为 $\\operatorname{median}(eGFR_{\\text{naive}}) - \\operatorname{median}(eGFR_{\\text{harmonized}})$（以 $\\mathrm{mL/min/1.73\\,m^2}$ 表示）。\n    3. 朴素 eGFR 样本和统一 eGFR 样本之间的 Kolmogorov–Smirnov 距离 $D$。\n\n角度单位不适用。所有 eGFR 量均以 $\\mathrm{mL/min/1.73\\,m^2}$ 表示，并将数值输出报告为十进制浮点数。将最终输出中的每个报告浮点数四舍五入到 $4$ 位小数。\n\n输入数据（嵌入在程序中；无外部输入）：\n每条记录都是一个元组 $(\\text{年龄（岁）}, \\text{性别}, \\text{血清肌酐值}, \\text{单位})$，其中性别为 $\\text{\"F\"}$（女性）或 $\\text{\"M\"}$（男性）。测试套件包含三个数据集：\n\n- 数据集 1（混合单位，典型值）：\n    - (65, \"F\", 1.1, \"mg/dL\")\n    - (50, \"M\", 90, \"μmol/L\")\n    - (80, \"F\", 1.8, \"mg/dL\")\n    - (40, \"M\", 75, \"μmol/L\")\n    - (30, \"F\", 0.7, \"mg/dL\")\n    - (70, \"M\", 110, \"μmol/L\")\n    - (55, \"F\", 95, \"μmol/L\")\n    - (45, \"M\", 1.3, \"mg/dL\")\n- 数据集 2（所有值已为 $\\mathrm{mg/dL}$）：\n    - (18, \"M\", 0.9, \"mg/dL\")\n    - (22, \"F\", 0.6, \"mg/dL\")\n    - (90, \"M\", 2.5, \"mg/dL\")\n    - (75, \"F\", 1.2, \"mg/dL\")\n    - (65, \"M\", 1.0, \"mg/dL\")\n    - (50, \"F\", 0.8, \"mg/dL\")\n- 数据集 3（所有值均为 $\\mathrm{\\mu mol/L}$）：\n    - (35, \"F\", 80, \"μmol/L\")\n    - (55, \"M\", 120, \"μmol/L\")\n    - (85, \"F\", 200, \"μmol/L\")\n    - (45, \"M\", 70, \"μmol/L\")\n    - (60, \"F\", 100, \"μmol/L\")\n    - (28, \"M\", 60, \"μmol/L\")\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[$数据集 1 的平均值差异, 数据集 1 的中位数差异, 数据集 1 的 KS 距离, 数据集 2 的平均值差异, 数据集 2 的中位数差异, 数据集 2 的 KS 距离, 数据集 3 的平均值差异, 数据集 3 的中位数差异, 数据集 3 的 KS 距离$]$。\n将每个浮点数四舍五入到 $4$ 位小数。数值代表平均值和中位数差异（单位为 $\\mathrm{mL/min/1.73\\,m^2}$）以及 KS 距离 $D$（无单位十进制数）。",
            "solution": "该问题要求实现一个数据处理流程，以展示在使用电子健康记录 (EHR) 数据进行临床计算时单位统一的重要性。该流程涉及三个关键阶段：数据统一、临床模型应用和统计比较。\n\n首先，我们必须定义用于估算肾小球滤过率 (eGFR) 的计算模型。问题指定使用慢性肾脏病流行病学合作组织 (CKD-EPI) 2021年基于肌酐的公式，这是当前评估成人肾功能的标准。该公式将血清肌酐 ($S_{Cr}$)、年龄和性别与 eGFR 关联起来。一个关键的先决条件是血清肌酐的单位必须是毫克/分升 ($\\mathrm{mg/dL}$)。2021年的公式，在排除基于种族的系数后，表示为：\n$$ eGFR = 142 \\times \\min\\left(\\frac{S_{Cr}}{k}, 1\\right)^\\alpha \\times \\max\\left(\\frac{S_{Cr}}{k}, 1\\right)^{-1.200} \\times 0.9938^{Age} \\times F_{sex} $$\n参数 $k$、$\\alpha$ 和 $F_{sex}$ 是性别依赖的。对于女性，$k = 0.7$，$\\alpha = -0.241$，性别特异性因子 $F_{sex} = 1.012$。对于男性，$k = 0.9$，$\\alpha = -0.302$，$F_{sex} = 1.0$。这个单一、紧凑的公式正确地捕捉了原始 CKD-EPI 定义的分段特性。\n\n其次，我们处理单位统一的核心任务。输入数据可能包含两种不同单位的血清肌酐值：质量浓度 ($\\mathrm{mg/dL}$) 和物质的量浓度 ($\\mathrm{\\mu mol/L}$)。要使用 CKD-EPI 公式，所有值都必须以 $\\mathrm{mg/dL}$ 为单位。问题提供了标准换算因子：$1\\ \\mathrm{mg/dL} = 88.4\\ \\mathrm{\\mu mol/L}$。因此，一个以 $\\mathrm{\\mu mol/L}$ 为单位的肌酐值 $S_{Cr, \\mu mol/L}$ 可以使用以下公式转换为以 $\\mathrm{mg/dL}$ 为单位的 $S_{Cr, mg/dL}$：\n$$ S_{Cr, mg/dL} = \\frac{S_{Cr, \\mu mol/L}}{88.4} $$\n问题要求计算两组 eGFR 值。“统一”组是通过首先对任何以 $\\mathrm{\\mu mol/L}$ 记录的肌酐值应用此转换来计算的，从而确保 CKD-EPI 公式的所用输入都正确无误。“朴素”组则是通过忽略所标示的单位，并将所有肌酐数值当作已经是以 $\\mathrm{mg/dL}$ 为单位来计算。这样设计是为了模拟一种常见的数据处理错误并量化其影响。\n\n第三，我们必须量化朴素 eGFR 值分布与统一 eGFR 值分布之间的差异。指定了三种统计度量：\n1.  平均值差异：$\\Delta_{\\text{mean}} = \\overline{eGFR}_{\\text{naive}} - \\overline{eGFR}_{\\text{harmonized}}$。非零值表示由单位错误引起的分布中心趋势的系统性偏移。\n2.  中位数差异：$\\Delta_{\\text{median}} = \\operatorname{median}(eGFR_{\\text{naive}}) - \\operatorname{median}(eGFR_{\\text{harmonized}})$。这提供了一种衡量中心趋势偏移的稳健度量，比平均值对异常值更不敏感。\n3.  Kolmogorov–Smirnov (KS) 距离：$D = \\sup_x |F_{\\text{naive}}(x) - F_{\\text{harmonized}}(x)|$，其中 $F$ 表示样本的经验累积分布函数 (ECDF)。KS 距离测量两个样本 ECDF 之间的最大绝对差，为它们的分布差异提供了一个全局度量。$D=0$ 的值意味着分布完全相同，而 $D=1$ 则意味着分布之间没有重叠。\n\n算法的执行过程是遍历每个提供的数据集。对于每个数据集，我们遍历每条患者记录。对于每位患者，我们计算两个 eGFR 值：一个使用朴素肌酐值，另一个使用统一后的肌酐值。处理完一个数据集中的所有患者后，我们收集得到的两组 eGFR 值。然后，我们使用标准的数值库函数来计算每组的平均值、每组的中位数以及两组之间的 KS 距离。最后，我们计算所需的差异，并格式化所有结果以供输出。对于数据集 2，其中所有单位都已是 $\\mathrm{mg/dL}$，朴素计算和统一计算是相同的，正确地得出差异和 KS 距离为 $0$。对于数据集 3，其中所有单位都是 $\\mathrm{\\mu mol/L}$，朴素计算使用的肌酐值大约是正确值的 88.4 倍，导致 eGFR 值极低，不符合生理常规，并与统一后的结果产生巨大差异，从而导致 KS 距离为 $1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import ks_2samp\n\ndef solve():\n    \"\"\"\n    Solves the eGFR harmonization problem by calculating naive and harmonized eGFR values\n    and comparing their distributions for three datasets.\n    \"\"\"\n\n    # Define the datasets as specified in the problem statement.\n    datasets = [\n        # Dataset 1 (mixed units)\n        [\n            (65, \"F\", 1.1, \"mg/dL\"),\n            (50, \"M\", 90, \"μmol/L\"),\n            (80, \"F\", 1.8, \"mg/dL\"),\n            (40, \"M\", 75, \"μmol/L\"),\n            (30, \"F\", 0.7, \"mg/dL\"),\n            (70, \"M\", 110, \"μmol/L\"),\n            (55, \"F\", 95, \"μmol/L\"),\n            (45, \"M\", 1.3, \"mg/dL\"),\n        ],\n        # Dataset 2 (all mg/dL)\n        [\n            (18, \"M\", 0.9, \"mg/dL\"),\n            (22, \"F\", 0.6, \"mg/dL\"),\n            (90, \"M\", 2.5, \"mg/dL\"),\n            (75, \"F\", 1.2, \"mg/dL\"),\n            (65, \"M\", 1.0, \"mg/dL\"),\n            (50, \"F\", 0.8, \"mg/dL\"),\n        ],\n        # Dataset 3 (all μmol/L)\n        [\n            (35, \"F\", 80, \"μmol/L\"),\n            (55, \"M\", 120, \"μmol/L\"),\n            (85, \"F\", 200, \"μmol/L\"),\n            (45, \"M\", 70, \"μmol/L\"),\n            (60, \"F\", 100, \"μmol/L\"),\n            (28, \"M\", 60, \"μmol/L\"),\n        ],\n    ]\n\n    def ckd_epi_2021(scr_mgdl, age, sex):\n        \"\"\"\n        Calculates eGFR using the CKD-EPI 2021 creatinine equation.\n        \n        Args:\n            scr_mgdl (float): Serum creatinine in mg/dL.\n            age (int): Age in years.\n            sex (str): \"F\" for female, \"M\" for male.\n\n        Returns:\n            float: Estimated GFR in mL/min/1.73m^2.\n        \"\"\"\n        if sex == \"F\":\n            k = 0.7\n            alpha = -0.241\n            sex_factor = 1.012\n        else:  # sex == \"M\"\n            k = 0.9\n            alpha = -0.302\n            sex_factor = 1.0\n\n        scr_over_k = scr_mgdl / k\n        min_term = min(scr_over_k, 1.0)**alpha\n        max_term = max(scr_over_k, 1.0)**(-1.200)\n        age_term = 0.9938**age\n        egfr = 142 * min_term * max_term * age_term * sex_factor\n        return egfr\n\n    final_results = []\n    \n    # Conversion factor from μmol/L to mg/dL is division by 88.4\n    CONVERSION_FACTOR = 88.4\n\n    for dataset in datasets:\n        egfr_naive = []\n        egfr_harmonized = []\n\n        for age, sex, scr_value, unit in dataset:\n            # 1. Naive eGFR calculation\n            # Treats all creatinine values as if they were in mg/dL.\n            naive_egfr_val = ckd_epi_2021(scr_value, age, sex)\n            egfr_naive.append(naive_egfr_val)\n\n            # 2. Harmonized eGFR calculation\n            # Converts μmol/L to mg/dL before calculation.\n            if unit == \"μmol/L\":\n                harmonized_scr = scr_value / CONVERSION_FACTOR\n            else: # unit == \"mg/dL\"\n                harmonized_scr = scr_value\n            \n            harmonized_egfr_val = ckd_epi_2021(harmonized_scr, age, sex)\n            egfr_harmonized.append(harmonized_egfr_val)\n        \n        # Convert lists to NumPy arrays for vectorized operations\n        egfr_naive_arr = np.array(egfr_naive)\n        egfr_harmonized_arr = np.array(egfr_harmonized)\n\n        # 3. Compute summary statistics\n        # Difference in means\n        mean_diff = np.mean(egfr_naive_arr) - np.mean(egfr_harmonized_arr)\n        \n        # Difference in medians\n        median_diff = np.median(egfr_naive_arr) - np.median(egfr_harmonized_arr)\n        \n        # Kolmogorov-Smirnov distance\n        ks_distance = ks_2samp(egfr_naive_arr, egfr_harmonized_arr).statistic\n        \n        final_results.extend([mean_diff, median_diff, ks_distance])\n\n    # Format the final output string as required\n    # Each float must be rounded to 4 decimal places.\n    formatted_results = [f\"{val:.4f}\" for val in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生成可靠的真实世界证据不仅需要干净的数据，还需要严谨的研究设计。本练习将探讨观察性研究中一个臭名昭著的陷阱——“永生时间偏倚”(immortal time bias)，这种偏倚会错误地使一种治疗看起来比实际效果更好 ()。通过比较一种有缺陷的分析方法和一种正确的时间更新方法，您将学会如何识别并纠正这种隐蔽但至关重要的偏倚。",
            "id": "4862751",
            "problem": "给定一个由电子健康记录 (EHR) 数据表示的队列，其中每个个体都有一个基线时间 $t=0$ 个月，一个治疗开始时间 $\\tau_i$（如果个体从未开始治疗，则该值可能为 $\\infty$），一个从基线到事件发生或删失的随访时间 $y_i$（以月为单位），以及一个二元事件指示符 $\\delta_i \\in \\{0,1\\}$，其中 $\\delta_i=1$ 表示在时间 $y_i$ 发生事件，$\\delta_i=0$ 表示在时间 $y_i$ 发生删失。假设在暴露状态的条件下，一个组内的风险随时间大致恒定，因此任何暴露组 $g \\in \\{0,1\\}$ 的经验风险可通过 $\\hat{h}_g = E_g / T_g$ 来估计，其中 $E_g$ 是在组 $g$ 中观察到的事件总数，$T_g$ 是个体在组 $g$ 期间累积的总人时（以月为单位）。将风险比定义为 $\\widehat{HR} = \\hat{h}_1 / \\hat{h}_0$。您必须计算两次 $\\widehat{HR}$：第一次在时间固定暴露定义下，第二次在时间更新暴露定义下，然后量化在时间固定暴露定义下由永生时间引入的偏倚。\n\n时间固定暴露定义根据个体在随访期间是否曾开始治疗来进行分类。具体来说，对于时间固定分析，如果 $\\tau_i  \\infty$，则将个体分配到暴露组 $g=1$；如果 $\\tau_i = \\infty$，则分配到非暴露组 $g=0$。对于此时间固定分析，计算 $T_1^{\\mathrm{fixed}}$ 为所有 $\\tau_i  \\infty$ 的个体的 $y_i$ 之和，计算 $T_0^{\\mathrm{fixed}}$ 为所有 $\\tau_i = \\infty$ 的个体的 $y_i$ 之和。计算 $E_1^{\\mathrm{fixed}}$ 为所有 $\\tau_i  \\infty$ 的个体的 $\\delta_i$ 之和，计算 $E_0^{\\mathrm{fixed}}$ 为所有 $\\tau_i = \\infty$ 的个体的 $\\delta_i$ 之和。则时间固定的风险比为 $\\widehat{HR}_{\\mathrm{fixed}} = \\left(E_1^{\\mathrm{fixed}} / T_1^{\\mathrm{fixed}}\\right) \\big/ \\left(E_0^{\\mathrm{fixed}} / T_0^{\\mathrm{fixed}}\\right)$。\n\n时间更新暴露定义将暴露视为一个时变协变量。对于具有有限 $\\tau_i$ 的个体，非暴露人时为区间 $[0, \\min(y_i,\\tau_i))$，如果 $\\tau_i  y_i$，则暴露人时为区间 $[\\tau_i, y_i)$。对于 $\\tau_i = \\infty$ 的个体，所有的人时 $[0, y_i)$ 都是非暴露的。将事件分配到紧邻 $y_i$ 之前的暴露状态；如果 $\\tau_i = y_i$，则将该事件计为非暴露事件。形式上，通过对所有个体求和上述适当的区间长度（以月为单位）来计算 $T_0^{\\mathrm{upd}}$ 和 $T_1^{\\mathrm{upd}}$，并使用以下规则将事件分配到 $y_i$ 之前活跃的状态来计算 $E_0^{\\mathrm{upd}}$ 和 $E_1^{\\mathrm{upd}}$：如果 $\\delta_i=1$ 且 $y_i \\le \\tau_i$，则 $E_0^{\\mathrm{upd}}$ 增加 $1$；如果 $\\delta_i=1$ 且 $y_i > \\tau_i$，则 $E_1^{\\mathrm{upd}}$ 增加 $1$；如果 $\\delta_i=0$，则不增加任何 $E_g$。则时间更新的风险比为 $\\widehat{HR}_{\\mathrm{upd}} = \\left(E_1^{\\mathrm{upd}} / T_1^{\\mathrm{upd}}\\right) \\big/ \\left(E_0^{\\mathrm{upd}} / T_0^{\\mathrm{upd}}\\right)$。\n\n为了量化永生时间偏倚，计算相对偏倚为 $b = \\left(\\widehat{HR}_{\\mathrm{fixed}} - \\widehat{HR}_{\\mathrm{upd}}\\right) / \\widehat{HR}_{\\mathrm{upd}}$，以小数表示。所有时间量必须以月为单位处理，风险比和偏倚是无单位的。您的程序必须输出每个风险比（四舍五入到3位小数）和每个偏倚（四舍五入到3位小数）。\n\n使用以下测试队列套件。每个队列是一个由元组 $(\\tau_i, y_i, \\delta_i)$ 给出的个体列表，其中所有时间都以月为单位，$\\tau_i = \\infty$ 表示从未接受治疗，$y_i$ 是事件或删失时间，$\\delta_i \\in \\{0,1\\}$ 是事件指示符。\n\n测试用例1（标准路径，混合的开始时间，部分删失）：\n- 患者：$\\left[(2, 10, 1), (5, 12, 0), (\\infty, 8, 1), (0, 9, 1), (\\infty, 7, 0), (3, 6, 1)\\right]$。\n\n测试用例2（较晚的治疗开始时间产生大量永生时间，两组均有事件）：\n- 患者：$\\left[(9, 12, 1), (10, 12, 0), (11, 14, 1), (\\infty, 6, 1), (\\infty, 12, 0)\\right]$。\n\n测试用例3（事件恰好发生在治疗开始边界，立即开始治疗者和从未治疗者）：\n- 患者：$\\left[(5, 5, 1), (0, 8, 0), (4, 9, 1), (\\infty, 7, 1), (\\infty, 10, 0)\\right]$。\n\n测试用例4（早期开始治疗者和从未治疗者的混合）：\n- 患者：$\\left[(0, 4, 1), (1, 6, 0), (2, 3, 1), (\\infty, 5, 1), (\\infty, 6, 0)\\right]$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，将4个测试用例的三元组 $\\left[\\widehat{HR}_{\\mathrm{fixed}}, \\widehat{HR}_{\\mathrm{upd}}, b\\right]$ 按顺序展平。例如，输出格式必须为 $\\left[\\widehat{HR}_{\\mathrm{fixed}}^{(1)}, \\widehat{HR}_{\\mathrm{upd}}^{(1)}, b^{(1)}, \\widehat{HR}_{\\mathrm{fixed}}^{(2)}, \\widehat{HR}_{\\mathrm{upd}}^{(2)}, b^{(2)}, \\widehat{HR}_{\\mathrm{fixed}}^{(3)}, \\widehat{HR}_{\\mathrm{upd}}^{(3)}, b^{(3)}, \\widehat{HR}_{\\mathrm{fixed}}^{(4)}, \\widehat{HR}_{\\mathrm{upd}}^{(4)}, b^{(4)}\\right]$，所有值都四舍五入到3位小数。时间必须以月为单位处理，风险比和偏倚是无单位的浮点数。",
            "solution": "用户提供的问题在科学上基于生物统计学和流行病学的原理，特别是关于生存分析和被称为永生时间偏倚的方法学伪迹。该问题陈述清晰，为所有计算提供了明确的数学定义和完整的数据。没有矛盾、歧义或事实错误。因此，该问题是有效的，并将提供解决方案。\n\n该问题的核心在于比较两种在治疗开始延迟的队列研究中定义暴露的不同方法。目标是在每种定义下计算风险比（$\\widehat{HR}$）并量化其差异，这阐明了永生时间偏倚的概念。\n\n**基本概念**\n\n风险率 $h(t)$ 表示在存活至时间 $t$ 的条件下，在时间 $t$ 发生事件的瞬时风险。在这个问题中，我们假设在特定暴露组 $g \\in \\{0, 1\\}$ 内风险是恒定的，其中 $g=0$ 表示非暴露状态，$g=1$ 表示暴露状态。这个假设允许我们凭经验估计风险为：\n$$\n\\hat{h}_g = \\frac{E_g}{T_g}\n$$\n其中 $E_g$ 是在组 $g$ 中观察到的事件总数，$T_g$ 是个体在组 $g$ 期间累积的总人时（在本例中为人时-月）。\n\n风险比（$\\widehat{HR}$）是暴露组与非暴露组的风险之比：\n$$\n\\widehat{HR} = \\frac{\\hat{h}_1}{\\hat{h}_0}\n$$\n$\\widehat{HR} > 1$ 表明暴露与事件风险增加相关，$\\widehat{HR}  1$ 表明具有保护性关联，而 $\\widehat{HR} = 1$ 表明没有关联。\n\n**分析1：时间固定暴露定义**\n\n这是一种朴素且方法学上有缺陷的方法。个体根据其整个历史被分入一个暴露组，具体取决于他们是否*曾经*开始治疗。\n- **暴露组 ($g=1$)**：具有有限治疗开始时间 $\\tau_i  \\infty$ 的个体。\n- **非暴露组 ($g=0$)**：从未开始治疗的个体 $\\tau_i = \\infty$。\n\n对于此分析，我们计算每个组的总事件和总人时：\n- $E_1^{\\mathrm{fixed}} = \\sum_{i: \\tau_i  \\infty} \\delta_i$\n- $T_1^{\\mathrm{fixed}} = \\sum_{i: \\tau_i  \\infty} y_i$\n- $E_0^{\\mathrm{fixed}} = \\sum_{i: \\tau_i = \\infty} \\delta_i$\n- $T_0^{\\mathrm{fixed}} = \\sum_{i: \\tau_i = \\infty} y_i$\n\n得到的时间固定风险比是：\n$$\n\\widehat{HR}_{\\mathrm{fixed}} = \\frac{E_1^{\\mathrm{fixed}} / T_1^{\\mathrm{fixed}}}{E_0^{\\mathrm{fixed}} / T_0^{\\mathrm{fixed}}}\n$$\n\n这里的关键缺陷是人时的错误归属。对于在 $\\tau_i > 0$ 时开始治疗的个体，从基线 $t=0$ 到 $\\tau_i$ 的时段是相对于暴露状态的“永生时间”。该个体*必须*无事件存活才能达到 $\\tau_i$ 并接受治疗。通过将其整个随访时间 $y_i$ 归类为“暴露”人时，我们包含了在此期间不可能发生暴露事件的一段时间（$[0, \\tau_i)$）。这种做法人为地增加了分母 $T_1^{\\mathrm{fixed}}$，而没有相应增加分子 $E_1^{\\mathrm{fixed}}$ 的可能性，从而使估计的风险 $\\hat{h}_1^{\\mathrm{fixed}}$ 偏低，并使 $\\widehat{HR}_{\\mathrm{fixed}}$ 偏向于零值1。\n\n**分析2：时间更新暴露定义**\n\n这是正确的方法，将暴露视为一个时变协变量。一个个体可以为非暴露和暴露状态都贡献人时。\n- 对于个体 $i$，时间区间 $[0, \\min(y_i, \\tau_i))$ 是非暴露人时。\n- 如果 $\\tau_i  y_i$，时间区间 $[\\tau_i, y_i)$ 是暴露人时。\n\n时间更新分析的总人时通过对所有个体的这些贡献求和来计算：\n- $T_0^{\\mathrm{upd}} = \\sum_{i} \\min(y_i, \\tau_i)$\n- $T_1^{\\mathrm{upd}} = \\sum_{i} \\max(0, y_i - \\tau_i)$\n\n事件被分配到个体在事件时间 $y_i$ 之前所处的暴露状态。\n- 如果事件（$\\delta_i=1$）在治疗开始时或之前发生（$y_i \\le \\tau_i$），则计入非暴露组（$E_0^{\\mathrm{upd}}$）。\n- 如果事件（$\\delta_i=1$）在治疗开始后发生（$y_i > \\tau_i$），则计入暴露组（$E_1^{\\mathrm{upd}}$）。\n\n在给定模型下，正确估计的时间更新风险比是：\n$$\n\\widehat{HR}_{\\mathrm{upd}} = \\frac{E_1^{\\mathrm{upd}} / T_1^{\\mathrm{upd}}}{E_0^{\\mathrm{upd}} / T_0^{\\mathrm{upd}}}\n$$\n\n**量化永生时间偏倚**\n\n通过将其结果与正确的时间更新结果进行比较，来量化错误的时间固定方法引入的偏倚。相对偏倚 $b$ 由下式给出：\n$$\nb = \\frac{\\widehat{HR}_{\\mathrm{fixed}} - \\widehat{HR}_{\\mathrm{upd}}}{\\widehat{HR}_{\\mathrm{upd}}}\n$$\n$b$ 的负值表示时间固定分析低估了风险比，这是永生时间偏倚的预期方向。\n\n**算法实现**\n\n解决方案将通过一个处理给定患者队列的函数来实现。该函数将执行以下步骤：\n1. 为固定和更新分析初始化计数器：$E_0^{\\mathrm{fixed}}$, $T_0^{\\mathrm{fixed}}$, $E_1^{\\mathrm{fixed}}$, $T_1^{\\mathrm{fixed}}$, $E_0^{\\mathrm{upd}}$, $T_0^{\\mathrm{upd}}$, $E_1^{\\mathrm{upd}}$, $T_1^{\\mathrm{upd}}$，全部设为 $0$。\n2. 遍历队列中的每个患者 $(\\tau_i, y_i, \\delta_i)$。\n3. 对于**时间固定分析**，根据 $\\tau_i$ 对患者进行分类。如果 $\\tau_i  \\infty$，则将 $y_i$ 加到 $T_1^{\\mathrm{fixed}}$，将 $\\delta_i$ 加到 $E_1^{\\mathrm{fixed}}$。如果 $\\tau_i = \\infty$，则将 $y_i$ 加到 $T_0^{\\mathrm{fixed}}$，将 $\\delta_i$ 加到 $E_0^{\\mathrm{fixed}}$。\n4. 对于**时间更新分析**，划分患者的人时。将 $\\min(y_i, \\tau_i)$ 加到 $T_0^{\\mathrm{upd}}$，将 $y_i - \\min(y_i, \\tau_i)$ 加到 $T_1^{\\mathrm{upd}}$。如果 $\\delta_i=1$，则分配事件：如果 $y_i \\le \\tau_i$，则 $E_0^{\\mathrm{upd}}$ 增加1；如果 $y_i > \\tau_i$，则 $E_1^{\\mathrm{upd}}$ 增加1。\n5. 遍历完所有患者后，计算四个风险（$\\hat{h}_0^{\\mathrm{fixed}}, \\hat{h}_1^{\\mathrm{fixed}}, \\hat{h}_0^{\\mathrm{upd}}, \\hat{h}_1^{\\mathrm{upd}}$），注意处理人时分母为0时可能出现的除零错误。\n6. 计算 $\\widehat{HR}_{\\mathrm{fixed}}$ 和 $\\widehat{HR}_{\\mathrm{upd}}$。\n7. 计算相对偏倚 $b$。\n8. 返回三元组 ($\\widehat{HR}_{\\mathrm{fixed}}, \\widehat{HR}_{\\mathrm{upd}}, b$)。\n\n此过程将应用于每个测试用例，结果将被收集并按规定格式化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes time-fixed and time-updated hazard ratios and the resulting\n    relative bias for several EHR cohorts to demonstrate immortal time bias.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (happy path, mixed initiation times, some censoring)\n        [(2, 10, 1), (5, 12, 0), (np.inf, 8, 1), (0, 9, 1), (np.inf, 7, 0), (3, 6, 1)],\n        \n        # Test Case 2 (late treatment initiation creating substantial immortal time)\n        [(9, 12, 1), (10, 12, 0), (11, 14, 1), (np.inf, 6, 1), (np.inf, 12, 0)],\n        \n        # Test Case 3 (event at initiation boundary, immediate initiators)\n        [(5, 5, 1), (0, 8, 0), (4, 9, 1), (np.inf, 7, 1), (np.inf, 10, 0)],\n        \n        # Test Case 4 (early initiations and never-treated mix)\n        [(0, 4, 1), (1, 6, 0), (2, 3, 1), (np.inf, 5, 1), (np.inf, 6, 0)],\n    ]\n\n    all_results = []\n\n    for cohort in test_cases:\n        # --- Time-Fixed Analysis ---\n        E0_fixed, T0_fixed = 0.0, 0.0\n        E1_fixed, T1_fixed = 0.0, 0.0\n\n        for tau_i, y_i, delta_i in cohort:\n            if tau_i == np.inf:  # Unexposed group (never-treated)\n                T0_fixed += y_i\n                E0_fixed += delta_i\n            else:  # Exposed group (ever-treated)\n                T1_fixed += y_i\n                E1_fixed += delta_i\n\n        h0_fixed = E0_fixed / T0_fixed if T0_fixed  0 else 0.0\n        h1_fixed = E1_fixed / T1_fixed if T1_fixed  0 else 0.0\n        \n        hr_fixed = h1_fixed / h0_fixed if h0_fixed  0 else np.inf\n\n        # --- Time-Updated Analysis ---\n        E0_upd, T0_upd = 0.0, 0.0\n        E1_upd, T1_upd = 0.0, 0.0\n\n        for tau_i, y_i, delta_i in cohort:\n            # Partition person-time\n            unexposed_pt = min(y_i, tau_i)\n            exposed_pt = y_i - unexposed_pt\n            \n            T0_upd += unexposed_pt\n            T1_upd += exposed_pt\n\n            # Allocate events\n            if delta_i == 1:\n                if y_i = tau_i:\n                    E0_upd += 1\n                else:  # y_i  tau_i\n                    E1_upd += 1\n        \n        h0_upd = E0_upd / T0_upd if T0_upd  0 else 0.0\n        h1_upd = E1_upd / T1_upd if T1_upd  0 else 0.0\n        \n        hr_upd = h1_upd / h0_upd if h0_upd  0 else np.inf\n\n        # --- Bias Calculation ---\n        # The problem cases ensure hr_upd is not zero\n        bias = (hr_fixed - hr_upd) / hr_upd\n        \n        all_results.extend([\n            round(hr_fixed, 3),\n            round(hr_upd, 3),\n            round(bias, 3)\n        ])\n\n    # Format the final output string\n    formatted_results = f\"[{','.join(map(str, all_results))}]\"\n    print(formatted_results)\n\nsolve()\n```"
        }
    ]
}