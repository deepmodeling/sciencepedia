{
    "hands_on_practices": [
        {
            "introduction": "密码学哈希是区块链数据完整性的基石。然而，对于像JSON格式的FHIR资源这样的复杂数据结构，即使临床内容完全相同，其文本表示也可能因密钥顺序或时间戳格式的微小差异而不同，导致哈希值不一致。这项练习  旨在引导你思考如何设计一个“规范化”策略，以确保语义上等同的数据始终产生唯一的、确定性的哈希值，这是构建可靠审计追踪系统的关键一步。",
            "id": "4824515",
            "problem": "一个医院联合体正在部署一个基于区块链的审计追踪系统，用于记录以 JavaScript 对象表示法（JSON）格式表示的快速医疗保健互操作性资源（FHIR）包。他们通过对每个包进行序列化后的加密哈希，将其锚定到账本上。在一次常规的微服务升级后，他们观察到，即使临床内容完全相同，未更改的包的哈希值有时也会发生变化。该联合体希望找到一种策略，以保证语义上等效的 FHIR 包能序列化为唯一的、确定性的字节序列，从而使哈希值保持稳定。\n\n基本事实和定义：\n- 一个加密哈希函数 $H:\\{0,1\\}^*\\rightarrow\\{0,1\\}^n$（例如，安全哈希算法 256 位（SHA-256））是确定性的，并且对每个输入位都敏感：如果两个输入 $x$ 和 $y$ 在任何位上不同，那么 $H(x)\\neq H(y)$ 的概率极高。哈希值的相等要求输入必须逐字节相等。\n- JavaScript 对象表示法（JSON）是一种文本数据格式。JSON 对象是名称/值对的无序集合；不同的实现可能会对相同的抽象值输出不同的键顺序、空格或数字文本形式。数组是有序序列；更改数组元素的顺序会改变其抽象值。\n- 快速医疗保健互操作性资源（FHIR），由第七层健康信息标准组织（HL7）标准化，定义了诸如包条目、标识符、时间戳和元数据等元素的语义。\n\n基于这些情况，请分析当相同的临床内容被重新序列化时导致哈希值不稳定的根本原因，并选择唯一的最佳策略，该策略能为一个 FHIR 包 $B$ 生成一个确定性的序列化 $S(B)$，使得对于 $B$ 的任何语义上等效的 JSON 编码 $e$ 和 $e'$，都有 $S(e)=S(e')$，从而意味着 $H(S(e))=H(S(e'))$。\n\n哪个选项最完整、最正确地阐述了一种确定性序列化策略，该策略能在保留 FHIR 语义的同时，防止虚假的哈希值变化？\n\nA. 定义一个作用于已解析的 FHIR 包的规范化序列化函数 $S$，该函数：\n   - 以 UTF-$8$ 编码和 Unicode 范式之规范化组合（NFC）形式输出文本。\n   - 在输出前按 Unicode 码点顺序对所有 JSON 对象成员的键进行排序；输出键和值时不带无意义的空格（使用单一的规范分隔符）。\n   - 完全保留抽象模型中的数组元素顺序（不重新排序）。\n   - 以小写规范形式输出布尔值和 null 值，以最小十进制形式输出数字，不带前导加号、不必要的前导零或小数点后的尾随零；整数输出时不带小数点。\n   - 使用带有明确“Z”指示符的单一 ISO $8601$ 文本模式，将时间戳规范化为协调世界时（UTC），保留其时间瞬间值；不改变具有临床意义的内容，并且只包含语义上定义的元素（不包含特定于实现的格式化产物）。\n   - 将此输出过程确定性地应用于已解析的数据模型，而不是现有的文本字符串。\n\nB. 将序列化器配置为使用一致的缩进和换行符进行“美化打印”，但将键的迭代留给运行时的原生字典顺序处理，并允许使用平台本地时区渲染时间戳；按原样包含所有元数据字段（例如，资源标识符和服务器分配的版本字段）。\n\nC. 通过对包的 gzip 压缩 JSON 流进行哈希来提高性能；依赖压缩器的默认设置和头部信息，并且不改变键的顺序或时间戳格式，因为压缩应该会平均掉文本上的差异。\n\nD. 通过去除所有空格和换行符来“压缩”JSON，同时保留对象键和数字的原始输出顺序；将数组视为集合，并按资源类型对包条目进行排序，以确保标准化的外观。\n\n选择一项。",
            "solution": "问题要求确定一种策略，以确保以 JavaScript 对象表示法（JSON）表示的、语义上等效的快速医疗保健互操作性资源（FHIR）包，总是能序列化为相同的字节序列。这对于在区块链上为审计追踪生成稳定的加密哈希是必要的。问题的核心在于数据的抽象语义表示与其具体的文本序列化之间的差异。一个加密哈希函数 $H$ 对特定的字节序列进行操作。因此，对于由可能不同的 JSON 编码 $e_1$ 和 $e_2$ 分别表示的两个语义等效的包 $B_1$ 和 $B_2$，我们需要一个规范化序列化函数 $S$，使得 $S(e_1) = S(e_2)$，这反过来又保证了 $H(S(e_1)) = H(S(e_2))$。\n\n正如问题陈述中所指出的，JSON 序列化中不确定性的来源有：\n1.  **无序的对象键**：JSON 规范（RFC 8259）指出，“对象是名称/值对的无序集合”。不同的序列化器可以按不同的顺序输出键（例如，`{\"a\": 1, \"b\": 2}` 与 `{\"b\": 2, \"a\": 1}`）。\n2.  **无意义的空格**：标记之间的空格字符（空格、制表符、换行符）在语义上是无关紧要的，可以添加、删除或更改，而不会改变抽象数据。\n3.  **可变的数字表示**：像 $100$ 这样的数字可以文本形式表示为 $100$、$100.0$ 或 $1 \\times 10^2$（例如 `1E2`）。\n4.  **可变的字符串表示**：由于字符编码（例如 UTF-8 vs. UTF-16）和 Unicode 范式（例如，一个预组合字符 'é' vs. 'e' 加上一个组合重音符）的不同，文本数据可以有不同的字节表示。\n5.  **领域特定的等效性**：在 FHIR 内部，一个特定的时间瞬间可以使用 ISO $8601$ 标准以多种方式表示（例如，`2023-01-01T12:00:00Z` 在语义上等同于 `2023-01-01T07:00:00-05:00`）。\n\n一个有效的策略必须解决所有这些可变性来源，以产生一个唯一的、规范的字节流。该策略必须作用于已解析的、抽象的数据模型，以正确处理语义等效性，而不仅仅是作用于预先存在的序列化的原始文本。\n\n### 逐项分析\n\n**A. 定义一个作用于已解析的 FHIR 包的规范化序列化函数 S，该函数...**\n该选项提出了一个详细的、多步骤的规范化算法。让我们分析其组成部分：\n- **作用于已解析的 FHIR 包**：这是正确的方法。它确保序列化基于抽象的语义结构，而不是基于可能非规范的输入字符串。\n- **使用 UTF-8 和 NFC**：指定单一的字符编码（UTF-8）和单一的 Unicode 范式（规范化组合）。这解决了字符串表示中的歧义。\n- **按 Unicode 码点顺序对所有 JSON 对象成员的键进行排序**：这是为无序对象键强制施加确定性顺序的标准且正确的方法。\n- **输出时不带无意义的空格**：这消除了由格式化和缩进引起的可变性。\n- **保留数组元素顺序**：这一点至关重要。JSON 数组是有序列表，其顺序在 FHIR 中具有语义意义（例如，事务包中条目的顺序）。改变这个顺序会改变数据的含义。这条规则正确地保留了语义。\n- **布尔值、null 和数字的规范形式**：这为原始数据类型提供了严格、无歧义的文本表示，消除了另一个可变性来源。\n- **将时间戳规范化为使用特定 ISO 8601 格式的 UTC 时间**：这解决了 FHIR 中时间表示的领域特定问题。通过将所有时间戳转换为单一时区（UTC）和格式，它确保了语义上等效的时间瞬间具有相同的字符串表示。\n- **仅包含语义上定义的元素**：这可以防止特定于实现或瞬态的元数据影响核心临床内容的哈希值。\n\n该选项系统地解决了 JSON 序列化中所有已知的不确定性来源，其方式与保留 FHIR 数据模型的语义相一致。所描述的过程是一个健壮且完整的规范化方案，类似于已建立的标准，如 JSON 规范化方案（JCS, RFC 8785）。\n**结论：正确**\n\n**B. 将序列化器配置为使用一致的缩进和换行符进行“美化打印”，但将键的迭代留给运行时的原生字典顺序处理，并允许使用平台本地时区渲染时间戳；按原样包含所有元数据字段（例如，资源标识符和服务器分配的版本字段）。**\n这个选项包含几个关键缺陷：\n- **“将键的迭代留给运行时的原生字典顺序处理”**：这是一个主要错误。在不同的编程语言实现、版本，甚至同一程序的连续运行中，字典/哈希映射中键的顺序通常不保证是稳定的。这未能解决键排序问题。\n- **“允许使用平台本地时区渲染时间戳”**：这是另一个重大错误。同一个 UTC 时间瞬间在不同的本地时区（例如 `America/New_York` vs. `Europe/London`）渲染会产生不同的文本字符串，导致语义相同的数据产生不同的哈希值。\n- **“使用一致的缩进进行美化打印”**：这是不够的。虽然它使空格的某一方面保持一致，但它没有创建单一的规范形式，也未能解决更重要的键顺序和数据表示问题。\n**结论：不正确**\n\n**C. 通过对包的 gzip 压缩 JSON 流进行哈希来提高性能；依赖压缩器的默认设置和头部信息，并且不改变键的顺序或时间戳格式，因为压缩应该会平均掉文本上的差异。**\n这个选项基于对加密哈希和数据压缩的根本误解。\n- **“压缩应该会平均掉文本上的差异”**：这是错误的。像 `gzip` 这样的数据压缩算法是确定性的，但它们不会对其输入进行规范化。如果两个输入字节流 $x$ 和 $y$ 不同 ($x \\neq y$)，它们的压缩输出 `gzip(x)` 和 `gzip(y)` 也将不同（除非发生极不可能的压缩冲突）。压缩不会将不同的输入合并成单一的输出。\n- 该策略明确指出**“不改变键的顺序或时间戳格式”**，这意味着它未能解决非确定性序列化的根本原因。\n- 此外，依赖 `gzip` 的默认设置可能会引入新的不确定性来源，因为头部信息（例如，包含时间戳或文件名）和压缩级别在不同实现之间可能会有所不同。\n**结论：不正确**\n\n**D. 通过去除所有空格和换行符来“压缩”JSON，同时保留对象键和数字的原始输出顺序；将数组视为集合，并按资源类型对包条目进行排序，以确保标准化的外观。**\n这个选项有两个致命缺陷：\n- **“保留对象键的原始输出顺序”**：与选项 B 一样，这未能解决键排序问题，而这是不确定性的主要来源。\n- **“将数组视为集合，并按资源类型对包条目进行排序”**：这是一种破坏性操作，会损坏数据。FHIR 包是集合，其中 `entry` 数组中条目的顺序具有语义上的重要性（例如，定义事务中的执行顺序）。将有序数组视为无序集合并对其元素进行重新排序违反了 FHIR 标准并改变了数据的含义。目标是找到一个等效的表示，而不是改变信息内容。\n**结论：不正确**\n\n基于此分析，选项 A 是唯一提供完整、正确且符合标准的策略，以实现 FHIR 包确定性序列化的选项。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在解决了如何为医疗数据生成一致哈希的问题后，下一个实际问题是：成本是多少？将数据“锚定”到公共区块链上会产生实际的经济开销，这通常通过“燃料”（gas）来计量。此练习  提供了一个基于以太坊的成本模型，让你能够亲手计算将医疗数据哈希值存储在链上所需承担的真实货币成本，从而深入理解区块链的经济可行性。",
            "id": "4824526",
            "problem": "一个医院信息系统将快速医疗保健互操作性资源 (FHIR) 锚定在类以太坊区块链上，以提供完整性证明，而无需存储完整的临床有效负荷。对于每个资源，系统在智能合约存储中记录其加密哈希和最低限度的元数据。假设以下基于科学依据的模型。\n\n- 每个资源都由一个单独的交易锚定，并将其哈希和元数据写入合约存储中。哈希值为 $b_{h}=32$ 字节（例如 Keccak-256 这样的 256 位哈希），元数据为 $b_{m}=64$ 字节。区块链存储槽的大小为 $b_{s}=32$ 字节，因此写入 $b_{h}$ 和 $b_{m}$ 每个交易会占用 $s=\\frac{b_{h}}{b_{s}}+\\frac{b_{m}}{b_{s}}$ 个存储槽。\n- 每个新初始化的 32 字节存储槽消耗 $g_{s}=20{,}000$ gas，基础交易成本为 $g_{b}=21{,}000$ gas。忽略存储和基础交易 gas 之外的任何额外操作码开销。假设每个资源都在其自己的交易中锚定。\n- gas 价格为每 gas $p_{g}=20\\times 10^{-9}$ 以太币，以太币价格为每以太币 $p_{\\text{USD}}=1{,}800$ 美元 (USD)。\n\n设资源数量为 $n=1{,}000$。从上述定义和标准的以太坊 gas 核算方法出发，推导在此模型下锚定所有 $n$ 个资源的总链上存储开销（以字节为单位）和总货币成本（以美元为单位）。将美元成本四舍五入到四位有效数字。用美元 (USD) 表示货币成本。以行矩阵的形式提供您的最终答案，其第一个条目是总字节数，第二个条目是美元成本。",
            "solution": "### 解题思路\n该问题要求计算在类以太坊区块链上锚定 $n=1,000$ 个医疗资源的**总存储开销**（以字节为单位）和**总货币成本**（以美元为单位）。我们将分步计算。\n\n#### 第1步：计算单个资源所需的存储空间和存储槽数量\n根据问题陈述，每个资源锚定需要存储：\n- 一个加密哈希：$b_h = 32$ 字节\n- 元数据：$b_m = 64$ 字节\n\n因此，每个资源在链上占用的总存储空间为：\n$$ \\text{存储空间/资源} = b_h + b_m = 32 + 64 = 96 \\text{ 字节} $$\n\n区块链的存储槽大小为 $b_s = 32$ 字节。写入这 96 字节的数据需要占用的存储槽数量为：\n$$ s = \\frac{b_h}{b_s} + \\frac{b_m}{b_s} = \\frac{32}{32} + \\frac{64}{32} = 1 + 2 = 3 \\text{ 个存储槽} $$\n\n#### 第2步：计算单个交易的 Gas 成本\n每个资源通过一个单独的交易进行锚定。该交易的总 Gas 成本由两部分组成：\n- **基础交易成本** ($g_b$)：固定的 $21,000$ Gas。\n- **存储成本**：将数据写入新的存储槽的成本。每个新初始化的 32 字节存储槽消耗 $g_s = 20,000$ Gas。\n\n因此，单个交易的总 Gas 成本为：\n$$ g_{\\text{交易}} = g_b + (s \\times g_s) = 21,000 + (3 \\times 20,000) = 21,000 + 60,000 = 81,000 \\text{ Gas} $$\n\n#### 第3步：计算锚定所有资源的总成本\n我们需要锚定 $n = 1,000$ 个资源。\n\n**总存储开销**（以字节为单位）：\n$$ \\text{总存储开销} = n \\times (\\text{存储空间/资源}) = 1,000 \\times 96 \\text{ 字节} = 96,000 \\text{ 字节} $$\n\n**总 Gas 成本**：\n$$ G_{\\text{总}} = n \\times g_{\\text{交易}} = 1,000 \\times 81,000 = 81,000,000 \\text{ Gas} $$\n\n**总货币成本**（以美元为单位）：\n首先，将总 Gas 成本转换为以太币 (ETH)，使用 Gas 价格 $p_g = 20 \\times 10^{-9}$ ETH/Gas：\n$$ C_{\\text{ETH}} = G_{\\text{总}} \\times p_g = 81,000,000 \\times (20 \\times 10^{-9}) = 1.62 \\text{ ETH} $$\n\n然后，将以太币成本转换为美元 (USD)，使用以太币价格 $p_{\\text{USD}} = 1,800$ USD/ETH：\n$$ C_{\\text{USD}} = C_{\\text{ETH}} \\times p_{\\text{USD}} = 1.62 \\times 1,800 = 2916 \\text{ USD} $$\n\n#### 第4步：格式化最终答案\n问题要求以行矩阵的形式提供最终答案，第一个条目是总字节数，第二个条目是美元成本。\n- 总字节数：96,000\n- 美元成本：2916\n\n因此，最终答案是 $\\begin{pmatrix} 96000 & 2916 \\end{pmatrix}$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 96000 & 2916 \\end{pmatrix} } $$"
        },
        {
            "introduction": "一个系统即使在安全性和成本上都表现完美，如果它对于实际应用来说太慢，也毫无价值。这项练习  将你置于系统工程师的角色，评估一个许可链网络是否能满足医院临床工作流程（如医生下单）的严格时间要求。你需要运用吞吐量和延迟等基本性能指标，分析不同系统配置的适用性，将技术参数与真实的临床需求联系起来。",
            "id": "4824488",
            "problem": "一个区域性医院联合体正在试行一个许可链，用于在不同机构间不可篡改地记录临床事件，包括医嘱录入和实验室结果报告。该网络在局域网上的 $n$ 个验证者节点之间使用实用拜占庭容错（Practical Byzantine Fault Tolerance, PBFT）算法。交易以固定的区块间隔 $\\Delta$ 被打包成大小为 $b$ 的区块，每个区块在经过持续时间近似恒定为 $t_c$ 的共识阶段后达到最终性。在高峰时段，所有机构的总交易到达过程可以合理地建模为速率为 $\\lambda$ 的泊松过程，其中医嘱录入事件的到达率为 $\\lambda_o = 12$ 交易/秒，实验室结果事件的到达率为 $\\lambda_r = 1$ 交易/秒，因此 $\\lambda = \\lambda_o + \\lambda_r$。对于最繁忙的时间窗口，经验测量得出 $\\lambda_o = 12$ 交易/秒，$\\lambda_r = 1$ 交易/秒。临床工作流程的及时性约束是：(i) 对于电子健康记录（EHR）中的交互式医嘱录入，一个已确认的交易必须在最多 $2$ 秒内得到反映，以避免用户界面中断和重复下单；(ii) 对于常规实验室结果报告，区块链的确认过程在分析仪可用时间之外，最多增加 $10$ 秒的延迟，以避免实质性影响实验室的周转时间。\n\n仅使用吞吐量和延迟的基本定义以及泊松到达下单服务器系统的标准、经过充分检验的排队近似方法，为该许可链定义相关的吞吐量和延迟指标，并确定以下哪些候选配置在高峰时段能同时满足两个及时性约束。假设系统处于稳态操作且稳定。每个配置指定了 $(b, \\Delta, t_c)$：\n\nA. $b = 100$，$\\Delta = 2$ 秒，$t_c = 0.5$ 秒。\n\nB. $b = 50$，$\\Delta = 1$ 秒，$t_c = 1.2$ 秒。\n\nC. $b = 200$，$\\Delta = 5$ 秒，$t_c = 0.7$ 秒。\n\nD. $b = 80$，$\\Delta = 4$ 秒，$t_c = 0.4$ 秒。\n\n选择所有适用的选项。",
            "solution": "## 推导与分析\n\n该问题要求根据吞吐量和延迟约束来评估候选的区块链配置。\n\n### 1. 定义指标和模型\n\n首先，我们计算总交易到达率 $\\lambda$。\n$$ \\lambda = \\lambda_o + \\lambda_r = 12 \\text{ s}^{-1} + 1 \\text{ s}^{-1} = 13 \\text{ s}^{-1} $$\n\n**吞吐量**：系统的最大可持续处理速率（吞吐量），用 $\\mu$ 表示，由区块大小 $b$ 和区块间隔 $\\Delta$ 决定。系统每 $\\Delta$ 秒可以处理 $b$ 笔交易。\n$$ \\mu = \\frac{b}{\\Delta} \\quad [\\text{交易/秒}] $$\n\n**稳定性**：为使系统处于稳定的稳态，到达率必须小于处理速率。如果 $\\lambda \\ge \\mu$，未处理交易的队列将无限增长，延迟将变为无穷大。\n$$ \\lambda < \\mu \\quad \\implies \\quad 13 < \\frac{b}{\\Delta} $$\n这个条件必须对每个配置进行验证。\n\n**延迟**：问题指导我们使用基本定义和标准的排队近似。对于一个在随机时间到达一个以固定批次处理的系统的交易，其总延迟 ($L$) 可以近似为两个部分的总和：\n1.  **批处理等待时间 ($W_{batch}$)**：交易在 $\\Delta$ 的间隔内被收集到一个区块中。一个在该间隔内随机时间点到达的交易，必须等待当前间隔结束并且区块被创建。根据更新理论（平均剩余寿命），对于一个持续时间为 $\\Delta$ 的确定性间隔，平均等待时间是该间隔的一半。\n    $$ W_{batch} = \\frac{\\Delta}{2} $$\n2.  **共识时间 ($t_c$)**：一旦区块被创建，它会经历一个持续时间为 $t_c$ 的共识阶段以达到最终性。\n\n该模型假设交易被包含在下一个可用区块中，这对于一个稳定系统（$\\lambda < \\mu$）是一个有效的近似。总平均延迟为：\n$$ L = W_{batch} + t_c = \\frac{\\Delta}{2} + t_c $$\n\n### 2. 及时性约束\n\n系统必须满足两个约束：\n- (i) 医嘱录入：$L \\le 2$ 秒。\n- (ii) 实验室结果：$L \\le 10$ 秒。\n\n由于所有交易在区块链批处理过程中被同等对待，计算出的延迟 $L$ 适用于两种类型的事件。因此，系统必须满足两个约束中更严格的一个，即医嘱录入的约束：\n$$ L \\le 2 \\text{ s} $$\n如果这个条件得到满足，那么实验室结果的约束（$L \\le 10 \\text{ s}$）将自动得到满足。\n\n### 3. 逐项分析\n\n我们现在评估每个配置。到达率恒定为 $\\lambda = 13 \\text{ s}^{-1}$。\n\n**A. 配置: $b = 100$，$\\Delta = 2$ 秒，$t_c = 0.5$ 秒**\n- **稳定性检查**：\n  吞吐量 $\\mu = \\frac{100}{2} = 50 \\text{ s}^{-1}$。\n  因为 $\\lambda = 13 \\text{ s}^{-1} < 50 \\text{ s}^{-1}$，系统是稳定的。\n- **延迟计算**：\n  $L = \\frac{\\Delta}{2} + t_c = \\frac{2}{2} + 0.5 = 1.0 + 0.5 = 1.5 \\text{ 秒}$。\n- **约束验证**：\n  $1.5 \\text{ 秒} \\le 2 \\text{ 秒}$。约束得到满足。\n- **结论**：**正确**。\n\n**B. 配置: $b = 50$，$\\Delta = 1$ 秒，$t_c = 1.2$ 秒**\n- **稳定性检查**：\n  吞吐量 $\\mu = \\frac{50}{1} = 50 \\text{ s}^{-1}$。\n  因为 $\\lambda = 13 \\text{ s}^{-1} < 50 \\text{ s}^{-1}$，系统是稳定的。\n- **延迟计算**：\n  $L = \\frac{\\Delta}{2} + t_c = \\frac{1}{2} + 1.2 = 0.5 + 1.2 = 1.7 \\text{ 秒}$。\n- **约束验证**：\n  $1.7 \\text{ 秒} \\le 2 \\text{ 秒}$。约束得到满足。\n- **结论**：**正确**。\n\n**C. 配置: $b = 200$，$\\Delta = 5$ 秒，$t_c = 0.7$ 秒**\n- **稳定性检查**：\n  吞吐量 $\\mu = \\frac{200}{5} = 40 \\text{ s}^{-1}$。\n  因为 $\\lambda = 13 \\text{ s}^{-1} < 40 \\text{ s}^{-1}$，系统是稳定的。\n- **延迟计算**：\n  $L = \\frac{\\Delta}{2} + t_c = \\frac{5}{2} + 0.7 = 2.5 + 0.7 = 3.2 \\text{ 秒}$。\n- **约束验证**：\n  $3.2 \\text{ 秒} > 2 \\text{ 秒}$。医嘱录入的及时性约束被违反。\n- **结论**：**不正确**。\n\n**D. 配置: $b = 80$，$\\Delta = 4$ 秒，$t_c = 0.4$ 秒**\n- **稳定性检查**：\n  吞吐量 $\\mu = \\frac{80}{4} = 20 \\text{ s}^{-1}$。\n  因为 $\\lambda = 13 \\text{ s}^{-1} < 20 \\text{ s}^{-1}$，系统是稳定的。\n- **延迟计算**：\n  $L = \\frac{\\Delta}{2} + t_c = \\frac{4}{2} + 0.4 = 2.0 + 0.4 = 2.4 \\text{ 秒}$。\n- **约束验证**：\n  $2.4 \\text{ 秒} > 2 \\text{ 秒}$。医嘱录入的及时性约束被违反。\n- **结论**：**不正确**。",
            "answer": "$$\\boxed{AB}$$"
        }
    ]
}