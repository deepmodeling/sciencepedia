{
    "hands_on_practices": [
        {
            "introduction": "Effective healthcare analytics begins with a well-designed database structure. This exercise challenges you to take a common, denormalized data table—typical of raw data exports—and apply the principles of relational normalization to design a clean, efficient schema . By identifying functional dependencies and creating distinct tables for patients, encounters, and observations, you will practice the foundational skill of building a database that prevents data redundancy and ensures integrity.",
            "id": "4833282",
            "problem": "A hospital’s Electronic Health Record (EHR) system has a denormalized table with columns: patient_id, patient_name, dob, encounter_id, provider_id, observation_id, loinc_code, value. The code loinc_code refers to Logical Observation Identifiers Names and Codes (LOINC). Assume the following domain and data modeling facts grounded in the relational model and healthcare workflow:\n\n- Each observation is a single clinical measurement or finding recorded during care and belongs to exactly one encounter.\n- Each encounter belongs to exactly one patient.\n- Each observation is attributable to exactly one provider.\n- Each observation is annotated with exactly one LOINC code indicating its clinical meaning.\n- Each patient may have many encounters, each encounter may have many observations, each provider may be responsible for many observations, and each LOINC code may label many observations.\n- Identifiers patient_id, provider_id, encounter_id, observation_id, and loinc_code are unique within their respective domains.\n- In the denormalized table, patient_name and dob are properties of a patient determined by patient_id.\n\nUsing only foundational principles from the relational model, including the definitions of relation, attribute, primary key, foreign key, and functional dependency, derive a fully normalized relational schema appropriate for clinical data in an EHR. Your normalization should remove update anomalies implied by the given dependencies and be consistent with healthcare data semantics as stated.\n\nThen, under the standard definition of referential integrity in Structured Query Language (SQL), compute the minimal number of distinct foreign key constraints necessary to ensure that no record references a non-existent parent across your normalized tables. Count only non-redundant constraints needed to enforce the relationships implied by the domain facts above, and do not introduce optional or derived references that are not required by these facts.\n\nProvide only the integer count of the minimal set of foreign key constraints as your final answer. No rounding is required and no units are necessary. Express the final answer as a single number.",
            "solution": "The problem requires the derivation of a fully normalized relational schema from a single denormalized table and the subsequent calculation of the minimum number of foreign key constraints required to enforce referential integrity. The process must be grounded in the foundational principles of the relational model.\n\nFirst, we formalize the problem by identifying the set of attributes and the functional dependencies (FDs) implied by the given statements.\n\nThe universal relation, let us call it $R$, contains the following attributes:\n$R(\\mathit{patient\\_id}, \\mathit{patient\\_name}, \\mathit{dob}, \\mathit{encounter\\_id}, \\mathit{provider\\_id}, \\mathit{observation\\_id}, \\mathit{loinc\\_code}, \\mathit{value})$\n\nFrom the problem description, we can extract the following functional dependencies:\n1.  \"In the denormalized table, `patient_name` and `dob` are properties of a patient determined by `patient_id`.\" This translates to the FD:\n    $$FD_1: \\{\\mathit{patient\\_id}\\} \\rightarrow \\{\\mathit{patient\\_name}, \\mathit{dob}\\}$$\n2.  \"Each encounter belongs to exactly one patient.\" This implies that the encounter's identifier determines the patient's identifier. This translates to the FD:\n    $$FD_2: \\{\\mathit{encounter\\_id}\\} \\rightarrow \\{\\mathit{patient\\_id}\\}$$\n3.  \"Each observation is a single clinical measurement...belongs to exactly one encounter...is attributable to exactly one provider...is annotated with exactly one LOINC code.\" This establishes that the identifier for an observation, $\\mathit{observation\\_id}$, uniquely determines the encounter it belongs to, the provider responsible, the code describing it, and its measured value. This translates to the FD:\n    $$FD_3: \\{\\mathit{observation\\_id}\\} \\rightarrow \\{\\mathit{encounter\\_id}, \\mathit{provider\\_id}, \\mathit{loinc\\_code}, \\mathit{value}\\}$$\nThe attribute $\\mathit{observation\\_id}$ serves as the primary key for the granular event of an observation. The initial denormalized table exhibits redundancy and is subject to update anomalies. For instance, a patient's date of birth ($\\mathit{dob}$) might be stored multiple times, once for each observation associated with that patient, leading to potential inconsistencies. These issues arise from transitive dependencies. Specifically, from $FD_3$ and $FD_2$, we have $\\{\\mathit{observation\\_id}\\} \\rightarrow \\{\\mathit{encounter\\_id}\\}$ and $\\{\\mathit{encounter\\_id}\\} \\rightarrow \\{\\mathit{patient\\_id}\\}$, which implies the transitive dependency $\\{\\mathit{observation\\_id}\\} \\rightarrow \\{\\mathit{patient\\_id}\\}$. Combining this with $FD_1$, we get another transitive dependency: $\\{\\mathit{observation\\_id}\\} \\rightarrow \\{\\mathit{patient\\_name}, \\mathit{dob}\\}$.\n\nTo create a fully normalized schema (typically achieving at least Third Normal Form, 3NF, or Boyce-Codd Normal Form, BCNF), we decompose the universal relation $R$ into smaller relations, such that in each resulting relation, every non-key attribute is fully functionally dependent on the primary key.\n\nThe decomposition proceeds as follows:\n1.  **Patients Table:** To resolve the transitive dependency involving patient attributes, we create a relation for patients based on $FD_1$.\n    $$\\text{Patients}(\\underline{\\mathit{patient\\_id}}, \\mathit{patient\\_name}, \\mathit{dob})$$\n    The primary key is $\\mathit{patient\\_id}$.\n\n2.  **Encounters Table:** To resolve the transitive dependency involving the patient link, we create a relation for encounters based on $FD_2$. This table links each encounter to a specific patient.\n    $$\\text{Encounters}(\\underline{\\mathit{encounter\\_id}}, \\mathit{patient\\_id})$$\n    The primary key is $\\mathit{encounter\\_id}$. The attribute $\\mathit{patient\\_id}$ will serve as a foreign key.\n\n3.  **Reference Tables (Dimensions):** The problem states that $\\mathit{provider\\_id}$ and $\\mathit{loinc\\_code}$ are unique identifiers for their respective domains. For referential integrity to be possible, these domains must be represented by relations (tables). Even though no other attributes are specified for providers or LOINC codes, we must define these entities.\n    $$\\text{Providers}(\\underline{\\mathit{provider\\_id}}, \\dots)$$\n    $$\\text{LOINCCodes}(\\underline{\\mathit{loinc\\_code}}, \\dots)$$\n    The primary keys are $\\mathit{provider\\_id}$ and $\\mathit{loinc\\_code}$, respectively.\n\n4.  **Observations Table (Fact Table):** The remaining attributes from $FD_3$ form the central, or fact, table. This relation records the core observational events and links to the other entities.\n    $$\\text{Observations}(\\underline{\\mathit{observation\\_id}}, \\mathit{encounter\\_id}, \\mathit{provider\\_id}, \\mathit{loinc\\_code}, \\mathit{value})$$\n    The primary key is $\\mathit{observation\\_id}$. The attributes $\\mathit{encounter\\_id}$, $\\mathit{provider\\_id}$, and $\\mathit{loinc\\_code}$ will serve as foreign keys.\n\nThe resulting normalized schema consists of $5$ relations: `Patients`, `Providers`, `LOINCCodes`, `Encounters`, and `Observations`. Now, we must identify the minimal set of foreign key (FK) constraints necessary to enforce the relationships defined in the problem. A foreign key constraint ensures that a value (or set of values) in a referencing table has a matching value in the primary key of a referenced table.\n\nLet's enumerate the non-redundant FK constraints for this schema:\n1.  **From `Encounters` to `Patients`:** The relationship \"Each encounter belongs to exactly one patient\" is modeled by the attribute $\\mathit{patient\\_id}$ in the `Encounters` table. To ensure that every encounter is associated with a valid, existing patient, we need a constraint.\n    - FK$1$: `Encounters.patient_id` must reference `Patients.patient_id`.\n\n2.  **From `Observations` to other tables:** The `Observations` table is the hub connecting various entities.\n    - To enforce \"Each observation...belongs to exactly one encounter\":\n        - FK$2$: `Observations.encounter_id` must reference `Encounters.encounter_id`.\n    - To enforce \"Each observation is attributable to exactly one provider\":\n        - FK$3$: `Observations.provider_id` must reference `Providers.provider_id`.\n    - To enforce \"Each observation is annotated with exactly one LOINC code\":\n        - FK$4$: `Observations.loinc_code` must reference `LOINCCodes.loinc_code`.\n\nThese $4$ constraints are minimal and non-redundant. The chain of integrity from an observation to a patient is enforced transitively through two constraints: FK$2$ (Observation $\\rightarrow$ Encounter) and FK$1$ (Encounter $\\rightarrow$ Patient). Adding a direct foreign key from `Observations` to `Patients` would first require adding a `patient_id` column to the `Observations` table. This would violate normalization principles, as `patient_id` would be transitively dependent on the primary key `observation_id` (via `encounter_id`), reintroducing the very redundancy we sought to eliminate. Therefore, such a constraint is not part of the minimal set for a normalized schema.\n\nThe minimal number of distinct foreign key constraints is the sum of the constraints identified:\n- $1$ constraint from the `Encounters` table.\n- $3$ constraints from the `Observations` table.\n\nTotal minimal constraints = $1 + 3 = 4$.",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "A robust data model goes beyond structure to ensure semantic consistency, especially when integrating data from multiple sources. In this practical scenario, you will tackle a frequent challenge in healthcare data: standardizing laboratory values reported in different units . You will not only perform the unit conversion from first principles but also quantify the analytical bias that arises from a common data pipeline error, highlighting the critical importance of data quality for accurate clinical insights.",
            "id": "4833263",
            "problem": "A hospital data warehouse integrates laboratory glucose measurements from two laboratories into an Electronic Health Record (EHR) analytics pipeline. One laboratory reports plasma glucose as milligrams per deciliter (mg/dL), while the other reports millimoles per liter (mmol/L). You are standardizing units to millimoles per liter (mmol/L) using the molecular weight of glucose. Use the definition of amount of substance, where the number of moles $n$ equals mass $m$ divided by molecular weight $M$, i.e., $n = m/M$, and the facts that $1\\,\\text{dL} = 0.1\\,\\text{L}$ and $1\\,\\text{mg} = 10^{-3}\\,\\text{g}$, to derive the conversion from mg/dL to mmol/L. The molecular weight of glucose is $M = 180.16\\,\\text{g/mol}$.\n\nConsider a cohort of $10$ patients with the following glucose measurements on the same day:\n- Laboratory A (reported in mg/dL): $75$, $90$, $95$, $110$, $130$, $160$, $180$, $200$.\n- Laboratory B (reported in mmol/L): $7.2$, $9.5$.\n\nAssume the correct aggregation standardizes all values to mmol/L before computing the arithmetic mean across patients.\n\nHowever, due to a unit-flag loss in the extract-transform-load step, an erroneous pipeline treats every numeric value as if it were in mg/dL and applies the mg/dL to mmol/L conversion to every value, including those originally in mmol/L.\n\nUsing first principles of unit conversion derived from $n = m/M$ and the definition of the arithmetic mean, answer the following in one consolidated computation:\n- Compute the absolute bias (the absolute value of the difference) between the correct cohort mean in mmol/L and the erroneous cohort mean in mmol/L caused by the unit misalignment.\n\nExpress the final quantity in millimoles per liter (mmol/L) and round your answer to four significant figures.",
            "solution": "The problem requires the calculation of the absolute bias between a correctly computed mean glucose level and an erroneously computed one. This involves first deriving the unit conversion factor from first principles, then formulating the expressions for both the correct and erroneous means, and finally calculating their absolute difference.\n\nFirst, we establish the necessary constants and data from the problem statement.\nThe molecular weight of glucose is given as $M = 180.16\\,\\text{g/mol}$.\nThe cohort consists of $N=10$ patients.\nThe data from Laboratory A, reported in milligrams per deciliter (mg/dL), is a set of $N_A = 8$ values: $X_A = \\{75, 90, 95, 110, 130, 160, 180, 200\\}$.\nThe data from Laboratory B, reported in millimoles per liter (mmol/L), is a set of $N_B = 2$ values: $X_B = \\{7.2, 9.5\\}$.\n\nThe first step is to derive the conversion factor from mg/dL to mmol/L based on the provided fundamental relationship $n = m/M$, where $n$ is the amount of substance in moles, $m$ is the mass, and $M$ is the molecular weight. We also use the definitions $1\\,\\text{dL} = 0.1\\,\\text{L}$ and $1\\,\\text{mg} = 10^{-3}\\,\\text{g}$.\n\nLet $C_{mg/dL}$ be a concentration value in units of mg/dL.\nTo convert this to grams per liter (g/L), we apply the unit conversions:\n$$ C \\left[ \\frac{\\text{mg}}{\\text{dL}} \\right] = C \\frac{1\\,\\text{mg}}{1\\,\\text{dL}} = C \\frac{10^{-3}\\,\\text{g}}{0.1\\,\\text{L}} = C \\cdot 10^{-2} \\left[ \\frac{\\text{g}}{\\text{L}} \\right] $$\nThis gives the mass concentration. To find the molar concentration (mol/L), we divide the mass concentration by the molecular weight $M$:\n$$ C \\left[ \\frac{\\text{mol}}{\\text{L}} \\right] = \\frac{C \\cdot 10^{-2} \\left[ \\frac{\\text{g}}{\\text{L}} \\right]}{M \\left[ \\frac{\\text{g}}{\\text{mol}} \\right]} = \\frac{C \\cdot 10^{-2}}{M} \\left[ \\frac{\\text{mol}}{\\text{L}} \\right] $$\nFinally, to convert from mol/L to mmol/L, we use the fact that $1\\,\\text{mol} = 1000\\,\\text{mmol} = 10^3\\,\\text{mmol}$:\n$$ C \\left[ \\frac{\\text{mmol}}{\\text{L}} \\right] = \\frac{C \\cdot 10^{-2}}{M} \\left[ \\frac{\\text{mol}}{\\text{L}} \\right] \\times 10^3 \\left[ \\frac{\\text{mmol}}{\\text{mol}} \\right] = C \\cdot \\frac{10}{M} \\left[ \\frac{\\text{mmol}}{\\text{L}} \\right] $$\nLet $f$ be the conversion factor such that a value $x_{mg/dL}$ in mg/dL is converted to $x_{mmol/L}$ by $x_{mmol/L} = f \\cdot x_{mg/dL}$. From our derivation:\n$$ f = \\frac{10}{M} = \\frac{10}{180.16} = \\frac{1}{18.016} $$\n\nNext, we define the correct cohort mean, $\\mu_{\\text{correct}}$. This is calculated by first converting all measurements to the standard unit of mmol/L and then computing the arithmetic mean. Let $A_i$ be the $i$-th value from Laboratory A and $B_j$ be the $j$-th value from Laboratory B.\nThe values from Lab A must be converted: $f \\cdot A_i$. The values from Lab B are already in the correct units.\n$$ \\mu_{\\text{correct}} = \\frac{1}{N} \\left( \\sum_{i=1}^{N_A} (f \\cdot A_i) + \\sum_{j=1}^{N_B} B_j \\right) = \\frac{1}{N} \\left( f \\sum_{i=1}^{N_A} A_i + \\sum_{j=1}^{N_B} B_j \\right) $$\n\nNow, we define the erroneous cohort mean, $\\mu_{\\text{erroneous}}$. This is calculated by incorrectly treating all numeric values as if they were in mg/dL and applying the conversion factor $f$ to all of them before averaging.\n$$ \\mu_{\\text{erroneous}} = \\frac{1}{N} \\left( \\sum_{i=1}^{N_A} (f \\cdot A_i) + \\sum_{j=1}^{N_B} (f \\cdot B_j) \\right) = \\frac{f}{N} \\left( \\sum_{i=1}^{N_A} A_i + \\sum_{j=1}^{N_B} B_j \\right) $$\n\nThe absolute bias, $\\Delta_{\\mu}$, is the absolute value of the difference between the correct and erroneous means.\n$$ \\Delta_{\\mu} = |\\mu_{\\text{correct}} - \\mu_{\\text{erroneous}}| $$\n$$ \\Delta_{\\mu} = \\left| \\frac{1}{N} \\left( f \\sum A_i + \\sum B_j \\right) - \\frac{f}{N} \\left( \\sum A_i + \\sum B_j \\right) \\right| $$\nExpanding the terms inside the absolute value:\n$$ \\Delta_{\\mu} = \\left| \\frac{f}{N}\\sum A_i + \\frac{1}{N}\\sum B_j - \\frac{f}{N}\\sum A_i - \\frac{f}{N}\\sum B_j \\right| $$\nThe terms involving $\\sum A_i$ cancel out:\n$$ \\Delta_{\\mu} = \\left| \\frac{1}{N}\\sum B_j - \\frac{f}{N}\\sum B_j \\right| = \\left| \\frac{1}{N} \\left( \\sum B_j \\right) (1-f) \\right| $$\nSince $f = 1/18.016$ is between $0$ and $1$, the term $(1-f)$ is positive. The sum of glucose values $\\sum B_j$ is also positive. Thus, the absolute value is not necessary.\n$$ \\Delta_{\\mu} = \\frac{1}{N} \\left( \\sum_{j=1}^{N_B} B_j \\right) (1-f) $$\nThis consolidated expression demonstrates that the bias depends only on the data that was incorrectly converted, the total sample size, and the conversion factor.\n\nNow we substitute the numerical values into this expression.\nThe total number of patients is $N = N_A + N_B = 8 + 2 = 10$.\nThe sum of the values from Laboratory B is $\\sum B_j = 7.2 + 9.5 = 16.7$.\nThe conversion factor is $f = 1/18.016$.\n$$ \\Delta_{\\mu} = \\frac{1}{10} (16.7) \\left(1 - \\frac{1}{18.016}\\right) $$\n$$ \\Delta_{\\mu} = 1.67 \\left(\\frac{18.016 - 1}{18.016}\\right) $$\n$$ \\Delta_{\\mu} = 1.67 \\left(\\frac{17.016}{18.016}\\right) $$\nPerforming the calculation:\n$$ \\Delta_{\\mu} \\approx 1.67 \\times 0.94449378... = 1.577304618... $$\nThe problem requires the answer to be rounded to four significant figures. The first four significant figures are $1$, $5$, $7$, and $7$. The fifth significant digit is $3$, so we round down.\n$$ \\Delta_{\\mu} \\approx 1.577 $$\nThe absolute bias is approximately $1.577\\,\\text{mmol/L}$.",
            "answer": "$$\\boxed{1.577}$$"
        },
        {
            "introduction": "For healthcare data to be truly useful, it must be exchangeable and understandable across different systems, a concept known as interoperability. This practice problem moves from relational theory to the modern standards that enable this, focusing on Fast Healthcare Interoperability Resources (FHIR) . You will implement the core logic for validating a clinical observation against a required terminology binding, gaining insight into how standards like FHIR ensure data is both structured and semantically correct.",
            "id": "4833269",
            "problem": "You are modeling a constraint from Fast Healthcare Interoperability Resources (FHIR) within a programmatic validation framework. In FHIR, Observation.code is a CodeableConcept that can contain multiple codings, each coding being a pair of a system Uniform Resource Identifier (URI) and a code string. You will create an abstract representation of a FHIR profile that restricts Observation.code to a Logical Observation Identifiers Names and Codes (LOINC) value set and implement the validation rule that enforces a “required” binding. The final program must compute the validation outcome for a set of test instances, including cases where an instance uses a code outside the value set expansion.\n\nFundamental base:\n- Set theory and first-order logic: given a set $E$ of allowed codes and a fixed system $S$, a CodeableConcept $C$ with $n$ codings $[(s_1,k_1),\\dots,(s_n,k_n)]$ is valid under a “required” binding if and only if there exists an index $i$ with $1 \\le i \\le n$ such that $s_i = S$ and $k_i \\in E$.\n- FHIR semantics: a “required” binding to a value set asserts that the coded element must draw from the expansion of the value set. For CodeableConcept, validity is satisfied if any coding conforms to the binding; otherwise, the element is invalid.\n\nTask:\n1. Define the LOINC system as the canonical URI string $S = \\text{\"http://loinc.org\"}$.\n2. Define a value set expansion $E$ as the set of allowed LOINC code strings. Use the following expansion: $E = \\{\\text{\"55284-4\"}, \\text{\"1234-5\"}, \\text{\"7890-1\"}\\}$. Treat these as exact string matches.\n3. Define a validation function that, given a CodeableConcept $C$ represented as a list of codings $[(s_1,k_1),\\dots,(s_n,k_n)]$, returns a boolean indicating conformance to the “required” binding. The predicate is:\n$$\\mathrm{valid}(C,E,S) \\iff \\exists i \\in \\{1,\\dots,n\\}: (s_i = S) \\land (k_i \\in E).$$\nIf $n = 0$, then the predicate is false.\n4. Implement a complete, runnable program that applies this validation to the test suite below and prints a single line containing the list of boolean results in the specified format.\n\nTest suite:\n- Case $1$ (general “happy path”): $C = [(\\text{\"http://loinc.org\"}, \\text{\"55284-4\"})]$.\n- Case $2$ (outside expansion): $C = [(\\text{\"http://loinc.org\"}, \\text{\"99999-9\"})]$.\n- Case $3$ (system mismatch): $C = [(\\text{\"http://snomed.info/sct\"}, \\text{\"55284-4\"})]$, where Systematized Nomenclature of Medicine—Clinical Terms (SNOMED CT) is a different system.\n- Case $4$ (multiple codings, one valid): $C = [(\\text{\"http://loinc.org\"}, \\text{\"55284-4\"}), (\\text{\"http://snomed.info/sct\"}, \\text{\"123456\"})]$.\n- Case $5$ (boundary, empty coding list): $C = []$.\n- Case $6$ (multiple LOINC codings, one valid and one invalid): $C = [(\\text{\"http://loinc.org\"}, \\text{\"1234-5\"}), (\\text{\"http://loinc.org\"}, \\text{\"99999-9\"})]$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result1},\\text{result2},\\dots]$).\n- Each result must be a boolean ($\\text{True}$ or $\\text{False}$) corresponding to the validity of the respective test case in the order given above.\n\nAngle units, physical units, and percentage formatting are not applicable to this problem, so none are required.",
            "solution": "The problem statement has been validated and found to be self-contained, scientifically grounded in set theory and established medical informatics standards (FHIR), and well-posed. All components required for a solution are present and logically consistent.\n\nThe task is to construct a validation function that determines if a Fast Healthcare Interoperability Resources (FHIR) `CodeableConcept` data structure conforms to a \"required\" binding to a specified value set. This problem is an exercise in applying first-order logic to data structure validation.\n\nThe fundamental components of the problem are:\n1. A target coding system, defined as a canonical URI string $S = \\text{\"http://loinc.org\"}$. This represents the Logical Observation Identifiers Names and Codes (LOINC) system.\n2. A value set expansion, which is the set of allowed codes within the target system. This set is given as $E = \\{\\text{\"55284-4\"}, \\text{\"1234-5\"}, \\text{\"7890-1\"}\\}$.\n3. A `CodeableConcept` instance, $C$, which is represented as a list of codings. Each coding is a tuple $(s_i, k_i)$, where $s_i$ is a system URI string and $k_i$ is a code string. Let the number of codings in $C$ be $n$.\n\nThe validation rule is formally defined by the logical predicate:\n$$ \\mathrm{valid}(C, E, S) \\iff \\exists i \\in \\{1,\\dots,n\\}: (s_i = S) \\land (k_i \\in E) $$\nThis predicate asserts that a `CodeableConcept` $C$ is valid if and only if there exists at least one coding $(s_i, k_i)$ in its list such that its system $s_i$ matches the required system $S$ AND its code $k_i$ is a member of the allowed value set expansion $E$. If the list of codings is empty ($n=0$), the existential quantification over an empty set of indices is false, so the `CodeableConcept` is invalid.\n\nTo implement this validation, we will design a function that takes a `CodeableConcept` $C$ as input. Inside this function, we will iterate through each coding $(s_i, k_i)$ from the input list $C$. For each coding, we perform two comparisons:\n1. Is the system string $s_i$ identical to the target system string $S$?\n2. Is the code string $k_i$ present in the value set expansion $E$?\n\nIf both conditions are met for any single coding, the existential condition $\\exists i$ is satisfied. The function can immediately terminate and return `True`. If the function iterates through all the codings in $C$ without finding one that satisfies both conditions, it means no such coding exists. In this case, the function should return `False` after the loop completes. This approach correctly handles the empty list case ($n=0$), as the loop will not execute and the function will proceed to the final return statement, yielding `False`.\n\nFor an efficient implementation, the value set expansion $E$ should be stored in a data structure that provides fast membership testing. A hash set (or `set` in Python) is ideal, offering an average-time complexity of $O(1)$ for lookups.\n\nLet's apply this logic to the provided test suite:\n- **Case 1**: $C = [(\\text{\"http://loinc.org\"}, \\text{\"55284-4\"})]$. Here, $n=1$. The single coding has $s_1 = S$ and $k_1 \\in E$. The predicate is satisfied. Result: `True`.\n- **Case 2**: $C = [(\\text{\"http://loinc.org\"}, \\text{\"99999-9\"})]$. Here, $n=1$. The coding has $s_1 = S$, but $k_1 = \\text{\"99999-9\"} \\notin E$. The predicate is not satisfied. Result: `False`.\n- **Case 3**: $C = [(\\text{\"http://snomed.info/sct\"}, \\text{\"55284-4\"})]$. Here, $n=1$. The coding has $k_1 \\in E$, but $s_1 = \\text{\"http://snomed.info/sct\"} \\neq S$. The predicate is not satisfied. Result: `False`.\n- **Case 4**: $C = [(\\text{\"http://loinc.org\"}, \\text{\"55284-4\"}), (\\text{\"http://snomed.info/sct\"}, \\text{\"123456\"})]$. Here, $n=2$. The first coding $(s_1, k_1)$ has $s_1 = S$ and $k_1 \\in E$. Since we have found one valid coding, the existential condition is met, and we do not need to inspect the rest of the list. Result: `True`.\n- **Case 5**: $C = []$. Here, $n=0$. The set of codings is empty. By definition, the predicate is false. Result: `False`.\n- **Case 6**: $C = [(\\text{\"http://loinc.org\"}, \\text{\"1234-5\"}), (\\text{\"http://loinc.org\"}, \\text{\"99999-9\"})]$. Here, $n=2$. The first coding has $s_1 = S$ and $k_1 = \\text{\"1234-5\"} \\in E$. The condition is satisfied. The fact that the second coding is invalid is irrelevant. Result: `True`.\n\nThe program will implement this logic and apply it to each test case, collecting the boolean outcomes into a list for final formatted printing.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Implements and runs the FHIR CodeableConcept validation logic\n    for a \"required\" binding against a set of test cases.\n    \"\"\"\n    \n    # Task 1: Define the LOINC system as the canonical URI string S.\n    # $S = \\text{\"http://loinc.org\"}$\n    LOINC_SYSTEM = \"http://loinc.org\"\n\n    # Task 2: Define a value set expansion E.\n    # $E = \\{\\text{\"55284-4\"}, \\text{\"1234-5\"}, \\text{\"7890-1\"}\\}$\n    # A set is used for efficient O(1) average time complexity for lookups.\n    VALUE_SET_EXPANSION = {\"55284-4\", \"1234-5\", \"7890-1\"}\n\n    # The test suite as defined in the problem statement.\n    # Each element is a CodeableConcept C represented as a list of codings.\n    # A coding is a tuple of (system, code).\n    test_cases = [\n        # Case 1: General \"happy path\"\n        [(\"http://loinc.org\", \"55284-4\")],\n        # Case 2: Outside expansion\n        [(\"http://loinc.org\", \"99999-9\")],\n        # Case 3: System mismatch\n        [(\"http://snomed.info/sct\", \"55284-4\")],\n        # Case 4: Multiple codings, one valid\n        [(\"http://loinc.org\", \"55284-4\"), (\"http://snomed.info/sct\", \"123456\")],\n        # Case 5: Boundary, empty coding list\n        [],\n        # Case 6: Multiple LOINC codings, one valid and one invalid\n        [(\"http://loinc.org\", \"1234-5\"), (\"http://loinc.org\", \"99999-9\")],\n    ]\n\n    def is_valid_codeable_concept(concept, system, value_set):\n        \"\"\"\n        Validates a CodeableConcept against a required binding to a value set.\n        \n        The predicate is:\n        valid(C, E, S) <=> exists i in {1,...,n}: (s_i = S) and (k_i in E)\n\n        Args:\n            concept (list): The CodeableConcept, a list of (system, code) tuples.\n            system (str): The required system URI ($S$).\n            value_set (set): The set of allowed codes ($E$).\n\n        Returns:\n            bool: True if the concept is valid, False otherwise.\n        \"\"\"\n        # Iterate through each coding in the CodeableConcept\n        for s_i, k_i in concept:\n            # Check if the coding's system and code match the requirements.\n            # (s_i = S) AND (k_i in E)\n            if s_i == system and k_i in value_set:\n                # If a valid coding is found, the existential condition is met.\n                return True\n        \n        # If the loop completes without finding a valid coding, it fails validation.\n        # This also handles the case of an empty concept list.\n        return False\n\n    results = []\n    for case in test_cases:\n        # Apply the validation function to each test case.\n        result = is_valid_codeable_concept(case, LOINC_SYSTEM, VALUE_SET_EXPANSION)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Example: [True,False,False,True,False,True]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}