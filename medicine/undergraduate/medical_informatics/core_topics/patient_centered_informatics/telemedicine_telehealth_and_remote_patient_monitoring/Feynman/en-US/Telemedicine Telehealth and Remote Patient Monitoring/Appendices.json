{
    "hands_on_practices": [
        {
            "introduction": "For any telehealth or Remote Patient Monitoring (RPM) program to be sustainable, it must be financially viable. This exercise moves from theory to practice by exploring the rules-based world of healthcare reimbursement. By applying specific criteria based on real-world regulations, you will determine billing eligibility and calculate potential revenue, a critical skill for program managers and informaticists who design and deploy these systems. ",
            "id": "4858431",
            "problem": "A Medicare beneficiary is newly enrolled on Remote Patient Monitoring (RPM) for hypertension in a health system’s telehealth program at the start of a $30$-day period. The device is a Food and Drug Administration (FDA)-cleared cellular blood pressure monitor that automatically transmits physiologic measurements to the clinic’s platform without patient self-entry. The physician documents medical necessity and places an order for RPM services. During the first $30$-day period, the following occurs: the device successfully transmits data on $20$ distinct days; clinical staff and the supervising physician perform $26$ minutes of RPM treatment management time in the calendar month, of which $17$ minutes involve synchronous, real-time interactive communication (telephone and secure video) with the patient and caregiver; initial device setup and patient education are completed at initiation and documented once for this episode of care. The program uses the Current Procedural Terminology (CPT) codes $99453$, $99454$, and $99457$. Under the Centers for Medicare & Medicaid Services (CMS) RPM rules, $99453$ describes initial device setup and patient education (once per episode of care), $99454$ describes device supply with daily recordings or programmed transmissions each $30$-day period and requires at least $16$ days of physiologic data in that period, and $99457$ describes RPM treatment management services for the first $20$ minutes per calendar month and requires interactive communication with the patient or caregiver during that month. Assume the allowed reimbursement rates for these services are $18.88$ United States dollars (USD) for $99453$, $54.26$ USD for $99454$, and $48.60$ USD for $99457$, and that only one unit of each code may be billed in this scenario. Based on these foundational definitions and facts, determine which of the codes are eligible to be billed for this $30$-day period, and compute the expected total monthly reimbursement. Express the final reimbursement in USD. Provide a single numeric answer; do not include any units in the final boxed value.",
            "solution": "The problem is valid as it is self-contained, scientifically grounded in the domain of medical informatics and billing practices, and well-posed. It presents a clear set of rules and data, allowing for a unique, verifiable solution.\n\nThe task is to calculate the total reimbursement for Remote Patient Monitoring (RPM) services provided over a $30$-day period by determining which of the specified Current Procedural Terminology (CPT) codes are eligible for billing based on the information provided. The total reimbursement, $R_{total}$, will be the sum of the allowed reimbursement rates for all eligible codes.\n\nLet's evaluate the eligibility of each CPT code individually.\n\n1.  **CPT Code $99453$**: This code pertains to the initial device setup and patient education.\n    -   **Rule**: The service must be performed and documented once per episode of care. The allowed reimbursement is $R_{99453} = 18.88$ USD.\n    -   **Given Information**: The problem states, \"initial device setup and patient education are completed at initiation and documented once for this episode of care.\"\n    -   **Conclusion**: The condition for billing CPT code $99453$ is explicitly met. Therefore, this code is billable.\n\n2.  **CPT Code $99454$**: This code pertains to the supply of the device and monitoring of data transmissions.\n    -   **Rule**: The device must supply daily recordings or programmed transmissions for each $30$-day period, and there must be at least $16$ days of physiologic data transmitted within that period. The allowed reimbursement is $R_{99454} = 54.26$ USD.\n    -   **Given Information**: \"The device successfully transmits data on $20$ distinct days\" during the $30$-day period.\n    -   **Analysis**: The number of data transmission days is $D_{data} = 20$. The requirement is $D_{data} \\ge 16$. Since $20 \\ge 16$, the condition is met.\n    -   **Conclusion**: The condition for billing CPT code $99454$ is met. Therefore, this code is billable.\n\n3.  **CPT Code $99457$**: This code pertains to the clinical staff time for treatment management.\n    -   **Rule**: This code covers the first $20$ minutes of RPM treatment management services per calendar month. It also requires that there has been interactive communication with the patient or caregiver during that month. The allowed reimbursement is $R_{99457} = 48.60$ USD.\n    -   **Given Information**: A total of $T_{mgmt} = 26$ minutes of RPM treatment management time was performed. Of this time, $T_{interactive} = 17$ minutes involved \"synchronous, real-time interactive communication\".\n    -   **Analysis**: The code has two conditions:\n        a.  **Time Threshold**: The service time must be at least $20$ minutes to bill for the first $20$ minutes. The total time spent was $26$ minutes, which satisfies the condition as $26 \\ge 20$.\n        b.  **Interactive Communication**: The service requires interactive communication. The problem states that $17$ minutes of such communication occurred. The presence of any amount of interactive communication fulfills this requirement.\n    -   **Conclusion**: Both conditions for billing CPT code $99457$ are met. Therefore, this code is billable.\n\nSince all three CPT codes ($99453$, $99454$, and $99457$) are determined to be eligible for billing, the total reimbursement is the sum of their individual reimbursement rates. The problem states only one unit of each code may be billed.\n\nTotal Reimbursement $R_{total} = R_{99453} + R_{99454} + R_{99457}$\n\nSubstituting the given values:\n$$R_{total} = 18.88 + 54.26 + 48.60$$\n$$R_{total} = 73.14 + 48.60$$\n$$R_{total} = 121.74$$\n\nThe total expected monthly reimbursement is $121.74$ USD.",
            "answer": "$$\\boxed{121.74}$$"
        },
        {
            "introduction": "The reliability of Remote Patient Monitoring hinges on overcoming real-world technical challenges, such as intermittent network connectivity. This practice explores a core engineering solution: the store-and-forward buffer. Using fundamental principles of data flow and conservation, you will model how a device can manage data transmission to ensure completeness, providing crucial insight into the technical design requirements for robust RPM systems. ",
            "id": "4858509",
            "problem": "A Remote Patient Monitoring (RPM) device in a telehealth deployment continuously acquires physiological waveform data and uses a store-and-forward buffer to tolerate intermittent cellular connectivity. The device samples at a base production rate of $R_{\\text{base}} = 0.6$ megabytes per minute and transmits only when the network is connected. The connectivity pattern is periodic: the network is offline for $T_{\\text{off}} = 12$ minutes and then online for $T_{\\text{on}} = 8$ minutes, repeating indefinitely. When online, the uplink service rate is $C = 1.2$ megabytes per minute. The buffer implements backpressure that adjusts the sampling rate to a constant effective rate $R_{\\text{eff}}$ over each cycle so that the buffer neither overflows nor permanently drains across cycles, thereby preventing data loss while bounding memory usage. Assume that $C > R_{\\text{eff}}$ during the online period and that the buffer fills during offline and drains during online, returning to the same occupancy at the end of each cycle.\n\nDefine data completeness as the long-run fraction of the base-rate samples (that would be produced under continuous connectivity with no backpressure) that are actually produced under this optimal backpressure policy. Using only conservation-of-data and steady-state arguments grounded in fundamental definitions of rates and flow balance, determine the data completeness.\n\nExpress your final answer as a decimal rounded to four significant figures. Use megabytes as $1$ megabyte $=$ $10^{6}$ bytes for all rate quantities in intermediate reasoning, but no units are required in the final answer box.",
            "solution": "The problem statement is first subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\nThe data and conditions provided in the problem statement are as follows:\n- Base production rate: $R_{\\text{base}} = 0.6$ megabytes per minute.\n- Network offline time: $T_{\\text{off}} = 12$ minutes.\n- Network online time: $T_{\\text{on}} = 8$ minutes.\n- Uplink service rate (when online): $C = 1.2$ megabytes per minute.\n- A backpressure mechanism adjusts the sampling rate to a constant effective rate, $R_{\\text{eff}}$, over each cycle.\n- The system is in a steady state, meaning the buffer does not permanently overflow or drain across cycles.\n- The buffer occupancy at the end of each cycle is the same as at the start.\n- The condition $C > R_{\\text{eff}}$ holds during the online period.\n- The goal is to determine the \"data completeness,\" defined as the long-run fraction of base-rate samples that are actually produced.\n- The final answer is to be a decimal rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed for validity based on the established criteria.\n- **Scientifically Grounded**: The problem is a straightforward application of the principle of conservation of data, a fundamental concept in queueing theory and network engineering. The model of a store-and-forward buffer with periodic connectivity is a standard, albeit simplified, representation of real-world systems. It is scientifically sound.\n- **Well-Posed**: The problem is well-posed. The steady-state condition provides the necessary constraint to determine a unique effective rate, $R_{\\text{eff}}$. All necessary parameters ($R_{\\text{base}}$, $T_{\\text{off}}$, $T_{\\text{on}}$, $C$) are provided. The objective—calculating data completeness—is clearly defined.\n- **Objective**: The problem is stated using precise, quantitative language, free of subjectivity or ambiguity. The terms are clearly defined within the context of the problem.\n- **Other Flaws**: The problem does not violate any of the other validation criteria. It is a formalizable problem directly relevant to the specified topic, is not contradictory or incomplete, uses realistic parameter values, and is not trivial.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be derived.\n\nThe problem describes a system in a periodic steady state. The total duration of one cycle is $T_{\\text{cycle}} = T_{\\text{off}} + T_{\\text{on}}$.\nThe backpressure mechanism sets a constant effective data production rate, which we denote as $R_{\\text{eff}}$, throughout the entire cycle. The total amount of data produced in one cycle is the product of this rate and the cycle duration:\n$$D_{\\text{produced}} = R_{\\text{eff}} \\times T_{\\text{cycle}} = R_{\\text{eff}} \\times (T_{\\text{off}} + T_{\\text{on}})$$\n\nData can only be transmitted during the online period, $T_{\\text{on}}$, at a maximum rate of $C$. The total amount of data that can be transmitted in one cycle is:\n$$D_{\\text{transmitted}} = C \\times T_{\\text{on}}$$\n\nThe problem specifies that the system is in a steady state, where the buffer level returns to its initial state at the end of every cycle. This implies that, over one full cycle, the total amount of data produced must equal the total amount of data transmitted. This is the principle of conservation of data for a system in steady state.\n$$D_{\\text{produced}} = D_{\\text{transmitted}}$$\nSubstituting the expressions for produced and transmitted data:\n$$R_{\\text{eff}} \\times (T_{\\text{off}} + T_{\\text{on}}) = C \\times T_{\\text{on}}$$\n\nWe can solve for $R_{\\text{eff}}$, which represents the maximum sustainable average production rate that the network can support over a full cycle.\n$$R_{\\text{eff}} = C \\times \\frac{T_{\\text{on}}}{T_{\\text{off}} + T_{\\text{on}}}$$\n\nNow, we substitute the given numerical values:\n- $C = 1.2$ MB/min\n- $T_{\\text{on}} = 8$ min\n- $T_{\\text{off}} = 12$ min\n\n$$R_{\\text{eff}} = 1.2 \\, \\frac{\\text{MB}}{\\text{min}} \\times \\frac{8 \\, \\text{min}}{12 \\, \\text{min} + 8 \\, \\text{min}} = 1.2 \\times \\frac{8}{20} = 1.2 \\times 0.4 = 0.48 \\, \\frac{\\text{MB}}{\\text{min}}$$\n\nThis rate, $R_{\\text{eff}} = 0.48$ MB/min, is the maximum rate at which data can be produced without causing the buffer to grow indefinitely. The device has a base production rate of $R_{\\text{base}} = 0.6$ MB/min. The backpressure mechanism's function is to throttle the device's production rate down to a level that is sustainable by the network. Therefore, the actual production rate of the device, let's call it $R_{\\text{actual}}$, will be the minimum of its intrinsic capability ($R_{\\text{base}}$) and the network-imposed limit ($R_{\\text{eff}}$).\n$$R_{\\text{actual}} = \\min(R_{\\text{base}}, R_{\\text{eff}})$$\n$$R_{\\text{actual}} = \\min(0.6 \\, \\frac{\\text{MB}}{\\text{min}}, 0.48 \\, \\frac{\\text{MB}}{\\text{min}}) = 0.48 \\, \\frac{\\text{MB}}{\\text{min}}$$\n\nThe problem defines \"data completeness\" as the long-run fraction of the base-rate samples that are actually produced. This is equivalent to the ratio of the actual data production rate to the base data production rate.\n$$\\text{Data Completeness} = \\frac{R_{\\text{actual}}}{R_{\\text{base}}}$$\nSubstituting the values for $R_{\\text{actual}}$ and $R_{\\text{base}}$:\n$$\\text{Data Completeness} = \\frac{0.48 \\, \\frac{\\text{MB}}{\\text{min}}}{0.6 \\, \\frac{\\text{MB}}{\\text{min}}} = \\frac{0.48}{0.6} = 0.8$$\n\nThe problem requires the answer to be expressed as a decimal rounded to four significant figures.\n$$0.8000$$\n\nFinally, we check the condition $C > R_{\\text{eff}}$ given in the problem. We have $C = 1.2$ MB/min and we found $R_{\\text{eff}} = 0.48$ MB/min. The condition $1.2 > 0.48$ is true, which confirms the consistency of the problem statement and our derived solution. This condition is physically necessary; if the production rate were greater than or equal to the transmission rate during the 'online' phase, the buffer could never drain.",
            "answer": "$$\\boxed{0.8000}$$"
        },
        {
            "introduction": "Once patient data is collected and transmitted, it must be represented in a universally understood format to be clinically useful across different systems. This hands-on coding practice addresses the heart of medical informatics: interoperability. You will map a common clinical measurement into a Fast Healthcare Interoperability Resources (FHIR) standard, using terminologies like LOINC and UCUM, and then verify its semantic integrity, demonstrating how raw data achieves meaning and portability. ",
            "id": "4858489",
            "problem": "You are given a specification task in the domain of medical informatics for Remote Patient Monitoring (RPM). The goal is to design and verify a computational mapping between a blood pressure measurement and a standards-based representation suitable for Electronic Health Record (EHR) exchange. You must implement a program that constructs a Fast Healthcare Interoperability Resources (FHIR) Observation resource for blood pressure using Logical Observation Identifiers Names and Codes (LOINC) codes and Unified Code for Units of Measure (UCUM) units, and then mathematically verify round-trip fidelity when exporting to a string and re-importing it through a simulated EHR transformation.\n\nDefinitions and foundational facts to use:\n- Fast Healthcare Interoperability Resources (FHIR) Observation is a standardized data structure with fields for codes, subject, time, and components. Blood pressure panel code in LOINC is the identifier \"85354-9\", with systolic blood pressure component code \"8480-6\" and diastolic blood pressure component code \"8462-4\".\n- Logical Observation Identifiers Names and Codes (LOINC) system is identified by the system Uniform Resource Locator (URL) \"http://loinc.org\".\n- Unified Code for Units of Measure (UCUM) system is identified by the system URL \"http://unitsofmeasure.org\". Millimeters of mercury must be encoded with UCUM code \"mm[Hg]\". The display string (e.g., \"mmHg\") is not part of the canonical UCUM code and may vary without loss of semantic fidelity provided the UCUM code and system are unchanged.\n- An Electronic Health Record (EHR) round-trip in this problem is simulated by a deterministic transformation applied to the serialized FHIR resource.\n\nMathematical model:\n- Let a measurement be the tuple $x = (p, s, d, t)$, where $p$ is a patient identifier string, $s$ is systolic blood pressure in millimeters of mercury, $d$ is diastolic blood pressure in millimeters of mercury, and $t$ is the observation time as an ISO $8601$ string.\n- Define an encoder function $E$ that maps $x$ to a FHIR Observation data structure $y$, and a decoder function $D$ that maps a FHIR Observation structure back to a tuple $\\hat{x}$.\n- Define an EHR transformation $T$ that acts on the serialized observation and may preserve or alter semantics. The mathematically desired property for fidelity is that for all $x$, $D(T(E(x))) = x$ under exact match on strings and a tolerance-based equality for floating values.\n- Define a tolerance $\\epsilon = 10^{-12}$ and floating-point equality predicate $|a - b| \\le \\epsilon$ for values $a$ and $b$ in $\\mathbb{R}$.\n\nProgram requirements:\n1. Construct the FHIR Observation resource for blood pressure from $x$ satisfying all of the following:\n   - The top-level Observation.code coding must include the LOINC system \"http://loinc.org\" and code \"85354-9\".\n   - The Observation.component list must contain two components:\n     - Systolic blood pressure component: LOINC code \"8480-6\".\n     - Diastolic blood pressure component: LOINC code \"8462-4\".\n   - Each component must include valueQuantity with:\n     - value equal to the input measurement in millimeters of mercury.\n     - unit display string; you may use \"mmHg\" or any other human-readable equivalent.\n     - system \"http://unitsofmeasure.org\".\n     - UCUM code \"mm[Hg]\".\n   - The Observation.subject reference must be \"Patient/\" followed by $p$.\n   - The Observation.effectiveDateTime must be $t$.\n   - The Observation.status must be \"final\", and category should denote vital signs.\n2. Implement an export function that serializes the Observation to a string and an import function that deserializes it back to a data structure.\n3. Implement $D$ that reconstructs $(p, s, d, t)$ by locating components based on their LOINC codes and validating UCUM unit code and system.\n4. Implement a fidelity checker that returns a boolean which is true if and only if:\n   - The decoded $(\\hat{p}, \\hat{s}, \\hat{d}, \\hat{t})$ equals $(p, s, d, t)$ with string equality for $\\hat{p}$ and $\\hat{t}$ and tolerance-based equality for $\\hat{s}$ and $\\hat{d}$ using $\\epsilon = 10^{-12}$.\n   - The UCUM unit code remains \"mm[Hg]\" and the unit system remains \"http://unitsofmeasure.org\" for both components.\n   - The LOINC codes for the panel and components remain as specified.\n5. Simulate the EHR transformation $T$ with the following policies:\n   - Identity: no change.\n   - Display-only unit change: change the human-readable valueQuantity.unit display string but do not change UCUM code or system.\n   - Wrong UCUM code: change the valueQuantity.code to a non-UCUM canonical code (e.g., \"mmHg\"), leaving other fields untouched.\n   - Swap component codes: swap the LOINC codes of systolic and diastolic components without changing values or units.\n\nAll physical quantities must be expressed in millimeters of mercury, and the UCUM code must be \"mm[Hg]\". No angles or percentages are involved.\n\nTest suite:\nUse the following test cases as input measurement tuples $(p, s, d, t)$ and EHR policies, ensuring scientific plausibility:\n- Case $1$: $(\\text{\"p001\"},\\, s = 120.0,\\, d = 80.0,\\, \\text{\"2023-01-10T08:30:00Z\"})$ with policy Identity.\n- Case $2$: $(\\text{\"p002\"},\\, s = 200.0,\\, d = 110.0,\\, \\text{\"2023-01-10T14:45:00Z\"})$ with policy Display-only unit change.\n- Case $3$: $(\\text{\"p003\"},\\, s = 119.75,\\, d = 76.5,\\, \\text{\"2023-02-01T07:00:00Z\"})$ with policy Identity.\n- Case $4$: $(\\text{\"p004\"},\\, s = 85.0,\\, d = 55.0,\\, \\text{\"2023-02-15T11:15:00Z\"})$ with policy Wrong UCUM code.\n- Case $5$: $(\\text{\"p005\"},\\, s = 130.0,\\, d = 70.0,\\, \\text{\"2023-03-05T12:00:00Z\"})$ with policy Swap component codes.\n\nAnswer specification:\n- For each test case, output a boolean indicating whether round-trip fidelity holds, as defined by the conditions in item $4$ above.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets using lowercase boolean literals, for example, \"[true,false,true,false,true]\".",
            "solution": "The problem avers a task in medical informatics: to design a computational model for representing a blood pressure measurement using modern healthcare interoperability standards—specifically FHIR, LOINC, and UCUM—and to verify the semantic fidelity of this representation after a simulated transformation by an Electronic Health Record (EHR) system. The problem is scientifically grounded, well-posed, and objective, providing a valid basis for a formal solution.\n\nThe foundational principle is semantic interoperability: the ability of computer systems to exchange data with unambiguous, shared meaning. In healthcare, this is critical for patient safety and continuity of care. The standards specified—FHIR, LOINC, and UCUM—form a robust framework for this purpose.\n- **FHIR (Fast Healthcare Interoperability Resources)** provides the data structure, in this case, an `Observation` resource, which acts as a container for the clinical finding.\n- **LOINC (Logical Observation Identifiers Names and Codes)** provides a universal code system for identifying the observation itself (e.g., the \"blood pressure panel\", code \"85354-9\") and its discrete components (systolic pressure, code \"8480-6\"; diastolic pressure, code \"8462-4\"). Using these codes ensures that any system can understand precisely what was measured, regardless of the local language or display names.\n- **UCUM (Unified Code for Units of Measure)** provides a formal, unambiguous system for representing units of measure. The UCUM code for millimeters of mercury, \"`mm[Hg]`\", is semantically distinct from a human-readable display string like \"`mmHg`\". This distinction is crucial; semantic fidelity is tied to the canonical code, not the display string.\n\nThe problem defines a mathematical model for round-trip data fidelity. A measurement tuple $x = (p, s, d, t)$, where $p$ is the patient identifier, $s$ is the systolic value, $d$ is the diastolic value, and $t$ is the timestamp, is encoded into a FHIR structure $y$ by an encoder function $E$. This structure $y$ undergoes a transformation $T$ simulating an EHR process, resulting in $y'$. A decoder function $D$ then attempts to reconstruct the original information from $y'$, yielding $\\hat{x} = (\\hat{p}, \\hat{s}, \\hat{d}, \\hat{t})$. Fidelity is achieved if $\\hat{x}$ is equivalent to $x$, defined by string equality for $p$ and $t$, and a numerical tolerance for the floating-point values $s$ and $d$: specifically, $|\\hat{s} - s| \\le \\epsilon$ and $|\\hat{d} - d| \\le \\epsilon$ for a given tolerance $\\epsilon = 10^{-12}$. Furthermore, true fidelity requires that the core semantic identifiers (LOINC and UCUM codes) within the data structure $y'$ remain unaltered.\n\nOur solution implements this model through a series of functions:\n\n1.  **Encoder $E(x)$**: This function, `encode_bp_observation`, constructs a Python dictionary that represents the FHIR `Observation` resource. It takes the input tuple $(p, s, d, t)$ and populates the structure according to the problem's strict specifications. This includes assigning the LOINC panel code \"85354-9\", creating two `component` entries for systolic (\"8480-6\") and diastolic (\"8462-4\") pressures, and ensuring each component's `valueQuantity` uses the correct UCUM system \"`http://unitsofmeasure.org`\" and code \"`mm[Hg]`\".\n\n2.  **Transformation $T(y)$**: The `apply_ehr_transformation` function simulates the EHR's handling of the data. It accepts the FHIR dictionary and a policy name. To ensure the original encoded object is pristine, it operates on a deep copy of the input.\n    - **Identity**: Returns an identical copy. This is the baseline for perfect transmission.\n    - **Display-only unit change**: Alters only the human-readable `valueQuantity.unit` string. This tests whether the system correctly distinguishes between display information and semantic information.\n    - **Wrong UCUM code**: Corrupts the semantic `valueQuantity.code` by changing it from \"`mm[Hg]`\" to a non-canonical string like \"`mmHg`\". This is a critical semantic error.\n    - **Swap component codes**: Swaps the LOINC codes between the systolic and diastolic components, disassociating the code from its corresponding value. This tests if the decoder is robustly identifying values by their codes, not by their position in an array.\n\n3.  **Decoder $D(y')$**: The `decode_bp_observation` function is designed for robustness. It parses a given FHIR `Observation` dictionary to extract the measurement tuple $(\\hat{p}, \\hat{s}, \\hat{d}, \\hat{t})$. Crucially, it does not assume a fixed order for the components. It iterates through the `component` list and identifies the systolic and diastolic values by their unique LOINC codes, \"`8480-6`\" and \"`8462-4`\", respectively. This design is essential for correctly handling scenarios like the component code swap.\n\n4.  **Fidelity Checker**: The `check_fidelity` function orchestrates the verification. It takes the original input tuple $x$ and the transformed FHIR object $y'$. It first uses the decoder $D$ to obtain the reconstructed tuple $\\hat{x}$. It then performs two sets of checks:\n    - **Value Fidelity**: It compares the components of $x$ and $\\hat{x}$—patient ID $\\hat{p}$ vs $p$, timestamp $\\hat{t}$ vs $t$, and blood pressure values $\\hat{s}$ vs $s$ and $\\hat{d}$ vs $d$ using the specified tolerance $\\epsilon = 10^{-12}$.\n    - **Semantic Fidelity**: It directly inspects the transformed object $y'$ to verify that all specified LOINC and UCUM codes and systems are present and correct. Any deviation, such as a modified UCUM code, results in a failure.\n\nA measurement passes the fidelity check only if both value and semantic integrity are fully preserved.\n\nThe analysis of the test cases is as follows:\n- **Case 1 (Identity)**: No changes are made. All values and codes are preserved. **Fidelity holds.**\n- **Case 2 (Display-only unit change)**: The human-readable `unit` string is changed, but the canonical UCUM `code` \"`mm[Hg]`\" is not. Our fidelity checker correctly ignores the display string, as it is semantically irrelevant. **Fidelity holds.**\n- **Case 3 (Identity with floats)**: A test with non-integer values ($s=119.75, d=76.5$) confirms that the floating-point comparison with tolerance $\\epsilon = 10^{-12}$ works as expected. **Fidelity holds.**\n- **Case 4 (Wrong UCUM code)**: The UCUM code is changed to a non-standard value. The semantic check for `code == \"mm[Hg]\"` will fail. **Fidelity is lost.**\n- **Case 5 (Swap component codes)**: The LOINC codes for systolic and diastolic are swapped. The decoder, searching by code, will assign the diastolic value ($d=70.0$) to the systolic variable $\\hat{s}$, and the systolic value ($s=130.0$) to the diastolic variable $\\hat{d}$. The value comparison check will subsequently fail. **Fidelity is lost.**\n\nThe expected boolean results are therefore `[true, true, true, false, false]`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom copy import deepcopy\n\n# Define global constants for standard codes and systems\nLOINC_SYSTEM = \"http://loinc.org\"\nUCUM_SYSTEM = \"http://unitsofmeasure.org\"\nBP_PANEL_CODE = \"85354-9\"\nSYSTOLIC_CODE = \"8480-6\"\nDIASTOLIC_CODE = \"8462-4\"\nUCUM_MMHG_CODE = \"mm[Hg]\"\nTOLERANCE = 1e-12\n\ndef encode_bp_observation(p, s, d, t):\n    \"\"\"\n    Encoder function E(x): Maps a measurement tuple to a FHIR Observation structure.\n    \n    Args:\n        p (str): Patient identifier.\n        s (float): Systolic blood pressure.\n        d (float): Diastolic blood pressure.\n        t (str): ISO 8601 observation time.\n        \n    Returns:\n        dict: A dictionary representing the FHIR Observation resource.\n    \"\"\"\n    observation = {\n        'resourceType': 'Observation',\n        'status': 'final',\n        'category': [{\n            'coding': [{\n                'system': 'http://terminology.hl7.org/CodeSystem/observation-category',\n                'code': 'vital-signs',\n                'display': 'Vital Signs'\n            }]\n        }],\n        'code': {\n            'coding': [{\n                'system': LOINC_SYSTEM,\n                'code': BP_PANEL_CODE,\n                'display': 'Blood pressure panel'\n            }]\n        },\n        'subject': {\n            'reference': f'Patient/{p}'\n        },\n        'effectiveDateTime': t,\n        'component': [\n            {  # Systolic Component\n                'code': {\n                    'coding': [{\n                        'system': LOINC_SYSTEM,\n                        'code': SYSTOLIC_CODE,\n                        'display': 'Systolic blood pressure'\n                    }]\n                },\n                'valueQuantity': {\n                    'value': s,\n                    'unit': 'mmHg',\n                    'system': UCUM_SYSTEM,\n                    'code': UCUM_MMHG_CODE\n                }\n            },\n            {  # Diastolic Component\n                'code': {\n                    'coding': [{\n                        'system': LOINC_SYSTEM,\n                        'code': DIASTOLIC_CODE,\n                        'display': 'Diastolic blood pressure'\n                    }]\n                },\n                'valueQuantity': {\n                    'value': d,\n                    'unit': 'mmHg',\n                    'system': UCUM_SYSTEM,\n                    'code': UCUM_MMHG_CODE\n                }\n            }\n        ]\n    }\n    return observation\n\ndef apply_ehr_transformation(observation, policy):\n    \"\"\"\n    Transformation function T(y): Simulates an EHR transformation on the FHIR resource.\n    \n    Args:\n        observation (dict): The input FHIR Observation.\n        policy (str): The name of the transformation policy to apply.\n        \n    Returns:\n        dict: The transformed FHIR Observation.\n    \"\"\"\n    transformed_obs = deepcopy(observation)\n    if policy == \"Identity\":\n        pass  # No changes\n    elif policy == \"Display-only unit change\":\n        for comp in transformed_obs.get('component', []):\n            if 'valueQuantity' in comp:\n                comp['valueQuantity']['unit'] = 'millimeters of mercury'\n    elif policy == \"Wrong UCUM code\":\n        for comp in transformed_obs.get('component', []):\n            if 'valueQuantity' in comp:\n                comp['valueQuantity']['code'] = 'mmHg'  # Incorrect canonical code\n    elif policy == \"Swap component codes\":\n        if len(transformed_obs.get('component', [])) == 2:\n            comp0_code = transformed_obs['component'][0]['code']\n            comp1_code = transformed_obs['component'][1]['code']\n            transformed_obs['component'][0]['code'] = comp1_code\n            transformed_obs['component'][1]['code'] = comp0_code\n    return transformed_obs\n\ndef decode_bp_observation(observation):\n    \"\"\"\n    Decoder function D(y'): Parses a FHIR Observation to extract the measurement tuple.\n    \n    Args:\n        observation (dict): The FHIR Observation resource.\n        \n    Returns:\n        tuple: The extracted tuple (p, s, d, t). Values may be None if not found.\n    \"\"\"\n    p_hat = observation.get('subject', {}).get('reference', 'Patient/').replace('Patient/', '')\n    t_hat = observation.get('effectiveDateTime')\n    \n    s_hat, d_hat = None, None\n    components = observation.get('component', [])\n    for comp in components:\n        # Safely access nested coding information\n        coding_list = comp.get('code', {}).get('coding', [])\n        if not coding_list:\n            continue\n        comp_code = coding_list[0].get('code')\n        \n        value = comp.get('valueQuantity', {}).get('value')\n        \n        if comp_code == SYSTOLIC_CODE:\n            s_hat = value\n        elif comp_code == DIASTOLIC_CODE:\n            d_hat = value\n            \n    return p_hat, s_hat, d_hat, t_hat\n\ndef check_fidelity(original_input, transformed_observation):\n    \"\"\"\n    Verifies the round-trip fidelity based on value and semantic checks.\n    \n    Args:\n        original_input (tuple): The original (p, s, d, t) tuple.\n        transformed_observation (dict): The FHIR Observation after transformation.\n        \n    Returns:\n        bool: True if fidelity is maintained, False otherwise.\n    \"\"\"\n    p_orig, s_orig, d_orig, t_orig = original_input\n\n    # 1. Decode the transformed observation\n    p_hat, s_hat, d_hat, t_hat = decode_bp_observation(transformed_observation)\n\n    # 2. Perform value fidelity check on decoded data\n    if None in (p_hat, s_hat, d_hat, t_hat):\n        return False # Decoding failed to find all required elements\n\n    value_check_passed = (\n        p_hat == p_orig and\n        t_hat == t_orig and\n        abs(s_hat - s_orig) <= TOLERANCE and\n        abs(d_hat - d_orig) <= TOLERANCE\n    )\n    if not value_check_passed:\n        return False\n\n    # 3. Perform semantic fidelity check directly on the transformed structure\n    # Check top-level panel code\n    panel_coding = transformed_observation.get('code', {}).get('coding', [{}])[0]\n    if not (panel_coding.get('system') == LOINC_SYSTEM and panel_coding.get('code') == BP_PANEL_CODE):\n        return False\n\n    # Check components for correct codes and units\n    components = transformed_observation.get('component', [])\n    if len(components) != 2:\n        return False\n\n    found_systolic, found_diastolic = False, False\n    for comp in components:\n        comp_coding = comp.get('code', {}).get('coding', [{}])[0]\n        loinc_code = comp_coding.get('code')\n        \n        value_quant = comp.get('valueQuantity', {})\n        ucum_code = value_quant.get('code')\n        ucum_system = value_quant.get('system')\n        \n        # Check that codes and systems required for semantic integrity are correct\n        if not (comp_coding.get('system') == LOINC_SYSTEM and ucum_system == UCUM_SYSTEM and ucum_code == UCUM_MMHG_CODE):\n            return False\n\n        if loinc_code == SYSTOLIC_CODE:\n            found_systolic = True\n        elif loinc_code == DIASTOLIC_CODE:\n            found_diastolic = True\n        else:\n            return False # An invalid component code was found\n    \n    # Ensure both components, correctly identified, were present\n    return found_systolic and found_diastolic\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'input': (\"p001\", 120.0, 80.0, \"2023-01-10T08:30:00Z\"), 'policy': \"Identity\"},\n        # Case 2\n        {'input': (\"p002\", 200.0, 110.0, \"2023-01-10T14:45:00Z\"), 'policy': \"Display-only unit change\"},\n        # Case 3\n        {'input': (\"p003\", 119.75, 76.5, \"2023-02-01T07:00:00Z\"), 'policy': \"Identity\"},\n        # Case 4\n        {'input': (\"p004\", 85.0, 55.0, \"2023-02-15T11:15:00Z\"), 'policy': \"Wrong UCUM code\"},\n        # Case 5\n        {'input': (\"p005\", 130.0, 70.0, \"2023-03-05T12:00:00Z\"), 'policy': \"Swap component codes\"},\n    ]\n\n    results = []\n    for case in test_cases:\n        original_input = case['input']\n        policy = case['policy']\n        \n        p, s, d, t = original_input\n\n        # E(x): Encode original measurement into a FHIR Observation\n        observation = encode_bp_observation(p, s, d, t)\n        \n        # T(E(x)): Apply the EHR transformation policy\n        transformed_obs = apply_ehr_transformation(observation, policy)\n        \n        # Check fidelity of the transformed observation against the original input\n        is_faithful = check_fidelity(original_input, transformed_obs)\n        results.append(is_faithful)\n\n    # Format the final output string as specified\n    result_string = f\"[{','.join(map(str, results))}]\".lower()\n    print(result_string)\n\nsolve()\n```"
        }
    ]
}