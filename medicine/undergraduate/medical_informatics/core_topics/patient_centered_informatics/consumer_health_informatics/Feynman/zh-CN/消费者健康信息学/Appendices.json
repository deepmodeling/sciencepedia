{
    "hands_on_practices": [
        {
            "introduction": "有效的沟通是消费者健康信息学的基石。为了做出明智的决策，消费者需要清晰地理解健康信息，但“相对风险降低”这类统计术语如果脱离上下文，则可能产生误导。本练习将挑战您区分相对风险与绝对风险，并学习如何将复杂的统计数据转化为对患者有意义的、易于理解的语言 。",
            "id": "4831516",
            "problem": "一位消费者健康信息学 (CHI) 门户的设计者需要以一种数学上有效且易于理解的方式向患者展示治疗益处。在该门户网站中，某一用户群发生特定不良事件的基线风险为 $2\\%$，而治疗被描述为可提供 $50\\%$ 的相对风险降低。仅使用基本定义，将“风险”视为在固定时间范围内事件发生的概率，取值在 $[0,1]$ 之间；将“相对风险降低”解释为风险相对于基线的成比例减少；将“绝对风险降低”解释为事件概率的变化。\n\n任务：\n1. 根据这些定义，推导出以基线风险和相对风险降低表示的治疗后风险的表达式。\n2. 根据您的推导，计算在基线风险为 $2\\%$ 和相对风险降低为 $50\\%$ 的情况下的绝对风险降低（即治疗前风险与治疗后风险之差）。\n3. 撰写一句适合患者的通俗易懂的解释，该解释能正确反映您的定量结果（例如，通过提及每 $100$ 人的结果）。\n\n将任务2的最终数值答案表示为小数（不使用百分号）。无需进行四舍五入；请提供精确的小数值。",
            "solution": "我们从基本定义开始。设 $p_{0} \\in [0,1]$ 表示给定人群在特定时期内发生不良事件的基线概率（风险），设 $p_{1} \\in [0,1]$ 表示干预后的治疗后概率（风险）。根据定义，绝对风险降低 (ARR) 是概率的变化：\n$$\n\\text{ARR} = p_{0} - p_{1}.\n$$\n相对风险降低 (RRR) 定义为风险相对于基线的成比例减少：\n$$\n\\text{RRR} = \\frac{p_{0} - p_{1}}{p_{0}}.\n$$\n这个定义可以重新整理，以 $p_{0}$ 和 $\\text{RRR}$ 来表示 $p_{1}$：\n$$\n\\text{RRR} = 1 - \\frac{p_{1}}{p_{0}} \\quad \\Longrightarrow \\quad \\frac{p_{1}}{p_{0}} = 1 - \\text{RRR} \\quad \\Longrightarrow \\quad p_{1} = p_{0}\\,(1 - \\text{RRR}).\n$$\n将这个 $p_{1}$ 代入 $\\text{ARR}$ 的表达式中，得到：\n$$\n\\text{ARR} = p_{0} - p_{0}(1 - \\text{RRR}) = p_{0}\\,\\text{RRR}.\n$$\n现在根据给定的数值进行计算。基线风险为 $2\\%$ 对应于概率 $p_{0} = 0.02$，相对风险降低为 $50\\%$ 对应于比例 $\\text{RRR} = 0.50$。计算治疗后风险：\n$$\np_{1} = 0.02\\,(1 - 0.50) = 0.02 \\times 0.50 = 0.01.\n$$\n因此，绝对风险降低为：\n$$\n\\text{ARR} = p_{0} - p_{1} = 0.02 - 0.01 = 0.01.\n$$\n与这些数值相符的通俗解释可以是：“如果不进行治疗，预计每 $100$ 人中约有 $2$ 人会发生该事件；如果进行治疗，每 $100$ 人中约有 $1$ 人会发生，因此该治疗可以为像您这样的每 $100$ 人预防约 $1$ 次事件。”这个陈述准确地反映了 $p_{0} = 0.02$，$p_{1} = 0.01$ 和 $\\text{ARR} = 0.01$。\n\n所要求的绝对风险降低的最终数值答案，以小数表示为 $0.01$。",
            "answer": "$$\\boxed{0.01}$$"
        },
        {
            "introduction": "消费者健康应用收集的数据极其敏感，保护用户隐私是其核心伦理要求。本练习将带您深入数据去标识化的一项基本技术：$k$-匿名化。通过一个动手编程实践，您将学习如何通过数据泛化和记录抑制等方法来处理数据集，以确保其中任何一条记录都无法与少于 $k$ 个其他记录区分开来，从而有效保护个人隐私 。",
            "id": "4831449",
            "problem": "一个消费者健康数据集包含带有准标识符的个体层面记录：邮政编码 (ZIP)、出生日期和性别。其基本基础是 $k$-匿名的定义：对于给定的 $k \\in \\mathbb{N}$，如果数据集中每个关于准标识符不可区分的记录所组成的等价类的大小至少为 $k$，则该数据集满足 $k$-匿名。在选定的泛化规则下，如果两条记录的每个准标识符经过相同泛化处理后，得到的泛化元组完全相同，则这两条记录是不可区分的。抑制（Suppression）会移除违反 $k$-匿名约束的记录，并且此过程会迭代应用，因为移除某些记录可能会改变剩余记录的等价类大小。\n\n您必须编写一个程序，对于固定的 $k=5$，计算在应用指定的泛化参数后，并迭代抑制所有大小小于 $k$ 的等价类中的记录，直到不存在此类等价类为止，所达到的 $k$-匿名级别（即最小等价类的大小）。如果抑制后没有记录剩余，则将达到的级别定义为 $0$。\n\n准标识符的泛化定义如下：\n- 邮政编码泛化参数 $g_{\\text{zip}} \\in \\{0,2,3,5\\}$ 表示：保留 $5$ 位邮政编码的前 $g_{\\text{zip}}$ 位数字，并将其余数字替换为星号字符 $\\text{\"*\"}$。例如，当 $g_{\\text{zip}}=3$ 时，$\\text{\"02139\"} \\mapsto \\text{\"021**\"}$；当 $g_{\\text{zip}}=0$ 时，任何邮政编码都映射为 $\\text{\"*****\"}$；当 $g_{\\text{zip}}=5$ 时，邮政编码保持不变。\n- 出生日期泛化参数 $g_{\\text{date}} \\in \\{\\text{\"day\"},\\text{\"month\"},\\text{\"year\"},\\text{\"decade\"}\\}$ 表示：\n  - $\\text{\"day\"}$：保持 $\\text{\"YYYY-MM-DD\"}$ 不变。\n  - $\\text{\"month\"}$：仅保留 $\\text{\"YYYY-MM\"}$。\n  - $\\text{\"year\"}$：仅保留 $\\text{\"YYYY\"}$。\n  - $\\text{\"decade\"}$：将年份 $\\text{\"YYYY\"}$ 映射到其年代标签 $\\text{\"YYYYs\"}$，其中 $\\text{\"YYYY\"}$ 被替换为年代的起始年份 $\\left\\lfloor \\frac{\\text{YYYY}}{10} \\right\\rfloor \\times 10$；例如，$\\text{\"1981-07-27\"} \\mapsto \\text{\"1980s\"}$ 且 $\\text{\"1979-12-12\"} \\mapsto \\text{\"1970s\"}$。\n- 性别泛化参数 $g_{\\text{gen}} \\in \\{\\text{\"exact\"},\\text{\"*\"}\\}$ 表示：\n  - $\\text{\"exact\"}$：保持 $\\text{\"M\"}$ 或 $\\text{\"F\"}$ 不变。\n  - $\\text{\"*\"}$：将任何性别替换为 $\\text{\"*\"}$。\n\n等价类由相同的泛化值三元组 $(\\text{ZIP}^{\\prime}, \\text{Birth}^{\\prime}, \\text{Gender}^{\\prime})$ 构成。抑制过程是迭代应用的：在每次迭代中，移除所有属于大小小于 $k$ 的等价类的记录；在剩余记录上重新计算等价类大小；重复此过程，直到没有等价类的大小小于 $k$ 或没有记录剩余为止。\n\n数据集：共有 $30$ 条记录。每条记录是一个三元组 $\\left(\\text{ZIP}, \\text{Birthdate}, \\text{Gender}\\right)$，其中 ZIP 是一个 $5$ 位数字的字符串，Birthdate 格式为 $\\text{\"YYYY-MM-DD\"}$，Gender 为 $\\text{\"M\"}$ 或 $\\text{\"F\"}$：\n- $\\left(\\text{\"02139\"},\\ \\text{\"1980-01-15\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02138\"},\\ \\text{\"1980-02-20\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02139\"},\\ \\text{\"1980-03-25\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02140\"},\\ \\text{\"1980-04-05\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02138\"},\\ \\text{\"1980-05-30\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02139\"},\\ \\text{\"1980-06-10\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02139\"},\\ \\text{\"1980-07-12\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"02138\"},\\ \\text{\"1980-08-08\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"02140\"},\\ \\text{\"1980-09-19\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"02139\"},\\ \\text{\"1980-10-21\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"10012\"},\\ \\text{\"1980-02-14\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"10011\"},\\ \\text{\"1980-03-01\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"10013\"},\\ \\text{\"1980-06-18\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"10012\"},\\ \\text{\"1980-07-07\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"10011\"},\\ \\text{\"1980-11-30\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"10013\"},\\ \\text{\"1981-01-09\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"10012\"},\\ \\text{\"1981-03-22\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"10011\"},\\ \\text{\"1981-05-11\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"10012\"},\\ \\text{\"1981-07-27\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"10013\"},\\ \\text{\"1981-09-13\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"30303\"},\\ \\text{\"1979-02-02\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"30310\"},\\ \\text{\"1979-12-12\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"30309\"},\\ \\text{\"1980-01-03\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"30303\"},\\ \\text{\"1980-05-20\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"30310\"},\\ \\text{\"1980-08-28\"},\\ \\text{\"F\"}\\right)$\n- $\\left(\\text{\"02138\"},\\ \\text{\"1981-02-17\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02139\"},\\ \\text{\"1981-04-26\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02140\"},\\ \\text{\"1981-06-06\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02138\"},\\ \\text{\"1981-08-16\"},\\ \\text{\"M\"}\\right)$\n- $\\left(\\text{\"02139\"},\\ \\text{\"1981-12-01\"},\\ \\text{\"M\"}\\right)$\n\n测试套件：对于每个测试用例，应用指定的泛化参数 $\\left(g_{\\text{zip}}, g_{\\text{date}}, g_{\\text{gen}}\\right)$，设 $k=5$，执行迭代抑制，并报告达到的级别（一个整数），该级别定义为剩余数据集中最小等价类的大小（如果为空则为 $0$）。测试用例如下：\n- 测试 $1$：$\\left(3,\\ \\text{\"year\"},\\ \\text{\"exact\"}\\right)$\n- 测试 $2$：$\\left(2,\\ \\text{\"decade\"},\\ \\text{\"*\"}\\right)$\n- 测试 $3$：$\\left(5,\\ \\text{\"month\"},\\ \\text{\"exact\"}\\right)$\n- 测试 $4$：$\\left(3,\\ \\text{\"year\"},\\ \\text{\"*\"}\\right)$\n- 测试 $5$：$\\left(0,\\ \\text{\"decade\"},\\ \\text{\"*\"}\\right)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与测试用例相同（例如，$\\text{\"[a,b,c,d,e]\"}$，其中 $a,b,c,d,e$ 均为达到的整数级别）。",
            "solution": "用户提供的问题是有效的。它在科学上基于数据隐私的原则，特别是 $k$-匿名。该问题定义明确，给出了一套完整且一致的已知条件，包括一个数据集、一个固定的参数 $k$、精确的泛化层级，以及一个用于迭代抑制的确定性算法。每个测试用例都存在唯一的解。\n\n问题的核心是确定数据集在应用特定转换后的隐私级别。这是通过实现一个两阶段过程来完成的，对于给定的匿名参数 $k \\in \\mathbb{N}$（在此设为 $k=5$）。这两个阶段是泛化和抑制。\n\n阶段 1：泛化\n数据集包含 $N=30$ 条记录，每条记录是一个准标识符元组：$(\\text{ZIP}, \\text{Birthdate}, \\text{Gender})$。泛化是将这些特定的准标识符转换为不那么具体但语义上一致的值的过程。设一条记录为 $r_i = (\\text{QID}_{i,1}, \\text{QID}_{i,2}, \\text{QID}_{i,3})$，其中 $i=1, \\dots, N$。一组泛化函数（每个准标识符对应一个）将应用于每条记录。\n$r_i \\mapsto r_i^{\\prime} = (g_1(\\text{QID}_{i,1}), g_2(\\text{QID}_{i,2}), g_3(\\text{QID}_{i,3}))$\n具体的泛化函数由参数 $(g_{\\text{zip}}, g_{\\text{date}}, g_{\\text{gen}})$ 定义。\n\n- 邮政编码泛化：对于一个 $5$ 位数字的 ZIP 编码字符串和一个参数 $g_{\\text{zip}} \\in \\{0,2,3,5\\}$，该函数保留前 $g_{\\text{zip}}$ 位数字，并将剩余的 $5 - g_{\\text{zip}}$ 位数字替换为星号 '*'。例如，对于 $g_{\\text{zip}}=3$，ZIP \"02139\" 被映射为 \"021**\"。\n\n- 出生日期泛化：对于一个日期字符串 \"YYYY-MM-DD\" 和一个参数 $g_{\\text{date}} \\in \\{\\text{\"day\"},\\text{\"month\"},\\text{\"year\"},\\text{\"decade\"}\\}$，转换如下：\n    - $g_{\\text{date}} = \\text{\"day\"}$：日期保持不变。\n    - $g_{\\text{date}} = \\text{\"month\"}$：日期被截断为 \"YYYY-MM\"。\n    - $g_{\\text{date}} = \\text{\"year\"}$：日期被截断为 \"YYYY\"。\n    - $g_{\\text{date}} = \\text{\"decade\"}$：将年份 YYYY 映射到其年代，表示为 $\\left\\lfloor \\frac{\\text{YYYY}}{10} \\right\\rfloor \\times 10$，并格式化为类似 \"1980s\" 的字符串。\n\n- 性别泛化：对于一个性别字符串和一个参数 $g_{\\text{gen}} \\in \\{\\text{\"exact\"},\\text{\"*\"}\\}$，转换如下：\n    - $g_{\\text{gen}} = \\text{\"exact\"}$：性别保持不变。\n    - $g_{\\text{gen}} = \\text{\"*\"}$：性别被替换为星号 '*'。\n\n此阶段之后，原始数据集被转换为一个泛化数据集，其中每条记录 $r_i$ 都被其泛化版本 $r_i^{\\prime}$ 替代。\n\n阶段 2：迭代抑制\n一个等价类是一组其泛化准标识符元组完全相同的记录集合。设 $E_j$ 是一个等价类。如果对于所有的 $j$，类的大小 $|E_j| \\ge k$，则称该数据集满足 $k$-匿名。\n\n抑制过程是迭代的。在每次迭代中，算法执行以下步骤：\n1.  将当前的（泛化）记录集划分为等价类。\n2.  计算每个等价类的大小 $|E_j|$。\n3.  识别所有大小 $|E_j|  k$ 的等价类。\n4a. 如果不存在此类等价类，则过程终止。数据集现在是 $k$-匿名的。\n4b. 如果存在此类等价类，则属于这些等价类的所有记录都将从数据集中移除（被抑制）。\n5.  从步骤 1 开始，用缩减后的数据集重复此过程。\n\n这个迭代过程保证会终止，因为数据集中的记录数量是有限的，并且在每一步都是非递增的。\n\n最终计算\n一旦迭代抑制完成，就确定“达到的 $k$-匿名级别”。\n- 如果最终的数据集为空（所有记录都被抑制），则达到的级别定义为 $0$。\n- 否则，达到的级别是所有剩余等价类中的最小大小。根据构造，该值将大于或等于 $k=5$。\n\n每个测试用例 $(g_{\\text{zip}}, g_{\\text{date}}, g_{\\text{gen}})$ 的算法：\n1.  用原始的 $30$ 条记录初始化一个记录列表 `current_records`。\n2.  通过对 `current_records` 中的每条记录应用由 $(g_{\\text{zip}}, g_{\\text{date}}, g_{\\text{gen}})$ 定义的泛化函数，创建一个相应的泛化记录列表 `generalized_records`。\n3.  进入一个循环，直到达到不动点：\n    a. 如果 `generalized_records` 为空，则跳出循环。\n    b. 对 `generalized_records` 进行分组，并计算每个等价类的大小。这可以使用哈希映射或 `Counter` 对象来完成，将每个唯一的泛化元组映射到其频率。\n    c. 识别出“无效”的泛化元组集合 `tuples_to_suppress`，即其频率小于 $k=5$ 的元组。\n    d. 如果 `tuples_to_suppress` 为空，则跳出循环。\n    e. 通过过滤掉任何其泛化元组在 `tuples_to_suppress` 中的记录，创建一个新的 `generalized_records` 列表。\n4.  循环终止后：\n    a. 如果最终的 `generalized_records` 列表为空，则结果为 $0$。\n    b. 否则，计算剩余唯一元组的频率。结果是这些频率中的最小值。\n5.  存储此结果。在处理完所有测试用例后，将结果格式化为逗号分隔的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Computes the achieved k-anonymity for a dataset given various generalization\n    and suppression rules.\n    \"\"\"\n    \n    # Define the dataset as a list of tuples.\n    dataset = [\n        (\"02139\", \"1980-01-15\", \"M\"), (\"02138\", \"1980-02-20\", \"M\"),\n        (\"02139\", \"1980-03-25\", \"M\"), (\"02140\", \"1980-04-05\", \"M\"),\n        (\"02138\", \"1980-05-30\", \"M\"), (\"02139\", \"1980-06-10\", \"M\"),\n        (\"02139\", \"1980-07-12\", \"F\"), (\"02138\", \"1980-08-08\", \"F\"),\n        (\"02140\", \"1980-09-19\", \"F\"), (\"02139\", \"1980-10-21\", \"F\"),\n        (\"10012\", \"1980-02-14\", \"M\"), (\"10011\", \"1980-03-01\", \"M\"),\n        (\"10013\", \"1980-06-18\", \"M\"), (\"10012\", \"1980-07-07\", \"M\"),\n        (\"10011\", \"1980-11-30\", \"M\"), (\"10013\", \"1981-01-09\", \"F\"),\n        (\"10012\", \"1981-03-22\", \"F\"), (\"10011\", \"1981-05-11\", \"F\"),\n        (\"10012\", \"1981-07-27\", \"F\"), (\"10013\", \"1981-09-13\", \"F\"),\n        (\"30303\", \"1979-02-02\", \"M\"), (\"30310\", \"1979-12-12\", \"M\"),\n        (\"30309\", \"1980-01-03\", \"F\"), (\"30303\", \"1980-05-20\", \"F\"),\n        (\"30310\", \"1980-08-28\", \"F\"), (\"02138\", \"1981-02-17\", \"M\"),\n        (\"02139\", \"1981-04-26\", \"M\"), (\"02140\", \"1981-06-06\", \"M\"),\n        (\"02138\", \"1981-08-16\", \"M\"), (\"02139\", \"1981-12-01\", \"M\"),\n    ]\n\n    # Define the generalization parameters for the test suite.\n    test_cases = [\n        (3, \"year\", \"exact\"),\n        (2, \"decade\", \"*\"),\n        (5, \"month\", \"exact\"),\n        (3, \"year\", \"*\"),\n        (0, \"decade\", \"*\"),\n    ]\n    \n    k_anonymity_param = 5\n    results = []\n\n    def generalize_zip(zip_code, g_zip):\n        return zip_code[:g_zip] + '*' * (5 - g_zip)\n\n    def generalize_date(birthdate, g_date):\n        if g_date == \"day\":\n            return birthdate\n        if g_date == \"month\":\n            return birthdate[:7]  # YYYY-MM\n        if g_date == \"year\":\n            return birthdate[:4]  # YYYY\n        if g_date == \"decade\":\n            year = int(birthdate[:4])\n            decade_start = (year // 10) * 10\n            return f\"{decade_start}s\"\n        return birthdate\n\n    def generalize_gender(gender, g_gen):\n        return gender if g_gen == \"exact\" else \"*\"\n\n    for g_zip, g_date, g_gen in test_cases:\n        # Phase 1: Generalization\n        generalized_records = []\n        for zip_code, birthdate, gender in dataset:\n            generalized_zip = generalize_zip(zip_code, g_zip)\n            generalized_date = generalize_date(birthdate, g_date)\n            generalized_gender = generalize_gender(gender, g_gen)\n            generalized_records.append(\n                (generalized_zip, generalized_date, generalized_gender)\n            )\n        \n        # Phase 2: Iterative Suppression\n        current_records = list(generalized_records)\n        while True:\n            if not current_records:\n                break\n            \n            class_counts = Counter(current_records)\n            \n            records_to_suppress = {\n                rec for rec, count in class_counts.items() if count  k_anonymity_param\n            }\n            \n            if not records_to_suppress:\n                # Fixed point reached: no classes violate k-anonymity\n                break\n            \n            current_records = [\n                rec for rec in current_records if rec not in records_to_suppress\n            ]\n\n        # Final Calculation\n        if not current_records:\n            achieved_level = 0\n        else:\n            final_counts = Counter(current_records)\n            achieved_level = min(final_counts.values())\n        \n        results.append(achieved_level)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}