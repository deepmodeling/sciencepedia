{
    "hands_on_practices": [
        {
            "introduction": "临床实验室结果是临床数据的核心来源。为了使这些数据能够被计算机处理和理解，我们需要一个标准化的方式来命名每一项检测。逻辑观察标识符命名和编码系统（LOINC）通过其六轴模型为我们提供了这种能力，能够精确地描述一项观察。这个练习将指导您把一个常见的检验项目——“血清葡萄糖”——分解为其基本组成部分，从而加深您对结构化术语系统如何为临床观察创建无歧义、机器可读的表示的理解。",
            "id": "4828090",
            "problem": "一个临床检验信息系统需要使用逻辑观察标识符名称和代码 (LOINC) 的六轴组合模型来表示血清葡萄糖的单时间点定量测量。LOINC 的六个轴定义如下：组分（分析物或观察项）、属性（测量的特性）、时间（测量的时间维度）、系统（标本或系统）、标度（测量标度类型）和方法（分析技术）。该系统收到了一个典型的化学检验结果，该结果是针对在单个时间点采集的血清标本，以毫克/分升为单位报告，且未指定方法。基于这些定义，确定“血清葡萄糖”这一观察项的适当轴分配。根据 LOINC 模型的基本原则和定量实验室结果的语义，论证每个轴的选择理由。\n\n为了生成一个用于下游处理的单一内部数字控制码，该机构使用以下组合编码规则，该规则将每个选定的轴术语映射到一个整数并将它们相乘：\n- 组分：\n  - 葡萄糖：$c_{\\mathrm{Glucose}} = 19$\n- 属性：\n  - 质量浓度 (LOINC 属性代码 “MCnc”)：$p_{\\mathrm{MCnc}} = 23$\n  - 物质的量浓度 (LOINC 属性代码 “SCnc”)：$p_{\\mathrm{SCnc}} = 17$\n- 时间：\n  - 时间点：$t_{\\mathrm{Pt}} = 29$\n- 系统：\n  - 血清：$s_{\\mathrm{Ser}} = 31$\n- 标度：\n  - 定量：$q_{\\mathrm{Qn}} = 37$\n- 方法：\n  - 未指定：$m_{\\mathrm{None}} = 41$\n\n根据您论证的轴分配，计算组合内部代码\n$$E = c \\times p \\times t \\times s \\times q \\times m.$$\n将$E$的最终值以单个整数形式报告。无需四舍五-入，且最终数值结果中不应包含任何单位。",
            "solution": "任务是为“血清葡萄糖”这一观察项分配六个 LOINC 轴，然后通过将每个选定轴的映射整数相乘来计算一个组合内部数字代码。我们从 LOINC 模型的核心定义出发。\n\n轴选择的基本原则：\n1. 组分轴定义：组分轴代表被测量的分析物或现象。对于“血清葡萄糖”，分析物是葡萄糖。因此，组分为“葡萄糖”，映射为 $c_{\\mathrm{Glucose}} = 19$。\n\n2. 属性轴定义：属性轴表示测量的特性（例如，质量浓度、物质的量浓度、存在与否、比率）。血清葡萄糖的临床化学检验结果通常以毫克/分升报告，这反映了单位体积的质量。在 LOINC 中，质量浓度用“MCnc”表示。相比之下，“SCnc”表示物质的量浓度，通常以毫摩尔/升报告。因为实验室结果是以毫克/分升提供的，所以适当的属性是质量浓度。因此，属性为“MCnc”，映射为 $p_{\\mathrm{MCnc}} = 23$（我们不使用 $p_{\\mathrm{SCnc}} = 17$）。\n\n3. 时间轴定义：时间轴捕捉测量的时间维度（例如，单个时间点与时间间隔或一段时间内的采集）。该观察项被明确描述为单时间点测量；在 LOINC 中，这表示为“Pt”（时间点）。因此，时间为“Pt”，映射为 $t_{\\mathrm{Pt}} = 29$。\n\n4. 系统轴定义：系统轴指定标本或系统。观察项说明是“血清葡萄糖”，这明确地将血清标识为标本。因此，系统为“Ser”，映射为 $s_{\\mathrm{Ser}} = 31$。\n\n5. 标度轴定义：标度轴指示用于报告结果的标度类型，如定量、定序、定性或叙述性。葡萄糖的数字实验室值是一个定量测量。LOINC 将此表示为“Qn”。因此，标度为“Qn”，映射为 $q_{\\mathrm{Qn}} = 37$。\n\n6. 方法轴定义：方法轴可选地记录分析技术（例如，酶法、电位法）。问题陈述中说明未指定方法。在 LOINC 中，当技术未指定或对结果解释不重要时，省略方法是标准做法。因此，方法为“None”，映射为 $m_{\\mathrm{None}} = 41$。\n\n有了这些合理的轴分配，我们使用提供的乘法规则计算组合内部代码：\n$$\nE = c \\times p \\times t \\times s \\times q \\times m\n= 19 \\times 23 \\times 29 \\times 31 \\times 37 \\times 41.\n$$\n\n我们逐步相乘：\n- 首先，$19 \\times 23 = 437$。\n- 接着，$437 \\times 29 = 12673$。\n- 然后，$12673 \\times 31 = 392863$。\n- 接着，$392863 \\times 37 = 14535931$。\n- 最后，$14535931 \\times 41 = 595973171$。\n\n因此，组合内部代码是\n$$\nE = 595973171.\n$$\n\n该数值结果反映了在该机构的编码方案下，对“血清葡萄糖”的合理的六轴 LOINC 表示，即 Glucose/MCnc/Pt/Ser/Qn/None。",
            "answer": "$$\\boxed{595973171}$$"
        },
        {
            "introduction": "在现实世界中，药物数据通常是杂乱的，不同的产品和包装可能代表同一种临床药物。RxNorm 是将这些药物信息规范化为其核心临床含义的标准术语系统。在这个练习中，您将首先构建一个标准的 RxNorm 临床药物概念，然后评估一个旨在规范化真实世界药物数据的假设性流程。这项任务不仅揭示了实现互操作性的实际挑战，还向您介绍了用于评估术语映射效果的数据质量度量标准。",
            "id": "4828018",
            "problem": "您正在构建一个互操作性管道，用于将本地药物记录规范化为 RxNorm 临床层级结构。请使用以下定义作为基础：国家药品代码 (NDC) 在美国唯一标识包装级别的药品，由标签商、产品和包装段组成；在 RxNorm 中，语义临床药物 (SCD) 概念类型由临床药物的规范化成分、规格和剂型定义（例如，“成分 规格 剂型”），并与语义品牌药物 (SBD) 相区别，后者还额外编码了品牌信息。RxNorm 标准对剂型术语（例如，“Oral Tablet”）和规格（例如，“MG”）进行标准化处理，从本地 NDC 进行规范化的路径通常是通过验证 NDC，使用当前的 NDC-to-RxCUI 交叉索引直接映射到 RxNorm 概念，如果初始映射结果为 SBD，则通过丢弃品牌属性同时保留成分、规格和剂型，将其投影到临床等效的 SCD。\n\n任务 A (概念构建)：根据 RxNorm 对 SCD 的命名约定，为临床概念“Metformin 500 mg oral tablet”构建规范化的 RxNorm SCD 表示。您的构建必须以上述标准的 SCD 词法形式表示。\n\n任务 B (规范化定量评估)：您有一个包含 $12$ 条产品记录的本地数据集，这些记录带有 NDC 和结构化字段（成分、规格、剂型、给药途径）。这些本地记录中真实的底层临床产品是：\n- $6$ 条记录：Metformin $500$ mg 速释口服片（这些是预期的目标 SCD）。在这 $6$ 条记录中，恰好有 $1$ 条使用了一个已停用的 NDC，该 NDC 已无法通过当前的 NDC-to-RxCUI 交叉索引进行映射。\n- $3$ 条记录：Metformin $500$ mg 缓释口服片。\n- $2$ 条记录：Metformin $1000$ mg 速释口服片。\n- $1$ 条记录：Metformin $500$ mg 口服溶液。\n\n您的管道的规范化步骤是：(i) 验证 NDC 并丢弃那些无法通过交叉索引查找到的 NDC；(ii) 将有效的 NDC 映射到 RxNorm；如果映射结果为语义品牌药物 (SBD)，则将其简化为其临床等效的语义临床药物 (SCD)；(iii) 使用本地结构化字段，要求剂型为“tablet”（片剂）且给药途径为“oral”（口服）；(iv) 对成分和规格进行分词和规范化，使其符合 RxNorm 的标准形式；(v) 忽略释放特性（即，您当前的管道不区分缓释与速释）。如果规范化后的元组为（成分 = Metformin，规格 = $500$ MG，剂型 = Oral Tablet），则决策规则将目标概念声明为“预测为阳性”。\n\n仅使用以上信息以及精确率、召回率和调和平均数的标准定义，计算您的管道在此数据集上识别目标 SCD “Metformin $500$ MG Oral Tablet” 的$F_1$分数。将$F_1$分数表示为无单位的小数，并四舍五入到四位有效数字。",
            "solution": "该问题分为两部分。A部分要求构建语义临床药物 (SCD) 名称。B部分要求使用标准性能指标对规范化管道进行定量评估。\n\n**A部分：SCD 的概念构建**\n\n问题将 RxNorm 中的语义临床药物 (SCD) 定义为其规范化的成分、规格和剂型，遵循词法模式“成分 规格 剂型”。我们被要求为临床概念“Metformin 500 mg oral tablet”构建 SCD。\n\n1.  **成分**：成分明确给出为“Metformin”。在 RxNorm 中，成分是标准化的，“Metformin”是标准名称。\n2.  **规格**：规格给出为“500 mg”。问题指出 RxNorm 会对规格进行标准化，并以“MG”为例。因此，规范化后的规格是“500 MG”。\n3.  **剂型**：剂型给出为“oral tablet”。问题指出 RxNorm 会对剂型术语进行标准化，并以“Oral Tablet”为例。因此，规范化后的剂型是“Oral Tablet”。\n\n根据指定的 SCD 词法形式“成分 规格 剂型”组合这些部分，得到：\nMetformin 500 MG Oral Tablet。\n\n**B部分：规范化的定量评估**\n\n为了计算$F_1$分数，我们必须首先确定管道对给定数据集产生的真阳性 ($\\text{TP}$)、假阳性 ($\\text{FP}$) 和假阴性 ($\\text{FN}$) 的数量。$F_1$分数是精确率和召回率的调和平均数。\n\n相关公式为：\n$$ \\text{Precision} = \\frac{\\text{TP}}{\\text{TP} + \\text{FP}} $$\n$$ \\text{Recall} = \\frac{\\text{TP}}{\\text{TP} + \\text{FN}} $$\n$$ \\text{F}_1 = 2 \\times \\frac{\\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}} = \\frac{2 \\times \\text{TP}}{2 \\times \\text{TP} + \\text{FP} + \\text{FN}} $$\n\n首先，我们从包含 $12$ 条记录的数据集中确定真实情况。\n目标概念是“Metformin 500 MG Oral Tablet”的 SCD。问题指明，那 $6$ 条“Metformin 500 mg 速释口服片”的记录是预期的目标。\n-   **实际阳性 ($P$)**：真实代表目标概念的记录数量。$P = 6$。\n-   **实际阴性 ($N$)**：不代表目标概念的记录数量。这包括另外 $3+2+1=6$ 条记录。$N = 6$。\n\n接下来，我们模拟管道在每组记录上的执行，以确定管道的预测结果。管道的决策规则将一个记录分类为“预测为阳性”，如果其规范化元组是（成分 = Metformin，规格 = 500 MG，剂型 = Oral Tablet）。\n\n1.  **对 $6$ 条实际阳性记录（Metformin 500 mg 速释口服片）的分析：**\n    -   问题指出，这 $6$ 条记录中有 $1$ 条的 NDC 已停用，无法通过 NDC-to-RxCUI 交叉索引进行映射。\n    -   根据管道步骤 (i)，此记录被丢弃。这是一个实际阳性但未被管道预测为阳性的情况。这构成了一个**假阴性 ($\\text{FN}$)**。因此，$\\text{FN} = 1$。\n    -   剩下的 $5$ 条记录具有有效的 NDC 并通过步骤 (i)。它们的成分、规格和剂型都正确。它们将通过所有后续的管道步骤并匹配决策规则。这些是实际阳性且被正确预测为阳性的情况。这构成了**真阳性 ($\\text{TP}$)**。因此，$\\text{TP} = 5$。\n\n2.  **对 $6$ 条实际阴性记录的分析：**\n    -   **$3$ 条记录：Metformin 500 mg 缓释口服片。**\n        -   这些记录是“口服片”，成分为“Metformin”，规格为“500 MG”。\n        -   管道步骤 (v) 指出，管道“忽略释放特性”。因此，“缓释”属性在规范化过程中被丢弃。\n        -   得到的规范化元组将是（Metformin, 500 MG, Oral Tablet），这与决策规则匹配。\n        -   这些记录是实际阴性但被预测为阳性。这构成了一个**假阳性 ($\\text{FP}$)**。因此，这 $3$ 条记录对 $\\text{FP}$ 的计数贡献了 $3$。\n    -   **$2$ 条记录：Metformin 1000 mg 速释口服片。**\n        -   在对规格进行规范化后（步骤 iv），规格将是“1000 MG”。\n        -   这不匹配决策规则中的规格“500 MG”。\n        -   这些记录被预测为阴性。它们是实际阴性且被预测为阴性，因此是真阴性 ($\\text{TN}$)。\n    -   **$1$ 条记录：Metformin 500 mg 口服溶液。**\n        -   管道步骤 (iii) 要求剂型为“tablet”（片剂）。\n        -   此记录的剂型是“oral solution”（口服溶液），将无法通过此筛选。\n        -   此记录被预测为阴性。它是实际阴性且被预测为阴性，因此是真阴性 ($\\text{TN}$)。\n\n计数总结：\n-   真阳性 ($\\text{TP}$) = $5$\n-   假阳性 ($\\text{FP}$) = $3$\n-   假阴性 ($\\text{FN}$) = $1$\n-   真阴性 ($\\text{TN}$) = $2 + 1 = 3$\n\n总记录检查：$\\text{TP} + \\text{FP} + \\text{FN} + \\text{TN} = 5 + 3 + 1 + 3 = 12$。计数是一致的。\n\n现在，我们计算精确率、召回率和$F_1$分数。\n$$ \\text{Precision} = \\frac{\\text{TP}}{\\text{TP} + \\text{FP}} = \\frac{5}{5 + 3} = \\frac{5}{8} $$\n$$ \\text{Recall} = \\frac{\\text{TP}}{\\text{TP} + \\text{FN}} = \\frac{5}{5 + 1} = \\frac{5}{6} $$\n$$ \\text{F}_1 = 2 \\times \\frac{\\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}} = 2 \\times \\frac{\\frac{5}{8} \\times \\frac{5}{6}}{\\frac{5}{8} + \\frac{5}{6}} $$\n为了简化分母：\n$$ \\frac{5}{8} + \\frac{5}{6} = \\frac{5 \\times 3}{24} + \\frac{5 \\times 4}{24} = \\frac{15 + 20}{24} = \\frac{35}{24} $$\n代回到$F_1$公式中：\n$$ \\text{F}_1 = 2 \\times \\frac{\\frac{25}{48}}{\\frac{35}{24}} = 2 \\times \\frac{25}{48} \\times \\frac{24}{35} = 2 \\times \\frac{25}{2 \\times 35} = \\frac{25}{35} = \\frac{5}{7} $$\n最后，我们按要求将分数转换为小数并四舍五入到四位有效数字。\n$$ \\text{F}_1 = \\frac{5}{7} \\approx 0.7142857... $$\n四舍五入到四位有效数字得到 $0.7143$。",
            "answer": "$$\n\\boxed{0.7143}\n$$"
        },
        {
            "introduction": "SNOMED CT 的强大之处在于其丰富的逻辑关系网络，这使得我们能够根据共享的属性来定义和查询一组概念。这对于为临床研究构建患者队列或创建临床决策支持规则至关重要。在这个动手实践的编码练习中，您将利用一个类似 SNOMED CT 的本体的层次和关系结构，基于活性成分的属性来定义一个“β受体阻滞剂”的值集（ValueSet），并实现一个函数来扩展和筛选该集合，模拟了术语服务器的核心功能。",
            "id": "4827973",
            "problem": "给定一个简化的、自包含的临床术语系统子集，其旨在模拟医学系统命名法临床术语（Systematized Nomenclature of Medicine Clinical Terms, SNOMED CT）的核心行为。每个概念都由一个整数概念标识符、一个人类可读的显示名称、一个活动状态以及一组关系和属性来标识。该本体被建模为一个有向无环图，其中使用 `is_a` 父关系表示分类层级，并为临床药物设置一个 `has_active_ingredient` 属性，指向其活性成分物质。您将使用这个微型本体为“β-受体阻滞剂”定义一个内涵性值集，并实现一个带筛选器的扩展函数 $expand$。\n\n基本依据和规则如下：\n1. 如果从概念 $x$ 到概念 $y$ 存在一条沿着零条或多条 `is_a` 边的路径（可能长度为0），则概念 $x$ 是概念 $y$ 的后代或自身。形式上，如果$x=y$或者存在一个 $p$ 使得 `is_a`($x,p$) 且 $descOrSelf(p,y)$ 成立，则 $descOrSelf(x,y)$ 成立。\n2. 一个“临床药物”概念 $c$ 具有一个 `has_active_ingredient` 属性，指向某个“物质”概念 $s$。如果一个概念缺少 `has_active_ingredient` 属性，则在本数据集中它不是临床药物。\n3. 内涵性值集由一个关于概念的逻辑谓词定义。其扩展是在评估时满足该谓词的所有概念的集合（定义中没有固定的、枚举的列表）。\n\n微型术语表（概念标识符、显示名称、活动状态、关系/属性）：\n- 物质：\n  - $100000$：“物质 (substance)”，活动 $\\mathrm{True}$；父概念：无。\n  - $111000$：“β-肾上腺素能受体拮抗剂 (substance)”，活动 $\\mathrm{True}$；父概念：$\\{100000\\}$。\n  - $111100$：“阿替洛尔 (substance)”，活动 $\\mathrm{True}$；父概念：$\\{111000\\}$。\n  - $111200$：“美托洛尔 (substance)”，活动 $\\mathrm{True}$；父概念：$\\{111000\\}$。\n  - $111300$：“普萘洛尔 (substance)”，活动 $\\mathrm{True}$；父概念：$\\{111000\\}$。\n  - $111400$：“卡维地洛 (substance)”，活动 $\\mathrm{True}$；父概念：$\\{111000\\}$。\n  - $112000$：“氨氯地平 (substance)”，活动 $\\mathrm{True}$；父概念：$\\{100000\\}$。\n\n- 临床药物（每个都有 `has_active_ingredient` 和剂型）：\n  - $201100$：“阿替洛尔 50 mg 口服片”，活动 $\\mathrm{True}$；父概念：$\\varnothing$；`has_active_ingredient`$=111100$；`dose_form`$=\\text{\"tablet\"}$。\n  - $201101$：“阿替洛尔 25 mg 口服片”，活动 $\\mathrm{True}$；父概念：$\\varnothing$；`has_active_ingredient`$=111100$；`dose_form`$=\\text{\"tablet\"}$。\n  - $201150$：“阿替洛尔 10 mg/mL 注射液”，活动 $\\mathrm{False}$；父概念：$\\varnothing$；`has_active_ingredient`$=111100$；`dose_form`$=\\text{\"injection\"}$。\n  - $202100$：“美托洛尔 50 mg 口服片”，活动 $\\mathrm{True}$；父概念：$\\varnothing$；`has_active_ingredient`$=111200$；`dose_form`$=\\text{\"tablet\"}$。\n  - $202110$：“美托洛尔 5 mg/mL 注射液”，活动 $\\mathrm{True}$；父概念：$\\varnothing$；`has_active_ingredient`$=111200$；`dose_form`$=\\text{\"injection\"}$。\n  - $203100$：“普萘洛尔 10 mg 口服片”，活动 $\\mathrm{True}$；父概念：$\\varnothing$；`has_active_ingredient`$=111300$；`dose_form`$=\\text{\"tablet\"}$。\n  - $203200$：“普萘洛尔 40 mg 口服片”，活动 $\\mathrm{True}$；父概念：$\\varnothing$；`has_active_ingredient`$=111300$；`dose_form`$=\\text{\"tablet\"}$。\n  - $204100$：“卡维地洛 6.25 mg 口服片”，活动 $\\mathrm{True}$；父概念：$\\varnothing$；`has_active_ingredient`$=111400$；`dose_form`$=\\text{\"tablet\"}$。\n  - $204200$：“卡维地洛 3.125 mg 口服片”，活动 $\\mathrm{True}$；父概念：$\\varnothing$；`has_active_ingredient`$=111400$；`dose_form`$=\\text{\"tablet\"}$。\n  - $205100$：“氨氯地平 5 mg 口服片”，活动 $\\mathrm{True}$；父概念：$\\varnothing$；`has_active_ingredient`$=112000$；`dose_form`$=\\text{\"tablet\"}$。\n\n“β-受体阻滞剂”的内涵性值集定义：\n令 $B=111000$ 表示“β-肾上腺素能受体拮抗剂 (substance)”概念。将值集 $V$ 定义为所有满足以下条件的临床药物 $c$：存在一个物质 $s$，使得 `has_active_ingredient`($c$)=$s$ 且 $descOrSelf(s,B)$ 成立。形式化表示为，\n$$\nV \\;=\\; \\{\\, c \\mid \\exists s\\;(\\text{has\\_active\\_ingredient}(c)=s \\land descOrSelf(s,B)) \\,\\}.\n$$\n\n带筛选器的扩展函数 $expand$ 的行为：\n给定筛选器 $(a,t,d)$，其中 $a\\in\\{0,1\\}$ 是一个“仅限活动”标志，$t$ 是一个（可能为空的）字符串，用于对显示名称进行不区分大小写的子字符串匹配，而 $d$ 是一个（可能为空的）字符串，用于对 `dose_form` 进行精确匹配，定义\n$$\nexpand(V,a,t,d) \\;=\\; \\mathrm{sort}_{\\uparrow}\\Big(\\{\\, \\mathrm{id}(c) \\in V \\;\\mid\\; (a=0 \\lor \\mathrm{active}(c)=\\mathrm{True}) \\land (\\lvert t\\rvert=0 \\lor t \\text{ occurs in display}(c)) \\land (\\lvert d\\rvert=0 \\lor \\text{dose\\_form}(c)=d) \\,\\}\\Big),\n$$\n其中 $\\mathrm{sort}_{\\uparrow}$ 按升序对概念标识符进行数值排序，且“$t$ occurs in display$(c)$”表示不区分大小写的子字符串测试。\n\n任务：\n- 实现一个程序，该程序使用上述本体构建集合 $V$，并为下面的每个测试用例计算 $expand(V,a,t,d)$。所有针对 $t$ 的字符串比较都必须不区分大小写。排序必须严格按照概念标识符的升序数值顺序进行。\n\n测试套件（每个测试用例是一个三元组 $(a,t,d)$）：\n1. $(0,\\text{\"\"},\\text{\"\"})$\n2. $(1,\\text{\"\"},\\text{\"\"})$\n3. $(1,\\text{\"tablet\"},\\text{\"\"})$\n4. $(1,\\text{\"\"},\\text{\"injection\"})$\n5. $(1,\\text{\"metoprolol\"},\\text{\"\"})$\n6. $(1,\\text{\"\"},\\text{\"capsule\"})$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，其中每个元素是相应测试用例的 $expand(V,a,t,d)$ 的列表结果。例如：$[\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$。结果必须是代表概念标识符的整数列表，按升序排列，不含任何额外文本。本任务不涉及物理单位或角度，也不需要百分比。",
            "solution": "任务是在一个简化的临床术语系统内，为一个内涵性定义的值集实现一个扩展函数。这需要几个步骤：表示术语，实现层级关系逻辑，构建初始值集，然后为每个测试用例应用一系列筛选器。\n\n**步骤1：数据表示**\n\n首先，我们必须将所提供的术语数据组织成便于高效访问的结构。这些概念及其属性可以存储在字典中，将每个概念标识符（整数）映射到一个包含其属性的对象或字典：`display`（字符串）、`active`（布尔值）、`parents`（整数集合）、`has_active_ingredient`（整数，如果适用）和 `dose_form`（字符串，如果适用）。\n\n由 `parents` 属性定义的 `is_a` 关系构成一个有向无环图。我们可以将其显式地表示为子到父的映射，这将用于遍历该层级结构。例如，对于一个具有 `parents: {p1, p2}` 的概念 `c`，我们有 `is_a(c, p1)` 和 `is_a(c, p2)`。\n\n**步骤2：实现 `descOrSelf` 函数**\n\n`descOrSelf(x, y)` 谓词是定义值集的核心。如果概念 $x$ 是概念 $y$ 的后代或者是 $y$ 本身，则该谓词成立。这等价于检查在 `is_a` 层级图中是否存在一条从 $x$ 到 $y$ 的路径。所提供的形式化定义，$descOrSelf(x,y)$ 成立，当且仅当$x=y$或存在一个 $p$ 使得 `is_a`($x,p$) 且 `descOrSelf(p,y)` 成立，这很自然地导出一个递归算法。\n\n我们将实现一个函数 `is_descendant_or_self(x, y, parent_map)`，该函数从概念 $x$ 开始通过其父概念向上遍历。\n1.  基本情况1：如果 $x=y$，条件满足，返回 `True`。\n2.  基本情况2：如果 $x$ 没有父概念，它不可能是任何其他概念的后代，因此返回 `False`。\n3.  递归步骤：对于 $x$ 的每个父概念 $p$，递归调用 `is_descendant_or_self(p, y, parent_map)`。如果其中任何一次调用返回 `True`，则 $x$ 是 $y$ 的后代，我们返回 `True`。\n4.  如果对所有父概念的递归都完成而没有找到 $y$，则返回 `False`。\n\n为避免重复计算图中的路径，我们可以使用记忆化技术，存储 `(x, y)` 对的结果。\n\n**步骤3：构建内涵性值集 `V`**\n\n值集 $V$ 定义为：\n$$\nV \\;=\\; \\{\\, c \\mid \\exists s\\;(\\text{has\\_active\\_ingredient}(c)=s \\land descOrSelf(s,B)) \\,\\}\n$$\n其中 $B = 111000$ 对应于“β-肾上腺素能受体拮抗剂 (substance)”。\n\n要计算 $V$ 的成员，我们遍历数据集中的所有概念：\n1.  识别出“临床药物”概念。根据问题描述，这些是具有 `has_active_ingredient` 属性的概念。\n2.  对于每个临床药物 $c$，获取其活性成分物质 $s$，其中 `has_active_ingredient`($c$) = $s$。\n3.  使用步骤2中的函数评估谓词 `descOrSelf(s, B)`。\n4.  如果谓词为真，则将 $c$ 的概念标识符添加到 $V$ 的成员集合中。\n\n让我们用我们的数据来追踪这个过程：\n- 目标祖先是 $B = 111000$。\n- $B$ 的后代或自身是 $111100$ (阿替洛尔)、$111200$ (美托洛尔)、$111300$ (普萘洛尔) 和 $111400$ (卡维地洛)。物质 $112000$ (氨氯地平) 不是 $B$ 的后代。\n- 我们找到所有 `has_active_ingredient` 是这四种物质之一的临床药物。\n- 这包括从 $201100$ 到 $204200$ 的所有药物概念。药物概念 $205100$ (氨氯地平片) 被排除在外。\n- 因此，$V$ 的概念标识符集合为 $\\{201100, 201101, 201150, 202100, 202110, 203100, 203200, 204100, 204200\\}$。\n\n**步骤4：实现 `expand` 函数**\n\n扩展函数 $expand(V, a, t, d)$ 根据一组标准筛选 $V$ 中的概念，并返回其标识符的排序列表。\n\n对于一组给定的筛选器 $(a, t, d)$，过程如下：\n1.  从标识符在 $V$ 中的完整概念集开始。\n2.  **活动状态筛选**：如果标志 $a=1$，则筛选该集合，只保留 `active(c)` 为 `True` 的概念 $c$。如果 $a=0$，则跳过此筛选。\n3.  **显示名称筛选**：如果筛选字符串 $t$ 不为空，则筛选当前集合。对于每个概念 $c$，仅当 $t$ 作为不区分大小写的子字符串出现在其显示名称 `display(c)` 中时，才保留它。\n4.  **剂型筛选**：如果筛选字符串 $d$ 不为空，则筛选当前集合。仅当概念 $c$ 的 `dose_form(c)` 属性与 $d$ 完全匹配时，才保留它。\n5.  应用所有筛选器后，收集余下概念的概念标识符。\n6.  按照 $\\mathrm{sort}_{\\uparrow}$ 的要求，将这些标识符按升序数值排序。\n\n**步骤5：执行测试套件**\n\n我们为每个测试用例 $(a,t,d)$ 对集合 $V$ 应用 `expand` 函数。\n\n1.  **测试用例 $(0, \\text{\"\"}, \\text{\"\"})$**：不应用任何筛选器（$a=0$，$t$ 和 $d$ 为空）。结果是 $V$ 中所有概念标识符的排序列表。\n    - 结果：$[201100, 201101, 201150, 202100, 202110, 203100, 203200, 204100, 204200]$\n\n2.  **测试用例 $(1, \\text{\"\"}, \\text{\"\"})$**：仅筛选活动概念（$a=1$）。这将移除 `active=False` 的概念 $201150$。\n    - 结果：$[201100, 201101, 202100, 202110, 203100, 203200, 204100, 204200]$\n\n3.  **测试用例 $(1, \\text{\"tablet\"}, \\text{\"\"})$**：筛选活动概念且显示名称中包含 \"tablet\" 的概念。从用例2的结果开始，我们移除显示名称不含 \"tablet\" 的概念。这将移除 $202110$ (\"美托洛尔 5 mg/mL 注射液\")。\n    - 结果：$[201100, 201101, 202100, 203100, 203200, 204100, 204200]$\n\n4.  **测试用例 $(1, \\text{\"\"}, \\text{\"injection\"})$**：筛选 `dose_form` 等于 \"injection\" 的活动概念。从用例2的结果开始，只有 $202110$ 匹配 `dose_form` 筛选器。\n    - 结果：$[202110]$\n\n5.  **测试用例 $(1, \\text{\"metoprolol\"}, \\text{\"\"})$**：筛选显示名称中包含 \"metoprolol\" 的活动概念。从用例2的结果开始，只有概念 $202100$ 和 $202110$ 匹配显示名称筛选器。\n    - 结果：$[202100, 202110]$\n\n6.  **测试用例 $(1, \\text{\"\"}, \\text{\"capsule\"})$**：筛选 `dose_form` 等于 \"capsule\" 的活动概念。$V$ 中没有任何概念具有此 `dose_form`。\n    - 结果：$[]$\n\n这些步骤提供了一个解决该问题的完整算法，该算法将在最终程序中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the clinical terminology expansion problem.\n    \"\"\"\n    \n    # Define the miniature terminology dataset\n    concepts_data = [\n        # Substances\n        (100000, \"Substance (substance)\", True, [], {}),\n        (111000, \"Beta adrenergic receptor antagonist (substance)\", True, [100000], {}),\n        (111100, \"Atenolol (substance)\", True, [111000], {}),\n        (111200, \"Metoprolol (substance)\", True, [111000], {}),\n        (111300, \"Propranolol (substance)\", True, [111000], {}),\n        (111400, \"Carvedilol (substance)\", True, [111000], {}),\n        (112000, \"Amlodipine (substance)\", True, [100000], {}),\n        # Clinical drugs\n        (201100, \"Atenolol 50 mg oral tablet\", True, [], {\"has_active_ingredient\": 111100, \"dose_form\": \"tablet\"}),\n        (201101, \"Atenolol 25 mg oral tablet\", True, [], {\"has_active_ingredient\": 111100, \"dose_form\": \"tablet\"}),\n        (201150, \"Atenolol 10 mg/mL injection\", False, [], {\"has_active_ingredient\": 111100, \"dose_form\": \"injection\"}),\n        (202100, \"Metoprolol 50 mg oral tablet\", True, [], {\"has_active_ingredient\": 111200, \"dose_form\": \"tablet\"}),\n        (202110, \"Metoprolol 5 mg/mL injection\", True, [], {\"has_active_ingredient\": 111200, \"dose_form\": \"injection\"}),\n        (203100, \"Propranolol 10 mg oral tablet\", True, [], {\"has_active_ingredient\": 111300, \"dose_form\": \"tablet\"}),\n        (203200, \"Propranolol 40 mg oral tablet\", True, [], {\"has_active_ingredient\": 111300, \"dose_form\": \"tablet\"}),\n        (204100, \"Carvedilol 6.25 mg oral tablet\", True, [], {\"has_active_ingredient\": 111400, \"dose_form\": \"tablet\"}),\n        (204200, \"Carvedilol 3.125 mg oral tablet\", True, [], {\"has_active_ingredient\": 111400, \"dose_form\": \"tablet\"}),\n        (205100, \"Amlodipine 5 mg oral tablet\", True, [], {\"has_active_ingredient\": 112000, \"dose_form\": \"tablet\"}),\n    ]\n\n    # Process data into a more usable format\n    concepts = {}\n    parents_map = {}\n    for cid, display, active, parents, props in concepts_data:\n        concepts[cid] = {\n            \"id\": cid,\n            \"display\": display,\n            \"active\": active,\n            **props\n        }\n        parents_map[cid] = set(parents)\n\n    memo_desc = {}\n    def is_descendant_or_self(x, y):\n        \"\"\"\n        Checks if concept x is a descendant of or is concept y using recursion with memoization.\n        \"\"\"\n        if (x, y) in memo_desc:\n            return memo_desc[(x, y)]\n        \n        if x == y:\n            memo_desc[(x, y)] = True\n            return True\n        \n        if not parents_map.get(x):\n            memo_desc[(x, y)] = False\n            return False\n\n        # Recurse on parents\n        result = any(is_descendant_or_self(p, y) for p in parents_map[x])\n        memo_desc[(x, y)] = result\n        return result\n\n    # --- Step 1: Construct the ValueSet V ---\n    B = 111000  # \"Beta adrenergic receptor antagonist (substance)\"\n    V = set()\n    for cid, concept in concepts.items():\n        if \"has_active_ingredient\" in concept:\n            s = concept[\"has_active_ingredient\"]\n            if is_descendant_or_self(s, B):\n                V.add(cid)\n\n    # --- Step 2: Define and apply the expansion function ---\n    def expand(value_set_ids, a, t, d):\n        \"\"\"\n        Expands the value set with the given filters.\n        \"\"\"\n        candidate_concepts = [concepts[cid] for cid in value_set_ids]\n        \n        # Filter 1: Active status\n        if a == 1:\n            candidate_concepts = [c for c in candidate_concepts if c[\"active\"]]\n        \n        # Filter 2: Display name substring\n        if t:\n            t_lower = t.lower()\n            candidate_concepts = [c for c in candidate_concepts if t_lower in c[\"display\"].lower()]\n\n        # Filter 3: Dose form exact match\n        if d:\n            candidate_concepts = [c for c in candidate_concepts if c.get(\"dose_form\") == d]\n            \n        # Extract IDs and sort\n        result_ids = [c[\"id\"] for c in candidate_concepts]\n        result_ids.sort()\n        \n        return result_ids\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, \"\", \"\"),\n        (1, \"\", \"\"),\n        (1, \"tablet\", \"\"),\n        (1, \"\", \"injection\"),\n        (1, \"metoprolol\", \"\"),\n        (1, \"\", \"capsule\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, t, d = case\n        result = expand(V, a, t, d)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a Python list (e.g., '[1, 2]') is used for each sub-list.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}