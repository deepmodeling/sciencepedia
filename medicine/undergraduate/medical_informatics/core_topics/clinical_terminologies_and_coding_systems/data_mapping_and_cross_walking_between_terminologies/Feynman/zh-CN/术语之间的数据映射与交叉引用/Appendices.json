{
    "hands_on_practices": [
        {
            "introduction": "精确的术语映射不仅仅是寻找相似的词语，更是对概念背后定义的深刻理解。本练习将引导你运用集合论的思维，通过分析医学概念的定义属性（如时间性、身体部位、严重程度等），来严谨地分类源概念与目标概念之间的关系。这项实践旨在培养你在处理复杂临床术语时进行原则性分析和决策的关键技能，这是构建可靠的术语交叉表的基石。",
            "id": "4832986",
            "problem": "在医学信息学中，临床术语之间的概念映射遵循与定义性属性（例如，疾病与发现的轴、时间性、侧向性、严重性和背景）相关的原则性标准。让每个概念表示一个满足其所有定义性约束的现实世界临床实例的集合。对于一个源概念 $S$ 和一个目标概念 $T$，使用外延 $\\mathrm{den}(S)$ 和 $\\mathrm{den}(T)$ 之间的集合论关系，定义以下源到目标的匹配类型：如果 $\\mathrm{den}(S)=\\mathrm{den}(T)$，则为精确匹配 (exact)；如果 $\\mathrm{den}(S)\\subset \\mathrm{den}(T)$，则为范围更窄 (narrower-than)；如果 $\\mathrm{den}(S)\\supset \\mathrm{den}(T)$，则为范围更广 (broader-than)；如果 $\\mathrm{den}(S)\\cap \\mathrm{den}(T)\\neq \\emptyset$ 但两者均不为对方的子集，则为部分重叠 (partial-overlap)；如果由于定义轴不兼容导致 $\\mathrm{den}(S)\\cap \\mathrm{den}(T)=\\emptyset$，则为无映射 (no-map)。请使用这些原则性标准，为以下 $4$ 个源-目标对分配匹配类型，并通过分析约束每个外延的定义性属性来证明你的分配：\n\n- 对 1：源是医学临床术语系统化命名法 (Systematized Nomenclature of Medicine Clinical Terms, SNOMED CT) 概念 $44054006$ “2 型糖尿病（疾病）”。目标是国际疾病分类第十版临床修订本 (International Classification of Diseases, Tenth Revision, Clinical Modification, ICD-10-CM) 代码 E11.9 “2 型糖尿病，无并发症”。\n- 对 2：源是本地实验室检验代码“血清钾”，仅代表对血清的测量。目标是逻辑观察标识符名称和代码 (Logical Observation Identifiers Names and Codes, LOINC) $2823-3$ “血清或血浆中的钾 [摩尔/体积]”。\n- 对 3：源是 SNOMED CT “左侧中耳炎（疾病）”（侧向性约束为左耳，时间性未指定）。目标是 ICD-10-CM “急性中耳炎，耳部未指定”（时间性约束为急性，侧向性未指定）。\n- 对 4：源是 SNOMED CT “心肌梗死病史（情况）”（背景轴表示过去事件）。目标是 ICD-10-CM I21.9 “急性心肌梗死，未特指”（当前急性事件）。\n\n哪个选项正确地为所有 $4$ 个对分配了源到目标的匹配类型？\n\nA. 对 1：范围更广；对 2：范围更窄；对 3：部分重叠；对 4：无映射\n\nB. 对 1：精确匹配；对 2：范围更窄；对 3：范围更窄；对 4：部分重叠\n\nC. 对 1：范围更窄；对 2：范围更广；对 3：精确匹配；对 4：无映射\n\nD. 对 1：范围更广；对 2：精确匹配；对 3：部分重叠；对 4：部分重叠",
            "solution": "问题陈述经过验证，被认为是有效的。它在科学上植根于医学信息学和形式本体论的原理，提法严谨，定义和约束清晰，并且表述客观。该问题提供了一个合理的逻辑框架和足够的信息来推导出唯一解。\n\n该问题基于源概念 $S$ 和目标概念 $T$ 的外延之间的集合论关系，定义了五种源到目标的概念映射类型。外延 $\\mathrm{den}(X)$ 是满足概念 $X$ 的定义性约束的所有现实世界实例的集合。定义如下：\n- **精确匹配 (Exact):** $\\mathrm{den}(S) = \\mathrm{den}(T)$\n- **范围更窄 (Narrower-than):** $\\mathrm{den}(S) \\subset \\mathrm{den}(T)$\n- **范围更广 (Broader-than):** $\\mathrm{den}(S) \\supset \\mathrm{den}(T)$\n- **部分重叠 (Partial-overlap):** $\\mathrm{den}(S) \\cap \\mathrm{den}(T) \\neq \\emptyset$，$\\mathrm{den}(S) \\not\\subset \\mathrm{den}(T)$ 且 $\\mathrm{den}(T) \\not\\subset \\mathrm{den}(S)$\n- **无映射 (No-map):** $\\mathrm{den}(S) \\cap \\mathrm{den}(T) = \\emptyset$\n\n我们现在将分析这 $4$ 个源-目标对。\n\n**对 1 分析：**\n- 源 ($S_1$): SNOMED CT $44054006$ “2 型糖尿病（疾病）”。这是一个关于该疾病的通用概念。其定义未指定是否存在并发症。因此，$\\mathrm{den}(S_1)$ 包括所有 2 型糖尿病的实例，无论有无并发症。\n- 目标 ($T_1$): ICD-10-CM E11.9 “2 型糖尿病，无并发症”。该概念的定义明确限定为不存在并发症的 2 型糖尿病实例。因此，$\\mathrm{den}(T_1)$ 是无并发症的 2 型糖尿病实例的集合。\n- 关系：$\\mathrm{den}(T_1)$ 中的临床实例集合是 $\\mathrm{den}(S_1)$ 中实例的真子集，因为 $\\mathrm{den}(S_1)$ 还包含*有*并发症的 2 型糖尿病实例。形式上，$\\mathrm{den}(T_1) \\subset \\mathrm{den}(S_1)$，这等同于 $\\mathrm{den}(S_1) \\supset \\mathrm{den}(T_1)$。\n- 结论：源到目标的匹配类型是 **范围更广 (broader-than)**。\n\n**对 2 分析：**\n- 源 ($S_2$): 本地实验室检验代码“血清钾”。其标本类型的定义性属性仅限于“血清”。因此，$\\mathrm{den}(S_2)$ 是所有在血清上进行的钾测量值的集合。\n- 目标 ($T_2$): LOINC $2823-3$ “血清或血浆中的钾 [摩尔/体积]”。其标本类型的定义性属性允许“血清”或“血浆”。因此，$\\mathrm{den}(T_2)$ 是所有在血清或血浆上进行的钾测量值的集合。\n- 关系：在血清上进行的测量值集合 $\\mathrm{den}(S_2)$ 是在血清或血浆上进行的测量值集合 $\\mathrm{den}(T_2)$ 的真子集。$\\mathrm{den}(S_2)$ 中的每个实例也都在 $\\mathrm{den}(T_2)$ 中，但 $\\mathrm{den}(T_2)$ 还包含不在 $\\mathrm{den}(S_2)$ 中的实例（在血浆上的测量值）。形式上，$\\mathrm{den}(S_2) \\subset \\mathrm{den}(T_2)$。\n- 结论：源到目标的匹配类型是 **范围更窄 (narrower-than)**。\n\n**对 3 分析：**\n- 源 ($S_3$): SNOMED CT “左侧中耳炎（疾病）”。定义性属性为侧向性='左' (Laterality='left') 和时间性='未指定' (Temporality='unspecified')。$\\mathrm{den}(S_3)$ 包含左耳中耳炎的所有实例，无论是急性的、慢性的、复发性的等等。\n- 目标 ($T_3$): ICD-10-CM “急性中耳炎，耳部未指定”。定义性属性为时间性='急性' (Temporality='acute') 和侧向性='未指定' (Laterality='unspecified')。$\\mathrm{den}(T_3)$ 包含所有急性中耳炎的实例，无论是左耳、右耳还是双侧。\n- 关系：\n    - 我们检验子集关系。$\\mathrm{den}(S_3) \\subset \\mathrm{den}(T_3)$ 吗？不是，因为“慢性左侧中耳炎”的实例在 $\\mathrm{den}(S_3)$ 中，但不在 $\\mathrm{den}(T_3)$ 中（因为 $T_3$ 仅为'急性'）。\n    - $\\mathrm{den}(T_3) \\subset \\mathrm{den}(S_3)$ 吗？不是，因为“急性右侧中耳炎”的实例在 $\\mathrm{den}(T_3)$ 中，但不在 $\\mathrm{den}(S_3)$ 中（因为 $S_3$ 仅为'左侧'）。\n    - 我们检验交集。$\\mathrm{den}(S_3) \\cap \\mathrm{den}(T_3) = \\emptyset$ 吗？不是，因为“急性左侧中耳炎”的实例满足两个概念的约束，因此在交集中。\n- 结论：由于这两个集合有非空交集，但两者均不为对方的子集，因此源到目标的匹配类型是 **部分重叠 (partial-overlap)**。\n\n**对 4 分析：**\n- 源 ($S_4$): SNOMED CT “心肌梗死病史（情况）”。“背景”(context) 定义轴指定这是一个过去的事件。患者当前没有发生心肌梗死 (MI)；他们有心肌梗死的病史。$\\mathrm{den}(S_4)$ 是表示过去已缓解的 MI 的临床状态集合。\n- 目标 ($T_4$): ICD-10-CM I21.9 “急性心肌梗死，未特指”。“背景”(context) 轴指定这是一个当前的急性事件。患者正在经历一次 MI。$\\mathrm{den}(T_4)$ 是当前急性 MI 的临床事件集合。\n- 关系：背景的定义轴（过去 vs. 当前）是互斥的。一个临床状态不能同时是“过去的 MI 病史”和“当前的急性 MI”。这两个实例集合是不相交的。形式上，$\\mathrm{den}(S_4) \\cap \\mathrm{den}(T_4) = \\emptyset$。\n- 结论：源到目标的匹配类型是 **无映射 (no-map)**。\n\n推导出的匹配总结：\n- 对 $1$: **范围更广 (broader-than)**\n- 对 $2$: **范围更窄 (narrower-than)**\n- 对 $3$: **部分重叠 (partial-overlap)**\n- 对 $4$: **无映射 (no-map)**\n\n我们现在评估给定的选项：\n\n**A. 对 1：范围更广；对 2：范围更窄；对 3：部分重叠；对 4：无映射**\n该选项的分配与我们对所有 $4$ 个对的推导分析相符。\n- 对 1：范围更广。正确。\n- 对 2：范围更窄。正确。\n- 对 3：部分重叠。正确。\n- 对 4：无映射。正确。\n此选项 **正确**。\n\n**B. 对 1：精确匹配；对 2：范围更窄；对 3：范围更窄；对 4：部分重叠**\n- 对 1 是范围更广，不是精确匹配。不正确。\n- 对 3 是部分重叠，不是范围更窄。不正确。\n- 对 4 是无映射，不是部分重叠。不正确。\n此选项 **不正确**。\n\n**C. 对 1：范围更窄；对 2：范围更广；对 3：精确匹配；对 4：无映射**\n- 对 1 是范围更广，不是范围更窄。不正确。\n- 对 2 是范围更窄，不是范围更广。不正确。\n- 对 3 是部分重叠，不是精确匹配。不正确。\n此选项 **不正确**。\n\n**D. 对 1：范围更广；对 2：精确匹配；对 3：部分重叠；对 4：部分重叠**\n- 对 2 是范围更窄，不是精确匹配。不正确。\n- 对 4 是无映射，不是部分重叠。不正确。\n此选项 **不正确**。\n\n根据所提供的原则性标准，只有选项 A 正确地为所有四个对分配了匹配类型。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在理解了概念映射的理论原则后，我们需要实用的计算工具来从庞大的术语库中自动发现潜在的匹配项。本练习让你亲手实践几种核心的基于字符串的相似度算法，包括杰卡德指数（Jaccard index）、余弦相似度（cosine similarity）和归一化编辑距离（normalized edit similarity）。通过计算这些指标并评估它们的排序性能，你将掌握评估和选择最适合特定映射任务的自动化方法的第一步。",
            "id": "4832998",
            "problem": "一个临床数据整合团队正在验证一份介于医学系统命名法—临床术语 (SNOMED CT) 和逻辑观察标识符名称和代码 (LOINC) 之间的基于字符串的交叉映射。对于每个 SNOMED CT 查询词 $Q_i$，都有两个候选的 LOINC 词 $C_i^{(1)}$ 和 $C_i^{(2)}$。预处理流程将所有术语转换为小写，移除标点符号和连字符，并按空格进行分词以生成词元集合。该团队将在词元层面评估三种相似度度量，以为每个查询的候选词进行排序：杰卡德指数、使用二元词元出现率的余弦相似度，以及根据词级 Levenshtein 距离（单位成本为替换、插入、删除）计算并由较长的词元序列长度进行归一化的归一化编辑相似度。\n\n给定以下查询和候选词，以及每个查询的真实正确候选词：\n\n- 查询 $Q_1$：“Hemoglobin A1c test”\n  - 候选词 $C_1^{(1)}$ (正确)：“Hemoglobin A1c level”\n  - 候选词 $C_1^{(2)}$：“Hepatic function panel”\n- 查询 $Q_2$：“Basic metabolic panel”\n  - 候选词 $C_2^{(1)}$ (正确)：“Basic metabolic panel”\n  - 候选词 $C_2^{(2)}$：“Complete blood count”\n- 查询 $Q_3$：“Urinalysis microscopy”\n  - 候选词 $C_3^{(1)}$ (正确)：“Urinalysis microscopic”\n  - 候选词 $C_3^{(2)}$：“Urine culture”\n\n使用所描述的分词方法，为每个查询-候选词对计算杰卡德指数、余弦相似度（二元出现率）和归一化编辑相似度（定义为 $1$ 减去词级 Levenshtein 距离除以较长的词元序列长度）。对每种度量独立地，按相似度降序为每个查询的两个候选词进行排序。然后，对于每种度量，计算这 $3$ 个查询的平均倒数排名，其中如果正确候选词在该度量对此查询的排名中位于第 $k$ 位，则该查询的倒数排名为 $1/k$。\n\n报告这三种度量中实现的最大平均倒数排名。将您的最终答案四舍五入到四位有效数字。",
            "solution": "我们从医学信息学中用于基于字符串的术语相似度和排名的标准且经过充分检验的定义开始。\n\n设一个查询词生成词元集合 $A$，一个候选词生成词元集合 $B$。\n\n- 杰卡德指数定义为\n$$\nJ(A,B) \\;=\\; \\frac{|A \\cap B|}{|A \\cup B|}.\n$$\n\n- 对于二元词元出现率（在每个集合中存在或不存在）的余弦相似度为\n$$\n\\cos(A,B) \\;=\\; \\frac{|A \\cap B|}{\\sqrt{|A|\\,|B|}}.\n$$\n\n- 词元级别的归一化编辑相似度基于词级 Levenshtein 距离 $d(A,B)$，其中替换、插入和删除的单位成本均为1。设 $m=|A|$ 且 $n=|B|$。归一化编辑相似度为\n$$\nS_{\\text{edit}}(A,B) \\;=\\; 1 - \\frac{d(A,B)}{\\max(m,n)}.\n$$\n\n我们现在应用规定的预处理：转换为小写、移除标点符号和连字符，并按空格分词。\n\n分词：\n\n- $Q_1$：“Hemoglobin A1c test” $\\rightarrow$ $A_1=\\{\\text{hemoglobin}, \\text{a1c}, \\text{test}\\}$ 所以 $|A_1|=3$。\n  - $C_1^{(1)}$：“Hemoglobin A1c level” $\\rightarrow$ $B_1^{(1)}=\\{\\text{hemoglobin}, \\text{a1c}, \\text{level}\\}$ 所以 $|B_1^{(1)}|=3$。\n  - $C_1^{(2)}$：“Hepatic function panel” $\\rightarrow$ $B_1^{(2)}=\\{\\text{hepatic}, \\text{function}, \\text{panel}\\}$ 所以 $|B_1^{(2)}|=3$。\n\n- $Q_2$：“Basic metabolic panel” $\\rightarrow$ $A_2=\\{\\text{basic}, \\text{metabolic}, \\text{panel}\\}$ 所以 $|A_2|=3$。\n  - $C_2^{(1)}$：“Basic metabolic panel” $\\rightarrow$ $B_2^{(1)}=\\{\\text{basic}, \\text{metabolic}, \\text{panel}\\}$ 所以 $|B_2^{(1)}|=3$。\n  - $C_2^{(2)}$：“Complete blood count” $\\rightarrow$ $B_2^{(2)}=\\{\\text{complete}, \\text{blood}, \\text{count}\\}$ 所以 $|B_2^{(2)}|=3$。\n\n- $Q_3$：“Urinalysis microscopy” $\\rightarrow$ $A_3=\\{\\text{urinalysis}, \\text{microscopy}\\}$ 所以 $|A_3|=2$。\n  - $C_3^{(1)}$：“Urinalysis microscopic” $\\rightarrow$ $B_3^{(1)}=\\{\\text{urinalysis}, \\text{microscopic}\\}$ 所以 $|B_3^{(1)}|=2$。\n  - $C_3^{(2)}$：“Urine culture” $\\rightarrow$ $B_3^{(2)}=\\{\\text{urine}, \\text{culture}\\}$ 所以 $|B_3^{(2)}|=2$。\n\n计算杰卡德指数 $J$：\n\n- $Q_1$:\n  - $A_1 \\cap B_1^{(1)}=\\{\\text{hemoglobin}, \\text{a1c}\\}$ 所以 $|A_1 \\cap B_1^{(1)}|=2$ 且 $A_1 \\cup B_1^{(1)}=\\{\\text{hemoglobin}, \\text{a1c}, \\text{test}, \\text{level}\\}$ 所以 $|A_1 \\cup B_1^{(1)}|=4$。因此\n  $$\n  J(A_1,B_1^{(1)}) = \\frac{2}{4} = \\frac{1}{2}.\n  $$\n  - $A_1 \\cap B_1^{(2)}=\\varnothing$ 所以 $|A_1 \\cap B_1^{(2)}|=0$ 且 $|A_1 \\cup B_1^{(2)}|=6$。因此\n  $$\n  J(A_1,B_1^{(2)}) = \\frac{0}{6} = 0.\n  $$\n\n- $Q_2$:\n  - $A_2=B_2^{(1)}$ 所以 $|A_2 \\cap B_2^{(1)}|=3$，$|A_2 \\cup B_2^{(1)}|=3$，且\n  $$\n  J(A_2,B_2^{(1)}) = \\frac{3}{3} = 1.\n  $$\n  - $A_2 \\cap B_2^{(2)}=\\varnothing$ 且 $|A_2 \\cup B_2^{(2)}|=6$，因此\n  $$\n  J(A_2,B_2^{(2)}) = \\frac{0}{6} = 0.\n  $$\n\n- $Q_3$:\n  - $A_3 \\cap B_3^{(1)}=\\{\\text{urinalysis}\\}$ 所以 $|A_3 \\cap B_3^{(1)}|=1$，且 $A_3 \\cup B_3^{(1)}=\\{\\text{urinalysis}, \\text{microscopy}, \\text{microscopic}\\}$ 所以 $|A_3 \\cup B_3^{(1)}|=3$。因此\n  $$\n  J(A_3,B_3^{(1)}) = \\frac{1}{3}.\n  $$\n  - $A_3 \\cap B_3^{(2)}=\\varnothing$ 且 $|A_3 \\cup B_3^{(2)}|=4$，因此\n  $$\n  J(A_3,B_3^{(2)}) = \\frac{0}{4} = 0.\n  $$\n\n计算二元出现率的余弦相似度 $\\cos$：\n\n- $Q_1$:\n  - $|A_1 \\cap B_1^{(1)}|=2$，$|A_1|=3$，$|B_1^{(1)}|=3$ 所以\n  $$\n  \\cos(A_1,B_1^{(1)}) = \\frac{2}{\\sqrt{3\\cdot 3}} = \\frac{2}{3}.\n  $$\n  - $|A_1 \\cap B_1^{(2)}|=0$ 所以\n  $$\n  \\cos(A_1,B_1^{(2)}) = 0.\n  $$\n\n- $Q_2$:\n  - $A_2=B_2^{(1)}$ 所以 $|A_2 \\cap B_2^{(1)}|=3$，$|A_2|=3$，$|B_2^{(1)}|=3$ 且\n  $$\n  \\cos(A_2,B_2^{(1)}) = \\frac{3}{\\sqrt{3\\cdot 3}} = 1.\n  $$\n  - $|A_2 \\cap B_2^{(2)}|=0$ 所以\n  $$\n  \\cos(A_2,B_2^{(2)}) = 0.\n  $$\n\n- $Q_3$:\n  - $|A_3 \\cap B_3^{(1)}|=1$，$|A_3|=2$，$|B_3^{(1)}|=2$ 所以\n  $$\n  \\cos(A_3,B_3^{(1)}) = \\frac{1}{\\sqrt{2\\cdot 2}} = \\frac{1}{2}.\n  $$\n  - $|A_3 \\cap B_3^{(2)}|=0$ 所以\n  $$\n  \\cos(A_3,B_3^{(2)}) = 0.\n  $$\n\n计算词元级别的归一化编辑相似度 $S_{\\text{edit}}$。对于词级 Levenshtein 距离 $d$，我们计算单位成本的替换、插入、删除次数。\n\n- $Q_1$:\n  - $A_1=[\\text{hemoglobin}, \\text{a1c}, \\text{test}]$，$B_1^{(1)}=[\\text{hemoglobin}, \\text{a1c}, \\text{level}]$。将 $A_1$ 转换为 $B_1^{(1)}$ 需要 $1$ 次替换（“test” $\\rightarrow$ “level”），所以 $d(A_1,B_1^{(1)})=1$。由于 $m=|A_1|=3$, $n=|B_1^{(1)}|=3$，我们得到\n  $$\n  S_{\\text{edit}}(A_1,B_1^{(1)}) = 1 - \\frac{1}{\\max(3,3)} = 1 - \\frac{1}{3} = \\frac{2}{3}.\n  $$\n  - $B_1^{(2)}=[\\text{hepatic}, \\text{function}, \\text{panel}]$。将 $A_1$ 转换为 $B_1^{(2)}$ 需要 $3$ 次替换，所以 $d(A_1,B_1^{(2)})=3$ 且\n  $$\n  S_{\\text{edit}}(A_1,B_1^{(2)}) = 1 - \\frac{3}{\\max(3,3)} = 0.\n  $$\n\n- $Q_2$:\n  - $A_2=B_2^{(1)}$，所以 $d(A_2,B_2^{(1)})=0$ 且\n  $$\n  S_{\\text{edit}}(A_2,B_2^{(1)}) = 1 - \\frac{0}{\\max(3,3)} = 1.\n  $$\n  - $B_2^{(2)}=[\\text{complete}, \\text{blood}, \\text{count}]$。将 $A_2$ 转换为 $B_2^{(2)}$ 需要 $3$ 次替换，所以 $d(A_2,B_2^{(2)})=3$ 且\n  $$\n  S_{\\text{edit}}(A_2,B_2^{(2)}) = 1 - \\frac{3}{\\max(3,3)} = 0.\n  $$\n\n- $Q_3$:\n  - $A_3=[\\text{urinalysis}, \\text{microscopy}]$，$B_3^{(1)}=[\\text{urinalysis}, \\text{microscopic}]$。将 $A_3$ 转换为 $B_3^{(1)}$ 需要 $1$ 次替换（“microscopy” $\\rightarrow$ “microscopic”），所以 $d(A_3,B_3^{(1)})=1$。由于 $m=|A_3|=2$, $n=|B_3^{(1)}|=2$，我们得到\n  $$\n  S_{\\text{edit}}(A_3,B_3^{(1)}) = 1 - \\frac{1}{\\max(2,2)} = 1 - \\frac{1}{2} = \\frac{1}{2}.\n  $$\n  - $B_3^{(2)}=[\\text{urine}, \\text{culture}]$。将 $A_3$ 转换为 $B_3^{(2)}$ 需要 $2$ 次替换，所以 $d(A_3,B_3^{(2)})=2$ 且\n  $$\n  S_{\\text{edit}}(A_3,B_3^{(2)}) = 1 - \\frac{2}{\\max(2,2)} = 0.\n  $$\n\n每个查询按度量排名（相似度降序）：\n\n- 杰卡德指数：\n  - $Q_1$：$C_1^{(1)}$ 为 $\\frac{1}{2}$，$C_1^{(2)}$ 为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_1^{(1)}$。\n  - $Q_2$：$C_2^{(1)}$ 为 $1$，$C_2^{(2)}$ 为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_2^{(1)}$。\n  - $Q_3$：$C_3^{(1)}$ 为 $\\frac{1}{3}$，$C_3^{(2)}$ 为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_3^{(1)}$。\n\n- 余弦相似度：\n  - $Q_1$：$C_1^{(1)}$ 为 $\\frac{2}{3}$，$C_1^{(2)}$ 为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_1^{(1)}$。\n  - $Q_2$：$C_2^{(1)}$ 为 $1$，$C_2^{(2)}$ 为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_2^{(1)}$。\n  - $Q_3$：$C_3^{(1)}$ 为 $\\frac{1}{2}$，$C_3^{(2)}$ 为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_3^{(1)}$。\n\n- 归一化编辑相似度：\n  - $Q_1$：$C_1^{(1)}$ 为 $\\frac{2}{3}$，$C_1^{(2)}$ 为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_1^{(1)}$。\n  - $Q_2$：$C_2^{(1)}$ 为 $1$，$C_2^{(2)}$ 为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_2^{(1)}$。\n  - $Q_3$：$C_3^{(1)}$ 为 $\\frac{1}{2}$，$C_3^{(2)}$ 为 $0$ $\\Rightarrow$ 排名第 1 的是 $C_3^{(1)}$。\n\n对于每种度量，每个查询中正确候选词的倒数排名都是 $1$（因为正确候选词位于第 1 位）。因此，对于每种度量，其在这 $3$ 个查询上的平均倒数排名 (MRR) 为\n$$\n\\text{MRR} \\;=\\; \\frac{1 + 1 + 1}{3} \\;=\\; 1.\n$$\n\n因此，这三种度量中实现的最大平均倒数排名为 $1$。四舍五入到四位有效数字后，结果仍为 $1.000$。",
            "answer": "$$\\boxed{1.000}$$"
        },
        {
            "introduction": "最后，我们需要将理论和算法封装到标准化、可互操作的格式中，以便在真实的医疗信息系统中应用。本练习将指导你使用 HL7 FHIR（当今健康数据交换的领先标准）来创建一个高级的条件概念图（ConceptMap）。你将学习如何为“膝关节疼痛”这一通用概念，根据“左侧”或“右侧”等上下文条件，精确地映射到特定的 ICD-10-CM 编码，从而掌握在实际应用中处理复杂映射逻辑的技能。",
            "id": "4833007",
            "problem": "要求您编写一个完整且可运行的程序，该程序构建一个第七级健康水平快速医疗保健互操作性资源 (Health Level Seven Fast Healthcare Interoperability Resources, HL7 FHIR) ConceptMap 实例，用于将单个本地问题列表概念映射到国际疾病分类第十版临床修订版 (International Classification of Diseases, Tenth Revision, Clinical Modification, ICD-10-CM) 代码。此映射使用类型为“narrower”的等价性，并带有关于侧向性 (laterality) 的 dependsOn 约束。然后，通过运行确定性测试套件来评估所构建 ConceptMap 的正确性。您的程序不得读取任何输入，并且必须产生在末尾指定的单行输出。\n\n基础和约束：\n- 使用核心定义，即术语体系之间的映射是一个二元关系 $R \\subseteq S \\times T$，其中 $S$ 是源概念集合，$T$ 是目标概念集合。条件映射将其细化为一个三元关系 $R_{c} \\subseteq S \\times T \\times C$，其中 $C$ 是一组条件（例如，侧向性）。对于给定的条件值 $c \\in C$，条件映射的解析会选择那些具有匹配 $c$ 的 $(s,t,c)$。\n- 使用来自资源建模的经过良好测试的不变量：一个 HL7 FHIR ConceptMap 按源和目标代码系统对映射进行分组，包含从一个源代码到一个或多个目标代码的逐元素映射，并且可以指定等价性限定符和 dependsOn 条件。将等价性“narrower”视为表示在包涵意义上，目标概念比源概念更具体。\n\n程序要求：\n- 构建一个且仅一个 ConceptMap 实例（作为您所用语言的本地数据结构），该实例具有以下属性：\n  - 源代码系统是一个本地系统，由统一资源名称 \"urn:oid:1.2.3.4.5.6.7.8.9\" 标识。要映射的单个源代码是字符串 \"LPL-001\"（代表一个关于膝关节疼痛的通用本地问题列表概念）。\n  - 目标代码系统是 \"http://hl7.org/fhir/sid/icd-10-cm\"。\n  - 必须至少有两个不同的目标映射（两个目标代码），每个映射都具有：\n    - 等价性设置为字面值字符串 \"narrower\"。\n    - 一个 dependsOn 条件，其属性 URI 等于字面值字符串 \"http://hl7.org/fhir/StructureDefinition/laterality\"，其系统等于字面值字符串 \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\"，其值等于字面值 \"left\" 或 \"right\" 之一。这用于编码侧向性。\n  - 使用 ICD-10-CM 代码 \"M25.561\" 表示右膝关节疼痛，\"M25.562\" 表示左膝关节疼痛作为目标。\n\n- 定义一个解析函数 $f$，它接受源概念代码 $s$ 和侧向性标记 $\\ell$ 作为输入，并通过如下方式评估 dependsOn 来返回适用的目标代码列表：\n  - 仅考虑源代码 $s = \\text{\"LPL-001\"}$ 的映射。\n  - 如果 $\\ell$ 等于字面值 \"left\"，则返回一个列表，其中仅包含其 dependsOn 值等于 \"left\" 的单个目标代码。\n  - 如果 $\\ell$ 等于字面值 \"right\"，则返回一个列表，其中仅包含其 dependsOn 值等于 \"right\" 的单个目标代码。\n  - 如果 $\\ell$ 等于字面值 \"bilateral\"，则返回 \"left\" 和 \"right\" 的两个目标代码（通过集合包含来证明这一点：“bilateral”意味着两个侧向性条件都成立）。\n  - 对于任何其他 $\\ell$，返回空列表。\n\n- 实现一个验证器 $V$，它返回一个布尔值，指示 ConceptMap 实例是否满足以下所有结构约束：\n  - resourceType 等于字面值 \"ConceptMap\"。\n  - group.source 等于字面值 \"urn:oid:1.2.3.4.5.6.7.8.9\"，group.target 等于字面值 \"http://hl7.org/fhir/sid/icd-10-cm\"。\n  - 对于源代码 \"LPL-001\"，有且仅有一个 group.element。\n  - 该元素的所有目标映射的等价性都等于字面值 \"narrower\"。\n  - 该元素的所有目标映射都有一个 dependsOn 数组，其中至少有一个对象的属性等于字面值 \"http://hl7.org/fhir/StructureDefinition/laterality\"，其系统等于字面值 \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\"，其值是字面值 \"left\" 或 \"right\" 之一。\n\n测试套件：\n- 使用您构建的 ConceptMap 和解析函数 $f$，评估以下用例，并为每个用例计算一个布尔值，该值是结构验证器 $V$ 的结果与解析出的代码和预期列表相等性的逻辑与运算结果：\n  - 用例 A（正常路径）：$\\ell = \\text{\"left\"}$，预期代码 [\"M25.562\"]。\n  - 用例 B（正常路径）：$\\ell = \\text{\"right\"}$，预期代码 [\"M25.561\"]。\n  - 用例 C（边界情况，双侧）：$\\ell = \\text{\"bilateral\"}$，预期代码 [\"M25.561\",\"M25.562\"] 按字典升序排序。\n  - 用例 D（边界情况，未知）：$\\ell = \\text{\"unknown\"}$，预期代码 []（空列表）。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序为 [用例 A, 用例 B, 用例 C, 用例 D]。例如，一个有效的输出形状是 \"[true,false,true,true]\"，前提是您所用语言的布尔字面值为小写；确保大小写完全匹配，并且除了您所用语言的默认字符串化（如果适用）可能产生的逗号外，没有多余的空格。不得打印任何其他文本。",
            "solution": "该问题是有效的。它是在医学信息学领域内一个定义明确、有科学依据且形式化指定的任务。它要求实现一个数据结构和相应的算法来建模和评估条件术语映射，并遵循 HL7 FHIR 标准的原则。\n\n解决方案将通过以下四个连续步骤进行开发：\n1.  构建一个表示 HL7 FHIR `ConceptMap` 的数据结构。\n2.  实现一个验证器函数 $V$，以验证 `ConceptMap` 的结构完整性。\n3.  实现一个解析函数 $f$，以执行条件映射。\n4.  执行一个确定性测试套件，以评估整个实现的正确性。\n\n**概念框架**\n\n该问题将映射定义为一个二元关系 $R \\subseteq S \\times T$，其中 $S$ 是源概念集合，$T$ 是目标概念集合。对于本问题，映射是条件的，被建模为一个三元关系 $R_c \\subseteq S \\times T \\times C$，其中 $C$ 代表一个条件集合。具体的集合如下：\n- 源概念集合：$S = \\{\\text{\"LPL-001\"}\\}$。\n- 目标概念集合：$T = \\{\\text{\"M25.561\"}, \\text{\"M25.562\"}\\}$。\n- 条件集合 $C$：条件基于侧向性属性。我们可以将一个条件表示为一个元组 $(p, v)$，其中 $p$ 是属性，$v$ 是值。相关条件是 $(\\text{\"laterality\"}, \\text{\"left\"})$ 和 $(\\text{\"laterality\"}, \\text{\"right\"})$。\n\nFHIR 中的 `ConceptMap` 资源就是为表示此类关系而设计的。一个 `group` 元素定义了源（$S$）和目标（$T$）代码系统。在一个 `group` 内部，`element` 结构将一个特定的源代码 $s \\in S$ 链接到一个或多个 `target` 映射。每个 `target` 包含一个目标代码 $t \\in T$，并可以使用 `dependsOn` 元素指定映射有效的条件，该元素实例化了条件集合 $C$。\n\n**步骤 1：`ConceptMap` 数据结构构建**\n\n将使用一个 Python 字典来建模 `ConceptMap` 资源。这个结构将严格遵循指定的约束。它将有一个值为 `\"ConceptMap\"` 的 `resourceType`。它将包含一个 `group`，该 `group` 将 `source` 系统 URI 指定为 `\"urn:oid:1.2.3.4.5.6.7.8.9\"`，将 `target` 系统 URI 指定为 `\"http://hl7.org/fhir/sid/icd-10-cm\"`。这个 `group` 将为源代码 `\"LPL-001\"` 包含一个 `element`。这个 `element` 又将包含两个 `target` 映射。\n\n每个 `target` 映射的 `equivalence` 将为 `\"narrower\"`，表示目标 ICD-10-CM 代码比通用的源代码更具体。条件性被编码在 `dependsOn` 列表中。\n- 第一个目标映射到代码 `\"M25.561\"`（右膝关节疼痛），并有一个 `dependsOn` 条件，其中 `property` 是 `\"http://hl7.org/fhir/StructureDefinition/laterality\"`，`system` 是 `\"http://hl7.org/fhir/CodeSystem/bodysite-laterality\"`，`value` 是 `\"right\"`。\n- 第二个目标映射到代码 `\"M25.562\"`（左膝关节疼痛），并有一个 `dependsOn` 条件，其 `value` 为 `\"left\"`。\n\n**步骤 2：验证器函数（$V$）实现**\n\n验证器函数 $V$ 将接受 `ConceptMap` 字典并返回一个布尔值。它将系统地检查所有必需结构元素的存在性和正确性。检查项包括：\n1. 顶层的 `resourceType` 必须是 `\"ConceptMap\"`。\n2. 结构中必须包含一个 `group` 列表，且该列表恰好有一个元素。\n3. 此 `group` 元素的 `source` 属性必须是 `\"urn:oid:1.2.3.4.5.6.7.8.9\"`，其 `target` 必须是 `\"http://hl7.org/fhir/sid/icd-10-cm\"`。\n4. `group` 必须包含一个 `element` 列表，且该列表恰好有一个元素。\n5. 此 `element` 的 `code` 必须是 `\"LPL-001\"`。\n6. 此 `element` 必须包含一个 `target` 列表，且该列表至少有两个元素。\n7. 对于此列表中的每个 `target`：\n   a. `equivalence` 必须是 `\"narrower\"`。\n   b. 它必须有一个 `dependsOn` 列表，且该列表至少有一个元素。\n   c. `dependsOn` 中至少有一个元素的 `property` 等于 `\"http://hl7.org/fhir/StructureDefinition/laterality\"`，`system` 等于 `\"http://hl7.org/fhir/CodeSystem/bodysite-laterality\"`，并且 `value` 是 `\"left\"` 或 `\"right\"` 之一。\n\n一个健壮的实现将使用安全的字典访问（例如 `.get()` 方法）以防止在键缺失时出错，并在这种情况下返回 `False`。\n\n**步骤 3：解析函数（$f$）实现**\n\n解析函数 $f(s, \\ell)$ 将接受一个源代码 $s$ 和一个侧向性标记 $\\ell$ 作为输入。\n1. 该函数将首先在 `ConceptMap` 中定位与源代码 $s = \\text{\"LPL-001\"}$ 对应的 `element`。如果不存在这样的元素，则返回一个空列表。\n2. 然后处理侧向性标记 $\\ell$：\n   - 如果 $\\ell$ 是 `\"left\"` 或 `\"right\"`，函数将遍历 `target` 映射。对于每个 `target`，它会检查其 `dependsOn` 元素的 `value`。如果 `value` 与 $\\ell$ 匹配，则将相应的 `target.code` 添加到结果列表中。\n   - 如果 $\\ell$ 是 `\"bilateral\"`，这被解释为请求所有满足“left”或“right”条件的代码。函数将收集这两个代码。这个逻辑与双侧条件包涵两个单侧条件的概念是一致的。\n   - 对于 $\\ell$ 的任何其他值（例如 `\"unknown\"`），没有条件匹配，函数返回一个空列表。\n3. 函数返回收集到的目标代码列表。\n\n**步骤 4：测试套件执行与最终输出**\n\n程序的最后一部分协调执行四个指定的测试用例。对于每个用例（A, B, C, D）：\n- 首先通过调用验证器函数 $V$ 来验证构建的 `ConceptMap`。\n- 使用源代码 `\"LPL-001\"` 和该用例的侧向性标记调用解析函数 $f$。\n- 对于用例 C (`\"bilateral\"`)，对 $f$ 返回的代码列表进行字典序排序，以确保与预期的排序列表 `[\"M25.561\", \"M25.562\"]` 进行确定性比较。\n- 该用例的最终布尔结果是验证器结果与函数输出和预期代码列表相等性的逻辑与。\n- 将四个布尔结果收集到一个列表中。然后将此列表转换为所需的字符串格式 `[true,true,true,true]`，确保布尔字面值为小写，并作为唯一输出打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Constructs, validates, and tests an HL7 FHIR ConceptMap for conditional mapping.\n    \"\"\"\n\n    # Step 1: Construct the ConceptMap data structure as a Python dictionary.\n    concept_map = {\n        \"resourceType\": \"ConceptMap\",\n        \"group\": [\n            {\n                \"source\": \"urn:oid:1.2.3.4.5.6.7.8.9\",\n                \"target\": \"http://hl7.org/fhir/sid/icd-10-cm\",\n                \"element\": [\n                    {\n                        \"code\": \"LPL-001\",\n                        \"target\": [\n                            {\n                                \"code\": \"M25.561\",\n                                \"equivalence\": \"narrower\",\n                                \"dependsOn\": [\n                                    {\n                                        \"property\": \"http://hl7.org/fhir/StructureDefinition/laterality\",\n                                        \"system\": \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\",\n                                        \"value\": \"right\"\n                                    }\n                                ]\n                            },\n                            {\n                                \"code\": \"M25.562\",\n                                \"equivalence\": \"narrower\",\n                                \"dependsOn\": [\n                                    {\n                                        \"property\": \"http://hl7.org/fhir/StructureDefinition/laterality\",\n                                        \"system\": \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\",\n                                        \"value\": \"left\"\n                                    }\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            }\n        ]\n    }\n\n    def validator(cm):\n        \"\"\"\n        Step 2: Implement the validator function V.\n        Validates the structural integrity of the ConceptMap instance.\n        \"\"\"\n        try:\n            # Check resourceType\n            if cm.get(\"resourceType\") != \"ConceptMap\":\n                return False\n\n            # Check group structure\n            groups = cm.get(\"group\", [])\n            if len(groups) != 1:\n                return False\n            group = groups[0]\n\n            if group.get(\"source\") != \"urn:oid:1.2.3.4.5.6.7.8.9\":\n                return False\n            if group.get(\"target\") != \"http://hl7.org/fhir/sid/icd-10-cm\":\n                return False\n\n            # Check element structure\n            elements = group.get(\"element\", [])\n            if len(elements) != 1:\n                return False\n            element = elements[0]\n\n            if element.get(\"code\") != \"LPL-001\":\n                return False\n            \n            targets = element.get(\"target\", [])\n            if len(targets)  2:  # at least two distinct target mappings\n                return False\n\n            # Check each target mapping\n            for target in targets:\n                if target.get(\"equivalence\") != \"narrower\":\n                    return False\n                \n                depends_on_list = target.get(\"dependsOn\", [])\n                if not depends_on_list:\n                    return False\n\n                valid_dependency_found = False\n                for dep in depends_on_list:\n                    prop = dep.get(\"property\") == \"http://hl7.org/fhir/StructureDefinition/laterality\"\n                    sys = dep.get(\"system\") == \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\"\n                    val = dep.get(\"value\") in [\"left\", \"right\"]\n                    if prop and sys and val:\n                        valid_dependency_found = True\n                        break\n                if not valid_dependency_found:\n                    return False\n\n        except (TypeError, KeyError, IndexError):\n            return False # Malformed structure\n\n        return True\n\n    def resolution_function(cm, source_code, laterality_token):\n        \"\"\"\n        Step 3: Implement the resolution function f.\n        Resolves target codes based on source code and a laterality condition.\n        \"\"\"\n        if source_code != \"LPL-001\":\n            return []\n\n        resolved_codes = []\n        try:\n            element = next((el for el in cm[\"group\"][0][\"element\"] if el[\"code\"] == source_code), None)\n            if not element:\n                return []\n            \n            targets_to_check = []\n            if laterality_token == \"left\":\n                targets_to_check = [\"left\"]\n            elif laterality_token == \"right\":\n                targets_to_check = [\"right\"]\n            elif laterality_token == \"bilateral\":\n                targets_to_check = [\"left\", \"right\"]\n            \n            for target in element[\"target\"]:\n                for dep in target[\"dependsOn\"]:\n                    if dep.get(\"value\") in targets_to_check:\n                        resolved_codes.append(target[\"code\"])\n                        break\n        except (KeyError, IndexError, TypeError):\n            return []\n            \n        return resolved_codes\n\n    # Step 4: Define and run the test suite.\n    test_cases = [\n        # Case A (happy path)\n        {\"laterality\": \"left\", \"expected\": [\"M25.562\"]},\n        # Case B (happy path)\n        {\"laterality\": \"right\", \"expected\": [\"M25.561\"]},\n        # Case C (edge case, bilateral)\n        {\"laterality\": \"bilateral\", \"expected\": [\"M25.561\", \"M25.562\"]},\n        # Case D (edge case, unknown)\n        {\"laterality\": \"unknown\", \"expected\": []},\n    ]\n\n    results = []\n    \n    # Run validator once, as it's static for all cases.\n    is_valid = validator(concept_map)\n\n    for case in test_cases:\n        laterality = case[\"laterality\"]\n        expected = case[\"expected\"]\n\n        # Call resolution function\n        resolved_codes = resolution_function(concept_map, \"LPL-001\", laterality)\n        \n        # Sort results for deterministic comparison, especially for 'bilateral'\n        resolved_codes.sort()\n        expected.sort()\n\n        # Compare results\n        resolution_correct = (resolved_codes == expected)\n        \n        # Final result for the case is the conjunction of validity and correct resolution\n        case_result = is_valid and resolution_correct\n        results.append(str(case_result).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}