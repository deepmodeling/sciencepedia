{
    "hands_on_practices": [
        {
            "introduction": "在临床决策支持（CDS）系统的设计中，实现“五个正确”原则并非总是直截了当的。有时，优化其中一个“正确”维度（如“正确的时间”）可能会无意中损害另一个维度（如“正确的对象”）。本练习  提供了一个定量框架，用于分析此类权衡，通过计算预期依从性这一关键绩效指标，帮助我们做出数据驱动的决策，理解优化 CDS 时的复杂性和微妙之处。",
            "id": "4860710",
            "problem": "一家医院实施了临床决策支持（CDS）系统，该系统被定义为在诊疗关键时刻向临床医生提供针对特定患者的评估或建议的软件，以维护五个正确原则：正确的信息、正确的人员、正确的干预形式、正确的渠道以及正确的时间/地点。考虑一个用于启动高风险抗生素的过敏检查警报。CDS团队考虑将警报在药物开具工作流程中提前触发，以改善“正确的时间/地点”，但这样做会引发一个路由限制：在更早的时间点，开具处方的医生的身份尚不明确，因此警报会以概率方式被路由到一个为分诊护士准备的池中，而不是直接发送给开具处方的医生。\n\n使用以下科学上合理的参数。在较晚的时间点（医嘱签署后），身份识别能力强，警报以 $0.95$ 的概率被路由至开具处方的医生，而以 $0.05$ 的概率被路由至分诊护士池。在较早的时间点（医嘱录入开始时），由于该步骤的身份识别不完整，警报以 $0.30$ 的概率被路由至开具处方的医生，并以 $0.70$ 的概率被路由至分诊护士池。\n\n令依从性为接收者执行推荐操作（例如，解决过敏冲突）的概率。在较晚的时间点，当开具处方的医生收到警报时，依从性概率为 $0.48$；当分诊护士收到警报时，依从性概率为 $0.15$。在较早的时间点，当开具处方的医生收到警报时，依从性概率增加到 $0.62$；当分诊护士收到警报时，依从性概率增加到 $0.25$，这反映了在医嘱最终确定前采取行动的更佳时机。所有概率均为经验估计值，并且在不同医嘱之间是独立的。\n\n从概率和条件概率的核心定义出发，通过适当组合路由概率和条件依从性概率，计算在较晚时间点和较早时间点的预期依从性。然后计算对依从性的净效应，定义为 $\\Delta A = A_{\\text{early}} - A_{\\text{late}}$，其中 $A_{\\text{early}}$ 和 $A_{\\text{late}}$ 分别是较早和较晚时间点下的预期依从性概率。\n\n将净效应 $\\Delta A$ 表示为一个无单位的小数。将您的答案四舍五入到四位有效数字。不要使用百分号。",
            "solution": "首先将根据指定标准对问题进行验证。\n\n### 问题验证\n\n#### 步骤1：提取已知信息\n问题提供了以下数据点和定义：\n\n*   **CDS 定义**：在诊疗关键时刻向临床医生提供针对特定患者的评估或建议的软件。\n*   **五个正确原则**：正确的信息、正确的人员、正确的干预形式、正确的渠道以及正确的时间/地点。\n*   **场景**：针对高风险抗生素的过敏检查警报。\n*   **较晚时间点（签署后）的路由概率**：\n    *   路由至开具处方的医生：$0.95$\n    *   路由至分诊护士池：$0.05$\n*   **较早时间点（签署前）的路由概率**：\n    *   路由至开具处方的医生：$0.30$\n    *   路由至分诊护士池：$0.70$\n*   **依从性定义**：接收者执行推荐操作的概率。\n*   **较晚时间点的条件依从性概率**：\n    *   医生接收者的依从性概率：$0.48$\n    *   护士接收者的依从性概率：$0.15$\n*   **较早时间点的条件依从性概率**：\n    *   医生接收者的依从性概率：$0.62$\n    *   护士接收者的依从性概率：$0.25$\n*   **独立性假设**：所有概率均为经验估计值，并且在不同医嘱之间是独立的。\n*   **待计算量**：\n    *   较晚时间点的预期依从性，$A_{\\text{late}}$。\n    *   较早时间点的预期依从性，$A_{\\text{early}}$。\n    *   对依从性的净效应，$\\Delta A = A_{\\text{early}} - A_{\\text{late}}$。\n*   **输出格式**：$\\Delta A$ 的最终答案必须是一个四舍五入到四位有效数字的无单位小数。\n\n#### 步骤2：使用提取的已知信息进行验证\n对问题的有效性进行评估：\n1.  **科学依据**：该问题植根于成熟的医学信息学领域，并使用了临床决策支持（CDS）和“五个正确原则”等该学科的标准概念。使用概率论来建模系统性能是一种标准且严谨的科学方法。参数被说明是“科学上合理的”，其数值与在真实世界环境中可能观察到的情况一致。\n2.  **适定性**：该问题是适定的。它提供了计算所需量的所有必要概率。目标明确：计算两个期望值及其差值。根据给定数据可以推导出唯一的解。\n3.  **客观性**：语言精确且量化。它避免了主观或基于意见的陈述。术语在问题背景下有明确定义。\n4.  **缺陷清单**：该问题没有表现出任何列举的缺陷。它并非科学上不合理、不可形式化、不完整、矛盾、不切实际、不适定、伪深刻或无法验证。其设置是全概率定律的直接应用。\n\n#### 步骤3：结论与行动\n该问题被判定为**有效**。将提供解答。\n\n### 解题推导\n\n该问题要求计算临床警报在两个不同时间点（“较晚”时间点和“较早”时间点）的预期依从性概率。预期依从性是依从性的总概率，可以使用全概率定律求得。警报接收者的样本空间被划分为两个互斥事件：警报被路由至开具处方的医生，或者被路由至分诊护士池。\n\n让我们定义以下事件和概率：\n*   $T_L$：警报在较晚时间点触发。\n*   $T_E$：警报在较早时间点触发。\n*   $R_P$：警报被路由至开具处方的医生。\n*   $R_N$：警报被路由至分诊护士池。\n*   $A$：接收者依从推荐。\n\n根据问题陈述，我们有以下概率：\n\n对于较晚时间点，$T_L$：\n*   $P(R_P | T_L) = 0.95$\n*   $P(R_N | T_L) = 0.05$\n*   $P(A | R_P \\cap T_L) = 0.48$（依从性，给定在较晚时间点接收者为医生）\n*   $P(A | R_N \\cap T_L) = 0.15$（依从性，给定在较晚时间点接收者为护士）\n\n对于较早时间点，$T_E$：\n*   $P(R_P | T_E) = 0.30$\n*   $P(R_N | T_E) = 0.70$\n*   $P(A | R_P \\cap T_E) = 0.62$（依从性，给定在较早时间点接收者为医生）\n*   $P(A | R_N \\cap T_E) = 0.25$（依从性，给定在较早时间点接收者为护士）\n\n在较晚时间点的预期依从性 $A_{\\text{late}}$ 是以较晚时间点为条件的依从性总概率 $P(A | T_L)$。我们应用全概率定律，对接收者类型进行边缘化：\n$$A_{\\text{late}} = P(A | T_L) = P(A \\cap R_P | T_L) + P(A \\cap R_N | T_L)$$\n使用条件概率的定义，$P(X \\cap Y | Z) = P(X | Y \\cap Z)P(Y | Z)$，我们得到：\n$$A_{\\text{late}} = P(A | R_P \\cap T_L) P(R_P | T_L) + P(A | R_N \\cap T_L) P(R_N | T_L)$$\n代入给定值：\n$$A_{\\text{late}} = (0.48)(0.95) + (0.15)(0.05)$$\n$$A_{\\text{late}} = 0.456 + 0.0075$$\n$$A_{\\text{late}} = 0.4635$$\n\n同样地，在较早时间点的预期依从性 $A_{\\text{early}}$ 是以较早时间点为条件的依从性总概率 $P(A | T_E)$：\n$$A_{\\text{early}} = P(A | T_E) = P(A | R_P \\cap T_E) P(R_P | T_E) + P(A | R_N \\cap T_E) P(R_N | T_E)$$\n代入较早时间点的给定值：\n$$A_{\\text{early}} = (0.62)(0.30) + (0.25)(0.70)$$\n$$A_{\\text{early}} = 0.186 + 0.175$$\n$$A_{\\text{early}} = 0.361$$\n\n最后一步是计算对依从性的净效应 $\\Delta A$，定义为较早和较晚依从性概率之间的差值：\n$$\\Delta A = A_{\\text{early}} - A_{\\text{late}}$$\n$$\\Delta A = 0.361 - 0.4635$$\n$$\\Delta A = -0.1025$$\n\n问题要求结果为一个四舍五入到四位有效数字的无单位小数。计算出的值 $-0.1025$ 已经有四位有效数字（数字 $1$、$0$、$2$ 和 $5$）。因此，无需进一步四舍五入。",
            "answer": "$$\\boxed{-0.1025}$$"
        },
        {
            "introduction": "“正确信息”的原则是任何可靠 CDS 系统的基石。本练习  通过一个具体模型，展示了数据质量的极端重要性：即使输入数据中存在很小比例的错误，也可能显著降低 CDS 警报的临床效用，特别是其阳性预测值（Positive Predictive Value, PPV）。这个练习将运用贝叶斯定理，对这种效用下降进行严谨的量化分析，从而加深对信息准确性的理解。",
            "id": "4860733",
            "problem": "一家医院为“五个正确”框架部署了临床决策支持（CDS）系统，旨在在正确的时间，通过正确的渠道，以正确的干预形式，将正确的信息传递给正确的人。考虑一个二元CDS警报，其设计目的是识别具有真实临床状况的患者（例如，指示风险的药物-检验相互作用），其中“正确信息”的要求是一个从电子健康记录中提取的单个关键二元输入变量。当此输入正确时，该CDS警报对于该真实状况（其在目标人群中的患病率为$p$）的表现如同一个诊断测试，具有灵敏度$Se$和特异度$Sp$。然而，当输入变量被错误分类时，警报可能会相对于其无错误状态发生反转。\n\n假设以下科学上合理的参数：灵敏度$Se = 0.85$，特异度$Sp = 0.95$，以及患病率$p = 0.10$。将“正确信息”的违背建模为对任何患者的警报输出的独立伯努利翻转，其概率为$m$，无论其真实状况状态如何。也就是说，警报输出有$m$的概率相对于其在信息正确情况下的状态发生反转，有$1-m$的概率保持与信息正确情况下相同。\n\n使用灵敏度、特异度、患病率和贝叶斯定理的基本定义，推导在$m=0$和$m=0.05$下的阳性预测值（PPV），然后计算其影响，定义为PPV的绝对变化，即$m=0.05$时的PPV减去$m=0$时的PPV。最终答案以小数形式表示，并四舍五入到四位有效数字。",
            "solution": "该问题要求计算信息错误对临床决策支持（CDS）警报的阳性预测值（PPV）的影响。解决方案首先推导PPV作为信息错误概率$m$的函数的通用公式，然后将此公式应用于$m=0$和$m=0.05$的特定情况。\n\n我们定义以下事件：\n$D$：患者具有真实的临床状况。\n$D^c$：患者不具有真实的临床状况。\n$A_0$：假设信息正确，警报为阳性（触发）。\n$A_m$：考虑信息错误概率$m$后，最终警报为阳性。\n\n问题提供了以下参数：\n状况的患病率：$P(D) = p = 0.10$\n理想警报的灵敏度：$P(A_0 | D) = Se = 0.85$\n理想警报的特异度：$P(A_0^c | D^c) = Sp = 0.95$\n\n由此，我们可以推导出理想警报的其他概率：\n无此状况的概率：$P(D^c) = 1 - p = 1 - 0.10 = 0.90$\n假阴性率：$P(A_0^c | D) = 1 - Se = 1 - 0.85 = 0.15$\n假阳性率：$P(A_0 | D^c) = 1 - Sp = 1 - 0.95 = 0.05$\n\n错误模型指出，最终警报输出以概率$m$发生反转。最终警报为阳性（$A_m$）发生在以下两种情况：理想警报为阳性（$A_0$）且未被反转（概率为$1-m$），或者理想警报为阴性（$A_0^c$）且被反转（概率为$m$）。此错误过程与患者的真实状况无关。\n\n阳性预测值 $\\text{PPV}_m$ 是在最终警报为阳性的条件下，患者具有该状况的概率，即 $P(D | A_m)$。使用贝叶斯定理：\n$$ \\text{PPV}_m = P(D | A_m) = \\frac{P(A_m | D) P(D)}{P(A_m)} $$\n分母 $P(A_m)$ 可以使用全概率公式展开：\n$$ P(A_m) = P(A_m | D) P(D) + P(A_m | D^c) P(D^c) $$\n为了解决这个问题，我们必须首先推导有效灵敏度 $P(A_m | D)$ 和有效假阳性率 $P(A_m | D^c)$ 作为 $m$ 的函数。\n\n有效灵敏度，我们称之为 $Se_m$，即 $P(A_m | D)$。我们通过以理想警报的状态 $A_0$ 为条件来求得此值：\n$$ Se_m = P(A_m | D) = P(A_m | A_0, D) P(A_0 | D) + P(A_m | A_0^c, D) P(A_0^c | D) $$\n在理想警报为阳性 ($A_0$) 的情况下，如果最终警报没有反转，则为阳性 ($A_m$)，因此 $P(A_m | A_0, D) = 1-m$。\n在理想警报为阴性 ($A_0^c$) 的情况下，如果最终警报发生反转，则为阳性 ($A_m$)，因此 $P(A_m | A_0^c, D) = m$。\n将这些与 $Se$ 和假阴性率（FNR）的定义代入：\n$$ Se_m = (1-m) P(A_0 | D) + m P(A_0^c | D) = (1-m)Se + m(1-Se) $$\n\n同样，有效假阳性率 $FPR_m = P(A_m | D^c)$ 为：\n$$ FPR_m = P(A_m | D^c) = P(A_m | A_0, D^c) P(A_0 | D^c) + P(A_m | A_0^c, D^c) P(A_0^c | D^c) $$\n对反转概率使用相同的逻辑：\n$$ FPR_m = (1-m) P(A_0 | D^c) + m P(A_0^c | D^c) = (1-m)(1-Sp) + m(Sp) $$\n\n现在我们可以写出 $\\text{PPV}_m$ 的通用公式：\n$$ \\text{PPV}_m = \\frac{p \\cdot Se_m}{p \\cdot Se_m + (1-p) \\cdot FPR_m} = \\frac{p \\cdot [Se(1-m) + m(1-Se)]}{p \\cdot [Se(1-m) + m(1-Se)] + (1-p) \\cdot [(1-Sp)(1-m) + m \\cdot Sp]} $$\n\n步骤1：计算 $\\text{PPV}_0$（当 $m=0$ 时）。\n当 $m=0$ 时，通用公式简化为标准的 PPV 公式：\n$$ \\text{PPV}_0 = \\frac{p \\cdot Se}{p \\cdot Se + (1-p)(1-Sp)} $$\n代入给定值 $p=0.10$，$Se=0.85$ 和 $Sp=0.95$：\n$$ \\text{PPV}_0 = \\frac{0.10 \\times 0.85}{(0.10 \\times 0.85) + (1-0.10)(1-0.95)} $$\n$$ \\text{PPV}_0 = \\frac{0.085}{0.085 + (0.90)(0.05)} = \\frac{0.085}{0.085 + 0.045} = \\frac{0.085}{0.130} \\approx 0.653846 $$\n\n步骤2：计算 $\\text{PPV}_{0.05}$（当 $m=0.05$ 时）。\n首先，我们计算当 $m=0.05$ 时的有效灵敏度 $Se_{0.05}$ 和有效假阳性率 $FPR_{0.05}$：\n$$ Se_{0.05} = (1-0.05)(0.85) + (0.05)(1-0.85) = (0.95)(0.85) + (0.05)(0.15) = 0.8075 + 0.0075 = 0.815 $$\n$$ FPR_{0.05} = (1-0.05)(1-0.95) + (0.05)(0.95) = (0.95)(0.05) + (0.05)(0.95) = 0.0475 + 0.0475 = 0.095 $$\n现在，我们用这些值来计算 $\\text{PPV}_{0.05}$：\n$$ \\text{PPV}_{0.05} = \\frac{p \\cdot Se_{0.05}}{p \\cdot Se_{0.05} + (1-p) \\cdot FPR_{0.05}} $$\n$$ \\text{PPV}_{0.05} = \\frac{0.10 \\times 0.815}{(0.10 \\times 0.815) + (0.90 \\times 0.095)} $$\n$$ \\text{PPV}_{0.05} = \\frac{0.0815}{0.0815 + 0.0855} = \\frac{0.0815}{0.1670} \\approx 0.488024 $$\n\n步骤3：计算影响。\n影响定义为 PPV 从理想状态到易错状态的变化：\n$$ \\text{Impact} = \\text{PPV}_{0.05} - \\text{PPV}_0 $$\n$$ \\text{Impact} \\approx 0.488024 - 0.653846 = -0.165822 $$\n四舍五入到四位有效数字，影响为 $-0.1658$。这个负值表明，由于存在 $5\\%$ 的信息错误率，警报的预测能力出现了显著下降。",
            "answer": "$$\\boxed{-0.1658}$$"
        },
        {
            "introduction": "在掌握了概率模型之后，最后的这个实践练习  将挑战您构建一个实用的工具。您将基于确定性有限自动机（Deterministic Finite Automaton, DFA）实现一个上下文感知算法，以识别临床工作流中的“正确时间”。这个练习旨在弥合“五个正确”原则的抽象概念与在真实电子健康记录（EHR）系统中实现这些原则所需的具体软件工程技术之间的鸿沟，将理论付诸实践。",
            "id": "4860764",
            "problem": "给定一个基于临床决策支持（CDS）“五个正确”（Five Rights）原则的序列建模任务，该原则规定 CDS 干预措施应“在工作流程中的正确时间，通过正确的渠道，以正确的干预格式，将正确的信息，传递给正确的人”。从电子健康记录（EHR）事件分析的角度来看，“在工作流程中的正确时间”这一维度要求检测临床医生是否正积极从事开立医嘱的活动，以便可以显示干预措施而不会中断不相关的工作。形式上，您必须使用基于第一性原理的确定性、可复现的算法，从 EHR 事件日志中推断出二元的医嘱开立状态，然后通过计算精确率和召回率，根据带标注的真实数据来验证这一推断。\n\n基本原理：\n- 临床决策支持（CDS）的五个正确原则被视为一项基本约束：CDS 干预必须在“工作流程中的正确时间”向“正确的人”展示。在计算术语中，这意味着状态推断应限定在正确的用户和患者上下文中，并且只应在开立医嘱任务期间激活。\n- 确定性有限自动机（DFA）：一个基于离散事件的 DFA 可以为工作流上下文建模。DFA 由一组有限的状态和基于事件的确定性转换组成。这在计算机科学中被广泛接受用于为交互序列建模。\n- 信息检索指标：精确率和召回率是基于预测为正的集合和实际为正的集合定义的。设 $\\mathrm{TP}$ 表示真阳性，$\\mathrm{FP}$ 表示假阳性，$\\mathrm{FN}$ 表示假阴性。则精确率为 $\\mathrm{precision} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}$，召回率为 $\\mathrm{recall} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}$。如果分母为 $0$，则按照惯例将相应的指标定义为 $1$，以避免出现未定义的值，同时保持相对于错误的单调性。\n\n任务：\n1. 构建一个确定性的上下文检测算法，对于每个事件，标注在该时刻医嘱开立上下文对于元组 $(\\text{user}, \\text{patient})$ 是否处于活动状态。使用一个 DFA，其状态包括一个基线的非活动状态和至少一个表示正在进行医嘱编辑的活动状态。该 DFA 必须：\n   - 为每个 $(\\text{user}, \\text{patient})$ 对维护独立的上下文，以满足“正确的人”约束。\n   - 在确定性地指示进入医嘱编辑（例如，打开医嘱编辑器）的事件上激活。\n   - 在涉及医嘱录入步骤（例如，输入剂量或途径，添加到购物车）的事件上保持激活状态。\n   - 在确定性地终止医嘱编辑（例如，签署医嘱，取消，关闭医嘱编辑器）的事件上停用。\n   - 当某个用户的事件切换了患者时，立即清除该用户的所有活动上下文。\n   - 当且仅当其 $(\\text{user}, \\text{patient})$ 的医嘱开立上下文在处理事件转换后立即处于活动状态时，将每个事件标注为阳性（活动）。特殊情况是，一个终止医嘱编辑的事件当且仅当其上下文在终止前立即处于活动状态时，才被标注为阳性。\n\n2. 计算您预测的标签与每个测试用例的真实标注之间的 $\\mathrm{precision}$ 和 $\\mathrm{recall}$。将每个指标作为 $[0,1]$ 范围内的十进制数返回，四舍五入到小数点后 $3$ 位。\n\n事件：\n每个事件是一个元组 $(t, u, p, e)$，其中 $t$ 是一个整数时间戳， $u$ 是一个字符串用户标识符， $p$ 是一个字符串患者标识符， $e$ 是一个字符串事件类型。事件空间至少包括以下标记：$\\texttt{open\\_patient\\_chart}$、$\\texttt{search\\_medication}$、$\\texttt{open\\_order\\_composer}$、$\\texttt{enter\\_dose}$、$\\texttt{enter\\_route}$、$\\texttt{add\\_to\\_cart}$、$\\texttt{view\\_lab}$、$\\texttt{sign\\_orders}$、$\\texttt{cancel}$、$\\texttt{close\\_order\\_composer}$、$\\texttt{switch\\_patient}$、$\\texttt{view\\_note}$。您可以假设在每个测试用例中，事件已经按 $t$ 的升序排列。\n\n测试套件：\n为以下案例提供结果。对于每个案例，第二项是与事件位置对应的真实二元标签序列。标签 $1$ 表示医嘱开立上下文处于活动状态；标签 $0$ 表示非活动状态。\n\n- 案例 $1$ (理想路径，单个用户和患者):\n  事件：\n  $(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart})$,\n  $(2,\\texttt{U1},\\texttt{P1},\\texttt{search\\_medication})$,\n  $(3,\\texttt{U1},\\texttt{P1},\\texttt{open\\_order\\_composer})$,\n  $(4,\\texttt{U1},\\texttt{P1},\\texttt{enter\\_dose})$,\n  $(5,\\texttt{U1},\\texttt{P1},\\texttt{enter\\_route})$,\n  $(6,\\texttt{U1},\\texttt{P1},\\texttt{add\\_to\\_cart})$,\n  $(7,\\texttt{U1},\\texttt{P1},\\texttt{view\\_lab})$,\n  $(8,\\texttt{U1},\\texttt{P1},\\texttt{sign\\_orders})$,\n  $(9,\\texttt{U1},\\texttt{P1},\\texttt{view\\_lab})$.\n  真实数据：$[0,0,1,1,1,1,1,1,0]$。\n\n- 案例 $2$ (无开立医嘱活动，仅有噪声):\n  事件：\n  $(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart})$,\n  $(2,\\texttt{U1},\\texttt{P1},\\texttt{view\\_lab})$,\n  $(3,\\texttt{U1},\\texttt{P1},\\texttt{view\\_note})$.\n  真实数据：$[0,0,0]$。\n\n- 案例 $3$ (放弃编辑器并切换患者):\n  事件：\n  $(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart})$,\n  $(2,\\texttt{U1},\\texttt{P1},\\texttt{open\\_order\\_composer})$,\n  $(3,\\texttt{U1},\\texttt{P1},\\texttt{enter\\_dose})$,\n  $(4,\\texttt{U1},\\texttt{P1},\\texttt{close\\_order\\_composer})$,\n  $(5,\\texttt{U1},\\texttt{P1},\\texttt{search\\_medication})$,\n  $(6,\\texttt{U1},\\texttt{P2},\\texttt{switch\\_patient})$,\n  $(7,\\texttt{U1},\\texttt{P2},\\texttt{open\\_order\\_composer})$,\n  $(8,\\texttt{U1},\\texttt{P2},\\texttt{enter\\_route})$,\n  $(9,\\texttt{U1},\\texttt{P2},\\texttt{cancel})$.\n  真实数据：$[0,1,1,1,0,0,1,1,1]$。\n\n- 案例 $4$ (多用户交错活动，同一患者):\n  事件：\n  $(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_order\\_composer})$,\n  $(2,\\texttt{U2},\\texttt{P1},\\texttt{open\\_patient\\_chart})$,\n  $(3,\\texttt{U1},\\texttt{P1},\\texttt{enter\\_dose})$,\n  $(4,\\texttt{U2},\\texttt{P1},\\texttt{search\\_medication})$,\n  $(5,\\texttt{U2},\\texttt{P1},\\texttt{open\\_order\\_composer})$,\n  $(6,\\texttt{U1},\\texttt{P1},\\texttt{sign\\_orders})$,\n  $(7,\\texttt{U2},\\texttt{P1},\\texttt{enter\\_route})$,\n  $(8,\\texttt{U2},\\texttt{P1},\\texttt{sign\\_orders})$.\n  真实数据：$[1,0,1,0,1,1,1,1]$。\n\n- 案例 $5$ (缺少编辑器打开事件，人工标注的医嘱开立):\n  事件：\n  $(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart})$,\n  $(2,\\texttt{U1},\\texttt{P1},\\texttt{search\\_medication})$,\n  $(3,\\texttt{U1},\\texttt{P1},\\texttt{enter\\_dose})$,\n  $(4,\\texttt{U1},\\texttt{P1},\\texttt{enter\\_route})$,\n  $(5,\\texttt{U1},\\texttt{P1},\\texttt{add\\_to\\_cart})$,\n  $(6,\\texttt{U1},\\texttt{P1},\\texttt{sign\\_orders})$.\n  真实数据：$[0,0,1,1,1,1]$。\n\n- 案例 $6$ (虚假的编辑器打开事件，立即取消):\n  事件：\n  $(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart})$,\n  $(2,\\texttt{U1},\\texttt{P1},\\texttt{open\\_order\\_composer})$,\n  $(3,\\texttt{U1},\\texttt{P1},\\texttt{cancel})$.\n  真实数据：$[0,0,0]$。\n\n输出规范：\n- 对于每个案例，计算 $\\mathrm{precision}$ 和 $\\mathrm{recall}$，结果为 $[0,1]$ 范围内的十进制数，四舍五入到小数点后 $3$ 位。\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，格式为：$[\\text{precision}_{1},\\text{recall}_{1},\\text{precision}_{2},\\text{recall}_{2},\\ldots]$，包含所有案例的结果。",
            "solution": "用户提供了一个问题，要求开发并评估一个确定性算法，用于在电子健康记录（EHR）事件日志中检测开立医嘱的活动。该问题被置于临床决策支持（CDS）“五个正确”原则的背景下，并使用确定性有限自动机（DFA）进行建模。该算法的性能将使用精确率和召回率，根据提供的真实标注数据进行衡量。\n\n### 第 1 步：提取已知信息\n\n- **基本概念**：\n    - **CDS 五个正确原则**：CDS 干预必须在“工作流程中的正确时间”向“正确的人”提供。这意味着状态推断必须限定在 $(\\text{user}, \\text{patient})$ 上下文中，并在开立医嘱期间激活。\n    - **DFA 模型**：使用 DFA 对工作流上下文进行建模，该模型包括状态和基于事件的确定性转换。\n    - **评估指标**：精确率定义为 $\\mathrm{precision} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}$，召回率定义为 $\\mathrm{recall} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}$，其中 $\\mathrm{TP}$ 是真阳性，$\\mathrm{FP}$ 是假阳性，$\\mathrm{FN}$ 是假阴性。如果分母为 $0$，则该指标定义为 $1$。\n\n- **任务要求**：\n    1.  **算法构建**：使用 DFA 构建一个确定性的上下文检测算法。\n        -   DFA 必须为每个 $(\\text{user}, \\text{patient})$ 对维护独立的状态。\n        -   激活事件：像 `open_order_composer` 这样的事件会激活医嘱开立上下文。\n        -   保持激活事件：像 `enter_dose`、`enter_route`、`add_to_cart` 这样的事件会维持活动状态。\n        -   终止事件：像 `sign_orders`、`cancel`、`close_order_composer` 这样的事件会停用上下文。\n        -   患者切换规则：对于给定用户的 `switch_patient` 类型事件，必须清除该用户的所有活动上下文。\n        -   标签规则：\n            - 对于一个终止事件，如果上下文在转换*之前*是活动的，则标签为阳性。\n            - 对于所有其他事件，如果上下文在转换*之后*是活动的，则标签为阳性。\n    2.  **评估**：为每个测试用例计算 $\\mathrm{precision}$ 和 $\\mathrm{recall}$，并四舍五入到小数点后 $3$ 位。\n\n- **事件数据**：\n    -   **结构**：事件是元组 $(t, u, p, e)$，其中 $t$ 是整数时间戳， $u$ 是用户字符串， $p$ 是患者字符串， $e$ 是事件类型字符串。事件已按 $t$ 排序。\n    -   **事件类型**：`open_patient_chart`、`search_medication`、`open_order_composer`、`enter_dose`、`enter_route`、`add_to_cart`、`view_lab`、`sign_orders`、`cancel`、`close_order_composer`、`switch_patient`、`view_note`。\n\n- **测试套件**：\n    -   **案例 1**：事件：$[(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart}), \\ldots, (9,\\texttt{U1},\\texttt{P1},\\texttt{view\\_lab})]$；真实数据：$[0,0,1,1,1,1,1,1,0]$。\n    -   **案例 2**：事件：$[(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart}), \\ldots, (3,\\texttt{U1},\\texttt{P1},\\texttt{view\\_note})]$；真实数据：$[0,0,0]$。\n    -   **案例 3**：事件：$[(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart}), \\ldots, (9,\\texttt{U1},\\texttt{P2},\\texttt{cancel})]$；真实数据：$[0,1,1,1,0,0,1,1,1]$。\n    -   **案例 4**：事件：$[(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_order\\_composer}), \\ldots, (8,\\texttt{U2},\\texttt{P1},\\texttt{sign\\_orders})]$；真实数据：$[1,0,1,0,1,1,1,1]$。\n    -   **案例 5**：事件：$[(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart}), \\ldots, (6,\\texttt{U1},\\texttt{P1},\\texttt{sign\\_orders})]$；真实数据：$[0,0,1,1,1,1]$。\n    -   **案例 6**：事件：$[(1,\\texttt{U1},\\texttt{P1},\\texttt{open\\_patient\\_chart}), \\ldots, (3,\\texttt{U1},\\texttt{P1},\\texttt{cancel})]$；真实数据：$[0,0,0]$。\n\n- **输出格式**：一个单一的逗号分隔的指标列表：$[\\text{precision}_{1},\\text{recall}_{1},\\ldots,\\text{precision}_{6},\\text{recall}_{6}]$。\n\n### 第 2 步：使用提取的已知信息进行验证\n该问题具有科学依据，借鉴了医学信息学（CDS）、计算机科学（DFA）和信息检索（指标）的成熟原理。问题陈述清晰，给出了明确的目标、确定性的算法构建规则以及一套完整的评估测试数据。语言客观、正式。\n\n该问题是自包含且内部一致的。DFA 的规则已明确规定。标签逻辑，包括终止事件的特殊情况，也已明确定义。处理指标计算中除以零情况的约定也已说明。一些测试用例（例如案例 5 和案例 6）呈现了一些场景，其中规定的简单 DFA 模型将与提供的真实数据不匹配。这不是问题陈述中的矛盾或缺陷。相反，这是模型评估任务的标准特征，其目标是实现一个特定的模型，并量化其性能（包括其失败之处）与由真实数据所代表的更复杂或细微的现实之间的差异。因此，该问题是一个有效的算法实现和评估练习。\n\n### 第 3 步：结论与行动\n问题被判定为**有效**。将提供一个解决方案。\n\n### 解决方案\n\n任务是实现一个确定性有限自动机（DFA），从 EHR 事件序列中推断出二元的“医嘱开立”状态，然后评估其性能。\n\n#### DFA 设计\n\n该 DFA 将有两个状态：`INACTIVE`（由 $0$ 表示）和 `ACTIVE`（由 $1$ 表示）。状态不是全局的，而是为每个 $(\\text{user}, \\text{patient})$ 上下文独立维护。使用一个将元组 $(u, p)$ 映射到其当前状态的字典是实现这一点的合适数据结构。\n\n转换由事件类型 $e$ 定义：\n- **激活事件**：$E_{\\text{activate}} = \\{\\texttt{open\\_order\\_composer}\\}$。一个事件 $e \\in E_{\\text{activate}}$ 将上下文状态从 `INACTIVE` 转换为 `ACTIVE`。\n- **终止事件**：$E_{\\text{terminate}} = \\{\\texttt{sign\\_orders}, \\texttt{cancel}, \\texttt{close\\_order\\_composer}\\}$。一个事件 $e \\in E_{\\text{terminate}}$ 将上下文状态从 `ACTIVE` 转换为 `INACTIVE`。\n- **中性事件**：所有其他事件不引起状态转换。\n- **上下文重置事件**：事件 `switch_patient` 是一个特例。对于一个事件 $(t, u, p, \\texttt{switch\\_patient})$，与用户 $u$ 相关的所有活动上下文，即任何元组 $(u, p')$（其中 $p'$ 是任何患者）的状态，都将被重置为 `INACTIVE`。\n\n#### 标签预测逻辑\n\n对于序列中的每个事件，我们预测一个二元标签（$1$ 表示活动，$0$ 表示非活动）。设 $S_{before}$ 为处理当前事件前相关 $(\\text{user}, \\text{patient})$ 上下文的状态， $S_{after}$ 为处理后立即的状态。\n- 如果事件类型 $e \\in E_{\\text{terminate}}$，则当 $S_{before} = \\text{ACTIVE}$ 时预测标签为 $1$，否则为 $0$。\n- 对于任何其他事件类型 $e \\notin E_{\\text{terminate}}$，则当 $S_{after} = \\text{ACTIVE}$ 时预测标签为 $1$，否则为 $0$。\n\n#### 评估指标\n\n给定一个测试用例的预测标签和真实标签，我们计算真阳性（$\\mathrm{TP}$）、假阳性（$\\mathrm{FP}$）和假阴性（$\\mathrm{FN}$）的数量。\n- $\\mathrm{TP}$：预测标签和真实标签都为 $1$ 的事件数量。\n- $\\mathrm{FP}$：预测标签为 $1$ 而真实标签为 $0$ 的事件数量。\n- $\\mathrm{FN}$：预测标签为 $0$ 而真实标签为 $1$ 的事件数量。\n\n然后按如下方式计算精确率和召回率：\n- $\\mathrm{precision} = \\begin{cases} 1.0  \\text{如果 } \\mathrm{TP}+\\mathrm{FP} = 0 \\\\ \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}  \\text{其他情况} \\end{cases}$\n- $\\mathrm{recall} = \\begin{cases} 1.0  \\text{如果 } \\mathrm{TP}+\\mathrm{FN} = 0 \\\\ \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}  \\text{其他情况} \\end{cases}$\n结果四舍五入到小数点后 $3$ 位。\n\n#### 算法流程\n\n对于每个测试用例：\n1. 初始化一个空字典 `contexts`，用于存储每个 $(\\text{user}, \\text{patient})$ 对的状态。\n2. 初始化一个空列表 `predicted_labels`。\n3. 遍历事件序列中的每个事件 $(t, u, p, e)$。\n    a. 从 `contexts` 中检索上下文 $(u, p)$ 的当前状态 $S_{before}$，如果不存在，则默认为 `INACTIVE` ($0$)。\n    b. 如果 $e = \\texttt{switch\\_patient}$，遍历 `contexts` 中的所有键 $(u', p')$。如果 $u' = u$，则设置 `contexts[(u', p')] = 0`。\n    c. 确定下一个状态 $S_{after}$：如果 $e \\in E_{\\text{activate}}$，则 $S_{after} = 1$。如果 $e \\in E_{\\text{terminate}}$，则 $S_{after} = 0$。否则，$S_{after} = S_{before}$。\n    d. 确定当前事件的标签：如果 $e \\in E_{\\text{terminate}}$，标签为 $S_{before}$。否则，标签为 $S_{after}$。将此标签附加到 `predicted_labels`。\n    e. 更新上下文状态：`contexts[(u, p)] = S_{after}`。\n4. 处理完所有事件后，通过比较 `predicted_labels` 和真实标签来计算 $\\mathrm{TP}$、$\\mathrm{FP}$ 和 $\\mathrm{FN}$。\n5. 使用指定的公式计算并四舍五入 `precision` 和 `recall`。\n6. 将计算出的指标附加到全局结果列表中。\n7. 在所有案例处理完毕后，将最终结果列表格式化为所需的输出字符串。",
            "answer": "$$\\boxed{[1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000,0.000,0.000,1.000]}$$"
        }
    ]
}