{
    "hands_on_practices": [
        {
            "introduction": "基因组流行病学的核心是理解时间与基因差异之间的关系。本练习将引导你从第一性原理出发，推导两个相关病原体基因组之间的预期单核苷酸多态性（SNP）差异数量，这是在疫情暴发中解读基因组数据的关键计算 。通过这个实践，你将掌握分子钟概念在实际应用中的基本计算方法。",
            "id": "4527622",
            "problem": "在一次克隆性细菌爆发中，两名患者在同一日历时间从一个共同来源感染，然后他们的感染在没有重组的情况下独立演化。两名患者在从共同来源分化后经过 $\\Delta t$ 的持续时间后，在同一调查时间进行采样。假设存在一个严格分子钟，其每个位点的替换率为 $\\mu$（每个位点每年替换次数），核心基因组长度为 $L$ 个可调用位点，并且突变根据泊松过程在各位点上作为独立事件发生。从泊松过程的定义和期望的线性性出发，推导一个表达式，用 $\\mu$、$L$ 和 $\\Delta t$ 表示采样时两个基因组之间预期的单核苷酸多态性（SNP）差异数。陈述使您的表达式在用于疫情控制的基因组流行病学背景下成为有效近似的最小建模假设。然后，使用 $\\mu = 1.0 \\times 10^{-6}$ 次替换/位点/年，$L = 4.0 \\times 10^{6}$ 个位点，以及 $\\Delta t = 0.25$ 年，计算预期的 SNP 差异。将您的最终数值答案四舍五入到三位有效数字。将您的最终答案表示为一个纯数（无量纲计数）。",
            "solution": "该问题陈述已经过验证，被认为是合理的。它具有科学依据，问题设定良好且客观。所有必要的参数和定义都已提供，它代表了基因组流行病学中一个可形式化的问题。\n\n问题要求推导从一个共同来源分化的两个细菌基因组之间预期的单核苷酸多态性（SNP）差异数。\n\n让我们定义所提供的参数：\n- 每个位点的替换率为 $\\mu$，单位为 替换数/位点/年。\n- 核心基因组长度为 $L$ 个可调用位点。\n- 从共同来源分化后经过的时间为 $\\Delta t$ 年。\n\n演化情景涉及两个从共同祖先分化的谱系（在患者1和患者2中）。两个谱系都独立演化了 $\\Delta t$ 的时间。分隔两个采样基因组的总演化时间是回到它们最近共同祖先的两个分支长度之和。因此，用于区分两个基因组的突变累积的总时间是 $T = \\Delta t + \\Delta t = 2\\Delta t$。\n\n问题陈述指出，突变根据泊松过程在各位点上作为独立事件发生。我们首先考虑单个位点，位点 $i$，其中 $i$ 是从 $1$ 到 $L$ 的整数。\n\n在这单个位点上的替换率为 $\\mu$。对于泊松过程，给定区间的速率参数 $\\lambda$ 是速率与区间长度的乘积。在这种情况下，区间是总演化时间 $T = 2\\Delta t$。因此，单个位点 $i$ 上替换次数的速率参数是 $\\lambda_{\\text{site}} = \\mu \\times T = 2\\mu\\Delta t$。\n\n令 $K_i$ 为表示在总演化时间 $T$ 内在位点 $i$ 上发生的替换次数的随机变量。根据问题定义，$K_i$ 服从参数为 $\\lambda_{\\text{site}}$ 的泊松分布。\n$$ K_i \\sim \\text{Poisson}(2\\mu\\Delta t) $$\n服从泊松分布的随机变量的期望值等于其速率参数。因此，位点 $i$ 上的预期替换次数为：\n$$ E[K_i] = 2\\mu\\Delta t $$\n现在，我们考虑整个长度为 $L$ 的基因组。令 $K_{\\text{total}}$ 为所有 $L$ 个位点上的总替换次数。由于假设不同位点上的突变是独立事件，所以 $K_{\\text{total}}$ 是每个位点上替换次数的总和：\n$$ K_{\\text{total}} = \\sum_{i=1}^{L} K_i $$\n问题要求我们使用期望的线性性。应用此原理，预期的总替换次数是各个期望值的总和：\n$$ E[K_{\\text{total}}] = E\\left[\\sum_{i=1}^{L} K_i\\right] = \\sum_{i=1}^{L} E[K_i] $$\n由于假设替换率 $\\mu$ 在所有 $L$ 个位点上是均一的，因此每个位点 $i$ 的期望 $E[K_i]$ 都是相同的。\n$$ E[K_{\\text{total}}] = \\sum_{i=1}^{L} (2\\mu\\Delta t) = L(2\\mu\\Delta t) = 2\\mu L\\Delta t $$\n问题要求的是预期的 SNP 差异数，我们表示为 $E[N_{\\text{SNP}}]$。一个位点上的 SNP 差异对应于该位点上发生了一次或多次替换事件。总替换次数 $K_{\\text{total}}$ 与 SNP 差异数 $N_{\\text{SNP}}$ 并不严格相同，因为在同一位点上可能发生多次替换（这种事件被称为“多次命中”）。如果一个位点经历两次或更多次替换，它仍然只计为一个 SNP 差异。\n\n然而，在基因组流行病学的短期爆发背景下，总演化时间 $T = 2\\Delta t$ 通常非常短，且突变率 $\\mu$ 很低。因此，单个位点的速率参数 $2\\mu\\Delta t$ 远小于 $1$。对于速率参数 $\\lambda$ 非常小的泊松过程，观察到两次或更多次事件的概率 $P(k \\ge 2)$ 与观察到一次事件的概率 $P(k=1)$ 相比可以忽略不计。\n$P(k=0) = \\exp(-\\lambda) \\approx 1 - \\lambda$\n$P(k=1) = \\lambda \\exp(-\\lambda) \\approx \\lambda$\n$P(k=2) = \\frac{\\lambda^2}{2} \\exp(-\\lambda) \\approx \\frac{\\lambda^2}{2}$\n由于 $\\lambda \\ll 1$，我们有 $\\lambda^2 \\ll \\lambda$。因此，单个位点上发生多次命中的概率可以忽略不计。\n\n在这个有效的近似下，至少有一次替换的位点数（$N_{\\text{SNP}}$）约等于总替换次数（$K_{\\text{total}}$）。因此，它们的期望值也近似相等：\n$$ E[N_{\\text{SNP}}] \\approx E[K_{\\text{total}}] $$\n所以，推导出的预期 SNP 差异数的表达式为：\n$$ E[N_{\\text{SNP}}] = 2\\mu L\\Delta t $$\n使该表达式成为有效近似的最小建模假设是：\n1.  **严格分子钟**：替换率 $\\mu$ 在时间和所有谱系中是恒定的。\n2.  **跨位点速率均一**：替换率 $\\mu$ 对于所有 $L$ 个基因组位点都是相同的。\n3.  **位点独立性**：不同位点上的替换是独立事件。\n4.  **泊松过程**：替换的发生随时间服从泊松分布。\n5.  **克隆演化**：基因组在没有重组的情况下演化。\n6.  **稀有突变近似**：在时间周期内，同一位点发生多次替换的概率可以忽略不计（$2\\mu\\Delta t \\ll 1$），这使得预期的 SNP 数可以通过预期的替换数来近似。\n\n最后，我们使用提供的数据计算数值：\n- $\\mu = 1.0 \\times 10^{-6}$ 替换数/位点/年\n- $L = 4.0 \\times 10^{6}$ 位点\n- $\\Delta t = 0.25$ 年\n\n将这些值代入我们推导的表达式中：\n$$ E[N_{\\text{SNP}}] = 2 \\times (1.0 \\times 10^{-6}) \\times (4.0 \\times 10^{6}) \\times (0.25) $$\n$$ E[N_{\\text{SNP}}] = 2 \\times 1.0 \\times 4.0 \\times 0.25 \\times 10^{-6} \\times 10^{6} $$\n$$ E[N_{\\text{SNP}}] = (2 \\times 0.25) \\times 4.0 $$\n$$ E[N_{\\text{SNP}}] = 0.5 \\times 4.0 $$\n$$ E[N_{\\text{SNP}}] = 2.0 $$\n问题要求答案四舍五入到三位有效数字。因此，结果是 $2.00$。结果是一个无量纲的计数，因为单位抵消了：$(\\text{位点}^{-1} \\text{年}^{-1}) \\times (\\text{位点}) \\times (\\text{年})$。",
            "answer": "$$\n\\boxed{2.00}\n$$"
        },
        {
            "introduction": "在估算了基因距离后，下一个实际步骤是将其用于决策。本练习模拟了一项核心的公共卫生任务：通过设定SNP阈值来定义传播集群 。你将应用统计学原理，推导出一个最佳分界点，以区分近期的直接传播和无关的社区背景病例。",
            "id": "4527583",
            "problem": "在预防医学的疫情控制中，基因组流行病学的一个核心决策问题是确定两个病例是由近期直接传播关联，还是无关的社区病例。考虑一个具有近似恒定分子钟的病原体，其突变过程通过泊松突变过程建模：每个谱系上的突变以每单位时间的恒定速率独立发生。假设以下有科学依据的事实作为推导基础：在分子钟的作用下，突变随时间近似线性累积；并且沿独立谱系累积的单核苷酸多态性（SNPs）数量由一个泊松过程描述，其均值与所用时间成正比。设每基因组替换率为每年每基因组 $\\mu$ 次替换。对于一对样本，设总时间分支长度（从最近共同祖先到每个样本的时间之和）为 $L$，因此预期的 SNP 数量为 $\\lambda = \\mu \\times L$，观测到的成对 SNP 数量 $D$ 被建模为均值为 $\\lambda$ 的泊松随机变量。\n\n给定以下疫情背景，其参数是根据一种快速演化的呼吸道病毒的实际情况选择的：\n\n-   每基因组替换率 $\\mu = 25$ 次替换/基因组/年。\n-   在直接传播情景下，两个病例在一次传播事件发生后 $t_{A} = 9$ 天和 $t_{B} = 14$ 天被采样。假设在直接传播下，最近共同祖先（MRCA）与传播事件重合，因此总分支长度为 $L_{\\mathrm{direct}} = t_{A} + t_{B}$（以天为单位）。\n-   在无关社区情景下，两个病例的谱系平均在过去的 $T_{c} = 0.7$ 年前合并，这反映了流行社区中的背景多样性。在此情景下，总分支长度近似为 $L_{\\mathrm{unrelated}} = 2 T_{c} + \\frac{t_{A} + t_{B}}{365}$（以年为单位），即从 MRCA 到每个样本的时间总和，包括微小的宿主内采样延迟。\n\n在根据观测到的 SNP 距离 $D$ 决定聚类成员关系时，假设“直接传播”和“无关社区”这两个假设具有相等的先验概率和相等的错分成本。使用泊松突变模型和这些假设，计算应设置决策边界的最佳整数 SNP 阈值 $d^{*}$，使得当 $D \\leq d^{*}$ 时，该对病例被归类为传播关联的聚类；当 $D  d^{*}$ 时，被归类为无关。请用单核苷酸多态性（SNPs）的整数形式表示您的最终答案。除了根据决策规则取相应的整数外，不需要其他取整说明。在方框内的最终答案中不要包含单位。",
            "solution": "该问题要求根据分隔一对病原体基因组的单核苷酸多态性（SNPs）数量，确定一个最佳整数阈值，用于将它们分类为直接传播关联或无关社区病例。这是统计决策理论中一个经典的二元假设检验问题。\n\n首先，我们根据所提供的信息将两个对立假设形式化。设 $D$ 为观测到的 SNP 数量，它是一个随机变量。\n-   假设 $H_0$：两个病例由直接传播关联。在此假设下，SNP 数量 $D$ 服从均值为 $\\lambda_0$ 的泊松分布，即 $D \\sim \\mathrm{Poisson}(\\lambda_0)$。\n-   假设 $H_1$：两个病例来自无关社区。在此假设下，SNP 数量 $D$ 服从均值为 $\\lambda_1$ 的泊松分布，即 $D \\sim \\mathrm{Poisson}(\\lambda_1)$。\n\n泊松分布的均值 $\\lambda$ 由每基因组替换率 $\\mu$ 与总时间分支长度 $L$ 的乘积给出。因此，$\\lambda = \\mu L$。我们必须使用给定的参数计算 $\\lambda_0$ 和 $\\lambda_1$，并确保单位一致。替换率为每年每基因组 $\\mu = 25$ 次替换。我们将所有时间间隔转换为年。一年的天数取为 $365$。\n\n两个病例的采样时间为 $t_{A} = 9$ 天和 $t_{B} = 14$ 天。\n\n在假设 $H_0$（直接传播）下，总分支长度为 $L_{\\mathrm{direct}} = t_{A} + t_{B}$。\n$$L_{\\mathrm{direct}} = (9 + 14) \\text{ days} = 23 \\text{ days}$$\n将其转换为年：\n$$L_{\\mathrm{direct}} = \\frac{23}{365} \\text{ years}$$\n在 $H_0$ 下泊松分布的均值为：\n$$\\lambda_0 = \\mu \\times L_{\\mathrm{direct}} = 25 \\times \\frac{23}{365} = \\frac{575}{365} = \\frac{115}{73}$$\n\n在假设 $H_1$（无关社区）下，总分支长度由公式 $L_{\\mathrm{unrelated}} = 2 T_{c} + \\frac{t_{A} + t_{B}}{365}$ 给出，其中平均合并时间为 $T_c = 0.7$ 年。\n$$L_{\\mathrm{unrelated}} = 2 \\times 0.7 + \\frac{9+14}{365} = 1.4 + \\frac{23}{365} \\text{ years}$$\n在 $H_1$ 下泊松分布的均值为：\n$$\\lambda_1 = \\mu \\times L_{\\mathrm{unrelated}} = 25 \\times \\left(1.4 + \\frac{23}{365}\\right) = 25 \\times 1.4 + 25 \\times \\frac{23}{365}$$\n$$\\lambda_1 = 35 + \\lambda_0 = 35 + \\frac{115}{73} = \\frac{35 \\times 73 + 115}{73} = \\frac{2555 + 115}{73} = \\frac{2670}{73}$$\n\n问题陈述，我们对这两个假设有相等的先验概率（$P(H_0) = P(H_1) = 0.5$）和相等的错分成本。在这种情况下，贝叶斯最优决策规则是选择具有较高后验概率的假设，这可以简化为选择具有较高似然的假设。如果观测到 $D$ 的概率在 $H_0$ 下大于或等于在 $H_1$ 下的概率，我们应将观测值 $D$ 归类为“直接传播”聚类（$H_0$）。决策规则是，如果 $P(D|H_0) \\ge P(D|H_1)$，则选择 $H_0$。\n\n均值为 $\\lambda$ 的泊松随机变量的概率质量函数为 $P(D=k) = \\frac{\\exp(-\\lambda) \\lambda^k}{k!}$。所以，我们的决策规则是：\n$$\\frac{\\exp(-\\lambda_0) \\lambda_0^D}{D!} \\ge \\frac{\\exp(-\\lambda_1) \\lambda_1^D}{D!}$$\n由于 $D!$ 是正数，我们可以消去它。\n$$\\exp(-\\lambda_0) \\lambda_0^D \\ge \\exp(-\\lambda_1) \\lambda_1^D$$\n对两边取自然对数：\n$$-\\lambda_0 + D \\ln(\\lambda_0) \\ge -\\lambda_1 + D \\ln(\\lambda_1)$$\n重新整理各项以求解 $D$：\n$$\\lambda_1 - \\lambda_0 \\ge D \\ln(\\lambda_1) - D \\ln(\\lambda_0)$$\n$$\\lambda_1 - \\lambda_0 \\ge D (\\ln(\\lambda_1) - \\ln(\\lambda_0))$$\n由于 $L_{\\mathrm{unrelated}}  L_{\\mathrm{direct}}$，因此有 $\\lambda_1  \\lambda_0$，所以 $\\ln(\\lambda_1) - \\ln(\\lambda_0)  0$。我们可以用这个项相除而不改变不等号的方向：\n$$D \\le \\frac{\\lambda_1 - \\lambda_0}{\\ln(\\lambda_1) - \\ln(\\lambda_0)}$$\n我们定义临界值 $D_c = \\frac{\\lambda_1 - \\lambda_0}{\\ln(\\lambda_1) - \\ln(\\lambda_0)}$。规则是如果 $D \\le D_c$，则分类为 $H_0$。\n\n问题要求一个整数阈值 $d^*$，使得当 $D \\le d^*$ 时，一对病例被分类为传播关联的聚类。我们将 $D$ 分类为 $H_0$ 的整数值集合是 $\\{0, 1, \\dots, d^*\\}$。这意味着 $d^*$ 必须是满足条件 $d^* \\le D_c$ 的最大整数。因此，最佳整数阈值为 $d^* = \\lfloor D_c \\rfloor$。\n\n现在我们代入 $\\lambda_0$ 和 $\\lambda_1$ 的数值：\n$$\\lambda_0 = \\frac{115}{73} \\approx 1.5753$$\n$$\\lambda_1 = \\frac{2670}{73} \\approx 36.5753$$\n差值为 $\\lambda_1 - \\lambda_0 = 35$。\n比值为 $\\frac{\\lambda_1}{\\lambda_0} = \\frac{2670/73}{115/73} = \\frac{2670}{115} = \\frac{534}{23}$。\n\n我们计算 $D_c$：\n$$D_c = \\frac{\\lambda_1 - \\lambda_0}{\\ln(\\lambda_1/\\lambda_0)} = \\frac{35}{\\ln(534/23)}$$\n使用数值计算：\n$$D_c \\approx \\frac{35}{\\ln(23.21739...)} \\approx \\frac{35}{3.14490...} \\approx 11.1291$$\n最佳整数阈值 $d^*$ 是该值的向下取整：\n$$d^* = \\lfloor D_c \\rfloor = \\lfloor 11.1291 \\rfloor = 11$$\n\n因此，最佳决策边界为 11 个 SNP。如果观测到的 SNP 数量 $D$ 小于或等于 11，则该对病例被分类为直接传播。如果 $D$ 大于 11，则被分类为无关病例。",
            "answer": "$$\\boxed{11}$$"
        },
        {
            "introduction": "现实世界中的基因组流行病学调查很少只依赖单一类型的数据。作为本章的综合练习，你将开发一个计算算法，该算法整合了基因组距离和传统的流行病学接触数据 。通过构建和评估一个聚类工具，你将体验在疫情调查中如何综合多种证据来提高推断的准确性。",
            "id": "4527634",
            "problem": "一个公共卫生团队正在使用基因组序列数据和接触者追踪数据调查病原体暴发中的潜在传播簇。每个病例在图中由一个顶点表示。对于每个测试用例，您将获得一个成对单核苷酸变异（SNV）距离的对称矩阵、一个对称的二元流行病学关联矩阵，以及一个用于评估的真实病例传播簇划分。您的任务是设计、实现并评估一种算法，该算法整合序列相似性和流行病学关联来推断聚类，并量化不相关病例被错误地分到一组的比率。\n\n基本定义和约束：\n- 两个病例之间的单核苷酸变异（SNV）距离是指在可比较的基因组区域内核苷酸差异的数量；将距离矩阵表示为 $D \\in \\mathbb{N}^{n \\times n}$，其中对于所有 $i \\neq j$，$D_{ii} = 0$ 且 $D_{ij} = D_{ji}$。\n- 流行病学关联由一个对称的二元矩阵 $L \\in \\{0,1\\}^{n \\times n}$ 表示，其中 $L_{ii} = 0$ 且 $L_{ij} = L_{ji}$。$L_{ij} = 1$ 的值表示病例 $i$ 和 $j$ 之间存在与潜在传播一致的记录关联。\n- 设 $t_s \\in \\mathbb{N}$ 为严格的SNV阈值，$t_e \\in \\mathbb{N}$ 为流行病学上宽松的SNV阈值，且 $t_s \\leq t_e$。\n\n使用原则：\n- 在基因组流行病学中，紧密相关的基因组（SNV距离小）和佐证的流行病学关联都支持近期传播。通过构建一个包含 $n$ 个顶点的无向图 $G$ 来对此进行建模，顶点 $i$ 和 $j$ 之间存在边的条件是当且仅当：\n  1. $D_{ij} \\leq t_s$，或\n  2. $L_{ij} = 1$ 且 $D_{ij} \\leq t_e$。\n- 将 $G$ 的连通分量推断为聚类。\n\n计算的评估指标：\n- 设真实情况（ground truth）以集合 $\\{0,1,\\dots,n-1\\}$ 的一个划分给出，这会导出一个对称矩阵 $T \\in \\{0,1\\}^{n \\times n}$，其中当且仅当 $i$ 和 $j$ 在同一个真实聚类中且 $i \\neq j$ 时，$T_{ij} = 1$，且 $T_{ii} = 0$。\n- 设 $\\widehat{C}$ 为推断出的聚类。定义推断为阳性的配对集合 $\\mathcal{P} = \\{(i,j) : 0 \\leq i  j \\leq n-1, \\text{ 且 } i,j \\text{ 在 } G \\text{ 的同一个连通分量中}\\}$。\n- 定义真阳性数为 $\\mathrm{TP} = \\sum_{(i,j) \\in \\mathcal{P}} \\mathbf{1}\\{T_{ij} = 1\\}$，假阳性数为 $\\mathrm{FP} = \\sum_{(i,j) \\in \\mathcal{P}} \\mathbf{1}\\{T_{ij} = 0\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n- 定义错误聚类率（以小数表示）为\n$$\n\\mathrm{FCR} =\n\\begin{cases}\n\\dfrac{\\mathrm{FP}}{\\mathrm{TP} + \\mathrm{FP}},  \\text{若 } \\mathrm{TP} + \\mathrm{FP} > 0, \\\\\n0,  \\text{若 } \\mathrm{TP} + \\mathrm{FP} = 0.\n\\end{cases}\n$$\n\n实现一个程序，对于下方的每个测试用例，使用给定的阈值和上述决策规则构建 $G$，并返回错误聚类率。所有输出必须是四舍五入到3位小数的小数。\n\n测试套件：\n- 所有测试用例均使用 $t_s = 2$ 和 $t_e = 5$。\n\n- 测试用例 1 ($n=6$)：\n  - SNV距离\n    $$\n    D =\n    \\begin{bmatrix}\n    0  2  4  8  7  6 \\\\\n    2  0  3  9  8  7 \\\\\n    4  3  0  10  9  8 \\\\\n    8  9  10  0  1  12 \\\\\n    7  8  9  1  0  11 \\\\\n    6  7  8  12  11  0\n    \\end{bmatrix}\n    $$\n  - 流行病学关联\n    $$\n    L =\n    \\begin{bmatrix}\n    0  1  0  0  0  0 \\\\\n    1  0  1  0  0  0 \\\\\n    0  1  0  0  0  0 \\\\\n    0  0  0  0  1  0 \\\\\n    0  0  0  1  0  0 \\\\\n    0  0  0  0  0  0\n    \\end{bmatrix}\n    $$\n  - 真实聚类：$\\{\\{0,1,2\\}, \\{3,4\\}, \\{5\\}\\}$。\n\n- 测试用例 2 ($n=3$)：\n  - SNV距离\n    $$\n    D =\n    \\begin{bmatrix}\n    0  9  9 \\\\\n    9  0  9 \\\\\n    9  9  0\n    \\end{bmatrix}\n    $$\n  - 流行病学关联\n    $$\n    L =\n    \\begin{bmatrix}\n    0  0  0 \\\\\n    0  0  0 \\\\\n    0  0  0\n    \\end{bmatrix}\n    $$\n  - 真实聚类：$\\{\\{0\\}, \\{1\\}, \\{2\\}\\}$。\n\n- 测试用例 3 ($n=5$)：\n  - SNV距离\n    $$\n    D =\n    \\begin{bmatrix}\n    0  2  4  9  10 \\\\\n    2  0  2  8  9 \\\\\n    4  2  0  5  9 \\\\\n    9  8  5  0  2 \\\\\n    10  9  9  2  0\n    \\end{bmatrix}\n    $$\n  - 流行病学关联\n    $$\n    L =\n    \\begin{bmatrix}\n    0  0  0  0  0 \\\\\n    0  0  0  0  0 \\\\\n    0  0  0  1  0 \\\\\n    0  0  1  0  0 \\\\\n    0  0  0  0  0\n    \\end{bmatrix}\n    $$\n  - 真实聚类：$\\{\\{0,1,2\\}, \\{3,4\\}\\}$。\n\n- 测试用例 4 ($n=4$)：\n  - SNV距离\n    $$\n    D =\n    \\begin{bmatrix}\n    0  2  5  6 \\\\\n    2  0  6  5 \\\\\n    5  6  0  5 \\\\\n    6  5  5  0\n    \\end{bmatrix}\n    $$\n  - 流行病学关联\n    $$\n    L =\n    \\begin{bmatrix}\n    0  0  0  0 \\\\\n    0  0  0  0 \\\\\n    0  0  0  1 \\\\\n    0  0  1  0\n    \\end{bmatrix}\n    $$\n  - 真实聚类：$\\{\\{0,1\\}, \\{2,3\\}\\}$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含4个测试用例的错误聚类率，按测试用例1到4的顺序排列，形式为逗号分隔的列表并用方括号括起，每个值四舍五入到3位小数（例如，$[0.123,0.000,0.700,0.250]$）。",
            "solution": "该问题要求通过整合基因组和流行病学数据，来实施并评估一种用于推断病原体传播簇的算法。评估是通过计算相对于所提供的真实情况的错误聚类率（FCR）来进行的。该过程是确定性的，可以分解为三个主要阶段：图构建、聚类识别和指标计算。\n\n设 $n$ 为正在调查的病例数。每个测试用例的输入包括一个对称的单核苷酸变异（SNV）距离矩阵 $D \\in \\mathbb{N}^{n \\times n}$、一个对称的二元流行病学关联矩阵 $L \\in \\{0,1\\}^{n \\times n}$、一个严格的SNV阈值 $t_s$ 和一个宽松的SNV阈值 $t_e$。对于此问题，阈值固定为 $t_s = 2$ 和 $t_e = 5$。\n\n首先，我们为无向图 $G=(V, E)$ 构建一个加权邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$，其中 $V = \\{0, 1, \\dots, n-1\\}$ 代表病例。如果两个不同的病例 $i$ 和 $j$ 根据指定标准被视为相关，则它们之间存在一条边 $(i, j)$。矩阵元素 $A_{ij}$ 定义如下：\n$$\nA_{ij} = \\begin{cases}\n1  \\text{如果 } (D_{ij} \\leq t_s) \\lor (L_{ij} = 1 \\land D_{ij} \\leq t_e) \\\\\n0  \\text{否则}\n\\end{cases}\n$$\n对于所有 $i \\neq j$。对角线元素为 $A_{ii} = 0$。条件 $D_{ij} \\leq t_s$ 仅基于高遗传相似性连接病例，表明传播时间非常近。第二个条件 $L_{ij} = 1 \\land D_{ij} \\leq t_e$ 整合了流行病学证据（$L_{ij} = 1$）和更宽松的遗传距离阈值（$D_{ij} \\leq t_e$），允许在有已知接触的情况下，连接基因组差异稍大的病例。\n\n其次，推断出的传播簇被定义为图 $G$ 的连通分量。连通分量是一个子图，其中任意两个顶点都通过路径相互连接，并且该子图不与超图中的任何其他顶点相连。可以采用广度优先搜索（BFS）或深度优先搜索（DFS）等标准算法从邻接矩阵 $A$ 中找到这些分量。其结果是顶点集 $V$ 的一个划分，该划分由不相交的子集组成，每个子集构成一个推断的聚类。我们将此推断的聚类表示为 $\\widehat{C}$。\n\n第三，我们根据真实聚类来评估推断的聚类 $\\widehat{C}$。评估基于成对关系。我们首先定义推断为阳性的配对集合 $\\mathcal{P}$，作为所有被分到同一推断聚类中的唯一病例对 $(i, j)$（其中 $i  j$）。\n$$\n\\mathcal{P} = \\{(i,j) : 0 \\leq i  j \\leq n-1, \\text{ 且 } i,j \\text{ 在 } G \\text{ 的同一个连通分量中}\\}\n$$\n真实情况以病例的划分为形式给出，这定义了相应的真实矩阵 $T \\in \\{0,1\\}^{n \\times n}$，其中当且仅当病例 $i$ 和 $j$ 属于同一个真实聚类（$i \\neq j$）时，$T_{ij} = 1$。对于每个配对 $(i, j) \\in \\mathcal{P}$，如果它们也处于同一个真实聚类中（$T_{ij} = 1$），我们将其分类为真阳性（TP）；如果不是（$T_{ij} = 0$），则分类为假阳性（FP）。总数计算如下：\n$$\n\\mathrm{TP} = \\sum_{(i,j) \\in \\mathcal{P}} \\mathbf{1}\\{T_{ij} = 1\\}\n$$\n$$\n\\mathrm{FP} = \\sum_{(i,j) \\in \\mathcal{P}} \\mathbf{1}\\{T_{ij} = 0\\}\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n最后，计算错误聚类率（FCR）。该指标表示在所有被算法聚类在一起的配对中，错误聚类的配对所占的比例。公式为：\n$$\n\\mathrm{FCR} =\n\\begin{cases}\n\\dfrac{\\mathrm{FP}}{\\mathrm{TP} + \\mathrm{FP}},  \\text{如果 } \\mathrm{TP} + \\mathrm{FP} > 0 \\\\\n0,  \\text{如果 } \\mathrm{TP} + \\mathrm{FP} = 0\n\\end{cases}\n$$\n如果算法没有将任何配对聚类在一起，则 $\\mathrm{TP} + \\mathrm{FP} = 0$，FCR 为 $0$。\n\n将这整个过程应用于每个测试用例，以计算相应的FCR，然后按要求将其四舍五入到3位小数。`scipy.sparse.csgraph.connected_components` 函数是从邻接矩阵 $A$ 中识别聚类的合适工具。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse.csgraph import connected_components\n\ndef solve():\n    \"\"\"\n    Solves the genomic epidemiology clustering problem for the given test cases.\n    \"\"\"\n    \n    # Define the global thresholds from the problem statement.\n    t_s = 2\n    t_e = 5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"D\": np.array([\n                [0, 2, 4, 8, 7, 6],\n                [2, 0, 3, 9, 8, 7],\n                [4, 3, 0, 10, 9, 8],\n                [8, 9, 10, 0, 1, 12],\n                [7, 8, 9, 1, 0, 11],\n                [6, 7, 8, 12, 11, 0]\n            ]),\n            \"L\": np.array([\n                [0, 1, 0, 0, 0, 0],\n                [1, 0, 1, 0, 0, 0],\n                [0, 1, 0, 0, 0, 0],\n                [0, 0, 0, 0, 1, 0],\n                [0, 0, 0, 1, 0, 0],\n                [0, 0, 0, 0, 0, 0]\n            ]),\n            \"true_clusters\": [{0, 1, 2}, {3, 4}, {5}]\n        },\n        {\n            \"D\": np.array([\n                [0, 9, 9],\n                [9, 0, 9],\n                [9, 9, 0]\n            ]),\n            \"L\": np.array([\n                [0, 0, 0],\n                [0, 0, 0],\n                [0, 0, 0]\n            ]),\n            \"true_clusters\": [{0}, {1}, {2}]\n        },\n        {\n            \"D\": np.array([\n                [0, 2, 4, 9, 10],\n                [2, 0, 2, 8, 9],\n                [4, 2, 0, 5, 9],\n                [9, 8, 5, 0, 2],\n                [10, 9, 9, 2, 0]\n            ]),\n            \"L\": np.array([\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0],\n                [0, 0, 0, 0, 0]\n            ]),\n            \"true_clusters\": [{0, 1, 2}, {3, 4}]\n        },\n        {\n            \"D\": np.array([\n                [0, 2, 5, 6],\n                [2, 0, 6, 5],\n                [5, 6, 0, 5],\n                [6, 5, 5, 0]\n            ]),\n            \"L\": np.array([\n                [0, 0, 0, 0],\n                [0, 0, 0, 0],\n                [0, 0, 0, 1],\n                [0, 0, 1, 0]\n            ]),\n            \"true_clusters\": [{0, 1}, {2, 3}]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        D = case[\"D\"]\n        L = case[\"L\"]\n        true_clusters = case[\"true_clusters\"]\n        n = D.shape[0]\n\n        # 1. Construct the adjacency matrix A for graph G.\n        A = np.zeros((n, n), dtype=int)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (D[i, j] = t_s) or (L[i, j] == 1 and D[i, j] = t_e):\n                    A[i, j] = 1\n                    A[j, i] = 1\n\n        # 2. Infer clusters as connected components of G.\n        n_components, labels = connected_components(csgraph=A, directed=False, return_labels=True)\n\n        # 3. Create a look-up for ground truth pairs.\n        true_pairs = set()\n        for cluster in true_clusters:\n            cluster_nodes = sorted(list(cluster))\n            for i in range(len(cluster_nodes)):\n                for j in range(i + 1, len(cluster_nodes)):\n                    true_pairs.add((cluster_nodes[i], cluster_nodes[j]))\n\n        # 4. Calculate TP and FP based on inferred clusters.\n        tp = 0\n        fp = 0\n        \n        # Iterate through all unique pairs (i, j) with i  j.\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check if the pair is in the same inferred cluster.\n                if labels[i] == labels[j]:\n                    pair = (i, j)\n                    if pair in true_pairs:\n                        tp += 1\n                    else:\n                        fp += 1\n        \n        # 5. Calculate the False Clustering Rate (FCR).\n        denominator = tp + fp\n        if denominator == 0:\n            fcr = 0.0\n        else:\n            fcr = fp / denominator\n        \n        results.append(fcr)\n\n    # Final print statement in the exact required format.\n    # Expected: [0.000, 0.000, 0.600, 0.000]\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}