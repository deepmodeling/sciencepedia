{
    "hands_on_practices": [
        {
            "introduction": "在实施科学中，准确测量是评估任何干预措施成功与否的基石。此练习  介绍了两个核心概念：衡量干预措施是否按计划执行的“保真度” (fidelity)，以及干预措施覆盖了多少目标人群的“渗透率” (penetration)。更重要的是，它引导我们思考一个关键的现实问题：测量误差会如何影响我们对项目成效的判断，并教会我们如何量化这种由不完美数据（如分类系统的灵敏度 $s$ 和特异性 $t$）所引入的系统性偏差 $B$。",
            "id": "4539049",
            "problem": "一个公共卫生部门正在使用粪便免疫化学测试（FIT）实施一项结直肠癌筛查计划。该计划对每位符合条件的患者的标准流程包括四个步骤：$1$）发送外展邀请，$2$）提供FIT试剂盒，$3$）返回FIT试剂盒，$4$）通知实验室结果。忠实度（Fidelity）定义为在所有患者流程中，按协议完成的步骤所占的比例。渗透率（Penetration）定义为真正被筛查的合格患者的比例，如果患者完成了4个步骤中的至少$3$个，则被视为真正被筛查。\n\n对$200$个符合条件的患者流程进行的审计得出了每个患者完成的协议步骤数的以下分布：$90$名患者完成了$4$个步骤，$40$名患者完成了$3$个步骤，$30$名患者完成了$2$个步骤，$20$名患者完成了$1$个步骤，以及$20$名患者完成了$0$个步骤。\n\n用于分类患者是否被筛查的信息系统使用了基于忠实度编码的步骤数据。由于这些忠实度编码步骤中存在测量误差，最终的患者级别筛查分类相对于真实筛查状态具有$s = 0.92$的灵敏度和$t = 0.95$的特异度。仅使用核心定义和概率定律，推导预期观测渗透率$p_{\\text{obs}}$作为真实渗透率$p_{\\text{true}}$、$s$和$t$的函数表达式，并从该表达式中得出预期偏差$B = p_{\\text{obs}} - p_{\\text{true}}$。然后计算：\n- 跨患者流程的总体忠实度$F$，定义为在所有患者流程中按协议完成的步骤所占的比例。\n- 由所述测量误差引起的观测渗透率中的预期偏差$B$。\n\n将$F$和$B$均表示为小数，并将答案四舍五入到四位有效数字。不要使用百分号。",
            "solution": "在尝试解决问题之前，将首先验证问题的科学合理性和一致性。\n\n**步骤1：提取已知条件**\n- 审计的合格患者总数，$N = 200$。\n- 一个患者流程包括$k=4$个步骤。\n- 每位患者完成的步骤数分布：\n    - $n_4 = 90$名患者完成了$4$个步骤。\n    - $n_3 = 40$名患者完成了$3$个步骤。\n    - $n_2 = 30$名患者完成了$2$个步骤。\n    - $n_1 = 20$名患者完成了$1$个步骤。\n    - $n_0 = 20$名患者完成了$0$个步骤。\n- 忠实度（$F$）的定义：在所有患者流程中，按协议完成的协议步骤所占的比例。\n- “真正被筛查”的定义：患者完成了4个步骤中的至少$3$个。\n- 真实渗透率（$p_{\\text{true}}$）的定义：真正被筛查的合格患者的比例。\n- 患者级别筛查分类系统的测量误差参数：\n    - 灵敏度，$s = P(\\text{观测到已筛查} | \\text{真实已筛查}) = 0.92$。\n    - 特异度，$t = P(\\text{观测到未筛查} | \\text{真实未筛查}) = 0.95$。\n- 观测渗透率（$p_{\\text{obs}}$）的定义：$P(\\text{观测到已筛查})$。\n- 偏差（$B$）的定义：$B = p_{\\text{obs}} - p_{\\text{true}}$。\n- 要求输出：\n    1. $p_{\\text{obs}}$作为$p_{\\text{true}}$、$s$和$t$的函数表达式。\n    2. 偏差$B = p_{\\text{obs}} - p_{\\text{true}}$的表达式。\n    3. 总体忠实度$F$的数值。\n    4. 预期偏差$B$的数值。\n- 格式要求：将$F$和$B$表示为四舍五入到四位有效数字的小数。\n\n**步骤2：使用提取的已知条件进行验证**\n对问题陈述根据验证标准进行评估：\n- **科学依据**：该问题设置在实施科学和流行病学的量化框架内。忠实度、渗透率（患病率）、灵敏度和特异度的定义是标准的、无争议的度量。该情景在科学上是合理的。\n- **适定性**：提供了所有必要的数据、定义和约束。患者计数总和（$90 + 40 + 30 + 20 + 20 = 200$）与审计的患者总数（$N=200$）相匹配，表明内部一致。问题明确无歧义，能导向唯一解。\n- **客观性**：问题陈述使用精确、客观、正式的语言，不含主观或有偏见的术语。\n发现该问题没有科学不合理、不完整、矛盾或模棱两可等缺陷。\n\n**步骤3：结论与行动**\n问题有效。将提供完整解答。\n\n**$p_{\\text{obs}}$和$B$的表达式推导**\n\n令$S_T$表示患者真正被筛查的事件，令$S_O$表示患者被分类系统观测为已筛查的事件。问题提供了以下概率：\n- 真实渗透率：$p_{\\text{true}} = P(S_T)$\n- 观测渗透率：$p_{\\text{obs}} = P(S_O)$\n- 灵敏度：$s = P(S_O | S_T) = 0.92$\n- 特异度：$t = P(\\text{not } S_O | \\text{not } S_T) = 0.95$\n\n根据特异度的定义，假阳性概率$P(S_O | \\text{not } S_T)$为：\n$$P(S_O | \\text{not } S_T) = 1 - P(\\text{not } S_O | \\text{not } S_T) = 1 - t$$\n\n使用全概率定律，观测渗透率$p_{\\text{obs}}$可以表示为真实渗透率$p_{\\text{true}}$的函数：\n$$p_{\\text{obs}} = P(S_O) = P(S_O | S_T)P(S_T) + P(S_O | \\text{not } S_T)P(\\text{not } S_T)$$\n代入已知项，并注意到$P(\\text{not } S_T) = 1 - P(S_T) = 1 - p_{\\text{true}}$：\n$$p_{\\text{obs}} = s \\cdot p_{\\text{true}} + (1 - t)(1 - p_{\\text{true}})$$\n这就是$p_{\\text{obs}}$所要求的表达式。\n\n接下来，我们推导偏差的表达式，$B = p_{\\text{obs}} - p_{\\text{true}}$。\n$$B = \\left[ s \\cdot p_{\\text{true}} + (1 - t)(1 - p_{\\text{true}}) \\right] - p_{\\text{true}}$$\n展开各项：\n$$B = s \\cdot p_{\\text{true}} + 1 - p_{\\text{true}} - t + t \\cdot p_{\\text{true}} - p_{\\text{true}}$$\n合并包含$p_{\\text{true}}$的项：\n$$B = (s + t - 2)p_{\\text{true}} + (1 - t)$$\n这就是偏差$B$所要求的表达式。\n\n**忠实度（$F$）和偏差（$B$）的计算**\n\n首先，我们计算总体忠实度$F$。这是在$N=200$个患者流程中完成的所有协议步骤的比例。可能的总步骤数是患者数量乘以每个患者流程的步骤数$k=4$。\n$$\\text{可能的总步骤数} = N \\times k = 200 \\times 4 = 800$$\n完成的总步骤数根据给定的分布计算得出：\n$$\\text{完成的总步骤数} = (90 \\times 4) + (40 \\times 3) + (30 \\times 2) + (20 \\times 1) + (20 \\times 0)$$\n$$\\text{完成的总步骤数} = 360 + 120 + 60 + 20 + 0 = 560$$\n忠实度是完成步骤数与可能步骤数的比率：\n$$F = \\frac{560}{800} = \\frac{56}{80} = \\frac{7}{10} = 0.7$$\n按要求，这表示为四位有效数字，即$F = 0.7000$。\n\n其次，我们计算预期偏差$B$。这需要真实渗透率$p_{\\text{true}}$的值。如果患者完成了$3$或$4$个步骤，则定义为“真正被筛查”。\n真正被筛查的患者数量是完成$3$个步骤的患者数（$n_3$）和完成$4$个步骤的患者数（$n_4$）的总和：\n$$\\text{真正被筛查的患者数} = n_3 + n_4 = 40 + 90 = 130$$\n真实渗透率是这些患者占总数的比例：\n$$p_{\\text{true}} = \\frac{130}{200} = \\frac{13}{20} = 0.65$$\n现在我们使用推导出的偏差公式$B = (s + t - 2)p_{\\text{true}} + (1 - t)$，并代入给定值$s = 0.92$和$t = 0.95$。\n$$B = (0.92 + 0.95 - 2) \\cdot (0.65) + (1 - 0.95)$$\n$$B = (1.87 - 2) \\cdot (0.65) + 0.05$$\n$$B = (-0.13) \\cdot (0.65) + 0.05$$\n$$B = -0.0845 + 0.05$$\n$$B = -0.0345$$\n问题要求将此结果四舍五入到四位有效数字。计算值为精确值。要将$-0.0345$表示为四位有效数字，我们将其写为$-0.03450$。\n\n计算出的值为忠实度$F = 0.7000$和预期偏差$B = -0.03450$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.7000 & -0.03450 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "当我们发现不同诊所或社区在实施同一项预防措施时渗透率存在差异，一个自然而然的问题是：这种差异是源于服务人群的特征不同（如年龄、病史），还是源于项目执行本身的效率或质量不同？此练习  介绍了一种强大的分析工具——Blinder-Oaxaca 分解法，来解答这个问题。通过将渗透率差异分解为“可解释部分”（由人群特征差异导致）和“不可解释部分”（反映项目效果差异），该方法为我们识别实施障碍、促进卫生公平提供了定量的决策依据。",
            "id": "4539048",
            "problem": "您需要实现一个程序，该程序基于预防医学中实施科学的标准定义，计算一项实施结果指标，并对两个诊所进行差异分解。该指标是渗透率（在实施科学术语中称为“触及率”），定义为实际接受服务的合格个体在所有合格个体中所占的比例。您还必须使用源自包含截距项的线性模型的两部分分解法，对诊所层面渗透率的差异进行 Blinder-Oaxaca 分解。\n\n使用的基本原理：\n- 渗透率定义为已筛查个体与合格个体的比率，可视为二元筛查指标的样本均值。设 $Y \\in \\{0,1\\}$ 表示个体是否在高血压筛查活动中接受了筛查。诊所层面的渗透率是 $E[Y]$，通过 $\\frac{\\text{已筛查}}{\\text{合格}}$ 以小数形式估算。\n- 在一个带有截距项的线性概率模型中，对于诊所 $j \\in \\{\\text{A}, \\text{B}\\}$，条件期望近似为 $E[Y_j \\mid X_j] \\approx X_j^\\top \\beta_j$，其中 $X_j$ 是一个经过增广以包含截距项 $1$ 的协变量向量，而 $\\beta_j$ 是该诊所特定的系数向量。对其求期望可得 $E[Y_j] \\approx E[X_j]^\\top \\beta_j$。\n\n您的任务：\n1. 在每个测试用例中，计算全部合格人群的总体渗透率（以小数表示）。\n2. 在每个测试用例中，计算诊所 A 和诊所 B 各自的渗透率（以小数表示）。\n3. 以诊所 B 的系数作为“可解释”部分的参照，根据包含截距项 $X$ 的 Blinder-Oaxaca 两部分分解公式，将诊所 A 和诊所 B 之间的渗透率差异分解为“可解释”和“不可解释”两个部分。需要计算的量如下：\n   - 可解释部分：$(E[X_{\\text{A}}] - E[X_{\\text{B}}])^\\top \\beta_{\\text{B}}$。\n   - 不可解释部分：$E[X_{\\text{A}}]^\\top (\\beta_{\\text{A}} - \\beta_{\\text{B}})$。\n   待分解的诊所层面差异为 $D = E[Y_{\\text{A}}] - E[Y_{\\text{B}}]$，以小数形式表示。\n4. 距离必须以公里为单位处理，但渗透率和分解部分的输出必须是小数（不使用百分号），因为它们是概率，所以没有单位。\n\n程序输入和输出规范：\n- 您不应读取任何输入。请使用下面硬编码的测试套件。\n- 对于每个测试用例，您的程序应按顺序输出一个包含三个浮点数的列表：$[\\text{总体渗透率}, \\text{可解释部分}, \\text{不可解释部分}]$。\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表，并用方括号括起来。列表中的每个元素对应一个测试用例，其本身也是一个列表。例如：$[[p_1,e_1,u_1],[p_2,e_2,u_2],[p_3,e_3,u_3],[p_4,e_4,u_4]]$。\n\n测试套件（每个用例都给出了总数、诊所层面的计数、协变量均值和系数）：\n- 用例 $1$（正常路径；与缩略图场景匹配）：\n  - 总计：合格 $= 12000$，已筛查 $= 7800$。\n  - 诊所 A：合格 $= 6000$，已筛查 $= 4200$。\n  - 诊所 B：合格 $= 6000$，已筛查 $= 3600$。\n  - 协变量均值（诊所 A）：上一年度就诊比例 $= 0.65$，平均出行距离 $= 5$ 公里。\n  - 协变量均值（诊所 B）：上一年度就诊比例 $= 0.55$，平均出行距离 $= 8$ 公里。\n  - 系数（诊所 A）：截距 $= 0.41$，上一年度就诊系数 $= 0.60$，距离系数 $= -0.02$。\n  - 系数（诊所 B）：截距 $= 0.445$，上一年度就诊系数 $= 0.50$，距离系数 $= -0.015$。\n- 用例 $2$（边界情况；诊所相同）：\n  - 总计：合格 $= 10000$，已筛查 $= 6400$。\n  - 诊所 A：合格 $= 5000$，已筛查 $= 3200$。\n  - 诊所 B：合格 $= 5000$，已筛查 $= 3200$。\n  - 协变量均值（诊所 A）：上一年度就诊比例 $= 0.60$，平均出行距离 $= 6$ 公里。\n  - 协变量均值（诊所 B）：上一年度就诊比例 $= 0.60$，平均出行距离 $= 6$ 公里。\n  - 系数（诊所 A）：截距 $= 0.40$，上一年度就诊系数 $= 0.60$，距离系数 $= -0.02$。\n  - 系数（诊所 B）：截距 $= 0.40$，上一年度就诊系数 $= 0.60$，距离系数 $= -0.02$。\n- 用例 $3$（边缘情况；协变量均值相等，系数不同）：\n  - 总计：合格 $= 10000$，已筛查 $= 5800$。\n  - 诊所 A：合格 $= 4000$，已筛查 $= 2800$。\n  - 诊所 B：合格 $= 6000$，已筛查 $= 3000$。\n  - 协变量均值（诊所 A）：上一年度就诊比例 $= 0.60$，平均出行距离 $= 6$ 公里。\n  - 协变量均值（诊所 B）：上一年度就诊比例 $= 0.60$，平均出行距离 $= 6$ 公里。\n  - 系数（诊所 A）：截距 $= 0.46$，上一年度就诊系数 $= 0.60$，距离系数 $= -0.02$。\n  - 系数（诊所 B）：截距 $= 0.38$，上一年度就诊系数 $= 0.30$，距离系数 $= -0.01$。\n- 用例 $4$（边缘情况；协变量均值不同，系数相等）：\n  - 总计：合格 $= 10000$，已筛查 $= 6300$。\n  - 诊所 A：合格 $= 3000$，已筛查 $= 2100$。\n  - 诊所 B：合格 $= 7000$，已筛查 $= 4200$。\n  - 协变量均值（诊所 A）：上一年度就诊比例 $= 0.70$，平均出行距离 $= 4$ 公里。\n  - 协变量均值（诊所 B）：上一年度就诊比例 $= 0.40$，平均出行距离 $= 9$ 公里。\n  - 系数（诊所 A）：截距 $= 0.78$，上一年度就诊系数 $= 0.00$，距离系数 $= -0.02$。\n  - 系数（诊所 B）：截距 $= 0.78$，上一年度就诊系数 $= 0.00$，距离系数 $= -0.02$。\n\n实现说明：\n- 将每个诊所的协变量向量视为 $E[X_j] = [1, \\text{上一年度就诊均值}, \\text{距离均值(公里)}]^\\top$。\n- 将系数向量视为 $\\beta_j = [\\text{截距}, \\text{上一年度就诊系数}, \\text{距离系数}]^\\top$。\n- 对每个用例，生成对应的结果列表 $[\\text{总体渗透率}, \\text{可解释部分}, \\text{不可解释部分}]$，并将所有用例的结果聚合到一个列表中，按规定格式单行打印。",
            "solution": "该问题是有效的。这是一个提法明确、有科学依据且客观的任务，植根于实施科学和计量经济学的定量方法。所有必要的数据和公式均已提供，且不存在内部矛盾或含糊不清之处。\n\n解决方案要求计算实施结果指标——渗透率，并使用 Blinder-Oaxaca 方法分解两个诊所之间该指标的差异。解决此问题的方法是首先定义其原理，然后详细阐述算法实现。\n\n**1. 科学原理**\n\n**渗透率指标**：渗透率，在实施科学中也称为触及率（reach），量化了目标人群接触到某项干预措施的程度。对于给定的人群，它定义为接受服务的个体数量（$N_{\\text{已筛查}}$）与有资格接受服务的个体总数（$N_{\\text{合格}}$）之比。\n$$\nP = \\frac{N_{\\text{已筛查}}}{N_{\\text{合格}}}\n$$\n这可以解释为二元指示变量 $Y \\in \\{0, 1\\}$ 的样本均值，其中如果个体接受筛查，则 $Y=1$，否则 $Y=0$。人群层面的渗透率是其期望值 $E[Y]$。\n\n**线性概率模型 (LPM)**：为了分析影响渗透率的因素，我们采用线性概率模型。对于诊所 $j \\in \\{\\text{A}, \\text{B}\\}$，在给定一组协变量 $X_j$ 的条件下，个体被筛查的概率可以通过一个线性函数来近似：\n$$\nE[Y_j \\mid X_j] \\approx X_j^\\top \\beta_j\n$$\n此处，$X_j$ 是个体协变量的列向量（为表示截距项而增广了常数 $1$），$\\beta_j$ 是特定于该诊所的系数列向量。根据全期望定律，通过对协变量的分布求期望，可以近似得到无条件的诊所层面渗透率：\n$$\nE[Y_j] = E[E[Y_j \\mid X_j]] \\approx E[X_j^\\top \\beta_j] = E[X_j]^\\top \\beta_j\n$$\n其中 $E[X_j]$ 是诊所 $j$ 合格人群的平均协变量值向量。\n\n**Blinder-Oaxaca 分解**：此方法用于分解两组之间结果的差异。诊所 A 和诊所 B 之间渗透率的总差异为 $D = E[Y_{\\text{A}}] - E[Y_{\\text{B}}]$。使用 LPM 近似，可得：\n$$\nD \\approx E[X_{\\text{A}}]^\\top \\beta_{\\text{A}} - E[X_{\\text{B}}]^\\top \\beta_{\\text{B}}\n$$\n为分解此差异，我们加上再减去一个反事实项。以诊所 B 的系数 $\\beta_{\\text{B}}$ 为参照结构，我们加上并减去 $E[X_{\\text{A}}]^\\top \\beta_{\\text{B}}$：\n$$\nD \\approx (E[X_{\\text{A}}]^\\top \\beta_{\\text{A}} - E[X_{\\text{A}}]^\\top \\beta_{\\text{B}}) + (E[X_{\\text{A}}]^\\top \\beta_{\\text{B}} - E[X_{\\text{B}}]^\\top \\beta_{\\text{B}})\n$$\n这将总差异 $D$ 分为两个部分：\n1.  **可解释部分**：这部分差异可归因于两个诊所之间人群特征（协变量）的差异，并以诊所 B 的“回报率”（系数）进行度量。\n    $$\n    \\text{可解释部分} = (E[X_{\\text{A}}] - E[X_{\\text{B}}])^\\top \\beta_{\\text{B}}\n    $$\n2.  **不可解释部分**：这部分差异可归因于对于诊所 A 的人群，两个诊所之间给定特征的效果（系数）存在差异。这通常被解释为由未观察到的因素或差异化对待（即，系统有效性的差异）所导致的差异。\n    $$\n    \\text{不可解释部分} = E[X_{\\text{A}}]^\\top (\\beta_{\\text{A}} - \\beta_{\\text{B}})\n    $$\n这两个部分的总和约等于模型预测结果的总差异。\n\n**2. 算法设计与计算**\n\n提供的测试套件为四个不同的用例提供了执行这些计算所需的所有数据。每个用例的处理过程如下：\n\n首先，通过将两个诊所已筛查的总人数除以合格的总人数，计算整个人群的总体渗透率。\n\n其次，为了进行分解，为每个诊所构建所需的向量。根据规定，诊所 $j$ 的平均协变量向量为 $E[X_j] = [1, \\text{上一年度就诊均值}_j, \\text{距离均值(公里)}_j]^\\top$，系数向量为 $\\beta_j = [\\text{截距}_j, \\text{就诊系数}_j, \\text{距离系数}_j]^\\top$。\n\n第三，应用 Blinder-Oaxaca 公式，使用向量代数，特别是点积运算。计算过程如下：\n- $\\text{可解释部分} = (E[X_A] - E[X_B]) \\cdot \\beta_B$\n- $\\text{不可解释部分} = E[X_A] \\cdot (\\beta_A - \\beta_B)$\n\n将此完整流程系统地应用于每个测试用例。让我们以用例 1 为例进行演示：\n\n- **给定数据**：\n  - 总计：$N_{\\text{合格,总计}} = 12000$，$N_{\\text{已筛查,总计}} = 7800$。\n  - 诊所 A：$E[X_{\\text{A}}] = [1, 0.65, 5]^\\top$，$\\beta_{\\text{A}} = [0.41, 0.60, -0.02]^\\top$。\n  - 诊所 B：$E[X_{\\text{B}}] = [1, 0.55, 8]^\\top$，$\\beta_{\\text{B}} = [0.445, 0.50, -0.015]^\\top$。\n\n- **计算过程**：\n  1.  **总体渗透率**：\n      $$\n      P_{\\text{总体}} = \\frac{7800}{12000} = 0.65\n      $$\n  2.  **向量差**：\n      $$\n      E[X_{\\text{A}}] - E[X_{\\text{B}}] = [1-1, 0.65-0.55, 5-8]^\\top = [0, 0.1, -3]^\\top\n      $$\n      $$\n      \\beta_{\\text{A}} - \\beta_{\\text{B}} = [0.41-0.445, 0.60-0.50, -0.02 - (-0.015)]^\\top = [-0.035, 0.1, -0.005]^\\top\n      $$\n  3.  **分解部分**：\n      - **可解释部分**：\n        $$\n        \\text{可解释部分} = [0, 0.1, -3] \\cdot [0.445, 0.50, -0.015]^\\top = (0)(0.445) + (0.1)(0.50) + (-3)(-0.015) = 0 + 0.05 + 0.045 = 0.095\n        $$\n      - **不可解释部分**：\n        $$\n        \\text{不可解释部分} = [1, 0.65, 5] \\cdot [-0.035, 0.1, -0.005]^\\top = (1)(-0.035) + (0.65)(0.1) + (5)(-0.005) = -0.035 + 0.065 - 0.025 = 0.005\n        $$\n\n用例 1 的最终结果是一个包含这三个值的列表：$[0.65, 0.095, 0.005]$。对所有测试用例重复此过程以生成最终输出。该实现将利用 `numpy` 库来进行高效且可读的向量运算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes overall penetration and Blinder-Oaxaca decomposition components\n    for a series of test cases related to a preventive medicine initiative.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"totals\": {\"eligible\": 12000, \"screened\": 7800},\n            \"A\": {\n                \"means\": {\"visit_prop\": 0.65, \"distance\": 5},\n                \"coeffs\": {\"intercept\": 0.41, \"visit\": 0.60, \"distance\": -0.02},\n            },\n            \"B\": {\n                \"means\": {\"visit_prop\": 0.55, \"distance\": 8},\n                \"coeffs\": {\"intercept\": 0.445, \"visit\": 0.50, \"distance\": -0.015},\n            },\n        },\n        {\n            \"name\": \"Case 2\",\n            \"totals\": {\"eligible\": 10000, \"screened\": 6400},\n            \"A\": {\n                \"means\": {\"visit_prop\": 0.60, \"distance\": 6},\n                \"coeffs\": {\"intercept\": 0.40, \"visit\": 0.60, \"distance\": -0.02},\n            },\n            \"B\": {\n                \"means\": {\"visit_prop\": 0.60, \"distance\": 6},\n                \"coeffs\": {\"intercept\": 0.40, \"visit\": 0.60, \"distance\": -0.02},\n            },\n        },\n        {\n            \"name\": \"Case 3\",\n            \"totals\": {\"eligible\": 10000, \"screened\": 5800},\n            \"A\": {\n                \"means\": {\"visit_prop\": 0.60, \"distance\": 6},\n                \"coeffs\": {\"intercept\": 0.46, \"visit\": 0.60, \"distance\": -0.02},\n            },\n            \"B\": {\n                \"means\": {\"visit_prop\": 0.60, \"distance\": 6},\n                \"coeffs\": {\"intercept\": 0.38, \"visit\": 0.30, \"distance\": -0.01},\n            },\n        },\n        {\n            \"name\": \"Case 4\",\n            \"totals\": {\"eligible\": 10000, \"screened\": 6300},\n            \"A\": {\n                \"means\": {\"visit_prop\": 0.70, \"distance\": 4},\n                \"coeffs\": {\"intercept\": 0.78, \"visit\": 0.00, \"distance\": -0.02},\n            },\n            \"B\": {\n                \"means\": {\"visit_prop\": 0.40, \"distance\": 9},\n                \"coeffs\": {\"intercept\": 0.78, \"visit\": 0.00, \"distance\": -0.02},\n            },\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Task 1: Compute overall penetration\n        overall_penetration = case[\"totals\"][\"screened\"] / case[\"totals\"][\"eligible\"]\n\n        # Prepare vectors for decomposition\n        # E[X_j] = [1, prior_annual_visit_mean, distance_km_mean]\n        E_X_A = np.array([1, case[\"A\"][\"means\"][\"visit_prop\"], case[\"A\"][\"means\"][\"distance\"]])\n        E_X_B = np.array([1, case[\"B\"][\"means\"][\"visit_prop\"], case[\"B\"][\"means\"][\"distance\"]])\n        \n        # beta_j = [intercept, prior_annual_visit_coef, distance_coef]\n        beta_A = np.array([case[\"A\"][\"coeffs\"][\"intercept\"], case[\"A\"][\"coeffs\"][\"visit\"], case[\"A\"][\"coeffs\"][\"distance\"]])\n        beta_B = np.array([case[\"B\"][\"coeffs\"][\"intercept\"], case[\"B\"][\"coeffs\"][\"visit\"], case[\"B\"][\"coeffs\"][\"distance\"]])\n\n        # Task 3: Perform Blinder-Oaxaca decomposition\n        # Explained component: (E[X_A] - E[X_B])' * beta_B\n        explained = np.dot(E_X_A - E_X_B, beta_B)\n        \n        # Unexplained component: E[X_A]' * (beta_A - beta_B)\n        unexplained = np.dot(E_X_A, beta_A - beta_B)\n\n        # Append the list of results for the current case\n        all_results.append([overall_penetration, explained, unexplained])\n\n    # Final print statement in the exact required format\n    # The default string representation of a list is the desired format for each sub-list.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "要评估一项新的实施策略（例如媒体宣传活动）是否真正有效，简单地比较干预前后的结果可能具有误导性，因为它忽略了可能已经存在的长期趋势。此练习  介绍了一种更为严谨的准实验研究设计——中断时间序列分析 (Interrupted Time Series, ITS)。通过构建分段回归模型，ITS 能够帮助我们量化干预措施带来的即时水平变化 $\\beta_2$ 和长期趋势斜率变化 $\\beta_3$，从而在控制了原有趋势的情况下，更准确地推断实施策略的因果效应。",
            "id": "4539045",
            "problem": "您正在预防医学中的实施科学背景下，分析一个关于青少年疫苗接种率的中断时间序列。针对单次干预的中断时间序列的经典分段回归模型，基于月度观测数据定义如下。设 $y_t$ 表示第 $t$ 个月的疫苗接种率（一个介于 $0$ 和 $1$ 之间的小数），设 $t \\in \\{1,2,\\dots,N\\}$ 为时间索引，其中 $N=48$。干预（一次媒体宣传活动）发生在第 24 个月之后（因此，干预前为 $t \\le 24$ 的月份，干预后为 $t \\ge 25$ 的月份）。定义 $I_t$ 为干预后的二元指示变量，当 $t \\le 24$ 时 $I_t=0$，当 $t \\ge 25$ 时 $I_t=1$。定义 $A_t$ 为干预后的时间，当 $t \\le 24$ 时 $A_t=0$，当 $t \\ge 25$ 时 $A_t=t-24$。该分段线性模型为\n$$\ny_t = \\beta_0 + \\beta_1 t + \\beta_2 I_t + \\beta_3 A_t + \\varepsilon_t,\n$$\n其中 $\\varepsilon_t$ 是可能表现出自相关的误差项。在此模型中，$\\beta_2$ 代表干预发生时的即时水平变化，而 $\\beta_3$ 代表干预后的斜率变化。您必须通过普通最小二乘法估计 $\\beta_2$ 和 $\\beta_3$，并使用 Durbin–Watson 统计量评估自相关性。\n\n从普通最小二乘法（最小化残差平方和）和 Durbin–Watson 统计量的定义出发。使用 $t$、$I_t$ 和 $A_t$ 的定义构建设计矩阵，并使用标准线性代数求解系数向量。计算残差，然后计算 Durbin–Watson 统计量\n$$\n\\mathrm{DW} = \\frac{\\sum_{t=2}^N \\left(\\hat{\\varepsilon}_t - \\hat{\\varepsilon}_{t-1}\\right)^2}{\\sum_{t=1}^N \\hat{\\varepsilon}_t^2},\n$$\n其中 $\\hat{\\varepsilon}_t$ 是拟合模型的残差。使用以下经验法则对 Durbin–Watson 统计量进行解释分类：如果 $\\mathrm{DW}  1.5$，则视为存在正自相关的证据，编码为 $1$；如果 $1.5 \\le \\mathrm{DW} \\le 2.5$，则视为无自相关，编码为 $0$；如果 $\\mathrm{DW} > 2.5$，则视为存在负自相关的证据，编码为 $-1$。\n\n所有疫苗接种率均为无单位的小数。将最终估计的系数 $\\beta_2$ 和 $\\beta_3$ 表示为小数（对于 $\\beta_3$，单位是“分数/月”），Durbin–Watson 统计量是无单位的。程序必须将 $\\beta_2$、$\\beta_3$ 和 $\\mathrm{DW}$ 四舍五入到 $6$ 位小数。\n\n测试套件。为了保证可复现性和科学真实性，月度疫苗接种率 $y_t$ 是使用以下分段基线结构和指定的噪声序列，从基础参数确定性地生成的。设 $b_0$ 表示第 1 个月的干预前基线水平，设 $m_1$ 表示干预前斜率（分数/月），设 $\\Delta$ 表示干预时的即时水平变化，设 $\\delta_m$ 表示干预后的斜率变化。定义无噪声基线轨迹为\n$$\ny_t^{\\mathrm{base}} =\n\\begin{cases}\nb_0 + m_1 (t-1),  \\text{for } 1 \\le t \\le 24,\\\\\nb_0 + m_1 \\cdot 24 + \\Delta + (m_1 + \\delta_m)(t-25),  \\text{for } 25 \\le t \\le 48.\n\\end{cases}\n$$\n观测率 $y_t = y_t^{\\mathrm{base}} + s_t$，其中 $s_t$ 是一个确定性噪声序列，其定义如下方每个测试用例所述。所有参数的选择都旨在使 $y_t$ 保持在 $[0,1]$ 区间内，并对青少年疫苗接种率而言是合理的。\n\n为以下 4 个测试用例提供估计值（每个用例都使用 $N=48$ 个月，其中 24 个月为干预前，24 个月为干预后）：\n\n- 测试用例 1（具有正自相关的一般“理想路径”）：\n  - 基线参数：$b_0 = 0.40$, $m_1 = 0.002$, $\\Delta = 0.10$, $\\delta_m = 0.001$。\n  - 噪声序列（带有常数创新的自回归）：$s_1 = 0$，对于 $t \\ge 2$，$s_t = \\phi s_{t-1} + c$，其中 $\\phi = 0.8$ 且 $c = 0.005$。\n\n- 测试用例 2（纯水平变化，交替引起负自相关）：\n  - 基线参数：$b_0 = 0.55$, $m_1 = 0.000$, $\\Delta = 0.05$, $\\delta_m = 0.000$。\n  - 噪声序列（交替符号）：$s_t = a(-1)^t$，其中 $a = 0.01$。\n\n- 测试用例 3（斜率下降，通过短周期实现接近无自相关）：\n  - 基线参数：$b_0 = 0.30$, $m_1 = 0.004$, $\\Delta = 0.00$, $\\delta_m = -0.003$。\n  - 噪声序列（长度为 4 的周期）：设模式为 $\\{0.0, a, -a, 0.0\\}$，其中 $a = 0.005$，对 $t=1$ 到 $48$ 重复。\n\n- 测试用例 4（无干预效果，通过短周期实现接近无自相关）：\n  - 基线参数：$b_0 = 0.35$, $m_1 = 0.001$, $\\Delta = 0.00$, $\\delta_m = 0.00$。\n  - 噪声序列（长度为 5 的周期）：设模式为 $\\{a, -a, a/2, -a/2, 0.0\\}$，其中 $a = 0.002$，对 $t=1$ 到 $48$ 重复。\n\n您的程序必须：\n- 使用上述定义为每个测试用例构建 $y_t$。\n- 使用普通最小二乘法拟合分段回归，从模型 $y_t = \\beta_0 + \\beta_1 t + \\beta_2 I_t + \\beta_3 A_t + \\varepsilon_t$ 中估计 $\\hat{\\beta}_2$ 和 $\\hat{\\beta}_3$。\n- 使用残差计算 Durbin–Watson 统计量 $\\mathrm{DW}$。\n- 使用经验法则对自相关进行分类，并编码为 $1$（正）、$0$（无）或 $-1$（负）。\n\n输出规格：\n- 对于每个测试用例，输出一个列表，其中包含四舍五入后的估计值 $\\hat{\\beta}_2$、$\\hat{\\beta}_3$、四舍五入后的 $\\mathrm{DW}$ 值以及自相关代码（整数）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身也是一个用方括号括起来的逗号分隔列表，顺序为 $[\\hat{\\beta}_2,\\hat{\\beta}_3,\\mathrm{DW},\\text{code}]$。例如，总体输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。",
            "solution": "问题陈述经评估有效。它在科学上基于时间序列分析和计量经济学的既定原则，特别是使用分段回归的中断时间序列（ITS）分析。问题是良定的，提供了所有必要的数据、定义和明确的目标。语言客观，没有歧义。任务是为四个确定性的测试用例估计给定回归模型的特定参数，并计算一个标准的诊断统计量。\n\n第 $t$ 个月青少年疫苗接种率 $y_t$ 的模型是分段线性回归模型：\n$$\ny_t = \\beta_0 + \\beta_1 t + \\beta_2 I_t + \\beta_3 A_t + \\varepsilon_t\n$$\n其中 $t \\in \\{1, 2, \\dots, N\\}$ 且 $N=48$。干预发生在第 $t=24$ 个月之后。变量定义如下：\n- $I_t$: 一个指示变量，当 $t \\le 24$ 时 $I_t=0$，当 $t \\ge 25$ 时 $I_t=1$。\n- $A_t$: 干预后的时间计数器，当 $t \\le 24$ 时 $A_t=0$，当 $t \\ge 25$ 时 $A_t=t-24$。\n- $\\varepsilon_t$: 时间 $t$ 的误差项。\n\n我们感兴趣的参数是 $\\beta_2$（代表干预后的即时水平变化）和 $\\beta_3$（代表干预后趋势斜率的变化）。这些参数将使用普通最小二乘法（OLS）进行估计。\n\n用矩阵表示法，该模型表示为 $\\boldsymbol{y} = \\boldsymbol{X}\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}$，其中：\n- $\\boldsymbol{y}$ 是观测值的 $N \\times 1$ 向量 $[y_1, y_2, \\dots, y_N]^T$。\n- $\\boldsymbol{X}$ 是 $N \\times 4$ 的设计矩阵。\n- $\\boldsymbol{\\beta}$ 是系数的 $4 \\times 1$ 向量 $[\\beta_0, \\beta_1, \\beta_2, \\beta_3]^T$。\n- $\\boldsymbol{\\varepsilon}$ 是误差的 $N \\times 1$ 向量 $[\\varepsilon_1, \\varepsilon_2, \\dots, \\varepsilon_N]^T$。\n\n对于 $N=48$，设计矩阵 $\\boldsymbol{X}$ 按列构建：\n- 第 1 列（对应 $\\beta_0$）：长度为 48 的全 1 向量。\n- 第 2 列（对应 $\\beta_1$）：时间向量 $\\boldsymbol{t} = [1, 2, \\dots, 48]^T$。\n- 第 3 列（对应 $\\beta_2$）：指示向量 $\\boldsymbol{I} = [0, \\dots, 0, 1, \\dots, 1]^T$，包含 24 个 0，后面跟着 24 个 1。\n- 第 4 列（对应 $\\beta_3$）：干预后时间向量 $\\boldsymbol{A} = [0, \\dots, 0, 1, 2, \\dots, 24]^T$，包含 24 个 0，后面跟着序列 1 到 24。\n\nOLS 估计量 $\\hat{\\boldsymbol{\\beta}}$ 是使残差平方和 $\\mathrm{SSR} = \\sum_{t=1}^N \\hat{\\varepsilon}_t^2 = \\hat{\\boldsymbol{\\varepsilon}}^T \\hat{\\boldsymbol{\\varepsilon}} = (\\boldsymbol{y} - \\boldsymbol{X}\\boldsymbol{\\beta})^T(\\boldsymbol{y} - \\boldsymbol{X}\\boldsymbol{\\beta})$ 最小化的向量。此最小化问题的解通过求解正规方程得到：\n$$\n(\\boldsymbol{X}^T\\boldsymbol{X})\\hat{\\boldsymbol{\\beta}} = \\boldsymbol{X}^T\\boldsymbol{y}\n$$\n只要矩阵 $\\boldsymbol{X}^T\\boldsymbol{X}$ 是可逆的（即 $\\boldsymbol{X}$ 的列是线性无关的），唯一的 OLS 估计量为：\n$$\n\\hat{\\boldsymbol{\\beta}} = (\\boldsymbol{X}^T\\boldsymbol{X})^{-1}\\boldsymbol{X}^T\\boldsymbol{y}\n$$\n从得到的向量 $\\hat{\\boldsymbol{\\beta}} = [\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2, \\hat{\\beta}_3]^T$ 中，我们提取估计值 $\\hat{\\beta}_2$ 和 $\\hat{\\beta}_3$。\n\n对于每个测试用例，必须首先构建观测向量 $\\boldsymbol{y}$。数据 $y_t$ 由 $y_t = y_t^{\\mathrm{base}} + s_t$ 生成。基线轨迹 $y_t^{\\mathrm{base}}$ 由一个分段函数给出：\n$$\ny_t^{\\mathrm{base}} =\n\\begin{cases}\nb_0 + m_1 (t-1),  \\text{for } 1 \\le t \\le 24 \\\\\nb_0 + m_1 \\cdot 24 + \\Delta + (m_1 + \\delta_m)(t-25),  \\text{for } 25 \\le t \\le 48\n\\end{cases}\n$$\n确定性噪声序列 $s_t$ 是为每个测试用例指定的。\n\n在获得估计值 $\\hat{\\boldsymbol{\\beta}}$ 后，残差向量计算为 $\\hat{\\boldsymbol{\\varepsilon}} = \\boldsymbol{y} - \\boldsymbol{X}\\hat{\\boldsymbol{\\beta}}$。\n\n然后计算 Durbin–Watson 统计量 $\\mathrm{DW}$，以评估残差中的一阶自相关：\n$$\n\\mathrm{DW} = \\frac{\\sum_{t=2}^N \\left(\\hat{\\varepsilon}_t - \\hat{\\varepsilon}_{t-1}\\right)^2}{\\sum_{t=1}^N \\hat{\\varepsilon}_t^2}\n$$\n$\\mathrm{DW}$ 的值根据提供的规则进行分类：\n- 正自相关（代码 $1$）：$\\mathrm{DW}  1.5$\n- 无自相关（代码 $0$）：$1.5 \\le \\mathrm{DW} \\le 2.5$\n- 负自相关（代码 $-1$）：$\\mathrm{DW} > 2.5$\n\n流程如下：\n1.  对于每个测试用例，定义参数 $b_0$、$m_1$、$\\Delta$ 和 $\\delta_m$，以及噪声序列 $s_t$ 的规则。\n2.  构建从 1 到 48 的时间向量 $\\boldsymbol{t}$。\n3.  首先计算所有 $t$ 的 $y_t^{\\mathrm{base}}$ 和 $s_t$，然后将它们相加，从而构建观测向量 $\\boldsymbol{y}$。\n4.  构建 $48 \\times 4$ 的设计矩阵 $\\boldsymbol{X}$。\n5.  使用 $\\hat{\\boldsymbol{\\beta}} = (\\boldsymbol{X}^T\\boldsymbol{X})^{-1}\\boldsymbol{X}^T\\boldsymbol{y}$ 计算 OLS 系数估计值。\n6.  从 $\\hat{\\boldsymbol{\\beta}}$ 向量中提取 $\\hat{\\beta}_2$ 和 $\\hat{\\beta}_3$。\n7.  计算残差 $\\hat{\\varepsilon}_t = y_t - (\\hat{\\beta}_0 + \\hat{\\beta}_1 t + \\hat{\\beta}_2 I_t + \\hat{\\beta}_3 A_t)$。\n8.  从残差中计算 $\\mathrm{DW}$ 统计量。\n9.  对 $\\mathrm{DW}$ 统计量进行分类以获得自相关代码。\n10. 将 $\\hat{\\beta}_2$、$\\hat{\\beta}_3$ 和 $\\mathrm{DW}$ 四舍五入到 6 位小数，并组装最终的输出列表。\n\n对所有四个测试用例重复此整个过程。实现将利用数值线性代数函数来执行矩阵运算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the interrupted time series problem for four test cases.\n    \"\"\"\n    \n    # Test cases defined by the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"b0\": 0.40, \"m1\": 0.002, \"Delta\": 0.10, \"delta_m\": 0.001,\n            \"noise_type\": \"ar1\", \"noise_params\": {\"phi\": 0.8, \"c\": 0.005}\n        },\n        {\n            \"name\": \"Case 2\",\n            \"b0\": 0.55, \"m1\": 0.000, \"Delta\": 0.05, \"delta_m\": 0.000,\n            \"noise_type\": \"alternating\", \"noise_params\": {\"a\": 0.01}\n        },\n        {\n            \"name\": \"Case 3\",\n            \"b0\": 0.30, \"m1\": 0.004, \"Delta\": 0.00, \"delta_m\": -0.003,\n            \"noise_type\": \"cycle\", \"noise_params\": {\"pattern\": [0.0, 0.005, -0.005, 0.0]}\n        },\n        {\n            \"name\": \"Case 4\",\n            \"b0\": 0.35, \"m1\": 0.001, \"Delta\": 0.00, \"delta_m\": 0.00,\n            \"noise_type\": \"cycle\", \"noise_params\": {\"pattern\": [0.002, -0.002, 0.001, -0.001, 0.0]}\n        }\n    ]\n\n    N = 48\n    intervention_point = 24\n    \n    # Construct the design matrix X, which is constant across test cases.\n    t = np.arange(1, N + 1)\n    I_t = (t > intervention_point).astype(float)\n    A_t = np.maximum(0, t - intervention_point)\n    \n    X = np.column_stack([np.ones(N), t, I_t, A_t])\n    \n    all_results = []\n\n    for case in test_cases:\n        # Step 1: Generate the observation vector y\n        \n        # Generate baseline trajectory y_base\n        y_base = np.zeros(N)\n        # Pre-intervention part (t = 24)\n        pre_mask = t = intervention_point\n        t_pre = t[pre_mask]\n        y_base[pre_mask] = case[\"b0\"] + case[\"m1\"] * (t_pre - 1)\n        # Post-intervention part (t >= 25)\n        post_mask = t > intervention_point\n        t_post = t[post_mask]\n        y_base[post_mask] = (case[\"b0\"] + case[\"m1\"] * intervention_point + case[\"Delta\"] + \n                             (case[\"m1\"] + case[\"delta_m\"]) * (t_post - (intervention_point + 1)))\n\n        # Generate noise sequence s_t\n        s_t = np.zeros(N)\n        if case[\"noise_type\"] == \"ar1\":\n            params = case[\"noise_params\"]\n            s_t[0] = 0.0\n            for i in range(1, N):\n                s_t[i] = params[\"phi\"] * s_t[i-1] + params[\"c\"]\n        elif case[\"noise_type\"] == \"alternating\":\n            params = case[\"noise_params\"]\n            s_t = params[\"a\"] * ((-1)**t)\n        elif case[\"noise_type\"] == \"cycle\":\n            params = case[\"noise_params\"]\n            pattern = params[\"pattern\"]\n            num_repeats = int(np.ceil(N / len(pattern)))\n            s_t = np.tile(pattern, num_repeats)[:N]\n            \n        y = y_base + s_t\n\n        # Step 2: Estimate coefficients using OLS\n        # beta_hat = (X^T * X)^-1 * X^T * y\n        try:\n            XTX_inv = np.linalg.inv(X.T @ X)\n            beta_hat = XTX_inv @ X.T @ y\n        except np.linalg.LinAlgError:\n            # This should not happen with the given X matrix\n            # but is good practice.\n            all_results.append([\"Error\", \"Error\", \"Error\", \"Error\"])\n            continue\n\n        beta2_hat = beta_hat[2]\n        beta3_hat = beta_hat[3]\n\n        # Step 3: Compute residuals\n        residuals = y - X @ beta_hat\n\n        # Step 4: Compute Durbin-Watson statistic\n        numerator = np.sum(np.diff(residuals)**2)\n        denominator = np.sum(residuals**2)\n        dw_statistic = numerator / denominator if denominator != 0 else 0\n\n        # Step 5: Classify autocorrelation\n        if dw_statistic  1.5:\n            autocorr_code = 1\n        elif 1.5 = dw_statistic = 2.5:\n            autocorr_code = 0\n        else:\n            autocorr_code = -1\n            \n        # Step 6: Round and store results\n        res = [\n            round(beta2_hat, 6),\n            round(beta3_hat, 6),\n            round(dw_statistic, 6),\n            autocorr_code\n        ]\n        all_results.append(res)\n        \n    # Final print statement in the exact required format.\n    result_str = \",\".join([f\"[{','.join(map(str, r))}]\" for r in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}