{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，通过模拟来建立直观理解是掌握孟德尔随机化（MR）精髓的有效方法。本练习将指导你通过编写代码，亲手验证MR研究的核心优势：即使在存在未测量混杂因素的情况下，只要工具变量的核心假设成立，MR仍能提供对因果效应的无偏估计。通过模拟有效和无效工具变量（例如，弱工具变量或违反排他性限制的变量）的场景，你将深刻理解MR分析的稳健性及其前提条件 。",
            "id": "2404055",
            "problem": "实现一个完全确定性的模拟，以在核心工具变量假设下，评估孟德尔随机化（MR）因果效应估计量的无偏性。考虑一个数据生成过程，该过程包含一个双等位基因遗传工具、一个未测量的混杂因素、一个连续暴露和一个连续结局。令 $G$ 表示遗传工具，$U$ 表示未测量的混杂因素，$X$ 表示暴露，$Y$ 表示结局。假设存在以下带有加性噪声的线性结构方程：\n$$\nX \\;=\\; \\pi \\, G \\;+\\; \\gamma \\, U \\;+\\; \\varepsilon_X,\n$$\n$$\nY \\;=\\; \\beta \\, X \\;+\\; \\delta \\, U \\;+\\; \\alpha \\, G \\;+\\; \\varepsilon_Y,\n$$\n其中 $G \\sim \\text{Binomial}(2,p)$，$U \\sim \\mathcal{N}(0,1)$，$\\varepsilon_X \\sim \\mathcal{N}(0,\\sigma_X^2)$，以及 $\\varepsilon_Y \\sim \\mathcal{N}(0,\\sigma_Y^2)$。除了由结构方程引出的关系外，所有随机变量都是相互独立的。在给定的模拟情景中，参数 $\\pi$、$\\gamma$、$\\delta$、$\\alpha$、$\\beta$、$p$、$\\sigma_X$ 和 $\\sigma_Y$ 均为固定常数。\n\n孟德尔随机化假设如下：\n- 相关性：$G$ 与 $X$ 相关，对应于 $\\pi \\neq 0$。\n- 独立性：$G$ 独立于 $U$以及 $X$ 和 $Y$ 的所有其他未测量原因。\n- 排他性限制：$G$ 对 $Y$ 没有除通过 $X$ 之外的直接因果效应，对应于 $\\alpha = 0$。\n\n将单个工具变量的估计量 $\\hat{\\beta}_{\\mathrm{IV}}$ 定义为满足以下经验矩条件的唯一标量 $\\hat{\\beta}$：\n$$\n\\frac{1}{N} \\sum_{i=1}^{N} G_i \\,\\bigl(Y_i - \\hat{\\beta}\\, X_i \\bigr) \\;=\\; 0,\n$$\n对于一个大小为 $N$ 的给定样本。将朴素普通最小二乘（OLS）估计量 $\\hat{\\beta}_{\\mathrm{OLS}}$ 定义为最小化以下经验均方差的标量 $\\hat{\\beta}$：\n$$\n\\frac{1}{N} \\sum_{i=1}^{N} \\bigl(Y_i - \\hat{\\beta}\\, X_i \\bigr)^2.\n$$\n\n对于下方的每个测试用例，您必须生成 $R$ 个独立的蒙特卡罗重复。在每次重复中，从指定的数据生成过程中抽取一个大小为 $N$ 的独立样本，从该重复中计算 $\\hat{\\beta}_{\\mathrm{IV}}$，然后计算重复偏差 $\\hat{\\beta}_{\\mathrm{IV}} - \\beta$。通过计算算术平均值来汇总重复偏差，以获得该测试用例的平均工具变量偏差。使用固定的伪随机数生成器种子以确保确定性：对于索引为 $k$（从零开始）的测试用例，使用种子 $2025 + k$。\n\n使用以下测试套件，其中每一项列出了 $(N, R, p, \\pi, \\beta, \\gamma, \\delta, \\alpha, \\sigma_X, \\sigma_Y)$：\n\n- 测试用例 A（理想情况，存在未测量混杂的有效工具）：$(\\,N=\\;4000,\\; R=\\;800,\\; p=\\;0.3,\\; \\pi=\\;0.2,\\; \\beta=\\;0.5,\\; \\gamma=\\;0.8,\\; \\delta=\\;0.8,\\; \\alpha=\\;0.0,\\; \\sigma_X=\\;1.0,\\; \\sigma_Y=\\;1.0\\,)$。\n- 测试用例 B（边界情况，存在未测量混杂的弱但有效工具）：$(\\,N=\\;4000,\\; R=\\;800,\\; p=\\;0.3,\\; \\pi=\\;0.01,\\; \\beta=\\;0.5,\\; \\gamma=\\;0.8,\\; \\delta=\\;0.8,\\; \\alpha=\\;0.0,\\; \\sigma_X=\\;1.0,\\; \\sigma_Y=\\;1.0\\,)$。\n- 测试用例 C（边缘情况，违反排他性限制）：$(\\,N=\\;4000,\\; R=\\;800,\\; p=\\;0.3,\\; \\pi=\\;0.2,\\; \\beta=\\;0.5,\\; \\gamma=\\;0.8,\\; \\delta=\\;0.8,\\; \\alpha=\\;0.2,\\; \\sigma_X=\\;1.0,\\; \\sigma_Y=\\;1.0\\,)$。\n- 测试用例 D（边缘情况，无未测量的混杂）：$(\\,N=\\;4000,\\; R=\\;800,\\; p=\\;0.3,\\; \\pi=\\;0.2,\\; \\beta=\\;0.5,\\; \\gamma=\\;0.0,\\; \\delta=\\;0.0,\\; \\alpha=\\;0.0,\\; \\sigma_X=\\;1.0,\\; \\sigma_Y=\\;1.0\\,)$。\n\n设无偏性的容忍度为 $\\tau = 0.05$。对于每个测试用例，输出一个布尔值，表示平均工具变量偏差的绝对值是否最多为 $\\tau$，即 $\\bigl|\\frac{1}{R}\\sum_{r=1}^{R} (\\hat{\\beta}_{\\mathrm{IV},r} - \\beta)\\bigr| \\le \\tau$ 是否成立。\n\n您的程序必须生成单行输出，其中包含测试用例 A、B、C、D 的布尔值（按此顺序），形式为用方括号括起来的逗号分隔列表，无空格，例如 $[{\\tt True},{\\tt False},{\\tt True},{\\tt True}]$。",
            "solution": "该问题要求在孟德尔随机化（MR）框架内，实现一个确定性的蒙特卡罗模拟，以评估因果效应 $\\beta$ 的工具变量（IV）估计量的无偏性。评估在多个情景下进行，每个情景由线性结构方程模型的一组参数定义。\n\n数据生成过程由以下方程组定义：\n$$\nX \\;=\\; \\pi \\, G \\;+\\; \\gamma \\, U \\;+\\; \\varepsilon_X\n$$\n$$\nY \\;=\\; \\beta \\, X \\;+\\; \\delta \\, U \\;+\\; \\alpha \\, G \\;+\\; \\varepsilon_Y\n$$\n此处，$G$ 是遗传工具，$U$ 是未测量的混杂因素，$X$ 是暴露，$Y$ 是结局。随机变量分布如下：$G \\sim \\text{Binomial}(2,p)$，$U \\sim \\mathcal{N}(0,1)$，$\\varepsilon_X \\sim \\mathcal{N}(0,\\sigma_X^2)$，以及 $\\varepsilon_Y \\sim \\mathcal{N}(0,\\sigma_Y^2)$。所有外生变量（$G$、$U$、$\\varepsilon_X$、$\\varepsilon_Y$）均被规定为相互独立。\n\n问题通过经验矩条件定义了工具变量估计量 $\\hat{\\beta}_{\\mathrm{IV}}$：\n$$\n\\frac{1}{N} \\sum_{i=1}^{N} G_i \\,\\bigl(Y_i - \\hat{\\beta}_{\\mathrm{IV}}\\, X_i \\bigr) \\;=\\; 0\n$$\n对于一个大小为 $N$ 的样本。此条件必须被满足。通过简单的代数运算，我们可以推导出 $\\hat{\\beta}_{\\mathrm{IV}}$ 的闭式表达式。将 $G_i$ 分配进去并重新整理求和项，可得：\n$$\n\\sum_{i=1}^{N} G_i Y_i - \\hat{\\beta}_{\\mathrm{IV}} \\sum_{i=1}^{N} G_i X_i = 0\n$$\n求解 $\\hat{\\beta}_{\\mathrm{IV}}$ 可得到单个工具变量估计量的表达式，通常称为 Wald 估计量：\n$$\n\\hat{\\beta}_{\\mathrm{IV}} = \\frac{\\sum_{i=1}^{N} G_i Y_i}{\\sum_{i=1}^{N} G_i X_i}\n$$\n该公式计算简单，并构成了我们模拟的基础。该估计量也可以表示为样本均值 $\\mathbb{E}_N[GY] = \\frac{1}{N}\\sum G_i Y_i$ 与样本均值 $\\mathbb{E}_N[GX] = \\frac{1}{N}\\sum G_i X_i$ 的比值。\n\n核心工具变量假设是：\n$1$. **相关性**：工具变量 $G$ 必须与暴露 $X$ 相关。在此模型中，这要求 $\\pi \\neq 0$。\n$2$. **独立性**：工具变量 $G$ 必须独立于未测量的混杂因素 $U$。这一点由问题的数据生成过程保证。\n$3$. **排他性限制**：工具变量 $G$ 除了通过暴露 $X$ 之外，不得对结局 $Y$ 产生影响。这要求直接效应参数 $\\alpha$ 为零，即 $\\alpha = 0$。\n\n当这些假设成立时，IV 估计量对于真实因果效应 $\\beta$ 是一致的。也就是说，当 $N \\to \\infty$ 时，$\\hat{\\beta}_{\\mathrm{IV}} \\xrightarrow{p} \\beta$。然而，在有限样本中，或当假设被违反时，该估计量可能是有偏的。\n\n对于每个由参数元组 $(N, R, p, \\pi, \\beta, \\gamma, \\delta, \\alpha, \\sigma_X, \\sigma_Y)$ 指定的测试用例，模拟算法按以下步骤进行：\n$1$. 对于第 $k$ 个测试用例（从 $k=0$ 开始），使用一个固定的伪随机数生成器种子 $2025+k$，以确保结果的确定性和可复现性。\n$2$. 共生成 $R$ 次蒙特卡罗重复。\n$3$. 在每次重复 $r \\in \\{1, \\dots, R\\}$ 中：\n    a. 抽取一个大小为 $N$ 的样本。这包括为每个外生变量生成 $N$ 个独立的抽样：$G_i \\sim \\text{Binomial}(2,p)$、$U_i \\sim \\mathcal{N}(0,1)$、$\\varepsilon_{X,i} \\sim \\mathcal{N}(0,\\sigma_X^2)$ 和 $\\varepsilon_{Y,i} \\sim \\mathcal{N}(0,\\sigma_Y^2)$。\n    b. 使用结构方程为每个观测值 $i \\in \\{1, \\dots, N\\}$ 构建内生变量 $X_i$ 和 $Y_i$。\n    c. 使用上面推导的公式计算该次重复的 IV 估计值 $\\hat{\\beta}_{\\mathrm{IV},r}$。\n    d. 计算该次重复的偏差为 $\\hat{\\beta}_{\\mathrm{IV},r} - \\beta$。\n$4$. 完成所有 $R$ 次重复后，计算平均偏差，即单个重复偏差的算术平均值：$\\text{平均偏差} = \\frac{1}{R} \\sum_{r=1}^{R} (\\hat{\\beta}_{\\mathrm{IV},r} - \\beta)$。\n$5$. 最后，将平均偏差的绝对值与指定的容忍度 $\\tau=0.05$ 进行比较。如果 $|\\text{平均偏差}| \\le \\tau$，则结果为 `True`，否则为 `False`。\n\n我们根据 MR 理论分析每个测试用例的预期结果：\n- **测试用例 A**：所有三个 MR 假设都满足，且工具变量很强（$\\pi=0.2$）。估计量应近似无偏。我们预期平均偏差会远小于容忍度 $\\tau=0.05$。\n- **测试用例 B**：工具变量的相关性假设得到满足，但工具变量很弱（$\\pi=0.01$）。已知弱工具变量会产生有限样本偏差，该偏差趋向于朴素 OLS 估计量的偏差。由于存在混杂（$\\gamma=0.8, \\delta=0.8$），OLS 估计是有偏的，因此 IV 估计也将有显著偏差。我们预期平均偏差会超过 $\\tau=0.05$。\n- **测试用例 C**：排他性限制被违反（$\\alpha=0.2$）。这种违反会引入渐进偏差。估计量 $\\hat{\\beta}_{\\mathrm{IV}}$ 依概率收敛于 $\\beta + \\alpha/\\pi$，而非 $\\beta$。在这种情况下，渐进偏差为 $0.2/0.2 = 1.0$，远大于 $\\tau=0.05$。\n- **测试用例 D**：不存在未测量的混杂（$\\gamma = 0$ 且 $\\delta = 0$）。在这种情况下，内生性的主要来源被移除。MR 假设得到满足，IV 估计量应该是无偏的。在这种情况下，即使是朴素的 OLS 估计量也是无偏的。我们预期平均偏差会远小于 $\\tau=0.05$。\n\n实现将遵循此逻辑以提供最终的布尔输出。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, R, p, pi, beta, gamma, delta, alpha, sigma_X, sigma_Y, seed):\n    \"\"\"\n    Runs a Monte Carlo simulation for a single Mendelian randomization scenario.\n    \n    Args:\n        N (int): Sample size per replicate.\n        R (int): Number of Monte Carlo replicates.\n        p (float): Allele frequency for the binomial genetic instrument.\n        pi (float): Effect of instrument G on exposure X.\n        beta (float): Causal effect of exposure X on outcome Y.\n        gamma (float): Effect of confounder U on exposure X.\n        delta (float): Effect of confounder U on outcome Y.\n        alpha (float): Direct effect of instrument G on outcome Y (pleiotropy).\n        sigma_X (float): Standard deviation of the noise term for X.\n        sigma_Y (float): Standard deviation of the noise term for Y.\n        seed (int): Seed for the pseudorandom number generator.\n        \n    Returns:\n        float: The mean bias of the IV estimator over all replicates.\n    \"\"\"\n    # Set the seed for reproducibility for this entire test case.\n    np.random.seed(seed)\n    \n    replicate_biases = []\n    \n    for _ in range(R):\n        # 1. Generate exogenous variables for a sample of size N.\n        G = np.random.binomial(2, p, size=N)\n        U = np.random.normal(0, 1, size=N)\n        eps_X = np.random.normal(0, sigma_X, size=N)\n        eps_Y = np.random.normal(0, sigma_Y, size=N)\n        \n        # 2. Generate endogenous variables based on structural equations.\n        X = pi * G + gamma * U + eps_X\n        Y = beta * X + delta * U + alpha * G + eps_Y\n        \n        # 3. Compute the IV estimator for the replicate.\n        sum_GX = np.sum(G * X)\n        sum_GY = np.sum(G * Y)\n        \n        # The probability of sum_GX being zero is astronomically small for the given\n        # parameters (N=4000, p=0.3) and can be safely disregarded.\n        if sum_GX == 0:\n            continue\n            \n        beta_iv = sum_GY / sum_GX\n        \n        # 4. Calculate and store the bias for this replicate.\n        bias = beta_iv - beta\n        replicate_biases.append(bias)\n        \n    # 5. Compute the mean bias over all replicates.\n    if not replicate_biases:\n        # This branch is effectively unreachable under the problem's constraints.\n        return np.nan\n        \n    mean_bias = np.mean(replicate_biases)\n    \n    return mean_bias\n\ndef solve():\n    \"\"\"\n    Defines the test cases, runs the simulations, and prints the results.\n    \"\"\"\n    # Test cases defined as (N, R, p, pi, beta, gamma, delta, alpha, sigma_X, sigma_Y)\n    test_cases = [\n        # Case A: Happy path, valid instrument\n        (4000, 800, 0.3, 0.2, 0.5, 0.8, 0.8, 0.0, 1.0, 1.0),\n        # Case B: Boundary, weak instrument\n        (4000, 800, 0.3, 0.01, 0.5, 0.8, 0.8, 0.0, 1.0, 1.0),\n        # Case C: Edge case, exclusion restriction violated\n        (4000, 800, 0.3, 0.2, 0.5, 0.8, 0.8, 0.2, 1.0, 1.0),\n        # Case D: Edge case, no confounding\n        (4000, 800, 0.3, 0.2, 0.5, 0.0, 0.0, 0.0, 1.0, 1.0),\n    ]\n    \n    tau = 0.05\n    results = []\n    \n    for k, case_params in enumerate(test_cases):\n        seed = 2025 + k\n        mean_bias = run_simulation(*case_params, seed=seed)\n        \n        # Check if the absolute mean bias is within the tolerance.\n        is_unbiased_within_tolerance = abs(mean_bias) = tau\n        results.append(is_unbiased_within_tolerance)\n        \n    # Print the final results in the specified format: [True,False,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n```"
        },
        {
            "introduction": "从理想到现实，真实的MR分析通常依赖于大规模的全基因组关联研究（GWAS）汇总数据。本练习将带你进入应用层面，学习如何对MR分析进行关键的诊断检验，这是确保结论可靠性的重要一步。你将学习计算和解读用于生成散点图和漏斗图的关键指标，从而能够直观地评估异质性（heterogeneity）和方向性水平多效性（directional horizontal pleiotropy）——这是MR分析中最常见的挑战 。",
            "id": "2404096",
            "problem": "在孟德尔随机化 (MR) 的背景下，您会获得来自全基因组关联研究 (GWAS) 的汇总关联数据，其中每个工具变量均为单核苷酸多态性 (SNP)。对于每个 SNP，您拥有其与暴露的关联性，记为 $ \\beta_{GX,i} $，以及其与结局的关联性，记为 $ \\beta_{GY,i} $，同时还有结局关联性的标准误 $ \\sigma_{GY,i} $。假设遵循以下基本原则：(i) 暴露-结局关系存在线性因果模型；(ii) 除了任何潜在的水平多效性外，工具变量仅通过暴露影响结局；(iii) $ \\beta_{GY,i} $ 的抽样变异性由 $ \\sigma_{GY,i} $ 量化，且为了加权目的，$ \\beta_{GX,i} $ 的不确定性相对于 $ \\sigma_{GY,i} $ 可以忽略不计；(iv) 因果效应可通过使用加权最小二乘法汇总每个变异位点的信息来估计。\n\n您的任务是编写一个完整的程序，针对下述每个测试用例，计算生成 (a) $ \\beta_{GY} $ 相对于 $ \\beta_{GX} $ 的散点图（图中包含截距约束的逆方差加权 (IVW) 回归线和孟德尔随机化-Egger (MR-Egger) 回归线）以及 (b) 比率估计值相对于其标准误的漏斗图（用于直观检查异质性和多效性）所需的数值对象。您的程序无需绘制任何图形，但必须返回定义这些图形的精确数值。\n\n仅根据上述基本原则，为每个测试用例实现以下计算：\n- 使用由结局方差的倒数定义的权重 $ w_i $，即 $ w_i $ 与 $ 1 / \\sigma_{GY,i}^2 $ 成正比。\n- 通过求解将截距固定为零的加权最小二乘问题，计算截距约束的 IVW 因果斜率估计值，该问题旨在对 $ b $ 最小化 $ \\sum_i w_i \\left( \\beta_{GY,i} - b \\, \\beta_{GX,i} \\right)^2 $。\n- 通过对 $ a $ 和 $ b $ 最小化 $ \\sum_i w_i \\left( \\beta_{GY,i} - a - b \\, \\beta_{GX,i} \\right)^2 $，计算具有无约束截距的 MR-Egger 加权回归线。\n- 在 IVW 拟合下，计算用于异质性的 Cochran’s $ Q $ 统计量和相应的 $ I^2 $ 异质性指标，其中 $ Q $ 比较了加权残差的离散度与其在同质性假设下的期望值。\n- 对于漏斗图，在 $ \\beta_{GX,i} $ 的不确定性相对于 $ \\sigma_{GY,i} $ 可忽略的假设下，计算每个变异位点的比率估计值 $ \\theta_i $ 及其近似标准误 $ s_i $。然后，计算每个变异位点围绕合并 IVW 效应的伪 $ 95\\% $ 漏斗界限，公式为 $ \\theta_{\\text{IVW}} \\pm 1.96 \\, s_i $。\n\n您的程序必须将这些计算应用于以下测试套件。每个测试用例由三个等长列表定义：$ \\beta_{GX} $、$ \\beta_{GY} $ 和 $ \\sigma_{GY} $。\n\n测试用例 A（理想情况；一致的工具变量）：\n- $ \\beta_{GX} = [\\, 0.08, \\, 0.12, \\, 0.10, \\, 0.15, \\, 0.07, \\, 0.11 \\,] $\n- $ \\beta_{GY} = [\\, 0.040, \\, 0.060, \\, 0.051, \\, 0.072, \\, 0.033, \\, 0.057 \\,] $\n- $ \\sigma_{GY} = [\\, 0.020, \\, 0.018, \\, 0.022, \\, 0.019, \\, 0.021, \\, 0.020 \\,] $\n\n测试用例 B（方向性多效性；预期非零截距）：\n- $ \\beta_{GX} = [\\, 0.05, \\, -0.04, \\, 0.09, \\, 0.12, \\, 0.03, \\, 0.07 \\,] $\n- $ \\beta_{GY} = [\\, 0.037, \\, 0.007, \\, 0.048, \\, 0.054, \\, 0.029, \\, 0.042 \\,] $\n- $ \\sigma_{GY} = [\\, 0.020, \\, 0.021, \\, 0.019, \\, 0.018, \\, 0.022, \\, 0.020 \\,] $\n\n测试用例 C（异质性与弱工具变量）：\n- $ \\beta_{GX} = [\\, 0.20, \\, 0.15, \\, 0.10, \\, 0.05, \\, 0.004 \\,] $\n- $ \\beta_{GY} = [\\, 0.080, \\, 0.070, \\, 0.045, \\, 0.050, \\, 0.010 \\,] $\n- $ \\sigma_{GY} = [\\, 0.015, \\, 0.015, \\, 0.016, \\, 0.020, \\, 0.020 \\,] $\n\n测试用例 D（平衡多效性；异质性但截距近似为零）：\n- $ \\beta_{GX} = [\\, 0.10, \\, 0.12, \\, 0.09, \\, 0.11, \\, 0.08 \\,] $\n- $ \\beta_{GY} = [\\, 0.080, \\, 0.052, \\, 0.064, \\, 0.056, \\, 0.048 \\,] $\n- $ \\sigma_{GY} = [\\, 0.020, \\, 0.020, \\, 0.020, \\, 0.020, \\, 0.020 \\,] $\n\n实现和数值要求：\n- 将所有权重视为 $ w_i = 1 / \\sigma_{GY,i}^2 $。\n- 对于漏斗图，计算 $ \\theta_i = \\beta_{GY,i} / \\beta_{GX,i} $ 和 $ s_i = \\sigma_{GY,i} / \\lvert \\beta_{GX,i} \\rvert $。\n- 在漏斗图界限 $ \\theta_{\\text{IVW}} \\pm 1.96 \\, s_i $ 中，使用 IVW 斜率作为合并效应。\n- 对于 IVW 拟合下的 Cochran’s 异质性统计量，计算 $ Q $，然后计算 $ I^2 = \\max \\left( 0, \\, \\dfrac{Q - (M - 1)}{Q} \\right) $，其中 $ M $ 是变异位点的数量。如果 $ Q = 0 $，则设 $ I^2 = 0 $。\n- 您的程序必须为每个测试用例输出一个包含以下九个元素的列表：\n  1. IVW 斜率（浮点数），\n  2. MR-Egger 斜率（浮点数），\n  3. MR-Egger 截距（浮点数），\n  4. IVW Cochran’s $ Q $（浮点数），\n  5. IVW $ I^2 $（浮点数），\n  6. 比率估计值列表 $ [ \\theta_i ] $，\n  7. 比率标准误列表 $ [ s_i ] $，\n  8. 漏斗图下界列表 $ [ \\theta_{\\text{IVW}} - 1.96 \\, s_i ] $，\n  9. 漏斗图上界列表 $ [ \\theta_{\\text{IVW}} + 1.96 \\, s_i ] $。\n- 将所有浮点数四舍五入至六位小数。\n- 最终输出格式：您的程序应生成一行输出，其中包含四个测试用例的结果，这些结果聚合为一个用方括号括起来的逗号分隔列表，且没有空格。即，形式为 $ [r_A, r_B, r_C, r_D] $ 的单行，其中每个 $ r_\\cdot $ 是上述的九元素列表。\n\n边界条件与科学现实性：\n- 确保 $ \\lvert \\beta_{GX,i} \\rvert $ 不为零，以避免在比率计算中出现除以零的情况。所提供的测试套件满足此条件；一般而言，如果任何 $ \\lvert \\beta_{GX,i} \\rvert $ 低于某个小阈值 $ \\varepsilon $，则该变异位点应从比率和漏斗图组件中排除，同时在回归拟合中（如果处理得当）保持一致。在此测试套件中，无需进行任何排除。",
            "solution": "问题陈述经评估有效。它在科学上基于孟德尔随机化 (MR) 的既定原则，这是一种遗传流行病学中的标准方法。该问题定义明确，为所需的计算提供了所有必要的数据和明确的数学定义。其语言客观、正式，没有歧义或主观论断。它提出了一个基于可验证的统计和数学原理的可计算任务。\n\n我们现在将系统地推导所需的量。背景是使用遗传变异作为工具变量来估计暴露对结局的因果效应。对于 $M$ 个遗传变异（SNP），我们给出了其与暴露的估计关联 $ \\beta_{GX,i} $、与结局的估计关联 $ \\beta_{GY,i} $ 以及后者的标准误 $ \\sigma_{GY,i} $。\n\n所有加权计算的权重由结局方差的倒数定义，假设为此目的 $ \\beta_{GX,i} $ 的不确定性可以忽略不计：\n$$\nw_i = \\frac{1}{\\sigma_{GY,i}^2}\n$$\n\n**1. 截距约束的逆方差加权 (IVW) 斜率**\n\nIVW 方法通过求解一个将回归线强制通过原点的加权最小二乘问题来估计因果效应 $b$。这对应于不存在水平多效性的假设。目标是最小化加权残差平方和：\n$$\nS(b) = \\sum_{i=1}^{M} w_i \\left( \\beta_{GY,i} - b \\, \\beta_{GX,i} \\right)^2\n$$\n为求最小值，我们将关于 $b$ 的导数设为零：\n$$\n\\frac{dS}{db} = -2 \\sum_{i=1}^{M} w_i \\beta_{GX,i} \\left( \\beta_{GY,i} - b \\, \\beta_{GX,i} \\right) = 0\n$$\n求解 $b$ 可得 IVW 估计值，我们记为 $\\theta_{\\text{IVW}}$：\n$$\n\\theta_{\\text{IVW}} = \\frac{\\sum_{i=1}^{M} w_i \\beta_{GX,i} \\beta_{GY,i}}{\\sum_{i=1}^{M} w_i \\beta_{GX,i}^2}\n$$\n\n**2. 孟德尔随机化-Egger (MR-Egger) 回归**\n\nMR-Egger 方法放宽了 IVW 方法的无多效性假设，允许在 $ \\beta_{GY,i} $ 对 $ \\beta_{GX,i} $ 的回归中存在非零截距。截距 $a$ 可被解释为平均方向性多效性效应的估计，而斜率 $b$ 仍然是因果效应的估计。我们对 $a$ 和 $b$ 最小化以下目标函数：\n$$\nS(a, b) = \\sum_{i=1}^{M} w_i \\left( \\beta_{GY,i} - a - b \\, \\beta_{GX,i} \\right)^2\n$$\n这是一个标准的加权线性回归问题。MR-Egger 斜率 ($b_{\\text{Egger}}$) 和截距 ($a_{\\text{Egger}}$) 的解由正规方程给出：\n$$\nb_{\\text{Egger}} = \\frac{ \\left(\\sum w_i\\right) \\left(\\sum w_i \\beta_{GX,i} \\beta_{GY,i}\\right) - \\left(\\sum w_i \\beta_{GX,i}\\right) \\left(\\sum w_i \\beta_{GY,i}\\right) }{ \\left(\\sum w_i\\right) \\left(\\sum w_i \\beta_{GX,i}^2\\right) - \\left(\\sum w_i \\beta_{GX,i}\\right)^2 }\n$$\n$$\na_{\\text{Egger}} = \\frac{\\sum w_i \\beta_{GY,i}}{\\sum w_i} - b_{\\text{Egger}} \\frac{\\sum w_i \\beta_{GX,i}}{\\sum w_i}\n$$\n这些公式对应于加权最小二乘回归系数的标准解法。\n\n**3. Cochran’s Q 统计量和 I² 异质性指标**\n\n工具变量特异性因果估计值之间的异质性可能表明违反了 MR 假设（例如多效性），或者表明对于不同工具变量所针对的不同人群子集，真实的因果效应有所不同。用于 IVW 模型的 Cochran’s $Q$ 统计量通过对单个比率估计值与合并 IVW 估计值之间的加权平方差求和来量化这种异质性。其计算公式为：\n$$\nQ = \\sum_{i=1}^{M} w_i \\left( \\frac{\\beta_{GY,i}}{\\beta_{GX,i}} - \\theta_{\\text{IVW}} \\right)^2 \\beta_{GX,i}^2 = \\sum_{i=1}^{M} w_i \\left( \\beta_{GY,i} - \\theta_{\\text{IVW}} \\beta_{GX,i} \\right)^2\n$$\n在同质性（即所有工具变量估计相同的因果效应）的原假设下，$Q$ 服从自由度为 $M-1$ 的卡方分布。\n\n$I^2$ 统计量描述了工具变量间的变异由异质性而非抽样误差所致的百分比。它由 $Q$ 推导得出：\n$$\nI^2 = \\max\\left(0, \\frac{Q - (M-1)}{Q}\\right)\n$$\n如果 $Q=0$（在实践中极不可能），则定义 $I^2$ 为 $0$。\n\n**4. 漏斗图组件**\n\n漏斗图是一种用于研究异质性和发表偏倚的可视化工具。它绘制了每个工具变量的效应大小与其精确度的度量。\n\n-   **每个变异位点的比率估计值 ($\\theta_i$):** 这是从单个工具变量 $i$ 估计的因果效应：\n    $$\n    \\theta_i = \\frac{\\beta_{GY,i}}{\\beta_{GX,i}}\n    $$\n-   **比率估计值的标准误 ($s_i$):** 使用 delta 方法，并假设 $ \\beta_{GX,i} $ 的测量误差可忽略不计，$\\theta_i$ 的标准误近似为：\n    $$\n    s_i = \\text{SE}(\\theta_i) \\approx \\frac{\\sigma_{GY,i}}{\\lvert \\beta_{GX,i} \\rvert}\n    $$\n-   **漏斗图界限:** 漏斗图围绕合并的 IVW 因果估计值 $\\theta_{\\text{IVW}}$ 构建。对于一个伪 $95\\%$ 置信区间，每个变异位点 $i$ 的界限为：\n    $$\n    \\text{Bounds}_i = \\theta_{\\text{IVW}} \\pm 1.96 \\, s_i\n    $$\n    下界和上界分别为 $\\theta_{\\text{IVW}} - 1.96 \\, s_i$ 和 $\\theta_{\\text{IVW}} + 1.96 \\, s_i$。\n\n实现过程将为每个提供的测试用例计算这九个量：IVW 斜率、MR-Egger 斜率和截距、IVW 拟合的 Cochran's Q 和 I² 统计量，以及比率估计值、其标准误、相应的漏斗图下界和上界的列表。所有浮点数将按要求四舍五入到小数点后六位。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_mr_metrics(beta_gx: list[float], beta_gy: list[float], sigma_gy: list[float]) - list:\n    \"\"\"\n    Computes Mendelian randomization metrics for a given set of summary statistics.\n\n    Args:\n        beta_gx: List of SNP-exposure associations.\n        beta_gy: List of SNP-outcome associations.\n        sigma_gy: List of standard errors for SNP-outcome associations.\n\n    Returns:\n        A list containing nine elements as specified in the problem description.\n    \"\"\"\n    # Convert lists to NumPy arrays for vectorized operations\n    bgx = np.array(beta_gx)\n    bgy = np.array(beta_gy)\n    sgy = np.array(sigma_gy)\n    \n    # 1. Weights\n    # w_i = 1 / sigma_GY,i^2\n    w = 1.0 / (sgy**2)\n    \n    # 2. IVW Slope (Intercept-constrained)\n    # theta_ivw = (sum w_i * beta_gx_i * beta_gy_i) / (sum w_i * beta_gx_i^2)\n    ivw_numerator = np.sum(w * bgx * bgy)\n    ivw_denominator = np.sum(w * bgx**2)\n    ivw_slope = ivw_numerator / ivw_denominator\n    \n    # 3. MR-Egger Slope and Intercept\n    # Weighted least squares regression of bgy on bgx with weights w\n    W = np.sum(w)\n    Swx = np.sum(w * bgx)\n    Swy = np.sum(w * bgy)\n    Swxx = np.sum(w * bgx**2)\n    Swxy = np.sum(w * bgx * bgy)\n    \n    egger_denominator = (W * Swxx - Swx**2)\n    if egger_denominator == 0:\n        # This case is unlikely with real data but handle for robustness\n        mr_egger_slope = np.nan\n        mr_egger_intercept = np.nan\n    else:\n        mr_egger_slope = (W * Swxy - Swx * Swy) / egger_denominator\n        mr_egger_intercept = (Swy / W) - mr_egger_slope * (Swx / W)\n\n    # 4. Cochran's Q for IVW\n    # Q = sum w_i * (beta_gy_i - theta_ivw * beta_gx_i)^2\n    cochran_q = np.sum(w * (bgy - ivw_slope * bgx)**2)\n    \n    # 5. I^2 for IVW\n    M = len(bgx)\n    df = M - 1\n    if cochran_q == 0:\n        i_squared = 0.0\n    else:\n        i_squared = max(0.0, (cochran_q - df) / cochran_q)\n\n    # 6. Ratio estimates (theta_i)\n    # theta_i = beta_gy_i / beta_gx_i\n    theta_i = bgy / bgx\n    \n    # 7. Ratio standard errors (s_i)\n    # s_i = sigma_gy_i / |beta_gx_i|\n    s_i = sgy / np.abs(bgx)\n    \n    # 8.  9. Funnel plot bounds\n    # lower/upper = theta_ivw +/- 1.96 * s_i\n    z_score = 1.96\n    funnel_lower_bounds = ivw_slope - z_score * s_i\n    funnel_upper_bounds = ivw_slope + z_score * s_i\n    \n    # Assemble results and round to 6 decimal places\n    results = [\n        round(ivw_slope, 6),\n        round(mr_egger_slope, 6),\n        round(mr_egger_intercept, 6),\n        round(cochran_q, 6),\n        round(i_squared, 6),\n        [round(val, 6) for val in theta_i],\n        [round(val, 6) for val in s_i],\n        [round(val, 6) for val in funnel_lower_bounds],\n        [round(val, 6) for val in funnel_upper_bounds],\n    ]\n    \n    return results\n\ndef format_result_list(res_list: list) - str:\n    \"\"\"Formats a single test case result list into the required string format.\"\"\"\n    str_parts = []\n    for item in res_list:\n        if isinstance(item, list):\n            formatted_list = f\"[{','.join([f'{x:.6f}' for x in item])}]\"\n            str_parts.append(formatted_list)\n        else:\n            str_parts.append(f\"{item:.6f}\")\n    return f\"[{','.join(str_parts)}]\"\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = {\n        'A': {\n            \"beta_gx\": [0.08, 0.12, 0.10, 0.15, 0.07, 0.11],\n            \"beta_gy\": [0.040, 0.060, 0.051, 0.072, 0.033, 0.057],\n            \"sigma_gy\": [0.020, 0.018, 0.022, 0.019, 0.021, 0.020]\n        },\n        'B': {\n            \"beta_gx\": [0.05, -0.04, 0.09, 0.12, 0.03, 0.07],\n            \"beta_gy\": [0.037, 0.007, 0.048, 0.054, 0.029, 0.042],\n            \"sigma_gy\": [0.020, 0.021, 0.019, 0.018, 0.022, 0.020]\n        },\n        'C': {\n            \"beta_gx\": [0.20, 0.15, 0.10, 0.05, 0.004],\n            \"beta_gy\": [0.080, 0.070, 0.045, 0.050, 0.010],\n            \"sigma_gy\": [0.015, 0.015, 0.016, 0.020, 0.020]\n        },\n        'D': {\n            \"beta_gx\": [0.10, 0.12, 0.09, 0.11, 0.08],\n            \"beta_gy\": [0.080, 0.052, 0.064, 0.056, 0.048],\n            \"sigma_gy\": [0.020, 0.020, 0.020, 0.020, 0.020]\n        }\n    }\n\n    all_results_str = []\n    # Process cases in alphabetical order to match output format\n    for key in sorted(test_cases.keys()):\n        case = test_cases[key]\n        result = calculate_mr_metrics(case[\"beta_gx\"], case[\"beta_gy\"], case[\"sigma_gy\"])\n        all_results_str.append(format_result_list(result))\n\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在诊断性检验（如上一练习）中发现异质性信号后，下一步自然是探究其来源。本练习介绍了一种重要的敏感性分析方法——留一法（Leave-One-Out analysis）。通过编程实现该方法，你将学会量化每个遗传变异对总体因果效应估计值的影响力，这有助于精确定位可能驱动异质性的、具有多效性的或异常的SNP，从而加深对分析结果的理解 。",
            "id": "2404032",
            "problem": "给定多组单核苷酸多态性（SNP）工具变量的汇总级别遗传关联数据，用于通过孟德尔随机化（MR）估计因果效应。对于一组 $K$ 个工具变量中的每个 SNP $i$，为您提供四个实数：与暴露的关联性 $b_{X,i}$、其标准误 $s_{X,i}$、与结局的关联性 $b_{Y,i}$ 以及其标准误 $s_{Y,i}$。考虑以下模型：因果效应参数 $\\beta$ 定义为加权残差平方和的唯一最小化子\n$$\nQ(\\beta) \\equiv \\sum_{i=1}^{K} w_i \\left(b_{Y,i} - \\beta\\, b_{X,i}\\right)^2,\n$$\n其中工具变量 $i$ 的权重为 $w_i = 1/s_{Y,i}^2$。将全数据估计量 $\\hat{\\beta}$ 定义为 $Q(\\beta)$ 的最小化子。对于每个索引 $j \\in \\{0,1,\\dots,K-1\\}$，将留一法子集估计量 $\\hat{\\beta}_{(-j)}$ 定义为在排除索引 $j$ 的所有工具变量的子集上计算的类似目标的最小化子。将工具变量 $j$ 的绝对影响定义为\n$$\nI_j \\equiv \\left|\\hat{\\beta}_{(-j)} - \\hat{\\beta}\\right|.\n$$\n令 $j^\\star$ 为达到最大绝对影响的索引，即 $j^\\star \\in \\arg\\max_{0 \\le j \\le K-1} I_j$。如果出现平局，则选择最小的索引。\n\n您的任务是编写一个完整的、可运行的程序，对于下面提供的测试套件中的每个工具变量集，计算：\n- 索引 $j^\\star$，作为一个从零开始的整数，\n- 全数据估计值 $\\hat{\\beta}$，\n- 有序列表 $\\left[\\hat{\\beta}_{(-0)}, \\hat{\\beta}_{(-1)}, \\dots, \\hat{\\beta}_{(-(K-1))}\\right]$。\n\n所有浮点数输出必须四舍五入到小数点后恰好六位。最终的程序输出必须将所有测试用例的结果聚合到单行中，该行包含一个列表，其中每个测试用例贡献一个形式为 $[j^\\star, \\hat{\\beta}, [\\hat{\\beta}_{(-0)}, \\dots, \\hat{\\beta}_{(-(K-1))}]]$ 的列表。因此，确切的输出格式为单行：\n\"[ [case1_jstar,case1_beta,[case1_loo_list]], [case2_jstar,case2_beta,[case2_loo_list]], ... ]\"\n除了默认逗号分隔符显示的空格外，不添加任何其他空格。\n\n测试套件（每个用例指定 $K$，后跟对齐的 $b_X$、$s_X$、$b_Y$、$s_Y$ 数组）：\n\n- 用例 A:\n  - $K = 6$\n  - $b_X = [0.10, 0.08, 0.12, 0.15, 0.09, 0.11]$\n  - $s_X = [0.01, 0.01, 0.01, 0.01, 0.01, 0.01]$\n  - $b_Y = [0.052, 0.039, 0.063, 0.073, 0.045, 0.125]$\n  - $s_Y = [0.02, 0.02, 0.02, 0.02, 0.02, 0.02]$\n\n- 用例 B:\n  - $K = 2$\n  - $b_X = [0.10, 0.12]$\n  - $s_X = [0.01, 0.01]$\n  - $b_Y = [0.050, 0.150]$\n  - $s_Y = [0.02, 0.02]$\n\n- 用例 C:\n  - $K = 5$\n  - $b_X = [0.07, 0.05, 0.005, 0.06, 0.08]$\n  - $s_X = [0.01, 0.01, 0.02, 0.01, 0.01]$\n  - $b_Y = [0.022, 0.014, 0.002, 0.018, 0.054]$\n  - $s_Y = [0.015, 0.015, 0.015, 0.015, 0.015]$\n\n- 用例 D:\n  - $K = 4$\n  - $b_X = [0.10, 0.10, 0.10, 0.10]$\n  - $s_X = [0.01, 0.01, 0.01, 0.01]$\n  - $b_Y = [0.050, 0.050, 0.110, -0.010]$\n  - $s_Y = [0.02, 0.02, 0.02, 0.02]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个如上所述形式的列表。例如（仅为示例）：\"[[0,0.123456,[0.120000,0.130000]], [1,0.500000,[0.600000,0.400000]]]\"。\n- 不要打印任何额外的文本或空格。",
            "solution": "该问题要求实现一种算法，使用孟德尔随机化（MR）中的逆方差加权（IVW）方法计算因果效应估计值，并执行留一法（LOO）敏感性分析以识别最具影响力的工具变量。该问题在科学上是有效的、良定的，并且基于计算生物学中已建立的统计学原理。\n\n问题的核心是找到最小化加权残差平方和的参数 $\\beta$，这是一个标准的加权最小二乘问题。目标函数如下：\n$$\nQ(\\beta) \\equiv \\sum_{i=0}^{K-1} w_i \\left(b_{Y,i} - \\beta\\, b_{X,i}\\right)^2\n$$\n这里，索引 $i$ 从 $0$ 到 $K-1$，以与从零开始的数组索引对齐。$K$ 个工具变量中每个的输入是其与暴露的关联性 $b_{X,i}$ 和与结局的关联性 $b_{Y,i}$。每个工具变量对平方和的贡献权重由其结局关联性方差的倒数给出，即 $w_i = 1/s_{Y,i}^2$。暴露关联性的标准误 $s_{X,i}$ 已提供，但在这种特定的 IVW 模型中并未使用，该模型假设暴露关联性没有测量误差。\n\n为了找到最小化 $Q(\\beta)$ 的全数据估计量 $\\hat{\\beta}$，我们对 $Q(\\beta)$ 关于 $\\beta$求导并令其为零：\n$$\n\\frac{dQ(\\beta)}{d\\beta} = \\sum_{i=0}^{K-1} w_i \\cdot 2 \\left(b_{Y,i} - \\beta\\, b_{X,i}\\right) \\cdot (-b_{X,i}) = 0\n$$\n$$\n\\sum_{i=0}^{K-1} w_i b_{X,i} \\left(b_{Y,i} - \\beta\\, b_{X,i}\\right) = 0\n$$\n$$\n\\sum_{i=0}^{K-1} w_i b_{X,i} b_{Y,i} - \\beta \\sum_{i=0}^{K-1} w_i b_{X,i}^2 = 0\n$$\n解出 $\\beta$ 可得全数据估计量 $\\hat{\\beta}$ 的闭式解：\n$$\n\\hat{\\beta} = \\frac{\\sum_{i=0}^{K-1} w_i b_{X,i} b_{Y,i}}{\\sum_{i=0}^{K-1} w_i b_{X,i}^2}\n$$\n该表达式等价于将 $b_Y$ 对 $b_X$ 进行加权线性回归（截距约束为零）的斜率。\n\n下一步是为每个工具变量 $j \\in \\{0, 1, \\dots, K-1\\}$ 计算留一法（LOO）估计量 $\\hat{\\beta}_{(-j)}$。估计量 $\\hat{\\beta}_{(-j)}$ 的计算公式与 $\\hat{\\beta}$ 相同，但求和是在除第 $j$ 个之外的所有工具变量上进行的。一种高效的计算方法是首先计算全数据估计量的总和，然后减去第 $j$ 个工具变量的贡献。\n令 $S_{XY} = \\sum_{i=0}^{K-1} w_i b_{X,i} b_{Y,i}$ 且 $S_{XX} = \\sum_{i=0}^{K-1} w_i b_{X,i}^2$。全数据估计量为 $\\hat{\\beta} = S_{XY} / S_{XX}$。\n则 LOO 估计量 $\\hat{\\beta}_{(-j)}$ 为：\n$$\n\\hat{\\beta}_{(-j)} = \\frac{\\sum_{i \\neq j} w_i b_{X,i} b_{Y,i}}{\\sum_{i \\neq j} w_i b_{X,i}^2} = \\frac{S_{XY} - w_j b_{X,j} b_{Y,j}}{S_{XX} - w_j b_{X,j}^2}\n$$\n\n工具变量 $j$ 的绝对影响，记为 $I_j$，定义为移除该工具变量时估计值的变化幅度：\n$$\nI_j = \\left|\\hat{\\beta}_{(-j)} - \\hat{\\beta}\\right|\n$$\n\n最后的任务是找到对应于具有最大绝对影响的工具变量的索引 $j^\\star$。\n$$\nj^\\star = \\arg\\max_{0 \\le j \\le K-1} I_j\n$$\n问题规定，如果影响值出现平局，应选择最小的索引 $j$。\n\n每个测试用例的总体算法如下：\n1.  接收输入数据：$K$、数组 $b_X$、$s_X$、$b_Y$ 和 $s_Y$。\n2.  为每个工具变量 $i$ 计算权重 $w_i = 1/s_{Y,i}^2$。\n3.  计算全数据集的充分统计量：分子 $S_{XY} = \\sum w_i b_{X,i} b_{Y,i}$ 和分母 $S_{XX} = \\sum w_i b_{X,i}^2$。\n4.  计算全数据估计值 $\\hat{\\beta} = S_{XY} / S_{XX}$。\n5.  从 $j=0$ 迭代到 $K-1$：\n    a. 通过从总和中减去第 $j$ 个工具变量的贡献来计算留一法估计值 $\\hat{\\beta}_{(-j)} = (S_{XY} - w_j b_{X,j} b_{Y,j}) / (S_{XX} - w_j b_{X,j}^2)$。\n    b. 将每个 $\\hat{\\beta}_{(-j)}$ 存储在一个有序列表中。\n6.  计算所有 $j$ 的绝对影响 $I_j = |\\hat{\\beta}_{(-j)} - \\hat{\\beta}|$。\n7.  找到使 $I_j$ 最大化的索引 $j^\\star$，在出现平局时使用最小的索引。\n8.  将浮点数值（$\\hat{\\beta}$ 和所有 $\\hat{\\beta}_{(-j)}$）四舍五入到小数点后六位。\n9.  将该测试用例的结果格式化为 $[j^\\star, \\hat{\\beta}, [\\hat{\\beta}_{(-0)}, \\dots, \\hat{\\beta}_{(-(K-1))}]]$，并按规定将所有测试用例的结果聚合到单个输出行中。\n此过程将使用 Python 的 `numpy` 库实现，以进行高效的数组计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Mendelian Randomization problem for a suite of test cases.\n\n    For each case, it computes the full-data causal effect estimate (`beta_hat`),\n    the leave-one-out estimates (`loo_betas`), and the index of the most\n    influential instrument (`j_star`).\n    \"\"\"\n    test_cases = [\n        {\n            \"K\": 6,\n            \"b_X\": [0.10, 0.08, 0.12, 0.15, 0.09, 0.11],\n            \"s_X\": [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],\n            \"b_Y\": [0.052, 0.039, 0.063, 0.073, 0.045, 0.125],\n            \"s_Y\": [0.02, 0.02, 0.02, 0.02, 0.02, 0.02],\n        },\n        {\n            \"K\": 2,\n            \"b_X\": [0.10, 0.12],\n            \"s_X\": [0.01, 0.01],\n            \"b_Y\": [0.050, 0.150],\n            \"s_Y\": [0.02, 0.02],\n        },\n        {\n            \"K\": 5,\n            \"b_X\": [0.07, 0.05, 0.005, 0.06, 0.08],\n            \"s_X\": [0.01, 0.01, 0.02, 0.01, 0.01],\n            \"b_Y\": [0.022, 0.014, 0.002, 0.018, 0.054],\n            \"s_Y\": [0.015, 0.015, 0.015, 0.015, 0.015],\n        },\n        {\n            \"K\": 4,\n            \"b_X\": [0.10, 0.10, 0.10, 0.10],\n            \"s_X\": [0.01, 0.01, 0.01, 0.01],\n            \"b_Y\": [0.050, 0.050, 0.110, -0.010],\n            \"s_Y\": [0.02, 0.02, 0.02, 0.02],\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        b_x = np.array(case[\"b_X\"])\n        b_y = np.array(case[\"b_Y\"])\n        s_y = np.array(case[\"s_Y\"])\n\n        # Calculate weights w_i = 1/s_{Y,i}^2\n        w = 1.0 / (s_y**2)\n\n        # Calculate terms for the full-data estimator\n        num_full = np.sum(w * b_x * b_y)\n        den_full = np.sum(w * b_x**2)\n\n        # Handle division by zero if all b_x are zero, though not expected\n        if den_full == 0:\n            beta_hat = np.nan\n        else:\n            beta_hat = num_full / den_full\n\n        # Calculate leave-one-out (LOO) estimators\n        # Individual contributions to numerator and denominator\n        num_i = w * b_x * b_y\n        den_i = w * b_x**2\n\n        # Subtract individual contributions from the full sums\n        loo_nums = num_full - num_i\n        loo_dens = den_full - den_i\n        \n        # Avoid division by zero in LOO calculation\n        # If loo_den is 0, the corresponding beta is undefined. This can happen\n        # if after removing one instrument, all remaining b_x are zero.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            loo_betas = np.divide(loo_nums, loo_dens)\n            loo_betas[np.isinf(loo_betas)] = np.nan\n\n        # Calculate absolute influence I_j = |beta_{(-j)} - beta|\n        influences = np.abs(loo_betas - beta_hat)\n\n        # Find index j_star with max influence.\n        # np.argmax returns the first occurrence in case of a tie, satisfying the rule.\n        j_star = np.nanargmax(influences) if not np.all(np.isnan(influences)) else -1\n\n        # Format results for this case.\n        # Rounding is handled by string formatting to 6 decimal places.\n        beta_hat_str = f\"{beta_hat:.6f}\"\n        loo_betas_str_list = [f\"{b:.6f}\" for b in loo_betas]\n        loo_list_str = f\"[{','.join(loo_betas_str_list)}]\"\n        case_result_str = f\"[{j_star},{beta_hat_str},{loo_list_str}]\"\n        \n        all_results.append(case_result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}