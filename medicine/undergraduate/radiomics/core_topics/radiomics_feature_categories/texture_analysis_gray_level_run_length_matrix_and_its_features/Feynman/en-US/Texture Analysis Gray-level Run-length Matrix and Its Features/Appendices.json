{
    "hands_on_practices": [
        {
            "introduction": "Before we can build a Gray-Level Run-Length Matrix (GLRLM), it's essential to understand what it tells us about image texture. This first exercise provides a pre-computed GLRLM, allowing you to focus on the fundamental skill of calculating texture features like Short Run Emphasis (SRE) and Long Run Emphasis (LRE) directly from their definitions. By working through these calculations, you will build a solid intuition for how these numerical descriptors correspond to qualitative texture properties such as coarseness or fineness .",
            "id": "4564433",
            "problem": "A two-dimensional medical image has been discretized into $N_{g}=3$ gray levels and analyzed along a single, fixed direction to form a Gray-Level Run-Length Matrix (GLRLM), which is the matrix of counts $P(i,j)$ where $i \\in \\{1,2,3\\}$ indexes the gray level and $j \\in \\{1,2,3\\}$ indexes the run length. The GLRLM encodes how many runs of exactly $j$ consecutive pixels occur at gray level $i$. Consider the following toy GLRLM (all entries are nonnegative integers):\n$$\nP(1,1)=6,\\quad P(1,2)=1,\\quad P(1,3)=0;\\\\\nP(2,1)=2,\\quad P(2,2)=0,\\quad P(2,3)=0;\\\\\nP(3,1)=0,\\quad P(3,2)=0,\\quad P(3,3)=0.\n$$\nUsing foundational definitions of the GLRLM and its role in radiomic texture analysis, compute the Short Run Emphasis (SRE), Long Run Emphasis (LRE), Low Gray-Level Run Emphasis (LGRE), and High Gray-Level Run Emphasis (HGRE) for this matrix. Adopt the conventional indexing $i=1,2,3$ for gray levels and $j=1,2,3$ for run lengths, and use the total number of runs implied by the matrix to normalize any necessary quantities. Express each of the four feature values as exact numbers (for example, rational numbers), with no rounding, and report your final answer as the ordered quadruple $\\big(\\mathrm{SRE},\\mathrm{LRE},\\mathrm{LGRE},\\mathrm{HGRE}\\big)$. Then, briefly interpret qualitatively which texture type this GLRLM represents (for example, whether it is dominated by short or long runs, and whether it emphasizes low or high gray levels). No units are required.",
            "solution": "The problem statement is critically evaluated and found to be valid. It is scientifically grounded in the established field of radiomic texture analysis, well-posed with all necessary information provided for a unique solution, and objective in its language and definitions. The problem is a standard calculation of texture features from a given Gray-Level Run-Length Matrix (GLRLM).\n\nThe provided Gray-Level Run-Length Matrix, $P(i,j)$, quantifies the number of runs of length $j$ for a given gray level $i$. The number of gray levels is $N_g=3$, and the maximum considered run length is also $3$. The matrix entries are:\n$$\nP(1,1)=6, \\quad P(1,2)=1, \\quad P(1,3)=0 \\\\\nP(2,1)=2, \\quad P(2,2)=0, \\quad P(2,3)=0 \\\\\nP(3,1)=0, \\quad P(3,2)=0, \\quad P(3,3)=0\n$$\nWe can represent this GLRLM in matrix form, where the rows correspond to the gray level index $i$ and columns to the run length index $j$:\n$$\nP = \\begin{pmatrix} P(1,1) & P(1,2) & P(1,3) \\\\ P(2,1) & P(2,2) & P(2,3) \\\\ P(3,1) & P(3,2) & P(3,3) \\end{pmatrix} = \\begin{pmatrix} 6 & 1 & 0 \\\\ 2 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\nThe first step is to calculate the total number of runs, $N_r$, in the image, which is the sum of all elements in the matrix $P$. This value is used for normalization.\n$$\nN_r = \\sum_{i=1}^{3} \\sum_{j=1}^{3} P(i,j) = 6 + 1 + 0 + 2 + 0 + 0 + 0 + 0 + 0 = 9\n$$\nNow, we compute the four requested texture features using their standard definitions.\n\n1.  **Short Run Emphasis (SRE)**: This feature emphasizes short runs, with the weighting for each run being inversely proportional to the square of its length.\n    $$\n    \\mathrm{SRE} = \\frac{1}{N_r} \\sum_{i=1}^{3} \\sum_{j=1}^{3} \\frac{P(i,j)}{j^2}\n    $$\n    Substituting the given values:\n    $$\n    \\mathrm{SRE} = \\frac{1}{9} \\left( \\frac{P(1,1)}{1^2} + \\frac{P(1,2)}{2^2} + \\frac{P(2,1)}{1^2} \\right) = \\frac{1}{9} \\left( \\frac{6}{1} + \\frac{1}{4} + \\frac{2}{1} \\right)\n    $$\n    $$\n    \\mathrm{SRE} = \\frac{1}{9} \\left( 8 + \\frac{1}{4} \\right) = \\frac{1}{9} \\left( \\frac{32+1}{4} \\right) = \\frac{1}{9} \\left( \\frac{33}{4} \\right) = \\frac{33}{36} = \\frac{11}{12}\n    $$\n\n2.  **Long Run Emphasis (LRE)**: This feature emphasizes long runs, with the weighting for each run being proportional to the square of its length.\n    $$\n    \\mathrm{LRE} = \\frac{1}{N_r} \\sum_{i=1}^{3} \\sum_{j=1}^{3} P(i,j) \\cdot j^2\n    $$\n    Substituting the given values:\n    $$\n    \\mathrm{LRE} = \\frac{1}{9} \\left( P(1,1) \\cdot 1^2 + P(1,2) \\cdot 2^2 + P(2,1) \\cdot 1^2 \\right) = \\frac{1}{9} \\left( 6 \\cdot 1 + 1 \\cdot 4 + 2 \\cdot 1 \\right)\n    $$\n    $$\n    \\mathrm{LRE} = \\frac{1}{9} (6 + 4 + 2) = \\frac{12}{9} = \\frac{4}{3}\n    $$\n\n3.  **Low Gray-Level Run Emphasis (LGRE)**: This feature emphasizes runs of low gray-level values, with the weighting being inversely proportional to the square of the gray level.\n    $$\n    \\mathrm{LGRE} = \\frac{1}{N_r} \\sum_{i=1}^{3} \\sum_{j=1}^{3} \\frac{P(i,j)}{i^2}\n    $$\n    Substituting the given values:\n    $$\n    \\mathrm{LGRE} = \\frac{1}{9} \\left( \\frac{P(1,1)}{1^2} + \\frac{P(1,2)}{1^2} + \\frac{P(2,1)}{2^2} \\right) = \\frac{1}{9} \\left( \\frac{6}{1} + \\frac{1}{1} + \\frac{2}{4} \\right)\n    $$\n    $$\n    \\mathrm{LGRE} = \\frac{1}{9} \\left( 7 + \\frac{1}{2} \\right) = \\frac{1}{9} \\left( \\frac{14+1}{2} \\right) = \\frac{15}{18} = \\frac{5}{6}\n    $$\n\n4.  **High Gray-Level Run Emphasis (HGRE)**: This feature emphasizes runs of high gray-level values, with the weighting being proportional to the square of the gray level.\n    $$\n    \\mathrm{HGRE} = \\frac{1}{N_r} \\sum_{i=1}^{3} \\sum_{j=1}^{3} P(i,j) \\cdot i^2\n    $$\n    Substituting the given values:\n    $$\n    \\mathrm{HGRE} = \\frac{1}{9} \\left( (P(1,1)+P(1,2)) \\cdot 1^2 + P(2,1) \\cdot 2^2 \\right) = \\frac{1}{9} \\left( (6+1) \\cdot 1 + 2 \\cdot 4 \\right)\n    $$\n    $$\n    \\mathrm{HGRE} = \\frac{1}{9} (7 + 8) = \\frac{15}{9} = \\frac{5}{3}\n    $$\n\nThe four feature values are $(\\mathrm{SRE}, \\mathrm{LRE}, \\mathrm{LGRE}, \\mathrm{HGRE}) = (\\frac{11}{12}, \\frac{4}{3}, \\frac{5}{6}, \\frac{5}{3})$.\n\nQualitatively, the high SRE value $(\\frac{11}{12} \\approx 0.92)$, which is close to its maximum possible value of $1$, indicates a strong predominance of short runs. This is consistent with the GLRLM where $8$ out of $9$ runs have length $j=1$. This suggests a fine-grained or noisy texture. Similarly, the high LGRE value $(\\frac{5}{6} \\approx 0.83)$ compared to the HGRE value $(\\frac{5}{3} \\approx 1.67)$ indicates that the runs are concentrated at lower gray levels. A pure gray-level $1$ texture would yield $\\mathrm{LGRE}=1$ and $\\mathrm{HGRE}=1$, while a pure gray-level $2$ texture would yield $\\mathrm{LGRE}=1/4$ and $\\mathrm{HGRE}=4$. Our values confirm a strong presence of low gray levels. In summary, the GLRLM represents a fine-grained texture dominated by short runs occurring primarily at low gray-level values (i.e., a \"dark,\" fine texture).",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{11}{12} & \\frac{4}{3} & \\frac{5}{6} & \\frac{5}{3} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "With a grasp of the feature definitions, the next step is to generate the GLRLM from raw image data. This practice moves from theory to application, challenging you to construct an algorithm that scans a 2D image, identifies runs of constant gray level within a masked region of interest, and builds the corresponding matrix. Developing this core computational skill is fundamental to understanding how texture information is systematically quantified in radiomics .",
            "id": "4564398",
            "problem": "You are given a two-dimensional discrete image $\\mathbf{I}$ with integer gray levels and a binary mask $\\mathbf{M}$ indicating the Region of Interest (ROI). Fix a lattice direction $\\vec{d}$ chosen from $\\{(0,1),(1,0),(1,1),(1,-1)\\}$, where each pair denotes unit steps in row-column coordinates on the integer grid. A line along $\\vec{d}$ is defined as a maximal sequence of mask-connected pixels obtained by repeatedly stepping by $\\vec{d}$ from a valid starting pixel, where mask connectivity is restricted to adjacency induced by $\\vec{d}$. A run along $\\vec{d}$ is a maximal contiguous subsequence of a line for which the gray level in $\\mathbf{I}$ is constant. The Gray-Level Run-Length Matrix (GLRLM) counts, for each gray level $g$ and run length $r$, the number $P(g,r)$ of runs of length $r$ at gray level $g$ observed within $\\mathbf{M}$ along $\\vec{d}$.\n\nConstruct an algorithm that, using a single pass per line along $\\vec{d}$, detects runs and thereby constructs the GLRLM. The algorithm must produce runs that are maximal with respect to mask connectivity and gray-level homogeneity. From the constructed GLRLM, compute the following derived quantities:\n- The total number of runs $N_r$.\n- The maximum run length $r_{\\max}$.\n- Short Run Emphasis (SRE), defined in terms of GLRLM and appropriate normalization.\n- Run-Length Non-Uniformity (RLNU), defined in terms of GLRLM and appropriate normalization.\n\nYour implementation must:\n- Scan each maximal line along $\\vec{d}$ exactly once and segment it into runs by detecting changes in gray level or mask connectivity.\n- Argue and verify programmatically that runs are maximal, by checking that no run can be extended by one step along $\\vec{d}$ without violating mask connectivity or gray-level homogeneity.\n- Compute SRE and RLNU from the GLRLM.\n\nReport floating-point outputs rounded to six decimal places. For each test case, the program must return a list containing $[N_r, r_{\\max}, \\text{SRE}, \\text{RLNU}, \\text{maximal\\_ok}]$, where $\\text{maximal\\_ok}$ is a boolean indicating whether all detected runs satisfy maximality. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where each $result_i$ is itself the list described above with no spaces.\n\nUse the following test suite, which exercises the algorithm on different images, masks, and directions. In all cases, gray levels are integers already discretized, and the mask uses $1$ for $\\text{True}$ and $0$ for $\\text{False}$.\n\nTest Case $1$ (general case, horizontal scan):\n- Image $\\mathbf{I}_1$:\n$$\n\\begin{bmatrix}\n1 & 1 & 2 & 2 & 2 \\\\\n1 & 3 & 3 & 2 & 2 \\\\\n1 & 3 & 3 & 2 & 4 \\\\\n4 & 4 & 3 & 3 & 4 \\\\\n4 & 4 & 4 & 3 & 4\n\\end{bmatrix}\n$$\n- Mask $\\mathbf{M}_1$:\n$$\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1 & 1\n\\end{bmatrix}\n$$\n- Direction $\\vec{d}_1 = (0,1)$.\n\nTest Case $2$ (homogeneous ROI, vertical scan):\n- Image $\\mathbf{I}_2$:\n$$\n\\begin{bmatrix}\n5 & 5 & 5 & 5 \\\\\n5 & 5 & 5 & 5 \\\\\n5 & 5 & 5 & 5 \\\\\n5 & 5 & 5 & 5\n\\end{bmatrix}\n$$\n- Mask $\\mathbf{M}_2$:\n$$\n\\begin{bmatrix}\n1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1\n\\end{bmatrix}\n$$\n- Direction $\\vec{d}_2 = (1,0)$.\n\nTest Case $3$ (alternating gray levels with holes, diagonal scan):\n- Image $\\mathbf{I}_3$:\n$$\n\\begin{bmatrix}\n1 & 2 & 1 & 2 & 1 \\\\\n2 & 1 & 2 & 1 & 2 \\\\\n1 & 2 & 1 & 2 & 1 \\\\\n2 & 1 & 2 & 1 & 2 \\\\\n1 & 2 & 1 & 2 & 1\n\\end{bmatrix}\n$$\n- Mask $\\mathbf{M}_3$:\n$$\n\\begin{bmatrix}\n1 & 0 & 1 & 0 & 1 \\\\\n0 & 1 & 0 & 1 & 0 \\\\\n1 & 0 & 1 & 0 & 1 \\\\\n0 & 1 & 0 & 1 & 0 \\\\\n1 & 0 & 1 & 0 & 1\n\\end{bmatrix}\n$$\n- Direction $\\vec{d}_3 = (1,1)$.\n\nTest Case $4$ (empty mask, anti-diagonal scan):\n- Image $\\mathbf{I}_4$:\n$$\n\\begin{bmatrix}\n7 & 8 & 9 \\\\\n6 & 5 & 4 \\\\\n3 & 2 & 1\n\\end{bmatrix}\n$$\n- Mask $\\mathbf{M}_4$:\n$$\n\\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n$$\n- Direction $\\vec{d}_4 = (1,-1)$.\n\nYour program must aggregate the results from these four test cases into a single list printed on one line, formatted exactly as a comma-separated list enclosed in square brackets with no spaces. Each floating-point number must be rounded to six decimal places.",
            "solution": "The provided problem requires the construction of a Gray-Level Run-Length Matrix (GLRLM) and the computation of several derived texture features. The problem is well-defined, scientifically grounded in the field of radiomics, and computationally tractable. The only minor ambiguity lies in the definitions of Short Run Emphasis (SRE) and Run-Length Non-Uniformity (RLNU), which are stated to require \"appropriate normalization\". I will proceed by adopting the standard definitions from foundational literature, where normalization is performed by the total number of runs, $N_r$.\n\nThe solution is structured into three main components: (1) an algorithm to identify all maximal runs within the region of interest (ROI) for a given direction, (2) a programmatic verification of this maximality condition, and (3) the computation of the specified features from the resulting GLRLM.\n\n**1. Algorithmic Framework for Run Detection and GLRLM Construction**\n\nThe core of the task is to scan an image $\\mathbf{I}$ and its corresponding mask $\\mathbf{M}$ along a specified direction $\\vec{d}=(d_r, d_c)$ to find all runs. A run is a maximal contiguous sequence of pixels along a line having the same gray level and being within the mask.\n\nA key challenge is to ensure that each such run is identified exactly once. This can be achieved by processing maximal *lines* of connected pixels within the mask. A maximal line is initiated at a \"starting pixel\". A pixel at coordinate $(r,c)$ is defined as a starting pixel if it is inside the mask (i.e., $\\mathbf{M}(r,c) = 1$) and the preceding pixel along the direction $\\vec{d}$, i.e., $(r-d_r, c-d_c)$, is either outside the image boundaries or outside the mask (i.e., $\\mathbf{M}(r-d_r, c-d_c) = 0$).\n\nThe algorithm proceeds as follows:\n1.  Iterate through every pixel $(r,c)$ of the image.\n2.  For each pixel, check if it qualifies as a line-starting pixel based on the condition above.\n3.  If $(r,c)$ is a starting pixel, traverse the line by repeatedly stepping by $\\vec{d}$, i.e., following the sequence $(r,c), (r+d_r, c+d_c), (r+2d_r, c+2d_c), \\dots$. This traversal continues as long as the current pixel remains within the image boundaries and inside the mask.\n4.  This line is then segmented into one or more runs. A run begins at the current position on the line. It is extended as long as subsequent pixels on the line share the same gray level. A run terminates when either the gray level changes or the line ends (by exiting the mask or the image boundaries).\n5.  Each time a run terminates, its properties—gray level $g$, run length $r$, and start position $(r_{start}, c_{start})$—are recorded. The line traversal then continues from the pixel that terminated the previous run, potentially starting a new run.\n6.  This process guarantees that every pixel within the mask is part of exactly one processed run, and the \"single pass per line\" constraint is satisfied.\n7.  After collecting all runs, the GLRLM, $P(g,r)$, is constructed by counting the occurrences of each $(g,r)$ pair.\n\n**2. Programmatic Verification of Run Maximality**\n\nThe problem requires programmatic verification that all detected runs are maximal. A run is maximal if it cannot be extended by one pixel in either direction (along $\\vec{d}$ or $-\\vec{d}$) without violating either gray-level homogeneity or mask connectivity.\n\nAlthough the run-finding algorithm is designed to produce maximal runs, an explicit verification step serves as a rigorous confirmation of correctness. For each detected run with gray level $g$, length $r$, and starting position $(r_s, c_s)$:\n-   The end position is $(r_e, c_e) = (r_s + (r-1)d_r, c_s + (r-1)d_c)$.\n-   **Backward Check**: The preceding pixel at $(r_s-d_r, c_s-d_c)$ is examined. If this pixel exists within the mask, its gray level must be different from $g$. If it is within the mask and has a gray level equal to $g$, the run is not maximal at its start.\n-   **Forward Check**: The succeeding pixel at $(r_e+d_r, c_e+d_c)$ is examined. If this pixel exists within the mask, its gray level must be different from $g$. If it is within the mask and has a gray level equal to $g$, the run is not maximal at its end.\n\nA boolean flag, `maximal_ok`, tracks the outcome of this verification across all runs. It is `True` if all runs pass both checks, and `False` otherwise. For an empty set of runs (i.e., empty ROI), the condition is vacuously `True`.\n\n**3. Feature Computation from the GLRLM**\n\nFrom the constructed GLRLM, $P(g,r)$, the following features are computed. Let $N_g$ be the number of gray levels and $N_{rl}$ be the maximum run length.\n\n-   **Total Number of Runs ($N_r$)**: The total count of runs in the ROI.\n    $$ N_r = \\sum_{g=1}^{N_g} \\sum_{r=1}^{N_{rl}} P(g,r) $$\n    This is the sum of all entries in the GLRLM.\n\n-   **Maximum Run Length ($r_{\\max}$)**: The longest run length observed in the ROI.\n    $$ r_{\\max} = \\max \\{r \\mid \\exists g: P(g,r) > 0 \\} $$\n\n-   **Short Run Emphasis (SRE)**: This feature accentuates shorter runs.\n    $$ \\text{SRE} = \\frac{1}{N_r} \\sum_{g=1}^{N_g} \\sum_{r=1}^{N_{rl}} \\frac{P(g,r)}{r^2} $$\n\n-   **Run-Length Non-Uniformity (RLNU)**: This feature measures the heterogeneity of run lengths.\n    $$ \\text{RLNU} = \\frac{1}{N_r} \\sum_{r=1}^{N_{rl}} \\left( \\sum_{g=1}^{N_g} P(g,r) \\right)^2 $$\n\nFor the edge case of an empty ROI where no runs are found ($N_r=0$), all features ($N_r, r_{\\max}, \\text{SRE}, \\text{RLNU}$) are defined to be $0$. This prevents division by zero and provides a meaningful result.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef compute_glrlm_features(image: list[list[int]], mask: list[list[int]], d_vec: tuple[int, int]):\n    \"\"\"\n    Computes the Gray-Level Run-Length Matrix (GLRLM) and derived features for a\n    given 2D image, a binary mask, and a direction vector.\n\n    The algorithm identifies maximal lines of connected pixels within the mask and segments\n    them into runs of constant gray level. It then computes features from the\n    resulting run statistics and programmatically verifies the maximality of each run.\n    \"\"\"\n    img = np.array(image, dtype=np.int32)\n    msk = np.array(mask, dtype=np.int32)\n    h, w = img.shape\n    dr, dc = d_vec\n\n    runs_list = []  # Stores tuples of (gray_level, run_length, start_pos_tuple)\n\n    # 1. Identify all runs by iterating through potential line starts.\n    for r_start in range(h):\n        for c_start in range(w):\n            \n            # A pixel is a line start if it's in the mask and the previous pixel along -d is not.\n            is_line_start = False\n            if msk[r_start, c_start] == 1:\n                prev_r, prev_c = r_start - dr, c_start - dc\n                if not (0 <= prev_r < h and 0 <= prev_c < w):\n                    is_line_start = True  # Previous pixel is out of bounds\n                elif msk[prev_r, prev_c] == 0:\n                    is_line_start = True  # Previous pixel is outside the mask\n\n            if is_line_start:\n                # A maximal line starts here. Traverse it and segment it into runs.\n                line_r, line_c = r_start, c_start\n                while 0 <= line_r < h and 0 <= line_c < w and msk[line_r, line_c] == 1:\n                    # Start of a new run on this line\n                    run_start_r, run_start_c = line_r, line_c\n                    current_gray_level = img[run_start_r, run_start_c]\n                    current_run_length = 0\n                    \n                    # Extend this run as long as mask and gray level are constant\n                    run_r, run_c = run_start_r, run_start_c\n                    while (0 <= run_r < h and 0 <= run_c < w and\n                           msk[run_r, run_c] == 1 and\n                           img[run_r, run_c] == current_gray_level):\n                        current_run_length += 1\n                        run_r += dr\n                        run_c += dc\n                    \n                    runs_list.append((current_gray_level, current_run_length, (run_start_r, run_start_c)))\n                    \n                    # Advance line cursor to the end of the processed run to start the next one\n                    line_r, line_c = run_r, run_c\n\n    # 2. Handle the edge case of an empty ROI where no runs are found.\n    if not runs_list:\n        return [0, 0, 0.0, 0.0, True]\n\n    # 3. Programmatically verify that every detected run is maximal.\n    maximal_ok = True\n    for g, length, start_pos in runs_list:\n        sr, sc = start_pos\n        \n        # Check if the run could have been extended backwards.\n        prev_r, prev_c = sr - dr, sc - dc\n        if 0 <= prev_r < h and 0 <= prev_c < w and msk[prev_r, prev_c] == 1:\n            if img[prev_r, prev_c] == g:\n                maximal_ok = False\n                break\n        \n        # Check if the run could have been extended forwards.\n        end_r, end_c = sr + (length - 1) * dr, sc + (length - 1) * dc\n        next_r, next_c = end_r + dr, end_c + dc\n        if 0 <= next_r < h and 0 <= next_c < w and msk[next_r, next_c] == 1:\n            if img[next_r, next_c] == g:\n                maximal_ok = False\n                break\n    if not maximal_ok: # This case is not expected with the current logic.\n        return [-1, -1, -1.0, -1.0, False]\n\n    # 4. Construct GLRLM and compute derived features.\n    \n    # Using a dictionary for the sparse GLRLM: glrlm[(g, r)] = count\n    glrlm = {}\n    max_run_found = 0\n    for g, r, _ in runs_list:\n        if r > max_run_found:\n            max_run_found = r\n        glrlm[(g, r)] = glrlm.get((g, r), 0) + 1\n\n    # Nr: Total number of runs\n    Nr = len(runs_list)\n    # r_max: Maximum run length\n    rmax = max_run_found\n\n    # SRE: Short Run Emphasis\n    sre_sum = 0.0\n    for (g, r), count in glrlm.items():\n        sre_sum += count / (r * r)\n    sre = sre_sum / Nr\n\n    # RLNU: Run-Length Non-Uniformity\n    run_length_sums = {} # Maps run length r to sum over g of R(g,r)\n    for (g, r), count in glrlm.items():\n        run_length_sums[r] = run_length_sums.get(r, 0) + count\n        \n    rln_sum = sum(s**2 for s in run_length_sums.values())\n    rln = rln_sum / Nr\n\n    return [Nr, rmax, sre, rln, maximal_ok]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            [\n                [1, 1, 2, 2, 2],\n                [1, 3, 3, 2, 2],\n                [1, 3, 3, 2, 4],\n                [4, 4, 3, 3, 4],\n                [4, 4, 4, 3, 4]\n            ],\n            [\n                [1, 1, 1, 1, 1],\n                [1, 1, 1, 1, 1],\n                [1, 1, 1, 1, 1],\n                [1, 1, 1, 1, 1],\n                [1, 1, 1, 1, 1]\n            ],\n            (0, 1)\n        ),\n        (\n            [\n                [5, 5, 5, 5],\n                [5, 5, 5, 5],\n                [5, 5, 5, 5],\n                [5, 5, 5, 5]\n            ],\n            [\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1]\n            ],\n            (1, 0)\n        ),\n        (\n            [\n                [1, 2, 1, 2, 1],\n                [2, 1, 2, 1, 2],\n                [1, 2, 1, 2, 1],\n                [2, 1, 2, 1, 2],\n                [1, 2, 1, 2, 1]\n            ],\n            [\n                [1, 0, 1, 0, 1],\n                [0, 1, 0, 1, 0],\n                [1, 0, 1, 0, 1],\n                [0, 1, 0, 1, 0],\n                [1, 0, 1, 0, 1]\n            ],\n            (1, 1)\n        ),\n        (\n            [\n                [7, 8, 9],\n                [6, 5, 4],\n                [3, 2, 1]\n            ],\n            [\n                [0, 0, 0],\n                [0, 0, 0],\n                [0, 0, 0]\n            ],\n            (1, -1)\n        )\n    ]\n\n    results = []\n    for image, mask, d_vec in test_cases:\n        result = compute_glrlm_features(image, mask, d_vec)\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    # Floating point numbers are formatted to 6 decimal places.\n    # The list representation must not have spaces.\n    formatted_results = []\n    for res in results:\n        res_copy = res[:] # Create a copy to modify for printing\n        res_copy[2] = f\"{res_copy[2]:.6f}\"\n        res_copy[3] = f\"{res_copy[3]:.6f}\"\n        res_str = '[' + ','.join(map(str, res_copy)) + ']'\n        formatted_results.append(res_str)\n        \n    print('[' + ','.join(formatted_results) + ']')\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world medical imaging is rarely limited to a single 2D slice or one direction; robust analysis requires a more comprehensive approach. This advanced practice challenges you to scale up your algorithm to handle 3D image volumes and aggregate run-length statistics over multiple directions, mirroring a true radiomics workflow. This exercise will not only solidify your implementation skills but also prompt you to consider the computational efficiency required for processing large-scale medical data .",
            "id": "4564440",
            "problem": "You are given the task of constructing the Gray-Level Run-Length Matrix (GLRLM) in the context of radiomics texture analysis. Consider a quantized image volume with a Region of Interest (ROI) and a finite set of direction vectors. The Gray-Level Run-Length Matrix $P(i,j)$ aggregated over a set of directions $\\mathcal{D}$ counts the number of runs that have gray level $i$ and run length $j$ when traversing the ROI along each direction $\\vec{d}\\in\\mathcal{D}$. A run is a maximal, contiguous sequence of voxels with constant gray level when moving along a direction $\\vec{d}$. Let the number of voxels in the ROI be $N_v$, the number of gray levels be $N_g$, and the maximum observed run length be $N_r$.\n\nStarting only from the fundamental definitions of sequences, runs, array indexing, and summation over discrete structures, design an algorithm that constructs $P(i,j)$ by streaming along lines for each $\\vec{d}\\in\\mathcal{D}$ such that the total work is linear in the number of visited voxels. The algorithm must:\n- Identify line start voxels for each direction $\\vec{d}$ as those ROI voxels whose predecessor along $-\\vec{d}$ is either outside the volume bounds or outside the ROI.\n- Traverse each line in forward direction $\\vec{d}$, detect gray-level changes, and emit exactly one run per maximal constant segment.\n- Accumulate the counts into $P(i,j)$ aggregated over all $\\vec{d}\\in\\mathcal{D}$.\n\nProvide a clear time and memory complexity analysis in terms of $N_v$, $N_g$, $N_r$, and $\\lvert\\mathcal{D}\\rvert$, justified from first principles.\n\nThen, implement a program that applies your algorithm to the following test suite. In all cases, the ROI is the full image volume, and gray levels are labeled as consecutive integers starting at $1$.\n\nTest case $\\mathbf{A}$ ($2$-dimensional):\n- Volume $V\\in\\mathbb{Z}^{3\\times 5}$ with\n$$\nV=\\begin{bmatrix}\n1 & 1 & 2 & 2 & 2\\\\\n1 & 3 & 3 & 3 & 2\\\\\n1 & 1 & 1 & 2 & 2\n\\end{bmatrix}.\n$$\n- Number of gray levels $N_g = 3$.\n- Direction set $\\mathcal{D}=\\{(1,0)\\}$, where $(1,0)$ means moving one step in the column direction.\n\nTest case $\\mathbf{B}$ ($2$-dimensional):\n- Volume $W\\in\\mathbb{Z}^{4\\times 4}$ with\n$$\nW=\\begin{bmatrix}\n1 & 2 & 1 & 2\\\\\n1 & 2 & 1 & 2\\\\\n1 & 2 & 1 & 2\\\\\n1 & 2 & 1 & 2\n\\end{bmatrix}.\n$$\n- Number of gray levels $N_g = 2$.\n- Direction set $\\mathcal{D}=\\{(1,0),(0,1)\\}$.\n\nTest case $\\mathbf{C}$ ($3$-dimensional):\n- Volume $X\\in\\mathbb{Z}^{2\\times 2\\times 3}$ given by two slices along the first axis (listed for $z=0$ and $z=1$):\n$$\nX[z=0]=\\begin{bmatrix}\n1 & 1 & 1\\\\\n2 & 2 & 2\n\\end{bmatrix},\\quad\nX[z=1]=\\begin{bmatrix}\n1 & 2 & 2\\\\\n1 & 1 & 2\n\\end{bmatrix}.\n$$\n- Number of gray levels $N_g = 2$.\n- Direction set $\\mathcal{D}=\\{(1,0,0),(0,1,0),(0,0,1)\\}$, corresponding respectively to steps along the last, middle, and first axes of the array.\n\nFrom the constructed GLRLM $P(i,j)$ aggregated over all directions in $\\mathcal{D}$, compute for each test case the following quantities:\n- Total runs $R=\\sum_{i=1}^{N_g}\\sum_{j=1}^{N_r} P(i,j)$.\n- Short Run Emphasis (SRE).\n- Long Run Emphasis (LRE).\n- Gray-Level Non-Uniformity (GLNU).\n- Run Length Non-Uniformity (RLNU).\n- Run Percentage (RP), defined as the ratio of the total runs to the number of voxels in the ROI.\n\nYour program must implement the linear-time streaming algorithm described above to build $P(i,j)$, then compute the listed quantities directly from $P(i,j)$ using only their definitions, and finally output the results for the three test cases in a single line as a list of lists:\n- For each test case, output the list $[R,\\mathrm{SRE},\\mathrm{LRE},\\mathrm{GLNU},\\mathrm{RLNU},\\mathrm{RP}]$.\n- The global output must be a single line containing a list of the three per-case lists, for example $[[\\cdot],[\\cdot],[\\cdot]]$.\n- Round all real-valued quantities to exactly $6$ decimal places. Print $R$ as an integer. There must be no spaces anywhere in the output line.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each per-case result is itself a comma-separated list enclosed in square brackets, and all floating-point values are rounded to exactly $6$ decimal places, for example\n$$\n[[R_A,\\mathrm{SRE}_A,\\mathrm{LRE}_A,\\mathrm{GLNU}_A,\\mathrm{RLNU}_A,\\mathrm{RP}_A],[R_B,\\mathrm{SRE}_B,\\mathrm{LRE}_B,\\mathrm{GLNU}_B,\\mathrm{RLNU}_B,\\mathrm{RP}_B],[R_C,\\mathrm{SRE}_C,\\mathrm{LRE}_C,\\mathrm{GLNU}_C,\\mathrm{RLNU}_C,\\mathrm{RP}_C]].\n$$",
            "solution": "The user's request is to develop and implement an algorithm for constructing the Gray-Level Run-Length Matrix (GLRLM) and computing several radiomics features from it. The problem is well-defined, scientifically sound, and provides specific test cases for validation.\n\n### Principle-Based Algorithm Design\n\nThe core task is to compute the GLRLM, $P(i,j)$, which is a matrix where each element counts the number of runs of gray level $i$ with length $j$. This must be done for a given image volume, a Region of Interest (ROI), and a set of directions $\\mathcal{D}$. The problem specifies an algorithmic approach that must be linear in the number of visited voxels. This suggests an efficient streaming or traversal method that avoids redundant computations.\n\nThe fundamental principles guiding the algorithm are:\n1.  **Decomposition by Direction**: The total GLRLM is the sum of GLRLMs computed for each individual direction $\\vec{d} \\in \\mathcal{D}$.\n    $$\n    P(i,j) = \\sum_{\\vec{d} \\in \\mathcal{D}} P_{\\vec{d}}(i,j)\n    $$\n2.  **Line-by-Line Traversal**: For a fixed direction $\\vec{d}$, the image volume can be partitioned into a set of parallel lines. To ensure each voxel is visited exactly once per direction, we can identify a unique set of \"start voxels\" for these lines and traverse each line from start to end.\n3.  **Start Voxel Identification**: As per the problem, a start voxel for a direction $\\vec{d}$ is a voxel within the ROI whose predecessor (at position $-\\vec{d}$) is outside the image bounds or outside the ROI. For the given test cases, where the ROI is the full volume and directions are axial (e.g., along the x-axis), this condition simplifies. For instance, for a direction along the positive x-axis, the start voxels are all those on the plane $x=0$.\n4.  **Run Detection by Streaming**: Traversing a line, a \"run\" is a contiguous sequence of voxels with the same gray level. By streaming along the line, we can detect changes in gray level. Each time a gray level change is encountered or the end of the line is reached, the completed run (defined by its gray level and length) is recorded.\n\nBased on these principles, the algorithm is as follows:\n\n1.  **Initialization**:\n    - Let the image volume be $V$ of shape $(S_0, S_1, ..., S_{N-1})$. The number of voxels is $N_v = \\prod S_k$.\n    - Initialize an integer-valued GLRLM, $P$, of size $(N_g+1) \\times (L_{\\max}+1)$ to all zeros, where $N_g$ is the number of gray levels and $L_{\\max} = \\max(S_0, ..., S_{N-1})$ is the maximum possible run length. We use 1-based indexing for gray levels and run lengths.\n\n2.  **Directional Aggregation Loop**:\n    - For each direction vector $\\vec{d} \\in \\mathcal{D}$:\n        a. **Identify Traversal Axis**: For the given axial directions, determine the axis $k$ along which the traversal will occur. For a vector $\\vec{d}$, this is the index of its single non-zero component.\n        b. **Identify Start Voxels**: The set of start voxels forms a hyperplane where the coordinate on axis $k$ is $0$. Iterate through all a-priori combinations of indices for all axes other than $k$.\n        c. **Line Traversal**: For each start voxel $\\vec{p}_{\\text{start}}$:\n            i.   Set the current position $\\vec{p} = \\vec{p}_{\\text{start}}$.\n            ii.  While $\\vec{p}$ is within the volume boundaries:\n                 - A new run begins at $\\vec{p}$. Read its gray level $i = V[\\vec{p}]$.\n                 - Initialize its length, $j=0$.\n                 - Advance $\\vec{p}$ along the line, incrementing $j$, as long as the position remains in-bounds and the gray level is constant.\n                 - Once the run terminates (due to boundary or gray-level change), increment the corresponding counter in the matrix: $P(i, j) \\leftarrow P(i, j) + 1$.\n                 - The outer `while` loop continues from the new position $\\vec{p}$, starting the detection of the next run on the same line.\n\n3.  **Feature Computation**:\n    - After processing all directions, $P$ holds the final aggregated counts.\n    - Let $R = \\sum_{i,j} P(i,j)$ be the total number of runs. If $R=0$, all features are $0$.\n    - The features are computed from their standard definitions:\n      - Short Run Emphasis (SRE): $\\text{SRE} = \\frac{1}{R} \\sum_{i=1}^{N_g} \\sum_{j=1}^{N_r} \\frac{P(i,j)}{j^2}$\n      - Long Run Emphasis (LRE): $\\text{LRE} = \\frac{1}{R} \\sum_{i=1}^{N_g} \\sum_{j=1}^{N_r} P(i,j) \\cdot j^2$\n      - Gray-Level Non-Uniformity (GLNU): $\\text{GLNU} = \\frac{1}{R} \\sum_{i=1}^{N_g} \\left( \\sum_{j=1}^{N_r} P(i,j) \\right)^2$\n      - Run Length Non-Uniformity (RLNU): $\\text{RLNU} = \\frac{1}{R} \\sum_{j=1}^{N_r} \\left( \\sum_{i=1}^{N_g} P(i,j) \\right)^2$\n      - Run Percentage (RP): $\\text{RP} = R / N_v$\n\n### Complexity Analysis\n\n- **Time Complexity**: The algorithm iterates through $|\\mathcal{D}|$ directions. For each direction, it partitions the volume into lines starting from a hyperplane. Each voxel in the volume is part of exactly one such line and is visited exactly once during the traversal for that direction. Therefore, the work for one direction is proportional to the number of voxels, $O(N_v)$. The total time complexity for building the GLRLM is $O(|\\mathcal{D}| \\cdot N_v)$. The subsequent feature calculation from the matrix $P$ takes $O(N_g \\cdot N_r)$ time, where $N_r$ is the maximum observed run length. Since $N_g \\cdot N_r \\ll |\\mathcal{D}| \\cdot N_v$ in typical scenarios, the overall time complexity is dominated by the GLRLM construction, meeting the required linear dependency on the number of visited voxels.\n\n- **Memory Complexity**: The algorithm requires storage for the input volume, $O(N_v)$, and the GLRLM, $O(N_g \\cdot N_r)$. $N_r$ is bounded by the largest dimension of the volume, $L_{\\max}$. Thus, the memory complexity is $O(N_v + N_g \\cdot L_{\\max})$. No auxiliary data structures of size comparable to the volume are needed per direction, making the memory usage efficient.\n\nThis design provides a correct and efficient solution that satisfies all constraints of the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef compute_glrlm_and_features(volume, n_g, directions):\n    \"\"\"\n    Computes the GLRLM and derived features for a single test case.\n\n    This function implements the linear-time streaming algorithm described\n    in the problem statement. It iterates through each specified direction,\n    identifies starting voxels for lines parallel to that direction,\n    and traverses each line to count runs of constant gray level.\n    The run counts are aggregated into the Gray-Level Run-Length Matrix (GLRLM).\n    Finally, it computes the six specified texture features from the GLRLM.\n\n    Args:\n        volume (np.ndarray): The input image volume.\n        n_g (int): The number of gray levels.\n        directions (list of tuples): The set of direction vectors.\n\n    Returns:\n        list: A list containing the calculated features:\n              [Total Runs, SRE, LRE, GLNU, RLNU, RP].\n    \"\"\"\n    shape = volume.shape\n    n_dim = volume.ndim\n    max_run_length = 0 if not shape else max(shape)\n    \n    # Initialize GLRLM with 1-based indexing for gray levels and run lengths.\n    P = np.zeros((n_g + 1, max_run_length + 1), dtype=np.int64)\n    \n    for d in directions:\n        # For the given axial directions, find the single axis of traversal.\n        try:\n            axis = next(i for i, val in enumerate(d) if val != 0)\n        except StopIteration:\n            continue # Skip zero vector if present\n\n        # Define the starting hyperplane by creating iteration ranges for all other axes.\n        start_coord_ranges = []\n        for i in range(n_dim):\n            if i == axis:\n                start_coord_ranges.append([0])\n            else:\n                start_coord_ranges.append(range(shape[i]))\n        \n        # Iterate over all starting voxels on the hyperplane.\n        for start_coord_tuple in itertools.product(*start_coord_ranges):\n            current_coord = list(start_coord_tuple)\n            \n            # Traverse the line starting from this voxel.\n            while current_coord[axis] < shape[axis]:\n                run_gray_level = volume[tuple(current_coord)]\n                run_length = 0\n                \n                # Stream along the line to find the length of the current run.\n                while current_coord[axis] < shape[axis] and \\\n                      volume[tuple(current_coord)] == run_gray_level:\n                    run_length += 1\n                    current_coord[axis] += 1\n                \n                # Record the completed run.\n                P[run_gray_level, run_length] += 1\n\n    # Find the maximum observed run length to trim the matrix.\n    n_r_observed = 0\n    if np.any(P):\n        n_r_observed = int(np.max(np.where(P.sum(axis=0) > 0)[0]))\n\n    if n_r_observed == 0:\n        return [0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        \n    # For calculation, use a 0-indexed matrix for convenience (p_matrix).\n    p_matrix = P[1 : n_g + 1, 1 : n_r_observed + 1]\n\n    R = p_matrix.sum()\n    if R == 0:\n        return [0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        \n    N_v = volume.size\n    \n    j_vector = np.arange(1, n_r_observed + 1, dtype=np.float64)\n    \n    # Short Run Emphasis (SRE)\n    sre_val = np.sum(p_matrix / (j_vector**2)) / R\n    \n    # Long Run Emphasis (LRE)\n    lre_val = np.sum(p_matrix * (j_vector**2)) / R\n    \n    # Gray-Level Non-Uniformity (GLNU)\n    runs_per_gray = p_matrix.sum(axis=1)\n    gln_val = np.sum(runs_per_gray**2) / R\n    \n    # Run Length Non-Uniformity (RLNU)\n    runs_per_length = p_matrix.sum(axis=0)\n    rln_val = np.sum(runs_per_length**2) / R\n    \n    # Run Percentage (RP)\n    rp_val = R / N_v\n    \n    return [int(R), sre_val, lre_val, gln_val, rln_val, rp_val]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final answer.\n    \"\"\"\n    test_cases = [\n        {\n            \"volume\": np.array([\n                [1, 1, 2, 2, 2],\n                [1, 3, 3, 3, 2],\n                [1, 1, 1, 2, 2]\n            ]),\n            \"n_g\": 3,\n            \"directions\": [(0, 1)]  # (d_row, d_col) test case A specifies (1,0) which is column\n        },\n        {\n            \"volume\": np.array([\n                [1, 2, 1, 2],\n                [1, 2, 1, 2],\n                [1, 2, 1, 2],\n                [1, 2, 1, 2]\n            ]),\n            \"n_g\": 2,\n            \"directions\": [(1, 0), (0, 1)]\n        },\n        {\n            \"volume\": np.array([\n                [[1, 1, 1], [2, 2, 2]],\n                [[1, 2, 2], [1, 1, 2]]\n            ]),\n            \"n_g\": 2,\n            \"directions\": [(0, 0, 1), (0, 1, 0), (1, 0, 0)] # Note: numpy axis order is z,y,x\n        }\n    ]\n\n    # Correction for Test Case A: The problem states \"(1,0) means moving one step in the column direction\".\n    # In numpy (row, col) indexing, this is (0,1). The code uses (0,1) for this.\n    # To be consistent with the problem's definition for Case C, where (1,0,0), (0,1,0), (0,0,1) are steps along\n    # last, middle, and first axes, let's map the definitions clearly.\n    # For a 2D array (axis 0=row, axis 1=col), a step in column direction is (0,1). A step in row direction is (1,0).\n    # The original problem for test A had (1,0) but described it as column-wise. This is an inconsistency. The code has (0,1). Let's assume the description (\"column direction\") is correct, so (0,1) is correct for numpy.\n    # For test C, the code has (0,0,1), (0,1,0), (1,0,0) which maps to x, y, z axes (last, middle, first) as per problem desc. This is correct.\n    \n    # I will modify the input in the code to reflect the problem's intent for case A. (1,0) means row-wise. But the problem description says column direction.\n    # Let me trust the code's interpretation and correct the ambiguous comment.\n    test_cases[0][\"directions\"] = [(0, 1)] # \"(1,0)\" in problem text described as column direction, which is (0,1) in (row,col) numpy indexing.\n\n    all_results = []\n    for case in test_cases:\n        result = compute_glrlm_and_features(case[\"volume\"], case[\"n_g\"], case[\"directions\"])\n        all_results.append(result)\n\n    # Format the output string exactly as specified.\n    result_strings = []\n    for res in all_results:\n        r_str = str(res[0])\n        float_strs = [f\"{x:.6f}\" for x in res[1:]]\n        result_strings.append(f\"[{r_str},{','.join(float_strs)}]\")\n            \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}