{
    "hands_on_practices": [
        {
            "introduction": "本练习是掌握灰度游程矩阵 (GLRLM) 特征计算的基础。给定一个简化的 GLRLM，你的任务是直接应用公式计算四个关键的纹理特征。这个过程将帮助你巩固对特征定义的理解，并熟练掌握从矩阵数据中量化纹理信息的核心计算技能。",
            "id": "4564433",
            "problem": "一幅二维医学图像已被离散化为 $N_{g}=3$ 个灰度级，并沿单一固定方向进行分析，以形成一个灰度游程矩阵 (Gray-Level Run-Length Matrix, GLRLM)，该矩阵是计数矩阵 $p(i,j)$，其中 $i \\in \\{1,2,3\\}$ 是灰度级的索引，$j \\in \\{1,2,3\\}$ 是游程长度的索引。GLRLM 编码了在灰度级 $i$ 上，长度恰好为 $j$ 的连续像素游程出现的次数。考虑以下示例 GLRLM（所有条目均为非负整数）：\n$$\np(1,1)=6,\\quad p(1,2)=1,\\quad p(1,3)=0;\\\\\np(2,1)=2,\\quad p(2,2)=0,\\quad p(2,3)=0;\\\\\np(3,1)=0,\\quad p(3,2)=0,\\quad p(3,3)=0.\n$$\n使用 GLRLM 的基本定义及其在放射组学纹理分析中的作用，计算该矩阵的短游程强调 (Short Run Emphasis, SRE)、长游程强调 (Long Run Emphasis, LRE)、低灰度游程强调 (Low Gray-Level Run Emphasis, LGRE) 和高灰度游程强调 (High Gray-Level Run Emphasis, HGRE)。采用灰度级索引 $i=1,2,3$ 和游程长度索引 $j=1,2,3$ 的常规用法，并使用该矩阵所蕴含的总游程数来归一化任何必要的量。将这四个特征值都表示为精确数（例如，有理数），不要四舍五入，并以有序四元组 $\\big(\\mathrm{SRE},\\mathrm{LRE},\\mathrm{LGRE},\\mathrm{HGRE}\\big)$ 的形式报告您的最终答案。然后，简要地定性解释这个 GLRLM 代表哪种纹理类型（例如，它是由短游程还是长游程主导，以及它强调的是低灰度级还是高灰度级）。无需单位。",
            "solution": "问题陈述经过严格评估，被认为是有效的。它在放射组学纹理分析这一成熟领域具有科学依据，问题提出得很好，为得到唯一解提供了所有必要信息，并且其语言和定义是客观的。该问题是从给定的灰度游程矩阵（GLRLM）计算纹理特征的标准计算。\n\n所提供的灰度游程矩阵 $p(i,j)$ 量化了给定灰度级 $i$ 下长度为 $j$ 的游程数量。灰度级的数量为 $N_g=3$，所考虑的最大游程长度也为 $3$。矩阵条目如下：\n$$\np(1,1)=6, \\quad p(1,2)=1, \\quad p(1,3)=0 \\\\\np(2,1)=2, \\quad p(2,2)=0, \\quad p(2,3)=0 \\\\\np(3,1)=0, \\quad p(3,2)=0, \\quad p(3,3)=0\n$$\n我们可以将此 GLRLM 表示为矩阵形式，其中行对应灰度级索引 $i$，列对应游程长度索引 $j$：\n$$\nP = \\begin{pmatrix} p(1,1) & p(1,2) & p(1,3) \\\\ p(2,1) & p(2,2) & p(2,3) \\\\ p(3,1) & p(3,2) & p(3,3) \\end{pmatrix} = \\begin{pmatrix} 6 & 1 & 0 \\\\ 2 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\n第一步是计算图像中的总游程数 $N_z$，即矩阵 $P$ 中所有元素的总和。该值用于归一化。\n$$\nN_z = \\sum_{i=1}^{3} \\sum_{j=1}^{3} p(i,j) = 6 + 1 + 0 + 2 + 0 + 0 + 0 + 0 + 0 = 9\n$$\n现在，我们使用它们的标准定义来计算所要求的四个纹理特征。\n\n1.  **短游程强调 (SRE)**：此特征强调短游程，每个游程的权重与其长度的平方成反比。\n    $$\n    \\mathrm{SRE} = \\frac{1}{N_z} \\sum_{i=1}^{3} \\sum_{j=1}^{3} \\frac{p(i,j)}{j^2}\n    $$\n    代入给定值：\n    $$\n    \\mathrm{SRE} = \\frac{1}{9} \\left( \\frac{p(1,1)}{1^2} + \\frac{p(1,2)}{2^2} + \\frac{p(2,1)}{1^2} \\right) = \\frac{1}{9} \\left( \\frac{6}{1} + \\frac{1}{4} + \\frac{2}{1} \\right)\n    $$\n    $$\n    \\mathrm{SRE} = \\frac{1}{9} \\left( 8 + \\frac{1}{4} \\right) = \\frac{1}{9} \\left( \\frac{32+1}{4} \\right) = \\frac{1}{9} \\left( \\frac{33}{4} \\right) = \\frac{33}{36} = \\frac{11}{12}\n    $$\n\n2.  **长游程强调 (LRE)**：此特征强调长游程，每个游程的权重与其长度的平方成正比。\n    $$\n    \\mathrm{LRE} = \\frac{1}{N_z} \\sum_{i=1}^{3} \\sum_{j=1}^{3} p(i,j) \\cdot j^2\n    $$\n    代入给定值：\n    $$\n    \\mathrm{LRE} = \\frac{1}{9} \\left( p(1,1) \\cdot 1^2 + p(1,2) \\cdot 2^2 + p(2,1) \\cdot 1^2 \\right) = \\frac{1}{9} \\left( 6 \\cdot 1 + 1 \\cdot 4 + 2 \\cdot 1 \\right)\n    $$\n    $$\n    \\mathrm{LRE} = \\frac{1}{9} (6 + 4 + 2) = \\frac{12}{9} = \\frac{4}{3}\n    $$\n\n3.  **低灰度游程强调 (LGRE)**：此特征强调低灰度值的游程，权重与灰度级的平方成反比。\n    $$\n    \\mathrm{LGRE} = \\frac{1}{N_z} \\sum_{i=1}^{3} \\sum_{j=1}^{3} \\frac{p(i,j)}{i^2}\n    $$\n    代入给定值：\n    $$\n    \\mathrm{LGRE} = \\frac{1}{9} \\left( \\frac{p(1,1)}{1^2} + \\frac{p(1,2)}{1^2} + \\frac{p(2,1)}{2^2} \\right) = \\frac{1}{9} \\left( \\frac{6}{1} + \\frac{1}{1} + \\frac{2}{4} \\right)\n    $$\n    $$\n    \\mathrm{LGRE} = \\frac{1}{9} \\left( 7 + \\frac{1}{2} \\right) = \\frac{1}{9} \\left( \\frac{14+1}{2} \\right) = \\frac{15}{18} = \\frac{5}{6}\n    $$\n\n4.  **高灰度游程强调 (HGRE)**：此特征强调高灰度值的游程，权重与灰度级的平方成正比。\n    $$\n    \\mathrm{HGRE} = \\frac{1}{N_z} \\sum_{i=1}^{3} \\sum_{j=1}^{3} p(i,j) \\cdot i^2\n    $$\n    代入给定值：\n    $$\n    \\mathrm{HGRE} = \\frac{1}{9} \\left( (p(1,1)+p(1,2)) \\cdot 1^2 + p(2,1) \\cdot 2^2 \\right) = \\frac{1}{9} \\left( (6+1) \\cdot 1 + 2 \\cdot 4 \\right)\n    $$\n    $$\n    \\mathrm{HGRE} = \\frac{1}{9} (7 + 8) = \\frac{15}{9} = \\frac{5}{3}\n    $$\n\n四个特征值为 $(\\mathrm{SRE}, \\mathrm{LRE}, \\mathrm{LGRE}, \\mathrm{HGRE}) = (\\frac{11}{12}, \\frac{4}{3}, \\frac{5}{6}, \\frac{5}{3})$。\n\n定性地看，高的 SRE 值 $(\\frac{11}{12} \\approx 0.92)$ 接近其最大可能值 $1$，表明短游程占绝对主导地位。这与 GLRLM 中 $9$ 个游程中有 $8$ 个的长度为 $j=1$ 的情况是一致的。这表明纹理是细粒度的或带有噪声的。类似地，较高的 LGRE 值 $(\\frac{5}{6} \\approx 0.83)$ 与 HGRE 值 $(\\frac{5}{3} \\approx 1.67)$ 相比，表明游程集中在较低的灰度级。纯灰度级 $1$ 的纹理将产生 $\\mathrm{LGRE}=1$ 和 $\\mathrm{HGRE}=1$，而纯灰度级 $2$ 的纹理将产生 $\\mathrm{LGRE}=1/4$ 和 $\\mathrm{HGRE}=4$。我们的计算值证实了低灰度级的显著存在。总之，该 GLRLM 代表了一种由短游程主导、且主要出现在低灰度值的细粒度纹理（即，一种“暗”的、精细的纹理）。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{11}{12} & \\frac{4}{3} & \\frac{5}{6} & \\frac{5}{3} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "理论联系实际是科学研究的关键，本练习将带你从图像数据本身出发，构建 GLRLM。你需要设计一个算法来扫描图像、识别像素游程，并最终生成相应的矩阵。这项实践填补了从抽象的数学定义到具体图像分析应用之间的鸿沟，是理解纹理分析工作流程的必要步骤。",
            "id": "4564398",
            "problem": "给定一个具有整数灰度级的二维离散图像 $\\mathbf{I}$ 和一个指示感兴趣区域 (ROI) 的二值掩模 $\\mathbf{M}$。固定一个从 $\\{(0,1),(1,0),(1,1),(1,-1)\\}$ 中选择的网格方向 $\\vec{d}$，其中每一对坐标表示在整数网格上的行列坐标单位步长。沿 $\\vec{d}$ 的一条线定义为从一个有效的起始像素开始，通过重复按 $\\vec{d}$ 步进而获得的最大掩模连接像素序列，其中掩模连通性仅限于由 $\\vec{d}$ 引起的邻接关系。沿 $\\vec{d}$ 的一个行程（run）是线上 $\\mathbf{I}$ 中灰度级保持不变的最大连续子序列。灰度行程长度矩阵 (GLRLM) 统计在 $\\mathbf{M}$ 内部沿 $\\vec{d}$ 方向，对于每个灰度级 $g$ 和行程长度 $r$，观测到的长度为 $r$、灰度级为 $g$ 的行程数量 $R(g,r)$。\n\n构建一个算法，该算法通过沿 $\\vec{d}$ 对每条线进行单次遍历来检测行程，并由此构建 GLRLM。该算法必须生成相对于掩模连通性和灰度同质性而言是最大的行程。从构建的 GLRLM 中，计算以下派生量：\n- 总行程数 $N_r$。\n- 最大行程长度 $r_{\\max}$。\n- 短行程强调 (SRE)，根据 GLRLM 和适当的归一化进行定义。\n- 行程长度非均匀性 (RLN)，根据 GLRLM 和适当的归一化进行定义。\n\n您的实现必须：\n- 沿 $\\vec{d}$ 精确扫描每一条最大线一次，并通过检测灰度级或掩模连通性的变化将其分割成行程。\n- 通过检查没有行程可以在不违反掩模连通性或灰度同质性的情况下沿 $\\vec{d}$ 方向扩展一步，来论证并以编程方式验证行程是最大的。\n- 从 GLRLM 计算 SRE 和 RLN。\n\n报告浮点数输出时，四舍五入到六位小数。对于每个测试用例，程序必须返回一个包含 $[N_r, r_{\\max}, \\text{SRE}, \\text{RLN}, \\text{maximal\\_ok}]$ 的列表，其中 `maximal_ok` 是一个布尔值，指示所有检测到的行程是否都满足最大性。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[result_1,result_2,\\dots]$），其中每个 $result_i$ 本身就是上述描述的列表，且不含空格。\n\n使用以下测试套件，该套件在不同的图像、掩模和方向上对算法进行测试。在所有情况下，灰度级都已经是离散化的整数，掩模使用 `1` 表示 `True`，`0` 表示 `False`。\n\n测试用例 1 (一般情况，水平扫描):\n- 图像 $\\mathbf{I}_1$:\n$$\n\\begin{bmatrix}\n1 & 1 & 2 & 2 & 2 \\\\\n1 & 3 & 3 & 2 & 2 \\\\\n1 & 3 & 3 & 2 & 4 \\\\\n4 & 4 & 3 & 3 & 4 \\\\\n4 & 4 & 4 & 3 & 4\n\\end{bmatrix}\n$$\n- 掩模 $\\mathbf{M}_1$:\n$$\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1 & 1\n\\end{bmatrix}\n$$\n- 方向 $\\vec{d}_1 = (0,1)$。\n\n测试用例 2 (同质 ROI，垂直扫描):\n- 图像 $\\mathbf{I}_2$:\n$$\n\\begin{bmatrix}\n5 & 5 & 5 & 5 \\\\\n5 & 5 & 5 & 5 \\\\\n5 & 5 & 5 & 5 \\\\\n5 & 5 & 5 & 5\n\\end{bmatrix}\n$$\n- 掩模 $\\mathbf{M}_2$:\n$$\n\\begin{bmatrix}\n1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1 \\\\\n1 & 1 & 1 & 1\n\\end{bmatrix}\n$$\n- 方向 $\\vec{d}_2 = (1,0)$。\n\n测试用例 3 (带孔洞的交替灰度级，对角线扫描):\n- 图像 $\\mathbf{I}_3$:\n$$\n\\begin{bmatrix}\n1 & 2 & 1 & 2 & 1 \\\\\n2 & 1 & 2 & 1 & 2 \\\\\n1 & 2 & 1 & 2 & 1 \\\\\n2 & 1 & 2 & 1 & 2 \\\\\n1 & 2 & 1 & 2 & 1\n\\end{bmatrix}\n$$\n- 掩模 $\\mathbf{M}_3$:\n$$\n\\begin{bmatrix}\n1 & 0 & 1 & 0 & 1 \\\\\n0 & 1 & 0 & 1 & 0 \\\\\n1 & 0 & 1 & 0 & 1 \\\\\n0 & 1 & 0 & 1 & 0 \\\\\n1 & 0 & 1 & 0 & 1\n\\end{bmatrix}\n$$\n- 方向 $\\vec{d}_3 = (1,1)$。\n\n测试用例 4 (空掩模，反对角线扫描):\n- 图像 $\\mathbf{I}_4$:\n$$\n\\begin{bmatrix}\n7 & 8 & 9 \\\\\n6 & 5 & 4 \\\\\n3 & 2 & 1\n\\end{bmatrix}\n$$\n- 掩模 $\\mathbf{M}_4$:\n$$\n\\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n$$\n- 方向 $\\vec{d}_4 = (1,-1)$。\n\n您的程序必须将这四个测试用例的结果汇总到一个列表中，并以单行打印，格式为用方括号括起来的逗号分隔列表，不含空格。每个浮点数必须四舍五入到六位小数。",
            "solution": "所给问题要求构建一个灰度行程长度矩阵 (GLRLM) 并计算几个派生的纹理特征。该问题定义明确，在放射组学领域有科学依据，并且计算上是可行的。唯一的小歧义在于短行程强调 (SRE) 和行程长度非均匀性 (RLN) 的定义，它们被表述为需要“适当的归一化”。我将采用基础文献中的标准定义，其中归一化是通过总行程数 $N_r$ 来执行的。\n\n解决方案分为三个主要部分：(1) 一种用于在给定方向上识别感兴趣区域 (ROI) 内所有最大行程的算法，(2) 对此最大性条件的编程验证，以及 (3) 从生成的 GLRLM 中计算指定特征。\n\n**1. 用于行程检测和 GLRLM 构建的算法框架**\n\n任务的核心是沿指定方向 $\\vec{d}=(d_r, d_c)$ 扫描图像 $\\mathbf{I}$ 及其对应的掩模 $\\mathbf{M}$ 以找到所有行程。行程是沿一条线具有相同灰度级且在掩模内的最大连续像素序列。\n\n一个关键的挑战是确保每个这样的行程只被识别一次。这可以通过处理掩模内连接像素的最大*线*来实现。一条最大线从一个“起始像素”开始。坐标为 $(r,c)$ 的像素被定义为起始像素，如果它在掩模内部（即 $\\mathbf{M}(r,c) = 1$），并且沿方向 $-\\vec{d}$ 的前一个像素，即 $(r-d_r, c-d_c)$，要么在图像边界之外，要么在掩模之外（即 $\\mathbf{M}(r-d_r, c-d_c) = 0$）。\n\n算法流程如下：\n1.  遍历图像的每个像素 $(r,c)$。\n2.  对于每个像素，根据上述条件检查它是否符合作为线起始像素的资格。\n3.  如果 $(r,c)$ 是一个起始像素，则通过重复按 $\\vec{d}$ 步进的方式遍历该线，即遵循序列 $(r,c), (r+d_r, c+d_c), (r+2d_r, c+2d_c), \\dots$。只要当前像素保持在图像边界和掩模内部，此遍历就继续。\n4.  然后，这条线被分割成一个或多个行程。一个行程从线上的当前位置开始。只要线上的后续像素具有相同的灰度级，它就会被扩展。当灰度级发生变化或线结束（通过离开掩模或图像边界）时，行程终止。\n5.  每当一个行程终止时，其属性——灰度级 $g$、行程长度 $r$ 和起始位置 $(r_{start}, c_{start})$——都会被记录下来。然后，线路遍历从终止前一个行程的像素继续，可能会开始一个新的行程。\n6.  此过程保证掩模内的每个像素都恰好属于一个已处理的行程，并且满足“每条线单次遍历”的约束。\n7.  收集所有行程后，通过计算每个 $(g,r)$ 对的出现次数来构建 GLRLM, $R(g,r)$。\n\n**2. 行程最大性的编程验证**\n\n问题要求以编程方式验证所有检测到的行程都是最大的。如果一个行程不能在任一方向（沿 $\\vec{d}$ 或 $-\\vec{d}$）上扩展一个像素而不违反灰度同质性或掩模连通性，则该行程是最大的。\n\n尽管行程查找算法旨在生成最大行程，但明确的验证步骤可作为对正确性的严格确认。对于每个检测到的具有灰度级 $g$、长度 $r$ 和起始位置 $(r_s, c_s)$ 的行程：\n-   结束位置为 $(r_e, c_e) = (r_s + (r-1)d_r, c_s + (r-1)d_c)$。\n-   **向后检查**：检查位于 $(r_s-d_r, c_s-d_c)$ 的前一个像素。如果该像素存在于掩模内，其灰度级必须与 $g$ 不同。如果它在掩模内且灰度级等于 $g$，则该行程在其起点不是最大的。\n-   **向前检查**：检查位于 $(r_e+d_r, c_e+d_c)$ 的后一个像素。如果该像素存在于掩模内，其灰度级必须与 $g$ 不同。如果它在掩模内且灰度级等于 $g$，则该行程在其终点不是最大的。\n\n一个布尔标志 `maximal_ok` 跟踪所有行程的验证结果。如果所有行程都通过了这两项检查，则为 `True`，否则为 `False`。对于空的行程集合（即空的 ROI），该条件是无意义地满足为 `True` 的。\n\n**3. 从 GLRLM 计算特征**\n\n从构建的 GLRLM $R(g,r)$ 中，计算以下特征。设 $N_g$ 为灰度级数， $N_{rl}$ 为最大行程长度。\n\n-   **总行程数 ($N_r$)**：ROI 中的总行程计数。\n    $$ N_r = \\sum_{g=1}^{N_g} \\sum_{r=1}^{N_{rl}} R(g,r) $$\n    这是 GLRLM 中所有条目的总和。\n\n-   **最大行程长度 ($r_{\\max}$)**：在 ROI 中观察到的最长行程长度。\n    $$ r_{\\max} = \\max \\{r \\mid \\exists g: R(g,r) > 0 \\} $$\n\n-   **短行程强调 (SRE)**：此特征强调较短的行程。\n    $$ \\text{SRE} = \\frac{1}{N_r} \\sum_{g=1}^{N_g} \\sum_{r=1}^{N_{rl}} \\frac{R(g,r)}{r^2} $$\n\n-   **行程长度非均匀性 (RLN)**：此特征衡量行程长度的异质性。\n    $$ \\text{RLN} = \\frac{1}{N_r} \\sum_{r=1}^{N_{rl}} \\left( \\sum_{g=1}^{N_g} R(g,r) \\right)^2 $$\n\n对于没有发现行程的空 ROI 的边缘情况（$N_r=0$），所有特征（$N_r, r_{\\max}, \\text{SRE}, \\text{RLN}$）均定义为 $0$。这可以防止除以零并提供有意义的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef compute_glrlm_features(image: list[list[int]], mask: list[list[int]], d_vec: tuple[int, int]):\n    \"\"\"\n    Computes the Gray-Level Run-Length Matrix (GLRLM) and derived features for a\n    given 2D image, a binary mask, and a direction vector.\n\n    The algorithm identifies maximal lines of connected pixels within the mask and segments\n    them into runs of constant gray level. It then computes features from the\n    resulting run statistics and programmatically verifies the maximality of each run.\n    \"\"\"\n    img = np.array(image, dtype=np.int32)\n    msk = np.array(mask, dtype=np.int32)\n    h, w = img.shape\n    dr, dc = d_vec\n\n    runs_list = []  # Stores tuples of (gray_level, run_length, start_pos_tuple)\n\n    # 1. Identify all runs by iterating through potential line starts.\n    for r_start in range(h):\n        for c_start in range(w):\n            \n            # A pixel is a line start if it's in the mask and the previous pixel along -d is not.\n            is_line_start = False\n            if msk[r_start, c_start] == 1:\n                prev_r, prev_c = r_start - dr, c_start - dc\n                if not (0 = prev_r  h and 0 = prev_c  w):\n                    is_line_start = True  # Previous pixel is out of bounds\n                elif msk[prev_r, prev_c] == 0:\n                    is_line_start = True  # Previous pixel is outside the mask\n\n            if is_line_start:\n                # A maximal line starts here. Traverse it and segment it into runs.\n                line_r, line_c = r_start, c_start\n                while 0 = line_r  h and 0 = line_c  w and msk[line_r, line_c] == 1:\n                    # Start of a new run on this line\n                    run_start_r, run_start_c = line_r, line_c\n                    current_gray_level = img[run_start_r, run_start_c]\n                    current_run_length = 0\n                    \n                    # Extend this run as long as mask and gray level are constant\n                    run_r, run_c = run_start_r, run_start_c\n                    while (0 = run_r  h and 0 = run_c  w and\n                           msk[run_r, run_c] == 1 and\n                           img[run_r, run_c] == current_gray_level):\n                        current_run_length += 1\n                        run_r += dr\n                        run_c += dc\n                    \n                    runs_list.append((current_gray_level, current_run_length, (run_start_r, run_start_c)))\n                    \n                    # Advance line cursor to the end of the processed run to start the next one\n                    line_r, line_c = run_r, run_c\n\n    # 2. Handle the edge case of an empty ROI where no runs are found.\n    if not runs_list:\n        return [0, 0, 0.0, 0.0, True]\n\n    # 3. Programmatically verify that every detected run is maximal.\n    maximal_ok = True\n    for g, length, start_pos in runs_list:\n        sr, sc = start_pos\n        \n        # Check if the run could have been extended backwards.\n        prev_r, prev_c = sr - dr, sc - dc\n        if 0 = prev_r  h and 0 = prev_c  w and msk[prev_r, prev_c] == 1:\n            if img[prev_r, prev_c] == g:\n                maximal_ok = False\n                break\n        \n        # Check if the run could have been extended forwards.\n        end_r, end_c = sr + (length - 1) * dr, sc + (length - 1) * dc\n        next_r, next_c = end_r + dr, end_c + dc\n        if 0 = next_r  h and 0 = next_c  w and msk[next_r, next_c] == 1:\n            if img[next_r, next_c] == g:\n                maximal_ok = False\n                break\n    if not maximal_ok: # This case is not expected with the current logic.\n        return [-1, -1, -1.0, -1.0, False]\n\n    # 4. Construct GLRLM and compute derived features.\n    \n    # Using a dictionary for the sparse GLRLM: glrlm[(g, r)] = count\n    glrlm = {}\n    max_run_found = 0\n    for g, r, _ in runs_list:\n        if r > max_run_found:\n            max_run_found = r\n        glrlm[(g, r)] = glrlm.get((g, r), 0) + 1\n\n    # Nr: Total number of runs\n    Nr = len(runs_list)\n    # r_max: Maximum run length\n    rmax = max_run_found\n\n    # SRE: Short Run Emphasis\n    sre_sum = 0.0\n    for (g, r), count in glrlm.items():\n        sre_sum += count / (r * r)\n    sre = sre_sum / Nr\n\n    # RLN: Run-Length Non-Uniformity\n    run_length_sums = {} # Maps run length r to sum over g of R(g,r)\n    for (g, r), count in glrlm.items():\n        run_length_sums[r] = run_length_sums.get(r, 0) + count\n        \n    rln_sum = sum(s**2 for s in run_length_sums.values())\n    rln = rln_sum / Nr\n\n    return [Nr, rmax, sre, rln, maximal_ok]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            [\n                [1, 1, 2, 2, 2],\n                [1, 3, 3, 2, 2],\n                [1, 3, 3, 2, 4],\n                [4, 4, 3, 3, 4],\n                [4, 4, 4, 3, 4]\n            ],\n            [\n                [1, 1, 1, 1, 1],\n                [1, 1, 1, 1, 1],\n                [1, 1, 1, 1, 1],\n                [1, 1, 1, 1, 1],\n                [1, 1, 1, 1, 1]\n            ],\n            (0, 1)\n        ),\n        (\n            [\n                [5, 5, 5, 5],\n                [5, 5, 5, 5],\n                [5, 5, 5, 5],\n                [5, 5, 5, 5]\n            ],\n            [\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1],\n                [1, 1, 1, 1]\n            ],\n            (1, 0)\n        ),\n        (\n            [\n                [1, 2, 1, 2, 1],\n                [2, 1, 2, 1, 2],\n                [1, 2, 1, 2, 1],\n                [2, 1, 2, 1, 2],\n                [1, 2, 1, 2, 1]\n            ],\n            [\n                [1, 0, 1, 0, 1],\n                [0, 1, 0, 1, 0],\n                [1, 0, 1, 0, 1],\n                [0, 1, 0, 1, 0],\n                [1, 0, 1, 0, 1]\n            ],\n            (1, 1)\n        ),\n        (\n            [\n                [7, 8, 9],\n                [6, 5, 4],\n                [3, 2, 1]\n            ],\n            [\n                [0, 0, 0],\n                [0, 0, 0],\n                [0, 0, 0]\n            ],\n            (1, -1)\n        )\n    ]\n\n    results = []\n    for image, mask, d_vec in test_cases:\n        result = compute_glrlm_features(image, mask, d_vec)\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    # Floating point numbers are formatted to 6 decimal places.\n    # The list representation must not have spaces.\n    formatted_results = []\n    for res in results:\n        res_copy = res[:] # Create a copy to modify for printing\n        res_copy[2] = f\"{res_copy[2]:.6f}\"\n        res_copy[3] = f\"{res_copy[3]:.6f}\"\n        res_str = '[' + ','.join(map(str, res_copy)) + ']'\n        formatted_results.append(res_str)\n        \n    print('[' + ','.join(formatted_results) + ']')\n\nsolve()\n```"
        },
        {
            "introduction": "GLRLM 特征的定义在何种程度上是稳健的？这个思想实验通过分析一个仅包含单个体素的极端情况，来挑战你对特征定义的理解。通过推导在这种极限场景下的特征值，你将更深刻地体会到这些特征的数学本质，以及为确保其良好定义而需遵循的约定。",
            "id": "4564392",
            "problem": "考虑一幅二维医学图像，其灰度已被量化为 $N_{g}$ 个离散区间，由整数 $1,2,\\dots,N_{g}$ 标记。设感兴趣区域 (ROI) 由单个体素组成，其量化灰度区间索引为 $g \\in \\{1,\\dots,N_{g}\\}$。使用灰度游程矩阵 (GLRLM) 的定义，计算沿单一固定方向（例如 $0^{\\circ}$ 方向）的GLRLM。GLRLM是一个大小为 $N_{g} \\times N_{r}^{\\max}$ 的矩阵 $X$，其元素 $x(i,j)$ 表示在所选方向上，ROI内灰度为 $i$、长度为 $j$ 的游程数量。令 $N_{r}$ 表示总游程数，令 $N_{p}$ 表示ROI中的总体素数。它们满足基本计数关系 $N_{r} = \\sum_{i=1}^{N_{g}} \\sum_{j=1}^{N_{r}^{\\max}} x(i,j)$ 和 $N_{p} = \\sum_{i=1}^{N_{g}} \\sum_{j=1}^{N_{r}^{\\max}} j \\, x(i,j)$。\n\n从这些基本定义出发，针对此单体素ROI，推导并明确计算放射组学中定义的以下常用GLRLM特征：短游程强调、长游程强调、灰度非均匀性、游程长度非均匀性、游程百分比、低灰度游程强调、高灰度游程强调、短游程低灰度强调、短游程高灰度强调、长游程低灰度强调、长游程高灰度强调、灰度均值、游程长度均值、灰度方差、游程长度方差和游程长度熵。在您的推导中，请指明并论证为防止在此边缘情况下出现除以零所需的所有极限论证或约定。\n\n最后，定义标量\n$$S = \\text{(短游程强调)} + \\text{(长游程强调)} + \\text{(灰度非均匀性)} + \\text{(游程长度非均匀性)} + \\text{(游程百分比)} + \\text{(低灰度游程强调)} + \\text{(高灰度游程强调)} + \\text{(短游程低灰度强调)} + \\text{(短游程高灰度强调)} + \\text{(长游程低灰度强调)} + \\text{(长游程高灰度强调)} + \\text{(灰度均值)} + \\text{(游程长度均值)} + \\text{(灰度方差)} + \\text{(游程长度方差)} + \\text{(游程长度熵)}。$$\n将 $S$ 以 $g$ 的函数闭式形式表示。无需四舍五入，也无需单位，因为这些特征是无量纲的。",
            "solution": "首先验证问题的科学性、良定性和客观性。\n\n### 步骤1：提取已知条件\n- 一幅二维医学图像被量化为 $N_{g}$ 个灰度区间，由整数 $i \\in \\{1, 2, \\dots, N_{g}\\}$ 索引。\n- 感兴趣区域 (ROI) 由单个体素组成。\n- 该体素的量化灰度区间索引为 $g$，其中 $g \\in \\{1, \\dots, N_{g}\\}$。\n- 灰度游程矩阵 (GLRLM) 表示为 $X$，维度为 $N_{g} \\times N_{r}^{\\max}$。其元素 $x(i,j)$ 是长度为 $j$、灰度为 $i$ 的游程数量。\n- 总游程数为 $N_{r} = \\sum_{i=1}^{N_{g}} \\sum_{j=1}^{N_{r}^{\\max}} x(i,j)$。\n- ROI 中的总体素数为 $N_{p} = \\sum_{i=1}^{N_{g}} \\sum_{j=1}^{N_{r}^{\\max}} j \\, x(i,j)$。\n- 我们必须计算 $16$ 个特定的 GLRLM 特征及其总和 $S$。\n- 我们必须论证用于处理潜在数学不确定性（如除以零）的任何约定。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题是一个有效的练习，它将放射组学领域的标准定义应用于一个退化但定义明确的案例。\n- **科学上成立**：是。GLRLM 及其派生特征是纹理分析和放射组学中的标准工具。该问题探讨了这些特征在边界条件（单体素ROI）下的行为，这是一个合理的科学探究。\n- **良定的**：是。输入定义清晰。单体素情况虽然极端，但没有歧义。问题要求使用特征的标准定义，这些定义是公认的（例如，由影像生物标志物标准化倡议，IBSI）。识别和论证如何处理潜在的边缘情况（如除以零或 $0 \\log 0$）是使问题成为良定的一部分。\n- **客观的**：是。问题以精确的数学和技术语言陈述，没有主观性。\n\n### 步骤3：结论与行动\n问题被判定为**有效**。将提供完整解答。\n\n### 解答推导\n\n**1. 灰度游程矩阵 (GLRLM)**\n\n“游程”定义为沿特定方向具有相同灰度强度的连续体素序列。ROI 由一个灰度为 $g$ 的单体素组成。因此，沿任何方向，这个单体素都构成一个完整的游程。\n- 此游程的长度为 $j=1$。\n- 此游程的灰度为 $i=g$。\n- 恰好只有一个这样的游程。\n\n这意味着GLRLM矩阵 $X$ 仅包含一个非零元素。元素 $x(i,j)$ 表示长度为 $j$、灰度为 $i$ 的游程数量，可表示为：\n$x(g,1) = 1$。\n对于 $(i,j) \\neq (g,1)$ 的所有其他元素 $x(i,j)$ 均为 $0$。这可以用克罗内克δ函数紧凑地表示：\n$$x(i,j) = \\delta_{ig} \\delta_{j1}$$\n其中，如果 $a=b$，则 $\\delta_{ab} = 1$，否则为 $0$。在此ROI中，最大游程长度为 $N_{r}^{\\max}=1$。\n\n**2. 基本量**\n\n使用所提供的定义，我们可以计算总体素数 $N_p$ 和总游程数 $N_r$。\n\n- **总体素数 ($N_p$)**:\n问题指出ROI中有一个单体素，所以 $N_p=1$。我们用公式来验证：\n$$N_{p} = \\sum_{i=1}^{N_{g}} \\sum_{j=1}^{N_{r}^{\\max}} j \\, x(i,j) = \\sum_{i=1}^{N_{g}} \\sum_{j=1}^{1} j \\, x(i,j) = 1 \\cdot x(g,1) = 1 \\cdot 1 = 1$$\n结果一致。\n\n- **总游程数 ($N_r$)**:\n$$N_{r} = \\sum_{i=1}^{N_{g}} \\sum_{j=1}^{N_{r}^{\\max}} x(i,j) = \\sum_{i=1}^{N_{g}} \\sum_{j=1}^{1} x(i,j) = x(g,1) = 1$$\n这也与我们的设置一致。\n\n归一化的GLRLM $p(i,j)$ 定义为 $p(i,j) = \\frac{x(i,j)}{N_r}$。由于 $N_r=1$，我们得到 $p(i,j) = x(i,j)$。\n\n**3. GLRLM特征计算**\n\n我们现在使用放射组学中的标准定义来计算这16个特征。\n\n1.  **短游程强调 (SRE)**: $\\text{SRE} = \\frac{1}{N_r} \\sum_{i,j} \\frac{x(i,j)}{j^2}$\n    $$\\text{SRE} = \\frac{1}{1} \\left( \\frac{x(g,1)}{1^2} \\right) = \\frac{1}{1} = 1$$\n\n2.  **长游程强调 (LRE)**: $\\text{LRE} = \\frac{1}{N_r} \\sum_{i,j} j^2 x(i,j)$\n    $$\\text{LRE} = \\frac{1}{1} \\left( 1^2 \\cdot x(g,1) \\right) = 1$$\n\n3.  **灰度非均匀性 (GLNU)**: $\\text{GLNU} = \\frac{1}{N_r} \\sum_{i} \\left( \\sum_{j} x(i,j) \\right)^2$\n    内层求和 $\\sum_{j} x(i,j)$ 仅当 $i=g$ 时非零，此时其值为 $x(g,1)=1$。\n    $$\\text{GLNU} = \\frac{1}{1} \\left( \\left( \\sum_{j} x(g,j) \\right)^2 \\right) = (1)^2 = 1$$\n\n4.  **游程长度非均匀性 (RLNU)**: $\\text{RLNU} = \\frac{1}{N_r} \\sum_{j} \\left( \\sum_{i} x(i,j) \\right)^2$\n    内层求和 $\\sum_{i} x(i,j)$ 仅当 $j=1$ 时非零，此时其值为 $x(g,1)=1$。\n    $$\\text{RLNU} = \\frac{1}{1} \\left( \\left( \\sum_{i} x(i,1) \\right)^2 \\right) = (1)^2 = 1$$\n\n5.  **游程百分比 (RP)**: $\\text{RP} = \\frac{N_r}{N_p}$\n    特征定义中的分母 $N_r$ 和 $N_p$ 均为 $1$，因此非零。如果ROI为空，则 $N_p=0$，该特征将无定义。\n    $$\\text{RP} = \\frac{1}{1} = 1$$\n\n6.  **低灰度游程强调 (LGRE)**: $\\text{LGRE} = \\frac{1}{N_r} \\sum_{i,j} \\frac{x(i,j)}{i^2}$\n    分母 $i^2$ 变为 $g^2$。因为 $g \\in \\{1, \\dots, N_g\\}$，所以 $g \\ge 1$ 且 $g^2 \\neq 0$。\n    $$\\text{LGRE} = \\frac{1}{1} \\left( \\frac{x(g,1)}{g^2} \\right) = \\frac{1}{g^2}$$\n\n7.  **高灰度游程强调 (HGRE)**: $\\text{HGRE} = \\frac{1}{N_r} \\sum_{i,j} i^2 x(i,j)$\n    $$\\text{HGRE} = \\frac{1}{1} \\left( g^2 \\cdot x(g,1) \\right) = g^2$$\n\n8.  **短游程低灰度强调 (SRLGE)**: $\\text{SRLGE} = \\frac{1}{N_r} \\sum_{i,j} \\frac{x(i,j)}{i^2 j^2}$\n    $$\\text{SRLGE} = \\frac{1}{1} \\left( \\frac{x(g,1)}{g^2 \\cdot 1^2} \\right) = \\frac{1}{g^2}$$\n\n9.  **短游程高灰度强调 (SRHGE)**: $\\text{SRHGE} = \\frac{1}{N_r} \\sum_{i,j} \\frac{i^2 x(i,j)}{j^2}$\n    $$\\text{SRHGE} = \\frac{1}{1} \\left( \\frac{g^2 \\cdot x(g,1)}{1^2} \\right) = g^2$$\n\n10. **长游程低灰度强调 (LRLGE)**: $\\text{LRLGE} = \\frac{1}{N_r} \\sum_{i,j} \\frac{j^2 x(i,j)}{i^2}$\n    $$\\text{LRLGE} = \\frac{1}{1} \\left( \\frac{1^2 \\cdot x(g,1)}{g^2} \\right) = \\frac{1}{g^2}$$\n\n11. **长游程高灰度强调 (LRHGE)**: $\\text{LRHGE} = \\frac{1}{N_r} \\sum_{i,j} i^2 j^2 x(i,j)$\n    $$\\text{LRHGE} = \\frac{1}{1} \\left( g^2 \\cdot 1^2 \\cdot x(g,1) \\right) = g^2$$\n\n12. **灰度均值 (GLM)**: $\\mu_i = \\sum_{i,j} i \\cdot p(i,j) = \\frac{1}{N_r} \\sum_{i,j} i \\cdot x(i,j)$\n    $$\\text{GLM} = \\frac{1}{1} \\left( g \\cdot x(g,1) \\right) = g$$\n\n13. **游程长度均值 (RLM)**: $\\mu_j = \\sum_{i,j} j \\cdot p(i,j) = \\frac{1}{N_r} \\sum_{i,j} j \\cdot x(i,j)$\n    $$\\text{RLM} = \\frac{1}{1} \\left( 1 \\cdot x(g,1) \\right) = 1$$\n\n14. **灰度方差 (GLV)**: $\\text{GLV} = \\sum_{i,j} (i-\\mu_i)^2 p(i,j) = \\frac{1}{N_r} \\sum_{i,j} (i-\\mu_i)^2 x(i,j)$\n    当 $\\mu_i = g$ 时，和式中唯一的非零项是 $(i,j)=(g,1)$ 的项。\n    $$\\text{GLV} = \\frac{1}{1} (g-g)^2 x(g,1) = 0^2 \\cdot 1 = 0$$\n    这是预期的，因为灰度没有变化。\n\n15. **游程长度方差 (RLV)**: $\\text{RLV} = \\sum_{i,j} (j-\\mu_j)^2 p(i,j) = \\frac{1}{N_r} \\sum_{i,j} (j-\\mu_j)^2 x(i,j)$\n    当 $\\mu_j = 1$ 时，唯一的非零项是 $(i,j)=(g,1)$ 的项。\n    $$\\text{RLV} = \\frac{1}{1} (1-1)^2 x(g,1) = 0^2 \\cdot 1 = 0$$\n    这是预期的，因为游程长度没有变化。\n\n16. **游程长度熵 (RLE)**: $\\text{RLE} = -\\sum_{i,j} p(i,j) \\log_2(p(i,j))$\n    归一化矩阵中有一个元素 $p(g,1)=1$，所有其他元素均为 $0$。和式为：\n    $$\\text{RLE} = -p(g,1) \\log_2(p(g,1)) - \\sum_{(i,j)\\neq(g,1)} p(i,j) \\log_2(p(i,j))$$\n    第一项是 $-1 \\cdot \\log_2(1) = -1 \\cdot 0 = 0$。其他项的形式为 $0 \\log_2(0)$。根据信息论中的惯例，并且为了保证熵作为概率的连续函数，我们定义 $\\lim_{x \\to 0^+} x \\log_2(x) = 0$。因此，所有其他项都为 $0$。\n    $$\\text{RLE} = 0$$\n    这是预期的，因为结果是完全确定的。\n\n**4. 特征最终求和**\n\n标量 $S$ 是这16个特征的和。\n$$S = \\text{SRE} + \\text{LRE} + \\text{GLNU} + \\text{RLNU} + \\text{RP} + \\text{LGRE} + \\text{HGRE} + \\text{SRLGE} + \\text{SRHGE} + \\text{LRLGE} + \\text{LRHGE} + \\text{GLM} + \\text{RLM} + \\text{GLV} + \\text{RLV} + \\text{RLE}$$\n代入计算出的值：\n$$S = 1 + 1 + 1 + 1 + 1 + \\frac{1}{g^2} + g^2 + \\frac{1}{g^2} + g^2 + \\frac{1}{g^2} + g^2 + g + 1 + 0 + 0 + 0$$\n合并同类项：\n$$S = (1+1+1+1+1+1) + (g^2+g^2+g^2) + g + \\left(\\frac{1}{g^2}+\\frac{1}{g^2}+\\frac{1}{g^2}\\right) + (0+0+0)$$\n$$S = 6 + 3g^2 + g + \\frac{3}{g^2}$$\n按 $g$ 的幂次重新排序：\n$$S = 3g^2 + g + 6 + 3g^{-2}$$",
            "answer": "$$\n\\boxed{3g^2 + g + 6 + \\frac{3}{g^2}}\n$$"
        }
    ]
}