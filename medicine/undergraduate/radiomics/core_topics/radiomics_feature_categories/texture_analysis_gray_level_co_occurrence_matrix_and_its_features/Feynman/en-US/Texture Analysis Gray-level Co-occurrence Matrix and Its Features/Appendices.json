{
    "hands_on_practices": [
        {
            "introduction": "The most effective way to grasp the concept of the Gray-Level Co-occurrence Matrix (GLCM) is to construct one from scratch. This foundational exercise guides you through the process of manually tallying pixel pairs within a small, structured region of interest for a specific spatial offset. By doing so, you will build a concrete understanding of how the GLCM captures the spatial distribution of gray levels, which is the basis for all subsequent texture analysis.",
            "id": "4563789",
            "problem": "A radiomics analyst is quantizing a small two-dimensional Region of Interest (ROI) from a computed tomography slice into $L=4$ discrete gray levels labeled $\\{0,1,2,3\\}$. The ROI is given as the $4 \\times 5$ matrix\n$$\nI=\\begin{pmatrix}\n0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 0 & 1 & 1 \\\\\n2 & 2 & 2 & 3 & 3 \\\\\n2 & 2 & 2 & 3 & 3\n\\end{pmatrix}.\n$$\nUsing the concept of the Gray-Level Co-occurrence Matrix (GLCM), defined as the matrix of counts of ordered gray-level pairs separated by a specified spatial offset, construct the non-normalized, symmetric GLCM for the horizontal offset vector $\\vec{d}=(0,1)$ in pixel units. Boundary handling must be nonperiodic: exclude any pair that would require a neighbor outside the ROI. Symmetric pairing means that for every valid pair $(i,j)$ observed with $\\vec{d}$, include the reverse pair $(j,i)$ observed with $-\\vec{d}$ in the same combined matrix, without normalization or averaging. \n\nTasks:\n1. From first principles, enumerate valid ordered pairs for the offset $\\vec{d}=(0,1)$ to construct the directional count matrix, and then apply the symmetric pairing rule to obtain the combined GLCM over gray levels $\\{0,1,2,3\\}$. Based on the resulting counts, justify whether diagonal entries are dominant for this ROI and offset.\n2. Compute the total number $N$ of counted pairs included in the symmetric, non-normalized GLCM under the stated boundary handling. Express your final answer for $N$ as an integer. No rounding is required.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of texture analysis, specifically the construction of a Gray-Level Co-occurrence Matrix (GLCM), and is well-posed with a complete and consistent set of givens.\n\nThe task is to construct a symmetric, non-normalized GLCM for a given $4 \\times 5$ Region of Interest (ROI) and then determine the total number of pairs counted. The ROI is quantized into $L=4$ gray levels $\\{0, 1, 2, 3\\}$ and is represented by the matrix:\n$$\nI=\\begin{pmatrix}\n0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 0 & 1 & 1 \\\\\n2 & 2 & 2 & 3 & 3 \\\\\n2 & 2 & 2 & 3 & 3\n\\end{pmatrix}\n$$\nThe spatial offset is specified as $\\vec{d}=(0,1)$, representing a displacement of $0$ rows down and $1$ column to the right (i.e., a horizontally adjacent pixel). Boundary handling is nonperiodic, meaning pairs that require a pixel outside the ROI are excluded.\n\n**1. Construction of the GLCM and Analysis of Diagonal Dominance**\n\nFirst, we construct the directional GLCM, let's call it $P(\\vec{d})$, for the offset $\\vec{d}=(0,1)$. This involves scanning the ROI and counting the occurrences of ordered gray-level pairs $(i, j)$ where $i$ is the gray level of a pixel at coordinates $(r, c)$ and $j$ is the gray level of the pixel at $(r, c+1)$. Given the $4 \\times 5$ dimensions of the matrix $I$ and the nonperiodic boundary condition, we can form pairs for columns $c \\in \\{1, 2, 3, 4\\}$.\n\nThe valid ordered pairs $(I(r,c), I(r,c+1))$ are enumerated as follows:\n- **Row 1:** $(I(1,1), I(1,2)) = (0,0)$; $(I(1,2), I(1,3)) = (0,0)$; $(I(1,3), I(1,4)) = (0,1)$; $(I(1,4), I(1,5)) = (1,1)$.\n- **Row 2:** $(I(2,1), I(2,2)) = (0,0)$; $(I(2,2), I(2,3)) = (0,0)$; $(I(2,3), I(2,4)) = (0,1)$; $(I(2,4), I(2,5)) = (1,1)$.\n- **Row 3:** $(I(3,1), I(3,2)) = (2,2)$; $(I(3,2), I(3,3)) = (2,2)$; $(I(3,3), I(3,4)) = (2,3)$; $(I(3,4), I(3,5)) = (3,3)$.\n- **Row 4:** $(I(4,1), I(4,2)) = (2,2)$; $(I(4,2), I(4,3)) = (2,2)$; $(I(4,3), I(4,4)) = (2,3)$; $(I(4,4), I(4,5)) = (3,3)$.\n\nNext, we tally the counts for each unique pair $(i, j)$ from the list above:\n- Count of $(0,0)$: $4$\n- Count of $(0,1)$: $2$\n- Count of $(1,1)$: $2$\n- Count of $(2,2)$: $4$\n- Count of $(2,3)$: $2$\n- Count of $(3,3)$: $2$\nAll other pairs have a count of $0$.\n\nThe resulting directional GLCM $P(\\vec{d})$ is a $4 \\times 4$ matrix, indexed by the gray levels $\\{0,1,2,3\\}$, where the entry at row $i$ and column $j$ is the count of the pair $(i,j)$:\n$$\nP(\\vec{d}) = \\begin{pmatrix}\n4 & 2 & 0 & 0 \\\\\n0 & 2 & 0 & 0 \\\\\n0 & 0 & 4 & 2 \\\\\n0 & 0 & 0 & 2\n\\end{pmatrix}\n$$\n\nThe problem requires a symmetric GLCM, $P_{sym}$, which accounts for both the offset $\\vec{d}=(0,1)$ and its reverse $-\\vec{d}=(0,-1)$. This is constructed by summing the directional GLCM for $\\vec{d}$ and the directional GLCM for $-\\vec{d}$. The GLCM for $-\\vec{d}$ is the transpose of the GLCM for $\\vec{d}$, i.e., $P(-\\vec{d}) = P(\\vec{d})^T$.\n\nFirst, we find the transpose of $P(\\vec{d})$:\n$$\nP(-\\vec{d}) = P(\\vec{d})^T = \\begin{pmatrix}\n4 & 0 & 0 & 0 \\\\\n2 & 2 & 0 & 0 \\\\\n0 & 0 & 4 & 0 \\\\\n0 & 0 & 2 & 2\n\\end{pmatrix}\n$$\nThe symmetric GLCM is the sum $P_{sym} = P(\\vec{d}) + P(\\vec{d})^T$:\n$$\nP_{sym} = \\begin{pmatrix}\n4 & 2 & 0 & 0 \\\\\n0 & 2 & 0 & 0 \\\\\n0 & 0 & 4 & 2 \\\\\n0 & 0 & 0 & 2\n\\end{pmatrix} + \\begin{pmatrix}\n4 & 0 & 0 & 0 \\\\\n2 & 2 & 0 & 0 \\\\\n0 & 0 & 4 & 0 \\\\\n0 & 0 & 2 & 2\n\\end{pmatrix} = \\begin{pmatrix}\n8 & 2 & 0 & 0 \\\\\n2 & 4 & 0 & 0 \\\\\n0 & 0 & 8 & 2 \\\\\n0 & 0 & 2 & 4\n\\end{pmatrix}\n$$\nTo justify whether diagonal entries are dominant, we compare the values on the main diagonal with the off-diagonal values. The diagonal entries are $P_{sym}(0,0)=8$, $P_{sym}(1,1)=4$, $P_{sym}(2,2)=8$, and $P_{sym}(3,3)=4$. The non-zero off-diagonal entries are $P_{sym}(0,1)=P_{sym}(1,0)=2$ and $P_{sym}(2,3)=P_{sym}(3,2)=2$.\nThe sum of diagonal entries is $8+4+8+4=24$. The sum of off-diagonal entries is $2+2+2+2=8$. Since $24 \\gg 8$, the counts are concentrated on the diagonal. Furthermore, for every row $i$, the diagonal element $P_{sym}(i,i)$ is greater than any off-diagonal element $P_{sym}(i,j)$ for $i \\neq j$. This dominance of the diagonal signifies that the texture is largely homogeneous in the horizontal direction, as adjacent pixels frequently share the same gray level. This is consistent with the visual structure of the ROI matrix $I$, which consists of blocks of constant intensity.\n\n**2. Computation of the Total Number of Pairs $N$**\n\nThe total number of counted pairs, $N$, in the symmetric, non-normalized GLCM is the sum of all its elements.\n$$\nN = \\sum_{i=0}^{3} \\sum_{j=0}^{3} P_{sym}(i,j)\n$$\nUsing the matrix $P_{sym}$ calculated above:\n$$\nN = (8+2+0+0) + (2+4+0+0) + (0+0+8+2) + (0+0+2+4) = 10 + 6 + 10 + 6 = 32\n$$\nAlternatively, we can determine $N$ by considering the number of valid pairs for each direction. For the $4 \\times 5$ matrix, the number of valid horizontal pairs for the offset $\\vec{d}=(0,1)$ is $4 \\text{ rows} \\times (5-1) \\text{ columns} = 16$. Similarly, for the reverse offset $-\\vec{d}=(0,-1)$, the number of valid pairs is $4 \\text{ rows} \\times (5-1) \\text{ columns} = 16$. The total number of pairs in the symmetric matrix is the sum from both directions: $N = 16 + 16 = 32$. This confirms the result.",
            "answer": "$$\\boxed{32}$$"
        },
        {
            "introduction": "GLCM-derived features such as contrast, homogeneity, and entropy can initially seem abstract, but their meaning becomes clear when we examine their behavior in extreme scenarios. This practice is a thought experiment that asks you to derive these feature values for a perfectly uniform image, a texture with no variation. This exercise provides an invaluable baseline for interpreting feature measurements from complex, real-world images.",
            "id": "4563803",
            "problem": "A square region of interest (ROI) in a medical image is quantized to $G$ discrete gray levels by a deterministic mapping $Q$ from raw intensities to $\\{0,1,\\dots,G-1\\}$. Consider an ROI of size $M \\times N$ in which all pixels share the same quantized gray-level index $g^{*} \\in \\{0,1,\\dots,G-1\\}$. Using the definition of the Gray-Level Co-occurrence Matrix (GLCM), compute the non-symmetric co-occurrence counts for the spatial offset $\\Delta = (0,1)$ (each pixel paired with its right neighbor when that neighbor lies inside the ROI), normalize the GLCM to obtain a probability matrix, and then derive from first principles the values of the following texture features, using their standard definitions in radiomics and information theory: contrast, dissimilarity, homogeneity (inverse difference moment), angular second moment, energy, entropy (use the natural logarithm), and maximum probability. Provide exact values; no rounding is required. Express your final answer as a row matrix in the order: contrast, dissimilarity, homogeneity, angular second moment, energy, entropy, maximum probability.",
            "solution": "We begin from the definition of quantization and the Gray-Level Co-occurrence Matrix (GLCM). Let $Q$ map raw pixel intensities to the set $\\{0,1,\\dots,G-1\\}$, and let the ROI be of size $M \\times N$ with all pixels having the same quantized level $g^{*}$. For a chosen offset $\\Delta = (0,1)$, we form ordered pairs $(i,j)$ by taking each pixel and its right neighbor when that neighbor is within the ROI. The GLCM $C$ is an array of counts where $C(i,j)$ is the number of such co-occurrences with left pixel level $i$ and right pixel level $j$.\n\nBecause every pixel in the ROI has level $g^{*}$, every valid pair at offset $\\Delta$ is $(g^{*},g^{*})$. The total number of valid pairs is the number of horizontal neighbor relationships in the ROI, which is $M(N-1)$. Hence\n$$\nC(i,j) = \\begin{cases}\nM(N-1), & \\text{if } i=g^{*} \\text{ and } j=g^{*},\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nThe normalized GLCM (probability matrix) $P$ is defined by dividing counts by the total number of pairs $\\sum_{i=0}^{G-1}\\sum_{j=0}^{G-1} C(i,j) = M(N-1)$. Therefore,\n$$\nP(i,j) = \\frac{C(i,j)}{M(N-1)} = \\begin{cases}\n1, & \\text{if } i=g^{*} \\text{ and } j=g^{*},\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nEquivalently, $P(i,j) = \\delta_{i,g^{*}}\\,\\delta_{j,g^{*}}$, where $\\delta$ is the Kronecker delta.\n\nWe now compute the requested features from their standard definitions in radiomics, starting from $P$. In what follows, all sums are over $i,j \\in \\{0,1,\\dots,G-1\\}$.\n\n1. Contrast. The contrast is\n$$\n\\text{contrast} = \\sum_{i}\\sum_{j} (i-j)^{2}\\,P(i,j).\n$$\nSince $P(i,j)$ is zero except at $(i,j)=(g^{*},g^{*})$, and $(g^{*}-g^{*})^{2} = 0$, it follows that\n$$\n\\text{contrast} = 0.\n$$\n\n2. Dissimilarity. The dissimilarity is\n$$\n\\text{dissimilarity} = \\sum_{i}\\sum_{j} |i-j|\\,P(i,j).\n$$\nAgain, only $(i,j)=(g^{*},g^{*})$ contributes, with $|g^{*}-g^{*}| = 0$, hence\n$$\n\\text{dissimilarity} = 0.\n$$\n\n3. Homogeneity (inverse difference moment). The homogeneity is\n$$\n\\text{homogeneity} = \\sum_{i}\\sum_{j} \\frac{P(i,j)}{1+(i-j)^{2}}.\n$$\nOnly $(i,j)=(g^{*},g^{*})$ contributes, with denominator $1+(g^{*}-g^{*})^{2} = 1$, so\n$$\n\\text{homogeneity} = \\frac{1}{1} \\cdot P(g^{*},g^{*}) = 1.\n$$\n\n4. Angular second moment (ASM). The ASM is\n$$\n\\text{ASM} = \\sum_{i}\\sum_{j} \\big(P(i,j)\\big)^{2}.\n$$\nWith a single entry equal to $1$ and all others $0$, this yields\n$$\n\\text{ASM} = 1^{2} + \\sum_{\\substack{(i,j)\\neq(g^{*},g^{*})}} 0^{2} = 1.\n$$\n\n5. Energy. The energy is the square root of the angular second moment:\n$$\n\\text{energy} = \\sqrt{\\text{ASM}} = \\sqrt{1} = 1.\n$$\n\n6. Entropy. Using the natural logarithm, the entropy is\n$$\n\\text{entropy} = -\\sum_{i}\\sum_{j} P(i,j)\\,\\ln\\big(P(i,j)\\big),\n$$\nwith the convention that $0\\ln(0)$ is treated as $0$ (by continuity). Only $P(g^{*},g^{*})=1$ contributes, and $\\ln(1)=0$, hence\n$$\n\\text{entropy} = -\\,1 \\cdot 0 = 0.\n$$\n\n7. Maximum probability. The maximum probability feature is\n$$\n\\text{max prob} = \\max_{i,j} P(i,j) = 1.\n$$\n\nCollecting the values in the prescribed order (contrast, dissimilarity, homogeneity, angular second moment, energy, entropy, maximum probability), we obtain the row matrix\n$$\n\\begin{pmatrix}\n0 & 0 & 1 & 1 & 1 & 0 & 1\n\\end{pmatrix}.\n$$\nThese values confirm the expected edge-case behavior for a constant-intensity ROI: maximal homogeneity ($1$), minimal entropy ($0$), zero contrast ($0$) and dissimilarity ($0$), and unity for angular second moment, energy, and maximum probability due to the single nonzero probability mass.",
            "answer": "$$\\boxed{\\begin{pmatrix}0 & 0 & 1 & 1 & 1 & 0 & 1\\end{pmatrix}}$$"
        },
        {
            "introduction": "While manual calculations build intuition, the true power of GLCM analysis is realized through computation. This capstone practice challenges you to bridge the gap from theory to application by designing a program that quantifies texture anisotropy. You will implement a complete pipeline to compute the GLCM correlation feature along multiple directions and use it to automatically differentiate between directional and isotropic textures.",
            "id": "4563805",
            "problem": "You are given the task to design a program that quantifies directional texture differences in a two-dimensional Region of Interest (ROI) using the Gray-Level Co-occurrence Matrix (GLCM). The ROI is a two-dimensional array of grayscale intensities in the closed interval $\\left[0,1\\right]$. Your goal is to compute the correlation feature from the GLCM for multiple offsets and decide whether anisotropy manifests as directional correlation differences.\n\nStart from the following base and rules:\n- Use the definition of the Gray-Level Co-occurrence Matrix (GLCM), which counts how often ordered pairs of gray levels occur at a prescribed spatial offset, and interpret its normalized entries as empirical joint probabilities.\n- Use the standard interpretation of covariance and correlation between two discrete random variables estimated from a joint probability mass function.\n- Quantize the ROI: map each intensity $x \\in \\left[0,1\\right]$ to an integer gray level $g \\in \\{0,1,\\ldots,N_g-1\\}$ by $g = \\min\\left(N_g-1, \\left\\lfloor x \\cdot N_g \\right\\rfloor\\right)$.\n- Construct a non-symmetric GLCM for each specified offset by counting valid in-bounds pixel pairs $(r,c)$ and $(r+\\Delta r, c+\\Delta c)$, where $(\\Delta r, \\Delta c)$ is the chosen offset and $(r,c)$ indexes the ROI using row-major order with row index increasing downward.\n- Normalize the GLCM by the sum of all counts to obtain an empirical joint probability mass function over gray-level pairs.\n- Compute the correlation feature from the normalized GLCM by treating gray levels as integer-valued random variables for the reference and neighbor pixels. If either estimated standard deviation equals zero, define the correlation value to be $0$.\n\nAnisotropy detection rule:\n- Given a set of directional offsets, compute one correlation per offset and then compute the range as the difference between the maximum and minimum correlation across those offsets. If this range is greater than or equal to a specified threshold $\\tau$, declare anisotropy as detected; otherwise, declare it not detected.\n\nImplementation requirements:\n- Offsets: use the set $\\{(\\Delta r,\\Delta c)\\} = \\{(0,1),(1,0),(1,1),(-1,1)\\}$, which correspond to four canonical directions at unit distance.\n- Gray levels: use $N_g = 8$.\n- Threshold: use $\\tau = 0.2$.\n- All added noise is independent, zero-mean Gaussian with the specified standard deviation. After adding noise, clip intensities to the closed interval $\\left[0,1\\right]$ before quantization.\n- Use non-symmetric GLCMs (do not merge counts with transposed offsets).\n- Include only in-bounds pixel pairs for each offset when counting co-occurrences.\n\nTest suite:\nYour program must evaluate the following four ROIs, each of size $16 \\times 16$, constructed as specified. For stochastic cases, use the given pseudorandom seeds with a fixed generator so results are deterministic.\n\n- Test case $1$ (horizontal stripes with noise; anisotropy expected to be detectable):\n  - Base pattern: for each pixel at row index $r$ and column index $c$, set the base intensity to $0.9$ if $r \\bmod 2 = 0$, and $0.1$ otherwise.\n  - Additive noise: Gaussian with standard deviation $0.05$.\n  - Seed: $0$.\n\n- Test case $2$ (vertical stripes with noise; anisotropy expected to be detectable):\n  - Base pattern: for each pixel at row index $r$ and column index $c$, set the base intensity to $0.9$ if $c \\bmod 2 = 0$, and $0.1$ otherwise.\n  - Additive noise: Gaussian with standard deviation $0.05$.\n  - Seed: $1$.\n\n- Test case $3$ (isotropic random texture with noise; anisotropy not expected to be detectable):\n  - Base pattern: draw each pixel intensity independently from the continuous uniform distribution on $\\left[0,1\\right]$.\n  - Additive noise: Gaussian with standard deviation $0.05$.\n  - Seed: $2$.\n\n- Test case $4$ (constant ROI; boundary condition for zero-variance handling; anisotropy not expected to be detectable):\n  - Base pattern: every pixel intensity is $0.5$.\n  - Additive noise: none, standard deviation $0$.\n  - Seed: ignored.\n\nProgram input and output:\n- There is no external input; your program must construct the specified ROIs internally.\n- For each test case, compute the correlation for each of the four specified offsets, compute the range across these four correlations, and apply the anisotropy decision rule with threshold $\\tau$.\n- Your program should produce a single line of output containing the results for the four test cases as a comma-separated list of boolean values enclosed in square brackets, for example, `[True,False,True,False]`. The booleans must reflect the anisotropy decisions in the order of the test cases $1$ through $4$.\n\nAngle unit note: Not applicable, since offsets are specified as discrete $(\\Delta r,\\Delta c)$ pairs rather than angles.\n\nPhysical units note: Not applicable.\n\nYour task is to implement the above strictly and produce the required output format in a single line.",
            "solution": "The problem requires the design and implementation of an algorithm to detect texture anisotropy in a two-dimensional Region of Interest (ROI) by analyzing the correlation feature derived from the Gray-Level Co-occurrence Matrix (GLCM). The solution involves several distinct stages: ROI generation and preprocessing, GLCM construction, calculation of the correlation feature, and application of a decision rule for anisotropy. This procedure is fundamental in fields such as radiomics, where quantitative image features are extracted to characterize tissue properties non-invasively.\n\n### Part I: ROI Generation and Quantization\n\nThe process begins with the generation and preprocessing of the input ROI. The problem specifies four test cases with $16 \\times 16$ ROIs. Each ROI is an array of grayscale intensity values, initially in the continuous range $[0, 1]$.\n\n1.  **Base Pattern Generation**: For each test case, a base intensity pattern is algorithmically generated. This includes horizontal stripes, vertical stripes, an isotropic random field, and a constant field.\n2.  **Noise Addition**: To simulate realistic imaging conditions, zero-mean Gaussian noise with a specified standard deviation $\\sigma$ is added to the base pattern. For stochastic patterns and noise, a fixed pseudorandom seed is used to ensure deterministic and reproducible results.\n3.  **Clipping**: After adding noise, intensity values may fall outside the $[0, 1]$ range. These values are clipped to fit within this closed interval, i.e., values less than $0$ are set to $0$, and values greater than $1$ are set to $1$.\n4.  **Quantization**: The continuous intensity values $x \\in [0, 1]$ are quantized into a discrete set of $N_g$ gray levels. The problem specifies $N_g=8$, with integer gray levels $g \\in \\{0, 1, \\ldots, 7\\}$. The mapping is defined by the formula:\n    $$ g = \\min(N_g-1, \\lfloor x \\cdot N_g \\rfloor) $$\n    This formula converts the floating-point ROI into an integer-valued matrix, which is the necessary input for GLCM construction. For $x=1.0$, the floor operation $\\lfloor 1.0 \\cdot 8 \\rfloor = 8$ would yield an out-of-bounds index, which is correctly handled by the $\\min(7, \\cdot)$ operation.\n\n### Part II: GLCM Construction\n\nThe Gray-Level Co-occurrence Matrix is a statistical tool used to describe the spatial relationship of gray levels in an image. For a given spatial offset $(\\Delta r, \\Delta c)$, the GLCM is an $N_g \\times N_g$ matrix where the entry $C_{i,j}$ represents the number of times a pixel with gray level $i$ is found at the specified spatial relationship to a pixel with gray level $j$.\n\nThe construction proceeds as follows:\n-   An $N_g \\times N_g$ matrix, initialized to all zeros, is created.\n-   The algorithm iterates through each pixel at location $(r,c)$ in the quantized ROI.\n-   The coordinates of the neighbor pixel are calculated as $(r', c') = (r + \\Delta r, c + \\Delta c)$.\n-   A pair is considered valid only if both $(r,c)$ and $(r',c')$ are within the bounds of the ROI.\n-   If the pair is valid, let the gray level at $(r,c)$ be $i$ and at $(r',c')$ be $j$. The GLCM element $C_{i,j}$ is then incremented.\n-   The problem specifies a non-symmetric GLCM, meaning the count for the pair from $(r,c)$ to $(r',c')$ is not combined with the count for the reverse offset $(-\\Delta r, -\\Delta c)$. This preserves the directional information.\n\n### Part III: Correlation Feature Extraction\n\nThe correlation feature measures the linear dependency of gray levels of neighboring pixels. It is calculated from the normalized GLCM, which is interpreted as a joint probability mass function.\n\n1.  **Normalization**: The raw GLCM, $C$, is normalized by the total number of valid pixel pairs, $N_p = \\sum_{i=0}^{N_g-1} \\sum_{j=0}^{N_g-1} C_{i,j}$, to obtain the joint probability $P(i,j)$:\n    $$ P(i,j) = \\frac{C_{i,j}}{N_p} $$\n2.  **Marginal Statistics**: From $P(i,j)$, the marginal probabilities for the reference pixel gray levels ($p_x$) and neighbor pixel gray levels ($p_y$) are computed:\n    $$ p_x(i) = \\sum_{j=0}^{N_g-1} P(i,j) \\quad \\text{and} \\quad p_y(j) = \\sum_{i=0}^{N_g-1} P(i,j) $$\n    The means ($\\mu_x, \\mu_y$) and standard deviations ($\\sigma_x, \\sigma_y$) of these marginal distributions are then calculated:\n    $$ \\mu_k = \\sum_{k=0}^{N_g-1} k \\cdot p_k(k), \\quad \\sigma_k = \\sqrt{\\sum_{k=0}^{N_g-1} (k-\\mu_k)^2 p_k(k)} \\quad \\text{for } k \\in \\{x,y\\}$$\n3.  **Correlation Calculation**: The correlation is calculated using the standard formula for discrete random variables:\n    $$ \\text{Corr} = \\frac{\\sum_{i=0}^{N_g-1} \\sum_{j=0}^{N_g-1} (i - \\mu_x)(j - \\mu_y) P(i,j)}{\\sigma_x \\sigma_y} $$\n    An equivalent and computationally convenient form is:\n    $$ \\text{Corr} = \\frac{\\sum_{i=0}^{N_g-1} \\sum_{j=0}^{N_g-1} ij P(i,j) - \\mu_x \\mu_y}{\\sigma_x \\sigma_y} $$\n    As per the problem specification, if either $\\sigma_x$ or $\\sigma_y$ is zero (which occurs for a constant or single-gray-level region), the correlation value is defined to be $0$.\n\n### Part IV: Anisotropy Detection\n\nAnisotropy, or directional dependency of texture, is assessed by comparing the correlation values computed along different directions.\n1.  **Directional Analysis**: The correlation feature is calculated for each of the four specified offsets: $\\{(0,1) \\text{ (horizontal)}, (1,0) \\text{ (vertical)}, (1,1) \\text{ (diagonal)}, (-1,1) \\text{ (anti-diagonal)}\\}$.\n2.  **Range Calculation**: The range, $R$, of these correlation values is computed as the difference between the maximum and minimum correlation values found across the four directions:\n    $$ R = \\max(\\{\\text{Corr}_k\\}_{k=1}^4) - \\min(\\{\\text{Corr}_k\\}_{k=1}^4) $$\n3.  **Decision Rule**: A texture is declared anisotropic if this range $R$ is greater than or equal to a specified threshold $\\tau$. The problem sets this threshold to $\\tau=0.2$.\n    $$ \\text{Anisotropy Detected} \\iff R \\ge 0.2 $$\n\nThis complete pipeline, from ROI generation to the final decision rule, will be applied to each of the four test cases. For example, in the horizontal stripes case, the horizontal offset $(0,1)$ is expected to yield a high positive correlation, while the vertical offset $(1,0)$ should result in a high negative correlation, producing a large range $R$ and leading to a detection of anisotropy. Conversely, for the isotropic and constant cases, the correlations across all directions are expected to be similar, resulting in a small range $R$ and a conclusion of no significant anisotropy.",
            "answer": "```python\nimport numpy as np\n\ndef quantize(roi_float, Ng):\n    \"\"\"\n    Quantizes a floating-point ROI in [0,1] to integer gray levels.\n\n    Args:\n        roi_float (np.ndarray): The input ROI with values in [0, 1].\n        Ng (int): The number of gray levels.\n\n    Returns:\n        np.ndarray: The quantized ROI with integer values in [0, Ng-1].\n    \"\"\"\n    return np.minimum(Ng - 1, np.floor(roi_float * Ng)).astype(int)\n\ndef compute_glcm(quantized_roi, offset, Ng):\n    \"\"\"\n    Computes the non-symmetric GLCM for a given offset.\n\n    Args:\n        quantized_roi (np.ndarray): The integer-valued quantized ROI.\n        offset (tuple): The (dr, dc) offset.\n        Ng (int): The number of gray levels.\n\n    Returns:\n        np.ndarray: The Ng x Ng GLCM.\n    \"\"\"\n    rows, cols = quantized_roi.shape\n    dr, dc = offset\n    glcm = np.zeros((Ng, Ng), dtype=np.uint32)\n    \n    for r in range(rows):\n        for c in range(cols):\n            r_neighbor, c_neighbor = r + dr, c + dc\n            if 0 <= r_neighbor < rows and 0 <= c_neighbor < cols:\n                i = quantized_roi[r, c]\n                j = quantized_roi[r_neighbor, c]\n                glcm[i, j] += 1\n    return glcm\n\ndef compute_correlation(glcm, Ng):\n    \"\"\"\n    Computes the correlation feature from a GLCM.\n\n    Args:\n        glcm (np.ndarray): The GLCM.\n        Ng (int): The number of gray levels.\n\n    Returns:\n        float: The correlation value.\n    \"\"\"\n    total_pairs = glcm.sum()\n    if total_pairs == 0:\n        return 0.0\n\n    P = glcm.astype(np.float64) / total_pairs\n    \n    i_vec = np.arange(Ng, dtype=np.float64)\n    \n    px = P.sum(axis=1)\n    py = P.sum(axis=0)\n\n    mux = (i_vec * px).sum()\n    muy = (i_vec * py).sum()\n    \n    var_x = ((i_vec - mux)**2 * px).sum()\n    var_y = ((i_vec - muy)**2 * py).sum()\n\n    sigx = np.sqrt(var_x)\n    sigy = np.sqrt(var_y)\n    \n    if sigx == 0.0 or sigy == 0.0:\n        return 0.0\n\n    I, J = np.meshgrid(i_vec, i_vec, indexing='ij')\n    numerator = np.sum((I - mux) * (J - muy) * P)\n    denominator = sigx * sigy\n    \n    correlation = numerator / denominator\n    return correlation\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for anisotropy detection.\n    \"\"\"\n    # Global parameters\n    Ng = 8\n    tau = 0.2\n    offsets = [(0, 1), (1, 0), (1, 1), (-1, 1)]\n    roi_shape = (16, 16)\n    rows, cols = roi_shape\n\n    # Test case definitions\n    test_params = [\n        {'id': 1, 'type': 'horizontal', 'noise_std': 0.05, 'seed': 0},\n        {'id': 2, 'type': 'vertical', 'noise_std': 0.05, 'seed': 1},\n        {'id': 3, 'type': 'isotropic', 'noise_std': 0.05, 'seed': 2},\n        {'id': 4, 'type': 'constant', 'noise_std': 0.0, 'seed': None}\n    ]\n\n    final_results = []\n\n    for params in test_params:\n        # Step 1: Generate base ROI\n        rng = np.random.default_rng(params['seed']) if params['seed'] is not None else None\n        \n        if params['type'] == 'horizontal':\n            r_indices = np.arange(rows).reshape(-1, 1)\n            base_roi = np.where(r_indices % 2 == 0, 0.9, 0.1) * np.ones(roi_shape)\n        elif params['type'] == 'vertical':\n            c_indices = np.arange(cols).reshape(1, -1)\n            base_roi = np.where(c_indices % 2 == 0, 0.9, 0.1) * np.ones(roi_shape)\n        elif params['type'] == 'isotropic':\n            base_roi = rng.uniform(0, 1, roi_shape)\n        elif params['type'] == 'constant':\n            base_roi = np.full(roi_shape, 0.5)\n        \n        # Step 2: Add noise and clip\n        if params['noise_std'] > 0:\n            if rng is None: # For cases where base pattern is fixed but noise is random\n                rng = np.random.default_rng(params['seed'])\n            noise = rng.normal(loc=0.0, scale=params['noise_std'], size=roi_shape)\n            noisy_roi = base_roi + noise\n        else:\n            noisy_roi = base_roi\n            \n        clipped_roi = np.clip(noisy_roi, 0, 1)\n        \n        # Step 3: Quantize ROI\n        quantized_roi = quantize(clipped_roi, Ng)\n        \n        # Step 4: Compute correlations for all offsets\n        correlations = []\n        for offset in offsets:\n            glcm = compute_glcm(quantized_roi, offset, Ng)\n            corr = compute_correlation(glcm, Ng)\n            correlations.append(corr)\n            \n        # Step 5: Apply anisotropy detection rule\n        if not correlations:\n            corr_range = 0.0\n        else:\n            corr_range = np.max(correlations) - np.min(correlations)\n        \n        is_anisotropic = corr_range >= tau\n        final_results.append(is_anisotropic)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}