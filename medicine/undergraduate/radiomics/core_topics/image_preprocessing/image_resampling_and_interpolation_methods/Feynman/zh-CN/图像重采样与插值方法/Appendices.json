{
    "hands_on_practices": [
        {
            "introduction": "这个练习旨在直观地展示不当重采样带来的实际后果。我们将通过编程创建一个包含锐利边缘和精细光栅的合成体模，模拟医学图像中的常见结构。通过对比经过正确抗锯齿处理和未经处理的降采样结果，您将亲眼见证并量化“混叠”伪影是如何扭曲灰度共生矩阵（GLCM）纹理特征的。这项实践将香农-奈奎斯特定理与放射组学分析中的具体问题紧密联系起来，让您深刻理解为何规范的预处理流程至关重要。",
            "id": "4546567",
            "problem": "你需要研究不当的图像重采样导致的混叠如何改变一个二维合成体模的灰度共生矩阵特征。该体模被设计为同时包含锐利边缘和精細光栅，这两种结构在放射组学中很常见。此分析必须基于基本原理：用于信号采样的 Shannon–Nyquist 采样定理，以及灰度共生矩阵及其派生特征的形式化定义。\n\n按如下方式构建一个合成图像体模。设该图像为一个大小为 $256 \\times 256$ 的离散数组，其整数像素索引为 $(x,y)$，其中 $x \\in \\{0,\\dots,255\\}$ 且 $y \\in \\{0,\\dots,255\\}$。定义一个由三个组成部分构成的强度场 $I(x,y)$：\n1. 强度为 $0.2$ 的均匀背景。\n2. 在轴对齐边界 $x \\in [64,192)$ 和 $y \\in [64,192)$ 内，一个强度为 $0.8$ 的边缘锐利的明亮方形区域。\n3. 一个可选的余弦光栅，局限于 $x \\in [32,224)$ 和 $y \\in [96,160)$ 内，由一个加法项 $A \\cos\\left(2\\pi x/p\\right)$ 给出，其振幅 $A = 0.2$，光栅周期 $p$ 以像素为单位。若存在此光栅，则仅在定义的条带区域内添加光栅项，其他像素不受光栅影响。将最终强度裁剪至区间 $[0,1]$ 内。\n\n使用两种不同的处理流程将此图像重采样至新的空间分辨率：\n- 不当重采样（混叠）：通过缩放因子 $s$ 在两个轴上进行各向同性的直接最近邻重采样（无抗混叠预滤波器）。\n- 适当重采样（抗混叠）：如果 $s < 1$，首先应用标准差为 $\\sigma = 0.6/s$ 像素的高斯低通滤波器于两个轴（以衰减超出新 Nyquist 极限的频率），然后使用双线性插值进行重采样；如果 $s = 1$，则跳过低通滤波步骤，并使用单位尺度的双线性插值。\n\n将每张图像（原始图像及两种重采样版本）通过四舍五入量化为 $N_g = 32$ 个灰度级：通过公式 $q = \\operatorname{round}\\left( v (N_g - 1) \\right)$ 将每个强度值 $v \\in [0,1]$ 映射到一个整数 $q \\in \\{0,1,\\dots,31\\}$，然后裁剪到允许的范围内。\n\n按如下方式为指定的偏移量定义灰度共生矩阵 (GLCM)。对于一个离散灰度级为 $q(x,y) \\in \\{0,1,\\dots, N_g - 1\\}$ 且偏移量为 $(\\Delta x,\\Delta y)$ 的图像，共生矩阵 $P \\in \\mathbb{R}^{N_g \\times N_g}$ 的元素为\n$$\nP(i,j) = \\#\\left\\{(x,y) \\,\\big|\\, q(x,y) = i,\\; q(x+\\Delta x,y+\\Delta y) = j\\right\\},\n$$\n仅计算其中 $(x,y)$ 和 $(x+\\Delta x,y+\\Delta y)$ 均在图像域内的有效像素对。通过累加两个方向的计数来使用对称形式，即同时累积 $(i,j)$ 和 $(j,i)$。进行归一化以获得概率矩阵 $\\hat{P} = P / \\sum_{i,j} P(i,j)$。使用 $\\hat{P}$ 计算特征对比度 $C$ 和均匀性 $H$，定义如下\n$$\nC = \\sum_{i=0}^{N_g-1} \\sum_{j=0}^{N_g-1} (i - j)^2 \\, \\hat{P}(i,j),\n\\quad\nH = \\sum_{i=0}^{N_g-1} \\sum_{j=0}^{N_g-1} \\frac{\\hat{P}(i,j)}{1 + (i - j)^2}.\n$$\n使用水平偏移量 $(\\Delta x, \\Delta y) = (1,0)$。\n\n你的推理应基于 Shannon–Nyquist 采样定理：一个单位间距的离散采样网格的 Nyquist 极限为 $0.5$ 周期/像素，按因子 $s$ 进行降采样会相应地降低新的 Nyquist 频率。不当重采样（没有足够的低通滤波）允许高于新 Nyquist 极限的频率成分折叠到较低频率（混叠），从而改变局部灰度关系，进而影响 GLCM 特征。\n\n你的程序必须实现上述构建过程，并评估以下参数设置的测试套件，每组设置都会创建一个独特的体模和重采样场景：\n- 测试用例 1：光栅周期 $p = 3$ 像素，缩放因子 $s = 0.5$。\n- 测试用例 2：光栅周期 $p = 12$ 像素，缩放因子 $s = 0.5$。\n- 测试用例 3：无光栅（省略部分 3），缩放因子 $s = 0.5$。\n- 测试用例 4：光栅周期 $p = 3$ 像素，缩放因子 $s = 1.0$。\n\n对于每个测试用例：\n1. 生成体模 $I(x,y)$（根据指定有或无光栅）。\n2. 在原始体模上计算 $C_{\\mathrm{orig}}$ 和 $H_{\\mathrm{orig}}$（无重采样）。\n3. 在不当重采样的图像上计算 $C_{\\mathrm{improper}}$ 和 $H_{\\mathrm{improper}}$。\n4. 在适当重采样的图像上计算 $C_{\\mathrm{proper}}$ 和 $H_{\\mathrm{proper}}$。\n\n对于每个测试用例，报告差值对\n$$\n\\Delta C = C_{\\mathrm{improper}} - C_{\\mathrm{proper}},\n\\quad\n\\Delta H = H_{\\mathrm{improper}} - H_{\\mathrm{proper}},\n$$\n每个值四舍五入到六位小数。将所有测试的结果按测试用例的顺序汇总到一个列表中，每个测试的两个差值交错排列。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[dC1,dH1,dC2,dH2,dC3,dH3,dC4,dH4]”）。不使用角度；偏移量直接以像素指定，因此不需要角度单位。所有输出均为不带单位的纯浮点数，四舍五入到六位小数。",
            "solution": "该问题要求分析混叠对源自灰度共生矩阵 (GLCM) 的放射组学特征的影响。这将通过构建一个合成图像体模，将其置于两种不同的重采样处理流程（一种适当，一种不当）中，并量化由此产生的 GLCM 特征“对比度”和“均匀性”的差异来完成。整个过程基于信号处理和图像分析的基本原理。\n\n### 采样与混叠原理\n\nShannon-Nyquist 采样定理是本次分析的理论基础。该定理指出，要从离散样本中完美重建一个连续时间信号，采样频率必须至少是信号中存在的最大频率分量的两倍。这个所需的最低采样频率被称为 Nyquist 速率。等效地，对于一个采样间隔为 $\\Delta t$ 的离散信号，可以被唯一表示的最高频率是 Nyquist 频率 $f_N = 1/(2\\Delta t)$。对于一个归一化像素间距为 $1$ 的数字图像，Nyquist 频率是 $f_N = 0.5$ 周期/像素。\n\n以各向同性的缩放因子 $s  1$ 对图像进行降采样，实际上是将采样间隔从 $1$ 增加到 $1/s$。因此，新的、更粗糙网格的 Nyquist 频率降低为 $f_{N, \\text{new}} = 0.5 \\times s$，单位是 周期/原始像素间距。\n\n当原始图像包含高于这个新的 Nyquist 频率 $f_{N, \\text{new}}$ 的频率时，就会发生混叠。这些高频分量并非简单地丢失了；它们被“折叠”或“混叠”到较低的频率范围 $[0, f_{N, \\text{new}}]$ 内，伪装成原始信号中不存在的、新的人为模式。“不当”重采样方法使用直接最近邻插值而没有任何预滤波，它无法阻止这种情况发生，因此如果输入图像包含足够高的频率，将会表现出混叠伪影。\n\n为避免混叠，必须执行抗混叠操作。这包括在重采样*之前*对原始图像应用一个低通滤波器，以移除任何高于 $f_{N, \\text{new}}$ 的频率分量。“适当”的重采样流程实现了这一点。对于缩放因子 $s  1$，它首先应用一个标准差为 $\\sigma = 0.6/s$ 的高斯低通滤波器。这个 $\\sigma$ 值是一个标准的启发式选择，旨在将滤波器的截止频率大致设置在新的 Nyquist 极限处，从而有效衰减会导致混叠的频率。在此滤波步骤之后，使用双线性插值进行重采样，与最近邻插值的块状伪影相比，它能提供更平滑的结果。\n\n### GLCM 与纹理特征原理\n\n灰度共生矩阵 (GLCM) 是一种统计工具，用于通过统计在特定空间偏移量下出现不同灰度级对的频率来分析纹理。对于量化为 $N_g$ 个灰度级的图像，GLCM（表示为 $P$）是一个 $N_g \\times N_g$ 的矩阵。对于偏移量 $(\\Delta x, \\Delta y)$，一个条目 $P(i,j)$ 统计了灰度级为 $i$ 的像素与灰度级为 $j$ 的像素在指定方向上相邻出现的次数。问题指定了一个对称 GLCM，这通过将偏移量 $(\\Delta x, \\Delta y)$ 的 GLCM 与其转置相加来实现。这使得分析对关系的方向不敏感（即，像素对 $(i,j)$ 与 $(j,i)$ 被同等对待）。然后对该矩阵进行归一化以形成概率分布 $\\hat{P}$。\n\n从此概率矩阵计算出纹理特征。问题指定了两种：\n1.  **对比度 (Contrast)**：$C = \\sum_{i=0}^{N_g-1} \\sum_{j=0}^{N_g-1} (i - j)^2 \\hat{P}(i,j)$。此特征衡量图像中的局部变化量。$(i-j)^2$ 项对灰度级差异大的像素对赋予更高的权重。高对比度表示存在急剧的过渡和高度的局部变化。混叠可能引入虚假的高频模式，预计会增加对比度特征的值。\n2.  **均匀性 (Homogeneity)**：$H = \\sum_{i=0}^{N_g-1} \\sum_{j=0}^{N_g-1} \\frac{\\hat{P}(i,j)}{1 + (i - j)^2}$。此特征也称为逆差矩，与对比度成反比。权重因子 $1/(1+(i-j)^2)$ 为灰度级相似的像素对赋予更高的值。高的均匀性值表示图像局部变化少，纹理更均匀。预计混叠会降低均匀性。\n\n### 算法实现\n\n该解决方案通过遵循问题陈述中列出的步骤来实现。\n\n1.  **体模生成**：创建一个 $256 \\times 256$ 的体模。它以强度为 $0.2$ 的均匀背景开始。从 $(64,64)$到 $(191,191)$ 的方形区域被设置为强度 $0.8$。对于包含光栅的测试用例，在一个水平条带内添加一个正弦模式 $0.2 \\cos(2\\pi x/p)$。最终的强度值被裁剪到 $[0,1]$ 范围内。\n2.  **重采样**：\n    *   **不当重采样**通过使用 `scipy.ndimage.zoom` 并设置参数 `order=0` 的最近邻插值来实现。\n    *   **适当重采样**是条件性实现的。如果缩放因子 $s  1$，首先对原始体模应用一个 $\\sigma=0.6/s$ 的高斯滤波器（`scipy.ndimage.gaussian_filter`）。然后，使用双线性插值（`scipy.ndimage.zoom` 并设置 `order=1`）对滤波后的图像进行重采样。如果 $s=1$，则跳过滤波步骤，仅应用双线性插值。\n3.  **量化**：所有图像（原始、不当重采样和适当重采样）都使用指定的舍入公式 $q = \\operatorname{round}(v(N_g-1))$ 量化为 $N_g=32$ 个灰度级，其中 $v$ 是像素强度。\n4.  **特征计算**：对于每个量化图像，计算水平偏移量 $(\\Delta x, \\Delta y) = (1,0)$ 的对称 GLCM。通过从相邻像素列创建一维灰度级数组并使用 `numpy.histogram2d` 可以高效地完成此操作。将生成的矩阵对称化、归一化，然后根据其定义用于计算对比度和均匀性。\n5.  **差异计算**：对于每个测试用例，使用来自不当重采样图像的特征（$C_{\\mathrm{improper}}, H_{\\mathrm{improper}}$）和来自适当重采样图像的特征（$C_{\\mathrm{proper}}, H_{\\mathrm{proper}}$）来计算差异 $\\Delta C = C_{\\mathrm{improper}} - C_{\\mathrm{proper}}$ 和 $\\Delta H = H_{\\mathrm{improper}} - H_{\\mathrm{proper}}$。\n\n此程序应用于四个指定的测试用例。差异 $\\Delta C$ 和 $\\Delta H$ 量化了混叠的影响。一个大的正 $\\Delta C$ 和一个大的负 $\\Delta H$ 表明两种重采样流程之间存在显著差异，这归因于不当方法中的混叠伪影，而这些伪影在适当方法中通过抗混叠滤波器得到了缓解。\n\n对于用例 1 ($p=3, s=0.5$)，光栅频率 $f = 1/3 \\approx 0.333$ 周期/像素 大于新的 Nyquist 频率 $f_{N, \\text{new}} = 0.5 \\times 0.5 = 0.25$ 周期/像素，导致强烈混叠。我们预期会有大的差异。对于用例 2 ($p=12, s=0.5$)，光栅频率 $f = 1/12 \\approx 0.083$ 低于新的 Nyquist 极限，因此预计不会发生光栅的混叠，差异应该很小。用例 3（无光栅, $s=0.5$）分离出了对锐利边缘的影响。用例 4 ($p=3, s=1.0$) 作为对照组，其中没有进行降采样，因此预计不会出现采样引起的混叠。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import ndimage\n\ndef generate_phantom(p=None, size=256):\n    \"\"\"\n    Constructs the synthetic image phantom.\n    \"\"\"\n    I = np.full((size, size), 0.2, dtype=np.float64)\n    I[64:192, 64:192] = 0.8\n    \n    if p is not None:\n        A = 0.2\n        x, y = np.meshgrid(np.arange(size), np.arange(size), indexing='xy')\n        \n        grating_mask = (x >= 32)  (x  224)  (y >= 96)  (y  160)\n        grating_term = A * np.cos(2 * np.pi * x / p)\n        \n        I[grating_mask] += grating_term[grating_mask]\n\n    return np.clip(I, 0.0, 1.0)\n\ndef quantize_image(img, Ng=32):\n    \"\"\"\n    Quantizes an image with intensities in [0,1] to Ng gray levels.\n    \"\"\"\n    quant_img = np.round(img * (Ng - 1))\n    return np.clip(quant_img, 0, Ng - 1).astype(int)\n\ndef resample_improper(img, s):\n    \"\"\"\n    Improper resampling using nearest-neighbor interpolation.\n    \"\"\"\n    return ndimage.zoom(img, s, order=0, mode='nearest')\n\ndef resample_proper(img, s):\n    \"\"\"\n    Proper resampling with anti-aliasing filter and bilinear interpolation.\n    \"\"\"\n    if s  1.0:\n        sigma = 0.6 / s\n        img_filtered = ndimage.gaussian_filter(img, sigma=sigma, mode='mirror')\n        return ndimage.zoom(img_filtered, s, order=1, mode='nearest')\n    else:  # s >= 1.0\n        return ndimage.zoom(img, s, order=1, mode='nearest')\n\ndef compute_glcm_features(quant_img, Ng=32):\n    \"\"\"\n    Computes a symmetric GLCM and its Contrast and Homogeneity features.\n    Offset is fixed to (dx=1, dy=0).\n    \"\"\"\n    if quant_img.shape[1]  2:\n        return 0.0, 0.0\n\n    # Extract pixel pairs for a (1,0) offset\n    i_vals = quant_img[:, :-1].ravel()\n    j_vals = quant_img[:, 1:].ravel()\n\n    # Compute GLCM using histogram2d\n    glcm = np.histogram2d(\n        i_vals, j_vals,\n        bins=(np.arange(Ng + 1), np.arange(Ng + 1))\n    )[0]\n\n    # Make the GLCM symmetric\n    glcm = glcm + glcm.T\n\n    # Normalize the GLCM to get a probability matrix\n    glcm_sum = glcm.sum()\n    if glcm_sum == 0:\n        return 0.0, 0.0\n    p_hat = glcm / glcm_sum\n\n    # Compute features\n    i_matrix, j_matrix = np.meshgrid(np.arange(Ng), np.arange(Ng), indexing='ij')\n    \n    # Contrast\n    weight_c = (i_matrix - j_matrix)**2\n    contrast = np.sum(weight_c * p_hat)\n\n    # Homogeneity\n    weight_h = 1.0 / (1.0 + (i_matrix - j_matrix)**2)\n    homogeneity = np.sum(weight_h * p_hat)\n\n    return contrast, homogeneity\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'p': 3, 's': 0.5},   # Case 1\n        {'p': 12, 's': 0.5},  # Case 2\n        {'p': None, 's': 0.5},# Case 3\n        {'p': 3, 's': 1.0},   # Case 4\n    ]\n\n    all_results = []\n    for case in test_cases:\n        p = case['p']\n        s = case['s']\n\n        # 1. Generate the original phantom\n        I_orig = generate_phantom(p=p)\n\n        # 2. Improper resampling pipeline\n        I_improper = resample_improper(I_orig, s)\n        Q_improper = quantize_image(I_improper)\n        C_improper, H_improper = compute_glcm_features(Q_improper)\n        \n        # 3. Proper resampling pipeline\n        I_proper = resample_proper(I_orig, s)\n        Q_proper = quantize_image(I_proper)\n        C_proper, H_proper = compute_glcm_features(Q_proper)\n\n        # 4. Calculate and store differences\n        delta_C = C_improper - C_proper\n        delta_H = H_improper - H_proper\n\n        all_results.extend([f\"{delta_C:.6f}\", f\"{delta_H:.6f}\"])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在放射组学中，并非所有图像数据都可以一概而論。本练习聚焦于一个关键且常见的陷阱：分割掩模（label image）的插值。我们将通过一个具体的计算案例，揭示为何诸如三次卷积插值这类在强度图像上表现优越的方法，应用于分类数据时会产生灾难性后果——创造出不存在的“伪类别”。这个练习强调了为不同数据类型选择合适工具的重要性，并巩固了为何应坚持对分割掩模使用最近邻插值的理解。",
            "id": "4546655",
            "problem": "在影像组学预处理中，标签图像是一个函数 $L:\\Omega\\subset\\mathbb{Z}^d\\to\\mathcal{C}$，其中 $\\mathcal{C}$ 是一个分类编码的有限集（例如，背景、器官、病灶）。与强度图像 $I:\\Omega\\to\\mathbb{R}$ 不同，标签图像携带分类语义，其 $\\mathcal{C}$ 上没有有意义的线性顺序或向量空间结构。将图像从一个体素网格重采样到另一个体素网格依赖于插值，而根据定义，插值假设底层量具有支持形成加权平均的代数结构。考虑广泛使用的立方卷积（在 $2\\text{D}$ 中也称为双三次）插值，它使用 Keys 核，参数为 $a=-\\frac{1}{2}$，定义了一个一维核 $h:\\mathbb{R}\\to\\mathbb{R}$：\n$$\nh(x)=\\begin{cases}\n(a+2)|x|^3-(a+3)|x|^2+1,0\\le |x|1,\\\\\na|x|^3-5a|x|^2+8a|x|-4a,1\\le |x|2,\\\\\n0,|x|\\ge 2,\n\\end{cases}\n$$\n其中 $a=-\\frac{1}{2}$。在样本 $y_1$ 和 $y_2$ 之间的小数偏移量 $t\\in[0,1]$ 处的插值使用四个相邻样本 $y_0,y_1,y_2,y_3$（索引从左到右递增）和权重：\n$$\nw_0=h(1+t),\\quad w_1=h(t),\\quad w_2=h(1-t),\\quad w_3=h(2-t),\n$$\n因此 $y(t)=w_0y_0+w_1y_1+w_2y_2+w_3y_3$。\n\n假设一个一维扫描线上的二值分割标签图像将背景编码为 $c=0$，血管编码为 $c=2$（即 $\\mathcal{C}=\\{0,2\\}$），在整数位置 $\\{x=0,1,2,3\\}$ 处的连续样本为 $\\{y_0,y_1,y_2,y_3\\}=\\{0,0,2,2\\}$。您通过在 $x=1.5$ 处进行插值（即在 $x=1$ 处的 $y_1$ 和 $x=2$ 处的 $y_2$ 之间 $t=\\frac{1}{2}$），将图像重采样到更精细的网格，然后通过四舍五入算子 $\\mathrm{round}(\\cdot)$ 将插值简单地转换为整数标签，而没有投影到有效编码集 $\\mathcal{C}$ 上。\n\n哪个选项从第一性原理出发，正确地解释了为什么最近邻插值是标签图像的首选方法，并且还正确地计算了使用 Keys 立方核得到的插值 $y\\!\\left(\\frac{1}{2}\\right)$，并指出了由此产生的伪类别及其对标签划分的影响？\n\nA. 标签图像是分类的；对编码进行平均没有语义意义，因为 $\\mathcal{C}$ 缺乏向量空间结构。最近邻插值通过选择一个已有的编码来保持成员关系。在 $t=\\frac{1}{2}$ 处使用 Keys 立方核（$a=-\\frac{1}{2}$），权重为 $w_1=h\\!\\left(\\frac{1}{2}\\right)=\\frac{9}{16}$，$w_2=h\\!\\left(\\frac{1}{2}\\right)=\\frac{9}{16}$，以及 $w_0=w_3=h\\!\\left(\\frac{3}{2}\\right)=-\\frac{1}{16}$，得出 $y\\!\\left(\\frac{1}{2}\\right)=0\\cdot\\!\\left(-\\frac{1}{16}\\right)+0\\cdot\\!\\left(\\frac{9}{16}\\right)+2\\cdot\\!\\left(\\frac{9}{16}\\right)+2\\cdot\\!\\left(-\\frac{1}{16}\\right)=1$。四舍五入产生整数标签 $1$，该标签不在 $\\mathcal{C}$ 中，从而引入了一个伪类别，并将标签划分从 $\\{0,2\\}$ 更改为 $\\{0,1,2\\}$。\n\nB. 最近邻插值不适用于标签图像，因为它会在边界处引起混叠；立方插值是安全的，因为四舍五入总能恢复有效的标签。对于给定的数据，$y\\!\\left(\\frac{1}{2}\\right)=\\frac{1}{2}(0+2)=1$，但四舍五入到最近的有效标签会得到 $2$，因此没有出现伪类别。\n\nC. 在单调段上的立方插值受样本凸包的限制，因此不能创建中间标签。对于 $\\{0,0,2,2\\}$，$y\\!\\left(\\frac{1}{2}\\right)=2$，并且最近邻插值是不必要的，因为立方插值保留了拓扑结构。\n\nD. 标签编码可以被视为概率；立方插值计算一个平滑的概率混合，而四舍五入只是恢复最大后验类别。对于给定的样本，$y\\!\\left(\\frac{1}{2}\\right)=\\frac{3}{2}$，四舍五入后为 $2$，并保留了原始类别。",
            "solution": "问题陈述是有效的。其科学依据在于数字图像处理和影像组学的原理，提法恰当，提供了所有必要的数据和定义，并以客观、正式的语言编写。其中没有矛盾、歧义或事实错误。\n\n该问题需要进行两部分分析：首先，对分类标签图像选择插值方法进行概念上的合理解释；其次，使用立方卷积插值进行具体计算。\n\n**第 1 部分：概念上的合理解释（分类数据的插值）**\n\n标签图像是一个函数 $L:\\Omega\\subset\\mathbb{Z}^d\\to\\mathcal{C}$，其中 $\\mathcal{C}$ 是一个分类编码的有限集。在本问题中，$\\mathcal{C}=\\{0,2\\}$，分别代表背景和血管。这些编码是标识符或标签，而不是连续尺度上的量。集合 $\\mathcal{C}$ 不是一个向量空间；加法和标量乘法等运算没有语义意义。例如，$0.5 \\times (\\text{背景}) + 0.5 \\times (\\text{血管})$ 的意义是什么？结果不是一个已定义的类别。\n\n线性、立方或样条等插值方法基于计算相邻样本值的加权平均。这种数学结构隐含地假设底层数据空间是一个连续体，其中这样的平均值是有意义的（例如，实向量空间 $\\mathbb{R}$）。当应用于像图像标签这样的分类数据时，这些方法可能会产生原始编码集 $\\mathcal{C}$ 之外的值。例如，在标签 $0$ 和标签 $2$ 之间插值可能会得到 $1$、$1.5$ 或任何其他实数，这些都不是有效的标签。这会引入伪类别并破坏分割图。\n\n相比之下，最近邻插值将原始网格中最近样本的值赋给新网格位置。它本身不对标签编码执行任何算术运算。因此，输出值始终是原始集合 $\\mathcal{C}$ 的一个元素。这种保持标签集的特性，是为什么最近邻插值是重采样分类图像（如分割图或掩模）的标准和概念上正确的方法。\n\n**第 2 部分：使用 Keys 立方核进行计算**\n\n我们需要计算在 $x=1.5$ 处的插值。该点位于 $x=1$ 处（值为 $y_1=0$）的样本和 $x=2$ 处（值为 $y_2=2$）的样本之间的一半位置。因此，小数偏移量为 $t = 1.5 - 1 = 0.5$，即 $t=\\frac{1}{2}$。插值使用四个相邻样本 $\\{y_0, y_1, y_2, y_3\\} = \\{0, 0, 2, 2\\}$。\n\n插值由 $y(t) = w_0 y_0 + w_1 y_1 + w_2 y_2 + w_3 y_3$ 给出。\n$t=\\frac{1}{2}$ 时的权重为：\n$w_1 = h(t) = h(\\frac{1}{2})$\n$w_2 = h(1-t) = h(1-\\frac{1}{2}) = h(\\frac{1}{2})$\n$w_0 = h(1+t) = h(1+\\frac{1}{2}) = h(\\frac{3}{2})$\n$w_3 = h(2-t) = h(2-\\frac{1}{2}) = h(\\frac{3}{2})$\n\n我们使用参数 $a=-\\frac{1}{2}$ 的 Keys 核公式：\n$$\nh(x)=\\begin{cases}\n(a+2)|x|^3-(a+3)|x|^2+1,0\\le |x|1,\\\\\na|x|^3-5a|x|^2+8a|x|-4a,1\\le |x|2,\\\\\n0,|x|\\ge 2,\n\\end{cases}\n$$\n\n首先，我们计算权重。\n对于 $x = \\frac{1}{2}$（在 $[0, 1)$ 区间内），我们使用 $h(x)$ 的第一种情况：\n当 $a = -\\frac{1}{2}$ 时，我们有 $a+2 = \\frac{3}{2}$ 和 $a+3 = \\frac{5}{2}$。\n$$\nw_1 = w_2 = h\\left(\\frac{1}{2}\\right) = \\left(\\frac{3}{2}\\right)\\left|\\frac{1}{2}\\right|^3 - \\left(\\frac{5}{2}\\right)\\left|\\frac{1}{2}\\right|^2 + 1 = \\frac{3}{2}\\cdot\\frac{1}{8} - \\frac{5}{2}\\cdot\\frac{1}{4} + 1 = \\frac{3}{16} - \\frac{5}{8} + 1 = \\frac{3}{16} - \\frac{10}{16} + \\frac{16}{16} = \\frac{9}{16}\n$$\n\n对于 $x = \\frac{3}{2}$（在 $[1, 2)$ 区间内），我们使用 $h(x)$ 的第二种情况：\n$$\nw_0 = w_3 = h\\left(\\frac{3}{2}\\right) = a\\left|\\frac{3}{2}\\right|^3 - 5a\\left|\\frac{3}{2}\\right|^2 + 8a\\left|\\frac{3}{2}\\right| - 4a\n$$\n提出因子 $a$：\n$$\nh\\left(\\frac{3}{2}\\right) = a \\left[ \\left(\\frac{3}{2}\\right)^3 - 5\\left(\\frac{3}{2}\\right)^2 + 8\\left(\\frac{3}{2}\\right) - 4 \\right] = -\\frac{1}{2} \\left[ \\frac{27}{8} - 5\\left(\\frac{9}{4}\\right) + 12 - 4 \\right]\n$$\n$$\nh\\left(\\frac{3}{2}\\right) = -\\frac{1}{2} \\left[ \\frac{27}{8} - \\frac{90}{8} + \\frac{64}{8} \\right] = -\\frac{1}{2} \\left[ \\frac{27 - 90 + 64}{8} \\right] = -\\frac{1}{2} \\left[ \\frac{1}{8} \\right] = -\\frac{1}{16}\n$$\n\n现在，我们计算插值 $y\\left(\\frac{1}{2}\\right)$：\n$$\ny\\left(\\frac{1}{2}\\right) = w_0 y_0 + w_1 y_1 + w_2 y_2 + w_3 y_3 = \\left(-\\frac{1}{16}\\right)(0) + \\left(\\frac{9}{16}\\right)(0) + \\left(\\frac{9}{16}\\right)(2) + \\left(-\\frac{1}{16}\\right)(2)\n$$\n$$\ny\\left(\\frac{1}{2}\\right) = 0 + 0 + \\frac{18}{16} - \\frac{2}{16} = \\frac{16}{16} = 1\n$$\n插值为 $1$。问题陈述这被简单地使用四舍五入算子转换为整数。由于 $y\\left(\\frac{1}{2}\\right) = 1$ 是一个整数，$\\mathrm{round}(1) = 1$。\n\n**第 3 部分：结果的含义**\n\n得到的标签是 $1$。原始有效标签集是 $\\mathcal{C}=\\{0,2\\}$。新标签 $1$ 不是 $\\mathcal{C}$ 的成员。这是一个**伪类别**。插值在背景和血管之间的边界上创建了一个新的、不存在的类别。这从根本上改变了图像的标签划分，将活动标签集从 $\\{0,2\\}$ 更改为 $\\{0,1,2\\}$。这会破坏分割，并会导致任何下游定量分析（影像组学）出错。生成超出局部样本范围的值的现象（“过冲”，尽管这里相对于 $\\{0,2\\}$ 的局部值是“下冲”，但全局上是一个中间值）是 Keys 核的一个已知特性，由其负波瓣引起。\n\n**逐项分析**\n\n*   **A**：该选项正确地指出标签图像是分类的，平均操作没有意义。它正确地指出最近邻是首选方法。它正确地计算了权重 $w_1=w_2=\\frac{9}{16}$ 和 $w_0=w_3=-\\frac{1}{16}$。它正确地计算了插值 $y(\\frac{1}{2}) = 1$。最后，它正确地指出结果是一个伪类别 $1$，不在 $\\mathcal{C}=\\{0,2\\}$ 中，这改变了标签划分。该选项完全正确。\n    **结论：正确**\n\n*   **B**：该选项错误地声称最近邻插值不被推荐。它恰恰是分类数据的首选方法。它错误地声称立方插值是“安全的”，并且四舍五入能恢复有效标签，我们的计算证明这是错误的。计算 $y(\\frac{1}{2})=\\frac{1}{2}(0+2)=1$ 对应的是线性插值，而不是指定的立方插值。声称没有伪类别出现是错误的。\n    **结论：错误**\n\n*   **C**：该选项提出了错误的说法，即立方插值受样本凸包的限制。负权重（$-\\frac{1}{16}$）的存在证明了这是错误的，并且可能会发生过冲/下冲。计算 $y(\\frac{1}{2}) = 2$ 是不正确的。声称立方插值保留了拓扑结构也是错误的；创建新标签会从根本上改变对象的连通性。\n    **结论：错误**\n\n*   **D**：该选项基于一个错误的前提，即标签编码可以被视为概率，这是一个概念性错误。问题将它们定义为分类编码。计算 $y(\\frac{1}{2}) = \\frac{3}{2}$ 是不正确的；正确的值是 $1$。基于这个不正确值的后续推理也是无效的。\n    **结论：错误**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "前面的练习揭示了放射组学特征值会随重采样参数的变化而改变。最后的这个实践将带领我们从发现问题走向系统性地量化其影响。我们将从第一性原理出发，实现“组内相关系数”（Intraclass Correlation Coefficient, $ICC$）的计算，用它来评估特征在不同重采样设置下的稳定性。通过这项练习，您将掌握一种核心的统计方法，学会如何筛选出稳健的特征，为构建可靠的放射组学模型奠定坚实基础。",
            "id": "4546583",
            "problem": "在放射组学中，通常在使用选定的插值方法将图像重采样到共同的体素间距后，计算量化的图像特征。预处理的选择，例如以毫米（mm）为单位的重采样间距和插值核，会改变特征值。一个关键问题是放射组学特征对这些选择的鲁棒性如何。评估鲁棒性的一种原则性方法是将每个预处理配置视为一个评分者（测量条件），并使用组内相关系数（Intraclass Correlation Coefficient, ICC）来评估这些条件之间的一致性。本问题的目标是，根据第一性原理，为一组在多种重采样间距和插值核下测量的特征，计算双向随机效应、单一测量、绝对一致性的组内相关系数（ICC），记为 $ICC(A,1)$，然后识别在指定阈值下具有鲁棒性的特征子集。\n\n基本原理和定义：考虑一个双向随机效应模型，用于评分者 $j$ 对受试者 $i$ 的测量值 $y_{ij}$，\n$$\ny_{ij} = \\mu + \\alpha_i + \\beta_j + \\varepsilon_{ij},\n$$\n其中 $i \\in \\{1,\\dots,N\\}$ 为受试者索引，$j \\in \\{1,\\dots,K\\}$ 为评分者（测量条件）索引，$\\mu$ 是一个固定的总均值，$\\alpha_i$ 是方差为 $\\sigma_{\\alpha}^2$ 的随机受试者效应，$\\beta_j$ 是方差为 $\\sigma_{\\beta}^2$ 的随机评分者效应，$\\varepsilon_{ij}$ 是方差为 $\\sigma_{\\varepsilon}^2$ 的独立误差。设 $Y$ 为 $N \\times K$ 的观测矩阵。定义以下均值：总均值 $\\bar{y}_{..}$，受试者均值 $\\bar{y}_{i.}$（对于 $i \\in \\{1,\\dots,N\\}$），以及评分者均值 $\\bar{y}_{.j}$（对于 $j \\in \\{1,\\dots,K\\}$）。方差分析（Analysis of Variance, ANOVA）的均方通过以下方式计算：\n$$\nSS_{\\text{subjects}} = K \\sum_{i=1}^{N} \\left(\\bar{y}_{i.} - \\bar{y}_{..}\\right)^2,\\quad MS_{\\text{subjects}} = \\frac{SS_{\\text{subjects}}}{N-1},\n$$\n$$\nSS_{\\text{raters}} = N \\sum_{j=1}^{K} \\left(\\bar{y}_{.j} - \\bar{y}_{..}\\right)^2,\\quad MS_{\\text{raters}} = \\frac{SS_{\\text{raters}}}{K-1},\n$$\n$$\nSS_{\\text{error}} = \\sum_{i=1}^{N}\\sum_{j=1}^{K} \\left(y_{ij} - \\bar{y}_{i.} - \\bar{y}_{.j} + \\bar{y}_{..}\\right)^2,\\quad MS_{\\text{error}} = \\frac{SS_{\\text{error}}}{(N-1)(K-1)}.\n$$\n然后，双向随机效应、单一测量、绝对一致性的组内相关系数为\n$$\nICC(A,1) = \\frac{MS_{\\text{subjects}} - MS_{\\text{error}}}{MS_{\\text{subjects}} + (K-1)MS_{\\text{error}} + \\frac{K}{N}\\left(MS_{\\text{raters}} - MS_{\\text{error}}\\right)}.\n$$\n\n数据集和测量条件：有 $N=5$ 个受试者和 $F=5$ 个特征，在 $K=4$ 种重采样配置（评分者）下进行测量。每种配置对应于重采样间距（单位：mm）和插值核的组合：\n- 评分者 $r_0$：间距 $1.0$ mm，线性插值。\n- 评分者 $r_1$：间距 $1.0$ mm，三次B样条插值。\n- 评分者 $r_2$：间距 $2.0$ mm，线性插值。\n- 评分者 $r_3$：间距 $2.0$ mm，最近邻插值。\n\n对于每个评分者 $r_j$，给定一个 $5 \\times 5$ 的矩阵 $Y^{(j)}$，其行索引受试者 $i \\in \\{1,\\dots,5\\}$，列索引特征 $f \\in \\{0,\\dots,4\\}$。这些矩阵是：\n\n对于 $r_0$：\n$$\nY^{(0)} = \\begin{bmatrix}\n10  5  8.0  20  100 \\\\\n12  5.5  8.2  25  100 \\\\\n14  6  7.9  30  100 \\\\\n16  6.5  8.1  35  100 \\\\\n18  7  8.0  40  100 \\\\\n\\end{bmatrix}.\n$$\n\n对于 $r_1$：\n$$\nY^{(1)} = \\begin{bmatrix}\n10  5.5  10.0  21  100 \\\\\n12  6.0  10.2  24  100 \\\\\n15  6.5  9.9  32  100 \\\\\n16  7.0  10.1  33  100 \\\\\n17  7.5  10.0  40  100 \\\\\n\\end{bmatrix}.\n$$\n\n对于 $r_2$：\n$$\nY^{(2)} = \\begin{bmatrix}\n9.8  4.4  6.0  20.5  100 \\\\\n12.1  4.8  6.2  24.5  100 \\\\\n14.3  5.5  5.9  30.5  100 \\\\\n15.9  5.9  6.1  34.5  100 \\\\\n17.9  6.2  6.0  40.5  100 \\\\\n\\end{bmatrix}.\n$$\n\n对于 $r_3$：\n$$\nY^{(3)} = \\begin{bmatrix}\n11  6.2  9.0  22  100 \\\\\n11  6.3  7.2  26  100 \\\\\n14  6.9  8.4  33  100 \\\\\n17  7.6  7.6  36  100 \\\\\n17  8.0  8.0  42  100 \\\\\n\\end{bmatrix}.\n$$\n\n你的任务：\n1. 为给定的一组评分者选择下的单个特征，实现上述定义的 $ICC(A,1)$ 计算。给定一组评分者索引 $\\mathcal{J} \\subseteq \\{0,1,2,3\\}$，通过连接所选评分者中目标特征的相应列，形成 $N \\times K'$ 矩阵 $Y_{\\mathcal{J}}$，其中 $K' = |\\mathcal{J}|$。然后使用上述公式从 $Y_{\\mathcal{J}}$ 计算 $ICC(A,1)$。如果 $K'  2$ 或 $ICC(A,1)$ 表达式中的分母为零，则将得到的 $ICC(A,1)$ 定义为 $0.0$。\n2. 对于下面的每个测试用例，计算每个特征 $f \\in \\{0,1,2,3,4\\}$ 在指定评分者下的 $ICC(A,1)$，然后选出鲁棒特征的索引，定义为那些 $ICC(A,1) \\ge \\tau$ 的特征，其中 $\\tau$ 是给定的阈值。\n\n测试套件：\n- 用例 1 (happy path)：评分者 $\\mathcal{J}_1 = \\{0,1,2,3\\}$，阈值 $\\tau_1 = 0.85$。\n- 用例 2 (间距变化，核类型相同)：评分者 $\\mathcal{J}_2 = \\{0,2\\}$，阈值 $\\tau_2 = 0.70$。\n- 用例 3 (固定间距下核的变化)：评分者 $\\mathcal{J}_3 = \\{0,1\\}$，阈值 $\\tau_3 = 0.90$。\n\n角度单位不适用。物理单位是毫米，用于重采样间距，但要报告的输出是无单位的相关系数，仅用于阈值判断。每个用例的最终答案是整数列表。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是对应测试用例的鲁棒特征索引列表，按用例 1、2、3 的顺序排列。例如，一个包含三个用例的输出应如下所示：$[[i_{1,1},i_{1,2}], [i_{2,1}], [\\,]]$，表示第一个用例选择了两个特征，第二个用例选择了一个特征，第三个用例没有选择任何特征。请确保除了列表格式本身包含的空格外，不插入任何多余的空格。",
            "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于可靠性分析的统计理论，特别是在放射组学中应用的组内相关系数（ICC）。该问题定义明确、客观，并为得出唯一解提供了所有必要的数据和数学定义。\n\n问题的核心是评估放射组学特征对图像预处理参数变化的鲁棒性。这是通过将每个独特的预处理配置（重采样间距和插值核的组合）视为一个“评分者”来实现的。这些评分者对一组受试者测量的结果之间的一致性，使用组内相关系数进行量化。高ICC值表明特征值在不同的预处理选择下是稳定的，使其成为一个鲁棒且可靠的生物标志物。\n\n要计算的特定ICC形式是 $ICC(A,1)$，它对应于一个双向随机效应模型，评估单一测量的绝对一致性。该模型假设受试者和评分者都是从更大的群体中随机抽取的样本，这对于推广研究结果是合适的。评分者 $j$ 对受试者 $i$ 的测量值 $y_{ij}$ 的模型由下式给出：\n$$\ny_{ij} = \\mu + \\alpha_i + \\beta_j + \\varepsilon_{ij}\n$$\n在这里，$i \\in \\{1,\\dots,N\\}$ 为受试者索引，$j \\in \\{1,\\dots,K\\}$ 为评分者索引。$\\mu$ 是总均值，$\\alpha_i \\sim \\mathcal{N}(0, \\sigma_{\\alpha}^2)$ 是受试者 $i$ 的随机效应，$\\beta_j \\sim \\mathcal{N}(0, \\sigma_{\\beta}^2)$ 是评分者 $j$ 的随机效应，$\\varepsilon_{ij} \\sim \\mathcal{N}(0, \\sigma_{\\varepsilon}^2)$ 是残差项。所有随机效应均假设为独立的。\n\n$ICC(A,1)$ 的计算依赖于对数据总变异性的方差分析（ANOVA）分解。给定一个 $N \\times K$ 的测量数据矩阵 $Y$，第一步是计算所需的均方。\n\n首先，我们定义必要的均值：\n- 总均值：$\\bar{y}_{..} = \\frac{1}{NK} \\sum_{i=1}^{N} \\sum_{j=1}^{K} y_{ij}$\n- 受试者均值（行均值）：对于每个受试者 $i$，$\\bar{y}_{i.} = \\frac{1}{K} \\sum_{j=1}^{K} y_{ij}$。\n- 评分者均值（列均值）：对于每个评分者 $j$，$\\bar{y}_{.j} = \\frac{1}{N} \\sum_{i=1}^{N} y_{ij}$。\n\n接下来，我们计算平方和（$SS$）和均方（$MS$）。自由度为 $df_{\\text{subjects}} = N-1$，$df_{\\text{raters}} = K-1$ 和 $df_{\\text{error}} = (N-1)(K-1)$。\n\n- **受试者间方差**：这反映了被测量的不同受试者之间的变异性。\n$$\nSS_{\\text{subjects}} = K \\sum_{i=1}^{N} \\left(\\bar{y}_{i.} - \\bar{y}_{..}\\right)^2\n$$\n$$\nMS_{\\text{subjects}} = \\frac{SS_{\\text{subjects}}}{N-1}\n$$\n\n- **评分者间方差**：这捕捉了评分者（预处理配置）之间的系统性差异。\n$$\nSS_{\\text{raters}} = N \\sum_{j=1}^{K} \\left(\\bar{y}_{.j} - \\bar{y}_{..}\\right)^2\n$$\n$$\nMS_{\\text{raters}} = \\frac{SS_{\\text{raters}}}{K-1}\n$$\n\n- **残差方差**：这是在考虑了受试者和评分者效应后剩余的未解释方差。\n$$\nSS_{\\text{error}} = \\sum_{i=1}^{N}\\sum_{j=1}^{K} \\left(y_{ij} - \\bar{y}_{i.} - \\bar{y}_{.j} + \\bar{y}_{..}\\right)^2\n$$\n$$\nMS_{\\text{error}} = \\frac{SS_{\\text{error}}}{(N-1)(K-1)}\n$$\n\n有了这些均方，就可以使用提供的公式计算 $ICC(A,1)$，该公式将这些观测到的方差与模型的基本方差分量（$\\sigma_{\\alpha}^2, \\sigma_{\\beta}^2, \\sigma_{\\varepsilon}^2$）联系起来：\n$$\nICC(A,1) = \\frac{\\sigma_{\\alpha}^2}{\\sigma_{\\alpha}^2 + \\sigma_{\\beta}^2 + \\sigma_{\\varepsilon}^2} = \\frac{MS_{\\text{subjects}} - MS_{\\text{error}}}{MS_{\\text{subjects}} + (K-1)MS_{\\text{error}} + \\frac{K}{N}\\left(MS_{\\text{raters}} - MS_{\\text{error}}\\right)}\n$$\n该问题指定了两种边缘情况：如果 $K  2$（即，可供比较的评分者少于两个），或者表达式的分母为零，则得到的 $ICC(A,1)$ 定义为 $0.0$。例如，当数据中完全没有方差时（例如，所有测量值都相同），分母会为零，这会正确地得到 ICC 为 $0$。\n\n解决该问题的总体算法流程如下：\n1.  存储四个数据矩阵 $Y^{(0)}, Y^{(1)}, Y^{(2)}, Y^{(3)}$。每个矩阵都是 $5 \\times 5$ 的，表示在 $K_{total}=4$ 个评分者条件之一下的 $N=5$ 个受试者和 $F=5$ 个特征。\n2.  顺序处理三个测试用例中的每一个。一个测试用例由一组评分者索引 $\\mathcal{J}$ 和一个鲁棒性阈值 $\\tau$ 定义。\n3.  对于给定的测试用例，我们遍历每个特征 $f \\in \\{0, 1, 2, 3, 4\\}$。\n4.  对于每个特征 $f$，构造一个 $N \\times K'$ 的数据矩阵 $Y_{\\mathcal{J},f}$，其中 $K' = |\\mathcal{J}|$。该矩阵的列是特征 $f$ 在受试者上的值，这些值是从与评分者索引 $j \\in \\mathcal{J}$ 对应的数据矩阵 $Y^{(j)}$ 中提取的。\n5.  以 $Y_{\\mathcal{J},f}$ 为输入调用计算 $ICC(A,1)$ 的函数。该函数实现了上述的 ANOVA 计算。\n6.  将计算出的 $ICC(A,1)$ 值与当前测试用例的阈值 $\\tau$ 进行比较。如果 $ICC(A,1) \\ge \\tau$，则认为特征索引 $f$ 是鲁棒的，并将其添加到该用例的列表中。\n7.  在处理完一个测试用例的所有特征后，存储鲁棒特征索引的列表。\n8.  最后，将收集到的所有三个用例的索引列表格式化为指定的单个字符串：`[[...],[...],[...]]`，不含多余空格。这是通过将每个内部列表转换为逗号分隔的字符串，用逗号连接这些字符串，并将最终结果括在方括号中来实现的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_icc_a1(Y: np.ndarray) -> float:\n    \"\"\"\n    Computes the two-way random-effects single-measure absolute-agreement ICC, ICC(A,1).\n    \n    Args:\n        Y: An N x K numpy array where N is the number of subjects and K is the number of raters.\n    \n    Returns:\n        The ICC(A,1) value as a float.\n    \"\"\"\n    N, K = Y.shape\n\n    # As per problem, if K'  2, ICC is 0.0.\n    if K  2:\n        return 0.0\n\n    # Calculate means\n    # y_i.\n    y_subject_means = np.mean(Y, axis=1)\n    # y_.j\n    y_rater_means = np.mean(Y, axis=0)\n    # y_..\n    y_grand_mean = np.mean(Y)\n\n    # Calculate Sums of Squares (SS)\n    ss_subjects = K * np.sum((y_subject_means - y_grand_mean)**2)\n    ss_raters = N * np.sum((y_rater_means - y_grand_mean)**2)\n    \n    # Calculate SS_error using the explicit formula to be exact\n    # SS_error = sum_i sum_j (y_ij - y_i. - y_.j + y_..)^2\n    # Broadcasting y_subject_means requires reshaping to (N, 1)\n    # Broadcasting y_rater_means requires reshaping to (1, K)\n    residuals = Y - y_subject_means[:, np.newaxis] - y_rater_means[np.newaxis, :] + y_grand_mean\n    ss_error = np.sum(residuals**2)\n\n    # Calculate Mean Squares (MS)\n    df_subjects = N - 1\n    df_raters = K - 1\n    df_error = (N - 1) * (K - 1)\n\n    # Handle cases with 0 degrees of freedom, though not expected with N=5, K>=2\n    ms_subjects = ss_subjects / df_subjects if df_subjects > 0 else 0.0\n    ms_raters = ss_raters / df_raters if df_raters > 0 else 0.0\n    ms_error = ss_error / df_error if df_error > 0 else 0.0\n    \n    # Calculate ICC(A,1)\n    numerator = ms_subjects - ms_error\n    denominator = ms_subjects + (K - 1) * ms_error + (K / N) * (ms_raters - ms_error)\n\n    # As per problem, if denominator is zero, ICC is 0.0\n    if denominator == 0.0:\n        return 0.0\n    \n    icc = numerator / denominator\n    return icc\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute robust features.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    Y0 = np.array([\n        [10.0, 5.0, 8.0, 20.0, 100.0],\n        [12.0, 5.5, 8.2, 25.0, 100.0],\n        [14.0, 6.0, 7.9, 30.0, 100.0],\n        [16.0, 6.5, 8.1, 35.0, 100.0],\n        [18.0, 7.0, 8.0, 40.0, 100.0],\n    ])\n\n    Y1 = np.array([\n        [10.0, 5.5, 10.0, 21.0, 100.0],\n        [12.0, 6.0, 10.2, 24.0, 100.0],\n        [15.0, 6.5, 9.9,  32.0, 100.0],\n        [16.0, 7.0, 10.1, 33.0, 100.0],\n        [17.0, 7.5, 10.0, 40.0, 100.0],\n    ])\n\n    Y2 = np.array([\n        [9.8, 4.4, 6.0, 20.5, 100.0],\n        [12.1, 4.8, 6.2, 24.5, 100.0],\n        [14.3, 5.5, 5.9, 30.5, 100.0],\n        [15.9, 5.9, 6.1, 34.5, 100.0],\n        [17.9, 6.2, 6.0, 40.5, 100.0],\n    ])\n\n    Y3 = np.array([\n        [11.0, 6.2, 9.0, 22.0, 100.0],\n        [11.0, 6.3, 7.2, 26.0, 100.0],\n        [14.0, 6.9, 8.4, 33.0, 100.0],\n        [17.0, 7.6, 7.6, 36.0, 100.0],\n        [17.0, 8.0, 8.0, 42.0, 100.0],\n    ])\n    \n    all_Y_matrices = [Y0, Y1, Y2, Y3]\n    num_features = Y0.shape[1]\n\n    test_cases = [\n        {'raters': [0, 1, 2, 3], 'tau': 0.85},\n        {'raters': [0, 2], 'tau': 0.70},\n        {'raters': [0, 1], 'tau': 0.90},\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        raters_indices = case['raters']\n        tau = case['tau']\n        robust_features = []\n\n        for f_idx in range(num_features):\n            # Construct the N x K' data matrix for the current feature and rater set\n            data_columns = [all_Y_matrices[r_idx][:, f_idx] for r_idx in raters_indices]\n            Y_feature = np.stack(data_columns, axis=1)\n            \n            # Calculate ICC(A,1)\n            icc_value = calculate_icc_a1(Y_feature)\n            \n            # Check for robustness\n            if icc_value >= tau:\n                robust_features.append(f_idx)\n        \n        final_results.append(robust_features)\n\n    # Format the output string as per requirements: [[x,y],[z],[]]\n    results_str_list = []\n    for res_list in final_results:\n        inner_str = f\"[{','.join(map(str, res_list))}]\"\n        results_str_list.append(inner_str)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```"
        }
    ]
}