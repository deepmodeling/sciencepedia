{
    "hands_on_practices": [
        {
            "introduction": "在将水平集方法应用于图像分割时，第一步是定义一个初始轮廓。本练习将带你亲手实践如何为一个简单的几何形状（一个圆形）在数字图像网格上创建其隐式表示，即符号距离函数（Signed Distance Function, SDF）。通过这个过程，你将在抽象的数学概念与其在图像处理中的具体应用之间建立起一座桥梁。",
            "id": "4548887",
            "problem": "一个二维放射影像切片被建模为一个大小为 $128 \\times 128$ 像素的离散图像网格。在水平集分割中，演化的轮廓被隐式地表示为一个嵌入函数 $\\phi$ 的零水平集，约定在分割的目标区域（ROI）内部 $\\phi  0$，而在外部 $\\phi > 0$。位于坐标 $(i_{1}, j_{1})$ 和 $(i_{2}, j_{2})$ 的两个像素中心之间的欧几里得距离定义为 $\\sqrt{(i_{1} - i_{2})^{2} + (j_{1} - j_{2})^{2}}$，并且像素中心位于整数坐标 $(i, j)$ 处，其中 $i, j \\in \\{0, 1, \\dots, 127\\}$。假设圆形种子区域的中心位于 $(i_{0}, j_{0}) = (64, 64)$，半径为 $r = 13$ 像素。\n\n仅使用水平集嵌入函数的零水平集编码目标轮廓这一定义，在此网格上构建一个初始的 $\\phi$，将给定的圆形种子区域编码为有符号嵌入，然后计算离散像素坐标中的零水平集，即所有满足 $\\phi(i, j) = 0$ 的整数对 $(i, j)$ 的集合。将最终的 $(i, j)$ 对列表表示为单个行矩阵，按 $i$ 然后按 $j$ 的升序字典序排序。无需舍入；坐标是精确的整数且无量纲。",
            "solution": "问题陈述已经过严格评估，并被确定为有效。它在科学上基于水平集方法和计算几何的原理，问题定义良好，提供了所有必要信息且无矛盾，并以客观、正式的语言表述。因此，我们可以着手求解。\n\n该问题要求为一个圆形区域构建一个水平集函数 $\\phi$，并在离散像素网格上确定其零水平集。水平集函数 $\\phi$ 隐式地将轮廓表示为 $\\phi=0$ 的点集。$\\phi$ 的符号表示一个点是在区域内部 ($\\phi  0$) 还是外部 ($\\phi > 0$)。\n\n对于一个几何形状，最自然的嵌入函数选择是符号距离函数（SDF）。对于坐标为 $(i, j)$ 的点和一个以 $(i_0, j_0)$ 为中心、半径为 $r$ 的圆形轮廓，SDF 定义为该点到中心的欧几里得距离减去半径：\n$$\n\\phi(i, j) = \\sqrt{(i - i_{0})^{2} + (j - j_{0})^{2}} - r\n$$\n对于圆内的点（到中心的距离小于 $r$），此函数为负；对于圆外的点，此函数为正；对于恰好在圆上的点，此函数为零。\n\n问题指定圆形种子区域的中心为 $(i_0, j_0) = (64, 64)$，半径为 $r = 13$。像素坐标 $(i, j)$ 是整数。我们的任务是找到零水平集，即所有满足 $\\phi(i, j) = 0$ 的整数对 $(i, j)$ 的集合。\n将 $\\phi(i, j)$ 的表达式设为零，得到：\n$$\n\\sqrt{(i - 64)^{2} + (j - 64)^{2}} - 13 = 0\n$$\n$$\n\\sqrt{(i - 64)^{2} + (j - 64)^{2}} = 13\n$$\n将方程两边平方，我们得到：\n$$\n(i - 64)^{2} + (j - 64)^{2} = 13^{2} = 169\n$$\n这是一个丢番图方程，表示整数格点上的一个圆。我们需要找到所有的整数解。我们引入变量替换来简化问题：\n令 $x = i - 64$ 和 $y = j - 64$。方程变为：\n$$\nx^{2} + y^{2} = 169\n$$\n我们需要找到所有满足此方程的整数对 $(x, y)$。这些整数对与勾股数有关。我们可以通过测试 $x$ 从 $0$ 到 $\\lfloor\\sqrt{169}\\rfloor = 13$ 的整数值来系统地找到整数解。\n\n- 如果 $x=0$，$y^2 = 169 \\implies y = \\pm 13$。这得到整数对 $(0, 13)$ 和 $(0, -13)$。\n- 如果 $x=1$，$y^2 = 169 - 1 = 168$，不是完全平方数。\n- 如果 $x=2$，$y^2 = 169 - 4 = 165$，不是完全平方数。\n- 如果 $x=3$，$y^2 = 169 - 9 = 160$，不是完全平方数。\n- 如果 $x=4$，$y^2 = 169 - 16 = 153$，不是完全平方数。\n- 如果 $x=5$，$y^2 = 169 - 25 = 144 \\implies y = \\pm 12$。这得到整数对 $(5, 12)$ 和 $(5, -12)$。\n- 如果 $x=6$，$y^2 = 169 - 36 = 133$，不是完全平方数。\n- 如果 $x=7$，$y^2 = 169 - 49 = 120$，不是完全平方数。\n- 如果 $x=8$，$y^2 = 169 - 64 = 105$，不是完全平方数。\n- 如果 $x=9$，$y^2 = 169 - 81 = 88$，不是完全平方数。\n- 如果 $x=10$，$y^2 = 169 - 100 = 69$，不是完全平方数。\n- 如果 $x=11$，$y^2 = 169 - 121 = 48$，不是完全平方数。\n- 如果 $x=12$，$y^2 = 169 - 144 = 25 \\implies y = \\pm 5$。这得到整数对 $(12, 5)$ 和 $(12, -5)$。\n- 如果 $x=13$，$y^2 = 169 - 169 = 0 \\implies y = 0$。这得到整数对 $(13, 0)$。\n\n根据对称性，如果 $(x, y)$ 是一个解，那么 $(-x, y)$、$(x, -y)$、$(-x, -y)$、$(y, x)$、$(-y, x)$、$(y, -x)$ 和 $(-y, -x)$ 也都是解。整理所有唯一的整数对 $(x, y)$：\n1. 从基本对 $(0, 13)$ 得到：$(0, 13), (0, -13), (13, 0), (-13, 0)$。\n2. 从基本对 $(5, 12)$ 得到：$(5, 12), (5, -12), (-5, 12), (-5, -12), (12, 5), (12, -5), (-12, 5), (-12, -5)$。\n\n这总共给出了 $4 + 8 = 12$ 个关于 $(x, y)$ 的整数解。\n\n现在，我们使用 $i = x + 64$ 和 $j = y + 64$ 将这些解转换回原始的 $(i, j)$ 坐标系：\n- $(x,y) = (0, 13) \\implies (i,j) = (64, 77)$\n- $(x,y) = (0, -13) \\implies (i,j) = (64, 51)$\n- $(x,y) = (13, 0) \\implies (i,j) = (77, 64)$\n- $(x,y) = (-13, 0) \\implies (i,j) = (51, 64)$\n- $(x,y) = (5, 12) \\implies (i,j) = (69, 76)$\n- $(x,y) = (5, -12) \\implies (i,j) = (69, 52)$\n- $(x,y) = (-5, 12) \\implies (i,j) = (59, 76)$\n- $(x,y) = (-5, -12) \\implies (i,j) = (59, 52)$\n- $(x,y) = (12, 5) \\implies (i,j) = (76, 69)$\n- $(x,y) = (12, -5) \\implies (i,j) = (76, 59)$\n- $(x,y) = (-12, 5) \\implies (i,j) = (52, 69)$\n- $(x,y) = (-12, -5) \\implies (i,j) = (52, 59)$\n\n这 $12$ 个点构成了离散的零水平集。最后一步是按升序字典序（先按 $i$，再按 $j$）对这些点对进行排序：\n1. $i=51$：$(51, 64)$\n2. $i=52$：$(52, 59), (52, 69)$\n3. $i=59$：$(59, 52), (59, 76)$\n4. $i=64$：$(64, 51), (64, 77)$\n5. $i=69$：$(69, 52), (69, 76)$\n6. $i=76$：$(76, 59), (76, 69)$\n7. $i=77$：$(77, 64)$\n\n最终排序后的点对列表是：\n$(51, 64), (52, 59), (52, 69), (59, 52), (59, 76), (64, 51), (64, 77), (69, 52), (69, 76), (76, 59), (76, 69), (77, 64)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n(51, 64)  (52, 59)  (52, 69)  (59, 52)  (59, 76)  (64, 51)  (64, 77)  (69, 52)  (69, 76)  (76, 59)  (76, 69)  (77, 64)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "一旦我们用隐式函数表示了一个形状，下一步往往是测量其几何属性以指导其演化。本练习聚焦于计算曲率（curvature），这是平滑轮廓的关键因素，也是许多水平集模型的核心组成部分。你将使用有限差分这一基本的数值方法，从离散的水平集场中近似计算曲率，并将其与精确的解析值进行比较，从而深入理解这类计算的准确性问题。",
            "id": "4548936",
            "problem": "在采用水平集方法的放射组学分割中，界面被表示为标量场 $\\phi(x,y)$ 的零水平集，其对演化的几何影响由平均曲率 $\\kappa$ 决定，$\\kappa$ 定义为单位法向量场的散度，即 $\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\left\\lvert \\nabla \\phi \\right\\rvert} \\right)$。考虑一个二维均匀采样网格，其间距为 $\\Delta x = \\Delta y = 1$ mm。设水平集函数为一个以原点为中心、半径为 $R$ 的圆的符号距离函数，即 $\\phi(x,y) = \\sqrt{x^{2} + y^{2}} - R$，其中 $R = 2$ mm。您需要使用二阶中心差分，在由点 $(x, y) \\in \\{1, 2, 3\\}\\ \\text{mm} \\times \\{-1, 0, 1\\}\\ \\text{mm}$ 组成的局部 $3 \\times 3$ 模板上对 $\\phi$ 进行计算，以近似网格节点 $(x_{0}, y_{0}) = (2\\ \\text{mm}, 0\\ \\text{mm})$ 处的 $\\kappa$。将在网格节点上对 $\\phi$ 的求值视为精确值。将得到的离散曲率 $\\kappa_{\\text{FD}}$ 与圆在零水平集上的解析曲率（等于 $1/R$）进行比较。计算绝对误差 $\\left\\lvert \\kappa_{\\text{FD}} - \\frac{1}{R} \\right\\rvert$ 并将其作为唯一的最终答案。将最终答案四舍五入到四位有效数字。最终答案以 $\\mathrm{mm}^{-1}$ 为单位表示。",
            "solution": "该问题陈述经核实具有科学依据、适定、客观且自包含。它提出了一个在医学成像和计算几何背景下的标准数值分析任务。所有必要的数据和定义均已提供，不存在矛盾或歧义。\n\n任务是计算一个特定水平集函数的数值近似平均曲率与其解析值之间的绝对误差。平均曲率 $\\kappa$ 定义为水平集函数 $\\phi$ 的单位法向量场的散度。\n$$ \\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\left\\lvert \\nabla \\phi \\right\\rvert} \\right) $$\n在二维笛卡尔坐标系 $(x,y)$ 中，该表达式展开为：\n$$ \\kappa = \\frac{\\phi_{xx}\\phi_y^2 - 2\\phi_x\\phi_y\\phi_{xy} + \\phi_{yy}\\phi_x^2}{(\\phi_x^2 + \\phi_y^2)^{3/2}} $$\n其中下标表示偏导数（例如，$\\phi_x = \\frac{\\partial \\phi}{\\partial x}$，$\\phi_{xy} = \\frac{\\partial^2 \\phi}{\\partial x \\partial y}$）。\n\n我们给定的水平集函数为 $\\phi(x,y) = \\sqrt{x^2 + y^2} - R$，半径 $R=2$ mm。网格间距为 $\\Delta x = \\Delta y = 1$ mm。我们需要使用二阶中心差分，在指定的 $3 \\times 3$ 模板上近似点 $(x_0, y_0) = (2, 0)$ 处的 $\\kappa$。该模板由 $x \\in \\{1, 2, 3\\}$ 和 $y \\in \\{-1, 0, 1\\}$ 的网格节点 $(x,y)$ 组成。\n\n首先，我们计算模板上 9 个点处的 $\\phi(x,y)$ 值。\n$\\phi(x,y) = \\sqrt{x^2 + y^2} - 2$ 的值为：\n- $\\phi(1, -1) = \\sqrt{1^2 + (-1)^2} - 2 = \\sqrt{2} - 2$\n- $\\phi(1, 0) = \\sqrt{1^2 + 0^2} - 2 = 1 - 2 = -1$\n- $\\phi(1, 1) = \\sqrt{1^2 + 1^2} - 2 = \\sqrt{2} - 2$\n- $\\phi(2, -1) = \\sqrt{2^2 + (-1)^2} - 2 = \\sqrt{5} - 2$\n- $\\phi(2, 0) = \\sqrt{2^2 + 0^2} - 2 = 2 - 2 = 0$\n- $\\phi(2, 1) = \\sqrt{2^2 + 1^2} - 2 = \\sqrt{5} - 2$\n- $\\phi(3, -1) = \\sqrt{3^2 + (-1)^2} - 2 = \\sqrt{10} - 2$\n- $\\phi(3, 0) = \\sqrt{3^2 + 0^2} - 2 = 3 - 2 = 1$\n- $\\phi(3, 1) = \\sqrt{3^2 + 1^2} - 2 = \\sqrt{10} - 2$\n\n接下来，我们使用二阶中心差分公式来近似 $(x_0, y_0) = (2, 0)$ 处的 $\\phi$ 的偏导数。当 $\\Delta x = \\Delta y = 1$ 时，这些公式为：\n- $\\phi_x \\approx \\frac{\\phi(x_0+\\Delta x, y_0) - \\phi(x_0-\\Delta x, y_0)}{2\\Delta x} = \\frac{\\phi(3,0) - \\phi(1,0)}{2(1)} = \\frac{1 - (-1)}{2} = 1$\n- $\\phi_y \\approx \\frac{\\phi(x_0, y_0+\\Delta y) - \\phi(x_0, y_0-\\Delta y)}{2\\Delta y} = \\frac{\\phi(2,1) - \\phi(2,-1)}{2(1)} = \\frac{(\\sqrt{5}-2) - (\\sqrt{5}-2)}{2} = 0$\n- $\\phi_{xx} \\approx \\frac{\\phi(x_0+\\Delta x, y_0) - 2\\phi(x_0, y_0) + \\phi(x_0-\\Delta x, y_0)}{(\\Delta x)^2} = \\frac{\\phi(3,0) - 2\\phi(2,0) + \\phi(1,0)}{1^2} = \\frac{1 - 2(0) + (-1)}{1} = 0$\n- $\\phi_{yy} \\approx \\frac{\\phi(x_0, y_0+\\Delta y) - 2\\phi(x_0, y_0) + \\phi(x_0, y_0-\\Delta y)}{(\\Delta y)^2} = \\frac{\\phi(2,1) - 2\\phi(2,0) + \\phi(2,-1)}{1^2} = \\frac{(\\sqrt{5}-2) - 2(0) + (\\sqrt{5}-2)}{1} = 2\\sqrt{5} - 4$\n- $\\phi_{xy} \\approx \\frac{\\phi(x_0+\\Delta x, y_0+\\Delta y) - \\phi(x_0+\\Delta x, y_0-\\Delta y) - \\phi(x_0-\\Delta x, y_0+\\Delta y) + \\phi(x_0-\\Delta x, y_0-\\Delta y)}{4\\Delta x \\Delta y} = \\frac{\\phi(3,1) - \\phi(3,-1) - \\phi(1,1) + \\phi(1,-1)}{4(1)(1)}$\n  代入数值：\n  $\\phi_{xy} \\approx \\frac{(\\sqrt{10}-2) - (\\sqrt{10}-2) - (\\sqrt{2}-2) + (\\sqrt{2}-2)}{4} = \\frac{0 - 0}{4} = 0$\n\n现在，我们将这些离散导数值代入 $\\kappa$ 的表达式中，以求得有限差分近似值 $\\kappa_{\\text{FD}}$：\n$$ \\kappa_{\\text{FD}} = \\frac{(0)(0)^2 - 2(1)(0)(0) + (2\\sqrt{5}-4)(1)^2}{((1)^2 + (0)^2)^{3/2}} = \\frac{2\\sqrt{5}-4}{1^{3/2}} = 2\\sqrt{5}-4 $$\n其数值为 $\\kappa_{\\text{FD}} \\approx 2(2.236068) - 4 = 4.472136 - 4 = 0.472136$ mm$^{-1}$。\n\n半径为 $R$ 的圆的解析曲率为 $\\kappa_{\\text{analytic}} = \\frac{1}{R}$。给定 $R=2$ mm，我们有：\n$$ \\kappa_{\\text{analytic}} = \\frac{1}{2} = 0.5 \\ \\mathrm{mm}^{-1} $$\n最后，我们计算离散值与解析值之间的绝对误差：\n$$ \\text{Error} = \\left\\lvert \\kappa_{\\text{FD}} - \\kappa_{\\text{analytic}} \\right\\rvert = \\left\\lvert (2\\sqrt{5}-4) - \\frac{1}{2} \\right\\rvert = \\left\\lvert 2\\sqrt{5} - 4.5 \\right\\rvert $$\n数值上，其值为：\n$$ \\text{Error} \\approx |0.472135955 - 0.5| = |-0.027864045| = 0.027864045 $$\n问题要求将最终答案四舍五入到四位有效数字。前四位有效数字是 $2$、$7$、$8$ 和 $6$。随后的数字是 $4$，因此我们舍去。\n$$ \\text{Error} \\approx 0.02786 $$\n用标准科学记数法表示，结果为 $2.786 \\times 10^{-2}$。单位是 $\\mathrm{mm}^{-1}$。",
            "answer": "$$\\boxed{2.786 \\times 10^{-2}}$$"
        },
        {
            "introduction": "水平集方法的真正威力在于其能够根据控制偏微分方程（PDE）使复杂形状随时间演化。这项综合性练习将指导你实现一个完整（尽管简单）的水平集演化方案。你不仅需要编写代码来更新轮廓，还需推导并验证确保模拟结果正确的数值稳定性条件（CFL条件），这对任何计算科学家来说都是一项至关重要的技能。",
            "id": "4548852",
            "problem": "您将从基本定义出发，实现并分析一个用于面向放射组学分割的 Hamilton-Jacobi 方程的二维显式水平集格式。考虑一个由偏微分方程控制的标量场 $\\,\\phi(x,y,t)\\,$ 的演化\n$$\n\\partial_t \\phi + F \\, \\lvert \\nabla \\phi \\rvert = 0,\n$$\n其中速度函数 $\\,F \\ge 0\\,$ 为常数，定义在周期性方形域上。您的任务是推导、实现并经验性地验证一个一阶显式格式在 Courant–Friedrichs–Lewy (CFL) 条件下的稳定性。\n\n基本原理和数值设置：\n- 该方程是一个 Hamilton–Jacobi 方程，其哈密顿量为 $\\,H(p_x,p_y) = F \\sqrt{p_x^2 + p_y^2}\\,$，是放射组学中许多水平集分割方法的数学核心。\n- 在域 $[0,1) \\times [0,1)$ 上使用一个均匀周期性网格，$\\,x\\,$ 方向有 $\\,N_x\\,$ 个点，$\\,y\\,$ 方向有 $\\,N_y\\,$ 个点。令 $\\,\\Delta x = 1/N_x\\,$ 且 $\\,\\Delta y = 1/N_y\\,$。\n- 在网格节点上计算初始值 $\\,\\phi(x,y,0) = \\sin(2\\pi x)\\sin(2\\pi y)\\,$。\n- 使用步长为 $\\,\\Delta t\\,$ 的前向欧拉格式对时间进行离散化。对于 $\\,\\lvert \\nabla \\phi \\rvert\\,$，使用由单边有限差分构建的一阶单调 Godunov 数值哈密顿量。设单边差分为\n$$\nD_x^- \\phi_{i,j} = \\frac{\\phi_{i,j} - \\phi_{i-1,j}}{\\Delta x},\\quad\nD_x^+ \\phi_{i,j} = \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{\\Delta x},\\quad\nD_y^- \\phi_{i,j} = \\frac{\\phi_{i,j} - \\phi_{i,j-1}}{\\Delta y},\\quad\nD_y^+ \\phi_{i,j} = \\frac{\\phi_{i,j+1} - \\phi_{i,j}}{\\Delta y},\n$$\n采用周期性索引。对于 $\\,F \\ge 0\\,$，使用单调 Godunov 近似\n$$\nG_{i,j} = \\sqrt{\n\\max\\!\\big( \\max(D_x^-\\phi_{i,j},0)^2,\\;\\min(D_x^+\\phi_{i,j},0)^2 \\big)\\;+\\;\n\\max\\!\\big( \\max(D_y^-\\phi_{i,j},0)^2,\\;\\min(D_y^+\\phi_{i,j},0)^2 \\big)\n},\n$$\n并通过以下方式更新\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^{n} - \\Delta t \\, F \\, G_{i,j}.\n$$\n\n解析稳定性目标：\n- 从 Hamilton–Jacobi 结构以及显式单调格式在一致范数下保持为压缩映射的要求出发，推导关于 $\\,\\Delta t\\,$ 的最严格上界（用 $\\,F\\,$, $\\,\\Delta x\\,$ 和 $\\,\\Delta y\\,$ 表示），使得前向欧拉更新在二维所有网格点上都是稳定的。\n- 您的推导应基于以下两点：为哈密顿量关于每个空间导数的方向 Lipschitz 常数定界，以及前向欧拉法要求适当缩放后的方向贡献之和不超过一来保持单调性。不要假设任何未声明的公式；从 Hamilton–Jacobi 定义和数值哈密顿量的单调性开始。\n\n经验性稳定性验证：\n- 对于 $\\,F \\ge 0\\,$ 的连续方程，一个必要属性是 $\\,\\partial_t \\phi \\le 0\\,$ 逐点成立，因此在一个有效的 CFL 约束下，对于稳定的单调格式，$\\,\\phi\\,$ 的离散最大值应随时间非增。\n- 对于每个测试用例，如果整个模拟过程中同时满足以下两个条件，则将数值演化归类为稳定：\n  1. $\\,\\phi\\,$ 中没有出现非数值，即没有 $\\,\\mathrm{NaN}\\,$ 或 $\\,\\pm\\infty\\,$。\n  2. 在任何时间步，离散最大值 $\\,\\max_{i,j} \\phi_{i,j}^n\\,$ 相较于其初始值的增量不超过 $\\,10^{-8}\\,$ 的容差。\n\n测试套件：\n- 使用以下四组参数集。对于每组参数，令 $\\,\\Delta t_{\\mathrm{theory}}\\,$ 为您通过分析理论上推导出的最大稳定时间步长。使用给定因子 $\\,\\alpha\\,$ 计算 $\\,\\Delta t = \\alpha \\, \\Delta t_{\\mathrm{theory}}\\,$，并演化指定的步数。\n  - 用例 $\\,1\\,$ (顺利路径)：$\\,N_x = 64\\,$, $\\,N_y = 64\\,$, $\\,F = 1.0\\,$, 步数 $\\,= 200\\,$, $\\,\\alpha = 0.90\\,$.\n  - 用例 $\\,2\\,$ (边界情况)：$\\,N_x = 64\\,$, $\\,N_y = 64\\,$, $\\,F = 1.0\\,$, 步数 $\\,= 200\\,$, $\\,\\alpha = 1.00\\,$.\n  - 用例 $\\,3\\,$ (违反 CFL 条件)：$\\,N_x = 64\\,$, $\\,N_y = 64\\,$, $\\,F = 1.0\\,$, 步数 $\\,= 200\\,$, $\\,\\alpha = 1.10\\,$.\n  - 用例 $\\,4\\,$ (各向异性网格，接近违规)：$\\,N_x = 128\\,$, $\\,N_y = 32\\,$, $\\,F = 0.5\\,$, 步数 $\\,= 300\\,$, $\\,\\alpha = 1.05\\,$.\n\n要求的最终输出格式：\n- 您的程序必须按顺序运行这四个用例，并生成单行输出，其中包含四个稳定性的分类，形式为方括号内由逗号分隔的布尔值列表，例如 $\\,\\big[$True,False,True,False$\\big]$ (这只是格式示例；您的结果必须反映您的计算)。",
            "solution": "该问题要求为 Hamilton–Jacobi 方程 $\\,\\partial_t \\phi + F \\, \\lvert \\nabla \\phi \\rvert = 0\\,$ 的一阶显式格式推导稳定性条件，并随后进行数值实现和验证。\n\n### 问题验证\n\n在尝试任何解决方案之前，对问题陈述进行严格评估。\n\n**步骤 1：提取的已知条件**\n- **PDE**：$\\,\\partial_t \\phi + F \\, \\lvert \\nabla \\phi \\rvert = 0\\,$，适用于标量场 $\\,\\phi(x,y,t)\\,$，其中速度函数 $\\,F \\ge 0\\,$ 为常数。\n- **哈密顿量**：$\\,H(p_x,p_y) = F \\sqrt{p_x^2 + p_y^2}\\,$。\n- **域**：周期性方形域 $\\,[0,1) \\times [0,1)\\,$。\n- **网格**：均匀网格，$\\,N_x \\times N_y\\,$ 个点，网格间距为 $\\,\\Delta x = 1/N_x\\,$ 和 $\\,\\Delta y = 1/N_y\\,$。\n- **初始条件**：在网格节点上计算的 $\\,\\phi(x,y,0) = \\sin(2\\pi x)\\sin(2\\pi y)\\,$。\n- **数值格式**：时间上采用前向欧拉（步长 $\\,\\Delta t\\,$），空间上采用一阶单调 Godunov。\n- **差分算子**：$\\,D_x^- \\phi_{i,j} = \\frac{\\phi_{i,j} - \\phi_{i-1,j}}{\\Delta x}\\,$, $\\,D_x^+ \\phi_{i,j} = \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{\\Delta x}\\,$, $\\,D_y^- \\phi_{i,j} = \\frac{\\phi_{i,j} - \\phi_{i,j-1}}{\\Delta y}\\,$, $\\,D_y^+ \\phi_{i,j} = \\frac{\\phi_{i,j+1} - \\phi_{i,j}}{\\Delta y}\\,$。\n- **数值通量**：$\\,G_{i,j} = \\sqrt{ \\max\\!\\big( \\max(D_x^-\\phi_{i,j},0)^2,\\;\\min(D_x^+\\phi_{i,j},0)^2 \\big)\\;+\\; \\max\\!\\big( \\max(D_y^-\\phi_{i,j},0)^2,\\;\\min(D_y^+\\phi_{i,j},0)^2 \\big) }\\,$。\n- **更新规则**：$\\,\\phi_{i,j}^{n+1} = \\phi_{i,j}^{n} - \\Delta t \\, F \\, G_{i,j}\\,$。\n- **稳定性推导目标**：从单调显式格式的第一性原理出发，推导 $\\,\\Delta t\\,$ 的上界（CFL 条件）。\n- **经验稳定性标准**：如果在所有时间步长中，演化过程满足以下两点，则为稳定：1) 不出现 $\\,\\mathrm{NaN}\\,$ 或 $\\,\\pm\\infty\\,$ 值，以及 2) $\\,\\max_{i,j} \\phi_{i,j}^n \\le \\max_{i,j} \\phi_{i,j}^0 + 10^{-8}\\,$。\n- **测试套件**：由参数 $\\,(N_x, N_y, F, \\text{steps}, \\alpha)\\,$ 定义的四个特定用例，其中 $\\,\\alpha\\,$ 是推导出的理论最大时间步长 $\\,\\Delta t_{\\mathrm{theory}}\\,$ 的乘数。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学基础**：该问题是偏微分方程数值分析中的一个典型练习。Hamilton–Jacobi 方程、水平集方法、Godunov 格式和 CFL 稳定性条件是计算科学中基础且完善的概念。\n- **适定性**：问题陈述清晰。它要求推导一个标准的理论结果，并通过具体的数值实现进行经验验证。所有参数、方程和标准都已明确给出。\n- **客观性**：语言精确且数学化。成功标准（稳定性分类）是定量的且无歧义的。\n\n问题陈述是自洽的、逻辑一致的且科学上合理的。它没有显示出指令中列出的任何无效缺陷。\n\n**步骤 3：结论与行动**\n该问题是有效的。将提供完整的解决方案。\n\n### CFL 条件的解析推导\n\n任务是为给定的数值格式推导 Courant–Friedrichs–Lewy (CFL) 条件。该格式是一种时间上显式前向的方法：\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^{n} - \\Delta t \\, F \\, G_{i,j}(\\phi^n)\n$$\n其中 $\\,G_{i,j}\\,$ 是在网格点 $\\,(i,j)\\,$ 对 $\\,\\lvert \\nabla \\phi \\rvert\\,$ 的数值近似。对于一个用于双曲型偏微分方程的一阶、显式、单调格式，要保证其稳定，时间步长 $\\,\\Delta t\\,$ 必须足够小，以确保信息在每个时间步内传播不超过一个网格单元。这被概括在 CFL 条件中。\n\n推导基于这样一个原理：对于应用于双曲型方程的前向欧拉格式，其稳定性（特别是保持单调性和确保在最大范数下的收敛性）要求在所有空间维度上，经过缩放的最大特征速度之和不超过1。问题陈述本身也暗示了这一点：“适当缩放后的方向贡献之和不超过一”。\n\n连续的 Hamilton–Jacobi 方程为 $\\,\\partial_t \\phi + H(\\nabla \\phi) = 0\\,$，哈密顿量为 $\\,H(p_x, p_y) = F \\sqrt{p_x^2 + p_y^2}\\,$。代表信息传播速度的特征速度由哈密顿量对其参数向量 $\\,p = \\nabla \\phi = (p_x, p_y)\\,$ 的分量的偏导数给出：\n$$\nv_x = \\frac{\\partial H}{\\partial p_x} = \\frac{F p_x}{\\sqrt{p_x^2 + p_y^2}}\n$$\n$$\nv_y = \\frac{\\partial H}{\\partial p_y} = \\frac{F p_y}{\\sqrt{p_x^2 + p_y^2}}\n$$\nCFL 条件要求基于每个方向上的最大可能速度来限制时间步长。我们必须在所有可能的梯度 $\\,(p_x, p_y) \\neq (0,0)\\,$ 上找到这些速度绝对值的上确界：\n$$\n\\max |v_x| = \\sup_{p_x, p_y} \\left| \\frac{F p_x}{\\sqrt{p_x^2 + p_y^2}} \\right| = \\sup_{p_x, p_y} F \\left| \\frac{p_x}{\\sqrt{p_x^2 + p_y^2}} \\right| = F\n$$\n当 $\\,p_y = 0\\,$ 且 $\\,p_x \\neq 0\\,$ 时，分数部分变为 $\\,\\pm 1\\,$，从而达到最大值 $\\,F\\,$。对称地，对于 $\\,y\\,$ 方向：\n$$\n\\max |v_y| = \\sup_{p_x, p_y} \\left| \\frac{F p_y}{\\sqrt{p_x^2 + p_y^2}} \\right| = F\n$$\n对于多维一阶显式格式，CFL 条件由这些最大速度的总和给出，每个速度都按相应的网格间距进行缩放：\n$$\n\\Delta t \\left( \\frac{\\max |v_x|}{\\Delta x} + \\frac{\\max |v_y|}{\\Delta y} \\right) \\le 1\n$$\n代入我们找到的最大速度：\n$$\n\\Delta t \\left( \\frac{F}{\\Delta x} + \\frac{F}{\\Delta y} \\right) \\le 1\n$$\n求解 $\\,\\Delta t\\,$ 得到时间步长的最严格上界，我们将其定义为 $\\,\\Delta t_{\\mathrm{theory}}\\,$：\n$$\n\\Delta t \\le \\frac{1}{F \\left( \\frac{1}{\\Delta x} + \\frac{1}{\\Delta y} \\right)}\n$$\n因此，最大稳定时间步长为：\n$$\n\\Delta t_{\\mathrm{theory}} = \\frac{1}{F \\left( \\frac{1}{\\Delta x} + \\frac{1}{\\Delta y} \\right)} = \\frac{\\Delta x \\Delta y}{F(\\Delta x + \\Delta y)}\n$$\n该推导满足了从 Hamilton–Jacobi 结构和显式格式的稳定性原理出发的要求。\n\n### 实现与验证策略\n\n经验验证将通过使用 `numpy` 库在 Python 中实现数值格式来执行。\n\n1.  **网格和初始状态**：对于每个测试用例，创建一个大小为 $\\,N_y \\times N_x\\,$ 的二维网格。使用坐标 $\\,x_i = i \\Delta x\\,$ 和 $\\,y_j = j \\Delta y\\,$ 根据 $\\,\\phi(x,y,0) = \\sin(2\\pi x)\\sin(2\\pi y)\\,$ 初始化场 $\\,\\phi\\,$。此初始场的最大值存储为 $\\,\\max_{i,j} \\phi_{i,j}^0\\,$。\n\n2.  **时间循环**：模拟将 $\\,\\phi\\,$ 演化指定的步数。在每个步骤中：\n    a.  **有限差分**：为整个网格计算单边空间差分 $\\,D_x^-\\phi, D_x^+\\phi, D_y^-\\phi, D_y^+\\phi\\,$。周期性边界条件通过使用 `numpy.roll` 高效处理，该函数可沿给定轴移动数组元素。\n    b.  **数值通量 (G)**：根据指定的公式，使用计算出的差分在每个网格点上计算 Godunov 项 $\\,G_{i,j}\\,$。为提高效率，使用向量化的 `numpy` 操作（`numpy.maximum`, `numpy.minimum`, `numpy.sqrt`）。\n    c.  **更新**：使用前向欧拉规则将场 $\\,\\phi\\,$ 更新到下一个时间步 $\\,\\phi^{n+1}\\,$：$\\,\\phi_{i,j}^{n+1} = \\phi_{i,j}^{n} - \\Delta t F G_{i,j}\\,$。\n\n3.  **稳定性检查**：在每个时间步结束时，检查两个条件：\n    a.  数组 $\\,\\phi\\,$ 中是否存在任何非有限数（`NaN` 或 `inf`），这是数值爆炸的明确迹象。\n    b.  场的最大值是否已超过一个小的容差范围：$\\,\\max_{i,j} \\phi_{i,j}^{n+1}  \\max_{i,j} \\phi_{i,j}^0 + 10^{-8}\\,$。连续方程意味着最大值应该是非增的，因此任何显著的增加都标志着不稳定性。\n\n如果在模拟过程中满足任一条件，该测试用例的演化将被归类为不稳定 (`False`)，并且该用例的循环终止。如果模拟完成所有步骤而没有触发这些条件，则将其归类为稳定 (`True`)。收集所有四个测试用例的布尔结果，并按要求的格式打印。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes a two-dimensional explicit level-set scheme\n    for the Hamilton–Jacobi equation, verifying stability under a derived\n    CFL condition.\n    \"\"\"\n    # Test suite parameters:\n    # (Nx, Ny, F, steps, alpha)\n    test_cases = [\n        (64, 64, 1.0, 200, 0.90),  # Case 1: Stable\n        (64, 64, 1.0, 200, 1.00),  # Case 2: Boundary\n        (64, 64, 1.0, 200, 1.10),  # Case 3: CFL Violation\n        (128, 32, 0.5, 300, 1.05), # Case 4: Anisotropic, CFL Violation\n    ]\n\n    results = []\n\n    for case in test_cases:\n        Nx, Ny, F, steps, alpha = case\n\n        # Grid setup\n        dx = 1.0 / Nx\n        dy = 1.0 / Ny\n        x = np.linspace(0, 1, Nx, endpoint=False)\n        y = np.linspace(0, 1, Ny, endpoint=False)\n        # Note: np.meshgrid with indexing='xy' creates arrays where shape is (Ny, Nx)\n        # so that phi[j, i] corresponds to (x_i, y_j)\n        X, Y = np.meshgrid(x, y, indexing='xy')\n\n        # Initial condition\n        phi = np.sin(2 * np.pi * X) * np.sin(2 * np.pi * Y)\n        \n        max_phi_initial = np.max(phi)\n        tolerance = 1e-8\n\n        # Time step from derived CFL condition\n        # dt_theory = 1 / (F * (1/dx + 1/dy))\n        # Handle F=0 case to avoid division by zero, although not in test cases\n        if F == 0:\n            dt_theory = np.inf\n        else:\n            dt_theory = 1.0 / (F * (1.0 / dx + 1.0 / dy))\n        \n        dt = alpha * dt_theory\n\n        is_stable = True\n        for _ in range(steps):\n            # Periodic boundary conditions using np.roll\n            # axis=1 corresponds to x-direction (columns)\n            # axis=0 corresponds to y-direction (rows)\n            phi_im1 = np.roll(phi, 1, axis=1)\n            phi_ip1 = np.roll(phi, -1, axis=1)\n            phi_jm1 = np.roll(phi, 1, axis=0)\n            phi_jp1 = np.roll(phi, -1, axis=0)\n\n            # One-sided finite differences\n            Dx_neg = (phi - phi_im1) / dx\n            Dx_pos = (phi_ip1 - phi) / dx\n            Dy_neg = (phi - phi_jm1) / dy\n            Dy_pos = (phi_jp1 - phi) / dy\n\n            # Godunov numerical Hamiltonian term G_ij for |nabla phi|\n            term_x_sq = np.maximum(np.maximum(Dx_neg, 0)**2, np.minimum(Dx_pos, 0)**2)\n            term_y_sq = np.maximum(np.maximum(Dy_neg, 0)**2, np.minimum(Dy_pos, 0)**2)\n            G = np.sqrt(term_x_sq + term_y_sq)\n            \n            # Forward Euler update\n            phi = phi - dt * F * G\n\n            # Stability check\n            # 1. Check for non-numerical values\n            if np.isnan(phi).any() or np.isinf(phi).any():\n                is_stable = False\n                break\n            \n            # 2. Check for non-increasing maximum principle violation\n            if np.max(phi) > max_phi_initial + tolerance:\n                is_stable = False\n                break\n        \n        results.append(is_stable)\n\n    # Format the final output as a comma-separated list of booleans in brackets\n    # Note: Python's `str(True)` is 'True', which needs to be lowercase.\n    # The example output in the prompt shows booleans, not their string reps.\n    # The requirement `[True,False,True,False]` suggests string representation of Python booleans is fine.\n    # Let's double check... the example `[True,False,True,False]` is not a python list literal but a string.\n    # `map(str, results)` will produce ['True', 'False', ...]\n    # `','.join(...)` will give 'True,False,...'\n    # The f-string will wrap it in `[]`. This matches the requirement.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}