{
    "hands_on_practices": [
        {
            "introduction": "为了将净获益 (Net Benefit) 这一抽象概念具体化，我们的第一个练习将从一个给定的混淆矩阵出发，直接计算其数值。这个练习将帮助你理解净获益公式的两个核心部分：真阳性带来的“收益”和假阳性带来的“损失”，以及决策阈值是如何权衡这两者的。通过这个基础计算 ，你将对决策曲线分析的根本原理建立起直观的认识。",
            "id": "4551107",
            "problem": "一个经过校准的影像组学分类器用于从影像特征中预测一个二元临床终点（某种状况存在或不存在）。在一个反映临床风险承受度的决策阈值概率 $t$ 下，该分类在一个外部验证集上产生以下混淆矩阵：真阳性 (TP) $=84$，假阳性 (FP) $=60$，真阴性 (TN) $=220$，假阴性 (FN) $=36$，总样本量 $N=400$。阈值概率为 $t=0.15$。使用阈值概率的基础决策理论解释，其中假阳性的危害按对应于 $t$ 的优势比进行缩放，计算该校准影像组学模型的净获益 $NB(t)$ 以及两种基线临床策略（全体治疗和全体不治疗）的净获益。然后，报告该影像组学模型相对于最佳基线策略的净获益优势，定义为 $NB(t)-\\max\\{NB_{\\text{all}}(t), NB_{\\text{none}}(t)\\}$。将最终优势表示为小数，并四舍五入到四位有效数字。",
            "solution": "首先对问题进行验证，以确保其科学合理、定义明确且客观。\n\n### 步骤 1：提取已知条件\n问题陈述中提供了以下数据：\n- 真阳性，$TP = 84$\n- 假阳性，$FP = 60$\n- 真阴性，$TN = 220$\n- 假阴性，$FN = 36$\n- 总样本量，$N = TP + FP + TN + FN = 84 + 60 + 220 + 36 = 400$\n- 决策阈值概率，$t = 0.15$\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题基于决策曲线分析 (DCA)，这是生物统计学和医学信息学中用于评估预测模型的一种标准且成熟的方法。净获益、阈值概率、混淆矩阵元素以及基线策略（全体治疗、全体不治疗）等概念是 DCA 的基础。将其应用于影像组学分类器是一个常见且合适的场景。\n2.  **定义明确**：该问题提供了所有必要的数值和一个清晰、明确的目标。所提供的数字在内部是一致的 ($TP+FP+TN+FN = N$)。问题要求计算一个具体的可计算量。\n3.  **客观性**：该问题以精确的定量术语陈述，不含主观性语言或观点。\n\n### 步骤 3：结论与行动\n问题被认为是有效的。将提供完整的解答。\n\n预测模型的净获益 ($NB$) 是基于指定的决策阈值概率 $t$ 定义的。阈值 $t$ 代表患者（或临床医生）会选择接受治疗的疾病概率。假阳性（不必要的治疗）的危害相对于真阳性（正确的治疗）的获益，通过该阈值的优势比 $\\frac{t}{1-t}$进行加权。净获益的公式为：\n$$NB(t) = \\frac{TP}{N} - \\frac{FP}{N} \\left( \\frac{t}{1-t} \\right)$$\n其中 $TP$ 是真阳性数量，$FP$ 是假阳性数量，$N$ 是总受试者数量。\n\n首先，我们计算给定阈值 $t=0.15$ 的优势比项：\n$$ \\frac{t}{1-t} = \\frac{0.15}{1 - 0.15} = \\frac{0.15}{0.85} = \\frac{15}{85} = \\frac{3}{17} $$\n\n接下来，我们使用给定的混淆矩阵值计算影像组学模型的净获益 $NB(t)$：\n$$ NB(t) = \\frac{84}{400} - \\frac{60}{400} \\left( \\frac{3}{17} \\right) $$\n化简分数：\n$$ NB(t) = \\frac{21}{100} - \\frac{15}{100} \\left( \\frac{3}{17} \\right) = \\frac{21}{100} - \\frac{45}{1700} $$\n为了进行减法，我们找到一个公分母 $1700$：\n$$ NB(t) = \\frac{21 \\times 17}{1700} - \\frac{45}{1700} = \\frac{357 - 45}{1700} = \\frac{312}{1700} $$\n这个分数可以化简：\n$$ NB(t) = \\frac{156}{850} = \\frac{78}{425} $$\n\n现在，我们计算两种基线临床策略的净获益。\n\n1.  **全体不治疗策略 ($NB_{\\text{none}}(t)$)**：在此策略中，没有人接受治疗。因此，没有真阳性也没有假阳性 ($TP=0$, $FP=0$)。净获益总是零。\n    $$ NB_{\\text{none}}(t) = \\frac{0}{N} - \\frac{0}{N} \\left( \\frac{t}{1-t} \\right) = 0 $$\n\n2.  **全体治疗策略 ($NB_{\\text{all}}(t)$)**：在此策略中，每个人都接受治疗。所有患有该状况的受试者都是真阳性，所有没有该状况的受试者都是假阳性。\n    患有该状况的受试者总数（患病率）为 $P = TP + FN = 84 + 36 = 120$。\n    不患有该状况的受试者总数为 $N_{\\text{neg}} = TN + FP = 220 + 60 = 280$。\n    对于全体治疗策略，“真阳性”的数量是患病患者的总数（$120$），而“假阳性”的数量是未患病患者的总数（$280$）。\n    净获益为：\n    $$ NB_{\\text{all}}(t) = \\frac{P}{N} - \\frac{N_{\\text{neg}}}{N} \\left( \\frac{t}{1-t} \\right) = \\frac{120}{400} - \\frac{280}{400} \\left( \\frac{3}{17} \\right) $$\n    化简分数：\n    $$ NB_{\\text{all}}(t) = \\frac{3}{10} - \\frac{7}{10} \\left( \\frac{3}{17} \\right) = \\frac{3}{10} - \\frac{21}{170} $$\n    为了进行减法，我们找到一个公分母 $170$：\n    $$ NB_{\\text{all}}(t) = \\frac{3 \\times 17}{170} - \\frac{21}{170} = \\frac{51 - 21}{170} = \\frac{30}{170} = \\frac{3}{17} $$\n\n问题要求计算影像组学模型相对于最佳基线策略的净获益优势。我们必须首先通过找到 $\\max\\{NB_{\\text{all}}(t), NB_{\\text{none}}(t)\\}$ 来确定最佳基线策略。\n我们比较 $NB_{\\text{all}}(t) = \\frac{3}{17}$ 和 $NB_{\\text{none}}(t) = 0$。显然，$\\frac{3}{17} > 0$，所以最佳基线策略是“全体治疗”。\n$$ \\max\\{NB_{\\text{all}}(t), NB_{\\text{none}}(t)\\} = \\frac{3}{17} $$\n\n净获益优势是模型的净获益与最佳基线净获益之间的差值：\n$$ \\text{Advantage} = NB(t) - \\max\\{NB_{\\text{all}}(t), NB_{\\text{none}}(t)\\} = \\frac{78}{425} - \\frac{3}{17} $$\n为了求差，我们使用公分母 $425$，注意到 $425 = 25 \\times 17$。\n$$ \\text{Advantage} = \\frac{78}{425} - \\frac{3 \\times 25}{17 \\times 25} = \\frac{78}{425} - \\frac{75}{425} = \\frac{3}{425} $$\n\n最后，我们将此分数表示为小数，并四舍五入到四位有效数字。\n$$ \\text{Advantage} = \\frac{3}{425} \\approx 0.0070588235... $$\n四舍五入到四位有效数字，我们确定第一个非零数字（$7$）和其后的三位数字（$058$）。第五位有效数字是 $8$，它 $\\ge 5$，所以我们将最后一位数字（$8$）向上取整为 $9$。\n四舍五入后的值为 $0.007059$。",
            "answer": "$$\\boxed{0.007059}$$"
        },
        {
            "introduction": "在掌握了手动计算之后，下一步是学习如何将评估过程自动化。本练习要求你编写代码，根据一组预测概率和真实结果，计算期望校准误差 (Expected Calibration Error, ECE) 和净获益 (Net Benefit, NB)。这个实践  不仅能加深你对模型校准度和临床实用性这两个核心概念的理解，还能为你使用真实数据进行模型评估打下关键的编程基础。",
            "id": "4551103",
            "problem": "一个小型放射组学数据集提供了一个基于纹理的模型所生成的经过校准的恶性肿瘤概率预测值以及相应的二元结局。设数据集大小为 $N$，预测概率为 $\\{p_i\\}_{i=1}^N$，结局为 $\\{y_i\\}_{i=1}^N$，其中每个 $p_i \\in [0,1]$ 是以小数形式表示的概率，每个 $y_i \\in \\{0,1\\}$。基本原理包含以下广为接受的定义：如果对于具有给定预测概率的任何病例子集，其事件的经验频率与预测概率相匹配，则该预测模型是良好校准的；预期校准误差 (Expected Calibration Error, ECE) 通过汇总各分箱中平均预测概率与经验事件率之间的绝对差值来总结校准度；决策曲线分析 (Decision Curve Analysis, DCA) 通过计算净获益来评估临床实用性，净获益等于真阳性带来的收益减去由决策阈值所隐含的“伤害-获益”权衡加权的假阳性惩罚。\n\n从这些定义出发，在单个程序中推导并实现以下内容：\n- 通过将区间 $[0,1]$ 划分为 $K$ 个宽度为 $1/K$ 的区间来构建 $K$ 个等宽分箱。根据每个 $p_i$ 的值将其分配到一个分箱中。对于每个非空分箱 $b$，计算平均预测概率 $m_b$ 和经验事件率 $f_b$。将分箱权重 $w_b$ 定义为分箱 $b$ 中样本数相对于 $N$ 的比例。通过使用 $w_b$ 对绝对差 $|m_b - f_b|$ 进行加权，在所有分箱上聚合一个标量校准误差，并从总和中排除任何空分箱。该标量即为从第一性原理得到的预期校准误差。\n- 对于决策阈值为 $t \\in (0,1)$ 的决策曲线分析，如果 $p_i \\ge t$，则将预测标记为阳性，否则标记为阴性。通过将真阳性决策计数归一化，并减去与假阳性决策计数成比例的惩罚，来推导每个患者的净获益。惩罚权重必须反映风险阈值权衡，该权衡将阈值概率 $t$ 等同于伤害-获益比。将最终的净获益表示为每个患者的浮点数。\n\n使用以下数据集，$N = 20$：\n- 预测值 (以小数形式表示的概率)：$[0.02, 0.15, 0.35, 0.65, 0.80, 0.45, 0.90, 0.12, 0.55, 0.30, 0.72, 0.08, 0.25, 0.50, 0.95, 0.40, 0.18, 0.60, 0.85, 0.10]$。\n- 结局 (二元事件)：$[0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0]$。\n\n测试套件规范：\n- 计算 $K \\in \\{1, 3, 5, 10, 20\\}$ 时的 ECE，其中包括边界情况 ($K=1$) 和近似-同一性分箱情况 ($K=20$)，即每个样本大约形成自己的分箱。\n- 计算决策阈值 $t \\in \\{0.10, 0.30, 0.50, 0.70\\}$ 时的净获益 (所有阈值均以小数表示)，覆盖了日益严格的决策标准，同时避免了在 $t=0$ 和 $t=1$ 附近的除零边缘情况。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\text{ECE}(1), \\text{ECE}(3), \\text{ECE}(5), \\text{ECE}(10), \\text{ECE}(20), \\text{NB}(0.10), \\text{NB}(0.30), \\text{NB}(0.50), \\text{NB}(0.70)]$。所有数字必须是四舍五入到六位小数的浮点数。不涉及物理单位；所有概率和最终结果都以小数表示，而非百分比。",
            "solution": "该问题要求推导并实现两种不同的度量指标，用于在放射组学背景下评估概率性预测模型：预期校准误差 (ECE) 和决策曲线分析 (DCA) 中的净获益 (NB)。分析将在一个给定的包含预测概率和二元结局的数据集上进行。\n\n问题陈述经确认为具有科学依据、定义明确且客观。它基于统计模型评估和决策理论的既定原则。所提供的数据集是自包含的，足以进行所需的计算。我们将着手提供一个完整的解决方案。\n\n### 第 1 部分：预期校准误差 (ECE)\n\n如果一个预测模型的预测概率能准确反映事件的真实潜在频率，则认为该模型是良好校准的。例如，如果我们考虑模型预测概率为 $p$ 的所有病例，我们期望事件在这些病例中的发生比例为 $p$。ECE 量化了预测概率与经验事件频率之间的差异。\n\n计算过程如下：\n1.  **分箱：** 连续的概率区间 $[0, 1]$ 被划分为 $K$ 个不相交的等宽分箱。对于 $k \\in \\{1, 2, ..., K\\}$，第 $k$ 个分箱对应于概率区间 $B_k = (\\frac{k-1}{K}, \\frac{k}{K}]$。对于给定的预测值 $p_i$，它被分配到唯一的满足 $p_i \\in B_k$ 的分箱 $B_k$ 中。我们必须确保 $p_i=0$ 的情况得到正确处理；为简单起见，我们将第一个分箱定义为 $[0, 1/K]$，而将通用的第 $k$ 个分箱定义为 $((k-1)/K, k/K]$。这等价于将概率 $p_i$ 映射到分箱索引 $b = \\text{floor}((p_i - \\epsilon) / (1/K))$，其中 $\\epsilon$ 是一个无穷小的正数，用于处理 $p_i=0$ 的边缘情况。一种更实用的实现方法是将 $p_i$ 分配给分箱索引 $\\lfloor (p_i \\cdot K - \\delta) \\rfloor$ (其中 $\\delta$ 是一个很小的数)，或者更稳健地，对除最后一个分箱外的所有分箱使用右侧开区间。对于 $p_i \\in [0,1]$，分箱索引可以计算为 $\\min(\\lfloor p_i \\cdot K \\rfloor, K-1)$，这种方法能将 $p_i=1.0$ 正确地分配到最后一个分箱。\n\n2.  **分箱内度量：** 对于每个非空分箱 $B_k$，我们计算三个量：\n    *   **经验事件率**或**阳性率**，$f_k$。这是分箱中所有样本里阳性结局 ($y_i=1$) 的比例。设 $I_k$ 是其预测概率 $p_i$ 落入分箱 $B_k$ 的样本索引集合，并设 $N_k = |I_k|$ 为该分箱中的样本数。那么 $f_k = \\frac{1}{N_k} \\sum_{i \\in I_k} y_i$。\n    *   **平均预测概率**或**平均置信度**，$m_k$。这是分箱中所有样本的预测概率的平均值：$m_k = \\frac{1}{N_k} \\sum_{i \\in I_k} p_i$。\n    *   **分箱权重**，$w_k$。这是落入该分箱的样本占总样本的比例：$w_k = \\frac{N_k}{N}$，其中 $N$ 是总样本数。\n\n3.  **聚合：** ECE 是所有分箱的经验事件率与平均预测概率之间绝对差的加权平均值。空分箱被排除在求和之外。\n    $$ \\text{ECE} = \\sum_{k=1}^{K} w_k |m_k - f_k| $$\n    对于非空分箱 ($N_k > 0$)，代入 $w_k$、$m_k$ 和 $f_k$ 的定义：\n    $$ \\text{ECE} = \\sum_{k: N_k > 0} \\frac{N_k}{N} \\left| \\frac{1}{N_k} \\sum_{i \\in I_k} p_i - \\frac{1}{N_k} \\sum_{i \\in I_k} y_i \\right| $$\n    $$ \\text{ECE} = \\sum_{k: N_k > 0} \\frac{1}{N} \\left| \\sum_{i \\in I_k} p_i - \\sum_{i \\in I_k} y_i \\right| $$\n    这可以简化为对所有分箱的求和（因为空分箱的项为零）：\n    $$ \\text{ECE} = \\frac{1}{N} \\sum_{k=1}^{K} \\left| \\sum_{i \\in I_k} p_i - \\sum_{i \\in I_k} y_i \\right| $$\n    这种最终形式在计算上是高效的，因为它避免了在循环中显式计算中间分数。\n\n### 第 2 部分：决策曲线分析 (DCA) 的净获益\n\nDCA通过比较正确决策（真阳性）的益处与错误决策（假阳性）的危害来评估预测模型的临床效用或“净获益”。这种权衡由决策阈值概率 $t$ 参数化。\n\n推导从决策理论的第一性原理开始：\n1.  **决策规则：** 在给定的阈值 $t \\in (0, 1)$ 下，如果患者的预测概率 $p_i \\ge t$，则将其分类为阳性（即建议进行干预）。\n\n2.  **效用框架：** 设对一个真正患有该病的患者（真阳性）进行干预的益处为 $B_{unit}$。设对一个没有患病的患者（假阳性）进行干预的危害为 $H_{unit}$。对于一个包含 $N$ 名患者的群体，决策策略的净效用为 $(TP \\times B_{unit}) - (FP \\times H_{unit})$，其中 $TP$ 和 $FP$ 是在阈值 $t$ 下该策略产生的真阳性和假阳性的总数。\n\n3.  **基于阈值的权衡：** 阈值概率 $t$ 代表决策者的无差异点。在此概率下，干预的预期益处等于干预的预期危害。对于风险为 $p$ 的个体，干预的预期效用是 $p \\cdot B_{unit} - (1-p) \\cdot H_{unit}$。在 $p=t$ 时将其设为零，得到 $t \\cdot B_{unit} = (1-t) \\cdot H_{unit}$。这就建立了由阈值所隐含的伤害-获益比：\n    $$ \\frac{H_{unit}}{B_{unit}} = \\frac{t}{1-t} $$\n    问题陈述中“惩罚权重必须反映风险阈值权衡，该权衡将阈值概率 $t$ 等同于伤害-获益比”这句话，是根据这一严谨的推导来解释的。这个比率不是 $t$，而是由 $t$ 推导出的 $\\frac{t}{1-t}$。这个标准定义在科学上是正确的，并避免了不一致性，尤其是在 $t \\to 1$ 时。\n\n4.  **净获益公式：** 为了创建一个标准化的度量，总效用通过总体大小 $N$ 和益处单位 $B_{unit}$ 进行归一化。这得出了每位患者的净获益：\n    $$ \\text{NB}(t) = \\frac{(TP \\times B_{unit}) - (FP \\times H_{unit})}{N \\cdot B_{unit}} = \\frac{TP(t)}{N} - \\frac{FP(t)}{N} \\frac{H_{unit}}{B_{unit}} $$\n    代入伤害-获益比，我们得到净获益的最终表达式：\n    $$ \\text{NB}(t) = \\frac{TP(t)}{N} - \\frac{FP(t)}{N} \\frac{t}{1-t} $$\n    此处，$TP(t)$ 是满足 $y_i=1$ 和 $p_i \\ge t$ 的患者数量，$FP(t)$ 是满足 $y_i=0$ 和 $p_i \\ge t$ 的患者数量。患者总数为 $N$。该公式以真阳性为单位，正确地捕捉了在给定风险阈值 $t$ 下应用模型建议所带来的净收益。\n\n该实现将使用所提供的数据集为指定的测试用例计算这两个度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_ece(p, y, K):\n    \"\"\"\n    Computes the Expected Calibration Error (ECE) for a given number of bins.\n\n    Args:\n        p (np.ndarray): Array of predicted probabilities.\n        y (np.ndarray): Array of true binary outcomes (0 or 1).\n        K (int): The number of equal-width bins to use.\n\n    Returns:\n        float: The calculated ECE value.\n    \"\"\"\n    p, y = np.asarray(p), np.asarray(y)\n    N = len(p)\n    if N == 0:\n        return 0.0\n    \n    # Create K bins of equal width\n    # Note: bin_indices calculation correctly handles p_i = 1.0\n    # For p_i = 1.0, int(1.0 * K) would be K, so min(..., K-1) places it in the last bin.\n    # For p_i = 0.0, int(0.0 * K) is 0, placing it in the first bin.\n    bin_indices = np.minimum(np.floor(p * K).astype(int), K - 1)\n\n    # Use bincount for efficient aggregation, requires non-negative weights\n    # Sum of probabilities in each bin\n    bin_sums_p = np.bincount(bin_indices, weights=p, minlength=K)\n    # Sum of outcomes (positives) in each bin\n    bin_sums_y = np.bincount(bin_indices, weights=y, minlength=K)\n    # Number of samples in each bin\n    bin_counts = np.bincount(bin_indices, minlength=K)\n\n    # Calculate the sum of absolute differences between sum of probabilities and sum of outcomes\n    # This corresponds to the formula: (1/N) * sum(|sum(p_i) - sum(y_i)| for each bin)\n    # We only consider non-empty bins implicitly, as for empty bins the difference is 0.\n    abs_diff = np.abs(bin_sums_p - bin_sums_y)\n    ece = np.sum(abs_diff) / N\n    \n    return ece\n\ndef calculate_net_benefit(p, y, t):\n    \"\"\"\n    Computes the Net Benefit (NB) for a given decision threshold.\n\n    Args:\n        p (np.ndarray): Array of predicted probabilities.\n        y (np.ndarray): Array of true binary outcomes (0 or 1).\n        t (float): The decision threshold, must be in (0, 1).\n\n    Returns:\n        float: The calculated Net Benefit.\n    \"\"\"\n    p, y = np.asarray(p), np.asarray(y)\n    N = len(p)\n    if N == 0:\n        return 0.0\n    \n    # A prediction is positive if the probability is >= threshold t\n    predicted_positives = (p >= t)\n    \n    # True Positives: predicted positive and outcome is positive\n    tp_count = np.sum((predicted_positives == 1)  (y == 1))\n    \n    # False Positives: predicted positive and outcome is negative\n    fp_count = np.sum((predicted_positives == 1)  (y == 0))\n    \n    # The harm-to-benefit ratio is t / (1 - t)\n    # The problem specifies that t is in (0, 1), so no division by zero at t=1.\n    harm_benefit_ratio = t / (1.0 - t)\n    \n    # Net Benefit formula: NB = (TP/N) - (FP/N) * (t / (1-t))\n    net_benefit = (tp_count / N) - (fp_count / N) * harm_benefit_ratio\n    \n    return net_benefit\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on the specified dataset and test cases.\n    \"\"\"\n    # Dataset provided in the problem statement\n    p_data = np.array([\n        0.02, 0.15, 0.35, 0.65, 0.80, 0.45, 0.90, 0.12, 0.55, 0.30,\n        0.72, 0.08, 0.25, 0.50, 0.95, 0.40, 0.18, 0.60, 0.85, 0.10\n    ])\n    y_data = np.array([\n        0, 0, 0, 1, 1, 0, 1, 0, 1, 0,\n        1, 0, 0, 1, 1, 0, 0, 1, 1, 0\n    ])\n\n    # Test suite specification\n    k_values = [1, 3, 5, 10, 20]\n    t_values = [0.10, 0.30, 0.50, 0.70]\n\n    # Store results in order\n    results = []\n\n    # Calculate ECE for each K\n    for k in k_values:\n        ece_result = calculate_ece(p_data, y_data, k)\n        results.append(ece_result)\n\n    # Calculate Net Benefit for each t\n    for t in t_values:\n        nb_result = calculate_net_benefit(p_data, y_data, t)\n        results.append(nb_result)\n        \n    # Format results to 6 decimal places and create the final output string\n    # e.g., f'{val:.6f}' ensures floating point representation with 6 decimal places.\n    formatted_results = [f'{val:.6f}' for val in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际应用中，任何单一的性能指标（如净获益）都只是一个点估计，它会受到样本随机性的影响。为了做出可靠的临床决策，我们必须量化这种不确定性。这个综合性练习  将指导你完成一个完整的分析流程：从生成模拟数据、比较不同模型，到最终使用自助法 (bootstrap method) 为净获益曲线构建置信区间。通过这种方式，我们可以对不同临床策略的优劣进行有统计学意义的比较。",
            "id": "4551064",
            "problem": "给定一个代表影像组学的二元分类场景，其中一个预测模型为每位患者分配一个恶性肿瘤概率。您必须形式化并实现决策曲线分析 (DCA)，通过自助法 (bootstrap) 为预设分类阈值下的净收益曲线构建逐点置信区间，并实现对临床决策策略之间重叠曲线的解释。\n\n从以下基本概念开始：\n- 在具有真实标签 $y \\in \\{0,1\\}$ 和在阈值 $t \\in (0,1)$ 下的预测类别 $\\hat{y} \\in \\{0,1\\}$ 的二元分类中，给定策略在阈值 $t$ 下的净收益定义为\n$$\n\\mathrm{NB}(t) = \\frac{\\mathrm{TP}(t)}{N} - \\frac{\\mathrm{FP}(t)}{N} \\cdot \\frac{t}{1-t},\n$$\n其中 $N$ 是总样本量，$\\mathrm{TP}(t)$ 是在阈值 $t$ 下的真阳性数量，$\\mathrm{FP}(t)$ 是在阈值 $t$ 下的假阳性数量。\n- 对于“全体治疗”策略（将每个人都视为阳性），在阈值 $t$ 下的净收益等于\n$$\n\\mathrm{NB}_{\\mathrm{TA}}(t) = \\hat{\\pi} - \\left(1-\\hat{\\pi}\\right)\\frac{t}{1-t},\n$$\n其中 $\\hat{\\pi}$ 是经验患病率 $\\hat{\\pi} = \\frac{1}{N}\\sum_{i=1}^{N} y_i$。\n- 对于“全体不治疗”策略（将每个人都视为阴性），对所有 $t$ 而言，净收益恒等于零，即 $\\mathrm{NB}_{\\mathrm{TN}}(t) = 0$。\n- 非参数自助法是一种重抽样方法，它通过从观测数据中有放回地重抽样来近似统计量的抽样分布。百分位数法通过取自助法复制样本的经验 $\\alpha/2$ 和 $1-\\alpha/2$ 分位数来构建双侧置信区间。\n\n您的任务是实现以下端到端流程。\n\n数据生成：\n1. 使用一个包含 $N = 500$ 名患者样本，其二元结局为 $y \\in \\{0,1\\}$，经验患病率约为 $0.35$。对于 $i \\in \\{1,\\dots,N\\}$，独立地从 $\\mathrm{Bernoulli}(0.35)$ 分布中生成 $y_i$。使用伪随机数生成器种子 $20240517$ 以确保可复现性。\n2. 基于 $y_i$ 构建模型 A 的预测概率 $p^{(A)}_i$ 如下：\n   - 如果 $y_i = 1$，从 $\\mathrm{Beta}(\\alpha_1,\\beta_1)$ 分布中抽取 $p^{(A)}_i$，其中 $(\\alpha_1,\\beta_1) = (5,2)$。\n   - 如果 $y_i = 0$，从 $\\mathrm{Beta}(\\alpha_0,\\beta_0)$ 分布中抽取 $p^{(A)}_i$，其中 $(\\alpha_0,\\beta_0) = (2,5)$。\n3. 构建模型 B，作为模型 A 的一个未校准变换，通过逻辑斯蒂链接变换保留其区分度。定义 logit 函数 $\\mathrm{logit}(x) = \\log\\left(\\frac{x}{1-x}\\right)$ 及其反函数 $\\mathrm{logit}^{-1}(z) = \\frac{1}{1+e^{-z}}$。令\n$$\n\\mathrm{logit}\\left(p^{(B)}_i\\right) = a + b \\cdot \\mathrm{logit}\\left(p^{(A)}_i\\right),\n$$\n其中 $a = -0.2$ 且 $b = 1.5$。为确保数值稳定性，将 logit 函数的输入裁剪到远离 $0$ 和 $1$ 的范围，例如 $[10^{-6}, 1-10^{-6}]$。\n\n策略和阈值：\n4. 考虑四种策略：模型 A（对 $p^{(A)}$ 使用阈值）、模型 B（对 $p^{(B)}$ 使用阈值）、全体治疗和全体不治疗。\n5. 在阈值集合 $T = \\{0.01, 0.10, 0.33, 0.50, 0.90\\}$ 上评估决策。对于每个阈值 $t \\in T$，对于 $M \\in \\{\\text{A}, \\text{B}\\}$，通过 $\\hat{y}^{(M)}_i(t) = \\mathbb{1}\\{p^{(M)}_i \\ge t\\}$ 定义模型的预测类别，并使用上述定义计算 $\\mathrm{NB}^{(M)}(t)$。对于全体治疗和全体不治疗策略，使用上面给出的表达式。\n\n自助法置信区间：\n6. 使用具有 $B = 1000$ 次复制的非参数自助法。对于每次复制 $b \\in \\{1,\\dots,B\\}$，从 $N$ 名患者中有放回地重抽样以获得一个自助样本。对于每个 $t \\in T$ 和每种策略，计算自助法净收益 $\\mathrm{NB}^{*,(M)}_b(t)$。\n7. 对于每个 $t \\in T$ 和每种策略，使用百分位数法计算一个双侧逐点 $95\\%$ 置信区间，即使用 $\\{\\mathrm{NB}^{*,(M)}_b(t)\\}_{b=1}^{B}$ 在水平 $0.025$ 和 $0.975$ 的经验分位数。\n\n解释重叠曲线：\n8. 为了形式化判断两种策略在阈值 $t$ 下是否可区分，考虑净收益的差异 $\\Delta(t) = \\mathrm{NB}^{(M_1)}(t) - \\mathrm{NB}^{(M_2)}(t)$。使用差异的自助法复制样本 $\\Delta^*_b(t) = \\mathrm{NB}^{*,(M_1)}_b(t) - \\mathrm{NB}^{*,(M_2)}_b(t)$ 来构建 $\\Delta(t)$ 的一个百分位数 $95\\%$ 置信区间。当且仅当该区间的下界严格大于 $0$ 时，声明策略 $M_1$ 在阈值 $t$ 下优于 $M_2$。这种方法通过评估差异的不确定性来直接处理曲线之间的重叠，而不是通过视觉比较边际区间。\n\n测试套件和要求输出：\n- 使用固定的阈值 $T = \\{0.01, 0.10, 0.33, 0.50, 0.90\\}$ 作为测试套件。\n- 对于每个 $t \\in T$，使用所述的差异的自助法置信区间评估以下三个比较：\n  1. 模型 A vs. 模型 B。\n  2. 模型 A vs. 全体治疗。\n  3. 模型 B vs. 全体治疗。\n- 对于每个比较，根据上述规则输出一个布尔值，指示第一个策略是否优于第二个策略。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。具体来说，对于按顺序 $0.01$, $0.10$, $0.33$, $0.50$, $0.90$ 迭代的 $t$，按以下顺序附加布尔值：模型 A 大于模型 B，模型 A 大于全体治疗，模型 B 大于全体治疗。例如，输出应类似于 $[b_1,b_2,\\dots,b_{15}]$，其中每个 $b_k$ 是 True 或 False。不应打印任何其他文本。\n- 所有量都是无单位的。在内部将所有浮点数表示为实数；最终打印的值是指定的布尔值。\n\n注意：\n- 不涉及角度；您不得使用度或弧度。\n- 自助法置信区间在 $t$ 上是逐点的。您不得合并阈值或使用任何参数假设。",
            "solution": "目标是实施并应用决策曲线分析 (DCA)，这是一种在临床背景下根据净收益评估和比较预测模型的方法。该分析涉及生成合成患者数据，建立两个预测模型（一个校准良好，一个未校准），并将它们相互比较以及与两种基线策略（全体治疗和全体不治疗）进行比较。净收益差异的统计显著性通过非参数自助法置信区间进行评估。\n\n程序步骤如下：数据生成、净收益计算、用于置信区间估计的自助法重抽样以及策略的形式化比较。\n\n首先，我们生成一个包含 $N=500$ 名患者的合成数据集。每位患者 $i$ 的真实二元结局 $y_i \\in \\{0, 1\\}$ 是从患病率为 $0.35$ 的伯努利分布中抽取的。具体来说，$y_i \\sim \\mathrm{Bernoulli}(p)$，其中 $p=0.35$。使用指定的伪随机数生成器种子 $20240517$ 以确保可复现性。\n\n其次，我们为两个模型（模型 A 和模型 B）构建预测概率。这些概率是根据真实结局 $y_i$ 条件生成的。\n对于模型 A，预测概率 $p^{(A)}_i$ 从 Beta 分布中抽取，这是为概率建模的标准选择。如果患者患有该病症 ($y_i=1$)，则概率从参数为 $(\\alpha_1, \\beta_1) = (5, 2)$ 的 $\\mathrm{Beta}(\\alpha_1, \\beta_1)$ 分布中抽取。如果患者没有该病症 ($y_i=0$)，则概率从参数为 $(\\alpha_0, \\beta_0) = (2, 5)$ 的 $\\mathrm{Beta}(\\alpha_0, \\beta_0)$ 分布中抽取。选择这些参数是为了使模型的预测对于阳性病例平均高于阴性病例，从而表明具有区分能力。\n\n对于模型 B，预测概率 $p^{(B)}_i$ 是通过对模型 A 的概率应用逻辑斯蒂变换来创建的。此过程旨在模拟预测建模中的一个常见问题：未校准，即模型的区分度得以保留，但其概率被系统性地扭曲。该变换由以下方程定义：\n$$\n\\mathrm{logit}\\left(p^{(B)}_i\\right) = a + b \\cdot \\mathrm{logit}\\left(p^{(A)}_i\\right)\n$$\n其中 $\\mathrm{logit}(x) = \\log\\left(\\frac{x}{1-x}\\right)$，参数给定为 $a = -0.2$ 和 $b = 1.5$。logit 函数的输入被裁剪到远离 $0$ 和 $1$ 的一个小区间内，例如 $[10^{-6}, 1-10^{-6}]$，以保持数值稳定性。\n\n第三，我们定义净收益指标。对于给定的风险阈值 $t \\in (0, 1)$，基于模型的策略建议在 $p_i \\ge t$ 时进行治疗。这种策略的净收益由以下公式给出：\n$$\n\\mathrm{NB}(t) = \\frac{\\mathrm{TP}(t)}{N} - \\frac{\\mathrm{FP}(t)}{N} \\cdot \\frac{t}{1-t}\n$$\n其中 $N$ 是总样本量，$\\mathrm{TP}(t)$ 是在阈值 $t$ 时的真阳性数量，$\\mathrm{FP}(t)$ 是在阈值 $t$ 时的假阳性数量。项 $\\frac{t}{1-t}$ 表示阈值下的结局优势比，并作为假阳性的权重，在需要更高确定性才能采取行动的较高阈值下对其施加更重的惩罚。\n\n我们还考虑了两种参考策略：\n1. 全体治疗：无论风险如何，每个人都接受治疗。其净收益为 $\\mathrm{NB}_{\\mathrm{TA}}(t) = \\hat{\\pi} - (1-\\hat{\\pi})\\frac{t}{1-t}$，其中 $\\hat{\\pi}$ 是样本患病率 $\\frac{1}{N}\\sum y_i$。\n2. 全体不治疗：没有人接受治疗。其净收益始终为零，$\\mathrm{NB}_{\\mathrm{TN}}(t) = 0$。\n这些策略在一组指定的阈值 $T = \\{0.01, 0.10, 0.33, 0.50, 0.90\\}$ 上进行评估。\n\n第四，为了评估净收益估计的统计不确定性，我们采用非参数自助法。这包括通过从原始数据元组 $(y_i, p^{(A)}_i, p^{(B)}_i)$ 中有放回地重抽样来创建 $B=1000$ 个新数据集。对于每个自助样本和每个阈值 $t \\in T$，我们计算所有四种策略（模型 A、模型 B、全体治疗、全体不治疗）的净收益。此过程为每个策略-阈值对产生 $B$ 个净收益的自助法复制样本，例如 $\\{\\mathrm{NB}^{*,(M)}_b(t)\\}_{b=1}^{B}$。\n\n最后，我们形式化了在给定阈值 $t$ 下两种策略 $M_1$ 和 $M_2$ 之间的比较。我们不比较它们各自的置信区间（如果它们重叠可能会产生误导），而是直接分析它们净收益差异的分布，即 $\\Delta(t) = \\mathrm{NB}^{(M_1)}(t) - \\mathrm{NB}^{(M_2)}(t)$。使用自助法复制样本，我们生成了该差异的经验分布：$\\Delta^*_b(t) = \\mathrm{NB}^{*,(M_1)}_b(t) - \\mathrm{NB}^{*,(M_2)}_b(t)$。通过找到 $\\{\\Delta^*_b(t)\\}_{b=1}^{B}$ 分布的 $0.025$ 和 $0.975$ 分位数，构建了 $\\Delta(t)$ 的一个双侧 $95\\%$ 百分位数置信区间。优势的判定规则是：当且仅当它们净收益差异的 $95\\%$ 置信区间的下界严格大于 $0$ 时，策略 $M_1$ 被宣布在阈值 $t$ 下优于策略 $M_2$。\n\n该算法首先生成单个合成数据集。然后，它进入一个进行 $B=1000$ 次迭代的自助法循环。在每次迭代中，它重新抽样数据并计算所有策略在所有阈值下的净收益。循环结束后，它使用存储的自助法结果来计算每个阈值下策略之间差异（模型 A vs. 模型 B，模型 A vs. 全体治疗，模型 B vs. 全体治疗）的置信区间。应用优势规则，并将得到的布尔值按特定顺序收集以用于最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import beta\nfrom scipy.special import logit, expit\n\ndef solve():\n    \"\"\"\n    Implements the end-to-end Decision Curve Analysis (DCA) procedure as specified.\n    \"\"\"\n    # ------------------\n    # 1. Define Constants  Setup\n    # ------------------\n    N = 500\n    PREVALENCE = 0.35\n    SEED = 20240517\n    \n    # Model A parameters\n    BETA_PARAMS_POS = {'a': 5, 'b': 2}\n    BETA_PARAMS_NEG = {'a': 2, 'b': 5}\n    \n    # Model B transformation parameters\n    LOGIT_A = -0.2\n    LOGIT_B = 1.5\n    CLIP_EPS = 1e-6\n    \n    # Analysis parameters\n    THRESHOLDS = [0.01, 0.10, 0.33, 0.50, 0.90]\n    B = 1000  # Number of bootstrap replicates\n    CI_ALPHA = 0.05\n\n    rng = np.random.default_rng(SEED)\n\n    # ------------------\n    # 2. Data Generation\n    # ------------------\n    # Generate true outcomes y\n    y = rng.binomial(1, PREVALENCE, size=N)\n    \n    # Generate Model A probabilities p_A conditional on y\n    pos_mask = (y == 1)\n    neg_mask = (y == 0)\n    n_pos = np.sum(pos_mask)\n    n_neg = N - n_pos\n\n    p_A = np.zeros(N, dtype=float)\n    p_A[pos_mask] = beta.rvs(a=BETA_PARAMS_POS['a'], b=BETA_PARAMS_POS['b'], size=n_pos, random_state=rng)\n    p_A[neg_mask] = beta.rvs(a=BETA_PARAMS_NEG['a'], b=BETA_PARAMS_NEG['b'], size=n_neg, random_state=rng)\n    \n    # Generate Model B probabilities p_B via logistic transformation\n    p_A_clipped = np.clip(p_A, CLIP_EPS, 1 - CLIP_EPS)\n    logit_p_A = logit(p_A_clipped)\n    logit_p_B = LOGIT_A + LOGIT_B * logit_p_A\n    p_B = expit(logit_p_B)\n\n    # ------------------\n    # 3. Net Benefit Helper Function\n    # ------------------\n    def calculate_net_benefit(y_true, p_pred, t):\n        \"\"\"Calculates net benefit for a model-based strategy.\"\"\"\n        n_samples = len(y_true)\n        if n_samples == 0:\n            return 0.0\n        \n        # Predictions based on threshold t\n        y_pred = p_pred = t\n        \n        # TP and FP counts\n        # Cast y_true to boolean for bitwise operations\n        y_true_bool = y_true.astype(bool)\n        tp_count = np.sum(y_pred  y_true_bool)\n        fp_count = np.sum(y_pred  ~y_true_bool)\n\n        # Net Benefit formula\n        return (tp_count / n_samples) - (fp_count / n_samples) * t / (1 - t)\n\n    # ------------------\n    # 4. Bootstrap Procedure\n    # ------------------\n    # Store data for easy resampling\n    all_data = np.column_stack((y, p_A, p_B))\n    \n    # Dictionary to store bootstrap replicates of net benefits\n    # Structure: {threshold: {'model_a': [...], 'model_b': [...], 'treat_all': [...]}}\n    boot_nb_results = {t: {'a': [], 'b': [], 'ta': []} for t in THRESHOLDS}\n\n    for _ in range(B):\n        # Create a bootstrap sample\n        indices = rng.choice(N, size=N, replace=True)\n        boot_sample = all_data[indices]\n        y_boot, p_a_boot, p_b_boot = boot_sample[:, 0], boot_sample[:, 1], boot_sample[:, 2]\n\n        for t in THRESHOLDS:\n            # Net benefit for Model A\n            nb_a = calculate_net_benefit(y_boot, p_a_boot, t)\n            boot_nb_results[t]['a'].append(nb_a)\n\n            # Net benefit for Model B\n            nb_b = calculate_net_benefit(y_boot, p_b_boot, t)\n            boot_nb_results[t]['b'].append(nb_b)\n            \n            # Net benefit for Treat-All strategy\n            pi_hat_boot = np.mean(y_boot)\n            if pi_hat_boot  0: # Avoid issues if bootstrap sample has no positive cases\n                nb_ta = pi_hat_boot - (1 - pi_hat_boot) * t / (1 - t)\n            else:\n                nb_ta = 0.0 # If prevalence is 0, NB is 0 for t0.\n            boot_nb_results[t]['ta'].append(nb_ta)\n\n    # ------------------\n    # 5. Interpretation and Final Output\n    # ------------------\n    final_results = []\n    \n    for t in THRESHOLDS:\n        # Convert lists to numpy arrays for vectorized operations\n        nb_a_boots = np.array(boot_nb_results[t]['a'])\n        nb_b_boots = np.array(boot_nb_results[t]['b'])\n        nb_ta_boots = np.array(boot_nb_results[t]['ta'])\n\n        # Comparison 1: Model A vs Model B\n        delta_ab = nb_a_boots - nb_b_boots\n        ci_lower_ab = np.quantile(delta_ab, CI_ALPHA / 2)\n        final_results.append(ci_lower_ab  0)\n\n        # Comparison 2: Model A vs Treat-All\n        delta_ata = nb_a_boots - nb_ta_boots\n        ci_lower_ata = np.quantile(delta_ata, CI_ALPHA / 2)\n        final_results.append(ci_lower_ata  0)\n        \n        # Comparison 3: Model B vs Treat-All\n        delta_bta = nb_b_boots - nb_ta_boots\n        ci_lower_bta = np.quantile(delta_bta, CI_ALPHA / 2)\n        final_results.append(ci_lower_bta  0)\n\n    # Print results in the specified single-line format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}