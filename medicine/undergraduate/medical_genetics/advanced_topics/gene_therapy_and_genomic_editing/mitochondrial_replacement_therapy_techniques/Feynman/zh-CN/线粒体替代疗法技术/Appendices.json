{
    "hands_on_practices": [
        {
            "introduction": "线粒体置换疗法（MRT）的核心目标是最大限度地减少致病性线粒体DNA（mtDNA）的遗传。本练习将通过一个基于浓度基本原理的简化模型，帮助我们理解母系纺锤体转移（MST）技术中的一个关键挑战——突变mtDNA的残留（carryover）。通过这个计算，你将能够量化影响残留水平的关键物理参数，这是评估MRT技术成功与否的重要一步。",
            "id": "5060831",
            "problem": "母系纺锤体移植（Maternal Spindle Transfer, MST）是一种线粒体替代疗法技术，该技术将母系中期II期纺锤体-染色体复合物作为核质体分离出来，并转移到去核的供体卵母细胞中。一个关键问题是与纺锤体相关线粒体共定位的突变线粒体脱氧核糖核酸（mtDNA）的残留。请使用浓度的标准定义（单位体积内的数量）以及预期计数等于浓度乘以体积这一事实，来模拟预期的突变mtDNA残留量。\n\n假设存在以下具有科学依据的情景。在纺锤体相关微环境中，线粒体的局部浓度为 $\\rho$（线粒体/皮升），每个线粒体平均含有 $m$ 个mtDNA拷贝，其中突变mtDNA拷贝的分数为 $\\varphi$。转移的纺锤体核质体体积为 $v$ 皮升。在微环境在 $v$ 的尺度上充分混合，并且相关线粒体内的突变分数是均匀的近似条件下，推导出有效突变mtDNA浓度 $\\alpha$，然后推导出残留的突变mtDNA拷贝的预期数量 $c$。最后，使用参数值 $\\rho = 300$ 线粒体/皮升, $m = 5$ 拷贝/线粒体, $\\varphi = 0.03$（以小数形式表示）以及 $v = 3.5$ 皮升，计算 $c$ 的值。\n\n将最终答案表示为预期的突变mtDNA拷贝数（单位：拷贝），并将您的答案四舍五入到三位有效数字。",
            "solution": "所述问题具有科学依据，提法恰当且客观。它基于细胞生物学和医学遗传学的既定原理，特别是关于线粒体替代疗法。所提供的定义和参数清晰且足以推导出唯一、有意义的解。所有验证标准均已满足。\n\n目标是确定在母系纺锤体移植（MST）过程中残留的突变线粒体脱氧核糖核酸（mtDNA）拷贝的预期数量，记为 $c$。推导将基于浓度的基本定义。\n\n首先，我们将给定的参数形式化：\n- $\\rho$: 纺锤体相关微环境中的线粒体局部浓度，单位为线粒体/皮升。\n- $m$: 每个线粒体的平均mtDNA拷贝数。\n- $\\varphi$: 突变mtDNA拷贝的无量纲分数。\n- $v$: 转移的纺锤体核质体的体积，单位为皮升。\n\n问题要求我们首先推导出有效突变mtDNA浓度，我们将其记为 $\\alpha$。浓度定义为单位体积内的数量。\n\n1.  线粒体的浓度由 $\\rho$ 给出。\n2.  每个线粒体平均含有 $m$ 个mtDNA拷贝。因此，总mtDNA拷贝（包括野生型和突变型）的浓度是线粒体浓度与每个线粒体拷贝数的乘积。\n    $$\n    \\text{Concentration of total mtDNA copies} = \\rho \\cdot m\n    $$\n    该量的单位是（线粒体/皮升） $\\times$ （mtDNA拷贝/线粒体） = mtDNA拷贝/皮升。\n\n3.  这些mtDNA拷贝中突变部分的分数由 $\\varphi$ 给出。为了求出仅突变mtDNA拷贝的浓度 $\\alpha$，我们将总mtDNA浓度乘以这个分数。\n    $$\n    \\alpha = (\\rho \\cdot m) \\cdot \\varphi = \\rho m \\varphi\n    $$\n    $\\alpha$ 的单位也是 mtDNA拷贝/皮升，这与其作为浓度的定义是一致的。\n\n接下来，我们推导转移中残留的突变mtDNA拷贝的预期数量 $c$。问题明确指出，预期计数是浓度和体积的乘积。\n\n1.  使用推导出的突变mtDNA浓度 $\\alpha$ 和给定的转移体积 $v$，预期的突变mtDNA拷贝数为：\n    $$\n    c = \\alpha \\cdot v\n    $$\n\n2.  代入 $\\alpha$ 的表达式，我们得到 $c$ 的最终符号表达式：\n    $$\n    c = (\\rho m \\varphi) v = \\rho m \\varphi v\n    $$\n    $c$ 的单位是（突变mtDNA拷贝/皮升） $\\times$ 皮升 = 突变mtDNA拷贝，这是一个无量纲的计数，符合预期。\n\n最后，我们被要求使用提供的参数计算 $c$ 的数值：\n- $\\rho = 300 \\, \\text{pL}^{-1}$\n- $m = 5$\n- $\\varphi = 0.03$\n- $v = 3.5 \\, \\text{pL}$\n\n将这些值代入推导出的 $c$ 的公式中：\n$$\nc = (300) \\cdot (5) \\cdot (0.03) \\cdot (3.5)\n$$\n我们分步进行计算：\n$$\nc = (1500) \\cdot (0.03) \\cdot (3.5)\n$$\n$$\nc = 45 \\cdot (3.5)\n$$\n$$\nc = 157.5\n$$\n问题要求最终答案四舍五入到三位有效数字。数字 $157.5$ 有四位有效数字。四舍五入到三位有效数字得到 $158$。第四位有效数字是 $5$，因此需要将前一位数字向上取整。",
            "answer": "$$\\boxed{158}$$"
        },
        {
            "introduction": "除了量化残留，理解MRT操作的生物学基础对于确保其安全性和有效性同样至关重要。本练习将探讨另一种主要的MRT技术——原核移植（PNT），并聚焦于其质量控制环节。这个思想实验将挑战你运用细胞生物学的基本原则，即线粒体位于细胞质而非细胞核内，来解释为何在分离出的原核中检测到父系mtDNA会是程序性失误的明确标志。",
            "id": "5060807",
            "problem": "一个实验室正在优化线粒体替代疗法（MRT）中的原核移植（PNT）技术，以防止致病性线粒体脱氧核糖核酸（mtDNA）的遗传。基本事实包括：在哺乳动物中，mtDNA几乎完全是母系遗传的；精子线粒体在受精时确实会进入卵母细胞，但此后不久会被选择性地清除；选择性清除过程涉及精子发生过程中的泛素标记、卵母细胞因子的识别、蛋白酶体活性、线粒体自噬（一种自噬形式）以及核酸酶介导的mtDNA降解；原核是不含线粒体的细胞核结构。在PNT中，亲本原核被分离成一个核质体，理想情况下，该核质体携带原核和极少量的周围细胞质，然后被移植到一个含有健康线粒体的去核供体受精卵细胞质体中。为了最大限度地减少假象，该实验室采用了一种环状mtDNA选择性测序文库制备方法，该方法能去除线性的核DNA。\n\n在质量控制期间，在分离出亲本核质体后（移植前），团队通过吸取微量体积对核质体进行短暂取样，并对单倍型特异性mtDNA变异进行超深度测序。他们在核质体样本中检测到了精子特有的父系单倍型标记，其水平低但可重复。从线粒体遗传和细胞生物学的基本原理出发，哪个选项最能解释为什么在核质体中检测到父系mtDNA表明PNT过程中存在程序性错误，而不是正常的生物学结果？\n\nA. 因为精子线粒体位于细胞质中，并在受精后不久通过泛素介导的蛋白酶体活性、线粒体自噬和核酸酶攻击被主动清除，所以在核质体中检测到的任何父系mtDNA信号都必定来自原核周围意外带入的细胞质；原核本身不含线粒体，因此这反映了显微切割过程中的一个错误。\n\nB. 因为父系线粒体清除失败是正常发育的常见变异，所以核质体中的父系mtDNA信号反映了预期的双亲遗传，并不意味着核质体分离过程存在任何缺陷。\n\nC. 因为线粒体能瞬时停靠在原核膜上，并将其基因组导入原核空间，所以父系mtDNA信号可以在原核内部自身产生，而无需周围的细胞质；因此，这一检测结果并不意味着PNT显微切割存在问题。\n\nD. 因为核线粒体DNA片段（NUMT）在测序中常常被误认为是环状mtDNA，所以父系mtDNA信号很可能反映的是核质体中线性核DNA的NUMT扩增，而不是真正的细胞质带入；因此，这并不意味着存在程序性错误。",
            "solution": "题目要求解释为什么在原核移植（PNT）过程中，从分离的亲本核质体样本中检测到父系线粒体脱氧核糖核酸（mtDNA）单倍型表明存在程序性错误。\n\n要解决这个问题，我们必须综合题干中提供的基础生物学原理和程序细节。\n\n**基于原理的推导**\n\n1.  **线粒体和mtDNA的细胞定位：** 题目明确指出线粒体是细胞质细胞器。细胞生物学的一个核心公理是，线粒体及其环状基因组（mtDNA）存在于细胞质中，而不是细胞核内。\n\n2.  **原核与核质体的性质：** 题目明确说明：“原核是不含线粒体的细胞核结构。”原核是存在于受精卵中、融合前的配子（精子和卵子）的单倍体细胞核。根据程序定义，核质体是被分离的实体，它“理想情况下携带原核和极少量的周围细胞质”。因此，一个理论上完美的核质体将仅由原核及其核膜组成，不含任何线粒体和mtDNA。\n\n3.  **父系mtDNA的来源：** 题目描述了携带父系mtDNA的精子线粒体在受精时进入卵母细胞。尽管它们是清除目标，但在受精后的一段时间内，它们物理上存在于受精卵的细胞质中，而这恰好是执行PNT的时间点。因此，父系mtDNA可作为受精卵内源自精子的细胞质内容的特异性标记。\n\n4.  **PNT显微切割的目标：** 分离亲本核质体的目标是将细胞核物质（包含亲本染色体的原核）与含有致病性mtDNA的母体细胞质分离开。该程序的成功取决于高保真地实现这种分离，即只带入“极少量的周围细胞质”。\n\n5.  **测序结果的解读：** 质量控制步骤涉及对分离出的核质体样本进行测序。检测到了父系mtDNA单倍型。鉴于线粒体和mtDNA完全位于细胞质中（相对于细胞核而言），且原核本身不含线粒体，那么这种父系mtDNA的唯一可能来源就是在显微切割过程中与原核一同被无意吸入的受精卵细胞质。\n\n6.  **排除其他解释：** 题干系统地排除了其他解释的可能性。\n    *   信号来源于核线粒体DNA片段（NUMT）——整合到核基因组中的mtDNA片段——的可能性，被指定的实验方法排除了：“一种环状mtDNA选择性测序文库制备方法，该方法能去除线性的核DNA。”由于NUMT是线性核基因组的一部分，该方法不会扩增它们。因此，信号必须来自真正的环状mtDNA分子。\n    *   认为这是正常生物学结果的观点与程序既定目标以及细胞核与细胞质区室的基本分离原则不符。\n\n**结论：** 在核质体样本中检测到父系mtDNA（一种纯粹的细胞质成分），是细胞质污染的直接且确凿的证据。这种污染意味着未能实现干净分离原核的程序目标。因此，它代表了PNT显微切割步骤中的一个程序性错误。\n\n**逐项分析**\n\n**A. 因为精子线粒体位于细胞质中，并在受精后不久通过泛素介导的蛋白酶体活性、线粒体自噬和核酸酶攻击被主动清除，所以在核质体中检测到的任何父系mtDNA信号都必定来自原核周围意外带入的细胞质；原核本身不含线粒体，因此这反映了显微切割过程中的一个错误。**\n*   **分析：** 该陈述正确地指出了精子线粒体位于细胞质中。它准确地回顾了原核不含线粒体这一既定事实。它正确地推断出，在核质体样本中出现父系mtDNA必定是由于细胞质带入。最后，它正确地得出结论，这种带入构成了显微切割中的程序性错误，因为目标是干净地分离原核。提及清除机制虽然正确，但相对于操作时父系线粒体位于细胞质这一主要事实而言是次要的。该推理完全合理，并与所有提供的信息一致。\n*   **结论：正确**。\n\n**B. 因为父系线粒体清除失败是正常发育的常见变异，所以核质体中的父系mtDNA信号反映了预期的双亲遗传，并不意味着核质体分离过程存在任何缺陷。**\n*   **分析：** 该陈述包含一个事实不正确的前提。题目指出“mtDNA几乎完全是母系遗传的”，这与父系线粒体清除失败是“常见变异”的说法相矛盾。在哺乳动物中，显著的父系泄漏是一种极其罕见的现象。此外，即使一些父系线粒体存留下来，它们也仍然在细胞质中。在核质体样本中检测到它们仍然表明存在细胞质带入，因此是程序性缺陷，而该选项错误地否认了这一点。\n*   **结论：不正确**。\n\n**C. 因为线粒体能瞬时停靠在原核膜上，并将其基因组导入原核空间，所以父系mtDNA信号可以在原核内部自身产生，而无需周围的细胞质；因此，这一检测结果并不意味着PNT显微切割存在问题。**\n*   **分析：** 该陈述提出了一个没有生物学依据的主张。线粒体不会将其整个环状基因组导入细胞核或原核。这将严重破坏真核细胞的区室化。题目明确提供了相反的事实，即“原核...不含线粒体”。该选项虚构了一种已知的不会发生的生物学机制，并与题目的前提相矛盾。\n*   **结论：不正确**。\n\n**D. 因为核线粒体DNA片段（NUMT）在测序中常常被误认为是环状mtDNA，所以父系mtDNA信号很可能反映的是核质体中线性核DNA的NUMT扩增，而不是真正的细胞质带入；因此，这并不意味着存在程序性错误。**\n*   **分析：** 尽管NUMT在mtDNA测序中确实是一个需要关注的问题，但题干明确排除了这种解释。它指明实验室使用了“一种环状mtDNA选择性测序文库制备方法，该方法能去除线性的核DNA”。这项技术专门用于区分来自线粒体的环状mtDNA和含有NUMT的线性核DNA。因此，根据所提供的方法，检测到的信号不可能来自NUMT。该选项忽略了这一关键信息。\n*   **结论：不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "即便MRT手术成功地将初始残留量控制在极低水平，这些残留的突变mtDNA在胚胎发育过程中的长期动态变化仍是一个关键问题。本练习将引导你进入计算生物学的领域，构建一个基于群体遗传学原理（如遗传漂变和自然选择）的随机模型。通过编写程序来模拟异质性在不同组织中的演变，你将能更深入地理解为何某些组织可能出现突变mtDNA比例回升的现象，从而定量评估疾病复发的风险。",
            "id": "5060776",
            "problem": "需要一个计算模型来量化线粒体替代疗法（MRT）中组织特异性回复的风险，其中残留的母系线粒体脱氧核糖核酸（mtDNA）由于复制优势，可能在某些组织中扩增。该模型必须基于适用于线粒体分离的成熟群体遗传学原理，特别是用于遗传漂变的 Wright–Fisher 模型和用于分离方差的二项式抽样，并结合一个简单的选择模型。令 $h \\in [0,1]$ 表示异质率，即细胞内突变 mtDNA 的比例。假设每个细胞在发育后包含固定拷贝数 $N$ 的 mtDNA 基因组。令 $s_t$ 为组织 $t$ 中突变 mtDNA 的组织特异性选择系数，其相对适应度为 $w_{\\mathrm{mut}} = 1 + s_t$，而野生型适应度为 $w_{\\mathrm{wt}} = 1$。从选择前异质率 $h$ 得到的选择后突变比例 $p$ 为\n$$\np = \\frac{h \\cdot w_{\\mathrm{mut}}}{h \\cdot w_{\\mathrm{mut}} + (1 - h) \\cdot w_{\\mathrm{wt}}} = \\frac{h (1 + s_t)}{h (1 + s_t) + (1 - h)}.\n$$\n复制分离通过二项式抽样 $K \\sim \\mathrm{Binomial}(N, p)$ 进行建模，下一代的异质率为 $h' = K / N$。早期胚胎发生会产生一个拷贝数为 $N_b$ 的瓶颈，随后扩增至 $N$，接着进行 $D$ 次与发育相关的细胞分裂，期间拷贝数维持在 $N$。\n\n你的任务是编写一个程序，为每个测试用例执行以下步骤：\n\n1. 对每个组织，在异质率为 $h_0$ 的情况下初始化 $M$ 个独立的细胞谱系。\n2. 对每个谱系，通过抽样 $K_b \\sim \\mathrm{Binomial}(N_b, h_0)$ 施加瓶颈效应，并设置 $h_b = K_b / N_b$。\n3. 使用上述选择更新公式从 $h_b$ 计算 $p$，扩增至 $N$，然后抽样 $K \\sim \\mathrm{Binomial}(N, p)$ 以设置 $h = K / N$。\n4. 迭代 $D$ 次分裂，每次都使用选择更新公式从 $h$ 计算 $p$，并抽样 $K \\sim \\mathrm{Binomial}(N, p)$ 来设置新的 $h$。\n5. 对每个组织，计算其 $M$ 个谱系在发育结束时的平均异质率。在所有组织间，计算这些组织均值的方差为\n$$\n\\mathrm{Var}_{\\mathrm{tissues}} = \\frac{1}{T} \\sum_{t=1}^{T} \\left(\\bar{h}_t - \\bar{h}\\right)^2,\n$$\n其中 $T$ 是组织数量，$\\bar{h}_t$ 是组织 $t$ 的平均异质率，$\\bar{h}$ 是各组织均值的平均值。\n6. 对 $R$ 次独立重复实验重复步骤 1-5，并报告：\n   - 各次重复实验中 $\\mathrm{Var}_{\\mathrm{tissues}}$ 的均值（一个浮点数）。\n   - 回复风险，定义为至少有一个组织的平均异质率大于或等于指定阈值 $h_{\\mathrm{thr}}$ 的重复实验所占的比例（以小数形式表示，不使用百分号）。\n\n请为以下测试套件实现上述模型，每个测试用例由元组 $(h_0, \\{s_t\\}_{t=1}^{T}, N_b, N, D, M, R, h_{\\mathrm{thr}})$ 指定：\n\n- 案例 1（一般差异性选择）：$(0.01, [0.02, 0.00, -0.01], 50, 1000, 15, 200, 200, 0.05)$。\n- 案例 2（无选择基线）：$(0.01, [0.00, 0.00, 0.00], 50, 1000, 15, 200, 200, 0.05)$。\n- 案例 3（一个组织中的强正向选择，更紧的瓶颈）：$(0.01, [0.05, 0.00, 0.00], 20, 1000, 15, 200, 200, 0.05)$。\n- 案例 4（所有组织均为负向选择，更大的 $N$ 和 $D$）：$(0.02, [-0.05, -0.03, -0.02], 50, 2000, 20, 200, 200, 0.05)$。\n\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。其中每个元素对应一个测试用例，并且本身是一个双元素列表 $[\\text{跨组织均值方差}, \\text{回复风险}]$。例如，输出格式必须与 $[[v_1, r_1],[v_2, r_2],[v_3, r_3],[v_4, r_4]]$ 完全一致，其中每个 $v_i$ 和 $r_i$ 都是浮点数。不使用物理单位，回复风险必须以小数形式表示。",
            "solution": "该问题要求开发一个计算模型，以模拟线粒体替代疗法（MRT）后不同组织中线粒体DNA（mtDNA）异质率的动态变化。该模型基于群体遗传学的基本原理，即遗传漂变和自然选择，这是控制分裂细胞中 mtDNA 变异体分离的主要驱动力。\n\n模型的核心是一个随机模拟，用于追踪被称为异质率（$h$）的突变 mtDNA 比例随时间在多个细胞谱系和组织中的变化。该模拟遵循一系列离散的发育步骤：早期胚胎瓶颈、随后的 mtDNA 拷贝数扩增以及一系列细胞分裂。\n\n**科学原理**\n\n1.  **通过二项式抽样实现的遗传漂变**：在任何含有有限数量（$N$）mtDNA 分子的细胞中，分裂时将这些分子分配给子细胞的过程会受到随机抽样误差的影响。这种被称为遗传漂变的现象，使用二项分布进行建模。如果一个亲代细胞的异质率为 $h$，那么分离到子细胞谱系中的突变 mtDNA 分子数量 $K$ 是一个随机变量 $K \\sim \\mathrm{Binomial}(N, p)$，其中 $p$ 是突变 mtDNA 的期望比例。下一代的异质率则为 $h' = K/N$。这种抽样引入的方差与拷贝数 $N$ 成反比。模型包含两个关键的漂变阶段：\n    *   **胚胎瓶颈**：在早期胚胎发生过程中，mtDNA 拷贝数急剧减少到一个很小的值 $N_b$。这在初始细胞谱系之间造成了异质率的显著随机变异，因为当 $N_b$ 很小时，抽样方差很大。\n    *   **体细胞分离**：在发育中组织的后续细胞分裂过程中，分离在一个更大、更稳定的拷贝数 $N$ 下继续进行。\n\n2.  **组织特异性选择**：与野生型 mtDNA 相比，突变型 mtDNA 可能具有复制优势或劣势。这通过一个对每个组织 $t$ 特异的选择系数 $s_t$ 来建模。突变 mtDNA 的相对适应度为 $w_{\\mathrm{mut}} = 1 + s_t$，而野生型的适应度为 $w_{\\mathrm{wt}} = 1$。选择通过在随机抽样（漂变）步骤之前修改突变 mtDNA 的期望频率来发挥作用。给定选择前的异质率 $h$，选择后的期望频率 $p$ 计算如下：\n    $$\n    p = \\frac{h \\cdot w_{\\mathrm{mut}}}{h \\cdot w_{\\mathrm{mut}} + (1 - h) \\cdot w_{\\mathrm{wt}}} = \\frac{h (1 + s_t)}{1 + h s_t}\n    $$\n    正的 $s_t$ 会增加 $h$，而负的 $s_t$ 会减少它。由于 $s_t$ 因组织而异，这是驱动不同组织间异质率水平分化的机制。\n\n**模拟算法**\n\n任务是实现这个模型并针对几个测试用例运行它。对于每个案例，模拟通过 $R$ 次独立重复实验进行，以确保结果在统计上是稳健的。在每次重复实验中，执行以下步骤：\n\n1.  **初始化**：对于 $T$ 个组织中的每一个，我们模拟 $M$ 个独立的细胞谱系。所有谱系都起源于一个具有指定初始异质率 $h_0$ 的合子。\n\n2.  **瓶颈**：$M$ 个谱系中的每一个都经历一个瓶颈。每个谱系的突变 mtDNA 数量 $K_b$ 从二项分布 $K_b \\sim \\mathrm{Binomial}(N_b, h_0)$ 中独立抽取。然后，每个谱系的瓶颈后异质率为 $h_b = K_b / N_b$。此步骤对每个组织都执行，但由于它发生在组织分化之前，所以所有组织的参数（$N_b, h_0$）都是相同的。\n\n3.  **扩增**：mtDNA 拷贝数扩增到体细胞水平 $N$。这被建模为第一次选择性分裂。对于每个谱系，使用其瓶颈后异质率 $h_b$ 和组织特异性选择系数 $s_t$ 来计算选择后概率 $p$。然后，我们抽样新的突变 mtDNA 数量 $K \\sim \\mathrm{Binomial}(N, p)$ 并将异质率更新为 $h = K/N$。\n\n4.  **体细胞分裂**：我们迭代进行 $D$ 次后续的细胞分裂。在每次分裂中，我们重复步骤3的过程：基于当前的异质率 $h$ 和 $s_t$ 计算新的选择概率 $p$，然后抽样下一代的突变计数 $K \\sim \\mathrm{Binomial}(N, p)$ 以得到新的异质率 $h' = K/N$。\n\n5.  **每次重复实验的数据收集**：在所有 $D$ 次分裂完成后，对于每个组织 $t$，我们计算其 $M$ 个谱系的平均异质率 $\\bar{h}_t$。然后我们计算当前重复实验中，这 $T$ 个组织的平均异质率值的方差：\n    $$\n    \\mathrm{Var}_{\\mathrm{tissues}} = \\frac{1}{T} \\sum_{t=1}^{T} (\\bar{h}_t - \\bar{h})^2\n    $$\n    其中 $\\bar{h}$ 是所有 $\\bar{h}_t$ 的均值。我们还检查是否有任何组织的平均异质率 $\\bar{h}_t$ 达到或超过了回复阈值 $h_{\\mathrm{thr}}$。\n\n6.  **最终汇总**：完成所有 $R$ 次重复实验后，我们计算两个最终指标：\n    *   在每次重复实验中计算出的 $\\mathrm{Var}_{\\mathrm{tissues}}$ 值的均值。\n    *   回复风险，定义为在 $R$ 次重复实验中，至少有一个组织的平均异质率超过 $h_{\\mathrm{thr}}$ 的实验所占的比例。\n\n**使用 `numpy` 实现**\n\n该模拟使用 Python 的 `numpy` 库来实现以提高性能。高效实现的关键是向量化。我们不是一次模拟一个谱系，而是将给定组织的 $M$ 个谱系表示为一个大小为 $M$ 的 `numpy` 数组。所有步骤——计算选择概率、从二项分布中抽样以及更新异质率——都作为数组操作执行，同时作用于所有 $M$ 个谱系。这显著加快了计算速度，因为每个测试用例都涉及数百万次随机抽样事件。`numpy.random.binomial` 函数特别适合此任务，因为它可以在单次调用中接受一个概率数组并生成一个相应的随机变量值数组。同样，`numpy.mean` 和 `numpy.var` 用于高效计算最终的统计数据。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (h_0, {s_t}, N_b, N, D, M, R, h_thr)\n        (0.01, [0.02, 0.00, -0.01], 50, 1000, 15, 200, 200, 0.05),\n        (0.01, [0.00, 0.00, 0.00], 50, 1000, 15, 200, 200, 0.05),\n        (0.01, [0.05, 0.00, 0.00], 20, 1000, 15, 200, 200, 0.05),\n        (0.02, [-0.05, -0.03, -0.02], 50, 2000, 20, 200, 200, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        h0, s_t_list, Nb, N, D, M, R, h_thr = case\n        result = run_simulation_for_case(h0, s_t_list, Nb, N, D, M, R, h_thr)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python matches the required format '[item1, item2]'.\n    # Joining these string representations with commas and enclosing in brackets gives the final format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation_for_case(h0, s_t_list, Nb, N, D, M, R, h_thr):\n    \"\"\"\n    Performs the full simulation for a single test case.\n\n    Args:\n        h0 (float): Initial heteroplasmy.\n        s_t_list (list of float): List of tissue-specific selection coefficients.\n        Nb (int): Bottleneck mtDNA copy number.\n        N (int): Somatic cell mtDNA copy number.\n        D (int): Number of developmentally relevant divisions.\n        M (int): Number of independent cell lineages per tissue.\n        R (int): Number of independent replicates.\n        h_thr (float): Heteroplasmy threshold for reversion risk.\n\n    Returns:\n        list: A two-element list containing [mean_variance_across_tissues, reversion_risk].\n    \"\"\"\n    num_tissues = len(s_t_list)\n    replicate_variances = np.zeros(R)\n    reversion_event_count = 0\n\n    for i in range(R):\n        tissue_mean_heteroplasmies = np.zeros(num_tissues)\n\n        for j, s_t in enumerate(s_t_list):\n            # Step 2: Apply bottleneck to M lineages starting from a single zygote state\n            k_b = np.random.binomial(Nb, h0, size=M)\n            h_b = k_b / Nb\n\n            # Step 3: Expand to somatic copy number N under selection\n            # The selection formula is p = h(1+s) / (h(1+s) + (1-h)) = h(1+s) / (1+hs)\n            # This vectorized calculation is applied to the array of M heteroplasmies.\n            \n            # Use np.divide to handle potential division by zero, although not expected here\n            # as 1 + h*s > 0 for given s_t > -1 and h in [0, 1].\n            p_expand_num = h_b * (1 + s_t)\n            p_expand_den = 1 + h_b * s_t\n            p_expand = np.divide(p_expand_num, p_expand_den, out=np.zeros_like(p_expand_num), where=p_expand_den!=0)\n\n            k_expand = np.random.binomial(N, p_expand)\n            h_current = k_expand / N\n\n            # Step 4: Iterate for D divisions\n            for _ in range(D):\n                p_division_num = h_current * (1 + s_t)\n                p_division_den = 1 + h_current * s_t\n                p_division = np.divide(p_division_num, p_division_den, out=np.zeros_like(p_division_num), where=p_division_den!=0)\n                \n                k_division = np.random.binomial(N, p_division)\n                h_current = k_division / N\n            \n            # Step 5 (Part 1): Compute mean heteroplasmy for the current tissue\n            tissue_mean_heteroplasmies[j] = np.mean(h_current)\n        \n        # Step 5 (Part 2): Compute variance of tissue means for this replicate\n        # np.var with default ddof=0 computes population variance (divides by T), as required.\n        replicate_variances[i] = np.var(tissue_mean_heteroplasmies)\n        \n        # Check for reversion risk event in this replicate\n        if np.any(tissue_mean_heteroplasmies >= h_thr):\n            reversion_event_count += 1\n            \n    # Step 6: Average variance and calculate risk fraction across all replicates\n    mean_variance = np.mean(replicate_variances)\n    reversion_risk = reversion_event_count / R\n    \n    return [mean_variance, reversion_risk]\n\n\nsolve()\n```"
        }
    ]
}