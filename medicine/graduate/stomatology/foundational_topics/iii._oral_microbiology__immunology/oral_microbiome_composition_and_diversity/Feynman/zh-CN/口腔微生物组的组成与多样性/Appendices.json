{
    "hands_on_practices": [
        {
            "introduction": "量化微生物多样性是口腔微生物组研究中的一项基本任务。然而，不同的多样性指数对群落结构的不同方面（例如优势物种与稀有物种的相对影响）具有不同的敏感性。本练习旨在培养计算和解释两种核心α多样性指数的基础技能，帮助您理解如何通过数学定义来揭示群落的内在结构特性。",
            "id": "4743979",
            "problem": "在高等口腔学中，对口腔微生物组组成和多样性的定量评估依赖于将观测到的分类单元计数转换为相对丰度，然后应用基于经过充分检验的信息论和概率论原理的多样性指标。考虑一个唾液样本，其分析了四个分类单元，计数分别为 $\\text{A}:5$、$\\text{B}:5$、$\\text{C}:40$ 和 $\\text{D}:50$。\n\n从核心定义出发，按以下步骤进行：\n1. 将计数归一化以获得每个分类单元的相对丰度 $p_i$，利用 $p_i$ 等于分类单元 $i$ 的计数除以总计数这一事实。\n2. 使用信息论中香农熵的基本定义，推导该分布的香农多样性（香农熵）$H$ 的表达式（以自然对数单位——奈特(nats)表示），并计算其样本值。\n3. 使用希尔数(Hill numbers)多样性框架，推导2阶多样性（表示为 ${}^{2}D$）的表达式，它对应于辛普森集中度(Simpson concentration)的倒数，并计算其样本值。\n4. 根据每个指标对相对丰度 $p_i$ 的数学依赖关系，解释哪个指标更侧重于优势分类单元，并说明原因，此解释不依赖于数值。\n\n将两个数值都四舍五入到四位有效数字。将香农多样性以奈特(nats)为单位表示，并将2阶希尔数表示为无量纲量。将最终数值结果报告为单行矩阵 $\\big(H \\text{ (in nats)}\\;\\; {}^{2}D\\big)$。",
            "solution": "该问题提法清晰，具有科学依据，并为完整解答提供了所有必要信息。我们按要求的四个部分进行。\n\n四个分类单元的计数给出为 $n_A = 5$、 $n_B = 5$、 $n_C = 40$ 和 $n_D = 50$。\n\n1.  **将计数归一化为相对丰度**\n\n第一步是计算样本中所有分类单元的总计数，记为 $N$。\n$$N = n_A + n_B + n_C + n_D = 5 + 5 + 40 + 50 = 100$$\n每个分类单元 $i$ 的相对丰度 $p_i$ 是其计数 $n_i$ 除以总计数 $N$。\n$$p_i = \\frac{n_i}{N}$$\n将此定义应用于我们的数据：\n$$p_A = \\frac{5}{100} = 0.05$$\n$$p_B = \\frac{5}{100} = 0.05$$\n$$p_C = \\frac{40}{100} = 0.40$$\n$$p_D = \\frac{50}{100} = 0.50$$\n作为验证，所有相对丰度的总和必须等于 $1$。\n$$\\sum_{i \\in \\{A,B,C,D\\}} p_i = 0.05 + 0.05 + 0.40 + 0.50 = 1.00$$\n\n2.  **香农多样性（香农熵），$H$**\n\n具有 $S$ 个状态（分类单元）和相应概率（相对丰度）$p_i$ 的概率分布的香农熵 $H$ 的基本定义由下式给出：\n$$H = - \\sum_{i=1}^{S} p_i \\ln(p_i)$$\n如题目所指定，使用自然对数 $\\ln$ 得出的熵单位为奈特(nats)。对于给定的 $S=4$ 个分类单元的样本， $H$ 的表达式为：\n$$H = - \\left( p_A \\ln(p_A) + p_B \\ln(p_B) + p_C \\ln(p_C) + p_D \\ln(p_D) \\right)$$\n代入计算出的相对丰度：\n$$H = - \\left( 0.05 \\ln(0.05) + 0.05 \\ln(0.05) + 0.40 \\ln(0.40) + 0.50 \\ln(0.50) \\right)$$\n这可以简化为：\n$$H = - \\left( 2 \\times 0.05 \\ln(0.05) + 0.40 \\ln(0.40) + 0.50 \\ln(0.50) \\right)$$\n我们现在计算其数值：\n$$H \\approx - \\left( 0.1 \\times (-2.99573) + 0.40 \\times (-0.91629) + 0.50 \\times (-0.69315) \\right)$$\n$$H \\approx - \\left( -0.299573 - 0.366516 - 0.346575 \\right)$$\n$$H \\approx - ( -1.012664 )$$\n$$H \\approx 1.012664$$\n四舍五入到四位有效数字，香农多样性为 $H \\approx 1.013$ nats。\n\n3.  **2阶希尔数，${}^{2}D$（辛普森多样性倒数）**\n\n$q$ 阶多样性的希尔数通用公式为：\n$${}^{q}D = \\left( \\sum_{i=1}^{S} p_i^q \\right)^{\\frac{1}{1-q}}$$\n此公式定义于 $q \\ge 0$ 且 $q \\neq 1$。对于阶数 $q=2$ 的多样性，表达式变为：\n$${}^{2}D = \\left( \\sum_{i=1}^{S} p_i^2 \\right)^{\\frac{1}{1-2}} = \\left( \\sum_{i=1}^{S} p_i^2 \\right)^{-1} = \\frac{1}{\\sum_{i=1}^{S} p_i^2}$$\n分母中的项 $\\sum_{i=1}^{S} p_i^2$ 是辛普森集中度指数，通常表示为 $\\lambda$。因此，${}^{2}D$ 是辛普森集中度的倒数。我们首先计算 $\\lambda$：\n$$\\lambda = p_A^2 + p_B^2 + p_C^2 + p_D^2$$\n代入相对丰度：\n$$\\lambda = (0.05)^2 + (0.05)^2 + (0.40)^2 + (0.50)^2$$\n$$\\lambda = 0.0025 + 0.0025 + 0.1600 + 0.2500 = 0.4150$$\n现在，我们计算 ${}^{2}D$：\n$${}^{2}D = \\frac{1}{\\lambda} = \\frac{1}{0.4150} \\approx 2.40963855$$\n四舍五入到四位有效数字，2阶希尔数为 ${}^{2}D \\approx 2.410$。这个量是无量纲的。\n\n4.  **对优势分类单元权重的比较**\n\n要确定哪个指标更侧重于优势分类单元，我们必须检查它们所源自的求和式的数学形式，而不参考具体的数值结果。\n\n2阶多样性 ${}^{2}D$ 是辛普森集中度 $\\lambda = \\sum_{i=1}^{S} p_i^2$ 的倒数。每个分类单元对该总和的贡献与其相对丰度的平方 $p_i^2$ 成正比。平方运算给予较大的 $p_i$ 值不成比例的更大权重。例如，一个丰度为 $p_1$ 的分类单元，其丰度是另一个丰度为 $p_2$ 的分类单元的两倍（即 $p_1 = 2p_2$），它对总和 $\\lambda$ 的贡献将是四倍（即 $p_1^2 = 4p_2^2$）。这种对高丰度分类单元贡献的放大意味着 $\\lambda$ 及其倒数 ${}^{2}D$ 受到群落中最优势成员的严重影响。\n\n香农多样性 $H = - \\sum_{i=1}^{S} p_i \\ln(p_i)$ 是形如 $f(p_i) = -p_i \\ln(p_i)$ 的项的总和。该函数由 $p_i$ 加权，但对数项 $\\ln(p_i)$ 的增长速度远慢于 $p_i$ 本身。对于一个优势分类单元，其 $p_i$很大（接近 $1$），$\\ln(p_i)$ 是一个小的负数（接近 $0$），这缓和了该分类单元的贡献。相反，对于一个稀有分类单元，其 $p_i$很小（接近 $0$），$\\ln(p_i)$ 是一个大的负数，这相对于其丰度增加了该项的贡献。这种函数形式给予所有物种更公平的权重，使得 $H$ 对丰富度（分类单元的数量）和均匀度都敏感，而不是由最丰富的分类单元主导。\n\n因此，由于其计算涉及相对丰度的平方，与香农多样性 $H$ 相比，2阶希尔数 ${}^{2}D$ 更侧重于优势分类单元。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 1.013  2.410 \\end{pmatrix} } $$"
        },
        {
            "introduction": "在评估了样本内的α多样性之后，我们通常需要比较不同位点（例如健康与疾病部位）的微生物群落，即β多样性分析。本练习超越了简单计算差异值，旨在深入探究群落差异背后的生态学机制。通过将Jaccard相异性分解为物种替换（turnover）和嵌套（nestedness）两个组分，我们可以更深刻地理解导致群落变化的生物学过程。",
            "id": "4743984",
            "problem": "在一项口腔医学领域的慢性牙周炎临床研究中，研究人员使用源自16S核糖体核糖核酸（rRNA）扩增子测序的有无数据，评估了两个龈下位点的群落组成。设位点$1$的分类单元集为$S_1 = \\{A,B,C,D\\}$，位点$2$的分类单元集为$S_2 = \\{A,C,D,E\\}$。从Jaccard相似性是共享分类单元数与在一对位点中观察到的总分类单元数之比的集合论定义出发，且β多样性作为Jaccard相异性是Jaccard相似性的补集，推导Jaccard相异性针对有无数据的两个概念组分的分解：一个捕捉位点间分类单元替换的周转组分，以及一个捕捉当一个位点是另一个位点的子集时完全由丰富度差异导致的相异性的嵌套导致的组分。使用这些基础（不假设任何快捷公式），确定当两个位点具有相等丰富度时，嵌套导致的组分是否必须为零，并计算给定集合$S_1$和$S_2$的周转组分。仅报告周转组分作为您的最终答案。以精确分数形式表示您的最终答案；无需单位。",
            "solution": "我们首先将两个分类单元集$S_1$和$S_2$之间的多样性组分形式化。设$a$为两个位点共有的分类单元数量（交集的基数），$b$为位点$1$独有的分类单元数量，$c$为位点$2$独有的分类单元数量。\n这些量定义如下：\n$$a = |S_1 \\cap S_2|$$\n$$b = |S_1 \\setminus S_2|$$\n$$c = |S_2 \\setminus S_1|$$\n\n每个位点的物种丰富度（分类单元数量）为$|S_1| = a+b$和$|S_2| = a+c$。两个位点的总分类单元数是并集的基数，$|S_1 \\cup S_2| = a+b+c$。\n\n根据问题陈述，Jaccard相似性$J_{sim}$是共享分类单元数与总分类单元数之比。\n$$J_{sim} = \\frac{|S_1 \\cap S_2|}{|S_1 \\cup S_2|} = \\frac{a}{a+b+c}$$\n\nJaccard相异性$J_{dis}$是相似性的补集。\n$$J_{dis} = 1 - J_{sim} = 1 - \\frac{a}{a+b+c} = \\frac{(a+b+c) - a}{a+b+c} = \\frac{b+c}{a+b+c}$$\n这个量$J_{dis}$表示相对于总分类单元库，两个位点之间不共享的分类单元的比例。分子$b+c$表示两个群落之间的差异总数。\n\n现在我们必须将这个总相异性分解为两个组分：周转（$J_{tur}$）和嵌套导致（$J_{nes}$），使得$J_{dis} = J_{tur} + J_{nes}$。\n\n周转组分解释了分类单元的替换。这是一个对称过程。对于位点$1$中存在但位点$2$中不存在的每个分类单元，可能在位点$2$中存在一个相应的分类单元而位点$1$中不存在。这种潜在“交换”的数量受限于两个独有分类单元集中较小者的数量。参与这种平衡替换的总分类单元数是$2 \\times \\min(b,c)$。将此值通过总分类单元数$a+b+c$进行归一化，得到Jaccard相异性的周转组分：\n$$J_{tur} = \\frac{2 \\min(b,c)}{a+b+c}$$\n\n嵌套导致的组分解释了由丰富度差异引起的相异性，即一个独有分类单元集大于另一个。这种不平衡由独有分类单元计数的绝对差$|b-c|$给出。将此值通过总分类单元数进行归一化，得到嵌套导致的组分：\n$$J_{nes} = \\frac{|b-c|}{a+b+c}$$\n\n为了验证这个分解，我们将两个组分相加：\n$$J_{tur} + J_{nes} = \\frac{2 \\min(b,c)}{a+b+c} + \\frac{|b-c|}{a+b+c} = \\frac{2 \\min(b,c) + |b-c|}{a+b+c}$$\n我们必须证明$2 \\min(b,c) + |b-c| = b+c$。\n情况1：如果$b \\ge c$，那么$\\min(b,c) = c$且$|b-c| = b-c$。分子变为$2c + (b-c) = b+c$。\n情况2：如果$c > b$，那么$\\min(b,c) = b$且$|b-c| = c-b$。分子变为$2b + (c-b) = b+c$。\n在这两种情况下，分子都是$b+c$。因此，分解是有效的：\n$$J_{dis} = J_{tur} + J_{nes} = \\frac{b+c}{a+b+c}$$\n推导至此完成。\n\n接下来，我们确定当两个位点具有相等丰富度时，嵌套导致的组分是否必须为零。\n相等丰富度意味着$|S_1| = |S_2|$。\n使用我们的符号，这意味着$a+b = a+c$。\n两边减去$a$得到$b = c$。\n现在，我们在此条件下检验嵌套导致的组分$J_{nes}$的公式：\n$$J_{nes} = \\frac{|b-c|}{a+b+c}$$\n如果$b=c$，那么分子变为$|b-b| = |0| = 0$。\n因此，$J_{nes} = \\frac{0}{a+b+c} = 0$。\n这证实了当两个位点具有相等的分类单元丰富度时，Jaccard相异性的嵌套导致的组分必须为零。在这种情况下，任何观察到的相异性完全是由周转引起的。\n\n最后，我们为给定的集合$S_1 = \\{A,B,C,D\\}$和$S_2 = \\{A,C,D,E\\}$计算周转组分$J_{tur}$。\n首先，我们计算$a$、$b$和$c$的值：\n-   共享的分类单元集是$S_1 \\cap S_2 = \\{A,C,D\\}$。因此，$a = |S_1 \\cap S_2| = 3$。\n-   位点$1$独有的分类单元集是$S_1 \\setminus S_2 = \\{B\\}$。因此，$b = |S_1 \\setminus S_2| = 1$。\n-   位点$2$独有的分类单元集是$S_2 \\setminus S_1 = \\{E\\}$。因此，$c = |S_2 \\setminus S_1| = 1$。\n\n每个位点的丰富度为$|S_1| = a+b = 3+1 = 4$和$|S_2| = a+c = 3+1 = 4$。由于丰富度相等，我们预期嵌套组分为$0$，所有相异性都来自周转。\n\n现在我们使用其推导出的公式计算周转组分：\n$$J_{tur} = \\frac{2 \\min(b,c)}{a+b+c}$$\n代入计算出的值$a=3$，$b=1$和$c=1$：\n$$J_{tur} = \\frac{2 \\min(1,1)}{3+1+1} = \\frac{2 \\times 1}{5} = \\frac{2}{5}$$\n给定集合的周转组分为$\\frac{2}{5}$。",
            "answer": "$$\\boxed{\\frac{2}{5}}$$"
        },
        {
            "introduction": "多样性指数提供了群落的静态“快照”，但口腔微生物组是一个动态系统。为了理解其对饮食变化等扰动的响应和稳定性，我们需要动态模型。这项高级计算练习将引导您使用广义Lotka-Volterra模型来模拟群落轨迹，从而在计算环境中探索如生态恢复力（resilience）和滞后效应（hysteresis）等关键生态学概念，这对于理解口腔的长期健康与疾病至关重要。",
            "id": "4744038",
            "problem": "您的任务是，以符合高阶研究生水平口腔科学的方式，实施并分析一个广义 Lotka–Volterra (gLV) 模型，用以研究在饮食中糖分发生瞬时变化的情况下，口腔微生物组的组成和多样性。目标是，当糖分供应被限制一周然后恢复后，通过使用组成空间中返回路径的形状作为判定标准，来确定模拟的群落是表现出恢复力还是滞后性。\n\n从以下基本基础开始：\n- 对于物种丰度 $x_i(t)$，$i \\in \\{1,\\dots,S\\}$，在影响人均增长率的环境驱动 $s(t)$ 下，广义 Lotka–Volterra (gLV) 动力学为\n$$\n\\frac{dx_i}{dt} \\;=\\; x_i(t)\\left[r_i \\;+\\; \\sum_{j=1}^{S} A_{ij} x_j(t) \\;+\\; b_i\\,s(t)\\right],\n$$\n其中 $r_i$ 是内在人均增长率，$A_{ij}$ 是相互作用系数，$b_i$ 是糖敏感性系数。\n- 此处，生态恢复力的操作性定义为：在相同条件下，沿着与扰动前轨迹没有显著偏离的路径返回到扰动前的组成。滞后性的操作性定义为：一种路径依赖的恢复，使得返回轨迹显著偏离扰动前轨迹，和/或在相同的环境条件下，恢复后的最终组成与限制前的组成有实质性差异。\n\n数学和算法要求：\n1. 使用步长为 $\\Delta t = 0.02$ 天的 4 阶定步长显式 Runge–Kutta 方法 (RK4) 来模拟 $S$ 个物种的 gLV 系统，以确保平滑向量场的数值稳定性。\n2. 糖分方案 $s(t)$ 必须在三个连续阶段内是分段常数：\n   - 基线糖分：持续 $7$ 天，其中 $s(t)=1$。\n   - 限制：持续 $7$ 天，其中 $s(t)=0$。\n   - 返回基线：持续 $7$ 天，其中 $s(t)=1$。\n   因此，完整的模拟时间范围是 $21$ 天。\n3. 为确保生物学合理性，在每个 RK4 步骤后通过截断丰度来强制非负性：如果任何 $x_i(t)$ 因数值误差变为负数，则在下一步之前将其设置为一个小的下限值 $10^{-9}$。\n4. 以每日间隔记录群落组成，形式为相对丰度（即归一化向量）\n$$\np(t_k) \\;=\\; \\frac{x(t_k)}{\\sum_{i=1}^{S} x_i(t_k)},\n$$\n其中 $t_k$ 为整数天数。\n5. 令 $C_{\\mathrm{forward}}$ 表示第一个 $7$ 天基线阶段的每日组成序列，令 $C_{\\mathrm{return}}$ 表示最后一个 $7$ 天返回基线阶段的序列。\n6. 使用以下递推关系定义两个组成序列 $P=\\{p_0,\\dots,p_m\\}$ 和 $Q=\\{q_0,\\dots,q_n\\}$ 之间的离散 Fréchet 距离：\n$$\n\\begin{aligned}\n(a,b) \\;=\\; \\left\\|a-b\\right\\|_2, \\\\\n(0,0) \\;=\\; d(p_0,q_0), \\\\\n(i,0) \\;=\\; \\max\\big(c(i-1,0),\\,d(p_i,q_0)\\big), \\\\\n(0,j) \\;=\\; \\max\\big(c(0,j-1),\\,d(p_0,q_j)\\big), \\\\\n(i,j) \\;=\\; \\max\\Big(\\min\\big(c(i-1,j),\\,c(i-1,j-1),\\,c(i,j-1)\\big),\\,d(p_i,q_j)\\Big),\n\\end{aligned}\n$$\n离散 Fréchet 距离由 $c(m,n)$ 给出。\n7. 计算两个度量指标：\n   - 组成空间中的路径分离度 $D_{\\mathrm{path}} \\equiv \\mathrm{Fr\\acute{e}chet}(C_{\\mathrm{forward}},C_{\\mathrm{return}})$。\n   - 组成空间中的终点分离度 $D_{\\mathrm{end}} \\equiv \\left\\|p(7)-p(21)\\right\\|_2$。\n8. 根据以下规则对每个参数集的结果进行分类：\n   - 恢复型：如果 $D_{\\mathrm{end}} \\le 0.02$ 且 $D_{\\mathrm{path}} \\le 0.05$，则输出整数 $1$。\n   - 滞后型：如果 $D_{\\mathrm{end}} \\ge 0.10$ 或 $D_{\\mathrm{path}} \\ge 0.12$，则输出整数 $2$。\n   - 不确定型：其他情况输出整数 $0$。\n\n测试套件规范：\n为以下三个参数集实施模拟和分类，每个参数集包含 $S=3$ 个物种，并给出了 $r$、$A$、$b$ 和初始丰度向量 $x(0)$ 的明确值。这些参数集旨在探查一个典型的恢复型情景、一个强路径依赖的滞后情景，以及一个具有缓慢竞争漂移的边界情况。\n\n- 案例 $\\mathrm{A}$ (共存且糖敏感性适中；预期为恢复型行为)：\n  - $r = (0.50,\\,0.45,\\,0.40)$,\n  - $A = \\begin{bmatrix}\n    -1.00  -0.10  -0.10 \\\\\n    -0.10  -1.10  -0.10 \\\\\n    -0.10  -0.10  -0.90\n  \\end{bmatrix}$,\n  - $b = (0.20,\\,-0.05,\\,0.00)$,\n  - $x(0)$ 等于基线糖分下的内部平衡点，即 $x(0) = -A^{-1}\\big(r + b\\cdot 1\\big)$。\n- 案例 $\\mathrm{B}$ (强烈的种间竞争且产酸物种具有高糖敏感性；预期为滞后型行为)：\n  - $r = (0.30,\\,0.30,\\,0.05)$,\n  - $A = \\begin{bmatrix}\n    -1.00  -1.40  -0.05 \\\\\n    -1.40  -1.00  -0.05 \\\\\n    -0.05  -0.05  -1.00\n  \\end{bmatrix}$,\n  - $b = (1.00,\\,-0.15,\\,0.00)$,\n  - $x(0) = (1.30,\\,0.01,\\,0.02)$。\n- 案例 $\\mathrm{C}$ (近中性的竞争相互作用且糖敏感性弱；预期为不确定型行为)：\n  - $r = (0.06,\\,0.06,\\,0.06)$,\n  - $A = \\begin{bmatrix}\n    -0.20  -0.19  -0.19 \\\\\n    -0.19  -0.20  -0.19 \\\\\n    -0.19  -0.19  -0.20\n  \\end{bmatrix}$,\n  - $b = (0.05,\\,0.00,\\,0.00)$,\n  - $x(0) = (0.10,\\,0.10,\\,0.10)$。\n\n数值和输出要求：\n- 使用固定的 RK4 步长 $\\Delta t = 0.02$ 天。\n- 在整数天 $t \\in \\{0,1,2,\\dots,21\\}$ 记录每日组成，并用这些数据构建第 $0$ 天到第 $7$ 天的 $C_{\\mathrm{forward}}$ 和第 $14$ 天到第 $21$ 天的 $C_{\\mathrm{return}}$。\n- 您的程序应生成单行输出，其中包含案例 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$ 的分类结果，按此顺序排列，形式为方括号内以逗号分隔的列表（例如，$\\big[$result$_A$,result$_B$,result$_C\\big]$）。\n- 最终输出为无单位的整数。",
            "solution": "本解决方案首先实现必要的计算组件，包括 gLV 模型动力学、一个数值积分器和指定的分析指标。然后将此框架应用于提供的三个不同参数集。\n\n### 1. 建模与数值积分\n\n问题的核心是描述 $S$ 个物种丰度 $x_i(t)$ 的广义 Lotka-Volterra 动力学的常微分方程 (ODE) 系统：\n$$\n\\frac{dx_i}{dt} \\;=\\; f_i(x, t) \\;=\\; x_i(t)\\left[r_i \\;+\\; \\sum_{j=1}^{S} A_{ij} x_j(t) \\;+\\; b_i s(t)\\right]\n$$\n这里，$r_i$ 表示物种 $i$ 的内在增长率，$A_{ij}$ 是相互作用矩阵，其中 $A_{ii}$ 表示种内竞争，$A_{ij}$ ($i \\neq j$) 表示种间相互作用，$b_i$ 量化物种 $i$ 对外部因素 $s(t)$（在此情境中为饮食糖分供应）的敏感性。\n\n糖分供应 $s(t)$ 在一个 $21$ 天的周期内遵循一个分段常数方案：\n$$\ns(t) = \\begin{cases} \n1 & \\text{if } 0 \\le t \\le 7 \\quad \\text{(基线)} \\\\\n0 & \\text{if } 7 < t \\le 14 \\quad \\text{(限制)} \\\\\n1 & \\text{if } 14 < t \\le 21 \\quad \\text{(返回)}\n\\end{cases}\n$$\n为求解此初值问题，我们采用指定的四阶 Runge-Kutta (RK4) 方法，这是一种因其对平滑向量场的准确性和稳定性而表现鲁棒的数值方案。单个 RK4 步骤通过以下方式从时间 $t$ 的状态计算时间 $t+\\Delta t$ 的状态：\n$$\n\\begin{align*}\nk_1 &= f(x(t), t) \\\\\nk_2 &= f(x(t) + \\frac{\\Delta t}{2} k_1, t + \\frac{\\Delta t}{2}) \\\\\nk_3 &= f(x(t) + \\frac{\\Delta t}{2} k_2, t + \\frac{\\Delta t}{2}) \\\\\nk_4 &= f(x(t) + \\Delta t k_3, t + \\Delta t) \\\\\nx(t+\\Delta t) &= x(t) + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\n此过程使用 $\\Delta t=0.02$ 天的固定步长执行。每步之后，通过将任何丰度 $x_i < 0$ 设置为一个小的下限值 $10^{-9}$ 来强制执行非负性约束。此步骤可防止数值伪影将种群驱动到物理上无意义的负值。\n\n### 2. 轨迹分析与度量\n\n模拟运行 $21$ 天。在每个整数天 $t_k \\in \\{0, 1, \\dots, 21\\}$，我们记录系统的组成，定义为相对丰度向量：\n$$\np(t_k) = \\frac{x(t_k)}{\\sum_{i=1}^{S} x_i(t_k)}\n$$\n这个组成空间中的两个特定轨迹值得关注：\n- $C_{\\mathrm{forward}}$：从第 $0$ 天到第 $7$ 天的组成序列，即 $\\{p(0), p(1), \\dots, p(7)\\}$。\n- $C_{\\mathrm{return}}$：从第 $14$ 天到第 $21$ 天的组成序列，即 $\\{p(14), p(15), \\dots, p(21)\\}$。\n\n为了对系统的行为进行分类，计算了两个度量指标：\n1.  **终点分离度 ($D_{\\mathrm{end}}$)**：该指标量化系统状态是否返回到其扰动前的配置。它是基线阶段结束时的组成与恢复阶段结束时的组成之间的欧几里得距离：\n    $$\n    D_{\\mathrm{end}} = \\|p(7) - p(21)\\|_2\n    $$\n2.  **路径分离度 ($D_{\\mathrm{path}}$)**：该指标通过测量基线轨迹和返回轨迹形状之间的相似性来评估路径依赖性。它使用离散 Fréchet 距离计算，概念上是连接两个沿着各自路径行走的实体所需的牵绳的最小长度。我们实现了提供的递推关系，这是一种标准的动态规划算法，来计算 $D_{\\mathrm{path}} = \\mathrm{Fr\\acute{e}chet}(C_{\\mathrm{forward}}, C_{\\mathrm{return}})$。\n\n### 3. 分类\n\n计算出的度量指标用于根据一组确定性规则对生态结果进行分类：\n- **恢复型 (1)**：如果最终状态和返回路径都接近其基线对应物，则系统被分类为恢复型。这要求 $D_{\\mathrm{end}} \\le 0.02$ **且** $D_{\\mathrm{path}} \\le 0.05$。\n- **滞后型 (2)**：如果最终状态远离基线平衡点，或者返回路径显著偏离基线轨迹，则系统被分类为滞后型。这在 $D_{\\mathrm{end}} \\ge 0.10$ **或** $D_{\\mathrm{path}} \\ge 0.12$ 时发生。\n- **不确定型 (0)**：任何不符合恢复型或滞后型严格标准的结​​果都属于此类别。\n\n### 4. 测试案例的实施\n\n将所描述的算法系统地应用于三个指定的测试案例。对于案例 A，初始条件 $x(0)$ 未直接给出，而是定义为基线条件 ($s(t)=1$) 下的平衡态。通过求解线性系统 $A x = -(r + b)$ 来找到该状态。对于案例 B 和 C，初始条件 $x(0)$ 是明确提供的。对每个案例执行模拟和分类逻辑以生成最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Specified in execution environment, but not strictly required for this implementation.\n# from scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"r\": np.array([0.50, 0.45, 0.40]),\n            \"A\": np.array([\n                [-1.00, -0.10, -0.10],\n                [-0.10, -1.10, -0.10],\n                [-0.10, -0.10, -0.90]\n            ]),\n            \"b\": np.array([0.20, -0.05, 0.00]),\n            \"x0\": \"equilibrium\"\n        },\n        {\n            \"name\": \"B\",\n            \"r\": np.array([0.30, 0.30, 0.05]),\n            \"A\": np.array([\n                [-1.00, -1.40, -0.05],\n                [-1.40, -1.00, -0.05],\n                [-0.05, -0.05, -1.00]\n            ]),\n            \"b\": np.array([1.00, -0.15, 0.00]),\n            \"x0\": np.array([1.30, 0.01, 0.02])\n        },\n        {\n            \"name\": \"C\",\n            \"r\": np.array([0.06, 0.06, 0.06]),\n            \"A\": np.array([\n                [-0.20, -0.19, -0.19],\n                [-0.19, -0.20, -0.19],\n                [-0.19, -0.19, -0.20]\n            ]),\n            \"b\": np.array([0.05, 0.00, 0.00]),\n            \"x0\": np.array([0.10, 0.10, 0.10])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation_and_classify(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_s(t):\n    \"\"\"\n    Returns the value of the sugar forcing term s(t) based on time.\n    \"\"\"\n    if t > 14.0:\n        return 1.0\n    elif t > 7.0:\n        return 0.0\n    else:\n        return 1.0\n\ndef glv_rhs(x, t, r, A, b):\n    \"\"\"\n    Computes the right-hand side of the gLV ODE system.\n    dx/dt = x_i * (r_i + sum(A_ij * x_j) + b_i * s(t))\n    \"\"\"\n    s_val = get_s(t)\n    return x * (r + A @ x + b * s_val)\n\ndef rk4_step(func, x, t, dt, r, A, b):\n    \"\"\"\n    Performs a single step of the RK4 method.\n    \"\"\"\n    k1 = func(x, t, r, A, b)\n    k2 = func(x + 0.5 * dt * k1, t + 0.5 * dt, r, A, b)\n    k3 = func(x + 0.5 * dt * k2, t + 0.5 * dt, r, A, b)\n    k4 = func(x + dt * k3, t + dt, r, A, b)\n    x_next = x + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n    return x_next\n\ndef frechet_distance(P, Q):\n    \"\"\"\n    Computes the discrete Fréchet distance between two trajectories P and Q.\n    P and Q are numpy arrays of shape (n_points, n_dims).\n    \"\"\"\n    n = P.shape[0]\n    m = Q.shape[0]\n    # Memoization cache for the coupling measure c(i, j)\n    ca = np.full((n, m), -1.0)\n\n    def dist(i, j):\n        return np.linalg.norm(P[i] - Q[j])\n\n    # Recursive function with memoization to compute c(i, j)\n    def c(i, j):\n        if ca[i, j] > -1.0:\n            return ca[i, j]\n        \n        d_ij = dist(i, j)\n        if i == 0 and j == 0:\n            ca[i, j] = d_ij\n        elif i > 0 and j == 0:\n            ca[i, j] = max(c(i - 1, 0), d_ij)\n        elif i == 0 and j > 0:\n            ca[i, j] = max(c(0, j - 1), d_ij)\n        elif i > 0 and j > 0:\n            ca[i, j] = max(min(c(i - 1, j), c(i - 1, j - 1), c(i, j - 1)), d_ij)\n        else:\n            # This case should not be reached\n            ca[i, j] = float(\"inf\")\n        \n        return ca[i, j]\n\n    return c(n - 1, m - 1)\n\ndef run_simulation_and_classify(case_params):\n    \"\"\"\n    Runs the full gLV simulation for one case, computes metrics, and classifies the outcome.\n    \"\"\"\n    r, A, b = case_params[\"r\"], case_params[\"A\"], case_params[\"b\"]\n    \n    if isinstance(case_params[\"x0\"], str) and case_params[\"x0\"] == \"equilibrium\":\n        # Solve A * x = -(r + b * 1) for equilibrium initial condition\n        x0 = np.linalg.solve(A, -(r + b))\n    else:\n        x0 = case_params[\"x0\"].copy()\n\n    dt = 0.02\n    t_total = 21.0\n    n_steps = int(t_total / dt)\n    steps_per_day = int(1.0 / dt)\n    floor_val = 1e-9\n\n    x = x0\n    t = 0.0\n    \n    daily_compositions = []\n    \n    # Store initial composition at t=0\n    daily_compositions.append(x / x.sum())\n\n    for i in range(n_steps):\n        x = rk4_step(glv_rhs, x, t, dt, r, A, b)\n        \n        # Enforce non-negativity\n        x[x < 0] = floor_val\n        \n        t += dt\n        \n        # Record composition at integer days\n        if (i + 1) % steps_per_day == 0:\n            if np.sum(x) > 0:\n                daily_compositions.append(x / x.sum())\n            else: # Handle case of total extinction\n                daily_compositions.append(np.zeros_like(x))\n\n    # Convert to numpy array for easier slicing\n    daily_compositions = np.array(daily_compositions)\n\n    # Extract trajectories\n    # C_forward: days 0 to 7 (8 points)\n    C_forward = daily_compositions[0:8]\n    # C_return: days 14 to 21 (8 points)\n    C_return = daily_compositions[14:22]\n\n    # Compute metrics\n    # End-point separation: ||p(7) - p(21)||\n    p_7 = daily_compositions[7]\n    p_21 = daily_compositions[21]\n    D_end = np.linalg.norm(p_7 - p_21)\n\n    # Path separation: Fréchet(C_forward, C_return)\n    D_path = frechet_distance(C_forward, C_return)\n    \n    # Classify the outcome\n    if D_end <= 0.02 and D_path <= 0.05:\n        return 1  # Resilient\n    elif D_end >= 0.10 or D_path >= 0.12:\n        return 2  # Hysteretic\n    else:\n        return 0  # Indeterminate\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}