{
    "hands_on_practices": [
        {
            "introduction": "变异过滤的基础是为每个假定的变异位点提供一个可靠的质量分数。本练习将揭开VCF文件中无处不在的$QUAL$分数的神秘面纱。我们将通过这个练习理解，$QUAL$分数并非一个随意设定的数字，而是源于一个严谨的贝叶斯框架，它结合了测序数据的证据（基因型似然）和先验生物学知识。",
            "id": "4617239",
            "problem": "对一个可能含有单核苷酸多态性（SNP）的双等位基因座上的单个二倍体样本进行测序。设 $g \\in \\{0/0, 0/1, 1/1\\}$ 表示样本的基因型，设 $D$ 表示在该基因座上观测到的测序读数数据。基因型似然 $L(D \\mid g)$ 是在给定基因型 $g$ 的条件下观测到数据 $D$ 的概率。广泛使用的Phred标度似然值 $PL_g$ 是相对于最可能的基因型定义的，其公式为 $PL_g = -10 \\log_{10}\\left(L(D \\mid g)/\\max_{h} L(D \\mid h)\\right)$。假设该基因座报告的 $PL$ 值如下：$PL_{0/0} = 80$，$PL_{0/1} = 0$，以及 $PL_{1/1} = 40$。\n\n一个位点层级的先验概率表达了“变异”与“无变异”的先验比值 $O$，其中“无变异”意味着单个样本的基因型为 $0/0$。设 $O = 10^{-3}$。在“变异”事件发生的条件下，假设基因型 $0/1$ 和 $1/1$ 的先验分配由杂合子分数 $\\alpha = 0.9$ 给出，因此 $P(0/1) = \\alpha \\frac{O}{1+O}$ 和 $P(1/1) = (1-\\alpha)\\frac{O}{1+O}$，而 $P(0/0) = \\frac{1}{1+O}$。\n\n仅使用以上定义和贝叶斯法则，推导后验概率 $P(\\text{无变异} \\mid D)$ 关于 $L(D \\mid g)$ 和 $P(g)$ 的表达式，然后通过对该后验概率应用标准的Phred变换，得到位点质量得分 $Q$。最后，使用提供的 $PL$ 值和先验参数计算该基因座的 $Q$ 值。将最终数值结果四舍五入到四位有效数字。",
            "solution": "用户希望我解决一个与变异检出相关的生物信息学问题。\n\n### 问题验证\n\n**第1步：提取已知条件**\n\n-   考虑在某个双等位基因座上的单个二倍体样本。\n-   基因型表示为 $g \\in \\{0/0, 0/1, 1/1\\}$。\n-   观测到的测序读数数据表示为 $D$。\n-   基因型似然为 $L(D \\mid g) = P(D \\mid g)$。\n-   基因型 $g$ 的Phred标度似然值为 $PL_g = -10 \\log_{10}\\left(L(D \\mid g)/\\max_{h} L(D \\mid h)\\right)$。\n-   观测到的Phred标度似然值为 $PL_{0/0} = 80$，$PL_{0/1} = 0$，以及 $PL_{1/1} = 40$。\n-   “变异”与“无变异”的先验比值为 $O = 10^{-3}$。\n-   “无变异”事件对应于基因型 $g=0/0$。\n-   条件杂合子分数为 $\\alpha = 0.9$。\n-   先验概率给出如下：\n    -   $P(g = 0/0) = \\frac{1}{1+O}$\n    -   $P(g = 0/1) = \\alpha \\frac{O}{1+O}$\n    -   $P(g = 1/1) = (1-\\alpha)\\frac{O}{1+O}$\n-   任务是推导后验概率 $P(\\text{无变异} \\mid D)$ 关于 $L(D \\mid g)$ 和 $P(g)$ 的表达式。\n-   然后，将位点质量得分 $Q$ 定义为该后验概率的Phred变换。\n-   最后，使用给定的数据计算 $Q$ 的数值，并四舍五入到四位有效数字。\n\n**第2步：使用提取的已知条件进行验证**\n\n该问题具有科学依据，表述清晰且客观。所提供的基因型似然、Phred标度、先验概率和贝叶斯法则的应用等定义，都是生物信息学领域，特别是在统计遗传学和变异检出流程（例如 GATK, SAMtools）中的标准和基本概念。该问题是自洽的，为得到唯一解提供了所有必要的参数和定义。数值是合理的。没有矛盾、歧义或违反科学原理之处。该问题要求对这些原理进行多步应用，这是一个有效且有意义的练习。\n\n**第3步：结论与行动**\n\n该问题被判定为有效。将提供完整解答。\n\n### 解答\n\n主要目标是计算位点质量得分 $Q$，这首先需要确定位点为非变异的后验概率，$P(\\text{无变异} \\mid D)$。\n\n**1. 推导后验概率 $P(\\text{无变异} \\mid D)$ 的表达式**\n\n“无变异”事件等同于样本具有纯合参考基因型，$g=0/0$。我们需要找到在给定观测数据 $D$ 的条件下该事件的后验概率，即 $P(g=0/0 \\mid D)$。\n\n根据贝叶斯法则，任何给定基因型 $g$ 的后验概率为：\n$$P(g \\mid D) = \\frac{P(D \\mid g) P(g)}{P(D)}$$\n其中 $P(D \\mid g)$ 是给定基因型的数据似然（表示为 $L(D \\mid g)$），$P(g)$ 是基因型的先验概率，而 $P(D)$ 是数据的边际概率，用作归一化常数。边际概率通过对所有可能的基因型 $h$ 求和来计算：\n$$P(D) = \\sum_{h \\in \\{0/0, 0/1, 1/1\\}} P(D \\mid h) P(h)$$\n\n代入给定的似然和先验表示法，分母变为：\n$$P(D) = L(D \\mid 0/0) P(0/0) + L(D \\mid 0/1) P(0/1) + L(D \\mid 1/1) P(1/1)$$\n\n因此，“无变异”情况（$g=0/0$）的后验概率是：\n$$P(\\text{无变异} \\mid D) = P(g=0/0 \\mid D) = \\frac{L(D \\mid 0/0) P(0/0)}{L(D \\mid 0/0) P(0/0) + L(D \\mid 0/1) P(0/1) + L(D \\mid 1/1) P(1/1)}$$\n这是所要求的后验概率关于 $L(D \\mid g)$ 和 $P(g)$ 的表达式。\n\n**2. 定义位点质量得分 $Q$**\n\n问题指出，位点质量得分 $Q$ 是通过对“无变异”事件的后验概率应用标准的Phred变换得到的。一个概率 $p$ 的Phred变换由 $-10 \\log_{10}(p)$ 给出。因此，$Q$ 的定义是：\n$$Q = -10 \\log_{10}(P(\\text{无变异} \\mid D)) = -10 \\log_{10}(P(g=0/0 \\mid D))$$\n\n**3. 计算 $Q$ 的值**\n\n要计算 $Q$，我们必须首先使用给定的参数计算 $P(g=0/0 \\mid D)$ 的数值。这包括从 $PL$ 值计算似然比，以及从 $O$ 和 $\\alpha$ 计算先验概率。\n\n首先，让我们根据给定的 $PL$ 值确定相对似然。定义是 $PL_g = -10 \\log_{10}\\left(L(D \\mid g)/ L_{\\max}\\right)$，其中 $L_{\\max} = \\max_{h} L(D \\mid h)$。整理这个公式得到：\n$$\\frac{L(D \\mid g)}{L_{\\max}} = 10^{-PL_g/10}$$\n给定的 $PL$ 值为 $PL_{0/0} = 80$，$PL_{0/1} = 0$，和 $PL_{1/1} = 40$。$PL=0$ 的基因型是似然最大的那个，所以 $L_{\\max} = L(D \\mid 0/1)$。相对似然为：\n-   对于 $g=0/0$: $\\frac{L(D \\mid 0/0)}{L_{\\max}} = 10^{-80/10} = 10^{-8}$\n-   对于 $g=0/1$: $\\frac{L(D \\mid 0/1)}{L_{\\max}} = 10^{-0/10} = 10^0 = 1$\n-   对于 $g=1/1$: $\\frac{L(D \\mid 1/1)}{L_{\\max}} = 10^{-40/10} = 10^{-4}$\n\n接下来，我们使用 $O = 10^{-3}$ 和 $\\alpha = 0.9$ 计算先验概率：\n-   $P(0/0) = \\frac{1}{1+O} = \\frac{1}{1+10^{-3}}$\n-   $P(0/1) = \\alpha \\frac{O}{1+O} = 0.9 \\times \\frac{10^{-3}}{1+10^{-3}}$\n-   $P(1/1) = (1-\\alpha) \\frac{O}{1+O} = (1-0.9) \\frac{10^{-3}}{1+10^{-3}} = 0.1 \\times \\frac{10^{-3}}{1+10^{-3}}$\n\n现在我们将这些代入 $P(g=0/0 \\mid D)$ 的表达式中。注意似然中的 $L_{\\max}$ 项和先验中的 $\\frac{1}{1+O}$ 项将从分子和分母中约去。我们可以使用与似然成比例的项 $L'_g = L(D \\mid g)/L_{max}$ 和与先验成比例的项 $P'(g) = P(g)(1+O)$ 来进行计算。\n-   $L'_{0/0} = 10^{-8}$, $L'_{0/1} = 1$, $L'_{1/1} = 10^{-4}$\n-   $P'(0/0) = 1$, $P'(0/1) = \\alpha O = 0.9 \\times 10^{-3}$, $P'(1/1) = (1-\\alpha)O = 0.1 \\times 10^{-3}$\n\n后验概率是：\n$$P(g=0/0 \\mid D) = \\frac{L'_{0/0} P'(0/0)}{L'_{0/0} P'(0/0) + L'_{0/1} P'(0/1) + L'_{1/1} P'(1/1)}$$\n代入数值：\n$$P(g=0/0 \\mid D) = \\frac{10^{-8} \\times 1}{(10^{-8} \\times 1) + (1 \\times 0.9 \\times 10^{-3}) + (10^{-4} \\times 0.1 \\times 10^{-3})}$$\n$$P(g=0/0 \\mid D) = \\frac{10^{-8}}{10^{-8} + 9 \\times 10^{-4} + 10^{-8}}$$\n$$P(g=0/0 \\mid D) = \\frac{10^{-8}}{9 \\times 10^{-4} + 2 \\times 10^{-8}}$$\n为简化计算，从分母中提出 $10^{-4}$：\n$$P(g=0/0 \\mid D) = \\frac{10^{-8}}{10^{-4} (9 + 2 \\times 10^{-4})} = \\frac{10^{-4}}{9 + 0.0002} = \\frac{10^{-4}}{9.0002}$$\n\n最后，我们计算 $Q$：\n$$Q = -10 \\log_{10} \\left( \\frac{10^{-4}}{9.0002} \\right)$$\n利用对数性质 $\\log_{10}(a/b) = \\log_{10}(a) - \\log_{10}(b)$：\n$$Q = -10 \\left( \\log_{10}(10^{-4}) - \\log_{10}(9.0002) \\right)$$\n$$Q = -10 \\left( -4 - \\log_{10}(9.0002) \\right)$$\n$$Q = 40 + 10 \\log_{10}(9.0002)$$\n使用计算器，$\\log_{10}(9.0002) \\approx 0.95425143$。\n$$Q \\approx 40 + 10 \\times (0.95425143)$$\n$$Q \\approx 40 + 9.5425143$$\n$$Q \\approx 49.5425143$$\n\n题目要求将结果四舍五入到四位有效数字。\n$$Q \\approx 49.54$$",
            "answer": "$$\\boxed{49.54}$$"
        },
        {
            "introduction": "在评估单个变异的质量之后，我们需要评估整个变异检出集（call set）的整体质量。转换/颠换比（Ti/Tv ratio）是实现这一目标的一个强大、高层次的汇总统计量。本练习将指导你计算Ti/Tv比率，更重要的是，学会将其数值解读为数据质量的标志或潜在生物学富集的迹象。",
            "id": "4617272",
            "problem": "一个变异检出集由人类全基因组测序（平均覆盖度为 $30\\times$）生成，并经过筛选，只包含高置信度的双等位基因单核苷酸变异 (SNV)。插入和缺失 (indel) 及多等位基因位点均被排除。在单链、有向的表示法中，观测到的参考碱基到替换碱基变化的计数如下：\n\n- $A \\rightarrow G$: $850{,}250$\n- $G \\rightarrow A$: $845{,}700$\n- $C \\rightarrow T$: $832{,}400$\n- $T \\rightarrow C$: $838{,}100$\n- $A \\rightarrow C$: $220{,}500$\n- $C \\rightarrow A$: $222{,}300$\n- $A \\rightarrow T$: $180{,}200$\n- $T \\rightarrow A$: $179{,}800$\n- $C \\rightarrow G$: $215{,}400$\n- $G \\rightarrow C$: $216{,}100$\n- $G \\rightarrow T$: $230{,}600$\n- $T \\rightarrow G$: $231{,}300$\n\n根据基本定义，转换 (transition) 是指嘌呤到嘌呤或嘧啶到嘧啶的替换 ($A \\leftrightarrow G$ 和 $C \\leftrightarrow T$)，而颠换 (transversion) 是指嘌呤到嘧啶或嘧啶到嘌呤的替换（其余四种碱基对类型）。将每个有向计数视为一个观测到的 SNV，并假设链对称性不改变其分类。\n\n- 计算该检出集的转换/颠换比率 (Ti/Tv)，即转换总数与颠换总数的比值。最终答案以无量纲比率表示，并四舍五入到四位有效数字。\n\n- 接着，从人类遗传学中经过充分检验的观察结果出发——即典型的全基因组 Ti/Tv 约为 $2.0$，而编码区的 Ti/Tv 约为 $3.0$（由于针对颠换型非同义改变的纯化选择）——解释观测到的 Ti/Tv 与这些预期值的偏差如何能表明质量问题（例如，过多的测序或比对错误）或编码区的富集。",
            "solution": "该问题要求根据一组给定的单核苷酸变异 (SNV) 计数来计算转换/颠换 (Ti/Tv) 比率，并随后解释该比率作为基因组学中质量控制指标的重要性。\n\n首先，我们必须将给定的 SNV 类型分为转换或颠换。四种核苷酸碱基可分为两类化学基团：嘌呤，具有双环结构 ($A$, $G$)；嘧啶，具有单环结构 ($C$, $T$)。\n**转换 (transition)** 是指在同一化学基团内部的替换：\n- 嘌呤到嘌呤：$A \\leftrightarrow G$\n- 嘧啶到嘧啶：$C \\leftrightarrow T$\n\n**颠换 (transversion)** 是指在不同化学基团之间的替换：\n- 嘌呤到嘧啶：$A \\leftrightarrow C$、$A \\leftrightarrow T$、$G \\leftrightarrow C$、$G \\leftrightarrow T$\n- 嘧啶到嘌呤：$C \\leftrightarrow A$、$C \\leftrightarrow G$、$T \\leftrightarrow A$、$T \\leftrightarrow G$\n\n题目为每种 SNV 类型提供了以下有向计数：\n- $N_{A \\rightarrow G} = 850,250$ (转换)\n- $N_{G \\rightarrow A} = 845,700$ (转换)\n- $N_{C \\rightarrow T} = 832,400$ (转换)\n- $N_{T \\rightarrow C} = 838,100$ (转换)\n- $N_{A \\rightarrow C} = 220,500$ (颠换)\n- $N_{C \\rightarrow A} = 222,300$ (颠换)\n- $N_{A \\rightarrow T} = 180,200$ (颠换)\n- $N_{T \\rightarrow A} = 179,800$ (颠换)\n- $N_{C \\rightarrow G} = 215,400$ (颠换)\n- $N_{G \\rightarrow C} = 216,100$ (颠换)\n- $N_{G \\rightarrow T} = 230,600$ (颠换)\n- $N_{T \\rightarrow G} = 231,300$ (颠换)\n\n转换总数，记为 $N_{Ti}$，是所有转换类型替换的总和。\n$$N_{Ti} = N_{A \\rightarrow G} + N_{G \\rightarrow A} + N_{C \\rightarrow T} + N_{T \\rightarrow C}$$\n$$N_{Ti} = 850,250 + 845,700 + 832,400 + 838,100 = 3,366,450$$\n\n颠换总数，记为 $N_{Tv}$，是所有颠换类型替换的总和。\n$$N_{Tv} = N_{A \\rightarrow C} + N_{C \\rightarrow A} + N_{A \\rightarrow T} + N_{T \\rightarrow A} + N_{C \\rightarrow G} + N_{G \\rightarrow C} + N_{G \\rightarrow T} + N_{T \\rightarrow G}$$\n$$N_{Tv} = 220,500 + 222,300 + 180,200 + 179,800 + 215,400 + 216,100 + 230,600 + 231,300$$\n$$N_{Tv} = 1,696,200$$\n\n转换/颠换比率，$R_{Ti/Tv}$，是转换总数与颠换总数的比值。\n$$R_{Ti/Tv} = \\frac{N_{Ti}}{N_{Tv}} = \\frac{3,366,450}{1,696,200}$$\n$$R_{Ti/Tv} \\approx 1.984700035...$$\n\n根据题目要求将结果四舍五入到四位有效数字，我们得到：\n$$R_{Ti/Tv} \\approx 1.985$$\n\n问题的第二部分要求解释观测到的 Ti/Tv 比率与预期值的偏差如何能表明质量问题或生物学背景。计算出的比率约为 $1.985$，非常接近人类全基因组测序 (WGS) 的公认基准（通常在 $2.0$ 左右）。这种接近性表明，所提供的变异检出集质量很高，并且代表了一个未富集的、全基因组范围的样本。\n\nTi/Tv 比率的重要性源于生物学和技术两方面因素：\n- **生物学基础**：由于核苷酸碱基的化学性质和自发突变的特性（例如，甲基化胞嘧啶脱氨基为胸腺嘧啶，这是一种常见的 $C \\rightarrow T$ 转换），转换在基因组中比颠换更频繁地出现。颠换在结构上更具破坏性（用单环碱基替换双环碱基，或反之），这使得它们如果落在功能性基因组元件中，更有可能是有害的。\n- **质量控制**：与预期 Ti/Tv 比率的偏差是变异检出集的一个关键质量控制指标。\n    1.  **低的 Ti/Tv 比率（例如，对于 WGS 显著低于 $2.0$）** 是随机错误的强烈指标。如果碱基替换是完全随机发生的，那么每个嘌呤或嘧啶都有两种可能的颠换结果，但只有一种可能的转换结果。这导致转换与颠换的比率为 $1:2$，即随机噪声的理论 Ti/Tv 比率为 $0.5$。因此，过多的假阳性变异检出（通常本质上是随机的，源于测序错误、比对假象等）会不成比例地增加颠换的数量，从而将总 Ti/Tv 比率拉低至 $0.5$。低的 Ti/Tv 比率是一个危险信号，表明检出集可能有高错误率，且变异过滤阈值可能过于宽松。\n    2.  **高的 Ti/Tv 比率（例如，接近 $3.0$）** 通常表明特定基因组区域的富集，特别是编码序列（外显子）。在蛋白质编码区内，自然选择作用于保留功能。颠换比转换更有可能导致非同义氨基酸替换，且这些替换在功能上可能更激进（例如，改变氨基酸的化学类别）。因此，纯化选择在编码区中更强烈地作用于排除颠换。这种差异性选择压力导致外显子组中观测到更高的 Ti/Tv 比率，通常在 $3.0$ 左右。在一个声称来自 WGS 的数据集中出现意料之外的高 Ti/Tv 比率，可能表明测序文库无意中偏向于捕获外显子区域。\n\n总之，Ti/Tv 比率是一个强大的汇总统计量。此处计算出的值 ($1.985$) 反映了一个高质量的 WGS 数据集。较低的值可能表明存在随机错误的污染，而显著较高的值则表明在编码区存在富集，其中纯化选择提高了该比率。",
            "answer": "$$\\boxed{1.985}$$"
        },
        {
            "introduction": "在对变异质量进行了个体和整体的量化之后，最后一步是应用过滤器。我们不应使用任意的“神奇数字”作为阈值，一种统计上更严谨的方法是控制假阳性发现率（False Discovery Rate, FDR）。本练习提供了一个动手编程任务，要求你实现一个算法，以找到能够达到目标FDR的最优质量阈值，从而在灵敏度和特异性之间取得平衡。",
            "id": "4617237",
            "problem": "给定一组来自全基因组分析的单核苷酸多态性（SNP）和插入缺失（indel）候选变异的检出集。每个检出都有一个关联的 Phred-like 变异质量分数 $QUAL$，以及一个布尔指标，用于指示该检出是否位于用于基准测试的独立验证的真实区域内。目标是从第一性原理出发，推导出一个关于 $QUAL$ 的阈值规则，在最大化保留检出数量的同时，将假发现率（FDR）控制在目标值或以下，然后将其实现为一个程序，为指定的测试套件计算结果。\n\n基本原理和定义：\n- Phred 量表将质量值 $Q$ 解释为错误可能性的单调变换，在基因组学中广泛用于按置信度对变异检出进行排序。不假定任何特定的校准；仅假定较高的 $Q$ 相对于较低的 $Q$ 不应降低其正确性的合理性。\n- 在统计假设检验中，假发现率（FDR）定义为所有发现中假发现的预期比例。在一个适用于对真实集进行基准测试的有限计数近似中，对于给定的 $QUAL$ 阈值 $\\tau$ 定义如下：\n  - 设数据集由 $n$ 个检出组成，索引为 $i \\in \\{1,\\dots,n\\}$。\n  - 设 $Q_i$ 为检出 $i$ 的 $QUAL$ 值。\n  - 设 $B_i \\in \\{0,1\\}$ 指示是否属于真实区域，其中 $B_i=1$ 表示检出位于真实区域内（可视为真阳性候选的代理），$B_i=0$ 表示检出位于真实区域外（可视为假阳性候选的代理）。\n  - 通过包含性规则保留检出：当且仅当 $Q_i \\ge \\tau$ 时，检出 $i$ 被保留。\n  - 设 $S(\\tau)=\\{i \\mid Q_i \\ge \\tau\\}$ 为保留的检出集合。\n  - 定义保留的假阳性为 $FP(\\tau) = \\sum_{i \\in S(\\tau)} (1 - B_i)$。\n  - 定义保留的真阳性为 $TP(\\tau) = \\sum_{i \\in S(\\tau)} B_i$。\n  - 定义在阈值 $\\tau$ 下的有限样本 FDR 为\n    $$\\mathrm{FDR}(\\tau) = \\begin{cases}\n    \\dfrac{FP(\\tau)}{FP(\\tau) + TP(\\tau)}  \\text{if } FP(\\tau) + TP(\\tau) > 0, \\\\\n    0  \\text{if } FP(\\tau) + TP(\\tau) = 0,\n    \\end{cases}$$\n    当没有保留的检出时，此定义将 FDR 设为 $0$（没有发现意味着没有假发现）。\n- 在目标 FDR $t$ 下的最优阈值是满足 $\\mathrm{FDR}(\\tau) \\le t$ 的最小 $\\tau$，使用包含性 $QUAL$ 过滤器 $Q_i \\ge \\tau$。最小化原则通过在满足 FDR 约束的条件下保留尽可能多的检出，从而提高灵敏度。\n\n算法要求：\n- 考虑由 $\\{Q_i\\}$ 的排序后唯一值给出的候选阈值，记为 $\\tau \\in \\mathcal{T} = \\{\\text{sorted unique }Q_i\\}$。在包含性规则 $Q_i \\ge \\tau$ 下，这些候选阈值枚举了所有不同的保留集 $S(\\tau)$。\n- 如果没有 $\\tau \\in \\mathcal{T}$ 满足 $\\mathrm{FDR}(\\tau) \\le t$，则定义一个后备阈值\n  $$\\tau^\\mathrm{fallback} = \\max_i(Q_i) + \\epsilon,$$\n  其中 $\\epsilon = 10^{-6}$，这将得到 $S(\\tau^\\mathrm{fallback}) = \\emptyset$，因此 $\\mathrm{FDR}(\\tau^\\mathrm{fallback}) = 0$ 且保留的检出数为 $0$。\n- 最优阈值为\n  $$\\tau^\\ast = \\begin{cases}\n  \\min\\{\\tau \\in \\mathcal{T} \\mid \\mathrm{FDR}(\\tau) \\le t\\}  \\text{若该集合非空}, \\\\\n  \\tau^\\mathrm{fallback}  \\text{否则}.\n  \\end{cases}$$\n\n任务：\n- 实现一个程序，对于每个测试用例，计算 $\\tau^\\ast$、$\\mathrm{FDR}(\\tau^\\ast)$ 和保留的检出计数 $\\lvert S(\\tau^\\ast) \\rvert$。\n- 精确地按照上述定义使用包含性过滤器 $Q_i \\ge \\tau$。\n- 将 $\\tau^\\ast$ 和 $\\mathrm{FDR}(\\tau^\\ast)$ 四舍五入到 $6$ 位小数；保留的检出计数必须是整数。\n\n测试套件：\n在以下测试用例上评估您的程序。每个测试用例由一个 $QUAL$ 值列表、一个对应的真实区域指标 $B_i$ 列表以及一个目标 FDR $t$（以小数形式表示）指定。\n\n- 案例 $1$（一般非单调场景）：\n  - $QUAL$: $\\{12,18,35,42,60,75,90,25,55,40\\}$\n  - $B$: $\\{0,0,1,1,1,1,0,1,1,0\\}$\n  - 目标 $t$: $0.3$\n- 案例 $2$（所有保留的检出都在真实区域内）：\n  - $QUAL$: $\\{5,10,20,40\\}$\n  - $B$: $\\{1,1,1,1\\}$\n  - 目标 $t$: $0.0$\n- 案例 $3$（除排除所有检出外没有可接受的阈值）：\n  - $QUAL$: $\\{30,60,90\\}$\n  - $B$: $\\{0,0,0\\}$\n  - 目标 $t$: $0.0$\n- 案例 $4$（阈值处存在平局，包含性保留）：\n  - $QUAL$: $\\{20,20,50,50,50\\}$\n  - $B$: $\\{0,1,0,1,1\\}$\n  - 目标 $t$: $0.35$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例的结果本身必须是 $[\\tau^\\ast,\\mathrm{FDR}(\\tau^\\ast),\\lvert S(\\tau^\\ast) \\rvert]$ 形式的列表，其中 $\\tau^\\ast$ 和 $\\mathrm{FDR}(\\tau^\\ast)$ 四舍五入到 $6$ 位小数，$\\lvert S(\\tau^\\ast) \\rvert$ 为整数。\n- 例如，整体输出应如下所示：\n  $$[[\\tau^\\ast_1,\\mathrm{FDR}(\\tau^\\ast_1),\\lvert S(\\tau^\\ast_1)\\rvert],[\\tau^\\ast_2,\\mathrm{FDR}(\\tau^\\ast_2),\\lvert S(\\tau^\\ast_2)\\rvert],\\dots].$$",
            "solution": "该问题要求推导并实现一个算法，用于确定过滤基因组变异检出的最优质量分数阈值。优化目标是在将假发现率（FDR）控制在指定目标水平 $t$ 或以下的同时，最大化保留的检出数量（即最大化灵敏度）。\n\n该框架基于FDR的有限样本近似，此近似是使用基准集计算得出的。数据集包含 $n$ 个检出，每个检出 $i$ 都有一个质量分数 $Q_i$ 和一个二元指标 $B_i$。$B_i=1$ 表示该检出位于可信的“真实”区域内（真阳性的代理），而 $B_i=0$ 则表示它在该区域之外（假阳性的代理）。核心假设是 $Q_i$ 是一个Phred-like分数，意味着它与检出的置信度单调相关；较高的 $Q_i$ 意味着更可靠的检出。\n\n当检出 $i$ 的质量分数 $Q_i$ 大于或等于给定阈值 $\\tau$ 时（即 $Q_i \\ge \\tau$），该检出被保留。保留的检出集合表示为 $S(\\tau) = \\{i \\mid Q_i \\ge \\tau\\}$。对于此集合，我们可以计算保留的真阳性数量 $TP(\\tau) = \\sum_{i \\in S(\\tau)} B_i$ 和保留的假阳性数量 $FP(\\tau) = \\sum_{i \\in S(\\tau)} (1 - B_i)$。保留的检出总数（或发现数）为 $|S(\\tau)| = TP(\\tau) + FP(\\tau)$。\n\n对于阈值 $\\tau$，有限样本FDR定义为所有保留检出中假阳性的比例：\n$$\n\\mathrm{FDR}(\\tau) = \\begin{cases}\n\\dfrac{FP(\\tau)}{FP(\\tau) + TP(\\tau)}  \\text{if } FP(\\tau) + TP(\\tau) > 0, \\\\\n0  \\text{if } FP(\\tau) + TP(\\tau) = 0.\n\\end{cases}\n$$\n分母为 $0$ 的情况意味着没有检出被保留，因此没有做出任何发现，也就没有假发现。\n\n目标是找到一个最优阈值 $\\tau^\\ast$。为了在满足约束 $\\mathrm{FDR}(\\tau) \\le t$ 的前提下最大化保留的检出数量（灵敏度），我们应该选择满足该条件的、最不严格（即最小）的阈值，因为较低的阈值会保留更多的检出。\n\n保留的检出集合 $S(\\tau)$ 仅在阈值 $\\tau$ 穿过其中一个质量分数值 $Q_i$ 时才会发生变化。因此，我们只需要考虑将唯一的 $Q_i$ 值作为候选阈值。设 $\\mathcal{T}$ 为唯一的质量分数集合，按升序排列：$\\mathcal{T} = \\{\\tau_1, \\tau_2, \\dots, \\tau_k\\}$，其中 $\\tau_1 < \\tau_2 < \\dots < \\tau_k$。\n\n寻找最优阈值 $\\tau^\\ast$ 的算法如下：\n\n1.  **识别候选阈值**：从数据集中提取所有唯一的质量分数 $\\{Q_i\\}$，并按升序排序，形成候选阈值集合 $\\mathcal{T}$。\n\n2.  **迭代搜索**：从最小的 $\\tau_1$ 开始，遍历候选阈值 $\\tau_j \\in \\mathcal{T}$。对于每个 $\\tau_j$：\n    a.  定义保留的检出集合 $S(\\tau_j) = \\{i \\mid Q_i \\ge \\tau_j\\}$。由于采用包含性不等式，所有质量等于 $\\tau_j$ 的检出都包括在内。\n    b.  计算保留的假阳性数量 $FP(\\tau_j) = \\sum_{i \\in S(\\tau_j)} (1-B_i)$ 和保留的检出总数 $|S(\\tau_j)|$。\n    c.  使用上述定义计算FDR，即 $\\mathrm{FDR}(\\tau_j)$。\n    d.  检查是否满足FDR约束：$\\mathrm{FDR}(\\tau_j) \\le t$。\n    e.  如果满足约束，我们便找到了最优阈值。因为我们是按阈值从小到大的顺序遍历的，所以第一个满足条件的阈值就是我们要找的最小阈值。设 $\\tau^\\ast = \\tau_j$，然后停止搜索。记录相应的 $\\mathrm{FDR}(\\tau^\\ast)$ 和 $|S(\\tau^\\ast)|$ 值。\n\n3.  **后备机制**：如果遍历完所有候选阈值后，仍没有 $\\tau_j \\in \\mathcal{T}$ 满足条件 $\\mathrm{FDR}(\\tau_j) \\le t$，这意味着没有任何非平凡的过滤能满足目标FDR。在这种情况下，问题指定了一个后备规则来严格满足FDR约束，代价是完全牺牲灵敏度。阈值被设置为一个保证拒绝所有检出的值：\n    $$ \\tau^\\ast = \\tau^\\mathrm{fallback} = \\max_i(Q_i) + \\epsilon $$\n    其中 $\\epsilon$ 是一个小的正常数，给定为 $10^{-6}$。对于此阈值，保留的检出集合 $S(\\tau^\\ast)$ 为空。因此， $|S(\\tau^\\ast)| = 0$，并且根据定义，$\\mathrm{FDR}(\\tau^\\ast) = 0$。\n\n对于任何给定的数据集和目标FDR $t$，此过程保证能找到一个唯一的最优阈值 $\\tau^\\ast$。为了提高计算效率，特别是在处理大型数据集时，可以先按质量分数对检出进行预排序，然后使用 $B_i$ 和 $(1-B_i)$ 的累积和来计算，这比为每个阈值重新扫描整个数据集性能更高。然而，对于指定的测试用例，直接实现上述逻辑已足够。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the optimal quality threshold based on FDR control for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"QUAL\": [12, 18, 35, 42, 60, 75, 90, 25, 55, 40],\n            \"B\": [0, 0, 1, 1, 1, 1, 0, 1, 1, 0],\n            \"t\": 0.3\n        },\n        {\n            \"QUAL\": [5, 10, 20, 40],\n            \"B\": [1, 1, 1, 1],\n            \"t\": 0.0\n        },\n        {\n            \"QUAL\": [30, 60, 90],\n            \"B\": [0, 0, 0],\n            \"t\": 0.0\n        },\n        {\n            \"QUAL\": [20, 20, 50, 50, 50],\n            \"B\": [0, 1, 0, 1, 1],\n            \"t\": 0.35\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        quals = np.array(case[\"QUAL\"], dtype=float)\n        bs = np.array(case[\"B\"], dtype=int)\n        target_fdr = case[\"t\"]\n        \n        if quals.size == 0:\n            all_results.append([1.0e-6, 0.0, 0])\n            continue\n\n        candidate_thresholds = np.unique(quals) # Already sorted in ascending order\n\n        found_solution = False\n        for tau in candidate_thresholds:\n            # Inclusive filter: retain if quality is greater than or equal to tau\n            retained_mask = quals >= tau\n            \n            retained_count = np.sum(retained_mask)\n\n            if retained_count == 0:\n                fdr = 0.0\n            else:\n                retained_bs = bs[retained_mask]\n                fp_count = np.sum(retained_bs == 0)\n                fdr = fp_count / retained_count\n\n            if fdr = target_fdr:\n                opt_tau = tau\n                opt_fdr = fdr\n                opt_count = int(retained_count)\n                found_solution = True\n                break\n\n        if not found_solution:\n            # Fallback case: no threshold met the criteria\n            epsilon = 1e-6\n            opt_tau = np.max(quals) + epsilon\n            opt_fdr = 0.0\n            opt_count = 0\n\n        all_results.append([opt_tau, opt_fdr, opt_count])\n\n    # Format the final output string exactly as required\n    formatted_results = [\n        f\"[{r[0]:.6f},{r[1]:.6f},{r[2]}]\" for r in all_results\n    ]\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}