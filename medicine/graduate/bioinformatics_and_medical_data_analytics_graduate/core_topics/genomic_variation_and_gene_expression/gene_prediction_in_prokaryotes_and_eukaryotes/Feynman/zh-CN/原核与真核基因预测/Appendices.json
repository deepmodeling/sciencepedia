{
    "hands_on_practices": [
        {
            "introduction": "基因预测的核心挑战之一是区分编码区和非编码区。此实践将指导您从头开始构建一个基于马尔可夫模型的分类器，这是一种在原核生物基因预测中广泛使用的基本方法。通过计算对数似然比（LLR），您将学习如何量化一段DNA序列是编码序列而非非编码序列的证据强度，并基于统计学原理设定决策阈值。",
            "id": "4567054",
            "problem": "给定您用于原核和真核生物环境的脱氧核糖核酸（DNA）序列训练集，这些序列被标记为编码和非编码。目标是使用带有加性平滑的$k$阶马尔可夫模型对查询序列进行评分，计算编码模型和非编码模型之间的对数似然比（LLR；log-likelihood ratio）分数，并使用一个非编码序列的验证集来确定一个决策阈值，以达到目标假阳性率（FPR；false positive rate）。您的程序必须仅从基本原理出发实现以下内容：分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质），编码区由于密码子结构和选择而表现出短程成分和周期性偏差的观察，以及马尔可夫假设，即局部依赖性可以通过核苷酸字母表上的有限阶链来近似。从这些基础出发，通过计数带有加性平滑的$(k+1)$-mers来推导条件发射概率的估计，并通过对查询序列上条件概率比率的对数求和来计算LLR。然后，使用非编码序列验证集上的分数经验分布，选择一个满足目标FPR约束的分类阈值。不要假设任何不能从所述基础推导出的公式；请用数学方式证明每一步。\n\n您的程序应使用的定义和约定：\n- 字母表为 $\\mathcal{A}=\\{A,C,G,T\\}$。任何其他字符对于本问题均无效。\n- 对于一个$k$阶马尔可夫模型，其中$k \\in \\{0,1,2,\\dots\\}$，在给定长度为$k$的上下文$c \\in \\mathcal{A}^k$的情况下，观察到碱基$b \\in \\mathcal{A}$的条件概率，是通过计算所有训练序列中$(c,b)$的出现次数并应用伪计数为$\\alpha \\in \\mathbb{R}_{>0}$的加性平滑来估计的。\n- 对于一个查询序列$x=x_0 x_1 \\dots x_{n-1}$，LLR分数是从位置$i=k$到$n-1$的编码模型条件概率与非编码模型条件概率之比的自然对数之和，每个概率都以$x_{i-k} \\dots x_{i-1}$为条件上下文。只有序列内部具有完整$k$长度上下文的位置才会被评分。\n- 在一个阈值$\\theta \\in \\mathbb{R}$处的经验FPR，在一个非编码序列验证集上进行评估，定义为LLR分数大于或等于$\\theta$的非编码验证序列所占的比例。为了直接从数据中产生一个确定性的、有限的阈值，将$\\theta$限制在非编码验证序列上观察到的不同分数的集合中，并选择其中满足经验FPR小于或等于目标的最大$\\theta^\\star$。如果因为目标小于经验FPR中可实现的最小正增量而导致不存在这样的$\\theta$，则此测试用例是病态的；所提供的测试套件通过构造避免了这种情况。\n\n您的程序必须处理以下测试套件。对于每个测试用例，非编码训练集同时作为阈值选择的验证集，以确保在给定约束下的可复现性。\n\n- 测试用例1（类原核生物成分差异，1阶）：\n  - 编码训练集：$[\\text{ATGAAATTTGAA}, \\text{ATGCCCAAAGGGTTT}, \\text{ATGAAAGGGAAGTAG}]$。\n  - 非编码训练与验证集：$[\\text{TATTTAATTAAT}, \\text{GGATTTTAATTA}, \\text{TAATAATATATT}, \\text{TTAATAAATATA}]$。\n  - 查询序列：$\\text{ATGAAAGTTGA}$。\n  - 马尔可夫阶数：$k=1$。\n  - 平滑伪计数：$\\alpha=0.5$。\n  - 目标FPR：$t=0.25$。\n\n- 测试用例2（通过平滑处理未见上下文的边缘情况，2阶）：\n  - 编码训练集：$[\\text{GCGCGCGCGC}, \\text{GCCGCGCCGC}]$。\n  - 非编码训练与验证集：$[\\text{ATATATATAT}, \\text{TATATATATA}, \\text{AAATTTAAAT}]$。\n  - 查询序列：$\\text{GCGATCGCGC}$。\n  - 马尔可夫阶数：$k=2$。\n  - 平滑伪计数：$\\alpha=0.1$。\n  - 目标FPR：$t=0.3333333333333333$。\n\n- 测试用例3（零阶模型作为基线，0阶）：\n  - 编码训练集：$[\\text{ATGGCC}, \\text{ATGGCG}, \\text{ATGGGC}, \\text{ATGGCCATG}]$。\n  - 非编码训练与验证集：$[\\text{AAAAAA}, \\text{TTTTTT}, \\text{AATTAA}, \\text{TTAAAT}]$。\n  - 查询序列：$\\text{ATGGCCG}$。\n  - 马尔可夫阶数：$k=0$。\n  - 平滑伪计数：$\\alpha=1.0$。\n  - 目标FPR：$t=0.5$。\n\n输出要求：\n- 对于每个测试用例，计算：\n  - 查询序列在编码模型与非编码模型下的LLR分数 $s \\in \\mathbb{R}$。\n  - 根据上述规定从验证非编码分数中确定的阈值 $\\theta^\\star \\in \\mathbb{R}$。\n  - 一个二元决策 $d \\in \\{0,1\\}$，其中如果 $s \\ge \\theta^\\star$ 则 $d=1$，否则 $d=0$。\n- 将所有实值输出 $s$ 和 $\\theta^\\star$ 在最终输出中四舍五入到恰好$6$位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是一个测试用例的三元组，格式为$[s,\\theta^\\star,d]$。例如，一个有效的整体输出结构看起来像$[[s_1,\\theta^\\star_1,d_1],[s_2,\\theta^\\star_2,d_2],[s_3,\\theta^\\star_3,d_3]]$，其中每个$s_i$和$\\theta^\\star_i$都四舍五入到$6$位小数，每个$d_i$都是一个整数。",
            "solution": "所提出的问题是统计生物信息学领域一个有效且适定的练习，特别是在*从头*基因预测（*de novo* gene prediction）领域。解决方案基于分子生物学和统计建模的基本原理，我们将逐步推导和形式化这些原理。\n\n这个问题的生物学基础是分子生物学的中心法则，它描述了遗传信息从DNA流向核糖核酸（RNA）再到蛋白质的过程。DNA的蛋白质编码区（基因）被转录并使用三联体密码翻译成蛋白质，其中称为密码子的$3$个核苷酸序列指定氨基酸。这个过程在编码序列上施加了特定的统计模式，而这些模式通常不存在于非编码区域。这些模式包括周期为3的核苷酸组成偏好和对同一氨基酸的某些密码子的偏好使用（密码子使用偏好）。这些组成偏好使我们能够从统计上区分编码DNA和非编码DNA。\n\n问题建议使用一个平稳的$k$阶马尔可夫模型来捕捉这些局部的成分依赖性。一个在字母表$\\mathcal{A}=\\{A,C,G,T\\}$上的DNA序列$x=x_0 x_1 \\dots x_{n-1}$被建模为马尔可夫链的一个实现。$k$阶模型的核心假设是，在给定位置观察到一个核苷酸的概率仅取决于前面的$k$个核苷酸。这个长度为$k$的上下文是序列$c = x_{i-k} \\dots x_{i-1}$。在数学上，这表示为：\n$$ P(x_i | x_0 x_1 \\dots x_{i-1}) = P(x_i | x_{i-k} \\dots x_{i-1}) = P(x_i | c) $$\n对于阶数$k=0$的特殊情况，模型是无记忆的，观察到一个核苷酸的概率与任何上下文无关：$P(x_i | c) = P(x_i)$。\n\n第一步是训练两个独立的马尔可夫模型：一个用于编码序列（$M_{cod}$），一个用于非编码序列（$M_{non}$）。训练包括为每个模型估计条件概率参数$P(b|c)$，其中$b \\in \\mathcal{A}$是一个核苷酸，$c \\in \\mathcal{A}^k$是一个上下文。概率是通过计算连接起来的训练数据中$(k+1)$-mer $cb$和$k$-mer $c$的出现次数来估计的。设$N(cb)$为$(k+1)$-mer的计数，$N(c)$为$k$-mer上下文的计数。为了防止在有限训练集中未见过的事件概率为$0$，我们采用带有伪计数$\\alpha > 0$的加性（Lidstone）平滑。平滑后的条件概率估计为：\n$$ P(b|c) = \\frac{N(cb) + \\alpha}{N(c) + |\\mathcal{A}|\\alpha} $$\n其中$|\\mathcal{A}|=4$是核苷酸字母表的大小。分母$N(c) + |\\mathcal{A}|\\alpha$是所有以上下文$c$开头的$(k+1)$-mers的计数总和，每个计数都增加了伪计数$\\alpha$。注意$N(c) = \\sum_{b' \\in \\mathcal{A}} N(cb')$。如果一个上下文$c$从未被观察到（$N(c)=0$），那么对于所有的$b$，$N(cb)=0$，平滑后的概率简化为$P(b|c) = \\frac{\\alpha}{|\\mathcal{A}|\\alpha} = \\frac{1}{|\\mathcal{A}|} = 0.25$，表示对下一个核苷酸的均匀信念。对于$k=0$，上下文为空，该公式估计了碱基$b$的边际概率：\n$$ P(b) = \\frac{N(b) + \\alpha}{N_{total} + |\\mathcal{A}|\\alpha} $$\n其中$N(b)$是碱基$b$的计数，$N_{total}$是训练数据中核苷酸的总数。\n\n一旦编码（$P_{cod}(b|c)$）和非编码（$P_{non}(b|c)$）模型都训练好了，我们就可以对一个查询序列$x=x_0 x_1 \\dots x_{n-1}$进行评分。问题要求计算对数似然比（LLR）分数。这个分数衡量了序列在两个竞争模型下的相对支持度。根据马尔可夫性质，联合概率的对数比率简化为在所有从$k$到$n-1$的位置上（即所有具有完整$k$长度上下文的位置）的条件概率对数比率之和：\n$$ S(x) = \\sum_{i=k}^{n-1} \\log \\frac{P_{cod}(x_i | x_{i-k} \\dots x_{i-1})}{P_{non}(x_i | x_{i-k} \\dots x_{i-1})} $$\n正分表示序列更可能是编码序列，而负分表示更可能是非编码序列。\n\n最后一步是确定用于分类的决策阈值$\\theta^\\star$。如果一个序列的分数$S(x) \\ge \\theta^\\star$，则它被分类为编码序列。选择阈值是为了控制假阳性率（FPR），即被错误分类为编码序列的非编码序列的比例。我们使用一个非编码序列的验证集来经验性地估计任何给定阈值$\\theta$的FPR。经验FPR是：\n$$ \\widehat{\\text{FPR}}(\\theta) = \\frac{\\text{分数 } \\ge \\theta \\text{ 的非编码验证序列数量}}{\\text{非编码验证序列总数}} $$\n问题指定了一个确定性程序，从验证集上观察到的不同分数集合中选择$\\theta^\\star$。我们必须找到最大的分数$\\theta^\\star$，使得$\\widehat{\\text{FPR}}(\\theta^\\star)$小于或等于目标FPR，$t$。为了实现这一点，我们可以计算所有非编码验证序列的LLR分数，识别出唯一的分数，并将它们按降序排序。然后我们遍历这个排序后的列表，第一个满足条件$\\widehat{\\text{FPR}}(\\theta) \\le t$的分数$\\theta$就是我们的最优阈值$\\theta^\\star$。\n\n完整的算法如下：\n$1$. 对于给定的测试用例，其参数为$k$和$\\alpha$：\n    a. 通过编码训练集计算所有概率$P_{cod}(b|c)$来训练编码模型$M_{cod}$。\n    b. 通过非编码训练集计算所有概率$P_{non}(b|c)$来训练非编码模型$M_{non}$。\n$2$. 对于非编码验证集中的每个序列：\n    a. 使用训练好的模型计算其LLR分数。\n$3$. 通过找到非编码分数集中能使经验FPR不大于目标$t$的最大分数来确定阈值$\\theta^\\star$。\n$4$. 对于查询序列：\n    a. 计算其LLR分数$s$。\n    b. 将分数与阈值进行比较以做出决策：如果$s \\ge \\theta^\\star$，则$d=1$，否则$d=0$。\n$5$. 报告三元组$[s, \\theta^\\star, d]$，其中实数四舍五入到$6$位小数。\n\n此过程为解决指定问题提供了一个完整且有科学依据的方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases for gene prediction modeling.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"coding_train\": ['ATGAAATTTGAA', 'ATGCCCAAAGGGTTT', 'ATGAAAGGGAAGTAG'],\n            \"noncoding_train\": ['TATTTAATTAAT', 'GGATTTTAATTA', 'TAATAATATATT', 'TTAATAAATATA'],\n            \"query\": 'ATGAAAGTTGA',\n            \"k\": 1,\n            \"alpha\": 0.5,\n            \"target_fpr\": 0.25,\n        },\n        {\n            \"coding_train\": ['GCGCGCGCGC', 'GCCGCGCCGC'],\n            \"noncoding_train\": ['ATATATATAT', 'TATATATATA', 'AAATTTAAAT'],\n            \"query\": 'GCGATCGCGC',\n            \"k\": 2,\n            \"alpha\": 0.1,\n            \"target_fpr\": 1/3,\n        },\n        {\n            \"coding_train\": ['ATGGCC', 'ATGGCG', 'ATGGGC', 'ATGGCCATG'],\n            \"noncoding_train\": ['AAAAAA', 'TTTTTT', 'AATTAA', 'TTAAAT'],\n            \"query\": 'ATGGCCG',\n            \"k\": 0,\n            \"alpha\": 1.0,\n            \"target_fpr\": 0.5,\n        }\n    ]\n\n    alphabet = ['A', 'C', 'G', 'T']\n    \n    def train_model(sequences, k, alpha):\n        \"\"\"\n        Trains an order-k Markov model with additive smoothing.\n\n        Args:\n            sequences (list[str]): A list of DNA training sequences.\n            k (int): The order of the Markov model.\n            alpha (float): The pseudocount for additive smoothing.\n\n        Returns:\n            dict: A dictionary representing the conditional probability table P(base|context).\n        \"\"\"\n        if k == 0:\n            # Handle the zero-order case (memoryless model)\n            counts = {base: 0 for base in alphabet}\n            total_bases = 0\n            for seq in sequences:\n                for base in seq:\n                    counts[base] += 1\n                total_bases += len(seq)\n            \n            probs = {}\n            # Context is empty for k=0\n            probs[''] = {base: (counts[base] + alpha) / (total_bases + len(alphabet) * alpha) for base in alphabet}\n            return probs\n\n        # Handle k > 0\n        kmer_counts = {} # (k+1)-mers\n        context_counts = {} # k-mers\n        \n        for seq in sequences:\n            for i in range(len(seq) - k):\n                context = seq[i:i+k]\n                kmer = seq[i:i+k+1]\n                \n                context_counts[context] = context_counts.get(context, 0) + 1\n                kmer_counts[kmer] = kmer_counts.get(kmer, 0) + 1\n        \n        # Generate all possible contexts\n        contexts = [''.join(p) for p in product(alphabet, repeat=k)]\n        \n        probs = {}\n        for context in contexts:\n            probs[context] = {}\n            n_c = context_counts.get(context, 0)\n            denominator = n_c + len(alphabet) * alpha\n            \n            for base in alphabet:\n                kmer = context + base\n                n_cb = kmer_counts.get(kmer, 0)\n                numerator = n_cb + alpha\n                probs[context][base] = numerator / denominator\n                \n        return probs\n\n    def calculate_llr(sequence, k, prob_cod, prob_non):\n        \"\"\"\n        Calculates the log-likelihood ratio (LLR) score for a query sequence.\n        \n        Args:\n            sequence (str): The query DNA sequence.\n            k (int): The order of the Markov model.\n            prob_cod (dict): The trained coding model probability table.\n            prob_non (dict): The trained noncoding model probability table.\n\n        Returns:\n            float: The LLR score.\n        \"\"\"\n        llr_score = 0.0\n        if len(sequence) = k:\n            return 0.0\n\n        for i in range(k, len(sequence)):\n            context = sequence[i-k:i] if k > 0 else ''\n            base = sequence[i]\n            \n            p_cod = prob_cod[context][base]\n            p_non = prob_non[context][base]\n            \n            llr_score += np.log(p_cod / p_non)\n            \n        return llr_score\n\n    def find_threshold(validation_sequences, k, prob_cod, prob_non, target_fpr):\n        \"\"\"\n        Determines the classification threshold based on a target FPR.\n        \n        Args:\n            validation_sequences (list[str]): A list of noncoding sequences for validation.\n            k (int): The order of the Markov model.\n            prob_cod (dict): The trained coding model.\n            prob_non (dict): The trained noncoding model.\n            target_fpr (float): The target False Positive Rate.\n        \n        Returns:\n            float: The determined threshold theta_star.\n        \"\"\"\n        scores = [calculate_llr(seq, k, prob_cod, prob_non) for seq in validation_sequences]\n        \n        unique_scores = sorted(list(set(scores)), reverse=True)\n        num_validation = len(validation_sequences)\n        \n        np_scores = np.array(scores)\n\n        for theta in unique_scores:\n            num_false_positives = np.sum(np_scores >= theta)\n            fpr = num_false_positives / num_validation\n            if fpr = target_fpr:\n                return theta\n        \n        # As per problem, a solution always exists.\n        # This case would handle if target FPR is smaller than the smallest possible step.\n        return float('inf')\n\n\n    results = []\n    for case in test_cases:\n        # 1. Train models\n        model_cod = train_model(case[\"coding_train\"], case[\"k\"], case[\"alpha\"])\n        model_non = train_model(case[\"noncoding_train\"], case[\"k\"], case[\"alpha\"])\n\n        # 2. Score query sequence\n        s = calculate_llr(case[\"query\"], case[\"k\"], model_cod, model_non)\n\n        # 3. Find threshold using noncoding sequences as validation set\n        theta_star = find_threshold(\n            case[\"noncoding_train\"], case[\"k\"], model_cod, model_non, case[\"target_fpr\"]\n        )\n\n        # 4. Make decision\n        d = 1 if s >= theta_star else 0\n        \n        results.append(f\"[{s:.6f},{theta_star:.6f},{d}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "与原核生物不同，真核生物的基因通常由多个外显子组成，中间被内含子隔开。基因预测程序不仅要识别外显子，还必须将它们正确地拼接成完整的转录本。本实践将引导您使用动态规划来解决这个经典的组合优化问题，即在众多候选的剪接信号中，找到一条得分最高的有效外显子链。",
            "id": "4567055",
            "problem": "给定沿单个基因组坐标轴的一组有限的候选剪接点。每个候选剪接点是由一对位置及其关联的实值分数组成。其生物学基础是，在真核生物的信使核糖核酸 (mRNA) 加工过程中，通过剪接掉内含子来连接外显子，其中每个内含子由一个供体位点和一个受体位点定义。分子生物学的中心法则指出，脱氧核糖核酸 (DNA) 转录为 mRNA，mRNA 再翻译成蛋白质。对于本问题，其形式化描述如下。\n\n定义与假设：\n- 一个候选剪接点 $j$ 由一个供体坐标 $d_j \\in \\mathbb{Z}$、一个受体坐标 $a_j \\in \\mathbb{Z}$ 和一个实值分数 $s_j \\in \\mathbb{R}$ 表示，其中 $d_j  a_j$。\n- 剪接点 $j$ 的内含子长度为 $L_j = a_j - d_j - 1$（被剪接掉的中间碱基的数量）。\n- 如果剪接点 $j$ 的长度满足 $L_{\\min} \\le L_j \\le L_{\\max}$，则称其在一对闭区间边界 $(L_{\\min}, L_{\\max}) \\in \\mathbb{Z} \\times \\mathbb{Z}$ 下是有效的。\n- 一条链（假定的剪接模式）是一个由不同有效剪接点索引组成的有序列表 $(j_1, j_2, \\dots, j_k)$，满足对所有 $t \\in \\{1,\\dots,k-1\\}$ 都有 $a_{j_t}  d_{j_{t+1}}$。此条件确保内含子不重叠，且内含子之间的外显子长度为非负。链的分数是 $\\sum_{t=1}^{k} s_{j_t}$。\n- 空链（$k=0$）的分数为 $0$。\n\n任务：\n- 针对每个给定的测试用例，计算一个使链分数最大化的链。如果多个链的分数并列最高，按以下顺序应用确定性决胜规则：\n  1. 优先选择剪接点数量 $k$ 较少的链。\n  2. 如果仍然平局，优先选择逐元素比较时字典序较小的从 0 开始的索引序列。\n\n您的程序必须实现一个基于基本原理的动态规划解决方案，该方案源于基因组坐标约束所引出的偏序下链的最优子结构，并且不依赖任何外部输入。\n\n需嵌入代码的输入（测试套件）：\n- 测试用例 $1$：\n  - $L_{\\min} = 20$, $L_{\\max} = 200$。\n  - 候选剪接点（索引 $j$：$(d_j,a_j,s_j)$）：\n    - $0$: $(100,150,3.0)$\n    - $1$: $(140,210,4.0)$\n    - $2$: $(220,300,6.5)$\n    - $3$: $(305,360,2.0)$\n    - $4$: $(170,190,1.0)$\n    - $5$: $(370,430,3.5)$\n    - $6$: $(250,265,2.0)$\n- 测试用例 $2$：\n  - $L_{\\min} = 50$, $L_{\\max} = 70$。\n  - 候选剪接点：\n    - $0$: $(100,151,1.0)$\n    - $1$: $(160,231,1.0)$\n    - $2$: $(232,283,2.0)$\n    - $3$: $(284,355,2.0)$\n- 测试用例 $3$：\n  - $L_{\\min} = 10$, $L_{\\max} = 1000$。\n  - 候选剪接点：\n    - $0$: $(100,220,5.0)$\n    - $1$: $(150,230,6.0)$\n    - $2$: $(180,240,4.5)$\n    - $3$: $(190,250,4.0)$\n- 测试用例 $4$：\n  - $L_{\\min} = 10$, $L_{\\max} = 100$。\n  - 候选剪接点：\n    - $0$: $(100,130,2.0)$\n    - $1$: $(140,170,2.0)$\n    - $2$: $(110,125,1.5)$\n    - $3$: $(126,141,1.0)$\n    - $4$: $(142,157,1.5)$\n- 测试用例 $5$：\n  - $L_{\\min} = 100$, $L_{\\max} = 120$。\n  - 候选剪接点：\n    - $0$: $(10,80,1.0)$\n    - $1$: $(100,300,2.0)$\n    - $2$: $(400,450,3.0)$\n\n输出规范：\n- 对每个测试用例，输出一个包含两个元素的列表 $[S, I]$，其中 $S$ 是可实现的最大分数（实数），$I$ 是所选候选剪接点的从 0 开始的索引列表，按基因组顺序升序排列。如果没有有效的剪接点或空链为最优解，则 $I$ 必须为空列表。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，每个元素的格式为 $[S,[i_1,i_2,\\dots,i_k]]$。例如，输出必须类似于 $[[S_1,[\\dots]],[S_2,[\\dots]],\\dots]$。\n\n算法中需遵守的约束：\n- 所有坐标均为整数，且对每个候选剪接点都满足 $d_j  a_j$。\n- 唯一需要强制执行的约束是内含子长度边界和不重叠条件 $a_{j_t}  d_{j_{t+1}}$；无需对其他生物学特征进行建模。\n- 动态规划必须根据由基因组坐标约束定义的候选剪接点偏序所蕴含的最优子结构，从基本原理出发进行设计。",
            "solution": "该问题要求找到一条最优的非重叠剪接点链，以最大化累积分数，并遵循特定的决胜规则。此问题表现出最优子结构和重叠子问题的特性，因此适合使用动态规划方法解决。其推导和实现如下。\n\n首先，我们将问题形式化。给定一个候选剪接点集合 $J$。一个剪接点 $j \\in J$ 由一个元组 $(d_j, a_j, s_j)$ 定义，其中 $d_j$ 和 $a_j$ 是整数坐标且 $d_j  a_j$，$s_j$ 是一个实值分数。设 $idx_j$ 为剪接点 $j$ 的原始从 0 开始的索引。\n\n解决方案分几个阶段进行：\n\n1.  **筛选**：只有当一个剪接点 $j$ 的内含子长度 $L_j = a_j - d_j - 1$ 落在闭区间 $[L_{\\min}, L_{\\max}]$ 内时，它才被认为是有效的。我们首先筛选初始候选集，只保留这些有效的剪接点。如果没有有效的剪接点，最优解即为空链，其分数为 $S=0$，索引列表为空 $I=[]$。\n\n2.  **排序和定义偏序**：形成链 $(j_1, j_2, \\dots, j_k)$ 的核心约束是，对于任意相邻的一对剪接点 $(j_t, j_{t+1})$，第一个的受体位点必须在第二个的供体位点之前，即 $a_{j_t}  d_{j_{t+1}}$。此条件在有效剪接点集合上定义了一个偏序。为了便于动态规划求解，我们必须以与此偏序一致的顺序处理剪接点。这需要进行拓扑排序。一个标准且有效的方法是，主要按有效剪接点的受体坐标 $a_j$ 升序排序。如果两个剪接点共享相同的受体坐标，则按其供体坐标 $d_j$ 进行次要排序，以确保确定性顺序。设排序后的有效剪接点列表为 $v_0, v_1, \\dots, v_{m-1}$。这种排序保证了对于任何剪接点 $v_i$，其在链中的任何潜在前驱 $v_p$（其中 $a_{v_p}  d_{v_i}$）必然满足 $a_{v_p}  a_{v_i}$，因此在我们的排序列表中会出现在 $v_i$ 之前（即 $p  i$）。\n\n3.  **动态规划公式**：\n    *   **最优子结构**：以剪接点 $v_i$ 结尾的最优链，是通过将某个以有效先行剪接点 $v_p$（其中 $a_{v_p}  d_{v_i}$）结尾的最优链进行扩展而形成的。这样一条新链的分数是，以 $v_p$ 结尾的最优链的分数加上 $v_i$ 的分数。\n    *   **状态定义**：令 $DP[i]$ 表示以剪接点 $v_i$ 结尾的最优链。由于存在复杂的决胜规则，此状态不仅要记录分数。我们将状态定义为一个元组：$(S_i, k_i, I_i)$，其中 $S_i$ 是以 $v_i$ 结尾的链的最大分数，$k_i$ 是该链中的剪接点数量，$I_i$ 是该链中剪接点的原始索引序列，按其基因组位置排序。\n    *   **递推关系**：对于排序列表中的每个剪接点 $v_i$，我们计算 $DP[i]$。基本情况是仅由 $v_i$ 自身构成的链，其状态为 $(s_{v_i}, 1, [idx_{v_i}])$。然后，我们遍历所有在前的剪接点 $v_p$（其中 $p  i$），并检查它们是否能在物理上位于 $v_i$ 之前（即 $a_{v_p}  d_{v_i}$）。如果可以，我们通过用 $v_i$ 扩展以 $v_p$ 结尾的最优链（存储在 $DP[p]$ 中）来形成一条候选新链。该候选链的状态为 $(S_p + s_{v_i}, k_p + 1, I_p \\oplus [idx_{v_i}])$，其中 $\\oplus$ 表示列表连接。我们使用指定的决胜规则将此候选链与当前为 $v_i$ 找到的最佳链进行比较：\n        1.  主要标准：最大化分数 $S$。\n        2.  次要标准（决胜局）：最小化剪接点数量 $k$。\n        3.  第三标准（决胜局）：优先选择字典序较小的索引序列 $I$。\n\n        递推关系可表示为：\n        $$ DP[i] = \\max_{\\prec} \\left( (s_{v_i}, 1, [idx_{v_i}]), \\bigcup_{pi, a_{v_p}  d_{v_i}} \\{ (S_p + s_{v_i}, k_p + 1, I_p \\oplus [idx_{v_i}]) \\} \\right) $$\n        其中 $\\max_{\\prec}$ 表示使用上述三层比较逻辑 $\\prec$ 找到的最优元素。\n\n4.  **最终解的提取**：所有以 $v_i$ 结尾的最优链（即所有 $DP[i]$）都可能是全局最优解。全局最优解是所有 $DP[i]$ 和空链 $(0, 0, [])$ 中最优的一个。我们遍历所有 $m$ 个最终状态以及空链，并使用相同的决胜规则找到全局最优链 $(S_{best}, k_{best}, I_{best})$。\n\n    比较两个链 $C_1 = (S_1, k_1, I_1)$ 和 $C_2 = (S_2, k_2, I_2)$ 的逻辑如下：如果 $S_1  S_2$，则 $C_1$ 更优。如果 $S_1 = S_2$ 且 $k_1  k_2$，则 $C_1$ 更优。如果 $S_1 = S_2$ 且 $k_1 = k_2$ 且 $I_1$ 在字典序上小于 $I_2$，则 $C_1$ 更优。在所有其他情况下，$C_2$ 不比 $C_1$ 差。\n\n通过将此逻辑应用于所有计算出的 $DP$ 状态和空链，我们可以确定性地找到所要求的最优链，并报告其总分数和索引列表。该算法的时间复杂度为 $O(m^2)$，其中 $m$ 是有效剪接点的数量，因为对于每个剪接点，我们都会回顾所有先前的剪接点。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the gene chaining problem for a fixed set of test cases\n    using dynamic programming.\n    \"\"\"\n    test_cases = [\n        {\n            \"L_bounds\": (20, 200),\n            \"candidates\": [\n                (100, 150, 3.0), (140, 210, 4.0), (220, 300, 6.5),\n                (305, 360, 2.0), (170, 190, 1.0), (370, 430, 3.5),\n                (250, 265, 2.0)\n            ]\n        },\n        {\n            \"L_bounds\": (50, 70),\n            \"candidates\": [\n                (100, 151, 1.0), (160, 231, 1.0), (232, 283, 2.0),\n                (284, 355, 2.0)\n            ]\n        },\n        {\n            \"L_bounds\": (10, 1000),\n            \"candidates\": [\n                (100, 220, 5.0), (150, 230, 6.0), (180, 240, 4.5),\n                (190, 250, 4.0)\n            ]\n        },\n        {\n            \"L_bounds\": (10, 100),\n            \"candidates\": [\n                (100, 130, 2.0), (140, 170, 2.0), (110, 125, 1.5),\n                (126, 141, 1.0), (142, 157, 1.5)\n            ]\n        },\n        {\n            \"L_bounds\": (100, 120),\n            \"candidates\": [\n                (10, 80, 1.0), (100, 300, 2.0), (400, 450, 3.0)\n            ]\n        }\n    ]\n\n    all_results = []\n\n    def is_chain1_better(chain1, chain2):\n        \"\"\"\n        Compares two chains based on the problem's tie-breaking rules.\n        A chain is a tuple: (score, k, index_list).\n        Returns True if chain1 is better than chain2.\n        \"\"\"\n        score1, k1, indices1 = chain1\n        score2, k2, indices2 = chain2\n\n        if score1 > score2:\n            return True\n        if score1  score2:\n            return False\n        \n        # Scores are equal, prefer smaller k\n        if k1  k2:\n            return True\n        if k1 > k2:\n            return False\n\n        # Scores and k are equal, prefer lexicographically smaller index list\n        if indices1  indices2:\n            return True\n        \n        return False\n\n    for case in test_cases:\n        L_min, L_max = case[\"L_bounds\"]\n        candidates = case[\"candidates\"]\n\n        valid_junctions = []\n        for i, (d, a, s) in enumerate(candidates):\n            length = a - d - 1\n            if L_min = length = L_max:\n                valid_junctions.append({'d': d, 'a': a, 's': s, 'idx': i})\n\n        if not valid_junctions:\n            all_results.append(\"[0.0,[]]\")\n            continue\n\n        valid_junctions.sort(key=lambda j: (j['a'], j['d']))\n\n        dp_states = []\n        for i in range(len(valid_junctions)):\n            current_j = valid_junctions[i]\n            \n            # Base case: a chain of one junction\n            best_chain_for_i = (current_j['s'], 1, [current_j['idx']])\n\n            for p in range(i):\n                pred_j = valid_junctions[p]\n\n                if pred_j['a']  current_j['d']:\n                    pred_chain_score, pred_chain_k, pred_chain_indices = dp_states[p]\n                    \n                    candidate_chain = (\n                        pred_chain_score + current_j['s'],\n                        pred_chain_k + 1,\n                        pred_chain_indices + [current_j['idx']]\n                    )\n\n                    if is_chain1_better(candidate_chain, best_chain_for_i):\n                        best_chain_for_i = candidate_chain\n            \n            dp_states.append(best_chain_for_i)\n\n        # The overall best chain is the best among all ending chains and the empty chain\n        best_overall_chain = (0.0, 0, [])\n        for chain in dp_states:\n            if is_chain1_better(chain, best_overall_chain):\n                best_overall_chain = chain\n\n        final_score = best_overall_chain[0]\n        final_indices = best_overall_chain[2]\n        \n        all_results.append(f\"[{final_score},{final_indices}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "构建了预测模型后，我们如何衡量其性能？评估是基因预测流程中至关重要且充满挑战的一步。本练习将让您亲手计算外显子水平和基因水平的评估指标，例如$F_1$分数和灵敏度，从而深刻理解为何必须在不同生物学层面上评估预测的准确性。",
            "id": "4567083",
            "problem": "一个研究小组正在一个包含真核和原核基因的混合数据集上，对一个基因预测流程进行基准测试。其生物学基础是，在真核生物中，基因可能含有多个外显子，并且可变剪接会为每个基因产生多个转录本；而在原核生物中，蛋白质编码基因通常是单外显子的开放阅读框。该评估在外显子水平上使用精确边界匹配，并要求在基因水平上，一个基因必须达到完整的转录本水平的正确性才被认为是正确预测的。对于外显子水平的评估，仅当一个预测的外显子与一个基准外显子具有完全相同的起始和终止坐标以及相同的链时，才被认为是正确预测的；部分重叠或边界移位均被视为不正确。对于基因水平的评估，如果存在至少一个预测的转录本，其外显子集合与该基因的至少一个基准转录本的外显子集合完全匹配，则该基因被认为是正确预测的。\n\n基准数据包含 $6$ 个基因：\n- 真核基因 $\\mathrm{E1}$，有 $2$ 个转录本：\n  - $\\mathrm{E1}$ 转录本 $\\mathrm{T1}$ 的外显子：$[100, 200]$, $[301, 400]$, $[501, 600]$。\n  - $\\mathrm{E1}$ 转录本 $\\mathrm{T2}$ 的外显子：$[100, 200]$, $[351, 400]$, $[501, 600]$。\n- 真核基因 $\\mathrm{E2}$，有 $1$ 个转录本：\n  - $\\mathrm{E2}$ 的外显子：$[1000, 1200]$, $[1301, 1400]$。\n- 真核基因 $\\mathrm{E3}$，有 $1$ 个转录本：\n  - $\\mathrm{E3}$ 的外显子：$[2000, 2300]$。\n- 原核基因 $\\mathrm{P1}$，有 $1$ 个转录本（单外显子）：\n  - $\\mathrm{P1}$ 的外显子：$[5000, 5600]$。\n- 原核基因 $\\mathrm{P2}$，有 $1$ 个转录本（单外显子）：\n  - $\\mathrm{P2}$ 的外显子：$[5700, 6200]$。\n- 原核基因 $\\mathrm{P3}$，有 $1$ 个转录本（单外显子）：\n  - $\\mathrm{P3}$ 的外显子：$[6300, 6700]$。\n\n该流程输出了以下预测的转录本及其外显子集合：\n- 预测的转录本 $1$：外显子 $[100, 200]$, $[301, 400]$, $[501, 600]$。\n- 预测的转录本 $2$：外显子 $[1000, 1200]$, $[1301, 1405]$。\n- 预测的转录本 $3$：外显子 $[2000, 2300]$。\n- 预测的转录本 $4$：外显子 $[5000, 5600]$。\n- 预测的转录本 $5$：外显子 $[6300, 6700]$, $[6450, 6460]$。\n- 预测的转录本 $6$：外显子 $[450, 480]$。\n\n假设所有坐标表示在正确链上的碱基对位置，并且外显子水平的评估是针对所有转录本中唯一的基准外显子集合进行的。请根据上述评估标准，计算该数据集的外显子水平F1分数和基因水平灵敏度（定义为基因水平召回率）。将两个指标均以小数表示，并各自四舍五入到四位有效数字。按以下顺序提供这两个值：外显子水平F1分数，基因水平灵敏度。",
            "solution": "这个问题是有效的，它在生物信息学领域有科学依据，并提供了计算所要求指标所需的所有数据和评估标准。外显子水平和基因水平正确性的定义是明确且无歧义的。因此，该问题是有效的。\n\n任务是计算两个指标：外显子水平的F1分数和基因水平的灵敏度（召回率）。这需要在两个不同的生物组织层面上，对预测实体与基准实体进行系统性比较。\n\n首先，我们处理外显子水平的评估。此评估的标准指标是精确率、召回率和F1分数，F1分数是前两者的调和平均数。\n设 $TP_{exon}$ 为真阳性外显子的数量，$FP_{exon}$ 为假阳性外显子的数量，$FN_{exon}$ 为假阴性外显子的数量。\n评估基于起始和终止坐标的精确匹配。\n外显子水平的精确率（$P_{exon}$）和召回率（$R_{exon}$）定义如下：\n$$P_{exon} = \\frac{TP_{exon}}{TP_{exon} + FP_{exon}}$$\n$$R_{exon} = \\frac{TP_{exon}}{TP_{exon} + FN_{exon}}$$\nF1分数（$F_{1,exon}$）则为：\n$$F_{1,exon} = 2 \\cdot \\frac{P_{exon} \\cdot R_{exon}}{P_{exon} + R_{exon}}$$\n\n为了计算这些值，我们必须首先确定唯一的基准外显子集合和所有预测的外显子集合。\n唯一的基准外显子集合 $S_{GT}$ 是通过收集所有基准转录本中的所有外显子并去除重复项而形成的。\n- E1-T1: $[100, 200], [301, 400], [501, 600]$\n- E1-T2: $[100, 200], [351, 400], [501, 600]$\n- E2: $[1000, 1200], [1301, 1400]$\n- E3: $[2000, 2300]$\n- P1: $[5000, 5600]$\n- P2: $[5700, 6200]$\n- P3: $[6300, 6700]$\n$S_{GT} = \\{[100, 200], [301, 400], [501, 600], [351, 400], [1000, 1200], [1301, 1400], [2000, 2300], [5000, 5600], [5700, 6200], [6300, 6700]\\}$.\n唯一的基准外显子总数为 $|S_{GT}| = 10$。这个数字代表了阳性实例的总数，因此 $TP_{exon} + FN_{exon} = 10$。\n\n预测的外显子集合 $S_{P}$ 是所有预测转录本中外显子的集合。\n- 预测 1: $[100, 200], [301, 400], [501, 600]$\n- 预测 2: $[1000, 1200], [1301, 1405]$\n- 预测 3: $[2000, 2300]$\n- 预测 4: $[5000, 5600]$\n- 预测 5: $[6300, 6700], [6450, 6460]$\n- 预测 6: $[450, 480]$\n$S_{P} = \\{[100, 200], [301, 400], [501, 600], [1000, 1200], [1301, 1405], [2000, 2300], [5000, 5600], [6300, 6700], [6450, 6460], [450, 480]\\}$.\n预测的外显子总数为 $|S_{P}| = 10$。这个数字代表了预测的总数，因此 $TP_{exon} + FP_{exon} = 10$。\n\n$TP_{exon}$ 是 $S_P$ 中也存在于 $S_{GT}$ 中的外显子数量。这是交集 $S_{P} \\cap S_{GT}$ 的大小。\n- $[100, 200]$ 存在于 $S_{GT}$ 中。\n- $[301, 400]$ 存在于 $S_{GT}$ 中。\n- $[501, 600]$ 存在于 $S_{GT}$ 中。\n- $[1000, 1200]$ 存在于 $S_{GT}$ 中。\n- $[1301, 1405]$ 不在 $S_{GT}$ 中（基准为 $[1301, 1400]$）。\n- $[2000, 2300]$ 存在于 $S_{GT}$ 中。\n- $[5000, 5600]$ 存在于 $S_{GT}$ 中。\n- $[6300, 6700]$ 存在于 $S_{GT}$ 中。\n- $[6450, 6460]$ 不在 $S_{GT}$ 中。\n- $[450, 480]$ 不在 $S_{GT}$ 中。\n统计匹配项，我们得到 $TP_{exon} = 7$。\n\n现在我们可以计算 $FP_{exon}$ 和 $FN_{exon}$。\n$FP_{exon} = |S_P| - TP_{exon} = 10 - 7 = 3$。假阳性外显子为 $\\{[1301, 1405], [6450, 6460], [450, 480]\\}$。\n$FN_{exon} = |S_{GT}| - TP_{exon} = 10 - 7 = 3$。假阴性外显子是 $S_{GT}$ 中未被预测的那些：$\\{[351, 400], [1301, 1400], [5700, 6200]\\}$。\n\n我们计算外显子水平的精确率和召回率：\n$P_{exon} = \\frac{7}{10} = 0.7$\n$R_{exon} = \\frac{7}{10} = 0.7$\n\n以及外显子水平的F1分数：\n$F_{1,exon} = 2 \\cdot \\frac{0.7 \\cdot 0.7}{0.7 + 0.7} = 2 \\cdot \\frac{0.49}{1.4} = \\frac{0.98}{1.4} = 0.7$.\n四舍五入到四位有效数字，结果为 $0.7000$。\n\n接下来，我们处理基因水平的评估。我们需要计算基因水平的灵敏度，它被定义为基因水平的召回率。\n设 $N_{genes}$ 为基准基因的总数。设 $TP_{gene}$ 为正确预测的基因数量。\n基因水平的灵敏度（$S_{gene}$）由下式给出：\n$$S_{gene} = \\frac{TP_{gene}}{N_{genes}}$$\n总共有 $N_{genes} = 6$ 个基准基因。如果一个预测的转录本的外显子集合与该基因至少一个基准转录本的外显子集合完全匹配，那么该基因就被认为是正确预测的。\n\n我们逐个评估每个基因：\n1.  基因 E1：有两个基准转录本，其外显子集合分别为 $T_{E1,1} = \\{[100, 200], [301, 400], [501, 600]\\}$ 和 $T_{E1,2} = \\{[100, 200], [351, 400], [501, 600]\\}$。预测的转录本 1 的外显子集合为 $\\{[100, 200], [301, 400], [501, 600]\\}$，与 $T_{E1,1}$ 完全匹配。因此，基因 E1 是一个真阳性。\n2.  基因 E2：有一个基准转录本，其外显子集合为 $T_{E2} = \\{[1000, 1200], [1301, 1400]\\}$。预测的转录本 2 的外显子为 $\\{[1000, 1200], [1301, 1405]\\}$。这不完全匹配。没有其他预测的转录本匹配。因此，基因 E2 是一个假阴性。\n3.  基因 E3：有一个基准转录本，其外显子集合为 $T_{E3} = \\{[2000, 2300]\\}$。预测的转录本 3 的外显子集合为 $\\{[2000, 2300]\\}$，完全匹配。因此，基因 E3 是一个真阳性。\n4.  基因 P1：有一个基准转录本，其外显子集合为 $T_{P1} = \\{[5000, 5600]\\}$。预测的转录本 4 的外显子集合为 $\\{[5000, 5600]\\}$，完全匹配。因此，基因 P1 是一个真阳性。\n5.  基因 P2：有一个基准转录本，其外显子集合为 $T_{P2} = \\{[5700, 6200]\\}$。没有为该基因预测的转录本。因此，基因 P2 是一个假阴性。\n6.  基因 P3：有一个基准转录本，其外显子集合为 $T_{P3} = \\{[6300, 6700]\\}$。预测的转录本 5 的外显子为 $\\{[6300, 6700], [6450, 6460]\\}$。这不完全匹配。因此，基因 P3 是一个假阴性。\n\n正确预测的基因数量为 $TP_{gene} = 3$（E1, E3, P1）。\n基因水平的灵敏度是：\n$S_{gene} = \\frac{TP_{gene}}{N_{genes}} = \\frac{3}{6} = 0.5$.\n四舍五入到四位有效数字，结果为 $0.5000$。\n\n两个所要求的值是外显子水平的F1分数（$0.7000$）和基因水平的灵敏度（$0.5000$）。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.7000  0.5000 \\end{pmatrix}}$$"
        }
    ]
}