{
    "hands_on_practices": [
        {
            "introduction": "为了识别未知的蛋白质，我们首先需要一个“嫌疑犯”名单。这项练习模拟了搜索引擎如何通过计算方式将已知的蛋白质序列“切割”成更小的肽段，就像胰蛋白酶在真实实验中所做的那样 。掌握这一过程是构建理论数据库的第一步，我们的实验数据将与该数据库进行比对。",
            "id": "4600247",
            "problem": "您的任务是实现一个程序，该程序模拟蛋白质数据库搜索鉴定中使用的标准肽段生成步骤。目标是从一个蛋白质序列中枚举出所有允许最多一个错切位点的完全胰蛋白酶酶切肽段，然后计算这些肽段的单同位素中性质量。您的实现必须遵循精确的生物化学规则，并以确定性的、单位指定的数值格式生成结果，以便用于后续匹配。\n\n使用的基本定义：\n- 胰蛋白酶的蛋白水解特异性：在赖氨酸（K）和精氨酸（R）残基之后进行切割，由单字母代码 $\\{K,R\\}$ 表示，但当下一个残基是脯氨酸 $P$ 时除外。此规则沿序列应用；蛋白质的N端和C端根据定义即为边界。\n- 完全胰蛋白酶酶切肽段是连续的子字符串，其 $N$ 端与蛋白质的 $N$ 端或一个有效的胰蛋白酶酶切位点重合，其 $C$ 端与一个有效的胰蛋白酶酶切位点或蛋白质的 $C$ 端重合。最多允许 $1$ 个错切位点：除了规范的完全胰蛋白酶酶切肽段（$0$ 个错切位点）之外，还包括由合并恰好两个相邻的规范完全胰蛋白酶酶切肽段形成的肽段（$1$ 个错切位点）。不包括任何半胰蛋白酶酶切肽段。\n- 单同位素中性肽段质量等于肽段中所有残基的单同位素残基质量之和，再加上一个水分子 $H_{2}O$ 的质量，以解释肽段末端的形成。形式上，对于一个肽段 $p = a_{1}a_{2}\\dots a_{L}$，\n$$\nM(p) = \\left(\\sum_{j=1}^{L} m(a_{j})\\right) + m(H_{2}O).\n$$\n- 使用以下以道尔顿（Da）为单位的单同位素残基质量 $m(\\cdot)$：$A=71.03711$, $R=156.10111$, $N=114.04293$, $D=115.02694$, $C=103.00919$, $E=129.04259$, $Q=128.05858$, $G=57.02146$, $H=137.05891$, $I=113.08406$, $L=113.08406$, $K=128.09496$, $M=131.04049$, $F=147.06841$, $P=97.05276$, $S=87.03203$, $T=101.04768$, $W=186.07931$, $Y=163.06333$, $V=99.06841$。使用 $m(H_{2}O)=18.01056$。\n- 将序列视为仅由上述 $20$ 种标准氨基酸组成。如果出现此集合之外的字符，则视为无效。\n\n算法的数学框架：\n- 设蛋白质序列为一个长度为 $n$ 的字符串 $s$，索引从 $0$ 到 $n-1$。为位置 $i \\in \\{0,1,\\dots,n-2\\}$ 定义一个切割指示函数 $c(i)$：\n$$\nc(i) = \\begin{cases}\n1  \\text{if } s[i]\\in\\{K,R\\} \\text{ and } s[i+1]\\neq P,\\\\\n0  \\text{otherwise.}\n\\end{cases}\n$$\n- 定义切割边界集合 $B = \\{0\\} \\cup \\{\\, i+1 \\mid c(i)=1 \\,\\} \\cup \\{n\\}$，并按严格递增顺序排序为 $0=b_{0}  b_{1}  \\dotsb  b_{m}=n$。具有 $0$ 个错切位点的规范完全胰蛋白酶酶切肽段是对于 $j\\in\\{0,1,\\dots,m-1\\}$ 的子字符串 $s[b_{j}:b_{j+1}]$。具有 $1$ 个错切位点的完全胰蛋白酶酶切肽段是对于 $j\\in\\{0,1,\\dots,m-2\\}$ 的子字符串 $s[b_{j}:b_{j+2}]$。报告质量时排除任何重复项。\n- 对于每个肽段 $p$，如上计算 $M(p)$。报告枚举出的肽段的唯一单同位素质量。\n\n单位和格式要求：\n- 所有质量均以道尔顿（Da）表示，并将每个质量四舍五入到小数点后恰好 $6$ 位。\n- 对于每个输入序列，返回按严格递增顺序排序的、唯一的、经过四舍五入的质量列表。\n\n测试套件：\n实现您的程序来处理以下序列作为独立的测试用例：\n- 用例 1：$s_{1} = \\text{\"AKRPQKTPR\"}$。\n- 用例 2：$s_{2} = \\text{\"MPEPTIDE\"}$。\n- 用例 3：$s_{3} = \\text{\"KK\"}$。\n- 用例 4：$s_{4} = \\text{\"MRP\"}$。\n\n覆盖理由：\n- 用例 1 涵盖了多个切割位点、一个被脯氨酸阻断的切割以及一次错切合并。\n- 用例 2 没有碱性切割残基 $\\{K,R\\}$，产生一个等于整个蛋白质的单一肽段。\n- 用例 3 包含连续的碱性残基，创建了相邻的单残基肽段和一个有效的一次错切合并。\n- 用例 4 包含一个后跟脯氨酸的碱性残基，在内部阻断了切割。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个元素对应一个测试用例，并且其本身必须是一个用方括号括起来的、逗号分隔的、经过四舍五入的质量列表，不含空格。例如，一个包含两个测试用例的输出可能看起来像 $[[x_{1},x_{2}],[y_{1}]]$，其中每个 $x_{i}$ 和 $y_{j}$ 都是小数点后恰好有 $6$ 位的小数。",
            "solution": "该问题陈述是生物信息学算法领域一个有效的、定义明确的练习。它科学地植根于蛋白质质谱法的原理，特别是蛋白水解消化的计算模拟和肽段质量计算。所有必需的参数，包括胰蛋白酶的酶切规则、20种标准氨基酸的单同位素质量表以及水分子的质量，都已提供且事实上是正确的。切割过程和肽段生成的数学形式化是精确、无歧义且内部一致的。因此，我们可以直接实现指定的模型。\n\n我们的目标是开发一个计算程序，对于给定的蛋白质序列，该程序能够枚举出所有具有零个或一个错切位点的完全胰蛋白酶酶切肽段，然后计算出它们唯一的、经过排序的单同位素质量。\n\n该算法通过直接转化所提供的数学框架来设计。设一个蛋白质序列由长度为 $n$ 的字符串 $s$ 表示。\n\n**步骤1：定义质量常数**\n\n首先，我们确定质量计算所需的基本常数。我们将提供的 $20$ 种标准氨基酸残基的单同位素质量和水分子的质量 $m(H_{2}O) = 18.01056 \\text{ Da}$，编码到一个数据结构（如哈希映射或字典）中，以便进行高效查找。残基质量如下：$m(A)=71.03711$, $m(R)=156.10111$, $m(N)=114.04293$, $m(D)=115.02694$, $m(C)=103.00919$, $m(E)=129.04259$, $m(Q)=128.05858$, $m(G)=57.02146$, $m(H)=137.05891$, $m(I)=113.08406$, $m(L)=113.08406$, $m(K)=128.09496$, $m(M)=131.04049$, $m(F)=147.06841$, $m(P)=97.05276$, $m(S)=87.03203$, $m(T)=101.04768$, $m(W)=186.07931$, $m(Y)=163.06333$, $m(V)=99.06841$。\n\n**步骤2：识别胰蛋白酶酶切位点**\n\n消化模拟的核心是识别切割位点。根据定义，胰蛋白酶在赖氨酸（$K$）和精氨酸（$R$）残基的C端进行切割，除非随后的残基是脯氨酸（$P$）。我们实现指定的切割指示函数 $c(i)$，该函数扫描序列。对于从 $0$ 到 $n-2$ 的每个位置 $i$：\n$$\nc(i) = \\begin{cases}\n1  \\text{if } s[i]\\in\\{K,R\\} \\text{ and } s[i+1]\\neq P,\\\\\n0  \\text{otherwise.}\n\\end{cases}\n$$\n然后构建切割边界集合 $B$。它用序列的末端 $0$ 和 $n$ 进行初始化。然后，对于 $c(i)=1$ 的每个位置 $i$，在索引 $i+1$ 处添加一个边界。将生成的边界集合排序，以产生一个有序列表 $B = \\{b_0, b_1, \\dots, b_m\\}$，其中 $0 = b_0  b_1  \\dots  b_m = n$。\n\n**步骤3：枚举肽段**\n\n使用排序后的边界，我们生成两类肽段：\n\n1.  **具有0个错切位点的肽段：** 这些是在相邻切割位点之间形成的规范胰蛋白酶酶切肽段。对于从 $0$ 到 $m-1$ 的每个 $j$，我们提取子字符串 $s[b_j:b_{j+1}]$。\n2.  **具有1个错切位点的肽段：** 这些肽段跨越恰好一个内部切割位点。对于从 $0$ 到 $m-2$ 的每个 $j$，我们提取子字符串 $s[b_j:b_{j+2}]$。\n\n所有生成的肽段字符串被收集到一个集合数据结构中，以确保任何重复项（例如，如果“K”和“K”作为单独的规范肽段生成）只被计算一次。\n\n**步骤4：计算并格式化肽段质量**\n\n对于我们集合中的每个唯一肽段 $p$，我们根据以下公式计算其单同位素中性质量 $M(p)$：\n$$\nM(p) = \\left(\\sum_{\\text{residue } a_j \\in p} m(a_j)\\right) + m(H_{2}O)\n$$\n这是通过将构成它的氨基酸残基的预定义质量相加，再加上一个水分子的质量来完成的。\n\n对于给定的序列，最终输出必须是一个排序的、唯一的、四舍五入到小数点后 $6$ 位的质量列表。为了严格遵守此要求，采用以下步骤：\n1.  将所有肽段质量计算为高精度浮点数。\n2.  对于每个计算出的质量，将其格式化为小数点后恰好有 $6$ 位的字符串。此步骤执行四舍五入和标准化。\n3.  将这些格式化的字符串收集到一个集合中，以获得唯一的、经过四舍五入的质量值。\n4.  将唯一的质量字符串集合转换为列表并进行排序。由于字符串格式统一，字典序排序等同于数值排序。\n\n此过程应用于每个测试用例，最终结果汇总成指定的嵌套列表格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used. Numpy is imported to adhere to the template.\n\ndef solve():\n    \"\"\"\n    Main function to solve the protein digestion problem for the given test suite.\n    \"\"\"\n\n    # Base definitions as per the problem statement.\n    MONOISOTOPIC_MASSES = {\n        'A': 71.03711, 'R': 156.10111, 'N': 114.04293, 'D': 115.02694,\n        'C': 103.00919, 'E': 129.04259, 'Q': 128.05858, 'G': 57.02146,\n        'H': 137.05891, 'I': 113.08406, 'L': 113.08406, 'K': 128.09496,\n        'M': 131.04049, 'F': 147.06841, 'P': 97.05276, 'S': 87.03203,\n        'T': 101.04768, 'W': 186.07931, 'Y': 163.06333, 'V': 99.06841,\n        'H2O': 18.01056\n    }\n    \n    # Test suite from the problem statement.\n    test_cases = [\n        \"AKRPQKTPR\",  # Case 1\n        \"MPEPTIDE\",   # Case 2\n        \"KK\",         # Case 3\n        \"MRP\"         # Case 4\n    ]\n\n    def process_sequence(sequence: str) - list[str]:\n        \"\"\"\n        Processes a single protein sequence to generate sorted, unique, rounded peptide masses.\n\n        Args:\n            sequence: The amino acid sequence string.\n\n        Returns:\n            A list of strings, where each string is a peptide mass rounded to 6 decimal places,\n            sorted in increasing order.\n        \"\"\"\n        n = len(sequence)\n        \n        # Step 1: Identify all cleavage sites.\n        # Cleavage after K or R, but not if followed by P.\n        cut_boundaries = {0, n}\n        for i in range(n - 1):\n            if sequence[i] in ('K', 'R') and sequence[i+1] != 'P':\n                cut_boundaries.add(i + 1)\n        \n        # Sort boundaries to get the ordered set B = {b_0, b_1, ..., b_m}.\n        sorted_boundaries = sorted(list(cut_boundaries))\n        m = len(sorted_boundaries)\n\n        # Step 2: Enumerate all peptides with 0 or 1 missed cleavages.\n        # A set is used to automatically handle any duplicate peptide sequences.\n        peptides = set()\n        \n        # Add peptides with 0 missed cleavages: s[b_j : b_{j+1}]\n        if m  1:\n            for j in range(m - 1):\n                peptide = sequence[sorted_boundaries[j]:sorted_boundaries[j+1]]\n                peptides.add(peptide)\n\n        # Add peptides with 1 missed cleavage: s[b_j : b_{j+2}]\n        if m  2:\n            for j in range(m - 2):\n                peptide = sequence[sorted_boundaries[j]:sorted_boundaries[j+2]]\n                peptides.add(peptide)\n\n        # Step 3: Calculate monoisotopic mass for each unique peptide.\n        raw_masses = []\n        mass_h2o = MONOISOTOPIC_MASSES['H2O']\n        for pep in peptides:\n            peptide_mass = mass_h2o\n            for residue in pep:\n                peptide_mass += MONOISOTOPIC_MASSES[residue]\n            raw_masses.append(peptide_mass)\n            \n        # Step 4: Format masses to obtain unique, sorted, rounded values.\n        # Format to 6 decimal places, put into a set for uniqueness, then sort.\n        unique_rounded_mass_strings = {f\"{mass:.6f}\" for mass in raw_masses}\n        \n        # Sort the unique mass strings. Lexicographical sort works for fixed-format numbers.\n        sorted_masses = sorted(list(unique_rounded_mass_strings))\n        \n        return sorted_masses\n\n    # Process all test cases.\n    all_results = []\n    for seq in test_cases:\n        mass_list = process_sequence(seq)\n        # Format the list of masses as a bracketed, comma-separated string.\n        all_results.append(f\"[{','.join(mass_list)}]\")\n\n    # Print the final result in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "一旦我们获得了实验质谱图（肽段的“指纹”），就需要将其与我们的理论“嫌疑犯”进行比较。本练习侧重于该比较过程中的一个关键环节：预测候选肽段的碎片模式 。通过计算诸如 y-离子等碎片的理论质量，我们可以生成一个理论谱图，并与实验谱图进行评分匹配。",
            "id": "4600205",
            "problem": "在串联质谱（MS/MS）中，肽骨架在低能碰撞诱导解离（CID）下的裂解主要产生N端的b离子和C端的y离子。带有电荷态 $z$ 的碎片离子的质荷比（m/z）等于其总质量（中性组分加上诸如质子之类的加合物）除以 $z$。在肽骨架中，单同位素残基质量定义为聚合链中氨基酸的质量贡献（即游离氨基酸质量减去水的质量）。在CID条件下，y离子由一个带有C端羧基的C端肽段组成。假设没有翻译后修饰，且半胱氨酸残基未被修饰。\n\n考虑肽序列“ACDE”。使用以下单同位素质量：\n- 残基质量（单位：道尔顿）：$A = 71.03711$, $C = 103.00919$, $D = 115.02694$, $E = 129.04259$。\n- 中性水质量：$\\mathrm{H_2O} = 18.01056$ 道尔顿。\n- 质子质量：$m_p = 1.007276$ 道尔顿。\n\n使用低能CID产生的y离子的既定定义和肽质量组成原理，计算肽“ACDE”在电荷态 $z = 1$ 时y离子系列 $y_1$、$y_2$、$y_3$ 和 $y_4$ 的理论质荷比。以道尔顿/基本电荷为单位表示最终数值，并四舍五入至六位有效数字。",
            "solution": "对问题陈述进行验证。\n\n### 步骤1：提取给定信息\n- 肽序列：“ACDE”\n- 目标离子：$y_1$、$y_2$、$y_3$ 和 $y_4$\n- 电荷态，$z$：$1$\n- Alanine (A) 的单同位素残基质量：$m_A = 71.03711$ 道尔顿\n- Cysteine (C) 的单同位素残基质量：$m_C = 103.00919$ 道尔顿\n- Aspartic acid (D) 的单同位素残基质量：$m_D = 115.02694$ 道尔顿\n- Glutamic acid (E) 的单同位素残基质量：$m_E = 129.04259$ 道尔顿\n- 中性水质量：$m_{\\mathrm{H_2O}} = 18.01056$ 道尔顿\n- 质子质量：$m_p = 1.007276$ 道尔顿\n- 假设：无翻译后修饰，半胱氨酸残基未修饰，低能CID碎裂。\n- 要求：计算指定y离子系列的理论质荷比（m/z），并四舍五入至六位有效数字。\n\n### 步骤2：使用提取的给定信息进行验证\n该问题具有科学依据，描述了基于串联质谱原理的蛋白质组学中的一个标准计算。所提供的残基质量、y离子和质荷比的定义与既定惯例一致。问题提法明确，提供了计算一组唯一且有意义的数值所需的所有数据（序列、质量、电荷态）。语言客观、精确。问题是完整的、一致的、现实的且并非微不足道的。\n\n### 步骤3：结论与行动\n问题有效。将继续进行求解。\n\n任务是计算肽“ACDE”在电荷态 $z=1$ 时，其y离子系列（$y_1, y_2, y_3, y_4$）的理论质荷比（记为 $m/z$）。\n\n肽序列为 Alanine-Cysteine-Aspartic acid-Glutamic acid。N端是 Alanine (A)，C端是 Glutamic acid (E)。\n$$\n\\text{N-terminus} - \\text{A} - \\text{C} - \\text{D} - \\text{E} - \\text{C-terminus}\n$$\n在低能碰撞诱导解离（CID）中，y离子是C端碎片。一个 $y_i$ 离子是包含最靠近C端的 $i$ 个氨基酸残基的碎片。\n\n一个y离子的中性质量 $M_{y_i, \\text{neutral}}$ 的计算方法是：其组成氨基酸的单同位素残基质量之和加上一个水分子的质量（$m_{\\mathrm{H_2O}}$）。水分子质量解释了碎片N端的氢原子和原始肽C端的羟基。\ny_i 离子的中性质量通用公式为：\n$$\nM_{y_i, \\text{neutral}} = \\left( \\sum_{\\text{residues in } y_i} m_{\\text{residue}} \\right) + m_{\\mathrm{H_2O}}\n$$\n在质谱仪中观测到的离子是带电的。检测到的离子的总质量 $M_{y_i, \\text{ion}}$ 是中性质量加上带电加合物的质量。对于电荷态为 $z$ 的正离子模式，这包括加上 $z$ 个质子（$m_p$）的质量。\n$$\nM_{y_i, \\text{ion}} = M_{y_i, \\text{neutral}} + z \\cdot m_p\n$$\n那么质荷比（$m/z$）为：\n$$\n\\left( \\frac{m}{z} \\right)_{y_i} = \\frac{M_{y_i, \\text{ion}}}{z} = \\frac{\\left( \\sum_{\\text{residues in } y_i} m_{\\text{residue}} \\right) + m_{\\mathrm{H_2O}} + z \\cdot m_p}{z}\n$$\n对于本问题，电荷态为 $z=1$。公式简化为：\n$$\n\\left( \\frac{m}{z} \\right)_{y_i, z=1} = \\left( \\sum_{\\text{residues in } y_i} m_{\\text{residue}} \\right) + m_{\\mathrm{H_2O}} + m_p\n$$\n我们对每个y离子应用此公式。碎片从C端（E）开始形成。\n- $y_1$ 碎片：E\n- $y_2$ 碎片：DE\n- $y_3$ 碎片：CDE\n- $y_4$ 碎片：ACDE（完整的肽，对应于前体离子 $[M+H]^+$）\n\n给定的单同位素质量为：\n$m_A = 71.03711$ Da\n$m_C = 103.00919$ Da\n$m_D = 115.02694$ Da\n$m_E = 129.04259$ Da\n$m_{\\mathrm{H_2O}} = 18.01056$ Da\n$m_p = 1.007276$ Da\n\n计算 $y_1$：\n该碎片仅包含C端残基E。\n$$\n\\left( \\frac{m}{z} \\right)_{y_1} = m_E + m_{\\mathrm{H_2O}} + m_p\n$$\n$$\n\\left( \\frac{m}{z} \\right)_{y_1} = 129.04259 + 18.01056 + 1.007276 = 148.060426\n$$\n四舍五入至六位有效数字，我们得到 $148.060$。\n\n计算 $y_2$：\n该碎片包含残基D和E。\n$$\n\\left( \\frac{m}{z} \\right)_{y_2} = (m_D + m_E) + m_{\\mathrm{H_2O}} + m_p\n$$\n$$\n\\left( \\frac{m}{z} \\right)_{y_2} = (115.02694 + 129.04259) + 18.01056 + 1.007276 = 244.06953 + 19.017836 = 263.087366\n$$\n四舍五入至六位有效数字，我们得到 $263.087$。\n\n计算 $y_3$：\n该碎片包含残基C、D和E。\n$$\n\\left( \\frac{m}{z} \\right)_{y_3} = (m_C + m_D + m_E) + m_{\\mathrm{H_2O}} + m_p\n$$\n$$\n\\left( \\frac{m}{z} \\right)_{y_3} = (103.00919 + 115.02694 + 129.04259) + 18.01056 + 1.007276 = 347.07872 + 19.017836 = 366.096556\n$$\n四舍五入至六位有效数字，我们得到 $366.097$。\n\n计算 $y_4$：\n该碎片包含所有残基A、C、D和E。这对应于单质子化的前体离子。\n$$\n\\left( \\frac{m}{z} \\right)_{y_4} = (m_A + m_C + m_D + m_E) + m_{\\mathrm{H_2O}} + m_p\n$$\n$$\n\\left( \\frac{m}{z} \\right)_{y_4} = (71.03711 + 103.00919 + 115.02694 + 129.04259) + 18.01056 + 1.007276 = 418.11583 + 19.017836 = 437.133666\n$$\n四舍五入至六位有效数字，我们得到 $437.134$。\n\n最终计算出的y离子系列的 $m/z$ 值为：\n- $y_1$: $148.060$\n- $y_2$: $263.087$\n- $y_3$: $366.097$\n- $y_4$: $437.134$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n148.060  263.087  366.097  437.134\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "数据库搜索是一个概率游戏，并非每个高分匹配都是正确的。为确保结果的可靠性，我们必须控制假阳性率，而靶标-诱饵策略是完成此任务的黄金标准 。这项练习将指导您计算假发现率（False Discovery Rate, FDR），这是评估肽段鉴定结果统计置信度的关键技能。",
            "id": "4600241",
            "problem": "您正在分析用于通过数据库搜索进行蛋白质鉴定的级联靶标-诱饵数据库搜索所产生的串联质谱（MS/MS）肽段-谱图匹配（PSM）。每个PSM都有一个实值匹配得分和一个标签，该标签指示得分最高的匹配是来自靶标数据库还是诱饵数据库。假设采用标准的竞争性靶标-诱饵设置，其中每个谱图在整个级联数据库中仅保留其唯一的最高分候选匹配，并假设无效PSM具有靶标-诱饵对称性。使用基本定义：在某一得分阈值下，肽段-谱图匹配层面的假发现率（FDR）是在所有被接受的PSM中，假PSM的期望比例。接受规则使用严格不等式：保留得分严格大于阈值的PSM。\n\n给定以下按得分降序排列的PSM列表。每一项都报告一个标识符、一个得分和一个标签：\n- PSM $1$：得分 $72.4$，标签 靶标\n- PSM $2$：得分 $69.8$，标签 靶标\n- PSM $3$：得分 $68.1$，标签 靶标\n- PSM $4$：得分 $66.5$，标签 靶标\n- PSM $5$：得分 $64.2$，标签 靶标\n- PSM $6$：得分 $63.7$，标签 靶标\n- PSM $7$：得分 $61.9$，标签 靶标\n- PSM $8$：得分 $60.3$，标签 靶标\n- PSM $9$：得分 $58.8$，标签 靶标\n- PSM $10$：得分 $57.6$，标签 靶标\n- PSM $11$：得分 $56.1$，标签 靶标\n- PSM $12$：得分 $55.4$，标签 靶标\n- PSM $13$：得分 $52.7$，标签 诱饵\n- PSM $14$：得分 $51.9$，标签 靶标\n- PSM $15$：得分 $50.5$，标签 靶标\n- PSM $16$：得分 $49.8$，标签 诱饵\n- PSM $17$：得分 $49.1$，标签 靶标\n- PSM $18$：得分 $48.6$，标签 靶标\n- PSM $19$：得分 $47.3$，标签 靶标\n- PSM $20$：得分 $46.7$，标签 诱饵\n- PSM $21$：得分 $46.2$，标签 靶标\n- PSM $22$：得分 $45.9$，标签 靶标\n- PSM $23$：得分 $45.0$，标签 诱饵\n- PSM $24$：得分 $44.6$，标签 靶标\n- PSM $25$：得分 $43.8$，标签 靶标\n- PSM $26$：得分 $42.9$，标签 诱饵\n- PSM $27$：得分 $41.7$，标签 靶标\n- PSM $28$：得分 $40.5$，标签 诱饵\n- PSM $29$：得分 $39.8$，标签 靶标\n- PSM $30$：得分 $38.2$，标签 靶标\n\n任务：\n1) 从肽段-谱图匹配层面假发现率（FDR）的定义和靶标-诱饵假设出发，推导出一个在给定得分阈值下，用接受的靶标和诱饵PSM计数表示的FDR实用估计量。然后，使用该估计量计算当得分阈值为 $t_{0}=48.5$ 时的FDR。将此FDR报告为四舍五入到 $4$ 位有效数字的小数。\n\n2) 确定最小的得分截止值 $t_{\\ast}$（使用相同的得分单位），使得估计的PSM层面FDR小于或等于 $0.01$。仅使用上述严格不等式接受规则（保留得分严格大于阈值的PSM）。如果 $t_{\\ast}$ 与观察到的某个得分重合，则报告该精确得分；否则，报告四舍五入到 $4$ 位有效数字的 $t_{\\ast}$。\n\n您最终提交的答案必须仅为 $t_{\\ast}$ 的单个值，不带单位。请勿在最终答案框中包含任何额外的文本或中间结果。",
            "solution": "该问题要求为来自靶标-诱饵数据库搜索的肽段-谱图匹配（PSM）推导假发现率（FDR）估计量，并将其应用于给定的数据集。验证问题陈述是第一个强制性步骤。\n\n### 步骤 1：提取已知信息\n- 分析对象是串联质谱（MS/MS）的肽段-谱图匹配（PSM）。\n- 使用了级联靶标-诱饵数据库搜索方法。\n- 每个PSM拥有一个实值得分和一个标签（'靶标'或'诱饵'）。\n- 设置是竞争性靶标-诱饵搜索：每个谱图只保留唯一的最高分PSM。\n- 提供了对于无效（不正确）PSM的靶标-诱饵对称性假设。\n- PSM层面FDR的定义是：“在所有被接受的PSM中，假PSM的期望比例”。\n- 接受规则是严格不等式：如果一个PSM的得分严格大于阈值 $t$，则该PSM被接受。\n- 提供了一个包含 $30$ 个PSM的列表，按得分降序排列，并附有各自的得分和标签。\n- 任务1：推导一个FDR估计量，并计算在得分阈值为 $t_{0}=48.5$ 时的FDR值。\n- 任务2：确定最小的得分截止值 $t_{\\ast}$，使得估计的PSM层面FDR小于或等于 $0.01$。\n\n### 步骤 2：使用提取的已知信息进行验证\n该问题具有科学依据，描述了在基于质谱的蛋白质组学中控制假发现率的标准靶标-诱饵方法。这是生物信息学中一个基础且广泛使用的方法。所提供的定义、假设（竞争性搜索、无效匹配的对称性）和数据与既定实践一致。问题陈述清晰，提供了所有必要信息（PSM和标签的列表）以及明确、客观的任务。使用的术语是该领域的标准术语。该问题不违反任何科学原则，不基于错误的前提，是完全可形式化的，并且与蛋白质鉴定这一主题直接相关。不存在会妨碍得出唯一解的矛盾或缺失信息。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。开始求解。\n\n### 第1部分：FDR估计量的推导与计算\n\n问题将得分阈值 $t$ 下的假发现率（记为 $FDR(t)$）定义为在所有被接受的PSM中，假PSM的期望比例。\n设 $R(t)$ 为在阈值 $t$ 下被接受的PSM数量，设 $V(t)$ 为其中的假发现（不正确匹配）数量。那么FDR为\n$$FDR(t) = E\\left[ \\frac{V(t)}{R(t)} \\right]$$\n如果 $R(t) = 0$，则该分数为 $0$。\n\n在实践中，我们从观测数据中计算一个估计值 $\\widehat{FDR}(t)$。在蛋白质鉴定的背景下，“被接受的PSM”是指通过得分阈值的靶标PSM。诱饵PSM是一种用于估计假阳性的统计工具，不包括在最终报告的鉴定列表中。因此，被接受的发现集由得分大于 $t$ 的靶标PSM组成。这类PSM的数量，即 $R(t)$ 的估计值，是：\n$$\\hat{R}(t) = N_T(t) = |\\{\\text{PSM}_i \\mid \\text{得分}(\\text{PSM}_i)  t \\text{ 且 标签}(\\text{PSM}_i) = \\text{靶标}\\}|$$\n\n假发现的数量 $V(t)$ 是在这个被接受的靶标列表中不正确PSM的数量。这些是源自无效谱图（即在靶标数据库中不存在正确肽段序列的谱图）的靶标PSM。这些假阳性靶标匹配的数量，即 $FP_T(t)$，必须被估计。\n\n靶标-诱饵方法的核心假设是：对于一个无效谱图，其与诱饵数据库的最佳匹配的得分分布，与其与靶标数据库的最佳匹配的得分分布相同。在使用等大规模（一个标准假设）的级联数据库进行竞争性搜索时，一个无效谱图有同等机会匹配到靶标序列或诱饵序列。这种对称性意味着，在任何给定的得分阈值 $t$ 下，得分大于 $t$ 的假阳性靶标PSM的数量，约等于得分大于 $t$ 的诱饵PSM的数量。根据定义，诱饵PSM是不正确的匹配。设 $N_D(t)$ 为得分 $ t$ 的诱饵PSM的数量：\n$$N_D(t) = |\\{\\text{PSM}_i \\mid \\text{得分}(\\text{PSM}_i)  t \\text{ 且 标签}(\\text{PSM}_i) = \\text{诱饵}\\}|$$\n因此，我们对假发现数量的估计是 $\\hat{V}(t) = N_D(t)$。\n\n结合这些要素，推导出的PSM层面FDR的实用估计量为：\n$$\\widehat{FDR}(t) = \\frac{\\hat{V}(t)}{\\hat{R}(t)} = \\frac{N_D(t)}{N_T(t)}$$\n该估计量在 $N_T(t)  0$ 的条件下使用。如果 $N_T(t)=0$，则 $\\widehat{FDR}(t) = 0$。\n\n现在，我们计算得分阈值为 $t_{0}=48.5$ 时的FDR。我们必须计算得分严格大于 $48.5$ 的靶标和诱饵PSM的数量。通过检查所提供的列表：\n- 得分 $ 48.5$ 的PSM是PSM $1$到PSM $18$。\n- 在这个集合中，我们计算标签为“靶标”的PSM数量。它们是PSM 1-12、14、15、17和18。因此，$N_T(48.5) = 16$。\n- 我们计算标签为“诱饵”的PSM数量。它们是PSM 13和16。因此，$N_D(48.5) = 2$。\n- 在此阈值下估计的FDR是：\n$$\\widehat{FDR}(48.5) = \\frac{N_D(48.5)}{N_T(48.5)} = \\frac{2}{16} = \\frac{1}{8} = 0.125$$\n作为四舍五入到 $4$ 位有效数字的小数，结果是 $0.1250$。\n\n### 第2部分：得分截止值 $t_{\\ast}$ 的确定\n\n我们的任务是找到最小的得分截止值 $t_{\\ast}$，使得估计的PSM层面FDR小于或等于 $0.01$。这需要找到满足以下不等式的最小 $t_{\\ast}$：\n$$\\widehat{FDR}(t_{\\ast}) = \\frac{N_D(t_{\\ast})}{N_T(t_{\\ast})} \\le 0.01$$\n这个不等式可以重写为 $N_D(t_{\\ast}) \\le 0.01 \\times N_T(t_{\\ast})$。\n\n由于 $N_D(t_{\\ast})$ 必须是一个非负整数，我们可以分析这个条件。\n如果 $N_D(t_{\\ast}) \\ge 1$，不等式将要求 $1 \\le 0.01 \\times N_T(t_{\\ast})$，这意味着 $N_T(t_{\\ast}) \\ge 100$。\n通过检查所提供的 $30$ 个PSM的列表，靶标匹配的最大可能数量是 $24$。因此，用这个数据集不可能满足条件 $N_T(t_{\\ast}) \\ge 100$。\n这迫使我们得出结论，满足FDR标准的唯一方法是使 $N_D(t_{\\ast}) = 0$。\n\n条件 $N_D(t_{\\ast}) = 0$ 意味着没有诱饵PSM被接受。根据接受规则（得分 $ t_{\\ast}$），这意味着数据集中每个诱饵PSM的得分必须小于或等于 $t_{\\ast}$。这等同于要求阈值 $t_{\\ast}$ 大于或等于得分最高的诱饵PSM的得分。\n\n我们扫描列表以找到得分最高的诱饵PSM。\n- 从列表顶部看，第一个诱饵是PSM $13$，得分为 $52.7$。\n- 所有其他诱饵PSM（PSM $16$、$20$、$23$、$26$、$28$）的得分都更低。\n因此，最高的诱饵得分是 $52.7$。\n\n为确保 $N_D(t_{\\ast}) = 0$，我们必须设置阈值 $t_{\\ast}$，使得 $t_{\\ast} \\ge 52.7$。任何低于 $52.7$ 的阈值都会导致PSM $13$ 被接受（因为其得分 $52.7$ 将大于 $t_{\\ast}$），这将导致 $N_D(t_{\\ast}) \\ge 1$ 并违反FDR条件。\n\n我们寻求满足 $t_{\\ast} \\ge 52.7$ 的 *最小* 得分截止值 $t_{\\ast}$。所有有效阈值的集合是区间 $[52.7, \\infty)$。此集合中的最小值为 $52.7$。\n\n我们来验证这个选择。如果我们设置 $t_{\\ast} = 52.7$，被接受的PSM是那些得分 $ 52.7$ 的。这些是PSM 1到12，它们都是靶标。\n- $N_T(52.7) = 12$。\n- $N_D(52.7) = 0$。\n- $\\widehat{FDR}(52.7) = \\frac{0}{12} = 0$。\n条件 $0 \\le 0.01$ 得到满足。\n\n如果我们选择任何阈值 $t'$ 使得 $t'  52.7$，那么至少会有一个诱饵（PSM $13$）被包含在接受列表中。例如，对于阈值 $t' = 52.69$，我们将有 $N_D(t')=1$ 和 $N_T(t')=12$，得出 $\\widehat{FDR}(t') = 1/12 \\approx 0.0833$，这大于 $0.01$。\n\n因此，满足所需FDR标准的最小得分截止值是 $t_{\\ast} = 52.7$。根据问题说明，由于该值与一个观察到的得分重合，应报告其精确值。",
            "answer": "$$\\boxed{52.7}$$"
        }
    ]
}