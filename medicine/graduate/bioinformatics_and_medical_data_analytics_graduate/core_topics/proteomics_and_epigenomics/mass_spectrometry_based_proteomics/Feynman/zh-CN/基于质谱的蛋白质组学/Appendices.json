{
    "hands_on_practices": [
        {
            "introduction": "质谱分析的核心在于精确测量离子的质荷比（$m/z$）。本练习将带您从第一性原理出发，推导并计算一个肽段在不同电荷状态下的预期$m/z$值。通过这个实践，您将掌握电喷雾电离（ESI）质谱中一个最基本的换算关系，这对于解读原始谱图和理解肽段离子化过程至关重要。",
            "id": "4581547",
            "problem": "在一项使用电喷雾电离 (ESI) 的自下而上（bottom-up）质谱蛋白质组学实验中，肽离子主要以质子化物质的形式形成，表示为 $\\left[\\mathrm{M} + z\\mathrm{H}\\right]^{z+}$，其中 $\\mathrm{M}$ 是中性肽，$z$ 是整数电荷态。质荷比 $m/z$ 定义为离子的总质量除以其电荷大小，并以汤姆逊 (Th) 为单位报告，其中 $1$ 汤姆逊 (Th) 等于 $1$ 道尔顿 (Da) 每基本电荷。\n\n从核心定义出发：\n- 离子总质量等于中性肽的单同位素质量与电离过程中加上的加合物的质量之和。\n- 在 ESI 中，质子化过程为中性肽添加了 $z$ 个质子，每个质子的质量为 $m_p$。\n- 离子的电荷大小为整数 $z$。\n\n一个肽的单同位素中性质量 $M = 2345.678901$ Da，质子质量为 $m_p = 1.00727646688$ Da。使用上述原理，推导肽的 $m/z$ 作为 $M$、$m_p$ 和 $z$ 的函数的一般表达式，然后计算电荷态 $z=2$ 和 $z=3$ 时的预期 $m/z$ 值。\n\n用汤姆逊 (Th) 表示最终的 $m/z$ 值，并将答案四舍五入到六位有效数字。",
            "solution": "**求解推导**\n\n质荷比，我们表示为 $\\frac{m}{z}$，定义为离子的总质量 $m_{ion}$ 除以其电荷大小，电荷大小对应于以基本电荷为单位的整数 $z$。\n$$\n\\frac{m}{z} = \\frac{m_{ion}}{z}\n$$\n根据问题陈述，离子总质量 $m_{ion}$ 是肽的单同位素中性质量 $M$ 与加合物质量之和。在 ESI 中，质子化过程添加了 $z$ 个质子，每个质子质量为 $m_p$。因此，加合物的总质量为 $z \\cdot m_p$。\n离子质量的表达式为：\n$$\nm_{ion} = M + z \\cdot m_p\n$$\n将此 $m_{ion}$ 的表达式代入质荷比方程，得到肽的 $\\frac{m}{z}$ 作为 $M$、$m_p$ 和 $z$ 的函数的一般表达式：\n$$\n\\frac{m}{z} = \\frac{M + z \\cdot m_p}{z}\n$$\n这个一般表达式也可以写成：\n$$\n\\frac{m}{z} = \\frac{M}{z} + m_p\n$$\n现在，我们将使用这个推导出的公式，为给定的肽（$M = 2345.678901$ Da 和 $m_p = 1.00727646688$ Da）计算在电荷态 $z=2$ 和 $z=3$ 时的预期 $\\frac{m}{z}$ 值。结果的单位将是汤姆逊 (Th)。\n\n**计算电荷态 $z=2$ 的情况：**\n对于 $z=2$，质荷比 $(\\frac{m}{z})_{z=2}$ 为：\n$$\n\\left(\\frac{m}{z}\\right)_{z=2} = \\frac{2345.678901 + 2 \\cdot 1.00727646688}{2}\n$$\n首先，计算两个质子的质量：\n$$\n2 \\cdot 1.00727646688 = 2.01455293376\n$$\n接下来，计算离子的总质量：\n$$\nm_{ion, z=2} = 2345.678901 + 2.01455293376 = 2347.69345393376\n$$\n最后，计算质荷比：\n$$\n\\left(\\frac{m}{z}\\right)_{z=2} = \\frac{2347.69345393376}{2} = 1173.84672696688\n$$\n将此值四舍五入到六位有效数字，得到 $1173.85$。\n\n**计算电荷态 $z=3$ 的情况：**\n对于 $z=3$，质荷比 $(\\frac{m}{z})_{z=3}$ 为：\n$$\n\\left(\\frac{m}{z}\\right)_{z=3} = \\frac{2345.678901 + 3 \\cdot 1.00727646688}{3}\n$$\n首先，计算三个质子的质量：\n$$\n3 \\cdot 1.00727646688 = 3.02182940064\n$$\n接下来，计算离子的总质量：\n$$\nm_{ion, z=3} = 2345.678901 + 3.02182940064 = 2348.70073040064\n$$\n最后，计算质荷比：\n$$\n\\left(\\frac{m}{z}\\right)_{z=3} = \\frac{2348.70073040064}{3} = 782.90024346688\n$$\n将此值四舍五入到六位有效数字，得到 $782.900$。\n\n计算出的 $\\frac{m}{z}$ 值对于 $z=2$ 是 $1173.85$ Th，对于 $z=3$ 是 $782.900$ Th。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1173.85  782.900 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在现代定量蛋白质组学中，同重异位标签（TMT）技术应用广泛，但也面临着共分离干扰导致的“比率压缩”问题。本练习构建了一个基于物理现实的模型，用以量化当目标肽段与干扰物一同被选择和碎裂时，其报告离子强度的失真程度。通过推导并计算这种偏差，您将深刻理解定量数据准确性的关键挑战之一，并学会如何从数学上描述和评估实验伪影。",
            "id": "4581574",
            "problem": "考虑在多重液相色谱-串联质谱 (LC–MS/MS) 实验中使用串联质谱标签 (TMT) 试剂进行同位素标记。定量依赖于串联质谱 (MS/MS) 中产生的报告离子的强度，在标准的比例假设下，报告离子强度与分离和碎裂的前体离子的数量成线性关系。当质谱仪使用有限的分离窗口分离前体离子时，共洗脱的肽段可能会被共分离。此时，测得的报告离子强度来自于目标肽段和一种或多种干扰物的混合物。假设以下基于离子产生和检测的线性关系的物理现实模型：\n\n- 设目标肽段在两个 TMT 通道中的真实报告离子强度为 $T_1$ 和 $T_2$，真实比值为 $R = T_1 / T_2$。\n- 设一个干扰肽段被共分离和共碎裂。其在两个通道中的报告离子分布用 $q_1$ 和 $q_2$ 表示，其中 $q_1 + q_2 = 1$。对于非差异表达的干扰物，取 $q_1 = q_2 = \\frac{1}{2}$。\n- 将共分离干扰水平 $\\phi \\in [0,1)$ 定义为谱图中源自干扰物的总 MS/MS 报告信号的分数。在报告离子生成的线性关系下，通道 1 和 2 中观测到的报告离子强度可以建模为凸混合：\n$$I_1 = S \\left[(1-\\phi) p_1 + \\phi q_1 \\right], \\quad I_2 = S \\left[(1-\\phi) p_2 + \\phi q_2 \\right],$$\n其中 $S$ 是谱图中的总报告信号，$p_1$ 和 $p_2$ 表示目标肽段在各通道上的报告离子分布，且 $p_1 + p_2 = 1$。真实比值 $R$ 意味着 $p_1 = \\frac{R}{1+R}$ 和 $p_2 = \\frac{1}{1+R}$。\n\n从这些定义和报告离子强度与分离离子数量成线性关系的基本假设出发，推导观测比值 $R_{\\mathrm{obs}} = \\frac{I_1}{I_2}$ 作为 $R$、$\\phi$、$q_1$ 和 $q_2$ 的函数的解析表达式。然后，将情况特殊化为 $q_1 = q_2 = \\frac{1}{2}$，并推导乘性偏差因子 $b = \\frac{R_{\\mathrm{obs}}}{R}$，该因子量化了由共分离干扰引起的比值压缩。\n\n最后，对真实比值 $R = 8$ 和干扰水平 $\\phi = 0.30$ 计算该偏差因子。将最终答案四舍五入至四位有效数字，并以纯数字（无单位）形式表示。",
            "solution": "### 详细解答\n按照题目要求，推导过程分为四个部分。首先，我们推导观测比值 $R_{\\mathrm{obs}}$ 的通用表达式。其次，我们将此表达式特殊化为非差异表达干扰物的情况。第三，我们推导乘性偏差因子 $b$。最后，我们用给定的数值计算这个因子。\n\n观测比值 $R_{\\mathrm{obs}}$ 定义为观测强度 $I_1$ 和 $I_2$ 的比值：\n$$R_{\\mathrm{obs}} = \\frac{I_1}{I_2} = \\frac{S \\left[(1-\\phi) p_1 + \\phi q_1 \\right]}{S \\left[(1-\\phi) p_2 + \\phi q_2 \\right]}$$\n总信号强度 $S$ 是分子和分母的公因子，因此可以消掉：\n$$R_{\\mathrm{obs}} = \\frac{(1-\\phi) p_1 + \\phi q_1}{(1-\\phi) p_2 + \\phi q_2}$$\n问题指出，目标肽段的报告离子分布分数 $p_1$ 和 $p_2$ 通过 $p_1 = \\frac{R}{1+R}$ 和 $p_2 = \\frac{1}{1+R}$ 与真实比值 $R$ 相关。将这些代入 $R_{\\mathrm{obs}}$ 的表达式中得到：\n$$R_{\\mathrm{obs}} = \\frac{(1-\\phi) \\frac{R}{1+R} + \\phi q_1}{(1-\\phi) \\frac{1}{1+R} + \\phi q_2}$$\n为了消去分子和分母内部的分数，我们将两者都乘以 $(1+R)$：\n$$R_{\\mathrm{obs}} = \\frac{(1-\\phi) R + \\phi q_1 (1+R)}{(1-\\phi) + \\phi q_2 (1+R)}$$\n这就是观测比值 $R_{\\mathrm{obs}}$ 作为 $R$、$\\phi$、$q_1$ 和 $q_2$ 的函数的通用解析表达式。\n\n接下来，我们将情况特殊化为干扰肽段非差异表达，即其信号在各通道间均匀分布：$q_1 = q_2 = \\frac{1}{2}$。将这些值代入 $R_{\\mathrm{obs}}$ 的通用表达式中：\n$$R_{\\mathrm{obs}} = \\frac{(1-\\phi) R + \\phi (\\frac{1}{2}) (1+R)}{(1-\\phi) + \\phi (\\frac{1}{2}) (1+R)}$$\n为了简化这个表达式，我们首先展开分子和分母中的项。\n分子：$(1-\\phi)R + \\frac{1}{2}\\phi(1+R) = R - R\\phi + \\frac{1}{2}\\phi + \\frac{1}{2}R\\phi = R - \\frac{1}{2}R\\phi + \\frac{1}{2}\\phi$\n分母：$(1-\\phi) + \\frac{1}{2}\\phi(1+R) = 1 - \\phi + \\frac{1}{2}\\phi + \\frac{1}{2}R\\phi = 1 - \\frac{1}{2}\\phi + \\frac{1}{2}R\\phi$\n所以，$R_{\\mathrm{obs}}$ 的表达式变为：\n$$R_{\\mathrm{obs}} = \\frac{R - \\frac{1}{2}R\\phi + \\frac{1}{2}\\phi}{1 - \\frac{1}{2}\\phi + \\frac{1}{2}R\\phi}$$\n将分子和分母同乘以 $2$ 以消除分数，得到一个更简洁的形式：\n$$R_{\\mathrm{obs}} = \\frac{2R - R\\phi + \\phi}{2 - \\phi + R\\phi}$$\n\n第三个任务是推导乘性偏差因子 $b = \\frac{R_{\\mathrm{obs}}}{R}$。我们使用上面推导出的 $R_{\\mathrm{obs}}$ 的简化表达式：\n$$b = \\frac{R_{\\mathrm{obs}}}{R} = \\frac{1}{R} \\left( \\frac{2R - R\\phi + \\phi}{2 - \\phi + R\\phi} \\right)$$\n将因子 $\\frac{1}{R}$ 分配到分数的分子中：\n$$b = \\frac{\\frac{1}{R}(2R - R\\phi + \\phi)}{2 - \\phi + R\\phi} = \\frac{2 - \\phi + \\frac{\\phi}{R}}{2 - \\phi + R\\phi}$$\n这就是乘性偏差因子 $b$ 作为真实比值 $R$ 和干扰水平 $\\phi$ 的函数的解析表达式。该因子量化了“比值压缩”效应。对于任何 $R > 1$ 和 $\\phi > 0$，分母中的项 $R\\phi$ 大于分子中的项 $\\frac{\\phi}{R}$，导致 $b  1$，这证实了观测到的比值被压缩向 1。\n\n最后，我们计算真实比值 $R = 8$ 和干扰水平 $\\phi = 0.30$ 时的偏差因子 $b$。\n将这些值代入 $b$ 的表达式中：\n$$b = \\frac{2 - 0.30 + \\frac{0.30}{8}}{2 - 0.30 + (8)(0.30)}$$\n我们计算表达式的各个部分：\n$$b = \\frac{1.70 + 0.0375}{1.70 + 2.40}$$\n$$b = \\frac{1.7375}{4.10}$$\n进行除法运算：\n$$b \\approx 0.423780487...$$\n问题要求将结果四舍五入到四位有效数字。第五位有效数字是 $8$，所以我们将第四位数字向上取整。\n$$b \\approx 0.4238$$",
            "answer": "$$\n\\boxed{0.4238}\n$$"
        },
        {
            "introduction": "蛋白质组学数据分析的核心挑战是从海量的肽段-谱图匹配（PSM）中可靠地识别出真实的肽段和蛋白质，同时控制假阳性。本练习要求您通过编程实现一个完整的多层次错误发现率（FDR）控制流程，该流程基于靶标-诱饵策略和经典的Benjamini–Hochberg方法。这项实践将让您亲手处理从原始分数到统计学上可信的蛋白质列表的全过程，这是生物信息学分析中的一项基本功。",
            "id": "4581563",
            "problem": "您将收到多个测试场景，每个场景包含一个按实值分数降序排列的肽-谱匹配（Peptide–Spectrum Match, PSM）条目列表。每个PSM条目有四个字段：一个分数，一个指示其是否来自伪库的布尔标志（$\\text{is\\_decoy} \\in \\{\\text{True}, \\text{False}\\}$），一个肽段标识符（字符串），以及一个蛋白质标识符（字符串）。您必须编写一个程序，从基于质谱的蛋白质组学和统计推断的基本原理出发，使用 Benjamini–Hochberg (BH) 程序来计算肽段水平和蛋白质水平的q值。\n\n该任务的科学基础如下：\n\n- 靶标-伪库竞争（Target–Decoy Competition, TDC）：在靶标-伪库搜索中，构建伪库是为了近似分数的零分布，而靶标代表候选的真实鉴定结果。伪库分数的分布提供了一个经验零模型。\n\n- 来自零分布的经验p值：对于每个观测到的分数 $s$，经验单侧p值定义为观测到大于或等于 $s$ 的伪库分数的尾部概率。为了在有限采样下避免零p值，应用一种保守平滑处理，\n$$\np(s) = \\frac{d(s) + 1}{N_{\\text{decoy}} + 1},\n$$\n其中 $d(s)$ 是分数 $\\ge s$ 的伪PSM数量，而 $N_{\\text{decoy}}$ 是数据集中伪PSM的总数。如果 $N_{\\text{decoy}} = 0$，则对所有 $s$ 设定 $p(s) = 1$。\n\n- 肽段的多证据聚合：一个肽段可能被多个PSM观测到。将从 $m$ 个PSM中选择最小PSM p值的过程视为一个族系选择，并应用针对最小统计量的Šidák校正来获得一个有效的肽段水平p值，\n$$\np_{\\text{pep}} = 1 - \\left(1 - \\min_{1 \\le i \\le m} p_i\\right)^m,\n$$\n其中 $p_i$ 是分配给该肽段的PSM水平p值。只有靶标PSM对一个肽段的 $m$ 和多重集 $\\{p_i\\}$ 有贡献。没有靶标PSM的肽段被排除在靶标肽段水平的推断之外。\n\n- 蛋白质的多证据聚合：一个蛋白质可能被多个肽段观测到。同样，将从 $k$ 个肽段中选择最小肽段p值的过程视为一个族系选择，并应用Šidák校正，\n$$\np_{\\text{prot}} = 1 - \\left(1 - \\min_{1 \\le j \\le k} p_{\\text{pep},j}\\right)^k,\n$$\n其中 $p_{\\text{pep},j}$ 是分配给该蛋白质的肽段水平p值。只有靶标肽段（即至少有一个靶标PSM的肽段）对一个蛋白质的 $k$ 和多重集 $\\{p_{\\text{pep},j}\\}$ 有贡献。没有靶标肽段的蛋白质被排除在靶标蛋白质水平的推断之外。\n\n- Benjamini–Hochberg (BH) 假发现率控制：给定 $n$ 个p值 $\\{p_1,\\dots,p_n\\}$（在感兴趣的水平上，每个靶标实体一个），将它们按升序排序得到 $p_{(1)} \\le p_{(2)} \\le \\cdots \\le p_{(n)}$。定义BH校正值为\n$$\nw_i = \\frac{n}{i}\\, p_{(i)},\n$$\n相应的q值则为\n$$\nq_{(i)} = \\min\\left(1, \\min_{j \\ge i} w_j\\right),\n$$\n确保 $q_{(1)} \\le q_{(2)} \\le \\cdots \\le q_{(n)}$。将这些q值映射回原始的实体顺序。所有q值必须以 $[0,1]$ 区间内的小数形式返回。\n\n在计算经验p值时，您必须按如下方式处理分数相同的情况：在任何分数相同的区块内，为所有PSM分配相同的尾部伪库计数 $d(s)$，该值等于分数大于或等于该分数的伪库数量（计算分数高于和处于该相同分数区块内的伪库），并对该区块内的所有PSM使用该 $d(s)$。\n\n只有靶标实体在肽段和蛋白质水平上进行检验。伪库仅用于估计经验p值。对于输出顺序，按肽段标识符的字典序报告肽段水平的结果，按蛋白质标识符的字典序报告蛋白质水平的结果。\n\n您的程序必须实现上述逻辑，并为以下测试套件生成结果。每个测试用例由一组已按分数降序排列的PSM条目和一个水平指示符（字符串“peptide”或“protein”）指定，该指示符明确了必须计算和返回q值的目标水平。每个测试用例的输出是一个浮点q值列表，按上文指定的方式排序。\n\n测试套件（每个PSM条目是 $(\\text{score}, \\text{is\\_decoy}, \\text{peptide}, \\text{protein})$ 形式的四元组）：\n\n- 测试用例 $1$（在混合靶标-伪库数据集上进行肽段水平分析，含相同分数）：\n  - 水平：“peptide”\n  - PSM（按分数降序排列）：\n    - $(98.1, \\text{False}, \\text{\"PEPA\"}, \\text{\"P1\"})$\n    - $(97.5, \\text{True}, \\text{\"DECOY1\"}, \\text{\"DPROT1\"})$\n    - $(96.8, \\text{False}, \\text{\"PEPB\"}, \\text{\"P2\"})$\n    - $(96.8, \\text{True}, \\text{\"DECOY2\"}, \\text{\"DPROT2\"})$\n    - $(95.0, \\text{False}, \\text{\"PEPA\"}, \\text{\"P1\"})$\n    - $(94.2, \\text{False}, \\text{\"PEPC\"}, \\text{\"P1\"})$\n    - $(94.2, \\text{True}, \\text{\"DECOY3\"}, \\text{\"DPROT3\"})$\n    - $(92.0, \\text{False}, \\text{\"PEPD\"}, \\text{\"P3\"})$\n    - $(90.1, \\text{True}, \\text{\"DECOY4\"}, \\text{\"DPROT4\"})$\n    - $(89.9, \\text{False}, \\text{\"PEPB\"}, \\text{\"P2\"})$\n\n- 测试用例 $2$（在与测试用例 $1$ 相同的数据集上进行蛋白质水平分析）：\n  - 水平：“protein”\n  - PSM：与测试用例 $1$ 相同。\n\n- 测试用例 $3$（在含有相同分数和每个蛋白质多个肽段的数据集上进行肽段水平分析）：\n  - 水平：“peptide”\n  - PSM（按分数降序排列）：\n    - $(99.0, \\text{False}, \\text{\"PEP1\"}, \\text{\"PR1\"})$\n    - $(99.0, \\text{True}, \\text{\"D1\"}, \\text{\"DR1\"})$\n    - $(98.0, \\text{False}, \\text{\"PEP2\"}, \\text{\"PR1\"})$\n    - $(97.0, \\text{True}, \\text{\"D2\"}, \\text{\"DR2\"})$\n    - $(97.0, \\text{False}, \\text{\"PEP3\"}, \\text{\"PR2\"})$\n    - $(96.0, \\text{True}, \\text{\"D3\"}, \\text{\"DR3\"})$\n    - $(95.0, \\text{False}, \\text{\"PEP2\"}, \\text{\"PR1\"})$\n    - $(94.0, \\text{False}, \\text{\"PEP4\"}, \\text{\"PR3\"})$\n\n- 测试用例 $4$（在一个边界数据集上进行肽段水平分析，该数据集全为伪库，不产生靶标肽段）：\n  - 水平：“peptide”\n  - PSM（按分数降序排列）：\n    - $(75.0, \\text{True}, \\text{\"DPA\"}, \\text{\"DP1\"})$\n    - $(74.5, \\text{True}, \\text{\"DPB\"}, \\text{\"DP2\"})$\n    - $(74.0, \\text{True}, \\text{\"DPC\"}, \\text{\"DP3\"})$\n    - $(73.5, \\text{True}, \\text{\"DPD\"}, \\text{\"DP4\"})$\n\n- 测试用例 $5$（在与测试用例 $4$ 相同的全伪库数据集上进行蛋白质水平分析，不产生靶标蛋白质）：\n  - 水平：“protein”\n  - PSM：与测试用例 $4$ 相同。\n\n所有返回的q值必须是小数（而非百分比）。您的程序应生成单行输出，其中包含一个以方括号括起来的、逗号分隔的结果列表，每个元素对应一个测试用例的结果。对于每个测试用例，该元素必须是一个浮点q值列表，按所要求水平的实体标识符的字典序排列。例如，一个包含三个测试用例的输出应类似于 $[\\,[q\\_1, q\\_2],\\,[q\\_3],\\,[\\,]\\,]$，其中空列表表示在所要求的水平上没有靶标实体。",
            "solution": "该解决方案被设计为一个多步流水线，系统地将输入的肽-谱匹配（PSM）数据转换为最终的q值。过程如下：\n\n**步骤1：为每个PSM计算经验p值**\n首先，我们为每个PSM（包括靶标和伪库）计算一个经验p值。此步骤的基础是从伪PSM中经验性估计出的分数零分布。问题将分数 $s$ 的p值定义为：\n$$\np(s) = \\frac{d(s) + 1}{N_{\\text{decoy}} + 1}\n$$\n其中 $N_{\\text{decoy}}$ 是伪PSM的总数，而 $d(s)$ 是分数大于或等于 $s$ 的伪PSM数量。在分子和分母上加1是一种伪计数，以防止p值为零。如果 $N_{\\text{decoy}}=0$，则所有p值均设为1。\n由于输入的PSM列表已按分数降序排列，我们可以高效地计算每个分数的 $d(s)$。我们创建一个排序好的伪库分数数组。对于任何给定的分数 $s$，可以使用二分查找（例如`numpy.searchsorted`）快速找到分数 $\\ge s$ 的伪库数量。此方法能正确处理分数相同的情况，因为所有具有相同分数 $s$ 的PSM自然会被赋予相同的 $d(s)$ 值。\n\n**步骤2：肽段水平p值聚合**\n一个给定的肽段序列可能被多个PSM鉴定。为了给每个唯一的靶标肽段获得一个单一的p值，我们必须聚合其相应靶标PSM的证据。问题指定使用针对最小p值统计量的Šidák校正。如果一个肽段由 $m$ 个靶标PSM鉴定，其对应的p值为 $\\{p_1, p_2, \\dots, p_m\\}$，则其聚合后的肽段水平p值为：\n$$\np_{\\text{pep}} = 1 - \\left(1 - \\min_{1 \\le i \\le m} p_i\\right)^m\n$$\n与任何靶标PSM都无关的肽段被排除在此分析之外。我们首先按肽段标识符将所有靶标PSM的p值分组，然后对每组应用此公式，以得出一组唯一的靶标肽段p值。\n\n**步骤3：蛋白质水平p值聚合（如果需要）**\n如果分析水平是“protein”，则执行一个类似的聚合步骤。一个蛋白质由一组肽段鉴定。为了得到一个单一的蛋白质水平p值，我们聚合其组成的靶标肽段的p值。如果一个蛋白质由 $k$ 个唯一的靶标肽段鉴定，其p值为 $\\{p_{\\text{pep},1}, \\dots, p_{\\text{pep},k}\\}$，则其聚合后的蛋白质水平p值为：\n$$\np_{\\text{prot}} = 1 - \\left(1 - \\min_{1 \\le j \\le k} p_{\\text{pep},j}\\right)^k\n$$\n为实现这一点，我们首先将每个蛋白质映射到其唯一的靶标肽段集合。然后，使用在步骤2中计算的肽段水平p值，对每个蛋白质应用该公式。与任何靶标肽段都无关的蛋白质被排除在外。\n\n**步骤4：Benjamini-Hochberg q值计算**\n最后一步是使用Benjamini-Hochberg (BH) 程序对计算出的p值（肽段或蛋白质水平）进行多重假设检验校正。给定 $n$ 个靶标实体的p值，将它们按升序排序：$p_{(1)} \\le p_{(2)} \\le \\cdots \\le p_{(n)}$。\n第 $i$ 个排序后p值的BH校正q值为：\n$$\nq_{(i)} = \\min\\left(1, \\min_{j \\ge i} \\frac{n}{j} p_{(j)}\\right)\n$$\n此公式确保所得的q值是单调非递减的（$q_{(1)} \\le q_{(2)} \\le \\cdots \\le q_{(n)}$）。在计算上，这可以通过从 $i=n$ 到 $1$ 反向迭代来高效实现，计算项 $w_i = \\frac{n}{i}p_{(i)}$ 并跟踪累积最小值，然后将其上限设为1。计算后，将q值映射回其原始的实体标识符。\n\n**最终输出生成**\n将靶标实体的q值按其标识符（肽段或蛋白质名称）的字典序排序，为每个测试用例生成最终列表，以符合问题规范的要求。对套件中的每个测试用例重复整个过程。最终输出是一个列表，其中包含每个测试用例的有序q值列表。",
            "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the q-value calculation problem for the provided test suite.\n    The solution is self-contained within this function.\n    \"\"\"\n\n    def benjamini_hochberg(p_values_dict):\n        \"\"\"\n        Computes q-values from p-values using the Benjamini-Hochberg procedure.\n\n        Args:\n            p_values_dict: A dictionary mapping entity IDs to their p-values.\n\n        Returns:\n            A list of q-values, sorted lexicographically by entity ID.\n        \"\"\"\n        if not p_values_dict:\n            return []\n        \n        # Sort entities by p-value in ascending order\n        p_val_list = sorted(p_values_dict.items(), key=lambda item: item[1])\n        n = len(p_val_list)\n\n        # Calculate q-values using the cumulative minimum approach\n        q_values_sorted = [0.0] * n\n        min_w = float('inf')\n        for i in range(n - 1, -1, -1):\n            rank = i + 1\n            p_val = p_val_list[i][1]\n            w_i = (n / rank) * p_val\n            min_w = min(min_w, w_i)\n            q_values_sorted[i] = min(1.0, min_w)\n\n        # Map q-values back to their original IDs\n        q_values_map = {p_val_list[i][0]: q_values_sorted[i] for i in range(n)}\n        \n        # Return q-values sorted by entity ID\n        sorted_ids = sorted(q_values_map.keys())\n        final_q_values = [q_values_map[id] for id in sorted_ids]\n        \n        return final_q_values\n\n    def calculate_protein_p_values(psms_with_pvals, peptide_p_values):\n        \"\"\"\n        Aggregates peptide-level p-values to protein-level p-values.\n\n        Args:\n            psms_with_pvals: A list of (PSM_tuple, p_value) pairs.\n            peptide_p_values: A dictionary mapping peptide IDs to their p-values.\n\n        Returns:\n            A dictionary mapping protein IDs to their aggregated p-values.\n        \"\"\"\n        protein_to_peptides = defaultdict(set)\n        target_psms = [p for p in psms_with_pvals if not p[0][1]]\n        \n        for psm_tuple, _ in target_psms:\n            peptide_id = psm_tuple[2]\n            protein_id = psm_tuple[3]\n            # A peptide contributes to a protein only if it's a target peptide\n            if peptide_id in peptide_p_values:\n                protein_to_peptides[protein_id].add(peptide_id)\n\n        protein_p_values = {}\n        for prot_id, pep_ids in protein_to_peptides.items():\n            pep_pvals_for_prot = [peptide_p_values[pid] for pid in pep_ids]\n            if not pep_pvals_for_prot:\n                continue\n            \n            k = len(pep_pvals_for_prot)\n            p_pep_min = min(pep_pvals_for_prot)\n            p_prot = 1.0 - (1.0 - p_pep_min)**k\n            protein_p_values[prot_id] = p_prot\n            \n        return protein_p_values\n\n    def calculate_peptide_p_values(psms_with_pvals):\n        \"\"\"\n        Aggregates PSM-level p-values to peptide-level p-values.\n\n        Args:\n            psms_with_pvals: A list of (PSM_tuple, p_value) pairs.\n\n        Returns:\n            A dictionary mapping peptide IDs to their aggregated p-values.\n        \"\"\"\n        peptides_to_psm_pvals = defaultdict(list)\n        target_psms = [p for p in psms_with_pvals if not p[0][1]]\n\n        for psm_tuple, p_val in target_psms:\n            peptide_id = psm_tuple[2]\n            peptides_to_psm_pvals[peptide_id].append(p_val)\n        \n        peptide_p_values = {}\n        for pep_id, p_vals in peptides_to_psm_pvals.items():\n            m = len(p_vals)\n            p_min = min(p_vals)\n            p_pep = 1.0 - (1.0 - p_min)**m\n            peptide_p_values[pep_id] = p_pep\n            \n        return peptide_p_values\n\n    def calculate_psm_p_values(psms):\n        \"\"\"\n        Calculates empirical p-values for all PSMs.\n\n        Args:\n            psms: A list of PSM tuples (score, is_decoy, peptide, protein).\n\n        Returns:\n            A list of (PSM_tuple, p_value) pairs.\n        \"\"\"\n        decoy_scores = [p[0] for p in psms if p[1]]\n        N_decoy = len(decoy_scores)\n\n        if N_decoy == 0:\n            return [(psm, 1.0) for psm in psms]\n\n        decoy_scores_asc = np.array(sorted(decoy_scores))\n        \n        psms_with_pvals = []\n        for psm in psms:\n            score = psm[0]\n            # Num decoys with score >= s is N_decoy - (num decoys with score  s)\n            num_less = np.searchsorted(decoy_scores_asc, score, side='left')\n            d_s = N_decoy - num_less\n            p_val = (d_s + 1.0) / (N_decoy + 1.0)\n            psms_with_pvals.append((psm, p_val))\n            \n        return psms_with_pvals\n\n    def calculate_q_values(psms, level):\n        \"\"\"\n        Orchestrates the full q-value calculation pipeline.\n\n        Args:\n            psms: A list of PSM tuples.\n            level: A string, either \"peptide\" or \"protein\".\n\n        Returns:\n            A list of final q-values, sorted by entity ID.\n        \"\"\"\n        # Step 1: Calculate PSM p-values\n        psms_with_pvals = calculate_psm_p_values(psms)\n\n        # Step 2: Calculate peptide-level p-values\n        peptide_p_values = calculate_peptide_p_values(psms_with_pvals)\n        if not peptide_p_values:\n            return []\n\n        if level == \"peptide\":\n            # Step 4 (peptide level): Compute q-values from peptide p-values\n            return benjamini_hochberg(peptide_p_values)\n        \n        elif level == \"protein\":\n            # Step 3: Calculate protein-level p-values\n            protein_p_values = calculate_protein_p_values(psms_with_pvals, peptide_p_values)\n            if not protein_p_values:\n                return []\n            # Step 4 (protein level): Compute q-values from protein p-values\n            return benjamini_hochberg(protein_p_values)\n        \n        return []\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([\n            (98.1, False, \"PEPA\", \"P1\"), (97.5, True, \"DECOY1\", \"DPROT1\"),\n            (96.8, False, \"PEPB\", \"P2\"), (96.8, True, \"DECOY2\", \"DPROT2\"),\n            (95.0, False, \"PEPA\", \"P1\"), (94.2, False, \"PEPC\", \"P1\"),\n            (94.2, True, \"DECOY3\", \"DPROT3\"), (92.0, False, \"PEPD\", \"P3\"),\n            (90.1, True, \"DECOY4\", \"DPROT4\"), (89.9, False, \"PEPB\", \"P2\")\n        ], \"peptide\"),\n        ([\n            (98.1, False, \"PEPA\", \"P1\"), (97.5, True, \"DECOY1\", \"DPROT1\"),\n            (96.8, False, \"PEPB\", \"P2\"), (96.8, True, \"DECOY2\", \"DPROT2\"),\n            (95.0, False, \"PEPA\", \"P1\"), (94.2, False, \"PEPC\", \"P1\"),\n            (94.2, True, \"DECOY3\", \"DPROT3\"), (92.0, False, \"PEPD\", \"P3\"),\n            (90.1, True, \"DECOY4\", \"DPROT4\"), (89.9, False, \"PEPB\", \"P2\")\n        ], \"protein\"),\n        ([\n            (99.0, False, \"PEP1\", \"PR1\"), (99.0, True, \"D1\", \"DR1\"),\n            (98.0, False, \"PEP2\", \"PR1\"), (97.0, True, \"D2\", \"DR2\"),\n            (97.0, False, \"PEP3\", \"PR2\"), (96.0, True, \"D3\", \"DR3\"),\n            (95.0, False, \"PEP2\", \"PR1\"), (94.0, False, \"PEP4\", \"PR3\")\n        ], \"peptide\"),\n        ([\n            (75.0, True, \"DPA\", \"DP1\"), (74.5, True, \"DPB\", \"DP2\"),\n            (74.0, True, \"DPC\", \"DP3\"), (73.5, True, \"DPD\", \"DP4\")\n        ], \"peptide\"),\n        ([\n            (75.0, True, \"DPA\", \"DP1\"), (74.5, True, \"DPB\", \"DP2\"),\n            (74.0, True, \"DPC\", \"DP3\"), (73.5, True, \"DPD\", \"DP4\")\n        ], \"protein\")\n    ]\n\n    all_results = []\n    for psms, level in test_cases:\n        result = calculate_q_values(psms, level)\n        all_results.append(result)\n\n    # Format the final output string exactly as required.\n    # str() on a list adds spaces, so we build the string manually\n    # to avoid them between list items, as per problem description parsing.\n    # On second thought, the example [q_1, q_2] does have a space.\n    # But the outer list [...,...] does not. `','.join(map(str,...` is correct.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}