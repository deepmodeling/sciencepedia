{
    "hands_on_practices": [
        {
            "introduction": "在拟合 Cox 模型之后，一个核心任务是解释其输出，并量化我们估计的不确定性。风险比（Hazard Ratio, HR）的点估计本身不足以进行稳健的科学推断；我们还需要一个置信区间来评估其统计精度。这个练习将指导您完成一个基本但至关重要的实践：使用对数-风险尺度上的 Wald 方法为风险比计算置信区间，这是解读和报告生存分析结果的一项基础技能 。",
            "id": "4551012",
            "problem": "一项转化肿瘤学研究使用Cox比例风险模型（CPHM）分析了转移性结直肠癌患者的总生存期。令协变量$X$表示一个与上皮-间质转化相关的基因的标准化信使核糖核酸（mRNA）表达得分，该得分在队列中经过缩放，均值为$0$，方差为$1$。在CPHM下，具有协变量值$x$的患者的风险率建模为$h(t \\mid x) = h_{0}(t)\\,\\exp(x\\,\\beta_{1})$，其中$h_{0}(t)$是基线风险率，$\\beta_{1}$是$X$的回归系数。最大偏似然估计量（MPLE）$\\hat{\\beta}_{1}$被用于推断，在偏似然的标准正则性条件下，它渐近服从正态分布，其均值为$\\beta_{1}$，方差由观测到的Fisher信息的逆给出。\n\n假设从拟合模型中得到的估计系数及其估计方差分别为$\\hat{\\beta}_{1} = 0.37$和$\\widehat{\\mathrm{Var}}(\\hat{\\beta}_{1}) = 0.0484$。利用$\\hat{\\beta}_{1}$的渐近正态性以及$X$每增加一个单位的风险比为$\\exp(\\beta_{1})$这一事实，通过在对数尺度上进行计算然后进行适当的变换，推导出风险比的双侧95% Wald置信区间。计算该区间的上端点。使用对应于水平$\\alpha = 0.05$的标准正态分位数，并将最终答案表示为一个纯数。将您的答案四舍五入到四位有效数字。",
            "solution": "该问题要求计算风险比（$\\mathrm{HR}$）的双侧95% Wald置信区间的上端点。在Cox比例风险模型$h(t \\mid x) = h_{0}(t)\\,\\exp(x\\,\\beta_{1})$的背景下，对于协变量$X$每增加一个单位，风险比定义为$\\mathrm{HR} = \\exp(\\beta_{1})$。\n\n如问题中所述，标准方法是首先为回归系数$\\beta_{1}$构建一个置信区间，然后变换其端点以获得风险比的置信区间。风险比的对数为$\\ln(\\mathrm{HR}) = \\ln(\\exp(\\beta_{1})) = \\beta_{1}$。因此，我们将在这个“对数尺度”上构建置信区间。\n\n最大偏似然估计量（MPLE）$\\hat{\\beta}_{1}$是渐近正态分布的。$\\beta_{1}$的一个双侧$(1-\\alpha) \\times 100\\%$ Wald置信区间由以下公式给出：\n$$ \\hat{\\beta}_{1} \\pm z_{\\alpha/2} \\cdot \\widehat{\\mathrm{SE}}(\\hat{\\beta}_{1}) $$\n其中$\\hat{\\beta}_{1}$是系数的点估计，$\\widehat{\\mathrm{SE}}(\\hat{\\beta}_{1})$是估计量的估计标准误，而$z_{\\alpha/2}$是来自标准正态分布的临界值，对应于$\\alpha/2$的上尾概率。\n\n根据问题陈述，我们已知：\n- 系数的点估计：$\\hat{\\beta}_{1} = 0.37$。\n- 系数的估计方差：$\\widehat{\\mathrm{Var}}(\\hat{\\beta}_{1}) = 0.0484$。\n\n首先，我们计算估计的标准误，即估计方差的平方根：\n$$ \\widehat{\\mathrm{SE}}(\\hat{\\beta}_{1}) = \\sqrt{\\widehat{\\mathrm{Var}}(\\hat{\\beta}_{1})} = \\sqrt{0.0484} = 0.22 $$\n对于一个95%的置信区间，显著性水平为$\\alpha = 0.05$。因此，我们需要临界值$z_{\\alpha/2} = z_{0.05/2} = z_{0.025}$。这是累积概率为$1 - 0.025 = 0.975$的标准正态分位数。众所周知，该值约为$1.96$。\n$$ z_{0.025} \\approx 1.95996 \\dots $$\n我们将使用常规值$z_{0.025} = 1.96$。\n\n现在我们可以构建$\\beta_{1}$的95%置信区间：\n$$ \\mathrm{CI}_{95\\%}(\\beta_{1}) = \\hat{\\beta}_{1} \\pm z_{0.025} \\cdot \\widehat{\\mathrm{SE}}(\\hat{\\beta}_{1}) $$\n$$ \\mathrm{CI}_{95\\%}(\\beta_{1}) = 0.37 \\pm 1.96 \\times 0.22 $$\n误差范围是$M = 1.96 \\times 0.22 = 0.4312$。\n因此，$\\beta_{1}$的区间为：\n$$ [0.37 - 0.4312, 0.37 + 0.4312] = [-0.0612, 0.8012] $$\n风险比为$\\mathrm{HR} = \\exp(\\beta_{1})$。由于指数函数$f(y) = \\exp(y)$是一个严格单调递增函数，风险比的置信区间可以通过对$\\beta_{1}$置信区间的端点取指数来获得。\n设$\\beta_{1}$置信区间的下界和上界分别为$L_{\\beta}$和$U_{\\beta}$。那么风险比的置信区间为$[\\exp(L_{\\beta}), \\exp(U_{\\beta})]$。\n$$ \\mathrm{CI}_{95\\%}(\\mathrm{HR}) = [\\exp(-0.0612), \\exp(0.8012)] $$\n问题特别要求该区间的上端点。\n$$ \\text{Upper Endpoint} = \\exp(0.8012) $$\n我们现在计算其数值：\n$$ \\exp(0.8012) \\approx 2.22822409\\dots $$\n问题要求答案四舍五入到四位有效数字。前四位有效数字是$2, 2, 2, 8$。第五位数字是$2$，所以我们向下舍入。\n$$ \\text{Upper Endpoint} \\approx 2.228 $$\n这就是与标准化mRNA表达得分每增加一个单位相关的风险比的95%置信区间的上界。",
            "answer": "$$\\boxed{2.228}$$"
        },
        {
            "introduction": "任何统计模型的有效性都取决于其底层假设的成立。对于 Cox 模型而言，最关键的假设是比例风险（Proportional Hazards, PH）假设，即协变量对风险的影响不随时间改变。本练习将深入探讨用于诊断此假设的主要工具——Schoenfeld 残差。通过理解这些残差的构造和解释，您将学会如何检验模型的有效性，并识别出可能需要更复杂建模方法（如时变系数）的情况 。",
            "id": "4550937",
            "problem": "生物信息学和医学数据分析中的一项临床基因组学研究调查了具有连续基因表达协变量 $x_j$ 和其他协变量 $\\mathbf{x}_{-j}$ 的患者的生存情况。研究拟合了一个Cox比例风险模型，其中对于协变量向量为 $\\mathbf{x}$ 的受试者，在时间 $t$ 的风险为 $h(t \\mid \\mathbf{x}) = h_0(t)\\exp\\{\\boldsymbol{\\beta}^\\top \\mathbf{x}\\}$，其中 $h_0(t)$ 是基线风险，$\\boldsymbol{\\beta}$ 是回归系数。设 $T_i$ 表示观测到的失败事件中第 $i$ 个不同的事件时间，数据存在右删失和可能的左截断；时间 $t$ 的风险集 $R(t)$ 定义为在 $t$ 时刻之前所有正在被观察且尚未失败的个体。\n\n将事件时间 $T_i$ 时协变量 $j$ 的Schoenfeld残差定义为 $r_{ij} = x_{ij} - \\tilde{x}_j(T_i)$，其中 $x_{ij}$ 是在 $T_i$ 时刻失败的受试者观测到的协变量 $j$ 的值，而 $\\tilde{x}_j(t)$ 是在拟合模型下，时间 $t$ 时协变量 $j$ 的风险集加权平均值，由下式给出：\n$$\n\\tilde{x}_j(t) = \\frac{\\sum_{k \\in R(t)} x_{kj}\\exp\\{\\hat{\\boldsymbol{\\beta}}^\\top \\mathbf{x}_k\\}}{\\sum_{k \\in R(t)} \\exp\\{\\hat{\\boldsymbol{\\beta}}^\\top \\mathbf{x}_k\\}},\n$$\n其中 $\\hat{\\boldsymbol{\\beta}}$ 是通过偏似然估计出的系数。$\\boldsymbol{\\beta}$ 的偏似然为：\n$$\nL(\\boldsymbol{\\beta}) = \\prod_{i}\\frac{\\exp\\{\\boldsymbol{\\beta}^\\top \\mathbf{x}_{(i)}\\}}{\\sum_{k \\in R(T_i)} \\exp\\{\\boldsymbol{\\beta}^\\top \\mathbf{x}_k\\}},\n$$\n其中 $\\mathbf{x}_{(i)}$ 表示在 $T_i$ 时刻失败的受试者的协变量向量。\n\n在此Cox模型中，以下哪个（些）陈述正确解释了Schoenfeld残差 $r_{ij}$ 如何诊断协变量 $j$ 违背比例风险假设的情况？\n\nA. 在具有恒定系数 $\\beta_j$ 的比例风险模型下，条件期望 $\\mathbb{E}\\{r_{ij} \\mid T_i, R(T_i)\\}$ 等于 $0$，因此将 $r_{ij}$（或适当标准化的变体）对 $T_i$ 作图应不显示系统性趋势；系统性趋势表明 $x_j$ 存在时变效应，从而违背了比例风险假设。\n\nB. 因为 $r_{ij}$ 使用了删失时间的 $x_{ij}$，所以所有受试者都有残差值，并且其主要设计目的是通过Martingale残差图评估 $x_j$ 的非线性。\n\nC. $r_{ij}$ 的大小直接估计了在时间 $T_i$ 时 $x_j$ 每增加一个单位的瞬时风险比；在所有事件时间上，残差大小保持恒定可证实比例风险假设。\n\nD. 标准化Schoenfeld残差，定义为将 $r_{ij}$ 乘以 $\\hat{\\beta}_j$ 的协方差估计值（或观测信息矩阵逆的适当分量），近似于局部时变效应 $\\beta_j(t)$ 与拟合的恒定效应 $\\hat{\\beta}_j$ 之间的偏差；当对 $t$ 或 $\\log t$ 进行回归时，若斜率不为零，则提供了反对协变量 $j$ 满足比例风险假设的证据。\n\nE. 在存在左截断的情况下，Schoenfeld残差无法定义，因为风险集是不适定的，所以无法用它们来评估比例风险假设。",
            "solution": "用户提供了一个关于在Cox比例风险回归模型中使用Schoenfeld残差的问题陈述。我将首先验证问题陈述的有效性，然后进行完整解答。\n\n### 步骤1：提取已知信息\n-   **模型**：Cox比例风险模型。\n-   **风险函数**：$h(t \\mid \\mathbf{x}) = h_0(t)\\exp\\{\\boldsymbol{\\beta}^\\top \\mathbf{x}\\}$，其中 $h_0(t)$ 是基线风险，$\\boldsymbol{\\beta}$ 是回归系数。\n-   **协变量**：一个连续基因表达协变量 $x_j$ 和其他协变量 $\\mathbf{x}_{-j}$。完整的向量是 $\\mathbf{x}$。\n-   **事件时间**：$T_i$ 表示观测到的失败事件中第 $i$ 个不同的事件时间。\n-   **数据结构**：存在右删失和可能的左截断。\n-   **风险集**：在时间 $t$，风险集 $R(t)$ 由所有正在被观察且在 $t$ 时刻之前尚未失败的个体组成。\n-   **Schoenfeld残差**：对于事件时间 $T_i$ 的协变量 $j$，残差为 $r_{ij} = x_{ij} - \\tilde{x}_j(T_i)$，其中 $x_{ij}$ 是在 $T_i$ 时刻失败的受试者的协变量值。\n-   **风险集加权平均值**：$\\tilde{x}_j(t) = \\frac{\\sum_{k \\in R(t)} x_{kj}\\exp\\{\\hat{\\boldsymbol{\\beta}}^\\top \\mathbf{x}_k\\}}{\\sum_{k \\in R(t)} \\exp\\{\\hat{\\boldsymbol{\\beta}}^\\top \\mathbf{x}_k\\}}$，其中 $\\hat{\\boldsymbol{\\beta}}$ 是估计的系数。\n-   **偏似然**：$L(\\boldsymbol{\\beta}) = \\prod_{i}\\frac{\\exp\\{\\boldsymbol{\\beta}^\\top \\mathbf{x}_{(i)}\\}}{\\sum_{k \\in R(T_i)} \\exp\\{\\boldsymbol{\\beta}^\\top \\mathbf{x}_k\\}}$，其中 $\\mathbf{x}_{(i)}$ 是在 $T_i$ 时刻失败的受试者的协变量向量。\n-   **问题**：哪个（些）陈述正确解释了Schoenfeld残差 $r_{ij}$ 如何诊断协变量 $j$ 违背比例风险假设的情况？\n\n### 步骤2：使用提取的已知信息进行验证\n问题陈述描述了生存分析中的一个标准情景。\n-   **科学依据**：Cox比例风险模型、偏似然、风险集（包括对删失和截断的处理）以及Schoenfeld残差的定义在生物统计学和生存分析领域都是标准的、教科书级别正确的。临床基因组学研究的背景是一个典型的应用场景。\n-   **问题适定性**：问题要求识别正确解释Schoenfeld残差诊断用途的陈述。这是一个基于既定统计理论、有明确答案的概念性问题。\n-   **客观性**：语言技术性强、精确，没有任何主观或模糊的术语。\n-   **完整性与一致性**：提供了所有必要的定义，并且这些定义在内部是一致的。数学公式是正确的。例如，Schoenfeld残差被正确定为失败个体的观测协变量值与其在风险集上的条件期望（使用拟合模型评估）之间的差值。偏似然表达式也是正确的。\n\n### 步骤3：结论与行动\n问题在科学上是合理的，适定的，并且所有定义都是正确和标准的。没有缺陷。因此，问题是**有效的**。我将继续推导解决方案并评估每个选项。\n\n### 解题推导\nCox模型中的比例风险（PH）假设，$h(t \\mid \\mathbf{x}) = h_0(t)\\exp\\{\\boldsymbol{\\beta}^\\top \\mathbf{x}\\}$，意味着系数向量 $\\boldsymbol{\\beta}$ 不随时间变化。对于协变量 $x_j$，违背此假设意味着其真实系数 $\\beta_j(t)$ 随时间 $t$ 变化。Schoenfeld残差是诊断此类违规情况的主要工具。\n\n在事件时间 $T_i$ 时协变量 $j$ 的Schoenfeld残差为 $r_{ij} = x_{ij} - \\tilde{x}_j(T_i)$。项 $\\tilde{x}_j(T_i)$ 是在给定风险集 $R(T_i)$ 和带有估计系数 $\\hat{\\boldsymbol{\\beta}}$ 的拟合模型的条件下，在时间 $T_i$ 失败的个体其协变量 $j$ 的期望值。具体来说，在该模型下，风险集 $R(T_i)$ 中某个特定个体 $k$ 失败的概率与 $\\exp\\{\\hat{\\boldsymbol{\\beta}}^\\top \\mathbf{x}_k\\}$ 成正比。因此，条件期望是风险集中 $x_{kj}$ 值的加权平均，权重为 $\\exp\\{\\hat{\\boldsymbol{\\beta}}^\\top \\mathbf{x}_k\\}$。\n\n如果PH假设成立，那么在每个事件时间 $T_i$，失败个体的观测协变量 $x_{ij}$ 应该是从该风险集分布中随机抽取的一个样本。因此，当将残差 $r_{ij}$ 对时间或时间的任何函数作图时，它们应该以 $0$ 为中心，且不表现出系统性模式。在 $r_{ij}$ 对 $T_i$ 的图中的系统性趋势（例如，线性、二次）表明，失败个体的协变量与风险集平均值之间的差异随时间系统性地变化。这反过来又表明协变量的效应 $\\beta_j$ 并非恒定不变，从而违背了PH假设。\n\n更高级的理论，特别是 Grambsch 和 Therneau 的研究，将此过程形式化。他们证明了*标准化*Schoenfeld残差对时间的平滑图，可以提供时变系数与拟合的恒定系数之间偏差的估计，即 $\\beta_j(t) - \\hat{\\beta}_j$。标准化过程涉及估计系数的方差-协方差矩阵 $\\widehat{\\text{Var}}(\\hat{\\boldsymbol{\\beta}})$。这引出了对PH假设的正式统计检验，即通过将标准化残差对时间进行回归并检验斜率是否为非零。\n\n### 逐项分析\n\n**A. 在具有恒定系数 $\\beta_j$ 的比例风险模型下，条件期望 $\\mathbb{E}\\{r_{ij} \\mid T_i, R(T_i)\\}$ 等于 $0$，因此将 $r_{ij}$（或适当标准化的变体）对 $T_i$ 作图应不显示系统性趋势；系统性趋势表明 $x_j$ 存在时变效应，从而违背了比例风险假设。**\n这个陈述正确地抓住了使用Schoenfeld残差的基本原理。如果期望是相对于由拟合模型本身定义的风险集上的概率分布来计算的，那么条件期望 $\\mathbb{E}\\{r_{ij} \\mid T_i, R(T_i)\\}$ 确实等于 $0$。这是期望残差在 $0$ 附近随机散布的理论基础。结论是，在PH假设下，这些残差（或其标准化版本）对时间的图应该没有趋势，而系统性趋势则表示违规，这是实践中标准且正确的解释。\n**结论：正确**\n\n**B. 因为 $r_{ij}$ 使用了删失时间的 $x_{ij}$，所以所有受试者都有残差值，并且其主要设计目的是通过Martingale残差图评估 $x_j$ 的非线性。**\n这个陈述包含多个错误。\n1.  Schoenfeld残差仅在事件时间（$T_i$）为经历事件的受试者定义。它们不在删失时间或为被删失的受试者定义。\n2.  因此，并非所有受试者都有残差，只有那些有观测事件的受试者才有。\n3.  Schoenfeld残差的主要目的是评估比例风险假设（系数的时间恒定性）。评估协变量函数形式的非线性通常使用martingale残差或deviance残差来完成。这个陈述混淆了两种不同类型残差的作用。\n**结论：错误**\n\n**C. $r_{ij}$ 的大小直接估计了在时间 $T_i$ 时 $x_j$ 每增加一个单位的瞬时风险比；在所有事件时间上，残差大小保持恒定可证实比例风险假设。**\n这是不正确的。$x_j$ 变化1个单位的风险比是 $\\exp(\\beta_j)$。残差 $r_{ij}$ 的单位与协变量 $x_j$ 相同（例如，基因表达水平）；它是协变量值的差，而不是无量纲的比率。它不估计风险比。此外，对PH的诊断检查是关于残差对时间图是否存在系统性*趋势*，而不是关于其大小是否恒定。残差预计会有随机变异。\n**结论：错误**\n\n**D. 标准化Schoenfeld残差，定义为将 $r_{ij}$ 乘以 $\\hat{\\beta}_j$ 的协方差估计值（或观测信息矩阵逆的适当分量），近似于局部时变效应 $\\beta_j(t)$ 与拟合的恒定效应 $\\hat{\\beta}_j$ 之间的偏差；当对 $t$ 或 $\\log t$ 进行回归时，若斜率不为零，则提供了反对协变量 $j$ 满足比例风险假设的证据。**\n这个陈述是对检验PH违规情况的正确且更高级的描述。残差的标准化涉及 $\\hat{\\boldsymbol{\\beta}}$ 的方差-协方差矩阵（通过信息矩阵的逆来估计）。Grambsch 和 Therneau 研究的关键结果是，这些标准化残差的平滑图近似于真实时变系数 $\\beta_j(t)$ 与估计的平均效应 $\\hat{\\beta}_j$ 之间的偏差。将这些标准化残差对时间的函数（$t$ 或 $\\log t$）进行回归，并检验斜率是否为非零，是检验PH假设的标准方法。这个陈述准确地总结了这一正式的诊断过程。\n**结论：正确**\n\n**E. 在存在左截断的情况下，Schoenfeld残差无法定义，因为风险集是不适定的，所以无法用它们来评估比例风险假设。**\n这个陈述是错误的。Cox模型框架，包括偏似然和所有相关的诊断方法，是专门设计用来处理各种数据结构的，包括左截断（也称为延迟进入）。左截断通过正确定义风险集 $R(t)$ 来处理，使其只包括已进入研究（在他们的进入时间）且在时间 $t$ 之前尚未失败或删失的个体。风险集仍然是适定的，因此可以计算Schoenfeld残差并以常规方式解释，以评估PH假设。\n**结论：错误**",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "虽然现成的统计软件包使拟合 Cox 模型变得简单，但深刻的理解来自于掌握其内部机制。本练习提供了一个高级挑战：从零开始实现用于复发事件分析的 Andersen-Gill 计数过程模型。您将通过 start-stop 编码来处理复发事件数据，并使用 Newton-Raphson 算法来估计回归系数，从而对风险集、偏似然和模型估计的整个过程获得深入的、实践性的理解 。",
            "id": "4550962",
            "problem": "一名开发者接到任务，需要构建一个程序，使用 Andersen–Gill 计数过程公式来估计复发事件的 Cox 比例风险回归中的回归系数。其生物医学背景是心力衰竭患者的复发性住院。每位患者在随访期间可能会经历多次住院，暴露变量是一个二元指标，表示是否接受了护理管理计划。模型应使用风险区间（at-risk intervals）的“开始-停止”（start–stop）表示法来构建，并应使用 Breslow 近似法处理事件时间中的并列情况（ties）。开发者必须从基本原理出发实现该估计器，从风险和风险集的定义开始，并且不得依赖外部的生存分析库。\n\n基本原理：\n- Cox 比例风险回归模型将个体 $i$ 在时间 $t$ 的风险定义为 $h_i(t) = h_0(t) \\exp\\{\\beta x_i(t)\\}$，其中 $h_0(t)$ 是一个未指定的基线风险，$x_i(t)$ 是可能随时间变化的协变量值，而 $\\beta$ 是待估计的回归系数。\n- 在 Andersen–Gill (AG) 计数过程公式中，每个受试者贡献一个或多个他们处于风险中的区间 $\\left[s, t\\right)$。对于每个区间，其右端点关联一个二元事件指标，反映在区间停止时间是否发生了事件。在时间 $t$ 的风险集包括所有开始时间严格小于 $t$ 且停止时间大于或等于 $t$ 的区间。\n- 估计过程通过最大化从这些定义中导出的偏似然来进行，并使用适当的并列处理方法（Breslow 近似法）来处理同一时间的多个事件。\n\n你的程序必须：\n1. 通过将原始事件时间转换为每个患者的 $(\\text{start}, \\text{stop}, \\text{event}, x)$ 形式的区间数据，来演示在 Andersen–Gill 计数过程公式下复发事件的“开始-停止”编码。\n2. 使用牛顿-拉弗森迭代法、用于处理并列事件时间的 Breslow 近似法以及上述风险集定义，从基本原理出发实现单个系数 $\\beta$ 的最大偏似然估计器。协变量 $x$ 在每个区间内是恒定的，如果患者参与护理管理计划，则等于 $1$，否则等于 $0$。\n3. 将该实现应用于以下测试套件（三个独立的数据集），每个数据集代表一个合理的复发性住院生物医学登记库。时间单位为天。\n\n数据集 A (理想情况；无左截断的复发事件):\n- 患者 1：在第 $0$ 天进入，在第 $10, 40, 90$ 天发生事件，在第 $120$ 天删失，$x=1$。\n- 患者 2：在第 $0$ 天进入，在第 $20, 85$ 天发生事件，在第 $100$ 天删失，$x=0$。\n- 患者 3：在第 $0$ 天进入，无事件，在第 $100$ 天删失，$x=1$。\n\n数据集 B (不同受试者之间存在并列事件时间):\n- 患者 1：在第 $0$ 天进入，在第 $30, 60$ 天发生事件，在第 $80$ 天删失，$x=0$。\n- 患者 2：在第 $0$ 天进入，在第 $30$ 天发生事件，在第 $50$ 天删失，$x=1$。\n- 患者 3：在第 $0$ 天进入，在第 $60$ 天发生事件，在第 $90$ 天删失，$x=1$。\n- 患者 4：在第 $0$ 天进入，无事件，在第 $60$ 天删失，$x=0$。\n\n数据集 C (左截断；具有复发事件的交错进入):\n- 患者 1：在第 $20$ 天进入，在第 $50$ 天发生事件，在第 $60$ 天删失，$x=1$。\n- 患者 2：在第 $0$ 天进入，在第 $25, 120$ 天发生事件，在第 $150$ 天删失，$x=0$。\n- 患者 3：在第 $0$ 天进入，无事件，在第 $150$ 天删失，$x=1$。\n- 患者 4：在第 $60$ 天进入，在第 $120$ 天发生事件，在第 $160$ 天删失，$x=0$。\n\n“开始-停止”编码细节：\n- 对于每个进入时间为 $a$，住院事件时间为 $t_1  t_2  \\dots  t_K$，删失时间为 $C$ 的患者，创建以下区间：\n  - 如果 $K \\ge 1$，则区间 $(a, t_1]$ 的事件指标为 $1$，\n  - 区间 $(t_j, t_{j+1}]$ 的事件指标为 $1$ (对于 $j = 1, \\dots, K-1$)，\n  - 如果 $K \\ge 1$，则区间 $(t_K, C]$ 的事件指标为 $0$；如果 $K = 0$，则区间 $(a, C]$ 的事件指标为 $0$。\n- 在日历时间 $t$ 的风险集包括每一个满足 $s  t \\le u$ 的区间 $(s, u]$。\n\n输出规范：\n- 对于每个数据集，使用上述方法估计护理管理计划的回归系数 $\\hat{\\beta}$。\n- 将每个估计值表示为四舍五入到六位小数的十进制数。\n- 你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 [数据集A结果, 数据集B结果, 数据集C结果]。例如：\"[0.123456,-0.010000,0.500000]\"。\n\n程序必须是完全自包含的，不需要任何输入，并且可以在任何支持 Python 和指定库的现代环境中运行。最终答案是浮点数；不需要报告物理或角度单位。确保通过一致的区间构建和如上所述的正确风险集形成来保证科学真实性。",
            "solution": "该问题是有效的。它提出了一个生物统计学中明确定义的任务：使用 Andersen–Gill (AG) 计数过程公式估计复发事件的 Cox 比例风险模型的回归系数。该问题提供了清晰的理论基础、数据表示的具体说明（“开始-停止”编码）、处理并列事件时间的指定方法（Breslow 近似法）以及用于估计的数值算法（牛顿-拉弗森法）。提供的三个数据集是完整的、一致的，并代表了医学研究中可能出现的场景，包括并列事件和左截断（交错进入）。\n\n解决方案首先将患者层面的数据转换为所需的“开始-停止”区间格式。然后，我们实现牛顿-拉弗森算法以找到偏对数似然函数的最大值。这涉及推导并实现对数似然的得分函数（一阶导数）和观测信息（二阶导数的负值）。\n\n**1. 数据转换：Andersen–Gill 计数过程公式**\n\nAndersen–Gill 模型通过重构数据将 Cox 模型扩展到复发事件。每个患者的随访历史被分解为一系列不相交的时间区间 $(\\text{start}, \\text{stop}]$。对于每个区间，我们记录一个事件指标（如果在停止时间发生事件，则为 $1$，否则为 $0$）和相应的协变量值。\n\n对于进入时间为 $a$，事件时间为 $t_1  t_2  \\dots  t_K$，删失时间为 $C$ 的患者，区间的构建如下：\n- $(\\text{start}_1, \\text{stop}_1] = (a, t_1]$，事件指标为 $1$。\n- $(\\text{start}_j, \\text{stop}_j] = (t_{j-1}, t_j]$，事件指标为 $1$ (对于 $j=2, \\dots, K$)。\n- $(\\text{start}_{K+1}, \\text{stop}_{K+1}] = (t_K, C]$，事件指标为 $0$。\n如果患者没有事件 ($K=0$)，他们贡献一个单一区间 $(a, C]$，事件指标为 $0$。协变量 $x$ 与每个区间相关联。\n\n**2. 复发事件的 Cox 模型偏似然**\n\nCox 比例风险模型指定了第 $i$ 个风险区间在时间 $t$ 发生事件的风险率为：\n$$ h_i(t) = h_0(t) \\exp(\\beta x_i) $$\n其中 $h_0(t)$ 是基线风险，$x_i$ 是区间 $i$ 的协变量，$\\beta$ 是待估计的对数风险比。\n\n$\\beta$ 的估计基于最大化偏似然。令唯一的有序事件时间为 $T_1  T_2  \\dots  T_m$。\n在时间 $T_j$ 的风险集，记为 $R(T_j)$，是所有在该时间处于活动状态的区间 $k$ 的集合，即满足 $\\text{start}_k  T_j \\le \\text{stop}_k$ 的区间。\n令 $D_j$ 为在时间 $T_j$ 发生事件的区间集合，令 $d_j = |D_j|$ 为在 $T_j$ 发生的（并列）事件数。\n\n使用 Breslow 近似法处理并列事件，偏对数似然函数由下式给出：\n$$ \\ell(\\beta) = \\sum_{j=1}^{m} \\left( \\sum_{k \\in D_j} \\beta x_k - d_j \\log \\left( \\sum_{l \\in R(T_j)} \\exp(\\beta x_l) \\right) \\right) $$\n\n**3. 通过牛顿-拉弗森法进行最大似然估计**\n\n为了找到最大化 $\\ell(\\beta)$ 的 $\\beta$ 值，我们使用牛顿-拉弗森法。这是一个迭代算法，用于找到对数似然函数的一阶导数（称为得分函数 $U(\\beta)$）的根。更新规则是：\n$$ \\beta_{k+1} = \\beta_k - \\frac{U(\\beta_k)}{\\frac{\\partial^2 \\ell(\\beta_k)}{\\partial \\beta^2}} = \\beta_k + \\frac{U(\\beta_k)}{\\mathcal{I}(\\beta_k)} $$\n其中 $\\mathcal{I}(\\beta) = -\\frac{\\partial^2 \\ell(\\beta)}{\\partial \\beta^2}$ 是观测信息。\n\n为实现这一点，我们需要 $\\ell(\\beta)$ 的一阶和二阶导数。让我们在给定事件时间 $T_j$ 定义风险集 $R(T_j)$ 上的以下总和：\n- $S^{(0)}(\\beta, T_j) = \\sum_{l \\in R(T_j)} \\exp(\\beta x_l)$\n- $S^{(1)}(\\beta, T_j) = \\sum_{l \\in R(T_j)} x_l \\exp(\\beta x_l)$\n- $S^{(2)}(\\beta, T_j) = \\sum_{l \\in R(T_j)} x_l^2 \\exp(\\beta x_l)$\n\n**得分函数**（一阶导数）是：\n$$ U(\\beta) = \\frac{\\partial \\ell(\\beta)}{\\partial \\beta} = \\sum_{j=1}^{m} \\left( \\sum_{k \\in D_j} x_k - d_j \\frac{S^{(1)}(\\beta, T_j)}{S^{(0)}(\\beta, T_j)} \\right) $$\n\n**观测信息**（二阶导数的负值）是：\n$$ \\mathcal{I}(\\beta) = -\\frac{\\partial^2 \\ell(\\beta)}{\\partial \\beta^2} = \\sum_{j=1}^{m} d_j \\left[ \\frac{S^{(2)}(\\beta, T_j)}{S^{(0)}(\\beta, T_j)} - \\left( \\frac{S^{(1)}(\\beta, T_j)}{S^{(0)}(\\beta, T_j)} \\right)^2 \\right] $$\n方括号中的项是在风险集 $R(T_j)$ 成员中协变量 $x$ 的方差，由它们各自的风险贡献 $\\exp(\\beta x_l)$ 加权。\n\n**4. 算法步骤**\n该实现将为每个数据集执行以下步骤：\n1.  **数据准备**：将每个数据集的原始患者数据转换为统一的 $(\\text{start}, \\text{stop}, \\text{event}, x)$ 区间列表。\n2.  **事件时间识别**：从区间数据中识别并排序唯一的事件时间 $\\{T_j\\}$。\n3.  **牛顿-拉弗森迭代**：\n    a. 初始化系数估计值，$\\beta = 0.0$。\n    b. 迭代固定次数或直到收敛（即 $\\beta$ 的变化可忽略不计）。\n    c. 在每次迭代中，通过对每个唯一事件时间 $T_j$ 的贡献求和，计算总得分 $U(\\beta)$ 和信息 $\\mathcal{I}(\\beta)$。\n    d. 对于每个 $T_j$，确定风险集 $R(T_j)$、事件集 $D_j$ 和事件计数 $d_j$。\n    e. 在风险集上计算 $S^{(0)}$、$S^{(1)}$ 和 $S^{(2)}$。\n    f. 更新总得分和信息。\n    g. 遍历所有事件时间后，使用公式 $\\beta \\leftarrow \\beta + U(\\beta) / \\mathcal{I}(\\beta)$ 更新 $\\beta$。\n4.  **输出**：报告为所提供的三个数据集中的每一个估计出的最终 $\\hat{\\beta}$，四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _create_ag_intervals(raw_patient_data):\n    \"\"\"\n    Transforms raw patient data into Andersen-Gill start-stop intervals.\n\n    Args:\n        raw_patient_data (list): A list of dictionaries, each representing a patient.\n            Keys: 'entry', 'events' (list of times), 'censor', 'x'.\n\n    Returns:\n        list: A list of dictionaries, each representing a risk interval.\n            Keys: 'start', 'stop', 'event', 'x'.\n    \"\"\"\n    intervals = []\n    for pt in raw_patient_data:\n        event_times = sorted(pt['events'])\n        current_start_time = pt['entry']\n        \n        # Create intervals ending with an event\n        for event_time in event_times:\n            if event_time > current_start_time:\n                intervals.append({\n                    'start': current_start_time,\n                    'stop': event_time,\n                    'event': 1,\n                    'x': pt['x']\n                })\n            current_start_time = event_time\n            \n        # Create final censoring interval\n        if pt['censor'] > current_start_time:\n            intervals.append({\n                'start': current_start_time,\n                'stop': pt['censor'],\n                'event': 0,\n                'x': pt['x']\n            })\n    return intervals\n\ndef calculate_beta_ag(raw_patient_data, max_iter=20, tol=1e-7):\n    \"\"\"\n    Estimates the regression coefficient for a single covariate Cox model\n    with recurrent events using the Andersen-Gill formulation.\n\n    Args:\n        raw_patient_data (list): A list of patient data dictionaries.\n        max_iter (int): Maximum number of Newton-Raphson iterations.\n        tol (float): Tolerance for convergence.\n\n    Returns:\n        float: The estimated regression coefficient beta.\n    \"\"\"\n    intervals = _create_ag_intervals(raw_patient_data)\n    \n    unique_event_times = sorted(list(set(\n        ival['stop'] for ival in intervals if ival['event'] == 1\n    )))\n    \n    beta = 0.0\n    for _ in range(max_iter):\n        score_U = 0.0  # First derivative of log-likelihood\n        info_I = 0.0   # Negative second derivative (information)\n\n        for t_event in unique_event_times:\n            # Identify risk set and event set for the current event time\n            risk_set_covariates, event_set_covariates = [], []\n            \n            for ival in intervals:\n                # Risk set: interval is active at t_event\n                if ival['start']  t_event and t_event = ival['stop']:\n                    risk_set_covariates.append(ival['x'])\n                    # Event set: event occurs exactly at t_event\n                    if ival['stop'] == t_event and ival['event'] == 1:\n                        event_set_covariates.append(ival['x'])\n\n            risk_set_x = np.array(risk_set_covariates)\n            d_j = len(event_set_covariates)\n            sum_x_at_event = sum(event_set_covariates)\n\n            if d_j == 0:\n                continue\n\n            # Calculate S_0, S_1, S_2 sums\n            risk_weights = np.exp(beta * risk_set_x)\n            \n            s0 = np.sum(risk_weights)\n            s1 = np.sum(risk_set_x * risk_weights)\n            s2 = np.sum(risk_set_x**2 * risk_weights)\n            \n            if s0 > 0:\n                E1 = s1 / s0\n                E2 = s2 / s0\n                \n                # Update total score and information\n                score_U += sum_x_at_event - d_j * E1\n                info_I += d_j * (E2 - E1**2)\n\n        if info_I = 1e-9:\n            # Information is zero or negative, cannot update.\n            # This can happen with perfect separation or sparse data.\n            break\n\n        delta_beta = score_U / info_I\n        beta += delta_beta\n\n        if abs(delta_beta)  tol:\n            break\n            \n    return beta\n\ndef solve():\n    \"\"\"\n    Main function to define datasets, run the analysis, and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Dataset A\n        [\n            {'id': 1, 'entry': 0, 'events': [10, 40, 90], 'censor': 120, 'x': 1},\n            {'id': 2, 'entry': 0, 'events': [20, 85], 'censor': 100, 'x': 0},\n            {'id': 3, 'entry': 0, 'events': [], 'censor': 100, 'x': 1},\n        ],\n        # Dataset B\n        [\n            {'id': 1, 'entry': 0, 'events': [30, 60], 'censor': 80, 'x': 0},\n            {'id': 2, 'entry': 0, 'events': [30], 'censor': 50, 'x': 1},\n            {'id': 3, 'entry': 0, 'events': [60], 'censor': 90, 'x': 1},\n            {'id': 4, 'entry': 0, 'events': [], 'censor': 60, 'x': 0},\n        ],\n        # Dataset C\n        [\n            {'id': 1, 'entry': 20, 'events': [50], 'censor': 60, 'x': 1},\n            {'id': 2, 'entry': 0, 'events': [25, 120], 'censor': 150, 'x': 0},\n            {'id': 3, 'entry': 0, 'events': [], 'censor': 150, 'x': 1},\n            {'id': 4, 'entry': 60, 'events': [120], 'censor': 160, 'x': 0},\n        ],\n    ]\n\n    results = []\n    for case_data in test_cases:\n        beta_hat = calculate_beta_ag(case_data)\n        results.append(beta_hat)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}