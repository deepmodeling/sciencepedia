{
    "hands_on_practices": [
        {
            "introduction": "许多生物信息学分析都依赖于像 BLOSUM62 这样的标准替换矩阵。但这些矩阵是如何推导出来的呢？本练习将通过指导您从一个小的、无空位的比对块构建一个类 BLOSUM 评分矩阵来揭开这一过程的神秘面纱。您将应用序列聚类的核心原则来减少来自近缘序列的偏差，然后基于观察到的替换频率计算对数奇比分 (log-odds scores)。通过从第一性原理构建矩阵 ，您将对 BLOSUM 等矩阵中的分数所代表的真实含义——即观察到的比对是由同源性而非随机机会产生的对数可能性——获得深刻而直观的理解。",
            "id": "4591431",
            "problem": "考虑一个由四个蛋白质序列组成的无空位保守块比对，每个序列长度为 $6$ 列。这些序列是：\n- $S_1$: ACDEFG\n- $S_2$: ACDQFG\n- $S_3$: ASDEFG\n- $S_4$: `VCNEY G`\n\n假设使用贪婪单连接方案，在同一性阈值 $T = 0.7$ 下执行块替换矩阵 (BLOSUM) 聚类。在贪婪单连接聚类中，序列被视为图中的节点，如果两个节点间的两两同一性（比对列中相同残基的比例）至少为 $T$，则在这两个节点之间画一条边，而簇是由这些边导出的连通分量。在每个簇内，为每个序列分配一个等于簇大小倒数的权重，并且簇内的比对残基对将从所有后续计数中排除。在簇之间，每对序列都对观察到的比对残基对计数有贡献，其权重为两个序列权重的乘积。\n\n使用对数奇数比替换评分的基本定义（即量化观察到比对残基对相对于独立背景组成期望的信息含量），从第一性原理出发执行以下步骤：\n- 确定阈值 $T$ 下的簇以及由此产生的每个序列的权重。\n- 遍历所有列，枚举所有簇间序列对，并为每个无序残基对 $\\{i,j\\}$ 累积加权计数，忽略簇内对。\n- 标准化这些计数以获得所有无序对的无序对概率 $p^{\\text{unord}}_{ij}$，使得 $\\sum_{i \\le j} p^{\\text{unord}}_{ij} = 1$。\n- 对于 $i \\ne j$ 的情况，通过在 $(i,j)$ 和 $(j,i)$ 之间平均分配概率质量，将 $p^{\\text{unord}}_{ij}$ 转换为有序对概率 $p_{ij}$，并保持 $p_{ii}$ 不变，使得 $\\sum_{i}\\sum_{j} p_{ij} = 1$。\n- 通过对与 $i$ 的比对求和，从有序对概率中获得残基背景概率 $q_i$，即 $q_i = \\sum_{j} p_{ij}$。\n\n最后，使用这些定义，推导特定非对角线对 $D$ 与 $N$ 比对的类 BLOSUM 以 2 为底的对数奇数比替换分数。将最终分数表示为精确的以 2 为底的对数，不进行四舍五入，也不带单位。由于该块是无空位的，因此不需要空位罚分模型，但您的推导应明确说明，根据典型的基于块的替换矩阵构建原则，在此阶段为何会排除空位。",
            "solution": "该问题要求基于一个由四条序列组成的小型无空位块比对，计算氨基酸对 (D, N) 的类 BLOSUM 对数奇数比分数。推导过程必须遵循第一性原理，从序列聚类和加权开始，接着进行配对计数和概率计算，最后以对数奇数比分数公式结束。\n\n首先，我们验证题目陈述。给定的是四条蛋白质序列，据称每条序列的长度为 $L=6$：\n$S_1$: ACDEFG\n$S_2$: ACDQFG\n$S_3$: ASDEFG\n$S_4$: VCNEY G\n\n所提供的数据中存在一个明显的矛盾。题目说明每条序列的长度为 $6$ 列，但所写的序列 $S_4$: `VCNEY G` 包含一个空格，总字符数为 $7$。空格不是 $20$ 种标准氨基酸之一。这是一个矛盾。严谨的分析需要明确的数据。我将基于一个明确且必要的假设继续进行，即该空格是一个排印错误，预期的序列是 $S_4$: `VCNEYG`，这与所述的长度 $L=6$ 一致。没有这个修正，这个问题是无法明确定义的。\n\n推导过程按以下步骤进行。\n\n**步骤 1：序列聚类与加权**\n\n我们首先计算所有序列对的两两同一性。同一性 $I(S_a, S_b)$ 是比对中相同残基的比例。比对长度为 $L=6$。序列对根据同一性阈值 $T = 0.7$ 进行评估。\n\n序列如下：\n$S_1$: ACDEFG\n$S_2$: ACDQFG\n$S_3$: ASDEFG\n$S_4$: VCNEYG\n\n两两同一性：\n- $I(S_1, S_2)$: 在第 $1, 2, 3, 5, 6$ 列匹配。匹配数 = $5$。同一性 = $5/6 \\approx 0.833$。由于 $0.833 > 0.7$，在 $S_1$ 和 $S_2$ 之间存在一条边。\n- $I(S_1, S_3)$: 在第 $1, 3, 4, 5, 6$ 列匹配。匹配数 = $5$。同一性 = $5/6 \\approx 0.833$。由于 $0.833 > 0.7$，在 $S_1$ 和 $S_3$ 之间存在一条边。\n- $I(S_1, S_4)$: 在第 $2, 4, 6$ 列匹配。匹配数 = $3$。同一性 = $3/6 = 0.5$。由于 $0.5  0.7$，在 $S_1$ 和 $S_4$ 之间不存在边。\n- $I(S_2, S_3)$: 在第 $1, 3, 5, 6$ 列匹配。匹配数 = $4$。同一性 = $4/6 \\approx 0.667$。由于 $0.667  0.7$，在 $S_2$ 和 $S_3$ 之间不存在边。\n- $I(S_2, S_4)$: 在第 $2, 6$ 列匹配。匹配数 = $2$。同一性 = $2/6 \\approx 0.333$。由于 $0.333  0.7$，在 $S_2$ 和 $S_4$ 之间不存在边。\n- $I(S_3, S_4)$: 在第 $4, 6$ 列匹配。匹配数 = $2$。同一性 = $2/6 \\approx 0.333$。由于 $0.333  0.7$，在 $S_3$ 和 $S_4$ 之间不存在边。\n\n基于单连接聚类，我们识别连通分量。由于 $S_1$ 与 $S_2$ 和 $S_3$ 都相连，序列 $\\{S_1, S_2, S_3\\}$ 构成一个单独的簇。$S_4$ 没有连接到它的边，所以它自己构成一个单元素簇。\n簇是：\n- 簇 1: $\\{S_1, S_2, S_3\\}$，大小 $n_1 = 3$。\n- 簇 2: $\\{S_4\\}$，大小 $n_2 = 1$。\n\n簇中每个序列的权重是簇大小的倒数。\n- 对于簇 1 中的 $S_1, S_2, S_3$，权重为 $w_1 = w_2 = w_3 = 1/n_1 = 1/3$。\n- 对于簇 2 中的 $S_4$，权重为 $w_4 = 1/n_2 = 1/1 = 1$。\n\n**步骤 2：累积加权配对计数**\n\n根据规则，我们只计算来自不同簇中序列的残基对。需要考虑的对是 $(S_1, S_4)$, $(S_2, S_4)$ 和 $(S_3, S_4)$。像 $(S_1, S_2)$ 这样的簇内对被排除。每个比对残基对的计数都按序列权重的乘积加权。这里所有簇间对的权重是 $w_i \\times w_4 = (1/3) \\times 1 = 1/3$。\n\n我们为簇间序列对逐列枚举无序残基对 $\\{i,j\\}$，并累积它们的加权计数，记为 $N_{ij}$。\n\n- 来自 $(S_1, S_4)$ 的比对对：`ACDEFG` vs `VCNEYG` $\\rightarrow$ {A,V}, {C,C}, {D,N}, {E,E}, {F,Y}, {G,G}。每个对其各自的计数贡献 $1/3$。\n- 来自 $(S_2, S_4)$ 的比对对：`ACDQFG` vs `VCNEYG` $\\rightarrow$ {A,V}, {C,C}, {D,N}, {Q,E}, {F,Y}, {G,G}。每个对其各自的计数贡献 $1/3$。\n- 来自 $(S_3, S_4)$ 的比对对：`ASDEFG` vs `VCNEYG` $\\rightarrow$ {A,V}, {S,C}, {D,N}, {E,E}, {F,Y}, {G,G}。每个对其各自的计数贡献 $1/3$。\n\n每个无序对 $\\{i,j\\}$ 的总加权计数：\n- $N_{AV} = 1/3 + 1/3 + 1/3 = 1$\n- $N_{CC} = 1/3 + 1/3 = 2/3$\n- $N_{DN} = 1/3 + 1/3 + 1/3 = 1$\n- $N_{EE} = 1/3 + 1/3 = 2/3$\n- $N_{FY} = 1/3 + 1/3 + 1/3 = 1$\n- $N_{GG} = 1/3 + 1/3 + 1/3 = 1$\n- $N_{EQ} = 1/3$\n- $N_{CS} = 1/3$\n\n所有其他对的计数为 $0$。加权对的总数 $N_{tot}$ 是这些计数的总和：\n$N_{tot} = 1 + 2/3 + 1 + 2/3 + 1 + 1 + 1/3 + 1/3 = 4 + 6/3 = 4 + 2 = 6$。\n这与贡献对的总数（$3$ 个序列对 $\\times 6$ 列）乘以它们的权重（$1/3$）相匹配，即 $3 \\times 6 \\times (1/3) = 6$。\n\n**步骤 3：计算配对概率 ($p^{\\text{unord}}_{ij}$ 和 $p_{ij}$)**\n\n观察到无序对 $\\{i,j\\}$ 的概率 $p^{\\text{unord}}_{ij}$ 是其加权计数除以总加权计数。\n$p^{\\text{unord}}_{ij} = N_{ij} / N_{tot}$。\n对于我们感兴趣的对 $\\{D,N\\}$：\n$p^{\\text{unord}}_{DN} = N_{DN} / N_{tot} = 1/6$。\n\n接下来，我们将这些转换为有序对概率 $p_{ij}$。对于 $i \\neq j$，$p_{ij} = p_{ji} = p^{\\text{unord}}_{ij} / 2$。对于 $i=j$，$p_{ii} = p^{\\text{unord}}_{ii}$。\n由于 $D \\neq N$，有序对 $(D,N)$ 的概率是：\n$p_{DN} = p^{\\text{unord}}_{DN} / 2 = (1/6) / 2 = 1/12$。\n\n**步骤 4：计算背景残基概率 ($q_i$)**\n\n残基 $i$ 的背景概率 $q_i$ 是其总体频率，从有序对概率推导得出：$q_i = \\sum_{j} p_{ij}$。我们需要找到 $q_D$ 和 $q_N$。\n\n为了找到 $q_D$，我们对所有的 $p_{Dj}$求和：\n$q_D = \\sum_{j} p_{Dj} = p_{DA} + p_{DC} + p_{DD} + \\dots + p_{DN} + \\dots = p_{DN} = 1/12$。没有观察到其他残基与 D 比对。\n$q_N = p_{NA} + p_{NC} + p_{ND} + \\dots = p_{ND} = 1/12$。没有观察到其他残基与 N 比对。\n我们必须小心，该定义具有对称性，所以 $q_D = \\sum_j p_{jD}$ 也成立。标准计算使用 $q_i = ( \\sum_j p_{ij} + \\sum_j p_{ji} )/2$。为了周全，让我们先计算所有有序概率。\n- $p_{AV} = p_{VA} = (1/6)/2 = 1/12$\n- $p_{CC} = 2/18 = 1/9$\n- $p_{DN} = p_{ND} = (1/6)/2 = 1/12$\n- $p_{EE} = 2/18 = 1/9$\n- $p_{FY} = p_{YF} = (1/6)/2 = 1/12$\n- $p_{GG} = 1/6$\n- $p_{EQ} = p_{QE} = (1/18)/2 = 1/36$\n- $p_{CS} = p_{SC} = (1/18)/2 = 1/36$\n\n现在，我们使用 $q_i = \\sum_{j} p_{ij}$ 计算 $q_D$ 和 $q_N$：\n$q_D = p_{DA} + p_{DC} + p_{DD} + \\dots + p_{DN} + \\dots = p_{DN} = 1/12$。没有观察到其他残基与 D 比对。\n$q_N = p_{NA} + p_{NC} + p_{ND} + \\dots = p_{ND} = 1/12$。没有观察到其他残基与 N 比对。\n\n所以，$q_D = 1/12$ 且 $q_N = 1/12$。\n\n**步骤 5：计算对数奇数比分数**\n\n残基 $i$ 替换为残基 $j$ 的对数奇数比分数 $S_{ij}$，是将观察到的比对概率 $p_{ij}$ 与一个模型下的期望概率 $e_{ij}$ 进行比较，该模型中残基根据其背景频率随机比对。期望概率为 $e_{ij} = q_i q_j$。分数以 2 为底的对数（比特）形式给出。\n\n$S_{ij} = \\log_2 \\left( \\frac{p_{ij}}{e_{ij}} \\right) = \\log_2 \\left( \\frac{p_{ij}}{q_i q_j} \\right)$。\n\n我们想要求出对 $(D,N)$ 的分数 $S_{DN}$：\n- $p_{DN} = 1/12$\n- $q_D = 1/12$\n- $q_N = 1/12$\n\n代入这些值：\n$S_{DN} = \\log_2 \\left( \\frac{1/12}{(1/12) \\times (1/12)} \\right) = \\log_2 \\left( \\frac{1}{1/12} \\right) = \\log_2(12)$。\n\n最终分数要求以精确的以 2 为底的对数形式表示。\n\n**空位的排除**\n\n问题指定了“无空位保守块比对”，并且构建 BLOSUM 矩阵的过程本身就从频率计数中排除了空位。其基本原理是基于替换和插入/删除（indel）事件之间的根本区别。像 BLOSUM 这样的替换矩阵旨在评估在进化时间内一个氨基酸替换另一个氨基酸的可能性。空位，用‘-’表示，不是一个氨基酸；它表示一个插入/删除事件。控制替换的进化过程和概率与控制插入/删除的过程和概率是不同的。因此，比对评分涉及两个独立的组成部分：一个用于匹配/不匹配残基的替换矩阵，和一个用于插入/删除的空位罚分函数。要构建替换矩阵，必须分离出纯粹的替换事件。这是通过使用根据定义不含空位的比对块来实现的。在源多重比对中任何包含空位的列，在统计残基-残基对频率时都将被忽略。",
            "answer": "$$\\boxed{\\log_{2}(12)}$$"
        },
        {
            "introduction": "替换过程并非总能用一个通用的模型来完美描述，不同的进化情景可能需要不同复杂度的模型。本练习将从构建单个矩阵的层面提升到一个更复杂的任务：从一组候选模型（JC69、K80、HKY85、GTR）中选择最佳拟合的替换模型。您将使用强大的统计工具——赤池信息准则 ($AIC$) 和贝叶斯信息准则 ($BIC$)——来平衡模型的拟合优度与复杂性。掌握模型选择  是现代系统发育学和分子进化中的一项关键技能，它使您能够就分析所依据的进化假设做出统计上合理的选择，从而得出更可靠的科学推论。",
            "id": "4591443",
            "problem": "一个生物信息学实验室在一个临床基因组学流程中，从一个非常大的独立、短进化分支集合中汇总了高置信度的单碱基替换事件。这些事件是从推断的祖先碱基到观察到的后代碱基的定向核苷酸变化。假设观察到类型为 $i \\to j$（其中 $i \\neq j$ 且 $i,j \\in \\{A,C,G,T\\}$）的事件的概率，可以通过一个多项式抽样方案很好地建模，其类别概率与稳态碱基频率加权的瞬时替换流成正比，即 $\\pi_{i} r_{ij}$，其中 $\\pi_{i}$ 是碱基 $i$ 的稳态频率，而 $r_{ij}$ 是从 $i$ 到 $j$ 的瞬时速率。当多重替换事件可以忽略不计，且整个集合中的分支长度足够短时，这种复合似然近似在科学上是现实的。将比较四种标准的可逆核苷酸替换模型：Jukes–Cantor 1969 (JC69)、Kimura 2-参数 (K80)、Hasegawa–Kishino–Yano 1985 (HKY85) 和通用时间可逆 (GTR) 模型。\n\n观察到的定向替换计数如下：\n- 转换 (Transitions)：$A \\to G = 520$, $G \\to A = 500$, $C \\to T = 540$, $T \\to C = 515$。\n- 颠换 (Transversions)：$A \\to C = 130$, $C \\to A = 125$, $A \\to T = 140$, $T \\to A = 135$, $C \\to G = 110$, $G \\to C = 115$, $G \\to T = 120$, $T \\to G = 118$。\n\n令 $n$ 表示事件总数，令 $S_{i} := \\sum_{j \\neq i} c_{ij}$ 为从碱基 $i$ 出发的总替换计数，令 $C_{T}$ 和 $C_{V}$ 分别表示转换和颠换的总计数。您可以假设在复合多项式框架下，以下经过充分检验的模型结构和自由度：\n- JC69：相等的碱基频率和相等的非对角线速率，导致 $12$ 个定向非对角线配对的类别概率相等；归一化后没有自由参数 ($k_{\\mathrm{JC69}} = 0$)。\n- K80：相等的碱基频率，一个转换速率 $\\alpha$ 和一个颠换速率 $\\beta$，它们仅通过其比率 $\\kappa := \\alpha / \\beta$ 进入模型 ($k_{\\mathrm{K80}} = 1$)。\n- HKY85：不相等的碱基频率 $\\pi_{i}$ (受 $\\sum_{i} \\pi_{i} = 1$ 约束) 和一个转换/颠换比率 $\\kappa$ ($k_{\\mathrm{HKY85}} = 4$，即 $3$ 个独立的 $\\pi_{i}$ 加上 $\\kappa$)。\n- GTR：在归一化下，针对无序核苷酸对有六个可逆流参数，实现为每个无序对上的对称定向类别概率；归一化后有 $5$ 个自由速率参数 ($k_{\\mathrm{GTR}} = 5$)。在这种仅使用非对角线元素的复合公式中，稳态碱基频率是不可单独辨识的。\n\n使用赤池信息准则 (AIC) 和贝叶斯信息准则 (BIC) 的基本定义：\n$$\\mathrm{AIC} = -2 \\ln L + 2k, \\quad \\mathrm{BIC} = -2 \\ln L + k \\ln n,$$\n其中 $L$ 是每个模型下的最大化（复合）似然， $k$ 是根据所述复合多项式参数化从计数中估计出的自由参数数量。对于每个模型，根据其约束从第一性原理推导其参数的最大似然估计，计算最大化复合对数似然 $\\ln L$，然后计算 $\\mathrm{AIC}$ 和 $\\mathrm{BIC}$。根据每个信息准则确定首选模型（即 AIC 和 BIC 值最小的模型）。\n\n最后，将首选模型在赤池信息准则 (AIC) 下的惩罚调整似然定义为\n$$\\Lambda_{\\mathrm{AIC}} := \\exp\\!\\left(-\\frac{\\mathrm{AIC}}{2}\\right).$$\n计算首选模型的 $\\Lambda_{\\mathrm{AIC}}$，并将您的最终答案表示为代入了数值计数的单一闭式解析表达式。不需要单位。如果您在任何步骤选择进行数值近似，您仍必须以基本函数的形式，将最终答案呈现为 $\\Lambda_{\\mathrm{AIC}}$ 的精确闭式表达式，并代入给定的整数；不要对最终表达式进行四舍五入。",
            "solution": "问题要求使用赤池信息准则 (AIC) 和贝叶斯信息准则 (BIC)，基于观察到的定向替换计数，对四种核苷酸替换模型 (JC69, K80, HKY85, GTR) 进行模型比较分析。模型概率被表述为与 $\\pi_i r_{ij}$ 成正比，其中 $\\pi_i$ 是碱基 $i$ 的稳态频率，而 $r_{ij}$ 是从 $i$ 到 $j$ 的瞬时替换速率。\n\n首先，我们汇总给定的替换计数。\n计数如下：\n$c_{AG} = 520$, $c_{GA} = 500$, $c_{CT} = 540$, $c_{TC} = 515$。\n$c_{AC} = 130$, $c_{CA} = 125$, $c_{AT} = 140$, $c_{TA} = 135$, $c_{CG} = 110$, $c_{GC} = 115$, $c_{GT} = 120$, $c_{TG} = 118$。\n\n转换的总计数为 $C_T = c_{AG} + c_{GA} + c_{CT} + c_{TC} = 520 + 500 + 540 + 515 = 2075$。\n颠换的总计数为 $C_V = c_{AC} + c_{CA} + c_{AT} + c_{TA} + c_{CG} + c_{GC} + c_{GT} + c_{TG} = 130+125+140+135+110+115+120+118 = 993$。\n观察到的替换事件总数为 $n = C_T + C_V = 2075 + 993 = 3068$。\n\n问题被建模为一个具有 $12$ 个类别的多项式实验（定向替换 $i \\to j, i \\neq j$）。我们记为 $\\ln L$ 的复合对数似然核由 $\\ln L = \\sum_{i \\neq j} c_{ij} \\ln p_{ij}$ 给出，其中 $p_{ij}$ 是给定模型下的类别概率。我们省略了多项式系数常数，因为它不影响模型选择。\n\n我们分析每个模型以找到其最大化对数似然。\n\n**1. Jukes–Cantor (JC69) 模型**\n在 JC69 模型下，碱基频率相等 ($\\pi_i = 1/4$) 且所有替换速率相等 ($r_{ij} = r$)。因此，概率 $p_{ij} \\propto \\pi_i r_{ij}$ 对于所有 $12$ 种替换类型都是相同的。\n归一化约束 $\\sum_{i \\neq j} p_{ij} = 1$ 意味着 $12 p = 1$，所以对于所有 $i \\neq j$ 都有 $p_{ij} = 1/12$。\n没有自由参数，所以 $k_{\\mathrm{JC69}} = 0$。\n最大化对数似然为：\n$$ \\ln L_{\\mathrm{JC69}} = \\sum_{i \\neq j} c_{ij} \\ln\\left(\\frac{1}{12}\\right) = n \\ln\\left(\\frac{1}{12}\\right) = -3068 \\ln(12) $$\n\n**2. Kimura 2-参数 (K80) 模型**\n在 K80 模型下，碱基频率相等 ($\\pi_i = 1/4$)。有一个用于转换的速率 ($\\alpha$) 和另一个用于颠换的速率 ($\\beta$)，模型参数是它们的比率 $\\kappa = \\alpha/\\beta$。\n有 $4$ 种转换类型和 $8$ 种颠换类型。\n任何转换的概率为 $p_T \\propto (1/4)\\alpha$。任何颠换的概率为 $p_V \\propto (1/4)\\beta$。\n所以，$p_T/p_V = \\kappa$。归一化约束为 $4p_T + 8p_V = 1$。\n代入 $p_T = \\kappa p_V$，我们得到 $4\\kappa p_V + 8p_V = 1$，这给出 $p_V = \\frac{1}{4\\kappa+8}$ 和 $p_T = \\frac{\\kappa}{4\\kappa+8}$。\n对数似然为 $\\ln L(\\kappa) = C_T \\ln p_T + C_V \\ln p_V = C_T \\ln\\left(\\frac{\\kappa}{4\\kappa+8}\\right) + C_V \\ln\\left(\\frac{1}{4\\kappa+8}\\right) = C_T \\ln\\kappa - n \\ln(4\\kappa+8)$。\n为了找到 $\\kappa$ 的最大似然估计 (MLE)，我们对 $\\kappa$ 求导并令其为零：\n$$ \\frac{d \\ln L}{d\\kappa} = \\frac{C_T}{\\kappa} - \\frac{4n}{4\\kappa+8} = \\frac{C_T}{\\kappa} - \\frac{n}{\\kappa+2} = 0 $$\n这得出 $C_T(\\kappa+2) = n\\kappa$。由于 $n = C_T+C_V$，我们有 $(n-C_T)\\kappa = 2C_T$，化简为 $C_V \\kappa = 2C_T$。\nMLE 是 $\\hat{\\kappa} = \\frac{2C_T}{C_V}$。\n将 MLE 代回概率表达式，得到 $\\hat{p}_T = \\frac{C_T}{4n}$ 和 $\\hat{p}_V = \\frac{C_V}{8n}$。\n最大化对数似然为：\n$$ \\ln L_{\\mathrm{K80}} = C_T \\ln\\left(\\frac{C_T}{4n}\\right) + C_V \\ln\\left(\\frac{C_V}{8n}\\right) $$\n$$ \\ln L_{\\mathrm{K80}} = C_T \\ln(C_T) + C_V \\ln(C_V) - C_T\\ln(4n) - C_V\\ln(8n) $$\n$$ \\ln L_{\\mathrm{K80}} = 2075 \\ln(2075) + 993 \\ln(993) - 2075 \\ln(12272) - 993 \\ln(24544) $$\n自由参数的数量为 $k_{\\mathrm{K80}} = 1$。\n\n**3. Hasegawa–Kishino–Yano (HKY85) 模型**\nHKY85 允许不相等的碱基频率 $\\pi_i$ 和一个转换/颠换比率 $\\kappa$。自由参数的数量为 $k_{\\mathrm{HKY85}} = 4$（$3$ 个用于 $\\pi_i$， $1$ 个用于 $\\kappa$）。\n从碱基 $i$ 发生转换的概率为 $p_{i, ts} \\propto \\pi_i \\alpha$，发生颠换的概率为 $p_{i, tv} \\propto \\pi_i \\beta$。\n归一化因子是 $Z = \\sum_{i \\neq j} \\pi_i r_{ij} = \\sum_i \\pi_i (\\alpha + 2\\beta) = \\alpha+2\\beta = \\beta(\\kappa+2)$。\n概率为 $p_{i,ts} = \\frac{\\pi_i \\kappa}{\\kappa+2}$ 和 $p_{i,tv} = \\frac{\\pi_i}{\\kappa+2}$。\n对数似然为 $\\ln L(\\pi, \\kappa) = \\sum_{i \\neq j} c_{ij} \\ln p_{ij} = (\\sum_{i} S_i \\ln\\pi_i) + C_T\\ln\\kappa - n\\ln(\\kappa+2)$，其中 $S_i = \\sum_{j \\neq i} c_{ij}$ 是从碱基 $i$ 开始的替换总数。\nMLEs 是通过分别对 $\\pi_i$ 和 $\\kappa$ 最大化此表达式找到的。这得出 $\\hat{\\kappa} = \\frac{2C_T}{C_V}$ (与 K80 相同) 和 $\\hat{\\pi}_i = S_i/n$。\n计数为：$S_A = 520+130+140=790$, $S_C = 125+540+110=775$, $S_G = 500+115+120=735$, $S_T = 135+515+118=768$。\n最大化对数似然为：\n$$ \\ln L_{\\mathrm{HKY85}} = \\sum_i S_i \\ln\\left(\\frac{S_i}{n}\\right) + C_T\\ln\\left(\\frac{2C_T}{C_V}\\right) - n\\ln\\left(\\frac{2C_T}{C_V}+2\\right) $$\n$$ \\ln L_{\\mathrm{HKY85}} = (790 \\ln(\\frac{790}{3068}) + \\dots) + 2075 \\ln(\\frac{4150}{993}) - 3068 \\ln(\\frac{6136}{993}) $$\n\n**4. 通用时间可逆 (GTR) 模型**\nGTR 模型被指定为具有对称的定向类别概率，$p_{ij}=p_{ji}$，有 $5$ 个自由参数 ($k_{\\mathrm{GTR}} = 5$)。这对应于一个模型，其中每个无序碱基对 $\\{i,j\\}$ 有 $6$ 个概率参数，我们称之为 $q_{\\{i,j\\}}$，并受一个归一化约束 $2\\sum q_{\\{i,j\\}}=1$ 的限制。\n对数似然为 $\\ln L(q) = \\sum_{\\{i,j\\}} (c_{ij}+c_{ji}) \\ln q_{\\{i,j\\}}$。定义 $C_{\\{i,j\\}} = c_{ij}+c_{ji}$，我们有 $\\ln L(q) = \\sum_{\\{i,j\\}} C_{\\{i,j\\}} \\ln q_{\\{i,j\\}}$。\nMLE 是 $\\hat{q}_{\\{i,j\\}} = \\frac{C_{\\{i,j\\}}}{2n}$。\n合并后的计数为：$C_{\\{AG\\}}=1020, C_{\\{CT\\}}=1055, C_{\\{AC\\}}=255, C_{\\{AT\\}}=275, C_{\\{CG\\}}=225, C_{\\{GT\\}}=238$。\n最大化对数似然为：\n$$ \\ln L_{\\mathrm{GTR}} = \\sum_{\\{i,j\\}} C_{\\{i,j\\}} \\ln\\left(\\frac{C_{\\{i,j\\}}}{2n}\\right) $$\n$$ \\ln L_{\\mathrm{GTR}} = 1020 \\ln\\left(\\frac{1020}{6136}\\right) + \\dots + 238 \\ln\\left(\\frac{238}{6136}\\right) $$\n\n**模型比较**\n我们计算最大化对数似然的数值：\n- $\\ln L_{\\mathrm{JC69}} = -3068 \\ln(12) \\approx -7622.7$\n- $\\ln L_{\\mathrm{K80}} \\approx 2075 \\ln(2075) + 993 \\ln(993) - 2075 \\ln(12272) - 993 \\ln(24544) \\approx -6873.0$\n- $\\ln L_{\\mathrm{HKY85}} \\approx -6871.9$\n- $\\ln L_{\\mathrm{GTR}} \\approx \\sum C_{\\{i,j\\}}\\ln(C_{\\{i,j\\}}) - n \\ln(2n) \\approx -6871.2$\n\n现在我们为每个模型计算 AIC 和 BIC。\n- $\\mathrm{AIC}_{\\mathrm{JC69}} = -2(-7622.7) + 2(0) = 15245.4$\n- $\\mathrm{BIC}_{\\mathrm{JC69}} = 15245.4 + 0 = 15245.4$\n\n- $\\mathrm{AIC}_{\\mathrm{K80}} = -2(-6873.0) + 2(1) = 13746.0 + 2 = 13748.0$\n- $\\mathrm{BIC}_{\\mathrm{K80}} = 13746.0 + 1 \\ln(3068) \\approx 13746.0 + 8.0 = 13754.0$\n\n- $\\mathrm{AIC}_{\\mathrm{HKY85}} = -2(-6871.9) + 2(4) = 13743.8 + 8 = 13751.8$\n- $\\mathrm{BIC}_{\\mathrm{HKY85}} = 13743.8 + 4 \\ln(3068) \\approx 13743.8 + 32.1 = 13775.9$\n\n- $\\mathrm{AIC}_{\\mathrm{GTR}} = -2(-6871.2) + 2(5) = 13742.4 + 10 = 13752.4$\n- $\\mathrm{BIC}_{\\mathrm{GTR}} = 13742.4 + 5 \\ln(3068) \\approx 13742.4 + 40.1 = 13782.5$\n\n比较这些值（越低越好）：\n- 根据 AIC：K80 模型的 AIC 最低 ($13748.0$)。\n- 根据 BIC：K80 模型的 BIC 最低 ($13754.0$)。\n\n两种准则都选择 K80 模型作为首选模型。\n\n**最终计算**\n我们计算首选模型 K80 的惩罚调整似然 $\\Lambda_{\\mathrm{AIC}} = \\exp(-\\frac{\\mathrm{AIC}}{2})$。\n使用基于对数似然核的 AIC 定义：\n$\\mathrm{AIC}_{\\mathrm{K80}} = -2 \\ln L_{\\mathrm{K80}} + 2k_{\\mathrm{K80}}$\n$$ \\Lambda_{\\mathrm{AIC}} = \\exp\\left(-\\frac{-2 \\ln L_{\\mathrm{K80}} + 2k_{\\mathrm{K80}}}{2}\\right) = \\exp(\\ln L_{\\mathrm{K80}} - k_{\\mathrm{K80}}) = \\exp(\\ln L_{\\mathrm{K80}} - 1) $$\n代入 $\\ln L_{\\mathrm{K80}}$ 的表达式：\n$$ \\Lambda_{\\mathrm{AIC}} = \\exp\\left( C_T \\ln\\left(\\frac{C_T}{4n}\\right) + C_V \\ln\\left(\\frac{C_V}{8n}\\right) - 1 \\right) $$\n$$ \\Lambda_{\\mathrm{AIC}} = \\exp(-1) \\left(\\frac{C_T}{4n}\\right)^{C_T} \\left(\\frac{C_V}{8n}\\right)^{C_V} $$\n我们将包含 $n$ 和 $2$ 的幂的项分解出来：\n$$ \\Lambda_{\\mathrm{AIC}} = \\exp(-1) \\frac{C_T^{C_T} C_V^{C_V}}{ (4n)^{C_T} (8n)^{C_V} } = \\exp(-1) \\frac{C_T^{C_T} C_V^{C_V}}{ 4^{C_T} 8^{C_V} n^{C_T+C_V} } $$\n$$ \\Lambda_{\\mathrm{AIC}} = \\exp(-1) \\frac{C_T^{C_T} C_V^{C_V}}{ (2^2)^{C_T} (2^3)^{C_V} n^n } = \\exp(-1) \\frac{C_T^{C_T} C_V^{C_V}}{ n^n 2^{2C_T+3C_V} } $$\n代入数值计数：$C_T=2075$, $C_V=993$, $n=3068$。\n$2$ 的指数是 $2(2075) + 3(993) = 4150 + 2979 = 7129$。\n最终表达式为：\n$$ \\Lambda_{\\mathrm{AIC}} = \\exp(-1) \\frac{2075^{2075} \\cdot 993^{993}}{3068^{3068} \\cdot 2^{7129}} $$",
            "answer": "$$\n\\boxed{\\exp(-1) \\frac{2075^{2075} \\cdot 993^{993}}{3068^{3068} \\cdot 2^{7129}}}\n$$"
        },
        {
            "introduction": "评分矩阵只是序列比对流程中的一个组成部分，空位罚分也同样至关重要，一个评分系统的真正考验是其在实际任务中的表现。在这个动手编程挑战中，您将实现一个局部比对算法，并用它来构建一个能够区分同源序列与非同源“诱饵”序列的分类器。然后，您将使用受试者工作特征曲线下面积 ($ROC$ $AUC$) 作为评价指标，系统地评估不同评分系统——即替换矩阵和空位罚分的组合——的性能。这项实践  连接了理论与应用，您将学习如何对不同的评分策略进行基准测试，识别出鲁棒的参数选择，并对替换分数和空位罚分在实现最佳比对灵敏度和特异性方面的相互作用获得实践性的理解。",
            "id": "4591533",
            "problem": "给定两个带标签的成对序列数据集：一个蛋白质数据集和一个脱氧核糖核酸（DNA）数据集。每对序列都被标记为同源（正例）或诱饵（负例）。您必须实现一个基于局部成对序列比对的分类器，该分类器使用仿射空位罚分模型和对数奇数比取代矩阵，然后评估其受试者工作特征曲线下面积（ROC AUC）。您将为多个取代矩阵计算在一系列网格化的空位罚分参数下的 ROC AUC，然后识别出性能保持在接近最优水平的稳健参数空间区域。\n\n使用以下基本原理。使用仿射空位的局部比对旨在基于取代得分函数和空位罚分方案，最大化所有可能的局部子序列的比对得分。对数奇数比取代矩阵将比对残基 $x$ 和 $y$ 的得分 $S(x,y)$ 编码为 $S(x,y) = \\log \\frac{p(x,y)}{q(x)q(y)}$，其中 $p(x,y)$ 是在同源序列中观察到 $x$ 与 $y$ 比对的概率，而 $q(x)$ 和 $q(y)$ 是背景频率。仿射空位罚分模型为空位长度为 $k$ 的空位分配一个成本 $g(k) = g_o + k \\cdot g_e$，其中 $g_o$ 是空位开放罚分，$g_e$ 是空位延伸罚分。在仿射模型下，局部比对得分是通过动态规划获得的最优值。为了进行分类，将一对序列的得分定义为在指定的取代矩阵和空位罚分下其最优局部比对得分。受试者工作特征（ROC）曲线比较了在不同决策阈值下的真阳性率和假阳性率，而曲线下面积（AUC）是 ROC 曲线的积分，等价于随机选择的正例得分高于随机选择的负例得分的概率。\n\n您的程序必须：\n\n- 实现带仿射空位罚分的局部比对，为每对序列计算比对得分：\n    - 给定两个序列 $a_1 a_2 \\dots a_m$ 和 $b_1 b_2 \\dots b_n$、一个取代函数 $S(\\cdot,\\cdot)$ 以及空位罚分 $g_o$ 和 $g_e$，计算所有子串的最优局部比对得分。\n- 对于每个指定的取代矩阵和一系列网格化的空位罚分参数 $(g_o, g_e)$，使用比对得分作为分类器得分，计算所有带标签序列对的 ROC AUC。使用基于秩的 ROC AUC 计算公式：对于 $n_+$ 个正例得分和 $n_-$ 个负例得分，令 $R_+$ 为正例得分在合并列表中的秩之和（对于平局使用平均秩）。则 AUC 为\n$$ \\text{AUC} = \\frac{R_+ - \\frac{n_+(n_+ + 1)}{2}}{n_+ n_-}. $$\n- 对于给定的取代矩阵，将其稳健参数区域定义为 AUC 值与该取代矩阵在数据集上实现的最大 AUC 值的差距在 $\\Delta$ 以内的 $(g_o, g_e)$ 网格点集合。使用 $\\Delta = 0.01$。\n- 报告每个取代矩阵在网格上的最大 AUC 及其稳健区域中的网格点数量。\n\n数据集和测试套件：\n\n- 蛋白质数据集（氨基酸字母表）。正例（同源对）：\n    - (\"MKTLLILALV\",\"MKTLVILALV\")\n    - (\"GAVLKVLTT\",\"GAVLKVLAT\")\n    - (\"HPNFGWQVL\",\"HPDFGWQVL\")\n    - (\"QQHLLSKNF\",\"QQHLLSKHF\")\n    - (\"VVKDNNTLE\",\"VVKDNNTLE\")\n    - (\"NSTEQQLIM\",\"NSTEQQLIM\")\n    - (\"RGLPYTNVV\",\"RGLPYANVV\")\n    - (\"KDELRQKLE\",\"KDELRQKLE\")\n  负例（诱饵）：\n    - (\"MKTLLILALV\",\"GGGGGGGGGG\")\n    - (\"GAVLKVLTT\",\"LLLLLLLLLL\")\n    - (\"HPNFGWQVL\",\"AAAAAAAAA\")\n    - (\"QQHLLSKNF\",\"PPPPPPPPP\")\n    - (\"VVKDNNTLE\",\"SSSSSSSSS\")\n    - (\"NSTEQQLIM\",\"TTTTTTTTT\")\n    - (\"RGLPYTNVV\",\"NNNNNNNNN\")\n    - (\"KDELRQKLE\",\"YYYYYYYYY\")\n- DNA 数据集（核苷酸字母表 $\\{A,C,G,T\\}$）。正例：\n    - (\"ATGCGTAC\",\"ATGCGTAC\")\n    - (\"GATTACA\",\"GATTTCA\")\n    - (\"CCGGAATT\",\"CCGGAACT\")\n    - (\"TTGCCAAA\",\"TTGCCAAG\")\n    - (\"AACCGGTT\",\"AACCGGTT\")\n    - (\"GGATCCGA\",\"GGATCCGA\")\n  负例：\n    - (\"ATGCGTAC\",\"TGCATGCA\")\n    - (\"GATTACA\",\"CTAGGAT\")\n    - (\"CCGGAATT\",\"TTCCGGAA\")\n    - (\"TTGCCAAA\",\"GGGTTCCC\")\n    - (\"AACCGGTT\",\"TTAACCGG\")\n    - (\"GGATCCGA\",\"AACCTTGG\")\n\n待评估的取代矩阵：\n\n- 氨基酸：BLOSUM62 和 PAM250。将它们视为标准 $20$ 种氨基酸中 $x,y$ 的对数奇数比得分表 $S(x,y)$。\n- DNA 矩阵：\n    - DNA\\_simple：匹配时 $S(x,y)=1$，错配时 $S(x,y)=-1$。\n    - DNA\\_ttv（转换/颠换加权）：匹配时 $S(x,y)=2$；对于转换（$A \\leftrightarrow G$ 或 $C \\leftrightarrow T$），$S(x,y)=-1$；对于颠换，$S(x,y)=-2$。\n\n空位罚分网格：\n\n- 使用 $g_o \\in \\{8,10,12\\}$ 和 $g_e \\in \\{1,2,3\\}$，为每个取代矩阵形成一个包含 $9$ 种参数组合的网格。\n\n稳健性标准：\n\n- 对于每个取代矩阵和数据集，设 $A_{\\max}$ 为网格上的最大 AUC，并取 $\\Delta = 0.01$。如果一个网格点的 AUC $A$ 满足 $A \\ge A_{\\max} - \\Delta$，则该点是稳健的。\n\n要求的最终输出：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含：\n    - 对于蛋白质数据集：BLOSUM62 的最大 AUC（四舍五入到 $3$ 位小数），BLOSUM62 的稳健点计数（整数），PAM250 的最大 AUC（四舍五入到 $3$ 位小数），PAM250 的稳健点计数（整数）。\n    - 对于 DNA 数据集：DNA\\_simple 的最大 AUC（四舍五入到 $3$ 位小数），DNA\\_simple 的稳健点计数（整数），DNA\\_ttv 的最大 AUC（四舍五入到 $3$ 位小数），DNA\\_ttv 的稳健点计数（整数）。\n- 最终打印的行必须没有多余的文本，并遵循确切的格式规范。\n\n覆盖设计：\n\n- 蛋白质数据集用于评估氨基酸取代矩阵；DNA 数据集用于评估核苷酸矩阵。\n- 空位罚分网格测试了 $g_o \\in \\{8,10,12\\}$ 和 $g_e \\in \\{1,2,3\\}$ 的边界条件，涵盖了更严格和更宽松的空位模型。\n- 稳健区域识别通过 $\\Delta = 0.01$ 的容差来测试对参数选择的敏感性。",
            "solution": "该问题要求实现并评估一个生物信息学分类器。分类器对一对序列（蛋白质或 DNA）的评分由最优局部比对得分确定，该得分使用仿射空位罚分模型计算。然后，该得分用于区分同源（正例）和非同源诱饵（负例）序列对。此分类器的性能通过受试者工作特征曲线下面积（$\\text{AUC}$）来量化。此评估是针对几种标准取代矩阵在一系列网格化的空位罚分参数上进行的。最后，对于每个矩阵，我们识别出性能接近最优的稳健参数区域。\n\n解决方案分为三个主要部分：\n$1$. 用于计算带仿射空位罚分的局部比对得分的核心算法。\n$2$. 根据正例和负例对的比对得分计算 $\\text{AUC}$ 的过程。\n$3$. 系统性评估方法，包括参数网格搜索和稳健区域的识别。\n\n### $1$. 带仿射空位罚分的局部比对\n\n问题指定了局部比对，其目的是在两个输入序列（例如 $a = a_1a_2\\dots a_m$ 和 $b = b_1b_2\\dots b_n$）的任何可能子串之间寻找得分最高的比对。计分基于一个取代矩阵 $S(x,y)$ 和一个仿射空位罚分模型。长度为 $k$ 的空位会产生一个罚分 $g(k) = g_o + k \\cdot g_e$，其中 $g_o$ 是空位开放罚分，$g_e$ 是空位延伸罚分。由于得分是最大化的，这些罚分将被减去。\n\n这个问题使用动态规划方法解决，特别是 Smith-Waterman-Gotoh 算法。使用三个矩阵 $M(i,j)$、$I_x(i,j)$ 和 $I_y(i,j)$ 来存储前缀 $a_1\\dots a_i$ 和 $b_1\\dots b_j$ 的最优比对得分。\n\n-   $M(i,j)$: 以 $a_i$ 与 $b_j$ 匹配结尾的比对得分。\n-   $I_x(i,j)$: 以 $a_i$ 与一个空位（'-'）比对结尾的比对得分。\n-   $I_y(i,j)$: 以 $b_j$ 与一个空位（'-'）比对结尾的比对得分。\n\n对于 $i$ 从 $1$ 到 $m$ 和 $j$ 从 $1$ 到 $n$，递推关系定义如下：\n\n$1$. 以匹配或错配（$a_i$ vs $b_j$）结尾的比对得分由以下公式给出：\n$$ M(i,j) = S(a_i, b_j) + \\max \\begin{cases} M(i-1, j-1)  \\text{(来自前一个匹配/错配)} \\\\ I_x(i-1, j-1)  \\text{(来自序列 } b \\text{ 中的空位)} \\\\ I_y(i-1, j-1)  \\text{(来自序列 } a \\text{ 中的空位)} \\\\ 0  \\text{(开始一个新的局部比对)} \\end{cases} $$\n包含 $0$ 项是 Smith-Waterman 算法的“局部”特性，它允许在任何位置 $(i,j)$ 开始一个新的局部比对，前提是所有先前位置结束的比对得分都为负。\n\n$2$. 以序列 $b$ 中的空位（相对于序列 $a$ 的删除）结尾的比对得分是：\n$$ I_x(i,j) = \\max \\begin{cases} M(i-1, j) - (g_o + g_e)  \\text{(开放一个新空位)} \\\\ I_x(i-1, j) - g_e  \\text{(延伸一个现有空位)} \\end{cases} $$\n\n$3$. 以序列 $a$ 中的空位（相对于序列 $a$ 的插入）结尾的比对得分是：\n$$ I_y(i,j) = \\max \\begin{cases} M(i, j-1) - (g_o + g_e)  \\text{(开放一个新空位)} \\\\ I_y(i, j-1) - g_e  \\text{(延伸一个现有空位)} \\end{cases} $$\n\n边界条件是 $M(0,0)=0$，$M$ 的第一行和第一列中的所有其他值均为 $0$，而对于 $I_x$ 和 $I_y$，它们被初始化为 $-\\infty$ 以禁止在比对开始时出现空位。最优局部比对得分是在所有 $i,j$ 中矩阵 $M$ 中找到的最大值。如果所有可能的比对得分都是负数，则最优得分为 $0$，这由 $M(i,j)$ 的递推式自然处理。\n\n### $2$. 使用 ROC AUC 进行分类器评估\n\n比对得分作为我们分类器的判别值。得分高的一对序列被预测为同源，而得分低的一对则被预测为诱饵。为了评估分类器区分这两个类别（同源与诱饵）的能力，我们使用受试者工作特征曲线下面积（$\\text{AUC}$）。\n\n$\\text{AUC}$ 表示一个随机选择的正例（同源对）的排名高于一个随机选择的负例（诱饵对）的概率，排名基于比对得分。问题指定了一个基于秩的公式来计算它：\n$$ \\text{AUC} = \\frac{R_+ - \\frac{n_+(n_+ + 1)}{2}}{n_+ n_-} $$\n其中 $n_+$ 是正样本的数量，$n_-$ 是负样本的数量，$R_+$ 是正例得分在所有得分的组合排序列表中的秩之和。得分的平局通过为所有平局项分配平均秩来处理。$\\text{AUC}$ 为 $1.0$ 表示完美分离，而 $\\text{AUC}$ 为 $0.5$ 表明性能不比随机猜测好。\n\n### $3$. 参数搜索和稳健性分析\n\n基于比对的分类器的性能对取代矩阵和空位罚分的选择很敏感。问题要求在指定的空位开放（$g_o \\in \\{8,10,12\\}$）和空位延伸（$g_e \\in \\{1,2,3\\}$）罚分集上进行网格搜索。对于取代矩阵和 $(g_o, g_e)$ 对的每种组合，我们计算数据集中所有序列对的局部比对得分，然后计算由此产生的 $\\text{AUC}$。\n\n在为给定取代矩阵的参数网格中的所有 $9$ 个点计算 $\\text{AUC}$ 后，我们确定最大 $\\text{AUC}$，记为 $A_{\\max}$。“稳健参数区域”则定义为 $(g_o, g_e)$ 网格点的集合，其对应的 $\\text{AUC}$ 值 $A$ 满足条件 $A \\ge A_{\\max} - \\Delta$，其中 $\\Delta = 0.01$。该区域的大小（此类网格点的数量）提供了关于分类器性能对空位罚分参数微小变化的敏感度的见解。数量越大意味着稳健性越强。\n\n最终输出汇总了这些发现：对于每个取代矩阵（蛋白质的 BLOSUM62、PAM250；DNA 的 DNA_simple、DNA_ttv），我们报告实现的最大 $\\text{AUC}$ 和稳健区域中的点数。此过程独立地应用于蛋白质和 DNA 数据集。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import rankdata\n\ndef solve():\n    # --- Data Definition ---\n\n    # Amino acid substitution matrices (BLOSUM62 and PAM250)\n    BLOSUM62_TEXT = \"\"\"\n       A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V\n    A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -1 -2 -1  1  0 -3 -2  0\n    R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -1 -3 -2 -1 -1 -3 -2 -3\n    N -2  0  6  1 -3  0  0  0  1 -3 -3  0 -2 -3 -2  1  0 -4 -2 -3\n    D -2 -2  1  6 -3  0  2 -1 -1 -3 -4 -1 -3 -3 -1  0 -1 -4 -3 -3\n    C  0 -3 -3 -3  9 -3 -4 -3 -3 -1 -1 -3 -1 -2 -3 -1 -1 -2 -2 -1\n    Q -1  1  0  0 -3  5  2 -2  0 -3 -2  1  0 -3 -1  0 -1 -2 -1 -2\n    E -1  0  0  2 -4  2  5 -2  0 -3 -3  1 -2 -3 -1  0 -1 -3 -2 -2\n    G  0 -2  0 -1 -3 -2 -2  6 -2 -4 -4 -2 -3 -3 -2  0 -2 -2 -3 -3\n    H -2  0  1 -1 -3  0  0 -2  8 -3 -3 -1 -2 -1 -2 -1 -2 -2  2 -3\n    I -1 -3 -3 -3 -1 -3 -3 -4 -3  4  2 -3  1  0 -3 -2 -1 -3 -1  3\n    L -1 -2 -3 -4 -1 -2 -3 -4 -3  2  4 -2  2  0 -3 -2 -1 -2 -1  1\n    K -1  2  0 -1 -3  1  1 -2 -1 -3 -2  5 -1 -3 -1  0 -1 -3 -2 -2\n    M -1 -1 -2 -3 -1  0 -2 -3 -2  1  2 -1  5  0 -2 -1 -1 -1 -1  1\n    F -2 -3 -3 -3 -2 -3 -3 -3 -1  0  0 -3  0  6 -4 -2 -2  1  3 -1\n    P -1 -2 -2 -1 -3 -1 -1 -2 -2 -3 -3 -1 -2 -4  7 -1 -1 -4 -3 -2\n    S  1 -1  1  0 -1  0  0  0 -1 -2 -2  0 -1 -2 -1  4  1 -3 -2 -2\n    T  0 -1  0 -1 -1 -1 -1 -2 -2 -1 -1 -1 -1 -2 -1  1  5 -2 -2  0\n    W -3 -3 -4 -4 -2 -2 -3 -2 -2 -3 -2 -3 -1  1 -4 -3 -2 11  2 -3\n    Y -2 -2 -2 -3 -2 -1 -2 -3  2 -1 -1 -2 -1  3 -3 -2 -2  2  7 -1\n    V  0 -3 -3 -3 -1 -2 -2 -3 -3  3  1 -2  1 -1 -2 -2  0 -3 -1  4\n    \"\"\"\n\n    PAM250_TEXT = \"\"\"\n       A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V\n    A  2 -2  0  0 -2  0  0  1 -1 -1 -2 -1 -1 -3  1  1  1 -6 -3  0\n    R -2  6  0 -1 -4  1 -1 -3  2 -2 -3  3  0 -4  0  0 -1  2 -4 -2\n    N  0  0  2  2 -4  1  1  0  2 -2 -3  1 -2 -3  0  1  0 -4 -2 -2\n    D  0 -1  2  4 -5  2  3  1  1 -2 -4  0 -3 -6 -1  0  0 -7 -4 -2\n    C -2 -4 -4 -5 12 -5 -5 -3 -3 -2 -6 -5 -5 -4 -3  0 -2 -8  0 -2\n    Q  0  1  1  2 -5  4  2 -1  3 -2 -2  1 -1 -5  0 -1 -1 -5 -4 -2\n    E  0 -1  1  3 -5  2  4  0  1 -2 -3  0 -2 -5 -1  0  0 -7 -4 -2\n    G  1 -3  0  1 -3 -1  0  5 -2 -3 -4 -2 -3 -5  0  1  0 -7 -5 -1\n    H -1  2  2  1 -3  3  1 -2  6 -2 -2  0 -2 -2  0 -1 -1 -3  0 -2\n    I -1 -2 -2 -2 -2 -2 -2 -3 -2  5  2 -2  2  1 -2 -1  0 -5 -1  4\n    L -2 -3 -3 -4 -6 -2 -3 -4 -2  2  6 -3  4  2 -3 -3 -2 -2 -1  2\n    K -1  3  1  0 -5  1  0 -2  0 -2 -3  5  0 -5 -1  0  0 -3 -4 -2\n    M -1  0 -2 -3 -5 -1 -2 -3 -2  2  4  0  6  0 -2 -2 -1 -4 -2  2\n    F -3 -4 -3 -6 -4 -5 -5 -5 -2  1  2 -5  0  9 -5 -3 -3  0  7 -1\n    P  1  0  0 -1 -3  0 -1  0  0 -2 -3 -1 -2 -5  6  1  0 -6 -5 -1\n    S  1  0  1  0  0 -1  0  1 -1 -1 -3  0 -2 -3  1  2  1 -2 -3  0\n    T  1 -1  0  0 -2 -1  0  0 -1  0 -2  0 -1 -3  0  1  3 -5 -3  0\n    W -6  2 -4 -7 -8 -5 -7 -7 -3 -5 -2 -3 -4  0 -6 -2 -5 17  0 -6\n    Y -3 -4 -2 -4  0 -4 -4 -5  0 -1 -1 -4 -2  7 -5 -3 -3  0 10 -2\n    V  0 -2 -2 -2 -2 -2 -2 -1 -2  4  2 -2  2 -1 -1  0  0 -6 -2  4\n    \"\"\"\n\n    def parse_matrix(text):\n        lines = text.strip().split('\\n')\n        header = lines[0].split()\n        matrix = {aa: {} for aa in header}\n        for line in lines[1:]:\n            parts = line.split()\n            row_aa = parts[0]\n            for col_aa, score in zip(header, parts[1:]):\n                matrix[row_aa][col_aa] = int(score)\n        return matrix\n\n    protein_matrices = {\n        \"BLOSUM62\": parse_matrix(BLOSUM62_TEXT),\n        \"PAM250\": parse_matrix(PAM250_TEXT)\n    }\n\n    # DNA substitution matrices (defined logically)\n    def dna_simple_matrix(c1, c2):\n        return 1 if c1 == c2 else -1\n\n    def dna_ttv_matrix(c1, c2):\n        if c1 == c2:\n            return 2\n        transitions = {('A', 'G'), ('G', 'A'), ('C', 'T'), ('T', 'C')}\n        if (c1, c2) in transitions:\n            return -1\n        else: # Transversions\n            return -2\n\n    # Datasets\n    protein_positives = [(\"MKTLLILALV\",\"MKTLVILALV\"), (\"GAVLKVLTT\",\"GAVLKVLAT\"), (\"HPNFGWQVL\",\"HPDFGWQVL\"), (\"QQHLLSKNF\",\"QQHLLSKHF\"), (\"VVKDNNTLE\",\"VVKDNNTLE\"), (\"NSTEQQLIM\",\"NSTEQQLIM\"), (\"RGLPYTNVV\",\"RGLPYANVV\"), (\"KDELRQKLE\",\"KDELRQKLE\")]\n    protein_negatives = [(\"MKTLLILALV\",\"GGGGGGGGGG\"), (\"GAVLKVLTT\",\"LLLLLLLLLL\"), (\"HPNFGWQVL\",\"AAAAAAAAA\"), (\"QQHLLSKNF\",\"PPPPPPPPP\"), (\"VVKDNNTLE\",\"SSSSSSSSS\"), (\"NSTEQQLIM\",\"TTTTTTTTT\"), (\"RGLPYTNVV\",\"NNNNNNNNN\"), (\"KDELRQKLE\",\"YYYYYYYYY\")]\n    \n    dna_positives = [(\"ATGCGTAC\",\"ATGCGTAC\"), (\"GATTACA\",\"GATTTCA\"), (\"CCGGAATT\",\"CCGGAACT\"), (\"TTGCCAAA\",\"TTGCCAAG\"), (\"AACCGGTT\",\"AACCGGTT\"), (\"GGATCCGA\",\"GGATCCGA\")]\n    dna_negatives = [(\"ATGCGTAC\",\"TGCATGCA\"), (\"GATTACA\",\"CTAGGAT\"), (\"CCGGAATT\",\"TTCCGGAA\"), (\"TTGCCAAA\",\"GGGTTCCC\"), (\"AACCGGTT\",\"TTAACCGG\"), (\"GGATCCGA\",\"AACCTTGG\")]\n\n    gap_penalty_grid = [(g_o, g_e) for g_o in [8, 10, 12] for g_e in [1, 2, 3]]\n    robustness_delta = 0.01\n\n    # --- Core Algorithms ---\n\n    def local_align_affine(seq1, seq2, sub_matrix_func, g_o, g_e):\n        m, n = len(seq1), len(seq2)\n        \n        M = np.zeros((m + 1, n + 1), dtype=np.float64)\n        Ix = np.full((m + 1, n + 1), -np.inf, dtype=np.float64)\n        Iy = np.full((m + 1, n + 1), -np.inf, dtype=np.float64)\n\n        max_score = 0.0\n        gap_open_cost = g_o + g_e\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                match_score = sub_matrix_func(seq1[i-1], seq2[j-1])\n                \n                prev_max = max(M[i-1, j-1], Ix[i-1, j-1], Iy[i-1, j-1], 0)\n                M[i,j] = match_score + prev_max\n                \n                Ix[i,j] = max(M[i-1, j] - gap_open_cost, Ix[i-1, j] - g_e)\n                Iy[i,j] = max(M[i, j-1] - gap_open_cost, Iy[i, j-1] - g_e)\n\n                current_max = max(M[i,j], Ix[i,j], Iy[i,j])\n                if current_max > max_score:\n                    max_score = current_max\n        \n        return max_score\n\n    def calculate_auc(pos_scores, neg_scores):\n        n_pos = len(pos_scores)\n        n_neg = len(neg_scores)\n        if n_pos == 0 or n_neg == 0:\n            return 0.5\n\n        all_scores = np.concatenate((pos_scores, neg_scores))\n        ranks = rankdata(all_scores, method='average')\n        \n        r_plus = np.sum(ranks[:n_pos])\n        \n        auc = (r_plus - n_pos * (n_pos + 1) / 2) / (n_pos * n_neg)\n        return auc\n\n    # --- Main Evaluation Loop ---\n\n    final_results = []\n    \n    # Process Protein Dataset\n    for matrix_name in [\"BLOSUM62\", \"PAM250\"]:\n        matrix = protein_matrices[matrix_name]\n        sub_func = lambda c1, c2: matrix[c1][c2]\n        auc_results = []\n        for g_o, g_e in gap_penalty_grid:\n            pos_scores = [local_align_affine(s1, s2, sub_func, g_o, g_e) for s1, s2 in protein_positives]\n            neg_scores = [local_align_affine(s1, s2, sub_func, g_o, g_e) for s1, s2 in protein_negatives]\n            auc = calculate_auc(pos_scores, neg_scores)\n            auc_results.append(auc)\n        \n        max_auc = max(auc_results)\n        robust_count = sum(1 for auc in auc_results if auc >= max_auc - robustness_delta)\n        \n        final_results.append(round(max_auc, 3))\n        final_results.append(robust_count)\n\n    # Process DNA Dataset\n    dna_matrix_defs = [(\"DNA_simple\", dna_simple_matrix), (\"DNA_ttv\", dna_ttv_matrix)]\n    for matrix_name, sub_func in dna_matrix_defs:\n        auc_results = []\n        for g_o, g_e in gap_penalty_grid:\n            pos_scores = [local_align_affine(s1, s2, sub_func, g_o, g_e) for s1, s2 in dna_positives]\n            neg_scores = [local_align_affine(s1, s2, sub_func, g_o, g_e) for s1, s2 in dna_negatives]\n            auc = calculate_auc(pos_scores, neg_scores)\n            auc_results.append(auc)\n\n        max_auc = max(auc_results) if auc_results else 0\n        robust_count = sum(1 for auc in auc_results if auc >= max_auc - robustness_delta)\n\n        final_results.append(round(max_auc, 3))\n        final_results.append(robust_count)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}