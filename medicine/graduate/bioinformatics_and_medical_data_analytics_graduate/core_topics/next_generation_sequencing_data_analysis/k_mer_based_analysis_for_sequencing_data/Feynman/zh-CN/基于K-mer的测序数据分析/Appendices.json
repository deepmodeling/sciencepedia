{
    "hands_on_practices": [
        {
            "introduction": "$k$-mer 计数是许多生物信息学分析（如基因组组装和序列比对）的基础步骤。由于DNA是双链结构，一个$k$-mer和它的反向互补序列代表了相同的生物学信息。此练习旨在通过实现一个“范式”$k$-mer计数算法，来巩固这一核心概念，确保每条生物信息只被统计一次，并避免对回文序列的重复计数。",
            "id": "4576288",
            "problem": "给定一组基于字母表 $\\{A,C,G,T\\}$ 的脱氧核糖核酸（DNA）读段和一个整数 $k$。根据 Watson–Crick 碱基配对（腺嘌呤与胸腺嘧啶配对，胞嘧啶与鸟嘌呤配对）的基本原理，DNA序列的反向互补序列是通过反转该序列，并通过双射关系 $A \\leftrightarrow T$ 和 $C \\leftrightarrow G$ 对每个碱基进行互补来获得的。一个 $k$-mer 是读段内任意一个长度为 $k$ 的连续子串。在整个读段数据集中对 $k$-mer 进行计数是高通量测序分析的基础。然而，如果一个 $k$-mer 及其反向互补序列被计为两个不同的实体，那么等于其自身反向互补序列的回文 $k$-mer 可能会被重复计数，除非使用规范化程序。定义一个规范化函数 $c(s)$，它将一个 $k$-mer $s$ 映射到 $s$ 及其反向互补序列 $rc(s)$ 中字典序最小的那个序列，使用的字典序为 $A<C<G<T$。如果一个 $k$-mer $p$ 满足 $p = rc(p)$，则称其为回文 $k$-mer。\n\n基于这些基本定义，设计并实现一个算法，该算法能够：\n- 从每个读段中提取所有有效的 $k$-mer（大小为 $k$ 的窗口），跳过任何包含 $\\{A,C,G,T\\}$ 之外字符的窗口，\n- 对每个有效的 $k$-mer $s$ 计算其反向互补序列 $rc(s)$，\n- 在给定的字典序下，将每个 $k$-mer $s$ 映射到其规范表示 $c(s) = \\min(s,rc(s))$，\n- 统计所有读段中规范 $k$-mer 的出现次数，\n- 并通过一个可量化的指标，验证回文 $k$-mer 没有被重复计数。\n\n对于每个测试用例，您的程序必须产生以下输出：\n- $U$：唯一规范 $k$-mer 的数量，\n- $T$：所有读段中规范 $k$-mer 出现的总次数（计数的总和），\n- $M$：所有规范 $k$-mer 中的最大计数值（如果不存在有效的 $k$-mer，则定义 $M=0$），\n- $B$：一个布尔值，如果回文 $k$-mer 未被重复计数，则为 $\\text{True}$，否则为 $\\text{False}$。对于指定了回文目标 $p$ 的测试用例，当且仅当 $p$ 的规范计数值等于与 $p$ 完全相等的原始窗口数时，$B$ 为 $\\text{True}$；对于未指定回文目标的测试用例，当且仅当不存在互为反向互补序列的不同规范键对时，$B$ 为 $\\text{True}$。\n\n仅使用 DNA 字母表 $\\{A,C,G,T\\}$ 进行计数；任何包含此集合之外字符的窗口都必须被排除。通过在处理前转换为大写来不区分大小写地处理输入读段。反向互补函数必须严格实现 $A \\leftrightarrow T$ 和 $C \\leftrightarrow G$。规范化必须使用字典序 $A<C<G<T$。\n\n测试套件（每个测试用例是一个包含读段、$k$ 和一个可选的待检查回文目标的元组）：\n1. 读段：[\"ACGTACGT\"]，$k=4$，回文目标 \"ACGT\"。\n2. 读段：[\"A\",\"ACG\"]，$k=4$，无回文目标。\n3. 读段：[\"ANNNT\",\"NTGC\"]，$k=3$，无回文目标。\n4. 读段：[\"ATTA\",\"TAAT\"]，$k=2$，回文目标 \"AT\"。\n\n科学真实性与覆盖范围：\n- 案例 $1$ 是一个一般情况，其中存在回文 $k$-mer 和跨方向的非回文对。\n- 案例 $2$ 是一个边界条件，其中读段长度小于 $k$，不产生任何有效的 $k$-mer。\n- 案例 $3$ 测试排除包含 $\\{A,C,G,T\\}$ 之外无效字符的窗口。\n- 案例 $4$ 包含多个偶数长度的回文 $k$-mer 和非回文 $k$-mer，用于测试规范分组和回文处理。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例的结果，表示为列表 $[U,T,M,B]$。例如，输出应如下所示： \"[[U1,T1,M1,B1],[U2,T2,M2,B2],[U3,T3,M3,B3],[U4,T4,M4,B4]]\"。不涉及物理单位或角度单位。所有计数必须是整数；布尔值必须以其原生布尔表示形式打印。",
            "solution": "对用户提供的问题进行验证。\n\n### 步骤 1：提取已知信息\n- **字母表**：有效的 DNA 碱基集合为 $\\{A, C, G, T\\}$。\n- **输入**：一组 DNA 序列读段和一个整数 $k$。\n- **k-mer**：长度为 $k$ 的连续子串。\n- **数据预处理**：通过转换为大写来不区分大小写地处理输入读段。任何大小为 $k$ 且包含有效字母表 $\\{A, C, G, T\\}$ 之外字符的窗口必须从分析中排除。\n- **反向互补序列，$rc(s)$**：对于一个 $k$-mer $s$，其反向互补序列 $rc(s)$ 的获得方式是，首先反转序列 $s$，然后根据 Watson-Crick 配对规则（由双射 $A \\leftrightarrow T$ 和 $C \\leftrightarrow G$ 定义）对每个碱基进行互补。\n- **回文 k-mer，$p$**：如果一个 $k$-mer $p$ 与其反向互补序列相同，即 $p = rc(p)$，则称其为回文 $k$-mer。\n- **字典序**：用于比较的顺序定义为 $A  C  G  T$。\n- **规范化，$c(s)$**：对于任意 $k$-mer $s$，其规范表示被定义为 $s$ 与其反向互补序列 $rc(s)$ 中字典序最小的序列。数学上表示为 $c(s) = \\min(s, rc(s))$。\n- **每个测试用例的所需输出**：\n    1.  $U$：在所有读段中发现的唯一规范 $k$-mer 的数量。\n    2.  $T$：所有规范 $k$-mer 出现的总次数。这是每个唯一规范 $k$-mer 计数之和。\n    3.  $M$：为任何单个规范 $k$-mer 观察到的最大计数值。如果未找到有效的 $k$-mer，则 $M$ 必须为 $0$。\n    4.  $B$：一个布尔验证指标。其值取决于测试用例：\n        - 如果提供了特定的回文目标 $p$，$B$ 为 $\\text{True}$ 当且仅当 $p$ 的规范形式的最终计数值等于子串 $p$ 在输入读段的有效窗口中出现的原始次数。\n        - 如果没有提供回文目标，$B$ 为 $\\text{True}$ 当且仅当由算法生成的唯一规范 $k$-mer 集合中不包含任何互为反向互补序列的不同键对。\n- **测试套件**：\n    1. 读段：`[\"ACGTACGT\"]`，$k=4$，回文目标：`\"ACGT\"`。\n    2. 读段：`[\"A\",\"ACG\"]`，$k=4$，无回文目标。\n    3. 读段：`[\"ANNNT\",\"NTGC\"]`，$k=3$，无回文目标。\n    4. 读段：`[\"ATTA\",\"TAAT\"]`，$k=2$，回文目标：`\"AT\"`。\n\n### 步骤 2：使用提取的已知信息进行验证\n根据验证标准对问题进行评估：\n- **科学依据**：该问题在根本上是合理的。$k$-mer、反向互补、规范化和计数的概念是现代生物信息学的基石，尤其是在基因组组装和高通量测序数据的序列分析中。碱基配对规则和字典序是标准的，并且陈述正确。\n- **定义明确**：该问题是定义明确的。所有术语（$k$-mer、反向互补、规范 $k$-mer）都得到了精确定义。输入和预期输出（$U、T、M、B$）被明确指定。计算 $B$ 的逻辑被划分为两个清晰、不重叠的情况。问题结构保证了每个测试用例都存在唯一且有意义的解。\n- **客观性**：问题陈述是客观的，不含主观或推测性内容。它使用形式化定义和数学关系进行构建。\n- **缺陷清单**：\n    1.  **科学/事实不准确**：无。所描述的原理是正确的。\n    2.  **不可形式化/不相关**：无。该问题是生物信息学中一个直接且可形式化的任务。\n    3.  **不完整/矛盾的设置**：无。提供了所有必要信息，包括字母表、无效字符的规则和精确定义。约束条件是一致的。\n    4.  **不切实际/不可行**：无。测试用例是小规模但真实的序列数据表示，并且在计算上是可行的。\n    5.  **不适定/结构不良**：无。定义和目标清晰，能够导向唯一的解。\n    6.  **伪深刻/琐碎**：无。该问题需要对几个算法步骤（提取、验证、转换、聚合和验证）进行精心编排，代表了一项实质性的实现任务。\n    7.  **超出科学可验证性**：无。结果是确定性的，可以通过执行所描述的算法来验证。\n\n### 步骤 3：结论与行动\n该问题是有效的。它具有科学依据、定义明确、客观且自洽。将逐步开发和实现一个解决方案。\n\n### 解决方案设计\n\n该问题要求一个算法来处理一组 DNA 读段，以对规范 $k$-mer 进行计数并验证计数的完整性。解决方案结构如下：\n\n1.  **初始化**：对于每个测试用例，我们初始化一个字典 `canonical_counts`，用于存储每个规范 $k$-mer 的频率。我们还定义了有效的 DNA 碱基集合 $\\{'A', 'C', 'G', 'T' \\}$ 以及用于碱基配对的互补映射。\n\n2.  **K-mer 提取与验证**：算法遍历每个提供的读段。读段首先被转换为大写以确保不区分大小写。一个长度为 $k$ 的滑动窗口在每个读段上移动。对于每个窗口（一个潜在的 $k$-mer），我们必须首先验证它只包含来自有效 DNA 字母表的字符。任何包含无效字符（例如 'N'）的窗口都将被丢弃。\n\n3.  **规范化**：对于每个有效的 $k$-mer，$s$，我们必须确定其规范表示。这涉及两个子步骤：a. **反向互补**：实现一个函数 $rc(s)$。它反转字符串 $s$ 并将每个碱基替换为其互补碱基（$A \\leftrightarrow T$, $C \\leftrightarrow G$）。b. **字典序比较**：规范形式 $c(s)$ 由 $k$-mer 与其反向互补序列的字典序最小值确定：$c(s) = \\min(s, rc(s))$。指定的顺序是 $A  C  G  T$。\n\n4.  **计数**：计算出的规范 $k$-mer，$c(s)$，被用作 `canonical_counts` 字典中的键。其对应的值（计数）被递增。这个过程确保了一个 $k$-mer 及其反向互补序列被聚合在单个规范键下，从而防止了对底层生物片段的重复计数。\n\n5.  **输出计算**：处理完一个测试用例的所有读段后，从 `canonical_counts` 字典中计算所需的指标：\n    -   $U$：唯一规范 $k$-mer 的数量就是字典中键的数量，即 `len(canonical_counts)`。\n    -   $T$：规范 $k$-mer 出现的总次数是字典中所有值的总和，即 `sum(canonical_counts.values())`。\n    -   $M$：最大频率是字典中的最大值。如果字典为空（未找到有效的 $k$-mer），则 $M$ 为 $0$。\n    -   $B$：布尔验证指标根据是否存在回文目标 $p$ 来计算。\n        -   **有目标 $p$ 的情况**：必须验证 $p$ 本身是回文的（$p = rc(p)$）。指定的逻辑规定，如果 $p$ 的规范计数值等于观测到的与 $p$ 匹配的窗口的原始计数值，则 $B$ 为 $\\text{True}$。设规范计数值为 $N_c(p)$，原始计数值为 $N_{raw}(p)$。我们检查是否 $N_c(p) = N_{raw}(p)$。对于一个回文 $p$，其规范形式是 $p$ 本身，即 $c(p) = p$。唯一映射到 $p$ 的 k-mer 是 $p$ 自身的出现。因此，此检查验证了计数逻辑没有错误地夸大回文序列的计数。我们必须在窗口化过程中收集 $p$ 的原始出现次数来执行此检查。\n        -   **无目标的情况**：检查 `canonical_counts` 字典中是否有任何两个不同的键互为反向互补。规范化函数 $c(s) = \\min(s, rc(s))$ 的正确实现使得这种情况不可能发生。如果 $k_1$ 是一个规范键，那么根据定义 $k_1 \\le rc(k_1)$。如果它的反向互补序列 $rc(k_1)$ 也是一个不同的规范键，那将意味着 $rc(k_1) \\le rc(rc(k_1)) = k_1$。这两个条件 $k_1 \\le rc(k_1)$ 和 $rc(k_1) \\le k_1$ 只有在 $k_1 = rc(k_1)$ 时才能同时成立。这意味着键不是不同的，这是一个矛盾。因此，此检查可作为对规范化算法本身内部一致性的形式验证。一个肯定的结果（$B=\\text{True}$）证实了算法的正确实现。\n\n这种结构化的方法确保了所有问题需求都以科学和逻辑的严谨性得到满足。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\"reads\": [\"ACGTACGT\"], \"k\": 4, \"palindromic_target\": \"ACGT\"},\n        {\"reads\": [\"A\", \"ACG\"], \"k\": 4, \"palindromic_target\": None},\n        {\"reads\": [\"ANNNT\", \"NTGC\"], \"k\": 3, \"palindromic_target\": None},\n        {\"reads\": [\"ATTA\", \"TAAT\"], \"k\": 2, \"palindromic_target\": \"AT\"},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(case[\"reads\"], case[\"k\"], case[\"palindromic_target\"])\n        all_results.append(result)\n\n    # Format the final output string to remove spaces for a compact representation\n    # e.g., '[3,5,2,True]' instead of '[3, 5, 2, True]'\n    formatted_strings = [str(res).replace(\" \", \"\") for res in all_results]\n    print(f\"[{','.join(formatted_strings)}]\")\n\ndef process_case(reads, k, palindromic_target):\n    \"\"\"\n    Processes a single test case according to the problem specification.\n    \"\"\"\n    complement_map = str.maketrans('ACGT', 'TGCA')\n    valid_bases = {'A', 'C', 'G', 'T'}\n\n    def reverse_complement(s):\n        return s.translate(complement_map)[::-1]\n\n    canonical_counts = {}\n    raw_target_count = 0\n\n    for read in reads:\n        read_upper = read.upper()\n        if len(read_upper)  k:\n            continue\n        for i in range(len(read_upper) - k + 1):\n            kmer = read_upper[i:i+k]\n            \n            # Skip any k-mer containing invalid characters\n            if not set(kmer).issubset(valid_bases):\n                continue\n\n            # For verification metric B with a target\n            if palindromic_target and kmer == palindromic_target:\n                raw_target_count += 1\n            \n            # Canonicalization\n            rc_kmer = reverse_complement(kmer)\n            canonical_kmer = min(kmer, rc_kmer)\n            \n            # Counting\n            canonical_counts[canonical_kmer] = canonical_counts.get(canonical_kmer, 0) + 1\n\n    # Calculate U, T, M\n    if not canonical_counts:\n        U, T, M = 0, 0, 0\n    else:\n        U = len(canonical_counts)\n        T = sum(canonical_counts.values())\n        M = max(canonical_counts.values())\n\n    # Calculate B\n    B = True\n    if palindromic_target:\n        # Check if the target is indeed palindromic.\n        is_palindrome = (palindromic_target == reverse_complement(palindromic_target))\n        if not is_palindrome:\n            # This case shouldn't happen with the given test data,\n            # but is a robust check. The canonical form would be different.\n            # The logic stands for any target p. We need its canonical form.\n            canonical_target = min(palindromic_target, reverse_complement(palindromic_target))\n            canonical_count_p = canonical_counts.get(canonical_target, 0)\n        else:\n             # For a palindrome, its canonical form is itself.\n            canonical_count_p = canonical_counts.get(palindromic_target, 0)\n        \n        B = (canonical_count_p == raw_target_count)\n\n    else:\n        # Verify that no two distinct canonical keys are reverse complements.\n        # This confirms the correctness of the canonicalization logic.\n        keys = list(canonical_counts.keys())\n        key_set = set(keys)\n        for key in keys:\n            rc_key = reverse_complement(key)\n            if key != rc_key and rc_key in key_set:\n                B = False\n                break\n    \n    return [U, T, M, B]\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "真实的测序数据并非完美无瑕，常含有低质量碱基和不确定的核苷酸（以 'N' 表示）。此练习将理论知识应用于实际挑战，要求你根据碱基质量（Phred分数）和序列内容，设计并实施一套严格的规则来过滤或转换不可靠的$k$-mer窗口。掌握这一技能对于确保下游分析（如变异检测或宏基因组学分析）的准确性至关重要。",
            "id": "4576335",
            "problem": "给定一个针对单条测序读长（read）的滑动窗口 $k$-mer 验证的形式化描述，该读长遵循FASTQ记录的结构。该记录由一个核苷酸序列字符串和在Phred标度下对应的整数值质量分数向量组成。一个Phred质量分数 $Q$ 通过广泛接受的关系 $p_{\\mathrm{err}} = 10^{-Q/10}$ 与错误碱基检出（base call）的概率 $p_{\\mathrm{err}}$ 相关联。在测序数据中，字符 $N$ 表示一个不确定的核苷酸。任务是形式化并实现一套有原则的规则集，该规则集用于排除或转换不确定的位置以形成有效的 $k$-mer，然后量化在该规则集下被丢弃窗口的比例。\n\n从核心定义开始：\n- $k$-mer 是从读长序列中取出的长度为 $k$ 的连续子串。\n- 定义一个滑动窗口索引 $i$，其范围从 $0$ 到 $L-k$，其中 $L$ 是读长长度。索引为 $i$ 的窗口跨越位置 $i, i+1, \\ldots, i+k-1$。\n- 设读长序列为 $S = (S_0, S_1, \\ldots, S_{L-1})$，其中 $S_i \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}, \\mathrm{N}\\}$，对应的Phred质量分数为 $Q = (Q_0, Q_1, \\ldots, Q_{L-1})$，其中 $Q_i \\in \\mathbb{Z}$。\n- 设 $\\pi = (\\pi_{\\mathrm{A}}, \\pi_{\\mathrm{C}}, \\pi_{\\mathrm{G}}, \\pi_{\\mathrm{T}})$ 是一个在 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 上的碱基组成先验，满足 $\\sum_b \\pi_b = 1$ 且对于每个碱基 $b$，$\\pi_b \\ge 0$。\n- 设 $\\rho$ 是一个填补确定性阈值，满足 $0 \\le \\rho \\le 1$。\n- 设 $Q_{\\min}$ 是可接受的单个位置最低Phred质量分数，设 $\\tau$ 是每个窗口预期错误数的上限。\n\n窗口有效性规则集：\n1. 不确定性解决：对于每个 $S_i = \\mathrm{N}$ 的位置 $i$，如果 $\\max_{b \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}} \\pi_b \\ge \\rho$，则确定性地填补 $S_i \\leftarrow b^\\*$，其中 $b^\\* = \\arg\\max_b \\pi_b$。否则，保持 $S_i = \\mathrm{N}$（未解决）。\n2. 质量过滤：如果 $\\min_{j \\in [i,i+k-1]} Q_j  Q_{\\min}$，则窗口 $(i,\\ldots,i+k-1)$ 立即无效。\n3. 填补后不确定性过滤：如果在不确定性解决步骤之后，窗口 $(i,\\ldots,i+k-1)$ 内仍有任何 $S_j = \\mathrm{N}$，则该窗口无效。\n4. 预期错误边界：对于一个窗口 $(i,\\ldots,i+k-1)$，使用Phred关系计算 $E_i = \\sum_{j=i}^{i+k-1} 10^{-Q_j/10}$。如果 $E_i > \\tau$，则该窗口无效。\n5. 一个窗口当且仅当通过上述所有过滤器时才有效。\n\n将被丢弃窗口的比例定义为分数 $\\frac{D}{W}$，其中 $W = L-k+1$ 是窗口总数，$D$ 是根据该规则集判定的无效窗口数。\n\n实现一个程序，该程序：\n- 对每个指定的测试用例应用上述规则集。\n- 为每个测试用例计算并报告比例 $\\frac{D}{W}$，结果为浮点数，四舍五入到六位小数。\n\n测试套件：\n- 测试用例 $1$（包含未解决不确定性和低质量碱基的正常路径）：\n  - $k = 7$，$Q_{\\min} = 20$，$\\tau = 0.7$，$\\rho = 0.3$，$\\pi = (0.25, 0.25, 0.25, 0.25)$。\n  - 长度为 $L = 30$ 的序列 $S$：$S = \\mathrm{ACNTACGTACNTACGNNCGTACGTANGTAA}$。\n  - 质量分数 $Q_i$：除了 $Q_5 = 15$，$Q_6 = 15$，$Q_{21} = 10$ 外，所有 $i$ 的 $Q_i = 30$。\n  - 该读长恰好包含 $5$ 个不确定位置 $\\mathrm{N}$。\n- 测试用例 $2$（启用填补，高置信度先验，全部高质量）：\n  - $k = 7$，$Q_{\\min} = 25$，$\\tau = 0.1$，$\\rho = 0.45$，$\\pi = (0.5, 0.2, 0.2, 0.1)$。\n  - 长度为 $L = 30$ 的序列 $S$：$S = \\mathrm{NGCATGCATNCANGCATGCANGCATGCATN}$。\n  - 质量分数 $Q_i$：所有 $i$ 的 $Q_i = 35$。\n  - 该读长恰好包含 $5$ 个不确定位置 $\\mathrm{N}$。\n- 测试用例 $3$（边界条件 $k=1$）：\n  - $k = 1$，$Q_{\\min} = 20$，$\\tau = 0.6$，$\\rho = 0.26$，$\\pi = (0.25, 0.25, 0.25, 0.25)$。\n  - 长度为 $L = 10$ 的序列 $S$：$S = \\mathrm{NNNNNAAAAA}$。\n  - 质量分数 $Q_i$：所有 $i$ 的 $Q_i = 40$。\n  - 该读长恰好包含 $5$ 个不确定位置 $\\mathrm{N}$。\n- 测试用例 $4$（大窗口，启用填补，但预期错误边界和质量阈值导致丢弃）：\n  - $k = 10$，$Q_{\\min} = 10$，$\\tau = 0.2$，$\\rho = 0.5$，$\\pi = (0.6, 0.2, 0.1, 0.1)$。\n  - 长度为 $L = 12$ 的序列 $S$：$S = \\mathrm{ANNTANGTNCGN}$。\n  - 质量分数 $Q_i$：在索引 $1, 2, 5, 8, 11$ 处 $Q_i = 5$，所有其他索引处 $Q_i = 30$。\n  - 该读长恰好包含 $5$ 个不确定位置 $\\mathrm{N}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个浮点数四舍五入到六位小数。例如，输出应类似于 $[\\mathrm{r}_1,\\mathrm{r}_2,\\mathrm{r}_3,\\mathrm{r}_4]$，其中每个 $\\mathrm{r}_i$ 是对应测试用例的被丢弃窗口比例，以十进制数表示。",
            "solution": "该问题要求验证从一条测序读长中提取的滑动窗口 $k$-mer，该读长由一个核苷酸序列 $S$ 和一个对应的Phred质量分数向量 $Q$ 定义。每个窗口的有效性由一套精确的、多阶段的规则集确定。我们的目标是实现这套规则集，并为几个测试用例计算被丢弃窗口的比例。\n\n解决方案的核心在于系统地、逐个窗口地应用指定的过滤器。对于一个给定的长度为 $L$ 的读长和一个长度为 $k$ 的 $k$-mer，存在 $W = L-k+1$ 个可能的滑动窗口。我们必须根据规则集评估这些窗口中的每一个。这个过程可以分解为两个主要阶段：对整个序列的一次性预处理步骤，以及一个逐窗口的验证循环。\n\n**1. 预处理：不确定性解决**\n\n第一条规则处理不确定的碱基，用 '$\\mathrm{N}$' 表示。\n- 规则 $1$：对于序列中每个 $S_i = \\mathrm{N}$ 的位置 $i$，我们参考一个碱基组成先验 $\\pi = (\\pi_{\\mathrm{A}}, \\pi_{\\mathrm{C}}, \\pi_{\\mathrm{G}}, \\pi_{\\mathrm{T}})$ 和一个填补确定性阈值 $\\rho$。如果最可能碱基的概率 $\\max_{b} \\pi_b$ 大于或等于阈值 $\\rho$，我们确定性地将不确定的碱基填补为这个最可能的碱基：$S_i \\leftarrow b^\\*$，其中 $b^\\* = \\arg\\max_b \\pi_b$。如果 $\\max_{b} \\pi_b  \\rho$，则该碱基保持未解决状态（$S_i = \\mathrm{N}$）。此步骤将原始序列 $S$ 转换为一个新序列，我们称之为 $S'$。\n\n**2. 逐窗口验证**\n\n预处理后，我们遍历每个窗口，其索引起始位置 $i$ 从 $0$ 到 $L-k$。一个窗口当且仅当满足以下所有条件时才被视为有效。如果任何条件不满足，该窗口即被标记为无效。\n\n- 规则 $3$（填补后不确定性过滤）：窗口内不得包含任何未解决的 '$\\mathrm{N}$' 字符。也就是说，对于窗口子序列 $S'_{i..i+k-1}$，每个字符都必须在 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 中。\n- 规则 $2$（质量过滤）：窗口内每个碱基的Phred质量分数必须达到一个最小阈值 $Q_{\\min}$。即 $\\min_{j=i}^{i+k-1} Q_j \\ge Q_{\\min}$。\n- 规则 $4$（预期错误边界）：窗口中所有碱基的错误概率之和不得超过指定的容差 $\\tau$。具有Phred分数 $Q_j$ 的碱基的错误概率 $p_{\\mathrm{err}}$ 由 $p_{\\mathrm{err},j} = 10^{-Q_j/10}$ 给出。条件是 $\\sum_{j=i}^{i+k-1} 10^{-Q_j/10} \\le \\tau$。\n\n如果一个起始索引为 $i$ 的窗口未能通过这三个过滤器中的一个或多个，则计为被丢弃。在评估完所有 $W$ 个窗口后，我们计算被丢弃窗口的总数 $D$。最终结果是比例 $\\frac{D}{W}$。\n\n现在我们将此过程应用于每个测试用例。\n\n**测试用例 1**\n- 参数：$k=7$，$Q_{\\min}=20$，$\\tau=0.7$，$\\rho=0.3$，$\\pi=(0.25, 0.25, 0.25, 0.25)$。\n- 序列：$S = \\mathrm{ACNTACGTACNTACGNNCGTACGTANGTAA}$ ($L=30$)。\n- 质量分数：除了 $Q_5 = 15$，$Q_6 = 15$，$Q_{21} = 10$ 外，所有 $i$ 的 $Q_i = 30$。\n- 总窗口数：$W = 30 - 7 + 1 = 24$。\n1.  不确定性解决：$\\max(\\pi) = 0.25$。由于 $0.25  \\rho=0.3$，不进行填补。序列 $S'$ 与 $S$ 相同。'$\\mathrm{N}$' 碱基保留在索引 $2, 10, 14, 15, 25$ 处。\n2.  窗口验证：\n    -   不确定性过滤（规则 3）：包含 '$\\mathrm{N}$' 的窗口无效。任何起始于 $i$ 且其区间 $[i, i+6]$ 与 $\\{2, 10, 14, 15, 25\\}$ 重叠的窗口都无效。这使得索引 $i \\in \\{0,1,2\\} \\cup \\{4,...,10\\} \\cup \\{8,...,14\\} \\cup \\{9,...,15\\} \\cup \\{19,...,23\\}$ 的窗口无效。这些集合的并集是 $\\{0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 19, 20, 21, 22, 23\\}$。\n    -   质量过滤（规则 2）：低质量碱基位于索引 $5, 6, 21$ 处。如果窗口的区间 $[i, i+6]$ 与这些索引重叠，则该窗口无效。这使得索引 $i \\in \\{0,...,5\\} \\cup \\{0,...,6\\} \\cup \\{15,...,21\\}$ 的窗口无效。其并集是 $\\{0, 1, 2, 3, 4, 5, 6\\} \\cup \\{15, 16, 17, 18, 19, 20, 21\\}$。\n    -   综合无效性：所有被丢弃窗口的集合是来自两个过滤器的集合的并集。该并集为 $\\{0, 1, ..., 23\\}$，覆盖了所有可能的窗口索引。\n-   结论：所有 $24$ 个窗口均无效。$D=24$。被丢弃窗口的比例为 $24/24 = 1.0$。\n\n**测试用例 2**\n- 参数：$k=7$，$Q_{\\min}=25$，$\\tau=0.1$，$\\rho=0.45$，$\\pi=(0.5, 0.2, 0.2, 0.1)$。\n- 序列：$S = \\mathrm{NGCATGCATNCANGCATGCANGCATGCATN}$ ($L=30$)。\n- 质量分数：所有 $i$ 的 $Q_i = 35$。\n- 总窗口数：$W = 30 - 7 + 1 = 24$。\n1.  不确定性解决：$\\max(\\pi) = 0.5$。由于 $0.5 \\ge \\rho=0.45$，执行填补。具有最高先验概率的碱基是 '$\\mathrm{A}$'。所有的 '$\\mathrm{N}$' 都被替换为 '$\\mathrm{A}$'。\n2.  窗口验证：\n    -   不确定性过滤（规则 3）：填补后，不再有 '$\\mathrm{N}$'。所有窗口都通过此过滤器。\n    -   质量过滤（规则 2）：所有质量分数均为 $35$，这 $\\ge Q_{\\min}=25$。所有窗口都通过此过滤器。\n    -   预期错误过滤（规则 4）：任何碱基的错误概率是 $10^{-35/10} = 10^{-3.5}$。每个窗口的预期错误是 $E_i = 7 \\times 10^{-3.5} \\approx 0.0022$。由于 $0.0022 \\le \\tau=0.1$，所有窗口都通过此过滤器。\n-   结论：所有 $24$ 个窗口均有效。$D=0$。被丢弃窗口的比例为 $0/24 = 0.0$。\n\n**测试用例 3**\n- 参数：$k=1$，$Q_{\\min}=20$，$\\tau=0.6$，$\\rho=0.26$，$\\pi=(0.25, 0.25, 0.25, 0.25)$。\n- 序列：$S = \\mathrm{NNNNNAAAAA}$ ($L=10$)。\n- 质量分数：所有 $i$ 的 $Q_i = 40$。\n- 总窗口数：$W = 10 - 1 + 1 = 10$。\n1.  不确定性解决：$\\max(\\pi) = 0.25$。由于 $0.25  \\rho=0.26$，不进行填补。\n2.  窗口验证：每个窗口是一个单一碱基。\n    -   不确定性过滤（规则 3）：索引为 $0, 1, 2, 3, 4$ 的窗口包含 '$\\mathrm{N}$'，因此无效。索引为 $5, 6, 7, 8, 9$ 的窗口在此规则下有效。\n    -   质量过滤（规则 2）：所有分数均为 $40 \\ge Q_{\\min}=20$。所有窗口通过。\n    -   预期错误过滤（规则 4）：对于每个窗口，预期错误为 $10^{-40/10} = 0.0001$。由于 $0.0001 \\le \\tau=0.6$，所有窗口通过。\n-   结论：前 $5$ 个窗口因不确定性而被丢弃。$D=5$。比例为 $5/10 = 0.5$。\n\n**测试用例 4**\n- 参数：$k=10$，$Q_{\\min}=10$，$\\tau=0.2$，$\\rho=0.5$，$\\pi=(0.6, 0.2, 0.1, 0.1)$。\n- 序列：$S = \\mathrm{ANNTANGTNCGN}$ ($L=12$)。\n- 质量分数：索引 $1, 2, 5, 8, 11$ 处 $Q_i=5$；其他位置 $Q_i = 30$。\n- 总窗口数：$W = 12 - 10 + 1 = 3$。窗口起始于 $i=0, 1, 2$。\n1.  不确定性解决：$\\max(\\pi)=0.6$。由于 $0.6 \\ge \\rho=0.5$，执行填补，将所有 '$\\mathrm{N}$' 替换为 '$\\mathrm{A}$'。\n2.  窗口验证：\n    -   不确定性过滤（规则 3）：填补后，不再有 '$\\mathrm{N}$'。所有窗口都通过此过滤器。\n    -   质量过滤（规则 2）：$Q_{\\min}=10$。\n        -   窗口 $0$（索引 $[0, 9]$）在索引 $1, 2, 5, 8$ 处包含 $Q=5$ 的碱基。由于 $5  10$，此窗口无效。\n        -   窗口 $1$（索引 $[1, 10]$）在索引 $1, 2, 5, 8$ 处包含 $Q=5$ 的碱基。由于 $5  10$，此窗口无效。\n        -   窗口 $2$（索引 $[2, 11]$）在索引 $2, 5, 8, 11$ 处包含 $Q=5$ 的碱基。由于 $5  10$，此窗口无效。\n-   结论：所有 $3$ 个窗口都因质量过滤器而无效。我们无需检查预期错误过滤器。$D=3$。比例为 $3/3 = 1.0$。\n\n最终比例：$[1.0, 0.0, 0.5, 1.0]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for k-mer window validation.\n    \"\"\"\n\n    def calculate_discard_proportion(k, Q_min, tau, rho, pi, S, Q):\n        \"\"\"\n        Calculates the proportion of discarded windows for a single test case.\n        \"\"\"\n        L = len(S)\n        if L  k:\n            return 1.0  # Or 0.0 if no windows exist, but problem implies L >= k\n\n        W = L - k + 1\n        S_list = list(S)\n        \n        # Rule 1: Ambiguity resolution\n        pi_max = np.max(pi)\n        if pi_max >= rho:\n            bases = ['A', 'C', 'G', 'T']\n            b_star_index = np.argmax(pi)\n            b_star = bases[b_star_index]\n            for i in range(L):\n                if S_list[i] == 'N':\n                    S_list[i] = b_star\n        \n        S_prime = \"\".join(S_list)\n\n        num_valid_windows = 0\n        p_err = 10**(-np.array(Q, dtype=float) / 10.0)\n\n        for i in range(W):\n            window_S = S_prime[i : i + k]\n            window_Q = Q[i : i + k]\n            window_p_err = p_err[i : i + k]\n            \n            # Rule 3: Post-imputation ambiguity filter\n            passes_ambiguity = 'N' not in window_S\n            \n            # Rule 2: Quality filter\n            passes_quality = np.min(window_Q) >= Q_min\n            \n            # Rule 4: Expected error bound\n            passes_error = np.sum(window_p_err) = tau\n\n            if passes_ambiguity and passes_quality and passes_error:\n                num_valid_windows += 1\n        \n        num_discarded = W - num_valid_windows\n        return num_discarded / W\n\n    # Test Case 1\n    Q1 = np.full(30, 30)\n    Q1[[5, 6, 21]] = [15, 15, 10]\n    case1 = {\n        \"k\": 7, \"Q_min\": 20, \"tau\": 0.7, \"rho\": 0.3, \"pi\": (0.25, 0.25, 0.25, 0.25),\n        \"S\": \"ACNTACGTACNTACGNNCGTACGTANGTAA\", \"Q\": Q1\n    }\n\n    # Test Case 2\n    Q2 = np.full(30, 35)\n    case2 = {\n        \"k\": 7, \"Q_min\": 25, \"tau\": 0.1, \"rho\": 0.45, \"pi\": (0.5, 0.2, 0.2, 0.1),\n        \"S\": \"NGCATGCATNCANGCATGCANGCATGCATN\", \"Q\": Q2\n    }\n\n    # Test Case 3\n    Q3 = np.full(10, 40)\n    case3 = {\n        \"k\": 1, \"Q_min\": 20, \"tau\": 0.6, \"rho\": 0.26, \"pi\": (0.25, 0.25, 0.25, 0.25),\n        \"S\": \"NNNNNAAAAA\", \"Q\": Q3\n    }\n    \n    # Test Case 4\n    Q4 = np.full(12, 30)\n    Q4[[1, 2, 5, 8, 11]] = 5\n    case4 = {\n        \"k\": 10, \"Q_min\": 10, \"tau\": 0.2, \"rho\": 0.5, \"pi\": (0.6, 0.2, 0.1, 0.1),\n        \"S\": \"ANNTANGTNCGN\", \"Q\": Q4\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    \n    results = []\n    for case in test_cases:\n        result = calculate_discard_proportion(**case)\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当处理包含数百万甚至数十亿$k$-mer的大型基因组数据集时，简单的线性搜索变得不切实际。为了实现高效的序列查询，必须构建专门的数据结构。此练习将引导你设计并实现一个基于哈希表的$k$-mer索引，这是一种核心的计算机科学技术，用于快速检索包含特定$k$-mer的基因组，是构建可扩展生物信息学工具的关键。",
            "id": "4576326",
            "problem": "给定一个有限的脱氧核糖核酸（DNA）基因组集合，每个基因组都表示为一个由字母表 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T}, \\text{N} \\}$ 构成的字符串，其中 $\\text{N}$ 表示一个不明确的核苷酸。一个 $k$-mer 是指在 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 上的任意长度为 $k$ 的连续子串。DNA 字符串的反向互补（RC）是通过反转字符串并将每个核苷酸替换为其互补核苷酸得到的，其中 $\\text{A}$ 与 $\\text{T}$ 互补，$\\text{C}$ 与 $\\text{G}$ 互补。您的任务是设计并实现一种查询算法和数据结构，对于给定的 $k$ 和一个查询 $k$-mer $q$（可能考虑反向互补等价性），返回包含至少一次 $q$（正向或反向互补方向）出现的所有基因组的标识符列表。查询时间必须是亚线性的，即低于 $n$，其中 $n$ 是所有基因组中的核苷酸总数。您必须从第一性原理出发，论证数据结构选择的合理性。\n\n请从基本定义和经过充分检验的观察结果开始，而不是从任何捷径公式入手，并使用以下基础：\n- $k$-mer 是一个在 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 上的长度为 $k$ 的连续子串。\n- 反向互补不变性捕捉了在任一 DNA 链上的匹配。\n- 哈希表（在均匀哈希假设下）提供期望常数时间的查找。\n- 双比特编码将 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 映射为整数，从而能够为 $k$-mer 提供紧凑的键。\n\n算法要求：\n- 预处理基因组以构建一个关于 $k$-mer 的索引，仅使用 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$（跳过任何包含 $\\text{N}$ 的窗口）。通过将每个观察到的 $k$-mer 规范化为其整数编码值及其反向互补的整数编码值中的较小者，将正向和反向互补的 $k$-mer 视为等价。\n- 对于给定的查询 $k$-mer $q$，返回包含 $q$（考虑反向互补等价性）的基因组标识符的排序列表。\n- 如果 $q$ 包含 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 之外的任何字符，或者其长度不等于 $k$，则返回空列表。\n\n您必须提供一个正确的程序，该程序构建索引并为一个固定的测试套件提供答案，无需读取输入、文件或使用网络访问。您的论证和设计应表明查询时间在 $n$ 上是亚线性的（例如，在均匀哈希下为期望常数时间），并明确地就计算 $q$ 的规范形式所需的时间以及实际包含 $q$ 的基因组数量所带来的影响进行推理。\n\n使用以下基因组（每个基因组被赋予一个等于其在列表中位置的标识符，从 $0$ 开始）：\n- $0$: $\\text{ACGTACGTACGT}$\n- $1$: $\\text{GTACGTAAGACT}$\n- $2$: $\\text{TTTTACGTGGGG}$\n- $3$: $\\text{CCCCGACTAAAA}$\n- $4$: $\\text{ACGNNNACGTAC}$\n- $5$: $\\text{TGCATGCAAGTC}$\n\n实现您的算法并为以下测试套件生成答案。每个测试用例是一个对 $(k, q)$:\n- 测试用例 1: $(k = 4, q = \\text{AGTC})$\n- 测试用例 2: $(k = 4, q = \\text{ACGT})$\n- 测试用例 3: $(k = 1, q = \\text{A})$\n- 测试用例 4: $(k = 6, q = \\text{ACGTAC})$\n- 测试用例 5: $(k = 5, q = \\text{AAAAA})$\n- 测试用例 6: $(k = 4, q = \\text{ACGN})$\n\n将每个测试用例的答案表示为一个整数列表（基因组标识符）。最终输出必须将所有测试用例的结果聚合成单行，形式为用方括号括起来的逗号分隔列表，其中每个元素是该测试用例的列表。例如，输出格式必须严格符合 $[\\,[\\ldots],\\,[\\ldots],\\ldots\\,]$ 的形式，且不含空格。\n\n此问题不涉及物理单位、角度单位或百分比。您的程序应该是自包含的，并产生包含聚合结果的单行输出。通过仅处理 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 上的精确匹配，并在构建索引时忽略包含 $\\text{N}$ 的窗口，来确保科学真实性。",
            "solution": "该问题要求设计并实现一种数据结构和算法，以高效地在一组基因组中查询给定 $k$-mer 或其反向互补序列的存在。主要约束是查询时间必须是亚线性的，即低于 $n$，其中 $n$ 是所有基因组中的核苷酸总数。\n\n我们的方法基于用预处理时间换取快速查询时间的原则。对一个查询 $k$-mer $q$ 进行朴素搜索将涉及扫描每个基因组，导致每次查询的时间复杂度为 $O(n)$，这是不可接受的。为了实现亚线性的查询性能，我们必须构建一个索引。\n\n**1. 核心策略：使用哈希表的倒排索引**\n\n对于此任务，最合适的数据结构是哈希表（在 Python 中是 `dict`），我们将用它来构建一个倒排索引。倒排索引将内容（在这里是 $k$-mer）映射到其位置（在这里是包含它的基因组的标识符）。\n\n哈希表的基本优势在于其查找、插入和删除的平均时间复杂度，在均匀哈希函数的合理假设下为 $O(1)$。通过将每个唯一的 $k$-mer 映射到基因组标识符列表，对一个 $k$-mer 的查询简化为单次哈希表查找。此操作的时间与基因组总大小 $n$ 无关，因此满足亚线性查询时间的要求。\n\n**2. 键表示：k-mer 的双比特编码**\n\n在哈希表中使用原始字符串作为键是可行的，但在内存和哈希计算及比较的计算成本方面效率低下。通过利用 DNA 字母表 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 规模小的特点，可以实现一种更紧凑、性能更高的表示方法。这 4 个字符可以唯一地映射到 2 位整数：\n$$\n\\text{A} \\rightarrow 00_2 (0) \\\\\n\\text{C} \\rightarrow 01_2 (1) \\\\\n\\text{G} \\rightarrow 10_2 (2) \\\\\n\\text{T} \\rightarrow 11_2 (3)\n$$\n一个 $k$-mer 是一个由 $k$ 个核苷酸组成的序列，因此可以表示为一个 $2k$ 位的整数。对于 $k \\le 32$ 的情况，这可以容纳在一个标准的 64 位整数类型中。例如，4-mer `ACGT` 被编码为 `A`、`C`、`G` 和 `T` 的 2 位编码的拼接，得到二进制的 `00011011`，即整数 $27$。这种整数表示可以作为我们哈希表的高效键。\n\n**3. 处理反向互补等价性：规范化表示**\n\n问题要求对 $k$-mer $q$ 的查询也应匹配其反向互补序列 $q^{RC}$。为了处理这一点，我们必须确保 $q$ 和 $q^{RC}$ 在我们的索引中映射到相同的条目。这通过为每个 $\\{q, q^{RC}\\}$ 对定义一个规范化表示来实现。问题明确了这种规范形式：任何 $k$-mer $s$ 的键是 $\\min(v(s), v(s^{RC}))$，其中 $v(s)$ 是 $s$ 的整数表示。\n\n为了从 $k$-mer 的整数表示 $v(s)$ 计算其反向互补序列的整数表示 $v(s^{RC})$，我们可以使用位运算。设 $s$ 是一个整数值为 $I$ 且 $2k$ 位表示为 $b_1b_2...b_k$ 的 $k$-mer，其中每个 $b_i$ 是一个 2 位块。\n核苷酸的互补对应其 2 位编码的按位取反（例如，$v(\\text{A})=00_2$，$v(\\text{T})=11_2$，且 $\\sim 00_2 = 11_2$）。\n反向互补字符串是互补碱基的颠倒序列。其整数表示 $I_{RC}$ 可以通过两步从 $I$ 计算得出：\n1.  对 $I$ 进行按位取反：$I_{comp} = \\sim I$。这将得到一个整数，其位表示为 $(\\sim b_1)(\\sim b_2)...(\\sim b_k)$。\n2.  颠倒 $I_{comp}$ 中 2 位块的顺序。这可以通过迭代地从 $I_{comp}$ 中剥离最低的 2 位块并将其前置到一个新整数来完成。\n\n这种位操作比基于字符串的翻转和互补要快得多。\n\n**4. 算法设计**\n\n该过程分为两个阶段：预处理和查询。\n\n**预处理阶段（索引构建）：**\n目标是填充一个哈希表 `index`，将规范化的 $k$-mer 整数键映射到基因组标识符的集合。\n1.  初始化一个空哈希表 `index`。\n2.  遍历每个基因组 $g$ 及其标识符 $gid \\in \\{0, 1, ..., G-1\\}$。\n3.  对于 $g$ 中每个长度为 $k$ 的子串 $s$：\n    a. 检查 $s$ 是否包含任何不明确的核苷酸 (`N`)。如果包含，则此窗口无效并跳过，根据问题陈述。\n    b. 如果 $s$ 有效，计算其 $2k$ 位整数表示 $v(s)$。\n    c. 计算其反向互补序列的整数表示 $v(s^{RC})$。\n    d. 确定规范键：$k_{canonical} = \\min(v(s), v(s^{RC}))$。\n    e. 将基因组标识符 $gid$ 添加到与 `index` 中 $k_{canonical}$ 关联的标识符集合中。使用 `set` 可以自动处理一个 $k$-mer 在同一基因组中多次出现的情况。\n\n为了优化步骤 3b，可以使用滚动计算。我们可以通过位移旧值以丢弃离开的核苷酸并与新核苷酸进行或运算，在 $O(1)$ 时间内从前一个 $k$-mer 计算出下一个 $k$-mer 的整数值，而不是从头重新编码每个 $k$-mer（一个 $O(k)$ 操作）。这将总预处理时间从 $O(nk)$ 减少到 $O(n)$。\n\n**查询阶段：**\n1.  给定一个查询 $k$-mer $q$ 和长度 $k$，首先验证查询。如果 `len(q)`不等于 $k$ 或者 $q$ 包含 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 之外的字符，则返回一个空列表。\n2.  计算 $q$ 的整数表示 $v(q)$。\n3.  计算其反向互补序列的整数表示 $v(q^{RC})$。\n4.  确定规范查询键：$k_{query} = \\min(v(q), v(q^{RC}))$。\n5.  在 `index` 中查找 $k_{query}$。\n6.  如果找到键，则检索关联的基因组标识符集合。将此集合转换为列表并按升序排序。\n7.  如果未找到键，则表示该 $k$-mer 不存在于任何基因组中，返回一个空列表。\n\n**5. 复杂度分析**\n\n*   **预处理时间**：使用滚动计算，遍历总长度为 $n$ 的所有基因组需要 $O(n)$ 时间。对于每个有效的 $k$-mer，计算规范键并更新哈希表平均需要 $O(1)$ 时间。因此，总预处理时间为 $O(n)$。\n*   **预处理空间**：索引为每个唯一的规范 $k$-mer 存储一个条目。此类 $k$-mer 的数量最多为 $n$。每个条目存储一个键和一组基因组 ID。总空间复杂度与不同规范 $k$-mer 的数量以及总出现次数成正比，即 $O(\\sum_{kmer} |docs(kmer)|)$。在最坏情况下，这是 $O(n)$。\n*   **查询时间**：\n    1.  验证和编码查询 $q$ 需要 $O(k)$ 时间。\n    2.  计算其规范键需要 $O(k)$。\n    3.  哈希表查找的期望时间是 $O(1)$。\n    4.  如果 $k$-mer 在 $m$ 个基因组中找到，将 ID 集合转换为排序列表需要 $O(m \\log m)$ 时间。\n    因此，总查询时间为 $O(k + m \\log m)$。由于 $k$ 是一个小常数，且 $m$（包含该 $k$-mer 的基因组数量）远小于 $n$，所以查询时间在 $n$ 上是亚线性的，完全满足问题的核心要求。",
            "answer": "```python\nimport numpy as np\n\nclass KmerIndex:\n    \"\"\"\n    A data structure to index k-mers from a set of genomes for fast querying.\n    It handles reverse-complement equivalence by canonicalizing k-mers.\n    \"\"\"\n    def __init__(self, genomes, k):\n        \"\"\"\n        Initializes and builds the k-mer index.\n\n        Args:\n            genomes (list of str): A list of DNA sequences.\n            k (int): The k-mer length.\n        \"\"\"\n        if not isinstance(k, int) or k = 0:\n            raise ValueError(\"k must be a positive integer.\")\n        \n        self.k = k\n        self.genomes = genomes\n        self.index = {}\n        self.encoding = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n        self.valid_chars = set(self.encoding.keys())\n\n        # Guard for k values that would exceed a 64-bit integer representation\n        if self.k > 32:\n            raise ValueError(\"k > 32 is not supported by this implementation.\")\n\n        # Bitmask to keep k-mer integers within 2*k bits\n        self.kmer_mask = (1  (2 * self.k)) - 1 if self.k > 0 else 0\n        \n        self._build_index()\n\n    def _to_int(self, kmer_str):\n        \"\"\"Converts a k-mer string to its integer representation.\"\"\"\n        val = 0\n        for char in kmer_str:\n            val = (val  2) | self.encoding[char]\n        return val\n\n    def _rc_int(self, kmer_int):\n        \"\"\"Computes the integer representation of a k-mer's reverse complement.\"\"\"\n        # 1. Bitwise complement the 2k-bit integer.\n        #    A(00)->T(11), C(01)->G(10), which is a bitwise NOT.\n        comp_int = ~kmer_int  self.kmer_mask\n        \n        # 2. Reverse the order of the 2-bit blocks.\n        rc = 0\n        for _ in range(self.k):\n            block = comp_int  3  # Get the lowest 2 bits\n            rc = (rc  2) | block\n            comp_int >>= 2\n        return rc\n\n    def _canonical_key(self, kmer_int):\n        \"\"\"Computes the canonical key for a k-mer (min of itself and its RC).\"\"\"\n        rc = self._rc_int(kmer_int)\n        return min(kmer_int, rc)\n\n    def _build_index(self):\n        \"\"\"\n        Scans all genomes and populates the index.\n        It skips any k-mer window containing 'N'.\n        \"\"\"\n        for gid, genome in enumerate(self.genomes):\n            if len(genome)  self.k:\n                continue\n            \n            # Using a simple sliding window. For very large genomes, a rolling\n            # hash update would be more performant (O(n) vs O(n*k)).\n            for i in range(len(genome) - self.k + 1):\n                kmer_str = genome[i : i + self.k]\n                \n                # Validate k-mer characters, skipping if 'N' is present.\n                if not all(c in self.valid_chars for c in kmer_str):\n                    continue\n                \n                # Process the valid k-mer\n                kmer_int = self._to_int(kmer_str)\n                key = self._canonical_key(kmer_int)\n                \n                if key not in self.index:\n                    self.index[key] = set()\n                self.index[key].add(gid)\n\n    def query(self, q_str):\n        \"\"\"\n        Queries the index for a given k-mer string.\n\n        Args:\n            q_str (str): The query k-mer.\n\n        Returns:\n            list: A sorted list of genome identifiers containing the k-mer\n                  or its reverse complement. Returns an empty list for invalid\n                  queries or if the k-mer is not found.\n        \"\"\"\n        # Validate query string\n        if len(q_str) != self.k or not set(q_str).issubset(self.valid_chars):\n            return []\n        \n        q_int = self._to_int(q_str)\n        key = self._canonical_key(q_int)\n        \n        if key in self.index:\n            return sorted(list(self.index[key]))\n        else:\n            return []\n\ndef solve():\n    \"\"\"\n    Main function to run the predefined test suite and print results.\n    \"\"\"\n    genomes = [\n        \"ACGTACGTACGT\",   # 0\n        \"GTACGTAAGACT\",   # 1\n        \"TTTTACGTGGGG\",   # 2\n        \"CCCCGACTAAAA\",   # 3\n        \"ACGNNNACGTAC\",   # 4\n        \"TGCATGCAAGTC\"    # 5\n    ]\n    test_cases = [\n        (4, \"AGTC\"),\n        (4, \"ACGT\"),\n        (1, \"A\"),\n        (6, \"ACGTAC\"),\n        (5, \"AAAAA\"),\n        (4, \"ACGN\")\n    ]\n\n    # Cache indices by k-value to avoid rebuilding for same-k queries\n    indices = {}\n    results = []\n    \n    for k, q in test_cases:\n        if k not in indices:\n            indices[k] = KmerIndex(genomes, k)\n        \n        index = indices[k]\n        result = index.query(q)\n        results.append(result)\n\n    # Format the final output string to be exactly [[...],[...],...]\n    # with no spaces, as per the strict output requirement.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}