{
    "hands_on_practices": [
        {
            "introduction": "在设计任何测序实验时，一个核心问题是：我们需要多少测序数据才能充分覆盖目标基因组？本练习将引导你从第一性原理出发，推导连接测序参数（读长 $L$、读段数 $N$ 和基因组大小 $G$）与平均测序深度 $\\lambda$ 之间关系的基础模型。通过这项练习 ()，你将掌握散弹法测序 (shotgun sequencing) 随机过程的核心数学模型，并理解为什么泊松分布是描述这一现象的有力工具，这对于测序实验设计和数据解释至关重要。",
            "id": "4590011",
            "problem": "在一个使用新一代测序（NGS）的全基因组测序（WGS）实验中，对一个有效可作图长度为 $G$（单位为碱基）的单倍体基因组进行测序，使用了 $N$ 条独立的单端读段（read），每条读段的固定长度为 $L$（单位为碱基）。假设存在以下生成模型：（i）读段的起始位置在所有允许的位置上独立且均匀分布；（ii）$L \\ll G$，因此边缘效应可以忽略不计，允许的起始位置数量可视为 $G$；（iii）读段无错误，并且总是能作图到其真实的基因组位点；（iv）在所有读段中，片段化和抽样是独立同分布的，并且不存在序列或上下文相关的偏好。\n\n将某个固定基因组位置的单碱基覆盖深度定义为一个随机变量，其值等于覆盖该碱基的读段数量。\n\na) 从上述定义出发，仅使用陈述的假设，推导单碱基覆盖深度的期望值关于 $N$、$L$ 和 $G$ 的解析表达式。\n\nb) 将固定位置的单碱基深度形式化为独立伯努利指示变量之和。使用极限论证，其中 $G \\to \\infty$，$L$ 固定，且 $N$ 的尺度可变以使平均单碱基深度保持为 $O(1)$，推导单碱基深度的分布近似，并论证其方差何时等于其均值。然后，在此近似下，推导基因组中未被覆盖（即深度为 $0$）的碱基所占比例的期望值的闭式表达式，该表达式是关于 $N$、$L$ 和 $G$ 的函数。\n\n请以单个闭式解析表达式的形式提供未覆盖比例期望值的最终答案，无需单位，也无需四舍五入。",
            "solution": "该问题经验证具有科学依据、问题明确、客观且自洽。这些假设构成了鸟枪法测序的 Lander-Waterman 模型的基础，这是生物信息学中的一个基本概念。所有必要的参数（$G$、$N$、$L$）和假设均已提供，足以推导出所要求的量。因此，该问题是有效的。\n\n**a部分) 单碱基覆盖深度的期望值**\n\n设一个固定的基因组位置由一个整数坐标表示。令 $D$ 为表示该固定位置单碱基覆盖深度的随机变量。深度 $D$ 是覆盖该位置的读段总数。\n\n实验包含 $N$ 条独立的读段。令 $X_i$ 为第 $i$ 条读段的指示随机变量，其中 $i \\in \\{1, 2, \\dots, N\\}$。我们定义，如果读段 $i$ 覆盖了固定的基因组位置，则 $X_i = 1$，否则 $X_i = 0$。总深度 $D$ 可以表示为这些指示变量的总和：\n$$D = \\sum_{i=1}^{N} X_i$$\n\n根据期望的线性性质，期望深度是个体指示变量期望值的总和：\n$$E[D] = E\\left[\\sum_{i=1}^{N} X_i\\right] = \\sum_{i=1}^{N} E[X_i]$$\n\n对于一个指示变量，其期望值等于它所指示事件的概率。因此，$E[X_i] = P(X_i = 1)$。问题陈述读段是独立同分布的（i.i.d.）。这意味着对于所有读段 $i$，概率 $P(X_i = 1)$ 都是相同的。我们用 $p$ 表示这个概率。\n$$E[D] = \\sum_{i=1}^{N} p = N p$$\n\n现在我们必须确定概率 $p$。一条长度为 $L$ 的读段要覆盖一个给定位置，其起始位置必须落在一个特定的窗口内。设固定的基因组位置为 $j$。一条起始于位置 $s$ 的读段将覆盖位置 $j$，如果 $s \\le j \\le s+L-1$，这等价于 $j-L+1 \\le s \\le j$。这定义了一个长度为 $L$ 的起始位置区间。\n\n问题陈述读段起始位置在所有 $G$ 个允许位置上均匀分布（假设边缘效应可忽略）。导致位置 $j$ 被覆盖的起始位置数量为 $L$。因此，单个随机放置的读段覆盖位置 $j$ 的概率 $p$ 是有利起始位置数量与总可能起始位置数量的比值：\n$$p = P(X_i = 1) = \\frac{\\text{有利起始位置数量}}{\\text{总起始位置数量}} = \\frac{L}{G}$$\n\n将 $p$ 的这个表达式代入期望深度的方程，我们得到单碱基覆盖深度期望值的表达式，通常用 $\\lambda$ 表示：\n$$\\lambda = E[D] = N \\left(\\frac{L}{G}\\right) = \\frac{NL}{G}$$\n\n**b部分) 分布近似与未覆盖比例**\n\n一个固定位置的深度 $D = \\sum_{i=1}^{N} X_i$ 是 $N$ 次独立同分布的伯努利试验的总和，其中每次试验的成功概率为 $p = L/G$。这在形式上意味着 $D$ 的精确分布是二项分布：\n$$D \\sim \\text{Binomial}(N, p) \\quad \\text{with} \\quad p = \\frac{L}{G}$$\n\n问题要求在特定的极限论证下进行分布近似：当 $G \\to \\infty$ 时，$L$ 固定，并且 $N$ 的尺度变化使得平均深度 $\\lambda = NL/G$ 保持为 $O(1)$ 的常数。在此极限下，试验次数 $N$ 必须趋于无穷大（$N \\to \\infty$），因为 $G \\to \\infty$ 且 $NL/G$ 是常数。同时，成功概率 $p = L/G$ 趋于零（$p \\to 0$）。\n\n这种情况——大量试验和极小的成功概率——是二项分布的泊松近似的经典条件。二项分布 $\\text{Binomial}(N, p)$ 收敛于参数为 $\\lambda = Np$ 的泊松分布。因此，单碱基深度 $D$ 的分布可以近似为均值为 $\\lambda = NL/G$ 的泊松分布：\n$$P(D=k) \\approx \\frac{\\lambda^k e^{-\\lambda}}{k!} \\quad \\text{其中} \\quad \\lambda = \\frac{NL}{G}$$\n\n我们被要求论证深度分布的方差何时等于其均值。\n精确二项分布的均值是 $E[D] = Np = NL/G$。\n精确二项分布的方差是 $\\text{Var}(D) = Np(1-p) = \\frac{NL}{G}\\left(1 - \\frac{L}{G}\\right)$。\n均值等于方差当且仅当 $Np = Np(1-p)$，这意味着 $1 = 1-p$，所以 $p=0$。对于任何有限的 $G$ 这都是不可能严格成立的。\n然而，对于泊松近似，均值为 $\\lambda$，方差也为 $\\lambda$。在我们考虑的极限（$G \\to \\infty$）下，我们有 $p = L/G \\to 0$。当 $p \\to 0$ 时，二项分布的方差 $Np(1-p)$ 趋近于其均值 $Np$。因此，在泊松极限中，方差等于均值，这证明了该近似的合理性。\n\n最后，我们需要推导基因组中未被覆盖（即深度 $D=0$）的碱基所占比例的期望值。令 $F_0$ 为该比例的随机变量。未被覆盖的碱基总数是每个位置 $j \\in \\{1, \\dots, G\\}$ 的指示变量 $I_j$ 的总和，其中如果位置 $j$ 的深度为 $0$，则 $I_j=1$，否则 $I_j=0$。\n期望比例为：\n$$E[F_0] = E\\left[\\frac{1}{G}\\sum_{j=1}^{G} I_j\\right] = \\frac{1}{G}\\sum_{j=1}^{G} E[I_j]$$\n指示变量的期望 $E[I_j]$ 是位置 $j$ 未被覆盖的概率，即 $P(D_j=0)$。由于均匀抽样假设和忽略边缘效应，这个概率对所有碱基 $j$ 都是相同的。我们将其表示为 $P(D=0)$。\n$$E[F_0] = \\frac{1}{G} \\sum_{j=1}^{G} P(D=0) = \\frac{1}{G} (G \\cdot P(D=0)) = P(D=0)$$\n因此，未覆盖碱基的期望比例就是任意单个碱基覆盖深度为零的概率。\n\n使用深度 $D$ 分布的泊松近似，我们可以计算这个概率。对于一个均值为 $\\lambda$ 的泊松分布随机变量，观察到 $k=0$ 的概率是：\n$$P(D=0) = \\frac{\\lambda^0 \\exp(-\\lambda)}{0!} = \\exp(-\\lambda)$$\n代入平均覆盖度 $\\lambda = NL/G$ 的表达式，我们得到基因组未被覆盖部分的期望比例：\n$$E[F_0] = \\exp\\left(-\\frac{NL}{G}\\right)$$\n这就是在所述假设和推导出的分布近似下，未覆盖比例期望值的闭式表达式。",
            "answer": "$$\\boxed{\\exp\\left(-\\frac{NL}{G}\\right)}$$"
        },
        {
            "introduction": "在评估测序数据的可靠性时，我们不仅关心覆盖范围的“量”，更关心每个碱基判读的“质”。此练习聚焦于 Phred 质量分数 ($Q$)，这是表示碱基检出错误概率的对数标尺。你将推导其定义公式，并应用它来模拟一个实际问题：在边合成边测序 (sequencing-by-synthesis) 技术中，由于信号衰减，测序质量会随着读长的增加而下降。完成这项练习 () 后，你将深刻理解 FASTQ 文件中质量分数的核心含义，以及它如何反映测序技术的物理限制。",
            "id": "5067209",
            "problem": "一个实验室对一份临床全外显子组样本进行新一代测序（NGS），采用合成法测序技术，单端读长长度为 $L=150$ 个循环。由于移相和累积信号衰减，碱基判读的错误概率随着循环指数 $i$ 的增加而增加，其关系遵循指数模型 $p_{i}=p_{0}\\exp(\\gamma(i-1))$，其中 $p_{0}=3.0\\times 10^{-3}$，$\\gamma=1.0\\times 10^{-2}$ 每循环。\n\n从碱基判读中使用的Phred质量分数的定义属性出发——即，质量分数是碱基判读错误概率的以10为底的对数编码，错误概率每降低十倍，质量分数增加10，并且当 $p=1$ 时 $Q=0$——请推导Phred质量分数 $Q$ 作为错误概率 $p$ 的函数的表达式。\n\n使用此表达式和所述的错误模型，推导在 $L$ 个循环中平均读长质量 $\\overline{Q}$ 的解析表达式，然后计算在给定 $p_{0}$、$\\gamma$ 和 $L$ 的情况下的数值。将最终数值答案四舍五入至四位有效数字。无需物理单位。",
            "solution": "首先将对问题陈述的科学合理性、清晰度和完整性进行验证。\n\n### 第1步：提取已知条件\n- 读长长度：$L=150$ 个循环。\n- 碱基判读错误概率模型：$p_{i}=p_{0}\\exp(\\gamma(i-1))$，对于循环指数 $i \\in \\{1, 2, ..., L\\}$。\n- 初始错误概率：$p_{0}=3.0\\times 10^{-3}$。\n- 错误率增长常数：$\\gamma=1.0\\times 10^{-2}$ 每循环。\n- Phred质量分数 $Q$ 的定义属性：\n    1. $Q$ 是错误概率 $p$ 的以10为底的对数编码。\n    2. 错误概率每降低十倍，质量分数增加10。\n    3. 当 $p=1$ 时，$Q=0$。\n\n### 第2步：使用提取的已知条件进行验证\n根据既定的验证标准对问题进行评估。\n\n- **科学依据：** 该问题牢固地植根于生物信息学和遗传学的原理，特别是关于新一代测序数据的质量控制。Phred质量分数是该领域的标准度量。错误概率作为测序循环函数的指数模型，是对合成法测序技术中信号衰减的一个公认且合理的近似。所有组成部分都符合科学实际。\n- **适定性：** 该问题提供了所有必需的参数（$L$、$p_0$、$\\gamma$）和一套完整的Phred分数公理化定义。它要求推导一个特定公式并进行后续的数值计算，这将导出一个唯一、稳定且有意义的解。\n- **客观性：** 语言技术性强且精确，没有任何主观或模糊的陈述。\n\n该问题没有表现出任何已定义的无效性缺陷。它是科学上合理的、可形式化的、完整的、一致的和适定的。\n\n### 第3步：结论与行动\n该问题被判定为 **有效**。将提供完整解答。\n\n### 解题推导\n\n解答过程包括三个主要部分：\n1.  推导Phred质量分数公式 $Q(p)$。\n2.  推导平均读长质量 $\\overline{Q}$ 的解析表达式。\n3.  $\\overline{Q}$ 的数值计算。\n\n**第1部分：推导Phred质量分数公式 $Q(p)$**\n\n问题陈述指出，$Q$ 是错误概率 $p$ 的以10为底的对数编码。这意味着其函数形式为：\n$$ Q(p) = a \\log_{10}(p) + b $$\n其中 $a$ 和 $b$ 是待定常数，需要根据给定属性确定。\n\n属性2指出，错误概率降低十倍，质量分数增加10。设 $p_1$ 为初始错误概率，$p_2 = p_1/10$ 为新的错误概率。相应的质量分数分别为 $Q_1$ 和 $Q_2 = Q_1 + 10$。\n$$ Q_1 = a \\log_{10}(p_1) + b $$\n$$ Q_2 = a \\log_{10}(p_2) + b = a \\log_{10}\\left(\\frac{p_1}{10}\\right) + b = a \\left(\\log_{10}(p_1) - \\log_{10}(10)\\right) + b = a (\\log_{10}(p_1) - 1) + b $$\n代入 $Q_2 = Q_1 + 10$：\n$$ a \\log_{10}(p_1) - a + b = (a \\log_{10}(p_1) + b) + 10 $$\n$$ -a = 10 \\implies a = -10 $$\n该公式变为：\n$$ Q(p) = -10 \\log_{10}(p) + b $$\n属性3指出，当 $p=1$ 时 $Q=0$。代入这些值：\n$$ 0 = -10 \\log_{10}(1) + b $$\n由于 $\\log_{10}(1) = 0$，我们得到 $b=0$。\n因此，Phred质量分数作为错误概率 $p$ 的函数的表达式为：\n$$ Q(p) = -10 \\log_{10}(p) $$\n\n**第2部分：推导平均读长质量 $\\overline{Q}$**\n\n特定循环 $i$ 的质量分数（记为 $Q_i$）可以通过将推导出的公式应用于错误概率 $p_i$ 来得到：\n$$ Q_i = Q(p_i) = -10 \\log_{10}(p_i) $$\n代入给定的错误模型 $p_i = p_0 \\exp(\\gamma(i-1))$：\n$$ Q_i = -10 \\log_{10}\\left( p_0 \\exp(\\gamma(i-1)) \\right) $$\n使用对数性质 $\\log(xy) = \\log(x) + \\log(y)$：\n$$ Q_i = -10 \\left( \\log_{10}(p_0) + \\log_{10}(\\exp(\\gamma(i-1))) \\right) $$\n为了处理指数项，我们使用对数换底公式 $\\log_{b}(x) = \\frac{\\ln(x)}{\\ln(b)}$：\n$$ \\log_{10}(\\exp(\\gamma(i-1))) = \\frac{\\ln(\\exp(\\gamma(i-1)))}{\\ln(10)} = \\frac{\\gamma(i-1)}{\\ln(10)} $$\n将此结果代回 $Q_i$ 的表达式中：\n$$ Q_i = -10 \\left( \\log_{10}(p_0) + \\frac{\\gamma(i-1)}{\\ln(10)} \\right) $$\n平均读长质量 $\\overline{Q}$ 是 $L$ 个循环中质量分数的算术平均值：\n$$ \\overline{Q} = \\frac{1}{L} \\sum_{i=1}^{L} Q_i = \\frac{1}{L} \\sum_{i=1}^{L} \\left[ -10 \\left( \\log_{10}(p_0) + \\frac{\\gamma(i-1)}{\\ln(10)} \\right) \\right] $$\n我们可以将常数项从求和中提取出来：\n$$ \\overline{Q} = -\\frac{10}{L} \\left[ \\sum_{i=1}^{L} \\log_{10}(p_0) + \\sum_{i=1}^{L} \\frac{\\gamma(i-1)}{\\ln(10)} \\right] $$\n第一个求和是关于一个常数项的：\n$$ \\sum_{i=1}^{L} \\log_{10}(p_0) = L \\log_{10}(p_0) $$\n第二个求和涉及一个等差数列。令 $j=i-1$。该和为 $\\sum_{j=0}^{L-1} j = \\frac{(L-1)(L-1+1)}{2} = \\frac{L(L-1)}{2}$。\n$$ \\sum_{i=1}^{L} \\frac{\\gamma(i-1)}{\\ln(10)} = \\frac{\\gamma}{\\ln(10)} \\sum_{i=1}^{L} (i-1) = \\frac{\\gamma}{\\ln(10)} \\frac{L(L-1)}{2} $$\n将这些结果代回 $\\overline{Q}$ 的表达式中：\n$$ \\overline{Q} = -\\frac{10}{L} \\left[ L \\log_{10}(p_0) + \\frac{\\gamma L(L-1)}{2 \\ln(10)} \\right] $$\n将因子 $-\\frac{10}{L}$ 分配进去，可将表达式简化为最终的解析形式：\n$$ \\overline{Q} = -10 \\log_{10}(p_0) - \\frac{5 \\gamma (L-1)}{\\ln(10)} $$\n\n**第3部分：$\\overline{Q}$ 的数值计算**\n\n给定数值：$p_{0}=3.0\\times 10^{-3}$，$\\gamma=1.0\\times 10^{-2}$，以及 $L=150$。\n我们分别计算 $\\overline{Q}$ 表达式中的两项。\n\n第一项：\n$$ -10 \\log_{10}(p_0) = -10 \\log_{10}(3.0 \\times 10^{-3}) = -10 (\\log_{10}(3.0) + \\log_{10}(10^{-3})) = -10 (\\log_{10}(3.0) - 3) $$\n使用 $\\log_{10}(3.0) \\approx 0.477121$：\n$$ -10 \\log_{10}(p_0) \\approx -10(0.477121 - 3) = -10(-2.522879) = 25.22879 $$\n\n第二项：\n$$ \\frac{5 \\gamma (L-1)}{\\ln(10)} = \\frac{5 \\times (1.0 \\times 10^{-2}) \\times (150-1)}{\\ln(10)} = \\frac{5 \\times 0.01 \\times 149}{\\ln(10)} = \\frac{7.45}{\\ln(10)} $$\n使用 $\\ln(10) \\approx 2.302585$：\n$$ \\frac{7.45}{\\ln(10)} \\approx \\frac{7.45}{2.302585} \\approx 3.23549 $$\n\n最后，我们计算 $\\overline{Q}$：\n$$ \\overline{Q} \\approx 25.22879 - 3.23549 = 21.9933 $$\n按要求四舍五入到四位有效数字，我们得到 $21.99$。",
            "answer": "$$\\boxed{21.99}$$"
        },
        {
            "introduction": "原始测序数据中充满了各种技术噪音，其中 PCR 扩增引入的重复读段 (PCR duplicates) 是一个主要来源，它会严重影响定量分析的准确性。本练习是一个高级计算挑战，要求你设计一个去重算法，利用唯一分子标识符 (UMI) 来区分真正的生物学重复和 PCR 假象。这个实践 () 完美地连接了理论（错误模型）与应用（生物信息学算法设计），让你掌握处理定量测序数据时一项关键的、先进的数据清洗技术。",
            "id": "4589934",
            "problem": "给定一个关于新一代测序读段（read）去重任务的形式化表述，该任务以离散数学对象表示。每个读段由一个元组 $(r_i) = (c_i, x_i, o_i, u_i)$ 表示，其中 $c_i$ 是染色体标识符（一个字符串），$x_i$ 是以碱基对为单位的基因组 $5'$ 端坐标（一个整数），$o_i \\in \\{+,-\\}$ 是链方向，而 $u_i$ 是一个唯一分子标识符（UMI），它是一个由字母表 $\\{A,C,G,T\\}$ 构成的定长字符串。读段来源于原始分子，而聚合酶链式反应（PCR）重复是同一原始分子的复制品，它们保留了比对位置和方向，并且在不考虑错误的情况下共享相同的UMI。生物学重复（不同的原始分子）可能由于UMI空间的碰撞而偶然共享或几乎共享UMI，但它们的比对位置不同，或者，如果位置重合，则集体证据表明它们与单一错误过程不符。\n\n假设UMI的错误模型为碱基水平的替换错误模型：UMI的每个位置以概率 $p$ 独立发生替换，其中 $L$ 是UMI的长度。如果一个读段具有相同的染色体 $c$、相同的 $5'$ 端坐标 $x$ 和相同的链方向 $o$，则它属于一个去重组。在每个组内，您必须通过将观察到的UMI字符串聚类成代表单个扩增前分子的等价类来推断原始分子的数量，并且只合并那些可以合理解释为源自丰度更高的UMI的测序错误的UMI，其约束条件为所涉及的UMI之间的最大汉明距离不超过 $d_{\\max}$。决策规则的推导必须基于错误模型，并且不得采用任何特设公式。核心要求是构建一个算法，该算法从第一性原理出发，决定当一个丰度较低的UMI与一个丰度较高的UMI的汉明距离 $\\le d_{\\max}$ 且它们的计数满足由 $p$ 和 $L$ 暗示的阈值时，是否应将前者合并到后者中。您的算法必须：\n- 按 $(c, x, o)$ 划分读段。\n- 在每个分区内，将精确的UMI视为具有计数 $c(u)$ 的观测类别。\n- 仅使用错误模型、比对位置和方向来决定有向合并，同时遵守合并必须从高计数走向低计数，并且必须由错误衍生的UMI的预期丰度来证明其合理性。\n- 返回所有合理合并后独特分子的数量，表示为一个整数。\n\n不涉及角度单位，也不必报告任何物理单位。所有数值答案必须是整数。您的程序必须实现该算法，并为以下测试套件生成结果，其中每个测试用例是一个由一个或多个组组成的数据集。对于每个组，字段为 $(c, x, o, L, p, d_{\\max}, \\text{UMI-计数对})$。UMI-计数对以 $(u, n)$ 的形式给出，表示UMI字符串 $u$ 在该组中以观测计数 $n$ 出现。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$\\left[\\text{result}_1,\\text{result}_2\\right]$）。要求的最终输出格式就是这一行。\n\n测试套件：\n- 测试用例 $1$（理想路径，边界相等）：一个组\n  - $(\\text{chr1}, x = 1000, o = +, L = 8, p = 0.01, d_{\\max} = 1,$ UMI-计数 $=\\{(\\text{ACGTACGT}, 50), (\\text{ACGTACGA}, 4), (\\text{ACGTACGG}, 2)\\})$。\n- 测试用例 $2$（同一位置的两个强生物学重复）：一个组\n  - $(\\text{chr1}, x = 2000, o = +, L = 8, p = 0.01, d_{\\max} = 1,$ UMI-计数 $=\\{(\\text{TTTTTTTT}, 30), (\\text{TTTTTTTA}, 28)\\})$。\n- 测试用例 $3$（同一坐标下的方向分离）：两个组\n  - 组 $A$：$(\\text{chr2}, x = 3000, o = +, L = 8, p = 0.01, d_{\\max} = 1,$ UMI-计数 $=\\{(\\text{GATTACAA}, 15), (\\text{GATTACAG}, 1)\\})$。\n  - 组 $B$：$(\\text{chr2}, x = 3000, o = -, L = 8, p = 0.01, d_{\\max} = 1,$ UMI-计数 $=\\{(\\text{GATTACAA}, 6), (\\text{GATTACAT}, 5)\\})$。\n  此测试用例的结果必须是两个组去重后分子计数的总和。\n- 测试用例 $4$（边缘情况 $d_{\\max} = 0$ 不允许任何错配合并）：一个组\n  - $(\\text{chr3}, x = 4000, o = +, L = 8, p = 0.01, d_{\\max} = 0,$ UMI-计数 $=\\{(\\text{CCCCCCCC}, 12), (\\text{CCCCCCCA}, 1)\\})$。\n- 测试用例 $5$（跨位置的UMI碰撞）：两个组\n  - 组 $A$：$(\\text{chrX}, x = 5000, o = +, L = 8, p = 0.01, d_{\\max} = 1,$ UMI-计数 $=\\{(\\text{AAAAAAAT}, 8)\\})$。\n  - 组 $B$：$(\\text{chrX}, x = 5001, o = +, L = 8, p = 0.01, d_{\\max} = 1,$ UMI-计数 $=\\{(\\text{AAAAAAAT}, 7)\\})$。\n  此测试用例的结果必须是两个组去重后分子计数的总和。\n\n您的程序必须：\n- 根据给定的错误模型和约束条件，从第一性原理推导并实现去重逻辑。\n- 对于每个测试用例，以整数形式输出去重后独特分子的数量。\n- 生成一行包含五个整数的列表，按测试用例1到5的顺序排列，用方括号括起，不含多余空格或文本。",
            "solution": "用户提供了一个关于使用唯一分子标识符（UMI）对新一代测序读段进行去重的问题。任务是设计一种从第一性原理出发的算法，通过对可能由测序错误关联的UMI进行聚类，来确定原始分子的数量。\n\n### 步骤 1：提取已知条件\n- 一个读段由元组 $(r_i) = (c_i, x_i, o_i, u_i)$ 表示，其中 $c_i$ 是染色体，$x_i$ 是 $5'$ 端坐标，$o_i \\in \\{+,-\\}$ 是链，而 $u_i$ 是一个由 $\\{A,C,G,T\\}$ 构成的长度为 $L$ 的UMI字符串。\n- 读段根据共享键 $(c, x, o)$ 被划分为去重组。\n- 假设采用碱基水平的替换错误模型，即UMI字符串中的每个位置以独立的概率 $p$ 发生替换。\n- 目标是在每个组内对UMI进行聚类，以推断原始分子的数量。\n- 仅当满足以下条件时，才允许将一个丰度较低的UMI（$u_j$，计数为 $n_j$）有向合并到一个丰度较高的UMI（$u_i$，计数为 $n_i$）中：\n    1. 汉明距离 $d = H(u_i, u_j)$ 至多为 $d_{\\max}$。\n    2. 计数满足从错误模型参数（$p$, $L$）推导出的阈值。\n    3. 该规则必须从第一性原理推导得出，而非特设公式。\n- 输出是每个测试用例中独特分子（簇）的总数。\n- 问题提供了五个测试用例，包含特定参数 $(L, p, d_{\\max})$ 和UMI-计数对。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题在生物信息学领域，特别是在新一代测序数据分析方面，有充分的科学依据。UMI、PCR重复和测序错误模型都是标准概念。所假设的错误模型是一种常见的简化方法。\n- **适定性**：该问题提供了所有必要的输入（$L, p, d_{\\max}$，UMI计数）和一个明确的目标（计算推断出的分子数量）。核心任务是推导合并的决策规则，这是问题的一个明确部分，而非缺失信息。\n- **客观性**：该问题以精确、客观、技术性的语言陈述，没有歧义或主观性陈述。\n\n该问题不违反任何无效性标准。它是一个定义明确的计算生物学问题，要求对算法进行原则性推导。\n\n### 步骤 3：结论与行动\n问题被判定为有效。将着手开发解决方案。\n\n### 从第一性原理推导去重算法\n\n核心任务是制定一个决策规则，用于将计数较低的UMI（$u_j$，计数为 $n_j$）合并到计数较高的UMI（$u_i$，计数为 $n_i$）中。只有当 $u_j$ 很有可能是由对应于 $u_i$ 的分子在测序过程中产生的错误产物时，才应进行合并。\n\n1.  **基本错误过程**：给定长度为 $L$ 的UMI和每个碱基的替换概率 $p$，每个碱基上的事件是独立的。在单个读段中恰好发生 $d$ 次替换的概率由二项概率质量函数给出：\n    $$P(\\text{d errors}) = \\binom{L}{d} p^d (1-p)^{L-d}$$\n\n2.  **错误读段的期望数量**：对于一个由UMI $u_i$ 标识的真实分子，其观测到的PCR重复计数为 $n_i$，我们可以估计由该分子产生但包含恰好 $d$ 个错误的总读段期望数量。这是试验次数（$n_i$）乘以成功概率（$P(\\text{d errors})$）：\n    $$E[\\text{total reads with d errors from } u_i] = n_i \\times \\binom{L}{d} p^d (1-p)^{L-d}$$\n\n3.  **决策规则**：问题要求决策规则“由错误衍生的UMI的预期丰度来证明其合理性”。一种直接的、基于第一性原理的方法是基于此预期丰度创建一个阈值。与 $u_i$ 的汉明距离为 $d$ 的UMI $u_j$ 可能是众多可能错误产物之一。一种高度保守的方法，它避免了对错误分布进行复杂的统计建模，是将单个特定子UMI的计数 $n_j$ 与*该距离上错误读段的总期望数量*进行比较。\n\n    其基本原理如下：如果单个观测到的错误UMI的计数（$n_j$）已经大于来自父UMI（$u_i$）在该距离（$d$）上预期错误读段的*全部预算*，那么 $u_j$ 极不可能是仅仅由 $u_i$ 产生的错误产物。反之，如果 $n_j$ 在这个总预期预算之内，则可以合理地认为它是一个错误。这就建立了一个直接从错误模型推导出的简单的、非统计的阈值。对于较小的 $p$，$(1-p)^{L-d}$ 项接近于 $1$，可以近似省略。\n\n    因此，决策规则是：**如果 $n_j \\le n_i \\times \\binom{L}{d} \\times p^d$，则将 $u_j$ 合并到 $u_i$ 中**。\n\n4.  **算法实现**：\n    - 对于每个去重组，所有独特的UMI最初都被视为不同的分子。\n    - 我们从计数最低的UMI开始遍历，为每个UMI寻找一个潜在的父UMI。\n    - 子UMI $u_j$ 的潜在父UMI $u_i$ 必须具有更高的计数（$n_i > n_j$）和汉明距离 $d = H(u_i, u_j)$，且满足 $0  d \\le d_{\\max}$。\n    - 为避免模糊合并，我们为任何给定的子UMI选择唯一的“最佳”父UMI：即计数 $n_i$ 最高的那一个。我们按计数降序遍历潜在的父UMI，并选择第一个满足距离标准的。\n    - 如果为子UMI $u_j$ 找到了最佳父UMI $u_i$，我们就应用决策规则。如果 $n_j \\le n_i \\times \\binom{L}{d} \\times p^d$，则将 $u_j$ 从独特分子集合中移除。\n    - 对所有UMI重复此过程。最终的分子计数是集合中剩余UMI的数量。\n\n该过程提供了一种确定性的方法，它源自问题的错误模型，用于系统地计算数据中所代表的独特分子的数量。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import comb\n\ndef solve():\n    \"\"\"\n    Main function to solve the UMI deduplication problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1\n        [\n            {'L': 8, 'p': 0.01, 'd_max': 1, 'umi_counts': [(\"ACGTACGT\", 50), (\"ACGTACGA\", 4), (\"ACGTACGG\", 2)]}\n        ],\n        # Test Case 2\n        [\n            {'L': 8, 'p': 0.01, 'd_max': 1, 'umi_counts': [(\"TTTTTTTT\", 30), (\"TTTTTTTA\", 28)]}\n        ],\n        # Test Case 3\n        [\n            {'L': 8, 'p': 0.01, 'd_max': 1, 'umi_counts': [(\"GATTACAA\", 15), (\"GATTACAG\", 1)]},\n            {'L': 8, 'p': 0.01, 'd_max': 1, 'umi_counts': [(\"GATTACAA\", 6), (\"GATTACAT\", 5)]}\n        ],\n        # Test Case 4\n        [\n            {'L': 8, 'p': 0.01, 'd_max': 0, 'umi_counts': [(\"CCCCCCCC\", 12), (\"CCCCCCCA\", 1)]}\n        ],\n        # Test Case 5\n        [\n            {'L': 8, 'p': 0.01, 'd_max': 1, 'umi_counts': [(\"AAAAAAAT\", 8)]},\n            {'L': 8, 'p': 0.01, 'd_max': 1, 'umi_counts': [(\"AAAAAAAT\", 7)]}\n        ]\n    ]\n\n    results = []\n    for case_data in test_cases:\n        total_molecules_in_case = 0\n        for group in case_data:\n            total_molecules_in_case += _process_group(\n                group['L'], group['p'], group['d_max'], group['umi_counts']\n            )\n        results.append(total_molecules_in_case)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef _hamming_distance(s1, s2):\n    \"\"\"\n    Calculates the Hamming distance between two strings of equal length.\n    \"\"\"\n    if len(s1) != len(s2):\n        raise ValueError(\"Strings must be of equal length to compare.\")\n    return sum(c1 != c2 for c1, c2 in zip(s1, s2))\n\n\ndef _process_group(L, p, d_max, umi_counts_list):\n    \"\"\"\n    Processes a single deduplication group to find the number of unique molecules.\n\n    Args:\n        L (int): UMI length.\n        p (float): Substitution probability per base.\n        d_max (int): Maximum Hamming distance for merging.\n        umi_counts_list (list of tuples): List of (UMI_string, count).\n\n    Returns:\n        int: Number of unique molecules in the group.\n    \"\"\"\n    if not umi_counts_list:\n        return 0\n\n    umi_counts = dict(umi_counts_list)\n    unique_molecules = set(umi_counts.keys())\n    \n    # Sort UMIs by count: ascending for child processing, descending for parent search.\n    umis_sorted_asc = sorted(umi_counts.keys(), key=lambda u: umi_counts[u])\n    umis_sorted_desc = umis_sorted_asc[::-1]\n\n    # Iterate through potential children from lowest to highest count.\n    for u_child in umis_sorted_asc:\n        # If this UMI has already been merged, skip it.\n        if u_child not in unique_molecules:\n            continue\n\n        n_child = umi_counts[u_child]\n        best_parent = None\n\n        # Find the best potential parent (highest count) for the current child.\n        for u_parent in umis_sorted_desc:\n            if u_parent == u_child:\n                continue\n            \n            n_parent = umi_counts[u_parent]\n\n            # A parent must have a strictly higher count.\n            if n_parent = n_child:\n                continue\n\n            d = _hamming_distance(u_child, u_parent)\n            \n            # Check if distance is within the allowed maximum.\n            if d > 0 and d = d_max:\n                best_parent = u_parent\n                break  # Found the highest-count parent, no need to check others.\n        \n        if best_parent:\n            n_parent = umi_counts[best_parent]\n            d = _hamming_distance(u_child, best_parent)\n            \n            # Decision rule derived from first principles.\n            # The threshold is the expected number of reads with d errors originating\n            # from the parent molecule, under a simplified error model.\n            threshold = n_parent * comb(L, d, exact=True) * (p ** d)\n            \n            if n_child = threshold:\n                unique_molecules.remove(u_child)\n\n    return len(unique_molecules)\n\n# Execute the solution\nsolve()\n```"
        }
    ]
}