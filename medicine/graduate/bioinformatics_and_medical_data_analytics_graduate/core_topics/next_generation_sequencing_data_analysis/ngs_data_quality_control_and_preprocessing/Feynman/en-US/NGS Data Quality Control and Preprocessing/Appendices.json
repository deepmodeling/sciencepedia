{
    "hands_on_practices": [
        {
            "introduction": "The quality of individual base calls is the foundation of NGS data analysis. This exercise demonstrates the sliding window trimming algorithm, a ubiquitous heuristic for removing low-quality segments that can otherwise introduce errors in alignment and variant calling. By applying a rule based on Phred quality scores ($Q$), you will directly connect this abstract metric to a concrete data processing action and develop an intuition for how read quality impacts data integrity.",
            "id": "4590261",
            "problem": "A sequencing center generates five reads from Next-Generation Sequencing (NGS), each accompanied by basewise Phred quality scores. The Phred quality score (Phred) is defined by $Q = -10 \\log_{10}(p)$, where $p$ is the probability that a base is called incorrectly. A widely used and well-tested heuristic in NGS data quality control is sliding-window trimming: scan the read from the $5'$ end with a fixed window of size $w$, compute the arithmetic mean of the Phred scores in the window, and if the windowâ€™s mean drops below a specified threshold, trim the read at the start of that window (discarding that window and all downstream bases). This approach improves downstream alignment and variant calling robustness by removing low-confidence regions.\n\nConsider a window size $w = 4$ and a threshold of mean quality $Q \\ge 20$. For each read, let the quality sequence be $Q_{1}, Q_{2}, \\dots, Q_{n}$ with $1$-based indexing. Define window means $M_{i} = \\frac{1}{4}\\left(Q_{i} + Q_{i+1} + Q_{i+2} + Q_{i+3}\\right)$ for $i = 1, 2, \\dots, n-3$. The trimming rule is:\n- Find the smallest index $k$ such that $M_{k}  20$. If such $k$ exists, trim the read starting at base $k$ (retain bases $1$ through $k-1$); if no such $k$ exists, retain the entire read of length $n$.\n\nGiven the following five quality strings (already in numeric Phred $Q$ units), apply the above trimming rule and report, for each read, the number of bases retained after trimming. Express the final results as a single row matrix of five numbers (no units), corresponding to reads $1$ through $5$ in order.\n\nRead $1$: $31, 30, 29, 30, 28, 27, 26, 25, 24, 23, 22, 21, 18, 17, 16, 15$\n\nRead $2$: $25, 24, 23, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29$\n\nRead $3$: $28, 29, 30, 31, 27, 26, 25, 24, 23, 22, 21, 20, 20, 21, 22, 23$\n\nRead $4$: $35, 34, 10, 10, 10, 10, 10, 10, 30, 30, 30, 30, 30, 30, 30, 30$\n\nRead $5$: $20, 20, 20, 20, 20, 19, 19, 19, 19, 18, 18, 18, 21, 22, 23, 24$\n\nNo rounding is needed; report exact integer retained lengths in bases.",
            "solution": "The problem is well-defined, scientifically grounded in the field of bioinformatics, and provides all necessary information to proceed. We are tasked with applying a sliding-window trimming algorithm to five sequences of Phred quality scores. The window size is $w=4$ and the mean quality threshold is $20$. For each read, described by its quality sequence $Q_1, Q_2, \\dots, Q_n$, we calculate the window means $M_i = \\frac{1}{4}(Q_i + Q_{i+1} + Q_{i+2} + Q_{i+3})$. We must find the smallest index $k$ for which $M_k  20$. If such a $k$ is found, the read is trimmed, and the number of retained bases is $k-1$. If no such $k$ exists, the entire read of length $n$ is retained. All reads have length $n=16$.\n\nRead $1$: $Q^{(1)} = (31, 30, 29, 30, 28, 27, 26, 25, 24, 23, 22, 21, 18, 17, 16, 15)$.\nWe calculate the window means sequentially:\n$M_1 = \\frac{1}{4}(31+30+29+30) = \\frac{120}{4} = 30.0 \\ge 20$.\n$M_2 = \\frac{1}{4}(30+29+30+28) = \\frac{117}{4} = 29.25 \\ge 20$.\n$M_3 = \\frac{1}{4}(29+30+28+27) = \\frac{114}{4} = 28.5 \\ge 20$.\n$M_4 = \\frac{1}{4}(30+28+27+26) = \\frac{111}{4} = 27.75 \\ge 20$.\n$M_5 = \\frac{1}{4}(28+27+26+25) = \\frac{106}{4} = 26.5 \\ge 20$.\n$M_6 = \\frac{1}{4}(27+26+25+24) = \\frac{102}{4} = 25.5 \\ge 20$.\n$M_7 = \\frac{1}{4}(26+25+24+23) = \\frac{98}{4} = 24.5 \\ge 20$.\n$M_8 = \\frac{1}{4}(25+24+23+22) = \\frac{94}{4} = 23.5 \\ge 20$.\n$M_9 = \\frac{1}{4}(24+23+22+21) = \\frac{90}{4} = 22.5 \\ge 20$.\n$M_{10} = \\frac{1}{4}(23+22+21+18) = \\frac{84}{4} = 21.0 \\ge 20$.\n$M_{11} = \\frac{1}{4}(22+21+18+17) = \\frac{78}{4} = 19.5  20$.\nThe smallest index for which the mean is less than $20$ is $k=11$. The read is trimmed by retaining bases $1$ through $k-1 = 10$. The number of retained bases is $10$.\n\nRead $2$: $Q^{(2)} = (25, 24, 23, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29)$.\n$M_1 = \\frac{1}{4}(25+24+23+15) = \\frac{87}{4} = 21.75 \\ge 20$.\n$M_2 = \\frac{1}{4}(24+23+15+16) = \\frac{78}{4} = 19.5  20$.\nThe smallest index is $k=2$. The read is trimmed by retaining bases $1$ through $k-1=1$. The number of retained bases is $1$.\n\nRead $3$: $Q^{(3)} = (28, 29, 30, 31, 27, 26, 25, 24, 23, 22, 21, 20, 20, 21, 22, 23)$.\n$M_1 = \\frac{1}{4}(28+29+30+31) = \\frac{118}{4} = 29.5 \\ge 20$.\n$M_2 = \\frac{1}{4}(29+30+31+27) = \\frac{117}{4} = 29.25 \\ge 20$.\n$M_3 = \\frac{1}{4}(30+31+27+26) = \\frac{114}{4} = 28.5 \\ge 20$.\n... (continuing this process) ...\n$M_9 = \\frac{1}{4}(23+22+21+20) = \\frac{86}{4} = 21.5 \\ge 20$.\n$M_{10} = \\frac{1}{4}(22+21+20+20) = \\frac{83}{4} = 20.75 \\ge 20$.\n$M_{11} = \\frac{1}{4}(21+20+20+21) = \\frac{82}{4} = 20.5 \\ge 20$.\n$M_{12} = \\frac{1}{4}(20+20+21+22) = \\frac{83}{4} = 20.75 \\ge 20$.\n$M_{13} = \\frac{1}{4}(20+21+22+23) = \\frac{86}{4} = 21.5 \\ge 20$.\nAll possible window means are greater than or equal to $20$. No trimming occurs. The entire read is retained. The number of retained bases is $n=16$.\n\nRead $4$: $Q^{(4)} = (35, 34, 10, 10, 10, 10, 10, 10, 30, 30, 30, 30, 30, 30, 30, 30)$.\n$M_1 = \\frac{1}{4}(35+34+10+10) = \\frac{89}{4} = 22.25 \\ge 20$.\n$M_2 = \\frac{1}{4}(34+10+10+10) = \\frac{64}{4} = 16  20$.\nThe smallest index is $k=2$. The read is trimmed by retaining bases $1$ through $k-1=1$. The number of retained bases is $1$.\n\nRead $5$: $Q^{(5)} = (20, 20, 20, 20, 20, 19, 19, 19, 19, 18, 18, 18, 21, 22, 23, 24)$.\n$M_1 = \\frac{1}{4}(20+20+20+20) = \\frac{80}{4} = 20.0 \\ge 20$.\n$M_2 = \\frac{1}{4}(20+20+20+20) = \\frac{80}{4} = 20.0 \\ge 20$.\n$M_3 = \\frac{1}{4}(20+20+20+19) = \\frac{79}{4} = 19.75  20$.\nThe smallest index is $k=3$. The read is trimmed by retaining bases $1$ through $k-1=2$. The number of retained bases is $2$.\n\nThe number of bases retained for each of the five reads are $10, 1, 16, 1, 2$. This is collated into a single row matrix.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 10  1  16  1  2 \\end{pmatrix} } $$"
        },
        {
            "introduction": "Raw sequencing data is often contaminated with synthetic adapter sequences left over from library preparation. This practice introduces a powerful, model-based approach to detect such artifacts by identifying statistically overrepresented short sequences, or $k$-mers. You will implement a workflow to compare observed $k$-mer counts against an expected frequency derived from background base composition, a core principle in discovering anomalies within large sequence datasets .",
            "id": "4590249",
            "problem": "You are tasked with implementing a program that performs a principled quality control step common in Next-Generation Sequencing (NGS) data preprocessing: the detection of adapter contamination via enriched $k$-mers. The task must be framed using first-principles probability under an independent base composition model and purely algorithmic logic.\n\nThe program shall process a set of test cases. In each case, you are given: a $k$-mer length $k$, a total number of reads $N$, a read length $L$, a base composition vector $\\boldsymbol{\\pi} = (\\pi_A, \\pi_C, \\pi_G, \\pi_T)$ where each $\\pi_X$ is the probability of observing nucleotide $X \\in \\{A, C, G, T\\}$ in any position, a dictionary mapping $k$-mer strings to integer counts where each count equals the number of reads that contain that $k$-mer at least once, and a list of known adapter sequences. You must identify the most enriched $k$-mer relative to the null model defined below, determine if it matches any known adapter allowing up to one mismatch, and compute the fraction of reads affected.\n\nFundamental base for modeling:\n- Assume independent and identically distributed nucleotides within each read according to $\\boldsymbol{\\pi}$.\n- For any specific $k$-mer string $s = (b_1, b_2, \\dots, b_k)$ with $b_j \\in \\{A, C, G, T\\}$, the probability that a particular window of length $k$ equals $s$ under the independence model is $q(s) = \\prod_{j=1}^{k} \\pi_{b_j}$.\n- A read of length $L$ contains $W = L - k + 1$ windows of length $k$. Treat these windows as independent draws from the base composition model.\n- Use a well-tested independence approximation to reason about the probability that a read contains the $k$-mer $s$ at least once (derive this in your solution; do not assume any shortcut formula without justification).\n- Let $c(s)$ denote the observed count of reads containing $s$ at least once, and let $\\mu(s)$ denote the expected count of reads containing $s$ under the independence model. Define an enrichment score $R(s)$ that compares $c(s)$ to $\\mu(s)$ and select the top enriched $k$-mer $s^\\*$ as the maximizer of $R(s)$.\n\nAdapter matching:\n- Define the Hamming distance $d_H(x, y)$ between two strings $x$ and $y$ of equal length as the number of positions where they differ.\n- A $k$-mer $s$ matches an adapter sequence $a$ if there exists a contiguous substring $t$ of $a$ of length $k$ such that $d_H(s, t) \\leq 1$.\n\nFinal quantity:\n- If $s^\\*$ matches any known adapter under the above definition, report the fraction of reads affected as $F = c(s^\\*) / N$. If there is no match, report $F = 0$.\n- Express the output fractions as decimal numbers (without any percentage sign) rounded to six decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[x,y,z]\"), in the same order as the test cases below.\n\nTest Suite:\nCase $1$:\n- $k = 10$, $N = 10000$, $L = 100$.\n- $\\boldsymbol{\\pi}$: $\\pi_A = 0.3$, $\\pi_C = 0.2$, $\\pi_G = 0.2$, $\\pi_T = 0.3$.\n- $k$-mer counts:\n  - \"AGATCGGAAG\": $1800$\n  - \"TTTTTTTTTT\": $300$\n  - \"ACGTACGTAC\": $270$\n  - \"GCTAGCTAGC\": $240$\n  - \"AAAAAAAAAA\": $260$\n  - \"CGATCGATCG\": $220$\n- Known adapters: [\"AGATCGGAAGAGC\", \"ACACTCTTTCCCT\"].\n\nCase $2$:\n- $k = 12$, $N = 8000$, $L = 75$.\n- $\\boldsymbol{\\pi}$: $\\pi_A = 0.25$, $\\pi_C = 0.25$, $\\pi_G = 0.25$, $\\pi_T = 0.25$.\n- $k$-mer counts:\n  - \"AGATCGGAAGAC\": $700$\n  - \"TTTTTTTTTTTT\": $650$\n  - \"ACGTACGTACGT\": $500$\n  - \"GCGCGCGCGCGC\": $480$\n  - \"AAAAAAAAAAAA\": $600$\n- Known adapters: [\"AGATCGGAAGAGCACACGTCT\", \"ACACTCTTTCCCTACACGACG\"].\n\nCase $3$ (boundary condition where $L = k$):\n- $k = 8$, $N = 5000$, $L = 8$.\n- $\\boldsymbol{\\pi}$: $\\pi_A = 0.25$, $\\pi_C = 0.25$, $\\pi_G = 0.25$, $\\pi_T = 0.25$.\n- $k$-mer counts:\n  - \"GCGCGCGC\": $400$\n  - \"ATATATAT\": $350$\n  - \"AAAAAAAA\": $320$\n  - \"CCCCCCCC\": $300$\n  - \"GGGGGGGG\": $290$\n- Known adapters: [\"AGATCGGAAGAGCACACGTCT\", \"ACACTCTTTCCCTACACGACG\"].\n\nYour program must implement the modeling logic from first principles, identify $s^\\*$ for each case, perform matching with up to one mismatch against the adapter substrings, and compute the final fraction $F$ as specified. The single-line output must present the three fractions as floating-point decimals rounded to six places in the order of Cases $1$, $2$, and $3$.",
            "solution": "The user-provided problem has been analyzed and found to be valid. It is scientifically grounded in the principles of bioinformatics and statistics, well-posed with a clear objective and sufficient data, and free from any scientific, logical, or formal flaws.\n\nThe solution proceeds by developing the required model from first principles, as outlined below.\n\n**1. The Null Model: Probability of a Specific $k$-mer**\n\nThe problem assumes an independent and identically distributed (i.i.d.) model for nucleotide sequences. The probability of observing any specific nucleotide $X \\in \\{A, C, G, T\\}$ at any position is given by the base composition vector $\\boldsymbol{\\pi} = (\\pi_A, \\pi_C, \\pi_G, \\pi_T)$.\n\nFor a specific $k$-mer string $s$ of length $k$, let its sequence be $s = (b_1, b_2, \\dots, b_k)$, where each $b_j$ is a nucleotide. Due to the independence assumption, the probability of a specific window of length $k$ matching this string $s$ is the product of the probabilities of its constituent bases:\n$$q(s) = P(\\text{window} = s) = \\prod_{j=1}^{k} \\pi_{b_j}$$\n\n**2. Probability of a $k$-mer Presence in a Single Read**\n\nA single read has a length of $L$. The number of possible starting positions for a $k$-mer within this read defines the number of windows, which is $W = L - k + 1$. The problem specifies that these $W$ windows should be treated as independent draws from the base composition model.\n\nWe are interested in the probability that a read contains the $k$-mer $s$ at least once. It is more straightforward to first calculate the complementary probability: that the read does not contain the $k$-mer $s$ in any of its $W$ windows.\n\nThe probability that a single, specific window does *not* match $s$ is $1 - q(s)$. Given the independence of windows, the probability that *none* of the $W$ windows match $s$ is the product of their individual probabilities of not matching:\n$$P(\\text{read does not contain } s) = \\prod_{i=1}^{W} (1 - q(s)) = (1 - q(s))^W$$\n\nTherefore, the probability that a read contains $s$ at least once, denoted as $p(s)$, is:\n$$p(s) = 1 - P(\\text{read does not contain } s) = 1 - (1 - q(s))^W = 1 - (1 - q(s))^{L-k+1}$$\n\n**3. Expected $k$-mer Count Across All Reads**\n\nGiven a total of $N$ reads, each read represents an independent Bernoulli trial where \"success\" is defined as the presence of the $k$-mer $s$. The probability of success for each trial is $p(s)$. The total number of reads containing $s$ thus follows a binomial distribution, $B(N, p(s))$.\n\nThe expected number of reads containing $s$, denoted $\\mu(s)$, is the mean of this distribution:\n$$\\mu(s) = E[\\text{count of reads with } s] = N \\cdot p(s) = N \\left(1 - (1 - q(s))^{L-k+1}\\right)$$\nThis is the expected count under the null model of random sequence composition.\n\n**4. Enrichment Score and Identification of the Candidate $k$-mer**\n\nAdapter contamination leads to an observed count of a $k$-mer, $c(s)$, that is significantly higher than its expected count, $\\mu(s)$. The enrichment score, $R(s)$, quantifies this discrepancy. As specified, $R(s)$ compares $c(s)$ to $\\mu(s)$; we define it as their ratio, a standard measure of overrepresentation:\n$$R(s) = \\frac{c(s)}{\\mu(s)}$$\nThe most enriched $k$-mer, $s^*$, is the one that maximizes this score among all observed $k$-mers in the provided dataset:\n$$s^* = \\underset{s}{\\operatorname{arg\\,max}} \\{R(s)\\}$$\n\n**5. Adapter Matching Protocol**\n\nTo confirm if the enriched $k$-mer $s^*$ originates from adapter contamination, it is compared against a list of known adapter sequences. The matching criterion is based on the Hamming distance, $d_H(x, y)$, which counts the number of positions at which two strings of equal length differ.\n\nA match is confirmed if there exists any contiguous substring $t$ within any known adapter sequence $a$ such that the length of $t$ is $k$ and the Hamming distance between the most enriched $k$-mer and the substring is at most one:\n$$\\exists t \\subset a \\text{ where } |t|=k \\text{ such that } d_H(s^*, t) \\leq 1$$\n\n**6. Computation of the Final Fraction**\n\nThe final output is the fraction of reads affected by the most prominent adapter contamination.\n- If the most enriched $k$-mer, $s^*$, matches a known adapter according to the rule above, the fraction of affected reads $F$ is calculated using its observed count $c(s^*)$ and the total number of reads $N$:\n$$F = \\frac{c(s^*)}{N}$$\n- If $s^*$ does not match any adapter, the enrichment is considered incidental or due to other biological reasons, not adapter contamination. In this case, the fraction of affected reads from adapters is zero:\n$$F = 0$$\nThe final value of $F$ is reported as a decimal rounded to six places.",
            "answer": "[0.180000,0.087500,0.000000]"
        },
        {
            "introduction": "In quantitative NGS applications, distinguishing PCR duplicates from true biological molecules is critical for accuracy. This advanced exercise tackles the challenges of using Unique Molecular Identifiers (UMIs) by combining algorithmic error correction with statistical estimation. You will first implement a directional merging algorithm to consolidate UMIs differing by small edit distances and then apply a model based on the classic occupancy problem to correct for UMI collisions, where different molecules are assigned the same tag by chance .",
            "id": "4590260",
            "problem": "You are given multiple sets of Next-Generation Sequencing (NGS) alignments annotated with Unique Molecular Identifiers (UMIs). The objective is two-fold: first, perform error-aware UMI deduplication using a Hamming-distance threshold of $1$ to estimate the number of unique molecules per locus; second, adjust these counts to estimate and correct for UMI collisions based on an occupancy model derived from first principles. All UMIs are of equal length and consist of characters from the Deoxyribonucleic Acid (DNA) alphabet $\\{A, C, G, T\\}$.\n\nDefinitions and assumptions to use:\n- The Hamming distance $d(u, v)$ between two UMIs $u$ and $v$ of equal length is the number of positions at which the corresponding symbols differ.\n- Error correction is performed within each locus by merging lower-abundance UMIs into higher-abundance UMIs if $d(u, v) \\leq 1$. Specifically, construct a directed graph where each UMI $u$ has a directed edge to UMI $v$ if $d(u, v) \\leq 1$ and the count $c(v)  c(u)$. Iteratively merge each UMI $u$ into its neighbor $v$ with the maximal count among neighbors satisfying those conditions (breaking ties lexicographically), updating counts and continuing until no merges are possible. The final number of nodes remaining is the deduplicated unique molecule count $K$ for that locus.\n- The UMI design space size $M$ for UMIs of length $L$ over the DNA alphabet size $A = 4$ is $M = A^{L} = 4^{L}$.\n- To adjust for UMI collisions, assume that each of the $N$ underlying molecules independently and uniformly selects a UMI from the $M$-sized design space. Under this assumption, derive $N$ from the observed $K$ using the occupancy model. Express the adjusted molecule estimate $\\hat{N}$ as a float rounded to $3$ decimal places. If $K = 0$, define $\\hat{N} = 0$.\n\nYour task is to implement a program that, given the following test suite, performs the above steps for each case and outputs the results in the specified format.\n\nTest suite parameterization:\nFor each test case, you are given the UMI length $L$, the edit-distance threshold $t$ (always $1$), and a list of UMI strings with integer counts. All UMIs listed belong to a single locus for that case.\n\n- Case $1$:\n  - $L = 8$, $t = 1$\n  - UMIs and counts:\n    - $\\texttt{ACGTACGT}$ with count $12$\n    - $\\texttt{ACGTACGA}$ with count $2$\n    - $\\texttt{ACGTTCGT}$ with count $1$\n    - $\\texttt{ACGTACGG}$ with count $1$\n    - $\\texttt{TCGTACGT}$ with count $1$\n\n- Case $2$:\n  - $L = 10$, $t = 1$\n  - UMIs and counts:\n    - $\\texttt{AAAAAGGGGG}$ with count $5$\n    - $\\texttt{TTTTTCCCCC}$ with count $4$\n    - $\\texttt{GGGGGAAAAA}$ with count $3$\n\n- Case $3$:\n  - $L = 2$, $t = 1$\n  - UMIs and counts ($15$ distinct UMIs, each with count $1$):\n    - $\\texttt{AA}$, $\\texttt{AC}$, $\\texttt{AG}$, $\\texttt{AT}$, $\\texttt{CA}$, $\\texttt{CC}$, $\\texttt{CG}$, $\\texttt{CT}$, $\\texttt{GA}$, $\\texttt{GC}$, $\\texttt{GG}$, $\\texttt{GT}$, $\\texttt{TA}$, $\\texttt{TC}$, $\\texttt{TG}$\n\n- Case $4$:\n  - $L = 6$, $t = 1$\n  - UMIs and counts:\n    - $\\texttt{AAAAAA}$ with count $20$\n    - $\\texttt{AAAATA}$ with count $1$\n    - $\\texttt{AAAAAG}$ with count $1$\n    - $\\texttt{CCCCCC}$ with count $18$\n    - $\\texttt{CCCACC}$ with count $2$\n    - $\\texttt{CCCCCG}$ with count $1$\n\n- Case $5$:\n  - $L = 8$, $t = 1$\n  - UMIs and counts:\n    - $\\texttt{GATTACAA}$ with count $3$\n    - $\\texttt{GATTACAT}$ with count $3$\n    - $\\texttt{CTTTACAA}$ with count $1$\n    - $\\texttt{TGCCGGTT}$ with count $10$\n    - $\\texttt{TGCCGGTA}$ with count $1$\n    - $\\texttt{AAAAAAAT}$ with count $1$\n    - $\\texttt{TTTTTTTT}$ with count $1$\n\nProgram requirements:\n- For each case, compute the deduplicated unique molecule count $K$ using the specified directional adjacency merging rule with $t = 1$.\n- Compute the UMI space size $M = 4^{L}$.\n- Derive the collision-adjusted molecule estimate $\\hat{N}$ from first principles of the occupancy model and report it rounded to $3$ decimal places. Use the unitless count domain; no physical units are involved.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is a two-element list $[K, \\hat{N}]$. For example, the output format must be exactly like $[[K_1,\\hat{N}_1],[K_2,\\hat{N}_2],\\dots]$ with no additional text.",
            "solution": "The problem statement has been analyzed and is determined to be valid. It is scientifically sound, well-posed, objective, and contains all necessary information to derive a unique, verifiable solution. The problem involves two standard procedures in bioinformatics: error-aware UMI deduplication and statistical correction for UMI collisions, both of which are grounded in established algorithmic and statistical principles.\n\nThe solution is partitioned into two principal stages for each test case:\n1.  Error-aware UMI deduplication to determine the observed number of unique molecules, $K$.\n2.  Statistical estimation of the true number of unique molecules, $\\hat{N}$, to correct for UMI collisions.\n\n### Part 1: UMI Deduplication via Directional Merging\n\nThe goal of this stage is to consolidate UMIs that are likely variants of a parent UMI due to sequencing errors. The problem defines a specific, deterministic algorithm for this process, which can be conceptualized as a directed graph problem.\n\nLet the set of unique UMIs at a given locus be $U = \\{u_1, u_2, \\dots, u_p\\}$, with associated counts $\\{c(u_1), c(u_2), \\dots, c(p)\\}$. The deduplication procedure is as follows:\n\n1.  **Graph Representation**: We can imagine a directed graph where each UMI is a node. A directed edge exists from node $u$ to node $v$ if and only if two conditions are met:\n    - The Hamming distance is minimal: $d(u, v) \\leq 1$. Given that $u \\neq v$, this is equivalent to $d(u, v) = 1$.\n    - The read count of the target UMI is strictly greater than the source UMI: $c(v)  c(u)$.\n\n2.  **Iterative Merging**: The process is iterative. In each pass, we identify UMIs that can be merged. A UMI $u$ is merged into a UMI $v$ if an edge exists from $u$ to $v$. The problem specifies a resolution strategy for cases where a UMI $u$ could be merged into multiple other UMIs:\n    - The target UMI $v$ must have the maximal count among all possible targets for $u$.\n    - If a tie in maximal counts occurs (i.e., multiple potential targets have the same highest count), the tie is broken by choosing the target UMI that is lexicographically smallest.\n\n3.  **Algorithmic Implementation**: To implement this deterministically, a systematic approach is required. The process continues until no more merges are possible in a full pass over the remaining UMIs.\n    - We maintain a dictionary of UMI strings to their integer counts.\n    - We loop until a pass completes with no merges. In each pass:\n        a. We create a sorted list of the current UMIs, ordered first by count (ascending) and second by the UMI string itself (lexicographically ascending). This ensures we always attempt to merge lower-abundance UMIs into higher-abundance ones in a consistent order.\n        b. For each UMI $u$ with count $c(u)$ in this sorted list, we identify a set of valid merge targets $\\{v_1, v_2, \\dots\\}$. A UMI $v_j$ is a valid target if $d(u, v_j) = 1$ and $c(v_j)  c(u)$.\n        c. If the set of targets is non-empty, we select the single best target $v_{best}$. This is done by finding the maximum count among all targets, and then selecting the lexicographically smallest UMI among those with the maximum count.\n        d. If a $v_{best}$ is found, we perform the merge: the count of $u$ is added to the count of $v_{best}$, and $u$ is removed from our set of UMIs. The pass is then immediately restarted (by breaking the inner loop and continuing the outer loop) because the change in counts can affect subsequent potential merges.\n        e. If a full pass over all UMIs results in no merges, the process terminates.\n\n4.  **Final Count**: The number of UMIs remaining at the end of this iterative process is the deduplicated unique molecule count, $K$.\n\n### Part 2: Collision Correction using an Occupancy Model\n\nThe second stage corrects for the possibility that two or more distinct initial molecules were, by chance, labeled with the same UMI. This is a classic statistical problem known as the occupancy problem or \"balls-into-bins\".\n\n1.  **Model Formulation**:\n    - Let $N$ be the true, unknown number of unique molecules (the \"balls\").\n    - Let $M$ be the total size of the UMI design space (the \"bins\"). For a UMI of length $L$ and an alphabet of size $A=4$ (for DNA), $M = A^L = 4^L$.\n    - We assume each of the $N$ molecules independently and uniformly selects one of the $M$ possible UMIs.\n    - We observe $K$ distinct UMIs after error correction (the number of \"occupied bins\").\n\n2.  **Derivation of the Estimator**: We can estimate $N$ by relating it to the expected value of $K$.\n    - The probability that a specific UMI (bin) is *not* chosen by a single molecule is $(1 - 1/M)$.\n    - The probability that this specific UMI is not chosen by any of the $N$ molecules is $(1 - 1/M)^N$.\n    - This is the probability that the bin is empty. By linearity of expectation, the expected number of empty bins is $E[\\text{empty bins}] = M \\cdot (1 - 1/M)^N$.\n    - The expected number of occupied bins, $E[K]$, is the total number of bins minus the expected number of empty bins:\n    $$E[K] = M - M \\left(1 - \\frac{1}{M}\\right)^N = M \\left[1 - \\left(1 - \\frac{1}{M}\\right)^N\\right]$$\n    - To find our estimator $\\hat{N}$, we apply the method of moments by setting the observed value $K$ equal to its expectation and solving for $N$:\n    $$K = M \\left[1 - \\left(1 - \\frac{1}{M}\\right)^{\\hat{N}}\\right]$$\n    - Rearranging the terms to solve for $\\hat{N}$:\n    $$\\frac{K}{M} = 1 - \\left(1 - \\frac{1}{M}\\right)^{\\hat{N}}$$\n    $$\\left(1 - \\frac{1}{M}\\right)^{\\hat{N}} = 1 - \\frac{K}{M}$$\n    - Taking the natural logarithm of both sides:\n    $$\\hat{N} \\ln\\left(1 - \\frac{1}{M}\\right) = \\ln\\left(1 - \\frac{K}{M}\\right)$$\n    - Finally, we arrive at the estimator for $N$:\n    $$\\hat{N} = \\frac{\\ln\\left(1 - \\frac{K}{M}\\right)}{\\ln\\left(1 - \\frac{1}{M}\\right)}$$\n\n3.  **Special Cases**:\n    - If $K=0$, the problem defines $\\hat{N}=0$, which is consistent with the formula as $\\ln(1)=0$.\n    - If $K \\geq M$, the argument to the numerator's logarithm, $(1-K/M)$, becomes non-positive, and the formula is undefined or yields a non-real result in this domain. This scenario, where more unique UMIs are observed than are possible, should not occur in a valid application of this model but would imply an extremely large or infinite number of original molecules. The provided test cases do not exhibit this property.\n\nThe final estimate $\\hat{N}$ is calculated using this formula and rounded to $3$ decimal places as required. The overall procedure combines these two parts to produce a pair $[K, \\hat{N}]$ for each test case.",
            "answer": "[[1,1.000],[3,3.000],[15,42.968],[2,2.000],[5,5.000]]"
        }
    ]
}