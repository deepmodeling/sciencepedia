{
    "hands_on_practices": [
        {
            "introduction": "在开始任何分析之前，我们必须确保能正确解读数据。第一个实践练习将处理一个关键的初始步骤：确定FASTQ文件的质量分数编码格式。错误地解读编码格式会使所有后续基于质量的分析失效，因此本练习旨在根据基本的数据标准，磨练您建立稳健验证规则的能力。",
            "id": "4590262",
            "problem": "您将设计并实现一个程序，该程序根据 FASTQ 格式（FASTQ）文件中的质量字符的经验分布，执行假设检验，以推断所使用的编码偏移量是 Phred 加 $33$ 还是 Phred 加 $64$。其背景是生物信息学和医学数据分析中的新一代测序（NGS）数据预处理，其中碱基识别准确率的质量控制至关重要。\n\n假设存在以下基本定义和事实：\n- Phred 质量分数（Phred）由关系式 $$Q=-10\\log_{10}(p)$$ 定义，其中 $Q$ 是一个整数值的质量分数，$p$ 是一个碱基识别的错误概率。\n- 在 FASTQ 格式中，质量分数通过美国信息交换标准代码（ASCII）字符和一个偏移量 $o$ 来表示，每个字符 $c$ 编码一个整数 $$q(c,o)=\\mathrm{ord}(c)-o$$。广泛使用的编码是 $o=33$（Phred 加 $33$）和 $o=64$（Phred 加 $64$）。\n- 根据经验和平台规范，观测到的 Phred 分数被限制在整数范围 $$q\\in\\{0,1,2,\\dots,41\\}$$ 内。\n- 在编码偏移量 $o$ 下，质量字符的有效 ASCII 支持集为 $$\\mathcal{S}_o=\\{c\\in\\text{ASCII}:\\mathrm{ord}(c)\\in[o,o+41]\\}$$。\n\n您的任务是，仅基于观测到的质量字符的经验分布，构建一个统计检验，在以下两个复合假设之间做出决策：\n- $$H_{33}:o=33,$$\n- $$H_{64}:o=64,$$\n该决策受限于一个约束条件，即对于所有观测到的字符 $c$，其映射分数 $q(c,o)$ 都必须位于集合 $\\{0,\\dots,41\\}$ 中。该检验必须是有原则的，其决策规则需从上述定义和事实推导得出，并为每个测试用例返回一个数值决策。如果在这些约束条件下，观测到的经验分布不允许在 $H_{33}$ 和 $H_{64}$ 之间做出明确选择，则检验必须根据一个明确合理的规则输出一个未定代码。\n\n输入格式和数据模型：\n- 程序没有外部输入；它将在内部使用四个测试用例，每个用例以字符串列表的形式提供。每个字符串代表一个 FASTQ 质量行。程序应将一个用例中所有行的全部字符的多重集视为经验样本 $\\{c_1,\\dots,c_n\\}$。\n- 四个测试用例如下：\n    1. 用例 A（典型的 Phred 加 $33$ 场景）：$$[\"!!IIJJ\", \"!IJIJ\"]$$\n    2. 用例 B（典型的 Phred 加 $64$ 场景）：$$[\"@@hhi\", \"hhi@@\"]$$\n    3. 用例 C（完全位于重叠区域的模糊场景）：$$[\"@ABCDEFGHIJ\"]$$\n    4. 用例 D（边界模糊场景）：$$[\"@@@III\", \"@I@I@I\"]$$\n\n输出规范：\n- 为每个用例输出一个整数决策：\n    - 如果您的检验推断为 Phred 加 $33$，输出 $33$。\n    - 如果您的检验推断为 Phred 加 $64$，输出 $64$。\n    - 如果在推导出的决策规则下检验结果为未定，输出 $0$。\n- 您的程序应生成单行输出，其中包含按四个用例顺序排列的结果，形式为逗号分隔的列表，并用方括号括起来，例如 $$[33,64,0,0]$$。\n\n设计约束：\n- 推导过程必须从上述核心定义和广为接受的事实出发，并得出一个逻辑上合理的决策规则。除所述约束外，不得假设任何额外的平台特定的启发式方法或外部提示。\n- 该统计检验必须用纯粹的数学术语来定义，仅依赖于观测到的 ASCII 字符的经验分布（通过其整数代码）以及两种编码所隐含的已知支持集约束。\n- 确保完整性、科学真实性和自洽性：决策规则对于所提供的测试套件必须是合理且稳健的，包括正常操作、边界条件和边缘情况。",
            "solution": "该问题要求设计一个统计检验，用以确定 FASTQ 格式数据中 Phred 质量分数的编码偏移量。决策需在两个相互竞争的假设之间做出：$H_{33}$ 假设偏移量 $o=33$ (Phred+33)，而 $H_{64}$ 假设偏移量 $o=64$ (Phred+64)。决策必须仅基于观测到的质量字符的经验分布，并遵循 FASTQ 格式和 Phred 分数的既定约束。\n\n我们的推导从所提供的基本原则开始。Phred 质量分数 $Q$ 是一个整数。问题陈述指出，根据经验，这些分数被限制在集合 $Q \\in \\{0, 1, 2, \\dots, 41\\}$ 中。在 FASTQ 文件中，每个质量分数被编码为一个美国信息交换标准代码（ASCII）字符 $c$，并使用一个整数偏移量 $o$。解码规则如下：\n$$q(c, o) = \\mathrm{ord}(c) - o$$\n其中 $\\mathrm{ord}(c)$ 是字符 $c$ 的 ASCII 序数值。\n\n对于质量字符串中存在的任何字符 $c$，要在特定的编码假设 $H_o$ 下被视为有效，其解码后的质量分数 $q(c, o)$ 必须落在 Phred 分数的允许范围内。也就是说，对于给定的偏移量 $o$，一个字符 $c$ 是有效的，当且仅当：\n$$0 \\le q(c, o) \\le 41$$\n代入 $q(c, o)$ 的定义，我们得到对该字符序数值的约束：\n$$0 \\le \\mathrm{ord}(c) - o \\le 41$$\n这个不等式可以重写，为给定的偏移量 $o$ 定义一个有效 ASCII 序数值的闭区间：\n$$o \\le \\mathrm{ord}(c) \\le o + 41$$\n\n现在，我们可以为我们的两个特定假设定义有效的 ASCII 序数范围。\n\n对于假设 $H_{33}$ (Phred+$33$)，其中偏移量 $o=33$：\n有效序数值的范围是 $[33, 33+41]$，即 $[33, 74]$。我们将此序数值集合表示为 $\\mathcal{R}_{33}$。对应的 ASCII 字符范围从 `!` (序数 $33$) 到 `J` (序数 $74$)。\n\n对于假设 $H_{64}$ (Phred+$64$)，其中偏移量 $o=64$：\n有效序数值的范围是 $[64, 64+41]$，即 $[64, 105]$。我们将此序数值集合表示为 $\\mathcal{R}_{64}$。对应的 ASCII 字符范围从 `@` (序数 $64$) 到 `i` (序数 $105$)。\n\n我们统计检验的核心是一致性规则。一个给定的假设 $H_o$ 被认为是可行的，当且仅当观测到的经验样本中的*所有*字符在该假设下都是有效的。设给定测试用例中观测到的字符的多重集为 $C_{obs} = \\{c_1, c_2, \\dots, c_n\\}$，对应的序数值集合为 $O_{obs} = \\{\\mathrm{ord}(c_1), \\mathrm{ord}(c_2), \\dots, \\mathrm{ord}(c_n)\\}$。\n\n假设 $H_{33}$ 是可行的，当且仅当每个观测到的序数值都落在范围 $\\mathcal{R}_{33}$ 内。数学上表示为 $O_{obs} \\subseteq \\mathcal{R}_{33}$。\n假设 $H_{64}$ 是可行的，当且仅当每个观测到的序数值都落在范围 $\\mathcal{R}_{64}$ 内。数学上表示为 $O_{obs} \\subseteq \\mathcal{R}_{64}$。\n\n这些集合包含条件可以通过检查观测到的序数值的最小值和最大值来高效地进行检验。设 $o_{min} = \\min(O_{obs})$ 和 $o_{max} = \\max(O_{obs})$。\n$H_{33}$ 的可行性条件，我们表示为布尔谓词 $V_{33}$，是：\n$$V_{33} \\equiv (o_{min} \\ge 33) \\land (o_{max} \\le 74)$$\n$H_{64}$ 的可行性条件，表示为 $V_{64}$，是：\n$$V_{64} \\equiv (o_{min} \\ge 64) \\land (o_{max} \\le 105)$$\n\n如果观测集 $C_{obs}$ 为空，那么 $o_{min}$ 和 $o_{max}$ 未定义。在这种特殊情况下，条件 $O_{obs} \\subseteq \\mathcal{R}_{33}$ 和 $O_{obs} \\subseteq \\mathcal{R}_{64}$ 因前提条件不满足而自然成立，使得两个假设都可行。\n\n利用这些谓词，我们可以构建一个确定性决策规则：\n1.  如果 $V_{33}$ 为真且 $V_{64}$ 为假：数据唯一地与 Phred+$33$ 编码一致。这意味着至少有一个字符 $c$ 的 $\\mathrm{ord}(c)  64$。决策为 $33$。\n2.  如果 $V_{33}$ 为假且 $V_{64}$ 为真：数据唯一地与 Phred+$64$ 编码一致。这意味着至少有一个字符 $c$ 的 $\\mathrm{ord}(c) > 74$。决策为 $64$。\n3.  如果 $V_{33}$ 为真且 $V_{64}$ 为真：数据与两种编码方案都一致。这种情况发生当且仅当所有观测到的字符的序数值都位于两个有效范围的交集中：$\\mathcal{R}_{33} \\cap \\mathcal{R}_{64} = [33, 74] \\cap [64, 105] = [64, 74]$。在这种情况下，根据给定的约束，编码是不明确的。决策为 $0$ (未定)。这个逻辑也覆盖了观测集为空的边缘情况。\n4.  如果 $V_{33}$ 为假且 $V_{64}$ 为假：数据与两个假设都不一致。例如，当样本中包含一个序数值小于 $33$ 的字符，或者字符组合跨越了两个独立范围之外（例如，一个字符的序数  64，另一个的序数 > 74），就会发生这种情况。此类数据将违反问题关于存在有效编码的基本前提。由于无法做出明确选择，这种情况也被归类为未定，决策为 $0$。\n\n这套规则为任何给定的质量字符样本提供了一个完整、稳健且逻辑上推导出的算法，用于在 $H_{33}$ 和 $H_{64}$ 之间做出决策，或宣布其不明确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Designs and implements a program to infer FASTQ quality encoding format.\n    The program performs a hypothesis test to decide between Phred+33 and Phred+64.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Typical Phred+33 scenario\n        [\"!!IIJJ\", \"!IJIJ\"],\n        # Case B: Typical Phred+64 scenario\n        [\"@@hhi\", \"hhi@@\"],\n        # Case C: Ambiguous scenario\n        [\"@ABCDEFGHIJ\"],\n        # Case D: Boundary ambiguous scenario\n        [\"@@@III\", \"@I@I@I\"],\n    ]\n\n    results = []\n    \n    # Define constants for the ordinal ranges based on the problem statement.\n    # For Phred+33 (o=33), valid quality scores q in [0, 41] map to ordinals in [33, 74].\n    PHRED33_ORD_MIN = 33\n    PHRED33_ORD_MAX = 74\n    \n    # For Phred+64 (o=64), valid quality scores q in [0, 41] map to ordinals in [64, 105].\n    PHRED64_ORD_MIN = 64\n    PHRED64_ORD_MAX = 105\n\n    for case in test_cases:\n        # Concatenate all quality strings in the case to get the full sample of characters.\n        all_chars = \"\".join(case)\n\n        # Handle the edge case of no character observations.\n        # If there are no characters, the data is consistent with both hypotheses (vacuously true),\n        # so the result is undetermined.\n        if not all_chars:\n            results.append(0)\n            continue\n            \n        # Convert all characters to their ASCII ordinal values.\n        ord_values = np.array([ord(c) for c in all_chars])\n        \n        # Find the minimum and maximum ordinal values in the sample.\n        o_min = ord_values.min()\n        o_max = ord_values.max()\n\n        # Determine if the observed range of ordinals is consistent with Phred+33.\n        # The entire sample must fall within the valid range for Phred+33.\n        is_valid_33 = (o_min = PHRED33_ORD_MIN) and (o_max = PHRED33_ORD_MAX)\n        \n        # Determine if the observed range of ordinals is consistent with Phred+64.\n        # The entire sample must fall within the valid range for Phred+64.\n        is_valid_64 = (o_min = PHRED64_ORD_MIN) and (o_max = PHRED64_ORD_MAX)\n\n        # Apply the decision rule derived from the consistency checks.\n        if is_valid_33 and not is_valid_64:\n            # The data is only consistent with Phred+33.\n            decision = 33\n        elif not is_valid_33 and is_valid_64:\n            # The data is only consistent with Phred+64.\n            decision = 64\n        elif is_valid_33 and is_valid_64:\n            # The data is consistent with both. All characters fall in the\n            # overlapping ordinal range [64, 74]. The encoding is ambiguous.\n            decision = 0\n        else: # not is_valid_33 and not is_valid_64\n            # The data is inconsistent with both schemas. This case is also ambiguous\n            # or indicates invalid data; it cannot be determined.\n            decision = 0\n            \n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦正确解读了质量分数，下一步就是通过去除不可靠的碱基检出来提高数据质量。本练习将让您亲手实践一种广泛使用的方法——滑动窗口修剪。这个过程将锻炼您的算法思维，并加深您对读段层面过滤如何影响数据可靠性的理解。",
            "id": "4590261",
            "problem": "一个测序中心通过新一代测序 (NGS) 生成了五条读长，每条读长都附有逐个碱基的 Phred 质量分数。Phred 质量分数 (Phred) 的定义为 $Q = -10 \\log_{10}(p)$，其中 $p$ 是一个碱基被错误判读的概率。在 NGS 数据质量控制中，一种广泛使用且经过充分检验的启发式方法是滑动窗口修剪：从 $5'$ 端开始用一个大小为 $w$ 的固定窗口扫描读长，计算窗口内 Phred 分数的算术平均值，如果窗口的平均值低于指定的阈值，就在该窗口的起始位置修剪读长（丢弃该窗口及其所有下游碱基）。这种方法通过移除低置信度区域，提高了下游比对和变异检测的稳健性。\n\n考虑窗口大小 $w = 4$ 和平均质量阈值 $Q \\ge 20$。对于每条读长，设其质量序列为 $Q_{1}, Q_{2}, \\dots, Q_{n}$，采用基于 1 的索引。将窗口平均值定义为 $M_{i} = \\frac{1}{4}\\left(Q_{i} + Q_{i+1} + Q_{i+2} + Q_{i+3}\\right)$，其中 $i = 1, 2, \\dots, n-3$。修剪规则如下：\n- 找到满足 $M_{k}  20$ 的最小索引 $k$。如果存在这样的 $k$，则从第 $k$ 个碱基处开始修剪读长（保留第 $1$ 到第 $k-1$ 个碱基）；如果不存在这样的 $k$，则保留长度为 $n$ 的整条读长。\n\n给定以下五个质量字符串（已经是数值形式的 Phred $Q$ 单位），应用上述修剪规则，并报告每条读长在修剪后保留的碱基数。将最终结果表示为一个包含五个数字的单行矩阵（无单位），按顺序对应于读长 1 到 5。\n\n读长 $1$：$31, 30, 29, 30, 28, 27, 26, 25, 24, 23, 22, 21, 18, 17, 16, 15$\n\n读长 $2$：$25, 24, 23, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29$\n\n读长 $3$：$28, 29, 30, 31, 27, 26, 25, 24, 23, 22, 21, 20, 20, 21, 22, 23$\n\n读长 $4$：$35, 34, 10, 10, 10, 10, 10, 10, 30, 30, 30, 30, 30, 30, 30, 30$\n\n读长 $5$：$20, 20, 20, 20, 20, 19, 19, 19, 19, 18, 18, 18, 21, 22, 23, 24$\n\n无需四舍五入；报告保留碱基的精确整数长度。",
            "solution": "该问题定义明确，具有生物信息学领域的科学依据，并提供了进行计算所需的所有信息。我们的任务是将滑动窗口修剪算法应用于五个 Phred 质量分数序列。窗口大小为 $w=4$，平均质量阈值为 $20$。对于每条由其质量序列 $Q_1, Q_2, \\dots, Q_n$ 描述的读长，我们计算窗口平均值 $M_i = \\frac{1}{4}(Q_i + Q_{i+1} + Q_{i+2} + Q_{i+3})$。我们必须找到满足 $M_k  20$ 的最小索引 $k$。如果找到了这样的 $k$，则修剪该读长，保留的碱基数为 $k-1$。如果不存在这样的 $k$，则保留长度为 $n$ 的整条读长。所有读长的长度均为 $n=16$。\n\n读长 $1$：$Q^{(1)} = (31, 30, 29, 30, 28, 27, 26, 25, 24, 23, 22, 21, 18, 17, 16, 15)$。\n我们依次计算窗口平均值：\n$M_1 = \\frac{1}{4}(31+30+29+30) = \\frac{120}{4} = 30.0 \\ge 20$。\n$M_2 = \\frac{1}{4}(30+29+30+28) = \\frac{117}{4} = 29.25 \\ge 20$。\n$M_3 = \\frac{1}{4}(29+30+28+27) = \\frac{114}{4} = 28.5 \\ge 20$。\n$M_4 = \\frac{1}{4}(30+28+27+26) = \\frac{111}{4} = 27.75 \\ge 20$。\n$M_5 = \\frac{1}{4}(28+27+26+25) = \\frac{106}{4} = 26.5 \\ge 20$。\n$M_6 = \\frac{1}{4}(27+26+25+24) = \\frac{102}{4} = 25.5 \\ge 20$。\n$M_7 = \\frac{1}{4}(26+25+24+23) = \\frac{98}{4} = 24.5 \\ge 20$。\n$M_8 = \\frac{1}{4}(25+24+23+22) = \\frac{94}{4} = 23.5 \\ge 20$。\n$M_9 = \\frac{1}{4}(24+23+22+21) = \\frac{90}{4} = 22.5 \\ge 20$。\n$M_{10} = \\frac{1}{4}(23+22+21+18) = \\frac{84}{4} = 21.0 \\ge 20$。\n$M_{11} = \\frac{1}{4}(22+21+18+17) = \\frac{78}{4} = 19.5  20$。\n平均值小于 $20$ 的最小索引为 $k=11$。该读长被修剪，保留第 1 至 $k-1 = 10$ 个碱基。保留的碱基数为 $10$。\n\n读长 $2$：$Q^{(2)} = (25, 24, 23, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29)$。\n$M_1 = \\frac{1}{4}(25+24+23+15) = \\frac{87}{4} = 21.75 \\ge 20$。\n$M_2 = \\frac{1}{4}(24+23+15+16) = \\frac{78}{4} = 19.5  20$。\n最小索引为 $k=2$。该读长被修剪，保留第 1 至 $k-1=1$ 个碱基。保留的碱基数为 $1$。\n\n读长 $3$：$Q^{(3)} = (28, 29, 30, 31, 27, 26, 25, 24, 23, 22, 21, 20, 20, 21, 22, 23)$。\n$M_1 = \\frac{1}{4}(28+29+30+31) = \\frac{118}{4} = 29.5 \\ge 20$。\n$M_2 = \\frac{1}{4}(29+30+31+27) = \\frac{117}{4} = 29.25 \\ge 20$。\n$M_3 = \\frac{1}{4}(30+31+27+26) = \\frac{114}{4} = 28.5 \\ge 20$。\n...（继续此过程）...\n$M_9 = \\frac{1}{4}(23+22+21+20) = \\frac{86}{4} = 21.5 \\ge 20$。\n$M_{10} = \\frac{1}{4}(22+21+20+20) = \\frac{83}{4} = 20.75 \\ge 20$。\n$M_{11} = \\frac{1}{4}(21+20+20+21) = \\frac{82}{4} = 20.5 \\ge 20$。\n$M_{12} = \\frac{1}{4}(20+20+21+22) = \\frac{83}{4} = 20.75 \\ge 20$。\n$M_{13} = \\frac{1}{4}(20+21+22+23) = \\frac{86}{4} = 21.5 \\ge 20$。\n所有可能的窗口平均值都大于或等于 $20$。不进行修剪。保留整条读长。保留的碱基数为 $n=16$。\n\n读长 $4$：$Q^{(4)} = (35, 34, 10, 10, 10, 10, 10, 10, 30, 30, 30, 30, 30, 30, 30, 30)$。\n$M_1 = \\frac{1}{4}(35+34+10+10) = \\frac{89}{4} = 22.25 \\ge 20$。\n$M_2 = \\frac{1}{4}(34+10+10+10) = \\frac{64}{4} = 16  20$。\n最小索引为 $k=2$。该读长被修剪，保留第 1 至 $k-1=1$ 个碱基。保留的碱基数为 $1$。\n\n读长 $5$：$Q^{(5)} = (20, 20, 20, 20, 20, 19, 19, 19, 19, 18, 18, 18, 21, 22, 23, 24)$。\n$M_1 = \\frac{1}{4}(20+20+20+20) = \\frac{80}{4} = 20.0 \\ge 20$。\n$M_2 = \\frac{1}{4}(20+20+20+20) = \\frac{80}{4} = 20.0 \\ge 20$。\n$M_3 = \\frac{1}{4}(20+20+20+19) = \\frac{79}{4} = 19.75  20$。\n最小索引为 $k=3$。该读长被修剪，保留第 1 至 $k-1=2$ 个碱基。保留的碱基数为 $2$。\n\n五条读长各自保留的碱基数分别为 $10, 1, 16, 1, 2$。将这些数字整理成一个单行矩阵。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 10  1  16  1  2 \\end{pmatrix} } $$"
        },
        {
            "introduction": "修剪后的读段会被比对到参考基因组上，但并非所有比对都同样可靠。最后一个实践练习将深入探讨比对质量（MAPQ），这是一个用于过滤模糊比对的关键指标。通过从第一性原理推导一个常见的多重比对场景的MAPQ值，您将对比对工具如何量化不确定性，以及为何基于MAPQ的过滤对于高置信度的下游分析至关重要，获得更深刻的直觉。",
            "id": "4590216",
            "problem": "一条来自人类全基因组测序、长度为 $150$ 个核苷酸的单端新一代测序（NGS）读段，由一个标准的短读段比对软件进行处理。该比对软件使用基于伯努利误差假设和独立位置的碱基对数似然模型对比对进行评分。对于这条特定的读段，比对软件识别出两个基因组位点，它们具有相同的最优比对分数（相同错配和空位模式），并且都位于一个已知的、具有相同可比对性的重复区域。比对软件报告其中一个为主比对，并通过不使用额外上下文信息的平局打破（tie-breaking）机制来抑制另一个。假设比对质量值（MAPQ），如序列比对/图谱（SAM）规范中所用，表示报告的比对不正确的Phred标度后验概率。在这些假设下，首先从第一性原理出发，量化不正确比对的后验概率，然后推导出所报告主比对的隐含MAPQ值。接着，解释在典型的预处理流程中，当控制错误比对读段的预期比例时，这个值如何为下游过滤阈值的设定提供依据。将最终的数值MAPQ四舍五入至四位有效数字。将最终的MAPQ表示为无量纲量。",
            "solution": "该问题要求推导一条单端新一代测序（NGS）读段的比对质量值（MAPQ），该读段以相同的最优分数比对到两个基因组位点。问题还要求解释这个值如何为下游过滤提供信息。\n\n### 步骤1：问题验证\n\n**1.1. 提取已知条件**\n- 读段长度：$150$ 个核苷酸。\n- 同等最佳比对位点数：$2$。\n- 这些位点的比对分数：相同且最优。\n- 位点属性：位于已知的重复区域，具有相等的可比对性。\n- 比对软件行为：报告一个比对为主比对，并通过不使用额外信息的平局打破机制抑制另一个。\n- MAPQ定义：报告的比对不正确的Phred标度后验概率。\n- MAPQ公式：$MAPQ = -10 \\log_{10}(P_{\\text{incorrect}})$。\n- 要求精度：将最终数值MAPQ四舍五入至四位有效数字。\n\n**1.2. 使用提取的已知条件进行验证**\n该问题具有科学依据，描述了短读段比对中一个标准且常见的情景：一条读段以同等质量比对到基因组的多个位置（多重比对），尤其是在重复元件内。MAPQ作为比对错误的Phred标度后验概率这一概念，是广泛使用的序列比对/图谱（SAM）格式的基石。该问题设定良好，提供了一个简化但完整的场景，包含了从第一性原理推导后验概率所需的所有必要信息。语言客观，并使用了标准的生物信息学术语。前提条件没有矛盾、不切实际或不恰当之处。\n\n**1.3. 结论与行动**\n该问题有效。将提供一个合理的解答。\n\n### 步骤2：MAPQ的推导\n\n问题的核心在于使用贝叶斯框架计算正确比对的后验概率。\n\n设 $R$ 表示观测到的序列读段。设 $L_1$ 和 $L_2$ 是该读段以相同的最优分数比对到的两个不同基因组位点。我们已知，与所有其他可能位点的比对都是次优的，这意味着它们的似然值相比之下可以忽略不计。因此，我们只需要考虑 $L_1$ 和 $L_2$ 作为该读段可能的真实来源。\n\n在给定读段数据 $R$ 的条件下，读段来源于特定位点 $L_i$ 的后验概率由贝叶斯定理给出：\n$$P(L_i | R) = \\frac{P(R | L_i) P(L_i)}{\\sum_{j} P(R | L_j) P(L_j)}$$\n其中：\n- $P(L_i | R)$ 是读段来源于位点 $L_i$ 的后验概率。\n- $P(R | L_i)$ 是在读段来源于位点 $L_i$ 的条件下，观测到读段 $R$ 的似然。该项与比对分数直接相关。\n- $P(L_i)$ 是读段来源于位点 $L_i$ 的先验概率。\n\n根据问题陈述：\n1.  $L_1$ 和 $L_2$ 的比对分数相同。由于比对软件使用对数似然评分模型，相同的分数意味着相同的似然值。\n    $$P(R | L_1) = P(R | L_2)$$\n2.  两个位点具有“相等的可比对性”。在贝叶斯框架下，这被解释为读段来源于任一位点的先验概率相等。\n    $$P(L_1) = P(L_2)$$\n3.  与所有其他位点的比对被认为具有可忽略的概率。因此，贝叶斯定理分母中的求和仅限于 $L_1$ 和 $L_2$ 这两个位点。\n\n我们来计算位点 $L_1$ 的后验概率：\n$$P(L_1 | R) = \\frac{P(R | L_1) P(L_1)}{P(R | L_1) P(L_1) + P(R | L_2) P(L_2)}$$\n代入我们假设中的等式：\n$$P(L_1 | R) = \\frac{P(R | L_1) P(L_1)}{P(R | L_1) P(L_1) + P(R | L_1) P(L_1)} = \\frac{P(R | L_1) P(L_1)}{2 \\cdot P(R | L_1) P(L_1)}$$\n由于似然和先验概率均非零，我们可以消去分子和分母中的 $P(R | L_1) P(L_1)$ 项：\n$$P(L_1 | R) = \\frac{1}{2}$$\n根据对称性，位点 $L_2$ 的后验概率也是：\n$$P(L_2 | R) = \\frac{1}{2}$$\n后验概率之和为 $P(L_1 | R) + P(L_2 | R) = \\frac{1}{2} + \\frac{1}{2} = 1$，符合预期。\n\n比对软件将其中一个比对（比如，与 $L_1$ 的比对）报告为主比对。如果读段的真实来源不是 $L_1$，则报告的比对被认为是不正确的。在我们的模型中，唯一的另一种可能性是真实来源为 $L_2$。\n\n因此，报告的比对不正确的后验概率 $P_{\\text{incorrect}}$，即在给定读段数据 $R$ 的情况下，真实来源是 $L_2$ 的概率：\n$$P_{\\text{incorrect}} = P(\\text{true origin is } L_2 | R) = P(L_2 | R) = \\frac{1}{2}$$\n或者，$P_{\\text{incorrect}} = 1 - P_{\\text{correct}} = 1 - P(L_1 | R) = 1 - \\frac{1}{2} = \\frac{1}{2}$。\n\n现在，我们可以使用给定的公式计算比对质量值（MAPQ）：\n$$MAPQ = -10 \\log_{10}(P_{\\text{incorrect}})$$\n代入 $P_{\\text{incorrect}} = \\frac{1}{2}$：\n$$MAPQ = -10 \\log_{10}\\left(\\frac{1}{2}\\right)$$\n使用对数性质 $\\log(1/x) = -\\log(x)$：\n$$MAPQ = 10 \\log_{10}(2)$$\n使用数值 $\\log_{10}(2) \\approx 0.30102999...$：\n$$MAPQ \\approx 10 \\times 0.30102999 \\approx 3.0102999$$\n四舍五入至四位有效数字，我们得到：\n$$MAPQ \\approx 3.010$$\n\n### 步骤3：下游过滤阈值的动机\n\n计算出的MAPQ分数约为 $3$，这是一个非常低的值。低的MAPQ分数表示读段定位的高度不确定性。关系式 $P_{\\text{incorrect}} = 10^{-MAPQ/10}$ 量化了这种不确定性。\n- 对于 $MAPQ = 3$，$P_{\\text{incorrect}} = 10^{-3/10} = 10^{-0.3} \\approx 0.501$，这基本上是 $50\\%$ 的错误几率。\n- 作为比较，在变异检出流程中，一个常用的最低MAPQ阈值是 $20$。这对应于 $P_{\\text{incorrect}} = 10^{-20/10} = 10^{-2} = 0.01$ 的错误概率，即 $1\\%$ 的错误几率。\n- 一个更严格的阈值 $MAPQ=30$ 意味着 $P_{\\text{incorrect}} = 10^{-30/10} = 10^{-3} = 0.001$，即 $0.1\\%$ 的错误几率。\n\nMAPQ值直接反映了比对的可靠性。许多下游的基因组分析，如单核苷酸多态性（SNP）检出、结构变异检测或差异基因表达分析，都对比对错误高度敏感。一条错误比对的读段可能导致假阳性的变异检出或不正确的表达量化。\n\n通过设定一个MAPQ阈值（例如，$MAPQ \\ge 20$），生物信息学家可以过滤掉那些位置不明确的读段，就像本问题中描述的这一条。这个过程是一个关键的质量控制步骤，旨在控制用于分析的数据集中错误比对读段的预期比例。移除 $MAPQ  20$ 的读段，能有效丢弃那些错误几率大于 $1\\%$ 的比对，从而提高最终生物学结论的整体准确性和可靠性。值 $MAPQ \\approx 3$ 是一个典型的例子，它是一个分配给多重比对读段的分数，几乎所有标准的过滤方案都会丢弃这样的读段。",
            "answer": "$$\n\\boxed{3.010}\n$$"
        }
    ]
}