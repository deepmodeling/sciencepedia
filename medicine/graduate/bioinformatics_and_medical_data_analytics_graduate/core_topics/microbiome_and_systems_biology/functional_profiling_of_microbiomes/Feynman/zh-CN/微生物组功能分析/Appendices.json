{
    "hands_on_practices": [
        {
            "introduction": "在功能分析中，将原始的测序读数转化为有意义的丰度值是至关重要的一步。本练习将引导你完成一个核心的标准化流程，即计算每百万转录本 (Transcripts Per Million, TPM)，它能同时校正测序深度和基因长度带来的偏差。通过这个练习，你将亲手计算TPM值，并运用Kullback-Leibler散度来量化长度校正对功能丰度谱的真实影响，从而深刻理解为何标准化对于准确的功能解读至关重要 。",
            "id": "4565555",
            "problem": "一个来自人类肠道微生物组的宏转录组数据集使用KEGG同源（KO）特征进行了功能丰度分析。短读段经过质量过滤，并与四个具有有效序列长度（考虑了读段可比对性和剪切）的KO特征进行比对。对于一个样本，记录了以下观察到的比对数和有效长度：\n- KO-A：长度 $900$ 个碱基对（bp），比对读段数 $360$。\n- KO-B：长度 $1800$ bp，比对读段数 $540$。\n- KO-C：长度 $300$ bp，比对读段数 $120$。\n- KO-D：长度 $1500$ bp，比对读段数 $180$。\n\n假设在用于功能分析的每百万转录本（TPM）归一化中，使用了标准的长度校正和百万分比缩放：计数必须根据特征长度进行校正，以得到每千碱基的比率，然后进行缩放，使得所有特征的总和等于 $10^{6}$。\n\n从基于测序的定量的基本定义（即读段覆盖度与特征长度及其真实丰度的乘积成正比，且缩放产生一个组分度量）出发，计算这些KO特征的TPM值，并形成这四个特征的TPM组分。从观察到的计数形成原始计数组分。使用自然对数，通过计算从TPM组分到原始计数组分的Kullback–Leibler散度，来量化长度校正如何改变功能的相对丰度。\n\n将您的最终答案四舍五入到四位有效数字。将最终答案表示为一个无单位的实数。",
            "solution": "该问题是有效的。它在科学上基于从测序数据中量化功能丰度的标准生物信息学程序，问题陈述清晰，提供了所有必要信息，并且表述客观。\n\n任务是为一组四个KEGG同源（KO）特征计算从每百万转录本（TPM）归一化组分到原始计数组分的Kullback-Leibler（KL）散度。设特征集由 $i \\in \\{A, B, C, D\\}$ 索引。\n\n提供的数据如下：\n- KO-A ($i=A$)：原始计数 $C_A = 360$，长度 $L_A = 900$ bp。\n- KO-B ($i=B$)：原始计数 $C_B = 540$，长度 $L_B = 1800$ bp。\n- KO-C ($i=C$)：原始计数 $C_C = 120$，长度 $L_C = 300$ bp。\n- KO-D ($i=D$)：原始计数 $C_D = 180$，长度 $L_D = 1500$ bp。\n\n首先，我们计算原始计数组分，我们将其表示为概率分布 $P = \\{p_i\\}$。这是通过将每个特征的计数除以比对上的总读段数得到的。\n总读段数为：\n$$N = \\sum_{i \\in \\{A,B,C,D\\}} C_i = 360 + 540 + 120 + 180 = 1200$$\n比例 $p_i = \\frac{C_i}{N}$ 为：\n$$p_A = \\frac{360}{1200} = \\frac{3}{10} = 0.30$$\n$$p_B = \\frac{540}{1200} = \\frac{9}{20} = 0.45$$\n$$p_C = \\frac{120}{1200} = \\frac{1}{10} = 0.10$$\n$$p_D = \\frac{180}{1200} = \\frac{3}{20} = 0.15$$\n集合 $P = \\{0.30, 0.45, 0.10, 0.15\\}$ 构成了原始计数组分分布。\n\n接下来，我们计算TPM组分，表示为概率分布 $Q = \\{q_i\\}$。TPM的计算包括两个步骤：长度归一化和文库大小缩放。\n首先，我们将原始计数 $C_i$ 按以千碱基为单位的特征长度 $L_{i,kb} = L_i / 1000$ 进行归一化。这给出了一个比率 $R_i$。\n$$L_{A,kb} = \\frac{900}{1000} = 0.9 \\, \\text{kb}$$\n$$L_{B,kb} = \\frac{1800}{1000} = 1.8 \\, \\text{kb}$$\n$$L_{C,kb} = \\frac{300}{1000} = 0.3 \\, \\text{kb}$$\n$$L_{D,kb} = \\frac{1500}{1000} = 1.5 \\, \\text{kb}$$\n比率 $R_i = \\frac{C_i}{L_{i,kb}}$ 为：\n$$R_A = \\frac{360}{0.9} = 400$$\n$$R_B = \\frac{540}{1.8} = 300$$\n$$R_C = \\frac{120}{0.3} = 400$$\n$$R_D = \\frac{180}{1.5} = 120$$\n\n其次，将这些比率进行缩放，使其总和为一个常数（对于TPM通常是 $10^6$）。TPM组分是经过此长度归一化后每个特征的相对比例。缩放常数 $10^6$ 对于组分本身是无关紧要的，因为它会被约掉。组分比例 $q_i$ 是通过将每个比率 $R_i$ 除以所有比率的总和得到的。\n比率的总和是：\n$$S = \\sum_{i \\in \\{A,B,C,D\\}} R_i = 400 + 300 + 400 + 120 = 1220$$\n比例 $q_i = \\frac{R_i}{S}$ 为：\n$$q_A = \\frac{400}{1220} = \\frac{20}{61}$$\n$$q_B = \\frac{300}{1220} = \\frac{15}{61}$$\n$$q_C = \\frac{400}{1220} = \\frac{20}{61}$$\n$$q_D = \\frac{120}{1220} = \\frac{6}{61}$$\n集合 $Q = \\{\\frac{20}{61}, \\frac{15}{61}, \\frac{20}{61}, \\frac{6}{61}\\}$ 构成了TPM组分分布。\n\n最后，我们按照规定使用自然对数计算从TPM组分（$Q$）到原始计数组分（$P$）的Kullback-Leibler散度，记为 $D_{KL}(Q || P)$。\nKL散度的公式是：\n$$D_{KL}(Q || P) = \\sum_{i \\in \\{A,B,C,D\\}} q_i \\ln\\left(\\frac{q_i}{p_i}\\right)$$\n代入计算出的 $p_i$ 和 $q_i$ 的值：\n$$D_{KL}(Q || P) = \\frac{20}{61} \\ln\\left(\\frac{20/61}{0.30}\\right) + \\frac{15}{61} \\ln\\left(\\frac{15/61}{0.45}\\right) + \\frac{20}{61} \\ln\\left(\\frac{20/61}{0.10}\\right) + \\frac{6}{61} \\ln\\left(\\frac{6/61}{0.15}\\right)$$\n$$D_{KL}(Q || P) = \\frac{20}{61} \\ln\\left(\\frac{20/61}{3/10}\\right) + \\frac{15}{61} \\ln\\left(\\frac{15/61}{9/20}\\right) + \\frac{20}{61} \\ln\\left(\\frac{20/61}{1/10}\\right) + \\frac{6}{61} \\ln\\left(\\frac{6/61}{3/20}\\right)$$\n$$D_{KL}(Q || P) = \\frac{20}{61} \\ln\\left(\\frac{200}{183}\\right) + \\frac{15}{61} \\ln\\left(\\frac{300}{549}\\right) + \\frac{20}{61} \\ln\\left(\\frac{200}{61}\\right) + \\frac{6}{61} \\ln\\left(\\frac{120}{183}\\right)$$\n简化对数内的分数：\n$$D_{KL}(Q || P) = \\frac{20}{61} \\ln\\left(\\frac{200}{183}\\right) + \\frac{15}{61} \\ln\\left(\\frac{100}{183}\\right) + \\frac{20}{61} \\ln\\left(\\frac{200}{61}\\right) + \\frac{6}{61} \\ln\\left(\\frac{40}{61}\\right)$$\n现在我们计算数值：\n$$D_{KL}(Q || P) \\approx \\left(\\frac{20}{61}\\right)(0.0888358) + \\left(\\frac{15}{61}\\right)(-0.6043254) + \\left(\\frac{20}{61}\\right)(1.1874253) + \\left(\\frac{6}{61}\\right)(-0.4220261)$$\n$$D_{KL}(Q || P) \\approx (0.32786885)(0.0888358) + (0.24590164)(-0.6043254) + (0.32786885)(1.1874253) + (0.09836066)(-0.4220261)$$\n$$D_{KL}(Q || P) \\approx 0.02912977 - 0.14860721 + 0.38927907 - 0.04151121$$\n$$D_{KL}(Q || P) \\approx 0.22829042$$\n将结果四舍五入到四位有效数字得到 $0.2283$。这个值量化了当从原始计数比例修正到经长度校正的比例时所获得的信息增益。",
            "answer": "$$\\boxed{0.2283}$$"
        },
        {
            "introduction": "从单个基因的功能到完整的代谢通路，我们需要一套逻辑框架来整合信息。本练习模拟了诸如HUMAnN等先进工具的核心算法，让你体验如何从基因家族的丰度推断整个代谢途径的活性。你将通过实现一个基于规则的系统来计算通路的覆盖度 (coverage) 和丰度 (abundance)，并理解逻辑操作符（AND/OR）是如何模拟酶促反应在通路中的串联和并联关系的 。",
            "id": "4565625",
            "problem": "给定一个受 HMP 统一代谢分析网络 (HUMAnN) 启发的、简化但有科学依据的建模任务。其目标是形式化地定义从测序读段衍生的 UniRef90 蛋白质家族丰度到代谢反应的映射，并计算基于模块的通路覆盖度和通路丰度。该场景的设定源于分子生物学的中心法则 (Central Dogma of Molecular Biology)，即基因编码催化反应的蛋白质家族（酶），而这些反应则聚合成模块和通路。目标是从第一性原理出发，推导出一个在基于模块的逻辑下对通路覆盖度和丰度进行评分的精确计算流程。\n\n定义一个有限的 UniRef90 家族集合 $F = \\{f_1, f_2, \\dots, f_n\\}$，其丰度值 $a_{f} \\in \\mathbb{R}_{\\ge 0}$ 为非负数，并被解释为以任意测序衍生丰度单位表示的标准化读段丰度值。定义一个有限的反应集合 $R = \\{r_1, r_2, \\dots, r_m\\}$。每个反应 $r \\in R$ 都关联一个非空集合 $M_r \\subseteq F$，该集合指明了哪些 UniRef90 家族映射到反应 $r$。一个反应 $r$ 的丰度由下式给出\n$$\nA_r = \\sum_{f \\in M_r} a_f \\, .\n$$\n给定一个非负阈值 $t \\in \\mathbb{R}_{\\ge 0}$，定义反应存在指示符\n$$\np_r = \\begin{cases}\n1  \\text{if } A_r \\ge t \\\\\n0  \\text{otherwise.}\n\\end{cases}\n$$\n\n一个模块是基于反应的逻辑表达式，它使用逻辑与 (AND) 和逻辑或 (OR) 这两个连接词构建。一个模块可以是一个叶节点反应 $r \\in R$，或一个内部节点 $X(\\cdot, \\cdot)$，其中 $X \\in \\{\\text{AND}, \\text{OR}\\}$ 且其两个子节点也是模块。一个通路 $P$ 是一个由模块组成的有序列表 $\\{m_1, m_2, \\dots, m_k\\}$。\n\n定义两个递归函数来评估模块覆盖度和模块丰度：\n1. 对于模块覆盖度，将模块 $m$ 的覆盖度 $c(m)$ 定义为\n$$\nc(m) = \\begin{cases}\n1  \\text{if } m \\text{ is a leaf reaction } r \\text{ and } p_r = 1 \\\\\n0  \\text{if } m \\text{ is a leaf reaction } r \\text{ and } p_r = 0 \\\\\n\\min\\left(c(m_{\\text{left}}), c(m_{\\text{right}})\\right)  \\text{if } m = \\text{AND}(m_{\\text{left}}, m_{\\text{right}}) \\\\\n\\max\\left(c(m_{\\text{left}}), c(m_{\\text{right}})\\right)  \\text{if } m = \\text{OR}(m_{\\text{left}}, m_{\\text{right}})\n\\end{cases}\n$$\n这将覆盖度在模块层级上推广为一个在 $[0,1]$ 区间内的连续分数：叶节点根据其是否存在贡献 $0$ 或 $1$，AND 运算通过取最小值来传播限制性的覆盖度，而 OR 运算通过取最大值来传播最佳可用覆盖度。\n\n2. 对于模块丰度，将模块 $m$ 的丰度 $b(m)$ 定义为\n$$\nb(m) = \\begin{cases}\nA_r  \\text{if } m \\text{ is a leaf reaction } r \\\\\n\\min\\left(b(m_{\\text{left}}), b(m_{\\text{right}})\\right)  \\text{if } m = \\text{AND}(m_{\\text{left}}, m_{\\text{right}}) \\\\\n\\max\\left(b(m_{\\text{left}}), b(m_{\\text{right}})\\right)  \\text{if } m = \\text{OR}(m_{\\text{left}}, m_{\\text{right}})\n\\end{cases}\n$$\n这里将 AND 算子视为瓶颈（限速步骤），而 OR 算子视为最大分支。叶节点贡献其反应丰度 $A_r$。\n\n使用瓶颈原则，通过聚合通路中各模块的得分来定义通路覆盖度和通路丰度：\n$$\nC_P = \\min_{i \\in \\{1,\\dots,k\\}} c(m_i), \\qquad B_P = \\min_{i \\in \\{1,\\dots,k\\}} b(m_i).\n$$\n$C_P$ 和 $B_P$ 均为实数值。通路覆盖度 $C_P$ 是 $[0,1]$ 范围内的一个小数（不是百分比），通路丰度 $B_P$ 的单位与 $A_r$ 的任意单位相同。\n\n对于本问题，使用以下具体的映射和通路：\n- 家族 $F = \\{\\text{U1}, \\text{U2}, \\text{U3}, \\text{U4}, \\text{U5}\\}$。\n- 反应 $R = \\{\\text{R1}, \\text{R2}, \\text{R3}, \\text{R4}, \\text{R5}, \\text{R6}\\}$，其映射关系为\n$$\nM_{\\text{R1}} = \\{\\text{U1}, \\text{U2}\\}, \\quad\nM_{\\text{R2}} = \\{\\text{U2}\\}, \\quad\nM_{\\text{R3}} = \\{\\text{U3}\\}, \\quad\nM_{\\text{R4}} = \\{\\text{U3}, \\text{U4}\\}, \\quad\nM_{\\text{R5}} = \\{\\text{U5}\\}, \\quad\nM_{\\text{R6}} = \\{\\text{U1}\\}.\n$$\n- 通路：\n  - 通路 $\\text{P\\_A}$ 有两个模块：\n    $$\n    m_1 = \\text{AND}\\left(\\text{R1}, \\, \\text{OR}(\\text{R2}, \\text{R3})\\right), \\qquad\n    m_2 = \\text{AND}\\left(\\text{R4}, \\text{R5}\\right).\n    $$\n  - 通路 $\\text{P\\_B}$ 有一个模块：\n    $$\n    m_3 = \\text{OR}\\left(\\text{AND}(\\text{R1}, \\text{R6}), \\, \\text{R3}\\right).\n    $$\n\n测试套件。对于每个测试用例，给定一个阈值 $t$ 和 $f \\in F$ 的丰度 $a_f$。计算每个反应的 $A_r$，然后是 $p_r$，接着是每个模块的 $c(m)$ 和 $b(m)$，最后计算通路 $\\text{P\\_A}$ 和 $\\text{P\\_B}$ 的 $C_P$ 和 $B_P$。测试套件包含四个用例：\n- 用例 1：阈值 $t = 0.5$，家族丰度为\n$$\na_{\\text{U1}} = 0.8,\\; a_{\\text{U2}} = 0.4,\\; a_{\\text{U3}} = 0.9,\\; a_{\\text{U4}} = 0.3,\\; a_{\\text{U5}} = 0.5.\n$$\n- 用例 2：阈值 $t = 0.7$，家族丰度为\n$$\na_{\\text{U1}} = 0.7,\\; a_{\\text{U2}} = 0.0,\\; a_{\\text{U3}} = 0.7,\\; a_{\\text{U4}} = 0.0,\\; a_{\\text{U5}} = 0.7.\n$$\n- 用例 3：阈值 $t = 0.0$，家族丰度为\n$$\na_{\\text{U1}} = 0.0,\\; a_{\\text{U2}} = 0.0,\\; a_{\\text{U3}} = 0.0,\\; a_{\\text{U4}} = 0.0,\\; a_{\\text{U5}} = 0.0.\n$$\n- 用例 4：阈值 $t = 0.6$，家族丰度为\n$$\na_{\\text{U1}} = 0.4,\\; a_{\\text{U2}} = 0.3,\\; a_{\\text{U3}} = 0.55,\\; a_{\\text{U4}} = 0.1,\\; a_{\\text{U5}} = 0.0.\n$$\n\n你的程序必须精确实现这些定义，并生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，输出一个包含两个列表的列表：第一个内部列表包含 $[C_{\\text{P\\_A}}, B_{\\text{P\\_A}}]$，第二个内部列表包含 $[C_{\\text{P\\_B}}, B_{\\text{P\\_B}}]$。所有值都必须是实数。因此，最终的输出格式为\n$$\n\\left[ \\left[ [C_{\\text{P\\_A}}^{(1)}, B_{\\text{P\\_A}}^{(1)}], [C_{\\text{P\\_B}}^{(1)}, B_{\\text{P\\_B}}^{(1)}] \\right], \\dots, \\left[ [C_{\\text{P\\_A}}^{(4)}, B_{\\text{P\\_A}}^{(4)}], [C_{\\text{P\\_B}}^{(4)}, B_{\\text{P\\_B}}^{(4)}] \\right] \\right]\n$$\n其中上标表示从 1 到 4 的测试用例索引。不应打印任何其他文本。",
            "solution": "问题陈述提供了一个形式化的定量模型，用于从基因家族丰度推导通路级功能谱，这是微生物组代谢重建中的一个核心概念。该模型具有科学依据，在数学上是适定的，并且其所有组成部分都有明确的定义。该问题是有效的。\n\n解决方案的流程是首先实现所定义的数学规则，然后将其应用于所提供的测试用例。该过程分为四个主要的计算步骤。\n\n1.  **反应丰度 ($A_r$) 的计算**：每个反应 $r$ 的丰度是催化该反应的所有 UniRef90 蛋白质家族 $f$ 的丰度之和。这基于给定的映射 $M_r \\subseteq F$，其中 $F$ 是家族集合。计算公式为：\n    $$\n    A_r = \\sum_{f \\in M_r} a_f\n    $$\n    其中 $a_f$ 是家族 $f$ 的丰度。\n\n2.  **反应存在性 ($p_r$) 的确定**：如果一个反应 $r$ 计算出的丰度 $A_r$ 达到或超过指定的阈值 $t \\in \\mathbb{R}_{\\ge 0}$，则该反应被认为是“存在的”或“活跃的”。这由一个二元指示变量 $p_r$ 来表示：\n    $$\n    p_r = \\begin{cases}\n    1  \\text{if } A_r \\ge t \\\\\n    0  \\text{if } A_r  t\n    \\end{cases}\n    $$\n    $p_r$ 的值是模块覆盖度计算的基础。\n\n3.  **模块指标 ($c(m)$ 和 $b(m)$) 的递归评估**：一个模块 $m$ 是反应的逻辑组合。其覆盖度 $c(m)$ 和丰度 $b(m)$ 通过递归计算得出。\n    -   对于一个叶模块（即单个反应 $r$），其覆盖度是其存在指示符 $p_r$，其丰度是 $A_r$。\n        $$\n        c(r) = p_r, \\qquad b(r) = A_r\n        $$\n    -   对于一个复合模块，评估取决于逻辑连接词。$\\text{AND}$ 算子代表瓶颈，要求所有子模块都存在，因此传播最小的覆盖度和丰度。$\\text{OR}$ 算子代表替代通路，因此传播最大的覆盖度和丰度。\n        $$\n        c(\\text{AND}(m_{\\text{left}}, m_{\\text{right}})) = \\min\\left(c(m_{\\text{left}}), c(m_{\\text{right}})\\right)\n        $$\n        $$\n        b(\\text{AND}(m_{\\text{left}}, m_{\\text{right}})) = \\min\\left(b(m_{\\text{left}}), b(m_{\\text{right}})\\right)\n        $$\n        $$\n        c(\\text{OR}(m_{\\text{left}}, m_{\\text{right}})) = \\max\\left(c(m_{\\text{left}}), c(m_{\\text{right}})\\right)\n        $$\n        $$\n        b(\\text{OR}(m_{\\text{left}}, m_{\\text{right}})) = \\max\\left(b(m_{\\text{left}}), b(m_{\\text{right}})\\right)\n        $$\n\n4.  **通路得分 ($C_P$ 和 $B_P$) 的聚合**：一个通路 $P = \\{m_1, m_2, \\dots, m_k\\}$ 被视为一系列必需的模块。在通路级别应用瓶颈原则，总的通路覆盖度 $C_P$ 和丰度 $B_P$ 由其所有组成模块的最低分决定。\n    $$\n    C_P = \\min_{i \\in \\{1,\\dots,k\\}} c(m_i), \\qquad B_P = \\min_{i \\in \\{1,\\dots,k\\}} b(m_i)\n    $$\n\n为了说明，我们来执行**用例 1**的计算：\n-   **给定条件**：阈值 $t = 0.5$。家族丰度：$a_{\\text{U1}} = 0.8$, $a_{\\text{U2}} = 0.4$, $a_{\\text{U3}} = 0.9$, $a_{\\text{U4}} = 0.3$, $a_{\\text{U5}} = 0.5$。\n-   **步骤 1  2：反应指标**：\n    -   $A_{\\text{R1}} = a_{\\text{U1}} + a_{\\text{U2}} = 0.8 + 0.4 = 1.2 \\implies p_{\\text{R1}} = 1$\n    -   $A_{\\text{R2}} = a_{\\text{U2}} = 0.4 \\implies p_{\\text{R2}} = 0$\n    -   $A_{\\text{R3}} = a_{\\text{U3}} = 0.9 \\implies p_{\\text{R3}} = 1$\n    -   $A_{\\text{R4}} = a_{\\text{U3}} + a_{\\text{U4}} = 0.9 + 0.3 = 1.2 \\implies p_{\\text{R4}} = 1$\n    -   $A_{\\text{R5}} = a_{\\text{U5}} = 0.5 \\implies p_{\\text{R5}} = 1$\n    -   $A_{\\text{R6}} = a_{\\text{U1}} = 0.8 \\implies p_{\\text{R6}} = 1$\n-   **步骤 3  4：通路 $\\text{P\\_A}$**：由模块 $m_1 = \\text{AND}(\\text{R1}, \\text{OR}(\\text{R2}, \\text{R3}))$ 和 $m_2 = \\text{AND}(\\text{R4}, \\text{R5})$ 组成。\n    -   $c(m_1) = \\min(p_{\\text{R1}}, \\max(p_{\\text{R2}}, p_{\\text{R3}})) = \\min(1, \\max(0, 1)) = 1$\n    -   $b(m_1) = \\min(A_{\\text{R1}}, \\max(A_{\\text{R2}}, A_{\\text{R3}})) = \\min(1.2, \\max(0.4, 0.9)) = 0.9$\n    -   $c(m_2) = \\min(p_{\\text{R4}}, p_{\\text{R5}}) = \\min(1, 1) = 1$\n    -   $b(m_2) = \\min(A_{\\text{R4}}, A_{\\text{R5}}) = \\min(1.2, 0.5) = 0.5$\n    -   $C_{\\text{P\\_A}} = \\min(c(m_1), c(m_2)) = \\min(1, 1) = 1.0$\n    -   $B_{\\text{P\\_A}} = \\min(b(m_1), b(m_2)) = \\min(0.9, 0.5) = 0.5$\n-   **步骤 3  4：通路 $\\text{P\\_B}$**：由模块 $m_3 = \\text{OR}(\\text{AND}(\\text{R1}, \\text{R6}), \\text{R3})$ 组成。\n    -   $c(m_3) = \\max(\\min(p_{\\text{R1}}, p_{\\text{R6}}), p_{\\text{R3}}) = \\max(\\min(1, 1), 1) = 1$\n    -   $b(m_3) = \\max(\\min(A_{\\text{R1}}, A_{\\text{R6}}), A_{\\text{R3}}) = \\max(\\min(1.2, 0.8), 0.9) = \\max(0.8, 0.9) = 0.9$\n    -   $C_{\\text{P\\_B}} = c(m_3) = 1.0$\n    -   $B_{\\text{P\\_B}} = b(m_3) = 0.9$\n-   **用例 1 的结果**：对于 $\\text{P\\_A}$，$[C_{\\text{P\\_A}}, B_{\\text{P\\_A}}] = [1.0, 0.5]$。对于 $\\text{P\\_B}$，$[C_{\\text{P\\_B}}, B_{\\text{P\\_B}}] = [1.0, 0.9]$。\n\n最终的程序为所有四个测试用例实现了这一精确逻辑。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the specified model for pathway coverage and abundance calculation.\n    \"\"\"\n    \n    # Static definitions from the problem statement\n    family_names = ['U1', 'U2', 'U3', 'U4', 'U5']\n    reaction_names = ['R1', 'R2', 'R3', 'R4', 'R5', 'R6']\n    \n    reaction_mappings = {\n        'R1': ['U1', 'U2'],\n        'R2': ['U2'],\n        'R3': ['U3'],\n        'R4': ['U3', 'U4'],\n        'R5': ['U5'],\n        'R6': ['U1']\n    }\n    \n    # Module structures are represented as nested tuples: (operator, child1, child2)\n    # Leaf nodes are reaction name strings.\n    pa_modules = [\n        ('AND', 'R1', ('OR', 'R2', 'R3')),  # m1\n        ('AND', 'R4', 'R5')                 # m2\n    ]\n    pb_modules = [\n        ('OR', ('AND', 'R1', 'R6'), 'R3')   # m3\n    ]\n    \n    test_cases = [\n        {'t': 0.5, 'a': {'U1': 0.8, 'U2': 0.4, 'U3': 0.9, 'U4': 0.3, 'U5': 0.5}},\n        {'t': 0.7, 'a': {'U1': 0.7, 'U2': 0.0, 'U3': 0.7, 'U4': 0.0, 'U5': 0.7}},\n        {'t': 0.0, 'a': {'U1': 0.0, 'U2': 0.0, 'U3': 0.0, 'U4': 0.0, 'U5': 0.0}},\n        {'t': 0.6, 'a': {'U1': 0.4, 'U2': 0.3, 'U3': 0.55, 'U4': 0.1, 'U5': 0.0}},\n    ]\n    \n    all_results = []\n    \n    memo_module_eval = {}\n\n    def evaluate_module(module_struct, Ar_vals, pr_vals):\n        \"\"\"Recursively computes coverage and abundance for a module.\"\"\"\n        # Check memoization table\n        if (module_struct, tuple(sorted(Ar_vals.items())), tuple(sorted(pr_vals.items()))) in memo_module_eval:\n           return memo_module_eval[(module_struct, tuple(sorted(Ar_vals.items())), tuple(sorted(pr_vals.items())))]\n        \n        # Base case: leaf node is a reaction\n        if isinstance(module_struct, str):\n            reaction_name = module_struct\n            coverage = float(pr_vals[reaction_name])\n            abundance = Ar_vals[reaction_name]\n            return coverage, abundance\n        \n        # Recursive step for internal nodes\n        op, left_child, right_child = module_struct\n        \n        c_left, b_left = evaluate_module(left_child, Ar_vals, pr_vals)\n        c_right, b_right = evaluate_module(right_child, Ar_vals, pr_vals)\n        \n        if op == 'AND':\n            c_m = min(c_left, c_right)\n            b_m = min(b_left, b_right)\n        elif op == 'OR':\n            c_m = max(c_left, c_right)\n            b_m = max(b_left, b_right)\n        else:\n            raise ValueError(f\"Unknown operator: {op}\")\n        \n        # Store result in memoization table before returning\n        memo_module_eval[(module_struct, tuple(sorted(Ar_vals.items())), tuple(sorted(pr_vals.items())))] = (c_m, b_m)\n        return c_m, b_m\n\n    for case in test_cases:\n        t = case['t']\n        abundances = case['a']\n        \n        # Step 1: Calculate Reaction Abundances (Ar)\n        Ar = {}\n        for r_name, fam_list in reaction_mappings.items():\n            Ar[r_name] = sum(abundances[f_name] for f_name in fam_list)\n        \n        # Step 2: Calculate Reaction Presences (pr)\n        pr = {r_name: 1 if Ar[r_name] = t else 0 for r_name in reaction_names}\n        \n        # Step 3  4: Calculate Pathway Scores\n        \n        # Pathway P_A\n        pa_module_scores = [evaluate_module(m, Ar, pr) for m in pa_modules]\n        C_PA = min(score[0] for score in pa_module_scores) if pa_module_scores else 0.0\n        B_PA = min(score[1] for score in pa_module_scores) if pa_module_scores else 0.0\n        \n        # Pathway P_B\n        pb_module_scores = [evaluate_module(m, Ar, pr) for m in pb_modules]\n        C_PB = min(score[0] for score in pb_module_scores) if pb_module_scores else 0.0\n        B_PB = min(score[1] for score in pb_module_scores) if pb_module_scores else 0.0\n        \n        case_result = [\n            [float(C_PA), float(B_PA)],\n            [float(C_PB), float(B_PB)]\n        ]\n        all_results.append(case_result)\n        \n    # Final print statement in the exact required format.\n    # The default str() representation of a list of lists matches the required format.\n    print(str(all_results).replace(\"'\", '\"'))\n\nsolve()\n\n```"
        },
        {
            "introduction": "我们获得的任何功能谱的可靠性都取决于分析过程中设定的参数，例如序列比对中的期望值 (E-value) 阈值。本练习将带你进行灵敏度分析，这是一项评估分析流程稳定性的关键技能。你将量化改变E-value阈值对功能存在与否的判断及其丰度值的影响，从而学会如何评估生物信息学结论的稳健性，并确保你的发现不是特定参数选择下的偶然产物 。",
            "id": "4565606",
            "problem": "给定一个简化的数学模型，用于基于序列注释匹配（以期望值 E-value 为特征）进行微生物组的功能谱分析。在序列比对中，期望值（E-value）定义为随机匹配中得分不低于观测比对得分的预期数量；E-value 越低，表示注释的置信度越高。考虑一组映射到参考目录中功能的读段。每个读段可能有多个候选功能注释，每个注释都有一个相关的 E-value。目标是针对 E-value 截断阈值的选择进行敏感性分析，并量化结论对合理参数变化的稳健性。\n\n基本定义和假设：\n- 设读段数量为 $N$，注释的功能数量为 $F$。设 E-value 矩阵为 $E \\in \\mathbb{R}_{\\ge 0}^{N \\times F}$，其中 $E_{r,f}$ 是读段 $r$ 映射到功能 $f$ 的 E-value。\n- 对于选定的阈值 $t \\in \\mathbb{R}_{0}$，定义每个读段的候选集为 $S_r(t) = \\{ f \\in \\{1,\\dots,F\\} : E_{r,f} \\le t \\}$。\n- 在阈值 $t$ 下，每个读段将其总计为 $1$ 的丰度质量贡献给其所有通过筛选的候选功能。该质量在所有通过的候选功能中平均分配，得出贡献值为\n$$\nc_{r,f}(t) = \n\\begin{cases}\n\\frac{1}{|S_r(t)|},  \\text{if } f \\in S_r(t) \\text{ and } |S_r(t)|  0, \\\\\n0,  \\text{if } |S_r(t)| = 0 \\text{ or } f \\notin S_r(t).\n\\end{cases}\n$$\n- 在阈值 $t$ 下，功能 $f$ 的相对丰度定义为\n$$\nA_f(t) = \\frac{1}{N} \\sum_{r=1}^{N} c_{r,f}(t).\n$$\n- 给定一个最小普遍性阈值 $\\theta \\in \\mathbb{R}_{\\ge 0}$，在阈值 $t$ 下功能 $f$ 的存在性判断由指示函数给出\n$$\nP_f(t) = \\mathbb{I}\\left[ A_f(t) \\ge \\theta \\right],\n$$\n其中，如果条件为真，$\\mathbb{I}[\\cdot]$ 等于 $1$，否则等于 $0$。\n\n稳健性度量：\n- 给定一个有限的阈值集合 $T = \\{ t_1, t_2, \\dots, t_m \\}$ 和一个指定的基线阈值 $t_0 \\in T$，将存在性稳健性定义为在所有阈值下其存在性判断保持不变的功能所占的比例：\n$$\nR_{\\text{presence}} = \\frac{1}{F} \\sum_{f=1}^{F} \\mathbb{I}\\left[ \\min_{t \\in T} P_f(t) = \\max_{t \\in T} P_f(t) \\right].\n$$\n- 将丰度稳健性距离定义为相对于基线阈值，各阈值下丰度的归一化均方偏差：\n$$\nD = \\frac{1}{m F} \\sum_{t \\in T} \\sum_{f=1}^{F} \\left( A_f(t) - A_f(t_0) \\right)^2.\n$$\n较小的 $D$ 值表示丰度估计对阈值变化的稳健性更高。存在性稳健性 $R_{\\text{presence}}$ 必须以 $0$ 到 $1$ 之间的小数形式报告（不带百分号）。\n\n你的任务是实现一个程序，为提供的测试套件中的每个参数集计算 $R_{\\text{presence}}$ 和 $D$，并为每个测试用例输出一对小数值。\n\n测试套件：\n- 测试用例 1 (通用，混合置信度)：\n    - $N = 6$, $F = 3$。\n    - 读段 $r = 1,\\dots,6$ 对应功能 $f = 1,2,3$ 的 $E$ 矩阵行：\n        - $r=1$: $(1 \\times 10^{-20}, 1 \\times 10^{-8}, 1 \\times 10^{-1})$。\n        - $r=2$: $(1 \\times 10^{-3}, 1 \\times 10^{-25}, 1 \\times 10^{-2})$。\n        - $r=3$: $(1 \\times 10^{-50}, 1 \\times 10^{-6}, 2)$。\n        - $r=4$: $(5 \\times 10^{-1}, 1 \\times 10^{-7}, 1 \\times 10^{-4})$。\n        - $r=5$: $(1 \\times 10^{-9}, 10, 1 \\times 10^{-3})$。\n        - $r=6$: $(5, 8 \\times 10^{-1}, 1 \\times 10^{-6})$。\n    - 阈值集合 $T = \\{ 1 \\times 10^{-2}, 1 \\times 10^{-5}, 1 \\times 10^{-10} \\}$，基线 $t_0 = 1 \\times 10^{-5}$。\n    - 普遍性阈值 $\\theta = 2 \\times 10^{-1}$。\n- 测试用例 2 (平局与边界情况)：\n    - $N = 4$, $F = 2$。\n    - $E$ 矩阵的行：\n        - $r=1$: $(1 \\times 10^{-5}, 1 \\times 10^{-5})$。\n        - $r=2$: $(1 \\times 10^{-4}, 1 \\times 10^{-6})$。\n        - $r=3$: $(1 \\times 10^{-2}, 1 \\times 10^{-2})$。\n        - $r=4$: $(10, 10)$。\n    - 阈值集合 $T = \\{ 1 \\times 10^{-2}, 1 \\times 10^{-5} \\}$，基线 $t_0 = 1 \\times 10^{-5}$。\n    - 普遍性阈值 $\\theta = 2.5 \\times 10^{-1}$。\n- 测试用例 3 (噪声主导，稀疏真实匹配)：\n    - $N = 5$, $F = 3$。\n    - $E$ 矩阵的行：\n        - $r=1$: $(9 \\times 10^{-1}, 7 \\times 10^{-1}, 6 \\times 10^{-1})$。\n        - $r=2$: $(3 \\times 10^{-1}, 2 \\times 10^{-1}, 9 \\times 10^{-1})$。\n        - $r=3$: $(5, 4, 3)$。\n        - $r=4$: $(1 \\times 10^{-6}, 5 \\times 10^{-1}, 9 \\times 10^{-1})$。\n        - $r=5$: $(8 \\times 10^{-1}, 1 \\times 10^{-7}, 7 \\times 10^{-1})$。\n    - 阈值集合 $T = \\{ 1 \\times 10^{-2}, 1 \\times 10^{-5}, 1 \\times 10^{-7} \\}$，基线 $t_0 = 1 \\times 10^{-5}$。\n    - 普遍性阈值 $\\theta = 1 \\times 10^{-1}$。\n- 测试用例 4 (边界极端情况：宽松 vs 极严)：\n    - $N = 7$, $F = 4$。\n    - $E$ 矩阵的行：\n        - $r=1$: $(1 \\times 10^{-60}, 5 \\times 10^{-2}, 2, 1 \\times 10^{-3})$。\n        - $r=2$: $(9 \\times 10^{-1}, 1 \\times 10^{-55}, 2 \\times 10^{-2}, 5)$。\n        - $r=3$: $(5 \\times 10^{-1}, 4 \\times 10^{-1}, 3 \\times 10^{-1}, 2 \\times 10^{-1})$。\n        - $r=4$: $(1 \\times 10^{-1}, 1 \\times 10^{-2}, 1 \\times 10^{-3}, 1 \\times 10^{-4})$。\n        - $r=5$: $(50, 60, 70, 80)$。\n        - $r=6$: $(1 \\times 10^{-7}, 1 \\times 10^{-8}, 1 \\times 10^{-9}, 1 \\times 10^{-10})$。\n        - $r=7$: $(1 \\times 10^{-3}, 1 \\times 10^{-3}, 1 \\times 10^{-3}, 1 \\times 10^{-3})$。\n    - 阈值集合 $T = \\{ 1, 1 \\times 10^{-2}, 1 \\times 10^{-10}, 1 \\times 10^{-50} \\}$，基线 $t_0 = 1 \\times 10^{-10}$。\n    - 普遍性阈值 $\\theta = 1.5 \\times 10^{-1}$。\n\n最终输出格式要求：\n- 你的程序应生成一行输出，包含一个顶级列表，每个测试用例对应一个元素。每个元素是该测试用例的两个小数值 $[R_{\\text{presence}}, D]$ 组成的列表。元素必须用逗号分隔并用方括号括起来，不含任何额外文本。例如，一个有效的结构格式是 $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$，其中每个 $x_i$ 和 $y_i$ 都是按规定计算的小数。",
            "solution": "用户提供了一个用于分析微生物组功能谱分析稳健性的数学模型。任务是实现这个模型，为一组给定的测试用例计算两个度量指标：存在性稳健性 ($R_{\\text{presence}}$) 和丰度稳健性距离 ($D$)。\n\n首先，我将验证问题陈述。该问题提供了一个自洽、形式化的数学框架。所有术语，包括 E-value 矩阵 ($E$)、阈值 ($t$)、候选集 ($S_r(t)$)、贡献值 ($c_{r,f}(t)$)、丰度 ($A_f(t)$)、存在性判断 ($P_f(t)$) 以及最终的稳健性度量 ($R_{\\text{presence}}$, $D$)，都给出了精确的数学定义。该模型本身是对生物信息学中一个常见任务（即从序列数据中量化功能潜力）的简化但科学上合理的表示。所提供的测试用例是完整的，所有必要的参数（$N, F, E, T, t_0, \\theta$）都已指定。没有矛盾、歧义或违反科学原则之处。问题定义明确且计算上是可行的。因此，该问题被认定为有效。\n\n解决方案将通过为每个测试用例逐步遵循所提供的定义来实现。总体算法如下：\n\n1.  对于每个测试用例，检索参数：读段数 $N$、功能数 $F$、E-value 矩阵 $E$、阈值集合 $T$、基线阈值 $t_0$ 和普遍性阈值 $\\theta$。\n2.  遍历每个阈值 $t \\in T$ 来计算功能丰度向量 $A(t) = [A_1(t), A_2(t), \\dots, A_F(t)]$。\n    a.  对于每个阈值 $t$，首先确定每个读段的候选集 $S_r(t)$。这是通过将每个 E-value $E_{r,f}$ 与 $t$ 进行比较来完成的。如果 $E_{r,f} \\le t$，则功能 $f$ 属于读段 $r$ 的候选集 $S_r(t)$。\n    b.  对于每个读段 $r$，计算其对每个功能丰度的贡献。如果候选集 $S_r(t)$ 不为空，则每个功能 $f \\in S_r(t)$ 获得的贡献值为 $c_{r,f}(t) = 1/|S_r(t)|$。如果 $S_r(t)$ 为空或 $f \\notin S_r(t)$，则贡献为 $0$。\n    c.  在阈值 $t$ 下，功能 $f$ 的总相对丰度 $A_f(t)$ 是其来自所有读段贡献的平均值：$A_f(t) = \\frac{1}{N} \\sum_{r=1}^{N} c_{r,f}(t)$。\n3.  存储所有 $t \\in T$ 的计算出的丰度向量 $A(t)$。这可以看作是一个大小为 $m \\times F$ 的丰度矩阵，其中 $m = |T|$。\n4.  在计算完所有阈值的丰度后，计算两个稳健性度量：\n    a.  **存在性稳健性 ($R_{\\text{presence}}$)**：\n        i.  首先，计算存在性判断矩阵 $P$。对于每个功能 $f$ 和阈值 $t$，如果 $A_f(t) \\ge \\theta$，则存在性判断 $P_f(t) = 1$，否则为 $0$。\n        ii. 如果一个功能 $f$ 的存在性判断 $P_f(t)$ 在所有阈值 $t \\in T$ 上都是恒定的，则认为该功能是稳健的。这等同于检查是否 $\\min_{t \\in T} P_f(t) = \\max_{t \\in T} P_f(t)$。\n        iii. $R_{\\text{presence}}$ 是稳健功能的比例：$R_{\\text{presence}} = (\\text{稳健功能数}) / F$。\n    b.  **丰度稳健性距离 ($D$)**：\n        i.  确定与基线阈值 $t_0$ 对应的基线丰度向量 $A(t_0)$。\n        ii. 对于每个丰度向量 $A(t)$，计算与基线的平方差之和：$\\sum_{f=1}^{F} (A_f(t) - A_f(t_0))^2$。\n        iii. 将这些值在所有阈值 $t \\in T$ 上求和，并除以总数据点数 $m \\times F$ 进行归一化。最终公式为 $D = \\frac{1}{m F} \\sum_{t \\in T} \\sum_{f=1}^{F} (A_f(t) - A_f(t_0))^2$。\n5.  将每个测试用例计算出的 $R_{\\text{presence}}$ 和 $D$ 组合成一对小数值 $[R_{\\text{presence}}, D]$，并将最终输出格式化为这些对的列表。\n\n这个过程将使用 Python 和 `numpy` 库来实现，以便进行高效的数组和矩阵运算，这简化了求和与元素级操作的计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"N\": 6, \"F\": 3,\n            \"E\": [\n                [1e-20, 1e-8, 1e-1],\n                [1e-3, 1e-25, 1e-2],\n                [1e-50, 1e-6, 2],\n                [5e-1, 1e-7, 1e-4],\n                [1e-9, 10, 1e-3],\n                [5, 8e-1, 1e-6]\n            ],\n            \"T\": [1e-2, 1e-5, 1e-10],\n            \"t0\": 1e-5,\n            \"theta\": 2e-1\n        },\n        {\n            \"N\": 4, \"F\": 2,\n            \"E\": [\n                [1e-5, 1e-5],\n                [1e-4, 1e-6],\n                [1e-2, 1e-2],\n                [10, 10]\n            ],\n            \"T\": [1e-2, 1e-5],\n            \"t0\": 1e-5,\n            \"theta\": 2.5e-1\n        },\n        {\n            \"N\": 5, \"F\": 3,\n            \"E\": [\n                [9e-1, 7e-1, 6e-1],\n                [3e-1, 2e-1, 9e-1],\n                [5, 4, 3],\n                [1e-6, 5e-1, 9e-1],\n                [8e-1, 1e-7, 7e-1]\n            ],\n            \"T\": [1e-2, 1e-5, 1e-7],\n            \"t0\": 1e-5,\n            \"theta\": 1e-1\n        },\n        {\n            \"N\": 7, \"F\": 4,\n            \"E\": [\n                [1e-60, 5e-2, 2, 1e-3],\n                [9e-1, 1e-55, 2e-2, 5],\n                [5e-1, 4e-1, 3e-1, 2e-1],\n                [1e-1, 1e-2, 1e-3, 1e-4],\n                [50, 60, 70, 80],\n                [1e-7, 1e-8, 1e-9, 1e-10],\n                [1e-3, 1e-3, 1e-3, 1e-3]\n            ],\n            \"T\": [1, 1e-2, 1e-10, 1e-50],\n            \"t0\": 1e-10,\n            \"theta\": 1.5e-1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result_pair = calculate_robustness_metrics(\n            case[\"N\"], case[\"F\"], case[\"E\"], case[\"T\"], case[\"t0\"], case[\"theta\"]\n        )\n        results.append(result_pair)\n\n    # Format the final output string exactly as required.\n    str_results = \",\".join([f\"[{r[0]},{r[1]}]\" for r in results])\n    print(f\"[{str_results}]\")\n\ndef calculate_robustness_metrics(N, F, E_list, T_list, t0, theta):\n    \"\"\"\n    Solves a single test case for microbiome functional profiling robustness.\n    \"\"\"\n    E = np.array(E_list, dtype=np.float64)\n    T = np.array(T_list, dtype=np.float64)\n    m = len(T)\n    \n    all_A = np.zeros((m, F), dtype=np.float64)\n    \n    for i, t in enumerate(T):\n        hits_matrix = (E = t)\n        num_hits_per_read = hits_matrix.sum(axis=1)\n        contributions = np.zeros((N, F), dtype=np.float64)\n        \n        for r in range(N):\n            if num_hits_per_read[r]  0:\n                mass = 1.0 / num_hits_per_read[r]\n                contributions[r, hits_matrix[r]] = mass\n                \n        A_t = contributions.sum(axis=0) / N\n        all_A[i, :] = A_t\n\n    t0_idx = np.where(T == t0)[0][0]\n    A_t0 = all_A[t0_idx, :]\n\n    # Abundance Robustness Distance (D)\n    squared_diffs = (all_A - A_t0)**2\n    D = np.sum(squared_diffs) / (m * F)\n    \n    # Presence Robustness (R_presence)\n    P_matrix = (all_A = theta)\n    is_robust_per_function = P_matrix.min(axis=0) == P_matrix.max(axis=0)\n    robust_count = np.sum(is_robust_per_function)\n    R_presence = robust_count / F\n    \n    return [R_presence, D]\n\nsolve()\n```"
        }
    ]
}