{
    "hands_on_practices": [
        {
            "introduction": "在新抗原预测流程中，获得高质量的体细胞突变列表是至关重要的第一步。然而，常用的福尔马林固定石蜡包埋（FFPE）样本制备过程会引入特定的测序假象，特别是 C>T 突变，这可能导致大量假阳性候选。本练习  旨在通过建立一个基于链偏好性和序列上下文的统计过滤器，来模拟和解决这一关键的数据质量控制问题，从而提高新抗原预测的准确性。",
            "id": "4589136",
            "problem": "福尔马林固定石蜡包埋（FFPE）组织保存方法可诱导胞嘧啶脱氨，将其转化为尿嘧啶。在分子生物学的中心法则过程中，复制机制将尿嘧啶解读为胸腺嘧啶，这在经过扩增和测序后，表现为正向链上明显的胞嘧啶到胸腺嘧啶（cytosine-to-thymine）的替换，或反向链上鸟嘌呤到腺嘌呤（guanine-to-adenine）的替换。在用于新抗原预测的新一代测序（NGS）变异检测流程中，此类假象会增加表现为 C>T 或 G>A 的候选单核苷酸变异的数量。本问题要求您推导一个统计过滤器，该过滤器利用链偏向性和序列上下文来识别FFPE诱导的假象，并将假发现率控制在指定水平。\n\n从以下基本依据出发：\n\n- 化学脱氨引入的单链损伤在测序读段的不同方向上分布不均。在真实突变且无技术偏向性的原假设下，正向链与反向链上的等位基因变异观测值遵循一个对称过程。将正向链上观测到的等位基因变异计数建模为二项式随机变量 $K \\sim \\mathrm{Binomial}(n, p)$，其中 $p = 0.5$，$n$ 是两条链上观测到的等位基因变异总数，$K$ 是在正向链上观测到的数量。\n\n- 序列上下文调节脱氨的易感性。定义一个易感上下文为参考序列中紧邻鸟嘌呤3'端的胞嘧啶（CpG），或鸟嘌呤的反向互补等效形式。在真实突变发生的上下文与局部基因组组成成比例的原假设下，一个随机定位的真实突变落入易感上下文的概率等于从参考序列邻域计算出的局部易感上下文频率 $q \\in [0,1]$。\n\n您的任务：\n\n1. 对每个候选变异，在原假设 $p = 0.5$ 下，根据总共 $n$ 个等位基因变异观测值和 $k$ 个正向链等位基因变异观测值，计算链对称性的双边 p 值。使用精确二项式检验。\n\n2. 对每个候选变异，如下计算上下文易感性的单边 p 值。如果事件类型为 C>T 或 G>A，且该位点的三核苷酸参考上下文是易感的，则在原假设下观测到易感上下文的概率为 $q$；将此单次试验事件视为一次伯努利成功，并将上下文 p 值设为 $q$。如果事件类型不是 C>T 或 G>A，或者上下文不是易感的，则将上下文 p 值设为 $1$，以避免仅因上下文而错误地夸大显著性。\n\n3. 对每个变异，使用Fisher方法合并链偏向性 p 值和上下文 p 值。设 p 值为 $p_1$ 和 $p_2$。计算统计量 $$X = -2 \\sum_{i=1}^{2} \\ln(p_i),$$ 并将合并后的 p 值计算为自由度为 $2 \\times 2$ 的卡方分布的生存函数，即 $$p_{\\mathrm{comb}} = \\Pr\\left(\\chi^2_{4} \\ge X\\right).$$\n\n4. 对所有候选变异，使用Benjamini-Hochberg (BH) 程序将假发现率控制在 $\\alpha = 0.05$ 的水平。假设有 $m$ 个变异，其合并后的 p 值按升序排列为 $p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。计算校正后的 p 值 $$\\tilde{p}_{(i)} = \\min\\left\\{1, \\min_{j \\ge i} \\frac{m \\, p_{(j)}}{j}\\right\\},$$ 并将这些值映射回原始顺序。如果一个变异的BH校正 p 值满足 $\\tilde{p} \\le \\alpha$，则将其标记为假象。\n\n5. 将此实现为一个完整的程序，该程序接受以下指定的测试套件并生成所需的输出格式。\n\n测试套件规范。每个测试用例提供：\n\n- $n$：正向链和反向链上的等位基因变异总观测值。\n- $k$：正向链上的等位基因变异观测值。\n- $\\mathrm{sus}$：一个布尔值，指示在参考序列下该位点是否处于易感上下文（CpG或其反向互补等效形式）。\n- $q$：从参考序列邻域计算出的局部易感上下文频率，以小数表示。\n- $\\mathrm{type}$：观测到的替换类型，以字符串表示。\n\n按此确切顺序使用以下六个测试用例：\n\n1. $(n = 20, k = 18, \\mathrm{sus} = \\mathrm{True}, q = 0.12, \\mathrm{type} = \"C>T\")$\n2. $(n = 20, k = 10, \\mathrm{sus} = \\mathrm{True}, q = 0.12, \\mathrm{type} = \"C>T\")$\n3. $(n = 10, k = 7, \\mathrm{sus} = \\mathrm{True}, q = 0.12, \\mathrm{type} = \"C>T\")$\n4. $(n = 20, k = 18, \\mathrm{sus} = \\mathrm{False}, q = 0.12, \\mathrm{type} = \"C>T\")$\n5. $(n = 8, k = 4, \\mathrm{sus} = \\mathrm{False}, q = 0.12, \\mathrm{type} = \"C>T\")$\n6. $(n = 15, k = 14, \\mathrm{sus} = \\mathrm{True}, q = 0.05, \\mathrm{type} = \"C>T\")$\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个布尔值对应一个测试用例，指示在假发现率控制水平 $\\alpha = 0.05$ 下它是否被标记为假象。例如，如果前两个是假象而后几个不是，则输出必须严格采用 $[\\mathrm{True},\\mathrm{True},\\mathrm{False},\\mathrm{False},\\mathrm{False},\\mathrm{False}]$ 的格式。",
            "solution": "福尔马林固定石蜡包埋（FFPE）处理将脱氧核糖核酸暴露于甲醛和热量中，这可能导致胞嘧啶发生水解脱氨，转化为尿嘧啶。在聚合酶扩增过程中，尿嘧啶与胸腺嘧啶配对，导致当参考序列为胞嘧啶时出现明显的 C>T 替换，以及当参考序列在相对链上为鸟嘌呤时出现明显的 G>A 替换。由于这些损伤通常是单链的，并且在片段方向上分布不均，因此真实的生物突变不应在正向与反向的等位基因变异观测值中表现出强烈的偏向性，而FFPE假象则可能表现出显著的链不对称性。此外，由于甲基化和局部化学环境的影响，CpG上下文中的脱氨易感性更高，因此在FFPE条件下，CpG中的 C>T 更有可能是假象。\n\n基于这些现象的统计建模，可以直接得出一个基于原理的过滤器。\n\n1. 链偏向性检验。在真实突变没有方向偏好的原假设下，正向与反向链上的等位基因变异观测值遵循 $K \\sim \\mathrm{Binomial}(n, p)$，其中 $p = 0.5$，$n$ 是总的等位基因变异观测值，$k$ 是正向链上的变异观测值。通过参数 $p = 0.5$ 的精确二项式检验，可以计算出观测到至少与 $k$ 一样极端的偏差的精确双边 p 值。该检验源于伯努利试验模型，这是一个经过充分检验的、适用于独立链分配观测的概率框架。\n\n2. 上下文易感性检验。将易感上下文定义为参考序列胞嘧啶上的CpG（或鸟嘌呤的反向互补等效形式）。如果一个变异的类型是 C>T 或 G>A 并且其三核苷酸上下文是易感的，则在原假设下，将该事件视为一次单次伯努利试验，其落入易感上下文的概率等于局部基因组背景频率 $q$。观测到易感上下文的单边 p 值为 $q$，因为在单次试验伯努利模型中，一次成功或至少一次成功的概率是 $q$。如果事件不是易感的或属于不同的替换类型，则将上下文 p 值设为 $1$，以确保上下文不会在不应驱动显著性的地方驱动显著性。\n\n3. 用于合并证据的Fisher方法。为整合两条独立的证据线（链偏向性和上下文），使用Fisher方法。对于 p 值 $p_1$ 和 $p_2$，定义 $$X = -2 \\sum_{i=1}^{2} \\ln(p_i).$$ 在两个检验的原假设均为真且 p 值独立的条件下，$X$ 遵循自由度为 $2 \\times 2 = 4$ 的卡方分布。合并后的 p 值为 $$p_{\\mathrm{comb}} = \\Pr\\left(\\chi^2_{4} \\ge X\\right),$$ 即在 $X$ 处求值的生存函数。\n\n4. 通过Benjamini-Hochberg (BH) 控制假发现率。对于 $m$ 个变异，将其合并后的 p 值按升序排列 $p_{(1)} \\le \\dots \\le p_{(m)}$。BH校正 p 值为 $$\\tilde{p}_{(i)} = \\min\\left\\{1, \\min_{j \\ge i} \\frac{m \\, p_{(j)}}{j}\\right\\}.$$ 这种构造确保了校正 p 值的单调性，并在水平 $\\alpha$ 上控制了假发现的预期比例，这是多重假设检验中一个经过充分检验的程序。\n\n5. 应用于测试套件。对六个案例中的每一个，通过 $p=0.5$ 的精确二项式检验计算链偏向性 p 值。对于类型为 C>T 且位点易感的案例，将上下文 p 值设为给定的 $q$，否则设 $p_{\\mathrm{context}} = 1$。通过Fisher方法合并 p 值，为每个案例获得 $p_{\\mathrm{comb}}$。将 $m=6$ 和 $\\alpha=0.05$ 的BH程序应用于这些合并后的 p 值。\n\n用于建立直觉的说明性近似计算：\n\n- 对于 $(n = 20, k = 18)$，在 $p=0.5$ 条件下的双边二项式 p 值约为 $0.000402$。当 $q = 0.12$ 时，Fisher统计量为 $X \\approx -2(\\ln 0.000402 + \\ln 0.12) \\approx 19.874$，在 $\\chi^2_{4}$ 分布上产生的 $p_{\\mathrm{comb}}$ 约为 $10^{-3}$ 的数量级。这是存在假象的强有力证据。\n\n- 对于 $(n = 20, k = 10)$，双边二项式 p 值为 $1.0$，因为观测值与原假设完全匹配；与 $q = 0.12$ 合并后得到 $X \\approx 4.240$， $p_{\\mathrm{comb}}$ 接近 $0.374$，不显著。\n\n- 对于 $(n = 10, k = 7)$，双边二项式 p 值约为 $0.343$；与 $q = 0.12$ 合并后得到 $p_{\\mathrm{comb}}$ 接近 $0.15$，在BH校正后不显著。\n\n- 对于非易感上下文中的 $(n = 20, k = 18)$，上下文 p 值设为 $1$，因此Fisher方法仅反映链的证据；$X \\approx -2\\ln 0.000402 \\approx 15.634$ 产生的 $p_{\\mathrm{comb}}$ 约为几个 $10^{-3}$。\n\n- 对于 $(n = 8, k = 4)$，二项式 p 值为 $1.0$；当 $p_{\\mathrm{context}} = 1$ 时，$X = 0$ 且 $p_{\\mathrm{comb}} = 1.0$。\n\n- 对于 $(n = 15, k = 14)$，双边二项式 p 值约等于 $0.000976$；当 $q = 0.05$ 时，Fisher方法给出 $X \\approx 19.852$ 和一个非常小的合并 p 值。\n\n在对合并后的 p 值进行排序并应用 $m=6$ 的BH程序后，第一个、第四个和第六个案例的校正 p 值低于 $\\alpha = 0.05$，其余则没有。因此，程序应将案例1、4和6标记为假象。\n\n最终输出是包含布尔值的单行文本，按测试用例的顺序排列，指示在 $\\alpha = 0.05$ 的BH控制下的假象标记。基于以上推理，预期输出为 $[\\mathrm{True},\\mathrm{False},\\mathrm{False},\\mathrm{True},\\mathrm{False},\\mathrm{True}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import binomtest, chi2\n\ndef fisher_combined_p(p_values):\n    \"\"\"\n    Combine p-values using Fisher's method.\n    p_values: list or array of p-values (assumed independent).\n    Returns the combined p-value via chi-square survival function.\n    \"\"\"\n    p_values = np.clip(np.array(p_values, dtype=float), 1e-300, 1.0)\n    X = -2.0 * np.sum(np.log(p_values))\n    df = 2 * len(p_values)\n    return float(chi2.sf(X, df))\n\ndef benjamini_hochberg(pvals, alpha=0.05):\n    \"\"\"\n    Benjamini-Hochberg FDR control.\n    pvals: list of raw p-values.\n    alpha: FDR level.\n    Returns adjusted p-values in the original order and flags (True if adj p = alpha).\n    \"\"\"\n    m = len(pvals)\n    # Sort p-values and keep original indices\n    order = np.argsort(pvals)\n    sorted_p = np.array(pvals)[order]\n    adj = np.empty(m, dtype=float)\n    # Compute BH adjusted p-values with monotonicity\n    prev = 1.0\n    for i in range(m - 1, -1, -1):\n        rank = i + 1  # ranks are 1..m\n        val = (m * sorted_p[i]) / rank\n        prev = min(prev, val)\n        adj[i] = min(prev, 1.0)\n    # Map back to original order\n    adj_full = np.empty(m, dtype=float)\n    adj_full[order] = adj\n    flags = adj_full = alpha\n    return adj_full.tolist(), flags.tolist()\n\ndef context_p_value(is_susceptible, q_bg, mut_type):\n    \"\"\"\n    Compute one-sided context p-value.\n    If mutation type is C>T or G>A and context is susceptible, p = q_bg.\n    Otherwise, p = 1 (neutral).\n    \"\"\"\n    if mut_type in (\"C>T\", \"G>A\") and is_susceptible:\n        return float(q_bg)\n    else:\n        return 1.0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (n_total, k_forward, susceptible_context, q_bg, mutation_type)\n    test_cases = [\n        (20, 18, True, 0.12, \"C>T\"),\n        (20, 10, True, 0.12, \"C>T\"),\n        (10, 7,  True, 0.12, \"C>T\"),\n        (20, 18, False,0.12, \"C>T\"),\n        (8,  4,  False,0.12, \"C>T\"),\n        (15, 14, True, 0.05, \"C>T\"),\n    ]\n\n    combined_pvals = []\n    for n_total, k_fwd, sus, q, mtype in test_cases:\n        # Strand-bias p-value (two-sided exact binomial test with p=0.5)\n        p_strand = binomtest(k_fwd, n_total, 0.5, alternative='two-sided').pvalue\n        # Context p-value\n        p_ctx = context_p_value(sus, q, mtype)\n        # Combine using Fisher's method\n        p_comb = fisher_combined_p([p_strand, p_ctx])\n        combined_pvals.append(p_comb)\n\n    # Apply Benjamini-Hochberg at alpha=0.05\n    _, flags = benjamini_hochberg(combined_pvals, alpha=0.05)\n    \n    # Convert boolean flags to string representation as required by the problem format\n    str_flags = [str(flag) for flag in flags]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str_flags)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个真正的新抗原不仅需要源自肿瘤特异性突变，还必须被主要组织相容性复合物（MHC）有效呈递，并且其源基因在肿瘤中有足够的表达。因此，新抗原的鉴定是一个多证据整合的决策过程。本练习  将指导你设计一个多规则分类器，通过设置明确的阈值来整合基因组、转录组和预测的结合亲和力数据，从而区分真正的体细胞新抗原和种系多态性。",
            "id": "2409285",
            "problem": "给定一个基于新抗原生物学定义的正式决策问题。新抗原是一种源自体细胞突变的肽，它存在于肿瘤中但不存在于患者的生殖系中，并且能被至少一个具有足够强结合力的人类白细胞抗原 (Human Leukocyte Antigen, HLA) 分子呈递，且其来源转录本在肿瘤中表达。对于每个候选肽，您会获得肿瘤和正常样本中突变等位基因和参考等位基因的读数计数、与一个或多个 HLA 等位基因的预测结合亲和力（单位为纳摩尔），以及以每百万转录本的转录数 (Transcripts Per Million, TPM) 为单位的转录本表达。您的任务是实现一个分类器，判断每个候选肽是否符合真正新抗原的正式定义，并将其应用于一个固定的测试集。\n\n定义和符号。对于每个候选肽，您将获得分别代表肿瘤和正常样本中参考和突变读数计数的非负整数 $T_{\\mathrm{ref}}$、$T_{\\mathrm{alt}}$、$N_{\\mathrm{ref}}$、$N_{\\mathrm{alt}}$。定义肿瘤覆盖度 $T_{\\mathrm{cov}} = T_{\\mathrm{ref}} + T_{\\mathrm{alt}}$ 和正常样本覆盖度 $N_{\\mathrm{cov}} = N_{\\mathrm{ref}} + N_{\\mathrm{alt}}$。定义肿瘤变异等位基因频率 (Variant Allele Fraction, VAF) 为\n$$\n\\mathrm{VAF}_T = \n\\begin{cases}\n\\dfrac{T_{\\mathrm{alt}}}{T_{\\mathrm{ref}} + T_{\\mathrm{alt}}},  \\text{若 } T_{\\mathrm{ref}} + T_{\\mathrm{alt}}  0,\\\\\n0,  \\text{若 } T_{\\mathrm{ref}} + T_{\\mathrm{alt}} = 0,\n\\end{cases}\n$$\n定义正常样本变异等位基因频率为\n$$\n\\mathrm{VAF}_N = \n\\begin{cases}\n\\dfrac{N_{\\mathrm{alt}}}{N_{\\mathrm{ref}} + N_{\\mathrm{alt}}},  \\text{若 } N_{\\mathrm{ref}} + N_{\\mathrm{alt}}  0,\\\\\n0,  \\text{若 } N_{\\mathrm{ref}} + N_{\\mathrm{alt}} = 0.\n\\end{cases}\n$$\n设预测的结合亲和力（单位为纳摩尔）列表为 $A = [a_1, a_2, \\dots, a_m]$，其中 $m \\geq 1$；肿瘤表达为一个以每百万转录本的转录数 (Transcripts Per Million, TPM) 为单位的非负实数 $E$。\n\n分类器规范。一个候选肽被分类为真正的新抗原，当且仅当以下所有条件同时成立：\n1. 两个样本中都有足够的测序支持：$T_{\\mathrm{cov}} \\geq c_{\\min}$ 且 $N_{\\mathrm{cov}} \\geq c_{\\min}$。\n2. 体细胞突变特征，即肿瘤中富集突变等位基因且生殖系中不存在：$\\mathrm{VAF}_T \\geq \\tau_{\\mathrm{tumor}}$ 且 $\\mathrm{VAF}_N  \\tau_{\\mathrm{germ}}$。\n3. 至少一个足够强的人类白细胞抗原结合预测：$\\min(A) \\leq \\theta_{\\mathrm{bind}}$ (纳摩尔)。\n4. 足够的肿瘤表达：$E \\geq \\theta_{\\mathrm{expr}}$ (每百万转录本的转录数, TPM)。\n\n使用以下固定阈值：$c_{\\min} = 10$, $\\tau_{\\mathrm{tumor}} = 0.05$, $\\tau_{\\mathrm{germ}} = 0.20$, $\\theta_{\\mathrm{bind}} = 500$ (纳摩尔), 以及 $\\theta_{\\mathrm{expr}} = 1.0$ (每百万转录本的转录数, TPM)。除了用于结合亲和力的纳摩尔和用于表达的每百万转录本的转录数 (TPM) 外，没有其他物理单位；不涉及角度单位。所有比较都应在标准实数意义上进行解释。\n\n测试集。将您的分类器应用于以下七个候选肽。每个候选肽以元组 $(T_{\\mathrm{ref}}, T_{\\mathrm{alt}}, N_{\\mathrm{ref}}, N_{\\mathrm{alt}}, A, E)$ 的形式给出，其中 $A$ 是一个包含一个或多个实数的列表。\n\n- 候选肽 $1$: $(30, 20, 50, 0, [120.0, 720.0], 8.5)$。\n- 候选肽 $2$: $(25, 35, 30, 30, [50.0, 80.0], 12.0)$。\n- 候选肽 $3$: $(42, 18, 55, 0, [650.0, 800.0], 9.0)$。\n- 候选肽 $4$: $(15, 15, 40, 0, [100.0], 0.5)$。\n- 候选肽 $5$: $(28, 12, 5, 0, [30.0, 40.0], 10.0)$。\n- 候选肽 $6$: $(25, 25, 38, 2, [200.0, 400.0], 3.0)$。\n- 候选肽 $7$: $(50, 0, 60, 0, [5.0], 9.0)$。\n\n您的程序必须根据上述规范为每个候选肽计算分类结果，并生成单行输出。输出内容为一个用方括号括起来的、由逗号分隔的整数列表，其中 $1$ 表示“真正的新抗原”，$0$ 表示“不是真正的新抗原”。例如，三个候选肽的输出可能看起来像 $[1,0,1]$。\n\n您的实现必须是自包含的，测试集需嵌入程序中。不要求也不允许外部输入。",
            "solution": "提交分析的问题陈述被视为有效。它提出了一个生物信息学领域中形式化、自包含且有科学依据的计算任务。目标是基于一套精确的规则和一个固定的测试集，为新抗原候选肽实现一个确定性分类器。该问题是良构的，所有定义、参数和数据都已明确提供。其中不存在矛盾、歧义或违反科学原理之处。我们现在开始进行解答。\n\n将一个候选肽分类为真正的新抗原需要同时满足四个不同的标准。如果所有四个条件都满足，则候选肽被分类为 $1$（真正的新抗原），否则为 $0$。这些条件所需的参数固定如下：\n- 最小覆盖度: $c_{\\min} = 10$ reads。\n- 最小肿瘤变异等位基因频率 (VAF): $\\tau_{\\mathrm{tumor}} = 0.05$。\n- 最大生殖系 VAF: $\\tau_{\\mathrm{germ}} = 0.20$。\n- 最大结合亲和力: $\\theta_{\\mathrm{bind}} = 500$ 纳摩尔 (nM)。\n- 最小肿瘤表达: $\\theta_{\\mathrm{expr}} = 1.0$ 每百万转录本的转录数 (TPM)。\n\n这四个条件是：\n1.  **测序覆盖度**：肿瘤覆盖度 $T_{\\mathrm{cov}} = T_{\\mathrm{ref}} + T_{\\mathrm{alt}}$ 和正常样本覆盖度 $N_{\\mathrm{cov}} = N_{\\mathrm{ref}} + N_{\\mathrm{alt}}$ 必须都至少为 $c_{\\min}$。\n2.  **体细胞来源**：肿瘤 VAF $\\mathrm{VAF}_T = T_{\\mathrm{alt}} / T_{\\mathrm{cov}}$ 必须至少为 $\\tau_{\\mathrm{tumor}}$，并且正常样本 VAF $\\mathrm{VAF}_N = N_{\\mathrm{alt}} / N_{\\mathrm{cov}}$ 必须严格小于 $\\tau_{\\mathrm{germ}}$。如果覆盖度为 $0$，则 VAF 定义为 $0$。\n3.  **HLA 结合**：最小预测结合亲和力 $\\min(A)$ 必须小于或等于 $\\theta_{\\mathrm{bind}}$。\n4.  **基因表达**：来源转录本表达 $E$ 必须至少为 $\\theta_{\\mathrm{expr}}$。\n\n我们现在将这个分类逻辑系统地应用于提供的七个候选肽中的每一个。\n\n**候选肽 1**：输入为 $(T_{\\mathrm{ref}}, T_{\\mathrm{alt}}, N_{\\mathrm{ref}}, N_{\\mathrm{alt}}, A, E) = (30, 20, 50, 0, [120.0, 720.0], 8.5)$。\n1.  覆盖度: $T_{\\mathrm{cov}} = 30 + 20 = 50 \\geq 10$。$N_{\\mathrm{cov}} = 50 + 0 = 50 \\geq 10$。此条件满足。\n2.  VAF: $\\mathrm{VAF}_T = \\frac{20}{50} = 0.4 \\geq 0.05$。$\\mathrm{VAF}_N = \\frac{0}{50} = 0  0.20$。此条件满足。\n3.  结合: $\\min(A) = \\min([120.0, 720.0]) = 120.0 \\leq 500$。此条件满足。\n4.  表达: $E = 8.5 \\geq 1.0$。此条件满足。\n所有四个条件均满足。分类结果：$1$。\n\n**候选肽 2**：输入为 $(25, 35, 30, 30, [50.0, 80.0], 12.0)$。\n1.  覆盖度: $T_{\\mathrm{cov}} = 25 + 35 = 60 \\geq 10$。$N_{\\mathrm{cov}} = 30 + 30 = 60 \\geq 10$。此条件满足。\n2.  VAF: $\\mathrm{VAF}_T = \\frac{35}{60} \\approx 0.583 \\geq 0.05$。然而，$\\mathrm{VAF}_N = \\frac{30}{60} = 0.5$，不小于 $0.20$。此条件不满足。\n该候选肽因体细胞来源标准而失败，表明其可能是一个生殖系变异。\n分类结果：$0$。\n\n**候选肽 3**：输入为 $(42, 18, 55, 0, [650.0, 800.0], 9.0)$。\n1.  覆盖度: $T_{\\mathrm{cov}} = 42 + 18 = 60 \\geq 10$。$N_{\\mathrm{cov}} = 55 + 0 = 55 \\geq 10$。此条件满足。\n2.  VAF: $\\mathrm{VAF}_T = \\frac{18}{60} = 0.3 \\geq 0.05$。$\\mathrm{VAF}_N = \\frac{0}{55} = 0  0.20$。此条件满足。\n3.  结合: $\\min(A) = \\min([650.0, 800.0]) = 650.0$。该值不小于或等于 $500$。此条件不满足。\n该候选肽因预测的结合亲和力弱而失败。\n分类结果：$0$。\n\n**候选肽 4**：输入为 $(15, 15, 40, 0, [100.0], 0.5)$。\n1.  覆盖度: $T_{\\mathrm{cov}} = 15 + 15 = 30 \\geq 10$。$N_{\\mathrm{cov}} = 40 + 0 = 40 \\geq 10$。此条件满足。\n2.  VAF: $\\mathrm{VAF}_T = \\frac{15}{30} = 0.5 \\geq 0.05$。$\\mathrm{VAF}_N = \\frac{0}{40} = 0  0.20$。此条件满足。\n3.  结合: $\\min(A) = \\min([100.0]) = 100.0 \\leq 500$。此条件满足。\n4.  表达: $E = 0.5$。该值不大于或等于 $1.0$。此条件不满足。\n该候选肽因来源转录本表达不足而失败。\n分类结果：$0$。\n\n**候选肽 5**：输入为 $(28, 12, 5, 0, [30.0, 40.0], 10.0)$。\n1.  覆盖度: $T_{\\mathrm{cov}} = 28 + 12 = 40 \\geq 10$。然而，$N_{\\mathrm{cov}} = 5 + 0 = 5$，不大于或等于 $10$。此条件不满足。\n该候选肽因正常样本中测序覆盖度不足而失败。\n分类结果：$0$。\n\n**候选肽 6**：输入为 $(25, 25, 38, 2, [200.0, 400.0], 3.0)$。\n1.  覆盖度: $T_{\\mathrm{cov}} = 25 + 25 = 50 \\geq 10$。$N_{\\mathrm{cov}} = 38 + 2 = 40 \\geq 10$。此条件满足。\n2.  VAF: $\\mathrm{VAF}_T = \\frac{25}{50} = 0.5 \\geq 0.05$。$\\mathrm{VAF}_N = \\frac{2}{40} = 0.05  0.20$。此条件满足。\n3.  结合: $\\min(A) = \\min([200.0, 400.0]) = 200.0 \\leq 500$。此条件满足。\n4.  表达: $E = 3.0 \\geq 1.0$。此条件满足。\n所有四个条件均满足。\n分类结果：$1$。\n\n**候选肽 7**：输入为 $(50, 0, 60, 0, [5.0], 9.0)$。\n1.  覆盖度: $T_{\\mathrm{cov}} = 50 + 0 = 50 \\geq 10$。$N_{\\mathrm{cov}} = 60 + 0 = 60 \\geq 10$。此条件满足。\n2.  VAF: $\\mathrm{VAF}_T = \\frac{0}{50} = 0$。该值不大于或等于 $0.05$。此条件不满足。\n该候选肽因肿瘤样本中没有突变等位基因的证据而失败。\n分类结果：$0$。\n\n最终的分类向量是 $[1, 0, 0, 0, 0, 1, 0]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a classifier for neoantigens based on a formal set of criteria\n    and applies it to a fixed test suite.\n    \"\"\"\n    \n    # Define fixed thresholds as per the problem specification.\n    C_MIN = 10         # Minimum read coverage\n    TAU_TUMOR = 0.05   # Minimum tumor VAF\n    TAU_GERM = 0.20    # Maximum normal VAF\n    THETA_BIND = 500   # Maximum binding affinity in nM\n    THETA_EXPR = 1.0   # Minimum expression in TPM\n\n    # Define the test suite of candidate peptides.\n    # Each tuple is (T_ref, T_alt, N_ref, N_alt, A, E).\n    test_cases = [\n        (30, 20, 50, 0, [120.0, 720.0], 8.5),   # Candidate 1\n        (25, 35, 30, 30, [50.0, 80.0], 12.0),  # Candidate 2\n        (42, 18, 55, 0, [650.0, 800.0], 9.0),  # Candidate 3\n        (15, 15, 40, 0, [100.0], 0.5),          # Candidate 4\n        (28, 12, 5, 0, [30.0, 40.0], 10.0),    # Candidate 5\n        (25, 25, 38, 2, [200.0, 400.0], 3.0),  # Candidate 6\n        (50, 0, 60, 0, [5.0], 9.0),            # Candidate 7\n    ]\n\n    def calculate_vaf(alt_reads, ref_reads):\n        \"\"\"\n        Calculates the Variant Allele Fraction (VAF).\n        Returns 0 if total coverage is 0, as specified.\n        \"\"\"\n        coverage = alt_reads + ref_reads\n        if coverage == 0:\n            return 0.0\n        return alt_reads / coverage\n\n    results = []\n    for case in test_cases:\n        t_ref, t_alt, n_ref, n_alt, a_list, e_val = case\n        \n        # Calculate intermediate values needed for the classification logic.\n        t_cov = t_ref + t_alt\n        n_cov = n_ref + n_alt\n        vaf_t = calculate_vaf(t_alt, t_ref)\n        vaf_n = calculate_vaf(n_alt, n_ref)\n        min_binding_affinity = np.min(a_list)\n        \n        # Condition 1: Adequate sequencing support in both samples.\n        cond1 = (t_cov >= C_MIN) and (n_cov >= C_MIN)\n        \n        # Condition 2: Somatic alteration signature.\n        cond2 = (vaf_t >= TAU_TUMOR) and (vaf_n  TAU_GERM)\n        \n        # Condition 3: Sufficiently strong HLA binding prediction.\n        cond3 = min_binding_affinity = THETA_BIND\n        \n        # Condition 4: Sufficient tumor expression.\n        cond4 = e_val >= THETA_EXPR\n        \n        # A candidate is a true neoantigen if and only if all conditions hold.\n        if cond1 and cond2 and cond3 and cond4:\n            results.append(1)\n        else:\n            results.append(0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在筛选出高置信度的新抗原列表后，最终目标是设计一种能激发最强、最广免疫反应的个性化疫苗。由于疫苗的容量（例如，可编码的总氨基酸长度）有限，我们需要从众多候选肽段中进行优化选择。本练习  将一个实际的疫苗设计问题抽象为一个带约束的优化问题，你需要最大化预期免疫原性，同时考虑肽段长度预算和序列相似性带来的冗余。",
            "id": "4589173",
            "problem": "给定一组候选新生抗原肽，每个肽都标注了与免疫原性相关的特征：与I类主要组织相容性复合体 (MHC) 的结合亲和力（以纳摩尔为单位的半数抑制浓度报告，缩写为 $IC50$）、基因表达（每百万转录本数，缩写为 $TPM$）、变异等位基因频率（缩写为 $VAF$；表示为小数）以及抗原加工概率（一个在 $[0,1]$ 区间内的概率）。目标是选择一个肽的子集，以纳入基于肽的癌症疫苗中，该选择受疫苗氨基酸长度预算 $B$ 的限制，旨在最大化期望免疫原性，同时不鼓励选择序列高度相似的冗余项。问题是要求在以下数学指定的模型和约束条件下，为多个测试用例计算最优子集。\n\n基本原理和定义：\n- 分子生物学中心法则断言蛋白质表达与转录本丰度成正比；因此，较高的 $TPM$ 可以增加肽的呈递。\n- 与主要组织相容性复合体 (MHC) 的更强结合通常会增加肽呈递的可能性；较低的 $IC50$ 意味着更强的结合。\n- 免疫原性可以通过一个逻辑斯蒂链接函数 (sigmoid) 来建模，该函数作用于一个组合了多个特征的线性得分。这在生物统计学中是一种经过充分检验的用于二元结果的方法。\n- 当事件被建模为独立的伯努利随机变量时，一个集合的期望免疫原性可以近似为各个概率的总和。\n- 由序列相似性（例如，重叠的表位竞争相同的T细胞克隆）引起的冗余，可以通过一个按 $[0,1]$ 区间内的相似性得分进行缩放的成对项来惩罚。\n\n对于每个具有特征 $IC50_i$（单位纳摩尔）、$E_i$（单位 $TPM$）、$VAF_i$（$[0,1]$ 区间内的小数）和 $P_i$（$[0,1]$ 区间内的加工概率）的肽 $i$，定义线性得分为\n$$\nz_i = \\beta_0 + \\beta_{\\mathrm{aff}} \\log\\left(\\frac{500}{IC50_i}\\right) + \\beta_{\\mathrm{expr}} \\log\\left(1 + E_i\\right) + \\beta_{\\mathrm{vaf}} \\cdot VAF_i + \\beta_{\\mathrm{proc}} \\cdot P_i,\n$$\n其中 $\\log$ 是自然对数。肽 $i$ 的期望免疫原性概率则为\n$$\np_i = \\frac{1}{1 + \\exp(-z_i)}.\n$$\n给定一个对称相似性矩阵 $S$，其元素为 $s_{ij} \\in [0,1]$ 且对所有 $i$ 都有 $s_{ii} = 0$，以及一个冗余惩罚系数 $\\lambda \\ge 0$，定义目标函数，在二元选择 $x_i \\in \\{0,1\\}$ 上进行最大化：\n$$\n\\text{maximize} \\quad \\sum_{i=1}^{n} x_i p_i \\;-\\; \\lambda \\sum_{1 \\le i  j \\le n} x_i x_j s_{ij},\n$$\n该优化受以下预算约束：\n$$\n\\sum_{i=1}^{n} x_i \\cdot l_i \\le B,\n$$\n其中 $l_i$ 是肽 $i$ 的氨基酸长度，而 $B$ 是以氨基酸为单位的疫苗长度预算。\n\n决胜规则：如果多个子集达到相同的目标值（在数值公差范围内），则选择索引按升序排列时字典序最小的索引列表（例如，$[0,1]$ 优于 $[0,2]$）。\n\n模型系数（在所有测试用例中均相同）：\n- $\\beta_0 = -3.0$,\n- $\\beta_{\\mathrm{aff}} = 1.4$,\n- $\\beta_{\\mathrm{expr}} = 0.7$,\n- $\\beta_{\\mathrm{vaf}} = 0.6$,\n- $\\beta_{\\mathrm{proc}} = 1.1$.\n\n所有对数均为自然对数（以 $e$ 为底）。$IC50$ 必须以纳摩尔 (nM) 为单位。$TPM$ 和 $VAF$ 必须以小数形式提供，不带百分号。惩罚系数 $\\lambda$ 是无单位的。\n\n您的程序必须为以下每个测试用例精确求解上述优化问题。为符合科学真实性，肽的长度是典型的I类MHC结合长度，相似性值在 $[0,1]$ 内预先计算以反映序列重叠或一致性。\n\n测试套件：\n- 测试用例 1（正常路径）：\n  - 长度 $l = [9,9,10,9,10,11]$，\n  - 预算 $B = 28$，\n  - $\\lambda = 0.15$，\n  - $IC50 = [25,400,150,800,60,1200]$ (nM)，\n  - $E = [45,10,30,5,60,2]$ ($TPM$)，\n  - $VAF = [0.35,0.5,0.2,0.9,0.4,0.15]$，\n  - $P = [0.8,0.6,0.7,0.5,0.85,0.4]$，\n  - 相似性矩阵\n    $$\n    S = \\begin{bmatrix}\n    0   0.6   0.1   0.2   0.05  0.4 \\\\\n    0.6  0     0.2   0.3   0.1   0.5 \\\\\n    0.1  0.2   0     0.15  0.05  0.2 \\\\\n    0.2  0.3   0.15  0     0.3   0.1 \\\\\n    0.05 0.1   0.05  0.3   0     0.25 \\\\\n    0.4  0.5   0.2   0.1   0.25  0\n    \\end{bmatrix}.\n    $$\n- 测试用例 2（边界，零预算）：\n  - 特征与测试用例1相同，\n  - 预算 $B = 0$，\n  - $\\lambda = 0.15$。\n- 测试用例 3（冗余主导情况）：\n  - 长度 $l = [9,9,9,10,10]$，\n  - 预算 $B = 40$，\n  - $\\lambda = 0.9$，\n  - $IC50 = [30,35,1000,45,55]$ (nM)，\n  - $E = [40,42,8,38,39]$ ($TPM$)，\n  - $VAF = [0.5,0.48,0.2,0.52,0.51]$，\n  - $P = [0.85,0.83,0.4,0.8,0.82]$，\n  - 相似性矩阵\n    $$\n    S = \\begin{bmatrix}\n    0   0.9   0.15  0.2   0.2 \\\\\n    0.9  0     0.15  0.2   0.2 \\\\\n    0.15 0.15  0     0.1   0.1 \\\\\n    0.2  0.2   0.1   0     0.85 \\\\\n    0.2  0.2   0.1   0.85  0\n    \\end{bmatrix}.\n    $$\n- 测试用例 4（预算等于总长度，低相似性）：\n  - 长度 $l = [9,9,10,11]$，\n  - 预算 $B = 39$，\n  - $\\lambda = 0.05$，\n  - $IC50 = [80,90,70,85]$ (nM)，\n  - $E = [20,25,22,24]$ ($TPM$)，\n  - $VAF = [0.3,0.35,0.32,0.31]$，\n  - $P = [0.7,0.72,0.71,0.69]$，\n  - 相似性矩阵\n    $$\n    S = \\begin{bmatrix}\n    0   0.05  0.05  0.05 \\\\\n    0.05 0     0.05  0.05 \\\\\n    0.05 0.05  0     0.05 \\\\\n    0.05 0.05  0.05  0\n    \\end{bmatrix}.\n    $$\n- 测试用例 5（决胜规则检查）：\n  - 长度 $l = [9,9,9]$，\n  - 预算 $B = 18$，\n  - $\\lambda = 0.0$，\n  - $IC50 = [100,100,100]$ (nM)，\n  - $E = [15,15,15]$ ($TPM$)，\n  - $VAF = [0.3,0.3,0.3]$，\n  - $P = [0.6,0.6,0.6]$，\n  - 相似性矩阵\n    $$\n    S = \\begin{bmatrix}\n    0  0  0 \\\\\n    0  0  0 \\\\\n    0  0  0\n    \\end{bmatrix}.\n    $$\n\n要求的最终输出格式：\n- 对于每个测试用例，输出最优选择的索引，形式为按非降序排列的从零开始的索引列表（例如，$[0,2,5]$）。\n- 将所有测试用例的结果聚合成单行，形式为用方括号括起来的逗号分隔列表，其中每个用例的结果本身也用方括号括起来，且不含任何空格。例如，如果有三个测试用例，输出必须是 $[[i_1,\\dots],[j_1,\\dots],[k_1,\\dots]]$ 的形式。\n\n您的程序必须以上述描述的精确格式生成单行输出。输出中不允许包含任何其他文本。",
            "solution": "所提供的问题是一个在计算免疫学和生物信息学领域内定义明确且具有科学依据的优化任务。它要求为癌症疫苗选择一个最优的新生抗原肽子集，在遵守预算约束的同时，最大化期望免疫原性的得分并惩罚冗余。\n\n### 问题验证\n\n**结论：有效**\n\n该问题经由以下方面验证为有效：\n1.  **科学依据**：问题公式建立在免疫学和生物统计学中已确立的原则之上。所使用的特征（$IC50$、$TPM$、$VAF$、$P_i$）是新生抗原优先排序的标准度量。使用逻辑斯蒂函数从特征的线性组合中建模免疫原性概率是标准做法（逻辑斯蒂回归）。惩罚序列相似性是增加诱导免疫反应广度的合理方法。\n2.  **良态问题 (Well-Posed)**：该问题是一个0-1二次整数规划问题，这是一类已知的优化问题。目标函数和约束条件都用数学精确地指定。每个测试用例中的肽数量 $n$ 很小（最大 $n=6$），这使得通过穷举搜索解决该问题在计算上是可行的。包含决胜规则确保了唯一解的存在。\n3.  **客观和完整**：问题陈述是客观的，采用了精确的数学语言。为每个测试用例提供了所有必要的数据，包括模型系数、肽特征、长度/预算约束和相似性矩阵，使问题自成一体且可解。\n\n### 求解方法\n\n该问题可以建模为一个0-1二次背包问题 (QKP)。令 $x_i \\in \\{0,1\\}$ 为决策变量，其中如果选择肽 $i$，则 $x_i=1$，否则 $x_i=0$。任务是找到向量 $x = (x_1, \\dots, x_n)$ 来解决以下优化问题。\n\n首先，根据每个肽 $i$ 基于特征的线性得分 $z_i$ 推导出其免疫原性概率 $p_i$。\n线性得分 $z_i$ 由下式给出：\n$$\nz_i = \\beta_0 + \\beta_{\\mathrm{aff}} \\log\\left(\\frac{500}{IC50_i}\\right) + \\beta_{\\mathrm{expr}} \\log\\left(1 + E_i\\right) + \\beta_{\\mathrm{vaf}} \\cdot VAF_i + \\beta_{\\mathrm{proc}} \\cdot P_i\n$$\n然后使用标准逻辑斯蒂 (sigmoid) 函数计算免疫原性概率 $p_i$：\n$$\np_i = \\frac{1}{1 + \\exp(-z_i)}\n$$\n目标是最大化函数 $F(x)$，它代表总期望免疫原性减去冗余惩罚：\n$$\n\\text{maximize}_{x \\in \\{0,1\\}^n} \\quad F(x) = \\sum_{i=1}^{n} x_i p_i \\;-\\; \\lambda \\sum_{1 \\le i  j \\le n} x_i x_j s_{ij}\n$$\n此最大化受制于对所选肽总长度的预算约束：\n$$\n\\sum_{i=1}^{n} x_i \\cdot l_i \\le B\n$$\n鉴于每个测试用例中的肽数量 $n$ 很小（从3到6不等），可以通过对所有 $2^n$ 个可能的子集进行完全枚举来找到精确解。\n\n算法流程如下：\n1.  **概率预计算**：对于给定测试用例中的每个肽 $i$，计算并存储其免疫原性概率 $p_i$。这些值仅取决于肽自身的特征，并且在该用例的优化过程中保持不变。\n\n2.  **穷举子集搜索**：算法遍历 $n$ 个肽的所有可能子集。从 $0$ 到 $2^n-1$ 的每个整数都可用于表示一个唯一的子集，其中该整数二进制表示的第 $i$ 位对应于肽 $i$ 的选择状态。\n\n3.  **约束验证**：对于每个生成的子集，计算其肽的总长度 $\\sum x_i l_i$。如果该总和超过预算 $B$，则该子集被视为不可行，并从考虑中丢弃。\n\n4.  **目标函数评估**：对于每个可行子集，计算目标函数 $F(x)$。这包括对所有选定肽（$x_i=1$）的预计算概率 $p_i$ 求和，并减去惩罚项，该惩罚项是所有选定肽对的相似性 $s_{ij}$ 之和，再乘以系数 $\\lambda$。\n\n5.  **确定最优子集**：算法维护迄今为止找到的具有最高目标值的子集。\n    -   一个变量 `best_objective` 初始化为 $-\\infty$，一个列表 `best_subset_indices` 初始化为空。\n    -   当评估每个可行子集时，如果其目标值大于 `best_objective`（在 $10^{-9}$ 的数值公差内），则更新 `best_objective` 并将 `best_subset_indices` 替换为当前子集的索引。\n    -   如果一个子集的目标值等于 `best_objective`（在公差范围内），则调用决胜规则：将当前子集的索引列表与 `best_subset_indices` 进行字典序比较，并保留较小的一个。\n\n此过程保证根据问题的规范找到精确的最优子集。对五个测试用例中的每一个重复此过程，并将得到的索引列表聚合成最终要求的格式。",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the neoantigen selection optimization problem for multiple test cases.\n    \"\"\"\n    # Model coefficients (constant across all test cases)\n    BETA_0 = -3.0\n    BETA_AFF = 1.4\n    BETA_EXPR = 0.7\n    BETA_VAF = 0.6\n    BETA_PROC = 1.1\n    \n    # Numerical tolerance for floating point comparisons\n    TOLERANCE = 1e-9\n\n    test_cases = [\n        # Test Case 1 (happy path)\n        {\n            \"l\": [9, 9, 10, 9, 10, 11],\n            \"B\": 28,\n            \"lambda\": 0.15,\n            \"ic50\": [25, 400, 150, 800, 60, 1200],\n            \"e\": [45, 10, 30, 5, 60, 2],\n            \"vaf\": [0.35, 0.5, 0.2, 0.9, 0.4, 0.15],\n            \"p_proc\": [0.8, 0.6, 0.7, 0.5, 0.85, 0.4],\n            \"S\": np.array([\n                [0, 0.6, 0.1, 0.2, 0.05, 0.4],\n                [0.6, 0, 0.2, 0.3, 0.1, 0.5],\n                [0.1, 0.2, 0, 0.15, 0.05, 0.2],\n                [0.2, 0.3, 0.15, 0, 0.3, 0.1],\n                [0.05, 0.1, 0.05, 0.3, 0, 0.25],\n                [0.4, 0.5, 0.2, 0.1, 0.25, 0]\n            ])\n        },\n        # Test Case 2 (boundary, zero budget)\n        {\n            \"l\": [9, 9, 10, 9, 10, 11],\n            \"B\": 0,\n            \"lambda\": 0.15,\n            \"ic50\": [25, 400, 150, 800, 60, 1200],\n            \"e\": [45, 10, 30, 5, 60, 2],\n            \"vaf\": [0.35, 0.5, 0.2, 0.9, 0.4, 0.15],\n            \"p_proc\": [0.8, 0.6, 0.7, 0.5, 0.85, 0.4],\n            \"S\": np.array([\n                [0, 0.6, 0.1, 0.2, 0.05, 0.4],\n                [0.6, 0, 0.2, 0.3, 0.1, 0.5],\n                [0.1, 0.2, 0, 0.15, 0.05, 0.2],\n                [0.2, 0.3, 0.15, 0, 0.3, 0.1],\n                [0.05, 0.1, 0.05, 0.3, 0, 0.25],\n                [0.4, 0.5, 0.2, 0.1, 0.25, 0]\n            ])\n        },\n        # Test Case 3 (redundancy-dominated regime)\n        {\n            \"l\": [9, 9, 9, 10, 10],\n            \"B\": 40,\n            \"lambda\": 0.9,\n            \"ic50\": [30, 35, 1000, 45, 55],\n            \"e\": [40, 42, 8, 38, 39],\n            \"vaf\": [0.5, 0.48, 0.2, 0.52, 0.51],\n            \"p_proc\": [0.85, 0.83, 0.4, 0.8, 0.82],\n            \"S\": np.array([\n                [0, 0.9, 0.15, 0.2, 0.2],\n                [0.9, 0, 0.15, 0.2, 0.2],\n                [0.15, 0.15, 0, 0.1, 0.1],\n                [0.2, 0.2, 0.1, 0, 0.85],\n                [0.2, 0.2, 0.1, 0.85, 0]\n            ])\n        },\n        # Test Case 4 (budget equals total length, low similarity)\n        {\n            \"l\": [9, 9, 10, 11],\n            \"B\": 39,\n            \"lambda\": 0.05,\n            \"ic50\": [80, 90, 70, 85],\n            \"e\": [20, 25, 22, 24],\n            \"vaf\": [0.3, 0.35, 0.32, 0.31],\n            \"p_proc\": [0.7, 0.72, 0.71, 0.69],\n            \"S\": np.array([\n                [0, 0.05, 0.05, 0.05],\n                [0.05, 0, 0.05, 0.05],\n                [0.05, 0.05, 0, 0.05],\n                [0.05, 0.05, 0.05, 0]\n            ])\n        },\n        # Test Case 5 (tie-breaking check)\n        {\n            \"l\": [9, 9, 9],\n            \"B\": 18,\n            \"lambda\": 0.0,\n            \"ic50\": [100, 100, 100],\n            \"e\": [15, 15, 15],\n            \"vaf\": [0.3, 0.3, 0.3],\n            \"p_proc\": [0.6, 0.6, 0.6],\n            \"S\": np.array([[0,0,0],[0,0,0],[0,0,0]])\n        }\n    ]\n\n    all_results = []\n\n    for case_data in test_cases:\n        l = case_data[\"l\"]\n        B = case_data[\"B\"]\n        lam = case_data[\"lambda\"]\n        ic50 = case_data[\"ic50\"]\n        e = case_data[\"e\"]\n        vaf = case_data[\"vaf\"]\n        p_proc = case_data[\"p_proc\"]\n        S = case_data[\"S\"]\n        \n        n = len(l)\n\n        # 1. Pre-compute immunogenicity probabilities p_i\n        p_imm = np.zeros(n)\n        for i in range(n):\n            z_i = (BETA_0 +\n                   BETA_AFF * np.log(500.0 / ic50[i]) +\n                   BETA_EXPR * np.log(1.0 + e[i]) +\n                   BETA_VAF * vaf[i] +\n                   BETA_PROC * p_proc[i])\n            p_imm[i] = 1.0 / (1.0 + np.exp(-z_i))\n\n        best_objective = -np.inf\n        best_subset_indices = []\n\n        # 2. Iterate through all 2^n subsets\n        for k in range(1  n):\n            current_subset_indices = []\n            current_length = 0\n            \n            # Form subset from integer k's binary representation\n            for i in range(n):\n                if (k >> i)  1:\n                    current_subset_indices.append(i)\n                    current_length += l[i]\n\n            # 3. Check budget constraint\n            if current_length > B:\n                continue\n\n            # 4. Calculate objective value\n            objective_p_sum = sum(p_imm[i] for i in current_subset_indices)\n            \n            objective_penalty = 0.0\n            if len(current_subset_indices) > 1:\n                # Use combinations to get all unique pairs (i, j) with i  j\n                for i1, i2 in combinations(current_subset_indices, 2):\n                    objective_penalty += S[i1, i2]\n            \n            current_objective = objective_p_sum - lam * objective_penalty\n            \n            # 5. Track the best solution found\n            if current_objective > best_objective + TOLERANCE:\n                best_objective = current_objective\n                best_subset_indices = current_subset_indices\n            elif abs(current_objective - best_objective)  TOLERANCE:\n                # Tie-breaking rule: choose lexicographically smallest index list\n                if not best_subset_indices or current_subset_indices  best_subset_indices:\n                    best_subset_indices = current_subset_indices\n        \n        all_results.append(best_subset_indices)\n    \n    # Format and print the final result string\n    result_str_list = []\n    for res in all_results:\n        result_str_list.append(f'[{\",\".join(map(str, res))}]')\n    \n    # The output MUST be a single line with no leading/trailing whitespace.\n    print(f\"[{','.join(result_str_list)}]\")\n\nsolve()\n```"
        }
    ]
}