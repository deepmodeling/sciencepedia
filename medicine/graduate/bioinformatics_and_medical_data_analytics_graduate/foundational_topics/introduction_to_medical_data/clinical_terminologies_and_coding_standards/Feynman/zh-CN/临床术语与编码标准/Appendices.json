{
    "hands_on_practices": [
        {
            "introduction": "将临床编码指南（如特异性原则）转化为精确的算法，是临床信息学中的一项核心任务。本练习模拟了这一过程，要求您基于一组形式化规则（如最大化特异性、优先选择组合编码），为给定的临床文档选择最合适的ICD代码。通过这个实践，您将掌握如何将定性的编码指南转化为可计算的、确定性的逻辑，这是构建自动化编码和数据验证系统的基础。",
            "id": "4548271",
            "problem": "给定一个国际疾病分类（International Classification of Diseases, ICD）的简化、完全指定的抽象，它是一个层级术语体系，其中的编码表示为与必需的文档特征相关联的元素，并带有指示其特异性级别的属性。您必须实现一个程序，为每个文档场景选择最合适的单一ICD编码索引，并遵循关于特异性的ICD编码指南。选择过程必须纯粹以数学和逻辑术语来构建，并且不得依赖于外部文本解释。\n\n推导的基本依据：层级临床术语体系编码了定义特异性递增的父子关系；选择指南要求编码到文档所支持的最高特异性级别；当文档中记录的多个病症可由单个编码捕获时，必须优先选择组合编码。\n\n定义与形式化：\n- 设 $C = \\{c_0, c_1, \\dots, c_{n-1}\\}$ 为一个有限的编码集合。每个编码 $c_i$ 关联以下内容：\n  1. 一个必需特征集 $R(c_i) \\subseteq \\mathcal{F}$，其中 $\\mathcal{F}$ 是文档特征的全集。\n  2. 一个非负整数深度 $d(c_i) \\in \\mathbb{N}$，表示层级特异性（较大的 $d(c_i)$ 意味着较高的特异性）。\n  3. 一个布尔型未特指标志 $u(c_i) \\in \\{0,1\\}$，其中 $u(c_i) = 1$ 表示该编码包含一个未特指限定词。\n  4. 一个非负严重性权重 $s(c_i) \\in \\mathbb{R}$，提供一个与临床意义一致的次要决胜标准。\n  5. 一个索引 $i \\in \\{0,1,\\dots,n-1\\}$，指示编码在列表中的位置。\n- 设一个病例的文档表示为一个有限集合 $D \\subseteq \\mathcal{F}$。\n- 一个编码 $c_i$ 对于 $D$ 是可采纳的，当且仅当 $R(c_i) \\subseteq D$。\n- 当编码 $c_i$ 可采纳时，其相对于 $D$ 的覆盖基数是 $k(c_i, D) = |R(c_i)|$，否则无定义。\n\n源自ICD指南的选择原则：\n- 在可采纳的编码中，优先选择那些直接作为必需特征捕获了最多数量已记录病症的编码（组合编码由较大的 $|R(c_i)|$ 体现）。\n- 在这些编码中，优先选择具有最大层级特异性 $d(c_i)$ 的编码。\n- 在这些编码中，优先选择不带未特指限定词的编码，即具有最小 $u(c_i)$ 的编码。\n- 在这些编码中，优先选择具有较大临床严重性 $s(c_i)$ 的编码。\n- 如果所有标准都相同，则选择最小的索引 $i$ 以确保确定性。\n\n形式上，对于给定的文档 $D$，定义可采纳集合 $A(D) = \\{c_i \\in C \\mid R(c_i) \\subseteq D\\}$。对每个 $c_i \\in A(D)$ 定义排序元组\n$$\n\\mathbf{r}(c_i, D) = \\left(k(c_i, D), \\; d(c_i), \\; 1 - u(c_i), \\; s(c_i), \\; -i\\right)\n$$\n并选择 $c^\\ast = \\arg\\max_{c_i \\in A(D)} \\mathbf{r}(c_i, D)$，其中元组的比较采用字典序。如果 $A(D) = \\varnothing$，则选择是未定义的；对于本问题，所有测试场景都已构造为 $A(D) \\neq \\varnothing$。\n\n本问题的编码目录（每个 $c_i$ 均与其索引 $i$、文本标签、必需特征集 $R(c_i)$、深度 $d(c_i)$、未特指标志 $u(c_i)$ 和严重性 $s(c_i)$ 一同列出）：\n- $i = 0$：标签 \"E11.9\"，$R(c_0) = \\{\\text{diabetes}, \\text{type2}\\}$，$d(c_0) = 2$，$u(c_0) = 0$，$s(c_0) = 1.0$。\n- $i = 1$：标签 \"E11.40\"，$R(c_1) = \\{\\text{diabetes}, \\text{type2}, \\text{neuropathy}\\}$，$d(c_1) = 3$，$u(c_1) = 1$，$s(c_1) = 2.0$。\n- $i = 2$：标签 \"E11.42\"，$R(c_2) = \\{\\text{diabetes}, \\text{type2}, \\text{polyneuropathy}\\}$，$d(c_2) = 3$，$u(c_2) = 0$，$s(c_2) = 3.0$。\n- $i = 3$：标签 \"E10.9\"，$R(c_3) = \\{\\text{diabetes}, \\text{type1}\\}$，$d(c_3) = 2$，$u(c_3) = 0$，$s(c_3) = 1.0$。\n- $i = 4$：标签 \"S52.521A\"，$R(c_4) = \\{\\text{fracture}, \\text{radius}, \\text{left}, \\text{initial}, \\text{closed}\\}$，$d(c_4) = 4$，$u(c_4) = 0$，$s(c_4) = 2.5$。\n- $i = 5$：标签 \"S52.522A\"，$R(c_5) = \\{\\text{fracture}, \\text{radius}, \\text{right}, \\text{initial}, \\text{closed}\\}$，$d(c_5) = 4$，$u(c_5) = 0$，$s(c_5) = 2.5$。\n- $i = 6$：标签 \"S52.529A\"，$R(c_6) = \\{\\text{fracture}, \\text{radius}, \\text{initial}, \\text{closed}\\}$，$d(c_6) = 3$，$u(c_6) = 1$，$s(c_6) = 2.0$。\n- $i = 7$：标签 \"I10\"，$R(c_7) = \\{\\text{hypertension}\\}$，$d(c_7) = 2$，$u(c_7) = 0$，$s(c_7) = 1.0$。\n- $i = 8$：标签 \"I50.9\"，$R(c_8) = \\{\\text{heart\\_failure}\\}$，$d(c_8) = 2$，$u(c_8) = 1$，$s(c_8) = 2.0$。\n- $i = 9$：标签 \"I11.0\"，$R(c_9) = \\{\\text{hypertension}, \\text{heart\\_failure}\\}$，$d(c_9) = 3$，$u(c_9) = 0$，$s(c_9) = 3.5$。\n- $i = 10$：标签 \"S52.521D\"，$R(c_{10}) = \\{\\text{fracture}, \\text{radius}, \\text{left}, \\text{subsequent}\\}$，$d(c_{10}) = 4$，$u(c_{10}) = 0$，$s(c_{10}) = 2.5$。\n- $i = 11$：标签 \"S52.521A\\_open\"，$R(c_{11}) = \\{\\text{fracture}, \\text{radius}, \\text{left}, \\text{initial}, \\text{open}\\}$，$d(c_{11}) = 4$，$u(c_{11}) = 0$，$s(c_{11}) = 2.7$。\n\n测试套件：\n- 案例 1：$D_1 = \\{\\text{diabetes}, \\text{type2}, \\text{polyneuropathy}\\}$。\n- 案例 2：$D_2 = \\{\\text{fracture}, \\text{radius}, \\text{left}, \\text{initial}, \\text{closed}\\}$。\n- 案例 3：$D_3 = \\{\\text{fracture}, \\text{radius}, \\text{initial}, \\text{closed}\\}$。\n- 案例 4：$D_4 = \\{\\text{hypertension}, \\text{heart\\_failure}\\}$。\n- 案例 5：$D_5 = \\{\\text{diabetes}, \\text{type1}\\}$。\n- 案例 6：$D_6 = \\{\\text{hypertension}\\}$。\n- 案例 7：$D_7 = \\{\\text{fracture}, \\text{radius}, \\text{left}, \\text{subsequent}\\}$。\n- 案例 8：$D_8 = \\{\\text{diabetes}, \\text{type2}, \\text{neuropathy}\\}$。\n- 案例 9：$D_9 = \\{\\text{fracture}, \\text{radius}, \\text{left}, \\text{initial}, \\text{open}\\}$。\n\n您的任务：\n- 实现一个完整的、可运行的程序，该程序为每个案例 $D_j$ 计算可采纳集合 $A(D_j)$，应用上面定义的字典序排序 $\\mathbf{r}(c_i, D_j)$，并返回所选编码的索引 $i^\\ast$。\n- 所有输出都必须是整数。不涉及物理单位和角度。\n- 最终输出格式：您的程序应生成单行输出，包含以逗号分隔的结果列表，并用方括号括起来（例如，$[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_9]$）。程序必须是自包含的，且不要求任何输入。\n\n覆盖性设计：\n- 案例 1 检验在针对并发症的糖尿病编码之间的选择。\n- 案例 2 检验具有方位和就诊类型的完全特异性。\n- 案例 3 检验因缺少方位信息而回退到特异性较低的编码。\n- 案例 4 检验组合编码相对于单个独立病症编码的优先选择。\n- 案例 5 和 案例 6 检验单一病症的选择。\n- 案例 7 检验后续就诊。\n- 案例 8 对比2型糖尿病中医源性与非医源性神经病变。\n- 案例 9 在初次就诊时区分开放性与闭合性骨折。",
            "solution": "该问题要求实现一个确定性算法，根据一组文档化的特征，从给定的目录中选择最合适的临床编码。选择过程受一套形式化的、源自标准临床编码指南（主要涉及特异性和完整性）的层级规则所支配。该问题定义明确，数学上自洽，并且可用算法解决。\n\n问题的核心在于将所提供的选择原则转化为一个计算过程。我们给定一个编码目录 $C = \\{c_0, c_1, \\dots, c_{11}\\}$，其中每个编码 $c_i$ 由一个五元组属性来表征：其索引 $i$、一个必需特征集 $R(c_i)$、一个层级深度 $d(c_i)$、一个未特指标志 $u(c_i)$ 和一个严重性权重 $s(c_i)$。我们还给定了一系列文档场景，每个场景表示为一个特征集 $D_j$。\n\n对于给定的文档集 $D$，选择算法分两个主要阶段进行：筛选和排序。\n\n首先，我们识别出可采纳编码的集合，表示为 $A(D)$。一个编码 $c_i$ 被定义为可采纳的，当且仅当其所有必需特征都存在于文档中。这是一个集合论的子集条件：\n$$\nA(D) = \\{c_i \\in C \\mid R(c_i) \\subseteq D\\}\n$$\n这一步确保我们只考虑那些得到可用文档完全支持的编码。\n\n其次，对于每个可采纳的编码 $c_i \\in A(D)$，我们必须根据指定的多级标准来评估其适宜性。这些标准被封装在一个排序元组 $\\mathbf{r}(c_i, D)$ 中。问题将此元组定义为：\n$$\n\\mathbf{r}(c_i, D) = \\left( k(c_i, D), \\; d(c_i), \\; 1 - u(c_i), \\; s(c_i), \\; -i \\right)\n$$\n其中 $k(c_i, D) = |R(c_i)|$ 是覆盖基数。最优编码 $c^\\ast$ 是在字典序比较下使该元组最大化的编码。让我们按优先顺序分析元组的各个组成部分：\n\n1.  $k(c_i, D) = |R(c_i)|$：这是主要标准。最大化必需特征集的大小，会优先选择那些将多个文档化病症集于一个编码中的“组合编码”，这是一条基本指南。\n2.  $d(c_i)$：这是第二个标准，用于打破第一个标准的平局。最大化深度 $d(c_i)$ 对应于选择层级结构中最特异的编码。\n3.  $1 - u(c_i)$：这是第三个标准。未特指标志 $u(c_i)$ 对于未特指编码为 $1$，对于特指编码为 $0$。为了优先选择特指编码，我们必须最小化 $u(c_i)$。最大化转换后的值 $1 - u(c_i)$ 可实现此目的，因为 $1 - 0 = 1$ 大于 $1 - 1 = 0$。\n4.  $s(c_i)$：第四个标准是最大化严重性权重 $s(c_i)$，在之前所有标准都相等时，提供一个临床相关的决胜标准。\n5.  $-i$：这是最后的确定性决胜标准。为了在完全平局的情况下选择索引最小的编码 $i$，我们最大化值 $-i$。\n\n因此，所选编码的索引 $i^\\ast$ 由下式给出：\n$$\ni^\\ast = \\text{index of } \\arg\\max_{c_i \\in A(D)} \\mathbf{r}(c_i, D)\n$$\n\n让我们将此过程应用于案例4，其中文档为 $D_4 = \\{\\text{hypertension}, \\text{heart\\_failure}\\}$。\n\n首先，我们确定可采纳集合 $A(D_4)$。我们检查目录中的每个编码：\n- $c_7$：$R(c_7) = \\{\\text{hypertension}\\} \\subseteq D_4$。可采纳。\n- $c_8$：$R(c_8) = \\{\\text{heart\\_failure}\\} \\subseteq D_4$。可采纳。\n- $c_9$：$R(c_9) = \\{\\text{hypertension}, \\text{heart\\_failure}\\} \\subseteq D_4$。可采纳。\n所有其他编码都包含 $D_4$ 中没有的必需特征，所以 $A(D_4) = \\{c_7, c_8, c_9\\}$。\n\n接下来，我们为每个可采纳编码计算排序元组：\n- 对于 $c_7$ ($i=7$)：$k=1$，$d=2$，$u=0$，$s=1.0$。元组为 $\\mathbf{r}(c_7, D_4) = (1, 2, 1-0, 1.0, -7) = (1, 2, 1, 1.0, -7)$。\n- 对于 $c_8$ ($i=8$)：$k=1$，$d=2$，$u=1$，$s=2.0$。元组为 $\\mathbf{r}(c_8, D_4) = (1, 2, 1-1, 2.0, -8) = (1, 2, 0, 2.0, -8)$。\n- 对于 $c_9$ ($i=9$)：$k=2$，$d=3$，$u=0$，$s=3.5$。元组为 $\\mathbf{r}(c_9, D_4) = (2, 3, 1-0, 3.5, -9) = (2, 3, 1, 3.5, -9)$。\n\n最后，我们对这些元组进行字典序比较：\n- $\\mathbf{r}(c_9, D_4)$ 与 $\\mathbf{r}(c_7, D_4)$：$\\mathbf{r}(c_9, D_4)$ 的第一个分量是 $2$，而 $\\mathbf{r}(c_7, D_4)$ 的是 $1$。因为 $2 > 1$，所以 $\\mathbf{r}(c_9, D_4)$ 更大。\n- $\\mathbf{r}(c_9, D_4)$ 与 $\\mathbf{r}(c_8, D_4)$：$\\mathbf{r}(c_9, D_4)$ 的第一个分量是 $2$，而 $\\mathbf{r}(c_8, D_4)$ 的是 $1$。因为 $2 > 1$，所以 $\\mathbf{r}(c_9, D_4)$ 更大。\n\n组合编码 $c_9$ 被选中，因为其覆盖基数 $k=2$ 是最高的，这反映了它能同时捕获两个已记录病症的能力。比较在第一个标准处即停止，所选索引为 $9$。\n\n对每个测试案例实施此逻辑，以生成最终的结果序列。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ICD code selection problem by implementing the specified\n    ranking and selection algorithm.\n    \"\"\"\n    \n    # Define the code catalog as a list of dictionaries.\n    # R(c_i) is stored as a set for efficient subset checking.\n    code_catalog = [\n        {'i': 0, 'label': 'E11.9', 'R': {'diabetes', 'type2'}, 'd': 2, 'u': 0, 's': 1.0},\n        {'i': 1, 'label': 'E11.40', 'R': {'diabetes', 'type2', 'neuropathy'}, 'd': 3, 'u': 1, 's': 2.0},\n        {'i': 2, 'label': 'E11.42', 'R': {'diabetes', 'type2', 'polyneuropathy'}, 'd': 3, 'u': 0, 's': 3.0},\n        {'i': 3, 'label': 'E10.9', 'R': {'diabetes', 'type1'}, 'd': 2, 'u': 0, 's': 1.0},\n        {'i': 4, 'label': 'S52.521A', 'R': {'fracture', 'radius', 'left', 'initial', 'closed'}, 'd': 4, 'u': 0, 's': 2.5},\n        {'i': 5, 'label': 'S52.522A', 'R': {'fracture', 'radius', 'right', 'initial', 'closed'}, 'd': 4, 'u': 0, 's': 2.5},\n        {'i': 6, 'label': 'S52.529A', 'R': {'fracture', 'radius', 'initial', 'closed'}, 'd': 3, 'u': 1, 's': 2.0},\n        {'i': 7, 'label': 'I10', 'R': {'hypertension'}, 'd': 2, 'u': 0, 's': 1.0},\n        {'i': 8, 'label': 'I50.9', 'R': {'heart_failure'}, 'd': 2, 'u': 1, 's': 2.0},\n        {'i': 9, 'label': 'I11.0', 'R': {'hypertension', 'heart_failure'}, 'd': 3, 'u': 0, 's': 3.5},\n        {'i': 10, 'label': 'S52.521D', 'R': {'fracture', 'radius', 'left', 'subsequent'}, 'd': 4, 'u': 0, 's': 2.5},\n        {'i': 11, 'label': 'S52.521A_open', 'R': {'fracture', 'radius', 'left', 'initial', 'open'}, 'd': 4, 'u': 0, 's': 2.7},\n    ]\n\n    # Define the test suite documentation sets.\n    test_cases = [\n        {'diabetes', 'type2', 'polyneuropathy'}, # Case 1\n        {'fracture', 'radius', 'left', 'initial', 'closed'}, # Case 2\n        {'fracture', 'radius', 'initial', 'closed'}, # Case 3\n        {'hypertension', 'heart_failure'}, # Case 4\n        {'diabetes', 'type1'}, # Case 5\n        {'hypertension'}, # Case 6\n        {'fracture', 'radius', 'left', 'subsequent'}, # Case 7\n        {'diabetes', 'type2', 'neuropathy'}, # Case 8\n        {'fracture', 'radius', 'left', 'initial', 'open'}, # Case 9\n    ]\n\n    results = []\n    for documentation_set in test_cases:\n        admissible_codes = []\n        # Step 1: Find all admissible codes\n        for code in code_catalog:\n            if code['R'].issubset(documentation_set):\n                admissible_codes.append(code)\n\n        # Step 2: For each admissible code, compute its ranking tuple\n        ranked_candidates = []\n        for code in admissible_codes:\n            k = len(code['R'])\n            d = code['d']\n            u_transformed = 1 - code['u']\n            s = code['s']\n            neg_i = -code['i']\n            \n            ranking_tuple = (k, d, u_transformed, s, neg_i)\n            ranked_candidates.append((ranking_tuple, code['i']))\n        \n        # Step 3: Select the code with the lexicographically largest ranking tuple\n        # The max() function on a list of tuples performs this comparison automatically.\n        if ranked_candidates:\n            best_candidate = max(ranked_candidates, key=lambda item: item[0])\n            selected_index = best_candidate[1]\n            results.append(selected_index)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在临床研究和数据分析中，准确地定义患者队列（即构建“可计算表型”）至关重要。SNOMED CT的表达式约束语言（ECL）为此提供了强大的工具，它允许通过逻辑组合概念及其属性来精确描述复杂条件。这个练习将指导您如何将一个临床研究问题（例如，识别特定类型的肺部炎症，同时排除肺炎）翻译成正式的集合论查询，并计算其结果，这是从海量电子健康记录中精确提取知识的关键技能。",
            "id": "4548301",
            "problem": "一个研究团队正在设计一个可计算表型管道，该管道使用医学系统命名法—临床术语（Systematized Nomenclature of Medicine—Clinical Terms, SNOMED CT）的表达式约束语言（Expression Constraint Language, ECL）进行查询。该团队希望识别出指定了病原体的肺部炎性临床发现，并排除肺炎。该查询使用了后代或自身运算符和属性组语义。尽管为了互操作性，通常会考虑与国际疾病分类（International Classification of Diseases, ICD）、现行医疗程序术语（Current Procedural Terminology, CPT）以及逻辑观察标识符名称和代码（Logical Observation Identifiers Names and Codes, LOINC）的映射，但这些不属于本次计算的一部分。\n\n假设使用以下ECL（带有属性分组，因此大括号中的所有属性都出现在同一个角色组内）：\n```\n$$ 404684003 |Clinical finding| : { 363698007 |Finding site| = $$ 39607008 |Lung structure|, 116676008 |Associated morphology| = $$ 409774005 |Inflammatory morphology|, 246075003 |Causative agent| = ($$ 49872002 |Virus| OR $$ 410607006 |Bacteria|) } MINUS $$ 233604007 |Pneumonia|\n```\n\n根据其标准的SNOMED CT ECL语义解释这些运算符：$$ 返回包含一个概念及其所有后代的集合；属性分组要求所列属性在概念定义中至少一个共同的角色组内共现；而 MINUS 表示集合差集。\n\n现给出医院SNOMED CT模块中，关于 $404684003$ $|$Clinical finding$|$ 的后代或自身概念中满足上述指定的分组肺部和炎性属性的子集的一致计数如下：\n\n- 令 $\\mathcal{L}$ 为满足分组约束 $|$Finding site$|$ $=$ $$ $39607008$ 和 $|$Associated morphology$|$ $=$ $$ $409774005$ 的概念集合。则 $|\\mathcal{L}|$ $=$ $2600$。\n- 令 $\\mathcal{M}$ 为 $\\mathcal{L}$ 中同样具有 $|$Causative agent$|$ $=$ $$ $49872002$ $|$Virus$|$ 的子集。则 $|\\mathcal{M}|$ $=$ $900$。\n- 令 $\\mathcal{B}$ 为 $\\mathcal{L}$ 中同样具有 $|$Causative agent$|$ $=$ $$ $410607006$ $|$Bacteria$|$ 的子集。则 $|\\mathcal{B}|$ $=$ $1100$。\n- 一些概念指定了多个病原体；其交集满足 $|\\mathcal{M} \\cap \\mathcal{B}|$ $=$ $200$。\n- 令 $\\mathcal{P}$ 为集合 $$ $233604007$ $|$Pneumonia$|$。假设 $\\mathcal{P}$ 中的每个概念都在 $\\mathcal{L}$ 中（即，每个此类概念都满足分组的肺部和炎性约束）。$\\mathcal{P}$ 内的病原体计数为：$|\\mathcal{P} \\cap \\mathcal{M}|$ $=$ $400$， $|\\mathcal{P} \\cap \\mathcal{B}|$ $=$ $700$，以及 $|\\mathcal{P} \\cap \\mathcal{M} \\cap \\mathcal{B}|$ $=$ $100$。\n\n仅使用后代或自身、属性分组、集合并集、交集和差集的形式语义，确定上述ECL返回的SNOMED CT概念的确切数量。最终答案以不带单位的精确整数形式给出。",
            "solution": "该问题已经过验证，被认为是一个基于集合论形式原理和SNOMED CT结构的自洽且定义明确的问题。\n\n目标是确定给定的SNOMED CT表达式约束语言（ECL）查询返回的概念数量。我们必须首先将ECL查询转换为一个形式化的集合论表达式，然后使用所提供的数据计算结果集的基数。\n\nECL查询如下：\n`$$ 404684003 |Clinical finding| : { 363698007 |Finding site| = $$ 39607008 |Lung structure|, 116676008 |Associated morphology| = $$ 409774005 |Inflammatory morphology|, 246075003 |Causative agent| = ($$ 49872002 |Virus| OR $$ 410607006 |Bacteria|) } MINUS $$ 233604007 |Pneumonia|`\n\n让我们将此查询返回的概念集合表示为 $\\mathcal{R}$。该查询可以分解如下：\n$1$. 概念的基础集合由位于肺部结构且具有炎性特征的临床发现组成。问题将此集合定义为 $\\mathcal{L}$，其基数为 $|\\mathcal{L}| = 2600$。查询的这一部分是：`$$ 404684003 |Clinical finding| : { 363698007 |Finding site| = $$ 39607008, 116676008 |Associated morphology| = $$ 409774005 }`。\n\n$2$. 这个基础集合被病原体进一步约束。约束 `|Causative agent| = ($$ 49872002 |Virus| OR $$ 410607006 |Bacteria|)` 从 $\\mathcal{L}$ 中选择那些病原体是病毒或细菌（或两者都是）的概念。\n令 $\\mathcal{M}$ 为 $\\mathcal{L}$ 中病原体为病毒的子集。问题提供了 $|\\mathcal{M}| = 900$。\n令 $\\mathcal{B}$ 为 $\\mathcal{L}$ 中病原体为细菌的子集。问题提供了 $|\\mathcal{B}| = 1100$。\n$\\mathcal{L}$ 中满足 `OR` 条件的概念集合是这两个集合的并集，即 $\\mathcal{M} \\cup \\mathcal{B}$。\n\n$3$. `MINUS` 运算符对应于集合差集。它移除了集合 `$$ 233604007 |Pneumonia|` 的所有成员概念。该集合被表示为 $\\mathcal{P}$。\n\n结合这些部分，最终的概念集合 $\\mathcal{R}$ 由以下表达式给出：\n$$\n\\mathcal{R} = (\\mathcal{M} \\cup \\mathcal{B}) \\setminus \\mathcal{P}\n$$\n我们的目标是找到这个集合的基数 $|\\mathcal{R}|$。\n\n使用集合差集的基数公式 $|A \\setminus B| = |A| - |A \\cap B|$，我们可以写出：\n$$\n|\\mathcal{R}| = |(\\mathcal{M} \\cup \\mathcal{B})| - |(\\mathcal{M} \\cup \\mathcal{B}) \\cap \\mathcal{P}|\n$$\n\n我们将分别计算右侧的两项。\n\n首先，我们使用容斥原​​理计算 $|\\mathcal{M} \\cup \\mathcal{B}|$：\n$$\n|\\mathcal{M} \\cup \\mathcal{B}| = |\\mathcal{M}| + |\\mathcal{B}| - |\\mathcal{M} \\cap \\mathcal{B}|\n$$\n问题提供了必要的值：$|\\mathcal{M}| = 900$， $|\\mathcal{B}| = 1100$，以及 $|\\mathcal{M} \\cap \\mathcal{B}| = 200$。代入这些值：\n$$\n|\\mathcal{M} \\cup \\mathcal{B}| = 900 + 1100 - 200 = 2000 - 200 = 1800\n$$\n\n其次，我们计算 $|(\\mathcal{M} \\cup \\mathcal{B}) \\cap \\mathcal{P}|$。使用交集对并集的分配律，我们得到：\n$$\n(\\mathcal{M} \\cup \\mathcal{B}) \\cap \\mathcal{P} = (\\mathcal{M} \\cap \\mathcal{P}) \\cup (\\mathcal{B} \\cap \\mathcal{P})\n$$\n我们再次应用容斥原​​理来求这个并集的基数：\n$$\n|(\\mathcal{M} \\cap \\mathcal{P}) \\cup (\\mathcal{B} \\cap \\mathcal{P})| = |\\mathcal{M} \\cap \\mathcal{P}| + |\\mathcal{B} \\cap \\mathcal{P}| - |(\\mathcal{M} \\cap \\mathcal{P}) \\cap (\\mathcal{B} \\cap \\mathcal{P})|\n$$\n这两个集合的交集简化为 $\\mathcal{M} \\cap \\mathcal{B} \\cap \\mathcal{P}$。所以表达式变为：\n$$\n|(\\mathcal{M} \\cup \\mathcal{B}) \\cap \\mathcal{P}| = |\\mathcal{M} \\cap \\mathcal{P}| + |\\mathcal{B} \\cap \\mathcal{P}| - |\\mathcal{M} \\cap \\mathcal{B} \\cap \\mathcal{P}|\n$$\n问题提供了这些交集的值：$|\\mathcal{M} \\cap \\mathcal{P}| = 400$， $|\\mathcal{B} \\cap \\mathcal{P}| = 700$，以及 $|\\mathcal{M} \\cap \\mathcal{B} \\cap \\mathcal{P}| = 100$。代入这些值：\n$$\n|(\\mathcal{M} \\cup \\mathcal{B}) \\cap \\mathcal{P}| = 400 + 700 - 100 = 1100 - 100 = 1000\n$$\n\n最后，我们将计算出的基数代回到 $|\\mathcal{R}|$ 的表达式中：\n$$\n|\\mathcal{R}| = |\\mathcal{M} \\cup \\mathcal{B}| - |(\\mathcal{M} \\cup \\mathcal{B}) \\cap \\mathcal{P}| = 1800 - 1000 = 800\n$$\n指定的ECL查询返回的SNOMED CT概念总数为 $800$。提供的信息 $|\\mathcal{L}| = 2600$ 用于确保一致性，因为 $|\\mathcal{M} \\cup \\mathcal{B}| = 1800 \\le 2600$，但在最终计算中没有直接使用。假设 $\\mathcal{P} \\subseteq \\mathcal{L}$ 也确保了模型的逻辑连贯性，因为从 $\\mathcal{P}$ 中减去概念是有意义的，因为它们是 $\\mathcal{M}$ 和 $\\mathcal{B}$ 所源自的同一个超集 $\\mathcal{L}$ 的一部分。",
            "answer": "$$\\boxed{800}$$"
        },
        {
            "introduction": "超越了简单地分配或查询代码，理解代码之间的语义关系是更高级分析的基石。例如，量化“流感”和“肺炎”这两种诊断的相似程度，对于患者分层、临床试验匹配和知识发现等应用至关重要。本练习  介绍了基于信息论和图论的标准方法来计算概念间的语义相似度与距离，使您能够对临床术语进行定量推理。",
            "id": "4548273",
            "problem": "实现一个程序，用于在一个模仿医学临床术语系统命名法 (Systematized Nomenclature of Medicine Clinical Terms, SNOMED CT) 的小型、固定概念层次结构中，计算临床概念对的基于原则的语义相似度和基于分类法的度量指标。目标是根据概率和信息量的基本定义以及分类法的图论属性来推导这些度量指标，而不依赖任何外部资源。\n\n基本依据和必要的推导：\n- 使用基于语料库频率的概率定义：对于一个概念 $c$，令 $f(c)$ 表示其传播频率，该频率通过对以 $c$ 为根的子树中所有叶节点注解的计数求和得到。令 $N$ 为语料库中叶节点注解的总数。$c$ 的经验概率为 $p(c) = f(c)/N$。\n- 使用信息论（Shannon）中的自信息定义：一个概念 $c$ 的信息量为 $\\mathrm{IC}(c) = -\\ln p(c)$，其中使用自然对数。\n- 使用分类法的定义，即一个有根有向无环图，其偏序关系由父子（“is-a”）关系的传递闭包导出。对于任意两个节点 $a$ 和 $b$，将最低共同上位概念（Least Common Subsumer, $\\mathrm{LCS}(a,b)$）定义为分类法中 $a$ 和 $b$ 的最深（最大深度）的共同祖先。假设为树形结构，因此 $\\mathrm{LCS}$ 是唯一的。\n- 基于这些基础，推导并实现以下三个用于衡量两个概念 $a$ 和 $b$ 之间关系的信息论度量：\n  1. 共享信息，定义为最低共同上位概念的信息量，即 $\\mathrm{shared\\_IC}(a,b) = \\mathrm{IC}(\\mathrm{LCS}(a,b))$。\n  2. 一种归一化相似度，该相似度对 $a$ 和 $b$ 对称，当 $a=b$ 时等于 $1$，当仅共享根节点时递减至 $0$；从共享信息量与总自信息量的比率推导得出：$\\mathrm{norm\\_sim}(a,b) = \\dfrac{2\\,\\mathrm{IC}(\\mathrm{LCS}(a,b))}{\\mathrm{IC}(a)+\\mathrm{IC}(b)}$，并约定当分母为 $0$ 且 $a=b$ 时，值为 $1$，否则为 $0$。\n  3. 一种信息论距离，对应于非共享信息：$\\mathrm{it\\_dist}(a,b) = \\mathrm{IC}(a)+\\mathrm{IC}(b)-2\\,\\mathrm{IC}(\\mathrm{LCS}(a,b))$。\n- 此外，基于分类法无向图版本中的最短路径长度 $\\ell(a,b)$ 推导一个基于路径的图论相似度：$\\mathrm{path\\_sim}(a,b) = \\dfrac{1}{1+\\ell(a,b)}$。在一个有根树中，$\\ell(a,b) = \\mathrm{depth}(a)+\\mathrm{depth}(b)-2\\,\\mathrm{depth}(\\mathrm{LCS}(a,b))$，其中 $\\mathrm{depth}(\\text{root})=0$，每条边使深度增加 $1$。\n\n使用的分类法、语料库和约束条件：\n- 概念（节点标识符和非正式标签）：\n  - $\\text{SCT\\_000}$: 临床发现 (根节点)\n  - $\\text{SCT\\_100}$: 感染性疾病\n  - $\\text{SCT\\_110}$: 呼吸道感染\n  - $\\text{SCT\\_120}$: 胃肠道感染\n  - $\\text{SCT\\_111}$: 流感\n  - $\\text{SCT\\_112}$: 肺炎\n  - $\\text{SCT\\_121}$: 病毒性肠胃炎\n  - $\\text{SCT\\_200}$: 肿瘤\n  - $\\text{SCT\\_210}$: 肺癌\n  - $\\text{SCT\\_220}$: 乳腺癌\n  - $\\text{SCT\\_300}$: 内分泌疾病\n  - $\\text{SCT\\_310}$: 糖尿病\n- 父子（“is-a”）边（从父节点指向子节点）：\n  - $\\text{SCT\\_000} \\to \\text{SCT\\_100}$、$\\text{SCT\\_000} \\to \\text{SCT\\_200}$、$\\text{SCT\\_000} \\to \\text{SCT\\_300}$\n  - $\\text{SCT\\_100} \\to \\text{SCT\\_110}$、$\\text{SCT\\_100} \\to \\text{SCT\\_120}$\n  - $\\text{SCT\\_110} \\to \\text{SCT\\_111}$、$\\text{SCT\\_110} \\to \\text{SCT\\_112}$\n  - $\\text{SCT\\_120} \\to \\text{SCT\\_121}$\n  - $\\text{SCT\\_200} \\to \\text{SCT\\_210}$、$\\text{SCT\\_200} \\to \\text{SCT\\_220}$\n  - $\\text{SCT\\_300} \\to \\text{SCT\\_310}$\n- 语料库叶节点注解计数（只有叶节点有直接注解；内部节点通过对其后代节点求和来获得传播计数）：\n  - $\\text{SCT\\_111}: f = $ $120$\n  - $\\text{SCT\\_112}: f = $ $80$\n  - $\\text{SCT\\_121}: f = $ $50$\n  - $\\text{SCT\\_210}: f = $ $70$\n  - $\\text{SCT\\_220}: f = $ $60$\n  - $\\text{SCT\\_310}: f = $ $90$\n- 叶节点注解总数为 $N = 120+80+50+70+60+90 = 470$。对于任意内部节点 $c$，将 $f(c)$ 定义为以 $c$ 为根的子树中所有叶节点的 $f(\\cdot)$ 之和。经验概率为 $p(c)=f(c)/N$，信息量为 $\\mathrm{IC}(c)=-\\ln p(c)$。\n\n测试套件：\n为以下每个有序概念对计算向量 $[\\mathrm{shared\\_IC}, \\mathrm{norm\\_sim}, \\mathrm{it\\_dist}, \\mathrm{path\\_sim}]$：\n- 案例 $1$: $(\\text{SCT\\_111}, \\text{SCT\\_112})$\n- 案例 $2$: $(\\text{SCT\\_111}, \\text{SCT\\_111})$\n- 案例 $3$: $(\\text{SCT\\_111}, \\text{SCT\\_310})$\n- 案例 $4$: $(\\text{SCT\\_210}, \\text{SCT\\_220})$\n- 案例 $5$: $(\\text{SCT\\_110}, \\text{SCT\\_112})$\n- 案例 $6$: $(\\text{SCT\\_121}, \\text{SCT\\_220})$\n\n输出规格：\n- 对于每个案例，按 $[\\mathrm{shared\\_IC}, \\mathrm{norm\\_sim}, \\mathrm{it\\_dist}, \\mathrm{path\\_sim}]$ 的顺序输出四个值，每个值四舍五入到 $6$ 位小数。\n- 你的程序应生成单行输出，其中包含所有案例的结果，格式为由方括号括起来的 $4$ 元组的逗号分隔列表。例如，要求的格式是类似 $[[v\\_{11},v\\_{12},v\\_{13},v_{14}],[v\\_{21},v_{22},v_{23},v_{24}],\\dots]$ 的单行，不含多余的空格或文本。\n\n所有对数必须是自然对数。不允许外部输入；上述分类法和计数是固定的并嵌入程序中。不涉及物理单位或角度。不得使用百分比；概率应按上文定义的十进制小数处理。",
            "solution": "我们从信息论和图论的基本原理出发，推导出可实现的公式。\n\n1. 概率和信息量。令 $f(c)$ 为概念 $c$ 的传播频率，通过对以 $c$ 为根的子树中所有叶节点的注解计数求和计算得出。令 $N$ 为所有叶节点的注解总数。那么 $c$ 的经验概率为 $p(c) = f(c)/N$。根据自信息的定义，信息量为 $\\mathrm{IC}(c) = -\\ln p(c)$。这一点基于一个经过充分检验的事实：信息对于独立事件是可加的，并且随着概率的增加而减少。\n\n2. 最低共同上位概念和深度。在一个带有父子（“is-a”）边的有根分类法（树）中，一个节点的祖先集合包括该节点本身以及其到根节点路径上的所有节点。最低共同上位概念 $\\mathrm{LCS}(a,b)$ 是同时存在于两个祖先集合中的最深（最大深度）的节点。在树中，这个节点是唯一的，因为从每个节点到根节点都有唯一的路径。深度的定义为 $\\mathrm{depth}(\\text{root})=0$，并沿着远离根节点的每条边增加 $1$。\n\n3. 信息论度量。考虑两个概念 $a$ 和 $b$ 以及它们的 LCS $c^{\\ast} = \\mathrm{LCS}(a,b)$。共享信息是它们最具体共同泛化概念的自信息，即 $\\mathrm{shared\\_IC}(a,b) = \\mathrm{IC}(c^{\\ast})$，因为 $-\\ln p(c^{\\ast})$ 是 $a$ 和 $b$ 共同意外程度的上限。通过将共享信息与总自信息进行比较，可以得到一个满足对称性、有界于 $[0,1]$、不可区分者同一性（当 $a=b$ 时等于 $1$）以及当仅共享根节点时消失为零的归一化相似度：$\\mathrm{norm\\_sim}(a,b) = \\dfrac{2\\,\\mathrm{IC}(c^{\\ast})}{\\mathrm{IC}(a)+\\mathrm{IC}(b)}$，并约定当分母为 $0$ 且 $a=b$ 时，值为 $1$，否则为 $0$。该比率的有界性为 $1$，因为 $\\mathrm{IC}(c^{\\ast}) \\le \\min\\{\\mathrm{IC}(a),\\mathrm{IC}(b)\\}$。非共享信息由信息论距离 $\\mathrm{it\\_dist}(a,b) = \\mathrm{IC}(a)+\\mathrm{IC}(b)-2\\,\\mathrm{IC}(c^{\\ast}) \\ge 0$ 捕获，该距离也遵循相同的单调性属性。\n\n4. 图论路径相似度。在分类法的无向版本中，$a$ 和 $b$ 之间的最短路径长度为 $\\ell(a,b)$。在有根树中，这等于 $\\mathrm{depth}(a)+\\mathrm{depth}(b)-2\\,\\mathrm{depth}(c^{\\ast})$。那么一个简单的有界相似度是 $\\mathrm{path\\_sim}(a,b) = \\dfrac{1}{1+\\ell(a,b)} \\in (0,1]$，当 $a=b$ 时它等于 $1$，并随着节点的分离而减小。\n\n算法设计：\n- 将分类法构建为父节点映射和子节点邻接表。将没有子节点的节点识别为叶节点。\n- 通过从根节点开始的广度优先遍历来计算深度。\n- 通过自底向上对叶节点计数求和来计算传播频率 $f(c)$。此处，叶节点计数为：$\\text{SCT\\_111}: f=$ $120$、$\\text{SCT\\_112}: f=$ $80$、$\\text{SCT\\_121}: f=$ $50$、$\\text{SCT\\_210}: f=$ $70$、$\\text{SCT\\_220}: f=$ $60$、$\\text{SCT\\_310}: f=$ $90$。总数为 $N=$ $470$。通过求和得到的内部节点频率为：$f(\\text{SCT\\_110})=$ $200$、 $f(\\text{SCT\\_120})=$ $50$、 $f(\\text{SCT\\_100})=$ $250$、 $f(\\text{SCT\\_200})=$ $130$、 $f(\\text{SCT\\_300})=$ $90$、 $f(\\text{SCT\\_000})=$ $470$。\n- 使用自然对数计算 $p(c)=f(c)/N$ 和 $\\mathrm{IC}(c)=-\\ln p(c)$。数值上（为透明起见，四舍五入到 $9$ 位小数）：$\\mathrm{IC}(\\text{SCT\\_111})=$ $1.365241055$、$\\mathrm{IC}(\\text{SCT\\_112})=$ $1.770706163$、$\\mathrm{IC}(\\text{SCT\\_121})=$ $2.240709793$、$\\mathrm{IC}(\\text{SCT\\_210})=$ $1.904237556$、$\\mathrm{IC}(\\text{SCT\\_220})=$ $2.058388236$、$\\mathrm{IC}(\\text{SCT\\_310})=$ $1.652923128$、$\\mathrm{IC}(\\text{SCT\\_110})=$ $0.854415432$、$\\mathrm{IC}(\\text{SCT\\_120})=$ $2.240709793$、$\\mathrm{IC}(\\text{SCT\\_100})=$ $0.631271880$、$\\mathrm{IC}(\\text{SCT\\_200})=$ $1.285198348$、$\\mathrm{IC}(\\text{SCT\\_300})=$ $1.652923128$、$\\mathrm{IC}(\\text{SCT\\_000})=$ $0$。\n- 对于每个测试案例，找到 $\\mathrm{LCS}$，从深度计算 $\\ell(a,b)$，并评估四个度量指标，结果四舍五入到 $6$ 位小数。\n\n指定测试套件的计算结果（每个向量格式为 $[\\mathrm{shared\\_IC}, \\mathrm{norm\\_sim}, \\mathrm{it\\_dist}, \\mathrm{path\\_sim}]$，四舍五入到 $6$ 位小数）：\n- 案例 $1$ $(\\text{SCT\\_111}, \\text{SCT\\_112})$: $[0.854415, 0.544917, 1.427116, 0.333333]$\n- 案例 $2$ $(\\text{SCT\\_111}, \\text{SCT\\_111})$: $[1.365241, 1.000000, 0.000000, 1.000000]$\n- 案例 $3$ $(\\text{SCT\\_111}, \\text{SCT\\_310})$: $[0.000000, 0.000000, 3.018164, 0.166667]$\n- 案例 $4$ $(\\text{SCT\\_210}, \\text{SCT\\_220})$: $[1.285198, 0.648660, 1.392229, 0.333333]$\n- 案例 $5$ $(\\text{SCT\\_110}, \\text{SCT\\_112})$: $[0.854415, 0.650953, 0.916291, 0.500000]$\n- 案例 $6$ $(\\text{SCT\\_121}, \\text{SCT\\_220})$: $[0.000000, 0.000000, 4.299098, 0.166667]$\n\n下面的程序根据提供的分类法和计数确定性地实现了这些步骤，并以精确要求的格式打印出包含所有六个案例结果的单行。",
            "answer": "```python\n# Python 3.12 program to compute semantic similarity and taxonomy metrics\n# for a fixed SNOMED-like taxonomy and corpus counts.\n# No external input; outputs a single line list-of-lists as specified.\n\nimport math\n\ndef build_taxonomy():\n    # Define nodes\n    nodes = {\n        'SCT_000': 'Clinical finding',\n        'SCT_100': 'Infectious disease',\n        'SCT_110': 'Respiratory infection',\n        'SCT_120': 'Gastrointestinal infection',\n        'SCT_111': 'Influenza',\n        'SCT_112': 'Pneumonia',\n        'SCT_121': 'Viral gastroenteritis',\n        'SCT_200': 'Neoplasm',\n        'SCT_210': 'Lung cancer',\n        'SCT_220': 'Breast cancer',\n        'SCT_300': 'Endocrine disease',\n        'SCT_310': 'Diabetes mellitus',\n    }\n    # Define parent-child edges\n    edges = [\n        ('SCT_000', 'SCT_100'),\n        ('SCT_000', 'SCT_200'),\n        ('SCT_000', 'SCT_300'),\n        ('SCT_100', 'SCT_110'),\n        ('SCT_100', 'SCT_120'),\n        ('SCT_110', 'SCT_111'),\n        ('SCT_110', 'SCT_112'),\n        ('SCT_120', 'SCT_121'),\n        ('SCT_200', 'SCT_210'),\n        ('SCT_200', 'SCT_220'),\n        ('SCT_300', 'SCT_310'),\n    ]\n    children = {n: [] for n in nodes}\n    parent = {}\n    for p, c in edges:\n        children[p].append(c)\n        parent[c] = p\n    root = 'SCT_000'\n    return nodes, children, parent, root\n\ndef compute_depths(children, root):\n    depths = {root: 0}\n    stack = [root]\n    while stack:\n        u = stack.pop()\n        for v in children.get(u, []):\n            depths[v] = depths[u] + 1\n            stack.append(v)\n    return depths\n\ndef compute_subtree_counts(children, leaf_counts, nodes):\n    # Post-order DFS to sum counts\n    # Initialize counts with leaf counts, zero otherwise\n    counts = {n: 0 for n in nodes}\n    for leaf, cnt in leaf_counts.items():\n        counts[leaf] = cnt\n\n    # We can perform multiple passes since it's a tree of small size\n    # or implement recursion\n    visited = set()\n    def dfs_sum(u):\n        if u in visited:\n            return counts[u]\n        total = counts[u]\n        for v in children.get(u, []):\n            total += dfs_sum(v)\n        counts[u] = total\n        visited.add(u)\n        return total\n\n    # Call for all nodes to ensure coverage\n    for n in nodes:\n        dfs_sum(n)\n    return counts\n\ndef ancestors_with_depth(node, parent, depths):\n    # Return list of (ancestor, depth) including node and root\n    res = []\n    u = node\n    while True:\n        d = depths[u]\n        res.append((u, d))\n        if u not in parent:\n            break\n        u = parent[u]\n    return res\n\ndef lcs(a, b, parent, depths):\n    anc_a = {u: d for u, d in ancestors_with_depth(a, parent, depths)}\n    anc_b = {u: d for u, d in ancestors_with_depth(b, parent, depths)}\n    common = set(anc_a.keys())  set(anc_b.keys())\n    # choose the one with maximum depth\n    best = None\n    best_depth = -1\n    for u in common:\n        d = depths[u]\n        if d > best_depth:\n            best_depth = d\n            best = u\n    return best\n\ndef path_length(a, b, depths, lcs_node):\n    return depths[a] + depths[b] - 2 * depths[lcs_node]\n\ndef compute_metrics_for_pair(a, b, ic, depths, parent):\n    c_star = lcs(a, b, parent, depths)\n    shared_ic = ic[c_star]\n    ia = ic[a]\n    ib = ic[b]\n    denom = ia + ib\n    if denom == 0.0:\n        norm_sim = 1.0 if a == b else 0.0\n    else:\n        norm_sim = (2.0 * shared_ic) / denom\n    it_dist = ia + ib - 2.0 * shared_ic\n    pl = path_length(a, b, depths, c_star)\n    path_sim = 1.0 / (1.0 + pl)\n    return shared_ic, norm_sim, it_dist, path_sim\n\ndef solve():\n    nodes, children, parent, root = build_taxonomy()\n    depths = compute_depths(children, root)\n    # Leaf counts\n    leaf_counts = {\n        'SCT_111': 120,\n        'SCT_112': 80,\n        'SCT_121': 50,\n        'SCT_210': 70,\n        'SCT_220': 60,\n        'SCT_310': 90,\n    }\n    counts = compute_subtree_counts(children, leaf_counts, nodes)\n    N = sum(leaf_counts.values())\n    # Compute IC\n    ic = {}\n    for n in nodes:\n        # Numerical safety: ensure p > 0\n        if counts[n] == 0:\n             p = 0.0\n        else:\n             p = counts[n] / N\n\n        if p == 0.0:\n            ic[n] = float('inf')\n        else:\n            ic[n] = -math.log(p)\n    # Test cases\n    test_cases = [\n        ('SCT_111', 'SCT_112'),\n        ('SCT_111', 'SCT_111'),\n        ('SCT_111', 'SCT_310'),\n        ('SCT_210', 'SCT_220'),\n        ('SCT_110', 'SCT_112'),\n        ('SCT_121', 'SCT_220'),\n    ]\n    results = []\n    for a, b in test_cases:\n        shared_ic, norm_sim, it_dist, path_sim = compute_metrics_for_pair(a, b, ic, depths, parent)\n        # Round to 6 decimals in string format\n        results.append([\n            f\"{shared_ic:.6f}\",\n            f\"{norm_sim:.6f}\",\n            f\"{it_dist:.6f}\",\n            f\"{path_sim:.6f}\",\n        ])\n    # Format as a single-line JSON-like list\n    inner = [f\"[{','.join(r)}]\" for r in results]\n    output = f\"[{','.join(inner)}]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}