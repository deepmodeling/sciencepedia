{
    "hands_on_practices": [
        {
            "introduction": "哈代-温伯格平衡（Hardy-Weinberg Equilibrium, HWE）是群体遗传学中的一个基本零模型，为变异分析提供了基准。本练习将指导你从第一性原理出发，推导等位基因频率的估计值，并检验观测数据是否偏离HWE的预期。掌握这一核心技能对于评估群体中的变异分布和进行数据质量控制至关重要。",
            "id": "4569027",
            "problem": "一个为精准医学研究而建立的大型临床生物样本库，在一个无亲缘关系的个体队列中，使用高覆盖度全基因组测序技术对一个常染色体、双等位基因的单核苷酸多态性（SNP）进行了基因分型。设这两个等位基因由核苷酸字母 $T$（参考）和 $C$（变异）表示。该队列中观察到的基因型计数为：$n_{TT} = 548$，$n_{TC} = 362$，$n_{CC} = 90$，总计 $n = 1000$ 个二倍体个体。\n\n从基本定义出发，在一个没有选择、突变、迁移或选择性交配的随机交配群体中，每个配子独立地以概率 $p$ 携带等位基因 $C$，以概率 $1 - p$ 携带等位基因 $T$，并且队列中的 $2n$ 个等位基因构成了对该群体的基因库的抽样。请完成以下任务：\n\n1. 仅使用基于 $2n$ 个等位基因的独立伯努利试验的似然第一性原理，推导出等位基因 $C$ 的群体频率 $p$ 的最大似然估计 $\\hat{p}$，并用观察到的基因型计数表示。\n\n2. 使用哈代-温伯格平衡（HWE）的定义，即配子的随机结合产生基因型类别，其频率为等位基因概率的乘积，推导出 $TT$、$TC$ 和 $CC$ 的期望基因型频率（用 $p$ 表示）。\n\n3. 将您的 $\\hat{p}$ 代入第2部分中获得的HWE表达式，计算该队列中杂合子 $TC$ 的期望数量。将最终结果表示为一个数字。将您的答案四舍五入到四位有效数字。不需要单位。",
            "solution": "问题陈述已经过验证，被认为是科学上合理的、问题定义明确的、客观的且自洽的。这是群体遗传学中的一个标准练习。因此，我们可以进行正式的求解。\n\n问题分为三个部分。我们将按顺序逐一解答。\n\n**第1部分：等位基因频率 $p$ 的最大似然估计（MLE）的推导**\n\n我们被要求推导变异等位基因 $C$ 频率的最大似然估计 $\\hat{p}$。问题规定，此推导必须基于对 $n$ 个二倍体个体队列中存在的 $2n$ 个等位基因进行独立伯努利试验的原理。\n\n个体总数为 $n = n_{TT} + n_{TC} + n_{CC} = 548 + 362 + 90 = 1000$。\n因此，样本中的等位基因总数为 $2n = 2000$。\n\n设 $p$ 为等位基因 $C$ 的群体频率。\n设 $1-p$ 为等位基因 $T$ 的群体频率。\n\n样本中的每个 $2n$ 等位基因都可以被看作是从群体基因库中的一次独立抽取。抽取到 $C$ 等位基因的事件是“成功”，概率为 $p$；抽取到 $T$ 等位基因的事件是“失败”，概率为 $1-p$。这构成了一系列 $2n$ 次独立的伯努利试验。\n\n首先，我们计算样本中 $C$ 等位基因的总数（记为 $N_C$）和 $T$ 等位基因的总数（记为 $N_T$）。\n基因型为 $TT$ 的个体贡献 $0$ 个 $C$ 等位基因。\n基因型为 $TC$ 的个体贡献 $1$ 个 $C$ 等位基因。\n基因型为 $CC$ 的个体贡献 $2$ 个 $C$ 等位基因。\n因此，$C$ 等位基因的总计数为：\n$$N_C = 2 \\cdot n_{CC} + 1 \\cdot n_{TC} + 0 \\cdot n_{TT} = 2n_{CC} + n_{TC}$$\n$T$ 等位基因的总计数为：\n$$N_T = 2 \\cdot n_{TT} + 1 \\cdot n_{TC} + 0 \\cdot n_{CC} = 2n_{TT} + n_{TC}$$\n等位基因总数为 $N_C + N_T = (2n_{CC} + n_{TC}) + (2n_{TT} + n_{TC}) = 2(n_{TT} + n_{TC} + n_{CC}) = 2n$，结果一致。\n\n在 $2n$ 次独立试验中观察到恰好 $N_C$ 次成功的概率遵循二项分布。似然函数 $L(p)$ 是在给定参数 $p$ 的情况下观察到当前数据的概率，其表达式为：\n$$L(p | N_C, n) = \\binom{2n}{N_C} p^{N_C} (1-p)^{2n - N_C}$$\n为了找到使该函数最大化的 $p$ 值，计算上更方便的是最大化似然函数的自然对数，即对数似然函数 $\\ell(p) = \\ln(L(p))$：\n$$\\ell(p) = \\ln\\left(\\binom{2n}{N_C}\\right) + N_C \\ln(p) + (2n - N_C) \\ln(1-p)$$\n我们通过求 $\\ell(p)$ 对 $p$ 的一阶导数并将其设为零来找到最大值。项 $\\ln\\left(\\binom{2n}{N_C}\\right)$ 相对于 $p$ 是一个常数，所以其导数为零。\n$$\\frac{d\\ell}{dp} = \\frac{N_C}{p} - \\frac{2n - N_C}{1-p}$$\n将导数设为零，得到最大似然估计，记为 $\\hat{p}$：\n$$\\frac{N_C}{\\hat{p}} - \\frac{2n - N_C}{1-\\hat{p}} = 0$$\n$$\\frac{N_C}{\\hat{p}} = \\frac{2n - N_C}{1-\\hat{p}}$$\n$$N_C (1-\\hat{p}) = \\hat{p} (2n - N_C)$$\n$$N_C - N_C \\hat{p} = 2n \\hat{p} - N_C \\hat{p}$$\n$$N_C = 2n \\hat{p}$$\n解出 $\\hat{p}$，我们得到最大似然估计：\n$$\\hat{p} = \\frac{N_C}{2n}$$\n将 $N_C$ 的表达式用基因型计数代入，我们得到最大似然估计的最终表达式：\n$$\\hat{p} = \\frac{2n_{CC} + n_{TC}}{2n}$$\n\n**第2部分：哈代-温伯格平衡（HWE）下期望基因型频率的推导**\n\n问题将HWE定义为配子随机结合所产生的状态。在群体的配子库中，等位基因 $C$ 的频率是 $p$，等位基因 $T$ 的频率是 $1-p$。一个二倍体合子的形成涉及两个此类配子的随机组合。\n\n形成 $CC$ 基因型的概率是一个携带 $C$ 的配子与另一个携带 $C$ 的配子结合的概率。由于是随机结合（独立性），该概率为：\n$$\\text{Freq}(CC) = p \\times p = p^2$$\n形成 $TT$ 基因型的概率是一个携带 $T$ 的配子与另一个携带 $T$ 的配子结合的概率：\n$$\\text{Freq}(TT) = (1-p) \\times (1-p) = (1-p)^2$$\n形成 $TC$ 杂合子的概率可以通过两种互斥的方式发生：\n1. 一个带 $T$ 等位基因的精子使一个带 $C$ 等位基因的卵子受精。概率为 $(1-p) \\times p$。\n2. 一个带 $C$ 等位基因的精子使一个带 $T$ 等位基因的卵子受精。概率为 $p \\times (1-p)$。\n杂合子基因型的总概率是这些概率之和：\n$$\\text{Freq}(TC) = p(1-p) + (1-p)p = 2p(1-p)$$\n因此，在HWE下的期望基因型频率为：\n$$(1-p)^2 \\quad \\text{对于 } TT$$\n$$2p(1-p) \\quad \\text{对于 } TC$$\n$$p^2 \\quad \\text{对于 } CC$$\n\n**第3部分：期望杂合子数量的计算**\n\n首先，我们使用给定的基因型计数（$n_{TT} = 548$，$n_{TC} = 362$，$n_{CC} = 90$，$n = 1000$）来计算MLE $\\hat{p}$ 的数值。\n根据第1部分，我们有：\n$$\\hat{p} = \\frac{2n_{CC} + n_{TC}}{2n} = \\frac{2(90) + 362}{2(1000)} = \\frac{180 + 362}{2000} = \\frac{542}{2000} = 0.271$$\n接下来，我们使用这个估计值 $\\hat{p}$，并基于第2部分推导的公式，来计算在HWE下杂合子（$TC$）的期望频率：\n$$\\text{Expected Freq}(TC) = 2\\hat{p}(1-\\hat{p})$$\n$$\\text{Expected Freq}(TC) = 2(0.271)(1 - 0.271) = 2(0.271)(0.729) = 0.395118$$\n最后，在一个大小为 $n=1000$ 的队列中，杂合子的期望数量 $E[n_{TC}]$ 是个体总数乘以该基因型的期望频率：\n$$E[n_{TC}] = n \\times \\text{Expected Freq}(TC)$$\n$$E[n_{TC}] = 1000 \\times 0.395118 = 395.118$$\n问题要求将答案四舍五入到四位有效数字。\n$$395.118 \\approx 395.1$$\n因此，在该队列中，基于HWE的假设，期望的杂合子数量为 $395.1$。",
            "answer": "$$\n\\boxed{395.1}\n$$"
        },
        {
            "introduction": "真实的测序数据常常受到技术偏差的影响，这使得从原始读数中直接解读生物学信号变得复杂。本练习聚焦于参考偏好（reference bias）这一常见问题，要求你构建一个概率模型来量化其对杂合位点等位基因平衡的影响。通过这项实践，你将学会如何透过测序伪影，更准确地理解等位基因的真实比例。",
            "id": "4568960",
            "problem": "单核苷酸多态性（SNP）是二倍体基因组中的一个双等位基因杂合位点，拥有一个参考等位基因（REF）和一个备选等位基因（ALT）。在高通量测序中，参考偏倚可能导致携带REF等位基因的读段（reads）比携带ALT等位基因的读段更成功地完成比对。考虑以下一个覆盖杂合SNP位点的读段生成模型：\n\n1. 每个原始片段来自REF或ALT单倍型的概率相等，分别为$0.5$和$0.5$。\n2. 以其来源单倍型为条件，如果片段携带REF单倍型，则其比对成功并通过所有筛选的概率为$m_{R}$；如果携带ALT单倍型，则概率为$m_{A}$。由于比对偏倚，$m_{R} \\neq m_{A}$。\n3. 以比对成功为条件，SNP位点上的碱基检出（base calling）服从一个对称的替换错误率$\\epsilon$：一个已比对的源自REF的读段报告为ALT的概率为$\\epsilon$，报告为REF的概率为$1-\\epsilon$；一个已比对的源自ALT的读段报告为ALT的概率为$1-\\epsilon$，报告为REF的概率为$\\epsilon$。\n\n将等位基因平衡（allele balance）定义为在所有覆盖该SNP的已比对读段中，支持ALT等位基因的读段所占的期望分数。仅使用条件概率的核心定义、全期望定律以及上述生成模型，推导出等位基因平衡作为$m_{R}$、$m_{A}$和$\\epsilon$的函数表达式，然后针对$m_{R}=0.98$、$m_{A}=0.84$和$\\epsilon=0.005$进行数值计算。\n\n将最终数值结果表示为四舍五入到四位有效数字的小数。最终答案中不要包含百分号或任何单位。",
            "solution": "用户要求在一个给定的包含参考偏倚和碱基检出错误的测序读段生成模型下，推导并计算杂合单核苷酸多态性（SNP）位点上等位基因平衡的表达式。\n\n首先，我将验证问题陈述。\n\n**步骤1：提取已知条件**\n- SNP是一个双等位基因杂合位点，拥有一个参考（REF）等位基因和一个备选（ALT）等位基因。\n- 原始片段来自REF单倍型的概率为$P(H_R) = 0.5$。\n- 原始片段来自ALT单倍型的概率为$P(H_A) = 0.5$。\n- 源自REF的片段比对成功的概率为$m_{R} = P(M|H_R)$。\n- 源自ALT的片段比对成功的概率为$m_{A} = P(M|H_A)$。\n- 存在比对偏倚，意味着$m_{R} \\neq m_{A}$。\n- 一个对称的替换错误率$\\epsilon$决定了已比对读段的碱基检出。\n- 已比对的源自REF的读段报告为ALT的概率：$P(A_{obs}|M, H_R) = \\epsilon$。\n- 已比对的源自REF的读段报告为REF的概率：$P(R_{obs}|M, H_R) = 1-\\epsilon$。\n- 已比对的源自ALT的读段报告为ALT的概率：$P(A_{obs}|M, H_A) = 1-\\epsilon$。\n- 已比对的源自ALT的读段报告为REF的概率：$P(R_{obs}|M, H_A) = \\epsilon$。\n- 等位基因平衡定义为支持ALT等位基因的已比对读段所占的期望分数。\n- 用于计算的数值：$m_{R}=0.98$，$m_{A}=0.84$，以及$\\epsilon=0.005$。\n- 最终数值结果应四舍五入到四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法严谨且客观。它提出了一个简化但标准且有效的概率模型，该模型在生物信息学中用于解释诸如比对偏倚和碱基检出错误等测序假象。所提供的参数在物理上是现实的。问题是自洽的，没有矛盾或歧义。使用的术语是基因组学领域的标准术语。因此，该问题是有效的。\n\n**步骤3：结论与行动**\n问题有效。我将继续进行解答。\n\n**等位基因平衡的推导**\n\n等位基因平衡（$AB$）定义为支持ALT等位基因的已比对读段所占的期望分数。这等同于求解一个随机选择的已比对读段报告为ALT等位基因的概率。我们将读段成功比对的事件表示为$M$，已比对读段报告为ALT等位基因的事件表示为$A_{obs}$。我们要求解的量是条件概率$P(A_{obs}|M)$。\n\n根据条件概率的定义：\n$$ AB = P(A_{obs}|M) = \\frac{P(A_{obs} \\cap M)}{P(M)} $$\n我们可以使用全概率定律，根据读段的来源单倍型（$H_R$ REF单倍型或$H_A$ ALT单倍型）对样本空间进行划分，分别计算分子和分母。\n\n首先，计算分母$P(M)$，即一个读段无论其来源如何都能成功比对的总概率。\n$$ P(M) = P(M|H_R)P(H_R) + P(M|H_A)P(H_A) $$\n代入给定的概率：\n$$ P(M) = m_{R}(0.5) + m_{A}(0.5) = 0.5(m_{R} + m_{A}) $$\n\n接下来，计算分子$P(A_{obs} \\cap M)$，即一个读段成功比对且报告为ALT等位基因的联合概率。\n$$ P(A_{obs} \\cap M) = P(A_{obs} \\cap M | H_R)P(H_R) + P(A_{obs} \\cap M | H_A)P(H_A) $$\n使用条件概率的链式法则，$P(A_{obs} \\cap M | H_i) = P(A_{obs}|M, H_i)P(M|H_i)$，我们可以将表达式重写为：\n$$ P(A_{obs} \\cap M) = P(A_{obs}|M, H_R)P(M|H_R)P(H_R) + P(A_{obs}|M, H_A)P(M|H_A)P(H_A) $$\n现在，我们代入生成模型中的参数：\n- 对于来自REF单倍型（$H_R$）的读段：它以概率$m_R$比对成功，然后以概率$\\epsilon$被错误地检出为ALT。\n- 对于来自ALT单倍型（$H_A$）的读段：它以概率$m_A$比对成功，然后以概率$1-\\epsilon$被正确地检出为ALT。\n\n将这些代入$P(A_{obs} \\cap M)$的方程中：\n$$ P(A_{obs} \\cap M) = (\\epsilon)(m_{R})(0.5) + (1-\\epsilon)(m_{A})(0.5) $$\n$$ P(A_{obs} \\cap M) = 0.5(\\epsilon m_{R} + (1-\\epsilon)m_{A}) $$\n\n最后，我们可以通过计算分子与分母的比值来得到等位基因平衡：\n$$ AB = \\frac{P(A_{obs} \\cap M)}{P(M)} = \\frac{0.5(\\epsilon m_{R} + (1-\\epsilon)m_{A})}{0.5(m_{R} + m_{A})} $$\n因子$0.5$可以消去，得到等位基因平衡的通用表达式：\n$$ AB = \\frac{\\epsilon m_{R} + (1-\\epsilon)m_{A}}{m_{R} + m_{A}} $$\n\n**数值计算**\n\n现在，我们将给定的数值代入推导出的表达式中：$m_{R}=0.98$，$m_{A}=0.84$，以及$\\epsilon=0.005$。\n$$ AB = \\frac{(0.005)(0.98) + (1-0.005)(0.84)}{0.98 + 0.84} $$\n$$ AB = \\frac{(0.005)(0.98) + (0.995)(0.84)}{1.82} $$\n计算分子中的各项：\n$$ (0.005)(0.98) = 0.0049 $$\n$$ (0.995)(0.84) = 0.8358 $$\n将分子中的各项相加：\n$$ 0.0049 + 0.8358 = 0.8407 $$\n现在，进行最后的除法运算：\n$$ AB = \\frac{0.8407}{1.82} \\approx 0.4619230769... $$\n问题要求结果四舍五入到四位有效数字。前四位有效数字是$4$，$6$，$1$和$9$。第五位数字是$2$，因此向下舍入。\n$$ AB \\approx 0.4619 $$\n这就是在给定条件下，支持ALT等位基因的已比对读段的期望分数。",
            "answer": "$$\n\\boxed{0.4619}\n$$"
        },
        {
            "introduction": "在基因组尺度上，偏差校正是准确检测结构变异的关键。本编码练习将引导你处理一个核心挑战：因基因组可作图性（mappability）不均一而导致的拷贝数变异（Copy Number Variation, CNV）检测偏差。你将实现一个包含归一化和统计检验的完整分析流程，从而在实际操作中学会如何有效降低由重复序列引起的假阳性CNV信号。",
            "id": "4568999",
            "problem": "考虑使用短读长全基因组测序来检测基因组变异，包括单核苷酸多态性（SNP）、插入和删除（indels）以及结构变异（SV）。测序读段被比对到参考基因组上，每个基因组位置的读段覆盖度被用来推断拷贝数变异（CNV）。有两个基本事实推动了对覆盖度进行统计学处理：(i) 在均匀抽样和独立的读段起始位点条件下，每个碱基的读段计数服从泊松过程；(ii) 由于包括片段重复在内的重复DNA的存在，比对可图谱性在整个基因组中是变化的。一个可图谱性轨道为每个基因组位置赋予一个介于 $0$ 和 $1$ 之间的分数，代表源于该位置的读段能够被唯一比对的概率；即使没有真实的CNV，低可图谱性的位置也会导致观测到的覆盖度降低，而高度重复的区域也可能因比对启发式算法而表现出异常的读段堆积。本任务的目标是形式化地描述可图谱性和片段重复如何扭曲覆盖度，并设计一个有原则的筛选和归一化方案，利用可图谱性轨道来减少CNV的假阳性。\n\n基本概念和定义：\n- 分子生物学中心法则指出，脱氧核糖核酸（DNA）转录为核糖核酸（RNA），并翻译成蛋白质；虽然这不直接决定读段覆盖度，但它为基于测序的基因组变异推断设定了背景。\n- 在短读长测序中，位置 $i$ 处观测到的单位碱基覆盖度 $C_i$ 可以被建模为一个均值为 $\\lambda_i$ 的泊松随机变量，记为 $C_i \\sim \\mathrm{Poisson}(\\lambda_i)$，其中 $\\lambda_i$ 取决于总测序深度、拷贝数和可图谱性。\n- 令 $m_i \\in [0,1]$ 表示碱基 $i$ 处的可图谱性。令在唯一可图谱区域中，二倍体拷贝数为 $2$ 时的基线期望覆盖度为 $\\mu$（读段数/碱基）。那么，对于碱基 $i$ 处的绝对拷贝数 $\\mathrm{CN}$，在一个不可唯一比对的读段实际上无法用于可信比对的模型下，期望覆盖度满足 $\\mathbb{E}[C_i] = \\lambda_i = \\mu \\cdot m_i \\cdot \\frac{\\mathrm{CN}}{2}$。\n- 一次拷贝数变异（CNV）检出的目标是通过聚合一个基因组窗口内的证据来检测 $\\mathrm{CN} \\neq 2$ 的情况。片段重复和其他低可图谱性特征扭曲了基于朴素覆盖度的CNV检出，因为 $\\{m_i\\}$ 变化很大，常常导致 $C_i$ 在与真实 $\\mathrm{CN}$ 无关的情况下向下偏置。\n\n任务：\n1. 从包含可图谱性的泊松模型出发，推导一个归一化和检验方案，用于估计一个基因组窗口的 $\\widehat{\\mathrm{CN}}$，并计算一个偏离零假设 $\\mathrm{CN}_0 = 2$ 的检验统计量。您的推导过程不能依赖捷径公式，必须从 $C_i \\sim \\mathrm{Poisson}(\\lambda_i)$ 和 $\\lambda_i = \\mu \\cdot m_i \\cdot \\frac{\\mathrm{CN}}{2}$ 开始。\n2. 提出并实现一个使用可图谱性轨道的筛选程序，以减少在低可图谱性或高度重复窗口中的假阳性。该筛选器必须包括：\n   - 排除 $m_i  t_{\\mathrm{map}}$ 的碱基。\n   - 尝试进行CNV检出所需的 $m_i \\ge t_{\\mathrm{map}}$ 的保留碱基的最小比例 $f_{\\min}$。\n   - 一个最小保留长度 $n_{\\min}$（以碱基为单位），低于该长度的窗口被视为不确定。\n3. 在代码中实现得到的估计量和检验统计量。对于每个测试窗口，使用对称显著性阈值 $z_{\\mathrm{thr}}$ 对CNV状态进行分类：删除输出 $-1$，中性（无CNV检出或不确定）输出 $0$，重复输出 $+1$。\n\n待实现的数学规范：\n- 给定一个窗口，其单位碱基覆盖度为 $\\{C_i\\}_{i=1}^n$，可图谱性为 $\\{m_i\\}_{i=1}^n$，以及参数 $\\mu$、$t_{\\mathrm{map}}$、$f_{\\min}$、$n_{\\min}$ 和 $z_{\\mathrm{thr}}$，应用筛选器保留索引 $\\mathcal{I} = \\{ i \\in \\{1,\\dots,n\\} : m_i \\ge t_{\\mathrm{map}} \\}$。如果 $|\\mathcal{I}|  n_{\\min}$ 或 $\\frac{|\\mathcal{I}|}{n}  f_{\\min}$，则输出 $0$。\n- 为 $i \\in \\mathcal{I}$ 定义归一化的单位碱基量 $X_i = \\frac{C_i}{\\mu \\cdot m_i}$。令 $\\widehat{\\mathrm{CN}} = \\frac{2}{|\\mathcal{I}|} \\sum_{i \\in \\mathcal{I}} X_i$。在零假设 $\\mathrm{CN}_0 = 2$ 下，通过泊松到正态的近似，将 $X_i$ 的方差近似为 $\\mathrm{Var}(X_i \\mid \\mathrm{CN}_0) = \\frac{\\mathrm{CN}_0}{2 \\cdot \\mu \\cdot m_i}$。那么 $\\widehat{\\mathrm{CN}}$ 在零假设下的方差为\n$$\n\\mathrm{Var}_0(\\widehat{\\mathrm{CN}}) = \\left( \\frac{2}{|\\mathcal{I}|} \\right)^2 \\sum_{i \\in \\mathcal{I}} \\mathrm{Var}(X_i \\mid \\mathrm{CN}_0) = \\frac{4}{|\\mathcal{I}|^2} \\sum_{i \\in \\mathcal{I}} \\frac{1}{\\mu \\cdot m_i}.\n$$\n- 计算零假设下的 $z$-分数，\n$$\nz = \\frac{\\widehat{\\mathrm{CN}} - 2}{\\sqrt{\\mathrm{Var}_0(\\widehat{\\mathrm{CN}})}}.\n$$\n根据 $z$ 值分类：如果 $z \\le -z_{\\mathrm{thr}}$，输出 $-1$；如果 $z \\ge z_{\\mathrm{thr}}$，输出 $+1$；否则输出 $0$。\n\n测试套件：\n使用以下五个窗口来探测试多种场景，其中 $\\{C_i\\}$ 的数组表示为整数序列，$\\{m_i\\}$ 的数组表示为 $[0,1]$ 内的小数序列：\n\n- 测试 $1$ (高可图谱性，中性二倍体): $\\mu = 30$, $t_{\\mathrm{map}} = 0.5$, $f_{\\min} = 0.6$, $n_{\\min} = 5$, $z_{\\mathrm{thr}} = 3.0$, $\\{C_i\\} = \\{31,29,33,30,28,32,31,30,29,34\\}$, $\\{m_i\\} = \\{0.99,0.98,1.0,0.97,0.96,0.99,0.98,1.0,0.95,0.97\\}$。\n- 测试 $2$ (片段重复伴随低可图谱性，中性二倍体但覆盖度下降): $\\mu = 30$, $t_{\\mathrm{map}} = 0.5$, $f_{\\min} = 0.6$, $n_{\\min} = 5$, $z_{\\mathrm{thr}} = 3.0$, $\\{C_i\\} = \\{9,11,8,12,10,9,10,9,8,10\\}$, $\\{m_i\\} = \\{0.30,0.35,0.25,0.40,0.33,0.28,0.31,0.29,0.27,0.34\\}$。\n- 测试 $3$ (高可图谱性区域的真实杂合删除): $\\mu = 30$, $t_{\\mathrm{map}} = 0.5$, $f_{\\min} = 0.6$, $n_{\\min} = 5$, $z_{\\mathrm{thr}} = 3.0$, $\\{C_i\\} = \\{15,14,16,13,17,15,14,16\\}$, $\\{m_i\\} = \\{0.98,0.97,0.99,0.96,0.97,0.98,0.99,0.97\\}$。\n- 测试 $4$ (混合可图谱性区域的重复；唯一可图谱部分足以通过筛选器): $\\mu = 30$, $t_{\\mathrm{map}} = 0.5$, $f_{\\min} = 0.6$, $n_{\\min} = 5$, $z_{\\mathrm{thr}} = 3.0$, $\\{C_i\\} = \\{36,31,27,18,25,41,38,23,20,31,29,27\\}$, $\\{m_i\\} = \\{0.8,0.7,0.6,0.4,0.55,0.9,0.85,0.5,0.45,0.7,0.65,0.6\\}$。\n- 测试 $5$ (边界处的短窗口；因最小长度而结果不确定): $\\mu = 30$, $t_{\\mathrm{map}} = 0.5$, $f_{\\min} = 0.6$, $n_{\\min} = 5$, $z_{\\mathrm{thr}} = 3.0$, $\\{C_i\\} = \\{30,31,29\\}$, $\\{m_i\\} = \\{0.95,0.96,0.97\\}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含五个测试的CNV分类，形式为一个用方括号括起来的逗号分隔列表，例如 $[\\dots]$。使用整数编码检出结果：$-1$ 表示删除， $0$ 表示中性或被筛选/不确定，$+1$ 表示重复。输出中不需要单位。程序必须是独立完整的，且不需要用户输入。",
            "solution": "该问题要求制定并实现一种统计方法，用于从短读长测序数据中检测拷贝数变异（CNV），同时考虑基因组可图谱性的混杂效应。该解决方案包含三个主要组成部分：一个读段覆盖度的统计模型、一个用于处理低数据质量区域的筛选方案，以及一个用于评估观测到的覆盖度偏差显著性的假设检验框架。\n\n推导和步骤如下：\n\n首先，我们建立观测读段计数的统计模型。在任意给定的基因组位置 $i$，覆盖该位置的读段数 $C_i$ 被建模为一个服从泊松分布的随机变量，记为 $C_i \\sim \\mathrm{Poisson}(\\lambda_i)$。参数 $\\lambda_i$ 代表该位置的期望（或平均）覆盖度。\n\n其次，我们通过结合生物学和技术因素来对期望覆盖度 $\\lambda_i$ 进行建模。问题假定 $\\lambda_i$ 是三个主要组成部分的函数：\n1.  总体测序深度，由一个“正常”基因组区域中的基线平均覆盖度 $\\mu$ 表示。正常区域被定义为二倍体（拷贝数为 $2$）且完全可图谱。\n2.  位置 $i$ 处真实的、潜在的绝对拷贝数，记为 $\\mathrm{CN}$。覆盖度与拷贝数成正比。我们通过二倍体状态对其进行归一化，得到因子 $\\frac{\\mathrm{CN}}{2}$。\n3.  位置 $i$ 处的比对可图谱性 $m_i \\in [0, 1]$。该分数代表源于位置 $i$ 的读段能够被唯一且正确地比对回参考基因组的概率。不可唯一比对的读段通常被丢弃或其比对质量分数被降低，从而导致观测覆盖度的有效降低。\n综合这些因素，期望覆盖度的模型由下式给出：\n$$\n\\lambda_i = \\mathbb{E}[C_i] = \\mu \\cdot m_i \\cdot \\frac{\\mathrm{CN}}{2}\n$$\n\n我们的目标是为一个包含碱基 $\\{1, \\dots, n\\}$ 的基因组窗口估计 $\\mathrm{CN}$，并检验它是否偏离二倍体零假设 $H_0: \\mathrm{CN} = 2$。\n\n为了推导拷贝数估计量，我们首先为每个碱基定义一个归一化量，以校正测序深度（$\\mu$）和可图谱性（$m_i$）的已知效应。我们定义 $X_i$：\n$$\nX_i = \\frac{C_i}{\\mu \\cdot m_i}\n$$\n代入 $C_i$ 的期望，得到 $X_i$ 的期望为：\n$$\n\\mathbb{E}[X_i] = \\frac{\\mathbb{E}[C_i]}{\\mu \\cdot m_i} = \\frac{\\mu \\cdot m_i \\cdot \\frac{\\mathrm{CN}}{2}}{\\mu \\cdot m_i} = \\frac{\\mathrm{CN}}{2}\n$$\n这表明 $X_i$ 是 $\\frac{\\mathrm{CN}}{2}$ 的一个无偏估计量。为了获得基因组窗口上更稳健的 $\\mathrm{CN}$ 估计，我们可以对这些单位置估计值求平均。问题在聚合前指定了一个筛选步骤。我们只考虑索引集合 $\\mathcal{I} = \\{ i \\in \\{1,\\dots,n\\} : m_i \\ge t_{\\mathrm{map}} \\}$，其中 $t_{\\mathrm{map}}$ 是一个最低可图谱性阈值。然后，窗口的拷贝数估计量 $\\widehat{\\mathrm{CN}}$ 被定义为在集合 $\\mathcal{I}$ 上对 $2 \\cdot X_i$ 的估计量的平均值：\n$$\n\\widehat{\\mathrm{CN}} = \\frac{1}{|\\mathcal{I}|} \\sum_{i \\in \\mathcal{I}} (2 \\cdot X_i) = \\frac{2}{|\\mathcal{I}|} \\sum_{i \\in \\mathcal{I}} \\frac{C_i}{\\mu \\cdot m_i}\n$$\n这是 $\\mathrm{CN}$ 的一个矩估计量。根据期望的线性性质，它是无偏的：$\\mathbb{E}[\\widehat{\\mathrm{CN}}] = \\mathrm{CN}$。\n\n为了进行统计检验，我们必须确定 $\\widehat{\\mathrm{CN}}$ 在零假设 $H_0: \\mathrm{CN} = 2$ 下的分布。根据中心极限定理，足够大量的独立随机变量之和（以及其均值）将近似服从正态分布。我们假设读段计数 $C_i$ 在不同位置上是独立的。\n在 $H_0$ 下，$\\widehat{\\mathrm{CN}}$ 的均值为 $\\mathbb{E}[\\widehat{\\mathrm{CN}} \\mid H_0] = 2$。\n接下来，我们推导 $\\widehat{\\mathrm{CN}}$ 在 $H_0$ 下的方差，记为 $\\mathrm{Var}_0(\\widehat{\\mathrm{CN}})$。首先，我们求 $X_i$ 的方差：\n$$\n\\mathrm{Var}(X_i) = \\mathrm{Var}\\left(\\frac{C_i}{\\mu \\cdot m_i}\\right) = \\frac{1}{(\\mu \\cdot m_i)^2} \\mathrm{Var}(C_i)\n$$\n泊松分布的一个关键性质是其方差等于其均值，即 $\\mathrm{Var}(C_i) = \\lambda_i$。在 $H_0: \\mathrm{CN} = 2$ 下，平均覆盖度为 $\\lambda_{i,0} = \\mu \\cdot m_i \\cdot \\frac{2}{2} = \\mu \\cdot m_i$。因此，$X_i$ 在零假设下的方差为：\n$$\n\\mathrm{Var}(X_i \\mid H_0) = \\frac{\\lambda_{i,0}}{(\\mu \\cdot m_i)^2} = \\frac{\\mu \\cdot m_i}{(\\mu \\cdot m_i)^2} = \\frac{1}{\\mu \\cdot m_i}\n$$\n这与提供的公式 $\\frac{\\mathrm{CN}_0}{2 \\cdot \\mu \\cdot m_i}$（其中 $\\mathrm{CN}_0 = 2$）是一致的。\n假设 $X_i$ 变量是独立的，则它们的和的方差是它们方差的和。因此，$\\widehat{\\mathrm{CN}}$ 在 $H_0$ 下的方差是：\n$$\n\\mathrm{Var}_0(\\widehat{\\mathrm{CN}}) = \\mathrm{Var}\\left(\\frac{2}{|\\mathcal{I}|} \\sum_{i \\in \\mathcal{I}} X_i \\mid H_0 \\right) = \\left(\\frac{2}{|\\mathcal{I}|}\\right)^2 \\sum_{i \\in \\mathcal{I}} \\mathrm{Var}(X_i \\mid H_0) = \\frac{4}{|\\mathcal{I}|^2} \\sum_{i \\in \\mathcal{I}} \\frac{1}{\\mu \\cdot m_i}\n$$\n在定义了均值和方差之后，我们可以构建一个 $z$-分数检验统计量，它以标准差为单位来衡量估计值与其零假设值的偏差：\n$$\nz = \\frac{\\widehat{\\mathrm{CN}} - \\mathbb{E}[\\widehat{\\mathrm{CN}} \\mid H_0]}{\\sqrt{\\mathrm{Var}_0(\\widehat{\\mathrm{CN}})}} = \\frac{\\widehat{\\mathrm{CN}} - 2}{\\sqrt{\\mathrm{Var}_0(\\widehat{\\mathrm{CN}})}}\n$$\n在零假设下，这个 $z$-分数近似服从标准正态分布 $\\mathcal{N}(0, 1)$。\n\n在进行检验之前，会应用一个筛选程序来确保检出结果的可靠性。这一点至关重要，因为低可图谱性区域会产生充满噪声和偏差的覆盖度数据，而非常短的窗口则缺乏统计功效。指定的筛选器如下：\n1.  单位碱基可图谱性筛选：只有可图谱性 $m_i \\ge t_{\\mathrm{map}}$ 的碱基 $i$ 才被纳入分析。这定义了集合 $\\mathcal{I}$。\n2.  窗口质量筛选：\n    -   保留的碱基数量必须满足一个最小计数：$|\\mathcal{I}| \\ge n_{\\min}$。\n    -   保留的碱基比例必须满足一个最小阈值：$\\frac{|\\mathcal{I}|}{n} \\ge f_{\\min}$，其中 $n$ 是原始窗口中的总碱基数。\n如果一个窗口未能通过任何一个质量筛选，它就被视为不确定，输出为 $0$（中性）。\n\n最后，对于通过筛选的窗口，CNV状态将根据计算出的 $z$-分数和一个预定义的显著性阈值 $z_{\\mathrm{thr}}$ 进行分类。使用一个对称的阈值来检出删除或重复：\n- 如果 $z \\ge z_{\\mathrm{thr}}$，覆盖度显著高于零假设下的预期，意味着发生了重复。输出为 $+1$。\n- 如果 $z \\le -z_{\\mathrm{thr}}$，覆盖度显著低于预期，意味着发生了删除。输出为 $-1$。\n- 如果 $-z_{\\mathrm{thr}}  z  z_{\\mathrm{thr}}$，偏差不具有统计显著性。输出为 $0$（中性）。\n\n这一完整的方案提供了一种有原则的、有统计学基础的CNV检测方法，它能正确地对可图谱性进行归一化，并对数据质量进行筛选，从而减少了假阳性的常见来源。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the CNV detection problem for the given test suite.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"id\": 1,\n            \"mu\": 30.0, \"t_map\": 0.5, \"f_min\": 0.6, \"n_min\": 5, \"z_thr\": 3.0,\n            \"C\": np.array([31, 29, 33, 30, 28, 32, 31, 30, 29, 34]),\n            \"m\": np.array([0.99, 0.98, 1.0, 0.97, 0.96, 0.99, 0.98, 1.0, 0.95, 0.97])\n        },\n        {\n            \"id\": 2,\n            \"mu\": 30.0, \"t_map\": 0.5, \"f_min\": 0.6, \"n_min\": 5, \"z_thr\": 3.0,\n            \"C\": np.array([9, 11, 8, 12, 10, 9, 10, 9, 8, 10]),\n            \"m\": np.array([0.30, 0.35, 0.25, 0.40, 0.33, 0.28, 0.31, 0.29, 0.27, 0.34])\n        },\n        {\n            \"id\": 3,\n            \"mu\": 30.0, \"t_map\": 0.5, \"f_min\": 0.6, \"n_min\": 5, \"z_thr\": 3.0,\n            \"C\": np.array([15, 14, 16, 13, 17, 15, 14, 16]),\n            \"m\": np.array([0.98, 0.97, 0.99, 0.96, 0.97, 0.98, 0.99, 0.97])\n        },\n        {\n            \"id\": 4,\n            \"mu\": 30.0, \"t_map\": 0.5, \"f_min\": 0.6, \"n_min\": 5, \"z_thr\": 3.0,\n            \"C\": np.array([36, 31, 27, 18, 25, 41, 38, 23, 20, 31, 29, 27]),\n            \"m\": np.array([0.8, 0.7, 0.6, 0.4, 0.55, 0.9, 0.85, 0.5, 0.45, 0.7, 0.65, 0.6])\n        },\n        {\n            \"id\": 5,\n            \"mu\": 30.0, \"t_map\": 0.5, \"f_min\": 0.6, \"n_min\": 5, \"z_thr\": 3.0,\n            \"C\": np.array([30, 31, 29]),\n            \"m\": np.array([0.95, 0.96, 0.97])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        C = case[\"C\"]\n        m = case[\"m\"]\n        mu = case[\"mu\"]\n        t_map = case[\"t_map\"]\n        f_min = case[\"f_min\"]\n        n_min = case[\"n_min\"]\n        z_thr = case[\"z_thr\"]\n        \n        n = len(C) # Original window size\n\n        # Step 1: Apply mappability filter to get the set of indices I\n        mappable_indices = np.where(m >= t_map)[0]\n        I_size = len(mappable_indices)\n        \n        # Step 2: Apply window quality filters\n        if I_size  n_min or (I_size / n)  f_min:\n            results.append(0)\n            continue\n            \n        C_I = C[mappable_indices]\n        m_I = m[mappable_indices]\n\n        # Step 3: Calculate the CNV estimate\n        # X_i = C_i / (mu * m_i) for i in I\n        X_I = C_I / (mu * m_I)\n        \n        # CN_hat = (2 / |I|) * sum(X_i) = 2 * mean(X_I)\n        CN_hat = 2.0 * np.mean(X_I)\n        \n        # Step 4: Calculate the variance of the estimator under the null (CN=2)\n        # Var_0(CN_hat) = (4 / |I|^2) * sum(1 / (mu * m_i)) for i in I\n        var_sum_term = np.sum(1.0 / (mu * m_I))\n        var_CN_hat_null = (4.0 / (I_size**2)) * var_sum_term\n        \n        # Step 5: Compute the z-score\n        # Prevent division by zero if variance is somehow zero\n        if var_CN_hat_null = 0:\n            results.append(0) # Inconclusive if variance is not positive\n            continue\n\n        std_dev_CN_hat_null = np.sqrt(var_CN_hat_null)\n        z_score = (CN_hat - 2.0) / std_dev_CN_hat_null\n\n        # Step 6: Classify the CNV state\n        if z_score = -z_thr:\n            results.append(-1) # Deletion\n        elif z_score >= z_thr:\n            results.append(1) # Duplication\n        else:\n            results.append(0) # Neutral\n            \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}