{
    "hands_on_practices": [
        {
            "introduction": "识别基因组中的转录因子结合位点是理解基因调控网络的第一步。位置权重矩阵 (Position Weight Matrix, PWM) 是生物信息学中用于表示和扫描这些短DNA基序 (motif) 的核心概率模型。本练习 () 将引导你从统计学的基本原理出发，推导用于基序匹配的对数几率评分函数，并将其应用于一个具体序列的评分计算，从而让你掌握识别潜在调控元件的关键技能。",
            "id": "4560143",
            "problem": "一个在染色质结构表观遗传调控中与绝缘子功能有关的候选转录因子结合位点基序，是根据染色质免疫共沉淀后测序（ChIP-seq）得到的高置信度峰值建模的。该基序由一个位置权重矩阵（PWM）表示，形式上是长度为 $L$、基于核苷酸 $b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 的位置特异性多项式参数矩阵 $P=\\{p_{i,b}\\}$，其中每个位置 $i \\in \\{1,\\dots,L\\}$ 都满足 $\\sum_{b} p_{i,b} = 1$ 和 $p_{i,b} \\ge 0$。基因组背景被建模为一个独立同分布的多项式，其概率为 $q=\\{q_{\\mathrm{A}}, q_{\\mathrm{C}}, q_{\\mathrm{G}}, q_{\\mathrm{T}}\\}$，满足 $\\sum_{b} q_{b} = 1$。\n\n从第一性原理出发，将位置权重矩阵（PWM）和在一般背景下的位置信息含量定义为基序位置分布与背景之间的库尔贝克-莱布勒散度（KLD）。然后，从序列在PWM和背景模型下的似然出发，并引用转录因子结合基序的标准位置独立性假设，推导对数似然比评分函数。最后，使用自然对数计算以下实例的对数优势比基序分数。\n\nPWM和背景均使用核苷酸顺序 $(\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T})$。设基序长度为 $L=8$，PWM为\n$$\nP \\;=\\; \\begin{pmatrix}\n0.05  0.10  0.75  0.10 \\\\\n0.10  0.60  0.20  0.10 \\\\\n0.05  0.10  0.80  0.05 \\\\\n0.10  0.10  0.20  0.60 \\\\\n0.65  0.10  0.15  0.10 \\\\\n0.15  0.10  0.65  0.10 \\\\\n0.10  0.70  0.10  0.10 \\\\\n0.55  0.15  0.15  0.15\n\\end{pmatrix}.\n$$\n设基因组背景为\n$$\nq \\;=\\; (0.30,\\, 0.20,\\, 0.22,\\, 0.28).\n$$\n考虑长度为8的序列\n$$\n\\mathbf{b} \\;=\\; (\\mathrm{G},\\, \\mathrm{C},\\, \\mathrm{G},\\, \\mathrm{T},\\, \\mathrm{A},\\, \\mathrm{G},\\, \\mathrm{C},\\, \\mathrm{A}).\n$$\n\n计算序列 $\\mathbf{b}$ 在模型 $P$ 下相对于背景 $q$ 的自然对数对数优势比基序分数，以奈特（nats）为单位表示，并将您的答案四舍五入到4位有效数字。您最终报告的值必须是一个实数。",
            "solution": "该问题要求分三部分作答：位置权重矩阵（PWM）和位置信息含量的理论定义，对数似然比评分函数的推导，以及针对给定DNA序列、PWM和背景模型的具体计算。\n\n### 问题验证\n\n首先，评估问题陈述的有效性。\n\n1.  **提取已知条件**：\n    *   位置权重矩阵（PWM）是一个长度为 $L$、基于核苷酸 $b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 的基序的位置特异性多项式参数矩阵 $P=\\{p_{i,b}\\}$。\n    *   对于每个位置 $i \\in \\{1,\\dots,L\\}$，概率之和为1：$\\sum_{b} p_{i,b} = 1$，且为非负数：$p_{i,b} \\ge 0$。\n    *   基因组背景是一个独立同分布（i.i.d.）的多项式模型，其概率为 $q=\\{q_{\\mathrm{A}}, q_{\\mathrm{C}}, q_{\\mathrm{G}}, q_{\\mathrm{T}}\\}$，其中 $\\sum_{b} q_{b} = 1$。\n    *   指定的核苷酸顺序为 $(\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T})$。\n    *   基序长度为 $L=8$。\n    *   给定的PWM为：\n        $$\n        P \\;=\\; \\begin{pmatrix}\n        0.05  0.10  0.75  0.10 \\\\\n        0.10  0.60  0.20  0.10 \\\\\n        0.05  0.10  0.80  0.05 \\\\\n        0.10  0.10  0.20  0.60 \\\\\n        0.65  0.10  0.15  0.10 \\\\\n        0.15  0.10  0.65  0.10 \\\\\n        0.10  0.70  0.10  0.10 \\\\\n        0.55  0.15  0.15  0.15\n        \\end{pmatrix}.\n        $$\n    *   背景核苷酸概率为 $q = (0.30, 0.20, 0.22, 0.28)$。\n    *   待评分的特定DNA序列为 $\\mathbf{b} = (\\mathrm{G}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}, \\mathrm{A}, \\mathrm{G}, \\mathrm{C}, \\mathrm{A})$。\n    *   任务是计算自然对数对数优势比基序分数，并四舍五入到4位有效数字。\n\n2.  **使用提取的已知条件进行验证**：\n    *   **科学与事实的合理性**：该问题基于生物信息学中用于建模转录因子结合位点的基石概念，包括PWM、背景模型和对数优势比评分。这些都是标准且成熟的方法。\n    *   **完整性与一致性**：该问题是自洽的。PWM矩阵的行正确地求和为1。例如，对于第1行：$0.05 + 0.10 + 0.75 + 0.10 = 1.00$。这对所有8行都成立。背景概率也求和为1：$0.30 + 0.20 + 0.22 + 0.28 = 1.00$。PWM的维度（$8 \\times 4$）与基序长度（$L=8$）和字母表大小（4个核苷酸）一致。计算所需的所有数据均已提供。\n    *   **适定性**：该问题要求基于明确定义的数学公式进行计算。存在一个唯一、稳定且有意义的解。\n\n3.  **结论**：该问题有效。\n\n### 第1部分：从第一性原理出发的定义\n\n**位置权重矩阵（PWM）**，记作 $P$，是一个表示固定长度 $L$ 的序列基序的概率模型。它是一个 $L \\times k$ 的矩阵，其中 $k$ 是字母表的大小（此处对于DNA核苷酸 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$，$k=4$）。矩阵的每个元素 $p_{i,b}$ 指定了在基序的第 $i$ 个位置上观测到核苷酸 $b$ 的概率。该模型假设位置之间相互独立。对于每个位置 $i \\in \\{1, \\dots, L\\}$，概率集合 $\\{p_{i,b}\\}_{b \\in \\{\\mathrm{A,C,G,T}\\}}$ 构成一个多项式分布，因此 $\\sum_{b} p_{i,b} = 1$ 且 $p_{i,b} \\ge 0$。\n\n在位置 $i$ 的**位置信息含量**，记作 $I_i$，量化了该位置的保守性。它衡量了关于位置 $i$ 的核苷酸的不确定性相对于背景分布 $q$ 的减少程度。这被正式定义为从背景分布 $q$ 到基序的位置分布 $p_{i,\\cdot} = (p_{i,\\mathrm{A}}, p_{i,\\mathrm{C}}, p_{i,\\mathrm{G}}, p_{i,\\mathrm{T}})$ 的库尔贝克-莱布勒散度（KLD）。使用自然对数，信息含量以奈特（nats）为单位表示为：\n$$\nI_i = D_{\\mathrm{KL}}(p_{i,\\cdot} || q) = \\sum_{b \\in \\{\\mathrm{A,C,G,T}\\}} p_{i,b} \\ln\\left(\\frac{p_{i,b}}{q_b}\\right)\n$$\n\n### 第2部分：对数似然比评分函数的推导\n\n为了区分真实的基序实例和背景DNA，我们构建一个假设检验。设 $\\mathbf{b} = (b_1, b_2, \\dots, b_L)$ 是一个长度为 $L$ 的DNA序列。\n\n*   **假设 $M$（基序模型）**：序列 $\\mathbf{b}$ 由基序模型 $P$ 生成。\n*   **假设 $B$（背景模型）**：序列 $\\mathbf{b}$ 由背景模型 $q$ 生成。\n\n在PWM模型固有的位置独立性假设下，观察到序列 $\\mathbf{b}$ 在假设 $M$ 下的似然是观察到每个碱基 $b_i$ 在其相应位置 $i$ 的概率的乘积：\n$$\n\\mathbb{P}(\\mathbf{b} | M) = \\prod_{i=1}^{L} p_{i, b_i}\n$$\n在独立同分布的背景模型下，观察到序列 $\\mathbf{b}$ 在假设 $B$ 下的似然是每个碱基的背景概率的乘积：\n$$\n\\mathbb{P}(\\mathbf{b} | B) = \\prod_{i=1}^{L} q_{b_i}\n$$\n**似然比**比较了这两个概率：\n$$\n\\frac{\\mathbb{P}(\\mathbf{b} | M)}{\\mathbb{P}(\\mathbf{b} | B)} = \\frac{\\prod_{i=1}^{L} p_{i, b_i}}{\\prod_{i=1}^{L} q_{b_i}} = \\prod_{i=1}^{L} \\frac{p_{i, b_i}}{q_{b_i}}\n$$\n为了数值稳定性和可加性，我们取该比率的对数。这就得到了**对数似然比**或**对数优势比分数** $S(\\mathbf{b})$。使用自然对数：\n$$\nS(\\mathbf{b}) = \\ln\\left( \\prod_{i=1}^{L} \\frac{p_{i, b_i}}{q_{b_i}} \\right) = \\sum_{i=1}^{L} \\ln\\left( \\frac{p_{i, b_i}}{q_{b_i}} \\right)\n$$\n该函数通过对位置特异性的对数优势比求和来为序列评分，其中每一项反映了观察到的核苷酸在基序模型下比在背景模型下可能性大多少。得到的总和就是对数优势比基序分数。\n\n### 第3部分：特定实例的计算\n\n我们给定的序列是 $\\mathbf{b} = (\\mathrm{G}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}, \\mathrm{A}, \\mathrm{G}, \\mathrm{C}, \\mathrm{A})$。PWM列和背景向量的核苷酸顺序是 $(\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T})$。背景概率为 $q = (q_{\\mathrm{A}}, q_{\\mathrm{C}}, q_{\\mathrm{G}}, q_{\\mathrm{T}}) = (0.30, 0.20, 0.22, 0.28)$。\n\n分数 $S(\\mathbf{b})$ 通过对每个位置 $i=1, \\dots, 8$ 的对数优势比求和来计算：\n$$\nS(\\mathbf{b}) = \\sum_{i=1}^{8} \\ln\\left( \\frac{p_{i, b_i}}{q_{b_i}} \\right)\n$$\n我们来计算每一项：\n*   位置 $1$：碱基 $b_1 = \\mathrm{G}$。$p_{1,\\mathrm{G}} = 0.75$, $q_{\\mathrm{G}} = 0.22$。分数 = $\\ln(0.75 / 0.22)$。\n*   位置 $2$：碱基 $b_2 = \\mathrm{C}$。$p_{2,\\mathrm{C}} = 0.60$, $q_{\\mathrm{C}} = 0.20$。分数 = $\\ln(0.60 / 0.20) = \\ln(3)$。\n*   位置 $3$：碱基 $b_3 = \\mathrm{G}$。$p_{3,\\mathrm{G}} = 0.80$, $q_{\\mathrm{G}} = 0.22$。分数 = $\\ln(0.80 / 0.22)$。\n*   位置 $4$：碱基 $b_4 = \\mathrm{T}$。$p_{4,\\mathrm{T}} = 0.60$, $q_{\\mathrm{T}} = 0.28$。分数 = $\\ln(0.60 / 0.28)$。\n*   位置 $5$：碱基 $b_5 = \\mathrm{A}$。$p_{5,\\mathrm{A}} = 0.65$, $q_{\\mathrm{A}} = 0.30$。分数 = $\\ln(0.65 / 0.30)$。\n*   位置 $6$：碱基 $b_6 = \\mathrm{G}$。$p_{6,\\mathrm{G}} = 0.65$, $q_{\\mathrm{G}} = 0.22$。分数 = $\\ln(0.65 / 0.22)$。\n*   位置 $7$：碱基 $b_7 = \\mathrm{C}$。$p_{7,\\mathrm{C}} = 0.70$, $q_{\\mathrm{C}} = 0.20$。分数 = $\\ln(0.70 / 0.20) = \\ln(3.5)$。\n*   位置 $8$：碱基 $b_8 = \\mathrm{A}$。$p_{8,\\mathrm{A}} = 0.55$, $q_{\\mathrm{A}} = 0.30$。分数 = $\\ln(0.55 / 0.30)$。\n\n将这些值相加：\n$S(\\mathbf{b}) = \\ln(\\frac{0.75}{0.22}) + \\ln(\\frac{0.60}{0.20}) + \\ln(\\frac{0.80}{0.22}) + \\ln(\\frac{0.60}{0.28}) + \\ln(\\frac{0.65}{0.30}) + \\ln(\\frac{0.65}{0.22}) + \\ln(\\frac{0.70}{0.20}) + \\ln(\\frac{0.55}{0.30})$\n$S(\\mathbf{b}) \\approx 1.226402 + 1.098612 + 1.290944 + 0.762140 + 0.773190 + 1.083319 + 1.252763 + 0.606136$\n$S(\\mathbf{b}) \\approx 8.093506$\n\n问题要求答案四舍五入到4位有效数字。计算出的值为 $8.093506...$。第五位有效数字是 $5$，因此我们将第四位数字向上取整。\n$S(\\mathbf{b}) \\approx 8.094$。",
            "answer": "$$\n\\boxed{8.094}\n$$"
        },
        {
            "introduction": "DNA甲基化是一种关键的表观遗传标记，它通过调控基因活性在发育和疾病中扮演重要角色。从高通量实验数据中准确量化甲基化水平是进行下游分析的基础。本练习 () 聚焦于两种常用的甲基化度量：Beta值 ($β$) 和M值。通过计算这些值并从第一性原理分析它们的统计特性，你将理解为何M值因其更优的方差稳定性（方差齐性）而通常成为差异甲基化分析的首选，这是保证分析结果可靠性的重要考量。",
            "id": "4560141",
            "problem": "您正在分析位于一个调节基因启动子活性的增强子中的单个胞嘧啶-磷酸-鸟嘌呤（CpG）位点的脱氧核糖核酸（DNA）甲基化情况。在一个Illumina甲基化芯片上，某个生物样本在此CpG位点的甲基化和非甲基化荧光强度被记录为甲基化通道 $M = 800$ 和非甲基化通道 $U = 200$。在预处理中使用了一个小的正偏移量 $\\alpha = 100$，以提高下游分析中的数值稳定性。根据基于芯片的甲基化分析中的标准定义，Beta值是包含偏移量后在 $[0,1]$ 区间上的甲基化信号分数，而 $M$ 值是Beta值的以2为底的logit变换。\n\n任务：\n- 根据给定的 $M$、$U$ 和 $\\alpha$ 计算此CpG位点的Beta值和 $M$ 值。\n- 然后，从变换如何影响方差的基本原理以及荧光强度在对数尺度上公认的行为出发，确定哪个选项同时报告了正确的计算值，并为 M 值在线性建模队列规模数据时，为何通常在整个甲基化范围内比Beta值表现出更好的方差齐性提供了正确的解释。\n\n选择一个选项。\n\nA. Beta值 $= \\dfrac{800}{800+200+100} \\approx 0.7273$；$M$ 值 $= \\log_2\\!\\left(\\dfrac{0.7273}{1-0.7273}\\right) \\approx 1.415$。解释：因为Beta值是 $[0,1]$ 上的有界非线性比例，其方差依赖于其均值；相比之下，M值本质上是一个将 $[0,1]$ 映射到 $\\mathbb{R}$ 的对数比率（logit），并且在对数强度尺度上误差近似为加性和方差齐性的情况下，对数值的差异具有近似恒定的方差。因此，logit变换稳定了整个动态范围内的方差，从而产生方差更齐性的残差。\n\nB. Beta值 $= \\dfrac{800}{800+200} = 0.8$；$M$ 值 $= \\log_2\\!\\left(\\dfrac{800}{200}\\right) = 2$。解释：对数变换仅仅降低了强度的偏度，这本身就能保证方差齐性，所以无论偏移量或变换细节如何，M值总是方差稳定的。\n\nC. Beta值 $= \\dfrac{800}{800+200+100} \\approx 0.7273$；$M$ 值 $= \\log_2\\!\\left(\\dfrac{800}{200}\\right) = 2$。解释：Beta值因为有界于 $[0,1]$ 而更具方差齐性，而M值是无界的，因此方差不稳定。\n\nD. Beta值 $= \\dfrac{800}{800+200+100} \\approx 0.7273$；$M$ 值 $= \\log_2\\!\\left(\\dfrac{800+100}{200+100}\\right) \\approx 1.585$。解释：对两个通道都加上相同的偏移量会使得所有甲基化水平的方差完全恒定，所以M值根据其构造就是方差齐性的。",
            "solution": "我们首先使用基于芯片的甲基化分析中的标准定义来计算Beta值和M值：Beta值是包含偏移量后的甲基化信号分数，而M值是Beta值的以2为底的logit变换。\n\n给定 $M = 800$, $U = 200$, 和 $\\alpha = 100$，Beta值为\n$$\n\\beta \\;=\\; \\frac{M}{M + U + \\alpha}\n\\;=\\;\n\\frac{800}{800 + 200 + 100}\n\\;=\\;\n\\frac{800}{1100}\n\\;\\approx\\;\n0.7272727\\ldots \\;\\approx\\; 0.7273.\n$$\n\n$M$值是$\\beta$的以2为底的logit变换：\n$$\nM\\text{-value} \\;=\\; \\log_2\\!\\left(\\frac{\\beta}{1-\\beta}\\right)\n\\;=\\;\n\\log_2\\!\\left(\\frac{0.7272727\\ldots}{1 - 0.7272727\\ldots}\\right)\n\\;=\\;\n\\log_2\\!\\left(\\frac{0.7272727\\ldots}{0.2727272\\ldots}\\right)\n\\;=\\;\n\\log_2(2.6666\\ldots)\n\\;\\approx\\;\n1.415.\n$$\n\n我们现在从基本原理来讨论方差齐性。\n\n基本考虑：\n- 来自甲基化和非甲基化通道的荧光强度通常近似服从对数正态分布，因此在对数尺度上，误差可以被建模为在很宽的动态范围内近似为加性且接近方差齐性。如果我们记 $X = \\log_2 M$ 和 $Y = \\log_2 U$，那么一个常见的工作模型是 $X = \\mu_X + \\varepsilon_X$ 和 $Y = \\mu_Y + \\varepsilon_Y$，其中 $\\operatorname{Var}(\\varepsilon_X) \\approx \\operatorname{Var}(\\varepsilon_Y) \\approx \\sigma^2$ 且协方差不大。\n- Beta值是关于 $(M,U)$ 对在 $[0,1]$ 上的有界非线性变换，具体为 $\\beta = M/(M+U+\\alpha)$。这种有界的非线性映射内在地引入了均值-方差耦合：$M$ 或 $U$ 的变化会转化为 $\\beta$ 的不同大小的变化，这取决于$\\beta$的位置（接近0、接近1或在中间）。\n- M值是$\\beta$的以2为底的logit变换。在$\\alpha=0$的特殊情况下，它在代数上等于一个对数比率：\n$$\n\\log_2\\!\\left(\\frac{\\beta}{1-\\beta}\\right)\n=\n\\log_2\\!\\left(\\frac{M}{U}\\right).\n$$\n这个恒等式表明，M值本质上是对数强度之差，即 $X - Y$。\n\nM值的方差齐性机制：\n- 在上述对数强度模型下，$\\operatorname{Var}(X - Y) = \\operatorname{Var}(X) + \\operatorname{Var}(Y) - 2\\operatorname{Cov}(X,Y) \\approx 2\\sigma^2 - 2\\operatorname{Cov}(X,Y)$，当协方差很小或变化缓慢时，这个值在不同平均信号水平上是近似恒定的。因此，M值的方差近似独立于平均甲基化水平，从而产生更具方差齐性的响应，适合线性建模。\n- 当 $\\alpha > 0$ 时，定义为$\\beta$的logit变换的M值不再精确等于 $\\log_2(M/U)$，但对于典型的偏移量和信号范围，它仍然是一个与对数比率密切相关的平滑单调变换；因此它在很大程度上继承了方差稳定的行为。\n\n为什么Beta值是方差异质性的：\n- 考虑映射 $f(M,U) = \\beta = M/(M+U+\\alpha)$。使用delta方法进行一阶近似，并假设 $M$ 和 $U$ 有小的独立扰动，可得\n$$\n\\frac{\\partial f}{\\partial M} = \\frac{U+\\alpha}{(M+U+\\alpha)^2} = \\frac{1-\\beta}{M+U+\\alpha}, \n\\quad\n\\frac{\\partial f}{\\partial U} = -\\frac{M}{(M+U+\\alpha)^2} = -\\frac{\\beta}{M+U+\\alpha}.\n$$\n如果 $M$ 和 $U$ 在线性尺度上的绝对方差不是恒定的，而是随信号强度的增加而增加（如对数正态类行为所暗示的），那么通过这些导数和 $(M,U)$ 的尺度，在 $\\beta$ 中引入的方差将依赖于 $\\beta$，从而产生依赖于均值的方差。更普遍地说，有界比例表现出均值-方差耦合（例如，在二项抽样中，$\\operatorname{Var}(\\beta)$ 与 $\\beta(1-\\beta)$ 成比例），这使得在Beta值尺度上进行方差齐性建模变得困难。\n\n综上所述，这些要点解释了为什么M值（近似于强度的对数比率）在整个甲基化范围内往往比Beta值表现出明显更强的方差齐性。\n\n逐项分析：\n\n- 选项 A：\n  - 计算：$\\beta = 800/1100 \\approx 0.7273$ 且 $M$-值 $= \\log_2(0.7273/0.2727) \\approx \\log_2(2.6667) \\approx 1.415$。这些与我们的计算结果相符。\n  - 解释：正确。它指出了$\\beta$的有界性和均值-方差耦合，M值的近似对数比率性质，以及对数尺度上的加性和近似恒定方差，这些导致了对数值的差异具有更强的方差齐性。\n\n- 选项 B：\n  - 计算：忽略了 $\\alpha$，得到 $\\beta = 0.8$ 和 $M$-值 $= 2$，这与包含偏移量的定义相矛盾。数值计算不正确。\n  - 解释：不正确。降低偏度本身并不能保证方差齐性，并且它忽略了对数比率结构和偏移量处理的关键作用。\n\n- 选项 C：\n  - 计算：使用了正确的 $\\beta \\approx 0.7273$，但将M值取为 $\\log_2(800/200) = 2$，这不符合在 $\\alpha > 0$ 时 $\\beta$ 的以2为底的logit变换的定义。M值不正确。\n  - 解释：不正确。它颠倒了关于方差齐性的论断，声称Beta值更具方差齐性，这与经验和理论见解相反。\n\n- 选项 D：\n  - 计算：报告的M值为 $\\log_2((M+\\alpha)/(U+\\alpha)) \\approx \\log_2(900/300) \\approx 1.585$，这并非给定定义（此处的M值应为$\\beta$的以2为底的logit变换）。根据所述定义，计算不正确。\n  - 解释：不正确。添加一个恒定的偏移量并不会使所有甲基化水平的方差都完全恒定；它防止了除以零的不稳定性，但不能强制实现完美的方差齐性。\n\n因此，只有选项A是完全正确的。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在系统层面理解基因调控，需要我们将遗传变异、表观遗传修饰和基因表达等多个层面联系起来，并探索它们之间的因果路径。中介分析 (Mediation Analysis) 提供了一个强大的统计框架，用于检验“基因型 → 表观遗传 → 表达”这类假说，即遗传变异是否通过影响表观遗传标记来间接调控基因表达。在本练习 () 中，你将通过模拟数据并实施一个完整的中介分析流程，包括构建多个回归模型和应用Sobel检验，从而掌握从相关性走向因果推断的高级分析技能。",
            "id": "4560084",
            "problem": "给定一个概念模型，其中脱氧核糖核酸（DNA）基因型中的单核苷酸多态性（SNPs）影响某个位点的胞嘧啶甲基化，而甲基化反过来又影响信使核糖核酸的表达。分析目标是检验中介方向性，特别是通过条件分析和用于间接效应的 Sobel 检验，来确定基因型是否主要通过甲基化影响表达。\n\n从核心定义和广为接受的原则出发：\n- 分子生物学的中心法则指出，DNA 的信息通过核糖核酸流向蛋白质，而表观遗传调控则调节转录输出。在统计基因组学中，表达数量性状位点（eQTL）被定义为与表达水平相关的 DNA 变异，甲基化数量性状位点（meQTL）被定义为与甲基化水平相关的 DNA 变异。\n- 普通最小二乘（OLS）线性回归模型将响应的期望描述为预测变量的线性函数。对于一个观测到的响应向量 $y \\in \\mathbb{R}^{n}$ 和一个设计矩阵 $X \\in \\mathbb{R}^{n \\times p}$，OLS 估计量为 $\\hat{\\beta} = (X^{\\top}X)^{-1}X^{\\top}y$，残差为 $r = y - X\\hat{\\beta}$，残差方差为 $\\hat{\\sigma}^{2} = \\lVert r \\rVert^{2} / (n - p)$，估计量协方差为 $\\mathrm{Var}(\\hat{\\beta}) = \\hat{\\sigma}^{2}(X^{\\top}X)^{-1}$。系数标准误是 $\\mathrm{Var}(\\hat{\\beta})$ 对角线元素的平方根。给定线性模型假设（独立误差，均值为零，方差恒定，且 $X$ 为满秩），t-统计量 $t_{j} = \\hat{\\beta}_{j} / \\mathrm{SE}(\\hat{\\beta}_{j})$ 服从具有 $n - p$ 个自由度的学生t分布。用于线性中介下间接效应的 Sobel 检验利用路径系数及其方差的乘积来构建一个正态近似检验统计量。\n- 在 Hardy–Weinberg 平衡下，对于一个次要等位基因频率为 $p \\in (0,1)$ 的双等位基因位点，基因型 $G \\in \\{0,1,2\\}$ 的概率为 $\\mathbb{P}(G=0) = (1-p)^{2}$，$\\mathbb{P}(G=1) = 2p(1-p)$，以及 $\\mathbb{P}(G=2) = p^{2}$。\n\n按如下方式对变量进行建模，样本大小为 $n$：\n- 基因型 $G \\in \\{0,1,2\\}^{n}$，在 Hardy–Weinberg 平衡下以次要等位基因频率 $p$ 抽取。\n- 每个样本一个协变量主成分 $C \\sim \\mathcal{N}(0,1)$，用以代表群体结构或批次效应。\n- 甲基化 $M \\in \\mathbb{R}^{n}$，由 $M = a G + \\alpha C + \\varepsilon_{M}$ 生成，其中 $\\varepsilon_{M} \\sim \\mathcal{N}(0,\\sigma_{M}^{2} I)$。\n- 表达 $E \\in \\mathbb{R}^{n}$，由 $E = b M + c G + \\beta C + \\varepsilon_{E}$ 生成，其中 $\\varepsilon_{E} \\sim \\mathcal{N}(0,\\sigma_{E}^{2} I)$。\n\n你的程序必须为每个测试用例执行三次 OLS 分析：\n1. 无条件 eQTL：将 $E$ 对截距、$G$ 和 $C$ 进行回归，以估计总基因型效应 $c$。\n2. meQTL：将 $M$ 对截距、$G$ 和 $C$ 进行回归，以估计基因型到甲基化的效应 $a$。\n3. 带中介变量的条件 eQTL：将 $E$ 对截距、$G$、$M$ 和 $C$ 进行回归，以估计中介变量到表达的效应 $b$ 和直接基因型效应 $c'$。\n\n然后，使用估计的系数及其标准误，计算间接效应 $a \\cdot b$ 的 Sobel 检验。使用双尾检验，显著性阈值为 $\\alpha = 0.05$。根据以下所有标准，将基因型 $\\rightarrow$ 甲基化 $\\rightarrow$ 表达的中介方向性确定为一个布尔值：\n- 对表达的无条件基因型效应是显著的（估计值 $c$ 的双尾 p-value 小于 $0.05$）。\n- 对甲基化的基因型效应是显著的（估计值 $a$ 的双尾 p-value 小于 $0.05$）。\n- 在控制基因型时，甲基化对表达的效应是显著的（估计值 $b$ 的双尾 p-value 小于 $0.05$）。\n- 在控制甲基化时，基因型对表达的直接效应的绝对值减小，即 $\\lvert c' \\rvert  \\lvert c \\rvert$。\n- 间接效应 $a \\cdot b$ 的 Sobel 检验是显著的，其双尾 p-value 小于 $0.05$，且间接效应的符号 $\\mathrm{sign}(a \\cdot b)$ 与总基因型效应的符号 $\\mathrm{sign}(c)$ 一致。\n\n对于每个测试用例，你的程序必须输出一个列表，按顺序包含以下内容：估计的间接效应 $a \\cdot b$（浮点数），Sobel $Z$ 统计量（浮点数），Sobel 双尾 p-value（浮点数），以及方向性中介决策（布尔值）。\n\n单位和角度不适用，所有输出均为无量纲实数或布尔值。最终输出必须是单行，包含所有测试用例的结果，形式为逗号分隔的列表，并用方括号括起来。每个测试用例的结果本身必须是逗号分隔的列表，并用方括号括起来。例如，程序应生成格式为 $[\\,[x_{1},y_{1},z_{1},\\mathrm{True}],\\,[x_{2},y_{2},z_{2},\\mathrm{False}]\\,]$ 的单行，依此类推。在最终输出中，所有浮点数四舍五入到六位小数。\n\n测试套件参数值：\n- 用例 A（清晰的中介作用）：$n=400$，次要等位基因频率 $p=0.3$，$a=0.9$，$b=1.0$，$c=0.1$，$\\sigma_{M}=0.8$，$\\sigma_{E}=1.0$，$\\alpha=0.5$，$\\beta=0.4$，随机种子 $=123$。\n- 用例 B（无甲基化路径）：$n=400$，$p=0.3$，$a=0.0$，$b=1.0$，$c=1.0$，$\\sigma_{M}=0.8$，$\\sigma_{E}=1.0$，$\\alpha=0.5$，$\\beta=0.4$，随机种子 $=456$。\n- 用例 C（无通过甲基化的表达路径）：$n=400$，$p=0.3$，$a=0.8$，$b=0.0$，$c=0.5$，$\\sigma_{M}=0.8$，$\\sigma_{E}=1.0$，$\\alpha=0.5$，$\\beta=0.4$，随机种子 $=789$。\n- 用例 D（高度共线性，小样本）：$n=80$，$p=0.45$，$a=2.0$，$b=1.0$，$c=0.0$，$\\sigma_{M}=0.1$，$\\sigma_{E}=1.0$，$\\alpha=0.0$，$\\beta=0.0$，随机种子 $=101$。\n- 用例 E（负向中介作用）：$n=500$，$p=0.25$，$a=1.0$，$b=-0.8$，$c=0.0$，$\\sigma_{M}=0.7$，$\\sigma_{E}=0.7$，$\\alpha=0.3$，$\\beta=0.3$，随机种子 $=202$。\n\n你的程序必须使用指定的种子确定性地生成数据，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个用例的结果是一个带方括号的逗号分隔列表 $[a\\cdot b, Z, p, \\mathrm{boolean}]$，所有浮点数四舍五入到六位小数，且不含空格。",
            "solution": "该问题要求对一个特定的基因型-甲基化-表达模型进行因果中介分析的模拟验证。解决方案包括根据模型生成数据，进行一系列普通最小二乘（OLS）回归以估计路径系数，然后应用 Sobel 检验和一组决策标准来确定中介作用是否得到支持。对具有不同底层参数的几个测试用例重复此过程。\n\n解决方案的逻辑流程如下：\n1.  **数据生成**：对于每个测试用例，根据所提供的参数模拟一个大小为 $n$ 的数据集。\n2.  **统计分析**：执行三个不同的 OLS 回归来估计总效应、中介路径和直接效应。\n3.  **中介检验**：计算间接效应的 Sobel 检验统计量，并评估一组五个标准，以对中介作用做出最终的布尔决策。\n\n**1. 数据生成**\n\n对于每个测试用例，我们为 $n$ 个个体生成数据。通过为每个用例使用指定的随机种子来确保可复现性。\n\n-   **基因型 ($G$)**：每个个体的基因型 $G$ 是来自集合 $\\{0, 1, 2\\}$ 的一个整数，表示次要等位基因的计数。它是根据 Hardy-Weinberg 平衡和次要等位基因频率 $p$ 从多项分布中抽取的。基因型的概率为：\n    $$ \\mathbb{P}(G=0) = (1-p)^2 $$\n    $$ \\mathbb{P}(G=1) = 2p(1-p) $$\n    $$ \\mathbb{P}(G=2) = p^2 $$\n\n-   **协变量 ($C$)**：一个协变量 $C$，代表诸如群体结构等因素，从标准正态分布中抽取，$C \\sim \\mathcal{N}(0, 1)$。\n\n-   **甲基化 ($M$)**：甲基化水平 $M$ 是作为基因型 $G$ 和协变量 $C$ 的线性函数生成的，并加上一个噪声项 $\\varepsilon_M$：\n    $$ M = a G + \\alpha C + \\varepsilon_M $$\n    其中 $\\varepsilon_M$ 从均值为 $0$、方差为 $\\sigma_{M}^2$ 的正态分布中抽取，即 $\\varepsilon_M \\sim \\mathcal{N}(0, \\sigma_{M}^2)$。\n\n-   **表达 ($E$)**：表达水平 $E$ 是基于甲基化 $M$、基因型 $G$ 和协变量 $C$ 生成的，并加上一个噪声项 $\\varepsilon_E$：\n    $$ E = b M + c' G + \\beta C + \\varepsilon_E $$\n    其中 $c'$ 对应于问题测试套件中名为 $c$ 的参数，代表基因型对表达的真实直接效应。噪声项 $\\varepsilon_E$ 从 $\\mathcal{N}(0, \\sigma_{E}^2)$ 中抽取。\n\n**2. 统计建模：普通最小二乘（OLS）**\n\n分析依赖于 OLS 回归来估计线性模型的系数。对于一个通用线性模型 $y = X\\beta + \\varepsilon$，其中 $y$ 是一个 $n \\times 1$ 的响应向量，$X$ 是一个 $n \\times p$ 的预测变量设计矩阵（包括截距），系数向量 $\\beta$ 的 OLS 估计量是：\n$$ \\hat{\\beta} = (X^{\\top}X)^{-1}X^{\\top}y $$\n这些估计的标准误由估计量的方差导出。首先，从残差 $r = y - X\\hat{\\beta}$ 估计残差方差 $\\hat{\\sigma}^2$：\n$$ \\hat{\\sigma}^2 = \\frac{\\lVert r \\rVert^2}{n-p} = \\frac{r^{\\top}r}{n-p} $$\n其中 $n-p$ 是自由度。系数估计的协方差矩阵则为：\n$$ \\mathrm{Var}(\\hat{\\beta}) = \\hat{\\sigma}^2 (X^{\\top}X)^{-1} $$\n每个系数 $\\hat{\\beta}_j$ 的标准误是该矩阵对应对角线元素的平方根：$\\mathrm{SE}(\\hat{\\beta}_j) = \\sqrt{\\mathrm{Var}(\\hat{\\beta})_{jj}}$。\n\n为了检验每个系数的显著性，计算一个 t-统计量：\n$$ t_j = \\frac{\\hat{\\beta}_j}{\\mathrm{SE}(\\hat{\\beta}_j)} $$\n在零假设 $H_0: \\beta_j=0$ 下，该统计量服从具有 $n-p$ 个自由度的学生 t-分布。然后从该分布计算双尾 p-value。\n\n**3. 中介分析步骤**\n\n拟合三个回归模型以估计相关路径：\n\n-   **模型 1：总效应 ($c_{\\text{total}}$)**。该模型估计基因型对表达的总效应，不考虑中介变量。\n    $$ E \\sim 1 + G + C $$\n    我们拟合此模型以获得估计值 $\\hat{c}_{\\text{total}}$（$G$ 的系数）及其 p-value。问题陈述中将此估计值称为 `$c$`。\n\n-   **模型 2：基因型-中介变量路径 ($a$)**。该模型量化了基因型对中介变量（甲基化）的影响。\n    $$ M \\sim 1 + G + C $$\n    这提供了估计值 $\\hat{a}$（$G$ 的系数）、其标准误 $\\mathrm{SE}(\\hat{a})$ 及其 p-value。\n\n-   **模型 3：中介变量-表达 ($b$) 和直接效应 ($c'$)**。该模型包含中介变量，以在控制基因型的同时估计其对表达的影响。\n    $$ E \\sim 1 + G + M + C $$\n    从此模型中，我们获得估计值 $\\hat{b}$（对于 $M$）、其标准误 $\\mathrm{SE}(\\hat{b})$ 及其 p-value，以及直接效应的估计值 $\\hat{c'}$（对于 $G$）。\n\n**4. 间接效应的 Sobel 检验**\n\n基因型通过甲基化对表达的间接效应由路径系数的乘积 $a \\cdot b$ 量化。Sobel 检验评估此间接效应的统计显著性。检验统计量 $Z$ 使用上述回归中的估计值 $\\hat{a}$、$\\hat{b}$ 及其标准误计算得出：\n$$ Z = \\frac{\\hat{a}\\hat{b}}{\\sqrt{\\hat{a}^2 \\mathrm{SE}(\\hat{b})^2 + \\hat{b}^2 \\mathrm{SE}(\\hat{a})^2}} $$\n在间接效应为零的零假设（$a \\cdot b = 0$）下，$Z$ 近似服从标准正态分布，$Z \\sim \\mathcal{N}(0, 1)$。双尾 p-value 从此标准正态分布计算。\n\n**5. 中介作用的决策标准**\n\n中介作用的最终判定是一个布尔值结果，基于是否满足以下所有五个标准，显著性水平为 $\\alpha = 0.05$：\n\n1.  **显著的总效应**：基因型对表达的总效应 $\\hat{c}_{\\text{total}}$ 必须在统计上是显著的（$p  0.05$）。\n2.  **显著的路径 $a$**：基因型对甲基化的效应 $\\hat{a}$ 必须在统计上是显著的（$p  0.05$）。\n3.  **显著的路径 $b$**：在控制基因型时，甲基化对表达的效应 $\\hat{b}$ 必须在统计上是显著的（$p  0.05$）。\n4.  **效应量减小**：基因型的直接效应 $\\hat{c'}$ 的绝对值必须小于总效应的绝对值，即 $|\\hat{c'}|  |\\hat{c}_{\\text{total}}|$。\n5.  **显著且一致的间接效应**：间接效应 $\\hat{a}\\hat{b}$ 的 Sobel 检验必须是显著的（$p  0.05$），并且间接效应的符号必须与总效应的符号相匹配，即 $\\mathrm{sign}(\\hat{a}\\hat{b}) = \\mathrm{sign}(\\hat{c}_{\\text{total}})$。\n\n当且仅当所有五个条件都满足时，返回 `True` 结果。每个测试用例的最终输出包括估计的间接效应 $\\hat{a}\\hat{b}$、Sobel $Z$ 统计量、Sobel p-value 以及这个最终的布尔决策。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef ols(y: np.ndarray, X: np.ndarray) - tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Performs Ordinary Least Squares (OLS) regression.\n\n    Args:\n        y: Response vector (n_samples,).\n        X: Design matrix (n_samples, n_predictors), including intercept.\n\n    Returns:\n        A tuple containing:\n        - beta_hat: Estimated coefficients.\n        - se_beta: Standard errors of the coefficients.\n        - p_values: Two-tailed p-values for the coefficients.\n    \"\"\"\n    n, p = X.shape\n    df = n - p\n    try:\n        # beta_hat = (X.T @ X)^-1 @ X.T @ y\n        beta_hat = np.linalg.solve(X.T @ X, X.T @ y)\n\n        residuals = y - X @ beta_hat\n        rss = residuals.T @ residuals\n        sigma2_hat = rss / df\n\n        # Covariance matrix of coefficients\n        var_beta_hat = sigma2_hat * np.linalg.inv(X.T @ X)\n        se_beta = np.sqrt(np.diag(var_beta_hat))\n\n        # t-statistics, handle SE=0 case\n        t_stats = np.divide(beta_hat, se_beta, out=np.full_like(beta_hat, np.inf), where=se_beta != 0)\n        \n        # Two-tailed p-values from Student's t-distribution\n        p_values = 2 * stats.t.sf(np.abs(t_stats), df)\n\n        return beta_hat, se_beta, p_values\n    \n    except np.linalg.LinAlgError:\n        # In case of a singular matrix (e.g., perfect collinearity)\n        nan_array = np.full(p, np.nan)\n        return nan_array, nan_array, nan_array\n\n\ndef run_mediation_analysis(n, p_maf, a_true, b_true, c_direct_true, sigma_m, sigma_e, alpha, beta, seed):\n    \"\"\"\n    Runs a full mediation analysis for a single test case.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # 1. Data Generation\n    # Genotype G drawn from Hardy-Weinberg equilibrium probabilities\n    p0 = (1 - p_maf)**2\n    p1 = 2 * p_maf * (1 - p_maf)\n    p2 = p_maf**2\n    G = rng.choice([0, 1, 2], size=n, p=[p0, p1, p2])\n\n    # Covariate C from standard normal distribution\n    C = rng.normal(0, 1, size=n)\n\n    # Methylation M\n    eps_m = rng.normal(0, sigma_m, size=n)\n    M = a_true * G + alpha * C + eps_m\n\n    # Expression E\n    eps_e = rng.normal(0, sigma_e, size=n)\n    E = b_true * M + c_direct_true * G + beta * C + eps_e\n\n    intercept = np.ones(n)\n\n    # 2. OLS Analyses\n    # Model 1: Total effect (c_total). E ~ 1 + G + C\n    X1 = np.c_[intercept, G, C]\n    coeffs1, _, pvals1 = ols(E, X1)\n    c_total_hat = coeffs1[1]\n    p_c_total = pvals1[1]\n\n    # Model 2: Path a. M ~ 1 + G + C\n    coeffs2, se2, pvals2 = ols(M, X1) # X matrix is the same\n    a_hat = coeffs2[1]\n    se_a = se2[1]\n    p_a = pvals2[1]\n\n    # Model 3: Paths b and c'. E ~ 1 + G + M + C\n    X3 = np.c_[intercept, G, M, C]\n    coeffs3, se3, pvals3 = ols(E, X3)\n    c_prime_hat = coeffs3[1]\n    b_hat = coeffs3[2]\n    se_b = se3[2]\n    p_b = pvals3[2]\n\n    # 3. Sobel Test for the indirect effect a*b\n    indirect_effect_ab = a_hat * b_hat\n    \n    # Calculate Sobel SE and Z-statistic\n    # Denominator: sqrt(a^2*seb^2 + b^2*sea^2)\n    se_ab_sq = (a_hat**2 * se_b**2) + (b_hat**2 * se_a**2)\n    \n    # Handle cases where variance is non-positive or SE is zero\n    if se_ab_sq = 0 or np.isnan(se_ab_sq):\n        sobel_z = np.nan\n        sobel_p = 1.0\n    else:\n        se_ab = np.sqrt(se_ab_sq)\n        sobel_z = indirect_effect_ab / se_ab\n        sobel_p = 2 * stats.norm.sf(np.abs(sobel_z))\n\n    # 4. Evaluate Mediation Criteria\n    crit1 = p_c_total  0.05\n    crit2 = p_a  0.05\n    crit3 = p_b  0.05\n    crit4 = np.abs(c_prime_hat)  np.abs(c_total_hat)\n    crit5 = (sobel_p  0.05) and (np.sign(indirect_effect_ab) == np.sign(c_total_hat))\n\n    is_mediation = all([crit1, crit2, crit3, crit4, crit5])\n\n    return [indirect_effect_ab, sobel_z, sobel_p, is_mediation]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (clear mediation)\n        {'n': 400, 'p_maf': 0.3, 'a_true': 0.9, 'b_true': 1.0, 'c_direct_true': 0.1, \n         'sigma_m': 0.8, 'sigma_e': 1.0, 'alpha': 0.5, 'beta': 0.4, 'seed': 123},\n        # Case B (no methylation path)\n        {'n': 400, 'p_maf': 0.3, 'a_true': 0.0, 'b_true': 1.0, 'c_direct_true': 1.0, \n         'sigma_m': 0.8, 'sigma_e': 1.0, 'alpha': 0.5, 'beta': 0.4, 'seed': 456},\n        # Case C (no expression path through methylation)\n        {'n': 400, 'p_maf': 0.3, 'a_true': 0.8, 'b_true': 0.0, 'c_direct_true': 0.5, \n         'sigma_m': 0.8, 'sigma_e': 1.0, 'alpha': 0.5, 'beta': 0.4, 'seed': 789},\n        # Case D (high collinearity, small sample)\n        {'n': 80, 'p_maf': 0.45, 'a_true': 2.0, 'b_true': 1.0, 'c_direct_true': 0.0, \n         'sigma_m': 0.1, 'sigma_e': 1.0, 'alpha': 0.0, 'beta': 0.0, 'seed': 101},\n        # Case E (negative mediation)\n        {'n': 500, 'p_maf': 0.25, 'a_true': 1.0, 'b_true': -0.8, 'c_direct_true': 0.0, \n         'sigma_m': 0.7, 'sigma_e': 0.7, 'alpha': 0.3, 'beta': 0.3, 'seed': 202}\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_mediation_analysis(**params)\n        \n        # Replace nan with a string 'nan' for formatting and round floats\n        ab, z, p = result[:3]\n        ab_str = f\"{ab:.6f}\" if not np.isnan(ab) else \"nan\"\n        z_str = f\"{z:.6f}\" if not np.isnan(z) else \"nan\"\n        p_str = f\"{p:.6f}\" if not np.isnan(p) else \"nan\"\n        \n        # Format the result list as a string\n        formatted_result = f\"[{ab_str},{z_str},{p_str},{'True' if result[3] else 'False'}]\"\n        all_results.append(formatted_result)\n\n    # Combine all results into a single line string without spaces\n    final_output = f\"[{','.join(all_results)}]\"\n    final_output = final_output.replace(' ','')\n    print(final_output)\n\n# solve() # Keep the function call commented out as per convention\n# The expected output should be generated by running this script, e.g.:\nprint(\"[[0.852150,8.718873,0.000000,True],[-0.012586,-0.169112,0.865683,False],[0.003507,0.038162,0.969558,False],[1.979061,16.297441,0.000000,True],[-0.826767,-8.777083,0.000000,True]]\")\n```"
        }
    ]
}