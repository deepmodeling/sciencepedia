{
    "hands_on_practices": [
        {
            "introduction": "理解运动系统的组织结构，应从其最基本的回路——单突触牵张反射——开始。本练习将我们所熟悉的膝跳反射分解为其基本的时间组成部分。通过计算从刺激到反应的总延迟时间，您将对支配所有运动行为的神经传导和突触传递速度有一个定量的认识。",
            "id": "4498323",
            "problem": "髌腱（膝跳）反射的基础是一种单突触牵张反射，它由来自股四头肌肌梭的Ia类传入神经纤维介导，该纤维直接与一个脊髓下运动神经元（α-运动神经元）形成突触，后者的轴突返回至股四头肌。上运动神经元（皮质脊髓束）可以调节此反射，但它们不增加单突触反射弧中必需的突触步骤，因此在估算潜伏期时可以忽略。从“传导时间等于距离除以传导速度”以及“总反射潜伏期是反射弧上所有顺序延迟的总和”这两个定义出发，推导并计算从敲击髌腱瞬间到股四头肌开始收缩的预期潜伏期。\n\n假设一个成年人具有以下经实验支持且生理上合理的参数：\n- 反射弧由一根Ia类传入神经纤维（传导速度 $v_{a} = 80 \\ \\mathrm{m/s}$）和一根α-下运动神经元传出纤维（传导速度 $v_{e} = 60 \\ \\mathrm{m/s}$）组成。\n- 总外周轴突路径长度（传入加传出）为 $L_{\\mathrm{total}} = 1 \\ \\mathrm{m}$，且两段长度相等，即 $L_{a} = 0.5 \\ \\mathrm{m}$ 和 $L_{e} = 0.5 \\ \\mathrm{m}$。\n- 脊髓中单突触连接处的中枢突触延迟为 $t_{\\mathrm{syn}} = 0.5 \\ \\mathrm{ms}$。\n- 神经肌肉接头处的突触延迟为 $t_{\\mathrm{NMJ}} = 0.5 \\ \\mathrm{ms}$。\n- 兴奋-收缩耦合时间（从终板去极化到股四头肌可检测到力产生）为 $t_{\\mathrm{EC}} = 15 \\ \\mathrm{ms}$。\n- 从敲击肌腱到肌梭激活的机械延迟建模为 $t_{\\mathrm{mech}} = 1 \\ \\mathrm{ms}$。\n\n仅使用上述基本定义，不借助任何额外的简化公式，计算从敲击到机械收缩开始的预期总潜伏期。最终答案以毫秒为单位表示，并四舍五入到四位有效数字。",
            "solution": "膝跳反射的潜伏期可以分解为一系列顺序延迟，这些延迟源于涉及下运动神经元及其传入输入的单突触反射弧的结构。我们使用的基本关系是：\n\n1. 沿神经纤维的传导时间等于距离除以传导速度，即，如果一个动作电位以速度 $v$ 传播距离 $L$，则时间为\n$$\nt = \\frac{L}{v}.\n$$\n\n2. 一系列串行事件的总潜伏期是各部分延迟的总和，因此，如果持续时间为 $t_{1}, t_{2}, \\ldots, t_{n}$ 的事件顺序发生，则总持续时间为\n$$\nt_{\\mathrm{total}} = \\sum_{i=1}^{n} t_{i}.\n$$\n\n接下来我们逐项列出膝跳反射潜伏期的组成部分：\n\n- 从股四头肌肌梭到脊髓的传入传导，距离为 $L_{a} = 0.5 \\ \\mathrm{m}$，速度为 $v_{a} = 80 \\ \\mathrm{m/s}$。传入传导时间为\n$$\nt_{a} = \\frac{L_{a}}{v_{a}} = \\frac{0.5 \\ \\mathrm{m}}{80 \\ \\mathrm{m/s}} = 0.00625 \\ \\mathrm{s} = 6.25 \\ \\mathrm{ms}.\n$$\n\n- 单突触连接处的中枢突触延迟已知为\n$$\nt_{\\mathrm{syn}} = 0.5 \\ \\mathrm{ms}.\n$$\n\n- 沿α-下运动神经元轴突从脊髓到股四头肌的传出传导，距离为 $L_{e} = 0.5 \\ \\mathrm{m}$，速度为 $v_{e} = 60 \\ \\mathrm{m/s}$：\n$$\nt_{e} = \\frac{L_{e}}{v_{e}} = \\frac{0.5 \\ \\mathrm{m}}{60 \\ \\mathrm{m/s}} = \\frac{1}{120} \\ \\mathrm{s} \\approx 0.008333\\ldots \\ \\mathrm{s} = 8.333\\ldots \\ \\mathrm{ms}.\n$$\n\n- 神经肌肉接头处的突触延迟已知为\n$$\nt_{\\mathrm{NMJ}} = 0.5 \\ \\mathrm{ms}.\n$$\n\n- 到可检测到力产生的兴奋-收缩耦合时间为\n$$\nt_{\\mathrm{EC}} = 15 \\ \\mathrm{ms}.\n$$\n\n- 从敲击肌腱到肌梭激活的机械延迟为\n$$\nt_{\\mathrm{mech}} = 1 \\ \\mathrm{ms}.\n$$\n\n将这些部分相加得到总潜伏期：\n$$\nt_{\\mathrm{total}} = t_{\\mathrm{mech}} + t_{a} + t_{\\mathrm{syn}} + t_{e} + t_{\\mathrm{NMJ}} + t_{\\mathrm{EC}}.\n$$\n代入数值（所有时间均以毫秒为单位）可得\n$$\nt_{\\mathrm{total}} = 1 \\ \\mathrm{ms} + 6.25 \\ \\mathrm{ms} + 0.5 \\ \\mathrm{ms} + 8.333\\ldots \\ \\mathrm{ms} + 0.5 \\ \\mathrm{ms} + 15 \\ \\mathrm{ms}.\n$$\n分步计算总和：\n$$\n1 + 6.25 = 7.25,\n$$\n$$\n7.25 + 0.5 = 7.75,\n$$\n$$\n7.75 + 8.333\\ldots = 16.083\\ldots,\n$$\n$$\n16.083\\ldots + 0.5 = 16.583\\ldots,\n$$\n$$\n16.583\\ldots + 15 = 31.583\\ldots.\n$$\n因此，\n$$\nt_{\\mathrm{total}} \\approx 31.583\\ldots \\ \\mathrm{ms}.\n$$\n\n按要求四舍五入到四位有效数字，可得\n$$\nt_{\\mathrm{total}} = 31.58 \\ \\mathrm{ms}.\n$$\n\n该值与健康成年人髌腱反射机械起始潜伏期的既定测量值一致，反映了下运动神经元通路及其传入输入的组织结构，而上运动神经元的影响是调节性的，并非单突触传导和构成潜伏期的突触步骤所必需的。",
            "answer": "$$\\boxed{31.58}$$"
        },
        {
            "introduction": "单个反射弧展示了其基本通路，但肌肉是由整个下运动神经元（LMN）群体控制的。本计算练习将探讨中枢神经系统如何利用Henneman尺寸原理来产生分级的力量。通过对具有不同募集阈值和放电率的运动神经元池进行建模，您将亲眼看到运动单位的有序募集和其放电频率的调节如何协同作用，从而实现对肌肉力量的精确控制。",
            "id": "4498374",
            "problem": "给定一个下运动神经元（LMN）池的数学模型，该神经元池支配一块肌肉。LMN 池接收来自上运动神经元（UMN）的共同突触驱动。其募集遵循 Henneman 体积原理：随着共同驱动的增加，募集阈值较低的单位先于阈值较高的单位被激活。每个被募集的 LMN 会产生一个脉冲序列，其发放频率随突触驱动的增加而增加，每个脉冲会引发一个抽搐力响应，这些响应在时间上线性叠加。目标是根据第一性原理计算在指定时间的瞬时总肌肉力，并量化增加共同突触驱动如何改变活动运动单位的组成（慢肌单位与快肌单位）。\n\n基本原理：\n- LMN 响应突触输入产生脉冲序列；当有效驱动超过阈值时，瞬时发放频率随之单调增加。\n- 来自单个运动单位动作电位的抽搐力在肌肉中线性叠加。\n- Henneman 体积原理：募集按阈值排序，慢肌单位的阈值通常低于快肌单位。\n\n模型规格：\n- 共有 $M=10$ 个运动单位，索引为 $i\\in\\{1,\\dots,10\\}$，其中 $i\\in\\{1,\\dots,6\\}$ 分类为慢肌（S 型），$i\\in\\{7,\\dots,10\\}$ 分类为快肌（F 型）。\n- 每个单位 $i$ 都有一个募集阈值 $\\theta_i$（无量纲）、一个抽搐振幅 $A_i$（单位：牛顿）和一个抽搐时间常数 $\\tau_i$（单位：秒）。\n- 每个单位 $i$ 都有一个最小发放频率 $r^{\\min}_i$（单位：赫兹）、一个最大发放频率 $r^{\\max}_i$（单位：赫兹）和一个增益 $k_i$（单位：赫兹/单位驱动）。当共同驱动 $u(t)$ 从时间 $t=t_{\\mathrm{step}}$ 开始处于平台期 $U$（无量纲）时，被募集单位的稳态发放频率模型为\n$$\nr_i(U)=\\min\\left(r^{\\max}_i,\\;r^{\\min}_i+k_i\\,(U-\\theta_i)\\right)\\quad\\text{for}\\quad U\\ge \\theta_i,\n$$\n如果 $U  \\theta_i$，则该单位不被募集（不产生脉冲）。\n- 单位 $i$ 在时间 $s$ 的每个脉冲产生的抽搐力由因果 alpha 函数给出\n$$\nh_i(t-s)=\n\\begin{cases}\nA_i\\,\\dfrac{t-s}{\\tau_i}\\,e^{-\\frac{t-s}{\\tau_i}},  t \\ge s \\\\\n0,  t  s\n\\end{cases}\n$$\n其中，所有参数（$\\theta_i, A_i, \\tau_i, r^{\\min}_i, r^{\\max}_i, k_i$）均在提供的求解器代码的“物理单元和常数”部分给出。\n- LMN池接收的共同驱动 $u(t)$ 是一个阶跃函数：当 $t  t_{\\mathrm{step}} = 0.50\\,\\mathrm{s}$ 时，$u(t)=0$；当 $t \\ge t_{\\mathrm{step}}$ 时，$u(t)=U$。\n- 所有被募集的运动单位在时间 $t_{\\mathrm{rec},i} = t_{\\mathrm{step}}$ 开始发放，并以 $1/r_i(U)$ 的脉冲间期周期性地发放。\n\n任务：\n您将获得四个不同的恒定突触驱动水平 $U$。对于每个 $U$ 值，计算在观察时间 $T_{\\mathrm{end}} = 1.50\\,\\mathrm{s}$ 的瞬时总肌肉力 $F(T_{\\mathrm{end}})$，以及在该驱动水平下活动的慢肌（$N_{\\mathrm{S}}$）和快肌（$N_{\\mathrm{F}}$）运动单位的数量。将力值四舍五入到小数点后四位。\n您的最终答案应是一个包含四个列表的列表，每个内部列表对应一个测试案例，格式为 $[F(T_{\\mathrm{end}}), N_{\\mathrm{S}}, N_{\\mathrm{F}}]$。\n\n测试套件：\n- 用例 1：$U=0.00$\n- 用例 2：$U=0.32$\n- 用例 3：$U=0.55$\n- 用例 4：$U=0.75$",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于运动控制的原理，数学上是适定的、客观的，并包含推导唯一解所需的所有信息。该模型是一个标准的、尽管简化了的下运动神经元（LMN）池的表示，整合了 Henneman 体积原理、频率调制和抽搐力的线性叠加。\n\n目标是计算在特定观察时间 $T_{\\mathrm{end}}$ 的总瞬时肌肉力 $F(t)$，并量化在四种不同水平的恒定突触驱动 $U$ 下，活动的慢抽搐（$N_{\\mathrm{S}}$）和快抽搐（$N_{\\mathrm{F}}$）运动单位的数量。突触驱动 $u(t)$ 是一个阶跃函数，当 $t  t_{\\mathrm{step}}$ 时为 $0$，当 $t \\ge t_{\\mathrm{step}}$ 时为恒定平台值 $U$。\n\n解决此问题的算法直接源自所提供的模型规格和基本原理。对于每个给定的、以平台驱动水平 $U$ 为特征的测试案例，执行以下计算步骤：\n\n1.  **运动单元募集与计数**：\n    第一步是确定 $M=10$ 个运动单位中有哪些被募集。根据 Henneman 体积原理，当且仅当共同驱动 $U$ 达到或超过其募集阈值 $\\theta_i$ 时，运动单位 $i$ 才会被激活。\n    $$ \\text{单位 } i \\text{ 被募集，如果 } U \\ge \\theta_i $$\n    我们遍历所有单位 $i=1, \\dots, 10$。对每个单位，我们检查此条件。我们维持两个计数器，$N_{\\mathrm{S}}(U)$ 和 $N_{\\mathrm{F}}(U)$，初始化为 $0$。如果单位 $i$ 被募集：\n    - 如果 $i \\in \\{1, \\dots, 6\\}$（慢肌单位），我们增加 $N_{\\mathrm{S}}(U)$。\n    - 如果 $i \\in \\{7, \\dots, 10\\}$（快肌单位），我们增加 $N_{\\mathrm{F}}(U)$。\n    此过程得出在驱动水平 $U$ 下活动运动单位池的组成。\n\n2.  **发放频率计算**：\n    对于每个被募集的单位 $i$，我们计算其稳态发放频率 $r_i(U)$，单位为赫兹。问题中指定的关系为：\n    $$ r_i(U) = \\min\\left(r^{\\max}_i, \\; r^{\\min}_i + k_i(U - \\theta_i)\\right) $$\n    其中 $r^{\\min}_i$ 是最小发放频率，$r^{\\max}_i$ 是最大频率，$k_i$ 是增益。如果一个单位未被募集（$U  \\theta_i$），其发放频率为 $0$。\n\n3.  **脉冲序列生成**：\n    所有被募集的单位在时间 $t_{\\mathrm{rec},i} = t_{\\mathrm{step}}$ 开始发放。它们随后以 $1/r_i(U)$ 的脉冲间期周期性地发放。单位 $i$ 的第 $n$ 个脉冲（$n$ 从 $0$ 开始）的时间由下式给出：\n    $$ t_{i,n} = t_{\\mathrm{step}} + \\frac{n}{r_i(U)} $$\n    我们的目标是计算在 $T_{\\mathrm{end}} = 1.50\\,\\mathrm{s}$ 时的总力。我们只需要考虑在该时间或之前发生的脉冲，即 $t_{i,n} \\le T_{\\mathrm{end}}$。这个不等式确定了要求和的脉冲索引 $n$ 的范围：\n    $$ t_{\\mathrm{step}} + \\frac{n}{r_i(U)} \\le T_{\\mathrm{end}} \\implies n \\le (T_{\\mathrm{end}} - t_{\\mathrm{step}}) \\cdot r_i(U) $$\n    由于 $n$ 必须是整数，因此对于每个单位 $i$ 需要考虑的脉冲索引为 $n = 0, 1, 2, \\ldots, n_{\\max,i}$，其中 $n_{\\max,i} = \\lfloor(T_{\\mathrm{end}} - t_{\\mathrm{step}}) \\cdot r_i(U)\\rfloor$。\n\n4.  **通过叠加计算总力**：\n    总肌肉力 $F(T_{\\mathrm{end}})$ 是截至时间 $T_{\\mathrm{end}}$ 的所有脉冲产生的抽搐力响应的线性总和。单位 $i$ 在时间 $s$ 发出的一个脉冲的抽搐响应 $h_i(t-s)$ 由一个因果 alpha 函数描述：\n    $$ h_i(\\Delta t) = A_i \\frac{\\Delta t}{\\tau_i} e^{-\\frac{\\Delta t}{\\tau_i}} \\quad \\text{for} \\quad \\Delta t \\ge 0 $$\n    其中 $\\Delta t = t-s$ 是脉冲后经过的时间，$A_i$ 是抽搐振幅，$\\tau_i$ 是抽搐时间常数。\n    \n    单位 $i$ 在时间 $t_{i,n}$ 的单个脉冲对时间 $T_{\\mathrm{end}}$ 总力的贡献是 $h_i(T_{\\mathrm{end}} - t_{i,n})$。为了求得总力，我们将这些贡献对所有被募集运动单位的所有相关脉冲求和：\n    $$ F(T_{\\mathrm{end}}) = \\sum_{i=1}^{M} \\sum_{n: \\, t_{i,n} \\le T_{\\mathrm{end}}} h_i(T_{\\mathrm{end}} - t_{i,n}) $$\n    利用前面步骤的结果，这可以算法化地写成：\n    $$ F(T_{\\mathrm{end}}) = \\sum_{i \\text{ s.t. } U \\ge \\theta_i} \\left( \\sum_{n=0}^{n_{\\max,i}} A_i \\frac{T_{\\mathrm{end}} - t_{i,n}}{\\tau_i} e^{-\\frac{T_{\\mathrm{end}} - t_{i,n}}{\\tau_i}} \\right) $$\n    计算过程是：将一个总力变量初始化为 $0$，然后遍历每个被募集的单位 $i$。对于每个这样的单位，一个嵌套循环从 $n=0$ 遍历到 $n_{\\max,i}$，计算每个抽搐在 $T_{\\mathrm{end}}$ 时的力，并将其加到总力上。\n\n5.  **最终输出组装**：\n    在为给定的 $U$ 计算出 $F(T_{\\mathrm{end}})$、$N_{\\mathrm{S}}(U)$ 和 $N_{\\mathrm{F}}(U)$ 之后，将力四舍五入到四位小数。一个测试案例的结果格式化为列表 $[F(T_{\\mathrm{end}}), N_{\\mathrm{S}}(U), N_{\\mathrm{F}}(U)]$。对测试套件中所有指定的 $U$ 值重复此过程。最终输出将这些列表聚合为一个列表的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes total muscle force and active unit counts for a motor neuron pool model.\n    \"\"\"\n    \n    # Define motor unit parameters using 0-based indexing for 10 units.\n    # Units 0-5 are slow (S), 6-9 are fast (F).\n    \n    # Recruitment thresholds (dimensionless)\n    theta = np.array([0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.50, 0.60, 0.70])\n    \n    # Twitch amplitudes (Newtons)\n    A = np.array([0.50, 0.55, 0.60, 0.65, 0.70, 0.75, 1.00, 1.20, 1.40, 1.60])\n    \n    # Twitch time constants (seconds)\n    tau = np.array([0.090, 0.085, 0.080, 0.075, 0.070, 0.065, 0.050, 0.045, 0.040, 0.035])\n    \n    # Minimal firing rates (Hertz)\n    r_min = np.array([8, 8, 8, 8, 8, 8, 12, 12, 12, 12])\n    \n    # Maximal firing rates (Hertz)\n    r_max = np.array([25, 25, 25, 25, 25, 25, 50, 50, 50, 50])\n    \n    # Firing rate gains (Hertz per unit drive)\n    k = np.array([100, 100, 100, 100, 100, 100, 150, 150, 150, 150])\n\n    # Timing parameters\n    t_step = 0.50  # s\n    T_end = 1.50   # s\n\n    # Test suite: plateau values for common drive U\n    test_cases = [0.00, 0.32, 0.55, 0.75]\n    \n    overall_results = []\n\n    for U in test_cases:\n        total_force = 0.0\n        N_S = 0\n        N_F = 0\n\n        # Iterate through all M=10 motor units\n        for i in range(10):\n            # Step 1: Check for recruitment based on threshold\n            if U >= theta[i]:\n                # Step 2: Count recruited units by type\n                if i  6:  # Slow units are indexed 0-5\n                    N_S += 1\n                else:      # Fast units are indexed 6-9\n                    N_F += 1\n\n                # Step 3: Calculate the stationary firing rate\n                rate = r_min[i] + k[i] * (U - theta[i])\n                firing_rate = min(r_max[i], rate)\n                \n                # If firing rate is non-positive, no spikes are generated.\n                if firing_rate = 0:\n                    continue\n\n                # Step 4: Determine the spike times and their contribution to force\n                # Spikes at t_i,n = t_step + n / firing_rate must satisfy t_i,n = T_end\n                # n = (T_end - t_step) * firing_rate\n                duration = T_end - t_step\n                max_n = int(np.floor(duration * firing_rate))\n                \n                # Step 5: Sum twitch responses by linear superposition\n                for n in range(max_n + 1):\n                    spike_time = t_step + n / firing_rate\n                    time_since_spike = T_end - spike_time\n                    \n                    # Twitch force h_i(t-s) = A_i * ( (t-s)/tau_i ) * exp( -(t-s)/tau_i )\n                    # This is the alpha-function response.\n                    twitch_force_contribution = A[i] * (time_since_spike / tau[i]) * np.exp(-time_since_spike / tau[i])\n                    total_force += twitch_force_contribution\n\n        # Store the results for the current test case\n        rounded_force = round(total_force, 4)\n        case_result = [rounded_force, N_S, N_F]\n        overall_results.append(case_result)\n\n    # Format the final output string to match the required format `[[f1,s1,f1],[f2,s2,f2],...]`\n    # without extraneous spaces.\n    formatted_results = []\n    for res in overall_results:\n        formatted_results.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "运动控制的精妙层次结构在其被破坏时表现得最为明显。这最后一个练习深入探讨了痉挛的病理生理学，这是上运动神经元（UMN）综合征的一个标志。通过一个生物物理模型，您将研究下行性单胺能输入的丧失如何通过上调持续性内向电流（PICs）导致下运动神经元（LMN）的过度兴奋，从而为上运动神经元损伤与由此产生的反射亢进之间建立了机制上的联系。",
            "id": "4498365",
            "problem": "要求您构建一个计算模型，该模型能从第一性原理出发，预测慢性上运动神经元 (UMN) 损伤如何通过上调由单胺能神经调质介导的持续性内向电流 (PICs) 来改变下运动神经元 (LMNs) 的兴奋性，并使用该模型来量化由此产生的痉挛模式和反射超兴奋性。模型背景为一个单室LMN膜，该膜遵循一个阻容方程，并带有一个代表PIC的附加电压依赖性内向电流。所有计算必须遵循一个基于电路动力学和生物物理膜电流核心定义的物理和逻辑一致的框架。\n\n定义：\n- 上运动神经元 (UMN) 指源于大脑、调节脊髓回路的下行运动通路。\n- 下运动神经元 (LMN) 指支配骨骼肌纤维的脊髓α-运动神经元。\n- 持续性内向电流 (PIC) 是LMN中的一种电压依赖性内向电流，由L型钙通道介导，并由单胺能神经调质（主要是血清素和去甲肾上腺素）放大。\n- 单胺能水平由一个标量 $M$ 建模，在慢性UMN损伤下该值会增加，并缩放PIC电导，同时增加一个去极化偏置电流。\n\n基本原理：\n- LMN膜被建模为一个具有电容 $C$、漏电导 $g_L$ 和漏反转电位 $E_L$ 的单等电位房室。根据电荷守恒和欧姆定律，该膜遵循\n$$\nC \\frac{dV}{dt} = -g_L (V - E_L) + I_{\\mathrm{ext}}(t) + I_{\\mathrm{PIC}}(V; M),\n$$\n其中 $V$ 是膜电压， $I_{\\mathrm{ext}}(t)$ 是外部突触和反射输入电流，而 $I_{\\mathrm{PIC}}(V; M)$ 是其强度依赖于 $M$ 的电压依赖性内向电流。\n- PIC电流被建模为一个S型激活电导乘以一个驱动力：\n$$\nI_{\\mathrm{PIC}}(V; M) = G(M) g_{\\mathrm{PIC}} s_{\\infty}(V) (E_{\\mathrm{PIC}} - V),\n$$\n其中单胺能增益为 $G(M) = 1 + \\alpha M$，最大PIC电导为 $g_{\\mathrm{PIC}}$，PIC反转电位为 $E_{\\mathrm{PIC}}$，稳态激活为\n$$\ns_{\\infty}(V) = \\frac{1}{1 + \\exp\\left(-\\frac{V - V_{1/2}}{k}\\right)}.\n$$\n- 外部输入分解为一个恒定的突触驱动 $I_{\\mathrm{syn}}$，一个去极化的单胺能偏置电流 $I_{\\mathrm{bias}} = b M$，以及一个速度依赖的Ia传入牵张输入，建模为 $I_{\\mathrm{Ia}} = k_{\\mathrm{Ia}} v$，其中 $v$ 是肌肉牵张速度。\n- 脉冲发放通过一个阈值-重置机制建模。当 $V$ 达到阈值 $V_{\\mathrm{th}}$ 时，发出一个脉冲，$V$ 被重置为 $V_{\\mathrm{reset}}$ 并保持一个绝对不应期 $t_{\\mathrm{ref}}$，然后继续。\n\n计算要求：\n1. 对于一组指定的参数三元组 $(M, I_{\\mathrm{syn}}, v)$，计算稳态放电率（单位：赫兹 Hz），通过在恒定输入 $I_{\\mathrm{ext}} = I_{\\mathrm{syn}} + I_{\\mathrm{bias}} + I_{\\mathrm{Ia}}$ 下对从 $V_{\\mathrm{reset}}$ 到 $V_{\\mathrm{th}}$ 的膜轨迹进行积分。具体来说，峰间期 $T$ 必须从第一性原理的定义中获得\n$$\nT = \\int_{V_{\\mathrm{reset}}}^{V_{\\mathrm{th}}} \\frac{C \\, dV}{-g_L (V - E_L) + I_{\\mathrm{syn}} + bM + k_{\\mathrm{Ia}} v + G(M) g_{\\mathrm{PIC}} s_{\\infty}(V) (E_{\\mathrm{PIC}} - V)} + t_{\\mathrm{ref}},\n$$\n需要理解的是，如果在 $[V_{\\mathrm{reset}}, V_{\\mathrm{th}}]$ 区间内任何一点的净漂移变为非正值，则神经元不放电，放电率定义为 $0$。\n2. 对于相同的参数，计算刚好达到阈值所需的最小牵张速度 $v_{\\mathrm{thresh}}$（单位：$\\mathrm{m/s}$）。对于在阈值处的最小穿越条件，强制在 $V_{\\mathrm{th}}$ 处的净漂移为零，并求解 $v$：\n$$\nv_{\\mathrm{thresh}} = \\max\\left(0, \\frac{g_L (V_{\\mathrm{th}} - E_L) - I_{\\mathrm{syn}} - bM - G(M) g_{\\mathrm{PIC}} s_{\\infty}(V_{\\mathrm{th}}) (E_{\\mathrm{PIC}} - V_{\\mathrm{th}})}{k_{\\mathrm{Ia}}}\\right).\n$$\n3. 定义痉挛指数为在指定 $v$ 下的放电率与阈值速度之比：\n$$\n\\mathrm{SI} = \\frac{r}{v_{\\mathrm{thresh}}}.\n$$\n如果 $v_{\\mathrm{thresh}} = 0$，则将 $\\mathrm{SI}$ 的上限设为 $10^9$ 以避免发散。\n\n物理单位和常数：\n- 使用 $C = 1.0$ 纳法 ($\\mathrm{nF}$)，$g_L = 0.02$ 微西门子 ($\\mu\\mathrm{S}$)，$E_L = -65$ 毫伏 ($\\mathrm{mV}$)，$V_{\\mathrm{th}} = -50$ $\\mathrm{mV}$, $V_{\\mathrm{reset}} = -55$ $\\mathrm{mV}$, $E_{\\mathrm{PIC}} = 120$ $\\mathrm{mV}$, $g_{\\mathrm{PIC}} = 0.0002$ $\\mu\\mathrm{S}$, $V_{1/2} = -60$ $\\mathrm{mV}$, $k = 4$ $\\mathrm{mV}$，单胺能增益斜率 $\\alpha = 1.5$ (无量纲)，偏置系数 $b = 0.02$ 纳安/单位$M$ ($\\mathrm{nA}$)，Ia输入增益 $k_{\\mathrm{Ia}} = 0.3$ $\\mathrm{nA}/(\\mathrm{m/s})$，以及绝对不应期 $t_{\\mathrm{ref}} = 5$ 毫秒 ($\\mathrm{ms}$)。请注意，使用 $\\mu\\mathrm{S}$ 和 $\\mathrm{mV}$ 会得到单位为 $\\mathrm{nA}$ 的电流，而 $C$ 的单位为 $\\mathrm{nF}$ 可确保时间积分的结果单位为 $\\mathrm{ms}$；在计算以赫兹为单位的速率时，需将其转换为秒。\n\n测试套件：\n提供五个测试用例，以指定单位的有序三元组 $(M, I_{\\mathrm{syn}}, v)$ 形式给出：\n- 用例 1：$(M = 0.2, I_{\\mathrm{syn}} = 0.2 \\mathrm{nA}, v = 0.3 \\mathrm{m/s})$。\n- 用例 2：$(M = 1.0, I_{\\mathrm{syn}} = 0.2 \\mathrm{nA}, v = 0.3 \\mathrm{m/s})$。\n- 用例 3：$(M = 0.0, I_{\\mathrm{syn}} = 0.1 \\mathrm{nA}, v = 0.3 \\mathrm{m/s})$。\n- 用例 4：$(M = 2.0, I_{\\mathrm{syn}} = 0.15 \\mathrm{nA}, v = 0.1 \\mathrm{m/s})$。\n- 用例 5：$(M = 1.5, I_{\\mathrm{syn}} = -0.05 \\mathrm{nA}, v = 0.3 \\mathrm{m/s})$。\n\n答案规格：\n- 对于每个测试用例，计算三个量：以 $\\mathrm{Hz}$ 为单位的放电率（浮点数），以 $\\mathrm{m/s}$ 为单位的阈值速度 $v_{\\mathrm{thresh}}$（浮点数），以及痉挛指数 $\\mathrm{SI}$（浮点数）。每个浮点数表示为四舍五入到三位小数。\n- 最终输出格式：您的程序应生成单行输出，包含一个列表的列表形式的结果，每个内部列表对应一个测试用例，顺序与上文相同。每个内部列表必须按 $[r (\\mathrm{Hz}), v_{\\mathrm{thresh}} (\\mathrm{m/s}), \\mathrm{SI}]$ 的顺序包含三个四舍五入后的浮点数，外部列表必须包含所有五个内部列表。例如，打印的结构必须类似于 $[[x_1,y_1,z_1],[x_2,y_2,z_2],\\ldots,[x_5,y_5,z_5]]$，不得包含任何额外文本。",
            "solution": "我们从第一性原理构建计算解。LMN被建模为一个阻容元件，带有一个漏电流和一个代表由单胺调制的持续性内向电流 (PIC) 的附加电压依赖性内向电流。\n\n原理：\n1. 根据电容定律，电容器上的电荷积累遵循 $C \\, dV/dt = I_{\\mathrm{net}}$。净电流是漏电流、外部输入和PIC之和。\n2. 膜上的欧姆定律给出漏电流 $I_L = -g_L (V - E_L)$。\n3. PIC被建模为一个具有稳态激活 $s_{\\infty}(V)$ 和驱动力 $(E_{\\mathrm{PIC}} - V)$ 的电导，并由单胺能增益 $G(M) = 1 + \\alpha M$ 缩放，因此\n$$\nI_{\\mathrm{PIC}}(V; M) = G(M) g_{\\mathrm{PIC}} s_{\\infty}(V) (E_{\\mathrm{PIC}} - V),\n$$\n其中 $s_{\\infty}(V) = \\frac{1}{1 + \\exp\\left(-\\frac{V - V_{1/2}}{k}\\right)}$。\n4. 外部输入包括一个恒定的突触驱动 $I_{\\mathrm{syn}}$，一个单胺能偏置 $I_{\\mathrm{bias}} = bM$，以及对应肌肉牵张速度 $v$ 的Ia输入 $I_{\\mathrm{Ia}} = k_{\\mathrm{Ia}} v$。\n\n因此电压动力学为\n$$\n\\frac{dV}{dt} = \\frac{-g_L (V - E_L) + I_{\\mathrm{syn}} + bM + k_{\\mathrm{Ia}} v + G(M) g_{\\mathrm{PIC}} s_{\\infty}(V) (E_{\\mathrm{PIC}} - V)}{C}.\n$$\n\n放电率计算：\n- 在恒定的输入参数 $(M, I_{\\mathrm{syn}}, v)$ 下，不包括不应期效应的峰间期 $T$ 是 $V$ 从 $V_{\\mathrm{reset}}$ 演化到 $V_{\\mathrm{th}}$ 所需的时间：\n$$\nT_{\\mathrm{drift}} = \\int_{V_{\\mathrm{reset}}}^{V_{\\mathrm{th}}} \\frac{C \\, dV}{-g_L (V - E_L) + I_{\\mathrm{syn}} + bM + k_{\\mathrm{Ia}} v + G(M) g_{\\mathrm{PIC}} s_{\\infty}(V) (E_{\\mathrm{PIC}} - V)}.\n$$\n- 如果在区间 $[V_{\\mathrm{reset}}, V_{\\mathrm{th}}]$ 内任何地方的净漂移为非正值（即分母变为 $\\le 0$），则轨迹无法达到阈值，根据定义，放电率为 $0$。\n- 包含绝对不应期 $t_{\\mathrm{ref}}$ 以获得完整的峰间期：\n$$\nT = T_{\\mathrm{drift}} + t_{\\mathrm{ref}}.\n$$\n- 单位：当 $C$ 以 $\\mathrm{nF}$ 为单位，电流以 $\\mathrm{nA}$ 为单位，电压以 $\\mathrm{mV}$ 为单位时，积分结果的单位为 $\\mathrm{ms}$。计算速率时，通过除以 $1000$ 将其转换为秒：\n$$\nr = \\frac{1}{T/1000} = \\frac{1000}{T} \\quad \\text{in} \\;\\mathrm{Hz}.\n$$\n\n反射阈值速度：\n- 刚好达到阈值的最小速度是通过在阈值处强制净漂移为零来获得的：\n$$\n0 = -g_L (V_{\\mathrm{th}} - E_L) + I_{\\mathrm{syn}} + bM + k_{\\mathrm{Ia}} v_{\\mathrm{thresh}} + G(M) g_{\\mathrm{PIC}} s_{\\infty}(V_{\\mathrm{th}}) (E_{\\mathrm{PIC}} - V_{\\mathrm{th}}).\n$$\n- 求解速度并将其限制为非负值：\n$$\nv_{\\mathrm{thresh}} = \\max\\left(0, \\frac{g_L (V_{\\mathrm{th}} - E_L) - I_{\\mathrm{syn}} - bM - G(M) g_{\\mathrm{PIC}} s_{\\infty}(V_{\\mathrm{th}}) (E_{\\mathrm{PIC}} - V_{\\mathrm{th}})}{k_{\\mathrm{Ia}}}\\right).\n$$\n\n痉挛指数：\n- 定义 $\\mathrm{SI} = r / v_{\\mathrm{thresh}}$ 以捕捉单位牵张获得的放电量。如果 $v_{\\mathrm{thresh}} = 0$，该比率会发散；上限设为 $10^9$：\n$$\n\\mathrm{SI} = \\begin{cases}\n\\frac{r}{v_{\\mathrm{thresh}}},  v_{\\mathrm{thresh}} > 0, \\\\\n10^9,  v_{\\mathrm{thresh}} = 0.\n\\end{cases}\n$$\n\n算法：\n- 对于每个测试用例的参数 $(M, I_{\\mathrm{syn}}, v)$：\n  1. 计算 $G(M) = 1 + \\alpha M$、$I_{\\mathrm{bias}} = bM$ 和 $I_{\\mathrm{Ia}} = k_{\\mathrm{Ia}} v$。\n  2. 定义积分分母中的漂移函数，\n  $$\n  F(V) = -g_L (V - E_L) + I_{\\mathrm{syn}} + bM + k_{\\mathrm{Ia}} v + G(M) g_{\\mathrm{PIC}} s_{\\infty}(V) (E_{\\mathrm{PIC}} - V).\n  $$\n  3. 通过采样检查在 $[V_{\\mathrm{reset}}, V_{\\mathrm{th}}]$ 上是否有 $F(V) > 0$；如果任何 $F(V) \\le 0$，则设 $r = 0$，否则使用高精度数值积分计算 $T_{\\mathrm{drift}} = \\int C/F(V)\\, dV$，并加上 $t_{\\mathrm{ref}}$ 形成 $T$；然后转换为 $r = 1000/T$（单位：$\\mathrm{Hz}$）。\n  4. 使用 $s_{\\infty}(V_{\\mathrm{th}})$ 通过上述闭式表达式计算 $v_{\\mathrm{thresh}}$，并将其限制为 $\\ge 0$。\n  5. 按规定计算 $\\mathrm{SI}$，如果 $v_{\\mathrm{thresh}} = 0$ 则上限为 $10^9$。\n  6. 将每个输出四舍五入到三位小数。\n\n测试覆盖理由：\n- 用例1是一个单胺水平轻度升高的典型基线。\n- 用例2代表具有较高 $M$ 的慢性UMN损伤，预测PIC增加和反射阈值降低。\n- 用例3测试了最小单胺能张力和弱突触驱动的边界条件，通常除非牵张足够快，否则不会产生放电。\n- 用例4是一个高单胺能情况，其中反射阈值变为零，说明了超兴奋性和痉挛。\n- 用例5包含净抑制性突触驱动，以探究鲁棒性以及激活所需更高牵张速度的要求。\n\n输出：\n- 生成一行：一个包含五个内部列表的Python列表；每个内部列表包含三个浮点数 $[r (\\mathrm{Hz}), v_{\\mathrm{thresh}} (\\mathrm{m/s}), \\mathrm{SI}]$，四舍五入到三位小数，并按测试用例序列排序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\n# Biophysical constants (units noted for clarity):\n# C: nF, g_L: uS, E_*: mV, g_PIC: uS, t_ref: ms, I_*: nA, k_Ia: nA/(m/s)\nC_nF = 1.0\ngL_uS = 0.02\nEL_mV = -65.0\nVth_mV = -50.0\nVreset_mV = -55.0\nEPIC_mV = 120.0\ngPIC_uS = 0.0002\nVhalf_mV = -60.0\nk_slope_mV = 4.0\nalpha = 1.5  # monoaminergic gain slope\nb_bias_nA_per_M = 0.02\nk_Ia_nA_per_ms = 0.3\nt_ref_ms = 5.0\n\ndef s_inf(V_mV: float) -> float:\n    \"\"\"Steady-state activation of PIC (dimensionless).\"\"\"\n    return 1.0 / (1.0 + np.exp(-(V_mV - Vhalf_mV) / k_slope_mV))\n\ndef drift_current_nA(V_mV: float, M: float, I_syn_nA: float, v_ms: float) -> float:\n    \"\"\"Net inward drift current in nA at voltage V under parameters.\"\"\"\n    G = 1.0 + alpha * M  # monoaminergic gain (dimensionless)\n    I_bias = b_bias_nA_per_M * M\n    I_Ia = k_Ia_nA_per_ms * v_ms\n    leak = -gL_uS * (V_mV - EL_mV)  # nA (since uS*mV = nA)\n    pic = G * gPIC_uS * s_inf(V_mV) * (EPIC_mV - V_mV)  # nA\n    return leak + I_syn_nA + I_bias + I_Ia + pic\n\ndef can_spike(M: float, I_syn_nA: float, v_ms: float) -> bool:\n    \"\"\"Check positivity of drift over [Vreset, Vth].\"\"\"\n    # Sample the interval uniformly; include endpoints cautiously\n    V_vals = np.linspace(Vreset_mV, Vth_mV, 200)\n    F_vals = drift_current_nA(V_vals, M, I_syn_nA, v_ms)\n    return np.all(F_vals > 0.0)\n\ndef interspike_interval_ms(M: float, I_syn_nA: float, v_ms: float) -> float:\n    \"\"\"Compute interspike interval in ms via quadrature; includes refractory.\"\"\"\n    # Integrand: C / F(V), units: nF / nA * mV -> ms\n    def integrand(V):\n        F = drift_current_nA(V, M, I_syn_nA, v_ms)\n        return C_nF / F\n    # Perform integration only if drift is positive across interval\n    if not can_spike(M, I_syn_nA, v_ms):\n        return np.inf\n    # Use high-accuracy quad; handle potential sharp changes near threshold\n    val, err = quad(lambda V: integrand(V), Vreset_mV, Vth_mV, epsabs=1e-9, epsrel=1e-9, limit=200)\n    return val + t_ref_ms\n\ndef firing_rate_hz(M: float, I_syn_nA: float, v_ms: float) -> float:\n    \"\"\"Compute firing rate in Hz.\"\"\"\n    T_ms = interspike_interval_ms(M, I_syn_nA, v_ms)\n    if not np.isfinite(T_ms) or T_ms = 0.0:\n        return 0.0\n    return 1000.0 / T_ms\n\ndef v_threshold_ms(M: float, I_syn_nA: float) -> float:\n    \"\"\"Minimal stretch velocity (m/s) to achieve zero drift at Vth; clamp to >= 0.\"\"\"\n    G = 1.0 + alpha * M\n    s_th = s_inf(Vth_mV)\n    numerator = gL_uS * (Vth_mV - EL_mV) - I_syn_nA - b_bias_nA_per_M * M - G * gPIC_uS * s_th * (EPIC_mV - Vth_mV)\n    v_thr = numerator / k_Ia_nA_per_ms\n    return float(max(0.0, v_thr))\n\ndef spasticity_index(rate_hz: float, v_thr_ms: float) -> float:\n    \"\"\"Spasticity index r / v_thr, capped at 1e9 if v_thr==0.\"\"\"\n    if v_thr_ms == 0.0:\n        return 1e9\n    return rate_hz / v_thr_ms\n\ndef solve():\n    # Define the test cases from the problem statement: (M, I_syn (nA), v (m/s))\n    test_cases = [\n        (0.2, 0.2, 0.3),   # Case 1\n        (1.0, 0.2, 0.3),   # Case 2\n        (0.0, 0.1, 0.3),   # Case 3\n        (2.0, 0.15, 0.1),  # Case 4\n        (1.5, -0.05, 0.3), # Case 5\n    ]\n\n    results = []\n    for M, I_syn, v in test_cases:\n        r = firing_rate_hz(M, I_syn, v)\n        v_thr = v_threshold_ms(M, I_syn)\n        si = spasticity_index(r, v_thr)\n        # Round to three decimals as specified\n        r_r = round(r, 3)\n        v_r = round(v_thr, 3)\n        si_r = round(si, 3)\n        results.append([r_r, v_r, si_r])\n\n    # Final print statement in the exact required format.\n    # One single line with the outer list of inner lists, no extra text.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```"
        }
    ]
}