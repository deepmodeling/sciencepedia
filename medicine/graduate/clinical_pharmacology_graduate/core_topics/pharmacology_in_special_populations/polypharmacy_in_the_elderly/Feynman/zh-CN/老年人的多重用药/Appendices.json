{
    "hands_on_practices": [
        {
            "introduction": "在老年患者中，由于肾功能会随年龄增长而生理性下降，因此精确调整药物剂量至关重要。许多药物通过肾脏排泄，因此准确评估肾功能是安全用药的基石。本练习将通过一个典型案例，指导您应用临床上广泛使用的 Cockcroft-Gault 公式来估算肌酐清除率（$CrCl$），这是老年药学实践中一项不可或缺的核心技能 。",
            "id": "4980475",
            "problem": "一名患有多种慢性病的老年患者正在服用多种经肾脏清除的药物。在多重用药的情况下，准确估算肾清除率对于避免浓度依赖性不良反应至关重要。假设有一名 $78$ 岁的男性患者，体重为 $70\\,\\mathrm{kg}$，稳态血清肌酐浓度为 $1.2\\,\\mathrm{mg/dL}$。使用临床验证的、基于年龄、性别、体重和血清肌酐的 Cockcroft–Gault 方法估算肌酐清除率，计算该患者的肌酐清除率。最终结果以毫升/分钟（$\\mathrm{mL/min}$）为单位表示，并四舍五入至三位有效数字。然后，根据以下用于剂量调整的肌酐清除率分级，确定该患者属于哪个级别：$\\geq 90$、$60$–$89$、$45$–$59$、$30$–$44$、$15$–$29$ 和  $15\\,\\mathrm{mL/min}$。仅提供以 $\\mathrm{mL/min}$ 为单位的肌酐清除率数值作为最终答案，并按要求四舍五入。",
            "solution": "该问题陈述被认为是有效的，因为它科学地基于临床药理学的既定原则，问题设置良好，数据充分且一致，并以客观、精确的语言表述。它要求应用 Cockcroft-Gault 方程，这是一个用于估算肾功能的标准临床工具。\n\n该问题要求使用 Cockcroft-Gault 公式计算一名老年男性患者的肌酐清除率（$\\mathrm{CrCl}$）。该公式为：\n$$ \\mathrm{CrCl} \\, (\\mathrm{mL/min}) = \\frac{(140 - \\text{年龄}) \\times \\text{体重 (kg)}}{\\text{SCr} \\times 72} \\times C $$\n其中 $\\text{年龄}$ 以年为单位，$\\text{SCr}$ 是血清肌酐浓度，单位为 $\\mathrm{mg/dL}$，$C$ 是性别校正因子，男性 $C=1$，女性 $C=0.85$。\n\n从问题陈述中提取的已知条件如下：\n- 年龄：$78$ 岁\n- 体重 (BW)：$70\\,\\mathrm{kg}$\n- 血清肌酐 (SCr)：$1.2\\,\\mathrm{mg/dL}$\n- 性别：男\n\n由于患者为男性，校正因子 $C$ 等于 $1$。现在我们可以将所给数值代入 Cockcroft-Gault 方程：\n$$ \\mathrm{CrCl} = \\frac{(140 - 78) \\times 70}{1.2 \\times 72} $$\n\n首先，我们计算分子中代表年龄因子的项：\n$$ 140 - 78 = 62 $$\n接下来，我们完成分子的计算：\n$$ 62 \\times 70 = 4340 $$\n然后，我们计算分母：\n$$ 1.2 \\times 72 = 86.4 $$\n现在，我们可以通过分子除以分母来计算肌酐清除率：\n$$ \\mathrm{CrCl} = \\frac{4340}{86.4} \\approx 50.231481... \\, \\mathrm{mL/min} $$\n问题要求最终答案四舍五入至三位有效数字。前三位有效数字是 $5$、$0$ 和 $2$。第四位数字是 $3$，小于 $5$，因此我们向下舍入，保持最后一位有效数字不变。\n$$ \\mathrm{CrCl} \\approx 50.2 \\, \\mathrm{mL/min} $$\n\n问题还要求确定该患者属于哪个剂量调整级别。给出的级别为：$\\geq 90$、$60$–$89$、$45$–$59$、$30$–$44$、$15$–$29$ 和  $15\\,\\mathrm{mL/min}$。\n计算出的肌酐清除率为 $50.2\\,\\mathrm{mL/min}$，属于 $45 \\leq \\mathrm{CrCl} \\leq 59$ 的范围。因此，该患者属于 $45$–$59\\,\\mathrm{mL/min}$ 这一级别。此信息对于临床背景至关重要，但根据题目要求，它不属于最终数值答案的一部分。\n\n最终答案是肌酐清除率的数值，四舍五入至三位有效数字。",
            "answer": "$$\\boxed{50.2}$$"
        },
        {
            "introduction": "除了药物清除率的变化，多重用药带来的累积性不良反应是老年患者面临的另一大风险。其中，抗胆碱能负担是导致认知能力下降、谵妄和跌倒等严重后果的关键因素。本练习将向您介绍一种量化此风险的实用工具——抗胆碱能认知负担（ACB）量表 。通过计算患者用药方案的总分，您可以学会如何识别和评估与药物相关的潜在风险。",
            "id": "4980492",
            "problem": "一名患有慢性失眠、急迫性尿失禁和季节性过敏的老年患者正在服用三种药物：amitriptyline、oxybutynin 和 cetirizine。抗胆碱能认知负荷 (Anticholinergic Cognitive Burden, ACB) 量表是一种经过临床验证的工具，它根据药物的药效学证据和中枢神经系统穿透性测量的抗胆碱能活性，为每种药物分配一个抗胆碱能评分 $s_{i}$，其中 $s_{i} \\in \\{1,2,3\\}$。累积抗胆碱能负荷定义为当前服用的所有药物的这些评分之和，记为 $S = \\sum s_{i}$。流行病学研究表明，较大的 $S$ 值与老年人认知功能障碍、谵妄、跌倒和便秘的风险增加相关；风险分类通常将累积负荷分级。\n\n对于该患者，使用以下公认的 ACB 评分分配：amitriptyline 的评分为 $s_{\\text{amitriptyline}}=3$，oxybutynin 的评分为 $s_{\\text{oxybutynin}}=3$，cetirizine 的评分为 $s_{\\text{cetirizine}}=1$。根据累积负荷 $S$ 将风险分类定义如下：如果 $S=0$，则为“极小”风险；如果 $1 \\leq S \\leq 2$，则为“低”风险；如果 $S \\geq 3$，则为“高”风险。将风险等级编码为整数 $r$，“极小”风险对应 $r=0$，“低”风险对应 $r=1$，“高”风险对应 $r=2$。\n\n计算累积负荷 $S$ 和编码后的风险等级 $r$。以行向量 $\\begin{pmatrix}S  r\\end{pmatrix}$ 的形式提供最终答案。无需四舍五入。",
            "solution": "该问题要求为服用特定药物组合的患者计算两个量：累积抗胆碱能负荷（记为 $S$）和编码后的风险等级（记为 $r$）。最终答案需以行向量的形式呈现。\n\n首先，我们验证问题陈述的有效性。\n该问题基于抗胆碱能认知负荷（ACB）量表，这是药理学和老年医学中一个有效且广泛使用的工具。给定的药物评分（$s_{\\text{amitriptyline}}=3$, $s_{\\text{oxybutynin}}=3$, $s_{\\text{cetirizine}}=1$）与已有的临床数据一致。累积负荷 $S$ 和风险分类的定义清晰、量化且明确。所有必要信息均已提供，且无内部矛盾。因此，该问题具有科学依据，提法得当，客观，并且可以按所述方式解决。\n\n累积抗胆碱能负荷 $S$ 定义为患者服用的所有药物的单个抗胆碱能评分 $s_i$ 的总和。公式如下：\n$$S = \\sum s_i$$\n该患者正在服用三种药物：amitriptyline、oxybutynin 和 cetirizine。问题提供了它们各自的 ACB 评分：\n\\begin{itemize}\n    \\item 对于 amitriptyline，$s_{\\text{amitriptyline}} = 3$。\n    \\item 对于 oxybutynin，$s_{\\text{oxybutynin}} = 3$。\n    \\item 对于 cetirizine，$s_{\\text{cetirizine}} = 1$。\n\\end{itemize}\n累积负荷 $S$ 是这些评分的总和：\n$$S = s_{\\text{amitriptyline}} + s_{\\text{oxybutynin}} + s_{\\text{cetirizine}}$$\n代入给定值：\n$$S = 3 + 3 + 1 = 7$$\n该患者的累积抗胆碱能负荷为 $S=7$。\n\n接下来，我们确定编码后的风险等级 $r$。问题根据 $S$ 的值定义了风险分类：\n\\begin{itemize}\n    \\item 如果 $S = 0$，则为“极小”风险。\n    \\item 如果 $1 \\leq S \\leq 2$，则为“低”风险。\n    \\item 如果 $S \\geq 3$，则为“高”风险。\n\\end{itemize}\n我们计算出的值为 $S=7$。我们根据标准检查此值。由于 $7 \\geq 3$，该患者的风险类别为“高”风险。\n\n问题接着为这些风险等级指定了整数编码：\n\\begin{itemize}\n    \\item $r=0$ 对应“极小”风险。\n    \\item $r=1$ 对应“低”风险。\n    \\item $r=2$ 对应“高”风险。\n\\end{itemize}\n由于该患者的类别为“高”风险，因此对应的编码风险等级为 $r=2$。\n\n最终答案要求是形式为 $\\begin{pmatrix} S  r \\end{pmatrix}$ 的行向量。代入我们计算出的 $S$ 和 $r$ 的值：\n$$\\begin{pmatrix} 7  2 \\end{pmatrix}$$\n这就完成了问题陈述所要求的计算。",
            "answer": "$$\\boxed{\\begin{pmatrix} 7  2 \\end{pmatrix}}$$"
        },
        {
            "introduction": "成功的药物精简（deprescribing）并非依赖单一指标，而是需要综合权衡药物的适应症、疗效、潜在危害及治疗重复性等多个维度。本练习将挑战您将这些复杂的临床决策原则转化为一套明确的算法规则，从而构建一个药物精简的优先排序模型 。这个高阶练习旨在模拟开发临床决策支持工具的过程，帮助您将零散的药学知识整合成一个系统化的解决方案，以应对多重用药带来的复杂挑战。",
            "id": "4581235",
            "problem": "您的任务是编写一个完整、可运行的程序，为一名存在多重用药情况的老年患者实施一套基于原则的处方精简优先排序方案。您的实现必须基于核心临床药理学原则，同时表达为一个纯粹的算法排序问题。您将获得三个不同的、各含十二种药物的治疗方案的标准化输入。对于每个方案，您必须根据缺乏适应证、治疗重复和预期伤害，生成一个药物标识符的排序列表，按处方精简的优先级从高到低排列。\n\n基本依据和定义：临床目标是通过移除产生净预期伤害的药物来最大化净临床价值。设每种药物由以下属性描述：一个标识符 $d_i$（整数）、一个治疗类别标签 $g_i$（代表其类别的整数）、一个适应证标志 $I_i \\in \\{0,1\\}$（指示当前适应证的有无）、一个获益评分 $B_i \\ge 0$（单位为任意效用单位）、一个伤害概率 $p_i \\in [0,1]$（以小数形式表示），以及一个伤害严重性权重 $c_i \\ge 0$（单位为任意严重性单位）。单个药物的预期伤害成本定义为其乘积 $p_i \\times c_i$，这代表了每单位时间的预期严重性加权伤害。这是一个基于概率和后果的标准期望值构造。\n\n治疗重复定义为在同一治疗类别 $g$ 中存在多于一种药物用于处理相同的临床适应证。为了编码“此类重复相对于保留该类别中的单一代表药物通常只有可忽略不计的边际获益”这一原则，请应用以下规则来识别重复药物：在每个治疗类别 $g$ 内，仅考虑那些 $I_i = 1$ 的药物。在这些药物中，精确选择一个代表药物予以保留。代表药物是具有最高 $B_i$ 的药物。如果 $B_i$ 存在并列，则从并列的药物中选择具有最低 $p_i \\times c_i$ 的药物。如果仍然存在并列，则选择具有最小 $d_i$ 的药物。该类别中所有其他未被选为代表且 $I_i = 1$ 的药物，为了优先排序的目的，均被视为重复药物。在选择代表药物时，不考虑 $I_i = 0$ 的药物。\n\n待实现的排序规则：为每种药物分配一个类别，然后根据一个编码了临床优先排序原则的确定性多键规则进行排序。类别确定如下：类别 $0$ 用于缺乏适应证（$I_i = 0$），类别 $1$ 用于治疗重复（即上文标记为重复的药物），类别 $2$ 用于所有其他药物。然后使用以下键，按此顺序应用字典序排序：\n$1.$ 主键：类别，按升序排列（$0$ 在 $1$ 之前，$1$ 在 $2$ 之前）。\n$2.$ 在同一类别内，按预期伤害成本 $p_i \\times c_i$ 降序排列。\n$3.$ 如果仍然并列，按获益 $B_i$ 升序排列。\n$4.$ 如果仍然并列，按伤害概率 $p_i$ 降序排列。\n$5.$ 如果仍然并列，按药物标识符 $d_i$ 升序排列。\n\n您的程序应处理以下测试套件。每个方案包含 $12$ 种药物，且必须独立处理，为每个方案生成一个药物标识符的排序列表。\n\n测试套件：\n\n方案 A：\n$1$: $(g=101, I=1, B=6.0, p=0.06, c=4)$\n$2$: $(g=101, I=1, B=4.0, p=0.08, c=5)$\n$3$: $(g=101, I=0, B=2.0, p=0.05, c=4)$\n$4$: $(g=202, I=1, B=3.0, p=0.15, c=6)$\n$5$: $(g=202, I=1, B=2.0, p=0.10, c=6)$\n$6$: $(g=303, I=0, B=1.0, p=0.02, c=2)$\n$7$: $(g=404, I=1, B=1.5, p=0.20, c=8)$\n$8$: $(g=404, I=1, B=0.5, p=0.18, c=8)$\n$9$: $(g=505, I=1, B=5.0, p=0.03, c=3)$\n$10$: $(g=606, I=1, B=0.8, p=0.12, c=7)$\n$11$: $(g=707, I=0, B=0.0, p=0.01, c=1)$\n$12$: $(g=808, I=1, B=2.5, p=0.05, c=5)$\n\n方案 B：\n$1$: $(g=1, I=0, B=3.0, p=0.10, c=4)$\n$2$: $(g=2, I=0, B=1.0, p=0.20, c=2)$\n$3$: $(g=3, I=0, B=0.5, p=0.05, c=4)$\n$4$: $(g=4, I=0, B=2.0, p=0.05, c=1)$\n$5$: $(g=5, I=1, B=4.0, p=0.05, c=4)$\n$6$: $(g=6, I=1, B=3.0, p=0.02, c=9)$\n$7$: $(g=7, I=1, B=5.0, p=0.01, c=10)$\n$8$: $(g=8, I=1, B=2.0, p=0.30, c=1)$\n$9$: $(g=9, I=1, B=1.0, p=0.20, c=2)$\n$10$: $(g=10, I=1, B=0.2, p=0.40, c=1)$\n$11$: $(g=11, I=1, B=0.2, p=0.40, c=1)$\n$12$: $(g=12, I=1, B=10.0, p=0.00, c=10)$\n\n方案 C：\n$1$: $(g=901, I=1, B=3.0, p=0.15, c=5)$\n$2$: $(g=901, I=1, B=7.0, p=0.05, c=3)$\n$3$: $(g=902, I=0, B=1.0, p=0.10, c=4)$\n$4$: $(g=902, I=1, B=2.0, p=0.10, c=7)$\n$5$: $(g=902, I=1, B=2.0, p=0.05, c=7)$\n$6$: $(g=903, I=1, B=1.0, p=0.20, c=5)$\n$7$: $(g=904, I=0, B=0.5, p=0.30, c=6)$\n$8$: $(g=904, I=0, B=0.5, p=0.05, c=6)$\n$9$: $(g=905, I=1, B=4.0, p=0.02, c=2)$\n$10$: $(g=905, I=1, B=4.5, p=0.02, c=9)$\n$11$: $(g=905, I=1, B=4.2, p=0.50, c=1)$\n$12$: $(g=906, I=1, B=0.1, p=0.01, c=1)$\n\n角度单位不适用。所有概率都必须作为 $[0,1]$ 区间内的小数处理。不使用物理单位；所有评分都是抽象的，但必须进行定量处理。\n\n您的程序必须：\n$1.$ 实现上文所述的精确重复检测规则和排序规则。\n$2.$ 将这些规则独立应用于测试套件中的每个方案。\n$3.$ 生成单行输出，其中包含三个结果排序列表，格式为类似 Python 的列表嵌套列表，除了默认的列表格式化之外，不移除或添加任何空格。例如，外部结构必须是一个包含三个内部列表的单一列表，每个内部列表是一个方案的有序药物标识符。最终输出必须是类似 \"[[...],[...],[...]]\" 的单行文本。",
            "solution": "问题陈述经评估是有效的。它在科学上基于临床药理学原则，特别是在处方精简背景下的风险-效益分析。该问题是适定的，提供了一套完整且内部一致的定义、数据和确定性规则，从而可以推导出一个唯一且可验证的解。所有术语都得到了形式化定义，排序逻辑通过一系列无歧义的平局打破规则来指定，并最终通过唯一的药物标识符进行排序。\n\n解决方案是所指定的处方精简优先排序方案的算法实现。对每个药物方案，该过程都独立执行。核心方法包括用派生属性（预期伤害成本、重复状态和优先级类别）来扩充初始药物数据，然后执行多键字典序排序。\n\n每个方案的逐步过程如下：\n\n1.  **数据结构化与预期伤害的预计算**：\n    每种药物都表示为一个数据结构，包含其给定属性：标识符 $d_i$、治疗类别 $g_i$、适应证标志 $I_i$、获益评分 $B_i$、伤害概率 $p_i$ 和伤害严重性权重 $c_i$。使用提供的公式为每种药物计算一个关键的派生属性——预期伤害成本 $H_i$：\n    $$H_i = p_i \\times c_i$$\n    该值量化了药物的预期负面影响，是一个主要的排序列。\n\n2.  **识别治疗重复**：\n    为实现治疗重复的规则，首先按药物的治疗类别标签 $g_i$ 进行分组。在每个组内，应用以下程序：\n    a. 创建一个仅包含有适应证（即 $I_i = 1$）的药物子集。\n    b. 如果该子集包含多于一种药物，则必须选择单一的“代表”药物予以保留。该子集中的所有其他药物都被标记为重复。\n    c. 代表药物的选择基于一个顺序性的平局打破规则。子集中的药物按以下键的顺序进行排序：\n        i. 按获益评分 $B_i$ 降序。\n        ii. 按预期伤害成本 $H_i = p_i \\times c_i$ 升序。\n        iii. 按药物标识符 $d_i$ 升序。\n    此排序列表中的第一个药物即为代表。该类别 $g_i$ 的 $I_i=1$ 子集中的所有其他药物均被标记为重复。在此步骤中不考虑 $I_i=0$ 的药物，它们不能被标记为重复。\n\n3.  **为优先排序进行分类**：\n    在识别出重复药物后，为每种药物分配一个优先级类别，该类别将作为主要排序列。这些类别的定义旨在反映临床优先级：\n    - **类别 $0$**：没有当前适应证的药物（$I_i = 0$）。这些是处方精简的最高优先级。\n    - **类别 $1$**：在上一步中被识别为治疗重复的药物。这些是次高优先级。\n    - **类别 $2$**：所有其余的药物，它们有适应证且不是重复药物。这些药物的处方精简优先级最低。\n\n4.  **字典序排序与最终排名**：\n    最后，对方案的完整药物列表（现已扩充了预期伤害成本 $H_i$ 和优先级类别）进行排序，以生成用于处方精简的最终排名列表。排序是字典序的，意味着它会依次通过一系列键，仅在处理前一个键的平局时才移至下一个键。排序顺序指定如下：\n    a. **主键**：类别，按升序排列（$0, 1, 2$）。这将无适应证的药物排在最前，其次是重复药物，然后是所有其他药物。\n    b. **第二键**：在每个类别内，按预期伤害成本 $H_i$ 降序排列。预期伤害更高的药物优先级更高。\n    c. **第三键**：为打破伤害成本的平局，按获益评分 $B_i$ 升序排列。获益较低的药物优先级更高。\n    d. **第四键**：如果仍然并列，按伤害概率 $p_i$ 降序排列。\n    e. **第五键**：作为最后的平局打破规则，按药物标识符 $d_i$ 升序排列，以确保唯一且稳定的顺序。\n\n排序后的药物标识符 $d_i$ 列表构成了该方案的最终输出。对所提供的三个测试方案中的每一个都重复此完整过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No scipy or other libraries are needed for this problem.\n\ndef solve():\n    \"\"\"\n    Implements a principled prioritization scheme for deprescribing in polypharmacy.\n    The function processes three drug regimens based on a set of deterministic rules,\n    producing a ranked list of drugs for deprescribing for each regimen.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each drug is defined by: (g, I, B, p, c)\n    test_suite = {\n        \"A\": [\n            # d_i: (g, I, B, p, c)\n            (101, 1, 6.0, 0.06, 4), (101, 1, 4.0, 0.08, 5), (101, 0, 2.0, 0.05, 4),\n            (202, 1, 3.0, 0.15, 6), (202, 1, 2.0, 0.10, 6), (303, 0, 1.0, 0.02, 2),\n            (404, 1, 1.5, 0.20, 8), (404, 1, 0.5, 0.18, 8), (505, 1, 5.0, 0.03, 3),\n            (606, 1, 0.8, 0.12, 7), (707, 0, 0.0, 0.01, 1), (808, 1, 2.5, 0.05, 5),\n        ],\n        \"B\": [\n            (1, 0, 3.0, 0.10, 4), (2, 0, 1.0, 0.20, 2), (3, 0, 0.5, 0.05, 4),\n            (4, 0, 2.0, 0.05, 1), (5, 1, 4.0, 0.05, 4), (6, 1, 3.0, 0.02, 9),\n            (7, 1, 5.0, 0.01, 10), (8, 1, 2.0, 0.30, 1), (9, 1, 1.0, 0.20, 2),\n            (10, 1, 0.2, 0.40, 1), (11, 1, 0.2, 0.40, 1), (12, 1, 10.0, 0.00, 10),\n        ],\n        \"C\": [\n            (901, 1, 3.0, 0.15, 5), (901, 1, 7.0, 0.05, 3), (902, 0, 1.0, 0.10, 4),\n            (902, 1, 2.0, 0.10, 7), (902, 1, 2.0, 0.05, 7), (903, 1, 1.0, 0.20, 5),\n            (904, 0, 0.5, 0.30, 6), (904, 0, 0.5, 0.05, 6), (905, 1, 4.0, 0.02, 2),\n            (905, 1, 4.5, 0.02, 9), (905, 1, 4.2, 0.50, 1), (906, 1, 0.1, 0.01, 1),\n        ]\n    }\n\n    regimens_to_process = [test_suite[\"A\"], test_suite[\"B\"], test_suite[\"C\"]]\n    final_results = []\n\n    for regimen_data in regimens_to_process:\n        # 1. Structure data and compute expected harm\n        drugs = []\n        for i, (g, I, B, p, c) in enumerate(regimen_data):\n            drug = {\n                'di': i + 1, 'gi': g, 'Ii': I, 'Bi': B, 'pi': p, 'ci': c,\n                'Hi': p * c,  # Expected Harm Cost\n            }\n            drugs.append(drug)\n\n        # 2. Identify therapeutic duplicates\n        therapeutic_groups = {}\n        for drug in drugs:\n            if drug['gi'] not in therapeutic_groups:\n                therapeutic_groups[drug['gi']] = []\n            therapeutic_groups[drug['gi']].append(drug)\n        \n        duplicate_ids = set()\n        for gi, group_drugs in therapeutic_groups.items():\n            indicated_drugs = [d for d in group_drugs if d['Ii'] == 1]\n            if len(indicated_drugs)  1:\n                # Sort to find representative\n                # Sort by B (desc), then H (asc), then d_i (asc)\n                indicated_drugs.sort(key=lambda d: (-d['Bi'], d['Hi'], d['di']))\n                \n                # The first is the representative, others are duplicates\n                for i in range(1, len(indicated_drugs)):\n                    duplicate_ids.add(indicated_drugs[i]['di'])\n\n        # 3. Categorize drugs\n        for drug in drugs:\n            if drug['Ii'] == 0:\n                drug['category'] = 0\n            elif drug['di'] in duplicate_ids:\n                drug['category'] = 1\n            else:\n                drug['category'] = 2\n\n        # 4. Lexicographic sort\n        # Keys: category (asc), H (desc), B (asc), p (desc), d_i (asc)\n        drugs.sort(key=lambda d: (d['category'], -d['Hi'], d['Bi'], -d['pi'], d['di']))\n\n        # Extract sorted drug identifiers\n        ranked_ids = [d['di'] for d in drugs]\n        final_results.append(ranked_ids)\n\n    # Format the final output string exactly as required\n    inner_lists_str = []\n    for res_list in final_results:\n        inner_lists_str.append(f\"[{','.join(map(str, res_list))}]\")\n    final_str = f\"[{','.join(inner_lists_str)}]\"\n    \n    print(final_str)\n\nsolve()\n\n```"
        }
    ]
}