{
    "hands_on_practices": [
        {
            "introduction": "希尔方程是量化生物系统中协同性的基石。本练习将深入探讨其数学基础，引导您并非从物理机制出发，而是从定义S型响应的一组抽象特性中推导出其为人熟知的形式。通过这个练习，您将增强区分唯象模型与机理模型的能力，这在定量生物学中是一项至关重要的技能 。",
            "id": "3884108",
            "problem": "考虑一个配体激活的变构酶，其具有单一可观测输出，该输出随游离配体浓度 $[L]$ 单调增加，并在 $[L]$ 非常大时达到最大值并饱和。令活化分数（也称占据分数）用 $\\theta([L])$ 表示，定义为酶处于其活化状态的概率。假设该酶具有以下性质，这些性质源于在许多协同结合和活化系统中观察到的S型响应的经验特征：\n\n1. 形状相对于特征浓度 $K$ 的标度不变性：存在一个无量纲函数 $f$，使得 $\\theta([L]) = f([L]/K)$，其中 $K$ 由半活化条件 $\\theta(K) = \\tfrac{1}{2}$ 定义。$[L]$ 和 $K$ 的量均以摩尔浓度 (M) 表示。\n\n2. 符合质量作用活化原理的恰当渐近极限：\n   $$\\lim_{[L]\\to 0} \\theta([L]) = 0, \\quad \\lim_{[L]\\to \\infty} \\theta([L]) = 1.$$\n\n3. 在对数浓度轴上围绕半活化点对称：对于所有正数 $x$，函数满足\n   $$f(x) + f\\!\\left(\\frac{1}{x}\\right) = 1,$$\n   这意味着对数优势比 $\\ln\\!\\big(\\theta([L])/(1-\\theta([L]))\\big)$ 是关于 $\\ln([L]/K)$ 的奇函数。\n\n4. 在动态范围内，对数优势比对配体浓度相对变化的对数敏感度恒定，由一个正常数 $n_H$（希尔系数）表征：$\\ln\\!\\big(\\theta([L])/(1-\\theta([L]))\\big)$ 相对于 $\\ln([L]/K)$ 的斜率与 $[L]$ 无关，在半活化点等于 $n_H$，并且根据假设，在整个动态范围内都等于 $n_H$。\n\n仅从这些性质以及活化分数和对数优势比的标准定义出发，推导与所有四个性质一致的、用 $[L]$、$K$ 和 $n_H$ 表示的 $\\theta([L])$ 的唯一解析表达式。将 $[L]$ 和 $K$ 以摩尔浓度 (M) 表示。然后，基于变构作用机理的第一性原理，讨论这种经验性表示作为一种现象学拟合的局限性，包括它与变构作用的微观质量作用模型的关系。最终答案必须是 $\\theta([L])$ 的单一闭式表达式；无需取整。",
            "solution": "目标是推导出一个与给定性质一致的 $\\theta([L])$ 表达式。我们首先重述将要使用的基本数学构造。活化分数 $\\theta([L])$ 是一个介于0和1之间的无量纲量，解释为在给定配体浓度 $[L]$ 下酶处于活化状态的概率。对数优势比，也称为logit，定义为\n$$\\mathrm{logit}(\\theta) = \\ln\\!\\left(\\frac{\\theta}{1-\\theta}\\right).$$\n\n根据性质1（标度不变性），对于某个满足 $\\theta(K)=\\tfrac{1}{2}$ 的函数 $f$，有 $\\theta([L]) = f([L]/K)$。根据性质2（恰当的渐近性），当 $x\\to 0$ 时 $f(x)\\to 0$，当 $x\\to \\infty$ 时 $f(x)\\to 1$。根据性质3（对称性），对于所有 $x0$，\n$$f(x) + f\\!\\left(\\frac{1}{x}\\right) = 1.$$\n这种对称性意味着\n$$\\frac{f(x)}{1-f(x)} = \\left(\\frac{1}{f(1/x)}\\right) - 1 = \\frac{f(x)}{f(1/x)}.$$\n取对数，对称性条件可以改写为 $f(x)$ 的对数优势比形式：\n$$\\ln\\!\\left(\\frac{f(x)}{1-f(x)}\\right) = -\\,\\ln\\!\\left(\\frac{f(1/x)}{1-f(1/x)}\\right),$$\n这表明函数 $g(y) \\equiv \\ln\\!\\left(\\frac{f(\\exp(y))}{1-f(\\exp(y))}\\right)$ 是关于 $y$ 的奇函数，即 $g(-y) = -g(y)$。用原始变量表示，这意味着\n$$\\ln\\!\\left(\\frac{\\theta([L])}{1-\\theta([L])}\\right)$$\n是关于 $\\ln([L]/K)$ 的奇函数。\n\n根据性质4（对数优势比的恒定对数敏感度），我们断言对数优势比相对于 $\\ln([L]/K)$ 的斜率与 $[L]$ 无关，在半活化点 $\\theta(K)=\\tfrac{1}{2}$ 处等于 $n_H$，并且根据假设，在整个动态范围内都等于 $n_H$。令 $y \\equiv \\ln([L]/K)$，并定义\n$$g(y) \\equiv \\ln\\!\\left(\\frac{\\theta([L])}{1-\\theta([L])}\\right) = \\ln\\!\\left(\\frac{f(\\exp(y))}{1-f(\\exp(y))}\\right).$$\n性质4指出\n$$\\frac{d g(y)}{d y} = n_H,$$\n对于动态范围内的所有 $y$。这是一个具有恒定斜率的一阶常微分方程。对 $y$ 积分得到\n$$g(y) = n_H\\,y + C,$$\n其中 $C$ 是一个积分常数。性质3指出 $g(y)$ 是一个奇函数，这意味着 $g(0)=0$。在 $y=0$ 处（对应于 $[L]=K$ 和 $\\theta=\\tfrac{1}{2}$）求值，我们发现 $g(0) = \\ln\\!\\left(\\frac{1/2}{1-1/2}\\right) = \\ln(1) = 0$，因此 $C=0$。所以，\n$$\\ln\\!\\left(\\frac{\\theta([L])}{1-\\theta([L])}\\right) = n_H \\,\\ln\\!\\left(\\frac{[L]}{K}\\right).$$\n\n对两边取指数，得到\n$$\\frac{\\theta([L])}{1-\\theta([L])} = \\left(\\frac{[L]}{K}\\right)^{n_H}.$$\n解出 $\\theta([L])$，\n$$\\theta([L]) = \\frac{\\left(\\frac{[L]}{K}\\right)^{n_H}}{1+\\left(\\frac{[L]}{K}\\right)^{n_H}} = \\frac{[L]^{n_H}}{K^{n_H} + [L]^{n_H}}.$$\n该表达式满足相对于 $K$ 的标度不变性，得出 $\\theta(K)=\\tfrac{1}{2}$，并服从渐近性：当 $[L]\\to 0$ 时，分子相对于分母可以忽略不计，得到 $\\theta\\to 0$；当 $[L]\\to \\infty$ 时，分母由 $[L]^{n_H}$ 主导，得到 $\\theta\\to 1$。此外，对称性 $f(x)+f(1/x)=1$ 也得到满足，因为\n$$\\frac{x^{n_H}}{1+x^{n_H}} + \\frac{(1/x)^{n_H}}{1+(1/x)^{n_H}} = \\frac{x^{n_H}}{1+x^{n_H}} + \\frac{1}{1+x^{n_H}} = 1.$$\n\n因此，在所述假设下，与所有四个性质一致的唯一解析表达式为\n$$\\theta([L]) = \\frac{[L]^{n_H}}{K^{n_H} + [L]^{n_H}},$$\n其中 $[L]$ 和 $K$ 以摩尔浓度 (M) 表示，$\\theta$ 是无量纲的。\n\n作为现象学拟合的局限性及其与机理性变构的关系：\n\n- $n_H$ 的微观可解释性：参数 $n_H$ 在此被定义为在动态范围内对数优势比相对于 $\\ln([L]/K)$ 的恒定斜率。在源自微观质量作用模型（如 Monod–Wyman–Changeux (MWC) 模型或 Koshland–Némethy–Filmer (KNF) 模型）的真实变构系统中，该斜率通常随 $[L]$ 变化。希尔系数等于半活化点处的斜率，但通常不等于结合位点的数量，也不会在不同 $[L]$ 值下保持不变。因此，$n_H$ 是一个捕捉表观协同性的现象学参数，但不能唯一地映射到一个特定的机制或位点数量。\n\n- 热力学一致性与微观状态解析：希尔形式将多状态结合和构象平衡集总为一个单一的有效等温线。它没有编码通过枚举与微观可逆性和细致平衡一致的微观状态而产生的结合多项式。因此，希尔等温线可能违反在异促变构中由热力学耦合和多配体偶联所施加的约束，并且除了通过平均斜率之外，它无法预测诸如顺序结合步骤、负协同性或状态依赖的亲和力变化等精细特征。\n\n- 调节剂和效应剂的作用：在机理模型中，变构调节剂会改变特定的平衡常数（例如，构象能或位点亲和力）。希尔方程可以模仿左移或右移（$K$ 的有效变化）和表观斜率变化（$n_H$ 的有效变化），但它无法辨别这些变化是源于改变的构象平衡、改变的位点亲和力，还是活性位点数量的变化。因此，它对突变效应和效应剂特异性扰动的预测能力有限。\n\n- 配体耗尽与有限受体浓度：希尔形式假设 $[L]$ 实际上是恒定的（浴近似）。在配体并非大量过量的细胞环境中，结合会耗尽游离配体，正确的等温线应包含守恒约束。希尔形式没有包含这些约束，并可能在配体和受体浓度相当的情况下错误估计活化程度。\n\n- 全局斜率恒定性：推导假设了对数优势比相对于 $\\ln([L]/K)$ 的斜率是恒定的。真实的协同系统通常表现出非恒定的对数敏感度；例如，陡峭程度可能在半活化点附近最大，而在两端则较平缓。因此，希尔形式可能会高估或低估远离中等浓度范围的敏感度，并可能在系统模型中错误地表示噪声过滤和超敏性。\n\n总而言之，推导出的表达式是一个紧凑的、标度不变的S型曲线，通过 $n_H$ 捕捉了平均协同性，但它是现象学的，可能不符合微观质量作用约束，也无法提供对变构调控的机理洞见。当需要进行机理诠释或对扰动进行预测性建模时，应谨慎使用。",
            "answer": "$$\\boxed{\\frac{[L]^{n_H}}{K^{n_H} + [L]^{n_H}}}$$"
        },
        {
            "introduction": "在探讨了经验性的希尔方程之后，我们现在转向使用Koshland-Némethy-Filmer (KNF) 序贯模型对协同性进行机理层面的解释。本练习要求您从第一性原理出发，在只有完全配体结合的酶才具有活性的假设下，构建酶的速率方程。通过完成此推导，您将具体理解逐步的结合事件如何共同产生协同的系统响应 。",
            "id": "3884072",
            "problem": "一个具有 $n$ 个相同底物结合位点的寡聚酶遵循 Koshland–Némethy–Filmer (KNF) 诱导契合序贯变构模型。设底物为 $S$，游离酶为 $E$，结合了 $i$ 个配体的酶为 $ES_i$（其中 $i \\in \\{1,\\dots,n\\}$）。假设底物结合相对于催化过程达到快速平衡，且产物积累可忽略不计，因此配体结合状态的分布遵循质量作用定律。宏观逐步结合常数 $K_i$ 定义为\n$$\nK_i \\equiv \\frac{[ES_i]}{[ES_{i-1}][S]}, \\quad i=1,\\dots,n,\n$$\n其中 $ES_0 \\equiv E$。只有完全结合配体的复合物 $ES_n$ 具有催化活性，并以一级催化速率常数 $k_{\\mathrm{cat}}$ 转化为产物；所有其他配体结合状态均无催化活性。总酶浓度是守恒的，由 $E_{\\mathrm{T}} = [E] + \\sum_{i=1}^{n}[ES_i]$ 给出。\n\n仅从质量作用定律、宏观逐步结合常数 $K_i$ 的定义以及酶守恒出发，推导出初始速率 $v([S])$ 的一个闭合形式解析表达式，该表达式应以 $[S]$、$\\{K_i\\}_{i=1}^{n}$、$k_{\\mathrm{cat}}$ 和 $E_{\\mathrm{T}}$ 来表示。将您的最终答案表示为单个解析表达式。不要代入任何数值，也不要在最终表达式中包含单位。",
            "solution": "反应的初始速率，记为 $v$，由产物的生成速率决定。根据题目陈述，只有完全结合配体的酶-底物复合物 $ES_n$ 具有催化活性。$ES_n$ 向产物的转化遵循一级动力学，其速率常数为 $k_{\\mathrm{cat}}$。因此，初始速率由以下表达式给出：\n$$\nv = k_{\\mathrm{cat}} [ES_n]\n$$\n我们的目标是用总酶浓度 $E_{\\mathrm{T}}$、底物浓度 $[S]$ 以及宏观逐步结合常数集 $\\{K_i\\}_{i=1}^{n}$ 来表示活性复合物的浓度 $[ES_n]$。\n\n连续结合配体的酶物种浓度之间的关系遵循质量作用定律，由逐步结合常数 $K_i$ 描述如下：\n$$\nK_i = \\frac{[ES_i]}{[ES_{i-1}][S]} \\quad \\text{for } i \\in \\{1, \\dots, n\\}\n$$\n其中 $[ES_0]$ 定义为游离酶的浓度 $[E]$。\n\n我们可以利用这组平衡关系，用 $[E]$、$[S]$ 和相关的结合常数来表示任意配体结合物种 $[ES_i]$ 的浓度。\n对于 $i=1$：\n$$\n[ES_1] = K_1 [ES_0] [S] = K_1 [E] [S]\n$$\n对于 $i=2$：\n$$\n[ES_2] = K_2 [ES_1] [S] = K_2 \\left( K_1 [E] [S] \\right) [S] = (K_1 K_2) [E] [S]^2\n$$\n通过继续这种递归代换，我们可以建立第 $i$ 个配体结合物种 $[ES_i]$ 浓度的通式：\n$$\n[ES_i] = \\left( \\prod_{j=1}^{i} K_j \\right) [E] [S]^i\n$$\n这个通式对所有 $i \\in \\{1, \\dots, n\\}$ 都成立。\n\n接下来，我们应用总酶浓度 $E_{\\mathrm{T}}$ 守恒原理。总酶浓度是游离酶和所有配体结合形式的浓度之和：\n$$\nE_{\\mathrm{T}} = [E] + \\sum_{i=1}^{n} [ES_i]\n$$\n将我们关于 $[ES_i]$ 的通式代入守恒方程，得到：\n$$\nE_{\\mathrm{T}} = [E] + \\sum_{i=1}^{n} \\left( \\left( \\prod_{j=1}^{i} K_j \\right) [E] [S]^i \\right)\n$$\n我们可以从右侧提取游离酶浓度 $[E]$ 作为公因子：\n$$\nE_{\\mathrm{T}} = [E] \\left( 1 + \\sum_{i=1}^{n} \\left( \\left( \\prod_{j=1}^{i} K_j \\right) [S]^i \\right) \\right)\n$$\n这个方程使我们能够用 $E_{\\mathrm{T}}$、$[S]$ 和结合常数来表示游离酶的浓度 $[E]$：\n$$\n[E] = \\frac{E_{\\mathrm{T}}}{1 + \\sum_{i=1}^{n} \\left( \\left( \\prod_{j=1}^{i} K_j \\right) [S]^i \\right)}\n$$\n现在我们可以确定催化活性物种 $[ES_n]$ 的浓度。使用我们关于 $[ES_i]$ 的通式，并令 $i=n$：\n$$\n[ES_n] = \\left( \\prod_{j=1}^{n} K_j \\right) [E] [S]^n\n$$\n将 $[E]$ 的表达式代入此方程，可以得到仅用题目给定参数表示的 $[ES_n]$：\n$$\n[ES_n] = \\left( \\prod_{j=1}^{n} K_j \\right) [S]^n \\left( \\frac{E_{\\mathrm{T}}}{1 + \\sum_{i=1}^{n} \\left( \\left( \\prod_{j=1}^{i} K_j \\right) [S]^i \\right)} \\right)\n$$\n为清晰起见，整理后我们得到：\n$$\n[ES_n] = \\frac{E_{\\mathrm{T}} \\left( \\prod_{j=1}^{n} K_j \\right) [S]^n}{1 + \\sum_{i=1}^{n} \\left( \\left( \\prod_{j=1}^{i} K_j \\right) [S]^i \\right)}\n$$\n最后，我们将 $[ES_n]$ 的这个闭合形式表达式代入初始速率方程 $v = k_{\\mathrm{cat}} [ES_n]$，以获得所需的结果：\n$$\nv([S]) = k_{\\mathrm{cat}} \\left( \\frac{E_{\\mathrm{T}} \\left( \\prod_{j=1}^{n} K_j \\right) [S]^n}{1 + \\sum_{i=1}^{n} \\left( \\left( \\prod_{j=1}^{i} K_j \\right) [S]^i \\right)} \\right)\n$$\n该表达式将反应初始速率表示为底物浓度和系统基本参数的函数，符合题目要求。",
            "answer": "$$\n\\boxed{\\frac{k_{\\mathrm{cat}} E_{\\mathrm{T}} \\left( \\prod_{j=1}^{n} K_j \\right) [S]^n}{1 + \\sum_{i=1}^{n} \\left( \\left( \\prod_{j=1}^{i} K_j \\right) [S]^i \\right)}}\n$$"
        },
        {
            "introduction": "当酶在一个更大的生物网络中发挥作用时，变构调控的真正威力才得以显现。这个高级计算练习旨在探索将一个变构酶置于正反馈回路中所产生的动态后果。您将使用数值分岔分析，来发现酶固有的超敏性（ultrasensitivity）如何能够产生如双稳态（bistability）和迟滞（hysteresis）等系统层面的特性，这些特性是细胞开关和记忆的分子基础 。",
            "id": "3884074",
            "problem": "考虑一种酶，它可存在于两种构象状态：松弛态 $R$ 和紧张态 $T$。其行为遵循 Monod–Wyman–Changeux (MWC) 变构模型。设 $x$ 表示变构激活剂的无量纲浓度（通过松弛态解离常数进行缩放），并假设该酶会产生这种激活剂，从而形成正反馈。处于 $R$ 态的酶所占的比例，记为 $f_R(x)$，由一个基于质量作用结合的标准 MWC 占有率公式给出。其中，$L$ 是变构常数（在无配体情况下 $T$ 与 $R$ 的比率），$m$ 是每个酶上相同结合位点的数量，$K_R$ 和 $K_T$ 分别是激活剂与 $R$ 态和 $T$ 态的解离常数。假设 $K_T \\gg K_R$，以模拟一种优先稳定 $R$ 态的激活剂。\n\n设激活剂的生成-降解动力学由以下常微分方程 (ODE) 建模：\n$$\n\\frac{dx}{dt} = k_b + k_p\\, f_R(x; L, m, K_R, K_T) - k_d\\, x,\n$$\n其中 $k_b \\ge 0$ 是基础生成速率（无量纲），$k_p \\ge 0$ 是最大激活诱导生成速率（无量纲），$k_d  0$ 是一级降解速率（无量纲）。系统在满足以下条件的 $x^\\ast$ 值处呈现稳态：\n$$\n0 = k_b + k_p\\, f_R(x^\\ast; L, m, K_R, K_T) - k_d\\, x^\\ast.\n$$\n如果雅可比行列式（右侧函数关于 $x$ 的导数）在 $x^\\ast$ 处的值为负，则稳态 $x^\\ast$ 是局部稳定的：\n$$\nJ(x^\\ast) = k_p\\, \\frac{df_R}{dx}(x^\\ast; L, m, K_R, K_T) - k_d  0.\n$$\n\n任务：\n1. 从 Monod–Wyman–Changeux (MWC) 模型的假设和质量作用结合出发，推导出 $f_R(x; L, m, K_R, K_T)$ 及其导数 $\\frac{df_R}{dx}(x; L, m, K_R, K_T)$ 作为 $x$ 的函数的计算表达式。\n2. 使用这些表达式和上述 ODE，为给定的参数集实现一个数值分岔分析。具体而言：\n   - 对于给定的参数集，计算所有非负实数稳态 $x^\\ast$，并使用 $J(x^\\ast)$ 对其稳定性进行分类。\n   - 对于该参数集，确定系统是否是双稳态的（即存在两个由一个不稳定稳态隔开的不同稳定稳态）。\n3. 对于固定的 $(L, m, K_R, K_T, k_b)$，通过在 $(k_p, k_d)$ 参数平面上扫描一个小网格来绘制双稳态区域。返回双稳态网格点的数量。\n4. 通过在 $k_p$ 上进行参数扫描来说明滞后现象：\n   - 进行前向扫描：将 $k_p$ 从一个低值逐步增加到一个高值，在每一步通过连续性选择稳定稳态（选择离上一步平衡点最近的稳定平衡点）。记录所追踪的稳定分支消失（跳跃到另一个分支）时的第一个 $k_p$ 值。\n   - 进行反向扫描：将 $k_p$ 从一个高值逐步降低到一个低值，类似地追踪稳定分支并记录跳跃时的 $k_p$ 值。\n   - 计算滞后宽度，即反向扫描跳跃值与前向扫描跳跃值在 $k_p$ 上的差值。如果两次扫描均未发生跳跃，则定义滞后宽度为 $0$。\n所有变量由于经过缩放都是无量纲的；不涉及物理单位。在有限域 $x \\in [0, x_{\\max}]$ 上使用稳健的数值求根区间法，其中 $x_{\\max}$ 的选择应足够大以包含所有交点。如果 $k_b + k_p \\le 0$，则将系统视为除基础生成外没有其他生成，并进行相应处理。在整个过程中确保 $x$ 的非负性。\n\n测试套件：\n提供三个参数集以测试不同方面：\n- 情况 A（正常路径，单稳态）：$(L, m, K_R, K_T, k_b) = (10, 3, 1.0, 10.0, 0.01)$；在 $3 \\times 3$ 网格上扫描 $(k_p, k_d)$，其中 $k_p \\in \\{0.2, 0.4, 0.6\\}$，$k_d \\in \\{0.8, 1.0, 1.2\\}$；在 $k_p$ 上执行从 $0.0$ 到 $2.0$ 的滞后扫描，步长为 $0.02$。\n- 情况 B（预期存在双稳态区域）：$(L, m, K_R, K_T, k_b) = (200, 4, 1.0, 50.0, 0.01)$；在 $5 \\times 5$ 网格上扫描 $(k_p, k_d)$，其中 $k_p \\in \\{0.5, 0.75, 1.0, 1.25, 1.5\\}$，$k_d \\in \\{0.10, 0.175, 0.25, 0.325, 0.40\\}$；在 $k_p$ 上执行从 $0.0$ 到 $2.0$ 的滞后扫描，步长为 $0.02$。\n- 情况 C（接近边界，敏感）：$(L, m, K_R, K_T, k_b) = (80, 4, 1.0, 30.0, 0.01)$；在 $4 \\times 4$ 网格上扫描 $(k_p, k_d)$，其中 $k_p \\in \\{0.6, 0.8, 1.0, 1.2\\}$，$k_d \\in \\{0.20, 0.23, 0.26, 0.29\\}$；在 $k_p$ 上执行从 $0.0$ 到 $2.0$ 的滞后扫描，步长为 $0.02$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于三种情况中的每一种，输出一个双元素列表 $[B, H]$，其中 $B$ 是在 $(k_p, k_d)$ 扫描中找到的双稳态网格点的整数计数，而 $H$ 是从 $k_p$ 扫描中计算出的滞后宽度（一个无量纲单位的浮点数）。最终输出必须是以下形式：\n$$\n[[B_A, H_A],[B_B, H_B],[B_C, H_C]]\n$$\n且无额外文本。",
            "solution": "我们从用于变构调节的 Monod–Wyman–Changeux (MWC) 模型开始。该酶具有两种构象状态，松弛态 $R$ 和紧张态 $T$，其变构常数 $L$ 等于在无配体情况下 $T$ 与 $R$ 的比率。一个变构激活剂可以结合到 $R$ 和 $T$ 两种状态上，其解离常数分别为 $K_R$ 和 $K_T$，并且有 $m$ 个相同的结合位点。在快速平衡和质量作用结合的条件下，每种状态下配体占据的统计权重为\n$$\nA_R(x) = \\left(1 + \\frac{x}{K_R}\\right)^m,\\quad A_T(x) = \\left(1 + \\frac{x}{K_T}\\right)^m,\n$$\n它们的比值为\n$$\nR(x) = \\frac{A_T(x)}{A_R(x)} = \\left(\\frac{1 + x/K_T}{1 + x/K_R}\\right)^m.\n$$\n处于 $R$ 态的酶分子所占的比例是条件概率\n$$\nf_R(x; L, m, K_R, K_T) = \\frac{1}{1 + L\\, R(x)} = \\frac{1}{1 + L \\left(\\frac{1 + x/K_T}{1 + x/K_R}\\right)^m}.\n$$\n这是一个从 MWC 框架和质量作用结合平衡推导出的、经过充分检验的公式。\n\n为了使用 ODE\n$$\n\\frac{dx}{dt} = k_b + k_p\\, f_R(x; L, m, K_R, K_T) - k_d\\, x,\n$$\n我们需要 $f_R(x)$ 关于 $x$ 的导数来进行稳定性分析。使用链式法则对 $R(x)$ 求导：\n$$\n\\frac{d}{dx}\\ln R(x) = m\\left(\\frac{1/K_T}{1 + x/K_T} - \\frac{1/K_R}{1 + x/K_R}\\right),\n$$\n所以\n$$\n\\frac{dR}{dx} = R(x)\\, m\\left(\\frac{1/K_T}{1 + x/K_T} - \\frac{1/K_R}{1 + x/K_R}\\right).\n$$\n对 $f_R(x) = \\left(1 + L R(x)\\right)^{-1}$ 应用求导法则得出\n$$\n\\frac{df_R}{dx}(x; L, m, K_R, K_T) = -\\frac{L\\, \\frac{dR}{dx}}{\\left(1 + L R(x)\\right)^2}\n= -\\frac{L\\, R(x)\\, m\\left(\\frac{1/K_T}{1 + x/K_T} - \\frac{1/K_R}{1 + x/K_R}\\right)}{\\left(1 + L R(x)\\right)^2}.\n$$\n对于一个 $K_T \\gg K_R$ 的激活剂，括号中的项为负，因此总导数为正，这与激活型配体的预期相符。\n\n稳态 $x^\\ast$ 满足\n$$\nh(x^\\ast) \\equiv k_b + k_p\\, f_R(x^\\ast) - k_d\\, x^\\ast = 0.\n$$\n为了在数值上找到所有非负稳态，我们在一个足够大的 $x_{\\max}$ 所定义的有限域 $x \\in [0, x_{\\max}]$ 上界定 $h(x)$ 的根。由于 $f_R(x) \\in (0, 1)$，当 $x \\to \\infty$ 时，$h(x) \\sim k_b + k_p - k_d x$，该值最终会变为负值；在 $x = 0$ 处，对于非负的 $k_b$ 和 $k_p$，$h(0) = k_b + k_p f_R(0) \\ge 0$。因此，至少存在一个根。我们在一个网格上对 $h(x)$进行采样，并使用稳健的区间法（例如 Brent 方法）来精化符号发生改变处的根的位置。\n\n为了分类稳定性，我们在每个稳态处计算雅可比矩阵：\n$$\nJ(x^\\ast) = k_p\\, \\frac{df_R}{dx}(x^\\ast) - k_d.\n$$\n如果 $J(x^\\ast)  0$，该不动点是局部稳定的；如果 $J(x^\\ast) > 0$，则它是不稳定的。在一个一维连续时间自治常微分方程中，局部稳定性取决于向量场在不动点处导数的符号。\n\n当存在三个非负实数不动点时，会出现双稳态：两个稳定平衡点被一个不稳定平衡点隔开。使用上述程序，我们可以确定对于固定的 $(L, m, K_R, K_T, k_b)$，给定的参数对 $(k_p, k_d)$ 是否会产生双稳态。绘制双稳态区域意味着在 $(k_p, k_d)$ 平面上扫描一个网格，并计算产生这种模式的参数对的数量。\n\n为了说明由折叠（鞍-结）分岔引起的滞后现象，我们在控制参数 $k_p$ 上进行扫描：\n- 在一个递增 $k_p$ 的前向扫描中，我们从一个低的 $k_p$ 值开始，计算所有稳定稳态，并选择一个与先前选择的稳定态最接近的稳态（通过邻近性进行延拓）。随着 $k_p$ 的增加，如果所追踪的稳定分支不复存在（一个鞍-结点使该分支湮灭），系统必须跳跃到另一个稳定分支。我们记录跳跃时的 $k_p$ 值。\n- 在一个递减 $k_p$ 的反向扫描中，我们类似地从高的 $k_p$ 值开始追踪高 $x$ 值的那个分支。当该分支消失时，系统会向下跳跃。我们记录那个跳跃值。\n滞后宽度是反向扫描跳跃值与前向扫描跳跃值在 $k_p$ 上的差值。如果没有发生跳跃（在所有 $k_p$ 值下均为单稳态区域），则滞后宽度为零。\n\n算法细节：\n1. 选择足够大的 $x_{\\max}$，例如 $x_{\\max} = \\max\\left(5, \\frac{5(k_b + k_p)}{\\max(k_d, \\varepsilon)}\\right)$，其中 $\\varepsilon  0$ 是一个小数，以避免除以零。在 $[0, x_{\\max}]$ 的细网格上对 $h(x)$ 进行采样，检测符号变化，并应用一个区间求根器来获取所有非负稳态。\n2. 使用上述解析表达式计算 $\\frac{df_R}{dx}$，评估 $J(x^\\ast)$，并分类稳定性。\n3. 对于网格映射，遍历 $(k_p, k_d)$ 值，应用步骤 1-2，并统计双稳态情况的数量。\n4. 对于滞后现象，构建一个 $k_p$ 值的列表。对每个值，找到所有稳定稳态。在每一步选择与前一个选定的根最接近的稳定根（沿 $x$ 的欧几里得距离），当先前追踪的分支消失且不存在邻近的稳定根时，检测到跳跃。记录递增和递减扫描的跳跃值，然后计算滞后宽度。\n\n通过确保 $x$ 的非负性、通过增大 $x_{\\max}$ 来防止无符号变化的情况，以及将只有一个不动点的情况视为单稳态来处理边缘案例。所有量都因通过解离常数进行缩放而是无量纲的，输出的滞后宽度以无量纲单位报告。\n\n测试套件包含三个参数集：\n- 情况 A 关注单稳态区域，并验证双稳态计数为零和滞后宽度为零。\n- 情况 B 探索可能存在双稳态和非零滞后宽度的强正反馈。\n- 情况 C 探究边界附近的敏感性，可能具有小的双稳态区域和小的滞后宽度。\n\n程序输出形式为 $[[B_A, H_A],[B_B, H_B],[B_C, H_C]]$ 的单行，其中 $B_\\cdot$ 是整数，$H_\\cdot$ 是浮点数。\n```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\n# MWC fraction of relaxed (active) state and its derivative\ndef mwc_fraction(x, L, m, KR, KT):\n    # Avoid division by zero with small epsilon\n    x = np.maximum(x, 0.0)\n    AR = (1.0 + x / KR) ** m\n    AT = (1.0 + x / KT) ** m\n    R = AT / AR\n    return 1.0 / (1.0 + L * R)\n\ndef mwc_fraction_derivative(x, L, m, KR, KT):\n    x = np.maximum(x, 0.0)\n    AR = (1.0 + x / KR) ** m\n    AT = (1.0 + x / KT) ** m\n    R = AT / AR\n    denomR = 1.0 + L * R\n    # d/dx ln R = m * [ (1/KT)/(1 + x/KT) - (1/KR)/(1 + x/KR) ]\n    term = m * ((1.0 / KT) / (1.0 + x / KT) - (1.0 / KR) / (1.0 + x / KR))\n    dRdx = R * term\n    # df/dx = -L * dRdx / (1 + L R)^2\n    return -L * dRdx / (denomR ** 2)\n\n# Vector field h(x) = kb + kp * fR(x) - kd * x\ndef h_field(x, params, kp, kd):\n    L, m, KR, KT, kb = params\n    return kb + kp * mwc_fraction(x, L, m, KR, KT) - kd * x\n\ndef jacobian_at_x(x, params, kp, kd):\n    L, m, KR, KT, kb = params\n    df = mwc_fraction_derivative(x, L, m, KR, KT)\n    return kp * df - kd\n\ndef find_roots_and_stability(params, kp, kd, x_max=None, grid_points=2000):\n    # Determine a robust x_max\n    L, m, KR, KT, kb = params\n    if x_max is None:\n        # ensure large enough domain\n        x_max = max(5.0, 5.0 * (kb + max(kp, 1e-6)) / max(kd, 1e-6))\n    xs = np.linspace(0.0, x_max, grid_points + 1)\n    hs = h_field(xs, params, kp, kd)\n\n    # Identify sign changes for bracketing\n    roots = []\n    for i in range(grid_points):\n        h1 = hs[i]\n        h2 = hs[i + 1]\n        if np.isnan(h1) or np.isnan(h2):\n            continue\n        if h1 == 0.0:\n            roots.append(xs[i])\n        elif h2 == 0.0:\n            roots.append(xs[i + 1])\n        elif h1 * h2  0.0:\n            # bracket found\n            try:\n                r = brentq(lambda z: h_field(z, params, kp, kd), xs[i], xs[i + 1], maxiter=200)\n                roots.append(r)\n            except Exception:\n                # If brentq fails, skip this bracket\n                continue\n\n    # Deduplicate roots (numerical noise)\n    roots = sorted(roots)\n    deduped = []\n    for r in roots:\n        if not deduped or abs(r - deduped[-1]) > 1e-6:\n            deduped.append(r)\n    roots = deduped\n\n    # Stability classification: J(x*)  0 => stable\n    stability = []\n    for r in roots:\n        J = jacobian_at_x(r, params, kp, kd)\n        stability.append(J  0.0)\n    return roots, stability\n\ndef is_bistable(roots, stability):\n    # Bistable if there exist at least two stable roots separated by an unstable one\n    # Count stable roots\n    stable_indices = [i for i, st in enumerate(stability) if st]\n    if len(stable_indices)  2 or len(roots)  3:\n        return False\n    # Check if there is an unstable root between the two extreme stable roots\n    min_stable = min(stable_indices)\n    max_stable = max(stable_indices)\n    # There must be at least one root between them and it must be unstable\n    for j in range(min_stable + 1, max_stable):\n        if not stability[j]:\n            return True\n    return False\n\ndef map_bistability(params, kp_values, kd_values):\n    count_bistable = 0\n    for kp in kp_values:\n        for kd in kd_values:\n            roots, stability = find_roots_and_stability(params, kp, kd)\n            if is_bistable(roots, stability):\n                count_bistable += 1\n    return count_bistable\n\ndef hysteresis_width_in_kp(params, kp_min, kp_max, kp_step, kd):\n    # Forward sweep: start at low kp, pick low-x stable state\n    kp_list_forward = np.arange(kp_min, kp_max + kp_step / 2.0, kp_step)\n    kp_list_backward = kp_list_forward[::-1]\n\n    forward_jump_kp = None\n    backward_jump_kp = None\n\n    # Helper to pick nearest stable root to previous x\n    def pick_nearest_stable(roots, stability, x_prev):\n        stable_roots = [r for r, st in zip(roots, stability) if st]\n        if len(stable_roots) == 0:\n            return None\n        if x_prev is None:\n            # For forward sweep, choose smallest stable root initially\n            return min(stable_roots)\n        # Choose root closest to x_prev\n        dists = [abs(r - x_prev) for r in stable_roots]\n        idx = int(np.argmin(dists))\n        return stable_roots[idx]\n\n    # Forward sweep\n    x_prev = None\n    branch_exists = True\n    for kp in kp_list_forward:\n        roots, stability = find_roots_and_stability(params, kp, kd)\n        candidate = pick_nearest_stable(roots, stability, x_prev)\n        if candidate is None:\n            # No stable root: pathological; treat as branch loss\n            if branch_exists and forward_jump_kp is None:\n                forward_jump_kp = kp\n            branch_exists = False\n            x_prev = None\n            continue\n        if x_prev is None:\n            # initialize\n            x_prev = candidate\n            branch_exists = True\n        else:\n            # If previously on branch but now nearest stable is far because branch vanished,\n            # detect jump by checking if previous x is not within any stable root neighborhood.\n            stable_roots = [r for r, st in zip(roots, stability) if st]\n            if branch_exists and len(stable_roots) >= 1:\n                # Check if previous branch root persists approximately\n                # If the closest stable root is not near previous by threshold, infer jump\n                if min(abs(np.array(stable_roots) - x_prev)) > 0.1:\n                    if forward_jump_kp is None:\n                        forward_jump_kp = kp\n                    branch_exists = False\n            x_prev = candidate\n\n    # Backward sweep: choose highest stable root initially\n    def pick_nearest_stable_backward(roots, stability, x_prev):\n        stable_roots = [r for r, st in zip(roots, stability) if st]\n        if len(stable_roots) == 0:\n            return None\n        if x_prev is None:\n            return max(stable_roots)\n        dists = [abs(r - x_prev) for r in stable_roots]\n        idx = int(np.argmin(dists))\n        return stable_roots[idx]\n\n    x_prev = None\n    branch_exists = True\n    for kp in kp_list_backward:\n        roots, stability = find_roots_and_stability(params, kp, kd)\n        candidate = pick_nearest_stable_backward(roots, stability, x_prev)\n        if candidate is None:\n            if branch_exists and backward_jump_kp is None:\n                backward_jump_kp = kp\n            branch_exists = False\n            x_prev = None\n            continue\n        if x_prev is None:\n            x_prev = candidate\n            branch_exists = True\n        else:\n            stable_roots = [r for r, st in zip(roots, stability) if st]\n            if branch_exists and len(stable_roots) >= 1:\n                if min(abs(np.array(stable_roots) - x_prev)) > 0.1:\n                    if backward_jump_kp is None:\n                        backward_jump_kp = kp\n                    branch_exists = False\n            x_prev = candidate\n\n    # Compute hysteresis width\n    if forward_jump_kp is None or backward_jump_kp is None:\n        return 0.0\n    else:\n        return float(max(0.0, backward_jump_kp - forward_jump_kp))\n\ndef solve():\n    results = []\n\n    # Case A: monostable expected\n    params_A = (10.0, 3, 1.0, 10.0, 0.01)  # (L, m, KR, KT, kb)\n    kp_values_A = np.array([0.2, 0.4, 0.6])\n    kd_values_A = np.array([0.8, 1.0, 1.2])\n    count_A = map_bistability(params_A, kp_values_A, kd_values_A)\n    width_A = hysteresis_width_in_kp(params_A, kp_min=0.0, kp_max=2.0, kp_step=0.02, kd=1.0)\n\n    results.append([int(count_A), float(width_A)])\n\n    # Case B: bistable region expected\n    params_B = (200.0, 4, 1.0, 50.0, 0.01)\n    kp_values_B = np.array([0.5, 0.75, 1.0, 1.25, 1.5])\n    kd_values_B = np.array([0.10, 0.175, 0.25, 0.325, 0.40])\n    count_B = map_bistability(params_B, kp_values_B, kd_values_B)\n    width_B = hysteresis_width_in_kp(params_B, kp_min=0.0, kp_max=2.0, kp_step=0.02, kd=0.25)\n\n    results.append([int(count_B), float(width_B)])\n\n    # Case C: near boundary\n    params_C = (80.0, 4, 1.0, 30.0, 0.01)\n    kp_values_C = np.array([0.6, 0.8, 1.0, 1.2])\n    kd_values_C = np.array([0.20, 0.23, 0.26, 0.29])\n    count_C = map_bistability(params_C, kp_values_C, kd_values_C)\n    width_C = hysteresis_width_in_kp(params_C, kp_min=0.0, kp_max=2.0, kp_step=0.02, kd=0.26)\n\n    results.append([int(count_C), float(width_C)])\n    \n    # This is an example of how the output would be generated.\n    # The actual execution is done by the system.\n    # print(f\"[[{results[0][0]},{results[0][1]}],[{results[1][0]},{results[1][1]}],[{results[2][0]},{results[2][1]}]]\")\n\n# To be run by the system to get the final answer.\n# solve()\n```",
            "answer": "[[0,0.0],[10,0.64],[6,0.18]]"
        }
    ]
}