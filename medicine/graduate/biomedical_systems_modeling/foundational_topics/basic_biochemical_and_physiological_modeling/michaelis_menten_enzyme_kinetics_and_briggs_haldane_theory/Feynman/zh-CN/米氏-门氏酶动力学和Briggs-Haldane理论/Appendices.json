{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握酶动力学，必须在抽象的速率常数和可测量的实验数据之间架起一座桥梁。第一个练习就将挑战你完成这一任务，从Briggs-Haldane推导开始，基于第一性原理确定关键的动力学参数，如 $K_{M}$ 和 $k_{\\text{cat}}$。更重要的是，你将对“初始速率”条件的有效性进行一项关键性检验，这是许多生物化学分析中的一个基本假设。",
            "id": "2649716",
            "problem": "研究了一种用于基准测试抑制机制的酶催化反应，该研究在旨在验证无抑制剂作为对照组的初始速率体系的条件下进行。其基元机制是两步结合与催化方案\n$$\nE + S \\xrightleftharpoons[k_{-1}]{k_{1}} ES \\xrightarrow{k_{2}} E + P,\n$$\n其中总酶浓度守恒，即 $[E]_{0} = [E] + [ES]$。假设质量作用动力学，早期逆向产物形成可忽略不计，且 $[S]_{0} \\gg [E]_{0}$。准稳态近似 (Quasi-Steady-State Approximation, QSSA) 定义为在初始速率窗口内假设 $d[ES]/dt \\approx 0$。\n\n给定以下物理上合理的参数：\n- 结合速率常数 $k_{1} = 1.2 \\times 10^{7}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}$，\n- 解离速率常数 $k_{-1} = 180\\ \\mathrm{s}^{-1}$，\n- 催化速率常数 $k_{2} = 20\\ \\mathrm{s}^{-1}$，\n- 总酶浓度 $[E]_{0} = 12\\ \\mathrm{nM}$，\n- 初始底物浓度 $[S]_{0} = 50\\ \\mathrm{\\mu M}$，\n\n从质量作用速率方程和守恒定律出发，执行以下操作，期间不得引用任何非由这些原则推导出的结果：\n\n1) 在 QSSA 条件下，用 $k_{1}$、$k_{-1}$ 和 $k_{2}$ 推导米氏常数 $K_{M}$ 和催化常数 $k_{\\text{cat}}$ 的定义。\n\n2) 使用您推导出的关系，计算 $t=0$ 时的 $K_{M}$（单位为 $\\mathrm{M}$）、$k_{\\text{cat}}$（单位为 $\\mathrm{s}^{-1}$）和初始速率 $v_{0}$（单位为 $\\mathrm{M}\\ \\mathrm{s}^{-1}$）。\n\n3) 使用化学计量式 $S \\to P$ 并假设初始速率在前 $5$ 秒内大致保持恒定，估算 $5$ 秒后底物消耗的分数（以无单位小数表示）。基于此分数，通过将其与一个保守的微小变化准则（例如，小于 $0.05$）进行比较，评估初始速率近似在 $5$ 秒内是否仍然有效。\n\n将第 3 部分中您最终报告的分数四舍五入至四位有效数字。以无单位小数形式表示最终答案。仅报告此最终分数作为您的答案。",
            "solution": "根据题目要求，解答分为三个部分构建。\n\n**第 1 部分：$K_M$ 和 $k_{\\text{cat}}$ 的推导**\n\n酶-底物复合物浓度 $[ES]$ 的变化率由应用于给定机制的质量作用定律描述：\n$$\n\\frac{d[ES]}{dt} = k_{1}[E][S] - k_{-1}[ES] - k_{2}[ES] = k_{1}[E][S] - (k_{-1} + k_{2})[ES]\n$$\n反应速率 $v$ 是产物 $P$ 的生成速率：\n$$\nv = \\frac{d[P]}{dt} = k_{2}[ES]\n$$\n准稳态近似 (QSSA) 假设中间复合物 $[ES]$ 的浓度在初始速率测量的时间尺度上几乎保持不变，即 $\\frac{d[ES]}{dt} \\approx 0$。将此近似应用于 $[ES]$ 的速率方程可得：\n$$\nk_{1}[E][S] \\approx (k_{-1} + k_{2})[ES]\n$$\n总酶浓度 $[E]_{0}$ 是守恒的：$[E]_{0} = [E] + [ES]$。这使我们能够将游离酶的浓度 $[E]$ 表示为 $[E] = [E]_{0} - [ES]$。将此代入稳态方程得到：\n$$\nk_{1}([E]_{0} - [ES])[S] \\approx (k_{-1} + k_{2})[ES]\n$$\n我们重排此表达式以求解 $[ES]$：\n$$\nk_{1}[E]_{0}[S] - k_{1}[ES][S] \\approx (k_{-1} + k_{2})[ES]\n$$\n$$\nk_{1}[E]_{0}[S] \\approx (k_{-1} + k_{2})[ES] + k_{1}[ES][S]\n$$\n$$\nk_{1}[E]_{0}[S] \\approx [ES]((k_{-1} + k_{2}) + k_{1}[S])\n$$\n$$\n[ES] \\approx \\frac{k_{1}[E]_{0}[S]}{(k_{-1} + k_{2}) + k_{1}[S]}\n$$\n为得到速率定律的标准形式，我们将分子和分母同除以 $k_{1}$：\n$$\n[ES] \\approx \\frac{[E]_{0}[S]}{\\frac{k_{-1} + k_{2}}{k_{1}} + [S]}\n$$\n现在，将此 $[ES]$ 的表达式代回反应速率 $v$ 的方程中：\n$$\nv = k_{2}[ES] \\approx \\frac{k_{2}[E]_{0}[S]}{\\frac{k_{-1} + k_{2}}{k_{1}} + [S]}\n$$\n这个方程就是 Michaelis-Menten 速率定律，通常写作 $v = \\frac{k_{\\text{cat}}[E]_{0}[S]}{K_{M} + [S]}$。通过将推导出的方程与标准形式直接比较，我们确定了催化常数 $k_{\\text{cat}}$ 和米氏常数 $K_{M}$ 的定义：\n$$\nk_{\\text{cat}} = k_{2}\n$$\n$$\nK_{M} = \\frac{k_{-1} + k_{2}}{k_{1}}\n$$\n推导完成。\n\n**第 2 部分：$K_{M}$、$k_{\\text{cat}}$ 和 $v_{0}$ 的计算**\n\n使用给定的参数值：\n-   $k_{1} = 1.2 \\times 10^{7}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}$\n-   $k_{-1} = 180\\ \\mathrm{s}^{-1}$\n-   $k_{2} = 20\\ \\mathrm{s}^{-1}$\n-   $[E]_{0} = 12\\ \\mathrm{nM} = 1.2 \\times 10^{-8}\\ \\mathrm{M}$\n-   $[S]_{0} = 50\\ \\mathrm{\\mu M} = 5.0 \\times 10^{-5}\\ \\mathrm{M}$\n\n我们计算 $k_{\\text{cat}}$：\n$$\nk_{\\text{cat}} = k_{2} = 20\\ \\mathrm{s}^{-1}\n$$\n接下来，我们计算 $K_{M}$：\n$$\nK_{M} = \\frac{k_{-1} + k_{2}}{k_{1}} = \\frac{180\\ \\mathrm{s}^{-1} + 20\\ \\mathrm{s}^{-1}}{1.2 \\times 10^{7}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}} = \\frac{200\\ \\mathrm{s}^{-1}}{1.2 \\times 10^{7}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}}\n$$\n$$\nK_{M} = \\frac{2}{1.2} \\times 10^{-5}\\ \\mathrm{M} = \\frac{5}{3} \\times 10^{-5}\\ \\mathrm{M} \\approx 1.67 \\times 10^{-5}\\ \\mathrm{M}\n$$\n初始速率 $v_{0}$ 是 $t=0$ 时的速率，此时 $[S] = [S]_{0}$。我们使用推导出的速率定律：\n$$\nv_{0} = \\frac{k_{\\text{cat}}[E]_{0}[S]_{0}}{K_{M} + [S]_{0}}\n$$\n代入数值：\n$$\nv_{0} = \\frac{(20\\ \\mathrm{s}^{-1})(1.2 \\times 10^{-8}\\ \\mathrm{M})(5.0 \\times 10^{-5}\\ \\mathrm{M})}{(\\frac{5}{3} \\times 10^{-5}\\ \\mathrm{M}) + (5.0 \\times 10^{-5}\\ \\mathrm{M})}\n$$\n分子是：\n$$\n(20)(1.2 \\times 10^{-8})(5.0 \\times 10^{-5})\\ \\mathrm{M}^2\\ \\mathrm{s}^{-1} = 120 \\times 10^{-13}\\ \\mathrm{M}^2\\ \\mathrm{s}^{-1} = 1.2 \\times 10^{-11}\\ \\mathrm{M}^2\\ \\mathrm{s}^{-1}\n$$\n分母是：\n$$\n\\left(\\frac{5}{3} + 5\\right) \\times 10^{-5}\\ \\mathrm{M} = \\left(\\frac{5}{3} + \\frac{15}{3}\\right) \\times 10^{-5}\\ \\mathrm{M} = \\frac{20}{3} \\times 10^{-5}\\ \\mathrm{M}\n$$\n因此，初始速率为：\n$$\nv_{0} = \\frac{1.2 \\times 10^{-11}\\ \\mathrm{M}^2\\ \\mathrm{s}^{-1}}{\\frac{20}{3} \\times 10^{-5}\\ \\mathrm{M}} = \\frac{1.2 \\times 3}{20} \\times 10^{-6}\\ \\mathrm{M}\\ \\mathrm{s}^{-1} = 0.18 \\times 10^{-6}\\ \\mathrm{M}\\ \\mathrm{s}^{-1} = 1.8 \\times 10^{-7}\\ \\mathrm{M}\\ \\mathrm{s}^{-1}\n$$\n\n**第 3 部分：底物消耗与有效性评估**\n\n初始速率近似假设在短时间间隔 $\\Delta t$ 内，速率 $v \\approx v_{0}$。速率通过 $v = -\\frac{d[S]}{dt}$ 与底物消耗相关。如果 $v$ 是常数，在 $\\Delta t$ 时间内消耗的底物量为 $|\\Delta[S]| \\approx v_{0} \\Delta t$。\n给定 $\\Delta t = 5\\ \\mathrm{s}$：\n$$\n|\\Delta[S]| \\approx (1.8 \\times 10^{-7}\\ \\mathrm{M}\\ \\mathrm{s}^{-1}) \\times (5\\ \\mathrm{s}) = 9.0 \\times 10^{-7}\\ \\mathrm{M}\n$$\n底物消耗的分数是消耗的底物量与初始底物浓度 $[S]_{0}$ 的比值：\n$$\n\\text{消耗分数} = \\frac{|\\Delta[S]|}{[S]_{0}} \\approx \\frac{v_{0} \\Delta t}{[S]_{0}}\n$$\n代入数值：\n$$\n\\text{消耗分数} \\approx \\frac{9.0 \\times 10^{-7}\\ \\mathrm{M}}{5.0 \\times 10^{-5}\\ \\mathrm{M}} = \\frac{9.0}{500} = \\frac{1.8}{100} = 0.018\n$$\n题目要求将此分数报告为四位有效数字。因此，该分数为 $0.01800$。\n为评估初始速率近似的有效性，我们将此分数与小于 $0.05$ 的准则进行比较。由于 $0.01800  0.05$，底物消耗约为 $1.8\\%$，这完全在可接受的限度内，表明初始速率假设在 $5\\ \\mathrm{s}$ 的时间间隔内是有效的。底物浓度的变化不足以导致其显著偏离初始速率。\n\n最终答案是底物消耗的无单位小数部分，四舍五入至四位有效数字。",
            "answer": "$$\\boxed{0.01800}$$"
        },
        {
            "introduction": "准稳态近似（Quasi-Steady-State Approximation, QSSA）是米氏动力学理论的基石，但它在何种情况下才真正有效？这项练习将超越简单的检验，带你进行严格的时间尺度分析，从而推导出QSSA有效性的形式化条件。通过一项动手编程任务，你将比较近似的QSSA解与完整系统的精确数值解，从而对该近似的适用边界获得深刻而定量的理解。",
            "id": "3306344",
            "problem": "考虑一个由质量作用定律控制的酶催化反应：一个酶 $E$ 与一个底物 $S$ 结合形成一个复合物 $ES$，然后释放产物 $P$ 并再生 $E$。基元反应方案为 $E + S \\xrightleftharpoons[k_{-1}]{k_{1}} ES \\xrightarrow{k_{2}} E + P$。总酶浓度是守恒的，因此 $[E](t) + [ES](t) = [E]_0$。米氏常数定义为 $K_m = \\frac{k_{-1} + k_{2}}{k_{1}}$。定义小参数 $\\epsilon = \\frac{[E]_0}{K_m + [S]_0}$。\n\n您的任务是：\n1. 从质量作用定律和总酶守恒出发，进行时间尺度分析，以推导准稳态近似（QSSA）有效的条件。用小参数 $\\epsilon$ 和 $k_{2}$ 相对于 $k_{-1}$ 的大小来表示这个条件，除了给定的定义外，不要引用任何预先指定的目标公式。您的推导必须证明所推导的条件如何捕捉了形成 $ES$ 的快速瞬态过程和产生 $P$ 的较慢底物消耗过程之间的时间尺度分离。\n2. 实现一个程序，对于每个指定的参数集，计算：\n   - 通过对完整质量作用系统进行数值积分来计算精确解，该系统针对 $( [S](t), [ES](t), [P](t) )$，并使用降维后的关系式 $[E](t) = [E]_0 - [ES](t)$。\n   - 通过对简化的底物-产物动力学进行数值积分来计算QSSA解，其中速率定律 $v(t)$ 仅依赖于 $[S](t)$ 和常数，并一致地使用酶守恒。\n   - 从任务1的推导中获得的时间尺度比率 $r$。\n   - 一个布尔有效性指示符，当使用数值阈值 $r  0.1$ 满足时间尺度分离条件时为 $true$，否则为 $false$。\n   - 一个定量误差，定义为精确产物轨迹与QSSA产物轨迹之间绝对差的最大值，并用结束时间的精确最终产物进行归一化：$\\max_{t \\in [0,T_{\\text{end}}]} \\frac{|[P]_{\\text{exact}}(t) - [P]_{\\text{QSSA}}(t)|}{\\max([P]_{\\text{exact}}(T_{\\text{end}}), \\delta)}$，其中正则化小常数 $\\delta = 10^{-12}$ 表示为一个纯数（无单位）。\n\n所有浓度必须以毫摩尔（mM）表示，时间以秒（s）表示。不涉及角度。误差是一个无量纲的浮点数；不要使用百分号。使用 $N = 1000$ 个等距采样点来评估轨迹并计算随时间变化的误差。对于数值积分，使用适合潜在刚性系统的方法。\n\n使用以下参数值的测试套件。每个测试用例是一个元组 $(k_1, k_{-1}, k_2, [E]_0, [S]_0, T_{\\text{end}})$，其中 $k_1$ 的单位是 $\\text{mM}^{-1}\\,\\text{s}^{-1}$，$k_{-1}$ 和 $k_2$ 的单位是 $\\text{s}^{-1}$，$[E]_0$ 和 $[S]_0$ 的单位是 $\\text{mM}$，$T_{\\text{end}}$ 的单位是 $\\text{s}$：\n- 测试用例 1：$(1000, 1, 1, 0.005, 1.0, 50)$。\n- 测试用例 2：$(1000, 0.5, 5, 0.05, 0.2, 5)$。\n- 测试用例 3：$(1000, 0.5, 50, 0.005, 0.01, 1)$。\n- 测试用例 4：$(1000, 0.1, 100, 0.2, 0.05, 0.05)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是一个包含三个元素的列表 $[ \\text{error}, r, \\text{valid} ]$。例如，输出格式必须与 $[[e_1,r_1,v_1],[e_2,r_2,v_2],\\ldots]$ 完全一样，其中每个 $e_i$ 和 $r_i$ 是一个浮点数，每个 $v_i$ 是一个布尔值。",
            "solution": "酶催化反应 $E + S \\xrightleftharpoons[k_{-1}]{k_{1}} ES \\xrightarrow{k_{2}} E + P$ 的动力学由一组源自质量作用定律的常微分方程（ODE）描述。设物种的浓度表示为 $[S](t)$、$[E](t)$、$[ES](t)$ 和 $[P](t)$。ODE 系统为：\n$$ \\frac{d[S]}{dt} = -k_1 [E](t) [S](t) + k_{-1} [ES](t) $$\n$$ \\frac{d[E]}{dt} = -k_1 [E](t) [S](t) + (k_{-1} + k_2) [ES](t) $$\n$$ \\frac{d[ES]}{dt} = k_1 [E](t) [S](t) - (k_{-1} + k_2) [ES](t) $$\n$$ \\frac{d[P]}{dt} = k_2 [ES](t) $$\n总酶浓度是守恒的：$[E](t) + [ES](t) = [E]_0$。利用这一点，我们可以消去 $[E](t) = [E]_0 - [ES](t)$ 并简化系统。底物 $[S]$ 和酶-底物复合物 $[ES]$ 的动力学由以下方程控制：\n$$ \\frac{d[S]}{dt} = -k_1 ([E]_0 - [ES](t)) [S](t) + k_{-1} [ES](t) $$\n$$ \\frac{d[ES]}{dt} = k_1 ([E]_0 - [ES](t)) [S](t) - (k_{-1} + k_2) [ES](t) $$\n在 $t=0$ 时的初始条件是 $[S](0) = [S]_0$、$[ES](0) = 0$、$[E](0) = [E]_0$ 和 $[P](0) = 0$。\n\n### 任务1：时间尺度分析和准稳态近似（QSSA）的有效性\n\n当中间复合物 $[ES]$ 的浓度在一个比底物浓度 $[S]$ 变化的时间尺度快得多的时间尺度上平衡到一个伪稳态值时，QSSA是有效的。这种时间尺度的分离使我们能够用一个代数方程来近似 $[ES]$ 的微分方程。\n\n让我们推导两个相关的时间尺度。\n\n**1. 复合物形成的快速时间尺度 ($\\tau_c$)**\n复合物 $[ES]$ 的动力学由以下ODE描述：\n$$ \\frac{d[ES]}{dt} = k_1 [E]_0 [S](t) - (k_1 [S](t) + k_{-1} + k_2) [ES](t) $$\n对于给定的（瞬时固定的）底物浓度 $[S]$，这是一个关于 $[ES]$ 的线性一阶ODE。解趋近于其稳态值 $[ES]_{qss} = \\frac{k_1 [E]_0 [S]}{k_1 [S] + k_{-1} + k_2}$，其特征弛豫时间我们确定为快速时间尺度 $\\tau_c$：\n$$ \\tau_c([S]) = \\frac{1}{k_1 [S](t) + k_{-1} + k_2} $$\n使用米氏常数的定义，$K_m = \\frac{k_{-1} + k_2}{k_1}$，我们可以将其重写为：\n$$ \\tau_c([S]) = \\frac{1}{k_1([S](t) + K_m)} $$\n\n**2. 底物消耗的慢速时间尺度 ($\\tau_s$)**\nQSSA假设 $d[ES]/dt \\approx 0$，这意味着 $[ES](t)$ 总是接近其准稳态值：\n$$ [ES]_{qss}(t) = \\frac{[E]_0 [S](t)}{[S](t) + K_m} $$\n在此近似下，产物形成速率或速度 $v(t)$ 为 $v(t) = k_2 [ES]_{qss}(t)$，底物消耗速率为 $\\frac{d[S]}{dt} = -v(t)$。这得到了著名的米氏-门顿方程：\n$$ \\frac{d[S]}{dt} = -\\frac{k_2 [E]_0 [S](t)}{[S](t) + K_m} $$\n底物浓度变化的特征时间可以估计为 $\\tau_s \\approx |[S] / \\frac{d[S]}{dt}|$。\n$$ \\tau_s([S]) = \\left| \\frac{[S](t)}{-\\frac{k_2 [E]_0 [S](t)}{[S](t) + K_m}} \\right| = \\frac{[S](t) + K_m}{k_2 [E]_0} $$\n\n**3. 有效性条件**\n如果 $[ES]$ 的快速动力学远快于 $[S]$ 的慢速动力学，即 $\\tau_c \\ll \\tau_s$，则QSSA有效。我们定义一个无量纲的时间尺度比率 $r$ 来量化这个条件：\n$$ r = \\frac{\\tau_c}{\\tau_s} = \\frac{1 / (k_1([S] + K_m))}{( [S] + K_m) / (k_2 [E]_0)} = \\frac{k_2 [E]_0}{k_1([S] + K_m)^2} $$\nQSSA的有效性取决于底物 $[S]$ 的浓度，而这个条件通常在反应开始时最为苛刻。因此，我们在 $t=0$ 时评估 $r$，此时 $[S](0) = [S]_0$：\n$$ r = \\frac{k_2 [E]_0}{k_1([S]_0 + K_m)^2} $$\nQSSA有效的条件是 $r \\ll 1$。该推导通过比较酶-底物复合物的弛豫时间与底物耗尽的特征时间，明确地证明了时间尺度的分离。$r$ 的微小确保了 $[ES](t)$ 能够快速调整并追踪其准稳态值 $[ES]_{qss}$，该值随着 $[S](t)$ 的消耗而缓慢变化。\n\n问题要求使用 $\\epsilon = \\frac{[E]_0}{K_m + [S]_0}$ 来表示此条件。我们可以将 $r$ 重写为：\n$$ r = \\left(\\frac{[E]_0}{K_m + [S]_0}\\right) \\frac{k_2}{k_1(K_m + [S]_0)} = \\epsilon \\frac{k_2}{k_1(K_m + [S]_0)} $$\n代入 $K_m = (k_{-1} + k_2)/k_1$：\n$$ r = \\epsilon \\frac{k_2}{k_1(\\frac{k_{-1}+k_2}{k_1} + [S]_0)} = \\epsilon \\frac{k_2}{k_{-1}+k_2+k_1[S]_0} $$\n该表达式涉及 $\\epsilon$ 和其他参数，隐式地包括了 $k_2$ 与 $k_{-1}$ 的比率。为了计算，我们将使用公式 $r = \\frac{k_2 [E]_0}{k_1([S]_0 + K_m)^2}$。\n\n### 任务2：算法实现\n\n**精确解：** 我们对状态向量 $\\vec{y}(t) = ([S](t), [ES](t))$ 的两个耦合ODE的完整系统进行数值积分：\n$$ \\frac{d[S]}{dt} = -k_1 ([E]_0 - [ES])[S] + k_{-1}[ES] $$\n$$ \\frac{d[ES]}{dt} = k_1 ([E]_0 - [ES])[S] - (k_{-1} + k_2)[ES] $$\n初始条件为 $\\vec{y}(0) = ([S]_0, 0)$。由于酶动力学系统可能是刚性的，我们使用合适的数值积分器，例如 `scipy.integrate.solve_ivp` 中的 `Radau` 或 `BDF`。然后从质量守恒中恢复产物浓度：$[P]_{\\text{exact}}(t) = [S]_0 - [S]_{\\text{exact}}(t) - [ES]_{\\text{exact}}(t)$。\n\n**QSSA解：** 我们对 $[S](t)$ 的降维一维米氏-门顿ODE进行数值积分：\n$$ \\frac{d[S]}{dt} = -\\frac{k_2 [E]_0 [S]}{K_m + [S]} $$\n初始条件为 $[S](0) = [S]_0$。通过质量平衡恢复产物浓度，$[P]_{QSSA}(t) = [S]_0 - [S]_{QSSA}(t)$，因为QSSA假设与 $[S](t)$ 相比，$[ES](t)$ 可以忽略不计。\n\n**计算：**\n对于每个测试用例，我们执行以下步骤：\n1.  计算 $K_m = (k_{-1} + k_2) / k_1$。\n2.  在区间 $[0, T_{\\text{end}}]$ 上，在 $N=1000$ 个点上数值求解精确系统和QSSA系统。\n3.  计算轨迹 $[P]_{\\text{exact}}(t)$ 和 $[P]_{QSSA}(t)$。\n4.  计算时间尺度比率 $r = \\frac{k_2 [E]_0}{k_1([S]_0 + K_m)^2}$。\n5.  设置有效性指示符：如果 $r  0.1$，则 `valid` 为 `true`，否则为 `false`。\n6.  计算归一化误差：$Error = \\max_{t \\in [0,T_{\\text{end}}]} \\frac{|[P]_{\\text{exact}}(t) - [P]_{QSSA}(t)|}{\\max([P]_{\\text{exact}}(T_{\\text{end}}), \\delta)}$，其中 $\\delta = 10^{-12}$。\n7.  收集每个测试用例的结果 $[\\text{Error}, r, \\text{valid}]$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport json\n\ndef solve():\n    \"\"\"\n    Solves the enzyme kinetics problem for a suite of test cases.\n    For each case, it computes the exact and QSSA solutions, the timescale ratio 'r',\n    the validity of the QSSA, and the normalized error between the two solutions.\n    \"\"\"\n    \n    # Test cases: (k1, k_1, k2, E0, S0, T_end)\n    test_cases = [\n        (1000.0, 1.0, 1.0, 0.005, 1.0, 50.0),\n        (1000.0, 0.5, 5.0, 0.05, 0.2, 5.0),\n        (1000.0, 0.5, 50.0, 0.005, 0.01, 1.0),\n        (1000.0, 0.1, 100.0, 0.2, 0.05, 0.05),\n    ]\n\n    # Numerical parameters\n    N_POINTS = 1000\n    DELTA = 1e-12\n\n    results = []\n\n    for case in test_cases:\n        k1, k_neg1, k2, E0, S0, T_end = case\n\n        # --- 1. Compute constants ---\n        Km = (k_neg1 + k2) / k1\n\n        # --- 2. Solve the exact (full) system ---\n        def full_system(t, y, k1, k_neg1, k2, E0):\n            S, ES = y\n            E = E0 - ES\n            dS_dt = -k1 * E * S + k_neg1 * ES\n            dES_dt = k1 * E * S - (k_neg1 + k2) * ES\n            return [dS_dt, dES_dt]\n\n        t_span = [0, T_end]\n        t_eval = np.linspace(t_span[0], t_span[1], N_POINTS)\n        y0_full = [S0, 0.0]\n\n        sol_exact = solve_ivp(\n            full_system,\n            t_span,\n            y0_full,\n            method='Radau',\n            t_eval=t_eval,\n            args=(k1, k_neg1, k2, E0),\n            rtol=1e-8,\n            atol=1e-11\n        )\n        \n        S_exact = sol_exact.y[0, :]\n        ES_exact = sol_exact.y[1, :]\n        # P_exact from mass balance: S0 + E0 = S + E + ES + P\n        # and E0 = E + ES, so S0 = S + ES + P\n        P_exact = S0 - S_exact - ES_exact\n        # Ensure P_exact does not become negative due to numerical noise\n        P_exact = np.maximum(P_exact, 0)\n        \n        # --- 3. Solve the QSSA (reduced) system ---\n        Vmax = k2 * E0\n        def qssa_system(t, y, Vmax, Km):\n            S = y[0]\n            dS_dt = -Vmax * S / (Km + S)\n            return [dS_dt]\n\n        y0_qssa = [S0]\n        \n        sol_qssa = solve_ivp(\n            qssa_system,\n            t_span,\n            y0_qssa,\n            method='Radau',\n            t_eval=t_eval,\n            args=(Vmax, Km),\n            rtol=1e-8,\n            atol=1e-11\n        )\n\n        S_qssa = sol_qssa.y[0,:]\n        # P_qssa from mass balance: S0 = S + P (since ES is assumed negligible)\n        P_qssa = S0 - S_qssa\n\n        # --- 4. Calculate timescale ratio r and validity ---\n        r = (k2 * E0) / (k1 * (S0 + Km)**2)\n        valid = r  0.1\n\n        # --- 5. Calculate quantitative error ---\n        abs_diff_P = np.abs(P_exact - P_qssa)\n        max_abs_diff = np.max(abs_diff_P)\n        \n        # Denominator for normalization\n        normalization_factor = max(P_exact[-1], DELTA)\n        \n        error = max_abs_diff / normalization_factor\n\n        results.append([error, r, valid])\n\n    # --- 6. Format and print the final output ---\n    # Use json.dumps to handle boolean and float formatting, then adjust for exact format\n    # The problem requires 'true'/'false' instead of 'True'/'False'\n    formatted_results = []\n    for res in results:\n        err_str = f\"{res[0]:.6g}\"  # Scientific notation for small numbers, float for others\n        r_str = f\"{res[1]:.6g}\"\n        valid_str = str(res[2]).lower()\n        formatted_results.append(f\"[{err_str},{r_str},{valid_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这最后一项练习是一次综合性的体验，它将动力学理论与现代计算和统计方法相结合，以应对一个真实的建模挑战。你将利用费雪信息矩阵（Fisher Information Matrix）来设计最优实验，从而探索理论模型如何指导实际的实验操作。此外，你还将学习如何将相互竞争的模型与含噪声的合成数据进行拟合，并使用严格的统计标准——赤池信息量准则（Akaike Information Criterion, AIC）——来判断哪个模型（是简化的米氏模型还是完整的机理模型）能为系统提供更合理的描述。",
            "id": "3901792",
            "problem": "一种单底物、单酶反应由酶-底物复合物形成和转化的基元机理描述，遵循质量作用定律：$$E + S \\xrightleftharpoons[k_{-1}]{k_1} ES \\xrightarrow{k_2} E + P,$$ 其中 $E$ 表示游离酶，$S$ 表示底物，$ES$ 表示酶-底物复合物，$P$ 表示产物。速率常数 $k_1$ 的单位为 $\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}$，$k_{-1}$ 的单位为 $\\mathrm{s}^{-1}$，$k_2$ 的单位为 $\\mathrm{s}^{-1}$。设初始条件为 $E(0)=E_0$（单位 $\\mu\\mathrm{M}$），$S(0)=S_0$（单位 $\\mu\\mathrm{M}$），$ES(0)=0$（单位 $\\mu\\mathrm{M}$），以及 $P(0)=0$（单位 $\\mu\\mathrm{M}$）。在质量作用定律下，其时间演化由以下常微分方程组控制：\n$$\\frac{d[E]}{dt} = -k_1[E][S] + (k_{-1}+k_2)[ES],\\quad \\frac{d[S]}{dt} = -k_1[E][S] + k_{-1}[ES],\\quad \\frac{d[ES]}{dt} = k_1[E][S] - (k_{-1}+k_2)[ES],\\quad \\frac{d[P]}{dt} = k_2[ES],$$\n并服从守恒定律 $E(t)+ES(t)=E_0$（对所有 $t\\ge 0$）。初始速率实验通过改变底物浓度来测量稳态初始条件下的 $\\frac{dP}{dt}$，并假设存在方差恒定的加性高斯噪声。反应进程曲线实验在指定时间点测量 $P(t)$，并同样假设存在方差已知的加性高斯噪声。\n\n您的任务是结合实验设计和模型验证，针对 Briggs 和 Haldane 的准稳态理论以及简化的 Michaelis-Menten 描述在生物医学系统建模中的应用。您必须从质量作用定律和守恒关系出发，在一个有充分理由的近似下，推导出一个简化的双参数初始速率模型，并为其构建费雪信息矩阵以用于实验设计。您还必须将简化模型和完整的机理模型与带有噪声的反应进程曲线数据进行拟合，以使用严格定义的信息准则评估模型的充分性。\n\n具体要求如下：\n\n1.  仅使用第一性原理（质量作用定律和代数守恒），在对中间复合物进行准稳态近似的条件下，推导出一个用两个集总参数表示的初始速率表达式。定义这两个参数，并解释它们是如何由速率常数和初始酶浓度 $E_0$ 产生的。不得将任何公式作为假设引入；必须证明近似和推导的合理性。\n\n2.  考虑一个初始速率实验设计，您可以从一个固定的候选集合中选择 $4$ 个底物浓度 $S$，每个选定的浓度测量一次。假设初始速率测量值含有独立同分布的高斯噪声，其方差为 $\\sigma_v^2$（单位 $(\\mu\\mathrm{M}/\\mathrm{s})^2$），并且为了构建费雪信息矩阵，任务1中推导的简化初始速率模型是局部可线性化的。为这两个参数构建费雪信息矩阵 $\\mathcal{I}(\\theta)$，并选择使 $\\det\\mathcal{I}(\\theta)$ 最大化（“D-最优性”）的 $4$ 点设计。使用测试案例的真实机理参数所隐含的名义参数值来评估 $\\mathcal{I}(\\theta)$。\n\n3.  通过数值积分完整的质量作用定律机理系统，使用给定的参数和初始条件，为每个测试案例生成合成的反应进程曲线产物数据 $P(t)$，并添加具有指定方差 $\\sigma_P^2$（单位 $\\mu\\mathrm{M}^2$）的独立同分布高斯噪声。通过非线性最小二乘法将两个竞争模型与这些含噪数据进行拟合：(a) 由任务1推导所隐含的简化双参数反应进程曲线模型，以及 (b) 具有未知 $k_1$、$k_{-1}$ 和 $k_2$ 的完整机理模型。对每次拟合，计算赤池信息准则 (AIC)，其定义为 $$\\mathrm{AIC}=n\\ln\\left(\\frac{\\mathrm{RSS}}{n}\\right)+2p,$$ 其中 $n$ 是时间点数量，$\\mathrm{RSS}$ 是残差平方和，$p$ 是拟合参数的数量。选择具有较低 AIC 的模型。\n\n4.  实现约束：所有数值积分必须以秒为单位，浓度以 $\\mu\\mathrm{M}$ 为单位，速率以 $\\mu\\mathrm{M}/\\mathrm{s}$ 为单位。为保证可复现性，高斯噪声必须使用固定的种子生成。非线性最小二乘法必须强制参数为正值。您推导的简化模型必须是用于初始速率设计和反应进程曲线拟合的任何公式的唯一来源。\n\n测试套件和参数：\n- 案例A（“理想的”准稳态情况）：$k_1=1.0\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}$，$k_{-1}=10.0\\,\\mathrm{s}^{-1}$，$k_2=2.0\\,\\mathrm{s}^{-1}$，$E_0=0.1\\,\\mu\\mathrm{M}$，$S_0=100.0\\,\\mu\\mathrm{M}$。初始速率候选集（单位均为 $\\mu\\mathrm{M}$）：$\\{2,5,10,20,50,100,200,500,1000,2000\\}$。初始速率噪声方差 $\\sigma_v^2=(0.02)^2$。反应进程曲线时间点 $t\\in\\{0.1,0.2,0.5,1.0,2.0,5.0\\}$ 秒。反应进程曲线噪声方差 $\\sigma_P^2=(0.5)^2$。\n- 案例B（高酶浓度导致的准稳态失效）：$k_1=1.0\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}$，$k_{-1}=1.0\\,\\mathrm{s}^{-1}$，$k_2=50.0\\,\\mathrm{s}^{-1}$，$E_0=50.0\\,\\mu\\mathrm{M}$，$S_0=100.0\\,\\mu\\mathrm{M}$。候选集与案例A相同。初始速率噪声方差 $\\sigma_v^2=(0.5)^2$。反应进程曲线时间点 $t\\in\\{0.01,0.02,0.05,0.1,0.2,0.5\\}$ 秒。反应进程曲线噪声方差 $\\sigma_P^2=(2.0)^2$。\n- 案例C（前稳态和低底物浓度）：$k_1=0.1\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}$，$k_{-1}=0.01\\,\\mathrm{s}^{-1}$，$k_2=5.0\\,\\mathrm{s}^{-1}$，$E_0=1.0\\,\\mu\\mathrm{M}$，$S_0=5.0\\,\\mu\\mathrm{M}$。候选集与案例A相同。初始速率噪声方差 $\\sigma_v^2=(0.1)^2$。反应进程曲线时间点 $t\\in\\{0.02,0.05,0.1,0.2,0.5,1.0\\}$ 秒。反应进程曲线噪声方差 $\\sigma_P^2=(0.2)^2$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含所有结果，聚合成一个用方括号括起来的逗号分隔列表。对于每个测试案例，输出四个选定的底物浓度（单位 $\\mu\\mathrm{M}$，浮点数），后跟一个整数模型选择指示符，其中 $0$ 表示简化双参数模型更优， $1$ 表示完整机理模型更优。因此，对于三个测试案例，输出应包含 $15$ 个逗号分隔的条目，顺序为案例A、案例B、案例C（例如，“[S1,S2,S3,S4,mA,S1,S2,S3,S4,mB,S1,S2,S3,S4,mC]”）。",
            "solution": "解决方案分为三个部分，对应于要求的主要任务。\n\n### 任务1：简化初始速率模型的推导\n\n起点是单底物酶反应的完整机理模型，该模型受质量作用定律支配。基元步骤如下：\n$$E + S \\xrightleftharpoons[k_{-1}]{k_1} ES \\xrightarrow{k_2} E + P$$\n化学物种浓度的时间演化由一个常微分方程（ODE）系统描述：\n$$\n\\begin{align*}\n\\frac{d[E]}{dt} = -k_1[E][S] + k_{-1}[ES] + k_2[ES] \\\\\n\\frac{d[S]}{dt} = -k_1[E][S] + k_{-1}[ES] \\\\\n\\frac{d[ES]}{dt} = k_1[E][S] - (k_{-1}+k_2)[ES] \\\\\n\\frac{d[P]}{dt} = k_2[ES]\n\\end{align*}\n$$\n这里，$[E]$、$[S]$、$[ES]$ 和 $[P]$ 分别代表游离酶、底物、酶-底物复合物和产物的浓度。总酶浓度是守恒的：\n$$[E](t) + [ES](t) = E_0$$\n其中 $E_0$ 是初始总酶浓度。这条守恒定律使我们能够从系统中消去 $[E]$：$[E] = E_0 - [ES]$。\n\n现在应用 Briggs-Haldane 准稳态近似（QSSA）。该近似假设在一个非常短暂的初始瞬态阶段之后，中间体酶-底物复合物的浓度 $[ES]$ 变得几乎恒定，即其变化率约等于零：\n$$\\frac{d[ES]}{dt} \\approx 0$$\n当酶的浓度远小于底物浓度与米氏常数之和（$E_0 \\ll [S_0] + K_M$）时，这种近似在物理上是合理的，这确保了复合物的形成和分解迅速达到平衡。\n\n将 $[ES]$ 的ODE设为零，得到一个代数方程：\n$$k_1[E][S] - (k_{-1}+k_2)[ES] \\approx 0$$\n将守恒定律 $[E] = E_0 - [ES]$ 代入此方程，得到：\n$$k_1(E_0 - [ES])[S] - (k_{-1}+k_2)[ES] \\approx 0$$\n我们现在可以求解复合物的准稳态浓度 $[ES]_{qssa}$：\n$$k_1 E_0 [S] - k_1 [ES][S] \\approx (k_{-1}+k_2)[ES]$$\n$$k_1 E_0 [S] \\approx [ES](k_1[S] + k_{-1} + k_2)$$\n$$[ES]_{qssa} \\approx \\frac{k_1 E_0 [S]}{k_1[S] + k_{-1} + k_2}$$\n为了以更标准的形式表示，我们将分子和分母同时除以 $k_1$：\n$$[ES]_{qssa} \\approx \\frac{E_0 [S]}{[S] + \\frac{k_{-1}+k_2}{k_1}}$$\n产物形成的初始速率 $v_0$ 由 $v_0 = \\left(\\frac{d[P]}{dt}\\right)_{t \\approx 0} = k_2[ES]_{qssa}$ 给出。对于初始速率实验，$[S]$ 取为初始底物浓度，我们简记为 $S$。代入 $[ES]_{qssa}$ 的表达式：\n$$v_0(S) = \\frac{k_2 E_0 S}{S + \\frac{k_{-1}+k_2}{k_1}}$$\n这就是著名的 Michaelis-Menten 方程。问题要求用两个集总参数来表示它。这些参数定义如下：\n\n1.  **最大速率 ($V_{\\max}$)**：这是反应的理论最大速率，在酶被底物完全饱和时（$S \\to \\infty$）达到。在此极限下，$[ES] \\to E_0$，速率变为 $k_2 E_0$。\n    $$V_{\\max} = k_2 E_0$$\n    其单位是浓度/时间（例如 $\\mu\\mathrm{M}/\\mathrm{s}$）。\n\n2.  **米氏常数 ($K_M$)**: 这是反应速率为 $V_{\\max}$ 一半时的底物浓度。它代表在 Briggs-Haldane 假设下，酶对其底物的亲和力。\n    $$K_M = \\frac{k_{-1}+k_2}{k_1}$$\n    其单位是浓度（例如 $\\mu\\mathrm{M}$）。\n\n使用这两个集总参数，简化的初始速率模型为：\n$$v(S; V_{\\max}, K_M) = \\frac{V_{\\max} S}{K_M + S}$$\n\n### 任务2：D-最优实验设计\n\n对于一个在 $N$ 个不同底物浓度 $\\{S_1, \\dots, S_N\\}$ 下测量速率 $v$ 的初始速率实验，其中测量值受到方差为 $\\sigma_v^2$ 的加性独立同分布高斯噪声的干扰，参数 $\\theta = [V_{\\max}, K_M]^T$ 的费雪信息矩阵（FIM）由以下公式给出：\n$$\\mathcal{I}(\\theta) = \\frac{1}{\\sigma_v^2} \\sum_{i=1}^{N} \\nabla_\\theta v(S_i; \\theta) [\\nabla_\\theta v(S_i; \\theta)]^T$$\n其中 $\\nabla_\\theta v$ 是速率方程关于参数的梯度。梯度的分量是偏导数：\n$$\\frac{\\partial v}{\\partial V_{\\max}} = \\frac{S}{K_M + S}$$\n$$\\frac{\\partial v}{\\partial K_M} = V_{\\max}S \\cdot \\frac{-1}{(K_M + S)^2} = -\\frac{V_{\\max}S}{(K_M + S)^2}$$\n在底物浓度 $S_i$ 处进行单次测量的 FIM 是一个 $2 \\times 2$ 矩阵：\n$$\\mathcal{I}_i(\\theta) = \\frac{1}{\\sigma_v^2} \\begin{pmatrix} \\left(\\frac{S_i}{K_M+S_i}\\right)^2  -\\frac{V_{\\max}S_i^2}{(K_M+S_i)^3} \\\\ -\\frac{V_{\\max}S_i^2}{(K_M+S_i)^3}  \\left(\\frac{V_{\\max}S_i}{(K_M+S_i)^2}\\right)^2 \\end{pmatrix}$$\n总 FIM 是对 $N=4$ 个选定设计点的 FIM 之和。D-最优性要求我们从候选池中选择一组 $4$ 个不同的浓度，以最大化 $\\det\\mathcal{I}(\\theta)$。由于对于一个 $k \\times k$ 矩阵 $A$ 和标量 $c$，有 $\\det(c A) = c^k \\det(A)$，因此常数因子 $1/\\sigma_v^2$ 不影响哪个设计是最优的。因此，我们寻求最大化不含此因子的矩阵和的行列式。这通过遍历候选集中的所有 $\\binom{10}{4}=210$ 种 $4$ 个底物浓度的组合来实现，使用每个测试案例的真实机理参数导出的名义参数值计算每个组合的总 FIM，并选择产生最大行列式的组合。\n\n### 任务3：反应进程曲线拟合与模型选择\n\n此任务涉及两个主要步骤：数据生成和模型比较。\n\n**数据生成**：通过对完整的三个 ODE（针对 $[S]$、$[ES]$ 和 $[P]$）机理系统进行数值积分，使用每个测试案例的真实参数，来生成产物浓度 $[P](t)$ 的合成反应进程曲线数据。初始条件为 $[S](0)=S_0$、$[ES](0)=0$、$[P](0)=0$。在指定的时间点获得真值 $P_{true}(t_i)$ 后，添加独立同分布的高斯噪声：$P_{noisy}(t_i) = P_{true}(t_i) + \\epsilon_i$，其中 $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma_P^2)$。\n\n**模型拟合**：使用非线性最小二乘法将两个模型与这些含噪数据进行拟合，并约束所有参数必须为正。\n1.  **简化模型 (a)**：该模型假设 QSSA 在整个时间进程中都成立。系统由一个关于 $[P](t)$ 的单一 ODE 描述，该 ODE 通过使用质量平衡关系 $[S](t) = S_0 - [P](t)$ 推导得出：\n    $$\\frac{d[P]}{dt} = \\frac{V_{\\max} (S_0 - [P](t))}{K_M + S_0 - [P](t)}, \\quad [P](0)=0$$\n    在拟合过程中，对该 ODE 进行数值积分，以找到两个参数 $p_a=2$（即 $V_{\\max}$ 和 $K_M$）的最优值。\n\n2.  **完整机理模型 (b)**：该模型使用原始的三个耦合 ODE 系统。拟合过程涉及对该系统进行数值积分，以找到三个参数 $p_b=3$（即 $k_1$、 $k_{-1}$ 和 $k_2$）的最优值。\n\n**模型选择**：拟合两个模型后，为每次拟合计算赤池信息准则（AIC）：\n$$\\mathrm{AIC} = n \\ln\\left(\\frac{\\mathrm{RSS}}{n}\\right) + 2p$$\n其中 $n$ 是数据点数量，$p$ 是拟合参数的数量，$\\mathrm{RSS}$ 是来自最小二乘拟合的残差平方和。具有较低 AIC 值的模型被认为在拟合优度（低 RSS）和模型简约性（低 $p$）之间取得了更好的平衡，因此被选为首选模型。简化模型的模型选择指示符被指定为 $0$，完整模型的为 $1$。对三个测试案例重复此过程，这些案例旨在探测 QSSA 有效性的不同区间。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import curve_fit\nfrom itertools import combinations\nimport math\n\n# Use a fixed seed for the random number generator for reproducibility as required.\nRNG = np.random.default_rng(seed=42)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It orchestrates the D-optimal design and model fitting/selection tasks.\n    \"\"\"\n    test_cases = [\n        {\n            'name': 'A',\n            'k1': 1.0, 'k_1': 10.0, 'k2': 2.0, 'E0': 0.1, 'S0': 100.0,\n            'S_candidates': np.array([2., 5., 10., 20., 50., 100., 200., 500., 1000., 2000.]),\n            'sigma_v_sq': 0.02**2,\n            't_points': np.array([0.1, 0.2, 0.5, 1.0, 2.0, 5.0]),\n            'sigma_P_sq': 0.5**2,\n        },\n        {\n            'name': 'B',\n            'k1': 1.0, 'k_1': 1.0, 'k2': 50.0, 'E0': 50.0, 'S0': 100.0,\n            'S_candidates': np.array([2., 5., 10., 20., 50., 100., 200., 500., 1000., 2000.]),\n            'sigma_v_sq': 0.5**2,\n            't_points': np.array([0.01, 0.02, 0.05, 0.1, 0.2, 0.5]),\n            'sigma_P_sq': 2.0**2,\n        },\n        {\n            'name': 'C',\n            'k1': 0.1, 'k_1': 0.01, 'k2': 5.0, 'E0': 1.0, 'S0': 5.0,\n            'S_candidates': np.array([2., 5., 10., 20., 50., 100., 200., 500., 1000., 2000.]),\n            'sigma_v_sq': 0.1**2,\n            't_points': np.array([0.02, 0.05, 0.1, 0.2, 0.5, 1.0]),\n            'sigma_P_sq': 0.2**2,\n        }\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        # --- Task 2: D-Optimal Design ---\n        Vmax_nom = case['k2'] * case['E0']\n        Km_nom = (case['k_1'] + case['k2']) / case['k1']\n\n        best_design = None\n        max_det = -1.0\n        \n        # Iterate through all combinations of 4 substrate concentrations\n        for s_design in combinations(case['S_candidates'], 4):\n            fim = np.zeros((2, 2))\n            s_design_np = np.array(s_design)\n            \n            # Calculate FIM for the current design\n            df_dV = s_design_np / (Km_nom + s_design_np)\n            df_dK = -Vmax_nom * s_design_np / (Km_nom + s_design_np)**2\n            \n            fim[0, 0] = np.sum(df_dV**2)\n            fim[1, 1] = np.sum(df_dK**2)\n            fim[0, 1] = fim[1, 0] = np.sum(df_dV * df_dK)\n            \n            det = np.linalg.det(fim)\n            if det > max_det:\n                max_det = det\n                best_design = sorted(list(s_design))\n\n        final_results.extend(best_design)\n\n        # --- Task 3: Progress-Curve Fitting and Model Selection ---\n        \n        # 1. Generate synthetic data\n        def full_ode_system(t, y, k1, k_1, k2, E0):\n            S, ES, P = y\n            E = E0 - ES\n            dS_dt = -k1 * E * S + k_1 * ES\n            dES_dt = k1 * E * S - (k_1 + k2) * ES\n            dP_dt = k2 * ES\n            return [dS_dt, dES_dt, dP_dt]\n\n        y0 = [case['S0'], 0, 0]\n        t_span = [0, max(case['t_points'])]\n        \n        sol_true = solve_ivp(\n            full_ode_system, t_span, y0,\n            args=(case['k1'], case['k_1'], case['k2'], case['E0']),\n            dense_output=True, method='Radau'\n        )\n        p_true = sol_true.sol(case['t_points'])[2]\n        noise = RNG.normal(0, np.sqrt(case['sigma_P_sq']), len(case['t_points']))\n        p_noisy = p_true + noise\n        p_noisy[p_noisy  0] = 0 # Product concentration cannot be negative.\n\n        # 2. Fit Reduced Model\n        def reduced_model_curve(t_points, Vmax, Km, S0):\n            def ode(t, P):\n                denominator = Km + S0 - P\n                if denominator = 1e-9: return 0.0\n                return Vmax * (S0 - P) / denominator\n            \n            sol = solve_ivp(ode, [0, max(t_points)], [0], dense_output=True, method='Radau')\n            return sol.sol(t_points)[0]\n\n        try:\n            popt_red, _ = curve_fit(\n                lambda t, Vmax, Km: reduced_model_curve(t, Vmax, Km, case['S0']),\n                case['t_points'], p_noisy,\n                p0=[Vmax_nom, Km_nom], bounds=(0, np.inf)\n            )\n            p_fit_red = reduced_model_curve(case['t_points'], *popt_red, case['S0'])\n            rss_red = np.sum((p_noisy - p_fit_red)**2)\n            n = len(case['t_points'])\n            p = 2\n            # Handle RSS being close to zero\n            if rss_red  1e-20: rss_red = 1e-20\n            aic_red = n * math.log(rss_red / n) + 2 * p\n        except (RuntimeError, ValueError):\n            aic_red = np.inf # Failed fit\n\n        # 3. Fit Full Model\n        def full_model_curve(t_points, k1, k_1, k2, E0, S0):\n            y0_fit = [S0, 0, 0]\n            sol = solve_ivp(\n                lambda t, y: full_ode_system(t, y, k1, k_1, k2, E0),\n                [0, max(t_points)], y0_fit, dense_output=True, method='Radau'\n            )\n            return sol.sol(t_points)[2]\n\n        try:\n            popt_full, _ = curve_fit(\n                lambda t, k1, k_1, k2: full_model_curve(t, k1, k_1, k2, case['E0'], case['S0']),\n                case['t_points'], p_noisy,\n                p0=[case['k1'], case['k_1'], case['k2']], bounds=(0, np.inf)\n            )\n            p_fit_full = full_model_curve(case['t_points'], *popt_full, case['E0'], case['S0'])\n            rss_full = np.sum((p_noisy - p_fit_full)**2)\n            n = len(case['t_points'])\n            p = 3\n            if rss_full  1e-20: rss_full = 1e-20\n            aic_full = n * math.log(rss_full / n) + 2 * p\n        except (RuntimeError, ValueError):\n            aic_full = np.inf # Failed fit\n\n        # 4. Compare AICs and select model\n        model_choice = 1 if aic_full  aic_red else 0\n        final_results.append(model_choice)\n        \n    print(f\"[{','.join(map(str, final_results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}