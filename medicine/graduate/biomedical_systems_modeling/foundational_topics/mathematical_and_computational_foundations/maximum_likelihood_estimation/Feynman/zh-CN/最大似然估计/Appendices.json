{
    "hands_on_practices": [
        {
            "introduction": "这第一个练习通过解决最大似然估计最基本的应用之一，为整个方法奠定基础。我们将推导正态分布的均值（$\\mu$）和方差（$\\sigma^2$）的估计量，这两个参数在模拟无数生物现象中都至关重要。通过这个练习 ，你将巩固最大似然估计（MLE）的核心步骤：构建似然函数、进行对数转换，以及利用微积分找到使观测数据出现概率最大化的参数值。",
            "id": "1933634",
            "problem": "一位材料科学家正在研究一种新开发的热电发电机性能。单个发电机模块的连续输出电压被建模为一个服从正态分布的随机变量。平均电压 $\\mu$ 代表了模块在特定热条件下的理想性能，而方差 $\\sigma^2$ 则量化了测量噪声和制造不一致性。为了对生产批次进行统计表征，随机抽取了 $n$ 个模块的样本，并测量了它们的输出电压，得到数值 $X_1, X_2, \\dots, X_n$。假设这些测量值是从一个均值 $\\mu$ 未知、正方差 $\\sigma^2$ 未知的正态分布中抽取的独立同分布样本。\n\n您的任务是使用最大似然法来求出 $\\mu$ 和 $\\sigma^2$ 的估计量。推导最大似然估计量（MLEs）的表达式，分别记为 $\\hat{\\mu}$ 和 $\\hat{\\sigma}^2$。两个估计量的最终表达式必须用样本值 $X_1, X_2, \\dots, X_n$ 和样本量 $n$ 来表示。",
            "solution": "设 $X_{1},\\dots,X_{n}$ 独立同分布于 $N(\\mu,\\sigma^{2})$，其中 $\\sigma^{2}0$。关于 $(\\mu,\\sigma^{2})$ 的联合似然函数为\n$$\nL(\\mu,\\sigma^{2};x_{1},\\dots,x_{n})=\\prod_{i=1}^{n}\\frac{1}{\\sqrt{2\\pi\\sigma^{2}}}\\,\\exp\\!\\left(-\\frac{(x_{i}-\\mu)^{2}}{2\\sigma^{2}}\\right).\n$$\n对数似然函数为\n$$\n\\ell(\\mu,\\sigma^{2})=\\ln L(\\mu,\\sigma^{2})=-\\frac{n}{2}\\ln(2\\pi)-\\frac{n}{2}\\ln(\\sigma^{2})-\\frac{1}{2\\sigma^{2}}\\sum_{i=1}^{n}(x_{i}-\\mu)^{2}.\n$$\n为了求出 $\\mu$ 的最大似然估计量，将 $\\ell$ 对 $\\mu$ 求导并令其为零：\n$$\n\\frac{\\partial \\ell}{\\partial \\mu}=\\frac{1}{\\sigma^{2}}\\sum_{i=1}^{n}(x_{i}-\\mu)=0\n\\;\\;\\Longrightarrow\\;\\;\n\\sum_{i=1}^{n}x_{i}-n\\mu=0\n\\;\\;\\Longrightarrow\\;\\;\n\\hat{\\mu}=\\frac{1}{n}\\sum_{i=1}^{n}x_{i}.\n$$\n其二阶导数为 $\\frac{\\partial^{2}\\ell}{\\partial \\mu^{2}}=-\\frac{n}{\\sigma^{2}}0$，因此该临界点是 $\\mu$ 的一个最大值点。\n\n为了求出 $\\sigma^{2}$ 的最大似然估计量，将 $\\ell$ 对 $\\sigma^{2}$ 求导并令其为零：\n$$\n\\frac{\\partial \\ell}{\\partial \\sigma^{2}}=-\\frac{n}{2}\\frac{1}{\\sigma^{2}}+\\frac{1}{2}\\frac{1}{(\\sigma^{2})^{2}}\\sum_{i=1}^{n}(x_{i}-\\mu)^{2}=0.\n$$\n两边同乘以 $2(\\sigma^{2})^{2}$ 得到\n$$\n-n\\sigma^{2}+\\sum_{i=1}^{n}(x_{i}-\\mu)^{2}=0\n\\;\\;\\Longrightarrow\\;\\;\n\\hat{\\sigma}^{2}=\\frac{1}{n}\\sum_{i=1}^{n}(x_{i}-\\hat{\\mu})^{2}.\n$$\n代入 $\\hat{\\mu}=\\frac{1}{n}\\sum_{j=1}^{n}x_{j}$ 得\n$$\n\\hat{\\sigma}^{2}=\\frac{1}{n}\\sum_{i=1}^{n}\\left(x_{i}-\\frac{1}{n}\\sum_{j=1}^{n}x_{j}\\right)^{2}.\n$$\n为验证这是 $\\sigma^{2}$ 的一个最大值点，计算其二阶导数\n$$\n\\frac{\\partial^{2}\\ell}{\\partial(\\sigma^{2})^{2}}=\\frac{n}{2(\\sigma^{2})^{2}}-\\frac{1}{(\\sigma^{2})^{3}}\\sum_{i=1}^{n}(x_{i}-\\mu)^{2},\n$$\n在临界点处，我们有 $\\sum_{i=1}^{n}(x_{i}-\\hat{\\mu})^{2}=n\\hat{\\sigma}^{2}$，代入二阶导数表达式得 $\\frac{n}{2(\\hat{\\sigma}^{2})^{2}}-\\frac{n\\hat{\\sigma}^{2}}{(\\hat{\\sigma}^{2})^{3}} = -\\frac{n}{2(\\hat{\\sigma}^{2})^{2}}  0$。因此，这两个估计量都使得对数似然函数最大化。\n\n因此，最大似然估计量是样本均值以及样本值与样本均值之差的平方的均值：\n$$\n\\hat{\\mu}=\\frac{1}{n}\\sum_{i=1}^{n}X_{i},\n\\quad\n\\hat{\\sigma}^{2}=\\frac{1}{n}\\sum_{i=1}^{n}\\left(X_{i}-\\frac{1}{n}\\sum_{j=1}^{n}X_{j}\\right)^{2}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{n}\\sum_{i=1}^{n}X_{i}  \\frac{1}{n}\\sum_{i=1}^{n}\\left(X_{i}-\\frac{1}{n}\\sum_{j=1}^{n}X_{j}\\right)^{2}\\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了基本方法之后，这项练习将深入探讨建模中一个更为精妙和关键的方面：数据筛选对参数估计的影响。我们将分析一个常见的实验场景，其中丢弃零计数样本的筛选步骤会给标准估计量带来系统性偏差。通过精确地解析推导出这种偏差 ，你将更深刻地理解为何必须在似然函数中准确反映真实的数据生成过程（包括任何筛选或截断），才能获得有效的统计推断。",
            "id": "2402432",
            "problem": "在一项用于定量单个基因座上稀有等位基因的靶向扩增子测序分析中，每个样本产生恰好 $n$ 个独立读数，每个读数报告该等位基因为突变型的概率为 $p$，为野生型的概率为 $1-p$，且各读数之间相互独立。令 $X$ 表示一个样本中的突变读数数量，因此 $X \\sim \\mathrm{Binomial}(n,p)$。作为质量控制过滤器的一部分，生物信息学流程会丢弃任何 $X=0$（即未观察到突变读数）的样本，仅保留 $X0$ 的样本。然后，分析师对保留的样本拟合一个二项模型，使用标准的二项似然（忽略过滤步骤），并从单个保留的样本中报告 $p$ 的最大似然估计量 (MLE) $\\hat{p}=X/n$。\n\n将整个过程（数据生成和过滤）视为数据生成机制，并视 $p \\in (0,1)$ 和 $n \\in \\{1,2,3,\\dots\\}$ 为固定值。仅使用基本原理和定义，推导在真实数据生成机制下该报告估计量的偏差的解析表达式，即：\n$$\n\\mathrm{Bias}(\\hat{p}) \\equiv \\mathbb{E}[\\hat{p}]-p,\n$$\n其中期望是关于在 $X0$ 条件下 $X$ 的条件分布计算的。请以 $p$ 和 $n$ 的闭式表达式形式给出最终答案。不要进行近似。您的最终答案必须是单个表达式，不带单位。",
            "solution": "该问题要求推导比例参数 $p$ 的一个特定估计量的偏差。问题陈述经过严格验证，被认为是科学上合理、适定、客观且自洽的。因此，有必要给出解答。\n\n突变等位基因概率 $p$ 的估计量为 $\\hat{p} = \\frac{X}{n}$，其中 $X$ 是总共 $n$ 个读数中的突变读数数量。数据生成过程包含一个过滤器，该过滤器会丢弃任何 $X=0$ 的样本。因此，分析仅在 $X0$ 的样本上进行。\n\n估计量 $\\hat{p}$ 的偏差定义为：\n$$\n\\mathrm{Bias}(\\hat{p}) \\equiv \\mathbb{E}[\\hat{p}] - p\n$$\n期望 $\\mathbb{E}[\\cdot]$ 必须是关于实际观察到的数据分布计算的。由于过滤步骤的存在，这个分布是 $X$ 在给定 $X  0$ 条件下的条件分布。\n\n首先，我们表达估计量 $\\hat{p}$ 的条件期望：\n$$\n\\mathbb{E}[\\hat{p} | X0] = \\mathbb{E}\\left[\\frac{X}{n} \\Big| X0\\right]\n$$\n根据期望的线性性质，我们可以写出：\n$$\n\\mathbb{E}[\\hat{p} | X0] = \\frac{1}{n} \\mathbb{E}[X | X0]\n$$\n我们的主要任务是计算条件期望 $\\mathbb{E}[X | X0]$。随机变量 $X$ 服从二项分布，$X \\sim \\mathrm{Binomial}(n,p)$，其概率质量函数 (PMF) 为：\n$$\nP(X=k) = \\binom{n}{k} p^k (1-p)^{n-k} \\quad \\text{对于 } k \\in \\{0, 1, 2, \\dots, n\\}\n$$\n离散随机变量的条件期望定义为：\n$$\n\\mathbb{E}[X | X0] = \\sum_{k} k \\cdot P(X=k | X0)\n$$\n求和是针对给定条件下 $X$ 的所有可能值。由于 $X0$， $k$ 的可能值为 $\\{1, 2, \\dots, n\\}$。\n根据条件概率的定义，对于任何 $k  0$：\n$$\nP(X=k | X0) = \\frac{P(X=k \\text{ 且 } X0)}{P(X0)}\n$$\n由于当 $k \\ge 1$ 时，事件 $\\{X=k\\}$ 是事件 $\\{X0\\}$ 的一个子集，它们的交集就是 $\\{X=k\\}$。因此：\n$$\nP(X=k | X0) = \\frac{P(X=k)}{P(X0)}\n$$\n条件事件的概率 $P(X0)$ 是观察到零个突变读数概率的补集：\n$$\nP(X0) = 1 - P(X=0)\n$$\n对于二项分布，零次成功的概率是：\n$$\nP(X=0) = \\binom{n}{0} p^0 (1-p)^{n-0} = (1-p)^n\n$$\n因此，条件事件的概率是：\n$$\nP(X0) = 1 - (1-p)^n\n$$\n现在我们可以写出条件期望的表达式：\n$$\n\\mathbb{E}[X | X0] = \\sum_{k=1}^{n} k \\cdot \\frac{P(X=k)}{P(X0)} = \\frac{1}{1 - (1-p)^n} \\sum_{k=1}^{n} k \\cdot P(X=k)\n$$\n求和项 $\\sum_{k=1}^{n} k \\cdot P(X=k)$ 几乎就是 $X$ 的无条件期望 $\\mathbb{E}[X] = \\sum_{k=0}^{n} k \\cdot P(X=k)$ 的定义。在无条件期望的求和中，当 $k=0$ 时的项是 $0 \\cdot P(X=0) = 0$，所以它对求和没有贡献。因此，从 $k=1$ 到 $n$ 的求和与从 $k=0$ 到 $n$ 的求和是相同的：\n$$\n\\sum_{k=1}^{n} k \\cdot P(X=k) = \\sum_{k=0}^{n} k \\cdot P(X=k) = \\mathbb{E}[X]\n$$\n一个服从二项分布的随机变量 $X \\sim \\mathrm{Binomial}(n,p)$ 的无条件期望是众所周知的 $\\mathbb{E}[X] = np$。\n将这个结果代入我们的条件期望表达式中：\n$$\n\\mathbb{E}[X | X0] = \\frac{np}{1 - (1-p)^n}\n$$\n现在我们可以计算我们的估计量 $\\hat{p}$ 的条件期望：\n$$\n\\mathbb{E}[\\hat{p} | X0] = \\frac{1}{n} \\mathbb{E}[X | X0] = \\frac{1}{n} \\left(\\frac{np}{1 - (1-p)^n}\\right) = \\frac{p}{1 - (1-p)^n}\n$$\n最后，我们可以通过将此结果代入偏差的定义来计算偏差：\n$$\n\\mathrm{Bias}(\\hat{p}) = \\mathbb{E}[\\hat{p} | X0] - p = \\frac{p}{1 - (1-p)^n} - p\n$$\n为了简化此表达式，我们找到一个公分母：\n$$\n\\mathrm{Bias}(\\hat{p}) = \\frac{p - p \\left(1 - (1-p)^n\\right)}{1 - (1-p)^n} = \\frac{p - p + p(1-p)^n}{1 - (1-p)^n}\n$$\n这可以简化为偏差的最终解析表达式：\n$$\n\\mathrm{Bias}(\\hat{p}) = \\frac{p(1-p)^n}{1 - (1-p)^n}\n$$\n这个表达式是在指定的数据生成和过滤机制下，估计量 $\\hat{p}$ 偏差的闭式表示，用参数 $p$ 和 $n$ 表示。由于 $p \\in (0,1)$，分子和分母都为正，这表明存在正偏差，这与过滤掉最低可能结果（$X=0$）的预期相符。",
            "answer": "$$\n\\boxed{\\frac{p(1-p)^n}{1 - (1-p)^n}}\n$$"
        },
        {
            "introduction": "最后的这项练习在一个真实的生物医学建模场景中，将理论与计算融为一体。你需要通过将一个由常微分方程（ODE）描述的病毒动力学机理模型与时间序列数据进行拟合，来估计一个关键的药物疗效参数。这个练习  展示了最大似然原理如何扩展到复杂的动态系统中，并构成了现代系统生物学和药理学中参数估计的基础，这一过程通常需要借助数值优化方法来完成。",
            "id": "2402430",
            "problem": "给定一个机制性病毒动力学模型和一名患者在治疗期间病毒载量随时间变化的合成观测数据。目标是实现最大似然估计，以推断药物疗效参数。\n\n状态变量是病毒载量 $V(t)$，单位为拷贝数/毫升，其演化遵循以下常微分方程\n$$\n\\frac{dV}{dt} \\;=\\; P \\;-\\; c\\,V(t) \\;-\\; k\\,V(t)\\,I(t),\n$$\n其中 $P$ 是生成速率（单位：拷贝数/毫升/天），$c$ 是自然清除率（单位：天$^{-1}$），$I(t)$ 是已知的以 mg/L 为单位的分段常数药物浓度，$k \\ge 0$ 是待估计的药物疗效参数，单位为天$^{-1}$/(mg/L)。初始条件 $V(0)=V_0$ 是已知的。\n\n观测值是在指定时间点的病毒载量的自然对数。具体来说，对于观测时间 $\\{t_i\\}_{i=1}^n$，测量值满足\n$$\nY_i \\;=\\; \\ln V(t_i) + \\varepsilon_i,\n$$\n其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ 是独立的、标准差 $\\sigma$ 已知的高斯噪声项。时间单位为天，浓度单位为 mg/L，最终估计的 $k$ 值必须以实数形式报告，单位为天$^{-1}$/(mg/L)。\n\n实现一个程序，对于下述每个测试用例，根据给定的参数、观测时间、分段常数函数 $I(t)$ 以及观测值 $\\{Y_i\\}$，计算 $k$ 的最大似然估计。所有对数运算均使用自然对数。假设 $k \\in [0,5]$。\n\n测试套件（三个用例）：\n- 用例 A（恒定药物下的普遍衰减）：\n  - 参数：$P=100000$, $c=1.2$, $V_0=200000$, $\\sigma=0.05$。\n  - 给药方案 $I(t)$：一个区间 $[0,12]$，$I(t)=2.0$ mg/L。\n  - 观测时间（天）：$[0,1,3,6,9,12]$。\n  - 观测值 $Y$（无量纲，自然对数）：$[12.206073,\\,11.220599,\\,10.880400,\\,10.871102,\\,10.871071,\\,10.871071]$。\n- 用例 B（药物浓度的阶跃变化）：\n  - 参数：$P=80000$, $c=0.8$, $V_0=100000$, $\\sigma=0.05$。\n  - 给药方案 $I(t)$：两个区间 $[0,2]$，$I(t)=0.0$ mg/L；以及 $(2,8]$，$I(t)=4.0$ mg/L。\n  - 观测时间（天）：$[0,1,2,3,5,8]$。\n  - 观测值 $Y$（无量纲，自然对数）：$[11.512925,\\,11.512925,\\,11.512925,\\,10.242055,\\,10.126838,\\,10.126635]$。\n- 用例 C（低剂量药物下缓慢趋近稳态，稀疏采样）：\n  - 参数：$P=60000$, $c=1.0$, $V_0=50000$, $\\sigma=0.05$。\n  - 给药方案 $I(t)$：一个区间 $[0,8]$，$I(t)=0.5$ mg/L。\n  - 观测时间（天）：$[0,2,4,8]$。\n  - 观测值 $Y$（无量纲，自然对数）：$[10.819778,\\,10.937881,\\,10.951433,\\,10.953281]$。\n\n你的程序必须为每个测试用例生成与模型和观测数据一致的最大似然估计值 $\\hat{k}$，并遵守 $k \\in [0,5]$ 的界限。将每个 $\\hat{k}$ 表示为单位是 天$^{-1}$/(mg/L) 的实数，并四舍五入到三位小数（输出中不包含单位）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含三个估计值，按测试用例 A、B、C 的顺序聚合为一个用方括号括起来的逗号分隔列表。例如，输出必须类似于 $[\\hat{k}_A,\\hat{k}_B,\\hat{k}_C]$，其中每个条目都四舍五入到三位小数，且没有额外的空格。\n\n所有计算都必须在你的程序中自包含完成。不得使用用户交互或外部数据。",
            "solution": "该问题要求在一个给定的病毒动力学模型中，利用最大似然估计（MLE）原理来确定药物疗效参数 $k$。所提供的数据包括三种不同情景下病毒载量随时间变化的合成带噪测量值。\n\n首先，确认问题陈述的有效性。该模型是用于病毒载量动力学的标准、有科学依据的线性常微分方程（ODE）。观测模型假设病毒载量的对数上存在加性高斯噪声，这是生物学建模中一种常见且适当的选择，它确保了状态变量的正定性，并表示原始尺度上的乘性误差。所有参数、初始条件和数据都已提供，使得问题是自包含且适定的。不存在矛盾、歧义或违背科学原理之处。因此，我们着手求解。\n\n问题的核心是找到使观测到给定数据 $\\{Y_i\\}_{i=1}^n$ 的似然最大的 $k$ 值。观测模型表述为：\n$$\nY_i = \\ln V(t_i) + \\varepsilon_i\n$$\n其中 $\\varepsilon_i$ 是来自均值为 $0$、已知方差为 $\\sigma^2$ 的正态分布的独立同分布随机变量，即 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。\n\n由此，给定模型预测值 $\\ln V(t_i; k)$，单个观测值 $Y_i$ 的概率分布为：\n$$\np(Y_i | k) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left( -\\frac{(Y_i - \\ln V(t_i; k))^2}{2\\sigma^2} \\right)\n$$\n符号 $V(t_i; k)$ 强调了病毒载量预测对参数 $k$ 的依赖性。\n\n由于噪声项 $\\varepsilon_i$ 是独立的，所有 $n$ 个观测值的总似然函数 $L(k)$ 是各个概率的乘积：\n$$\nL(k) = \\prod_{i=1}^n p(Y_i | k) = \\left( \\frac{1}{2\\pi\\sigma^2} \\right)^{n/2} \\exp\\left( -\\frac{1}{2\\sigma^2} \\sum_{i=1}^n (Y_i - \\ln V(t_i; k))^2 \\right)\n$$\n\n最大化似然函数 $L(k)$ 等价于最大化其自然对数，即对数似然函数 $\\ell(k)$：\n$$\n\\ell(k) = \\ln L(k) = -\\frac{n}{2}\\ln(2\\pi\\sigma^2) - \\frac{1}{2\\sigma^2} \\sum_{i=1}^n (Y_i - \\ln V(t_i; k))^2\n$$\n\n为求得最大似然估计 $\\hat{k}$，我们必须找到使 $\\ell(k)$ 最大化的 $k$ 值。第一项 $-\\frac{n}{2}\\ln(2\\pi\\sigma^2)$ 和缩放因子 $-\\frac{1}{2\\sigma^2}$ 均与 $k$ 无关。因此，最大化 $\\ell(k)$ 等价于最小化观测对数数据与预测对数数据之间的残差平方和（SSR）：\n$$\n\\hat{k} = \\arg\\min_{k \\in [0,5]} \\text{SSR}(k) \\quad \\text{where} \\quad \\text{SSR}(k) = \\sum_{i=1}^n (Y_i - \\ln V(t_i; k))^2\n$$\n对 $\\hat{k}$ 的搜索被约束在区间 $[0, 5]$ 内。\n\n为评估给定 $k$ 的 SSR，我们必须计算模型预测值 $V(t_i; k)$。其控制 ODE 为：\n$$\n\\frac{dV}{dt} = P - (c + kI(t))V(t)\n$$\n这是一个线性一阶常微分方程。由于药物浓度 $I(t)$ 被指定为分段常数函数，我们可以在 $I(t)$ 为常数的每个时间区间内解析地求解该 ODE。考虑一个区间 $[t_A, t_B]$，在该区间内 $I(t) = I_{\\text{const}}$。ODE 变为：\n$$\n\\frac{dV}{dt} + \\lambda V = P, \\quad \\text{with} \\quad \\lambda = c + kI_{\\text{const}}\n$$\n给定初始条件 $V(t_A)$，该方程的解为：\n$$\nV(t) = V_{ss} + (V(t_A) - V_{ss}) e^{-\\lambda(t - t_A)} \\quad \\text{for} \\quad t \\in [t_A, t_B]\n$$\n其中 $V_{ss} = P/\\lambda$ 是在恒定药物浓度 $I_{\\text{const}}$ 下的稳态病毒载量。此解析解允许在任意时间 $t$ 精确计算 $V(t)$。注意，由于 $P  0$ 且 $V(0)  0$，病毒载量 $V(t)$ 对所有 $t \\ge 0$ 保持为正，因此其对数总是有定义的。\n\n计算策略如下：\n1.  定义一个目标函数，该函数接受一个 $k$ 值并返回相应的 SSR。\n2.  在此函数内部，对于给定的 $k$：\n    a.  需要一个模拟例程来计算所有观测时间 $\\{t_i\\}_{i=1}^n$ 的 $V(t_i; k)$。\n    b.  该例程首先建立一个统一的时间轴，包含所有观测时间点和药物浓度 $I(t)$ 发生变化的所有时间点。\n    c.  然后，它使用解析解将 ODE 从一个时间点积分到下一个时间点，以分段方式向前传播 $V(t)$ 的值。每个分段的初始条件是前一个分段的最终值，从 $V(0) = V_0$ 开始。\n    d.  计算出所有 $i$ 的 $V(t_i)$ 后，该函数计算 $\\ln V(t_i; k)$ 并与观测数据 $\\{Y_i\\}$ 计算 SSR。\n3.  使用数值优化算法在指定范围 $[0, 5]$ 内找到最小化目标函数的 $k$ 值。一个合适的选择是有界标量最小化方法，例如 SciPy 库中提供的方法。对所提供的三个测试用例中的每一个都重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Computes the Maximum Likelihood Estimate (MLE) for the drug efficacy parameter k\n    for three test cases of a viral dynamics model.\n    \"\"\"\n\n    test_cases = [\n        # Case A\n        {\n            'P': 100000.0, 'c': 1.2, 'V0': 200000.0, 'sigma': 0.05,\n            'drug_schedule': [(12.0, 2.0)],  # (t_end, concentration)\n            'obs_times': [0.0, 1.0, 3.0, 6.0, 9.0, 12.0],\n            'Y_obs': [12.206073, 11.220599, 10.880400, 10.871102, 10.871071, 10.871071]\n        },\n        # Case B\n        {\n            'P': 80000.0, 'c': 0.8, 'V0': 100000.0, 'sigma': 0.05,\n            'drug_schedule': [(2.0, 0.0), (8.0, 4.0)],\n            'obs_times': [0.0, 1.0, 2.0, 3.0, 5.0, 8.0],\n            'Y_obs': [11.512925, 11.512925, 11.512925, 10.242055, 10.126838, 10.126635]\n        },\n        # Case C\n        {\n            'P': 60000.0, 'c': 1.0, 'V0': 50000.0, 'sigma': 0.05,\n            'drug_schedule': [(8.0, 0.5)],\n            'obs_times': [0.0, 2.0, 4.0, 8.0],\n            'Y_obs': [10.819778, 10.937881, 10.951433, 10.953281]\n        }\n    ]\n\n    def get_I(t, drug_schedule):\n        \"\"\"\n        Returns the drug concentration I at a given time t based on the piecewise schedule.\n        \"\"\"\n        for t_end, I_val in drug_schedule:\n            # The problem defines intervals like [0, T1] and (T1, T2].\n            # A time t equal to an endpoint T1 falls into the first interval.\n            if t = t_end:\n                return I_val\n        # This part should not be reached if observation times are within the schedule.\n        return drug_schedule[-1][1]\n\n    def simulate_V_at_times(k, P, c, V0, drug_schedule, obs_times):\n        \"\"\"\n        Simulates the viral load V(t) at specified observation times\n        by solving the ODE piecewise.\n        \"\"\"\n        # Create a unified timeline of all relevant time points.\n        schedule_endpoints = [s[0] for s in drug_schedule]\n        # Using a set handles duplicate times.\n        all_unique_times = sorted(list(set([0.0] + list(obs_times) + schedule_endpoints)))\n        \n        # Filter out any times beyond the final observation/schedule time\n        max_time = max(max(obs_times), max(schedule_endpoints))\n        all_unique_times = [t for t in all_unique_times if t = max_time]\n        \n        v_results = {0.0: V0}\n        v_current = V0\n        \n        for i in range(len(all_unique_times) - 1):\n            t_start = all_unique_times[i]\n            t_end = all_unique_times[i+1]\n            \n            if t_start >= t_end:\n                continue\n            \n            dt = t_end - t_start\n            \n            # I(t) is constant on (t_start, t_end]. A point in the middle ensures correctness.\n            mid_point_t = (t_start + t_end) / 2.0\n            I_val = get_I(mid_point_t, drug_schedule)\n            \n            lam = c + k * I_val\n            \n            if lam == 0.0:\n                v_end = v_current + P * dt\n            else:\n                v_ss = P / lam\n                v_end = v_ss + (v_current - v_ss) * np.exp(-lam * dt)\n                \n            v_results[t_end] = v_end\n            v_current = v_end\n            \n        # Extract V values in the order of the original observation times\n        return np.array([v_results[t] for t in obs_times])\n\n    def make_objective_function(P, c, V0, drug_schedule, obs_times, Y_obs):\n        \"\"\"\n        Creates the objective function (Sum of Squared Residuals) to be minimized.\n        \"\"\"\n        Y_obs_arr = np.array(Y_obs)\n        \n        def objective(k):\n            V_pred = simulate_V_at_times(k, P, c, V0, drug_schedule, obs_times)\n            \n            # V(t) is guaranteed to be positive given P>0, V0>0.\n            Y_pred = np.log(V_pred)\n            \n            ssr = np.sum((Y_obs_arr - Y_pred)**2)\n            return ssr\n            \n        return objective\n\n    results = []\n    for case in test_cases:\n        objective_func = make_objective_function(\n            case['P'], case['c'], case['V0'], \n            case['drug_schedule'], case['obs_times'], case['Y_obs']\n        )\n        \n        # Find the value of k that minimizes the objective function, bounded in [0, 5].\n        opt_result = minimize_scalar(\n            objective_func, \n            bounds=(0, 5), \n            method='bounded'\n        )\n        \n        results.append(opt_result.x)\n\n    # Format the output as specified: a comma-separated list in brackets,\n    # with each value rounded to three decimal places.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}