{
    "hands_on_practices": [
        {
            "introduction": "我们从最核心的模型开始。在生物系统中，对蛋白质浓度的最直接的建模方法是将其视为一个连续量，其变化由平均合成速率和降解速率决定。本练习将建立蛋白质动力学的基本常微分方程（ODE），这是理解系统如何达到稳态的基础。掌握这个确定性模型是探索更复杂的细胞现象（如随机噪声和调控）之前至关重要的第一步。",
            "id": "3906729",
            "problem": "一种蛋白质存在于一个均匀、充分混合的细胞区室中。设蛋白质浓度表示为 $P(t)$，其初始值为 $P(0) = P_{0}$。假设合成速率 $k_{s}$（单位时间浓度）为常数，一级降解的速率常数为 $k_{d}$（单位时间）。从封闭区室（无平流流入或流出）的质量守恒原理出发，基于源项和汇项的净平衡，建立 $P(t)$ 的控制常微分方程（ODE）。推导出 $P(t)$ 关于 $P_{0}$、$k_{s}$、$k_{d}$ 和 $t$ 的闭式解析解，然后在趋于稳态和依赖于初始条件的背景下解释当 $t \\to 0^{+}$ 和 $t \\to \\infty$ 时的极限行为。请将您的最终答案以 $P(t)$ 的单一闭式表达式形式给出。不需要进行数值计算，也不需要四舍五入。在最终的方框答案中不要包含单位。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n**步骤1：提取已知条件**\n- 时间 $t$ 时的蛋白质浓度：$P(t)$\n- 初始蛋白质浓度：$P(0) = P_{0}$\n- 恒定合成速率：$k_{s}$（量纲为单位时间浓度）\n- 一级降解速率常数：$k_{d}$（量纲为单位时间）\n- 控制原理：封闭、均匀、充分混合区室的质量守恒。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题描述了一个零级生产和一级消耗过程。这是一个标准且基础的单室模型，广泛应用于系统生物学、药代动力学和化学动力学中，用于模拟物质的浓度。该模型具有科学合理性，并基于已建立的质量平衡原理。\n- **适定性：** 该问题要求解一个带指定初始条件的一阶线性常微分方程。根据微分方程理论，此类问题已知有唯一且稳定的解。求解所需的所有参数（$P_{0}$、$k_{s}$、$k_{d}$）均已提供。\n- **客观性：** 问题使用精确、客观和定量的术语进行表述。没有主观或模棱两可的陈述。\n\n**步骤3：结论与行动**\n该问题被确定为有效的，因为它具有科学依据、适定、客观，并包含唯一解所需的所有必要信息。因此，我将继续进行推导。\n\n构建控制微分方程的核心原理是质量守恒。对于一个充分混合的区室，蛋白质浓度的变化率 $\\frac{dP(t)}{dt}$ 是所有源（生产）过程速率之和减去所有汇（去除）过程速率之和。\n\n$$\n\\text{变化率} = \\text{合成速率} - \\text{降解速率}\n$$\n\n问题陈述了一个恒定的合成速率，这是一个零级过程。它对变化率的贡献就是常数 $k_{s}$。\n$$\n\\text{合成速率} = k_{s}\n$$\n降解是一个一级过程，这意味着其速率与当前浓度 $P(t)$ 成正比。比例常数是降解速率常数 $k_{d}$。\n$$\n\\text{降解速率} = k_{d} P(t)\n$$\n结合这些项，得到控制常微分方程（ODE）：\n$$\n\\frac{dP(t)}{dt} = k_{s} - k_{d} P(t)\n$$\n这是一个一阶、线性、非齐次、常系数的常微分方程。为了求解它，我们可以将其重新排列成标准形式：\n$$\n\\frac{dP(t)}{dt} + k_{d} P(t) = k_{s}\n$$\n这个常微分方程可以用积分因子 $I(t)$ 来求解。积分因子由下式给出：\n$$\nI(t) = \\exp\\left(\\int k_{d} \\, dt\\right) = \\exp(k_{d} t)\n$$\n将整个标准形式的常微分方程乘以积分因子 $I(t)$，得到：\n$$\n\\exp(k_{d} t) \\frac{dP(t)}{dt} + k_{d} \\exp(k_{d} t) P(t) = k_{s} \\exp(k_{d} t)\n$$\n根据微分的乘法法则，该方程的左边是 $P(t)$ 和积分因子 $I(t)$ 乘积的导数：\n$$\n\\frac{d}{dt} \\left[ P(t) \\exp(k_{d} t) \\right] = k_{s} \\exp(k_{d} t)\n$$\n为了找到解，我们对两边关于时间 $t$ 进行积分：\n$$\n\\int \\frac{d}{dt} \\left[ P(t) \\exp(k_{d} t) \\right] dt = \\int k_{s} \\exp(k_{d} t) dt\n$$\n$$\nP(t) \\exp(k_{d} t) = \\frac{k_{s}}{k_{d}} \\exp(k_{d} t) + C\n$$\n其中 $C$ 是积分常数。为了求得 $P(t)$ 的显式解，我们两边除以 $\\exp(k_{d} t)$：\n$$\nP(t) = \\frac{k_{s}}{k_{d}} + C \\exp(-k_{d} t)\n$$\n积分常数 $C$ 的值通过应用初始条件 $P(0) = P_{0}$ 来确定：\n$$\nP(0) = P_{0} = \\frac{k_{s}}{k_{d}} + C \\exp(-k_{d} \\cdot 0) = \\frac{k_{s}}{k_{d}} + C\n$$\n求解 $C$：\n$$\nC = P_{0} - \\frac{k_{s}}{k_{d}}\n$$\n将 $C$ 的这个表达式代入通解中，得到 $P(t)$ 的最终闭式解析解：\n$$\nP(t) = \\frac{k_{s}}{k_{d}} + \\left( P_{0} - \\frac{k_{s}}{k_{d}} \\right) \\exp(-k_{d} t)\n$$\n通过分离各项，可以将此解重新排列成一个等价且通常更直观的形式：\n$$\nP(t) = \\frac{k_{s}}{k_{d}} - \\frac{k_{s}}{k_{d}} \\exp(-k_{d} t) + P_{0} \\exp(-k_{d} t)\n$$\n$$\nP(t) = \\frac{k_{s}}{k_{d}} \\left(1 - \\exp(-k_{d} t)\\right) + P_{0} \\exp(-k_{d} t)\n$$\n\n接下来，我们解释此解的极限行为。\n\n**当 $t \\to 0^{+}$ 时的极限：**\n当时间从正方向趋近于零时，我们计算极限：\n$$\n\\lim_{t \\to 0^{+}} P(t) = \\lim_{t \\to 0^{+}} \\left[ \\frac{k_{s}}{k_{d}} \\left(1 - \\exp(-k_{d} t)\\right) + P_{0} \\exp(-k_{d} t) \\right]\n$$\n因为 $\\exp(0) = 1$，极限变为：\n$$\nP(t \\to 0^{+}) = \\frac{k_{s}}{k_{d}} (1 - 1) + P_{0}(1) = 0 + P_{0} = P_{0}\n$$\n这证实了解在 $t=0$ 处是连续的，并正确返回初始条件 $P_{0}$，符合系统的物理要求。\n\n**当 $t \\to \\infty$ 时的极限：**\n当时间趋于无穷大时，指数项 $\\exp(-k_{d} t)$ 趋近于零，前提是降解常数 $k_{d}$ 必须为正才能发生降解。\n$$\n\\lim_{t \\to \\infty} P(t) = \\lim_{t \\to \\infty} \\left[ \\frac{k_{s}}{k_{d}} \\left(1 - \\exp(-k_{d} t)\\right) + P_{0} \\exp(-k_{d} t) \\right]\n$$\n$$\nP(t \\to \\infty) = \\frac{k_{s}}{k_{d}} (1 - 0) + P_{0}(0) = \\frac{k_{s}}{k_{d}}\n$$\n这个极限值是稳态浓度，记为 $P_{ss}$。在稳态时，浓度不随时间变化，即 $\\frac{dP}{dt} = 0$。从我们最初的常微分方程可知，这意味着 $0 = k_{s} - k_{d} P_{ss}$，从而得到 $P_{ss} = \\frac{k_{s}}{k_{d}}$。我们的解正确地收敛到这个值。其解释是，经过足够长的时间后，系统达到一个平衡状态，此时蛋白质的合成速率与降解速率完全相等。至关重要的是要注意到，这个稳态值与初始浓度 $P_{0}$ 无关。项 $P_{0} \\exp(-k_{d} t)$ 代表了初始状态的瞬态影响，它随时间呈指数衰减，最终状态仅由合成速率和降解速率的平衡决定。",
            "answer": "$$\n\\boxed{\\frac{k_{s}}{k_{d}} \\left(1 - \\exp(-k_{d} t)\\right) + P_{0} \\exp(-k_{d} t)}\n$$"
        },
        {
            "introduction": "确定性模型描述的是大量分子的平均行为，但在单个细胞内，由于分子数量通常很少，化学反应本质上是随机的。本练习将超越平均值的概念，使用化学主方程将蛋白质的合成和降解建模为一个随机的生灭过程。通过推导蛋白质数量分布的平均值和方差，您将深入理解细胞功能和变异性中固有的内在噪声。",
            "id": "3906698",
            "problem": "考虑一个均匀混合细胞中的单一蛋白质物种 $P$，在随机化学动力学框架下，该过程被建模为一个连续时间马尔可夫跳跃过程。蛋白质以恒定的零级速率 $k_{s}$（分子/单位时间）组成性地合成，该过程与当前蛋白质数量无关。蛋白质通过一级过程降解，速率常数为 $k_{d}$（每分子/单位时间），因此当存在 $n$ 个分子时，降解倾向为 $k_{d}\\,n$。设 $p_{n}(t)$ 表示在时刻 $t$ 存在 $n$ 个 $P$ 分子的概率。建模的基本依据是化学主方程（CME），该方程指出，$p_{n}(t)$ 的时间演化由允许的反应所引起的流入和流出概率流的总和决定。\n\n从化学主方程出发，在不预先假设稳态分布任何特定形式的情况下，推导该泊松出生和线性死亡过程中蛋白质拷贝数分布的稳态均值 $\\langle P \\rangle$ 和方差 $\\mathrm{Var}(P)$。然后计算法诺因子 $F = \\mathrm{Var}(P) / \\langle P \\rangle$。将您的最终结果用 $k_{s}$ 和 $k_{d}$ 以闭合形式表示。不需要进行数值近似或四舍五入，最终表达式中也不应包含单位。",
            "solution": "该问题要求计算一个简单的蛋白质合成与降解过程中，蛋白质拷贝数的稳态均值、方差和法诺因子。该过程被建模为一个由化学主方程（CME）控制的连续时间马尔可夫跳跃过程。对问题陈述的验证已确认其科学合理性、自洽性和良定性。\n\n该系统由单一物种 $P$ 组成。反应如下：\n1.  蛋白质合成：$\\emptyset \\xrightarrow{k_s} P$。这是一个零级反应，其倾向（速率）为常数 $a_1(n) = k_s$。\n2.  蛋白质降解：$P \\xrightarrow{k_d} \\emptyset$。这是一个一级反应，其倾向为 $a_2(n) = k_d n$，其中 $n$ 是蛋白质 $P$ 的分子数。\n\n设 $p_n(t)$ 为在时刻 $t$ 有 $n$ 个蛋白质 $P$ 分子的概率。化学主方程（CME）描述了此概率分布的时间演化。对于一个有 $n$ 个分子的状态，其概率因从 $n-1$ 分子状态的合成或从 $n+1$ 分子状态的降解而增加。其概率因合成为 $n+1$ 分子状态或降解为 $n-1$ 分子状态而减少。\n\n该系统的CME为：\n$$ \\frac{dp_n(t)}{dt} = k_s p_{n-1}(t) + k_d(n+1)p_{n+1}(t) - (k_s + k_d n)p_n(t) $$\n该方程对 $n \\ge 1$ 成立。对于状态 $n=0$，没有导致 $n=-1$ 的降解项，因此方程为：\n$$ \\frac{dp_0(t)}{dt} = k_d p_1(t) - k_s p_0(t) $$\n\n该问题要求在不首先求解稳态分布 $p_n$ 的情况下推导分布的矩。我们可以通过推导矩本身所满足的常微分方程来实现这一点。对于任意函数 $f(n)$，其期望值 $\\langle f(n) \\rangle = \\sum_{n=0}^{\\infty} f(n) p_n(t)$ 的时间演化由下式给出：\n$$ \\frac{d\\langle f(n) \\rangle}{dt} = \\sum_{n=0}^{\\infty} f(n) \\frac{dp_n(t)}{dt} $$\n一个更直接的方法是考虑每次反应时 $f(n)$ 的变化。对于一个倾向为 $a_j(n)$、将拷贝数改变 $\\nu_j$ 的反应 $j$，$\\langle f(n) \\rangle$ 的变化率为：\n$$ \\frac{d\\langle f(n) \\rangle}{dt} = \\sum_{j} \\langle (f(n+\\nu_j) - f(n)) a_j(n) \\rangle $$\n对我们的系统，我们有两个反应：\n合成 ($j=1$): $\\nu_1 = +1$, $a_1(n) = k_s$。\n降解 ($j=2$): $\\nu_2 = -1$, $a_2(n) = k_d n$。\n矩演化的一般方程为：\n$$ \\frac{d\\langle f(n) \\rangle}{dt} = \\langle (f(n+1) - f(n))k_s \\rangle + \\langle (f(n-1) - f(n))k_d n \\rangle $$\n\n首先，我们推导稳态均值 $\\langle P \\rangle = \\langle n \\rangle_{ss}$。令 $f(n) = n$。\n$$ \\frac{d\\langle n \\rangle}{dt} = \\langle ((n+1) - n)k_s \\rangle + \\langle ((n-1) - n)k_d n \\rangle $$\n$$ \\frac{d\\langle n \\rangle}{dt} = \\langle (1)k_s \\rangle + \\langle (-1)k_d n \\rangle $$\n利用期望算子的线性性质，$\\langle cX \\rangle = c\\langle X \\rangle$ 和 $\\langle c \\rangle = c$：\n$$ \\frac{d\\langle n \\rangle}{dt} = k_s - k_d \\langle n \\rangle $$\n在稳态下，矩是恒定的，因此 $\\frac{d\\langle n \\rangle}{dt} = 0$。设 $\\langle P \\rangle = \\langle n \\rangle_{ss}$ 表示稳态均值。\n$$ 0 = k_s - k_d \\langle P \\rangle $$\n求解 $\\langle P \\rangle$：\n$$ \\langle P \\rangle = \\frac{k_s}{k_d} $$\n\n接下来，我们推导稳态方差 $\\mathrm{Var}(P) = \\langle n^2 \\rangle_{ss} - \\langle n \\rangle_{ss}^2$。这需要计算二阶矩 $\\langle n^2 \\rangle_{ss}$。令 $f(n) = n^2$。\n$$ \\frac{d\\langle n^2 \\rangle}{dt} = \\langle ((n+1)^2 - n^2)k_s \\rangle + \\langle ((n-1)^2 - n^2)k_d n \\rangle $$\n简化期望内的项：\n$(n+1)^2 - n^2 = n^2 + 2n + 1 - n^2 = 2n+1$\n$(n-1)^2 - n^2 = n^2 - 2n + 1 - n^2 = -2n+1$\n将这些代入 $\\frac{d\\langle n^2 \\rangle}{dt}$ 的方程中：\n$$ \\frac{d\\langle n^2 \\rangle}{dt} = \\langle (2n+1)k_s \\rangle + \\langle (-2n+1)k_d n \\rangle $$\n$$ \\frac{d\\langle n^2 \\rangle}{dt} = k_s \\langle 2n+1 \\rangle + k_d \\langle -2n^2+n \\rangle $$\n利用期望的线性性质：\n$$ \\frac{d\\langle n^2 \\rangle}{dt} = k_s (2\\langle n \\rangle + 1) + k_d (-2\\langle n^2 \\rangle + \\langle n \\rangle) $$\n$$ \\frac{d\\langle n^2 \\rangle}{dt} = 2k_s \\langle n \\rangle + k_s - 2k_d \\langle n^2 \\rangle + k_d \\langle n \\rangle $$\n在稳态下，$\\frac{d\\langle n^2 \\rangle}{dt} = 0$。设 $\\langle n^2 \\rangle_{ss}$ 为稳态二阶矩。\n$$ 0 = 2k_s \\langle n \\rangle_{ss} + k_s - 2k_d \\langle n^2 \\rangle_{ss} + k_d \\langle n \\rangle_{ss} $$\n重新整理以求解 $\\langle n^2 \\rangle_{ss}$：\n$$ 2k_d \\langle n^2 \\rangle_{ss} = (2k_s + k_d)\\langle n \\rangle_{ss} + k_s $$\n现在，代入先前求得的稳态均值 $\\langle n \\rangle_{ss} = k_s/k_d$：\n$$ 2k_d \\langle n^2 \\rangle_{ss} = (2k_s + k_d)\\left(\\frac{k_s}{k_d}\\right) + k_s $$\n$$ 2k_d \\langle n^2 \\rangle_{ss} = \\frac{2k_s^2}{k_d} + k_s + k_s = \\frac{2k_s^2}{k_d} + 2k_s $$\n求解 $\\langle n^2 \\rangle_{ss}$：\n$$ \\langle n^2 \\rangle_{ss} = \\frac{1}{2k_d}\\left(\\frac{2k_s^2}{k_d} + 2k_s\\right) = \\frac{k_s^2}{k_d^2} + \\frac{k_s}{k_d} $$\n现在我们可以计算方差：\n$$ \\mathrm{Var}(P) = \\langle n^2 \\rangle_{ss} - (\\langle n \\rangle_{ss})^2 = \\left(\\frac{k_s^2}{k_d^2} + \\frac{k_s}{k_d}\\right) - \\left(\\frac{k_s}{k_d}\\right)^2 $$\n$$ \\mathrm{Var}(P) = \\frac{k_s}{k_d} $$\n\n最后，我们计算法诺因子 $F$，其定义为方差与均值之比：\n$$ F = \\frac{\\mathrm{Var}(P)}{\\langle P \\rangle} = \\frac{k_s/k_d}{k_s/k_d} $$\n$$ F = 1 $$\n法诺因子为 $1$ 表明蛋白质拷贝数的稳态分布是参数为 $\\lambda = k_s/k_d$ 的泊松分布，这是我们在没有预先假设此分布形式的情况下得到的结果。\n\n所求的三个量为：\n均值：$\\langle P \\rangle = \\frac{k_s}{k_d}$\n方差：$\\mathrm{Var}(P) = \\frac{k_s}{k_d}$\n法诺因子：$F = 1$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{k_s}{k_d}  \\frac{k_s}{k_d}  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "真实的蛋白质生产过程更为复杂，通常涉及转录等中间步骤。这个计算实践练习将应用著名的Gillespie算法来模拟一个更真实的包含mRNA和蛋白质的两阶段基因表达模型。通过亲手实现这个模拟，您将探索转录脉冲和分子寿命等因素如何共同影响蛋白质表达的噪声，从而架起理论模型与可观测的细胞行为之间的桥梁。",
            "id": "3906686",
            "problem": "考虑一个经典的、用于描述单细胞内信使核糖核酸 (mRNA) 和蛋白质的双阶段随机基因表达模型，该模型被构建为一个连续时间马尔可夫链 (CTMC)，在质量作用动力学下包含以下反应：\n- 转录：$\\varnothing \\xrightarrow{k_{\\mathrm{tx}}} m$，\n- mRNA 降解：$m \\xrightarrow{k_{\\mathrm{dm}}} \\varnothing$，\n- 翻译：$m \\xrightarrow{k_{\\mathrm{tl}}} m + P$，\n- 蛋白质降解（或稀释）：$P \\xrightarrow{k_d} \\varnothing$。\n此处，$m$ 表示 mRNA 拷贝数，$P$ 表示蛋白质拷贝数。反应倾向由广泛接受的随机化学动力学法则给出：转录为一个零级倾向 $a_1 = k_{\\mathrm{tx}}$，mRNA 降解、翻译和蛋白质降解分别为一级倾向 $a_2 = k_{\\mathrm{dm}}\\,m$、$a_3 = k_{\\mathrm{tl}}\\,m$ 和 $a_4 = k_d\\,P$。随机模拟算法 (SSA)，也称为 Gillespie 算法，通过从速率为 $a_0 = a_1 + a_2 + a_3 + a_4$ 的指数分布中采样下一次反应的等待时间 $\\Delta t$，并根据各反应倾向的比例选择发生的反应，从而推进 CTMC 的演化。此构建源于化学主方程，并基于充分混合、等温条件的假设。\n\n任务：实现一个程序，在给定固定的动力学参数和一组指定的蛋白质降解速率的情况下，为每个速率模拟一条长的 SSA 轨迹，并在一个预烧期后，使用时间加权稳态平均值来估计蛋白质拷贝数的稳态变异系数，其定义为 $\\mathrm{CV} = \\sqrt{\\mathrm{Var}(P)}/\\langle P \\rangle$。\n\n使用以下科学上一致的参数值和单位：\n- 转录速率：$k_{\\mathrm{tx}} = 1.0\\ \\text{min}^{-1}$。\n- mRNA 降解速率：$k_{\\mathrm{dm}} = 0.2\\ \\text{min}^{-1}$。\n- 每 mRNA 翻译速率：$k_{\\mathrm{tl}} = 5.0\\ \\text{min}^{-1}$。\n- 待变化的蛋白质降解速率：$k_d \\in \\{0.05, 0.1, 0.2, 0.5, 1.0\\}\\ \\text{min}^{-1}$。\n- 时间 $t = 0$ 时的初始条件：$m(0) = 0$，$P(0) = 0$。\n- 总模拟时间：$T_{\\mathrm{total}} = 2000\\ \\text{min}$。\n- 用于丢弃瞬态的预烧时间：$T_{\\mathrm{burn}} = 500\\ \\text{min}$。\n\n基本原理和估计原则：对于在稳态下具有有限期望计数的不可约 CTMC，根据其遍历性，时间平均等于系综平均。因此，对于 $t \\ge T_{\\mathrm{burn}}$，时间加权估计\n$$\n\\langle P \\rangle \\approx \\frac{1}{T_{\\mathrm{total}} - T_{\\mathrm{burn}}}\\int_{T_{\\mathrm{burn}}}^{T_{\\mathrm{total}}} P(t)\\,dt,\\quad\n\\langle P^2 \\rangle \\approx \\frac{1}{T_{\\mathrm{total}} - T_{\\mathrm{burn}}}\\int_{T_{\\mathrm{burn}}}^{T_{\\mathrm{total}}} P(t)^2\\,dt\n$$\n可以得出 $\\mathrm{Var}(P) \\approx \\langle P^2 \\rangle - \\langle P \\rangle^2$，进而得到 $\\mathrm{CV} \\approx \\sqrt{\\mathrm{Var}(P)}/\\langle P \\rangle$。\n\n实现约束：\n- 使用上述定义的倾向，通过 Gillespie 算法进行模拟。\n- 在反应间隔期内，系统状态是恒定的；因此，对于每个反应间隔中位于 $[T_{\\mathrm{burn}}, T_{\\mathrm{total}}]$ 内的部分，通过累加 $P\\,\\Delta t$ 和 $P^2\\,\\Delta t$ 来计算时间加权矩。\n- 使用分钟作为时间单位，所有一级速率常数的单位为 $\\text{min}^{-1}$。\n- 为了保证可复现性，使用固定的种子 $1729$ 初始化一个伪随机数生成器，并按给定顺序处理测试集。\n- 如果采样的指数步长将超过 $T_{\\mathrm{total}}$，则将贡献裁剪至 $T_{\\mathrm{total}}$ 并终止模拟。\n- 仅在 $\\langle P \\rangle = 0$ 的情况下返回一个“非数值”(not-a-number)；否则，以小数值形式报告一个有限的 $\\mathrm{CV}$ (不带百分号)。\n\n测试集：\n- 对 $k_d \\in \\{0.05, 0.1, 0.2, 0.5, 1.0\\}\\ \\text{min}^{-1}$ 计算 $\\mathrm{CV}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含与指定顺序的 $k_d$ 值相对应的估计 $\\mathrm{CV}$ 值，格式为一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是一个浮点数。结果应表示为纯小数（无单位），可选择四舍五入，但输出中不应包含任何单位或百分号。",
            "solution": "我们将蛋白质的随机合成与降解建模为一个连续时间马尔可夫链 (CTMC)，其状态为数对 $(m,P)$，其中 $m$ 是信使核糖核酸 (mRNA) 的拷贝数，$P$ 是蛋白质的拷贝数。其基本原理是适用于充分混合系统的化学主方程，以及随机动力学的质量作用定律。反应如下：\n- 转录：$\\varnothing \\xrightarrow{k_{\\mathrm{tx}}} m$，倾向为 $a_1 = k_{\\mathrm{tx}}$，是一个与 $m$ 和 $P$ 无关的零级过程。\n- mRNA 降解：$m \\xrightarrow{k_{\\mathrm{dm}}} \\varnothing$，倾向为 $a_2 = k_{\\mathrm{dm}}\\,m$。\n- 翻译：$m \\xrightarrow{k_{\\mathrm{tl}}} m + P$，倾向为 $a_3 = k_{\\mathrm{tl}}\\,m$。\n- 蛋白质降解：$P \\xrightarrow{k_d} \\varnothing$，倾向为 $a_4 = k_d\\,P$。\n\n这些形式基于经过充分检验的事实：对于一级过程，单位时间内发生反应的概率与反应物分子的数量成正比；对于零级源，其倾向为常数。\n\nGillespie 的随机模拟算法 (SSA) 源于以下观察：在总倾向为 $a_0 = a_1 + a_2 + a_3 + a_4$ 的 CTMC 中，到下一个事件的等待时间 $\\Delta t$ 服从速率为 $a_0$ 的指数分布，即 $\\Delta t \\sim \\mathrm{Exp}(a_0)$，而下一个反应的身份是根据与各反应倾向成正比的概率选择的。具体来说，如果 $u_1 \\sim \\mathrm{Uniform}(0,1)$ 和 $u_2 \\sim \\mathrm{Uniform}(0,1)$ 是独立的，则\n$$\n\\Delta t = -\\frac{\\ln(u_1)}{a_0},\n$$\n反应索引是满足 $\\sum_{i=1}^{j} a_i \\ge u_2\\,a_0$ 的最小整数 $j$。\n\n为了估计稳态下的变异系数，我们使用适用于可数状态空间上不可约 CTMC 的遍历性定理：时间平均收敛于系综平均。鉴于所用参数范围内的生成（转录和翻译）和消亡（降解）倾向确保了系统的稳定性，该过程是正常返的且具有遍历性。因此，在剔除初始瞬态动力学（预烧）后，对于一个足够长的观察窗口，可以近似计算\n$$\n\\langle P \\rangle \\approx \\frac{1}{T_{\\mathrm{obs}}} \\int_{T_{\\mathrm{burn}}}^{T_{\\mathrm{total}}} P(t)\\,dt,\\quad\n\\langle P^2 \\rangle \\approx \\frac{1}{T_{\\mathrm{obs}}} \\int_{T_{\\mathrm{burn}}}^{T_{\\mathrm{total}}} P(t)^2\\,dt,\n$$\n其中 $T_{\\mathrm{obs}} = T_{\\mathrm{total}} - T_{\\mathrm{burn}}$。在反应事件之间，状态是恒定的，因此积分可简化为分段常数片段的总和。如果一个事件间隔 $[t, t+\\Delta t)$ 与 $[T_{\\mathrm{burn}}, T_{\\mathrm{total}}]$ 部分重叠，我们将其裁剪到 $[\\max(t, T_{\\mathrm{burn}}), \\min(t+\\Delta t, T_{\\mathrm{total}})]$，以仅累加观察窗口内的贡献。这确保了当事件跨越预烧边界以及当最终事件超过 $T_{\\mathrm{total}}$ 时，时间加权的正确性。\n\n对于一个固定的 $k_d$，算法流程如下：\n1. 初始化时间 $t \\leftarrow 0$，状态 $(m,P) \\leftarrow (0,0)$，以及用于在 $[T_{\\mathrm{burn}}, T_{\\mathrm{total}}]$ 上计算 $\\int P(t)\\,dt$ 和 $\\int P(t)^2\\,dt$ 的累加器 $S_1 \\leftarrow 0$，$S_2 \\leftarrow 0$。\n2. 当 $t  T_{\\mathrm{total}}$ 时，计算倾向\n$$\na_1 = k_{\\mathrm{tx}},\\quad a_2 = k_{\\mathrm{dm}}\\,m,\\quad a_3 = k_{\\mathrm{tl}}\\,m,\\quad a_4 = k_d\\,P,\\quad a_0 = a_1 + a_2 + a_3 + a_4.\n$$\n3. 使用 $u_1 \\sim \\mathrm{Uniform}(0,1)$ 采样 $\\Delta t = -\\ln(u_1)/a_0$ 并设置 $t_{\\mathrm{next}} = t + \\Delta t$。\n4. 在重叠区间 $[\\max(t, T_{\\mathrm{burn}}), \\min(t_{\\mathrm{next}}, T_{\\mathrm{total}})]$ 上累加时间加权矩：设置 $\\Delta t_{\\mathrm{eff}} = \\max\\{0, \\min(t_{\\mathrm{next}}, T_{\\mathrm{total}}) - \\max(t, T_{\\mathrm{burn}})\\}$ 并更新 $S_1 \\leftarrow S_1 + P\\,\\Delta t_{\\mathrm{eff}}$，$S_2 \\leftarrow S_2 + P^2\\,\\Delta t_{\\mathrm{eff}}$。\n5. 如果 $t_{\\mathrm{next}} \\ge T_{\\mathrm{total}}$，则终止循环；否则，通过采样 $u_2 \\sim \\mathrm{Uniform}(0,1)$ 并找到满足 $\\sum_{i=1}^{j} a_i \\ge u_2\\,a_0$ 的最小 $j$ 来选择反应。根据反应 $j$ 更新 $(m,P)$，并设置 $t \\leftarrow t_{\\mathrm{next}}$。\n6. 循环结束后，计算 $T_{\\mathrm{obs}} = T_{\\mathrm{total}} - T_{\\mathrm{burn}}$，$\\langle P \\rangle \\approx S_1/T_{\\mathrm{obs}}$，$\\langle P^2 \\rangle \\approx S_2/T_{\\mathrm{obs}}$，$\\mathrm{Var}(P) \\approx \\langle P^2 \\rangle - \\langle P \\rangle^2$，最后如果 $\\langle P \\rangle > 0$，则计算 $\\mathrm{CV} \\approx \\sqrt{\\mathrm{Var}(P)}/\\langle P \\rangle$。\n\n我们对测试集 $k_d \\in \\{0.05, 0.1, 0.2, 0.5, 1.0\\}\\ \\text{min}^{-1}$ 中的每个 $k_d$ 重复此过程。伪随机数生成器使用种子 $1729$ 初始化一次，以确保确定性输出。最终程序打印单行，其中包含与指定顺序的 $k_d$ 值相对应的 $\\mathrm{CV}$ 值列表，格式为方括号内的逗号分隔列表，即 $[r_1,r_2,r_3,r_4,r_5]$，使用无单位的小数表示。\n\n关于 $k_d$ 的定性预期：随着 $k_d$ 的增加，稳态均值 $\\langle P \\rangle$ 通常会降低，因为蛋白质被清除得更快；而相对波动可能会增加，反映了蛋白质寿命缩短和翻译爆发的时间平均效应减弱。因此，变异系数 $\\mathrm{CV}$ 倾向于随 $k_d$ 增大而上升，尽管确切值由 $k_{\\mathrm{tx}}$、$k_{\\mathrm{dm}}$、$k_{\\mathrm{tl}}$ 和 $k_d$ 之间的相互作用决定，并在此通过 SSA 和时间加权稳态平均进行数值估计。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gillespie_cv_for_kd(k_tx, k_dm, k_tl, k_d, T_total, T_burn, rng):\n    \"\"\"\n    Simulate one SSA trajectory for the two-stage gene expression model\n    and estimate steady-state CV of protein copy number using time-weighted averages.\n    \"\"\"\n    # State variables: mRNA (m) and Protein (p)\n    m = 0\n    p = 0\n    t = 0.0\n\n    # Accumulators for time-weighted moments over [T_burn, T_total]\n    sum_P_dt = 0.0\n    sum_P2_dt = 0.0\n\n    # Observation window length\n    T_obs = T_total - T_burn\n    if T_obs = 0:\n        raise ValueError(\"Observation window must be positive (T_total > T_burn).\")\n\n    while t  T_total:\n        # Propensities\n        a1 = k_tx                 # transcription\n        a2 = k_dm * m             # mRNA degradation\n        a3 = k_tl * m             # translation\n        a4 = k_d * p              # protein degradation\n\n        a0 = a1 + a2 + a3 + a4\n        # a0 should be strictly positive because a1 = k_tx > 0\n        if a0 == 0.0:\n            # No further reactions can occur; fill the rest of the window at current state\n            # Accumulate any remaining time within the observation window\n            start = max(t, T_burn)\n            end = T_total\n            if end > start:\n                dur = end - start\n                sum_P_dt += p * dur\n                sum_P2_dt += (p * p) * dur\n            break\n\n        # Sample next reaction time\n        u1 = rng.random()\n        # Guard against log(0)\n        while u1 == 0.0:\n            u1 = rng.random()\n        dt = -np.log(u1) / a0\n        t_next = t + dt\n\n        # Accumulate time-weighted moments for the portion within [T_burn, T_total]\n        start = max(t, T_burn)\n        end = min(t_next, T_total)\n        if end > start:\n            dur = end - start\n            sum_P_dt += p * dur\n            sum_P2_dt += (p * p) * dur\n\n        if t_next >= T_total:\n            # Reached or exceeded the observation horizon\n            t = t_next\n            break\n\n        # Select which reaction occurs\n        u2 = rng.random() * a0\n        threshold = a1\n        if u2  threshold:\n            # Transcription: ∅ -> m\n            m += 1\n        else:\n            threshold += a2\n            if u2  threshold:\n                # mRNA degradation: m -> ∅\n                # m >= 1 is guaranteed by a2 being positive only when m > 0\n                m -= 1\n            else:\n                threshold += a3\n                if u2  threshold:\n                    # Translation: m -> m + P\n                    p += 1\n                else:\n                    # Protein degradation: P -> ∅\n                    # p >= 1 is guaranteed by a4 being positive only when p > 0\n                    p -= 1\n\n        t = t_next\n\n    # Compute time-averaged moments and CV\n    mean_P = sum_P_dt / T_obs\n    mean_P2 = sum_P2_dt / T_obs\n    var_P = mean_P2 - mean_P * mean_P\n    if var_P  0.0:\n        # Numerical guard against tiny negative due to floating errors\n        var_P = 0.0\n    if mean_P > 0.0:\n        cv = np.sqrt(var_P) / mean_P\n    else:\n        cv = float('nan')\n    return float(cv)\n\ndef solve():\n    # Fixed parameters (time unit: minutes; rates in min^-1)\n    k_tx = 1.0   # transcription rate\n    k_dm = 0.2   # mRNA degradation rate\n    k_tl = 5.0   # translation rate per mRNA\n\n    # Test suite for k_d (protein degradation rate)\n    test_cases = [0.05, 0.1, 0.2, 0.5, 1.0]\n\n    # Simulation times\n    T_total = 2000.0  # minutes\n    T_burn = 500.0    # minutes\n\n    # Reproducible RNG\n    rng = np.random.default_rng(1729)\n\n    results = []\n    for kd in test_cases:\n        cv = gillespie_cv_for_kd(k_tx, k_dm, k_tl, kd, T_total, T_burn, rng)\n        # Round to 6 decimal places for stable, concise output\n        results.append(f\"{cv:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}