{
    "hands_on_practices": [
        {
            "introduction": "剂量-反应关系是药理学和系统生物学的基石。这项实践将引导你建立一个简单的信号级联模型，以分析推导半数有效浓度（$EC_{50}$），这是衡量信号效力的关键指标。通过这个练习，你将巩固对质量作用动力学和稳态分析的理解，并将理论模型与可衡量的生物学输出联系起来 。",
            "id": "3880102",
            "problem": "对一个细胞因子-受体信号模块进行建模，以推导其稳态剂量-反应关系，并计算半数有效浓度 (EC50)。考虑一个浓度为 $L$（纳摩尔，nM）的胞外细胞因子，它与总浓度为 $R_T$（nM）的细胞表面受体结合。结合比例为 $1:1$，遵循质量作用动力学，其平衡解离常数为 $K_D$（nM），定义为 $K_D = k_{\\mathrm{off}}/k_{\\mathrm{on}}$。令 $C$（nM）表示稳态下受体-配体复合物的浓度。下游信号传导被建模为一个总浓度为 $S_T$（nM）的转录因子（例如，Janus kinase/signal transducer and activator of transcription (JAK-STAT)）的激活过程。活性形式 $S^*$（nM）通过复合物依赖的激活过程产生，并通过一级失活过程被移除。假设在充分混合条件下，结合与信号传导均处于稳态。使用以下基本依据：(i) 质量作用结合与受体守恒，(ii) 质量作用激活与底物守恒，以及 (iii) 一级失活。\n\n定义与使用的模型组件：\n- 结合与守恒：受体-配体结合是可逆的，且受体总量守恒。在稳态下，使用质量作用平衡和受体守恒来建立 $C$ 与 $L$、$R_T$ 和 $K_D$ 之间的关系，不假设整体胞外池中的配体被耗尽。\n- 下游激活与失活：$S^*$ 的激活与复合物 $C$ 和可用的非活性库 $(S_T - S^*)$ 成正比，激活速率常数为 $k_a$（每纳摩尔每秒，$\\mathrm{nM}^{-1}\\mathrm{s}^{-1}$）。失活是一级反应，速率常数为 $k_d$（每秒，$\\mathrm{s}^{-1}$）。对 $S^*$ 施加稳态条件。\n\n任务：\n1. 基于上述基本依据，推导出一个稳态映射 $L \\mapsto S^*(L)$，该映射仅依赖于 $L$、$K_D$、$R_T$、$S_T$、$k_a$ 和 $k_d$。不要引入任何额外的唯象假设。\n2. 将半数有效浓度 (EC50) 定义为唯一的 $L$ 值（单位为纳摩尔），使得 $S^*(L)$ 等于相对于 $L$ 的最小至最大稳态激活动態范围的一半。在该模型中，$S^*$ 在 $L \\to 0$ 时趋近于最小值，在 $L \\to \\infty$ 时趋近于最大值。使用这些极限来精确地形式化 EC50 条件，并从第一性原理求解 EC50。\n3. 实现一个程序，为下面测试套件中的每个参数集计算 EC50（单位为纳摩尔）并返回这些值。该程序不得要求任何用户输入，并且必须确定性地运行。\n\n物理和数值单位：\n- 浓度 $L$、$R_T$、$S_T$ 和 $K_D$ 的单位为纳摩尔 (nM)。\n- 时间单位为秒 (s)。\n- 速率常数 $k_a$ 的单位为 $\\mathrm{nM}^{-1}\\mathrm{s}^{-1}$，$k_d$ 的单位为 $\\mathrm{s}^{-1}$。\n- 将最终的 EC50 值以纳摩尔 (nM) 为单位表示为浮点数。\n\n测试套件（每行列出 $(K_D, R_T, S_T, k_a, k_d)$）：\n- 情况 A（一般“理想”路径）：$K_D = 10$，$R_T = 100$，$S_T = 100$，$k_a = 0.01$，$k_d = 0.1$。\n- 情况 B（边界接近线性下游模块，满足 $k_a R_T \\ll k_d$）：$K_D = 10$，$R_T = 100$，$S_T = 100$，$k_a = 10^{-5}$，$k_d = 0.1$。\n- 情况 C（强下游饱和，满足 $k_a R_T \\gg k_d$）：$K_D = 50$，$R_T = 50$，$S_T = 200$，$k_a = 0.1$，$k_d = 0.01$。\n\n你的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[result1,result2,result3]$），其中每个 $resulti$ 是对应测试用例的 EC50 值，单位为纳摩尔，表示为浮点数。",
            "solution": "首先验证问题，确保其科学上合理、良定且客观。\n\n### 步骤 1：提取已知条件\n\n-   **变量与浓度：**\n    -   $L$：胞外细胞因子浓度 (nM)。\n    -   $R_T$：细胞表面受体总浓度 (nM)。\n    -   $C$：稳态下受体-配体复合物浓度 (nM)。\n    -   $S_T$：转录因子总库浓度 (nM)。\n    -   $S^*$：稳态下活化转录因子浓度 (nM)。\n\n-   **常数：**\n    -   $K_D$：配体-受体结合的平衡解离常数 (nM)，定义为 $K_D = k_{\\mathrm{off}}/k_{\\mathrm{on}}$。\n    -   $k_a$：$S^*$ 的激活速率常数 (nM$^{-1}$s$^{-1}$)。\n    -   $k_d$：$S^*$ 的失活速率常数 (s$^{-1}$)。\n\n-   **模型原理（基本依据）：**\n    1.  **结合与守恒：** 结合是平衡状态下的可逆质量作用（$L + R \\rightleftharpoons C$）。总受体库是守恒的（$R_T = [R] + C$，其中 $[R]$ 是游离受体浓度）。不假设配体耗尽。\n    2.  **下游激活与守恒：** $S^*$ 的激活是质量作用，与 $C$ 和非活性底物库 $(S_T - S^*)$ 成正比。总底物库是守恒的（$S_T = [S] + S^*$，其中 $[S]$ 是非活性底物浓度）。\n    3.  **失活：** $S^*$ 的失活是一个一级过程。\n\n-   **任务：**\n    1.  推导稳态映射 $L \\mapsto S^*(L)$。\n    2.  推导半数有效浓度 (EC50)，其定义为唯一的 $L$ 值，使得 $S^*(L)$ 等于其从 $L \\to 0$ 到 $L \\to \\infty$ 的动态范围的一半。\n    3.  实现一个程序，为给定的参数集计算 EC50。\n\n-   **测试套件：**\n    -   情况 A：$(K_D, R_T, S_T, k_a, k_d) = (10, 100, 100, 0.01, 0.1)$。\n    -   情况 B：$(K_D, R_T, S_T, k_a, k_d) = (10, 100, 100, 10^{-5}, 0.1)$。\n    -   情况 C：$(K_D, R_T, S_T, k_a, k_d) = (50, 50, 200, 0.1, 0.01)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述描述了一个典型的两阶段信号通路，这是系统生物学中的一个常见基序。该建模方法依赖于基本的、公认的原理：用于双分子相互作用的质量作用动力学和用于单分子衰变的一级动力学，并结合了组分总浓度的守恒定律。对于构建生物化学网络的常微分方程 (ODE) 模型而言，这些是标准的、科学上合理的假设，并且其稳态分析是一个常规程序。该问题是自洽的，提供了所有必要的参数和定义。EC50 的定义是剂量-反应分析中的标准定义。参数和单位在量纲上是一致的。该问题是客观的，不含非科学性主张。\n\n### 步骤 3：结论与行动\n\n该问题是有效的。它具有科学依据，是良定的、客观的。我将继续进行推导和求解。\n\n### 求解过程推导\n\n**第 1 部分：稳态复合物浓度 $C(L)$ 的推导**\n\n配体 $L$ 与受体 $R$ 结合形成复合物 $C$ 的过程由反应 $L + R \\rightleftharpoons C$ 描述。在平衡状态下，解离常数 $K_D$ 由下式给出：\n$$K_D = \\frac{[R][L]}{[C]}$$\n游离受体 $[R]$ 的浓度和复合物 $C$ 的浓度受到总受体守恒 $R_T$ 的约束：\n$$R_T = [R] + C \\implies [R] = R_T - C$$\n将 $[R]$ 的表达式代入 $K_D$ 方程：\n$$K_D = \\frac{(R_T - C)L}{C}$$\n我们求解这个代数方程，以得到 $C$ 作为 $L$ 的函数：\n$$K_D C = L R_T - L C$$\n$$C (K_D + L) = L R_T$$\n$$C(L) = \\frac{R_T L}{K_D + L}$$\n这是标准的 Langmuir 等温线或 Michaelis-Menten 结合方程，它将受体-配体复合物的稳态浓度与配体浓度关联起来。\n\n**第 2 部分：稳态活化底物浓度 $S^*(C)$ 的推导**\n\n底物 $S$ 活化为其活性形式 $S^*$ 的过程由复合物 $C$ 催化，而 $S^*$ 通过一级过程失活。$S^*$ 的形成速率为 $v_{\\text{form}} = k_a [S] C$，失活速率为 $v_{\\text{deact}} = k_d S^*$。总底物库 $S_T$ 是守恒的：\n$$S_T = [S] + S^* \\implies [S] = S_T - S^*$$\n在稳态下，形成速率等于失活速率：\n$$v_{\\text{form}} = v_{\\text{deact}}$$\n$$k_a (S_T - S^*) C = k_d S^*$$\n我们求解此方程，以得到 $S^*$ 作为 $C$ 的函数：\n$$k_a S_T C - k_a S^* C = k_d S^*$$\n$$k_a S_T C = S^* (k_d + k_a C)$$\n$$S^*(C) = \\frac{k_a S_T C}{k_d + k_a C}$$\n该方程描述了下游信号 $S^*$ 如何依赖于活性复合物 $C$ 的浓度。\n\n**第 3 部分：完整剂量-反应曲线 $S^*(L)$ 的推导**\n\n为了获得完整的剂量-反应关系，我们将第 1 部分中 $C(L)$ 的表达式代入第 2 部分中 $S^*(C)$ 的表达式：\n$$S^*(L) = \\frac{k_a S_T \\left( \\frac{R_T L}{K_D + L} \\right)}{k_d + k_a \\left( \\frac{R_T L}{K_D + L} \\right)}$$\n为简化起见，我们将分子和分母同乘以 $(K_D + L)$：\n$$S^*(L) = \\frac{k_a S_T R_T L}{k_d(K_D + L) + k_a R_T L}$$\n将分母中含 $L$ 的项合并：\n$$S^*(L) = \\frac{k_a S_T R_T L}{k_d K_D + k_d L + k_a R_T L} = \\frac{k_a S_T R_T L}{k_d K_D + (k_d + k_a R_T)L}$$\n这就是稳态剂量-反应曲线 $S^*(L)$ 的最终表达式。\n\n**第 4 部分：EC50 的推导**\n\nEC50 是指反应 $S^*$ 达到其最大可能变化一半时的配体浓度 $L$。首先，我们确定最小和最大反应。\n\n最小反应 $S_{\\text{min}}^*$ 发生在 $L=0$ 时：\n$$S_{\\text{min}}^* = S^*(0) = \\frac{k_a S_T R_T (0)}{k_d K_D + (k_d + k_a R_T)(0)} = 0$$\n最大反应 $S_{\\text{max}}^*$ 发生在极限 $L \\to \\infty$ 时：\n$$S_{\\text{max}}^* = \\lim_{L \\to \\infty} S^*(L) = \\lim_{L \\to \\infty} \\frac{k_a S_T R_T L}{k_d K_D + (k_d + k_a R_T)L}$$\n为了计算该极限，我们将分子和分母同除以 $L$：\n$$S_{\\text{max}}^* = \\lim_{L \\to \\infty} \\frac{k_a S_T R_T}{\\frac{k_d K_D}{L} + (k_d + k_a R_T)} = \\frac{k_a S_T R_T}{0 + k_d + k_a R_T} = \\frac{k_a S_T R_T}{k_d + k_a R_T}$$\nEC50 由条件 $S^*(\\text{EC50}) = \\frac{1}{2}(S_{\\text{max}}^* - S_{\\text{min}}^*) + S_{\\text{min}}^*$ 定义。由于 $S_{\\text{min}}^* = 0$，该条件简化为：\n$$S^*(\\text{EC50}) = \\frac{1}{2} S_{\\text{max}}^*$$\n$$\\frac{k_a S_T R_T (\\text{EC50})}{k_d K_D + (k_d + k_a R_T)(\\text{EC50})} = \\frac{1}{2} \\left( \\frac{k_a S_T R_T}{k_d + k_a R_T} \\right)$$\n假设系统是功能性的（$k_a, S_T, R_T$ 均非零），我们可以消去等式两边的项 $k_a S_T R_T$：\n$$\\frac{\\text{EC50}}{k_d K_D + (k_d + k_a R_T)(\\text{EC50})} = \\frac{1}{2(k_d + k_a R_T)}$$\n交叉相乘得到：\n$$2(k_d + k_a R_T)(\\text{EC50}) = k_d K_D + (k_d + k_a R_T)(\\text{EC50})$$\n从等式两边减去 $(k_d + k_a R_T)(\\text{EC50})$：\n$$(k_d + k_a R_T)(\\text{EC50}) = k_d K_D$$\n最后，求解 EC50 得到确定性公式：\n$$\\text{EC50} = \\frac{k_d K_D}{k_d + k_a R_T}$$\n这个简洁的结果表明，系统的半数有效浓度取决于受体-配体结合亲和力（$K_D$），并受到下游信号传导参数（$k_a, k_d, R_T$）的调节。值得注意的是，信号底物的总库 $S_T$ 会影响最大反应的幅度（$S_{\\text{max}}^*$），但不会影响 EC50。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the EC50 for a cytokine signaling model based on a derived formula.\n\n    The model consists of a two-stage signaling cascade:\n    1. Receptor-ligand binding: L + R -> C\n    2. Substrate activation: S + C -> S* + C and S* -> S\n\n    The derived steady-state half-maximal effective concentration (EC50) is given by:\n    EC50 = (k_d * K_D) / (k_d + k_a * R_T)\n\n    where:\n    K_D : Dissociation constant (nM)\n    R_T : Total receptor concentration (nM)\n    S_T : Total substrate concentration (nM) - Note: not in the final EC50 formula\n    k_a : Activation rate constant (nM^-1 s^-1)\n    k_d : Deactivation rate constant (s^-1)\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple represents (K_D, R_T, S_T, k_a, k_d).\n    test_cases = [\n        # Case A (general “happy path”)\n        (10.0, 100.0, 100.0, 0.01, 0.1),\n        # Case B (boundary approaching linear downstream module)\n        (10.0, 100.0, 100.0, 1e-5, 0.1),\n        # Case C (strong downstream saturation)\n        (50.0, 50.0, 200.0, 0.1, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        K_D, R_T, S_T, k_a, k_d = case\n\n        # The parameter S_T is part of the problem definition but analytically\n        # cancels out from the EC50 calculation, as it only affects the\n        # magnitude of the response, not the concentration at which\n        # the half-maximal response is achieved.\n\n        # Calculate the numerator of the EC50 formula.\n        numerator = k_d * K_D\n        \n        # Calculate the denominator of the EC50 formula.\n        denominator = k_d + k_a * R_T\n\n        # Compute the EC50.\n        # Check for division by zero, although physically unlikely in this model.\n        if denominator == 0:\n            # A denominator of zero would imply k_d=0 and (k_a=0 or R_T=0),\n            # which is a physically degenerate system. We can assign inf or nan.\n            # Based on the physics, if k_d=0, the system never deactivates,\n            # so any non-zero L would eventually lead to S_max. EC50 would be 0.\n            # If denominator is zero AND k_d is also 0, EC50 is 0/0.\n            # Let's stick to the formula and normal parameter regimes.\n            ec50 = np.nan \n        else:\n            ec50 = numerator / denominator\n        \n        results.append(ec50)\n\n    # Format the results into the required string format.\n    # e.g., \"[result1,result2,result3]\"\n    output_string = \"[\" + \",\".join(map(str, results)) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "信号网络不仅仅是简单的信息中继；反馈回路可以创造出复杂的动态行为，如开关（双稳态）和生物钟（振荡）。这项实践将挑战你通过模拟一个包含正负反馈的模型，使用数值方法来探索和识别这些涌现特性 。它强调了网络拓扑与动态功能之间的深刻联系，并让你掌握通过计算实验来探究复杂系统行为的方法。",
            "id": "3880126",
            "problem": "考虑一个最小的、基于机理的细胞因子信号网络模型，该模型捕捉了导致双稳态的正反馈和导致振荡的负反馈。该网络涉及信号转导与转录激活因子 (STAT)、细胞因子信号抑制因子 (SOCS) 和细胞因子受体的激活。令 $R(t)$ 表示活化受体的无量纲分数，$S(t)$ 表示活性 STAT（磷酸化和二聚化）的无量纲分数，以及 $X(t)$ 表示 SOCS 的无量纲浓度。令 $S_{\\mathrm{tot}}$ 为可用于激活的无量纲 STAT 总量。其动力学由一个常微分方程 (ODE) 系统建模，该系统源于质量作用和希尔型动力学：\n$$\n\\frac{dR}{dt} \\;=\\; k_{r0} \\;+\\; k_{rp}\\,\\frac{S(t)^{n}}{K_{r}^{n} + S(t)^{n}} \\;-\\; k_{rd}\\,R(t) \\;-\\; k_{rx}\\,X(t)\\,R(t),\n$$\n$$\n\\frac{dS}{dt} \\;=\\; k_{s}\\,R(t)\\,\\big(S_{\\mathrm{tot}} - S(t)\\big) \\;-\\; k_{sd}\\,S(t),\n$$\n$$\n\\frac{dX}{dt} \\;=\\; k_{x}\\,\\frac{S(t)^{m}}{K_{x}^{m} + S(t)^{m}} \\;-\\; k_{xd}\\,X(t).\n$$\n在这些方程中，$k_{r0}$ 代表由恒定细胞因子输入引起的基础受体激活，$k_{rp}$ 是从 $S(t)$ 到受体激活的正反馈强度（例如，通过受体上调或自分泌增强），$k_{rd}$ 是受体失活，$k_{rx}$ 捕捉了 SOCS 依赖的受体抑制，$k_{s}$ 和 $k_{sd}$ 分别是 STAT 的激活和失活速率，而 $k_{x}$ 和 $k_{xd}$ 分别是 SOCS 的合成和降解速率。希尔系数 $n$ 和 $m$ 反映了反馈过程中的协同性。希尔函数为 $H_{r}(S) = \\dfrac{S^{n}}{K_{r}^{n} + S^{n}}$ 和 $H_{x}(S) = \\dfrac{S^{m}}{K_{x}^{m} + S^{m}}$。时间单位为分钟。所有状态变量和阈值均为无量纲。所有速率常数的单位均为每分钟。\n\n从质量作用动力学、STAT 总量守恒以及由希爾函数建模的可饱和转录激活出发，已知正反馈可以在相同参数和输入下产生多个稳定稳态（双稳态），而足够强且延迟的负反馈可以使稳态失稳并产生持续振荡。您的任务是实现一个程序，对每个提供的参数集，确定：\n- 系统在恒定参数下是否表现出双稳态，操作性地定义为从不同初始条件达到的至少两个不同的渐近稳定平衡点的存在。\n- 系统是否表现出持续振荡，操作性地定义为在瞬态过程之后，轨迹收敛到一个在 $S(t)$ 上具有非零振幅的非平凡极限环。\n\n必须通过直接数值模拟，并遵循以下标准化程序和阈值来做出判断，以确保在不同编程语言间的通用性：\n\n模拟与检测协议：\n- 使用 $S_{\\mathrm{tot}} = 1$。\n- 对每个参数集，在时间范围 $[0, T]$（其中 $T = 300$ 分钟）上模拟 ODE 系统，使用一个包含 $N = 3001$ 个点的均匀评估网格。\n- 使用初始条件 $R(0) \\in \\{0, 0.5, 1.5\\}$、$S(0) \\in \\{0, 0.5\\,S_{\\mathrm{tot}}, S_{\\mathrm{tot}}\\}$ 和 $X(0) \\in \\{0, 0.5, 1.5\\}$ 的笛卡尔积来探测多个吸引盆。\n- 将模拟的最后四分之一时间定义为最终分析窗口，即 $t \\in [0.75\\,T, T]$。对于任何轨迹，计算振幅 $A_{R}$、$A_{S}$ 和 $A_{X}$，即 $R(t)$、$S(t)$ 和 $X(t)$ 在此窗口内的最大值与最小值之差。\n- 平衡点检测：如果 $\\max\\{A_{R}, A_{S}, A_{X}\\}  \\epsilon_{\\mathrm{eq}}$（其中 $\\epsilon_{\\mathrm{eq}} = 10^{-3}$），则将该轨迹分类为收敛到一个平衡点。通过窗口内的均值向量记录该平衡点，并使用欧几里得距离容差 $\\epsilon_{\\mathrm{cluster}} = 0.02$ 对来自不同初始条件的平衡点进行聚类；距离超过 $\\epsilon_{\\mathrm{cluster}}$ 的平衡点被认为是不同的。\n- 振荡检测：如果在最终窗口内 $A_{S} \\ge \\epsilon_{\\mathrm{osc}}$（其中 $\\epsilon_{\\mathrm{osc}} = 0.05$），并且最后四分之一窗口的振幅至少是前一四分之一窗口振幅的 $0.8$ 倍（以排除衰减的瞬态），并且在模拟的后半部分 $S(t)$ 至少有三个不同的局部最大值，则将该轨迹分类为表现出持续振荡。\n- 案例级别决策：对于一个参数集，如果在初始条件网格中识别出至少两个不同的平衡点，则声明为双稳态。如果至少有一个初始条件根据上述标准产生持续振荡，则声明为振荡。\n\n测试套件：\n使用 $S_{\\mathrm{tot}} = 1$ 评估以下四个参数集（速率单位为每分钟，阈值为无量纲）：\n- 案例 1（标称负反馈，无正反馈）：\n$k_{r0} = 0.1$, $k_{rp} = 0.0$, $K_{r} = 0.3$, $n = 2$, $k_{rd} = 0.5$, $k_{rx} = 0.2$, $k_{s} = 2.0$, $k_{sd} = 1.0$, $k_{x} = 0.5$, $K_{x} = 0.4$, $m = 2$, $k_{xd} = 0.3$。\n- 案例 2（强正反馈，弱负反馈）：\n$k_{r0} = 0.05$, $k_{rp} = 1.5$, $K_{r} = 0.2$, $n = 4$, $k_{rd} = 0.4$, $k_{rx} = 0.05$, $k_{s} = 2.0$, $k_{sd} = 1.0$, $k_{x} = 0.2$, $K_{x} = 0.3$, $m = 3$, $k_{xd} = 0.3$。\n- 案例 3（强负反馈，慢 SOCS 和高协同性）：\n$k_{r0} = 0.05$, $k_{rp} = 0.3$, $K_{r} = 0.3$, $n = 3$, $k_{rd} = 0.4$, $k_{rx} = 1.5$, $k_{s} = 3.0$, $k_{sd} = 1.0$, $k_{x} = 2.0$, $K_{x} = 0.5$, $m = 10$, $k_{xd} = 0.05$。\n- 案例 4（具有快速失活和降解的边界案例）：\n$k_{r0} = 0.2$, $k_{rp} = 3.0$, $K_{r} = 0.2$, $n = 4$, $k_{rd} = 2.0$, $k_{rx} = 0.5$, $k_{s} = 5.0$, $k_{sd} = 3.0$, $k_{x} = 0.5$, $K_{x} = 0.5$, $m = 2$, $k_{xd} = 1.5$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表包含在方括号中，每个元素是对应各案例顺序的两个布尔值的列表 $[\\text{bistability}, \\text{oscillation}]$。例如，输出应类似于 $[[False,False],[True,False],[False,True],[False,False]]$。",
            "solution": "用户提供了一个生物医学系统建模领域中明确定义的问题，特别关注细胞因子信号网络的动力学。任务是确定给定常微分方程 (ODE) 模型的特定参数集是否会导致双稳态或持续振荡。\n\n### 问题阐述与模型\n\n系统的动力学由一组三个耦合的非线性 ODE 描述，其状态变量为 $R(t)$、$S(t)$ 和 $X(t)$，分别代表活化受体、活性 STAT 和 SOCS 蛋白的无量纲浓度。\n\n控制方程如下：\n$$\n\\frac{dR}{dt} \\;=\\; k_{r0} \\;+\\; k_{rp}\\,\\frac{S(t)^{n}}{K_{r}^{n} + S(t)^{n}} \\;-\\; k_{rd}\\,R(t) \\;-\\; k_{rx}\\,X(t)\\,R(t)\n$$\n$$\n\\frac{dS}{dt} \\;=\\; k_{s}\\,R(t)\\,\\big(S_{\\mathrm{tot}} - S(t)\\big) \\;-\\; k_{sd}\\,S(t)\n$$\n$$\n\\frac{dX}{dt} \\;=\\; k_{x}\\,\\frac{S(t)^{m}}{K_{x}^{m} + S(t)^{m}} \\;-\\; k_{xd}\\,X(t)\n$$\n\n在这里，各项模拟了基础激活 ($k_{r0}$)、从活性 STAT 到受体激活的协同正反馈（带有希尔系数 $n$ 的 $k_{rp}$ 项）、一阶失活 ($k_{rd}R$)、SOCS 介导的抑制 ($k_{rx}XR$)、与受体活性成比例的 STAT 激活 ($k_s R (S_{\\mathrm{tot}}-S)$) 和失活 ($k_{sd}S$)，以及协同的 STAT 诱导的 SOCS 合成（带有希尔系数 $m$ 的 $k_x$ 项）及其降解 ($k_{xd}X$)。该模型结构具有机理合理性，包含了关键的调控基序：一个能够产生双稳态的正反馈回路 ($S \\rightarrow R \\rightarrow S$)，以及一个能够产生振荡的负反馈回路 ($S \\rightarrow X \\dashv R \\rightarrow S$)。\n\n### 算法设计与实现\n\n解决策略是执行 ODE 系统的直接数值模拟，并根据问题陈述中提供的详细协议分析轨迹的长期行为。这种方法避免了对这个三维非线性系统进行解析分岔分析的复杂性。\n\n1.  **数值积分**：解决方案的核心是一个数值 ODE 求解器。我们将使用 `scipy.integrate.solve_ivp`，一个鲁棒的自适应步长求解器，在 $T = 300$ 分钟的时间范围内对系统动力学进行积分。解将在一个包含 $N = 3001$ 个点的细粒度均匀时间网格上进行评估，以确保像振荡这样的动态特征能被很好地解析。\n\n2.  **状态空间探索**：为检测多个稳定状态（双稳态），从状态空间的不同点开始模拟至关重要。协议指定了一个由 $3 \\times 3 \\times 3 = 27$ 个初始条件组成的网格，该网格由 $R(0)$ 和 $X(0)$ 的 $\\{0, 0.5, 1.5\\}$ 与 $S(0)$ 的 $\\{0, 0.5 S_{\\mathrm{tot}}, S_{\\mathrm{tot}}\\}$（其中 $S_{\\mathrm{tot}}=1$）的笛卡尔积构成。该网格为潜在的吸引盆提供了广泛的采样。\n\n3.  **渐近行为分析**：对于每个轨迹，我们在模拟时间的最后四分之一，即 $t \\in [225, 300]$，分析其行为，以确保初始瞬态已经衰减，系统已稳定到其渐近状态（一个平衡点或一个极限环）。\n\n4.  **平衡点检测与聚类**：如果所有状态变量（$R, S, X$）在最终分析窗口中的振幅都低于一个小阈值 $\\epsilon_{\\mathrm{eq}} = 10^{-3}$，则该轨迹被分类为收敛到一个平衡点。稳态值记录为该窗口内状态向量的平均值。在模拟完所有初始条件后，收集到的平衡点集合使用欧几里得距离容差 $\\epsilon_{\\mathrm{cluster}} = 0.02$ 进行聚类。如果发现两个或更多个不同的平衡点簇，则该参数集被分类为表现出**双稳态**。\n\n5.  **振荡检测**：一个轨迹是否被分类为振荡，基于一个旨在识别振幅显著的持续、非衰减振荡的三部分准则：\n    a. 在最终窗口中，活性 STAT 的振幅 $A_S$ 必须不可忽略 ($A_S \\ge \\epsilon_{\\mathrm{osc}} = 0.05$)。\n    b. 振荡必须是持续的，而不是衰减的瞬态。这通过要求最后四分之一窗口的振幅至少是前一四分之一窗口（$t \\in [150, 225]$）振幅的 $80\\%$ 来检查。\n    c. 振荡必须具有周期性特征，这通过要求在模拟的后半部分（$t \\in [150, 300]$）中 $S(t)$ 至少有三个不同的局部最大值来验证。\n    如果给定参数集的 27 个轨迹中有任何一个满足所有这三个标准，则该参数集被分类为表现出**振荡**。\n\n6.  **案例评估**：将整个程序系统地应用于四个提供的参数集中的每一个。对每个案例，我们确定双稳态和振荡的两个布尔标志，并将结果汇总为指定的输出格式。这种基于原理的、基于模拟的方法为表征给定非线性系统的复杂动力学提供了一种鲁棒且可验证的方法。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the cytokine signaling network problem.\n    It iterates through four parameter sets, analyzes each for bistability and\n    oscillations according to the specified protocol, and prints the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Nominal negative feedback, no positive feedback\n        {\n            \"k_r0\": 0.1, \"k_rp\": 0.0, \"K_r\": 0.3, \"n\": 2, \"k_rd\": 0.5, \"k_rx\": 0.2,\n            \"k_s\": 2.0, \"k_sd\": 1.0, \"k_x\": 0.5, \"K_x\": 0.4, \"m\": 2, \"k_xd\": 0.3\n        },\n        # Case 2: Strong positive feedback, weak negative feedback\n        {\n            \"k_r0\": 0.05, \"k_rp\": 1.5, \"K_r\": 0.2, \"n\": 4, \"k_rd\": 0.4, \"k_rx\": 0.05,\n            \"k_s\": 2.0, \"k_sd\": 1.0, \"k_x\": 0.2, \"K_x\": 0.3, \"m\": 3, \"k_xd\": 0.3\n        },\n        # Case 3: Strong negative feedback with slow SOCS and high cooperativity\n        {\n            \"k_r0\": 0.05, \"k_rp\": 0.3, \"K_r\": 0.3, \"n\": 3, \"k_rd\": 0.4, \"k_rx\": 1.5,\n            \"k_s\": 3.0, \"k_sd\": 1.0, \"k_x\": 2.0, \"K_x\": 0.5, \"m\": 10, \"k_xd\": 0.05\n        },\n        # Case 4: Boundary case with fast deactivation and degradation\n        {\n            \"k_r0\": 0.2, \"k_rp\": 3.0, \"K_r\": 0.2, \"n\": 4, \"k_rd\": 2.0, \"k_rx\": 0.5,\n            \"k_s\": 5.0, \"k_sd\": 3.0, \"k_x\": 0.5, \"K_x\": 0.5, \"m\": 2, \"k_xd\": 1.5\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = analyze_parameter_set(params)\n        results.append(result)\n\n    # Format the final output as a Python literal string without spaces\n    print(repr(results).replace(\" \", \"\"))\n\ndef analyze_parameter_set(params):\n    \"\"\"\n    Analyzes a single parameter set for bistability and oscillations.\n    \"\"\"\n    S_tot = 1.0\n    T_final = 300.0\n    N_points = 3001\n    t_span = [0, T_final]\n    t_eval = np.linspace(t_span[0], t_span[1], N_points)\n    \n    epsilon_eq = 1e-3\n    epsilon_cluster = 0.02\n    epsilon_osc = 0.05\n\n    def model(t, y, p):\n        R, S, X = y\n        hr_s = S**p[\"n\"] / (p[\"K_r\"]**p[\"n\"] + S**p[\"n\"]) if S > 0 else 0\n        hx_s = S**p[\"m\"] / (p[\"K_x\"]**p[\"m\"] + S**p[\"m\"]) if S > 0 else 0\n\n        # Ensure state variables are non-negative for biological realism\n        R, S, X = max(0, R), max(0, S), max(0,X)\n\n        dRdt = p[\"k_r0\"] + p[\"k_rp\"] * hr_s - p[\"k_rd\"] * R - p[\"k_rx\"] * X * R\n        dSdt = p[\"k_s\"] * R * (S_tot - S) - p[\"k_sd\"] * S\n        dXdt = p[\"k_x\"] * hx_s - p[\"k_xd\"] * X\n        return [dRdt, dSdt, dXdt]\n\n    ic_R = [0, 0.5, 1.5]\n    ic_S = [0, 0.5 * S_tot, S_tot]\n    ic_X = [0, 0.5, 1.5]\n    initial_conditions = list(itertools.product(ic_R, ic_S, ic_X))\n\n    found_equilibria = []\n    is_oscillatory = False\n\n    # Define analysis window indices\n    final_quarter_start_idx = int(N_points * 0.75)\n    third_quarter_start_idx = int(N_points * 0.5)\n    \n    for y0 in initial_conditions:\n        sol = solve_ivp(model, t_span, y0, args=(params,), t_eval=t_eval, method='RK45', dense_output=True)\n        \n        R_sol, S_sol, X_sol = sol.y\n        \n        # Final analysis window (last quarter)\n        R_final = R_sol[final_quarter_start_idx:]\n        S_final = S_sol[final_quarter_start_idx:]\n        X_final = X_sol[final_quarter_start_idx:]\n        \n        A_R = np.ptp(R_final)\n        A_S = np.ptp(S_final)\n        A_X = np.ptp(X_final)\n        \n        # Equilibrium detection\n        if max(A_R, A_S, A_X)  epsilon_eq:\n            eq_point = np.array([np.mean(R_final), np.mean(S_final), np.mean(X_final)])\n            found_equilibria.append(eq_point)\n            continue # Move to next initial condition\n            \n        # Oscillation detection (only if not an equilibrium and not already found)\n        if not is_oscillatory:\n            # Condition 1: Amplitude threshold\n            if A_S >= epsilon_osc:\n                # Condition 2: Non-decaying amplitude\n                S_preceding = S_sol[third_quarter_start_idx:final_quarter_start_idx]\n                A_S_preceding = np.ptp(S_preceding) if len(S_preceding) > 0 else 0\n                if A_S_preceding == 0 or A_S >= 0.8 * A_S_preceding:\n                    # Condition 3: At least 3 peaks in the final half\n                    S_half = S_sol[third_quarter_start_idx:]\n                    num_peaks = 0\n                    for i in range(1, len(S_half) - 1):\n                        if S_half[i] > S_half[i-1] and S_half[i] > S_half[i+1]:\n                            num_peaks += 1\n                    \n                    if num_peaks >= 3:\n                        is_oscillatory = True\n\n    # Bistability decision via clustering\n    is_bistable = False\n    if len(found_equilibria) >= 2:\n        unique_equilibria = []\n        for eq in found_equilibria:\n            is_new = True\n            for unique_eq in unique_equilibria:\n                dist = np.linalg.norm(eq - unique_eq)\n                if dist = epsilon_cluster:\n                    is_new = False\n                    break\n            if is_new:\n                unique_equilibria.append(eq)\n        if len(unique_equilibria) >= 2:\n            is_bistable = True\n            \n    return [is_bistable, is_oscillatory]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "细胞信号传导存在两种主要模式：渐变式（模拟）响应和全或无式（数字）开关。这项最后的实践将探讨这些不同的单细胞行为如何转化为群体水平的响应，并引入细胞间异质性的关键作用 。你将对这两种模式进行建模和比较，从而深入了解细胞群体是如何编码和处理信息的。",
            "id": "3880109",
            "problem": "一个极简的种群水平模型被用于对比在由细胞因子激活的Janus激酶-信号转导与转录激活子 (JAK-STAT) 通路中，数字信号与模拟信号的传导方式。该模型必须从质量作用配体-受体结合和一个通用的超敏转移函数出发。在单细胞水平上，假设对于浓度为 $L$（单位：纳摩尔，nM）的配体，存在以下两种信号转导模式：\n- 模拟模式：下游归一化输出 $y_{\\mathrm{A}}$ 是受体占据率的一个渐变函数，它源于质量作用结合和有效协同性。\n- 数字模式：由于超敏正反馈，每个细胞的下游归一化输出 $y_{\\mathrm{D}}$ 是二元的；在种群水平上，激活阈值的异质性产生分数响应。\n\n使用以下基本依据和定义：\n1) 在准稳态下，受体 $R$ 和配体 $L$ 的质量作用结合形成结合复合物 $RL$，其解离常数为 $K_{\\mathrm{d}}$（单位：纳摩尔，nM）。被占据的受体分数为\n$$\n\\theta(L;K_{\\mathrm{d}}) \\equiv \\frac{L}{K_{\\mathrm{d}} + L}.\n$$\n2) 在模拟模式下，假设归一化的单细胞输出为\n$$\ny_{\\mathrm{A}}(L;K_{\\mathrm{d}},n) \\equiv \\left(\\theta(L;K_{\\mathrm{d}})\\right)^{n},\n$$\n其中 $n$（无单位）是编码JAK-STAT级联反应中协同性的有效Hill系数，且最大响应被归一化为 $1$。\n3) 在数字模式下，假设每个细胞有一个配体阈值 $T$（单位：纳摩尔，nM），当 $L \\ge T$ 时单细胞响应为 $1$，否则为 $0$。在整个种群中，$T$ 服从参数为 $\\mu_T$ 和 $\\sigma_T$（两者均无单位）的对数正态分布，即 $\\ln T \\sim \\mathcal{N}(\\mu_T,\\sigma_T^2)$。激活细胞的种群分数为\n$$\np_{\\mathrm{on}}(L;\\mu_T,\\sigma_T) \\equiv \\mathbb{P}(T \\le L) = \\Phi\\!\\left(\\frac{\\ln L - \\mu_T}{\\sigma_T}\\right),\n$$\n对于 $L>0$，其中 $\\Phi(\\cdot)$ 是标准正态累积分布函数 (CDF)。定义 $p_{\\mathrm{on}}(0;\\mu_T,\\sigma_T)\\equiv 0$。\n4) 由于二元的单细胞响应和单位归一化，数字模式下的种群归一化平均输出等于 $y_{\\mathrm{D}}^{\\mathrm{pop}}(L;\\mu_T,\\sigma_T) \\equiv p_{\\mathrm{on}}(L;\\mu_T,\\sigma_T)$。在模拟情况下，由于假设所有细胞都是相同的，因此模拟模式下的种群归一化平均输出等于 $y_{\\mathrm{A}}(L;K_{\\mathrm{d}},n)$。\n\n任务：实现一个程序，对指定的参数集，计算每组的两个量：\n- 数字种群分数 $p_{\\mathrm{on}}(L;\\mu_T,\\sigma_T)$（无单位，在 $[0,1]$ 区间内）。\n- 模拟归一化输出 $y_{\\mathrm{A}}(L;K_{\\mathrm{d}},n)$（无单位，在 $[0,1]$ 区间内）。\n\n数值要求：\n- 当 $L=0$ 时，根据上述定义返回 $p_{\\mathrm{on}}=0$ 和 $y_{\\mathrm{A}}=0$。\n- 对 $\\ln(\\cdot)$ 使用自然对数。\n- 所有输出必须四舍五入到六位小数，并以小数形式表示（而非百分比）。\n- 本问题不涉及角度，因此不需要角度单位。\n- 配体和解离常数必须解释为纳摩尔 (nM)。输出是无量纲的。\n\n测试套件（每个案例是一个元组 $(L, K_{\\mathrm{d}}, n, \\mu_T, \\sigma_T)$，其中 $L$ 和 $K_{\\mathrm{d}}$ 的单位是纳摩尔 (nM)）：\n- 案例 1：($L=10$, $K_{\\mathrm{d}}=5$, $n=2$, $\\mu_T=\\ln(8)$, $\\sigma_T=0.4$)\n- 案例 2：($L=0$, $K_{\\mathrm{d}}=5$, $n=2$, $\\mu_T=\\ln(1)$, $\\sigma_T=0.5$)\n- 案例 3：($L=10000$, $K_{\\mathrm{d}}=50$, $n=2$, $\\mu_T=\\ln(100)$, $\\sigma_T=0.5$)\n- 案例 4：($L=5$, $K_{\\mathrm{d}}=50$, $n=4$, $\\mu_T=\\ln(5)$, $\\sigma_T=0.2$)\n- 案例 5：($L=20$, $K_{\\mathrm{d}}=20$, $n=1$, $\\mu_T=\\ln(20)$, $\\sigma_T=1.0$)\n- 案例 6：($L=15$, $K_{\\mathrm{d}}=15$, $n=3$, $\\mu_T=\\ln(15)$, $\\sigma_T=0.05$)\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的案例结果列表，不含空格。每个案例结果本身必须是一个形式为 $[p_{\\mathrm{on}},y_{\\mathrm{A}}]$ 的双元素列表。\n- 例如，两个案例的输出应如下所示：`[[$p_{\\mathrm{on}}$,$y_{\\mathrm{A}}$],[0.000000,1.000000]]`。",
            "solution": "我们根据质量作用结合和种群异质性的第一性原理来构建所需的计算。\n\n首先，考虑准稳态质量作用动力学下的配体-受体结合。设 $R$ 表示未结合的受体，$L$ 表示配体，$RL$ 表示结合的复合物。可逆反应 $R + L \\rightleftharpoons RL$ 的结合速率常数为 $k_{\\mathrm{on}}$，解离速率常数为 $k_{\\mathrm{off}}$，在平衡时得到解离常数 $K_{\\mathrm{d}} \\equiv k_{\\mathrm{off}}/k_{\\mathrm{on}}$。在配体浓度为 $L$ 时，被占据的受体分数为\n$$\n\\theta(L;K_{\\mathrm{d}}) = \\frac{L}{K_{\\mathrm{d}} + L},\n$$\n该公式由总受体守恒和正反向通量平衡的标准推导得出。\n\n在模拟信号传导模式中，我们采用一个经过广泛验证的从占据率到下游输出的唯象映射，该映射通过一个有效Hill系数 $n$ 来捕捉超敏性。归一化输出（最大值等于 $1$）为\n$$\ny_{\\mathrm{A}}(L;K_{\\mathrm{d}},n) = \\left(\\theta(L;K_{\\mathrm{d}})\\right)^{n} = \\left(\\frac{L}{K_{\\mathrm{d}} + L}\\right)^{n}.\n$$\n这个函数在 $L$ 上是单调递增的，界于 $0$ 和 $1$ 之间，并通过指数 $n$ 编码了模拟渐变响应。当 $L=0$ 时，显然 $\\theta=0$，因此 $y_{\\mathrm{A}}=0$。\n\n在数字信号传导模式中，单细胞的输入-输出映射是全或无的，这是由Janus激酶-信号转导与转录激活子 (JAK-STAT) 级联反应中的超敏正反馈驱动的。在单个细胞水平上，定义一个以配体单位（纳摩尔，nM）表示的阈值 $T$，细胞响应当且仅当 $L \\ge T$。在整个种群中，这个阈值并非完全相同，而是由于细胞间在受体丰度、激酶活性、磷酸酶活性和染色质状态等方面的差异而变化。经验表明，许多生物学参数近似服从对数正态分布，这促使我们做出假设 $\\ln T \\sim \\mathcal{N}(\\mu_T,\\sigma_T^2)$。那么，在浓度 $L$ 下处于开启状态的细胞分数就是阈值不高于 $L$ 的概率：\n$$\np_{\\mathrm{on}}(L;\\mu_T,\\sigma_T) = \\mathbb{P}(T \\le L) = \\mathbb{P}(\\ln T \\le \\ln L) = \\Phi\\!\\left(\\frac{\\ln L - \\mu_T}{\\sigma_T}\\right),\n$$\n对于 $L>0$，其中 $\\Phi(\\cdot)$ 是标准正态累积分布函数 (CDF)。在 $L=0$ 时，激活概率必须为零，因为对数正态随机变量 $T$ 是严格为正的；因此我们定义 $p_{\\mathrm{on}}(0;\\mu_T,\\sigma_T)=0$。\n\n因为每个数字模式的单细胞响应要么是 $0$（关闭），要么是 $1$（开启），所以种群归一化的平均值等于开启分数：\n$$\ny_{\\mathrm{D}}^{\\mathrm{pop}}(L;\\mu_T,\\sigma_T) = p_{\\mathrm{on}}(L;\\mu_T,\\sigma_T).\n$$\n\n算法设计：\n- 对于每个测试案例 $(L,K_{\\mathrm{d}},n,\\mu_T,\\sigma_T)$，使用 $y_{\\mathrm{A}} = (L/(K_{\\mathrm{d}}+L))^{n}$ 计算模拟输出 $y_{\\mathrm{A}}(L;K_{\\mathrm{d}},n)$。当 $L=0$ 时，其值为 $0$。\n- 当 $L>0$ 时，通过将标准正态CDF应用于 $z = (\\ln L - \\mu_T)/\\sigma_T$ 来计算数字开启分数。在数值上，标准正态CDF可以使用误差函数表示为\n$$\n\\Phi(z) = \\frac{1}{2}\\left(1 + \\operatorname{erf}\\!\\left(\\frac{z}{\\sqrt{2}}\\right)\\right).\n$$\n当 $L=0$ 时，根据定义设置 $p_{\\mathrm{on}}=0$。\n- 将 $p_{\\mathrm{on}}$ 和 $y_{\\mathrm{A}}$ 都四舍五入到六位小数。\n- 将结果聚合成一个形如 $[[p_{\\mathrm{on}},y_{\\mathrm{A}}],\\dots]$ 的单行字符串，不含空格。\n\n边界情况和覆盖范围：\n- $L=0$ 的案例测试了模拟和数字输出的边界行为。\n- 极大 $L$ 值（例如 $L=10000$）的案例评估了模拟响应的饱和情况以及接近1的数字激活水平。\n- $\\mu_T = \\ln L$ 的案例测试了数字模式的中间过渡行为，其中 $\\sigma_T$ 控制陡峭度；小的 $\\sigma_T$ 近似于一个近乎确定的阈值（数字阶跃），而大的 $\\sigma_T$ 则产生一个平缓的分数响应。\n- 改变 $n$ 和 $K_{\\mathrm{d}}$ 测试了模拟灵敏度和渐变响应曲线的位置。\n\n实现的程序精确地遵循了这些步骤，使用自然对数，并准确地生成了所需的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\n\ndef normal_cdf(z: float) - float:\n    \"\"\"Standard normal CDF using the error function.\"\"\"\n    return 0.5 * (1.0 + math.erf(z / math.sqrt(2.0)))\n\ndef digital_fraction_on(L: float, mu_log_T: float, sigma_log_T: float) - float:\n    \"\"\"Compute p_on = P(T = L) where ln T ~ N(mu_log_T, sigma_log_T^2).\n    For L = 0, return 0 by definition.\n    \"\"\"\n    if L = 0.0:\n        return 0.0\n    if sigma_log_T = 0: # Avoid division by zero\n        return 1.0 if math.log(L) >= mu_log_T else 0.0\n    z = (math.log(L) - mu_log_T) / sigma_log_T\n    return normal_cdf(z)\n\ndef analog_output(L: float, Kd: float, n: float) - float:\n    \"\"\"Compute y_A = (L / (Kd + L))^n. For L = 0, returns 0.\"\"\"\n    if L = 0.0:\n        return 0.0\n    theta = L / (Kd + L)\n    return theta ** n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (L, Kd, n, mu_log_T, sigma_log_T)\n    test_cases = [\n        (10.0, 5.0, 2.0, math.log(8.0), 0.4),      # Case 1\n        (0.0, 5.0, 2.0, math.log(1.0), 0.5),       # Case 2\n        (10000.0, 50.0, 2.0, math.log(100.0), 0.5),# Case 3\n        (5.0, 50.0, 4.0, math.log(5.0), 0.2),      # Case 4\n        (20.0, 20.0, 1.0, math.log(20.0), 1.0),    # Case 5\n        (15.0, 15.0, 3.0, math.log(15.0), 0.05),   # Case 6\n    ]\n\n    # Compute results with rounding to six decimals and format with no spaces.\n    formatted_cases = []\n    for L, Kd, n, mu_log_T, sigma_log_T in test_cases:\n        p_on = digital_fraction_on(L, mu_log_T, sigma_log_T)\n        yA = analog_output(L, Kd, n)\n        # Round to six decimals and format explicitly\n        p_on_str = f\"{p_on:.6f}\"\n        yA_str = f\"{yA:.6f}\"\n        formatted_cases.append(f\"[{p_on_str},{yA_str}]\")\n\n    # Final print statement in the exact required format (no spaces).\n    print(f\"[{','.join(formatted_cases)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}