{
    "hands_on_practices": [
        {
            "introduction": "剂量-响应曲线是理解信号通路如何对不同强度的刺激做出反应的基础。然而，像半数有效浓度（$EC_{50}$）这样的关键系统特性并非一个独立的参数，而是由底层的分子相互作用决定的。这项练习将指导您从基本原理出发，为一个典型的两步信号级联推导$EC_{50}$，从而将微观动力学参数与宏观系统行为联系起来。",
            "id": "3880102",
            "problem": "建立一个细胞因子-受体信号模块模型，以推导其稳态剂量-反应关系，并计算半数有效浓度 ($EC_{50}$)。考虑一种细胞外细胞因子，其浓度为 $L$ (纳摩尔, nM)，它与总水平为 $R_T$ (nM) 的细胞表面受体结合。结合比例为 $1:1$，受质量作用动力学控制，平衡解离常数为 $K_D$ (nM)，定义为 $K_D = k_{\\mathrm{off}}/k_{\\mathrm{on}}$。令 $C$ (nM) 表示稳态时的受体-配体复合物。下游信号传导被建模为一个总库为 $S_T$ (nM) 的转录因子（例如，Janus激酶/信号转导与转录激活子 (JAK-STAT)）的激活过程。活性形式 $S^*$ (nM) 通过复合物依赖的激活过程产生，并通过一级失活过程被移除。假设结合和信号传导过程处于充分混合条件和稳态。使用以下基本依据：(i) 质量作用结合和受体守恒，(ii) 质量作用激活和底物守恒，以及 (iii) 一级失活。\n\n使用的定义和模型组件：\n- 结合与守恒：受体-配体结合是可逆的，且受体库是守恒的。在稳态下，使用质量作用平衡和受体守恒来建立 $C$ 与 $L$、$R_T$ 和 $K_D$ 之间的关系，不假设细胞外体库中的配体被消耗。\n- 下游激活与失活：$S^*$ 的激活与复合物 $C$ 和可用的非活性库 $(S_T - S^*)$ 成正比，激活速率常数为 $k_a$ (每纳摩尔每秒, $\\mathrm{nM}^{-1}\\mathrm{s}^{-1}$)。失活是一级的，速率常数为 $k_d$ (每秒, $\\mathrm{s}^{-1}$)。对 $S^*$ 施加稳态条件。\n\n任务：\n1. 基于上述基本依据，推导出一个仅依赖于 $L$、$K_D$、$R_T$、$S_T$、$k_a$ 和 $k_d$ 的稳态映射 $L \\mapsto S^*(L)$。不要引入任何额外的唯象假设。\n2. 将半数有效浓度 ($EC_{50}$) 定义为唯一的 $L$ (单位为纳摩尔)，使得 $S^*(L)$ 等于相对于 $L$ 的最小至最大稳态激活动态范围的一半。在此模型中，$S^*$ 在 $L \\to 0$ 时趋于最小值，在 $L \\to \\infty$ 时趋于最大值。使用这些极限来精确地形式化 $EC_{50}$ 条件，并从第一性原理求解 $EC_{50}$。\n3. 实现一个程序，对于下面测试套件中的每一组参数，计算以纳摩尔为单位的 $EC_{50}$ 并返回这些值。该程序不得需要任何用户输入，并且必须确定性地运行。\n\n物理和数值单位：\n- 浓度 $L$、$R_T$、$S_T$ 和 $K_D$ 的单位是纳摩尔 (nM)。\n- 时间单位是秒 (s)。\n- 速率常数 $k_a$ 的单位是 $\\mathrm{nM}^{-1}\\mathrm{s}^{-1}$，$k_d$ 的单位是 $\\mathrm{s}^{-1}$。\n- 将最终的 $EC_{50}$ 值以纳摩尔 (nM) 为单位表示为浮点数。\n\n测试套件 (每行列出 $(K_D, R_T, S_T, k_a, k_d)$)：\n- 情况 A (一般“理想路径”)：$K_D = 10$, $R_T = 100$, $S_T = 100$, $k_a = 0.01$, $k_d = 0.1$。\n- 情况 B (边界情况，接近线性的下游模块，其中 $k_a R_T \\ll k_d$)：$K_D = 10$, $R_T = 100$, $S_T = 100$, $k_a = 10^{-5}$, $k_d = 0.1$。\n- 情况 C (强下游饱和，其中 $k_a R_T \\gg k_d$)：$K_D = 50$, $R_T = 50$, $S_T = 200$, $k_a = 0.1$, $k_d = 0.01$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result1,result2,result3]$），其中每个 $resulti$ 是相应测试用例的 $EC_{50}$ 值，单位为纳摩尔，表示为浮点数。",
            "solution": "首先验证问题，以确保其科学上合理、良定且客观。\n\n### 步骤 1：提取已知条件\n\n-   **变量和浓度：**\n    -   $L$：细胞外细胞因子浓度 (nM)。\n    -   $R_T$：细胞表面受体总浓度 (nM)。\n    -   $C$：稳态下受体-配体复合物浓度 (nM)。\n    -   $S_T$：转录因子总库浓度 (nM)。\n    -   $S^*$：稳态下活化转录因子浓度 (nM)。\n\n-   **常数：**\n    -   $K_D$：配体-受体结合的平衡解离常数 (nM)，定义为 $K_D = k_{\\mathrm{off}}/k_{\\mathrm{on}}$。\n    -   $k_a$：$S^*$ 的激活速率常数 (nM$^{-1}$s$^{-1}$)。\n    -   $k_d$：$S^*$ 的失活速率常数 (s$^{-1}$)。\n\n-   **模型原理 (基本依据)：**\n    1.  **结合与守恒：** 结合是可逆的质量作用平衡 ($L + R \\rightleftharpoons C$)。受体总库是守恒的 ($R_T = [R] + C$，其中 $[R]$ 是游离受体浓度)。不假设配体被消耗。\n    2.  **下游激活与守恒：** $S^*$ 的激活是质量作用过程，与 $C$ 和非活性底物库 $(S_T - S^*)$ 成正比。底物总库是守恒的 ($S_T = [S] + S^*$，其中 $[S]$ 是非活性底物浓度)。\n    3.  **失活：** $S^*$ 的失活是一级过程。\n\n-   **任务：**\n    1.  推导稳态映射 $L \\mapsto S^*(L)$。\n    2.  推导半数有效浓度 ($EC_{50}$)，定义为唯一的 $L$，在该浓度下 $S^*(L)$ 为其动态范围 (从 $L \\to 0$ 到 $L \\to \\infty$) 的一半。\n    3.  实现一个程序，为给定的参数集计算 $EC_{50}$。\n\n-   **测试套件：**\n    -   情况 A: $(K_D, R_T, S_T, k_a, k_d) = (10, 100, 100, 0.01, 0.1)$。\n    -   情况 B: $(K_D, R_T, S_T, k_a, k_d) = (10, 100, 100, 10^{-5}, 0.1)$。\n    -   情况 C: $(K_D, R_T, S_T, k_a, k_d) = (50, 50, 200, 0.1, 0.01)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述描述了一个经典的两阶段信号通路，这是系统生物学中的一个常见基序。该建模方法依赖于基本且公认的原理：用于双分子相互作用的质量作用动力学和用于单分子衰变的一级动力学，并结合了组分总浓度的守恒定律。这些是构建生物化学网络常微分方程 (ODE) 模型的标准且科学合理的假设，对其进行稳态分析是一个常规程序。该问题是自洽的，提供了所有必要的参数和定义。$EC_{50}$ 的定义是剂量-反应分析中的标准定义。参数和单位在量纲上是一致的。该问题是客观的，不含非科学性论断。\n\n### 步骤 3：结论与行动\n\n该问题是有效的。它具有科学依据，是良定且客观的。我将继续进行推导和求解。\n\n### 解的推导\n\n**第 1 部分：稳态复合物浓度 $C(L)$ 的推导**\n\n配体 $L$ 与受体 $R$ 结合形成复合物 $C$ 的过程由反应 $L + R \\rightleftharpoons C$ 描述。在平衡状态下，解离常数 $K_D$ 由下式给出：\n$$K_D = \\frac{[R][L]}{[C]}$$\n游离受体浓度 $[R]$ 和复合物浓度 $C$ 受总受体守恒 $R_T$ 的约束：\n$$R_T = [R] + C \\implies [R] = R_T - C$$\n将 $[R]$ 的表达式代入 $K_D$ 方程：\n$$K_D = \\frac{(R_T - C)L}{C}$$\n我们求解这个关于 $L$ 的函数 $C$ 的代数方程：\n$$K_D C = L R_T - L C$$\n$$C (K_D + L) = L R_T$$\n$$C(L) = \\frac{R_T L}{K_D + L}$$\n这是标准的 Langmuir 等温线或 Michaelis-Menten 结合方程，它将受体-配体复合物的稳态浓度与配体浓度联系起来。\n\n**第 2 部分：稳态活化底物浓度 $S^*(C)$ 的推导**\n\n底物 $S$ 活化为其活性形式 $S^*$ 的过程由复合物 $C$ 催化，而 $S^*$ 通过一级过程失活。$S^*$ 的生成速率为 $v_{\\text{form}} = k_a [S] C$，失活速率为 $v_{\\text{deact}} = k_d S^*$。底物总库 $S_T$ 是守恒的：\n$$S_T = [S] + S^* \\implies [S] = S_T - S^*$$\n在稳态下，生成速率等于失活速率：\n$$v_{\\text{form}} = v_{\\text{deact}}$$\n$$k_a (S_T - S^*) C = k_d S^*$$\n我们求解这个关于 $C$ 的函数 $S^*$：\n$$k_a S_T C - k_a S^* C = k_d S^*$$\n$$k_a S_T C = S^* (k_d + k_a C)$$\n$$S^*(C) = \\frac{k_a S_T C}{k_d + k_a C}$$\n这个方程描述了下游信号 $S^*$ 如何依赖于活性复合物 $C$ 的浓度。\n\n**第 3 部分：完整剂量-反应曲线 $S^*(L)$ 的推导**\n\n为了获得完整的剂量-反应关系，我们将第 1 部分中 $C(L)$ 的表达式代入第 2 部分中 $S^*(C)$ 的表达式：\n$$S^*(L) = \\frac{k_a S_T \\left( \\frac{R_T L}{K_D + L} \\right)}{k_d + k_a \\left( \\frac{R_T L}{K_D + L} \\right)}$$\n为了简化，我们将分子和分母同乘以 $(K_D + L)$：\n$$S^*(L) = \\frac{k_a S_T R_T L}{k_d(K_D + L) + k_a R_T L}$$\n在分母中合并关于 $L$ 的项：\n$$S^*(L) = \\frac{k_a S_T R_T L}{k_d K_D + k_d L + k_a R_T L} = \\frac{k_a S_T R_T L}{k_d K_D + (k_d + k_a R_T)L}$$\n这就是稳态剂量-反应曲线 $S^*(L)$ 的最终表达式。\n\n**第 4 部分：EC50 的推导**\n\n$EC_{50}$ 是指响应 $S^*$ 达到其最大可能变化一半时的配体浓度 $L$。首先，我们确定最小和最大响应。\n\n最小响应 $S_{\\text{min}}^*$ 出现在 $L=0$ 时：\n$$S_{\\text{min}}^* = S^*(0) = \\frac{k_a S_T R_T (0)}{k_d K_D + (k_d + k_a R_T)(0)} = 0$$\n最大响应 $S_{\\text{max}}^*$ 出现在极限 $L \\to \\infty$ 时：\n$$S_{\\text{max}}^* = \\lim_{L \\to \\infty} S^*(L) = \\lim_{L \\to \\infty} \\frac{k_a S_T R_T L}{k_d K_D + (k_d + k_a R_T)L}$$\n为了计算该极限，我们将分子和分母同除以 $L$：\n$$S_{\\text{max}}^* = \\lim_{L \\to \\infty} \\frac{k_a S_T R_T}{\\frac{k_d K_D}{L} + (k_d + k_a R_T)} = \\frac{k_a S_T R_T}{0 + k_d + k_a R_T} = \\frac{k_a S_T R_T}{k_d + k_a R_T}$$\n$EC_{50}$ 由条件 $S^*(\\text{EC50}) = \\frac{1}{2}(S_{\\text{max}}^* - S_{\\text{min}}^*) + S_{\\text{min}}^*$ 定义。由于 $S_{\\text{min}}^* = 0$，该式简化为：\n$$S^*(\\text{EC50}) = \\frac{1}{2} S_{\\text{max}}^*$$\n$$\\frac{k_a S_T R_T (\\text{EC50})}{k_d K_D + (k_d + k_a R_T)(\\text{EC50})} = \\frac{1}{2} \\left( \\frac{k_a S_T R_T}{k_d + k_a R_T} \\right)$$\n假设系统是功能性的（$k_a, S_T, R_T$ 非零），我们可以消去等式两边的 $k_a S_T R_T$ 项：\n$$\\frac{\\text{EC50}}{k_d K_D + (k_d + k_a R_T)(\\text{EC50})} = \\frac{1}{2(k_d + k_a R_T)}$$\n交叉相乘得到：\n$$2(k_d + k_a R_T)(\\text{EC50}) = k_d K_D + (k_d + k_a R_T)(\\text{EC50})$$\n从等式两边减去 $(k_d + k_a R_T)(\\text{EC50})$：\n$$(k_d + k_a R_T)(\\text{EC50}) = k_d K_D$$\n最后，求解 $EC_{50}$ 得到确定性公式：\n$$\\text{EC50} = \\frac{k_d K_D}{k_d + k_a R_T}$$\n这个简洁的结果表明，系统的半数有效浓度取决于受体-配体结合亲和力 ($K_D$)，并受到下游信号参数 ($k_a, k_d, R_T$) 的调节。值得注意的是，信号底物的总库 $S_T$ 影响最大响应的幅度 ($S_{\\text{max}}^*$)，但不影响 $EC_{50}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the EC50 for a cytokine signaling model based on a derived formula.\n\n    The model consists of a two-stage signaling cascade:\n    1. Receptor-ligand binding: L + R -> C\n    2. Substrate activation: S + C -> S* + C and S* -> S\n\n    The derived steady-state half-maximal effective concentration (EC50) is given by:\n    EC50 = (k_d * K_D) / (k_d + k_a * R_T)\n\n    where:\n    K_D : Dissociation constant (nM)\n    R_T : Total receptor concentration (nM)\n    S_T : Total substrate concentration (nM) - Note: not in the final EC50 formula\n    k_a : Activation rate constant (nM^-1 s^-1)\n    k_d : Deactivation rate constant (s^-1)\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple represents (K_D, R_T, S_T, k_a, k_d).\n    test_cases = [\n        # Case A (general “happy path”)\n        (10.0, 100.0, 100.0, 0.01, 0.1),\n        # Case B (boundary approaching linear downstream module)\n        (10.0, 100.0, 100.0, 1e-5, 0.1),\n        # Case C (strong downstream saturation)\n        (50.0, 50.0, 200.0, 0.1, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        K_D, R_T, S_T, k_a, k_d = case\n\n        # The parameter S_T is part of the problem definition but analytically\n        # cancels out from the EC50 calculation, as it only affects the\n        # magnitude of the response, not the concentration at which\n        # the half-maximal response is achieved.\n\n        # Calculate the numerator of the EC50 formula.\n        numerator = k_d * K_D\n        \n        # Calculate the denominator of the EC50 formula.\n        denominator = k_d + k_a * R_T\n\n        # Compute the EC50.\n        # Check for division by zero, although physically unlikely in this model.\n        if denominator == 0:\n            # A denominator of zero would imply k_d=0 and (k_a=0 or R_T=0),\n            # which is a physically degenerate system. We can assign inf or nan.\n            # Based on the physics, if k_d=0, the system never deactivates,\n            # so any non-zero L would eventually lead to S_max. EC50 would be 0.\n            # If denominator is zero AND k_d is also 0, EC50 is 0/0.\n            # Let's stick to the formula and normal parameter regimes.\n            ec50 = np.nan \n        else:\n            ec50 = numerator / denominator\n        \n        results.append(ec50)\n\n    # Format the results into the required string format.\n    # e.g., \"[result1,result2,result3]\"\n    output_string = \"[\" + \",\".join(map(str, results)) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "细胞信号网络的功能远不止简单的线性响应，反馈回路等网络基序能够产生复杂的非线性行为，如开关（双稳态）和生物钟（振荡）。这项实践是一个计算实验，您将通过模拟一个包含正负反馈回路的模型，学习如何用数值方法识别这些高级动态模式。通过这项练习，您将深入理解网络结构如何决定其动态功能。",
            "id": "3880126",
            "problem": "考虑一个最小的、基于机理的细胞因子信号网络模型，该模型能够捕捉导致双稳态的正反馈和导致振荡的负反馈。该网络涉及信号转导与转录激活因子 (STAT)、细胞因子信号抑制因子 (SOCS) 以及细胞因子受体的激活。令 $R(t)$ 表示活化受体的无量纲分数，$S(t)$ 表示活性 STAT（磷酸化和二聚化后）的无量纲分数，$X(t)$ 表示 SOCS 的无量纲浓度。令 $S_{\\mathrm{tot}}$ 为可用于激活的无量纲总 STAT 量。其动力学由一个常微分方程 (ODE) 系统建模，该系统源自质量作用和希尔型动力学：\n$$\n\\frac{dR}{dt} \\;=\\; k_{r0} \\;+\\; k_{rp}\\,\\frac{S(t)^{n}}{K_{r}^{n} + S(t)^{n}} \\;-\\; k_{rd}\\,R(t) \\;-\\; k_{rx}\\,X(t)\\,R(t),\n$$\n$$\n\\frac{dS}{dt} \\;=\\; k_{s}\\,R(t)\\,\\big(S_{\\mathrm{tot}} - S(t)\\big) \\;-\\; k_{sd}\\,S(t),\n$$\n$$\n\\frac{dX}{dt} \\;=\\; k_{x}\\,\\frac{S(t)^{m}}{K_{x}^{m} + S(t)^{m}} \\;-\\; k_{xd}\\,X(t).\n$$\n在这些方程中，$k_{r0}$ 代表由恒定细胞因子输入引起的基线受体激活，$k_{rp}$ 是 $S(t)$ 对受体激活的正反馈强度（例如，通过受体上调或自分泌增强），$k_{rd}$ 是受体失活率，$k_{rx}$ 捕捉了 SOCS 依赖性的受体抑制，$k_{s}$ 和 $k_{sd}$ 是 STAT 激活和失活速率，而 $k_{x}$ 和 $k_{xd}$ 是 SOCS 合成和降解速率。希尔系数 $n$ 和 $m$ 反映了反馈过程中的协同性。希尔函数为 $H_{r}(S) = \\dfrac{S^{n}}{K_{r}^{n} + S^{n}}$ 和 $H_{x}(S) = \\dfrac{S^{m}}{K_{x}^{m} + S^{m}}$。时间以分钟为单位。所有状态变量和阈值都是无量纲的。所有速率常数的单位均为每分钟。\n\n从质量作用动力学、总 STAT 守恒以及由希尔函数建模的可饱和转录激活出发，已知正反馈可以在相同参数和输入下产生多个稳定稳态（双稳态），而足够强的延迟负反馈可以使稳态失稳并产生持续振荡。您的任务是实现一个程序，对于每个给定的参数集，确定：\n- 系统在恒定参数下是否表现出双稳态，操作上定义为从不同初始条件出发，系统达到至少两个不同的渐近稳定平衡点。\n- 系统是否表现出持续振荡，操作上定义为在瞬态过程后，轨迹收敛到一个在 $S(t)$ 上具有非零振幅的非平凡极限环。\n\n该决策必须通过直接数值模拟，并遵循以下标准化的程序和阈值，以确保在不同编程语言间的普适性：\n\n模拟与检测协议：\n- 使用 $S_{\\mathrm{tot}} = 1$。\n- 对于每个参数集，在时间范围 $[0, T]$（其中 $T = 300$ 分钟）上模拟 ODE 系统，并使用包含 $N = 3001$ 个点的均匀评估网格。\n- 使用初始条件 $R(0) \\in \\{0, 0.5, 1.5\\}$，$S(0) \\in \\{0, 0.5\\,S_{\\mathrm{tot}}, S_{\\mathrm{tot}}\\}$ 和 $X(0) \\in \\{0, 0.5, 1.5\\}$ 的笛卡尔积来探测多个吸引盆。\n- 将模拟的最后四分之一时间段，即 $t \\in [0.75\\,T, T]$，定义为最终分析窗口。对于任何轨迹，计算振幅 $A_{R}$、$A_{S}$ 和 $A_{X}$，即在此窗口内 $R(t)$、$S(t)$ 和 $X(t)$ 的最大值与最小值之差。\n- 平衡点检测：如果 $\\max\\{A_{R}, A_{S}, A_{X}\\}  \\epsilon_{\\mathrm{eq}}$（其中 $\\epsilon_{\\mathrm{eq}} = 10^{-3}$），则将该轨迹分类为收敛到一个平衡点。通过窗口内的平均向量记录该平衡点，并使用欧几里得距离容差 $\\epsilon_{\\mathrm{cluster}} = 0.02$ 对来自不同初始条件的平衡点进行聚类；分离距离大于 $\\epsilon_{\\mathrm{cluster}}$ 的平衡点被认为是不同的。\n- 振荡检测：如果在最终窗口内 $A_{S} \\ge \\epsilon_{\\mathrm{osc}}$（其中 $\\epsilon_{\\mathrm{osc}} = 0.05$），并且最后四分之一时间段的振幅至少是前一个四分之一时间段振幅的 $0.8$ 倍（以排除衰减的瞬态），并且在模拟的后半段内 $S(t)$ 至少有三个不同的局部最大值，则将该轨迹分类为表现出持续振荡。\n- 案例级决策：对于一个参数集，如果在初始条件网格中识别出至少两个不同的平衡点，则声明为双稳态。如果至少有一个初始条件根据上述标准产生持续振荡，则声明为振荡。\n\n测试套件：\n使用 $S_{\\mathrm{tot}} = 1$ 评估以下四个参数集（速率单位为每分钟，阈值为无量纲）：\n- 案例 $1$（标称负反馈，无正反馈）：\n$k_{r0} = 0.1$, $k_{rp} = 0.0$, $K_{r} = 0.3$, $n = 2$, $k_{rd} = 0.5$, $k_{rx} = 0.2$, $k_{s} = 2.0$, $k_{sd} = 1.0$, $k_{x} = 0.5$, $K_{x} = 0.4$, $m = 2$, $k_{xd} = 0.3$。\n- 案例 $2$（强正反馈，弱负反馈）：\n$k_{r0} = 0.05$, $k_{rp} = 1.5$, $K_{r} = 0.2$, $n = 4$, $k_{rd} = 0.4$, $k_{rx} = 0.05$, $k_{s} = 2.0$, $k_{sd} = 1.0$, $k_{x} = 0.2$, $K_{x} = 0.3$, $m = 3$, $k_{xd} = 0.3$。\n- 案例 $3$（具有慢速 SOCS 和高协同性的强负反馈）：\n$k_{r0} = 0.05$, $k_{rp} = 0.3$, $K_{r} = 0.3$, $n = 3$, $k_{rd} = 0.4$, $k_{rx} = 1.5$, $k_{s} = 3.0$, $k_{sd} = 1.0$, $k_{x} = 2.0$, $K_{x} = 0.5$, $m = 10$, $k_{xd} = 0.05$。\n- 案例 $4$（具有快速失活和降解的边界情况）：\n$k_{r0} = 0.2$, $k_{rp} = 3.0$, $K_{r} = 0.2$, $n = 4$, $k_{rd} = 2.0$, $k_{rx} = 0.5$, $k_{s} = 5.0$, $k_{sd} = 3.0$, $k_{x} = 0.5$, $K_{x} = 0.5$, $m = 2$, $k_{xd} = 1.5$。\n\n要求的最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应于按顺序排列的案例的两个布尔值 $[\\text{bistability}, \\text{oscillation}]$ 组成的列表。例如，输出应类似于 $[[\\mathrm{False},\\mathrm{False}],[\\mathrm{True},\\mathrm{False}],[\\mathrm{False},\\mathrm{True}],[\\mathrm{False},\\mathrm{False}]]$。",
            "solution": "用户在生物医学系统建模领域提供了一个明确定义的问题，特别关注一个细胞因子信号网络动力学。任务是确定给定常微分方程 (ODE) 模型的特定参数集是否会导致双稳态或持续振荡。\n\n### 问题阐述与模型\n\n系统的动力学由一组三个耦合的非线性 ODE 描述，其状态变量为 $R(t)$、$S(t)$ 和 $X(t)$，分别代表活化受体、活性 STAT 和 SOCS 蛋白的无量纲浓度。\n\n控制方程为：\n$$\n\\frac{dR}{dt} \\;=\\; k_{r0} \\;+\\; k_{rp}\\,\\frac{S(t)^{n}}{K_{r}^{n} + S(t)^{n}} \\;-\\; k_{rd}\\,R(t) \\;-\\; k_{rx}\\,X(t)\\,R(t)\n$$\n$$\n\\frac{dS}{dt} \\;=\\; k_{s}\\,R(t)\\,\\big(S_{\\mathrm{tot}} - S(t)\\big) \\;-\\; k_{sd}\\,S(t)\n$$\n$$\n\\frac{dX}{dt} \\;=\\; k_{x}\\,\\frac{S(t)^{m}}{K_{x}^{m} + S(t)^{m}} \\;-\\; k_{xd}\\,X(t)\n$$\n\n在这里，这些项模拟了基线激活（$k_{r0}$）、从活性 STAT 到受体激活的协同正反馈（带有希尔系数 $n$ 的 $k_{rp}$ 项）、一级失活（$k_{rd}R$）、SOCS 介导的抑制（$k_{rx}XR$）、与受体活性成比例的 STAT 激活（$k_s R (S_{\\mathrm{tot}}-S)$）和失活（$k_{sd}S$），以及协同的 STAT 诱导的 SOCS 合成（带有希尔系数 $m$ 的 $k_x$ 项）及其降解（$k_{xd}X$）。此模型结构在机理上是合理的，包含了关键的调控模体：一个能够产生双稳态的正反馈回路（$S \\rightarrow R \\rightarrow S$），以及一个能够产生振荡的负反馈回路（$S \\rightarrow X \\dashv R \\rightarrow S$）。\n\n### 算法设计与实现\n\n解决方案的策略是对 ODE 系统进行直接数值模拟，并根据问题陈述中提供的详细协议分析轨迹的长期行为。这种方法避免了对这个三维非线性系统进行解析分岔分析的复杂性。\n\n1.  **数值积分**：解决方案的核心是一个数值 ODE 求解器。我们将使用 `scipy.integrate.solve_ivp`，一个鲁棒的自适应步长求解器，在 $T = 300$ 分钟的时间范围内对系统动力学进行积分。解将在一个包含 $N = 3001$ 个点的细粒度均匀时间网格上进行评估，以确保振荡等动态特征得到良好解析。\n\n2.  **状态空间探索**：为了检测多个稳定状态（双稳态），从状态空间的不同点开始模拟至关重要。协议指定了一个由 $3 \\times 3 \\times 3 = 27$ 个初始条件组成的网格，该网格由 $R(0)$ 和 $X(0)$ 的 $\\{0, 0.5, 1.5\\}$ 与 $S(0)$ 的 $\\{0, 0.5 S_{\\mathrm{tot}}, S_{\\mathrm{tot}}\\}$（其中 $S_{\\mathrm{tot}}=1$）的笛卡尔积构成。这个网格为潜在的吸引盆提供了广泛的采样。\n\n3.  **渐近行为分析**：对于每个轨迹，我们分析其在模拟时间的最后四分之一（即 $t \\in [225, 300]$）的行为，以确保初始瞬态已经衰减，系统已经稳定到其渐近状态（一个平衡点或一个极限环）。\n\n4.  **平衡点检测与聚类**：如果所有状态变量（$R, S, X$）在最终分析窗口中的振幅都低于一个很小的阈值 $\\epsilon_{\\mathrm{eq}} = 10^{-3}$，则该轨迹被分类为收敛到一个平衡点。稳态值记录为此窗口内状态向量的平均值。在模拟完所有初始条件后，使用欧几里得距离容差 $\\epsilon_{\\mathrm{cluster}} = 0.02$ 对收集到的平衡点集合进行聚类。如果找到两个或更多个不同的平衡点簇，则该参数集被分类为表现出**双稳态**。\n\n5.  **振荡检测**：一个轨迹是否被分类为振荡，是基于一个由三部分组成的准则，旨在识别持续的、非衰减的、具有显著振幅的振荡：\n    a. 在最终窗口内，活性 STAT 的振幅 $A_S$ 必须不可忽略（$A_S \\ge \\epsilon_{\\mathrm{osc}} = 0.05$）。\n    b. 振荡必须是持续的，而不是衰减的瞬态。通过要求最后四分之一时间段的振幅至少是前一个四分之一时间段（$t \\in [150, 225]$）振幅的 $80\\%$ 来检查这一点。\n    c. 振荡必须具有周期性特征，通过要求在模拟的后半段（$t \\in [150, 300]$）内，$S(t)$ 至少有三个不同的局部最大值来验证。\n    如果给定参数集的 27 个轨迹中任何一个满足所有三个标准，则该参数集被分类为表现出**振荡**。\n\n6.  **案例评估**：此完整流程被系统地应用于所提供的四个参数集中的每一个。对于每个案例，我们确定双稳态和振荡的两个布尔标志，并将结果汇总成指定的输出格式。这种基于原则的、以模拟为基础的方法为表征给定非线性系统的复杂动力学提供了一种鲁棒且可验证的方法。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the cytokine signaling network problem.\n    It iterates through four parameter sets, analyzes each for bistability and\n    oscillations according to the specified protocol, and prints the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Nominal negative feedback, no positive feedback\n        {\n            \"k_r0\": 0.1, \"k_rp\": 0.0, \"K_r\": 0.3, \"n\": 2, \"k_rd\": 0.5, \"k_rx\": 0.2,\n            \"k_s\": 2.0, \"k_sd\": 1.0, \"k_x\": 0.5, \"K_x\": 0.4, \"m\": 2, \"k_xd\": 0.3\n        },\n        # Case 2: Strong positive feedback, weak negative feedback\n        {\n            \"k_r0\": 0.05, \"k_rp\": 1.5, \"K_r\": 0.2, \"n\": 4, \"k_rd\": 0.4, \"k_rx\": 0.05,\n            \"k_s\": 2.0, \"k_sd\": 1.0, \"k_x\": 0.2, \"K_x\": 0.3, \"m\": 3, \"k_xd\": 0.3\n        },\n        # Case 3: Strong negative feedback with slow SOCS and high cooperativity\n        {\n            \"k_r0\": 0.05, \"k_rp\": 0.3, \"K_r\": 0.3, \"n\": 3, \"k_rd\": 0.4, \"k_rx\": 1.5,\n            \"k_s\": 3.0, \"k_sd\": 1.0, \"k_x\": 2.0, \"K_x\": 0.5, \"m\": 10, \"k_xd\": 0.05\n        },\n        # Case 4: Boundary case with fast deactivation and degradation\n        {\n            \"k_r0\": 0.2, \"k_rp\": 3.0, \"K_r\": 0.2, \"n\": 4, \"k_rd\": 2.0, \"k_rx\": 0.5,\n            \"k_s\": 5.0, \"k_sd\": 3.0, \"k_x\": 0.5, \"K_x\": 0.5, \"m\": 2, \"k_xd\": 1.5\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = analyze_parameter_set(params)\n        results.append(result)\n\n    # Format the final output as a Python literal string without spaces\n    print(repr(results).replace(\" \", \"\"))\n\ndef analyze_parameter_set(params):\n    \"\"\"\n    Analyzes a single parameter set for bistability and oscillations.\n    \"\"\"\n    S_tot = 1.0\n    T_final = 300.0\n    N_points = 3001\n    t_span = [0, T_final]\n    t_eval = np.linspace(t_span[0], t_span[1], N_points)\n    \n    epsilon_eq = 1e-3\n    epsilon_cluster = 0.02\n    epsilon_osc = 0.05\n\n    def model(t, y, p):\n        R, S, X = y\n        hr_s = S**p[\"n\"] / (p[\"K_r\"]**p[\"n\"] + S**p[\"n\"]) if S >= 0 else 0\n        hx_s = S**p[\"m\"] / (p[\"K_x\"]**p[\"m\"] + S**p[\"m\"]) if S >= 0 else 0\n\n        # Ensure state variables are non-negative for biological realism\n        R, S, X = max(0, R), max(0, S), max(0,X)\n\n        dRdt = p[\"k_r0\"] + p[\"k_rp\"] * hr_s - p[\"k_rd\"] * R - p[\"k_rx\"] * X * R\n        dSdt = p[\"k_s\"] * R * (S_tot - S) - p[\"k_sd\"] * S\n        dXdt = p[\"k_x\"] * hx_s - p[\"k_xd\"] * X\n        return [dRdt, dSdt, dXdt]\n\n    ic_R = [0, 0.5, 1.5]\n    ic_S = [0, 0.5 * S_tot, S_tot]\n    ic_X = [0, 0.5, 1.5]\n    initial_conditions = list(itertools.product(ic_R, ic_S, ic_X))\n\n    found_equilibria = []\n    is_oscillatory = False\n\n    # Define analysis window indices\n    final_quarter_start_idx = int(N_points * 0.75)\n    third_quarter_start_idx = int(N_points * 0.5)\n    \n    for y0 in initial_conditions:\n        sol = solve_ivp(model, t_span, y0, args=(params,), t_eval=t_eval, method='RK45')\n        \n        R_sol, S_sol, X_sol = sol.y\n        \n        # Final analysis window (last quarter)\n        R_final = R_sol[final_quarter_start_idx:]\n        S_final = S_sol[final_quarter_start_idx:]\n        X_final = X_sol[final_quarter_start_idx:]\n        \n        A_R = np.ptp(R_final)\n        A_S = np.ptp(S_final)\n        A_X = np.ptp(X_final)\n        \n        # Equilibrium detection\n        if max(A_R, A_S, A_X)  epsilon_eq:\n            eq_point = np.array([np.mean(R_final), np.mean(S_final), np.mean(X_final)])\n            found_equilibria.append(eq_point)\n            continue # Move to next initial condition\n            \n        # Oscillation detection (only if not an equilibrium and not already found)\n        if not is_oscillatory:\n            # Condition 1: Amplitude threshold\n            if A_S >= epsilon_osc:\n                # Condition 2: Non-decaying amplitude\n                S_preceding = S_sol[third_quarter_start_idx:final_quarter_start_idx]\n                A_S_preceding = np.ptp(S_preceding)\n                if A_S_preceding == 0 or A_S >= 0.8 * A_S_preceding:\n                    # Condition 3: At least 3 peaks in the final half\n                    S_half = S_sol[third_quarter_start_idx:]\n                    num_peaks = 0\n                    for i in range(1, len(S_half) - 1):\n                        if S_half[i] > S_half[i-1] and S_half[i] > S_half[i+1]:\n                            num_peaks += 1\n                    \n                    if num_peaks >= 3:\n                        is_oscillatory = True\n\n    # Bistability decision via clustering\n    is_bistable = False\n    if len(found_equilibria) >= 2:\n        unique_equilibria = []\n        for eq in found_equilibria:\n            is_new = True\n            for unique_eq in unique_equilibria:\n                dist = np.linalg.norm(eq - unique_eq)\n                if dist  epsilon_cluster:\n                    is_new = False\n                    break\n            if is_new:\n                unique_equilibria.append(eq)\n        if len(unique_equilibria) >= 2:\n            is_bistable = True\n            \n    return [is_bistable, is_oscillatory]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "构建了信号网络模型后，一个至关重要的问题是：我们对模型参数的置信度有多高？“马虎性”（Sloppiness）是系统生物学模型中普遍存在的一个特性，它描述了某些参数组合难以从实验数据中精确确定的现象。这项练习将引导您完成模型辨识中的一个关键步骤，即学习如何运用灵敏度分析和费雪信息矩阵来量化模型参数的不确定性。",
            "id": "3880132",
            "problem": "您的任务是在生物医学系统建模的更广泛背景下，为一个简化的细胞因子信号网络模型实施定量敏感性分析和草率性评估。考虑一个细胞因子配体与其细胞表面受体结合，形成一个具有信号传导能力的复合物，该复合物驱动下游的信号转导与转录激活因子 (STAT) 的磷酸化。使用以下模型假设和定义作为基本基础：\n\n- 动力学由常微分方程 (ODE) 控制，这是一种用于生化网络建模的经过充分检验的形式体系。受体-配体相互作用遵循质量作用动力学，磷酸化/去磷酸化则使用双线性质量作用项进行建模。\n- 测量模型是加性的、独立的、且随时间具有恒定方差的高斯噪声，这是一个标准假设，它导出了最小二乘目标和费雪信息矩阵 (FIM)。\n\n模型变量和参数：\n- 变量：$R(t)$ 是游离受体的浓度，$C(t)$ 是配体结合的受体复合物的浓度，$P(t)$ 是磷酸化 STAT 的浓度。总 STAT 守恒为 $S_{\\text{tot}}$，因此未磷酸化的 STAT 为 $S(t) = S_{\\text{tot}} - P(t)$。\n- 外部配体浓度 $L$ 随时间恒定。\n- 参数（均为非负值）：$k_{\\text{on}}$ (结合，单位 $\\text{nM}^{-1}\\cdot\\text{s}^{-1}$)，$k_{\\text{off}}$ (解离，单位 $\\text{s}^{-1}$)，$k_{\\text{int}}$ (复合物内化，单位 $\\text{s}^{-1}$)，$k_{p}$ (磷酸化，单位 $\\text{nM}^{-1}\\cdot\\text{s}^{-1}$)，$k_{dp}$ (去磷酸化，单位 $\\text{s}^{-1}$)，$k_{\\text{syn}}$ (受体合成，单位 $\\text{nM}\\cdot\\text{s}^{-1}$)，$k_{\\text{deg}}$ (受体降解，单位 $\\text{s}^{-1}$)。\n- 初始条件代表受体在刺激前的平衡状态，此时没有复合物和磷酸化的 STAT：$R(0) = k_{\\text{syn}}/k_{\\text{deg}}$, $C(0) = 0$, $P(0) = 0$。\n\nODE 系统：\n$$\n\\frac{dR}{dt} = k_{\\text{syn}} - k_{\\text{deg}}\\,R - k_{\\text{on}}\\,L\\,R + k_{\\text{off}}\\,C,\n$$\n$$\n\\frac{dC}{dt} = k_{\\text{on}}\\,L\\,R - (k_{\\text{off}} + k_{\\text{int}})\\,C,\n$$\n$$\n\\frac{dP}{dt} = k_{p}\\,C\\,(S_{\\text{tot}} - P) - k_{dp}\\,P.\n$$\n\n测量：\n- 可观测量是在一组指定时间点测量的 $P(t)$。\n- 测量噪声模型是加性高斯噪声，每次测量的方差为 $\\sigma^2$ (单位 $\\text{nM}^2$) 。\n\n敏感性和草率性评估：\n- 设参数向量为 $\\theta = [k_{\\text{on}}, k_{\\text{off}}, k_{\\text{int}}, k_{p}, k_{dp}, k_{\\text{syn}}, k_{\\text{deg}}]$。\n- 将测量时间的敏感性定义为通过有限差分计算的数值偏导数 $\\partial P(t_j)/\\partial \\theta_i$。当正向和负向扰动都保持参数为非负时，使用中心差分；否则，使用单侧前向差分。对于给定的参数值 $\\theta_i$，使用扰动幅度 $\\delta_i = \\max(10^{-8}, 10^{-6}\\,\\theta_i)$。\n- 对于独立同分布的高斯噪声，费雪信息矩阵 (FIM) 由敏感性和噪声方差构建。根据 FIM 的特征谱，将草率性定义为比率 $s = \\lambda_{\\min}/\\lambda_{\\max}$，其中 $\\lambda_{\\min}$ 和 $\\lambda_{\\max}$ 分别是最小和最大的特征值。如果 $\\lambda_{\\max}$ 在数值上为零（例如，小于 $10^{-15}$），则定义 $s = 0.0$。\n- 在计算 $s$ 之前，必须通过将小的负特征值（由数值舍入误差引起）截断为零来将其视为非负值。\n\n单位：\n- 浓度单位为纳摩尔 (nM)，时间单位为秒 (s)，所有速率参数的单位都与上述 ODE 一致。最终的草率性指标 $s$ 是无量纲的，并且必须以四舍五入到六位小数的浮点数形式报告。\n\n测试套件：\n实现您的程序，为以下四种情况中的每一种计算草率性指标 $s$。在所有情况下，可观测量都是在指定时间点的 $P(t)$。\n\n- 情况 1 (正常路径)：$\\theta = [1\\times 10^{-3}, 1\\times 10^{-2}, 5\\times 10^{-3}, 2\\times 10^{-3}, 1\\times 10^{-2}, 1\\times 10^{-2}, 2\\times 10^{-3}]$, $L = 10$, $S_{\\text{tot}} = 100$, $\\sigma = 1.0$, $t = [0, 50, 100, 200, 400, 800]$。\n- 情况 2 (接近稳态的晚期时间测量)：与情况 1 相同的 $\\theta$、 $L$ 和 $S_{\\text{tot}}$，但 $\\sigma = 1.0$, $t = [1000, 2000, 4000, 8000]$。\n- 情况 3 (低配体，接近不可观测)：与情况 1 相同的 $\\theta$ 和 $S_{\\text{tot}}$，但 $L = 0.01$, $\\sigma = 1.0$, $t = [0, 50, 100, 200, 400, 800]$。\n- 情况 4 (快速结合和较慢的内化)：$\\theta = [5\\times 10^{-3}, 5\\times 10^{-3}, 1\\times 10^{-3}, 5\\times 10^{-3}, 5\\times 10^{-3}, 2\\times 10^{-2}, 1\\times 10^{-3}]$, $L = 20$, $S_{\\text{tot}} = 100$, $\\sigma = 0.5$, $t = [10, 20, 40, 80, 160, 320]$。\n\n答案规范：\n- 您的程序应生成单行输出，其中包含情况 $1$–$4$ 的草率性结果，形式为方括号内以逗号分隔的列表，每个值都四舍五入到六位小数（例如，$[0.123456,0.000789,0.000000,0.045678]$）。",
            "solution": "用户在生物医学系统建模领域提供了一个定义明确的问题。该问题具有科学依据，数学上一致，且算法上已指定。它通过了所有验证检查。\n\n该问题要求对一个简化的细胞因子信号传导常微分方程 (ODE) 模型进行定量敏感性和草率性分析。目标是为四种不同的情景计算草率性指标 $s$。该指标量化了从指定的实验数据中对模型参数的实际可辨识性。该过程涉及数值求解 ODE，使用有限差分计算参数敏感性，构建费雪信息矩阵 (FIM)，并分析其特征值谱。\n\n首先，我们将数学模型形式化。系统状态由游离受体浓度 $R(t)$、配体结合的受体复合物浓度 $C(t)$ 和磷酸化 STAT 浓度 $P(t)$ 描述。其动力学由以下 ODE 系统控制：\n$$\n\\frac{dR}{dt} = k_{\\text{syn}} - k_{\\text{deg}}\\,R - k_{\\text{on}}\\,L\\,R + k_{\\text{off}}\\,C\n$$\n$$\n\\frac{dC}{dt} = k_{\\text{on}}\\,L\\,R - (k_{\\text{off}} + k_{\\text{int}})\\,C\n$$\n$$\n\\frac{dP}{dt} = k_{p}\\,C\\,(S_{\\text{tot}} - P) - k_{dp}\\,P\n$$\n待分析的参数向量为 $\\theta = [k_{\\text{on}}, k_{\\text{off}}, k_{\\text{int}}, k_{p}, k_{dp}, k_{\\text{syn}}, k_{\\text{deg}}]$。系统由恒定的配体浓度 $L$ 刺激。总 STAT 在 $S_{\\text{tot}}$ 处守恒。时间 $t=0$ 时的初始条件代表刺激前的稳态：\n$$\nR(0) = \\frac{k_{\\text{syn}}}{k_{\\text{deg}}}, \\quad C(0) = 0, \\quad P(0) = 0\n$$\n至关重要的是要注意到 $R(0)$ 的初始条件取决于参数 $k_{\\text{syn}}$（在 $\\theta$ 中索引为 5）和 $k_{\\text{deg}}$（在 $\\theta$ 中索引为 6）。\n\n分析过程分为几个步骤：\n\n1.  **ODE 的数值解**：为了确定在指定测量时间 $t_j$ 的模型输出 $P(t)$，必须对每种情况将 ODE 系统从 $t=0$ 数值积分到最大测量时间。高精度数值求解器，例如 `SciPy` 库中的 `solve_ivp`，适合此任务。\n\n2.  **敏感性矩阵计算**：分析的核心是敏感性矩阵 $J$，它包含可观测量 $P(t)$ 相对于每个参数 $\\theta_i$ 的偏导数，并在测量时间点 $t_j$ 进行评估。该矩阵的元素为 $J_{ji} = \\frac{\\partial P(t_j)}{\\partial \\theta_i}$。这些是使用有限差分进行数值计算的。对于每个参数 $\\theta_i$，施加一个小的扰动 $\\delta_i = \\max(10^{-8}, 10^{-6}\\,\\theta_i)$。\n    - 如果可以进行对称扰动（即 $\\theta_i - \\delta_i \\ge 0$），则使用中心差分公式：\n      $$\n      \\frac{\\partial P(t_j)}{\\partial \\theta_i} \\approx \\frac{P(t_j; \\theta + \\delta_i \\mathbf{e}_i) - P(t_j; \\theta - \\delta_i \\mathbf{e}_i)}{2\\delta_i}\n      $$\n    - 否则，使用前向差分公式：\n      $$\n      \\frac{\\partial P(t_j)}{\\partial \\theta_i} \\approx \\frac{P(t_j; \\theta + \\delta_i \\mathbf{e}_i) - P(t_j; \\theta)}{\\delta_i}\n      $$\n    在这里，$P(t_j; \\theta')$ 表示使用参数向量 $\\theta'$ 计算的在时间 $t_j$ 的模型输出，而 $\\mathbf{e}_i$ 是第 $i$ 个参数的标准基向量。在计算受扰动参数向量的输出时，必须使用受扰动的 $k_{\\text{syn}}$ 和 $k_{\\text{deg}}$ 值重新评估初始条件 $R(0)$。这需要为 7 个参数中的每一个多次求解 ODE 系统。\n\n3.  **费雪信息矩阵 (FIM)**：FIM 将参数敏感性与测量不确定性联系起来。对于指定的具有方差为 $\\sigma^2$ 的加性、独立高斯噪声的模型，FIM 由以下公式给出：\n    $$\n    F = \\frac{1}{\\sigma^2} J^T J\n    $$\n    其中 $J^T$ 是敏感性矩阵的转置。FIM 是一个 $7 \\times 7$ 的对称、半正定矩阵。其特征值表征了数据为不同参数组合提供的信息量。\n\n4.  **草率性评估**：模型的草率性通过 FIM 的特征值谱进行评估。计算特征值 $\\{\\lambda_i\\}$。由于数值精度限制，任何小的负特征值都会被截断为 0。设 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$ 分别是最大和最小的非负特征值。草率性指标 $s$ 是这些特征值的比率：\n    $$\n    s = \\frac{\\lambda_{\\min}}{\\lambda_{\\max}}\n    $$\n    $s$ 的小值（即 $s \\ll 1$）表示草率性，意味着某些参数组合受到数据的约束非常弱，而其他参数组合则受到良好约束。作为一种特殊情况，如果 $\\lambda_{\\max}$ 在数值上为零（小于 $10^{-15}$），则草率性定义为 $s = 0.0$。\n\n该实现将把这个四步过程应用于提供的四个测试用例中的每一个，产生四个不同的草率性值，然后按要求进行格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef _calculate_sloppiness_for_case(case_data):\n    \"\"\"\n    Calculates the sloppiness metric for a single case.\n    \"\"\"\n    theta, L, S_tot, sigma, t_points = case_data\n    num_params = len(theta)\n    num_t_points = len(t_points)\n    \n    # Ensure t_points are sorted and include 0 if not present for integration span\n    t_points_sorted = np.sort(list(set(np.union1d([0], t_points))))\n    t_span = (0, t_points_sorted[-1])\n\n    def model_odes(t, y, current_theta, L_val, Stot_val):\n        \"\"\"Defines the system of ODEs.\"\"\"\n        R, C, P = y\n        k_on, k_off, k_int, k_p, k_dp, k_syn, k_deg = current_theta\n        \n        dR_dt = k_syn - k_deg * R - k_on * L_val * R + k_off * C\n        dC_dt = k_on * L_val * R - (k_off + k_int) * C\n        dP_dt = k_p * C * (Stot_val - P) - k_dp * P\n        \n        return [dR_dt, dC_dt, dP_dt]\n\n    def solve_for_p(params, t_eval_points):\n        \"\"\"Solves the ODE system and returns the P(t) trajectory.\"\"\"\n        k_syn, k_deg = params[5], params[6]\n        R0 = k_syn / k_deg if k_deg > 0 else 0\n        y0 = [R0, 0, 0]\n        \n        sol = solve_ivp(\n            fun=model_odes,\n            t_span=(0, t_eval_points[-1] if len(t_eval_points) > 0 else 0),\n            y0=y0,\n            args=(params, L, S_tot),\n            dense_output=True,\n            method='RK45',\n            rtol=1e-8,\n            atol=1e-10\n        )\n        \n        # Evaluate the dense solution at the specified time points\n        p_values = sol.sol(t_eval_points)[2]\n        return p_values\n\n    # Get base trajectory for P(t)\n    p_base = solve_for_p(theta, t_points)\n    \n    # Initialize sensitivity matrix\n    J = np.zeros((num_t_points, num_params))\n\n    # Calculate sensitivities for each parameter\n    for i in range(num_params):\n        theta_i = theta[i]\n        delta_i = max(1e-8, 1e-6 * theta_i)\n\n        if theta_i >= delta_i: # Use central difference\n            theta_plus = np.copy(theta)\n            theta_plus[i] += delta_i\n            p_plus = solve_for_p(theta_plus, t_points)\n            \n            theta_minus = np.copy(theta)\n            theta_minus[i] -= delta_i\n            p_minus = solve_for_p(theta_minus, t_points)\n            \n            J[:, i] = (p_plus - p_minus) / (2 * delta_i)\n        else: # Use forward difference\n            theta_plus = np.copy(theta)\n            theta_plus[i] += delta_i\n            p_plus = solve_for_p(theta_plus, t_points)\n            \n            J[:, i] = (p_plus - p_base) / delta_i\n\n    # Calculate Fisher Information Matrix (FIM)\n    FIM = (1 / sigma**2) * (J.T @ J)\n    \n    # Calculate eigenvalues\n    eigenvalues = np.linalg.eigvalsh(FIM)\n    \n    # Clip small negative eigenvalues to zero\n    eigenvalues[eigenvalues  0] = 0\n    \n    # Sort eigenvalues\n    eigenvalues = np.sort(eigenvalues)\n    \n    lambda_min = eigenvalues[0]\n    lambda_max = eigenvalues[-1]\n    \n    # Calculate sloppiness\n    if lambda_max  1e-15:\n        s = 0.0\n    else:\n        s = lambda_min / lambda_max\n        \n    return s\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (\n            np.array([1e-3, 1e-2, 5e-3, 2e-3, 1e-2, 1e-2, 2e-3]), # theta\n            10.0, # L\n            100.0, # S_tot\n            1.0, # sigma\n            np.array([0, 50, 100, 200, 400, 800]) # t\n        ),\n        # Case 2\n        (\n            np.array([1e-3, 1e-2, 5e-3, 2e-3, 1e-2, 1e-2, 2e-3]),\n            10.0,\n            100.0,\n            1.0,\n            np.array([1000, 2000, 4000, 8000])\n        ),\n        # Case 3\n        (\n            np.array([1e-3, 1e-2, 5e-3, 2e-3, 1e-2, 1e-2, 2e-3]),\n            0.01,\n            100.0,\n            1.0,\n            np.array([0, 50, 100, 200, 400, 800])\n        ),\n        # Case 4\n        (\n            np.array([5e-3, 5e-3, 1e-3, 5e-3, 5e-3, 2e-2, 1e-3]),\n            20.0,\n            100.0,\n            0.5,\n            np.array([10, 20, 40, 80, 160, 320])\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        sloppiness = _calculate_sloppiness_for_case(case)\n        results.append(sloppiness)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}