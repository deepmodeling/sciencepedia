{
    "hands_on_practices": [
        {
            "introduction": "要建立胰高血糖素的动态模型，我们首先必须了解其药代动力学——即它是如何从体内清除的。本练习专注于根据模拟单次推注实验的数据来估算清除速率常数（$k_{cl}$）和半衰期（$t_{1/2}$）。通过这项实践，您将学习到统计噪声模型的选择如何从根本上影响数据拟合策略，这是定量生物医学分析中的一个关键考量。",
            "id": "3890333",
            "problem": "您正在对单次静脉推注后，单个充分混合隔室中的血浆胰高血糖素动态进行建模。推注后，胰高血糖素被清除，无进一步的分泌或输注。使用质量平衡和守恒原理，推导血浆胰高血糖素清除速率常数的估计量，并计算其半衰期。该隔室模型假设一级清除和恒定体积。浓度单位为皮摩尔/升（$\\mathrm{pmol/L}$），时间单位为分钟。\n\n从隔室质量平衡的基本原理和生物医学系统建模中使用的标准噪声模型出发，构建一个程序，根据 $t=0$ 时推注后的血浆胰高血糖素浓度 $H(t)$ 的实验测量值，估计清除速率常数 $k_{cl}$ 和半衰期 $t_{1/2}$。在两种不同的测量噪声假设下处理数据：\n\n- 对于乘性对数正态测量噪声，在自然对数域中使用线性模型，对 $\\ln(H)$ 与时间进行普通最小二乘法 (OLS) 估计。\n- 对于方差恒定的加性高斯测量噪声，在原始尺度上使用非线性最小二乘法 (NLS) 进行估计，并对参数施加正性约束。\n\n对于下面定义的每个测试用例，您的程序必须估计以 $\\mathrm{min^{-1}}$ 为单位的 $k_{cl}$ 并计算以分钟为单位的半衰期 $t_{1/2}$。输出结果表示为浮点数，并四舍五入到六位小数。最终输出必须为单行，包含一个逗号分隔的列表，其中按顺序汇总了所有结果，格式为 $[k_{cl}^{(1)}, t_{1/2}^{(1)}, k_{cl}^{(2)}, t_{1/2}^{(2)}, \\dots]$。\n\n使用以下四个参数集的测试套件来验证您的实现。在每种情况下，将提供的数组视为观测测量值。所有时间单位均为分钟，所有浓度单位均为 $\\mathrm{pmol/L}$。\n\n测试用例 1 (乘性对数正态噪声，对数域中的普通最小二乘法):\n- 时间点 t: [$0$, $3$, $6$, $9$, $12$, $15$, $18$, $21$, $24$, $27$, $30$]\n- 测量浓度 H: [$500.000000$, $279.893934$, $146.079193$, $85.128928$, $44.905386$, $25.142469$, $13.388624$, $7.797699$, $3.951277$, $2.145555$, $1.177407$]\n- 噪声模型：对数正态 (乘性)\n\n测试用例 2 (加性高斯噪声，原始尺度上的非线性最小二乘法):\n- 时间点 t: [$0$, $5$, $10$, $15$, $20$, $25$, $30$, $35$, $40$]\n- 测量浓度 H: [$297.000000$, $185.959198$, $105.363832$, $69.939048$, $40.600585$, $22.625500$, $19.936120$, $5.059215$, $7.494691$]\n- 噪声模型：加性 (恒定方差)\n\n测试用例 3 (乘性对数正态噪声，对数域中的普通最小二乘法):\n- 时间点 t: [$0$, $0.5$, $1.0$, $1.5$, $2.0$, $2.5$, $3.0$, $3.5$, $4.0$, $4.5$, $5.0$]\n- 测量浓度 H: [$800.000000$, $490.076772$, $291.360517$, $182.074211$, $106.102862$, $65.667999$, $41.024544$, $23.432169$, $14.652510$, $9.331557$, $5.120840$]\n- 噪声模型：对数正态 (乘性)\n\n测试用例 4 (数据最少的乘性对数正态噪声，对数域中的普通最小二乘法):\n- 时间点 t: [$0$, $10$]\n- 测量浓度 H: [$250.000000$, $126.629253$]\n- 噪声模型：对数正态 (乘性)\n\n算法要求：\n- 基于质量守恒定义一个物理上合理的隔室框架。使用常微分方程 (ODE) 推理来阐述您的估计量。\n- 对于对数正态噪声情况，在对数域中估计线性关系的斜率和截距，然后反向变换以恢复参数。对于加性噪声情况，通过在原始尺度上最小化残差平方和来估计参数，并施加正性约束。\n- 根据估计的清除速率常数计算 $t_{1/2}$。\n- 程序必须生成 $k_{cl}$ (单位为 $\\mathrm{min^{-1}}$) 和 $t_{1/2}$ (单位为分钟) 的结果，每个结果都四舍五入到六位小数。\n\n最終輸出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，[$k_{cl}^{(1)}$, $t_{1/2}^{(1)}$, $k_{cl}^{(2)}$, $t_{1/2}^{(2)}$, $k_{cl}^{(3)}$, $t_{1/2}^{(3)}$, $k_{cl}^{(4)}$, $t_{1/2}^{(4)}$]）。",
            "solution": "我们从 $t=0$ 时推注后血浆胰高血糖素的隔室质量平衡开始，假设没有后续的分泌或输注。设 $H(t)$ 表示以 $\\mathrm{pmol/L}$ 为单位的血浆胰高血糖素浓度，并假设体积恒定和一级清除。质量平衡的常微分方程 (ODE) 为\n$$\n\\frac{dH}{dt} = -k_{cl}\\, H(t),\n$$\n其中 $k_{cl} > 0$ 是以 $\\mathrm{min^{-1}}$ 为单位的清除速率常数。推注后的初始条件是\n$$\nH(0) = H_0,\n$$\n其中 $H_0$ 是注射后瞬间的初始浓度。求解该线性 ODE 得到指数衰减解\n$$\nH(t) = H_0 \\, e^{-k_{cl} t}.\n$$\n半衰期的标准药代动力学定义是浓度降至其初始值一半所需的时间 $t_{1/2}$：\n$$\nH(t_{1/2}) = \\frac{H_0}{2}.\n$$\n代入解得\n$$\nH_0 \\, e^{-k_{cl} t_{1/2}} = \\frac{H_0}{2} \\quad \\Rightarrow \\quad e^{-k_{cl} t_{1/2}} = \\frac{1}{2} \\quad \\Rightarrow \\quad t_{1/2} = \\frac{\\ln(2)}{k_{cl}}.\n$$\n\n估计策略取决于测量噪声模型。我们考虑两种常见的模型：\n\n1. 乘性对数正态噪声：$M_i = H(t_i) \\, e^{\\varepsilon_i}$，其中 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$ 且在 $i$ 上独立。取自然对数，\n$$\n\\ln M_i = \\ln H_0 - k_{cl} t_i + \\varepsilon_i,\n$$\n这是一个关于 $t_i$ 的线性模型，截距为 $\\ln H_0$，斜率为 $-k_{cl}$。在此噪声模型下，对 $(t_i, \\ln M_i)$ 进行普通最小二乘法 (OLS) 可提供最大似然估计。设 $y_i = \\ln M_i$，并定义样本均值 $\\bar{t} = \\frac{1}{n}\\sum_i t_i$ 和 $\\bar{y} = \\frac{1}{n}\\sum_i y_i$。OLS 的斜率和截距为\n$$\ns = \\frac{\\sum_i (t_i - \\bar{t})(y_i - \\bar{y})}{\\sum_i (t_i - \\bar{t})^2}, \\quad b = \\bar{y} - s \\bar{t}.\n$$\n参数估计为\n$$\n\\hat{k}_{cl} = -s, \\quad \\hat{H}_0 = e^{b}, \\quad \\hat{t}_{1/2} = \\frac{\\ln(2)}{\\hat{k}_{cl}}.\n$$\n\n2. 方差恒定的加性高斯噪声：$M_i = H(t_i) + \\eta_i$，其中 $\\eta_i \\sim \\mathcal{N}(0, \\sigma^2)$ 独立。在这种情况下，取自然对数不能使误差线性化，因此合适的估计方法是在原始尺度上使用非线性最小二乘法 (NLS)。定义残差\n$$\nr_i(H_0, k_{cl}) = M_i - H_0 e^{-k_{cl} t_i},\n$$\n并最小化目标函数\n$$\nJ(H_0, k_{cl}) = \\sum_i r_i(H_0, k_{cl})^2\n$$\n约束条件为 $H_0 > 0$ 和 $k_{cl} > 0$。最小化器 $(\\hat{H}_0, \\hat{k}_{cl})$ 得到半衰期估计值\n$$\n\\hat{t}_{1/2} = \\frac{\\ln(2)}{\\hat{k}_{cl}}.\n$$\n一个实用的方法是使用对数域中的 OLS 估计值来初始化 NLS，以改善收敛性。\n\n算法摘要：\n- 对于每个测试用例，检查其噪声模型。\n- 如果噪声模型是对数正态 (乘性)，则通过对 $(t_i, \\ln M_i)$ 进行 OLS 来计算 $\\hat{k}_{cl}$ 和 $\\hat{H}_0$，然后计算 $\\hat{t}_{1/2} = \\ln(2)/\\hat{k}_{cl}$。\n- 如果噪声模型是加性 (恒定方差)，则在原始尺度上执行 NLS，边界条件为 $H_0 > 0, k_{cl} > 0$，并从对数域 OLS 的结果进行初始化，然后计算 $\\hat{t}_{1/2}$。\n- 将 $\\hat{k}_{cl}$ (单位 $\\mathrm{min^{-1}}$) 和 $\\hat{t}_{1/2}$ (单位分钟) 四舍五入到六位小数。\n- 将结果汇总为指定的单行格式。\n\n科学真实性与一致性：\n- 隔室 ODE 源于质量守恒和一级清除动力学，这是对许多肽类激素经过充分检验的假设。\n- 半衰期的定义在药代动力学中是标准的。\n- 噪声模型反映了常见的测量特性：乘性误差对应于成比例的测定变异性，而加性误差对应于恒定方差的仪器噪声。\n- 测试套件包括一个带乘性噪声的典型衰减、一个由 NLS 处理的加性噪声场景、一个快速清除的边界情况以及一个最小数据的边缘情况，从而覆盖了各种方法和数值条件。\n\n所实现的程序遵循这些原则，为每个案例选择合适的估计器，并以要求的格式打印结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef ols_log_domain(t, H):\n    \"\"\"\n    Estimate k_cl and H0 using OLS in the log-domain.\n    Model: ln(H) = b - k_cl * t + epsilon\n    Returns k_cl (>0), H0 (>0)\n    \"\"\"\n    t = np.asarray(t, dtype=float)\n    H = np.asarray(H, dtype=float)\n    if np.any(H = 0):\n        raise ValueError(\"All concentration measurements must be positive for log-domain OLS.\")\n    y = np.log(H)\n    t_mean = t.mean()\n    y_mean = y.mean()\n    denom = np.sum((t - t_mean) ** 2)\n    # Handle potential zero denominator\n    if denom == 0.0:\n        # If all t are identical (degenerate), fall back to two-point slope if possible\n        if len(t) >= 2 and t[0] != t[-1]:\n            s = (y[-1] - y[0]) / (t[-1] - t[0])\n        else:\n            s = 0.0\n    else:\n        s = np.sum((t - t_mean) * (y - y_mean)) / denom\n    b = y_mean - s * t_mean\n    k_cl = -s\n    H0 = float(np.exp(b))\n    return float(k_cl), H0\n\ndef nls_original_scale(t, H, init_kcl=None, init_H0=None):\n    \"\"\"\n    Estimate k_cl and H0 using NLS on original scale with positivity constraints.\n    Returns k_cl (>0), H0 (>0)\n    \"\"\"\n    t = np.asarray(t, dtype=float)\n    H = np.asarray(H, dtype=float)\n\n    def model_func(tt, H0, k_cl):\n        return H0 * np.exp(-k_cl * tt)\n\n    # Initial guesses from log-domain OLS\n    if init_kcl is None or init_H0 is None:\n        try:\n            k_guess, H0_guess = ols_log_domain(t, H.clip(min=1e-9))\n        except Exception:\n            # Fallback initial guesses\n            H0_guess = max(H.max(), 1.0)\n            # Use rough slope from two points if possible\n            if len(t) >= 2 and H[0] > 0 and H[-1] > 0 and t[-1] != t[0]:\n                s = (np.log(H[-1]) - np.log(H[0])) / (t[-1] - t[0])\n                k_guess = max(-s, 1e-6)\n            else:\n                k_guess = 0.1\n    else:\n        k_guess, H0_guess = init_kcl, init_H0\n\n    # Bounds ensure positivity\n    bounds = ([1e-12, 1e-12], [np.inf, np.inf])\n    try:\n        popt, _ = curve_fit(\n            model_func,\n            t,\n            H,\n            p0=[H0_guess, k_guess],\n            bounds=bounds,\n            maxfev=10000,\n        )\n        H0_hat, k_hat = popt\n    except Exception:\n        # Fallback to initial guesses if optimization fails\n        H0_hat, k_hat = H0_guess, k_guess\n\n    return float(k_hat), float(H0_hat)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"t\": [0.0, 3.0, 6.0, 9.0, 12.0, 15.0, 18.0, 21.0, 24.0, 27.0, 30.0],\n            \"H\": [500.000000, 279.893934, 146.079193, 85.128928, 44.905386, 25.142469,\n                  13.388624, 7.797699, 3.951277, 2.145555, 1.177407],\n            \"noise_model\": \"log-normal\",\n        },\n        {\n            \"t\": [0.0, 5.0, 10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0],\n            \"H\": [297.000000, 185.959198, 105.363832, 69.939048, 40.600585, 22.625500,\n                  19.936120, 5.059215, 7.494691],\n            \"noise_model\": \"additive\",\n        },\n        {\n            \"t\": [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0],\n            \"H\": [800.000000, 490.076772, 291.360517, 182.074211, 106.102862, 65.667999,\n                  41.024544, 23.432169, 14.652510, 9.331557, 5.120840],\n            \"noise_model\": \"log-normal\",\n        },\n        {\n            \"t\": [0.0, 10.0],\n            \"H\": [250.000000, 126.629253],\n            \"noise_model\": \"log-normal\",\n        },\n    ]\n\n    results = []\n    ln2 = np.log(2.0)\n\n    for case in test_cases:\n        t = case[\"t\"]\n        H = case[\"H\"]\n        noise_model = case[\"noise_model\"]\n\n        if noise_model == \"log-normal\":\n            k_hat, H0_hat = ols_log_domain(t, H)\n        elif noise_model == \"additive\":\n            # Initialize from log-domain OLS to aid NLS\n            k_init, H0_init = ols_log_domain(t, np.clip(H, 1e-9, None))\n            k_hat, H0_hat = nls_original_scale(t, H, init_kcl=k_init, init_H0=H0_init)\n        else:\n            # Unknown model: default to log-domain OLS\n            k_hat, H0_hat = ols_log_domain(t, H)\n\n        # Ensure positivity\n        k_hat = float(abs(k_hat))\n        # Compute half-life\n        t_half = ln2 / k_hat if k_hat > 0 else float('inf')\n\n        # Round to six decimals\n        results.append(round(k_hat, 6))\n        results.append(round(t_half, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在描述了清除过程之后，我们转向胰高血糖素分泌的调控。一个关键的生理机制是高血糖对胰高血糖素释放的抑制作用。这项实践要求您使用希尔型函数（Hill-type function）来模拟这种抑制关系，该函数是剂量-反应建模的基石。您将实施一个稳健的参数估计程序，首先通过模型线性化找到初始猜测值，然后通过非线性优化对其进行精确化。",
            "id": "3890363",
            "problem": "您正在使用 Hill 型抑制反应模拟血浆葡萄糖影响下的胰腺 α 细胞胰高血糖素分泌。分泌模型被假设为一个饱和抑制函数，由下式给出\n$$\ns_{H}(G) \\;=\\; \\frac{s_{0}}{1 + \\left(\\frac{G}{K_{G}}\\right)^{n}},\n$$\n其中 $s_{H}(G)$ 是在葡萄糖浓度为 $G$ 时的预测分泌量，$s_{0}$ 是在没有葡萄糖抑制时的最大分泌量，$K_{G}$ 是分泌被抑制一半时的特征葡萄糖水平，$n$ 是描述抑制协同性的 Hill 指数。这种 Hill 型形式是内分泌生理学中配体介导抑制的一种经过充分检验的经验表示，当葡萄糖快速平衡且细胞内过程达到准稳态时，它适合作为一种简化的调节定律。\n\n任务：给定测量的葡萄糖 $G$（单位为毫摩尔，mM）、观察到的分泌量 $s$（单位为任意一致的单位）以及每个数据集的已知 $s_{0}$，通过非线性最小二乘法在原始分泌尺度上拟合模型来估计参数 $n$ 和 $K_{G}$，约束条件为 $n > 0$ 和 $K_{G} > 0$。您的程序必须实现一个有原则的估计程序，该程序可以从第一性原理得到证明（例如，转换模型以获得可识别的线性关系作为初始猜测，然后在原始非线性模型上进行优化）。将 $K_{G}$ 以毫摩尔表示，$n$ 作为无量纲量。所有数值答案必须报告为小数点后保留三位的小数浮点数。\n\n您可以假设的基础出发点包括：导致 Hill 型剂量反应的准稳态受体-配体占有率、自然对数的定义，以及将最小二乘估计定义为最小化残差平方和。\n\n估计目标：对于每个数据集，计算使残差平方和最小化的参数对 $(\\hat{n}, \\hat{K}_{G})$\n$$\n\\sum_{i=1}^{N}\\left[\\frac{s_{0}}{1+\\left(\\frac{G_{i}}{K_{G}}\\right)^{n}} - s_{i}\\right]^{2},\n$$\n其中 $n > 0$ 且 $K_{G} > 0$，使用从模型的数学上合理的变换导出的初始化方法。\n\n单位要求：葡萄糖 $G$ 和 $K_{G}$ 必须以毫摩尔（mM）处理。报告 $K_{G}$ 的单位为毫摩尔，$n$ 为无量纲。\n\n角度单位不适用。如果您计算任何比率或分数，请以小数形式报告，而不是使用百分号。\n\n测试套件：使用以下四个数据集。每个数据集指定了 $s_{0}$、一系列葡萄糖值 $G$（单位 mM）以及相应的观测分泌值 $s$（单位与 $s_{0}$ 相同，为任意单位）。\n\n- 数据集 A（良态，无噪声，协同抑制）：\n  - $s_{0} = 1.0$\n  - $G = [\\,3.0,\\,4.0,\\,6.0,\\,8.0,\\,10.0\\,]$ (mM)\n  - $s = [\\,0.6400000000,\\,0.5000000000,\\,0.3076923077,\\,0.2000000000,\\,0.1379310345\\,]$\n\n- 数据集 B（中度噪声，典型动态范围）：\n  - $s_{0} = 2.0$\n  - $G = [\\,3.0,\\,4.0,\\,5.0,\\,7.0,\\,10.0\\,]$ (mM)\n  - $s = [\\,1.6200000000,\\,1.3700000000,\\,1.1800000000,\\,0.8400000000,\\,0.5300000000\\,]$\n\n- 数据集 C（陡峭协同性，高 Hill 指数）：\n  - $s_{0} = 1.5$\n  - $G = [\\,3.0,\\,4.0,\\,5.0,\\,6.0,\\,7.0,\\,8.0\\,]$ (mM)\n  - $s = [\\,1.2110000000,\\,0.7500000000,\\,0.3700000000,\\,0.1750000000,\\,0.0860000000,\\,0.0450000000\\,]$\n\n- 数据集 D（边界可识别性，数据点最少）：\n  - $s_{0} = 1.0$\n  - $G = [\\,3.0,\\,10.0\\,]$ (mM)\n  - $s = [\\,0.8220000000,\\,0.1110000000\\,]$\n\n计算和报告要求：\n\n- 对于每个数据集，计算 $(\\hat{n}, \\hat{K}_{G})$，并满足正性约束（$\\hat{n} > 0$, $\\hat{K}_{G} > 0$）。\n- 使用基于模型结构的变换获得初始猜测，然后通过最小化原始尺度 $s$ 上的残差平方和进行优化。\n- 输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$\n[\\,\\hat{n}_{A},\\,\\hat{K}_{G,A},\\,\\hat{n}_{B},\\,\\hat{K}_{G,B},\\,\\hat{n}_{C},\\,\\hat{K}_{G,C},\\,\\hat{n}_{D},\\,\\hat{K}_{G,D}\\,],\n$$\n每个值都四舍五入到小数点后三位。如上所述，$K_{G}$ 值的单位默认为毫摩尔（mM），$n$ 为无量纲。",
            "solution": "此问题陈述有效。它具有科学依据，问题定义明确且完整。所提出的模型，一个 Hill 型抑制函数，是生理学和药理学中剂量反应现象的典型且经过经验验证的表示。其目标是使用非线性最小二乘法从提供的数据集中估计模型参数 $n$ 和 $K_{G}$，这在计算科学和统计建模中是一项标准且定义明确的任务。所提供的数据在葡萄糖-胰高血糖素动态的背景下，数值上是一致且合理的。\n\n参数 $(\\hat{n}, \\hat{K}_{G})$ 的估计将使用一个两步、有原则的方法进行。首先，通过线性化模型方程来推导参数的初始猜测。其次，通过执行非线性优化，在原始、未转换的尺度上最小化残差平方和，来优化这个初始猜测。这个两步过程是稳健的：线性化提供了一个计算成本低廉且通常准确的起点，引导后续的非线性搜索朝向全局最小值，并避开非物理的局部最小值。优化步骤至关重要，因为它尊重数据的原始误差结构，确保在分泌测量上存在加性、同方差噪声的假设下，最终估计值在统计上是最优的。\n\n**步骤 1：通过模型线性化进行初始参数猜测**\n\n分泌模型由下式给出：\n$$ s_{H}(G) = \\frac{s_{0}}{1 + \\left(\\frac{G}{K_{G}}\\right)^{n}} $$\n$s_{H}(G)$ 是分泌值，我们将其等同于每个葡萄糖浓度 $G_i$ 的观测数据 $s_i$。对于每个数据集，参数 $s_0$ 是已知的。我们必须估计 $n$ 和 $K_{G}$。我们可以通过代数方式重新排列方程，以分离出包含参数 $n$ 和 $K_{G}$ 的项：\n$$ \\frac{s_0}{s_i} = 1 + \\left(\\frac{G_i}{K_{G}}\\right)^{n} $$\n$$ \\frac{s_0}{s_i} - 1 = \\left(\\frac{G_i}{K_{G}}\\right)^{n} $$\n为使此变换有效，我们需要 $s_i  s_0$，所有提供的数据点均满足此条件，确保了左侧为正。对两边取自然对数，得到：\n$$ \\ln\\left(\\frac{s_0}{s_i} - 1\\right) = \\ln\\left[\\left(\\frac{G_i}{K_{G}}\\right)^{n}\\right] $$\n使用对数性质 $\\ln(a^b) = b\\ln(a)$ 和 $\\ln(a/b) = \\ln(a) - \\ln(b)$，我们得到：\n$$ \\ln\\left(\\frac{s_0}{s_i} - 1\\right) = n \\left( \\ln(G_i) - \\ln(K_{G}) \\right) $$\n这个方程可以表示为线性关系 $y = m x + c$ 的形式：\n$$ \\underbrace{\\ln\\left(\\frac{s_0}{s_i} - 1\\right)}_{y_i} = \\underbrace{n}_{m} \\cdot \\underbrace{\\ln(G_i)}_{x_i} + \\underbrace{(-n \\ln(K_{G}))}_{c} $$\n因此，我们可以将每个数据点 $(G_i, s_i)$ 转换到新的坐标系 $(x_i, y_i)$ 中，其中 $x_i = \\ln(G_i)$ 且 $y_i = \\ln(s_0/s_i - 1)$。然后，我们对这些转换后的点进行线性回归，以估计斜率 $m$ 和 y 轴截距 $c$。由此，我们推导出初始参数猜测：\n$$ n_{\\text{init}} = m $$\n$$ K_{G, \\text{init}} = \\exp\\left(-\\frac{c}{m}\\right) = \\exp\\left(-\\frac{c}{n_{\\text{init}}}\\right) $$\n\n**步骤 2：非线性最小二乘优化**\n\n初始猜测 $(n_{\\text{init}}, K_{G, \\text{init}})$ 被用作更严格优化的起点。目标是找到参数集 $(\\hat{n}, \\hat{K}_{G})$，以最小化模型预测与原始尺度上观测数据之间的残差平方和 (SSR)：\n$$ \\text{SSR}(n, K_G) = \\sum_{i=1}^{N}\\left[s_{H}(G_i; n, K_G) - s_{i}\\right]^{2} = \\sum_{i=1}^{N}\\left[\\frac{s_{0}}{1+\\left(\\frac{G_{i}}{K_{G}}\\right)^{n}} - s_{i}\\right]^{2} $$\n此最小化问题是一个非线性优化问题，受制于物理约束 $n > 0$ 和 $K_{G} > 0$。我们采用一种拟牛顿法，特别是 L-BFGS-B，它非常适合这类问题，因为它可以高效地处理边界约束 (box constraints)。优化使用 `scipy.optimize` 库中的 `minimize` 函数执行，将 $n$ 和 $K_{G}$ 的边界都设置为 $(0, \\infty)$ 以确保结果具有物理意义。最终估计的参数 $(\\hat{n}, \\hat{K}_{G})$ 是优化算法收敛时返回的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Estimates parameters for a Hill-type model of glucagon secretion.\n    The solution follows a two-step process:\n    1.  Calculates an initial guess for the parameters (n, K_G) by\n        linearizing the model equation and performing a linear regression.\n    2.  Refines the initial guess by minimizing the sum of squared residuals\n        on the original nonlinear model using scipy.optimize.minimize.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"s0\": 1.0,\n            \"G\": [3.0, 4.0, 6.0, 8.0, 10.0],\n            \"s\": [0.6400000000, 0.5000000000, 0.3076923077, 0.2000000000, 0.1379310345]\n        },\n        {\n            \"id\": \"B\",\n            \"s0\": 2.0,\n            \"G\": [3.0, 4.0, 5.0, 7.0, 10.0],\n            \"s\": [1.6200000000, 1.3700000000, 1.1800000000, 0.8400000000, 0.5300000000]\n        },\n        {\n            \"id\": \"C\",\n            \"s0\": 1.5,\n            \"G\": [3.0, 4.0, 5.0, 6.0, 7.0, 8.0],\n            \"s\": [1.2110000000, 0.7500000000, 0.3700000000, 0.1750000000, 0.0860000000, 0.0450000000]\n        },\n        {\n            \"id\": \"D\",\n            \"s0\": 1.0,\n            \"G\": [3.0, 10.0],\n            \"s\": [0.8220000000, 0.1110000000]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s0 = case[\"s0\"]\n        G = np.array(case[\"G\"], dtype=float)\n        s = np.array(case[\"s\"], dtype=float)\n\n        # Step 1: Calculate initial guess via model linearization.\n        # Filter data to ensure s  s0 for the log transformation.\n        valid_indices = (s > 0)  (s  s0)\n        G_filt = G[valid_indices]\n        s_filt = s[valid_indices]\n        \n        # Check if enough points are available for linear regression\n        if len(G_filt) >= 2:\n            x = np.log(G_filt)\n            y = np.log(s0 / s_filt - 1)\n\n            # Perform linear regression y = m*x + c\n            # where m = n and c = -n*ln(K_G)\n            m, c = np.polyfit(x, y, 1)\n\n            # Derived initial guesses. A positive slope 'm' is expected for inhibitory action.\n            if m > 0:\n                n_init = m\n                KG_init = np.exp(-c / m)\n            else:\n                # Fallback guess if data is too noisy for a good linear fit\n                n_init = 2.0\n                KG_init = np.median(G)\n        else:\n             # Fallback guess if no valid points for linearization.\n             n_init = 2.0\n             KG_init = np.median(G)\n        \n        # Ensure initial guesses are positive\n        if n_init = 0: n_init = 1.0\n        if KG_init = 0: KG_init = np.median(G)\n\n\n        # Step 2: Refine parameters with nonlinear least squares.\n        def model_func(params, G_vals, s0_val):\n            n, KG = params\n            # Clip KG to avoid division by zero or domain errors.\n            KG = max(KG, 1e-9)\n            return s0_val / (1.0 + (G_vals / KG)**n)\n\n        def ssr_func(params, G_vals, s_vals, s0_val):\n            \"\"\"Sum of Squared Residuals objective function.\"\"\"\n            model_s = model_func(params, G_vals, s0_val)\n            return np.sum((model_s - s_vals)**2)\n\n        initial_guess = [n_init, KG_init]\n        # Set bounds to enforce n > 0 and K_G > 0\n        bounds = ((1e-9, None), (1e-9, None))\n        \n        # Run the optimization\n        opt_result = minimize(\n            ssr_func,\n            initial_guess,\n            args=(G, s, s0),\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n\n        n_hat, KG_hat = opt_result.x\n\n        results.append(f\"{n_hat:.3f}\")\n        results.append(f\"{KG_hat:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们的最终实践将分析提升到系统层面，在一个闭环反馈系统中考察胰高血糖素、胰岛素和葡萄糖之间的相互作用，这对于设计人工胰腺等技术至关重要。在本练习中，您将执行线性稳定性分析，以确定控制器增益如何影响系统行为，从而识别出能够防止不稳定和不必要振荡的“安全”参数范围。",
            "id": "3890365",
            "problem": "考虑一个以胰高血糖素和胰岛素相互作用为中心的连续时间、集总参数葡萄糖调节模型。令 $H(t)$ 表示胰高血糖素与其稳态的偏差，$I(t)$ 表示胰岛素与其稳态的偏差，$G(t)$ 表示血浆葡萄糖浓度与其稳态（设定点）的偏差。时间以分钟为单位，$t$ 的单位是分钟，$H$ 和 $I$ 的单位是标准化激素单位，$G$ 的单位是 $\\mathrm{mg/dL}$。控制目标是通过基于 $G(t)$ 的反馈来调节激素分泌速率，从而将 $G(t)$ 调节至 $0$。从标准的连续时间建模假设和经过充分检验的生理事实（胰岛素降低血糖，胰高血糖素升高血糖；血糖升高时胰高血糖素减少，血糖升高时胰岛素增加）出发，围绕设定点的线性化动力学由以下常微分方程（ODE）系统给出：\n$$\n\\frac{dH}{dt} = -a_H H + \\sigma_H G + u_H, \\quad\n\\frac{dI}{dt} = -a_I I + \\sigma_I G + u_I, \\quad\n\\frac{dG}{dt} = c_H H - c_I I - a_G G,\n$$\n带有反馈控制器\n$$\nu_H = -k_H G, \\quad u_I = k_I G.\n$$\n此处，$a_H$、$a_I$ 和 $a_G$ 是单位为 $\\mathrm{min^{-1}}$ 的正衰减率；$c_H$ 和 $c_I$ 量化了胰高血糖素和胰岛素对葡萄糖的影响，单位为 $\\mathrm{(mg/dL)/(unit \\cdot min)}$；$\\sigma_H$（负值）和 $\\sigma_I$（正值）是内源性激素分泌对葡萄糖的局部敏感性，单位为 $\\mathrm{(unit)/(mg/dL \\cdot min)}$；$k_H$ 和 $k_I$ 是反馈增益，单位为 $\\mathrm{(unit)/(mg/dL \\cdot min)}$。在稳态 $(H,I,G)=(0,0,0)$ 附近，雅可比矩阵为\n$$\nA(k_H,k_I)=\\begin{bmatrix}\n-a_H  0  \\sigma_H - k_H \\\\\n0  -a_I  \\sigma_I + k_I \\\\\nc_H  -c_I  -a_G\n\\end{bmatrix}.\n$$\n当 $k_H$ 或 $k_I$ 变化时，$A(k_H,k_I)$ 的特征值发生性质上的改变，就会出现分岔，例如穿过虚轴（不稳定性开始）或从实数变为复共轭对（振荡瞬态的开始）。对于本问题，如果 $A(k_H,k_I)$ 的所有特征值都是实数且实部严格为负，则参数对 $(k_H,k_I)$ 被认为是“安全的”；否则是“不安全的”。所有的稳定性和振荡评估都必须通过分析 $A(k_H,k_I)$ 的特征值来进行。\n\n使用以下数值上合理的参数值，这些值与公认的生理量级一致：\n$$\na_H = 0.15 \\ \\mathrm{min^{-1}}, \\quad a_I = 0.25 \\ \\mathrm{min^{-1}}, \\quad a_G = 0.10 \\ \\mathrm{min^{-1}},\n$$\n$$\nc_H = 0.60 \\ \\mathrm{\\frac{mg/dL}{unit \\cdot min}}, \\quad c_I = 1.20 \\ \\mathrm{\\frac{mg/dL}{unit \\cdot min}},\n$$\n$$\n\\sigma_H = -0.03 \\ \\mathrm{\\frac{unit}{mg/dL \\cdot min}}, \\quad \\sigma_I = 0.04 \\ \\mathrm{\\frac{unit}{mg/dL \\cdot min}}.\n$$\n\n任务：通过在固定的 $k_I$ 值下，在指定范围内扫描 $k_H$，进行单参数分岔分析。对于每个测试用例，确定系统中 $k_H$ 的所有安全连续子区间。“连续子区间”是指 $k_H$ 值（在离散化网格上）的一个最大区间，在该区间内的每个网格点上系统都保持安全；区间的端点必须取自用于扫描的网格。\n\n你的程序必须：\n- 为每个网格点构建 $A(k_H,k_I)$。\n- 计算其特征值。\n- 当且仅当所有特征值都是实数且实部严格为负时，将每个网格点分类为安全。\n- 对于每个测试用例，返回在网格上找到的 $k_H$ 的最大连续安全子区间列表，表示为包含两个端点的对 $[k_{\\text{start}}, k_{\\text{end}}]$。\n\n使用以下固定的 $k_I$ 和 $k_H$ 扫描规范的测试套件：\n1. $k_I = 0.05$；扫描 $k_H$ 从 $-0.10$ 到 $0.20$，步长为 $0.005$。\n2. $k_I = -0.10$；扫描 $k_H$ 从 $-0.10$ 到 $0.20$，步长为 $0.005$。\n3. $k_I = 0.20$；扫描 $k_H$ 从 $-0.05$ 到 $0.50$，步长为 $0.01$。\n\n最终输出格式必须是单行，包含一个由逗号分隔的三个结果的列表，每个结果本身是一个区间对的列表，用方括号括起来。例如：$[\\,[\\,[x_1,x_2],[x_3,x_4]\\,],\\,[\\,],\\,[\\,[y_1,y_2]\\,]\\,]$。输出中不应包含任何单位；$k_H$ 和 $k_I$ 的所有值都是单位为 $\\mathrm{(unit)/(mg/dL \\cdot min)}$ 的普通十进制数。",
            "solution": "问题的核心是确定给定的三维线性动力学系统的稳定性，并识别出使系统“安全”的控制器增益 $k_H$ 的区间。根据定义，一个“安全”的系统需要其雅可比矩阵 $A(k_H,k_I)$ 的所有特征值都是实数且严格为负。这个条件确保了系统不仅是稳定的（所有特征值的实部为负），而且其对扰动的响应是纯粹的指数衰减，没有任何振荡（所有特征值都是实数）。\n\n**分析步骤**\n\n我们的任务是为每个给定的固定 $k_I$ 值，通过扫描一系列 $k_H$ 值来执行单参数分岔分析。对于 $k_H$ 网格上的每个点，我们将执行以下步骤：\n\n1.  **构建雅可比矩阵**：将给定的生理参数（$a_H, a_I, a_G, c_H, c_I, \\sigma_H, \\sigma_I$）以及当前的控制器增益（$k_I$ 和网格点上的 $k_H$）代入雅可比矩阵的表达式中：\n    $$\n    A(k_H,k_I)=\\begin{bmatrix}\n    -0.15   0   -0.03 - k_H \\\\\n    0   -0.25   0.04 + k_I \\\\\n    0.60   -1.20   -0.10\n    \\end{bmatrix}\n    $$\n\n2.  **计算特征值**：对于构建好的数值矩阵 $A$，我们计算它的三个特征值，记为 $\\lambda_1, \\lambda_2, \\lambda_3$。这通常通过求解特征方程 $\\det(A - \\lambda I) = 0$ 来完成，在实践中则使用数值线性代数库（如 NumPy）来高效计算。\n\n3.  **应用安全准则**：检查计算出的特征值是否同时满足以下两个条件：\n    a.  **实数条件**：所有特征值的虚部必须为零（在数值计算中，即绝对值小于一个很小的容差，例如 $10^{-9}$）。$\\forall i \\in \\{1,2,3\\}, \\text{Im}(\\lambda_i) = 0$。\n    b.  **稳定性条件**：所有特征值的实部必须严格为负。$\\forall i \\in \\{1,2,3\\}, \\text{Re}(\\lambda_i)  0$。\n\n4.  **分类和区间识别**：如果一个 $k_H$ 值对应的系统同时满足上述两个条件，则该点被标记为“安全”。在对所有网格点进行分类后，我们将识别出所有连续的“安全” $k_H$ 值构成的最大区间。每个区间的端点由该连续安全区域在扫描网格上的第一个和最后一个点确定。\n\n**算法实现**\n\n该分析过程将通过一个程序实现，该程序迭代遍历每个测试用例中指定的 $k_H$ 范围。在每次迭代中，它会构建矩阵，计算特征值，并根据安全准则评估系统。最后，程序将整理并输出所有识别出的安全区间，格式如问题要求所述。这个过程有效地将一个控制理论中的稳定性分析问题转化为一个定义明确的数值计算任务。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a one-parameter bifurcation analysis for a glucose regulation model.\n\n    The function sweeps the controller gain k_H for fixed values of k_I,\n    computes the eigenvalues of the system's Jacobian matrix at each point,\n    and identifies \"safe\" intervals where all eigenvalues are real and strictly negative.\n    \"\"\"\n    # Define constant model parameters\n    a_H = 0.15      # min^-1\n    a_I = 0.25      # min^-1\n    a_G = 0.10      # min^-1\n    c_H = 0.60      # (mg/dL)/(unit * min)\n    c_I = 1.20      # (mg/dL)/(unit * min)\n    sigma_H = -0.03 # (unit)/(mg/dL * min)\n    sigma_I = 0.04  # (unit)/(mg/dL * min)\n\n    # Define the test cases for the parameter sweeps\n    test_cases = [\n        {'k_I': 0.05, 'k_H_start': -0.10, 'k_H_end': 0.20, 'k_H_step': 0.005},\n        {'k_I': -0.10, 'k_H_start': -0.10, 'k_H_end': 0.20, 'k_H_step': 0.005},\n        {'k_I': 0.20, 'k_H_start': -0.05, 'k_H_end': 0.50, 'k_H_step': 0.01},\n    ]\n\n    all_results = []\n    TOLERANCE = 1e-9  # Tolerance for checking if an imaginary part is zero\n\n    for case in test_cases:\n        k_I = case['k_I']\n        start, end, step = case['k_H_start'], case['k_H_end'], case['k_H_step']\n\n        # Generate the grid of k_H values using np.linspace for precision\n        num_points = int(round((end - start) / step)) + 1\n        k_H_grid = np.linspace(start, end, num_points)\n\n        is_safe_list = []\n        for k_H in k_H_grid:\n            # Construct the Jacobian matrix A for the current (k_H, k_I) pair\n            A = np.array([\n                [-a_H, 0.0, sigma_H - k_H],\n                [0.0, -a_I, sigma_I + k_I],\n                [c_H, -c_I, -a_G]\n            ])\n\n            # Compute the eigenvalues of the matrix\n            eigenvalues = np.linalg.eigvals(A)\n\n            # Check the \"safe\" conditions\n            # 1. All eigenvalues must be real.\n            all_real = np.all(np.abs(np.imag(eigenvalues))  TOLERANCE)\n            # 2. All real parts must be strictly negative.\n            all_neg_real = np.all(np.real(eigenvalues)  0.0)\n\n            is_safe_list.append(all_real and all_neg_real)\n\n        # Identify contiguous subintervals of safe k_H values\n        safe_intervals = []\n        in_interval = False\n        start_k_H = None\n        for i, is_safe in enumerate(is_safe_list):\n            if is_safe and not in_interval:\n                start_k_H = k_H_grid[i]\n                in_interval = True\n            elif not is_safe and in_interval:\n                end_k_H = k_H_grid[i - 1]\n                safe_intervals.append([start_k_H, end_k_H])\n                in_interval = False\n        \n        # If the sweep ends while in a safe interval, close the interval\n        if in_interval:\n            end_k_H = k_H_grid[-1]\n            safe_intervals.append([start_k_H, end_k_H])\n            \n        all_results.append(safe_intervals)\n\n    # Format the final output string to match the required format '[[...],[],...]'\n    # with no whitespace. Using str() and replace() is a robust way to achieve this.\n    final_output_string = str(all_results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}