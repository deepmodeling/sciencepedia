{
    "hands_on_practices": [
        {
            "introduction": "将一个物理模型付诸实践的第一步，是将其控制方程转化为计算机可以求解的形式。本练习将引导你推导基础的二元件 Windkessel 模型的常微分方程（ODE），并实现一个简单的数值求解器。本练习的重点是理解数值选择（如时间步长 $\\Delta t$）对模拟稳定性和准确性的实际影响，以及它与系统物理时间常数 $RC$ 的关系，这是任何建模者都必须掌握的关键技能 。",
            "id": "3938480",
            "problem": "考虑动脉树的两元件 Windkessel 表示，该模型将下游血管特性聚合为单一的液压阻力 $R$（单位为 $\\mathrm{mmHg\\cdot s/mL}$）和单一的动脉顺应性 $C$（单位为 $\\mathrm{mL/mmHg}$）。令 $P(t)$ 表示动脉压（单位为 $\\mathrm{mmHg}$），$Q_{\\mathrm{in}}(t)$ 表示来自心脏的流入量（单位为 $\\mathrm{mL/s}$），$Q_{\\mathrm{out}}(t)$ 表示通过外周阻力的流出量（单位为 $\\mathrm{mL/s}$）。使用以下基本关系：\n- 体积守恒：$\\dfrac{dV}{dt} = Q_{\\mathrm{in}}(t) - Q_{\\mathrm{out}}(t)$。\n- 顺应性定义：$C = \\dfrac{dV}{dP}$，假定在工作范围内为常数；等效地，$\\dfrac{dP}{dt} = \\dfrac{1}{C}\\dfrac{dV}{dt}$。\n- 液压欧姆定律：$Q_{\\mathrm{out}}(t) = \\dfrac{P(t)}{R}$。\n\n任务 $1$（推导）：严格从这些关系出发，推导由已知流入量 $Q_{\\mathrm{in}}(t)$ 驱动的 $P(t)$ 的控制常微分方程 (ODE)，以及该 ODE 在初始条件 $P(0)=P_0$ 下使用均匀步长 $\\Delta t$ 的显式欧拉时间离散化。\n\n任务 $2$（稳定性和准确性）：分析应用于 $Q_{\\mathrm{in}}(t)=0$ 的齐次情况下的显式欧拉更新。推导离散时间解的数值稳定性的充分必要条件以及一个更强的非振荡单调衰减条件。证明为什么无量纲比 $\\alpha=\\dfrac{\\Delta t}{RC}$ 必须满足 $\\alpha\\ll 1$ 以确保准确性，并从解析物理松弛时间尺度 $RC$ 的角度解释此要求。\n\n任务 $3$（实现和测试套件）：实现一个程序，该程序：\n- 对给定的 $(R,C,\\Delta t)$、流入量 $Q_{\\mathrm{in}}(t)$、时间范围 $T$（单位为 $\\mathrm{s}$）和初始条件 $P_0$（单位为 $\\mathrm{mmHg}$）模拟显式欧拉格式。\n- 对于恒定流入量，计算解析解，并评估在欧拉网格点上数值解和解析解压力之间的最大绝对误差。\n\n使用以下测试套件。对于所有测试，取 $R=1.0\\,\\mathrm{mmHg\\cdot s/mL}$ 和 $C=2.0\\,\\mathrm{mL/mmHg}$，因此 $RC=2.0\\,\\mathrm{s}$。流入量 $Q_{\\mathrm{in}}(t)$ 和其他参数按每个测试指定。您的程序必须以指定的单位和所要求的类型产生输出。\n\n- 测试 A（理想情况准确性）：恒定流入量 $Q_{\\mathrm{in}}(t)=5.0\\,\\mathrm{mL/s}$，初始压力 $P_0=80.0\\,\\mathrm{mmHg}$，步长 $\\Delta t=0.01\\,\\mathrm{s}$，时间范围 $T=6.0\\,\\mathrm{s}$。输出显式欧拉解与解析解之间的最大绝对误差，作为浮点数，单位为 $\\mathrm{mmHg}$，四舍五入到 $6$ 位小数。\n\n- 测试 B（在 $\\Delta t=RC$ 时的边界单调性）：零流入量 $Q_{\\mathrm{in}}(t)=0$，初始压力 $P_0=100.0\\,\\mathrm{mmHg}$，步长 $\\Delta t=2.0\\,\\mathrm{s}$，时间范围 $T=10.0\\,\\mathrm{s}$。输出一个布尔值，指示显式欧拉序列在所有模拟时间点是否单调非增且非负。\n\n- 测试 C（振荡但稳定，$\\Delta t=1.5\\,RC$）：零流入量 $Q_{\\mathrm{in}}(t)=0$，初始压力 $P_0=100.0\\,\\mathrm{mmHg}$，步长 $\\Delta t=3.0\\,\\mathrm{s}$，时间范围 $T=18.0\\,\\mathrm{s}$。输出一个整数，等于在显式欧拉压力序列中观察到的符号变化次数。\n\n- 测试 D（接近稳定性极限，在 $\\Delta t=1.9\\,RC$ 时的幅值检查）：零流入量 $Q_{\\mathrm{in}}(t)=0$，初始压力 $P_0=100.0\\,\\mathrm{mmHg}$，步长 $\\Delta t=3.8\\,\\mathrm{s}$，时间范围 $T=19.0\\,\\mathrm{s}$。输出一个布尔值，指示幅值是否在每一步都非递增，即 $\\lvert P_{n+1}\\rvert\\le \\lvert P_n\\rvert$ 是否对所有步都成立。\n\n- 测试 E（不稳定区域，$\\Delta t=2.1\\,RC$）：零流入量 $Q_{\\mathrm{in}}(t)=0$，初始压力 $P_0=100.0\\,\\mathrm{mmHg}$，步长 $\\Delta t=4.2\\,\\mathrm{s}$，时间范围 $T=21.0\\,\\mathrm{s}$。输出一个布尔值，指示序列是否发散，此处定义为存在至少一步满足 $\\lvert P_{n+1}\\rvert>\\lvert P_n\\rvert$。\n\n最终输出格式要求：您的程序应产生单行输出，包含一个逗号分隔的列表，用方括号括起来（例如，$\\left[\\text{result1},\\text{result2},\\text{result3}\\right]$），结果顺序遵循测试 A 到 E 的顺序。确保遵循物理单位：压力单位为 $\\mathrm{mmHg}$，流量单位为 $\\mathrm{mL/s}$，时间单位为 $\\mathrm{s}$。",
            "solution": "该问题是有效的，因为它科学地基于生物医学系统建模的既定原则，问题陈述清晰，提供了所有必要信息，并且表述客观。这些任务涉及与一阶线性常微分方程及其数值解相关的标准但非平凡的推导、分析和实现。\n\n解决方案分为三个部分，与问题陈述中概述的任务相对应。\n\n任务 1：控制常微分方程及其离散化的推导\n\n目标是推导动脉压 $P(t)$ 的微分方程及其显式欧拉近似。我们从提供的三个基本关系开始：\n\n1.  体积守恒：$\\dfrac{dV}{dt} = Q_{\\mathrm{in}}(t) - Q_{\\mathrm{out}}(t)$\n2.  顺应性定义：$C = \\dfrac{dV}{dP}$，对于常数 $C$ 可得 $\\dfrac{dP}{dt} = \\dfrac{1}{C}\\dfrac{dV}{dt}$\n3.  液压欧姆定律：$Q_{\\mathrm{out}}(t) = \\dfrac{P(t)}{R}$\n\n首先，我们将方程 ($1$) 中体积变化率 $\\dfrac{dV}{dt}$ 的表达式代入方程 ($2$)：\n$$\n\\dfrac{dP}{dt} = \\dfrac{1}{C} \\left( Q_{\\mathrm{in}}(t) - Q_{\\mathrm{out}}(t) \\right)\n$$\n接下来，我们使用方程 ($3$) 中的欧姆定律替换流出量 $Q_{\\mathrm{out}}(t)$：\n$$\n\\dfrac{dP}{dt} = \\dfrac{1}{C} \\left( Q_{\\mathrm{in}}(t) - \\dfrac{P(t)}{R} \\right)\n$$\n将 $\\dfrac{1}{C}$ 项展开并重新整理，我们得到一阶线性常微分方程 (ODE) 的标准形式：\n$$\n\\dfrac{dP}{dt} + \\dfrac{1}{RC}P(t) = \\dfrac{1}{C}Q_{\\mathrm{in}}(t)\n$$\n这是两元件 Windkessel 模型中动脉压 $P(t)$ 的控制常微分方程。\n\n为了推导显式欧拉时间离散化，我们用前向差分来近似导数 $\\dfrac{dP}{dt}$。设 $t_n = n \\Delta t$ 为具有均匀步长 $\\Delta t$ 的离散时间点，并设 $P_n$ 为 $P(t_n)$ 的数值近似。在时间 $t_n$ 的导数近似为：\n$$\n\\dfrac{dP}{dt}\\bigg|_{t=t_n} \\approx \\dfrac{P_{n+1} - P_n}{\\Delta t}\n$$\n将此代入在 $t=t_n$ 处取值的 ODE 中：\n$$\n\\dfrac{P_{n+1} - P_n}{\\Delta t} = \\dfrac{1}{C}Q_{\\mathrm{in}}(t_n) - \\dfrac{1}{RC}P_n\n$$\n求解 $P_{n+1}$，得到显式欧拉更新规则：\n$$\nP_{n+1} = P_n + \\Delta t \\left( \\dfrac{1}{C}Q_{\\mathrm{in}}(t_n) - \\dfrac{1}{RC}P_n \\right)\n$$\n对含 $P_n$ 的项进行分组：\n$$\nP_{n+1} = \\left(1 - \\dfrac{\\Delta t}{RC}\\right)P_n + \\dfrac{\\Delta t}{C}Q_{\\mathrm{in}}(t_n)\n$$\n此公式连同初始条件 $P(0) = P_0$，定义了数值模拟的完整算法。\n\n任务 2：稳定性和准确性分析\n\n我们分析齐次情况下的数值格式，其中流入量 $Q_{\\mathrm{in}}(t)=0$。ODE 变为 $\\dfrac{dP}{dt} = -\\dfrac{1}{RC}P(t)$，其解析解为 $P(t) = P_0 e^{-t/RC}$，显示了以时间常数 $\\tau = RC$ 向 $0$ 的指数衰减。欧拉更新规则简化为：\n$$\nP_{n+1} = \\left(1 - \\dfrac{\\Delta t}{RC}\\right)P_n\n$$\n这是一个几何递推关系。设放大因子为 $g = 1 - \\dfrac{\\Delta t}{RC}$。第 $n$ 步的解为 $P_n = g^n P_0$。\n\n如果数值解的幅值不无界增长，则称其是稳定的，这要求 $|g| \\le 1$。这导致条件：\n$$\n\\left|1 - \\dfrac{\\Delta t}{RC}\\right| \\le 1\n$$\n此不等式等价于 $-1 \\le 1 - \\dfrac{\\Delta t}{RC} \\le 1$。\n右侧不等式 $1 - \\dfrac{\\Delta t}{RC} \\le 1$ 意味着 $-\\dfrac{\\Delta t}{RC} \\le 0$，这总是成立的，因为 $R, C, \\Delta t$ 都是正的物理量。\n左侧不等式 $-1 \\le 1 - \\dfrac{\\Delta t}{RC}$ 意味着 $\\dfrac{\\Delta t}{RC} \\le 2$。\n因此，该问题显式欧拉格式数值稳定性的充分必要条件是 $\\dfrac{\\Delta t}{RC} \\le 2$。\n\n解析解表现为向 $0$ 的单调衰减（对于 $P_0 > 0$）。为了让数值解能够不产生振荡地复现此行为，放大因子 $g$ 必须在范围 $0 \\le g  1$ 内。对于 $\\Delta t > 0$，条件 $g  1$ 总是满足的。非负性条件 $g \\ge 0$ 给出：\n$$\n1 - \\dfrac{\\Delta t}{RC} \\ge 0 \\implies \\dfrac{\\Delta t}{RC} \\le 1\n$$\n这是非振荡、单调衰减的条件。\n\n为了使数值解准确，它必须紧密逼近解析解。离散解为 $P_n = P_0 g^n = P_0 \\left(1 - \\dfrac{\\Delta t}{RC}\\right)^n$。在时间 $t_n = n \\Delta t$ 的解析解为 $P(t_n) = P_0 e^{-t_n/RC} = P_0 e^{-n\\Delta t/RC} = P_0 \\left(e^{-\\Delta t/RC}\\right)^n$。\n准确性要求幂的底数相近：$1 - \\dfrac{\\Delta t}{RC} \\approx e^{-\\Delta t/RC}$。\n令 $\\alpha = \\dfrac{\\Delta t}{RC}$，则 $e^{-\\alpha}$ 的泰勒级数展开为 $e^{-\\alpha} = 1 - \\alpha + \\dfrac{\\alpha^2}{2!} - \\dfrac{\\alpha^3}{3!} + \\dots$。显式欧拉法使用一阶近似 $e^{-\\alpha} \\approx 1 - \\alpha$，因此产生 $\\mathcal{O}(\\alpha^2)$ 阶的局部截断误差。为使此近似有效，高阶项必须可以忽略不计，这要求 $\\alpha \\ll 1$，即 $\\dfrac{\\Delta t}{RC} \\ll 1$。\n物理上，$RC$ 是系统松弛的时间常数。条件 $\\Delta t \\ll RC$ 指出，模拟的时间步长必须远小于物理过程的特征时间尺度。使用大的 $\\Delta t$ 将无法解析系统的动态特性，导致巨大的误差，并且如上所示，可能导致数值不稳定性。\n\n任务 3：实现和测试套件逻辑\n\n实现将遵循推导出的欧拉更新规则。\n- 测试 A 评估恒定流入量下的准确性。解析解 $P_{an}(t) = (P_0 - RQ_0)e^{-t/RC} + RQ_0$ 用作基准。我们预期误差会很小，因为 $\\alpha = \\dfrac{\\Delta t}{RC} = \\dfrac{0.01}{2.0} = 0.005 \\ll 1$。\n- 测试 B 设置 $\\dfrac{\\Delta t}{RC} = 1$。放大因子为 $g = 1 - 1 = 0$。序列变为 $P_0, 0, 0, \\dots, 0$。此序列既是单调非增的，也是非负的。\n- 测试 C 设置 $\\dfrac{\\Delta t}{RC} = 1.5$。放大因子为 $g = 1 - 1.5 = -0.5$。由于 $1  \\dfrac{\\Delta t}{RC} \\le 2$，解是稳定但振荡的。$P_n$ 的符号将在每一步交替。对于有 $N$ 步的模拟，将有 $N$ 次符号变化。\n- 测试 D 设置 $\\dfrac{\\Delta t}{RC} = 1.9$。放大因子为 $g = 1 - 1.9 = -0.9$。放大因子的幅值为 $|g|=0.9$。由于 $|g|  1$，压力的幅值在每一步减小：$|P_{n+1}| = |g||P_n|  |P_n|$。条件 $|P_{n+1}| \\le |P_n|$ 将成立。\n- 测试 E 设置 $\\dfrac{\\Delta t}{RC} = 2.1$。放大因子为 $g = 1 - 2.1 = -1.1$。稳定性条件被违反，因为 $|g| = 1.1 > 1$。幅值将在每一步增长，$|P_{n+1}| = |g||P_n| > |P_n|$，表明发散。发散的条件在第一步就满足了。",
            "answer": "```python\nimport numpy as np\n# from scipy import integrate # Not used but listed as permitted\n\ndef solve():\n    \"\"\"\n    Solves the Windkessel problem according to the specified test cases.\n    \"\"\"\n\n    def euler_simulation(R, C, dt, T, P0, Q_in_func):\n        \"\"\"\n        Performs an explicit Euler simulation for the 2-element Windkessel model.\n        \n        Args:\n            R (float): Peripheral resistance.\n            C (float): Arterial compliance.\n            dt (float): Time step.\n            T (float): Simulation horizon.\n            P0 (float): Initial pressure.\n            Q_in_func (callable): Inflow function Q_in(t).\n            \n        Returns:\n            tuple: A tuple containing the time array and the pressure array.\n        \"\"\"\n        # Ensure robust calculation of the number of steps\n        num_steps = int(round(T / dt))\n        t = np.linspace(0, T, num_steps + 1)\n        P = np.zeros(num_steps + 1)\n        P[0] = P0\n        \n        RC = R * C\n        # Pre-compute constants for the loop\n        term1_factor = 1.0 - dt / RC\n        term2_factor = dt / C\n        \n        for i in range(num_steps):\n            Q_in_i = Q_in_func(t[i])\n            P[i+1] = term1_factor * P[i] + term2_factor * Q_in_i\n            \n        return t, P\n\n    # --- Test Case Parameters ---\n    R_base = 1.0\n    C_base = 2.0\n    RC_base = R_base * C_base\n\n    test_cases = [\n        # Test A: Constant inflow, accuracy check\n        {'R': R_base, 'C': C_base, 'dt': 0.01, 'T': 6.0, 'P0': 80.0, 'Q_in': lambda t: 5.0, 'id': 'A'},\n        # Test B: Monotonicity at stability boundary\n        {'R': R_base, 'C': C_base, 'dt': 2.0, 'T': 10.0, 'P0': 100.0, 'Q_in': lambda t: 0.0, 'id': 'B'},\n        # Test C: Oscillatory but stable\n        {'R': R_base, 'C': C_base, 'dt': 3.0, 'T': 18.0, 'P0': 100.0, 'Q_in': lambda t: 0.0, 'id': 'C'},\n        # Test D: Near stability limit, magnitude check\n        {'R': R_base, 'C': C_base, 'dt': 3.8, 'T': 19.0, 'P0': 100.0, 'Q_in': lambda t: 0.0, 'id': 'D'},\n        # Test E: Unstable regime\n        {'R': R_base, 'C': C_base, 'dt': 4.2, 'T': 21.0, 'P0': 100.0, 'Q_in': lambda t: 0.0, 'id': 'E'},\n    ]\n\n    results = []\n    for case in test_cases:\n        t, P_numerical = euler_simulation(case['R'], case['C'], case['dt'], case['T'], case['P0'], case['Q_in'])\n        \n        if case['id'] == 'A':\n            Q0 = case['Q_in'](0)  # Constant inflow\n            P0 = case['P0']\n            \n            def p_analytical(t_vals, R, C, P0, Q0):\n                RC = R * C\n                return (P0 - R * Q0) * np.exp(-t_vals / RC) + R * Q0\n            \n            P_analytic = p_analytical(t, case['R'], case['C'], P0, Q0)\n            max_abs_error = np.max(np.abs(P_numerical - P_analytic))\n            results.append(round(max_abs_error, 6))\n\n        elif case['id'] == 'B':\n            is_non_increasing = np.all(P_numerical[1:] <= P_numerical[:-1])\n            is_non_negative = np.all(P_numerical >= 0)\n            results.append(is_non_increasing and is_non_negative)\n\n        elif case['id'] == 'C':\n            sign_changes = 0\n            for i in range(len(P_numerical) - 1):\n                if P_numerical[i] * P_numerical[i+1] < 0:\n                    sign_changes += 1\n            results.append(sign_changes)\n\n        elif case['id'] == 'D':\n            is_mag_non_increasing = np.all(np.abs(P_numerical[1:]) <= np.abs(P_numerical[:-1]))\n            results.append(is_mag_non_increasing)\n\n        elif case['id'] == 'E':\n            diverges = np.any(np.abs(P_numerical[1:]) > np.abs(P_numerical[:-1]))\n            results.append(diverges)\n\n    # Format the final output string\n    output_str = f\"[{results[0]},{str(results[1]).lower()},{results[2]},{str(results[3]).lower()},{str(results[4]).lower()}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在建立了基本的线性模型之后，一个自然的问题是：模型的简化假设在多大程度上是合理的？本练习将探讨一个更符合生理学现实的场景，其中动脉顺应性并非恒定，而是随压力变化。通过比较线性和非线性模型的预测结果，你将体会到引入非线性如何改变系统行为，并理解为何对于更复杂、更真实的模型，数值方法变得不可或缺 。",
            "id": "3938486",
            "problem": "考虑舒张期动脉树的双元件 Windkessel 模型，该模型由单一外周阻力和单一动脉顺应性构成。在舒张期，主动脉瓣关闭，因此流入顺应性动脉腔室的血流量为零。设通过外周阻力的流出量由阻性血流定律 $Q_{\\text{out}}(t) = \\dfrac{P(t) - P_{\\text{ven}}}{R}$ 决定，其中 $P(t)$ 是动脉压力，$P_{\\text{ven}}$ 是一个恒定的静脉压力（作为下游压力），$R$ 是外周阻力。体积守恒意味着 $dV/dt = -Q_{\\text{out}}(t)$，而顺应性的定义意味着 $dV/dP = C(P)$，因此有 $C(P)\\, \\dfrac{dP}{dt} = \\dfrac{dV}{dt}$。\n\n您将比较两种顺应性模型：\n- 具有恒定顺应性 $C(P) = C_{0}$ 的线性顺应性模型。\n- 具有压力依赖性顺应性 $C(P) = C_{0}\\,\\exp\\!\\big(\\beta\\,P\\big)$ 的非线性顺应性模型，其中 $C_{0} > 0$ 和 $\\beta \\ge 0$ 是常数。\n\n仅从所述定律和定义出发，推导舒张期 $P(t)$ 的控制方程，并对于两种顺应性模型，在给定相同的 $R$、$P_{\\text{ven}}$ 和相同的初始条件 $P(0) = P_{0}$ 的情况下，确定在时间 $t = T_{\\text{d}}/2$ 时的动脉压力。舒张期持续时间 $T_{\\text{d}}$ 是给定的。所有压力以 $\\text{mmHg}$ 表示，阻力以 $\\text{mmHg}\\cdot\\text{s}/\\text{mL}$ 表示，顺应性以 $\\text{mL}/\\text{mmHg}$ 表示，时间以 $\\text{s}$ 表示。\n\n您的程序必须为每个测试用例计算一个包含三个浮点数的元组 $[P_{\\text{lin}}(T_{\\text{d}}/2),\\,P_{\\text{nl}}(T_{\\text{d}}/2),\\,\\Delta]$，其中 $P_{\\text{lin}}(T_{\\text{d}}/2)$ 是线性顺应性模型在 $t = T_{\\text{d}}/2$ 时的预测值，$P_{\\text{nl}}(T_{\\text{d}}/2)$ 是非线性顺应性模型在 $t = T_{\\text{d}}/2$ 时的预测值，且 $\\Delta = P_{\\text{nl}}(T_{\\text{d}}/2) - P_{\\text{lin}}(T_{\\text{d}}/2)$。所有输出必须以 $\\text{mmHg}$ 为单位。\n\n测试套件参数（每行定义一个测试用例，格式为 $(R, C_{0}, \\beta, P_{0}, P_{\\text{ven}}, T_{\\text{d}})$）：\n- 案例 A（一般正常路径）：$(\\,\\;1.10,\\;\\;1.60,\\;\\;0.015,\\;\\;95.0,\\;\\;5.0,\\;\\;0.80\\,)$\n- 案例 B（边界情况 $\\beta = 0$，非线性模型简化为线性模型）：$(\\,\\;1.20,\\;\\;1.40,\\;\\;0.0,\\;\\;100.0,\\;\\;10.0,\\;\\;0.70\\,)$\n- 案例 C（初始压力接近下游压力）：$(\\,\\;0.80,\\;\\;2.00,\\;\\;0.020,\\;\\;12.0,\\;\\;10.0,\\;\\;0.50\\,)$\n- 案例 D（高阻力，低顺应性）：$(\\,\\;2.50,\\;\\;0.80,\\;\\;0.030,\\;\\;110.0,\\;\\;5.0,\\;\\;1.00\\,)$\n- 案例 E（短舒张期）：$(\\,\\;1.00,\\;\\;1.00,\\;\\;0.010,\\;\\;80.0,\\;\\;5.0,\\;\\;0.20\\,)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个包含三个浮点数的列表，例如：$[\\,[x_{1},y_{1},z_{1}],\\,[x_{2},y_{2},z_{2}],\\,\\dots\\,]$。不应打印任何额外文本。",
            "solution": "问题陈述科学严谨、内容完整且定义明确。所有参数和条件都已清晰定义。\n\n目标是推导舒张期双元件 Windkessel 模型中动脉压力 $P(t)$ 的控制微分方程，并针对两种不同的动脉顺应性模型 $C(P)$ 进行求解。需要在特定时间点 $t = T_{\\text{d}}/2$ 评估压力值。\n\n首先，我们推导通用的控制方程。动脉腔室内的体积守恒原理由 $\\dfrac{dV}{dt} = Q_{\\text{in}}(t) - Q_{\\text{out}}(t)$ 给出。在舒张期，主动脉瓣关闭，因此流入量 $Q_{\\text{in}}(t)$ 为零。于是，$\\dfrac{dV}{dt} = -Q_{\\text{out}}(t)$。\n通过外周阻力 $R$ 的流出量由 $Q_{\\text{out}}(t) = \\dfrac{P(t) - P_{\\text{ven}}}{R}$ 给出，其中 $P_{\\text{ven}}$ 是恒定的静脉压力。\n顺应性 $C(P)$ 的定义将体积变化 $dV$ 与压力变化 $dP$ 联系起来，即 $dV = C(P)dP$，或者用变化率表示为 $\\dfrac{dV}{dt} = C(P) \\dfrac{dP}{dt}$。\n\n通过代入 $\\dfrac{dV}{dt}$ 和 $Q_{\\text{out}}(t)$ 的表达式，我们得到动脉压力 $P(t)$ 的控制常微分方程 (ODE)：\n$$ C(P) \\frac{dP}{dt} = -Q_{\\text{out}}(t) = -\\frac{P(t) - P_{\\text{ven}}}{R} $$\n这可以写成：\n$$ \\frac{dP}{dt} = -\\frac{P(t) - P_{\\text{ven}}}{R C(P)} $$\n这就是通用的控制方程。我们现在针对两种指定的顺应性模型，在初始条件 $P(0) = P_{0}$ 下求解该方程。\n\n**线性顺应性模型：$C(P) = C_0$**\n对于线性模型，顺应性是一个常数，$C(P) = C_0$。控制方程变为：\n$$ \\frac{dP}{dt} = -\\frac{P(t) - P_{\\text{ven}}}{RC_0} $$\n这是一个一阶线性常系数 ODE。它是可分离的。我们可以重新整理并积分：\n$$ \\int_{P(0)}^{P(t)} \\frac{dP'}{P' - P_{\\text{ven}}} = -\\int_{0}^{t} \\frac{ds}{RC_0} $$\n给定 $P(0) = P_0$，积分得到：\n$$ \\left[ \\ln|P' - P_{\\text{ven}}| \\right]_{P_0}^{P(t)} = -\\frac{t}{RC_0} $$\n假设 $P_0 > P_{\\text{ven}}$，压力 $P(t)$ 将指数衰减至 $P_{\\text{ven}}$，但在有限时间 $t$ 内将保持大于 $P_{\\text{ven}}$。因此，我们可以去掉绝对值符号。\n$$ \\ln(P(t) - P_{\\text{ven}}) - \\ln(P_0 - P_{\\text{ven}}) = -\\frac{t}{RC_0} $$\n$$ \\ln\\left(\\frac{P(t) - P_{\\text{ven}}}{P_0 - P_{\\text{ven}}}\\right) = -\\frac{t}{RC_0} $$\n求解 $P(t)$，我们得到线性模型的解析解 $P_{\\text{lin}}(t)$：\n$$ P_{\\text{lin}}(t) = P_{\\text{ven}} + (P_0 - P_{\\text{ven}}) \\exp\\left(-\\frac{t}{RC_0}\\right) $$\n我们需要求出在 $t = T_{\\text{d}}/2$ 时的压力。将此值代入 $t$：\n$$ P_{\\text{lin}}(T_{\\text{d}}/2) = P_{\\text{ven}} + (P_0 - P_{\\text{ven}}) \\exp\\left(-\\frac{T_{\\text{d}}}{2RC_0}\\right) $$\n\n**非线性顺应性模型：$C(P) = C_0 \\exp(\\beta P)$**\n对于非线性模型，顺应性是压力依赖的。将 $C(P) = C_0 \\exp(\\beta P)$ 代入通用控制方程：\n$$ \\frac{dP}{dt} = -\\frac{P(t) - P_{\\text{ven}}}{R C_0 \\exp(\\beta P)} $$\n这是一个非线性一阶 ODE。它也是可分离的。\n$$ C_0 \\exp(\\beta P) dP = -\\frac{P - P_{\\text{ven}}}{R} dt $$\n$$ \\frac{\\exp(\\beta P)}{P - P_{\\text{ven}}} dP = -\\frac{1}{RC_0} dt $$\n对两边从 $t=0$ 到 $t$ 进行积分：\n$$ \\int_{P_0}^{P(t)} \\frac{\\exp(\\beta P')}{P' - P_{\\text{ven}}} dP' = -\\int_{0}^{t} \\frac{ds}{RC_0} = -\\frac{t}{RC_0} $$\n左边的积分无法用初等函数表示。它涉及到指数积分函数 $\\text{Ei}(x)$。因此，直接实现 $P(t)$ 的解析解是不切实际的。所以，我们采用数值方法求解该 ODE。\n需要求解的 ODE 是：\n$$ \\frac{dP}{dt} = f(t, P) = -\\frac{P - P_{\\text{ven}}}{RC_0 \\exp(\\beta P)} $$\n初始条件为 $P(0) = P_0$。标准的数值 ODE 求解器，例如 `scipy.integrate.solve_ivp` 函数中可用的 Runge-Kutta 方法，非常适合这项任务。我们从 $t=0$ 积分到 $t=T_{\\text{d}}/2$ 来求得 $P_{\\text{nl}}(T_{\\text{d}}/2)$。\n\n当 $\\beta = 0$ 时会出现一个特殊情况。此时，非线性顺应性 $C(P) = C_0 \\exp(0) = C_0$，这与线性顺应性模型完全相同。因此，对于 $\\beta=0$，解 $P_{\\text{nl}}(t)$ 必须等于 $P_{\\text{lin}}(t)$，从而 $\\Delta = P_{\\text{nl}}(T_{\\text{d}}/2) - P_{\\text{lin}}(T_{\\text{d}}/2)$ 必须为 $0$。这是一个重要的验证点。\n\n**计算步骤：**\n对于每个给定的测试用例 $(R, C_0, \\beta, P_0, P_{\\text{ven}}, T_{\\text{d}})$：\n1.  使用推导出的解析公式计算 $P_{\\text{lin}}(T_{\\text{d}}/2)$。\n2.  如果 $\\beta = 0$，则设 $P_{\\text{nl}}(T_{\\text{d}}/2) = P_{\\text{lin}}(T_{\\text{d}}/2)$。\n3.  如果 $\\beta > 0$，则对非线性 ODE 从 $t=0$ 到 $t=T_{\\text{d}}/2$ 进行数值积分，初始条件为 $P(0)=P_0$，以求得 $P_{\\text{nl}}(T_{\\text{d}}/2)$。\n4.  计算差值 $\\Delta = P_{\\text{nl}}(T_{\\text{d}}/2) - P_{\\text{lin}}(T_{\\text{d}}/2)$。\n5.  该测试用例的结果是列表 $[P_{\\text{lin}}(T_{\\text{d}}/2), P_{\\text{nl}}(T_{\\text{d}}/2), \\Delta]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Windkessel model for both linear and nonlinear compliance\n    and computes the pressures at t = Td/2.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (R, C0, beta, P0, P_ven, T_d)\n    test_cases = [\n        (1.10, 1.60, 0.015, 95.0, 5.0, 0.80),\n        (1.20, 1.40, 0.0, 100.0, 10.0, 0.70),\n        (0.80, 2.00, 0.020, 12.0, 10.0, 0.50),\n        (2.50, 0.80, 0.030, 110.0, 5.0, 1.00),\n        (1.00, 1.00, 0.010, 80.0, 5.0, 0.20),\n    ]\n\n    results = []\n\n    def nonlinear_ode(t, P, R, C0, beta, P_ven):\n        \"\"\"\n        Defines the ODE for the nonlinear Windkessel model.\n        dP/dt = -(P - P_ven) / (R * C(P))\n        where C(P) = C0 * exp(beta * P).\n        \"\"\"\n        pressure = P[0]\n        # The equation is valid for P > P_ven.\n        # The pressure naturally decays towards P_ven.\n        dPdt = -(pressure - P_ven) / (R * C0 * np.exp(beta * pressure))\n        return [dPdt]\n\n    for case in test_cases:\n        R, C0, beta, P0, P_ven, T_d = case\n        \n        t_eval_point = T_d / 2.0\n\n        # 1. Linear model calculation (analytical solution)\n        time_constant = R * C0\n        p_lin_half_td = P_ven + (P0 - P_ven) * np.exp(-t_eval_point / time_constant)\n\n        # 2. Nonlinear model calculation\n        if beta == 0.0:\n            # If beta is zero, the nonlinear model reduces to the linear model.\n            p_nl_half_td = p_lin_half_td\n        else:\n            # Use a numerical ODE solver for the nonlinear case.\n            # We solve from t=0 to t=t_eval_point.\n            sol = solve_ivp(\n                fun=nonlinear_ode,\n                t_span=(0, t_eval_point),\n                y0=[P0],\n                method='RK45',  # A robust general-purpose solver\n                t_eval=[t_eval_point], # Get solution only at the specified time\n                args=(R, C0, beta, P_ven)\n            )\n            p_nl_half_td = sol.y[0, 0]\n\n        # 3. Calculate the difference\n        delta = p_nl_half_td - p_lin_half_td\n        \n        results.append([p_lin_half_td, p_nl_half_td, delta])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists of floats, e.g., [[x1,y1,z1],[x2,y2,z2],...]\n    # We construct the string manually to avoid extra spaces from Python's default list-to-string conversion.\n    inner_results_str = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in results]\n    print(f\"[{','.join(inner_results_str)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "模型是用于特定目的的工具，选择合适的工具至关重要。最后的这个练习将演示如何改进模型的*结构*以捕捉特定的生理事件，例如动脉压力波中的重搏切迹。通过比较二元件和三元件模型的表现，你将学习到增加如特征阻抗（$Z_0$）等元件，如何显著提高模型复现系统动态中重要高频细节的能力 。",
            "id": "3938519",
            "problem": "一个关于动脉血压 Windkessel 表示的流动驱动推导与仿真问题。考虑一个集总参数动脉段，其模型可以是二元件 Windkessel（一个外周阻力与一个顺应性并联）或三元件 Windkessel（一个近端特征阻抗与一个外周阻力和一个顺应性的并联组合串联）。使用以下基本定律作为出发点：质量守恒定律和类似于欧姆定律的压力与流量之间的线性液压关系。具体来说，对于一个压力为 $p(t)$、顺应性为 $C$ 的顺应性腔室，其流入量为 $q_{\\text{in}}(t)$，流出量为 $q_{\\text{out}}(t)$，质量守恒定律表述为 $C \\,\\dfrac{dp}{dt} = q_{\\text{in}}(t) - q_{\\text{out}}(t)$。对于一个值为 $R$ 的电阻器，其线性液压关系表述为 $p = R\\,q$，其中 $p$ 是该电阻器两端的压降，$q$ 是流经它的流量，下游参考压力取为零。\n\n给定一个生理上合理的流入波形 $q_{\\text{in}}(t)$，它由一个收缩期分量和一个旨在模拟与主动脉瓣关闭相关的重搏切迹事件的短暂负脉冲组成：\n- 收缩期分量是在区间 $t \\in [0, T_s]$ 内峰值为 $Q_{\\max}$ 的半正弦波，具体为 $q_{\\text{sys}}(t) = Q_{\\max}\\,\\sin\\!\\left(\\pi t/T_s\\right)$（当 $0 \\le t \\le T_s$ 时），其他情况下 $q_{\\text{sys}}(t) = 0$。\n- 切迹分量是一个以时间 $t_n$ 为中心、标准差为 $\\sigma$、峰值幅度为 $A_{\\text{imp}}$ 的负高斯脉冲，具体为 $q_{\\text{notch}}(t) = -A_{\\text{imp}} \\exp\\!\\left(-\\dfrac{(t - t_n)^2}{2 \\sigma^2}\\right)$。\n- 总流入量为 $q_{\\text{in}}(t) = q_{\\text{sys}}(t) + q_{\\text{notch}}(t)$。\n\n从上述基础和定义出发，对这两个系统进行如下建模，不假设任何进一步的简化公式：\n- 二元件 Windkessel：一个外周阻力 $R$ 与一个顺应性 $C$ 并联。令 $p_a(t)$ 表示顺应性两端的动脉压。流出量为 $q_{\\text{out}}(t) = \\dfrac{p_a(t)}{R}$。在入口处观测到的压力等于 $p_{\\text{in,2}}(t) = p_a(t)$。\n- 三元件 Windkessel（阻性-顺应性-阻性 (RCR)）：一个近端特征阻抗 $Z_0$ 与相同的 $R$ 和 $C$ 组成的并联网络串联。同样的质量平衡控制 $p_a(t)$，观测到的入口压力为 $p_{\\text{in,3}}(t) = p_a(t) + Z_0\\,q_{\\text{in}}(t)$。\n\n实现一个时域仿真器，使用固定的时间步长 $\\Delta t$ 从 $t=0$ 到 $t=T_{\\text{end}}$，在给定的 $q_{\\text{in}}(t)$ 下对 $p_a(t)$ 的常微分方程进行数值积分，初始条件为 $p_a(0) = p_0$。所有物理单位必须一致：压力单位为毫米汞柱 (mmHg)，时间单位为秒 (s)，流量单位为毫升/秒 (mL/s)，电阻和特征阻抗单位为 $\\text{mmHg}\\cdot\\text{s}/\\text{mL}$，顺应性单位为 $\\text{mL}/\\text{mmHg}$。\n\n如下定义观测到的入口压力轨迹 $p_{\\text{obs}}(t)$ 中的重搏切迹振幅。设切迹分析窗口为 $[t_n - \\Delta_1, t_n + \\Delta_2]$，其中切迹前基线子窗口为 $[t_n - \\Delta_1, t_n - \\delta]$，切迹后搜索子窗口为 $[t_n, t_n + \\Delta_2]$，其中 $\\Delta_1 > \\delta > 0$ 且 $\\Delta_2 > 0$。令 $p_{\\text{base}}$ 为 $p_{\\text{obs}}(t)$ 在 $[t_n - \\Delta_1, t_n - \\delta]$ 上的平均值，令 $p_{\\min}$ 为 $p_{\\text{obs}}(t)$ 在 $[t_n, t_n + \\Delta_2]$ 上的最小值。切迹振幅为 $A_{\\text{notch}} = p_{\\text{base}} - p_{\\min}$，单位为毫米汞柱 (mmHg)。您必须从 $p_{\\text{in,2}}(t)$ 计算 $A_{\\text{notch,2}}$，从 $p_{\\text{in,3}}(t)$ 计算 $A_{\\text{notch,3}}$。\n\n您的任务是：\n1. 对于二元件和三元件系统，在给定的 $q_{\\text{in}}(t)$ 下，从所述的基本定律推导出 $p_a(t)$ 的控制常微分方程。\n2. 实现一个数值仿真器，计算 $p_{\\text{in,2}}(t)$ 和 $p_{\\text{in,3}}(t)$，然后为一组测试用例评估 $A_{\\text{notch,2}}$ 和 $A_{\\text{notch,3}}$。\n3. 对于每个测试用例，按如下规定生成一个标量结果。您必须将任何压力振幅表示为毫米汞柱 (mmHg)，四舍五入到六位小数。任何不等式检查必须返回一个布尔值。\n\n除非在特定测试用例中被覆盖，否则使用以下固定的仿真和分析设置：时间步长 $\\Delta t = 10^{-4}\\,\\text{s}$，结束时间 $T_{\\text{end}} = 1.0\\,\\text{s}$，初始压力 $p_0 = 80.0\\,\\text{mmHg}$，收缩期持续时间 $T_s = 0.3\\,\\text{s}$，切迹中心时间 $t_n = 0.31\\,\\text{s}$，切迹前窗口参数 $\\Delta_1 = 0.015\\,\\text{s}$ 和 $\\delta = 0.005\\,\\text{s}$，以及切迹后窗口参数 $\\Delta_2 = 0.020\\,\\text{s}$。\n\n使用以下测试套件。每个测试用例指定 $(R, C, Z_0, Q_{\\max}, A_{\\text{imp}}, \\sigma)$，单位如上所述一致：\n- 测试用例 1（$Z_0 = 0$ 时的边界一致性）：$(1.2, 1.5, 0.0, 300.0, 20.0, 0.004)$。输出绝对差 $|A_{\\text{notch,3}} - A_{\\text{notch,2}}|$，单位为 mmHg，四舍五入到六位小数。\n- 测试用例 2（三元件模型的基本增强效果）：$(1.2, 1.5, 0.15, 300.0, 20.0, 0.004)$。输出不等式 $A_{\\text{notch,3}} > A_{\\text{notch,2}}$ 的布尔值。\n- 测试用例 3（随脉冲幅度缩放）：计算两种情景，其 $(R, C, Z_0, Q_{\\max}, \\sigma)$ 相同，为 $(1.2, 1.5, 0.15, 300.0, 0.004)$，但 $A_{\\text{imp}}$ 值不同，分别为 $20.0$ 和 $40.0$。输出不等式 $\\left(A_{\\text{notch,3}} - A_{\\text{notch,2}}\\right)\\big|_{A_{\\text{imp}}=40.0} > \\left(A_{\\text{notch,3}} - A_{\\text{notch,2}}\\right)\\big|_{A_{\\text{imp}}=20.0}$ 的布尔值。\n- 测试用例 4（随近端特征阻抗缩放）：计算两种情景，其 $(R, C, Q_{\\max}, A_{\\text{imp}}, \\sigma)$ 相同，为 $(1.2, 1.5, 300.0, 25.0, 0.004)$，但 $Z_0$ 值不同，分别为 $0.05$ 和 $0.20$。输出不等式 $\\left(A_{\\text{notch,3}} - A_{\\text{notch,2}}\\right)\\big|_{Z_0=0.20} > \\left(A_{\\text{notch,3}} - A_{\\text{notch,2}}\\right)\\big|_{Z_0=0.05}$ 的布尔值。\n- 测试用例 5（对切迹持续时间的敏感性）：计算两种情景，其 $(R, C, Z_0, Q_{\\max}, A_{\\text{imp}})$ 相同，为 $(1.2, 1.5, 0.15, 300.0, 30.0)$，但 $\\sigma$ 值不同，分别为 $0.002$ 和 $0.008$。输出不等式 $\\left(A_{\\text{notch,3}} - A_{\\text{notch,2}}\\right)\\big|_{\\sigma=0.002} > \\left(A_{\\text{notch,3}} - A_{\\text{notch,2}}\\right)\\big|_{\\sigma=0.008}$ 的布尔值。\n\n您的程序应生成单行输出，其中包含测试 1 到 5 的结果，以逗号分隔的列表形式包含在方括号内，顺序为：$[r_1,r_2,r_3,r_4,r_5]$，其中 $r_1$ 是一个单位为毫米汞柱 (mmHg) 的浮点数，四舍五入到六位小数，而 $r_2$ 到 $r_5$ 是布尔值。",
            "solution": "该问题要求推导二元件和三元件 Windkessel 模型中动脉压的控制常微分方程 (ODE)，然后通过数值仿真分析在指定流入波形下的重搏切迹特征。推导和仿真过程详述如下。\n\n### I. 控制微分方程的推导\n\n问题提供了集总参数液压电路的基本定律。对于顺应性元件，质量守恒定律由下式给出：\n$$\nC \\frac{dp_a(t)}{dt} = q_{\\text{in}}(t) - q_{\\text{out}}(t)\n$$\n其中 $p_a(t)$ 是顺应性 $C$ 两端的压力，$q_{\\text{in}}(t)$ 是流入量，$q_{\\text{out}}(t)$ 是流出量。\n\n对于下游压力为零的电阻器 $R$，欧姆定律的液压等效形式为：\n$$\np_a(t) = R \\cdot q_{\\text{out}}(t)\n$$\n该关系成立，因为外周阻力 $R$ 与顺应性 $C$ 并联，这意味着两个元件两端的压降相同，均为 $p_a(t)$。\n\n从欧姆定律，我们可以将流出量 $q_{\\text{out}}(t)$ 表示为：\n$$\nq_{\\text{out}}(t) = \\frac{p_a(t)}{R}\n$$\n\n将这个 $q_{\\text{out}}(t)$ 的表达式代入质量守恒方程，得到：\n$$\nC \\frac{dp_a(t)}{dt} = q_{\\text{in}}(t) - \\frac{p_a(t)}{R}\n$$\n\n为了得到一阶线性常微分方程的标准形式，我们整理各项：\n$$\n\\frac{dp_a(t)}{dt} + \\frac{1}{RC} p_a(t) = \\frac{1}{C} q_{\\text{in}}(t)\n$$\n\n这个常微分方程控制着顺应性元件中的压力 $p_a(t)$。至关重要的是，该方程对于所指定的二元件和三元件 Windkessel 模型是完全相同的。模型之间的区别在于*观测*入口压力的定义。\n\n流入量 $q_{\\text{in}}(t)$ 是收缩期分量 $q_{\\text{sys}}(t)$ 和切迹分量 $q_{\\text{notch}}(t)$ 的和：\n$$\nq_{\\text{in}}(t) = q_{\\text{sys}}(t) + q_{\\text{notch}}(t)\n$$\n其中\n$$\nq_{\\text{sys}}(t) = \n\\begin{cases} \nQ_{\\max}\\sin\\left(\\frac{\\pi t}{T_s}\\right)  \\text{for } 0 \\le t \\le T_s \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n并且\n$$\nq_{\\text{notch}}(t) = -A_{\\text{imp}} \\exp\\left(-\\frac{(t - t_n)^2}{2 \\sigma^2}\\right)\n$$\n\n两种模型的观测入口压力为：\n-   **二元件模型**：入口压力就是并联 RC 电路两端的压力。\n    $$\n    p_{\\text{in,2}}(t) = p_a(t)\n    $$\n-   **三元件模型**：入口压力是并联 RC 电路两端的压力与近端特征阻抗 $Z_0$ 两端压降之和。\n    $$\n    p_{\\text{in,3}}(t) = p_a(t) + Z_0 \\cdot q_{\\text{in}}(t)\n    $$\n\n### II. 数值仿真与分析\n\n该问题是一个初值问题，包含 $p_a(t)$ 的常微分方程和初始条件 $p_a(0) = p_0$。我们将使用前向欧拉法，根据指定的固定时间步长 $\\Delta t$ 对其进行数值求解。\n\n导数 $\\frac{dp_a}{dt}$ 可以写成：\n$$\n\\frac{dp_a}{dt} = f(t, p_a) = \\frac{1}{C} q_{\\text{in}}(t) - \\frac{1}{RC} p_a(t)\n$$\n\n从时间步 $t_i$ 到 $t_{i+1} = t_i + \\Delta t$ 的前向欧拉更新规则是：\n$$\np_a(t_{i+1}) \\approx p_a(t_i) + \\Delta t \\cdot f(t_i, p_a(t_i))\n$$\n代入 $f(t_i, p_a(t_i))$ 的表达式，我们得到离散时间更新方程：\n$$\np_a(t_{i+1}) = p_a(t_i) + \\Delta t \\left( \\frac{1}{C} q_{\\text{in}}(t_i) - \\frac{1}{RC} p_a(t_i) \\right)\n$$\n为了计算效率，可以重新排列为：\n$$\np_a(t_{i+1}) = p_a(t_i) \\left(1 - \\frac{\\Delta t}{RC}\\right) + \\frac{\\Delta t}{C} q_{\\text{in}}(t_i)\n$$\n\n仿真过程如下：\n1.  将时间轴从 $t=0$ 到 $t=T_{\\text{end}}$ 以步长 $\\Delta t$ 离散化。令时间点为 $t_i = i \\cdot \\Delta t$。\n2.  预先计算所有时间点 $t_i$ 的流入向量 $q_{\\text{in}}(t_i)$。\n3.  用 $p_a(t_0=0) = p_0$ 初始化压力向量 $p_a$。\n4.  对于 $i=0, 1, 2, \\dots$，使用欧拉更新规则迭代计算 $p_a(t_{i+1})$，直到时间区间结束。\n5.  一旦计算出 $p_a(t)$ 的时间序列，使用各自的定义计算观测压力轨迹 $p_{\\text{in,2}}(t)$ 和 $p_{\\text{in,3}}(t)$。\n\n### III. 重搏切迹振幅计算\n\n重搏切迹振幅 $A_{\\text{notch}}$ 是从一个观测压力轨迹 $p_{\\text{obs}}(t)$（它将是 $p_{\\text{in,2}}(t)$ 或 $p_{\\text{in,3}}(t)$）计算得出的。\n1.  将切迹前基线窗口定义为 $[t_n - \\Delta_1, t_n - \\delta]$。基线压力 $p_{\\text{base}}$ 是 $p_{\\text{obs}}(t)$ 在此窗口内的平均值。\n2.  将切迹后搜索窗口定义为 $[t_n, t_n + \\Delta_2]$。最小压力 $p_{\\min}$ 是 $p_{\\text{obs}}(t)$ 在此窗口内的最小值。\n3.  切迹振幅是差值：$A_{\\text{notch}} = p_{\\text{base}} - p_{\\min}$。\n\n这整个过程——仿真和分析——被封装在一个函数中，该函数将模型和仿真参数作为输入。然后为五个测试用例中的每一个调用此函数，以计算指定的结果。\n\n对于测试用例 1，其中 $Z_0=0.0$，我们预期 $p_{\\text{in,3}}(t) = p_a(t) + 0.0 \\cdot q_{\\text{in}}(t) = p_a(t) = p_{\\text{in,2}}(t)$。因此，它们的切迹振幅 $A_{\\text{notch,3}}$ 和 $A_{\\text{notch,2}}$ 必须相同，其绝对差应为零（或由于有限浮点精度而非常接近零的值）。这可以作为对实现逻辑的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Windkessel model simulations for all test cases.\n    \"\"\"\n\n    def simulate_and_analyze(R, C, Z0, Q_max, A_imp, sigma):\n        \"\"\"\n        Performs a single simulation run for given parameters and calculates notch amplitudes.\n\n        Args:\n            R (float): Peripheral resistance (mmHg*s/mL).\n            C (float): Arterial compliance (mL/mmHg).\n            Z0 (float): Characteristic impedance (mmHg*s/mL).\n            Q_max (float): Peak systolic flow (mL/s).\n            A_imp (float): Peak magnitude of the negative notch impulse (mL/s).\n            sigma (float): Standard deviation of the Gaussian notch impulse (s).\n\n        Returns:\n            tuple[float, float]: A tuple containing the notch amplitudes for the 2-element\n                                 and 3-element models (A_notch_2, A_notch_3).\n        \"\"\"\n        # Fixed simulation and analysis parameters\n        dt = 1e-4          # s\n        T_end = 1.0        # s\n        p0 = 80.0          # mmHg\n        Ts = 0.3           # s\n        tn = 0.31          # s\n        delta1 = 0.015     # s\n        delta_ = 0.005     # s\n        delta2 = 0.020     # s\n\n        # Time vector\n        t = np.arange(0, T_end, dt)\n        num_steps = len(t)\n\n        # Inflow q_in(t) calculation\n        q_sys = np.zeros(num_steps)\n        systolic_indices = t <= Ts\n        q_sys[systolic_indices] = Q_max * np.sin(np.pi * t[systolic_indices] / Ts)\n        q_notch = -A_imp * np.exp(-((t - tn)**2) / (2 * sigma**2))\n        q_in = q_sys + q_notch\n\n        # Numerical integration using Forward Euler method\n        pa = np.zeros(num_steps)\n        pa[0] = p0\n\n        # Pre-calculate constants for the loop\n        # pa[i+1] = pa[i] * (1 - dt/(R*C)) + (dt/C) * q_in[i]\n        euler_coeff_p = 1 - dt / (R * C)\n        euler_coeff_q = dt / C\n        \n        for i in range(num_steps - 1):\n            pa[i+1] = pa[i] * euler_coeff_p + euler_coeff_q * q_in[i]\n\n        # Calculate observed pressures for 2-element and 3-element models\n        p_in2 = pa\n        p_in3 = pa + Z0 * q_in\n\n        # Function to calculate notch amplitude\n        def calculate_notch_amplitude(p_obs):\n            # Find indices for analysis windows\n            idx_tn = np.searchsorted(t, tn)\n            idx_pre_start = np.searchsorted(t, tn - delta1)\n            idx_pre_end = np.searchsorted(t, tn - delta_)\n            idx_post_end = np.searchsorted(t, tn + delta2)\n\n            # Calculate p_base and p_min\n            p_base = np.mean(p_obs[idx_pre_start : idx_pre_end])\n            p_min = np.min(p_obs[idx_tn : idx_post_end])\n            \n            return p_base - p_min\n\n        A_notch_2 = calculate_notch_amplitude(p_in2)\n        A_notch_3 = calculate_notch_amplitude(p_in3)\n\n        return A_notch_2, A_notch_3\n\n    results = []\n\n    # Test Case 1: Boundary consistency when Z0 = 0\n    R, C, Z0, Q_max, A_imp, sigma = (1.2, 1.5, 0.0, 300.0, 20.0, 0.004)\n    A2, A3 = simulate_and_analyze(R, C, Z0, Q_max, A_imp, sigma)\n    results.append(round(abs(A3 - A2), 6))\n\n    # Test Case 2: Basic enhancement by three-element model\n    R, C, Z0, Q_max, A_imp, sigma = (1.2, 1.5, 0.15, 300.0, 20.0, 0.004)\n    A2, A3 = simulate_and_analyze(R, C, Z0, Q_max, A_imp, sigma)\n    results.append(A3 > A2)\n    \n    # Test Case 3: Scaling with impulse magnitude\n    R_tc3, C_tc3, Z0_tc3, Q_max_tc3, sigma_tc3 = (1.2, 1.5, 0.15, 300.0, 0.004)\n    A_imp_1, A_imp_2 = 20.0, 40.0\n    A2_1, A3_1 = simulate_and_analyze(R_tc3, C_tc3, Z0_tc3, Q_max_tc3, A_imp_1, sigma_tc3)\n    A2_2, A3_2 = simulate_and_analyze(R_tc3, C_tc3, Z0_tc3, Q_max_tc3, A_imp_2, sigma_tc3)\n    diff_1 = A3_1 - A2_1\n    diff_2 = A3_2 - A2_2\n    results.append(diff_2 > diff_1)\n\n    # Test Case 4: Scaling with proximal characteristic impedance\n    R_tc4, C_tc4, Q_max_tc4, A_imp_tc4, sigma_tc4 = (1.2, 1.5, 300.0, 25.0, 0.004)\n    Z0_1, Z0_2 = 0.05, 0.20\n    A2_1, A3_1 = simulate_and_analyze(R_tc4, C_tc4, Z0_1, Q_max_tc4, A_imp_tc4, sigma_tc4)\n    A2_2, A3_2 = simulate_and_analyze(R_tc4, C_tc4, Z0_2, Q_max_tc4, A_imp_tc4, sigma_tc4)\n    diff_1 = A3_1 - A2_1\n    diff_2 = A3_2 - A2_2\n    results.append(diff_2 > diff_1)\n\n    # Test Case 5: Sensitivity to notch duration\n    R_tc5, C_tc5, Z0_tc5, Q_max_tc5, A_imp_tc5 = (1.2, 1.5, 0.15, 300.0, 30.0)\n    sigma_1, sigma_2 = 0.002, 0.008\n    A2_1, A3_1 = simulate_and_analyze(R_tc5, C_tc5, Z0_tc5, Q_max_tc5, A_imp_tc5, sigma_1)\n    A2_2, A3_2 = simulate_and_analyze(R_tc5, C_tc5, Z0_tc5, Q_max_tc5, A_imp_tc5, sigma_2)\n    diff_1 = A3_1 - A2_1\n    diff_2 = A3_2 - A2_2\n    results.append(diff_1 > diff_2)\n\n    # Format the final output string\n    # Convert booleans to lowercase 'true'/'false' for consistency\n    formatted_results = [f\"{r:.6f}\" if isinstance(r, float) else str(r).lower() for r in results]\n    output_str = f\"[{','.join(formatted_results)}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}