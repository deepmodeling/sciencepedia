{
    "hands_on_practices": [
        {
            "introduction": "模型验证的第一步是量化其预测与真实观测值之间的差异。本练习将引导您计算两个最基本的回归误差指标：均方根误差（RMSE）和平均绝对误差（MAE）。通过在包含不同误差特征（包括异常值）的假设场景中应用这些指标，您将亲身体会到它们对大误差的不同敏感性，并学习如何基于误差分布的稳健统计特性，为您的模型选择最合适的评估指标。",
            "id": "3904284",
            "problem": "您正在使用基于原则的误差度量，在生物医学系统建模中验证一个药代动力学浓度模型。考虑一个单室静脉推注模型，其血浆浓度预测由基准公式 $C(t) = C_0 e^{-k t}$ 给出，其中 $C_0$ 是初始浓度，$k$ 是消除速率常数。模型预测值将与测量浓度进行比较。将残差定义为 $r_i = y_i - \\hat{y}_i$，其中 $\\hat{y}_i$ 是预测浓度，$y_i$ 是在时间 $t_i$ 的测量浓度。使用均方根误差和平均绝对误差的标准定义来量化差异。所有与浓度相关的量均以毫克/升 (mg/L) 表示。\n\n从具有独立残差 $\\varepsilon_i$ 的标准测量模型 $y_i = \\hat{y}_i + \\varepsilon_i$ 出发，您的程序必须为每个测试用例计算：\n- 在所提供的时间点上的均方根误差 (RMSE)，单位为 mg/L。\n- 在所提供的时间点上的平均绝对误差 (MAE)，单位为 mg/L。\n- 敏感度比率 $R$，定义为 $R = \\text{RMSE} / \\text{MAE}$，以浮点数形式报告。如果 $\\text{MAE} = 0$，则设 $R = 0.0$。\n- 一个离群值影响指标，解释为布尔值，计算如下。定义稳健尺度估计 $s_{\\text{MAD}} = \\text{median}(|r_i - \\text{median}(r)|)$，并令 $I = \\max_i |r_i| / (s_{\\text{MAD}} + \\epsilon)$，其中 $\\epsilon = 10^{-12}$。如果 $I > 6$，则将“存在强离群值”分类为真，否则为假。\n- 一个作为整数的度量选择代码，由残差的统计建模证明其合理性：如果有重尾或离群值的证据，推荐的验证度量是平均绝对误差 (MAE)，则输出 $0$；如果条件与 Gaussian 残差一致，推荐的验证度量是均方根误差 (RMSE)，则输出 $1$。尽管其基本原理基于最大似然一致性和稳健性，但仍必须生成这些数字代码；其原理将在解答中解释。\n\n使用以下科学上真实的测试套件。所有浓度单位为 mg/L，所有时间单位为小时。预测参数为 $C_0 = 4$ 和 $k = 0.25$，时间点为 $t \\in \\{\\,0,1,2,3,4,5,6,7,8,9\\,\\}$。预测值计算为 $\\hat{y}_i = C_0 e^{-k t_i}$，测量值使用指定的残差 $r_i$ 构建为 $y_i = \\hat{y}_i + r_i$：\n\n- 用例 A（理想情况，类似高斯分布的小偏差）：残差 $r^{(A)} = [0.05, -0.04, 0.02, -0.03, 0.01, -0.02, 0.00, 0.03, -0.01, 0.02]$。\n- 用例 B（单个大离群值）：残差 $r^{(B)} = [0.05, -0.04, 0.02, -0.03, 0.01, 2.50, 0.00, 0.03, -0.01, 0.02]$。\n- 用例 C（重尾残差模式）：残差 $r^{(C)} = [0.10, -0.08, 0.06, -0.05, 0.00, 0.00, 0.30, -0.40, 0.50, -0.30]$。\n- 用例 D（边界情况，零误差）：残差 $r^{(D)} = [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]$。\n- 用例 E（边缘情况，单时间点，严重偏差）：使用 $t = [2]$，预测值 $\\hat{y} = C_0 e^{-k \\cdot 2}$，以及残差 $r^{(E)} = [4.50]$。\n\n您的程序必须根据指定的 $C_0$、$k$ 和 $t$ 为每个用例构建预测值 $\\hat{y}_i$，添加相应的残差以形成测量值 $y_i$，从构建的 $y_i$ 和 $\\hat{y}_i$ 计算残差 $r_i$，然后按上述要求计算输出。\n\n最终输出格式要求：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是一个包含五项的列表，顺序为 $[\\,\\text{RMSE}, \\text{MAE}, R, \\text{outlier\\_boolean}, \\text{metric\\_code}\\,]$。将用例 A、B、C、D、E 的结果按顺序聚合到一个外部列表中。例如，总输出格式为 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$。",
            "solution": "问题陈述已经过严格验证，被认为是合理的。它具有科学依据、提法恰当、客观且内部一致。为获得唯一且有意义的解，所有必要的数据、模型和定义均已提供。因此，我们可以着手提供完整的解答。\n\n该问题要求计算几种误差度量，以根据合成测量数据验证药代动力学模型。这是生物医学系统建模中的一项基本任务，其目标是量化模型预测与实验观察之间的差异。\n\n所考虑的模型是单室静脉 (IV) 推注模型，它描述了快速注射后药物在时间 $t$ 的血浆浓度 $C(t)$。其控制方程为：\n$$\nC(t) = C_0 e^{-k t}\n$$\n其中 $C_0$ 是在 $t=0$ 时的初始浓度，$k$ 是一级消除速率常数。对于此问题，给定 $C_0 = 4 \\, \\text{mg/L}$ 和 $k = 0.25 \\, \\text{hr}^{-1}$。\n\n模型的预测值，记为 $\\hat{y}_i$，是在特定时间点 $t_i$ 计算的。相应的实验测量值记为 $y_i$。模型验证的核心在于分析残差 $r_i$，其定义为观测值与预测值之差：\n$$\nr_i = y_i - \\hat{y}_i\n$$\n问题为五个不同的测试用例指定了确切的残差。尽管问题指示我们首先构建预测值 $\\hat{y}_i$，然后是测量值 $y_i = \\hat{y}_i + r_i$，最后重新计算残差，但这最后一步只是返回了最初给定的残差，因为 $y_i - \\hat{y}_i = (\\hat{y}_i + r_i) - \\hat{y}_i = r_i$。这个过程仅仅是为了确认设置的一致性。分析将基于这些残差进行。\n\n我们需要为每个用例计算五个量：\n\n1.  **均方根误差 (RMSE):** 该度量衡量的是残差平方均值的平方根。由于平方项的存在，它对大误差（离群值）很敏感。\n    $$\n    \\text{RMSE} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} r_i^2}\n    $$\n2.  **平均绝对误差 (MAE):** 该度量衡量的是残差绝对值的平均值。与 RMSE 相比，它对离群值不那么敏感。\n    $$\n    \\text{MAE} = \\frac{1}{n} \\sum_{i=1}^{n} |r_i|\n    $$\n3.  **敏感度比率 ($R$):** 定义为 $R = \\text{RMSE} / \\text{MAE}$，该比率有助于深入了解误差的分布。对于单个误差，$R=1$。对于多个误差，$R \\ge 1$。一个远大于 $1$ 的 $R$ 值表明存在大的离群值，这些离群值不成比例地放大了 RMSE。如果 $\\text{MAE} = 0$，则所有残差均为零，因此 RMSE 也为零，我们定义 $R=0.0$。\n\n4.  **离群值影响指标:** 这个布尔值是使用一种稳健的统计方法确定的。首先，我们计算中位数绝对偏差 ($s_{\\text{MAD}}$)，这是一种统计离散度的稳健估计量：\n    $$\n    s_{\\text{MAD}} = \\text{median}(|r_i - \\text{median}(r)|)\n    $$\n    接下来，我们计算一个影响分数 $I$，它将最大绝对残差与这个稳健尺度估计进行比较：\n    $$\n    I = \\frac{\\max_i |r_i|}{s_{\\text{MAD}} + \\epsilon}\n    $$\n    其中 $\\epsilon=10^{-12}$ 是一个防止除以零的小常数。一个大的 $I$ 值表示最大误差比典型误差幅度大很多倍。问题将标记“存在强离群值”的阈值设置为 $I > 6$。\n\n5.  **度量选择代码:** 这个整数代码（$0$ 或 $1$）为模型验证选择更合适的误差度量（MAE 或 RMSE）提供了一个有原则的建议。其理由源于最大似然估计 (MLE) 的原理。当假设残差遵循 Gaussian（正态）分布时，最小化误差平方和（从而最小化 RMSE）对应于模型参数的 MLE 解。当假设残差遵循 Laplace 分布时，最小化绝对误差和 (MAE) 对应于 MLE 解，Laplace 分布比 Gaussian 分布具有“更重的尾部”，因此对离群值更具容忍性。\n    -   **代码 1 (RMSE):** 当残差与 Gaussian 分布一致（即没有显著离群值）时推荐使用。\n    -   **代码 0 (MAE):** 当有证据表明存在重尾或显著离群值时推荐使用，此时 Laplace 假设更为合适，MAE 是一个更稳健的度量。\n    该决策基于离群值影响指标：如果`存在强离群值`为真，我们选择代码 $0$；否则，我们选择代码 $1$。\n\n现在我们将这些计算应用于每个测试用例。\n\n**用例 A：类似高斯分布的小偏差**\n-   $r^{(A)} = [0.05, -0.04, 0.02, -0.03, 0.01, -0.02, 0.00, 0.03, -0.01, 0.02]$\n-   $\\sum r_i^2 = 0.0073$, $n=10$。 $\\text{RMSE} = \\sqrt{0.0073/10} = \\sqrt{0.00073} \\approx 0.0270185$。\n-   $\\sum |r_i| = 0.23$。 $\\text{MAE} = 0.23/10 = 0.023$。\n-   $R = 0.0270185 / 0.023 \\approx 1.174718$。\n-   $\\text{median}(r) = 0.005$。 $s_{\\text{MAD}} = \\text{median}(\\{|0.045, -0.045, \\dots|\\}) = 0.02$。\n-   $\\max|r_i| = 0.05$。 $I = 0.05 / (0.02 + 10^{-12}) = 2.5$。\n-   离群值指标：$I \\le 6$，所以为 `假`。\n-   度量代码：`1`。\n-   结果：$[0.0270185, 0.023, 1.174718, \\text{False}, 1]$\n\n**用例 B：单个大离群值**\n-   $r^{(B)} = [0.05, -0.04, 0.02, -0.03, 0.01, 2.50, 0.00, 0.03, -0.01, 0.02]$\n-   $\\sum r_i^2 = (0.0073 - (-0.02)^2) + 2.5^2 = 6.2569$。 $\\text{RMSE} = \\sqrt{6.2569/10} \\approx 0.791005$。\n-   $\\sum |r_i| = (0.23 - |-0.02|) + 2.5 = 2.71$。 $\\text{MAE} = 2.71/10 = 0.271$。\n-   $R = 0.791005 / 0.271 \\approx 2.91884$。\n-   $\\text{median}(r) = 0.015$。 $s_{\\text{MAD}} = 0.02$。\n-   $\\max|r_i| = 2.50$。 $I = 2.50 / (0.02 + 10^{-12}) = 125.0$。\n-   离群值指标：$I > 6$，所以为 `真`。\n-   度量代码：`0`。\n-   结果：$[0.791005, 0.271, 2.91884, \\text{True}, 0]$\n\n**用例 C：重尾残差模式**\n-   $r^{(C)} = [0.10, -0.08, 0.06, -0.05, 0.00, 0.00, 0.30, -0.40, 0.50, -0.30]$\n-   $\\sum r_i^2 = 0.5594$。 $\\text{RMSE} = \\sqrt{0.5594/10} \\approx 0.236516$。\n-   $\\sum |r_i| = 1.79$。 $\\text{MAE} = 1.79/10 = 0.179$。\n-   $R = 0.236516 / 0.179 \\approx 1.321319$。\n-   $\\text{median}(r) = 0.00$。 $s_{\\text{MAD}} = \\text{median}(\\{|r_i|\\}) = \\text{median}([0,0,0.05,0.06,0.08,0.1,0.3,0.3,0.4,0.5]) = (0.08+0.1)/2 = 0.09$。\n-   $\\max|r_i| = 0.50$。 $I = 0.50 / (0.09 + 10^{-12}) \\approx 5.555...$。\n-   离群值指标：$I \\le 6$，所以为 `假`。\n-   度量代码：`1`。\n-   结果：$[0.236516, 0.179, 1.321319, \\text{False}, 1]$\n\n**用例 D：零误差**\n-   $r^{(D)} = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$\n-   $\\text{RMSE} = 0.0$。\n-   $\\text{MAE} = 0.0$。\n-   $R = 0.0$ (按定义)。\n-   $\\text{median}(r) = 0$。 $s_{\\text{MAD}} = 0$。\n-   $\\max|r_i| = 0$。 $I = 0 / (0 + 10^{-12}) = 0.0$。\n-   离群值指标：$I \\le 6$，所以为 `假`。\n-   度量代码：`1`。\n-   结果：$[0.0, 0.0, 0.0, \\text{False}, 1]$\n\n**用例 E：单时间点，严重偏差**\n-   $r^{(E)} = [4.50]$, $n=1$。\n-   $\\text{RMSE} = \\sqrt{4.5^2} = 4.5$。\n-   $\\text{MAE} = |4.5| = 4.5$。\n-   $R = 4.5 / 4.5 = 1.0$。\n-   $\\text{median}(r) = 4.5$。 $s_{\\text{MAD}} = \\text{median}(|4.5 - 4.5|) = 0$。\n-   $\\max|r_i| = 4.5$。 $I = 4.5 / (0 + 10^{-12}) = 4.5 \\times 10^{12}$。\n-   离群值指标：$I > 6$，所以为 `真`。\n-   度量代码：`0`。\n-   结果：$[4.5, 4.5, 1.0, \\text{True}, 0]$\n\n这些结果将由提供的 Python 代码生成，并遵循指定的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a pharmacokinetic model by computing error metrics for several test cases.\n    \"\"\"\n\n    # Model parameters and constants\n    C0 = 4.0  # mg/L\n    k = 0.25  # hr^-1\n    epsilon = 1e-12\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (time_points, residuals).\n    test_cases = [\n        # Case A: Happy path, small Gaussian-like deviations\n        (np.arange(10), \n         np.array([0.05, -0.04, 0.02, -0.03, 0.01, -0.02, 0.00, 0.03, -0.01, 0.02])),\n        \n        # Case B: Single large outlier\n        (np.arange(10), \n         np.array([0.05, -0.04, 0.02, -0.03, 0.01, 2.50, 0.00, 0.03, -0.01, 0.02])),\n        \n        # Case C: Heavy-tailed residual pattern\n        (np.arange(10), \n         np.array([0.10, -0.08, 0.06, -0.05, 0.00, 0.00, 0.30, -0.40, 0.50, -0.30])),\n        \n        # Case D: Boundary, zero error\n        (np.arange(10), \n         np.array([0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00])),\n        \n        # Case E: Edge, single time point, severe deviation\n        (np.array([2.0]), \n         np.array([4.50]))\n    ]\n\n    all_results = []\n    \n    for t_points, r_given in test_cases:\n        # Per the problem description, construct predictions and measurements to get residuals.\n        # This step is formally required, though it just returns the provided residuals.\n        y_hat = C0 * np.exp(-k * t_points)\n        y_measured = y_hat + r_given\n        r = y_measured - y_hat\n\n        # 1. Compute Root Mean Square Error (RMSE)\n        rmse = np.sqrt(np.mean(r**2))\n\n        # 2. Compute Mean Absolute Error (MAE)\n        mae = np.mean(np.abs(r))\n\n        # 3. Compute Ratio R\n        # Handles the case where MAE is 0 to avoid division by zero.\n        ratio_r = rmse / mae if mae > 0 else 0.0\n\n        # 4. Compute Outlier Influence Indicator\n        median_r = np.median(r)\n        s_mad = np.median(np.abs(r - median_r))\n        max_abs_r = np.max(np.abs(r))\n        \n        # The influence score I\n        influence_score = max_abs_r / (s_mad + epsilon)\n        \n        # Classify as True if I > 6\n        heavy_outliers_present = influence_score > 6\n\n        # 5. Compute Metric Selection Code\n        # Code 0 for MAE (if outliers), Code 1 for RMSE (otherwise)\n        metric_code = 0 if heavy_outliers_present else 1\n\n        case_result = [\n            rmse,\n            mae,\n            ratio_r,\n            heavy_outliers_present,\n            metric_code\n        ]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # Custom formatting to match the example output style exactly.\n    result_str = \"[\"\n    for i, res in enumerate(all_results):\n        # Format: [float, float, float, Boolean, int]\n        # Python's bool __str__ is 'True' or 'False' which is standard.\n        res_list_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]}]\"\n        result_str += res_list_str\n        if i  len(all_results) - 1:\n            result_str += \",\"\n    result_str += \"]\"\n    \n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在生物医学领域，许多模型用于分类任务，例如诊断疾病。当处理罕见事件（如罕见病筛查）时，传统的评估指标可能会产生误导。本练习将深入探讨受试者工作特征（ROC）曲线和精确率-召回率（PR）曲线的优劣，特别是在类别极不平衡的情况下，帮助您理解为什么精确率（即阳性预测值）和PR曲线能更好地反映模型的临床实用价值。",
            "id": "3904290",
            "problem": "一个二元分类器被训练用于在筛查人群中检测一种罕见疾病。该疾病的患病率为 $p \\ll 1$。分类器输出一个连续的风险评分 $s(x) \\in [0,1]$，并且通过一个决策阈值 $\\tau$ 产生二元预测。验证在一个大小为 $N$ 的大规模队列上进行，其中真阳性、假阳性、真阴性和假阴性的数量根据给定阈值 $\\tau$ 的混淆矩阵定义得出。\n\n基本定义：\n-   真阳性率（TPR，灵敏度）为 $\\mathrm{TPR}(\\tau) = \\Pr(\\hat{Y}=1 \\mid Y=1)$。\n-   假阳性率（FPR）为 $\\mathrm{FPR}(\\tau) = \\Pr(\\hat{Y}=1 \\mid Y=0)$。\n-   精确率（阳性预测值，PPV）为 $\\mathrm{PPV}(\\tau) = \\Pr(Y=1 \\mid \\hat{Y}=1)$。\n-   召回率等于灵敏度：$\\mathrm{Recall}(\\tau) = \\mathrm{TPR}(\\tau)$。\n\n受试者工作特征（ROC）曲线绘制了 $\\mathrm{TPR}(\\tau)$ 相对于 $\\mathrm{FPR}(\\tau)$ 在 $\\tau$ 变化时的曲线，而曲线下面积（AUC）将此曲线总结为单个数字。精确率-召回率（PR）曲线绘制了 $\\mathrm{PPV}(\\tau)$ 相对于 $\\mathrm{TPR}(\\tau)$ 在 $\\tau$ 变化时的曲线，而 PR-AUC 总结了此曲线。\n\n根据贝叶斯定理，阳性预测值满足\n$$\n\\mathrm{PPV}(\\tau) = \\frac{\\mathrm{TPR}(\\tau)\\,p}{\\mathrm{TPR}(\\tau)\\,p + \\mathrm{FPR}(\\tau)\\,(1-p)}.\n$$\n\n考虑一个大小为 $N = 10^6$、患病率为 $p = 10^{-3}$ 的筛查人群。在一个临床上合理的运行阈值 $\\tau^\\star$ 下，假设分类器达到 $\\mathrm{TPR}(\\tau^\\star) = 0.90$ 和 $\\mathrm{FPR}(\\tau^\\star) = 0.01$。计算真阳性和假阳性的期望计数，在 $\\tau^\\star$ 下的精确率，并解释当 $p \\ll 1$ 时对临床效用的影响。基于第一性原理和上述定义，判断哪个汇总指标——ROC-AUC 还是 PR-AUC——在这种罕见疾病背景下能更好地反映临床效用，并证明其选择的合理性。\n\n选择最准确的陈述：\n\nA. ROC-AUC 更优，因为它对患病率 $p$ 不变，确保了性能评估不会被类别不平衡所混淆；当 $p \\ll 1$ 时，这种不变性使 ROC-AUC 成为临床效用的最佳代表。\n\nB. PR-AUC 更优，因为精确率等于阳性预测值，根据贝叶斯定理，它依赖于患病率 $p$；当 $p \\ll 1$ 时，假阳性主导了资源消耗和患者负担，而 PR-AUC 捕捉了 $\\mathrm{TPR}$ 和 $\\mathrm{PPV}$ 之间具有临床相关性的权衡。\n\nC. ROC-AUC 和 PR-AUC 对于任何单调评分变换都是等价的，因此在罕见疾病检测中提供关于临床效用的相同信息。\n\nD. ROC-AUC 更受青睐，因为通过降低决策阈值总能提高精确率，这使得 PR-AUC 不稳定，而 ROC-AUC 能抵抗阈值操纵，因此能更好地反映临床效用。",
            "solution": "用户提供了一个关于评估用于罕见疾病的二元分类器的问题。我将首先验证问题陈述，然后进行计算和原则性分析，以确定正确的选项。\n\n### 问题验证\n\n**第 1 步：提取给定条件**\n\n-   **场景**：用于筛查人群中罕见疾病的二元分类器。\n-   **患病率**：$p \\ll 1$。\n-   **分类器输出**：连续风险评分 $s(x) \\in [0,1]$。\n-   **人群规模**：$N = 10^6$。\n-   **特定患病率**：$p = 10^{-3}$。\n-   **运行点**：在阈值 $\\tau^\\star$ 处，真阳性率 $\\mathrm{TPR}(\\tau^\\star) = 0.90$，假阳性率 $\\mathrm{FPR}(\\tau^\\star) = 0.01$。\n-   **定义**：\n    -   真阳性率（TPR，灵敏度，召回率）：$\\mathrm{TPR}(\\tau) = \\Pr(\\hat{Y}=1 \\mid Y=1)$。\n    -   假阳性率（FPR）：$\\mathrm{FPR}(\\tau) = \\Pr(\\hat{Y}=1 \\mid Y=0)$。\n    -   精确率（阳性预测值，PPV）：$\\mathrm{PPV}(\\tau) = \\Pr(Y=1 \\mid \\hat{Y}=1)$。\n-   **公式与曲线**：\n    -   ROC 曲线：$\\mathrm{TPR}(\\tau)$ vs. $\\mathrm{FPR}(\\tau)$。\n    -   PR 曲线：$\\mathrm{PPV}(\\tau)$ vs. $\\mathrm{TPR}(\\tau)$。\n    -   用于 PPV 的贝叶斯定理：$\\mathrm{PPV}(\\tau) = \\frac{\\mathrm{TPR}(\\tau)\\,p}{\\mathrm{TPR}(\\tau)\\,p + \\mathrm{FPR}(\\tau)\\,(1-p)}$。\n-   **问题**：计算真阳性/假阳性的期望计数，计算在 $\\tau^\\star$ 处的精确率，解释临床影响，并确定 ROC-AUC 或 PR-AUC 哪个是该场景下临床效用的更佳指标。\n\n**第 2 步：使用提取的给定条件进行验证**\n\n-   **科学依据**：该问题在标准的统计学和机器学习分类器评估理论中有充分的依据。所有定义（$\\mathrm{TPR}$、$\\mathrm{FPR}$、$\\mathrm{PPV}$）和关系（贝叶斯定理）都是正确的。筛查罕见疾病的场景是生物统计学和生物医学信息学中的一个经典应用。\n-   **问题的适定性**：该问题是适定的。它提供了所有必要的数值和定义，以执行所需的计算，并支持对两种汇总指标进行逻辑比较。\n-   **客观性**：该问题使用清晰、客观和标准的术语进行陈述。\n-   **结论**：问题陈述是有效的。它在科学上是合理的、完整的且无歧义的。\n\n**结论**：问题有效。我将继续进行解答。\n\n### 推导与分析\n\n首先，我们计算给定人群和分类器性能的期望计数。\n总人口为 $N = 10^6$。\n疾病患病率为 $p = 10^{-3}$。\n\n预期患病人数（阳性）为：\n$$ P = N \\times p = 10^6 \\times 10^{-3} = 1000 $$\n预期未患病人数（阴性）为：\n$$ N_{neg} = N \\times (1-p) = 10^6 \\times (1 - 10^{-3}) = 10^6 \\times 0.999 = 999000 $$\n\n在指定的运行阈值 $\\tau^\\star$ 下，我们有 $\\mathrm{TPR}(\\tau^\\star) = 0.90$ 和 $\\mathrm{FPR}(\\tau^\\star) = 0.01$。\n\n预期真阳性（$\\mathrm{TP}$）数量是正确识别出的患病个体数量：\n$$ \\mathrm{TP} = P \\times \\mathrm{TPR}(\\tau^\\star) = 1000 \\times 0.90 = 900 $$\n预期假阳性（$\\mathrm{FP}$）数量是错误识别出的健康个体数量：\n$$ \\mathrm{FP} = N_{neg} \\times \\mathrm{FPR}(\\tau^\\star) = 999000 \\times 0.01 = 9990 $$\n\n接下来，我们计算在该阈值下的精确率（或阳性预测值，$\\mathrm{PPV}$）。精确率是阳性预测中正确的比例：\n$$ \\mathrm{PPV}(\\tau^\\star) = \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}} = \\frac{900}{900 + 9990} = \\frac{900}{10890} = \\frac{10}{121} \\approx 0.0826 $$\n这个结果可以用所提供的源自贝叶斯定理的公式来证实：\n$$ \\mathrm{PPV}(\\tau^\\star) = \\frac{\\mathrm{TPR}(\\tau^\\star)\\,p}{\\mathrm{TPR}(\\tau^\\star)\\,p + \\mathrm{FPR}(\\tau^\\star)\\,(1-p)} = \\frac{(0.90)(10^{-3})}{(0.90)(10^{-3}) + (0.01)(1-10^{-3})} = \\frac{0.0009}{0.0009 + 0.00999} = \\frac{0.0009}{0.01089} \\approx 0.0826 $$\n\n**临床效用解读**\n该分类器在 1000 个真实病例中识别出 900 个，这代表了高灵敏度（$\\mathrm{TPR}=90\\%$）。假阳性率也很低（$\\mathrm{FPR}=1\\%$）。然而，临床现实由精确率揭示。约 8.3% 的 $\\mathrm{PPV}$ 意味着在所有收到阳性测试结果的患者中，超过 91% 的人实际上是健康的。假阳性数量（$9990$）是真阳性数量（$900$）的 11 倍多。\n这对临床效用构成了重大问题。它意味着每发现一个真实病例，就有 11 名健康个体被错误地引导去接受进一步的、可能是侵入性且昂贵的诊断程序，这会引起不必要的患者焦虑，并给医疗资源带来巨大负担。\n\n**ROC-AUC 与 PR-AUC 的比较**\n受试者工作特征（ROC）曲线绘制了 $\\mathrm{TPR}$ 相对于 $\\mathrm{FPR}$。这两个指标都是以真实类别为条件（即，给定 $Y=1$ 或给定 $Y=0$）。因此，ROC 曲线及其面积（ROC-AUC）对类别患病率 $p$ 的变化是不变的。这意味着一个分类器的 ROC-AUC 无论是在平衡数据集（$p=0.5$）上评估，还是在高度不平衡的数据集（$p=10^{-3}$）上评估，都将是相同的。虽然这衡量了分类器分数的内在区分能力，但在像罕见疾病筛查这样极端类别不平衡是核心挑战的背景下，它可能具有高度误导性。0.01 的低 $\\mathrm{FPR}$ 可能看起来很优秀，但正如我们所见，当真阴性数量庞大时，它可能产生巨大的假阳性数量。\n\n精确率-召回率（PR）曲线绘制了精确率（$\\mathrm{PPV}$）相对于召回率（$\\mathrm{TPR}$）。正如公式和我们的计算所展示的，精确率关键性地依赖于患病率 $p$。对于 $p \\ll 1$ 的罕见疾病，$\\mathrm{PPV}$ 公式分母中的 $\\mathrm{FPR}(\\tau)(1-p)$ 项可以轻易地主导 $\\mathrm{TPR}(\\tau)p$ 项，导致非常低的 $\\mathrm{PPV}$，除非 $\\mathrm{FPR}(\\tau)$ 极小（在 $p$ 的数量级或更小）。PR 曲线直接可视化了发现阳性病例（召回率）和阳性预测为正确的概率（精确率）之间的权衡。一条差的 PR 曲线（以及低的 PR-AUC）会立即表明，在有用的召回率水平上，该分类器产生的假阳性相对于真阳性来说太多了。这直接关系到临床效用，后者关注的是有效利用资源和最大限度地减少假警报对患者的伤害。\n\n因此，在罕见疾病的背景下，PR-AUC 是一个比 ROC-AUC 信息量大得多的指标，因为它正确地反映了类别不平衡对测试实际性能的巨大影响。\n\n### 逐项分析\n\n**A. ROC-AUC 更优，因为它对患病率 $p$ 不变，确保了性能评估不会被类别不平衡所混淆；当 $p \\ll 1$ 时，这种不变性使 ROC-AUC 成为临床效用的最佳代表。**\n该陈述的前提是正确的（ROC-AUC 对 $p$ 不变），但其结论是错误的。这种不变性恰恰是使 ROC-AUC 在此特定背景下成为临床效用的一个*糟糕*代表的原因。类别不平衡的影响不是一个应被忽略的“混杂因素”；它是临床问题的核心。由于对患病率不敏感，ROC-AUC 可能会呈现一个过分乐观的图景，掩盖了不可接受的假阳性率。\n**结论：不正确。**\n\n**B. PR-AUC 更优，因为精确率等于阳性预测值，根据贝叶斯定理，它依赖于患病率 $p$；当 $p \\ll 1$ 时，假阳性主导了资源消耗和患者负担，而 PR-AUC 捕捉了 $\\mathrm{TPR}$ 和 $\\mathrm{PPV}$ 之间具有临床相关性的权衡。**\n该陈述完全正确。它正确地将精确率（$\\mathrm{PPV}$）识别为临床效用的关键指标，将其与患病率联系起来，并准确地描述了在罕见疾病背景下（$p \\ll 1$）假阳性占主导地位的问题。它正确地得出结论，PR 曲线及其 AUC 捕捉了这一临床上至关重要的权衡。\n**结论：正确。**\n\n**C. ROC-AUC 和 PR-AUC 对于任何单调评分变换都是等价的，因此在罕见疾病检测中提供关于临床效用的相同信息。**\n该陈述是错误的。虽然两条曲线都对分类器分数的单调变换不变，但曲线本身并不等价，也不提供相同的信息。在 ROC 空间和 PR 空间之间没有一个对所有分类器和患病率都成立的简单一一对应关系。如前所述，在显著的类别不平衡下，一个分类器可以有很高的 ROC-AUC 和很低的 PR-AUC。\n**结论：不正确。**\n\n**D. ROC-AUC 更受青睐，因为通过降低决策阈值总能提高精确率，这使得 PR-AUC 不稳定，而 ROC-AUC 能抵抗阈值操纵，因此能更好地反映临床效用。**\n该陈述在根本上是错误的。降低决策阈值会使分类器更频繁地预测“阳性”。这通常会增加 $\\mathrm{TP}$ 和 $\\mathrm{FP}$ 的总数。对精确率 $\\mathrm{PPV} = \\mathrm{TP}/(\\mathrm{TP}+\\mathrm{FP})$ 的影响不保证是增加。实际上，为了获得更高的精确率，通常需要*提高*阈值，但这会降低召回率。该论点的前提在关于降低阈值对精确率的影响方面，事实上是不正确的。\n**结论：不正确。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "一个预测准确的模型不一定具有临床实用性，其价值最终取决于它能否改善临床决策。决策曲线分析（DCA）是一种先进的验证技术，它将模型评估置于决策理论的框架内，通过权衡干预的利弊来量化模型的“净获益”。在本练习中，您将从第一性原理出发，构建决策曲线，并确定在何种风险阈值范围内，您的模型优于“全部治疗”或“全部不治疗”等基准策略，从而直接评估其临床决策价值。",
            "id": "3904334",
            "problem": "给定一个癌症筛查风险模型的验证预测结果，以及多个留出队列的相应二元结局。目标是为每个队列构建模型的决策曲线，并确定在该阈值概率范围内，该模型提供的临床净获益严格高于全体治疗和全体不治疗两种策略。此项工作必须基于决策理论原则，并从第一性原理出发进行构建，而不是使用捷径公式。\n\n从适用于生物医学系统建模和模型验证的有效基本基础开始，具体而言：\n- 定义二元结局 $y_i \\in \\{0,1\\}$，其中 $y_i=1$ 表示个体 $i$ 患有癌症，$y_i=0$ 表示未患癌症。\n- 设 $p_i \\in [0,1]$ 表示对个体 $i$ 的校准后验证预测，代表其患癌症的估计概率。\n- 给定一个阈值概率 $p_t \\in (0,1)$，它被解释为临床干预变得合理的风险水平，定义二元决策规则 $d_i(p_t)$：当且仅当 $p_i \\ge p_t$ 时，治疗个体 $i$，否则避免治疗。\n- 从决策分析的第一性原理出发，将临床净获益表示为正确治疗病例的期望收益减去错误治疗非病例的期望危害，并按人群规模进行归一化。通过将决策规则与混淆矩阵计数以及阈值隐含的收益与危害之间的交换率相结合，推导出必要的表达式。\n- 将全体治疗策略定义为对所有 $i$ 都有 $d_i^{\\text{all}}=1$，将全体不治疗策略定义为对所有 $i$ 都有 $d_i^{\\text{none}}=0$。使用这些作为比较对象。\n\n您必须实现以下任务：\n- 对于每个队列，通过在一系列均匀的阈值概率网格 $p_t \\in \\{0.01,0.02,\\ldots,0.99\\}$ 上计算模型的净获益、全体治疗净获益和全体不治疗净获益，来构建决策曲线。概率应表示为小数（而非百分比）。\n- 在此网格上确定连续的阈值区间，在这些区间内，模型的净获益严格大于全体治疗策略的净获益，且严格大于全体不治疗策略的净获益。将每个区间报告为 $[a,b]$ 的形式，其中 $a$ 和 $b$ 是直接从网格中取到的包含边界。\n- 将最终的区间边界表示为四舍五入到三位小数的小数概率。\n\n测试套件由三个留出队列组成，其验证预测和结局如下。每个队列表示为一个列表对 $(\\{p_i\\},\\{y_i\\})$：\n\n队列 $1$ ($n=20$):\n- 验证预测 $\\{0.02,0.05,0.10,0.15,0.20,0.25,0.35,0.40,0.45,0.55,0.60,0.65,0.70,0.75,0.80,0.85,0.90,0.30,0.50,0.95\\}$。\n- 结局 $\\{0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,1\\}$。\n\n队列 $2$ ($n=15$):\n- 验证预测 $\\{0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.30,0.20,0.27,0.23\\}$。\n- 结局 $\\{0,1,0,0,1,0,0,0,1,0,0,1,0,0,0\\}$。\n\n队列 $3$ ($n=10$):\n- 验证预测 $\\{0.00,0.00,0.00,0.00,1.00,1.00,1.00,1.00,1.00,1.00\\}$。\n- 结局 $\\{0,0,0,0,1,1,1,1,1,1\\}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的列表形式的结果。列表中的每个元素对应一个队列，其本身是一个 $[a,b]$ 区间的列表。例如，输出必须看起来像 $[[[a_1,b_1],[a_2,b_2]],[],[[a_3,b_3]]]$，所有数字都四舍五入到三位小数。如果某个队列没有使模型严格优于两个比较策略的阈值，则为该队列输出一个空列表。\n\n所有概率和阈值都必须视为无单位的小数值。不要使用百分号。此问题不涉及角度。\n\n最终输出必须遵循所描述的精确格式，并打印为单行。不应打印任何其他文本。",
            "solution": "该问题要求确定阈值概率范围，在此范围内，临床风险模型提供的净获益要大于全体患者都治疗和全体患者都不治疗这两种策略。解决方案需要从决策理论的第一性原理推导出净获益度量，然后通过计算实现来为给定的三个队列找到指定的范围。\n\n首先，我们为净获益 ($NB$) 建立理论基础。分析基于二元结局 $y_i \\in \\{0, 1\\}$，其中 $y_i=1$ 表示存在该状况（例如，癌症），而 $y_i=0$ 表示不存在。模型为每个个体 $i$ 提供一个风险评分 $p_i \\in [0, 1]$。临床干预（治疗）的决策基于一个阈值概率 $p_t \\in (0, 1)$。决策规则是当且仅当个体 $i$ 的预测风险 $p_i$ 大于或等于该阈值时（即 $p_i \\ge p_t$）才进行治疗。\n\n决策理论假定，如果一项决策的期望收益为正，则应做出该决策。设 $B$ 为真阳性（治疗患有该病的患者）的收益，设 $H$ 为假阳性（治疗未患该病的患者）的危害。对于一个真实潜在疾病概率为 $p$ 的患者，治疗的期望收益为 $E[\\text{treat}] = p \\cdot B - (1-p) \\cdot H$。如果 $E[\\text{treat}]  E[\\text{not treat}]$，则治疗是合理的。假设不治疗的净收益为 $0$，那么当 $p \\cdot B - (1-p) \\cdot H  0$ 时，我们选择治疗。阈值概率 $p_t$ 代表无差异点，在该点上，治疗的期望收益等于不治疗的期望收益：$p_t \\cdot B = (1-p_t) \\cdot H$。这得出了由阈值所隐含的危害与收益之间的“交换率”：\n$$\n\\frac{H}{B} = \\frac{p_t}{1-p_t}\n$$\n这个关系意味着，对于给定的 $p_t$，一个假阳性的危害等同于 $\\frac{p_t}{1-p_t}$ 个真阳性的收益。\n\n整个队列的净获益定义为总收益减去总危害，并在队列中的所有个体上进行平均。设 $N$ 为总人群规模。对于给定的阈值 $p_t$，我们可以计算出真阳性数 $TP(p_t)$ 和假阳性数 $FP(p_t)$。总收益为 $TP(p_t) \\cdot B$，总危害为 $FP(p_t) \\cdot H$。人群水平的净获益是：\n$$\nNB_{\\text{total}} = TP(p_t) \\cdot B - FP(p_t) \\cdot H\n$$\n为了使该度量独立于 $B$ 的具体单位，并用 $p_t$ 来表示，我们可以除以 $B$ 并代入交换率。然后通过除以 $N$ 得到每个个体的净获益：\n$$\nNB_{\\text{model}}(p_t) = \\frac{TP(p_t) \\cdot B - FP(p_t) \\cdot H}{N \\cdot B} = \\frac{TP(p_t)}{N} - \\frac{FP(p_t)}{N} \\left(\\frac{H}{B}\\right)\n$$\n代入 $\\frac{H}{B} = \\frac{p_t}{1-p_t}$，我们得到模型净获益的标准公式：\n$$\nNB_{\\text{model}}(p_t) = \\frac{TP(p_t)}{N} - \\frac{FP(p_t)}{N} \\frac{p_t}{1-p_t}\n$$\n\n接下来，我们为两种比较策略定义净获益。\n“全体不治疗”策略导致 $TP=0$ 和 $FP=0$。因此，其净获益始终为零：\n$$\nNB_{\\text{none}}(p_t) = 0\n$$\n“全体治疗”策略导致治疗队列中的每一个体。真阳性的数量等于患有该状况的个体总数 $N_{pos}$，假阳性的数量等于未患该状况的个体总数 $N_{neg}$。设队列中该状况的患病率为 $\\pi = N_{pos} / N$。那么 $N_{neg}/N = 1-\\pi$。其净获益是：\n$$\nNB_{\\text{all}}(p_t) = \\frac{N_{pos}}{N} - \\frac{N_{neg}}{N} \\frac{p_t}{1-p_t} = \\pi - (1-\\pi) \\frac{p_t}{1-p_t}\n$$\n\n目标是找到 $p_t$ 的区间，在这些区间内，模型严格优于两种比较策略，即 $NB_{\\text{model}}(p_t)  NB_{\\text{all}}(p_t)$ 且 $NB_{\\text{model}}(p_t)  NB_{\\text{none}}(p_t)$。\n\n该算法对每个队列按以下步骤进行：\n1. 初始化一个空列表，用于存储模型表现更优的阈值 $p_t$。\n2. 遍历指定网格 $\\{0.01, 0.02, \\ldots, 0.99\\}$ 中的每个阈值 $p_t$。\n3. 对于每个 $p_t$：\n    a. 通过将决策规则 ($p_i \\ge p_t$) 应用于队列的预测值 $\\{p_i\\}$ 和结局 $\\{y_i\\}$，计算 $TP(p_t)$ 和 $FP(p_t)$。\n    b. 使用推导出的公式计算 $NB_{\\text{model}}(p_t)$、$NB_{\\text{all}}(p_t)$ 和 $NB_{\\text{none}}(p_t)$。\n    c. 如果 $NB_{\\text{model}}(p_t)  NB_{\\text{all}}(p_t)$ 且 $NB_{\\text{model}}(p_t)  NB_{\\text{none}}(p_t)$，则将 $p_t$ 添加到优势阈值列表中。\n4. 遍历所有阈值后，处理优势阈值列表以识别连续区间。如果一个区间的构成阈值在网格中是连续的（例如，$0.21, 0.22, 0.23$），则该区间是连续的。\n5. 将识别出的区间格式化为 $[a, b]$，其中 $a$ 和 $b$ 是从网格中获取的包含起始和结束的边界，表示为三位小数。为每个队列收集这些区间。\n6. 最后，将所有队列的结果汇总成指定的最终输出格式。\n该程序被系统地应用于问题陈述中提供的三个队列中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the decision curve analysis problem for given cohorts.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            [0.02, 0.05, 0.10, 0.15, 0.20, 0.25, 0.35, 0.40, 0.45, 0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.30, 0.50, 0.95],\n            [0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,1]\n        ),\n        (\n            [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.30, 0.20, 0.27, 0.23],\n            [0,1,0,0,1,0,0,0,1,0,0,1,0,0,0]\n        ),\n        (\n            [0.00, 0.00, 0.00, 0.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n            [0,0,0,0,1,1,1,1,1,1]\n        )\n    ]\n\n    pt_grid = np.arange(0.01, 1.00, 0.01)\n    all_cohort_results = []\n\n    for predictions, outcomes in test_cases:\n        p = np.array(predictions)\n        y = np.array(outcomes)\n        n = len(y)\n        \n        if n == 0:\n            all_cohort_results.append([])\n            continue\n\n        prevalence = np.sum(y) / n\n        superior_thresholds = []\n\n        for pt in pt_grid:\n            # The denominator (1-pt) would be zero if pt=1, but the grid excludes it.\n            exchange_rate = pt / (1 - pt)\n\n            # Model Net Benefit\n            treated_mask = p >= pt\n            tp = np.sum(treated_mask  (y == 1))\n            fp = np.sum(treated_mask  (y == 0))\n            nb_model = (tp / n) - (fp / n) * exchange_rate\n\n            # Comparator Net Benefits\n            nb_treat_all = prevalence - (1 - prevalence) * exchange_rate\n            nb_treat_none = 0.0\n\n            if nb_model > nb_treat_all and nb_model > nb_treat_none:\n                superior_thresholds.append(pt)\n\n        # Find contiguous intervals from the list of superior thresholds\n        intervals = []\n        if superior_thresholds:\n            start_interval = superior_thresholds[0]\n            for i in range(1, len(superior_thresholds)):\n                # Check for a gap in the sequence of thresholds.\n                # Use a small tolerance for floating point comparison.\n                if superior_thresholds[i] - superior_thresholds[i-1] > (0.01 + 1e-9):\n                    end_interval = superior_thresholds[i-1]\n                    intervals.append([start_interval, end_interval])\n                    start_interval = superior_thresholds[i]\n            \n            # Add the last interval\n            end_interval = superior_thresholds[-1]\n            intervals.append([start_interval, end_interval])\n\n        all_cohort_results.append(intervals)\n\n    # Format the final output string exactly as specified.\n    cohort_strs = []\n    for cohort_intervals in all_cohort_results:\n        if not cohort_intervals:\n            cohort_strs.append(\"[]\")\n        else:\n            interval_strs = [f\"[{start:.3f},{end:.3f}]\" for start, end in cohort_intervals]\n            cohort_strs.append(f\"[{','.join(interval_strs)}]\")\n    \n    final_output = f\"[{','.join(cohort_strs)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}