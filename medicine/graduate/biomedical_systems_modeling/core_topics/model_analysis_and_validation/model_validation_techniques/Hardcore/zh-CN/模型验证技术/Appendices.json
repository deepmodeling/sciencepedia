{
    "hands_on_practices": [
        {
            "introduction": "我们的第一个实践聚焦于药代动力学（PK）模型，这类模型常用于预测药物在体内的浓度变化。模型验证的关键一步是量化其预测值与真实测量值之间的偏差。通过这个练习 ，你将亲手计算两个基本误差指标——均方根误差（$RMSE$）和平均绝对误差（$MAE$），并探索它们对异常值的不同敏感性，从而理解在不同数据情境下如何选择最合适的评估指标。",
            "id": "3904284",
            "problem": "您正在使用基于原则的误差度量来验证生物医学系统模型中的药代动力学浓度模型。考虑一个单室静脉推注模型，其血浆浓度由基准公式 $C(t) = C_0 e^{-k t}$ 给出，其中 $C_0$ 是初始浓度，而 $k$ 是消除速率常数。模型预测值将与测量浓度进行比较。将残差定义为 $r_i = y_i - \\hat{y}_i$，其中 $\\hat{y}_i$ 是预测浓度，$y_i$ 是在时间 $t_i$ 的测量浓度。使用均方根误差和平均绝对误差的标准定义来量化差异。所有与浓度相关的量均以毫克每升 (mg/L) 表示。\n\n从标准测量模型 $y_i = \\hat{y}_i + \\varepsilon_i$ 和独立残差 $\\varepsilon_i$ 开始，您的程序必须为每个测试用例计算：\n- 在所提供的时间点上，以 mg/L 为单位的均方根误差 (RMSE)。\n- 在所提供的时间点上，以 mg/L 为单位的平均绝对误差 (MAE)。\n- 敏感度比率 $R$，定义为 $R = \\text{RMSE} / \\text{MAE}$，以浮点数形式报告。如果 $MAE = 0$，则设 $R = 0.0$。\n- 一个离群点影响指标，解释为一个布尔值，计算如下。定义稳健尺度估计 $s_{\\text{MAD}} = \\text{median}(|r_i - \\text{median}(r)|)$，并令 $I = \\frac{\\max_i |r_i|}{s_{\\text{MAD}} + \\epsilon}$，其中 $\\epsilon = 10^{-12}$。如果 $I > 6$，则将“存在强离群点”分类为真，否则为假。\n- 一个度量选择代码，以整数形式表示，并由残差的统计模型证明其合理性：如果由于存在重尾或离群点的证据，推荐的验证度量是平均绝对误差 (MAE)，则输出 $0$；如果在与高斯残差一致的条件下，推荐的验证度量是均方根误差 (RMSE)，则输出 $1$。尽管其基本原理基于最大似然一致性和稳健性，但必须生成这些数字代码；其原理将在解决方案中解释。\n\n使用以下科学上真实的测试套件。所有浓度单位为 mg/L，所有时间单位为小时。预测参数为 $C_0 = 4$ 和 $k = 0.25$，时间点为 $t \\in \\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\}$。预测值计算为 $\\hat{y}_i = C_0 e^{-k t_i}$，测量值通过使用指定的残差 $r_i$ 构建为 $y_i = \\hat{y}_i + r_i$：\n\n- 情况 A（理想情况，类似高斯分布的小偏差）：残差 $r^{(A)} = [0.05, -0.04, 0.02, -0.03, 0.01, -0.02, 0.00, 0.03, -0.01, 0.02]$。\n- 情况 B（单个大离群点）：残差 $r^{(B)} = [0.05, -0.04, 0.02, -0.03, 0.01, 2.50, 0.00, 0.03, -0.01, 0.02]$。\n- 情况 C（重尾残差模式）：残差 $r^{(C)} = [0.10, -0.08, 0.06, -0.05, 0.00, 0.00, 0.30, -0.40, 0.50, -0.30]$。\n- 情况 D（边界情况，零误差）：残差 $r^{(D)} = [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]$。\n- 情况 E（边缘情况，单个时间点，严重偏差）：使用 $t = [2]$，预测值 $\\hat{y} = C_0 e^{-k \\cdot 2}$，以及残差 $r^{(E)} = [4.50]$。\n\n您的程序必须根据指定的 $C_0$、$k$ 和 $t$ 为每个情况构建预测值 $\\hat{y}_i$，添加相应的残差以形成测量值 $y_i$，从构建的 $y_i$ 和 $\\hat{y}_i$ 计算残差 $r_i$，然后按上述要求计算输出。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个包含五项的列表，顺序为 $[\\,\\text{RMSE}, \\text{MAE}, R, \\text{outlier\\_boolean}, \\text{metric\\_code}\\,]$。将情况 A、B、C、D、E 的结果按顺序聚合到一个外部列表中。例如，总输出格式为 $[[...],[...],[...],[...],[...]]$。",
            "solution": "问题陈述已经过严格验证，被认为是合理的。它具有科学依据，提法明确，客观且内部一致。为得到唯一且有意义的解，所有必要的数据、模型和定义均已提供。因此，我们可以着手提供完整的解决方案。\n\n该问题要求计算几种误差度量，以根据合成测量数据验证一个药代动力学模型。这是生物医学系统建模中的一项基本任务，其目标是量化模型预测与实验观察值之间的差异。\n\n所考虑的模型是单室静脉（IV）推注模型，它描述了快速注射后药物在时间 $t$ 的血浆浓度 $C(t)$。其控制方程为：\n$$\nC(t) = C_0 e^{-k t}\n$$\n其中 $C_0$ 是在 $t=0$ 时的初始浓度，而 $k$ 是一级消除速率常数。对于此问题，给定 $C_0 = 4 \\, \\text{mg/L}$ 和 $k = 0.25 \\, \\text{hr}^{-1}$。\n\n模型的预测值（表示为 $\\hat{y}_i$）是在特定时间点 $t_i$ 计算的。相应的实验测量值表示为 $y_i$。模型验证的核心在于分析残差 $r_i$，其定义为观测值与预测值之间的差异：\n$$\nr_i = y_i - \\hat{y}_i\n$$\n问题为五个不同的测试用例指定了确切的残差。虽然问题指示我们首先构建预测值 $\\hat{y}_i$，然后是测量值 $y_i = \\hat{y}_i + r_i$，最后重新计算残差，但这最后一步只是返回了最初给定的残差，因为 $y_i - \\hat{y}_i = (\\hat{y}_i + r_i) - \\hat{y}_i = r_i$。此过程仅确认了设置的一致性。分析将基于这些残差进行。\n\n我们被要求为每个案例计算五个量：\n\n1.  **均方根误差 (RMSE):** 该度量衡量的是残差平方的平均值的平方根。由于平方项的存在，它对大误差（离群点）很敏感。\n    $$\n    \\text{RMSE} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} r_i^2}\n    $$\n2.  **平均绝对误差 (MAE):** 该度量衡量的是残差绝对值的平均值。它比 RMSE 对离群点的敏感度低。\n    $$\n    \\text{MAE} = \\frac{1}{n} \\sum_{i=1}^{n} |r_i|\n    $$\n3.  **敏感度比率 ($R$):** 定义为 $R = \\text{RMSE} / \\text{MAE}$，该比率提供了对误差分布的洞察。对于单个误差，$R=1$。对于多个误差，$R \\ge 1$。一个远大于 $1$ 的 $R$ 值表明存在大的离群点，这些离群点不成比例地增大了 RMSE。如果 $\\text{MAE} = 0$，则所有残差都为零，因此 $\\text{RMSE}$ 也为零，我们定义 $R=0.0$。\n\n4.  **离群点影响指标：** 这个布尔值是使用一种稳健的统计方法确定的。首先，我们计算中位数绝对偏差 ($s_{\\text{MAD}}$)，这是一种稳健的统计离散度估计量：\n    $$\n    s_{\\text{MAD}} = \\text{median}(|r_i - \\text{median}(r)|)\n    $$\n    接下来，我们计算一个影响分数 $I$，它将最大绝对残差与这个稳健的尺度估计进行比较：\n    $$\n    I = \\frac{\\max_i |r_i|}{s_{\\text{MAD}} + \\epsilon}\n    $$\n    其中 $\\epsilon=10^{-12}$ 是一个很小的常数，以防止除以零。一个大的 $I$ 值表示最大的误差是典型误差幅度的许多倍。问题将标记“存在强离群点”的阈值设置为 $I > 6$。\n\n5.  **度量选择代码：** 这个整数代码（$0$ 或 $1$）为哪个误差度量（MAE 或 RMSE）更适合模型验证提供了有原则的建议。其理由源于最大似然估计 (MLE) 的原理。当残差被假定服从高斯（正态）分布时，最小化误差平方和（从而最小化 RMSE）对应于模型参数的 MLE 解。当残差被假定服从拉普拉斯分布时，最小化绝对误差和 (MAE) 对应于 MLE 解，拉普拉斯分布比高斯分布具有更“重”的尾部，因此对离群点更具容忍性。\n    -   **代码 1 (RMSE):** 当残差与高斯分布一致时（即没有显著的离群点）推荐使用。\n    -   **代码 0 (MAE):** 当有证据表明存在重尾或显著离群点时推荐使用，此时拉普拉斯假设更为合适，MAE 是一个更稳健的度量。\n    该决策基于离群点影响指标：如果“存在强离群点”为真，我们选择代码 $0$；否则，我们选择代码 $1$。\n\n我们现在将这些计算应用于每个测试用例。\n\n**情况 A：类似高斯分布的小偏差**\n-   $r^{(A)} = [0.05, -0.04, 0.02, -0.03, 0.01, -0.02, 0.00, 0.03, -0.01, 0.02]$\n-   $\\sum r_i^2 = 0.0073$, $n=10$。 $\\text{RMSE} = \\sqrt{0.0073/10} = \\sqrt{0.00073} \\approx 0.027019$。\n-   $\\sum |r_i| = 0.23$。 $\\text{MAE} = 0.23/10 = 0.023$。\n-   $R = 0.027019 / 0.023 \\approx 1.174718$。\n-   $\\text{median}(r) = 0.005$。 $s_{\\text{MAD}} = \\text{median}(\\{|0.045, -0.045, \\dots|\\}) = 0.02$。\n-   $\\max|r_i| = 0.05$。 $I = 0.05 / (0.02 + 10^{-12}) = 2.5$。\n-   离群点指标：$I \\le 6$，所以为 `False`。\n-   度量代码：`1`。\n-   结果：$[0.027019, 0.023, 1.174718, \\text{False}, 1]$\n\n**情况 B：单个大离群点**\n-   $r^{(B)} = [0.05, -0.04, 0.02, -0.03, 0.01, 2.50, 0.00, 0.03, -0.01, 0.02]$\n-   $\\sum r_i^2 = (0.0073 - (-0.02)^2) + 2.5^2 = 6.2569$。 $\\text{RMSE} = \\sqrt{6.2569/10} \\approx 0.791005$。\n-   $\\sum |r_i| = (0.23 - |-0.02|) + 2.5 = 2.71$。 $\\text{MAE} = 2.71/10 = 0.271$。\n-   $R = 0.791005 / 0.271 \\approx 2.918840$。\n-   $\\text{median}(r) = 0.015$。 $s_{\\text{MAD}} = 0.02$。\n-   $\\max|r_i| = 2.50$。 $I = 2.50 / (0.02 + 10^{-12}) = 125.0$。\n-   离群点指标：$I > 6$，所以为 `True`。\n-   度量代码：`0`。\n-   结果：$[0.791005, 0.271, 2.918840, \\text{True}, 0]$\n\n**情况 C：重尾残差模式**\n-   $r^{(C)} = [0.10, -0.08, 0.06, -0.05, 0.00, 0.00, 0.30, -0.40, 0.50, -0.30]$\n-   $\\sum r_i^2 = 0.5225$。 $\\text{RMSE} = \\sqrt{0.5225/10} \\approx 0.228583$。\n-   $\\sum |r_i| = 1.79$。 $\\text{MAE} = 1.79/10 = 0.179$。\n-   $R = 0.228583 / 0.179 \\approx 1.276998$。\n-   $\\text{median}(r) = 0.00$。 $s_{\\text{MAD}} = \\text{median}(\\{|r_i|\\}) = \\text{median}([0,0,0.05,0.06,0.08,0.1,0.3,0.3,0.4,0.5]) = (0.08+0.1)/2 = 0.09$。\n-   $\\max|r_i| = 0.50$。 $I = 0.50 / (0.09 + 10^{-12}) \\approx 5.555...$。\n-   离群点指标：$I \\le 6$，所以为 `False`。\n-   度量代码：`1`。\n-   结果：$[0.228583, 0.179, 1.276998, \\text{False}, 1]$\n\n**情况 D：零误差**\n-   $r^{(D)} = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$\n-   $\\text{RMSE} = 0.0$。\n-   $\\text{MAE} = 0.0$。\n-   $R = 0.0$（根据定义）。\n-   $\\text{median}(r) = 0$。 $s_{\\text{MAD}} = 0$。\n-   $\\max|r_i| = 0$。 $I = 0 / (0 + 10^{-12}) = 0.0$。\n-   离群点指标：$I \\le 6$，所以为 `False`。\n-   度量代码：`1`。\n-   结果：$[0.0, 0.0, 0.0, \\text{False}, 1]$\n\n**情况 E：单个时间点，严重偏差**\n-   $r^{(E)} = [4.50]$, $n=1$。\n-   $\\text{RMSE} = \\sqrt{4.5^2} = 4.5$。\n-   $\\text{MAE} = |4.5| = 4.5$。\n-   $R = 4.5 / 4.5 = 1.0$。\n-   $\\text{median}(r) = 4.5$。 $s_{\\text{MAD}} = \\text{median}(|4.5 - 4.5|) = 0$。\n-   $\\max|r_i| = 4.5$。 $I = 4.5 / (0 + 10^{-12}) = 4.5 \\times 10^{12}$。\n-   离群点指标：$I > 6$，所以为 `True`。\n-   度量代码：`0`。\n-   结果：$[4.5, 4.5, 1.0, \\text{True}, 0]$\n\n这些结果将由提供的 Python 代码生成，并遵循指定的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a pharmacokinetic model by computing error metrics for several test cases.\n    \"\"\"\n\n    # Model parameters and constants\n    C0 = 4.0  # mg/L\n    k = 0.25  # hr^-1\n    epsilon = 1e-12\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (time_points, residuals).\n    test_cases = [\n        # Case A: Happy path, small Gaussian-like deviations\n        (np.arange(10), \n         np.array([0.05, -0.04, 0.02, -0.03, 0.01, -0.02, 0.00, 0.03, -0.01, 0.02])),\n        \n        # Case B: Single large outlier\n        (np.arange(10), \n         np.array([0.05, -0.04, 0.02, -0.03, 0.01, 2.50, 0.00, 0.03, -0.01, 0.02])),\n        \n        # Case C: Heavy-tailed residual pattern\n        (np.arange(10), \n         np.array([0.10, -0.08, 0.06, -0.05, 0.00, 0.00, 0.30, -0.40, 0.50, -0.30])),\n        \n        # Case D: Boundary, zero error\n        (np.arange(10), \n         np.array([0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00])),\n        \n        # Case E: Edge, single time point, severe deviation\n        (np.array([2.0]), \n         np.array([4.50]))\n    ]\n\n    all_results = []\n    \n    for t_points, r_given in test_cases:\n        # Per the problem description, construct predictions and measurements to get residuals.\n        # This step is formally required, though it just returns the provided residuals.\n        y_hat = C0 * np.exp(-k * t_points)\n        y_measured = y_hat + r_given\n        r = y_measured - y_hat\n\n        # 1. Compute Root Mean Square Error (RMSE)\n        rmse = np.sqrt(np.mean(r**2))\n\n        # 2. Compute Mean Absolute Error (MAE)\n        mae = np.mean(np.abs(r))\n\n        # 3. Compute Ratio R\n        # Handles the case where MAE is 0 to avoid division by zero.\n        ratio_r = rmse / mae if mae > 0 else 0.0\n\n        # 4. Compute Outlier Influence Indicator\n        median_r = np.median(r)\n        s_mad = np.median(np.abs(r - median_r))\n        max_abs_r = np.max(np.abs(r))\n        \n        # The influence score I\n        influence_score = max_abs_r / (s_mad + epsilon)\n        \n        # Classify as True if I > 6\n        heavy_outliers_present = influence_score > 6\n\n        # 5. Compute Metric Selection Code\n        # Code 0 for MAE (if outliers), Code 1 for RMSE (otherwise)\n        metric_code = 0 if heavy_outliers_present else 1\n\n        case_result = [\n            rmse,\n            mae,\n            ratio_r,\n            heavy_outliers_present,\n            metric_code\n        ]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # Custom formatting to match the example output style exactly.\n    result_str = \"[\"\n    for i, res in enumerate(all_results):\n        # Format: [float, float, float, Boolean, int]\n        # Python's bool __str__ is 'True' or 'False' which is standard.\n        res_list_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]}]\"\n        result_str += res_list_str\n        if i  len(all_results) - 1:\n            result_str += \",\"\n    result_str += \"]\"\n    \n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "从连续预测转向二元分类后，我们面临新的挑战，尤其是在罕见病诊断等类别极不平衡的场景中。一个看似表现优异的模型，在临床上可能因产生大量假阳性而并无价值。本实践  将引导你辨析两种关键的评估工具——受试者工作特征（ROC）曲线和精确率-召回率（PR）曲线，并阐明为何在处理严重类别不平衡问题时，后者通常能更真实、更切合临床地反映模型的性能。",
            "id": "3904290",
            "problem": "一个二元分类器被训练用于在筛查人群中检测一种罕见疾病。该疾病的患病率为 $p \\ll 1$。该分类器输出一个连续的风险评分 $s(x) \\in [0,1]$，一个决策阈值 $\\tau$ 产生一个二元预测。验证在一个大小为 $N$ 的大型队列上进行，其中真阳性、假阳性、真阴性和假阴性的数量根据给定阈值 $\\tau$ 的混淆矩阵定义得出。\n\n基本定义：\n- 真阳性率（TPR，灵敏度）是 $\\mathrm{TPR}(\\tau) = \\Pr(\\hat{Y}=1 \\mid Y=1)$。\n- 假阳性率（FPR）是 $\\mathrm{FPR}(\\tau) = \\Pr(\\hat{Y}=1 \\mid Y=0)$。\n- 精确率（阳性预测值，PPV）是 $\\mathrm{PPV}(\\tau) = \\Pr(Y=1 \\mid \\hat{Y}=1)$。\n- 召回率等于灵敏度：$\\mathrm{Recall}(\\tau) = \\mathrm{TPR}(\\tau)$。\n\n受试者工作特征（ROC）曲线绘制了 $\\mathrm{TPR}(\\tau)$ 随 $\\tau$ 变化的对 $\\mathrm{FPR}(\\tau)$ 的关系图，曲线下面积（AUC）将该曲线概括为一个单一数值。精确率-召回率（PR）曲线绘制了 $\\mathrm{PPV}(\\tau)$ 随 $\\tau$ 变化的对 $\\mathrm{TPR}(\\tau)$ 的关系图，PR-AUC 概括了这条曲线。\n\n根据贝叶斯定理，阳性预测值满足\n$$\n\\mathrm{PPV}(\\tau) = \\frac{\\mathrm{TPR}(\\tau)\\,p}{\\mathrm{TPR}(\\tau)\\,p + \\mathrm{FPR}(\\tau)\\,(1-p)}.\n$$\n\n考虑一个大小为 $N = 10^6$、患病率为 $p = 10^{-3}$ 的筛查人群。在一个临床上合理的运行阈值 $\\tau^\\star$ 下，假设分类器达到 $\\mathrm{TPR}(\\tau^\\star) = 0.90$ 和 $\\mathrm{FPR}(\\tau^\\star) = 0.01$。计算真阳性和假阳性的预期数量，在 $\\tau^\\star$ 处的精确率，并解释当 $p \\ll 1$ 时对临床效用的影响。基于第一性原理和以上定义，确定哪个汇总指标（ROC-AUC 或 PR-AUC）能更好地反映在这种罕见疾病背景下的临床效用，并证明你的选择。\n\n选择最准确的陈述：\n\nA. ROC-AUC 更优，因为它对患病率 $p$ 不变，确保了性能评估不受类别不平衡的干扰；这种不变性使得 ROC-AUC 在 $p \\ll 1$ 时成为临床效用的最佳代表。\n\nB. PR-AUC 更优，因为精确率等于阳性预测值，根据贝叶斯定理，它依赖于患病率 $p$；当 $p \\ll 1$ 时，假阳性在资源使用和患者负担中占主导地位，而 PR-AUC 捕捉了 $\\mathrm{TPR}$ 和 $\\mathrm{PPV}$ 之间具有临床意义的权衡。\n\nC. ROC-AUC 和 PR-AUC 对于任何单调评分转换都是等价的，因此在罕见疾病检测中提供关于临床效用的相同信息。\n\nD. ROC-AUC 更受青睐，因为通过降低决策阈值总能提高精确率，这使得 PR-AUC 不稳定，而 ROC-AUC 能抵抗阈值操纵，因此能更好地反映临床效用。",
            "solution": "用户提供了一个关于评估用于罕见疾病的二元分类器的问题。我将首先验证问题陈述，然后进行计算和原则性分析，以确定正确的选项。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n\n-   **场景**：一个用于在筛查人群中检测罕见疾病的二元分类器。\n-   **患病率**：$p \\ll 1$。\n-   **分类器输出**：连续风险评分 $s(x) \\in [0,1]$。\n-   **人群规模**：$N = 10^6$。\n-   **具体患病率**：$p = 10^{-3}$。\n-   **工作点**：在阈值 $\\tau^\\star$ 下，真阳性率为 $\\mathrm{TPR}(\\tau^\\star) = 0.90$，假阳性率为 $\\mathrm{FPR}(\\tau^\\star) = 0.01$。\n-   **定义**：\n    -   真阳性率（TPR, 灵敏度, 召回率）：$\\mathrm{TPR}(\\tau) = \\Pr(\\hat{Y}=1 \\mid Y=1)$。\n    -   假阳性率（FPR）：$\\mathrm{FPR}(\\tau) = \\Pr(\\hat{Y}=1 \\mid Y=0)$。\n    -   精确率（阳性预测值, PPV）：$\\mathrm{PPV}(\\tau) = \\Pr(Y=1 \\mid \\hat{Y}=1)$。\n-   **公式和曲线**：\n    -   ROC 曲线：$\\mathrm{TPR}(\\tau)$ vs. $\\mathrm{FPR}(\\tau)$。\n    -   PR 曲线：$\\mathrm{PPV}(\\tau)$ vs. $\\mathrm{TPR}(\\tau)$。\n    -   用于 PPV 的贝叶斯定理：$\\mathrm{PPV}(\\tau) = \\frac{\\mathrm{TPR}(\\tau)\\,p}{\\mathrm{TPR}(\\tau)\\,p + \\mathrm{FPR}(\\tau)\\,(1-p)}$。\n-   **问题**：计算真阳性/假阳性的预期数量，计算在 $\\tau^\\star$ 时的精确率，解释其临床意义，并确定在这种情况下，ROC-AUC 或 PR-AUC 哪个是更好的临床效用指标。\n\n**步骤2：使用提取的给定信息进行验证**\n\n-   **科学依据**：该问题在分类器评估的标准统计学和机器学习理论中有充分的依据。所有定义（$\\mathrm{TPR}$、$\\mathrm{FPR}$、$\\mathrm{PPV}$）和关系（贝叶斯定理）都是正确的。罕见疾病筛查的场景是生物统计学和生物医学信息学中的一个经典应用。\n-   **适定性**：该问题是适定的。它提供了所有必要的数值和定义，以执行所需的计算，并支持对两个汇总指标进行逻辑比较。\n-   **客观性**：该问题使用清晰、客观和标准的术语陈述。\n-   **结论**：问题陈述有效。它在科学上是合理的、完整的和明确的。\n\n**裁定**：问题有效。我将继续解答。\n\n### 推导与分析\n\n首先，我们计算给定人群和分类器性能下的预期数量。\n总人口为 $N = 10^6$。\n疾病患病率为 $p = 10^{-3}$。\n\n预期患病人数（阳性）为：\n$$ P = N \\times p = 10^6 \\times 10^{-3} = 1000 $$\n预期未患病人数（阴性）为：\n$$ N_{neg} = N \\times (1-p) = 10^6 \\times (1 - 10^{-3}) = 10^6 \\times 0.999 = 999000 $$\n\n在指定的工作阈值 $\\tau^\\star$ 下，我们有 $\\mathrm{TPR}(\\tau^\\star) = 0.90$ 和 $\\mathrm{FPR}(\\tau^\\star) = 0.01$。\n\n预期真阳性（$\\mathrm{TP}$）数量是正确识别的患病人数：\n$$ \\mathrm{TP} = P \\times \\mathrm{TPR}(\\tau^\\star) = 1000 \\times 0.90 = 900 $$\n预期假阳性（$\\mathrm{FP}$）数量是错误识别的健康人数：\n$$ \\mathrm{FP} = N_{neg} \\times \\mathrm{FPR}(\\tau^\\star) = 999000 \\times 0.01 = 9990 $$\n\n接下来，我们计算此阈值下的精确率（或阳性预测值，$\\mathrm{PPV}$）。精确率是阳性预测中正确的比例：\n$$ \\mathrm{PPV}(\\tau^\\star) = \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}} = \\frac{900}{900 + 9990} = \\frac{900}{10890} = \\frac{10}{121} \\approx 0.0826 $$\n这个结果可以使用由贝叶斯定理推导出的给定公式来确认：\n$$ \\mathrm{PPV}(\\tau^\\star) = \\frac{\\mathrm{TPR}(\\tau^\\star)\\,p}{\\mathrm{TPR}(\\tau^\\star)\\,p + \\mathrm{FPR}(\\tau^\\star)\\,(1-p)} = \\frac{(0.90)(10^{-3})}{(0.90)(10^{-3}) + (0.01)(1-10^{-3})} = \\frac{0.0009}{0.0009 + 0.00999} = \\frac{0.0009}{0.01089} \\approx 0.0826 $$\n\n**临床效用解读**\n该分类器在1000个真实病例中识别出900个，这代表了很高的灵敏度（$\\mathrm{TPR}=90\\%$）。假阳性率也很低（$\\mathrm{FPR}=1\\%$）。然而，临床现实由精确率揭示。约 $8.3\\%$ 的 $\\mathrm{PPV}$ 意味着在所有收到阳性测试结果的患者中，超过 $91\\%$ 的人实际上是健康的。假阳性的数量（$9990$）是真阳性数量（$900$）的11倍以上。\n这对临床效用构成了重大问题。这意味着每发现一个真阳性病例，就有 $11$ 名健康个体被错误地要求接受进一步的、可能是侵入性且昂贵的诊断程序，这会引起患者不必要的焦虑，并给医疗资源带来巨大负担。\n\n**ROC-AUC 与 PR-AUC 的比较**\n受试者工作特征（ROC）曲线绘制了 $\\mathrm{TPR}$ 对 $\\mathrm{FPR}$ 的关系。这两个指标都是以真实类别为条件的（即给定 $Y=1$ 或给定 $Y=0$）。因此，ROC曲线及其面积（ROC-AUC）对于类别患病率 $p$ 的变化是不变的。这意味着一个分类器的ROC-AUC无论是在平衡数据集（$p=0.5$）上评估，还是在高度不平衡的数据集（$p=10^{-3}$）上评估，都将是相同的。虽然这衡量了分类器评分的内在判别能力，但在罕见疾病筛查等极端类别不平衡是核心挑战的情境中，这可能具有高度误导性。$0.01$ 的低 $\\mathrm{FPR}$ 可能看起来很优秀，但正如我们所见，当真阴性的数量巨大时，它可能产生大量的假阳性。\n\n精确率-召回率（PR）曲线绘制了精确率（$\\mathrm{PPV}$）对召回率（$\\mathrm{TPR}$）的关系。正如公式和我们的计算所示，精确率严重依赖于患病率 $p$。对于患病率 $p \\ll 1$ 的罕见疾病，$\\mathrm{PPV}$ 公式分母中的 $\\mathrm{FPR}(\\tau)(1-p)$ 项可以轻易地超过 $\\mathrm{TPR}(\\tau)p$ 项，导致非常低的 $\\mathrm{PPV}$，除非 $\\mathrm{FPR}(\\tau)$ 极小（在 $p$ 的数量级或更小）。PR曲线直接可视化了发现阳性病例（召回率）和阳性预测是正确的概率（精确率）之间的权衡。一个差的PR曲线（和低的PR-AUC）立即表明，在有用的召回率水平上，该分类器相对于真阳性产生了太多的假阳性。这直接关系到临床效用，后者关注资源的有效利用和最小化假警报对患者的伤害。\n\n因此，在罕见疾病背景下，PR-AUC 是一个比 ROC-AUC 信息量大得多的指标，因为它正确反映了类别不平衡对测试实际性能的巨大影响。\n\n### 逐项分析\n\n**A. ROC-AUC 更优，因为它对患病率 $p$ 不变，确保了性能评估不受类别不平衡的干扰；这种不变性使得 ROC-AUC 在 $p \\ll 1$ 时成为临床效用的最佳代表。**\n该陈述的前提是正确的（ROC-AUC对 $p$ 不变），但其结论是错误的。正是这种不变性使得ROC-AUC在这种特定情境下成为临床效用的一个*糟糕*的代表。类别不平衡的影响不是一个可以忽略的“混淆因素”；它是临床问题的核心。由于对患病率不敏感，ROC-AUC可能呈现出过于乐观的景象，掩盖了不可接受的假阳性率。\n**裁定：不正确。**\n\n**B. PR-AUC 更优，因为精确率等于阳性预测值，根据贝叶斯定理，它依赖于患病率 $p$；当 $p \\ll 1$ 时，假阳性在资源使用和患者负担中占主导地位，而 PR-AUC 捕捉了 $\\mathrm{TPR}$ 和 $\\mathrm{PPV}$ 之间具有临床意义的权衡。**\n该陈述完全正确。它正确地将精确率（$\\mathrm{PPV}$）确定为临床效用的关键指标，将其与患病率联系起来，并准确描述了在罕见疾病设置（$p \\ll 1$）中假阳性占主导地位的问题。它正确地得出结论，即PR曲线及其AUC捕捉了这种临床上至关重要的权衡。\n**裁定：正确。**\n\n**C. ROC-AUC 和 PR-AUC 对于任何单调评分转换都是等价的，因此在罕见疾病检测中提供关于临床效用的相同信息。**\n该陈述是错误的。虽然两条曲线对于分类器分数的单调变换都是不变的，但曲线本身并不等价，也不提供相同的信息。在ROC空间和PR空间之间不存在对所有分类器和患病率都成立的简单一一对应关系。如前所述，在显著的类别不平衡下，一个分类器可以有很高的ROC-AUC和很低的PR-AUC。\n**裁定：不正确。**\n\n**D. ROC-AUC 更受青睐，因为通过降低决策阈值总能提高精确率，这使得 PR-AUC 不稳定，而 ROC-AUC 能抵抗阈值操纵，因此能更好地反映临床效用。**\n该陈述存在根本性缺陷。降低决策阈值会使分类器更频繁地预测“阳性”。这通常会同时增加$\\mathrm{TP}$和$\\mathrm{FP}$的总数。对精确率 $\\mathrm{PPV} = \\mathrm{TP}/(\\mathrm{TP}+\\mathrm{FP})$ 的影响不保证是增加。实际上，为了获得更高的精确率，通常需要*提高*阈值，这会降低召回率。该论点关于降低阈值对精确率影响的前提在事实上是错误的。\n**裁定：不正确。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在掌握了统计性能评估后，我们必须回答一个更重要的问题：这个模型在临床决策中真的有用吗？决策曲线分析（DCA）为此提供了一个强有力的框架，它将模型的预测性能与临床后果直接挂钩。在最后的这个实践中 ，你将从第一性原理出发构建决策曲线，以确定在何种临床偏好（风险阈值）范围内，使用你的模型比“全部治疗”或“全部不治疗”等默认策略能带来更高的净获益。",
            "id": "3904334",
            "problem": "给定一个癌症筛查风险模型的验证预测结果以及多个独立队列的相应二元结局。目标是为每个队列构建模型的决策曲线，并确定在该阈值概率范围内，模型的临床净获益严格高于“治疗全部”和“不治疗”两种策略。这项工作必须基于决策理论原理，并从第一性原理出发进行构建，而不是使用简便公式。\n\n从适用于生物医学系统建模和模型验证的有效基本基础开始，具体如下：\n- 定义一个二元结局 $y_i \\in \\{0,1\\}$，其中 $y_i=1$ 表示个体 $i$ 患有癌症，$y_i=0$ 表示个体 $i$ 未患癌症。\n- 令 $p_i \\in [0,1]$ 表示对个体 $i$ 的校准后验证预测，代表其估计的患癌概率。\n- 给定一个阈值概率 $p_t \\in (0,1)$，该阈值被解释为临床干预变得合理的风险水平，定义二元决策规则 $d_i(p_t)$：当且仅当 $p_i \\ge p_t$ 时，对个体 $i$ 进行治疗，否则不进行治疗。\n- 从决策分析的第一性原理出发，将临床净获益表示为正确治疗病例的预期获益减去错误治疗非病例的预期危害，并按人群规模进行归一化。通过将决策规则与混淆矩阵计数以及阈值所隐含的获益与危害之间的交换率相结合，推导出必要的表达式。\n- 定义“治疗全部”策略为对所有 $i$ 都有 $d_i^{\\text{all}}=1$，“不治疗”策略为对所有 $i$ 都有 $d_i^{\\text{none}}=0$。将这些用作比较基准。\n\n您必须实现以下任务：\n- 对于每个队列，通过在一个均匀的阈值概率网格 $p_t \\in \\{0.01,0.02,\\ldots,0.99\\}$ 上计算模型的净获益、“治疗全部”策略的净获益和“不治疗”策略的净获益，来构建决策曲线。这些概率以小数形式表示（而非百分比）。\n- 在此网格上确定连续的阈值区间，在这些区间内，模型的净获益严格大于“治疗全部”策略的净获益，且严格大于“不治疗”策略的净获益。将每个区间报告为 $[a,b]$ 的形式，其中 $a$ 和 $b$ 是直接从网格中获取的包含性边界。\n- 将最终的区间边界表示为四舍五入到三位小数的小数概率。\n\n测试套件包含三个独立队列及其验证预测和结局。每个队列表示为一个列表对 $(\\{p_i\\},\\{y_i\\})$：\n\n队列 $1$ ($n=20$):\n- 验证预测 $\\{0.02,0.05,0.10,0.15,0.20,0.25,0.35,0.40,0.45,0.55,0.60,0.65,0.70,0.75,0.80,0.85,0.90,0.30,0.50,0.95\\}$。\n- 结局 $\\{0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,1\\}$。\n\n队列 $2$ ($n=15$):\n- 验证预测 $\\{0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.30,0.20,0.27,0.23\\}$。\n- 结局 $\\{0,1,0,0,1,0,0,0,1,0,0,1,0,0,0\\}$。\n\n队列 $3$ ($n=10$):\n- 验证预测 $\\{0.00,0.00,0.00,0.00,1.00,1.00,1.00,1.00,1.00,1.00\\}$。\n- 结局 $\\{0,0,0,0,1,1,1,1,1,1\\}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个队列，并且其本身是一个由 $[a,b]$ 区间组成的列表。例如，输出必须类似于 $[[[a_1,b_1],[a_2,b_2]],[],[[a_3,b_3]]]$，所有数字均四舍五入到三位小数。如果某个队列在任何阈值下模型都不严格优于两个比较基准，则为该队列输出一个空列表。\n\n所有概率和阈值都必须视为无单位的小数值。不要使用百分号。此问题不涉及角度。\n\n最终输出必须遵循所述的确切格式，并打印为单行。不应打印任何其他文本。",
            "solution": "该问题要求确定阈值概率范围，在此范围内，临床风险模型提供的净获益要大于治疗所有患者和不治疗任何患者这两种策略。解决方案需要从决策理论的第一性原理推导出净获益指标，然后通过计算实现来为给定的三个队列找到指定的范围。\n\n首先，我们建立净获益（Net Benefit, $NB$）的理论基础。该分析基于二元结局 $y_i \\in \\{0, 1\\}$，其中 $y_i=1$ 表示存在某种状况（例如癌症），而 $y_i=0$ 表示不存在。模型为每个个体 $i$ 提供一个风险评分 $p_i \\in [0, 1]$。临床干预（治疗）的决策基于一个阈值概率 $p_t \\in (0, 1)$。决策规则是当且仅当个体 $i$ 的预测风险 $p_i$ 大于或等于阈值时，即 $p_i \\ge p_t$，才对其进行治疗。\n\n决策理论假定，如果一项决策的预期收益为正，则应做出该决策。设 $B$ 为真阳性（治疗患有该病的患者）的获益，设 $H$ 为假阳性（治疗未患该病的患者）的危害。治疗一个真实、潜在患病概率为 $p$ 的患者的预期收益为 $E[\\text{treat}] = p \\cdot B - (1-p) \\cdot H$。如果 $E[\\text{treat}]  E[\\text{not treat}]$，则治疗决策是合理的。假设不治疗的净获益为 $0$，则当 $p \\cdot B - (1-p) \\cdot H  0$ 时我们进行治疗。阈值概率 $p_t$ 代表无差异点，在该点上，治疗的预期收益等于不治疗的预期收益：$p_t \\cdot B = (1-p_t) \\cdot H$。由此得出该阈值所隐含的危害与获益之间的“交换率”：\n$$\n\\frac{H}{B} = \\frac{p_t}{1-p_t}\n$$\n此关系表明，对于给定的 $p_t$，一个假阳性的危害等同于 $\\frac{p_t}{1-p_t}$ 个真阳性的获益。\n\n整个队列的净获益定义为总获益减去总危害，并根据队列中的个体总数进行归一化。设 $N$ 为总人口规模。对于给定的阈值 $p_t$，我们可以计算出真阳性数量 $TP(p_t)$ 和假阳性数量 $FP(p_t)$。总获益为 $TP(p_t) \\cdot B$，总危害为 $FP(p_t) \\cdot H$。人群层面的净获益是：\n$$\nNB_{\\text{total}} = TP(p_t) \\cdot B - FP(p_t) \\cdot H\n$$\n为了使该指标独立于 $B$ 的具体单位，并用 $p_t$ 来表示它，我们可以除以 $B$ 并代入交换率。然后通过除以 $N$ 得到每个个体的净获益：\n$$\nNB_{\\text{model}}(p_t) = \\frac{TP(p_t) \\cdot B - FP(p_t) \\cdot H}{N \\cdot B} = \\frac{TP(p_t)}{N} - \\frac{FP(p_t)}{N} \\left(\\frac{H}{B}\\right)\n$$\n代入 $\\frac{H}{B} = \\frac{p_t}{1-p_t}$，我们得到模型净获益的标准公式：\n$$\nNB_{\\text{model}}(p_t) = \\frac{TP(p_t)}{N} - \\frac{FP(p_t)}{N} \\frac{p_t}{1-p_t}\n$$\n\n接下来，我们定义两种比较基准策略的净获益。\n“不治疗”策略导致 $TP=0$ 和 $FP=0$。因此，其净获益始终为零：\n$$\nNB_{\\text{none}}(p_t) = 0\n$$\n“治疗全部”策略导致治疗队列中的每个个体。真阳性的数量等于患有该病的个体总数 $N_{pos}$，假阳性的数量等于未患该病的个体总数 $N_{neg}$。设该病在队列中的患病率为 $\\pi = N_{pos} / N$。那么 $N_{neg}/N = 1-\\pi$。净获益为：\n$$\nNB_{\\text{all}}(p_t) = \\frac{N_{pos}}{N} - \\frac{N_{neg}}{N} \\frac{p_t}{1-p_t} = \\pi - (1-\\pi) \\frac{p_t}{1-p_t}\n$$\n\n目标是找到 $p_t$ 的区间，在这些区间内，模型严格优于两种比较基准，即 $NB_{\\text{model}}(p_t)  NB_{\\text{all}}(p_t)$ 且 $NB_{\\text{model}}(p_t)  NB_{\\text{none}}(p_t)$。\n\n对于每个队列，算法按以下步骤进行：\n1.  初始化一个空列表，用于存储模型表现更优的阈值 $p_t$。\n2.  遍历指定网格 $\\{0.01, 0.02, \\ldots, 0.99\\}$ 中的每个阈值 $p_t$。\n3.  对于每个 $p_t$：\n    a. 将决策规则（$p_i \\ge p_t$）应用于队列的预测值 $\\{p_i\\}$ 和结局 $\\{y_i\\}$，计算 $TP(p_t)$ 和 $FP(p_t)$。\n    b. 使用推导出的公式计算 $NB_{\\text{model}}(p_t)$、$NB_{\\text{all}}(p_t)$ 和 $NB_{\\text{none}}(p_t)$。\n    c. 如果 $NB_{\\text{model}}(p_t)  NB_{\\text{all}}(p_t)$ 且 $NB_{\\text{model}}(p_t)  NB_{\\text{none}}(p_t)$，则将 $p_t$ 添加到最优阈值列表中。\n4.  遍历所有阈值后，处理最优阈值列表以识别连续区间。如果一个区间的构成阈值在网格中是连续的（例如，$0.21, 0.22, 0.23$），则该区间是连续的。\n5.  将识别出的区间格式化为 $[a, b]$，其中 $a$ 和 $b$ 是从网格中获取的包含性起始和结束边界，并以三位小数表示。为每个队列收集这些区间。\n6.  最后，将所有队列的结果汇总成指定的最终输出格式。\n此过程被系统地应用于问题陈述中提供的三个队列中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the decision curve analysis problem for given cohorts.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            [0.02, 0.05, 0.10, 0.15, 0.20, 0.25, 0.35, 0.40, 0.45, 0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.30, 0.50, 0.95],\n            [0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,1]\n        ),\n        (\n            [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.30, 0.20, 0.27, 0.23],\n            [0,1,0,0,1,0,0,0,1,0,0,1,0,0,0]\n        ),\n        (\n            [0.00, 0.00, 0.00, 0.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n            [0,0,0,0,1,1,1,1,1,1]\n        )\n    ]\n\n    pt_grid = np.arange(0.01, 1.00, 0.01)\n    all_cohort_results = []\n\n    for predictions, outcomes in test_cases:\n        p = np.array(predictions)\n        y = np.array(outcomes)\n        n = len(y)\n        \n        if n == 0:\n            all_cohort_results.append([])\n            continue\n\n        prevalence = np.sum(y) / n\n        superior_thresholds = []\n\n        for pt in pt_grid:\n            # The denominator (1-pt) would be zero if pt=1, but the grid excludes it.\n            exchange_rate = pt / (1 - pt)\n\n            # Model Net Benefit\n            treated_mask = p >= pt\n            tp = np.sum(treated_mask  (y == 1))\n            fp = np.sum(treated_mask  (y == 0))\n            nb_model = (tp / n) - (fp / n) * exchange_rate\n\n            # Comparator Net Benefits\n            nb_treat_all = prevalence - (1 - prevalence) * exchange_rate\n            nb_treat_none = 0.0\n\n            if nb_model > nb_treat_all and nb_model > nb_treat_none:\n                superior_thresholds.append(pt)\n\n        # Find contiguous intervals from the list of superior thresholds\n        intervals = []\n        if superior_thresholds:\n            start_interval = superior_thresholds[0]\n            for i in range(1, len(superior_thresholds)):\n                # Check for a gap in the sequence of thresholds.\n                # Use a small tolerance for floating point comparison.\n                if superior_thresholds[i] - superior_thresholds[i-1] > (0.01 + 1e-9):\n                    end_interval = superior_thresholds[i-1]\n                    intervals.append([start_interval, end_interval])\n                    start_interval = superior_thresholds[i]\n            \n            # Add the last interval\n            end_interval = superior_thresholds[-1]\n            intervals.append([start_interval, end_interval])\n\n        all_cohort_results.append(intervals)\n\n    # Format the final output string exactly as specified.\n    cohort_strs = []\n    for cohort_intervals in all_cohort_results:\n        if not cohort_intervals:\n            cohort_strs.append(\"[]\")\n        else:\n            interval_strs = [f\"[{start:.3f},{end:.3f}]\" for start, end in cohort_intervals]\n            cohort_strs.append(f\"[{','.join(interval_strs)}]\")\n    \n    final_output = f\"[{','.join(cohort_strs)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}