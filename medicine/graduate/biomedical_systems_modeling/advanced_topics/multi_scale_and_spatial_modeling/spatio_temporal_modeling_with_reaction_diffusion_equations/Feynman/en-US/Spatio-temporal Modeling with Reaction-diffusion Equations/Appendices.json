{
    "hands_on_practices": [
        {
            "introduction": "While modeling diffusion in infinite space offers key insights, most biological processes occur within confined geometries like cells or tissues. This practice explores how physical boundaries shape the spatio-temporal evolution of a diffusing substance. By solving the diffusion equation on a bounded domain with impermeable walls, you will see how boundary conditions give rise to a discrete set of spatial patterns, or \"modes,\" each with a characteristic temporal decay rate determined by an eigenvalue. This exercise provides a foundational understanding of how a system's geometry constrains its dynamics, connecting the abstract mathematical concept of eigenvalues to the concrete physical process of concentration homogenization .",
            "id": "3929096",
            "problem": "A signaling molecule is released uniformly into a thin, square tissue slice of side length $L$ and subsequently undergoes passive diffusion with no reaction and no external sources. The tissue boundaries are impermeable due to a surrounding barrier, so there is no net flux across the boundary. The concentration field $c(x,y,t)$ obeys conservation of mass and Fick’s law, which together yield the Partial Differential Equation (PDE) $ \\partial c/\\partial t = D \\nabla^2 c $ for $ (x,y) \\in (0,L) \\times (0,L) $ and $ t > 0 $, where $D$ is the diffusion coefficient. The boundary condition is zero normal flux on each edge of the square.\n\nStarting from conservation of mass and Fick’s law, use separation of variables to formulate and solve the spatial eigenvalue problem on the square domain with zero-flux boundaries. Then connect the spatial eigenvalues to the temporal decay rates of the diffusive modes. Determine the slowest non-zero temporal decay rate of perturbations to the concentration (i.e., the smallest positive decay rate among all non-constant modes) as an analytic expression in terms of $D$ and $L$.\n\nExpress your final answer in $ \\mathrm{s}^{-1} $. If you obtain a symbolic expression, do not round.",
            "solution": "The analysis of this problem begins with the fundamental principles of mass transport. The conservation of mass for a species with concentration $c(\\mathbf{r}, t)$ within an arbitrary control volume $V$ bounded by a surface $\\partial V$ is expressed in integral form as:\n$$\n\\frac{d}{dt} \\int_V c \\, dV = - \\oint_{\\partial V} \\mathbf{J} \\cdot \\mathbf{\\hat{n}} \\, dA\n$$\nwhere $\\mathbf{J}$ is the mass flux vector and $\\mathbf{\\hat{n}}$ is the outward unit normal to the surface element $dA$. By applying the divergence theorem to the surface integral, $\\oint_{\\partial V} \\mathbf{J} \\cdot \\mathbf{\\hat{n}} \\, dA = \\int_V (\\nabla \\cdot \\mathbf{J}) \\, dV$, and bringing the time derivative inside the volume integral, we obtain:\n$$\n\\int_V \\frac{\\partial c}{\\partial t} \\, dV = - \\int_V (\\nabla \\cdot \\mathbf{J}) \\, dV\n$$\nSince this relation must hold for any arbitrary control volume $V$, the integrands must be equal, yielding the differential form of the continuity equation:\n$$\n\\frac{\\partial c}{\\partial t} = - \\nabla \\cdot \\mathbf{J}\n$$\nThe problem states that the molecule undergoes passive diffusion, which is described by Fick's first law. This law posits that the flux is proportional to the negative of the concentration gradient:\n$$\n\\mathbf{J} = -D \\nabla c\n$$\nwhere $D$ is the diffusion coefficient, assumed to be a constant scalar. Substituting Fick's law into the continuity equation gives:\n$$\n\\frac{\\partial c}{\\partial t} = - \\nabla \\cdot (-D \\nabla c) = \\nabla \\cdot (D \\nabla c)\n$$\nAs $D$ is constant, it can be factored out of the divergence operator, resulting in the diffusion equation, as provided in the problem statement:\n$$\n\\frac{\\partial c}{\\partial t} = D \\nabla^2 c\n$$\nThe domain is a square $(x,y) \\in [0,L] \\times [0,L]$. The boundary conditions specify that the boundaries are impermeable, meaning there is zero net flux across them. This is expressed as $\\mathbf{J} \\cdot \\mathbf{\\hat{n}} = 0$ on all boundaries. Using $\\mathbf{J} = -D \\nabla c$, this becomes $-D (\\nabla c \\cdot \\mathbf{\\hat{n}}) = 0$. Since $D \\ne 0$, the condition is equivalent to the normal derivative of the concentration being zero, $\\frac{\\partial c}{\\partial n} = \\nabla c \\cdot \\mathbf{\\hat{n}} = 0$. For the square domain, this yields the following four Neumann boundary conditions:\n$1.$ At $x=0$: $\\frac{\\partial c}{\\partial x}(0, y, t) = 0$ for $y \\in (0,L)$\n$2.$ At $x=L$: $\\frac{\\partial c}{\\partial x}(L, y, t) = 0$ for $y \\in (0,L)$\n$3.$ At $y=0$: $\\frac{\\partial c}{\\partial y}(x, 0, t) = 0$ for $x \\in (0,L)$\n$4.$ At $y=L$: $\\frac{\\partial c}{\\partial y}(x, L, t) = 0$ for $x \\in (0,L)$\n\nTo solve the partial differential equation, we employ the method of separation of variables. We seek solutions of the form $c(x,y,t) = S(x,y)T(t)$. Substituting this into the diffusion equation yields:\n$$\nS(x,y) \\frac{dT(t)}{dt} = D T(t) \\nabla^2 S(x,y)\n$$\nDividing by $D S(x,y)T(t)$ separates the variables:\n$$\n\\frac{1}{D T(t)} \\frac{dT(t)}{dt} = \\frac{\\nabla^2 S(x,y)}{S(x,y)}\n$$\nThe left side is a function of $t$ only, while the right side is a function of $x$ and $y$ only. For these to be equal for all $(x,y,t)$, they must both be equal to a constant. We denote this separation constant as $-\\lambda$. This yields two ordinary differential equations:\nTemporal equation: $\\frac{dT}{dt} = -\\lambda D T$\nSpatial equation: $\\nabla^2 S + \\lambda S = 0$ (the Helmholtz equation)\n\nThe temporal equation has the solution $T(t) = T(0) \\exp(-\\lambda D t)$. The term $\\gamma = \\lambda D$ is the temporal decay rate of a given mode. For a physically realistic solution in a closed system where concentrations do not grow unboundedly, we expect $\\lambda \\ge 0$.\n\nThe spatial part is a two-dimensional eigenvalue problem. We solve the Helmholtz equation on the square domain with the corresponding Neumann boundary conditions on $S(x,y)$:\n$\\frac{\\partial S}{\\partial x}(0,y) = 0$, $\\frac{\\partial S}{\\partial x}(L,y) = 0$, $\\frac{\\partial S}{\\partial y}(x,0) = 0$, $\\frac{\\partial S}{\\partial y}(x,L) = 0$.\nWe apply separation of variables again to the spatial function, setting $S(x,y) = X(x)Y(y)$. Substituting into the Helmholtz equation:\n$$\nY(y)\\frac{d^2X(x)}{dx^2} + X(x)\\frac{d^2Y(y)}{dy^2} + \\lambda X(x)Y(y) = 0\n$$\nDividing by $X(x)Y(y)$ yields:\n$$\n\\frac{1}{X(x)}\\frac{d^2X}{dx^2} + \\frac{1}{Y(y)}\\frac{d^2Y}{dy^2} + \\lambda = 0\n$$\nWe can rearrange this as $\\frac{1}{X}\\frac{d^2X}{dx^2} = -\\lambda - \\frac{1}{Y}\\frac{d^2Y}{dy^2}$. The left side depends only on $x$ and the right only on $y$. Thus, both must equal a constant, which we denote $-k_x^2$. This gives two one-dimensional eigenvalue problems:\n$1.$ $\\frac{d^2X}{dx^2} + k_x^2 X = 0$, with boundary conditions $X'(0)=0$ and $X'(L)=0$.\n$2.$ $\\frac{d^2Y}{dy^2} + k_y^2 Y = 0$, with boundary conditions $Y'(0)=0$ and $Y'(L)=0$, where $k_y^2 = \\lambda - k_x^2$.\n\nLet's solve for $X(x)$. The general solution to $X'' + k_x^2 X = 0$ is $X(x) = A \\cos(k_x x) + B \\sin(k_x x)$. The derivative is $X'(x) = -A k_x \\sin(k_x x) + B k_x \\cos(k_x x)$.\nApplying the boundary condition at $x=0$: $X'(0) = B k_x = 0$. If $k_x \\neq 0$, then $B=0$.\nThe solution becomes $X(x) = A \\cos(k_x x)$. Applying the boundary condition at $x=L$: $X'(L) = -A k_x \\sin(k_x L) = 0$. For a non-trivial solution ($A \\ne 0, k_x \\ne 0$), we must have $\\sin(k_x L) = 0$. This implies $k_x L = n\\pi$ for $n \\in \\{1, 2, 3, \\dots\\}$. Thus, $k_x = \\frac{n\\pi}{L}$.\nWe must also consider the case $k_x=0$. The equation becomes $X''=0$, with solution $X(x) = C_1 x + C_2$. The boundary conditions $X'(0)=0$ and $X'(L)=0$ both give $C_1=0$. Thus $X(x) = C_2$ (a constant) is a valid eigenfunction. This case corresponds to $n=0$ in the formula $k_x = \\frac{n\\pi}{L}$. The eigenfunctions are therefore $X_n(x) = \\cos(\\frac{n\\pi x}{L})$ for $n \\in \\{0, 1, 2, \\dots\\}$.\n\nThe problem for $Y(y)$ is identical in form. The eigenfunctions are $Y_m(y) = \\cos(\\frac{m\\pi y}{L})$ with corresponding eigenvalues $k_y^2 = (\\frac{m\\pi}{L})^2$ for $m \\in \\{0, 1, 2, \\dots\\}$.\n\nThe spatial eigenvalues $\\lambda$ are given by the sum $\\lambda_{nm} = k_x^2 + k_y^2$:\n$$\n\\lambda_{nm} = \\left(\\frac{n\\pi}{L}\\right)^2 + \\left(\\frac{m\\pi}{L}\\right)^2 = \\frac{\\pi^2}{L^2}(n^2 + m^2)\n$$\nwhere $n$ and $m$ are non-negative integers. Each pair $(n,m)$ defines a spatial mode $S_{nm}(x,y) = \\cos(\\frac{n\\pi x}{L})\\cos(\\frac{m\\pi y}{L})$ with a corresponding temporal decay rate $\\gamma_{nm} = D \\lambda_{nm} = \\frac{D\\pi^2}{L^2}(n^2+m^2)$.\n\nThe problem asks for the slowest non-zero temporal decay rate of perturbations. The term \"perturbation\" refers to any non-constant spatial variation from the mean concentration.\nLet's analyze the decay rates:\nThe mode $(n,m) = (0,0)$ gives $\\lambda_{00} = 0$ and a decay rate $\\gamma_{00}=0$. The corresponding eigenfunction $S_{00}(x,y)=1$ represents a spatially uniform concentration. This is the DC component or the steady-state average concentration, which is conserved over time in a closed system and thus does not decay.\nAny deviation from this uniform state is a superposition of modes with $(n,m) \\neq (0,0)$. These are the \"non-constant modes\" or perturbations. We need to find the smallest positive value of $\\gamma_{nm}$. This is equivalent to finding the minimum value of $n^2+m^2$ for non-negative integers $n,m$, where not both are zero.\nPossible values for integer $n, m \\ge 0$:\n- If $(n,m) = (0,0)$, then $n^2+m^2=0$. This gives $\\gamma_{00}=0$.\n- If one index is $1$ and the other is $0$, e.g., $(n,m)=(1,0)$ or $(0,1)$, then $n^2+m^2 = 1^2+0^2 = 1$.\n- If $(n,m) = (1,1)$, then $n^2+m^2=1^2+1^2=2$.\n- If one index is $2$ and the other is $0$, e.g., $(n,m)=(2,0)$ or $(0,2)$, then $n^2+m^2=2^2+0^2=4$.\n\nThe minimum non-zero value of $n^2+m^2$ is $1$. This occurs for the modes $(n,m)=(1,0)$ and $(n,m)=(0,1)$. These are the fundamental modes of decay.\nThe slowest non-zero temporal decay rate is therefore:\n$$\n\\gamma_{\\text{min, non-zero}} = \\frac{D\\pi^2}{L^2}(1) = \\frac{D\\pi^2}{L^2}\n$$\nThis rate corresponds to the decay of the longest wavelength perturbations that fit within the domain, specifically $\\cos(\\pi x/L)$ and $\\cos(\\pi y/L)$.",
            "answer": "$$\\boxed{\\frac{D\\pi^{2}}{L^{2}}}$$"
        },
        {
            "introduction": "Moving from analytical theory to computational modeling, we confront the challenge of creating numerical schemes that respect fundamental physical laws. For biochemical concentrations, a critical constraint is non-negativity. This hands-on coding practice demonstrates how a seemingly straightforward explicit numerical method can fail by producing unphysical negative concentrations under certain conditions . By implementing and comparing this with a positivity-preserving implicit scheme, you will gain practical experience in diagnosing numerical instabilities and learn why the choice of time-stepping method is crucial for building robust and reliable simulations of physical systems.",
            "id": "3929058",
            "problem": "Consider a one-dimensional reaction-diffusion model for a nonnegative biochemical concentration field $u(x,t)$ governed by the partial differential equation\n$$\n\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} - k u\n$$\non the spatial interval $x \\in [0,L]$ with zero-flux (Neumann) boundary conditions and nonnegative initial condition. Here $D \\ge 0$ is the diffusion coefficient and $k \\ge 0$ is the first-order reaction decay rate. It is a well-tested fact in parabolic partial differential equations that the continuous problem preserves nonnegativity: if $u(x,0) \\ge 0$ and the boundary condition is zero-flux, then $u(x,t) \\ge 0$ for all $t \\ge 0$.\n\nYour task is to derive, implement, and test two time-stepping discretizations on a uniform grid with spacing $h = L/(N-1)$:\n- A naive explicit method (forward Euler in time with central differences in space).\n- A positivity-preserving method (backward Euler in time with the same central difference spatial operator).\n\nStarting from Fick’s law and conservation of mass, derive conditions under which the explicit method can violate nonnegativity, and explain why the implicit method preserves nonnegativity for arbitrary time step sizes. Use mirrored ghost points to impose the zero-flux boundary condition in the finite difference discretization at $x=0$ and $x=L$.\n\nImplementation requirements:\n- Use a uniform grid with $N$ points and enforce zero-flux boundaries by mirror reflection in the discretization of the second spatial derivative.\n- Initialize $u(x,0)$ as a nonnegative smooth bump:\n$$\nu(x,0) = \\exp\\!\\left(-\\frac{(x - L/2)^2}{2 \\sigma^2}\\right),\n$$\nwith $\\sigma = 0.1L$.\n- For each time step, detect whether any grid value becomes negative (strict negativity below a tolerance of $-10^{-12}$ counts as negative).\n- For the implicit method, solve the linear system at each step exactly using a sparse direct solver.\n\nTest suite:\nImplement the simulation for the following four parameter sets. For each case, simulate over a total time $T$ using a specified time step $\\Delta t$ as described below. Use $L=1$ and $N=101$ for all cases.\n\n1. Case A (diffusion and reaction, explicit instability expected):\n   - $D = 1.0$, $k = 0.5$, $T = 0.01$, $\\Delta t = 0.001$.\n\n2. Case B (pure diffusion, explicit instability expected):\n   - $D = 0.1$, $k = 0.0$, $T = 0.05$, $\\Delta t = 0.005$.\n\n3. Case C (pure reaction decay, explicit instability expected when $\\Delta t > 1/k$):\n   - $D = 0.0$, $k = 5.0$, $T = 1.0$, $\\Delta t = 0.5$.\n\n4. Case D (explicit method at the positivity boundary condition):\n   - $D = 1.0$, $k = 0.0$, $T = 0.001$, $\\Delta t$ chosen exactly at the explicit positivity threshold\n   $$\n   \\Delta t = \\frac{1}{\\frac{2D}{h^2} + k}.\n   $$\n\nOutput specification:\n- For each of the four cases, run both methods and report a pair of boolean values $[b_{\\text{explicit}}, b_{\\text{implicit}}]$, where each boolean is true if and only if any negative values occur during the time integration for that method (using the strict threshold $-10^{-12}$).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The output must therefore be a list of four two-element lists, one per test case, for example `[[true,false],[true,false],[true,false],[false,false]]`.\nNo physical units are required in the output because the reported values are booleans. Ensure your implementation is scientifically realistic and numerically self-consistent, and do not use any shortcut formulas beyond what is derived from the governing equation and boundary conditions.",
            "solution": "The governing partial differential equation is\n$$\n\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} - k u,\n$$\nwith $D \\ge 0$, $k \\ge 0$, and zero-flux boundary conditions $\\frac{\\partial u}{\\partial x}(0,t) = 0$ and $\\frac{\\partial u}{\\partial x}(L,t) = 0$. For nonnegative initial data $u(x,0) \\ge 0$, the maximum principle for parabolic equations indicates that the continuous solution maintains $u(x,t) \\ge 0$ for all $t \\ge 0$.\n\nWe discretize space on a uniform grid $x_i = i h$ with $h = L/(N-1)$ and indices $i = 0,1,\\dots,N-1$. The second derivative is approximated by the central difference operator\n$$\n\\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_i \\approx \\frac{u_{i+1} - 2 u_i + u_{i-1}}{h^2},\n$$\nwith mirrored ghost points to enforce zero-flux boundaries. For $i=0$, mirroring enforces $u_{-1} = u_1$, so\n$$\n\\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_0 \\approx \\frac{u_{1} - 2 u_0 + u_{-1}}{h^2} = \\frac{2 u_1 - 2 u_0}{h^2}.\n$$\nSimilarly, for $i=N-1$, mirroring gives $u_{N} = u_{N-2}$,\n$$\n\\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{N-1} \\approx \\frac{2 u_{N-2} - 2 u_{N-1}}{h^2}.\n$$\n\nExplicit method (forward Euler in time):\nFrom first principles, forward Euler applies the temporal update\n$$\nu_i^{n+1} = u_i^n + \\Delta t \\left( D \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_i^n - k u_i^n \\right),\n$$\nwhich for interior nodes yields\n$$\nu_i^{n+1} = u_i^n + \\Delta t \\left( D \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{h^2} - k u_i^n \\right).\n$$\nDefine the dimensionless parameters $r = \\frac{D \\Delta t}{h^2}$ and $s = k \\Delta t$. The explicit update can be written as a linear combination of current and neighbor values:\n$$\nu_i^{n+1} = (1 - 2 r - s) u_i^n + r u_{i-1}^n + r u_{i+1}^n,\n$$\nand at the boundaries\n$$\nu_0^{n+1} = (1 - 2 r - s) u_0^n + 2 r u_1^n, \\quad\nu_{N-1}^{n+1} = (1 - 2 r - s) u_{N-1}^n + 2 r u_{N-2}^n.\n$$\nA sufficient condition for the explicit method to preserve nonnegativity for nonnegative $u^n$ is that all coefficients in the convex combination are nonnegative. This requires\n$$\nr \\ge 0 \\quad \\text{and} \\quad 1 - 2 r - s \\ge 0 \\quad \\Longleftrightarrow \\quad \\Delta t \\le \\frac{1}{\\frac{2D}{h^2} + k}.\n$$\nWhen this condition is violated, the self-weight $1 - 2 r - s$ becomes negative, and the update may produce $u_i^{n+1} < 0$ even if all $u^n$ are nonnegative. This is the mechanism by which naive explicit discretizations can violate positivity.\n\nImplicit method (backward Euler in time):\nBackward Euler updates according to\n$$\nu^{n+1} - \\Delta t \\left(D \\frac{\\partial^2 u^{n+1}}{\\partial x^2} - k u^{n+1}\\right) = u^n,\n$$\nwhich can be written as a linear system\n$$\n\\left( \\mathbf{I} + s \\mathbf{I} - r \\mathbf{L} \\right) \\mathbf{u}^{n+1} = \\mathbf{u}^n,\n$$\nwhere $\\mathbf{L}$ is the discrete Laplacian with mirrored Neumann boundaries. The structure of $\\mathbf{L}$ is tri-diagonal with main diagonal entries $-2/h^2$ and off-diagonal entries $1/h^2$ for interior nodes, while the boundary-adjacent off-diagonal entries are $2/h^2$ due to mirroring:\n$$\n\\mathbf{L} =\n\\begin{bmatrix}\n-2/h^2 & 2/h^2 & 0 & \\cdots & 0 \\\\\n1/h^2 & -2/h^2 & 1/h^2 & \\ddots & \\vdots \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & \\ddots & 1/h^2 & -2/h^2 & 1/h^2 \\\\\n0 & \\cdots & 0 & 2/h^2 & -2/h^2\n\\end{bmatrix}.\n$$\nTherefore, the system matrix\n$$\n\\mathbf{M} = \\mathbf{I} + s \\mathbf{I} - r \\mathbf{L}\n$$\nhas strictly positive diagonal entries and nonpositive off-diagonal entries, and is strictly diagonally dominant for $r \\ge 0$, $s \\ge 0$. Such matrices are monotone matrices, specifically M-matrices. A fundamental property of M-matrices is that $\\mathbf{M}^{-1} \\ge 0$ component-wise. Consequently, for nonnegative $\\mathbf{u}^n$, the update\n$$\n\\mathbf{u}^{n+1} = \\mathbf{M}^{-1} \\mathbf{u}^n\n$$\nsatisfies $\\mathbf{u}^{n+1} \\ge 0$ for any $\\Delta t > 0$. Hence, backward Euler preserves nonnegativity unconditionally.\n\nAlgorithmic design:\n- Discretize the domain $[0,L]$ with $N$ points and compute $h = L/(N-1)$.\n- Initialize $\\mathbf{u}^0$ from $u(x,0)$ using the specified smooth bump profile.\n- Explicit method: At each time step, compute the discrete Laplacian with mirrored boundaries to get $(\\partial^2 u/\\partial x^2)^n$, and update $\\mathbf{u}^{n+1}$ via forward Euler. Track negativity by checking if $\\min_i u_i^{n+1} < -10^{-12}$.\n- Implicit method: Construct the sparse tri-diagonal matrix $\\mathbf{L}$ that encodes the discrete Laplacian with mirrored boundaries. At each time step, form $\\mathbf{M} = \\mathbf{I} + s \\mathbf{I} - r \\mathbf{L}$ and solve $\\mathbf{M} \\mathbf{u}^{n+1} = \\mathbf{u}^n$ using a sparse direct solver. Check negativity as above.\n\nTest suite rationale:\n- Case A combines diffusion and decay with a large $\\Delta t$ relative to $h$, ensuring $1 - 2 r - s < 0$ and making explicit negativity likely; backward Euler remains nonnegative.\n- Case B isolates diffusion with an unstable explicit $\\Delta t$; backward Euler is positive regardless.\n- Case C isolates reaction decay with $\\Delta t > 1/k$, yielding $u^{n+1} = (1 - k \\Delta t) u^n$ negative for the explicit method, while backward Euler gives $u^{n+1} = \\frac{u^n}{1 + k \\Delta t} \\ge 0$.\n- Case D sets $\\Delta t$ exactly at the explicit positivity threshold, so the explicit scheme becomes a nonnegative convex combination yielding nonnegativity; backward Euler is also nonnegative.\n\nThe program implements these steps and returns, for each case, the pair of booleans $[b_{\\text{explicit}}, b_{\\text{implicit}}]$ indicating whether any negative values were observed during the simulation under the respective method.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef initial_condition(L, N):\n    x = np.linspace(0.0, L, N)\n    sigma = 0.1 * L\n    u0 = np.exp(-((x - L/2.0)**2) / (2.0 * sigma**2))\n    return u0\n\ndef laplacian_neumann(u, h):\n    # Discrete Laplacian with mirrored Neumann boundaries\n    N = len(u)\n    lap = np.zeros_like(u)\n    if N == 1:\n        # Degenerate domain: second derivative zero\n        lap[0] = 0.0\n        return lap\n    lap[1:-1] = (u[2:] - 2.0*u[1:-1] + u[:-2]) / (h**2)\n    lap[0] = (2.0*u[1] - 2.0*u[0]) / (h**2)\n    lap[-1] = (2.0*u[-2] - 2.0*u[-1]) / (h**2)\n    return lap\n\ndef build_L_matrix(N, h):\n    # Build sparse Laplacian with mirrored Neumann boundaries on [0,L]\n    main = np.full(N, -2.0 / (h**2))\n    upper = np.full(N-1, 1.0 / (h**2))\n    lower = np.full(N-1, 1.0 / (h**2))\n    # Adjust for mirrored boundaries: off-diagonal is doubled at boundary adjacency\n    upper[0] = 2.0 / (h**2)      # L[0,1] = 2/h^2\n    lower[-1] = 2.0 / (h**2)     # L[N-1,N-2] = 2/h^2\n    L = diags([lower, main, upper], offsets=[-1, 0, 1], shape=(N, N), format='csc')\n    return L\n\ndef simulate_explicit(D, k, L, N, dt, T, tol=-1e-12):\n    h = L / (N - 1)\n    u = initial_condition(L, N)\n    steps = int(np.round(T / dt))\n    negative_detected = False\n    for _ in range(steps):\n        lap = laplacian_neumann(u, h)\n        u = u + dt * (D * lap - k * u)\n        if np.min(u) < tol:\n            negative_detected = True\n            # Continue running to mimic full simulation; but flag remains set\n    return negative_detected\n\ndef simulate_implicit(D, k, L, N, dt, T, tol=-1e-12):\n    h = L / (N - 1)\n    u = initial_condition(L, N)\n    steps = int(np.round(T / dt))\n    # Build matrices once; M changes with dt but remains constant across steps\n    Lmat = build_L_matrix(N, h)\n    r = D * dt / (h**2)  # used only in forming M consistently with L definition\n    # Form M = I + s I - r L; note r defined as D*dt/h^2 but we directly use D*dt with L entries already contain 1/h^2\n    I = identity(N, format='csc')\n    M = I + (k * dt) * I - (D * dt) * Lmat\n    negative_detected = False\n    for _ in range(steps):\n        u = spsolve(M, u)\n        if np.min(u) < tol:\n            negative_detected = True\n    return negative_detected\n\ndef solve():\n    # Define common domain parameters\n    L = 1.0\n    N = 101\n\n    # Compute h for threshold calculation in Case D\n    h = L / (N - 1)\n\n    test_cases = [\n        # (D, k, T, dt, dt_is_threshold_flag)\n        (1.0, 0.5, 0.01, 0.001, False),     # Case A\n        (0.1, 0.0, 0.05, 0.005, False),     # Case B\n        (0.0, 5.0, 1.0, 0.5, False),        # Case C\n        (1.0, 0.0, 0.001, None, True),      # Case D: dt at threshold\n    ]\n\n    results = []\n    for D, k, T, dt, use_threshold in test_cases:\n        if use_threshold:\n            dt = 1.0 / (2.0 * D / (h**2) + k if (D > 0 or k > 0) else np.inf)\n        # Explicit (naive)\n        neg_explicit = simulate_explicit(D, k, L, N, dt, T)\n        # Implicit (positivity-preserving)\n        neg_implicit = simulate_implicit(D, k, L, N, dt, T)\n        results.append([neg_explicit, neg_implicit])\n\n    # Final print in exact required format.\n    # Convert booleans to lowercase strings to match JSON-like true/false\n    formatted = []\n    for pair in results:\n        formatted.append(f\"[{str(pair[0]).lower()},{str(pair[1]).lower()}]\")\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Advanced simulations of reaction-diffusion systems often employ operator splitting, a powerful technique that decomposes a complex problem into a sequence of simpler, solvable subproblems for reaction and diffusion. However, this simplification is not exact; the order in which the operators are applied matters and introduces a \"splitting error.\" This error originates from the fact that the reaction and diffusion operators do not generally commute. This advanced exercise guides you through implementing a splitting scheme and deriving the leading-order error term, known as the commutator, which provides a deep connection between the practical performance of a numerical method and the underlying mathematical structure of the governing equation .",
            "id": "3928994",
            "problem": "Consider a one-dimensional Partial Differential Equation (PDE) describing a diffusing and reacting biochemical species on a periodic domain, given by $$\\partial_t u(x,t) = D\\,\\partial_{xx} u(x,t) + f\\big(u(x,t)\\big),$$ where $u(x,t)$ is the dimensionless concentration field, $D$ is the dimensionless diffusion coefficient, and $f(u)$ is a dimensionless reaction term. The spatial domain is $x \\in [0,L]$ with periodic boundary conditions, and all quantities in this problem are dimensionless. The operator splitting scheme to be implemented is first-order Lie splitting, in which the reaction and diffusion subproblems are advanced over a single time step of size $\\Delta t$ in a specified order. The diffusion substep should be solved exactly using the Fast Fourier Transform (FFT), and the reaction substep should be solved exactly when possible by pointwise integration of the ordinary differential equation.\n\nUsing only the following well-tested foundational facts as the base: Fick’s second law governs diffusion, so the diffusion operator is $L(u) = D\\,\\partial_{xx}u$; reaction kinetics are local so the reaction vector field is $N(u) = f(u)$; and for periodic domains, the Fourier modes are eigenfunctions of the Laplacian, permitting exact advancement of the diffusion substep in Fourier space.\n\nTasks:\n1. Implement a first-order Lie operator splitting scheme in two orders: reaction-then-diffusion and diffusion-then-reaction, each over one time step $\\Delta t$. Use the FFT to implement the diffusion substep exactly in Fourier space, i.e., each Fourier mode with wavenumber $k$ is multiplied by $\\exp\\!\\big(-D\\,k^2\\,\\Delta t\\big)$. Implement the reaction substep pointwise using the exact solution when $f(u)$ is linear or logistic.\n2. For the analysis of splitting error to first order in $\\Delta t$, compute the difference between the two Lie split orderings applied to the same initial condition $u_0(x)$, defined by $$d(\\Delta t) = \\big(\\mathrm{Diffusion}_{\\Delta t} \\circ \\mathrm{Reaction}_{\\Delta t}\\big)u_0 - \\big(\\mathrm{Reaction}_{\\Delta t} \\circ \\mathrm{Diffusion}_{\\Delta t}\\big)u_0.$$ This quantity isolates the leading commutator contribution in the local error without requiring the unsplit exact evolution.\n3. Derive the leading-order expression for $d(\\Delta t)$ as $\\Delta t \\to 0$ using principled operator analysis and determine the analytic form of the commutator for a one-dimensional scalar field. Implement this analytic leading-order term and use it to assess the first-order splitting error numerically.\n\nNumerical specifications:\n- Domain length: $L = 1$.\n- Spatial grid: uniform grid with $N_x$ points and spacing $\\Delta x = L/N_x$.\n- Wavenumbers: use the FFT convention, with angular wavenumbers given by $k = 2\\pi\\,\\mathrm{fftfreq}(N_x,\\Delta x)$.\n- Discrete $L^2$ norm on the periodic grid: for a grid function $v$, define $$\\|v\\|_2 = \\sqrt{\\Delta x\\,\\sum_{j=0}^{N_x-1} v_j^2}.$$\n\nTest suite and required outputs:\nYou must handle the following three test cases and produce three scalar outputs that quantify distinct aspects of the first-order splitting error. In all cases, take $L = 1$ and report results without units (dimensionless).\n\n- Test Case A (baseline linear reaction):\n  - Parameters: $D = 0.05$, $f(u) = \\alpha\\,u$ with $\\alpha = 0.3$, $N_x = 1024$, $\\Delta t = 10^{-3}$.\n  - Initial condition: $u_0(x) = \\sin(2\\pi x)$.\n  - Output: $$E_A = \\frac{\\|d(\\Delta t)\\|_2}{\\Delta t^2}.$$\n\n- Test Case B (smooth nonlinear logistic reaction):\n  - Parameters: $D = 0.02$, $f(u) = k\\,u\\,(1-u)$ with $k = 5$, $N_x = 1024$, $\\Delta t = 10^{-3}$.\n  - Initial condition: $u_0(x) = 0.2 + 0.1\\,\\sin(2\\pi x)$.\n  - Output: Let $C(u_0)$ denote the analytic commutator term you derive in Task 3 evaluated at $u_0(x)$. Report the relative discrepancy between the measured difference and its analytic leading-order approximation: $$E_B = \\frac{\\big\\|d(\\Delta t) - \\Delta t^2\\,C(u_0)\\big\\|_2}{\\big\\|\\Delta t^2\\,C(u_0)\\big\\|_2}.$$\n\n- Test Case C (edge case with sharper gradients under logistic reaction):\n  - Parameters: $D = 0.02$, $f(u) = k\\,u\\,(1-u)$ with $k = 5$, $N_x = 1024$, $\\Delta t = 10^{-3}$.\n  - Initial condition: $u_0(x) = 0.5 + 0.45\\,\\tanh\\!\\big(10\\,\\sin(6\\pi x)\\big)$.\n  - Output: Report the ratio between the measured commutator coefficient from $d(\\Delta t)$ and the analytic coefficient from $C(u_0)$: $$R_C = \\frac{\\|d(\\Delta t)\\|_2/\\Delta t^2}{\\|C(u_0)\\|_2}.$$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[result1,result2,result3]`). The three entries must be the floats $E_A$, $E_B$, and $R_C$ computed for Test Cases A, B, and C in that order.",
            "solution": "The problem requires an analysis of the first-order Lie operator splitting method for a one-dimensional reaction-diffusion equation. The analysis involves both numerical implementation and theoretical derivation of the leading-order error term that arises from the non-commutativity of the reaction and diffusion operators.\n\nThe governing partial differential equation (PDE) is:\n$$\n\\partial_t u(x,t) = D\\,\\partial_{xx} u(x,t) + f\\big(u(x,t)\\big)\n$$\nThis equation can be formally written as $\\partial_t u = (\\mathcal{D} + \\mathcal{R})u$, where $\\mathcal{D}u = D\\,\\partial_{xx}u$ is the linear diffusion operator and $\\mathcal{R}(u) = f(u)$ is the nonlinear reaction operator.\n\nThe two first-order Lie splitting schemes to be compared are:\n1.  Reaction-then-Diffusion ($S_{RD}$): First, advance the solution under the reaction dynamics, and then advance the result under diffusion dynamics.\n    $$u_1(x) = \\Phi_{\\mathcal{R}}^{\\Delta t}(u_0(x))$$\n    $$u_{RD}(x) = \\Phi_{\\mathcal{D}}^{\\Delta t}(u_1(x)) = (\\Phi_{\\mathcal{D}}^{\\Delta t} \\circ \\Phi_{\\mathcal{R}}^{\\Delta t})(u_0(x))$$\n2.  Diffusion-then-Reaction ($S_{DR}$): First, advance the solution under diffusion, and then advance the result under reaction.\n    $$u_2(x) = \\Phi_{\\mathcal{D}}^{\\Delta t}(u_0(x))$$\n    $$u_{DR}(x) = \\Phi_{\\mathcal{R}}^{\\Delta t}(u_2(x)) = (\\Phi_{\\mathcal{R}}^{\\Delta t} \\circ \\Phi_{\\mathcal{D}}^{\\Delta t})(u_0(x))$$\n\nHere, $\\Phi_{\\mathcal{D}}^{\\Delta t}$ and $\\Phi_{\\mathcal{R}}^{\\Delta t}$ represent the exact flow operators for the diffusion and reaction subproblems, respectively, over a time step $\\Delta t$. The problem defines the difference between these two schemes as:\n$$\nd(\\Delta t) = \\big(\\mathrm{Diffusion}_{\\Delta t} \\circ \\mathrm{Reaction}_{\\Delta t}\\big)u_0 - \\big(\\mathrm{Reaction}_{\\Delta t} \\circ \\mathrm{Diffusion}_{\\Delta t}\\big)u_0\n$$\nFollowing the order of operations for composition, this corresponds to $d(\\Delta t) = u_{RD} - u_{DR}$.\n\n### Task 3: Derivation of the Analytic Commutator Term\nTo determine the leading-order behavior of $d(\\Delta t)$ as $\\Delta t \\to 0$, we perform a Taylor series expansion of each scheme. Let $u_0 = u(x,0)$.\n\nThe reaction step is governed by the ODE $\\frac{du}{dt} = f(u)$. Expanding its solution to second order in $\\Delta t$:\n$$\n\\Phi_{\\mathcal{R}}^{\\Delta t}(u_0) = u_0 + \\Delta t f(u_0) + \\frac{(\\Delta t)^2}{2} \\frac{d}{dt}f(u) \\bigg|_{t=0} + O\\big((\\Delta t)^3\\big)\n$$\nUsing the chain rule, $\\frac{d}{dt}f(u) = f'(u)\\frac{du}{dt} = f'(u)f(u)$. Thus,\n$$\n\\Phi_{\\mathcal{R}}^{\\Delta t}(u_0) = u_0 + \\Delta t f(u_0) + \\frac{(\\Delta t)^2}{2} f'(u_0)f(u_0) + O\\big((\\Delta t)^3\\big)\n$$\n\nThe diffusion step is linear, $\\frac{du}{dt} = \\mathcal{D}u$, with flow operator $\\Phi_{\\mathcal{D}}^{\\Delta t} = \\exp(\\Delta t \\mathcal{D})$. Its series expansion is:\n$$\n\\Phi_{\\mathcal{D}}^{\\Delta t}(v) = \\big(I + \\Delta t \\mathcal{D} + \\frac{(\\Delta t)^2}{2}\\mathcal{D}^2 + \\dots\\big)v\n$$\n\nNow we expand the two schemes:\n\n**1. Reaction-then-Diffusion ($S_{RD}u_0 = u_{RD}$):**\nLet $u_1 = \\Phi_{\\mathcal{R}}^{\\Delta t}(u_0)$. Then $u_{RD} = \\Phi_{\\mathcal{D}}^{\\Delta t}(u_1)$.\n$$\nu_{RD} = \\big(I + \\Delta t \\mathcal{D} + \\frac{(\\Delta t)^2}{2}\\mathcal{D}^2 + \\dots\\big) \\bigg( u_0 + \\Delta t f(u_0) + \\frac{(\\Delta t)^2}{2} f'(u_0)f(u_0) + \\dots \\bigg)\n$$\nExpanding and keeping terms up to order $(\\Delta t)^2$:\n$$\nu_{RD} = u_0 + \\Delta t(\\mathcal{D}u_0 + f(u_0)) + (\\Delta t)^2 \\bigg( \\frac{1}{2}\\mathcal{D}^2 u_0 + \\mathcal{D}f(u_0) + \\frac{1}{2}f'(u_0)f(u_0) \\bigg) + O\\big((\\Delta t)^3\\big)\n$$\n\n**2. Diffusion-then-Reaction ($S_{DR}u_0 = u_{DR}$):**\nLet $u_2 = \\Phi_{\\mathcal{D}}^{\\Delta t}(u_0) = u_0 + \\Delta t \\mathcal{D}u_0 + \\frac{(\\Delta t)^2}{2}\\mathcal{D}^2 u_0 + \\dots$. Then $u_{DR} = \\Phi_{\\mathcal{R}}^{\\Delta t}(u_2)$.\n$$\nu_{DR} = u_2 + \\Delta t f(u_2) + \\frac{(\\Delta t)^2}{2} f'(u_2)f(u_2) + O\\big((\\Delta t)^3\\big)\n$$\nWe must expand $f(u_2)$ and $f'(u_2)f(u_2)$ around $u_0$.\n$f(u_2) \\approx f(u_0) + f'(u_0)(u_2 - u_0) = f(u_0) + f'(u_0)\\big(\\Delta t \\mathcal{D}u_0 + O((\\Delta t)^2)\\big)$.\n$f'(u_2)f(u_2) \\approx f'(u_0)f(u_0) + O(\\Delta t)$.\nSubstituting these into the expansion for $u_{DR}$:\n$$\nu_{DR} \\approx \\bigg( u_0 + \\Delta t \\mathcal{D}u_0 + \\frac{(\\Delta t)^2}{2}\\mathcal{D}^2 u_0 \\bigg) + \\Delta t \\bigg( f(u_0) + \\Delta t f'(u_0)\\mathcal{D}u_0 \\bigg) + \\frac{(\\Delta t)^2}{2} f'(u_0)f(u_0) + O\\big((\\Delta t)^3\\big)\n$$\n$$\nu_{DR} = u_0 + \\Delta t(\\mathcal{D}u_0 + f(u_0)) + (\\Delta t)^2 \\bigg( \\frac{1}{2}\\mathcal{D}^2 u_0 + f'(u_0)\\mathcal{D}u_0 + \\frac{1}{2}f'(u_0)f(u_0) \\bigg) + O\\big((\\Delta t)^3\\big)\n$$\n\n**Difference and Commutator:**\nSubtracting the two expressions, we find that the terms of order $1$ and $\\Delta t$ cancel, as do the terms $\\frac{1}{2}\\mathcal{D}^2 u_0$ and $\\frac{1}{2}f'(u_0)f(u_0)$.\n$$\nd(\\Delta t) = u_{RD} - u_{DR} = (\\Delta t)^2 \\big( \\mathcal{D}f(u_0) - f'(u_0)\\mathcal{D}u_0 \\big) + O\\big((\\Delta t)^3\\big)\n$$\nThe problem asks for the analytic commutator term $C(u_0)$ such that $d(\\Delta t) \\approx (\\Delta t)^2 C(u_0)$. Thus,\n$$\nC(u_0) = \\mathcal{D}f(u_0) - f'(u_0)\\mathcal{D}u_0\n$$\nLet's find the explicit form of $C(u_0)$. With $\\mathcal{D} = D\\partial_{xx}$:\n$$\nC(u_0) = D\\,\\partial_{xx}\\big(f(u_0)\\big) - f'(u_0)\\big(D\\,\\partial_{xx}u_0\\big)\n$$\nUsing the chain rule for the first term: $\\partial_x f(u_0) = f'(u_0)\\partial_x u_0$.\n$$\n\\partial_{xx}f(u_0) = \\partial_x \\big(f'(u_0)\\partial_x u_0\\big) = f''(u_0)(\\partial_x u_0)^2 + f'(u_0)\\partial_{xx} u_0\n$$\nSubstituting this into the expression for $C(u_0)$:\n$$\nC(u_0) = D\\big[ f''(u_0)(\\partial_x u_0)^2 + f'(u_0)\\partial_{xx} u_0 \\big] - D\\,f'(u_0)\\partial_{xx}u_0\n$$\nThe terms involving $\\partial_{xx}u_0$ cancel, yielding the final compact expression for the commutator term:\n$$\nC(u_0) = D\\,f''(u_0)\\,(\\partial_x u_0)^2\n$$\n\n### Tasks 1 & 2: Numerical Implementation\nThe implementation proceeds as follows:\n1.  **Spatial Discretization**: A uniform grid with $N_x$ points on the domain $[0, L]$ is used, with spacing $\\Delta x = L/N_x$. The spatial coordinates are $x_j = j \\Delta x$ for $j=0, \\dots, N_x-1$.\n2.  **Diffusion Substep**: The diffusion equation $\\partial_t u = D\\partial_{xx}u$ is solved in Fourier space. The initial state $u(x,0)$ is transformed using the Fast Fourier Transform (FFT). Each Fourier mode $\\hat{u}(k)$ is then evolved exactly by multiplying with the factor $\\exp(-D k^2 \\Delta t)$, where $k$ are the angular wavenumbers. The result is transformed back to real space using an inverse FFT. The wavenumbers are given by $k = 2\\pi\\,\\mathrm{fftfreq}(N_x, \\Delta x)$.\n3.  **Reaction Substep**: The ODE $\\frac{du}{dt} = f(u)$ is solved pointwise at each grid location. The problem requires using the exact solution.\n    -   For a linear reaction $f(u) = \\alpha u$, the solution is $u(\\Delta t) = u(0)e^{\\alpha \\Delta t}$.\n    -   For a logistic reaction $f(u) = k u(1-u)$, the solution is $u(\\Delta t) = \\frac{u(0)e^{k\\Delta t}}{1 - u(0) + u(0)e^{k\\Delta t}}$.\n4.  **Commutator Calculation**: The analytic term $C(u_0) = D\\,f''(u_0)\\,(\\partial_x u_0)^2$ is computed numerically. The derivative $\\partial_x u_0$ is calculated spectrally via $\\partial_x u_0 = \\mathrm{IFFT}\\big(i k \\cdot \\mathrm{FFT}(u_0)\\big)$ for consistency with the diffusion solver. The second derivative of the reaction term, $f''(u_0)$, is evaluated pointwise.\n5.  **Norm Calculation**: The specified discrete $L^2$ norm $\\|v\\|_2 = \\sqrt{\\Delta x \\sum_{j=0}^{N_x-1} v_j^2}$ is used to compute the required scalar outputs for each test case.\n\n### Test Case Analysis\n-   **Case A (Linear Reaction)**: $f(u) = \\alpha u$. Here, $f'(u) = \\alpha$ and $f''(u) = 0$. Therefore, the analytic commutator term is $C(u_0) = 0$. This implies that the diffusion and reaction operators commute. The two splitting schemes, $S_{RD}$ and $S_{DR}$, should produce identical results up to floating-point precision, making $d(\\Delta t)$ negligibly small. The output $E_A = \\|d(\\Delta t)\\|_2/\\Delta t^2$ is expected to be close to zero.\n-   **Case B (Nonlinear Reaction)**: For the logistic reaction, $f(u) = ku(1-u)$, we have $f''(u) = -2k$. The commutator term is non-zero: $C(u_0) = -2kD(\\partial_x u_0)^2$. The output $E_B$ measures the relative error between the numerically computed difference $d(\\Delta t)$ and its leading-order approximation $(\\Delta t)^2 C(u_0)$. Since $d(\\Delta t) = (\\Delta t)^2 C(u_0) + O((\\Delta t)^3)$, this ratio should be of order $O(\\Delta t)$, and thus small for the given $\\Delta t=10^{-3}$.\n-   **Case C (Sharp Gradients)**: This case uses the same nonlinear reaction but a more complex initial condition with sharper spatial features. This tests the robustness of the leading-order approximation. The output $R_C$ is the ratio of the norms of the \"measured\" commutator coefficient, $\\|d(\\Delta t)\\|_2/\\Delta t^2$, and the analytic one, $\\|C(u_0)\\|_2$. A value close to $1$ indicates that the analytic formula accurately predicts the magnitude of the splitting difference, even for challenging initial data.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Solves the three test cases for the operator splitting error analysis.\n    \"\"\"\n\n    def get_rd_dr_difference(u0, D, reaction_solver, reaction_params, dt, k, Nx, dx):\n        \"\"\"\n        Calculates the difference d(dt) = (RD - DR)u0.\n        \"\"\"\n        # Reaction-then-Diffusion (RD)\n        u_after_reaction = reaction_solver(u0, reaction_params, dt)\n        u_hat_r = fft(u_after_reaction)\n        u_hat_rd = u_hat_r * np.exp(-D * k**2 * dt)\n        u_rd = np.real(ifft(u_hat_rd))\n\n        # Diffusion-then-Reaction (DR)\n        u0_hat = fft(u0)\n        u_hat_d = u0_hat * np.exp(-D * k**2 * dt)\n        u_after_diffusion = np.real(ifft(u_hat_d))\n        u_dr = reaction_solver(u_after_diffusion, reaction_params, dt)\n\n        return u_rd - u_dr\n\n    def linear_reaction_solver(u, params, dt):\n        \"\"\"Exact solver for du/dt = alpha*u.\"\"\"\n        alpha = params['alpha']\n        return u * np.exp(alpha * dt)\n\n    def logistic_reaction_solver(u, params, dt):\n        \"\"\"Exact solver for du/dt = k*u*(1-u).\"\"\"\n        k_param = params['k']\n        exp_kdt = np.exp(k_param * dt)\n        return (u * exp_kdt) / (1.0 - u + u * exp_kdt)\n        \n    def l2_norm(v, dx):\n        \"\"\"Computes the discrete L2 norm.\"\"\"\n        return np.sqrt(dx * np.sum(v**2))\n\n    # General parameters\n    L = 1.0\n    Nx = 1024\n    dt = 1e-3\n    x = np.linspace(0, L, Nx, endpoint=False)\n    dx = L / Nx\n    k = 2 * np.pi * fftfreq(Nx, d=dx)\n\n    results = []\n\n    # --- Test Case A ---\n    D_A = 0.05\n    alpha_A = 0.3\n    u0_A = np.sin(2 * np.pi * x)\n    \n    d_dt_A = get_rd_dr_difference(\n        u0_A, D_A, linear_reaction_solver, {'alpha': alpha_A}, dt, k, Nx, dx\n    )\n    norm_d_dt_A = l2_norm(d_dt_A, dx)\n    E_A = norm_d_dt_A / (dt**2)\n    results.append(E_A)\n\n    # --- Test Case B ---\n    D_B = 0.02\n    k_B = 5.0\n    u0_B = 0.2 + 0.1 * np.sin(2 * np.pi * x)\n\n    d_dt_B = get_rd_dr_difference(\n        u0_B, D_B, logistic_reaction_solver, {'k': k_B}, dt, k, Nx, dx\n    )\n    \n    # Analytic commutator term C(u0) = D * f''(u0) * (du0/dx)^2\n    # For f(u) = k*u*(1-u), f''(u) = -2*k\n    f_dd_u0_B = -2.0 * k_B\n    u0_hat_B = fft(u0_B)\n    du0_dx_hat_B = 1j * k * u0_hat_B\n    du0_dx_B = np.real(ifft(du0_dx_hat_B))\n    C_u0_B = D_B * f_dd_u0_B * (du0_dx_B**2)\n    \n    approx_term_B = dt**2 * C_u0_B\n    numerator_B = l2_norm(d_dt_B - approx_term_B, dx)\n    denominator_B = l2_norm(approx_term_B, dx)\n    \n    E_B = numerator_B / denominator_B if denominator_B != 0 else 0.0\n    results.append(E_B)\n\n    # --- Test Case C ---\n    D_C = 0.02\n    k_C = 5.0\n    u0_C = 0.5 + 0.45 * np.tanh(10 * np.sin(6 * np.pi * x))\n\n    d_dt_C = get_rd_dr_difference(\n        u0_C, D_C, logistic_reaction_solver, {'k': k_C}, dt, k, Nx, dx\n    )\n\n    # Analytic commutator term C(u0) = D * f''(u0) * (du0/dx)^2\n    f_dd_u0_C = -2.0 * k_C\n    u0_hat_C = fft(u0_C)\n    du0_dx_hat_C = 1j * k * u0_hat_C\n    du0_dx_C = np.real(ifft(du0_dx_hat_C))\n    C_u0_C = D_C * f_dd_u0_C * (du0_dx_C**2)\n\n    measured_coeff_norm_C = l2_norm(d_dt_C, dx) / (dt**2)\n    analytic_coeff_norm_C = l2_norm(C_u0_C, dx)\n\n    R_C = measured_coeff_norm_C / analytic_coeff_norm_C if analytic_coeff_norm_C != 0 else 0.0\n    results.append(R_C)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}