{
    "hands_on_practices": [
        {
            "introduction": "在分析像宿主内病毒动力学这样的复杂系统时，第一步通常是简化模型以揭示其核心行为。本练习将引导您完成无量纲化的过程，这是一种强大的数学技术，可以将多个模型参数合并为少数几个控制系统动态的关键无量纲组合。通过这项实践，您将学会如何识别决定感染过程基本时间尺度和幅度的参数群，从而更深入地理解模型的内在结构。",
            "id": "3944294",
            "problem": "考虑经典的靶细胞限制的宿主内病毒动力学模型，其中易感靶细胞 $T(t)$、感染细胞 $I(t)$ 和游离病毒粒子 $V(t)$ 的密度根据质量作用相互作用和线性出生/死亡过程演变。其控制常微分方程组 (ODEs) 为\n$$\n\\frac{dT}{dt} = s - d T - \\beta T V,\\quad\n\\frac{dI}{dt} = \\beta T V - \\delta I,\\quad\n\\frac{dV}{dt} = p I - c V,\n$$\n其中 $s$ 是靶细胞的生成率， $d$ 是靶细胞的自然清除率， $\\beta$ 是感染率常数， $\\delta$ 是感染细胞的死亡率， $p$ 是每个感染细胞的病毒粒子产生率， $c$ 是病毒粒子的清除率。所有参数均为正常数，所有变量均为时间 $t$ 的非负函数。\n\n从这些方程以及变量和参数的定义出发，通过引入特征时间尺度 $t^{\\ast}$ 和特征种群尺度 $T^{\\ast}$、$I^{\\ast}$ 和 $V^{\\ast}$ 对系统进行无量纲化。令无量纲时间为 $\\tau = t/t^{\\ast}$，无量纲状态变量为 $\\tilde{T} = T/T^{\\ast}$、$\\tilde{I} = I/I^{\\ast}$ 和 $\\tilde{V} = V/V^{\\ast}$。选择时间尺度 $t^{\\ast} = 1/c$ 以反映病毒粒子的清除时间，并选择病毒粒子尺度 $V^{\\ast} = p I^{\\ast}/c$ 以便在代数上简化游离病毒粒子方程。为了具体化并将重标度锚定到生理基线，取 $T^{\\ast} = s/d$ 和 $I^{\\ast} = s/d$。\n\n显式地导出所得的无量纲 ODEs，并将所有系数用无量纲参数组合表示。特别地，在这种 $t^{\\ast}$ 和 $V^{\\ast}$ 的选择下，确定分别用于缩放感染细胞方程中感染项和感染细胞死亡项的无量纲参数 $\\tilde{\\beta}$ 和 $\\tilde{\\delta}$。你的最终答案应包含 $\\tilde{\\beta}$ 和 $\\tilde{\\delta}$ 以原始有量纲参数表示的闭式解析表达式，无需进行数值计算。最终答案中不应包含任何单位。",
            "solution": "该问题陈述是关于常微分方程组 (ODEs) 无量纲化的一个适定且标准的练习，这是应用数学和系统生物学中的一项基本技术。所呈现的模型是经典的宿主内病毒动力学靶细胞限制模型，该模型具有科学依据。所有参数、变量和标度选择都已明确定义，系统是自洽且无矛盾的。任务是执行特定的代数变换并确定由此产生的无量纲参数。因此，该问题是有效的，可以推导出解答。\n\n问题将有量纲状态变量定义为易感靶细胞 $T(t)$、感染细胞 $I(t)$ 和游离病毒粒子 $V(t)$。其动力学由以下 ODEs 系统控制：\n$$\n\\frac{dT}{dt} = s - d T - \\beta T V\n$$\n$$\n\\frac{dI}{dt} = \\beta T V - \\delta I\n$$\n$$\n\\frac{dV}{dt} = p I - c V\n$$\n所有参数 $s$、$d$、$\\beta$、$\\delta$、$p$ 和 $c$ 均为正常数。\n\n我们引入无量纲变量 $\\tilde{T}$、$\\tilde{I}$、$\\tilde{V}$ 和无量纲时间 $\\tau$ 如下：\n$$\nT(t) = T^{\\ast} \\tilde{T}(\\tau), \\quad I(t) = I^{\\ast} \\tilde{I}(\\tau), \\quad V(t) = V^{\\ast} \\tilde{V}(\\tau), \\quad t = t^{\\ast} \\tau\n$$\n问题指定了特征尺度：\n$$\nt^{\\ast} = \\frac{1}{c}, \\quad T^{\\ast} = \\frac{s}{d}, \\quad I^{\\ast} = \\frac{s}{d}\n$$\n病毒粒子尺度 $V^{\\ast}$ 定义为 $V^{\\ast} = \\frac{p I^{\\ast}}{c}$。代入给定的 $I^{\\ast}$，我们得到：\n$$\nV^{\\ast} = \\frac{p (s/d)}{c} = \\frac{ps}{cd}\n$$\n接下来，我们使用链式法则变换时间导数：\n$$\n\\frac{d}{dt} = \\frac{d\\tau}{dt} \\frac{d}{d\\tau} = \\frac{1}{t^{\\ast}} \\frac{d}{d\\tau} = c \\frac{d}{d\\tau}\n$$\n将此应用于每个状态变量：\n$$\n\\frac{dT}{dt} = \\frac{d(T^{\\ast} \\tilde{T})}{dt} = T^{\\ast} \\frac{d\\tilde{T}}{dt} = T^{\\ast} c \\frac{d\\tilde{T}}{d\\tau}\n$$\n$$\n\\frac{dI}{dt} = \\frac{d(I^{\\ast} \\tilde{I})}{dt} = I^{\\ast} \\frac{d\\tilde{I}}{dt} = I^{\\ast} c \\frac{d\\tilde{I}}{d\\tau}\n$$\n$$\n\\frac{dV}{dt} = \\frac{d(V^{\\ast} \\tilde{V})}{dt} = V^{\\ast} \\frac{d\\tilde{V}}{dt} = V^{\\ast} c \\frac{d\\tilde{V}}{d\\tau}\n$$\n现在，我们将这些表达式和无量纲变量代入原始的 ODEs。\n\n对于靶细胞方程：\n$$\nT^{\\ast} c \\frac{d\\tilde{T}}{d\\tau} = s - d (T^{\\ast} \\tilde{T}) - \\beta (T^{\\ast} \\tilde{T}) (V^{\\ast} \\tilde{V})\n$$\n除以 $T^{\\ast} c$：\n$$\n\\frac{d\\tilde{T}}{d\\tau} = \\frac{s}{T^{\\ast} c} - \\frac{d T^{\\ast}}{T^{\\ast} c} \\tilde{T} - \\frac{\\beta T^{\\ast} V^{\\ast}}{T^{\\ast} c} \\tilde{T} \\tilde{V} = \\frac{s}{T^{\\ast} c} - \\frac{d}{c} \\tilde{T} - \\frac{\\beta V^{\\ast}}{c} \\tilde{T} \\tilde{V}\n$$\n代入 $T^{\\ast}$ 和 $V^{\\ast}$ 的表达式：\n$$\n\\frac{d\\tilde{T}}{d\\tau} = \\frac{s}{(\\frac{s}{d}) c} - \\frac{d}{c} \\tilde{T} - \\frac{\\beta (\\frac{ps}{cd})}{c} \\tilde{T} \\tilde{V}\n$$\n$$\n\\frac{d\\tilde{T}}{d\\tau} = \\frac{d}{c} - \\frac{d}{c} \\tilde{T} - \\frac{\\beta p s}{c^2 d} \\tilde{T} \\tilde{V} = \\frac{d}{c}(1 - \\tilde{T}) - \\frac{\\beta p s}{c^2 d} \\tilde{T} \\tilde{V}\n$$\n\n对于感染细胞方程：\n$$\nI^{\\ast} c \\frac{d\\tilde{I}}{d\\tau} = \\beta (T^{\\ast} \\tilde{T}) (V^{\\ast} \\tilde{V}) - \\delta (I^{\\ast} \\tilde{I})\n$$\n除以 $I^{\\ast} c$：\n$$\n\\frac{d\\tilde{I}}{d\\tau} = \\frac{\\beta T^{\\ast} V^{\\ast}}{I^{\\ast} c} \\tilde{T} \\tilde{V} - \\frac{\\delta I^{\\ast}}{I^{\\ast} c} \\tilde{I} = \\frac{\\beta T^{\\ast} V^{\\ast}}{I^{\\ast} c} \\tilde{T} \\tilde{V} - \\frac{\\delta}{c} \\tilde{I}\n$$\n由于 $T^{\\ast} = I^{\\ast} = \\frac{s}{d}$，比值 $\\frac{T^{\\ast}}{I^{\\ast}} = 1$。该方程简化为：\n$$\n\\frac{d\\tilde{I}}{d\\tau} = \\frac{\\beta V^{\\ast}}{c} \\tilde{T} \\tilde{V} - \\frac{\\delta}{c} \\tilde{I}\n$$\n代入 $V^{\\ast}$ 的表达式：\n$$\n\\frac{d\\tilde{I}}{d\\tau} = \\frac{\\beta (\\frac{ps}{cd})}{c} \\tilde{T} \\tilde{V} - \\frac{\\delta}{c} \\tilde{I} = \\frac{\\beta p s}{c^2 d} \\tilde{T} \\tilde{V} - \\frac{\\delta}{c} \\tilde{I}\n$$\n\n对于游离病毒粒子方程：\n$$\nV^{\\ast} c \\frac{d\\tilde{V}}{d\\tau} = p (I^{\\ast} \\tilde{I}) - c (V^{\\ast} \\tilde{V})\n$$\n除以 $V^{\\ast} c$：\n$$\n\\frac{d\\tilde{V}}{d\\tau} = \\frac{p I^{\\ast}}{V^{\\ast} c} \\tilde{I} - \\frac{c V^{\\ast}}{V^{\\ast} c} \\tilde{V} = \\frac{p I^{\\ast}}{V^{\\ast} c} \\tilde{I} - \\tilde{V}\n$$\n根据问题中提供的定义，$V^{\\ast} = \\frac{p I^{\\ast}}{c}$，这意味着 $\\frac{p I^{\\ast}}{V^{\\ast}} = c$。将此代入系数中：\n$$\n\\frac{d\\tilde{V}}{d\\tau} = \\frac{c}{c} \\tilde{I} - \\tilde{V} = \\tilde{I} - \\tilde{V}\n$$\n这证实了选择此标度的目的确实是为了简化该方程。\n\n得到的无量纲系统是：\n$$\n\\frac{d\\tilde{T}}{d\\tau} = \\frac{d}{c}(1 - \\tilde{T}) - \\frac{\\beta p s}{c^2 d} \\tilde{T} \\tilde{V}\n$$\n$$\n\\frac{d\\tilde{I}}{d\\tau} = \\frac{\\beta p s}{c^2 d} \\tilde{T} \\tilde{V} - \\frac{\\delta}{c} \\tilde{I}\n$$\n$$\n\\frac{d\\tilde{V}}{d\\tau} = \\tilde{I} - \\tilde{V}\n$$\n问题要求分别确定在感染细胞方程中用于缩放感染项 ($\\tilde{T}\\tilde{V}$) 和死亡项 ($\\tilde{I}$) 的无量纲参数 $\\tilde{\\beta}$ 和 $\\tilde{\\delta}$。无量纲感染细胞方程的结构是：\n$$\n\\frac{d\\tilde{I}}{d\\tau} = \\tilde{\\beta} \\tilde{T} \\tilde{V} - \\tilde{\\delta} \\tilde{I}\n$$\n通过将此形式与我们导出的方程进行比较，我们可以确定 $\\tilde{\\beta}$ 和 $\\tilde{\\delta}$ 的表达式：\n感染项是 $(\\frac{\\beta p s}{c^2 d}) \\tilde{T} \\tilde{V}$，所以：\n$$\n\\tilde{\\beta} = \\frac{\\beta p s}{c^2 d}\n$$\n死亡项是 $-(\\frac{\\delta}{c}) \\tilde{I}$，所以：\n$$\n\\tilde{\\delta} = \\frac{\\delta}{c}\n$$\n这些就是所要求的无量纲参数的闭式解析表达式。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\beta p s}{c^{2} d}  \\frac{\\delta}{c} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "一个数学模型的实用性最终取决于其与真实世界数据的契合程度。本练习将带您从理论走向实践，探讨如何从模拟的病毒载量数据中估计模型参数。您将通过一个具体的计算任务，亲身体验参数估计的过程，并直面系统生物学中的一个核心挑战：参数不可辨识性（parameter non-identifiability），即不同的参数组合可能产生无法区分的模型预测结果。",
            "id": "3944264",
            "problem": "考虑一个基于质量作用定律的经典宿主内靶细胞限制病毒动力学模型，其中未感染的靶细胞 $T(t)$、已感染细胞 $I(t)$ 和游离病毒颗粒 $V(t)$ 的演变遵循以下常微分方程 (ODE, Ordinary Differential Equation)\n$$\n\\frac{dT}{dt} = -\\beta\\,T\\,V,\\quad\n\\frac{dI}{dt} = \\beta\\,T\\,V - \\delta\\,I,\\quad\n\\frac{dV}{dt} = p\\,I - c\\,V.\n$$\n此处，$\\beta$ 的单位是 $\\mathrm{mL}\\cdot\\mathrm{copies}^{-1}\\cdot\\mathrm{day}^{-1}$，$\\delta$ 是已感染细胞失活率，单位是 $\\mathrm{day}^{-1}$，$p$ 是单位细胞病毒产生率，单位是 $\\mathrm{copies}\\cdot\\mathrm{cell}^{-1}\\cdot\\mathrm{day}^{-1}$，$c$ 是病毒清除率，单位是 $\\mathrm{day}^{-1}$。当 $c$ 相对于其他速率较大时，在对游离病毒采用准稳态 (QSS, Quasi-Steady-State) 假设下，$V(t)\\approx \\frac{p}{c}I(t)$，简化的双方程模型变为\n$$\n\\frac{dT}{dt} = -\\alpha\\,T\\,I,\\quad\n\\frac{dI}{dt} = \\alpha\\,T\\,I - \\delta\\,I,\\quad\nV(t) = \\frac{p}{c}I(t),\n$$\n其中，可识别组合为 $\\alpha = \\frac{\\beta p}{c}$，单位是 $\\mathrm{mL}\\cdot\\mathrm{cell}^{-1}\\cdot\\mathrm{day}^{-1}$。在 $T(t)\\approx T(0)$ 的早期阶段，$I(t)$（以及 $V(t)$）的指数增长率由 $r \\approx \\alpha\\,T(0) - \\delta$ 控制，这表明 $\\alpha$ 和 $T(0)$ 通过其乘积而混淆。\n\n您的任务是量化仅从病毒载量数据 $V(t)$ 推断 $\\alpha=\\beta p / c$ 时，固定初始靶细胞计数 $T(0)$ 与估计该值对推断结果的影响，并实现一个算法，通过将简化模型与合成数据进行最小二乘拟合来估计 $\\alpha$。将 $\\delta$ 视为已知常数，并将 $I(0)$ 视为已知。所有量的物理单位必须被遵守。时间 $t$ 的单位是天，$T$ 和 $I$ 的单位是 $\\mathrm{cells}\\cdot\\mathrm{mL}^{-1}$，$V$ 的单位是 $\\mathrm{copies}\\cdot\\mathrm{mL}^{-1}$。所有推断出的 $\\alpha$ 值都以 $\\mathrm{mL}\\cdot\\mathrm{cell}^{-1}\\cdot\\mathrm{day}^{-1}$ 表示。\n\n合成数据生成方案：\n- 使用具有真实参数值的简化模型\n  - $\\alpha_{\\mathrm{true}} = 1.5\\times 10^{-8}\\ \\mathrm{mL}\\cdot\\mathrm{cell}^{-1}\\cdot\\mathrm{day}^{-1}$,\n  - $\\delta = 1\\ \\mathrm{day}^{-1}$,\n  - $T(0)_{\\mathrm{true}} = 1.0\\times 10^{8}\\ \\mathrm{cells}\\cdot\\mathrm{mL}^{-1}$,\n  - $I(0) = 1.0\\times 10^{1}\\ \\mathrm{cells}\\cdot\\mathrm{mL}^{-1}$,\n  - $p = 5.0\\times 10^{3}\\ \\mathrm{copies}\\cdot\\mathrm{cell}^{-1}\\cdot\\mathrm{day}^{-1}$,\n  - $c = 1.0\\times 10^{1}\\ \\mathrm{day}^{-1}$.\n- 使用精确的简化模型关系 $V(t)=\\frac{p}{c}I(t)$，在等间隔的时间点上生成 $V(t)$，不添加噪声。\n\n估计方案：\n- 对于给定的数据集 $V(t_k)$ 和已知的 $(\\delta, I(0), p, c)$，通过最小化模型预测的 $V(t_k)$ 与数据之间的残差平方和来估计参数，这需要使用简化系统的常微分方程数值积分。在 $T(0)$ 被固定的情况下，仅估计 $\\alpha$。在 $T(0)$ 也需要估计的情况下，联合估计 $(\\alpha, T(0))$ 并施加正值约束。\n\n测试套件：\n- 使用以下四个测试用例，所有用例均使用上述真实参数生成，并使用指定的均匀间隔观测时间。\n  1. 用例 A (理想情况)：$t_k = 0,1,2,\\dots,10$ 天。将 $T(0)$ 固定为 $T(0)_{\\mathrm{true}}$ 并估计 $\\alpha$。\n  2. 用例 B (初始靶细胞指定错误)：$t_k = 0,1,2,\\dots,10$ 天。将 $T(0)$ 固定为 $2.0\\times 10^{7}\\ \\mathrm{cells}\\cdot\\mathrm{mL}^{-1}$ 并估计 $\\alpha$。\n  3. 用例 C (估计 $T(0)$)：$t_k = 0,1,2,\\dots,10$ 天。联合估计 $(\\alpha, T(0))$，其边界为 $1.0\\times 10^{-10}\\le\\alpha\\le 1.0\\times 10^{-6}$ 和 $1.0\\times 10^{7}\\le T(0)\\le 5.0\\times 10^{8}$。\n  4. 用例 D (仅早期阶段，可识别性的边界条件)：$t_k = 0,0.5,1.0,1.5,2.0$ 天。联合估计 $(\\alpha, T(0))$，边界与用例 C 相同。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目对应于相应测试用例推断出的 $\\alpha$ 值，顺序为 [用例 A, 用例 B, 用例 C, 用例 D]，以浮点数形式表示，单位为 $\\mathrm{mL}\\cdot\\mathrm{cell}^{-1}\\cdot\\mathrm{day}^{-1}$。例如，一个有效的输出行如下所示\n$$\n[\\alpha_A,\\alpha_B,\\alpha_C,\\alpha_D].\n$$\n不允许有其他任何输出。",
            "solution": "用户提供了一个问题陈述，在尝试解决方案之前需要对其进行验证。\n\n### 步骤 1：提取已知条件\n- **模型方程（简化版）：**\n  - $\\frac{dT}{dt} = -\\alpha\\,T\\,I$\n  - $\\frac{dI}{dt} = \\alpha\\,T\\,I - \\delta\\,I$\n  - $V(t) = \\frac{p}{c}I(t)$\n- **参数定义和单位：**\n  - $t$：时间，单位 $\\mathrm{days}$\n  - $T(t)$：未感染的靶细胞，单位 $\\mathrm{cells}\\cdot\\mathrm{mL}^{-1}$\n  - $I(t)$：已感染细胞，单位 $\\mathrm{cells}\\cdot\\mathrm{mL}^{-1}$\n  - $V(t)$：游离病毒颗粒，单位 $\\mathrm{copies}\\cdot\\mathrm{mL}^{-1}$\n  - $\\alpha$：可识别的速率常数，单位 $\\mathrm{mL}\\cdot\\mathrm{cell}^{-1}\\cdot\\mathrm{day}^{-1}$\n  - $\\delta$：已感染细胞失活率，单位 $\\mathrm{day}^{-1}$\n  - $p$：病毒产生率，单位 $\\mathrm{copies}\\cdot\\mathrm{cell}^{-1}\\cdot\\mathrm{day}^{-1}$\n  - $c$：病毒清除率，单位 $\\mathrm{day}^{-1}$\n- **用于生成合成数据的真实参数：**\n  - $\\alpha_{\\mathrm{true}} = 1.5\\times 10^{-8}\\ \\mathrm{mL}\\cdot\\mathrm{cell}^{-1}\\cdot\\mathrm{day}^{-1}$\n  - $\\delta = 1\\ \\mathrm{day}^{-1}$\n  - $T(0)_{\\mathrm{true}} = 1.0\\times 10^{8}\\ \\mathrm{cells}\\cdot\\mathrm{mL}^{-1}$\n  - $I(0) = 1.0\\times 10^{1}\\ \\mathrm{cells}\\cdot\\mathrm{mL}^{-1}$\n  - $p = 5.0\\times 10^{3}\\ \\mathrm{copies}\\cdot\\mathrm{cell}^{-1}\\cdot\\mathrm{day}^{-1}$\n  - $c = 1.0\\times 10^{1}\\ \\mathrm{day}^{-1}$\n- **估计方案：**\n  - 方法：对 $V(t)$ 数据进行最小二乘拟合（最小化残差平方和）。\n  - 估计过程中的已知量：$\\delta$、$I(0)$、$p$、$c$。\n- **测试用例：**\n  1.  **用例 A：** 数据时间点 $t_k = 0,1,2,\\dots,10$ 天。固定 $T(0) = T(0)_{\\mathrm{true}} = 1.0\\times 10^{8}$。估计 $\\alpha$。\n  2.  **用例 B：** 数据时间点 $t_k = 0,1,2,\\dots,10$ 天。固定 $T(0) = 2.0\\times 10^{7}$。估计 $\\alpha$。\n  3.  **用例 C：** 数据时间点 $t_k = 0,1,2,\\dots,10$ 天。在边界 $1.0\\times 10^{-10}\\le\\alpha\\le 1.0\\times 10^{-6}$ 和 $1.0\\times 10^{7}\\le T(0)\\le 5.0\\times 10^{8}$ 内联合估计 $(\\alpha, T(0))$。\n  4.  **用例 D：** 数据时间点 $t_k = 0,0.5,1.0,1.5,2.0$ 天。使用与用例 C 相同的边界联合估计 $(\\alpha, T(0))$。\n- **要求输出：** 四个用例推断出的 $\\alpha$ 值的逗号分隔列表：$[\\alpha_A,\\alpha_B,\\alpha_C,\\alpha_D]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题使用了病毒动力学中标准的靶细胞限制模型，这是数学生物学和病毒学中一个完善的基础模型。准稳态 (QSS) 假设是该领域中一个标准且有效的简化技术。所有参数、变量和单位都科学真实且定义正确。\n2.  **良态问题：** 该任务是一个常微分方程 (ODE) 系统的参数估计问题。这是一个定义明确的计算问题。问题提供了所有必要信息：模型、用于数据生成的真实参数、观测时间、估计过程中的已知/未知量以及目标函数（最小二乘法）。\n3.  **客观性：** 问题以精确、客观的数学和计算术语陈述。没有主观或基于观点的陈述。\n4.  **完整性：** 问题是自洽的。它为每个测试用例的数据生成和估计程序提供了完整的规范，包括参数边界和初始条件。\n5.  **一致性：** 整个问题陈述中的单位是一致的。数学推导（例如，早期增长率 $r$ 的表达式）是正确的。所提供的信息中没有矛盾之处。\n\n### 步骤 3：结论与行动\n该问题是有效的。它是一个在生物医学系统建模领域内具有科学依据、良态且客观的计算任务。将提供解决方案。\n\n### 基于原则的设计\n问题的核心是估计一个由常微分方程 (ODE) 组描述的动力学系统的参数。解决方案的设计围绕着最小化一个目标函数的原则，该函数量化了模型预测与观测数据之间的差异。\n\n**1. 模型仿真：**\n必须预测模型在给定一组参数下的行为。该模型是简化的双方程系统：\n$$\n\\frac{dT}{dt} = -\\alpha\\,T\\,I\n$$\n$$\n\\frac{dI}{dt} = \\alpha\\,T\\,I - \\delta\\,I\n$$\n给定速率常数 $\\alpha$ 的值、已知的已感染细胞失活率 $\\delta=1$ 以及靶细胞 $T(0)$ 和已感染细胞 $I(0)=10$ 的初始条件，可以对该 ODE 系统进行数值积分，以找到轨迹 $T(t)$ 和 $I(t)$。为此，我们采用一个标准的、高质量的数值 ODE 求解器，即 `scipy.integrate.solve_ivp`。根据 $I(t)$ 的解，使用 QSS 关系 $V(t) = \\frac{p}{c}I(t)$ 计算可观测的病毒载量 $V(t)$，其中 $\\frac{p}{c} = \\frac{5000}{10} = 500$。\n\n**2. 目标函数：**\n参数估计被构建为一个优化问题。目标是找到使模型输出与数据最佳匹配的参数值。遵循问题中“最小二乘拟合”的指令，我们定义一个目标函数（或成本函数）$J$，作为在观测时间点 $t_k$ 上，模型预测的病毒载量 $V_{\\mathrm{model}}(t_k)$ 与合成数据 $V_{\\mathrm{data}}(t_k)$ 之间的残差平方和 (SSR)：\n$$\nJ(\\boldsymbol{\\theta}) = \\sum_{k} \\left( V_{\\mathrm{model}}(t_k; \\boldsymbol{\\theta}) - V_{\\mathrm{data}}(t_k) \\right)^2\n$$\n此处，$\\boldsymbol{\\theta}$ 代表待估计的参数向量（例如，$\\boldsymbol{\\theta} = [\\alpha]$ 或 $\\boldsymbol{\\theta} = [\\alpha, T(0)]$)。\n\n**3. 优化：**\n目标函数 $J(\\boldsymbol{\\theta})$ 必须相对于 $\\boldsymbol{\\theta}$ 进行最小化。我们使用 `scipy.optimize.minimize` 提供的数值优化算法。鉴于参数存在正值和范围约束（$\\alpha  0$，以及用例 C 和 D 的指定边界），一个合适的方法是 L-BFGS-B 算法，它可以高效地处理这类箱形约束。优化器会迭代地调整参数值，在每一步调用目标函数，直到找到一个局部最小值。\n\n**4. 测试用例的实现：**\n整个算法的结构是通过相应地配置估计过程来处理每个测试用例。\n\n- **数据生成：** 首先，通过使用给定的 $\\alpha_{\\mathrm{true}}$ 和 $T(0)_{\\mathrm{true}}$ 求解 ODE，生成一个单一的、高保真的“真实”轨迹。然后，该解被用来为每个测试用例所需的特定时间点生成合成数据 $V_{\\mathrm{data}}(t_k)$。\n\n- **用例 A (估计 $\\alpha$，正确的 $T(0)$):** 参数向量为 $\\boldsymbol{\\theta} = [\\alpha]$。$T(0)$ 被固定为其真实值 $1.0\\times 10^{8}$。优化器搜索使 $J([\\alpha])$ 最小化的 $\\alpha$ 值。由于模型和数据完美匹配，且 $T(0)$ 是正确的，预计估计出的 $\\alpha$ 将非常接近 $\\alpha_{\\mathrm{true}}$。\n\n- **用例 B (估计 $\\alpha$，不正确的 $T(0)$):** 设置与用例 A 相同，但 $T(0)$ 被固定为一个不正确的值 $2.0\\times 10^{7}$。优化器将找到能够最佳补偿此错误指定的 $\\alpha$。由于早期增长率近似为 $r \\approx \\alpha T(0) - \\delta$，我们预计优化器会找到一个 $\\alpha$，使得乘积 $\\alpha T(0)$ 接近真实的乘积 $\\alpha_{\\mathrm{true}} T(0)_{\\mathrm{true}} \\approx 1.5$。这意味着 $\\alpha \\approx \\frac{1.5}{2.0\\times 10^7} = 7.5 \\times 10^{-8}$。\n\n- **用例 C (联合估计 $\\alpha, T(0)$):** 参数向量为 $\\boldsymbol{\\theta} = [\\alpha, T(0)]$，并带有指定的边界。数据跨越 10 天，其中包括显著的靶细胞耗尽。这种耗尽打破了 $\\alpha$ 和 $T(0)$ 之间简单的乘法关系，为区分它们提供了必要的信息。预计优化器将恢复出与真实值非常接近的 $\\alpha$ 和 $T(0)$。\n\n- **用例 D (联合估计 $\\alpha, T(0)$，早期数据):** 设置与用例 C 相同，但数据仅限于前 2 天。在此早期阶段，靶细胞水平 $T(t)$ 仍然非常接近 $T(0)$。因此，动力学几乎完全由乘积 $\\alpha T(0)$ 控制，如早期增长率近似所描述。参数 $\\alpha$ 和 $T(0)$ 实际上是不可识别的。目标函数曲面将在 $\\alpha T(0) \\approx 1.5$ 的等值线上呈现一个长而平坦的谷底。优化器会在此谷底内找到一个解，但其具体坐标 $(\\alpha, T(0))$ 将对初始猜测和优化器路径敏感，而不是由数据唯一确定。此用例旨在展示这个根本性的可识别性问题。\n\n最终的 Python 实现封装了这些原则，系统地处理每个用例以得出所需的 $\\alpha$ 估计值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the parameter estimation problem for the reduced viral dynamics model.\n    It generates synthetic data and then runs four estimation test cases as specified.\n    \"\"\"\n\n    # --- Constants and True Parameters for Data Generation ---\n    DELTA = 1.0  # Infected cell loss rate [day^-1]\n    I0 = 10.0    # Initial infected cells [cells/mL]\n    P = 5000.0   # Viral production rate [copies/cell/day]\n    C = 10.0     # Viral clearance rate [day^-1]\n    P_OVER_C = P / C  # Ratio for V(t) calculation [copies/cell]\n\n    ALPHA_TRUE = 1.5e-8  # True alpha value [mL/cell/day]\n    T0_TRUE = 1.0e8      # True initial target cells [cells/mL]\n\n    # --- Reduced Model ODE System ---\n    def reduced_model_ode(t, y, alpha, delta):\n        \"\"\"\n        Defines the ODE system for the reduced target-cell limited model.\n        y = [T, I]\n        \"\"\"\n        T, I = y\n        dT_dt = -alpha * T * I\n        dI_dt = alpha * T * I - delta * I\n        return [dT_dt, dI_dt]\n\n    # --- Generate Synthetic Data ---\n    # Generate a single high-resolution solution to be used for all cases.\n    t_span_gen = [0, 10]\n    y0_gen = [T0_TRUE, I0]\n    sol_true = solve_ivp(\n        reduced_model_ode,\n        t_span_gen,\n        y0_gen,\n        args=(ALPHA_TRUE, DELTA),\n        dense_output=True,\n        method='RK45',\n        rtol=1e-6,\n        atol=1e-9\n    )\n\n    def get_viral_load_data(times):\n        \"\"\"\n        Calculates the noise-free viral load data at specified times from the true solution.\n        \"\"\"\n        _, I_true = sol_true.sol(times)\n        V_data = P_OVER_C * I_true\n        return V_data\n\n    # --- Test Case Definitions ---\n    test_cases = [\n        # Case A: Happy path, fix T(0) to true value\n        {\n            \"times\": np.linspace(0, 10, 11),\n            \"estimate_T0\": False,\n            \"T0_fixed\": T0_TRUE,\n            \"bounds\": [(1e-10, 1e-6)],\n            \"x0\": [1e-8]\n        },\n        # Case B: Misspecified T(0)\n        {\n            \"times\": np.linspace(0, 10, 11),\n            \"estimate_T0\": False,\n            \"T0_fixed\": 2.0e7,\n            \"bounds\": [(1e-10, 1e-6)],\n            \"x0\": [5e-8]\n        },\n        # Case C: Jointly estimate alpha and T(0) with full data\n        {\n            \"times\": np.linspace(0, 10, 11),\n            \"estimate_T0\": True,\n            \"T0_fixed\": None,\n            \"bounds\": [(1e-10, 1e-6), (1e7, 5e8)],\n            \"x0\": [2e-8, 5e7]\n        },\n        # Case D: Jointly estimate alpha and T(0) with early data\n        {\n            \"times\": np.linspace(0, 2, 5),\n            \"estimate_T0\": True,\n            \"T0_fixed\": None,\n            \"bounds\": [(1e-10, 1e-6), (1e7, 5e8)],\n            \"x0\": [2e-8, 5e7]\n        }\n    ]\n\n    results_alpha = []\n\n    # --- Run Estimation for Each Case ---\n    for case in test_cases:\n        t_data = case[\"times\"]\n        v_data = get_viral_load_data(t_data)\n\n        def objective_function(params):\n            if case[\"estimate_T0\"]:\n                alpha, T0 = params\n            else:\n                alpha = params[0]\n                T0 = case[\"T0_fixed\"]\n\n            y0_model = [T0, I0]\n\n            sol_model = solve_ivp(\n                reduced_model_ode,\n                [t_data[0], t_data[-1]],\n                y0_model,\n                args=(alpha, DELTA),\n                t_eval=t_data,\n                method='RK45',\n                rtol=1e-6,\n                atol=1e-9\n            )\n            \n            # If the ODE solver fails, return a large penalty\n            if sol_model.status != 0 or sol_model.y.shape[1] != len(t_data):\n                return np.inf\n\n            I_model = sol_model.y[1]\n            V_model = P_OVER_C * I_model\n            \n            residuals = V_model - v_data\n            return np.sum(residuals**2)\n\n        opt_result = minimize(\n            objective_function,\n            x0=case[\"x0\"],\n            bounds=case[\"bounds\"],\n            method='L-BFGS-B'\n        )\n\n        estimated_alpha = opt_result.x[0]\n        results_alpha.append(estimated_alpha)\n\n    # Format and print the final results as specified\n    print(f\"[{','.join(map(str, results_alpha))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们通常使用的常微分方程（ODE）模型描述的是大群体中的平均行为，但在细胞或病毒数量较少时，随机事件的主导作用不可忽视。本练习将引导您探索病毒动力学的随机性，您将实现Gillespie随机模拟算法（SSA），这是一种精确模拟单个生化反应事件的方法。通过这项实践，您将理解随机性在感染动态中的作用，并观察确定性的平均场行为如何从大量随机轨迹的系综平均中浮现。",
            "id": "3944239",
            "problem": "考虑一个充分混合的宿主内区室，其被建模为一个包含三种组分的连续时间马尔可夫跳跃过程：靶细胞 $T$、感染细胞 $I$ 和游离病毒 $V$。该反应系统由四个事件组成：感染 $T \\to I$、感染细胞死亡 $I \\to \\emptyset$、病毒产生 $I \\to I+V$ 和病毒清除 $V \\to \\emptyset$。假设在一个尺寸参数为 $\\Omega$ 的区室中遵循质量作用动力学，其中感染倾向采用密度依赖标度。\n\n您的任务是为此反应网络实现精确的随机模拟算法（SSA），通常称为 Gillespie 算法，模拟多次独立的实现，并通过将随机模型的系综平均值与相应确定性常微分方程（ODE）的物种密度解进行比较，来验证平均场行为的恢复。时间必须以天为单位表示，所有输出应为无单位的密度或无单位的密度差。\n\n基本和建模假设：\n- 充分混合区室中的质量作用动力学意味着反应风险是当前状态的函数。事件一次发生一个，其等待时间由总风险决定，服从指数分布。\n- 对于双分子感染反应，使用与尺寸参数为 $\\Omega$ 的区室一致的密度依赖标度。\n- 密度定义为 $t = T/\\Omega$、$i = I/\\Omega$ 和 $v = V/\\Omega$，平均场确定性模型是为这些密度定义的。\n\n对于 SSA，在时间 $t$ 时状态为 $(T,I,V)$ 的情况下，使用以下风险：\n- 感染：风险 $a_1(T,I,V) = (\\beta/\\Omega)\\, T\\, V$。\n- 感染细胞死亡：风险 $a_2(T,I,V) = \\delta\\, I$。\n- 病毒产生：风险 $a_3(T,I,V) = p\\, I$。\n- 病毒清除：风险 $a_4(T,I,V) = c\\, V$。\n\n这里，$\\beta$ 是感染速率常数（每天），$\\delta$ 是感染细胞死亡率（每天），$p$ 是病毒产生率（每天），$c$ 是病毒清除率（每天）。SSA 应通过从速率等于所有风险之和的指数分布中抽取下一个反应时间来推进时间，然后以与其风险成正比的概率选择具体发生的反应。\n\n为量化平均场行为的恢复，计算具有相同参数和初始密度的确定性 ODE 解，在相同的时间范围内，并将最终时间的 SSA 密度系综平均值与最终时间的 ODE 解进行比较。使用最终时间点上三种密度的绝对 $L^1$ 差值作为误差度量：\n$$\nE = \\left| t_{\\mathrm{SSA}}(t_f) - t_{\\mathrm{ODE}}(t_f) \\right| + \\left| i_{\\mathrm{SSA}}(t_f) - i_{\\mathrm{ODE}}(t_f) \\right| + \\left| v_{\\mathrm{SSA}}(t_f) - v_{\\mathrm{ODE}}(t_f) \\right|.\n$$\n\n在质量作用定律下，为密度 $(t,i,v)$ 实现具有相同参数和初始密度的确定性 ODE。从 $t=0$ 积分到 $t=t_f$（单位：天）。\n\n测试套件：\n- 案例 1（基准线，中等数量）：参数 $(\\beta,\\delta,p,c,\\Omega,T_0,I_0,V_0,t_f,R) = (0.02, 1.0, 5.0, 10.0, 100000, 100000, 0, 10, 5.0, 200)$。计算误差 $E$（浮点数）。\n- 案例 2（边界情况，无初始病毒）：$(\\beta,\\delta,p,c,\\Omega,T_0,I_0,V_0,t_f,R) = (0.02, 1.0, 5.0, 10.0, 100000, 100000, 0, 0, 5.0, 50)$。计算误差 $E$（浮点数）。\n- 案例 3（更大系统尺寸，相同初始密度）：$(\\beta,\\delta,p,c,\\Omega,T_0,I_0,V_0,t_f,R) = (0.02, 1.0, 5.0, 10.0, 200000, 200000, 0, 20, 5.0, 200)$。计算误差 $E$（浮点数）。\n- 案例 4（高清除率）：$(\\beta,\\delta,p,c,\\Omega,T_0,I_0,V_0,t_f,R) = (0.02, 1.0, 5.0, 50.0, 100000, 100000, 0, 10, 5.0, 200)$。计算误差 $E$（浮点数）。\n- 案例 5（平均场恢复的布尔检查）：使用案例 1 和案例 3 的误差，输出一个布尔值，指示较大系统尺寸下的误差是否严格小于基准系统尺寸下的误差。\n\n算法要求：\n- 对于每个案例，运行 $R$ 次独立的 SSA 实现直到时间 $t_f$，并计算时间 $t_f$ 时的平均密度。\n- 独立求解具有相同初始密度的确定性 ODE，以获得 $(t_{\\mathrm{ODE}}(t_f), i_{\\mathrm{ODE}}(t_f), v_{\\mathrm{ODE}}(t_f))$。\n- 对于每个案例，计算如上定义的误差 $E$。对于案例 5，返回比较的布尔结果。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为案例 1 到案例 5。例如，输出应类似于 $[e_1,e_2,e_3,e_4,b_5]$，其中 $e_j$ 是浮点数，$b_5$ 是布尔值。所有时间都以天为单位；输出值为无单位值。\n\n所有浮点结果均以标准十进制表示法表示。程序必须是完整的、可直接运行的，并且不得读取任何输入。",
            "solution": "用户提供的问题经评估有效。这是一个在计算系统生物学领域中提法恰当、有科学依据的问题，没有矛盾、歧义或伪科学主张。该问题要求实现并比较病毒动力学的随机模拟及其对应的平均场确定性模型，这是一项标准且有意义的任务。\n\n解决方案分三个主要阶段制定：首先，定义确定性常微分方程（ODE）模型，该模型代表系统的平均场行为；其次，实现精确的随机模拟算法（SSA），也称为 Gillespie 算法，该算法模拟反应的离散和随机性质；第三，执行指定的测试案例，以比较两种模型并量化它们的差异。\n\n### 1. 确定性平均场模型（ODEs）\n\n该问题描述了一个包含三种组分的系统：靶细胞（$T$）、感染细胞（$I$）和游离病毒（$V$）。其动力学由四个反应事件控制。确定性模型描述了物种密度 $t(t) = T(t)/\\Omega$，$i(t) = I(t)/\\Omega$ 和 $v(t) = V(t)/\\Omega$ 的演化，其中 $\\Omega$ 是系统尺寸参数。这些 ODE 是作为底层随机过程的平均场极限（$\\Omega \\to \\infty$）推导出来的。\n\n每个反应的状态变化向量 $(\\Delta T, \\Delta I, \\Delta V)$ 和风险如下：\n1.  **感染**（$T \\to I$，由 $V$ 催化）：风险为 $a_1 = (\\beta/\\Omega)TV$。这代表一种双分子相互作用，其中靶细胞在与病毒接触后被感染。反应符号 $T \\to I$ 意味着病毒不被消耗，充当催化剂。状态变化为 $\\nu_1 = (-1, 1, 0)$。\n2.  **感染细胞死亡**（$I \\to \\emptyset$）：风险为 $a_2 = \\delta I$。这代表感染细胞的自然死亡。状态变化为 $\\nu_2 = (0, -1, 0)$。\n3.  **病毒产生**（$I \\to I+V$）：风险为 $a_3 = p I$。感染细胞产生新的病毒颗粒。状态变化为 $\\nu_3 = (0, 0, 1)$。\n4.  **病毒清除**（$V \\to \\emptyset$）：风险为 $a_4 = c V$。游离病毒颗粒从系统中被清除。状态变化为 $\\nu_4 = (0, 0, -1)$。\n\n每种组分 $\\vec{X} = (T,I,V)$ 的粒子数期望值的变化率由 $\\frac{d\\langle \\vec{X} \\rangle}{dt} = \\sum_{j=1}^{4} \\nu_j a_j(\\vec{X})$ 给出。应用平均场近似 $\\langle XY \\rangle \\approx \\langle X \\rangle \\langle Y \\rangle$ 并代入密度，我们得到以下 ODE 系统：\n$$\n\\frac{dt}{d\\tau} = -\\beta t v\n$$\n$$\n\\frac{di}{d\\tau} = \\beta t v - \\delta i\n$$\n$$\n\\frac{dv}{d\\tau} = p i - c v\n$$\n该系统使用初值问题求解器，特别是 `scipy.integrate.solve_ivp` 进行数值求解，以获得最终时间 $t_f$ 的密度确定性预测值。\n\n### 2. 随机模拟算法（SSA）\n\nSSA 模拟了由反应及其风险定义的连续时间马尔可夫跳跃过程的一个精确实现。该算法迭代进行，在每一步回答两个问题：（1）下一个反应何时发生？以及（2）它将是哪个反应？\n\n给定时间 $\\tau$ 时的状态 $(T, I, V)$：\n1.  **计算风险**：根据当前状态和参数 $(\\beta, \\delta, p, c, \\Omega)$ 计算四个风险 $a_1, a_2, a_3, a_4$。\n2.  **计算总风险**：总风险为 $a_0 = \\sum_{j=1}^{4} a_j$。如果 $a_0 = 0$，则没有更多反应可以发生，模拟终止。\n3.  **确定下一个反应时间**：到下一个反应发生的时间 $\\Delta \\tau$ 从速率为 $a_0$ 的指数分布中抽取。计算方式为 $\\Delta \\tau = \\frac{1}{a_0} \\ln(\\frac{1}{r_1})$，其中 $r_1$ 是从均匀分布 $U(0,1)$ 中抽取的随机数。然后模拟时间向前推进：$\\tau \\to \\tau + \\Delta \\tau$。\n4.  **选择下一个反应**：要发生的具体反应 $j$ 以概率 $a_j/a_0$ 被选择。这通过抽取第二个随机数 $r_2 \\sim U(0,1)$ 并找到索引 $j$ 来实现，使得 $\\sum_{k=1}^{j-1} a_k \\le r_2 a_0  \\sum_{k=1}^{j} a_k$。\n5.  **更新状态**：根据所选反应 $j$ 更新状态：$(T, I, V) \\to (T, I, V) + \\nu_j$。\n\n此过程重复进行，直到模拟时间 $\\tau$ 达到或超过最终时间 $t_f$。\n\n### 3. 比较与误差计算\n\n对于每个测试案例，我们执行以下步骤：\n1.  **运行 SSA 系综**：从初始状态 $(T_0, I_0, V_0)$ 运行 $R$ 次独立的 SSA 模拟，直到时间 $t_f$。收集所有 $R$ 次实现的最终时间状态并取平均，以产生系综平均计数 $(\\langle T(t_f) \\rangle, \\langle I(t_f) \\rangle, \\langle V(t_f) \\rangle)$。通过除以 $\\Omega$ 将它们转换为平均密度 $(t_{\\mathrm{SSA}}(t_f), i_{\\mathrm{SSA}}(t_f), v_{\\mathrm{SSA}}(t_f))$。\n2.  **求解 ODE**：在区间 $[0, t_f]$ 上用初始密度 $(t_0, i_0, v_0) = (T_0/\\Omega, I_0/\\Omega, V_0/\\Omega)$ 求解 ODE 系统，以获得最终时间的确定性解 $(t_{\\mathrm{ODE}}(t_f), i_{\\mathrm{ODE}}(t_f), v_{\\mathrm{ODE}}(t_f))$。\n3.  **计算误差**：将 SSA 系综平均密度与 $t_f$ 时的 ODE 密度之间的绝对 $L^1$ 差值计算为误差度量 $E$：\n    $$\n    E = | t_{\\mathrm{SSA}}(t_f) - t_{\\mathrm{ODE}}(t_f) | + | i_{\\mathrm{SSA}}(t_f) - i_{\\mathrm{ODE}}(t_f) | + | v_{\\mathrm{SSA}}(t_f) - v_{\\mathrm{ODE}}(t_f) |\n    $$\n4.  **案例 5 检查**：问题指明，随着系统尺寸 $\\Omega$ 的增加，随机模型应收敛于平均场模型。案例 1 和案例 3 测试了这一原理，因为案例 3 具有与案例 1 相同的初始密度，但系统尺寸更大（$\\Omega=200000$ 对比 $\\Omega=100000$）。我们预期案例 3 的误差 $E$ 会更小。执行一个布尔检查 $E_{case3}  E_{case1}$。\n\n该实现封装了此逻辑，处理了每个测试案例，包括没有初始病毒或感染细胞的边界情况（导致一个误差为零的静态系统），并最终将结果格式化为所需的单行输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef ode_model(t, y, beta, delta, p, c):\n    \"\"\"\n    Defines the system of ordinary differential equations for the viral dynamics model.\n    y = [t_density, i_density, v_density]\n    \"\"\"\n    t_density, i_density, v_density = y\n    \n    dtdt = -beta * t_density * v_density\n    didt = beta * t_density * v_density - delta * i_density\n    dvdt = p * i_density - c * v_density\n    \n    return [dtdt, didt, dvdt]\n\ndef run_ssa_trajectory(beta, delta, p, c, Omega, T0, I0, V0, tf):\n    \"\"\"\n    Runs a single realization of the Stochastic Simulation Algorithm (Gillespie).\n    \"\"\"\n    state = np.array([T0, I0, V0], dtype=np.int64)\n    time = 0.0\n    \n    nu = np.array([\n        [-1, 1, 0],  # Infection\n        [0, -1, 0],  # Infected cell death\n        [0, 0, 1],   # Viral production\n        [0, 0, -1]   # Viral clearance\n    ], dtype=np.int64)\n    \n    while time  tf:\n        T, I, V = state\n        \n        hazards = np.array([\n            (beta / Omega) * T * V,\n            delta * I,\n            p * I,\n            c * V\n        ])\n        \n        total_hazard = np.sum(hazards)\n        \n        if total_hazard == 0:\n            # No more reactions can occur\n            break\n            \n        dt = np.random.exponential(1.0 / total_hazard)\n        \n        # Select the next reaction\n        rand_val = np.random.uniform(0, 1) * total_hazard\n        reaction_index = 0\n        cumulative_hazard = hazards[0]\n        # This linear search is efficient for a small number of reactions (4)\n        while cumulative_hazard  rand_val and reaction_index  3:\n            reaction_index += 1\n            cumulative_hazard += hazards[reaction_index]\n\n        # Advance time, but break if we've passed the final time\n        time += dt\n        if time  tf:\n            break\n\n        # Update state based on the chosen reaction\n        state += nu[reaction_index]\n        # Prevent negative counts, a safeguard for numerical stability\n        state[state  0] = 0\n        \n    return state\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, orchestrating SSA and ODE simulations\n    for all test cases and formatting the final output.\n    \"\"\"\n    test_cases = [\n        # Case 1 (baseline)\n        {'beta': 0.02, 'delta': 1.0, 'p': 5.0, 'c': 10.0, 'Omega': 100000, 'T0': 100000, 'I0': 0, 'V0': 10, 'tf': 5.0, 'R': 200},\n        # Case 2 (no initial virus)\n        {'beta': 0.02, 'delta': 1.0, 'p': 5.0, 'c': 10.0, 'Omega': 100000, 'T0': 100000, 'I0': 0, 'V0': 0, 'tf': 5.0, 'R': 50},\n        # Case 3 (larger system size)\n        {'beta': 0.02, 'delta': 1.0, 'p': 5.0, 'c': 10.0, 'Omega': 200000, 'T0': 200000, 'I0': 0, 'V0': 20, 'tf': 5.0, 'R': 200},\n        # Case 4 (high clearance)\n        {'beta': 0.02, 'delta': 1.0, 'p': 5.0, 'c': 50.0, 'Omega': 100000, 'T0': 100000, 'I0': 0, 'V0': 10, 'tf': 5.0, 'R': 200},\n    ]\n\n    results = []\n    error_cache = {}\n\n    for i, params in enumerate(test_cases):\n        # Unpack parameters\n        beta, delta, p, c = params['beta'], params['delta'], params['p'], params['c']\n        Omega, T0, I0, V0 = params['Omega'], params['T0'], params['I0'], params['V0']\n        tf, R = params['tf'], params['R']\n        \n        # --- ODE Solution ---\n        y0 = [T0 / Omega, I0 / Omega, V0 / Omega]\n        sol = solve_ivp(\n            fun=ode_model,\n            t_span=(0, tf),\n            y0=y0,\n            args=(beta, delta, p, c),\n            t_eval=[tf],\n            method='RK45'\n        )\n        ode_final_densities = sol.y.flatten()\n\n        # --- SSA Ensemble Average ---\n        # Handle the static case where no reactions can ever occur\n        if ((beta / Omega) * T0 * V0 == 0) and (delta * I0 == 0) and (p * I0 == 0) and (c * V0 == 0):\n             ssa_final_avg_counts = np.array([T0, I0, V0], dtype=np.float64)\n        else:\n            final_counts_sum = np.zeros(3, dtype=np.float64)\n            for _ in range(R):\n                final_counts = run_ssa_trajectory(beta, delta, p, c, Omega, T0, I0, V0, tf)\n                final_counts_sum += final_counts\n            ssa_final_avg_counts = final_counts_sum / R\n        \n        ssa_final_avg_densities = ssa_final_avg_counts / Omega\n        \n        # --- Error Calculation ---\n        error = np.sum(np.abs(ssa_final_avg_densities - ode_final_densities))\n        \n        results.append(error)\n        error_cache[i + 1] = error\n\n    # --- Case 5: Boolean check of mean-field recovery ---\n    error_case1 = error_cache[1]\n    error_case3 = error_cache[3]\n    boolean_result = error_case3  error_case1\n    \n    final_output_list = results + [boolean_result]\n    \n    # Format the final output list into the required string format\n    final_str_list = [f\"{x:.12f}\" if isinstance(x, (float, np.floating)) else str(x) for x in final_output_list]\n    print(f\"[{','.join(final_str_list)}]\")\n\nsolve()\n```"
        }
    ]
}