{
    "hands_on_practices": [
        {
            "introduction": "免疫系统的机理模型通常涉及众多参数，这使得分析变得复杂且不直观。无量纲化是一种强大的数学技术，它通过选择特征尺度来重新缩放变量，从而减少参数数量，揭示控制系统行为的关键参数组合。本练习将指导您完成对一个病原体-效应细胞-细胞因子相互作用模型的无量纲化过程，通过此练习，您将学会如何识别系统中的主导平衡和时间尺度分离，这是理论生物学和系统建模中的一项核心技能。",
            "id": "3893326",
            "problem": "考虑以下病原体、效应细胞和细胞因子动力学的机理模型，该模型被表述为一个常微分方程（ODE）系统。病原体种群 $P(t)$ 进行逻辑斯谛增长，并被效应细胞种群 $E(t)$ 清除。效应细胞响应抗原和细胞因子的刺激而增殖，并以恒定的人均速率死亡。细胞因子 $C(t)$ 由效应细胞产生并迅速衰减。模型为\n$$\n\\frac{dP}{dt} \\;=\\; r\\,P\\left(1-\\frac{P}{K}\\right) \\;-\\; \\kappa\\,E\\,P,\n$$\n$$\n\\frac{dE}{dt} \\;=\\; \\alpha\\,\\frac{P}{P+\\theta}\\,\\frac{C}{C+\\gamma}\\,E \\;-\\; \\delta\\,E,\n$$\n$$\n\\frac{dC}{dt} \\;=\\; \\sigma\\,E \\;-\\; \\mu\\,C,\n$$\n其中 $r$ 是病原体的内禀增长率，$K$ 是病原体的环境容纳量，$\\kappa$ 是每个效应细胞对病原体的清除效率，$\\alpha$ 是抗原驱动的效应细胞最大增殖率，$\\theta$ 是抗原刺激的半饱和常数，$\\gamma$ 是细胞因子介导的共刺激的半饱和常数，$\\delta$ 是效应细胞的死亡率，$\\sigma$ 是每个效应细胞的细胞因子产生率，$\\mu$ 是细胞因子的衰减率。所有参数均为正，并且在生物学上是合理的。\n\n您的任务是：\n- 从无量纲化和主导平衡的核心定义出发，为时间、病原体、效应细胞和细胞因子选择特征尺度，以缩减参数空间并明确揭示主导阶平衡。具体而言：\n  - 令特征时间尺度由病原体的内禀增长决定，即选择 $t_{0}$ 使得 $t_{0}^{-1}$ 等于内禀增长率。\n  - 令特征病原体尺度由环境容纳量决定。\n  - 通过在病原体和效应细胞处于其特征尺度时，平衡它们各自产生和损失过程中的主导项，来确定效应细胞和细胞因子的尺度。\n- 引入由此产生的无量纲变量和参数，并写出无量纲化的常微分方程组。\n- 在细胞因子周转远快于病原体种群变化的现实假设下，识别一个小的无量纲参数，该参数捕捉了细胞因子快速衰减时间尺度相对于病原体增长时间尺度的分离。\n- 使用主导平衡推理，解释细胞因子方程中出现的奇异摄动结构，并陈述其在主导阶上的相关准稳态关系。\n\n作为最终答案，请提供上述定义的小参数的单一闭合形式解析表达式，用原始有量纲参数明确写出。最终的方框答案中不要包含单位。如果引入任何缩写词，请在首次使用时写出全称（例如，常微分方程 (ordinary differential equation, ODE)）。",
            "solution": "问题要求对给定的常微分方程（ODE）系统进行无量纲化，识别一个关键的小参数，并解释由此产生的奇异摄动结构。\n\n该常微分方程组为：\n$$\n\\frac{dP}{dt} \\;=\\; r\\,P\\left(1-\\frac{P}{K}\\right) \\;-\\; \\kappa\\,E\\,P\n$$\n$$\n\\frac{dE}{dt} \\;=\\; \\alpha\\,\\frac{P}{P+\\theta}\\,\\frac{C}{C+\\gamma}\\,E \\;-\\; \\delta\\,E\n$$\n$$\n\\frac{dC}{dt} \\;=\\; \\sigma\\,E \\;-\\; \\mu\\,C\n$$\n\n我们的首要任务是为时间（$t$）、病原体种群（$P$）、效应细胞种群（$E$）和细胞因子浓度（$C$）选择特征尺度。让这些尺度分别表示为 $t_0$、$P_0$、$E_0$ 和 $C_0$。我们引入无量纲变量 $\\tau$、$p$、$e$ 和 $c$，使得：\n$$\nt = t_0 \\tau, \\quad P = P_0 p, \\quad E = E_0 e, \\quad C = C_0 c\n$$\n\n问题指明了时间和病原体种群的尺度：\n1.  特征时间尺度 $t_0$ 由病原体的内禀增长率 $r$ 决定。这意味着 $t_0 = 1/r$。\n2.  特征病原体尺度 $P_0$ 由环境容纳量 $K$ 决定。这意味着 $P_0 = K$。\n\n接下来，我们通过对控制方程应用主导平衡原理来确定效应细胞的尺度 $E_0$ 和细胞因子的尺度 $C_0$。\n\n为了确定 $E_0$，我们考察病原体方程。右侧的两项分别代表病原体的增长和被效应细胞清除。当这两个过程的量级相当时，会发生有意义的动态相互作用。因此，我们在它们的特征尺度（$P \\sim P_0$，$E \\sim E_0$）上平衡内禀增长项 $rP$ 和清除项 $\\kappa EP$。\n$$\nr P_0 \\sim \\kappa E_0 P_0\n$$\n解出 $E_0$，我们得到：\n$$\nE_0 = \\frac{r}{\\kappa}\n$$\n这一选择确保了清除项的无量纲系数将是单位量级。\n\n为了确定 $C_0$，我们考察细胞因子方程。右侧的两项分别代表效应细胞产生细胞因子和细胞因子的衰减。此处的主导平衡意味着，当变量处于其特征尺度（$E \\sim E_0$，$C \\sim C_0$）时，产生和衰减速率处于同一数量级。\n$$\n\\sigma E_0 \\sim \\mu C_0\n$$\n代入 $E_0=r/\\kappa$ 的表达式并解出 $C_0$，我们得到：\n$$\nC_0 = \\frac{\\sigma E_0}{\\mu} = \\frac{\\sigma r}{\\mu \\kappa}\n$$\n这一选择等同于在尺度级别上对细胞因子动力学做出准稳态假设，这与问题的前提——细胞因子周转迅速——是一致的。\n\n完整的尺度关系集为：\n$$\nt = \\frac{1}{r}\\tau, \\quad P = Kp, \\quad E = \\frac{r}{\\kappa}e, \\quad C = \\frac{\\sigma r}{\\mu \\kappa}c\n$$\n\n现在我们将原始的常微分方程组转换为其无量纲形式。导数变换如下：\n$$\n\\frac{d}{dt} = \\frac{d}{d(t_0 \\tau)} = \\frac{1}{t_0}\\frac{d}{d\\tau} = r\\frac{d}{d\\tau}\n$$\n所以，$\\frac{dP}{dt} = K r \\frac{dp}{d\\tau}$，$\\frac{dE}{dt} = \\frac{r^2}{\\kappa} \\frac{de}{d\\tau}$，以及 $\\frac{dC}{dt} = \\frac{\\sigma r^2}{\\mu \\kappa} \\frac{dc}{d\\tau}$。\n\n将这些代入原始的常微分方程组：\n\n1.  病原体方程：\n$$\nK r \\frac{dp}{d\\tau} = r(Kp)\\left(1 - \\frac{Kp}{K}\\right) - \\kappa\\left(\\frac{r}{\\kappa}e\\right)(Kp)\n$$\n$$\nK r \\frac{dp}{d\\tau} = rKp(1-p) - rKep\n$$\n将整个方程除以 $Kr$ 得到无量纲的病原体方程：\n$$\n\\frac{dp}{d\\tau} = p(1-p) - ep\n$$\n\n2.  效应细胞方程：\n$$\n\\frac{r^2}{\\kappa} \\frac{de}{d\\tau} = \\alpha \\frac{Kp}{Kp+\\theta} \\frac{\\frac{\\sigma r}{\\mu \\kappa}c}{\\frac{\\sigma r}{\\mu \\kappa}c + \\gamma} \\left(\\frac{r}{\\kappa}e\\right) - \\delta\\left(\\frac{r}{\\kappa}e\\right)\n$$\n除以 $r/\\kappa$：\n$$\nr \\frac{de}{d\\tau} = \\alpha \\frac{p}{p+\\theta/K} \\frac{c}{c+\\gamma/(\\frac{\\sigma r}{\\mu \\kappa})} e - \\delta e\n$$\n除以 $r$：\n$$\n\\frac{de}{d\\tau} = \\left( \\frac{\\alpha}{r} \\frac{p}{p+\\theta/K} \\frac{c}{c + \\frac{\\gamma \\mu \\kappa}{\\sigma r}} - \\frac{\\delta}{r} \\right) e\n$$\n我们定义以下无量纲参数：\n$\\beta_1 = \\frac{\\alpha}{r}$，最大效应细胞增殖率与病原体增长率之比。\n$\\hat{\\theta} = \\frac{\\theta}{K}$，无量纲的抗原饱和常数。\n$\\hat{\\gamma} = \\frac{\\gamma \\mu \\kappa}{\\sigma r}$，无量纲的细胞因子饱和常数。\n$\\beta_2 = \\frac{\\delta}{r}$，效应细胞死亡率与病原体增长率之比。\n无量纲的效应细胞方程为：\n$$\n\\frac{de}{d\\tau} = \\left( \\beta_1 \\frac{p}{p+\\hat{\\theta}} \\frac{c}{c+\\hat{\\gamma}} - \\beta_2 \\right) e\n$$\n\n3.  细胞因子方程：\n$$\n\\frac{\\sigma r^2}{\\mu \\kappa} \\frac{dc}{d\\tau} = \\sigma\\left(\\frac{r}{\\kappa}e\\right) - \\mu\\left(\\frac{\\sigma r}{\\mu \\kappa}c\\right)\n$$\n$$\n\\frac{\\sigma r^2}{\\mu \\kappa} \\frac{dc}{d\\tau} = \\frac{\\sigma r}{\\kappa}e - \\frac{\\sigma r}{\\kappa}c = \\frac{\\sigma r}{\\kappa}(e-c)\n$$\n除以 $\\frac{\\sigma r}{\\kappa}$：\n$$\n\\frac{r}{\\mu}\\frac{dc}{d\\tau} = e-c\n$$\n\n最终的无量纲系统为：\n$$\n\\frac{dp}{d\\tau} = p(1-p) - ep\n$$\n$$\n\\frac{de}{d\\tau} = \\left( \\beta_1 \\frac{p}{p+\\hat{\\theta}} \\frac{c}{c+\\hat{\\gamma}} - \\beta_2 \\right) e\n$$\n$$\n\\frac{r}{\\mu}\\frac{dc}{d\\tau} = e-c\n$$\n\n第三个任务是识别一个与时间尺度分离相关的小参数。病原体增长的特征时间是 $t_{pathogen} \\sim 1/r$。细胞因子衰减的特征时间是 $t_{cytokine} \\sim 1/\\mu$。问题陈述细胞因子周转远快于病原体种群变化，这意味着 $t_{cytokine} \\ll t_{pathogen}$，或 $1/\\mu \\ll 1/r$。这蕴含了 $r/\\mu \\ll 1$。\n\n在我们的无量纲细胞因子方程中，我们有 $\\frac{r}{\\mu}$ 这一项。让我们将这个无量纲参数定义为 $\\epsilon$：\n$$\n\\epsilon = \\frac{r}{\\mu}\n$$\n方程变为 $\\epsilon \\frac{dc}{d\\tau} = e-c$。因为 $r/\\mu \\ll 1$，我们有 $\\epsilon \\ll 1$。\n\n最后一个任务是解释奇异摄动结构。方程 $\\epsilon \\frac{dc}{d\\tau} = e-c$ 是奇异摄动常微分方程的一个经典例子，其中小参数 $\\epsilon$ 乘以导数。这表明时间尺度的分离：变量 $c$ 在量级为 $\\epsilon$ 的快时间尺度上演化，而 $p$ 和 $e$ 在量级为 $1$ 的慢时间尺度上演化。\n\n对慢时间尺度使用主导平衡推理，我们可以通过考虑极限 $\\epsilon \\to 0$ 来近似动力学。这被称为准稳态近似。在细胞因子方程中令 $\\epsilon=0$ 得到：\n$$\n0 = e - c\n$$\n这蕴含了主导阶的准稳态关系：\n$$\nc(\\tau) \\approx e(\\tau)\n$$\n这意味着，在病原体和效应细胞动力学的时间尺度上，无量纲的细胞因子浓度迅速达到平衡，并追踪无量纲的效应细胞种群。量化此时间尺度分离的小参数是 $\\epsilon = r/\\mu$。",
            "answer": "$$\\boxed{\\frac{r}{\\mu}}$$"
        },
        {
            "introduction": "免疫系统在面对抗原时，常常表现出类似开关的决策行为，例如在免疫激活和免疫耐受两种状态之间做出选择。这种行为在动力学系统模型中通常表现为“双稳态”，即系统在相同的参数条件下可能存在两个不同的稳定状态。分岔分析是研究这些状态如何随外界条件（如抗原驱动强度 $A$）的变化而出现、消失或转变的计算工具。 在这个计算实践中，您将通过对一个调节性T细胞（Treg）与效应T细胞相互作用的模型进行数值模拟，来绘制不同状态的吸引盆，从而深入理解免疫系统是如何做出关键的质性决策的。",
            "id": "3893263",
            "problem": "考虑一个调节性T细胞 (Treg) 和常规效应T细胞的最小动力系统模型，该模型捕捉了免疫耐受与激活的对比。令 $E(t)$ 表示效应T细胞的无量纲激活水平，令 $R(t)$ 表示调节性T细胞 (Treg) 的无量纲丰度。该系统根据耦合常微分方程 (ODE) 演化，其中一方的产生过程受另一方群体的抑制，并存在线性清除：\n$$\n\\frac{dE}{dt} \\;=\\; \\frac{\\alpha_E}{1 + \\left(\\frac{R}{K_R}\\right)^{n}} \\;-\\; \\delta_E E,\\quad\n\\frac{dR}{dt} \\;=\\; \\frac{\\alpha_R}{1 + \\left(\\frac{E}{K_E}\\right)^{m}} \\;-\\; \\delta_R R.\n$$\n抗原驱动被建模为通过参数 $A$ 对效应细胞产生率 $\\alpha_E$ 的一个附加增加，即 $\\alpha_E = \\alpha_{E0} + \\theta A$，其中 $\\alpha_{E0}$ 是基线效应细胞产生率，$\\theta$ 是抗原与效应细胞产生的耦合强度。量 $E$ 和 $R$ 以及时间 $t$ 都是无量纲的，所有参数都严格为正。调节性T细胞 (Treg) 通过一个带有系数 $n$ 和半饱和常数 $K_R$ 的希尔型项来抑制效应细胞的产生，而效应T细胞则通过一个带有希尔系数 $m$ 和半饱和常数 $K_E$ 的项来抑制Treg的产生。清除率分别为 $\\delta_E$ 和 $\\delta_R$。\n\n该系统的基本建模原则是：\n- 产生过程受到饱和抑制的限制，这与受体介导的调控和细胞因子反馈一致。\n- 清除过程相对于群体水平是线性的，反映了一级损失。\n- 抗原驱动是一个外部参数输入，它调节效应细胞的产生，但不直接改变Treg的产生。\n\n您的任务是针对抗原驱动 $A$ 进行计算分岔分析，以识别表现出双稳态的区域，并刻画耐受状态与激活状态的吸引盆。使用从有界域中的初始条件网格进行的数值前向积分，以近似吸引子及其吸引盆。\n\n分类定义：\n- 耐受吸引子是任何满足 $R^\\star \\ge E^\\star$ 的数值近似稳态 $(E^\\star, R^\\star)$。\n- 激活吸引子是任何满足 $E^\\star  R^\\star$ 的数值近似稳态 $(E^\\star, R^\\star)$。\n\n对于下文测试套件中的每个参数集，您必须：\n1. 对于集合中 $A$ 的每个指定值，从指定域上的均匀初始条件网格 $(E(0), R(0))$ 开始对ODE进行积分，积分时间需足够长以达到稳定行为。使用固定的距离阈值 $\\varepsilon$ 对终点进行聚类，以识别不同的吸引子。对于每个 $A$，计算不同吸引子的数量。报告该集合中所有 $A$ 值中不同吸引子的最大数量（一个整数）。\n2. 对于集合中指定的 $A^\\star$，通过计算其轨迹分别收敛到耐受吸引子与激活吸引子的初始条件所占的比例，来估计耐受和激活的吸引盆分数。吸引盆分数表示为 $[0,1]$ 范围内的小数。\n\n科学和计算约束：\n- 所有变量和参数都是无量纲的；不需要物理单位。\n- 初始条件网格必须在 $E(0) \\in [0, E_{\\max}]$ 和 $R(0) \\in [0, R_{\\max}]$ 上均匀分布，使用每个轴上指定的网格点数。\n- 必须对积分执行至固定的最终时间 $T_{\\text{end}}$。\n- 聚类必须在 $(E,R)$ 平面上使用指定的欧几里得阈值 $\\varepsilon$ 将终点分组为吸引子。\n\n参数集测试套件（每个案例都是一个需要在程序中硬编码的元组式规范）：\n- 案例1（偏向耐受的基线）：\n  - $\\alpha_{E0} = 0.2$, $\\alpha_{R} = 1.4$, $\\theta = 0.6$, $\\delta_{E} = 1.0$, $\\delta_{R} = 1.0$, $K_{E} = 0.5$, $K_{R} = 0.5$, $m = 4$, $n = 4$。\n  - $A \\in \\{0.0, 0.2, 0.4, 0.6\\}$，$A^\\star = 0.4$。\n  - $E_{\\max} = 2.0$, $R_{\\max} = 2.0$，每轴网格点数 $= 5$, $T_{\\text{end}} = 200.0$, $\\varepsilon = 10^{-3}$。\n- 案例2（偏向激活的基线）：\n  - $\\alpha_{E0} = 1.2$, $\\alpha_{R} = 0.5$, $\\theta = 0.6$, $\\delta_{E} = 1.0$, $\\delta_{R} = 1.0$, $K_{E} = 0.5$, $K_{R} = 0.5$, $m = 4$, $n = 4$。\n  - $A \\in \\{0.0, 0.5, 1.0\\}$，$A^\\star = 1.0$。\n  - $E_{\\max} = 2.0$, $R_{\\max} = 2.0$，每轴网格点数 $= 5$, $T_{\\text{end}} = 200.0$, $\\varepsilon = 10^{-3}$。\n- 案例3（中间区域，可能存在双稳态）：\n  - $\\alpha_{E0} = 0.7$, $\\alpha_{R} = 1.0$, $\\theta = 0.9$, $\\delta_{E} = 1.0$, $\\delta_{R} = 1.0$, $K_{E} = 0.5$, $K_{R} = 0.5$, $m = 4$, $n = 4$。\n  - $A \\in \\{0.0, 0.3, 0.6, 0.9, 1.2\\}$，$A^\\star = 0.6$。\n  - $E_{\\max} = 2.0$, $R_{\\max} = 2.0$，每轴网格点数 $= 5$, $T_{\\text{end}} = 200.0$, $\\varepsilon = 10^{-3}$。\n- 案例4（近乎平衡的边界区域）：\n  - $\\alpha_{E0} = 0.9$, $\\alpha_{R} = 0.9$, $\\theta = 0.4$, $\\delta_{E} = 1.0$, $\\delta_{R} = 1.0$, $K_{E} = 0.5$, $K_{R} = 0.5$, $m = 4$, $n = 4$。\n  - $A \\in \\{0.0, 0.4, 0.8\\}$，$A^\\star = 0.4$。\n  - $E_{\\max} = 2.0$, $R_{\\max} = 2.0$，每轴网格点数 $= 5$, $T_{\\text{end}} = 200.0$, $\\varepsilon = 10^{-3}$。\n\n算法要求：\n- 对每个初始条件和每个 $A$ 值，使用数值ODE积分到 $t = T_{\\text{end}}$。\n- 使用带有阈值 $\\varepsilon$ 的欧几里得聚类将终点归纳为不同的吸引子。\n- 通过比较 $R^\\star$ 和 $E^\\star$ 将每个吸引子分类为耐受或激活。\n- 对每个案例，计算：\n  - 在所有提供的 $A$ 值中，不同吸引子的最大数量（一个整数）。\n  - 一个布尔值，表示在 $A^\\star$ 时是否存在双稳态（即，在 $A^\\star$ 时至少有两个不同的吸引子）。\n  - 在 $A^\\star$ 时的耐受吸引盆分数（一个小数）。\n  - 在 $A^\\star$ 时的激活吸引盆分数（一个小数）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。每个案例贡献一个包含四个值的列表，顺序为 $[{\\text{max\\_attractors}}, {\\text{bistability\\_at\\_}A^\\star}, {\\text{tolerance\\_fraction}}, {\\text{activation\\_fraction}}]$，最终产生形式如下的输出：\n$[[m_1,b_1,t_1,a_1],[m_2,b_2,t_2,a_2],[m_3,b_3,t_3,a_3],[m_4,b_4,t_4,a_4]]$\n其中 $m_i$ 是整数，$b_i$ 是布尔值，$t_i,a_i$ 是 $[0,1]$ 范围内的小数。",
            "solution": "用户提供了一个数学问题，具体是分析一个模拟效应T细胞和调节性T细胞（Treg）相互作用的动力系统。问题要求针对一个抗原驱动参数 $A$ 进行计算分岔分析。这涉及对系统的常微分方程（ODE）进行数值积分，识别吸引子，并估计它们的吸引盆。\n\n该问题是有效的。它在科学上基于系统生物学的既定原则，定义了所有必要的参数和条件，问题阐述清晰，并提出了一个明确、客观且可验证的计算任务。我将着手提供一个解决方案。\n\n该ODE系统由以下公式给出：\n$$\n\\frac{dE}{dt} \\;=\\; \\frac{\\alpha_E}{1 + \\left(\\frac{R}{K_R}\\right)^{n}} \\;-\\; \\delta_E E\n$$\n$$\n\\frac{dR}{dt} \\;=\\; \\frac{\\alpha_R}{1 + \\left(\\frac{E}{K_E}\\right)^{m}} \\;-\\; \\delta_R R\n$$\n其中 $E(t)$ 是效应T细胞激活水平，$R(t)$ 是Treg丰度。效应细胞产生率 $\\alpha_E$ 受抗原驱动项 $A$ 调节，使得 $\\alpha_E = \\alpha_{E0} + \\theta A$。对于给定的情景，所有其他参数均为常数。该系统描述了一个拨动开关，其中每个细胞群体通过希尔型动力学抑制对方的产生。已知这类系统会表现出双稳态，即对于同一组参数，可以共存两个不同的稳定稳态。\n\n解决方案的核心是为四个测试案例中的每一个实施指定的数值程序。该程序如下：\n\n1.  **遍历测试案例**：主逻辑将循环遍历测试套件中提供的四个参数集中的每一个。\n\n2.  **分岔分析循环**：对于每个测试案例，我们将遍历抗原驱动参数 $A$ 的指定值。对于每个 $A$ 值：\n    *   **生成初始条件**：在域 $[0, E_{\\max}] \\times [0, R_{\\max}]$ 上使用每个轴指定的网格点数，创建一个均匀的初始条件网格 $(E(0), R(0))$。对于每个轴 $N$ 个点，这将产生总共 $N^2$ 个初始条件。\n    *   **数值积分**：对于每个初始条件，将ODE系统从 $t=0$ 数值积分到 $t=T_{\\text{end}}$。最终状态 $(E(T_{\\text{end}}), R(T_{\\text{end}}))$ 代表了轨迹在相图上演化到的点。鉴于清除率 $\\delta_E = \\delta_R = 1.0$，系统的特征时间尺度约为 $1$。积分到 $T_{\\text{end}} = 200.0$ 足以使系统收敛到一个稳定吸引子。我们将为此使用 `scipy.integrate.solve_ivp` 函数及标准的龙格-库塔方法。\n    *   **通过聚类识别吸引子**：在给定 $A$ 的所有积分完成后，收集终点坐标集。这些点将在 $(E, R)$ 平面中进行聚类。实现一个简单的顺序聚类算法：\n        1.  从所有唯一的终点坐标列表开始。\n        2.  当未分配点的列表不为空时，取第一个点作为新聚类的“种子”。\n        3.  列表中所有与“种子”的欧几里得距离在 $\\varepsilon$ 之内的点（包括种子本身）被分组到一个新聚类中，并从未分配点列表中移除。\n        4.  计算这个新聚类的质心，并将其作为不同吸引子的代表坐标 $(E^\\star, R^\\star)$ 存储起来。\n        5.  重复此过程，直到所有点都已分配到一个聚类中。\n    *   **数据收集**：记录当前 $A$ 值下找到的不同吸引子的数量（即聚类的数量）。该值用于更新当前测试案例中迄今为止观察到的最大吸引子数量。\n\n3.  **吸引盆分析**：对于每个测试案例，指定一个特定的值 $A^\\star$ 进行详细的吸引盆分析。使用在 $A = A^\\star$ 时的模拟运行结果：\n    *   **双稳态检查**：如果在 $A^\\star$ 处找到的吸引子数量为两个或更多，则存在双稳态（或多稳态）。这被记录为一个布尔值。\n    *   **吸引子分类**：每个识别出的吸引子 $(E^\\star, R^\\star)$ 根据提供的定义进行分类：\n        *   **耐受**：$R^\\star \\ge E^\\star$。\n        *   **激活**：$E^\\star  R^\\star$。\n    *   **吸引盆分数计算**：每种类型吸引子的吸引盆由收敛到它的初始条件所占的比例来估计。将收敛到任何耐受吸引子的初始模拟点总数相加，对激活吸引子也进行同样操作。将这些总和除以初始条件的总数 ($N^2$)，分别得到耐受和激活的吸引盆分数。\n\n4.  **最终输出格式化**：对于每个测试案例，将所需的四个指标——所有 $A$ 值中的最大吸引子数、在 $A^\\star$ 处的双稳态布尔值、在 $A^\\star$ 处的耐受吸引盆分数和在 $A^\\star$ 处的激活吸引盆分数——收集到一个列表中。最终输出是这四个列表的列表，格式化为问题陈述中指定的单个字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run the bifurcation analysis for all test cases and print results.\n    \"\"\"\n    \n    test_cases = [\n        {\n            # Case 1 (tolerance-favoring baseline)\n            \"params\": {\"alpha_E0\": 0.2, \"alpha_R\": 1.4, \"theta\": 0.6, \"delta_E\": 1.0, \"delta_R\": 1.0, \"K_E\": 0.5, \"K_R\": 0.5, \"m\": 4, \"n\": 4},\n            \"A_values\": [0.0, 0.2, 0.4, 0.6],\n            \"A_star\": 0.4,\n            \"sim_settings\": {\"E_max\": 2.0, \"R_max\": 2.0, \"grid_points\": 5, \"T_end\": 200.0, \"epsilon\": 1e-3},\n        },\n        {\n            # Case 2 (activation-favoring baseline)\n            \"params\": {\"alpha_E0\": 1.2, \"alpha_R\": 0.5, \"theta\": 0.6, \"delta_E\": 1.0, \"delta_R\": 1.0, \"K_E\": 0.5, \"K_R\": 0.5, \"m\": 4, \"n\": 4},\n            \"A_values\": [0.0, 0.5, 1.0],\n            \"A_star\": 1.0,\n            \"sim_settings\": {\"E_max\": 2.0, \"R_max\": 2.0, \"grid_points\": 5, \"T_end\": 200.0, \"epsilon\": 1e-3},\n        },\n        {\n            # Case 3 (intermediate regime, potential bistability)\n            \"params\": {\"alpha_E0\": 0.7, \"alpha_R\": 1.0, \"theta\": 0.9, \"delta_E\": 1.0, \"delta_R\": 1.0, \"K_E\": 0.5, \"K_R\": 0.5, \"m\": 4, \"n\": 4},\n            \"A_values\": [0.0, 0.3, 0.6, 0.9, 1.2],\n            \"A_star\": 0.6,\n            \"sim_settings\": {\"E_max\": 2.0, \"R_max\": 2.0, \"grid_points\": 5, \"T_end\": 200.0, \"epsilon\": 1e-3},\n        },\n        {\n            # Case 4 (near-balanced boundary regime)\n            \"params\": {\"alpha_E0\": 0.9, \"alpha_R\": 0.9, \"theta\": 0.4, \"delta_E\": 1.0, \"delta_R\": 1.0, \"K_E\": 0.5, \"K_R\": 0.5, \"m\": 4, \"n\": 4},\n            \"A_values\": [0.0, 0.4, 0.8],\n            \"A_star\": 0.4,\n            \"sim_settings\": {\"E_max\": 2.0, \"R_max\": 2.0, \"grid_points\": 5, \"T_end\": 200.0, \"epsilon\": 1e-3},\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        max_attractors = 0\n        results_at_A_star = {}\n\n        for A_val in case[\"A_values\"]:\n            # Set up parameters for this run\n            current_params = case[\"params\"].copy()\n            current_params[\"A\"] = A_val\n            \n            # Generate initial conditions\n            sim_settings = case[\"sim_settings\"]\n            grid_points = sim_settings[\"grid_points\"]\n            E_space = np.linspace(0, sim_settings[\"E_max\"], grid_points)\n            R_space = np.linspace(0, sim_settings[\"R_max\"], grid_points)\n            initial_conditions = np.array(np.meshgrid(E_space, R_space)).T.reshape(-1, 2)\n            \n            # Run simulations\n            endpoints = []\n            for ic in initial_conditions:\n                sol = solve_ivp(\n                    fun=ode_system,\n                    t_span=[0, sim_settings[\"T_end\"]],\n                    y0=ic,\n                    args=(current_params,),\n                    method='RK45',\n                    rtol=1e-6,\n                    atol=1e-6\n                )\n                endpoints.append(sol.y[:, -1])\n            \n            # Cluster endpoints\n            attractors, counts = cluster_endpoints(endpoints, sim_settings[\"epsilon\"])\n            num_attractors = len(attractors)\n            if num_attractors > max_attractors:\n                max_attractors = num_attractors\n\n            # Analyze for A_star\n            if A_val == case[\"A_star\"]:\n                bistability = True if num_attractors >= 2 else False\n                \n                tol_count = 0\n                act_count = 0\n                \n                for i, attractor in enumerate(attractors):\n                    E_star, R_star = attractor\n                    if R_star >= E_star: # Tolerance\n                        tol_count += counts[i]\n                    else: # Activation\n                        act_count += counts[i]\n                \n                total_points = len(initial_conditions)\n                tol_frac = tol_count / total_points\n                act_frac = act_count / total_points\n                \n                results_at_A_star = {\n                    \"bistability\": bistability,\n                    \"tol_frac\": tol_frac,\n                    \"act_frac\": act_frac\n                }\n        \n        case_result = [\n            max_attractors,\n            results_at_A_star[\"bistability\"],\n            results_at_A_star[\"tol_frac\"],\n            results_at_A_star[\"act_frac\"]\n        ]\n        all_results.append(case_result)\n\n    # Format output\n    def format_item(item):\n        if isinstance(item, bool):\n            return str(item).lower()\n        if isinstance(item, float):\n             return f\"{item:.6f}\".rstrip('0').rstrip('.') if '.' in f\"{item:.6f}\" else f\"{item:.1f}\"\n        return str(item)\n\n    formatted_sublists = []\n    for sublist in all_results:\n        # A bit of logic to ensure float representation is clean\n        sublist[2] = float(f\"{sublist[2]:.4f}\")\n        sublist[3] = float(f\"{sublist[3]:.4f}\")\n        formatted_sublists.append(f\"[{','.join(format_item(item) for item in sublist)}]\")\n    \n    final_output = f\"[{','.join(formatted_sublists)}]\"\n    print(final_output)\n\ndef ode_system(t, y, params):\n    \"\"\"\n    Defines the system of ODEs for T-cell dynamics.\n    y[0] = E, y[1] = R\n    \"\"\"\n    E, R = y\n    \n    alpha_E = params[\"alpha_E0\"] + params[\"theta\"] * params[\"A\"]\n    \n    dE_dt = alpha_E / (1 + (R / params[\"K_R\"])**params[\"n\"]) - params[\"delta_E\"] * E\n    dR_dt = params[\"alpha_R\"] / (1 + (E / params[\"K_E\"])**params[\"m\"]) - params[\"delta_R\"] * R\n    \n    return [dE_dt, dR_dt]\n\ndef cluster_endpoints(endpoints, epsilon):\n    \"\"\"\n    Clusters final trajectory points into attractors.\n    Implements a simple sequential (leader) clustering algorithm.\n    \"\"\"\n    if not endpoints:\n        return [], []\n\n    unassigned_points = [np.array(p) for p in endpoints]\n    centroids = []\n    counts = []\n\n    while unassigned_points:\n        seed = unassigned_points[0]\n        \n        # Points in the new cluster are those close to the seed\n        current_cluster_points = [p for p in unassigned_points if np.linalg.norm(p - seed)  epsilon]\n        \n        # Remaining points are those not in the new cluster\n        unassigned_points = [p for p in unassigned_points if np.linalg.norm(p - seed) >= epsilon]\n        \n        if current_cluster_points:\n            centroid = np.mean(current_cluster_points, axis=0)\n            centroids.append(centroid)\n            counts.append(len(current_cluster_points))\n            \n    return centroids, counts\n\nsolve()\n```"
        },
        {
            "introduction": "生物医学系统建模的一个最终目标是将其应用于改善疾病治疗，例如设计更优的癌症免疫疗法方案。这通常需要将描述药物在体内动态（药代动力学，PK）的模型与描述药物如何影响生物系统（药效学，PD）的模型相结合。这种PK/PD整合模型是定量系统药理学（QSP）领域的核心。 在这项综合性实践中，您将构建并模拟一个免疫检查点抑制剂的PK/PD模型，并通过搜索不同的给药方案，找到在满足安全性约束（即效应T细胞数量不超过上限 $E_{\\mathrm{upper}}$）的前提下，能够最大化治疗效果（即功能性效应T细胞的恢复水平）的最优给药策略。这个练习充分展示了系统建模在转化医学中的应用潜力。",
            "id": "3893271",
            "problem": "考虑一个检查点抑制剂的单室药代动力学（PK）模型与T细胞耗竭和再活化的药效学（PD）的耦合。从以下基本依据出发：(i) 充分混合隔室中的质量平衡，这意味着药物总量的变化率等于输入减去输出，对于固定体积隔室中的一级消除，浓度呈指数衰减；以及(ii) T细胞在稳态增殖、逻辑限制、死亡、耗竭转化和药物诱导的再活化下的种群动态。您将以纯数学术语形式化该系统，并计算离散给药策略，以在不违反超调安全界限的情况下，最大化功能性效应T细胞的恢复。\n\n模型假设与定义：\n\n- 药代动力学 (PK): 设 $C(t)$ 为检查点抑制剂在单室模型中的血浆浓度，单位为 $\\mathrm{mg/L}$，清除率为 $CL$（单位 $\\mathrm{L/day}$），分布容积为 $V$（单位 $\\mathrm{L}$）。消除速率常数为 $k_e = CL/V$，单位为 $\\mathrm{day^{-1}}$。在 $t_i$ 时刻的推注剂量之间，浓度遵循\n$$\\frac{dC}{dt} = -k_e C,$$\n在 $t_i$ 时刻给予一次量级为 $D$（单位 $\\mathrm{mg}$）的瞬时推注剂量，会使浓度增加 $\\Delta C = D/V$。\n\n- 药效学 (PD): 设 $E(t)$ 表示功能性效应T细胞群体，单位为 $\\mathrm{cells/\\mu L}$；$X(t)$ 表示耗竭T细胞，单位为 $\\mathrm{cells/\\mu L}$。效应细胞以内在速率 $r_E$（单位 $\\mathrm{day^{-1}}$）和承载能力 $K$（单位 $\\mathrm{cells/\\mu L}$）进行逻辑斯谛增殖，以速率 $d_E$（单位 $\\mathrm{day^{-1}}$）死亡，并以基线速率 $k_{\\mathrm{exh}}$（单位 $\\mathrm{day^{-1}}$）转化为耗竭状态，该速率受检查点抑制调节。耗竭细胞以速率 $d_X$（单位 $\\mathrm{day^{-1}}$）死亡，并能以速率 $k_{\\mathrm{rev}}$（单位 $\\mathrm{day^{-1}}$）再活化为效应状态，该速率受检查点抑制调节。药物效应由一个 $E_{\\max}$ 模型表示\n$$I(C) = E_{\\max} \\frac{C}{EC_{50} + C},$$\n其中 $E_{\\max} \\in [0,1]$ 是最大抑制效应，$EC_{50}$（单位 $\\mathrm{mg/L}$）是半最大效应浓度。耗竭转化速率降低为 $k_{\\mathrm{exh}} (1 - I(C))$，再活化速率变为 $k_{\\mathrm{rev}} I(C)$。耦合常微分方程为\n$$\\frac{dE}{dt} = r_E E \\left(1 - \\frac{E+X}{K}\\right) - d_E E - k_{\\mathrm{exh}} (1 - I(C)) E + k_{\\mathrm{rev}} I(C) X,$$\n$$\\frac{dX}{dt} = k_{\\mathrm{exh}} (1 - I(C)) E - d_X X - k_{\\mathrm{rev}} I(C) X.$$\n\n- 初始条件: 在 $t=0$ 时，设 $C(0) = 0$, $E(0) = E_0$, and $X(0) = X_0$。\n\n- 给药方案: 考虑一个离散给药方案，包含 $N$ 次相同的推注剂量，量级为 $D$（单位 $\\mathrm{mg}$），在时间 $t \\in \\{0, \\tau, 2\\tau, \\dots, (N-1)\\tau\\}$ 给予，其中 $\\tau$（单位 $\\mathrm{day}$）是给药间隔。对于此问题，您将在一个有限的候选 $(D, \\tau)$ 方案集合中进行搜索。\n\n- 目标与约束: 对于一个固定的时间范围 $T_h$（单位 $\\mathrm{day}$），将恢复目标定义为效应细胞数超过基线部分的时间积分，\n$$J(D,\\tau) = \\int_{0}^{T_h} \\max(E(t) - E_0, 0)\\, dt.$$\n定义一个超调安全界限 $E_{\\mathrm{upper}}$，单位为 $\\mathrm{cells/\\mu L}$。如果一个方案 $(D,\\tau)$ 满足 $\\max_{t \\in [0,T_h]} E(t) \\le E_{\\mathrm{upper}}$，则该方案是可行的。目标是选择使 $J(D,\\tau)$ 最大化且满足可行性约束的 $(D,\\tau)$。如果多个方案达到相同的最大目标值，优先选择D最小的方案。如果候选集中不存在可行的方案，则返回一个不可行性指标。\n\n算法要求：\n\n- 使用标准的初值问题求解器，实现耦合系统的分段数值积分，并在给药时刻对 $C(t)$ 进行瞬时推注更新。\n- 基于求解器的输出，使用数值积分（求积）方法评估目标 $J(D,\\tau)$。\n- 通过检查轨迹上 $E(t)$ 的最大值来强制执行超调约束。\n- 在每个测试案例中给定的剂量 $D$ 和间隔 $\\tau$ 的有限候选集中进行搜索。\n\n物理和数值单位：\n\n- 剂量 $D$ 以 $\\mathrm{mg}$ 表示，给药间隔 $\\tau$ 以 $\\mathrm{day}$ 表示，浓度 $C$ 以 $\\mathrm{mg/L}$ 表示，时间以 $\\mathrm{day}$ 表示，T细胞计数以 $\\mathrm{cells/\\mu L}$ 表示。\n\n角度单位不适用。如果任何量必须表示为分数，请使用小数形式。\n\n测试套件与参数值：\n\n对于每个测试案例 $i$，所有参数均已提供，并且对于免疫检查点抑制剂疗法和T细胞动态具有科学合理性。您的程序必须处理以下四个测试案例：\n\n- 案例1（中等清除率，中等效力，典型动态，理想路径）：\n    - $CL = 0.3$ $\\mathrm{L/day}$, $V = 3.0$ $\\mathrm{L}$, $EC_{50} = 0.5$ $\\mathrm{mg/L}$, $E_{\\max} = 0.8$,\n    - $K = 1000.0$ $\\mathrm{cells/\\mu L}$, $r_E = 0.05$ $\\mathrm{day^{-1}}$, $d_E = 0.02$ $\\mathrm{day^{-1}}$, $d_X = 0.03$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{exh}} = 0.04$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{rev}} = 0.06$ $\\mathrm{day^{-1}}$,\n    - $E_0 = 200.0$ $\\mathrm{cells/\\mu L}$, $X_0 = 300.0$ $\\mathrm{cells/\\mu L}$,\n    - $E_{\\mathrm{upper}} = 800.0$ $\\mathrm{cells/\\mu L}$, $T_h = 30.0$ $\\mathrm{day}$, $N = 3$ 剂,\n    - 候选 $D \\in \\{0, 50, 100, 150, 200\\}$ $\\mathrm{mg}$, 候选 $\\tau \\in \\{7, 14\\}$ $\\mathrm{day}$.\n\n- 案例2（高清除率，更严格的安全界限，测试对更短间隔的需求）：\n    - $CL = 0.9$ $\\mathrm{L/day}$, $V = 3.0$ $\\mathrm{L}$, $EC_{50} = 0.5$ $\\mathrm{mg/L}$, $E_{\\max} = 0.8$,\n    - $K = 1000.0$ $\\mathrm{cells/\\mu L}$, $r_E = 0.05$ $\\mathrm{day^{-1}}$, $d_E = 0.02$ $\\mathrm{day^{-1}}$, $d_X = 0.03$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{exh}} = 0.04$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{rev}} = 0.06$ $\\mathrm{day^{-1}}$,\n    - $E_0 = 200.0$ $\\mathrm{cells/\\mu L}$, $X_0 = 300.0$ $\\mathrm{cells/\\mu L}$,\n    - $E_{\\mathrm{upper}} = 750.0$ $\\mathrm{cells/\\mu L}$, $T_h = 30.0$ $\\mathrm{day}$, $N = 3$ 剂,\n    - 候选 $D \\in \\{0, 50, 100, 150, 200\\}$ $\\mathrm{mg}$, 候选 $\\tau \\in \\{7, 14\\}$ $\\mathrm{day}$.\n\n- 案例3（高效力，有超调风险）：\n    - $CL = 0.3$ $\\mathrm{L/day}$, $V = 3.0$ $\\mathrm{L}$, $EC_{50} = 0.1$ $\\mathrm{mg/L}$, $E_{\\max} = 1.0$,\n    - $K = 1000.0$ $\\mathrm{cells/\\mu L}$, $r_E = 0.05$ $\\mathrm{day^{-1}}$, $d_E = 0.02$ $\\mathrm{day^{-1}}$, $d_X = 0.03$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{exh}} = 0.04$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{rev}} = 0.06$ $\\mathrm{day^{-1}}$,\n    - $E_0 = 200.0$ $\\mathrm{cells/\\mu L}$, $X_0 = 300.0$ $\\mathrm{cells/\\mu L}$,\n    - $E_{\\mathrm{upper}} = 700.0$ $\\mathrm{cells/\\mu L}$, $T_h = 30.0$ $\\mathrm{day}$, $N = 3$ 剂,\n    - 候选 $D \\in \\{0, 50, 100, 150, 200\\}$ $\\mathrm{mg}$, 候选 $\\tau \\in \\{7, 14\\}$ $\\mathrm{day}$.\n\n- 案例4（低再活化效力，测试对最小剂量的偏好）：\n    - $CL = 0.3$ $\\mathrm{L/day}$, $V = 3.0$ $\\mathrm{L}$, $EC_{50} = 0.5$ $\\mathrm{mg/L}$, $E_{\\max} = 0.8$,\n    - $K = 1000.0$ $\\mathrm{cells/\\mu L}$, $r_E = 0.05$ $\\mathrm{day^{-1}}$, $d_E = 0.02$ $\\mathrm{day^{-1}}$, $d_X = 0.03$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{exh}} = 0.04$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{rev}} = 0.0$ $\\mathrm{day^{-1}}$,\n    - $E_0 = 200.0$ $\\mathrm{cells/\\mu L}$, $X_0 = 300.0$ $\\mathrm{cells/\\mu L}$,\n    - $E_{\\mathrm{upper}} = 900.0$ $\\mathrm{cells/\\mu L}$, $T_h = 30.0$ $\\mathrm{day}$, $N = 3$ 剂,\n    - 候选 $D \\in \\{0, 50, 100, 150, 200\\}$ $\\mathrm{mg}$, 候选 $\\tau \\in \\{7, 14\\}$ $\\mathrm{day}$.\n\n最终输出格式要求：\n\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来。此列表中的每个元素对应一个测试案例，并且本身必须是包含两个整数的列表 $[D_{\\mathrm{best}}, \\tau_{\\mathrm{best}}]$，报告该案例的最佳剂量大小（单位 $\\mathrm{mg}$）和最佳给药间隔（单位 $\\mathrm{day}$）。如果候选集中不存在可行的方案，则为该案例输出列表 $[-1, -1]$。例如，输出格式必须如下所示：\n$$[[D_1,\\tau_1],[D_2,\\tau_2],[D_3,\\tau_3],[D_4,\\tau_4]].$$",
            "solution": "用户希望为一个用于模拟T细胞对检查点抑制剂疗法响应的药代动力学/药效学（PK/PD）模型求解一个优化问题。解决方案需要对一个常微分方程（ODE）系统进行数值模拟，并在一个离散的给药策略集合中进行搜索。\n\n### 步骤1：提取给定信息\n问题提供了一个耦合的PK/PD模型，该模型由一个包含三个ODE的系统定义，分别描述药物浓度 $C(t)$、功能性效应T细胞群体 $E(t)$ 和耗竭T细胞群体 $X(t)$。\n\n**药代动力学 (PK):**\n- 状态变量: $C(t)$ [$\\mathrm{mg/L}$]\n- 模型: 具有一级消除的单室模型。\n- ODE (剂量之间): $\\frac{dC}{dt} = -k_e C$\n- 消除速率常数: $k_e = CL/V$ [$\\mathrm{day^{-1}}$]\n- 参数: 清除率 $CL$ [$\\mathrm{L/day}$], 分布容积 $V$ [$\\mathrm{L}$]\n- 给药: 在时刻 $t_i$ 的瞬时推注剂量 $D$ [$\\mathrm{mg}$] 导致浓度变化 $\\Delta C = D/V$。\n\n**药效学 (PD):**\n- 状态变量: $E(t)$ [$\\mathrm{cells/\\mu L}$], $X(t)$ [$\\mathrm{cells/\\mu L}$]\n- 药物效应模型: $I(C) = E_{\\max} \\frac{C}{EC_{50} + C}$\n- 参数: 最大效应 $E_{\\max}$ (无量纲), 半最大效应浓度 $EC_{50}$ [$\\mathrm{mg/L}$]\n- 耦合ODE:\n$$ \\frac{dE}{dt} = r_E E \\left(1 - \\frac{E+X}{K}\\right) - d_E E - k_{\\mathrm{exh}} (1 - I(C)) E + k_{\\mathrm{rev}} I(C) X $$\n$$ \\frac{dX}{dt} = k_{\\mathrm{exh}} (1 - I(C)) E - d_X X - k_{\\mathrm{rev}} I(C) X $$\n- 参数:\n    - $r_E$: 效应细胞的内在增殖速率 [$\\mathrm{day^{-1}}$]\n    - $K$: 承载能力 [$\\mathrm{cells/\\mu L}$]\n    - $d_E$: 效应细胞的死亡速率 [$\\mathrm{day^{-1}}$]\n    - $d_X$: 耗竭细胞的死亡速率 [$\\mathrm{day^{-1}}$]\n    - $k_{\\mathrm{exh}}$: 基线耗竭转化速率 [$\\mathrm{day^{-1}}$]\n    - $k_{\\mathrm{rev}}$: 基线再活化速率 [$\\mathrm{day^{-1}}$]\n\n**模拟设置:**\n- $t=0$ 时的初始条件: $C(0) = 0$, $E(0) = E_0$, $X(0) = X_0$。\n- 给药方案: 在时间 $t \\in \\{0, \\tau, 2\\tau, \\dots, (N-1)\\tau\\}$ 给予 $N$ 次量级为 $D$ [$\\mathrm{mg}$] 的相同推注剂量。\n- 时间范围: $T_h$ [$\\mathrm{day}$]。\n\n**优化问题:**\n- 目标函数: 最大化恢复量 $J(D,\\tau) = \\int_{0}^{T_h} \\max(E(t) - E_0, 0)\\, dt$。\n- 约束: 可行性要求 $\\max_{t \\in [0,T_h]} E(t) \\le E_{\\mathrm{upper}}$。\n- 搜索空间: 每个测试案例的 $(D, \\tau)$ 对的有限候选集。\n- 决胜规则: 如果多个方案产生相同的最大 $J$，优先选择 $D$ 最小的方案。\n- 不可行性: 如果不存在可行的方案，返回 $[-1, -1]$。\n\n**测试案例:** 问题提供了四个不同的测试案例，每个案例都有一整套参数值和候选方案。\n\n### 步骤2：使用提取的给定信息进行验证\n- **科学依据:** 该模型是定量系统药理学中一个标准且广为接受的公式。它将一个单室PK模型与一个免疫细胞的种群动态模型相结合，使用了诸如一级消除、逻辑斯谛增长和用于药物效应的 $E_{\\max}$ 模型等已建立的形式。所有组成部分都基于质量平衡和种群动态的基本原理。该模型就其预期目的而言是科学合理的。\n- **适定性:** ODE系统的右侧函数是光滑的（解析的），这保证了给定初始条件下解的存在性和唯一性。优化任务是在一个有限的离散候选方案集上进行搜索。对于每个候选方案，目标函数和约束都是明确定义的。因此，可以保证在候选集内存在一个最优解，或者可以证明不存在可行的解。该问题是适定的。\n- **客观性:** 问题使用精确的数学符号和明确的技术语言进行描述。所有参数、变量和目标都已清晰定义。它不含主观或基于意见的主张。\n- **完整性与一致性:** 为每个测试案例提供了所有必要的参数（$CL$、$V$、$E_{\\max}$、$EC_{50}$、T细胞动态速率、初始条件、$N$、$T_h$、$E_{\\mathrm{upper}}$）和候选方案。单位在整个模型定义中保持一致。\n- **其他缺陷:** 该问题没有表现出任何其他缺陷，例如不切实际（在数学建模的背景下）、结构不良、过于简单或无法验证。\n\n### 步骤3：结论与行动\n该问题是**有效的**。它是一个在生物医学系统建模领域中定义明确的计算问题。我将着手制定并实施解决方案。\n\n### 基于原则的设计\n该解决方案围绕核心任务设计：为每个候选给药方案模拟系统轨迹，然后根据指定的目标和约束评估其性能。\n\n1.  **系统表示**: 系统的状态由一个向量 $\\mathbf{y}(t) = [C(t), E(t), X(t)]^T$ 表示。动态由所提供的包含三个耦合ODE的系统控制。ODE的参数对每个测试案例都是特定的。\n\n2.  **分段数值积分**: 给药方案涉及在离散时间点 $t_k = k \\tau$ 对状态变量 $C(t)$ 进行瞬时改变（跳跃）。这需要一个分段积分策略。模拟范围 $[0, T_h]$ 被分解为多个段，其端点由给药时间和最终时间 $T_h$ 定义。\n    - 模拟按顺序从一个段进行到下一个段。\n    - 在每个从给药时间 $t_k$ 开始的段的开头，浓度会瞬时增加：$C(t_k^+) = C(t_k^-) + D/V$。\n    - 使用一个数值ODE求解器，特别是`scipy`库中的`scipy.integrate.solve_ivp`，来对每个连续段上的系统进行积分。该函数适用于初值问题，并采用自适应步长来确保准确性和效率。\n    - 将每个段的解连接起来，形成在整个时间范围 $[0, T_h]$ 上的完整轨迹。\n\n3.  **方案评估**: 在为一个给定的方案 $(D, \\tau)$ 模拟出完整轨迹后：\n    - **约束检查**: 通过找到计算出的 $E(t)$ 轨迹的最大值来检查约束 $\\max_{t \\in [0,T_h]} E(t) \\le E_{\\mathrm{upper}}$。如果违反约束，则该方案被视为不可行。\n    - **目标计算**: 如果方案可行，则计算目标函数 $J(D,\\tau) = \\int_{0}^{T_h} \\max(E(t) - E_0, 0)\\, dt$。这通过数值积分实现。梯形法则（由`numpy.trapz`实现）应用于在数值解的时间点 $t_j$ 上评估的函数值 $\\max(E(t_j) - E_0, 0)$。\n\n4.  **通过搜索进行优化**: 通过在每个测试案例提供的有限离散候选对 $(D, \\tau)$ 集合上进行穷举搜索来找到最优方案。\n    - 对于每个案例，我们初始化一个“最佳”方案跟踪器，其状态表示尚未找到可行的解决方案（例如，目标 $J = -1.0$，方案 $[-1, -1]$）。\n    - 我们遍历所有候选方案。对每一个方案，我们执行模拟和评估步骤。\n    - 如果一个方案是可行的，其目标值 $J$ 将与迄今为止找到的最佳值进行比较。如果新方案的 $J$ 严格更高，或者 $J$ 相等但剂量 $D$ 更小（根据问题的决胜规则），则更新“最佳”方案。\n    - 检查完所有候选方案后，最终存储的“最佳”方案即为该测试案例的解。\n\n这种结构化方法确保每个候选方案都根据模型的动态和问题的标准得到严格评估，从而找到最优策略。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the PK/PD optimization problem for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"CL\": 0.3, \"V\": 3.0, \"EC50\": 0.5, \"Emax\": 0.8,\n            \"K\": 1000.0, \"rE\": 0.05, \"dE\": 0.02, \"dX\": 0.03, \"k_exh\": 0.04, \"k_rev\": 0.06,\n            \"E0\": 200.0, \"X0\": 300.0,\n            \"Eupper\": 800.0, \"Th\": 30.0, \"N\": 3,\n            \"candidate_D\": [0, 50, 100, 150, 200], \"candidate_tau\": [7, 14],\n        },\n        {\n            \"CL\": 0.9, \"V\": 3.0, \"EC50\": 0.5, \"Emax\": 0.8,\n            \"K\": 1000.0, \"rE\": 0.05, \"dE\": 0.02, \"dX\": 0.03, \"k_exh\": 0.04, \"k_rev\": 0.06,\n            \"E0\": 200.0, \"X0\": 300.0,\n            \"Eupper\": 750.0, \"Th\": 30.0, \"N\": 3,\n            \"candidate_D\": [0, 50, 100, 150, 200], \"candidate_tau\": [7, 14],\n        },\n        {\n            \"CL\": 0.3, \"V\": 3.0, \"EC50\": 0.1, \"Emax\": 1.0,\n            \"K\": 1000.0, \"rE\": 0.05, \"dE\": 0.02, \"dX\": 0.03, \"k_exh\": 0.04, \"k_rev\": 0.06,\n            \"E0\": 200.0, \"X0\": 300.0,\n            \"Eupper\": 700.0, \"Th\": 30.0, \"N\": 3,\n            \"candidate_D\": [0, 50, 100, 150, 200], \"candidate_tau\": [7, 14],    \n        },\n        {\n            \"CL\": 0.3, \"V\": 3.0, \"EC50\": 0.5, \"Emax\": 0.8,\n            \"K\": 1000.0, \"rE\": 0.05, \"dE\": 0.02, \"dX\": 0.03, \"k_exh\": 0.04, \"k_rev\": 0.0,\n            \"E0\": 200.0, \"X0\": 300.0,\n            \"Eupper\": 900.0, \"Th\": 30.0, \"N\": 3,\n            \"candidate_D\": [0, 50, 100, 150, 200], \"candidate_tau\": [7, 14],\n        }\n    ]\n\n    final_results = []\n\n    for params in test_cases:\n        p = params # Use a shorthand for easier access\n        \n        # Define the ODE system as a nested function to capture parameters\n        def ode_system(t, y, k_e, EC50, Emax, K, rE, dE, dX, k_exh, k_rev):\n            C, E, X = y\n            \n            # Avoid division by zero or negative values for E and X\n            E = max(E, 0)\n            X = max(X, 0)\n\n            # Drug effect\n            I_C = Emax * C / (EC50 + C)\n            \n            # ODEs\n            dCdt = -k_e * C\n            dEdt = rE * E * (1 - (E + X) / K) - dE * E - k_exh * (1 - I_C) * E + k_rev * I_C * X\n            dXdt = k_exh * (1 - I_C) * E - dX * X - k_rev * I_C * X\n            \n            return [dCdt, dEdt, dXdt]\n\n        best_J = -1.0\n        best_schedule = [-1, -1]\n\n        k_e = p['CL'] / p['V']\n        ode_args = (k_e, p['EC50'], p['Emax'], p['K'], p['rE'], p['dE'], p['dX'], p['k_exh'], p['k_rev'])\n        \n        for tau in p['candidate_tau']:\n            for D in p['candidate_D']:\n                \n                # --- Piecewise Simulation ---\n                y0 = np.array([0.0, p['E0'], p['X0']])\n                t_current = 0.0\n                y_current = y0.copy()\n                \n                dose_times = {i * tau for i in range(p['N'])}\n                # Define integration stop points: dosing times and final horizon time\n                time_stops = sorted(list(dose_times | {0, p['Th']}))\n                \n                ts_pieces, ys_pieces = [], []\n                \n                for t_stop in time_stops:\n                    if t_stop = t_current:\n                        continue\n                        \n                    # Apply dose at the beginning of the interval\n                    if t_current in dose_times:\n                        y_current[0] += D / p['V']\n\n                    # Integrate over the segment\n                    sol = solve_ivp(\n                        fun=ode_system, \n                        t_span=[t_current, t_stop], \n                        y0=y_current,\n                        args=ode_args,\n                        rtol=1e-6, atol=1e-6, # Standard tolerances for accuracy\n                        method='RK45'\n                    )\n                    \n                    ts_pieces.append(sol.t)\n                    ys_pieces.append(sol.y)\n                    \n                    y_current = sol.y[:, -1]\n                    t_current = t_stop\n                \n                # Stitch the solution pieces together, removing duplicate time points\n                if not ts_pieces: \n                    # This case happens if Th=0, not applicable here, but good practice\n                    t_traj, y_traj = np.array([0.0]), np.array([y0]).T\n                else:\n                    t_traj = np.concatenate([pc if i == 0 else pc[1:] for i, pc in enumerate(ts_pieces)])\n                    y_traj = np.concatenate([pc if i == 0 else pc[:, 1:] for i, pc in enumerate(ys_pieces)], axis=1)\n\n                E_traj = y_traj[1, :]\n\n                # --- Evaluation and Optimization ---\n                # Check overshoot constraint\n                max_E = np.max(E_traj)\n                is_admissible = max_E = p['Eupper']\n\n                if is_admissible:\n                    # Calculate objective function J\n                    integrand = np.maximum(E_traj - p['E0'], 0)\n                    J = np.trapz(integrand, t_traj)\n                    \n                    # Update best schedule based on maximization and tie-breaking rule\n                    # The first admissible schedule will always satisfy J > best_J (since best_J starts at -1)\n                    if J > best_J or (np.isclose(J, best_J) and D  best_schedule[0]):\n                        best_J = J\n                        best_schedule = [int(D), int(tau)]\n        \n        final_results.append(best_schedule)\n        \n    print(f\"{final_results}\")\n\nsolve()\n```"
        }
    ]
}