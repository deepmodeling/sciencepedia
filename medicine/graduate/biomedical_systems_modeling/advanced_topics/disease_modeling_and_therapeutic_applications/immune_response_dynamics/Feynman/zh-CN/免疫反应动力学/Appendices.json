{
    "hands_on_practices": [
        {
            "introduction": "对免疫反应进行建模的核心目标之一是预测其结果：病原体是被清除，还是会建立持续性感染？本练习将指导你使用动态系统的基本工具——稳态和局部稳定性分析——来解决这个问题。通过分析一个描述吞噬细胞与细菌相互作用的简化模型 ，你将推导出一个决定感染结果的关键条件，从而将抽象的数学概念与具体的生物学结果联系起来。",
            "id": "3893282",
            "problem": "考虑一个局部组织部位的急性细菌感染，该感染通过细菌和活化的吞噬细胞之间的相互作用进行建模。设 $B(t)$ 表示细菌载量，$P(t)$ 表示该部位活化吞噬细胞的密度。以下模型反映了核心的生物物理和生理学原理：吞噬细胞对细菌的质量作用杀伤、受承载能力限制的细菌内在增长、来自循环系统的基线吞噬细胞流入、细菌触发的招募、线性吞噬细胞损失，以及在基线附近，由细胞因子驱动的、吞噬细胞招募的局部线性化自催化放大作用：\n$$\n\\frac{dB}{dt} \\;=\\; \\gamma\\,B\\left(1-\\frac{B}{K}\\right) \\;-\\; \\kappa\\,P\\,B,\n$$\n$$\n\\frac{dP}{dt} \\;=\\; \\lambda \\;+\\; \\rho\\,B \\;-\\; \\delta\\,P \\;+\\; \\sigma\\,P,\n$$\n其中所有参数均为非负值：$\\gamma$ 是最大细菌人均增长率，$K$ 是细菌承载能力，$\\kappa$ 是吞噬细胞介导的杀伤速率常数，$\\lambda$ 是基线吞噬细胞流入量，$\\rho$ 是细菌触发的招募系数，$\\delta$ 是吞噬细胞损失率，$\\sigma$ 是描述在基线附近由细胞因子介导的吞噬细胞招募自催化放大的局部线性化系数。假设初始感染满足 $B(0)\\ll K$，因此无菌状态的局部稳定性决定了早期清除与入侵。\n\n从动力系统的局部（线性）稳定性的基本定义出发，分析无菌平衡点，并以闭式形式推导出最小基线招募率 $\\lambda^{\\dagger}$，该速率既能确保局部细菌清除，同时又能避免失控性炎症。就本问题而言，将“失控性炎症”解释为当 $B=0$ 时纯吞噬细胞子系统失去稳定性（即在没有细菌时吞噬细胞的净增长），并将“细菌清除”解释为无菌平衡点的局部渐近稳定性。\n\n给出用模型参数表示的 $\\lambda^{\\dagger}$ 的闭式表达式作为你的最终答案。以与 $\\lambda$ 相同的单位报告 $\\lambda^{\\dagger}$（例如，如果 $\\lambda$ 的单位是细胞/秒，则 $\\lambda^{\\dagger}$ 的单位也是细胞/秒）。不要报告任何不等式；只报告 $\\lambda^{\\dagger}$ 的单一表达式。无需四舍五入。",
            "solution": "用户希望找到最小的基线吞噬细胞招募率，记为 $\\lambda^{\\dagger}$，该速率能确保给定的微分方程组满足两个条件：\n$$\n\\frac{dB}{dt} \\;=\\; \\gamma\\,B\\left(1-\\frac{B}{K}\\right) \\;-\\; \\kappa\\,P\\,B\n$$\n$$\n\\frac{dP}{dt} \\;=\\; \\lambda \\;+\\; \\rho\\,B \\;-\\; \\delta\\,P \\;+\\; \\sigma\\,P\n$$\n这两个条件是：\n1.  **避免失控性炎症**：这被定义为当 $B=0$ 时纯吞噬细胞子系统的稳定性。\n2.  **局部细菌清除**：这被定义为无菌平衡点的局部渐近稳定性。\n\n首先，我们分析“避免失控性炎症”的条件。这涉及到在没有细菌的情况下（即 $B(t)=0$ 时）吞噬细胞的动力学。吞噬细胞密度 $P(t)$ 的方程变为：\n$$\n\\frac{dP}{dt} = \\lambda - \\delta P + \\sigma P = \\lambda - (\\delta - \\sigma)P\n$$\n这是一个一维线性常微分方程。如果 $\\delta \\neq \\sigma$，则在 $P_0^* = \\frac{\\lambda}{\\delta - \\sigma}$ 处存在一个平衡点。该平衡点的稳定性由 $P$ 项的系数决定。设 $f(P) = \\lambda - (\\delta - \\sigma)P$。如果 $\\frac{df}{dP}  0$，系统是稳定的。这里，$\\frac{df}{dP} = -(\\delta - \\sigma)$。\n为保证稳定性，我们需要 $-(\\delta - \\sigma)  0$，这可以简化为 $\\delta - \\sigma > 0$，即 $\\delta > \\sigma$。如果这个条件不满足（即 $\\delta \\le \\sigma$），吞噬细胞种群 $P(t)$ 将会无限增长，这对应于问题中描述的“失控性炎症”。因此，为避免失控性炎症，系统参数必须满足不等式 $\\delta > \\sigma$。由于 $\\lambda$ 是非负的，这个条件也确保了平衡吞噬细胞水平 $P_0^*$ 是正的。\n\n接下来，我们分析“局部细菌清除”的条件，这要求完整系统的无菌平衡点是局部渐近稳定的。平衡点 $(B^*, P^*)$ 是 $\\frac{dB}{dt}=0$ 和 $\\frac{dP}{dt}=0$ 的解。无菌平衡点对应于 $B^*=0$。\n将 $B^*=0$ 代入方程组得到：\n$$\n\\gamma(0)\\left(1-\\frac{0}{K}\\right) - \\kappa P^* (0) = 0\n$$\n$$\n\\lambda + \\rho(0) - \\delta P^* + \\sigma P^* = 0\n$$\n第一个方程自然满足 ($0=0$)。第二个方程给出：\n$$\n\\lambda - (\\delta - \\sigma)P^* = 0 \\implies P^* = \\frac{\\lambda}{\\delta - \\sigma}\n$$\n因此，无菌平衡点是 $E_0 = (B^*, P^*) = \\left(0, \\frac{\\lambda}{\\delta - \\sigma}\\right)$。如前所述，为了使这个平衡点具有物理意义并且纯吞噬细胞子系统是稳定的，我们必须有 $\\delta > \\sigma$。\n\n为了确定 $E_0$ 的局部稳定性，我们计算系统在该点的雅可比矩阵 $J$。雅可比矩阵的一般形式是：\n$$\nJ(B, P) = \\begin{pmatrix} \\frac{\\partial}{\\partial B}\\frac{dB}{dt}  \\frac{\\partial}{\\partial P}\\frac{dB}{dt} \\\\ \\frac{\\partial}{\\partial B}\\frac{dP}{dt}  \\frac{\\partial}{\\partial P}\\frac{dP}{dt} \\end{pmatrix}\n$$\n分量函数是 $F_1(B, P) = \\gamma B - \\frac{\\gamma}{K}B^2 - \\kappa PB$ 和 $F_2(B, P) = \\lambda + \\rho B - (\\delta-\\sigma)P$。偏导数是：\n$$\n\\frac{\\partial F_1}{\\partial B} = \\gamma - \\frac{2\\gamma}{K}B - \\kappa P\n$$\n$$\n\\frac{\\partial F_1}{\\partial P} = -\\kappa B\n$$\n$$\n\\frac{\\partial F_2}{\\partial B} = \\rho\n$$\n$$\n\\frac{\\partial F_2}{\\partial P} = -(\\delta - \\sigma)\n$$\n现在，我们在无菌平衡点 $E_0 = \\left(0, \\frac{\\lambda}{\\delta - \\sigma}\\right)$ 处计算雅可比矩阵：\n$$\nJ(E_0) = \\begin{pmatrix} \\gamma - \\frac{2\\gamma}{K}(0) - \\kappa \\left(\\frac{\\lambda}{\\delta - \\sigma}\\right)  -\\kappa (0) \\\\ \\rho  -(\\delta - \\sigma) \\end{pmatrix} = \\begin{pmatrix} \\gamma - \\frac{\\kappa \\lambda}{\\delta - \\sigma}  0 \\\\ \\rho  -(\\delta - \\sigma) \\end{pmatrix}\n$$\n三角矩阵的特征值 $\\mu$ 是其对角线元素。因此，$J(E_0)$ 的特征值是：\n$$\n\\mu_1 = \\gamma - \\frac{\\kappa \\lambda}{\\delta - \\sigma}\n$$\n$$\n\\mu_2 = -(\\delta - \\sigma)\n$$\n要使平衡点 $E_0$ 局部渐近稳定，所有特征值的实部都必须为负。由于所有参数都是实数，这意味着两个特征值都必须是负数。\n1.  $\\mu_2  0 \\implies -(\\delta - \\sigma)  0 \\implies \\delta > \\sigma$。这与我们为避免失控性炎症而找到的条件相同。这是系统能够实现细菌清除所必需的一个结构性属性。\n2.  $\\mu_1  0 \\implies \\gamma - \\frac{\\kappa \\lambda}{\\delta - \\sigma}  0$。\n\n这第二个条件确保了微小的细菌扰动将会衰减，从而导致清除。我们可以对这个不等式求解 $\\lambda$：\n$$\n\\gamma  \\frac{\\kappa \\lambda}{\\delta - \\sigma}\n$$\n由于我们必须有 $\\delta > \\sigma$，所以项 $\\delta - \\sigma$ 是正的。参数 $\\kappa$ 和 $\\lambda$ 是非负的。对于一个非平凡系统，$\\kappa>0$。我们可以用 $\\frac{\\delta - \\sigma}{\\kappa}$ 乘以不等式两边而不改变不等号的方向：\n$$\n\\frac{\\gamma(\\delta - \\sigma)}{\\kappa}  \\lambda\n$$\n这个不等式定义了在避免失控性炎症（$\\delta > \\sigma$）的前提下，保证局部细菌清除对基线招募率 $\\lambda$ 的条件。问题要求的是确保清除的最小基线招募率 $\\lambda^{\\dagger}$。这对应于稳定区域边界上的阈值。因此，$\\lambda^{\\dagger}$ 是使该不等式成为等式时的 $\\lambda$ 值。\n$$\n\\lambda^{\\dagger} = \\frac{\\gamma(\\delta - \\sigma)}{\\kappa}\n$$\n对于任何 $\\lambda > \\lambda^{\\dagger}$，无菌平衡点都是稳定的，从而导致清除。在 $\\lambda = \\lambda^{\\dagger}$ 时，会发生一个跨临界分岔，无菌状态的稳定性在此丧失。因此，$\\lambda^{\\dagger}$ 代表了所需的最小速率。",
            "answer": "$$\\boxed{\\frac{\\gamma(\\delta - \\sigma)}{\\kappa}}$$"
        },
        {
            "introduction": "免疫系统的行为并非总是趋向于单一的确定性结果。在许多情况下，系统可以存在于多个稳定状态之间，例如免疫激活或免疫耐受，这种现象称为“双稳态”。本计算练习  探讨了一个调节性T细胞和效应T细胞之间相互抑制的模型，这是一种经典的“拨动开关”网络基序。你将通过数值模拟和分岔分析，探索系统如何根据初始条件和外部刺激（如抗原）在不同功能状态之间做出选择。",
            "id": "3893263",
            "problem": "考虑一个捕获免疫耐受与激活的调节性T细胞（Treg）和常规效应T细胞的最小动态系统模型。令$E(t)$表示效应T细胞的无量纲激活水平，$R(t)$表示调节性T细胞（Treg）的无量纲丰度。该系统根据耦合常微分方程（ODEs）演化，其中产生过程被对手种群抑制，并存在线性清除：\n$$\n\\frac{dE}{dt} \\;=\\; \\frac{\\alpha_E}{1 + \\left(\\frac{R}{K_R}\\right)^{n}} \\;-\\; \\delta_E E,\\quad\n\\frac{dR}{dt} \\;=\\; \\frac{\\alpha_R}{1 + \\left(\\frac{E}{K_E}\\right)^{m}} \\;-\\; \\delta_R R.\n$$\n抗原驱动被建模为通过参数$A$对效应细胞产生速率$\\alpha_E$的加性增加，即$\\alpha_E = \\alpha_{E0} + \\theta A$，其中$\\alpha_{E0}$是基线效应细胞产生速率，$\\theta$是抗原与效应细胞产生的耦合强度。量$E$和$R$以及时间$t$都是无量纲的，并且所有参数都严格为正。调节性T细胞（Treg）通过系数为$n$、半饱和常数为$K_R$的Hill型项抑制效应细胞的产生，而效应T细胞通过Hill系数为$m$、半饱和常数为$K_E$的项抑制Treg的产生。清除率分别为$\\delta_E$和$\\delta_R$。\n\n该系统的基础建模原则是：\n- 产生过程受到饱和抑制的限制，这与受体介导的调节和细胞因子反馈一致。\n- 清除过程相对于种群水平是线性的，反映了一阶损失。\n- 抗原驱动是一个外部参数输入，它调节效应细胞的产生，但不直接改变Treg的产生。\n\n您的任务是针对抗原驱动$A$进行计算分岔分析，以识别表现出双稳态的区域，并刻画耐受与激活状态的吸引盆。使用从有界域中的初始条件网格进行的数值前向积分来近似吸引子及其吸引盆。\n\n分类定义：\n- 耐受吸引子是任何满足$R^\\star \\ge E^\\star$的数值近似稳态$(E^\\star, R^\\star)$。\n- 激活吸引子是任何满足$E^\\star  R^\\star$的数值近似稳态$(E^\\star, R^\\star)$。\n\n对于下文测试套件中的每个参数集，您必须：\n1. 对于集合中指定的每个$A$值，在指定域上从一个均匀的初始条件网格$(E(0), R(0))$开始积分ODE，积分足够长的时间以达到稳态行为。使用固定的距离阈值$\\varepsilon$对终点进行聚类，以识别不同的吸引子。对于每个$A$，计算不同吸引子的数量。将该集合中所有$A$值对应的不同吸引子数量的最大值报告为一个整数。\n2. 对于集合中指定的$A^\\star$，通过计算其轨迹分别收敛到耐受与激活吸引子的初始条件的比例，来估计耐受和激活的吸引盆分数。吸引盆分数以$[0,1]$区间内的小数表示。\n\n科学和计算约束：\n- 所有变量和参数都是无量纲的；不需要物理单位。\n- 初始条件网格必须在$E(0) \\in [0, E_{\\max}]$和$R(0) \\in [0, R_{\\max}]$上均匀分布，使用每个轴上指定的网格点数。\n- 积分必须执行到固定的最终时间$T_{\\text{end}}$。\n- 聚类必须使用$(E,R)$平面中指定的欧几里得阈值$\\varepsilon$将终点分组为吸引子。\n\n参数集测试套件（每个案例都是一个要在程序中硬编码的类元组规范）：\n- 案例1（偏向耐受的基线）：\n  - $\\alpha_{E0} = 0.2$, $\\alpha_{R} = 1.4$, $\\theta = 0.6$, $\\delta_{E} = 1.0$, $\\delta_{R} = 1.0$, $K_{E} = 0.5$, $K_{R} = 0.5$, $m = 4$, $n = 4$。\n  - $A \\in \\{0.0, 0.2, 0.4, 0.6\\}$, $A^\\star = 0.4$。\n  - $E_{\\max} = 2.0$, $R_{\\max} = 2.0$, 每个轴的网格点数 $= 5$, $T_{\\text{end}} = 200.0$, $\\varepsilon = 10^{-3}$。\n- 案例2（偏向激活的基线）：\n  - $\\alpha_{E0} = 1.2$, $\\alpha_{R} = 0.5$, $\\theta = 0.6$, $\\delta_{E} = 1.0$, $\\delta_{R} = 1.0$, $K_{E} = 0.5$, $K_{R} = 0.5$, $m = 4$, $n = 4$。\n  - $A \\in \\{0.0, 0.5, 1.0\\}$, $A^\\star = 1.0$。\n  - $E_{\\max} = 2.0$, $R_{\\max} = 2.0$, 每个轴的网格点数 $= 5$, $T_{\\text{end}} = 200.0$, $\\varepsilon = 10^{-3}$。\n- 案例3（中间区域，可能存在双稳态）：\n  - $\\alpha_{E0} = 0.7$, $\\alpha_{R} = 1.0$, $\\theta = 0.9$, $\\delta_{E} = 1.0$, $\\delta_{R} = 1.0$, $K_{E} = 0.5$, $K_{R} = 0.5$, $m = 4$, $n = 4$。\n  - $A \\in \\{0.0, 0.3, 0.6, 0.9, 1.2\\}$, $A^\\star = 0.6$。\n  - $E_{\\max} = 2.0$, $R_{\\max} = 2.0$, 每个轴的网格点数 $= 5$, $T_{\\text{end}} = 200.0$, $\\varepsilon = 10^{-3}$。\n- 案例4（近平衡边界区域）：\n  - $\\alpha_{E0} = 0.9$, $\\alpha_{R} = 0.9$, $\\theta = 0.4$, $\\delta_{E} = 1.0$, $\\delta_{R} = 1.0$, $K_{E} = 0.5$, $K_{R} = 0.5$, $m = 4$, $n = 4$。\n  - $A \\in \\{0.0, 0.4, 0.8\\}$, $A^\\star = 0.4$。\n  - $E_{\\max} = 2.0$, $R_{\\max} = 2.0$, 每个轴的网格点数 $= 5$, $T_{\\text{end}} = 200.0$, $\\varepsilon = 10^{-3}$。\n\n算法要求：\n- 对每个初始条件和每个$A$值，使用数值ODE积分到$t = T_{\\text{end}}$。\n- 使用阈值为$\\varepsilon$的欧几里得聚类将终点合并为不同的吸引子。\n- 通过比较$R^\\star$和$E^\\star$将每个吸引子分类为耐受或激活。\n- 对于每个案例，计算：\n  - 在所提供的$A$值中不同吸引子的最大数量（一个整数）。\n  - 一个布尔值，指示在$A^\\star$处是否存在双稳态（即，在$A^\\star$处至少有两个不同的吸引子）。\n  - 在$A^\\star$处的耐受吸引盆分数（一个小数）。\n  - 在$A^\\star$处的激活吸引盆分数（一个小数）。\n\n最终输出格式：\n- 您的程序应生成一行输出，包含用方括号括起来的逗号分隔的结果列表。每个案例贡献一个包含四个值的列表，顺序为 [${\\text{max\\_attractors}}, {\\text{bistability\\_at\\_}A^\\star}, {\\text{tolerance\\_fraction}}, {\\text{activation\\_fraction}}]$，从而产生以下形式的总体输出：\n$[[m_1,b_1,t_1,a_1],[m_2,b_2,t_2,a_2],[m_3,b_3,t_3,a_3],[m_4,b_4,t_4,a_4]]$\n其中$m_i$是整数，$b_i$是布尔值，$t_i,a_i$是$[0,1]$区间内的小数。",
            "solution": "用户提供了一个数学生物学领域的问题，具体是分析一个模拟效应T细胞和调节性T细胞（Treg）相互作用的动态系统。问题要求对一个抗原驱动参数$A$进行计算分岔分析。这涉及对系统的常微分方程（ODEs）进行数值积分、识别吸引子以及估计它们的吸引盆。\n\n该问题是有效的。它在科学上基于系统生物学的既定原则，定义明确，所有必要的参数和条件都已给定，并提出了一个清晰、客观且可验证的计算任务。我将着手解决。\n\nODE系统由以下方程给出：\n$$\n\\frac{dE}{dt} \\;=\\; \\frac{\\alpha_E}{1 + \\left(\\frac{R}{K_R}\\right)^{n}} \\;-\\; \\delta_E E\n$$\n$$\n\\frac{dR}{dt} \\;=\\; \\frac{\\alpha_R}{1 + \\left(\\frac{E}{K_E}\\right)^{m}} \\;-\\; \\delta_R R\n$$\n其中$E(t)$是效应T细胞的激活水平，$R(t)$是Treg的丰度。效应细胞的产生率$\\alpha_E$受抗原驱动项$A$的调节，满足$\\alpha_E = \\alpha_{E0} + \\theta A$。对于给定的情景，所有其他参数都是常数。该系统描述了一个触发开关，其中每个细胞种群通过Hill型动力学抑制对方的产生。已知这类系统会表现出双稳态，即对于同一组参数，两个不同的稳定稳态可以共存。\n\n解决方案的核心是为四个测试案例中的每一个实施指定的数值程序。该程序如下：\n\n1.  **遍历测试案例**：主逻辑将循环遍历测试套件中提供的四个参数集中的每一个。\n\n2.  **分岔分析循环**：对于每个测试案例，我们将遍历抗原驱动参数$A$的指定值。对于每个$A$值：\n    *   **生成初始条件**：在域$[0, E_{\\max}] \\times [0, R_{\\max}]$上，使用每个轴上指定的网格点数，创建一个均匀的初始条件网格$(E(0), R(0))$。对于每个轴$N$个点，这将产生总共$N^2$个初始条件。\n    *   **数值积分**：对于每个初始条件，从$t=0$到$t=T_{\\text{end}}$对ODE系统进行数值积分。最终状态$(E(T_{\\text{end}}), R(T_{\\text{end}}))$代表轨迹演化到的相图上的点。鉴于清除率$\\delta_E = \\delta_R = 1.0$，系统的特征时间尺度约为1。积分到$T_{\\text{end}} = 200.0$足以使系统收敛到一个稳定吸引子。为此，我们将使用`scipy.integrate.solve_ivp`函数和一个标准的龙格-库塔方法。\n    *   **通过聚类识别吸引子**：在给定$A$的所有积分完成后，收集终点坐标集。这些点将在$(E, R)$平面中进行聚类。实现一个简单的顺序聚类算法：\n        1.  从所有唯一的终点坐标列表开始。\n        2.  当未分配点的列表不为空时，取第一个点作为新聚类的`种子`。\n        3.  列表中所有与`种子`的欧几里得距离在$\\varepsilon$之内的点（包括种子本身）被分到新聚类中，并从未分配点列表中移除。\n        4.  计算这个新聚类的质心，并将其存储为代表一个不同吸引子的坐标$(E^\\star, R^\\star)$。\n        5.  重复此过程，直到所有点都被分配到一个聚类。\n    *   **数据收集**：记录当前$A$值下找到的不同吸引子的数量（即聚类的数量）。该值用于更新当前测试案例迄今为止观察到的最大吸引子数量。\n\n3.  **吸引盆分析**：对于每个测试案例，指定一个特定的值$A^\\star$用于详细的吸引盆分析。使用在$A = A^\\star$时模拟运行的结果：\n    *   **双稳态检查**：如果在$A^\\star$处找到的吸引子数量为两个或更多，则存在双稳态（或多稳态）。这被记录为一个布尔值。\n    *   **吸引子分类**：根据提供的定义对每个识别出的吸引子$(E^\\star, R^\\star)$进行分类：\n        *   **耐受**：$R^\\star \\ge E^\\star$。\n        *   **激活**：$E^\\star > R^\\star$。\n    *   **吸引盆分数计算**：每种类型吸引子的吸引盆通过收敛到它的初始条件的比例来估计。将收敛到任何耐受吸引子的初始模拟点总数相加，对激活吸引子也做同样处理。将这些总和除以初始条件的总数（$N^2$），分别得到耐受和激活的吸引盆分数。\n\n4.  **最终输出格式化**：对于每个测试案例，将四个必需的指标——所有$A$值中的最大吸引子数量、在$A^\\star$处的双稳态布尔值、在$A^\\star$处的耐受吸引盆分数以及在$A^\\star$处的激活吸引盆分数——收集到一个列表中。最终输出是这四个列表的列表，按问题陈述指定的格式化为单个字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run the bifurcation analysis for all test cases and print results.\n    \"\"\"\n    \n    test_cases = [\n        {\n            # Case 1 (tolerance-favoring baseline)\n            \"params\": {\"alpha_E0\": 0.2, \"alpha_R\": 1.4, \"theta\": 0.6, \"delta_E\": 1.0, \"delta_R\": 1.0, \"K_E\": 0.5, \"K_R\": 0.5, \"m\": 4, \"n\": 4},\n            \"A_values\": [0.0, 0.2, 0.4, 0.6],\n            \"A_star\": 0.4,\n            \"sim_settings\": {\"E_max\": 2.0, \"R_max\": 2.0, \"grid_points\": 5, \"T_end\": 200.0, \"epsilon\": 1e-3},\n        },\n        {\n            # Case 2 (activation-favoring baseline)\n            \"params\": {\"alpha_E0\": 1.2, \"alpha_R\": 0.5, \"theta\": 0.6, \"delta_E\": 1.0, \"delta_R\": 1.0, \"K_E\": 0.5, \"K_R\": 0.5, \"m\": 4, \"n\": 4},\n            \"A_values\": [0.0, 0.5, 1.0],\n            \"A_star\": 1.0,\n            \"sim_settings\": {\"E_max\": 2.0, \"R_max\": 2.0, \"grid_points\": 5, \"T_end\": 200.0, \"epsilon\": 1e-3},\n        },\n        {\n            # Case 3 (intermediate regime, potential bistability)\n            \"params\": {\"alpha_E0\": 0.7, \"alpha_R\": 1.0, \"theta\": 0.9, \"delta_E\": 1.0, \"delta_R\": 1.0, \"K_E\": 0.5, \"K_R\": 0.5, \"m\": 4, \"n\": 4},\n            \"A_values\": [0.0, 0.3, 0.6, 0.9, 1.2],\n            \"A_star\": 0.6,\n            \"sim_settings\": {\"E_max\": 2.0, \"R_max\": 2.0, \"grid_points\": 5, \"T_end\": 200.0, \"epsilon\": 1e-3},\n        },\n        {\n            # Case 4 (near-balanced boundary regime)\n            \"params\": {\"alpha_E0\": 0.9, \"alpha_R\": 0.9, \"theta\": 0.4, \"delta_E\": 1.0, \"delta_R\": 1.0, \"K_E\": 0.5, \"K_R\": 0.5, \"m\": 4, \"n\": 4},\n            \"A_values\": [0.0, 0.4, 0.8],\n            \"A_star\": 0.4,\n            \"sim_settings\": {\"E_max\": 2.0, \"R_max\": 2.0, \"grid_points\": 5, \"T_end\": 200.0, \"epsilon\": 1e-3},\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        max_attractors = 0\n        results_at_A_star = {}\n\n        for A_val in case[\"A_values\"]:\n            # Set up parameters for this run\n            current_params = case[\"params\"].copy()\n            current_params[\"A\"] = A_val\n            \n            # Generate initial conditions\n            sim_settings = case[\"sim_settings\"]\n            grid_points = sim_settings[\"grid_points\"]\n            E_space = np.linspace(0, sim_settings[\"E_max\"], grid_points)\n            R_space = np.linspace(0, sim_settings[\"R_max\"], grid_points)\n            initial_conditions = np.array(np.meshgrid(E_space, R_space)).T.reshape(-1, 2)\n            \n            # Run simulations\n            endpoints = []\n            for ic in initial_conditions:\n                sol = solve_ivp(\n                    fun=ode_system,\n                    t_span=[0, sim_settings[\"T_end\"]],\n                    y0=ic,\n                    args=(current_params,),\n                    method='RK45',\n                    rtol=1e-6,\n                    atol=1e-6\n                )\n                endpoints.append(sol.y[:, -1])\n            \n            # Cluster endpoints\n            attractors, counts = cluster_endpoints(endpoints, sim_settings[\"epsilon\"])\n            num_attractors = len(attractors)\n            if num_attractors > max_attractors:\n                max_attractors = num_attractors\n\n            # Analyze for A_star\n            if A_val == case[\"A_star\"]:\n                bistability = True if num_attractors >= 2 else False\n                \n                tol_count = 0\n                act_count = 0\n                \n                for i, attractor in enumerate(attractors):\n                    E_star, R_star = attractor\n                    if R_star >= E_star: # Tolerance\n                        tol_count += counts[i]\n                    else: # Activation\n                        act_count += counts[i]\n                \n                total_points = len(initial_conditions)\n                tol_frac = tol_count / total_points\n                act_frac = act_count / total_points\n                \n                results_at_A_star = {\n                    \"bistability\": bistability,\n                    \"tol_frac\": tol_frac,\n                    \"act_frac\": act_frac\n                }\n        \n        case_result = [\n            max_attractors,\n            results_at_A_star[\"bistability\"],\n            results_at_A_star[\"tol_frac\"],\n            results_at_A_star[\"act_frac\"]\n        ]\n        all_results.append(case_result)\n\n    # Format output\n    def format_item(item):\n        if isinstance(item, bool):\n            return str(item).lower()\n        if isinstance(item, float):\n             return f\"{item:.6f}\".rstrip('0').rstrip('.') if '.' in f\"{item:.6f}\" else f\"{item:.1f}\"\n        return str(item)\n\n    formatted_sublists = []\n    for sublist in all_results:\n        # A bit of logic to ensure float representation is clean\n        sublist[2] = float(f\"{sublist[2]:.4f}\")\n        sublist[3] = float(f\"{sublist[3]:.4f}\")\n        formatted_sublists.append(f\"[{','.join(format_item(item) for item in sublist)}]\")\n    \n    final_output = f\"[{','.join(formatted_sublists)}]\"\n    print(final_output)\n\ndef ode_system(t, y, params):\n    \"\"\"\n    Defines the system of ODEs for T-cell dynamics.\n    y[0] = E, y[1] = R\n    \"\"\"\n    E, R = y\n    \n    alpha_E = params[\"alpha_E0\"] + params[\"theta\"] * params[\"A\"]\n    \n    dE_dt = alpha_E / (1 + (R / params[\"K_R\"])**params[\"n\"]) - params[\"delta_E\"] * E\n    dR_dt = params[\"alpha_R\"] / (1 + (E / params[\"K_E\"])**params[\"m\"]) - params[\"delta_R\"] * R\n    \n    return [dE_dt, dR_dt]\n\ndef cluster_endpoints(endpoints, epsilon):\n    \"\"\"\n    Clusters final trajectory points into attractors.\n    Implements a simple sequential (leader) clustering algorithm.\n    \"\"\"\n    if not endpoints:\n        return [], []\n\n    unassigned_points = [np.array(p) for p in endpoints]\n    centroids = []\n    counts = []\n\n    while unassigned_points:\n        seed = unassigned_points[0]\n        \n        # Points in the new cluster are those close to the seed\n        current_cluster_points = [p for p in unassigned_points if np.linalg.norm(p - seed)  epsilon]\n        \n        # Remaining points are those not in the new cluster\n        unassigned_points = [p for p in unassigned_points if np.linalg.norm(p - seed) >= epsilon]\n        \n        if current_cluster_points:\n            centroid = np.mean(current_cluster_points, axis=0)\n            centroids.append(centroid)\n            counts.append(len(current_cluster_points))\n            \n    return centroids, counts\n\nsolve()\n```"
        },
        {
            "introduction": "理解免疫系统的动态行为最终是为了能够主动调控它，尤其是在治疗疾病时。本练习将理论与临床应用相结合，要求你为一个模拟检查点抑制剂疗法的药代动力学/药效动力学（PK/PD）模型设计最佳给药方案。通过模拟不同的剂量和给药间隔 ，你将学习如何在最大化治疗效果（恢复功能性T细胞）与避免不良反应（过度免疫激活）之间进行权衡，这是定量系统药理学的核心挑战。",
            "id": "3893271",
            "problem": "考虑一个检查点抑制剂的单室药代动力学（PK）模型与T细胞耗竭和再活化的药效学（PD）的耦合。从以下基本依据出发：(i) 良好混合室中的质量平衡，这意味着药物总量的变化率等于输入减去输出，并且对于固定体积室中的一级消除，浓度呈指数衰减；以及 (ii) 在具有逻辑限制的稳态增殖、死亡、耗竭转化和药物诱导的再活化下的T细胞群体动力学。您将以纯数学术语形式化该系统，并计算能够最大化功能性效应T细胞恢复同时不违反过冲安全界限的离散给药策略。\n\n模型假设与定义：\n\n- 药代动力学（PK）：令 $C(t)$ 为检查点抑制剂在单室模型中的血浆浓度（单位为 $\\mathrm{mg/L}$），清除率为 $CL$（单位为 $\\mathrm{L/day}$），分布容积为 $V$（单位为 $\\mathrm{L}$）。消除速率常数为 $k_e = CL/V$（单位为 $\\mathrm{day^{-1}}$）。在时间 $t_i$ 的推注给药之间，浓度遵循\n$$\\frac{dC}{dt} = -k_e C,$$\n在时间 $t_i$ 给予一次量级为 $D$（单位为 $\\mathrm{mg}$）的瞬时推注给药会使浓度增加 $\\Delta C = D/V$。\n\n- 药效学（PD）：令 $E(t)$ 表示功能性效应T细胞群体（单位为 $\\mathrm{cells/\\mu L}$），$X(t)$ 表示耗竭T细胞群体（单位为 $\\mathrm{cells/\\mu L}$）。效应细胞以固有速率 $r_E$（单位为 $\\mathrm{day^{-1}}$）和承载能力 $K$（单位为 $\\mathrm{cells/\\mu L}$）进行逻辑增殖，以速率 $d_E$（单位为 $\\mathrm{day^{-1}}$）死亡，并以受检查点抑制调节的基线速率 $k_{\\mathrm{exh}}$（单位为 $\\mathrm{day^{-1}}$）转化为耗竭状态。耗竭细胞以速率 $d_X$（单位为 $\\mathrm{day^{-1}}$）死亡，并可以受检查点抑制调节的速率 $k_{\\mathrm{rev}}$（单位为 $\\mathrm{day^{-1}}$）再活化为效应状态。药物效应由一个 $E_{\\max}$ 模型表示\n$$I(C) = E_{\\max} \\frac{C}{EC_{50} + C},$$\n其中 $E_{\\max} \\in [0,1]$ 是最大抑制效应，$EC_{50}$（单位为 $\\mathrm{mg/L}$）是达到半数最大效应时的浓度。耗竭转化率降低为 $k_{\\mathrm{exh}} (1 - I(C))$，再活化速率变为 $k_{\\mathrm{rev}} I(C)$。耦合的常微分方程组为\n$$\\frac{dE}{dt} = r_E E \\left(1 - \\frac{E+X}{K}\\right) - d_E E - k_{\\mathrm{exh}} (1 - I(C)) E + k_{\\mathrm{rev}} I(C) X,$$\n$$\\frac{dX}{dt} = k_{\\mathrm{exh}} (1 - I(C)) E - d_X X - k_{\\mathrm{rev}} I(C) X.$$\n\n- 初始条件：在 $t=0$ 时，令 $C(0) = 0$，$E(0) = E_0$，且 $X(0) = X_0$。\n\n- 给药方案：考虑一个离散给药方案，在时间 $t \\in \\{0, \\tau, 2\\tau, \\dots, (N-1)\\tau\\}$ 给予 $N$ 次量级为 $D$（单位为 $\\mathrm{mg}$）的相同推注给药，其中 $\\tau$（单位为 $\\mathrm{day}$）是给药间隔。对于此问题，您将在一个有限的候选 $(D, \\tau)$ 方案集合中进行搜索。\n\n- 目标与约束：对于固定的时间范围 $T_h$（单位为 $\\mathrm{day}$），将恢复目标定义为效应细胞超过基线的时间积分，\n$$J(D,\\tau) = \\int_{0}^{T_h} \\max(E(t) - E_0, 0)\\, dt.$$\n定义一个过冲安全上限 $E_{\\mathrm{upper}}$（单位为 $\\mathrm{cells/\\mu L}$）。如果 $\\max_{t \\in [0,T_h]} E(t) \\le E_{\\mathrm{upper}}$，则方案 $(D,\\tau)$ 是可接受的。目标是选择在满足可接受性约束的条件下，使 $J(D,\\tau)$ 最大化的 $(D,\\tau)$。如果多个方案达到相同的最大目标值，则优先选择 $D$ 最小的方案。如果在候选集合中不存在可接受的方案，则返回一个不可行的指示符。\n\n算法要求：\n\n- 使用标准的初值问题求解器，实现耦合系统的分段数值积分，并在给药时间对 $C(t)$ 进行瞬时推注更新。\n- 基于求解器的输出，使用数值求积法评估目标 $J(D,\\tau)$。\n- 通过检查轨迹上 $E(t)$ 的最大值来强制执行过冲约束。\n- 在每个测试用例中给出的剂量 $D$ 和间隔 $\\tau$ 的有限候选集合中进行搜索。\n\n物理和数值单位：\n\n- 剂量 $D$ 以 $\\mathrm{mg}$ 表示，给药间隔 $\\tau$ 以 $\\mathrm{day}$ 表示，浓度 $C$ 以 $\\mathrm{mg/L}$ 表示，时间以 $\\mathrm{day}$ 表示，T细胞计数以 $\\mathrm{cells/\\mu L}$ 表示。\n\n角度单位不适用。如果任何数量必须以分数表示，请使用小数形式。\n\n测试套件和参数值：\n\n对于每个测试用例 $i$，所有参数均已提供，并且对于免疫检查点抑制剂治疗和T细胞动力学具有科学合理性。您的程序必须处理以下四个测试用例：\n\n- 案例1（中等清除率，中等效力，典型动力学，理想路径）：\n    - $CL = 0.3$ $\\mathrm{L/day}$, $V = 3.0$ $\\mathrm{L}$, $EC_{50} = 0.5$ $\\mathrm{mg/L}$, $E_{\\max} = 0.8$,\n    - $K = 1000.0$ $\\mathrm{cells/\\mu L}$, $r_E = 0.05$ $\\mathrm{day^{-1}}$, $d_E = 0.02$ $\\mathrm{day^{-1}}$, $d_X = 0.03$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{exh}} = 0.04$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{rev}} = 0.06$ $\\mathrm{day^{-1}}$,\n    - $E_0 = 200.0$ $\\mathrm{cells/\\mu L}$, $X_0 = 300.0$ $\\mathrm{cells/\\mu L}$,\n    - $E_{\\mathrm{upper}} = 800.0$ $\\mathrm{cells/\\mu L}$, $T_h = 30.0$ $\\mathrm{day}$, $N = 3$ doses,\n    - 候选 $D \\in \\{0, 50, 100, 150, 200\\}$ $\\mathrm{mg}$, 候选 $\\tau \\in \\{7, 14\\}$ $\\mathrm{day}$.\n\n- 案例2（高清除率，更紧的安全界限，测试需要更短的间隔）：\n    - $CL = 0.9$ $\\mathrm{L/day}$, $V = 3.0$ $\\mathrm{L}$, $EC_{50} = 0.5$ $\\mathrm{mg/L}$, $E_{\\max} = 0.8$,\n    - $K = 1000.0$ $\\mathrm{cells/\\mu L}$, $r_E = 0.05$ $\\mathrm{day^{-1}}$, $d_E = 0.02$ $\\mathrm{day^{-1}}$, $d_X = 0.03$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{exh}} = 0.04$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{rev}} = 0.06$ $\\mathrm{day^{-1}}$,\n    - $E_0 = 200.0$ $\\mathrm{cells/\\mu L}$, $X_0 = 300.0$ $\\mathrm{cells/\\mu L}$,\n    - $E_{\\mathrm{upper}} = 750.0$ $\\mathrm{cells/\\mu L}$, $T_h = 30.0$ $\\mathrm{day}$, $N = 3$ doses,\n    - 候选 $D \\in \\{0, 50, 100, 150, 200\\}$ $\\mathrm{mg}$, 候选 $\\tau \\in \\{7, 14\\}$ $\\mathrm{day}$.\n\n- 案例3（高效力，有过度反应风险）：\n    - $CL = 0.3$ $\\mathrm{L/day}$, $V = 3.0$ $\\mathrm{L}$, $EC_{50} = 0.1$ $\\mathrm{mg/L}$, $E_{\\max} = 1.0$,\n    - $K = 1000.0$ $\\mathrm{cells/\\mu L}$, $r_E = 0.05$ $\\mathrm{day^{-1}}$, $d_E = 0.02$ $\\mathrm{day^{-1}}$, $d_X = 0.03$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{exh}} = 0.04$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{rev}} = 0.06$ $\\mathrm{day^{-1}}$,\n    - $E_0 = 200.0$ $\\mathrm{cells/\\mu L}$, $X_0 = 300.0$ $\\mathrm{cells/\\mu L}$,\n    - $E_{\\mathrm{upper}} = 700.0$ $\\mathrm{cells/\\mu L}$, $T_h = 30.0$ $\\mathrm{day}$, $N = 3$ doses,\n    - 候选 $D \\in \\{0, 50, 100, 150, 200\\}$ $\\mathrm{mg}$, 候选 $\\tau \\in \\{7, 14\\}$ $\\mathrm{day}$.\n\n- 案例4（低再活化功效，测试对最小剂量的偏好）：\n    - $CL = 0.3$ $\\mathrm{L/day}$, $V = 3.0$ $\\mathrm{L}$, $EC_{50} = 0.5$ $\\mathrm{mg/L}$, $E_{\\max} = 0.8$,\n    - $K = 1000.0$ $\\mathrm{cells/\\mu L}$, $r_E = 0.05$ $\\mathrm{day^{-1}}$, $d_E = 0.02$ $\\mathrm{day^{-1}}$, $d_X = 0.03$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{exh}} = 0.04$ $\\mathrm{day^{-1}}$, $k_{\\mathrm{rev}} = 0.0$ $\\mathrm{day^{-1}}$,\n    - $E_0 = 200.0$ $\\mathrm{cells/\\mu L}$, $X_0 = 300.0$ $\\mathrm{cells/\\mu L}$,\n    - $E_{\\mathrm{upper}} = 900.0$ $\\mathrm{cells/\\mu L}$, $T_h = 30.0$ $\\mathrm{day}$, $N = 3$ doses,\n    - 候选 $D \\in \\{0, 50, 100, 150, 200\\}$ $\\mathrm{mg}$, 候选 $\\tau \\in \\{7, 14\\}$ $\\mathrm{day}$.\n\n最终输出格式要求：\n\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，列表被方括号括起。此列表中的每个元素对应一个测试用例，并且其本身必须是一个包含两个整数 $[D_{\\mathrm{best}}, \\tau_{\\mathrm{best}}]$ 的列表，报告该案例的最佳剂量（单位 $\\mathrm{mg}$）和最佳给药间隔（单位 $\\mathrm{day}$）。如果在候选集合中不存在可接受的方案，则为该案例输出列表 $[-1, -1]$。例如，输出格式必须如下所示\n$$[[D_1,\\tau_1],[D_2,\\tau_2],[D_3,\\tau_3],[D_4,\\tau_4]].$$",
            "solution": "用户希望解决一个关于T细胞对检查点抑制剂治疗响应的药代动力学/药效学（PK/PD）模型的优化问题。该解决方案需要对一个常微分方程（ODE）系统进行数值模拟，并在一个离散的给药策略集合上进行搜索。\n\n### 步骤1：提取给定信息\n问题提供了一个耦合的PK/PD模型，该模型由一个包含三个ODE的系统定义，分别对应药物浓度 $C(t)$、功能性效应T细胞群体 $E(t)$ 和耗竭T细胞群体 $X(t)$。\n\n**药代动力学（PK）：**\n- 状态变量：$C(t)$ [$\\mathrm{mg/L}$]\n- 模型：单室模型，一级消除。\n- ODE（给药间隔期）：$\\frac{dC}{dt} = -k_e C$\n- 消除速率常数：$k_e = CL/V$ [$\\mathrm{day^{-1}}$]\n- 参数：清除率 $CL$ [$\\mathrm{L/day}$]，分布容积 $V$ [$\\mathrm{L}$]\n- 给药：在时间 $t_i$ 的瞬时推注给药 $D$ [$\\mathrm{mg}$] 导致浓度变化 $\\Delta C = D/V$。\n\n**药效学（PD）：**\n- 状态变量：$E(t)$ [$\\mathrm{cells/\\mu L}$]， $X(t)$ [$\\mathrm{cells/\\mu L}$]\n- 药物效应模型：$I(C) = E_{\\max} \\frac{C}{EC_{50} + C}$\n- 参数：最大效应 $E_{\\max}$ (无量纲)，半最大效应浓度 $EC_{50}$ [$\\mathrm{mg/L}$]\n- 耦合ODE：\n$$ \\frac{dE}{dt} = r_E E \\left(1 - \\frac{E+X}{K}\\right) - d_E E - k_{\\mathrm{exh}} (1 - I(C)) E + k_{\\mathrm{rev}} I(C) X $$\n$$ \\frac{dX}{dt} = k_{\\mathrm{exh}} (1 - I(C)) E - d_X X - k_{\\mathrm{rev}} I(C) X $$\n- 参数：\n    - $r_E$: 效应细胞的固有增殖率 [$\\mathrm{day^{-1}}$]\n    - $K$: 承载能力 [$\\mathrm{cells/\\mu L}$]\n    - $d_E$: 效应细胞的死亡率 [$\\mathrm{day^{-1}}$]\n    - $d_X$: 耗竭细胞的死亡率 [$\\mathrm{day^{-1}}$]\n    - $k_{\\mathrm{exh}}$: 基线耗竭转化率 [$\\mathrm{day^{-1}}$]\n    - $k_{\\mathrm{rev}}$: 基线再活化率 [$\\mathrm{day^{-1}}$]\n\n**模拟设置：**\n- $t=0$ 时的初始条件：$C(0) = 0$, $E(0) = E_0$, $X(0) = X_0$。\n- 给药方案：在时间 $t \\in \\{0, \\tau, 2\\tau, \\dots, (N-1)\\tau\\}$ 给予 $N$ 次量级为 $D$ [$\\mathrm{mg}$] 的相同推注给药。\n- 时间范围：$T_h$ [$\\mathrm{day}$]。\n\n**优化问题：**\n- 目标函数：最大化恢复度 $J(D,\\tau) = \\int_{0}^{T_h} \\max(E(t) - E_0, 0)\\, dt$。\n- 约束：可接受性要求 $\\max_{t \\in [0,T_h]} E(t) \\le E_{\\mathrm{upper}}$。\n- 搜索空间：每个测试用例的 $(D, \\tau)$ 对的有限候选集合。\n- 决胜规则：如果多个方案产生相同的最大 $J$，则优先选择 $D$ 最小的方案。\n- 不可行性：如果不存在可接受的方案，则返回 $[-1, -1]$。\n\n**测试用例：** 问题提供了四个不同的测试用例，每个用例都有一整套参数值和候选方案。\n\n### 步骤2：使用提取的给定信息进行验证\n- **科学依据：** 该模型是定量系统药理学中一个标准且被广泛接受的公式。它将一个单室PK模型与一个免疫细胞的群体动力学模型相结合，使用了诸如一级消除、逻辑斯蒂增长和用于药物效应的 $E_{\\max}$ 模型等已建立的形式。所有组件都基于质量平衡和群体动力学的基本原理。该模型就其预期目的而言是科学合理的。\n- **适定性：** ODE系统的右侧函数是光滑（解析）的，这保证了给定初始条件下解的存在性和唯一性。优化任务是在一个有限的离散候选方案集上进行搜索。对于每个候选方案，目标函数和约束都有明确的定义。因此，保证在候选集内存在最优解，或者可以证明不存在可接受的解。该问题是适定的。\n- **客观性：** 该问题使用精确的数学符号和明确的技术语言进行描述。所有参数、变量和目标都已明确定义。它不包含主观或基于意见的主张。\n- **完整性和一致性：** 为每个测试用例提供了所有必要的参数（$CL$, $V$, $E_{\\max}$, $EC_{50}$, T细胞动力学速率，初始条件, $N$, $T_h$, $E_{\\mathrm{upper}}$）和候选方案。单位在整个模型定义中是一致的。\n- **其他缺陷：** 该问题没有表现出任何其他缺陷，例如不切实际（在数学建模的背景下）、结构不良、过于简单或无法验证。\n\n### 步骤3：结论与行动\n该问题是**有效的**。这是一个在生物医学系统建模中定义明确的计算问题。我将继续制定和实施解决方案。\n\n### 基于原则的设计\n解决方案的设计围绕核心任务展开：为每个候选给药方案模拟系统轨迹，然后根据指定的目标和约束评估其性能。\n\n1.  **系统表示**：系统的状态由向量 $\\mathbf{y}(t) = [C(t), E(t), X(t)]^T$ 表示。动力学由所提供的三个耦合ODE系统控制。ODE的参数对每个测试用例都是特定的。\n\n2.  **分段数值积分**：给药方案涉及在离散时间点 $t_k = k \\tau$ 处状态变量 $C(t)$ 的瞬时变化（跳跃）。这需要一个分段积分策略。模拟范围 $[0, T_h]$ 被分解为多个段，其端点由给药时间和最终时间 $T_h$ 定义。\n    - 模拟按顺序从一个段进行到下一个段。\n    - 在每个从给药时间 $t_k$ 开始的段的开头，浓度瞬间增加：$C(t_k^+) = C(t_k^-) + D/V$。\n    - 使用一个数值ODE求解器，特别是`scipy`库中的`scipy.integrate.solve_ivp`，来在每个连续段上对系统进行积分。此函数适用于初值问题，并采用自适应步长来确保准确性和效率。\n    - 将每个段的解连接起来，形成在整个时间范围 $[0, T_h]$ 上的完整轨迹。\n\n3.  **方案评估**：在为给定方案 $(D, \\tau)$ 模拟完整轨迹后：\n    - **约束检查**：通过找到计算出的 $E(t)$ 轨迹的最大值来检查约束 $\\max_{t \\in [0,T_h]} E(t) \\le E_{\\mathrm{upper}}$。如果违反约束，则该方案被视为不可接受。\n    - **目标计算**：如果方案是可接受的，则计算目标函数 $J(D,\\tau) = \\int_{0}^{T_h} \\max(E(t) - E_0, 0)\\, dt$。这通过数值求积实现。将梯形法则（由`numpy.trapz`实现）应用于在数值解的时间点 $t_j$ 处评估的函数值 $\\max(E(t_j) - E_0, 0)$。\n\n4.  **通过搜索进行优化**：通过对每个测试用例提供的有限、离散的候选对 $(D, \\tau)$ 集合进行穷举搜索来找到最优方案。\n    - 对于每个案例，我们用一个表示尚未找到可接受解的状态（例如，目标 $J = -1.0$，方案 $[-1, -1]$）来初始化一个“最佳”方案跟踪器。\n    - 我们遍历所有候选方案。对每一个方案，我们执行模拟和评估步骤。\n    - 如果一个方案是可接受的，则将其目标值 $J$ 与迄今为止找到的最佳值进行比较。如果新方案具有严格更高的 $J$，或者具有相等的 $J$ 但剂量 $D$ 更小（根据问题的决胜规则），则更新“最佳”方案。\n    - 在检查所有候选方案后，最终存储的“最佳”方案即为该测试用例的解。\n\n这种结构化的方法确保每个候选方案都根据模型的动力学和问题的标准得到严格评估，从而找到最优策略。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the PK/PD optimization problem for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"CL\": 0.3, \"V\": 3.0, \"EC50\": 0.5, \"Emax\": 0.8,\n            \"K\": 1000.0, \"rE\": 0.05, \"dE\": 0.02, \"dX\": 0.03, \"k_exh\": 0.04, \"k_rev\": 0.06,\n            \"E0\": 200.0, \"X0\": 300.0,\n            \"Eupper\": 800.0, \"Th\": 30.0, \"N\": 3,\n            \"candidate_D\": [0, 50, 100, 150, 200], \"candidate_tau\": [7, 14],\n        },\n        {\n            \"CL\": 0.9, \"V\": 3.0, \"EC50\": 0.5, \"Emax\": 0.8,\n            \"K\": 1000.0, \"rE\": 0.05, \"dE\": 0.02, \"dX\": 0.03, \"k_exh\": 0.04, \"k_rev\": 0.06,\n            \"E0\": 200.0, \"X0\": 300.0,\n            \"Eupper\": 750.0, \"Th\": 30.0, \"N\": 3,\n            \"candidate_D\": [0, 50, 100, 150, 200], \"candidate_tau\": [7, 14],\n        },\n        {\n            \"CL\": 0.3, \"V\": 3.0, \"EC50\": 0.1, \"Emax\": 1.0,\n            \"K\": 1000.0, \"rE\": 0.05, \"dE\": 0.02, \"dX\": 0.03, \"k_exh\": 0.04, \"k_rev\": 0.06,\n            \"E0\": 200.0, \"X0\": 300.0,\n            \"Eupper\": 700.0, \"Th\": 30.0, \"N\": 3,\n            \"candidate_D\": [0, 50, 100, 150, 200], \"candidate_tau\": [7, 14],    \n        },\n        {\n            \"CL\": 0.3, \"V\": 3.0, \"EC50\": 0.5, \"Emax\": 0.8,\n            \"K\": 1000.0, \"rE\": 0.05, \"dE\": 0.02, \"dX\": 0.03, \"k_exh\": 0.04, \"k_rev\": 0.0,\n            \"E0\": 200.0, \"X0\": 300.0,\n            \"Eupper\": 900.0, \"Th\": 30.0, \"N\": 3,\n            \"candidate_D\": [0, 50, 100, 150, 200], \"candidate_tau\": [7, 14],\n        }\n    ]\n\n    final_results = []\n\n    for params in test_cases:\n        p = params # Use a shorthand for easier access\n        \n        # Define the ODE system as a nested function to capture parameters\n        def ode_system(t, y, k_e, EC50, Emax, K, rE, dE, dX, k_exh, k_rev):\n            C, E, X = y\n            \n            # Avoid division by zero or negative values for E and X\n            E = max(E, 0)\n            X = max(X, 0)\n\n            # Drug effect\n            I_C = Emax * C / (EC50 + C)\n            \n            # ODEs\n            dCdt = -k_e * C\n            dEdt = rE * E * (1 - (E + X) / K) - dE * E - k_exh * (1 - I_C) * E + k_rev * I_C * X\n            dXdt = k_exh * (1 - I_C) * E - dX * X - k_rev * I_C * X\n            \n            return [dCdt, dEdt, dXdt]\n\n        best_J = -1.0\n        best_schedule = [-1, -1]\n\n        k_e = p['CL'] / p['V']\n        ode_args = (k_e, p['EC50'], p['Emax'], p['K'], p['rE'], p['dE'], p['dX'], p['k_exh'], p['k_rev'])\n        \n        for tau in p['candidate_tau']:\n            for D in p['candidate_D']:\n                \n                # --- Piecewise Simulation ---\n                y0 = np.array([0.0, p['E0'], p['X0']])\n                t_current = 0.0\n                y_current = y0.copy()\n                \n                dose_times = {i * tau for i in range(p['N'])}\n                # Define integration stop points: dosing times and final horizon time\n                time_stops = sorted(list(dose_times | {0, p['Th']}))\n                \n                ts_pieces, ys_pieces = [], []\n                \n                for t_stop in time_stops:\n                    if t_stop = t_current:\n                        continue\n                        \n                    # Apply dose at the beginning of the interval\n                    if t_current in dose_times:\n                        y_current[0] += D / p['V']\n\n                    # Integrate over the segment\n                    sol = solve_ivp(\n                        fun=ode_system, \n                        t_span=[t_current, t_stop], \n                        y0=y_current,\n                        args=ode_args,\n                        rtol=1e-6, atol=1e-6, # Standard tolerances for accuracy\n                        method='RK45'\n                    )\n                    \n                    ts_pieces.append(sol.t)\n                    ys_pieces.append(sol.y)\n                    \n                    y_current = sol.y[:, -1]\n                    t_current = t_stop\n                \n                # Stitch the solution pieces together, removing duplicate time points\n                if not ts_pieces: \n                    # This case happens if Th=0, not applicable here, but good practice\n                    t_traj, y_traj = np.array([0.0]), np.array([y0]).T\n                else:\n                    t_traj = np.concatenate([pc if i == 0 else pc[1:] for i, pc in enumerate(ts_pieces)])\n                    y_traj = np.concatenate([pc if i == 0 else pc[:, 1:] for i, pc in enumerate(ys_pieces)], axis=1)\n\n                E_traj = y_traj[1, :]\n\n                # --- Evaluation and Optimization ---\n                # Check overshoot constraint\n                max_E = np.max(E_traj)\n                is_admissible = max_E = p['Eupper']\n\n                if is_admissible:\n                    # Calculate objective function J\n                    integrand = np.maximum(E_traj - p['E0'], 0)\n                    J = np.trapz(integrand, t_traj)\n                    \n                    # Update best schedule based on maximization and tie-breaking rule\n                    # The first admissible schedule will always satisfy J > best_J (since best_J starts at -1)\n                    if J > best_J or (np.isclose(J, best_J) and D  best_schedule[0]):\n                        best_J = J\n                        best_schedule = [int(D), int(tau)]\n        \n        final_results.append(best_schedule)\n        \n    print(str(final_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}