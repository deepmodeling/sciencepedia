{
    "hands_on_practices": [
        {
            "introduction": "基因开关是合成生物学中的一个典型模体，展示了系统如何实现双稳态。本练习将通过分析一个由两个相互抑制的基因组成的简单网络，来帮助您掌握识别不动点吸引子的方法，并理解双稳态——即系统可以稳定存在于两种不同状态之一——这一基本属性。通过解决这个问题 ()，您将为分析更复杂的网络动力学打下坚实的基础。",
            "id": "1419894",
            "problem": "遗传拨动开关是一种表现出双稳态的小型合成基因调控网络。考虑一个由两个基因（基因 Alpha 和基因 Beta）组成的拨动开关的简化模型。在离散时间步长 $t$ 时，该系统的状态可以用一对布尔变量 $(A(t), B(t))$ 来描述，其中值 1 表示基因被表达（ON），值 0 表示基因未被表达（OFF）。\n\n这两个基因是相互抑制的。在同步更新方案下（两个基因在每个时间步长同时更新其状态），控制网络演化的规则如下：\n\n1.  基因 Alpha 在时间 $t+1$ 时被表达，当且仅当基因 Beta 在时间 $t$ 时未被表达。\n2.  基因 Beta 在时间 $t+1$ 时被表达，当且仅当基因 Alpha 在时间 $t$ 时未被表达。\n\n一个稳定的稳态，也称为不动点，是系统随时间保持不变的状态。也就是说，如果系统处于状态 $(A(t), B(t))$，其下一个状态 $(A(t+1), B(t+1))$ 是相同的。\n\n找出该遗传拨动开关模型所有可能的稳定稳态（不动点）。\n\nA. 状态 (0, 0) 是唯一的稳态。\n\nB. 状态 (0, 1) 和 (1, 0) 是两个稳态。\n\nC. 状态 (1, 1) 是唯一的稳态。\n\nD. 状态 (0, 0) 和 (1, 1) 是两个稳态。\n\nE. 所有四个状态 (0, 0), (0, 1), (1, 0), 和 (1, 1) 都是稳态。\n\nF. 系统没有稳定的稳态。",
            "solution": "令 $A(t), B(t) \\in \\{0,1\\}$ 表示基因 Alpha 和基因 Beta 在时间 $t$ 的状态。同步更新规则是\n$$\nA(t+1)=\\neg B(t), \\quad B(t+1)=\\neg A(t),\n$$\n其中 $\\neg$ 表示布尔非。一个不动点是满足\n$$\nA(t+1)=A(t)=A, \\quad B(t+1)=B(t)=B.\n$$\n的状态 $(A,B)$。因此，不动点满足方程组\n$$\nA=\\neg B, \\quad B=\\neg A.\n$$\n从 $A=\\neg B$ 出发，对两边应用 $\\neg$ 运算得到 $\\neg A=\\neg(\\neg B)=B$，这与第二个方程相符。因此，该方程组简化为在布尔值上求解 $A=\\neg B$。其解恰好为\n$$\n(A,B)=(0,1) \\quad \\text{和} \\quad (A,B)=(1,0).\n$$\n验证：\n- 对于 $(0,1)$，更新得到 $(\\neg 1,\\neg 0)=(0,1)$，因此它是一个不动点。\n- 对于 $(1,0)$，更新得到 $(\\neg 0,\\neg 1)=(1,0)$，因此它是一个不动点。\n其余状态不是不动点：\n- $(0,0)\\mapsto(1,1)\\neq(0,0)$,\n- $(1,1)\\mapsto(0,0)\\neq(1,1)$.\n因此，稳定的稳态是 $(0,1)$ 和 $(1,0)$，对应于选项 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在吸引子的概念基础上，本练习引入了“吸引盆”这一关键思想，它定义了从哪些初始状态出发系统会收敛到特定的吸引子。通过一个三基因网络模型 ()，您将探索即使是微小的初始状态差异（汉明距离为1）也可能导致系统走向完全不同的长期行为。这个练习旨在揭示状态空间的结构及其对系统命运的决定性影响。",
            "id": "1419879",
            "problem": "考虑一个由三个基因 $G_1$、$G_2$ 和 $G_3$ 组成的遗传调控回路的简化模型。每个基因的状态可以是“关闭”（用 0 表示）或“开启”（用 1 表示）。在离散时间步 $t$ 时，整个系统的状态由有序三元组 $S(t) = (g_1(t), g_2(t), g_3(t))$ 给出，其中 $g_i(t)$ 是基因 $G_i$ 的状态。系统根据以下布尔更新规则以同步离散时间步演化，其中 $g'_i$ 表示基因 $G_i$ 在时间 $t+1$ 时的状态：\n\n$g'_1 = \\neg g_2(t)$\n$g'_2 = \\neg g_3(t)$\n$g'_3 = \\neg g_1(t)$\n\n此处，$\\neg$ 代表逻辑非运算符。从一个给定的初始状态出发，系统的长期行为是进入一个吸引子，这个吸引子可以是一个单一的稳定状态（不动点）或一个重复的状态序列（极限环）。所有能够导致系统进入某个特定吸引子的初始状态的集合，被称为其吸引盆。\n\n两个状态之间的汉明距离是它们基因状态不同的数量。下列哪对初始状态 $(S_A, S_B)$，其汉明距离为 1，且 $S_A$ 和 $S_B$ 属于两个不同吸引子的吸引盆？\n\nA. $((0, 0, 0), (1, 1, 1))$\n\nB. $((1, 0, 0), (0, 1, 0))$\n\nC. $((0, 0, 0), (1, 0, 0))$\n\nD. $((1, 1, 0), (0, 1, 0))$\n\nE. $((0, 0, 1), (1, 0, 1))$",
            "solution": "定义同步布尔更新映射 $F:\\{0,1\\}^3 \\to \\{0,1\\}^3$ 如下：\n$$\nF(g_{1},g_{2},g_{3})=(\\neg g_{2},\\,\\neg g_{3},\\,\\neg g_{1}).\n$$\n吸引子是 $F$ 的周期轨道（包括可能的不动点）。\n\n首先，检验满足以下条件的不动点 $(g_{1},g_{2},g_{3})$：\n$$\ng_{1}=\\neg g_{2},\\quad g_{2}=\\neg g_{3},\\quad g_{3}=\\neg g_{1}.\n$$\n由 $g_{1}=\\neg g_{2}$ 和 $g_{2}=\\neg g_{3}$，可得 $g_{1}=\\neg(\\neg g_{3})=g_{3}$。结合 $g_{3}=\\neg g_{1}$ 得出 $g_{1}=\\neg g_{1}$，这是不可能的。因此，不存在不动点。\n\n接下来，通过从给定的像 $(g'_{1},g'_{2},g'_{3})$ 求解唯一的原像 $(g_{1},g_{2},g_{3})$ 来证明 $F$ 是双射的：\n$$\ng'_{1}=\\neg g_{2}\\Rightarrow g_{2}=\\neg g'_{1},\\quad\ng'_{2}=\\neg g_{3}\\Rightarrow g_{3}=\\neg g'_{2},\\quad\ng'_{3}=\\neg g_{1}\\Rightarrow g_{1}=\\neg g'_{3}.\n$$\n因此，$F$ 是这 8 个状态的一个排列，所以每个状态都位于一个环上（没有瞬态）。计算各个状态的像以确定这些环：\n- $F(0,0,0)=(1,1,1)$ 且 $F(1,1,1)=(0,0,0)$，得到一个 2-周期环 $\\{000,111\\}$。\n- 从 $(0,0,1)$ 开始：\n$$\n001\\to 101\\to 100\\to 110\\to 010\\to 011\\to 001,\n$$\n这是一个包含 $\\{001,011,010,110,100,101\\}$ 的 6-周期环。\n\n因此，恰好有两个吸引子：2-周期环 $\\{000,111\\}$ 和 6-周期环 $\\{001,011,010,110,100,101\\}$。因为 $F$ 是双射的，每个吸引子的吸引盆恰好是该吸引子上的状态集合。\n\n现在评估各个选项。汉明距离 $d_{H}(S_{A},S_{B})$ 是两个三元组中不同位置的数量。\n- A: $(000,111)$ 的 $d_{H}=3$，不是 $1$。\n- B: $(100,010)$ 的 $d_{H}=2$；两者都在 6-周期环的吸引盆中。\n- C: $(000,100)$ 的 $d_{H}=1$；$000$ 在 2-周期环的吸引盆中，$100$ 在 6-周期环的吸引盆中。\n- D: $(110,010)$ 的 $d_{H}=1$；两者都在 6-周期环的吸引盆中。\n- E: $(001,101)$ 的 $d_{H}=1$；两者都在 6-周期环的吸引盆中。\n\n只有选项 C 满足这两个条件。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "本练习将引导您从理论分析转向对一个更复杂的、具有生物学意义的系统进行计算建模。我们将探索一个简化的造血过程模型 ()，并重点考察同步与异步更新机制对系统最终细胞命运（即吸引子）的决定性影响。通过这个动手编程实践，您将掌握模拟布尔网络并解释其生物学意义的实用技能。",
            "id": "2376751",
            "problem": "给定一个离散基因调控布尔网络，旨在捕捉造血过程中的粗粒度谱系决定。布尔网络由一个有限节点集和每个节点的确定性更新函数组成。在时间 $t$ 的系统状态是一个向量 $\\mathbf{x}(t) \\in \\{0,1\\}^{n}$，其中 $n$ 是节点数，每个分量编码一个基因或调控因子的非激活 ($0$) 或激活 ($1$) 状态。每个节点 $i$ 都有一个布尔更新函数 $f_i:\\{0,1\\}^{n}\\to\\{0,1\\}$，全局更新规则在指定的更新方案下聚合这 $n$ 个逐节点的更新。考虑两种方案：同步更新和异步更新。在同步更新中，所有 $n$ 个节点在每个离散时间步 $t\\to t+1$ 同时更新，使用公式 $\\mathbf{x}(t+1)=\\left(f_1(\\mathbf{x}(t)),\\dots,f_n(\\mathbf{x}(t))\\right)$。在异步更新中，在每个微步中只有一个节点根据其函数进行更新，而其他节点保持其当前值；一个调度表指定了在每个微步中要更新哪个节点。在选定的更新方案下，状态转移图中的吸引子可以是不动点（周期为1的循环），也可以是极限环（周期为 $k$ 且 $k\\ge 2$ 的循环）。预测的细胞命运由从指定初始条件达到的吸引子定义。\n\n考虑以下由 $n=5$ 个节点组成的网络，其顺序为 $\\left[G,P,F,C,E\\right]$，分别代表 GATA$1$、PU.$1$、FOG$1$、CEBP$\\alpha$ 和 E$2$A。布尔更新规则如下：\n- $G^{+} = (G \\lor F)\\land \\neg P$，\n- $P^{+} = (P \\lor C)\\land \\neg G$，\n- $F^{+} = G$，\n- $C^{+} = P$，\n- $E^{+} = \\neg (G \\lor P)$,\n其中 $X^{+}$ 表示在所选更新方案下节点 $X$ 在下一个时间索引的值，$\\lor$ 是逻辑或，$\\land$ 是逻辑与，$\\neg$ 是逻辑非。\n\n预测的细胞命运根据吸引子映射如下。如果吸引子是一个不动点 $\\mathbf{x}^{\\star}$：\n- 红细胞系：如果 $G^{\\star}=1$ 且 $P^{\\star}=0$（编码为整数 $0$），\n- 髓系：如果 $G^{\\star}=0$ 且 $P^{\\star}=1$（编码为整数 $1$），\n- 淋巴系：如果 $G^{\\star}=0$ 且 $P^{\\star}=0$（编码为整数 $2$）。\n如果吸引子是极限环（周期 $k\\ge 2$）或其他模糊构型，则编码为整数 $3$。\n\n实现一个程序，对于下面的每个测试用例，根据上述网络和映射计算预测的命运代码（整数）。你的实现应满足：\n- 对于同步更新，迭代 $\\mathbf{x}(t+1)=\\mathbf{f}(\\mathbf{x}(t))$ 直到通过首次重复出现先前见过的状态来检测到吸引子。如果周期为 $1$，则按定义将 $\\mathbf{x}^{\\star}$ 映射到命运代码；如果周期大于 $1$，则返回 $3$。最多使用 $T_{\\max}=50$ 个步骤；如果届时未找到吸引子，则返回 $3$。\n- 对于异步更新，使用提供的节点索引调度表在每个微步更新一个节点。如果调度表长度为 $L$，则循环应用它（即，无限调度表中位置 $s$ 的索引是 $(s \\bmod L)$ 处的索引）。与同步情况一样检测和分类吸引子，同样使用 $T_{\\max}=50$ 的界限；如果届时未找到吸引子，则返回 $3$。\n\n测试套件。每个测试用例是一个元组，指明更新方案、初始条件以及（对于异步情况）调度表：\n- 测试用例 1：同步；初始 $\\mathbf{x}(0)=[1,0,1,0,0]$。\n- 测试用例 2：同步；初始 $\\mathbf{x}(0)=[0,1,0,1,0]$。\n- 测试用例 3：同步；初始 $\\mathbf{x}(0)=[0,0,0,0,0]$。\n- 测试用例 4：异步；初始 $\\mathbf{x}(0)=[1,1,1,1,0]$；调度表 $[0,2,3,4,1]$ 循环重复。\n- 测试用例 5：异步；初始 $\\mathbf{x}(0)=[1,1,1,1,0]$；调度表 $[1,3,4,0,2]$ 循环重复。\n\n你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[0,1,2,3,0]”）。每个元素必须是对应于上面所列顺序的测试用例的整数命运代码。不涉及物理单位。不使用角度。不使用百分比。唯一允许的输出类型是聚合成指定列表格式的整数。",
            "solution": "该问题要求模拟一个离散基因调控布尔网络，以根据其吸引子预测细胞命运。对问题陈述的验证发现其具有科学依据、问题良定且计算上可行。因此，我们将着手构建解决方案。\n\n该系统是一个具有 $n=5$ 个节点的布尔网络，代表造血过程中的关键调控因子。在任何离散时间 $t$ 的系统状态是一个向量 $\\mathbf{x}(t) \\in \\{0,1\\}^{5}$，其分量按顺序对应于基因 $[G, P, F, C, E]$。值为 $1$ 表示基因激活，值为 $0$ 表示基因非激活。\n\n网络的动力学由一组布尔更新函数控制，每个节点 $i$ 都有一个，表示为 $f_i:\\{0,1\\}^5 \\to \\{0,1\\}$。设状态向量为 $\\mathbf{x} = [x_0, x_1, x_2, x_3, x_4]$，对应于 $[G, P, F, C, E]$。更新规则如下：\n- $G^{+} = x_0^{+} = f_0(\\mathbf{x}) = (x_0 \\lor x_2) \\land \\neg x_1$\n- $P^{+} = x_1^{+} = f_1(\\mathbf{x}) = (x_1 \\lor x_3) \\land \\neg x_0$\n- $F^{+} = x_2^{+} = f_2(\\mathbf{x}) = x_0$\n- $C^{+} = x_3^{+} = f_3(\\mathbf{x}) = x_1$\n- $E^{+} = x_4^{+} = f_4(\\mathbf{x}) = \\neg (x_0 \\lor x_1)$\n此处，$\\lor$ 是逻辑或，$\\land$ 是逻辑与，$\\neg$ 是逻辑非。这些逻辑运算的结果必须解释为整数 $0$ 或 $1$。\n\n该问题指定了两种不同的更新方案：同步和异步。对于每种方案，我们都必须从给定的初始状态 $\\mathbf{x}(0)$ 开始模拟网络轨迹，以识别吸引子。吸引子是一个状态或一组状态，系统一旦进入就无法离开。它可以是不动点（一个映射到自身的状态，形成周期 $k=1$ 的循环），也可以是极限环（一个重复的状态序列，形成周期 $k \\ge 2$ 的循环）。\n\n两种方案算法的核心是迭代系统状态并维护一个已访问状态的历史记录，以检测状态何时重复。让我们使用一个字典来存储遇到的每个唯一状态向量及其首次访问的时间步。模拟最多进行 $T_{\\max}=50$ 个步骤。\n\n对于**同步更新方案**，所有五个节点函数都同时进行评估。系统在时间 $t+1$ 的状态由时间 $t$ 的状态计算如下：\n$$\n\\mathbf{x}(t+1) = \\mathbf{f}(\\mathbf{x}(t)) = [f_0(\\mathbf{x}(t)), f_1(\\mathbf{x}(t)), f_2(\\mathbf{x}(t)), f_3(\\mathbf{x}(t)), f_4(\\mathbf{x}(t))]\n$$\n模拟过程如下：\n1. 在时间 $t=0$ 时，用给定的状态 $\\mathbf{x}(0)$ 初始化。\n2. 将 $\\mathbf{x}(0)$ 存储在历史记录中：`history[tuple(x(0))] = 0`。\n3. 对于 $t$ 从 $0$ 到 $T_{\\max}-1$：\n   a. 计算下一个状态，$\\mathbf{x}_{next} = \\mathbf{f}(\\mathbf{x}(t))$。\n   b. 检查 $\\mathbf{x}_{next}$ 是否出现过（即 `tuple(x_next)` 是否在 `history` 中）。\n   c. 如果是，则找到了一个吸引子。设 $t_{prev}$ 是为 $\\mathbf{x}_{next}$ 存储的时间步。循环的周期是 $k = (t+1) - t_{prev}$。\n   d. 如果否，则将 $\\mathbf{x}_{next}$ 添加到历史记录中：`history[tuple(x_next)] = t+1`，并设置 $\\mathbf{x}(t+1) = \\mathbf{x}_{next}$。\n4. 如果循环完成而没有找到循环，则结果被认为是模糊的。\n\n对于**异步更新方案**，每个微步只更新一个节点，由给定的调度表决定。调度表是一个循环重复的节点索引序列。设调度表为 $S$，长度为 $L$。\n1. 在微步 $s=0$ 时，用给定的状态 $\\mathbf{x}(0)$ 初始化。\n2. 将 $\\mathbf{x}(0)$ 存储在历史记录中：`history[tuple(x(0))] = 0`。\n3. 对于 $s$ 从 $0$ 到 $T_{\\max}-1$：\n   a. 确定要更新的节点：$i = S[s \\bmod L]$。\n   b. 仅计算该节点的新值：$x'_{i} = f_i(\\mathbf{x}(s))$。\n   c. 通过复制 $\\mathbf{x}(s)$ 并将其第 $i$ 个分量设置为 $x'_{i}$ 来形成下一个状态 $\\mathbf{x}(s+1)$。\n   d. 循环检测逻辑与同步情况相同，使用微步索引 $s$ 代替 $t$。\n\n一旦识别出吸引子，就必须对其进行分类以确定细胞命运。\n- 如果吸引子是不动点（周期 $k=1$），则其状态向量 $\\mathbf{x}^{\\star} = [G^{\\star}, P^{\\star}, F^{\\star}, C^{\\star}, E^{\\star}]$ 用于映射。\n  - 红细胞系（代码 $0$）：如果 $G^{\\star}=1$ 且 $P^{\\star}=0$。\n  - 髓系（代码 $1$）：如果 $G^{\\star}=0$ 且 $P^{\\star}=1$。\n  - 淋巴系（代码 $2$）：如果 $G^{\\star}=0$ 且 $P^{\\star}=0$。\n- 如果吸引子是极限环（周期 $k \\ge 2$）或者在 $T_{\\max}$ 步内没有找到吸引子，则命运是模糊的（代码 $3$）。值得注意的是，对于大小为 $2^5=32$ 的状态空间，任何轨迹都必须在 32 步内重复一个状态，因此 $T_{\\max}=50$ 的限制是绰绰有余的。\n\n让我们追踪**测试用例4**：异步更新，$\\mathbf{x}(0)=[1,1,1,1,0]$，调度表为 $[0,2,3,4,1]$。\n- 状态表示：$[G, P, F, C, E]$。\n- $s=0$ 时的初始状态：$\\mathbf{x}_0 = [1,1,1,1,0]$。历史记录：$\\{ (1,1,1,1,0): 0 \\}$。\n- 微步 $s=1$（更新索引 $0$，节点 $G$）：$G^{+} = (1 \\lor 1) \\land \\neg 1 = 0$。新状态 $\\mathbf{x}_1 = [0,1,1,1,0]$。历史记录：$\\{ \\dots, (0,1,1,1,0): 1 \\}$。\n- 微步 $s=2$（更新索引 $2$，节点 $F$）：$F^{+} = G = 0$。新状态 $\\mathbf{x}_2 = [0,1,0,1,0]$。历史记录：$\\{ \\dots, (0,1,0,1,0): 2 \\}$。\n- 微步 $s=3$（更新索引 $3$，节点 $C$）：$C^{+} = P = 1$。新状态 $\\mathbf{x}_3 = [0,1,0,1,0]$。\n- 此时，生成的状态 $\\mathbf{x}_3$ 已经出现过。它在微步 $s_{prev}=2$ 时被首次记录。\n- 周期为 $k = (\\text{当前步索引}) - s_{prev} = 3 - 2 = 1$。吸引子是一个不动点。\n- 不动点状态为 $\\mathbf{x}^{\\star} = [0,1,0,1,0]$。\n- 将此映射到命运：$G^{\\star}=0, P^{\\star}=1$ 对应于髓系，其代码为 $1$。\n实现将对所有测试用例遵循此逻辑。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Boolean network simulation problem for a given set of test cases.\n    \"\"\"\n\n    T_max = 50\n\n    def get_update_vector(state):\n        \"\"\"\n        Computes the full next state vector for synchronous update.\n        state: [G, P, F, C, E]\n        \"\"\"\n        x = state\n        g_next = (x[0] or x[2]) and not x[1]\n        p_next = (x[1] or x[3]) and not x[0]\n        f_next = x[0]\n        c_next = x[1]\n        e_next = not (x[0] or x[1])\n        return np.array([g_next, p_next, f_next, c_next, e_next], dtype=int)\n\n    def get_single_update(state, node_index):\n        \"\"\"\n        Computes the updated value for a single node.\n        \"\"\"\n        x = state\n        if node_index == 0:  # G\n            return (x[0] or x[2]) and not x[1]\n        elif node_index == 1:  # P\n            return (x[1] or x[3]) and not x[0]\n        elif node_index == 2:  # F\n            return x[0]\n        elif node_index == 3:  # C\n            return x[1]\n        elif node_index == 4:  # E\n            return not (x[0] or x[1])\n        return x[node_index] # Should not be reached\n\n    def get_fate_code(state_vector):\n        \"\"\"\n        Maps a fixed point attractor state to a fate code.\n        \"\"\"\n        g_star, p_star = state_vector[0], state_vector[1]\n        if g_star == 1 and p_star == 0:\n            return 0  # Erythroid\n        if g_star == 0 and p_star == 1:\n            return 1  # Myeloid\n        if g_star == 0 and p_star == 0:\n            return 2  # Lymphoid\n        # According to the problem analysis, this case should not be reached\n        # for a fixed point of the given network.\n        return 3 # Ambiguous\n\n    def simulate_synchronous(initial_state):\n        \"\"\"\n        Simulates the network using synchronous updates.\n        \"\"\"\n        current_state = np.array(initial_state, dtype=int)\n        history = {tuple(current_state): 0}\n\n        for t in range(T_max):\n            next_state = get_update_vector(current_state)\n            \n            if tuple(next_state) in history:\n                t_prev = history[tuple(next_state)]\n                period = (t + 1) - t_prev\n                if period == 1:\n                    return get_fate_code(next_state)\n                else:\n                    return 3  # Limit cycle\n            \n            history[tuple(next_state)] = t + 1\n            current_state = next_state\n        \n        return 3 # No attractor found within T_max\n\n    def simulate_asynchronous(initial_state, schedule):\n        \"\"\"\n        Simulates the network using asynchronous updates based on a schedule.\n        \"\"\"\n        current_state = np.array(initial_state, dtype=int)\n        history = {tuple(current_state): 0}\n        schedule_len = len(schedule)\n\n        for s in range(T_max):\n            node_to_update = schedule[s % schedule_len]\n            \n            next_state = current_state.copy()\n            updated_val = get_single_update(current_state, node_to_update)\n            next_state[node_to_update] = int(updated_val)\n            \n            if tuple(next_state) in history:\n                s_prev = history[tuple(next_state)]\n                period = (s + 1) - s_prev\n                if period == 1:\n                    return get_fate_code(next_state)\n                else:\n                    return 3  # Limit cycle\n            \n            history[tuple(next_state)] = s + 1\n            current_state = next_state\n            \n        return 3 # No attractor found within T_max\n\n    test_cases = [\n        {'type': 'sync', 'initial': [1, 0, 1, 0, 0]},\n        {'type': 'sync', 'initial': [0, 1, 0, 1, 0]},\n        {'type': 'sync', 'initial': [0, 0, 0, 0, 0]},\n        {'type': 'async', 'initial': [1, 1, 1, 1, 0], 'schedule': [0, 2, 3, 4, 1]},\n        {'type': 'async', 'initial': [1, 1, 1, 1, 0], 'schedule': [1, 3, 4, 0, 2]},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'sync':\n            result = simulate_synchronous(case['initial'])\n        else: # async\n            result = simulate_asynchronous(case['initial'], case['schedule'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}