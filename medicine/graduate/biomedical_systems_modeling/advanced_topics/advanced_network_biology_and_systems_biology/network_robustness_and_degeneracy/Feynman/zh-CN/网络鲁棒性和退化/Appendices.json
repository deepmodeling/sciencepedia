{
    "hands_on_practices": [
        {
            "introduction": "生物系统在充满噪声的环境中运行，其内部参数很少是固定不变的。鲁棒性的一个关键方面是对这些微小波动的非敏感性。这项实践  介绍了一种量化这种鲁棒性的基本分析方法。你将学习如何在一个工作点附近对系统响应进行线性化，并利用雅可比矩阵推导参数噪声的协方差如何传播到系统输出的方差，从而为局部稳定性提供一个具体的度量。",
            "id": "3909340",
            "problem": "考虑一个从参数向量 $p \\in \\mathbb{R}^{3}$到输出向量 $y \\in \\mathbb{R}^{2}$的可微映射，记为 $y = f(p)$，它代表一个双读出生物医学信号模块的归一化稳态输出。设 $p^{\\star}$ 是通过校准实验得到的标称参数工作点，并将小的参数波动建模为零均值多元正态分布 (MVN) $p = p^{\\star} + \\delta p$，其协方差矩阵为 $\\Sigma_{p} \\in \\mathbb{R}^{3 \\times 3}$。假设映射 $f$ 足够光滑，使得在 $p^{\\star}$ 的一个邻域内一阶泰勒线性化有效，并将 $p^{\\star}$ 处的雅可比矩阵记为 $J = \\left.\\frac{\\partial f}{\\partial p}\\right|_{p^{\\star}} \\in \\mathbb{R}^{2 \\times 3}$。\n\n从基本原理（泰勒线性化和协方差的定义）出发，推导输出协方差矩阵 $\\Sigma_{y}$ 关于 $J$ 和 $\\Sigma_{p}$ 的表达式。然后，对于特定情况\n$$\nJ = \\begin{pmatrix}\n0.5  -0.3  0.0 \\\\\n0.1  0.2  0.4\n\\end{pmatrix},\n\\qquad\n\\Sigma_{p} = \\begin{pmatrix}\n0.04  0.012  0.0 \\\\\n0.012  0.09  -0.006 \\\\\n0.0  -0.006  0.01\n\\end{pmatrix},\n$$\n计算输出协方差矩阵 $\\Sigma_{y}$，并使用标量度量 $R = \\operatorname{tr}(\\Sigma_{y})$（即线性化模型下输出偏差的期望平方幅值）来量化对参数噪声的鲁棒性。\n\n报告 $R$ 的数值，四舍五入到四位有效数字。由于输出是归一化的，将 $R$ 视为无量纲，不附加单位。你的最终答案必须是一个实数。",
            "solution": "经评估，问题陈述是有效的。它在科学上基于非线性系统的灵敏度分析和误差传播原理。该问题是适定的，为获得唯一解提供了所有必要的数据和定义。给定的数值是一致且合理的，因为所提供的协方差矩阵 $\\Sigma_p$ 是对称正定的。该问题是客观的，没有歧义。\n\n求解过程分为两部分。首先，我们在线性近似下推导输出协方差矩阵 $\\Sigma_y$ 的通用表达式。其次，我们将此公式应用于给定的特定矩阵，以计算鲁棒性度量 $R$。\n\n### 第1部分：输出协方差矩阵的推导\n\n给定一个可微映射 $y = f(p)$，其中 $p \\in \\mathbb{R}^{3}$ 是参数向量， $y \\in \\mathbb{R}^{2}$ 是输出向量。参数围绕一个标称工作点 $p^{\\star}$ 波动，关系为 $p = p^{\\star} + \\delta p$。波动 $\\delta p$ 被建模为具有协方差矩阵 $\\Sigma_{p}$ 的零均值多元正态分布。因此，我们有以下统计特性：\n$$E[\\delta p] = 0$$\n$$\\text{Cov}(\\delta p) = E[(\\delta p - E[\\delta p])(\\delta p - E[\\delta p])^{T}] = E[\\delta p (\\delta p)^{T}] = \\Sigma_{p}$$\n\n输出 $y$ 将围绕其标称值 $y^{\\star} = f(p^{\\star})$ 波动。我们可以使用 $f(p)$ 在 $p^{\\star}$ 附近的一阶泰勒级数展开来近似输出波动 $\\delta y = y - y^{\\star}$：\n$$y = f(p) = f(p^{\\star} + \\delta p) \\approx f(p^{\\star}) + \\left.\\frac{\\partial f}{\\partial p}\\right|_{p^{\\star}} \\delta p$$\n令 $J = \\left.\\frac{\\partial f}{\\partial p}\\right|_{p^{\\star}}$ 为在标称点计算的映射的雅可比矩阵。近似变为：\n$$y \\approx y^{\\star} + J \\delta p$$\n这意味着输出与标称值的偏差约等于参数偏差的线性函数：\n$$\\delta y = y - y^{\\star} \\approx J \\delta p$$\n我们现在推导输出向量 $y$ 的协方差矩阵，记为 $\\Sigma_{y} = \\text{Cov}(y)$。 $y$ 的期望值为：\n$$E[y] \\approx E[y^{\\star} + J \\delta p] = y^{\\star} + J E[\\delta p] = y^{\\star} + J \\cdot 0 = y^{\\star}$$\n利用这一点，协方差矩阵 $\\Sigma_{y}$ 可以计算如下：\n$$\\Sigma_{y} = E[(y - E[y])(y - E[y])^{T}]$$\n代入 $E[y]$ 的近似值和偏差 $y - E[y] \\approx J \\delta p$：\n$$\\Sigma_{y} \\approx E[(J \\delta p)(J \\delta p)^{T}]$$\n使用转置性质 $(AB)^{T} = B^{T}A^{T}$，我们有：\n$$\\Sigma_{y} \\approx E[J (\\delta p) (\\delta p)^{T} J^{T}]$$\n由于雅可比矩阵 $J$ 是一个常数矩阵（在不动点 $p^{\\star}$ 处计算），它可以从期望中提出来：\n$$\\Sigma_{y} \\approx J E[\\delta p (\\delta p)^{T}] J^{T}$$\n我们识别出期望内的项是参数的协方差矩阵，即 $\\Sigma_{p} = E[\\delta p (\\delta p)^{T}]$。因此，在此线性近似下，输出协方差矩阵的表达式为：\n$$\\Sigma_{y} = J \\Sigma_{p} J^{T}$$\n\n### 第2部分：鲁棒性度量 $R$ 的计算\n\n我们被给予了雅可比矩阵和参数协方差的具体矩阵：\n$$J = \\begin{pmatrix} 0.5  -0.3  0.0 \\\\ 0.1  0.2  0.4 \\end{pmatrix}, \\qquad \\Sigma_{p} = \\begin{pmatrix} 0.04  0.012  0.0 \\\\ 0.012  0.09  -0.006 \\\\ 0.0  -0.006  0.01 \\end{pmatrix}$$\n雅可比矩阵 $J$ 的转置是：\n$$J^{T} = \\begin{pmatrix} 0.5  0.1 \\\\ -0.3  0.2 \\\\ 0.0  0.4 \\end{pmatrix}$$\n首先，我们计算矩阵乘积 $J \\Sigma_{p}$：\n$$J \\Sigma_{p} = \\begin{pmatrix} 0.5  -0.3  0.0 \\\\ 0.1  0.2  0.4 \\end{pmatrix} \\begin{pmatrix} 0.04  0.012  0.0 \\\\ 0.012  0.09  -0.006 \\\\ 0.0  -0.006  0.01 \\end{pmatrix}$$\n$$J \\Sigma_{p} = \\begin{pmatrix} (0.5)(0.04) + (-0.3)(0.012) + (0.0)(0.0)  (0.5)(0.012) + (-0.3)(0.09) + (0.0)(-0.006)  (0.5)(0.0) + (-0.3)(-0.006) + (0.0)(0.01) \\\\ (0.1)(0.04) + (0.2)(0.012) + (0.4)(0.0)  (0.1)(0.012) + (0.2)(0.09) + (0.4)(-0.006)  (0.1)(0.0) + (0.2)(-0.006) + (0.4)(0.01) \\end{pmatrix}$$\n$$J \\Sigma_{p} = \\begin{pmatrix} 0.02 - 0.0036  0.006 - 0.027  0.0018 \\\\ 0.004 + 0.0024  0.0012 + 0.018 - 0.0024  -0.0012 + 0.004 \\end{pmatrix}$$\n$$J \\Sigma_{p} = \\begin{pmatrix} 0.0164  -0.021  0.0018 \\\\ 0.0064  0.0168  0.0028 \\end{pmatrix}$$\n接下来，我们计算 $\\Sigma_{y} = (J \\Sigma_{p}) J^{T}$：\n$$\\Sigma_{y} = \\begin{pmatrix} 0.0164  -0.021  0.0018 \\\\ 0.0064  0.0168  0.0028 \\end{pmatrix} \\begin{pmatrix} 0.5  0.1 \\\\ -0.3  0.2 \\\\ 0.0  0.4 \\end{pmatrix}$$\n$$\\Sigma_{y} = \\begin{pmatrix} (0.0164)(0.5) + (-0.021)(-0.3) + (0.0018)(0.0)  (0.0164)(0.1) + (-0.021)(0.2) + (0.0018)(0.4) \\\\ (0.0064)(0.5) + (0.0168)(-0.3) + (0.0028)(0.0)  (0.0064)(0.1) + (0.0168)(0.2) + (0.0028)(0.4) \\end{pmatrix}$$\n$$\\Sigma_{y} = \\begin{pmatrix} 0.0082 + 0.0063  0.00164 - 0.0042 + 0.00072 \\\\ 0.0032 - 0.00504  0.00064 + 0.00336 + 0.00112 \\end{pmatrix}$$\n$$\\Sigma_{y} = \\begin{pmatrix} 0.0145  -0.00184 \\\\ -0.00184  0.00512 \\end{pmatrix}$$\n鲁棒性度量 $R$ 定义为输出协方差矩阵的迹，即 $R = \\operatorname{tr}(\\Sigma_{y})$。迹是对角线元素之和。\n$$R = 0.0145 + 0.00512 = 0.01962$$\n问题要求答案四舍五入到四位有效数字。数字 $0.01962$ 有四位有效数字（$1$、$9$、$6$、$2$）。下一位数字是隐含的零。因此，不需要四舍五入。\n鲁棒性度量的值是 $0.01962$。该度量代表了输出偏差的期望平方幅值 $E[||\\delta y||^2]$，并作为总输出方差的度量。较小的 $R$ 值意味着对参数噪声具有更强的鲁棒性。",
            "answer": "$$\\boxed{0.01962}$$"
        },
        {
            "introduction": "除了微小的参数波动，生物网络还必须能够承受更剧烈的扰动，例如基因完全丢失及其对应的酶功能失效。这项实践  使用通量平衡分析 (Flux Balance Analysis, FBA) 这一强大框架，将研究重点从局部敏感性转移到大规模的结构鲁棒性。通过在代谢网络中计算模拟单反应敲除，你将通过确定在敲除后仍能实现关键生物学功能（如生物质生成）的比例，来量化网络的恢复能力。",
            "id": "3909395",
            "problem": "考虑一个稳态代谢网络，其由化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 和通量向量 $v \\in \\mathbb{R}^{n}$ 表示，并受到质量平衡约束 $S v = 0$ 和边界约束 $l \\le v \\le u$ 的限制，其中 $l, u \\in \\mathbb{R}^{n}$ 分别是每个反应的下界和上界。通量平衡分析 (FBA) 被构建为一个线性优化问题，其目标是在满足约束 $S v = 0$ 和 $l \\le v \\le u$ 的条件下，最大化生物质生产目标 $c^{\\top} v$，其中 $c \\in \\mathbb{R}^{n}$ 用于选择产生生物质的反应。对于一个最小生物质通量阈值 $f_{\\min} \\in \\mathbb{R}_{\\ge 0}$，我们将对单反应敲除的鲁棒性定义为：在一个指定的敲除集 $\\mathcal{K} \\subseteq \\{0,1,\\dots,n-1\\}$ 中，存在一个可行通量 $v$（在敲除条件下，即通过将相应通量 $v_i$ 固定为 $0$ 来实现）使得 $c^{\\top} v \\ge f_{\\min}$ 成立的反应所占的比例。形式上，对于一个给定的测试用例，\n$$\nR \\equiv \\frac{1}{|\\mathcal{K}|} \\sum_{i \\in \\mathcal{K}} \\mathbf{1}\\left(\\exists v \\text{ such that } S v = 0,\\; l \\le v \\le u,\\; v_i = 0,\\; c^{\\top} v \\ge f_{\\min}\\right),\n$$\n其中，如果条件为真，$\\mathbf{1}(\\cdot)$ 为 $1$，否则为 $0$，而 $|\\mathcal{K}|$ 是 $\\mathcal{K}$ 的基数。所有通量和阈值都使用任意一致的通量单位，因此不需要进行物理单位转换。\n\n你的任务是编写一个完整的程序，为以下四个玩具网络测试用例中的每一个计算 $R$。在每个用例中，程序必须针对每个单反应敲除 $i \\in \\mathcal{K}$ 求解一个在指定约束下最大化 $c^{\\top} v$ 的 FBA 问题，然后检查其最优值是否至少为 $f_{\\min}$。在比较 $c^{\\top} v$ 与 $f_{\\min}$ 时，请使用 $10^{-9}$ 的数值容差，以考虑求解器的精度问题。每个测试用例的最终结果必须以 $[0,1]$ 范围内的浮点数形式返回，该值等于成功敲除的反应所占的比例。\n\n测试用例 1 (具有充足容量的平行冗余通路):\n- 内部代谢物为两个物种，因此 $m = 2$，有 $n = 4$ 个反应，索引为 $0,1,2,3$。化学计量矩阵为\n$$\nS = \\begin{bmatrix}\n1 & -1 & -1 & 0 \\\\\n0 & 0 & 1 & -1\n\\end{bmatrix},\n$$\n其中列分别对应于反应 $0,1,2,3$。边界为\n$$\nl = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\nu = \\begin{bmatrix} 10 \\\\ 1000 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n$$\n目标向量为\n$$\nc = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 1 \\end{bmatrix},\n$$\n因此生物质目标等于 $v_1 + v_3$。敲除集为\n$$\n\\mathcal{K} = \\{0,1,2,3\\}.\n$$\n最小生物质阈值为\n$$\nf_{\\min} = 5.\n$$\n\n测试用例 2 (无冗余的单条线性通路):\n- 内部代谢物为两个物种，因此 $m = 2$，有 $n = 3$ 个反应，索引为 $0,1,2$。化学计量矩阵为\n$$\nS = \\begin{bmatrix}\n1 & -1 & 0 \\\\\n0 & 1 & -1\n\\end{bmatrix},\n$$\n分别对应反应 $0,1,2$。边界为\n$$\nl = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\nu = \\begin{bmatrix} 10 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n$$\n目标向量为\n$$\nc = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix},\n$$\n因此生物质目标等于 $v_2$。敲除集为\n$$\n\\mathcal{K} = \\{0,1,2\\}.\n$$\n最小生物质阈值为\n$$\nf_{\\min} = 5.\n$$\n\n测试用例 3 (平行冗余通路，阈值等于未敲除时的最优值):\n- 在 $S$、$l$、$u$、$c$ 和 $\\mathcal{K}$ 方面与测试用例 1 相同。唯一的区别是最小生物质阈值\n$$\nf_{\\min} = 10.\n$$\n\n测试用例 4 (各分支具有容量限制的平行通路):\n- 内部代谢物为两个物种，因此 $m = 2$，有 $n = 4$ 个反应，索引为 $0,1,2,3$。化学计量矩阵为\n$$\nS = \\begin{bmatrix}\n1 & -1 & -1 & 0 \\\\\n0 & 0 & 1 & -1\n\\end{bmatrix}.\n$$\n边界为\n$$\nl = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\nu = \\begin{bmatrix} 10 \\\\ 8 \\\\ 1000 \\\\ 6 \\end{bmatrix},\n$$\n因此反应 $1$ 的上界为 $8$，反应 $3$ 的上界为 $6$。目标向量为\n$$\nc = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 1 \\end{bmatrix},\n$$\n敲除集为\n$$\n\\mathcal{K} = \\{0,1,2,3\\}.\n$$\n最小生物质阈值为\n$$\nf_{\\min} = 9.\n$$\n\n请实现程序以完全按照规定求解每个测试用例。你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按上述测试用例的顺序列出，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是为测试用例 $i$ 计算出的鲁棒性值，以 $[0,1]$ 范围的小数表示。",
            "solution": "问题陈述经评估是有效的。它在科学上基于通量平衡分析（FBA）的既定原则，FBA 是系统生物学中分析代谢网络的标准方法。该问题是适定的，为四个不同且可解的测试用例提供了所有必要的数学定义、约束和数据。其语言客观、精确，任务在计算上是可行的。\n\n问题的核心是计算代谢网络在一系列单反应敲除下的鲁棒性 $R$。该指标定义为：在敲除集 $\\mathcal{K}$ 中，网络仍能产生大于或等于最小阈值 $f_{\\min}$ 的生物质通量的敲除所占的比例。这种通量分布的存在性是通过为每次敲除求解一个 FBA 问题来确定的。\n\n其基本原理是，在稳态假设下，一个拥有 $m$ 个内部代谢物和 $n$ 个反应的代谢网络，其通量 $v \\in \\mathbb{R}^n$ 必须满足质量平衡方程 $S v = 0$，其中 $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵。此外，通量还受到下界和上界 $l \\le v \\le u$ 的约束。FBA 使用线性规划 (LP) 来寻找一个通量向量 $v$，该向量在满足这些约束的同时，能最大化一个细胞目标函数，通常是表示为 $c^{\\top} v$ 的生物质生产。\n\n每个测试用例的分析步骤如下：\n1.  将成功敲除的计数器 $N_{success}$ 初始化为 $0$。\n2.  对于指定敲除集 $\\mathcal{K}$ 中的每个反应索引 $i$：\n    a. 构建一个 LP 问题，以找到在敲除条件下的最大可能生物质通量。反应 $i$ 的敲除是通过将其通量约束为零（即 $v_i = 0$）来实现的。\n    b. 因此，LP 问题为：\n    $$\n    \\begin{array}{ll}\n    \\underset{v}{\\text{maximize}} & z = c^{\\top} v \\\\\n    \\text{subject to} & S v = 0 \\\\\n    & l_j \\le v_j \\le u_j \\quad \\forall j \\neq i \\\\\n    & v_i = 0\n    \\end{array}\n    $$\n    c. 这个最大化问题使用标准的 LP 求解器来求解。在计算上，这通常被表述为一个最小化问题。最大化 $c^{\\top}v$ 等同于最小化 $(-c)^{\\top}v$。约束被传递给求解器：$S$ 作为等式约束矩阵 `A_eq`，一个零向量作为等式约束向量 `b_eq`，通量边界 $l \\le v \\le u$ 作为 `bounds` 参数。敲除约束 $v_i=0$ 通过将 $v_i$ 的特定边界设置为 $(0, 0)$ 来高效处理。\n    d. 设求解器为最小化问题返回的最优目标值为 $z^*_{\\min}$。那么最大生物质产量就是 $z^*_{\\max} = -z^*_{\\min}$。\n    e. 将此最大生物质值与阈值 $f_{\\min}$进行比较。为了考虑数值求解器可能产生的浮点数不精确性，使用了一个容差 $\\epsilon = 10^{-9}$。如果求解器找到了一个可行解，并且 $z^*_{\\max} \\ge f_{\\min} - \\epsilon$，则认为该敲除是可存活的，计数器 $N_{success}$ 加一。\n3.  在遍历完 $\\mathcal{K}$ 中的所有敲除后，鲁棒性 $R$ 计算为成功敲除的次数与执行的总敲除次数之比：\n    $$\n    R = \\frac{N_{success}}{|\\mathcal{K}|}\n    $$\n此过程将应用于四个测试用例中的每一个，使用它们各自的参数（$S$、$l$、$u$、$c$、$\\mathcal{K}$ 和 $f_{\\min}$）来生成最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, compute robustness for each,\n    and print the results in the specified format.\n    \"\"\"\n    # Numerical tolerance for comparing biomass flux to the threshold.\n    TOLERANCE = 1e-9\n\n    # Definition of the four test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Test Case 1\",\n            \"S\": np.array([[1, -1, -1, 0], [0, 0, 1, -1]]),\n            \"l\": np.array([0, 0, 0, 0]),\n            \"u\": np.array([10, 1000, 1000, 1000]),\n            \"c\": np.array([0, 1, 0, 1]),\n            \"K\": {0, 1, 2, 3},\n            \"f_min\": 5.0,\n        },\n        {\n            \"name\": \"Test Case 2\",\n            \"S\": np.array([[1, -1, 0], [0, 1, -1]]),\n            \"l\": np.array([0, 0, 0]),\n            \"u\": np.array([10, 1000, 1000]),\n            \"c\": np.array([0, 0, 1]),\n            \"K\": {0, 1, 2},\n            \"f_min\": 5.0,\n        },\n        {\n            \"name\": \"Test Case 3\",\n            \"S\": np.array([[1, -1, -1, 0], [0, 0, 1, -1]]),\n            \"l\": np.array([0, 0, 0, 0]),\n            \"u\": np.array([10, 1000, 1000, 1000]),\n            \"c\": np.array([0, 1, 0, 1]),\n            \"K\": {0, 1, 2, 3},\n            \"f_min\": 10.0,\n        },\n        {\n            \"name\": \"Test Case 4\",\n            \"S\": np.array([[1, -1, -1, 0], [0, 0, 1, -1]]),\n            \"l\": np.array([0, 0, 0, 0]),\n            \"u\": np.array([10, 8, 1000, 6]),\n            \"c\": np.array([0, 1, 0, 1]),\n            \"K\": {0, 1, 2, 3},\n            \"f_min\": 9.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        robustness = compute_robustness(\n            S=case[\"S\"],\n            l=case[\"l\"],\n            u=case[\"u\"],\n            c=case[\"c\"],\n            K=case[\"K\"],\n            f_min=case[\"f_min\"],\n            tol=TOLERANCE\n        )\n        results.append(robustness)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_robustness(S, l, u, c, K, f_min, tol):\n    \"\"\"\n    Computes the robustness for a single metabolic network configuration.\n\n    Args:\n        S (np.ndarray): Stoichiometric matrix (m x n).\n        l (np.ndarray): Lower bounds for fluxes (n,).\n        u (np.ndarray): Upper bounds for fluxes (n,).\n        c (np.ndarray): Objective vector (n,).\n        K (set): Set of reaction indices to knock out.\n        f_min (float): Minimum biomass flux threshold.\n        tol (float): Numerical tolerance for comparison.\n\n    Returns:\n        float: The computed robustness value R.\n    \"\"\"\n    successful_knockouts = 0\n    num_reactions = S.shape[1]\n    \n    # Objective for minimization: -c to maximize c'v\n    c_solver = -c\n    \n    # Equality constraints: Sv = 0\n    A_eq = S\n    b_eq = np.zeros(S.shape[0])\n\n    for i in K:\n        # Create the bounds for the fluxes for this knockout simulation.\n        # It's a list of (min, max) tuples.\n        bounds = list(zip(l, u))\n        \n        # Apply the knockout by setting the flux bounds to (0, 0)\n        if 0 = i  num_reactions:\n            bounds[i] = (0, 0)\n        else:\n            # This case should not happen with valid input but is good practice.\n            continue\n            \n        # Solve the linear programming problem\n        res = linprog(c=c_solver, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        # Check if a feasible solution was found that meets the threshold\n        if res.success:\n            # The result from linprog is the minimum. We need the maximum.\n            max_biomass = -res.fun\n            if max_biomass >= f_min - tol:\n                successful_knockouts += 1\n\n    # Calculate robustness R\n    if not K:\n        return 0.0\n    \n    return successful_knockouts / len(K)\n\nsolve()\n```"
        },
        {
            "introduction": "前一个练习中观察到的结构鲁棒性通常源于简并性：即存在多条不同的内部途径可以实现相同的系统级功能。这项实践  通过探索代谢网络的解空间来深入研究这一核心机制。你将实现字典序优化（lexicographic optimization），这是一种先进的 FBA 技术，用以系统地揭示这些能够达到相同最优生物学目标的不同最优通量分布，为我们理解简并性如何赋予代谢灵活性和恢复能力提供了一个切实的范例。",
            "id": "3909353",
            "problem": "考虑一个处于稳态的代谢网络的通量平衡分析（FBA）公式，其中通量向量表示为 $\\mathbf{v} \\in \\mathbb{R}^n$，化学计量矩阵表示为 $\\mathbf{S} \\in \\mathbb{R}^{m \\times n}$。稳态施加了约束 $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$。通量边界由下界 $\\mathbf{l} \\in \\mathbb{R}^n$ 和上界 $\\mathbf{u} \\in \\mathbb{R}^n$ 给出，形成逐分量的箱式约束 $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$。生物学目标由一个系数向量 $\\mathbf{c} \\in \\mathbb{R}^n$ 编码，标准的 FBA 目标是在约束条件下最大化 $\\mathbf{c}^\\top \\mathbf{v}$。当多个不同的通量分布达到相同的最大生物量目标值时，替代最优解表明代谢功能存在简并性。为了从结构上探究简并性，可以使用字典序优化：首先最大化 $\\mathbf{c}^\\top \\mathbf{v}$ 以获得最大值 $z^\\star$，然后施加等式约束 $\\mathbf{c}^\\top \\mathbf{v} = z^\\star$，接着根据一个优先级顺序依次最小化 $\\mathbf{v}$ 的分量。当存在替代最优解时，此过程会选择不同的路径集。\n\n实现一个程序，对下面的每个测试网络执行以下步骤：\n- 求解原始线性规划问题，在满足 $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ 和 $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$ 的约束下最大化 $\\mathbf{c}^\\top \\mathbf{v}$，得到最优值 $z^\\star$ 和一个最优通量向量 $\\mathbf{v}^\\star$。\n- 对于每个给定的字典序优先级序列（每个序列是一个有序的反应索引列表），按如下方式执行序列化最小化：从由 $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$、$\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$ 和 $\\mathbf{c}^\\top \\mathbf{v} = z^\\star$ 定义的可行集开始，最小化 $v_{i_1}$；然后施加等式 $v_{i_1} = v_{i_1}^{\\min}$ 并最小化 $v_{i_2}$；依此进行，直到序列中的所有索引都按顺序被最小化，每次都添加等式约束，将先前最小化的分量固定为其已达到的最小值。将该序列的最终通量向量表示为 $\\mathbf{v}^{\\mathrm{lex}}$。\n- 将给定序列的路径集定义为指定路径索引列表中，其在 $\\mathbf{v}^{\\mathrm{lex}}$ 中的通量超过阈值 $\\epsilon$ 的索引集合，其中 $\\epsilon$ 必须设置为 $\\epsilon = 10^{-9}$。\n- 对于每个测试网络，收集所有给定的优先级序列得到的路径集，去除重复项，并报告不同路径集的数量。始终使用从零开始的反应索引（即，第一个反应的索引为 $0$，第二个为 $1$，依此类推）。\n\n您必须以纯数学的方式使用线性规划来实现上述过程。所有计算都是无量纲的；不需要物理单位。不涉及角度。不需要百分比。\n\n测试套件：\n- 测试用例 $1$（两个并行转化）：\n  - 反应：$v_0$（摄取），$v_1$ 和 $v_2$（两个并行转化），$v_3$（生物量流出）。\n  - 代谢物：$m_1$，$m_2$。\n  - 化学计量矩阵 $\\mathbf{S} \\in \\mathbb{R}^{2 \\times 4}$：\n    $$\n    \\mathbf{S} = \\begin{bmatrix}\n    1  -1  -1  0 \\\\\n    0  1  1  -1\n    \\end{bmatrix}\n    $$\n  - 边界：$\\mathbf{l} = [0, 0, 0, 0]$，$\\mathbf{u} = [6, 100, 100, 100]$。\n  - 目标系数：$\\mathbf{c} = [0, 0, 0, 1]$。\n  - 字典序优先级序列：$[1, 2]$ 和 $[2, 1]$。\n  - 在支持集中考虑的路径索引：$[1, 2]$。\n- 测试用例 $2$（三个并行转化）：\n  - 反应：$v_0$（摄取），$v_1$，$v_2$，$v_3$（三个并行转化），$v_4$（生物量流出）。\n  - 代谢物：$m_1$，$m_2$。\n  - 化学计量矩阵 $\\mathbf{S} \\in \\mathbb{R}^{2 \\times 5}$：\n    $$\n    \\mathbf{S} = \\begin{bmatrix}\n    1  -1  -1  -1  0 \\\\\n    0  1  1  1  -1\n    \\end{bmatrix}\n    $$\n  - 边界：$\\mathbf{l} = [0, 0, 0, 0, 0]$，$\\mathbf{u} = [9, 100, 100, 100, 100]$。\n  - 目标系数：$\\mathbf{c} = [0, 0, 0, 0, 1]$。\n  - 字典序优先级序列：$[1, 2, 3]$，$[2, 3, 1]$，$[3, 1, 2]$。\n  - 在支持集中考虑的路径索引：$[1, 2, 3]$。\n- 测试用例 $3$（容量有限的分支）：\n  - 反应：$v_0$（摄取），$v_1$ 和 $v_2$（两个具有不对称容量的并行转化），$v_3$（生物量流出）。\n  - 代谢物：$m_1$，$m_2$。\n  - 化学计量矩阵 $\\mathbf{S} \\in \\mathbb{R}^{2 \\times 4}$：\n    $$\n    \\mathbf{S} = \\begin{bmatrix}\n    1  -1  -1  0 \\\\\n    0  1  1  -1\n    \\end{bmatrix}\n    $$\n  - 边界：$\\mathbf{l} = [0, 0, 0, 0]$，$\\mathbf{u} = [8, 5, 8, 100]$。\n  - 目标系数：$\\mathbf{c} = [0, 0, 0, 1]$。\n  - 字典序优先级序列：$[1, 2]$，$[2, 1]$。\n  - 在支持集中考虑的路径索引：$[1, 2]$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含测试用例 $1$、测试用例 $2$ 和测试用例 $3$ 的不同路径集数量，格式为逗号分隔的列表，并用方括号括起来，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是一个整数。在确定通量分量是否在路径集中被视为活跃时，阈值必须设置为 $\\epsilon = 10^{-9}$。",
            "solution": "该问题是有效的。它在科学上基于通量平衡分析（FBA）和线性规划的既定原则，这些原则通常用于系统生物学中研究代谢网络。该问题是适定的，提供了所有必要的数据和清晰、明确的算法描述，从而为每个测试用例导出一个唯一的解。所有术语都得到了正式定义，并且在代谢建模的背景下，其前提在事实上是合理的。\n\n该问题要求实现一个字典序优化程序，以探索代谢网络简并的解空间。在此背景下，简并性指的是存在多个不同的通量分布（$\\mathbf{v}$）产生相同的最大生物学目标值（$z^\\star$）。字典序优化提供了一种系统的方法，可以基于一个带优先级的目标列表，从这个替代最优解空间中选择一个唯一的通量分布。通过改变优先级顺序，我们可以揭示网络可以使用的不同“策略”或路径，这些策略或路径表现为不同的活性反应集合。\n\n对每个测试用例，该解决方案分四个主要步骤实现：\n\n**1. 针对生物学目标的原始线性规划（LP）**\n\n首先，我们解决标准的 FBA 问题，这是一个线性规划问题，旨在找到通过生物学目标函数（如生物量生产）的最大可能通量。该目标由向量 $\\mathbf{c} \\in \\mathbb{R}^n$ 表示。问题表述如下：\n\n$$\n\\begin{align*}\n\\text{maximize} \\quad  z = \\mathbf{c}^\\top \\mathbf{v} \\\\\n\\text{subject to} \\quad  \\mathbf{S}\\mathbf{v} = \\mathbf{0} \\\\\n \\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}\n\\end{align*}\n$$\n\n这里，$\\mathbf{v} \\in \\mathbb{R}^n$ 是反应通量向量，$\\mathbf{S} \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$\\mathbf{l} \\in \\mathbb{R}^n$ 和 $\\mathbf{u} \\in \\mathbb{R}^n$ 分别是通量的下界和上界。约束 $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ 强制执行稳态假设，即每个内部代谢物的产生和消耗是平衡的。\n\n这个最大化问题使用标准的 LP 求解器来解决。我们将最优目标值表示为 $z^\\star$。\n\n**2. 序列化字典序最小化**\n\n在确定 $z^\\star$ 之后，我们探索达到此最大值的通量向量空间。这是通过向原问题添加一个新约束 $\\mathbf{c}^\\top \\mathbf{v} = z^\\star$ 来实现的。这个约束将可行解限制在对应于最大目标的解多胞体的面上。\n\n对于每个给定的反应索引的字典序优先级序列，例如 $(i_1, i_2, \\dots, i_k)$，我们执行一系列序列化的 LP。过程如下：\n\n对于 $j = 1, 2, \\dots, k$：\n- 我们求解一个 LP 来最小化优先级序列中第 $j$ 个反应的通量 $v_{i_j}$。此 LP 的可行集包括原始的稳态和边界约束、最优性约束 $\\mathbf{c}^\\top \\mathbf{v} = z^\\star$，以及序列中先前步骤附加的约束。具体来说，对于所有在前的索引 $p  j$，我们添加等式约束 $v_{i_p} = v_{i_p}^{\\min}$，其中 $v_{i_p}^{\\min}$ 是在第 $p$ 步中找到的最小值。\n\n第 $j$ 步的公式为：\n\n$$\n\\begin{align*}\n\\text{minimize} \\quad  v_{i_j} \\\\\n\\text{subject to} \\quad  \\mathbf{S}\\mathbf{v} = \\mathbf{0} \\\\\n \\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u} \\\\\n \\mathbf{c}^\\top \\mathbf{v} = z^\\star \\\\\n v_{i_p} = v_{i_p}^{\\min} \\quad \\text{for } p = 1, \\dots, j-1\n\\end{align*}\n$$\n\n设此 LP 的最优值为 $v_{i_j}^{\\min}$。该值随后用于固定通量 $v_{i_j}$，以用于序列中所有后续的最小化。在遍历优先级序列中的所有索引后，得到的通量向量 $\\mathbf{v}^{\\mathrm{lex}}$ 是唯一确定的。\n\n**3. 路径集识别**\n\n对于从一个优先级序列中获得的每个最终向量 $\\mathbf{v}^{\\mathrm{lex}}$，我们识别其对应的“路径集”。问题将其定义为从指定的 `route_indices` 列表中选出的活性反应集合。如果来自此列表的反应 $j$ 的通量 $v_j^{\\mathrm{lex}}$ 超过一个小的正阈值 $\\epsilon$，则该反应被认为是活性的。问题指定 $\\epsilon = 10^{-9}$。\n\n形式上，对于给定的 $\\mathbf{v}^{\\mathrm{lex}}$ 和一组 `route_indices` $I_{\\text{route}}$，得到的路径集 $R$ 为：\n$$\nR = \\{ j \\in I_{\\text{route}} \\mid v_j^{\\mathrm{lex}}  \\epsilon \\}\n$$\n\n**4. 计数不同路径集**\n\n对测试用例中提供的每个优先级序列重复整个过程（步骤2和3）。收集所有序列生成的路径集。该测试用例的最终结果是找到的唯一路径集的总数。这个计数用于量化通过改变最小化优先级可以选择的不同代谢操作模式的数量，从而提供了对网络结构简并性的洞察。\n\n该实现使用了 `scipy.optimize.linprog` 函数。初始的最大化通过最小化 $-\\mathbf{c}^\\top \\mathbf{v}$ 来执行。对于字典序部分，将最优性约束 $\\mathbf{c}^\\top \\mathbf{v} = z^\\star$ 添加到等式约束集中。通过在序列中为每个变量逐步收紧 `linprog` 函数的 `bounds` 参数，可以高效地实现变量 $v_{i_j} = v_{i_j}^{\\min}$ 的序列化固定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of FBA problems with lexicographic optimization\n    to count distinct metabolic route sets.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"S\": np.array([[1.0, -1.0, -1.0, 0.0], [0.0, 1.0, 1.0, -1.0]]),\n            \"l\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"u\": np.array([6.0, 100.0, 100.0, 100.0]),\n            \"c\": np.array([0.0, 0.0, 0.0, 1.0]),\n            \"sequences\": [[1, 2], [2, 1]],\n            \"route_indices\": [1, 2],\n        },\n        {\n            \"S\": np.array([[1.0, -1.0, -1.0, -1.0, 0.0], [0.0, 1.0, 1.0, 1.0, -1.0]]),\n            \"l\": np.array([0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"u\": np.array([9.0, 100.0, 100.0, 100.0, 100.0]),\n            \"c\": np.array([0.0, 0.0, 0.0, 0.0, 1.0]),\n            \"sequences\": [[1, 2, 3], [2, 3, 1], [3, 1, 2]],\n            \"route_indices\": [1, 2, 3],\n        },\n        {\n            \"S\": np.array([[1.0, -1.0, -1.0, 0.0], [0.0, 1.0, 1.0, -1.0]]),\n            \"l\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"u\": np.array([8.0, 5.0, 8.0, 100.0]),\n            \"c\": np.array([0.0, 0.0, 0.0, 1.0]),\n            \"sequences\": [[1, 2], [2, 1]],\n            \"route_indices\": [1, 2],\n        },\n    ]\n\n    epsilon = 1e-9\n    results = []\n\n    for case in test_cases:\n        S, l, u, c = case[\"S\"], case[\"l\"], case[\"u\"], case[\"c\"]\n        sequences = case[\"sequences\"]\n        route_indices = case[\"route_indices\"]\n        num_vars = S.shape[1]\n\n        # Step 1: Solve the primal FBA problem to find the optimal objective value z_star.\n        # We maximize c'v by minimizing -c'v.\n        initial_bounds = list(zip(l, u))\n        res_primal = linprog(\n            -c,\n            A_eq=S,\n            b_eq=np.zeros(S.shape[0]),\n            bounds=initial_bounds,\n            method='highs',\n        )\n\n        if not res_primal.success:\n            # According to the problem specification, all test cases are well-posed.\n            # This block is for robustness but should not be reached.\n            raise RuntimeError(\"Primal FBA optimization failed.\")\n        \n        # The optimal objective value z_star is the negative of the minimized value.\n        z_star = -res_primal.fun\n\n        # Step 2: Perform lexicographic optimization for each priority sequence.\n        distinct_route_sets = set()\n\n        # Add the objective constraint c'v = z_star to the equality constraints.\n        A_lex = np.vstack([S, c])\n        b_lex = np.hstack([np.zeros(S.shape[0]), z_star])\n\n        for seq in sequences:\n            # For each sequence, start with the original bounds.\n            current_bounds = list(zip(l, u))\n            v_lex = None\n\n            # Sequentially minimize fluxes according to the priority sequence.\n            for reaction_idx in seq:\n                # Define objective: minimize v[reaction_idx]\n                c_lex = np.zeros(num_vars)\n                c_lex[reaction_idx] = 1\n\n                # Solve the LP with the current set of fixed fluxes.\n                res_lex = linprog(\n                    c_lex,\n                    A_eq=A_lex,\n                    b_eq=b_lex,\n                    bounds=current_bounds,\n                    method='highs',\n                )\n\n                if not res_lex.success:\n                    raise RuntimeError(f\"Lexicographic minimization failed for index {reaction_idx}.\")\n                \n                # Get the minimum value for the current reaction flux.\n                v_min = res_lex.fun\n                \n                # Update the bounds for this reaction to 'fix' it to its minimized value\n                # for all subsequent optimization steps in this sequence.\n                # A small tolerance is subtracted/added to handle potential solver precision issues,\n                # ensuring the new bound is strictly a point.\n                current_bounds[reaction_idx] = (v_min, v_min)\n                \n                # The solution vector from the last LP call in the sequence is the final one.\n                v_lex = res_lex.x\n\n            if v_lex is None:\n                # This would only occur if a sequence is empty.\n                continue\n\n            # Step 3: Determine the route set for the final flux vector v_lex.\n            # A route set consists of indices from route_indices whose flux > epsilon.\n            # A frozenset is used as it is hashable and can be added to a set.\n            current_route_set = frozenset(\n                idx for idx in route_indices if v_lex[idx] > epsilon\n            )\n            distinct_route_sets.add(current_route_set)\n        \n        # Step 4: The result for this test case is the count of distinct route sets found.\n        results.append(len(distinct_route_sets))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}