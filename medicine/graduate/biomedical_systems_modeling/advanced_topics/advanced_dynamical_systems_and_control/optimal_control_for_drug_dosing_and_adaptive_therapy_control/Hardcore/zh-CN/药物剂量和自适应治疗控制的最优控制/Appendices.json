{
    "hands_on_practices": [
        {
            "introduction": "药物治疗的一个核心目标是在患者体内维持一个理想的治疗效果。本练习将引导您完成一项基本但至关重要的计算：如何根据一个特定的药效学（PD）目标，确定达到该目标所需的稳态血药浓度，并进一步计算出维持该浓度所需的恒定输注速率。通过这项练习，您将实践连接药代动力学（PK）和药效学（PD）模型的基本技能，这是设计任何剂量方案的基石。",
            "id": "3914577",
            "problem": "一种细胞抑制性抗癌剂通过恒速静脉输注给药，其遵循带线性消除的单室药代动力学 (PK) 模型。设血浆浓度为 $C(t)$，输注速率为 $u$ (假设不随时间变化)，分布容积为 $V$，清除率为 $CL$。浓度的质量平衡由下式给出\n$$\n\\frac{dC}{dt} \\;=\\; \\frac{u}{V} \\;-\\; \\frac{CL}{V}\\,C,\\quad t0.\n$$\n药效学 (PD) 效应是 $C$ 的一个单调递增函数，由一个 $E_{\\max}$ 模型描述：\n$$\nR(C) \\;=\\; R_{0} \\;+\\; \\frac{E_{\\max}\\,C}{EC_{50} + C},\n$$\n其中 $R_{0}$ 是基线效应，$E_{\\max}$ 是药物在基线之上引起的最大效应增加值，$EC_{50}$ 是产生最大效应增加值一半时的浓度。一个自适应治疗控制器指定了模型设定的允许范围内的稳态药效学目标 $R_{\\text{target}}^{\\ast}$。\n\n给定参数 $R_{0} = 10$ 效应单位，$E_{\\max} = 40$ 效应单位，$EC_{50} = 2\\,\\mathrm{mg/L}$，$CL = 5\\,\\mathrm{L/h}$，以及 $V = 40\\,\\mathrm{L}$，目标 $R_{\\text{target}}^{\\ast} = 30$ 效应单位，求达到该目标所需的恒定稳态浓度 $C$ 以及维持该稳态浓度所需的相应恒定输注速率 $u$。\n\n浓度以 $\\mathrm{mg/L}$ 表示，输注速率以 $\\mathrm{mg/h}$ 表示。答案四舍五入至三位有效数字。",
            "solution": "解答过程分为两部分。首先，根据 PD 模型确定达到目标效应所需的稳态浓度 ($C_{ss}$)。其次，根据处于稳态的 PK 模型计算维持此浓度所需的恒定输注速率 ($u$)。\n\n**第一部分：确定稳态浓度 ($C_{ss}$)**\n系统处于稳态，这意味着效应 $R(C)$ 等于目标效应 $R_{\\text{target}}^{\\ast}$。设稳态浓度为 $C_{ss}$。我们将 PD 模型方程设为目标值：\n$$\nR_{\\text{target}}^{\\ast} \\;=\\; R_{0} \\;+\\; \\frac{E_{\\max}\\,C_{ss}}{EC_{50} + C_{ss}}\n$$\n代入给定的参数值：\n$$\n30 \\;=\\; 10 \\;+\\; \\frac{40\\,C_{ss}}{2 + C_{ss}}\n$$\n我们求解这个代数方程以得到 $C_{ss}$。首先，从两边减去 $R_{0}=10$：\n$$\n30 - 10 \\;=\\; \\frac{40\\,C_{ss}}{2 + C_{ss}}\n$$\n$$\n20 \\;=\\; \\frac{40\\,C_{ss}}{2 + C_{ss}}\n$$\n现在，两边乘以分母 $(2 + C_{ss})$：\n$$\n20(2 + C_{ss}) \\;=\\; 40\\,C_{ss}\n$$\n在左边展开 $20$：\n$$\n40 \\;+\\; 20\\,C_{ss} \\;=\\; 40\\,C_{ss}\n$$\n将包含 $C_{ss}$ 的项归类：\n$$\n40 \\;=\\; 40\\,C_{ss} - 20\\,C_{ss}\n$$\n$$\n40 \\;=\\; 20\\,C_{ss}\n$$\n最后，求解 $C_{ss}$：\n$$\nC_{ss} \\;=\\; \\frac{40}{20} \\;=\\; 2\n$$\n所需的稳态浓度是 $C_{ss} = 2\\,\\mathrm{mg/L}$。按照要求，四舍五入到三位有效数字得到 $2.00\\,\\mathrm{mg/L}$。\n\n**第二部分：确定相应的输注速率 ($u$)**\nPK 模型描述了浓度随时间的变化。在稳态下，浓度是恒定的，这意味着其时间导数为零：$\\frac{dC}{dt} = 0$。\n$$\n\\frac{dC}{dt} \\;=\\; 0 \\;=\\; \\frac{u}{V} \\;-\\; \\frac{CL}{V}C_{ss}\n$$\n我们可以重新整理这个方程来求解输注速率 $u$：\n$$\n\\frac{u}{V} \\;=\\; \\frac{CL}{V}C_{ss}\n$$\n两边乘以 $V$ 得到稳态药代动力学中的一个基本关系：输注速率等于消除速率。\n$$\nu \\;=\\; CL \\cdot C_{ss}\n$$\n现在，我们代入给定的清除率值 ($CL = 5\\,\\mathrm{L/h}$) 和计算出的稳态浓度 ($C_{ss} = 2\\,\\mathrm{mg/L}$):\n$$\nu \\;=\\; (5\\,\\mathrm{L/h}) \\cdot (2\\,\\mathrm{mg/L})\n$$\n$$\nu \\;=\\; 10\\,\\mathrm{mg/h}\n$$\n得到的输注速率为 $u = 10\\,\\mathrm{mg/h}$。四舍五入到三位有效数字得到 $10.0\\,\\mathrm{mg/h}$。\n\n因此，要达到 30 个单位的目标效应，必须维持 $2.00\\,\\mathrm{mg/L}$ 的稳态血浆浓度，这需要 $10.0\\,\\mathrm{mg/h}$ 的恒定输注速率。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.00  10.0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "虽然连续输注在理论上易于分析，但在临床实践中，许多药物是以周期性推注（bolus）或口服的方式给予的。这种间歇性给药方式会引起血药浓度的波动。本练习将深入探讨这种给药方案下的动态过程，指导您推导描述药物在体内随时间累积的离散时间映射关系，并计算在重复给药下达到的稳态峰值浓度。理解这些动态特性对于设计安全有效的间歇性治疗方案至关重要。",
            "id": "3914599",
            "problem": "考虑一个用于描述血浆药物浓度的单室药代动力学 (PK) 模型，该浓度记为 $C(t)$，具有一级消除和瞬时静脉推注给药的特点。两次给药之间的消除动力学遵循质量平衡和一级动力学：$C(t)$ 的变化率与 $C(t)$ 成正比，比例常数为一个正的消除速率常数 $k$，因此有 $dC/dt = -k C$。给药事件发生在时间点 $\\{t_k\\}_{k \\in \\mathbb{N}}$，具有恒定的给药间隔 $\\Delta t$，其中 $t_{k+1} = t_k + \\Delta t$。在每个给药时间 $t_{k+1}$，施用一次静脉推注，导致浓度瞬时增加，增量幅度为 $\\Delta_k$（单位为浓度）。设 $C_k$ 表示在时间 $t_k$ 推注后瞬间的浓度，同样地，$C_{k+1}$ 表示在时间 $t_{k+1}$ 推注后瞬间的浓度。\n\n仅从以下基本前提出发：在给药事件之间系统遵循 $dC/dt = -k C$（其中 $k  0$），且在每个给药时间 $t_{k+1}$，推注使浓度瞬时增加 $\\Delta_k$。请推导将 $C_k$ 映射到 $C_{k+1}$ 的精确离散时间映射，该映射涵盖了给药间隔 $\\Delta t$ 和推注量 $\\Delta_k$。然后，施加周期性给药条件，即对所有 $k$ 都有 $\\Delta_k \\equiv \\Delta$，并分析此映射的不动点及其在小扰动下的稳定性。您的分析必须根据该映射的线性化以及一级动力学指数解的基本性质来明确证明其稳定性。\n\n作为最终答案，请提供周期性给药条件下不动点浓度 $C^{\\ast}$ 的单一闭式解析表达式，该表达式应以 $k$、$\\Delta t$ 和 $\\Delta$ 表示。",
            "solution": "我们首先分析在单个给药间隔内，即从第 $k$ 次给药时间 $t_k$ 到第 $(k+1)$ 次给药时间 $t_{k+1}$，药物浓度 $C(t)$ 的动态变化。设 $C_k$ 表示在时间 $t_k$ 推注给药后瞬间的浓度。\n\n在时间区间 $(t_k, t_{k+1})$ 内，没有药物施用，浓度根据一级消除过程衰减，该过程由以下微分方程描述：\n$$\n\\frac{dC}{dt} = -k C(t)\n$$\n其中 $k  0$ 是消除速率常数。这是一个可分离的一阶线性常微分方程。其解可以通过对区间起始点的初始条件进行积分得到。在时间 $t_k$ 给药后瞬间的浓度是 $C_k$。因此，对于 $t \\in [t_k, t_{k+1})$，解为：\n$$\nC(t) = C_k \\exp(-k(t-t_k))\n$$\n我们关心的是在下一次给药时间 $t_{k+1}$ 之前的瞬间浓度。我们将这个“谷”浓度记为 $C_{k+1}^{-}$。通过计算当 $t \\to t_{k+1}$ 时，即在区间末端，$C(t)$ 的值，我们可以求得该浓度。已知给药间隔是恒定的，$t_{k+1} - t_k = \\Delta t$。\n$$\nC_{k+1}^{-} = C(t_{k+1}) = C_k \\exp(-k(t_{k+1}-t_k)) = C_k \\exp(-k \\Delta t)\n$$\n在时间 $t_{k+1}$，施用一次静脉推注，导致浓度瞬时增加，增量为 $\\Delta_k$。这次给药后瞬间的浓度，记为 $C_{k+1}$，是谷浓度与推注引起的增加量之和：\n$$\nC_{k+1} = C_{k+1}^{-} + \\Delta_k\n$$\n代入 $C_{k+1}^{-}$ 的表达式，我们推导出关联了从一个周期到下一个周期的给药后浓度的离散时间映射：\n$$\nC_{k+1} = C_k \\exp(-k \\Delta t) + \\Delta_k\n$$\n这就是具有可变给药量 $\\Delta_k$ 的系统的通用精确离散时间映射。\n\n接下来，我们施加周期性给药的条件，即所有剂量的推注量恒定，即对所有 $k \\in \\mathbb{N}$ 都有 $\\Delta_k = \\Delta$。该映射简化为一个线性一阶递推关系：\n$$\nC_{k+1} = C_k \\exp(-k \\Delta t) + \\Delta\n$$\n此映射的一个不动点，记为 $C^{\\ast}$，是一个从一个周期到下一个周期保持不变的浓度。在不动点处，系统处于稳态，因此 $C_{k+1} = C_k = C^{\\ast}$。我们可以通过将其代入映射来求得 $C^{\\ast}$：\n$$\nC^{\\ast} = C^{\\ast} \\exp(-k \\Delta t) + \\Delta\n$$\n现在，我们求解 $C^{\\ast}$：\n$$\nC^{\\ast} - C^{\\ast} \\exp(-k \\Delta t) = \\Delta\n$$\n$$\nC^{\\ast} (1 - \\exp(-k \\Delta t)) = \\Delta\n$$\n$$\nC^{\\ast} = \\frac{\\Delta}{1 - \\exp(-k \\Delta t)}\n$$\n这就是不动点（稳态峰值）浓度的闭式解析表达式。\n\n最后，我们分析这个不动点的稳定性。对于一个一维离散映射 $x_{k+1} = f(x_k)$，如果该映射在不动点 $x^{\\ast}$ 处的导数的绝对值小于1，即 $|f'(x^{\\ast})|  1$，则该不动点是稳定的。\n我们的映射是 $C_{k+1} = f(C_k)$，其中函数 $f(C)$ 由下式给出：\n$$\nf(C) = C \\exp(-k \\Delta t) + \\Delta\n$$\n我们计算 $f(C)$ 关于 $C$ 的导数：\n$$\nf'(C) = \\frac{d}{dC} \\left( C \\exp(-k \\Delta t) + \\Delta \\right) = \\exp(-k \\Delta t)\n$$\n该导数是一个常数，与浓度 $C$ 无关。因此，稳定性条件 $|f'(C^{\\ast})|  1$ 可转化为：\n$$\n|\\exp(-k \\Delta t)|  1\n$$\n问题陈述中指出消除速率常数 $k$ 是正的（$k  0$）。给药间隔 $\\Delta t$ 本身也是正的（$\\Delta t  0$）。因此，指数 $-k \\Delta t$ 是严格为负的。实指数函数的基本性质决定了对于任何负实数参数 $x  0$，其值 $\\exp(x)$ 介于 0 和 1 之间，即 $0  \\exp(x)  1$。\n将此应用于我们的情况：\n$$\n-k \\Delta t  0 \\implies 0  \\exp(-k \\Delta t)  1\n$$\n由于 $\\exp(-k \\Delta t)$ 是一个小于 1 的正数，其绝对值就是它本身，并且它严格小于 1：\n$$\n|\\exp(-k \\Delta t)| = \\exp(-k \\Delta t)  1\n$$\n因此，对于任何具有物理意义的参数 $k  0$ 和 $\\Delta t  0$，稳定性条件总是被满足。这意味着不动点 $C^{\\ast}$ 是全局稳定的。任何初始浓度 $C_0$ 都会导出一个浓度序列 $\\{C_k\\}$，该序列收敛于这个唯一的稳态值 $C^{\\ast}$。项 $\\exp(-k \\Delta t)$ 作为一个收缩因子，确保了初始状态的影响在每个给药周期中逐渐减小，最终导致收敛。",
            "answer": "$$\n\\boxed{\\frac{\\Delta}{1 - \\exp(-k \\Delta t)}}\n$$"
        },
        {
            "introduction": "在真实的临床环境中，治疗方案必须能够应对患者的个体差异、模型参数的不确定性以及测量数据中存在的噪声。这项高级实践将指导您构建一个完整的自适应给药控制系统，该系统集成了卡尔曼滤波器（Kalman filter）进行状态估计和模型预测控制（MPC）进行决策优化。您将学习如何利用模型预测未来的药物浓度，实时优化受约束的药物输入以达到治疗目标，并通过反馈机制不断适应新的测量数据，这正是现代个体化和自适应药物治疗控制策略的核心。",
            "id": "3914522",
            "problem": "考虑一个描述零级输注下血浆药物浓度的单室药代动力学模型。质量平衡定律指出，浓度变化率等于单位体积的输入速率减去一级消除速率。令 $c(t)$ 表示血浆浓度（单位为 $\\mathrm{mg/L}$），$u(t)$ 表示输注速率（单位为 $\\mathrm{mg/hour}$），清除率 $CL$（单位为 $\\mathrm{L/hour}$），以及分布容积 $V$（单位为 $\\mathrm{L}$）。连续时间动态方程为\n$$\n\\frac{dc(t)}{dt} = -\\frac{CL}{V}\\,c(t) + \\frac{1}{V}\\,u(t).\n$$\n假设采用采样数据实现，采样间隔为 $T_s$（单位为 $\\mathrm{hour}$），并且在每个间隔内输注速率 $u(t)$ 是分段恒定的。精确离散化后得到\n$$\nc_{k+1} = A\\,c_k + B\\,u_k + w_k,\n$$\n其中 $A = \\exp\\!\\big(-\\tfrac{CL}{V}T_s\\big)$，$B = \\frac{1}{V}\\cdot\\frac{1 - \\exp\\!\\big(-\\tfrac{CL}{V}T_s\\big)}{\\tfrac{CL}{V}}$，$c_k$ 是采样点 $k$ 处的浓度，$u_k$ 是在 $[kT_s,(k+1)T_s)$ 区间内的恒定输注速率，过程噪声 $w_k$ 被建模为零均值高斯分布，其方差为 $Q$（单位为 $\\mathrm{(mg/L)^2}$）。浓度测量值受到加性零均值高斯噪声的干扰：\n$$\ny_k = c_k + v_k,\\quad v_k \\sim \\mathcal{N}(0,R),\n$$\n其方差为 $R$（单位为 $\\mathrm{(mg/L)^2}$）。\n\n你将设计一个模型预测控制 (MPC) 策略，在一个长度为 $H$ 步的预测时域和一个长度为 $H$ 步的控制时域内，将 $c_k$ 调节到一个恒定的参考值 $r$（单位为 $\\mathrm{mg/L}$），并受到对所有 $k$ 均成立的箱式约束 $u_{\\min} \\le u_k \\le u_{\\max}$ 的限制。在每个采样时刻，你将：\n- 使用离散时间卡尔曼滤波器，根据最新的测量值 $y_k$ 和由参数 $(CL_{\\mathrm{model}},V_{\\mathrm{model}})$ 计算出的线性模型参数 $(A_{\\mathrm{model}},B_{\\mathrm{model}})$，来更新状态估计值 $\\hat{c}_k$。\n- 求解一个有限时域最优控制问题，计算一个输注速率序列 $\\{u_k,u_{k+1},\\dots,u_{k+H-1}\\}$，以最小化以下二次代价函数\n$$\nJ = \\sum_{i=0}^{H-1} q\\,(c_{k+i+1} - r)^2 + \\sum_{i=0}^{H-1} \\rho\\,(u_{k+i} - u_{k+i-1})^2 + \\sum_{i=0}^{H-1} \\eta\\,u_{k+i}^2 + q_f\\,(c_{k+H} - r)^2,\n$$\n其中 $c_{k+i+1}$ 是基于 $(A_{\\mathrm{model}},B_{\\mathrm{model}})$ 和初始条件 $\\hat{c}_k$ 的预测值，$u_{k-1}$ 是上一步施加的输注速率。常数 $q,q_f,\\rho,\\eta$ 是非负权重。对所有 $i=0,\\dots,H-1$ 施加约束 $u_{\\min} \\le u_{k+i} \\le u_{\\max}$。\n- 将计算出的第一个输注速率 $u_k$ 应用于被控对象，观测下一个测量值 $y_{k+1}$，并重复该过程，总共进行 $N$ 步。\n\n假设被控对象可能具有与控制器使用的参数 $(CL_{\\mathrm{model}},V_{\\mathrm{model}})$ 不同的参数 $(CL_{\\mathrm{plant}},V_{\\mathrm{plant}})$，以测试在模型失配情况下的自适应能力。对所有高斯噪声使用固定的随机种子以确保可复现性。标量情况下的离散时间卡尔曼滤波器递归必须遵循\n$$\n\\hat{c}_{k+1|k} = A_{\\mathrm{model}}\\,\\hat{c}_{k|k} + B_{\\mathrm{model}}\\,u_k,\\quad\nP_{k+1|k} = A_{\\mathrm{model}}^2 P_{k|k} + Q,\n$$\n$$\nK_{k+1} = \\frac{P_{k+1|k}}{P_{k+1|k} + R},\\quad\n\\hat{c}_{k+1|k+1} = \\hat{c}_{k+1|k} + K_{k+1}\\,(y_{k+1} - \\hat{c}_{k+1|k}),\\quad\nP_{k+1|k+1} = (1 - K_{k+1})\\,P_{k+1|k}.\n$$\n\n使用带边界约束的数值优化器实现 MPC 优化。程序必须计算并输出每个测试用例施加的输注速率序列，以展示对测量更新的闭环自适应能力。\n\n物理单位：所有输注速率 $u_k$ 必须以 $\\mathrm{mg/hour}$ 为单位进行计算和报告。浓度单位为 $\\mathrm{mg/L}$，时间单位为 $\\mathrm{hour}$。\n\n测试套件。使用以下三个测试用例来评估不同方面：\n- 案例 1 (标称情况，执行能力充足)：$N=12$, $H=4$, $T_s=6\\,\\mathrm{小时}$, $CL_{\\mathrm{plant}}=4\\,\\mathrm{升/小时}$, $V_{\\mathrm{plant}}=40\\,\\mathrm{升}$, $CL_{\\mathrm{model}}=4\\,\\mathrm{升/小时}$, $V_{\\mathrm{model}}=40\\,\\mathrm{升}$, $r=2\\,\\mathrm{毫克/升}$, $u_{\\min}=0\\,\\mathrm{毫克/小时}$, $u_{\\max}=200\\,\\mathrm{毫克/小时}$, $q=1$, $q_f=1$, $\\rho=10^{-3}$, $\\eta=10^{-4}$, $Q=0$ $\\mathrm{(毫克/升)^2}$, $R=0.01$ $\\mathrm{(毫克/升)^2}$, 初始 $c_0=0\\,\\mathrm{毫克/升}$, 初始协方差 $P_0=1$ $\\mathrm{(毫克/升)^2}$, 初始前一输入 $u_{-1}=0\\,\\mathrm{毫克/小时}$。\n- 案例 2 (严格边界，饱和)：$N=12$, $H=4$, $T_s=6\\,\\mathrm{小时}$, $CL_{\\mathrm{plant}}=6\\,\\mathrm{升/小时}$, $V_{\\mathrm{plant}}=40\\,\\mathrm{升}$, $CL_{\\mathrm{model}}=6\\,\\mathrm{升/小时}$, $V_{\\mathrm{model}}=40\\,\\mathrm{升}$, $r=2\\,\\mathrm{毫克/升}$, $u_{\\min}=0\\,\\mathrm{毫克/小时}$, $u_{\\max}=50\\,\\mathrm{毫克/小时}$, $q=1$, $q_f=1$, $\\rho=10^{-3}$, $\\eta=10^{-4}$, $Q=0$ $\\mathrm{(毫克/升)^2}$, $R=0.01$ $\\mathrm{(毫克/升)^2}$, 初始 $c_0=0\\,\\mathrm{毫克/升}$, $P_0=1$ $\\mathrm{(毫克/升)^2}$, $u_{-1}=0\\,\\mathrm{毫克/小时}$。\n- 案例 3 (模型失配和更嘈杂的测量)：$N=10$, $H=4$, $T_s=6\\,\\mathrm{小时}$, $CL_{\\mathrm{plant}}=7\\,\\mathrm{升/小时}$, $V_{\\mathrm{plant}}=40\\,\\mathrm{升}$, $CL_{\\mathrm{model}}=5\\,\\mathrm{升/小时}$, $V_{\\mathrm{model}}=40\\,\\mathrm{升}$, $r=2\\,\\mathrm{毫克/升}$, $u_{\\min}=0\\,\\mathrm{毫克/小时}$, $u_{\\max}=150\\,\\mathrm{毫克/小时}$, $q=1$, $q_f=1$, $\\rho=10^{-3}$, $\\eta=10^{-4}$, $Q=0$ $\\mathrm{(毫克/升)^2}$, $R=0.09$ $\\mathrm{(毫克/升)^2}$, 初始 $c_0=0\\,\\mathrm{毫克/升}$, $P_0=1$ $\\mathrm{(毫克/升)^2}$, $u_{-1}=0\\,\\mathrm{毫克/小时}$。\n\n随机性：所有案例均使用固定的随机种子，以使测量噪声的实现是可复现的。每个案例使用由不同种子值初始化的独立生成器；案例 1、2 和 3 的种子分别设置为 $202311$、$202312$ 和 $202313$。\n\n你的任务。编写一个完整的程序，实现上述的卡尔曼滤波器和 MPC，并为每个测试用例计算施加的输注速率序列 $\\{u_0,u_1,\\dots,u_{N-1}\\}$。输注速率以 $\\mathrm{mg/hour}$ 为单位表示，并四舍五入到两位小数。\n\n最终输出格式。你的程序应生成单行输出，其中包含三个结果，形式为一个用方括号括起来的逗号分隔列表。每个结果本身是该测试用例施加的输注速率列表，按案例 1、案例 2、案例 3 的顺序排列。例如，它看起来应该像 \"[[...],[...],[...]]\"，其中的数值项四舍五入到两位小数，并且打印的列表中不带单位。",
            "solution": "该问题要求设计并实现一种模型预测控制 (MPC) 策略，用于调节单室药代动力学 (PK) 模型中的药物浓度。解决方案涉及一个闭环仿真，其中控制器基于数学模型和对真实系统（“被控对象”）的不完美测量来做出决策。解决方案的核心组成部分是：被控对象模型、状态估计器（卡尔曼滤波器）和 MPC 优化器。\n\n### 1. 系统动力学与离散化\n\n药物浓度 $c(t)$ 的连续时间动力学由以下线性常微分方程给出：\n$$\n\\frac{dc(t)}{dt} = -\\frac{CL}{V}\\,c(t) + \\frac{1}{V}\\,u(t)\n$$\n其中 $CL$ 是清除率，$V$ 是分布容积，$u(t)$ 是输注速率。这是一个标准的单室 PK 模型。\n\n为了在数字控制器中实现，该系统在采样间隔 $T_s$ 上进行离散化，假设控制输入 $u_k$ 在每个区间 $[kT_s, (k+1)T_s)$ 上是恒定的。在此条件下，微分方程的精确解可得到离散时间状态空间模型：\n$$\nc_{k+1} = A\\,c_k + B\\,u_k + w_k\n$$\n其中 $c_k = c(kT_s)$ 是采样点 $k$ 处的浓度。系统矩阵 $A$ 和 $B$ 是物理参数的函数：\n$$\nA = \\exp\\!\\left(-\\frac{CL}{V}T_s\\right)\n$$\n$$\nB = \\frac{1 - A}{CL}\n$$\n项 $w_k$ 代表过程噪声，建模为零均值、方差为 $Q$ 的高斯分布。该问题的一个关键方面是控制器模型使用的参数 $(CL_{\\mathrm{model}}, V_{\\mathrm{model}})$ 与实际被控对象参数 $(CL_{\\mathrm{plant}}, V_{\\mathrm{plant}})$ 之间可能存在失配。因此，我们将区分用于预测和控制的 $(A_{\\mathrm{model}}, B_{\\mathrm{model}})$ 和用于仿真真实系统响应的 $(A_{\\mathrm{plant}}, B_{\\mathrm{plant}})$。\n\n### 2. 使用卡尔曼滤波器进行状态估计\n\n由于真实浓度 $c_k$ 无法被完美测量，我们使用一个状态估计器。测量值 $y_k$ 受到零均值、方差为 $R$ 的高斯噪声 $v_k$ 的干扰：\n$$\ny_k = c_k + v_k\n$$\n采用离散时间卡尔曼滤波器，在给定截至时刻 $k$ 的所有测量值的情况下，提供真实状态 $c_k$ 的最优估计 $\\hat{c}_{k|k}$。在每一步，滤波器执行一个两阶段的递归：\n\n1.  **预测：** 使用模型动力学将状态估计及其误差协方差向前投影。给定前一时刻的估计值 $\\hat{c}_{k|k}$ 和施加的控制 $u_k$：\n    $$\n    \\hat{c}_{k+1|k} = A_{\\mathrm{model}}\\,\\hat{c}_{k|k} + B_{\\mathrm{model}}\\,u_k\n    $$\n    $$\n    P_{k+1|k} = A_{\\mathrm{model}}^2\\,P_{k|k} + Q\n    $$\n2.  **更新：** 使用新的测量值 $y_{k+1}$ 修正预测估计值。新息（测量残差）为 $y_{k+1} - \\hat{c}_{k+1|k}$。\n    $$\n    K_{k+1} = \\frac{P_{k+1|k}}{P_{k+1|k} + R} \\quad \\text{(卡尔曼增益)}\n    $$\n    $$\n    \\hat{c}_{k+1|k+1} = \\hat{c}_{k+1|k} + K_{k+1}\\,(y_{k+1} - \\hat{c}_{k+1|k}) \\quad \\text{(更新后的状态估计)}\n    $$\n    $$\n    P_{k+1|k+1} = (1 - K_{k+1})\\,P_{k+1|k} \\quad \\text{(更新后的协方差)}\n    $$\n该滤波器通过持续修正其对系统真实状态的认知，使控制器能够适应噪声和模型失配。\n\n### 3. 模型预测控制 (MPC)\n\n在每个采样时刻 $k$，MPC 控制器求解一个有限时域最优控制问题，以确定最佳的输入序列。决策基于当前的状态估计值 $\\hat{c}_{k|k}$。\n\n目标是找到一个控制输入序列 $U_k = \\{u_{k}, u_{k+1}, \\dots, u_{k+H-1}\\}$，该序列在长度为 $H$ 步的预测时域上最小化一个二次代价函数 $J$。该代价函数平衡了几个相互竞争的目标：\n$$\nJ(U_k) = \\underbrace{\\sum_{i=0}^{H-1} q\\,(\\hat{c}_{k+i+1|k} - r)^2 + q_f\\,(\\hat{c}_{k+H|k} - r)^2}_{\\text{跟踪误差}} + \\underbrace{\\sum_{i=0}^{H-1} \\rho\\,(u_{k+i} - u_{k+i-1})^2}_{\\text{变化率惩罚}} + \\underbrace{\\sum_{i=0}^{H-1} \\eta\\,u_{k+i}^2}_{\\text{输入量值惩罚}}\n$$\n其中：\n- $\\hat{c}_{k+i|k}$ 是从 $\\hat{c}_{k|k}$ 开始，使用 $U_k$ 中的输入预测出的状态。\n- $r$ 是期望的浓度参考值。\n- $u_{k-1}$ 是上一步施加的控制作用。\n- $q, q_f, \\rho, \\eta$ 是非负权重因子。$\\eta  0$ 项确保了该问题是严格凸的。\n\n该优化问题受到输入约束 $u_{\\min} \\le u_{k+i} \\le u_{\\max}$（对所有 $i \\in [0, H-1]$）的限制。这个约束优化问题是一个二次规划 (QP) 问题，可以使用数值方法高效求解。我们将使用 `scipy.optimize.minimize` 提供的带边界约束的优化器。\n\n在求得最优序列 $U_k$ 后，仅将其第一个元素 $u_k$ 应用于被控对象。然后系统演化到下一个状态，获取新的测量值，并在下一个采样时刻 $k+1$ 重复整个过程（估计和优化）。这就是滚动时域控制器的原理。\n\n### 4. 闭环仿真协议\n\n对于每个测试用例，整体算法流程如下：\n1.  **初始化：** 根据特定案例的 $(CL, V, T_s)$ 设置被控对象和模型的参数 $(A, B)$。初始化真实状态 $c_0$、状态估计 $\\hat{c}_{0|0} = c_0$、其协方差 $P_{0|0} = P_0$ 以及上一步的输入 $u_{-1}$。使用指定的种子初始化一个随机数生成器。\n2.  **仿真循环：** 对从 $0$ 到 $N-1$ 的每个时间步 $k$：\n    a.  **MPC 控制计算：** 使用当前估计值 $\\hat{c}_{k|k}$ 和前一输入 $u_{k-1}$，求解约束优化问题以找到最优输入序列 $U_k^*$。\n    b.  **施加控制：** 提取第一个输入 $u_k = U_k^*[0]$ 并施加。存储此值。\n    c.  **被控对象仿真：** 真实系统状态根据 $c_{k+1} = A_{\\mathrm{plant}}\\,c_k + B_{\\mathrm{plant}}\\,u_k$ 演化。（由于 $Q=0$，本次仿真中没有过程噪声）。\n    d.  **测量仿真：** 生成一个带噪声的测量值 $y_{k+1} = c_{k+1} + v_{k+1}$，其中 $v_{k+1} \\sim \\mathcal{N}(0, R)$。\n    e.  **卡尔曼滤波器更新：** 使用 $u_k$ 和 $y_{k+1}$ 计算下一个状态估计 $\\hat{c}_{k+1|k+1}$ 和协方差 $P_{k+1|k+1}$。\n3.  **输出：** 在 $N$ 步之后，将收集到的已施加输入序列 $\\{u_0, u_1, \\dots, u_{N-1}\\}$ 进行格式化并报告。\n\n对三个测试用例中的每一个都实施此程序，以展示控制器在标称条件、执行器饱和以及存在显著模型-被控对象失配情况下的性能。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to run the MPC simulation for all test cases and print the results.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: Nominal, sufficient actuation\n        {\n            \"N\": 12, \"H\": 4, \"Ts\": 6.0,\n            \"CL_plant\": 4.0, \"V_plant\": 40.0,\n            \"CL_model\": 4.0, \"V_model\": 40.0,\n            \"r\": 2.0, \"u_min\": 0.0, \"u_max\": 200.0,\n            \"q\": 1.0, \"qf\": 1.0, \"rho\": 1e-3, \"eta\": 1e-4,\n            \"Q\": 0.0, \"R\": 0.01,\n            \"c0\": 0.0, \"P0\": 1.0, \"u_m1\": 0.0,\n            \"seed\": 202311\n        },\n        # Case 2: Tight bounds, saturation\n        {\n            \"N\": 12, \"H\": 4, \"Ts\": 6.0,\n            \"CL_plant\": 6.0, \"V_plant\": 40.0,\n            \"CL_model\": 6.0, \"V_model\": 40.0,\n            \"r\": 2.0, \"u_min\": 0.0, \"u_max\": 50.0,\n            \"q\": 1.0, \"qf\": 1.0, \"rho\": 1e-3, \"eta\": 1e-4,\n            \"Q\": 0.0, \"R\": 0.01,\n            \"c0\": 0.0, \"P0\": 1.0, \"u_m1\": 0.0,\n            \"seed\": 202312\n        },\n        # Case 3: Model mismatch and noisier measurements\n        {\n            \"N\": 10, \"H\": 4, \"Ts\": 6.0,\n            \"CL_plant\": 7.0, \"V_plant\": 40.0,\n            \"CL_model\": 5.0, \"V_model\": 40.0,\n            \"r\": 2.0, \"u_min\": 0.0, \"u_max\": 150.0,\n            \"q\": 1.0, \"qf\": 1.0, \"rho\": 1e-3, \"eta\": 1e-4,\n            \"Q\": 0.0, \"R\": 0.09,\n            \"c0\": 0.0, \"P0\": 1.0, \"u_m1\": 0.0,\n            \"seed\": 202313\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result_sequence = run_mpc_simulation(params)\n        all_results.append(result_sequence)\n    \n    # Format the final output string\n    result_strings = []\n    for res_list in all_results:\n        formatted_list = [f\"{x:.2f}\" for x in res_list]\n        result_strings.append(f\"[{','.join(formatted_list)}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef get_discrete_params(CL, V, Ts):\n    \"\"\"Computes discrete-time system matrices A and B from continuous-time parameters.\"\"\"\n    if CL == 0:\n        A = 1.0\n        B = Ts / V\n    else:\n        A = np.exp(-CL / V * Ts)\n        B = (1.0 - A) / CL\n    return A, B\n\ndef mpc_cost_function(u_seq, c_hat_k, u_prev, A, B, r, H, q, qf, rho, eta):\n    \"\"\"\n    Calculates the MPC cost function J for a given sequence of control inputs.\n    \"\"\"\n    cost = 0.0\n    c_pred = c_hat_k\n    u_current_prev = u_prev\n\n    for i in range(H):\n        u_current = u_seq[i]\n        c_next_pred = A * c_pred + B * u_current\n        \n        # State tracking cost\n        cost += q * (c_next_pred - r)**2\n        \n        # Input rate-of-change cost\n        cost += rho * (u_current - u_current_prev)**2\n        \n        # Input magnitude cost\n        cost += eta * u_current**2\n        \n        # Update states for the next iteration in the prediction horizon\n        c_pred = c_next_pred\n        u_current_prev = u_current\n    \n    # Terminal state cost\n    cost += qf * (c_pred - r)**2\n    \n    return cost\n\ndef run_mpc_simulation(params):\n    \"\"\"\n    Runs a full closed-loop MPC simulation for a single test case.\n    \"\"\"\n    # Unpack parameters\n    N, H, Ts = params[\"N\"], params[\"H\"], params[\"Ts\"]\n    CL_plant, V_plant = params[\"CL_plant\"], params[\"V_plant\"]\n    CL_model, V_model = params[\"CL_model\"], params[\"V_model\"]\n    r, u_min, u_max = params[\"r\"], params[\"u_min\"], params[\"u_max\"]\n    q, qf, rho, eta = params[\"q\"], params[\"qf\"], params[\"rho\"], params[\"eta\"]\n    Q, R = params[\"Q\"], params[\"R\"]\n    c0, P0, u_m1 = params[\"c0\"], params[\"P0\"], params[\"u_m1\"]\n    seed = params[\"seed\"]\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Get discrete-time parameters for plant and model\n    A_plant, B_plant = get_discrete_params(CL_plant, V_plant, Ts)\n    A_model, B_model = get_discrete_params(CL_model, V_model, Ts)\n\n    # Initialize simulation variables\n    c_true_k = c0\n    c_est_kk = c0\n    P_kk = P0\n    u_prev = u_m1\n    applied_inputs = []\n\n    # Main simulation loop\n    for k in range(N):\n        # 1. Solve MPC optimal control problem\n        args_for_cost = (c_est_kk, u_prev, A_model, B_model, r, H, q, qf, rho, eta)\n        bounds = [(u_min, u_max)] * H\n        # Use a reasonable initial guess for the optimizer\n        initial_guess = np.clip([u_prev] * H, u_min, u_max)\n        \n        opt_result = minimize(\n            mpc_cost_function,\n            initial_guess,\n            args=args_for_cost,\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n        \n        u_k = opt_result.x[0]\n        applied_inputs.append(u_k)\n\n        # 2. Simulate the plant's evolution\n        # Process noise w_k is zero since Q=0\n        c_true_k_plus_1 = A_plant * c_true_k + B_plant * u_k\n\n        # 3. Simulate the measurement\n        measurement_noise = rng.normal(loc=0.0, scale=np.sqrt(R))\n        y_k_plus_1 = c_true_k_plus_1 + measurement_noise\n\n        # 4. Kalman Filter Update\n        # Prediction step\n        c_est_k_plus_1_k = A_model * c_est_kk + B_model * u_k\n        P_k_plus_1_k = A_model**2 * P_kk + Q\n        \n        # Update step\n        innovation = y_k_plus_1 - c_est_k_plus_1_k\n        K_k_plus_1 = P_k_plus_1_k / (P_k_plus_1_k + R)\n        c_est_k_plus_1_k_plus_1 = c_est_k_plus_1_k + K_k_plus_1 * innovation\n        P_k_plus_1_k_plus_1 = (1 - K_k_plus_1) * P_k_plus_1_k\n\n        # 5. Update states for the next iteration\n        c_true_k = c_true_k_plus_1\n        c_est_kk = c_est_k_plus_1_k_plus_1\n        P_kk = P_k_plus_1_k_plus_1\n        u_prev = u_k\n        \n    return applied_inputs\n\n# Execute the main function when the script is run\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}