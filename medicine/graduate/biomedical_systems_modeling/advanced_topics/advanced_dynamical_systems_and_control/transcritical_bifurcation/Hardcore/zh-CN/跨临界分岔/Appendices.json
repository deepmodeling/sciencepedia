{
    "hands_on_practices": [
        {
            "introduction": "分析分岔的第一步通常是定位其发生的临界参数值。本练习  提供了一个合成生物学中的具体情景，要求学生计算触发跨临界分岔的抑制剂浓度。此过程将抽象的稳定性条件与可测量的物理量直接联系起来，从而加深对理论在实际应用中作用的理解。",
            "id": "1724859",
            "problem": "一个合成生物电路中酶的浓度 $y(t)$ 的动力学可以通过以下一阶非线性微分方程来建模：\n$$ \\frac{dy}{dt} = (k_p - k_d - \\beta c)y - \\frac{k_p}{Y_{max}} y^2 $$\n在这个模型中，外部施加的抑制剂分子的浓度 $c$ 作为系统的控制参数。当参数 $c$ 变化时，系统在平凡不动点 $y=0$ 处表现出跨临界分岔。\n\n系统的参数已通过实验确定为：\n- 最大自催化生产速率常数，$k_p = 0.52 \\, \\text{min}^{-1}$。\n- 天然酶降解速率常数，$k_d = 0.11 \\, \\text{min}^{-1}$。\n- 抑制剂有效性常数，$\\beta = 0.075 \\, \\text{L} \\cdot \\mu\\text{mol}^{-1} \\cdot \\text{min}^{-1}$。\n- 酶饱和浓度，$Y_{max} = 15 \\, \\mu\\text{M}$。\n\n$y$ 和 $c$ 的单位都是微摩尔/升（$\\mu\\text{M}$）。\n\n确定抑制剂浓度的临界值 $c_{crit}$，在该值下系统在平衡点 $y=0$ 处发生跨临界分岔。请以微摩尔/升（$\\mu\\text{M}$）为单位表示你的答案，并将最终答案四舍五入到三位有效数字。",
            "solution": "我们给定的微分方程是\n$$\n\\frac{dy}{dt} = \\left(k_{p} - k_{d} - \\beta c\\right)y - \\frac{k_{p}}{Y_{\\max}}y^{2}.\n$$\n平衡点满足\n$$\n0 = \\left(k_{p} - k_{d} - \\beta c\\right)y - \\frac{k_{p}}{Y_{\\max}}y^{2}\n= y\\left[\\left(k_{p} - k_{d} - \\beta c\\right) - \\frac{k_{p}}{Y_{\\max}}y\\right].\n$$\n因此不动点是\n$$\ny_{1}=0,\\qquad y_{2}=\\frac{Y_{\\max}}{k_{p}}\\left(k_{p} - k_{d} - \\beta c\\right).\n$$\n当 $y=0$ 处的线性化改变稳定性且非平凡平衡点与 $y=0$ 碰撞时，在 $y=0$ 处发生跨临界分岔。雅可比矩阵（右侧关于 $y$ 的导数）是\n$$\nf_{y}(y;c)=\\left(k_{p} - k_{d} - \\beta c\\right) - 2\\frac{k_{p}}{Y_{\\max}}y,\n$$\n所以在 $y=0$ 处，\n$$\nf_{y}(0;c)=k_{p} - k_{d} - \\beta c.\n$$\n分岔发生在 $f_{y}(0;c)=0$ 时，这给出了临界抑制剂浓度\n$$\nc_{\\text{crit}}=\\frac{k_{p} - k_{d}}{\\beta}.\n$$\n代入给定的参数值，\n$$\nc_{\\text{crit}}=\\frac{0.52 - 0.11}{0.075}=\\frac{0.41}{0.075}=\\frac{82}{15}\\approx 5.466\\overline{6}.\n$$\n按要求四舍五入到三位有效数字，得到 $5.47$ 微摩尔单位。",
            "answer": "$$\\boxed{5.47}$$"
        },
        {
            "introduction": "并非所有看起来相似的分岔都属于同一类型，严格的数学分类至关重要。本练习  挑战学生超越直观观察，应用严格的数学判据——特别是系统函数偏导数所满足的条件——来区分跨临界分岔与另一种常见类型，即叉式分岔。这凸显了局部泰勒展开在动力系统行为分类中的核心作用。",
            "id": "1724860",
            "problem": "考虑一个由微分方程 $\\dot{x} = f(x, \\mu)$ 定义的一维动力系统，其中 $x(t)$ 是状态变量，$\\mu$ 是一个实值参数。系统的一个不动点 $x^*$ 满足 $f(x^*, \\mu) = 0$。如果当参数 $\\mu$ 经过某个值 $\\mu_c$ 时，系统的定性行为（例如其不动点的数量或稳定性）发生改变，则称在参数值 $\\mu_c$ 处发生分岔。\n\n发生在原点 $(x^*, \\mu_c) = (0, 0)$ 处的跨临界分岔的范式由 $\\dot{x} = \\mu x - x^2$ 给出。对于一个一般系统 $\\dot{x} = f(x, \\mu)$，要在点 $(x^*, \\mu_c)$ 处经历跨临界分岔，必须满足关于 $f(x, \\mu)$ 在该点求值的偏导数的某些条件。\n\n现在，考虑由以下方程给出的特定系统：\n$$ \\dot{x} = \\mu x - x^3 $$\n可以验证，$x^* = 0$ 对所有 $\\mu$ 值都是一个不动点，并且涉及到该不动点的分岔发生在临界参数值 $\\mu_c = 0$ 处。然而，这个分岔不是一个跨临界分岔。\n\n对于系统 $\\dot{x} = \\mu x - x^3$，设 $f(x, \\mu) = \\mu x - x^3$。下列哪个陈述给出了精确的数学原因，来解释为什么在 $(x^*, \\mu_c)=(0,0)$ 处的分岔不是一个跨临界分岔？\n\nA. 不动点 $x^*=0$ 并非对所有 $\\mu$ 值都存在。\n\nB. 当 $\\mu$ 穿过 $\\mu_c=0$ 时，不动点 $x^*=0$ 的稳定性不发生改变。\n\nC. 偏导数 $\\frac{\\partial f}{\\partial \\mu}$ 在 $(0,0)$ 的取值为非零。\n\nD. 二阶偏导数 $\\frac{\\partial^2 f}{\\partial x^2}$ 在 $(0,0)$ 的取值为零。\n\nE. 偏导数 $\\frac{\\partial^2 f}{\\partial x \\partial \\mu}$ 在 $(0,0)$ 的取值为零。",
            "solution": "我们旨在找出对于系统 $\\dot{x}=f(x,\\mu)=\\mu x - x^{3}$，在 $(x^{*},\\mu_{c})=(0,0)$ 处不满足跨临界分岔的那个精确条件。\n\n对于一维系统 $\\dot{x}=f(x,\\mu)$ 在 $(0,0)$ 发生的跨临界分岔，标准的非退化性和横截性条件要求：\n1) $f(0,0)=0$,\n2) $f_{x}(0,0)=0$,\n3) $f_{xx}(0,0)\\neq 0$,\n4) $f_{x\\mu}(0,0)\\neq 0$,\n并且（在许多标准表述中）还要求 $f_{\\mu}(0,0)=0$，以便不动点处的主要参数依赖性由混合偏导数所捕获。\n\n计算 $f(x,\\mu)=\\mu x - x^{3}$ 的必要导数：\n- 在候选分岔点的值：\n$$\nf(0,0)=\\mu\\cdot 0 - 0^{3}=0.\n$$\n- 关于 $x$ 的一阶导数：\n$$\nf_{x}(x,\\mu)=\\frac{\\partial}{\\partial x}(\\mu x - x^{3})=\\mu - 3x^{2},\\quad f_{x}(0,0)=0.\n$$\n- 关于 $x$ 的二阶导数：\n$$\nf_{xx}(x,\\mu)=\\frac{\\partial^{2}}{\\partial x^{2}}(\\mu x - x^{3})=-6x,\\quad f_{xx}(0,0)=0.\n$$\n- 混合偏导数：\n$$\nf_{x\\mu}(x,\\mu)=\\frac{\\partial}{\\partial\\mu}(\\mu - 3x^{2})=1,\\quad f_{x\\mu}(0,0)=1\\neq 0.\n$$\n- 关于 $\\mu$ 的一阶导数：\n$$\nf_{\\mu}(x,\\mu)=\\frac{\\partial}{\\partial\\mu}(\\mu x - x^{3})=x,\\quad f_{\\mu}(0,0)=0.\n$$\n\n因此，在 $(0,0)$ 点，条件 $f(0,0)=0$、$f_{x}(0,0)=0$、$f_{x\\mu}(0,0)\\neq 0$ 和 $f_{\\mu}(0,0)=0$ 均得到满足。然而，跨临界分岔的关键非退化性条件 $f_{xx}(0,0)\\neq 0$ 不成立，因为 $f_{xx}(0,0)=0$。因此，该分岔不是跨临界分岔的精确数学原因是，关于 $x$ 的二阶偏导数在 $(0,0)$ 处为零。\n\n在给定的选项中，这与陈述 D 完全对应。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "在真实的生物医学建模中，我们往往无法得到系统的解析表达式，而必须依赖于数值模拟。这项高级练习  通过要求学生开发一种数值算法，从模拟数据中估计关键的偏导数，从而架起了理论与实践之间的桥梁。这项技能对于分析系统生物学中常见的复杂“黑箱”模型的分岔行为至关重要。",
            "id": "3939176",
            "problem": "考虑一个一维常微分方程，用于模拟均匀混合隔室中的稳态细胞密度，其中状态 $x$ 表示无量纲的细胞密度，参数 $\\mu$ 表示净增殖驱动力，二次饱和项源于接触抑制。动力学由初值问题 $\\frac{dx}{dt} = f(x,\\mu;k)$ 给出，其中 $f$ 在 $(x,\\mu)=(0,0)$ 的邻域内是光滑的，并以在一个小时间增量 $\\Delta t$ 上的显式欧拉步的模拟形式指定：从 $x(0)=x_0$ 开始，生成 $x(\\Delta t)=x_0 + \\Delta t\\, f(x_0,\\mu;k)$。假设 $k$ 是一个非负实数参数，表示自限制的强度。\n\n在生物医学系统建模中，当两个平衡分支相交并交换稳定性时，会发生跨临界分岔。在 $(x,\\mu)=(0,0)$ 处的一般跨临界分岔的非退化条件要求 $f_{x\\mu}(0,0)\\neq 0$ 和 $f_{xx}(0,0)\\neq 0$，其中下标表示偏导数。您的任务是开发一种数值方法，该方法仅利用上述显式欧拉步模拟的短时数据，来估计 $f_{x\\mu}(0,0)$ 和 $f_{xx}(0,0)$，然后使用这些估计值来检验跨临界非退化条件。\n\n从微积分和动力系统的核心定义出发，实现一个算法，该算法能够：\n- 通过模拟一个大小为 $\\Delta t$ 的显式欧拉步，从 $x(0)=x$ 开始，并计算有限差分 $(x(\\Delta t)-x)/\\Delta t$，来估计在指定 $(x,\\mu)$ 处的右侧函数 $f(x,\\mu;k)$。\n- 使用围绕 $(x,\\mu)=(0,0)$ 的有限差分法，以及小的对称扰动 $h_x$ 和 $h_\\mu$，从扰动点处 $f(x,\\mu;k)$ 的估计值来数值近似 $f_{x\\mu}(0,0)$ 和 $f_{xx}(0,0)$。\n- 如果对于指定的容差 $\\epsilon0$， $|f_{x\\mu}(0,0)|\\epsilon$ 和 $|f_{xx}(0,0)|\\epsilon$ 同时成立，则宣布跨临界非退化检验通过。\n\n使用以下参数集测试套件 $(k,h_x,h_\\mu,\\Delta t,\\epsilon)$：\n- 情况 1：$k=1.0$, $h_x=10^{-4}$, $h_\\mu=10^{-4}$, $\\Delta t=10^{-6}$, $\\epsilon=10^{-6}$。\n- 情况 2：$k=0.0$, $h_x=10^{-4}$, $h_\\mu=10^{-4}$, $\\Delta t=10^{-6}$, $\\epsilon=10^{-6}$。\n- 情况 3：$k=2.5$, $h_x=5\\times 10^{-5}$, $h_\\mu=2\\times 10^{-4}$, $\\Delta t=5\\times 10^{-7}$, $\\epsilon=10^{-6}$。\n- 情况 4：$k=10^{-12}$, $h_x=10^{-4}$, $h_\\mu=10^{-4}$, $\\Delta t=10^{-6}$, $\\epsilon=10^{-6}$。\n\n假设生物医学模拟器的底层 $f$ 与接触限制增殖一致，具体而言，在原点邻域内 $f(x,\\mu;k)=\\mu x - k x^2$，但您不能使用此闭式形式来计算导数；您必须如上所述从模拟数据中估计 $f$。\n\n对于每个测试用例，您的程序必须生成一个包含三个值的列表：$f_{x\\mu}(0,0)$ 和 $f_{xx}(0,0)$ 的数值估计值（作为浮点数），后跟一个布尔值，指示在容差 $\\epsilon$ 下跨临界非退化检验是否通过。将所有测试用例的结果汇总到单行输出中，该输出包含一个用方括号括起来的逗号分隔列表，例如，$[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]]$，其中每个 $a_i$ 和 $b_i$ 是浮点数，每个 $c_i$ 是布尔值。输出不需要物理单位，也不涉及角度。最终输出格式必须严格符合指定的一行格式。",
            "solution": "该问题要求对由常微分方程 $\\frac{dx}{dt} = f(x,\\mu;k)$ 描述的动力系统，在原点 $(x, \\mu) = (0, 0)$ 处的跨临界分岔的非退化条件进行数值验证。非退化条件由 $f_{x\\mu}(0,0) \\neq 0$ 和 $f_{xx}(0,0) \\neq 0$ 给出，其中下标表示偏导数。函数 $f$ 本身没有以闭式形式给出以供分析；相反，它必须从模拟的显式欧拉步中估计。\n\n该算法方法包括三个主要阶段：首先，定义函数 $f(x, \\mu; k)$ 的数值估计器；其次，在该估计器基础上使用有限差分公式来近似偏导数 $f_{xx}(0,0)$ 和 $f_{x\\mu}(0,0)$；第三，对这些估计的导数的绝对值应用容差 $\\epsilon$ 来检验非退化条件。\n\n第一阶段是估计函数 $f(x,\\mu;k)$。问题通过一个执行单步显式欧拉法的模拟器提供了对系统动力学的访问。对于初始条件 $x(0) = x_0$，在时间 $\\Delta t$ 的状态由以下公式给出：\n$$ x(\\Delta t) = x_0 + \\Delta t \\cdot f(x_0, \\mu; k) $$\n通过代数方法重排此方程，我们可以为函数 $f$ 在点 $(x_0, \\mu)$ 处构建一个估计器：\n$$ \\hat{f}(x_0, \\mu; k) = \\frac{x(\\Delta t) - x_0}{\\Delta t} $$\n问题指明模拟器所使用的底层动力学遵循模型 $f(x,\\mu;k) = \\mu x - k x^2$。虽然我们的算法不能使用这种解析形式来计算导数，但我们必须用它来定义模拟器。将此代入欧拉步可得：\n$$ x(\\Delta t) = x_0 + \\Delta t (\\mu x_0 - k x_0^2) $$\n该函数代表了我们用以估计 $f$ 的模拟“神谕”(simulation oracle)。\n\n第二阶段是偏导数的数值近似。我们采用中心有限差分公式来估计在分岔点 $(x, \\mu) = (0, 0)$ 处的二阶和混合偏导数，使用小的对称扰动 $h_x$ 和 $h_\\mu$。$f_{xx}(0,0)$ 的近似使用三点中心差分公式：\n$$ f_{xx}(0,0) \\approx \\frac{\\hat{f}(h_x, 0; k) - 2\\hat{f}(0, 0; k) + \\hat{f}(-h_x, 0; k)}{h_x^2} $$\n所需的函数值通过我们的估计器 $\\hat{f}$ 获得：$\\hat{f}(h_x, 0; k)$ 是通过从 $x(0) = h_x$ 和 $\\mu=0$ 开始模拟计算的；$\\hat{f}(0, 0; k)$ 是从 $x(0) = 0$ 和 $\\mu=0$ 计算的；$\\hat{f}(-h_x, 0; k)$ 是从 $x(0) = -h_x$ 和 $\\mu=0$ 计算的。$f_{x\\mu}(0,0)$ 的近似使用四点中心差分公式：\n$$ f_{x\\mu}(0,0) \\approx \\frac{\\hat{f}(h_x, h_\\mu; k) - \\hat{f}(h_x, -h_\\mu; k) - \\hat{f}(-h_x, h_\\mu; k) + \\hat{f}(-h_x, -h_\\mu; k)}{4 h_x h_\\mu} $$\n这需要在 $(x, \\mu)$ 平面中以原点为中心的小矩形的四个角点上对我们的函数估计器 $\\hat{f}$ 进行四次求值。例如，$\\hat{f}(h_x, h_\\mu; k)$ 是通过从初始条件 $x(0) = h_x$ 和参数值 $\\mu = h_\\mu$ 开始模拟计算的。\n\n第三个也是最后一个阶段是非退化检验。利用导数的数值估计值（记为 $\\hat{f}_{xx}(0,0)$ 和 $\\hat{f}_{x\\mu}(0,0)$），根据给定的正常数容差 $\\epsilon$ 来检验非退化条件。当且仅当以下两个不等式都成立时，检验被宣布为通过：\n$$ |\\hat{f}_{xx}(0,0)|  \\epsilon \\quad \\text{and} \\quad |\\hat{f}_{x\\mu}(0,0)|  \\epsilon $$\n然后将此过程应用于每个提供的测试用例。对于给定的底层函数 $f(x, \\mu; k) = \\mu x - k x^2$，真实导数是 $f_{xx}(0,0) = -2k$ 和 $f_{x\\mu}(0,0) = 1$。我们的数值估计值应该与这些解析值非常接近，因为有限差分公式对于低阶多项式是精确的。非退化检验实际上变成了检查 $|-2k|  \\epsilon$ 和 $|1|  \\epsilon$ 是否成立。鉴于 $\\epsilon$ 很小（例如 $10^{-6}$），第二个条件几乎总是满足的，因此检验的关键在于参数 $k$ 的量级是否足够大。",
            "answer": "```python\nimport numpy as np\n\ndef _hidden_simulator_step(x0, mu, k, dt):\n    \"\"\"\n    This function represents the \"black box\" biomedical simulator.\n    It computes x(t+dt) from x(t) using one explicit Euler step.\n    The problem specifies the underlying ODE is dx/dt = mu*x - k*x**2.\n    The algorithm must treat this as an oracle and not use its internal formula\n    to compute analytical derivatives.\n    \"\"\"\n    f_val = mu * x0 - k * x0**2\n    return x0 + dt * f_val\n\ndef estimate_f(x0, mu, k, dt):\n    \"\"\"\n    Estimates f(x0, mu; k) by simulating one explicit Euler step of size dt\n    from x(0)=x0 and computing the finite difference (x(dt)-x0)/dt,\n    as required by the problem statement.\n    \"\"\"\n    x_at_dt = _hidden_simulator_step(x0, mu, k, dt)\n    f_estimate = (x_at_dt - x0) / dt\n    return f_estimate\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    # Test suite of parameter sets (k, h_x, h_mu, dt, epsilon)\n    test_cases = [\n        # Case 1: k=1.0, h_x=10^-4, h_mu=10^-4, dt=10^-6, epsilon=10^-6\n        (1.0, 1e-4, 1e-4, 1e-6, 1e-6),\n        # Case 2: k=0.0, h_x=10^-4, h_mu=10^-4, dt=10^-6, epsilon=10^-6\n        (0.0, 1e-4, 1e-4, 1e-6, 1e-6),\n        # Case 3: k=2.5, h_x=5e-5, h_mu=2e-4, dt=5e-7, epsilon=10^-6\n        (2.5, 5e-5, 2e-4, 5e-7, 1e-6),\n        # Case 4: k=10^-12, h_x=10^-4, h_mu=10^-4, dt=10^-6, epsilon=10^-6\n        (1e-12, 1e-4, 1e-4, 1e-6, 1e-6),\n    ]\n\n    results = []\n    for case in test_cases:\n        k, h_x, h_mu, dt, epsilon = case\n\n        # Estimate f_xx(0,0) using a central difference formula.\n        # This requires three calls to the f-estimator.\n        f_plus_x = estimate_f(h_x, 0.0, k, dt)\n        f_zero = estimate_f(0.0, 0.0, k, dt)\n        f_minus_x = estimate_f(-h_x, 0.0, k, dt)\n        est_f_xx = (f_plus_x - 2.0 * f_zero + f_minus_x) / (h_x**2)\n\n        # Estimate f_xmu(0,0) using a central difference formula.\n        # This requires four calls to the f-estimator.\n        f_pp = estimate_f(h_x, h_mu, k, dt)   # Point (+h_x, +h_mu)\n        f_pm = estimate_f(h_x, -h_mu, k, dt)  # Point (+h_x, -h_mu)\n        f_mp = estimate_f(-h_x, h_mu, k, dt)  # Point (-h_x, +h_mu)\n        f_mm = estimate_f(-h_x, -h_mu, k, dt) # Point (-h_x, -h_mu)\n        est_f_xmu = (f_pp - f_pm - f_mp + f_mm) / (4.0 * h_x * h_mu)\n\n        # Perform the transcritical nondegeneracy test.\n        is_nondegenerate = abs(est_f_xmu)  epsilon and abs(est_f_xx)  epsilon\n\n        results.append([est_f_xmu, est_f_xx, is_nondegenerate])\n\n    # Format the final output string exactly as specified: [[...],[...],...]\n    # Using str() on a list of lists creates the required formatting.\n    # Capitalized True/False from Python's str() is the standard representation.\n    output_str = f\"[{','.join(str(res).replace(' ', '') for res in results)}]\"\n    output_str = output_str.replace(\"True\", \"true\").replace(\"False\", \"false\")\n    print(output_str)\n\n# The following is a patched version to match an expected output format\n# without spaces and with lowercase booleans. Standard python `str()` on lists\n# and booleans doesn't do this, so we add post-processing.\ndef solve_patched():\n    test_cases = [\n        (1.0, 1e-4, 1e-4, 1e-6, 1e-6),\n        (0.0, 1e-4, 1e-4, 1e-6, 1e-6),\n        (2.5, 5e-5, 2e-4, 5e-7, 1e-6),\n        (1e-12, 1e-4, 1e-4, 1e-6, 1e-6),\n    ]\n\n    results = []\n    for case in test_cases:\n        k, h_x, h_mu, dt, epsilon = case\n        f_plus_x = estimate_f(h_x, 0.0, k, dt)\n        f_zero = estimate_f(0.0, 0.0, k, dt)\n        f_minus_x = estimate_f(-h_x, 0.0, k, dt)\n        est_f_xx = (f_plus_x - 2.0 * f_zero + f_minus_x) / (h_x**2)\n        f_pp = estimate_f(h_x, h_mu, k, dt)\n        f_pm = estimate_f(h_x, -h_mu, k, dt)\n        f_mp = estimate_f(-h_x, h_mu, k, dt)\n        f_mm = estimate_f(-h_x, -h_mu, k, dt)\n        est_f_xmu = (f_pp - f_pm - f_mp + f_mm) / (4.0 * h_x * h_mu)\n        is_nondegenerate = abs(est_f_xmu) > epsilon and abs(est_f_xx) > epsilon\n        results.append(f\"[{est_f_xmu},{est_f_xx},{str(is_nondegenerate).lower()}]\")\n\n    print(f\"[{','.join(results)}]\")\n\n# For this environment, we will use a simpler printing that matches the original code's intent\n# as `str` is standard and should not be overly manipulated.\nsolve()\n```"
        }
    ]
}