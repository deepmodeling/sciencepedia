{
    "hands_on_practices": [
        {
            "introduction": "在应用复杂的数值方法之前，理解其内部构造至关重要。本练习将引导您从第一性原理出发，构建一个龙格-库塔方法，为您提供一次基础性的实践体验。通过求解代数阶数条件，您不仅能推导出三阶方法的系数，还将探索设计选择如何影响生物医学模型所需的特性，例如系数的非负性 。",
            "id": "3890888",
            "problem": "一个带有消除的药代动力学单室模型由常微分方程 (ODE) $dx/dt = f(t,x)$ 控制，其中 $x(t) \\ge 0$ 代表药物量。在此类动力学的生物医学系统建模中，人们通常寻求既精确又能保持各级计算值和权重非负性的时间步进格式，以避免引入人为的负浓度。考虑一个显式 $3$ 级 Runge–Kutta (RK) 方法，用于在步长 $h>0$ 上逼近 $dx/dt = f(t,x)$ 的解，该方法由一个严格下三角的 Butcher 矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$、权重 $b \\in \\mathbb{R}^{3}$ 和节点 $c \\in \\mathbb{R}^{3}$ 指定，其中 $c_1 = 0$，$c_2 \\in (0,1)$ 且 $c_3 = 1$。该方法需要满足截至 $3$ 阶的三阶条件（使用标准的有根树矩约束）：$b^{\\top}\\mathbf{1} = 1$，$b^{\\top} c = 1/2$，$b^{\\top} c^{[2]} = 1/3$ 和 $b^{\\top} A c = 1/6$，其中 $\\mathbf{1} = (1,1,1)^{\\top}$ 且 $c^{[2]}$ 表示 $c$ 的逐元素平方。假设该方法是显式的，因此有 $c_2 = a_{21}$ 和 $c_3 = a_{31} + a_{32}$。\n\n请从第一性原理出发，即从显式 Runge–Kutta 方法的定义和上述阶条件开始，推导 $b_2$ 和 $b_3$ 关于 $c_2$ 和 $c_3$ 的显式表达式，然后特化到 $c_3 = 1$ 的情况以获得 $b_2(c_2)$ 和 $b_3(c_2)$。接着，使用条件 $b^{\\top} A c = 1/6$ 来表示 $a_{32}$ 和 $a_{31}$（用 $c_2$ 和 $b_3$ 表示）。讨论在生物医学非负性要求下，所得 $(A,b,c)$ 的可行性，包括 $a_{31}$ 是否可以为非负，并确定为使权重为非负而对 $c_2$ 施加的任何限制。\n\n最后，报告 $c_2 \\in (0,1)$ 的上确界，在该上确界下，所有权重 $b_1$、$b_2$ 和 $b_3$ 均为非负，并且阶条件允许一个 $c_3 = 1$ 的有限显式格式。你的最终答案必须是一个精确写出的数字（不要四舍五入）。不需要单位。如果在中间步骤中使用了任何近似值，请不要对最终结果进行四舍五入。",
            "solution": "用户希望分析一个 3 级、三阶的显式 Runge-Kutta 方法。\n\n### 第 1 步：提取已知条件\n- **ODE 模型**：$\\frac{dx}{dt} = f(t,x)$，用于表示药物量 $x(t) \\ge 0$。\n- **方法类型**：显式 $3$ 级 Runge-Kutta (RK) 方法。\n- **Butcher 表的组成部分**：\n    - $A$：一个严格下三角矩阵，$A \\in \\mathbb{R}^{3 \\times 3}$。\n    - $b$：一个权重向量，$b \\in \\mathbb{R}^{3}$。\n    - $c$：一个节点向量，$c \\in \\mathbb{R}^{3}$。\n- **节点条件**：\n    - $c_1 = 0$\n    - $c_2 \\in (0,1)$\n    - $c_3 = 1$\n- **阶条件（最高 3 阶）**：\n    1. $b^{\\top}\\mathbf{1} = 1$，其中 $\\mathbf{1} = (1,1,1)^{\\top}$。\n    2. $b^{\\top}c = 1/2$。\n    3. $b^{\\top}c^{[2]} = 1/3$，其中 $c^{[2]}$ 是 $c$ 的逐元素平方。\n    4. $b^{\\top}Ac = 1/6$。\n- **显式条件**：\n    - $A$ 是严格下三角矩阵，即当 $j \\ge i$ 时 $a_{ij} = 0$。\n    - 对 $i=2,3$，$c_i = \\sum_{j=1}^{i-1} a_{ij}$。这可具体化为 $c_2 = a_{21}$ 和 $c_3 = a_{31} + a_{32}$。\n- **生物医学要求**：权重（$b_i \\ge 0$）和分段系数（$a_{ij} \\ge 0$）的非负性。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题在科学和数学上是合理的。它涉及 Runge-Kutta 方法的标准理论，特别是从阶条件推导系数。其在药代动力学模型中的应用以及相关的非负性约束是生物医学系统数值分析中的一个成熟课题（例如，强稳定性保持方法）。该问题是适定的，提供了足够的方程和约束来推导所要求的量。语言客观而精确。该问题是自洽的，不违反任何物理或数学原理。\n\n### 第 3 步：结论与行动\n问题有效。将提供完整解答。\n\n### 求解推导\n\n分析过程是通过系统地求解由阶条件施加的代数约束来进行的。\n\n**1. 推导权重 $b_i$ 的表达式**\n\n前三个阶条件构成了关于权重 $b_1$、$b_2$ 和 $b_3$ 的一个线性方程组。\n条件如下：\n1. $\\sum_{i=1}^3 b_i = b_1 + b_2 + b_3 = 1$\n2. $\\sum_{i=1}^3 b_i c_i = b_1 c_1 + b_2 c_2 + b_3 c_3 = 1/2$\n3. $\\sum_{i=1}^3 b_i c_i^2 = b_1 c_1^2 + b_2 c_2^2 + b_3 c_3^2 = 1/3$\n\n代入给定的节点值 $c_1 = 0$，系统简化为：\n1. $b_1 + b_2 + b_3 = 1$\n2. $b_2 c_2 + b_3 c_3 = 1/2$\n3. $b_2 c_2^2 + b_3 c_3^2 = 1/3$\n\n我们可以求解后两个方程，用 $c_2$ 和 $c_3$ 表示 $b_2$ 和 $b_3$。这是一个 $2 \\times 2$ 线性系统：\n$$\n\\begin{pmatrix} c_2 & c_3 \\\\ c_2^2 & c_3^2 \\end{pmatrix} \\begin{pmatrix} b_2 \\\\ b_3 \\end{pmatrix} = \\begin{pmatrix} 1/2 \\\\ 1/3 \\end{pmatrix}\n$$\n系数矩阵的行列式是 $D = c_2 c_3^2 - c_3 c_2^2 = c_2 c_3(c_3 - c_2)$。由于 $c_2 \\in (0,1)$ 并且我们已知 $c_3$ 是 $(0,1]$ 中的一个不同值，因此该行列式不为零。使用克莱姆法则：\n$$\nb_2 = \\frac{\\det \\begin{pmatrix} 1/2 & c_3 \\\\ 1/3 & c_3^2 \\end{pmatrix}}{D} = \\frac{\\frac{1}{2}c_3^2 - \\frac{1}{3}c_3}{c_2 c_3(c_3 - c_2)} = \\frac{\\frac{3c_3^2 - 2c_3}{6}}{c_2 c_3(c_3 - c_2)} = \\frac{c_3(3c_3 - 2)}{6c_2 c_3(c_3 - c_2)} = \\frac{3c_3 - 2}{6c_2(c_3 - c_2)}\n$$\n$$\nb_3 = \\frac{\\det \\begin{pmatrix} c_2 & 1/2 \\\\ c_2^2 & 1/3 \\end{pmatrix}}{D} = \\frac{\\frac{1}{3}c_2 - \\frac{1}{2}c_2^2}{c_2 c_3(c_3 - c_2)} = \\frac{\\frac{2c_2 - 3c_2^2}{6}}{c_2 c_3(c_3 - c_2)} = \\frac{c_2(2 - 3c_2)}{6c_2 c_3(c_3 - c_2)} = \\frac{2 - 3c_2}{6c_3(c_3 - c_2)}\n$$\n现在，我们特化到 $c_3 = 1$ 的情况：\n$$\nb_2(c_2) = \\frac{3(1) - 2}{6c_2(1 - c_2)} = \\frac{1}{6c_2(1 - c_2)}\n$$\n$$\nb_3(c_2) = \\frac{2 - 3c_2}{6(1)(1 - c_2)} = \\frac{2 - 3c_2}{6(1 - c_2)}\n$$\n我们从 $b_1 = 1 - b_2 - b_3$ 求得 $b_1$：\n$$\nb_1(c_2) = 1 - \\frac{1}{6c_2(1 - c_2)} - \\frac{2 - 3c_2}{6(1 - c_2)}\n$$\n为了合并这些项，我们使用公分母 $6c_2(1 - c_2)$：\n$$\nb_1(c_2) = \\frac{6c_2(1 - c_2) - 1 - c_2(2 - 3c_2)}{6c_2(1 - c_2)} = \\frac{6c_2 - 6c_2^2 - 1 - 2c_2 + 3c_2^2}{6c_2(1 - c_2)}\n$$\n$$\nb_1(c_2) = \\frac{-3c_2^2 + 4c_2 - 1}{6c_2(1 - c_2)} = \\frac{-(3c_2^2 - 4c_2 + 1)}{6c_2(1 - c_2)}\n$$\n分子可因式分解为 $-(3c_2 - 1)(c_2 - 1)$。\n$$\nb_1(c_2) = \\frac{-(3c_2 - 1)(c_2 - 1)}{6c_2(1 - c_2)} = \\frac{(3c_2 - 1)(1 - c_2)}{6c_2(1 - c_2)}\n$$\n由于 $c_2 \\neq 1$，我们可以消去 $(1 - c_2)$ 项，得到：\n$$\nb_1(c_2) = \\frac{3c_2 - 1}{6c_2}\n$$\n\n**2. 推导 $a_{31}$ 和 $a_{32}$ 的表达式**\n\n第四个阶条件是 $b^{\\top} A c = 1/6$。一个 $3$ 级显式方法的 Butcher 矩阵 $A$ 是：\n$$\nA = \\begin{pmatrix} 0 & 0 & 0 \\\\ a_{21} & 0 & 0 \\\\ a_{31} & a_{32} & 0 \\end{pmatrix}\n$$\n根据显式 RK 条件 $c_2 = a_{21}$ 和 $c_3 = a_{31} + a_{32}$，并设 $c_3=1$，我们有 $a_{21}=c_2$ 和 $a_{31} + a_{32} = 1$。\n首先，计算乘积 $Ac$：\n$$\nAc = \\begin{pmatrix} 0 & 0 & 0 \\\\ a_{21} & 0 & 0 \\\\ a_{31} & a_{32} & 0 \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_2 \\\\ c_3 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ a_{21}c_2 \\\\ a_{31}c_2 + a_{32}c_3 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ c_2^2 \\\\ a_{31}c_2 + a_{32} \\end{pmatrix}\n$$\n现在计算标量积 $b^{\\top}Ac$：\n$$\nb^{\\top}Ac = b_1(0) + b_2(c_2^2) + b_3(a_{31}c_2 + a_{32}) = \\frac{1}{6}\n$$\n将 $a_{31} = 1 - a_{32}$ 代入方程：\n$$\nb_2 c_2^2 + b_3((1 - a_{32})c_2 + a_{32}) = \\frac{1}{6}\n$$\n$$\nb_2 c_2^2 + b_3 c_2 - b_3 a_{32} c_2 + b_3 a_{32} = \\frac{1}{6}\n$$\n$$\na_{32} (b_3 - b_3 c_2) = \\frac{1}{6} - b_2 c_2^2 - b_3 c_2 \\implies a_{32} b_3 (1-c_2) = \\frac{1}{6} - b_2 c_2^2 - b_3 c_2\n$$\n求解 $a_{32}$：\n$$\na_{32} = \\frac{\\frac{1}{6} - b_2 c_2^2 - b_3 c_2}{b_3(1-c_2)}\n$$\n代入 $b_2$ 和 $b_3$ 的表达式：\n- 分母是 $b_3(1 - c_2) = \\frac{2 - 3c_2}{6(1-c_2)}(1-c_2) = \\frac{2 - 3c_2}{6}$。\n- 分子是 $\\frac{1}{6} - \\left(\\frac{1}{6c_2(1 - c_2)}\\right)c_2^2 - \\left(\\frac{2-3c_2}{6(1-c_2)}\\right)c_2 = \\frac{1}{6} - \\frac{c_2}{6(1-c_2)} - \\frac{c_2(2-3c_2)}{6(1-c_2)}$。\n合并分子中的项：\n$$\n\\text{分子} = \\frac{1}{6} \\left(1 - \\frac{c_2}{1-c_2} - \\frac{c_2(2-3c_2)}{1-c_2} \\right) = \\frac{1}{6} \\left( \\frac{1-c_2 - c_2 - 2c_2 + 3c_2^2}{1-c_2} \\right)\n$$\n$$\n\\text{分子} = \\frac{1}{6} \\left( \\frac{3c_2^2 - 4c_2 + 1}{1-c_2} \\right) = \\frac{1}{6} \\frac{(3c_2 - 1)(c_2 - 1)}{1-c_2} = \\frac{1}{6} (-(3c_2 - 1)) = \\frac{1 - 3c_2}{6}\n$$\n因此，我们求得 $a_{32}$：\n$$\na_{32} = \\frac{(1-3c_2)/6}{(2 - 3c_2)/6} = \\frac{1 - 3c_2}{2 - 3c_2}\n$$\n然后从 $a_{31} = 1 - a_{32}$ 求得 $a_{31}$：\n$$\na_{31} = 1 - \\frac{1-3c_2}{2-3c_2} = \\frac{(2-3c_2) - (1-3c_2)}{2-3c_2} = \\frac{1}{2-3c_2}\n$$\n\n**3. 关于可行性和非负性的讨论**\n\n为了使该方法适用于浓度必须保持为正的生物医学应用，希望所有系数 $b_i$ 和 $a_{ij}$ 都是非负的。我们分析对 $c_2 \\in (0,1)$ 的约束。\n\n- **权重的非负性 ($b_i \\ge 0$)**：\n    - $b_1 = \\frac{3c_2 - 1}{6c_2} \\ge 0 \\implies 3c_2 - 1 \\ge 0 \\implies c_2 \\ge \\frac{1}{3}$。\n    - $b_2 = \\frac{1}{6c_2(1-c_2)} > 0$ 对所有 $c_2 \\in (0,1)$ 成立。\n    - $b_3 = \\frac{2 - 3c_2}{6(1-c_2)} \\ge 0 \\implies 2 - 3c_2 \\ge 0 \\implies c_2 \\le \\frac{2}{3}$。\n    - 为使所有权重都非负，我们要求 $c_2 \\in [\\frac{1}{3}, \\frac{2}{3}]$。\n\n- **矩阵系数的非负性 ($a_{ij} \\ge 0$)**：\n    - $a_{21} = c_2 > 0$ 对所有 $c_2 \\in (0,1)$ 成立。\n    - $a_{31} = \\frac{1}{2-3c_2} \\ge 0 \\implies 2-3c_2 > 0 \\implies c_2  \\frac{2}{3}$。因此，$a_{31}$ 可以是非负的。\n    - $a_{32} = \\frac{1-3c_2}{2-3c_2} \\ge 0$。这要求分子和分母同号。由于我们已经要求 $c_2  \\frac{2}{3}$ 以保证 $a_{31}$ 的非负性和良定义性，分母 $2-3c_2$ 是正的。因此，我们只需要分子非负：$1-3c_2 \\ge 0 \\implies c_2 \\le \\frac{1}{3}$。\n\n- **总体非负性**：为使权重和矩阵系数都非负，我们必须找到满足所有条件的 $c_2$ 范围的交集。\n    - 权重的非负性要求 $c_2 \\in [\\frac{1}{3}, \\frac{2}{3}]$。\n    - 矩阵系数的非负性要求 $c_2  \\frac{2}{3}$ 且 $c_2 \\le \\frac{1}{3}$，即 $c_2 \\in (0, \\frac{1}{3}]$。\n    - 将这两个范围取交集，即 $[\\frac{1}{3}, \\frac{2}{3}] \\cap (0, \\frac{1}{3}]$，我们得到的唯一解是单点 $c_2 = \\frac{1}{3}$。\n\n**4. 最终上确界的计算**\n\n最后一个问题要求计算 $c_2 \\in (0,1)$ 的上确界，使得所有权重 $b_i$ 均为非负，且格式是良定义的（即，允许一个有限的显式格式）。这不要求矩阵系数 $a_{ij}$ 为非负。\n\n根据我们的分析，所有 $i=1,2,3$ 的条件 $b_i \\ge 0$ 将 $c_2$ 限制在区间 $[\\frac{1}{3}, \\frac{2}{3}]$ 内。\n只要其系数表达式中的分母不为零，该格式就是“有限的”或良定义的。系数 $b_i$ 对 $c_2 \\in (0,1)$ 都是良定义的。系数 $a_{31}$ 和 $a_{32}$ 的分母为 $2-3c_2$，当 $c_2 = \\frac{2}{3}$ 时为零。因此，该格式在 $c_2 = \\frac{2}{3}$ 处没有定义。\n\n使所有权重非负且存在有限格式的 $c_2$ 值的集合，是权重非负的区间 $[\\frac{1}{3}, \\frac{2}{3}]$ 与格式有定义的域 $c_2 \\neq \\frac{2}{3}$ 的交集。这得出了集合 $[\\frac{1}{3}, \\frac{2}{3})$。\n\n一个集合的上确界是它的最小上界。对于区间 $[\\frac{1}{3}, \\frac{2}{3})$，上确界是 $\\frac{2}{3}$。",
            "answer": "$$\n\\boxed{\\frac{2}{3}}\n$$"
        },
        {
            "introduction": "在为生物医学系统选择数值积分器时，理论精度阶数并非唯一的考量因素。这个编程实践将通过一个代谢路径模型，探讨至关重要的正性保持特性。通过实现并比较一种经典高阶方法（RK4）和一种强稳定性保持（SSP）方法，您将直接观察到积分器的内部结构如何影响其维持物理上有意义的非负浓度的能力 。",
            "id": "3890900",
            "problem": "一个包含三种代谢物的序贯代谢途径，在质量作用一级动力学下，被建模为一个常微分方程 (ODE)。设代谢物浓度为 $x_1(t)$、$x_2(t)$ 和 $x_3(t)$，单位均为毫摩尔 (mM)，速率常数为 $k_1$ 和 $k_2$，单位均为秒的倒数 ($\\text{s}^{-1}$)。该途径为 $x_1 \\rightarrow x_2 \\rightarrow x_3$，形成如下自治系统\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\nx_1 \\\\\nx_2 \\\\\nx_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-k_1 x_1 \\\\\nk_1 x_1 - k_2 x_2 \\\\\nk_2 x_2\n\\end{bmatrix},\n$$\n其初始条件为 $x(0) = [x_1(0), x_2(0), x_3(0)]^\\top$，终止时间为 $T  0$。该系统保持不变量 $I(t) = x_1(t) + x_2(t) + x_3(t)$，因此对于所有 $t \\ge 0$ 都有 $I(t) = I(0)$，并且精确解保持正性，即对于所有 $i \\in \\{1,2,3\\}$ 和所有 $t \\ge 0$ 都有 $x_i(t) \\ge 0$。\n\n您必须实现两种显式时间积分方法：\n- 一种3阶3级的强保稳龙格-库塔 (SSP RK) 方法（记作 SSPRK$(3,3)$）。\n- 经典的4阶龙格-库塔方法（记作 RK$4$），该方法不是强保稳的。\n\n两种方法必须在相同的自适应容差控制下运行。使用以下步长加倍局部误差估计器：给定时间 $t$ 的当前状态 $x$、一个建议的步长 $h  0$ 以及一个 $p$ 阶龙格-库塔方法，计算一个步长为 $h$ 的完整步长结果 $y_h$，以及应用两次步长为 $h/2$ 的两个半步长结果 $y_{h/2}$。将局部误差估计定义为\n$$\ne = \\|y_{h/2} - y_h\\|_{\\infty}.\n$$\n如果 $e \\le \\tau$，则接受该步，其中 $\\tau  0$ 是给定的容差。接受步长后，使用更精确的两个半步长值 $y_{h/2}$ 来推进求解。两种方法均使用相同的控制律更新步长，\n$$\nh_{\\text{new}} = s \\, h \\left(\\frac{\\tau}{\\max(e, \\epsilon)}\\right)^{\\frac{1}{p+1}},\n$$\n其中 $s$ 是一个安全因子，$\\epsilon$ 是一个小的正数下限，以避免除以零。如果拒绝，则不推进时间，并使用相同的公式减小 $h$。如有必要，通过截断 $h$ 来确保最后一步正好到达 $T$。不要钳制或以其他方式修改负状态值；任何负值都必须被记录下来。\n\n将正性保持定义为以下条件：对于所有接受的步长端点 $t_n$，最小分量满足 $\\min_i x_i(t_n) \\ge 0$，其严格绝对阈值为 $\\epsilon_p = 10^{-12}$。当且仅当对于所有 $n$ 都有 $\\min_i x_i(t_n) \\ge -\\epsilon_p$ 时，声明正性得以保持。将不变量误差定义为终止时间处不变量的绝对偏差，\n$$\nE_{\\text{inv}} = \\left| \\left(x_1(T) + x_2(T) + x_3(T)\\right) - \\left(x_1(0) + x_2(0) + x_3(0)\\right) \\right|.\n$$\n\n实现这两种方法时，使用相同的自适应容差 $\\tau$、相同的安全因子 $s$ 和相同的 $\\epsilon$。对两种方法使用相同的初始步长选择策略。对于每个测试用例，程序必须评估并报告两种方法的正性保持布尔值和不变量误差。\n\n使用以下测试套件：\n- 案例 1：$k_1 = 1.0$，$k_2 = 0.5$，$x(0) = [1.0, 0.0, 0.0]^\\top$，$T = 10.0$，$\\tau = 10^{-6}$。\n- 案例 2：$k_1 = 1.0$，$k_2 = 0.5$，$x(0) = [1.0, 0.0, 0.0]^\\top$，$T = 10.0$，$\\tau = 10^{-3}$。\n- 案例 3：$k_1 = 10.0$，$k_2 = 1.0$，$x(0) = [1.0, 0.0, 0.0]^\\top$，$T = 2.0$，$\\tau = 10^{-5}$。\n- 案例 4：$k_1 = 0.1$，$k_2 = 0.1$，$x(0) = [1.0, 0.0, 0.0]^\\top$，$T = 100.0$，$\\tau = 10^{-6}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例按以下顺序提供一个子列表\n$$\n[\\text{pos}_{\\text{SSP}}, \\text{pos}_{\\text{RK4}}, E_{\\text{inv,SSP}}, E_{\\text{inv,RK4}}],\n$$\n其中包含布尔值 $\\text{pos}_{\\text{SSP}}$ 和 $\\text{pos}_{\\text{RK4}}$，以及浮点数 $E_{\\text{inv,SSP}}$ 和 $E_{\\text{inv,RK4}}$。最终输出必须是这四个案例的四个四元列表的列表，例如\n$$\n[[\\text{bool},\\text{bool},\\text{float},\\text{float}], [\\text{bool},\\text{bool},\\text{float},\\text{float}], [\\text{bool},\\text{bool},\\text{float},\\text{float}], [\\text{bool},\\text{bool},\\text{float},\\text{float}]].\n$$\n输出中不需要物理单位；仅报告指定的布尔值和浮点数。",
            "solution": "具有一级质量作用动力学的序贯代谢途径是一个线性房室模型，其状态向量 $x(t) = [x_1(t), x_2(t), x_3(t)]^\\top$ 在以下条件下演化\n$$\n\\frac{d x}{d t} = f(x) =\n\\begin{bmatrix}\n-k_1 x_1 \\\\\nk_1 x_1 - k_2 x_2 \\\\\nk_2 x_2\n\\end{bmatrix},\n$$\n其中 $x(0) = x_0$。此公式基于广为接受的质量作用定律，该定律规定单分子反应 $X \\rightarrow Y$ 以速率 $v = k \\, x$ 进行，其中 $k$ 是速率常数，$x$ 是反应物的浓度。系统矩阵是 Metzler 矩阵（非对角线元素为非负），这意味着正象限对于精确动力学是前向不变的，而不变量 $I(t) = x_1(t) + x_2(t) + x_3(t)$ 是守恒的，因为净通量是途径内部的，从而得到\n$$\n\\frac{d}{dt} \\left( x_1 + x_2 + x_3 \\right) = -k_1 x_1 + \\left(k_1 x_1 - k_2 x_2\\right) + k_2 x_2 = 0.\n$$\n\n为了数值逼近 $x(T)$，我们使用显式龙格-库塔方法。一个 $p$ 阶方法的局部截断误差对于步长 $h$ 满足与 $\\mathcal{O}(h^{p+1})$ 成比例。强保稳 (SSP) 龙格-库塔方法 SSPRK$(3,3)$ 的构造方式是，在保证前向欧拉法稳定性的相同时间步长限制下，它能为特定类型的问题（包括带有 Metzler 矩阵的线性系统）保持某些单调性属性，例如正性。以 Shu-Osher 形式，SSPRK$(3,3)$ 可以写成前向欧拉步的凸组合：\n1. $u^{(1)} = u^n + h f(u^n)$,\n2. $u^{(2)} = \\frac{3}{4} u^n + \\frac{1}{4} \\left( u^{(1)} + h f(u^{(1)}) \\right)$,\n3. $u^{n+1} = \\frac{1}{3} u^n + \\frac{2}{3} \\left( u^{(2)} + h f(u^{(2)}) \\right)$.\n每个阶段都是具有非负系数的凸组合，因此，如果前向欧拉法在给定的步长界限下保持正性，那么 SSP 方案在该界限下也将保持正性。\n\n经典的4阶龙格-库塔方法 (RK$4$) 由其阶段定义\n$$\nk_1 = f(u^n), \\quad\nk_2 = f\\left(u^n + \\frac{h}{2} k_1\\right), \\quad\nk_3 = f\\left(u^n + \\frac{h}{2} k_2\\right), \\quad\nk_4 = f\\left(u^n + h k_3\\right),\n$$\n和更新\n$$\nu^{n+1} = u^n + \\frac{h}{6} \\left( k_1 + 2 k_2 + 2 k_3 + k_4 \\right).\n$$\n此方法不是强保稳的；即使在前向欧拉法不会违反的情况下，它也可能根据步长违反单调性或正性。\n\n为了在两种方法中强制实施相同的容差控制，我们使用步长加倍来估计局部误差。给定状态 $x$ 下的一个建议步长 $h$，使用该方法的一步计算 $y_h$，并使用两个连续的半步计算 $y_{h/2}$。无穷范数误差估计为 $e = \\|y_{h/2} - y_h\\|_\\infty$。如果 $e \\le \\tau$，则接受该步长，并使用 $y_{h/2}$ 推进求解，因为它是更精确的近似值。步长更新利用了局部误差与 $h^{p+1}$ 成比例这一事实：\n$$\nh_{\\text{new}} = s \\, h \\left(\\frac{\\tau}{\\max(e, \\epsilon)}\\right)^{\\frac{1}{p+1}},\n$$\n其中 $s$ 是一个安全因子，以避免过于激进的改变，$\\epsilon$ 是一个小的下限，以处理趋于零的误差估计。如果拒绝（$e  \\tau$），则使用相同的更新公式减小 $h$，并且状态和时间不向前推进。\n\n通过检查每个被接受的步长端点处的最小状态分量来评估正性保持。定义 $\\epsilon_p = 10^{-12}$；如果对于所有被接受的时间 $t_n$，都有 $\\min_i x_i(t_n) \\ge -\\epsilon_p$，我们就声明正性得以保持。不变量保持通过计算 $E_{\\text{inv}} = |(x_1(T) + x_2(T) + x_3(T)) - (x_1(0) + x_2(0) + x_3(0))|$ 来评估。\n\n算法步骤：\n- 初始化 $t = 0$，$x = x_0$，并将 $h$ 设置为一个合理的初始猜测值（例如，$h = \\min(0.1, T/10)$），安全因子 $s$（例如，$s = 0.9$）和下限 $\\epsilon$（例如，$\\epsilon = 10^{-16}$）。\n- 当 $t  T$ 时：\n  - 设置 $h = \\min(h, T - t)$ 以确保 $t$ 不会超过 $T$。\n  - 通过一个完整步长计算 $y_h$，通过两个半步长计算 $y_{h/2}$。\n  - 计算 $e = \\|y_{h/2} - y_h\\|_\\infty$。\n  - 如果 $e \\le \\tau$ 或 $h$ 处于数值下限：\n    - 接受：设置 $x \\leftarrow y_{h/2}$，更新运行中的最小值 $\\min_i x_i$，并更新 $t \\leftarrow t + h$。\n    - 使用指数为 $1/(p+1)$ 的 $h_{\\text{new}}$ 更新 $h$。\n  - 否则：\n    - 拒绝：使用相同的更新公式减小 $h$ 并重复，不推进 $t$ 或 $x$。\n- 到达 $T$ 后，使用保存的最小值计算 $E_{\\text{inv}}$ 和 $\\text{pos}$。\n\n这种设计确保了原则性的、与方法无关的容差控制，同时隔离了 SSP 结构对正性保持和不变量保持的影响。该测试套件涵盖了一个典型途径（$k_1 = 1.0$，$k_2 = 0.5$）在严格（$\\tau = 10^{-6}$）和粗略（$\\tau = 10^{-3}$）容差下的情况，一个更快的上游反应（$k_1 = 10.0$，$k_2 = 1.0$）以探究类刚性行为，以及一个缓慢、长时程的情景（$k_1 = 0.1$，$k_2 = 0.1$，$T = 100.0$）以检查累积不变量误差。输出是布尔值和浮点数，用于量化 SSPRK$(3,3)$ 和 RK$4$ 在相同容差下对正性的保持情况和不变量的保持情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f(x, k1, k2):\n    # RHS of the metabolic pathway ODE: x1 -> x2 -> x3\n    dx1 = -k1 * x[0]\n    dx2 = k1 * x[0] - k2 * x[1]\n    dx3 = k2 * x[1]\n    return np.array([dx1, dx2, dx3], dtype=float)\n\ndef ssprk3_step(x, h, k1, k2):\n    # SSPRK(3,3) in Shu-Osher form\n    f1 = f(x, k1, k2)\n    u1 = x + h * f1\n    f2 = f(u1, k1, k2)\n    u2 = (3.0/4.0) * x + (1.0/4.0) * (u1 + h * f2)\n    f3 = f(u2, k1, k2)\n    u3 = (1.0/3.0) * x + (2.0/3.0) * (u2 + h * f3)\n    return u3\n\ndef rk4_step(x, h, k1, k2):\n    # Classical RK4\n    k1v = f(x, k1, k2)\n    k2v = f(x + 0.5 * h * k1v, k1, k2)\n    k3v = f(x + 0.5 * h * k2v, k1, k2)\n    k4v = f(x + h * k3v, k1, k2)\n    return x + (h / 6.0) * (k1v + 2.0 * k2v + 2.0 * k3v + k4v)\n\ndef integrate(method_step, order, x0, T, tau, k1, k2,\n              safety=0.9, eps_floor=1e-16, min_h=1e-16, max_growth=2.0):\n    # Adaptive integration using step-doubling error estimate\n    t = 0.0\n    x = x0.copy()\n    total0 = float(np.sum(x))\n    min_comp = float(np.min(x))\n    # Initial step heuristic\n    h = min(0.1, T / 10.0) if T > 0 else 0.0\n\n    # Guard against T == 0\n    if T == 0.0:\n        inv_err = abs(float(np.sum(x)) - total0)\n        pos_preserved = (min_comp >= -1e-12)\n        return pos_preserved, inv_err\n\n    while t  T:\n        # Prevent overshoot\n        h = min(h, T - t)\n        if h  min_h:\n            # Accept tiny step to avoid stalling\n            y_full = method_step(x, h, k1, k2)\n            y_half = method_step(method_step(x, 0.5 * h, k1, k2), 0.5 * h, k1, k2)\n            x = y_half\n            t += h\n            min_comp = min(min_comp, float(np.min(x)))\n            # Attempt to grow step modestly\n            h = min(max_growth * h, T - t if T - t > 0 else h)\n            continue\n\n        # One full step\n        y_full = method_step(x, h, k1, k2)\n        # Two half steps\n        y_half = method_step(method_step(x, 0.5 * h, k1, k2), 0.5 * h, k1, k2)\n\n        # Infinity-norm error estimate\n        e = float(np.max(np.abs(y_half - y_full)))\n\n        if e = tau or h = min_h:\n            # Accept: advance with the more accurate two-half-step value\n            x = y_half\n            t += h\n            min_comp = min(min_comp, float(np.min(x)))\n            # Update step size\n            exponent = 1.0 / (order + 1)\n            h_candidate = safety * h * (tau / max(e, eps_floor))**exponent\n            # Limit excessive growth\n            h = min(h_candidate, max_growth * h)\n        else:\n            # Reject: reduce h and retry\n            exponent = 1.0 / (order + 1)\n            h = safety * h * (tau / e)**exponent\n            if h  min_h:\n                h = min_h\n\n    inv_err = abs(float(np.sum(x)) - total0)\n    pos_preserved = (min_comp >= -1e-12)\n    return pos_preserved, inv_err\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k1, k2, x0, T, tau)\n        (1.0, 0.5, np.array([1.0, 0.0, 0.0], dtype=float), 10.0, 1e-6),\n        (1.0, 0.5, np.array([1.0, 0.0, 0.0], dtype=float), 10.0, 1e-3),\n        (10.0, 1.0, np.array([1.0, 0.0, 0.0], dtype=float), 2.0, 1e-5),\n        (0.1, 0.1, np.array([1.0, 0.0, 0.0], dtype=float), 100.0, 1e-6),\n    ]\n\n    results = []\n    for k1, k2, x0, T, tau in test_cases:\n        # SSPRK(3,3): order = 3\n        pos_ssp, inv_ssp = integrate(ssprk3_step, 3, x0, T, tau, k1, k2)\n        # RK4: order = 4\n        pos_rk4, inv_rk4 = integrate(rk4_step, 4, x0, T, tau, k1, k2)\n        results.append([pos_ssp, pos_rk4, inv_ssp, inv_rk4])\n\n    # Final print statement in the exact required format.\n    # Produces a single line: list of per-case lists [bool,bool,float,float]\n    print(f\"[{','.join([str(r) for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多生物医学模型，特别是涉及酶动力学的模型，都是“刚性”的，意味着它们包含在极大不同时间尺度上发生的过程，这对标准的显式求解器构成了重大挑战。这项高级实践将介绍高阶隐式龙格-库塔方法，特别是高斯-勒让德（Gauss-Legendre）族，它们非常适合求解刚性系统。您将使用牛顿法实现一个隐式求解器，并在一个人为构造的解上验证其高阶精度，从而掌握一个处理复杂多尺度生物动力学的强大工具 。",
            "id": "3890916",
            "problem": "实现一个独立的程序，该程序构建一个隐式高斯-勒让德龙格-库塔方法，并将其应用于一个在人造（强迫）解范式下的刚性酶反应网络，并用它来经验性地验证理论收敛阶。该程序必须是通用的、可复现的，不得要求用户输入，并且必须按照本问题末尾的规定输出单行结果。\n\n该模型的基础是一个标准的质量作用酶反应网络，描述了底物在酶的催化下消耗并形成复合物的反应，具体反应为：底物与酶可逆地形成复合物，复合物再不可逆地生成产物。设状态向量为 $y(t) = [S(t), E(t), C(t), P(t)]^\\top$，其中 $S$ 是底物，$E$ 是游离酶，$C$ 是复合物，$P$ 是产物。无强迫项时的质量作用动力学为\n$$\n\\begin{aligned}\n\\frac{dS}{dt} = -k_1 S E + k_2 C, \\\\\n\\frac{dE}{dt} = -k_1 S E + (k_2 + k_3) C, \\\\\n\\frac{dC}{dt} = k_1 S E - (k_2 + k_3) C, \\\\\n\\frac{dP}{dt} = k_3 C,\n\\end{aligned}\n$$\n其中速率常数为 $k_1$、$k_2$、$k_3$。为了能够精确评估误差，使用人造解方法：指定一个光滑、刚性且遵守不变量的精确解 $y_{\\mathrm{ex}}(t)$，并定义一个随时间变化的强迫项 $r(t)$，使得非自治系统\n$$\n\\frac{dy}{dt} = f(t, y) := f_{\\mathrm{mass}}(y) + r(t)\n$$\n对于给定的初始数据，其精确解为 $y_{\\mathrm{ex}}(t)$。此处，$f_{\\mathrm{mass}}(y)$ 是由上述质量作用动力学定义的右端项。人造解必须始终满足酶守恒和底物总量守恒，即对于常数 $E_{\\mathrm{tot}}$ 和 $S_{\\mathrm{tot}}$，有 $E(t) + C(t) = E_{\\mathrm{tot}}$ 和 $S(t) + C(t) + P(t) = S_{\\mathrm{tot}}$。人造解定义如下\n$$\n\\begin{aligned}\nC(t) = c_1 e^{-\\alpha t} + c_2 e^{-t}, \\\\\nE(t) = E_{\\mathrm{tot}} - C(t), \\\\\nS(t) = s_0 + s_1 e^{-t} + s_2 e^{-3 t}, \\\\\nP(t) = S_{\\mathrm{tot}} - S(t) - C(t),\n\\end{aligned}\n$$\n其中 $E_{\\mathrm{tot}}$、$S_{\\mathrm{tot}}$、$c_1$、$c_2$、$s_0$、$s_1$、$s_2$ 为常数，$\\alpha  0$ 为刚性参数。通过恒等式 $r(t) = \\frac{d}{dt} y_{\\mathrm{ex}}(t) - f_{\\mathrm{mass}}(y_{\\mathrm{ex}}(t))$ 来构造 $r(t)$，这保证了 $y_{\\mathrm{ex}}(t)$ 是从 $y_{\\mathrm{ex}}(0)$ 开始的方程 $\\frac{dy}{dt} = f(t, y)$ 的精确解。\n\n您必须使用高斯点配置法实现一个高阶的隐式高斯-勒让德龙格-库塔方法：\n- 实现两级高斯-勒让德方法（其理论全局阶为 $4$）。\n- 实现三级高斯-勒让德方法（其理论全局阶为 $6$）。\n\n隐式级方程必须通过牛顿法求解，该方法使用 $f(t, y)$ 关于 $y$ 的精确雅可比矩阵，即 $f_{\\mathrm{mass}}(y)$ 的雅可比矩阵，因为强迫项 $r(t)$ 与 $y$ 无关。必须在每个时间步组装和求解用于求解各级的块结构牛顿系统。\n\n从第一性原理出发，您的程序应：\n- 根据上述质量作用定律定义 $f_{\\mathrm{mass}}(y)$。\n- 定义 $y_{\\mathrm{ex}}(t)$，其参数值应确保对所有 $t$ 均有 $E(t) + C(t) = E_{\\mathrm{tot}}$ 和 $S(t) + C(t) + P(t) = S_{\\mathrm{tot}}$。\n- 通过 $r(t) = \\frac{d}{dt} y_{\\mathrm{ex}}(t) - f_{\\mathrm{mass}}(y_{\\mathrm{ex}}(t))$ 推导 $r(t)$。\n- 使用 $f_{\\mathrm{mass}}$ 的精确雅可比矩阵实现用于隐式级的牛顿法。\n- 使用固定步长 $h$ 将数值解从 $t=0$ 推进到 $t=T$。\n\n为酶网络和人造解使用以下科学上合理且自洽的参数，这些参数的选择是为了引入刚性并保持不变量：\n- 酶和底物总量：$E_{\\mathrm{tot}} = 1$，$S_{\\mathrm{tot}} = 1$。\n- 动力学速率：$k_1 = 100$，$k_2 = 10$，$k_3 = 1$。\n- 人造解系数：$c_1 = 0.05$，$c_2 = 0.02$，$s_0 = 0.1$，$s_1 = 0.4$，$s_2 = 0.2$。\n\n$f_{\\mathrm{mass}}(y)$ 关于 $y = [S,E,C,P]^\\top$ 的雅可比矩阵是\n$$\nJ(y) =\n\\begin{bmatrix}\n- k_1 E  - k_1 S  k_2  0 \\\\\n- k_1 E  - k_1 S  k_2 + k_3  0 \\\\\nk_1 E  k_1 S  -(k_2 + k_3)  0 \\\\\n0  0  k_3  0\n\\end{bmatrix}.\n$$\n\n您的程序必须通过网格加密来验证理论阶，使用在 $t = T$ 时的精确误差，定义为 $e(h) = \\lVert y_{\\mathrm{num}}(T; h) - y_{\\mathrm{ex}}(T) \\rVert_2$。对于每种方法，通过以下公式计算观测阶\n$$\np(h_1 \\to h_2) = \\frac{\\log\\left( \\frac{e(h_1)}{e(h_2)} \\right)}{\\log(2)},\n$$\n其中步长连续减半 $h_2 = h_1 / 2$。\n\n测试套件和答案规范：\n- 情况 $1$（正常路径，中等刚性）：两级高斯-勒让德，最终时间 $T = 1$，刚性参数 $\\alpha = 50$，步长 $h \\in \\{0.2, 0.1, 0.05\\}$。报告两个浮点数：$p(0.2 \\to 0.1)$ 和 $p(0.1 \\to 0.05)$。\n- 情况 $2$（高阶覆盖）：三级高斯-勒让德，最终时间 $T = 1$，刚性参数 $\\alpha = 50$，步长 $h \\in \\{0.1, 0.05, 0.025\\}$。报告两个浮点数：$p(0.1 \\to 0.05)$ 和 $p(0.05 \\to 0.025)$。\n- 情况 $3$（边缘情况，更强刚性）：两级高斯-勒让德，最终时间 $T = 0.2$，刚性参数 $\\alpha = 200$，步长 $h \\in \\{0.05, 0.025, 0.0125\\}$。报告两个浮点数：$p(0.05 \\to 0.025)$ 和 $p(0.025 \\to 0.0125)$。\n\n所有初始条件必须设置为 $t=0$ 时的人造精确解：\n$$\ny(0) = y_{\\mathrm{ex}}(0).\n$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$\n[\\;p_{1,1},\\;p_{1,2},\\;p_{2,1},\\;p_{2,2},\\;p_{3,1},\\;p_{3,2}\\;],\n$$\n其中 $p_{i,j}$ 表示上述定义的情况 $i$ 和配对 $j$ 的观测阶。例如，输出应类似于 $[x_1,x_2,x_3,x_4,x_5,x_6]$，其中每个 $x_k$ 是一个浮点数。不得打印任何其他文本。",
            "solution": "用户要求实现并验证用于刚性酶动力学模型的隐式高斯-勒让德龙格-库塔方法。验证将使用人造解方法进行，以便能够精确计算误差并进行收敛阶的经验性分析。\n\n### 步骤1：问题构建与数学框架\n\n问题围绕一个形式为 $\\frac{dy}{dt} = f(t, y)$ 的非自治常微分方程组（ODEs）的数值求解展开。状态向量为 $y(t) = [S(t), E(t), C(t), P(t)]^\\top$，分别代表底物、酶、复合物和产物的浓度。\n\n右端函数 $f(t, y)$ 由两部分组成：一个来自质量作用动力学的项 $f_{\\mathrm{mass}}(y)$，以及一个通过人造解方法引入的随时间变化的强迫项 $r(t)$。\n$$\n\\frac{dy}{dt} = f(t, y) = f_{\\mathrm{mass}}(y) + r(t)\n$$\n质量作用动力学由下式给出：\n$$\nf_{\\mathrm{mass}}(y) = \\begin{bmatrix}\n-k_1 S E + k_2 C \\\\\n-k_1 S E + (k_2 + k_3) C \\\\\nk_1 S E - (k_2 + k_3) C \\\\\nk_3 C\n\\end{bmatrix}\n$$\n指定一个人造解 $y_{\\mathrm{ex}}(t)$ 以满足特定的守恒定律：$E(t) + C(t) = E_{\\mathrm{tot}}$ 和 $S(t) + C(t) + P(t) = S_{\\mathrm{tot}}$。然后定义强迫项 $r(t)$，使得 $y_{\\mathrm{ex}}(t)$ 是该 ODE 系统的精确解：\n$$\nr(t) = \\frac{d y_{\\mathrm{ex}}(t)}{dt} - f_{\\mathrm{mass}}(y_{\\mathrm{ex}}(t))\n$$\n我们需要计算 $y_{\\mathrm{ex}}(t)$ 及其导数 $\\frac{d y_{\\mathrm{ex}}(t)}{dt}$ 来构建完整的 ODE 系统。\n\n牛顿法求解器需要 ODE 右端项的雅可比矩阵 $J(t, y) = \\frac{\\partial f(t, y)}{\\partial y}$。由于强迫项 $r(t)$ 与 $y$ 无关，雅可比矩阵就是质量作用项的雅可比矩阵，即 $J(t, y) = J_{\\mathrm{mass}}(y)$。问题提供了这个雅可比矩阵：\n$$\nJ_{\\mathrm{mass}}(y) =\n\\begin{bmatrix}\n- k_1 E  - k_1 S  k_2  0 \\\\\n- k_1 E  - k_1 S  k_2 + k_3  0 \\\\\nk_1 E  k_1 S  -(k_2 + k_3)  0 \\\\\n0  0  k_3  0\n\\end{bmatrix}\n$$\n\n### 步骤2：隐式龙格-库塔方法（高斯-勒让德）\n\n一个 $s$ 级隐式龙格-库塔（IRK）方法使用以下公式将解从时间 $t_n$ 的 $y_n$ 推进到时间 $t_{n+1} = t_n + h$ 的 $y_{n+1}$：\n$$\ny_{n+1} = y_n + h \\sum_{i=1}^s b_i k_i\n$$\n各级导数 $k_i$ 是一个耦合的、通常为非线性的方程组的解：\n$$\nk_i = f\\left(t_n + c_i h, y_n + h \\sum_{j=1}^s a_{ij} k_j\\right), \\quad i = 1, \\dots, s\n$$\n更方便的做法是求解各级的值 $Y_i = y_n + h \\sum_{j=1}^s a_{ij} k_j$。各级值的方程组为：\n$$\nY_i = y_n + h \\sum_{j=1}^s a_{ij} f(t_n + c_j h, Y_j), \\quad i = 1, \\dots, s\n$$\n这是一个关于未知量 $Y_1, \\dots, Y_s$ 的 $s \\times d$ 非线性方程组，其中 $d=4$ 是 $y$ 的维数。我们使用牛顿法来求解这个系统。\n\n#### 求解各级值的牛顿法\n令 $\\mathbf{Y} = [Y_1^\\top, \\ldots, Y_s^\\top]^\\top$ 为所有级值的拼接向量。我们寻求函数 $\\mathbf{G}(\\mathbf{Y}) = 0$ 的根，其中：\n$$\nG_i(\\mathbf{Y}) = Y_i - y_n - h \\sum_{j=1}^s a_{ij} f(t_n + c_j h, Y_j)\n$$\n牛顿迭代为 $\\mathbf{Y}^{(k+1)} = \\mathbf{Y}^{(k)} + \\Delta\\mathbf{Y}^{(k)}$，其中更新量 $\\Delta\\mathbf{Y}^{(k)}$ 是以下线性系统的解：\n$$\n\\mathcal{J}_G(\\mathbf{Y}^{(k)}) \\Delta\\mathbf{Y}^{(k)} = -\\mathbf{G}(\\mathbf{Y}^{(k)})\n$$\n$\\mathbf{G}$ 的雅可比矩阵，记作 $\\mathcal{J}_G$，是一个大小为 $(s \\cdot d) \\times (s \\cdot d)$ 的块矩阵。位于 $(i,j)$ 位置的块是 $\\frac{\\partial G_i}{\\partial Y_j} = \\delta_{ij}I_d - h a_{ij} J(t_n+c_j h, Y_j)$，其中 $I_d$ 是 $d \\times d$ 的单位矩阵，$\\delta_{ij}$ 是克罗内克 δ。\n\n所需的高斯-勒让德方法的布赫表 $(A, b, c)$ 如下：\n\n1.  **两级高斯-勒让德（4阶）**：\n    -   $s=2$, $c_1 = \\frac{1}{2} - \\frac{\\sqrt{3}}{6}$, $c_2 = \\frac{1}{2} + \\frac{\\sqrt{3}}{6}$\n    -   $b = [1/2, 1/2]^\\top$\n    -   $A = \\begin{pmatrix} 1/4  1/4 - \\sqrt{3}/6 \\\\ 1/4 + \\sqrt{3}/6  1/4 \\end{pmatrix}$\n\n2.  **三级高斯-勒让德（6阶）**：\n    -   $s=3$, $c_1 = \\frac{1}{2} - \\frac{\\sqrt{15}}{10}$, $c_2 = \\frac{1}{2}$, $c_3 = \\frac{1}{2} + \\frac{\\sqrt{15}}{10}$\n    -   $b = [5/18, 8/18, 5/18]^\\top$\n    -   $A = \\begin{pmatrix}\n        5/36  2/9 - \\sqrt{15}/15  5/36 - \\sqrt{15}/30 \\\\\n        5/36 + \\sqrt{15}/24  2/9  5/36 - \\sqrt{15}/24 \\\\\n        5/36 + \\sqrt{15}/30  2/9 + \\sqrt{15}/15  5/36\n        \\end{pmatrix}$\n\n### 步骤3：经验性阶验证\n\n程序将按照三个测试用例的规定执行模拟。对于每个用例，它将使用一系列递减的步长 $h$ 对 ODE 系统从 $t=0$ 到 $t=T$ 进行积分。\n将最终时刻的数值解 $y_{\\mathrm{num}}(T; h)$ 与精确解 $y_{\\mathrm{ex}}(T)$ 进行比较，以计算误差 $e(h) = \\lVert y_{\\mathrm{num}}(T; h) - y_{\\mathrm{ex}}(T) \\rVert_2$。\n然后，对于连续的步长加密 $h_2 = h_1 / 2$，计算观测到的收敛阶 $p$：\n$$\np(h_1 \\to h_2) = \\frac{\\log(e(h_1)/e(h_2))}{\\log(2)}\n$$\n所有测试用例的结果将被汇总到一个列表中作为最终输出。实现将遵循上述详细逻辑，将物理模型和数值求解器封装到独立的、定义明确的组件中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and applies implicit Gauss-Legendre Runge-Kutta methods to\n    a stiff enzyme reaction network, and verifies the theoretical convergence order.\n    \"\"\"\n\n    # --- Butcher Tableaus for Gauss-Legendre Methods ---\n    s3 = np.sqrt(3)\n    s15 = np.sqrt(15)\n\n    TABLEAUS = {\n        'GL4': {  # 2-stage, order 4\n            'A': np.array([\n                [1/4, 1/4 - s3/6],\n                [1/4 + s3/6, 1/4]\n            ]),\n            'b': np.array([1/2, 1/2]),\n            'c': np.array([1/2 - s3/6, 1/2 + s3/6])\n        },\n        'GL6': {  # 3-stage, order 6\n            'A': np.array([\n                [5/36, 2/9 - s15/15, 5/36 - s15/30],\n                [5/36 + s15/24, 2/9, 5/36 - s15/24],\n                [5/36 + s15/30, 2/9 + s15/15, 5/36]\n            ]),\n            'b': np.array([5/18, 8/18, 5/18]),\n            'c': np.array([1/2 - s15/10, 1/2, 1/2 + s15/10])\n        }\n    }\n\n    class EnzymeModel:\n        \"\"\"\n        Represents the enzyme kinetics model with a manufactured solution.\n        y = [S, E, C, P]\n        \"\"\"\n        def __init__(self, alpha):\n            self.k1, self.k2, self.k3 = 100.0, 10.0, 1.0\n            self.Etot, self.Stot = 1.0, 1.0\n            self.c1, self.c2 = 0.05, 0.02\n            self.s0, self.s1, self.s2 = 0.1, 0.4, 0.2\n            self.alpha = float(alpha)\n            self.dim = 4\n\n        def f_mass(self, y):\n            S, E, C, _ = y\n            r1 = self.k1 * S * E\n            r2 = self.k2 * C\n            r3 = self.k3 * C\n            return np.array([\n                -r1 + r2,\n                -r1 + r2 + r3,\n                 r1 - r2 - r3,\n                 r3\n            ])\n\n        def J_mass(self, y):\n            S, E, _, _ = y\n            J = np.zeros((self.dim, self.dim))\n            J[0, 0] = -self.k1 * E\n            J[0, 1] = -self.k1 * S\n            J[0, 2] = self.k2\n            J[1, 0] = -self.k1 * E\n            J[1, 1] = -self.k1 * S\n            J[1, 2] = self.k2 + self.k3\n            J[2, 0] = self.k1 * E\n            J[2, 1] = self.k1 * S\n            J[2, 2] = -(self.k2 + self.k3)\n            J[3, 2] = self.k3\n            return J\n\n        def y_ex(self, t):\n            exp_a = np.exp(-self.alpha * t)\n            exp_1 = np.exp(-t)\n            exp_3 = np.exp(-3.0 * t)\n            C = self.c1 * exp_a + self.c2 * exp_1\n            E = self.Etot - C\n            S = self.s0 + self.s1 * exp_1 + self.s2 * exp_3\n            P = self.Stot - S - C\n            return np.array([S, E, C, P])\n\n        def y_ex_dot(self, t):\n            exp_a = np.exp(-self.alpha * t)\n            exp_1 = np.exp(-t)\n            exp_3 = np.exp(-3.0 * t)\n            C_dot = -self.alpha * self.c1 * exp_a - self.c2 * exp_1\n            E_dot = -C_dot\n            S_dot = -self.s1 * exp_1 - 3.0 * self.s2 * exp_3\n            P_dot = -S_dot - C_dot\n            return np.array([S_dot, E_dot, C_dot, P_dot])\n        \n        def r(self, t):\n            return self.y_ex_dot(t) - self.f_mass(self.y_ex(t))\n\n        def f(self, t, y):\n            return self.f_mass(y) + self.r(t)\n        \n        def J(self, t, y):\n            return self.J_mass(y)\n\n    class IRKSolver:\n        \"\"\"\n        An implicit Runge-Kutta solver using Newton's method for stage equations.\n        \"\"\"\n        def __init__(self, model, tableau, newton_tol=1e-12, max_newton_iter=10):\n            self.model = model\n            self.A = tableau['A']\n            self.b = tableau['b']\n            self.c = tableau['c']\n            self.s = len(self.b)\n            self.dim = model.dim\n            self.tol = newton_tol\n            self.max_iter = max_newton_iter\n\n        def step(self, y_n, t_n, h):\n            # Initial guess for stage values Y_i is y_n for all i\n            Y = np.tile(y_n, (self.s, 1))\n\n            # Newton's method for stage values\n            for _ in range(self.max_iter):\n                # Form residual G and Jacobian J_G\n                f_vals = np.array([self.model.f(t_n + self.c[i] * h, Y[i, :]) for i in range(self.s)])\n                G = Y - np.tile(y_n, (self.s, 1)) - h * (self.A @ f_vals)\n                \n                J_vals = [self.model.J(t_n + self.c[i] * h, Y[i, :]) for i in range(self.s)]\n                J_G = np.zeros((self.s * self.dim, self.s * self.dim))\n\n                for i in range(self.s):\n                    for j in range(self.s):\n                        block = -h * self.A[i, j] * J_vals[j]\n                        if i == j:\n                            block += np.identity(self.dim)\n                        J_G[i*self.dim:(i+1)*self.dim, j*self.dim:(j+1)*self.dim] = block\n\n                # Solve linear system and update\n                delta_Y_flat = np.linalg.solve(J_G, -G.flatten())\n                Y += delta_Y_flat.reshape((self.s, self.dim))\n\n                if np.linalg.norm(delta_Y_flat)  self.tol:\n                    break\n            \n            # Compute final solution y_{n+1}\n            f_vals = np.array([self.model.f(t_n + self.c[i] * h, Y[i, :]) for i in range(self.s)])\n            y_np1 = y_n + h * (self.b @ f_vals)\n            return y_np1\n\n    def run_simulation(solver, model, T, h):\n        num_steps = int(round(T / h))\n        y = model.y_ex(0.0)\n        t = 0.0\n        for _ in range(num_steps):\n            y = solver.step(y, t, h)\n            t += h\n        return y\n    \n    test_cases = [\n        {'id': 1, 'method': 'GL4', 'T': 1.0, 'alpha': 50, 'hs': [0.2, 0.1, 0.05]},\n        {'id': 2, 'method': 'GL6', 'T': 1.0, 'alpha': 50, 'hs': [0.1, 0.05, 0.025]},\n        {'id': 3, 'method': 'GL4', 'T': 0.2, 'alpha': 200, 'hs': [0.05, 0.025, 0.0125]}\n    ]\n\n    all_orders = []\n    for case in test_cases:\n        model = EnzymeModel(alpha=case['alpha'])\n        tableau = TABLEAUS[case['method']]\n        solver = IRKSolver(model, tableau)\n        \n        errors = []\n        for h in case['hs']:\n            y_final_num = run_simulation(solver, model, case['T'], h)\n            y_final_ex = model.y_ex(case['T'])\n            error = np.linalg.norm(y_final_num - y_final_ex)\n            errors.append(error)\n        \n        order1 = np.log(errors[0] / errors[1]) / np.log(2.0)\n        order2 = np.log(errors[1] / errors[2]) / np.log(2.0)\n        all_orders.extend([order1, order2])\n\n    print(f\"[{','.join(map(str, all_orders))}]\")\n\nsolve()\n\n```"
        }
    ]
}