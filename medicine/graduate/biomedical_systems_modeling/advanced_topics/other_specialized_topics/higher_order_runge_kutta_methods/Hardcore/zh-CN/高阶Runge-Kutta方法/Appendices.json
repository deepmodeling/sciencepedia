{
    "hands_on_practices": [
        {
            "introduction": "龙格-库塔方法中的“布彻表”系数并非随意设定。它们是通过求解一组被称为“阶数条件”的代数方程组得到的。本练习将引导你亲手完成这一推导过程，让你体验从零开始构建一个三阶龙格-库塔方法，并将其与生物医学模型（如药代动力学）中保持浓度非负性的实际需求联系起来 ()。",
            "id": "3890888",
            "problem": "一个带消除的药代动力学单室模型由常微分方程 (ODE) $dx/dt = f(t,x)$ 控制，其中 $x(t) \\ge 0$ 代表药物量。在此类动力学的生物医学系统建模中，人们通常寻求精确且能保持各阶段求值和权重非负性的时间步进格式，以避免引入人为的负浓度。考虑一个显式 $3$ 级龙格-库塔 (RK) 方法，用于在步长 $h>0$ 上近似求解 $dx/dt = f(t,x)$ 的解。该方法由一个严格下三角的布彻 (Butcher) 矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$、权重 $b \\in \\mathbb{R}^{3}$ 和节点 $c \\in \\mathbb{R}^{3}$ 指定，其中 $c_1 = 0$，$c_2 \\in (0,1)$ 且 $c_3 = 1$。该方法需要满足最高 $3$ 阶的精度条件（使用标准的根树矩约束）：$b^{\\top}\\mathbf{1} = 1$，$b^{\\top} c = 1/2$，$b^{\\top} c^{[2]} = 1/3$ 和 $b^{\\top} A c = 1/6$，其中 $\\mathbf{1} = (1,1,1)^{\\top}$ 且 $c^{[2]}$ 表示 $c$ 的逐元素平方。假设该方法是显式的，因此 $c_2 = a_{21}$ 且 $c_3 = a_{31} + a_{32}$。\n\n根据第一性原理，从显式龙格-库塔方法的定义和上述阶数条件出发，推导出 $b_2$ 和 $b_3$ 关于 $c_2$ 和 $c_3$ 的显式表达式，然后特化到 $c_3 = 1$ 的情况以获得 $b_2(c_2)$ 和 $b_3(c_2)$。接下来，使用条件 $b^{\\top} A c = 1/6$ 将 $a_{32}$ 和 $a_{31}$ 表示为 $c_2$ 和 $b_3$ 的函数。讨论所得到的 $(A,b,c)$ 在生物医学非负性要求下的可行性，包括 $a_{31}$ 是否可以为非负，并确定为使权重为非负所需对 $c_2$ 的任何限制。\n\n最后，报告 $c_2 \\in (0,1)$ 的上确界，在该上确界下，所有权重 $b_1$, $b_2$, 和 $b_3$ 均为非负，并且阶数条件允许一个在 $c_3 = 1$ 时具有有限系数的显式格式。你的最终答案必须是一个精确写出的数字（不要四舍五入）。不需要单位。如果在中间步骤中使用了任何近似，请不要对最终结果进行四舍五入。",
            "solution": "用户希望分析一个 3 级、三阶显式龙格-库塔方法。\n\n### 步骤 1：提取已知条件\n- **ODE 模型**: $\\frac{dx}{dt} = f(t,x)$，用于表示药物量 $x(t) \\ge 0$。\n- **方法类型**: 显式 $3$ 级龙格-库塔 (RK) 方法。\n- **布彻表 (Butcher Tableau) 组成部分**:\n    - `A`: 一个严格下三角矩阵，$A \\in \\mathbb{R}^{3 \\times 3}$。\n    - `b`: 一个权重向量，$b \\in \\mathbb{R}^{3}$。\n    - `c`: 一个节点向量，$c \\in \\mathbb{R}^{3}$。\n- **节点条件**:\n    - $c_1 = 0$\n    - $c_2 \\in (0,1)$\n    - $c_3 = 1$ (在问题描述的某些部分，这最初被指定为 $c_3 \\in (0,1]$，但主要的推导和最终问题将 $c_3$ 固定为 $1$。让我们按照指示，在相关部分假设 $c_3=1$。)\n- **阶数条件 (最高 3 阶)**:\n    1. $b^{\\top}\\mathbf{1} = 1$，其中 $\\mathbf{1} = (1,1,1)^{\\top}$。\n    2. $b^{\\top}c = 1/2$。\n    3. $b^{\\top}c^{[2]} = 1/3$，其中 $c^{[2]}$ 是 $c$ 的逐元素平方。\n    4. $b^{\\top}Ac = 1/6$。\n- **显式性条件**:\n    - A 是严格下三角的，即对于 $j \\ge i$ 有 $a_{ij} = 0$。\n    - $c_i = \\sum_{j=1}^{i-1} a_{ij}$ 对于 $i=2,3$。这可具体化为 $c_2 = a_{21}$ 和 $c_3 = a_{31} + a_{32}$。\n- **生物医学要求**: 权重 ($b_i \\ge 0$) 和阶段系数 ($a_{ij} \\ge 0$) 的非负性。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学和数学上是合理的。它涉及龙格-库塔方法的标准理论，特别是从阶数条件推导系数。其在药代动力学模型中的应用以及相关的非负性约束是生物医学系统数值分析中的一个成熟课题（例如，强稳定性保持方法）。该问题是适定的，提供了足够的方程和约束来推导所要求的量。语言客观而精确。该问题是自洽的，不违反任何物理或数学原理。\n\n### 步骤 3：结论与行动\n该问题有效。将提供完整的解答。\n\n### 解答推导\n\n分析通过系统地求解阶数条件所施加的代数约束来进行。\n\n**1. 推导权重 $b_i$ 的表达式**\n\n前三个阶数条件构成了关于权重 $b_1$、$b_2$ 和 $b_3$ 的一个线性系统。\n条件是：\n1. $\\sum_{i=1}^3 b_i = b_1 + b_2 + b_3 = 1$\n2. $\\sum_{i=1}^3 b_i c_i = b_1 c_1 + b_2 c_2 + b_3 c_3 = 1/2$\n3. $\\sum_{i=1}^3 b_i c_i^2 = b_1 c_1^2 + b_2 c_2^2 + b_3 c_3^2 = 1/3$\n\n代入给定的节点值 $c_1 = 0$，系统简化为：\n1. $b_1 + b_2 + b_3 = 1$\n2. $b_2 c_2 + b_3 c_3 = 1/2$\n3. $b_2 c_2^2 + b_3 c_3^2 = 1/3$\n\n我们可以求解最后两个方程，用 $c_2$ 和 $c_3$ 表示 $b_2$ 和 $b_3$。这是一个 $2 \\times 2$ 的线性系统：\n$$\n\\begin{pmatrix} c_2 & c_3 \\\\ c_2^2 & c_3^2 \\end{pmatrix} \\begin{pmatrix} b_2 \\\\ b_3 \\end{pmatrix} = \\begin{pmatrix} 1/2 \\\\ 1/3 \\end{pmatrix}\n$$\n系数矩阵的行列式是 $D = c_2 c_3^2 - c_3 c_2^2 = c_2 c_3(c_3 - c_2)$。由于 $c_2 \\in (0,1)$ 并且给定的 $c_3$ 是 $(0,1]$ 中的一个不同值，该行列式不为零。使用克莱姆法则 (Cramer's rule)：\n$$\nb_2 = \\frac{\\det \\begin{pmatrix} 1/2 & c_3 \\\\ 1/3 & c_3^2 \\end{pmatrix}}{D} = \\frac{\\frac{1}{2}c_3^2 - \\frac{1}{3}c_3}{c_2 c_3(c_3 - c_2)} = \\frac{\\frac{3c_3^2 - 2c_3}{6}}{c_2 c_3(c_3 - c_2)} = \\frac{c_3(3c_3 - 2)}{6c_2 c_3(c_3 - c_2)} = \\frac{3c_3 - 2}{6c_2(c_3 - c_2)}\n$$\n$$\nb_3 = \\frac{\\det \\begin{pmatrix} c_2 & 1/2 \\\\ c_2^2 & 1/3 \\end{pmatrix}}{D} = \\frac{\\frac{1}{3}c_2 - \\frac{1}{2}c_2^2}{c_2 c_3(c_3 - c_2)} = \\frac{\\frac{2c_2 - 3c_2^2}{6}}{c_2 c_3(c_3 - c_2)} = \\frac{c_2(2 - 3c_2)}{6c_2 c_3(c_3 - c_2)} = \\frac{2 - 3c_2}{6c_3(c_3 - c_2)}\n$$\n现在，我们特化到 $c_3 = 1$ 的情况：\n$$\nb_2(c_2) = \\frac{3(1) - 2}{6c_2(1 - c_2)} = \\frac{1}{6c_2(1 - c_2)}\n$$\n$$\nb_3(c_2) = \\frac{2 - 3c_2}{6(1)(1 - c_2)} = \\frac{2 - 3c_2}{6(1 - c_2)}\n$$\n我们从 $b_1 = 1 - b_2 - b_3$ 求得 $b_1$：\n$$\nb_1(c_2) = 1 - \\frac{1}{6c_2(1 - c_2)} - \\frac{2 - 3c_2}{6(1 - c_2)}\n$$\n为合并这些项，我们使用公分母 $6c_2(1 - c_2)$：\n$$\nb_1(c_2) = \\frac{6c_2(1 - c_2) - 1 - c_2(2 - 3c_2)}{6c_2(1 - c_2)} = \\frac{6c_2 - 6c_2^2 - 1 - 2c_2 + 3c_2^2}{6c_2(1 - c_2)}\n$$\n$$\nb_1(c_2) = \\frac{-3c_2^2 + 4c_2 - 1}{6c_2(1 - c_2)} = \\frac{-(3c_2^2 - 4c_2 + 1)}{6c_2(1 - c_2)}\n$$\n分子可因式分解为 $-(3c_2 - 1)(c_2 - 1)$。\n$$\nb_1(c_2) = \\frac{-(3c_2 - 1)(c_2 - 1)}{6c_2(1 - c_2)} = \\frac{(3c_2 - 1)(1 - c_2)}{6c_2(1 - c_2)}\n$$\n由于 $c_2 \\neq 1$，我们可以消去项 $(1 - c_2)$，得到：\n$$\nb_1(c_2) = \\frac{3c_2 - 1}{6c_2}\n$$\n\n**2. 推导 $a_{31}$ 和 $a_{32}$ 的表达式**\n\n第四个阶数条件是 $b^{\\top} A c = 1/6$。一个 3 级显式方法的布彻矩阵 $A$ 是：\n$$\nA = \\begin{pmatrix} 0 & 0 & 0 \\\\ a_{21} & 0 & 0 \\\\ a_{31} & a_{32} & 0 \\end{pmatrix}\n$$\n根据显式 RK 条件 $c_2 = a_{21}$ 和 $c_3 = a_{31} + a_{32}$，并设 $c_3=1$，我们有 $a_{21}=c_2$ 和 $a_{31} + a_{32} = 1$。\n首先，计算乘积 $Ac$：\n$$\nAc = \\begin{pmatrix} 0 & 0 & 0 \\\\ a_{21} & 0 & 0 \\\\ a_{31} & a_{32} & 0 \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_2 \\\\ c_3 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ a_{21}c_2 \\\\ a_{31}c_2 + a_{32}c_3 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ c_2^2 \\\\ a_{31}c_2 + a_{32} \\end{pmatrix}\n$$\n现在计算标量积 $b^{\\top}Ac$：\n$$\nb^{\\top}Ac = b_1(0) + b_2(c_2^2) + b_3(a_{31}c_2 + a_{32}) = \\frac{1}{6}\n$$\n将 $a_{31} = 1 - a_{32}$ 代入方程：\n$$\nb_2 c_2^2 + b_3((1 - a_{32})c_2 + a_{32}) = \\frac{1}{6}\n$$\n$$\nb_2 c_2^2 + b_3 c_2 - b_3 a_{32} c_2 + b_3 a_{32} = \\frac{1}{6}\n$$\n$$\na_{32} (b_3 - b_3 c_2) = \\frac{1}{6} - b_2 c_2^2 - b_3 c_2 \\implies a_{32} b_3 (1-c_2) = \\frac{1}{6} - b_2 c_2^2 - b_3 c_2\n$$\n解出 $a_{32}$：\n$$\na_{32} = \\frac{\\frac{1}{6} - b_2 c_2^2 - b_3 c_2}{b_3(1-c_2)}\n$$\n代入 $b_2$ 和 $b_3$ 的表达式：\n- 分母是 $b_3(1 - c_2) = \\frac{2 - 3c_2}{6(1-c_2)}(1-c_2) = \\frac{2 - 3c_2}{6}$。\n- 分子是 $\\frac{1}{6} - \\left(\\frac{1}{6c_2(1 - c_2)}\\right)c_2^2 - \\left(\\frac{2-3c_2}{6(1-c_2)}\\right)c_2 = \\frac{1}{6} - \\frac{c_2}{6(1-c_2)} - \\frac{c_2(2-3c_2)}{6(1-c_2)}$。\n合并分子中的各项：\n$$\n\\text{分子} = \\frac{1}{6} \\left(1 - \\frac{c_2}{1-c_2} - \\frac{c_2(2-3c_2)}{1-c_2} \\right) = \\frac{1}{6} \\left( \\frac{1-c_2 - c_2 - 2c_2 + 3c_2^2}{1-c_2} \\right)\n$$\n$$\n\\text{分子} = \\frac{1}{6} \\left( \\frac{3c_2^2 - 4c_2 + 1}{1-c_2} \\right) = \\frac{1}{6} \\frac{(3c_2 - 1)(c_2 - 1)}{1-c_2} = \\frac{1}{6} (-(3c_2 - 1)) = \\frac{1 - 3c_2}{6}\n$$\n于是，我们求得 $a_{32}$：\n$$\na_{32} = \\frac{(1-3c_2)/6}{(2 - 3c_2)/6} = \\frac{1 - 3c_2}{2 - 3c_2}\n$$\n然后从 $a_{31} = 1 - a_{32}$ 求得 $a_{31}$：\n$$\na_{31} = 1 - \\frac{1-3c_2}{2-3c_2} = \\frac{(2-3c_2) - (1-3c_2)}{2-3c_2} = \\frac{1}{2-3c_2}\n$$\n\n**3. 可行性与非负性讨论**\n\n为使该方法适用于浓度必须保持正值的生物医学应用，所有系数 $b_i$ 和 $a_{ij}$ 都最好为非负。我们分析对 $c_2 \\in (0,1)$ 的约束。\n\n- **权重的非负性 ($b_i \\ge 0$)**:\n    - $b_1 = \\frac{3c_2 - 1}{6c_2} \\ge 0 \\implies 3c_2 - 1 \\ge 0 \\implies c_2 \\ge \\frac{1}{3}$。\n    - $b_2 = \\frac{1}{6c_2(1-c_2)} > 0$ 对于所有 $c_2 \\in (0,1)$。\n    - $b_3 = \\frac{2 - 3c_2}{6(1-c_2)} \\ge 0 \\implies 2 - 3c_2 \\ge 0 \\implies c_2 \\le \\frac{2}{3}$。\n    - 为使所有权重都为非负，我们需要 $c_2 \\in [\\frac{1}{3}, \\frac{2}{3}]$。\n\n- **矩阵系数的非负性 ($a_{ij} \\ge 0$)**:\n    - $a_{21} = c_2 > 0$ 对于所有 $c_2 \\in (0,1)$。\n    - $a_{31} = \\frac{1}{2-3c_2} \\ge 0 \\implies 2-3c_2 > 0 \\implies c_2 < \\frac{2}{3}$。因此，$a_{31}$ 可以为非负。\n    - $a_{32} = \\frac{1-3c_2}{2-3c_2} \\ge 0$。这要求分子和分母同号。\n        - 情况 1 (均为正)：$1-3c_2 \\ge 0$ 且 $2-3c_2 > 0 \\implies c_2 \\le \\frac{1}{3}$ 且 $c_2 < \\frac{2}{3}$。这得到 $c_2 \\le \\frac{1}{3}$。\n        - 情况 2 (均为负)：$1-3c_2 \\le 0$ 且 $2-3c_2 < 0 \\implies c_2 \\ge \\frac{1}{3}$ 且 $c_2 > \\frac{2}{3}$。这得到 $c_2 > \\frac{2}{3}$。\n        - 所以，$a_{32} \\ge 0$ 要求 $c_2 \\in (0, 1/3] \\cup (2/3, 1)$。\n\n- **整体非负性**: 为使权重和矩阵系数均为非负，我们必须找到 $c_2$ 的有效区间的交集：$[\\frac{1}{3}, \\frac{2}{3}] \\cap \\{c_2 | c_2 < \\frac{2}{3}\\} \\cap \\{c_2 | c_2 \\in (0, \\frac{1}{3}] \\cup (\\frac{2}{3}, 1)\\}$。这个交集是单点 $c_2 = \\frac{1}{3}$。\n\n**4. 最终上确界计算**\n\n最后一个问题要求的是 $c_2 \\in (0,1)$ 的上确界，使得所有权重 $b_i$ 均为非负，并且该格式是良定义的（即，系数是有限的）。这不要求矩阵系数 $a_{ij}$ 为非负。\n\n根据我们的分析，所有 $i=1,2,3$ 的 $b_i \\ge 0$ 条件将 $c_2$ 限制在区间 $[\\frac{1}{3}, \\frac{2}{3}]$。\n只要其系数表达式中的分母不为零，该格式就是“有限的”或良定义的。系数 $b_i$ 对于 $c_2 \\in (0,1)$ 是良定义的。系数 $a_{31}$ 和 $a_{32}$ 有一个分母 $2-3c_2$，当 $c_2 = \\frac{2}{3}$ 时该分母为零。因此，该格式在 $c_2 = \\frac{2}{3}$ 处没有定义。\n\n所有权重为非负且存在有限格式的 $c_2$ 值的集合，是权重非负区间 $[\\frac{1}{3}, \\frac{2}{3}]$ 与格式有定义的域 $c_2 \\neq \\frac{2}{3}$ 的交集。这得到了集合 $[\\frac{1}{3}, \\frac{2}{3})$。\n\n一个集合的上确界是它的最小上界。对于区间 $[\\frac{1}{3}, \\frac{2}{3})$，上确界是 $\\frac{2}{3}$。",
            "answer": "$$\n\\boxed{\\frac{2}{3}}\n$$"
        },
        {
            "introduction": "在了解了如何构建数值方法之后，下一步是将其付诸实践。本练习模拟了一个常见的代谢网络模型，其中各物质浓度必须保持非负。通过实现并比较一个通用方法（经典的四阶龙格-库塔法）和一个为此特性专门设计的方法（强稳定性保持方法），你将直观地理解数值方法的选择如何深刻影响模拟结果的物理真实性和有效性 ()。",
            "id": "3890900",
            "problem": "一个具有三种代谢物的序贯代谢途径，在质量作用一级动力学下被建模为一个常微分方程 (ODE)。设代谢物浓度为 $x_1(t)$、$x_2(t)$ 和 $x_3(t)$，单位均为毫摩尔 (mM)，速率常数为 $k_1$ 和 $k_2$，单位均为秒的倒数 ($\\text{s}^{-1}$)。该途径为 $x_1 \\rightarrow x_2 \\rightarrow x_3$，形成如下自治系统\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\nx_1 \\\\\nx_2 \\\\\nx_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-k_1 x_1 \\\\\nk_1 x_1 - k_2 x_2 \\\\\nk_2 x_2\n\\end{bmatrix},\n$$\n初始条件为 $x(0) = [x_1(0), x_2(0), x_3(0)]^\\top$，终端时间为 $T > 0$。该系统保持不变量 $I(t) = x_1(t) + x_2(t) + x_3(t)$，因此对于所有 $t \\ge 0$ 都有 $I(t) = I(0)$，并且精确解对所有 $i \\in \\{1,2,3\\}$ 和所有 $t \\ge 0$ 保持正性 $x_i(t) \\ge 0$。\n\n您必须实现两种显式时间积分方法：\n- 一种3阶3级的强稳定性保持龙格-库塔 (SSP RK) 方法（记为 SSPRK$(3,3)$）。\n- 经典的4阶龙格-库塔方法（记为 RK$4$），该方法不是强稳定性保持的。\n\n两种方法都必须在相同的自适应容差控制下运行。使用以下步长加倍局部误差估计器：给定时间 $t$ 的当前状态 $x$，一个建议的步长 $h > 0$，以及一个 $p$ 阶龙格-库塔方法，计算一个步长为 $h$ 的完整步长 $y_h$ 和应用两次步长为 $h/2$ 的两个半步长 $y_{h/2}$。定义局部误差估计为\n$$\ne = \\|y_{h/2} - y_h\\|_{\\infty}.\n$$\n如果 $e \\le \\tau$，则接受该步，其中 $\\tau > 0$ 是给定的容差。接受时，使用更精确的两个半步长的值 $y_{h/2}$ 来推进解。使用对两种方法都相同的控制律来更新步长，\n$$\nh_{\\text{new}} = s \\, h \\left(\\frac{\\tau}{\\max(e, \\epsilon)}\\right)^{\\frac{1}{p+1}},\n$$\n其中 $s$ 是一个安全因子，$\\epsilon$ 是一个小的正数下限，以避免除以零。拒绝时，不推进时间，并使用相同的公式减小 $h$。如有必要，通过截断 $h$ 来确保最后一步正好到达 $T$。不要限制或以其他方式修改负状态；任何负值都必须被记录下来。\n\n将正性保持定义为：对于所有接受的步长端点 $t_n$，最小分量满足 $\\min_i x_i(t_n) \\ge 0$ 的条件，严格绝对阈值为 $\\epsilon_p = 10^{-12}$。当且仅当对于所有的 $n$，$\\min_i x_i(t_n) \\ge -\\epsilon_p$ 时，声明正性得以保持。将不变量误差定义为终端时间处不变量的绝对偏差，\n$$\nE_{\\text{inv}} = \\left| \\left(x_1(T) + x_2(T) + x_3(T)\\right) - \\left(x_1(0) + x_2(0) + x_3(0)\\right) \\right|.\n$$\n\n用相同的自适应容差 $\\tau$、相同的安全因子 $s$ 和相同的 $\\epsilon$ 来实现这两种方法。对两种方法使用相同的初始步长选择策略。对于每个测试用例，程序必须评估并报告两种方法的正性保持布尔值和不变量误差。\n\n使用以下测试套件：\n- 情况1：$k_1 = 1.0$, $k_2 = 0.5$, $x(0) = [1.0, 0.0, 0.0]^\\top$, $T = 10.0$, $\\tau = 10^{-6}$。\n- 情况2：$k_1 = 1.0$, $k_2 = 0.5$, $x(0) = [1.0, 0.0, 0.0]^\\top$, $T = 10.0$, $\\tau = 10^{-3}$。\n- 情况3：$k_1 = 10.0$, $k_2 = 1.0$, $x(0) = [1.0, 0.0, 0.0]^\\top$, $T = 2.0$, $\\tau = 10^{-5}$。\n- 情况4：$k_1 = 0.1$, $k_2 = 0.1$, $x(0) = [1.0, 0.0, 0.0]^\\top$, $T = 100.0$, $\\tau = 10^{-6}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例按以下顺序提供一个子列表\n$$\n[\\text{pos}_{\\text{SSP}}, \\text{pos}_{\\text{RK4}}, E_{\\text{inv,SSP}}, E_{\\text{inv,RK4}}],\n$$\n其中布尔值为 $\\text{pos}_{\\text{SSP}}$ 和 $\\text{pos}_{\\text{RK4}}$，浮点数为 $E_{\\text{inv,SSP}}$ 和 $E_{\\text{inv,RK4}}$。最终输出必须是这四个情况的四元素列表的列表，例如\n$$\n[[\\text{bool},\\text{bool},\\text{float},\\text{float}], [\\text{bool},\\text{bool},\\text{float},\\text{float}], [\\text{bool},\\text{bool},\\text{float},\\text{float}], [\\text{bool},\\text{bool},\\text{float},\\text{float}]].\n$$\n输出中不需要物理单位；仅报告指定的布尔值和浮点数。",
            "solution": "具有一级质量作用动力学的序贯代谢途径是一个线性房室模型，其中状态向量 $x(t) = [x_1(t), x_2(t), x_3(t)]^\\top$ 根据以下方程演化\n$$\n\\frac{d x}{d t} = f(x) =\n\\begin{bmatrix}\n-k_1 x_1 \\\\\nk_1 x_1 - k_2 x_2 \\\\\nk_2 x_2\n\\end{bmatrix},\n$$\n初始条件为 $x(0) = x_0$。此公式基于广为接受的质量作用定律，该定律规定单分子反应 $X \\rightarrow Y$ 以速率 $v = k \\, x$ 进行，其中 $k$ 是速率常数，$x$ 是反应物的浓度。系统矩阵是 Metzler 矩阵（非对角线元素为非负），这意味着正象限对于精确动力学是前向不变的，并且不变量 $I(t) = x_1(t) + x_2(t) + x_3(t)$ 是守恒的，因为净通量是途径内部的，从而得出\n$$\n\\frac{d}{dt} \\left( x_1 + x_2 + x_3 \\right) = -k_1 x_1 + \\left(k_1 x_1 - k_2 x_2\\right) + k_2 x_2 = 0.\n$$\n\n为了数值近似 $x(T)$，我们使用显式龙格-库塔方法。一个 $p$ 阶方法的局部截断误差对于步长 $h$ 满足 $\\mathcal{O}(h^{p+1})$ 的缩放关系。强稳定性保持 (SSP) 龙格-库塔方法 SSPRK$(3,3)$ 的构造方式使得，在保证前向欧拉法稳定性的相同时间步长限制下，它能为特定类别的问题（包括具有 Metzler 矩阵的线性系统）保持某些单调性属性，例如正性。在 Shu-Osher 形式中，SSPRK$(3,3)$ 可以写成前向欧拉步长的凸组合：\n1. $u^{(1)} = u^n + h f(u^n)$,\n2. $u^{(2)} = \\frac{3}{4} u^n + \\frac{1}{4} \\left( u^{(1)} + h f(u^{(1)}) \\right)$,\n3. $u^{n+1} = \\frac{1}{3} u^n + \\frac{2}{3} \\left( u^{(2)} + h f(u^{(2)}) \\right)$.\n每个阶段都是具有非负系数的凸组合，因此如果前向欧拉法在给定的步长界限下保持正性，那么 SSP 方案在该界限下也将保持正性。\n\n经典的4阶龙格-库塔方法 (RK$4$) 由其各阶段定义\n$$\nk_1 = f(u^n), \\quad\nk_2 = f\\left(u^n + \\frac{h}{2} k_1\\right), \\quad\nk_3 = f\\left(u^n + \\frac{h}{2} k_2\\right), \\quad\nk_4 = f\\left(u^n + h k_3\\right),\n$$\n和更新\n$$\nu^{n+1} = u^n + \\frac{h}{6} \\left( k_1 + 2 k_2 + 2 k_3 + k_4 \\right).\n$$\n这种方法不是强稳定性保持的；即使在前向欧拉法不会违反的情况下，它也可能根据步长违反单调性或正性。\n\n为了在两种方法中实施相同的容差控制，我们使用步长加倍来估计局部误差。给定状态 $x$ 处的一个建议步长 $h$，使用该方法的一个步长计算 $y_h$，并使用两个连续的半步长计算 $y_{h/2}$。无穷范数误差估计为 $e = \\|y_{h/2} - y_h\\|_\\infty$。如果 $e \\le \\tau$，则接受该步，并使用 $y_{h/2}$ 推进解，因为它是更精确的近似。步长更新利用了局部误差按 $h^{p+1}$ 缩放的事实：\n$$\nh_{\\text{new}} = s \\, h \\left(\\frac{\\tau}{\\max(e, \\epsilon)}\\right)^{\\frac{1}{p+1}},\n$$\n其中 $s$ 是一个安全因子，用于避免激进的改变，$\\epsilon$ 是一个小的下限，用于处理消失的误差估计。在拒绝时 ($e > \\tau$)，相同的更新公式会减小 $h$，状态和时间不被推进。\n\n通过检查每个接受的步长端点的最小状态分量来评估正性保持。定义 $\\epsilon_p = 10^{-12}$；如果对于所有接受的时间 $t_n$，都有 $\\min_i x_i(t_n) \\ge -\\epsilon_p$，我们则声明正性得以保持。不变量保持通过计算 $E_{\\text{inv}} = |(x_1(T) + x_2(T) + x_3(T)) - (x_1(0) + x_2(0) + x_3(0))|$ 来评估。\n\n算法步骤：\n- 初始化 $t = 0$，$x = x_0$，并将 $h$ 设置为一个合理的初始猜测值（例如，$h = \\min(0.1, T/10)$），安全因子 $s$（例如，$s = 0.9$），以及下限 $\\epsilon$（例如，$\\epsilon = 10^{-16}$）。\n- 当 $t < T$ 时：\n  - 设置 $h = \\min(h, T - t)$ 以确保 $t$ 不会超过 $T$。\n  - 通过一个完整步长计算 $y_h$，通过两个半步长计算 $y_{h/2}$。\n  - 计算 $e = \\|y_{h/2} - y_h\\|_\\infty$。\n  - 如果 $e \\le \\tau$ 或 $h$ 处于数值下限：\n    - 接受：设置 $x \\leftarrow y_{h/2}$，更新运行中的最小值 $\\min_i x_i$，并 $t \\leftarrow t + h$。\n    - 使用指数为 $1/(p+1)$ 的 $h_{\\text{new}}$ 更新 $h$。\n  - 否则：\n    - 拒绝：使用相同的更新公式减小 $h$ 并重复，不推进 $t$ 或 $x$。\n- 到达 $T$ 后，使用保存的最小值计算 $E_{\\text{inv}}$ 和 $\\text{pos}$。\n\n这种设计确保了原则性的、与方法无关的容差控制，同时隔离了 SSP 结构对正性保持和不变量保持的影响。测试套件涵盖了一个典型的途径（$k_1 = 1.0$，$k_2 = 0.5$），在严格（$\\tau = 10^{-6}$）和粗略（$\\tau = 10^{-3}$）容差下；一个更快的上游反应（$k_1 = 10.0$，$k_2 = 1.0$），以探究类刚性行为；以及一个缓慢、长时程的场景（$k_1 = 0.1$，$k_2 = 0.1$，$T = 100.0$），以检验累积不变量误差。输出是布尔值和浮点数，用于量化在相同容差下 SSPRK$(3,3)$ 和 RK$4$ 的正性保持和不变量保持情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f(x, k1, k2):\n    # RHS of the metabolic pathway ODE: x1 -> x2 -> x3\n    dx1 = -k1 * x[0]\n    dx2 = k1 * x[0] - k2 * x[1]\n    dx3 = k2 * x[1]\n    return np.array([dx1, dx2, dx3], dtype=float)\n\ndef ssprk3_step(x, h, k1, k2):\n    # SSPRK(3,3) in Shu-Osher form\n    f1 = f(x, k1, k2)\n    u1 = x + h * f1\n    f2 = f(u1, k1, k2)\n    u2 = (3.0/4.0) * x + (1.0/4.0) * (u1 + h * f2)\n    f3 = f(u2, k1, k2)\n    u3 = (1.0/3.0) * x + (2.0/3.0) * (u2 + h * f3)\n    return u3\n\ndef rk4_step(x, h, k1, k2):\n    # Classical RK4\n    k1v = f(x, k1, k2)\n    k2v = f(x + 0.5 * h * k1v, k1, k2)\n    k3v = f(x + 0.5 * h * k2v, k1, k2)\n    k4v = f(x + h * k3v, k1, k2)\n    return x + (h / 6.0) * (k1v + 2.0 * k2v + 2.0 * k3v + k4v)\n\ndef integrate(method_step, order, x0, T, tau, k1, k2,\n              safety=0.9, eps_floor=1e-16, min_h=1e-16, max_growth=2.0):\n    # Adaptive integration using step-doubling error estimate\n    t = 0.0\n    x = x0.copy()\n    total0 = float(np.sum(x))\n    min_comp = float(np.min(x))\n    # Initial step heuristic\n    h = min(0.1, T / 10.0) if T > 0 else 0.0\n\n    # Guard against T == 0\n    if T == 0.0:\n        inv_err = abs(float(np.sum(x)) - total0)\n        pos_preserved = (min_comp >= -1e-12)\n        return pos_preserved, inv_err\n\n    while t  T:\n        # Prevent overshoot\n        h = min(h, T - t)\n        if h  min_h:\n            # Accept tiny step to avoid stalling\n            y_full = method_step(x, h, k1, k2)\n            y_half = method_step(method_step(x, 0.5 * h, k1, k2), 0.5 * h, k1, k2)\n            x = y_half\n            t += h\n            min_comp = min(min_comp, float(np.min(x)))\n            # Attempt to grow step modestly\n            h = min(max_growth * h, T - t if T - t > 0 else h)\n            continue\n\n        # One full step\n        y_full = method_step(x, h, k1, k2)\n        # Two half steps\n        y_half = method_step(method_step(x, 0.5 * h, k1, k2), 0.5 * h, k1, k2)\n\n        # Infinity-norm error estimate\n        e = float(np.max(np.abs(y_half - y_full)))\n\n        if e = tau or h = min_h:\n            # Accept: advance with the more accurate two-half-step value\n            x = y_half\n            t += h\n            min_comp = min(min_comp, float(np.min(x)))\n            # Update step size\n            exponent = 1.0 / (order + 1)\n            h_candidate = safety * h * (tau / max(e, eps_floor))**exponent\n            # Limit excessive growth\n            h = min(h_candidate, max_growth * h)\n        else:\n            # Reject: reduce h and retry\n            exponent = 1.0 / (order + 1)\n            h = safety * h * (tau / e)**exponent\n            if h  min_h:\n                h = min_h\n\n    inv_err = abs(float(np.sum(x)) - total0)\n    pos_preserved = (min_comp >= -1e-12)\n    return pos_preserved, inv_err\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k1, k2, x0, T, tau)\n        (1.0, 0.5, np.array([1.0, 0.0, 0.0], dtype=float), 10.0, 1e-6),\n        (1.0, 0.5, np.array([1.0, 0.0, 0.0], dtype=float), 10.0, 1e-3),\n        (10.0, 1.0, np.array([1.0, 0.0, 0.0], dtype=float), 2.0, 1e-5),\n        (0.1, 0.1, np.array([1.0, 0.0, 0.0], dtype=float), 100.0, 1e-6),\n    ]\n\n    results = []\n    for k1, k2, x0, T, tau in test_cases:\n        # SSPRK(3,3): order = 3\n        pos_ssp, inv_ssp = integrate(ssprk3_step, 3, x0, T, tau, k1, k2)\n        # RK4: order = 4\n        pos_rk4, inv_rk4 = integrate(rk4_step, 4, x0, T, tau, k1, k2)\n        results.append([pos_ssp, pos_rk4, inv_ssp, inv_rk4])\n\n    # Final print statement in the exact required format.\n    # Produces a single line: list of per-case lists [bool,bool,float,float]\n    print(f\"[{','.join([str(r) for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多生物医学系统（如酶动力学网络）在数学上是“刚性”的，这意味着系统内不同过程的时间尺度差异巨大，这对显式数值方法构成了严峻挑战。本项高级练习将介绍专为解决此类问题而设计的隐式龙格-库塔方法，特别是高阶的“高斯-勒让德”方法。你将实践如何通过牛顿法求解隐式方程，并使用“人造解”方法来严谨地验证其理论收敛阶，从而掌握处理刚性问题的关键技术 ()。",
            "id": "3890916",
            "problem": "实现一个自包含程序，该程序构建并应用一种隐式高斯-勒让德龙格-库塔方法到一个刚性酶反应网络上，该网络采用制造解（强迫）范式，并用它来经验性地验证理论收敛阶。该程序必须是通用的、可复现的，无需用户输入，并且必须按照本问题末尾的规定输出单行结果。\n\n该模型的基础是一个标准的质量作用酶反应网络，描述了由酶催化的底物消耗，其中涉及复合物的形成，其反应过程为：底物与酶可逆地形成复合物，该复合物不可逆地生成产物。设状态向量为 $y(t) = [S(t), E(t), C(t), P(t)]^\\top$，其中 $S$ 是底物，$E$ 是游离酶，$C$ 是复合物，$P$ 是产物。无强迫项时的质量作用动力学为\n$$\n\\begin{aligned}\n\\frac{dS}{dt} = -k_1 S E + k_2 C, \\\\\n\\frac{dE}{dt} = -k_1 S E + (k_2 + k_3) C, \\\\\n\\frac{dC}{dt} = k_1 S E - (k_2 + k_3) C, \\\\\n\\frac{dP}{dt} = k_3 C,\n\\end{aligned}\n$$\n速率常数为 $k_1, k_2, k_3$。为实现精确误差评估，请使用制造解方法：指定一个光滑、刚性且保持不变量的精确解 $y_{\\mathrm{ex}}(t)$，并定义一个随时间变化的强迫项 $r(t)$，使得非自治系统\n$$\n\\frac{dy}{dt} = f(t, y) := f_{\\mathrm{mass}}(y) + r(t)\n$$\n对于给定的初始数据，其精确解为 $y_{\\mathrm{ex}}(t)$。这里，$f_{\\mathrm{mass}}(y)$ 是由上述质量作用动力学定义的右端项。制造解必须始终满足酶守恒和底物总量守恒，即对于常数 $E_{\\mathrm{tot}}$ 和 $S_{\\mathrm{tot}}$，$E(t) + C(t) = E_{\\mathrm{tot}}$ 且 $S(t) + C(t) + P(t) = S_{\\mathrm{tot}}$。制造解定义如下\n$$\n\\begin{aligned}\nC(t) = c_1 e^{-\\alpha t} + c_2 e^{-t}, \\\\\nE(t) = E_{\\mathrm{tot}} - C(t), \\\\\nS(t) = s_0 + s_1 e^{-t} + s_2 e^{-3 t}, \\\\\nP(t) = S_{\\mathrm{tot}} - S(t) - C(t),\n\\end{aligned}\n$$\n其中 $E_{\\mathrm{tot}}$, $S_{\\mathrm{tot}}$, $c_1$, $c_2$, $s_0$, $s_1$, $s_2$ 为常数，刚性参数 $\\alpha  0$。通过恒等式 $r(t) = \\frac{d}{dt} y_{\\mathrm{ex}}(t) - f_{\\mathrm{mass}}(y_{\\mathrm{ex}}(t))$ 构建 $r(t)$，这保证了 $y_{\\mathrm{ex}}(t)$ 是从 $y_{\\mathrm{ex}}(0)$ 出发的方程 $\\frac{dy}{dt} = f(t, y)$ 的精确解。\n\n您必须使用在高斯点上的配置法实现一种高阶隐式高斯-勒让德龙格-库塔方法：\n- 实现两级高斯-勒让德方法（其理论全局阶为 $4$）。\n- 实现三级高斯-勒让德方法（其理论全局阶为 $6$）。\n\n隐式阶段方程必须通过牛顿法求解，该牛顿法使用 $f(t, y)$ 关于 $y$ 的精确雅可比矩阵，即 $f_{\\mathrm{mass}}(y)$ 的雅可比矩阵，因为强迫项 $r(t)$ 与 $y$ 无关。每个时间步都必须组装并求解用于各阶段的块结构牛顿系统。\n\n您的程序应从基本原理出发：\n- 根据上述质量作用定律定义 $f_{\\mathrm{mass}}(y)$。\n- 定义 $y_{\\mathrm{ex}}(t)$，其参数值需确保对所有 $t$ 满足 $E(t) + C(t) = E_{\\mathrm{tot}}$ 和 $S(t) + C(t) + P(t) = S_{\\mathrm{tot}}$。\n- 通过 $r(t) = \\frac{d}{dt} y_{\\mathrm{ex}}(t) - f_{\\mathrm{mass}}(y_{\\mathrm{ex}}(t))$ 推导 $r(t)$。\n- 使用 $f_{\\mathrm{mass}}$ 的精确雅可比矩阵为隐式阶段实现牛顿法。\n- 使用固定步长 $h$ 将数值解从 $t=0$ 推进到 $t=T$。\n\n使用以下为酶网络和制造解设定的科学上合理且自洽的参数，选择这些参数是为了引入刚性并保持不变量：\n- 酶和底物总量：$E_{\\mathrm{tot}} = 1$，$S_{\\mathrm{tot}} = 1$。\n- 动力学速率：$k_1 = 100$，$k_2 = 10$，$k_3 = 1$。\n- 制造解系数：$c_1 = 0.05$，$c_2 = 0.02$，$s_0 = 0.1$，$s_1 = 0.4$，$s_2 = 0.2$。\n\n$f_{\\mathrm{mass}}(y)$ 关于 $y = [S,E,C,P]^\\top$ 的雅可比矩阵为\n$$\nJ(y) =\n\\begin{bmatrix}\n- k_1 E  - k_1 S  k_2  0 \\\\\n- k_1 E  - k_1 S  k_2 + k_3  0 \\\\\nk_1 E  k_1 S  -(k_2 + k_3)  0 \\\\\n0  0  k_3  0\n\\end{bmatrix}.\n$$\n\n您的程序必须通过网格加密来验证理论阶，使用在 $t = T$ 时的精确误差，定义为 $e(h) = \\lVert y_{\\mathrm{num}}(T; h) - y_{\\mathrm{ex}}(T) \\rVert_2$。对于每种方法，通过以下公式计算观测阶\n$$\np(h_1 \\to h_2) = \\frac{\\log\\left( \\frac{e(h_1)}{e(h_2)} \\right)}{\\log(2)},\n$$\n其中 $h_2 = h_1 / 2$ 为连续的步长减半。\n\n测试套件与答案规范：\n- 情况1（正常路径，中等刚性）：两级高斯-勒让德方法，最终时间 $T = 1$，刚性参数 $\\alpha = 50$，步长 $h \\in \\{0.2, 0.1, 0.05\\}$。报告两个浮点数：$p(0.2 \\to 0.1)$ 和 $p(0.1 \\to 0.05)$。\n- 情况2（高阶覆盖）：三级高斯-勒让德方法，最终时间 $T = 1$，刚性参数 $\\alpha = 50$，步长 $h \\in \\{0.1, 0.05, 0.025\\}$。报告两个浮点数：$p(0.1 \\to 0.05)$ 和 $p(0.05 \\to 0.025)$。\n- 情况3（边界情况，更极端刚性）：两级高斯-勒让德方法，最终时间 $T = 0.2$，刚性参数 $\\alpha = 200$，步长 $h \\in \\{0.05, 0.025, 0.0125\\}$。报告两个浮点数：$p(0.05 \\to 0.025)$ 和 $p(0.025 \\to 0.0125)$。\n\n所有初始条件必须设置为 $t=0$ 时的制造精确解：\n$$\ny(0) = y_{\\mathrm{ex}}(0).\n$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按如下顺序排列：\n$$\n[\\;p_{1,1},\\;p_{1,2},\\;p_{2,1},\\;p_{2,2},\\;p_{3,1},\\;p_{3,2}\\;],\n$$\n其中 $p_{i,j}$ 表示上述定义的案例 $i$ 和配对 $j$ 的观测阶。例如，输出应类似于 $[x_1,x_2,x_3,x_4,x_5,x_6]$，其中每个 $x_k$ 是一个浮点数。不得打印任何其他文本。",
            "solution": "用户要求为刚性酶动力学模型实现并验证隐式高斯-勒让德龙格-库塔方法。验证将使用制造解方法进行，以便能够进行精确误差计算和收敛阶的经验性分析。\n\n### 步骤1：问题公式化与数学框架\n\n该问题围绕形式为 $\\frac{dy}{dt} = f(t, y)$ 的非自治常微分方程（ODE）系统的数值求解展开。状态向量为 $y(t) = [S(t), E(t), C(t), P(t)]^\\top$，分别代表底物、酶、复合物和产物的浓度。\n\n右端函数 $f(t, y)$ 由两部分组成：来自质量作用动力学的项 $f_{\\mathrm{mass}}(y)$，以及通过制造解方法引入的随时间变化的强迫项 $r(t)$。\n$$\n\\frac{dy}{dt} = f(t, y) = f_{\\mathrm{mass}}(y) + r(t)\n$$\n质量作用动力学由以下公式给出：\n$$\nf_{\\mathrm{mass}}(y) = \\begin{bmatrix}\n-k_1 S E + k_2 C \\\\\n-k_1 S E + (k_2 + k_3) C \\\\\nk_1 S E - (k_2 + k_3) C \\\\\nk_3 C\n\\end{bmatrix}\n$$\n指定制造解 $y_{\\mathrm{ex}}(t)$ 以满足特定的守恒定律：$E(t) + C(t) = E_{\\mathrm{tot}}$ 和 $S(t) + C(t) + P(t) = S_{\\mathrm{tot}}$。然后定义强迫项 $r(t)$，使得 $y_{\\mathrm{ex}}(t)$ 成为该ODE系统的精确解：\n$$\nr(t) = \\frac{d y_{\\mathrm{ex}}(t)}{dt} - f_{\\mathrm{mass}}(y_{\\mathrm{ex}}(t))\n$$\n我们需要计算 $y_{\\mathrm{ex}}(t)$ 及其导数 $\\frac{d y_{\\mathrm{ex}}(t)}{dt}$ 来构建完整的ODE系统。\n\n牛顿法求解器需要ODE右端项的雅可比矩阵 $J(t, y) = \\frac{\\partial f(t, y)}{\\partial y}$。由于强迫项 $r(t)$ 与 $y$ 无关，雅可比矩阵就是质量作用项的雅可比矩阵，即 $J(t, y) = J_{\\mathrm{mass}}(y)$。问题提供了这个雅可比矩阵：\n$$\nJ_{\\mathrm{mass}}(y) =\n\\begin{bmatrix}\n- k_1 E  - k_1 S  k_2  0 \\\\\n- k_1 E  - k_1 S  k_2 + k_3  0 \\\\\nk_1 E  k_1 S  -(k_2 + k_3)  0 \\\\\n0  0  k_3  0\n\\end{bmatrix}\n$$\n\n### 步骤2：隐式龙格-库塔方法（高斯-勒让德）\n\n一个 $s$ 级隐式龙格-库塔（IRK）方法使用以下公式将解从时间 $t_n$ 的 $y_n$ 推进到时间 $t_{n+1} = t_n + h$ 的 $y_{n+1}$：\n$$\ny_{n+1} = y_n + h \\sum_{i=1}^s b_i k_i\n$$\n阶段导数 $k_i$ 是一个耦合的、通常为非线性的方程组的解：\n$$\nk_i = f\\left(t_n + c_i h, y_n + h \\sum_{j=1}^s a_{ij} k_j\\right), \\quad i = 1, \\dots, s\n$$\n求解阶段值 $Y_i = y_n + h \\sum_{j=1}^s a_{ij} k_j$ 更为方便。阶段值的方程组为：\n$$\nY_i = y_n + h \\sum_{j=1}^s a_{ij} f(t_n + c_j h, Y_j), \\quad i = 1, \\dots, s\n$$\n这是一个关于未知数 $Y_1, \\dots, Y_s$ 的 $s \\times d$ 非线性方程组，其中 $d=4$ 是 $y$ 的维数。我们使用牛顿法求解该系统。\n\n#### 求解阶段值的牛顿法\n设 $\\mathbf{Y} = [Y_1^\\top, \\ldots, Y_s^\\top]^\\top$ 是所有阶段值的串联向量。我们求解函数 $\\mathbf{G}(\\mathbf{Y}) = 0$ 的根，其中：\n$$\nG_i(\\mathbf{Y}) = Y_i - y_n - h \\sum_{j=1}^s a_{ij} f(t_n + c_j h, Y_j)\n$$\n牛顿迭代为 $\\mathbf{Y}^{(k+1)} = \\mathbf{Y}^{(k)} + \\Delta\\mathbf{Y}^{(k)}$，其中更新量 $\\Delta\\mathbf{Y}^{(k)}$ 是以下线性系统的解：\n$$\n\\mathcal{J}_G(\\mathbf{Y}^{(k)}) \\Delta\\mathbf{Y}^{(k)} = -\\mathbf{G}(\\mathbf{Y}^{(k)})\n$$\n$\\mathbf{G}$ 的雅可比矩阵，记为 $\\mathcal{J}_G$，是一个大小为 $(s \\cdot d) \\times (s \\cdot d)$ 的块矩阵。位置 $(i,j)$ 处的块是 $\\frac{\\partial G_i}{\\partial Y_j} = \\delta_{ij}I_d - h a_{ij} J(t_n+c_j h, Y_j)$，其中 $I_d$ 是 $d \\times d$ 的单位矩阵，$\\delta_{ij}$ 是克罗内克δ函数。\n\n所需的高斯-勒让德方法的布卓表 $(A, b, c)$ 如下：\n\n1.  **两级高斯-勒让德方法（4阶）**：\n    -   $s=2$, $c_1 = \\frac{1}{2} - \\frac{\\sqrt{3}}{6}$, $c_2 = \\frac{1}{2} + \\frac{\\sqrt{3}}{6}$\n    -   $b = [1/2, 1/2]^\\top$\n    -   $A = \\begin{pmatrix} 1/4  1/4 - \\sqrt{3}/6 \\\\ 1/4 + \\sqrt{3}/6  1/4 \\end{pmatrix}$\n\n2.  **三级高斯-勒让德方法（6阶）**：\n    -   $s=3$, $c_1 = \\frac{1}{2} - \\frac{\\sqrt{15}}{10}$, $c_2 = \\frac{1}{2}$, $c_3 = \\frac{1}{2} + \\frac{\\sqrt{15}}{10}$\n    -   $b = [5/18, 8/18, 5/18]^\\top$\n    -   $A = \\begin{pmatrix}\n        5/36  2/9 - \\sqrt{15}/15  5/36 - \\sqrt{15}/30 \\\\\n        5/36 + \\sqrt{15}/24  2/9  5/36 - \\sqrt{15}/24 \\\\\n        5/36 + \\sqrt{15}/30  2/9 + \\sqrt{15}/15  5/36\n        \\end{pmatrix}$\n\n### 步骤3：经验阶验证\n\n程序将按照三个测试用例的规定执行模拟。对于每个用例，它将使用一系列递减的步长 $h$ 对ODE系统从 $t=0$ 积分到 $t=T$。将最终时间的数值解 $y_{\\mathrm{num}}(T; h)$ 与精确解 $y_{\\mathrm{ex}}(T)$ 进行比较，以计算误差 $e(h) = \\lVert y_{\\mathrm{num}}(T; h) - y_{\\mathrm{ex}}(T) \\rVert_2$。\n然后，对于连续的步长加密 $h_2 = h_1 / 2$，计算观测到的收敛阶 $p$：\n$$\np(h_1 \\to h_2) = \\frac{\\log(e(h_1)/e(h_2))}{\\log(2)}\n$$\n所有测试用例的结果将被汇总到一个列表中作为最终输出。该实现将遵循上述详细逻辑，将物理模型和数值求解器封装到独立的、定义明确的组件中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and applies implicit Gauss-Legendre Runge-Kutta methods to\n    a stiff enzyme reaction network, and verifies the theoretical convergence order.\n    \"\"\"\n\n    # --- Butcher Tableaus for Gauss-Legendre Methods ---\n    s3 = np.sqrt(3)\n    s15 = np.sqrt(15)\n\n    TABLEAUS = {\n        'GL4': {  # 2-stage, order 4\n            'A': np.array([\n                [1/4, 1/4 - s3/6],\n                [1/4 + s3/6, 1/4]\n            ]),\n            'b': np.array([1/2, 1/2]),\n            'c': np.array([1/2 - s3/6, 1/2 + s3/6])\n        },\n        'GL6': {  # 3-stage, order 6\n            'A': np.array([\n                [5/36, 2/9 - s15/15, 5/36 - s15/30],\n                [5/36 + s15/24, 2/9, 5/36 - s15/24],\n                [5/36 + s15/30, 2/9 + s15/15, 5/36]\n            ]),\n            'b': np.array([5/18, 8/18, 5/18]),\n            'c': np.array([1/2 - s15/10, 1/2, 1/2 + s15/10])\n        }\n    }\n\n    class EnzymeModel:\n        \"\"\"\n        Represents the enzyme kinetics model with a manufactured solution.\n        y = [S, E, C, P]\n        \"\"\"\n        def __init__(self, alpha):\n            self.k1, self.k2, self.k3 = 100.0, 10.0, 1.0\n            self.Etot, self.Stot = 1.0, 1.0\n            self.c1, self.c2 = 0.05, 0.02\n            self.s0, self.s1, self.s2 = 0.1, 0.4, 0.2\n            self.alpha = float(alpha)\n            self.dim = 4\n\n        def f_mass(self, y):\n            S, E, C, _ = y\n            r1 = self.k1 * S * E\n            r2 = self.k2 * C\n            r3 = self.k3 * C\n            return np.array([\n                -r1 + r2,\n                -r1 + r2 + r3,\n                 r1 - r2 - r3,\n                 r3\n            ])\n\n        def J_mass(self, y):\n            S, E, _, _ = y\n            J = np.zeros((self.dim, self.dim))\n            J[0, 0] = -self.k1 * E\n            J[0, 1] = -self.k1 * S\n            J[0, 2] = self.k2\n            J[1, 0] = -self.k1 * E\n            J[1, 1] = -self.k1 * S\n            J[1, 2] = self.k2 + self.k3\n            J[2, 0] = self.k1 * E\n            J[2, 1] = self.k1 * S\n            J[2, 2] = -(self.k2 + self.k3)\n            J[3, 2] = self.k3\n            return J\n\n        def y_ex(self, t):\n            exp_a = np.exp(-self.alpha * t)\n            exp_1 = np.exp(-t)\n            exp_3 = np.exp(-3.0 * t)\n            C = self.c1 * exp_a + self.c2 * exp_1\n            E = self.Etot - C\n            S = self.s0 + self.s1 * exp_1 + self.s2 * exp_3\n            P = self.Stot - S - C\n            return np.array([S, E, C, P])\n\n        def y_ex_dot(self, t):\n            exp_a = np.exp(-self.alpha * t)\n            exp_1 = np.exp(-t)\n            exp_3 = np.exp(-3.0 * t)\n            C_dot = -self.alpha * self.c1 * exp_a - self.c2 * exp_1\n            E_dot = -C_dot\n            S_dot = -self.s1 * exp_1 - 3.0 * self.s2 * exp_3\n            P_dot = -S_dot - C_dot\n            return np.array([S_dot, E_dot, C_dot, P_dot])\n        \n        def r(self, t):\n            return self.y_ex_dot(t) - self.f_mass(self.y_ex(t))\n\n        def f(self, t, y):\n            return self.f_mass(y) + self.r(t)\n        \n        def J(self, t, y):\n            return self.J_mass(y)\n\n    class IRKSolver:\n        \"\"\"\n        An implicit Runge-Kutta solver using Newton's method for stage equations.\n        \"\"\"\n        def __init__(self, model, tableau, newton_tol=1e-12, max_newton_iter=10):\n            self.model = model\n            self.A = tableau['A']\n            self.b = tableau['b']\n            self.c = tableau['c']\n            self.s = len(self.b)\n            self.dim = model.dim\n            self.tol = newton_tol\n            self.max_iter = max_newton_iter\n\n        def step(self, y_n, t_n, h):\n            # Initial guess for stage values Y_i is y_n for all i\n            Y = np.tile(y_n, (self.s, 1))\n\n            # Newton's method for stage values\n            for _ in range(self.max_iter):\n                # Form residual G and Jacobian J_G\n                f_vals = np.array([self.model.f(t_n + self.c[i] * h, Y[i, :]) for i in range(self.s)])\n                G = Y - np.tile(y_n, (self.s, 1)) - h * (self.A @ f_vals)\n                \n                J_vals = [self.model.J(t_n + self.c[i] * h, Y[i, :]) for i in range(self.s)]\n                J_G = np.zeros((self.s * self.dim, self.s * self.dim))\n\n                for i in range(self.s):\n                    for j in range(self.s):\n                        block = -h * self.A[i, j] * J_vals[j]\n                        if i == j:\n                            block += np.identity(self.dim)\n                        J_G[i*self.dim:(i+1)*self.dim, j*self.dim:(j+1)*self.dim] = block\n\n                # Solve linear system and update\n                delta_Y_flat = np.linalg.solve(J_G, -G.flatten())\n                Y += delta_Y_flat.reshape((self.s, self.dim))\n\n                if np.linalg.norm(delta_Y_flat)  self.tol:\n                    break\n            \n            # Compute final solution y_{n+1}\n            f_vals = np.array([self.model.f(t_n + self.c[i] * h, Y[i, :]) for i in range(self.s)])\n            y_np1 = y_n + h * (self.b @ f_vals)\n            return y_np1\n\n    def run_simulation(solver, model, T, h):\n        num_steps = int(round(T / h))\n        y = model.y_ex(0.0)\n        t = 0.0\n        for _ in range(num_steps):\n            y = solver.step(y, t, h)\n            t += h\n        return y\n    \n    test_cases = [\n        {'id': 1, 'method': 'GL4', 'T': 1.0, 'alpha': 50, 'hs': [0.2, 0.1, 0.05]},\n        {'id': 2, 'method': 'GL6', 'T': 1.0, 'alpha': 50, 'hs': [0.1, 0.05, 0.025]},\n        {'id': 3, 'method': 'GL4', 'T': 0.2, 'alpha': 200, 'hs': [0.05, 0.025, 0.0125]}\n    ]\n\n    all_orders = []\n    for case in test_cases:\n        model = EnzymeModel(alpha=case['alpha'])\n        tableau = TABLEAUS[case['method']]\n        solver = IRKSolver(model, tableau)\n        \n        errors = []\n        for h in case['hs']:\n            y_final_num = run_simulation(solver, model, case['T'], h)\n            y_final_ex = model.y_ex(case['T'])\n            error = np.linalg.norm(y_final_num - y_final_ex)\n            errors.append(error)\n        \n        order1 = np.log(errors[0] / errors[1]) / np.log(2.0)\n        order2 = np.log(errors[1] / errors[2]) / np.log(2.0)\n        all_orders.extend([order1, order2])\n\n    print(f\"[{','.join(map(str, all_orders))}]\")\n\nsolve()\n\n```"
        }
    ]
}