{
    "hands_on_practices": [
        {
            "introduction": "The Leaky Integrate-and-Fire (LIF) model is a cornerstone of computational neuroscience, providing a simplified yet powerful representation of neuronal dynamics. This model exemplifies a deterministic hybrid system where a continuous process, the integration of the membrane potential, is governed by an Ordinary Differential Equation (ODE). This practice provides fundamental experience in analyzing such systems by deriving an emergent property—the firing rate—from the interplay between the continuous flow and the discrete spike-and-reset event that occurs when the potential reaches a threshold .",
            "id": "3892038",
            "problem": "Consider a hybrid leaky integrate-and-fire neuron model that combines continuous subthreshold membrane dynamics with discrete spike-and-reset events and a fixed dwell-time representing absolute refractoriness. The continuous subthreshold dynamics are modeled using the resistor-capacitor (RC) membrane equation, which, in the absence of synaptic noise and under a constant input current, can be written as an Ordinary Differential Equation (ODE): $$\\tau_{m}\\,\\frac{dV}{dt} = -\\big(V - V_{\\mathrm{rest}}\\big) + R_{m}\\,I,$$ where $V$ is the membrane potential, $V_{\\mathrm{rest}}$ is the resting potential, $\\tau_{m}$ is the membrane time constant, $R_{m}$ is the membrane resistance, and $I$ is the constant input current. When the continuous trajectory reaches the spike threshold $V_{\\mathrm{th}}$, a discrete event is triggered: the membrane potential is instantaneously reset according to $V \\leftarrow V_{\\mathrm{reset}}$, and the system enters an absolute refractory dwell-state for a fixed time $\\tau_{\\mathrm{ref}}$, during which no evolution occurs in the continuous state and no spikes can be generated.\n\nAssume constant input and parameters chosen so that tonic spiking occurs, i.e., $V_{\\infty} \\equiv V_{\\mathrm{rest}} + R_{m} I > V_{\\mathrm{th}}$. Starting from the fundamental RC law and the hybrid event/reset mechanism described above, derive the steady firing rate by computing the mean inter-spike interval as the sum of the threshold-crossing time from $V_{\\mathrm{reset}}$ to $V_{\\mathrm{th}}$ and the refractory dwell-time $\\tau_{\\mathrm{ref}}$. Use the following parameter values: $$\\tau_{m} = 20\\,\\mathrm{ms},\\quad R_{m} = 100\\,\\mathrm{M}\\Omega,\\quad I = 0.5\\,\\mathrm{nA},\\quad V_{\\mathrm{rest}} = -65\\,\\mathrm{mV},\\quad V_{\\mathrm{reset}} = -65\\,\\mathrm{mV},\\quad V_{\\mathrm{th}} = -50\\,\\mathrm{mV},\\quad \\tau_{\\mathrm{ref}} = 2\\,\\mathrm{ms}.$$ Express the final firing rate in $\\mathrm{Hz}$ and round your answer to four significant figures.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the established principles of computational neuroscience, specifically the leaky integrate-and-fire (LIF) model. It is mathematically well-posed, providing a clear ordinary differential equation (ODE), a discrete reset mechanism, and a complete set of parameters. The condition for tonic spiking, $V_{\\infty} > V_{\\mathrm{th}}$, is satisfied by the given parameters, ensuring a meaningful solution exists. The problem is objective and contains no ambiguities.\n\nThe task is to derive the steady-state firing rate, $f$, of a hybrid leaky integrate-and-fire neuron. The firing rate is the reciprocal of the mean inter-spike interval, $ISI$, so $f = 1/ISI$. The problem defines the $ISI$ as the sum of two periods: the time it takes for the membrane potential to rise from the reset value to the threshold, which we will call $t_{\\mathrm{reach}}$, and the absolute refractory period, $\\tau_{\\mathrm{ref}}$.\n$$ISI = t_{\\mathrm{reach}} + \\tau_{\\mathrm{ref}}$$\n\nFirst, we must solve for $t_{\\mathrm{reach}}$. This is the duration of the continuous evolution of the membrane potential, $V$, governed by the provided ODE:\n$$\\tau_{m}\\,\\frac{dV}{dt} = -\\big(V - V_{\\mathrm{rest}}\\big) + R_{m}\\,I$$\nTo solve this first-order linear ODE, we rearrange it into a standard form. Let's define the steady-state voltage, $V_{\\infty}$, as the value $V$ would approach if there were no threshold:\n$$V_{\\infty} \\equiv V_{\\mathrm{rest}} + R_{m}\\,I$$\nSubstituting this definition into the ODE gives:\n$$\\tau_{m}\\,\\frac{dV}{dt} = -(V - V_{\\infty})$$\nThis equation can be solved by separation of variables:\n$$\\frac{dV}{V - V_{\\infty}} = -\\frac{dt}{\\tau_{m}}$$\nIntegrating both sides from the start of the integration period (time $t=0$, voltage $V(0) = V_{\\mathrm{reset}}$) to a later time $t$ (voltage $V(t)$) yields:\n$$\\int_{V_{\\mathrm{reset}}}^{V(t)} \\frac{dV'}{V' - V_{\\infty}} = \\int_{0}^{t} -\\frac{dt'}{\\tau_{m}}$$\n$$\\left[ \\ln|V' - V_{\\infty}| \\right]_{V_{\\mathrm{reset}}}^{V(t)} = -\\frac{t}{\\tau_{m}}$$\n$$\\ln|V(t) - V_{\\infty}| - \\ln|V_{\\mathrm{reset}} - V_{\\infty}| = -\\frac{t}{\\tau_{m}}$$\n$$\\ln\\left( \\frac{|V(t) - V_{\\infty}|}{|V_{\\mathrm{reset}} - V_{\\infty}|} \\right) = -\\frac{t}{\\tau_{m}}$$\nGiven the condition $V_{\\mathrm{rest}} + R_{m}\\,I > V_{\\mathrm{th}}$ and starting from $V_{\\mathrm{reset}} \\le V_{\\mathrm{th}}$, the voltage $V(t)$ will always be less than $V_{\\infty}$ as it evolves towards the threshold. Thus, the terms inside the absolute value signs, $V(t) - V_{\\infty}$ and $V_{\\mathrm{reset}} - V_{\\infty}$, are both negative. We can therefore write:\n$$\\ln\\left( \\frac{V_{\\infty} - V(t)}{V_{\\infty} - V_{\\mathrm{reset}}} \\right) = -\\frac{t}{\\tau_{m}}$$\nExponentiating both sides and rearranging gives the solution for $V(t)$:\n$$\\frac{V_{\\infty} - V(t)}{V_{\\infty} - V_{\\mathrm{reset}}} = \\exp\\left(-\\frac{t}{\\tau_{m}}\\right)$$\n$$V_{\\infty} - V(t) = (V_{\\infty} - V_{\\mathrm{reset}}) \\exp\\left(-\\frac{t}{\\tau_{m}}\\right)$$\n$$V(t) = V_{\\infty} - (V_{\\infty} - V_{\\mathrm{reset}}) \\exp\\left(-\\frac{t}{\\tau_{m}}\\right)$$\nThis is equivalent to the more common form $V(t) = V_{\\infty} + (V_{\\mathrm{reset}} - V_{\\infty}) \\exp(-t/\\tau_m)$.\n\nNow we solve for $t_{\\mathrm{reach}}$, which is the time $t$ when $V(t) = V_{\\mathrm{th}}$.\n$$V_{\\mathrm{th}} = V_{\\infty} + (V_{\\mathrm{reset}} - V_{\\infty}) \\exp\\left(-\\frac{t_{\\mathrm{reach}}}{\\tau_{m}}\\right)$$\n$$V_{\\mathrm{th}} - V_{\\infty} = (V_{\\mathrm{reset}} - V_{\\infty}) \\exp\\left(-\\frac{t_{\\mathrm{reach}}}{\\tau_{m}}\\right)$$\n$$\\exp\\left(-\\frac{t_{\\mathrm{reach}}}{\\tau_{m}}\\right) = \\frac{V_{\\mathrm{th}} - V_{\\infty}}{V_{\\mathrm{reset}} - V_{\\infty}}$$\nTaking the natural logarithm of both sides:\n$$-\\frac{t_{\\mathrm{reach}}}{\\tau_{m}} = \\ln\\left(\\frac{V_{\\mathrm{th}} - V_{\\infty}}{V_{\\mathrm{reset}} - V_{\\infty}}\\right)$$\n$$t_{\\mathrm{reach}} = -\\tau_{m} \\ln\\left(\\frac{V_{\\mathrm{th}} - V_{\\infty}}{V_{\\mathrm{reset}} - V_{\\infty}}\\right)$$\nUsing the logarithmic identity $-\\ln(a/b) = \\ln(b/a)$, we can write this in a form where the argument of the logarithm is greater than $1$, ensuring a positive time:\n$$t_{\\mathrm{reach}} = \\tau_{m} \\ln\\left(\\frac{V_{\\mathrm{reset}} - V_{\\infty}}{V_{\\mathrm{th}} - V_{\\infty}}\\right)$$\n\nNow we substitute the provided parameter values. It is critical to maintain consistent units (e.g., Volts, Amperes, Ohms, Seconds).\n$\\tau_{m} = 20\\,\\mathrm{ms} = 20 \\times 10^{-3}\\,\\mathrm{s}$\n$R_{m} = 100\\,\\mathrm{M}\\Omega = 100 \\times 10^{6}\\,\\Omega$\n$I = 0.5\\,\\mathrm{nA} = 0.5 \\times 10^{-9}\\,\\mathrm{A}$\n$V_{\\mathrm{rest}} = -65\\,\\mathrm{mV} = -0.065\\,\\mathrm{V}$\n$V_{\\mathrm{reset}} = -65\\,\\mathrm{mV} = -0.065\\,\\mathrm{V}$\n$V_{\\mathrm{th}} = -50\\,\\mathrm{mV} = -0.050\\,\\mathrm{V}$\n$\\tau_{\\mathrm{ref}} = 2\\,\\mathrm{ms} = 2 \\times 10^{-3}\\,\\mathrm{s}$\n\nFirst, we calculate $V_{\\infty}$:\n$$R_{m}\\,I = (100 \\times 10^{6}\\,\\Omega) \\times (0.5 \\times 10^{-9}\\,\\mathrm{A}) = 50 \\times 10^{-3}\\,\\mathrm{V} = 50\\,\\mathrm{mV}$$\n$$V_{\\infty} = V_{\\mathrm{rest}} + R_{m}\\,I = -65\\,\\mathrm{mV} + 50\\,\\mathrm{mV} = -15\\,\\mathrm{mV}$$\n\nNext, we calculate $t_{\\mathrm{reach}}$:\n$$t_{\\mathrm{reach}} = (20\\,\\mathrm{ms}) \\times \\ln\\left(\\frac{V_{\\mathrm{reset}} - V_{\\infty}}{V_{\\mathrm{th}} - V_{\\infty}}\\right)$$\n$$t_{\\mathrm{reach}} = (20\\,\\mathrm{ms}) \\times \\ln\\left(\\frac{-65\\,\\mathrm{mV} - (-15\\,\\mathrm{mV})}{-50\\,\\mathrm{mV} - (-15\\,\\mathrm{mV})}\\right)$$\n$$t_{\\mathrm{reach}} = (20\\,\\mathrm{ms}) \\times \\ln\\left(\\frac{-50}{-35}\\right) = (20\\,\\mathrm{ms}) \\times \\ln\\left(\\frac{10}{7}\\right)$$\n$$t_{\\mathrm{reach}} \\approx (20\\,\\mathrm{ms}) \\times 0.356675 \\approx 7.1335\\,\\mathrm{ms}$$\n\nNow, we compute the total inter-spike interval, $ISI$:\n$$ISI = t_{\\mathrm{reach}} + \\tau_{\\mathrm{ref}} \\approx 7.1335\\,\\mathrm{ms} + 2\\,\\mathrm{ms} = 9.1335\\,\\mathrm{ms}$$\nIn seconds, $ISI \\approx 9.1335 \\times 10^{-3}\\,\\mathrm{s}$.\n\nFinally, we calculate the firing rate, $f$, in Hertz ($\\mathrm{Hz}$), which is $s^{-1}$:\n$$f = \\frac{1}{ISI} \\approx \\frac{1}{9.1335 \\times 10^{-3}\\,\\mathrm{s}} \\approx 109.486\\,\\mathrm{Hz}$$\n\nRounding to four significant figures as requested, we get:\n$$f \\approx 109.5\\,\\mathrm{Hz}$$\nThe final analytical expression for the firing rate is:\n$$f = \\left[ \\tau_{\\mathrm{ref}} + \\tau_{m} \\ln\\left(\\frac{V_{\\mathrm{reset}} - V_{\\mathrm{rest}} - R_m I}{V_{\\mathrm{th}} - V_{\\mathrm{rest}} - R_m I}\\right) \\right]^{-1}$$",
            "answer": "$$\\boxed{109.5}$$"
        },
        {
            "introduction": "Understanding the inherent randomness, or \"noise,\" in gene expression is critical for explaining cellular variability and function. This exercise introduces the Linear Noise Approximation (LNA), a powerful method for analyzing fluctuations in stochastic biochemical networks by linking microscopic random events to macroscopic statistical properties. By deriving the stationary protein variance for a two-stage gene expression model, you will practice using the algebraic Lyapunov equation, a key tool for characterizing noise in systems that blend stochastic and deterministic descriptions .",
            "id": "3892040",
            "problem": "Consider a hybrid dynamical model of gene expression in a single cell where discrete promoter switching is fast relative to transcription and translation, and molecular copy-number fluctuations are modeled by a continuous stochastic approximation. The promoter switches between an active state and an inactive state with constant rates $\\alpha$ (inactive to active) and $\\beta$ (active to inactive). Under a separation-of-timescales assumption, the fraction of time the promoter is active is approximated by its steady-state mean $s^* = \\alpha/(\\alpha+\\beta)$, and the continuous dynamics of the mean molecular counts for messenger ribonucleic acid (mRNA) and protein, denoted by $m$ and $p$, follow a deterministic drift given by\n$$\n\\frac{dm}{dt} = k_{m} s^* - \\gamma_{m} m, \n\\qquad\n\\frac{dp}{dt} = k_{p} m - \\gamma_{p} p,\n$$\nwhere $k_{m}$ is the transcription rate (conditional on promoter being active), $\\gamma_{m}$ is the mRNA degradation rate, $k_{p}$ is the translation rate, and $\\gamma_{p}$ is the protein degradation rate. The underlying discrete reaction events are\n- Transcription: $\\varnothing \\rightarrow m$ with propensity $a_{1}(x) = k_{m} s^*$,\n- mRNA degradation: $m \\rightarrow \\varnothing$ with propensity $a_{2}(x) = \\gamma_{m} m$,\n- Translation: $m \\rightarrow m + p$ with propensity $a_{3}(x) = k_{p} m$,\n- Protein degradation: $p \\rightarrow \\varnothing$ with propensity $a_{4}(x) = \\gamma_{p} p$,\nwhere $x = (m,p)^{\\top}$.\n\nAssume the Linear Noise Approximation (LNA) is valid and the fluctuations around the unique stable equilibrium are well approximated by a Gaussian Ornstein–Uhlenbeck process for $(m,p)$. Let $x^{\\ast} = (m^{\\ast},p^{\\ast})^{\\top}$ denote the equilibrium. Using first principles from the stochastic formulation of reaction networks, derive the stationary variance of protein fluctuations $\\sigma_{pp}$ (the $(2,2)$-entry of the stationary covariance matrix of $(m,p)$) as a closed-form analytic expression in terms of the parameters $\\alpha$, $\\beta$, $k_{m}$, $k_{p}$, $\\gamma_{m}$, and $\\gamma_{p}$.\n\nExpress your final answer as a symbolic expression. Do not provide numerical evaluation and do not attach units.",
            "solution": "The user wants to find the stationary variance of protein fluctuations, $\\sigma_{pp}$, for a given hybrid model of gene expression, using the Linear Noise Approximation (LNA).\n\n### Step 1: Extract Givens\n- **State variables**: $m$ (mRNA count), $p$ (protein count). State vector $x = (m, p)^{\\top}$.\n- **Parameters**:\n  - Promoter switching rates: $\\alpha$ (inactive to active), $\\beta$ (active to inactive).\n  - Transcription rate (active promoter): $k_m$.\n  - mRNA degradation rate: $\\gamma_m$.\n  - Translation rate: $k_p$.\n  - Protein degradation rate: $\\gamma_p$.\n- **Derived quantity**: Steady-state fraction of active promoter time: $s^* = \\frac{\\alpha}{\\alpha+\\beta}$.\n- **Deterministic dynamics**:\n  $$ \\frac{dm}{dt} = k_{m} s^* - \\gamma_{m} m $$\n  $$ \\frac{dp}{dt} = k_{p} m - \\gamma_{p} p $$\n- **Stochastic reaction scheme**: Let $x=(m,p)$.\n  - R1: $\\varnothing \\rightarrow m$, propensity $a_{1}(x) = k_{m} s^*$, stoichiometric vector $v_1 = (1, 0)^{\\top}$.\n  - R2: $m \\rightarrow \\varnothing$, propensity $a_{2}(x) = \\gamma_{m} m$, stoichiometric vector $v_2 = (-1, 0)^{\\top}$.\n  - R3: $m \\rightarrow m + p$, propensity $a_{3}(x) = k_{p} m$, stoichiometric vector $v_3 = (0, 1)^{\\top}$.\n  - R4: $p \\rightarrow \\varnothing$, propensity $a_{4}(x) = \\gamma_{p} p$, stoichiometric vector $v_4 = (0, -1)^{\\top}$.\n- **Objective**: Derive the stationary variance $\\sigma_{pp}$, the $(2,2)$-entry of the stationary covariance matrix of $(m,p)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is a standard application of the Linear Noise Approximation (LNA) to a well-established two-stage model of gene expression.\n- **Scientifically Grounded**: The model is a cornerstone of stochastic gene expression theory. The LNA is a rigorous and widely accepted method derived from the chemical master equation under the assumption of large system size.\n- **Well-Posed**: The deterministic system has a unique, globally stable fixed point. The LNA framework provides a clear path to a unique solution for the stationary covariance matrix, provided the system is stable, which it is.\n- **Objective**: The problem is stated in precise mathematical terms, free of ambiguity or subjective claims.\n- **Completeness**: All required parameters, rates, and reaction definitions are provided.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n### Derivation of the Stationary Protein Variance\n\nThe Linear Noise Approximation (LNA) describes the dynamics of fluctuations $\\eta(t) = x(t) - x^{\\ast}$ around a stable deterministic equilibrium $x^{\\ast}$. The fluctuations follow an Ornstein-Uhlenbeck process, whose covariance matrix $C(t) = \\langle \\eta(t) \\eta(t)^{\\top} \\rangle$ evolves according to the Lyapunov equation:\n$$ \\frac{dC}{dt} = J C(t) + C(t) J^{\\top} + D $$\nAt steady state, $\\frac{dC}{dt} = 0$, and the stationary covariance matrix $C_{ss}$ satisfies the algebraic Lyapunov equation:\n$$ J C_{ss} + C_{ss} J^{\\top} + D = 0 $$\nOur goal is to find the $(2,2)$ element of $C_{ss}$, which we denote as $\\sigma_{pp}$.\n\n**1. Determine the Deterministic Equilibrium $x^{\\ast} = (m^{\\ast}, p^{\\ast})^{\\top}$**\nWe set the time derivatives of the deterministic equations to zero:\n$k_{m} s^* - \\gamma_{m} m^{\\ast} = 0 \\implies m^{\\ast} = \\frac{k_{m} s^*}{\\gamma_{m}}$\n$k_{p} m^{\\ast} - \\gamma_{p} p^{\\ast} = 0 \\implies p^{\\ast} = \\frac{k_{p} m^{\\ast}}{\\gamma_{p}}$\nSubstituting the expression for $m^{\\ast}$ into the equation for $p^{\\ast}$:\n$p^{\\ast} = \\frac{k_{p}}{\\gamma_{p}} \\left( \\frac{k_{m} s^*}{\\gamma_{m}} \\right) = \\frac{k_{p} k_{m} s^*}{\\gamma_{p} \\gamma_{m}}$.\n\n**2. Compute the Jacobian Matrix $J$**\nLet the vector of deterministic rates be $f(x) = (f_m, f_p)^{\\top} = (k_m s^* - \\gamma_m m, k_p m - \\gamma_p p)^{\\top}$. The Jacobian matrix $J$ is given by $J_{ij} = \\frac{\\partial f_i}{\\partial x_j}$ evaluated at $x^{\\ast}$.\n$J_{11} = \\frac{\\partial f_m}{\\partial m} = -\\gamma_m$\n$J_{12} = \\frac{\\partial f_m}{\\partial p} = 0$\n$J_{21} = \\frac{\\partial f_p}{\\partial m} = k_p$\n$J_{22} = \\frac{\\partial f_p}{\\partial p} = -\\gamma_p$\nThe Jacobian is constant and does not depend on the equilibrium point:\n$$ J = \\begin{pmatrix} -\\gamma_m  0 \\\\ k_p  -\\gamma_p \\end{pmatrix} $$\n\n**3. Compute the Diffusion Matrix $D$**\nThe diffusion matrix $D$ is given by $D = \\sum_{j} v_j v_j^{\\top} a_j(x^{\\ast})$, where $v_j$ are the stoichiometric vectors and $a_j(x^{\\ast})$ are the propensities evaluated at the equilibrium $x^{\\ast}$.\nThe propensities at equilibrium are:\n$a_1(x^{\\ast}) = k_m s^*$\n$a_2(x^{\\ast}) = \\gamma_m m^{\\ast} = \\gamma_m \\left(\\frac{k_m s^*}{\\gamma_m}\\right) = k_m s^*$\n$a_3(x^{\\ast}) = k_p m^{\\ast}$\n$a_4(x^{\\ast}) = \\gamma_p p^{\\ast} = \\gamma_p \\left(\\frac{k_p m^{\\ast}}{\\gamma_p}\\right) = k_p m^{\\ast}$\nThe components of $D$ are:\n$D_{11} = (1)^2 a_1(x^{\\ast}) + (-1)^2 a_2(x^{\\ast}) = k_m s^* + k_m s^* = 2k_m s^*$\n$D_{22} = (1)^2 a_3(x^{\\ast}) + (-1)^2 a_4(x^{\\ast}) = k_p m^{\\ast} + k_p m^{\\ast} = 2k_p m^{\\ast}$\n$D_{12} = D_{21} = 0$, as no single reaction affects both $m$ and $p$.\nThus, the diffusion matrix is:\n$$ D = \\begin{pmatrix} 2k_m s^*  0 \\\\ 0  2k_p m^{\\ast} \\end{pmatrix} $$\n\n**4. Solve the Algebraic Lyapunov Equation**\nLet $C_{ss} = \\begin{pmatrix} \\sigma_{mm}  \\sigma_{mp} \\\\ \\sigma_{mp}  \\sigma_{pp} \\end{pmatrix}$. The equation $J C_{ss} + C_{ss} J^{\\top} + D = 0$ becomes:\n$$ \\begin{pmatrix} -\\gamma_m  0 \\\\ k_p  -\\gamma_p \\end{pmatrix} \\begin{pmatrix} \\sigma_{mm}  \\sigma_{mp} \\\\ \\sigma_{mp}  \\sigma_{pp} \\end{pmatrix} + \\begin{pmatrix} \\sigma_{mm}  \\sigma_{mp} \\\\ \\sigma_{mp}  \\sigma_{pp} \\end{pmatrix} \\begin{pmatrix} -\\gamma_m  k_p \\\\ 0  -\\gamma_p \\end{pmatrix} + \\begin{pmatrix} D_{11}  0 \\\\ 0  D_{22} \\end{pmatrix} = \\begin{pmatrix} 0  0 \\\\ 0  0 \\end{pmatrix} $$\nExpanding this matrix equation gives a system of linear equations for the elements of $C_{ss}$:\n$$ \\begin{pmatrix} -2\\gamma_m \\sigma_{mm}  k_p \\sigma_{mm} - (\\gamma_m+\\gamma_p)\\sigma_{mp} \\\\ k_p \\sigma_{mm} - (\\gamma_m+\\gamma_p)\\sigma_{mp}  2k_p \\sigma_{mp} - 2\\gamma_p \\sigma_{pp} \\end{pmatrix} + \\begin{pmatrix} D_{11}  0 \\\\ 0  D_{22} \\end{pmatrix} = \\begin{pmatrix} 0  0 \\\\ 0  0 \\end{pmatrix} $$\nFrom the matrix elements, we get:\n(1,1): $-2\\gamma_m \\sigma_{mm} + D_{11} = 0 \\implies \\sigma_{mm} = \\frac{D_{11}}{2\\gamma_m} = \\frac{2k_m s^*}{2\\gamma_m} = \\frac{k_m s^*}{\\gamma_m} = m^{\\ast}$.\n(1,2): $k_p \\sigma_{mm} - (\\gamma_m+\\gamma_p)\\sigma_{mp} = 0 \\implies \\sigma_{mp} = \\frac{k_p \\sigma_{mm}}{\\gamma_m+\\gamma_p} = \\frac{k_p m^{\\ast}}{\\gamma_m+\\gamma_p}$.\n(2,2): $2k_p \\sigma_{mp} - 2\\gamma_p \\sigma_{pp} + D_{22} = 0 \\implies \\sigma_{pp} = \\frac{k_p \\sigma_{mp}}{\\gamma_p} + \\frac{D_{22}}{2\\gamma_p}$.\n\nNow, we substitute the expressions for $\\sigma_{mp}$ and $D_{22}$ to find $\\sigma_{pp}$:\n$$ \\sigma_{pp} = \\frac{k_p}{\\gamma_p} \\left( \\frac{k_p m^{\\ast}}{\\gamma_m+\\gamma_p} \\right) + \\frac{2k_p m^{\\ast}}{2\\gamma_p} $$\n$$ \\sigma_{pp} = \\frac{k_p^2 m^{\\ast}}{\\gamma_p(\\gamma_m+\\gamma_p)} + \\frac{k_p m^{\\ast}}{\\gamma_p} $$\nRecognizing that $p^{\\ast} = \\frac{k_p m^{\\ast}}{\\gamma_p}$, we can simplify:\n$$ \\sigma_{pp} = \\frac{k_p}{\\gamma_m+\\gamma_p} \\left(\\frac{k_p m^{\\ast}}{\\gamma_p}\\right) + p^{\\ast} = p^{\\ast} \\frac{k_p}{\\gamma_m+\\gamma_p} + p^{\\ast} $$\nFactoring out $p^{\\ast}$:\n$$ \\sigma_{pp} = p^{\\ast} \\left( 1 + \\frac{k_p}{\\gamma_m+\\gamma_p} \\right) $$\nFinally, substitute the expressions for $p^{\\ast} = \\frac{k_p k_m s^*}{\\gamma_p \\gamma_m}$ and $s^* = \\frac{\\alpha}{\\alpha+\\beta}$:\n$$ \\sigma_{pp} = \\left(\\frac{k_p k_m}{\\gamma_p \\gamma_m} \\frac{\\alpha}{\\alpha+\\beta}\\right) \\left( 1 + \\frac{k_p}{\\gamma_m+\\gamma_p} \\right) $$\nTo get a single expression, we combine the terms in the parentheses:\n$$ 1 + \\frac{k_p}{\\gamma_m+\\gamma_p} = \\frac{\\gamma_m+\\gamma_p+k_p}{\\gamma_m+\\gamma_p} $$\nSubstituting this back gives the final expression for the stationary protein variance:\n$$ \\sigma_{pp} = \\left(\\frac{k_p k_m}{\\gamma_p \\gamma_m} \\frac{\\alpha}{\\alpha+\\beta}\\right) \\left(\\frac{\\gamma_m+\\gamma_p+k_p}{\\gamma_m+\\gamma_p}\\right) $$\n$$ \\sigma_{pp} = \\frac{\\alpha k_m k_p (\\gamma_m + \\gamma_p + k_p)}{(\\alpha+\\beta)\\gamma_m \\gamma_p (\\gamma_m + \\gamma_p)} $$\nThis is the closed-form analytic expression for the stationary variance of protein fluctuations in terms of the fundamental model parameters.",
            "answer": "$$\\boxed{\\frac{\\alpha k_m k_p (\\gamma_m + \\gamma_p + k_p)}{(\\alpha+\\beta)\\gamma_m \\gamma_p (\\gamma_m + \\gamma_p)}}$$"
        },
        {
            "introduction": "Modeling an artificial pancreas for diabetes management involves designing controllers that couple continuous physiological processes with discrete therapeutic actions, often based on noisy sensor data. This problem challenges you to implement and analyze a complex stochastic-hybrid system, where random measurement noise influences the timing of discrete insulin bolus events. This simulation-based task provides practical experience in translating a formal hybrid model into a working algorithm and using computational experiments to assess the stability and performance of a closed-loop biomedical control system .",
            "id": "3892153",
            "problem": "Consider closed-loop glucose regulation in a person with Type 1 Diabetes modeled as a hybrid dynamical system that couples continuous glucose-insulin kinetics with event-triggered insulin boluses driven by noisy glucose measurements. The continuous-time state is the pair $(G(t), I(t))$, where $G(t)$ is plasma glucose concentration in $\\mathrm{mg/dL}$ and $I(t)$ is an effective subcutaneous insulin compartment in $\\mathrm{mU}$. The baseline glucose setpoint is $G_b$ in $\\mathrm{mg/dL}$. The continuous dynamics follow first-order mass-balance and pharmacokinetics commonly used in minimal models:\n$$\n\\frac{dG}{dt} = -k_g \\left(G(t) - G_b\\right) - S_I\\, I(t)\\, \\left(G(t) - G_b\\right) + d(t),\n$$\n$$\n\\frac{dI}{dt} = -k_i\\, I(t) + u_{\\mathrm{basal}},\n$$\nwhere $k_g$ in $\\mathrm{min^{-1}}$ is glucose clearance, $S_I$ in $\\mathrm{(mU\\cdot min)^{-1}}$ is insulin sensitivity, $k_i$ in $\\mathrm{min^{-1}}$ is insulin decay rate, $u_{\\mathrm{basal}}$ in $\\mathrm{mU/min}$ is basal insulin infusion, and $d(t)$ in $\\mathrm{mg/dL\\cdot min}$ is exogenous glucose disturbance (assume $d(t) = 0$ for this problem). The measured glucose $y(t)$ is subject to additive measurement noise,\n$$\ny(t) = G(t) + \\varepsilon(t),\n$$\nwhere $\\varepsilon(t)$ is a zero-mean random variable sampled independently at discrete simulation steps and satisfies a Gaussian distribution $\\varepsilon(t) \\sim \\mathcal{N}(0,\\sigma^2)$ with variance $\\sigma^2$ in $\\mathrm{(mg/dL)^2}$. Define the event-triggered bolus control using a guard and reset as follows. The guard function is\n$$\n\\gamma(t) = y(t) - \\theta,\n$$\nwith threshold $\\theta$ in $\\mathrm{mg/dL}$. An event occurs whenever $\\gamma(t)$ crosses from negative to nonnegative and a minimum inter-event dwell-time $\\tau$ in $\\mathrm{min}$ has elapsed since the last event. At an event time $t_k$, the reset map applies an insulin bolus of magnitude $B$ in $\\mathrm{mU}$,\n$$\nG(t_k^+) = G(t_k^-), \\quad I(t_k^+) = I(t_k^-) + B,\n$$\nand continuous evolution resumes from $(G(t_k^+), I(t_k^+))$. Assume piecewise-constant sampling with step $h$ in $\\mathrm{min}$, and approximate the continuous dynamics with a forward Euler scheme on this grid.\n\nTask. Starting from these fundamental definitions, derive an event-triggered controller as specified by the guard and reset, and analyze the closed-loop stability in the presence of measurement noise using a Lyapunov-style argument that explains why bounded inter-event times and bounded bolus sizes can lead to mean-square boundedness of $G(t)$ around $G_b$. Then implement a simulation-based test to assess stability operationally: for a given parameter set, simulate for a duration $T$ in $\\mathrm{min}$, compute the sample mean $\\mu$ and sample variance $v$ of $G(t)$ over the last $T/2$ minutes, and declare the closed loop \"stable\" if\n$$\n\\left|\\mu - G_b\\right| \\leq \\epsilon_\\mu \\quad \\text{and} \\quad v \\leq v_{\\max},\n$$\nwith specified tolerances $\\epsilon_\\mu$ in $\\mathrm{mg/dL}$ and $v_{\\max}$ in $\\mathrm{(mg/dL)^2}$. Use only the stochastic measurement $y(t)$ to trigger events; the state updates must use the noise-free $G(t)$ and $I(t)$. Assume $u_{\\mathrm{basal}} = 0$ and $d(t) = 0$ throughout.\n\nImplementation details. Use forward Euler with step $h$ to integrate the continuous dynamics. At each discrete step $t_n = n h$, generate $\\varepsilon_n \\sim \\mathcal{N}(0,\\sigma^2)$ independently, set $y_n = G_n + \\varepsilon_n$, and apply the guard and reset with dwell-time constraint $\\tau$; after any reset, continue integration. Initialize the random number generator with a provided integer seed per test case for reproducibility. The initial conditions are $G(0) = G_0$ in $\\mathrm{mg/dL}$ and $I(0) = I_0$ in $\\mathrm{mU}$. The simulation duration is $T$ minutes with step $h$, producing $N = T/h$ steps.\n\nUnits. All glucose quantities must be in $\\mathrm{mg/dL}$, time in $\\mathrm{min}$, insulin units in $\\mathrm{mU}$. Report the stability decision as a boolean for each test case. No angles are used. No percentages are used.\n\nTest suite. Implement the program to evaluate the following four parameter sets, which explore diverse regimes, including a \"happy path\", a high-noise regime, a small-bolus regime, and a noise-free boundary case. In each case, use tolerances $\\epsilon_\\mu = 5$ $\\mathrm{mg/dL}$ and $v_{\\max} = 400$ $\\mathrm{(mg/dL)^2}$.\n\n- Case $1$ (happy path): $k_g = 0.01$ $\\mathrm{min^{-1}}$, $S_I = 5\\times 10^{-4}$ $\\mathrm{(mU\\cdot min)^{-1}}$, $k_i = 0.05$ $\\mathrm{min^{-1}}$, $G_b = 100$ $\\mathrm{mg/dL}$, $G_0 = 180$ $\\mathrm{mg/dL}$, $I_0 = 0$ $\\mathrm{mU}$, $\\theta = 140$ $\\mathrm{mg/dL}$, $B = 30$ $\\mathrm{mU}$, $\\sigma = 5$ $\\mathrm{mg/dL}$, $\\tau = 20$ $\\mathrm{min}$, $T = 360$ $\\mathrm{min}$, $h = 0.5$ $\\mathrm{min}$, seed $= 1$.\n\n- Case $2$ (high noise, frequent events): $k_g = 0.01$ $\\mathrm{min^{-1}}$, $S_I = 5\\times 10^{-4}$ $\\mathrm{(mU\\cdot min)^{-1}}$, $k_i = 0.05$ $\\mathrm{min^{-1}}$, $G_b = 100$ $\\mathrm{mg/dL}$, $G_0 = 130$ $\\mathrm{mg/dL}$, $I_0 = 0$ $\\mathrm{mU}$, $\\theta = 110$ $\\mathrm{mg/dL}$, $B = 50$ $\\mathrm{mU}$, $\\sigma = 30$ $\\mathrm{mg/dL}$, $\\tau = 5$ $\\mathrm{min}$, $T = 360$ $\\mathrm{min}$, $h = 0.5$ $\\mathrm{min}$, seed $= 2$.\n\n- Case $3$ (small bolus): $k_g = 0.01$ $\\mathrm{min^{-1}}$, $S_I = 5\\times 10^{-4}$ $\\mathrm{(mU\\cdot min)^{-1}}$, $k_i = 0.05$ $\\mathrm{min^{-1}}$, $G_b = 100$ $\\mathrm{mg/dL}$, $G_0 = 160$ $\\mathrm{mg/dL}$, $I_0 = 0$ $\\mathrm{mU}$, $\\theta = 140$ $\\mathrm{mg/dL}$, $B = 5$ $\\mathrm{mU}$, $\\sigma = 5$ $\\mathrm{mg/dL}$, $\\tau = 20$ $\\mathrm{min}$, $T = 360$ $\\mathrm{min}$, $h = 0.5$ $\\mathrm{min}$, seed $= 3$.\n\n- Case $4$ (noise-free boundary): $k_g = 0.01$ $\\mathrm{min^{-1}}$, $S_I = 5\\times 10^{-4}$ $\\mathrm{(mU\\cdot min)^{-1}}$, $k_i = 0.05$ $\\mathrm{min^{-1}}$, $G_b = 100$ $\\mathrm{mg/dL}$, $G_0 = 150$ $\\mathrm{mg/dL}$, $I_0 = 0$ $\\mathrm{mU}$, $\\theta = 120$ $\\mathrm{mg/dL}$, $B = 20$ $\\mathrm{mU}$, $\\sigma = 0$ $\\mathrm{mg/dL}$, $\\tau = 20$ $\\mathrm{min}$, $T = 360$ $\\mathrm{min}$, $h = 0.5$ $\\mathrm{min}$, seed $= 4$.\n\nOutput specification. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3},\\mathrm{result4}\\right]$), where each $\\mathrm{result}$ is a boolean indicating whether the closed loop is stable for the corresponding test case under the operational criterion above.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in established principles of biomedical systems modeling, specifically pharmacokinetics and pharmacodynamics of glucose regulation. The problem is well-posed, providing all necessary parameters, initial conditions, and a clear, objective task. It is free from ambiguities, contradictions, and factual errors.\n\n### Theoretical Framework\n\n#### 1. Hybrid Dynamical Model\n\nThe system describes closed-loop glucose control as a hybrid automaton. The state is $\\mathbf{x}(t) = [G(t), I(t)]^T$, where $G(t)$ is the plasma glucose concentration in $\\mathrm{mg/dL}$ and $I(t)$ is the effective subcutaneous insulin concentration in $\\mathrm{mU}$. The model comprises two main parts: continuous evolution (flow) and discrete events (jumps).\n\n**Continuous Dynamics (Flow):** Between events, the state evolves according to a set of ordinary differential equations (ODEs). Given the problem's constraints that basal insulin infusion $u_{\\mathrm{basal}} = 0$ and glucose disturbance $d(t) = 0$, the dynamics are:\n$$\n\\frac{dG}{dt} = -k_g \\left(G(t) - G_b\\right) - S_I\\, I(t)\\, \\left(G(t) - G_b\\right)\n$$\n$$\n\\frac{dI}{dt} = -k_i\\, I(t)\n$$\nHere, $k_g$ is the insulin-independent glucose clearance rate, $S_I$ is insulin sensitivity, $k_i$ is the insulin clearance rate, and $G_b$ is the basal glucose setpoint. These equations describe how glucose naturally returns to baseline and how this process is accelerated by insulin, while the insulin itself decays over time.\n\n**Discrete Dynamics (Jumps):** The system state is altered instantaneously at specific event times $t_k$. These events are triggered by a controller based on noisy glucose measurements, $y(t) = G(t) + \\varepsilon(t)$, where $\\varepsilon(t) \\sim \\mathcal{N}(0, \\sigma^2)$. An event occurs if all three of the following conditions are met:\n1.  **Guard Condition:** The noisy measurement $y(t)$ crosses a threshold $\\theta$ from below. That is, the guard function $\\gamma(t) = y(t) - \\theta$ becomes non-negative, having been negative just prior.\n2.  **Dwell-Time Constraint:** A minimum time $\\tau$ has passed since the last event at $t_{k-1}$, i.e., $t_k - t_{k-1} \\ge \\tau$.\n3.  **Reset Map:** At an event time $t_k$, an insulin bolus of size $B$ is administered. The state is reset as follows:\n    $$\n    G(t_k^+) = G(t_k^-)\n    $$\n    $$\n    I(t_k^+) = I(t_k^-) + B\n    $$\nwhere $t_k^-$ and $t_k^+$ denote the time just before and just after the event, respectively.\n\n#### 2. Stability Analysis via Lyapunov-style Argument\n\nThe task requires an argument for why this control strategy can lead to the mean-square boundedness of $G(t)$ around its setpoint $G_b$. Let us define the glucose deviation from the setpoint as $g(t) = G(t) - G_b$. A simple Lyapunov function candidate for this subsystem is $V(g) = \\frac{1}{2}g^2$. The time derivative of $V$ during the continuous flow phase is:\n$$\n\\dot{V} = \\frac{dV}{dg}\\frac{dg}{dt} = g \\cdot \\left[ -k_g g - S_I I(t) g \\right] = -(k_g + S_I I(t)) g^2\n$$\nSince $k_g > 0$, $S_I > 0$, and $I(t) \\ge 0$ (insulin concentration cannot be negative), the term $(k_g + S_I I(t))$ is strictly positive. Therefore, $\\dot{V} \\le 0$. The derivative is strictly negative if $g \\neq 0$, indicating that between events, the glucose level $G(t)$ is always driven towards the setpoint $G_b$. The system's flow dynamics are inherently stabilizing.\n\nThe discrete events (bolus injections) serve as a corrective control action. A bolus is triggered when $y(t) = G(t) + \\varepsilon(t) \\ge \\theta$, which typically occurs when $G(t)$ is significantly above $G_b$. The bolus $B$ causes an instantaneous increase in $I(t)$, which makes the term $S_I I(t)$ larger and thus makes $\\dot{V}$ more negative, accelerating the return of $G(t)$ to $G_b$.\n\nThe stability in the presence of noise can be understood as follows:\n*   **Bounded Inputs:** The bolus size $B$ is finite. This prevents a single, potentially erroneous, measurement from injecting an unbounded amount of insulin, which could cause severe hypoglycemia. The system cannot be destabilized by a single event.\n*   **Dwell Time:** The minimum inter-event time $\\tau$ prevents an excessively high frequency of boluses (a phenomenon known as Zeno behavior in hybrid systems or \"insulin stacking\" in diabetes care). This limits the total amount of insulin injected over any finite period, ensuring $I(t)$ remains bounded and providing time for the system to react to a previous bolus before administering another.\n*   **Noise Effect:** The zero-mean measurement noise $\\varepsilon(t)$ can cause both premature triggers (when a positive $\\varepsilon(t)$ pushes $y(t)$ above $\\theta$ even if $G(t)  \\theta$) and missed triggers (when a negative $\\varepsilon(t)$ keeps $y(t)$ below $\\theta$ even if $G(t) \\ge \\theta$). While individual triggers may be suboptimal, the zero-mean nature of the noise means there is no systematic bias. Over time, the controller's actions are, on average, corrective.\n*   **Mean-Square Boundedness:** The combination of stabilizing continuous dynamics and a bounded, non-Zeno, corrective discrete controller means the state trajectories are \"trapped\" within a certain region around the equilibrium point $(G_b, 0)$. The noise introduces random perturbations, causing the state to fluctuate. However, because the restoring forces (both continuous and discrete) grow as the state moves away from the setpoint, the variance of these fluctuations remains finite. This is the essence of mean-square boundedness. The size of this bounded region (and thus the variance $v$) will depend on the noise variance $\\sigma^2$ and the controller parameters ($\\theta, B, \\tau$).\n\n#### 3. Numerical Implementation\n\nTo test this model, we implement a discrete-time simulation using the forward Euler method with a fixed time step $h$.\n\n**Discretization:** Let $G_n \\approx G(t_n)$ and $I_n \\approx I(t_n)$ for $t_n = n h$. The Euler approximation of the ODEs is:\n$$\nG_{n+1} = G_n + h \\cdot \\left[ -k_g(G_n - G_b) - S_I I_{\\mathrm{eff},n} (G_n - G_b) \\right]\n$$\n$$\nI_{n+1} = I_{\\mathrm{eff},n} + h \\cdot \\left[ -k_i I_{\\mathrm{eff},n} \\right] = I_{\\mathrm{eff},n}(1 - h k_i)\n$$\nwhere $I_{\\mathrm{eff},n}$ is the effective insulin level at the start of the interval $[t_n, t_{n+1}]$.\n\n**Simulation Algorithm:**\n1.  Initialize state variables $G_0, I_0$, simulation time $t=0$, and `last_event_time` to a sufficiently small value (e.g., $-\\infty$) to permit an initial event. Initialize a `y_prev` variable to detect threshold crossings.\n2.  For each time step $n$ from $0$ to $N-1 = T/h - 1$:\n    a. Let $t_n = n \\cdot h$.\n    b. Generate a measurement noise sample $\\varepsilon_n \\sim \\mathcal{N}(0, \\sigma^2)$.\n    c. Calculate the noisy measurement $y_n = G_n + \\varepsilon_n$.\n    d. Check for an event trigger: The conditions are (`y_n = \\theta`), (`y_{prev}  \\theta`), and (`t_n - \\text{last\\_event\\_time} \\ge \\tau`). The `y_{prev}  \\theta` condition discretizes the \"crossing from negative\" requirement.\n    e. Define the effective insulin for the current step, $I_{\\mathrm{eff},n} = I_n$.\n    f. If an event is triggered, apply the reset map: update $I_{\\mathrm{eff},n} \\leftarrow I_{\\mathrm{eff},n} + B$ and record the event time: $\\text{last\\_event\\_time} = t_n$.\n    g. Update `y_prev = y_n` for the next iteration.\n    h. Calculate the states at the next time step, $G_{n+1}$ and $I_{n+1}$, using the Euler formulas with $G_n$ and the (potentially updated) $I_{\\mathrm{eff},n}$.\n3.  After the simulation completes, collect the glucose history $G(t)$ for the second half of the simulation period, i.e., for $t \\in [T/2, T]$.\n4.  Compute the sample mean $\\mu$ and sample variance $v$ (with Bessel's correction, ddof=1) of this collected data.\n5.  Apply the operational stability test: the system is declared \"stable\" if $|\\mu - G_b| \\leq \\epsilon_\\mu$ and $v \\leq v_{\\max}$. For this problem, $\\epsilon_\\mu = 5 \\, \\mathrm{mg/dL}$ and $v_{\\max} = 400 \\, (\\mathrm{mg/dL})^2$.\n\n```python\nimport numpy as np\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single simulation of the hybrid glucose-insulin model.\n    \"\"\"\n    # Unpack parameters\n    k_g = params[\"k_g\"]\n    S_I = params[\"S_I\"]\n    k_i = params[\"k_i\"]\n    G_b = params[\"G_b\"]\n    G_0 = params[\"G_0\"]\n    I_0 = params[\"I_0\"]\n    theta = params[\"theta\"]\n    B = params[\"B\"]\n    sigma = params[\"sigma\"]\n    tau = params[\"tau\"]\n    T = params[\"T\"]\n    h = params[\"h\"]\n    seed = params[\"seed\"]\n    epsilon_mu = params[\"epsilon_mu\"]\n    v_max = params[\"v_max\"]\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Simulation setup\n    num_steps = int(T / h)\n    G = np.zeros(num_steps + 1)\n    I = np.zeros(num_steps + 1)\n\n    # Initial conditions\n    G[0] = G_0\n    I[0] = I_0\n\n    last_event_time = -np.inf\n    # Initialize y_prev to ensure a trigger can occur at t=0 if y_0 = theta\n    y_prev = -np.inf \n\n    # Simulation loop\n    for n in range(num_steps):\n        t_n = n * h\n        G_n = G[n]\n        I_n = I[n]\n\n        # Generate noisy measurement\n        epsilon_n = rng.normal(0.0, sigma)\n        y_n = G_n + epsilon_n\n\n        # Event trigger logic\n        # 1. Guard check: y_n = theta\n        # 2. Crossing condition: y_prev  theta\n        # 3. Dwell-time constraint: t_n - last_event_time = tau\n        is_event_triggered = (y_n = theta) and (y_prev  theta) and (t_n - last_event_time = tau)\n        \n        # Store current y_n for the next iteration's crossing check\n        y_prev = y_n\n\n        # The effective insulin for the current step's dynamics\n        I_eff_n = I_n\n        if is_event_triggered:\n            I_eff_n += B\n            last_event_time = t_n\n\n        # Forward Euler step for continuous dynamics\n        # Note: u_basal and d(t) are zero as per problem statement\n        dG_dt = -k_g * (G_n - G_b) - S_I * I_eff_n * (G_n - G_b)\n        dI_dt = -k_i * I_eff_n\n\n        G[n + 1] = G_n + h * dG_dt\n        # The Euler step for insulin starts from the post-bolus value\n        I[n + 1] = I_eff_n + h * dI_dt\n\n    # Stability assessment over the last T/2 minutes\n    analysis_start_index = int(num_steps / 2)\n    G_analysis_slice = G[analysis_start_index:]\n    \n    mu = np.mean(G_analysis_slice)\n    # Use ddof=1 for sample variance as is standard\n    v = np.var(G_analysis_slice, ddof=1)\n    \n    is_stable = (abs(mu - G_b) = epsilon_mu) and (v = v_max)\n    \n    return is_stable\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the simulation for each to determine stability.\n    \"\"\"\n    common_tolerances = {\n        \"epsilon_mu\": 5.0,     # mg/dL\n        \"v_max\": 400.0       # (mg/dL)^2\n    }\n\n    test_cases = [\n        # Case 1 (happy path)\n        {\"k_g\": 0.01, \"S_I\": 5e-4, \"k_i\": 0.05, \"G_b\": 100, \"G_0\": 180, \"I_0\": 0,\n         \"theta\": 140, \"B\": 30, \"sigma\": 5, \"tau\": 20, \"T\": 360, \"h\": 0.5, \"seed\": 1, **common_tolerances},\n        # Case 2 (high noise, frequent events)\n        {\"k_g\": 0.01, \"S_I\": 5e-4, \"k_i\": 0.05, \"G_b\": 100, \"G_0\": 130, \"I_0\": 0,\n         \"theta\": 110, \"B\": 50, \"sigma\": 30, \"tau\": 5, \"T\": 360, \"h\": 0.5, \"seed\": 2, **common_tolerances},\n        # Case 3 (small bolus)\n        {\"k_g\": 0.01, \"S_I\": 5e-4, \"k_i\": 0.05, \"G_b\": 100, \"G_0\": 160, \"I_0\": 0,\n         \"theta\": 140, \"B\": 5, \"sigma\": 5, \"tau\": 20, \"T\": 360, \"h\": 0.5, \"seed\": 3, **common_tolerances},\n        # Case 4 (noise-free boundary)\n        {\"k_g\": 0.01, \"S_I\": 5e-4, \"k_i\": 0.05, \"G_b\": 100, \"G_0\": 150, \"I_0\": 0,\n         \"theta\": 120, \"B\": 20, \"sigma\": 0, \"tau\": 20, \"T\": 360, \"h\": 0.5, \"seed\": 4, **common_tolerances}\n    ]\n\n    results = []\n    for params in test_cases:\n        is_stable = run_simulation(params)\n        results.append(is_stable)\n\n    # Format the final output as specified\n    return f\"[{','.join(str(r) for r in results)}]\"\n\n# The final output is generated by this call.\n# solve()\n```",
            "answer": "[True,True,False,True]"
        }
    ]
}