{
    "hands_on_practices": [
        {
            "introduction": "为了有效地处理刚性系统，我们首先必须学会如何诊断它们。本练习将演示如何通过分析系统的局部动力学来量化刚性。通过计算雅可比矩阵的特征值，您将确定显式方法的最大稳定步长，从而具体揭示为何此类方法对于具有广泛分离时间尺度的问题是不切实际的。",
            "id": "3913778",
            "problem": "考虑在生物医学系统建模中用于表示快慢生化反应网络的三物种 Robertson 动力学模型。设状态向量为 $\\mathbf{y} = [y_1, y_2, y_3]^\\top$，并设反应速率由质量作用动力学控制，速率常数为 $k_1$、$k_2$ 和 $k_3$。其控制性常微分方程 (ODE) 为\n$$\n\\frac{dy_1}{dt} = -k_1 y_1 + k_3 y_2 y_3,\\quad\n\\frac{dy_2}{dt} = k_1 y_1 - k_2 y_2^2 - k_3 y_2 y_3,\\quad\n\\frac{dy_3}{dt} = k_2 y_2^2.\n$$\n在一个固定的代表性状态 $\\mathbf{y}$，假设动力学由下式给出局部线性化\n$$\n\\frac{d\\mathbf{y}}{dt} \\approx \\mathbf{J}(\\mathbf{y})\\,\\mathbf{y},\n$$\n其中 $\\mathbf{J}(\\mathbf{y})$ 是向量场关于 $\\mathbf{y}$ 的偏导数构成的雅可比矩阵。推导并实现一种计算 $\\mathbf{J}(\\mathbf{y})$ 特征值的方法，并基于线性稳定性分析，用这些特征值来估计显式前向欧拉方法的稳定时间步长上限。\n\n使用以下基础原理：\n- 将反应速率定义为物种浓度多项式函数的质量作用动力学。\n- 雅可比矩阵的定义 $\\mathbf{J}_{ij} = \\frac{\\partial f_i}{\\partial y_j}$，其中 $\\mathbf{f}(\\mathbf{y})$ 是向量场。\n- 应用于线性测试方程 $\\frac{dz}{dt} = \\lambda z$ 的前向欧拉方法的线性稳定性，其要求 $\\lvert 1 + h\\lambda \\rvert \\le 1$ 才能保持稳定，其中 $h$ 是时间步长，$\\lambda$ 是雅可比矩阵的特征值。\n\n任务：\n1. 从常微分方程和质量作用动力学出发，显式地写出雅可比矩阵 $\\mathbf{J}(\\mathbf{y})$，用 $k_1$、$k_2$、$k_3$ 以及 $\\mathbf{y}$ 的分量表示。不要使用任何快捷公式；从第一性原理推导每个偏导数。\n2. 对于给定的状态 $\\mathbf{y}$ 和参数 $(k_1, k_2, k_3)$，计算 $\\mathbf{J}(\\mathbf{y})$ 的特征值 $\\{\\lambda_i\\}$。\n3. 利用前向欧拉方法的绝对稳定性条件 $\\lvert 1 + h\\lambda \\rvert \\le 1$，通过求解等式条件（在 $h \\ge 0$ 的情况下），为每个具有负实部的特征值确定稳定性边界上的临界步长 $h_i$。然后选择一个能同时满足所有特征值条件的全局最大稳定时间步长 $h_{\\max}$。\n4. 所有最终步长均以秒为单位表示。\n\n对于稳定性边界的计算，您必须通过代数方法精确求解不等式 $\\lvert 1 + h\\lambda \\rvert \\le 1$ 以得到 $h$，而不能假设特征值为纯实数。您的结果必须普遍适用于任何具有负实部的复特征值 $\\lambda$。\n\n测试用例：\n除非特定测试用例另有规定，否则使用基础参数值 $k_1 = 0.04\\,\\mathrm{s}^{-1}$，$k_2 = 3\\times 10^7\\,\\mathrm{s}^{-1}$（每平方浓度单位），以及 $k_3 = 1\\times 10^4\\,\\mathrm{s}^{-1}$。所选状态满足 $y_1 + y_2 + y_3 = 1$。\n\n- 测试用例 1：$\\mathbf{y} = [1.0, 0.0, 0.0]$，$k_1 = 0.04$，$k_2 = 3\\times 10^7$，$k_3 = 1\\times 10^4$。\n- 测试用例 2：$\\mathbf{y} = [0.999, 1\\times 10^{-4}, 9\\times 10^{-4}]$，$k_1 = 0.04$，$k_2 = 3\\times 10^7$，$k_3 = 1\\times 10^4$。\n- 测试用例 3：$\\mathbf{y} = [0.9, 5\\times 10^{-3}, 9.5\\times 10^{-2}]$，$k_1 = 0.04$，$k_2 = 3\\times 10^7$，$k_3 = 1\\times 10^4$。\n- 测试用例 4：$\\mathbf{y} = [0.5, 1\\times 10^{-2}, 4.9\\times 10^{-1}]$，$k_1 = 0.04$，$k_2 = 3\\times 10^7$，$k_3 = 1\\times 10^4$。\n- 测试用例 5：$\\mathbf{y} = [0.9, 5\\times 10^{-3}, 9.5\\times 10^{-2}]$，$k_1 = 0.04$，$k_2 = 3\\times 10^6$，$k_3 = 1\\times 10^4$。\n- 测试用例 6：$\\mathbf{y} = [0.999, 1\\times 10^{-4}, 9\\times 10^{-4}]$，$k_1 = 0.04$，$k_2 = 3\\times 10^7$，$k_3 = 1\\times 10^5$。\n\n您的程序应针对每个测试用例，根据指定状态下雅可比矩阵的特征值，计算前向欧拉方法的最大时间步长 $h_{\\max}$（以秒为单位）。最终输出必须是包含六个结果的单行，结果为逗号分隔的列表，并用方括号括起来，例如 $\\texttt{[h1,h2,h3,h4,h5,h6]}$，其中每个 $h_i$ 均以秒为单位。",
            "solution": "当前问题要求分析前向欧拉方法应用于 Robertson 动力学模型的数值稳定性，该模型是化学和生物医学建模中刚性系统的一个典型例子。主要任务是推导系统的雅可比矩阵，利用其特征值确定前向欧拉方法的绝对稳定域，并为几个测试用例计算最大允许时间步长 $h_{\\max}$。\n\n控制性常微分方程 (ODE) 系统由向量场 $\\mathbf{f}(\\mathbf{y}) = [f_1(\\mathbf{y}), f_2(\\mathbf{y}), f_3(\\mathbf{y})]^\\top$ 给出，其中 $\\mathbf{y} = [y_1, y_2, y_3]^\\top$ 是物种浓度的状态向量。向量场的分量为：\n$$\n\\frac{dy_1}{dt} = f_1(\\mathbf{y}) = -k_1 y_1 + k_3 y_2 y_3\n$$\n$$\n\\frac{dy_2}{dt} = f_2(\\mathbf{y}) = k_1 y_1 - k_2 y_2^2 - k_3 y_2 y_3\n$$\n$$\n\\frac{dy_3}{dt} = f_3(\\mathbf{y}) = k_2 y_2^2\n$$\n\n该系统的一个基本性质是总浓度守恒。将这三个方程相加可得：\n$$\n\\frac{d(y_1 + y_2 + y_3)}{dt} = (-k_1 y_1 + k_3 y_2 y_3) + (k_1 y_1 - k_2 y_2^2 - k_3 y_2 y_3) + (k_2 y_2^2) = 0\n$$\n这意味着 $y_1 + y_2 + y_3$ 是一个守恒量。如下所示，这一性质对系统的雅可比矩阵有直接影响。\n\n**步骤 1：推导雅可比矩阵**\n\n数值方法在状态 $\\mathbf{y}$ 的稳定性由在该状态下求值的雅可比矩阵 $\\mathbf{J}(\\mathbf{y})$ 的特征值决定。雅可比矩阵由其元素 $\\mathbf{J}_{ij} = \\frac{\\partial f_i}{\\partial y_j}$ 定义。我们从第一性原理推导每个元素。\n\n$f_1 = -k_1 y_1 + k_3 y_2 y_3$ 的偏导数为：\n- $\\mathbf{J}_{11} = \\frac{\\partial f_1}{\\partial y_1} = -k_1$\n- $\\mathbf{J}_{12} = \\frac{\\partial f_1}{\\partial y_2} = k_3 y_3$\n- $\\mathbf{J}_{13} = \\frac{\\partial f_1}{\\partial y_3} = k_3 y_2$\n\n$f_2 = k_1 y_1 - k_2 y_2^2 - k_3 y_2 y_3$ 的偏导数为：\n- $\\mathbf{J}_{21} = \\frac{\\partial f_2}{\\partial y_1} = k_1$\n- $\\mathbf{J}_{22} = \\frac{\\partial f_2}{\\partial y_2} = -2k_2 y_2 - k_3 y_3$\n- $\\mathbf{J}_{23} = \\frac{\\partial f_2}{\\partial y_3} = -k_3 y_2$\n\n$f_3 = k_2 y_2^2$ 的偏导数为：\n- $\\mathbf{J}_{31} = \\frac{\\partial f_3}{\\partial y_1} = 0$\n- $\\mathbf{J}_{32} = \\frac{\\partial f_3}{\\partial y_2} = 2k_2 y_2$\n- $\\mathbf{J}_{33} = \\frac{\\partial f_3}{\\partial y_3} = 0$\n\n将这些元素组合起来，雅可比矩阵为：\n$$\n\\mathbf{J}(\\mathbf{y}) = \\begin{pmatrix}\n-k_1 & k_3 y_3 & k_3 y_2 \\\\\nk_1 & -2k_2 y_2 - k_3 y_3 & -k_3 y_2 \\\\\n0 & 2k_2 y_2 & 0\n\\end{pmatrix}\n$$\n守恒律 $y_1+y_2+y_3=\\text{常数}$ 意味着向量 $\\mathbf{v} = [1, 1, 1]^\\top$ 是 $\\mathbf{J}$ 的一个左特征向量，其特征值为 $0$。这可以通过对 $\\mathbf{J}$ 的各列求和来验证：\n$$\n\\sum_{i=1}^3 \\mathbf{J}_{i1} = -k_1 + k_1 + 0 = 0\n$$\n$$\n\\sum_{i=1}^3 \\mathbf{J}_{i2} = k_3 y_3 + (-2k_2 y_2 - k_3 y_3) + 2k_2 y_2 = 0\n$$\n$$\n\\sum_{i=1}^3 \\mathbf{J}_{i3} = k_3 y_2 - k_3 y_2 + 0 = 0\n$$\n由于每列之和为零，显然有 $[1, 1, 1]\\mathbf{J} = [0, 0, 0]$。这证实了 $\\lambda=0$ 总是 $\\mathbf{J}$ 的一个特征值。\n\n**步骤 2：推导最大稳定时间步长**\n\n将前向欧拉方法应用于线性测试方程 $\\frac{dz}{dt} = \\lambda z$ 会得到递推关系 $z_{n+1} = z_n + h\\lambda z_n = (1+h\\lambda)z_n$。为使方法稳定，放大因子的模不得超过 1，即 $|1+h\\lambda| \\le 1$。我们必须找到满足雅可比矩阵 $\\mathbf{J}$ 所有特征值 $\\lambda$ 的最大步长 $h \\ge 0$。\n\n设特征值 $\\lambda$ 为复数，$\\lambda = a + ib$，其中 $a = \\operatorname{Re}(\\lambda)$，$b = \\operatorname{Im}(\\lambda)$。对于动态稳定模式，必须有 $a  0$。问题正确地指明只考虑具有负实部的特征值。\n\n稳定性条件是：\n$$\n|1 + h(a+ib)| \\le 1\n$$\n$$\n|(1+ha) + i(hb)| \\le 1\n$$\n对模进行平方，我们得到：\n$$\n(1+ha)^2 + (hb)^2 \\le 1\n$$\n$$\n1 + 2ha + h^2 a^2 + h^2 b^2 \\le 1\n$$\n$$\n2ha + h^2(a^2 + b^2) \\le 0\n$$\n因为我们在寻找一个非平凡的步长 $h > 0$，我们可以用 $h$ 除以上式：\n$$\n2a + h(a^2 + b^2) \\le 0\n$$\n$$\nh(a^2 + b^2) \\le -2a\n$$\n项 $a^2 + b^2$ 是特征值的模的平方，即 $|\\lambda|^2$。由于 $a0$，右侧 $-2a$ 是正的。我们可以除以 $|\\lambda|^2$（假设 $\\lambda \\ne 0$，这一点由 $a0$ 保证）：\n$$\nh \\le \\frac{-2a}{a^2+b^2} = \\frac{-2\\operatorname{Re}(\\lambda)}{|\\lambda|^2}\n$$\n这个不等式为每个具有负实部的特征值 $\\lambda_i$ 提供了时间步长 $h_i$ 的上界。为了确保整个系统的稳定性，时间步长 $h$ 必须同时满足所有这些特征值的条件。因此，全局最大稳定时间步长 $h_{\\max}$ 是这些单个上界的最小值：\n$$\nh_{\\max} = \\min_{i, \\text{ s.t. } \\operatorname{Re}(\\lambda_i)  0} \\left( \\frac{-2\\operatorname{Re}(\\lambda_i)}{|\\lambda_i|^2} \\right)\n$$\n特征值 $\\lambda = 0$ 导致条件 $|1+0| \\le 1$，该条件始终成立，因此对 $h$ 没有限制。\n\n**步骤 3：算法实现**\n\n对于每个测试用例，求解过程如下：\n1. 将状态向量 $\\mathbf{y} = [y_1, y_2, y_3]^\\top$ 和速率常数 $\\mathbf{k} = [k_1, k_2, k_3]^\\top$ 的数值代入雅可比矩阵 $\\mathbf{J}(\\mathbf{y})$ 的解析表达式。\n2. 计算得到的数值矩阵 $\\mathbf{J}$ 的特征值 $\\{\\lambda_i\\}$。\n3. 对于每个满足 $\\operatorname{Re}(\\lambda_i)  0$ 的特征值 $\\lambda_i$，计算临界时间步长 $h_i = \\frac{-2\\operatorname{Re}(\\lambda_i)}{|\\lambda_i|^2}$。\n4. 确定该测试用例的最大稳定时间步长 $h_{\\max}$，即为所有这样计算出的 $h_i$ 的最小值。如果没有特征值具有负实部，则 $h_{\\max}$ 被认为是无界的（无穷大）。\n\n此过程在提供的 Python 代码中实现，使用 `numpy` 库进行数值线性代数运算，特别是使用 `numpy.linalg.eigvals` 来计算特征值。然后，所有测试用例的最终结果被格式化并按要求打印。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum stable Forward Euler time step for the Robertson\n    kinetics model for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (y_vector, k_vector)\n    # y_vector: [y1, y2, y3]\n    # k_vector: [k1, k2, k3]\n    test_cases = [\n        ([1.0, 0.0, 0.0], [0.04, 3e7, 1e4]),\n        ([0.999, 1.0e-4, 9.0e-4], [0.04, 3e7, 1e4]),\n        ([0.9, 5.0e-3, 9.5e-2], [0.04, 3e7, 1e4]),\n        ([0.5, 1.0e-2, 4.9e-1], [0.04, 3e7, 1e4]),\n        ([0.9, 5.0e-3, 9.5e-2], [0.04, 3e6, 1e4]),\n        ([0.999, 1.0e-4, 9.0e-4], [0.04, 3e7, 1e5]),\n    ]\n\n    results = []\n    for y_vec, k_vec in test_cases:\n        y1, y2, y3 = y_vec\n        k1, k2, k3 = k_vec\n\n        # Construct the Jacobian matrix J based on the derived formula.\n        # J_ij = d(f_i)/d(y_j)\n        # f1 = -k1*y1 + k3*y2*y3\n        # f2 = k1*y1 - k2*y2**2 - k3*y2*y3\n        # f3 = k2*y2**2\n        J = np.array([\n            [-k1, k3 * y3, k3 * y2],\n            [k1, -2.0 * k2 * y2 - k3 * y3, -k3 * y2],\n            [0.0, 2.0 * k2 * y2, 0.0]\n        ], dtype=float)\n\n        # Compute the eigenvalues of the Jacobian matrix.\n        eigenvalues = np.linalg.eigvals(J)\n\n        h_max = float('inf')\n        \n        # Iterate through eigenvalues to find the most restrictive stability limit.\n        for lam in eigenvalues:\n            real_part = lam.real\n            \n            # The stability condition is relevant only for eigenvalues with a\n            # negative real part, which correspond to stable modes.\n            if real_part  0:\n                # Calculate the squared magnitude of the eigenvalue.\n                mag_sq = lam.real**2 + lam.imag**2\n                \n                # Avoid division by zero, although this case is already handled by\n                # the real_part  0 check, as lambda=0 has a zero real part.\n                if mag_sq  1e-15: # A small tolerance for floating point safety.\n                    # Calculate the critical time step for this eigenvalue.\n                    # h_crit = -2 * Re(lambda) / |lambda|^2\n                    h_crit = -2.0 * real_part / mag_sq\n                    \n                    # The overall maximum step size is the minimum of all critical step sizes.\n                    if h_crit  h_max:\n                        h_max = h_crit\n                        \n        results.append(h_max)\n\n    # Format the final output as a comma-separated list in brackets.\n    # Scientific notation with 8 decimal places is used for precision.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在诊断出显式方法的局限性之后，我们现在来实践其解决方案。本练习将指导您使用向后欧拉法为刚性系统构建一个鲁棒的求解器。您将看到，其卓越的稳定性需要在每一步求解一个非线性方程组，而您将通过实现带有解析推导雅可比矩阵的牛顿法来完成这项任务。",
            "id": "3913755",
            "problem": "您需要设计并实现一个完整的、可运行的程序，该程序使用隐式方法对生物医学系统建模中出现的刚性化学动力学模型进行数值积分。该模型是 Robertson 系统，这是一个典型的刚性系统，代表了质量作用动力学下的三物种反应网络。其目的是展示为何数值刚性问题需要使用隐式方法，以及解析计算的雅可比矩阵如何在一个后向欧拉格式中实现稳健的 Newton 迭代。您的任务必须纯粹用数学和算法术语来表述，并且无需特定领域的实验室数据即可解决。\n\nRobertson 系统以浓度作为时间函数表示，由以下常微分方程 (ODE) 系统给出：\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y}), \\quad \\mathbf{y}(t) = \\begin{bmatrix} x(t) \\\\ y(t) \\\\ z(t) \\end{bmatrix},\n$$\n其右侧函数定义为：\n$$\nf_1(x,y,z) = -k_1 x + k_2 y z, \\quad\nf_2(x,y,z) = k_1 x - k_2 y z - k_3 y^2, \\quad\nf_3(x,y,z) = k_3 y^2,\n$$\n初始条件为：\n$$\n\\mathbf{y}(0) = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}.\n$$\n使用科学上标准的速率常数：\n$$\nk_1 = 0.04 \\text{ s}^{-1}, \\quad k_2 = 10^4 \\text{ (mol/L)}^{-1}\\text{ s}^{-1}, \\quad k_3 = 3\\times 10^7 \\text{ (mol/L)}^{-1}\\text{ s}^{-1}.\n$$\n所有浓度 $x$、$y$ 和 $z$ 的单位为 $\\text{mol/L}$，时间 $t$ 的单位为 $\\text{s}$。该系统是刚性的，因为 $k_3$ 的数量级远大于 $k_1$ 和 $k_2$，导致分量 $y(t)$ 相对于 $x(t)$ 和 $z(t)$ 在一个非常快的时间尺度上演化。\n\n为此初始值问题实现两种数值积分器：\n- 具有固定时间步长 $h$ 的显式欧拉法（前向欧拉法）：\n$$\n\\mathbf{y}_{n+1}^{\\mathrm{EE}} = \\mathbf{y}_n + h\\,\\mathbf{f}(\\mathbf{y}_n).\n$$\n- 具有固定时间步长 $h$ 的后向欧拉法（隐式欧拉法），在每个时间步通过 Newton 法求解：\n$$\n\\mathbf{y}_{n+1}^{\\mathrm{BE}} \\text{ 满足 } \\mathbf{y}_{n+1}^{\\mathrm{BE}} = \\mathbf{y}_n + h\\,\\mathbf{f}(\\mathbf{y}_{n+1}^{\\mathrm{BE}}).\n$$\n将后向欧拉法表述为求解残差的求根问题：\n$$\n\\mathbf{R}(\\mathbf{y}) = \\mathbf{y} - \\mathbf{y}_n - h\\,\\mathbf{f}(\\mathbf{y}),\n$$\n并使用带有回溯线搜索的 Newton 法求解 $\\mathbf{R}(\\mathbf{y}) = \\mathbf{0}$。您必须解析地计算 $\\mathbf{f}$ 的雅可比矩阵，并用它来构造 Newton 雅可比矩阵：\n$$\n\\mathbf{J}_{\\mathbf{R}}(\\mathbf{y}) = \\mathbf{I} - h\\,\\mathbf{J}_{\\mathbf{f}}(\\mathbf{y}),\n$$\n其中 $\\mathbf{I}$ 是 $3\\times 3$ 的单位矩阵。推导并实现解析雅可比矩阵 $\\mathbf{J}_{\\mathbf{f}}$：\n$$\n\\mathbf{J}_{\\mathbf{f}}(\\mathbf{y}) =\n\\begin{bmatrix}\n\\frac{\\partial f_1}{\\partial x}  \\frac{\\partial f_1}{\\partial y}  \\frac{\\partial f_1}{\\partial z} \\\\\n\\frac{\\partial f_2}{\\partial x}  \\frac{\\partial f_2}{\\partial y}  \\frac{\\partial f_2}{\\partial z} \\\\\n\\frac{\\partial f_3}{\\partial x}  \\frac{\\partial f_3}{\\partial y}  \\frac{\\partial f_3}{\\partial z}\n\\end{bmatrix} =\n\\begin{bmatrix}\n-k_1  k_2 z  k_2 y \\\\\nk_1  -k_2 z - 2 k_3 y  -k_2 y \\\\\n0  2 k_3 y  0\n\\end{bmatrix}.\n$$\n\n对于此问题，“稳定积分”的定义如下：如果在所有时间步，所有计算出的浓度都保持非负（即，对所有 $n$，有 $x_n \\ge 0$，$y_n \\ge 0$，$z_n \\ge 0$），并且在每个后向欧拉步中，Newton 求解器都能收敛到残差范数小于一个很小的容差，则该积分被认为是数值稳定的。如果任何浓度在任何时间步变为负值，或者产生了任何非有限值（非数或无穷大），则认为显式欧拉法的运行“失败”。\n\n使用以下固定步长的测试套件，每个案例由结束时间 $T$ 和时间步长 $h$ 指定：\n1. $T = 2\\ \\text{s}$, $h = 1\\ \\text{s}$.\n2. $T = 1\\ \\text{s}$, $h = 0.1\\ \\text{s}$.\n3. $T = 10^{-3}\\ \\text{s}$, $h = 10^{-5}\\ \\text{s}$.\n4. $T = 5\\ \\text{s}$, $h = 5\\ \\text{s}$.\n\n对于每个测试案例，使用共同的初始条件 $\\mathbf{y}(0)$ 和指定的步长 $h$，将两种积分器运行到指定的最终时间 $T$。对于后向欧拉法，请使用带有解析计算雅可比矩阵的 Newton 法，并结合回溯线搜索，以确保试验迭代点的浓度为非负。对残差范数使用 $10^{-12}$ 的收敛容差，每个步骤最多进行 $50$ 次 Newton 迭代。如果在迭代限制内 Newton 法未能收敛或在任何步骤产生非有限值，则认为该案例的后向欧拉积分“不稳定”。\n\n您的程序应生成一行输出，其中包含一个含四个整数的列表，每个整数对应一个测试案例，顺序如上，编码如下：\n- 如果后向欧拉法稳定而显式欧拉法失败，则输出 $2$。\n- 如果两种方法都稳定，则输出 $1$。\n- 如果后向欧拉法不稳定（无论显式欧拉法如何），则输出 $0$。\n\n最终输出必须严格按照方括号内逗号分隔的列表形式打印，例如 $[2,2,1,2]$。所有时间量单位为秒，所有浓度量单位为 $\\text{mol/L}$。此问题不涉及角度。不涉及百分比；如果需要任何小数，请用十进制表示。\n\n该测试套件旨在涵盖以下几个方面：一个“理想”案例，其中小步长使两种方法都稳定；大步长案例，由于刚性问题，显式欧拉法预计会失败，但后向欧拉法保持稳定；以及一个单次大步长隐式积分的边界案例，需要稳健的 Newton 收敛。每个测试案例的答案是如上定义的整数。您的最终程序必须是自包含的、可直接运行的，并且不得需要用户输入或外部文件。确保所有数学运算和变量都得到适当且一致的表示。",
            "solution": "该问题要求实现并比较显式欧拉法和后向欧拉法这两种数值积分方法，以求解 Robertson 系统。Robertson 系统是常微分方程 (ODE) 刚性系统的一个典型例子，在生物医学化学动力学中经常遇到。对问题陈述的验证证实了其科学合理性、完整性和客观性。所有提供的数学公式，包括 ODE 系统、其雅可比矩阵以及数值方法，都是标准且正确的。我们开始进行求解。\n\n该 ODE 系统由 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ 给出，其中 $\\mathbf{y}(t) = [x(t), y(t), z(t)]^T$。向量函数 $\\mathbf{f}$ 的分量为：\n$$\n\\begin{aligned}\nf_1(x,y,z) = -k_1 x + k_2 y z \\\\\nf_2(x,y,z) = k_1 x - k_2 y z - k_3 y^2 \\\\\nf_3(x,y,z) = k_3 y^2\n\\end{aligned}\n$$\n该系统满足初始条件 $\\mathbf{y}(0) = [1, 0, 0]^T$，速率常数为 $k_1 = 0.04$，$k_2 = 10^4$ 和 $k_3 = 3 \\times 10^7$。这些常数量级上的巨大差异引入了刚性，意味着各分量之间存在差异巨大的时间尺度，这对数值求解器构成了重大挑战。\n\n**显式欧拉法**\n\n显式欧拉法（前向欧拉法）是求解 ODE 的最简单数值格式。给定时间 $t_n$ 时的状态 $\\mathbf{y}_n$，下一个时间步 $t_{n+1} = t_n + h$ 的状态近似为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h\\,\\mathbf{f}(\\mathbf{y}_n)\n$$\n该方法的计算成本低廉，因为每步只需对函数 $\\mathbf{f}$ 进行一次求值。然而，其主要缺点是条件稳定性。对于刚性系统，显式欧拉法的稳定性受到最快动力学的限制，要求步长 $h$ 小到不切实际。具体来说，$h$ 与雅可比矩阵 $\\mathbf{J}_{\\mathbf{f}}$ 最大特征值模的乘积必须位于一个小的稳定区域内。对于 Robertson 系统，这意味着需要非常小的 $h$，使得该方法对于长时间积分不切实际。如果任何物种浓度在任何步骤变为负值或计算出非有限值，则认为积分失败，这是违反稳定性条件时常见的结果。\n\n**后向欧拉法和 Newton 法**\n\n后向欧拉法（隐式欧拉法）通过求解以下隐式方程来计算下一个状态 $\\mathbf{y}_{n+1}$：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h\\,\\mathbf{f}(\\mathbf{y}_{n+1})\n$$\n该方法是 A-稳定的，意味着当应用于线性刚性问题时，它对任何步长 $h > 0$ 都是数值稳定的。这一特性使其非常适合刚性系统。然而，由于 $\\mathbf{y}_{n+1}$ 出现在方程的两边，因此在每个时间步都必须求解一个（通常是非线性的）代数方程组。\n\n为了求解 $\\mathbf{y}_{n+1}$，我们将方程重构为一个求根问题。设 $\\mathbf{y}$ 为 $\\mathbf{y}_{n+1}$ 的未知值。我们寻求残差函数 $\\mathbf{R}(\\mathbf{y})$ 的根：\n$$\n\\mathbf{R}(\\mathbf{y}) = \\mathbf{y} - \\mathbf{y}_n - h\\,\\mathbf{f}(\\mathbf{y}) = \\mathbf{0}\n$$\n这个根使用 Newton 法（一种迭代过程）来找到。从一个初始猜测 $\\mathbf{y}^{(0)}$（通常为 $\\mathbf{y}_n$）开始，逐次计算近似值 $\\mathbf{y}^{(k)}$：\n$$\n\\mathbf{y}^{(k+1)} = \\mathbf{y}^{(k)} - [\\mathbf{J}_{\\mathbf{R}}(\\mathbf{y}^{(k)})]^{-1} \\mathbf{R}(\\mathbf{y}^{(k)})\n$$\n其中 $\\mathbf{J}_{\\mathbf{R}}$ 是残差函数 $\\mathbf{R}$ 的雅可比矩阵。该雅可比矩阵推导如下：\n$$\n\\mathbf{J}_{\\mathbf{R}}(\\mathbf{y}) = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{y}} = \\mathbf{I} - h\\,\\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}} = \\mathbf{I} - h\\,\\mathbf{J}_{\\mathbf{f}}(\\mathbf{y})\n$$\n这里，$\\mathbf{I}$ 是 $3 \\times 3$ 的单位矩阵，$\\mathbf{J}_{\\mathbf{f}}$ 是问题陈述中给出的 ODE 系统的解析计算雅可比矩阵。在每次 Newton 迭代中，我们求解线性系统 $\\mathbf{J}_{\\mathbf{R}}(\\mathbf{y}^{(k)}) \\Delta\\mathbf{y}^{(k)} = -\\mathbf{R}(\\mathbf{y}^{(k)})$ 以获得更新步 $\\Delta\\mathbf{y}^{(k)}$。\n\n为了确保稳健的收敛性，尤其是在初始猜测不佳或步长 $h$ 较大时，我们引入了回溯线搜索。计算出 Newton 步 $\\Delta\\mathbf{y}^{(k)}$ 后，下一个迭代点通过 $\\mathbf{y}^{(k+1)} = \\mathbf{y}^{(k)} + \\alpha \\Delta\\mathbf{y}^{(k)}$ 找到，其中步长 $\\alpha \\in (0, 1]$ 从初始值 1 开始减小，直到试验迭代点 $\\mathbf{y}^{(k+1)}$ 满足某些条件。对于此问题，关键条件是所有浓度都为非负，即 $\\mathbf{y}^{(k+1)}$ 的所有分量必须大于或等于 0。如果 Newton 求解器在 50 次迭代内未能收敛到残差范数低于 $10^{-12}$ 的容差，或者线搜索未能找到一个非负的试验迭代点，则认为其失败。\n\n**实现与测试案例分析**\n\n实现包括用于 $\\mathbf{f}(\\mathbf{y})$、$\\mathbf{J}_{\\mathbf{f}}(\\mathbf{y})$ 的独立函数，一个用于后向欧拉步的 Newton 求解器，以及一个主驱动程序来运行每个测试案例的积分。\n\n1.  **案例 1: $T = 2\\ \\text{s}$, $h = 1\\ \\text{s}$**。步长 $h=1$ 对显式欧拉法来说过大，无法保持稳定，因为它严重违反了刚性分量施加的稳定性条件。这将导致振荡和负浓度，使显式方法失败。后向欧拉法是 A-稳定的，将能处理这个大步长，其稳健的 Newton 求解器预计会收敛。因此，预期结果为 $2$。\n2.  **案例 2: $T = 1\\ \\text{s}$, $h = 0.1\\ \\text{s}$**。与第一个案例类似，$h=0.1$ 仍然远大于显式欧拉法的稳定性极限，导致失败。后向欧拉法应保持稳定。预期结果：$2$。\n3.  **案例 3: $T = 10^{-3}\\ \\text{s}$, $h = 10^{-5}\\ \\text{s}$**。在这里，步长 $h=10^{-5}$ 非常小，并且落在显式欧拉法的稳定区域内。因此，显式和后向欧拉法预计都能成功完成积分，在整个过程中得到非负浓度。预期结果：$1$。\n4.  **案例 4: $T = 5\\ \\text{s}$, $h = 5\\ \\text{s}$**。这涉及一个单一的、极大的步长。对于显式欧拉法，更新 $\\mathbf{y}_1 = \\mathbf{y}_0 + h\\,\\mathbf{f}(\\mathbf{y}_0)$ 得出 $[0.8, 0.2, 0]^T$，这是非负的。根据问题对稳定性的严格定义（仅检查在时间步 $t_0, t_1$ 计算出的非负值），此积分被认为是“稳定的”，尽管结果在物理上并不准确。对于后向欧拉法，这个单次大步长对 Newton 求解器是一个重大挑战，但它的设计初衷就是为了在这种条件下收敛。因此，根据问题的标准，两种方法都被认为是稳定的。预期结果：$1$。\n\n程序计算这些结果，并将它们格式化为一个整数列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# language: Python\n# version: 3.12\n# libraries:\n#     name: numpy, version: 1.23.5\n\ndef solve():\n    \"\"\"\n    Solves the Robertson stiff ODE problem by comparing Explicit and\n    Backward Euler methods over a suite of test cases.\n    \"\"\"\n\n    # --- Problem Constants ---\n    K1 = 0.04\n    K2 = 1.0e4\n    K3 = 3.0e7\n\n    # --- ODE System Definition ---\n\n    def robertson_f(y, k1, k2, k3):\n        \"\"\"Computes the right-hand side of the Robertson ODE system.\"\"\"\n        x, y_comp, z = y\n        dydt = np.zeros(3, dtype=np.float64)\n        dydt[0] = -k1 * x + k2 * y_comp * z\n        dydt[1] = k1 * x - k2 * y_comp * z - k3 * y_comp**2\n        dydt[2] = k3 * y_comp**2\n        return dydt\n\n    def robertson_Jf(y, k1, k2, k3):\n        \"\"\"Computes the analytical Jacobian of the Robertson ODE system.\"\"\"\n        x, y_comp, z = y\n        Jf = np.zeros((3, 3), dtype=np.float64)\n        # df1/dx, df1/dy, df1/dz\n        Jf[0, 0] = -k1\n        Jf[0, 1] = k2 * z\n        Jf[0, 2] = k2 * y_comp\n        # df2/dx, df2/dy, df2/dz\n        Jf[1, 0] = k1\n        Jf[1, 1] = -k2 * z - 2 * k3 * y_comp\n        Jf[1, 2] = -k2 * y_comp\n        # df3/dx, df3/dy, df3/dz\n        Jf[2, 0] = 0.0\n        Jf[2, 1] = 2 * k3 * y_comp\n        Jf[2, 2] = 0.0\n        return Jf\n\n    # --- Backward Euler Newton Solver ---\n\n    def solve_be_step(y_n, h, k1, k2, k3, tol=1e-12, max_iter=50):\n        \"\"\"\n        Solves for y_{n+1} in a single backward Euler step using Newton's method\n        with backtracking line search.\n        Finds the root of R(y) = y - y_n - h * f(y) = 0.\n        \"\"\"\n        y_k = np.copy(y_n)\n        \n        for _ in range(max_iter):\n            f_yk = robertson_f(y_k, k1, k2, k3)\n            R = y_k - y_n - h * f_yk\n            \n            if not np.all(np.isfinite(R)):\n                return None, False\n\n            if np.linalg.norm(R)  tol:\n                return y_k, True\n\n            Jf_yk = robertson_Jf(y_k, k1, k2, k3)\n            JR = np.eye(3) - h * Jf_yk\n            \n            try:\n                delta_y = np.linalg.solve(JR, -R)\n            except np.linalg.LinAlgError:\n                return None, False\n\n            if not np.all(np.isfinite(delta_y)):\n                return None, False\n\n            alpha = 1.0\n            line_search_success = False\n            for _ in range(10):  # Max 10 backtracking steps\n                y_trial = y_k + alpha * delta_y\n                if np.all(y_trial = 0):\n                    y_k = y_trial\n                    line_search_success = True\n                    break\n                alpha /= 2.0\n            \n            if not line_search_success:\n                return None, False\n        \n        return None, False\n\n    # --- Integrator Driver ---\n\n    def run_integration(integrator_type, y0, T, h, k1, k2, k3):\n        \"\"\"\n        Integrates the ODE system and returns True for stable integration, False for failure.\n        \"\"\"\n        y = np.copy(y0)\n        num_steps = int(round(T / h))\n\n        if num_steps == 0:\n            return True\n\n        for _ in range(num_steps):\n            if integrator_type == 'ee':\n                if not np.all(np.isfinite(y)): return False\n                dydt = robertson_f(y, k1, k2, k3)\n                if not np.all(np.isfinite(dydt)): return False\n                y_next = y + h * dydt\n                if np.any(y_next  0) or not np.all(np.isfinite(y_next)):\n                    return False\n                y = y_next\n            \n            elif integrator_type == 'be':\n                y_next, converged = solve_be_step(y, h, k1, k2, k3)\n                if not converged:\n                    return False\n                y = y_next\n        \n        return True\n\n    # --- Main Execution Logic ---\n    \n    y0 = np.array([1.0, 0.0, 0.0], dtype=np.float64)\n    \n    test_cases = [\n        (2.0, 1.0),\n        (1.0, 0.1),\n        (1.0e-3, 1.0e-5),\n        (5.0, 5.0)\n    ]\n    \n    results = []\n    for T, h in test_cases:\n        ee_stable = run_integration('ee', y0, T, h, K1, K2, K3)\n        be_stable = run_integration('be', y0, T, h, K1, K2, K3)\n        \n        if not be_stable:\n            result_code = 0\n        elif be_stable and not ee_stable:\n            result_code = 2\n        elif be_stable and ee_stable:\n            result_code = 1\n        else: # Should not be reached\n            result_code = -1 \n            \n        results.append(result_code)\n            \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然向后欧拉法很鲁棒，但其精度仅为一阶。本练习将带您进入更高阶的隐式方法，它们能在不牺牲稳定性的前提下提供更高的精度。您将构建一个Radau IIA方法（一种处理刚性问题的强大工具），并学习如何使用块结构的牛顿迭代法来求解其内部阶段的耦合非线性系统。",
            "id": "3913789",
            "problem": "考虑一个基于质量作用动力学的双物种酶催化生化反应网络，该网络通过游离酶守恒进行了简化。物种为浓度为 $[S]$ 的底物 $S$ 和浓度为 $[C]$ 的酶-底物复合物 $C$。游离酶的浓度为 $[E] = E_{\\text{tot}} - [C]$，其中 $E_{\\text{tot}}$ 是守恒的总酶浓度。反应包括结合反应 $S + E \\xrightarrow{k_1} C$、解离反应 $C \\xrightarrow{k_{-1}} S + E$ 和催化反应 $C \\xrightarrow{k_2} P + E$，其中 $P$ 是产物。控制该系统的常微分方程（ODE）组为\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\n[S]\\\\\n[C]\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n- k_1 [S][E] + k_{-1}[C]\\\\\n\\phantom{-} k_1 [S][E] - (k_{-1} + k_2)[C]\n\\end{bmatrix}, \\quad [E] = E_{\\text{tot}} - [C].\n$$\n假设参数为 $k_1 = 10^{6}\\ \\text{M}^{-1}\\ \\text{s}^{-1}$、$k_{-1} = 10^{3}\\ \\text{s}^{-1}$、$k_2 = 10^{2}\\ \\text{s}^{-1}$、$E_{\\text{tot}} = 10^{-6}\\ \\text{M}$，并且在时间 $t_n = 0\\ \\text{s}$ 时的初始条件为 $[S](0) = 10^{-4}\\ \\text{M}$、$[C](0) = 0\\ \\text{M}$。使用两级 IIA 型 Radau 隐式 Runge–Kutta 方法处理该系统，并分析其数值刚性和非线性求解策略。\n\n您的任务是：\n\n1. 从初值问题定义 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$（其中 $\\mathbf{y} = \\begin{bmatrix}[S][C]\\end{bmatrix}^{\\top}$）和 s 级隐式 Runge–Kutta 方法的核心定义出发，通过确定满足 Radau IIA 族定义属性（包括刚性精度和高达 $2s-1$ 阶的阶条件）的节点位置 $c_i$、系数 $a_{ij}$ 和权重 $b_i$ 来构建两级 Radau IIA 方法。请勿使用任何未从定义属性推导出的捷径公式。\n\n2. 使用您构建的系数，写出在时间层 $t_n + c_1 h$ 和 $t_n + c_2 h$ 上关于级值 $\\mathbf{Y}_1$ 和 $\\mathbf{Y}_2$ 的耦合非线性级方程，其中 $h$ 是以秒为单位的时间步长。将级方程表示为残差形式 $\\mathbf{F}(\\mathbf{Z}) = \\mathbf{0}$，其中 $\\mathbf{Z} = \\begin{bmatrix}\\mathbf{Y}_1 \\\\ \\mathbf{Y}_2\\end{bmatrix} \\in \\mathbb{R}^{4}$ 是两个级向量的堆叠。\n\n3. 从针对方程组的 Newton 方法的基本定义出发，推导一个用于求解级方程的 Newton 迭代过程，其中包括用在当前级迭代值上计算的 $\\mathbf{f}$ 的雅可比矩阵表示的显式 $4 \\times 4$ 分块雅可比结构。清晰地指出单位矩阵的作用以及通过 Runge–Kutta 系数产生的耦合。您的推导应从非线性系统的残差和雅可比矩阵的定义开始，然后进行到每个 Newton 迭代中需求解的线性系统。陈述一个基于残差的欧几里得范数和最大允许迭代次数的收敛准则。如果需要步长策略，请基于基本原理指定一个标准的回溯准则及其参数。\n\n4. 实现从 $t_n$ 到 $t_{n+1} = t_n + h$ 的单步推进，使用两级 Radau IIA 方法和您为级方程设计的 Newton 求解器。使用以下以秒为单位的时间步长 $h$ 测试套件来检查在不同情况下的行为：\n- 理想情况：$h = 10^{-6}\\ \\text{s}$。\n- 中等刚性：$h = 10^{-3}\\ \\text{s}$。\n- 强刚性：$h = 10^{-1}\\ \\text{s}$。\n- 极大步长：$h = 10^{1}\\ \\text{s}$。\n\n对于每个 $h$，使用初始猜测 $\\mathbf{Y}_1^{(0)} = \\mathbf{y}_n$ 和 $\\mathbf{Y}_2^{(0)} = \\mathbf{y}_n$ 开始 Newton 迭代。使用收敛容差，要求 $\\lVert \\mathbf{F}(\\mathbf{Z}^{(k)}) \\rVert_2 \\le 10^{-12}$，并且最多进行 $50$ 次 Newton 迭代。如果使用回溯法，请对残差范数的平方采用一个具有标准 Armijo 型参数选择的充分下降条件。\n\n您的程序必须为测试套件中的每个 $h$ 计算求解级方程至规定容差所需的 Newton 迭代次数。如果求解器在最大迭代次数内未能收敛，则对该情况报告整数 $-1$。无需报告任何其他量。输出为单行，包含一个用方括号括起来的逗号分隔列表，例如 $[n_1,n_2,n_3,n_4]$，其中每个 $n_i$ 是对应 $h$ 的整数 Newton 迭代次数。\n\n在您的推导中，所有物理量必须遵循其给定单位。不出现角度。不出现百分比。程序必须是完全自包含的，且不得要求任何用户输入。",
            "solution": "该问题陈述已通过验证，被认为是具有科学依据、良定、客观和完整的。它是在刚性常微分方程（ODE）数值解领域一个标准但重要的练习，与生物医学系统的建模高度相关。各项任务逻辑结构清晰，所有需要的数据均已提供。因此，我们可以进行完整的解答。\n\n该问题要求使用一种特定的隐式 Runge-Kutta (IRK) 方法，对一个刚性生化 ODE 系统从时间 $t_n=0$ 到 $t_{n+1} = t_n+h$ 进行单步积分。这涉及三个主要部分，将按顺序解决：从基本原理推导 IRK 方法的系数，构建用于求解内部级值的非线性方程组，以及推导和实现一个用于求解该系统的 Newton-Raphson 求解器。\n\n设状态向量为 $\\mathbf{y}(t) = \\begin{bmatrix} [S](t) \\\\ [C](t) \\end{bmatrix} \\in \\mathbb{R}^2$。控制该系统的 ODE 方程组为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$，其中函数 $\\mathbf{f}: \\mathbb{R}^2 \\to \\mathbb{R}^2$ 由下式给出\n$$\n\\mathbf{f}(\\mathbf{y}) = \\begin{bmatrix} -k_1 y_1 (E_{\\text{tot}} - y_2) + k_{-1} y_2 \\\\ k_1 y_1 (E_{\\text{tot}} - y_2) - (k_{-1} + k_2) y_2 \\end{bmatrix},\n$$\n其中 $y_1 = [S]$ 且 $y_2 = [C]$。给定参数为 $k_1 = 10^6 \\ \\text{M}^{-1}\\text{s}^{-1}$、$k_{-1} = 10^3 \\ \\text{s}^{-1}$、$k_2 = 10^2 \\ \\text{s}^{-1}$ 和 $E_{\\text{tot}} = 10^{-6} \\ \\text{M}$。在 $t_n=0 \\ \\text{s}$ 时的初始条件为 $\\mathbf{y}_n = \\mathbf{y}(0) = \\begin{bmatrix} 10^{-4} \\\\ 0 \\end{bmatrix} \\ \\text{M}$。\n\n**1. 两级 Radau IIA 方法的构建**\n\n一个 s 级隐式 Runge-Kutta 方法由其 Butcher 盘 $(\\mathbf{c}, \\mathbf{A}, \\mathbf{b})$ 定义。级值 $\\mathbf{Y}_i \\in \\mathbb{R}^2$ 是在中间时间点 $t_n + c_i h$ 处解的近似值，由以下方程组定义：\n$$\n\\mathbf{Y}_i = \\mathbf{y}_n + h \\sum_{j=1}^s a_{ij} \\mathbf{f}(\\mathbf{Y}_j), \\quad \\text{for } i=1, \\dots, s.\n$$\n下一个时间步的解由下式给出：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^s b_i \\mathbf{f}(\\mathbf{Y}_i).\n$$\nRadau IIA 方法是一类特殊的配置法。对于 $s=2$，其定义属性如下：\n1. 该方法是一种配置法，其中节点 $c_i$ 是从移位的勒让德多项式派生出的多项式的根。对于 Radau IIA，节点是多项式 $P_s'(x)$ 的根，其中 $P_s(x) = x^{s-1}(x-1)^s$。对于 $s=2$，此为 $\\frac{d}{dx}[x(x-1)^2] = (x-1)^2 + 2x(x-1) = (x-1)(x-1+2x) = (x-1)(3x-1)$。定义节点的根为 $c_1=1/3$ 和 $c_2=1$。\n2. 系数 $a_{ij}$ 由 $a_{ij} = \\int_0^{c_i} L_j(\\tau) d\\tau$ 给出，其中 $L_j(\\tau)$ 是节点 $\\{c_1, c_2\\}$ 的拉格朗日基多项式。\n    拉格朗日多项式为：\n    $L_1(\\tau) = \\frac{\\tau - c_2}{c_1 - c_2} = \\frac{\\tau - 1}{1/3 - 1} = -\\frac{3}{2}(\\tau-1)$。\n    $L_2(\\tau) = \\frac{\\tau - c_1}{c_2 - c_1} = \\frac{\\tau - 1/3}{1 - 1/3} = \\frac{3}{2}(\\tau-1/3)$。\n    系数 $a_{ij}$ 通过积分计算得出：\n    $a_{11} = \\int_0^{1/3} L_1(\\tau) d\\tau = \\int_0^{1/3} -\\frac{3}{2}(\\tau-1) d\\tau = -\\frac{3}{2}[\\frac{\\tau^2}{2} - \\tau]_0^{1/3} = -\\frac{3}{2}(\\frac{1}{18} - \\frac{1}{3}) = \\frac{5}{12}$。\n    $a_{12} = \\int_0^{1/3} L_2(\\tau) d\\tau = \\int_0^{1/3} \\frac{3}{2}(\\tau-1/3) d\\tau = \\frac{3}{2}[\\frac{\\tau^2}{2} - \\frac{\\tau}{3}]_0^{1/3} = \\frac{3}{2}(\\frac{1}{18} - \\frac{1}{9}) = -\\frac{1}{12}$。\n    $a_{21} = \\int_0^{1} L_1(\\tau) d\\tau = \\int_0^{1} -\\frac{3}{2}(\\tau-1) d\\tau = -\\frac{3}{2}[\\frac{\\tau^2}{2} - \\tau]_0^{1} = -\\frac{3}{2}(\\frac{1}{2} - 1) = \\frac{3}{4}$。\n    $a_{22} = \\int_0^{1} L_2(\\tau) d\\tau = \\int_0^{1} \\frac{3}{2}(\\tau-1/3) d\\tau = \\frac{3}{2}[\\frac{\\tau^2}{2} - \\frac{\\tau}{3}]_0^{1} = \\frac{3}{2}(\\frac{1}{2} - \\frac{1}{3}) = \\frac{1}{4}$。\n3. 权重 $b_i$ 由 $b_i = \\int_0^1 L_i(\\tau) d\\tau$ 给出。由于 $c_2=1$，我们立即得到 $b_i = a_{2i}$。\n    $b_1 = a_{21} = 3/4$。\n    $b_2 = a_{22} = 1/4$。\n该方法的阶为 $p = 2s-1 = 3$。得到的 Butcher 盘为：\n$$\n\\begin{array}{c|cc}\n1/3  5/12  -1/12 \\\\\n1  3/4  1/4 \\\\\n\\hline\n  3/4  1/4\n\\end{array}\n$$\n该方法是刚性精确的，因为 $c_s = c_2 = 1$ 并且对于 $j=1, 2$ 有 $a_{sj} = b_j$。这意味着 $\\mathbf{y}_{n+1} = \\mathbf{Y}_s = \\mathbf{Y}_2$，这在计算上是有利的。\n\n**2. 级值的非线性系统**\n\n使用推导出的系数，关于 $\\mathbf{Y}_1, \\mathbf{Y}_2 \\in \\mathbb{R}^2$ 的级方程为：\n$$\n\\mathbf{Y}_1 = \\mathbf{y}_n + h \\left( \\frac{5}{12} \\mathbf{f}(\\mathbf{Y}_1) - \\frac{1}{12} \\mathbf{f}(\\mathbf{Y}_2) \\right)\n$$\n$$\n\\mathbf{Y}_2 = \\mathbf{y}_n + h \\left( \\frac{3}{4} \\mathbf{f}(\\mathbf{Y}_1) + \\frac{1}{4} \\mathbf{f}(\\mathbf{Y}_2) \\right)\n$$\n这是一个包含 $2 \\times 2 = 4$ 个非线性代数方程的耦合系统。为了使用 Newton 方法求解，我们将其表示为残差形式 $\\mathbf{F}(\\mathbf{Z}) = \\mathbf{0}$。设 $\\mathbf{Z} \\in \\mathbb{R}^4$ 是级值的堆叠向量，$\\mathbf{Z} = \\begin{bmatrix} \\mathbf{Y}_1 \\\\ \\mathbf{Y}_2 \\end{bmatrix}$。残差函数 $\\mathbf{F}: \\mathbb{R}^4 \\to \\mathbb{R}^4$ 为：\n$$\n\\mathbf{F}(\\mathbf{Z}) =\n\\begin{bmatrix}\n\\mathbf{F}_1(\\mathbf{Y}_1, \\mathbf{Y}_2) \\\\\n\\mathbf{F}_2(\\mathbf{Y}_1, \\mathbf{Y}_2)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{Y}_1 - \\mathbf{y}_n - h \\left( \\frac{5}{12} \\mathbf{f}(\\mathbf{Y}_1) - \\frac{1}{12} \\mathbf{f}(\\mathbf{Y}_2) \\right) \\\\\n\\mathbf{Y}_2 - \\mathbf{y}_n - h \\left( \\frac{3}{4} \\mathbf{f}(\\mathbf{Y}_1) + \\frac{1}{4} \\mathbf{f}(\\mathbf{Y}_2) \\right)\n\\end{bmatrix}\n= \\mathbf{0}\n$$\n\n**3. 级方程的 Newton 方法**\n\n用于求解系统 $\\mathbf{F}(\\mathbf{Z}) = \\mathbf{0}$ 的 Newton 方法是一个迭代过程。从初始猜测 $\\mathbf{Z}^{(0)}$ 开始，每次迭代通过求解一个线性系统得到更新步长 $\\Delta \\mathbf{Z}^{(k)}$ 来计算一个新的近似值 $\\mathbf{Z}^{(k+1)}$：\n$$\n\\mathbf{J}_{\\mathbf{F}}(\\mathbf{Z}^{(k)}) \\Delta \\mathbf{Z}^{(k)} = -\\mathbf{F}(\\mathbf{Z}^{(k)})\n$$\n$$\n\\mathbf{Z}^{(k+1)} = \\mathbf{Z}^{(k)} + \\alpha_k \\Delta \\mathbf{Z}^{(k)}\n$$\n其中 $\\mathbf{J}_{\\mathbf{F}}$ 是残差函数 $\\mathbf{F}$ 的 $4 \\times 4$ 雅可比矩阵，$\\alpha_k \\in (0, 1]$ 是由线搜索算法确定的步长。\n\n雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}$ 具有一个 $2 \\times 2$ 的分块结构，其中每个分块都是一个 $2 \\times 2$ 的矩阵：\n$$\n\\mathbf{J}_{\\mathbf{F}}(\\mathbf{Z}) = \\begin{bmatrix} \\frac{\\partial \\mathbf{F}_1}{\\partial \\mathbf{Y}_1}  \\frac{\\partial \\mathbf{F}_1}{\\partial \\mathbf{Y}_2} \\\\ \\frac{\\partial \\mathbf{F}_2}{\\partial \\mathbf{Y}_1}  \\frac{\\partial \\mathbf{F}_2}{\\partial \\mathbf{Y}_2} \\end{bmatrix}\n$$\n设 $\\mathbf{J}_{\\mathbf{f}}(\\mathbf{y})$ 为 ODE 函数 $\\mathbf{f}$ 的 $2 \\times 2$ 雅可比矩阵。$\\mathbf{J}_{\\mathbf{F}}$ 的分块是：\n$\\frac{\\partial \\mathbf{F}_1}{\\partial \\mathbf{Y}_1} = \\mathbf{I} - h a_{11} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_1) = \\mathbf{I} - h \\frac{5}{12} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_1)$\n$\\frac{\\partial \\mathbf{F}_1}{\\partial \\mathbf{Y}_2} = -h a_{12} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_2) = h \\frac{1}{12} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_2)$\n$\\frac{\\partial \\mathbf{F}_2}{\\partial \\mathbf{Y}_1} = -h a_{21} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_1) = -h \\frac{3}{4} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_1)$\n$\\frac{\\partial \\mathbf{F}_2}{\\partial \\mathbf{Y}_2} = \\mathbf{I} - h a_{22} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_2) = \\mathbf{I} - h \\frac{1}{4} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_2)$\n其中 $\\mathbf{I}$ 是 $2 \\times 2$ 的单位矩阵。\n\nODE 函数 $\\mathbf{f}(\\mathbf{y})$ 关于 $\\mathbf{y} = [y_1, y_2]^T$ 的雅可比矩阵是：\n$$\n\\mathbf{J}_{\\mathbf{f}}(\\mathbf{y}) =\n\\begin{bmatrix}\n\\frac{\\partial f_1}{\\partial y_1}  \\frac{\\partial f_1}{\\partial y_2} \\\\\n\\frac{\\partial f_2}{\\partial y_1}  \\frac{\\partial f_2}{\\partial y_2}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-k_1(E_{\\text{tot}} - y_2)  k_1 y_1 + k_{-1} \\\\\nk_1(E_{\\text{tot}} - y_2)  -k_1 y_1 - (k_{-1} + k_2)\n\\end{bmatrix}.\n$$\n在每个 Newton 步骤 $k$ 中，$\\mathbf{J}_{\\mathbf{f}}$ 在当前的级值迭代 $\\mathbf{Y}_1^{(k)}$ 和 $\\mathbf{Y}_2^{(k)}$ 处被求值，以组装完整的 $4 \\times 4$ 矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{Z}^{(k)})$。\n\n迭代持续进行，直到满足收敛准则 $\\lVert \\mathbf{F}(\\mathbf{Z}^{(k)}) \\rVert_2 \\le 10^{-12}$，或直到达到最大迭代次数 $50$ 次。\n为了确保稳健的收敛性，特别是对于大步长 $h$，我们对步长 $\\alpha_k$ 采用回溯线搜索。我们寻求满足 Armijo-Goldstein 充分下降条件的最大 $\\alpha_k \\in \\{1, 1/2, 1/4, \\dots\\}$：\n$$\n\\left\\lVert \\mathbf{F}\\left(\\mathbf{Z}^{(k)} + \\alpha_k \\Delta \\mathbf{Z}^{(k)}\\right) \\right\\rVert_2^2 \\le \\left(1 - 2\\sigma\\alpha_k\\right) \\left\\lVert \\mathbf{F}\\left(\\mathbf{Z}^{(k)}\\right) \\right\\rVert_2^2\n$$\n控制参数 $\\sigma$ 的一个标准选择是 $\\sigma = 10^{-4}$。\n\n**4. 实现与数值测试**\n\n从 $t_n=0$ 开始的单步算法如下：\n1. 初始化参数和初始状态 $\\mathbf{y}_n = [10^{-4}, 0]^T$。\n2. 对于测试套件中的每个时间步长 $h \\in \\{10^{-6}, 10^{-3}, 10^{-1}, 10^{1}\\}$ 秒：\n    a. 用猜测值 $\\mathbf{Z}^{(0)} = [\\mathbf{y}_n^T, \\mathbf{y}_n^T]^T$ 和迭代次数 `iter = 0` 来初始化 Newton 求解器。\n    b. 对于 $k = 0, \\dots, 49$ 进行循环：\n        i.   计算残差 $\\mathbf{F}(\\mathbf{Z}^{(k)})$。\n        ii.  检查是否 $\\lVert \\mathbf{F}(\\mathbf{Z}^{(k)}) \\rVert_2 \\le 10^{-12}$。如果为真，存储 `iter` 并跳出循环。\n        iii. 通过在 $\\mathbf{Y}_1^{(k)}$ 和 $\\mathbf{Y}_2^{(k)}$ 处计算 $\\mathbf{J}_{\\mathbf{f}}$ 来构建雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{Z}^{(k)})$。\n        iv.  求解线性系统 $\\mathbf{J}_{\\mathbf{F}} \\Delta \\mathbf{Z} = -\\mathbf{F}$ 以获得 Newton 步长 $\\Delta \\mathbf{Z}$。\n        v.   执行回溯线搜索以找到可接受的步长 $\\alpha_k$。\n        vi.  更新解：$\\mathbf{Z}^{(k+1)} = \\mathbf{Z}^{(k)} + \\alpha_k \\Delta \\mathbf{Z}$。\n        vii. 增加 `iter`。\n    c. 如果循环完成但未收敛，则记录 $-1$。\n3. 最终输出是迭代次数的列表。以下程序实现了此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the number of Newton iterations required for a single step of the\n    2-stage Radau IIA method applied to a stiff biochemical system.\n    \"\"\"\n    # 1. Define model parameters and initial conditions\n    k1 = 1.0e6  # M^-1 s^-1\n    k_1 = 1.0e3  # s^-1\n    k2 = 1.0e2  # s^-1\n    Etot = 1.0e-6  # M\n    y_n = np.array([1.0e-4, 0.0])  # [S], [C] at t_n=0\n\n    # 2. Define the ODE system function f(y) and its Jacobian J_f(y)\n    def f(y):\n        \"\"\"ODE function dy/dt = f(y)\"\"\"\n        s, c = y[0], y[1]\n        e = Etot - c\n        ds_dt = -k1 * s * e + k_1 * c\n        dc_dt = k1 * s * e - (k_1 + k2) * c\n        return np.array([ds_dt, dc_dt])\n\n    def J_f(y):\n        \"\"\"Jacobian of f(y)\"\"\"\n        s, c = y[0], y[1]\n        # df1/ds, df1/dc\n        # df2/ds, df2/dc\n        J = np.array([\n            [-k1 * (Etot - c), k1 * s + k_1],\n            [k1 * (Etot - c), -k1 * s - (k_1 + k2)]\n        ])\n        return J\n\n    # 3. Radau IIA (s=2) method coefficients\n    a11, a12 = 5.0 / 12.0, -1.0 / 12.0\n    a21, a22 = 3.0 / 4.0, 1.0 / 4.0\n\n    # 4. Define test cases for the step size h\n    test_cases_h = [1.0e-6, 1.0e-3, 1.0e-1, 1.0e1]\n\n    # 5. Newton solver parameters\n    tol = 1.0e-12\n    max_iter = 50\n    sigma = 1.0e-4  # Armijo condition parameter\n\n    results = []\n\n    # 6. Loop over each test case\n    for h in test_cases_h:\n        # Initial guess for stage values Y1, Y2\n        Z = np.concatenate([y_n, y_n])\n        \n        num_iter = -1 # Default to failure\n\n        for k in range(max_iter):\n            Y1, Y2 = Z[0:2], Z[2:4]\n\n            # Calculate residual F(Z)\n            f_Y1 = f(Y1)\n            f_Y2 = f(Y2)\n            F1 = Y1 - y_n - h * (a11 * f_Y1 + a12 * f_Y2)\n            F2 = Y2 - y_n - h * (a21 * f_Y1 + a22 * f_Y2)\n            F_Z = np.concatenate([F1, F2])\n\n            # Check for convergence\n            res_norm_sq = np.dot(F_Z, F_Z)\n            if np.sqrt(res_norm_sq)  tol:\n                num_iter = k\n                break\n\n            # Assemble the 4x4 Jacobian J_F(Z)\n            J_f_Y1 = J_f(Y1)\n            J_f_Y2 = J_f(Y2)\n            I2 = np.identity(2)\n\n            J_F = np.block([\n                [I2 - h * a11 * J_f_Y1, -h * a12 * J_f_Y2],\n                [-h * a21 * J_f_Y1, I2 - h * a22 * J_f_Y2]\n            ])\n\n            # Solve the linear system for Newton step dZ\n            try:\n                dZ = np.linalg.solve(J_F, -F_Z)\n            except np.linalg.LinAlgError:\n                # Jacobian is singular, can't proceed\n                break\n\n            # Backtracking line search\n            alpha = 1.0\n            while alpha  1e-8:\n                Z_new = Z + alpha * dZ\n                Y1_new, Y2_new = Z_new[0:2], Z_new[2:4]\n                f_Y1_new, f_Y2_new = f(Y1_new), f(Y2_new)\n                F1_new = Y1_new - y_n - h * (a11 * f_Y1_new + a12 * f_Y2_new)\n                F2_new = Y2_new - y_n - h * (a21 * f_Y1_new + a22 * f_Y2_new)\n                F_new = np.concatenate([F1_new, F2_new])\n                \n                res_norm_new_sq = np.dot(F_new, F_new)\n                \n                # Check Armijo condition\n                if res_norm_new_sq = (1 - 2 * sigma * alpha) * res_norm_sq:\n                    Z = Z_new\n                    break\n                \n                alpha /= 2.0\n            else:\n                # Line search failed to find a step\n                break\n\n        # After Newton loop, if num_iter is still -1, it means we hit max_iter\n        if num_iter == -1 and k == max_iter - 1:\n            # Check final residual if loop terminated\n            Y1, Y2 = Z[0:2], Z[2:4]\n            f_Y1, f_Y2 = f(Y1), f(Y2)\n            F1 = Y1 - y_n - h * (a11 * f_Y1 + a12 * f_Y2)\n            F2 = Y2 - y_n - h * (a21 * f_Y1 + a22 * f_Y2)\n            F_Z = np.concatenate([F1, F2])\n            if np.linalg.norm(F_Z)  tol:\n                num_iter = k + 1\n        \n        results.append(num_iter)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}