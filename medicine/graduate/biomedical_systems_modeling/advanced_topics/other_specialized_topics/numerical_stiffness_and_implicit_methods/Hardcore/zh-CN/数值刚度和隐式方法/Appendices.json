{
    "hands_on_practices": [
        {
            "introduction": "理解刚性问题的第一步是能够量化它。通过分析一个系统的雅可比矩阵，我们可以揭示其固有的时间尺度，而其特征值则决定了显式数值方法的稳定性边界。这项练习 () 将指导您分析一个经典的刚性生化反应模型，通过计算雅可比矩阵的特征值，具体地确定显式欧拉法所允许的最大稳定时间步长，从而将刚性的抽象概念转化为一个切实的挑战。",
            "id": "3913778",
            "problem": "考虑用于生物医学系统建模中表示快慢生化反应网络的三物种 Robertson 动力学模型。令状态向量为 $\\mathbf{y} = [y_1, y_2, y_3]^\\top$，反应速率由质量作用动力学控制，速率常数为 $k_1$、$k_2$ 和 $k_3$。其控制常微分方程 (ODE) 为\n$$\n\\frac{dy_1}{dt} = -k_1 y_1 + k_3 y_2 y_3,\\quad\n\\frac{dy_2}{dt} = k_1 y_1 - k_2 y_2^2 - k_3 y_2 y_3,\\quad\n\\frac{dy_3}{dt} = k_2 y_2^2.\n$$\n在一个固定的代表性状态 $\\mathbf{y}$，假设动力学的局部线性化由下式给出\n$$\n\\frac{d\\mathbf{y}}{dt} \\approx \\mathbf{J}(\\mathbf{y})\\,\\mathbf{y},\n$$\n其中 $\\mathbf{J}(\\mathbf{y})$ 是向量场关于 $\\mathbf{y}$ 的偏导数构成的雅可比矩阵。推导并实现一个计算 $\\mathbf{J}(\\mathbf{y})$ 特征值的方法，并基于线性稳定性分析，用这些特征值来估计显式前向欧拉法的最大稳定时间步长。\n\n使用以下基本依据：\n- 质量作用动力学，将反应速率定义为物种浓度的多项式函数。\n- 向量场 $\\mathbf{f}(\\mathbf{y})$ 的雅可比矩阵定义为 $\\mathbf{J}_{ij} = \\frac{\\partial f_i}{\\partial y_j}$。\n- 应用于线性测试方程 $\\frac{dz}{dt} = \\lambda z$ 的前向欧拉法的线性稳定性，其稳定性要求 $\\lvert 1 + h\\lambda \\rvert \\le 1$，其中 $h$ 是时间步长，$\\lambda$ 是雅可比矩阵的一个特征值。\n\n任务：\n1. 从 ODE 和质量作用动力学出发，用 $k_1$、$k_2$、$k_3$ 以及 $\\mathbf{y}$ 的分量显式地写出雅可比矩阵 $\\mathbf{J}(\\mathbf{y})$。不要使用任何快捷公式；从第一性原理推导每个偏导数。\n2. 对于给定的状态 $\\mathbf{y}$ 和参数 $(k_1, k_2, k_3)$，计算 $\\mathbf{J}(\\mathbf{y})$ 的特征值 $\\{\\lambda_i\\}$。\n3. 使用前向欧拉法的绝对稳定性条件 $\\lvert 1 + h\\lambda \\rvert \\le 1$，对于每个具有负实部的特征值，通过求解 $h \\ge 0$ 的等式条件来确定稳定性边界上的临界步长 $h_i$。然后，选择同时满足所有特征值条件的全局最大稳定时间步长 $h_{\\max}$。\n4. 所有最终步长以秒为单位表示。\n\n对于稳定性边界的计算，您必须通过代数方法对 $h$ 精确求解不等式 $\\lvert 1 + h\\lambda \\rvert \\le 1$，而不假设特征值为纯实数。您的结果必须普遍适用于任何具有负实部的复数特征值 $\\lambda$。\n\n测试套件：\n使用基本参数值 $k_1 = 0.04\\,\\mathrm{s}^{-1}$，$k_2 = 3\\times 10^7\\,\\mathrm{s}^{-1}$ (每平方浓度单位)，以及 $k_3 = 1\\times 10^4\\,\\mathrm{s}^{-1}$，除非测试用例另有规定。所选状态满足 $y_1 + y_2 + y_3 = 1$。\n\n- 测试用例 1：$\\mathbf{y} = [1.0, 0.0, 0.0]$，$k_1 = 0.04$，$k_2 = 3\\times 10^7$，$k_3 = 1\\times 10^4$。\n- 测试用例 2：$\\mathbf{y} = [0.999, 1\\times 10^{-4}, 9\\times 10^{-4}]$，$k_1 = 0.04$，$k_2 = 3\\times 10^7$，$k_3 = 1\\times 10^4$。\n- 测试用例 3：$\\mathbf{y} = [0.9, 5\\times 10^{-3}, 9.5\\times 10^{-2}]$，$k_1 = 0.04$，$k_2 = 3\\times 10^7$，$k_3 = 1\\times 10^4$。\n- 测试用例 4：$\\mathbf{y} = [0.5, 1\\times 10^{-2}, 4.9\\times 10^{-1}]$，$k_1 = 0.04$，$k_2 = 3\\times 10^7$，$k_3 = 1\\times 10^4$。\n- 测试用例 5：$\\mathbf{y} = [0.9, 5\\times 10^{-3}, 9.5\\times 10^{-2}]$，$k_1 = 0.04$，$k_2 = 3\\times 10^6$，$k_3 = 1\\times 10^4$。\n- 测试用例 6：$\\mathbf{y} = [0.999, 1\\times 10^{-4}, 9\\times 10^{-4}]$，$k_1 = 0.04$，$k_2 = 3\\times 10^7$，$k_3 = 1\\times 10^5$。\n\n您的程序应针对每个测试用例，根据指定状态下的雅可比矩阵特征值，计算出以秒为单位的最大前向欧拉时间步长 $h_{\\max}$。最终输出必须是单行文本，包含六个结果，形式为方括号内的逗号分隔列表，例如 `[h1,h2,h3,h4,h5,h6]`，其中每个 $h_i$ 都以秒为单位。",
            "solution": "当前问题要求分析将前向欧拉法应用于 Robertson 动力学模型时的数值稳定性，该模型是化学和生物医学建模中刚性系统的一个典范例子。主要任务是推导系统的雅可比矩阵，利用其特征值确定前向欧拉法的绝对稳定域，并为几个测试用例计算最大允许时间步长 $h_{\\max}$。\n\n控制常微分方程 (ODE) 系统由向量场 $\\mathbf{f}(\\mathbf{y}) = [f_1(\\mathbf{y}), f_2(\\mathbf{y}), f_3(\\mathbf{y})]^\\top$ 给出，其中 $\\mathbf{y} = [y_1, y_2, y_3]^\\top$ 是物种浓度的状态向量。向量场的分量为：\n$$\n\\frac{dy_1}{dt} = f_1(\\mathbf{y}) = -k_1 y_1 + k_3 y_2 y_3\n$$\n$$\n\\frac{dy_2}{dt} = f_2(\\mathbf{y}) = k_1 y_1 - k_2 y_2^2 - k_3 y_2 y_3\n$$\n$$\n\\frac{dy_3}{dt} = f_3(\\mathbf{y}) = k_2 y_2^2\n$$\n\n该系统的一个基本性质是总浓度守恒。将这三个方程相加可得：\n$$\n\\frac{d(y_1 + y_2 + y_3)}{dt} = (-k_1 y_1 + k_3 y_2 y_3) + (k_1 y_1 - k_2 y_2^2 - k_3 y_2 y_3) + (k_2 y_2^2) = 0\n$$\n这意味着 $y_1 + y_2 + y_3$ 是一个运动不变量。这一性质对系统的雅可比矩阵有直接影响，下文将对此进行说明。\n\n**步骤 1：雅可比矩阵的推导**\n\n数值方法在状态 $\\mathbf{y}$ 的稳定性由在该状态下求值的雅可比矩阵 $\\mathbf{J}(\\mathbf{y})$ 的特征值决定。雅可比矩阵由其元素 $\\mathbf{J}_{ij} = \\frac{\\partial f_i}{\\partial y_j}$ 定义。我们从第一性原理推导每个元素。\n\n$f_1 = -k_1 y_1 + k_3 y_2 y_3$ 的偏导数是：\n- $\\mathbf{J}_{11} = \\frac{\\partial f_1}{\\partial y_1} = -k_1$\n- $\\mathbf{J}_{12} = \\frac{\\partial f_1}{\\partial y_2} = k_3 y_3$\n- $\\mathbf{J}_{13} = \\frac{\\partial f_1}{\\partial y_3} = k_3 y_2$\n\n$f_2 = k_1 y_1 - k_2 y_2^2 - k_3 y_2 y_3$ 的偏导数是：\n- $\\mathbf{J}_{21} = \\frac{\\partial f_2}{\\partial y_1} = k_1$\n- $\\mathbf{J}_{22} = \\frac{\\partial f_2}{\\partial y_2} = -2k_2 y_2 - k_3 y_3$\n- $\\mathbf{J}_{23} = \\frac{\\partial f_2}{\\partial y_3} = -k_3 y_2$\n\n$f_3 = k_2 y_2^2$ 的偏导数是：\n- $\\mathbf{J}_{31} = \\frac{\\partial f_3}{\\partial y_1} = 0$\n- $\\mathbf{J}_{32} = \\frac{\\partial f_3}{\\partial y_2} = 2k_2 y_2$\n- $\\mathbf{J}_{33} = \\frac{\\partial f_3}{\\partial y_3} = 0$\n\n将这些元素组合起来，雅可比矩阵为：\n$$\n\\mathbf{J}(\\mathbf{y}) = \\begin{pmatrix}\n-k_1 & k_3 y_3 & k_3 y_2 \\\\\nk_1 & -2k_2 y_2 - k_3 y_3 & -k_3 y_2 \\\\\n0 & 2k_2 y_2 & 0\n\\end{pmatrix}\n$$\n守恒律 $y_1+y_2+y_3=\\text{常数}$ 意味着向量 $\\mathbf{v} = [1, 1, 1]^\\top$ 是 $\\mathbf{J}$ 的一个左特征向量，其特征值为 $0$。这可以通过对 $\\mathbf{J}$ 的各列求和来验证：\n$$\n\\sum_{i=1}^3 \\mathbf{J}_{i1} = -k_1 + k_1 + 0 = 0\n$$\n$$\n\\sum_{i=1}^3 \\mathbf{J}_{i2} = k_3 y_3 + (-2k_2 y_2 - k_3 y_3) + 2k_2 y_2 = 0\n$$\n$$\n\\sum_{i=1}^3 \\mathbf{J}_{i3} = k_3 y_2 - k_3 y_2 + 0 = 0\n$$\n由于每一列的和都为零，显然有 $[1, 1, 1]\\mathbf{J} = [0, 0, 0]$。这证实了 $\\lambda=0$ 始终是 $\\mathbf{J}$ 的一个特征值。\n\n**步骤 2：最大稳定时间步长的推导**\n\n将前向欧拉法应用于线性测试方程 $\\frac{dz}{dt} = \\lambda z$，得到递推关系 $z_{n+1} = z_n + h\\lambda z_n = (1+h\\lambda)z_n$。为使该方法稳定，放大因子的模不得超过 1，即 $|1+h\\lambda| \\le 1$。我们必须找到满足雅可比矩阵 $\\mathbf{J}$ 的所有特征值 $\\lambda$ 的最大步长 $h \\ge 0$。\n\n设特征值 $\\lambda$ 为复数，$\\lambda = a + ib$，其中 $a = \\operatorname{Re}(\\lambda)$，$b = \\operatorname{Im}(\\lambda)$。对于动态稳定的模式，必须有 $a < 0$。问题正确地指明了只考虑具有负实部的特征值。\n\n稳定性条件是：\n$$\n|1 + h(a+ib)| \\le 1\n$$\n$$\n|(1+ha) + i(hb)| \\le 1\n$$\n对模取平方，我们得到：\n$$\n(1+ha)^2 + (hb)^2 \\le 1\n$$\n$$\n1 + 2ha + h^2 a^2 + h^2 b^2 \\le 1\n$$\n$$\n2ha + h^2(a^2 + b^2) \\le 0\n$$\n由于我们寻求的是非平凡步长 $h > 0$，我们可以除以 $h$：\n$$\n2a + h(a^2 + b^2) \\le 0\n$$\n$$\nh(a^2 + b^2) \\le -2a\n$$\n项 $a^2 + b^2$ 是特征值的模的平方，即 $|\\lambda|^2$。由于 $a < 0$，右侧的 $-2a$ 是正数。我们可以除以 $|\\lambda|^2$（假设 $\\lambda \\ne 0$，这一点由 $a < 0$ 保证）：\n$$\nh \\le \\frac{-2a}{a^2+b^2} = \\frac{-2\\operatorname{Re}(\\lambda)}{|\\lambda|^2}\n$$\n这个不等式为每个具有负实部的特征值 $\\lambda_i$ 提供了时间步长 $h_i$ 的上限。为确保整个系统的稳定性，时间步长 $h$ 必须同时满足所有这些特征值的条件。因此，全局最大稳定时间步长 $h_{\\max}$ 是这些单个上界的最小值：\n$$\nh_{\\max} = \\min_{i, \\text{ s.t. } \\operatorname{Re}(\\lambda_i) < 0} \\left( \\frac{-2\\operatorname{Re}(\\lambda_i)}{|\\lambda_i|^2} \\right)\n$$\n特征值 $\\lambda = 0$ 导致条件 $|1+0| \\le 1$，该条件始终成立，因此对 $h$ 没有施加任何约束。\n\n**步骤 3：算法实现**\n\n对于每个测试用例，求解过程如下：\n1.  将状态向量 $\\mathbf{y} = [y_1, y_2, y_3]^\\top$ 和速率常数 $\\mathbf{k} = [k_1, k_2, k_3]^\\top$ 的数值代入雅可比矩阵 $\\mathbf{J}(\\mathbf{y})$ 的解析表达式。\n2.  计算得到的数值矩阵 $\\mathbf{J}$ 的特征值 $\\{\\lambda_i\\}$。\n3.  对于每个满足 $\\operatorname{Re}(\\lambda_i) < 0$ 的特征值 $\\lambda_i$，计算临界时间步长 $h_i = \\frac{-2\\operatorname{Re}(\\lambda_i)}{|\\lambda_i|^2}$。\n4.  测试用例的最大稳定时间步长 $h_{\\max}$ 被确定为所有计算出的 $h_i$ 中的最小值。如果没有特征值具有负实部，则 $h_{\\max}$ 被认为是无界的（无穷大）。\n\n这个过程在提供的 Python 代码中实现，使用 `numpy` 库进行数值线性代数运算，特别是使用 `numpy.linalg.eigvals` 来计算特征值。然后，所有测试用例的最终结果会按照要求进行格式化和打印。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum stable Forward Euler time step for the Robertson\n    kinetics model for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (y_vector, k_vector)\n    # y_vector: [y1, y2, y3]\n    # k_vector: [k1, k2, k3]\n    test_cases = [\n        ([1.0, 0.0, 0.0], [0.04, 3e7, 1e4]),\n        ([0.999, 1.0e-4, 9.0e-4], [0.04, 3e7, 1e4]),\n        ([0.9, 5.0e-3, 9.5e-2], [0.04, 3e7, 1e4]),\n        ([0.5, 1.0e-2, 4.9e-1], [0.04, 3e7, 1e4]),\n        ([0.9, 5.0e-3, 9.5e-2], [0.04, 3e6, 1e4]),\n        ([0.999, 1.0e-4, 9.0e-4], [0.04, 3e7, 1e5]),\n    ]\n\n    results = []\n    for y_vec, k_vec in test_cases:\n        y1, y2, y3 = y_vec\n        k1, k2, k3 = k_vec\n\n        # Construct the Jacobian matrix J based on the derived formula.\n        # J_ij = d(f_i)/d(y_j)\n        # f1 = -k1*y1 + k3*y2*y3\n        # f2 = k1*y1 - k2*y2**2 - k3*y2*y3\n        # f3 = k2*y2**2\n        J = np.array([\n            [-k1, k3 * y3, k3 * y2],\n            [k1, -2.0 * k2 * y2 - k3 * y3, -k3 * y2],\n            [0.0, 2.0 * k2 * y2, 0.0]\n        ], dtype=float)\n\n        # Compute the eigenvalues of the Jacobian matrix.\n        eigenvalues = np.linalg.eigvals(J)\n\n        h_max = float('inf')\n        \n        # Iterate through eigenvalues to find the most restrictive stability limit.\n        for lam in eigenvalues:\n            real_part = lam.real\n            \n            # The stability condition is relevant only for eigenvalues with a\n            # negative real part, which correspond to stable modes.\n            if real_part < 0:\n                # Calculate the squared magnitude of the eigenvalue.\n                mag_sq = lam.real**2 + lam.imag**2\n                \n                # Avoid division by zero, although this case is already handled by\n                # the real_part < 0 check, as lambda=0 has a zero real part.\n                if mag_sq > 1e-15: # A small tolerance for floating point safety.\n                    # Calculate the critical time step for this eigenvalue.\n                    # h_crit = -2 * Re(lambda) / |lambda|^2\n                    h_crit = -2.0 * real_part / mag_sq\n                    \n                    # The overall maximum step size is the minimum of all critical step sizes.\n                    if h_crit < h_max:\n                        h_max = h_crit\n                        \n        results.append(h_max)\n\n    # Format the final output as a comma-separated list in brackets.\n    # Scientific notation with 8 decimal places is used for precision.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在揭示了显式方法的局限性之后，下一步自然是构建一个能够克服这些限制的解决方案。这项实践 () 将引导您实现一个基于向后欧拉法的求解器，该方法对于刚性问题是无条件稳定的。您将为在每个时间步中求解隐式方程构建一个牛顿迭代求解器，从而亲身体验隐式积分器克服稳定性瓶颈的核心机制。",
            "id": "3913755",
            "problem": "您的任务是设计并实现一个完整的、可运行的程序，该程序使用隐式方法对生物医学系统建模中出现的刚性化学动力学模型进行数值积分。该模型是 Robertson 系统，一个典型的刚性系统，它代表了质量作用动力学下的三物种反应网络。其目的是展示为何数值刚性问题必须使用隐式方法，以及解析计算的雅可比矩阵如何在后向欧拉格式中实现稳健的牛顿迭代。您的任务必须纯粹以数学和算法的术语来表述，并且无需特定领域的实验数据即可解决。\n\nRobertson 系统，以浓度作为时间函数表示，由以下常微分方程(ODE)组给出\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y}), \\quad \\mathbf{y}(t) = \\begin{bmatrix} x(t) \\\\ y(t) \\\\ z(t) \\end{bmatrix},\n$$\n其右端项定义为\n$$\nf_1(x,y,z) = -k_1 x + k_2 y z, \\quad\nf_2(x,y,z) = k_1 x - k_2 y z - k_3 y^2, \\quad\nf_3(x,y,z) = k_3 y^2,\n$$\n初始条件为\n$$\n\\mathbf{y}(0) = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}.\n$$\n使用科学上标准的速率常数\n$$\nk_1 = 0.04 \\text{ s}^{-1}, \\quad k_2 = 10^4 \\text{ (mol/L)}^{-1}\\text{ s}^{-1}, \\quad k_3 = 3\\times 10^7 \\text{ (mol/L)}^{-1}\\text{ s}^{-1}.\n$$\n所有浓度 $x$、$y$ 和 $z$ 的单位均为 $\\text{mol/L}$，时间 $t$ 的单位为 $\\text{s}$。该系统是刚性的，因为 $k_3$ 的量级远大于 $k_1$ 和 $k_2$，这使得分量 $y(t)$ 相对于 $x(t)$ 和 $z(t)$ 在一个非常快的时间尺度上变化。\n\n为此初值问题实现两种数值积分器：\n- 一种是具有固定时间步长 $h$ 的显式欧拉法（前向欧拉法）：\n$$\n\\mathbf{y}_{n+1}^{\\mathrm{EE}} = \\mathbf{y}_n + h\\,\\mathbf{f}(\\mathbf{y}_n).\n$$\n- 一种是具有固定时间步长 $h$ 的后向欧拉法（隐式欧拉法），在每个时间步通过牛顿法求解：\n$$\n\\mathbf{y}_{n+1}^{\\mathrm{BE}} \\text{ 满足 } \\mathbf{y}_{n+1}^{\\mathrm{BE}} = \\mathbf{y}_n + h\\,\\mathbf{f}(\\mathbf{y}_{n+1}^{\\mathrm{BE}}).\n$$\n将后向欧拉法表述为求解残差的求根问题\n$$\n\\mathbf{R}(\\mathbf{y}) = \\mathbf{y} - \\mathbf{y}_n - h\\,\\mathbf{f}(\\mathbf{y}),\n$$\n并使用带有回溯线搜索的牛顿法求解 $\\mathbf{R}(\\mathbf{y}) = \\mathbf{0}$。您必须解析地计算 $\\mathbf{f}$ 的雅可比矩阵，并用它来构建牛顿雅可比矩阵\n$$\n\\mathbf{J}_{\\mathbf{R}}(\\mathbf{y}) = \\mathbf{I} - h\\,\\mathbf{J}_{\\mathbf{f}}(\\mathbf{y}),\n$$\n其中 $\\mathbf{I}$ 是 $3\\times 3$ 单位矩阵。推导并实现解析雅可比矩阵 $\\mathbf{J}_{\\mathbf{f}}$：\n$$\n\\mathbf{J}_{\\mathbf{f}}(\\mathbf{y}) =\n\\begin{bmatrix}\n\\frac{\\partial f_1}{\\partial x} & \\frac{\\partial f_1}{\\partial y} & \\frac{\\partial f_1}{\\partial z} \\\\\n\\frac{\\partial f_2}{\\partial x} & \\frac{\\partial f_2}{\\partial y} & \\frac{\\partial f_2}{\\partial z} \\\\\n\\frac{\\partial f_3}{\\partial x} & \\frac{\\partial f_3}{\\partial y} & \\frac{\\partial f_3}{\\partial z}\n\\end{bmatrix} =\n\\begin{bmatrix}\n-k_1 & k_2 z & k_2 y \\\\\nk_1 & -k_2 z - 2 k_3 y & -k_2 y \\\\\n0 & 2 k_3 y & 0\n\\end{bmatrix}.\n$$\n\n对此问题，“稳定积分”定义如下：如果所有计算出的浓度在所有时间步都保持非负（即，对所有 $n$ 都有 $x_n \\ge 0$, $y_n \\ge 0$, $z_n \\ge 0$），并且牛顿求解器在每个后向欧拉步都收敛，使得残差范数低于一个很小的容差，则该积分被认为是数值稳定的。如果任何浓度在任何时间步变为负值，或者产生了任何非有限值（非数字或无穷大），则认为显式欧拉法的运行“失败”。\n\n使用以下固定步长测试套件，每个案例由结束时间 $T$ 和时间步长 $h$ 指定：\n1. $T = 2\\ \\text{s}$, $h = 1\\ \\text{s}$。\n2. $T = 1\\ \\text{s}$, $h = 0.1\\ \\text{s}$。\n3. $T = 10^{-3}\\ \\text{s}$, $h = 10^{-5}\\ \\text{s}$。\n4. $T = 5\\ \\text{s}$, $h = 5\\ \\text{s}$。\n\n对于每个测试案例，使用指定的步长 $h$，从共同的初始条件 $\\mathbf{y}(0)$ 开始，对两种积分器进行积分，直至指定的结束时间 $T$。对于后向欧拉法，使用带有解析计算的雅可比矩阵和回溯线搜索的牛顿法，该线搜索在试验迭代点上强制执行浓度的非负性。在残差范数上使用 $10^{-12}$ 的收敛容差，并且每步最多进行 $50$ 次牛顿迭代。如果牛顿法在迭代限制内未能收敛，或在任何步骤中产生非有限值，则认为该案例的后向欧拉积分是“不稳定的”。\n\n您的程序应生成单行输出，其中包含一个由四个整数组成的列表，每个整数对应一个测试案例，按上述顺序排列，编码规则如下：\n- 如果该案例中后向欧拉法稳定而显式欧拉法失败，则输出 $2$。\n- 如果该案例中两种方法都稳定，则输出 $1$。\n- 如果该案例中后向欧拉法不稳定（无论显式欧拉法如何），则输出 $0$。\n\n最终输出必须严格按照方括号括起来的逗号分隔列表的格式打印，例如 $[2,2,1,2]$。所有时间量的单位都是秒，所有浓度的单位都是 $\\text{mol/L}$。本问题不涉及角度。不涉及百分比；如果需要任何小数，请以十进制形式表示。\n\n该测试套件旨在涵盖以下几个方面：一个“理想路径”案例，其中小步长能使两种方法都稳定；大步长案例，预计显式欧拉法会因刚性而失败，但后向欧拉法会保持稳定；以及一个边界案例，即单个大的隐式步长，需要稳健的牛顿法收敛。每个测试案例的答案是如上定义的整数。您的最终程序必须是自包含的、可直接运行的，并且不得需要用户输入或外部文件。请确保所有数学运算和变量都得到适当且一致的表示。",
            "solution": "该问题要求实现并比较两种数值积分方法——显式欧拉法和后向欧拉法，用于求解 Robertson 系统。该系统是常微分方程(ODE)刚性系统的一个典型例子，在生物医学化学动力学中经常遇到。对问题陈述的验证证实了其科学合理性、完整性和客观性。所有给定的数学公式，包括ODE系统、其雅可比矩阵以及数值方法，都是标准且正确的。我们开始进行求解。\n\n该ODE系统由 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ 给出，其中 $\\mathbf{y}(t) = [x(t), y(t), z(t)]^T$。向量函数 $\\mathbf{f}$ 的分量为：\n$$\n\\begin{aligned}\nf_1(x,y,z) = -k_1 x + k_2 y z \\\\\nf_2(x,y,z) = k_1 x - k_2 y z - k_3 y^2 \\\\\nf_3(x,y,z) = k_3 y^2\n\\end{aligned}\n$$\n该系统满足初始条件 $\\mathbf{y}(0) = [1, 0, 0]^T$，速率常数为 $k_1 = 0.04$，$k_2 = 10^4$ 和 $k_3 = 3 \\times 10^7$。这些常数量级上的巨大差异引入了刚性，意味着各分量之间存在着巨大的演化时间尺度差异，这对数值求解器构成了重大挑战。\n\n**显式欧拉法**\n\n显式欧拉法（前向欧拉法）是求解ODE的最简单的数值格式。给定时间 $t_n$ 的状态 $\\mathbf{y}_n$，下一个时间步 $t_{n+1} = t_n + h$ 的状态近似为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h\\,\\mathbf{f}(\\mathbf{y}_n)\n$$\n该方法计算成本低，因为每步只需对函数 $\\mathbf{f}$ 进行一次评估。然而，其主要缺点是条件稳定性。对于刚性系统，显式欧拉法的稳定性受到最快动力学的制约，要求步长 $h$ 小到不切实际的程度。具体来说，$h$ 与雅可比矩阵 $\\mathbf{J}_{\\mathbf{f}}$ 最大特征值模的乘积必须位于一个小的稳定域内。对于 Robertson 系统，这意味着 $h$ 必须非常小，使得该方法对于长时间积分不切实际。如果在任何步骤中，物种浓度变为负值或计算出非有限值，则认为积分失败，这是违反稳定性条件时的常见结果。\n\n**后向欧拉法和牛顿法**\n\n后向欧拉法（隐式欧拉法）通过求解以下隐式方程来计算下一个状态 $\\mathbf{y}_{n+1}$：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h\\,\\mathbf{f}(\\mathbf{y}_{n+1})\n$$\n该方法是A-稳定的，这意味着当应用于线性刚性问题时，对于任何步长 $h > 0$ 它都是数值稳定的。这一特性使其非常适合于刚性系统。然而，由于 $\\mathbf{y}_{n+1}$ 出现在方程的两边，因此在每个时间步都必须求解一个（通常是非线性的）代数方程组。\n\n为了求解 $\\mathbf{y}_{n+1}$，我们将方程重新表述为一个求根问题。设 $\\mathbf{y}$ 为 $\\mathbf{y}_{n+1}$ 的未知值。我们寻求残差函数 $\\mathbf{R}(\\mathbf{y})$ 的根：\n$$\n\\mathbf{R}(\\mathbf{y}) = \\mathbf{y} - \\mathbf{y}_n - h\\,\\mathbf{f}(\\mathbf{y}) = \\mathbf{0}\n$$\n这个根通过牛顿法这一迭代过程来找到。从一个初始猜测 $\\mathbf{y}^{(0)}$（通常是 $\\mathbf{y}_n$）开始，逐次逼近 $\\mathbf{y}^{(k)}$ 的计算如下：\n$$\n\\mathbf{y}^{(k+1)} = \\mathbf{y}^{(k)} - [\\mathbf{J}_{\\mathbf{R}}(\\mathbf{y}^{(k)})]^{-1} \\mathbf{R}(\\mathbf{y}^{(k)})\n$$\n其中 $\\mathbf{J}_{\\mathbf{R}}$ 是残差函数 $\\mathbf{R}$ 的雅可比矩阵。该雅可比矩阵推导如下：\n$$\n\\mathbf{J}_{\\mathbf{R}}(\\mathbf{y}) = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{y}} = \\mathbf{I} - h\\,\\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}} = \\mathbf{I} - h\\,\\mathbf{J}_{\\mathbf{f}}(\\mathbf{y})\n$$\n这里，$\\mathbf{I}$ 是 $3 \\times 3$ 单位矩阵，$\\mathbf{J}_{\\mathbf{f}}$ 是ODE系统的解析计算雅可比矩阵，如问题陈述中所提供。在每次牛顿迭代中，我们求解线性系统 $\\mathbf{J}_{\\mathbf{R}}(\\mathbf{y}^{(k)}) \\Delta\\mathbf{y}^{(k)} = -\\mathbf{R}(\\mathbf{y}^{(k)})$ 以获得更新步 $\\Delta\\mathbf{y}^{(k)}$。\n\n为了确保稳健收敛，特别是在初始猜测不佳或步长 $h$ 较大时，我们引入了回溯线搜索。在计算出牛顿步 $\\Delta\\mathbf{y}^{(k)}$ 后，下一个迭代点通过 $\\mathbf{y}^{(k+1)} = \\mathbf{y}^{(k)} + \\alpha \\Delta\\mathbf{y}^{(k)}$ 找到，其中步长 $\\alpha \\in (0, 1]$ 从初始值 $1$ 开始减小，直到试验迭代点 $\\mathbf{y}^{(k+1)}$ 满足某些条件为止。对于本问题，关键条件是所有浓度的非负性，即 $\\mathbf{y}^{(k+1)}$ 的所有分量必须大于或等于 $0$。如果牛顿求解器在 $50$ 次迭代内未能收敛到残差范数低于 $10^{-12}$ 的容差，或者线搜索未能找到一个非负的试验迭代点，则认为求解器失败。\n\n**实现与测试案例分析**\n\n实现包括用于 $\\mathbf{f}(\\mathbf{y})$、$\\mathbf{J}_{\\mathbf{f}}(\\mathbf{y})$ 的独立函数、一个用于后向欧拉步的牛顿求解器，以及一个主驱动程序来为每个测试案例运行积分。\n\n1.  **案例1：$T = 2\\ \\text{s}$，$h = 1\\ \\text{s}$**。步长 $h=1$ 对于显式欧拉法来说太大，无法保持稳定，因为它严重违反了由刚性分量施加的稳定性条件。这将导致振荡和负浓度，从而导致显式方法失败。而后向欧拉法是A-稳定的，能够处理这个大步长，其稳健的牛顿求解器预计会收敛。因此，预期结果为 $2$。\n2.  **案例2：$T = 1\\ \\text{s}$，$h = 0.1\\ \\text{s}$**。与第一个案例类似，$h=0.1$ 仍然远大于显式欧拉法的稳定性极限，会导致失败。后向欧拉法应保持稳定。预期结果：$2$。\n3.  **案例3：$T = 10^{-3}\\ \\text{s}$，$h = 10^{-5}\\ \\text{s}$**。在这里，步长 $h=10^{-5}$ 非常小，落在显式欧拉法的稳定域内。因此，预计显式和后向欧拉法都能成功完成积分，在整个过程中得到非负浓度。预期结果：$1$。\n4.  **案例4：$T = 5\\ \\text{s}$，$h = 5\\ \\text{s}$**。这涉及一个单一的、极大的步长。对于显式欧拉法，更新 $\\mathbf{y}_1 = \\mathbf{y}_0 + h\\,\\mathbf{f}(\\mathbf{y}_0)$ 产生 $[0.8, 0.2, 0]^T$，这是非负的。根据问题对稳定性的严格定义（仅检查在时间步 $t_0, t_1$ 计算出的非负值），此积分被认为是“稳定的”，尽管结果在物理上不准确。对于后向欧拉法，这个单次大步长对牛顿求解器构成了重大挑战，但它的设计就是为了在这种条件下收敛。因此，根据问题的标准，两种方法都被认为是稳定的。预期结果：$1$。\n\n程序计算这些结果并将其格式化为整数列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# language: Python\n# version: 3.12\n# libraries:\n#     name: numpy, version: 1.23.5\n\ndef solve():\n    \"\"\"\n    Solves the Robertson stiff ODE problem by comparing Explicit and\n    Backward Euler methods over a suite of test cases.\n    \"\"\"\n\n    # --- Problem Constants ---\n    K1 = 0.04\n    K2 = 1.0e4\n    K3 = 3.0e7\n\n    # --- ODE System Definition ---\n\n    def robertson_f(y, k1, k2, k3):\n        \"\"\"Computes the right-hand side of the Robertson ODE system.\"\"\"\n        x, y_comp, z = y\n        dydt = np.zeros(3, dtype=np.float64)\n        dydt[0] = -k1 * x + k2 * y_comp * z\n        dydt[1] = k1 * x - k2 * y_comp * z - k3 * y_comp**2\n        dydt[2] = k3 * y_comp**2\n        return dydt\n\n    def robertson_Jf(y, k1, k2, k3):\n        \"\"\"Computes the analytical Jacobian of the Robertson ODE system.\"\"\"\n        x, y_comp, z = y\n        Jf = np.zeros((3, 3), dtype=np.float64)\n        # df1/dx, df1/dy, df1/dz\n        Jf[0, 0] = -k1\n        Jf[0, 1] = k2 * z\n        Jf[0, 2] = k2 * y_comp\n        # df2/dx, df2/dy, df2/dz\n        Jf[1, 0] = k1\n        Jf[1, 1] = -k2 * z - 2 * k3 * y_comp\n        Jf[1, 2] = -k2 * y_comp\n        # df3/dx, df3/dy, df3/dz\n        Jf[2, 0] = 0.0\n        Jf[2, 1] = 2 * k3 * y_comp\n        Jf[2, 2] = 0.0\n        return Jf\n\n    # --- Backward Euler Newton Solver ---\n\n    def solve_be_step(y_n, h, k1, k2, k3, tol=1e-12, max_iter=50):\n        \"\"\"\n        Solves for y_{n+1} in a single backward Euler step using Newton's method\n        with backtracking line search.\n        Finds the root of R(y) = y - y_n - h * f(y) = 0.\n        \"\"\"\n        y_k = np.copy(y_n)\n        \n        for _ in range(max_iter):\n            f_yk = robertson_f(y_k, k1, k2, k3)\n            R = y_k - y_n - h * f_yk\n            \n            if not np.all(np.isfinite(R)):\n                return None, False\n\n            if np.linalg.norm(R) < tol:\n                return y_k, True\n\n            Jf_yk = robertson_Jf(y_k, k1, k2, k3)\n            JR = np.eye(3) - h * Jf_yk\n            \n            try:\n                delta_y = np.linalg.solve(JR, -R)\n            except np.linalg.LinAlgError:\n                return None, False\n\n            if not np.all(np.isfinite(delta_y)):\n                return None, False\n\n            alpha = 1.0\n            line_search_success = False\n            for _ in range(10):  # Max 10 backtracking steps\n                y_trial = y_k + alpha * delta_y\n                if np.all(y_trial >= 0):\n                    y_k = y_trial\n                    line_search_success = True\n                    break\n                alpha /= 2.0\n            \n            if not line_search_success:\n                return None, False\n        \n        return None, False\n\n    # --- Integrator Driver ---\n\n    def run_integration(integrator_type, y0, T, h, k1, k2, k3):\n        \"\"\"\n        Integrates the ODE system and returns True for stable integration, False for failure.\n        \"\"\"\n        y = np.copy(y0)\n        num_steps = int(round(T / h))\n\n        if num_steps == 0:\n            return True\n\n        for _ in range(num_steps):\n            if integrator_type == 'ee':\n                if not np.all(np.isfinite(y)): return False\n                dydt = robertson_f(y, k1, k2, k3)\n                if not np.all(np.isfinite(dydt)): return False\n                y_next = y + h * dydt\n                if np.any(y_next < 0) or not np.all(np.isfinite(y_next)):\n                    return False\n                y = y_next\n            \n            elif integrator_type == 'be':\n                y_next, converged = solve_be_step(y, h, k1, k2, k3)\n                if not converged:\n                    return False\n                y = y_next\n        \n        return True\n\n    # --- Main Execution Logic ---\n    \n    y0 = np.array([1.0, 0.0, 0.0], dtype=np.float64)\n    \n    test_cases = [\n        (2.0, 1.0),\n        (1.0, 0.1),\n        (1.0e-3, 1.0e-5),\n        (5.0, 5.0)\n    ]\n    \n    results = []\n    for T, h in test_cases:\n        ee_stable = run_integration('ee', y0, T, h, K1, K2, K3)\n        be_stable = run_integration('be', y0, T, h, K1, K2, K3)\n        \n        if not be_stable:\n            result_code = 0\n        elif be_stable and not ee_stable:\n            result_code = 2\n        elif be_stable and ee_stable:\n            result_code = 1\n        else: # Should not be reached\n            result_code = -1 \n            \n        results.append(result_code)\n            \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然向后欧拉法提供了稳定性，但为了提高计算效率，我们往往需要更高阶的精度。这项高级实践 () 介绍了更为强大的 Radau IIA 方法，这是一种高阶隐式龙格-库塔格式。您将为该方法的内部“阶段”构建耦合的非线性方程组，并开发一个牛顿求解器来处理这个更复杂的系统，从而深化对前沿刚性积分器设计原理的理解。",
            "id": "3913789",
            "problem": "考虑一个双物种酶催化生物化学反应网络，该网络遵循质量作用动力学，并通过游离酶守恒进行了简化。物种为底物 $S$（浓度为 $[S]$）和酶-底物复合物 $C$（浓度为 $[C]$）。游离酶浓度为 $[E] = E_{\\text{tot}} - [C]$，其中 $E_{\\text{tot}}$ 是守恒的总酶浓度。反应包括结合反应 $S + E \\xrightarrow{k_1} C$、解离反应 $C \\xrightarrow{k_{-1}} S + E$ 和催化反应 $C \\xrightarrow{k_2} P + E$，其中 $P$ 是产物。其控制常微分方程（ODE）系统为\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\n[S]\\\\\n[C]\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n- k_1 [S][E] + k_{-1}[C]\\\\\n\\phantom{-} k_1 [S][E] - (k_{-1} + k_2)[C]\n\\end{bmatrix}, \\quad [E] = E_{\\text{tot}} - [C].\n$$\n假设参数 $k_1 = 10^{6}\\ \\text{M}^{-1}\\ \\text{s}^{-1}$，$k_{-1} = 10^{3}\\ \\text{s}^{-1}$，$k_2 = 10^{2}\\ \\text{s}^{-1}$，$E_{\\text{tot}} = 10^{-6}\\ \\text{M}$，以及在时间 $t_n = 0\\ \\text{s}$ 时的初始条件为 $[S](0) = 10^{-4}\\ \\text{M}$ 和 $[C](0) = 0\\ \\text{M}$。使用二阶Radau IIA型隐式龙格-库塔方法处理该系统，并分析其数值刚性和非线性求解策略。\n\n您的任务是：\n\n1. 基于初值问题定义 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$（其中 $\\mathbf{y} = \\begin{bmatrix}[S] & [C]\\end{bmatrix}^{\\top}$）和一个 $s$ 阶隐式龙格-库塔方法的核心定义，通过确定满足Radau IIA族定义性质（包括高达 $2s-1$ 阶的刚性精度和阶数条件）的节点位置 $c_i$、系数 $a_{ij}$ 和权重 $b_i$ 来构建二阶Radau IIA方法。请勿使用任何未从定义性质中推导出的简化公式。\n\n2. 使用您构建的系数，写出在时间层 $t_n + c_1 h$ 和 $t_n + c_2 h$ 处阶段值 $\\mathbf{Y}_1$ 和 $\\mathbf{Y}_2$ 的耦合非线性阶段方程，其中 $h$ 是以秒为单位的时间步长。将阶段方程表示为残差形式 $\\mathbf{F}(\\mathbf{Z}) = \\mathbf{0}$，其中 $\\mathbf{Z} = \\begin{bmatrix}\\mathbf{Y}_1 \\\\ \\mathbf{Y}_2\\end{bmatrix} \\in \\mathbb{R}^{4}$ 是两个阶段向量的堆叠。\n\n3. 从方程组牛顿法的基础定义出发，推导一个用于求解阶段方程的牛顿迭代过程，包括以在当前阶段迭代值处求值的 $\\mathbf{f}$ 的雅可比矩阵表示的显式 $4 \\times 4$ 块雅可比矩阵结构。清楚地指明单位矩阵的作用以及通过龙格-库塔系数产生的耦合。您的推导应从非线性系统的残差和雅可比矩阵的定义开始，然后进行到每次牛顿迭代中需求解的线性系统。陈述一个基于残差的欧几里得范数和最大允许迭代次数的收敛准则。如果需要步长策略，请基于基本原理指定一个标准的回溯规则及其参数。\n\n4. 使用二阶Radau IIA方法和您的牛顿求解器，实现从 $t_n$ 到 $t_{n+1} = t_n + h$ 的单步推进。使用以下以秒为单位的时间步长 $h$ 测试集来检验在不同情况下的行为：\n- 理想情况：$h = 10^{-6}\\ \\text{s}$。\n- 中等刚性：$h = 10^{-3}\\ \\text{s}$。\n- 强刚性：$h = 10^{-1}\\ \\text{s}$。\n- 极大步长：$h = 10^{1}\\ \\text{s}$。\n\n对于每个 $h$，使用初始猜测 $\\mathbf{Y}_1^{(0)} = \\mathbf{y}_n$ 和 $\\mathbf{Y}_2^{(0)} = \\mathbf{y}_n$ 开始牛顿迭代。使用收敛容差，要求 $\\lVert \\mathbf{F}(\\mathbf{Z}^{(k)}) \\rVert_2 \\le 10^{-12}$，并且最多进行 $50$ 次牛顿迭代。如果使用回溯法，则对残差范数的平方采用满足充分下降条件的标准Armijo型参数选择。\n\n您的程序必须计算测试集中每个 $h$ 值下，将阶段方程求解至规定容差所需的牛顿迭代次数。如果求解器未能在最大迭代次数内收敛，则对该情况报告整数 $-1$。无需报告任何其他量。输出为单行，包含一个方括号括起来的逗号分隔列表，例如 $[n_1,n_2,n_3,n_4]$，其中每个 $n_i$ 是对应 $h$ 的整数牛顿迭代次数。\n\n您的推导中所有物理量必须遵守其给定单位。不出现角度。不出现百分比。程序必须完全自包含，且不得要求任何用户输入。",
            "solution": "问题陈述已经过验证，被认为是科学上可靠、适定、客观且完整的。它提出了一个在刚性常微分方程（ODEs）数值求解方面的标准但重要的练习，这与生物医学系统的建模高度相关。各项任务逻辑结构清晰，且所有必需数据均已提供。因此，我们可以着手提供完整的解决方案。\n\n该问题要求使用一种特定的隐式龙格-库塔（IRK）方法，对一个刚性生化ODE系统进行从时间 $t_n=0$ 到 $t_{n+1} = t_n+h$ 的单步积分。这涉及三个主要部分，将按顺序进行阐述：从基本原理推导IRK方法的系数，为内部阶段值构建相应的非线性方程组，以及推导并实现一个牛顿-拉夫逊求解器来求解该系统。\n\n设状态向量为 $\\mathbf{y}(t) = \\begin{bmatrix} [S](t) \\\\ [C](t) \\end{bmatrix} \\in \\mathbb{R}^2$。控制ODE系统为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$，其中函数 $\\mathbf{f}: \\mathbb{R}^2 \\to \\mathbb{R}^2$ 由下式给出\n$$\n\\mathbf{f}(\\mathbf{y}) = \\begin{bmatrix} -k_1 y_1 (E_{\\text{tot}} - y_2) + k_{-1} y_2 \\\\ k_1 y_1 (E_{\\text{tot}} - y_2) - (k_{-1} + k_2) y_2 \\end{bmatrix},\n$$\n其中 $y_1 = [S]$ 且 $y_2 = [C]$。给定参数为 $k_1 = 10^6 \\ \\text{M}^{-1}\\text{s}^{-1}$，$k_{-1} = 10^3 \\ \\text{s}^{-1}$，$k_2 = 10^2 \\ \\text{s}^{-1}$，以及 $E_{\\text{tot}} = 10^{-6} \\ \\text{M}$。在 $t_n=0 \\ \\text{s}$ 时的初始条件为 $\\mathbf{y}_n = \\mathbf{y}(0) = \\begin{bmatrix} 10^{-4} \\\\ 0 \\end{bmatrix} \\ \\text{M}$。\n\n**1. 构建二阶Radau IIA方法**\n\n一个 $s$ 阶隐式龙格-库塔方法由其Butcher表 $(\\mathbf{c}, \\mathbf{A}, \\mathbf{b})$ 定义。阶段值 $\\mathbf{Y}_i \\in \\mathbb{R}^2$ 是对中间时间 $t_n + c_i h$ 处解的近似，由以下方程组定义：\n$$\n\\mathbf{Y}_i = \\mathbf{y}_n + h \\sum_{j=1}^s a_{ij} \\mathbf{f}(\\mathbf{Y}_j), \\quad \\text{对于 } i=1, \\dots, s.\n$$\n下一个时间步的解由下式给出：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^s b_i \\mathbf{f}(\\mathbf{Y}_i).\n$$\nRadau IIA方法是一类特殊的配置方法。对于 $s=2$，其定义性质如下：\n1.  该方法是一种配置方法，其节点 $c_i$ 是由移位的勒让德多项式派生出的多项式的根。对于Radau IIA，节点是多项式 $P_s'(x)$ 的根，其中 $P_s(x) = x^{s-1}(x-1)^s$。对于 $s=2$，此为 $\\frac{d}{dx}[x(x-1)^2] = (x-1)^2 + 2x(x-1) = (x-1)(x-1+2x) = (x-1)(3x-1)$。定义节点的根为 $c_1=1/3$ 和 $c_2=1$。\n2.  系数 $a_{ij}$ 由 $a_{ij} = \\int_0^{c_i} L_j(\\tau) d\\tau$ 给出，其中 $L_j(\\tau)$ 是针对节点 $\\{c_1, c_2\\}$ 的拉格朗日基多项式。\n    拉格朗日多项式为：\n    $L_1(\\tau) = \\frac{\\tau - c_2}{c_1 - c_2} = \\frac{\\tau - 1}{1/3 - 1} = -\\frac{3}{2}(\\tau-1)$。\n    $L_2(\\tau) = \\frac{\\tau - c_1}{c_2 - c_1} = \\frac{\\tau - 1/3}{1 - 1/3} = \\frac{3}{2}(\\tau-1/3)$。\n    系数 $a_{ij}$ 通过积分计算：\n    $a_{11} = \\int_0^{1/3} L_1(\\tau) d\\tau = \\int_0^{1/3} -\\frac{3}{2}(\\tau-1) d\\tau = -\\frac{3}{2}[\\frac{\\tau^2}{2} - \\tau]_0^{1/3} = -\\frac{3}{2}(\\frac{1}{18} - \\frac{1}{3}) = \\frac{5}{12}$。\n    $a_{12} = \\int_0^{1/3} L_2(\\tau) d\\tau = \\int_0^{1/3} \\frac{3}{2}(\\tau-1/3) d\\tau = \\frac{3}{2}[\\frac{\\tau^2}{2} - \\frac{\\tau}{3}]_0^{1/3} = \\frac{3}{2}(\\frac{1}{18} - \\frac{1}{9}) = -\\frac{1}{12}$。\n    $a_{21} = \\int_0^{1} L_1(\\tau) d\\tau = \\int_0^{1} -\\frac{3}{2}(\\tau-1) d\\tau = -\\frac{3}{2}[\\frac{\\tau^2}{2} - \\tau]_0^{1} = -\\frac{3}{2}(\\frac{1}{2} - 1) = \\frac{3}{4}$。\n    $a_{22} = \\int_0^{1} L_2(\\tau) d\\tau = \\int_0^{1} \\frac{3}{2}(\\tau-1/3) d\\tau = \\frac{3}{2}[\\frac{\\tau^2}{2} - \\frac{\\tau}{3}]_0^{1} = \\frac{3}{2}(\\frac{1}{2} - \\frac{1}{3}) = \\frac{1}{4}$。\n3.  权重 $b_i$ 由 $b_i = \\int_0^1 L_i(\\tau) d\\tau$ 给出。由于 $c_2=1$，我们立即得到 $b_i = a_{2i}$。\n    $b_1 = a_{21} = 3/4$。\n    $b_2 = a_{22} = 1/4$。\n该方法的阶为 $p = 2s-1 = 3$。得到的Butcher表为：\n$$\n\\begin{array}{c|cc}\n1/3 & 5/12 & -1/12 \\\\\n1 & 3/4 & 1/4 \\\\\n\\hline\n & 3/4 & 1/4\n\\end{array}\n$$\n该方法是刚性精确的，因为 $c_s = c_2 = 1$ 且 $a_{sj} = b_j$ 对 $j=1, 2$ 成立。这意味着 $\\mathbf{y}_{n+1} = \\mathbf{Y}_s = \\mathbf{Y}_2$，这在计算上是有利的。\n\n**2. 阶段值的非线性系统**\n\n使用推导出的系数，阶段值 $\\mathbf{Y}_1, \\mathbf{Y}_2 \\in \\mathbb{R}^2$ 的阶段方程为：\n$$\n\\mathbf{Y}_1 = \\mathbf{y}_n + h \\left( \\frac{5}{12} \\mathbf{f}(\\mathbf{Y}_1) - \\frac{1}{12} \\mathbf{f}(\\mathbf{Y}_2) \\right)\n$$\n$$\n\\mathbf{Y}_2 = \\mathbf{y}_n + h \\left( \\frac{3}{4} \\mathbf{f}(\\mathbf{Y}_1) + \\frac{1}{4} \\mathbf{f}(\\mathbf{Y}_2) \\right)\n$$\n这是一个包含 $2 \\times 2 = 4$ 个非线性代数方程的耦合系统。为了使用牛顿法求解，我们将其表示为残差形式 $\\mathbf{F}(\\mathbf{Z}) = \\mathbf{0}$。设 $\\mathbf{Z} \\in \\mathbb{R}^4$ 是阶段值的堆叠向量，$\\mathbf{Z} = \\begin{bmatrix} \\mathbf{Y}_1 \\\\ \\mathbf{Y}_2 \\end{bmatrix}$。残差函数 $\\mathbf{F}: \\mathbb{R}^4 \\to \\mathbb{R}^4$ 为：\n$$\n\\mathbf{F}(\\mathbf{Z}) =\n\\begin{bmatrix}\n\\mathbf{F}_1(\\mathbf{Y}_1, \\mathbf{Y}_2) \\\\\n\\mathbf{F}_2(\\mathbf{Y}_1, \\mathbf{Y}_2)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{Y}_1 - \\mathbf{y}_n - h \\left( \\frac{5}{12} \\mathbf{f}(\\mathbf{Y}_1) - \\frac{1}{12} \\mathbf{f}(\\mathbf{Y}_2) \\right) \\\\\n\\mathbf{Y}_2 - \\mathbf{y}_n - h \\left( \\frac{3}{4} \\mathbf{f}(\\mathbf{Y}_1) + \\frac{1}{4} \\mathbf{f}(\\mathbf{Y}_2) \\right)\n\\end{bmatrix}\n= \\mathbf{0}\n$$\n\n**3. 阶段方程的牛顿法**\n\n求解系统 $\\mathbf{F}(\\mathbf{Z}) = \\mathbf{0}$ 的牛顿法是一个迭代过程。从一个初始猜测 $\\mathbf{Z}^{(0)}$ 开始，每次迭代通过求解一个线性系统来计算更新步长 $\\Delta \\mathbf{Z}^{(k)}$，从而得到新的近似值 $\\mathbf{Z}^{(k+1)}$：\n$$\n\\mathbf{J}_{\\mathbf{F}}(\\mathbf{Z}^{(k)}) \\Delta \\mathbf{Z}^{(k)} = -\\mathbf{F}(\\mathbf{Z}^{(k)})\n$$\n$$\n\\mathbf{Z}^{(k+1)} = \\mathbf{Z}^{(k)} + \\alpha_k \\Delta \\mathbf{Z}^{(k)}\n$$\n其中 $\\mathbf{J}_{\\mathbf{F}}$ 是残差函数 $\\mathbf{F}$ 的 $4 \\times 4$ 雅可比矩阵，$\\alpha_k \\in (0, 1]$ 是由线搜索算法确定的步长。\n\n雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}$ 具有一个 $2 \\times 2$ 的块结构，其中每个块都是一个 $2 \\times 2$ 矩阵：\n$$\n\\mathbf{J}_{\\mathbf{F}}(\\mathbf{Z}) = \\begin{bmatrix} \\frac{\\partial \\mathbf{F}_1}{\\partial \\mathbf{Y}_1} & \\frac{\\partial \\mathbf{F}_1}{\\partial \\mathbf{Y}_2} \\\\ \\frac{\\partial \\mathbf{F}_2}{\\partial \\mathbf{Y}_1} & \\frac{\\partial \\mathbf{F}_2}{\\partial \\mathbf{Y}_2} \\end{bmatrix}\n$$\n设 $\\mathbf{J}_{\\mathbf{f}}(\\mathbf{y})$ 是ODE函数 $\\mathbf{f}$ 的 $2 \\times 2$ 雅可比矩阵。$\\mathbf{J}_{\\mathbf{F}}$ 的块矩阵为：\n$\\frac{\\partial \\mathbf{F}_1}{\\partial \\mathbf{Y}_1} = \\mathbf{I} - h a_{11} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_1) = \\mathbf{I} - h \\frac{5}{12} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_1)$\n$\\frac{\\partial \\mathbf{F}_1}{\\partial \\mathbf{Y}_2} = -h a_{12} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_2) = h \\frac{1}{12} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_2)$\n$\\frac{\\partial \\mathbf{F}_2}{\\partial \\mathbf{Y}_1} = -h a_{21} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_1) = -h \\frac{3}{4} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_1)$\n$\\frac{\\partial \\mathbf{F}_2}{\\partial \\mathbf{Y}_2} = \\mathbf{I} - h a_{22} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_2) = \\mathbf{I} - h \\frac{1}{4} \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y}_2)$\n其中 $\\mathbf{I}$ 是 $2 \\times 2$ 的单位矩阵。\n\nODE函数 $\\mathbf{f}(\\mathbf{y})$ 相对于 $\\mathbf{y} = [y_1, y_2]^T$ 的雅可比矩阵是：\n$$\n\\mathbf{J}_{\\mathbf{f}}(\\mathbf{y}) =\n\\begin{bmatrix}\n\\frac{\\partial f_1}{\\partial y_1} & \\frac{\\partial f_1}{\\partial y_2} \\\\\n\\frac{\\partial f_2}{\\partial y_1} & \\frac{\\partial f_2}{\\partial y_2}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-k_1(E_{\\text{tot}} - y_2) & k_1 y_1 + k_{-1} \\\\\nk_1(E_{\\text{tot}} - y_2) & -k_1 y_1 - (k_{-1} + k_2)\n\\end{bmatrix}.\n$$\n在每个牛顿步 $k$，$\\mathbf{J}_{\\mathbf{f}}$ 在当前的阶段值迭代 $\\mathbf{Y}_1^{(k)}$ 和 $\\mathbf{Y}_2^{(k)}$ 处被求值，以组装完整的 $4 \\times 4$ 矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{Z}^{(k)})$。\n\n迭代持续进行，直到满足收敛准则 $\\lVert \\mathbf{F}(\\mathbf{Z}^{(k)}) \\rVert_2 \\le 10^{-12}$，或直到达到最多 $50$ 次迭代的上限。\n为确保稳健收敛，尤其是在大步长 $h$ 的情况下，采用回溯线搜索来确定步长 $\\alpha_k$。我们寻找最大的 $\\alpha_k \\in \\{1, 1/2, 1/4, \\dots\\}$，使其满足Armijo-Goldstein充分下降条件：\n$$\n\\left\\lVert \\mathbf{F}\\left(\\mathbf{Z}^{(k)} + \\alpha_k \\Delta \\mathbf{Z}^{(k)}\\right) \\right\\rVert_2^2 \\le \\left(1 - 2\\sigma\\alpha_k\\right) \\left\\lVert \\mathbf{F}\\left(\\mathbf{Z}^{(k)}\\right) \\right\\rVert_2^2\n$$\n控制参数的一个标准选择是 $\\sigma = 10^{-4}$。\n\n**4. 实现与数值测试**\n\n从 $t_n=0$ 开始单步计算的算法如下：\n1.  初始化参数和初始状态 $\\mathbf{y}_n = [10^{-4}, 0]^T$。\n2.  对于测试集 $\\{10^{-6}, 10^{-3}, 10^{-1}, 10^{1}\\}$ 秒中的每个时间步长 $h$：\n    a. 使用猜测值 $\\mathbf{Z}^{(0)} = [\\mathbf{y}_n^T, \\mathbf{y}_n^T]^T$ 和迭代次数 `iter = 0` 初始化牛顿求解器。\n    b. 进行循环 $k = 0, \\dots, 49$：\n        i.   计算残差 $\\mathbf{F}(\\mathbf{Z}^{(k)})$。\n        ii.  检查是否 $\\lVert \\mathbf{F}(\\mathbf{Z}^{(k)}) \\rVert_2 \\le 10^{-12}$。如果为真，存储 `iter` 并跳出循环。\n        iii. 通过在 $\\mathbf{Y}_1^{(k)}$ 和 $\\mathbf{Y}_2^{(k)}$ 处求值 $\\mathbf{J}_{\\mathbf{f}}$ 来构建雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{Z}^{(k)})$。\n        iv.  求解线性系统 $\\mathbf{J}_{\\mathbf{F}} \\Delta \\mathbf{Z} = -\\mathbf{F}$ 以获得牛顿步长 $\\Delta \\mathbf{Z}$。\n        v.   执行回溯线搜索以找到可接受的步长 $\\alpha_k$。\n        vi.  更新解：$\\mathbf{Z}^{(k+1)} = \\mathbf{Z}^{(k)} + \\alpha_k \\Delta \\mathbf{Z}$。\n        vii. `iter` 自增。\n    c. 如果循环完成但未收敛，则记录 `-1`。\n3.  最终输出是迭代次数的列表。以下程序实现了这一过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the number of Newton iterations required for a single step of the\n    2-stage Radau IIA method applied to a stiff biochemical system.\n    \"\"\"\n    # 1. Define model parameters and initial conditions\n    k1 = 1.0e6  # M^-1 s^-1\n    k_1 = 1.0e3  # s^-1\n    k2 = 1.0e2  # s^-1\n    Etot = 1.0e-6  # M\n    y_n = np.array([1.0e-4, 0.0])  # [S], [C] at t_n=0\n\n    # 2. Define the ODE system function f(y) and its Jacobian J_f(y)\n    def f(y):\n        \"\"\"ODE function dy/dt = f(y)\"\"\"\n        s, c = y[0], y[1]\n        e = Etot - c\n        ds_dt = -k1 * s * e + k_1 * c\n        dc_dt = k1 * s * e - (k_1 + k2) * c\n        return np.array([ds_dt, dc_dt])\n\n    def J_f(y):\n        \"\"\"Jacobian of f(y)\"\"\"\n        s, c = y[0], y[1]\n        # df1/ds, df1/dc\n        # df2/ds, df2/dc\n        J = np.array([\n            [-k1 * (Etot - c), k1 * s + k_1],\n            [k1 * (Etot - c), -k1 * s - (k_1 + k2)]\n        ])\n        return J\n\n    # 3. Radau IIA (s=2) method coefficients\n    a11, a12 = 5.0 / 12.0, -1.0 / 12.0\n    a21, a22 = 3.0 / 4.0, 1.0 / 4.0\n\n    # 4. Define test cases for the step size h\n    test_cases_h = [1.0e-6, 1.0e-3, 1.0e-1, 1.0e1]\n\n    # 5. Newton solver parameters\n    tol = 1.0e-12\n    max_iter = 50\n    sigma = 1.0e-4  # Armijo condition parameter\n\n    results = []\n\n    # 6. Loop over each test case\n    for h in test_cases_h:\n        # Initial guess for stage values Y1, Y2\n        Z = np.concatenate([y_n, y_n])\n        \n        num_iter = -1 # Default to failure\n\n        for k in range(max_iter):\n            Y1, Y2 = Z[0:2], Z[2:4]\n\n            # Calculate residual F(Z)\n            f_Y1 = f(Y1)\n            f_Y2 = f(Y2)\n            F1 = Y1 - y_n - h * (a11 * f_Y1 + a12 * f_Y2)\n            F2 = Y2 - y_n - h * (a21 * f_Y1 + a22 * f_Y2)\n            F_Z = np.concatenate([F1, F2])\n\n            # Check for convergence\n            res_norm_sq = np.dot(F_Z, F_Z)\n            if np.sqrt(res_norm_sq) < tol:\n                num_iter = k\n                break\n\n            # Assemble the 4x4 Jacobian J_F(Z)\n            J_f_Y1 = J_f(Y1)\n            J_f_Y2 = J_f(Y2)\n            I2 = np.identity(2)\n\n            J_F = np.block([\n                [I2 - h * a11 * J_f_Y1, -h * a12 * J_f_Y2],\n                [-h * a21 * J_f_Y1, I2 - h * a22 * J_f_Y2]\n            ])\n\n            # Solve the linear system for Newton step dZ\n            try:\n                dZ = np.linalg.solve(J_F, -F_Z)\n            except np.linalg.LinAlgError:\n                # Jacobian is singular, can't proceed\n                break\n\n            # Backtracking line search\n            alpha = 1.0\n            while alpha > 1e-8:\n                Z_new = Z + alpha * dZ\n                Y1_new, Y2_new = Z_new[0:2], Z_new[2:4]\n                f_Y1_new, f_Y2_new = f(Y1_new), f(Y2_new)\n                F1_new = Y1_new - y_n - h * (a11 * f_Y1_new + a12 * f_Y2_new)\n                F2_new = Y2_new - y_n - h * (a21 * f_Y1_new + a22 * f_Y2_new)\n                F_new = np.concatenate([F1_new, F2_new])\n                \n                res_norm_new_sq = np.dot(F_new, F_new)\n                \n                # Check Armijo condition\n                if res_norm_new_sq <= (1 - 2 * sigma * alpha) * res_norm_sq:\n                    Z = Z_new\n                    break\n                \n                alpha /= 2.0\n            else:\n                # Line search failed to find a step\n                break\n\n        # After Newton loop, if num_iter is still -1, it means we hit max_iter\n        if num_iter == -1 and k == max_iter - 1:\n            # Check final residual if loop terminated\n            Y1, Y2 = Z[0:2], Z[2:4]\n            f_Y1, f_Y2 = f(Y1), f(Y2)\n            F1 = Y1 - y_n - h * (a11 * f_Y1 + a12 * f_Y2)\n            F2 = Y2 - y_n - h * (a21 * f_Y1 + a22 * f_Y2)\n            F_Z = np.concatenate([F1, F2])\n            if np.linalg.norm(F_Z) < tol:\n                num_iter = k + 1\n        \n        results.append(num_iter)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}