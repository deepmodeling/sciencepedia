{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握粒子滤波，我们必须从其核心机制——更新步骤——开始。本练习将引导您一步步具体计算如何利用新的测量信息来精确化我们的状态估计。通过这个血糖监测的实例，您将亲身体验粒子如何根据其解释观测值的可能性被重新“赋权”，这是贝叶斯推断中的一个基本概念。",
            "id": "3917036",
            "problem": "一位生物医学工程师正在使用粒子滤波来估计一位1型糖尿病患者在使用连续血糖监测仪（CGM）进行常规监测时的血浆葡萄糖浓度。隐状态 $x_t$ 表示在时间 $t$ 时的血浆葡萄糖浓度（单位：mg/dL），观测模型由一个具有已知传感器噪声方差的高斯似然指定。该工程师已经完成了预测步骤，并生成了一个带有相关先验权重的粒子集。时间 $t$ 的观测值是一个单一的 CGM 读数，目标是计算归一化的重要性权重和血浆葡萄糖的滤波后验均值。生理学背景是符合现实的：由于传感器噪声和校准不确定性，CGM 传感器在真实血浆葡萄糖值周围表现出具有已知标准差的近似高斯测量误差。\n\n使用以下科学上合理的数据：\n- 粒子数 $N$ 为 $5$。\n- 预测的粒子状态（单位：mg/dL）：$x_t^{(1)} = 140$, $x_t^{(2)} = 148$, $x_t^{(3)} = 152$, $x_t^{(4)} = 160$, $x_t^{(5)} = 172$。\n- 先验权重（总和为 $1$）：$w_{t-1}^{(1)} = 0.10$, $w_{t-1}^{(2)} = 0.25$, $w_{t-1}^{(3)} = 0.30$, $w_{t-1}^{(4)} = 0.20$, $w_{t-1}^{(5)} = 0.15$。\n- 时间 $t$ 的观测值（CGM 读数，单位：mg/dL）：$y_t = 154$。\n- 测量噪声标准差：$\\sigma_v = 6$ mg/dL，其中似然 $p(y_t \\mid x_t)$ 被建模为以 $x_t$ 为中心、方差为 $\\sigma_v^2$ 的高斯分布。\n\n从贝叶斯推断和粒子滤波中的序列重要性采样的基本原理出发，计算：\n1. 使用测量似然和先验权重，计算 $i = 1, \\dots, N$ 的未归一化重要性权重 $\\tilde{w}_t^{(i)}$。\n2. 通过将每个 $\\tilde{w}_t^{(i)}$ 除以所有粒子的总和，得到归一化权重 $\\bar{w}_t^{(i)}$。\n3. 滤波后验均值 $\\hat{x}_t = \\sum_{i=1}^{N} \\bar{w}_t^{(i)} x_t^{(i)}$。\n\n然后，相对于典型的血糖目标，对 $\\hat{x}_t$ 的值提供一个简要的临床解释。以 mg/dL 为单位表示 $\\hat{x}_t$ 的最终数值，并将答案四舍五入到四位有效数字。最终方框内的答案必须只包含数值，不带单位。",
            "solution": "这个问题有科学依据、提法明确、客观，并包含了计算出唯一且有意义解所需的所有信息。它代表了序列重要性采样（粒子滤波的核心）在现实生物医学状态估计任务中的一个标准应用。所有提供的数据在物理上和生理上都是合理的。因此，该问题被认为是有效的。\n\n目标是使用粒子滤波计算隐状态（血浆葡萄糖浓度 $x_t$）的滤波后验均值。我们给定了一个由 $N=5$ 个粒子组成的集合 $\\{x_t^{(i)}\\}_{i=1}^N$，这些粒子代表了从预测状态分布 $p(x_t \\mid y_{1:t-1})$ 中抽取的样本。每个粒子都有一个相关的先验权重 $w_{t-1}^{(i)}$。对于一个标准的粒子滤波器，如果没有除状态转移模型之外的特定提议分布，这个权重是从前一个时间步的后验权重继承而来的，并满足 $\\sum_{i=1}^N w_{t-1}^{(i)} = 1$。在接收到新的测量值 $y_t$ 后，我们根据贝叶斯准则更新这些权重。\n\n给定截至时间 $t$ 的所有观测值，状态 $x_t$ 的后验分布由贝叶斯定理给出：\n$$p(x_t \\mid y_{1:t}) \\propto p(y_t \\mid x_t) p(x_t \\mid y_{1:t-1})$$\n此处，$p(y_t \\mid x_t)$ 是似然，$p(x_t \\mid y_{1:t-1})$ 是先验（或预测）分布。在粒子滤波器中，先验分布由加权粒子集近似：\n$$p(x_t \\mid y_{1:t-1}) \\approx \\sum_{i=1}^N w_{t-1}^{(i)} \\delta(x_t - x_t^{(i)})$$\n其中 $\\delta(\\cdot)$ 是狄拉克δ函数。\n\n更新步骤涉及为每个粒子计算新的重要性权重。第 $i$ 个粒子的未归一化重要性权重 $\\tilde{w}_t^{(i)}$ 是通过将其先验权重与给定该粒子状态下的观测似然相乘来计算的：\n$$ \\tilde{w}_t^{(i)} = w_{t-1}^{(i)} p(y_t \\mid x_t^{(i)}) $$\n似然 $p(y_t \\mid x_t)$ 被建模为均值为 $x_t$、方差为 $\\sigma_v^2$ 的高斯分布。其概率密度函数为：\n$$p(y_t \\mid x_t^{(i)}) = \\frac{1}{\\sqrt{2\\pi\\sigma_v^2}} \\exp\\left(-\\frac{(y_t - x_t^{(i)})^2}{2\\sigma_v^2}\\right)$$\n常数项 $\\frac{1}{\\sqrt{2\\pi\\sigma_v^2}}$ 是所有粒子的一个公共缩放因子，在计算中间的未归一化权重时可以省略，因为它将在归一化步骤中被抵消。因此，我们可以计算成比例的未归一化权重为 $\\tilde{w}_t^{(i)} \\propto w_{t-1}^{(i)} \\exp\\left(-\\frac{(y_t - x_t^{(i)})^2}{2\\sigma_v^2}\\right)$。\n\n给定的数据如下：\n- 粒子数：$N = 5$。\n- 粒子状态 (mg/dL)：$x_t^{(1)} = 140$, $x_t^{(2)} = 148$, $x_t^{(3)} = 152$, $x_t^{(4)} = 160$, $x_t^{(5)} = 172$。\n- 先验权重：$w_{t-1}^{(1)} = 0.10$, $w_{t-1}^{(2)} = 0.25$, $w_{t-1}^{(3)} = 0.30$, $w_{t-1}^{(4)} = 0.20$, $w_{t-1}^{(5)} = 0.15$。\n- 观测值 (mg/dL)：$y_t = 154$。\n- 测量噪声标准差 (mg/dL)：$\\sigma_v = 6$，所以方差为 $\\sigma_v^2 = 36$。\n\n**1. 未归一化重要性权重 $\\tilde{w}_t^{(i)}$ 的计算**\n\n我们为每个粒子计算指数项 $-\\frac{(y_t - x_t^{(i)})^2}{2\\sigma_v^2} = -\\frac{(154 - x_t^{(i)})^2}{72}$。\n- 对于 $i=1$：$-\\frac{(154 - 140)^2}{72} = -\\frac{14^2}{72} = -\\frac{196}{72} = -\\frac{49}{18}$。\n- 对于 $i=2$：$-\\frac{(154 - 148)^2}{72} = -\\frac{6^2}{72} = -\\frac{36}{72} = -0.5$。\n- 对于 $i=3$：$-\\frac{(154 - 152)^2}{72} = -\\frac{2^2}{72} = -\\frac{4}{72} = -\\frac{1}{18}$。\n- 对于 $i=4$：$-\\frac{(154 - 160)^2}{72} = -\\frac{(-6)^2}{72} = -\\frac{36}{72} = -0.5$。\n- 对于 $i=5$：$-\\frac{(154 - 172)^2}{72} = -\\frac{(-18)^2}{72} = -\\frac{324}{72} = -4.5$。\n\n现在，我们计算未归一化的权重，$\\tilde{w}_t^{(i)} \\propto w_{t-1}^{(i)} \\exp(\\dots)$:\n- $\\tilde{w}_t^{(1)} \\propto 0.10 \\times \\exp(-49/18) \\approx 0.10 \\times 0.065733 = 0.0065733$\n- $\\tilde{w}_t^{(2)} \\propto 0.25 \\times \\exp(-0.5) \\approx 0.25 \\times 0.606531 = 0.1516328$\n- $\\tilde{w}_t^{(3)} \\propto 0.30 \\times \\exp(-1/18) \\approx 0.30 \\times 0.945959 = 0.2837877$\n- $\\tilde{w}_t^{(4)} \\propto 0.20 \\times \\exp(-0.5) \\approx 0.20 \\times 0.606531 = 0.1213062$\n- $\\tilde{w}_t^{(5)} \\propto 0.15 \\times \\exp(-4.5) \\approx 0.15 \\times 0.011109 = 0.0016664$\n\n**2. 归一化权重 $\\bar{w}_t^{(i)}$ 的计算**\n\n首先，对未归一化的权重求和以找到归一化常数：\n$$ S = \\sum_{j=1}^{N} \\tilde{w}_t^{(j)} \\approx 0.0065733 + 0.1516328 + 0.2837877 + 0.1213062 + 0.0016664 \\approx 0.5649664 $$\n接下来，通过除以总和 $S$ 来归一化每个权重：$\\bar{w}_t^{(i)} = \\frac{\\tilde{w}_t^{(i)}}{S}$。\n- $\\bar{w}_t^{(1)} = \\frac{0.0065733}{0.5649664} \\approx 0.0116348$\n- $\\bar{w}_t^{(2)} = \\frac{0.1516328}{0.5649664} \\approx 0.2683931$\n- $\\bar{w}_t^{(3)} = \\frac{0.2837877}{0.5649664} \\approx 0.5023101$\n- $\\bar{w}_t^{(4)} = \\frac{0.1213062}{0.5649664} \\approx 0.2147139$\n- $\\bar{w}_t^{(5)} = \\frac{0.0016664}{0.5649664} \\approx 0.0029496$\n这些归一化权重的总和约等于 $1$，符合预期。\n\n**3. 滤波后验均值 $\\hat{x}_t$ 的计算**\n\n滤波后验均值在时间 $t$ 提供了最终的状态估计，它是使用新的归一化权重对粒子状态进行的加权平均：\n$$ \\hat{x}_t = \\sum_{i=1}^{N} \\bar{w}_t^{(i)} x_t^{(i)} $$\n代入数值：\n$$ \\hat{x}_t \\approx (0.0116348 \\times 140) + (0.2683931 \\times 148) + (0.5023101 \\times 152) + (0.2147139 \\times 160) + (0.0029496 \\times 172) $$\n$$ \\hat{x}_t \\approx 1.628872 + 39.722179 + 76.351135 + 34.354224 + 0.507331 $$\n$$ \\hat{x}_t \\approx 152.563741 $$\n四舍五入到四位有效数字，滤波后验均值为 $152.6$ mg/dL。\n\n**临床解释**\n\n血浆葡萄糖浓度的滤波估计值为 $\\hat{x}_t \\approx 152.6$ mg/dL。这个值代表了模型对真实血糖水平的最佳估计，它融合了先验预测（由初始加权粒子代表）和新的 CGM 测量值 $y_t=154$ mg/dL。该估计值与测量值非常接近，因为来自预测步骤的最可能粒子 $x_t^{(3)}=152$ mg/dL，它具有最高的先验权重（$w_{t-1}^{(3)} = 0.30$），同时也是最接近新观测值的粒子。这种高先验置信度和高似然的组合导致该粒子获得了非常大的后验权重（$\\bar{w}_t^{(3)} \\approx 0.50$），从而极大地影响了后验均值。\n\n在临床背景下，$152.6$ mg/dL 的血糖水平被认为是轻度升高（轻度高血糖症）。根据 American Diabetes Association 的建议，糖尿病患者的典型血糖目标通常是餐前 $80-130$ mg/dL，餐后一到两小时低于 $180$ mg/dL。该估计值在可接受的餐后范围内，但高于餐前目标，表明该个体的血糖有偏高趋势，但尚未达到需要立即警惕的水平。与单独的原始传感器读数相比，这个滤波后的估计值提供了对血糖状态更稳健的描述，因为它融合了关于系统动态和过去状态的知识。",
            "answer": "$$\\boxed{152.6}$$"
        },
        {
            "introduction": "更新粒子权重后，我们面临一个关键挑战：权重退化，即少数粒子占据了估计的主导地位。若直接继续进行，会导致计算效率低下和跟踪性能变差。本练习深入探讨了何时进行重采样的关键决策，引入了有效样本量 ($N_{\\mathrm{eff}}$) 这一诊断工具，并基于均方误差 (MSE) 的权衡推导出一个原则性的重采样阈值。",
            "id": "3916982",
            "problem": "一个研究小组正在部署一个序贯蒙特卡洛粒子滤波器 (PF)，旨在使用非线性状态空间模型来估计重症监护室中的血浆葡萄糖浓度。在某个更新时刻 $t$，该粒子滤波器有 $N=8$ 个粒子，其归一化重要性权重 $\\{\\bar{w}_{t}^{(i)}\\}_{i=1}^{8}$ 由下式给出\n$$\n\\left[0.35,\\;0.25,\\;0.15,\\;0.10,\\;0.06,\\;0.04,\\;0.03,\\;0.02\\right].\n$$\n该小组希望基于均方误差 (MSE) 的权衡来设定一个有原则的重采样阈值。他们采用以下决策规则：当有效样本大小低于阈值 $N_{\\mathrm{th}}$ 时，他们将进行重采样。该阈值被隐式地定义为后验均值的自归一化重要性抽样估计器的预期单步预测MSE在重采样和不重采样两种情况下相等时的值。\n\n假设以下建模假设基于标准的重要性抽样方差缩放。令 $\\kappa$ 表示当所有粒子权重相等时，葡萄糖模型在时刻 $t$ 的后验状态方差尺度；取 $\\kappa = 49$，单位为 $(\\text{mg}\\,\\text{dL}^{-1})^{2}$。不进行重采样时，后验均值估计器的单步预测MSE近似为 $\\kappa$ 除以有效样本大小。采用系统重采样和粗糙化处理时，单步预测MSE近似为等权重蒙特卡洛方差与一个附加的样本贫化惩罚项 $\\beta$ 之和；取 $\\beta = 1.225$，单位为 $(\\text{mg}\\,\\text{dL}^{-1})^{2}$。\n\n任务：\n1) 从有效样本大小的定义出发（即产生与当前加权样本相同估计器方差的等权重样本数量），推导一个用 $\\{\\bar{w}_{t}^{(i)}\\}_{i=1}^{N}$ 表示 $N_{\\mathrm{eff}}$ 的公式，并根据给定的权重计算 $N_{\\mathrm{eff}}$。\n\n2) 从决策规则出发（即重采样阈值 $N_{\\mathrm{th}}$ 是使得重采样与不重采样的预期单步预测MSE相等时的 $N_{\\mathrm{eff}}$ 值），推导一个用 $N$、$\\kappa$ 和 $\\beta$ 表示 $N_{\\mathrm{th}}$ 的闭式表达式，然后根据所提供的值进行数值计算。\n\n3) 在此生物医学滤波背景下，从后验均值估计器的方差和偏差角度，简要解释选择的 $N_{\\mathrm{th}}$ 远高于或远低于第2项中得到的值会产生的定性后果。\n\n你最终报告的答案应仅为第2项中得到的 $N_{\\mathrm{th}}$ 值，以最简精确分数形式表示（不要用小数近似）。最终答案中不要包含单位。",
            "solution": "所述问题具有科学依据，提法恰当且客观。所有必要的数据和定义均已提供，并且在粒子滤波理论中没有内部矛盾或违反基本原则。因此，我们可以进行完整解答。\n\n该问题要求完成三项与粒子滤波器中重采样相关的任务。我们将按顺序解决它们。\n\n1) 有效样本大小 $N_{\\mathrm{eff}}$ 的推导与计算。\n\n有效样本大小 $N_{\\mathrm{eff}}$ 定义为能够产生与当前 $N$ 个非等权重粒子集合具有相同估计器方差的假设性等权重粒子的数量。\n\n设感兴趣的状态为 $x$，并让粒子滤波器使用一组 $N$ 个粒子 $\\{x_t^{(i)}\\}_{i=1}^{N}$ 及其对应的归一化重要性权重 $\\{\\bar{w}_{t}^{(i)}\\}_{i=1}^{N}$（满足 $\\sum_{i=1}^{N} \\bar{w}_{t}^{(i)} = 1$）来近似其后验分布。后验均值通过 $\\hat{E}[x_t] = \\sum_{i=1}^{N} \\bar{w}_{t}^{(i)} x_t^{(i)}$ 来估计。\n\n假设粒子 $x_t^{(i)}$ 是从方差为 $\\sigma^2_p$ 的提议分布中独立同分布地抽取的样本，则该估计器的方差为：\n$$ \\text{Var}(\\hat{E}[x_t]) = \\text{Var}\\left(\\sum_{i=1}^{N} \\bar{w}_{t}^{(i)} x_t^{(i)}\\right) = \\sum_{i=1}^{N} (\\bar{w}_{t}^{(i)})^2 \\text{Var}(x_t^{(i)}) = \\sigma_p^2 \\sum_{i=1}^{N} (\\bar{w}_{t}^{(i)})^2 $$\n现在，考虑一个大小为 $N_{\\mathrm{eff}}$ 的假设性样本，其权重均等，即 $w^{(j)} = 1/N_{\\mathrm{eff}}$，对于 $j=1, \\dots, N_{\\mathrm{eff}}$。对于这个均匀样本，均值估计器的方差为：\n$$ \\text{Var}(\\hat{E}_{\\text{unif}}[x_t]) = \\sigma_p^2 \\sum_{j=1}^{N_{\\mathrm{eff}}} \\left(\\frac{1}{N_{\\mathrm{eff}}}\\right)^2 = \\sigma_p^2 \\cdot N_{\\mathrm{eff}} \\cdot \\frac{1}{N_{\\mathrm{eff}}^2} = \\frac{\\sigma_p^2}{N_{\\mathrm{eff}}} $$\n根据 $N_{\\mathrm{eff}}$ 的定义，令两个方差相等：\n$$ \\frac{\\sigma_p^2}{N_{\\mathrm{eff}}} = \\sigma_p^2 \\sum_{i=1}^{N} (\\bar{w}_{t}^{(i)})^2 $$\n求解 $N_{\\mathrm{eff}}$，我们得到标准公式：\n$$ N_{\\mathrm{eff}} = \\frac{1}{\\sum_{i=1}^{N} (\\bar{w}_{t}^{(i)})^2} $$\n对于给定的问题，我们有 $N=8$ 且权重 $\\{\\bar{w}_{t}^{(i)}\\}_{i=1}^{8}$ 为 $[0.35, 0.25, 0.15, 0.10, 0.06, 0.04, 0.03, 0.02]$。我们计算权重的平方和：\n$$ \\sum_{i=1}^{8} (\\bar{w}_{t}^{(i)})^2 = (0.35)^2 + (0.25)^2 + (0.15)^2 + (0.10)^2 + (0.06)^2 + (0.04)^2 + (0.03)^2 + (0.02)^2 $$\n$$ \\sum_{i=1}^{8} (\\bar{w}_{t}^{(i)})^2 = 0.1225 + 0.0625 + 0.0225 + 0.0100 + 0.0036 + 0.0016 + 0.0009 + 0.0004 = 0.224 $$\n因此，有效样本大小为：\n$$ N_{\\mathrm{eff}} = \\frac{1}{0.224} = \\frac{1}{224/1000} = \\frac{1000}{224} = \\frac{125}{28} \\approx 4.46 $$\n\n2) 重采样阈值 $N_{\\mathrm{th}}$ 的推导与计算。\n\n重采样阈值 $N_{\\mathrm{th}}$ 被定义为在有重采样和无重采样两种情况下，预期单步预测均方误差 (MSE) 相等时的 $N_{\\mathrm{eff}}$ 值。问题为这些MSE提供了近似值：\n$$ \\text{MSE}_{\\text{no-resample}} \\approx \\frac{\\kappa}{N_{\\mathrm{eff}}} $$\n$$ \\text{MSE}_{\\text{resample}} \\approx \\frac{\\kappa}{N} + \\beta $$\n这里，$\\kappa$ 是后验状态方差尺度，$N$ 是粒子总数，$\\beta$ 是样本贫化惩罚项。项 $\\kappa/N$ 代表等权重蒙特卡洛估计器的方差。决策规则是在阈值 $N_{\\mathrm{eff}} = N_{\\mathrm{th}}$ 处令MSE相等：\n$$ \\frac{\\kappa}{N_{\\mathrm{th}}} = \\frac{\\kappa}{N} + \\beta $$\n我们求解此方程以得到 $N_{\\mathrm{th}}$。首先，我们合并右侧的项：\n$$ \\frac{\\kappa}{N_{\\mathrm{th}}} = \\frac{\\kappa + N\\beta}{N} $$\n将两边取倒数得到：\n$$ \\frac{N_{\\mathrm{th}}}{\\kappa} = \\frac{N}{\\kappa + N\\beta} $$\n最后，乘以 $\\kappa$ 得到阈值的闭式表达式：\n$$ N_{\\mathrm{th}} = \\frac{\\kappa N}{\\kappa + N\\beta} $$\n给定值为 $N=8$，$\\kappa=49$，$\\beta=1.225$。为确保得到一个精确的分数答案，我们将 $\\beta$ 转换为分数：$\\beta = 1.225 = \\frac{1225}{1000} = \\frac{245}{200} = \\frac{49}{40}$。\n现在我们将这些值代入 $N_{\\mathrm{th}}$ 的表达式中：\n$$ N_{\\mathrm{th}} = \\frac{49 \\cdot 8}{49 + 8 \\cdot \\left(\\frac{49}{40}\\right)} $$\n首先，我们简化分母：\n$$ 49 + 8 \\cdot \\frac{49}{40} = 49 + \\frac{49}{5} = \\frac{5 \\cdot 49}{5} + \\frac{49}{5} = \\frac{6 \\cdot 49}{5} $$\n现在我们将其代回 $N_{\\mathrm{th}}$ 的表达式中：\n$$ N_{\\mathrm{th}} = \\frac{49 \\cdot 8}{\\frac{6 \\cdot 49}{5}} = \\frac{49 \\cdot 8 \\cdot 5}{6 \\cdot 49} $$\n$49$ 这个因子被消掉了：\n$$ N_{\\mathrm{th}} = \\frac{8 \\cdot 5}{6} = \\frac{40}{6} = \\frac{20}{3} $$\n\n3) 选择 $N_{\\mathrm{th}}$ 的定性后果。\n\n$N_{\\mathrm{th}} = 20/3 \\approx 6.67$ 这个值代表了基于所提供的MSE模型进行重采样的最优权衡点。显著偏离此值会对滤波器的性能产生有害后果，特别是会影响后验均值估计器的方差。\n\n选择远高于 $20/3$ 的 $N_{\\mathrm{th}}$：这会导致过于频繁的重采样。即使粒子权重没有高度退化，滤波器也会进行重采样。虽然每一步都重采样会将单步估计器方差降至其最小值 ($\\kappa/N$)，但这一行为并非没有代价。重采样的随机性引入了其自身的变异性，表现为样本贫化——随着时间的推移，粒子变得高度相关，从而导致粒子多样性的丧失。模型通过加性惩罚项 $\\beta$ 来捕捉这个代价。过于频繁地重采样会不必要地招致惩罚项 $\\beta$，使平均MSE高于可达到的最小值。尽管每次重采样后估计器瞬间是无偏的，但由于贫化的粒子集无法适应新信息，估计器在多个时间步长上的方差会增加。\n\n选择远低于 $20/3$ 的 $N_{\\mathrm{th}}$：这会导致不频繁的重采样。滤波器在干预之前会容忍非常高程度的粒子退化。随着滤波器在不重采样的情况下演化，重要性权重的方差会增加，导致 $N_{\\mathrm{eff}}$ 急剧下降。后验均值估计器的方差（近似为 $\\kappa/N_{\\mathrm{eff}}$）将无界增长。滤波器的计算资源被浪费在传播大量权重可忽略不计的粒子上，而估计值仅依赖于极少数“更适应”的粒子。这会导致估计不稳定且方差很高。虽然这种选择避免了样本贫化惩罚项 $\\beta$，但其代价是由于粒子退化而导致的灾难性的估计器方差，从而导致MSE高得多，并使滤波器在跟踪血浆葡萄糖浓度方面无效。该估计器在技术上仍是无偏的，但其极端的方差使其在实践中毫无用处。",
            "answer": "$$\\boxed{\\frac{20}{3}}$$"
        },
        {
            "introduction": "理论通过实践才具有生命力。这最后一个动手实践将挑战您为一个非线性生物医学模型编写代码，实现自举粒子滤波的单步流程。本练习不仅是简单的代码实现，更重要的是，它模拟了模型失配这一现实世界中的难题，指导您运用有效样本量 ($\\mathrm{ESS}$) 来诊断您假设的模型参数中的误差如何影响滤波器性能并可能导致退化。",
            "id": "3917022",
            "problem": "考虑一个标量潜在生理状态 $x_t$，它根据一个非线性状态空间模型演化，并通过一个带有加性高斯噪声的非线性传感器进行观测。生成性假设为：$x_t = f(x_{t-1}) + \\eta_t$（其中 $\\eta_t \\sim \\mathcal{N}(0,Q)$）以及 $y_t = h(x_t) + v_t$（其中 $v_t \\sim \\mathcal{N}(0,R)$）。需要使用自举粒子滤波器，在给定单个观测值 $y_t$ 的情况下，执行一个预测-更新时间步。自举粒子滤波器使用转移先验作为提议分布，并根据观测似然对粒子进行加权。使用 Bayes 定理以及过程噪声和测量噪声的独立性作为基本依据。除这些原则外，不要使用任何捷径公式。状态 $x_t$ 和观测值 $y_t$ 是无量纲标量，因此无需报告物理单位。\n\n定义非线性状态转移为 $f(x) = x + \\alpha \\sin(x)$，非线性观测为 $h(x) = \\dfrac{1}{1 + \\exp\\left(-\\beta(x - x_0)\\right)}$。时刻 $t-1$ 的先验粒子分布为 $\\mathcal{N}(m_{t-1},P_{t-1})$，其中 $m_{t-1} = 0.0$ 且 $P_{t-1} = 1.0$。真实数据生成参数为 $\\alpha_{\\text{true}} = 0.7$，$\\beta_{\\text{true}} = 1.0$，$x_{0,\\text{true}} = 0.0$，$Q_{\\text{true}} = 0.2$ 和 $R_{\\text{true}} = 0.1$。按如下方式生成单个观测值 $y_t$：从 $\\mathcal{N}(m_{t-1},P_{t-1})$ 中采样 $x_{t-1}^{\\text{true}}$，通过 $x_t^{\\text{true}} = f_{\\text{true}}(x_{t-1}^{\\text{true}}) + \\eta_t^{\\text{true}}$（其中 $\\eta_t^{\\text{true}} \\sim \\mathcal{N}(0,Q_{\\text{true}})$）进行传播，然后从 $y_t = h_{\\text{true}}(x_t^{\\text{true}}) + v_t^{\\text{true}}$（其中 $v_t^{\\text{true}} \\sim \\mathcal{N}(0,R_{\\text{true}})$）中采样 $y_t$。为确保可复现性，所有随机抽样均使用固定的伪随机种子 $123$。\n\n为一组测试用例实现一个自举粒子滤波器时间步，在这些用例中，假设的滤波器模型可能与真实的数据生成模型不匹配。对每个测试用例：\n- 抽取 $N$ 个粒子 $x_{t-1}^{(i)} \\sim \\mathcal{N}(m_{t-1},P_{t-1})$。\n- 在滤波器假设的转移 $f_{\\text{assumed}}(x) = x + \\alpha_{\\text{assumed}} \\sin(x)$ 和加性过程噪声 $\\eta_t^{(i)} \\sim \\mathcal{N}(0,Q_{\\text{assumed}})$ 下传播粒子，以获得提议样本 $x_t^{(i)}$。\n- 使用滤波器假设的观测 $h_{\\text{assumed}}$ 和测量噪声方差 $R_{\\text{assumed}}$ 计算未归一化权重 $w^{(i)} \\propto p(y_t \\mid x_t^{(i)})$，然后将权重归一化，使其总和为 $1$。\n- 为每个测试用例报告有效样本量 $\\mathrm{ESS} = \\dfrac{1}{\\sum_{i=1}^{N} (w^{(i)})^2}$，结果为四舍五入到六位小数的浮点数。有效样本量是衡量粒子退化的标准权重分散度量。\n\n测试套件包含以下六个案例，所有案例都使用上述由真实参数生成的同一个 $y_t$：\n1. 匹配模型（理想路径）：$N = 1000$，$\\alpha_{\\text{assumed}} = 0.7$，$Q_{\\text{assumed}} = 0.2$，$h_{\\text{assumed}}$ 为相同的 sigmoid 函数，其中 $\\beta_{\\text{assumed}} = 1.0$ 且 $x_{0,\\text{assumed}} = 0.0$，$R_{\\text{assumed}} = 0.1$。\n2. 低估的过程噪声：$N = 1000$，$\\alpha_{\\text{assumed}} = 0.7$，$Q_{\\text{assumed}} = 0.02$，$h_{\\text{assumed}}$ 为 sigmoid 函数，其中 $\\beta_{\\text{assumed}} = 1.0$，$x_{0,\\text{assumed}} = 0.0$，$R_{\\text{assumed}} = 0.1$。\n3. 错误指定的观测映射：$N = 1000$，$\\alpha_{\\text{assumed}} = 0.7$，$Q_{\\text{assumed}} = 0.2$，$h_{\\text{assumed}}(x) = x$（恒等函数），$R_{\\text{assumed}} = 0.1$。\n4. 大的假设测量噪声：$N = 1000$，$\\alpha_{\\text{assumed}} = 0.7$，$Q_{\\text{assumed}} = 0.2$，$h_{\\text{assumed}}$ 为 sigmoid 函数，其中 $\\beta_{\\text{assumed}} = 1.0$，$x_{0,\\text{assumed}} = 0.0$，$R_{\\text{assumed}} = 1.0$。\n5. 小粒子数边界情况：$N = 20$，$\\alpha_{\\text{assumed}} = 0.7$，$Q_{\\text{assumed}} = 0.2$，$h_{\\text{assumed}}$ 为 sigmoid 函数，其中 $\\beta_{\\text{assumed}} = 1.0$，$x_{0,\\text{assumed}} = 0.0$，$R_{\\text{assumed}} = 0.1$。\n6. 近乎确定的假设动态（边缘案例）：$N = 1000$，$\\alpha_{\\text{assumed}} = 0.7$，$Q_{\\text{assumed}} = 10^{-6}$，$h_{\\text{assumed}}$ 为 sigmoid 函数，其中 $\\beta_{\\text{assumed}} = 1.0$，$x_{0,\\text{assumed}} = 0.0$，$R_{\\text{assumed}} = 0.1$。\n\n你的程序应生成单行输出，其中包含六个测试用例的有效样本量，格式为方括号括起来的逗号分隔列表（例如 $[e_1,e_2,e_3,e_4,e_5,e_6]$），其中每个 $e_k$ 都四舍五入到六位小数。",
            "solution": "该问题要求实现自举粒子滤波器的一个时间步，以估计一个潜在的生理状态。通过计算有效样本量（ESS）来评估滤波器在几种模型不匹配情景下的性能。解决方案按要求从第一性原理构建。\n\n**1. 基本原理：Bayesian 滤波**\n\n状态空间滤波的核心目标是在给定一系列观测值 $y_{1:t} = \\{y_1, y_2, \\dots, y_t\\}$ 的条件下，递归地估计在时刻 $t$ 的隐藏状态 $x_t$ 的概率分布。这由后验分布 $p(x_t | y_{1:t})$ 来描述。估计过程包括两个阶段：\n\n- **预测：** 上一时间步的后验分布 $p(x_{t-1} | y_{1:t-1})$ 通过状态转移模型 $p(x_t | x_{t-1})$ 向前传播，从而得到当前状态的先验（或预测）分布：\n$$p(x_t | y_{1:t-1}) = \\int p(x_t | x_{t-1}) p(x_{t-1} | y_{1:t-1}) dx_{t-1}$$\n状态转移模型由 $x_t = f(x_{t-1}) + \\eta_t$ 给出，其中过程噪声 $\\eta_t \\sim \\mathcal{N}(0, Q)$。\n\n- **更新：** 预测分布通过 Bayes 定理使用新的观测值 $y_t$ 进行更新。观测模型由 $y_t = h(x_t) + v_t$ 给出，其中测量噪声 $v_t \\sim \\mathcal{N}(0, R)$。给定状态下观测值的似然为 $p(y_t | x_t)$。\n$$p(x_t | y_{1:t}) = \\frac{p(y_t | x_t) p(x_t | y_{1:t-1})}{p(y_t | y_{1:t-1})}$$\n分母 $p(y_t | y_{1:t-1}) = \\int p(y_t | x_t) p(x_t | y_{1:t-1}) dx_t$ 是一个归一化常数。\n\n对于问题中指定的非线性函数 $f(x)$ 和 $h(x)$，这些积分在解析上是难解的。\n\n**2. 粒子滤波器近似**\n\n粒子滤波器是一类序贯蒙特卡洛方法，它通过用一组有限的 $N$ 个加权样本（或称“粒子”）$\\{x_t^{(i)}, \\tilde{w}_t^{(i)}\\}_{i=1}^N$ 来近似后验分布，从而规避了这种难解性。后验分布表示为 Dirac delta 函数的加权和：\n$$p(x_t | y_{1:t}) \\approx \\sum_{i=1}^N \\tilde{w}_t^{(i)} \\delta(x_t - x_t^{(i)})$$\n其中 $\\sum_{i=1}^N \\tilde{w}_t^{(i)} = 1$。关键思想是从一个易于处理的提议分布 $q(x_t | x_{t-1}, y_t)$ 中生成粒子，然后分配重要性权重以修正提议分布与真实后验分布之间的差异。\n\n**3. 自举滤波器：一种具体实现**\n\n自举粒子滤波器是最简单和最常见的变体，它使用状态转移先验作为其提议分布：\n$$q(x_t^{(i)} | x_{t-1}^{(i)}, y_t) = p(x_t^{(i)} | x_{t-1}^{(i)})$$\n一般的重要性权重更新规则是 $w_t^{(i)} \\propto w_{t-1}^{(i)} \\frac{p(y_t | x_t^{(i)}) p(x_t^{(i)} | x_{t-1}^{(i)})}{q(x_t^{(i)} | x_{t-1}^{(i)}, y_t)}$。使用自举提议时，$p(x_t^{(i)} | x_{t-1}^{(i)})$ 和 $q(\\cdot)$ 项会相互抵消。假设上一步的权重相等（$w_{t-1}^{(i)} = 1/N$，如重采样后或初始化时的情况），权重更新简化为与观测似然成正比：\n$$w_t^{(i)} \\propto p(y_t | x_t^{(i)})$$\n这种简化使得该算法易于实现。\n\n**4. 单个时间步的算法步骤**\n\n按照问题要求，一个时间步的流程如下：\n\n- **步骤 0：生成单个观测值 $y_t$**\n在运行滤波器之前，我们根据真实模型参数生成一个固定的观测值 $y_t$。使用固定的随机种子 123 确保此过程是可复现的。\n1. 抽取上一时刻的真实状态：$x_{t-1}^{\\text{true}} \\sim \\mathcal{N}(m_{t-1}, P_{t-1})$，其中 $m_{t-1}=0.0$ 且 $P_{t-1}=1.0$。\n2. 传播真实状态：$x_t^{\\text{true}} = f_{\\text{true}}(x_{t-1}^{\\text{true}}) + \\eta_t^{\\text{true}}$，其中 $\\eta_t^{\\text{true}} \\sim \\mathcal{N}(0, Q_{\\text{true}})$，使用 $f_{\\text{true}}(x) = x + \\alpha_{\\text{true}} \\sin(x)$。\n3. 生成观测值：$y_t = h_{\\text{true}}(x_t^{\\text{true}}) + v_t^{\\text{true}}$，其中 $v_t^{\\text{true}} \\sim \\mathcal{N}(0, R_{\\text{true}})$，使用 $h_{\\text{true}}(x) = (1 + \\exp(-\\beta_{\\text{true}}(x - x_{0,\\text{true}})))^{-1}$。\n这个 $y_t$ 值在所有测试用例中保持不变。\n\n- **步骤 1：初始化**\n对于每个测试用例，我们从代表时刻 $t-1$ 知识的一组 $N$ 个粒子开始。这些粒子从先验分布 $p(x_{t-1})$ 中抽取：\n$$x_{t-1}^{(i)} \\sim \\mathcal{N}(m_{t-1}, P_{t-1}) \\quad \\text{for } i=1, \\dots, N$$\n\n- **步骤 2：预测（传播）**\n每个粒子 $x_{t-1}^{(i)}$ 通过滤波器假设的状态动态进行传播，以生成一个提议粒子 $x_t^{(i)}$。这是一个从提议分布 $p(x_t | x_{t-1}^{(i)})$ 中抽取的样本。\n$$x_t^{(i)} = f_{\\text{assumed}}(x_{t-1}^{(i)}) + \\eta_t^{(i)}$$\n其中 $\\eta_t^{(i)} \\sim \\mathcal{N}(0, Q_{\\text{assumed}})$ 且 $f_{\\text{assumed}}(x) = x + \\alpha_{\\text{assumed}} \\sin(x)$。\n\n- **步骤 3：更新（加权）**\n根据给定粒子状态 $x_t^{(i)}$ 下观测值 $y_t$ 的似然，为每个粒子计算未归一化的权重 $w_t^{(i)}$。似然函数 $p(y_t | x_t)$ 由假设的观测模型 $y_t = h_{\\text{assumed}}(x_t) + v_t$（其中 $v_t \\sim \\mathcal{N}(0, R_{\\text{assumed}})$）定义。\n$$w_t^{(i)} \\propto p(y_t | x_t^{(i)}) = \\frac{1}{\\sqrt{2\\pi R_{\\text{assumed}}}} \\exp\\left(-\\frac{(y_t - h_{\\text{assumed}}(x_t^{(i)}))^2}{2 R_{\\text{assumed}}}\\right)$$\n由于权重会被归一化，常数前置因子可以忽略。为保证数值稳定性，最好先计算对数权重，然后再取指数。令 $\\hat{y}_t^{(i)} = h_{\\text{assumed}}(x_t^{(i)})$。未归一化的权重计算如下：$w_t^{(i)} = \\exp\\left( -\\frac{(y_t - \\hat{y}_t^{(i)})^2}{2R_{\\text{assumed}}} \\right)$。\n\n- **步骤 4：归一化**\n将权重归一化，使其总和为 1：\n$$\\tilde{w}_t^{(i)} = \\frac{w_t^{(i)}}{\\sum_{j=1}^N w_t^{(j)}}$$\n\n- **步骤 5：性能评估**\n粒子退化程度——即少数粒子获得大部分权重的现象——由有效样本量 (ESS) 来量化：\n$$\\mathrm{ESS} = \\frac{1}{\\sum_{i=1}^N (\\tilde{w}_t^{(i)})^2}$$\nESS 的范围从 1（完全退化）到 N（所有粒子权重相等）。对于指定的六个测试用例中的每一个，都重复整个过程，使用相同的生成 $y_t$，但根据问题的序贯随机抽样方案抽取新的粒子集。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Implements one step of a bootstrap particle filter for a nonlinear state-space model,\n    calculating the Effective Sample Size (ESS) for six different test cases.\n    \"\"\"\n\n    # --- Step 0: Generate a single reproducible observation y_t ---\n\n    # Fixed random seed for reproducibility\n    rng = np.random.default_rng(123)\n\n    # True data-generating parameters\n    m_tm1 = 0.0\n    P_tm1 = 1.0\n    alpha_true = 0.7\n    beta_true = 1.0\n    x0_true = 0.0\n    Q_true = 0.2\n    R_true = 0.1\n\n    # True model functions\n    def f_true(x):\n        return x + alpha_true * np.sin(x)\n\n    def h_true(x):\n        return 1.0 / (1.0 + np.exp(-beta_true * (x - x0_true)))\n\n    # Generate the single observation y_t\n    x_tm1_true = rng.normal(loc=m_tm1, scale=np.sqrt(P_tm1))\n    eta_t_true = rng.normal(loc=0.0, scale=np.sqrt(Q_true))\n    x_t_true = f_true(x_tm1_true) + eta_t_true\n    v_t_true = rng.normal(loc=0.0, scale=np.sqrt(R_true))\n    y_t = h_true(x_t_true) + v_t_true\n\n    # --- Define Test Cases ---\n    test_cases = [\n        {\n            \"N\": 1000, \"alpha\": 0.7, \"Q\": 0.2,\n            \"h_type\": \"sigmoid\", \"beta\": 1.0, \"x0\": 0.0, \"R\": 0.1\n        },\n        {\n            \"N\": 1000, \"alpha\": 0.7, \"Q\": 0.02,\n            \"h_type\": \"sigmoid\", \"beta\": 1.0, \"x0\": 0.0, \"R\": 0.1\n        },\n        {\n            \"N\": 1000, \"alpha\": 0.7, \"Q\": 0.2,\n            \"h_type\": \"identity\", \"beta\": None, \"x0\": None, \"R\": 0.1\n        },\n        {\n            \"N\": 1000, \"alpha\": 0.7, \"Q\": 0.2,\n            \"h_type\": \"sigmoid\", \"beta\": 1.0, \"x0\": 0.0, \"R\": 1.0\n        },\n        {\n            \"N\": 20, \"alpha\": 0.7, \"Q\": 0.2,\n            \"h_type\": \"sigmoid\", \"beta\": 1.0, \"x0\": 0.0, \"R\": 0.1\n        },\n        {\n            \"N\": 1000, \"alpha\": 0.7, \"Q\": 1e-6,\n            \"h_type\": \"sigmoid\", \"beta\": 1.0, \"x0\": 0.0, \"R\": 0.1\n        },\n    ]\n\n    results = []\n\n    # --- Run Particle Filter for Each Case ---\n    for case in test_cases:\n        N = case[\"N\"]\n        alpha_assumed = case[\"alpha\"]\n        Q_assumed = case[\"Q\"]\n        R_assumed = case[\"R\"]\n\n        # Define assumed model functions for the current case\n        def f_assumed(x):\n            return x + alpha_assumed * np.sin(x)\n\n        if case[\"h_type\"] == \"sigmoid\":\n            beta_assumed = case[\"beta\"]\n            x0_assumed = case[\"x0\"]\n            def h_assumed(x):\n                return 1.0 / (1.0 + np.exp(-beta_assumed * (x - x0_assumed)))\n        else: # identity\n            def h_assumed(x):\n                return x\n\n        # Step 1: Initialization - Draw particles from the prior\n        x_tm1_particles = rng.normal(loc=m_tm1, scale=np.sqrt(P_tm1), size=N)\n\n        # Step 2: Prediction - Propagate particles\n        eta_t_particles = rng.normal(loc=0.0, scale=np.sqrt(Q_assumed), size=N)\n        x_t_particles = f_assumed(x_tm1_particles) + eta_t_particles\n\n        # Step 3: Update - Compute weights\n        # Calculate expected observations for each particle\n        y_hat_particles = h_assumed(x_t_particles)\n        \n        # Calculate log weights for numerical stability\n        log_weights = -0.5 * ((y_t - y_hat_particles)**2) / R_assumed\n\n        # Stabilize by subtracting the max log weight before exponentiating\n        log_weights -= np.max(log_weights)\n        unnormalized_weights = np.exp(log_weights)\n\n        # Step 4: Normalization\n        sum_weights = np.sum(unnormalized_weights)\n        if sum_weights == 0:\n            # Handle case where all weights are zero (underflow)\n            normalized_weights = np.full(N, 1.0 / N)\n        else:\n            normalized_weights = unnormalized_weights / sum_weights\n\n        # Step 5: Calculate Effective Sample Size (ESS)\n        ess = 1.0 / np.sum(normalized_weights**2)\n\n        results.append(ess)\n\n    # Final output formatting\n    # Note: rounding to 6 decimal places as required.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}