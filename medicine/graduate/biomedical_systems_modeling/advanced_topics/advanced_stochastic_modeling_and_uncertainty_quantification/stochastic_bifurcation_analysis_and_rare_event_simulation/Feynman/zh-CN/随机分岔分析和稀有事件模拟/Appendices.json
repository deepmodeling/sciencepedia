{
    "hands_on_practices": [
        {
            "introduction": "理论的基石是能够将其应用于可计算的问题。本练习将引导您使用经典的 Eyring-Kramers 公式，这是估算随机系统中跨越势垒的平均首过时间（MFPT）的基石。通过直接应用此公式 ，您将学习如何将势能面的局部几何结构（通过在极小点和鞍点处的黑塞矩阵来表征）与宏观的转变速率联系起来。",
            "id": "3931118",
            "problem": "考虑一个干细胞分化系统中基因调控网络的表观遗传景观的三维过阻尼朗之万模型，其中状态向量 $X_{t} \\in \\mathbb{R}^{3}$ 根据随机微分方程演化\n$$\n\\mathrm{d}X_{t} = -\\nabla V(X_{t})\\,\\mathrm{d}t + \\sqrt{2\\,\\varepsilon}\\,\\mathrm{d}W_{t},\n$$\n其中 $V:\\mathbb{R}^{3}\\to\\mathbb{R}$ 是一个光滑势（无量纲），$\\varepsilon>0$ 是噪声强度（无量纲），$W_{t}$ 是一个标准的三维维纳过程。两个表型状态对应于局部极小值点 $x_{m}$ 和 $x_{m'}$，主导转变路径经过一个唯一的指数为1的鞍点 $x_{s}$，该鞍点有一个不稳定方向。在 $x_{m}$ 和 $x_{s}$ 附近对势进行局部二次近似，得到Hessian矩阵\n$$\nH(x_{m}) = \\begin{pmatrix} 3.0  0  0 \\\\ 0  2.0  0 \\\\ 0  0  1.0 \\end{pmatrix}, \\quad\nH(x_{s}) = \\begin{pmatrix} -4.0  0  0 \\\\ 0  1.5  0 \\\\ 0  0  0.5 \\end{pmatrix},\n$$\n当解释为漂移项 $-\\nabla V$ 中的线性化速率时，每个元素的单位为 $s^{-1}$。势垒高度为 $\\Delta V = V(x_{s}) - V(x_{m}) = 0.5$，噪声强度为 $\\varepsilon = 0.05$。假设对于这个在鞍点处有单一不稳定方向的多维梯度系统，当 $\\varepsilon$ 很小时，Eyring-Kramers渐近理论适用。\n\n使用 Eyring-Kramers 框架以及在极小值点和鞍点处给定的 Hessian 矩阵，计算从 $x_{m}$ 的吸引盆到 $x_{m'}$ 的平均首达时间 (MFPT)。请用秒作单位表示最终答案，并将答案四舍五入到四位有效数字。",
            "solution": "该问题陈述经核实具有科学依据、问题明确且客观。它为使用指定的 Eyring-Kramers 框架计算多维梯度系统的平均首达时间 (MFPT) 提供了一套完整且一致的已知条件。应用此框架的所有条件，例如小噪声强度和指数为1的鞍点，均已满足。\n\n该问题要求计算从局部极小值点 $x_m$ 的吸引盆出发，穿过鞍点 $x_s$ 处的势垒到达另一状态的平均首达时间 (MFPT)。其控制动力学由一个 $d=3$ 维的过阻尼朗之万方程给出：\n$$\n\\mathrm{d}X_{t} = -\\nabla V(X_{t})\\,\\mathrm{d}t + \\sqrt{2\\,\\varepsilon}\\,\\mathrm{d}W_{t}\n$$\n对于这样一个系统，在小噪声强度 $\\varepsilon$ 的极限下，MFPT（记为 $\\tau$）由 Eyring-Kramers 公式给出。对于多维系统，该公式为：\n$$\n\\tau = \\frac{2\\pi}{|\\lambda_u|} \\sqrt{\\frac{|\\det H(x_s)|}{\\det H(x_m)}} \\exp\\left(\\frac{\\Delta V}{\\varepsilon}\\right)\n$$\n其中：\n- $\\Delta V = V(x_s) - V(x_m)$ 是极小值点和鞍点之间的势能垒。\n- $\\varepsilon$ 是噪声强度。\n- $H(x_m)$ 是势 $V$ 在局部极小值点 $x_m$ 处的 Hessian 矩阵。\n- $H(x_s)$ 是在鞍点 $x_s$ 处的 Hessian 矩阵。\n- $\\lambda_u$ 是 $H(x_s)$ 的唯一负特征值，对应于鞍点处的不稳定方向。$|\\lambda_u|$ 是其大小。\n- $\\det H(x_m)$ 和 $\\det H(x_s)$ 分别是相应 Hessian 矩阵的行列式。该公式依赖于这样一个事实：对于极小值点，$\\det H(x_m) > 0$；对于指数为1的鞍点，$\\det H(x_s)  0$。\n\n该问题提供了以下数值：\n1.  在极小值点 $x_m$ 处的 Hessian 矩阵：\n    $$\n    H(x_{m}) = \\begin{pmatrix} 3.0  0  0 \\\\ 0  2.0  0 \\\\ 0  0  1.0 \\end{pmatrix}\n    $$\n    特征值即对角线元素：$\\lambda_{m,1}=3.0$，$\\lambda_{m,2}=2.0$，以及 $\\lambda_{m,3}=1.0$。问题说明这些元素的单位是 $s^{-1}$。行列式是特征值的乘积：\n    $$\n    \\det H(x_m) = (3.0)\\,(2.0)\\,(1.0) = 6.0 \\, s^{-3}\n    $$\n\n2.  在鞍点 $x_s$ 处的 Hessian 矩阵：\n    $$\n    H(x_{s}) = \\begin{pmatrix} -4.0  0  0 \\\\ 0  1.5  0 \\\\ 0  0  0.5 \\end{pmatrix}\n    $$\n    特征值为 $\\lambda_{s,1}=-4.0$，$\\lambda_{s,2}=1.5$，以及 $\\lambda_{s,3}=0.5$，单位均为 $s^{-1}$。唯一的负特征值是 $\\lambda_u = -4.0 \\, s^{-1}$。其大小为：\n    $$\n    |\\lambda_u| = 4.0 \\, s^{-1}\n    $$\n    鞍点处 Hessian 矩阵的行列式为：\n    $$\n    \\det H(x_s) = (-4.0)\\,(1.5)\\,(0.5) = -3.0 \\, s^{-3}\n    $$\n    该行列式的大小为 $|\\det H(x_s)| = 3.0 \\, s^{-3}$。\n\n3.  势垒高度和噪声强度（无量纲）：\n    $$\n    \\Delta V = 0.5\n    $$\n    $$\n    \\varepsilon = 0.05\n    $$\n    指数部分的参数为：\n    $$\n    \\frac{\\Delta V}{\\varepsilon} = \\frac{0.5}{0.05} = 10\n    $$\n\n现在，我们将这些值代入 Eyring-Kramers 公式计算 $\\tau$。单位是一致的：指前因子的单位是秒，符合时间的要求。\n$$\n\\tau = \\frac{2\\pi}{|\\lambda_u|} \\sqrt{\\frac{|\\det H(x_s)|}{\\det H(x_m)}} \\exp\\left(\\frac{\\Delta V}{\\varepsilon}\\right)\n$$\n$$\n\\tau = \\frac{2\\pi}{4.0 \\, s^{-1}} \\sqrt{\\frac{3.0 \\, s^{-3}}{6.0 \\, s^{-3}}} \\exp(10)\n$$\n$$\n\\tau = \\frac{\\pi}{2.0} \\sqrt{\\frac{1}{2}} \\exp(10) \\, s\n$$\n$$\n\\tau = \\frac{\\pi}{2.0} \\frac{1}{\\sqrt{2}} \\exp(10) \\, s = \\frac{\\pi}{2\\sqrt{2}} \\exp(10) \\, s\n$$\n为简化计算，我们可以将其写作：\n$$\n\\tau = \\frac{\\pi\\sqrt{2}}{4} \\exp(10) \\, s\n$$\n现在我们计算其数值：\n$$\n\\exp(10) \\approx 22026.4658\n$$\n$$\n\\frac{\\pi\\sqrt{2}}{4} \\approx \\frac{(3.14159265...)(1.41421356...)}{4} \\approx 1.11072073\n$$\n$$\n\\tau \\approx 1.11072073 \\times 22026.4658 \\, s \\approx 24467.45 \\, s\n$$\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $2$、$4$、$4$、$6$。第五位数字是 $7$，所以我们将第四位数字向上取整。\n$$\n\\tau \\approx 24470 \\, s\n$$\n这可以用科学记数法表示为 $2.447 \\times 10^4 \\, s$。",
            "answer": "$$\\boxed{2.447 \\times 10^{4}}$$"
        },
        {
            "introduction": "虽然 Kramers 理论为从单个势阱中的逃逸提供了一个优雅的指数分布模型，但许多生物物理系统的行为更为复杂。本练习将理论付诸实践，要求您通过数值模拟来检验逃逸时间分布的“无记忆”特性 。您将开发一套诊断工具来识别非指数行为，从而深入了解多势阱相互作用和分岔附近动力学如何从根本上改变系统的转变特性。",
            "id": "3931108",
            "problem": "考虑一个单生化状态变量的过阻尼随机动力学模型，该模型由一个带加性白噪声的一维随机微分方程控制，该方程由伊藤过阻尼朗之万方程 $dx_t = -U'(x_t)\\,dt + \\sqrt{2D}\\,dW_t$ 定义，其中 $U(x)$ 是一个光滑势，$U'(x)$ 是势的导数，$D$ 是噪声强度，$W_t$ 是一个标准维纳过程。从吸引盆逃逸的稀有事件模拟由首次穿越时间 $T$ 定义，即从左盆穿越到右盆并越过一个吸收阈值的时间。在单一主导准稳态模式的情况下，逃逸时间分布近似为指数分布，具有恒定的风险率。然而，当多阱相互作用产生多个可比较的慢模式或势垒的慢调制时，逃逸时间分布可能变为具有时变风险的非平凡指数混合分布，从而导致非指数生存曲线。\n\n从过阻尼朗之万方程、福克-普朗克算子和首次穿越时间的基本定义出发，通过生存函数和风险函数来测试和诊断无记忆性。生存函数为 $S(t) = \\mathbb{P}(T  t)$，风险函数为 $h(t) = f(t)/S(t)$，其中 $f(t)$ 是 $T$ 的概率密度函数。恒定的风险函数对应于逃逸时间的指数分布，而时变的风险则表明由于多时间尺度和相互作用而产生的非指数行为。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n- 对每个指定的势，使用时间步长为 $dt$、噪声强度为 $D$ 的欧拉-丸山法，模拟 $N$ 条独立的过阻尼朗之万方程轨迹。\n- 记录从 $x_0$ 出发，首次穿越吸收阈值 $x \\geq x_{\\mathrm{th}}$ 的时间 $T$。\n- 在 $T$ 样本的第5和第95个经验百分位数之间的一个包含 $M$ 个点的规则网格上，构建经验生存函数 $\\hat{S}(t)$。\n- 计算一个非指数性得分 $s$，其定义为网格上 $\\log \\hat{S}(t)$ 与其最佳拟合直线之间的归一化均方根偏差。具体来说，令 $\\{\\,(t_j, y_j)\\,\\}_{j=1}^M$ 表示网格点，其中 $y_j = \\log \\hat{S}(t_j)$，并令最小二乘拟合为 $y_j^{\\mathrm{fit}} = \\alpha + \\beta t_j$。定义\n$$\ns = \\sqrt{\\frac{\\sum_{j=1}^M \\left(y_j - y_j^{\\mathrm{fit}}\\right)^2}{\\sum_{j=1}^M \\left(y_j - \\bar{y}\\right)^2}},\n$$\n其中 $\\bar{y} = \\frac{1}{M}\\sum_{j=1}^M y_j$。\n- 通过有限差分 $h_j \\approx \\frac{-(y_{j+1}-y_j)}{t_{j+1}-t_j}$（对于 $j=1,\\dots,M-1$）估计分段风险，并计算其变异系数 $c = \\mathrm{std}(h_j)/\\mathrm{mean}(h_j)$。\n- 对经验 $T$ 与尺度参数等于样本均值 $\\hat{\\mu} = \\frac{1}{N}\\sum_i T_i$ 的指数分布进行柯尔莫哥洛夫-斯米尔诺夫拟合优度检验。使用显著性水平 $\\alpha = 0.05$。\n\n定义诊断规则，当且仅当以下三个条件同时成立时，将分布分类为近似指数分布：柯尔莫哥洛夫-斯米尔诺夫检验的 $p$ 值至少为 $\\alpha$，非指数性得分最多为阈值 $\\tau$，风险变异系数最多为阈值 $\\eta$。使用具体阈值 $\\tau = 0.08$ 和 $\\eta = 0.25$。否则，将分布分类为非指数分布。\n\n模拟以下势和参数的测试套件。在所有情况下，使用欧拉-丸山法，并以秒为单位表示时间。通过选择合适的 $dt$ 和 $t_{\\max}$，确保大多数轨迹在 $t_{\\max}$ 内逃逸，从而保证数值稳定性。\n\n- 情况1（单一主导的阱间逃逸，预期为近似指数分布）：势 $U(x) = a(x^2 - 1)^2$，其中 $a = 1$，噪声强度 $D = 0.25$，初始条件 $x_0 = -1.0$，吸收阈值 $x_{\\mathrm{th}} = 0.0$，时间步长 $dt = 0.01\\,\\mathrm{s}$，最大模拟时间 $t_{\\max} = 40.0\\,\\mathrm{s}$，轨迹数量 $N = 800$。\n- 情况2（多阱相互作用产生多个慢模式，预期为非指数分布）：势 $U(x) = a(x^2 - 1)^2 + h \\exp\\!\\left(-\\frac{(x+1.5)^2}{2\\sigma^2}\\right)$，其中 $a = 1$, $h = 2.5$, $\\sigma = 0.2$，噪声强度 $D = 0.25$，初始条件 $x_0 = -1.8$，吸收阈值 $x_{\\mathrm{th}} = 0.0$，时间步长 $dt = 0.01\\,\\mathrm{s}$，最大模拟时间 $t_{\\max} = 50.0\\,\\mathrm{s}$，轨迹数量 $N = 800$。\n- 情况3（近分岔的倾斜削弱了左侧势垒，产生非指数瞬态）：势 $U(x) = a(x^2 - 1)^2 + v x$，其中 $a = 1$, $v = 1.2$，噪声强度 $D = 0.12$，初始条件 $x_0 = -0.9$，吸收阈值 $x_{\\mathrm{th}} = 0.0$，时间步长 $dt = 0.01\\,\\mathrm{s}$，最大模拟时间 $t_{\\max} = 15.0\\,\\mathrm{s}$，轨迹数量 $N = 800$。\n\n您的程序应产生单行输出，其中包含三个案例的分类结果，形式为方括号内的逗号分隔列表；对于每个案例，如果逃逸时间分布根据上述诊断规则是近似指数分布，则输出布尔值 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。例如，输出必须是 $\\left[\\mathrm{True},\\mathrm{False},\\mathrm{False}\\right]$ 的形式，不得包含其他文本。",
            "solution": "我们从过阻尼朗之万方程 $dx_t = -U'(x_t)\\,dt + \\sqrt{2D}\\,dW_t$ 开始，其中 $U(x)$ 是一个光滑势，$U'(x)$ 是其导数，$D$ 是噪声强度，$W_t$ 是一个标准维纳过程。该动力系统诱导出一个概率密度 $p(x,t)$，该密度根据福克-普朗克方程 $\\partial_t p = \\mathcal{L}p$ 演化，其生成元为 $\\mathcal{L} = \\partial_x\\left(U'(x)\\cdot\\right) + D\\,\\partial_{xx}$。从一个盆地到一个吸收集的逃逸，可以通过在阈值 $x \\geq x_{\\mathrm{th}}$ 处施加吸收边界来捕捉，从而将动力学限制在域 $x  x_{\\mathrm{th}}$ 内，直到首次穿越。\n\n在弱噪声亚稳态机制下，如果存在单一主导的慢模式，则逃逸时间分布近似为指数分布。这可以从带吸收边界的福克-普朗克算子的谱表示中得出。令 $\\lambda_1  \\lambda_2 \\leq \\lambda_3 \\leq \\dots$ 表示在吸收域上具有相关边界条件的 $-\\mathcal{L}$ 的特征值。生存概率 $S(t) = \\mathbb{P}(T > t)$ 具有表示式\n$$\nS(t) = \\sum_{k\\geq 1} c_k e^{-\\lambda_k t},\n$$\n其中系数 $c_k$ 由初始条件和特征函数确定。如果谱隙很大，即 $\\lambda_2 \\gg \\lambda_1$，那么对于大于初始瞬态的时间，生存概率由主导项决定，即 $S(t) \\approx c_1 e^{-\\lambda_1 t}$，因此风险 $h(t) = -\\frac{d}{dt}\\log S(t)$ 近似为常数，等于 $\\lambda_1$。这导致了指数分布的逃逸时间。\n\n当多阱相互作用产生多个可比较的慢模式，使得 $\\lambda_2$ 不比 $\\lambda_1$ 大很多时，就会出现非指数行为。一个常见的机制是盆地被一个小的内势垒分裂成子阱，子阱之间的内部交换速率 $k_{AB}$ 与跨越主势垒的逃逸速率 $k_E$ 相当。在这种情况下，生存函数是指数函数的非平凡混合，\n$$\nS(t) \\approx c_1 e^{-\\lambda_1 t} + c_2 e^{-\\lambda_2 t} + \\dots,\n$$\n其中 $c_2$ 不可忽略且 $\\lambda_2$ 接近 $\\lambda_1$，这导致时变的风险 $h(t)$ 和 $\\log S(t)$ 的曲率。近分岔条件，例如削弱或消除局部最小值的倾斜 $v$，也可能产生非指数瞬态，因为确定性漂移主导了随机探索，导致在达到准稳态之前，逃逸时间依赖于初始条件和时间上的不均匀性。\n\n诊断设计遵循这些原则。纯指数分布具有恒定的风险和严格线性的 $\\log S(t)$ 对 $t$ 的关系。因此，一个稳健的诊断结合了三个指标：\n- 对经验 $T$ 与尺度参数等于经验均值 $\\hat{\\mu}$ 的指数分布进行柯尔莫哥洛夫-斯米尔诺夫拟合优度检验，显著性水平为 $\\alpha = 0.05$。这可以在不指定分箱的情况下检验整体分布形状。\n- 一个非指数性得分 $s$，定义为在内部网格上 $\\log \\hat{S}(t)$ 与其最佳线性拟合的归一化均方根偏差，它量化了超出噪声的曲率。具体来说，\n$$\ns = \\sqrt{\\frac{\\sum_{j=1}^M \\left(y_j - y_j^{\\mathrm{fit}}\\right)^2}{\\sum_{j=1}^M \\left(y_j - \\bar{y}\\right)^2}},\n$$\n其中 $y_j = \\log \\hat{S}(t_j)$ 是经验对数生存值，$y_j^{\\mathrm{fit}}$ 是最小二乘线性拟合，而 $t_j$ 在一个规则网格上取值。小的 $s$ 表示接近线性。\n- 一个风险变异性度量 $c$，定义为通过有限差分 $h_j \\approx \\frac{-(y_{j+1}-y_j)}{t_{j+1}-t_j}$ 估计的分段风险的变异系数，即 $c = \\mathrm{std}(h_j)/\\mathrm{mean}(h_j)$。指数行为产生近乎恒定的风险和小的 $c$。\n\n我们采用非指数性得分阈值 $\\tau = 0.08$ 和风险变异系数阈值 $\\eta = 0.25$，并要求柯尔莫哥洛夫-斯米尔诺夫检验的 $p$ 值至少为 $\\alpha = 0.05$。如果所有三个检验都一致，我们将分布分类为近似指数分布；否则，为非指数分布。\n\n模拟方法使用欧拉-丸山离散化：\n$$\nx_{n+1} = x_n - U'(x_n)\\,dt + \\sqrt{2D\\,dt}\\,\\xi_n,\n$$\n其中 $\\xi_n \\sim \\mathcal{N}(0,1)$ 是独立的。首次穿越时间 $T$ 记录为轨迹首次满足 $x \\geq x_{\\mathrm{th}}$ 的离散时间。为了在稀有事件中保持数值稳定性和效率，应选择足够小的 $dt$、足够大的 $t_{\\max}$ 和足够大的 $N$，以确保准确的经验生存估计，同时保持可接受的运行时间。\n\n我们测试三个科学上合理的情形：\n- 情况1：$U(x) = a(x^2-1)^2$，其中 $a=1$，一个对称双阱。从左阱跨越 $x=0$ 附近的势垒到右阱的逃逸，当 $D = 0.25$ 时，预期会有一个主导的慢模式，从而产生近似指数分布的 $T$。\n- 情况2：$U(x) = a(x^2-1)^2 + h\\exp\\!\\left(-\\frac{(x+1.5)^2}{2\\sigma^2}\\right)$，其中 $a = 1$, $h = 2.5$, $\\sigma = 0.2$，这引入了一个内势垒，将左盆地分裂成位于 $x \\approx -2$ 和 $x \\approx -1$ 附近的两个子阱。当 $D = 0.25$ 时，这会产生可比较的内部和逃逸时间尺度，由于多个慢模式而产生非指数生存函数。\n- 情况3：$U(x) = a(x^2-1)^2 + v x$，其中 $a = 1, v = 1.2$，这使势倾斜，削弱了左侧势垒，并接近一个鞍结状分岔。当 $D = 0.12$ 时，这会产生由漂移和初始条件效应主导的非指数瞬态。\n\n每个案例的算法步骤：\n1.  在 $x_0$ 处初始化 $N$ 条轨迹，并积分直到穿越阈值或达到 $t_{\\max}$。\n2.  收集首次穿越时间 $\\{T_i\\}$，并在经验第5和第95百分位数之间的 $M$ 个线性间隔点组成的网格上形成经验生存函数 $\\hat{S}(t)$，以避免极端分箱伪影。\n3.  计算对数生存函数 $\\log \\hat{S}(t)$，拟合一条最小二乘直线，并计算非指数性得分 $s$。\n4.  通过有限差分计算分段风险 $h_j$，并推导出 $c$。\n5.  对尺度为 $\\hat{\\mu}$ 的指数分布进行柯尔莫哥洛夫-斯米尔诺夫检验，并记录 $p$ 值。\n6.  根据 $p \\geq \\alpha$, $s \\leq \\tau$ 和 $c \\leq \\eta$ 分类为指数或非指数。\n\n预期的定性结果：\n- 情况1：近似指数分布，具有单一主导慢模式，因此具有近线性的对数生存函数、小的 $s$、小的 $c$ 和不显著的柯尔莫哥洛夫-斯米尔诺夫偏差，从而得到 $\\mathrm{True}$。\n- 情况2：由于多阱相互作用和内部子阱跃迁而呈非指数分布，导致对数生存函数出现曲率、较大的 $s$、较大的 $c$ 和显著的柯尔莫哥洛夫-斯米尔诺夫偏差，从而得到 $\\mathrm{False}$。\n- 情况3：由于接近分岔的倾斜导致非指数瞬态和时变风险，从而得到 $\\mathrm{False}$。\n\n最终程序实现了此模拟和诊断，汇总布尔结果，并以要求的单行格式 $\\left[\\mathrm{True},\\mathrm{False},\\mathrm{False}\\right]$ 打印它们。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import kstest, expon\n\n# Set a global random seed for reproducibility\nnp.random.seed(12345)\n\ndef grad_double(x, a):\n    # U(x) = a (x^2 - 1)^2 - U'(x) = 4 a x (x^2 - 1)\n    return 4.0 * a * x * (x**2 - 1.0)\n\ndef grad_split_left(x, a, h, sigma):\n    # U(x) = a (x^2 - 1)^2 + h * exp(- (x+1.5)^2 / (2 sigma^2))\n    # U'(x) = 4 a x (x^2 - 1) - h * ((x+1.5)/sigma^2) * exp(- (x+1.5)^2 / (2 sigma^2))\n    gauss = np.exp(-((x + 1.5)**2) / (2.0 * sigma**2))\n    return 4.0 * a * x * (x**2 - 1.0) - h * ((x + 1.5) / (sigma**2)) * gauss\n\ndef grad_tilted(x, a, v):\n    # U(x) = a (x^2 - 1)^2 + v x - U'(x) = 4 a x (x^2 - 1) + v\n    return 4.0 * a * x * (x**2 - 1.0) + v\n\ndef simulate_escape_times(potential_type, params):\n    \"\"\"\n    Simulate first passage times for N trajectories using Euler-Maruyama.\n    potential_type: 'double', 'split_left', or 'tilted'\n    params: dict containing a, D, x0, threshold, dt, t_max, N, and potential-specific parameters\n    Returns an array of escape times for trajectories that crossed the threshold.\n    \"\"\"\n    a = params.get('a', 1.0)\n    D = params['D']\n    x0 = params['x0']\n    threshold = params['threshold']\n    dt = params['dt']\n    t_max = params['t_max']\n    N = params['N']\n\n    # Initialize state\n    x = np.full(N, x0, dtype=np.float64)\n    alive = np.ones(N, dtype=bool)\n    times = np.zeros(N, dtype=np.float64)\n\n    n_steps = int(np.ceil(t_max / dt))\n    sqrt_term = np.sqrt(2.0 * D * dt)\n    t = 0.0\n\n    # Simulate in vectorized fashion\n    for _ in range(n_steps):\n        if not np.any(alive):\n            break\n        idx_alive = np.where(alive)[0]\n        xa = x[idx_alive]\n        if potential_type == 'double':\n            drift = -grad_double(xa, a)\n        elif potential_type == 'split_left':\n            h = params['h']\n            sigma = params['sigma']\n            drift = -grad_split_left(xa, a, h, sigma)\n        elif potential_type == 'tilted':\n            v = params['v']\n            drift = -grad_tilted(xa, a, v)\n        else:\n            raise ValueError(\"Unknown potential type\")\n\n        xi = np.random.randn(xa.size)\n        xa_new = xa + drift * dt + sqrt_term * xi\n        ta_new = t + dt\n\n        crossed = xa_new >= threshold\n        # Record times for those that crossed at this step\n        times[idx_alive[crossed]] = ta_new\n\n        # Update survivors\n        survivors_idx = idx_alive[~crossed]\n        x[survivors_idx] = xa_new[~crossed]\n        alive[:] = False\n        alive[survivors_idx] = True\n\n        t = ta_new\n\n    # Return only successful escape times (exclude zeros)\n    return times[times > 0.0]\n\ndef empirical_survival(times, M=50):\n    \"\"\"\n    Compute empirical survival S_hat(t) on a grid of M points\n    between the 5th and 95th percentile of times.\n    Returns t_grid, S_values.\n    \"\"\"\n    times_sorted = np.sort(times)\n    N = times_sorted.size\n    if N  5:\n        # Degenerate case: return trivial survival on a minimal grid\n        t_grid = np.linspace(times_sorted.min(), times_sorted.max(), max(3, M))\n        # Survival computed via counts\n        idx = np.searchsorted(times_sorted, t_grid, side='right')\n        S = (N - idx) / N\n        return t_grid, S\n\n    t_lo = np.percentile(times_sorted, 5.0)\n    t_hi = np.percentile(times_sorted, 95.0)\n    if t_hi = t_lo:\n        t_lo = times_sorted.min()\n        t_hi = times_sorted.max()\n    t_grid = np.linspace(t_lo, t_hi, M)\n    idx = np.searchsorted(times_sorted, t_grid, side='right')\n    S = (N - idx) / N\n    # Prevent zero survival to avoid log singularity\n    eps = 1e-12\n    S = np.clip(S, eps, 1.0)\n    return t_grid, S\n\ndef non_exponentiality_score(t_grid, S_values):\n    \"\"\"\n    Compute normalized RMS deviation of log survival from best-fit line,\n    and hazard coefficient of variation.\n    \"\"\"\n    logS = np.log(S_values)\n    # Least squares linear fit: logS ~ alpha + beta * t\n    coeffs = np.polyfit(t_grid, logS, 1)\n    logS_fit = np.polyval(coeffs, t_grid)\n    # Normalized RMS deviation\n    numerator = np.mean((logS - logS_fit)**2)\n    denom = np.var(logS)\n    s = np.sqrt(numerator / denom) if denom > 0 else 0.0\n\n    # Piecewise hazard via finite differences\n    dlogS = np.diff(logS)\n    dt = np.diff(t_grid)\n    # Hazard estimates h_j = -(d logS) / dt\n    with np.errstate(divide='ignore', invalid='ignore'):\n        hazards = -dlogS / dt\n    hazards = hazards[np.isfinite(hazards)]\n    if hazards.size == 0:\n        c = np.inf\n    else:\n        mean_h = np.mean(hazards)\n        std_h = np.std(hazards)\n        c = (std_h / mean_h) if mean_h > 0 else np.inf\n    return s, c\n\ndef ks_test_exponential(times):\n    \"\"\"\n    Perform KS test against exponential with scale equal to sample mean.\n    Returns p-value.\n    \"\"\"\n    mean_T = np.mean(times)\n    if mean_T = 0.0:\n        return 0.0\n    # scipy.stats.kstest with distribution 'expon' uses args=(loc, scale)\n    result = kstest(times, 'expon', args=(0.0, mean_T))\n    return result.pvalue\n\ndef classify_exponential(times, tau=0.08, eta=0.25, alpha=0.05, M=50):\n    \"\"\"\n    Classify whether the escape time distribution is approximately exponential.\n    Criteria: KS p >= alpha, non-exponentiality score s = tau, hazard CV c = eta.\n    \"\"\"\n    if times.size  10:\n        # Not enough data, conservative classify as non-exponential\n        return False\n    t_grid, S_vals = empirical_survival(times, M=M)\n    s, c = non_exponentiality_score(t_grid, S_vals)\n    pval = ks_test_exponential(times)\n    is_exp = (pval >= alpha) and (s = tau) and (c = eta)\n    return is_exp\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'case_id': 1,\n            'potential': 'double',\n            'a': 1.0,\n            'D': 0.25,\n            'x0': -1.0,\n            'threshold': 0.0,\n            'dt': 0.01,\n            't_max': 40.0,\n            'N': 800\n        },\n        {\n            'case_id': 2,\n            'potential': 'split_left',\n            'a': 1.0,\n            'h': 2.5,\n            'sigma': 0.2,\n            'D': 0.25,\n            'x0': -1.8,\n            'threshold': 0.0,\n            'dt': 0.01,\n            't_max': 50.0,\n            'N': 800\n        },\n        {\n            'case_id': 3,\n            'potential': 'tilted',\n            'a': 1.0,\n            'v': 1.2,\n            'D': 0.12,\n            'x0': -0.9,\n            'threshold': 0.0,\n            'dt': 0.01,\n            't_max': 15.0,\n            'N': 800\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Simulate escape times for one case\n        times = simulate_escape_times(case['potential'], case)\n        # Classify using diagnostic\n        is_exp = classify_exponential(times, tau=0.08, eta=0.25, alpha=0.05, M=50)\n        results.append(is_exp)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "当转变事件极为罕见时，直接模拟在计算上会变得不可行。本练习将向您介绍重要性采样，这是一种用于高效估计稀有事件概率的强大方差缩减技术 。您将针对一个慢-快系统实施一个先进的算法，其中采样路径由系统的慢动力学引导，这代表了从理论理解到实际计算效率的关键一步。",
            "id": "3931138",
            "problem": "考虑一个无量纲形式的生物医学模块的慢快随机模型，其中快激活变量 $x_t$ 与慢表观遗传状态 $y_t$ 耦合。系统根据以下随机微分方程演化\n$$\n\\mathrm{d}x_t = \\left(x_t - x_t^3 - y_t\\right)\\,\\mathrm{d}t + \\sqrt{2\\,\\epsilon}\\,\\mathrm{d}W^{x}_t,\\quad\n\\mathrm{d}y_t = \\delta\\left(x_t - \\lambda\\,y_t\\right)\\,\\mathrm{d}t + \\sqrt{2\\,\\epsilon\\,\\delta}\\,\\mathrm{d}W^{y}_t,\n$$\n其中 $\\epsilon  0$ 是噪声强度，$\\delta \\ll 1$ 引起 $y_t$ 的慢动态，$\\lambda  0$ 是慢变量 $y_t$ 的稳定性参数，$W^{x}_t$ 和 $W^{y}_t$ 是独立的标准维纳过程。假设初始条件 $x_0$ 和 $y_0$ 已给定。将罕见偏移事件定义为快变量在有限时间域 $[0,T]$ 内穿越阈值 $x_{\\mathrm{thr}}$：\n$$\n\\mathcal{E} = \\left\\{\\sup_{t \\in [0,T]} x_t \\geq x_{\\mathrm{thr}}\\right\\}.\n$$\n您的任务是基于直接蒙特卡洛方法和由降维慢动态原理引导的重要性采样，实现概率 $\\mathbb{P}(\\mathcal{E})$ 的估计器。使用步长为 $\\Delta t$ 的欧拉-丸山时间离散化方法：\n$$\nx_{n+1} = x_n + \\left(x_n - x_n^3 - y_n\\right)\\Delta t + \\sigma_x\\,\\Delta W^{x}_n,\\quad\ny_{n+1} = y_n + \\delta\\left(x_n - \\lambda\\,y_n\\right)\\Delta t + \\sigma_y\\left(u_{y,n}\\,\\Delta t + \\Delta W^{y}_n\\right),\n$$\n其中 $\\sigma_x = \\sqrt{2\\,\\epsilon}$，$\\sigma_y = \\sqrt{2\\,\\epsilon\\,\\delta}$，且在每个时间步长 $n$，$\\Delta W^{x}_n, \\Delta W^{y}_n \\sim \\mathcal{N}(0,\\Delta t)$ 相互独立。项 $u_{y,n}$ 是为重要性采样选择的控制项，它应使用降维慢流形启发式方法，在慢变量方向上对样本路径进行偏置：快子系统大致沿着由 $x - x^3 - y = 0$ 的根定义的慢流形达到平衡。具体来说，使用由阈值 $x_{\\mathrm{thr}}$ 通过慢流形条件 $x_{\\mathrm{thr}} - x_{\\mathrm{thr}}^3 - y_{\\star} = 0$ 所隐含的目标慢状态 $y_{\\star}$，即\n$$\ny_{\\star} = x_{\\mathrm{thr}} - x_{\\mathrm{thr}}^3,\n$$\n并构造一个形式如下的重要性采样控制：\n$$\nu_{y,n} = \\kappa\\left(y_{\\star} - y_n\\right),\n$$\n其中 $\\kappa \\ge 0$ 是一个倾斜强度参数。在测度变换下，重要性采样估计器必须是无偏的，这要求包含与沿慢变量应用的漂移修正相一致的似然比。使用以下方法计算 $\\mathbb{P}(\\mathcal{E})$：\n1. 直接蒙特卡洛，其中 $u_{y,n} \\equiv 0$。\n2. 使用中等倾斜 $\\kappa  0$ 的重要性采样。\n3. 使用更强倾斜 $\\kappa$ 的重要性采样。\n4. 一个具有更小 $\\delta$ 的边界情况，以测试当慢时间尺度分离增加时的行为。\n\n所有量都是无量纲的；将概率估计值以小数形式报告。实现您的程序，为每个测试用例模拟 $N$ 条独立轨迹，检测每个轨迹上是否发生 $\\mathcal{E}$，并适当地汇总结果。您的实现必须：\n1. 按规定使用欧拉-丸山方案。\n2. 使用方差为 $\\Delta t$ 的独立高斯增量 $\\Delta W^{x}_n$ 和 $\\Delta W^{y}_n$。\n3. 对于重要性采样，在慢变量中整合与所实现的控制相关的无偏似然比。\n\n您的程序要使用的测试参数集：\n- 案例 A (基线蒙特卡洛)：$\\epsilon = 0.01$, $\\delta = 0.05$, $\\lambda = 1.0$, $x_0 = -1.0$, $y_0 = 0.2$, $x_{\\mathrm{thr}} = 0.8$, $T = 2.5$, $\\Delta t = 0.01$, $N = 3000$, $\\kappa = 0.0$。\n- 案例 B (重要性采样，中等)：与案例 A 相同，但 $\\kappa = 2.0$。\n- 案例 C (重要性采样，强)：与案例 A 相同，但 $\\kappa = 5.0$。\n- 案例 D (慢时间尺度边界)：与案例 B 相同，但 $\\delta = 0.02$。\n\n您的程序应产生单行输出，其中包含四个估计概率，以逗号分隔的列表形式并用方括号括起来（例如，\"[pA,pB,pC,pD]\"）。",
            "solution": "目标是使用直接蒙特卡洛 (DMC) 模拟和重要性采样 (IS) 来估计一个慢快随机系统的罕见偏移事件的概率。该系统由一个快变量 $x_t$ 和一个慢变量 $y_t$ 的一对耦合随机微分方程 (SDE) 描述。\n\n无量纲形式的控制性SDE为：\n$$\n\\mathrm{d}x_t = \\left(x_t - x_t^3 - y_t\\right)\\,\\mathrm{d}t + \\sqrt{2\\,\\epsilon}\\,\\mathrm{d}W^{x}_t,\n$$\n$$\n\\mathrm{d}y_t = \\delta\\left(x_t - \\lambda\\,y_t\\right)\\,\\mathrm{d}t + \\sqrt{2\\,\\epsilon\\,\\delta}\\,\\mathrm{d}W^{y}_t,\n$$\n其中 $x_t, y_t$ 是状态变量，$\\epsilon  0$ 是噪声强度，$\\delta \\ll 1$ 是时间尺度分离参数，$\\lambda  0$ 是稳定性参数，$W^{x}_t, W^{y}_t$ 是独立的标准维纳过程。\n\n罕见事件 $\\mathcal{E}$ 被定义为快变量 $x_t$ 在时间域 $[0,T]$ 内超过阈值 $x_{\\mathrm{thr}}$：\n$$\n\\mathcal{E} = \\left\\{\\sup_{t \\in [0,T]} x_t \\geq x_{\\mathrm{thr}}\\right\\}.\n$$\n我们旨在计算 $\\mathbb{P}(\\mathcal{E}) = \\mathbb{E}[\\mathbf{1}_{\\mathcal{E}}]$，其中 $\\mathbf{1}_{\\mathcal{E}}$ 是事件 $\\mathcal{E}$ 的指示函数。\n\nSDE的数值模拟是使用时间步长为 $\\Delta t$ 的欧拉-丸山方案进行的。一条轨迹的离散化方程由下式给出：\n$$\nx_{n+1} = x_n + \\left(x_n - x_n^3 - y_n\\right)\\Delta t + \\sigma_x\\,\\Delta W^{x}_n,\n$$\n$$\ny_{n+1} = y_n + \\delta\\left(x_n - \\lambda\\,y_n\\right)\\Delta t + \\sigma_y\\,\\Delta W^{y}_n,\n$$\n其中 $n$ 是时间步索引，$\\sigma_x = \\sqrt{2\\,\\epsilon}$，$\\sigma_y = \\sqrt{2\\,\\epsilon\\,\\delta}$，$\\Delta W^{x}_n, \\Delta W^{y}_n$ 是从正态分布 $\\mathcal{N}(0,\\Delta t)$ 中抽取的独立随机变量。\n\n$\\mathbb{P}(\\mathcal{E})$ 的直接蒙特卡洛 (DMC) 估计器是 $N$ 条独立轨迹上指示函数的样本均值：\n$$\n\\hat{P}_{\\mathrm{DMC}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{1}_{\\mathcal{E}}^{(i)}.\n$$\n对于每条轨迹 $i$，如果 $\\max_{n} x_n^{(i)} \\geq x_{\\mathrm{thr}}$，则 $\\mathbf{1}_{\\mathcal{E}}^{(i)}=1$，否则为 $0$。对于罕见事件，这种方法的计算成本很高，因为大多数轨迹对总和没有贡献。DMC情况对应于将重要性采样控制设置为零。\n\n为了提高效率，我们采用重要性采样 (IS)。IS 的核心原理是在一个新的、有偏的概率测度 $\\mathbb{Q}$ 下模拟系统，在该测度下罕见事件更频繁地发生，然后使用似然比来校正这种偏差。测度的改变是通过在SDE的漂移项中添加一个控制项来实现的。问题指定仅对慢变量 $y_t$ 应用控制。\n\n控制策略由快子系统的慢流形引导，该慢流形由 $x-x^3-y=0$ 定义。为了促进 $x_{\\mathrm{thr}}$ 的穿越，慢变量 $y_t$ 被引向一个目标值 $y_{\\star}$，该值使得 $x_{\\mathrm{thr}}$ 成为一个更可能的状态。这个目标值由 $x=x_{\\mathrm{thr}}$ 时的慢流形条件导出：\n$$\ny_{\\star} = x_{\\mathrm{thr}} - x_{\\mathrm{thr}}^3.\n$$\n该控制是一个比例反馈项，将 $y_n$ 推向 $y_{\\star}$：\n$$\nu_{y,n} = \\kappa\\left(y_{\\star} - y_n\\right),\n$$\n其中 $\\kappa \\ge 0$ 是倾斜强度。\n\n根据吉尔萨诺夫（Girsanov）定理，为了保持估计的无偏性，我们必须引入一个权重，即似然比 $L_T^{-1} = \\mathrm{d}\\mathbb{P}/\\mathrm{d}\\mathbb{Q}$。对于一个通过增加额外漂移项 $g_t$ 来改变测度的过程，其离散时间对数似然的更新规则为：\n$$\n\\Delta(\\log L^{-1}) = -h_n \\Delta\\tilde{W}_n - \\frac{1}{2}h_n^2 \\Delta t\n$$\n其中 $h_n = g_n / \\sigma_n$ 是吉尔萨诺夫控制过程，$\\Delta\\tilde{W}_n$ 是在新测度 $\\mathbb{Q}$ 下的维纳增量。\n在本问题中，受控更新为 $y_{n+1} = y_n + [\\delta(x_n - \\lambda y_n) + \\sigma_y u_{y,n}]\\Delta t + \\sigma_y \\Delta\\tilde{W}_n^y$。与原始漂移相比，额外增加的漂移是 $g_n = \\sigma_y u_{y,n}$。扩散项系数是 $\\sigma_y$。因此，吉尔萨诺夫控制过程为 $h_n = g_n / \\sigma_y = u_{y,n}$。我们模拟中生成的噪声增量 `dw_y` 对应于 $\\Delta\\tilde{W}_n^y$。因此，单步对数似然更新的正确公式是：\n$$\n\\log L_{n+1}^{-1} = \\log L_n^{-1} - u_{y,n} \\Delta\\tilde{W}_n^y - \\frac{1}{2}u_{y,n}^2 \\Delta t\n$$\n这正是该算法实现的核心。\n\n$\\mathbb{P}(\\mathcal{E})$ 的IS估计器是加权指示函数的平均值：\n$$\n\\hat{P}_{\\mathrm{IS}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{1}_{\\mathcal{E}}^{(i)} L^{-1,(i)}.\n$$\n每个测试用例的算法如下：\n1. 初始化参数：$\\epsilon, \\delta, \\lambda, x_0, y_0, x_{\\mathrm{thr}}, T, \\Delta t, N, \\kappa$。\n2. 预计算常数：$\\sigma_x$、$\\sigma_y$、步数 $N_{\\mathrm{steps}} = T/\\Delta t$ 和目标 $y_{\\star}$。\n3. 对于 $N$ 次模拟中的每一次：\n    a. 初始化状态 $(x, y) = (x_0, y_0)$ 和对数似然 $\\log L^{-1} = 0$。\n    b. 对于从 $0$ 到 $N_{\\mathrm{steps}}-1$ 的每个时间步 $n$：\n        i. 生成独立增量 $\\Delta \\tilde{W}_n^x, \\Delta \\tilde{W}_n^y \\sim \\mathcal{N}(0, \\Delta t)$。\n        ii. 计算控制 $u_{y,n} = \\kappa(y_{\\star} - y_n)$。\n        iii. 更新对数似然。\n        iv. 更新状态变量，包括控制项。\n        v. 如果 $x_{n+1} \\geq x_{\\mathrm{thr}}$，事件发生。轨迹终止，并记录其贡献 $\\exp(\\log L^{-1})$。\n4. 最终估计值是所有 $N$ 条轨迹贡献的平均值。对所有四个测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n\n    # Test suite parameter sets:\n    # (epsilon, delta, lambda, x0, y0, x_thr, T, dt, N, kappa)\n    test_cases = [\n        (0.01, 0.05, 1.0, -1.0, 0.2, 0.8, 2.5, 0.01, 3000, 0.0), # Case A\n        (0.01, 0.05, 1.0, -1.0, 0.2, 0.8, 2.5, 0.01, 3000, 2.0), # Case B\n        (0.01, 0.05, 1.0, -1.0, 0.2, 0.8, 2.5, 0.01, 3000, 5.0), # Case C\n        (0.01, 0.02, 1.0, -1.0, 0.2, 0.8, 2.5, 0.01, 3000, 2.0), # Case D\n    ]\n\n    results = []\n    # Use a fixed seed for reproducibility of the results.\n    rng = np.random.default_rng(seed=42)\n\n    for params in test_cases:\n        prob = run_simulation(params, rng)\n        results.append(prob)\n\n    # Format the output as specified\n    print(f\"[{','.join(f'{p:.7f}' for p in results)}]\")\n\n\ndef run_simulation(params, rng):\n    \"\"\"\n    Runs a Monte Carlo or Importance Sampling simulation for a single parameter set.\n\n    Args:\n        params (tuple): A tuple containing the simulation parameters.\n        rng (np.random.Generator): The random number generator instance.\n\n    Returns:\n        float: The estimated probability of the rare event.\n    \"\"\"\n    epsilon, delta, lam, x0, y0, x_thr, T, dt, N, kappa = params\n\n    # Pre-calculate constants for the simulation\n    num_steps = int(T / dt)\n    sigma_x = np.sqrt(2 * epsilon)\n    sigma_y = np.sqrt(2 * epsilon * delta)\n    sqrt_dt = np.sqrt(dt)\n\n    # Target slow state y_star for importance sampling control\n    y_star = x_thr - x_thr**3\n\n    total_weighted_indicators = 0.0\n\n    for _ in range(N):\n        x, y = x0, y0\n        log_L_inv = 0.0\n        crossed = False\n\n        for _ in range(num_steps):\n            # Generate Wiener increments dW ~ N(0, dt)\n            dw_x = rng.normal(0.0, sqrt_dt)\n            dw_y = rng.normal(0.0, sqrt_dt)\n            \n            # This dw_y corresponds to the increment of the Wiener process under the\n            # biased measure Q, i.e., dW_tilde in the theoretical formulation.\n\n            # Calculate IS control (kappa=0.0 for Direct Monte Carlo)\n            u_y = kappa * (y_star - y)\n\n            # Update the logarithm of the likelihood ratio L^-1 = dP/dQ\n            # log(L_inv) -= u * dW_tilde + 0.5 * u^2 * dt\n            if kappa > 0:\n                log_L_inv -= (u_y * dw_y + 0.5 * u_y**2 * dt)\n\n            # Update state variables using the Euler-Maruyama scheme\n            # Drift terms\n            drift_x = x - x**3 - y\n            drift_y = delta * (x - lam * y)\n            \n            # Update x\n            x_next = x + drift_x * dt + sigma_x * dw_x\n            \n            # Update y with the control term\n            # The controlled drift is (drift_y + sigma_y * u_y)\n            y_next = y + (drift_y + sigma_y * u_y) * dt + sigma_y * dw_y\n            \n            x, y = x_next, y_next\n\n            # Check for threshold crossing\n            if x >= x_thr:\n                crossed = True\n                break\n        \n        if crossed:\n            # For IS, add the weighted indicator. For DMC (kappa=0), L_inv=1.\n            total_weighted_indicators += np.exp(log_L_inv)\n\n    # The probability is the mean of the (weighted) indicators\n    probability_estimate = total_weighted_indicators / N\n    \n    return probability_estimate\n\n# Run the full solution\nsolve()\n```"
        }
    ]
}