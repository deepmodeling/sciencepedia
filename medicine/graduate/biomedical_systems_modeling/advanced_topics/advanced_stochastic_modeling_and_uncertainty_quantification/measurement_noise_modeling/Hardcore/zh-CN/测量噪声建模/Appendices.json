{
    "hands_on_practices": [
        {
            "introduction": "理论知识在实践中才能真正发挥其价值。在进行任何测量之前，一个基本而关键的问题是：我们需要收集多少数据才能达到期望的精度？本练习  将高斯噪声的抽象统计模型与设计一个高效校准实验的实际问题联系起来。通过计算获得特定置信区间宽度所需的最小样本量，你将掌握连接理论与实验设计的核心技能，并进一步探讨当我们的噪声假设与真实情况不完全相符时，实验设计的稳健性如何，这是在真实世界工程中必须考虑的重要因素。",
            "id": "3900231",
            "problem": "一个生物医学实验室正在校准一款腕戴式光电容积脉搏波（PPG）设备，以估计个体的静息心率，该心率用参数 $\\theta$（单位为次/分钟）表示。在受控条件下的校准过程中，该设备产生独立重复的测量值 $\\{y_{i}\\}_{i=1}^{n}$，这些测量值可通过加性高斯噪声模型 $y_{i} = \\theta + \\varepsilon_{i}$ 来建模，其中 $\\varepsilon_{i} \\sim \\mathcal{N}(0,\\sigma^{2})$ 且 $\\sigma^{2}$ 从先前的台架测试表征中已知。假设在短暂的校准窗口期内，潜在的生理状态是平稳的，因此 $\\theta$ 是一个常数。设备制造商报告 $\\sigma^{2} = 9$（因此 $\\sigma = 3$）。该实验室希望使用样本均值 $\\bar{y}_{n}$ 为 $\\theta$ 构建一个置信水平为 $1 - \\alpha$（其中 $\\alpha = 0.05$）的双侧置信区间（CI），并要求该置信区间的半宽最多为 $w = 1.5$。\n\n- 仅使用高斯测量噪声和样本均值抽样分布的基本定义，确定保证在置信水平 $1 - \\alpha$ 下置信区间半宽最多为 $w$ 的最小整数样本量 $n$。\n\n- 另外，按如下方式分析其对方差误设定的稳健性。假设校准是基于一个假设方差 $\\sigma_{0}^{2}$ 设计的，但真实的测量方差是 $\\sigma^{2}$。定义方差误设定因子 $\\kappa = \\sigma^{2} / \\sigma_{0}^{2}$。当使用在 $\\sigma_{0}^{2}$ 下计算的样本量时，推导出乘性膨胀因子 $r(\\kappa)$ 的闭式表达式，该因子定义为达到的置信区间半宽与目标半宽之比。\n\n报告最小整数 $n$ 和 $r(\\kappa)$ 的闭式解析表达式。由于 $n$ 是一个精确的整数，因此无需按有效数字进行舍入。膨胀因子 $r(\\kappa)$ 必须精确表示。",
            "solution": "该问题提出了两个不同的任务：首先，为指定宽度的置信区间计算所需的最小样本量；其次，推导由于测量方差的误设定导致的置信区间宽度膨胀的表达式。我们将系统地解决每个部分。\n\n### 第1部分：最小样本量计算\n\n单个测量的模型由 $y_{i} = \\theta + \\varepsilon_{i}$ 给出，其中 $i=1, 2, \\dots, n$。测量误差 $\\varepsilon_{i}$ 是独立同分布（i.i.d.）的随机变量，服从均值为 $0$、已知方差为 $\\sigma^{2}$ 的正态分布，即 $\\varepsilon_{i} \\sim \\mathcal{N}(0, \\sigma^{2})$。我们感兴趣的参数是真实静息心率 $\\theta$。\n\n$\\theta$ 的估计量是样本均值 $\\bar{y}_{n} = \\frac{1}{n} \\sum_{i=1}^{n} y_{i}$。因为 $y_{i}$ 是均值为 $\\theta$、方差为 $\\sigma^{2}$ 的独立同分布正态随机变量（即 $y_{i} \\sim \\mathcal{N}(\\theta, \\sigma^{2})$），所以样本均值 $\\bar{y}_{n}$ 服从正态分布。样本均值的期望值为 $\\mathbb{E}[\\bar{y}_{n}] = \\theta$，其方差为 $\\text{Var}(\\bar{y}_{n}) = \\frac{\\sigma^{2}}{n}$。因此，估计量的抽样分布为 $\\bar{y}_{n} \\sim \\mathcal{N}(\\theta, \\frac{\\sigma^{2}}{n})$。\n\n为了构建 $\\theta$ 的置信区间，我们通过标准化估计量 $\\bar{y}_{n}$ 来构造一个枢轴量。标准化变量 $Z$ 为：\n$$ Z = \\frac{\\bar{y}_{n} - \\theta}{\\sigma/\\sqrt{n}} $$\n这个量 $Z$ 服从标准正态分布，$Z \\sim \\mathcal{N}(0, 1)$。\n\n置信水平为 $1 - \\alpha$ 的双侧置信区间（CI）可从以下概率陈述中导出：\n$$ P(-z_{\\alpha/2} \\le Z \\le z_{\\alpha/2}) = 1 - \\alpha $$\n其中 $z_{\\alpha/2}$ 是标准正态分布的上临界值，由 $P(Z > z_{\\alpha/2}) = \\alpha/2$ 定义。代入 $Z$ 的表达式：\n$$ P\\left(-z_{\\alpha/2} \\le \\frac{\\bar{y}_{n} - \\theta}{\\sigma/\\sqrt{n}} \\le z_{\\alpha/2}\\right) = 1 - \\alpha $$\n通过重新整理不等式以分离 $\\theta$，我们得到置信区间的界限：\n$$ \\bar{y}_{n} - z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} \\le \\theta \\le \\bar{y}_{n} + z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} $$\n因此，置信区间为 $[\\bar{y}_{n} - z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}}, \\bar{y}_{n} + z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}}]$。该区间的半宽（记为 $H$）是从样本均值上加减的量：\n$$ H = z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} $$\n问题要求这个半宽最多为 $w = 1.5$。我们建立不等式：\n$$ z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} \\le w $$\n解出样本量 $n$：\n$$ \\sqrt{n} \\ge \\frac{z_{\\alpha/2} \\sigma}{w} $$\n$$ n \\ge \\left(\\frac{z_{\\alpha/2} \\sigma}{w}\\right)^{2} $$\n我们已知以下值：\n- 方差 $\\sigma^{2} = 9$，所以标准差为 $\\sigma = \\sqrt{9} = 3$。\n- 置信水平为 $1 - \\alpha = 1 - 0.05 = 0.95$，所以 $\\alpha = 0.05$ 且 $\\alpha/2 = 0.025$。\n- 临界值 $z_{0.025}$ 是使标准正态分布的累积分布函数值为 $1 - 0.025 = 0.975$ 的值。该值为 $z_{0.025} \\approx 1.95996$。我们将使用常用近似值 $z_{0.025} \\approx 1.96$。\n- 要求的最大半宽为 $w = 1.5$。\n\n将这些值代入关于 $n$ 的不等式：\n$$ n \\ge \\left(\\frac{1.96 \\times 3}{1.5}\\right)^{2} $$\n$$ n \\ge \\left(\\frac{5.88}{1.5}\\right)^{2} $$\n$$ n \\ge (3.92)^{2} $$\n$$ n \\ge 15.3664 $$\n由于样本量 $n$ 必须是整数，我们需要找到满足此条件的最小整数。这可以通过对结果向上取整得到：\n$$ n = \\lceil 15.3664 \\rceil = 16 $$\n因此，所需的最小整数样本量为 $16$。\n\n### 第2部分：对方差误设定的稳健性\n\n在这一部分中，我们分析这样一种情景：样本量是基于一个假设方差 $\\sigma_{0}^{2}$ 来选择的，但真实的方差是 $\\sigma^{2}$。置信区间的目标半宽为 $w$。\n\n样本量（我们称之为 $n_{0}$）是使用假设方差 $\\sigma_{0}^{2}$ 确定的。如果假设方差是正确的，确保能达到目标半宽 $w$ 的设计方程是：\n$$ w = z_{\\alpha/2} \\frac{\\sigma_{0}}{\\sqrt{n_{0}}} $$\n该方程定义了设计参数之间的关系。为了进行后续分析，我们可以用其他参数表示 $\\sqrt{n_{0}}$：$\\sqrt{n_{0}} = \\frac{z_{\\alpha/2} \\sigma_{0}}{w}$。\n\n然后使用这个样本量 $n_{0}$ 进行实验。然而，数据是由一个真实方差为 $\\sigma^{2}$ 的过程生成的。因此，样本均值 $\\bar{y}_{n_{0}}$ 的真实标准差是 $\\sigma/\\sqrt{n_{0}}$。\n\n实际达到的置信区间半宽，我们记为 $H_{\\text{achieved}}$，将基于这个真实的标准差：\n$$ H_{\\text{achieved}} = z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n_{0}}} $$\n膨胀因子 $r(\\kappa)$ 定义为达到的半宽与目标半宽 $w$ 之比：\n$$ r(\\kappa) = \\frac{H_{\\text{achieved}}}{w} $$\n代入 $H_{\\text{achieved}}$ 和 $w$（来自设计方程）的表达式：\n$$ r(\\kappa) = \\frac{z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n_{0}}}}{z_{\\alpha/2} \\frac{\\sigma_{0}}{\\sqrt{n_{0}}}} $$\n$z_{\\alpha/2}$ 和 $\\sqrt{n_{0}}$ 项相互抵消，剩下：\n$$ r(\\kappa) = \\frac{\\sigma}{\\sigma_{0}} $$\n问题将方差误设定因子定义为 $\\kappa = \\frac{\\sigma^{2}}{\\sigma_{0}^{2}}$。为了将 $r(\\kappa)$ 表示为 $\\kappa$ 的函数，我们对 $\\kappa$ 取平方根：\n$$ \\sqrt{\\kappa} = \\sqrt{\\frac{\\sigma^{2}}{\\sigma_{0}^{2}}} = \\frac{|\\sigma|}{|\\sigma_{0}|} $$\n由于标准差是非负的，即 $\\sigma \\ge 0$ 和 $\\sigma_{0} \\ge 0$，这可以简化为：\n$$ \\sqrt{\\kappa} = \\frac{\\sigma}{\\sigma_{0}} $$\n因此，乘性膨胀因子 $r(\\kappa)$ 的闭式表达式为：\n$$ r(\\kappa) = \\sqrt{\\kappa} $$\n这个结果表明，置信区间半宽的膨胀因子等于真实方差与假设方差之比的平方根。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 16  \\sqrt{\\kappa} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "除了普遍存在的统计噪声，测量硬件本身也会引入特定的噪声源。几乎所有的现代生物医学数字系统都依赖于模数转换器 (ADC)，而这一过程必然会产生量化误差。本练习  旨在深入剖析量化噪声的基本模型，并将其与信噪比（SNR）这一衡量任何测量设备性能的关键指标联系起来。通过从第一性原理推导量化噪声的方差，并计算特定输入信号下的信噪比，你将对数字信号采集的内在限制有更深刻的理解。",
            "id": "3900253",
            "problem": "一个生物医学监测系统使用一个模数转换器 (ADC) 来数字化一个带限动脉血压波形。该 ADC 可以被建模为一个步长为 $\\Delta$ 的均匀中平型量化器，将任意实数输入 $x$ 映射到由 $Q(x) = \\Delta \\cdot \\mathrm{round}(x/\\Delta)$ 定义的 $Q(x)$。令量化误差为 $e = Q(x) - x$。假设量化噪声建模满足以下经过充分检验的条件：(i) 输入使得 $e$ 与 $x$ 统计独立，以及 (ii) $e$ 在一个量化单元内取任何值的可能性均等，即 $e$ 在 $[-\\Delta/2, \\Delta/2]$ 上服从均匀分布。\n\n1. 仅使用方差的定义和 $e$ 的假定均匀分布，推导量化噪声方差 $\\sigma_q^2$。\n\n2. 在校准阶段，输入到 ADC 的波形是一个正弦波 $x[n] = A \\sin(2\\pi f n T_s)$，其中 $A$ 是振幅，$f$ 是频率，$T_s$ 是采样周期。$A$ 足够小以避免削波，且 $f T_s$ 使得采样相位在 $[0, 2\\pi)$ 上是遍历的。在上述独立性假设下，计算信噪比 (SNR)，其定义为平均信号功率与量化噪声方差之比，即 $ \\mathrm{SNR} = P_x / \\sigma_q^2$，其中 $P_x$ 是 $x[n]$ 的时间平均功率。将 SNR 表示为以 $A$ 和 $\\Delta$ 表示的闭式、无量纲的比率。\n\n提供一个包含量化噪声方差和 SNR 的行矩阵作为最终答案。不需要数值。",
            "solution": "该问题陈述清晰，具有科学依据，并为完整的推导提供了所有必要的信息。我们将按要求分两部分进行。\n\n### 第1部分：量化噪声方差 $\\sigma_q^2$ 的推导\n\n量化误差是一个随机变量 $e$，在区间 $[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}]$ 上服从均匀概率分布。因此，$e$ 的概率密度函数 (PDF)，记为 $p(e)$，为：\n$$\np(e) =\n\\begin{cases}\n\\frac{1}{\\Delta}  \\text{for } -\\frac{\\Delta}{2} \\le e \\le \\frac{\\Delta}{2} \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n随机变量 $e$ 的方差，记为 $\\sigma_q^2$，定义为 $\\sigma_q^2 = \\mathrm{E}[(e - \\mu_e)^2]$，其中 $\\mu_e = \\mathrm{E}[e]$ 是 $e$ 的均值。\n\n首先，我们计算均值 $\\mu_e$：\n$$\n\\mu_e = \\mathrm{E}[e] = \\int_{-\\infty}^{\\infty} e \\cdot p(e) \\, de\n$$\n代入 PDF $p(e)$：\n$$\n\\mu_e = \\int_{-\\frac{\\Delta}{2}}^{\\frac{\\Delta}{2}} e \\cdot \\frac{1}{\\Delta} \\, de = \\frac{1}{\\Delta} \\left[ \\frac{e^2}{2} \\right]_{-\\frac{\\Delta}{2}}^{\\frac{\\Delta}{2}}\n$$\n$$\n\\mu_e = \\frac{1}{2\\Delta} \\left( \\left(\\frac{\\Delta}{2}\\right)^2 - \\left(-\\frac{\\Delta}{2}\\right)^2 \\right) = \\frac{1}{2\\Delta} \\left( \\frac{\\Delta^2}{4} - \\frac{\\Delta^2}{4} \\right) = 0\n$$\n由于量化误差的均值为 $0$，方差简化为误差平方的均值，$\\sigma_q^2 = \\mathrm{E}[e^2]$。\n$$\n\\sigma_q^2 = \\mathrm{E}[e^2] = \\int_{-\\infty}^{\\infty} e^2 \\cdot p(e) \\, de\n$$\n$$\n\\sigma_q^2 = \\int_{-\\frac{\\Delta}{2}}^{\\frac{\\Delta}{2}} e^2 \\cdot \\frac{1}{\\Delta} \\, de = \\frac{1}{\\Delta} \\left[ \\frac{e^3}{3} \\right]_{-\\frac{\\Delta}{2}}^{\\frac{\\Delta}{2}}\n$$\n$$\n\\sigma_q^2 = \\frac{1}{3\\Delta} \\left( \\left(\\frac{\\Delta}{2}\\right)^3 - \\left(-\\frac{\\Delta}{2}\\right)^3 \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{8} - \\left(-\\frac{\\Delta^3}{8}\\right) \\right)\n$$\n$$\n\\sigma_q^2 = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{8} + \\frac{\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( 2 \\frac{\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{4} \\right)\n$$\n$$\n\\sigma_q^2 = \\frac{\\Delta^2}{12}\n$$\n这就是量化噪声方差。\n\n### 第2部分：信噪比 (SNR) 的计算\n\nSNR 定义为 $\\mathrm{SNR} = \\frac{P_x}{\\sigma_q^2}$，其中 $P_x$ 是输入信号 $x[n]$ 的平均功率，$\\sigma_q^2$ 是上面推导出的量化噪声方差。\n\n输入信号为 $x[n] = A \\sin(2\\pi f n T_s)$。平均信号功率 $P_x$ 是 $x[n]$ 的时间平均功率。对于正弦信号，或更一般地，对于遍历信号，这可以计算为信号值平方的期望。问题指出，采样相位在 $[0, 2\\pi)$ 上是遍历的，这允许我们将相位 $\\theta_n = 2\\pi f n T_s$ 视为一个在区间 $[0, 2\\pi)$ 上均匀分布的随机变量 $\\theta$。\n$$\nP_x = \\mathrm{E}[x^2] = \\mathrm{E}[(A \\sin(\\theta))^2] = A^2 \\mathrm{E}[\\sin^2(\\theta)]\n$$\n期望 $\\mathrm{E}[\\sin^2(\\theta)]$ 通过对 $\\theta$ 的分布进行积分来计算：\n$$\n\\mathrm{E}[\\sin^2(\\theta)] = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\sin^2(\\theta) \\, d\\theta\n$$\n使用三角恒等式 $\\sin^2(\\theta) = \\frac{1 - \\cos(2\\theta)}{2}$：\n$$\n\\mathrm{E}[\\sin^2(\\theta)] = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\left(\\frac{1 - \\cos(2\\theta)}{2}\\right) \\, d\\theta = \\frac{1}{4\\pi} \\left[ \\theta - \\frac{\\sin(2\\theta)}{2} \\right]_{0}^{2\\pi}\n$$\n$$\n\\mathrm{E}[\\sin^2(\\theta)] = \\frac{1}{4\\pi} \\left( (2\\pi - 0) - (0 - 0) \\right) = \\frac{2\\pi}{4\\pi} = \\frac{1}{2}\n$$\n因此，平均信号功率为：\n$$\nP_x = A^2 \\cdot \\frac{1}{2} = \\frac{A^2}{2}\n$$\n现在我们可以使用 $P_x$ 和 $\\sigma_q^2$ 的结果来计算 SNR：\n$$\n\\mathrm{SNR} = \\frac{P_x}{\\sigma_q^2} = \\frac{A^2/2}{\\Delta^2/12} = \\frac{A^2}{2} \\cdot \\frac{12}{\\Delta^2} = \\frac{6A^2}{\\Delta^2}\n$$\n这就是信噪比的最终表达式。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{\\Delta^2}{12}  \\frac{6A^2}{\\Delta^2} \\end{pmatrix}}$$"
        },
        {
            "introduction": "真实世界的传感器数据很少只包含单一类型的噪声，它通常是多种噪声过程在不同时间尺度上混合作用的结果。艾伦方差（Allan variance）是一种强大的时序分析工具，专门用于识别和表征这些不同的噪声源，尤其是在生物医学设备中常见的惯性传感器（如陀螺仪）数据中。本计算练习  提供了一个宝贵的动手实践机会，你将学习如何实现这一标准工业技术，以合成、分析并分类如白噪声、偏置不稳定性和速率随机游走等关键噪声类型，从而将理论知识应用于复杂的真实数据场景。",
            "id": "3900256",
            "problem": "考虑一个用于生物医学设备运动跟踪的陀螺仪所产生的离散时间角速率测量序列。该序列为 $x_0, x_1, \\dots, x_{N-1}$，以恒定间隔 $T_0 = 1/f_s$ 秒进行采样，其中 $x_k$ 的单位为弧度/秒 ($\\mathrm{rad/s}$)。对于整数 $m \\ge 1$，在平均时间 $ \\tau = m T_0 $ 下的阿伦方差是基于重叠聚类平均值定义的，其中聚类平均值为 $ \\bar{x}_k^{(m)} = \\frac{1}{m} \\sum_{i=k}^{k+m-1} x_i $，对于 $k \\in \\{0,1,\\dots,N-m\\}$。阿伦方差为 $$\\sigma^2(\\tau) = \\frac{1}{2} \\left\\langle \\left( \\bar{x}_{k+1}^{(m)} - \\bar{x}_k^{(m)} \\right)^2 \\right\\rangle,$$ 其中 $\\langle \\cdot \\rangle$ 表示对所有产生重叠聚类对的有效索引 $k$ 进行平均。阿伦偏差为 $ \\sigma(\\tau) = \\sqrt{\\sigma^2(\\tau)} $。\n\n陀螺仪测量中的噪声机制通常可以通过 $ \\sigma(\\tau) $ 在对数-对数图上的标度行为进行分类，这种行为反映了底层的频谱特性。目标是实现从 $x_k$ 计算阿伦偏差的功能，该计算针对一组对数间隔的平均时间 $\\tau$ 进行，然后使用在 $\\tau$ 的一个内部区间上计算出的单一特征斜率来对主要噪声机制进行分类，预计在该区间内某一种机制占主导地位。\n\n基本依据：使用所提供的重叠阿伦方差的核心定义、聚类平均值的定义，以及对数-对数尺度上的斜率与标度行为之间的关系。除这些核心定义外，不要假设任何快捷公式。\n\n你的程序必须：\n- 在指定的参数集下合成测试序列 $x_k$。\n- 在一组对数尺度上等间距的平均时间 $ \\tau $ 上计算 $ \\sigma(\\tau) $（选择至少 $15$ 个不同的 $m$ 值，范围从 $m=1$ 到 $m = \\lfloor N/4 \\rfloor$）。\n- 在 $\\tau$ 网格的中间区间上，估算 $ \\log_{10} \\sigma(\\tau) $ 相对于 $ \\log_{10} \\tau $ 的单一代表性斜率 $s$（排除至少最小和最大的 $20\\%$ 的 $\\tau$ 值以避免边界效应）。\n- 根据以下整数代码映射，使用斜率 $s$ 对主要机制进行分类：\n    - 代码 $0$：角速率白噪声（角度随机游走），特征为 $s \\approx -\\tfrac{1}{2}$。\n    - 代码 $1$：偏置不稳定性（闪烁噪声，$1/f$ 噪声），特征为 $s \\approx 0$。\n    - 代码 $2$：速率随机游走（$1/f^2$ 噪声），特征为 $s \\approx +\\tfrac{1}{2}$。\n    - 代码 $3$：量化噪声，特征为 $s \\approx -1$。\n    - 代码 $4$：其他或不确定行为（如果 $s$ 不在所列的典型斜率附近，则使用此代码）。\n- 分类决策必须通过对 $s$ 进行带有合理裕量的阈值化来做出，以使小的数值偏差不会改变分类决策。实现固定的阈值，将斜率轴划分为上述类别。\n\n科学真实性与单位：\n- 所有角速率值必须以 $\\mathrm{rad/s}$ 为单位，平均时间 $\\tau$ 以秒为单位，采样频率 $f_s$ 以赫兹（$\\mathrm{Hz}$）为单位。\n- 以 $\\mathrm{rad/s}$ 或与 $x_k$ 一致的派生单位表示任何内部计算的系数。\n- 输出不包含单位，但内部计算必须遵守单位制。\n\n用于合成 $x_k$ 的测试套件和参数值：\n使用以下参数生成四个独立的测试用例，每个用例在采样频率 $f_s$ 下产生 $N$ 个样本。如下所述，通过对指定的噪声分量求和来构造 $x_k$。在每个用例中使用固定的随机种子以保证可复现性。\n\n- 用例 $1$（白噪声主导）：\n    - $N = 8192$，$f_s = 100\\,\\mathrm{Hz}$。\n    - 白噪声标准差 $\\sigma_w = 3.0 \\times 10^{-3}\\,\\mathrm{rad/s}$。\n    - 不存在其他分量。\n\n- 用例 $2$（通过近似粉红噪声主导的偏置不稳定性）：\n    - $N = 8192$，$f_s = 100\\,\\mathrm{Hz}$。\n    - 白噪声标准差 $\\sigma_w = 3.0 \\times 10^{-4}\\,\\mathrm{rad/s}$。\n    - 添加一个零均值的近似粉红噪声分量（在频域中，单边振幅被整形为与 $1/\\sqrt{f}$ 成正比，且直流分量为零），并将其缩放至均方根值等于 $5.0 \\times 10^{-3}\\,\\mathrm{rad/s}$。\n\n- 用例 $3$（通过积分白噪声过程主导的速率随机游走）：\n    - $N = 8192$，$f_s = 100\\,\\mathrm{Hz}$。\n    - 白噪声标准差 $\\sigma_w = 3.0 \\times 10^{-4}\\,\\mathrm{rad/s}$。\n    - 添加一个速率随机游走分量，定义为 $b_k = \\sum_{i=0}^{k} w_i$，其中 $w_i$ 是独立的标准差为 $\\sigma_{\\mathrm{rw}} = 1.0 \\times 10^{-5}\\,\\mathrm{rad/s}$ 每样本的正态样本；速率随机游走分量为 $b_k$（单位为 $\\mathrm{rad/s}$）。\n\n- 用例 $4$（量化主导）：\n    - $N = 8192$，$f_s = 100\\,\\mathrm{Hz}$。\n    - 白噪声标准差 $\\sigma_w = 3.0 \\times 10^{-4}\\,\\mathrm{rad/s}$。\n    - 使用最近步长舍入法，将所得信号量化到步长 $q = 5.0 \\times 10^{-3}\\,\\mathrm{rad/s}$，即 $x_k \\leftarrow q \\cdot \\mathrm{round}(x_k / q)$。\n\n合成细节：\n- 白噪声分量是 $w_k \\sim \\mathcal{N}(0, \\sigma_w^2)$，它是独立的并直接加到 $x_k$ 上。\n- 粉红噪声分量必须通过以下方式合成：对复高斯谱进行整形，使其在正频率处的振幅与 $1/\\sqrt{f}$ 成正比，将零频分量设为 $0$，然后使用离散傅里叶逆变换获得实值时间序列；将所得序列缩放至指定的均方根值。确保其为零均值。\n- 速率随机游走分量是通过对其增量过程 $w_i$ 进行累积求和形成的；将其加到 $x_k$ 上。\n\n计算输出：\n- 对于每个测试用例，在选定的 $ \\tau $ 值集合上计算阿伦偏差 $ \\sigma(\\tau) $，在内部区间上估计斜率 $s$，并使用上述整数代码映射进行分类。\n- 最终的程序输出必须是单行文本，包含按用例 $1$ 到 $4$ 顺序排列的四个分类代码，形式为用方括号括起来的逗号分隔列表（例如，$[c_1,c_2,c_3,c_4]$）。输出必须只包含整数。\n\n角度单位说明：\n- 角度和角速率的单位是弧度；平均时间 $\\tau$ 的单位是秒。不需要进行角度单位转换。\n\n数值规范：\n- 对于最大值 $m$，使用至少 $15$ 个不同的平均时间，且 $m$ 最大不超过 $ \\lfloor N/4 \\rfloor $。\n- 用于斜率估计的内部区间必须排除至少最小和最大的 $20\\%$ 的 $\\tau$ 值。\n- 斜率估计必须对 $ (\\log_{10} \\tau, \\log_{10} \\sigma(\\tau)) $ 对使用普通最小二乘法。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如 $[c_1,c_2,c_3,c_4]$）。",
            "solution": "此问题的解决方案涉及合成四个不同的时间序列，每个序列代表陀螺仪传感器中发现的一种主要噪声过程，然后根据其阿伦偏差图的斜率对这些过程进行分类。该方法分为三个主要阶段：信号合成、阿伦偏差计算和基于斜率的分类。\n\n### 1. 信号合成\n\n对于四个测试用例中的每一个，都会在采样频率 $f_s=100\\,\\mathrm{Hz}$（采样周期 $T_0 = 1/f_s = 0.01\\,\\mathrm{s}$）下生成一个长度为 $N=8192$ 的离散时间信号 $x_k$。每个用例都使用唯一的随机种子以确保可复现性。\n\n- **用例1（白噪声）：** 信号完全由零均值高斯白噪声过程组成，$x_k = w_k$，其中 $w_k \\sim \\mathcal{N}(0, \\sigma_w^2)$，标准差为 $\\sigma_w = 3.0 \\times 10^{-3}\\,\\mathrm{rad/s}$。\n\n- **用例2（偏置不稳定性）：** 信号是一个低水平白噪声分量（$w_k$，$\\sigma_w = 3.0 \\times 10^{-4}\\,\\mathrm{rad/s}$）和一个主导的粉红噪声（闪烁噪声）分量 $p_k$ 的和。粉红噪声在频域中合成。生成一个复高斯白噪声谱，然后通过一个对于频率 $f > 0$ 与 $1/\\sqrt{f}$ 成正比的振幅滤波器进行整形。直流分量（$f=0$）设置为零。快速傅里叶逆变换（iFFT）产生时域信号 $p_k$，然后将其缩放至均方根（RMS）值为 $5.0 \\times 10^{-3}\\,\\mathrm{rad/s}$ 并使其均值为零。最终信号为 $x_k = w_k + p_k$。\n\n- **用例3（速率随机游走）：** 信号是一个低水平白噪声分量（$w_k$，$\\sigma_w = 3.0 \\times 10^{-4}\\,\\mathrm{rad/s}$）和一个速率随机游走分量 $b_k$ 的和。速率随机游走通过对一个离散时间白噪声过程进行累积求和生成，$b_k = \\sum_{i=0}^{k} w'_i$，其中增量 $w'_i$ 从 $\\mathcal{N}(0, \\sigma_{\\mathrm{rw}}^2)$ 中抽取，$\\sigma_{\\mathrm{rw}} = 1.0 \\times 10^{-5}\\,\\mathrm{rad/s}$。最终信号为 $x_k = w_k + b_k$。\n\n- **用例4（量化噪声）：** 首先生成一个 $\\sigma_w = 3.0 \\times 10^{-4}\\,\\mathrm{rad/s}$ 的白噪声信号。然后使用量化步长为 $q = 5.0 \\times 10^{-3}\\,\\mathrm{rad/s}$ 的最近步长舍入函数对该信号进行量化。操作为 $x_k \\leftarrow q \\cdot \\mathrm{round}(x_k / q)$。\n\n### 2. 阿伦偏差计算\n\n阿伦偏差 $\\sigma(\\tau)$ 是为一组平均时间 $\\tau$ 计算的。平均时间是通过选择一组对数间隔的聚类大小 $m$ 来确定的。生成一组约 $30$ 个 $m$ 值，范围从 $m=1$ 到 $m_{max} = \\lfloor N/4 \\rfloor = 2048$，然后将这些值四舍五入到最近的整数并取唯一值。这通常会产生超过 $15$ 个不同的 $m$ 值。相应的平均时间为 $\\tau = m T_0$。\n\n对于每个 $m$ 值，阿伦方差 $\\sigma^2(\\tau)$ 根据其定义进行计算：\n$$ \\sigma^2(\\tau) = \\frac{1}{2} \\left\\langle \\left( \\bar{x}_{k+1}^{(m)} - \\bar{x}_k^{(m)} \\right)^2 \\right\\rangle $$\n其中 $\\bar{x}_k^{(m)}$ 是从索引 $k$ 开始的 $m$ 个连续样本的平均值：\n$$ \\bar{x}_k^{(m)} = \\frac{1}{m} \\sum_{i=k}^{k+m-1} x_i $$\n运算符 $\\langle \\cdot \\rangle$ 表示对所有 $N-m$ 个可能的相邻聚类对进行平均。因此，方差计算如下：\n$$ \\sigma^2(\\tau) = \\frac{1}{2(N-m)} \\sum_{k=0}^{N-m-1} \\left( \\bar{x}_{k+1}^{(m)} - \\bar{x}_k^{(m)} \\right)^2 $$\n在计算上，聚类平均值 $\\bar{x}_k^{(m)}$ 可以通过将信号 $x_k$ 与长度为 $m$ 的归一化窗口进行一维卷积来高效计算。阿伦偏差则为 $\\sigma(\\tau) = \\sqrt{\\sigma^2(\\tau)}$。\n\n### 3. 斜率估计与分类\n\n主要噪声类型通过阿伦偏差曲线在对数-对数图上的斜率来识别。通过对数据对 $(\\log_{10} \\tau, \\log_{10} \\sigma(\\tau))$ 进行普通最小二乘线性回归，可以估算出单一的代表性斜率 $s$。为避免有限数据长度（在大的 $\\tau$ 处）和其他噪声类型（在小的 $\\tau$ 处）引起的边界效应，拟合在数据的内部区间上进行。具体来说，从回归中排除了最小的 $25\\%$ 和最大的 $25\\%$ 的 $(\\tau, \\sigma(\\tau))$ 数据对。\n\n然后使用估算出的斜率 $s$，通过以下固定阈值对噪声过程进行分类，这些阈值设置在典型斜率之间的中点：\n- **代码 3 (量化噪声):** $s  -0.75$，理论斜率为 $-1$。\n- **代码 0 (白噪声 / 角度随机游走):** $-0.75 \\le s  -0.25$，理论斜率为 $-0.5$。\n- **代码 1 (偏置不稳定性 / 闪烁噪声):** $-0.25 \\le s  +0.25$，理论斜率为 $0$。\n- **代码 2 (速率随机游走):** $+0.25 \\le s \\le +0.75$，理论斜率为 $+0.5$。\n- **代码 4 (其他/不确定):** 如果 $s$ 落在上述范围之外。\n\n此程序应用于四个合成信号中的每一个，为每个用例生成一个分类代码。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_white_noise(N, sigma_w, rng):\n    \"\"\"Generates a white noise sequence.\"\"\"\n    return rng.normal(scale=sigma_w, size=N)\n\ndef generate_pink_noise(N, fs, rms_value, rng):\n    \"\"\"Generates an approximate pink noise sequence using FFT.\"\"\"\n    n_freqs = N // 2 + 1\n    freqs = np.fft.rfftfreq(N, d=1.0 / fs)\n\n    # Generate complex Gaussian noise spectrum\n    spec = rng.standard_normal(n_freqs) + 1j * rng.standard_normal(n_freqs)\n    \n    # Shape the spectrum amplitude by 1/sqrt(f)\n    pink_filter = np.ones_like(freqs)\n    if len(freqs)  1:\n        pink_filter[1:] = 1.0 / np.sqrt(freqs[1:])\n    pink_filter[0] = 0  # No DC component\n\n    spec *= pink_filter\n    \n    # Ensure properties for real signal are met\n    if N % 2 == 0:\n        spec[-1] = np.real(spec[-1])\n\n    # Inverse FFT to get time domain signal\n    signal = np.fft.irfft(spec, n=N)\n\n    # Scale to desired RMS\n    current_rms = np.sqrt(np.mean(signal**2))\n    if current_rms  1e-9:\n        signal *= (rms_value / current_rms)\n\n    # Remove any residual mean\n    signal -= np.mean(signal)\n    \n    return signal\n\ndef generate_rate_random_walk(N, sigma_rw, rng):\n    \"\"\"Generates a rate random walk sequence.\"\"\"\n    increments = rng.normal(scale=sigma_rw, size=N)\n    return np.cumsum(increments)\n\ndef apply_quantization(signal, q):\n    \"\"\"Applies quantization to a signal.\"\"\"\n    return q * np.round(signal / q)\n\ndef compute_allan_deviation(x, fs, m_values):\n    \"\"\"Computes the overlapped Allan deviation.\"\"\"\n    N = len(x)\n    T0 = 1.0 / fs\n    tau_values = []\n    adev_values = []\n\n    for m in m_values:\n        if m = N:\n            continue\n        \n        # Efficiently compute cluster averages using convolution\n        cluster_avg = np.convolve(x, np.ones(m) / m, mode='valid')\n        \n        if len(cluster_avg)  2:\n            continue\n            \n        # Compute differences of adjacent cluster averages\n        diffs = cluster_avg[1:] - cluster_avg[:-1]\n        \n        # Compute Allan variance\n        avar = 0.5 * np.mean(diffs**2)\n        \n        # Compute Allan deviation\n        adev = np.sqrt(avar)\n        \n        tau_values.append(m * T0)\n        adev_values.append(adev)\n\n    return np.array(tau_values), np.array(adev_values)\n\ndef get_classification(slope):\n    \"\"\"Classifies the noise type based on the log-log slope.\"\"\"\n    if slope  -0.75:\n        return 3  # Quantization\n    elif slope  -0.25:\n        return 0  # White noise\n    elif slope  0.25:\n        return 1  # Bias instability\n    elif slope = 0.75:\n        return 2  # Rate random walk\n    else:\n        return 4  # Other/Indeterminate\n\ndef process_case(params):\n    \"\"\"Processes a single test case from synthesis to classification.\"\"\"\n    N = params['N']\n    fs = params['fs']\n    rng = np.random.default_rng(params['seed'])\n    \n    # Signal Synthesis\n    x = np.zeros(N, dtype=np.float64)\n    if params['type'] == 'white':\n        x = generate_white_noise(N, params['sigma_w'], rng)\n    elif params['type'] == 'pink':\n        x = generate_white_noise(N, params['sigma_w'], rng)\n        x += generate_pink_noise(N, fs, params['pink_rms'], rng)\n    elif params['type'] == 'rrw':\n        x = generate_white_noise(N, params['sigma_w'], rng)\n        x += generate_rate_random_walk(N, params['sigma_rw'], rng)\n    elif params['type'] == 'quant':\n        signal_unquantized = generate_white_noise(N, params['sigma_w'], rng)\n        x = apply_quantization(signal_unquantized, params['q'])\n\n    # Allan Deviation Calculation\n    m_max = N // 4\n    # Generate a log-spaced set of m values, ensuring at least 15 unique values.\n    m_values = np.unique(np.round(np.logspace(np.log10(1), np.log10(m_max), num=30))).astype(int)\n    \n    tau_values, adev_values = compute_allan_deviation(x, fs, m_values)\n    \n    # Filter out zero or negative adev values for log plot\n    valid_indices = adev_values  0\n    tau_values = tau_values[valid_indices]\n    adev_values = adev_values[valid_indices]\n\n    if len(tau_values)  5: # Not enough points for a reliable fit\n        return 4\n\n    # Slope Estimation\n    log_tau = np.log10(tau_values)\n    log_adev = np.log10(adev_values)\n    \n    # Fit over the middle span (excluding first and last 25%)\n    n_points = len(log_tau)\n    # The problem asks to exclude at least 20%, we'll use 25% for a more stable interior.\n    start_index = int(np.ceil(0.25 * n_points))\n    end_index = int(np.floor(0.75 * n_points))\n    \n    if end_index = start_index + 1: # Not enough points in the middle span\n        return 4\n\n    fit_log_tau = log_tau[start_index:end_index]\n    fit_log_adev = log_adev[start_index:end_index]\n    \n    slope, _ = np.polyfit(fit_log_tau, fit_log_adev, 1)\n\n    # Classification\n    return get_classification(slope)\n\ndef solve():\n    \"\"\"Main solver function to run all test cases.\"\"\"\n    test_cases = [\n        # Case 1: White noise dominated\n        {'type': 'white', 'N': 8192, 'fs': 100, 'sigma_w': 3.0e-3, 'seed': 0},\n        # Case 2: Bias instability dominated\n        {'type': 'pink', 'N': 8192, 'fs': 100, 'sigma_w': 3.0e-4, 'pink_rms': 5.0e-3, 'seed': 1},\n        # Case 3: Rate random walk dominated\n        {'type': 'rrw', 'N': 8192, 'fs': 100, 'sigma_w': 3.0e-4, 'sigma_rw': 1.0e-5, 'seed': 2},\n        # Case 4: Quantization dominated\n        {'type': 'quant', 'N': 8192, 'fs': 100, 'sigma_w': 3.0e-4, 'q': 5.0e-3, 'seed': 3}\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result_code = process_case(case_params)\n        results.append(result_code)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}