{
    "hands_on_practices": [
        {
            "introduction": "在现代生物医学系统中，模拟信号的数字化是数据采集的基石。然而，模数转换（ADC）过程本身会引入一种被称为量化噪声的特有误差。本练习将引导您从第一性原理出发，推导在标准假设下这种噪声的功率，并计算信噪比（SNR）。通过这个过程，您将具体理解系统的基本参数（如量化阶距 $\\Delta$）如何直接决定噪声的基线水平。",
            "id": "3900253",
            "problem": "一个生物医学监测系统使用模数转换器 (ADC) 来数字化一个带限的动脉血压波形。该 ADC 可建模为一个步长为 $\\Delta$ 的均匀中置型量化器，将任何实数输入 $x$ 映射到由 $Q(x) = \\Delta \\cdot \\mathrm{round}(x/\\Delta)$ 定义的 $Q(x)$。令量化误差为 $e = Q(x) - x$。假设量化噪声建模满足以下经过充分检验的条件：(i) 输入使得 $e$ 与 $x$ 統計独立，以及 (ii) $e$ 在一个量化单元内等可能地取任何值，即 $e$ 在 $[-\\Delta/2, \\Delta/2]$ 上服从均匀分布。\n\n1. 仅使用方差的定义和 $e$ 的假设均匀分布，推导量化噪声方差 $\\sigma_q^2$。\n\n2. 在校准阶段，ADC 的输入波形是一个正弦波 $x[n] = A \\sin(2\\pi f n T_s)$，其中 $A$ 是幅度，$f$ 是频率，$T_s$ 是采样周期，$A$ 足够小以避免削波，且 $f T_s$ 使得采样相位在 $[0, 2\\pi)$ 上是遍历的。在上述独立性假设下，计算信噪比 (SNR)，其定义为平均信号功率与量化噪声方差的比率，$ \\mathrm{SNR} = P_x / \\sigma_q^2$，其中 $P_x$ 是 $x[n]$ 的时间平均功率。将 SNR 表示为 $A$ 和 $\\Delta$ 的闭式、无量纲比。\n\n提供一个包含量化噪声方差和 SNR 的行矩阵作为最终答案。无需提供数值。",
            "solution": "该问题提法明确，具有科学依据，并为完整的推导提供了所有必要信息。我们将按要求分两部分进行。\n\n第 1 部分：量化噪声方差 $\\sigma_q^2$ 的推导。\n\n量化误差是随机变量 $e$，在区间 $[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}]$上服从均匀概率分布。因此，$e$ 的概率密度函数 (PDF)，记为 $p(e)$，是：\n$$\np(e) =\n\\begin{cases}\n\\frac{1}{\\Delta}  & \\text{for } -\\frac{\\Delta}{2} \\le e \\le \\frac{\\Delta}{2} \\\\\n0  & \\text{otherwise}\n\\end{cases}\n$$\n随机变量 $e$ 的方差，记为 $\\sigma_q^2$，定义为 $\\sigma_q^2 = \\mathrm{E}[(e - \\mu_e)^2]$，其中 $\\mu_e = \\mathrm{E}[e]$ 是 $e$ 的均值。\n\n首先，我们计算均值 $\\mu_e$：\n$$\n\\mu_e = \\mathrm{E}[e] = \\int_{-\\infty}^{\\infty} e \\cdot p(e) \\, de\n$$\n代入概率密度函数 $p(e)$：\n$$\n\\mu_e = \\int_{-\\frac{\\Delta}{2}}^{\\frac{\\Delta}{2}} e \\cdot \\frac{1}{\\Delta} \\, de = \\frac{1}{\\Delta} \\left[ \\frac{e^2}{2} \\right]_{-\\frac{\\Delta}{2}}^{\\frac{\\Delta}{2}}\n$$\n$$\n\\mu_e = \\frac{1}{2\\Delta} \\left( \\left(\\frac{\\Delta}{2}\\right)^2 - \\left(-\\frac{\\Delta}{2}\\right)^2 \\right) = \\frac{1}{2\\Delta} \\left( \\frac{\\Delta^2}{4} - \\frac{\\Delta^2}{4} \\right) = 0\n$$\n由于量化误差的均值为 $0$，方差简化为均方误差，即 $\\sigma_q^2 = \\mathrm{E}[e^2]$。\n$$\n\\sigma_q^2 = \\mathrm{E}[e^2] = \\int_{-\\infty}^{\\infty} e^2 \\cdot p(e) \\, de\n$$\n$$\n\\sigma_q^2 = \\int_{-\\frac{\\Delta}{2}}^{\\frac{\\Delta}{2}} e^2 \\cdot \\frac{1}{\\Delta} \\, de = \\frac{1}{\\Delta} \\left[ \\frac{e^3}{3} \\right]_{-\\frac{\\Delta}{2}}^{\\frac{\\Delta}{2}}\n$$\n$$\n\\sigma_q^2 = \\frac{1}{3\\Delta} \\left( \\left(\\frac{\\Delta}{2}\\right)^3 - \\left(-\\frac{\\Delta}{2}\\right)^3 \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{8} - \\left(-\\frac{\\Delta^3}{8}\\right) \\right)\n$$\n$$\n\\sigma_q^2 = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{8} + \\frac{\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( 2 \\frac{\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{4} \\right)\n$$\n$$\n\\sigma_q^2 = \\frac{\\Delta^2}{12}\n$$\n这就是量化噪声方差。\n\n第 2 部分：信噪比 (SNR) 的计算。\n\nSNR 定义为 $\\mathrm{SNR} = \\frac{P_x}{\\sigma_q^2}$，其中 $P_x$ 是输入信号 $x[n]$ 的平均功率，$\\sigma_q^2$ 是上面推导出的量化噪声方差。\n\n输入信号为 $x[n] = A \\sin(2\\pi f n T_s)$。平均信号功率 $P_x$ 是 $x[n]$ 的时间平均功率。对于正弦信号，或更一般地，对于遍历信号，这可以计算为信号值平方的期望。问题指出采样相位在 $[0, 2\\pi)$ 上是遍历的，这允许我们将相位 $\\theta_n = 2\\pi f n T_s$ 视为在区间 $[0, 2\\pi)$ 上均匀分布的随机变量 $\\theta$。\n$$\nP_x = \\mathrm{E}[x^2] = \\mathrm{E}[(A \\sin(\\theta))^2] = A^2 \\mathrm{E}[\\sin^2(\\theta)]\n$$\n期望 $\\mathrm{E}[\\sin^2(\\theta)]$ 通过对 $\\theta$ 的分布进行积分来计算：\n$$\n\\mathrm{E}[\\sin^2(\\theta)] = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\sin^2(\\theta) \\, d\\theta\n$$\n使用三角恒等式 $\\sin^2(\\theta) = \\frac{1 - \\cos(2\\theta)}{2}$：\n$$\n\\mathrm{E}[\\sin^2(\\theta)] = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\left(\\frac{1 - \\cos(2\\theta)}{2}\\right) \\, d\\theta = \\frac{1}{4\\pi} \\left[ \\theta - \\frac{\\sin(2\\theta)}{2} \\right]_{0}^{2\\pi}\n$$\n$$\n\\mathrm{E}[\\sin^2(\\theta)] = \\frac{1}{4\\pi} \\left( (2\\pi - 0) - (0 - 0) \\right) = \\frac{2\\pi}{4\\pi} = \\frac{1}{2}\n$$\n因此，平均信号功率为：\n$$\nP_x = A^2 \\cdot \\frac{1}{2} = \\frac{A^2}{2}\n$$\n现在我们可以使用 $P_x$ 和 $\\sigma_q^2$ 的结果来计算 SNR：\n$$\n\\mathrm{SNR} = \\frac{P_x}{\\sigma_q^2} = \\frac{A^2/2}{\\Delta^2/12} = \\frac{A^2}{2} \\cdot \\frac{12}{\\Delta^2} = \\frac{6A^2}{\\Delta^2}\n$$\n这就是信噪比的最终表达式。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{\\Delta^2}{12} & \\frac{6A^2}{\\Delta^2} \\end{pmatrix}}$$"
        },
        {
            "introduction": "虽然简单的加性噪声模型（$y = \\text{信号} + \\text{噪声}$）是一个常见的假设，但许多物理过程，尤其是那些涉及增益波动的系统（如放大器或光学传感器），实际上遵循乘性噪声模型（$y = \\text{增益} \\times \\text{信号} + \\text{噪声}$）。本练习挑战您分析当乘性噪声被错误地简化为加性模型时，使用普通最小二乘法进行线性回归所带来的后果。通过推导渐近偏差，您将学会量化评估模型误设所引入的系统性误差，这是任何严谨的建模者都必须掌握的关键技能。",
            "id": "3900200",
            "problem": "考虑一次反射式光电容积脉搏波（Photoplethysmography, PPG）测量，其中观测到的光电二极管输出被建模为 $y = g I + \\epsilon$，其中 $I$ 是受脉动血容量调制的入射光强度，$g$ 是一个由于传感器和放大器变异性而波动的随机增益，而 $\\epsilon$ 是加性电子噪声。假设 $I$ 是一个具有有限二阶矩的随机变量，$g$ 是一个独立的、具有有限二阶矩的随机变量，$\\epsilon$ 是一个均值为零、且独立于 $I$ 和 $g$ 的随机变量。在许多生物医学信号处理流程中，这种乘性波动通过写作 $y \\approx \\beta I + \\nu$ 的形式被近似为加性的，其中 $\\beta$ 是某个常数，$\\nu$ 是一个加性扰动项，然后使用普通最小二乘法来估计 $\\beta$。\n\n从普通最小二乘法的基本原理和无偏性定义（$\\mathbb{E}[\\hat{\\beta}] = \\beta$）出发，当真实数据生成过程为 $y = g I + \\epsilon$ 时，推导将 $y$ 对 $I$ 进行回归所得到的斜率估计量 $\\hat{\\beta}$ 的大样本极限。利用这个结果，定义强制 $\\beta = 1$ 的加性近似（即将 $y$ 建模为 $y \\approx I + \\nu$），并推导该近似所导致的渐近偏差。将该偏差表示为仅含 $\\mathbb{E}[g]$ 的单个闭式解析表达式。除了所述的独立性和矩假设外，不要假设任何特定的分布形式。无需进行数值四舍五入。你的最终答案必须是单个解析表达式。",
            "solution": "本题要求在特定形式的模型设定错误下，推导普通最小二乘法（OLS）估计量的渐近偏差。我们首先验证问题陈述的有效性。\n\n### 第一步：提取已知条件\n-   真实数据生成过程：$y = g I + \\epsilon$。\n-   近似模型：$y \\approx \\beta I + \\nu$。\n-   $y$：观测到的光电二极管输出。\n-   $I$：入射光强度，一个具有有限二阶矩的随机变量。\n-   $g$：随机增益，一个独立的、具有有限二阶矩的随机变量。\n-   $\\epsilon$：加性电子噪声，一个均值为零、且独立于 $I$ 和 $g$ 的随机变量。\n-   $\\beta$：近似模型中的一个常数系数。\n-   $\\nu$：近似模型中的一个加性扰动项。\n-   $\\beta$ 的估计量（记为 $\\hat{\\beta}$）是通过使用普通最小二乘法将 $y$ 对 $I$ 进行回归得到的。\n-   任务是求出 $\\hat{\\beta}$ 的大样本极限，然后推导在 $\\beta = 1$ 的特定近似下的渐近偏差。最终答案应为仅含 $\\mathbb{E}[g]$ 的表达式。\n\n### 第二步：使用提取的已知条件进行验证\n该问题在科学上和数学上都是合理的。\n-   **科学依据**：模型 $y = gI + \\epsilon$ 是一个经典且物理上现实的测量系统表示，该系统包含乘性增益噪声（$g$）和加性传感器噪声（$\\epsilon$），这在像光电容积脉搏波这样的生物医学仪器中很常见。\n-   **适定性**：该问题是适定的。独立性和有限二阶矩的假设足以保证推导所需量（方差、协方差）的存在，并应用大数定律来找到 OLS 估计量的概率极限。问题要求一个唯一的、可推导的量。\n-   **客观性**：问题以精确、客观的数学语言陈述。\n-   **完整性和一致性**：所有必要的信息（模型、变量的统计特性以及估计方法）都已提供。没有矛盾之处。\n\n### 第三步：结论与行动\n问题有效。将进行求解。\n\n### 求解过程\n\n本题要求解通过将 $y$ 对 $I$ 进行普通最小二乘法（OLS）回归得到的斜率估计量 $\\hat{\\beta}$ 的大样本极限。对于形如 $y_i = \\alpha + \\beta I_i + u_i$ 的简单线性回归模型，斜率系数 $\\beta$ 的 OLS 估计量由下式给出：\n$$\n\\hat{\\beta} = \\frac{\\sum_{i=1}^{n} (I_i - \\bar{I})(y_i - \\bar{y})}{\\sum_{i=1}^{n} (I_i - \\bar{I})^2} = \\frac{\\widehat{\\text{Cov}}(I, y)}{\\widehat{\\text{Var}}(I)}\n$$\n其中 $n$ 是样本数量，$\\bar{I}$ 和 $\\bar{y}$ 是样本均值，$\\widehat{\\text{Cov}}$ 和 $\\widehat{\\text{Var}}$ 分别是样本协方差和样本方差。\n\n我们关心的是该估计量的大样本行为。当 $n \\to \\infty$ 时，$\\hat{\\beta}$ 的概率极限（probability limit）可以通过应用大数定律找到，该定律指出样本矩依概率收敛于其对应的总体矩。\n$$\n\\text{plim}_{n \\to \\infty} \\hat{\\beta} = \\frac{\\text{Cov}(I, y)}{\\text{Var}(I)}\n$$\n这个表达式给出了 OLS 估计量收敛到的值，即使在基础线性模型被设定错误的情况下也是如此。为了评估这个表达式，我们必须使用给定的真实数据生成过程 $y = gI + \\epsilon$ 来计算协方差项 $\\text{Cov}(I, y)$。\n\n利用协方差算子的性质，我们有：\n$$\n\\text{Cov}(I, y) = \\text{Cov}(I, gI + \\epsilon)\n$$\n根据协方差的双线性性质：\n$$\n\\text{Cov}(I, gI + \\epsilon) = \\text{Cov}(I, gI) + \\text{Cov}(I, \\epsilon)\n$$\n问题陈述指出，噪声 $\\epsilon$ 独立于强度 $I$。两个独立随机变量之间的协方差为 $0$。因此，$\\text{Cov}(I, \\epsilon) = 0$。这可将表达式简化为：\n$$\n\\text{Cov}(I, y) = \\text{Cov}(I, gI)\n$$\n接下来，我们使用协方差的定义，$\\text{Cov}(X, Z) = \\mathbb{E}[XZ] - \\mathbb{E}[X]\\mathbb{E}[Z]$。\n$$\n\\text{Cov}(I, gI) = \\mathbb{E}[I \\cdot (gI)] - \\mathbb{E}[I]\\mathbb{E}[gI] = \\mathbb{E}[gI^2] - \\mathbb{E}[I]\\mathbb{E}[gI]\n$$\n问题陈述指出，随机增益 $g$ 和强度 $I$ 是独立的。这使得我们可以分离它们乘积的期望：\n$$\n\\mathbb{E}[gI^2] = \\mathbb{E}[g]\\mathbb{E}[I^2]\n$$\n$$\n\\mathbb{E}[gI] = \\mathbb{E}[g]\\mathbb{E}[I]\n$$\n将这些代回协方差的表达式中：\n$$\n\\text{Cov}(I, gI) = \\mathbb{E}[g]\\mathbb{E}[I^2] - \\mathbb{E}[I](\\mathbb{E}[g]\\mathbb{E}[I]) = \\mathbb{E}[g]\\mathbb{E}[I^2] - \\mathbb{E}[g](\\mathbb{E}[I])^2\n$$\n将项 $\\mathbb{E}[g]$ 因子分解出来：\n$$\n\\text{Cov}(I, gI) = \\mathbb{E}[g] \\left( \\mathbb{E}[I^2] - (\\mathbb{E}[I])^2 \\right)\n$$\n括号中的项是 $I$ 的方差的定义，即 $\\text{Var}(I) = \\mathbb{E}[I^2] - (\\mathbb{E}[I])^2$。\n因此，我们得到了协方差的结果：\n$$\n\\text{Cov}(I, y) = \\mathbb{E}[g]\\text{Var}(I)\n$$\n现在我们可以通过将此结果代入我们之前的公式来确定 $\\hat{\\beta}$ 的概率极限。我们假设 $\\text{Var}(I) > 0$，因为对一个常数进行回归是没有意义的。\n$$\n\\text{plim}_{n \\to \\infty} \\hat{\\beta} = \\frac{\\mathbb{E}[g]\\text{Var}(I)}{\\text{Var}(I)} = \\mathbb{E}[g]\n$$\n这表明 OLS 斜率估计量通常不会收敛到简化模型的参数 $\\beta$，而是收敛到随机增益的期望值 $\\mathbb{E}[g]$。\n\n接下来，问题要求我们考虑强制 $\\beta = 1$ 的特定加性近似。这对应于简化模型 $y \\approx I + \\nu$。在这种情况下，我们试图估计的“真实”参数值为 $\\beta = 1$。\n\n估计量的渐近偏差是其概率极限与它旨在估计的真实参数值之间的差。\n$$\n\\text{Asymptotic Bias} = \\text{plim}_{n \\to \\infty} \\hat{\\beta} - \\beta\n$$\n代入推导出的概率极限和目标参数值 $\\beta=1$：\n$$\n\\text{Asymptotic Bias} = \\mathbb{E}[g] - 1\n$$\n这个表达式表示当将乘性噪声模型 $y = gI + \\epsilon$ 错误地设定为简单的加性噪声模型 $y \\approx I + \\nu$，并使用 OLS 来估计被隐式假定为 $1$ 的斜率时，在大样本极限下产生的系统性误差。如果随机增益的均值 $\\mathbbE}[g]$ 不等于 $1$，则偏差非零。",
            "answer": "$$\\boxed{\\mathbb{E}[g] - 1}$$"
        },
        {
            "introduction": "理论建模之后，我们转向实际数据分析。在实践中，我们通常从传感器（如陀螺仪）获得时间序列数据，并需要识别其内在噪声的性质。本练习将介绍阿伦方差（Allan variance）这一强大工具，它能够根据信号方差随平均时间的变化来识别不同类型的噪声（例如，白噪声、闪烁噪声或随机游走）。这是一个完整的计算实践，您将合成具有已知噪声特征的数据，实现阿伦方差算法，并验证该技术能够正确识别潜在的噪声过程，从而将理论与实际数据分析联系起来。",
            "id": "3900256",
            "problem": "考虑一个用于生物医学设备运动跟踪的陀螺仪所产生的离散时间角速率测量序列。该序列为 $x_0, x_1, \\dots, x_{N-1}$，以恒定间隔 $T_0 = 1/f_s$ 秒进行采样，其中 $x_k$ 的单位为弧度/秒 ($\\mathrm{rad/s}$)。对于整数 $m \\ge 1$，在平均时间 $ \\tau = m T_0 $ 上的阿伦方差是基于重叠簇平均值定义的，其中簇平均值为 $ \\bar{x}_k^{(m)} = \\frac{1}{m} \\sum_{i=k}^{k+m-1} x_i $，对于 $k \\in \\{0,1,\\dots,N-m\\}$。阿伦方差为 $$\\sigma^2(\\tau) = \\frac{1}{2} \\left\\langle \\left( \\bar{x}_{k+1}^{(m)} - \\bar{x}_k^{(m)} \\right)^2 \\right\\rangle,$$ 其中 $\\langle \\cdot \\rangle$ 表示对所有产生重叠簇对的有效索引 $k$ 取平均值。阿伦偏差为 $ \\sigma(\\tau) = \\sqrt{\\sigma^2(\\tau)} $。\n\n陀螺仪测量中的噪声机制通常可以通过 $ \\sigma(\\tau) $ 在对数-对数图上的标度行为进行分类，这反映了其潜在的频谱特性。目标是实现从 $x_k$ 计算阿伦偏差的功能，该计算针对一组对数间隔的平均时间 $\\tau$ 进行，然后使用在 $\\tau$ 的一个内部区间上计算的单一特征斜率来对主导噪声机制进行分类，该区间预计由单一机制主导。\n\n基本原理：使用所提供的重叠阿伦方差的核心定义、簇平均值的定义，以及对数-对数尺度上的斜率与标度行为之间的关系。除了这些核心定义之外，不要假设任何快捷公式。\n\n您的程序必须：\n- 根据指定的参数集合成测试序列 $x_k$。\n- 在一组对数尺度上等间距的平均时间 $ \\tau $ 上计算 $ \\sigma(\\tau) $（选择至少 $15$ 个不同的 $m$ 值，范围从 $m=1$ 到 $m = \\lfloor N/4 \\rfloor$）。\n- 在 $\\tau$ 网格的中间跨度上估计 $ \\log_{10} \\sigma(\\tau) $ 相对于 $ \\log_{10} \\tau $ 的单一代表性斜率 $s$（排除至少最小和最大的 $20\\%$ 的 $\\tau$ 值以避免边界效应）。\n- 根据以下整数代码映射，使用斜率 $s$ 对主导机制进行分类：\n    - 代码 $0$：角速率白噪声（角度随机游走），其特征为 $s \\approx -\\tfrac{1}{2}$。\n    - 代码 $1$：偏置不稳定性（闪烁噪声，$1/f$），其特征为 $s \\approx 0$。\n    - 代码 $2$：速率随机游走（$1/f^2$），其特征为 $s \\approx +\\tfrac{1}{2}$。\n    - 代码 $3$：量化噪声，其特征为 $s \\approx -1$。\n    - 代码 $4$：其他或不确定行为（如果 $s$ 不接近所列的典型斜率，则使用此代码）。\n- 分类决策必须通过对 $s$ 进行带有合理裕量的阈值处理来做出，以确保小的数值偏差不会改变分类决策。实现固定的阈值，将斜率轴划分为上述类别。\n\n科学真实性和单位：\n- 所有角速率值必须以 $\\mathrm{rad/s}$ 为单位，平均时间 $\\tau$ 以秒为单位，采样频率 $f_s$ 以赫兹（$\\mathrm{Hz}$）为单位。\n- 以 $\\mathrm{rad/s}$ 或与 $x_k$ 一致的派生单位表示任何内部计算的系数。\n- 输出不包括单位，但内部计算必须遵守单位规定。\n\n用于合成 $x_k$ 的测试套件和参数值：\n使用以下参数生成四个独立的测试用例，每个用例在采样频率 $f_s$ 下产生 $N$ 个样本。如下所述，通过对指定的噪声分量求和来构造 $x_k$。在每个用例中使用固定的随机种子以保证可复现性。\n\n- 用例 $1$（白噪声主导）：\n    - $N = 8192$，$f_s = 100\\,\\mathrm{Hz}$。\n    - 白噪声标准差 $\\sigma_w = 3.0 \\times 10^{-3}\\,\\mathrm{rad/s}$。\n    - 不存在其他分量。\n\n- 用例 $2$（通过近似粉红噪声主导的偏置不稳定性）：\n    - $N = 8192$，$f_s = 100\\,\\mathrm{Hz}$。\n    - 白噪声标准差 $\\sigma_w = 3.0 \\times 10^{-4}\\,\\mathrm{rad/s}$。\n    - 添加一个零均值的近似粉红噪声分量（在频域中，其单边振幅与 $1/\\sqrt{f}$ 成正比，且直流分量为零），并将其缩放至均方根值等于 $5.0 \\times 10^{-3}\\,\\mathrm{rad/s}$。\n\n- 用例 $3$（通过积分白噪声过程主导的速率随机游走）：\n    - $N = 8192$，$f_s = 100\\,\\mathrm{Hz}$。\n    - 白噪声标准差 $\\sigma_w = 3.0 \\times 10^{-4}\\,\\mathrm{rad/s}$。\n    - 添加一个速率随机游走分量，定义为 $b_k = \\sum_{i=0}^{k} w_i$，其中 $w_i$ 是独立的标准差为 $\\sigma_{\\mathrm{rw}} = 1.0 \\times 10^{-5}\\,\\mathrm{rad/s}$ 每样本的正态样本；速率随机游走分量为 $b_k$（单位 $\\mathrm{rad/s}$）。\n\n- 用例 $4$（量化主导）：\n    - $N = 8192$，$f_s = 100\\,\\mathrm{Hz}$。\n    - 白噪声标准差 $\\sigma_w = 3.0 \\times 10^{-4}\\,\\mathrm{rad/s}$。\n    - 使用最近步长舍入法，将生成的信号量化到步长 $q = 5.0 \\times 10^{-3}\\,\\mathrm{rad/s}$，即 $x_k \\leftarrow q \\cdot \\mathrm{round}(x_k / q)$。\n\n合成细节：\n- 白噪声分量 $w_k \\sim \\mathcal{N}(0, \\sigma_w^2)$ 是独立的，并直接加到 $x_k$ 上。\n- 粉红噪声分量必须通过以下方式合成：对复高斯频谱进行整形，使其在正频率下的振幅与 $1/\\sqrt{f}$ 成正比，将零频分量设置为 $0$，然后使用离散傅里叶逆变换获得实值时间序列；将所得序列缩放至指定的均方根值。确保其为零均值。\n- 速率随机游走分量由其增量过程 $w_i$ 的累积和形成；将其加到 $x_k$ 上。\n\n计算输出：\n- 对于每个测试用例，在选定的一组 $ \\tau $ 值上计算阿伦偏差 $ \\sigma(\\tau) $，在内部跨度上估计斜率 $s$，并使用上面的整数代码映射进行分类。\n- 最终程序输出必须是一行，包含四个分类代码，按用例 $1$ 到 $4$ 的顺序，以逗号分隔的列表形式包含在方括号中（例如，$[c_1,c_2,c_3,c_4]$）。输出必须只包含整数。\n\n角度单位规范：角度和角速率以弧度为单位；平均时间 $\\tau$ 以秒为单位。不需要进行角度单位转换。\n\n数值规范：\n- 对最大 $m$ 值，使用至少 $15$ 个不同的平均时间，且最大不超过 $ \\lfloor N/4 \\rfloor $。\n- 用于斜率估计的内部跨度必须排除至少最小和最大的 $20\\%$ 的 $\\tau$ 值。\n- 斜率估计必须对 $ (\\log_{10} \\tau, \\log_{10} \\sigma(\\tau)) $ 对使用普通最小二乘法。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[c_1,c_2,c_3,c_4]$）。",
            "solution": "此问题的解决方案涉及合成四个不同的时间序列，每个序列代表陀螺仪传感器中发现的一种主导噪声过程，然后根据其阿伦偏差图的斜率对这些过程进行分类。该方法分为三个主要阶段：信号合成、阿伦偏差计算和基于斜率的分类。\n\n### 1. 信号合成\n\n对于四个测试用例中的每一个，都会在采样频率 $f_s=100\\,\\mathrm{Hz}$（采样周期 $T_0 = 1/f_s = 0.01\\,\\mathrm{s}$）下生成一个长度为 $N=8192$ 的离散时间信号 $x_k$。每个用例都使用唯一的随机种子以确保可复现性。\n\n- **用例 1 (白噪声)：** 信号完全由零均值高斯白噪声过程组成，$x_k = w_k$，其中 $w_k \\sim \\mathcal{N}(0, \\sigma_w^2)$，标准差为 $\\sigma_w = 3.0 \\times 10^{-3}\\,\\mathrm{rad/s}$。\n\n- **用例 2 (偏置不稳定性)：** 信号是一个低电平白噪声分量（$w_k$，$\\sigma_w = 3.0 \\times 10^{-4}\\,\\mathrm{rad/s}$）和一个主导的粉红噪声（闪烁噪声）分量 $p_k$ 的和。粉红噪声在频域中合成。生成一个复高斯白噪声频谱，然后通过一个振幅滤波器进行整形，该滤波器在频率 $f > 0$ 时与 $1/\\sqrt{f}$ 成正比。直流分量（$f=0$）设置为零。快速傅里叶逆变换（iFFT）产生时域信号 $p_k$，然后将其缩放以使其均方根（RMS）值为 $5.0 \\times 10^{-3}\\,\\mathrm{rad/s}$ 并使其为零均值。最终信号为 $x_k = w_k + p_k$。\n\n- **用例 3 (速率随机游走)：** 信号是一个低电平白噪声分量（$w_k$，$\\sigma_w = 3.0 \\times 10^{-4}\\,\\mathrm{rad/s}$）和一个速率随机游走分量 $b_k$ 的和。速率随机游走是通过对一个离散时间白噪声过程进行累积求和生成的，$b_k = \\sum_{i=0}^{k} w'_i$，其中增量 $w'_i$ 从 $\\mathcal{N}(0, \\sigma_{\\mathrm{rw}}^2)$ 中抽取，$\\sigma_{\\mathrm{rw}} = 1.0 \\times 10^{-5}\\,\\mathrm{rad/s}$。最终信号为 $x_k = w_k + b_k$。\n\n- **用例 4 (量化噪声)：** 首先生成一个 $\\sigma_w = 3.0 \\times 10^{-4}\\,\\mathrm{rad/s}$ 的白噪声信号。然后使用最近步长舍入函数对该信号进行量化，量化步长为 $q = 5.0 \\times 10^{-3}\\,\\mathrm{rad/s}$。操作为 $x_k \\leftarrow q \\cdot \\mathrm{round}(x_k / q)$。\n\n### 2. 阿伦偏差计算\n\n阿伦偏差 $\\sigma(\\tau)$ 是为一组平均时间 $\\tau$ 计算的。通过选择一组对数间隔的簇大小 $m$ 来确定平均时间。生成一组大约 $30$ 个 $m$ 值，范围从 $m=1$ 到 $m_{max} = \\lfloor N/4 \\rfloor = 2048$，然后将它们四舍五入到最近的整数并使其唯一。这通常会产生超过 $15$ 个不同的 $m$ 值。相应的平均时间为 $\\tau = m T_0$。\n\n对于每个 $m$ 值，根据其定义计算阿伦方差 $\\sigma^2(\\tau)$：\n$$ \\sigma^2(\\tau) = \\frac{1}{2} \\left\\langle \\left( \\bar{x}_{k+1}^{(m)} - \\bar{x}_k^{(m)} \\right)^2 \\right\\rangle $$\n其中 $\\bar{x}_k^{(m)}$ 是从索引 $k$ 开始的 $m$ 个连续样本的平均值：\n$$ \\bar{x}_k^{(m)} = \\frac{1}{m} \\sum_{i=k}^{k+m-1} x_i $$\n运算符 $\\langle \\cdot \\rangle$ 表示对所有可能的重叠簇对进行平均，其中 $k \\in \\{0, 1, \\dots, N-m-1\\}$。相邻簇对的数量是 $N-m$。因此，方差计算如下：\n$$ \\sigma^2(\\tau) = \\frac{1}{2(N-m-1)} \\sum_{k=0}^{N-m-2} \\left( \\bar{x}_{k+1}^{(m)} - \\bar{x}_k^{(m)} \\right)^2 $$\n在计算上，簇平均值 $\\bar{x}_k^{(m)}$ 可以通过将信号 $x_k$ 与长度为 $m$ 的归一化窗口进行一维卷积来高效计算。阿伦偏差则为 $\\sigma(\\tau) = \\sqrt{\\sigma^2(\\tau)}$。\n\n### 3. 斜率估计与分类\n\n主导噪声类型是通过阿伦偏差曲线在对数-对数图上的斜率来识别的。通过对数据对 $(\\log_{10} \\tau, \\log_{10} \\sigma(\\tau))$ 执行普通最小二乘线性回归，可以估计出一个单一的代表性斜率 $s$。为了避免有限数据长度（在大的 $\\tau$ 处）和其他噪声类型（在小的 $\\tau$ 处）引起的边界效应，拟合在数据的内部跨度上进行。具体来说，从回归中排除了最小的 $25\\%$ 和最大的 $25\\%$ 的 $(\\tau, \\sigma(\\tau))$ 数据对。\n\n然后，使用估计出的斜率 $s$ 和以下固定的阈值对噪声过程进行分类，这些阈值设置在典型斜率之间的中点：\n- **代码 3 (量化噪声)：** $s  -0.75$，理论斜率为 $-1$。\n- **代码 0 (白噪声 / 角度随机游走)：** $-0.75 \\le s  -0.25$，理论斜率为 $-0.5$。\n- **代码 1 (偏置不稳定性 / 闪烁噪声)：** $-0.25 \\le s  +0.25$，理论斜率为 $0$。\n- **代码 2 (速率随机游走)：** $+0.25 \\le s \\le +0.75$，理论斜率为 $+0.5$。\n- **代码 4 (其他/不确定)：** 如果 $s$ 落在上述范围之外。\n\n此过程应用于四个合成信号中的每一个，为每个用例生成一个分类代码。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_white_noise(N, sigma_w, rng):\n    \"\"\"Generates a white noise sequence.\"\"\"\n    return rng.normal(scale=sigma_w, size=N)\n\ndef generate_pink_noise(N, fs, rms_value, rng):\n    \"\"\"Generates an approximate pink noise sequence using FFT.\"\"\"\n    n_freqs = N // 2 + 1\n    freqs = np.fft.rfftfreq(N, d=1.0 / fs)\n\n    # Generate complex Gaussian noise spectrum\n    spec = rng.standard_normal(n_freqs) + 1j * rng.standard_normal(n_freqs)\n    \n    # Shape the spectrum amplitude by 1/sqrt(f)\n    pink_filter = np.ones_like(freqs)\n    if len(freqs)  1:\n        pink_filter[1:] = 1.0 / np.sqrt(freqs[1:])\n    pink_filter[0] = 0  # No DC component\n\n    spec *= pink_filter\n    \n    # Ensure properties for real signal are met\n    if N % 2 == 0:\n        spec[-1] = np.real(spec[-1])\n\n    # Inverse FFT to get time domain signal\n    signal = np.fft.irfft(spec, n=N)\n\n    # Scale to desired RMS\n    current_rms = np.sqrt(np.mean(signal**2))\n    if current_rms  1e-9:\n        signal *= (rms_value / current_rms)\n\n    # Remove any residual mean\n    signal -= np.mean(signal)\n    \n    return signal\n\ndef generate_rate_random_walk(N, sigma_rw, rng):\n    \"\"\"Generates a rate random walk sequence.\"\"\"\n    increments = rng.normal(scale=sigma_rw, size=N)\n    return np.cumsum(increments)\n\ndef apply_quantization(signal, q):\n    \"\"\"Applies quantization to a signal.\"\"\"\n    return q * np.round(signal / q)\n\ndef compute_allan_deviation(x, fs, m_values):\n    \"\"\"Computes the overlapped Allan deviation.\"\"\"\n    N = len(x)\n    T0 = 1.0 / fs\n    tau_values = []\n    adev_values = []\n\n    for m in m_values:\n        if m = N:\n            continue\n        \n        # Efficiently compute cluster averages using convolution\n        cluster_avg = np.convolve(x, np.ones(m) / m, mode='valid')\n        \n        if len(cluster_avg)  2:\n            continue\n            \n        # Compute differences of adjacent cluster averages\n        diffs = cluster_avg[1:] - cluster_avg[:-1]\n        \n        # Compute Allan variance\n        avar = 0.5 * np.mean(diffs**2)\n        \n        # Compute Allan deviation\n        adev = np.sqrt(avar)\n        \n        tau_values.append(m * T0)\n        adev_values.append(adev)\n\n    return np.array(tau_values), np.array(adev_values)\n\ndef get_classification(slope):\n    \"\"\"Classifies the noise type based on the log-log slope.\"\"\"\n    if slope  -0.75:\n        return 3  # Quantization\n    elif slope  -0.25:\n        return 0  # White noise\n    elif slope  0.25:\n        return 1  # Bias instability\n    elif slope = 0.75:\n        return 2  # Rate random walk\n    else:\n        return 4  # Other/Indeterminate\n\ndef process_case(params):\n    \"\"\"Processes a single test case from synthesis to classification.\"\"\"\n    N = params['N']\n    fs = params['fs']\n    rng = np.random.default_rng(params['seed'])\n    \n    # Signal Synthesis\n    x = np.zeros(N, dtype=np.float64)\n    if params['type'] == 'white':\n        x = generate_white_noise(N, params['sigma_w'], rng)\n    elif params['type'] == 'pink':\n        x = generate_white_noise(N, params['sigma_w'], rng)\n        x += generate_pink_noise(N, fs, params['pink_rms'], rng)\n    elif params['type'] == 'rrw':\n        x = generate_white_noise(N, params['sigma_w'], rng)\n        x += generate_rate_random_walk(N, params['sigma_rw'], rng)\n    elif params['type'] == 'quant':\n        signal_unquantized = generate_white_noise(N, params['sigma_w'], rng)\n        x = apply_quantization(signal_unquantized, params['q'])\n\n    # Allan Deviation Calculation\n    m_max = N // 4\n    # Generate a log-spaced set of m values, ensuring at least 15 unique values.\n    m_values = np.unique(np.round(np.logspace(np.log10(1), np.log10(m_max), num=30))).astype(int)\n    \n    tau_values, adev_values = compute_allan_deviation(x, fs, m_values)\n    \n    # Filter out zero or negative adev values for log plot\n    valid_indices = adev_values  0\n    tau_values = tau_values[valid_indices]\n    adev_values = adev_values[valid_indices]\n\n    if len(tau_values)  5: # Not enough points for a reliable fit\n        return 4\n\n    # Slope Estimation\n    log_tau = np.log10(tau_values)\n    log_adev = np.log10(adev_values)\n    \n    # Fit over the middle span (excluding first and last 25%)\n    n_points = len(log_tau)\n    # The problem asks to exclude at least 20%, we'll use 25% for a more stable interior.\n    start_index = int(np.ceil(0.25 * n_points))\n    end_index = int(np.floor(0.75 * n_points))\n    \n    if end_index = start_index + 1: # Not enough points in the middle span\n        return 4\n\n    fit_log_tau = log_tau[start_index:end_index]\n    fit_log_adev = log_adev[start_index:end_index]\n    \n    slope, _ = np.polyfit(fit_log_tau, fit_log_adev, 1)\n\n    # Classification\n    return get_classification(slope)\n\ndef solve():\n    \"\"\"Main solver function to run all test cases.\"\"\"\n    test_cases = [\n        # Case 1: White noise dominated\n        {'type': 'white', 'N': 8192, 'fs': 100, 'sigma_w': 3.0e-3, 'seed': 0},\n        # Case 2: Bias instability dominated\n        {'type': 'pink', 'N': 8192, 'fs': 100, 'sigma_w': 3.0e-4, 'pink_rms': 5.0e-3, 'seed': 1},\n        # Case 3: Rate random walk dominated\n        {'type': 'rrw', 'N': 8192, 'fs': 100, 'sigma_w': 3.0e-4, 'sigma_rw': 1.0e-5, 'seed': 2},\n        # Case 4: Quantization dominated\n        {'type': 'quant', 'N': 8192, 'fs': 100, 'sigma_w': 3.0e-4, 'q': 5.0e-3, 'seed': 3}\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result_code = process_case(case_params)\n        results.append(result_code)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}