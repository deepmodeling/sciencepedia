{
    "hands_on_practices": [
        {
            "introduction": "人工智能在外科领域的应用不仅限于图像识别，更拓展到辅助决策和自主控制等动态任务。强化学习（Reinforcement Learning, RL）为智能体（agent）通过与环境互动学习最优策略提供了强大的理论框架，例如，控制手术机器人的摄像机以获得最佳视野。本练习将通过一个具体的计算任务，带您亲手体验Q学习（Q-learning）算法的核心更新步骤，深入理解智能体如何根据获得的奖励（reward）和对未来的预期来迭代优化其行为价值函数（action-value function），从而揭示AI决策过程的底层学习机制。",
            "id": "5110348",
            "problem": "在一个集成了增强现实（AR）叠加层、三维（3D）打印解剖导板和分子谱分析指导的患者分层的机器人全身手术工作流程中，一个自主相机控制器使用强化学习（RL）在器械操作期间稳定AR配准。该任务被建模为一个马尔可夫决策过程，其中动作价值函数量化了在给定状态下执行某一动作的预期折扣回报。从动作价值函数的贝尔曼最优性原理出发，并使用恒定步长的随机近似方法，推导出动作价值估计的单步更新规则，并将其应用于以下场景。在时间步 $t$，控制器处于状态 $s$ 并执行动作 $a$。观测到的立即奖励为 $r=1.0$。当前的估计值为 $Q_t(s,a)=2.0$。折扣因子为 $\\gamma=0.95$。恒定学习率为 $\\alpha=0.1$。在当前估计器下，后继状态 $s'$ 中的最大预测动作价值为 $\\max_{a'}Q_t(s',a')=3.0$。计算更新后的估计值 $Q_{t+1}(s,a)$，结果为一个实数。无需四舍五入。",
            "solution": "首先将对问题的科学合理性、自洽性和清晰度进行验证。\n\n### 第一步：提取已知条件\n问题提供了以下信息：\n- **模型**：用于自主相机控制器的马尔可夫决策过程。\n- **函数**：动作价值函数，记为 $Q(s,a)$。\n- **学习原理**：贝尔曼最优性原理。\n- **更新方法**：单步、恒定步长的随机近似（具体为 Q-learning）。\n- **时间步**：$t$。\n- **时间 $t$ 时的状态**：$s$。\n- **时间 $t$ 时的动作**：$a$。\n- **观测到的立即奖励**：$r = 1.0$。\n- **当前动作价值估计**：$Q_t(s,a) = 2.0$。\n- **折扣因子**：$\\gamma = 0.95$。\n- **恒定学习率（步长）**：$\\alpha = 0.1$。\n- **后继状态 $s'$ 中的最大预测动作价值**：$\\max_{a'}Q_t(s',a') = 3.0$。\n- **目标**：计算更新后的动作价值估计 $Q_{t+1}(s,a)$。\n\n### 第二步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n\n- **科学依据**：该问题基于标准且成熟的强化学习（RL）理论。马尔可夫决策过程（MDP）、贝尔曼最优性原理、动作价值函数（$Q$-函数）以及 Q-learning 更新规则的使用都是该领域的基本概念。其在机器人手术控制中的应用是一个现实且活跃的研究领域。该问题在科学和数学上是合理的。\n- **适定性**：单步时序差分更新所需的所有必要参数（$\\alpha$、$\\gamma$、$r$、$Q_t(s,a)$ 和 $\\max_{a'}Q_t(s',a')$）均已提供。问题要求一个具体、唯一可确定的数值。\n- **客观性**：问题以精确的技术语言陈述，没有主观或模棱两可的术语。所有数值都已明确给出。\n\n该问题没有表现出任何科学不合理、不完整、矛盾或模糊等缺陷。其框架虽然特定于外科技术背景，但提出了一个计算科学中标准的、可形式化的问题。\n\n### 第三步：结论与行动\n问题是**有效的**。将推导解答。\n\n### 推导与解答\n任务是使用时序差分学习的原理，特别是 Q-learning 算法，来计算更新后的动作价值估计 $Q_{t+1}(s,a)$。\n\n动作价值函数 $Q^*(s,a)$ 的贝尔曼最优方程指出，在状态 $s$ 下采取动作 $a$ 的最优价值等于立即奖励的期望值加上从下一个状态 $s'$ 开始的最大预期未来奖励的折扣值：\n$$Q^*(s,a) = \\mathbb{E}[R_{t+1} + \\gamma \\max_{a'} Q^*(S_{t+1}, a') | S_t=s, A_t=a]$$\n在强化学习中，真实的环境动态和奖励函数是未知的。因此，$Q^*(s,a)$ 是通过经验迭代近似的。在状态 $s$ 中执行动作 $a$ 后，我们观察到一个奖励 $r$ 和一个新状态 $s'$。这个单一的经验样本 $(s, a, r, s')$ 被用来更新我们当前的估计值 $Q_t(s,a)$。\n\nQ-learning 算法使用观察到的奖励 $r$ 和从下一状态可获得的最大价值的当前估计值 $\\max_{a'}Q_t(s',a')$ 来形成一个更新的目标值。这就是时序差分（TD）目标：\n$$ \\text{TD Target} = r + \\gamma \\max_{a'}Q_t(s',a') $$\n$Q_t(s,a)$ 的更新规则源于随机近似，它将当前估计值向 TD 目标移动一小步，步长由学习率 $\\alpha$ 决定。更新规则是：\n$$ Q_{t+1}(s,a) = Q_t(s,a) + \\alpha \\left[ \\left( r + \\gamma \\max_{a'}Q_t(s',a') \\right) - Q_t(s,a) \\right] $$\n方括号内的项 $\\left( r + \\gamma \\max_{a'}Q_t(s',a') \\right) - Q_t(s,a)$ 被称为 TD 误差。\n\n我们已知以下数值：\n- 当前估计值：$Q_t(s,a) = 2.0$\n- 奖励：$r = 1.0$\n- 折扣因子：$\\gamma = 0.95$\n- 学习率：$\\alpha = 0.1$\n- 后继状态中的最大价值：$\\max_{a'}Q_t(s',a') = 3.0$\n\n将这些值代入 Q-learning 更新方程：\n$$ Q_{t+1}(s,a) = 2.0 + 0.1 \\left[ \\left( 1.0 + 0.95 \\times 3.0 \\right) - 2.0 \\right] $$\n首先，我们计算括号内的项，这是最优未来价值的抽样估计（即 TD 目标）：\n$$ 1.0 + 0.95 \\times 3.0 = 1.0 + 2.85 = 3.85 $$\n接下来，我们通过从这个目标中减去旧的估计值来计算 TD 误差：\n$$ \\text{TD Error} = 3.85 - 2.0 = 1.85 $$\n最后，我们通过将学习率与 TD 误差的乘积加到旧的估计值上来更新估计：\n$$ Q_{t+1}(s,a) = 2.0 + 0.1 \\times 1.85 $$\n$$ Q_{t+1}(s,a) = 2.0 + 0.185 $$\n$$ Q_{t+1}(s,a) = 2.185 $$\n因此，对于状态-动作对 $(s,a)$，动作价值函数的更新后估计值为 $2.185$。",
            "answer": "$$\\boxed{2.185}$$"
        },
        {
            "introduction": "增强现实（Augmented Reality, AR）技术通过将虚拟信息精准叠加于现实世界，为外科医生提供了前所未有的术中导航能力。然而，AR系统的成败关键在于虚拟信息与真实解剖结构之间的时空一致性，任何可察觉的延迟都可能导致致命的配准误差。本练习聚焦于AR系统中一个核心的工程挑战：“运动到光子”（motion-to-photon）延迟，即从系统捕捉到运动到显示屏更新像素之间的总时间。您将通过分解延迟来源并结合临床精度要求进行计算，从而量化评估系统性能并判断是否需要引入高级补偿技术（如异步时间扭曲），深刻理解AR技术在临床应用中的性能瓶颈与优化策略。",
            "id": "5110434",
            "problem": "一个头戴式光学透视增强现实（AR）手术导航系统将解剖学引导信息叠加到外科医生的视野中。为确保虚拟叠加层与移动的器械尖端之间的精确配准，必须控制从运动到光子（motion-to-photon）的延迟。该流水线包括：带有曝光积分的相机传感、计算姿态估计和渲染、由显示器刷新引起的垂直同步门控，以及直到感兴趣区域被照亮的栅格扫描输出。\n\n假设存在以下硬件特性和操作条件：\n- 显示器刷新频率为 $f = 60\\,\\mathrm{Hz}$（采样保持），因此帧仅在刷新边界处呈现。\n- 相机曝光持续时间为 $T_{\\text{exp}} = 10\\,\\mathrm{ms}$，样本在曝光结束时可用于处理。\n- 姿态估计和渲染需要 $T_{\\text{proc}} = 20\\,\\mathrm{ms}$。\n- 从帧更新开始到感兴趣区域像素被照亮，扫描输出时间为 $T_{\\text{scan}} = 8\\,\\mathrm{ms}$。\n- 期望的垂直同步（vsync）等待时间在一个刷新周期内均匀分布，因此将其期望值取为刷新周期的一半。\n\n术中精度要求规定，相对于器械尖端，叠加层的配准误差 $d$ 不应超过 $0.5\\,\\mathrm{mm}$。在精细操作期间，尖端速度可达到 $v = 30\\,\\mathrm{mm/s}$。使用位移和延迟之间的运动学关系 $d = v \\, t$ 来确定用于叠加层对齐的最大允许延迟 $L_{\\max}$。\n\n从第一性原理和核心定义出发，推导：\n1. 此AR流水线的期望从运动到光子的延迟 $L$，其为曝光完成、处理、期望的vsync等待和扫描输出之和。\n2. 根据位移约束 $d = v \\, t$ 得出的最大允许延迟 $L_{\\max}$。\n\n将由重投影（异步时间扭曲）引起的所需延迟减少量定义为 $R = \\max\\!\\big(0,\\, L - L_{\\max}\\big)$。\n\n计算 $R$ 并以毫秒为单位表示您的最终数值答案。将您的答案四舍五入到四位有效数字。在最终的方框答案中不要包含单位。",
            "solution": "该问题要求计算增强现实（AR）手术导航系统所需的延迟减少量 $R$。这个量定义为 $R = \\max\\!\\big(0,\\, L - L_{\\max}\\big)$，其中 $L$ 是系统的期望从运动到光子的延迟，而 $L_{\\max}$ 是为满足指定精度要求所允许的最大延迟。解决方案将首先推导 $L$ 和 $L_{\\max}$ 的表达式，然后计算 $R$ 的最终值。\n\n首先，我们确定期望的从运动到光子的延迟 $L$。问题陈述该延迟是处理流水线中几个顺序延迟的总和。这些组成部分是：相机曝光、处理、垂直同步（vsync）等待和显示扫描输出。总延迟 $L$ 的模型由下式给出：\n$$L = T_{\\text{exp}} + T_{\\text{proc}} + T_{\\text{vsync\\_wait}} + T_{\\text{scan}}$$\n给定的固定延迟值如下：\n- 相机曝光持续时间，$T_{\\text{exp}} = 10\\,\\mathrm{ms}$。问题指定，在延迟的简单求和模型中，将此值直接用于“曝光完成”分量。\n- 姿态估计和渲染时间，$T_{\\text{proc}} = 20\\,\\mathrm{ms}$。\n- 栅格扫描输出时间，$T_{\\text{scan}} = 8\\,\\mathrm{ms}$。\n\nvsync等待时间 $T_{\\text{vsync\\_wait}}$ 是一个可变延迟，它取决于渲染帧相对于显示器刷新周期准备就绪的时间。显示器刷新频率给定为 $f = 60\\,\\mathrm{Hz}$。单个刷新周期 $T_{\\text{period}}$ 的持续时间是频率的倒数：\n$$T_{\\text{period}} = \\frac{1}{f} = \\frac{1}{60}\\,\\mathrm{s}$$\n为保持单位一致，我们将此周期转换为毫秒：\n$$T_{\\text{period}} = \\frac{1}{60}\\,\\mathrm{s} \\times \\frac{1000\\,\\mathrm{ms}}{1\\,\\mathrm{s}} = \\frac{100}{6}\\,\\mathrm{ms} = \\frac{50}{3}\\,\\mathrm{ms}$$\n问题陈述vsync等待时间在一个刷新周期内均匀分布。在区间 $[0, T_{\\text{period}}]$ 上的均匀随机变量的期望值是该区间长度的一半。因此，期望的vsync等待时间为：\n$$T_{\\text{vsync\\_wait}} = \\frac{1}{2} T_{\\text{period}} = \\frac{1}{2} \\times \\frac{50}{3}\\,\\mathrm{ms} = \\frac{25}{3}\\,\\mathrm{ms}$$\n现在，我们可以通过将各分量相加来计算总的期望延迟 $L$：\n$$L = 10\\,\\mathrm{ms} + 20\\,\\mathrm{ms} + \\frac{25}{3}\\,\\mathrm{ms} + 8\\,\\mathrm{ms}$$\n$$L = (10 + 20 + 8)\\,\\mathrm{ms} + \\frac{25}{3}\\,\\mathrm{ms} = 38\\,\\mathrm{ms} + \\frac{25}{3}\\,\\mathrm{ms}$$\n$$L = \\frac{3 \\times 38}{3}\\,\\mathrm{ms} + \\frac{25}{3}\\,\\mathrm{ms} = \\frac{114 + 25}{3}\\,\\mathrm{ms} = \\frac{139}{3}\\,\\mathrm{ms}$$\n\n接下来，我们确定最大允许延迟 $L_{\\max}$。这是根据术中精度要求推导出来的，该要求规定，当器械尖端以高达 $30\\,\\mathrm{mm/s}$ 的速度 $v$ 移动时，动态配准误差（位移）$d$ 不应超过 $0.5\\,\\mathrm{mm}$。位移、速度和时间（延迟）之间的运动学关系是 $d = v \\, t$。求解时间，即我们的最大允许延迟 $L_{\\max}$，我们得到：\n$$L_{\\max} = \\frac{d}{v}$$\n代入给定值：\n- $d = 0.5\\,\\mathrm{mm}$\n- $v = 30\\,\\mathrm{mm/s}$\n$$L_{\\max} = \\frac{0.5\\,\\mathrm{mm}}{30\\,\\mathrm{mm/s}} = \\frac{0.5}{30}\\,\\mathrm{s}$$\n将此持续时间转换为毫秒：\n$$L_{\\max} = \\frac{0.5}{30}\\,\\mathrm{s} \\times \\frac{1000\\,\\mathrm{ms}}{1\\,\\mathrm{s}} = \\frac{500}{30}\\,\\mathrm{ms} = \\frac{50}{3}\\,\\mathrm{ms}$$\n\n最后，我们使用给定的定义 $R = \\max\\!\\big(0,\\, L - L_{\\max}\\big)$ 来计算所需的延迟减少量 $R$。\n我们将计算出的系统延迟 $L$ 与最大允许延迟 $L_{\\max}$ 进行比较：\n$$L = \\frac{139}{3}\\,\\mathrm{ms} \\approx 46.33\\,\\mathrm{ms}$$\n$$L_{\\max} = \\frac{50}{3}\\,\\mathrm{ms} \\approx 16.67\\,\\mathrm{ms}$$\n由于 $L > L_{\\max}$，系统的固有延迟超过了可接受的阈值，因此有必要进行减少。所需的减少量是这两个值之间的差：\n$$R = L - L_{\\max} = \\frac{139}{3}\\,\\mathrm{ms} - \\frac{50}{3}\\,\\mathrm{ms} = \\frac{139 - 50}{3}\\,\\mathrm{ms} = \\frac{89}{3}\\,\\mathrm{ms}$$\n为了提供最终的数值答案，我们计算其十进制值并按要求四舍五入到四位有效数字：\n$$R = \\frac{89}{3}\\,\\mathrm{ms} \\approx 29.6666...\\,\\mathrm{ms}$$\n四舍五入到四位有效数字，得到：\n$$R \\approx 29.67\\,\\mathrm{ms}$$\n这就是为了满足手术精度要求而必须补偿的延迟量，例如可以通过使用预测性追踪或像异步时间扭曲这样的重投影技术来进行补偿。",
            "answer": "$$\\boxed{29.67}$$"
        },
        {
            "introduction": "无论是用于术前规划的患者特异性3D打印解剖模型，还是在AR导航中显示的虚拟器官，其应用基础都是高质量的三维数字模型。然而，直接从CT或MRI等医学影像重建的初始三维网格（mesh）往往含有孔洞、自相交等拓扑或几何缺陷，使其无法直接用于后续应用。本练习模拟了在临床应用前对三维模型进行预处理的关键步骤，要求您构建一个网格修复算法，在保留关键解剖标志点的前提下，实现孔洞填充、消除自相交并进行平滑处理。通过这项实践，您将掌握处理三维医疗数据的核心计算几何技术，理解确保数字模型“水密性”（watertight）和几何正确性对于精准外科技术的 fundamental importance。",
            "id": "5110349",
            "problem": "您将获得一个三角网格，该网格代表一个用于三维（3D）打印和增强现实（AR）辅助系统手术规划的解剖学表面。该网格可能包含拓扑缺陷（由边界边循环引起的孔洞）和几何缺陷（自相交）。某些顶点被指定为解剖学标志点，并且必须在空间中保持固定。您的任务是构建一个完整的、可运行的程序，通过闭合孔洞和移除自相交来修复网格，同时在标志点约束下最小化原始形状的几何畸变。该程序必须实现以下算法和数学要求，并为测试套件生成指定的输出。\n\n使用的基本基础和定义：\n- 将网格表示为顶点集 $\\{ \\mathbf{x}_i \\in \\mathbb{R}^3 \\}_{i=1}^n$ 和面集 $\\{ f_k = (i,j,\\ell) \\}_{k=1}^m$，其中每个面 $f_k$ 是顶点集中的一个索引三元组。\n- 将无向边集 $E$ 定义为出现在任何面中的所有无序对 $\\{i,j\\}$。如果一条边恰好出现在一个面中，则为边界边；否则为内部边。\n- 对于网格配置 $\\mathbf{X} = (\\mathbf{x}_1,\\dots,\\mathbf{x}_n)$，将离散狄利克雷（谐波）能量定义为 $$E_{\\mathrm{D}}(\\mathbf{X}) = \\sum_{\\{i,j\\} \\in E} w_{ij} \\left\\| \\mathbf{x}_i - \\mathbf{x}_j \\right\\|_2^2,$$ 其中 $w_{ij} > 0$ 是权重；使用均匀权重 $w_{ij} = 1$ 作为与均匀离散拉普拉斯平滑一致的、经过充分测试的基线。\n- 对于非标志点顶点 $i$，在固定标志点的约束下，其约束平滑更新是在 $E_{\\mathrm{D}}$ 上的梯度下降步骤：$$\\mathbf{x}_i^{(t+1)} = (1 - \\alpha) \\mathbf{x}_i^{(t)} + \\alpha \\cdot \\frac{1}{\\deg(i)} \\sum_{j \\in N(i)} \\mathbf{x}_j^{(t)},$$ 其中 $N(i)$ 是 $i$ 在 $E$ 中的邻居集合，$\\deg(i) = |N(i)|$，$\\alpha \\in (0,1)$ 是为保证稳定性而选择的步长（例如，$\\alpha  1/\\Delta_{\\max}$，其中 $\\Delta_{\\max}$ 是最大顶点度数）。标志点顶点不移动。\n- 孔洞是任何界定缺失面区域的简单边界边循环。闭合孔洞必须通过在循环质心处插入一个新顶点并形成一个扇形来添加面，从而对循环进行三角剖分；循环质心为 $$\\mathbf{c} = \\frac{1}{k} \\sum_{r=1}^k \\mathbf{x}_{v_r},$$ 其中 $(v_1,\\dots,v_k)$ 是按循环顺序排列的循环顶点。\n- 如果任何一对不相交的面 $(f_a, f_b)$ 中，一个三角形的边与另一个三角形在 $\\mathbb{R}^3$ 中的内部相交，则存在自相交。移除相交必须通过沿着连接三角形质心的直线，以一个小的排斥步长 $\\delta > 0$ 来移位非标志点顶点，从而迭代地分离相交的三角形对，重复此过程直到不再有相交或达到最大迭代次数；这是一种经过充分测试的几何分离启发式方法，与计算几何中的碰撞解决方法一致。\n- 将相对于原始网格的几何畸变定义为，在修复前限制于原始边集 $E_0$ 的边长最大绝对相对变化：$$D_{\\max} = \\max_{\\{i,j\\}\\in E_0} \\left| \\frac{\\left\\| \\mathbf{x}_i^{\\mathrm{final}} - \\mathbf{x}_j^{\\mathrm{final}} \\right\\|_2}{\\left\\| \\mathbf{x}_i^{\\mathrm{orig}} - \\mathbf{x}_j^{\\mathrm{orig}} \\right\\|_2} - 1 \\right|.$$\n\n需要实现的算法任务：\n1. 识别边界边并提取简单边界循环。通过插入一个质心顶点并形成一个扇形来对每个循环进行三角剖分以闭合孔洞。标志点顶点必须保持固定。\n2. 对所有三角形边对使用线段-三角形相交测试来检测三角形-三角形自相交。对于每对相交的三角形，计算其质心，并沿着质心到质心连线的单位向量，以 $\\pm \\delta$ 的距离移位这两个三角形的非标志点顶点。迭代此过程，直到不再有相交或达到指定的迭代上限。\n3. 对非标志点顶点执行约束拉普拉斯平滑，使用上述更新规则迭代指定的次数，步长 $\\alpha$ 的选择应在保持拓扑完整性的同时最小化畸变。\n4. 计算布尔值的`holes_closed`状态（如果启用孔洞闭合后没有边界边剩余，则为真）、布尔值的`no_intersections`状态（如果没有相交剩余，则为真），以及根据原始边集 $E_0$ 计算的最终最大畸变 `D_{\\max}`。\n\n您的程序必须使用给定的网格、参数和标志点集运行以下测试套件。在此问题中，所有坐标都是无单位的。为清晰起见，下面给出的每个数字都是明确的。您必须精确使用这些值。\n\n测试用例 1（一个带孔洞的闭合八面体，孔洞待闭合，所有顶点均为标志点）：\n- 顶点 $\\mathbf{X}$: $[ (1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1) ]$。\n- 面 $F$（从八面体中移除面 $(1,3,4)$ 以创建一个孔洞）：$[ (0,2,4), (2,1,4), (3,0,4), (2,0,5), (1,2,5), (3,1,5), (0,3,5) ]$。\n- 标志点索引 $L$: $[0,1,2,3,4,5]$。\n- 参数：启用孔洞闭合，$\\alpha = 0.2$，平滑迭代次数 $= 5$，排斥步长 $\\delta = 0.0$，排斥迭代上限 $= 10$。\n\n测试用例 2（两个相交的三角形，将一个三角形保留为标志点，不进行孔洞闭合）：\n- 顶点 $\\mathbf{X}$: $[ (0,0,0), (1,0,0), (0.5,1,0), (0.5,-0.2,-0.5), (0.5,0.5,0.5), (0.5,1.2,-0.5) ]$。\n- 面 $F$: $[ (0,1,2), (3,4,5) ]$。\n- 标志点索引 $L$: $[0,1,2]$。\n- 参数：禁用孔洞闭合，$\\alpha = 0.05$，平滑迭代次数 $= 5$，排斥步长 $\\delta = 0.05$，排斥迭代上限 $= 100$。\n\n测试用例 3（一个带孔洞的八面体，允许选定顶点移动，启用孔洞闭合）：\n- 顶点 $\\mathbf{X}$: $[ (1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1) ]$。\n- 面 $F$（移除面 $(1,3,4)$）：$[ (0,2,4), (2,1,4), (3,0,4), (2,0,5), (1,2,5), (3,1,5), (0,3,5) ]$。\n- 标志点索引 $L$: $[0,1,3,5]$（顶点 $2$ 和 $4$ 允许移动）。\n- 参数：启用孔洞闭合，$\\alpha = 0.1$，平滑迭代次数 $= 10$，排斥步长 $\\delta = 0.0$，排斥迭代上限 $= 10$。\n\n最终输出规范：\n- 对于每个测试用例，计算一个列表 `[`holes_closed`, `no_intersections`, `D_{\\max}`]`，其中 `holes_closed` 和 `no_intersections` 是布尔值，`D_{\\max}` 是一个浮点数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为由逗号分隔的各用例列表，并用方括号括起来，不含空格。例如：`[[True,True,0.001234],[False,True,0.0567],[True,True,0.0]]`。请使用规范的 Python 布尔值大写形式，即输出 `True` 或 `False`。\n\n您的解决方案必须从给定的基本基础开始，以科学上现实的方式实现所描述的算法，并在解决方案部分证明任何参数选择的合理性。最终答案必须是执行环境约束中指定的完整 Python 程序。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于计算几何和离散微分几何的原理，问题定义良好，具有清晰的算法描述和明确的输入，并且其表述是客观的。所有必要的组成部分——数据结构、数学定义、算法步骤和测试参数——均已提供，从而可以得到一个唯一且可验证的解决方案。\n\n我们将通过以顺序化、模块化的方式实现指定的算法来构建解决方案，并遵循所提供的数学定义。该过程涉及三个主要阶段：(1) 通过识别和闭合边界循环（孔洞）进行拓扑修复，(2) 通过检测和解决自相交进行几何清理，以及 (3) 通过约束拉普拉斯平滑进行几何优化。最后，我们将计算所需的质量度量。\n\n**1. 网格数据结构和初始处理**\n\n网格由一组顶点 $\\mathbf{X} = \\{\\mathbf{x}_i \\in \\mathbb{R}^3\\}_{i=1}^n$ 和一组面 $F = \\{ f_k = (i,j,\\ell) \\}_{k=1}^m$ 定义。我们用一个形状为 $(n, 3)$ 的 NumPy 数组来表示顶点，以实现高效的向量运算。面存储为元组列表。\n\n第一步是通过构建边集 $E$ 来建立网格的连通性。一条边由一对顶点索引 $\\{i,j\\}$ 定义。为了正确识别边界边，我们计算每条唯一边在所有面中出现的次数。一条边表示为一个已排序的索引元组 $(\\min(i,j), \\max(i,j))$，以确保无论方向如何都具有唯一性。出现在一个面中的边是边界边；出现在两个面中的边是内部边。\n\n设 $E_0$ 为输入网格的初始边集。存储该集合用于计算最终的畸变度量 $D_{\\max}$。\n\n**2. 孔洞识别与三角剖分**\n\n如果启用孔洞闭合，我们将识别边界循环。首先，我们构建一个数据结构，将边界上的每个顶点映射到其相邻的边界顶点。对于测试用例中的简单、单个边界循环，这将形成一个简单的循环图。我们遍历此图以提取构成孔洞边界的有序顶点序列 $(v_1, v_2, \\dots, v_k)$。\n\n为闭合孔洞，在循环顶点的质心处创建一个新顶点 $\\mathbf{x}_{\\text{new}}$：\n$$\n\\mathbf{x}_{\\text{new}} = \\mathbf{c} = \\frac{1}{k} \\sum_{r=1}^k \\mathbf{x}_{v_r}\n$$\n顶点列表 $\\mathbf{X}$ 中追加 $\\mathbf{x}_{\\text{new}}$。然后通过形成新面的“扇形”对孔洞进行三角剖分。对于每个边界边 $\\{v_r, v_{r+1}\\}$（其中 $v_{k+1}=v_1$），将一个新的三角形面 $(v_r, v_{r+1}, i_{\\text{new}})$ 添加到面列表 $F$ 中，其中 $i_{\\text{new}}$ 是新质心顶点的索引。此过程保证了边界循环的消除，从而形成一个拓扑闭合（水密）的表面区域。\n\n**3. 自相交检测与解决**\n\n自相交是一种几何缺陷，指网格的不相交部分占据了相同的空间。问题指定检测一个三角形的边与另一个三角形内部之间的相交。我们遍历所有不相交的面 $(f_a, f_b)$ 对，即不共享任何顶点的面。对于每个这样的对，我们测试 $f_a$ 的每条边与面 $f_b$ 的相交情况，反之亦然。\n\n使用标准的重心坐标法执行线段-三角形相交测试。设一条边由其端点 $\\mathbf{P}_0$ 和 $\\mathbf{P}_1$ 定义，一个三角形由其顶点 $\\mathbf{T}_0, \\mathbf{T}_1, \\mathbf{T}_2$ 定义。包含该线段的直线可以参数化地写为 $\\mathbf{L}(t) = \\mathbf{P}_0 + t(\\mathbf{P}_1 - \\mathbf{P}_0)$。三角形内部的一个点 $\\mathbf{Q}$ 可以用重心坐标写为 $\\mathbf{Q}(u,v) = (1-u-v)\\mathbf{T}_0 + u\\mathbf{T}_1 + v\\mathbf{T}_2$。如果我们能找到 $t, u, v$ 使得 $\\mathbf{L}(t) = \\mathbf{Q}(u,v)$ 并且参数满足位于线段和三角形内部的约束条件：$t \\in (0, 1)$、$u > 0$、$v > 0$ 和 $u+v  1$，则存在相交。这可以表示为一个 $3 \\times 3$ 的线性系统：\n$$\n\\begin{bmatrix}\n|  |  | \\\\\n(\\mathbf{P}_0 - \\mathbf{P}_1)  (\\mathbf{T}_1 - \\mathbf{T}_0)  (\\mathbf{T}_2 - \\mathbf{T}_0) \\\\\n|  |  |\n\\end{bmatrix}\n\\begin{pmatrix} t \\\\ u \\\\ v \\end{pmatrix}\n=\n\\begin{pmatrix} | \\\\ \\mathbf{P}_0 - \\mathbf{T}_0 \\\\ | \\end{pmatrix}\n$$\n如果在面 $f_a$ 和 $f_b$ 之间检测到相交，其顶点分别为 $\\{\\mathbf{v}_{a1}, \\mathbf{v}_{a2}, \\mathbf{v}_{a3}\\}$ 和 $\\{\\mathbf{v}_{b1}, \\mathbf{v}_{b2}, \\mathbf{v}_{b3}\\}$，则计算它们各自的质心：\n$$\n\\mathbf{c}_a = \\frac{1}{3}\\sum_{k=1}^3 \\mathbf{v}_{ak}, \\quad \\mathbf{c}_b = \\frac{1}{3}\\sum_{k=1}^3 \\mathbf{v}_{bk}\n$$\n定义一个排斥向量为 $\\mathbf{u}_{ab} = (\\mathbf{c}_b - \\mathbf{c}_a) / \\|\\mathbf{c}_b - \\mathbf{c}_a\\|_2$。面 $f_a$ 的非标志点顶点被移位 $-\\delta \\mathbf{u}_{ab}$，面 $f_b$ 的非标志点顶点被移位 $+\\delta \\mathbf{u}_{ab}$，其中 $\\delta$ 是排斥步长。此过程重复指定的迭代次数，或直到未检测到相交为止。\n\n**4. 约束拉普拉斯平滑**\n\n拉普拉斯平滑是一个迭代过程，它将每个顶点重新定位到其邻居的平均位置，从而有效地平滑网格。这等同于最小化离散狄利克雷能量 $E_{\\mathrm{D}}(\\mathbf{X})$。所提供的更新规则是此能量最小化的一个显式积分步骤：\n$$\n\\mathbf{x}_i^{(t+1)} = (1 - \\alpha) \\mathbf{x}_i^{(t)} + \\alpha \\cdot \\frac{1}{\\deg(i)} \\sum_{j \\in N(i)} \\mathbf{x}_j^{(t)}\n$$\n此处，$N(i)$ 是顶点 $i$ 的 1-环邻居集合，$\\deg(i)$ 是其度数（邻居数量），$\\alpha \\in (0,1)$ 是控制收敛速率的步长。此更新仅应用于非标志点顶点。标志点顶点 $\\{\\mathbf{x}_j | j \\in L\\}$ 在整个过程中保持固定。为确保正确性，在迭代 $t+1$ 时对所有顶点的更新都必须基于迭代 $t$ 时的顶点位置来计算。这需要使用顶点数组的临时副本来存储新位置，然后再更新主数组。\n\n**5. 最终度量计算**\n\n在所有修复和平滑操作完成后，我们评估最终网格的质量。\n-   **孔洞闭合状态：** 我们重新计算最终网格上的边界边集。如果该集合为空，则 `holes_closed` 状态为 `True`，否则为 `False`。\n-   **自相交状态：** 我们在最终网格上运行完整的自相交检测算法。如果未发现相交，则 `no_intersections` 状态为 `True`，否则为 `False`。\n-   **几何畸变 ($D_{\\max}$):** 此度量量化了网格相对于其原始形状的变形程度。它通过仅考虑原始网格中存在的边 $\\{i,j\\}$（即 $E_0$）来计算。对于每个这样的边，我们计算其在原始网格中的长度 $\\|\\mathbf{x}_i^{\\mathrm{orig}} - \\mathbf{x}_j^{\\mathrm{orig}}\\|_2$，以及在最终修复网格中的长度 $\\|\\mathbf{x}_i^{\\mathrm{final}} - \\mathbf{x}_j^{\\mathrm{final}}\\|_2$。所有原始边上的最大绝对相对变化即为畸变：\n    $$\n    D_{\\max} = \\max_{\\{i,j\\}\\in E_0} \\left| \\frac{\\left\\| \\mathbf{x}_i^{\\mathrm{final}} - \\mathbf{x}_j^{\\mathrm{final}} \\right\\|_2}{\\left\\| \\mathbf{x}_i^{\\mathrm{orig}} - \\mathbf{x}_j^{\\mathrm{orig}} \\right\\|_2} - 1 \\right|\n    $$\n    $D_{\\max}=0$ 的值表示原始边的长度没有变化。\n\n这些算法的组合为修复三角网格中的常见缺陷提供了一个鲁棒的流程，这是 3D 打印和增强现实在手术规划中应用的一个关键预处理步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import Counter\n\ndef get_edges_and_boundaries(faces):\n    \"\"\"\n    Identifies all unique edges and boundary edges from a list of faces.\n    An edge is a sorted tuple of vertex indices.\n    \"\"\"\n    edges = []\n    for face in faces:\n        edges.append(tuple(sorted((face[0], face[1]))))\n        edges.append(tuple(sorted((face[1], face[2]))))\n        edges.append(tuple(sorted((face[2], face[0]))))\n    \n    edge_counts = Counter(edges)\n    boundary_edges = [edge for edge, count in edge_counts.items() if count == 1]\n    \n    return set(edges), boundary_edges\n\ndef find_boundary_loops(boundary_edges):\n    \"\"\"\n    Traces boundary edges to form ordered loops of vertices.\n    Assumes simple, non-branching loops for this problem's scope.\n    \"\"\"\n    if not boundary_edges:\n        return []\n\n    adj = {}\n    for u, v in boundary_edges:\n        if u not in adj: adj[u] = []\n        if v not in adj: adj[v] = []\n        adj[u].append(v)\n        adj[v].append(u)\n\n    loops = []\n    visited_edges = set()\n\n    for start_edge in boundary_edges:\n        if start_edge in visited_edges:\n            continue\n        \n        loop = []\n        \n        start_node, second_node = start_edge\n        loop.append(start_node)\n        loop.append(second_node)\n        visited_edges.add(start_edge)\n        \n        prev_node, curr_node = start_node, second_node\n        \n        while curr_node != start_node:\n            found_next = False\n            for next_node in adj[curr_node]:\n                edge = tuple(sorted((curr_node, next_node)))\n                if next_node != prev_node and edge in boundary_edges:\n                    if edge in visited_edges and next_node != start_node:\n                        # Should not happen in simple loops\n                        continue\n\n                    prev_node, curr_node = curr_node, next_node\n                    if curr_node != start_node:\n                        loop.append(curr_node)\n                    visited_edges.add(edge)\n                    found_next = True\n                    break\n            if not found_next:\n                 # Incomplete loop or complex topology, break for robustness\n                break\n        loops.append(loop)\n    return loops\n\ndef segment_triangle_intersect(p0, p1, t0, t1, t2):\n    \"\"\"\n    Möller-Trumbore inspired segment-triangle intersection test.\n    Checks if segment (p0, p1) intersects triangle (t0, t1, t2).\n    Returns True if intersection is in the segment interior and triangle interior.\n    \"\"\"\n    epsilon = 1e-6\n    edge1 = t1 - t0\n    edge2 = t2 - t0\n    direction = p1 - p0\n    \n    h = np.cross(direction, edge2)\n    a = np.dot(edge1, h)\n\n    if -epsilon  a  epsilon:\n        return False  # Parallel\n\n    f = 1.0 / a\n    s = p0 - t0\n    u = f * np.dot(s, h)\n\n    if u  epsilon or u > 1.0 - epsilon:\n        return False\n\n    q = np.cross(s, edge1)\n    v = f * np.dot(direction, q)\n\n    if v  epsilon or u + v > 1.0 - epsilon:\n        return False\n\n    t = f * np.dot(edge2, q)\n\n    if t > epsilon and t  1.0 - epsilon: # t is relative to segment length implicit in direction\n        return True\n    \n    return False\n\ndef detect_intersections(vertices, faces):\n    \"\"\"\n    Detects self-intersections by checking all disjoint face pairs.\n    Returns a list of intersecting face index pairs.\n    \"\"\"\n    intersections = []\n    num_faces = len(faces)\n    face_sets = [set(f) for f in faces]\n\n    for i in range(num_faces):\n        for j in range(i + 1, num_faces):\n            # Check for disjoint faces\n            if not face_sets[i].isdisjoint(face_sets[j]):\n                continue\n\n            f_i = faces[i]\n            f_j = faces[j]\n            v_i = vertices[list(f_i)]\n            v_j = vertices[list(f_j)]\n\n            # Test edges of face i against face j\n            for k in range(3):\n                p0 = v_i[k]\n                p1 = v_i[(k + 1) % 3]\n                if segment_triangle_intersect(p0, p1, v_j[0], v_j[1], v_j[2]):\n                    intersections.append((i, j))\n                    break\n            if (i, j) in intersections: continue\n\n            # Test edges of face j against face i\n            for k in range(3):\n                p0 = v_j[k]\n                p1 = v_j[(k + 1) % 3]\n                if segment_triangle_intersect(p0, p1, v_i[0], v_i[1], v_i[2]):\n                    intersections.append((i, j))\n                    break\n    return intersections\n\ndef solve_case(vertices_orig, faces_orig, landmarks_idx, params):\n    # Convert to NumPy array and list for mutability\n    vertices = np.array(vertices_orig, dtype=float)\n    faces = [list(f) for f in faces_orig]\n    landmarks = set(landmarks_idx)\n\n    # --- Initial state ---\n    E0, _ = get_edges_and_boundaries(faces)\n    original_edge_lengths = {\n        edge: np.linalg.norm(vertices[edge[0]] - vertices[edge[1]]) for edge in E0\n    }\n\n    # --- 1. Hole Closing ---\n    if params['hole_closing_enabled']:\n        _, boundary_edges = get_edges_and_boundaries(faces)\n        loops = find_boundary_loops(boundary_edges)\n        for loop in loops:\n            centroid = np.mean(vertices[loop], axis=0)\n            new_v_idx = len(vertices)\n            vertices = np.vstack([vertices, centroid])\n            for i in range(len(loop)):\n                v1 = loop[i]\n                v2 = loop[(i + 1) % len(loop)]\n                faces.append([v1, v2, new_v_idx])\n\n    # --- 2. Intersection Removal ---\n    if params['delta'] > 0:\n        for _ in range(params['repulsion_iters']):\n            intersecting_pairs = detect_intersections(vertices, faces)\n            if not intersecting_pairs:\n                break\n            \n            # Using set to avoid duplicate updates for a vertex\n            displacements = {}\n\n            for i, j in intersecting_pairs:\n                face_i_indices = faces[i]\n                face_j_indices = faces[j]\n                \n                c_i = np.mean(vertices[face_i_indices], axis=0)\n                c_j = np.mean(vertices[face_j_indices], axis=0)\n                \n                direction_vec = c_j - c_i\n                norm = np.linalg.norm(direction_vec)\n                if norm  1e-9: continue\n                unit_vec = direction_vec / norm\n\n                for v_idx in face_i_indices:\n                    if v_idx not in landmarks:\n                        if v_idx not in displacements: displacements[v_idx] = np.zeros(3)\n                        displacements[v_idx] -= params['delta'] * unit_vec\n                \n                for v_idx in face_j_indices:\n                    if v_idx not in landmarks:\n                        if v_idx not in displacements: displacements[v_idx] = np.zeros(3)\n                        displacements[v_idx] += params['delta'] * unit_vec\n            \n            for v_idx, disp in displacements.items():\n                vertices[v_idx] += disp\n    \n    # --- 3. Laplacian Smoothing ---\n    if params['smoothing_iters'] > 0 and params['alpha'] > 0:\n        # Build adjacency list\n        adj = {i: [] for i in range(len(vertices))}\n        for face in faces:\n            adj[face[0]].extend([face[1], face[2]])\n            adj[face[1]].extend([face[0], face[2]])\n            adj[face[2]].extend([face[0], face[1]])\n\n        # Create unique neighbor lists\n        neighbors = {i: list(set(n)) for i, n in adj.items()}\n        \n        for _ in range(params['smoothing_iters']):\n            new_vertices = vertices.copy()\n            for i in range(len(vertices)):\n                if i in landmarks:\n                    continue\n                \n                neighbor_indices = neighbors.get(i, [])\n                if not neighbor_indices:\n                    continue\n                \n                neighbor_coords = vertices[neighbor_indices]\n                avg_pos = np.mean(neighbor_coords, axis=0)\n                \n                new_vertices[i] = (1 - params['alpha']) * vertices[i] + params['alpha'] * avg_pos\n            vertices = new_vertices\n\n    # --- 4. Final Metrics ---\n    # Hole closure status\n    _, final_boundaries = get_edges_and_boundaries(faces)\n    holes_closed = (not final_boundaries)\n\n    # Intersection status\n    final_intersections = detect_intersections(vertices, faces)\n    no_intersections = (not final_intersections)\n\n    # Distortion\n    max_distortion = 0.0\n    for edge, orig_len in original_edge_lengths.items():\n        if orig_len  1e-9: continue\n        # edge vertices must exist in final mesh\n        if edge[0]  len(vertices) and edge[1]  len(vertices):\n            final_len = np.linalg.norm(vertices[edge[0]] - vertices[edge[1]])\n            distortion = abs(final_len / orig_len - 1.0)\n            if distortion > max_distortion:\n                max_distortion = distortion\n\n    return [holes_closed, no_intersections, max_distortion]\n\ndef solve():\n    test_cases = [\n        {\n            \"vertices\": [(1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)],\n            \"faces\": [(0,2,4), (2,1,4), (3,0,4), (2,0,5), (1,2,5), (3,1,5), (0,3,5)],\n            \"landmarks\": [0,1,2,3,4,5],\n            \"params\": {\n                \"hole_closing_enabled\": True, \"alpha\": 0.2, \"smoothing_iters\": 5,\n                \"delta\": 0.0, \"repulsion_iters\": 10\n            }\n        },\n        {\n            \"vertices\": [(0,0,0), (1,0,0), (0.5,1,0), (0.5,-0.2,-0.5), (0.5,0.5,0.5), (0.5,1.2,-0.5)],\n            \"faces\": [(0,1,2), (3,4,5)],\n            \"landmarks\": [0,1,2],\n            \"params\": {\n                \"hole_closing_enabled\": False, \"alpha\": 0.05, \"smoothing_iters\": 5,\n                \"delta\": 0.05, \"repulsion_iters\": 100\n            }\n        },\n        {\n            \"vertices\": [(1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)],\n            \"faces\": [(0,2,4), (2,1,4), (3,0,4), (2,0,5), (1,2,5), (3,1,5), (0,3,5)],\n            \"landmarks\": [0,1,3,5],\n            \"params\": {\n                \"hole_closing_enabled\": True, \"alpha\": 0.1, \"smoothing_iters\": 10,\n                \"delta\": 0.0, \"repulsion_iters\": 10\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"vertices\"], case[\"faces\"], case[\"landmarks\"], case[\"params\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_str = \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}