{
    "hands_on_practices": [
        {
            "introduction": "在灾难医学中，最基本的挑战是确保服务能力与激增的伤员需求相匹配。本练习将此核心原则应用于一个具体的场景：为化学品泄漏事件设立洗消通道 。通过从第一性原理出发，您将运用流量守恒的概念来计算确保系统稳定的最小资源量，这是所有后续资源规划与运营管理的基础。",
            "id": "5110870",
            "problem": "某大都市卫生系统在一起蒸发性有毒工业化学品泄漏事件影响到一处大型户外场所后，启动了事件指挥系统（ICS）。可走动的伤员在进行外科分诊和确定性治疗之前，需要在并行通道中进行快速的初步净化。为便于规划，假设存在一个至少$1$小时的稳态操作窗口，在此期间，到达净化走廊的可走动伤员速率近似恒定，为每小时$240$名伤员。每条净化通道均配备了接受过个人防护装备（PPE）规程培训的人员，并提供确定性的、标准化的净化周期，每位伤员耗时$2$分钟，包括进入、湿式净化、冲洗以及离开进入暖区进行分诊。假设同一通道内连续伤员之间的准备和转换开销可忽略不计，通道无停工时间，且伤员中途退出或放弃等待的情况也可忽略不计。\n\n从适用于大规模伤亡事件的基本原理出发——特别是稳态系统中的流量守恒原理，以及服务率定义为处理时间倒数的概念——推导在所述条件下，为使系统保持稳定且不产生积压，所需并行净化通道的最小整数数量。最终答案必须是一个整数（无单位）。无需四舍五入。",
            "solution": "该问题要求确定为确保系统稳定性所需的并行净化通道的最小数量。系统稳定性定义为系统不积压伤员的状况。这是一个稳态系统中的流量守恒问题，可以使用排队论的基本原理进行分析。\n\n此类系统稳定性的核心原则是总服务率必须大于或等于到达率。如果总服务率小于到达率，等待的伤员数量将无限增长，导致系统不稳定并产生积压。设 $\\lambda$ 为伤员到达率，$\\mu_{total}$ 为净化系统的总服务率。稳定性条件为：\n$$\n\\mu_{total} \\ge \\lambda\n$$\n\n首先，我们将给定参数形式化。伤员到达率被表述为近似恒定。\n$$\n\\lambda = 240 \\text{ victims/hour}\n$$\n\n服务过程由每条通道的确定性、标准化的净化周期时间 $T_s$ 描述。\n$$\nT_s = 2 \\text{ minutes/victim}\n$$\n\n单条通道的服务率 $\\mu_{lane}$ 是服务时间 $T_s$ 的倒数。服务率表示单条通道单位时间内可以处理的伤员数量。\n$$\n\\mu_{lane} = \\frac{1}{T_s}\n$$\n\n为了与以“伤员/小时”为单位的到达率 $\\lambda$ 保持量纲一致性，我们必须将服务时间 $T_s$ 从分钟转换为小时。$1$小时等于$60$分钟。\n$$\nT_s = 2 \\text{ minutes/victim} \\times \\frac{1 \\text{ hour}}{60 \\text{ minutes}} = \\frac{2}{60} \\text{ hours/victim} = \\frac{1}{30} \\text{ hours/victim}\n$$\n\n现在，我们可以计算出单条通道以“伤员/小时”为单位的服务率。\n$$\n\\mu_{lane} = \\frac{1}{T_s} = \\frac{1}{\\frac{1}{30} \\text{ hours/victim}} = 30 \\text{ victims/hour}\n$$\n因此，每条净化通道的处理能力为每小时$30$名伤员。\n\n该系统由 $N$ 条相同的并行净化通道组成。假设各通道独立运行，系统的总服务率 $\\mu_{total}$ 是各条独立通道服务率的总和。\n$$\n\\mu_{total} = N \\times \\mu_{lane}\n$$\n\n现在我们将总服务率的表达式代入稳定性条件中。\n$$\nN \\times \\mu_{lane} \\ge \\lambda\n$$\n\n为了求出所需的最小通道数 $N$，我们可以重排不等式来解出 $N$。\n$$\nN \\ge \\frac{\\lambda}{\\mu_{lane}}\n$$\n\n代入 $\\lambda$ 和 $\\mu_{lane}$ 的数值：\n$$\nN \\ge \\frac{240 \\text{ victims/hour}}{30 \\text{ victims/hour}}\n$$\n$$\nN \\ge 8\n$$\n\n结果表明，$N$ 必须是大于或等于$8$的数。由于通道数必须是整数，满足此条件的最小整数 $N$ 值为$8$。当有$8$条通道时，总服务能力为每小时 $8 \\times 30 = 240$ 名伤员，恰好与到达率相等。在这个确定性的稳态模型中，此处理能力足以防止积压的产生。如果通道数少于$8$条，到达率将超过服务能力，队列会持续增长。因此，所需最小整数通道数为$8$。",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "有效的灾难响应不仅依赖于前瞻性规划，也依赖于严格的绩效评估以持续改进。本练习聚焦于检伤分类这一关键环节的量化分析 。您将学习如何应用伤情严重程度评分（Injury Severity Score, $ISS$）作为客观基准，来计算过度分类（overtriage）与分类不足（undertriage）这两个核心绩效指标，从而深刻理解在资源压力下进行临床决策的权衡与后果。",
            "id": "5110820",
            "problem": "一场里氏 $7.2$ 级地震导致了一次大规模伤亡事件，有 $250$ 名成年患者在抵达前方外科设施时，按三个类别进行分诊：紧急（红色）、延迟（黄色）和轻微（绿色）。所有患者在 $12$ 小时内都获得了损伤严重程度评分（ISS）。为了评估与手术资源分配相关的分诊性能，我们考虑以下基于创伤系统科学的操作性定义：$ISS \\geq 15$ 的患者被视为“重伤”，在没有压倒性姑息标准的情况下，通常需要优先接受紧急救生干预；紧急分诊表示分配到高危护理并优先获得紧急手术能力；延迟和轻微分诊表示分配到低危处理途径。\n\n计数数据集总结如下：\n- 紧急：$90$ 名患者，其中 $52$ 名 $ISS \\geq 15$，$38$ 名 $ISS  15$。\n- 延迟：$110$ 名患者，其中 $22$ 名 $ISS \\geq 15$，$88$ 名 $ISS  15$。\n- 轻微：$50$ 名患者，其中 $3$ 名 $ISS \\geq 15$，$47$ 名 $ISS  15$。\n\n在大规模伤亡管理中，使用两个性能率来评估分诊决策：\n- 过度分诊率：被分配到紧急分诊但根据ISS标准并非重伤的患者比例。\n- 分诊不足率：被分配到延迟或轻微分诊但根据ISS标准为重伤的患者比例。\n\n假设过度分诊的系统目标为 $0.35$，分诊不足的系统目标为 $0.05$，并定义一个加权偏差分数\n$$\nS \\equiv w_{o}\\left(\\text{Overtriage} - 0.35\\right)^{2} + w_{u}\\left(\\text{Undertriage} - 0.05\\right)^{2},\n$$\n其中 $w_{o} = 1$ 且 $w_{u} = 4$，以反映分诊不足具有更高的临床风险。\n\n仅使用上述数据集和操作性定义，计算过度分诊率和分诊不足率（以小数形式表示），然后计算 $S$。将您的 $S$ 最终值四舍五入到四位有效数字。将所有比率和 $S$ 的最终值表示为小数（而非分数或百分比）。最终提交的答案必须是 $S$ 的单个舍入值。",
            "solution": "首先验证问题陈述的科学基础、一致性和完整性。该问题设置在外科的一个子学科——大规模伤亡管理的背景下。它使用了标准、定义明确的指标，如损伤严重程度评分（ISS）、分诊类别（紧急、延迟、轻微）以及性能指标（过度分诊、分诊不足）。提供的数值数据内部一致 ($52+38=90$；$22+88=110$；$3+47=50$；$90+110+50=250$)。过度分诊和分诊不足的定义清晰明确。加权偏差分数 $S$ 的公式已明确给出。所有必要信息均已提供，问题提法是适定的。因此，该问题被认为是有效的，可以构建解决方案。\n\n目标是计算过度分诊率、分诊不足率以及加权偏差分数 $S$。\n\n首先，我们从问题描述中确定相关的患者计数。\n设 $N_I$ 为被分诊为紧急类的患者总数。$N_I = 90$。\n设 $N_D$ 为被分诊为延迟类的患者总数。$N_D = 110$。\n设 $N_M$ 为被分诊为轻微类的患者总数。$N_M = 50$。\n设 $N_{I,NS}$ 为紧急类别中非重伤（$ISS  15$）患者的数量。$N_{I,NS} = 38$。\n设 $N_{D,S}$ 为延迟类别中重伤（$ISS \\geq 15$）患者的数量。$N_{D,S} = 22$。\n设 $N_{M,S}$ 为轻微类别中重伤（$ISS \\geq 15$）患者的数量。$N_{M,S} = 3$。\n\n接下来，我们计算过度分诊率，记为 $R_o$。提供的定义是“被分配到紧急分诊但根据ISS标准并非重伤的患者比例”。这是紧急组中非重伤患者与紧急组总患者人数的比率。\n$$\nR_o = \\frac{N_{I,NS}}{N_I} = \\frac{38}{90}\n$$\n将此分数转换为小数得出：\n$$\nR_o \\approx 0.42222...\n$$\n接下来，我们计算分诊不足率，记为 $R_u$。提供的定义是“被分配到延迟或轻微分诊但根据ISS标准为重伤的患者比例”。这是延迟和轻微组合组中的重伤患者与这两个组的总患者人数的比率。\n延迟和轻微类别中的重伤患者数量为 $N_{D,S} + N_{M,S}$。\n延迟和轻微类别中的总患者数量为 $N_D + N_M$。\n$$\nR_u = \\frac{N_{D,S} + N_{M,S}}{N_D + N_M} = \\frac{22 + 3}{110 + 50} = \\frac{25}{160}\n$$\n将此分数转换为小数得出：\n$$\nR_u = 0.15625\n$$\n现在我们使用给定的公式计算加权偏差分数 $S$：\n$$\nS \\equiv w_{o}\\left(R_o - T_o\\right)^{2} + w_{u}\\left(R_u - T_u\\right)^{2}\n$$\n问题指定了目标率 $T_o = 0.35$ 和 $T_u = 0.05$，以及权重 $w_o = 1$ 和 $w_u = 4$。我们将这些值以及计算出的比率 $R_o$ 和 $R_u$ 代入 $S$ 的方程。为保持精度，我们尽可能长时间地使用比率的分数形式。\n$$\nS = 1 \\cdot \\left(\\frac{38}{90} - 0.35\\right)^{2} + 4 \\cdot \\left(0.15625 - 0.05\\right)^{2}\n$$\n首先，我们计算括号中的项：\n$$\nR_o - T_o = \\frac{38}{90} - \\frac{35}{100} = \\frac{19}{45} - \\frac{7}{20} = \\frac{19 \\cdot 4}{180} - \\frac{7 \\cdot 9}{180} = \\frac{76 - 63}{180} = \\frac{13}{180}\n$$\n$$\nR_u - T_u = 0.15625 - 0.05 = 0.10625 = \\frac{25}{160} - \\frac{5}{100} = \\frac{5}{32} - \\frac{1}{20} = \\frac{5 \\cdot 5}{160} - \\frac{1 \\cdot 8}{160} = \\frac{25-8}{160} = \\frac{17}{160}\n$$\n现在，将这些精确的分数差代入 $S$ 的表达式中：\n$$\nS = 1 \\cdot \\left(\\frac{13}{180}\\right)^{2} + 4 \\cdot \\left(\\frac{17}{160}\\right)^{2}\n$$\n$$\nS = \\frac{13^2}{180^2} + 4 \\cdot \\frac{17^2}{160^2} = \\frac{169}{32400} + 4 \\cdot \\frac{289}{25600} = \\frac{169}{32400} + \\frac{289}{6400}\n$$\n为了获得最终的数值，我们可以使用小数展开：\n$$\nS \\approx 0.00521604938... + 0.04515625\n$$\n$$\nS \\approx 0.05037229938...\n$$\n问题要求将 $S$ 的最终值四舍五入到四位有效数字。第一个非零数字是 $5$，这是第一位有效数字。随后的有效数字是 $0$、$3$ 和 $7$。第五位有效数字是 $2$。由于 $2  5$，我们向下舍入，这意味着我们保持第四位有效数字不变。\n$$\nS \\approx 0.05037\n$$",
            "answer": "$$\\boxed{0.05037}$$"
        },
        {
            "introduction": "在前两个练习所建立的规划和评估概念之上，本章的最终实践要求您构建一个动态的、系统级的解决方案。您将设计一个分配算法，在多个医疗设施之间实时调度大量伤员，并需要同时处理行程时间、手术室($OR$)与重症监护室($ICU$)容量等多重动态约束 。这项练习旨在弥合理论模型与运营指挥之间的鸿沟，模拟区域性灾难响应中所需的复杂、实时的决策过程。",
            "id": "5110858",
            "problem": "一场大规模伤亡事件（MCI）会产生一个带有时间戳的外科病患流，这些病患需要在手术室（OR）中接受确定性手术治疗，并在重症监护室（ICU）中接受术后即时护理。您必须构建一个离散时间分配算法，为每位新来的病患分配一个医疗设施和预定的到达时间，以确保其在到达该设施的离散时间步时，既有一个手术室空位，也有一个重症监护室床位可用。该算法必须遵守因果关系、运输时间及有限容量的限制，并在每次分配后动态更新剩余容量。\n\n需使用的基本原理和约束：\n- 离散容量下的流量守恒：在一个给定的时间步，一个设施分配的病患数不能超过其拥有的手术室空位数或重症监护室床位数。形式上，如果设施 $j$ 在时间步 $t$ 的手术室容量为 $OR_{j,t}$，重症监护室容量为 $ICU_{j,t}$，那么分配到在时间步 $t$ 到达设施 $j$ 的病患数不能超过 $\\min(OR_{j,t}, ICU_{j,t})$。\n- 因果关系与运输时间约束：一名在现场释放时间为 $t_i$ 的病患 $i$ 只能在时间 $t_i + TT_j$ 或之后到达设施 $j$，其中 $TT_j$ 是前往设施 $j$ 的运输时间。\n- 离散化：使用固定的时间步长 $\\Delta$（单位：分钟）。连续时间 $\\tau$ 映射到离散时间步索引 $a = \\left\\lfloor \\tau / \\Delta \\right\\rfloor$。时间步索引为 $0, 1, \\dots, T-1$，分别代表时间区间 $[0,\\Delta), [\\Delta, 2\\Delta), \\dots, [(T-1)\\Delta, T\\Delta)$。\n- 最大可容忍等待时间：每位病患 $i$ 的预定到达时间不得晚于 $t_i + TT_j + W$，其中 $W$ 是一个非负的等待时间上限。在离散时间步中，对于设施 $j$ 的候选到达时间步位于闭整数区间 $a \\in \\left[\\left\\lfloor (t_i+TT_j)/\\Delta \\right\\rfloor,\\ \\min\\left(T-1,\\ \\left\\lfloor (t_i+TT_j+W)/\\Delta \\right\\rfloor\\right)\\right]$。\n- 优先级规则：按 $t_i$ 的升序（先释放的优先）处理病患。若 $t_i$ 相同，则按伤情严重程度 $A_i$ 的升序处理，其中 $A_i = 1$ 为最高优先级。若仍然存在平局，则按原始输入索引的升序打破。\n- 决策时的短视目标：对于给定的病患 $i$，在所有满足上述约束且在时间步 $a$ 的手术室和重症监护室剩余容量均为正的设施 $j$ 和可行到达时间步 $a$ 中，选择使 $a$ 最小化（最早的确定性治疗）的配对 $(j,a)$。如果不同设施之间在 $a$ 上出现平局，则按较小的 $TT_j$ 打破平局，然后按较小的设施索引 $j$ 打破。分配后，将 $OR_{j,a}$ 和 $ICU_{j,a}$ 减 1。如果对于任何设施都不存在可行的 $(j,a)$，则将该病患分配到溢出类别 $0$，并且不改变任何容量。\n\n所有时间量必须以分钟为单位处理。不涉及角度。设施索引是从 1 开始的正整数。溢出编码为整数 $0$。\n\n您的程序必须精确实现上述算法，并将其应用于下面的测试套件。对于每个测试用例，返回一个分配给病患的设施索引列表，其顺序与该测试用例中列出的病患顺序完全一致。将所有测试用例的结果汇总到一个列表的列表中。\n\n测试套件（所有时间单位为分钟，步长 $\\Delta$ 单位为分钟，答案为无单位整数）：\n- 测试用例 1：\n  - $\\Delta = 15$， $F = 2$， $T = 6$， $W = 60$。\n  - 运输时间 $TT = [10, 25]$。\n  - 各设施和时间步的手术室容量：\n    - 设施 1： $[1, 1, 0, 1, 0, 1]$。\n    - 设施 2： $[0, 1, 1, 0, 1, 1]$。\n  - 各设施和时间步的重症监护室容量：\n    - 设施 1： $[1, 0, 1, 1, 0, 1]$。\n    - 设施 2： $[1, 1, 0, 1, 1, 0]$。\n  - 按所列顺序的病患 $(t_i, A_i)$：\n    - $[(0, 1), (15, 2), (15, 1), (30, 3)]$。\n- 测试用例 2：\n  - $\\Delta = 15$， $F = 2$， $T = 4$， $W = 30$。\n  - 运输时间 $TT = [15, 15]$。\n  - 手术室容量：\n    - 设施 1： $[1, 0, 1, 0]$。\n    - 设施 2： $[1, 0, 1, 0]$。\n  - 重症监护室容量：\n    - 设施 1： $[1, 0, 1, 0]$。\n    - 设施 2： $[1, 0, 1, 0]$。\n  - 病患： $[(0, 1)]$。\n- 测试用例 3（溢出边界情况）：\n  - $\\Delta = 15$， $F = 1$， $T = 3$， $W = 15$。\n  - 运输时间 $TT = [10]$。\n  - 手术室容量：\n    - 设施 1： $[0, 0, 0]$。\n  - 重症监护室容量：\n    - 设施 1： $[1, 1, 1]$。\n  - 病患： $[(0, 1)]$。\n- 测试用例 4（动态更新与平局打破）：\n  - $\\Delta = 15$， $F = 3$， $T = 5$， $W = 45$。\n  - 运输时间 $TT = [10, 10, 25]$。\n  - 手术室容量：\n    - 设施 1： $[1, 1, 0, 0, 0]$。\n    - 设施 2： $[1, 0, 1, 0, 0]$。\n    - 设施 3： $[0, 1, 1, 1, 0]$。\n  - 重症监护室容量：\n    - 设施 1： $[1, 1, 0, 0, 0]$。\n    - 设施 2： $[1, 1, 0, 0, 0]$。\n    - 设施 3： $[0, 1, 1, 1, 0]$。\n  - 病患： $[(0, 1), (0, 2), (15, 1)]$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果，无空格，例如 `[[\\dots],[\\dots],\\dots]`。每个内部列表包含一个测试用例的分配设施索引，并保持该测试用例中列出的病患顺序。如果病患在等待时间上限 $W$ 内无法分配，则在该位置输出 $0$。不应打印任何其他文本。",
            "solution": "所提出的问题是一个离散时间资源分配与调度挑战，背景设定在大规模伤亡事件管理中。任务是设计一种算法，将外科病患分配到医疗设施，同时遵守一系列详细的约束，包括设施容量、病患运输时间以及最大等待时间。\n\n该问题陈述经确认为合理。它在科学上基于运筹学和离散事件模拟的原理，这些是建模和优化复杂系统的标准STEM方法。此问题是适定 (well-posed) 的，提供了一套完整、一致且客观的规则，包括明确的优先级和打破平局的机制。这种确定性确保了唯一解的存在，并且可以通过直接实现指定的算法找到该解。\n\n该解决方案是一种分步、短视的调度算法，它按顺序处理病患，并在决策时为每位病患做出当前最优的分配，而不考虑未来的病患到达情况。资源（手术室和重症监护室床位）的剩余容量在每次分配后都会动态更新，从而影响对后续病患的决策。\n\n该算法的执行步骤如下：\n\n1.  **系统初始化**：为每个测试用例定义参数——时间步长 $\\Delta$、设施数量 $F$、时间步数 $T$ 和最大等待时间 $W$。每个设施 $j$ 在每个时间步 $a$ 的手术室（$OR_{j,a}$）和重症监护室（$ICU_{j,a}$）的初始容量根据输入数据进行初始化。\n\n2.  **病患优先级排序**：对待处理的病患列表进行排序。主排序键是按升序排列的现场释放时间 $t_i$。$t_i$ 的平局由按升序排列的伤情等级 $A_i$ 打破（$A_i$ 值越小表示优先级越高）。任何剩余的平局则由病患在输入列表中的原始索引按升序打破。这确保了唯一且确定性的处理顺序。\n\n3.  **迭代分配**：算法遍历经过优先级排序的病患列表。对于每位病患 $i$，它寻找最优的分配对 $(j, a)$，代表分配到设施 $j$ 并在时间步 $a$ 到达。\n\n4.  **候选方案搜索**：对于当前病患 $i$，算法将每个设施 $j \\in \\{1, 2, ..., F\\}$ 作为潜在目的地进行评估。\n    \n    a.  **可行到达窗口**：对于每个设施 $j$，计算一个可行的离散到达时间步窗口。此窗口受因果关系、运输时间和最大可容忍等待时间的约束。最早可能到达的连续分钟时间是 $\\tau_{min} = t_i + TT_j$，其中 $TT_j$ 是到设施 $j$ 的运输时间。最晚允许的到达时间是 $\\tau_{max} = t_i + TT_j + W$。这些时间通过公式 $a = \\lfloor \\tau / \\Delta \\rfloor$ 映射到离散时间步。候选到达时间步的范围是闭合整数区间：\n    $$ a \\in \\left[ a_{start}, a_{end} \\right] = \\left[ \\lfloor (t_i + TT_j) / \\Delta \\rfloor, \\min(T-1, \\lfloor (t_i + TT_j + W) / \\Delta \\rfloor) \\right] $$\n    搜索不能超过最大模拟时间步，因此有 $\\min(T-1, \\dots)$ 项。\n\n    b.  **容量检查与候选方案生成**：算法从 $a_{start}$ 到 $a_{end}$ 遍历时间步 $a$。对于每个时间步，它检查设施 $j$ 是否有足够容量。只有当手术室和重症监护室的剩余容量都严格为正时，分配才是可行的：\n    $$ \\text{OR}_{j,a}  0 \\quad \\text{and} \\quad \\text{ICU}_{j,a}  0 $$\n    窗口内满足此条件的第一个时间步 $a$ 代表了病患 $i$ 在设施 $j$ 能获得的最早服务时间。这个配对 $(j, a)$ 成为一个候选分配方案。由于主要目标是最小化到达时间 $a$，我们只需为每个设施考虑这第一个可行的时间步。\n\n5.  **最优决策**：在评估完所有设施后，算法会得到一个候选分配列表，其中每个候选方案是一个对应于各设施提供的最佳选项的元组 $(a, TT_j, j)$。算法根据指定的短视目标选择全局最优的分配方案：\n    -   主要标准：最小化到达时间步 $a$。\n    -   次要标准（平局打破）：最小化运输时间 $TT_j$。\n    -   第三标准（平局打破）：最小化设施索引 $j$。\n    这是通过对候选元组列表进行排序并选择第一个来实现的。\n\n6.  **状态更新与溢出处理**：\n    -   如果找到了一个最优分配 $(j^*, a^*)$，则将该病患分配给设施 $j^*$。然后通过将该设施在该时间步的容量递减来更新系统状态：\n        $$ \\text{OR}_{j^*, a^*} \\leftarrow \\text{OR}_{j^*, a^*} - 1 $$\n        $$ \\text{ICU}_{j^*, a^*} \\leftarrow \\text{ICU}_{j^*, a^*} - 1 $$\n    -   如果在任何设施的相应时间窗口内都找不到该病患的可行分配，则将该病患分配到一个溢出类别，用整数 $0$ 表示。在这种情况下，不进行任何容量更新。\n\n7.  **结果汇总**：记录每位病患分配到的设施索引（或表示溢出的 $0$）。在一个测试用例中的所有病患都处理完毕后，生成的分配列表会根据病患的原始输入顺序进行排序，然后添加到最终的结果集合中。\n\n这个结构化、确定性的流程被实现用于处理所提供的测试套件并生成所需的输出。\n```python\nimport numpy as np\nimport math\n\ndef solve_mci_allocation(delta, F, T, W, travel_times, or_capacities, icu_capacities, patients):\n    \"\"\"\n    Implements the discrete-time allocation algorithm for a Mass Casualty Incident.\n    \"\"\"\n    \n    # Use numpy arrays for capacities for easier indexing and updates.\n    # We create copies to modify them during the simulation for one test case.\n    or_caps = np.array(or_capacities)\n    icu_caps = np.array(icu_capacities)\n    \n    # Augment patients with their original index to maintain output order.\n    # Patient tuple format: (release_time, acuity, original_index)\n    patients_with_indices = [(p[0], p[1], i) for i, p in enumerate(patients)]\n    \n    # Sort patients based on the priority discipline:\n    # 1. Ascending scene release time (t_i)\n    # 2. Ascending acuity (A_i)\n    # 3. Ascending original input index\n    patients_with_indices.sort(key=lambda x: (x[0], x[1], x[2]))\n    \n    # Initialize results array, ordered by original patient index.\n    num_patients = len(patients)\n    assignments = [0] * num_patients\n    \n    # Process each patient according to the sorted priority list.\n    for t_i, A_i, original_index in patients_with_indices:\n        \n        best_options = []\n        \n        # Evaluate each facility (j is 1-based index)\n        for j in range(1, F + 1):\n            tt_j = travel_times[j - 1]\n            \n            # Calculate the feasible arrival window in discrete time steps.\n            earliest_arrival_time = t_i + tt_j\n            latest_arrival_time = t_i + tt_j + W\n            \n            start_step = math.floor(earliest_arrival_time / delta)\n            end_step = min(T - 1, math.floor(latest_arrival_time / delta))\n\n            # Ensure the window is valid\n            if start_step > end_step:\n                continue\n                \n            # Find the first available time step 'a' for facility 'j'.\n            for a in range(start_step, end_step + 1):\n                # Check for available OR and ICU slots. Array indices are 0-based.\n                if or_caps[j - 1, a] > 0 and icu_caps[j - 1, a] > 0:\n                    # Found the earliest feasible slot for this facility.\n                    # Candidate tuple: (arrival_step, travel_time, facility_index)\n                    best_options.append((a, tt_j, j))\n                    break # Move to the next facility\n    \n        # Select the best assignment from the collected options.\n        if best_options:\n            # Sort according to the tie-breaking rules:\n            # 1. Minimize arrival step 'a'\n            # 2. Minimize travel time 'TT_j'\n            # 3. Minimize facility index 'j'\n            best_options.sort()\n            \n            best_a, _, best_j = best_options[0]\n            \n            # Record the assignment.\n            assignments[original_index] = best_j\n            \n            # Update capacities (decrement by 1).\n            or_caps[best_j - 1, best_a] -= 1\n            icu_caps[best_j - 1, best_a] -= 1\n        else:\n            # No feasible assignment found, assign to overflow.\n            assignments[original_index] = 0\n            \n    return assignments\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"delta\": 15, \"F\": 2, \"T\": 6, \"W\": 60,\n            \"travel_times\": [10, 25],\n            \"or_capacities\": [[1, 1, 0, 1, 0, 1], [0, 1, 1, 0, 1, 1]],\n            \"icu_capacities\": [[1, 0, 1, 1, 0, 1], [1, 1, 0, 1, 1, 0]],\n            \"patients\": [(0, 1), (15, 2), (15, 1), (30, 3)]\n        },\n        {\n            \"delta\": 15, \"F\": 2, \"T\": 4, \"W\": 30,\n            \"travel_times\": [15, 15],\n            \"or_capacities\": [[1, 0, 1, 0], [1, 0, 1, 0]],\n            \"icu_capacities\": [[1, 0, 1, 0], [1, 0, 1, 0]],\n            \"patients\": [(0, 1)]\n        },\n        {\n            \"delta\": 15, \"F\": 1, \"T\": 3, \"W\": 15,\n            \"travel_times\": [10],\n            \"or_capacities\": [[0, 0, 0]],\n            \"icu_capacities\": [[1, 1, 1]],\n            \"patients\": [(0, 1)]\n        },\n        {\n            \"delta\": 15, \"F\": 3, \"T\": 5, \"W\": 45,\n            \"travel_times\": [10, 10, 25],\n            \"or_capacities\": [[1, 1, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 1, 1, 0]],\n            \"icu_capacities\": [[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 1, 1, 1, 0]],\n            \"patients\": [(0, 1), (0, 2), (15, 1)]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_mci_allocation(\n            case[\"delta\"], case[\"F\"], case[\"T\"], case[\"W\"],\n            case[\"travel_times\"], case[\"or_capacities\"],\n            case[\"icu_capacities\"], case[\"patients\"]\n        )\n        all_results.append(result)\n    \n    # Format the final output string exactly as specified.\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(inner_strings)}]\")\n\n# solve() # The function call is commented out as it is not part of the solution logic itself.\n```",
            "answer": "[[1,2,1,1],[1],[0],[1,2,1]]"
        }
    ]
}