{
    "hands_on_practices": [
        {
            "introduction": "在初级保健等广泛的临床环境中，筛查精神障碍是一项重要但充满挑战的任务。阳性筛查结果并不等同于确诊，理解这一点至关重要。本练习  将应用贝叶斯定理，在一个假设的临床情景中计算阳性筛查结果后患者真正患有特定恐惧症的后验概率。这项实践旨在揭示阳性预测值（PPV）这一核心概念，帮助临床医生就后续的诊断评估做出更明智的决策。",
            "id": "4761015",
            "problem": "一家初级保健诊所使用一种经过验证的超简短筛查工具来筛查特定恐惧症。在该诊所的成年人群中，《精神疾病诊断与统计手册》第五版 (DSM-5) 所定义的特定恐惧症的时点患病率（先验概率）为 $0.05$。该工具的敏感性 $Se=0.85$，特异性 $Sp=0.90$。一名患者筛查结果为阳性。\n\n从敏感性、特异性、患病率和贝叶斯定理的核心定义出发，推导出一个表达式，用于计算在筛查结果为阳性的情况下，该患者确实患有特定恐惧症的后验概率，然后使用所提供的参数计算其数值。\n\n将最终的后验概率以小数形式表示，并将答案四舍五入至四位有效数字。\n\n最后，简洁地解释该后验概率在初级保健中对于进行进一步诊断评估还是立即治疗的决策方面的临床意义。在您的最终数值答案中不要包含任何解释。",
            "solution": "设 $D$ 表示患者患有特定恐惧症的事件，设 $D^c$ 表示患者没有患特定恐惧症的事件。设 $T+$ 表示测试结果为阳性的事件，设 $T-$ 表示测试结果为阴性的事件。\n\n题目提供了以下信息：\n1.  疾病的时点患病率，或先验概率：$P(D) = 0.05$。\n2.  该工具的敏感性：$Se = P(T+|D) = 0.85$。这是在患者患有该疾病的条件下，测试结果为阳性的条件概率。\n3.  该工具的特异性：$Sp = P(T-|D^c) = 0.90$。这是在患者没有患该疾病的条件下，测试结果为阴性的条件概率。\n\n我们被要求推导在筛查结果为阳性的情况下，该患者确实患有特定恐惧症的后验概率（记为 $P(D|T+)$）的表达式，然后计算其值。\n\n我们从条件概率的定义开始，这是贝叶斯定理的基础：\n$$P(D|T+) = \\frac{P(D \\cap T+)}{P(T+)}$$\n分子 $P(D \\cap T+)$ 可以再次使用条件概率的定义重新表示为：$P(D \\cap T+) = P(T+|D) P(D)$。\n分母 $P(T+)$ 是测试结果为阳性的总概率。它可以通过考虑出现阳性测试的两种互斥且穷尽的情形来计算：真阳性（患者患有该疾病且测试为阳性）和假阳性（患者没有患该疾病但测试为阳性）。使用全概率公式：\n$$P(T+) = P(T+ \\cap D) + P(T+ \\cap D^c)$$\n再次对每一项应用条件概率的定义：\n$$P(T+) = P(T+|D)P(D) + P(T+|D^c)P(D^c)$$\n\n我们已知 $P(T+|D) = Se$ 和 $P(D)$。我们需要确定剩下的项，$P(D^c)$ 和 $P(T+|D^c)$。\n没有患该疾病的概率 $P(D^c)$ 是患病率的补集：\n$$P(D^c) = 1 - P(D)$$\n概率 $P(T+|D^c)$ 是假阳性率。它是特异性 $Sp = P(T-|D^c)$ 的补集，因为一个没有患该疾病的患者要么测试为阴性（特异性），要么测试为阳性（假阳性）。因此：\n$$P(T+|D^c) = 1 - P(T-|D^c) = 1 - Sp$$\n\n将这些表达式代回 $P(T+)$ 的公式中：\n$$P(T+) = P(T+|D)P(D) + (1 - Sp)(1 - P(D))$$\n\n现在我们将 $P(T+)$ 的完整表达式代入 $P(D|T+)$ 的初始贝叶斯定理公式中：\n$$P(D|T+) = \\frac{P(T+|D) P(D)}{P(T+|D)P(D) + (1 - Sp)(1 - P(D))}$$\n这就是用患病率、敏感性和特异性表示后验概率的推导出的解析表达式。\n\n接下来，我们使用给定的参数计算数值：$P(D) = 0.05$, $Se = 0.85$, 和 $Sp = 0.90$。\n\n首先，我们计算真阳性的概率，也就是分子：\n$$P(T+ \\cap D) = Se \\cdot P(D) = 0.85 \\times 0.05 = 0.0425$$\n\n接下来，我们计算假阳性的概率，也就是分母中的第二项：\n$$P(T+ \\cap D^c) = P(T+|D^c)P(D^c) = (1 - Sp)(1 - P(D))$$\n$$P(T+ \\cap D^c) = (1 - 0.90)(1 - 0.05) = 0.10 \\times 0.95 = 0.0950$$\n\n测试结果为阳性的总概率 $P(T+)$ 是真阳性概率和假阳性概率之和：\n$$P(T+) = P(T+ \\cap D) + P(T+ \\cap D^c) = 0.0425 + 0.0950 = 0.1375$$\n\n最后，我们计算后验概率 $P(D|T+)$：\n$$P(D|T+) = \\frac{0.0425}{0.1375} \\approx 0.30909090...$$\n\n按照要求将结果四舍五入到四位有效数字，我们得到：\n$$P(D|T+) \\approx 0.3091$$\n\n这个值通常被称为测试的阳性预测值 (PPV)，它表示筛查结果为阳性的患者实际患有该疾病的概率。\n\n这个大约 $31\\%$ 的后验概率的临床意义是，这种超简短筛查工具的阳性结果本身并不足以作为确诊特定恐惧症或开始治疗的充分依据。即使筛查结果为阳性，患者没有患病的可能性（概率约为 $1 - 0.3091 \\approx 69\\%$）仍然比患病的可能性要大。该筛查成功地识别出一个比普通人群风险更高的亚群（风险从 $5\\%$ 增加到 $31\\%$），但假阳性率相当高。因此，在筛查结果呈阳性后，正确的临床操作是进行更彻底的诊断性评估，例如由心理健康专业人员进行的结构化临床访谈，以便在考虑治疗计划之前确认或排除诊断。",
            "answer": "$$ \\boxed{0.3091} $$"
        },
        {
            "introduction": "在评估恐惧症和追踪治疗进展时，客观的行为测量方法至关重要，例如行为趋近测试（BAT）。本练习  将超越简单的观察，要求您应用经典测试理论来确定患者的改善是否具有统计学意义的真实变化，还是仅仅源于测量误差。您将推导并计算可靠变化指数（RCI），这是循证实践中的一个关键工具，用以量化治疗效果的真实性。",
            "id": "4761048",
            "problem": "一名临床医生计划使用一种行为趋近测试 (Behavioral Approach Test, BAT) 来客观评估和追踪恐高症，该测试通过离散的高度暴露水平来构建。BAT包含$10$个水平，每个水平代表一个逐渐增高的观察点，且暴露参数在所有治疗单元中都是标准化的。患者的任务是接近每个水平并在该水平停留$2$分钟。BAT得分定义为在不违反停止规则的情况下完全完成的最高水平。各水平如下：水平$1$（$3$米阳台）、水平$2$（$6$米阳台）、水平$3$（$9$米阳台）、水平$4$（$12$米阳台）、水平$5$（$15$米阳台）、水平$6$（$18$米阳台）、水平$7$（$21$米阳台）、水平$8$（$24$米阳台）、水平$9$（$27$米阳台）、水平$10$（$30$米屋顶观景台）。客观停止规则在每个水平上统一应用：在$2$分钟的暴露窗口期内，如果发生以下任何一种情况，则终止该水平的测试：(i) 主观痛苦单位量表 (Subjective Units of Distress Scale, SUDS) 评分达到$\\geq 80$并持续$\\geq 60$秒，(ii) 心率超过$150$次/分钟并持续$\\geq 30$秒，(iii) 可观察到的恐慌行为（如逃跑、拒绝或僵住）持续$\\geq 30$秒，或 (iv) 安全行为（如双手紧抓栏杆、距离边缘$\\geq 2$米）在一次指导提示后$30$秒内未能减少。BAT在所有治疗单元中均按照这些规则一致地实施。\n\n假设BAT总分（完成的最高水平）具有已确立的重测信度$r$和来自稳定参照总体的标准差$\\sigma$。记录了一名患者在第$1$次和第$6$次治疗单元的BAT得分。您需要使用经典测量理论 (Classical Test Theory) 的框架作为基本依据，从将观测分数分解为真实分数和误差，以及根据方差分量定义信度开始。请从第一性原理推导出一个指标，该指标用于量化观测到的变化是否超出了仅由测量误差引起的预期变化，然后根据以下参数计算其值：重测信度$r = 0.90$，标准参照总体的标准差$\\sigma = 2.5$个水平，第$1$次治疗单元的观测BAT得分为$X_{1} = 3$个水平，第$6$次治疗单元的观测BAT得分为$X_{6} = 8$个水平。将最终指标表示为单个实数值。将您的答案四舍五入到四位有效数字。无需单位。",
            "solution": "### 推导与解答\n该问题要求推导一个指标，以量化两次测验施测之间分数的观测变化是否具有统计学意义，即，是否大于仅由测量误差所预期的变化。这个指标被称为可靠改变指数 (Reliable Change Index, RCI)。推导将从经典测量理论 (CTT) 的第一性原理开始。\n\n根据CTT，任何观测分数 $X$ 都由一个真实分数 $T$ 和一个随机误差分量 $E$ 组成。\n$$X = T + E$$\n误差分量 $E$ 假设其均值为零，并且与真实分数 $T$ 不相关。\n\n观测分数的方差 $\\sigma_X^2$ 可以分解为真实分数的方差 $\\sigma_T^2$ 和误差分数的方差 $\\sigma_E^2$：\n$$\\sigma_X^2 = \\sigma_T^2 + \\sigma_E^2$$\n\n测验的信度 $r$ 定义为观测分数方差中可归因于真实分数方差的比例。对于重测信度，这表示为 $r_{XX'}$。\n$$r = \\frac{\\sigma_T^2}{\\sigma_X^2}$$\n\n根据这个定义，我们可以用观测分数方差和信度来表示误差方差 $\\sigma_E^2$。\n$$r = \\frac{\\sigma_X^2 - \\sigma_E^2}{\\sigma_X^2} = 1 - \\frac{\\sigma_E^2}{\\sigma_X^2}$$\n整理得到 $\\sigma_E^2$：\n$$\\sigma_E^2 = \\sigma_X^2 (1 - r)$$\n误差分布的标准差 $\\sigma_E$ 称为测量标准误 (Standard Error of Measurement, SEM)。\n$$SEM = \\sigma_E = \\sigma_X \\sqrt{1 - r}$$\n在这个问题中，标准参照总体的标准差 $\\sigma$ 等同于 $\\sigma_X$。\n$$SEM = \\sigma \\sqrt{1 - r}$$\n\n我们关心的是第$1$次治疗单元的观测分数 $X_1$ 和第$6$次治疗单元的观测分数 $X_6$ 之间的变化。差值分数是 $D = X_6 - X_1$。为了确定这个变化是否“可靠”，我们必须将其与仅由测量误差引起的预期变化量进行比较。这需要计算差值分数分布的标准差，即差值标准误 (Standard Error of the Difference, $S_{diff}$)。\n\n差值分数 $D$ 可以用真实分数和误差分数表示：\n$$D = X_6 - X_1 = (T_6 + E_6) - (T_1 + E_1) = (T_6 - T_1) + (E_6 - E_1)$$\n为了评估变化的可信度，我们考虑零假设，即没有发生真实的变化，即 $T_6 - T_1 = 0$。在此假设下，任何观测到的差异都完全由测量误差引起，$D = E_6 - E_1$。\n\n这个差值误差的方差 $\\sigma_{diff}^2$ 由下式给出：\n$$\\sigma_{diff}^2 = Var(E_6 - E_1)$$\n假设两次施测的误差不相关 ($Cov(E_6, E_1) = 0$)，这是CTT中的一个标准假设，则差值的方差是各方差之和：\n$$\\sigma_{diff}^2 = Var(E_6) + Var(E_1)$$\n由于两个分数都来自在标准条件下施测的同一测验，我们假设它们的误差方差等于测量标准误的平方：\n$$Var(E_6) = Var(E_1) = SEM^2$$\n因此，\n$$\\sigma_{diff}^2 = SEM^2 + SEM^2 = 2 \\cdot SEM^2$$\n差值标准误 $S_{diff}$ 是这个方差的平方根：\n$$S_{diff} = \\sqrt{2 \\cdot SEM^2} = SEM \\sqrt{2}$$\n代入 SEM 的表达式：\n$$S_{diff} = (\\sigma \\sqrt{1 - r}) \\sqrt{2} = \\sigma \\sqrt{2(1 - r)}$$\n这是在没有发生真实变化的情况下，所预期的变化分数分布的标准差。\n\n可靠改变指数 (RCI) 是一个 $z$ 分数，它通过将观测到的变化 $X_6 - X_1$ 除以差值标准误 $S_{diff}$ 来对其进行标准化。\n$$RCI = \\frac{X_6 - X_1}{S_{diff}}$$\n代入推导出的 $S_{diff}$ 公式：\n$$RCI = \\frac{X_6 - X_1}{\\sigma \\sqrt{2(1 - r)}}$$\n这就是推导出的用于量化观测到的变化是否超出了仅由测量误差引起的预期变化的指标。\n\n现在，我们使用给定的参数计算其值：\n-   $X_1 = 3$\n-   $X_6 = 8$\n-   $\\sigma = 2.5$\n-   $r = 0.90$\n\n首先，计算观测到的差值：\n$$X_6 - X_1 = 8 - 3 = 5$$\n接下来，计算差值标准误 $S_{diff}$：\n$$S_{diff} = 2.5 \\sqrt{2(1 - 0.90)} = 2.5 \\sqrt{2(0.10)} = 2.5 \\sqrt{0.20}$$\n现在，计算 RCI：\n$$RCI = \\frac{5}{2.5 \\sqrt{0.20}} = \\frac{2}{\\sqrt{0.20}}$$\n为了简化，$\\sqrt{0.20} = \\sqrt{\\frac{1}{5}} = \\frac{1}{\\sqrt{5}}$。\n$$RCI = \\frac{2}{\\frac{1}{\\sqrt{5}}} = 2\\sqrt{5}$$\n最后，我们计算数值并四舍五入到四位有效数字。\n$$RCI = 2 \\times 2.2360679... = 4.4721359...$$\n四舍五入到四位有效数字得到$4.472$。\nRCI统计显著性的常规阈值是$|RCI| \\ge 1.96$，对应于$p$值为$0.05$（双尾检验）。计算出的值$4.472$远超过这个阈值，表明患者从水平$3$提高到水平$8$是一个统计上可靠的改变，不太可能是由随机测量误差引起的。",
            "answer": "$$\n\\boxed{4.472}\n$$"
        },
        {
            "introduction": "暴露疗法被认为是修正患者对恐惧线索所带来的伤害可能性的高估信念而起作用的。本练习  将使用贝叶斯学习模型来操作化这一理念，为您提供一个计算精神病理学的视角。通过一个模拟计算，您将探索患者先验信念的强度如何从数学上解释其在治疗中对变化的“抵抗”，从而为临床现象提供一个计算层面的解释。",
            "id": "4761033",
            "problem": "您正在使用贝叶斯学习者对特定恐惧症中的信念更新进行建模。在此模型中，患者在遇到恐惧线索时，对伤害概率（表示为 $p$）持有一个先验信念。$p$ 的先验是一个 Beta 分布 $\\mathrm{Beta}(a,b)$。暴露会话产生独立的伯努利结果 $x_t \\in \\{0,1\\}$，其中 $x_t = 1$ 代表有害结果，$x_t = 0$ 代表安全结果。假设各次暴露之间独立同分布，并且伯努利似然参数为 $p$。\n\n使用的基本原理：\n- Beta 先验和伯努利似然的共轭性：一个 $\\mathrm{Beta}(a,b)$ 先验，在 $n$ 次试验中取得 $k$ 次成功的伯努利数据，会产生一个 $\\mathrm{Beta}(a+k,b+n-k)$ 后验。\n- $\\mathrm{Beta}(\\alpha,\\beta)$ 的均值为 $\\alpha / (\\alpha + \\beta)$。\n- Digamma 函数 $\\psi(\\cdot)$ 和对数 Beta 函数 $\\ln B(\\cdot,\\cdot)$ 是良定义的特殊函数。从 $\\mathrm{Beta}(a_0,b_0)$ 到 $\\mathrm{Beta}(a_1,b_1)$ 的 Kullback–Leibler 散度具有以这些函数表示的已知闭式解。\n\n任务：\n给定由元组 $(a,b,n,k)$ 描述的测试用例，其中 $a$ 和 $b$ 是 Beta 先验参数，$n$ 是暴露次数，$k$ 是暴露期间观察到的有害结果次数，请实现一个程序，为每个测试用例计算：\n- 后验均值 $\\mu_{\\text{post}} = \\dfrac{a+k}{a+b+n}$。\n- 伤害概率信念的绝对偏移量 $\\Delta = \\left| \\dfrac{a+k}{a+b+n} - \\dfrac{a}{a+b} \\right|$。\n- 先验权重因子 $w_{\\text{prior}} = \\dfrac{a+b}{a+b+n}$，它量化了相对于数据，先验在多大程度上锚定后验均值。\n- Kullback–Leibler 散度 $D_{\\mathrm{KL}}\\big(\\mathrm{Beta}(a,b)\\,\\|\\,\\mathrm{Beta}(a+k,b+n-k)\\big)$，定义为\n\n$$\nD_{\\mathrm{KL}}\\big(\\mathrm{Beta}(a_0,b_0)\\,\\|\\,\\mathrm{Beta}(a_1,b_1)\\big)\n= \\ln B(a_1,b_1) - \\ln B(a_0,b_0) \n+ (a_0-a_1)\\big(\\psi(a_0)-\\psi(a_0+b_0)\\big) \n+ (b_0-b_1)\\big(\\psi(b_0)-\\psi(a_0+b_0)\\big).\n$$\n\n\n您的程序应使用以下测试套件：\n- 用例 $1$：$(a,b,n,k) = (80,20,20,0)$。\n- 用例 $2$：$(a,b,n,k) = (2,2,20,0)$。\n- 用例 $3$：$(a,b,n,k) = (5,5,0,0)$。\n- 用例 $4$：$(a,b,n,k) = (20,80,20,12)$。\n- 用例 $5$：$(a,b,n,k) = (1000,1000,50,0)$。\n- 用例 $6$：$(a,b,n,k) = (10,10,100,5)$。\n\n所有输出必须是实数。对于每个用例，将四个输出中的每一个都四舍五入到 $6$ 位小数。不涉及物理单位。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身是测试用例的一个列表 $[\\mu_{\\text{post}}, \\Delta, w_{\\text{prior}}, D_{\\mathrm{KL}}]$，顺序与测试套件中的顺序相同。例如，打印的结构应类似于 $[[m_1,\\Delta_1,w_1,D_1],[m_2,\\Delta_2,w_2,D_2],\\dots]$，行内任何地方都没有空格。\n\n目标是纯粹从数学角度证明，较大的 $a+b$ 值如何通过保持较大的 $w_{\\text{prior}}$ 值来减慢暴露期间的信念更新，从而将 $\\mu_{\\text{post}}$ 更紧密地锚定在先验均值上。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据、问题设定良好且客观。它基于标准的 Beta-伯努利共轭模型，概述了一个清晰的计算任务，该模型是贝叶斯统计的基石，常用于认知和学习的计算建模，包括在精神病学领域。所有必要的数据、公式和约束都已提供，并且它们在内部是一致的，在数学上是合理的。\n\n该问题要求为一系列测试用例计算与贝叶斯信念更新相关的几个量。患者对有害结果概率 $p$ 的信念通过一个概率分布来建模。先验信念由一个 Beta 分布捕获，$p \\sim \\mathrm{Beta}(a,b)$，其中 $a$ 和 $b$ 是其参数。这个先验分布的均值代表了初始估计的伤害概率，即 $\\mu_{\\text{prior}} = \\dfrac{a}{a+b}$。\n\n然后，患者经历 $n$ 次暴露会话，这些会话被建模为独立的伯努利试验。在这 $n$ 次试验中，观察到 $k$ 次有害结果。在给定概率 $p$ 的情况下，在 $n$ 次试验中观察到 $k$ 次有害结果的似然遵循二项分布。由于 Beta 先验与伯努利/二项似然之间的共轭性，观察数据后 $p$ 的后验分布也是一个 Beta 分布。具体来说，后验为 $p | \\text{数据} \\sim \\mathrm{Beta}(a', b')$，其中更新后的参数为 $a' = a+k$ 和 $b' = b+n-k$。\n\n任务是为每个给定的测试用例 $(a,b,n,k)$ 计算四个度量指标：\n\n1.  后验均值，$\\mu_{\\text{post}}$：这是后验分布 $\\mathrm{Beta}(a+k, b+n-k)$ 的均值。使用 Beta 分布的均值公式 $\\mu = \\alpha/(\\alpha+\\beta)$，我们得到：\n    $$ \\mu_{\\text{post}} = \\frac{a'}{a'+b'} = \\frac{a+k}{(a+k) + (b+n-k)} = \\frac{a+k}{a+b+n} $$\n    这个值代表了暴露会话后关于伤害概率的更新信念。\n\n2.  绝对信念偏移，$\\Delta$：这个量化了从先验到后验的平均信念变化幅度。它定义为：\n    $$ \\Delta = \\left| \\mu_{\\text{post}} - \\mu_{\\text{prior}} \\right| = \\left| \\frac{a+k}{a+b+n} - \\frac{a}{a+b} \\right| $$\n\n3.  先验权重因子，$w_{\\text{prior}}$：这个因子揭示了后验均值是如何通过先验均值和来自数据的 $p$ 的最大似然估计 $\\hat{p}_{\\text{MLE}} = k/n$ 的加权平均构建的。后验均值可以表示为：\n    $$ \\mu_{\\text{post}} = \\frac{a+b}{a+b+n} \\left(\\frac{a}{a+b}\\right) + \\frac{n}{a+b+n} \\left(\\frac{k}{n}\\right) $$\n    问题将先验权重因子定义为先验均值上的权重：\n    $$ w_{\\text{prior}} = \\frac{a+b}{a+b+n} $$\n    项 $a+b$ 可以解释为先验的“等效样本量”。较大的 $a+b$ 会导致较大的 $w_{\\text{prior}}$，表明先验信念更强，对新数据的变化更具抵抗力。\n\n4.  Kullback–Leibler (KL) 散度，$D_{\\mathrm{KL}}$：它衡量了从先验分布移动到后验分布时的信息增益，或“距离”。问题提供了从源分布 $\\mathrm{Beta}(a_0,b_0)$ 到目标分布 $\\mathrm{Beta}(a_1,b_1)$ 的 KL 散度公式：\n    $$ D_{\\mathrm{KL}}\\big(\\mathrm{Beta}(a_0,b_0)\\,\\|\\,\\mathrm{Beta}(a_1,b_1)\\big) = \\ln B(a_1,b_1) - \\ln B(a_0,b_0) + (a_0-a_1)\\big(\\psi(a_0)-\\psi(a_0+b_0)\\big) + (b_0-b_1)\\big(\\psi(b_0)-\\psi(a_0+b_0)\\big) $$\n    在我们的情境中，源分布是先验，$\\mathrm{Beta}(a_0,b_0) = \\mathrm{Beta}(a,b)$，目标是后验，$\\mathrm{Beta}(a_1,b_1) = \\mathrm{Beta}(a+k, b+n-k)$。代入这些参数得到：\n    $a_0 = a$, $b_0 = b$, $a_1 = a+k$, $b_1 = b+n-k$。\n    因此，$a_0 - a_1 = -k$ 且 $b_0 - b_1 = -(n-k)$。\n    具体公式为：\n    $$ D_{\\mathrm{KL}} = \\ln B(a+k, b+n-k) - \\ln B(a,b) - k\\big(\\psi(a) - \\psi(a+b)\\big) - (n-k)\\big(\\psi(b) - \\psi(a+b)\\big) $$\n    其中 $\\psi(\\cdot)$ 是 digamma 函数，$\\ln B(\\cdot,\\cdot)$ 是对数 Beta 函数，它可以使用对数伽玛函数 $\\ln \\Gamma(\\cdot)$ 计算，即 $\\ln B(\\alpha, \\beta) = \\ln \\Gamma(\\alpha) + \\ln \\Gamma(\\beta) - \\ln \\Gamma(\\alpha+\\beta)$。\n\n实现过程将是遍历所提供的测试用例。对于每个元组 $(a,b,n,k)$，将使用上述公式计算四个量。特殊函数 $\\psi(\\cdot)$ (digamma) 和 $\\ln \\Gamma(\\cdot)$ (log-gamma) 在 `scipy.special` 库中分别以 `psi` 和 `gammaln` 的形式提供。每个量的结果将被四舍五入到 $6$ 位小数，并按规定格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import psi, gammaln\n\ndef solve():\n    \"\"\"\n    Computes belief updating metrics for a series of Bayesian learning scenarios.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, b, n, k)\n        (80, 20, 20, 0),\n        (2, 2, 20, 0),\n        (5, 5, 0, 0),\n        (20, 80, 20, 12),\n        (1000, 1000, 50, 0),\n        (10, 10, 100, 5)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        a, b, n, k = case\n\n        # Prior parameters\n        a0, b0 = float(a), float(b)\n        \n        # Posterior parameters\n        a1, b1 = a0 + k, b0 + n - k\n\n        # 1. Posterior mean\n        mu_post = a1 / (a1 + b1)\n\n        # 2. Absolute shift in belief\n        # Check for a+b > 0 to avoid division by zero, although not an issue in given test cases.\n        mu_prior = a0 / (a0 + b0) if (a0 + b0) > 0 else 0\n        delta = abs(mu_post - mu_prior)\n\n        # 3. Prior weight factor\n        w_prior = (a0 + b0) / (a0 + b0 + n)\n\n        # 4. Kullback-Leibler divergence\n        # D_KL(prior || posterior)\n        if (a0 == a1 and b0 == b1):\n            # This occurs when n=0, k=0 (e.g., Case 3). The posterior is the prior. D_KL is 0.\n            d_kl = 0.0\n        else:\n            # log Beta function: log(B(alpha, beta)) = gammaln(alpha) + gammaln(beta) - gammaln(alpha + beta)\n            log_B0 = gammaln(a0) + gammaln(b0) - gammaln(a0 + b0)\n            log_B1 = gammaln(a1) + gammaln(b1) - gammaln(a1 + b1)\n            \n            # Digamma function psi is used\n            psi_a0 = psi(a0)\n            psi_b0 = psi(b0)\n            psi_a0b0 = psi(a0 + b0)\n\n            term1 = log_B1 - log_B0\n            term2 = (a0 - a1) * (psi_a0 - psi_a0b0)\n            term3 = (b0 - b1) * (psi_b0 - psi_a0b0)\n            \n            d_kl = term1 + term2 + term3\n\n        # Assemble the results for the current case, rounded to 6 decimal places\n        case_result = [\n            round(mu_post, 6),\n            round(delta, 6),\n            round(w_prior, 6),\n            round(d_kl, 6)\n        ]\n        all_results.append(case_result)\n\n    # Format the final output string as per the requirements: [[v1,v2,...],[v3,v4,...],...] with no spaces.\n    case_strings = []\n    for case_res in all_results:\n        num_strings = [f\"{num:.6f}\" for num in case_res]\n        case_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    final_output_string = f\"[{','.join(case_strings)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}