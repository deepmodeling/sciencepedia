{
    "hands_on_practices": [
        {
            "introduction": "在数字信号处理中，混叠是一个基础性挑战。当信号的采样率不足时，高频成分会伪装成低频成分，从而破坏数据。本练习  提供了一个动手实践的机会，通过推导和计算这种伪影的确切频率，帮助您建立关于抗混叠滤波器和正确采样方案重要性的关键直觉。",
            "id": "4202751",
            "problem": "您正在分析用于生物力学的高保真肌电图(EMG)采集系统中的运动伪影干扰。该EMG前置放大器无意中通过了一个连续时间频率为 $f_0$ 的单音正弦波，该频率高于奈奎斯特频率 $f_N$，其中奈奎斯特频率定义为 $f_N = \\frac{f_s}{2}$，而 $f_s$ 是均匀采样率。采样前没有模拟抗混叠滤波器。从周期为 $T_s = \\frac{1}{f_s}$ 的采样和被采样正弦波的离散时间频率的定义出发，推导当频率为 $f_0 > f_N$ 的正弦波以采样率 $f_s$ 采样时，在采样后的EMG数据中，于基带区间 $[0, f_N]$ 内将观察到的混叠频率 $f_{\\mathrm{alias}}$ 的解析表达式。然后，计算当 $f_0 = 80\\,\\text{Hz}$ 且 $f_s = 100\\,\\text{Hz}$ 时的 $f_{\\mathrm{alias}}$。最终的混叠频率以 Hz 为单位表示。无需四舍五入。",
            "solution": "所述问题具有科学依据、提法明确且客观。它涉及数字信号处理中的混叠基本原理，这是生物力学数据采集中一个常见且关键的问题。该问题提供了获得唯一解所需的所有参数。因此，我们进行推导和计算。\n\n设代表干扰的连续时间正弦信号为 $x_c(t)$：\n$$x_c(t) = A \\cos(2\\pi f_0 t + \\phi)$$\n其中 $A$ 是振幅，$f_0$ 是以赫兹为单位的连续时间频率，$t$ 是时间，$\\phi$ 是相位。\n\n该信号以每秒 $f_s$ 次采样的速率进行均匀采样，对应的采样周期为 $T_s = \\frac{1}{f_s}$。通过在离散时间点 $t = nT_s$（其中 $n$ 为整数索引）上对 $x_c(t)$ 进行求值，可获得离散时间信号 $x[n]$。\n$$x[n] = x_c(nT_s) = A \\cos(2\\pi f_0 n T_s + \\phi)$$\n将 $T_s = \\frac{1}{f_s}$ 代入方程，得到用采样频率表示的采样信号表达式：\n$$x[n] = A \\cos\\left(2\\pi \\frac{f_0}{f_s} n + \\phi\\right)$$\n项 $2\\pi \\frac{f_0}{f_s}$ 是归一化离散时间角频率，可表示为 $\\omega_0$。\n\n离散时间正弦波的一个基本性质是其频谱的周期性。在归一化角频率域中，离散时间傅里叶变换以 $2\\pi$ 为周期。因此，如果任意两个角频率 $\\omega_1$ 和 $\\omega_2$ 相差 $2\\pi$ 的整数倍，则它们是不可区分的。对于实值余弦信号，这由以下恒等式表示：\n$$\\cos(\\omega n + \\phi) = \\cos(\\omega n \\pm 2\\pi k n + \\phi) = \\cos((\\omega \\pm 2\\pi k)n + \\phi)$$\n对于任意整数 $k$。\n\n该性质意味着，在采样后，一个连续时间频率 $f_0$ 与集合 $\\{f_0 + k f_s \\mid k \\in \\mathbb{Z}\\}$ 中的任何频率都是不可区分的。采样过程将这一无限的连续时间频率集合映射到单一的离散时间表示上。\n\n问题要求找到混叠频率 $f_{\\mathrm{alias}}$，它是 $f_0$ 在基带区间 $[0, f_N]$ 内的唯一表示。奈奎斯特频率 $f_N$ 定义为 $f_N = \\frac{f_s}{2}$。对于实信号，该区间表示可以无歧义地解析的唯一频率范围。\n\n为了找到 $f_{\\mathrm{alias}}$，我们必须在区间 $[0, \\frac{f_s}{2}]$ 内找到一个频率，该频率在等价关系 $f \\sim f + kf_s$ 下与 $f_0$ 等价。这可以形象地理解为在奈奎斯特频率 $f_N = f_s/2$ 的每个整数倍处“折叠”频率轴。在解析上，这对应于找到原始频率 $f_0$ 到采样频率 $f_s$ 的最近整数倍的绝对距离。\n\n设采样频率的整数倍集合为 $M = \\{k f_s \\mid k \\in \\mathbb{Z}\\}$。我们必须找到此集合中与 $f_0$ 最接近的成员 $k^* f_s$。通过将比率 $\\frac{f_0}{f_s}$ 四舍五入到最近的整数，可以找到使距离 $|f_0 - k f_s|$ 最小化的整数 $k^*$：\n$$k^* = \\text{round}\\left(\\frac{f_0}{f_s}\\right)$$\n其中 $\\text{round}(x)$ 是将其参数 $x$ 四舍五入到最近整数的函数。\n\n混叠频率 $f_{\\mathrm{alias}}$ 是 $f_0$ 与 $f_s$ 的这个最近倍数之差的绝对值：\n$$f_{\\mathrm{alias}} = \\left|f_0 - k^* f_s\\right| = \\left|f_0 - \\text{round}\\left(\\frac{f_0}{f_s}\\right) f_s\\right|$$\n这个通用表达式得出了在区间 $[0, \\frac{f_s}{2}]$ 内的混叠频率。\n\n我们现在将此推导出的公式应用于问题陈述中给出的具体值：\n- 原始连续时间频率：$f_0 = 80\\,\\text{Hz}$\n- 均匀采样率：$f_s = 100\\,\\text{Hz}$\n\n首先，我们确定奈奎斯特频率以确认发生混叠：\n$$f_N = \\frac{f_s}{2} = \\frac{100}{2} = 50\\,\\text{Hz}$$\n由于 $f_0 = 80\\,\\text{Hz}$ 大于 $f_N = 50\\,\\text{Hz}$，信号被欠采样，其频率将混叠到基带中。\n\n接下来，我们计算原始频率与采样频率之比：\n$$\\frac{f_0}{f_s} = \\frac{80}{100} = 0.8$$\n我们将此比率四舍五入到最近的整数以找到 $k^*$：\n$$k^* = \\text{round}(0.8) = 1$$\n最后，我们将这些值代入混叠频率的表达式中：\n$$f_{\\mathrm{alias}} = |80 - (1) \\times 100| = |80 - 100| = |-20| = 20$$\n得到的混叠频率为 $20\\,\\text{Hz}$。该值位于所要求的基带区间 $[0, 50\\,\\text{Hz}]$ 内。因此，这个 $80\\,\\text{Hz}$ 的正弦干扰将以 $20\\,\\text{Hz}$ 频率的伪影形式出现在采样的EMG数据中。",
            "answer": "$$\\boxed{20}$$"
        },
        {
            "introduction": "一旦确定了滤波的必要性，下一步就是设计一个满足特定应用需求的滤波器。本练习  模拟了一个真实的生物力学场景：设计一个低通滤波器以分离生理运动和噪声。您将经历一个完整的流程，将通带波纹和阻带衰减等性能要求转化为切比雪夫原型滤波器所需的阶数，这是无限脉冲响应（IIR）滤波器设计的基石。",
            "id": "4202801",
            "problem": "一个安装在胫骨上的惯性测量单元 (IMU) 在跑步过程中以 $f_{\\mathrm{samp}} = 200$ Hz 的采样频率记录矢状面内的膝关节角度。具有生理意义的运动内容集中在 $f_{\\mathrm{p}} = 8$ Hz 以下，而传感器微振动和软组织伪影则在 $f_{\\mathrm{sb}} = 35$ Hz 以上贡献能量。为了在保留运动学信号的同时衰减这些伪影，你将通过双线性变换，从一个模拟切比雪夫I型原型设计一个数字低通滤波器。设计指标为：通带波纹不大于 $0.5$ 分贝 (dB)，阻带衰减不小于 $40$ dB。通带边缘设置在 $f_{\\mathrm{p}}$，阻带边缘设置在 $f_{\\mathrm{sb}}$。对双线性变换使用频率预畸，其中模拟原型频率变量由 $\\Omega = 2 f_{\\mathrm{samp}} \\tan\\!\\left( \\pi f / f_{\\mathrm{samp}} \\right)$ 定义，适用于以赫兹表示的数字频率 $f$。\n\n从第一性原理出发——即基于第一类切比雪夫多项式的切比雪夫I型幅值平方响应的定义、波纹和衰减的分贝关系，以及双线性变换映射——推导出能同时满足这些通带和阻带指标的最小滤波器阶数 $N$。将你的最终答案表示为满足这两个约束条件的最小整数 $N$。无需四舍五入到指定的有效数字位数。报告单个整数值 $N$，不带单位。",
            "solution": "所述问题具有科学依据、是良定的且客观的。它提出了数字信号处理中的一个标准任务：基于模拟原型设计一个无限脉冲响应 (IIR) 滤波器，以满足特定的频域标准。该应用属于生物力学领域，在此类领域中，这种滤波是常规操作。所有提供的数据 ($f_{\\mathrm{samp}}$、$f_{\\mathrm{p}}$、$f_{\\mathrm{sb}}$、$A_{\\mathrm{p}}$、$A_{\\mathrm{s}}$)、定义（切比雪夫I型滤波器）和方法（带预畸的双线性变换）都是标准的、一致的，并且足以确定一个唯一的最小滤波器阶数。因此，该问题被认为是有效的，并且可以构建解答。\n\n任务是找到满足给定指标的切比雪夫I型低通滤波器的最小整数阶数 $N$。设计过程包括将数字滤波器指标映射到模拟原型域，确定模拟滤波器所需的阶数，然后将其变换回数字域。滤波器阶数 $N$ 在双线性变换下是不变的。\n\n一个 $N$ 阶模拟低通切比雪夫I型滤波器的幅值平方频率响应由下式给出：\n$$ |H_a(j\\Omega)|^2 = \\frac{1}{1 + \\epsilon^2 T_N^2(\\frac{\\Omega}{\\Omega_{\\mathrm{p}}})} $$\n其中 $\\Omega$ 是模拟频率（单位：弧度/秒），$\\Omega_{\\mathrm{p}}$ 是模拟通带边缘频率，$T_N(x)$ 是 $N$ 阶第一类切比雪夫多项式，而 $\\epsilon$ 是一个决定通带波纹的参数。\n\n首先，我们将以分贝 (dB) 给出的设计指标与滤波器响应的参数联系起来。\n\n通带波纹指标为 $A_{\\mathrm{p}} \\le 0.5$ dB。在通带边缘 $\\Omega = \\Omega_{\\mathrm{p}}$ 处，$T_N^2(1) = 1$，幅值平方响应在通带内达到其最小值，即 $|H_a(j\\Omega_{\\mathrm{p}})|^2 = \\frac{1}{1+\\epsilon^2}$。以 dB 为单位的通带波纹定义为 $A_{\\mathrm{p}} = 10 \\log_{10}(1+\\epsilon^2)$。我们使用允许的最大波纹来求得所需的 $\\epsilon$：\n$$ A_{\\mathrm{p}} = 0.5 \\, \\text{dB} $$\n$$ 10 \\log_{10}(1 + \\epsilon^2) = 0.5 $$\n$$ 1 + \\epsilon^2 = 10^{0.05} $$\n$$ \\epsilon^2 = 10^{0.05} - 1 $$\n这得到 $\\epsilon = \\sqrt{10^{0.05} - 1}$。\n\n阻带衰减指标为在阻带边缘频率 $\\Omega_{\\mathrm{s}}$ 处 $A_{\\mathrm{s}} \\ge 40$ dB。衰减是幅度响应的倒数。以 dB 表示，可写为 $A_{\\mathrm{s}} \\le -20 \\log_{10}(|H_a(j\\Omega_{\\mathrm{s}})|)$。这等价于 $|H_a(j\\Omega_{\\mathrm{s}})|^2 \\le 10^{-A_{\\mathrm{s}}/10}$。\n$$ A_{\\mathrm{s}} = 40 \\, \\text{dB} $$\n$$ \\frac{1}{1 + \\epsilon^2 T_N^2(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}})} \\le 10^{-40/10} = 10^{-4} $$\n重排此不等式以求解 $T_N$：\n$$ 1 + \\epsilon^2 T_N^2(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}}) \\ge 10^4 $$\n$$ \\epsilon^2 T_N^2(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}}) \\ge 10^4 - 1 $$\n$$ |T_N(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}})| \\ge \\frac{\\sqrt{10^4 - 1}}{\\epsilon} $$\n\n接下来，我们必须根据给定的数字频率 $f_{\\mathrm{p}} = 8$ Hz 和 $f_{\\mathrm{sb}} = 35$ Hz，使用指定的预畸公式 $\\Omega = 2 f_{\\mathrm{samp}} \\tan(\\pi f / f_{\\mathrm{samp}})$（其中 $f_{\\mathrm{samp}} = 200$ Hz）来确定模拟频率 $\\Omega_{\\mathrm{p}}$ 和 $\\Omega_{\\mathrm{s}}$。\n模拟通带边缘频率为：\n$$ \\Omega_{\\mathrm{p}} = 2 f_{\\mathrm{samp}} \\tan\\left(\\frac{\\pi f_{\\mathrm{p}}}{f_{\\mathrm{samp}}}\\right) = 2(200) \\tan\\left(\\frac{\\pi \\cdot 8}{200}\\right) = 400 \\tan(0.04\\pi) \\, \\frac{\\text{rad}}{\\text{s}} $$\n模拟阻带边缘频率为：\n$$ \\Omega_{\\mathrm{s}} = 2 f_{\\mathrm{samp}} \\tan\\left(\\frac{\\pi f_{\\mathrm{sb}}}{f_{\\mathrm{samp}}}\\right) = 2(200) \\tan\\left(\\frac{\\pi \\cdot 35}{200}\\right) = 400 \\tan(0.175\\pi) \\, \\frac{\\text{rad}}{\\text{s}} $$\n因此，比值 $\\Omega_{\\mathrm{s}}/\\Omega_{\\mathrm{p}}$ 为：\n$$ \\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}} = \\frac{400 \\tan(0.175\\pi)}{400 \\tan(0.04\\pi)} = \\frac{\\tan(0.175\\pi)}{\\tan(0.04\\pi)} $$\n由于 $f_{\\mathrm{sb}} > f_{\\mathrm{p}}$，因此 $\\Omega_{\\mathrm{s}} > \\Omega_{\\mathrm{p}}$，并且切比雪夫多项式的自变量大于 $1$。对于 $x > 1$，切比雪夫多项式可以用双曲余弦表示：$T_N(x) = \\cosh(N \\operatorname{arccosh}(x))$。\n将此代入我们的不等式中：\n$$ \\cosh\\left(N \\operatorname{arccosh}\\left(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}}\\right)\\right) \\ge \\frac{\\sqrt{10^4 - 1}}{\\epsilon} $$\n由于 $\\operatorname{arccosh}(x)$ 对于 $x \\ge 1$ 是一个单调递增函数：\n$$ N \\operatorname{arccosh}\\left(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}}\\right) \\ge \\operatorname{arccosh}\\left(\\frac{\\sqrt{10^4 - 1}}{\\epsilon}\\right) $$\n求解 $N$：\n$$ N \\ge \\frac{\\operatorname{arccosh}\\left(\\frac{\\sqrt{10^4 - 1}}{\\epsilon}\\right)}{\\operatorname{arccosh}\\left(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}}\\right)} $$\n现在，我们代入 $\\epsilon$ 和频率比的表达式：\n$$ N \\ge \\frac{\\operatorname{arccosh}\\left(\\frac{\\sqrt{10^4 - 1}}{\\sqrt{10^{0.05} - 1}}\\right)}{\\operatorname{arccosh}\\left(\\frac{\\tan(0.175\\pi)}{\\tan(0.04\\pi)}\\right)} $$\n我们继续对各项进行数值计算。\n分子上 $\\operatorname{arccosh}$ 的自变量为：\n$$ \\frac{\\sqrt{10000 - 1}}{\\sqrt{10^{0.05} - 1}} \\approx \\frac{\\sqrt{9999}}{\\sqrt{1.122018 - 1}} \\approx \\frac{99.995}{\\sqrt{0.122018}} \\approx \\frac{99.995}{0.34931} \\approx 286.265 $$\n分母上 $\\operatorname{arccosh}$ 的自变量为：\n$$ \\frac{\\tan(0.175\\pi)}{\\tan(0.04\\pi)} \\approx \\frac{\\tan(0.549779)}{\\tan(0.125664)} \\approx \\frac{0.62487}{0.12633} \\approx 4.94623 $$\n现在我们计算 $\\operatorname{arccosh}$ 函数。我们可以使用恒等式 $\\operatorname{arccosh}(x) = \\ln(x + \\sqrt{x^2-1})$。\n分子：\n$$ \\operatorname{arccosh}(286.265) \\approx \\ln(286.265 + \\sqrt{286.265^2 - 1}) \\approx \\ln(572.528) \\approx 6.3500 $$\n分母：\n$$ \\operatorname{arccosh}(4.94623) \\approx \\ln(4.94623 + \\sqrt{4.94623^2 - 1}) \\approx \\ln(9.7903) \\approx 2.2814 $$\n最后，我们计算 $N$ 的下界：\n$$ N \\ge \\frac{6.3500}{2.2814} \\approx 2.7834 $$\n由于滤波器阶数 $N$ 必须为整数，我们必须选择满足此条件的最小整数，也就是对计算值向上取整。\n$$ N = \\lceil 2.7834 \\rceil = 3 $$\n因此，要同时满足通带和阻带指标，所需的最小滤波器阶数为 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "生物力学信号处理的一个主要目标是量化运动的频率成分，例如识别步态周期频率。本计算练习  将指导您使用韦尔奇方法（Welch's method），这是一种从含噪、有限长度的数据中估计功率谱密度（PSD）的强大技术。通过合成信号并实现一个稳健的峰值检测算法，您将在从频域中提取有意义的生物力学信息方面获得实用的技能。",
            "id": "4202813",
            "problem": "膝关节屈伸角度时间序列是一种一维运动学信号，可建模为实值函数 $x(t)$，单位为度，随时间 $t$（单位为秒）变化。当以赫兹为单位的采样频率 $f_{s}$ 对其进行离散采样时，该序列变为 $x[n]$，其中整数采样索引 $n$ 之间由采样间隔 $\\Delta t = 1/f_{s}$ 分隔。目标是估计该信号的功率谱密度 (PSD)，并解读反映周期性生物力学模式（如步态周期）的主导频率分量。功率谱密度 (PSD) 量化了信号功率在频率上的分布情况。对于离散时间信号，通常通过加窗和平均等一致性方法来估计 PSD，以减少方差和频谱泄漏。在本问题中，必须使用 Welch 方法计算 PSD，并采用汉宁窗（也称汉氏窗）以及连续分段之间 $50\\%$ 的重叠。角度单位必须为度，频率必须以赫兹报告。\n\n从基本原理出发，假设信号 $x[n]$ 在分析窗口内是宽平稳的，并且离散时间傅里叶变换 (DTFT) 将时域测量与其频域表示关联起来。对于有限长度的含噪数据，为减少方差和抑制泄漏，需要进行加窗和分段平均。Welch 方法通过将 $x[n]$ 分割成长度为 $L$ 的分段，对每个分段应用窗函数 $w[n]$，计算分段周期图，并对所有分段进行平均来实现这一目标。汉宁窗是一种平滑的余弦锥形窗，与矩形窗相比能减少频谱泄漏。将分段重叠 $50\\%$ 可以增加平均次数，从而进一步减小估计量的方差。\n\n您必须实现以下任务：\n- 对于每个测试用例，合成一个膝关节角度时间序列 $x[n]$（单位为度），其形式为指定振幅和频率的正弦波之和，可选择性地包含一个小的线性漂移项和附加的指定标准差（单位为度）的零均值高斯噪声。\n- 使用 Welch 方法计算 PSD $S_{xx}(f)$，采用汉宁窗、分段长度 $L$（以采样点数计）和 $L/2$ 的重叠（如有必要，向下取整）。使用密度缩放，使 PSD 的单位为 $\\text{degrees}^{2}/\\text{Hz}$。\n- 在指定的生物力学相关频带 $[f_{\\min}, f_{\\max}]$（单位为赫兹）内识别主导频率分量。使用一个峰值选择标准，该标准要求峰值超过该频带内最大 PSD 的 $\\alpha$ 倍作为相对阈值，并且还需超过该频带内 PSD 中值的 $\\beta$ 倍作为噪声基底因子。只有在这些阈值下为局部最大值的频率才应作为主导频率返回。报告每个主导频率，以赫兹为单位，四舍五入到两位小数。\n- 角度单位必须为度。所有频率输出必须以赫兹为单位。最终输出必须是一行，将所有测试用例的结果聚合到一个方括号列表中，其中每个项目本身都是一个表示该测试用例发现的主导频率的浮点数方括号列表，整行中不得有任何空格。因此，最终输出必须看起来像一个由浮点数方括号列表组成的方括号列表，每个浮点数四舍五入到两位小数。\n\n测试套件：\n请提供以下四个用例的结果；每个用例必须使用下面给出的确切参数独立地进行合成和分析。每个用例使用固定的随机种子以确保可复现性。\n\n- 用例 $1$（理想情况，多分量类步态信号）：\n  - 采样频率 $f_{s} = 120$ Hz，持续时间 $T = 12$ s，总采样点数 $N = f_{s} \\cdot T$。\n  - 分量：振幅和频率 $(A_{1}, f_{1}) = (25, 1.80)$、$(A_{2}, f_{2}) = (8, 3.60)$、$(A_{3}, f_{3}) = (5, 3.20)$，单位为度和赫兹，相位为 $(\\phi_{1}, \\phi_{2}, \\phi_{3}) = (0.00, 0.50, 1.00)$ 弧度。\n  - 附加噪声：标准差 $\\sigma = 1.50$ 度，零均值。\n  - 窗长 $L = 512$ 个采样点，重叠 $L/2$。\n  - 频带限制 $[f_{\\min}, f_{\\max}] = [0.50, 10.00]$ Hz。\n  - 相对阈值 $\\alpha = 0.20$，噪声基底因子 $\\beta = 3.00$。\n  - 随机种子 $s = 12345$。\n\n- 用例 $2$（边界条件，单分段）：\n  - 采样频率 $f_{s} = 100$ Hz，持续时间 $T = 2.56$ s，总采样点数 $N = 256$。\n  - 分量：$(A_{1}, f_{1}) = (30, 2.00)$，单位为度和赫兹，相位 $\\phi_{1} = 0.00$ 弧度。\n  - 附加噪声：$\\sigma = 0.50$ 度。\n  - 窗长 $L = 256$ 个采样点，重叠 $L/2$。\n  - 频带限制 $[f_{\\min}, f_{\\max}] = [0.50, 10.00]$ Hz。\n  - 相对阈值 $\\alpha = 0.30$，噪声基底因子 $\\beta = 3.00$。\n  - 随机种子 $s = 23456$。\n\n- 用例 $3$（边缘情况，步态带外的低频趋势）：\n  - 采样频率 $f_{s} = 100$ Hz，持续时间 $T = 15.00$ s，总采样点数 $N = 1500$。\n  - 分量：$(A_{1}, f_{1}) = (15, 0.20)$，单位为度和赫兹，相位 $\\phi_{1} = 0.00$ 弧度。\n  - 线性漂移：速率 $d = 0.50$ 度/秒。\n  - 附加噪声：$\\sigma = 1.00$ 度。\n  - 窗长 $L = 512$ 个采样点，重叠 $L/2$。\n  - 频带限制 $[f_{\\min}, f_{\\max}] = [0.50, 10.00]$ Hz。\n  - 相对阈值 $\\alpha = 0.40$，噪声基底因子 $\\beta = 3.00$。\n  - 随机种子 $s = 34567$。\n\n- 用例 $4$（边缘情况，频率接近分辨率极限）：\n  - 采样频率 $f_{s} = 90$ Hz，持续时间 $T = 5.00$ s，总采样点数 $N = 450$。\n  - 分量：$(A_{1}, f_{1}) = (15, 1.95)$，单位为度和赫兹，相位 $\\phi_{1} = 0.00$ 弧度。\n  - 附加噪声：$\\sigma = 1.50$ 度。\n  - 窗长 $L = 256$ 个采样点，重叠 $L/2$。\n  - 频带限制 $[f_{\\min}, f_{\\max}] = [0.50, 10.00]$ Hz。\n  - 相对阈值 $\\alpha = 0.25$，噪声基底因子 $\\beta = 3.00$。\n  - 随机种子 $s = 45678$。\n\n您的程序必须：\n- 根据提供的参数合成每个信号 $x[n]$（单位为度）。\n- 使用 Welch 方法、汉宁（Hann）窗和 $50\\%$ 重叠计算 PSD。\n- 在每个用例的指定频带内，找到同时超过上述两个阈值的局部最大值，并返回它们的频率，四舍五入到两位小数。\n- 生成单行输出，其中包含四个结果，形式为用方括号括起来的逗号分隔列表。每个结果本身是一个浮点数的方括号列表，其中没有任何空格。例如，外层列表有四个项目，如果根据指定标准未检测到主导分量，内层列表可能为空。数值频率必须以赫兹为单位。\n\n所有测试用例的最终输出必须是浮点数或浮点数列表。不得打印任何其他文本。",
            "solution": "问题陈述经过了严格验证，被认为是有效的。它以数字信号处理的原理为科学依据，特别是功率谱密度 (PSD) 估计，并将这些原理应用于生物力学中一个明确定义的问题。该问题是自洽的，为每个测试用例明确提供了所有必要的参数、条件和约束。语言客观、精确，结构适定，从而导向一个唯一且可验证的解。\n\n任务是实现一个算法，用于在合成的生物力学信号（具体为膝关节屈伸角度时间序列）中识别主导频率。解决方案包括三个主要阶段：信号合成、使用 Welch 方法进行 PSD 估计，以及一个基于规则的峰值检测算法。\n\n首先，基于一个定义的模型进行信号合成。在持续时间 $T$ 和采样频率 $f_s$ 下生成离散时间信号 $x[n]$。总采样点数为 $N = f_s T$。时间向量为 $t_n = n/f_s$，其中 $n = 0, 1, \\dots, N-1$。信号模型是正弦波的叠加，可能带有一个线性趋势和附加噪声：\n$$x[n] = \\sum_{i} A_i \\sin(2\\pi f_i t_n + \\phi_i) + d \\cdot t_n + \\epsilon[n]$$\n此处，$A_i$、$f_i$ 和 $\\phi_i$ 分别是第 $i$ 个正弦分量的振幅、频率和相位。项 $d \\cdot t_n$ 表示速率为 $d$（单位为度/秒）的线性漂移。噪声项 $\\epsilon[n]$ 被建模为一个从零均值、标准差为 $\\sigma$ 的高斯分布中抽取的独立同分布序列。为保证可复现性，在生成 $\\epsilon[n]$ 时，每个用例都使用一个特定的随机种子。\n\n其次，使用 Welch 方法估计合成信号 $x[n]$ 的功率谱密度 (PSD)。该技术旨在与对整个信号使用简单周期图相比，减少 PSD 估计的方差。该方法包括以下步骤：\n1. 长度为 $N$ 的信号 $x[n]$ 被划分为 $K$ 个可能重叠的、长度为 $L$ 的分段。在本问题中，重叠指定为分段长度的 $50\\%$，即 $L/2$ 个采样点。\n2. 每个分段都与一个窗函数 $w[n]$（此处为汉宁窗）相乘，以减少由数据分段的有限长度引起的频谱泄漏。汉宁窗定义为：\n$$ w[n] = 0.5 \\left(1 - \\cos\\left(\\frac{2\\pi n}{L-1}\\right)\\right), \\quad 0 \\le n < L $$\n3. 对每个加窗分段计算周期图。使用 `density` 缩放时，第 $k$ 个分段的周期图 $I_k(f)$ 被归一化，使其单位为 $\\text{power}/\\text{Hz}$（此处为 $\\text{degrees}^2/\\text{Hz}$）。此归一化通过除以采样频率 $f_s$ 和窗函数样本的平方和 $U = \\sum_{n=0}^{L-1} w[n]^2$ 来实现。\n4. 最终的 PSD 估计值 $S_{xx}(f)$ 是通过对所有 $K$ 个分段的周期图进行平均得到的：\n$$ S_{xx}(f) = \\frac{1}{K} \\sum_{k=0}^{K-1} I_k(f) $$\n这个平均过程减少了估计的方差。所得 PSD 的频率分辨率为 $\\Delta f = f_s/L$。\n\n第三，从估计的 PSD $S_{xx}(f)$ 中，在指定的生物力学相关频带 $[f_{\\min}, f_{\\max}]$ 内识别主导频率。如果一个频率点满足一个多条件准则，则认为它是主导的。频率 $f_p$ 处的峰值必须是一个局部最大值，并且其幅值 $S_{xx}(f_p)$ 必须同时满足两个阈值：\n1. 相对幅值阈值，峰值的功率必须超过频带内最大功率的一个分数 $\\alpha$：\n$$ S_{xx}(f_p) > \\alpha \\cdot \\max_{f \\in [f_{\\min}, f_{\\max}]} \\{S_{xx}(f)\\} $$\n2. 噪声基底阈值，峰值的功率必须显著大于背景噪声水平，该水平由频带内的功率中值估计：\n$$ S_{xx}(f_p) > \\beta \\cdot \\text{median}_{f \\in [f_{\\min}, f_{\\max}]} \\{S_{xx}(f)\\} $$\n只有当两个条件都满足时，才报告一个峰值。这等同于要求其幅值大于两个阈值中的最大值。\n\n实现将通过迭代四个指定的测试用例来进行。对于每个用例，将合成信号，并使用 `scipy.signal.welch` 计算其 PSD。然后，使用 `scipy.signal.find_peaks` 在指定频带内识别 PSD 中的局部最大值，并设置其 `height` 参数以强制执行两个检测阈值。收集已识别峰值的频率，并根据指定的输出要求进行格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Solves the problem by synthesizing signals, computing PSDs, \n    and identifying dominant frequencies for four test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"fs\": 120, \"T\": 12,\n            \"components\": [\n                {\"A\": 25, \"f\": 1.80, \"phi\": 0.00},\n                {\"A\": 8,  \"f\": 3.60, \"phi\": 0.50},\n                {\"A\": 5,  \"f\": 3.20, \"phi\": 1.00}\n            ],\n            \"drift\": 0.0,\n            \"noise_sigma\": 1.50,\n            \"L\": 512,\n            \"f_min\": 0.50, \"f_max\": 10.00,\n            \"alpha\": 0.20, \"beta\": 3.00,\n            \"seed\": 12345\n        },\n        {\n            \"fs\": 100, \"T\": 2.56,\n            \"components\": [\n                {\"A\": 30, \"f\": 2.00, \"phi\": 0.00}\n            ],\n            \"drift\": 0.0,\n            \"noise_sigma\": 0.50,\n            \"L\": 256,\n            \"f_min\": 0.50, \"f_max\": 10.00,\n            \"alpha\": 0.30, \"beta\": 3.00,\n            \"seed\": 23456\n        },\n        {\n            \"fs\": 100, \"T\": 15.00,\n            \"components\": [\n                {\"A\": 15, \"f\": 0.20, \"phi\": 0.00}\n            ],\n            \"drift\": 0.50,\n            \"noise_sigma\": 1.00,\n            \"L\": 512,\n            \"f_min\": 0.50, \"f_max\": 10.00,\n            \"alpha\": 0.40, \"beta\": 3.00,\n            \"seed\": 34567\n        },\n        {\n            \"fs\": 90, \"T\": 5.00,\n            \"components\": [\n                {\"A\": 15, \"f\": 1.95, \"phi\": 0.00}\n            ],\n            \"drift\": 0.0,\n            \"noise_sigma\": 1.50,\n            \"L\": 256,\n            \"f_min\": 0.50, \"f_max\": 10.00,\n            \"alpha\": 0.25, \"beta\": 3.00,\n            \"seed\": 45678\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Set seed for reproducibility\n        np.random.seed(case[\"seed\"])\n\n        # Signal Synthesis\n        fs = case[\"fs\"]\n        T = case[\"T\"]\n        N = int(fs * T)\n        t = np.arange(N) / fs\n        \n        x = np.zeros(N)\n\n        # Add sinusoidal components\n        for comp in case[\"components\"]:\n            x += comp[\"A\"] * np.sin(2 * np.pi * comp[\"f\"] * t + comp[\"phi\"])\n        \n        # Add linear drift\n        if case[\"drift\"] > 0:\n            x += case[\"drift\"] * t\n\n        # Add Gaussian noise\n        x += np.random.normal(0, case[\"noise_sigma\"], N)\n\n        # PSD Computation using Welch's method\n        L = case[\"L\"]\n        overlap = L // 2\n        f, Pxx = signal.welch(x, fs=fs, window='hann', nperseg=L, noverlap=overlap, scaling='density')\n\n        # Dominant Frequency Identification\n        f_min, f_max = case[\"f_min\"], case[\"f_max\"]\n        band_indices = np.where((f >= f_min) & (f <= f_max))\n        \n        f_band = f[band_indices]\n        Pxx_band = Pxx[band_indices]\n        \n        dominant_freqs = []\n        if len(f_band) > 0:\n            # Calculate thresholds\n            max_psd_in_band = np.max(Pxx_band)\n            rel_threshold = case[\"alpha\"] * max_psd_in_band\n            \n            median_psd_in_band = np.median(Pxx_band)\n            noise_floor_threshold = case[\"beta\"] * median_psd_in_band\n            \n            # Combined threshold for peak finding\n            min_height = max(rel_threshold, noise_floor_threshold)\n\n            # Find peaks that satisfy the height requirement\n            peak_indices, _ = signal.find_peaks(Pxx_band, height=min_height)\n            \n            dominant_freqs = [round(f_band[i], 2) for i in peak_indices]\n        \n        all_results.append(dominant_freqs)\n\n    # Format the final output string\n    # e.g., [[1.88,3.28,3.52],[2.00],[],[2.11]]\n    output_parts = []\n    for res_list in all_results:\n        inner_list_str = '[' + ','.join([f\"{freq:.2f}\" for freq in res_list]) + ']'\n        output_parts.append(inner_list_str)\n    \n    final_output_string = '[' + ','.join(output_parts) + ']'\n    print(final_output_string)\n\nsolve()\n\n```"
        }
    ]
}