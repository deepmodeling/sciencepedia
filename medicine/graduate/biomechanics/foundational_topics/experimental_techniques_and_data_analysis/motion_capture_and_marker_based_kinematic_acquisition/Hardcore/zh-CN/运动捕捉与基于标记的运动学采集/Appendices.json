{
    "hands_on_practices": [
        {
            "introduction": "基于标记点的运动捕捉技术的基础是立体摄影测量法，即从多个相机拍摄的二维图像中重建三维坐标。本练习旨在探究该重建过程精度的基本限制。通过从第一性原理推导系统参数与深度方差之间的关系 ，您将对如何设计运动捕捉系统以达到预期的精度水平获得定量的理解。",
            "id": "4192313",
            "problem": "在一个经过标定的光学运动捕捉系统中，使用两台经过校正的针孔相机观察一个单一的回归反射标记点。每台相机的光轴相互平行，且相机中心由一条水平基线分隔。世界坐标系固定在左相机中心，基线沿世界坐标系的 $X$ 轴，光轴与世界坐标系的 $Z$ 轴对齐。标记点位于深度 $Z$ 处，并分别投影到左相机和右相机的水平图像坐标 $u_L$ 和 $u_R$。相机经过校正，使得对极线是水平的，且视差 $d$ 定义为 $d = u_L - u_R$。假设采用针孔模型，并且每个相机水平图像坐标的测量噪声为微小的、无偏的、独立同分布的高斯噪声，其标准差为 $\\sigma_{\\text{pix}}$（单位：像素）。\n\n已知：\n- 基线长度 $b$（单位：米），\n- 物方相机焦距 $f_c$（单位：米），\n- 方形像素间距 $p$（单位：米/像素），因此以像素为单位的焦距为 $f_{\\text{pix}} = f_c / p$，\n- 一个工作深度 $Z$（单位：米），\n- 每个相机的水平定位噪声标准差 $\\sigma_{\\text{pix}}$（单位：像素），\n\n请从第一性原理推导重建深度方差 $\\operatorname{Var}(Z)$ 的一阶近似，将其表示为 $b$、$f_{\\text{pix}}$、$Z$ 和视差方差 $\\operatorname{Var}(d)$ 的函数。然后，利用左右相机测量的独立性，用 $\\sigma_{\\text{pix}}$ 表示 $\\operatorname{Var}(d)$。最后，使用以下符合科学实际的参数对深度方差进行数值计算：\n- $b = 1.0$ $\\text{m}$，\n- $f_c = 20 \\times 10^{-3}$ $\\text{m}$，\n- $p = 5 \\times 10^{-6}$ $\\text{m/pixel}$，\n- $Z = 5.0$ $\\text{m}$，\n- $\\sigma_{\\text{pix}} = 0.10$ $\\text{pixels}$。\n\n请以 $\\text{m}^2$ 为单位表示最终方差，并将您的答案四舍五入至三位有效数字。",
            "solution": "我们从经过校正的立体针孔几何模型开始。对于一个世界坐标为 $(X,Y,Z)$ 的点，其在左、右相机中的水平图像坐标（以传感器长度单位表示，记为 $x_L$ 和 $x_R$）满足针孔关系式\n$$\nx_L = \\frac{f X}{Z}, \\quad x_R = \\frac{f (X - b)}{Z},\n$$\n其中 $f$ 是以与 $x_L$ 和 $x_R$ 相同长度单位表示的焦距， $b$ 是相机中心之间的水平基线。以传感器长度单位表示的视差为\n$$\nd_{\\ell} = x_L - x_R = \\frac{f X}{Z} - \\frac{f (X - b)}{Z} = \\frac{f b}{Z}.\n$$\n如果像素间距为 $p$（单位：米/像素），那么像素域视差 $d$ 和像素域焦距 $f_{\\text{pix}}$ 分别为\n$$\nd = \\frac{d_{\\ell}}{p}, \\quad f_{\\text{pix}} = \\frac{f}{p}.\n$$\n因此，\n$$\nd = \\frac{f b}{p Z} = \\frac{f_{\\text{pix}} b}{Z}.\n$$\n将 $Z$ 用 $d$ 求解，得到重建公式\n$$\nZ(d) = \\frac{f_{\\text{pix}} b}{d}.\n$$\n\n为了将视差不确定性传播到深度不确定性，我们对一个标量随机变量的可微函数应用一阶（线性）不确定性传播。如果 $Z = g(d)$ 且 $d$ 的方差很小，则\n$$\n\\operatorname{Var}(Z) \\approx \\left(\\frac{\\partial g}{\\partial d}\\right)^{2} \\operatorname{Var}(d).\n$$\n这里 $g(d) = \\frac{f_{\\text{pix}} b}{d}$，所以\n$$\n\\frac{\\partial Z}{\\partial d} = - \\frac{f_{\\text{pix}} b}{d^{2}}.\n$$\n将导数用 $Z$ 本身重新表示会很有用。使用 $d = \\frac{f_{\\text{pix}} b}{Z}$，我们有\n$$\n\\frac{\\partial Z}{\\partial d} = - \\frac{f_{\\text{pix}} b}{\\left(\\frac{f_{\\text{pix}} b}{Z}\\right)^{2}} = - \\frac{Z^{2}}{f_{\\text{pix}} b}.\n$$\n因此，作为视差方差函数的深度方差为\n$$\n\\operatorname{Var}(Z) \\approx \\left(\\frac{Z^{2}}{f_{\\text{pix}} b}\\right)^{2} \\operatorname{Var}(d) = \\frac{Z^{4}}{f_{\\text{pix}}^{2} b^{2}} \\operatorname{Var}(d).\n$$\n\n接下来，将视差方差与每个相机的像素定位噪声联系起来。设测得的水平像素坐标为\n$$\nU_L = u_L^{\\ast} + \\epsilon_L, \\quad U_R = u_R^{\\ast} + \\epsilon_R,\n$$\n其中 $u_L^{\\ast}$ 和 $u_R^{\\ast}$ 是无噪声坐标，$\\epsilon_L, \\epsilon_R$ 是独立的、零均值的高斯噪声，且 $\\operatorname{Var}(\\epsilon_L) = \\operatorname{Var}(\\epsilon_R) = \\sigma_{\\text{pix}}^{2}$。测得的视差为 $D = U_L - U_R$，因此\n$$\n\\operatorname{Var}(D) = \\operatorname{Var}(U_L) + \\operatorname{Var}(U_R) - 2\\,\\operatorname{Cov}(U_L,U_R).\n$$\n独立性意味着 $\\operatorname{Cov}(U_L,U_R) = 0$，所以\n$$\n\\operatorname{Var}(d) = \\operatorname{Var}(D) = \\sigma_{\\text{pix}}^{2} + \\sigma_{\\text{pix}}^{2} = 2 \\sigma_{\\text{pix}}^{2}.\n$$\n\n综合起来，一阶深度方差为\n$$\n\\operatorname{Var}(Z) \\approx \\frac{Z^{4}}{f_{\\text{pix}}^{2} b^{2}} \\cdot 2 \\sigma_{\\text{pix}}^{2}.\n$$\n\n现在根据给定参数进行数值计算。由 $f_c$ 和 $p$ 计算 $f_{\\text{pix}}$：\n$$\nf_{\\text{pix}} = \\frac{f_c}{p} = \\frac{20 \\times 10^{-3}}{5 \\times 10^{-6}} = 4000.\n$$\n已知 $b = 1.0$，$Z = 5.0$，且 $\\sigma_{\\text{pix}} = 0.10$，我们有\n$$\n\\operatorname{Var}(d) = 2 \\sigma_{\\text{pix}}^{2} = 2 \\times (0.10)^{2} = 0.02,\n$$\n以及\n$$\n\\operatorname{Var}(Z) \\approx \\frac{(5.0)^{4}}{(4000)^{2} (1.0)^{2}} \\times 0.02.\n$$\n计算各项因子：\n$$\n(5.0)^{4} = 625, \\quad (4000)^{2} = 16000000,\n$$\n所以\n$$\n\\operatorname{Var}(Z) \\approx \\frac{625}{16000000} \\times 0.02 = 3.90625 \\times 10^{-5} \\times 0.02 = 7.8125 \\times 10^{-7}.\n$$\n因此，深度方差为\n$$\n\\operatorname{Var}(Z) \\approx 7.8125 \\times 10^{-7} \\ \\text{m}^{2}.\n$$\n四舍五入到三位有效数字，得到\n$$\n\\operatorname{Var}(Z) \\approx 7.81 \\times 10^{-7} \\ \\text{m}^{2}.\n$$",
            "answer": "$$\\boxed{7.81 \\times 10^{-7}}$$"
        },
        {
            "introduction": "理想的针孔模型是理论上的简化，而真实相机镜头会引入几何畸变，从而导致系统误差。本实践将指导您模拟未校正的径向畸变所带来的影响，这是运动捕捉中一个常见且显著的误差来源。通过量化由此产生的三维重建偏差 ，您将体会到精确相机标定对于获得可靠运动学数据的至关重要性。",
            "id": "4192373",
            "problem": "考虑一个基于标记点的运动学采集场景，其中有两个同步的透视相机观测一个单独的标记点。每个相机都遵循针孔模型，将三维世界坐标映射到二维图像坐标，并且两个相机共享相同的内参。相机的安装方式使其光轴与世界坐标系的 $z$ 轴大致对齐。设左相机的旋转矩阵为 $R_1 = I$，中心为 $C_1 = (0,0,0)$；右相机的旋转矩阵 $R_2$ 为绕世界坐标系 $y$ 轴的一个偏航旋转，角度为一个很小的 $\\phi$（单位为弧度，具体值见下文），中心为 $C_2 = (B,0,0)$，其中 $B$ 是相机间的基线长度。使用以下内参：焦距 $f = 1200$ 像素，主点 $(c_x, c_y) = (960, 540)$ 像素，以及正方形像素。图像分辨率为 $1920 \\times 1080$ 像素。使用定义在归一化图像坐标上的 Brown-Conrady 径向畸变模型。\n\n基本原理和定义：\n- 针孔投影将世界坐标中的三维点 $X = (X, Y, Z)$ 映射到归一化相机坐标，通过 $x_n = X_{\\text{cam}}/Z_{\\text{cam}}$ 和 $y_n = Y_{\\text{cam}}/Z_{\\text{cam}}$ 实现，其中 $X_{\\text{cam}} = R(X - C)$，$R$ 是相机旋转矩阵，$C$ 是相机中心。然后，像素坐标为 $u = f x_n + c_x$ 和 $v = f y_n + c_y$。\n- Brown-Conrady 径向畸变将归一化坐标修改为 $(x_d, y_d) = (x_n, y_n)\\,s(r)$，其中 $s(r) = 1 + k_1 r^2 + k_2 r^4$ 且 $r^2 = x_n^2 + y_n^2$。畸变后的像素坐标为 $u_d = f x_d + c_x$ 和 $v_d = f y_d + c_y$。\n- 运动捕捉系统通过相交两条观测光线来三角化三维位置。如果 $d_1$ 和 $d_2$ 是从相机中心 $C_1$ 和 $C_2$ 发出、穿过所测像素坐标的光线的单位方向向量（在世界坐标系中），那么直线 $L_1(s_1) = C_1 + s_1 d_1$ 和 $L_2(s_2) = C_2 + s_2 d_2$ 上的最近点可以通过求解最小二乘交点问题得到，从而得到估计点 $\\hat{X}$，该点是两直线最近点对的中点。\n\n任务：\n编写一个程序，量化在标定中忽略径向畸变对三维重建引入的偏差。对于每个测试用例，执行以下操作：\n1. 对于相机 $i \\in \\{1,2\\}$，通过对真实世界坐标点使用基于归一化坐标的针孔模型进行前向投影，然后应用系数为 $(k_1, k_2)$ 的 Brown-Conrady 径向畸变，最后使用 $(f, c_x, c_y)$ 转换为像素坐标，从而生成两个畸变后的图像测量值 $(u_{d,i}, v_{d,i})$。\n2. 假设使用理想的无畸变针孔模型，通过三角测量重建三维点 $\\hat{X}$，即将 $(u_{d,i}, v_{d,i})$ 视为未畸变的针孔测量值。根据归一化坐标 $(x_{u,i}, y_{u,i}) = \\left((u_{d,i} - c_x)/f, (v_{d,i} - c_y)/f\\right)$ 在每个相机的局部坐标系中构建单位光线，并使用 $R_i^\\top$ 将它们映射到世界坐标。通过计算最近点对的中点来求光线的交点。\n3. 计算两个误差度量：\n   - 边缘区域的重投影误差：对于每个相机，使用理想针孔模型（无畸变）重投影 $\\hat{X}$，得到 $(u_{\\text{pin},i}, v_{\\text{pin},i})$。以像素为单位，测量欧几里得重投影残差 $e_i = \\sqrt{(u_{d,i} - u_{\\text{pin},i})^2 + (v_{d,i} - v_{\\text{pin},i})^2}$。找出距离主点径向距离 $r_{\\text{px},i} = \\sqrt{(u_{d,i} - c_x)^2 + (v_{d,i} - c_y)^2}$ 较大的相机，并报告该相机对应的重投影误差 $e_{\\text{peri}}$（单位为像素）。\n   - 深度偏差：计算深度的绝对误差 $\\Delta Z = | \\hat{Z} - Z_{\\text{true}} |$，单位为米，其中 $\\hat{Z}$ 是重建点的 $z$ 坐标，$Z_{\\text{true}}$ 是真实深度。\n\n所有用例均使用以下固定参数：\n- 基线 $B = 0.25$ 米。\n- 偏航角 $\\phi = 3\\pi/180$ 弧度。\n- 焦距 $f = 1200$ 像素。\n- 主点 $(c_x, c_y) = (960, 540)$ 像素。\n\n测试套件：\n每个测试用例是一个元组 $(X, Y, Z, k_1, k_2)$，其中坐标单位为米，畸变系数无量纲，$Z$ 是真实深度。四个用例如下：\n- 用例 1（基线，零畸变，中心点）：$(0.0, 0.0, 3.0, 0.0, 0.0)$。\n- 用例 2（中等畸变，中心点）：$(0.0, 0.0, 3.0, -0.2, 0.05)$。\n- 用例 3（中等畸变，水平边缘点）：$(2.1, 0.0, 3.0, -0.2, 0.05)$。\n- 用例 4（强畸变，水平和垂直组合边缘点）：$(2.1, 1.2, 3.0, -0.35, 0.10)$。\n\n角度单位说明：所有角度均以弧度为单位。\n\n输出规格：\n对于每个测试用例，返回一个双元素列表 $[e_{\\text{peri}}, \\Delta Z]$，其中 $e_{\\text{peri}}$ 的单位是像素，$\\Delta Z$ 的单位是米。您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，内容是按测试套件顺序排列的结果，每个用例的结果本身也用方括号括起来。例如，输出应类似于 $[[e_1,\\Delta Z_1],[e_2,\\Delta Z_2],[e_3,\\Delta Z_3],[e_4,\\Delta Z_4]]$。",
            "solution": "解决方案始于针孔相机模型，该模型提供了从世界坐标到归一化图像坐标的映射，然后通过乘以焦距和加上主点来映射到像素坐标。设世界坐标系中的一个三维点表示为 $X = (X, Y, Z)^\\top$。对于旋转矩阵为 $R_i$、中心为 $C_i$ 的相机 $i$，其在相机坐标系下的坐标由下式给出：\n$$\nX_{\\text{cam}, i} = R_i \\left( X - C_i \\right).\n$$\n定义 $X_{\\text{cam}, i} = (X_i, Y_i, Z_i)$，则归一化的无畸变针孔坐标为：\n$$\nx_{n,i} = \\frac{X_i}{Z_i}, \\quad y_{n,i} = \\frac{Y_i}{Z_i}.\n$$\n在归一化坐标上的 Brown-Conrady 径向畸变由下式给出：\n$$\nr_i^2 = x_{n,i}^2 + y_{n,i}^2, \\quad s(r_i) = 1 + k_1 r_i^2 + k_2 r_i^4,\n$$\n畸变后的归一化坐标为：\n$$\nx_{d,i} = x_{n,i} \\, s(r_i), \\quad y_{d,i} = y_{n,i} \\, s(r_i).\n$$\n使用焦距 $f$ 和主点 $(c_x, c_y)$ 转换为像素坐标，可得：\n$$\nu_{d,i} = f \\, x_{d,i} + c_x, \\quad v_{d,i} = f \\, y_{d,i} + c_y.\n$$\n这些 $(u_{d,i}, v_{d,i})$ 是存在畸变时由前向模型生成的合成测量值。\n\n重建是在无畸变的错误假设下进行的。因此，我们通过仅反转针孔映射来形成无畸变的归一化坐标：\n$$\nx_{u,i} = \\frac{u_{d,i} - c_x}{f}, \\quad y_{u,i} = \\frac{v_{d,i} - c_y}{f}.\n$$\n在相机坐标系中，指向该点的光线方向与以下向量成比例：\n$$\n\\tilde{d}_{\\text{cam}, i} = \\begin{bmatrix} x_{u,i} \\\\ y_{u,i} \\\\ 1 \\end{bmatrix},\n$$\n我们将其归一化为单位长度：\n$$\nd_{\\text{cam}, i} = \\frac{\\tilde{d}_{\\text{cam}, i}}{\\|\\tilde{d}_{\\text{cam}, i}\\|_2}.\n$$\n为在世界坐标系中表示光线，我们应用逆旋转：\n$$\nd_i = R_i^\\top \\, d_{\\text{cam}, i}.\n$$\n因此，世界坐标系中的光线为：\n$$\nL_1(s_1) = C_1 + s_1 d_1, \\quad L_2(s_2) = C_2 + s_2 d_2.\n$$\n这两条异面直线上的最近点可通过求解标准的最小二乘法直线-直线相交问题得到。定义：\n$$\nw_0 = C_1 - C_2, \\quad a = d_1^\\top d_1, \\quad b = d_1^\\top d_2, \\quad c = d_2^\\top d_2, \\quad d = d_1^\\top w_0, \\quad e = d_2^\\top w_0.\n$$\n假设两条直线不完全平行（因此 $a c - b^2 \\neq 0$），最优参数为：\n$$\ns_1^\\star = \\frac{b e - c d}{a c - b^2}, \\quad s_2^\\star = \\frac{a e - b d}{a c - b^2}.\n$$\n重建的三维位置取为两个最近点的中点：\n$$\n\\hat{X} = \\frac{1}{2}\\left( \\left(C_1 + s_1^\\star d_1\\right) + \\left(C_2 + s_2^\\star d_2\\right) \\right),\n$$\n其深度 $\\hat{Z}$ 等于 $\\hat{X}$ 的 $z$ 分量。\n\n为了量化建模偏差，我们计算两个度量指标。\n\n首先，边缘重投影误差。我们使用理想针孔映射（无畸变）将 $\\hat{X}$ 重投影到每个相机中：\n$$\n\\hat{X}_{\\text{cam}, i} = R_i \\left( \\hat{X} - C_i \\right), \\quad \\hat{x}_{n,i} = \\frac{\\hat{X}_{\\text{cam}, i,x}}{\\hat{X}_{\\text{cam}, i,z}}, \\quad \\hat{y}_{n,i} = \\frac{\\hat{X}_{\\text{cam}, i,y}}{\\hat{X}_{\\text{cam}, i,z}},\n$$\n然后得到：\n$$\nu_{\\text{pin}, i} = f \\, \\hat{x}_{n,i} + c_x, \\quad v_{\\text{pin}, i} = f \\, \\hat{y}_{n,i} + c_y.\n$$\n相机 $i$ 的以像素为单位的残差为：\n$$\ne_i = \\sqrt{(u_{d,i} - u_{\\text{pin}, i})^2 + (v_{d,i} - v_{\\text{pin}, i})^2}.\n$$\n我们通过较大的径向像素距离来确定哪个是更边缘的视图：\n$$\nr_{\\text{px}, i} = \\sqrt{(u_{d,i} - c_x)^2 + (v_{d,i} - c_y)^2},\n$$\n并报告外围视图的重投影误差 $e_{\\text{peri}}$，其值为径向像素距离 $r_{\\text{px},i}$ 较大的相机的误差 $e_i$。\n\n其次，深度偏差是重建深度与真实深度之间的绝对差：\n$$\n\\Delta Z = \\left| \\hat{Z} - Z_{\\text{true}} \\right|.\n$$\n\n科学原理：忽略畸变会将弯曲的光线视为通过理想针孔模型的直线，这会扰动用于三角测量的方向向量。由于畸变尺度 $s(r)$ 随着 $r$ 的增大而更多地偏离 1，这种扰动随径向距离 $r$ 的增大而增大。这导致光线相交时产生系统性偏差，从而引起深度误差，该误差取决于基线 $B$、通过 $R_i$ 决定的观测几何以及畸变函数的非线性。在理想针孔模型下的重投影残差是模型与畸变测量值之间不匹配程度的直接度量，预计在中心（$r \\approx 0$）处可忽略不计，而在边缘（大的 $r$）处则较大。\n\n程序中实现的算法步骤：\n1. 对于每个测试用例 $(X, Y, Z, k_1, k_2)$，使用基于归一化坐标的针孔投影，然后应用 Brown-Conrady 径向畸变，再转换为像素，计算两个相机的畸变后像素测量值。\n2. 从畸变像素中形成无畸变的归一化坐标，如同不存在畸变一样。在相机坐标系中构建单位光线方向，并将其旋转到世界坐标系。\n3. 使用最小二乘交点公式求解两条光线上的最近点，以获得 $\\hat{X}$ 及其深度 $\\hat{Z}$。\n4. 在理想针孔模型下计算每个相机的重投影残差，并选择距主点径向像素距离较大的相机的残差作为 $e_{\\text{peri}}$。\n5. 计算深度偏差 $\\Delta Z$，即 $\\hat{Z}$ 和 $Z$ 之间的绝对差。\n6. 对于每个测试用例，按指定格式输出数据对 $[e_{\\text{peri}}, \\Delta Z]$。\n\n所有角度均以弧度处理；我们将偏航角设置为 $\\phi = 3\\pi/180$。基线 $B$ 为 $0.25$ 米。畸变系数是无量纲的，应用于归一化坐标，确保了边缘和中心用例的科学真实性。测试套件包括一个零畸变边界情况、中心点中等畸变、水平边缘点中等畸变，以及水平和垂直组合边缘点强畸变，覆盖了因忽略畸变而导致的重建偏差的关键方面。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotation_y(phi):\n    \"\"\"Rotation matrix about the world y-axis by angle phi (radians).\"\"\"\n    c = np.cos(phi)\n    s = np.sin(phi)\n    return np.array([[ c, 0.0,  s],\n                     [0.0, 1.0, 0.0],\n                     [-s, 0.0,  c]], dtype=float)\n\ndef project_with_radial_distortion(X_world, R, C, f, cx, cy, k1, k2):\n    \"\"\"\n    Project X_world into pixel coordinates using pinhole model on normalized\n    coordinates followed by Brown-Conrady radial distortion (k1, k2).\n    \"\"\"\n    X_cam = R @ (X_world - C)\n    Xc, Yc, Zc = X_cam\n    x_n = Xc / Zc\n    y_n = Yc / Zc\n    r2 = x_n * x_n + y_n * y_n\n    s = 1.0 + k1 * r2 + k2 * (r2 * r2)\n    x_d = x_n * s\n    y_d = y_n * s\n    u = f * x_d + cx\n    v = f * y_d + cy\n    return np.array([u, v], dtype=float)\n\ndef ray_from_pixel_no_distortion(u, v, f, cx, cy, R, C):\n    \"\"\"\n    Construct unit ray direction in world coordinates assuming an ideal pinhole (no distortion).\n    \"\"\"\n    x_u = (u - cx) / f\n    y_u = (v - cy) / f\n    d_cam = np.array([x_u, y_u, 1.0], dtype=float)\n    d_cam /= np.linalg.norm(d_cam)\n    # Map direction from camera to world by inverse rotation\n    d_world = R.T @ d_cam\n    # Ray originates at camera center C\n    return d_world\n\ndef triangulate_midpoint(C1, d1, C2, d2):\n    \"\"\"\n    Triangulate via closest-point midpoint of two skew rays:\n    L1(s1) = C1 + s1 d1, L2(s2) = C2 + s2 d2.\n    \"\"\"\n    w0 = C1 - C2\n    a = np.dot(d1, d1)\n    b = np.dot(d1, d2)\n    c = np.dot(d2, d2)\n    d = np.dot(d1, w0)\n    e = np.dot(d2, w0)\n    denom = a * c - b * b\n    if np.abs(denom) < 1e-12:\n        # Rays are nearly parallel; fall back to average of projecting from one ray\n        s1 = -d / a if np.abs(a) > 1e-12 else 0.0\n        p1 = C1 + s1 * d1\n        # Project p1 onto second ray\n        # s2 = argmin ||(C2 + s2 d2) - p1||^2 => s2 = d2·(p1 - C2)\n        s2 = np.dot(d2, (p1 - C2))\n        p2 = C2 + s2 * d2\n        return 0.5 * (p1 + p2)\n    s1 = (b * e - c * d) / denom\n    s2 = (a * e - b * d) / denom\n    p1 = C1 + s1 * d1\n    p2 = C2 + s2 * d2\n    return 0.5 * (p1 + p2)\n\ndef pinhole_reproject(X_world, R, C, f, cx, cy):\n    \"\"\"Reproject a 3D point using an ideal pinhole model (no distortion).\"\"\"\n    X_cam = R @ (X_world - C)\n    Xc, Yc, Zc = X_cam\n    x_n = Xc / Zc\n    y_n = Yc / Zc\n    u = f * x_n + cx\n    v = f * y_n + cy\n    return np.array([u, v], dtype=float)\n\ndef solve():\n    # Intrinsics\n    f = 1200.0\n    cx, cy = 960.0, 540.0\n    # Extrinsics\n    B = 0.25  # meters\n    phi = 3.0 * np.pi / 180.0  # radians\n    R1 = np.eye(3)\n    C1 = np.array([0.0, 0.0, 0.0], dtype=float)\n    R2 = rotation_y(phi)\n    C2 = np.array([B, 0.0, 0.0], dtype=float)\n\n    # Define the test cases from the problem statement.\n    # Each case: (X, Y, Z, k1, k2)\n    test_cases = [\n        (0.0, 0.0, 3.0, 0.0, 0.0),           # Case 1: baseline, zero distortion, centered\n        (0.0, 0.0, 3.0, -0.2, 0.05),         # Case 2: moderate distortion, centered\n        (2.1, 0.0, 3.0, -0.2, 0.05),         # Case 3: moderate distortion, horizontal periphery\n        (2.1, 1.2, 3.0, -0.35, 0.10),        # Case 4: strong distortion, combined periphery\n    ]\n\n    results = []\n    for X, Y, Z, k1, k2 in test_cases:\n        X_world_true = np.array([X, Y, Z], dtype=float)\n\n        # Forward projection with distortion for both cameras\n        uvd1 = project_with_radial_distortion(X_world_true, R1, C1, f, cx, cy, k1, k2)\n        uvd2 = project_with_radial_distortion(X_world_true, R2, C2, f, cx, cy, k1, k2)\n\n        # Construct rays assuming no distortion\n        d1 = ray_from_pixel_no_distortion(uvd1[0], uvd1[1], f, cx, cy, R1, C1)\n        d2 = ray_from_pixel_no_distortion(uvd2[0], uvd2[1], f, cx, cy, R2, C2)\n\n        # Triangulate midpoint\n        X_hat = triangulate_midpoint(C1, d1, C2, d2)\n        Z_hat = X_hat[2]\n\n        # Reproject using ideal pinhole\n        upin1 = pinhole_reproject(X_hat, R1, C1, f, cx, cy)\n        upin2 = pinhole_reproject(X_hat, R2, C2, f, cx, cy)\n\n        # Reprojection residuals per camera (compare to distorted observations)\n        e1 = np.linalg.norm(uvd1 - upin1)\n        e2 = np.linalg.norm(uvd2 - upin2)\n\n        # Peripheral camera selection by larger radial pixel distance from principal point\n        rpx1 = np.linalg.norm(uvd1 - np.array([cx, cy], dtype=float))\n        rpx2 = np.linalg.norm(uvd2 - np.array([cx, cy], dtype=float))\n        e_peri = e1 if rpx1 >= rpx2 else e2\n\n        # Depth bias\n        dZ = abs(Z_hat - Z)\n\n        # Append result as [reproj_error_px, depth_error_m]\n        results.append([float(e_peri), float(dZ)])\n\n    # Final print statement in the exact required format.\n    # Single line output: list of per-case [e_peri, dZ]\n    print(f\"[{','.join('[' + ','.join(map(str, pair)) + ']' for pair in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这项练习关注生物力学解释的一个关键方面：敏感性分析。解剖学标记点的定位误差，无论是源于软组织运动伪影还是触诊的可变性，都会传播到由这些标记点计算得出的生物力学变量中。您将研究用于定义关节轴的标记点微小错位如何影响其方向 ，从而培养评估运动学研究结果稳健性的核心技能。",
            "id": "4192315",
            "problem": "您将实现一个完整的、可运行的程序，该程序用于量化解剖学标记点的错位如何改变基于标记点运动学定义的关节轴。背景是三维运动捕捉中由内侧和外侧上髁标记点定义的膝关节屈伸轴。从三维欧几里得空间中向量的基本定义以及通过点积定义单位向量之间的夹角出发。使用第一性原理推导出一个灵敏度分析，该分析将微小的标记点扰动映射到单位轴向量的微小角度偏差。\n\n定义与假设：\n- 关节轴由两个解剖学标记点定义：外侧上髁位置 $\\mathbf{L}\\in\\mathbb{R}^3$ 和内侧上髁位置 $\\mathbf{M}\\in\\mathbb{R}^3$，两者均在全局笛卡尔坐标系中以米为单位表示。\n- 基准轴方向为 $\\mathbf{u}=\\dfrac{\\mathbf{L}-\\mathbf{M}}{\\|\\mathbf{L}-\\mathbf{M}\\|}$，其中 $\\|\\cdot\\|$ 是欧几里得范数。\n- 标记点的错位被建模为微小的附加扰动 $\\delta\\mathbf{L}$ 和 $\\delta\\mathbf{M}$（单位为米），通过相同的定义从 $\\mathbf{L}+\\delta\\mathbf{L}$ 和 $\\mathbf{M}+\\delta\\mathbf{M}$ 计算出受扰动的轴方向 $\\tilde{\\mathbf{u}}$。\n- 基准轴与受扰动轴之间的角度偏差 $\\theta$ 定义为 $\\theta=\\arccos\\!\\left(\\mathbf{u}^\\top \\tilde{\\mathbf{u}}\\right)$（单位为弧度）。在报告时，您必须将角度量表示为度，并保留六位小数。\n- 对单位轴方向关于 $\\mathbf{L}$ 和 $\\mathbf{M}$ 的每个坐标进行一阶灵敏度分析。将三个标准坐标方向视为 $\\mathbb{R}^3$ 中的标准正交基向量。\n\n每个测试用例的任务：\n1. 根据提供的 $\\mathbf{L}$ 和 $\\mathbf{M}$ 计算基准单位轴 $\\mathbf{u}$。\n2. 当每个标记点扰动满足 $\\|\\delta\\mathbf{L}\\|\\le \\varepsilon$ 和 $\\|\\delta\\mathbf{M}\\|\\le \\varepsilon$（其中 $\\varepsilon$ 以米为单位给出）时，计算各向同性标记点错位的最坏情况小角度边界（以度为单位）。使用第一性原理和线性化方法，得到一个依赖于 $\\varepsilon$ 和基准分离距离 $\\|\\mathbf{L}-\\mathbf{M}\\|$ 的边界。将该边界表示为度，并四舍五入到六位小数。\n3. 计算轴角度相对于每个标记点沿 $x$、$y$ 和 $z$ 方向的无穷小位移的坐标级一阶灵敏度（单位为弧度/米）。根据这些值，报告所有六个坐标 $\\{L_x,L_y,L_z,M_x,M_y,M_z\\}$ 中的最大和最小灵敏度大小，每个值都四舍五入到六位小数。\n4. 使用精确的点积定义，计算对于给定的特定扰动 $\\delta\\mathbf{L}$ 和 $\\delta\\mathbf{M}$，$\\mathbf{u}$ 与受扰动轴 $\\tilde{\\mathbf{u}}$ 之间的实际角度偏差（以度为单位）。四舍五入到六位小数。\n\n角度单位要求：所有角度输出必须以度为单位，四舍五入到六位小数。灵敏度必须以弧度/米为单位，四舍五入到六位小数。所有长度单位均为米。\n\n测试套件：\n将以下三个测试用例未经更改地提供给您的程序。每个案例都是一个元组 $(\\mathbf{L},\\mathbf{M},\\varepsilon,\\delta\\mathbf{L},\\delta\\mathbf{M})$，其中向量以米为单位：\n- 案例 $1$（轴几乎与全局 $x$ 轴对齐）：\n  - $\\mathbf{L}=[\\,0.08,\\,0.0,\\,0.0\\,]$\n  - $\\mathbf{M}=[\\,0.0,\\,0.0,\\,0.0\\,]$\n  - $\\varepsilon=0.005$\n  - $\\delta\\mathbf{L}=[\\,0.002,\\,-0.001,\\,0.0005\\,]$\n  - $\\delta\\mathbf{M}=[\\,0.0005,\\,0.0015,\\,-0.0005\\,]$\n- 案例 $2$（轴在 $xy$ 平面中大约成 $45^\\circ$ 角）：\n  - $\\mathbf{L}=[\\,0.0565685424949238,\\,0.0565685424949238,\\,0.0\\,]$\n  - $\\mathbf{M}=[\\,0.0,\\,0.0,\\,0.0\\,]$\n  - $\\varepsilon=0.005$\n  - $\\delta\\mathbf{L}=[\\,0.003,\\,-0.002,\\,0.001\\,]$\n  - $\\delta\\mathbf{M}=[\\,-0.001,\\,0.002,\\,-0.002\\,]$\n- 案例 $3$（分离距离较短，在 $xz$ 平面内倾斜且有偏移）：\n  - $\\mathbf{L}=[\\,0.050,\\,-0.010,\\,0.025\\,]$\n  - $\\mathbf{M}=[\\,0.020,\\,-0.010,\\,0.015\\,]$\n  - $\\varepsilon=0.005$\n  - $\\delta\\mathbf{L}=[\\,-0.0015,\\,0.001,\\,-0.001\\,]$\n  - $\\delta\\mathbf{M}=[\\,0.001,\\,-0.001,\\,0.0015\\,]$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含三个测试用例的结果，结果为一个逗号分隔的列表，并用方括号括起来。每个测试用例贡献一个包含四个浮点数的内部列表，顺序如下：$[\\text{worst\\_case\\_deg},\\text{max\\_sensitivity\\_rad\\_per\\_m},\\text{min\\_sensitivity\\_rad\\_per\\_m},\\text{actual\\_deg}]$。例如，整体格式必须是：\n$[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3]]$\n每个值都四舍五入到六位小数。",
            "solution": "该问题是有效的，因为它在科学上基于矢量微积分和生物力学建模，问题提出得当，提供了所有必要的数据，并且其定义是客观的。我们将从第一性原理出发，给出一个完整的解法。\n\n设外侧和内侧上髁标记点的位置分别为 $\\mathbf{L} \\in \\mathbb{R}^3$ 和 $\\mathbf{M} \\in \\mathbb{R}^3$。连接这些标记点的向量定义为 $\\mathbf{v} = \\mathbf{L} - \\mathbf{M}$。它们之间的标量距离是该向量的欧几里得范数，$d = \\|\\mathbf{v}\\| = \\|\\mathbf{L} - \\mathbf{M}\\|$。基准单位轴向量 $\\mathbf{u}$ 随之定义为 $\\mathbf{v}$ 的归一化形式：\n$$ \\mathbf{u} = \\frac{\\mathbf{v}}{d} = \\frac{\\mathbf{L} - \\mathbf{M}}{\\|\\mathbf{L} - \\mathbf{M}\\|} $$\n\n标记点受到微小的附加扰动 $\\delta\\mathbf{L}$ 和 $\\delta\\mathbf{M}$，导致受扰动的位置为 $\\tilde{\\mathbf{L}} = \\mathbf{L} + \\delta\\mathbf{L}$ 和 $\\tilde{\\mathbf{M}} = \\mathbf{M} + \\delta\\mathbf{M}$。受扰动的向量 $\\tilde{\\mathbf{v}}$ 及其单位向量 $\\tilde{\\mathbf{u}}$ 为：\n$$ \\tilde{\\mathbf{v}} = \\tilde{\\mathbf{L}} - \\tilde{\\mathbf{M}} = (\\mathbf{L} - \\mathbf{M}) + (\\delta\\mathbf{L} - \\delta\\mathbf{M}) = \\mathbf{v} + \\delta\\mathbf{v} $$\n$$ \\tilde{\\mathbf{u}} = \\frac{\\tilde{\\mathbf{v}}}{\\|\\tilde{\\mathbf{v}}\\|} $$\n其中我们定义复合扰动向量 $\\delta\\mathbf{v} = \\delta\\mathbf{L} - \\delta\\mathbf{M}$。基准轴 $\\mathbf{u}$ 与受扰动轴 $\\tilde{\\mathbf{u}}$ 之间的角度偏差由 $\\theta = \\arccos(\\mathbf{u}^\\top \\tilde{\\mathbf{u}})$ 给出。\n\n### 任务 1：基准单位轴 $\\mathbf{u}$\n这是一个使用公式 $\\mathbf{u} = (\\mathbf{L} - \\mathbf{M}) / \\|\\mathbf{L} - \\mathbf{M}\\|$ 的直接计算。该值是后续所有计算的基础。\n\n### 任务 2：最坏情况小角度边界\n对于小角度偏差，角度 $\\theta$（以弧度为单位）可以很好地用单位向量变化的幅度来近似，即 $\\theta \\approx \\|\\tilde{\\mathbf{u}} - \\mathbf{u}\\|$。我们对 $\\mathbf{u}(\\mathbf{v}) = \\mathbf{v}/\\|\\mathbf{v}\\|$ 在 $\\mathbf{v}$ 周围进行一阶泰勒展开，以求得一阶变化量 $\\delta\\mathbf{u} = \\tilde{\\mathbf{u}} - \\mathbf{u}$。\n\n$\\mathbf{u}$ 关于 $\\mathbf{v}$ 的雅可比矩阵是：\n$$ \\frac{\\partial \\mathbf{u}}{\\partial \\mathbf{v}^\\top} = \\frac{\\partial}{\\partial \\mathbf{v}^\\top} \\left( \\frac{\\mathbf{v}}{\\|\\mathbf{v}\\|} \\right) = \\frac{1}{\\|\\mathbf{v}\\|} \\frac{\\partial \\mathbf{v}}{\\partial \\mathbf{v}^\\top} - \\frac{\\mathbf{v}}{\\|\\mathbf{v}\\|^2} \\frac{\\partial \\|\\mathbf{v}\\|}{\\partial \\mathbf{v}^\\top} = \\frac{1}{d} I - \\frac{\\mathbf{v}}{d^2} \\frac{\\mathbf{v}^\\top}{d} = \\frac{1}{d} (I - \\mathbf{u}\\mathbf{u}^\\top) $$\n其中 $I$ 是 $3 \\times 3$ 单位矩阵。因此，一阶变化量 $\\delta\\mathbf{u}$ 是：\n$$ \\delta\\mathbf{u} \\approx \\frac{\\partial \\mathbf{u}}{\\partial \\mathbf{v}^\\top} \\delta\\mathbf{v} = \\frac{1}{d} (I - \\mathbf{u}\\mathbf{u}^\\top) \\delta\\mathbf{v} = \\frac{1}{d} (\\delta\\mathbf{v} - (\\mathbf{u}^\\top \\delta\\mathbf{v})\\mathbf{u}) $$\n向量 $\\delta\\mathbf{u}$ 表示 $\\delta\\mathbf{v}/d$ 中与 $\\mathbf{u}$ 正交的分量。对于小角度，角度误差 $\\theta$ 约等于该向量的幅度：\n$$ \\theta \\approx \\|\\delta\\mathbf{u}\\| = \\frac{1}{d} \\| \\delta\\mathbf{v} - (\\mathbf{u}^\\top \\delta\\mathbf{v})\\mathbf{u} \\| = \\frac{\\|\\delta\\mathbf{v}_{\\perp}\\|}{d} $$\n其中 $\\delta\\mathbf{v}_{\\perp}$ 是 $\\delta\\mathbf{v}$ 与 $\\mathbf{u}$ 正交的分量。\n\n为了找到最坏情况边界，我们必须在约束条件 $\\|\\delta\\mathbf{L}\\| \\le \\varepsilon$ 和 $\\|\\delta\\mathbf{M}\\| \\le \\varepsilon$ 下最大化 $\\theta$。$\\delta\\mathbf{v}$ 的幅度受三角不等式约束：\n$$ \\|\\delta\\mathbf{v}\\| = \\|\\delta\\mathbf{L} - \\delta\\mathbf{M}\\| \\le \\|\\delta\\mathbf{L}\\| + \\|\\delta\\mathbf{M}\\| \\le \\varepsilon + \\varepsilon = 2\\varepsilon $$\n正交分量的幅度 $\\|\\delta\\mathbf{v}_{\\perp}\\|$ 在向量 $\\delta\\mathbf{v}$ 本身的幅度最大且方向与 $\\mathbf{u}$ 正交时达到最大值。$\\|\\delta\\mathbf{v}\\|$ 的最大幅度为 $2\\varepsilon$，在 $\\delta\\mathbf{L}$ 和 $\\delta\\mathbf{M}$ 反向平行时达到（例如，对于某个单位向量 $\\mathbf{w}$，有 $\\delta\\mathbf{L} = \\varepsilon\\mathbf{w}$ 和 $\\delta\\mathbf{M} = -\\varepsilon\\mathbf{w}$）。如果我们选择 $\\mathbf{w}$ 与 $\\mathbf{u}$ 正交，则 $\\delta\\mathbf{v} = 2\\varepsilon\\mathbf{w}$ 完全与 $\\mathbf{u}$ 正交，从而使 $\\|\\delta\\mathbf{v}_{\\perp}\\|$ 在 $2\\varepsilon$ 处最大化。\n因此，最坏情况的角度边界为：\n$$ \\theta_{\\text{bound}} = \\frac{2\\varepsilon}{d} = \\frac{2\\varepsilon}{\\|\\mathbf{L} - \\mathbf{M}\\|} $$\n这个结果以弧度为单位，报告时必须转换为度。\n\n### 任务 3：坐标级一阶灵敏度\n我们寻求轴角度相对于六个坐标 $\\{L_x, L_y, L_z, M_x, M_y, M_z\\}$ 中每一个的无穷小位移的灵敏度。相对于某个坐标（例如 $L_x$）的灵敏度是角度 $\\theta$ 关于 $L_x$ 变化的速率。对于沿 $x$ 轴的无穷小位移 $\\delta L_x$，有 $\\delta\\mathbf{L} = [\\delta L_x, 0, 0]^\\top = \\delta L_x \\mathbf{e}_x$ 且 $\\delta\\mathbf{M} = \\mathbf{0}$，得出 $\\delta\\mathbf{v} = \\delta L_x \\mathbf{e}_x$。\n\n由此产生的无穷小角度变化 $\\delta\\theta$ 为：\n$$ \\delta\\theta \\approx \\|\\delta\\mathbf{u}\\| = \\left\\| \\frac{1}{d} (I - \\mathbf{u}\\mathbf{u}^\\top)(\\delta L_x \\mathbf{e}_x) \\right\\| = \\frac{|\\delta L_x|}{d} \\|\\mathbf{e}_x - (\\mathbf{u}^\\top\\mathbf{e}_x)\\mathbf{u}\\| $$\n范数内的项是基向量 $\\mathbf{e}_x$ 与 $\\mathbf{u}$ 正交的分量。其幅度为 $\\sqrt{\\|\\mathbf{e}_x\\|^2 - (\\mathbf{u}^\\top\\mathbf{e}_x)^2} = \\sqrt{1 - u_x^2}$，因为 $\\mathbf{e}_x$ 和 $\\mathbf{u}$ 都是单位向量。灵敏度 $S_{L_x}$ 是比率 $\\delta\\theta / |\\delta L_x|$ 在 $\\delta L_x \\to 0$ 时的极限：\n$$ S_{L_x} = \\frac{\\sqrt{1 - u_x^2}}{d} $$\n通过对称性，$\\mathbf{L}$ 的 $y$ 和 $z$ 坐标的灵敏度为：\n$$ S_{L_y} = \\frac{\\sqrt{1 - u_y^2}}{d}, \\quad S_{L_z} = \\frac{\\sqrt{1 - u_z^2}}{d} $$\n对于 $\\mathbf{M}$ 的某个坐标（例如 $M_x$）的扰动，我们有 $\\delta\\mathbf{M} = [\\delta M_x, 0, 0]^\\top$ 且 $\\delta\\mathbf{L} = \\mathbf{0}$，所以 $\\delta\\mathbf{v} = -\\delta M_x \\mathbf{e}_x$。由于 $\\delta\\theta$ 的幅度计算依赖于 $\\|\\delta\\mathbf{v}\\|$，负号不影响结果。因此，相对于 $\\mathbf{M}$ 坐标的灵敏度与 $\\mathbf{L}$ 的相同：\n$$ S_{M_x} = S_{L_x}, \\quad S_{M_y} = S_{L_y}, \\quad S_{M_z} = S_{L_z} $$\n必须从集合 $\\{S_{L_x}, S_{L_y}, S_{L_z}\\}$ 中找出最大和最小灵敏度大小。\n\n### 任务 4：实际角度偏差\n此任务需要不使用近似的直接计算。给定特定的扰动 $\\delta\\mathbf{L}$ 和 $\\delta\\mathbf{M}$：\n1.  计算受扰动的标记点位置：$\\tilde{\\mathbf{L}} = \\mathbf{L} + \\delta\\mathbf{L}$ 和 $\\tilde{\\mathbf{M}} = \\mathbf{M} + \\delta\\mathbf{M}$。\n2.  计算受扰动的轴向量：$\\tilde{\\mathbf{v}} = \\tilde{\\mathbf{L}} - \\tilde{\\mathbf{M}}$。\n3.  归一化以找到受扰动的单位轴：$\\tilde{\\mathbf{u}} = \\tilde{\\mathbf{v}} / \\|\\tilde{\\mathbf{v}}\\|$。\n4.  计算基准轴 $\\mathbf{u}$ 和受扰动轴 $\\tilde{\\mathbf{u}}$ 之间的点积。为防止数值误差，应将此值裁剪到有效范围 $[-1, 1]$ 内。\n5.  计算弧度角：$\\theta = \\arccos(\\mathbf{u}^\\top\\tilde{\\mathbf{u}})$。\n6.  将最终角度转换为度。\n\n实现将对每个测试用例遵循这些推导出的公式。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the biomechanical sensitivity analysis problem for three test cases.\n    \"\"\"\n    \n    # Test cases: tuple of (L, M, eps, dL, dM)\n    # Vectors are in meters.\n    test_cases = [\n        # Case 1\n        (\n            np.array([0.08, 0.0, 0.0]),\n            np.array([0.0, 0.0, 0.0]),\n            0.005,\n            np.array([0.002, -0.001, 0.0005]),\n            np.array([0.0005, 0.0015, -0.0005])\n        ),\n        # Case 2\n        (\n            np.array([0.0565685424949238, 0.0565685424949238, 0.0]),\n            np.array([0.0, 0.0, 0.0]),\n            0.005,\n            np.array([0.003, -0.002, 0.001]),\n            np.array([-0.001, 0.002, -0.002])\n        ),\n        # Case 3\n        (\n            np.array([0.050, -0.010, 0.025]),\n            np.array([0.020, -0.010, 0.015]),\n            0.005,\n            np.array([-0.0015, 0.001, -0.001]),\n            np.array([0.001, -0.001, 0.0015])\n        )\n    ]\n\n    all_results_str = []\n\n    for L, M, eps, dL, dM in test_cases:\n        # Task 1: Compute baseline unit axis u\n        v = L - M\n        d = np.linalg.norm(v)\n        \n        # Handle case where L=M, though not in test data.\n        if d == 0:\n            # Axis is undefined, can't proceed. In a real scenario, this would raise an error.\n            # For this problem, we assume d > 0 based on test cases.\n            u = np.array([0.0, 0.0, 0.0])\n        else:\n            u = v / d\n\n        # Task 2: Compute worst-case small-angle bound\n        # Formula: theta_bound = 2 * eps / d\n        if d > 0:\n            worst_case_rad = (2 * eps) / d\n        else:\n            worst_case_rad = np.inf\n        worst_case_deg = np.rad2deg(worst_case_rad)\n\n        # Task 3: Compute coordinate-wise first-order sensitivities\n        if d > 0:\n            # Sensitivities are sqrt(1-u_i^2)/d for i=x,y,z\n            sensitivities = [np.sqrt(1 - u_comp**2) / d for u_comp in u]\n            max_sensitivity_rad_per_m = max(sensitivities)\n            min_sensitivity_rad_per_m = min(sensitivities)\n        else:\n            max_sensitivity_rad_per_m = np.inf\n            min_sensitivity_rad_per_m = np.inf\n\n        # Task 4: Compute actual angular deviation\n        L_tilde = L + dL\n        M_tilde = M + dM\n        v_tilde = L_tilde - M_tilde\n        d_tilde = np.linalg.norm(v_tilde)\n\n        if d > 0 and d_tilde > 0:\n            u_tilde = v_tilde / d_tilde\n            # Dot product can be slightly outside [-1, 1] due to floating point error\n            dot_product = np.clip(np.dot(u, u_tilde), -1.0, 1.0)\n            actual_rad = np.arccos(dot_product)\n            actual_deg = np.rad2deg(actual_rad)\n        else:\n            actual_deg = 0.0 # Or undefined; 0 if no change.\n\n        # Store results for this case\n        case_results = [\n            worst_case_deg,\n            max_sensitivity_rad_per_m,\n            min_sensitivity_rad_per_m,\n            actual_deg\n        ]\n        \n        # Format the sublist as a string [val1,val2,val3,val4]\n        sub_list_str = f\"[{','.join([f'{x:.6f}' for x in case_results])}]\"\n        all_results_str.append(sub_list_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n\n```"
        }
    ]
}