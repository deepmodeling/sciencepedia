{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of advanced meshless methods is the concept of \"consistency,\" which guarantees that the approximation can exactly represent simple polynomial solutions. This exercise guides you through implementing a one-dimensional Reproducing Kernel Particle Method (RKPM) approximation from first principles . By numerically verifying the exact reproduction of a linear displacement field, you will gain direct, hands-on insight into this fundamental property that underpins the accuracy and convergence of these powerful methods.",
            "id": "4190935",
            "problem": "Consider a one-dimensional bar model of a soft tissue fiber under small-strain uniaxial tension, idealized on the domain $x \\in [0, L]$ with $L = 1$. In small-strain linear elasticity, the equilibrium of a prismatic bar with constant axial modulus and under uniform axial traction admits an exact displacement field that is linear in space. In advanced meshless formulations such as the Reproducing Kernel Particle Method (RKPM), linear fields should be reproduced exactly if first-order consistency is enforced by the approximation. Your task is to start from fundamental principles and implement a first-order consistent RKPM approximation in one dimension, and then verify numerically that linear fields are reproduced by computing a displacement error norm over the domain.\n\nStarting from the following bases and facts:\n- Small-strain kinematics and linear momentum balance for a one-dimensional bar imply that, under a uniform axial load with appropriate boundary conditions, the exact displacement field is linear in $x$.\n- In the Reproducing Kernel Particle Method (RKPM), shape functions are constructed to satisfy reproducing conditions for a chosen polynomial basis. For first-order consistency in one dimension, the polynomial basis is $p(x) = [1, x]^T$. To achieve this, one may formulate a weighted least-squares fit over neighbor nodes with a positive weight (kernel) $w(r; h)$, where $r$ is a distance and $h$ is a support parameter.\n- A Gaussian kernel is positive for all $r$ and defined by $w(r; h) = \\exp\\!\\left(-\\left(\\frac{r}{h}\\right)^2\\right)$.\n\nDerive the discrete equations required to obtain first-order consistent RKPM shape functions at an arbitrary evaluation coordinate $x \\in [0, L]$ using the polynomial basis $p(x) = [1, x]^T$ and the Gaussian kernel $w(r; h) = \\exp\\!\\left(-\\left(\\frac{r}{h}\\right)^2\\right)$. Using these shape functions, construct the RKPM approximation $u_h(x)$ of a prescribed exact displacement field $u(x) = a x + b$, given nodal samples $u_i = u(x_i)$ at a chosen set of nodes $\\{x_i\\}_{i=1}^N$.\n\nImplement the following numerical experiment:\n- Domain and units: Use $L = 1$ without assigning physical units to $x$ or $u(x)$; compute a dimensionless error norm. Any trigonometric function must use angles in radians.\n- Nodes: For each test case, construct a set of $N$ nodes $\\{x_i\\}_{i=1}^N \\subset [0, L]$. For uniform grids, take $x_i$ uniformly spaced over $[0, L]$. For jittered grids, start from a uniform grid and add a smooth deterministic perturbation as specified below; ensure $x_1 = 0$ and $x_N = L$, and keep the nodes sorted in ascending order.\n- Kernel: Use the Gaussian kernel $w(r; h) = \\exp\\!\\left(-\\left(\\frac{r}{h}\\right)^2\\right)$ in all test cases with the support parameter $h = \\alpha \\Delta x$, where $\\Delta x$ is the mean nodal spacing and $\\alpha$ is specified per test case.\n- Field: For each test case, prescribe a linear exact displacement field $u(x) = a x + b$.\n- Approximation: At any evaluation point $x$, build the first-order consistent RKPM approximation $u_h(x)$ using the first-order reproducing conditions. Evaluate the approximation on a set of $M$ uniformly distributed sample points in $[0, L]$ with $M = 1001$.\n- Error norm: Compute the discrete $L^2$ norm of the displacement error over $[0, L]$ by the composite midpoint or trapezoidal rule. Concretely, with uniform samples, you may approximate\n$$\n\\|e\\|_{L^2} \\approx \\left(\\sum_{j=1}^{M} \\left(u_h(x_j) - u(x_j)\\right)^2 \\, \\Delta x_s \\right)^{1/2},\n$$\nwhere $\\Delta x_s = \\frac{L}{M-1}$ and $\\{x_j\\}_{j=1}^{M}$ are the uniform sample points. Report this norm as a dimensionless floating-point number.\n\nTest suite (four cases):\n- Case $1$ (happy path, uniform grid, moderate support): $N = 41$, $\\alpha = 2.5$, $(a, b) = (1.5, -0.3)$, uniform nodes on $[0, L]$.\n- Case $2$ (nonuniform grid by deterministic jitter, moderate support): $N = 41$, $\\alpha = 2.0$, $(a, b) = (-2.2, 0.4)$, jitter the uniform grid by $x_i \\leftarrow x_i + \\gamma \\Delta x \\sin\\!\\left(2 \\pi \\frac{i-1}{N-1}\\right)$ with $\\gamma = 0.2$, then clip to $[0, L]$, set $x_1 = 0$, $x_N = L$, and sort ascending.\n- Case $3$ (near-minimal support, uniform grid): $N = 41$, $\\alpha = 0.8$, $(a, b) = (0.75, 0.1)$, uniform nodes.\n- Case $4$ (finer grid with jitter, small support): $N = 81$, $\\alpha = 1.2$, $(a, b) = (1.0, 0.0)$, jitter as in Case $2$ with the same $\\gamma = 0.2$.\n\nRequired program output:\n- Your program must produce a single line of output containing the four error norms for the four cases as a comma-separated list enclosed in square brackets, for example, $[e_1,e_2,e_3,e_4]$, where each $e_k$ is the floating-point error norm for Case $k$ in the order listed above. The output must be exactly one line and contain no additional text.\n\nYour implementation must be a complete, runnable program that constructs the nodes, computes first-order consistent RKPM shape functions with a Gaussian kernel, forms $u_h(x)$ from nodal values for the prescribed linear fields, evaluates the discrete $L^2$ error norms as specified, and prints the list of four error norms in the required format.",
            "solution": "The problem requires the derivation and implementation of a first-order consistent Reproducing Kernel Particle Method (RKPM) approximation for a one-dimensional bar. The objective is to numerically verify that this approximation exactly reproduces linear displacement fields, a property known as first-order consistency. The verification will be conducted by computing the discrete $L^2$ error norm between the RKPM approximation and a known linear field for several test cases.\n\nThe theoretical foundation for constructing RKPM shape functions that satisfy specific consistency (or reproducing) conditions is the method of moving least-squares (MLS). We begin by deriving the MLS approximation for a one-dimensional field $u(x)$.\n\nAt any evaluation point $x \\in [0, L]$, we seek a local polynomial approximation, denoted $u_h(y; x)$, for the true field $u(y)$ for points $y$ in the vicinity of $x$. For first-order consistency, the approximation is constructed from a linear basis. The problem specifies the basis in global coordinates as $p(y) = [1, y]^T$. The local approximation is thus written as:\n$$\nu_h(y; x) = p^T(y) \\mathbf{a}(x) = a_1(x) + y a_2(x)\n$$\nwhere $\\mathbf{a}(x) = [a_1(x), a_2(x)]^T$ is a vector of coefficients that depends on the evaluation point $x$. These coefficients are determined by performing a weighted least-squares fit to the known nodal data $\\{ (x_i, u_i) \\}_{i=1}^N$. The functional to be minimized is:\n$$\nJ(\\mathbf{a}) = \\sum_{i=1}^{N} \\left[ u_h(x_i; x) - u_i \\right]^2 w(x - x_i; h) = \\sum_{i=1}^{N} \\left[ p^T(x_i) \\mathbf{a}(x) - u_i \\right]^2 w(x - x_i; h)\n$$\nHere, $w(r; h)$ is a positive weight or kernel function with a characteristic support size $h$. The problem specifies the Gaussian kernel $w(r; h) = \\exp\\left(-(r/h)^2\\right)$. The weight functions are centered at the evaluation point $x$, localizing the least-squares fit.\n\nTo find the coefficients $\\mathbf{a}(x)$ that minimize $J(\\mathbf{a})$, we take the derivative of $J$ with respect to $\\mathbf{a}$ and set it to zero:\n$$\n\\frac{\\partial J}{\\partial \\mathbf{a}} = \\sum_{i=1}^{N} 2 \\left[ p^T(x_i) \\mathbf{a}(x) - u_i \\right] p(x_i) w(x - x_i; h) = \\mathbf{0}\n$$\nRearranging this expression yields the normal equations, a system of linear equations for $\\mathbf{a}(x)$:\n$$\n\\left[ \\sum_{i=1}^{N} p(x_i) p^T(x_i) w(x - x_i; h) \\right] \\mathbf{a}(x) = \\sum_{i=1}^{N} p(x_i) u_i w(x - x_i; h)\n$$\nThis system can be written in matrix form as:\n$$\n\\mathbf{M}(x) \\mathbf{a}(x) = \\mathbf{V}(x)\n$$\nwhere $\\mathbf{M}(x)$ is the $2 \\times 2$ moment matrix:\n$$\n\\mathbf{M}(x) = \\sum_{i=1}^{N} p(x_i) p^T(x_i) w(x-x_i; h) = \\sum_{i=1}^{N} \\begin{pmatrix} 1 & x_i \\\\ x_i & x_i^2 \\end{pmatrix} w(x-x_i; h)\n$$\nand $\\mathbf{V}(x)$ is a $2 \\times 1$ vector:\n$$\n\\mathbf{V}(x) = \\sum_{i=1}^{N} p(x_i) u_i w(x-x_i; h) = \\sum_{i=1}^{N} \\begin{pmatrix} 1 \\\\ x_i \\end{pmatrix} u_i w(x-x_i; h)\n$$\nAssuming the moment matrix $\\mathbf{M}(x)$ is invertible, the coefficient vector is $\\mathbf{a}(x) = \\mathbf{M}(x)^{-1} \\mathbf{V}(x)$.\n\nThe RKPM approximation of the field *at* the point $x$ is then given by evaluating the local approximation $u_h(y; x)$ at $y=x$:\n$$\nu_h(x) = u_h(x; x) = p^T(x) \\mathbf{a}(x) = p^T(x) \\mathbf{M}(x)^{-1} \\mathbf{V}(x)\n$$\nSubstituting the expression for $\\mathbf{V}(x)$:\n$$\nu_h(x) = p^T(x) \\mathbf{M}(x)^{-1} \\left[ \\sum_{i=1}^{N} p(x_i) u_i w(x-x_i; h) \\right]\n$$\nThis can be expressed in the standard form of a discrete approximation, $u_h(x) = \\sum_{i=1}^N \\Psi_i(x) u_i$, where $\\Psi_i(x)$ are the RKPM shape functions. By inspection, the shape function for node $i$ evaluated at point $x$ is:\n$$\n\\Psi_i(x) = p^T(x) \\mathbf{M}(x)^{-1} p(x_i) w(x-x_i; h)\n$$\nWe now verify algebraically that this construction exactly reproduces any linear field. Let the nodal values be sampled from a linear field $u(x) = ax + b$, so $u_i = u(x_i) = a x_i + b$. We can write this in terms of the basis $p(x_i)$:\n$$\nu_i = \\begin{pmatrix} b & a \\end{pmatrix} \\begin{pmatrix} 1 \\\\ x_i \\end{pmatrix} = \\mathbf{c}^T p(x_i), \\quad \\text{with} \\quad \\mathbf{c} = \\begin{pmatrix} b \\\\ a \\end{pmatrix}\n$$\nSubstituting this into the expression for $u_h(x)$:\n$$\nu_h(x) = p^T(x) \\mathbf{M}(x)^{-1} \\left[ \\sum_{i=1}^{N} p(x_i) (\\mathbf{c}^T p(x_i)) w(x-x_i; h) \\right]\n$$\nSince $\\mathbf{c}^T p(x_i)$ is a scalar, we can write $p(x_i) (\\mathbf{c}^T p(x_i)) = p(x_i) p^T(x_i) \\mathbf{c}$. This allows us to factor out the constant vector $\\mathbf{c}$:\n$$\nu_h(x) = p^T(x) \\mathbf{M}(x)^{-1} \\left[ \\sum_{i=1}^{N} p(x_i) p^T(x_i) w(x-x_i; h) \\right] \\mathbf{c}\n$$\nThe term in the square brackets is precisely the definition of the moment matrix $\\mathbf{M}(x)$. Therefore:\n$$\nu_h(x) = p^T(x) \\mathbf{M}(x)^{-1} \\mathbf{M}(x) \\mathbf{c} = p^T(x) \\mathbf{I} \\mathbf{c} = p^T(x) \\mathbf{c}\n$$\nwhere $\\mathbf{I}$ is the $2 \\times 2$ identity matrix. Finally, substituting the definitions of $p^T(x)$ and $\\mathbf{c}$:\n$$\nu_h(x) = \\begin{pmatrix} 1 & x \\end{pmatrix} \\begin{pmatrix} b \\\\ a \\end{pmatrix} = 1 \\cdot b + x \\cdot a = ax + b\n$$\nThis proves that $u_h(x) = u(x)$ for any linear field, provided $\\mathbf{M}(x)$ is invertible. The invertibility of $\\mathbf{M}(x)$ is guaranteed as long as there are at least two distinct nodes $\\{x_i\\}$ with non-zero weights $w(x-x_i; h)$, which is true for the Gaussian kernel and any grid with $N \\ge 2$.\n\nFor the numerical experiment, we will implement this procedure.\n1. For each test case, we generate the set of $N$ nodes $\\{x_i\\}_{i=1}^N$ on the domain $[0, 1]$, either uniformly or with the specified deterministic jitter.\n2. The kernel support parameter is set to $h = \\alpha \\Delta x$, where $\\Delta x = 1/(N-1)$ is the spacing of the initial uniform grid.\n3. The nodal values are computed as $u_i = u(x_i) = ax_i + b$ using the case-specific parameters $(a, b)$.\n4. A set of $M = 1001$ uniform evaluation points $\\{x_j\\}_{j=1}^M$ is created on $[0,1]$.\n5. For each evaluation point $x_j$, we compute the approximation $u_h(x_j)$. This involves:\n   a. Assembling the $2 \\times 2$ moment matrix $\\mathbf{M}(x_j)$ and the $2 \\times 1$ vector $\\mathbf{V}(x_j)$ by summing contributions from all $N$ nodes.\n   b. Solving the linear system $\\mathbf{M}(x_j) \\mathbf{a}(x_j) = \\mathbf{V}(x_j)$ for the coefficients $\\mathbf{a}(x_j)$.\n   c. Computing the approximation $u_h(x_j) = p^T(x_j) \\mathbf{a}(x_j)$.\n6. After computing all $u_h(x_j)$, the discrete $L^2$ error norm is calculated as:\n$$\n\\|e\\|_{L^2} \\approx \\left(\\sum_{j=1}^{M} \\left(u_h(x_j) - u(x_j)\\right)^2 \\Delta x_s \\right)^{1/2}\n$$\nwhere $u(x_j)$ are the exact values at the evaluation points, and $\\Delta x_s = L/(M-1) = 1/(1000)$.\nGiven the algebraic proof, the computed error norm is expected to be on the order of machine floating-point precision (approximately $10^{-15}$ to $10^{-16}$ for double precision). Any significant deviation would indicate numerical ill-conditioning, for instance, if the support parameter $h$ is too small or too large, though the chosen parameters should be well-behaved.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a first-order consistent RKPM approximation in 1D\n    to verify that linear fields are reproduced exactly.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 41, 'alpha': 2.5, 'a': 1.5, 'b': -0.3, 'jitter': False},\n        {'N': 41, 'alpha': 2.0, 'a': -2.2, 'b': 0.4, 'jitter': True, 'gamma': 0.2},\n        {'N': 41, 'alpha': 0.8, 'a': 0.75, 'b': 0.1, 'jitter': False},\n        {'N': 81, 'alpha': 1.2, 'a': 1.0, 'b': 0.0, 'jitter': True, 'gamma': 0.2},\n    ]\n\n    L = 1.0\n    M = 1001  # Number of evaluation points for error norm calculation\n\n    # Uniform evaluation points for error calculation\n    eval_points = np.linspace(0.0, L, M)\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        alpha = case['alpha']\n        a_coeff = case['a']\n        b_coeff = case['b']\n\n        # 1. Generate nodes {x_i}\n        # The problem implies delta_x is based on the uniform grid for all cases\n        delta_x_uniform = L / (N - 1)\n        nodes = np.linspace(0.0, L, N)\n\n        if case['jitter']:\n            gamma = case['gamma']\n            # i=1,...,N corresponds to array indices 0,...,N-1\n            indices = np.arange(N)\n            perturbation = gamma * delta_x_uniform * np.sin(2 * np.pi * indices / (N - 1))\n            \n            nodes = nodes + perturbation\n            \n            # Clip, fix boundaries, and sort\n            nodes = np.clip(nodes, 0.0, L)\n            nodes[0] = 0.0\n            nodes[-1] = L\n            nodes.sort()\n\n        # 2. Define kernel, field, and get nodal values\n        h = alpha * delta_x_uniform\n\n        def kernel(r, h_val):\n            return np.exp(-(r / h_val)**2)\n\n        def u_exact(x):\n            return a_coeff * x + b_coeff\n\n        nodal_displacements = u_exact(nodes)\n\n        # 3. Evaluate RKPM approximation u_h(x) at each evaluation point\n        u_h_values = np.zeros(M)\n\n        for j, x_eval in enumerate(eval_points):\n            # Assemble moment matrix M(x) and vector V(x)\n            moment_matrix = np.zeros((2, 2))\n            rhs_vector = np.zeros(2)\n\n            for i in range(N):\n                xi = nodes[i]\n                ui = nodal_displacements[i]\n                w = kernel(x_eval - xi, h)\n                \n                p_i = np.array([1.0, xi])\n                \n                # M = sum(p_i * p_i^T * w_i)\n                moment_matrix += w * np.outer(p_i, p_i)\n                # V = sum(p_i * u_i * w_i)\n                rhs_vector += w * p_i * ui\n            \n            # Solve M(x) * a(x) = V(x) for coefficients a(x)\n            try:\n                coeffs = np.linalg.solve(moment_matrix, rhs_vector)\n            except np.linalg.LinAlgError:\n                # This should not occur with the given problem parameters\n                coeffs = np.array([np.nan, np.nan])\n\n            # Evaluate approximation u_h(x) = p^T(x) * a(x)\n            p_eval = np.array([1.0, x_eval])\n            u_h_values[j] = p_eval @ coeffs\n\n        # 4. Compute discrete L2 error norm\n        exact_values_at_eval = u_exact(eval_points)\n        errors = u_h_values - exact_values_at_eval\n\n        # Guard against NaN from failed linear solve\n        if np.any(np.isnan(errors)):\n            l2_error_norm = np.nan\n        else:\n            delta_xs = L / (M - 1)\n            l2_error_norm = np.sqrt(np.sum(errors**2) * delta_xs)\n        \n        results.append(l2_error_norm)\n\n    # Final print statement in the exact required format.\n    # The output should show values very close to zero, so scientific notation is appropriate.\n    print(f\"[{','.join([f'{norm:.16e}' for norm in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Isogeometric Analysis (IGA) offers elegant solutions to long-standing challenges in computational mechanics, including the imposition of boundary conditions. This practice explores how the structure of a Non-Uniform Rational B-Splines (NURBS) basis, specifically the use of an open knot vector, yields interpolatory behavior at domain boundaries . By working through a simple 1D bar problem, you will see how essential boundary conditions can be applied directly to the control variables, a significant departure from and simplification of traditional finite element procedures.",
            "id": "4190908",
            "problem": "A straight, axially deformable soft-tissue tendon segment is modeled as a one-dimensional bar occupying the physical domain $x \\in [0,L]$ with constant cross-sectional area $A$ and Young’s modulus $E$. The tendon is subjected to a uniform axial distributed load $q$ (force per unit length) along the $+x$ direction. The kinematics are small strain, with axial strain defined by $\\varepsilon(x) = \\frac{du}{dx}$, where $u(x)$ is the axial displacement field. The constitutive relation is linear elastic, $\\sigma(x) = E\\,\\varepsilon(x)$, and the weak form arises from the principle of virtual work.\n\nYou will discretize this problem using Isogeometric Analysis (IGA), employing a quadratic open Non-Uniform Rational B-Splines (NURBS) basis specialized to non-rational B-splines. Let the parameter domain be $\\xi \\in [0,1]$, with an open knot vector $\\mathcal{U} = [0,0,0,1,1,1]$ and three control points for the geometry placed at $X_1 = 0$, $X_2 = \\frac{L}{2}$, and $X_3 = L$. Use the same quadratic open B-spline basis for the displacement field $u(x)$ as is used for the geometry mapping. Assume zero traction at $x=L$. \n\nTasks:\n- Starting from the weak form for a one-dimensional linear elastic bar under a distributed axial load and small strains, construct the quadratic open B-spline basis on $\\mathcal{U}$, show that the open knot vector regains interpolatory control at the boundaries, and explain why essential boundary conditions can be directly imposed on the end control variables. Then, impose the essential boundary conditions $u(0) = 0$ and $u(L) = 0$ by directly setting the appropriate displacement control variables.\n- With those boundary conditions enforced, derive the single scalar equation for the remaining displacement control variable by assembling the stiffness contribution from the internal virtual work and the load contribution from the external virtual work, respecting the isoparametric mapping induced by the geometry control points.\n- Using the following physical parameters: $L = 0.1\\,\\text{m}$, $A = 1.0 \\times 10^{-4}\\,\\text{m}^2$, $E = 1.5 \\times 10^{6}\\,\\text{Pa}$, and $q = 10\\,\\text{N}\\,\\text{m}^{-1}$, compute the value of the remaining displacement control variable. \n\nExpress your final answer for the remaining displacement control variable in meters and round your answer to four significant figures. The final answer must be a single real number.",
            "solution": "The fundamental base is the one-dimensional linear elasticity model for an axially deformable bar, under small strains and linear constitutive behavior. The axial strain is $\\varepsilon(x) = \\frac{du}{dx}$, the stress is $\\sigma(x) = E\\,\\varepsilon(x)$, and the internal virtual work is $\\delta W_{\\text{int}} = \\int_{0}^{L} E A \\frac{du}{dx} \\frac{d \\delta u}{dx}\\, dx$. The external virtual work due to a distributed axial load $q$ is $\\delta W_{\\text{ext}} = \\int_{0}^{L} q\\, \\delta u\\, dx$, and we assume zero end traction at $x=L$. The weak form is: find $u$ in the appropriate space satisfying the essential boundary conditions such that\n$$\n\\int_{0}^{L} E A \\frac{du}{dx} \\frac{d \\delta u}{dx}\\, dx = \\int_{0}^{L} q\\, \\delta u\\, dx \\quad \\text{for all admissible } \\delta u.\n$$\n\nIn Isogeometric Analysis (IGA), the same basis used for geometry is used for the displacement field. We adopt a quadratic open B-spline basis on the parameter domain $\\xi \\in [0,1]$ with the open knot vector $\\mathcal{U} = [0,0,0,1,1,1]$. This yields $p+1=3$ basis functions, which for this single element coincide with the quadratic Bernstein polynomials:\n$$\nN_1(\\xi) = (1 - \\xi)^{2}, \\quad N_2(\\xi) = 2 \\xi (1 - \\xi), \\quad N_3(\\xi) = \\xi^{2}.\n$$\nThe open knot vector ensures that the end basis functions are interpolatory at the boundaries:\n$$\nN_1(0) = 1, \\quad N_2(0) = 0, \\quad N_3(0) = 0; \\qquad N_1(1) = 0, \\quad N_2(1) = 0, \\quad N_3(1) = 1.\n$$\nTherefore, the displacement control variables corresponding to the first and last basis functions directly evaluate the displacement at the physical ends when the geometry mapping places those ends at $\\xi=0$ and $\\xi=1$.\n\nWe construct the geometry mapping $x(\\xi)$ using the same basis and control points $X_i$:\n$$\nx(\\xi) = N_1(\\xi) X_1 + N_2(\\xi) X_2 + N_3(\\xi) X_3.\n$$\nWith $X_1 = 0$, $X_2 = \\frac{L}{2}$, and $X_3 = L$, we obtain\n$$\nx(\\xi) = (1 - \\xi)^{2} \\cdot 0 + 2 \\xi (1 - \\xi) \\cdot \\frac{L}{2} + \\xi^{2} \\cdot L = L \\left[\\xi (1 - \\xi) + \\xi^{2} \\right] = L \\xi,\n$$\nwhich is a linear isoparametric mapping, hence $\\frac{d\\xi}{dx} = \\frac{1}{L}$ and $dx = L\\, d\\xi$.\n\nWe approximate the displacement field as\n$$\nu(x(\\xi)) = \\sum_{i=1}^{3} N_i(\\xi) d_i,\n$$\nwhere $d_i$ are the displacement control variables. Owing to the interpolatory property at the boundaries, and the geometry mapping placing $x=0$ at $\\xi=0$ and $x=L$ at $\\xi=1$, the essential boundary conditions $u(0) = 0$ and $u(L) = 0$ impose directly\n$$\nd_1 = 0, \\qquad d_3 = 0.\n$$\nThus, only $d_2$ remains unknown.\n\nWe derive the discrete equation for $d_2$ from the weak form. The internal virtual work contribution induces the stiffness entry\n$$\nK_{22} = \\int_{0}^{L} E A \\left( \\frac{dN_2}{dx} \\right) \\left( \\frac{dN_2}{dx} \\right) dx.\n$$\nUsing the isoparametric mapping, $\\frac{dN_2}{dx} = \\frac{dN_2}{d\\xi} \\frac{d\\xi}{dx} = \\frac{1}{L} \\frac{dN_2}{d\\xi}$, and $dx = L\\, d\\xi$, we obtain\n$$\nK_{22} = \\int_{0}^{1} E A \\left( \\frac{1}{L} \\frac{dN_2}{d\\xi} \\right)^{2} L\\, d\\xi = \\frac{E A}{L} \\int_{0}^{1} \\left( \\frac{dN_2}{d\\xi} \\right)^{2} d\\xi.\n$$\nFor $N_2(\\xi) = 2 \\xi (1 - \\xi)$, we compute\n$$\n\\frac{dN_2}{d\\xi} = 2(1 - 2\\xi),\n$$\nso\n$$\nK_{22} = \\frac{E A}{L} \\int_{0}^{1} 4 (1 - 2\\xi)^{2} d\\xi = \\frac{E A}{L} \\cdot 4 \\int_{0}^{1} \\left( 1 - 4\\xi + 4\\xi^{2} \\right) d\\xi = \\frac{E A}{L} \\cdot 4 \\left( 1 - 2 + \\frac{4}{3} \\right) = \\frac{4 E A}{3 L}.\n$$\n\nThe external virtual work contribution gives the load vector entry\n$$\nF_{2} = \\int_{0}^{L} q\\, N_2\\, dx = \\int_{0}^{1} q\\, N_2(\\xi)\\, L\\, d\\xi = q L \\int_{0}^{1} 2 \\xi (1 - \\xi)\\, d\\xi.\n$$\nWe compute\n$$\n\\int_{0}^{1} 2 \\xi (1 - \\xi)\\, d\\xi = \\int_{0}^{1} \\left( 2\\xi - 2\\xi^{2} \\right) d\\xi = \\left[ \\xi^{2} - \\frac{2}{3}\\xi^{3} \\right]_{0}^{1} = 1 - \\frac{2}{3} = \\frac{1}{3},\n$$\nhence\n$$\nF_{2} = \\frac{q L}{3}.\n$$\n\nAfter imposing $d_1 = 0$ and $d_3 = 0$, the reduced discrete equation for the single unknown becomes\n$$\nK_{22}\\, d_2 = F_2,\n$$\nso\n$$\nd_2 = \\frac{F_2}{K_{22}} = \\frac{\\frac{q L}{3}}{\\frac{4 E A}{3 L}} = \\frac{q L^{2}}{4 E A}.\n$$\n\nWe now substitute the given physical parameters, keeping symbolic reasoning until the final step. With $L = 0.1\\,\\text{m}$, $A = 1.0 \\times 10^{-4}\\,\\text{m}^{2}$, $E = 1.5 \\times 10^{6}\\,\\text{Pa}$, and $q = 10\\,\\text{N}\\,\\text{m}^{-1}$, we find\n$$\nE A = \\left(1.5 \\times 10^{6}\\right) \\left(1.0 \\times 10^{-4}\\right) = 1.5 \\times 10^{2} = 150,\n$$\n$$\nL^{2} = \\left( 0.1 \\right)^{2} = 1.0 \\times 10^{-2} = 0.01,\n$$\nand hence\n$$\nd_2 = \\frac{q L^{2}}{4 E A} = \\frac{10 \\times 0.01}{4 \\times 150} = \\frac{0.1}{600} = \\frac{1}{6000} = 1.666\\ldots \\times 10^{-4}.\n$$\nRounding to four significant figures, the displacement control variable is\n$$\nd_2 \\approx 0.0001667 \\quad \\text{meters}.\n$$\n\nThis construction demonstrates that open knot vectors regain interpolatory control at the boundaries, allowing direct imposition of essential boundary conditions via $d_1$ and $d_3$, and yields a single scalar unknown $d_2$ whose value is computed from first principles via the weak form.",
            "answer": "$$\\boxed{0.0001667}$$"
        },
        {
            "introduction": "In the quest for computational efficiency, simplified integration schemes are often employed, but they can introduce non-physical instabilities known as spurious zero-energy or \"hourglass\" modes. This exercise tackles this critical issue by implementing the Stabilized Conforming Nodal Integration (SCNI) method for a 2D elasticity problem . Through eigenvalue analysis of the resulting stiffness matrices, you will directly compare a standard under-integrated element with its stabilized counterpart and quantify the effectiveness of SCNI in creating robust, physically meaningful simulations.",
            "id": "4190921",
            "problem": "You are given a two-dimensional linear elasticity patch representative of a soft tissue sample. The discretization uses a bilinear quadrilateral basis that is equivalent to a degree-$1$ isogeometric mapping (a special case of Non-Uniform Rational B-Splines (NURBS) with uniform knots). The objective is to demonstrate, by first principles and algorithmic construction, how Stabilized Conforming Nodal Integration (SCNI) mitigates spurious zero-energy modes (hourglass modes) that arise in under-integrated stiffness formulations.\n\nStart from the small-strain linear elasticity of an isotropic material under plane strain. The deformation mapping is characterized by the displacement field $(u_x(x,y),u_y(x,y))$, and the strain vector is $\\boldsymbol{\\varepsilon}=[\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy}]^\\top$ with $\\gamma_{xy}=2\\varepsilon_{xy}$. The constitutive relation is $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$, where $\\mathbf{D}$ is the symmetric elasticity matrix for plane strain. The stiffness matrix $\\mathbf{K}$ follows from the principle of virtual work as\n$$\n\\mathbf{K} = \\int_{\\Omega} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} \\,\\mathrm{d}\\Omega,\n$$\nwhere $\\mathbf{B}$ is the strain-displacement matrix built from the spatial gradients of the shape functions.\n\nIn nodal or reduced integration for bilinear quadrilaterals, evaluating the integral using a single point per element causes rank deficiency and spurious zero-energy modes (hourglass modes). The SCNI method constructs a smoothed gradient over a nodal or cell domain by the divergence theorem. For a smoothing cell $\\Omega_s$ with boundary $\\partial\\Omega_s$ and outward unit normal $\\mathbf{n}$,\n$$\n\\overline{\\nabla N_i} = \\frac{1}{|\\Omega_s|}\\int_{\\partial\\Omega_s} N_i \\,\\mathbf{n}\\,\\mathrm{d}s.\n$$\nReplacing the raw gradient $\\nabla N_i$ by the smoothed gradient $\\overline{\\nabla N_i}$ in $\\mathbf{B}$ yields a corrected stiffness that reduces spurious modes.\n\nImplement both formulations for the following test suite and compare the number of near-zero eigenvalues of $\\mathbf{K}$ beyond the rigid body modes. For an unconstrained planar body, there are exactly $3$ rigid-body modes corresponding to two translations and one rotation, so any additional near-zero eigenvalues quantify spurious modes.\n\nUse the following material properties for all cases: Young’s modulus $E=10000$ (Pascal), Poisson’s ratio $\\nu=0.45$, plane strain, and unit thickness $t=1$. Geometric layouts are axis-aligned rectangles with uniform nodal grids. Each quadrilateral element is formed by four neighboring nodes in counterclockwise order. No essential boundary conditions are applied; the stiffness matrix is analyzed in the free state.\n\nDefine near-zero eigenvalues using a relative threshold $\\tau$ multiplied by the largest eigenvalue magnitude: an eigenvalue $\\lambda$ is classified near-zero if $|\\lambda| \\le \\tau \\max_i |\\lambda_i|$. Set $\\tau=10^{-8}$. The number of spurious modes equals the count of near-zero eigenvalues minus $3$ (if this difference is negative, take $0$).\n\nTest suite:\n- Case $1$ (balanced patch): domain size $L_x=1.0$, $L_y=1.0$, nodal grid $N_x=3$, $N_y=3$.\n- Case $2$ (slender patch): domain size $L_x=2.0$, $L_y=0.5$, nodal grid $N_x=5$, $N_y=2$.\n- Case $3$ (single element): domain size $L_x=1.0$, $L_y=1.0$, nodal grid $N_x=2$, $N_y=2$.\n\nAlgorithmic requirements:\n- Construct the global stiffness matrices $\\mathbf{K}_{\\text{naive}}$ and $\\mathbf{K}_{\\text{SCNI}}$ for each case:\n  - For the naive under-integrated formulation, approximate the element stiffness using a single quadrature point at the element center $(\\xi,\\eta)=(0,0)$ in the parent space with weight $w=4$ on $[-1,1]^2$, mapping gradients via the Jacobian at the center.\n  - For the SCNI formulation, compute the smoothed gradient for each element by applying the divergence theorem over the element polygon. Use a $2$-point Gauss rule per edge in parent coordinates to evaluate $\\int_{\\partial\\Omega_e} N_i \\,\\mathbf{n}\\,\\mathrm{d}s$ with outward normals constructed from the physical edge vectors. The element stiffness is $\\mathbf{K}_e^{\\text{SCNI}} = |\\Omega_e|\\,\\mathbf{B}_{\\text{SCNI}}^\\top \\mathbf{D}\\mathbf{B}_{\\text{SCNI}}$, where $\\mathbf{B}_{\\text{SCNI}}$ uses $\\overline{\\nabla N_i}$ for each node.\n- Assemble the global matrices from the element contributions with standard finite element connectivity.\n- Compute all eigenvalues of each global stiffness and count spurious modes as specified.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, for each case: the number of spurious modes for the naive formulation, then the number for the SCNI formulation. Therefore, the final output must be of the form\n$[s_1^{\\text{naive}},s_1^{\\text{SCNI}},s_2^{\\text{naive}},s_2^{\\text{SCNI}},s_3^{\\text{naive}},s_3^{\\text{SCNI}}]$,\nwhere each $s_k$ is an integer.",
            "solution": "The solution proceeds as follows. First, we establish the theoretical background for two-dimensional linear elasticity using a bilinear quadrilateral element. Second, we detail the construction of the global stiffness matrix $\\mathbf{K}$ using two methods: a naive single-point under-integration scheme and the Stabilized Conforming Nodal Integration (SCNI) method. Finally, we provide the implementation details for analyzing the eigenspectrum of the resulting matrices to quantify spurious zero-energy modes.\n\n**1. Theoretical Framework**\n\nThe analysis is based on small-strain linear elasticity under plane strain conditions. The displacement field is $\\mathbf{u} = (u_x, u_y)^\\top$. The infinitesimal strain tensor components are arranged in a vector $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top$, where $\\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x}$, $\\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y}$, and the engineering shear strain is $\\gamma_{xy} = \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x}$.\n\nThe strain field is related to the nodal displacements $\\mathbf{d}$ via the strain-displacement matrix $\\mathbf{B}$, such that $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{d}$. For a single quadrilateral element with $4$ nodes, the nodal displacement vector is $\\mathbf{d}_e \\in \\mathbb{R}^8$. The matrix $\\mathbf{B}$ is constructed from the spatial derivatives of the element's shape functions, $N_i$. For a node $i$, its contribution to the $\\mathbf{B}$ matrix is $\\mathbf{B}_i = \\begin{pmatrix} \\partial N_i / \\partial x & 0 \\\\ 0 & \\partial N_i / \\partial y \\\\ \\partial N_i / \\partial y & \\partial N_i / \\partial x \\end{pmatrix}$. The full element matrix is $\\mathbf{B}_e = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]$.\n\nThe material is isotropic and linear elastic, so the stress vector $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^\\top$ is related to the strain via the constitutive matrix $\\mathbf{D}$: $\\boldsymbol{\\sigma} = \\mathbf{D}\\boldsymbol{\\varepsilon}$. For plane strain, the matrix $\\mathbf{D}$ is given by:\n$$\n\\mathbf{D} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & \\frac{1-2\\nu}{2} \\end{pmatrix}\n$$\nwhere $E$ is Young's modulus and $\\nu$ is Poisson's ratio.\n\nThe element stiffness matrix $\\mathbf{K}_e$ is derived from the principle of virtual work and is given by the integral over the element's domain $\\Omega_e$:\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega\n$$\n\n**2. Bilinear Quadrilateral Element**\n\nWe use a standard isoparametric formulation. The geometry and displacement field within the element are interpolated from the nodal values using bilinear shape functions $N_i(\\xi, \\eta)$ defined on a parent domain $[-1, 1]^2$:\n$N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$, $N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$, $N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$, $N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$.\nThe spatial derivatives of the shape functions $\\nabla_x N_i = (\\partial N_i / \\partial x, \\partial N_i / \\partial y)^\\top$ are found using the chain rule and the inverse of the Jacobian matrix $\\mathbf{J}$: $\\nabla_x N_i = \\mathbf{J}^{-1} \\nabla_\\xi N_i$.\n\n**3. Naive Under-Integrated Formulation ($\\mathbf{K}_{\\text{naive}}$)**\n\nThis formulation approximates the stiffness integral using a single Gauss quadrature point at the center of the parent element, $(\\xi, \\eta) = (0, 0)$. The weight for this rule on $[-1, 1]^2$ is $w=4$. The element stiffness matrix is:\n$$\n\\mathbf{K}_e^{\\text{naive}} \\approx \\left(\\mathbf{B}^\\top \\mathbf{D} \\mathbf{B}\\right)|_{(\\xi, \\eta)=(0,0)} \\det(\\mathbf{J}(0,0)) \\cdot w\n$$\nFor a rectangular element of area $|\\Omega_e|$, $\\det(\\mathbf{J})$ is constant and equals $|\\Omega_e|/4$. The formula simplifies to:\n$$\n\\mathbf{K}_e^{\\text{naive}} = |\\Omega_e| \\, \\mathbf{B}(0,0)^\\top \\mathbf{D} \\mathbf{B}(0,0)\n$$\nAt the center of the element, the derivatives of the shape functions exhibit certain symmetries that allow for non-physical deformation modes (hourglass modes) to exist with zero strain energy. This causes the element stiffness matrix to be rank-deficient, propagating to a rank-deficient global stiffness matrix $\\mathbf{K}_{\\text{naive}}$ with spurious zero-energy modes beyond the three rigid-body modes (two translations, one rotation).\n\n**4. Stabilized Conforming Nodal Integration ($\\mathbf{K}_{\\text{SCNI}}$)**\n\nThe SCNI method corrects this rank deficiency by using a smoothed gradient $\\overline{\\nabla N_i}$ in place of the standard gradient $\\nabla N_i$. The smoothed gradient is the average gradient over a smoothing domain, which for this problem is the element itself ($\\Omega_s = \\Omega_e$). By the divergence theorem, this average is computed via a boundary integral:\n$$\n\\overline{\\nabla N_i} = \\frac{1}{|\\Omega_e|}\\int_{\\partial\\Omega_e} N_i \\, \\mathbf{n} \\, \\mathrm{d}s\n$$\nwhere $\\mathbf{n}$ is the outward unit normal to the boundary $\\partial\\Omega_e$. The integral is performed numerically by summing contributions from each of the four element edges.\n$$\n\\int_{\\partial\\Omega_e} N_i \\, \\mathbf{n} \\, \\mathrm{d}s = \\sum_{j=1}^4 \\int_{\\text{edge}_j} N_i \\, \\mathbf{n}_j \\, \\mathrm{d}s\n$$\nFor a straight edge $j$ between nodes $a$ and $b$, the normal $\\mathbf{n}_j$ is constant. The integral for shape function $N_i$ along this edge is non-zero only if node $i$ is one of the edge's endpoints ($i=a$ or $i=b$). The integral is computed with a 2-point Gauss rule on the parent domain edge. For a linear shape function along the edge, this integration is exact and yields $\\int_{\\text{edge}_j}N_i ds = L_j/2$ for $i \\in \\{a,b\\}$, where $L_j$ is the length of the edge.\n\nThe total boundary integral for node $i$ (connected to edges $j$ and $k$) is $\\frac{1}{2}(L_j \\mathbf{n}_j + L_k \\mathbf{n}_k)$. Let $\\mathbf{v}_j = \\mathbf{x}_i - \\mathbf{x}_{\\text{prev}}$ and $\\mathbf{v}_k = \\mathbf{x}_{\\text{next}} - \\mathbf{x}_i$ be the edge vectors. The normal contributions are $L_j\\mathbf{n}_j = (v_{jy}, -v_{jx})$ and $L_k\\mathbf{n}_k = (v_{ky}, -v_{kx})$. The smoothed gradient is:\n$$\n\\overline{\\nabla N_i} = \\frac{1}{2|\\Omega_e|} ((v_{jy}, -v_{jx}) + (v_{ky}, -v_{kx}))\n$$\nThis smoothed gradient $\\overline{\\nabla N_i} = (\\overline{N_{i,x}}, \\overline{N_{i,y}})^\\top$ is then used to construct a constant, smoothed strain-displacement matrix $\\mathbf{B}_{\\text{SCNI}}$ for the element. The SCNI element stiffness matrix is then:\n$$\n\\mathbf{K}_e^{\\text{SCNI}} = |\\Omega_e|\\, \\mathbf{B}_{\\text{SCNI}}^\\top \\mathbf{D} \\mathbf{B}_{\\text{SCNI}}\n$$\nThis formulation is designed to have the correct rank (i.e., nullity of $3$ corresponding to rigid body modes for a single unconstrained element), thus eliminating spurious zero-energy modes.\n\n**5. Assembly and Analysis**\n\nFor both methods, the element stiffness matrices $\\mathbf{K}_e$ are assembled into their respective global stiffness matrices, $\\mathbf{K}_{\\text{naive}}$ and $\\mathbf{K}_{\\text{SCNI}}$, using standard finite element procedures based on element connectivity.\n\nThe final step is to analyze the eigenspectrum of these global matrices. The eigenvalues $\\lambda_i$ are computed. An eigenvalue is classified as \"near-zero\" if $|\\lambda_i| \\le \\tau \\max_j|\\lambda_j|$, with the given threshold $\\tau=10^{-8}$. The number of spurious modes is the count of near-zero eigenvalues minus the $3$ expected rigid-body modes. If this difference is negative, the count is $0$. This procedure is repeated for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print results.\n    \"\"\"\n    \n    # Material and analysis parameters from the problem statement\n    E = 10000.0  # Young's modulus\n    nu = 0.45    # Poisson's ratio\n    tau = 1e-8   # Eigenvalue threshold\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (Lx, Ly, Nx, Ny)\n        (1.0, 1.0, 3, 3),  # Case 1: balanced patch\n        (2.0, 0.5, 5, 2),  # Case 2: slender patch\n        (1.0, 1.0, 2, 2),  # Case 3: single element\n    ]\n\n    results = []\n    for Lx, Ly, Nx, Ny in test_cases:\n        # 1. Generate mesh and constitutive matrix\n        nodes, elements = generate_mesh(Lx, Ly, Nx, Ny)\n        D = compute_elasticity_matrix(E, nu)\n\n        # 2. Compute stiffness matrices for both formulations\n        K_naive = compute_stiffness_naive(nodes, elements, D)\n        K_scni = compute_stiffness_scni(nodes, elements, D)\n\n        # 3. Count spurious modes for each matrix\n        s_naive = count_spurious_modes(K_naive, tau)\n        s_scni = count_spurious_modes(K_scni, tau)\n        \n        results.extend([s_naive, s_scni])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_mesh(Lx, Ly, Nx, Ny):\n    \"\"\"Generates nodal coordinates and element connectivity for a rectangular grid.\"\"\"\n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    nodes = np.array([[xi, yi] for yi in y for xi in x])\n    \n    elements = []\n    for j in range(Ny - 1):\n        for i in range(Nx - 1):\n            n1 = j * Nx + i\n            n2 = n1 + 1\n            n3 = n2 + Nx\n            n4 = n1 + Nx\n            elements.append([n1, n2, n3, n4])\n            \n    return nodes, np.array(elements)\n\ndef compute_elasticity_matrix(E, nu):\n    \"\"\"Computes the plane strain elasticity matrix D.\"\"\"\n    factor = E / ((1 + nu) * (1 - 2 * nu))\n    D = factor * np.array([\n        [1 - nu, nu, 0],\n        [nu, 1 - nu, 0],\n        [0, 0, (1 - 2 * nu) / 2]\n    ])\n    return D\n\ndef get_shape_func_grads_parent(xi, eta):\n    \"\"\"Computes gradients of bilinear shape functions in the parent domain.\"\"\"\n    dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    return dN_dxi, dN_deta\n\ndef compute_stiffness_naive(nodes, elements, D):\n    \"\"\"Computes the global stiffness matrix using naive 1-point integration.\"\"\"\n    num_nodes = len(nodes)\n    K_global = np.zeros((2 * num_nodes, 2 * num_nodes))\n    \n    # Quadrature point at center of parent element\n    xi_c, eta_c = 0.0, 0.0\n    \n    for el_nodes_idx in elements:\n        coords = nodes[el_nodes_idx]\n        \n        # Derivatives of shape functions in parent coordinates at center\n        dN_dxi, dN_deta = get_shape_func_grads_parent(xi_c, eta_c)\n        \n        # Jacobian at center\n        J = np.zeros((2, 2))\n        J[0, 0] = np.dot(dN_dxi, coords[:, 0])\n        J[0, 1] = np.dot(dN_dxi, coords[:, 1])\n        J[1, 0] = np.dot(dN_deta, coords[:, 0])\n        J[1, 1] = np.dot(dN_deta, coords[:, 1])\n        \n        detJ = np.linalg.det(J)\n        A_e = detJ * 4.0 # For rectangular elements, Area = detJ * 4\n\n        J_inv = np.linalg.inv(J)\n        \n        # Derivatives of shape functions in physical coordinates\n        dN_dxy = J_inv @ np.vstack((dN_dxi, dN_deta))\n        \n        # Strain-displacement matrix B at center\n        B = np.zeros((3, 8))\n        for i in range(4):\n            B[0, 2*i] = dN_dxy[0, i]\n            B[1, 2*i+1] = dN_dxy[1, i]\n            B[2, 2*i] = dN_dxy[1, i]\n            B[2, 2*i+1] = dN_dxy[0, i]\n\n        # Element stiffness matrix\n        K_e = A_e * (B.T @ D @ B)\n        \n        # Assembly\n        dof_indices = np.array([[2*n, 2*n+1] for n in el_nodes_idx]).flatten()\n        K_global[np.ix_(dof_indices, dof_indices)] += K_e\n        \n    return K_global\n\ndef compute_stiffness_scni(nodes, elements, D):\n    \"\"\"Computes the global stiffness matrix using SCNI.\"\"\"\n    num_nodes = len(nodes)\n    K_global = np.zeros((2 * num_nodes, 2 * num_nodes))\n    \n    for el_nodes_idx in elements:\n        coords = nodes[el_nodes_idx]\n        \n        # Element area (for convex quads)\n        p1, p2, p3, p4 = coords\n        A_e = 0.5 * np.abs(np.cross(p3 - p1, p4 - p2))\n\n        # Smoothed strain-displacement matrix B_scni\n        B_scni = np.zeros((3, 8))\n        \n        for i in range(4):\n            # Node indices in CCW order\n            p_prev_idx = (i - 1 + 4) % 4\n            p_next_idx = (i + 1) % 4\n            \n            p_i = coords[i]\n            p_prev = coords[p_prev_idx]\n            p_next = coords[p_next_idx]\n            \n            # Vectors of edges connected to node i\n            v_prev = p_i - p_prev  # edge from prev to i\n            v_next = p_next - p_i  # edge from i to next\n            \n            # Outward normal contributions (normal vector * edge length)\n            n_prev = np.array([v_prev[1], -v_prev[0]])\n            n_next = np.array([v_next[1], -v_next[0]])\n            \n            # Smoothed gradient using boundary integral formula\n            grad_N_bar = (0.5 / A_e) * (n_prev + n_next)\n            \n            # Populate B_scni matrix\n            B_scni[0, 2*i] = grad_N_bar[0]\n            B_scni[1, 2*i+1] = grad_N_bar[1]\n            B_scni[2, 2*i] = grad_N_bar[1]\n            B_scni[2, 2*i+1] = grad_N_bar[0]\n            \n        # Element stiffness matrix\n        K_e = A_e * (B_scni.T @ D @ B_scni)\n        \n        # Assembly\n        dof_indices = np.array([[2*n, 2*n+1] for n in el_nodes_idx]).flatten()\n        K_global[np.ix_(dof_indices, dof_indices)] += K_e\n\n    return K_global\n\ndef count_spurious_modes(K, tol):\n    \"\"\"Computes number of spurious modes from stiffness matrix eigenvalues.\"\"\"\n    # Using eigh for symmetric matrices; it is faster and more stable.\n    # The eigenvalues are returned sorted.\n    eigvals = linalg.eigh(K, eigvals_only=True)\n    \n    # The largest eigenvalue is the last one\n    max_abs_eigval = np.abs(eigvals[-1]) if len(eigvals) > 0 else 0\n    if max_abs_eigval == 0:\n        return 0 # Trivial case\n\n    threshold = tol * max_abs_eigval\n    near_zero_count = np.sum(np.abs(eigvals) = threshold)\n    \n    # Spurious modes are near-zero eigenvalues beyond the 3 rigid body modes\n    num_rigid_body_modes = 3\n    spurious_count = max(0, near_zero_count - num_rigid_body_modes)\n    \n    return spurious_count\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}