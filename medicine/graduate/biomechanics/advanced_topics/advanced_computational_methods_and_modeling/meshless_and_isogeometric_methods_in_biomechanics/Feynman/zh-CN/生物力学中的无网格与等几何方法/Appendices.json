{
    "hands_on_practices": [
        {
            "introduction": "许多先进数值方法的一个标志性特征是它们能够精确表示简单的多项式场。在诸如再生核粒子法（RKPM）等无网格方法中，这被称为“再生条件”或一致性。本动手实践将指导您实现一个RKPM近似，以数值方式验证其一阶一致性，证明该方法能够以机器精度再现线性位移场。这项练习将加深您对这些方法为何功能强大且精确的理论基础的理解。",
            "id": "4190935",
            "problem": "考虑一个在小应变单轴拉伸下的软组织纤维的一维杆模型，该模型在域 $x \\in [0, L]$（其中 $L=1$）上进行理想化处理。在小应变线性弹性力学中，一个具有恒定轴向模量并在均匀轴向牵引力作用下的等截面杆的平衡状态，其精确位移场在空间上是线性的。在诸如再生核粒子法 (Reproducing Kernel Particle Method, RKPM) 的高级无网格方法中，如果近似满足一阶协调性，则应能精确地再生线性场。您的任务是从基本原理出发，实现一个一维的一阶协调 RKPM 近似，然后通过计算域上的位移误差范数来数值验证线性场是否被再生。\n\n从以下基础和事实出发：\n- 一维杆的小应变运动学和线性动量平衡表明，在均匀轴向载荷和适当的边界条件下，精确位移场是关于 $x$ 的线性函数。\n- 在再生核粒子法 (RKPM) 中，构造形函数以满足所选多项式基的再生条件。对于一维的一阶协调性，多项式基为 $p(x) = [1, x]^T$。为实现此目的，可以对相邻节点构建一个加权最小二乘拟合，其中权重（核函数）$w(r; h)$ 为正， $r$ 是距离， $h$ 是一个支撑参数。\n- 高斯核函数对所有 $r$ 均为正，其定义为 $w(r; h) = \\exp\\!\\left(-\\left(\\frac{r}{h}\\right)^2\\right)$。\n\n使用多项式基 $p(x) = [1, x]^T$ 和高斯核函数 $w(r; h) = \\exp\\!\\left(-\\left(\\frac{r}{h}\\right)^2\\right)$，推导在任意评估坐标 $x \\in [0, L]$ 处获得一阶协调 RKPM 形函数所需的离散方程。给定一组选定节点 $\\{x_i\\}_{i=1}^N$ 上的节点样本 $u_i = u(x_i)$，使用这些形函数为给定的精确位移场 $u(x) = a x + b$ 构建 RKPM 近似 $u_h(x)$。\n\n实现以下数值实验：\n- 域和单位：使用 $L = 1$，不为 $x$ 或 $u(x)$ 指定物理单位；计算一个无量纲的误差范数。任何三角函数都必须使用弧度作为角度单位。\n- 节点：对于每个测试用例，构建一组 $N$ 个节点 $\\{x_i\\}_{i=1}^N \\subset [0, L]$。对于均匀网格，在 $[0, L]$ 上均匀分布 $x_i$。对于抖动网格，从均匀网格开始，并如下文所述添加一个光滑的确定性扰动；确保 $x_1 = 0$ 和 $x_N = L$，并保持节点按升序排序。\n- 核函数：在所有测试用例中，使用高斯核函数 $w(r; h) = \\exp\\!\\left(-\\left(\\frac{r}{h}\\right)^2\\right)$，支撑参数为 $h = \\alpha \\Delta x$，其中 $\\Delta x$ 是平均节点间距，$\\alpha$ 由每个测试用例指定。\n- 场：对于每个测试用例，给定一个线性的精确位移场 $u(x) = a x + b$。\n- 近似：在任何评估点 $x$ 处，使用一阶再生条件构建一阶协调的 RKPM 近似 $u_h(x)$。在一组 $M$ 个均匀分布于 $[0, L]$ 上的采样点上评估该近似，其中 $M = 1001$。\n- 误差范数：通过复合中点或梯形法则计算位移误差在 $[0, L]$ 上的离散 $L^2$ 范数。具体来说，对于均匀样本，您可以近似为\n$$\n\\|e\\|_{L^2} \\approx \\left(\\sum_{j=1}^{M} \\left(u_h(x_j) - u(x_j)\\right)^2 \\, \\Delta x_s \\right)^{1/2},\n$$\n其中 $\\Delta x_s = \\frac{L}{M-1}$ 且 $\\{x_j\\}_{j=1}^{M}$ 是均匀采样点。将此范数报告为无量纲浮点数。\n\n测试套件（四个用例）：\n- 用例 1（理想路径，均匀网格，中等支撑）：$N = 41$，$\\alpha = 2.5$，$(a, b) = (1.5, -0.3)$，节点在 $[0, L]$ 上均匀分布。\n- 用例 2（通过确定性抖动生成的非均匀网格，中等支撑）：$N = 41$，$\\alpha = 2.0$，$(a, b) = (-2.2, 0.4)$，通过 $x_i \\leftarrow x_i + \\gamma \\Delta x \\sin\\!\\left(2 \\pi \\frac{i-1}{N-1}\\right)$（其中 $\\gamma = 0.2$）抖动均匀网格，然后裁剪到 $[0, L]$ 范围内，设置 $x_1 = 0$，$x_N = L$，并按升序排序。\n- 用例 3（近最小支撑，均匀网格）：$N = 41$，$\\alpha = 0.8$，$(a, b) = (0.75, 0.1)$，均匀节点。\n- 用例 4（带抖动的更精细网格，小支撑）：$N = 81$，$\\alpha = 1.2$，$(a, b) = (1.0, 0.0)$，按用例 2 的方式进行抖动，使用相同的 $\\gamma = 0.2$。\n\n要求的程序输出：\n- 您的程序必须生成单行输出，其中包含四个用例的四个误差范数，格式为方括号括起来的逗号分隔列表，例如 `[e_1,e_2,e_3,e_4]`，其中每个 `e_k` 是按上述顺序列出的用例 `k` 的浮点误差范数。输出必须只有一行，且不包含任何其他文本。\n\n您的实现必须是一个完整的、可运行的程序，该程序能够构建节点，用高斯核函数计算一阶协调的 RKPM 形函数，根据给定线性场的节点值构成 $u_h(x)$，按规定评估离散 $L^2$ 误差范数，并以所需格式打印出四个误差范数的列表。",
            "solution": "该问题要求对一维杆推导并实现一阶协调的再生核粒子法 (Reproducing Kernel Particle Method, RKPM) 近似。目标是数值验证该近似能精确再生线性位移场，这一性质被称为一阶协调性。验证将通过计算 RKPM 近似与已知线性场在几个测试用例中的离散 $L^2$ 误差范数来进行。\n\n构建满足特定协调性（或再生）条件的 RKPM 形函数的理论基础是移动最小二乘法 (moving least-squares, MLS)。我们首先推导一维场 $u(x)$ 的 MLS 近似。\n\n在任何评估点 $x \\in [0, L]$，我们为真实场 $u(y)$ 在点 $x$ 邻域内的点 $y$ 寻求一个局部多项式近似，记为 $u_h(y; x)$。为满足一阶协调性，该近似由一个线性基构造。问题中指定了全局坐标下的基为 $p(y) = [1, y]^T$。因此，局部近似可写为：\n$$\nu_h(y; x) = p^T(y) \\mathbf{a}(x) = a_1(x) + y a_2(x)\n$$\n其中 $\\mathbf{a}(x) = [a_1(x), a_2(x)]^T$ 是一个依赖于评估点 $x$ 的系数向量。这些系数通过对已知节点数据 $\\{ (x_i, u_i) \\}_{i=1}^N$ 进行加权最小二乘拟合来确定。待最小化的泛函为：\n$$\nJ(\\mathbf{a}) = \\sum_{i=1}^{N} \\left[ u_h(x_i; x) - u_i \\right]^2 w(x - x_i; h) = \\sum_{i=1}^{N} \\left[ p^T(x_i) \\mathbf{a}(x) - u_i \\right]^2 w(x - x_i; h)\n$$\n此处，$w(r; h)$ 是一个具有特征支撑尺寸 $h$ 的正权重或核函数。问题指定了高斯核函数 $w(r; h) = \\exp\\left(-(r/h)^2\\right)$。权重函数以评估点 $x$ 为中心，从而使最小二乘拟合局部化。\n\n为了找到最小化 $J(\\mathbf{a})$ 的系数 $\\mathbf{a}(x)$，我们将 $J$ 对 $\\mathbf{a}$ 求导并令其为零：\n$$\n\\frac{\\partial J}{\\partial \\mathbf{a}} = \\sum_{i=1}^{N} 2 \\left[ p^T(x_i) \\mathbf{a}(x) - u_i \\right] p(x_i) w(x - x_i; h) = \\mathbf{0}\n$$\n重新整理该表达式可得到正规方程组，这是一个关于 $\\mathbf{a}(x)$ 的线性方程组：\n$$\n\\left[ \\sum_{i=1}^{N} p(x_i) p^T(x_i) w(x - x_i; h) \\right] \\mathbf{a}(x) = \\sum_{i=1}^{N} p(x_i) u_i w(x - x_i; h)\n$$\n该系统可以写成矩阵形式：\n$$\n\\mathbf{M}(x) \\mathbf{a}(x) = \\mathbf{V}(x)\n$$\n其中 $\\mathbf{M}(x)$ 是 $2 \\times 2$ 的矩量矩阵：\n$$\n\\mathbf{M}(x) = \\sum_{i=1}^{N} p(x_i) p^T(x_i) w(x-x_i; h) = \\sum_{i=1}^{N} \\begin{pmatrix} 1 & x_i \\\\ x_i & x_i^2 \\end{pmatrix} w(x-x_i; h)\n$$\n而 $\\mathbf{V}(x)$ 是一个 $2 \\times 1$ 的向量：\n$$\n\\mathbf{V}(x) = \\sum_{i=1}^{N} p(x_i) u_i w(x-x_i; h) = \\sum_{i=1}^{N} \\begin{pmatrix} 1 \\\\ x_i \\end{pmatrix} u_i w(x-x_i; h)\n$$\n假设矩量矩阵 $\\mathbf{M}(x)$ 可逆，则系数向量为 $\\mathbf{a}(x) = \\mathbf{M}(x)^{-1} \\mathbf{V}(x)$。\n\n场在点 $x$ *处*的 RKPM 近似则通过在 $y=x$ 处评估局部近似 $u_h(y; x)$ 得到：\n$$\nu_h(x) = u_h(x; x) = p^T(x) \\mathbf{a}(x) = p^T(x) \\mathbf{M}(x)^{-1} \\mathbf{V}(x)\n$$\n代入 $\\mathbf{V}(x)$ 的表达式：\n$$\nu_h(x) = p^T(x) \\mathbf{M}(x)^{-1} \\left[ \\sum_{i=1}^{N} p(x_i) u_i w(x-x_i; h) \\right]\n$$\n这可以表示为离散近似的标准形式 $u_h(x) = \\sum_{i=1}^N \\Psi_i(x) u_i$，其中 $\\Psi_i(x)$ 是 RKPM 形函数。通过观察可得，节点 $i$ 在点 $x$ 处评估的形函数为：\n$$\n\\Psi_i(x) = p^T(x) \\mathbf{M}(x)^{-1} p(x_i) w(x-x_i; h)\n$$\n我们现在用代数方法验证这种构造能够精确再生任何线性场。假设节点值从线性场 $u(x) = ax + b$ 中采样得到，因此 $u_i = u(x_i) = a x_i + b$。我们可以用基 $p(x_i)$ 来表示它：\n$$\nu_i = \\begin{pmatrix} b & a \\end{pmatrix} \\begin{pmatrix} 1 \\\\ x_i \\end{pmatrix} = \\mathbf{c}^T p(x_i), \\quad \\text{with} \\quad \\mathbf{c} = \\begin{pmatrix} b \\\\ a \\end{pmatrix}\n$$\n将此代入 $u_h(x)$ 的表达式中：\n$$\nu_h(x) = p^T(x) \\mathbf{M}(x)^{-1} \\left[ \\sum_{i=1}^{N} p(x_i) (\\mathbf{c}^T p(x_i)) w(x-x_i; h) \\right]\n$$\n由于 $\\mathbf{c}^T p(x_i)$ 是一个标量，我们可以写成 $p(x_i) (\\mathbf{c}^T p(x_i)) = p(x_i) p^T(x_i) \\mathbf{c}$。这使我们能够提出常数向量 $\\mathbf{c}$：\n$$\nu_h(x) = p^T(x) \\mathbf{M}(x)^{-1} \\left[ \\sum_{i=1}^{N} p(x_i) p^T(x_i) w(x-x_i; h) \\right] \\mathbf{c}\n$$\n方括号中的项正是矩量矩阵 $\\mathbf{M}(x)$ 的定义。因此：\n$$\nu_h(x) = p^T(x) \\mathbf{M}(x)^{-1} \\mathbf{M}(x) \\mathbf{c} = p^T(x) \\mathbf{I} \\mathbf{c} = p^T(x) \\mathbf{c}\n$$\n其中 $\\mathbf{I}$ 是 $2 \\times 2$ 的单位矩阵。最后，代入 $p^T(x)$ 和 $\\mathbf{c}$ 的定义：\n$$\nu_h(x) = \\begin{pmatrix} 1 & x \\end{pmatrix} \\begin{pmatrix} b \\\\ a \\end{pmatrix} = 1 \\cdot b + x \\cdot a = ax + b\n$$\n这证明了对于任何线性场，只要 $\\mathbf{M}(x)$ 可逆，就有 $u_h(x) = u(x)$。只要存在至少两个具有非零权重 $w(x-x_i; h)$ 的不同节点 $\\{x_i\\}$，$\\mathbf{M}(x)$ 的可逆性就得到保证，而对于高斯核函数和任何 $N \\ge 2$ 的网格，这一条件都成立。\n\n对于数值实验，我们将实现以下步骤：\n1. 对于每个测试用例，我们在域 $[0, 1]$ 上生成一组 $N$ 个节点 $\\{x_i\\}_{i=1}^N$，节点可以是均匀分布的，也可以是带有指定的确定性抖动的。\n2. 核函数的支撑参数设置为 $h = \\alpha \\Delta x$，其中 $\\Delta x = 1/(N-1)$ 是初始均匀网格的间距。\n3. 使用特定用例的参数 $(a, b)$ 计算节点值 $u_i = u(x_i) = ax_i + b$。\n4. 在 $[0,1]$ 上创建一组 $M = 1001$ 个均匀评估点 $\\{x_j\\}_{j=1}^M$。\n5. 对于每个评估点 $x_j$，我们计算近似值 $u_h(x_j)$。这包括：\n   a. 通过对所有 $N$ 个节点的贡献求和，组装 $2 \\times 2$ 的矩量矩阵 $\\mathbf{M}(x_j)$ 和 $2 \\times 1$ 的向量 $\\mathbf{V}(x_j)$。\n   b. 求解线性系统 $\\mathbf{M}(x_j) \\mathbf{a}(x_j) = \\mathbf{V}(x_j)$，得到系数 $\\mathbf{a}(x_j)$。\n   c. 计算近似值 $u_h(x_j) = p^T(x_j) \\mathbf{a}(x_j)$。\n6. 计算完所有 $u_h(x_j)$ 后，离散 $L^2$ 误差范数按如下方式计算：\n$$\n\\|e\\|_{L^2} \\approx \\left(\\sum_{j=1}^{M} \\left(u_h(x_j) - u(x_j)\\right)^2 \\Delta x_s \\right)^{1/2}\n$$\n其中 $u(x_j)$ 是在评估点处的精确值，且 $\\Delta x_s = L/(M-1) = 1/(1000)$。\n鉴于代数证明，计算出的误差范数应在机器浮点精度的数量级上（对于双精度，约为 $10^{-15}$ 到 $10^{-16}$）。任何显著的偏差都将表明存在数值病态问题，例如，如果支撑参数 $h$ 太小或太大，尽管所选参数应该是良态的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a first-order consistent RKPM approximation in 1D\n    to verify that linear fields are reproduced exactly.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 41, 'alpha': 2.5, 'a': 1.5, 'b': -0.3, 'jitter': False},\n        {'N': 41, 'alpha': 2.0, 'a': -2.2, 'b': 0.4, 'jitter': True, 'gamma': 0.2},\n        {'N': 41, 'alpha': 0.8, 'a': 0.75, 'b': 0.1, 'jitter': False},\n        {'N': 81, 'alpha': 1.2, 'a': 1.0, 'b': 0.0, 'jitter': True, 'gamma': 0.2},\n    ]\n\n    L = 1.0\n    M = 1001  # Number of evaluation points for error norm calculation\n\n    # Uniform evaluation points for error calculation\n    eval_points = np.linspace(0.0, L, M)\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        alpha = case['alpha']\n        a_coeff = case['a']\n        b_coeff = case['b']\n\n        # 1. Generate nodes {x_i}\n        # The problem implies delta_x is based on the uniform grid for all cases\n        delta_x_uniform = L / (N - 1)\n        nodes = np.linspace(0.0, L, N)\n\n        if case['jitter']:\n            gamma = case['gamma']\n            # i=1,...,N corresponds to array indices 0,...,N-1\n            indices = np.arange(N)\n            perturbation = gamma * delta_x_uniform * np.sin(2 * np.pi * indices / (N - 1))\n            \n            nodes = nodes + perturbation\n            \n            # Clip, fix boundaries, and sort\n            nodes = np.clip(nodes, 0.0, L)\n            nodes[0] = 0.0\n            nodes[-1] = L\n            nodes.sort()\n\n        # 2. Define kernel, field, and get nodal values\n        h = alpha * delta_x_uniform\n\n        def kernel(r, h_val):\n            return np.exp(-(r / h_val)**2)\n\n        def u_exact(x):\n            return a_coeff * x + b_coeff\n\n        nodal_displacements = u_exact(nodes)\n\n        # 3. Evaluate RKPM approximation u_h(x) at each evaluation point\n        u_h_values = np.zeros(M)\n\n        for j, x_eval in enumerate(eval_points):\n            # Assemble moment matrix M(x) and vector V(x)\n            moment_matrix = np.zeros((2, 2))\n            rhs_vector = np.zeros(2)\n\n            for i in range(N):\n                xi = nodes[i]\n                ui = nodal_displacements[i]\n                w = kernel(x_eval - xi, h)\n                \n                p_i = np.array([1.0, xi])\n                \n                # M = sum(p_i * p_i^T * w_i)\n                moment_matrix += w * np.outer(p_i, p_i)\n                # V = sum(p_i * u_i * w_i)\n                rhs_vector += w * p_i * ui\n            \n            # Solve M(x) * a(x) = V(x) for coefficients a(x)\n            try:\n                coeffs = np.linalg.solve(moment_matrix, rhs_vector)\n            except np.linalg.LinAlgError:\n                # This should not occur with the given problem parameters\n                coeffs = np.array([np.nan, np.nan])\n\n            # Evaluate approximation u_h(x) = p^T(x) * a(x)\n            p_eval = np.array([1.0, x_eval])\n            u_h_values[j] = p_eval @ coeffs\n\n        # 4. Compute discrete L2 error norm\n        exact_values_at_eval = u_exact(eval_points)\n        errors = u_h_values - exact_values_at_eval\n\n        # Guard against NaN from failed linear solve\n        if np.any(np.isnan(errors)):\n            l2_error_norm = np.nan\n        else:\n            delta_xs = L / (M - 1)\n            l2_error_norm = np.sqrt(np.sum(errors**2) * delta_xs)\n        \n        results.append(l2_error_norm)\n\n    # Final print statement in the exact required format.\n    # The output should show values very close to zero, so scientific notation is appropriate.\n    print(f\"[{','.join([f'{norm:.16e}' for norm in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "等几何分析（IGA）通过对几何和分析使用相同的基函数，统一了计算机辅助设计（CAD）和有限元分析的世界。IGA的一个关键特性是能够通过直接操纵控制变量来精确施加本质边界条件。本实践探讨了如何在B样条基函数中使用开放节点矢量，在定义域的端点上产生插值行为，从而让您能够通过直接设定边界位移来解决一个简单的生物力学问题。",
            "id": "4190908",
            "problem": "一段直的、轴向可变形的软组织肌腱段被建模为一根一维杆，占据物理域 $x \\in [0,L]$，具有恒定的横截面积 $A$ 和杨氏模量 $E$。该肌腱沿 $+x$ 方向承受均匀的轴向分布载荷 $q$（单位长度上的力）。运动学关系为小应变，轴向应变定义为 $\\varepsilon(x) = \\frac{du}{dx}$，其中 $u(x)$ 是轴向位移场。本构关系为线性弹性，即 $\\sigma(x) = E\\,\\varepsilon(x)$，其弱形式源于虚功原理。\n\n您将使用等几何分析 (IGA) 对此问题进行离散化，采用一个特化为非有理 B 样条的二次开放非均匀有理 B 样条 (NURBS) 基。设参数域为 $\\xi \\in [0,1]$，开放节点矢量为 $\\mathcal{U} = [0,0,0,1,1,1]$，几何的三个控制点分别放置在 $X_1 = 0$、$X_2 = \\frac{L}{2}$ 和 $X_3 = L$。位移场 $u(x)$ 使用与几何映射相同的二次开放 B 样条基。假设在 $x=L$ 处面力为零。\n\n任务：\n- 从承受分布轴向载荷和小应变的一维线性弹性杆的弱形式出发，构造在 $\\mathcal{U}$ 上的二次开放 B 样条基，证明该开放节点矢量在边界处恢复了插值控制，并解释为什么本质边界条件可以直接施加在末端控制变量上。然后，通过直接设置相应的位移控制变量来施加本质边界条件 $u(0) = 0$ 和 $u(L) = 0$。\n- 在强制施加这些边界条件后，通过组装内部虚功的刚度贡献和外部虚功的载荷贡献，推导剩余位移控制变量的单个标量方程，同时遵循由几何控制点引起的等参数映射。\n- 使用以下物理参数：$L = 0.1\\,\\text{m}$、$A = 1.0 \\times 10^{-4}\\,\\text{m}^2$、$E = 1.5 \\times 10^{6}\\,\\text{Pa}$ 和 $q = 10\\,\\text{N}\\,\\text{m}^{-1}$，计算剩余位移控制变量的值。\n\n将剩余位移控制变量的最终答案以米为单位表示，并四舍五入到四位有效数字。最终答案必须是一个实数。",
            "solution": "基本模型是轴向可变形杆的一维线性弹性模型，该模型处于小应变和线性本构行为下。轴向应变为 $\\varepsilon(x) = \\frac{du}{dx}$，应力为 $\\sigma(x) = E\\,\\varepsilon(x)$，内部虚功为 $\\delta W_{\\text{int}} = \\int_{0}^{L} E A \\frac{du}{dx} \\frac{d \\delta u}{dx}\\, dx$。由分布轴向载荷 $q$ 引起的外部虚功为 $\\delta W_{\\text{ext}} = \\int_{0}^{L} q\\, \\delta u\\, dx$，并假设在 $x=L$ 处端部面力为零。弱形式为：在满足本质边界条件的适当空间中找到 $u$，使得\n$$\n\\int_{0}^{L} E A \\frac{du}{dx} \\frac{d \\delta u}{dx}\\, dx = \\int_{0}^{L} q\\, \\delta u\\, dx \\quad \\text{对于所有容许的 } \\delta u.\n$$\n\n在等几何分析 (IGA) 中，用于几何的基也同样用于位移场。我们采用参数域 $\\xi \\in [0,1]$ 上的一个二次开放 B 样条基，其开放节点矢量为 $\\mathcal{U} = [0,0,0,1,1,1]$。这产生了 $p+1=3$ 个基函数，对于这个单个单元，它们与二次伯恩斯坦多项式重合：\n$$\nN_1(\\xi) = (1 - \\xi)^{2}, \\quad N_2(\\xi) = 2 \\xi (1 - \\xi), \\quad N_3(\\xi) = \\xi^{2}.\n$$\n开放节点矢量确保了端点基函数在边界处具有插值性：\n$$\nN_1(0) = 1, \\quad N_2(0) = 0, \\quad N_3(0) = 0; \\qquad N_1(1) = 0, \\quad N_2(1) = 0, \\quad N_3(1) = 1.\n$$\n因此，当几何映射将物理端点置于 $\\xi=0$ 和 $\\xi=1$ 时，与第一个和最后一个基函数对应的位移控制变量直接给出了物理端点处的位移。\n\n我们使用相同的基函数和控制点 $X_i$ 来构造几何映射 $x(\\xi)$：\n$$\nx(\\xi) = N_1(\\xi) X_1 + N_2(\\xi) X_2 + N_3(\\xi) X_3.\n$$\n当 $X_1 = 0$，$X_2 = \\frac{L}{2}$ 和 $X_3 = L$ 时，我们得到\n$$\nx(\\xi) = (1 - \\xi)^{2} \\cdot 0 + 2 \\xi (1 - \\xi) \\cdot \\frac{L}{2} + \\xi^{2} \\cdot L = L \\left[\\xi (1 - \\xi) + \\xi^{2} \\right] = L \\xi,\n$$\n这是一个线性等参数映射，因此 $\\frac{d\\xi}{dx} = \\frac{1}{L}$ 且 $dx = L\\, d\\xi$。\n\n我们将位移场近似为\n$$\nu(x(\\xi)) = \\sum_{i=1}^{3} N_i(\\xi) d_i,\n$$\n其中 $d_i$ 是位移控制变量。由于边界处的插值特性，并且几何映射将 $x=0$ 置于 $\\xi=0$、将 $x=L$ 置于 $\\xi=1$，本质边界条件 $u(0) = 0$ 和 $u(L) = 0$ 直接施加为\n$$\nd_1 = 0, \\qquad d_3 = 0.\n$$\n因此，只有 $d_2$ 仍然是未知的。\n\n我们从弱形式中为 $d_2$ 推导离散方程。内部虚功的贡献导出了刚度项\n$$\nK_{22} = \\int_{0}^{L} E A \\left( \\frac{dN_2}{dx} \\right) \\left( \\frac{dN_2}{dx} \\right) dx.\n$$\n使用等参数映射，$\\frac{dN_2}{dx} = \\frac{dN_2}{d\\xi} \\frac{d\\xi}{dx} = \\frac{1}{L} \\frac{dN_2}{d\\xi}$，且 $dx = L\\, d\\xi$，我们得到\n$$\nK_{22} = \\int_{0}^{1} E A \\left( \\frac{1}{L} \\frac{dN_2}{d\\xi} \\right)^{2} L\\, d\\xi = \\frac{E A}{L} \\int_{0}^{1} \\left( \\frac{dN_2}{d\\xi} \\right)^{2} d\\xi.\n$$\n对于 $N_2(\\xi) = 2 \\xi (1 - \\xi)$，我们计算\n$$\n\\frac{dN_2}{d\\xi} = 2(1 - 2\\xi),\n$$\n所以\n$$\nK_{22} = \\frac{E A}{L} \\int_{0}^{1} 4 (1 - 2\\xi)^{2} d\\xi = \\frac{E A}{L} \\cdot 4 \\int_{0}^{1} \\left( 1 - 4\\xi + 4\\xi^{2} \\right) d\\xi = \\frac{E A}{L} \\cdot 4 \\left( 1 - 2 + \\frac{4}{3} \\right) = \\frac{4 E A}{3 L}.\n$$\n\n外部虚功的贡献给出了载荷向量项\n$$\nF_{2} = \\int_{0}^{L} q\\, N_2\\, dx = \\int_{0}^{1} q\\, N_2(\\xi)\\, L\\, d\\xi = q L \\int_{0}^{1} 2 \\xi (1 - \\xi)\\, d\\xi.\n$$\n我们计算\n$$\n\\int_{0}^{1} 2 \\xi (1 - \\xi)\\, d\\xi = \\int_{0}^{1} \\left( 2\\xi - 2\\xi^{2} \\right) d\\xi = \\left[ \\xi^{2} - \\frac{2}{3}\\xi^{3} \\right]_{0}^{1} = 1 - \\frac{2}{3} = \\frac{1}{3},\n$$\n因此\n$$\nF_{2} = \\frac{q L}{3}.\n$$\n\n在施加 $d_1 = 0$ 和 $d_3 = 0$ 后，针对单个未知数的简化离散方程变为\n$$\nK_{22}\\, d_2 = F_2,\n$$\n所以\n$$\nd_2 = \\frac{F_2}{K_{22}} = \\frac{\\frac{q L}{3}}{\\frac{4 E A}{3 L}} = \\frac{q L^{2}}{4 E A}.\n$$\n\n现在我们代入给定的物理参数，在最后一步之前保持符号推理。对于 $L = 0.1\\,\\text{m}$、$A = 1.0 \\times 10^{-4}\\,\\text{m}^{2}$、$E = 1.5 \\times 10^{6}\\,\\text{Pa}$ 和 $q = 10\\,\\text{N}\\,\\text{m}^{-1}$，我们发现\n$$\nE A = \\left(1.5 \\times 10^{6}\\right) \\left(1.0 \\times 10^{-4}\\right) = 1.5 \\times 10^{2} = 150,\n$$\n$$\nL^{2} = \\left( 0.1 \\right)^{2} = 1.0 \\times 10^{-2} = 0.01,\n$$\n因此\n$$\nd_2 = \\frac{q L^{2}}{4 E A} = \\frac{10 \\times 0.01}{4 \\times 150} = \\frac{0.1}{600} = \\frac{1}{6000} = 1.666\\ldots \\times 10^{-4}.\n$$\n四舍五入到四位有效数字，位移控制变量为\n$$\nd_2 \\approx 0.0001667 \\quad \\text{米}.\n$$\n\n这个构造过程表明，开放节点矢量在边界处恢复了插值控制，允许通过 $d_1$ 和 $d_3$ 直接施加本质边界条件，并得出了一个单一标量未知数 $d_2$，其值通过弱形式从第一性原理计算得出。",
            "answer": "$$\\boxed{0.0001667}$$"
        },
        {
            "introduction": "尽管计算效率高，但简化的数值积分方案有时会引入非物理的不稳定性，即所谓的伪零能模式或“沙漏”模式，这会污染求解结果。本高阶实践通过让您实现稳定共轭节点积分（SCNI）方法来解决这个关键问题。通过比较标准减缩积分刚度矩阵与经SCNI校正后矩阵的特征值谱，您将能够量化并验证这些伪模式的消除，这是实现稳健模拟的关键一步。",
            "id": "4190921",
            "problem": "给定一个代表软组织样本的二维线性弹性补片。该离散化使用双线性四边形基，其等效于 1 次等几何映射（一种具有均匀节点的非均匀有理 B 样条 (NURBS) 的特例）。目标是通过第一性原理和算法构造，演示稳定共形节点积分 (SCNI) 如何减轻在欠积分刚度公式中出现的伪零能模式（沙漏模式）。\n\n从平面应变条件下各向同性材料的小应变线性弹性理论出发。变形映射由位移场 $(u_x(x,y),u_y(x,y))$ 表征，应变向量为 $\\boldsymbol{\\varepsilon}=[\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy}]^\\top$，其中 $\\gamma_{xy}=2\\varepsilon_{xy}$。本构关系为 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{D}$ 是平面应变的对称弹性矩阵。根据虚功原理，刚度矩阵 $\\mathbf{K}$ 可表示为\n$$\n\\mathbf{K} = \\int_{\\Omega} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} \\,\\mathrm{d}\\Omega,\n$$\n其中 $\\mathbf{B}$ 是由形函数的空间梯度构建的应变-位移矩阵。\n\n对于双线性四边形单元的节点积分或减缩积分，每个单元使用单点计算积分会导致秩亏和伪零能模式（沙漏模式）。SCNI 方法通过散度定理在节点域或单元域上构造一个平滑梯度。对于一个边界为 $\\partial\\Omega_s$、外单位法向量为 $\\mathbf{n}$ 的平滑单元 $\\Omega_s$：\n$$\n\\overline{\\nabla N_i} = \\frac{1}{|\\Omega_s|}\\int_{\\partial\\Omega_s} N_i \\,\\mathbf{n}\\,\\mathrm{d}s.\n$$\n在 $\\mathbf{B}$ 中用平滑梯度 $\\overline{\\nabla N_i}$ 替代原始梯度 $\\nabla N_i$，可以得到一个修正后的刚度，从而减少伪模式。\n\n为以下测试套件实现这两种公式，并比较 $\\mathbf{K}$ 的特征值中除刚体模式外的近零特征值的数量。对于一个无约束的平面体，存在正好 $3$ 种刚体模式，对应于两个平移和一个旋转，因此任何额外的近零特征值都量化了伪模式。\n\n所有情况均使用以下材料属性：杨氏模量 $E=10000$ (帕斯卡)，泊松比 $\\nu=0.45$，平面应变条件，单位厚度 $t=1$。几何布局为具有均匀节点网格的轴对齐矩形。每个四边形单元由四个相邻节点按逆时针顺序构成。不施加本质边界条件；刚度矩阵在自由状态下进行分析。\n\n使用相对阈值 $\\tau$ 乘以最大特征值模来定义近零特征值：如果一个特征值 $\\lambda$ 满足 $|\\lambda| \\le \\tau \\max_i |\\lambda_i|$，则其被分类为近零特征值。设置 $\\tau=10^{-8}$。伪模式的数量等于近零特征值的计数减去 $3$（如果差值为负，则取 $0$）。\n\n测试套件：\n- 情况 1 (均衡补片): 域尺寸 $L_x=1.0$, $L_y=1.0$, 节点网格 $N_x=3$, $N_y=3$。\n- 情况 2 (细长补片): 域尺寸 $L_x=2.0$, $L_y=0.5$, 节点网格 $N_x=5$, $N_y=2$。\n- 情况 3 (单个单元): 域尺寸 $L_x=1.0$, $L_y=1.0$, 节点网格 $N_x=2$, $N_y=2$。\n\n算法要求：\n- 为每种情况构造全局刚度矩阵 $\\mathbf{K}_{\\text{naive}}$ 和 $\\mathbf{K}_{\\text{SCNI}}$：\n  - 对于朴素的欠积分公式，在父空间 $[-1,1]^2$ 中，使用单元中心 $(\\xi,\\eta)=(0,0)$ 处的单个求积点（权重 $w=4$）来近似单元刚度，并通过中心点的雅可比矩阵映射梯度。\n  - 对于 SCNI 公式，通过在单元多边形上应用散度定理来计算每个单元的平滑梯度。在父坐标系下，对每条边使用 2 点高斯法则来计算 $\\int_{\\partial\\Omega_e} N_i \\,\\mathbf{n}\\,\\mathrm{d}s$，其中外法线由物理边向量构造。单元刚度为 $\\mathbf{K}_e^{\\text{SCNI}} = |\\Omega_e|\\,\\mathbf{B}_{\\text{SCNI}}^\\top \\mathbf{D}\\mathbf{B}_{\\text{SCNI}}$，其中 $\\mathbf{B}_{\\text{SCNI}}$ 对每个节点使用 $\\overline{\\nabla N_i}$。\n- 利用标准的有限元连接关系，从单元贡献组装全局矩阵。\n- 计算每个全局刚度的所有特征值，并按规定计算伪模式的数量。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含每种情况的结果：朴素公式的伪模式数量，然后是 SCNI 公式的伪模式数量。因此，最终输出必须是以下形式：$[s_1^{\\text{naive}},s_1^{\\text{SCNI}},s_2^{\\text{naive}},s_2^{\\text{SCNI}},s_3^{\\text{naive}},s_3^{\\text{SCNI}}]$，其中每个 $s_k$ 都是一个整数。",
            "solution": "该问题陈述经评估有效。它在科学上基于连续介质力学和有限元方法，问题设定良好，目标明确，数据齐全，并使用精确、客观的语言进行表述。该任务是计算固体力学中一个标准的、非平凡的练习，要求实现并比较两种不同的单元刚度矩阵公式，以演示一个已知的数值伪影及其稳定化方法。\n\n解决方案如下。首先，我们建立使用双线性四边形单元的二维线性弹性的理论背景。其次，我们详细说明使用两种方法构造全局刚度矩阵 $\\mathbf{K}$ 的过程：一种是朴素的单点欠积分方案，另一种是稳定共形节点积分 (SCNI) 方法。最后，我们提供分析所得矩阵的特征谱以量化伪零能模式的实现细节。\n\n**1. 理论框架**\n\n分析基于平面应变条件下的小应变线性弹性理论。位移场为 $\\mathbf{u} = (u_x, u_y)^\\top$。无穷小应变张量分量排列成一个向量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top$，其中 $\\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x}$，$\\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y}$，工程剪切应变为 $\\gamma_{xy} = \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x}$。\n\n应变场通过应变-位移矩阵 $\\mathbf{B}$ 与节点位移 $\\mathbf{d}$ 相关联，即 $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{d}$。对于一个有 $4$ 个节点的单个四边形单元，节点位移向量为 $\\mathbf{d}_e \\in \\mathbb{R}^8$。矩阵 $\\mathbf{B}$ 由单元形函数 $N_i$ 的空间导数构造而成。对于节点 $i$，其对 $\\mathbf{B}$ 矩阵的贡献为 $\\mathbf{B}_i = \\begin{pmatrix} \\partial N_i / \\partial x & 0 \\\\ 0 & \\partial N_i / \\partial y \\\\ \\partial N_i / \\partial y & \\partial N_i / \\partial x \\end{pmatrix}$。完整的单元矩阵为 $\\mathbf{B}_e = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]$。\n\n材料是各向同性的线弹性体，因此应力向量 $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^\\top$ 通过本构矩阵 $\\mathbf{D}$ 与应变相关：$\\boldsymbol{\\sigma} = \\mathbf{D}\\boldsymbol{\\varepsilon}$。对于平面应变，矩阵 $\\mathbf{D}$ 由下式给出：\n$$\n\\mathbf{D} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & \\frac{1-2\\nu}{2} \\end{pmatrix}\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n\n单元刚度矩阵 $\\mathbf{K}_e$ 由虚功原理导出，并通过在单元域 $\\Omega_e$ 上的积分给出：\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega\n$$\n\n**2. 双线性四边形单元**\n\n我们使用标准的等参公式。单元内的几何形状和位移场使用定义在父域 $[-1, 1]^2$ 上的双线性形函数 $N_i(\\xi, \\eta)$ 从节点值插值得到：\n$N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$, $N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$, $N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$, $N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$。\n形函数的空间导数 $\\nabla_x N_i = (\\partial N_i / \\partial x, \\partial N_i / \\partial y)^\\top$ 通过链式法则和雅可比矩阵 $\\mathbf{J}$ 的逆求得：$\\nabla_x N_i = \\mathbf{J}^{-1} \\nabla_\\xi N_i$。\n\n**3. 朴素的欠积分公式 ($\\mathbf{K}_{\\text{naive}}$)**\n\n此公式使用父单元中心 $(\\xi, \\eta) = (0, 0)$ 处的单个高斯求积点来近似刚度积分。在 $[-1, 1]^2$ 上，该法则的权重为 $w=4$。单元刚度矩阵为：\n$$\n\\mathbf{K}_e^{\\text{naive}} \\approx \\left(\\mathbf{B}^\\top \\mathbf{D} \\mathbf{B}\\right)|_{(\\xi, \\eta)=(0,0)} \\det(\\mathbf{J}(0,0)) \\cdot w\n$$\n对于面积为 $|\\Omega_e|$ 的矩形单元，$\\det(\\mathbf{J})$ 是常数且等于 $|\\Omega_e|/4$。公式简化为：\n$$\n\\mathbf{K}_e^{\\text{naive}} = |\\Omega_e| \\, \\mathbf{B}(0,0)^\\top \\mathbf{D} \\mathbf{B}(0,0)\n$$\n在单元中心，形函数的导数表现出某些对称性，这使得应变能为零的非物理变形模式（沙漏模式）得以存在。这导致单元刚度矩阵秩亏，并进一步导致全局刚度矩阵 $\\mathbf{K}_{\\text{naive}}$ 秩亏，从而在三个刚体模式（两个平移，一个旋转）之外产生伪零能模式。\n\n**4. 稳定共形节点积分 ($\\mathbf{K}_{\\text{SCNI}}$)**\n\nSCNI 方法通过使用平滑梯度 $\\overline{\\nabla N_i}$ 替代标准梯度 $\\nabla N_i$ 来修正这种秩亏。平滑梯度是在一个平滑域上的平均梯度，对于本问题，该域就是单元本身（$\\Omega_s = \\Omega_e$）。根据散度定理，这个平均值通过边界积分计算：\n$$\n\\overline{\\nabla N_i} = \\frac{1}{|\\Omega_e|}\\int_{\\partial\\Omega_e} N_i \\, \\mathbf{n} \\, \\mathrm{d}s\n$$\n其中 $\\mathbf{n}$ 是边界 $\\partial\\Omega_e$ 的外单位法向量。该积分通过对四个单元边的贡献求和来进行数值计算。\n$$\n\\int_{\\partial\\Omega_e} N_i \\, \\mathbf{n} \\, \\mathrm{d}s = \\sum_{j=1}^4 \\int_{\\text{edge}_j} N_i \\, \\mathbf{n}_j \\, \\mathrm{d}s\n$$\n对于节点 $a$ 和 $b$ 之间的直边 $j$，法向量 $\\mathbf{n}_j$ 是恒定的。形函数 $N_i$ 沿该边的积分仅当节点 $i$ 是该边的端点之一时（$i=a$ 或 $i=b$）才非零。该积分在父域边上使用 2 点高斯法则计算。对于沿边的线性形函数，此积分为精确积分，对于 $i \\in \\{a,b\\}$，其结果为 $\\int_{\\text{edge}_j}N_i ds = L_j/2$，其中 $L_j$ 是边的长度。\n\n对于节点 $i$（连接到边 $j$ 和 $k$），总边界积分为 $\\frac{1}{2}(L_j \\mathbf{n}_j + L_k \\mathbf{n}_k)$。设 $\\mathbf{v}_j = \\mathbf{x}_i - \\mathbf{x}_{\\text{prev}}$ 和 $\\mathbf{v}_k = \\mathbf{x}_{\\text{next}} - \\mathbf{x}_i$ 为边向量。法向贡献为 $L_j\\mathbf{n}_j = (v_{jy}, -v_{jx})$ 和 $L_k\\mathbf{n}_k = (v_{ky}, -v_{kx})$。平滑梯度为：\n$$\n\\overline{\\nabla N_i} = \\frac{1}{2|\\Omega_e|} ((v_{jy}, -v_{jx}) + (v_{ky}, -v_{kx}))\n$$\n然后，使用此平滑梯度 $\\overline{\\nabla N_i} = (\\overline{N_{i,x}}, \\overline{N_{i,y}})^\\top$ 为单元构造一个恒定的、平滑的应变-位移矩阵 $\\mathbf{B}_{\\text{SCNI}}$。SCNI 单元刚度矩阵则为：\n$$\n\\mathbf{K}_e^{\\text{SCNI}} = |\\Omega_e|\\, \\mathbf{B}_{\\text{SCNI}}^\\top \\mathbf{D} \\mathbf{B}_{\\text{SCNI}}\n$$\n此公式旨在具有正确的秩（即，对于单个无约束单元，零度为 $3$，对应于刚体模式），从而消除伪零能模式。\n\n**5. 组装与分析**\n\n对于这两种方法，单元刚度矩阵 $\\mathbf{K}_e$ 都使用基于单元连接关系的标准有限元程序组装成各自的全局刚度矩阵 $\\mathbf{K}_{\\text{naive}}$ 和 $\\mathbf{K}_{\\text{SCNI}}$。\n\n最后一步是分析这些全局矩阵的特征谱。计算特征值 $\\lambda_i$。如果一个特征值满足 $|\\lambda_i| \\le \\tau \\max_j|\\lambda_j|$（给定阈值 $\\tau=10^{-8}$），则被分类为“近零”特征值。伪模式的数量是近零特征值的计数减去 $3$ 个预期的刚体模式。如果此差值为负，则计数为 $0$。对每个测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print results.\n    \"\"\"\n    \n    # Material and analysis parameters from the problem statement\n    E = 10000.0  # Young's modulus\n    nu = 0.45    # Poisson's ratio\n    tau = 1e-8   # Eigenvalue threshold\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (Lx, Ly, Nx, Ny)\n        (1.0, 1.0, 3, 3),  # Case 1: balanced patch\n        (2.0, 0.5, 5, 2),  # Case 2: slender patch\n        (1.0, 1.0, 2, 2),  # Case 3: single element\n    ]\n\n    results = []\n    for Lx, Ly, Nx, Ny in test_cases:\n        # 1. Generate mesh and constitutive matrix\n        nodes, elements = generate_mesh(Lx, Ly, Nx, Ny)\n        D = compute_elasticity_matrix(E, nu)\n\n        # 2. Compute stiffness matrices for both formulations\n        K_naive = compute_stiffness_naive(nodes, elements, D)\n        K_scni = compute_stiffness_scni(nodes, elements, D)\n\n        # 3. Count spurious modes for each matrix\n        s_naive = count_spurious_modes(K_naive, tau)\n        s_scni = count_spurious_modes(K_scni, tau)\n        \n        results.extend([s_naive, s_scni])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_mesh(Lx, Ly, Nx, Ny):\n    \"\"\"Generates nodal coordinates and element connectivity for a rectangular grid.\"\"\"\n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    nodes = np.array([[xi, yi] for yi in y for xi in x])\n    \n    elements = []\n    for j in range(Ny - 1):\n        for i in range(Nx - 1):\n            n1 = j * Nx + i\n            n2 = n1 + 1\n            n3 = n2 + Nx\n            n4 = n1 + Nx\n            elements.append([n1, n2, n3, n4])\n            \n    return nodes, np.array(elements)\n\ndef compute_elasticity_matrix(E, nu):\n    \"\"\"Computes the plane strain elasticity matrix D.\"\"\"\n    factor = E / ((1 + nu) * (1 - 2 * nu))\n    D = factor * np.array([\n        [1 - nu, nu, 0],\n        [nu, 1 - nu, 0],\n        [0, 0, (1 - 2 * nu) / 2]\n    ])\n    return D\n\ndef get_shape_func_grads_parent(xi, eta):\n    \"\"\"Computes gradients of bilinear shape functions in the parent domain.\"\"\"\n    dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    return dN_dxi, dN_deta\n\ndef compute_stiffness_naive(nodes, elements, D):\n    \"\"\"Computes the global stiffness matrix using naive 1-point integration.\"\"\"\n    num_nodes = len(nodes)\n    K_global = np.zeros((2 * num_nodes, 2 * num_nodes))\n    \n    # Quadrature point at center of parent element\n    xi_c, eta_c = 0.0, 0.0\n    \n    for el_nodes_idx in elements:\n        coords = nodes[el_nodes_idx]\n        \n        # Derivatives of shape functions in parent coordinates at center\n        dN_dxi, dN_deta = get_shape_func_grads_parent(xi_c, eta_c)\n        \n        # Jacobian at center\n        J = np.zeros((2, 2))\n        J[0, 0] = np.dot(dN_dxi, coords[:, 0])\n        J[0, 1] = np.dot(dN_dxi, coords[:, 1])\n        J[1, 0] = np.dot(dN_deta, coords[:, 0])\n        J[1, 1] = np.dot(dN_deta, coords[:, 1])\n        \n        detJ = np.linalg.det(J)\n        A_e = detJ * 4.0 # For rectangular elements, Area = detJ * 4\n\n        J_inv = np.linalg.inv(J)\n        \n        # Derivatives of shape functions in physical coordinates\n        dN_dxy = J_inv @ np.vstack((dN_dxi, dN_deta))\n        \n        # Strain-displacement matrix B at center\n        B = np.zeros((3, 8))\n        for i in range(4):\n            B[0, 2*i] = dN_dxy[0, i]\n            B[1, 2*i+1] = dN_dxy[1, i]\n            B[2, 2*i] = dN_dxy[1, i]\n            B[2, 2*i+1] = dN_dxy[0, i]\n\n        # Element stiffness matrix\n        K_e = A_e * (B.T @ D @ B)\n        \n        # Assembly\n        dof_indices = np.array([[2*n, 2*n+1] for n in el_nodes_idx]).flatten()\n        K_global[np.ix_(dof_indices, dof_indices)] += K_e\n        \n    return K_global\n\ndef compute_stiffness_scni(nodes, elements, D):\n    \"\"\"Computes the global stiffness matrix using SCNI.\"\"\"\n    num_nodes = len(nodes)\n    K_global = np.zeros((2 * num_nodes, 2 * num_nodes))\n    \n    for el_nodes_idx in elements:\n        coords = nodes[el_nodes_idx]\n        \n        # Element area (for convex quads)\n        p1, p2, p3, p4 = coords\n        A_e = 0.5 * np.abs(np.cross(p3 - p1, p4 - p2))\n\n        # Smoothed strain-displacement matrix B_scni\n        B_scni = np.zeros((3, 8))\n        \n        for i in range(4):\n            # Node indices in CCW order\n            p_prev_idx = (i - 1 + 4) % 4\n            p_next_idx = (i + 1) % 4\n            \n            p_i = coords[i]\n            p_prev = coords[p_prev_idx]\n            p_next = coords[p_next_idx]\n            \n            # Vectors of edges connected to node i\n            v_prev = p_i - p_prev  # edge from prev to i\n            v_next = p_next - p_i  # edge from i to next\n            \n            # Outward normal contributions (normal vector * edge length)\n            n_prev = np.array([v_prev[1], -v_prev[0]])\n            n_next = np.array([v_next[1], -v_next[0]])\n            \n            # Smoothed gradient using boundary integral formula\n            grad_N_bar = (0.5 / A_e) * (n_prev + n_next)\n            \n            # Populate B_scni matrix\n            B_scni[0, 2*i] = grad_N_bar[0]\n            B_scni[1, 2*i+1] = grad_N_bar[1]\n            B_scni[2, 2*i] = grad_N_bar[1]\n            B_scni[2, 2*i+1] = grad_N_bar[0]\n            \n        # Element stiffness matrix\n        K_e = A_e * (B_scni.T @ D @ B_scni)\n        \n        # Assembly\n        dof_indices = np.array([[2*n, 2*n+1] for n in el_nodes_idx]).flatten()\n        K_global[np.ix_(dof_indices, dof_indices)] += K_e\n\n    return K_global\n\ndef count_spurious_modes(K, tol):\n    \"\"\"Computes number of spurious modes from stiffness matrix eigenvalues.\"\"\"\n    # Using eigh for symmetric matrices; it is faster and more stable.\n    # The eigenvalues are returned sorted.\n    eigvals = linalg.eigh(K, eigvals_only=True)\n    \n    # The largest eigenvalue is the last one\n    max_abs_eigval = np.abs(eigvals[-1]) if len(eigvals) > 0 else 0\n    if max_abs_eigval == 0:\n        return 0 # Trivial case\n\n    threshold = tol * max_abs_eigval\n    near_zero_count = np.sum(np.abs(eigvals) = threshold)\n    \n    # Spurious modes are near-zero eigenvalues beyond the 3 rigid body modes\n    num_rigid_body_modes = 3\n    spurious_count = max(0, near_zero_count - num_rigid_body_modes)\n    \n    return spurious_count\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}