{
    "hands_on_practices": [
        {
            "introduction": "A patient-specific model is only as good as the physical laws it represents. This first practice focuses on the cornerstone of soft tissue biomechanics: constitutive modeling. You will start from a hyperelastic strain energy function, a mathematical description of how a fibrous tissue stores energy when deformed, and derive the resulting stress response from first principles . This exercise solidifies the theoretical connection between material behavior at the microstructural level and the macroscopic stresses that can be predicted in a simulation.",
            "id": "4198117",
            "problem": "Consider a patient-specific hyperelastic model for a transversely isotropic soft tissue with a single fiber family, where the fiber direction in the reference configuration $\\boldsymbol{a}_0$ is obtained from imaging (for example, diffusion tensor magnetic resonance imaging) and serves as a personalized input. Let the deformation gradient be $\\boldsymbol{F}$, the right Cauchy–Green tensor be $\\boldsymbol{C} = \\boldsymbol{F}^{\\top}\\boldsymbol{F}$, the left Cauchy–Green tensor be $\\boldsymbol{B} = \\boldsymbol{F}\\boldsymbol{F}^{\\top}$, and the current fiber direction be $\\boldsymbol{m} = \\boldsymbol{F}\\boldsymbol{a}_0$. Assume the tissue is incompressible so that $J = \\det(\\boldsymbol{F}) = 1$, and the isochoric fiber invariant equals the structural invariant $\\,\\bar{I}_4 = I_4 = \\boldsymbol{a}_0 \\cdot \\boldsymbol{C}\\boldsymbol{a}_0 = \\boldsymbol{m} \\cdot \\boldsymbol{m}\\,$. Let the strain energy density be\n$$\nW = C_{10}\\,(I_1 - 3) + \\frac{k_1}{2k_2}\\left(\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right] - 1\\right),\n$$\nwhere $I_1 = \\operatorname{tr}(\\boldsymbol{C})$, $C_{10}  0$ characterizes the isotropic matrix response, and $k_1  0$, $k_2  0$ characterize the fiber reinforcement, all to be calibrated patient-specifically.\n\nStarting from first principles of hyperelasticity and incompressibility, derive the Cauchy stress tensor $\\boldsymbol{\\sigma}$ as a closed-form expression in terms of the invariants and the fiber direction. Your derivation must begin from the fundamental definitions and the energy function $W$ and must not assume any pre-derived stress formula. Express the final result using only the symbols $C_{10}$, $k_1$, $k_2$, $\\bar{I}_4$, $\\boldsymbol{B}$, $\\boldsymbol{m}$, $\\boldsymbol{I}$, and the Lagrange multiplier $p$ enforcing incompressibility. The final answer must be a single analytical expression. No numerical evaluation is required.",
            "solution": "The appropriate starting point is the principle of hyperelasticity, which states that stress arises from the variation of the strain energy density with respect to the strain measure. For incompressible hyperelastic materials, the second Cauchy–Green tensor $\\boldsymbol{C}$ is a suitable strain measure, and the second Piola–Kirchhoff stress $\\boldsymbol{S}$ follows from the constrained energy functional using a Lagrange multiplier $p$ to enforce incompressibility. Specifically, the constitutive relation is\n$$\n\\boldsymbol{S} = -p\\,\\boldsymbol{C}^{-1} + 2\\,\\frac{\\partial W}{\\partial \\boldsymbol{C}}.\n$$\nThe Cauchy stress $\\boldsymbol{\\sigma}$ is then obtained by pushing forward $\\boldsymbol{S}$:\n$$\n\\boldsymbol{\\sigma} = \\frac{1}{J}\\,\\boldsymbol{F}\\,\\boldsymbol{S}\\,\\boldsymbol{F}^{\\top}.\n$$\nUnder the incompressibility assumption $J=1$, this reduces to\n$$\n\\boldsymbol{\\sigma} = \\boldsymbol{F}\\,\\boldsymbol{S}\\,\\boldsymbol{F}^{\\top}.\n$$\n\nWe next evaluate $\\partial W/\\partial \\boldsymbol{C}$ via the chain rule in terms of the invariants that $W$ depends on. The given energy density is\n$$\nW(I_1,\\bar{I}_4) = C_{10}\\,(I_1 - 3) + \\frac{k_1}{2k_2}\\left(\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right] - 1\\right),\n$$\nwith $I_1 = \\operatorname{tr}(\\boldsymbol{C})$ and, under incompressibility, $\\bar{I}_4 = I_4 = \\boldsymbol{a}_0 \\cdot \\boldsymbol{C}\\boldsymbol{a}_0$. The differential of $W$ with respect to $\\boldsymbol{C}$ is\n$$\n\\frac{\\partial W}{\\partial \\boldsymbol{C}} = \\frac{\\partial W}{\\partial I_1}\\,\\frac{\\partial I_1}{\\partial \\boldsymbol{C}} + \\frac{\\partial W}{\\partial \\bar{I}_4}\\,\\frac{\\partial \\bar{I}_4}{\\partial \\boldsymbol{C}}.\n$$\nWe compute each factor:\n\n1. For the first invariant,\n$$\n\\frac{\\partial I_1}{\\partial \\boldsymbol{C}} = \\boldsymbol{I},\n$$\nwhere $\\boldsymbol{I}$ is the identity tensor, and\n$$\n\\frac{\\partial W}{\\partial I_1} = C_{10}.\n$$\n\n2. For the fiber invariant under incompressibility,\n$$\n\\bar{I}_4 = I_4 = \\boldsymbol{a}_0 \\cdot \\boldsymbol{C}\\boldsymbol{a}_0,\n$$\nand its tensor derivative is\n$$\n\\frac{\\partial \\bar{I}_4}{\\partial \\boldsymbol{C}} = \\boldsymbol{a}_0 \\otimes \\boldsymbol{a}_0.\n$$\nThe scalar derivative of $W$ with respect to $\\bar{I}_4$ is\n$$\n\\frac{\\partial W}{\\partial \\bar{I}_4} = \\frac{k_1}{2k_2}\\,\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right] \\cdot \\frac{d}{d\\bar{I}_4}\\left(k_2(\\bar{I}_4 - 1)^2\\right) = k_1\\,(\\bar{I}_4 - 1)\\,\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right].\n$$\n\nPutting these together,\n$$\n\\frac{\\partial W}{\\partial \\boldsymbol{C}} = C_{10}\\,\\boldsymbol{I} + k_1\\,(\\bar{I}_4 - 1)\\,\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right]\\,(\\boldsymbol{a}_0 \\otimes \\boldsymbol{a}_0).\n$$\nTherefore, the second Piola–Kirchhoff stress is\n$$\n\\boldsymbol{S} = -p\\,\\boldsymbol{C}^{-1} + 2\\,C_{10}\\,\\boldsymbol{I} + 2\\,k_1\\,(\\bar{I}_4 - 1)\\,\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right]\\,(\\boldsymbol{a}_0 \\otimes \\boldsymbol{a}_0).\n$$\n\nWe now push forward $\\boldsymbol{S}$ to obtain the Cauchy stress. Using $\\boldsymbol{\\sigma} = \\boldsymbol{F}\\,\\boldsymbol{S}\\,\\boldsymbol{F}^{\\top}$ and recalling the identities $\\boldsymbol{F}\\,\\boldsymbol{C}^{-1}\\,\\boldsymbol{F}^{\\top} = \\boldsymbol{I}$ (since $\\boldsymbol{C} = \\boldsymbol{F}^{\\top}\\boldsymbol{F}$), $\\boldsymbol{F}\\,\\boldsymbol{I}\\,\\boldsymbol{F}^{\\top} = \\boldsymbol{B}$, and $\\boldsymbol{F}\\,(\\boldsymbol{a}_0 \\otimes \\boldsymbol{a}_0)\\,\\boldsymbol{F}^{\\top} = (\\boldsymbol{F}\\boldsymbol{a}_0)\\otimes(\\boldsymbol{F}\\boldsymbol{a}_0) = \\boldsymbol{m} \\otimes \\boldsymbol{m}$, we obtain\n$$\n\\boldsymbol{\\sigma} = -p\\,\\boldsymbol{I} + 2\\,C_{10}\\,\\boldsymbol{B} + 2\\,k_1\\,(\\bar{I}_4 - 1)\\,\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right]\\,(\\boldsymbol{m} \\otimes \\boldsymbol{m}).\n$$\n\nThis expression presents the Cauchy stress in terms of the invariants $I_1$ and $\\bar{I}_4$ through their appearance in the coefficients and the structural tensors $\\boldsymbol{B}$ and $\\boldsymbol{m}\\otimes\\boldsymbol{m}$, with $p$ enforcing incompressibility. It is directly applicable to patient-specific modeling because the fiber direction $\\boldsymbol{a}_0$ (and hence $\\boldsymbol{m}$ and $\\bar{I}_4$) and the material parameters $C_{10}$, $k_1$, $k_2$ are calibrated using patient-specific data.",
            "answer": "$$\\boxed{-p\\,\\boldsymbol{I} + 2\\,C_{10}\\,\\boldsymbol{B} + 2\\,k_1\\,(\\bar{I}_4 - 1)\\,\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right]\\,(\\boldsymbol{m} \\otimes \\boldsymbol{m})}$$"
        },
        {
            "introduction": "With a constitutive model in hand, the next step is to \"personalize\" it by calibrating its parameters using patient data. This practice moves from theory to data-driven modeling, tasking you with fitting a biomechanical model to noisy measurements . By implementing a profile likelihood analysis, you will not only find the best-fit parameters, such as $a$ and $b$, but also rigorously quantify their identifiability—a critical step for ensuring a personalized model is trustworthy for clinical decision-making.",
            "id": "4198157",
            "problem": "You are tasked with building a patient-specific arterial wall model for personalized medicine using pressure–diameter measurements with additive noise. From biomechanical first principles, you must derive the mapping from diameter to pressure using a thin-wall equilibrium and an exponential constitutive law, then implement a profile likelihood analysis to assess practical identifiability of two stiffness parameters. Your final program must simulate data for three test cases, fit the model, compute profile likelihoods for each parameter, and report confidence interval widths that quantify identifiability.\n\nBegin from the following fundamental base:\n\n- Thin-wall circumferential equilibrium (Laplace law): the circumferential Cauchy stress is related to blood pressure by $$\\sigma_{\\theta} = \\frac{P R}{h},$$ where $P$ is blood pressure, $R$ is the deformed vessel radius, and $h$ is the wall thickness. This equilibrium is appropriate for arteries whose wall thickness is small relative to the radius.\n\n- Green-Lagrange circumferential strain definition: $$E_{\\theta} = \\frac{1}{2}(\\lambda_{\\theta}^2 - 1), \\quad \\lambda_{\\theta} = \\frac{D}{D_0},$$ where $D$ is the deformed diameter and $D_0$ is the reference diameter.\n\n- Exponential stress–strain law (Fung-type) with two unknown stiffness parameters: $$\\sigma_{\\theta}(E_{\\theta}; a,b) = a \\, \\exp(b \\, E_{\\theta}),$$ where $a$ has units of stress and $b$ is dimensionless.\n\nAssume the observed pressures are generated by the forward model with additive independent and identically distributed Gaussian noise of unknown variance. Given measurements $\\{(D_i, P_i^{\\text{obs}})\\}_{i=1}^{n}$, the observation model is $$P_i^{\\text{obs}} = P(D_i; a,b) + \\varepsilon_i, \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2),$$ where $\\sigma^2$ is the (unknown) noise variance and $P(D_i; a,b)$ is the model-implied pressure at diameter $D_i$ from the derived equilibrium.\n\nYou must:\n1. Derive, from the given fundamental base without shortcuts, the expression for $P(D;a,b)$ as a function of $D$, $a$, $b$, $D_0$, and $h$.\n2. Use the Gaussian likelihood with variance concentrated out to define the profile likelihood for each parameter. Let the sum of squared residuals be $$\\mathrm{SSE}(a,b) = \\sum_{i=1}^{n} \\left(P_i^{\\text{obs}} - P(D_i; a,b)\\right)^2.$$ The maximum likelihood estimates (maximum likelihood estimate, MLE) $(\\hat{a},\\hat{b})$ minimize $\\mathrm{SSE}(a,b)$. For a fixed value of $a$ (respectively, $b$), define the profiled sum of squares $$\\mathrm{SSE}_a(a) = \\min_{b0} \\mathrm{SSE}(a,b), \\quad \\mathrm{SSE}_b(b) = \\min_{a0} \\mathrm{SSE}(a,b).$$ Using the concentrated Gaussian likelihood, the likelihood ratio statistic for a single profiled parameter is $$\\Delta_a(a) = n \\, \\ln\\!\\left(\\frac{\\mathrm{SSE}_a(a)}{\\mathrm{SSE}(\\hat{a},\\hat{b})}\\right), \\quad \\Delta_b(b) = n \\, \\ln\\!\\left(\\frac{\\mathrm{SSE}_b(b)}{\\mathrm{SSE}(\\hat{a},\\hat{b})}\\right).$$ Under regularity, $\\Delta_a$ and $\\Delta_b$ are approximately distributed as a chi-square random variable with one degree of freedom. Define the confidence interval for each parameter as the set of values whose profile statistic does not exceed the chi-square quantile at level $0.95$ with one degree of freedom.\n3. Implement a program to compute the profile likelihoods and the corresponding confidence intervals over specified grids and report the confidence interval width for each parameter. Treat $D_0$ and $h$ as known patient-specific constants for each test case and enforce positivity constraints $a0$ and $b0$ during optimization.\n\nPhysical and numerical units:\n- Pressure $P$ must be in kilopascals (kPa).\n- Diameter $D$ and thickness $h$ must be in millimeters (mm).\n- Report the confidence interval width for $a$ in kilopascals (kPa) and for $b$ as a dimensionless number, each rounded to six decimal places.\n\nTest suite specification:\n- Test Case $1$ (well-informed, lower noise):\n  - Reference diameter $D_0 = 10$ mm, wall thickness $h = 1$ mm.\n  - True parameters $a_{\\text{true}} = 120$ kPa, $b_{\\text{true}} = 6$.\n  - Diameters $D_i$ uniformly spaced from $8$ mm to $12$ mm with $n = 30$ points.\n  - Noise standard deviation $\\sigma = 2$ kPa.\n  - Random seed $123$ for reproducibility.\n- Test Case $2$ (narrow diameter range, higher noise):\n  - Reference diameter $D_0 = 10$ mm, wall thickness $h = 1$ mm.\n  - True parameters $a_{\\text{true}} = 120$ kPa, $b_{\\text{true}} = 6$.\n  - Diameters $D_i$ uniformly spaced from $9.8$ mm to $10.5$ mm with $n = 20$ points.\n  - Noise standard deviation $\\sigma = 8$ kPa.\n  - Random seed $456$ for reproducibility.\n- Test Case $3$ (near-linear response, moderate noise):\n  - Reference diameter $D_0 = 10$ mm, wall thickness $h = 1$ mm.\n  - True parameters $a_{\\text{true}} = 120$ kPa, $b_{\\text{true}} = 1$.\n  - Diameters $D_i$ uniformly spaced from $8.5$ mm to $11.5$ mm with $n = 30$ points.\n  - Noise standard deviation $\\sigma = 3$ kPa.\n  - Random seed $789$ for reproducibility.\n\nProfile grids and confidence construction:\n- For $a$, evaluate the profile over a grid of $201$ points from $20$ kPa to $300$ kPa.\n- For $b$, evaluate the profile over a grid of $201$ points from $0.5$ to $12$.\n- Use the chi-square quantile at level $0.95$ with one degree of freedom to determine each parameter’s confidence interval. If the entire grid satisfies the inequality or if no grid point satisfies the inequality, report the full grid width as the confidence interval width to indicate practical non-identifiability within the probed range.\n\nFinal output format:\nYour program should produce a single line of output containing the confidence interval widths for $a$ and $b$ for the three test cases, in order, as a comma-separated list enclosed in square brackets. The six values must be in the order $[w_a^{(1)}, w_b^{(1)}, w_a^{(2)}, w_b^{(2)}, w_a^{(3)}, w_b^{(3)}]$, where $w_a^{(j)}$ is the confidence interval width for $a$ in test case $j$ (in kPa) and $w_b^{(j)}$ is the confidence interval width for $b$ in test case $j$ (dimensionless), each rounded to six decimal places. For example, the output must have the form $$[w_a^{(1)},w_b^{(1)},w_a^{(2)},w_b^{(2)},w_a^{(3)},w_b^{(3)}].$$",
            "solution": "The problem has been validated and is deemed sound. It is scientifically grounded in established principles of biomechanics and statistics, is well-posed, objective, and contains all necessary information to proceed with a solution.\n\nThe task requires the derivation of a patient-specific arterial wall model, followed by the implementation of a profile likelihood analysis to assess parameter identifiability from simulated noisy data.\n\n**1. Derivation of the Pressure-Diameter Relationship**\n\nThe goal is to derive an expression for the internal pressure $P$ as a function of the vessel diameter $D$ and a set of model parameters. This is achieved by combining the provided equations for mechanical equilibrium, strain kinematics, and constitutive behavior.\n\nFirst, the circumferential Green-Lagrange strain, $E_{\\theta}$, is defined in terms of the circumferential stretch, $\\lambda_{\\theta}$:\n$$E_{\\theta} = \\frac{1}{2}(\\lambda_{\\theta}^2 - 1)$$\nThe stretch $\\lambda_{\\theta}$ is the ratio of the deformed diameter $D$ to the reference (zero-stress) diameter $D_0$:\n$$\\lambda_{\\theta} = \\frac{D}{D_0}$$\nSubstituting the expression for $\\lambda_{\\theta}$ into the strain definition gives $E_{\\theta}$ as a function of $D$:\n$$E_{\\theta} = \\frac{1}{2}\\left(\\left(\\frac{D}{D_0}\\right)^2 - 1\\right)$$\n\nNext, the Fung-type exponential constitutive law relates the circumferential Cauchy stress, $\\sigma_{\\theta}$, to the strain $E_{\\theta}$ via two material parameters, $a$ and $b$:\n$$\\sigma_{\\theta} = a \\exp(b E_{\\theta})$$\nSubstituting the derived expression for $E_{\\theta}$ into this law gives the stress as a function of diameter:\n$$\\sigma_{\\theta} = a \\exp\\left(b \\left[\\frac{1}{2}\\left(\\frac{D}{D_0}\\right)^2 - \\frac{1}{2}\\right]\\right) = a \\exp\\left(\\frac{b}{2}\\left[\\left(\\frac{D}{D_0}\\right)^2 - 1\\right]\\right)$$\n\nFinally, the thin-wall equilibrium equation (Law of Laplace) relates the stress $\\sigma_{\\theta}$ to the internal pressure $P$, the deformed radius $R$, and the wall thickness $h$:\n$$\\sigma_{\\theta} = \\frac{P R}{h}$$\nSince the radius is half the diameter, $R = D/2$, the equilibrium equation becomes:\n$$\\sigma_{\\theta} = \\frac{P (D/2)}{h} = \\frac{P D}{2h}$$\n\nTo find the pressure-diameter relationship, we equate the constitutive expression for stress with the equilibrium expression for stress:\n$$\\frac{P D}{2h} = a \\exp\\left(\\frac{b}{2}\\left[\\left(\\frac{D}{D_0}\\right)^2 - 1\\right]\\right)$$\nSolving for $P$ yields the final forward model, which we denote as $P(D; a, b)$:\n$$P(D; a,b) = \\frac{2ha}{D} \\exp\\left(\\frac{b}{2}\\left[\\left(\\frac{D}{D_0}\\right)^2 - 1\\right]\\right)$$\nThis equation describes the pressure required to maintain a vessel at diameter $D$, given its material properties ($a$, $b$) and patient-specific geometry ($D_0$, $h$).\n\n**2. Statistical Framework and Numerical Implementation**\n\nThe problem of estimating parameters $a$ and $b$ from noisy measurements $\\{(D_i, P_i^{\\text{obs}})\\}$ is framed as a non-linear least squares problem. Under the assumption of additive, independent, and identically distributed Gaussian noise, minimizing the sum of squared residuals (SSE) is equivalent to maximizing the likelihood.\n\nThe SSE is given by:\n$$\\mathrm{SSE}(a,b) = \\sum_{i=1}^{n} \\left(P_i^{\\text{obs}} - P(D_i; a,b)\\right)^2$$\nThe maximum likelihood estimates (MLEs), $(\\hat{a}, \\hat{b})$, are the values of $a$ and $b$ that minimize this function, subject to the physical constraints $a0$ and $b0$.\n$$(\\hat{a}, \\hat{b}) = \\arg\\min_{a0, b0} \\mathrm{SSE}(a,b)$$\nThe minimized value of the SSE is denoted $\\mathrm{SSE}_{\\text{min}} = \\mathrm{SSE}(\\hat{a}, \\hat{b})$. This is a $2\\mathrm{D}$ numerical optimization problem.\n\nProfile likelihood analysis is used to assess the identifiability of each parameter individually. For a parameter of interest (e.g., $a$), the nuisance parameter (e.g., $b$) is optimized out for each fixed value of the parameter of interest.\n\nThe profile for $a$ is constructed by calculating the profiled sum of squares, $\\mathrm{SSE}_a(a)$, for each value of $a$ on a predefined grid:\n$$\\mathrm{SSE}_a(a^*) = \\min_{b0} \\mathrm{SSE}(a^*, b)$$\nThis requires solving a $1\\mathrm{D}$ optimization problem for $b$ for each fixed $a^*$.\n\nSimilarly, the profile for $b$ is:\n$$\\mathrm{SSE}_b(b^*) = \\min_{a0} \\mathrm{SSE}(a, b^*)$$\n\nThe likelihood ratio statistic, $\\Delta(p)$, for a generic parameter $p$ is then calculated. For parameter $a$, it is:\n$$\\Delta_a(a) = n \\cdot \\ln\\left(\\frac{\\mathrm{SSE}_a(a)}{\\mathrm{SSE}_{\\text{min}}}\\right)$$\nAnd for parameter $b$:\n$$\\Delta_b(b) = n \\cdot \\ln\\left(\\frac{\\mathrm{SSE}_b(b)}{\\mathrm{SSE}_{\\text{min}}}\\right)$$\n\nA pointwise $95\\%$ confidence interval for each parameter is defined as the set of parameter values for which the likelihood ratio statistic does not exceed a critical threshold. This threshold is the quantile of the chi-square distribution with one degree of freedom at a confidence level of $1-\\alpha = 0.95$.\n$$\\text{CI}_{95\\%} = \\{ p \\mid \\Delta(p) \\le \\chi^2_{1, 0.95} \\}$$\nNumerically, for each profile (e.g., for $a$), we find all values on the grid, $a_{\\text{grid}}$, that satisfy $\\Delta_a(a) \\le \\chi^2_{1, 0.95} \\approx 3.841$. The confidence interval width is the difference between the maximum and minimum values in this set.\n\nThe implementation will proceed as follows for each test case:\n1.  Generate synthetic pressure data $P_i^{\\text{obs}}$ by adding Gaussian noise to the true model output, using the specified random seed for reproducibility.\n2.  Perform a $2\\mathrm{D}$ optimization using `scipy.optimize.minimize` to find the MLEs $(\\hat{a}, \\hat{b})$ and the minimum SSE, $\\mathrm{SSE}_{\\text{min}}$. Positivity constraints will be enforced using bounds.\n3.  For each parameter ($a$ and $b$), iterate over its predefined grid. At each grid point, perform a $1\\mathrm{D}$ optimization of the nuisance parameter to find the profiled SSE.\n4.  Calculate the likelihood ratio statistic vectors, $\\Delta_a$ and $\\Delta_b$.\n5.  Determine the set of parameter values within the $95\\%$ confidence interval by comparing the statistic to the $\\chi^2$ critical value.\n6.  Compute and store the width of this interval. The problem specifies that if the interval covers the entire grid or is empty, the full grid width should be reported, signaling practical non-identifiability.\n7.  Finally, all computed widths are collected and formatted into a single output string.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the biomechanics profile likelihood problem for three test cases.\n    \"\"\"\n\n    # Test case definitions\n    test_cases = [\n        # Case 1: Well-informed, lower noise\n        {\n            \"D0\": 10.0, \"h\": 1.0, \"a_true\": 120.0, \"b_true\": 6.0,\n            \"D_range\": (8.0, 12.0), \"n\": 30, \"sigma\": 2.0, \"seed\": 123\n        },\n        # Case 2: Narrow diameter range, higher noise\n        {\n            \"D0\": 10.0, \"h\": 1.0, \"a_true\": 120.0, \"b_true\": 6.0,\n            \"D_range\": (9.8, 10.5), \"n\": 20, \"sigma\": 8.0, \"seed\": 456\n        },\n        # Case 3: Near-linear response, moderate noise\n        {\n            \"D0\": 10.0, \"h\": 1.0, \"a_true\": 120.0, \"b_true\": 1.0,\n            \"D_range\": (8.5, 11.5), \"n\": 30, \"sigma\": 3.0, \"seed\": 789\n        }\n    ]\n\n    # Profile grid definitions\n    a_grid = np.linspace(20.0, 300.0, 201)\n    b_grid = np.linspace(0.5, 12.0, 201)\n    \n    # Chi-square critical value for 95% CI, 1 degree of freedom\n    chi2_crit = chi2.ppf(0.95, df=1)\n\n    # Positivity constraints for optimization\n    bounds = [(1e-9, None), (1e-9, None)]\n\n    # Main function for the pressure model\n    def pressure_model(D, a, b, D0, h):\n        term_in_exp = (b / 2.0) * ((D / D0)**2 - 1.0)\n        return (2.0 * h * a / D) * np.exp(term_in_exp)\n\n    results = []\n    for case in test_cases:\n        # 1. Generate synthetic data\n        rng = np.random.default_rng(case[\"seed\"])\n        D_obs = np.linspace(case[\"D_range\"][0], case[\"D_range\"][1], case[\"n\"])\n        P_true = pressure_model(D_obs, case[\"a_true\"], case[\"b_true\"], case[\"D0\"], case[\"h\"])\n        P_obs = P_true + rng.normal(0, case[\"sigma\"], size=case[\"n\"])\n\n        # 2. Find MLEs and minimum SSE\n        def sse_global(params):\n            a, b = params\n            P_model = pressure_model(D_obs, a, b, case[\"D0\"], case[\"h\"])\n            return np.sum((P_obs - P_model)**2)\n\n        # A reasonable initial guess\n        initial_guess = [100.0, 5.0]\n        mle_result = minimize(sse_global, initial_guess, bounds=bounds, method='L-BFGS-B')\n        a_hat, b_hat = mle_result.x\n        sse_min = mle_result.fun\n\n        # 3. Calculate Profile Likelihood for parameter 'a'\n        sse_profile_a = np.zeros_like(a_grid)\n        for i, a_val in enumerate(a_grid):\n            def sse_profile_a_obj(b_param):\n                # Ensure b_param is a scalar\n                b = b_param[0]\n                P_model = pressure_model(D_obs, a_val, b, case[\"D0\"], case[\"h\"])\n                return np.sum((P_obs - P_model)**2)\n\n            res_prof_a = minimize(sse_profile_a_obj, [b_hat], bounds=[bounds[1]], method='L-BFGS-B')\n            sse_profile_a[i] = res_prof_a.fun\n        \n        delta_a = case[\"n\"] * np.log(sse_profile_a / sse_min)\n\n        # 4. Calculate Profile Likelihood for parameter 'b'\n        sse_profile_b = np.zeros_like(b_grid)\n        for i, b_val in enumerate(b_grid):\n            def sse_profile_b_obj(a_param):\n                # Ensure a_param is a scalar\n                a = a_param[0]\n                P_model = pressure_model(D_obs, a, b_val, case[\"D0\"], case[\"h\"])\n                return np.sum((P_obs - P_model)**2)\n\n            res_prof_b = minimize(sse_profile_b_obj, [a_hat], bounds=[bounds[0]], method='L-BFGS-B')\n            sse_profile_b[i] = res_prof_b.fun\n\n        delta_b = case[\"n\"] * np.log(sse_profile_b / sse_min)\n\n        # 5. Compute Confidence Interval Widths\n        # For 'a'\n        valid_points_a = a_grid[delta_a = chi2_crit]\n        if valid_points_a.size == 0 or valid_points_a.size == a_grid.size:\n            width_a = a_grid[-1] - a_grid[0]\n        else:\n            width_a = valid_points_a.max() - valid_points_a.min()\n        \n        # For 'b'\n        valid_points_b = b_grid[delta_b = chi2_crit]\n        if valid_points_b.size == 0 or valid_points_b.size == b_grid.size:\n            width_b = b_grid[-1] - b_grid[0]\n        else:\n            width_b = valid_points_b.max() - valid_points_b.min()\n            \n        results.append(f\"{width_a:.6f}\")\n        results.append(f\"{width_b:.6f}\")\n\n    # Final print statement\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "The final step in building a reliable model is ensuring that the numerical solution is an accurate representation of the underlying mathematical equations. This practice addresses the critical task of code and solution verification, where you will implement the Grid Convergence Index (GCI) method for a hemodynamic simulation . This exercise will provide you with a standard, rigorous tool to quantify discretization error and build confidence that your computational predictions reflect the model's physics rather than numerical artifacts.",
            "id": "4198139",
            "problem": "You are tasked with verifying numerical grid convergence for a patient-specific computational fluid dynamics model of cerebral aneurysm hemodynamics, focusing on Wall Shear Stress (WSS). The scenario is framed in the context of biomechanics and personalized medicine, where quantifying discretization uncertainty is critical for clinical reliability. Starting from the fundamental discretization error model and the conceptual basis of systematic mesh refinement, your program must compute the Grid Convergence Index (GCI) and the observed order of accuracy for WSS using three refined meshes.\n\nUse the following fundamental base:\n- The finite volume or finite element discretization of a continuum model introduces a discretization error represented by a leading-order term such that the discretized solution $\\,\\phi(h)\\,$ for a mesh with characteristic size $\\,h\\,$ satisfies $\\,\\phi(h) = \\phi^\\ast + C h^p\\,$, where $\\,\\phi^\\ast\\,$ is the continuum (mesh-independent) solution, $\\,C\\,$ is a constant, and $\\,p\\,$ is the order of accuracy.\n- Systematic mesh refinement implies three meshes with characteristic sizes $\\,h_1  h_2  h_3\\,$ and refinement ratios $\\,r_{21} = h_2/h_1\\,$ and $\\,r_{32} = h_3/h_2\\,$.\n- The Grid Convergence Index (GCI) is a dimensionless decimal quantification of the discretization uncertainty on a given grid pair, incorporating a safety factor. It is based on the observed differences among successively refined meshes and the observed order $\\,p\\,$.\n\nYour program must implement the following tasks from first principles:\n1. Given $\\,\\phi_1\\,$, $\\,\\phi_2\\,$, and $\\,\\phi_3\\,$ (the WSS computed on meshes with sizes $\\,h_1\\,$, $\\,h_2\\,$, and $\\,h_3\\,$ respectively), infer the observed order of accuracy $\\,p\\,$ using the three-grid model of discretization error $\\,\\phi(h) = \\phi^\\ast + C h^p\\,$ and systematic refinement ratios $\\,r_{21}\\,$ and $\\,r_{32}\\,$.\n2. Compute the Richardson-extrapolated WSS $\\,\\phi_{\\mathrm{ext}}\\,$ using the finest grid and the inferred $\\,p\\,$.\n3. Compute the fine/medium GCI $\\,\\mathrm{GCI}_{21}\\,$ and the medium/coarse GCI $\\,\\mathrm{GCI}_{32}\\,$ using a safety factor of $\\,1.25\\,$.\n4. Determine whether the sequence of $\\,\\phi\\,$ values exhibits monotonic convergence (a boolean indicating whether the successive differences have the same sign).\n5. Produce all outputs for each test case in a structured, unit-consistent, and machine-checkable format.\n\nUse these scientifically plausible test cases. All WSS values must be given in pascals (Pa), and mesh characteristic sizes must be given in meters (m). The safety factor is fixed at $\\,1.25\\,$. Angles are not used in this problem. The observed order $\\,p\\,$ and the GCI values are dimensionless. Round all floating-point outputs to six digits after the decimal point.\n\n- Test Case 1 (equal refinement ratios, monotonic convergence):\n  - $\\,h_1 = 2.0 \\times 10^{-4}\\,\\mathrm{m}\\,$, $\\,h_2 = 4.0 \\times 10^{-4}\\,\\mathrm{m}\\,$, $\\,h_3 = 8.0 \\times 10^{-4}\\,\\mathrm{m}\\,$.\n  - $\\,\\phi_1 = 5.012\\,\\mathrm{Pa}\\,$, $\\,\\phi_2 = 5.048\\,\\mathrm{Pa}\\,$, $\\,\\phi_3 = 5.192\\,\\mathrm{Pa}\\,$.\n- Test Case 2 (unequal refinement ratios, monotonic convergence):\n  - $\\,h_1 = 5.0 \\times 10^{-4}\\,\\mathrm{m}\\,$, $\\,h_2 = 7.5 \\times 10^{-4}\\,\\mathrm{m}\\,$, $\\,h_3 = 1.5 \\times 10^{-3}\\,\\mathrm{m}\\,$.\n  - $\\,\\phi_1 = 4.900\\,\\mathrm{Pa}\\,$, $\\,\\phi_2 = 5.025\\,\\mathrm{Pa}\\,$, $\\,\\phi_3 = 5.700\\,\\mathrm{Pa}\\,$.\n- Test Case 3 (equal refinement ratios, oscillatory convergence):\n  - $\\,h_1 = 3.0 \\times 10^{-4}\\,\\mathrm{m}\\,$, $\\,h_2 = 6.0 \\times 10^{-4}\\,\\mathrm{m}\\,$, $\\,h_3 = 1.2 \\times 10^{-3}\\,\\mathrm{m}\\,$.\n  - $\\,\\phi_1 = 4.980\\,\\mathrm{Pa}\\,$, $\\,\\phi_2 = 5.020\\,\\mathrm{Pa}\\,$, $\\,\\phi_3 = 4.940\\,\\mathrm{Pa}\\,$.\n\nYour program must:\n- Treat WSS inputs in pascals (Pa) and $\\,h\\,$ in meters (m).\n- Compute and output, for each test case, a list containing $\\,p\\,$, $\\,\\mathrm{GCI}_{21}\\,$, $\\,\\mathrm{GCI}_{32}\\,$, $\\,\\phi_{\\mathrm{ext}}\\,$, and the monotonic convergence boolean, all in that order.\n- Round $\\,p\\,$, $\\,\\mathrm{GCI}_{21}\\,$, $\\,\\mathrm{GCI}_{32}\\,$, and $\\,\\phi_{\\mathrm{ext}}\\,$ to six decimal places. Express GCI values as decimals (no percentage signs).\n- Final output format: your program should produce a single line of output containing the results as a comma-separated list of the per-test-case lists, with no spaces, enclosed in square brackets. For example: \"[[p1,GCI21_1,GCI32_1,phi_ext_1,flag1],[p2,GCI21_2,GCI32_2,phi_ext_2,flag2],[p3,GCI21_3,GCI32_3,phi_ext_3,flag3]]\".",
            "solution": "The problem statement is critically evaluated for validity prior to attempting a solution.\n\n### Step 1: Extract Givens\n- **Discretization Error Model**: The discretized solution $\\phi(h)$ for a mesh with characteristic size $h$ is given by $\\phi(h) = \\phi^\\ast + C h^p$, where $\\phi^\\ast$ is the continuum (mesh-independent) solution, $C$ is a constant, and $p$ is the order of accuracy.\n- **Mesh Hierarchy**: Three meshes are used with characteristic sizes $h_1  h_2  h_3$.\n- **Refinement Ratios**: $r_{21} = h_2/h_1$ and $r_{32} = h_3/h_2$.\n- **Solution Variables**: $\\phi_1$, $\\phi_2$, and $\\phi_3$ are the solutions (Wall Shear Stress, WSS) corresponding to meshes with sizes $h_1$, $h_2$, and $h_3$, respectively.\n- **Safety Factor**: A safety factor $F_s = 1.25$ is specified for Grid Convergence Index (GCI) calculations.\n- **Tasks**:\n  1. Infer the observed order of accuracy, $p$.\n  2. Compute the Richardson-extrapolated WSS, $\\phi_{\\mathrm{ext}}$.\n  3. Compute the fine/medium GCI, $\\mathrm{GCI}_{21}$, and the medium/coarse GCI, $\\mathrm{GCI}_{32}$.\n  4. Determine if convergence is monotonic (boolean).\n- **Test Case 1**:\n  - $h_1 = 2.0 \\times 10^{-4}\\,\\mathrm{m}$, $h_2 = 4.0 \\times 10^{-4}\\,\\mathrm{m}$, $h_3 = 8.0 \\times 10^{-4}\\,\\mathrm{m}$.\n  - $\\phi_1 = 5.012\\,\\mathrm{Pa}$, $\\phi_2 = 5.048\\,\\mathrm{Pa}$, $\\phi_3 = 5.192\\,\\mathrm{Pa}$.\n- **Test Case 2**:\n  - $h_1 = 5.0 \\times 10^{-4}\\,\\mathrm{m}$, $h_2 = 7.5 \\times 10^{-4}\\,\\mathrm{m}$, $h_3 = 1.5 \\times 10^{-3}\\,\\mathrm{m}$.\n  - $\\phi_1 = 4.900\\,\\mathrm{Pa}$, $\\phi_2 = 5.025\\,\\mathrm{Pa}$, $\\phi_3 = 5.700\\,\\mathrm{Pa}$.\n- **Test Case 3**:\n  - $h_1 = 3.0 \\times 10^{-4}\\,\\mathrm{m}$, $h_2 = 6.0 \\times 10^{-4}\\,\\mathrm{m}$, $h_3 = 1.2 \\times 10^{-3}\\,\\mathrm{m}$.\n  - $\\phi_1 = 4.980\\,\\mathrm{Pa}$, $\\phi_2 = 5.020\\,\\mathrm{Pa}$, $\\phi_3 = 4.940\\,\\mathrm{Pa}$.\n- **Output Requirements**: All floating-point outputs ($\\,p\\,$, $\\,\\mathrm{GCI}_{21}\\,$, $\\,\\mathrm{GCI}_{32}\\,$, $\\,\\phi_{\\mathrm{ext}}\\,$) are to be rounded to six decimal places. The final output must be a single line containing a list of lists in a specified format.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the Grid Convergence Index (GCI) methodology, which is a standard, widely accepted procedure for quantifying numerical uncertainty in computational fluid dynamics and other fields of computational mechanics. The underlying error model is a direct consequence of Taylor series expansion of discretization error. The context, patient-specific modeling of cerebral aneurysms, is a scientifically relevant and critical application area in biomechanics. The problem is scientifically sound.\n- **Well-Posed**: The problem is well-posed. It provides all necessary inputs (mesh sizes, solution values, safety factor) and a clear set of deliverables. The mathematical framework, while requiring numerical solution in the general case, admits a unique solution for $p$ within a physically meaningful range.\n- **Objective**: The problem is stated using precise, quantitative, and unbiased language. All inputs are numerical, and all required outputs are well-defined quantities.\n- **Consistency and Completeness**: The problem is self-contained. The data for all test cases are provided, and no external information is required. There are no contradictions in the givens. The test cases are plausible representations of simulation results.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is scientifically grounded, well-posed, objective, and self-contained. A rigorous solution can be formulated from the provided principles.\n\n### Solution Derivation\nThe solution is derived from the fundamental error model $\\phi(h) = \\phi^\\ast + C h^p$. We consider the solutions on three grids, denoted by subscripts $1$ (fine), $2$ (medium), and $3$ (coarse):\n$$ \\phi_1 = \\phi(h_1) = \\phi^\\ast + C h_1^p $$\n$$ \\phi_2 = \\phi(h_2) = \\phi^\\ast + C h_2^p $$\n$$ \\phi_3 = \\phi(h_3) = \\phi^\\ast + C h_3^p $$\nThe differences between solutions on successive grids are defined as $\\epsilon_{21} = \\phi_2 - \\phi_1$ and $\\epsilon_{32} = \\phi_3 - \\phi_2$.\n\n1.  **Monotonic Convergence**\n    Convergence is monotonic if the solution approaches the asymptotic value $\\phi^\\ast$ from one side as the mesh is refined. This implies that the sequence $\\phi_3, \\phi_2, \\phi_1$ is monotonic. Mathematically, this condition is met if the successive differences, $\\epsilon_{32}$ and $\\epsilon_{21}$, have the same sign. Therefore, monotonic convergence is confirmed if the ratio of differences, $s = \\epsilon_{32} / \\epsilon_{21}$, is positive.\n    $$ \\text{is\\_monotonic} = \\left( s = \\frac{\\phi_3 - \\phi_2}{\\phi_2 - \\phi_1}  0 \\right) $$\n    If $s  0$, the convergence is oscillatory. The denominator $\\phi_2 - \\phi_1$ must be non-zero.\n\n2.  **Observed Order of Accuracy ($p$)**\n    From the error model, we can express the differences as:\n    $$ \\epsilon_{21} = (\\phi^\\ast + C h_2^p) - (\\phi^\\ast + C h_1^p) = C(h_2^p - h_1^p) = C h_1^p (r_{21}^p - 1) $$\n    $$ \\epsilon_{32} = (\\phi^\\ast + C h_3^p) - (\\phi^\\ast + C h_2^p) = C(h_3^p - h_2^p) = C h_2^p (r_{32}^p - 1) $$\n    Taking the ratio of these differences eliminates the unknown constant $C$:\n    $$ s = \\frac{\\epsilon_{32}}{\\epsilon_{21}} = \\frac{C h_2^p (r_{32}^p - 1)}{C h_1^p (r_{21}^p - 1)} = \\left(\\frac{h_2}{h_1}\\right)^p \\frac{r_{32}^p - 1}{r_{21}^p - 1} = r_{21}^p \\frac{r_{32}^p - 1}{r_{21}^p - 1} $$\n    This gives the equation for $p$:\n    $$ s(r_{21}^p - 1) - r_{21}^p(r_{32}^p - 1) = 0 $$\n    In the special case of uniform refinement where $r_{21} = r_{32} = r$, the equation simplifies to $s = r^p$. For monotonic convergence ($s0$), $p$ can be found directly:\n    $$ p = \\frac{\\ln(s)}{\\ln(r)} $$\n    For oscillatory convergence ($s0$), a real solution for $p$ does not exist from this equation. However, to satisfy the problem's requirement for a numerical output, a common pragmatic approach is to use the absolute value of $s$, i.e., $p = \\ln(|s|) / \\ln(r)$. This is an engineering approximation, as oscillatory convergence suggests the single-term error model is not holding.\n    In the general case of non-uniform refinement, the transcendental equation for $p$ must be solved numerically, for instance, using a root-finding algorithm. The same pragmatic use of $|s|$ will be applied if convergence is oscillatory.\n\n3.  **Richardson Extrapolation ($\\phi_{\\mathrm{ext}}$)**\n    Richardson extrapolation provides an estimate of the continuum solution $\\phi^\\ast$ (here denoted $\\phi_{\\mathrm{ext}}$) by eliminating the leading-order error term. Using the two finest grid solutions, $\\phi_1$ and $\\phi_2$:\n    $$ \\phi_1 = \\phi_{\\mathrm{ext}} + C h_1^p $$\n    $$ \\phi_2 = \\phi_{\\mathrm{ext}} + C h_2^p = \\phi_{\\mathrm{ext}} + C (r_{21}h_1)^p = \\phi_{\\mathrm{ext}} + r_{21}^p (C h_1^p) $$\n    Substituting $C h_1^p = \\phi_1 - \\phi_{\\mathrm{ext}}$ into the second equation:\n    $$ \\phi_2 = \\phi_{\\mathrm{ext}} + r_{21}^p (\\phi_1 - \\phi_{\\mathrm{ext}}) $$\n    Solving for $\\phi_{\\mathrm{ext}}$ yields:\n    $$ \\phi_{\\mathrm{ext}}(r_{21}^p - 1) = r_{21}^p \\phi_1 - \\phi_2 $$\n    $$ \\phi_{\\mathrm{ext}} = \\frac{r_{21}^p \\phi_1 - \\phi_2}{r_{21}^p - 1} = \\phi_1 + \\frac{\\phi_1 - \\phi_2}{r_{21}^p - 1} $$\n    The latter form is used for improved numerical stability.\n\n4.  **Grid Convergence Index (GCI)**\n    The GCI provides a conservative estimate of the discretization error as a percentage or decimal.\n    For the fine/medium grid pair ($1$ and $2$), the GCI on the fine grid ($\\phi_1$) is:\n    $$ \\mathrm{GCI}_{21} = F_s \\frac{|\\epsilon_a^{21}|}{r_{21}^p - 1} \\quad \\text{where} \\quad \\epsilon_a^{21} = \\frac{\\phi_1 - \\phi_2}{\\phi_1} $$\n    For the medium/coarse grid pair ($2$ and $3$), the GCI on the medium grid ($\\phi_2$) is:\n    $$ \\mathrm{GCI}_{32} = F_s \\frac{|\\epsilon_a^{32}|}{r_{32}^p - 1} \\quad \\text{where} \\quad \\epsilon_a^{32} = \\frac{\\phi_2 - \\phi_3}{\\phi_2} $$\n    The safety factor $F_s$ is given as $1.25$.\n\nThis completes the theoretical framework. The algorithm will implement these derived formulas for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Structure: (h1, h2, h3, phi1, phi2, phi3)\n    test_cases = [\n        # Test Case 1 (equal refinement, monotonic)\n        (2.0e-4, 4.0e-4, 8.0e-4, 5.012, 5.048, 5.192),\n        # Test Case 2 (unequal refinement, monotonic)\n        (5.0e-4, 7.5e-4, 1.5e-3, 4.900, 5.025, 5.700),\n        # Test Case 3 (equal refinement, oscillatory)\n        (3.0e-4, 6.0e-4, 1.2e-3, 4.980, 5.020, 4.940),\n    ]\n\n    Fs = 1.25  # Safety Factor\n    all_results = []\n\n    for case in test_cases:\n        h1, h2, h3, phi1, phi2, phi3 = case\n        result = calculate_gci_metrics(h1, h2, h3, phi1, phi2, phi3, Fs)\n        all_results.append(result)\n\n    # Format the final output string as per requirements.\n    # Example: [[p1,GCI21_1,GCI32_1,phi_ext_1,flag1],...]\n    formatted_results = []\n    for res in all_results:\n        p, gci21, gci32, phi_ext, is_monotonic = res\n        # Format floats to 6 decimal places, boolean to Python's default string repr\n        formatted_list = [\n            f\"{p:.6f}\",\n            f\"{gci21:.6f}\",\n            f\"{gci32:.6f}\",\n            f\"{phi_ext:.6f}\",\n            str(is_monotonic)\n        ]\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_gci_metrics(h1, h2, h3, phi1, phi2, phi3, Fs):\n    \"\"\"\n    Calculates GCI metrics based on three-grid solutions.\n    \"\"\"\n    # 1. Calculate refinement ratios\n    r21 = h2 / h1\n    r32 = h3 / h2\n\n    # 2. Calculate solution differences\n    eps21 = phi2 - phi1\n    eps32 = phi3 - phi2\n    \n    # Edge case: if solutions are identical, p is undefined.\n    if np.isclose(eps21, 0.0):\n        # This case is not in the problem spec but is a necessary check.\n        # Indicates p - infinity or method failure. We return NaNs.\n        return (np.nan, np.nan, np.nan, np.nan, False)\n\n    # 3. Determine monotonic convergence\n    s = eps32 / eps21\n    is_monotonic = s  0\n\n    # 4. Calculate observed order of accuracy 'p'\n    # For oscillatory convergence, the standard method is not strictly valid.\n    # As a pragmatic step required by the problem, use abs(s).\n    s_abs = abs(s)\n\n    # Check for uniform refinement, which has an analytical solution\n    if np.isclose(r21, r32):\n        r = r21\n        # Handle case where s is close to 0 or 1.\n        if np.isclose(s_abs, 0.0) or np.isclose(r, 1.0):\n             p = np.nan # Undefined\n        else:\n             p = np.log(s_abs) / np.log(r)\n    else:\n        # Non-uniform refinement requires a numerical root-finder.\n        # The equation to solve is: s * (r21^p - 1) - r21^p * (r32^p - 1) = 0\n        def p_equation(p_val):\n            # Use np.power for robust handling of potential float exponents\n            term1 = s_abs * (np.power(r21, p_val) - 1.0)\n            term2 = np.power(r21, p_val) * (np.power(r32, p_val) - 1.0)\n            return term1 - term2\n        \n        try:\n            # Search for a root in a physically plausible range (e.g., 0.1 to 5)\n            sol = root_scalar(p_equation, bracket=[0.1, 5.0], method='brentq')\n            p = sol.root\n        except ValueError:\n            # If no root is found in the bracket, the model might be invalid.\n            p = np.nan\n\n    # 5. Calculate Richardson Extrapolation\n    # phi_ext = phi1 + (phi1 - phi2) / (r21^p - 1)\n    if not np.isclose(np.power(r21, p), 1.0):\n        phi_ext = phi1 + (phi1 - phi2) / (np.power(r21, p) - 1.0)\n    else:\n        phi_ext = np.nan\n\n    # 6. Calculate Grid Convergence Indices (GCI)\n    # GCI_21 for the fine/medium grid pair, on the fine grid solution\n    denom21 = np.power(r21, p) - 1.0\n    if not np.isclose(denom21, 0.0) and not np.isclose(phi1, 0.0):\n        rel_err_21 = abs((phi1 - phi2) / phi1)\n        gci21 = Fs * rel_err_21 / denom21\n    else:\n        gci21 = np.nan\n\n    # GCI_32 for the medium/coarse grid pair, on the medium grid solution\n    denom32 = np.power(r32, p) - 1.0\n    if not np.isclose(denom32, 0.0) and not np.isclose(phi2, 0.0):\n        rel_err_32 = abs((phi2 - phi3) / phi2)\n        gci32 = Fs * rel_err_32 / denom32\n    else:\n        gci32 = np.nan\n        \n    return (p, gci21, gci32, phi_ext, is_monotonic)\n\n# Execute the solution\nsolve()\n\n```"
        }
    ]
}