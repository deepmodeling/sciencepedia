{
    "hands_on_practices": [
        {
            "introduction": "患者特异性模型的基石在于其能够准确描述生物组织的力学行为。许多组织，如动脉壁或心肌，表现出各向异性，即在不同方向上具有不同的力学强度。本练习将从给定的应变能函数出发，推导这类材料的应力-应变关系，这是建立精确固体生物力学模型的关键一步，为后续的计算分析提供本构基础。",
            "id": "4198117",
            "problem": "考虑一个针对患者特异性的、具有单一纤维族的横向各向同性软组织的超弹性模型，其中参考构型中的纤维方向 $\\boldsymbol{a}_0$ 是通过成像（例如，扩散张量磁共振成像）获得的，并作为个性化输入。令变形梯度为 $\\boldsymbol{F}$，右柯西-格林张量为 $\\boldsymbol{C} = \\boldsymbol{F}^{\\top}\\boldsymbol{F}$，左柯西-格林张量为 $\\boldsymbol{B} = \\boldsymbol{F}\\boldsymbol{F}^{\\top}$，当前纤维方向为 $\\boldsymbol{m} = \\boldsymbol{F}\\boldsymbol{a}_0$。假设组织是不可压缩的，因此 $J = \\det(\\boldsymbol{F}) = 1$，并且等容纤维不变量等于结构不变量 $\\,\\bar{I}_4 = I_4 = \\boldsymbol{a}_0 \\cdot \\boldsymbol{C}\\boldsymbol{a}_0 = \\boldsymbol{m} \\cdot \\boldsymbol{m}\\,$。令应变能密度为\n$$\nW = C_{10}\\,(I_1 - 3) + \\frac{k_1}{2k_2}\\left(\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right] - 1\\right),\n$$\n其中 $I_1 = \\operatorname{tr}(\\boldsymbol{C})$，$C_{10} > 0$ 表征各向同性基质的响应，$k_1 > 0, k_2 > 0$ 表征纤维的增强作用，所有这些参数都将针对患者进行特异性标定。\n\n从超弹性和不可压缩性的第一性原理出发，推导柯西应力张量 $\\boldsymbol{\\sigma}$，使其成为一个用不变量和纤维方向表示的闭式表达式。你的推导必须从基本定义和能量函数 $W$ 开始，并且不得假定任何预先推导出的应力公式。最终结果只能使用符号 $C_{10}$、$k_1$、$k_2$、$\\bar{I}_4$、$\\boldsymbol{B}$、$\\boldsymbol{m}$、$\\boldsymbol{I}$ 以及用于施加不可压缩性约束的拉格朗日乘子 $p$ 来表示。最终答案必须是单一的解析表达式。不需要进行数值计算。",
            "solution": "合适的出发点是超弹性原理，该原理指出应力源于应变能密度对应变度量的变分。对于不可压缩的超弹性材料，右柯西-格林张量 $\\boldsymbol{C}$ 是一个合适的应变度量，而第二皮奥拉-基尔霍夫应力 $\\boldsymbol{S}$ 可通过使用拉格朗日乘子 $p$ 来施加不可压缩性约束，从约束能量泛函中导出。具体来说，本构关系为\n$$\n\\boldsymbol{S} = -p\\,\\boldsymbol{C}^{-1} + 2\\,\\frac{\\partial W}{\\partial \\boldsymbol{C}}.\n$$\n然后通过将 $\\boldsymbol{S}$ 前推得到柯西应力 $\\boldsymbol{\\sigma}$：\n$$\n\\boldsymbol{\\sigma} = \\frac{1}{J}\\,\\boldsymbol{F}\\,\\boldsymbol{S}\\,\\boldsymbol{F}^{\\top}.\n$$\n在不可压缩假设 $J=1$ 下，上式简化为\n$$\n\\boldsymbol{\\sigma} = \\boldsymbol{F}\\,\\boldsymbol{S}\\,\\boldsymbol{F}^{\\top}.\n$$\n\n接下来，我们根据 $W$ 所依赖的不变量，通过链式法则计算 $\\partial W/\\partial \\boldsymbol{C}$。给定的能量密度为\n$$\nW(I_1,\\bar{I}_4) = C_{10}\\,(I_1 - 3) + \\frac{k_1}{2k_2}\\left(\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right] - 1\\right),\n$$\n其中 $I_1 = \\operatorname{tr}(\\boldsymbol{C})$，并且在不可压缩条件下，$\\bar{I}_4 = I_4 = \\boldsymbol{a}_0 \\cdot \\boldsymbol{C}\\boldsymbol{a}_0$。$W$ 对 $\\boldsymbol{C}$ 的微分为\n$$\n\\frac{\\partial W}{\\partial \\boldsymbol{C}} = \\frac{\\partial W}{\\partial I_1}\\,\\frac{\\partial I_1}{\\partial \\boldsymbol{C}} + \\frac{\\partial W}{\\partial \\bar{I}_4}\\,\\frac{\\partial \\bar{I}_4}{\\partial \\boldsymbol{C}}.\n$$\n我们分别计算各项：\n\n1. 对于第一个不变量，\n$$\n\\frac{\\partial I_1}{\\partial \\boldsymbol{C}} = \\boldsymbol{I},\n$$\n其中 $\\boldsymbol{I}$ 是单位张量，且\n$$\n\\frac{\\partial W}{\\partial I_1} = C_{10}.\n$$\n\n2. 对于不可压缩条件下的纤维不变量，\n$$\n\\bar{I}_4 = I_4 = \\boldsymbol{a}_0 \\cdot \\boldsymbol{C}\\boldsymbol{a}_0,\n$$\n其张量导数为\n$$\n\\frac{\\partial \\bar{I}_4}{\\partial \\boldsymbol{C}} = \\boldsymbol{a}_0 \\otimes \\boldsymbol{a}_0.\n$$\n$W$ 对 $\\bar{I}_4$ 的标量导数为\n$$\n\\frac{\\partial W}{\\partial \\bar{I}_4} = \\frac{k_1}{2k_2}\\,\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right] \\cdot \\frac{d}{d\\bar{I}_4}\\left(k_2(\\bar{I}_4 - 1)^2\\right) = k_1\\,(\\bar{I}_4 - 1)\\,\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right].\n$$\n\n将这些结果汇总，\n$$\n\\frac{\\partial W}{\\partial \\boldsymbol{C}} = C_{10}\\,\\boldsymbol{I} + k_1\\,(\\bar{I}_4 - 1)\\,\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right]\\,(\\boldsymbol{a}_0 \\otimes \\boldsymbol{a}_0).\n$$\n因此，第二皮奥拉-基尔霍夫应力为\n$$\n\\boldsymbol{S} = -p\\,\\boldsymbol{C}^{-1} + 2\\,C_{10}\\,\\boldsymbol{I} + 2\\,k_1\\,(\\bar{I}_4 - 1)\\,\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right]\\,(\\boldsymbol{a}_0 \\otimes \\boldsymbol{a}_0).\n$$\n\n现在我们将 $\\boldsymbol{S}$ 前推以获得柯西应力。使用 $\\boldsymbol{\\sigma} = \\boldsymbol{F}\\,\\boldsymbol{S}\\,\\boldsymbol{F}^{\\top}$ 并回顾恒等式 $\\boldsymbol{F}\\,\\boldsymbol{C}^{-1}\\,\\boldsymbol{F}^{\\top} = \\boldsymbol{I}$（因为 $\\boldsymbol{C} = \\boldsymbol{F}^{\\top}\\boldsymbol{F}$）、$\\boldsymbol{F}\\,\\boldsymbol{I}\\,\\boldsymbol{F}^{\\top} = \\boldsymbol{B}$ 以及 $\\boldsymbol{F}\\,(\\boldsymbol{a}_0 \\otimes \\boldsymbol{a}_0)\\,\\boldsymbol{F}^{\\top} = (\\boldsymbol{F}\\boldsymbol{a}_0)\\otimes(\\boldsymbol{F}\\boldsymbol{a}_0) = \\boldsymbol{m} \\otimes \\boldsymbol{m}$，我们得到\n$$\n\\boldsymbol{\\sigma} = -p\\,\\boldsymbol{I} + 2\\,C_{10}\\,\\boldsymbol{B} + 2\\,k_1\\,(\\bar{I}_4 - 1)\\,\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right]\\,(\\boldsymbol{m} \\otimes \\boldsymbol{m}).\n$$\n\n该表达式用不变量 $I_1$ 和 $\\bar{I}_4$（通过它们在系数中的出现）以及结构张量 $\\boldsymbol{B}$ 和 $\\boldsymbol{m}\\otimes\\boldsymbol{m}$ 来表示柯西应力，其中 $p$ 施加了不可压缩性约束。它直接适用于患者特异性建模，因为纤维方向 $\\boldsymbol{a}_0$（并因此包括 $\\boldsymbol{m}$ 和 $\\bar{I}_4$）以及材料参数 $C_{10}$、$k_1$、$k_2$ 都是使用患者特异性数据进行标定的。",
            "answer": "$$\\boxed{-p\\,\\boldsymbol{I} + 2\\,C_{10}\\,\\boldsymbol{B} + 2\\,k_1\\,(\\bar{I}_4 - 1)\\,\\exp\\!\\left[k_2(\\bar{I}_4 - 1)^2\\right]\\,(\\boldsymbol{m} \\otimes \\boldsymbol{m})}$$"
        },
        {
            "introduction": "在定义了材料的本构模型后，下一步是利用有限元或有限体积等计算方法求解控制方程。然而，这些数值方法会引入离散误差，其大小取决于网格的精细程度。本练习将指导您如何进行网格收敛性研究，这是一个至关重要的验证步骤，旨在量化离散误差并确保模拟结果的可靠性和可信度，这在临床应用中是不可或缺的。",
            "id": "4198139",
            "problem": "您的任务是为一个患者特异性的脑动脉瘤血流动力学计算流体力学模型验证数值网格收敛性，重点关注壁面剪切应力 (WSS)。该场景设定在生物力学和个性化医疗的背景下，其中量化离散化不确定性对于临床可靠性至关重要。从基本的离散化误差模型和系统性网格加密的概念基础出发，您的程序必须使用三个加密的网格计算壁面剪切应力 (WSS) 的网格收敛指数 (GCI) 和观测到的精度阶数。\n\n使用以下基本依据：\n- 连续介质模型的有限体积或有限元离散化会引入一个由领头阶项表示的离散化误差，使得特征尺寸为 $\\,h\\,$ 的网格上的离散解 $\\,\\phi(h)\\,$ 满足 $\\,\\phi(h) = \\phi^\\ast + C h^p\\,$，其中 $\\,\\phi^\\ast\\,$ 是连续介质（网格无关）解，$\\,C\\,$ 是一个常数，$\\,p\\,$ 是精度阶数。\n- 系统性网格加密意味着有三个特征尺寸为 $\\,h_1  h_2  h_3\\,$ 的网格，以及加密比 $\\,r_{21} = h_2/h_1\\,$ 和 $\\,r_{32} = h_3/h_2\\,$。\n- 网格收敛指数 (GCI) 是对给定网格对上离散化不确定性的无量纲十进制量化，其中包含一个安全系数。它基于连续加密的网格之间的观测差异和观测阶数 $\\,p\\,$。\n\n您的程序必须从第一性原理出发实现以下任务：\n1. 给定 $\\,\\phi_1\\,$, $\\,\\phi_2\\,$ 和 $\\,\\phi_3\\,$ （分别在尺寸为 $\\,h_1\\,$, $\\,h_2\\,$ 和 $\\,h_3\\,$ 的网格上计算的 WSS），使用三网格离散化误差模型 $\\,\\phi(h) = \\phi^\\ast + C h^p\\,$ 和系统性加密比 $\\,r_{21}\\,$ 和 $\\,r_{32}\\,$，推断观测到的精度阶数 $\\,p\\,$。\n2. 使用最密网格和推断出的 $\\,p\\,$ 计算 Richardson 外推的 WSS $\\,\\phi_{\\mathrm{ext}}\\,$。\n3. 使用 $\\,1.25\\,$ 的安全系数计算密/中等网格 GCI $\\,\\mathrm{GCI}_{21}\\,$ 和中等/粗网格 GCI $\\,\\mathrm{GCI}_{32}\\,$。\n4. 判断 $\\,\\phi\\,$ 值序列是否呈现单调收敛（一个布尔值，指示连续差异是否具有相同的符号）。\n5. 为每个测试用例以结构化、单位一致且机器可检查的格式生成所有输出。\n\n使用这些科学上合理的测试用例。所有 WSS 值必须以帕斯卡 (Pa) 为单位，网格特征尺寸必须以米 (m) 为单位。安全系数固定为 $\\,1.25\\,$。此问题不使用角度。观测阶数 $\\,p\\,$ 和 GCI 值为无量纲。将所有浮点输出四舍五入到小数点后六位。\n\n- 测试用例 1（等加密比，单调收敛）：\n  - $\\,h_1 = 2.0 \\times 10^{-4}\\,\\mathrm{m}\\,$, $\\,h_2 = 4.0 \\times 10^{-4}\\,\\mathrm{m}\\,$, $\\,h_3 = 8.0 \\times 10^{-4}\\,\\mathrm{m}\\,$.\n  - $\\,\\phi_1 = 5.012\\,\\mathrm{Pa}\\,$, $\\,\\phi_2 = 5.048\\,\\mathrm{Pa}\\,$, $\\,\\phi_3 = 5.192\\,\\mathrm{Pa}\\,$.\n- 测试用例 2（不等加密比，单调收敛）：\n  - $\\,h_1 = 5.0 \\times 10^{-4}\\,\\mathrm{m}\\,$, $\\,h_2 = 7.5 \\times 10^{-4}\\,\\mathrm{m}\\,$, $\\,h_3 = 1.5 \\times 10^{-3}\\,\\mathrm{m}\\,$.\n  - $\\,\\phi_1 = 4.900\\,\\mathrm{Pa}\\,$, $\\,\\phi_2 = 5.025\\,\\mathrm{Pa}\\,$, $\\,\\phi_3 = 5.700\\,\\mathrm{Pa}\\,$.\n- 测试用例 3（等加密比，振荡收敛）：\n  - $\\,h_1 = 3.0 \\times 10^{-4}\\,\\mathrm{m}\\,$, $\\,h_2 = 6.0 \\times 10^{-4}\\,\\mathrm{m}\\,$, $\\,h_3 = 1.2 \\times 10^{-3}\\,\\mathrm{m}\\,$.\n  - $\\,\\phi_1 = 4.980\\,\\mathrm{Pa}\\,$, $\\,\\phi_2 = 5.020\\,\\mathrm{Pa}\\,$, $\\,\\phi_3 = 4.940\\,\\mathrm{Pa}\\,$.\n\n您的程序必须：\n- 将 WSS 输入视为帕斯卡 (Pa)，将 $\\,h\\,$ 视为米 (m)。\n- 对每个测试用例，计算并输出一个列表，按顺序包含 $\\,p\\,$、$\\,\\mathrm{GCI}_{21}\\,$、$\\,\\mathrm{GCI}_{32}\\,$、$\\,\\phi_{\\mathrm{ext}}\\,$ 和单调收敛布尔值。\n- 将 $\\,p\\,$、$\\,\\mathrm{GCI}_{21}\\,$、$\\,\\mathrm{GCI}_{32}\\,$ 和 $\\,\\phi_{\\mathrm{ext}}\\,$ 四舍五入到小数点后六位。将 GCI 值表示为小数（无百分号）。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个以逗号分隔的各测试用例列表的列表，不含空格，并用方括号括起来。例如：\"[[p1,GCI21_1,GCI32_1,phi_ext_1,flag1],[p2,GCI21_2,GCI32_2,phi_ext_2,flag2],[p3,GCI21_3,GCI32_3,phi_ext_3,flag3]]\"。",
            "solution": "在尝试解决问题之前，对问题陈述的有效性进行了严格评估。\n\n### 第 1 步：提取已知条件\n- **离散化误差模型**：特征尺寸为 $h$ 的网格上的离散解 $\\phi(h)$ 由 $\\phi(h) = \\phi^\\ast + C h^p$ 给出，其中 $\\phi^\\ast$ 是连续介质（网格无关）解，$C$ 是一个常数，$p$ 是精度阶数。\n- **网格层级**：使用三个特征尺寸为 $h_1  h_2  h_3$ 的网格。\n- **加密比**：$r_{21} = h_2/h_1$ 和 $r_{32} = h_3/h_2$。\n- **解变量**：$\\phi_1$、$\\phi_2$ 和 $\\phi_3$ 分别是对应于尺寸为 $h_1$、$h_2$ 和 $h_3$ 的网格的解（壁面剪切应力，WSS）。\n- **安全系数**：为网格收敛指数 (GCI) 计算指定了安全系数 $F_s = 1.25$。\n- **任务**：\n  1. 推断观测到的精度阶数 $p$。\n  2. 计算 Richardson 外推的 WSS $\\phi_{\\mathrm{ext}}$。\n  3. 计算密/中等网格 GCI $\\mathrm{GCI}_{21}$ 和中等/粗网格 GCI $\\mathrm{GCI}_{32}$。\n  4. 判断收敛是否为单调（布尔值）。\n- **测试用例 1**：\n  - $h_1 = 2.0 \\times 10^{-4}\\,\\mathrm{m}$, $h_2 = 4.0 \\times 10^{-4}\\,\\mathrm{m}$, $h_3 = 8.0 \\times 10^{-4}\\,\\mathrm{m}$。\n  - $\\phi_1 = 5.012\\,\\mathrm{Pa}$, $\\phi_2 = 5.048\\,\\mathrm{Pa}$, $\\phi_3 = 5.192\\,\\mathrm{Pa}$。\n- **测试用例 2**：\n  - $h_1 = 5.0 \\times 10^{-4}\\,\\mathrm{m}$, $h_2 = 7.5 \\times 10^{-4}\\,\\mathrm{m}$, $h_3 = 1.5 \\times 10^{-3}\\,\\mathrm{m}$。\n  - $\\phi_1 = 4.900\\,\\mathrm{Pa}$, $\\phi_2 = 5.025\\,\\mathrm{Pa}$, $\\phi_3 = 5.700\\,\\mathrm{Pa}$。\n- **测试用例 3**：\n  - $h_1 = 3.0 \\times 10^{-4}\\,\\mathrm{m}$, $h_2 = 6.0 \\times 10^{-4}\\,\\mathrm{m}$, $h_3 = 1.2 \\times 10^{-3}\\,\\mathrm{m}$。\n  - $\\phi_1 = 4.980\\,\\mathrm{Pa}$, $\\phi_2 = 5.020\\,\\mathrm{Pa}$, $\\phi_3 = 4.940\\,\\mathrm{Pa}$。\n- **输出要求**：所有浮点输出（$\\,p\\,$、$\\,\\mathrm{GCI}_{21}\\,$、$\\,\\mathrm{GCI}_{32}\\,$、$\\,\\phi_{\\mathrm{ext}}\\,$）都需四舍五入到小数点后六位。最终输出必须是单行，包含一个按指定格式排列的列表的列表。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题基于网格收敛指数 (GCI) 方法论，这是一种在计算流体力学及其他计算力学领域中量化数值不确定性的标准、被广泛接受的程序。其底层的误差模型是离散化误差泰勒级数展开的直接结果。其背景，即患者特异性脑动脉瘤建模，是生物力学中一个科学相关且关键的应用领域。该问题在科学上是合理的。\n- **适定性**：该问题是适定的。它提供了所有必要的输入（网格尺寸、解值、安全系数）和一套明确的可交付成果。其数学框架虽然在一般情况下需要数值解，但在物理上有意义的范围内，允许 $p$ 有唯一解。\n- **客观性**：问题陈述使用了精确、定量且无偏见的语言。所有输入都是数值，所有要求的输出都是明确定义的量。\n- **一致性与完整性**：该问题是自洽的。提供了所有测试用例的数据，不需要外部信息。已知条件中没有矛盾。测试用例是模拟结果的合理解释。\n\n### 第 3 步：结论与行动\n该问题有效。它具有科学依据，是适定的、客观的和自洽的。可以根据所提供的原则制定出严谨的解决方案。\n\n### 解题推导\n解是从基本误差模型 $\\phi(h) = \\phi^\\ast + C h^p$ 推导出来的。我们考虑三套网格上的解，用下标 $1$（密）、$2$（中等）和 $3$（粗）表示：\n$$ \\phi_1 = \\phi(h_1) = \\phi^\\ast + C h_1^p $$\n$$ \\phi_2 = \\phi(h_2) = \\phi^\\ast + C h_2^p $$\n$$ \\phi_3 = \\phi(h_3) = \\phi^\\ast + C h_3^p $$\n连续网格上解之间的差异定义为 $\\epsilon_{21} = \\phi_2 - \\phi_1$ 和 $\\epsilon_{32} = \\phi_3 - \\phi_2$。\n\n1.  **单调收敛**\n    如果随着网格加密，解从一侧趋近于渐近值 $\\phi^\\ast$，则收敛是单调的。这意味着序列 $\\phi_3, \\phi_2, \\phi_1$ 是单调的。在数学上，如果连续差异 $\\epsilon_{32}$ 和 $\\epsilon_{21}$ 具有相同的符号，则满足此条件。因此，如果差异之比 $s = \\epsilon_{32} / \\epsilon_{21}$ 为正，则确认为单调收敛。\n    $$ \\text{is\\_monotonic} = \\left( s = \\frac{\\phi_3 - \\phi_2}{\\phi_2 - \\phi_1} > 0 \\right) $$\n    如果 $s  0$，则收敛是振荡的。分母 $\\phi_2 - \\phi_1$ 必须为非零。\n\n2.  **观测精度阶数 ($p$)**\n    根据误差模型，我们可以将差异表示为：\n    $$ \\epsilon_{21} = (\\phi^\\ast + C h_2^p) - (\\phi^\\ast + C h_1^p) = C(h_2^p - h_1^p) = C h_1^p (r_{21}^p - 1) $$\n    $$ \\epsilon_{32} = (\\phi^\\ast + C h_3^p) - (\\phi^\\ast + C h_2^p) = C(h_3^p - h_2^p) = C h_2^p (r_{32}^p - 1) $$\n    取这些差异的比值可以消去未知常数 $C$：\n    $$ s = \\frac{\\epsilon_{32}}{\\epsilon_{21}} = \\frac{C h_2^p (r_{32}^p - 1)}{C h_1^p (r_{21}^p - 1)} = \\left(\\frac{h_2}{h_1}\\right)^p \\frac{r_{32}^p - 1}{r_{21}^p - 1} = r_{21}^p \\frac{r_{32}^p - 1}{r_{21}^p - 1} $$\n    这给出了求解 $p$ 的方程：\n    $$ s(r_{21}^p - 1) - r_{21}^p(r_{32}^p - 1) = 0 $$\n    在均匀加密的特殊情况下，即 $r_{21} = r_{32} = r$，方程简化为 $s = r^p$。对于单调收敛（$s0$），可以直接求出 $p$：\n    $$ p = \\frac{\\ln(s)}{\\ln(r)} $$\n    对于振荡收敛（$s0$），此方程不存在 $p$ 的实数解。然而，为了满足问题对数值输出的要求，一种常见的实用方法是使用 $s$ 的绝对值，即 $p = \\ln(|s|) / \\ln(r)$。这是一种工程近似，因为振荡收敛表明单项误差模型不成立。\n    在非均匀加密的一般情况下，必须通过数值方法（例如，使用求根算法）求解关于 $p$ 的超越方程。如果收敛是振荡的，将同样采用 $|s|$ 的实用方法。\n\n3.  **Richardson 外推 ($\\phi_{\\mathrm{ext}}$)**\n    Richardson 外推通过消除领头阶误差项来提供连续介质解 $\\phi^\\ast$（此处表示为 $\\phi_{\\mathrm{ext}}$）的估计值。使用两套最密网格的解 $\\phi_1$ 和 $\\phi_2$：\n    $$ \\phi_1 = \\phi_{\\mathrm{ext}} + C h_1^p $$\n    $$ \\phi_2 = \\phi_{\\mathrm{ext}} + C h_2^p = \\phi_{\\mathrm{ext}} + C (r_{21}h_1)^p = \\phi_{\\mathrm{ext}} + r_{21}^p (C h_1^p) $$\n    将 $C h_1^p = \\phi_1 - \\phi_{\\mathrm{ext}}$ 代入第二个方程：\n    $$ \\phi_2 = \\phi_{\\mathrm{ext}} + r_{21}^p (\\phi_1 - \\phi_{\\mathrm{ext}}) $$\n    求解 $\\phi_{\\mathrm{ext}}$ 得：\n    $$ \\phi_{\\mathrm{ext}}(r_{21}^p - 1) = r_{21}^p \\phi_1 - \\phi_2 $$\n    $$ \\phi_{\\mathrm{ext}} = \\frac{r_{21}^p \\phi_1 - \\phi_2}{r_{21}^p - 1} = \\phi_1 + \\frac{\\phi_1 - \\phi_2}{r_{21}^p - 1} $$\n    为提高数值稳定性，使用后一种形式。\n\n4.  **网格收敛指数 (GCI)**\n    GCI 以百分比或小数形式提供了离散化误差的保守估计。\n    对于密/中等网格对（$1$ 和 $2$），在密网格（$\\phi_1$）上的 GCI 为：\n    $$ \\mathrm{GCI}_{21} = F_s \\frac{|\\epsilon_a^{21}|}{r_{21}^p - 1} \\quad \\text{其中} \\quad \\epsilon_a^{21} = \\frac{\\phi_1 - \\phi_2}{\\phi_1} $$\n    对于中等/粗网格对（$2$ 和 $3$），在中等网格（$\\phi_2$）上的 GCI 为：\n    $$ \\mathrm{GCI}_{32} = F_s \\frac{|\\epsilon_a^{32}|}{r_{32}^p - 1} \\quad \\text{其中} \\quad \\epsilon_a^{32} = \\frac{\\phi_2 - \\phi_3}{\\phi_2} $$\n    安全系数 $F_s$ 给定为 $1.25$。\n\n理论框架至此完成。算法将对每个测试用例实施这些推导出的公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Structure: (h1, h2, h3, phi1, phi2, phi3)\n    test_cases = [\n        # Test Case 1 (equal refinement, monotonic)\n        (2.0e-4, 4.0e-4, 8.0e-4, 5.012, 5.048, 5.192),\n        # Test Case 2 (unequal refinement, monotonic)\n        (5.0e-4, 7.5e-4, 1.5e-3, 4.900, 5.025, 5.700),\n        # Test Case 3 (equal refinement, oscillatory)\n        (3.0e-4, 6.0e-4, 1.2e-3, 4.980, 5.020, 4.940),\n    ]\n\n    Fs = 1.25  # Safety Factor\n    all_results = []\n\n    for case in test_cases:\n        h1, h2, h3, phi1, phi2, phi3 = case\n        result = calculate_gci_metrics(h1, h2, h3, phi1, phi2, phi3, Fs)\n        all_results.append(result)\n\n    # Format the final output string as per requirements.\n    # Example: [[p1,GCI21_1,GCI32_1,phi_ext_1,flag1],...]\n    formatted_results = []\n    for res in all_results:\n        p, gci21, gci32, phi_ext, is_monotonic = res\n        # Format floats to 6 decimal places, boolean to Python's default string repr\n        formatted_list = [\n            f\"{p:.6f}\",\n            f\"{gci21:.6f}\",\n            f\"{gci32:.6f}\",\n            f\"{phi_ext:.6f}\",\n            str(is_monotonic)\n        ]\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_gci_metrics(h1, h2, h3, phi1, phi2, phi3, Fs):\n    \"\"\"\n    Calculates GCI metrics based on three-grid solutions.\n    \"\"\"\n    # 1. Calculate refinement ratios\n    r21 = h2 / h1\n    r32 = h3 / h2\n\n    # 2. Calculate solution differences\n    eps21 = phi2 - phi1\n    eps32 = phi3 - phi2\n    \n    # Edge case: if solutions are identical, p is undefined.\n    if np.isclose(eps21, 0.0):\n        # This case is not in the problem spec but is a necessary check.\n        # Indicates p - infinity or method failure. We return NaNs.\n        return (np.nan, np.nan, np.nan, np.nan, False)\n\n    # 3. Determine monotonic convergence\n    s = eps32 / eps21\n    is_monotonic = s  0\n\n    # 4. Calculate observed order of accuracy 'p'\n    # For oscillatory convergence, the standard method is not strictly valid.\n    # As a pragmatic step required by the problem, use abs(s).\n    s_abs = abs(s)\n\n    # Check for uniform refinement, which has an analytical solution\n    if np.isclose(r21, r32):\n        r = r21\n        # Handle case where s is close to 0 or 1.\n        if np.isclose(s_abs, 0.0) or np.isclose(r, 1.0):\n             p = np.nan # Undefined\n        else:\n             p = np.log(s_abs) / np.log(r)\n    else:\n        # Non-uniform refinement requires a numerical root-finder.\n        # The equation to solve is: s * (r21^p - 1) - r21^p * (r32^p - 1) = 0\n        def p_equation(p_val):\n            # Use np.power for robust handling of potential float exponents\n            term1 = s_abs * (np.power(r21, p_val) - 1.0)\n            term2 = np.power(r21, p_val) * (np.power(r32, p_val) - 1.0)\n            return term1 - term2\n        \n        try:\n            # Search for a root in a physically plausible range (e.g., 0.1 to 5)\n            sol = root_scalar(p_equation, bracket=[0.1, 5.0], method='brentq')\n            p = sol.root\n        except ValueError:\n            # If no root is found in the bracket, the model might be invalid.\n            p = np.nan\n\n    # 5. Calculate Richardson Extrapolation\n    # phi_ext = phi1 + (phi1 - phi2) / (r21^p - 1)\n    if not np.isclose(np.power(r21, p), 1.0):\n        phi_ext = phi1 + (phi1 - phi2) / (np.power(r21, p) - 1.0)\n    else:\n        phi_ext = np.nan\n\n    # 6. Calculate Grid Convergence Indices (GCI)\n    # GCI_21 for the fine/medium grid pair, on the fine grid solution\n    denom21 = np.power(r21, p) - 1.0\n    if not np.isclose(denom21, 0.0) and not np.isclose(phi1, 0.0):\n        rel_err_21 = abs((phi1 - phi2) / phi1)\n        gci21 = Fs * rel_err_21 / denom21\n    else:\n        gci21 = np.nan\n\n    # GCI_32 for the medium/coarse grid pair, on the medium grid solution\n    denom32 = np.power(r32, p) - 1.0\n    if not np.isclose(denom32, 0.0) and not np.isclose(phi2, 0.0):\n        rel_err_32 = abs((phi2 - phi3) / phi2)\n        gci32 = Fs * rel_err_32 / denom32\n    else:\n        gci32 = np.nan\n        \n    return (p, gci21, gci32, phi_ext, is_monotonic)\n\n# Execute the solution\nsolve()\n\n```"
        },
        {
            "introduction": "一个可靠的力学模型框架本身并不足够，它必须通过患者特异性数据进行个性化校准。本练习旨在解决参数估计这一核心任务，即调整模型的材料参数以匹配临床测量数据。此外，本练习还引入了剖面似然这一强大的统计技术，用于评估这些参数的实际可辨识性并量化其估计的不确定性，从而使我们从一个确定性的模型走向对结果的概率性理解。",
            "id": "4198157",
            "problem": "您的任务是利用带有加性噪声的压力-直径测量数据，为个性化医疗构建一个针对特定患者的动脉壁模型。您必须从生物力学第一性原理出发，利用薄壁平衡和指数型本构律推导出从直径到压力的映射关系，然后实施剖面似然分析，以评估两个刚度参数的实际可识别性。您的最终程序必须模拟三个测试案例的数据，拟合模型，计算每个参数的剖面似然，并报告量化可识别性的置信区间宽度。\n\n从以下基本原理开始：\n\n- 薄壁周向平衡 (Laplace定律)：周向Cauchy应力与血压的关系为 $$\\sigma_{\\theta} = \\frac{P R}{h},$$ 其中 $P$ 是血压，$R$ 是变形后的血管半径，$h$ 是壁厚。此平衡适用于壁厚相对于半径较小的动脉。\n\n- Green-Lagrange周向应变定义：$$E_{\\theta} = \\frac{1}{2}(\\lambda_{\\theta}^2 - 1), \\quad \\lambda_{\\theta} = \\frac{D}{D_0},$$ 其中 $D$ 是变形后的直径，$D_0$ 是参考直径。\n\n- 带有两个未知刚度参数的指数型应力-应变律 (Fung型)：$$\\sigma_{\\theta}(E_{\\theta}; a,b) = a \\, \\exp(b \\, E_{\\theta}),$$ 其中 $a$ 的单位是应力，$b$ 是无量纲的。\n\n假设观测到的压力是由带有加性独立同分布、方差未知的高斯噪声的正向模型生成的。给定测量值 $\\{(D_i, P_i^{\\text{obs}})\\}_{i=1}^{n}$，观测模型为 $$P_i^{\\text{obs}} = P(D_i; a,b) + \\varepsilon_i, \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2),$$ 其中 $\\sigma^2$ 是（未知的）噪声方差，$P(D_i; a,b)$ 是从推导的平衡关系得出的、在直径 $D_i$ 处由模型预测的压力。\n\n您必须：\n1. 从给定的基本原理出发，不走捷径，推导出 $P(D;a,b)$ 作为 $D$、$a$、$b$、$D_0$ 和 $h$ 的函数表达式。\n2. 使用将方差集总消去的高斯似然来定义每个参数的剖面似然。令残差平方和为 $$\\mathrm{SSE}(a,b) = \\sum_{i=1}^{n} \\left(P_i^{\\text{obs}} - P(D_i; a,b)\\right)^2.$$ 最大似然估计 (maximum likelihood estimate, MLE) $(\\hat{a},\\hat{b})$ 使 $\\mathrm{SSE}(a,b)$ 最小化。对于固定的 $a$ 值（或 $b$ 值），定义剖面残差平方和 $$\\mathrm{SSE}_a(a) = \\min_{b0} \\mathrm{SSE}(a,b), \\quad \\mathrm{SSE}_b(b) = \\min_{a0} \\mathrm{SSE}(a,b).$$ 使用集总高斯似然，单个剖面参数的似然比统计量为 $$\\Delta_a(a) = n \\, \\ln\\!\\left(\\frac{\\mathrm{SSE}_a(a)}{\\mathrm{SSE}(\\hat{a},\\hat{b})}\\right), \\quad \\Delta_b(b) = n \\, \\ln\\!\\left(\\frac{\\mathrm{SSE}_b(b)}{\\mathrm{SSE}(\\hat{a},\\hat{b})}\\right).$$ 在正则性条件下，$\\Delta_a$ 和 $\\Delta_b$ 近似服从自由度为1的卡方随机变量分布。将每个参数的置信区间定义为剖面统计量不超过自由度为1、水平为0.95的卡方分位数的那组值的集合。\n3. 实现一个程序，在指定的网格上计算剖面似然和相应的置信区间，并报告每个参数的置信区间宽度。在每个测试案例中，将 $D_0$ 和 $h$ 视为已知的患者特定常数，并在优化过程中强制执行 $a0$ 和 $b0$ 的正性约束。\n\n物理和数值单位：\n- 压力 $P$ 必须以千帕 (kPa) 为单位。\n- 直径 $D$ 和厚度 $h$ 必须以毫米 (mm) 为单位。\n- 报告 $a$ 的置信区间宽度，单位为千帕 (kPa)；报告 $b$ 的置信区间宽度，为无量纲数。两者均四舍五入至六位小数。\n\n测试套件规范：\n- 测试案例1 (信息充分，较低噪声)：\n  - 参考直径 $D_0 = 10$ mm，壁厚 $h = 1$ mm。\n  - 真实参数 $a_{\\text{true}} = 120$ kPa, $b_{\\text{true}} = 6$。\n  - 直径 $D_i$ 在 $8$ mm 到 $12$ mm 之间均匀分布，共 $n = 30$ 个点。\n  - 噪声标准差 $\\sigma = 2$ kPa。\n  - 随机种子 $123$ 以确保可复现性。\n- 测试案例2 (直径范围窄，较高噪声)：\n  - 参考直径 $D_0 = 10$ mm，壁厚 $h = 1$ mm。\n  - 真实参数 $a_{\\text{true}} = 120$ kPa, $b_{\\text{true}} = 6$。\n  - 直径 $D_i$ 在 $9.8$ mm 到 $10.5$ mm 之间均匀分布，共 $n = 20$ 个点。\n  - 噪声标准差 $\\sigma = 8$ kPa。\n  - 随机种子 $456$ 以确保可复现性。\n- 测试案例3 (近线性响应，中等噪声)：\n  - 参考直径 $D_0 = 10$ mm，壁厚 $h = 1$ mm。\n  - 真实参数 $a_{\\text{true}} = 120$ kPa, $b_{\\text{true}} = 1$。\n  - 直径 $D_i$ 在 $8.5$ mm 到 $11.5$ mm 之间均匀分布，共 $n = 30$ 个点。\n  - 噪声标准差 $\\sigma = 3$ kPa。\n  - 随机种子 $789$ 以确保可复现性。\n\n剖面网格和置信区间构建：\n- 对于 $a$，在从 20 kPa 到 300 kPa 的 201 个点的网格上评估剖面。\n- 对于 $b$，在从 0.5 到 12 的 201 个点的网格上评估剖面。\n- 使用自由度为1、水平为0.95的卡方分位数来确定每个参数的置信区间。如果整个网格都满足不等式，或者没有网格点满足不等式，则报告整个网格宽度作为置信区间宽度，以表明在探测范围内存在实际上的不可识别性。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试案例的 $a$ 和 $b$ 的置信区间宽度，按顺序排列，并用方括号括起来的逗号分隔列表。这六个值必须按 $[w_a^{(1)}, w_b^{(1)}, w_a^{(2)}, w_b^{(2)}, w_a^{(3)}, w_b^{(3)}]$ 的顺序排列，其中 $w_a^{(j)}$ 是测试案例 $j$ 中 $a$ 的置信区间宽度（单位为 kPa），$w_b^{(j)}$ 是测试案例 $j$ 中 $b$ 的置信区间宽度（无量纲），每个值都四舍五入到六位小数。例如，输出必须具有以下形式 $$[w_a^{(1)},w_b^{(1)},w_a^{(2)},w_b^{(2)},w_a^{(3)},w_b^{(3)}].$$",
            "solution": "该问题已经过验证，被认为是可靠的。它在科学上基于生物力学和统计学的既定原理，问题定义明确、客观，并包含进行求解所需的所有必要信息。\n\n该任务要求推导一个针对特定患者的动脉壁模型，然后实施剖面似然分析，以评估从模拟的含噪数据中参数的可识别性。\n\n**1. 压力-直径关系的推导**\n\n目标是推导出一个表示内压 $P$ 作为血管直径 $D$ 和一组模型参数的函数的表达式。这是通过结合所提供的机械平衡、应变运动学和本构行为方程来实现的。\n\n首先，周向Green-Lagrange应变 $E_{\\theta}$ 是根据周向拉伸 $\\lambda_{\\theta}$ 定义的：\n$$E_{\\theta} = \\frac{1}{2}(\\lambda_{\\theta}^2 - 1)$$\n拉伸 $\\lambda_{\\theta}$ 是变形后直径 $D$ 与参考（零应力）直径 $D_0$ 的比值：\n$$\\lambda_{\\theta} = \\frac{D}{D_0}$$\n将 $\\lambda_{\\theta}$ 的表达式代入应变定义，得到 $E_{\\theta}$ 作为 $D$ 的函数：\n$$E_{\\theta} = \\frac{1}{2}\\left(\\left(\\frac{D}{D_0}\\right)^2 - 1\\right)$$\n\n接下来，Fung型指数本构律通过两个材料参数 $a$ 和 $b$ 将周向Cauchy应力 $\\sigma_{\\theta}$ 与应变 $E_{\\theta}$ 联系起来：\n$$\\sigma_{\\theta} = a \\exp(b E_{\\theta})$$\n将推导出的 $E_{\\theta}$ 表达式代入该定律，得到应力作为直径的函数：\n$$\\sigma_{\\theta} = a \\exp\\left(b \\left[\\frac{1}{2}\\left(\\frac{D}{D_0}\\right)^2 - \\frac{1}{2}\\right]\\right) = a \\exp\\left(\\frac{b}{2}\\left[\\left(\\frac{D}{D_0}\\right)^2 - 1\\right]\\right)$$\n\n最后，薄壁平衡方程 (Laplace定律) 将应力 $\\sigma_{\\theta}$ 与内压 $P$、变形后半径 $R$ 和壁厚 $h$ 联系起来：\n$$\\sigma_{\\theta} = \\frac{P R}{h}$$\n由于半径是直径的一半，即 $R = D/2$，平衡方程变为：\n$$\\sigma_{\\theta} = \\frac{P (D/2)}{h} = \\frac{P D}{2h}$$\n\n为了找到压力-直径关系，我们将应力的本构表达式与应力的平衡表达式相等：\n$$\\frac{P D}{2h} = a \\exp\\left(\\frac{b}{2}\\left[\\left(\\frac{D}{D_0}\\right)^2 - 1\\right]\\right)$$\n求解 $P$ 得到最终的正向模型，我们将其表示为 $P(D; a, b)$：\n$$P(D; a,b) = \\frac{2ha}{D} \\exp\\left(\\frac{b}{2}\\left[\\left(\\frac{D}{D_0}\\right)^2 - 1\\right]\\right)$$\n该方程描述了在给定材料特性 ($a$, $b$) 和患者特定几何形状 ($D_0$, $h$) 的情况下，将血管维持在直径 $D$ 所需的压力。\n\n**2. 统计框架与数值实现**\n\n从含噪声的测量值 $\\{(D_i, P_i^{\\text{obs}})\\}$ 中估计参数 $a$ 和 $b$ 的问题被构建为一个非线性最小二乘问题。在加性、独立同分布的高斯噪声假设下，最小化残差平方和 (SSE) 等价于最大化似然。\n\nSSE由下式给出：\n$$\\mathrm{SSE}(a,b) = \\sum_{i=1}^{n} \\left(P_i^{\\text{obs}} - P(D_i; a,b)\\right)^2$$\n最大似然估计 (MLEs) $(\\hat{a}, \\hat{b})$ 是使该函数最小化的 $a$ 和 $b$ 的值，并受物理约束 $a0$ 和 $b0$ 的限制。\n$$(\\hat{a}, \\hat{b}) = \\arg\\min_{a0, b0} \\mathrm{SSE}(a,b)$$\nSSE 的最小值表示为 $\\mathrm{SSE}_{\\text{min}} = \\mathrm{SSE}(\\hat{a}, \\hat{b})$。这是一个二维数值优化问题。\n\n剖面似然分析用于单独评估每个参数的可识别性。对于一个感兴趣的参数（例如 $a$），对于其每个固定值，都会对讨厌参数（例如 $b$）进行优化以将其消除。\n\n$a$ 的剖面是通过在预定义网格上为每个 $a$ 值计算剖面残差平方和 $\\mathrm{SSE}_a(a)$ 来构建的：\n$$\\mathrm{SSE}_a(a^*) = \\min_{b0} \\mathrm{SSE}(a^*, b)$$\n这需要为每个固定的 $a^*$ 求解一个关于 $b$ 的一维优化问题。\n\n类似地，$b$ 的剖面是：\n$$\\mathrm{SSE}_b(b^*) = \\min_{a0} \\mathrm{SSE}(a, b^*)$$\n\n然后计算通用参数 $p$ 的似然比统计量 $\\Delta(p)$。对于参数 $a$，它是：\n$$\\Delta_a(a) = n \\cdot \\ln\\left(\\frac{\\mathrm{SSE}_a(a)}{\\mathrm{SSE}_{\\text{min}}}\\right)$$\n对于参数 $b$：\n$$\\Delta_b(b) = n \\cdot \\ln\\left(\\frac{\\mathrm{SSE}_b(b)}{\\mathrm{SSE}_{\\text{min}}}\\right)$$\n\n每个参数的逐点95%置信区间被定义为参数值的集合，对于这些值，似然比统计量不超过一个临界阈值。这个阈值是在置信水平 $1-\\alpha = 0.95$ 下，自由度为1的卡方分布的分位数。\n$$\\text{CI}_{95\\%} = \\{ p \\mid \\Delta(p) \\le \\chi^2_{1, 0.95} \\}$$\n在数值上，对于每个剖面（例如，对于 $a$），我们找到网格上所有满足 $\\Delta_a(a) \\le \\chi^2_{1, 0.95} \\approx 3.841$ 的值 $a_{\\text{grid}}$。置信区间宽度是该集合中最大值和最小值之差。\n\n对于每个测试案例，实现将按以下步骤进行：\n1.  通过向真实模型输出添加高斯噪声来生成合成压力数据 $P_i^{\\text{obs}}$，使用指定的随机种子以确保可复现性。\n2.  使用 `scipy.optimize.minimize` 进行二维优化，以找到 MLE $(\\hat{a}, \\hat{b})$ 和最小 SSE $\\mathrm{SSE}_{\\text{min}}$。将使用边界来强制执行正性约束。\n3.  对于每个参数（$a$ 和 $b$），遍历其预定义的网格。在每个网格点，对讨厌参数进行一维优化，以找到剖面SSE。\n4.  计算似然比统计量向量 $\\Delta_a$ 和 $\\Delta_b$。\n5.  通过将统计量与 $\\chi^2$ 临界值进行比较，确定95%置信区间内的参数值集合。\n6.  计算并存储该区间的宽度。问题规定，如果区间覆盖整个网格或为空，则应报告整个网格宽度，以表示实际上的不可识别性。\n7.  最后，将所有计算出的宽度收集并格式化为单个输出字符串。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the biomechanics profile likelihood problem for three test cases.\n    \"\"\"\n\n    # Test case definitions\n    test_cases = [\n        # Case 1: Well-informed, lower noise\n        {\n            \"D0\": 10.0, \"h\": 1.0, \"a_true\": 120.0, \"b_true\": 6.0,\n            \"D_range\": (8.0, 12.0), \"n\": 30, \"sigma\": 2.0, \"seed\": 123\n        },\n        # Case 2: Narrow diameter range, higher noise\n        {\n            \"D0\": 10.0, \"h\": 1.0, \"a_true\": 120.0, \"b_true\": 6.0,\n            \"D_range\": (9.8, 10.5), \"n\": 20, \"sigma\": 8.0, \"seed\": 456\n        },\n        # Case 3: Near-linear response, moderate noise\n        {\n            \"D0\": 10.0, \"h\": 1.0, \"a_true\": 120.0, \"b_true\": 1.0,\n            \"D_range\": (8.5, 11.5), \"n\": 30, \"sigma\": 3.0, \"seed\": 789\n        }\n    ]\n\n    # Profile grid definitions\n    a_grid = np.linspace(20.0, 300.0, 201)\n    b_grid = np.linspace(0.5, 12.0, 201)\n    \n    # Chi-square critical value for 95% CI, 1 degree of freedom\n    chi2_crit = chi2.ppf(0.95, df=1)\n\n    # Positivity constraints for optimization\n    bounds = [(1e-9, None), (1e-9, None)]\n\n    # Main function for the pressure model\n    def pressure_model(D, a, b, D0, h):\n        term_in_exp = (b / 2.0) * ((D / D0)**2 - 1.0)\n        return (2.0 * h * a / D) * np.exp(term_in_exp)\n\n    results = []\n    for case in test_cases:\n        # 1. Generate synthetic data\n        rng = np.random.default_rng(case[\"seed\"])\n        D_obs = np.linspace(case[\"D_range\"][0], case[\"D_range\"][1], case[\"n\"])\n        P_true = pressure_model(D_obs, case[\"a_true\"], case[\"b_true\"], case[\"D0\"], case[\"h\"])\n        P_obs = P_true + rng.normal(0, case[\"sigma\"], size=case[\"n\"])\n\n        # 2. Find MLEs and minimum SSE\n        def sse_global(params):\n            a, b = params\n            P_model = pressure_model(D_obs, a, b, case[\"D0\"], case[\"h\"])\n            return np.sum((P_obs - P_model)**2)\n\n        # A reasonable initial guess\n        initial_guess = [100.0, 5.0]\n        mle_result = minimize(sse_global, initial_guess, bounds=bounds, method='L-BFGS-B')\n        a_hat, b_hat = mle_result.x\n        sse_min = mle_result.fun\n\n        # 3. Calculate Profile Likelihood for parameter 'a'\n        sse_profile_a = np.zeros_like(a_grid)\n        for i, a_val in enumerate(a_grid):\n            def sse_profile_a_obj(b_param):\n                # Ensure b_param is a scalar\n                b = b_param[0]\n                P_model = pressure_model(D_obs, a_val, b, case[\"D0\"], case[\"h\"])\n                return np.sum((P_obs - P_model)**2)\n\n            res_prof_a = minimize(sse_profile_a_obj, [b_hat], bounds=[bounds[1]], method='L-BFGS-B')\n            sse_profile_a[i] = res_prof_a.fun\n        \n        delta_a = case[\"n\"] * np.log(sse_profile_a / sse_min)\n\n        # 4. Calculate Profile Likelihood for parameter 'b'\n        sse_profile_b = np.zeros_like(b_grid)\n        for i, b_val in enumerate(b_grid):\n            def sse_profile_b_obj(a_param):\n                # Ensure a_param is a scalar\n                a = a_param[0]\n                P_model = pressure_model(D_obs, a, b_val, case[\"D0\"], case[\"h\"])\n                return np.sum((P_obs - P_model)**2)\n\n            res_prof_b = minimize(sse_profile_b_obj, [a_hat], bounds=[bounds[0]], method='L-BFGS-B')\n            sse_profile_b[i] = res_prof_b.fun\n\n        delta_b = case[\"n\"] * np.log(sse_profile_b / sse_min)\n\n        # 5. Compute Confidence Interval Widths\n        # For 'a'\n        valid_points_a = a_grid[delta_a = chi2_crit]\n        if valid_points_a.size == 0 or valid_points_a.size == a_grid.size:\n            width_a = a_grid[-1] - a_grid[0]\n        else:\n            width_a = valid_points_a.max() - valid_points_a.min()\n        \n        # For 'b'\n        valid_points_b = b_grid[delta_b = chi2_crit]\n        if valid_points_b.size == 0 or valid_points_b.size == b_grid.size:\n            width_b = b_grid[-1] - b_grid[0]\n        else:\n            width_b = valid_points_b.max() - valid_points_b.min()\n            \n        results.append(f\"{width_a:.6f}\")\n        results.append(f\"{width_b:.6f}\")\n\n    # Final print statement\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}