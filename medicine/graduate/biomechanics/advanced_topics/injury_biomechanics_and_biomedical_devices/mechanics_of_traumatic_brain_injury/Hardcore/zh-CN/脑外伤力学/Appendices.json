{
    "hands_on_practices": [
        {
            "introduction": "理解创伤性脑损伤始于分析头部在撞击过程中的整体运动。本练习的核心是头部损伤标准（HIC），这是一个用于此类分析的基础工具，它将简化的撞击脉冲运动学与损伤风险联系起来。通过解决这个问题 ，您将应用冲量-动量原理来确定峰值加速度，并使用标准的 HIC 公式来量化损伤风险，这是安全工程和冲击生物力学领域的一项核心技能。",
            "id": "4188804",
            "problem": "一个平移性头部撞击通过一个柔性减速过程来建模，其中，颅骨质心以撞击前速度 $v_{0}$ 运动，在一个测得的撞击持续时间 $\\Delta t$ 内，通过一个近似半正弦的加速度脉冲而停止。假设在短时事件中，颅骨-大脑系统表现为单平移自由度，并忽略旋转。设加速度为 $a(t) = a_{\\max} \\sin\\!\\big(\\pi t / \\Delta t\\big)$（当 $0 \\le t \\le \\Delta t$ 时）且在其他情况下 $a(t) = 0$。使用冲量-动量原理和头部损伤标准 (HIC) 的标准定义，\n$$\n\\mathrm{HIC} = \\max_{\\substack{t_{1},\\,t_{2} \\\\ 0  t_{2}-t_{1} \\le 0.036}} \\left\\{ (t_{2}-t_{1}) \\left[ \\frac{1}{t_{2}-t_{1}} \\int_{t_{1}}^{t_{2}} a_{g}(t)\\, dt \\right]^{2.5} \\right\\},\n$$\n其中 $a_{g}(t) = a(t)/g_{0}$ 是以重力单位表示的加速度，且 $g_{0} = 9.80665 \\ \\mathrm{m/s^{2}}$，对于以下科学上合理的参数，确定 $\\mathrm{HIC}$ 的数值：撞击前速度 $v_{0} = 7.0 \\ \\mathrm{m/s}$ 和撞击持续时间 $\\Delta t = 12 \\ \\mathrm{ms}$。在你的推理中，将计算出的 $\\mathrm{HIC}$ 与通常引用的阈值 $\\mathrm{HIC}_{15} = 700$ 进行比较以评估严重程度，但最终答案只报告计算出的 $\\mathrm{HIC}$ 值。\n\n将最终的 $\\mathrm{HIC}$ 表示为一个纯数（使用以重力单位表示的 $a_{g}(t)$ 和以秒为单位的时间）。将你的答案四舍五入到三位有效数字。",
            "solution": "该问题要求计算一个以半正弦加速度脉冲建模的平移性头部撞击的头部损伤标准 (HIC)。该问题在冲击生物力学领域内提法得当且有科学依据。\n\n首先，我们必须根据给定的撞击参数确定峰值加速度 $a_{\\max}$。颅骨的质心在持续时间 $\\Delta t$ 内从初始速度 $v_{0}$ 变为静止。根据冲量-动量原理，速度的变化量等于加速度的时间积分。设初始速度方向为正。加速度作为减速度，其方向必为相反。然而，表达式 $a(t) = a_{\\max} \\sin(\\pi t / \\Delta t)$ 在 $t \\in (0, \\Delta t)$ 区间内为正。因此，我们将 $a(t)$ 解释为加速度矢量的大小。速度的变化量是 $v_{0}$。\n\n$$ \\int_{0}^{\\Delta t} a(t) dt = v_{0} $$\n代入给定的加速度分布：\n$$ \\int_{0}^{\\Delta t} a_{\\max} \\sin\\left(\\frac{\\pi t}{\\Delta t}\\right) dt = v_{0} $$\n计算该积分：\n$$ a_{\\max} \\left[ -\\frac{\\Delta t}{\\pi} \\cos\\left(\\frac{\\pi t}{\\Delta t}\\right) \\right]_{0}^{\\Delta t} = v_{0} $$\n$$ a_{\\max} \\left( -\\frac{\\Delta t}{\\pi} \\cos(\\pi) - \\left(-\\frac{\\Delta t}{\\pi} \\cos(0)\\right) \\right) = v_{0} $$\n$$ a_{\\max} \\left( \\frac{\\Delta t}{\\pi} + \\frac{\\Delta t}{\\pi} \\right) = \\frac{2 \\Delta t}{\\pi} a_{\\max} = v_{0} $$\n由此，我们求解峰值加速度 $a_{\\max}$：\n$$ a_{\\max} = \\frac{\\pi v_{0}}{2 \\Delta t} $$\n\nHIC 使用以重力单位表示的加速度 $a_{g}(t) = a(t)/g_{0}$ 来定义，其中 $g_{0} = 9.80665 \\ \\mathrm{m/s^{2}}$。以 g 为单位的峰值加速度是：\n$$ a_{g, \\max} = \\frac{a_{\\max}}{g_{0}} = \\frac{\\pi v_{0}}{2 \\Delta t g_{0}} $$\n以 g 为单位的加速度函数是 $a_{g}(t) = a_{g, \\max} \\sin(\\pi t / \\Delta t)$，其中 $t \\in [0, \\Delta t]$。\n\nHIC 公式为：\n$$ \\mathrm{HIC} = \\max_{\\substack{t_{1},\\,t_{2} \\\\ 0  t_{2}-t_{1} \\le 0.036}} \\left\\{ (t_{2}-t_{1}) \\left[ \\frac{1}{t_{2}-t_{1}} \\int_{t_{1}}^{t_{2}} a_{g}(t)\\, dt \\right]^{2.5} \\right\\} $$\n撞击的总持续时间为 $\\Delta t = 12 \\ \\mathrm{ms} = 0.012 \\ \\mathrm{s}$。由于 $\\Delta t  0.036 \\ \\mathrm{s}$，撞击事件 $[0, \\Delta t]$ 内的任何区间 $[t_{1}, t_{2}]$ 都将满足约束条件 $t_{2}-t_{1} \\le 0.036 \\ \\mathrm{s}$。加速度在 $[0, \\Delta t]$ 之外为零，因此我们只需考虑此范围内的区间。HIC 泛函可以写作：\n$$ F(t_{1}, t_{2}) = (t_{2}-t_{1})^{-1.5} \\left( \\int_{t_{1}}^{t_{2}} a_{g}(t)\\, dt \\right)^{2.5} $$\n加速度脉冲 $a_{g}(t)$ 关于其在 $t = \\Delta t/2$ 处的峰值对称。对于任何固定的区间持续时间 $\\Delta\\tau = t_{2}-t_{1}$，当积分区间关于 $a_{g}(t)$ 的峰值中心对称时，积分 $\\int a_{g}(t) dt$ 的值最大。因此，使 HIC 最大的区间 $[t_{1}, t_{2}]$ 必须关于 $t = \\Delta t/2$ 对称。\n\n设搜索区间为 $[t_{1}, t_{2}] = [\\Delta t/2 - \\delta, \\Delta t/2 + \\delta]$，其中 $2\\delta$ 是区间的持续时间。变量 $\\delta$ 的范围是从 $0$ 到 $\\Delta t/2$。\n$a_{g}(t)$ 在这个对称区间上的积分是：\n$$ \\int_{\\Delta t/2 - \\delta}^{\\Delta t/2 + \\delta} a_{g}(t) dt = a_{g, \\max} \\int_{\\Delta t/2 - \\delta}^{\\Delta t/2 + \\delta} \\sin\\left(\\frac{\\pi t}{\\Delta t}\\right) dt $$\n$$ = a_{g, \\max} \\left[ -\\frac{\\Delta t}{\\pi} \\cos\\left(\\frac{\\pi t}{\\Delta t}\\right) \\right]_{\\Delta t/2 - \\delta}^{\\Delta t/2 + \\delta} $$\n$$ = -a_{g, \\max} \\frac{\\Delta t}{\\pi} \\left[ \\cos\\left(\\frac{\\pi}{2} + \\frac{\\pi \\delta}{\\Delta t}\\right) - \\cos\\left(\\frac{\\pi}{2} - \\frac{\\pi \\delta}{\\Delta t}\\right) \\right] $$\n$$ = -a_{g, \\max} \\frac{\\Delta t}{\\pi} \\left[ -\\sin\\left(\\frac{\\pi \\delta}{\\Delta t}\\right) - \\sin\\left(\\frac{\\pi \\delta}{\\Delta t}\\right) \\right] = 2 a_{g, \\max} \\frac{\\Delta t}{\\pi} \\sin\\left(\\frac{\\pi \\delta}{\\Delta t}\\right) $$\n将此结果代入 HIC 泛函，区间持续时间为 $2\\delta$：\n$$ H(\\delta) = (2\\delta)^{-1.5} \\left( 2 a_{g, \\max} \\frac{\\Delta t}{\\pi} \\sin\\left(\\frac{\\pi \\delta}{\\Delta t}\\right) \\right)^{2.5} $$\n为了简化最大化过程，令 $x = \\pi \\delta / \\Delta t$。$x$ 的范围是 $(0, \\pi/2]$。则 $\\delta = x \\Delta t / \\pi$。\n$$ H(x) = \\left(\\frac{2 x \\Delta t}{\\pi}\\right)^{-1.5} \\left( 2 a_{g, \\max} \\frac{\\Delta t}{\\pi} \\sin(x) \\right)^{2.5} $$\n$$ H(x) = \\left(\\frac{2 \\Delta t}{\\pi}\\right)^{-1.5} x^{-1.5} \\left(2 a_{g, \\max} \\frac{\\Delta t}{\\pi}\\right)^{2.5} (\\sin x)^{2.5} $$\n$$ H(x) = \\left(\\frac{2 \\Delta t}{\\pi}\\right) (a_{g, \\max})^{2.5} \\left(\\frac{(\\sin x)^{2.5}}{x^{1.5}}\\right) = \\frac{2 \\Delta t}{\\pi} (a_{g, \\max})^{2.5} \\left(\\frac{\\sin x}{x^{0.6}}\\right)^{2.5} $$\n为了最大化 $H(x)$，我们必须在 $x \\in (0, \\pi/2]$ 的范围内最大化函数 $f(x) = \\frac{\\sin x}{x^{0.6}}$。我们通过将其导数设为零来找到临界点。\n$$ f'(x) = \\frac{d}{dx} \\left( (\\sin x) x^{-0.6} \\right) = (\\cos x)x^{-0.6} - 0.6(\\sin x)x^{-1.6} = 0 $$\n$$ (\\cos x)x^{-0.6} = 0.6(\\sin x)x^{-1.6} \\implies x \\cos x = 0.6 \\sin x $$\n$$ \\tan x = \\frac{x}{0.6} $$\n对这个超越方程在 $x \\in (0, \\pi/2]$ 区间内进行数值求解，得到最优值 $x_{\\mathrm{opt}} \\approx 1.05156$ 弧度。二阶导数分析证实这确实是一个最大值。\n\n现在我们使用给定参数计算 HIC 的数值：$v_{0} = 7.0 \\ \\mathrm{m/s}$，$\\Delta t = 0.012 \\ \\mathrm{s}$，以及 $g_{0} = 9.80665 \\ \\mathrm{m/s^{2}}$。我们可以使用以下表达式：\n$$ \\mathrm{HIC} = \\left(\\frac{2 \\Delta t}{\\pi}\\right)^{-1.5} \\left(\\frac{v_{0}}{g_{0}}\\right)^{2.5} \\left( \\frac{\\sin x_{\\mathrm{opt}}}{x_{\\mathrm{opt}}^{0.6}} \\right)^{2.5} $$\n我们来计算每一项：\n$$ \\frac{v_{0}}{g_{0}} = \\frac{7.0}{9.80665} \\approx 0.713818 $$\n$$ \\left(\\frac{v_{0}}{g_{0}}\\right)^{2.5} \\approx (0.713818)^{2.5} \\approx 0.43000 $$\n$$ \\frac{2 \\Delta t}{\\pi} = \\frac{2(0.012)}{\\pi} = \\frac{0.024}{\\pi} \\approx 0.00763944 $$\n$$ \\left(\\frac{2 \\Delta t}{\\pi}\\right)^{-1.5} \\approx (0.00763944)^{-1.5} \\approx (130.900)^{1.5} \\approx 1500.27 $$\n对于包含 $x_{\\mathrm{opt}} \\approx 1.05156$ 的项：\n$$ \\frac{\\sin(1.05156)}{(1.05156)^{0.6}} \\approx \\frac{0.868153}{1.03050} \\approx 0.842459 $$\n$$ \\left(0.842459\\right)^{2.5} \\approx 0.65082 $$\n最后，将这些项相乘：\n$$ \\mathrm{HIC} \\approx (1500.27) \\times (0.43000) \\times (0.65082) \\approx 419.54 $$\n问题要求答案四舍五入到三位有效数字，即 $420$。用科学记数法表示为 $4.20 \\times 10^{2}$。\n\n作为参考，将此值与阈值 $\\mathrm{HIC}_{15} = 700$ 进行比较，该阈值常被引用为发生严重（AIS 4+级）头部损伤的低概率耐受极限。计算出的值 $420$ 低于此阈值，表明在这种特定的撞击情景下，发生严重损伤的风险为中等，但并非极端。",
            "answer": "$$\\boxed{4.20 \\times 10^2}$$"
        },
        {
            "introduction": "大脑的力学响应在很大程度上取决于其变形的速度，这一特性被称为粘弹性。本练习  使用一个简洁而强大的 Kelvin-Voigt 模型来探讨这一关键概念，该模型将脑组织表示为并联的弹簧和阻尼器。通过推导在给定的高应变率历史下的峰值应力，您将直接理解为何即使最终变形相同，更快的冲击也可能造成更大的损伤。",
            "id": "4188834",
            "problem": "一个用于导致创伤性脑损伤（TBI）的旋转性头部撞击的简化局部模型，将一小块经历小应变简单剪切的脑实质区域视为一个均质的线性粘弹性固体。考虑两个典范元件的并联组合：一个 Hookean 弹簧和一个 Newtonian 粘壶。弹簧产生的剪切应力与剪切应变成正比，粘壶产生的剪切应力与剪切应变率成正比。在并联排列中，元件承受相同的剪切应变，其剪切应力相加。\n\n仅从这些元件级定律和并联组合规则出发，推导该模型中连接剪切应力 $\\sigma(t)$ 与剪切应变 $\\epsilon(t)$ 及其时间导数 $\\dot{\\epsilon}(t)$ 的本构关系。然后分析由以下分段斜坡函数指定的高速率类冲击剪切应变历史：\n$$\n\\epsilon(t)=\n\\begin{cases}\n0,  t  0, \\\\\n\\epsilon_{\\max}\\dfrac{t}{t_{r}},  0 \\leq t \\leq t_{r}, \\\\\n\\epsilon_{\\max},  t  t_{r}\n\\end{cases}\n$$\n证明峰值应力发生在时间 $t=t_r$，并推导其表达式。最后，计算该峰值应力的数值（单位：帕斯卡），参数为：剪切模量 $E=850\\,\\mathrm{Pa}$，粘度 $\\eta=0.03\\,\\mathrm{Pa\\cdot s}$，最大应变 $\\epsilon_{\\max}=0.04$，上升时间 $t_r=0.0025\\,\\mathrm{s}$。将你的答案四舍五入到四位有效数字。",
            "solution": "问题要求推导由一个 Hookean 弹簧和一个 Newtonian 粘壶并联组合所代表的线性粘弹性固体的本构关系，然后求出在指定的剪切应变历史下的峰值应力。\n\n基本元件定律和并联组合规则：\n- Hookean 弹簧（小应变剪切）：其剪切应力与剪切应变成正比，\n$$\n\\sigma_{s}(t)=E\\,\\epsilon(t),\n$$\n其中 $E$ 是剪切模量。\n- Newtonian 粘壶（剪切）：其剪切应力与剪切应变率成正比，\n$$\n\\sigma_{d}(t)=\\eta\\,\\dot{\\epsilon}(t),\n$$\n其中 $\\eta$ 是粘度。\n- 并联排列：每个元件中的应变相同，应力相加，\n$$\n\\sigma(t)=\\sigma_{s}(t)+\\sigma_{d}(t).\n$$\n将这些结合起来得到本构关系\n$$\n\\sigma(t)=E\\,\\epsilon(t)+\\eta\\,\\dot{\\epsilon}(t).\n$$\n该关系通过 $\\eta\\,\\dot{\\epsilon}(t)$ 项显示出显式的应变率依赖性：在较高的 $\\dot{\\epsilon}$ 下，粘性贡献增加。\n\n现在分析指定的应变历史。对于分段函数，\n- 对于 $0\\leq t\\leq t_{r}$（线性上升），\n$$\n\\epsilon(t)=\\epsilon_{\\max}\\frac{t}{t_{r}}\\quad\\Rightarrow\\quad \\dot{\\epsilon}(t)=\\frac{\\epsilon_{\\max}}{t_{r}}\\ \\text{(常数)}.\n$$\n- 对于 $t > t_{r}$（保持），\n$$\n\\epsilon(t)=\\epsilon_{\\max}\\quad\\Rightarrow\\quad \\dot{\\epsilon}(t)=0.\n$$\n相应的应力历史为：\n- 对于 $0\\leq t\\leq t_{r}$，\n$$\n\\sigma(t)=E\\left(\\epsilon_{\\max}\\frac{t}{t_{r}}\\right)+\\eta\\left(\\frac{\\epsilon_{\\max}}{t_{r}}\\right)=\\frac{\\epsilon_{\\max}}{t_{r}}(E t+\\eta).\n$$\n应力随时间线性增加。\n- 对于 $t > t_{r}$，\n$$\n\\sigma(t)=E\\,\\epsilon_{\\max}+\\eta(0)=E\\,\\epsilon_{\\max}\\ \\text{(常数)}.\n$$\n\n为了找到峰值应力，我们评估在 $t=t_r$ 时两个区间的边界处的应力。\n- 当 $t \\to t_r^-$ 时（从下方逼近），\n$$\n\\sigma(t_r)= \\frac{\\epsilon_{\\max}}{t_r}(E t_r + \\eta) = \\epsilon_{\\max}(E+\\frac{\\eta}{t_r}).\n$$\n- 当 $t \\to t_r^+$ 时（从上方逼近），\n$$\n\\sigma(t_r)=E\\,\\epsilon_{\\max}.\n$$\n因为 $\\eta>0$ 且 $t_r>0$，所以 $\\eta/t_r > 0$，因此 $\\epsilon_{\\max}(E+\\eta/t_r) > E\\epsilon_{\\max}$。\n应力在 $t_r$ 处达到其峰值，然后在 $t_r$ 之后立即下降到一个较低的常数值。峰值应力由以下公式给出：\n$$\n\\sigma_{\\max}=\\sigma(t_r)=\\epsilon_{\\max}\\left(E+\\frac{\\eta}{t_r}\\right).\n$$\n\n最后，代入给定的数值：\n$E=850\\,\\mathrm{Pa}$, $\\eta=0.03\\,\\mathrm{Pa\\cdot s}$, $\\epsilon_{\\max}=0.04$, $t_r=0.0025\\,\\mathrm{s}$。\n$$\n\\sigma_{\\max} = 0.04 \\left(850 + \\frac{0.03}{0.0025}\\right) = 0.04 (850 + 12) = 0.04(862) = 34.48\\,\\mathrm{Pa}.\n$$\n该结果被四舍五入到四位有效数字。",
            "answer": "$$\\boxed{34.48}$$"
        },
        {
            "introduction": "现代生物力学在很大程度上依赖计算模型来根据复杂的头部运动预测组织层面的损伤。然而，这些预测的准确性关键取决于所使用的数值方法。这个编程实践练习  将指导您完成一次网格收敛性研究，这是验证有限元或有限差分模拟可靠性的基本过程，以确保您计算出的应变场能真实地反映其底层的力学原理。",
            "id": "4188766",
            "problem": "考虑一个二维小变形连续介质，该介质理想化为一个占据矩形域 $[0,L_x]\\times[0,L_y]$ 的脑组织样本，其中 $L_x=L_y=0.1$ 米。设位移场由 $u_x(x,y)=a\\sin\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\left(\\frac{2\\pi y}{L_y}\\right)$ 和 $u_y(x,y)=b\\sin\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\left(\\frac{2\\pi y}{L_y}\\right)$ 给出，其中 $a=0.002$ 米，$b=0.0015$ 米。在小应变假设下，无穷小应变张量定义为位移梯度的对称部分。最大主应变 (MPS) 是某点处对称 $2\\times 2$ 应变张量的最大特征值。该度量在创伤性脑损伤力学中被广泛用于评估目标区域的变形严重程度。\n\n您必须在一系列均匀网格上计算 MPS 的网格收敛性评估，这些网格由单元尺寸 $h$（单位为米）和单元阶数 $p\\in\\{1,2\\}$ 表征，分别代表一阶和二阶离散导数近似。对于每个网格，使用与阶数 $p$ 相适应的离散差分来近似位移梯度，构建应变张量，并计算网格节点处的 MPS。对于每个目标区域，将该区域上近似 MPS 的最大值与通过对域进行非常精细的采样从解析位移场获得的参考值进行比较。验收标准是：对于每个网格，每个目标区域中最大 MPS 的相对误差必须严格小于 $0.05$（即小于百分之五，无百分号）。\n\n您必须使用的基本原理：\n- 牛顿连续介质运动学：位移场 $u(x,y)$ 通过对称梯度定义无穷小应变张量。\n- 最大主应变是无穷小应变张量的最大特征值。\n- 在均匀网格上使用阶数相适应的有限差分格式对空间导数进行数值近似。\n\n待评估的目标区域：\n- 区域 A：正方形 $[0.03,0.07]\\times[0.03,0.07]$ 米。\n- 区域 B：矩形 $[0.06,0.09]\\times[0.01,0.04]$ 米。\n\n导数近似规则：\n- 对于 $p=1$，在内部和边界处，对两个空间方向均使用一阶精度的单边差分。\n- 对于 $p=2$，在内部使用二阶精度的中心差分，在边界处对两个空间方向均使用二阶精度的单边差分。\n\n参考值：\n- 区域 $A$ 和 $B$ 中的参考 MPS 最大值必须通过在覆盖整个域的精细均匀网格上评估解析位移场得到的应变张量，然后取每个区域内的最大值来获得。\n- 使用足够密集的采样来模拟连续介质值。\n\n测试套件：\n您必须评估以下六个网格，每个网格由 $(h,p)$ 指定，其中 $h$ 的单位为米，$p$ 是整数阶数：\n- $(0.05,1)$\n- $(0.025,1)$\n- $(0.025,2)$\n- $(0.0125,1)$\n- $(0.0125,2)$\n- $(0.00625,2)$\n\n输出规范：\n- 对于每个测试用例 $(h,p)$，计算区域 $A$ 和区域 $B$ 中最大 MPS 的相对误差 $|M_{\\text{approx}}-M_{\\text{ref}}|/M_{\\text{ref}}$，并判断两者是否都严格小于 $0.05$。如果两个区域都满足标准，则测试用例的结果为布尔值 $True$，否则为 $False$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[True,False,True,True,False,True]$）。\n- 应变是无量纲的，所有长度必须以米为单位处理。所有相对误差必须以小数（例如，$0.05$）而不是百分比进行计算和比较。\n\n您的解决方案必须从所述基本原理出发，并生成在整个测试套件中均符合验收标准的结果。程序必须是自包含的，且不需要外部输入。",
            "solution": "该问题是有效的，因为它在科学上基于连续介质力学和数值分析，问题陈述清晰，目标明确，并为获得唯一解提供了所有必要的数据和约束。我们将首先推导最大主应变 (MPS) 的解析表达式以建立参考解。其次，我们将详细说明数值近似方案。最后，我们将概述根据指定验收标准评估每个测试用例的流程。\n\n**1. 解析参考解**\n\n位移场由以下公式给出：\n$$ u_x(x,y) = a\\sin\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\left(\\frac{2\\pi y}{L_y}\\right) $$\n$$ u_y(x,y) = b\\sin\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\left(\\frac{2\\pi y}{L_y}\\right) $$\n其中 $a = 0.002$ 米，$b = 0.0015$ 米，$L_x = L_y = 0.1$ 米。设 $k_x = \\frac{2\\pi}{L_x}$ 且 $k_y = \\frac{2\\pi}{L_y}$。由于 $L_x=L_y$，我们有 $k_x = k_y = k = 20\\pi \\text{ m}^{-1}$。\n\n在小应变假设下，无穷小应变张量 $\\epsilon$ 是位移梯度 $\\nabla u$ 的对称部分：\n$$ \\epsilon = \\frac{1}{2} \\left[ \\nabla u + (\\nabla u)^T \\right] = \\begin{pmatrix} \\epsilon_{xx}  \\epsilon_{xy} \\\\ \\epsilon_{yx}  \\epsilon_{yy} \\end{pmatrix} $$\n应变张量的分量为：\n$$ \\epsilon_{xx} = \\frac{\\partial u_x}{\\partial x} = a k \\cos(kx)\\sin(ky) $$\n$$ \\epsilon_{yy} = \\frac{\\partial u_y}{\\partial y} = b k \\sin(kx)\\cos(ky) $$\n$$ \\epsilon_{xy} = \\epsilon_{yx} = \\frac{1}{2}\\left( \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x} \\right) = \\frac{1}{2}\\left( a k \\sin(kx)\\cos(ky) + b k \\cos(kx)\\sin(ky) \\right) $$\n\n最大主应变 (MPS) 是应变张量 $\\epsilon$ 的最大特征值。对于一个 $2 \\times 2$ 对称矩阵，其特征值 $\\lambda$ 由公式 $\\lambda = \\text{tr}(\\epsilon)/2 \\pm \\sqrt{(\\text{tr}(\\epsilon)/2)^2 - \\det(\\epsilon)}$ 给出，其中 $\\text{tr}(\\epsilon) = \\epsilon_{xx} + \\epsilon_{yy}$ 且 $\\det(\\epsilon) = \\epsilon_{xx}\\epsilon_{yy} - \\epsilon_{xy}^2$。较大的特征值为：\n$$ \\text{MPS}(x,y) = \\lambda_{\\max} = \\frac{\\epsilon_{xx} + \\epsilon_{yy}}{2} + \\sqrt{\\left(\\frac{\\epsilon_{xx} - \\epsilon_{yy}}{2}\\right)^2 + \\epsilon_{xy}^2} $$\n\n为了获得参考最大 MPS 值 $M_{\\text{ref},A}$ 和 $M_{\\text{ref},B}$，我们在覆盖域 $[0,L_x]\\times[0,L_y]$ 的一个非常精细的网格上计算解析 MPS 函数，并找出指定目标区域内的最大值：\n- 区域 A：$[0.03, 0.07] \\times [0.03, 0.07]$ 米。\n- 区域 B：$[0.06, 0.09] \\times [0.01, 0.04]$ 米。\n使用足够密集的网格（例如，$1001 \\times 1001$ 个点）以确保计算出的最大值是真实连续介质最大值的紧密近似。\n\n**2. 数值近似方案**\n\n对于每个由网格尺寸 $h$ 和阶数 $p$ 给定的测试用例，我们构建一个均匀的节点网格。每个方向上的节点数为 $N_x = \\text{round}(L_x/h) + 1$ 和 $N_y = \\text{round}(L_y/h) + 1$。在这些节点上对位移场进行采样。然后，使用指定的有限差分法近似位移场的空间导数。\n\n**一阶 ($p=1$) 近似：**\n使用一阶精度的单边差分。对于一个离散为 $f_i = f(x_i)$ 的函数 $f(x)$，除最后一个节点使用后向差分外，其余所有节点均使用前向差分计算导数。\n对于网格点 $(i,j)$ 处关于 $x$ 的导数：\n- 前向差分（对于 $j=0, \\dots, N_x-2$）：$\\frac{\\partial u}{\\partial x}\\bigg|_{i,j} \\approx \\frac{u_{i,j+1} - u_{i,j}}{h}$\n- 后向差分（对于 $j=N_x-1$）：$\\frac{\\partial u}{\\partial x}\\bigg|_{i,N_x-1} \\approx \\frac{u_{i,N_x-1} - u_{i,N_x-2}}{h}$\n对关于 $y$ 的导数应用类似的方案。\n\n**二阶 ($p=2$) 近似：**\n使用二阶精度的方案。\n- 内部节点 $(j=1, \\dots, N_x-2)$：中心差分格式。\n  $$ \\frac{\\partial u}{\\partial x}\\bigg|_{i,j} \\approx \\frac{u_{i,j+1} - u_{i,j-1}}{2h} $$\n- 起始边界节点 $(j=0)$：二阶前向差分格式。\n  $$ \\frac{\\partial u}{\\partial x}\\bigg|_{i,0} \\approx \\frac{-3u_{i,0} + 4u_{i,1} - u_{i,2}}{2h} $$\n- 末端边界节点 $(j=N_x-1)$：二阶后向差分格式。\n  $$ \\frac{\\partial u}{\\partial x}\\bigg|_{i,N_x-1} \\approx \\frac{3u_{i,N_x-1} - 4u_{i,N_x-2} + u_{i,N_x-3}}{2h} $$\n对关于 $y$ 的导数应用类似的方案。\n\n**3. 评估流程**\n\n对于测试套件中的每个测试用例 $(h,p)$：\n1.  生成间距为 $h$ 的均匀网格。\n2.  识别位于区域 A 和区域 B 内部的网格节点集。\n3.  如果任一区域不包含网格节点，则认为该网格过于粗糙，无法解析该区域。在这种情况下，评估标准无法满足，该测试用例的结果将立即确定为 `False`。\n4.  如果两个区域都至少包含一个节点，则使用与阶数 $p$ 对应的有限差分方案计算所有网格节点上的四个位移梯度分量（$\\frac{\\partial u_x}{\\partial x}, \\frac{\\partial u_x}{\\partial y}, \\frac{\\partial u_y}{\\partial x}, \\frac{\\partial u_y}{\\partial y}$）。\n5.  根据每个节点上的近似梯度计算数值应变张量分量（$\\epsilon_{xx}, \\epsilon_{yy}, \\epsilon_{xy}$）。\n6.  使用特征值公式计算每个节点处的 MPS。这将产生一个近似 MPS 值的离散场。\n7.  通过取每个区域内节点的最大值，找到该区域的最大近似 MPS，$M_{\\text{approx},A}$ 和 $M_{\\text{approx},B}$。\n8.  计算两个区域的相对误差：\n    $$ E_A = \\frac{|M_{\\text{approx},A} - M_{\\text{ref},A}|}{M_{\\text{ref},A}} $$\n    $$ E_B = \\frac{|M_{\\text{approx},B} - M_{\\text{ref},B}|}{M_{\\text{ref},B}} $$\n9.  当且仅当两个相对误差都严格小于 $0.05$ 的验收标准时，测试用例才算成功（`True`）。即，$E_A  0.05$ 且 $E_B  0.05$。否则，结果为 `False`。\n对所有六个指定的测试用例重复此过程，并收集布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mesh-convergence assessment problem for Maximum Principal Strain (MPS).\n    \"\"\"\n    # Problem Constants\n    Lx = 0.1\n    Ly = 0.1\n    a = 0.002\n    b = 0.0015\n    kx = 2.0 * np.pi / Lx\n    ky = 2.0 * np.pi / Ly\n    \n    # Target Regions\n    region_A_bounds = {'x_min': 0.03, 'x_max': 0.07, 'y_min': 0.03, 'y_max': 0.07}\n    region_B_bounds = {'x_min': 0.06, 'x_max': 0.09, 'y_min': 0.01, 'y_max': 0.04}\n\n    # Acceptance Criterion\n    REL_ERROR_THRESHOLD = 0.05\n\n    # Test Suite\n    test_cases = [\n        (0.05, 1),\n        (0.025, 1),\n        (0.025, 2),\n        (0.0125, 1),\n        (0.0125, 2),\n        (0.00625, 2)\n    ]\n\n    def get_analytical_mps_field(xx, yy):\n        \"\"\"Calculates the analytical MPS field on a given meshgrid.\"\"\"\n        Cx = np.cos(kx * xx)\n        Sx = np.sin(kx * xx)\n        Cy = np.cos(ky * yy)\n        Sy = np.sin(ky * yy)\n\n        eps_xx = a * kx * Cx * Sy\n        eps_yy = b * ky * Sx * Cy\n        eps_xy = 0.5 * (a * ky * Sx * Cy + b * kx * Cx * Sy)\n        \n        term1 = 0.5 * (eps_xx + eps_yy)\n        term2 = np.sqrt(0.25 * (eps_xx - eps_yy)**2 + eps_xy**2)\n        \n        return term1 + term2\n\n    def calculate_reference_mps():\n        \"\"\"Calculates reference maximum MPS for regions A and B using a fine grid.\"\"\"\n        N_fine = 1001\n        x_fine = np.linspace(0.0, Lx, N_fine)\n        y_fine = np.linspace(0.0, Ly, N_fine)\n        xx_fine, yy_fine = np.meshgrid(x_fine, y_fine)\n\n        mps_analytical_field = get_analytical_mps_field(xx_fine, yy_fine)\n\n        mask_A = (xx_fine = region_A_bounds['x_min'])  (xx_fine = region_A_bounds['x_max'])  \\\n                 (yy_fine = region_A_bounds['y_min'])  (yy_fine = region_A_bounds['y_max'])\n        \n        mask_B = (xx_fine = region_B_bounds['x_min'])  (xx_fine = region_B_bounds['x_max'])  \\\n                 (yy_fine = region_B_bounds['y_min'])  (yy_fine = region_B_bounds['y_max'])\n\n        ref_mps_A = np.max(mps_analytical_field[mask_A])\n        ref_mps_B = np.max(mps_analytical_field[mask_B])\n        \n        return ref_mps_A, ref_mps_B\n\n    def calculate_derivatives(U, h, p):\n        \"\"\"Calculates derivatives of a 2D field U using specified order p.\"\"\"\n        Nx, Ny = U.shape[1], U.shape[0]\n        dU_dx = np.zeros_like(U)\n        dU_dy = np.zeros_like(U)\n\n        if p == 1:\n            # d/dx\n            dU_dx[:, :-1] = (U[:, 1:] - U[:, :-1]) / h\n            dU_dx[:, -1] = (U[:, -1] - U[:, -2]) / h\n            # d/dy\n            dU_dy[:-1, :] = (U[1:, :] - U[:-1, :]) / h\n            dU_dy[-1, :] = (U[-1, :] - U[-2, :]) / h\n        elif p == 2:\n            # d/dx\n            dU_dx[:, 1:-1] = (U[:, 2:] - U[:, :-2]) / (2 * h)\n            dU_dx[:, 0] = (-3 * U[:, 0] + 4 * U[:, 1] - U[:, 2]) / (2 * h)\n            dU_dx[:, -1] = (3 * U[:, -1] - 4 * U[:, -2] + U[:, -3]) / (2 * h)\n            # d/dy\n            dU_dy[1:-1, :] = (U[2:, :] - U[:-2, :]) / (2 * h)\n            dU_dy[0, :] = (-3 * U[0, :] + 4 * U[1, :] - U[2, :]) / (2 * h)\n            dU_dy[-1, :] = (3 * U[-1, :] - 4 * U[-2, :] + U[-3, :]) / (2 * h)\n        \n        return dU_dx, dU_dy\n\n    # Pre-calculate reference values\n    ref_mps_A, ref_mps_B = calculate_reference_mps()\n    \n    results = []\n    \n    for h, p in test_cases:\n        # 1. Create numerical grid and evaluate displacements\n        Nx = int(round(Lx / h)) + 1\n        Ny = int(round(Ly / h)) + 1\n        x_grid = np.linspace(0.0, Lx, Nx)\n        y_grid = np.linspace(0.0, Ly, Ny)\n        xx_n, yy_n = np.meshgrid(x_grid, y_grid)\n\n        Ux = a * np.sin(kx * xx_n) * np.sin(ky * yy_n)\n        Uy = b * np.sin(kx * xx_n) * np.sin(ky * yy_n)\n\n        # 2. Check if regions contain nodes\n        mask_A_num = (xx_n = region_A_bounds['x_min'])  (xx_n = region_A_bounds['x_max'])  \\\n                     (yy_n = region_A_bounds['y_min'])  (yy_n = region_A_bounds['y_max'])\n        mask_B_num = (xx_n = region_B_bounds['x_min'])  (xx_n = region_B_bounds['x_max'])  \\\n                     (yy_n = region_B_bounds['y_min'])  (yy_n = region_B_bounds['y_max'])\n\n        if not np.any(mask_A_num) or not np.any(mask_B_num):\n            results.append(False)\n            continue\n            \n        # 3. Approximate derivatives\n        dUx_dx, dUx_dy = calculate_derivatives(Ux, h, p)\n        dUy_dx, dUy_dy = calculate_derivatives(Uy, h, p)\n\n        # 4. Construct numerical strain and MPS fields\n        eps_xx_num = dUx_dx\n        eps_yy_num = dUy_dy\n        eps_xy_num = 0.5 * (dUx_dy + dUy_dx)\n        \n        term1_num = 0.5 * (eps_xx_num + eps_yy_num)\n        term2_num = np.sqrt(0.25 * (eps_xx_num - eps_yy_num)**2 + eps_xy_num**2)\n        mps_numerical = term1_num + term2_num\n        \n        # 5. Find max MPS in regions\n        approx_mps_A = np.max(mps_numerical[mask_A_num])\n        approx_mps_B = np.max(mps_numerical[mask_B_num])\n\n        # 6. Calculate relative errors and evaluate criterion\n        error_A = np.abs(approx_mps_A - ref_mps_A) / ref_mps_A\n        error_B = np.abs(approx_mps_B - ref_mps_B) / ref_mps_B\n        \n        if error_A  REL_ERROR_THRESHOLD and error_B  REL_ERROR_THRESHOLD:\n            results.append(True)\n        else:\n            results.append(False)\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}