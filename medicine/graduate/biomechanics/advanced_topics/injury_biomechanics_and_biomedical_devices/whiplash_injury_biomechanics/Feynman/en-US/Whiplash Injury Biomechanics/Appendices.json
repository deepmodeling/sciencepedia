{
    "hands_on_practices": [
        {
            "introduction": "Understanding whiplash requires first analyzing how forces are distributed within the fundamental building blocks of the spine. This exercise models a single Functional Spinal Unit (FSU) with a simplified two-spring system to explore load sharing through the principles of static equilibrium. By solving this problem, you will quantify how an extension moment—a key component of whiplash loading—can dramatically shift compressive loads from the robust intervertebral disc to the more delicate facet joints, illuminating a primary mechanism of injury .",
            "id": "4212455",
            "problem": "A cervical Functional Spinal Unit (FSU) subjected to whiplash-like extension can be idealized, for small deformations, as a rigid superior vertebra connected to the inferior vertebra by two linear elastic elements acting in parallel: a central intervertebral disc spring and a posterior facet contact spring. The intervertebral disc is modeled as a linear axial spring of stiffness $k_{d}$ located at the centroid of the disc ($x=0$). The facet contact is modeled as a linear spring of normal stiffness $k_{f}$ located at a posterior offset $x=d$ along the sagittal plane. The FSU experiences an externally applied compressive preload $F_{c}$ along the disc centroid line and a pure extension moment $M$ about that line. Assume quasi-static equilibrium, small rotations, and that both springs can carry compression or tension.\n\nStarting only from Newton’s laws for force and moment equilibrium, and linear elasticity (Hooke’s law), derive the internal disc force $F_{d}$ and facet force $F_{f}$ consistent with rigid-body kinematics (uniform vertical translation and small rotation of the superior vertebra). Then, using those internal forces, compute the facet load share defined as the dimensionless quantity $s = F_{f}/F_{c}$ for the given parameters $M = 8\\,\\mathrm{N\\cdot m}$, $F_{c} = 150\\,\\mathrm{N}$, $d = 10\\,\\mathrm{mm}$, $k_{d} = 5000\\,\\mathrm{N/mm}$, and $k_{f} = 12000\\,\\mathrm{N/mm}$.\n\nExpress the final answer as a pure number (no units) and round your answer to three significant figures.",
            "solution": "The modeling assumptions imply the superior vertebra behaves as a rigid body undergoing a small vertical translation and a small rotation relative to the inferior vertebra. Let the vertical translation be denoted by $\\Delta$ and the small rotation (about the disc centroid line) by $\\theta$. With the disc spring located at $x=0$ and the facet spring at $x=d$ posteriorly, the vertical compressions (positive in compression) of the disc and facet springs, respectively, are given by the rigid-body kinematics:\n$$\n\\delta_{d} = \\Delta, \\qquad \\delta_{f} = \\Delta + \\theta d.\n$$\nBy linear elasticity (Hooke’s law), the internal forces in the springs are\n$$\nF_{d} = k_{d}\\,\\delta_{d} = k_{d}\\,\\Delta, \\qquad F_{f} = k_{f}\\,\\delta_{f} = k_{f}\\,(\\Delta + \\theta d).\n$$\n\nForce and moment equilibrium are enforced relative to the disc centroid line. The net external compressive preload is $F_{c}$, so the sum of internal vertical forces must satisfy:\n$$\nF_{d} + F_{f} = F_{c}.\n$$\nThe externally applied pure extension moment about the disc centroid is $M$. The disc force acts at $x=0$ and therefore does not contribute to a moment about the disc centroid line, while the facet force acts at $x=d$. Thus, the moment equilibrium is:\n$$\nF_{f}\\,d = M.\n$$\n\nFrom the moment equilibrium,\n$$\nF_{f} = \\frac{M}{d}.\n$$\nSubstituting into the force equilibrium gives the disc force:\n$$\nF_{d} = F_{c} - F_{f} = F_{c} - \\frac{M}{d}.\n$$\n\nThese expressions for $F_{d}$ and $F_{f}$ are independent of stiffness; the stiffnesses $k_{d}$ and $k_{f}$ determine the kinematics $\\Delta$ and $\\theta$ necessary to realize these forces. Specifically, using Hooke’s law and the kinematic relations,\n$$\n\\Delta = \\frac{F_{d}}{k_{d}} = \\frac{F_{c} - \\frac{M}{d}}{k_{d}}, \\qquad \\theta = \\frac{1}{d}\\left(\\frac{F_{f}}{k_{f}} - \\Delta\\right) = \\frac{1}{d}\\left(\\frac{\\frac{M}{d}}{k_{f}} - \\frac{F_{c} - \\frac{M}{d}}{k_{d}}\\right).\n$$\nHowever, the requested quantity is the facet load share defined as $s = F_{f}/F_{c}$. Using the equilibrium-derived force,\n$$\ns = \\frac{F_{f}}{F_{c}} = \\frac{\\frac{M}{d}}{F_{c}} = \\frac{M}{d\\,F_{c}}.\n$$\n\nWe now substitute the given numerical values, converting $d$ to meters consistently or noting that $M/d$ is a force when $M$ is in $\\mathrm{N\\cdot m}$ and $d$ in meters. With $M = 8\\,\\mathrm{N\\cdot m}$, $d = 10\\,\\mathrm{mm} = 0.01\\,\\mathrm{m}$, and $F_{c} = 150\\,\\mathrm{N}$:\n$$\ns = \\frac{8\\,\\mathrm{N\\cdot m}}{0.01\\,\\mathrm{m}\\times 150\\,\\mathrm{N}} = \\frac{8}{1.5} = \\frac{16}{3} \\approx 5.333\\ldots\n$$\nRounded to three significant figures, the facet load share is\n$$\ns \\approx 5.33.\n$$\n\nInterpretation: Because the external moment $M$ demands an internal couple that is supplied entirely by the offset facet force, the facet force $F_{f}$ can exceed the applied compressive preload $F_{c}$, leading to a facet load share $s>1$ and a tensile (negative compressive) disc force $F_{d} = F_{c} - M/d < 0$. This reflects realistic extension scenarios in whiplash where posterior structures bear high compressive loads while the disc experiences distraction.",
            "answer": "$$\\boxed{5.33}$$"
        },
        {
            "introduction": "To bridge the gap between observable crash kinematics and the risk of biological injury, biomechanists develop injury criteria. This practice delves into the fluid-dynamic origins of the Neck Injury Criterion (NIC), an established metric used in automotive safety to assess whiplash risk. You will derive the NIC formula from the first principles of unsteady momentum balance, modeling the pressure dynamics within the cerebrospinal fluid during an impact, and then apply it to a hypothetical test scenario . This exercise demystifies a key industry standard by revealing its foundation in fundamental physics.",
            "id": "4212466",
            "problem": "A rear-impact sled test is performed on a seated human surrogate. The relative kinematics between the head center of gravity and the first thoracic vertebra (T1) are measured along the anterior-posterior axis. The measured time histories show a relative acceleration $a_{\\mathrm{rel}}(t)$ and a relative velocity $v_{\\mathrm{rel}}(t)$ whose peak magnitudes are $5\\,\\mathrm{m/s^{2}}$ and $0.8\\,\\mathrm{m/s}$, respectively. Assume these peak values occur simultaneously. In the context of whiplash injury biomechanics, the Neck Injury Criterion (NIC) is motivated by the one-dimensional unsteady momentum balance for the cerebrospinal fluid column in the cervical spinal canal of characteristic length $L$, which is commonly taken as $L = 0.2\\,\\mathrm{m}$ for adult occupants. Using Newton’s second law and an appropriate one-dimensional unsteady momentum balance as the fundamental base, construct a scalar measure proportional to the canal pressure rise per unit density using the measured relative kinematics, and thereby obtain an explicit analytic expression for the Neck Injury Criterion (NIC) in terms of $a_{\\mathrm{rel}}$ and $v_{\\mathrm{rel}}$ and the canonical length $L$. Then, for the given test, evaluate this expression at the stated peaks to obtain a single numerical value for NIC. Finally, compare the computed value to a commonly cited whiplash risk threshold of $15\\,\\mathrm{m^{2}/s^{2}}$ by reporting the dimensionless ratio $R = \\mathrm{NIC}/15$. Round your final answer for $R$ to four significant figures. Report the final answer as the single number $R$ with no units.",
            "solution": "The fundamental principle governing the pressure change in the cerebrospinal fluid (CSF) is the one-dimensional unsteady momentum equation for an incompressible fluid, also known as Euler's equation in one dimension. Neglecting body forces such as gravity, which contribute a static pressure head but do not affect the dynamic pressure changes during impact, the equation is:\n$$\n\\frac{\\partial p}{\\partial x} = -\\rho \\left( \\frac{\\partial v}{\\partial t} + v \\frac{\\partial v}{\\partial x} \\right)\n$$\nwhere $p$ is the pressure, $\\rho$ is the fluid density, $v$ is the fluid velocity along the spinal canal axis $x$, and $t$ is time. The term $\\frac{\\partial v}{\\partial t}$ is the local acceleration, and $v \\frac{\\partial v}{\\partial x}$ is the convective acceleration.\n\nTo model the fluid kinematics based on the given relative motion between the head (at one end of the canal, $x=L$) and the T1 vertebra (at the other end, $x=0$), we can establish a reference frame fixed to T1. In this frame, the velocity at the T1 end is $v(0, t) = 0$ and the velocity at the head end is $v(L, t) = v_{\\mathrm{rel}}(t)$. A simple and standard assumption for the fluid velocity profile along the canal is a linear distribution:\n$$\nv(x, t) = v_{\\mathrm{rel}}(t) \\frac{x}{L}\n$$\nFrom this assumed velocity profile, we can calculate the local and convective acceleration terms. The local acceleration is:\n$$\n\\frac{\\partial v}{\\partial t} = \\frac{\\partial}{\\partial t} \\left( v_{\\mathrm{rel}}(t) \\frac{x}{L} \\right) = \\frac{x}{L} \\frac{d v_{\\mathrm{rel}}(t)}{dt} = \\frac{x}{L} a_{\\mathrm{rel}}(t)\n$$\nThe convective acceleration is:\n$$\nv \\frac{\\partial v}{\\partial x} = \\left( v_{\\mathrm{rel}}(t) \\frac{x}{L} \\right) \\frac{\\partial}{\\partial x} \\left( v_{\\mathrm{rel}}(t) \\frac{x}{L} \\right) = \\left( v_{\\mathrm{rel}}(t) \\frac{x}{L} \\right) \\left( \\frac{v_{\\mathrm{rel}}(t)}{L} \\right) = \\frac{x}{L^2} v_{\\mathrm{rel}}(t)^2\n$$\nSubstituting these expressions back into Euler's equation gives the pressure gradient:\n$$\n\\frac{\\partial p}{\\partial x} = -\\rho \\left( \\frac{x}{L} a_{\\mathrm{rel}}(t) + \\frac{x}{L^2} v_{\\mathrm{rel}}(t)^2 \\right) = -\\rho x \\left( \\frac{a_{\\mathrm{rel}}(t)}{L} + \\frac{v_{\\mathrm{rel}}(t)^2}{L^2} \\right)\n$$\nTo find the pressure difference, $\\Delta p = p(L) - p(0)$, we integrate the pressure gradient from $x=0$ to $x=L$:\n$$\n\\Delta p = \\int_0^L \\frac{\\partial p}{\\partial x} dx = \\int_0^L -\\rho x \\left( \\frac{a_{\\mathrm{rel}}(t)}{L} + \\frac{v_{\\mathrm{rel}}(t)^2}{L^2} \\right) dx\n$$\nSince the terms in the parenthesis are functions of time $t$ only, they are constant with respect to the spatial integration variable $x$:\n$$\n\\Delta p = -\\rho \\left( \\frac{a_{\\mathrm{rel}}(t)}{L} + \\frac{v_{\\mathrm{rel}}(t)^2}{L^2} \\right) \\int_0^L x \\, dx = -\\rho \\left( \\frac{a_{\\mathrm{rel}}(t)}{L} + \\frac{v_{\\mathrm{rel}}(t)^2}{L^2} \\right) \\left[ \\frac{x^2}{2} \\right]_0^L\n$$\n$$\n\\Delta p = -\\rho \\left( \\frac{a_{\\mathrm{rel}}(t)}{L} + \\frac{v_{\\mathrm{rel}}(t)^2}{L^2} \\right) \\frac{L^2}{2} = -\\frac{\\rho}{2} \\left( a_{\\mathrm{rel}}(t)L + v_{\\mathrm{rel}}(t)^2 \\right)\n$$\nThe problem requests a scalar measure proportional to the canal pressure rise per unit density. The pressure rise per unit density is $\\frac{\\Delta p}{\\rho}$:\n$$\n\\frac{\\Delta p}{\\rho} = -\\frac{1}{2} \\left( a_{\\mathrm{rel}}(t)L + v_{\\mathrm{rel}}(t)^2 \\right)\n$$\nThe Neck Injury Criterion (NIC) is defined as a scalar measure proportional to the magnitude of this quantity. By convention, the factor of $\\frac{1}{2}$ is dropped, and the terms are considered as positive contributions to injury risk. Thus, we obtain the explicit analytic expression for NIC:\n$$\n\\mathrm{NIC} = a_{\\mathrm{rel}}L + v_{\\mathrm{rel}}^2\n$$\nThe units of this expression are $(\\mathrm{m/s^2}) \\cdot \\mathrm{m} + (\\mathrm{m/s})^2$, which simplifies to $\\mathrm{m^2/s^2}$, consistent with the given threshold value.\n\nNow, we evaluate this expression at the given peak values, which are assumed to occur simultaneously.\n-   $a_{\\mathrm{rel}} = 5\\,\\mathrm{m/s^2}$\n-   $v_{\\mathrm{rel}} = 0.8\\,\\mathrm{m/s}$\n-   $L = 0.2\\,\\mathrm{m}$\n\n$$\n\\mathrm{NIC} = (5) \\cdot (0.2) + (0.8)^2\n$$\n$$\n\\mathrm{NIC} = 1.0 + 0.64 = 1.64\\,\\mathrm{m^2/s^2}\n$$\nFinally, we compute the dimensionless ratio $R$ by comparing the computed NIC value to the whiplash risk threshold of $15\\,\\mathrm{m^{2}/s^{2}}$:\n$$\nR = \\frac{\\mathrm{NIC}}{15} = \\frac{1.64}{15}\n$$\n$$\nR \\approx 0.109333...\n$$\nRounding to four significant figures, as required:\n$$\nR = 0.1093\n$$\nThis is the final dimensionless ratio.",
            "answer": "$$\\boxed{0.1093}$$"
        },
        {
            "introduction": "While single-joint analysis is foundational, the whiplash event involves the complex, coordinated motion of the entire cervical spine. This computational problem introduces the concept of the injurious \"S-shape\" curvature, a non-physiological kinematic pattern where the lower cervical spine extends while the upper spine flexes. You will implement a biomechanical model to process synthetic kinematic data, quantify the S-shape phenomenon using a curvature gradient metric, and correlate its timing with key features of the impact pulse . This practice offers valuable hands-on experience with the signal processing and data analysis techniques that are central to modern biomechanics research.",
            "id": "4212449",
            "problem": "A cervical spine chain during a rear-impact event can be modeled as five motion segments from the second to third cervical vertebra through the sixth to seventh cervical vertebra, denoted by $C2$-$C3$ through $C6$-$C7$. Let the intervertebral angles be given as time histories $\\theta_{C2-3}(t)$, $\\theta_{C3-4}(t)$, $\\theta_{C4-5}(t)$, $\\theta_{C5-6}(t)$, and $\\theta_{C6-7}(t)$, measured in radians, and let the base (seat) acceleration input be $a_{\\text{base}}(t)$ in meters per second squared. Assume effective segment lengths $L_i$ in meters for $i \\in \\{1,2,3,4,5\\}$ corresponding to the five motion segments from cranial to caudal.\n\nStarting from Newton's laws of motion (sum of forces equals mass times acceleration) and the definition of curvature in planar kinematics, model the instantaneous curvature of each motion segment by the approximation $\\kappa_i(t) \\approx \\theta_i(t) / L_i$, and define the spatial curvature gradient along the spine at time $t$ by a finite-difference approximation of the spatial derivative:\n$$\n\\frac{d\\kappa}{ds}\\Big|_{i+\\frac{1}{2}}(t) \\approx \\frac{\\kappa_{i+1}(t) - \\kappa_i(t)}{\\Delta s_{i+\\frac{1}{2}}},\n$$\nwhere $\\Delta s_{i+\\frac{1}{2}} = \\frac{L_i + L_{i+1}}{2}$ is the mean arc length between adjacent segments. Define the instantaneous spine-wide curvature-gradient magnitude as\n$$\nG(t) = \\max_{i \\in \\{1,2,3,4\\}} \\left| \\frac{\\kappa_{i+1}(t) - \\kappa_i(t)}{\\Delta s_{i+\\frac{1}{2}}} \\right|.\n$$\nDefine an $S$-shape condition at time $t$ to occur if there exists at least one adjacent pair $(i,i+1)$ such that $\\kappa_i(t)\\,\\kappa_{i+1}(t) < 0$ (a sign change in curvature along the chain). Let $t_S$ be the time that maximizes $G(t)$ subject to the $S$-shape condition; if the $S$-shape condition never occurs, set $t_S = -1$.\n\nTo correlate $t_S$ with base pulse features, define the peak-acceleration time $t_{\\text{peak,a}}$ as the time at which $\\left|a_{\\text{base}}(t)\\right|$ attains its maximum, and define jerk as $j(t) = \\frac{da_{\\text{base}}}{dt}(t)$ with peak-jerk time $t_{\\text{peak,j}}$ the time at which $\\left|j(t)\\right|$ attains its maximum. For each test case, compute the list $[t_S,\\; t_{\\text{peak,a}},\\; t_{\\text{peak,j}},\\; t_S - t_{\\text{peak,a}},\\; t_S - t_{\\text{peak,j}},\\; s\\_shape\\_present]$, where s_shape_present is a boolean indicating whether $t_S \\ge 0$. Express all time quantities in seconds, rounded to six decimals. The booleans must be literal true or false values. If no $S$-shape occurs, both $t_S$ and the differences $t_S - t_{\\text{peak,a}}$ and $t_S - t_{\\text{peak,j}}$ must be set to $-1.0$.\n\nConstruct the following scientifically plausible test suite using deterministic synthetic signals. For each case, use a uniform sampling interval $\\Delta t = 0.001$ seconds and total duration $T_{\\text{total}} = 0.200$ seconds (i.e., times $t \\in [0,\\, T_{\\text{total}}]$). Let the base acceleration be a half-sine pulse:\n$$\na_{\\text{base}}(t) = \\begin{cases}\nA \\sin\\left( \\frac{\\pi t}{T} \\right), & 0 \\le t \\le T,\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwith amplitude $A$ and pulse duration $T$ specified per case. Let effective segment lengths be\n$$\nL = [\\,0.018,\\; 0.018,\\; 0.019,\\; 0.020,\\; 0.021\\,] \\text{ meters}.\n$$\nGenerate each intervertebral angle $\\theta_i(t)$ via linear viscoelastic-like shaping of $a_{\\text{base}}(t)$ using convolution with a segment-specific causal kernel\n$$\nh_i(t) = \\left(\\frac{t}{\\tau_i}\\right)\\exp\\left(-\\frac{t}{\\tau_i}\\right) u(t),\n$$\nwhere $u(t)$ is the unit step function and $\\tau_i$ are segment-specific time constants. The angle response is\n$$\n\\theta_i(t) = g_i \\, \\big( a_{\\text{base}} \\ast h_i \\big)(t),\n$$\napproximated numerically with the convolution integral using the sampling interval $\\Delta t$. In Test Case $3$, add a small dynamic component proportional to the time derivative of the base acceleration to simulate rapid upper-segment response:\n$$\n\\theta_i^{(3)}(t) = g_i \\, \\big( a_{\\text{base}} \\ast h_i \\big)(t) + b_i \\, \\frac{da_{\\text{base}}}{dt}(t),\n$$\nwith coefficients $b_i$ specified below.\n\nProvide and use the following three test cases:\n\n- Test Case $1$ (clear $S$-shape):\n    - $A = 8.0$ $\\text{m/s}^2$, $T = 0.100$ $\\text{s}$.\n    - $\\tau = [\\,0.015,\\; 0.020,\\; 0.025,\\; 0.030,\\; 0.035\\,]$ $\\text{s}$.\n    - $g = [\\,0.040,\\; 0.030,\\; -0.020,\\; -0.030,\\; -0.035\\,]$ (radians per unit of the convolved signal).\n\n- Test Case $2$ (no $S$-shape):\n    - $A = 6.0$ $\\text{m/s}^2$, $T = 0.100$ $\\text{s}$.\n    - $\\tau = [\\,0.020,\\; 0.025,\\; 0.030,\\; 0.035,\\; 0.040\\,]$ $\\text{s}$.\n    - $g = [\\,0.030,\\; 0.028,\\; 0.026,\\; 0.024,\\; 0.022\\,]$.\n\n- Test Case $3$ (late $S$-shape with dynamic upper response):\n    - $A = 10.0$ $\\text{m/s}^2$, $T = 0.080$ $\\text{s}$.\n    - $\\tau = [\\,0.012,\\; 0.016,\\; 0.020,\\; 0.024,\\; 0.028\\,]$ $\\text{s}$.\n    - $g = [\\,0.050,\\; 0.040,\\; -0.010,\\; -0.020,\\; -0.025\\,]$.\n    - $b = [\\,0.0020,\\; 0.0015,\\; -0.0005,\\; -0.0010,\\; -0.0012\\,]$ (seconds; note $b_i$ scales $\\frac{da_{\\text{base}}}{dt}$ so units yield radians).\n\nAlgorithmic requirements:\n- Use the discrete time derivative for jerk via a consistent finite-difference approximation with respect to $t$.\n- Use the discrete convolution with $\\Delta t$ scaling to approximate the continuous convolution.\n- Detect the $S$-shape condition by testing $\\kappa_i(t)\\,\\kappa_{i+1}(t) < 0$ for any adjacent pair at each time point.\n- Determine $t_S$ as the time of the maximum $G(t)$ over only those time points where the $S$-shape condition is satisfied; if no such points exist, set $t_S = -1.0$.\n- Determine $t_{\\text{peak,a}}$ and $t_{\\text{peak,j}}$ from the maxima of the absolute values of $a_{\\text{base}}(t)$ and $j(t)$, respectively.\n\nExact final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of the form $[t_S,\\; t_{\\text{peak,a}},\\; t_{\\text{peak,j}},\\; t_S - t_{\\text{peak,a}},\\; t_S - t_{\\text{peak,j}},\\; s\\_shape\\_present]$. For example, the printed structure must be like $[[\\dots],[\\dots],[\\dots]]$ with all time values in seconds rounded to six decimals, and boolean values printed as their literal forms.",
            "solution": "The solution requires implementing a time-domain simulation based on the provided biomechanical model. The process for each test case is as follows:\n\n1.  **Time and Signal Generation**: A discrete time vector $t$ is created from $0$ to $T_{\\text{total}}$ with a step of $\\Delta t$. Using this, the base acceleration signal $a_{\\text{base}}(t)$ is generated as a half-sine pulse. The jerk signal, $j(t) = da_{\\text{base}}/dt$, is computed numerically using a second-order central finite difference.\n\n2.  **Input Pulse Feature Extraction**: The peak acceleration time, $t_{\\text{peak,a}}$, is found by locating the time index of the maximum absolute value of $a_{\\text{base}}(t)$. Similarly, the peak jerk time, $t_{\\text{peak,j}}$, is found from the maximum absolute value of $j(t)$.\n\n3.  **Spine Segment Response Calculation**: The angular response $\\theta_i(t)$ of each of the five spinal segments is computed. This involves generating the segment-specific viscoelastic-like response kernel $h_i(t)$ and performing a discrete convolution with the acceleration signal $a_{\\text{base}}(t)$, scaled by the gain factor $g_i$. For Test Case 3, an additional term proportional to the jerk, $b_i j(t)$, is added.\n\n4.  **Kinematic Analysis**: With the time histories of all five intervertebral angles computed, the kinematic analysis proceeds. The instantaneous curvature of each segment, $\\kappa_i(t)$, is calculated by dividing its angle by its effective length. The S-shape condition is then evaluated at each time step by checking if any adjacent pair of segments has curvatures of opposite sign, i.e., $\\kappa_i(t)\\,\\kappa_{i+1}(t) < 0$. Finally, the spine-wide curvature-gradient magnitude, $G(t)$, is determined at each time point by taking the maximum absolute value of the finite-difference gradients between adjacent segments.\n\n5.  **Peak S-Shape Time ($t_S$) Determination**: If the S-shape condition never occurs, `s_shape_present` is `False`, and $t_S$ is set to $-1.0$. Otherwise, `s_shape_present` is `True`, and $t_S$ is identified as the time that corresponds to the global maximum of the gradient magnitude $G(t)$, considering only the time points where the S-shape condition was met.\n\n6.  **Output Compilation**: For each test case, the computed values ($t_S$, $t_{\\text{peak,a}}$, $t_{\\text{peak,j}}$), the derived time differences, and the S-shape presence flag are collected. If $t_S = -1.0$, the differences are also set to $-1.0$. The final numerical results are rounded to six decimal places and formatted as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the whiplash biomechanics problem for three test cases.\n    \"\"\"\n    \n    # Global parameters\n    DELTA_T = 0.001  # s\n    T_TOTAL = 0.200  # s\n    L = np.array([0.018, 0.018, 0.019, 0.020, 0.021])  # m\n    \n    # Test case definitions\n    test_cases = [\n        {\n            \"A\": 8.0, \"T\": 0.100,\n            \"tau\": np.array([0.015, 0.020, 0.025, 0.030, 0.035]),\n            \"g\": np.array([0.040, 0.030, -0.020, -0.030, -0.035]),\n            \"b\": np.zeros(5)\n        },\n        {\n            \"A\": 6.0, \"T\": 0.100,\n            \"tau\": np.array([0.020, 0.025, 0.030, 0.035, 0.040]),\n            \"g\": np.array([0.030, 0.028, 0.026, 0.024, 0.022]),\n            \"b\": np.zeros(5)\n        },\n        {\n            \"A\": 10.0, \"T\": 0.080,\n            \"tau\": np.array([0.012, 0.016, 0.020, 0.024, 0.028]),\n            \"g\": np.array([0.050, 0.040, -0.010, -0.020, -0.025]),\n            \"b\": np.array([0.0020, 0.0015, -0.0005, -0.0010, -0.0012])\n        }\n    ]\n\n    all_results = []\n\n    # Time vector\n    t = np.arange(0, T_TOTAL + DELTA_T, DELTA_T)\n    num_timesteps = len(t)\n\n    for case in test_cases:\n        # --- 1. Signal Generation ---\n        A, T = case[\"A\"], case[\"T\"]\n        \n        a_base = A * np.sin(np.pi * t / T)\n        a_base[t > T] = 0.0\n        \n        jerk = np.gradient(a_base, DELTA_T)\n\n        # --- 2. Input Pulse Feature Extraction ---\n        t_peak_a = t[np.argmax(np.abs(a_base))]\n        t_peak_j = t[np.argmax(np.abs(jerk))]\n\n        # --- 3. Spine Segment Response Calculation ---\n        tau_vec, g_vec, b_vec = case[\"tau\"], case[\"g\"], case[\"b\"]\n        thetas = np.zeros((num_timesteps, 5))\n\n        for i in range(5):\n            # Causal kernel h_i(t)\n            h_i = (t / tau_vec[i]) * np.exp(-t / tau_vec[i])\n            \n            # Convolution (a_base * h_i)(t)\n            conv_result = np.convolve(a_base, h_i, mode='full')[:num_timesteps] * DELTA_T\n            \n            # Angle response theta_i(t)\n            thetas[:, i] = g_vec[i] * conv_result + b_vec[i] * jerk\n\n        # --- 4. Kinematic Analysis ---\n        # Curvature kappa_i(t)\n        kappas = thetas / L\n\n        # S-shape condition: kappa_i * kappa_{i+1} < 0\n        s_shape_products = kappas[:, :-1] * kappas[:, 1:]\n        s_shape_mask = np.any(s_shape_products < 0, axis=1)\n\n        s_shape_present = np.any(s_shape_mask)\n        \n        # --- 5. Peak S-Shape Time (t_S) Determination ---\n        if not s_shape_present:\n            t_S = -1.0\n            ts_minus_t_peak_a = -1.0\n            ts_minus_t_peak_j = -1.0\n        else:\n            # Curvature gradient G(t)\n            delta_s = (L[:-1] + L[1:]) / 2.0\n            kappa_gradients = (kappas[:, 1:] - kappas[:, :-1]) / delta_s\n            G_t = np.max(np.abs(kappa_gradients), axis=1)\n\n            # Find t_S by maximizing G(t) only during S-shape\n            G_t_masked = np.copy(G_t)\n            G_t_masked[~s_shape_mask] = -1.0 # Mask out non-S-shape times\n            \n            t_S_idx = np.argmax(G_t_masked)\n            t_S = t[t_S_idx]\n            \n            ts_minus_t_peak_a = t_S - t_peak_a\n            ts_minus_t_peak_j = t_S - t_peak_j\n\n        # --- 6. Output Compilation ---\n        result_tuple = (\n            t_S, t_peak_a, t_peak_j,\n            ts_minus_t_peak_a, ts_minus_t_peak_j,\n            s_shape_present\n        )\n        all_results.append(result_tuple)\n\n    # Format the final output string exactly as required\n    output_parts = []\n    for result in all_results:\n        formatted_items = []\n        for item in result:\n            if isinstance(item, bool):\n                formatted_items.append(str(item).lower())\n            elif isinstance(item, float):\n                formatted_items.append(f\"{item:.6f}\")\n            else:\n                formatted_items.append(str(item))\n        output_parts.append(f\"[{','.join(formatted_items)}]\")\n        \n    print(f\"[[{output_parts[0][1:-1]}],[{output_parts[1][1:-1]}],[{output_parts[2][1:-1]}]]\")\n\n\nsolve()\n```"
        }
    ]
}