{
    "hands_on_practices": [
        {
            "introduction": "在模拟运动之前，我们必须首先理解在静态下肌肉骨骼系统如何产生力矩。这个练习将指导你从基本原理出发，构建一个包含肌肉路径、羽状角和力学特性的详细肌肉模型，以计算在给定姿势和激活水平下的关节力矩。通过这个实践，你将掌握建立生物力学模型的关键组成部分，并解决肌肉-肌腱单元的静态平衡问题。",
            "id": "4193925",
            "problem": "考虑一个绕 $z$ 轴旋转的平面单自由度关节，其静态姿势由关节角度 $\\theta$（以弧度为单位）定义。有两块肌肉跨过该关节：一块屈肌和一块伸肌。每块肌肉都有一条由三个途经点定义的多段路径，其中一个远端途经点刚性附着在远端节段上，并随关节一起旋转。近端途经点刚性附着在近端节段上，不随关节旋转。每块肌肉的肌腱路径长度是连续途经点之间欧几里得距离的总和。在静态条件下（关节角加速度为零），关节周围的净肌肉力矩来自于肌腱力与其力臂乘积的总和。您的任务是，在给定肌肉激活度和肌腱刚度的情况下，计算特定姿势下的净肌肉力矩，其中需为每块肌肉整合羽状结构和多个途经点，并使用基本定律和核心定义，而不预设专门的简化公式。\n\n基本原理：问题必须从第一性原理推导，具体如下：\n- 牛顿第二旋转定律：关节的净力矩等于各独立力矩之和，在静态条件下，净关节力矩可通过将每块肌肉的力通过其力臂进行投影并求和来计算。\n- 平面内刚体旋转运动学：远端途经点的位置通过绕关节中心的旋转矩阵进行变换。\n- 几何定义：肌腱路径长度等于途经点之间欧几里得节段长度的总和。\n- 串联弹性肌肉模型：肌肉纤维与肌腱串联，强制实现力的平衡和一个几何约束，该约束关联了肌腱路径长度、肌腱长度以及由羽状角投影的纤维长度。\n\n使用的定义和建模假设：\n1. 设肌腱路径长度为 $L_{\\mathrm{mt}}(\\theta)$，根据角度 $\\theta$ 处的途经点几何结构计算得出。\n2. 设肌腱长度为 $L_{\\mathrm{t}}$，肌肉纤维长度为 $L_{\\mathrm{f}}$。\n3. 设羽状角为 $\\alpha(L_{\\mathrm{f}})$，基于恒定体积假设建模为 $\\alpha(L_{\\mathrm{f}}) = \\arcsin\\!\\left(\\min\\left( \\sin(\\alpha_0)\\,\\frac{L_{\\mathrm{opt}}}{L_{\\mathrm{f}}},\\,0.999\\right)\\right)$，其中 $\\alpha_0$ 是在最佳纤维长度 $L_{\\mathrm{opt}}$ 时的羽状角。\n4. 几何约束：$L_{\\mathrm{mt}}(\\theta) = L_{\\mathrm{t}} + L_{\\mathrm{f}}\\cos\\!\\big(\\alpha(L_{\\mathrm{f}})\\big)$。\n5. 肌腱力：$F_{\\mathrm{t}} = k \\,\\max\\!\\big(0,\\, L_{\\mathrm{t}} - L_{\\mathrm{ts}}\\big)$，其中 $k$ 是肌腱刚度，$L_{\\mathrm{ts}}$ 是肌腱松弛长度。\n6. 肌肉纤维主动力-长度关系（归一化）：$f_{\\mathrm{L}}(L_{\\mathrm{f}}) = \\exp\\!\\left(-\\frac{(L_{\\mathrm{f}} - L_{\\mathrm{opt}})^2}{w^2}\\right)$，其中 $w$ 是宽度参数。\n7. 肌肉纤维被动力：$F_{\\mathrm{p}}(L_{\\mathrm{f}}) = F_{\\mathrm{max}}\\,p_{\\mathrm{scale}}\\,\\max\\!\\big(0,\\,\\exp\\!\\big(p_k\\big(\\frac{L_{\\mathrm{f}}}{L_{\\mathrm{opt}}}-1\\big)\\big) - 1\\big)$。\n8. 肌肉纤维总力：$F_{\\mathrm{f}}(L_{\\mathrm{f}}) = a\\,F_{\\mathrm{max}}\\,f_{\\mathrm{L}}(L_{\\mathrm{f}}) + F_{\\mathrm{p}}(L_{\\mathrm{f}})$，其中 $a$ 是激活度（$0 \\le a \\le 1$）。\n9. 串联平衡：$F_{\\mathrm{t}} = F_{\\mathrm{f}}(L_{\\mathrm{f}})\\cos\\!\\big(\\alpha(L_{\\mathrm{f}})\\big)$，使用沿着作用线从肌肉纤维到肌腱的投影。\n\n力臂计算：\n- 关于 $z$ 轴的肌肉力臂 $r(\\theta)$ 定义为 $r(\\theta) = -\\frac{dL_{\\mathrm{mt}}}{d\\theta}$，通过对路径长度关于关节角度 $\\theta$ 求导得到。使用数值稳定的对称有限差分法，并采用一个小的扰动量 $\\Delta\\theta$ 来估计该导数。\n\n关节力矩：\n- 对于每块肌肉，通过平衡和几何关系计算肌腱力 $F_{\\mathrm{t}}$，然后计算关节力矩贡献 $\\tau_i(\\theta) = r_i(\\theta) F_{\\mathrm{t},i}$，其中下标 $i$ 为肌肉索引。净关节力矩为 $\\tau(\\theta) = \\sum_i \\tau_i(\\theta)$。\n- 关节力矩以牛顿米（$\\mathrm{N\\cdot m}$）表示。\n\n几何与参数：\n- 关节中心位于原点。远端节段在 $x$–$y$ 平面内绕 $z$ 轴旋转。使用旋转矩阵\n$$\nR_z(\\theta) = \\begin{bmatrix}\n\\cos\\theta  -\\sin\\theta  0 \\\\\n\\sin\\theta  \\cos\\theta  0 \\\\\n0  0  1\n\\end{bmatrix}.\n$$\n- 定义屈肌的途经点为三个点：近端附着点 $P_{\\mathrm{prox},f} = [-0.05,\\,0.15,\\,0]$，近端途经点 $P_{\\mathrm{via},f} = [-0.02,\\,0.03,\\,0]$，远端途经点 $P_{\\mathrm{dist},f} = [0.18,\\,0.02,\\,0]$，该点随 $R_z(\\theta) P_{\\mathrm{dist},f}$ 旋转。\n- 定义伸肌的途经点为三个点：近端附着点 $P_{\\mathrm{prox},e} = [-0.06,\\,-0.16,\\,0]$，近端途经点 $P_{\\mathrm{via},e} = [-0.02,\\,-0.03,\\,0]$，远端途经点 $P_{\\mathrm{dist},e} = [0.17,\\,-0.03,\\,0]$，该点随 $R_z(\\theta) P_{\\mathrm{dist},e}$ 旋转。\n- 肌肉参数：\n  - 屈肌：$F_{\\mathrm{max}} = 900$, $L_{\\mathrm{opt}} = 0.11$, $\\alpha_0 = 0.261799$（即 15 度，以弧度表示），$L_{\\mathrm{ts}} = 0.20$。\n  - 伸肌：$F_{\\mathrm{max}} = 700$, $L_{\\mathrm{opt}} = 0.10$, $\\alpha_0 = 0.20944$（即 12 度，以弧度表示），$L_{\\mathrm{ts}} = 0.19$。\n- 力-长度形状参数（两块肌肉共享）：$w = 0.25\\,L_{\\mathrm{opt}}$（对于各自的肌肉），$p_{\\mathrm{scale}} = 0.01$, $p_k = 4$。\n- 使用数值有限差分步长 $\\Delta\\theta = 10^{-6}$ 弧度进行力臂计算。\n\n任务：\n- 对以下每个测试用例，使用上述定义和建模假设计算净肌肉力矩 $\\tau(\\theta)$（单位为 $\\mathrm{N\\cdot m}$）。使用稳健的一维求根方法求解每块肌肉在容许区间 $L_{\\mathrm{f}} \\in [0.5\\,L_{\\mathrm{opt}},\\,1.8\\,L_{\\mathrm{opt}}]$ 内的 $L_{\\mathrm{f}}$ 平衡，如果未找到严格的变号区间，则在此区间内选择使绝对平衡残差最小的 $L_{\\mathrm{f}}$。\n\n测试套件：\n- 测试用例 1：$\\theta = 1.0$；屈肌激活度 $a_f = 0.4$；伸肌激活度 $a_e = 0.1$；屈肌肌腱刚度 $k_f = 12000$；伸肌肌腱刚度 $k_e = 10000$。\n- 测试用例 2（边界情况：伸肌可能松弛）：$\\theta = 1.4$；$a_f = 0.05$；$a_e = 0.0$；$k_f = 20000$；$k_e = 20000$。\n- 测试用例 3（边界情况：高激活度，软肌腱）：$\\theta = 0.5$；$a_f = 0.9$；$a_e = 0.2$；$k_f = 5000$；$k_e = 8000$。\n\n答案规格：\n- 对于每个测试用例，输出一个代表净关节力矩 $\\tau(\\theta)$（单位为 $\\mathrm{N\\cdot m}$）的浮点数。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3]$，其中每个 $x_i$ 对应测试用例 $i$ 的力矩。角度必须以弧度解释。力矩单位必须是 $\\mathrm{N\\cdot m}$。不应打印额外文本。",
            "solution": "该问题被评估为有效，因为它科学上基于成熟的肌肉骨骼生物力学原理，提法良好，包含所有必要的参数和定义，并且陈述客观。该模型虽然是对生物现实的简化，但其内部是一致的，并且不违反物理学或数学的基本定律。该任务是生物力学领域的标准计算练习，并且已完全指定。\n\n解决方案的步骤是：首先为每块肌肉建立运动学和动力学模型，然后描述用于求解肌肉内部状态的数值程序，最后结合结果计算净关节力矩。\n\n### 1. 运动学模型：肌腱路径长度 ($L_{\\mathrm{mt}}$)\n对于给定的肌肉 $i$（屈肌或伸肌），其肌肉骨骼几何结构由三个途经点组成：一个近端附着点 $P_{\\mathrm{prox},i}$、一个近端途经点 $P_{\\mathrm{via},i}$ 和一个远端途经点 $P_{\\mathrm{dist},i}$。近端点是固定的，而远端点附着于旋转节段。在关节角度为 $\\theta$ 时，远端途经点在全局坐标系中的位置 $P'_{\\mathrm{dist},i}(\\theta)$，是通过将其局部坐标应用于指定的旋转矩阵 $R_z(\\theta)$ 来计算的：\n$$\nP'_{\\mathrm{dist},i}(\\theta) = R_z(\\theta) P_{\\mathrm{dist},i} =\n\\begin{bmatrix}\n\\cos\\theta  -\\sin\\theta  0 \\\\\n\\sin\\theta  \\cos\\theta  0 \\\\\n0  0  1\n\\end{bmatrix}\nP_{\\mathrm{dist},i}\n$$\n总肌腱路径长度 $L_{\\mathrm{mt},i}(\\theta)$ 是该路径上连续点之间欧几里得距离的总和：\n$$\nL_{\\mathrm{mt},i}(\\theta) = \\| P_{\\mathrm{via},i} - P_{\\mathrm{prox},i} \\|_2 + \\| P'_{\\mathrm{dist},i}(\\theta) - P_{\\mathrm{via},i} \\|_2\n$$\n其中 $\\| \\cdot \\|_2$ 表示欧几里得范数。\n\n### 2. 力臂计算 ($r$)\n肌肉 $i$ 的力臂 $r_i(\\theta)$ 定义为肌腱路径长度相对于关节角度 $\\theta$ 的负偏导数。这个量代表了肌肉力在关节轴周围产生力矩的有效性。\n$$\nr_i(\\theta) = -\\frac{\\partial L_{\\mathrm{mt},i}}{\\partial \\theta}\n$$\n正力臂通常对应于屈肌，负力臂对应于伸肌。我们按照规定，使用二阶对称有限差分公式，并采用一个小的扰动量 $\\Delta\\theta = 10^{-6}$ 弧度，来数值估计该导数：\n$$\nr_i(\\theta) \\approx -\\frac{L_{\\mathrm{mt},i}(\\theta + \\Delta\\theta) - L_{\\mathrm{mt},i}(\\theta - \\Delta\\theta)}{2 \\Delta\\theta}\n$$\n\n### 3. 肌腱单元模型\n每块肌肉的模型由一个收缩性肌肉纤维元件与一个被动弹性肌腱元件串联组成。该系统的状态由一组耦合的几何方程和力方程控制。\n\n- **羽状角 $\\alpha(L_{\\mathrm{f}})$：** 肌肉纤维与肌腱作用线之间的夹角 $\\alpha$ 取决于纤维长度 $L_{\\mathrm{f}}$。假设肌肉体积恒定，该关系由下式给出：\n  $$\n  \\alpha(L_{\\mathrm{f}}) = \\arcsin\\left(\\min\\left( \\sin(\\alpha_0)\\,\\frac{L_{\\mathrm{opt}}}{L_{\\mathrm{f}}},\\,0.999\\right)\\right)\n  $$\n  其中 $\\alpha_0$ 是在最佳纤维长度 $L_{\\mathrm{opt}}$ 时的羽状角。裁剪到 0.999 这个值可以确保反正弦函数的参数保持在其有效定义域 $[-1, 1]$ 内。\n\n- **几何约束：** 总路径长度 $L_{\\mathrm{mt}}$ 在肌腱长度 $L_{\\mathrm{t}}$ 和沿肌腱轴投影的肌肉纤维长度之间分配。\n  $$\n  L_{\\mathrm{mt}}(\\theta) = L_{\\mathrm{t}} + L_{\\mathrm{f}}\\cos\\big(\\alpha(L_{\\mathrm{f}})\\big)\n  $$\n\n- **力方程：** 肌腱和肌肉纤维产生的力是其各自长度的函数。\n  - **肌腱力 ($F_{\\mathrm{t}}$)：** 建模为一个线性弹簧，其刚度为 $k$，仅当肌腱被拉伸超过其松弛长度 $L_{\\mathrm{ts}}$ 时才起作用。\n    $$\n    F_{\\mathrm{t}} = k \\,\\max\\!\\big(0,\\, L_{\\mathrm{t}} - L_{\\mathrm{ts}}\\big)\n    $$\n    通过代入几何约束中的 $L_{\\mathrm{t}}$，$F_{\\mathrm{t}}$ 可以表示为 $L_{\\mathrm{f}}$ 和 $\\theta$ 的函数：\n    $$\n    F_{\\mathrm{t}}(L_{\\mathrm{f}}; \\theta, k) = k \\,\\max\\!\\left(0,\\, L_{\\mathrm{mt}}(\\theta) - L_{\\mathrm{f}}\\cos\\big(\\alpha(L_{\\mathrm{f}})\\big) - L_{\\mathrm{ts}}\\right)\n    $$\n  - **肌肉纤维力 ($F_{\\mathrm{f}}$)：** 纤维总力是主动分量（由激活度 $a \\in [0, 1]$ 缩放）和被动分量之和。\n    $$\n    F_{\\mathrm{f}}(L_{\\mathrm{f}}; a) = a\\,F_{\\mathrm{max}}\\,f_{\\mathrm{L}}(L_{\\mathrm{f}}) + F_{\\mathrm{p}}(L_{\\mathrm{f}})\n    $$\n    各分量定义如下：\n    - 主动力-长度乘子：$f_{\\mathrm{L}}(L_{\\mathrm{f}}) = \\exp\\!\\left(-\\frac{(L_{\\mathrm{f}} - L_{\\mathrm{opt}})^2}{w^2}\\right)$，宽度 $w = 0.25\\,L_{\\mathrm{opt}}$。\n    - 被动力：$F_{\\mathrm{p}}(L_{\\mathrm{f}}) = F_{\\mathrm{max}}\\,p_{\\mathrm{scale}}\\,\\max\\!\\big(0,\\,\\exp\\!\\big(p_k\\big(\\frac{L_{\\mathrm{f}}}{L_{\\mathrm{opt}}}-1\\big)\\big) - 1\\big)$，其中 $p_{\\mathrm{scale}} = 0.01$ 且 $p_k = 4$。\n\n### 4. 静态平衡\n对于静态姿势，肌腱力必须与投影的肌肉纤维力相平衡。\n$$\nF_{\\mathrm{t}} = F_{\\mathrm{f}}(L_{\\mathrm{f}})\\cos\\big(\\alpha(L_{\\mathrm{f}})\\big)\n$$\n为求解系统状态，我们必须找到在给定的 $\\theta$、激活度 $a$ 和刚度 $k$ 下满足此平衡的纤维长度 $L_{\\mathrm{f}}$。这通过找到残差函数 $E(L_{\\mathrm{f}})$ 的根来实现：\n$$\nE(L_{\\mathrm{f}}) = F_{\\mathrm{t}}(L_{\\mathrm{f}}; \\theta, k) - F_{\\mathrm{f}}(L_{\\mathrm{f}}; a) \\cos\\big(\\alpha(L_{\\mathrm{f}})\\big) = 0\n$$\n\n### 5. 纤维长度的数值解\n问题指定在搜索区间 $[0.5\\,L_{\\mathrm{opt}},\\,1.8\\,L_{\\mathrm{opt}}]$ 内求解 $L_{\\mathrm{f}}$。采用一种稳健的数值程序：\n1.  首先在该区间上尝试使用求根算法（特别是 Brent 方法）。如果端点处的函数值 $E(0.5\\,L_{\\mathrm{opt}})$ 和 $E(1.8\\,L_{\\mathrm{opt}})$ 符号相反，则该方法是高效的且保证收敛。\n2.  如果未找到变号区间，问题指示需找到使绝对平衡残差 $|E(L_{\\mathrm{f}})|$ 最小的 $L_{\\mathrm{f}}$。这通过有界标量优化程序处理，该程序在允许范围内找到“最接近平衡”的点。\n\n一旦确定了平衡纤维长度 $L_{\\mathrm{f}}^*$，就可以计算出相应的肌腱力 $F_{\\mathrm{t}}$。\n\n### 6. 净关节力矩\n来自每块肌肉 $i$ 的力矩贡献 $\\tau_i$ 是其力臂和肌腱力的乘积：\n$$\n\\tau_i(\\theta) = r_i(\\theta) F_{\\mathrm{t},i}\n$$\n关节周围的总净肌肉力矩 $\\tau(\\theta)$ 是屈肌和伸肌力矩的代数和：\n$$\n\\tau(\\theta) = \\tau_{\\text{flexor}}(\\theta) + \\tau_{\\text{extensor}}(\\theta)\n$$\n对每个测试用例应用此程序，以计算最终所需的力矩值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq, minimize_scalar\n\ndef solve():\n    \"\"\"\n    Solves the musculoskeletal forward dynamics problem for a single-joint system.\n    \"\"\"\n\n    class Muscle:\n        \"\"\"\n        Represents a single pennate muscle with a series elastic tendon.\n        \"\"\"\n        def __init__(\n            self, F_max, L_opt, alpha_0, L_ts, p_scale, p_k,\n            P_prox, P_via, P_dist_local\n        ):\n            self.F_max = F_max\n            self.L_opt = L_opt\n            self.alpha_0 = alpha_0\n            self.L_ts = L_ts\n            self.p_scale = p_scale\n            self.p_k = p_k\n            self.w = 0.25 * L_opt\n\n            self.P_prox = np.array(P_prox)\n            self.P_via = np.array(P_via)\n            self.P_dist_local = np.array(P_dist_local)\n\n        @staticmethod\n        def _rotate_point(theta, point):\n            c, s = np.cos(theta), np.sin(theta)\n            R_z = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n            return R_z @ point\n\n        def get_Lmt(self, theta):\n            P_dist_rotated = self._rotate_point(theta, self.P_dist_local)\n            seg1_len = np.linalg.norm(self.P_via - self.P_prox)\n            seg2_len = np.linalg.norm(P_dist_rotated - self.P_via)\n            return seg1_len + seg2_len\n\n        def get_moment_arm(self, theta, delta_theta):\n            Lmt_plus = self.get_Lmt(theta + delta_theta)\n            Lmt_minus = self.get_Lmt(theta - delta_theta)\n            return -(Lmt_plus - Lmt_minus) / (2 * delta_theta)\n\n        def _get_alpha(self, L_f):\n            # Clip argument to arcsin to avoid domain errors, as per problem spec\n            arg_asin = min(np.sin(self.alpha_0) * self.L_opt / L_f, 0.999)\n            return np.arcsin(arg_asin)\n\n        def _equilibrium_residual(self, L_f, L_mt, a, k):\n            # Pennation\n            alpha = self._get_alpha(L_f)\n            cos_alpha = np.cos(alpha)\n\n            # Tendon force\n            L_t = L_mt - L_f * cos_alpha\n            F_t = k * max(0, L_t - self.L_ts)\n\n            # Fiber force\n            # Active\n            f_L = np.exp(-((L_f - self.L_opt) / self.w)**2)\n            # Passive\n            f_passive_term = np.exp(self.p_k * (L_f / self.L_opt - 1)) - 1\n            F_p = self.F_max * self.p_scale * max(0, f_passive_term)\n            \n            F_f = a * self.F_max * f_L + F_p\n\n            return F_t - F_f * cos_alpha\n        \n        def solve_equilibrium(self, L_mt, a, k):\n            L_f_min, L_f_max = 0.5 * self.L_opt, 1.8 * self.L_opt\n            args = (L_mt, a, k)\n            \n            try:\n                res_min = self._equilibrium_residual(L_f_min, *args)\n                res_max = self._equilibrium_residual(L_f_max, *args)\n                if np.sign(res_min) != np.sign(res_max):\n                    L_f_eq = brentq(self._equilibrium_residual, L_f_min, L_f_max, args=args)\n                else:\n                    # Fallback to minimization if no sign change\n                    def objective(L_f, L_mt, a, k):\n                        return abs(self._equilibrium_residual(L_f, L_mt, a, k))\n                    res = minimize_scalar(objective, bounds=(L_f_min, L_f_max), args=args, method='bounded')\n                    L_f_eq = res.x\n            except (ValueError, RuntimeError):\n                # General fallback to minimization\n                def objective(L_f, L_mt, a, k):\n                    return abs(self._equilibrium_residual(L_f, L_mt, a, k))\n                res = minimize_scalar(objective, bounds=(L_f_min, L_f_max), args=args, method='bounded')\n                L_f_eq = res.x\n            \n            return L_f_eq\n\n        def get_tendon_force(self, L_f, L_mt, k):\n            alpha = self._get_alpha(L_f)\n            cos_alpha = np.cos(alpha)\n            L_t = L_mt - L_f * cos_alpha\n            return k * max(0, L_t - self.L_ts)\n\n        def calculate_torque_contribution(self, theta, a, k, delta_theta):\n            L_mt = self.get_Lmt(theta)\n            r = self.get_moment_arm(theta, delta_theta)\n            \n            if L_mt == 0: return 0.0\n\n            L_f_eq = self.solve_equilibrium(L_mt, a, k)\n            F_t = self.get_tendon_force(L_f_eq, L_mt, k)\n            \n            return r * F_t\n\n    # Define shared parameters\n    p_scale = 0.01\n    p_k = 4.0\n    delta_theta = 1e-6\n\n    # Define flexor muscle\n    flexor = Muscle(\n        F_max=900, L_opt=0.11, alpha_0=0.261799, L_ts=0.20,\n        p_scale=p_scale, p_k=p_k,\n        P_prox=[-0.05, 0.15, 0],\n        P_via=[-0.02, 0.03, 0],\n        P_dist_local=[0.18, 0.02, 0]\n    )\n\n    # Define extensor muscle\n    extensor = Muscle(\n        F_max=700, L_opt=0.10, alpha_0=0.20944, L_ts=0.19,\n        p_scale=p_scale, p_k=p_k,\n        P_prox=[-0.06, -0.16, 0],\n        P_via=[-0.02, -0.03, 0],\n        P_dist_local=[0.17, -0.03, 0]\n    )\n\n    # Test suite\n    test_cases = [\n        # (theta, a_f, a_e, k_f, k_e)\n        (1.0, 0.4, 0.1, 12000, 10000),\n        (1.4, 0.05, 0.0, 20000, 20000),\n        (0.5, 0.9, 0.2, 5000, 8000),\n    ]\n\n    results = []\n    for theta, a_f, a_e, k_f, k_e in test_cases:\n        tau_flexor = flexor.calculate_torque_contribution(theta, a_f, k_f, delta_theta)\n        tau_extensor = extensor.calculate_torque_contribution(theta, a_e, k_e, delta_theta)\n        net_torque = tau_flexor + tau_extensor\n        results.append(net_torque)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\n# Run the solver\nsolve()\n```"
        },
        {
            "introduction": "运动是一个动态过程，其中一个关键环节是神经兴奋如何随时间转化为肌肉激活。本练习将探讨常用的一阶肌肉激活动态模型，并要求你使用显式欧拉法这一基本数值方法对其进行离散化。此实践的核心是进行稳定性分析，以确定保证模拟稳定性的最大时间步长 $\\Delta t$，这项技能对于确保任何前向动力学模拟的准确性和可靠性至关重要。",
            "id": "4193963",
            "problem": "单肌激活状态 $a(t) \\in [0,1]$ 在有界神经控制输入 $u(t) \\in [0,1]$ 的驱动下，遵循一阶激活-动力学演化。在广泛使用的肌肉骨骼模型中，激活-动力学由常微分方程 (ODE) 表示\n$$\n\\frac{d a(t)}{d t} = \\frac{u(t) - a(t)}{\\tau\\!\\left(u(t),a(t)\\right)},\n$$\n其中时间常数 $\\tau\\!\\left(u,a\\right)$ 分段定义为\n$$\n\\tau\\!\\left(u,a\\right) = \\begin{cases}\n\\tau_{\\text{act}}  \\text{若 } u \\ge a, \\\\\n\\tau_{\\text{deact}}  \\text{若 } u  a,\n\\end{cases}\n$$\n其中 $\\tau_{\\text{act}} > 0$ 且 $\\tau_{\\text{deact}} > 0$。激活状态以均匀间隔 $\\Delta t > 0$ 进行采样，并且输入 $u(t)$ 在每个采样间隔内保持恒定，即对于整数 $k \\ge 0$，$t \\in [k \\Delta t, (k+1)\\Delta t)$ 时，$u(t) = u_k$。\n\n从时间导数的定义和给定的 ODE 出发，使用显式欧拉法构建离散时间更新映射 $a_k \\mapsto a_{k+1}$。然后，对得到的离散时间齐次误差动力学围绕瞬时稳态进行线性稳定性分析，以获得一个关于 $\\Delta t$ 的不等式，该不等式保证对于分段定义中所有允许的 $\\tau$ 值，系统都是稳定的。最后，给定 $\\tau_{\\text{act}} = 12.3~\\text{ms}$ 和 $\\tau_{\\text{deact}} = 46.0~\\text{ms}$，计算满足您稳定性条件的最大稳定采样间隔 $\\Delta t_{\\max}$ (以毫秒为单位)。以毫秒为单位表示 $\\Delta t_{\\max}$，并将您的数值答案四舍五入到四位有效数字。",
            "solution": "首先验证问题陈述，以确保其科学基础扎实、问题定义良好且客观。\n\n### 步骤 1：提取已知条件\n- 激活状态为 $a(t) \\in [0,1]$。\n- 神经控制输入为 $u(t) \\in [0,1]$。\n- 激活-动力学的控制常微分方程 (ODE) 为：\n$$\n\\frac{d a(t)}{d t} = \\frac{u(t) - a(t)}{\\tau\\!\\left(u(t),a(t)\\right)}\n$$\n- 分段定义的时间常数 $\\tau\\!\\left(u,a\\right)$ 为：\n$$\n\\tau\\!\\left(u,a\\right) = \\begin{cases}\n\\tau_{\\text{act}}  \\text{if } u \\ge a, \\\\\n\\tau_{\\text{deact}}  \\text{if } u  a,\n\\end{cases}\n$$\n- 常数参数满足 $\\tau_{\\text{act}} > 0$ 且 $\\tau_{\\text{deact}} > 0$。\n- 激活状态以均匀间隔 $\\Delta t > 0$ 进行采样。\n- 输入 $u(t)$ 是一个分段常数函数：对于整数 $k \\ge 0$，$t \\in [k \\Delta t, (k+1)\\Delta t)$ 时，$u(t) = u_k$。\n- 给定的时间常数具体值为 $\\tau_{\\text{act}} = 12.3~\\text{ms}$ 和 $\\tau_{\\text{deact}} = 46.0~\\text{ms}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估问题。\n- **科学基础：** 用于肌肉激活-动力学的一阶 ODE 模型是生物力学和肌肉骨骼建模领域中一个标准且被广泛接受的模型，通常归功于 Zajac (1989) 的工作。所提供的激活和失活时间常数值在生理上是合理的。\n- **定义良好：** 问题提供了进行求解所需的所有必要信息。它要求推导离散时间更新、进行线性稳定性分析以及计算最大稳定步长。这些都是应用于动力系统的数值分析中的标准、定义明確的任务。数据是自洽且一致的。\n- **客观性：** 问题使用精确、标准的科学术语进行表述，没有主观或模糊的语言。\n\n### 步骤 3：结论与行动\n问题被判定为**有效**。现在开始求解过程。\n\n### 解题推导\n根据要求，解题过程分为三部分：推导离散时间更新，进行稳定性分析，以及计算最大稳定采样间隔。\n\n**1. 构建离散时间更新映射**\n显式（或前向）欧拉法用于离散化给定的 ODE。对于一个形式为 $\\frac{dy}{dt} = f(t,y)$ 的一般一阶 ODE，显式欧拉更新规则为 $y_{k+1} = y_k + \\Delta t \\cdot f(t_k, y_k)$。\n\n在这个问题中，$y(t)$ 对应于激活状态 $a(t)$，所以 $y_k = a(k \\Delta t) \\equiv a_k$。函数 $f(t,y)$ 由激活-动力学 ODE 的右侧给出。在区间 $[k\\Delta t, (k+1)\\Delta t)$ 内，输入 $u(t)$ 恒为 $u_k$，我们用 $a_k$ 来近似状态 $a(t)$。时间常数 $\\tau$ 也依赖于 $u$ 和 $a$，因此我们在时间步 $k$ 对其进行求值：$\\tau_k = \\tau(u_k, a_k)$。\n\n在步骤 k 的函数 f 为：\n$$\nf(k\\Delta t, a_k) = \\frac{u_k - a_k}{\\tau(u_k, a_k)} = \\frac{u_k - a_k}{\\tau_k}\n$$\n应用显式欧拉公式，我们得到离散时间更新映射 $a_k \\mapsto a_{k+1}$：\n$$\na_{k+1} = a_k + \\Delta t \\left( \\frac{u_k - a_k}{\\tau_k} \\right)\n$$\n这个方程可以重新排列，以显示 $a_{k+1}$ 对 $a_k$ 和 $u_k$ 的依赖关系：\n$$\na_{k+1} = a_k - \\frac{\\Delta t}{\\tau_k} a_k + \\frac{\\Delta t}{\\tau_k} u_k = \\left(1 - \\frac{\\Delta t}{\\tau_k}\\right)a_k + \\left(\\frac{\\Delta t}{\\tau_k}\\right)u_k\n$$\n这就是所要求的离散时间更新映射。\n\n**2. 进行线性稳定性分析**\n稳定性分析是针对齐次误差动力学进行的。误差是相对于瞬时稳态定义的。对于一个恒定的输入 $u_k$，稳态激活 $a_{ss}$ 是使 $\\frac{da}{dt} = 0$ 的 $a$ 值。从 ODE 可知，这意味着 $u_k - a_{ss} = 0$，所以 $a_{ss} = u_k$。\n\n在时间步 k 的误差定义为 $e_k = a_k - a_{ss} = a_k - u_k$。\n在下一个时间步 k+1 的误差为 $e_{k+1} = a_{k+1} - a_{ss} = a_{k+1} - u_k$。\n\n我们将更新规则中的 $a_{k+1}$ 表达式代入 $e_{k+1}$ 的方程中：\n$$\ne_{k+1} = \\left[ \\left(1 - \\frac{\\Delta t}{\\tau_k}\\right)a_k + \\left(\\frac{\\Delta t}{\\tau_k}\\right)u_k \\right] - u_k\n$$\n合并含有 $u_k$ 的项：\n$$\ne_{k+1} = \\left(1 - \\frac{\\Delta t}{\\tau_k}\\right)a_k + \\left(\\frac{\\Delta t}{\\tau_k} - 1\\right)u_k\n$$\n提出公因式 $(1 - \\frac{\\Delta t}{\\tau_k})$：\n$$\ne_{k+1} = \\left(1 - \\frac{\\Delta t}{\\tau_k}\\right)(a_k - u_k)\n$$\n根据定义，$e_k = a_k - u_k$，因此我们得到齐次误差动力学：\n$$\ne_{k+1} = \\left(1 - \\frac{\\Delta t}{\\tau_k}\\right)e_k\n$$\n这是一个一阶线性离散时间系统。为了使系统稳定，误差必须随时间衰减至零，这要求放大因子（系统矩阵的特征值，此处为一个标量）的幅值严格小于 1：\n$$\n\\left| 1 - \\frac{\\Delta t}{\\tau_k} \\right|  1\n$$\n这个不等式等价于双重不等式：\n$$\n-1  1 - \\frac{\\Delta t}{\\tau_k}  1\n$$\n我们分别分析这两个部分：\n1.  右侧不等式：$1 - \\frac{\\Delta t}{\\tau_k}  1 \\implies -\\frac{\\Delta t}{\\tau_k}  0$。由于 $\\Delta t > 0$ 且 $\\tau_k$（可以是 $\\tau_{\\text{act}}$ 或 $\\tau_{\\text{deact}}$）也为正，此条件始终满足。\n2.  左侧不等式：$-1  1 - \\frac{\\Delta t}{\\tau_k} \\implies \\frac{\\Delta t}{\\tau_k}  2 \\implies \\Delta t  2\\tau_k$。\n\n因此，该系统显式欧拉积分的数值稳定性条件是 $\\Delta t  2\\tau_k$。\n\n这个稳定性条件必须对时间常数 $\\tau$ 的任何允许值都成立。时间常数 $\\tau_k$可以是 $\\tau_{\\text{act}}$ 或 $\\tau_{\\text{deact}}$，具体取决于 $u_k$ 和 $a_k$ 的值。为了在所有情况下都保证稳定性，必须选择 $\\Delta t$ 以满足最严格的条件。对于较小的 $\\tau$ 值，不等式 $\\Delta t  2\\tau$ 更具限制性（对 $\\Delta t$ 施加一个更小的上界）。因此，我们必须满足 $\\tau$ 的最小可能值的条件：\n$$\n\\Delta t  2 \\min(\\tau_{\\text{act}}, \\tau_{\\text{deact}})\n$$\n这就是保证对所有允许的 $\\tau$ 都稳定的不等式。\n\n**3. 计算最大稳定采样间隔**\n最大稳定采样间隔 $\\Delta t_{\\max}$ 是稳定 $\\Delta t$ 集合的上确界，它对应于稳定区域的上边界：\n$$\n\\Delta t_{\\max} = 2 \\min(\\tau_{\\text{act}}, \\tau_{\\text{deact}})\n$$\n我们给定的数值是 $\\tau_{\\text{act}} = 12.3~\\text{ms}$ 和 $\\tau_{\\text{deact}} = 46.0~\\text{ms}$。\n首先，我们找出这两个值中的最小值：\n$$\n\\min(\\tau_{\\text{act}}, \\tau_{\\text{deact}}) = \\min(12.3, 46.0)~\\text{ms} = 12.3~\\text{ms}\n$$\n现在，我们可以计算 $\\Delta t_{\\max}$：\n$$\n\\Delta t_{\\max} = 2 \\times 12.3~\\text{ms} = 24.6~\\text{ms}\n$$\n题目要求答案四舍五入到四位有效数字。\n$$\n\\Delta t_{\\max} = 24.60~\\text{ms}\n$$",
            "answer": "$$\\boxed{24.60}$$"
        },
        {
            "introduction": "前向动力学研究的最终目标通常是理解或创造受控的运动。这个练习将引导你完成一个完整的设计与验证循环：你将首先对复杂的生物力学系统进行线性化，以设计一个能够实现临界阻尼性能的PD控制器。随后，你将在完整的非线性模型中测试该控制器，从而亲身体验理论设计与实际性能之间的联系，并加深对控制理论与复杂生物力学建模相互作用的理解。",
            "id": "4193974",
            "problem": "一个由单个具有恒定力臂的希尔型肌肉驱动的单自由度（DOF）旋转关节。目标是设计比例-微分增益，以在指定工作点附近实现关节阶跃响应的临界阻尼，并通过正向仿真验证设计。推导和实现必须从基本力学和经过充分检验的肌腱生理学出发，并且必须避免使用快捷公式，从第一性原理出发进行最终设计。\n\n假设关节遵循牛顿第二旋转定律。令 $J$ 表示转动惯量（单位为 $\\mathrm{kg\\cdot m^2}$），$\\theta$ 表示关节角度（单位为 $\\mathrm{rad}$），$\\omega = d\\theta/dt$ 表示关节角速度（单位为 $\\mathrm{rad/s}$）。旋转动力学为\n$$\nJ \\,\\frac{d\\omega}{dt} = \\tau_m,\n$$\n运动学关系为\n$$\n\\frac{d\\theta}{dt} = \\omega,\n$$\n除了肌肉产生的力矩外，没有其他外部力矩。肌肉力矩建模为\n$$\n\\tau_m = r\\,F_m(\\ell, v, a),\n$$\n其中 $r$ 是恒定的肌肉力臂（单位为 $\\mathrm{m}$），$F_m$ 是肌肉力（单位为 $\\mathrm{N}$），$\\ell$ 是肌腱长度（单位为 $\\mathrm{m}$），$v$ 是肌腱速度（单位为 $\\mathrm{m/s}$），$a$ 是肌肉激活度（无量纲，范围为 $[0,1]$）。令 $\\ell_{\\mathrm{opt}}$ 表示最佳肌肉纤维长度，使得工作点位于 $\\theta = 0$ 和 $\\ell = \\ell_{\\mathrm{opt}}$。使用仿射映射\n$$\n\\ell(\\theta) = \\ell_{\\mathrm{opt}} - r\\,\\theta, \\quad v(\\theta,\\omega) = -r\\,\\omega.\n$$\n\n希尔型肌肉力由主动和被动两部分组成，\n$$\nF_m(\\ell, v, a) = F_{\\mathrm{active}}(\\ell, v, a) + F_{\\mathrm{passive}}(\\ell),\n$$\n其中主动力定义为\n$$\nF_{\\mathrm{active}}(\\ell, v, a) = a\\,F_{\\max}\\,f_{\\ell}(\\ell)\\,f_{v}(v),\n$$\n其中 $F_{\\max}$ 是最大等长力（单位为 $\\mathrm{N}$），$f_{\\ell}(\\ell)$ 是归一化的力-长度曲线，$f_v(v)$ 是归一化的力-速度曲线，两者均为无量纲，在工作点 $(\\ell=\\ell_{\\mathrm{opt}}, v=0)$ 处等于 $1$。使用以下广为接受的形式：\n$$\nf_{\\ell}(\\ell) = \\exp\\!\\left(-\\left(\\frac{\\ell - \\ell_{\\mathrm{opt}}}{w\\,\\ell_{\\mathrm{opt}}}\\right)^2\\right),\n$$\n其中 $w$ 是宽度参数（无量纲），以及希尔双曲线力-速度关系\n$$\nf_{v}(v) = \\frac{v_{\\max} - v}{v_{\\max} + k_v\\,v},\n$$\n其中 $v_{\\max}$ 是最大缩短速度（单位为 $\\mathrm{m/s}$），$k_v$ 是一个无量纲参数。被动力由二次松弛模型定义\n$$\nF_{\\mathrm{passive}}(\\ell) = F_{\\max}\\,k_{\\mathrm{pas}}\\,\\max\\!\\left(0, \\frac{\\ell}{\\ell_{\\mathrm{opt}}}-1\\right)^2,\n$$\n其中 $k_{\\mathrm{pas}}$ 是无量纲的。\n\n肌肉激活动力学被建模为一个时间常数为 $T_a$（单位为 $\\mathrm{s}$）的一阶系统，\n$$\n\\frac{da}{dt} = \\frac{u - a}{T_a},\n$$\n其中 $u\\in[0,1]$ 是神经控制输入。控制器是一个比例-微分定律，作用于关节角度相对于参考值 $\\theta_{\\mathrm{ref}}$（单位为 $\\mathrm{rad}$）的跟踪误差，参考值取为阶跃输入：\n$$\nu = K_p\\left(\\theta_{\\mathrm{ref}} - \\theta\\right) - K_d\\,\\omega,\n$$\n其中 $K_p$ 和 $K_d$ 是将角度和角速度映射到激活度的无量纲增益。激活度 $a$ 和指令 $u$ 被饱和限制在区间 $[0,1]$ 内。\n\n设计增益 $(K_p,K_d)$ 以在工作点 $\\theta=0$ 附近实现闭环关节动力学的临界阻尼，并采用以下近似：在 $(\\theta=0,\\omega=0,a=0)$ 周围对 $\\tau_m$ 进行小信号线性化，并在设计阶段忽略激活动力学。为得到的二阶闭环关节动力学选择一个目标自然频率 $\\omega_n$（单位为 $\\mathrm{rad/s}$）。从第一性原理出发，推导使近似二阶系统达到临界阻尼的 $(K_p,K_d)$ 表达式，然后在完整的非线性正向仿真（包括激活动力学和希尔型肌肉特性）中使用这些增益。通过仿真阶跃响应并计算超调分数来验证设计。\n\n超调分数必须按如下方式计算。令 $\\theta(t)$ 表示从 $t=0$ 到 $t=t_{\\mathrm{end}}$ 的仿真角度轨迹。将最终角度 $\\theta_f$ 定义为仿真区间最后 $10\\%$ 内 $\\theta(t)$ 的平均值。令 $\\theta_{\\max}$ 表示仿真期间达到的最大角度。对于初始角度 $\\theta(0)=0$ 和阶跃输入 $\\theta_{\\mathrm{ref}} = \\theta_{\\mathrm{step}} > 0$，定义超调分数\n$$\n\\mathrm{OS} = \\frac{\\theta_{\\max} - \\theta_f}{\\theta_f - \\theta(0)},\n$$\n这是一个无量纲的小数。\n\n所有仿真必须使用弧度作为角度单位，秒作为时间单位，$\\mathrm{N\\cdot m}$ 作为力矩单位，$\\mathrm{N}$ 作为力单位。对于每个测试用例，根据你推导的公式计算 $(K_p,K_d)$，使用数值积分对正向动力学进行时长为 $t_{\\mathrm{end}} = 2.0$（单位为 $\\mathrm{s}$）的仿真，并返回四舍五入到三位小数的超调分数。\n\n测试套件参数集如下：\n\n- 情况A（一般情况）：$J=0.05$（单位 $\\mathrm{kg\\cdot m^2}$），$r=0.03$（单位 $\\mathrm{m}$），$F_{\\max}=1500$（单位 $\\mathrm{N}$），$T_a=0.03$（单位 $\\mathrm{s}$），$\\ell_{\\mathrm{opt}}=0.10$（单位 $\\mathrm{m}$），$w=0.25$（无量纲），$v_{\\max}=10\\,\\ell_{\\mathrm{opt}}$（单位 $\\mathrm{m/s}$），$k_v=0.25$（无量纲），$k_{\\mathrm{pas}}=0.03$（无量纲），$\\theta_{\\mathrm{step}}=0.10$（单位 $\\mathrm{rad}$），目标 $\\omega_n=10.0$（单位 $\\mathrm{rad/s}$）。\n- 情况B（慢激活边界）：$J=0.05$，$r=0.03$，$F_{\\max}=1500$，$T_a=0.20$，$\\ell_{\\mathrm{opt}}=0.10$，$w=0.25$，$v_{\\max}=10\\,\\ell_{\\mathrm{opt}}$，$k_v=0.25$，$k_{\\mathrm{pas}}=0.03$，$\\theta_{\\mathrm{step}}=0.10$，目标 $\\omega_n=10.0$。\n- 情况C（小力臂和较低力量边缘）：$J=0.05$，$r=0.01$，$F_{\\max}=800$，$T_a=0.05$，$\\ell_{\\mathrm{opt}}=0.10$，$w=0.25$，$v_{\\max}=10\\,\\ell_{\\mathrm{opt}}$，$k_v=0.25$，$k_{\\mathrm{pas}}=0.03$，$\\theta_{\\mathrm{step}}=0.10$，目标 $\\omega_n=10.0$。\n- 情况D（较大惯量，较低目标频率）：$J=0.10$，$r=0.03$，$F_{\\max}=2000$，$T_a=0.03$，$\\ell_{\\mathrm{opt}}=0.10$，$w=0.25$，$v_{\\max}=10\\,\\ell_{\\mathrm{opt}}$，$k_v=0.25$，$k_{\\mathrm{pas}}=0.03$，$\\theta_{\\mathrm{step}}=0.15$，目标 $\\omega_n=7.0$。\n\n您的程序应生成单行输出，其中包含四个情况的超调分数，四舍五入到三位小数，以逗号分隔的列表形式包含在方括号内（例如，$[\\mathrm{os}_A,\\mathrm{os}_B,\\mathrm{os}_C,\\mathrm{os}_D]$）。",
            "solution": "用户提供的问题陈述已经过仔细分析，并被认为是**有效**的。它在科学上基于转动动力学原理和已建立的肌腱单元生物力学模型。该问题是适定的、客观的，并包含推导唯一解和执行所需验证的所有必要信息。该任务需要结合解析推导和数值仿真，这代表了受控生物力学系统设计和分析的标准工作流程。\n\n解决方案分为两个主要部分：首先，从第一性原理分析推导比例-微分（$K_p$, $K_d$）控制器增益；其次，使用完整的非线性系统模型实现正向动力学仿真，以验证控制器设计并计算指定的性能指标（超调分数）。\n\n### 第1部分：控制器增益的推导\n\n设计目标是选择增益 $K_p$ 和 $K_d$，以便在系统的线性化近似中，针对给定的目标自然频率 $\\omega_n$ 实现临界阻尼（$\\zeta=1$）。\n\n**1. 系统动力学与线性化**\n\n单自由度关节的旋转动力学由牛顿第二旋转定律决定：\n$$\nJ \\frac{d^2\\theta}{dt^2} = J \\dot{\\omega} = \\tau_m(\\theta, \\omega, a)\n$$\n其中 $J$ 是转动惯量，$\\theta$ 是关节角度，$\\omega$ 是角速度，$\\tau_m$ 是净肌肉力矩。\n\n问题明确指出，在控制器设计阶段，我们必须进行两个关键简化：\ni. 忽略肌肉激活动力学，即假定肌肉激活度 $a$ 等于控制指令 $u$，即 $a=u$。\nii. 在平衡点 $(\\theta, \\omega, a) = (0, 0, 0)$ 周围对力矩函数 $\\tau_m$ 进行线性化。\n\n线性化力矩 $\\delta\\tau_m$ 由一阶泰勒展开给出：\n$$\n\\delta\\tau_m \\approx \\left.\\frac{\\partial \\tau_m}{\\partial \\theta}\\right|_{op} \\delta\\theta + \\left.\\frac{\\partial \\tau_m}{\\partial \\omega}\\right|_{op} \\delta\\omega + \\left.\\frac{\\partial \\tau_m}{\\partial a}\\right|_{op} \\delta a\n$$\n其中偏导数在工作点 $(op)$，即 $(\\theta, \\omega, a) = (0, 0, 0)$ 处求值。此时，肌腱长度为 $\\ell = \\ell_{\\mathrm{opt}}$，其速度为 $v=0$。\n\n**2. 偏导数的计算**\n\n我们计算力矩 $\\tau_m = r F_m = r(F_{\\mathrm{active}} + F_{\\mathrm{passive}})$ 的每个偏导数。\n\n*   **关于激活度 $a$ 的导数**：\n    $$\n    \\frac{\\partial \\tau_m}{\\partial a} = r \\frac{\\partial}{\\partial a} \\left[ a F_{\\max} f_{\\ell}(\\ell) f_v(v) + F_{\\mathrm{passive}}(\\ell) \\right] = r F_{\\max} f_{\\ell}(\\ell) f_v(v)\n    $$\n    在工作点处求值，其中 $\\ell=\\ell_{\\mathrm{opt}}$ 且 $v=0$，我们利用性质 $f_{\\ell}(\\ell_{\\mathrm{opt}})=1$ 和 $f_v(0)=1$：\n    $$\n    \\left.\\frac{\\partial \\tau_m}{\\partial a}\\right|_{op} = r F_{\\max}\n    $$\n\n*   **关于角度 $\\theta$ 的导数（刚度项）**：使用链式法则，其中 $\\ell = \\ell_{\\mathrm{opt}} - r\\theta \\implies \\frac{d\\ell}{d\\theta} = -r$：\n    $$\n    \\frac{\\partial \\tau_m}{\\partial \\theta} = \\frac{\\partial \\tau_m}{\\partial \\ell} \\frac{d\\ell}{d\\theta} = -r \\frac{\\partial}{\\partial \\ell} \\left[ r \\left( a F_{\\max} f_{\\ell}(\\ell) f_v(v) + F_{\\mathrm{passive}}(\\ell) \\right) \\right] = -r^2 \\left( a F_{\\max} f'_{\\ell}(\\ell) f_v(v) + F'_{\\mathrm{passive}}(\\ell) \\right)\n    $$\n    在工作点处，$a=0$。力-长度曲线的导数 $f'_{\\ell}(\\ell_{opt})$ 为零，因为该曲线在 $\\ell=\\ell_{opt}$ 处达到峰值。被动力的导数 $F'_{\\mathrm{passive}}(\\ell_{opt})$ 也为零，因为函数 $F_{\\mathrm{passive}}(\\ell) \\propto \\max(0, \\ell/\\ell_{\\mathrm{opt}}-1)^2$ 在 $\\ell=\\ell_{\\mathrm{opt}}$ 处有最小值。因此：\n    $$\n    \\left.\\frac{\\partial \\tau_m}{\\partial \\theta}\\right|_{op} = 0\n    $$\n\n*   **关于角速度 $\\omega$ 的导数（阻尼项）**：使用链式法则，其中 $v = -r\\omega \\implies \\frac{dv}{d\\omega} = -r$：\n    $$\n    \\frac{\\partial \\tau_m}{\\partial \\omega} = \\frac{\\partial \\tau_m}{\\partial v} \\frac{dv}{d\\omega} = -r \\frac{\\partial}{\\partial v} \\left[ r \\left( a F_{\\max} f_{\\ell}(\\ell) f_v(v) + F_{\\mathrm{passive}}(\\ell) \\right) \\right] = -r^2 a F_{\\max} f_{\\ell}(\\ell) f'_{v}(v)\n    $$\n    在工作点 $a=0$ 处求值：\n    $$\n    \\left.\\frac{\\partial \\tau_m}{\\partial \\omega}\\right|_{op} = 0\n    $$\n\n**3. 线性化闭环动力学**\n\n将导数代入线性化力矩表达式得到：\n$$\n\\delta\\tau_m \\approx (r F_{\\max}) \\delta a\n$$\n线性化运动方程为 $J \\ddot{\\delta\\theta} = \\delta\\tau_m$。为分析响应，我们可以省略扰动符号 $\\delta$：\n$$\nJ \\ddot{\\theta} = r F_{\\max} a\n$$\n使用控制器 $u = K_p(\\theta_{\\mathrm{ref}} - \\theta) - K_d \\omega$ 和近似 $a=u$，我们得到闭环系统动力学：\n$$\nJ \\ddot{\\theta} = r F_{\\max} \\left( K_p(\\theta_{\\mathrm{ref}} - \\theta) - K_d \\dot{\\theta} \\right)\n$$\n将其整理成标准的二阶形式 $\\ddot{x} + 2\\zeta\\omega_n\\dot{x} + \\omega_n^2 x = \\omega_n^2 x_{\\mathrm{ref}}$：\n$$\nJ \\ddot{\\theta} + (r F_{\\max} K_d) \\dot{\\theta} + (r F_{\\max} K_p) \\theta = (r F_{\\max} K_p) \\theta_{\\mathrm{ref}}\n$$\n两边除以 $J$：\n$$\n\\ddot{\\theta} + \\left(\\frac{r F_{\\max} K_d}{J}\\right) \\dot{\\theta} + \\left(\\frac{r F_{\\max} K_p}{J}\\right) \\theta = \\left(\\frac{r F_{\\max} K_p}{J}\\right) \\theta_{\\mathrm{ref}}\n$$\n\n**4. 增益推导**\n\n通过将系数与标准二阶系统进行比较，我们确定：\n$$\n\\omega_n^2 = \\frac{r F_{\\max} K_p}{J}\n$$\n$$\n2\\zeta\\omega_n = \\frac{r F_{\\max} K_d}{J}\n$$\n为了在给定的目标自然频率 $\\omega_n$ 下实现临界阻尼（$\\zeta=1$），我们求解增益 $K_p$ 和 $K_d$：\n$$\nK_p = \\frac{J \\omega_n^2}{r F_{\\max}}\n$$\n$$\nK_d = \\frac{2 J \\omega_n}{r F_{\\max}}\n$$\n这些方程基于系统参数和设计规范提供了所需的控制器增益。\n\n### 第2部分：正向仿真与验证\n\n验证步骤涉及使用推导出的增益仿真完整的非线性系统，并计算阶跃响应的超调。\n\n**1. 非线性系统模型**\n\n系统的状态是向量 $y(t) = [\\theta(t), \\omega(t), a(t)]^T$。其动力学由一个包含三个耦合一阶常微分方程（ODEs）的系统描述：\n$$\n\\frac{d}{dt}y = \n\\begin{pmatrix} \\dot{\\theta} \\\\ \\dot{\\omega} \\\\ \\dot{a} \\end{pmatrix} = \n\\begin{pmatrix}\n\\omega \\\\\n\\frac{1}{J} \\tau_m(\\theta, \\omega, a) \\\\\n\\frac{u_{\\mathrm{sat}} - a}{T_a}\n\\end{pmatrix}\n$$\n其中：\n- 控制指令为 $u = K_p(\\theta_{\\mathrm{ref}} - \\theta) - K_d \\omega$。\n- 指令被饱和处理：$u_{\\mathrm{sat}} = \\mathrm{clip}(u, 0, 1)$。\n- 肌肉力矩 $\\tau_m = r(F_{\\mathrm{active}} + F_{\\mathrm{passive}})$ 使用问题陈述中提供的完整非线性希尔型模型计算，不采用为增益推导所作的简化假设。\n\n**2. 数值仿真与超调计算**\n\n对于每个测试用例，执行以下程序：\n1.  指定参数（$J, r, F_{\\max}, \\omega_n$ 等）。\n2.  使用推导出的公式计算增益 $K_p$ 和 $K_d$。\n3.  从初始状态 $y(0) = [0, 0, 0]^T$ 在时间区间 $[0, t_{\\mathrm{end}}]$（其中 $t_{\\mathrm{end}}=2.0\\mathrm{s}$）内对ODE系统进行数值积分。\n4.  分析得到的角度轨迹 $\\theta(t)$ 以计算超调分数。\n    - 达到的最大角度为 $\\theta_{\\max} = \\max_{t \\in [0, t_{\\mathrm{end}}]} \\theta(t)$。\n    - 最终角度 $\\theta_f$ 是仿真最后 $10\\%$（即 $t \\in [1.8, 2.0]$）内 $\\theta(t)$ 的平均值。\n    - 超调分数为 $\\mathrm{OS} = \\frac{\\theta_{\\max} - \\theta_f}{\\theta_f - \\theta(0)}$。由于初始角度 $\\theta(0)=0$，这简化为 $\\mathrm{OS} = (\\theta_{\\max} / \\theta_f) - 1$。\n5.  最终结果四舍五入到三位小数。\n\n此过程在以下Python代码中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the musculoskeletal control problem for all test cases.\n    Derives controller gains, runs a forward simulation, and computes overshoot.\n    \"\"\"\n\n    # J, r, F_max, T_a, l_opt, w, vmax_factor, k_v, k_pas, theta_step, omega_n\n    test_cases = [\n        # Case A: general case\n        (0.05, 0.03, 1500, 0.03, 0.10, 0.25, 10.0, 0.25, 0.03, 0.10, 10.0),\n        # Case B: slow activation boundary\n        (0.05, 0.03, 1500, 0.20, 0.10, 0.25, 10.0, 0.25, 0.03, 0.10, 10.0),\n        # Case C: small moment arm and lower strength edge\n        (0.05, 0.01, 800, 0.05, 0.10, 0.25, 10.0, 0.25, 0.03, 0.10, 10.0),\n        # Case D: larger inertia, lower target frequency\n        (0.10, 0.03, 2000, 0.03, 0.10, 0.25, 10.0, 0.25, 0.03, 0.15, 7.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        overshoot = run_simulation(params)\n        results.append(f\"{overshoot:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single forward dynamics simulation for a given parameter set.\n    \"\"\"\n    J, r, F_max, T_a, l_opt, w, vmax_factor, k_v, k_pas, theta_step, omega_n = params\n    v_max = vmax_factor * l_opt\n    \n    # 1. Derive controller gains Kp and Kd from first principles\n    # Based on the linearized model: J*theta_ddot + (r*F_max*Kd)*theta_dot + (r*F_max*Kp)*theta = ...\n    # Comparing to theta_ddot + 2*zeta*wn*theta_dot + wn^2*theta = ...\n    # wn^2 = (r*F_max*Kp)/J  => Kp = J*wn^2 / (r*F_max)\n    # 2*zeta*wn = (r*F_max*Kd)/J => Kd = 2*zeta*J*wn / (r*F_max)\n    # For critical damping, zeta = 1.\n    \n    r_F_max = r * F_max\n    Kp = (J * omega_n**2) / r_F_max\n    Kd = (2 * J * omega_n) / r_F_max\n\n    # 2. Define the nonlinear ODE system for forward simulation\n    def system_dynamics(t, y):\n        theta, omega, a = y\n        \n        # PD Controller\n        theta_ref = theta_step\n        u = Kp * (theta_ref - theta) - Kd * omega\n        # Saturate control command\n        u_sat = np.clip(u, 0.0, 1.0)\n\n        # Musculotendon kinematics\n        # l is muscle-tendon length, v is muscle-tendon velocity\n        l = l_opt - r * theta\n        v = -r * omega\n\n        # Hill-type muscle force calculation\n        # Force-length curve (f_l)\n        fl_exp_arg = -(((l - l_opt) / (w * l_opt))**2)\n        f_l = np.exp(fl_exp_arg)\n        \n        # Force-velocity curve (f_v)\n        fv_denom = v_max + k_v * v\n        # Prevent division by zero for extreme velocities, though unlikely with given params\n        f_v = (v_max - v) / fv_denom if abs(fv_denom) > 1e-9 else 0.0\n        \n        # Active force (F_active)\n        F_active = a * F_max * f_l * f_v\n        \n        # Passive force (F_passive)\n        passive_strain = np.maximum(0.0, (l / l_opt) - 1.0)\n        F_passive = F_max * k_pas * (passive_strain**2)\n\n        # Total muscle force and torque\n        F_m = F_active + F_passive\n        tau_m = r * F_m\n        \n        # State derivatives\n        d_theta_dt = omega\n        d_omega_dt = tau_m / J\n        d_a_dt = (u_sat - a) / T_a\n        \n        return [d_theta_dt, d_omega_dt, d_a_dt]\n\n    # 3. Perform numerical integration\n    t_end = 2.0\n    y0 = [0.0, 0.0, 0.0]  # Initial state: [theta, omega, a]\n    sol = solve_ivp(\n        system_dynamics,\n        [0, t_end],\n        y0,\n        dense_output=True,\n        rtol=1e-6,\n        atol=1e-9\n    )\n\n    # 4. Compute overshoot fraction\n    # Get angle trajectory from solution\n    t_points = sol.t\n    theta_traj = sol.y[0]\n    \n    # Find maximum angle\n    theta_max = np.max(theta_traj)\n    \n    # Calculate final steady-state angle (theta_f) from last 10% of simulation\n    t_avg_start = 0.9 * t_end\n    t_eval_avg = np.linspace(t_avg_start, t_end, num=100)\n    theta_avg_samples = sol.sol(t_eval_avg)[0]\n    theta_f = np.mean(theta_avg_samples)\n\n    # Calculate overshoot fraction OS = (theta_max - theta_f) / (theta_f - theta_0)\n    theta_0 = y0[0]\n    if abs(theta_f - theta_0)  1e-9:\n        overshoot = 0.0\n    else:\n        overshoot = (theta_max - theta_f) / (theta_f - theta_0)\n\n    return overshoot\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}