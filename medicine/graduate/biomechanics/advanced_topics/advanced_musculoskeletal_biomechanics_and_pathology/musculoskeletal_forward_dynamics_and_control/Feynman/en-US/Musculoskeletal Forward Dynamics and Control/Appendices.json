{
    "hands_on_practices": [
        {
            "introduction": "Forward dynamic simulations of movement are built upon the numerical integration of differential equations that describe the system's physics. This first practice drills down into a core component: the first-order ordinary differential equation (ODE) governing muscle activation. By deriving a discrete-time update rule and analyzing its numerical stability , you will gain hands-on experience with the crucial process of translating a continuous biological model into a computable algorithm and understanding the practical constraints, such as the maximum stable time step, that emerge from this process.",
            "id": "4193963",
            "problem": "A single-muscle activation state $a(t) \\in [0,1]$ evolves under first-order activation kinetics driven by a bounded neural control input $u(t) \\in [0,1]$. In widely used musculoskeletal models, the activation dynamics are represented by the ordinary differential equation (ODE)\n$$\n\\frac{d a(t)}{d t} = \\frac{u(t) - a(t)}{\\tau\\!\\left(u(t),a(t)\\right)},\n$$\nwhere the time constant $\\tau\\!\\left(u,a\\right)$ is piecewise defined by\n$$\n\\tau\\!\\left(u,a\\right) = \\begin{cases}\n\\tau_{\\text{act}}  \\text{if } u \\ge a, \\\\\n\\tau_{\\text{deact}}  \\text{if } u  a,\n\\end{cases}\n$$\nwith $\\tau_{\\text{act}}  0$ and $\\tau_{\\text{deact}}  0$. The activation state is sampled at uniform interval $\\Delta t  0$, and the input $u(t)$ is held constant over each sampling interval, that is, $u(t) = u_k$ for $t \\in [k \\Delta t, (k+1)\\Delta t)$ and integer $k \\ge 0$.\n\nStarting from the definition of the time derivative and the given ODE, construct a discrete-time update mapping $a_k \\mapsto a_{k+1}$ using the explicit Euler method. Then perform a linear stability analysis of the resulting discrete-time homogeneous error dynamics around the instantaneous steady state to obtain an inequality on $\\Delta t$ that guarantees stability for all admissible $\\tau$ in the piecewise definition. Finally, given $\\tau_{\\text{act}} = 12.3~\\text{ms}$ and $\\tau_{\\text{deact}} = 46.0~\\text{ms}$, compute the maximum stable sampling interval $\\Delta t_{\\max}$ (in milliseconds) that satisfies your stability condition. Express $\\Delta t_{\\max}$ in milliseconds and round your numerical answer to four significant figures.",
            "solution": "The problem statement is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- The activation state is $a(t) \\in [0,1]$.\n- The neural control input is $u(t) \\in [0,1]$.\n- The governing ordinary differential equation (ODE) for activation dynamics is:\n$$\n\\frac{d a(t)}{d t} = \\frac{u(t) - a(t)}{\\tau\\!\\left(u(t),a(t)\\right)}\n$$\n- The piecewise time constant $\\tau\\!\\left(u,a\\right)$ is defined as:\n$$\n\\tau\\!\\left(u,a\\right) = \\begin{cases}\n\\tau_{\\text{act}}  \\text{if } u \\ge a, \\\\\n\\tau_{\\text{deact}}  \\text{if } u  a,\n\\end{cases}\n$$\n- The constant parameters satisfy $\\tau_{\\text{act}}  0$ and $\\tau_{\\text{deact}}  0$.\n- The activation state is sampled at a uniform interval $\\Delta t  0$.\n- The input $u(t)$ is a piecewise constant function: $u(t) = u_k$ for $t \\in [k \\Delta t, (k+1)\\Delta t)$ and integer $k \\ge 0$.\n- Specific values for the time constants are given as $\\tau_{\\text{act}} = 12.3~\\text{ms}$ and $\\tau_{\\text{deact}} = 46.0~\\text{ms}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded:** The first-order ODE model for muscle activation dynamics is a standard and widely accepted model in the field of biomechanics and musculoskeletal modeling, often attributed to the work of Zajac (1989). The values provided for activation and deactivation time constants are physiologically plausible.\n- **Well-Posed:** The problem provides all necessary information to proceed. It asks for the derivation of a discrete-time update, a linear stability analysis, and the calculation of a maximum stable step size. These are standard, well-defined tasks in numerical analysis applied to dynamical systems. The data is self-contained and consistent.\n- **Objective:** The problem is phrased using precise, standard scientific terminology and is free of subjective or ambiguous language.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. The solution process will now proceed.\n\n### Solution Derivation\nThe solution is constructed in three parts as requested: deriving the discrete-time update, performing the stability analysis, and computing the maximum stable sampling interval.\n\n**1. Construct the Discrete-Time Update Mapping**\nThe explicit (or forward) Euler method is used to discretize the given ODE. For a general first-order ODE of the form $\\frac{dy}{dt} = f(t,y)$, the explicit Euler update rule is $y_{k+1} = y_k + \\Delta t \\cdot f(t_k, y_k)$.\n\nIn this problem, $y(t)$ corresponds to the activation state $a(t)$, so $y_k = a(k \\Delta t) \\equiv a_k$. The function $f(t,y)$ is given by the right-hand side of the activation dynamics ODE. Over the interval $[k\\Delta t, (k+1)\\Delta t)$, the input $u(t)$ is constant at $u_k$, and we approximate the state $a(t)$ by $a_k$. The time constant $\\tau$ also depends on $u$ and $a$, so we evaluate it at time step $k$: $\\tau_k = \\tau(u_k, a_k)$.\n\nThe function $f$ at step $k$ is:\n$$\nf(k\\Delta t, a_k) = \\frac{u_k - a_k}{\\tau(u_k, a_k)} = \\frac{u_k - a_k}{\\tau_k}\n$$\nApplying the explicit Euler formula, we get the discrete-time update mapping $a_k \\mapsto a_{k+1}$:\n$$\na_{k+1} = a_k + \\Delta t \\left( \\frac{u_k - a_k}{\\tau_k} \\right)\n$$\nThis equation can be rearranged to show the dependence of $a_{k+1}$ on $a_k$ and $u_k$:\n$$\na_{k+1} = a_k - \\frac{\\Delta t}{\\tau_k} a_k + \\frac{\\Delta t}{\\tau_k} u_k = \\left(1 - \\frac{\\Delta t}{\\tau_k}\\right)a_k + \\left(\\frac{\\Delta t}{\\tau_k}\\right)u_k\n$$\nThis is the required discrete-time update mapping.\n\n**2. Perform Linear Stability Analysis**\nThe stability analysis is performed on the homogeneous error dynamics. The error is defined with respect to the instantaneous steady state. For a constant input $u_k$, the steady state activation $a_{ss}$ is the value of $a$ for which $\\frac{da}{dt} = 0$. From the ODE, this implies $u_k - a_{ss} = 0$, so $a_{ss} = u_k$.\n\nThe error at time step $k$ is defined as $e_k = a_k - a_{ss} = a_k - u_k$.\nThe error at the next time step, $k+1$, is $e_{k+1} = a_{k+1} - a_{ss} = a_{k+1} - u_k$.\n\nWe substitute the expression for $a_{k+1}$ from the update rule into the equation for $e_{k+1}$:\n$$\ne_{k+1} = \\left[ \\left(1 - \\frac{\\Delta t}{\\tau_k}\\right)a_k + \\left(\\frac{\\Delta t}{\\tau_k}\\right)u_k \\right] - u_k\n$$\nCombining the terms with $u_k$:\n$$\ne_{k+1} = \\left(1 - \\frac{\\Delta t}{\\tau_k}\\right)a_k + \\left(\\frac{\\Delta t}{\\tau_k} - 1\\right)u_k\n$$\nFactoring out the common term $(1 - \\frac{\\Delta t}{\\tau_k})$:\n$$\ne_{k+1} = \\left(1 - \\frac{\\Delta t}{\\tau_k}\\right)(a_k - u_k)\n$$\nBy definition, $e_k = a_k - u_k$, so we obtain the homogeneous error dynamics:\n$$\ne_{k+1} = \\left(1 - \\frac{\\Delta t}{\\tau_k}\\right)e_k\n$$\nThis is a first-order linear discrete-time system. For the system to be stable, the error must decay to zero over time, which requires the magnitude of the amplification factor (the eigenvalue of the system matrix, which is a scalar here) to be strictly less than $1$:\n$$\n\\left| 1 - \\frac{\\Delta t}{\\tau_k} \\right|  1\n$$\nThis inequality is equivalent to the double inequality:\n$$\n-1  1 - \\frac{\\Delta t}{\\tau_k}  1\n$$\nWe analyze the two parts separately:\n1.  The right-hand inequality: $1 - \\frac{\\Delta t}{\\tau_k}  1 \\implies -\\frac{\\Delta t}{\\tau_k}  0$. Since $\\Delta t  0$ and $\\tau_k$ (which can be $\\tau_{\\text{act}}$ or $\\tau_{\\text{deact}}$) is also positive, this condition is always met.\n2.  The left-hand inequality: $-1  1 - \\frac{\\Delta t}{\\tau_k} \\implies \\frac{\\Delta t}{\\tau_k}  2 \\implies \\Delta t  2\\tau_k$.\n\nThus, the condition for numerical stability of the explicit Euler integration for this system is $\\Delta t  2\\tau_k$.\n\nThis stability condition must hold for any admissible value of the time constant $\\tau$. The time constant $\\tau_k$ can be either $\\tau_{\\text{act}}$ or $\\tau_{\\text{deact}}$ depending on the values of $u_k$ and $a_k$. To guarantee stability in all cases, $\\Delta t$ must be chosen to satisfy the most restrictive condition. The inequality $\\Delta t  2\\tau$ is more restrictive (imposes a smaller upper bound on $\\Delta t$) for smaller values of $\\tau$. Therefore, we must satisfy the condition for the minimum possible value of $\\tau$:\n$$\n\\Delta t  2 \\min(\\tau_{\\text{act}}, \\tau_{\\text{deact}})\n$$\nThis is the inequality that guarantees stability for all admissible $\\tau$.\n\n**3. Compute the Maximum Stable Sampling Interval**\nThe maximum stable sampling interval, $\\Delta t_{\\max}$, is the supremum of the set of stable $\\Delta t$, which corresponds to the upper boundary of the stability region:\n$$\n\\Delta t_{\\max} = 2 \\min(\\tau_{\\text{act}}, \\tau_{\\text{deact}})\n$$\nWe are given the numerical values $\\tau_{\\text{act}} = 12.3~\\text{ms}$ and $\\tau_{\\text{deact}} = 46.0~\\text{ms}$.\nFirst, we find the minimum of these two values:\n$$\n\\min(\\tau_{\\text{act}}, \\tau_{\\text{deact}}) = \\min(12.3, 46.0)~\\text{ms} = 12.3~\\text{ms}\n$$\nNow, we can compute $\\Delta t_{\\max}$:\n$$\n\\Delta t_{\\max} = 2 \\times 12.3~\\text{ms} = 24.6~\\text{ms}\n$$\nThe problem requires the answer to be rounded to four significant figures.\n$$\n\\Delta t_{\\max} = 24.60~\\text{ms}\n$$",
            "answer": "$$\\boxed{24.60}$$"
        },
        {
            "introduction": "Building from the dynamics of a single component, we now scale up to model a multi-muscle system in a static configuration. This practice requires you to compute the net joint torque by integrating several key biomechanical concepts from first principles, including complex muscle-tendon paths with via-points, pennation architecture, and the force equilibrium between a contractile element and a series elastic tendon. Successfully completing this task  demonstrates a comprehensive understanding of how to construct and solve a static musculoskeletal model, which is the foundation for analyzing posture and the potential for movement.",
            "id": "4193925",
            "problem": "Consider a planar single-degree-of-freedom joint rotating about the $z$-axis, with a static posture defined by a joint angle $\\theta$ in radians. Two muscles cross the joint: a flexor and an extensor. Each muscle has a multi-segment path defined by three via-points, with one distal via-point rigidly attached to the distal segment and rotating with the joint. The proximal via-points are rigidly attached to the proximal segment and do not rotate with the joint. The muscle-tendon path length for each muscle is the sum of Euclidean distances between consecutive via-points. Under static conditions (zero joint angular acceleration), the net muscle torque about the joint arises from the sum of muscle tendon forces multiplied by their moment arms. Your task is to compute the net muscle torque at specified postures for given muscle activations and tendon stiffnesses, incorporating pennation and multiple via-points for each muscle, using fundamental laws and core definitions without presupposing specialized shortcut formulas.\n\nFundamental base: The problem must be derived from first principles, specifically:\n- Newton's Second Law for rotation: the net moment about a joint equals the sum of individual moments, and under static conditions, the net joint torque can be computed by summing the contributions of each muscle force projected by its moment arm.\n- Kinematics of rigid rotation in a plane: the distal via-point position transforms by a rotation matrix about the joint center.\n- Geometric definitions: muscle-tendon path length equals the sum of Euclidean segment lengths between via-points.\n- Series elastic muscle model: a muscle fiber in series with a tendon enforces an equilibrium of forces and a geometric constraint relating muscle-tendon length, tendon length, and fiber length projected by pennation.\n\nDefinitions and modeling assumptions to be used:\n1. Let the muscle-tendon length be $L_{\\mathrm{mt}}(\\theta)$ computed from via-point geometry at angle $\\theta$.\n2. Let the tendon length be $L_{\\mathrm{t}}$ and the muscle fiber length be $L_{\\mathrm{f}}$.\n3. Let the pennation angle be $\\alpha(L_{\\mathrm{f}})$, modeled with constant volume assumption as $\\alpha(L_{\\mathrm{f}}) = \\arcsin\\!\\left(\\min\\left( \\sin(\\alpha_0)\\,\\frac{L_{\\mathrm{opt}}}{L_{\\mathrm{f}}},\\,0.999\\right)\\right)$, where $\\alpha_0$ is the pennation at optimal fiber length $L_{\\mathrm{opt}}$.\n4. Geometric constraint: $L_{\\mathrm{mt}}(\\theta) = L_{\\mathrm{t}} + L_{\\mathrm{f}}\\cos\\!\\big(\\alpha(L_{\\mathrm{f}})\\big)$.\n5. Tendon force: $F_{\\mathrm{t}} = k \\,\\max\\!\\big(0,\\, L_{\\mathrm{t}} - L_{\\mathrm{ts}}\\big)$, where $k$ is tendon stiffness and $L_{\\mathrm{ts}}$ is tendon slack length.\n6. Muscle fiber active force-length (normalized): $f_{\\mathrm{L}}(L_{\\mathrm{f}}) = \\exp\\!\\left(-\\frac{(L_{\\mathrm{f}} - L_{\\mathrm{opt}})^2}{w^2}\\right)$, with width parameter $w$.\n7. Muscle fiber passive force: $F_{\\mathrm{p}}(L_{\\mathrm{f}}) = F_{\\mathrm{max}}\\,p_{\\mathrm{scale}}\\,\\max\\!\\big(0,\\,\\exp\\!\\big(p_k\\big(\\frac{L_{\\mathrm{f}}}{L_{\\mathrm{opt}}}-1\\big)\\big) - 1\\big)$.\n8. Muscle fiber total force: $F_{\\mathrm{f}}(L_{\\mathrm{f}}) = a\\,F_{\\mathrm{max}}\\,f_{\\mathrm{L}}(L_{\\mathrm{f}}) + F_{\\mathrm{p}}(L_{\\mathrm{f}})$, where $a$ is activation ($0 \\le a \\le 1$).\n9. Series equilibrium: $F_{\\mathrm{t}} = F_{\\mathrm{f}}(L_{\\mathrm{f}})\\cos\\!\\big(\\alpha(L_{\\mathrm{f}})\\big)$ using the projection from muscle fiber to tendon along the line of action.\n\nMoment arm computation:\n- The muscle moment arm $r(\\theta)$ about the $z$-axis is defined as $r(\\theta) = -\\frac{dL_{\\mathrm{mt}}}{d\\theta}$ obtained by differentiating the path length with respect to the joint angle $\\theta$. Use a numerically stable symmetric finite difference with a small perturbation $\\Delta\\theta$ to estimate the derivative.\n\nJoint torque:\n- For each muscle, compute the tendon force $F_{\\mathrm{t}}$ via equilibrium and geometry, and then compute the joint torque contribution $\\tau_i(\\theta) = r_i(\\theta) F_{\\mathrm{t},i}$, where subscript $i$ indexes the muscle. The net joint torque is $\\tau(\\theta) = \\sum_i \\tau_i(\\theta)$.\n- Express joint torque in Newton-meters ($\\mathrm{N\\cdot m}$).\n\nGeometry and parameters:\n- The joint center is at the origin. The distal segment rotates in the $x$–$y$ plane about the $z$-axis. Use the rotation matrix\n$$\nR_z(\\theta) = \\begin{bmatrix}\n\\cos\\theta  -\\sin\\theta  0 \\\\\n\\sin\\theta  \\cos\\theta  0 \\\\\n0  0  1\n\\end{bmatrix}.\n$$\n- Define the flexor muscle via-points as three points: proximal attachment $P_{\\mathrm{prox},f} = [-0.05,\\,0.15,\\,0]$, proximal via $P_{\\mathrm{via},f} = [-0.02,\\,0.03,\\,0]$, distal via $P_{\\mathrm{dist},f} = [0.18,\\,0.02,\\,0]$ that rotates as $R_z(\\theta) P_{\\mathrm{dist},f}$.\n- Define the extensor muscle via-points as three points: proximal attachment $P_{\\mathrm{prox},e} = [-0.06,\\,-0.16,\\,0]$, proximal via $P_{\\mathrm{via},e} = [-0.02,\\,-0.03,\\,0]$, distal via $P_{\\mathrm{dist},e} = [0.17,\\,-0.03,\\,0]$ that rotates as $R_z(\\theta) P_{\\mathrm{dist},e}$.\n- Muscle parameters:\n  - Flexor: $F_{\\mathrm{max}} = 900$, $L_{\\mathrm{opt}} = 0.11$, $\\alpha_0 = 0.261799$ (which is $15$ degrees in radians), $L_{\\mathrm{ts}} = 0.20$.\n  - Extensor: $F_{\\mathrm{max}} = 700$, $L_{\\mathrm{opt}} = 0.10$, $\\alpha_0 = 0.20944$ (which is $12$ degrees in radians), $L_{\\mathrm{ts}} = 0.19$.\n- Force-length shape parameters (shared by both muscles): $w = 0.25\\,L_{\\mathrm{opt}}$ for the respective muscle, $p_{\\mathrm{scale}} = 0.01$, $p_k = 4$.\n- Use the numerical finite difference step $\\Delta\\theta = 10^{-6}$ radians for moment arm calculation.\n\nTask:\n- For each test case below, compute the net muscle torque $\\tau(\\theta)$ in $\\mathrm{N\\cdot m}$ using the above definitions and modeling assumptions. Use a robust one-dimensional root-finding method to solve the equilibrium for $L_{\\mathrm{f}}$ per muscle in the admissible interval $L_{\\mathrm{f}} \\in [0.5\\,L_{\\mathrm{opt}},\\,1.8\\,L_{\\mathrm{opt}}]$, and if a strict sign-changing bracket is not found, select the $L_{\\mathrm{f}}$ in this interval that minimizes the absolute equilibrium residual.\n\nTest Suite:\n- Test case $1$: $\\theta = 1.0$; flexor activation $a_f = 0.4$; extensor activation $a_e = 0.1$; flexor tendon stiffness $k_f = 12000$; extensor tendon stiffness $k_e = 10000$.\n- Test case $2$ (edge case: extensor slack possibility): $\\theta = 1.4$; $a_f = 0.05$; $a_e = 0.0$; $k_f = 20000$; $k_e = 20000$.\n- Test case $3$ (boundary: high activation, soft tendon): $\\theta = 0.5$; $a_f = 0.9$; $a_e = 0.2$; $k_f = 5000$; $k_e = 8000$.\n\nAnswer specification:\n- For each test case, output a single floating-point number representing the net joint torque $\\tau(\\theta)$ in $\\mathrm{N\\cdot m}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[x_1,x_2,x_3]$, where each $x_i$ corresponds to the torque of test case $i$. Angles must be interpreted in radians. The torques must be in $\\mathrm{N\\cdot m}$. No additional text should be printed.",
            "solution": "The problem is assessed as valid because it is scientifically grounded in established principles of musculoskeletal biomechanics, well-posed with all necessary parameters and definitions, and stated objectively. The model, while a simplification of biological reality, is internally consistent and does not violate fundamental laws of physics or mathematics. The task is a standard computational exercise in the field of biomechanics and is fully specified.\n\nThe solution proceeds by first establishing the kinematic and dynamic models for each muscle, then describing the numerical procedure to solve for the muscle's internal state, and finally combining the results to compute the net joint torque.\n\n### 1. Kinematic Model: Muscle-Tendon Path Length ($L_{\\mathrm{mt}}$)\nFor a given muscle $i$ (flexor or extensor), the musculoskeletal geometry consists of three via-points: a proximal attachment $P_{\\mathrm{prox},i}$, a proximal via-point $P_{\\mathrm{via},i}$, and a distal via-point $P_{\\mathrm{dist},i}$. The proximal points are fixed, while the distal point is attached to the rotating segment. At a joint angle $\\theta$, the position of the distal via-point in the global frame, $P'_{\\mathrm{dist},i}(\\theta)$, is calculated by applying the specified rotation matrix $R_z(\\theta)$ to its local coordinates:\n$$\nP'_{\\mathrm{dist},i}(\\theta) = R_z(\\theta) P_{\\mathrm{dist},i} =\n\\begin{bmatrix}\n\\cos\\theta  -\\sin\\theta  0 \\\\\n\\sin\\theta  \\cos\\theta  0 \\\\\n0  0  1\n\\end{bmatrix}\nP_{\\mathrm{dist},i}\n$$\nThe total muscle-tendon path length, $L_{\\mathrm{mt},i}(\\theta)$, is the sum of the Euclidean distances between consecutive points along this path:\n$$\nL_{\\mathrm{mt},i}(\\theta) = \\| P_{\\mathrm{via},i} - P_{\\mathrm{prox},i} \\|_2 + \\| P'_{\\mathrm{dist},i}(\\theta) - P_{\\mathrm{via},i} \\|_2\n$$\nwhere $\\| \\cdot \\|_2$ denotes the Euclidean norm.\n\n### 2. Moment Arm Calculation ($r$)\nThe moment arm $r_i(\\theta)$ for muscle $i$ is defined as the negative partial derivative of the muscle-tendon path length with respect to the joint angle $\\theta$. This quantity represents the effectiveness of the muscle force in producing a torque about the joint axis.\n$$\nr_i(\\theta) = -\\frac{\\partial L_{\\mathrm{mt},i}}{\\partial \\theta}\n$$\nA positive moment arm typically corresponds to a flexor, and a negative moment arm to an extensor. We estimate this derivative numerically using a second-order symmetric finite difference formula with a small perturbation $\\Delta\\theta = 10^{-6}$ radians, as specified:\n$$\nr_i(\\theta) \\approx -\\frac{L_{\\mathrm{mt},i}(\\theta + \\Delta\\theta) - L_{\\mathrm{mt},i}(\\theta - \\Delta\\theta)}{2 \\Delta\\theta}\n$$\n\n### 3. Muscle-Tendon Unit Model\nThe model for each muscle comprises a contractile muscle fiber element in series with a passive elastic tendon element. The state of this system is governed by a set of coupled geometric and force equations.\n\n- **Pennation Angle $\\alpha(L_{\\mathrm{f}})$:** The angle between the muscle fibers and the tendon's line of action, $\\alpha$, depends on the fiber length $L_{\\mathrm{f}}$. Assuming constant muscle volume, this relationship is given by:\n  $$\n  \\alpha(L_{\\mathrm{f}}) = \\arcsin\\left(\\min\\left( \\sin(\\alpha_0)\\,\\frac{L_{\\mathrm{opt}}}{L_{\\mathrm{f}}},\\,0.999\\right)\\right)\n  $$\n  where $\\alpha_0$ is the pennation angle at optimal fiber length $L_{\\mathrm{opt}}$. The clipping to a value of $0.999$ ensures the argument to the inverse sine function remains within its valid domain $[-1, 1]$.\n\n- **Geometric Constraint:** The total path length $L_{\\mathrm{mt}}$ is partitioned between the tendon length $L_{\\mathrm{t}}$ and the projected length of the muscle fiber along the tendon axis.\n  $$\n  L_{\\mathrm{mt}}(\\theta) = L_{\\mathrm{t}} + L_{\\mathrm{f}}\\cos\\big(\\alpha(L_{\\mathrm{f}})\\big)\n  $$\n\n- **Force Equations:** The forces generated by the tendon and the muscle fiber are functions of their respective lengths.\n  - **Tendon Force ($F_{\\mathrm{t}}$):** Modeled as a linear spring with stiffness $k$ that engages only when the tendon is stretched beyond its slack length $L_{\\mathrm{ts}}$.\n    $$\n    F_{\\mathrm{t}} = k \\,\\max\\!\\big(0,\\, L_{\\mathrm{t}} - L_{\\mathrm{ts}}\\big)\n    $$\n    By substituting $L_{\\mathrm{t}}$ from the geometric constraint, $F_{\\mathrm{t}}$ can be expressed as a function of $L_{\\mathrm{f}}$ and $\\theta$:\n    $$\n    F_{\\mathrm{t}}(L_{\\mathrm{f}}; \\theta, k) = k \\,\\max\\!\\left(0,\\, L_{\\mathrm{mt}}(\\theta) - L_{\\mathrm{f}}\\cos\\big(\\alpha(L_{\\mathrm{f}})\\big) - L_{\\mathrm{ts}}\\right)\n    $$\n  - **Muscle Fiber Force ($F_{\\mathrm{f}}$):** The total fiber force is the sum of an active component, scaled by activation $a \\in [0, 1]$, and a passive component.\n    $$\n    F_{\\mathrm{f}}(L_{\\mathrm{f}}; a) = a\\,F_{\\mathrm{max}}\\,f_{\\mathrm{L}}(L_{\\mathrm{f}}) + F_{\\mathrm{p}}(L_{\\mathrm{f}})\n    $$\n    The components are defined as:\n    - Active force-length multiplier: $f_{\\mathrm{L}}(L_{\\mathrm{f}}) = \\exp\\!\\left(-\\frac{(L_{\\mathrm{f}} - L_{\\mathrm{opt}})^2}{w^2}\\right)$, with width $w = 0.25\\,L_{\\mathrm{opt}}$.\n    - Passive force: $F_{\\mathrm{p}}(L_{\\mathrm{f}}) = F_{\\mathrm{max}}\\,p_{\\mathrm{scale}}\\,\\max\\!\\big(0,\\,\\exp\\!\\big(p_k\\big(\\frac{L_{\\mathrm{f}}}{L_{\\mathrm{opt}}}-1\\big)\\big) - 1\\big)$, with $p_{\\mathrm{scale}} = 0.01$ and $p_k = 4$.\n\n### 4. Static Equilibrium\nFor a static posture, the tendon force must balance the projected muscle fiber force.\n$$\nF_{\\mathrm{t}} = F_{\\mathrm{f}}(L_{\\mathrm{f}})\\cos\\big(\\alpha(L_{\\mathrm{f}})\\big)\n$$\nTo solve for the system's state, we must find the fiber length $L_{\\mathrm{f}}$ that satisfies this equilibrium for a given $\\theta$, activation $a$, and stiffness $k$. This is achieved by finding the root of the residual function $E(L_{\\mathrm{f}})$:\n$$\nE(L_{\\mathrm{f}}) = F_{\\mathrm{t}}(L_{\\mathrm{f}}; \\theta, k) - F_{\\mathrm{f}}(L_{\\mathrm{f}}; a) \\cos\\big(\\alpha(L_{\\mathrm{f}})\\big) = 0\n$$\n\n### 5. Numerical Solution for Fiber Length\nThe problem specifies solving for $L_{\\mathrm{f}}$ within the search interval $[0.5\\,L_{\\mathrm{opt}},\\,1.8\\,L_{\\mathrm{opt}}]$. A robust numerical procedure is employed:\n1.  A root-finding algorithm (specifically, Brent's method) is first attempted on the interval. This method is efficient and guaranteed to converge if the function values at the endpoints, $E(0.5\\,L_{\\mathrm{opt}})$ and $E(1.8\\,L_{\\mathrm{opt}})$, have opposite signs.\n2.  If a sign-changing bracket is not found, the problem instructs to find the $L_{\\mathrm{f}}$ that minimizes the absolute equilibrium residual, $|E(L_{\\mathrm{f}})|$. This is handled by a bounded scalar optimization routine, which finds the point of \"closest equilibrium\" within the allowed range.\n\nOnce the equilibrium fiber length, $L_{\\mathrm{f}}^*$, is determined, the corresponding tendon force, $F_{\\mathrm{t}}$, is calculated.\n\n### 6. Net Joint Torque\nThe torque contribution, $\\tau_i$, from each muscle $i$ is the product of its moment arm and tendon force:\n$$\n\\tau_i(\\theta) = r_i(\\theta) F_{\\mathrm{t},i}\n$$\nThe total net muscle torque about the joint, $\\tau(\\theta)$, is the algebraic sum of the torques from the flexor and extensor muscles:\n$$\n\\tau(\\theta) = \\tau_{\\text{flexor}}(\\theta) + \\tau_{\\text{extensor}}(\\theta)\n$$\nThis procedure is applied to each test case to compute the final required torque values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq, minimize_scalar\n\ndef solve():\n    \"\"\"\n    Solves the musculoskeletal forward dynamics problem for a single-joint system.\n    \"\"\"\n\n    class Muscle:\n        \"\"\"\n        Represents a single pennate muscle with a series elastic tendon.\n        \"\"\"\n        def __init__(\n            self, F_max, L_opt, alpha_0, L_ts, p_scale, p_k,\n            P_prox, P_via, P_dist_local\n        ):\n            self.F_max = F_max\n            self.L_opt = L_opt\n            self.alpha_0 = alpha_0\n            self.L_ts = L_ts\n            self.p_scale = p_scale\n            self.p_k = p_k\n            self.w = 0.25 * L_opt\n\n            self.P_prox = np.array(P_prox)\n            self.P_via = np.array(P_via)\n            self.P_dist_local = np.array(P_dist_local)\n\n        @staticmethod\n        def _rotate_point(theta, point):\n            c, s = np.cos(theta), np.sin(theta)\n            R_z = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n            return R_z @ point\n\n        def get_Lmt(self, theta):\n            P_dist_rotated = self._rotate_point(theta, self.P_dist_local)\n            seg1_len = np.linalg.norm(self.P_via - self.P_prox)\n            seg2_len = np.linalg.norm(P_dist_rotated - self.P_via)\n            return seg1_len + seg2_len\n\n        def get_moment_arm(self, theta, delta_theta):\n            Lmt_plus = self.get_Lmt(theta + delta_theta)\n            Lmt_minus = self.get_Lmt(theta - delta_theta)\n            return -(Lmt_plus - Lmt_minus) / (2 * delta_theta)\n\n        def _get_alpha(self, L_f):\n            # Clip argument to arcsin to avoid domain errors, as per problem spec\n            arg_asin = min(np.sin(self.alpha_0) * self.L_opt / L_f, 0.999)\n            return np.arcsin(arg_asin)\n\n        def _equilibrium_residual(self, L_f, L_mt, a, k):\n            # Pennation\n            alpha = self._get_alpha(L_f)\n            cos_alpha = np.cos(alpha)\n\n            # Tendon force\n            L_t = L_mt - L_f * cos_alpha\n            F_t = k * max(0, L_t - self.L_ts)\n\n            # Fiber force\n            # Active\n            f_L = np.exp(-((L_f - self.L_opt) / self.w)**2)\n            # Passive\n            f_passive_term = np.exp(self.p_k * (L_f / self.L_opt - 1)) - 1\n            F_p = self.F_max * self.p_scale * max(0, f_passive_term)\n            \n            F_f = a * self.F_max * f_L + F_p\n\n            return F_t - F_f * cos_alpha\n        \n        def solve_equilibrium(self, L_mt, a, k):\n            L_f_min, L_f_max = 0.5 * self.L_opt, 1.8 * self.L_opt\n            args = (L_mt, a, k)\n            \n            try:\n                res_min = self._equilibrium_residual(L_f_min, *args)\n                res_max = self._equilibrium_residual(L_f_max, *args)\n                if np.sign(res_min) != np.sign(res_max):\n                    L_f_eq = brentq(self._equilibrium_residual, L_f_min, L_f_max, args=args)\n                else:\n                    # Fallback to minimization if no sign change\n                    def objective(L_f, L_mt, a, k):\n                        return abs(self._equilibrium_residual(L_f, L_mt, a, k))\n                    res = minimize_scalar(objective, bounds=(L_f_min, L_f_max), args=args, method='bounded')\n                    L_f_eq = res.x\n            except (ValueError, RuntimeError):\n                # General fallback to minimization\n                def objective(L_f, L_mt, a, k):\n                    return abs(self._equilibrium_residual(L_f, L_mt, a, k))\n                res = minimize_scalar(objective, bounds=(L_f_min, L_f_max), args=args, method='bounded')\n                L_f_eq = res.x\n            \n            return L_f_eq\n\n        def get_tendon_force(self, L_f, L_mt, k):\n            alpha = self._get_alpha(L_f)\n            cos_alpha = np.cos(alpha)\n            L_t = L_mt - L_f * cos_alpha\n            return k * max(0, L_t - self.L_ts)\n\n        def calculate_torque_contribution(self, theta, a, k, delta_theta):\n            L_mt = self.get_Lmt(theta)\n            r = self.get_moment_arm(theta, delta_theta)\n            \n            if L_mt = 0: return 0.0\n\n            L_f_eq = self.solve_equilibrium(L_mt, a, k)\n            F_t = self.get_tendon_force(L_f_eq, L_mt, k)\n            \n            return r * F_t\n\n    # Define shared parameters\n    p_scale = 0.01\n    p_k = 4.0\n    delta_theta = 1e-6\n\n    # Define flexor muscle\n    flexor = Muscle(\n        F_max=900, L_opt=0.11, alpha_0=0.261799, L_ts=0.20,\n        p_scale=p_scale, p_k=p_k,\n        P_prox=[-0.05, 0.15, 0],\n        P_via=[-0.02, 0.03, 0],\n        P_dist_local=[0.18, 0.02, 0]\n    )\n\n    # Define extensor muscle\n    extensor = Muscle(\n        F_max=700, L_opt=0.10, alpha_0=0.20944, L_ts=0.19,\n        p_scale=p_scale, p_k=p_k,\n        P_prox=[-0.06, -0.16, 0],\n        P_via=[-0.02, -0.03, 0],\n        P_dist_local=[0.17, -0.03, 0]\n    )\n\n    # Test suite\n    test_cases = [\n        # (theta, a_f, a_e, k_f, k_e)\n        (1.0, 0.4, 0.1, 12000, 10000),\n        (1.4, 0.05, 0.0, 20000, 20000),\n        (0.5, 0.9, 0.2, 5000, 8000),\n    ]\n\n    results = []\n    for theta, a_f, a_e, k_f, k_e in test_cases:\n        tau_flexor = flexor.calculate_torque_contribution(theta, a_f, k_f, delta_theta)\n        tau_extensor = extensor.calculate_torque_contribution(theta, a_e, k_e, delta_theta)\n        net_torque = tau_flexor + tau_extensor\n        results.append(net_torque)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\n# Run the solver\nsolve()\n```"
        },
        {
            "introduction": "The ultimate goal of forward dynamics is often to understand control, bridging the gap between neural commands and observable motion. This final practice encapsulates the complete design-and-validate workflow of a neuromuscular controller, where you will first linearize a nonlinear Hill-type muscle model to design a Proportional-Derivative (PD) controller that achieves a target performance. You will then implement this controller in a full forward simulation of the nonlinear system to test its real-world efficacy , a process that provides deep insight into the practical application and limitations of linear control theory in complex biomechanical systems.",
            "id": "4193974",
            "problem": "A single-degree-of-freedom (DOF) rotational joint is actuated by a single Hill-type muscle with a constant moment arm. The objective is to design proportional-derivative gains that achieve critical damping in the joint’s step response about a specified operating point and validate the design via forward simulation. The derivation and implementation must start from fundamental mechanics and well-tested musculotendon physiology and must avoid shortcut formulas, proceeding from first principles to the final design.\n\nAssume the joint obeys Newton’s Second Law for rotation. Let $J$ denote the rotational inertia (in $\\mathrm{kg\\cdot m^2}$), $\\theta$ denote the joint angle (in $\\mathrm{rad}$), and $\\omega = d\\theta/dt$ denote the joint angular velocity (in $\\mathrm{rad/s}$). The rotational dynamics are\n$$\nJ \\,\\frac{d\\omega}{dt} = \\tau_m,\n$$\nwith kinematics\n$$\n\\frac{d\\theta}{dt} = \\omega,\n$$\nand zero external torques aside from those generated by the muscle. The muscle torque is modeled as\n$$\n\\tau_m = r\\,F_m(\\ell, v, a),\n$$\nwhere $r$ is the constant muscle moment arm (in $\\mathrm{m}$), $F_m$ is the muscle force (in $\\mathrm{N}$), $\\ell$ is the muscle-tendon length (in $\\mathrm{m}$), $v$ is the muscle-tendon velocity (in $\\mathrm{m/s}$), and $a$ is the muscle activation (dimensionless in $[0,1]$). Let $\\ell_{\\mathrm{opt}}$ denote the optimal muscle fiber length such that the operating point is at $\\theta = 0$ and $\\ell = \\ell_{\\mathrm{opt}}$. Use the affine mapping\n$$\n\\ell(\\theta) = \\ell_{\\mathrm{opt}} - r\\,\\theta, \\quad v(\\theta,\\omega) = -r\\,\\omega.\n$$\n\nThe Hill-type muscle force is composed of active and passive contributions,\n$$\nF_m(\\ell, v, a) = F_{\\mathrm{active}}(\\ell, v, a) + F_{\\mathrm{passive}}(\\ell),\n$$\nwith the active force defined by\n$$\nF_{\\mathrm{active}}(\\ell, v, a) = a\\,F_{\\max}\\,f_{\\ell}(\\ell)\\,f_{v}(v),\n$$\nwhere $F_{\\max}$ is the maximum isometric force (in $\\mathrm{N}$), $f_{\\ell}(\\ell)$ is a normalized force-length curve, and $f_v(v)$ is a normalized force-velocity curve, both dimensionless and equal to $1$ at the operating point $(\\ell=\\ell_{\\mathrm{opt}}, v=0)$. Use the following widely accepted forms:\n$$\nf_{\\ell}(\\ell) = \\exp\\!\\left(-\\left(\\frac{\\ell - \\ell_{\\mathrm{opt}}}{w\\,\\ell_{\\mathrm{opt}}}\\right)^2\\right),\n$$\nwith width parameter $w$ (dimensionless), and a Hill-hyperbolic force-velocity relationship\n$$\nf_{v}(v) = \\frac{v_{\\max} - v}{v_{\\max} + k_v\\,v},\n$$\nwhere $v_{\\max}$ is a maximum shortening velocity (in $\\mathrm{m/s}$) and $k_v$ is a dimensionless parameter. The passive force is defined by a quadratic slack model\n$$\nF_{\\mathrm{passive}}(\\ell) = F_{\\max}\\,k_{\\mathrm{pas}}\\,\\max\\!\\left(0, \\frac{\\ell}{\\ell_{\\mathrm{opt}}}-1\\right)^2,\n$$\nwith $k_{\\mathrm{pas}}$ dimensionless.\n\nMuscle activation dynamics are modeled as a first-order system with time constant $T_a$ (in $\\mathrm{s}$),\n$$\n\\frac{da}{dt} = \\frac{u - a}{T_a},\n$$\nwhere $u\\in[0,1]$ is the neural control input. The controller is a proportional-derivative law acting on the tracking error of the joint angle relative to a reference $\\theta_{\\mathrm{ref}}$ (in $\\mathrm{rad}$), taken to be a step input:\n$$\nu = K_p\\left(\\theta_{\\mathrm{ref}} - \\theta\\right) - K_d\\,\\omega,\n$$\nwith $K_p$ and $K_d$ dimensionless gains mapping angle and angular velocity to activation. The activation $a$ and command $u$ are saturated to the interval $[0,1]$.\n\nDesign the gains $(K_p,K_d)$ to achieve critical damping of the closed-loop joint dynamics about the operating point $\\theta=0$ under the following approximation: perform a small-signal linearization of $\\tau_m$ around $(\\theta=0,\\omega=0,a=0)$ and neglect activation dynamics in the design phase. Choose a target natural frequency $\\omega_n$ (in $\\mathrm{rad/s}$) for the resulting second-order closed-loop joint dynamics. Derive, from first principles, expressions for $(K_p,K_d)$ that achieve critical damping of the approximate second-order system and then use these gains in the full nonlinear forward simulation (including activation dynamics and Hill-type muscle properties). Validate the design by simulating the step response and computing the overshoot fraction.\n\nThe overshoot fraction must be computed as follows. Let $\\theta(t)$ denote the simulated angle trajectory from $t=0$ to $t=t_{\\mathrm{end}}$. Define the final angle $\\theta_f$ as the average of $\\theta(t)$ over the last $10\\%$ of the simulation interval. Let $\\theta_{\\max}$ denote the maximum angle achieved during the simulation. With initial angle $\\theta(0)=0$ and step input $\\theta_{\\mathrm{ref}} = \\theta_{\\mathrm{step}}  0$, define the overshoot fraction\n$$\n\\mathrm{OS} = \\frac{\\theta_{\\max} - \\theta_f}{\\theta_f - \\theta(0)},\n$$\nwhich is a dimensionless decimal.\n\nAll simulations must be performed with angles in radians, time in seconds, torques in $\\mathrm{N\\cdot m}$, and forces in $\\mathrm{N}$. For each test case, compute $(K_p,K_d)$ from your derived formulas, simulate the forward dynamics for a duration $t_{\\mathrm{end}} = 2.0$ (in $\\mathrm{s}$) using numerical integration, and return the overshoot fraction rounded to three decimal places.\n\nTest suite parameter sets are:\n\n- Case A (general case): $J=0.05$ (in $\\mathrm{kg\\cdot m^2}$), $r=0.03$ (in $\\mathrm{m}$), $F_{\\max}=1500$ (in $\\mathrm{N}$), $T_a=0.03$ (in $\\mathrm{s}$), $\\ell_{\\mathrm{opt}}=0.10$ (in $\\mathrm{m}$), $w=0.25$ (dimensionless), $v_{\\max}=10\\,\\ell_{\\mathrm{opt}}$ (in $\\mathrm{m/s}$), $k_v=0.25$ (dimensionless), $k_{\\mathrm{pas}}=0.03$ (dimensionless), $\\theta_{\\mathrm{step}}=0.10$ (in $\\mathrm{rad}$), and target $\\omega_n=10.0$ (in $\\mathrm{rad/s}$).\n- Case B (slow activation boundary): $J=0.05$, $r=0.03$, $F_{\\max}=1500$, $T_a=0.20$, $\\ell_{\\mathrm{opt}}=0.10$, $w=0.25$, $v_{\\max}=10\\,\\ell_{\\mathrm{opt}}$, $k_v=0.25$, $k_{\\mathrm{pas}}=0.03$, $\\theta_{\\mathrm{step}}=0.10$, target $\\omega_n=10.0$.\n- Case C (small moment arm and lower strength edge): $J=0.05$, $r=0.01$, $F_{\\max}=800$, $T_a=0.05$, $\\ell_{\\mathrm{opt}}=0.10$, $w=0.25$, $v_{\\max}=10\\,\\ell_{\\mathrm{opt}}$, $k_v=0.25$, $k_{\\mathrm{pas}}=0.03$, $\\theta_{\\mathrm{step}}=0.10$, target $\\omega_n=10.0$.\n- Case D (larger inertia, lower target frequency): $J=0.10$, $r=0.03$, $F_{\\max}=2000$, $T_a=0.03$, $\\ell_{\\mathrm{opt}}=0.10$, $w=0.25$, $v_{\\max}=10\\,\\ell_{\\mathrm{opt}}$, $k_v=0.25$, $k_{\\mathrm{pas}}=0.03$, $\\theta_{\\mathrm{step}}=0.15$, target $\\omega_n=7.0$.\n\nYour program should produce a single line of output containing the overshoot fractions for the four cases, rounded to three decimal places, as a comma-separated list enclosed in square brackets (e.g., $[\\mathrm{os}_A,\\mathrm{os}_B,\\mathrm{os}_C,\\mathrm{os}_D]$).",
            "solution": "The user-provided problem statement has been meticulously analyzed and is deemed to be **valid**. It is scientifically grounded in the principles of rotational dynamics and established biomechanical models of muscle-tendon units. The problem is well-posed, objective, and contains all necessary information to derive a unique solution and perform the required validation. The task requires a combination of analytical derivation and numerical simulation, representing a standard workflow in the design and analysis of controlled biomechanical systems.\n\nThe solution is divided into two main parts: first, the analytical derivation of the proportional-derivative ($K_p$, $K_d$) controller gains from first principles; second, the implementation of a forward dynamics simulation using the full nonlinear system model to validate the controller design and compute the specified performance metric (overshoot fraction).\n\n### Part 1: Derivation of Controller Gains\n\nThe design goal is to select gains $K_p$ and $K_d$ to achieve critical damping ($\\zeta=1$) for a target natural frequency $\\omega_n$ in a linearized approximation of the system.\n\n**1. System Dynamics and Linearization**\n\nThe rotational dynamics of the single-degree-of-freedom joint are governed by Newton's Second Law for rotation:\n$$\nJ \\frac{d^2\\theta}{dt^2} = J \\dot{\\omega} = \\tau_m(\\theta, \\omega, a)\n$$\nwhere $J$ is the moment of inertia, $\\theta$ is the joint angle, $\\omega$ is the angular velocity, and $\\tau_m$ is the net muscle torque.\n\nThe problem specifies that for the controller design phase, we must make two key simplifications:\ni. The muscle activation dynamics are neglected, meaning the muscle activation $a$ is assumed to be equal to the control command $u$, i.e., $a=u$.\nii. The torque function $\\tau_m$ is linearized around the equilibrium point $(\\theta, \\omega, a) = (0, 0, 0)$.\n\nThe linearized torque $\\delta\\tau_m$ is given by the first-order Taylor expansion:\n$$\n\\delta\\tau_m \\approx \\left.\\frac{\\partial \\tau_m}{\\partial \\theta}\\right|_{op} \\delta\\theta + \\left.\\frac{\\partial \\tau_m}{\\partial \\omega}\\right|_{op} \\delta\\omega + \\left.\\frac{\\partial \\tau_m}{\\partial a}\\right|_{op} \\delta a\n$$\nwhere the partial derivatives are evaluated at the operating point $(op)$ which is $(\\theta, \\omega, a) = (0, 0, 0)$. At this point, the muscle-tendon length is $\\ell = \\ell_{\\mathrm{opt}}$ and its velocity is $v=0$.\n\n**2. Calculation of Partial Derivatives**\n\nWe calculate each partial derivative of the torque $\\tau_m = r F_m = r(F_{\\mathrm{active}} + F_{\\mathrm{passive}})$.\n\n*   **Derivative with respect to activation $a$**:\n    $$\n    \\frac{\\partial \\tau_m}{\\partial a} = r \\frac{\\partial}{\\partial a} \\left[ a F_{\\max} f_{\\ell}(\\ell) f_v(v) + F_{\\mathrm{passive}}(\\ell) \\right] = r F_{\\max} f_{\\ell}(\\ell) f_v(v)\n    $$\n    Evaluating at the operating point, where $\\ell=\\ell_{\\mathrm{opt}}$ and $v=0$, we use the properties $f_{\\ell}(\\ell_{\\mathrm{opt}})=1$ and $f_v(0)=1$:\n    $$\n    \\left.\\frac{\\partial \\tau_m}{\\partial a}\\right|_{op} = r F_{\\max}\n    $$\n\n*   **Derivative with respect to angle $\\theta$ (Stiffness Term)**: Using the chain rule with $\\ell = \\ell_{\\mathrm{opt}} - r\\theta \\implies \\frac{d\\ell}{d\\theta} = -r$:\n    $$\n    \\frac{\\partial \\tau_m}{\\partial \\theta} = \\frac{\\partial \\tau_m}{\\partial \\ell} \\frac{d\\ell}{d\\theta} = -r \\frac{\\partial}{\\partial \\ell} \\left[ r \\left( a F_{\\max} f_{\\ell}(\\ell) f_v(v) + F_{\\mathrm{passive}}(\\ell) \\right) \\right] = -r^2 \\left( a F_{\\max} f'_{\\ell}(\\ell) f_v(v) + F'_{\\mathrm{passive}}(\\ell) \\right)\n    $$\n    At the operating point, $a=0$. The derivative of the force-length curve, $f'_{\\ell}(\\ell_{opt})$, is zero as the curve has its peak at $\\ell=\\ell_{opt}$. The derivative of the passive force, $F'_{\\mathrm{passive}}(\\ell_{opt})$, is also zero as the function $F_{\\mathrm{passive}}(\\ell) \\propto \\max(0, \\ell/\\ell_{\\mathrm{opt}}-1)^2$ has a minimum at $\\ell=\\ell_{\\mathrm{opt}}$. Therefore:\n    $$\n    \\left.\\frac{\\partial \\tau_m}{\\partial \\theta}\\right|_{op} = 0\n    $$\n\n*   **Derivative with respect to angular velocity $\\omega$ (Damping Term)**: Using the chain rule with $v = -r\\omega \\implies \\frac{dv}{d\\omega} = -r$:\n    $$\n    \\frac{\\partial \\tau_m}{\\partial \\omega} = \\frac{\\partial \\tau_m}{\\partial v} \\frac{dv}{d\\omega} = -r \\frac{\\partial}{\\partial v} \\left[ r \\left( a F_{\\max} f_{\\ell}(\\ell) f_v(v) + F_{\\mathrm{passive}}(\\ell) \\right) \\right] = -r^2 a F_{\\max} f_{\\ell}(\\ell) f'_{v}(v)\n    $$\n    Evaluating at the operating point where $a=0$:\n    $$\n    \\left.\\frac{\\partial \\tau_m}{\\partial \\omega}\\right|_{op} = 0\n    $$\n\n**3. Linearized Closed-Loop Dynamics**\n\nSubstituting the derivatives into the linearized torque expression yields:\n$$\n\\delta\\tau_m \\approx (r F_{\\max}) \\delta a\n$$\nThe linearized equation of motion is $J \\ddot{\\delta\\theta} = \\delta\\tau_m$. For analyzing the response, we can omit the perturbation notation $\\delta$:\n$$\nJ \\ddot{\\theta} = r F_{\\max} a\n$$\nUsing the controller $u = K_p(\\theta_{\\mathrm{ref}} - \\theta) - K_d \\omega$ and the approximation $a=u$, we obtain the closed-loop system dynamics:\n$$\nJ \\ddot{\\theta} = r F_{\\max} \\left( K_p(\\theta_{\\mathrm{ref}} - \\theta) - K_d \\dot{\\theta} \\right)\n$$\nRearranging this into the standard second-order form $\\ddot{x} + 2\\zeta\\omega_n\\dot{x} + \\omega_n^2 x = \\omega_n^2 x_{\\mathrm{ref}}$ gives:\n$$\nJ \\ddot{\\theta} + (r F_{\\max} K_d) \\dot{\\theta} + (r F_{\\max} K_p) \\theta = (r F_{\\max} K_p) \\theta_{\\mathrm{ref}}\n$$\nDividing by $J$:\n$$\n\\ddot{\\theta} + \\left(\\frac{r F_{\\max} K_d}{J}\\right) \\dot{\\theta} + \\left(\\frac{r F_{\\max} K_p}{J}\\right) \\theta = \\left(\\frac{r F_{\\max} K_p}{J}\\right) \\theta_{\\mathrm{ref}}\n$$\n\n**4. Gain Derivation**\n\nBy comparing the coefficients with the canonical second-order system, we identify:\n$$\n\\omega_n^2 = \\frac{r F_{\\max} K_p}{J}\n$$\n$$\n2\\zeta\\omega_n = \\frac{r F_{\\max} K_d}{J}\n$$\nTo achieve critical damping ($\\zeta=1$) for a given target natural frequency $\\omega_n$, we solve for the gains $K_p$ and $K_d$:\n$$\nK_p = \\frac{J \\omega_n^2}{r F_{\\max}}\n$$\n$$\nK_d = \\frac{2 J \\omega_n}{r F_{\\max}}\n$$\nThese equations provide the required controller gains based on the system parameters and design specifications.\n\n### Part 2: Forward Simulation and Validation\n\nThe validation step involves simulating the full nonlinear system using the derived gains and calculating the step response overshoot.\n\n**1. Nonlinear System Model**\n\nThe state of the system is the vector $y(t) = [\\theta(t), \\omega(t), a(t)]^T$. The dynamics are described by a system of three coupled first-order ordinary differential equations (ODEs):\n$$\n\\frac{d}{dt}y = \n\\begin{pmatrix} \\dot{\\theta} \\\\ \\dot{\\omega} \\\\ \\dot{a} \\end{pmatrix} = \n\\begin{pmatrix}\n\\omega \\\\\n\\frac{1}{J} \\tau_m(\\theta, \\omega, a) \\\\\n\\frac{u_{\\mathrm{sat}} - a}{T_a}\n\\end{pmatrix}\n$$\nwhere:\n- The control command is $u = K_p(\\theta_{\\mathrm{ref}} - \\theta) - K_d \\omega$.\n- The command is saturated: $u_{\\mathrm{sat}} = \\mathrm{clip}(u, 0, 1)$.\n- The muscle torque $\\tau_m = r(F_{\\mathrm{active}} + F_{\\mathrm{passive}})$ is computed using the full nonlinear Hill-type model provided in the problem statement, without the simplifying assumptions made for the gain derivation.\n\n**2. Numerical Simulation and Overshoot Calculation**\n\nFor each test case, the following procedure is executed:\n1.  The parameters ($J, r, F_{\\max}, \\omega_n$, etc.) are specified.\n2.  The gains $K_p$ and $K_d$ are calculated using the derived formulas.\n3.  The ODE system is integrated numerically from the initial state $y(0) = [0, 0, 0]^T$ over the time interval $[0, t_{\\mathrm{end}}]$ with $t_{\\mathrm{end}}=2.0\\mathrm{s}$.\n4.  The resulting angle trajectory $\\theta(t)$ is analyzed to compute the overshoot fraction.\n    - The maximum angle achieved is $\\theta_{\\max} = \\max_{t \\in [0, t_{\\mathrm{end}}]} \\theta(t)$.\n    - The final angle $\\theta_f$ is the mean of $\\theta(t)$ over the last $10\\%$ of the simulation, i.e., $t \\in [1.8, 2.0]$.\n    - The overshoot fraction is $\\mathrm{OS} = \\frac{\\theta_{\\max} - \\theta_f}{\\theta_f - \\theta(0)}$. Since the initial angle $\\theta(0)=0$, this simplifies to $\\mathrm{OS} = (\\theta_{\\max} / \\theta_f) - 1$.\n5.  The final result is rounded to three decimal places.\n\nThis procedure is implemented in the following Python code.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the musculoskeletal control problem for all test cases.\n    Derives controller gains, runs a forward simulation, and computes overshoot.\n    \"\"\"\n\n    # J, r, F_max, T_a, l_opt, w, vmax_factor, k_v, k_pas, theta_step, omega_n\n    test_cases = [\n        # Case A: general case\n        (0.05, 0.03, 1500, 0.03, 0.10, 0.25, 10.0, 0.25, 0.03, 0.10, 10.0),\n        # Case B: slow activation boundary\n        (0.05, 0.03, 1500, 0.20, 0.10, 0.25, 10.0, 0.25, 0.03, 0.10, 10.0),\n        # Case C: small moment arm and lower strength edge\n        (0.05, 0.01, 800, 0.05, 0.10, 0.25, 10.0, 0.25, 0.03, 0.10, 10.0),\n        # Case D: larger inertia, lower target frequency\n        (0.10, 0.03, 2000, 0.03, 0.10, 0.25, 10.0, 0.25, 0.03, 0.15, 7.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        overshoot = run_simulation(params)\n        results.append(f\"{overshoot:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single forward dynamics simulation for a given parameter set.\n    \"\"\"\n    J, r, F_max, T_a, l_opt, w, vmax_factor, k_v, k_pas, theta_step, omega_n = params\n    v_max = vmax_factor * l_opt\n    \n    # 1. Derive controller gains Kp and Kd from first principles\n    # Based on the linearized model: J*theta_ddot + (r*F_max*Kd)*theta_dot + (r*F_max*Kp)*theta = ...\n    # Comparing to theta_ddot + 2*zeta*wn*theta_dot + wn^2*theta = ...\n    # wn^2 = (r*F_max*Kp)/J  = Kp = J*wn^2 / (r*F_max)\n    # 2*zeta*wn = (r*F_max*Kd)/J = Kd = 2*zeta*J*wn / (r*F_max)\n    # For critical damping, zeta = 1.\n    \n    r_F_max = r * F_max\n    Kp = (J * omega_n**2) / r_F_max\n    Kd = (2 * J * omega_n) / r_F_max\n\n    # 2. Define the nonlinear ODE system for forward simulation\n    def system_dynamics(t, y):\n        theta, omega, a = y\n        \n        # PD Controller\n        theta_ref = theta_step\n        u = Kp * (theta_ref - theta) - Kd * omega\n        # Saturate control command\n        u_sat = np.clip(u, 0.0, 1.0)\n\n        # Musculotendon kinematics\n        # l is muscle-tendon length, v is muscle-tendon velocity\n        l = l_opt - r * theta\n        v = -r * omega\n\n        # Hill-type muscle force calculation\n        # Force-length curve (f_l)\n        fl_exp_arg = -(((l - l_opt) / (w * l_opt))**2)\n        f_l = np.exp(fl_exp_arg)\n        \n        # Force-velocity curve (f_v)\n        fv_denom = v_max + k_v * v\n        # Prevent division by zero for extreme velocities, though unlikely with given params\n        f_v = (v_max - v) / fv_denom if abs(fv_denom)  1e-9 else 0.0\n        \n        # Active force (F_active)\n        F_active = a * F_max * f_l * f_v\n        \n        # Passive force (F_passive)\n        passive_strain = np.maximum(0.0, (l / l_opt) - 1.0)\n        F_passive = F_max * k_pas * (passive_strain**2)\n\n        # Total muscle force and torque\n        F_m = F_active + F_passive\n        tau_m = r * F_m\n        \n        # State derivatives\n        d_theta_dt = omega\n        d_omega_dt = tau_m / J\n        d_a_dt = (u_sat - a) / T_a\n        \n        return [d_theta_dt, d_omega_dt, d_a_dt]\n\n    # 3. Perform numerical integration\n    t_end = 2.0\n    y0 = [0.0, 0.0, 0.0]  # Initial state: [theta, omega, a]\n    sol = solve_ivp(\n        system_dynamics,\n        [0, t_end],\n        y0,\n        dense_output=True,\n        rtol=1e-6,\n        atol=1e-9\n    )\n\n    # 4. Compute overshoot fraction\n    # Get angle trajectory from solution\n    t_points = sol.t\n    theta_traj = sol.y[0]\n    \n    # Find maximum angle\n    theta_max = np.max(theta_traj)\n    \n    # Calculate final steady-state angle (theta_f) from last 10% of simulation\n    t_avg_start = 0.9 * t_end\n    t_eval_avg = np.linspace(t_avg_start, t_end, num=100)\n    theta_avg_samples = sol.sol(t_eval_avg)[0]\n    theta_f = np.mean(theta_avg_samples)\n\n    # Calculate overshoot fraction OS = (theta_max - theta_f) / (theta_f - theta_0)\n    theta_0 = y0[0]\n    if abs(theta_f - theta_0)  1e-9:\n        overshoot = 0.0\n    else:\n        overshoot = (theta_max - theta_f) / (theta_f - theta_0)\n\n    return overshoot\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}