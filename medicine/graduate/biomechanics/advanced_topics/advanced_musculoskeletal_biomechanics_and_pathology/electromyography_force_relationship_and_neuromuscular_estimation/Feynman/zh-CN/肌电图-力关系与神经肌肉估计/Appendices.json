{
    "hands_on_practices": [
        {
            "introduction": "原始的表面肌电图（EMG）信号是一种高频的随机信号，反映了运动单位动作电位的总和。为了从中估计肌肉的潜在神经驱动或激活水平（一个缓慢变化的生理过程），我们必须对其进行处理。本练习将指导您基于肌肉激活和失活的生理时间常数，设计一个合适的低通滤波器，从而将信号处理理论与生物物理现实联系起来。",
            "id": "4170468",
            "problem": "一个实验室旨在通过表面肌电图 (EMG) 估计肌肉激活，以用于等长力预测。记录的EMG信号已经过 $20$–$450$ Hz 的带通滤波和全波整流。为了获得一个能近似肌肉低频激活动态的包络，你需要设计一个一阶低通滤波器，并将其应用于整流后的信号。\n\n假设将神经驱动映射到激活的底层激活动态可以被一个一阶线性时不变系统局部近似，但其上升和下降阶段具有非对称的指数时间过程：上升时间常数为 $\\tau_{\\text{act}} = 35$ 毫秒，衰减时间常数为 $\\tau_{\\text{deact}} = 70$ 毫秒。你将使用一个时间常数为 $\\tau_f$ 的单一阶低通滤波器来近似这些非对称动态，该滤波器应用于整流后的EMG信号以形成激活估计值。\n\n从线性一阶系统和指数响应的原理出发，且不使用任何预先指定的包络设计公式，通过最小化上升和衰减时间常数之间的对称乘性失配来选择 $\\tau_f$。也就是说，选择 $\\tau_f$，使其在对数意义上同等地偏向两个阶段的指数速率。然后，使用一阶低通系统的频率响应，确定与你选择的 $\\tau_f$ 相对应的截止频率 $f_c$（定义为 $-3$ dB 频率）。\n\n以赫兹 (Hz) 为单位，提供最终选择的截止频率的单个数值。将你的答案四舍五入到三位有效数字。在你的推理中，论证为何对于一个旨在反映激活动态的EMG包络，所得的截止频率落在 $3$–$10~\\text{Hz}$ 的经验合理范围内。",
            "solution": "该问题要求设计一个一阶低通滤波器，以生成一个近似肌肉激活动态的肌电图 (EMG) 包络。滤波器的设计必须基于对其时间常数 $\\tau_f$ 的原则性选择，该选择源于肌肉激活的非对称上升和衰减时间常数。\n\n首先，我们将选择滤波器时间常数 $\\tau_f$ 的标准形式化。问题指出，底层的肌肉激活动态由非对称的指数响应近似，其上升时间常数为 $\\tau_{\\text{act}} = 35$ 毫秒，衰减时间常数为 $\\tau_{\\text{deact}} = 70$ 毫秒。我们被要求为一个对称的一阶滤波器选择一个单一的时间常数 $\\tau_f$，以“在对数意义上”最小化这两个值之间的对称乘性失配。\n\n这个条件意味着，所选时间常数 $\\tau_f$ 与较小时间常数 $\\tau_{\\text{act}}$ 的比值，应等于较长时间常数 $\\tau_{\\text{deact}}$ 与 $\\tau_f$ 的比值。这确保了 $\\tau_f$ 在乘法意义上与 $\\tau_{\\text{act}}$ 和 $\\tau_{\\text{deact}}$ 等距。在数学上，这表示为：\n$$\n\\frac{\\tau_f}{\\tau_{\\text{act}}} = \\frac{\\tau_{\\text{deact}}}{\\tau_f}\n$$\n这等价于陈述从 $\\ln(\\tau_f)$ 到 $\\ln(\\tau_{\\text{act}})$ 的对数距离与从 $\\ln(\\tau_{\\text{deact}})$ 到 $\\ln(\\tau_f)$ 的对数距离相同，即 $\\ln(\\tau_f) - \\ln(\\tau_{\\text{act}}) = \\ln(\\tau_{\\text{deact}}) - \\ln(\\tau_f)$。\n\n为了求解 $\\tau_f$，我们重新整理方程：\n$$\n\\tau_f^2 = \\tau_{\\text{act}} \\cdot \\tau_{\\text{deact}}\n$$\n由于时间常数必须为正，取正平方根后，我们发现 $\\tau_f$ 是 $\\tau_{\\text{act}}$ 和 $\\tau_{\\text{deact}}$ 的几何平均值：\n$$\n\\tau_f = \\sqrt{\\tau_{\\text{act}} \\cdot \\tau_{\\text{deact}}}\n$$\n我们已知 $\\tau_{\\text{act}} = 35 \\text{ ms} = 0.035 \\text{ s}$ 和 $\\tau_{\\text{deact}} = 70 \\text{ ms} = 0.070 \\text{ s}$。将这些值代入公式：\n$$\n\\tau_f = \\sqrt{(0.035 \\text{ s}) \\cdot (0.070 \\text{ s})} = \\sqrt{0.00245 \\text{ s}^2}\n$$\n\n接下来，我们必须确定与此时间常数相对应的截止频率 $f_c$。一阶低通滤波器的传递函数在拉普拉斯域中由下式给出：\n$$\nH(s) = \\frac{1}{1 + s\\tau_f}\n$$\n通过设置 $s = j\\omega$ 来求得频率响应，其中 $j$ 是虚数单位，$\\omega = 2\\pi f$ 是角频率。\n$$\nH(j\\omega) = \\frac{1}{1 + j\\omega\\tau_f}\n$$\n频率响应的幅值为：\n$$\n|H(j\\omega)| = \\frac{1}{|1 + j\\omega\\tau_f|} = \\frac{1}{\\sqrt{1^2 + (\\omega\\tau_f)^2}} = \\frac{1}{\\sqrt{1 + (2\\pi f \\tau_f)^2}}\n$$\n截止频率 $f_c$ 被定义为信号功率减半时的频率，这对应于幅值下降到其直流值的 $1/\\sqrt{2}$。直流幅值为 $|H(j0)| = 1$。因此，在 $f = f_c$ 时，我们有：\n$$\n|H(j2\\pi f_c)| = \\frac{1}{\\sqrt{2}}\n$$\n将此代入幅值方程：\n$$\n\\frac{1}{\\sqrt{1 + (2\\pi f_c \\tau_f)^2}} = \\frac{1}{\\sqrt{2}}\n$$\n两边平方并取倒数，得到：\n$$\n1 + (2\\pi f_c \\tau_f)^2 = 2\n$$\n$$\n(2\\pi f_c \\tau_f)^2 = 1\n$$\n由于 $f_c$ 和 $\\tau_f$ 均为正，取正根：\n$$\n2\\pi f_c \\tau_f = 1\n$$\n这给出了一阶系统的截止频率和时间常数之间的基本关系：\n$$\nf_c = \\frac{1}{2\\pi \\tau_f}\n$$\n现在，我们代入 $\\tau_f$ 的表达式：\n$$\nf_c = \\frac{1}{2\\pi \\sqrt{0.00245 \\text{ s}^2}}\n$$\n数值计算该表达式：\n$$\nf_c \\approx \\frac{1}{2\\pi (0.04949747... \\text{ s})} \\approx \\frac{1}{0.31100... \\text{ s}} \\approx 3.2159... \\text{ Hz}\n$$\n按要求将结果四舍五入到三位有效数字：\n$$\nf_c \\approx 3.22 \\text{ Hz}\n$$\n这个结果落在 $3$–$10~\\text{Hz}$ 的经验合理范围内。这个范围是合理的，因为最终目标是估计肌肉力，这是一个低频生理过程。自主肌肉力信号的大部分功率集中在 $10$ Hz 以下。一个截止频率在此范围内的低通滤波器能有效去除原始EMG信号中与净力输出不直接相关的高频随机分量，同时保留反映对肌肉的分级神经驱动的低频内容。$3.22$ Hz 的截止频率提供了显著的平滑以创建稳定的力估计，但其频率也足够高，可以跟踪等长收缩水平的中等速度变化而不会引入过多的相位延迟，从而在噪声抑制和系统响应性之间达到了一个有生物物理学动机的平衡。",
            "answer": "$$\n\\boxed{3.22}\n$$"
        },
        {
            "introduction": "在不同日期或不同受试者之间比较EMG信号的幅值需要一个稳定的参考标准。最常用的方法，即对最大自主收缩（MVC）进行归一化，存在一些已知的问题。本练习使用一个简化模型，通过数学推导来揭示MVC表现的日常波动如何引入人为误差，从而影响结果的可比性，旨在培养对标准实验方法的批判性思维。",
            "id": "4170432",
            "problem": "考虑由同一名参与者在两个不同的日子里执行的单关节等长收缩任务。设机械力为 $F$，到运动神经元池的神经驱动为 $u$。假设在感兴趣的操作范围内，输入-输出映射是局部线性的：$F = \\eta u$，其中 $\\eta$ 是一个常数，代表等长收缩力产生时的有效肌肉-肌腱增益。设处理后的表面肌电图（EMG）振幅为 $E$，并假设EMG振幅与神经驱动之间存在局部线性关系，$E = \\gamma u$，其中 $\\gamma$ 是一个综合增益，反映了电极、组织和运动单位的特性。假设这两种关系在中等收缩范围内均有效，并且基线偏移已被正确移除。\n\n对最大自主收缩（MVC）振幅的归一化定义为 $\\hat{E} = E / E_{\\mathrm{MVC}}$，其中 $E_{\\mathrm{MVC}}$ 是在特定一天MVC期间记录的EMG振幅。在第 $i$ 天（$i \\in \\{1,2\\}$），假设记录的MVC未达到真正的最大激活水平，仅达到了真正最大神经驱动 $u_{\\max}$ 的一部分 $\\beta_i u_{\\max}$，其中 $0  \\beta_i \\le 1$。因此，$E_{\\mathrm{MVC},i} = \\gamma \\beta_i u_{\\max}$。假设 $\\eta$ 和 $\\gamma$ 在这两天内是恒定的。\n\n利用这些前提，推导每一天的归一化EMG-力斜率，并说明对MVC的归一化如何影响EMG-力斜率的日间可比性。然后，将日间可比性比率 $R$ 定义为第1天和第2天归一化EMG-力斜率之比，即 $R = \\left.\\frac{d\\hat{E}}{dF}\\right|_{1} \\Big/ \\left.\\frac{d\\hat{E}}{dF}\\right|_{2}$，并计算当 $\\beta_1 = 0.80$ 和 $\\beta_2 = 0.90$ 时的 $R$ 值。\n\n将您的答案四舍五入至四位有效数字。最终结果以无单位的无量纲乘数表示。",
            "solution": "该问题要求我们在特定的建模假设下，分析归一化表面肌电图（EMG）与机械力之间的关系，并量化最大自主收缩（MVC）表现的日常变化对这种关系的影响。\n\n首先，我们形式化给出的关系。机械力 $F$ 通过线性增益 $\\eta$ 与神经驱动 $u$ 相关：\n$$F = \\eta u$$\n处理后的EMG振幅 $E$ 通过另一个线性增益 $\\gamma$ 与同一神经驱动 $u$ 相关：\n$$E = \\gamma u$$\n假设 $\\eta$ 和 $\\gamma$ 在两天的测量中保持不变。\n\n根据这两个方程，我们可以将EMG振幅 $E$ 表示为力 $F$ 的函数。通过重新排列第一个方程，我们得到 $u = F/\\eta$。将其代入第二个方程，得到直接的EMG-力关系：\n$$E = \\gamma \\left(\\frac{F}{\\eta}\\right) = \\left(\\frac{\\gamma}{\\eta}\\right) F$$\n未归一化的EMG-力关系的斜率是 $E$ 对 $F$ 的导数：\n$$\\frac{dE}{dF} = \\frac{\\gamma}{\\eta}$$\n由于 $\\gamma$ 和 $\\eta$ 在不同日期是恒定的，未归一化的斜率也是恒定的。这意味着，如果使用原始EMG信号，在这些理想化的假设下，两天的EMG-力关系将是完全可比的。\n\n接下来，我们考虑归一化过程。归一化的EMG $\\hat{E}$ 定义为原始EMG振幅 $E$ 除以在MVC期间记录的EMG振幅 $E_{\\mathrm{MVC}}$。对于特定的一天 $i \\in \\{1, 2\\}$，即为：\n$$\\hat{E}_i = \\frac{E}{E_{\\mathrm{MVC},i}}$$\n问题陈述，在第 $i$ 天，MVC尝试仅达到真正最大神经驱动 $u_{\\max}$ 的一部分 $\\beta_i$。因此，在此次尝试中记录的EMG为：\n$$E_{\\mathrm{MVC},i} = \\gamma (\\beta_i u_{\\max}) = \\gamma \\beta_i u_{\\max}$$\n其中 $0  \\beta_i \\le 1$。\n\n现在，我们可以将第 $i$ 天归一化EMG $\\hat{E}_i$ 的表达式写成力 $F$ 的函数。我们代入 $E$ 和 $E_{\\mathrm{MVC},i}$ 的表达式：\n$$\\hat{E}_i = \\frac{(\\gamma/\\eta)F}{\\gamma \\beta_i u_{\\max}}$$\n增益项 $\\gamma$ 被消去，表达式简化为：\n$$\\hat{E}_i = \\frac{F}{\\eta \\beta_i u_{\\max}}$$\n这个方程描述了第 $i$ 天归一化EMG振幅与机械力之间的线性关系。\n\n为了求出第 $i$ 天的归一化EMG-力斜率，我们将 $\\hat{E}_i$ 对 $F$ 求导：\n$$\\left.\\frac{d\\hat{E}}{dF}\\right|_{i} = \\frac{d}{dF}\\left(\\frac{F}{\\eta \\beta_i u_{\\max}}\\right) = \\frac{1}{\\eta \\beta_i u_{\\max}}$$\n这个推导揭示了归一化如何影响斜率。虽然未归一化的斜率 $\\gamma/\\eta$ 是恒定的，但归一化的斜率与MVC达成率 $\\beta_i$ 成反比。如果 $\\beta_i$ 每天都不同（即 $\\beta_1 \\neq \\beta_2$），那么即使潜在的生理参数 $\\gamma$ 和 $\\eta$ 保持不变，归一化的EMG-力斜率也会变化。这表明，对一个波动的参考（非真实的MVC）进行归一化会引入变异性，并损害日间可比性。\n\n我们被要求计算日间可比性比率 $R$，它被定义为第1天和第2天归一化斜率之比：\n$$R = \\frac{\\left.\\frac{d\\hat{E}}{dF}\\right|_{1}}{\\left.\\frac{d\\hat{E}}{dF}\\right|_{2}}$$\n代入我们为每一天推导出的斜率表达式：\n$$R = \\frac{\\frac{1}{\\eta \\beta_1 u_{\\max}}}{\\frac{1}{\\eta \\beta_2 u_{\\max}}}$$\n分子和分母中的项 $\\eta$ 和 $u_{\\max}$ 是公有的，因此可以消去：\n$$R = \\frac{1/\\beta_1}{1/\\beta_2} = \\frac{\\beta_2}{\\beta_1}$$\n这个简洁的结果表明，归一化EMG-力斜率之比等于MVC达成率的反比。\n\n最后，我们用给定的值 $\\beta_1 = 0.80$ 和 $\\beta_2 = 0.90$ 来计算 $R$。\n$$R = \\frac{0.90}{0.80} = \\frac{9}{8} = 1.125$$\n题目要求答案四舍五入到四位有效数字。精确结果 $1.125$ 可以通过添加一个尾随零来表示为四位有效数字。\n$$R = 1.1250$$\n这个结果表明，第1天的归一化EMG-力斜率是第2天斜率的 $1.1250$ 倍。这种差异完全是由于用于归一化的MVC表现的日常变化所造成的人为结果，而不是潜在神经肌肉系统的变化。",
            "answer": "$$\\boxed{1.1250}$$"
        },
        {
            "introduction": "现代生物力学越来越多地使用机器学习来构建预测模型，例如从EMG预测关节力矩。然而，我们很容易被过于乐观的性能指标所误导，这种现象被称为“过拟合”或“选择偏倚”。本练习  提供了一个基于代码的实践任务，旨在量化这种乐观偏差，并理解为何像嵌套交叉验证这样严谨的技术对于构建能够可靠泛化的模型至关重要。",
            "id": "4170418",
            "problem": "给定一个将肌电图 (EMG) 信号映射到关节力矩的模型的折级（fold-level）预测摘要统计数据。目标是量化当在样本内或内部验证集上评估时，估计的决定系数 (R-squared) 与在外部测试集上的样本外性能相比，其乐观程度有多大。然后，基于量化的乐观程度，确定使用嵌套交叉验证 (NCV) 进行超参数调优是否合理。\n\n使用以下基础知识：\n- 肌电图 (EMG) 提供了一种神经激活的代理指标，而关节力矩是一种机械输出。所学习的映射可以建模为从 EMG 特征到力矩的回归。令真实力矩表示为 $y$，预测力矩表示为 $\\hat{y}$。\n- 决定系数 (R-squared) 定义为 $R^2 = 1 - \\dfrac{\\sum_{j}(y_j - \\hat{y}_j)^2}{\\sum_{j}(y_j - \\bar{y})^2} = 1 - \\dfrac{\\mathrm{SSE}}{\\mathrm{SST}}$，其中 $\\mathrm{SSE}$ 是残差平方和，$\\mathrm{SST}$ 是相对于样本均值 $\\bar{y}$ 的总平方和。\n- 交叉验证 (CV) 将数据划分为多个折，根据 CV 设计，每个折提供训练、验证和测试子集。嵌套交叉验证 (NCV) 引入一个用于无偏测试的外部 CV 循环和一个用于超参数选择的内部 CV 循环，以防止信息从验证集泄漏到测试集。\n\n将 $R^2$ 中的预期乐观度定义为样本内或基于验证的估计与留出的外部测试估计之间的差异，并在所有折上取平均值。具体而言：\n- 训练乐观度：$\\mathcal{O}_{\\text{train}} = \\dfrac{1}{k} \\sum_{i=1}^{k} \\left(R^2_{\\text{train}, i} - R^2_{\\text{outer}, i}\\right)$，其中 $k$ 是折的数量。\n- 选择乐观度：$\\mathcal{O}_{\\text{val}} = \\dfrac{1}{k} \\sum_{i=1}^{k} \\left(R^2_{\\text{val}, i} - R^2_{\\text{outer}, i}\\right)$，其中 $R^2_{\\text{val}, i}$ 指的是在第 $i$ 折中选定的超参数配置的内部验证性能。\n\n合理性判据：如果 $\\mathcal{O}_{\\text{val}}$ 严格为正（超出数值容差），则使用嵌套交叉验证以在调整超参数的同时获得无偏的泛化估计是合理的。\n\n您的任务是编写一个程序，使用为训练、内部验证和外部测试分区提供的折级 $\\mathrm{SSE}$ 和 $\\mathrm{SST}$ 值，计算每个折中每个分区的 $R^2$，然后计算每个测试用例的 $\\mathcal{O}_{\\text{train}}$ 和 $\\mathcal{O}_{\\text{val}}$。此外，返回一个布尔值，说明是否推荐使用嵌套交叉验证（如果 $\\mathcal{O}_{\\text{val}}  0$ 则为 true，使用容差 $\\epsilon = 10^{-12}$ 来处理浮点效应）。\n\n所有输出均为无量纲量或布尔值。将所有浮点输出表示为四舍五入到六位小数的小数。\n\n测试套件：\n- 用例 1（典型的中等样本五折设置）：\n  - $k = 5$\n  - 按折训练：$\\mathrm{SSE}_{\\text{train}} = [1500, 1560, 1470, 1530, 1515]$, $\\mathrm{SST}_{\\text{train}} = [5000, 5200, 4900, 5100, 5050]$\n  - 按折内部验证：$\\mathrm{SSE}_{\\text{val}} = [340, 310, 350, 300, 320]$, $\\mathrm{SST}_{\\text{val}} = [1000, 950, 1020, 980, 1005]$\n  - 按折外部测试：$\\mathrm{SSE}_{\\text{outer}} = [480, 473, 460, 432, 448]$, $\\mathrm{SST}_{\\text{outer}} = [1200, 1100, 1150, 1080, 1120]$\n- 用例 2（具有显著选择效应的小样本三折设置）：\n  - $k = 3$\n  - 按折训练：$\\mathrm{SSE}_{\\text{train}} = [420, 550, 500]$, $\\mathrm{SST}_{\\text{train}} = [2100, 2200, 2000]$\n  - 按折内部验证：$\\mathrm{SSE}_{\\text{val}} = [100, 80, 70]$, $\\mathrm{SST}_{\\text{val}} = [400, 380, 360]$\n  - 按折外部测试：$\\mathrm{SSE}_{\\text{outer}} = [225, 252, 234]$, $\\mathrm{SST}_{\\text{outer}} = [450, 420, 390]$\n- 用例 3（完美预测的边缘情况）：\n  - $k = 3$\n  - 按折训练：$\\mathrm{SSE}_{\\text{train}} = [0, 0, 0]$, $\\mathrm{SST}_{\\text{train}} = [1000, 900, 1100]$\n  - 按折内部验证：$\\mathrm{SSE}_{\\text{val}} = [0, 0, 0]$, $\\mathrm{SST}_{\\text{val}} = [200, 180, 220]$\n  - 按折外部测试：$\\mathrm{SSE}_{\\text{outer}} = [0, 0, 0]$, $\\mathrm{SST}_{\\text{outer}} = [220, 210, 230]$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按顺序输出三个值：$\\mathcal{O}_{\\text{train}}$、$\\mathcal{O}_{\\text{val}}$ 和嵌套交叉验证合理性的布尔值。按顺序汇总所有测试用例。例如，输出应类似于 $[\\text{case1\\_O\\_train},\\text{case1\\_O\\_val},\\text{case1\\_NCV\\_bool},\\text{case2\\_O\\_train},\\ldots]$。",
            "solution": "该问题已经过验证，并被确定为一个有效、适定（well-posed）的科学问题。\n\n### 步骤 1：提取已知信息\n\n- **模型背景**：一个回归模型将肌电图 (EMG) 信号映射到关节力矩。真实力矩为 $y$，预测力矩为 $\\hat{y}$。\n- **决定系数 ($R^2$) 定义**：$R^2 = 1 - \\dfrac{\\sum_{j}(y_j - \\hat{y}_j)^2}{\\sum_{j}(y_j - \\bar{y})^2} = 1 - \\dfrac{\\mathrm{SSE}}{\\mathrm{SST}}$。\n- **交叉验证背景**：使用嵌套交叉验证 (NCV)，包含一个用于测试的外部循环和一个用于超参数选择的内部循环。数据在 $k$ 个折中被划分为训练集、内部验证集和外部测试集。\n- **训练乐观度定义**：$\\mathcal{O}_{\\text{train}} = \\dfrac{1}{k} \\sum_{i=1}^{k} \\left(R^2_{\\text{train}, i} - R^2_{\\text{outer}, i}\\right)$。\n- **选择乐观度定义**：$\\mathcal{O}_{\\text{val}} = \\dfrac{1}{k} \\sum_{i=1}^{k} \\left(R^2_{\\text{val}, i} - R^2_{\\text{outer}, i}\\right)$，其中 $R^2_{\\text{val}, i}$ 是在第 $i$ 折中选定的超参数配置的内部验证性能。\n- **NCV 的合理性判据**：$\\mathcal{O}_{\\text{val}}  0$，使用数值容差 $\\epsilon = 10^{-12}$。如果为真，则 NCV 是合理的。\n- **输出格式**：浮点输出四舍五入到六位小数。用于 NCV 合理性的布尔值。输出是方括号内的单个逗号分隔列表，汇总所有测试用例的结果。\n- **测试用例 1**：\n  - $k = 5$\n  - $\\mathrm{SSE}_{\\text{train}} = [1500, 1560, 1470, 1530, 1515]$\n  - $\\mathrm{SST}_{\\text{train}} = [5000, 5200, 4900, 5100, 5050]$\n  - $\\mathrm{SSE}_{\\text{val}} = [340, 310, 350, 300, 320]$\n  - $\\mathrm{SST}_{\\text{val}} = [1000, 950, 1020, 980, 1005]$\n  - $\\mathrm{SSE}_{\\text{outer}} = [480, 473, 460, 432, 448]$\n  - $\\mathrm{SST}_{\\text{outer}} = [1200, 1100, 1150, 1080, 1120]$\n- **测试用例 2**：\n  - $k = 3$\n  - $\\mathrm{SSE}_{\\text{train}} = [420, 550, 500]$\n  - $\\mathrm{SST}_{\\text{train}} = [2100, 2200, 2000]$\n  - $\\mathrm{SSE}_{\\text{val}} = [100, 80, 70]$\n  - $\\mathrm{SST}_{\\text{val}} = [400, 380, 360]$\n  - $\\mathrm{SSE}_{\\text{outer}} = [225, 252, 234]$\n  - $\\mathrm{SST}_{\\text{outer}} = [450, 420, 390]$\n- **测试用例 3**：\n  - $k = 3$\n  - $\\mathrm{SSE}_{\\text{train}} = [0, 0, 0]$\n  - $\\mathrm{SST}_{\\text{train}} = [1000, 900, 1100]$\n  - $\\mathrm{SSE}_{\\text{val}} = [0, 0, 0]$\n  - $\\mathrm{SST}_{\\text{val}} = [200, 180, 220]$\n  - $\\mathrm{SSE}_{\\text{outer}} = [0, 0, 0]$\n  - $\\mathrm{SST}_{\\text{outer}} = [220, 210, 230]$\n\n### 步骤 2：使用提取的已知信息进行验证\n\n该问题在科学上是合理的、适定的且客观的。\n- **科学依据**：该问题基于应用于生物力学中一个成熟问题（EMG-力建模）的标准统计方法（$R^2$，交叉验证）。过拟合、模型选择偏差和嵌套交叉验证等概念是现代机器学习实践的核心。所提供的定义是正确的。\n- **适定性**：该问题提供了所有必要的数据（所有分区和折的 $\\mathrm{SSE}$、$\\mathrm{SST}$）和明确的公式来计算所需的量。每个测试用例都存在唯一且稳定的解。\n- **客观性**：问题以精确、正式的语言陈述。证明 NCV 合理性的标准是客观且明确定义的（$\\mathcal{O}_{\\text{val}}  10^{-12}$）。\n\n该问题被视为有效，并将提供解决方案。\n\n### 解题推导\n\n目标是量化回归模型中的性能乐观度，并确定嵌套交叉验证 (NCV) 是否是获得无偏性能估计的必要程序。这是通过计算两个乐观度指标 $\\mathcal{O}_{\\text{train}}$ 和 $\\mathcal{O}_{\\text{val}}$ 来实现的，这两个指标基于交叉验证过程的摘要统计数据。\n\n每个测试用例的求解过程包括三个主要步骤：\n\n**步骤 1：计算每个分区的决定系数 ($R^2$)**\n\n决定系数 $R^2$ 是衡量模型预测值与真实数据点拟合程度的指标。对于每个折 $i$（从 $1$ 到 $k$）以及每个数据分区（训练、验证和外部测试），使用提供的残差平方和 ($\\mathrm{SSE}$) 和总平方和 ($\\mathrm{SST}$) 计算 $R^2$ 值。其控制公式为：\n\n$$R^2 = 1 - \\frac{\\mathrm{SSE}}{\\mathrm{SST}}$$\n\n对所有 $k$ 个折的 $R^2_{\\text{train}, i}$、$R^2_{\\text{val}, i}$ 和 $R^2_{\\text{outer}, i}$ 执行此计算，生成三个长度为 $k$ 的 $R^2$ 值向量。\n\n**步骤 2：计算乐观度指标**\n\n乐观度量化了当在用于训练或模型选择的数据上评估性能指标时，该指标相对于一个真正留出的测试集被夸大的程度。我们计算两种类型的乐观度：\n\n1.  **训练乐观度 ($\\mathcal{O}_{\\text{train}}$)**：这衡量了在训练数据本身上性能的典型夸大程度，这是模型拟合的一个标志。它通过对训练 $R^2$ 和外部测试 $R^2$ 之间的逐折差异进行平均来计算：\n    $$\\mathcal{O}_{\\text{train}} = \\frac{1}{k} \\sum_{i=1}^{k} \\left(R^2_{\\text{train}, i} - R^2_{\\text{outer}, i}\\right)$$\n    一个高的正值表示显著的过拟合。\n\n2.  **选择乐观度 ($\\mathcal{O}_{\\text{val}}$)**：这衡量了因基于内部验证集上的性能来选择超参数而引入的更微妙的偏差。所选模型对这个特定的验证集是“最优”的，但这可能无法在外部测试集上转化为相同水平的性能。它通过对所选模型的验证 $R^2$ 和外部测试 $R^2$ 之间的逐折差异进行平均来计算：\n    $$\\mathcal{O}_{\\text{val}} = \\frac{1}{k} \\sum_{i=1}^{k} \\left(R^2_{\\text{val}, i} - R^2_{\\text{outer}, i}\\right)$$\n\n**步骤 3：嵌套交叉验证 (NCV) 的合理性判断**\n\nNCV 旨在减轻由 $\\mathcal{O}_{\\text{val}}$ 测量的选择偏差。如果存在可证明的选择乐观度，这意味着在内部验证集上报告的性能是真实泛化性能的不可靠、有偏的估计。NCV 通过使用一个专门用于评估的外部循环来纠正这一点，从而提供一个无偏的估计。\n\n因此，决策标准直接基于 $\\mathcal{O}_{\\text{val}}$。如果此值严格为正，则表明超参数选择引入了乐观偏差。为了考虑浮点运算的局限性，使用了一个小的容差 $\\epsilon = 10^{-12}$。\n\nNCV 的合理性由以下条件确定：\n$$\\text{NCV Justified} = (\\mathcal{O}_{\\text{val}}  \\epsilon)$$\n这会产生一个布尔值（`true` 或 `false`）。`true` 结果强烈建议对此建模问题使用 NCV，以确保报告的性能指标是无偏的。\n\n这三个步骤系统地应用于问题陈述中提供的每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates R^2 optimism and NCV justification for given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"k\": 5,\n            \"sse_train\": np.array([1500, 1560, 1470, 1530, 1515]),\n            \"sst_train\": np.array([5000, 5200, 4900, 5100, 5050]),\n            \"sse_val\": np.array([340, 310, 350, 300, 320]),\n            \"sst_val\": np.array([1000, 950, 1020, 980, 1005]),\n            \"sse_outer\": np.array([480, 473, 460, 432, 448]),\n            \"sst_outer\": np.array([1200, 1100, 1150, 1080, 1120]),\n        },\n        {\n            \"k\": 3,\n            \"sse_train\": np.array([420, 550, 500]),\n            \"sst_train\": np.array([2100, 2200, 2000]),\n            \"sse_val\": np.array([100, 80, 70]),\n            \"sst_val\": np.array([400, 380, 360]),\n            \"sse_outer\": np.array([225, 252, 234]),\n            \"sst_outer\": np.array([450, 420, 390]),\n        },\n        {\n            \"k\": 3,\n            \"sse_train\": np.array([0, 0, 0]),\n            \"sst_train\": np.array([1000, 900, 1100]),\n            \"sse_val\": np.array([0, 0, 0]),\n            \"sst_val\": np.array([200, 180, 220]),\n            \"sse_outer\": np.array([0, 0, 0]),\n            \"sst_outer\": np.array([220, 210, 230]),\n        }\n    ]\n\n    results = []\n    # Tolerance for floating point comparison.\n    epsilon = 1e-12\n\n    for case in test_cases:\n        # Step 1: Calculate R^2 for each partition across all folds.\n        # R^2 = 1 - (SSE / SST)\n        r2_train = 1 - (case[\"sse_train\"] / case[\"sst_train\"])\n        r2_val = 1 - (case[\"sse_val\"] / case[\"sst_val\"])\n        r2_outer = 1 - (case[\"sse_outer\"] / case[\"sst_outer\"])\n\n        # Step 2: Calculate optimism metrics.\n        # O_train = mean(R^2_train - R^2_outer)\n        # O_val = mean(R^2_val - R^2_outer)\n        o_train = np.mean(r2_train - r2_outer)\n        o_val = np.mean(r2_val - r2_outer)\n\n        # Step 3: Determine NCV justification.\n        # NCV is justified if selection optimism is strictly positive.\n        ncv_justified = o_val > epsilon\n\n        # Format and append results\n        results.append(f\"{o_train:.6f}\")\n        results.append(f\"{o_val:.6f}\")\n        results.append(str(ncv_justified).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}