{
    "hands_on_practices": [
        {
            "introduction": "理解不确定性问题的最佳方法是在一个简化的情境中解决它。本练习提供了一个基础的肘关节模型，其中有多块肌肉可以完成相同的动作 。你将使用静态优化这一标准的生物力学技术，为肌肉力找到一个唯一的、符合生理学逻辑的解。这项练习旨在培养建立和求解约束优化问题的核心技能。",
            "id": "4182773",
            "problem": "考虑一个在准静态条件下的平面肘关节模型。一个大小为 $M=20$ 牛顿·米的外部肘关节屈曲力矩作用于前臂。两个单关节肘屈肌驱动该关节，其垂直力臂分别为 $r_1=3$ 厘米和 $r_2=5$ 厘米。每块肌肉沿其作用线对前臂产生一个拉力 $f_1$ 和 $f_2$。假设肘关节接触力 $F_c$ 作用于肘关节的瞬时旋转中心，因此对肘关节产生的净力矩为零。\n\n假设如下：\n- 系统处于准静态，因此线动量和角动量平衡简化为力和力矩平衡。\n- 每块肌肉只能产生拉力，因此 $f_1 \\geq 0$ 且 $f_2 \\geq 0$。\n- 两块肌肉的作用线与前臂轴线共线，因此它们对平移平衡的净效应由 $F_c$ 平衡，且当关节接触力与肌肉拉力方向相反时，该接触力为压力。\n\n肘关节是力学不确定的，因为执行器数量多于满足单一力矩平衡所需的数量。为了解决这种不确定性，通过求解一个静态优化问题来确定肌肉力，该问题在精确满足肘关节力矩平衡的约束下，最小化肌肉力的平方和。然后，计算相应的压缩性关节接触力的大小。使用以下基本原理：用于力和力矩平衡的牛顿定律，以及在力矩平衡等式约束下最小化 $\\sum f_i^2$ 的优化准则。\n\n任务：\n1. 建立约束优化问题，以确定 $f_1$ 和 $f_2$。该问题在肘关节屈曲力矩平衡的约束下，最小化 $\\sum_{i=1}^{2} f_i^2$。使用给定的力臂和施加的力矩。除了非负性约束 $f_i \\geq 0$ 和力矩平衡约束外，不要引入任何其他约束。\n2. 用符号 $M$、$r_1$ 和 $r_2$ 求解最优的 $f_1$ 和 $f_2$，然后对 $M=20$ 牛顿·米、$r_1=3$ 厘米和 $r_2=5$ 厘米进行数值计算。\n3. 利用前臂的平移平衡，计算用于平衡净肌肉拉力的压缩性肘关节接触力大小 $F_c$，假设没有其他外力对线平衡有贡献。\n\n以牛顿为单位表示 $f_1$、$f_2$ 和 $F_c$。将最终数值结果四舍五入到四位有效数字。以单行矩阵的形式提供最终答案，其中包含按顺序排列的三个值 $\\left(f_1, f_2, F_c\\right)$。",
            "solution": "该问题已经过验证，并被确定为生物力学领域中一个适定、有科学依据的问题。它自成体系、前后一致，并运用静态平衡和优化的既定原则来解决肌肉不确定性问题。\n\n任务是在一个简化的平面肘关节模型中，确定肌肉力 $f_1$ 和 $f_2$ 以及关节接触力 $F_c$。\n\n首先，我们必须确保所有单位在国际单位制（SI）内保持一致。给定的外力矩为 $M = 20$ N·m。给定的肌肉力臂单位是厘米，必须转换为米：\n$r_1 = 3$ cm $= 0.03$ m\n$r_2 = 5$ cm $= 0.05$ m\n\n**1. 建立约束优化问题**\n问题要求找到肌肉力 $f_1$ 和 $f_2$，以最小化肌肉力的平方和。要最小化的目标函数是：\n$$J(f_1, f_2) = f_1^2 + f_2^2$$\n此最小化过程受两种约束条件的限制：\n1.  **力矩平衡**：屈肌产生的力矩之和必须等于所需的外屈曲力矩 $M$。关节接触力 $F_c$ 作用于旋转中心，因此不产生力矩。力矩平衡方程为：\n    $$f_1 r_1 + f_2 r_2 = M$$\n2.  **非负性**：肌肉只能产生拉力（产生张力），所以它们的力必须是非负的。\n    $$f_1 \\geq 0$$\n    $$f_2 \\geq 0$$\n\n因此，完整的约束优化问题是：\n最小化 $J = f_1^2 + f_2^2$\n约束条件为 $f_1 r_1 + f_2 r_2 = M$，$f_1 \\geq 0$，以及 $f_2 \\geq 0$。\n\n**2. 求解最优肌肉力 ($f_1, f_2$)**\n这是一个凸优化问题，可以使用拉格朗日乘数法求解。我们定义拉格朗日函数 $L$，引入拉格朗日乘子 $\\lambda$ 来整合等式约束。我们将在最后通过验证解来处理不等式约束。\n$$L(f_1, f_2, \\lambda) = (f_1^2 + f_2^2) + \\lambda(M - f_1 r_1 - f_2 r_2)$$\n为求最小值，我们对 $L$ 分别求关于 $f_1$、$f_2$ 和 $\\lambda$ 的偏导数，并令它们为零。\n$$\\frac{\\partial L}{\\partial f_1} = 2f_1 - \\lambda r_1 = 0 \\implies f_1 = \\frac{\\lambda r_1}{2}$$\n$$\\frac{\\partial L}{\\partial f_2} = 2f_2 - \\lambda r_2 = 0 \\implies f_2 = \\frac{\\lambda r_2}{2}$$\n$$\\frac{\\partial L}{\\partial \\lambda} = M - f_1 r_1 - f_2 r_2 = 0 \\implies f_1 r_1 + f_2 r_2 = M$$\n现在我们将前两个方程中 $f_1$ 和 $f_2$ 的表达式代入第三个方程（约束方程），以求解 $\\lambda$：\n$$\\left(\\frac{\\lambda r_1}{2}\\right)r_1 + \\left(\\frac{\\lambda r_2}{2}\\right)r_2 = M$$\n$$\\frac{\\lambda}{2}(r_1^2 + r_2^2) = M$$\n$$\\lambda = \\frac{2M}{r_1^2 + r_2^2}$$\n有了 $\\lambda$ 的表达式，我们就可以找到 $f_1$ 和 $f_2$ 的符号解：\n$$f_1 = \\frac{r_1}{2} \\left( \\frac{2M}{r_1^2 + r_2^2} \\right) = \\frac{M r_1}{r_1^2 + r_2^2}$$\n$$f_2 = \\frac{r_2}{2} \\left( \\frac{2M}{r_1^2 + r_2^2} \\right) = \\frac{M r_2}{r_1^2 + r_2^2}$$\n由于 $M$、$r_1$ 和 $r_2$ 均为正值，因此得到的力 $f_1$ 和 $f_2$ 也将是正值，满足非负性约束 $f_1 \\geq 0$ 和 $f_2 \\geq 0$。\n\n现在，我们代入数值 $M=20$ N·m、$r_1=0.03$ m 和 $r_2=0.05$ m，来计算以牛顿为单位的力。首先，我们计算分母：\n$$r_1^2 + r_2^2 = (0.03)^2 + (0.05)^2 = 0.0009 + 0.0025 = 0.0034 \\text{ m}^2$$\n现在我们计算力的大小：\n$$f_1 = \\frac{(20 \\text{ N·m})(0.03 \\text{ m})}{0.0034 \\text{ m}^2} = \\frac{0.6}{0.0034} \\text{ N} \\approx 176.47058... \\text{ N}$$\n$$f_2 = \\frac{(20 \\text{ N·m})(0.05 \\text{ m})}{0.0034 \\text{ m}^2} = \\frac{1.0}{0.0034} \\text{ N} \\approx 294.11764... \\text{ N}$$\n四舍五入到四位有效数字，我们得到：\n$f_1 \\approx 176.5$ N\n$f_2 \\approx 294.1$ N\n\n**3. 计算关节接触力 ($F_c$)**\n问题指明系统处于准静态平衡，并对平移平衡做了一个简化假设：“两块肌肉的作用线与前臂轴线共线，因此它们对平移平衡的净效应由 $F_c$ 平衡”。这意味着沿着前臂轴线存在一维的力平衡。肌肉产生的总拉力必须由来自关节的相反方向的压力来平衡。\n总肌肉力为 $f_{total} = f_1 + f_2$。\n因此，压缩性关节接触力 $F_c$ 的大小等于肌肉力大小之和：\n$$F_c = f_1 + f_2$$\n在最终四舍五入之前，使用 $f_1$ 和 $f_2$ 的未舍入值以保证精度：\n$$F_c = 176.47058... \\text{ N} + 294.11764... \\text{ N} = 470.58823... \\text{ N}$$\n四舍五入到四位有效数字，我们得到：\n$F_c \\approx 470.6$ N\n\n所要求的三个量的最终数值结果，四舍五入到四位有效数字后为：\n$f_1 = 176.5$ N\n$f_2 = 294.1$ N\n$F_c = 470.6$ N\n按照要求，将这些值排列成一个行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n176.5  & 294.1  & 470.6\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "真实的生物关节比简单的铰链要复杂得多。本练习将转向一个更精密的膝关节模型，该模型包含了更真实的特征，例如独立的内侧和外侧接触点，以及这些接触面不能相互拉动（即单边接触）的事实 。你将探索如何在同时受平衡方程和这些复杂接触约束控制的系统中求解力，并引入互补性这一关键概念。这项练习将挑战你运用逻辑推导来确定关节的接触状态。",
            "id": "4182767",
            "problem": "考虑一个平面的、准静态的胫股膝关节模型，该模型具有两个单边接触界面：一个内侧髁和一个外侧髁。该关节承受沿胫股轴的外部压缩力 $F_{\\mathrm{ext}}$ 和绕关节中心的外部内翻力矩 $M_{\\mathrm{ext}}$。两组肌肉群作用于压缩关节并产生一个绕关节中心的冠状面力矩；它们的力表示为 $f_1$ 和 $f_2$，其对应的冠状面力臂为 $d_1$ 和 $d_2$。最小肌肉应力准则通过最小化归一化肌肉力的平方和来建模。接触由内侧髁和外侧髁的无穿透间隙函数 $g_{\\mathrm{m}}(s,\\theta)$ 和 $g_{\\mathrm{l}}(s,\\theta)$ 分别强制执行，其中 $s$ 是沿胫股轴的关节压缩坐标，$\\theta$ 是内翻-外翻角。假设角度很小，因此 $\\theta$ 以弧度为单位测量。\n\n模型数据如下：\n- 外部载荷：$F_{\\mathrm{ext}} = 1800\\,\\mathrm{N}$ 和 $M_{\\mathrm{ext}} = 18\\,\\mathrm{N\\,m}$。\n- 接触几何半间距：$r = 0.02\\,\\mathrm{m}$，因此来自接触力的冠状面力矩为 $r(\\lambda_{\\mathrm{m}} - \\lambda_{\\mathrm{l}})$，其中 $\\lambda_{\\mathrm{m}}$ 和 $\\lambda_{\\mathrm{l}}$ 是内侧髁和外侧髁的接触乘子（法向接触力）。\n- 肌肉力臂：$d_1 = 0.04\\,\\mathrm{m}$ 和 $d_2 = 0.03\\,\\mathrm{m}$。\n- 用于肌肉应力的归一化常数：$w_1 = 3000\\,\\mathrm{N}$ 和 $w_2 = 1500\\,\\mathrm{N}$。\n- 线性化间隙函数：\n$$\ng_{\\mathrm{m}}(s,\\theta) = s + c\\theta - \\delta_{\\mathrm{m}},\\quad\ng_{\\mathrm{l}}(s,\\theta) = s - c\\theta - \\delta_{\\mathrm{l}},\n$$\n其中 $c = 0.01\\,\\mathrm{m\\,rad^{-1}}$，$\\delta_{\\mathrm{m}} = 0.0015\\,\\mathrm{m}$，且 $\\delta_{\\mathrm{l}} = 0.0010\\,\\mathrm{m}$。\n\n假设接触无摩擦，因此接触力垂直于表面作用，并采用单边接触和互补性条件：$g_{\\mathrm{m}} \\ge 0$，$g_{\\mathrm{l}} \\ge 0$，$\\lambda_{\\mathrm{m}} \\ge 0$，$\\lambda_{\\mathrm{l}} \\ge 0$，且 $\\lambda_{\\mathrm{m}} g_{\\mathrm{m}} = 0$，$\\lambda_{\\mathrm{l}} g_{\\mathrm{l}} = 0$。未知量为肌肉力 $f_1$、$f_2$、接触乘子 $\\lambda_{\\mathrm{m}}$、$\\lambda_{\\mathrm{l}}$ 和运动学坐标 $s$、$\\theta$。\n\n使用牛顿定律（合力为零，合力矩为零）建立胫股轴和冠状面力矩的静力平衡方程，然后求解以下优化问题：\n$$\n\\min_{f_1,f_2,s,\\theta,\\lambda_{\\mathrm{m}},\\lambda_{\\mathrm{l}}}\\ J(f_1,f_2) = \\left(\\frac{f_1}{w_1}\\right)^{2} + \\left(\\frac{f_2}{w_2}\\right)^{2}\n$$\n满足约束条件\n$$\nf_1 + f_2 + \\lambda_{\\mathrm{m}} + \\lambda_{\\mathrm{l}} = F_{\\mathrm{ext}},\n$$\n$$\nr(\\lambda_{\\mathrm{m}} - \\lambda_{\\mathrm{l}}) + d_1 f_1 - d_2 f_2 = M_{\\mathrm{ext}},\n$$\n$$\ng_{\\mathrm{m}}(s,\\theta) \\ge 0,\\quad g_{\\mathrm{l}}(s,\\theta) \\ge 0,\\quad \\lambda_{\\mathrm{m}} \\ge 0,\\quad \\lambda_{\\mathrm{l}} \\ge 0,\\quad \\lambda_{\\mathrm{m}} g_{\\mathrm{m}}(s,\\theta) = 0,\\quad \\lambda_{\\mathrm{l}} g_{\\mathrm{l}}(s,\\theta) = 0.\n$$\n\n使用与这些约束和互补性条件一致的最优解，计算与无穿透约束相对应的接触乘子 $\\lambda_{\\mathrm{m}}$ 和 $\\lambda_{\\mathrm{l}}$。将最终数值四舍五入到四位有效数字。以牛顿为单位表示力。以行向量 $\\begin{pmatrix}\\lambda_{\\mathrm{m}}  \\lambda_{\\mathrm{l}}\\end{pmatrix}$ 的形式提供您的答案。",
            "solution": "该问题是生物力学领域一个定义明确的静态优化问题。它采用了标准原理：用于静力平衡的牛顿定律、用于肌肉力分担的二次成本函数（一种解决肌肉冗余问题的常用方法），以及带有互补性条件的单边接触约束。所有必要的数据和方程均已提供。\n\n### 求解策略\n\n目标是找到一组变量 $\\{f_1, f_2, s, \\theta, \\lambda_{\\mathrm{m}}, \\lambda_{\\mathrm{l}}\\}$，使得目标函数 $J(f_1,f_2)$ 最小化，同时满足所有给定的约束条件。\n\n目标函数是平方和：\n$$\nJ(f_1,f_2) = \\left(\\frac{f_1}{w_1}\\right)^{2} + \\left(\\frac{f_2}{w_2}\\right)^{2}\n$$\n该函数在点 $(f_1, f_2) = (0, 0)$ 处达到其全局最小值 $J=0$。\n\n我们假设这个点 $f_1=0$ 和 $f_2=0$ 是约束优化问题的解。为此，这个选择必须是可行的；也就是说，我们必须能够找到剩余未知数（$s, \\theta, \\lambda_{\\mathrm{m}}, \\lambda_{\\mathrm{l}}$）的值，以满足所有的平衡和接触约束。\n\n我们首先在平衡方程中设置 $f_1=0$ 和 $f_2=0$。这也满足了肌肉力的非负约束。\n\n力平衡方程变为：\n$$\n\\lambda_{\\mathrm{m}} + \\lambda_{\\mathrm{l}} = F_{\\mathrm{ext}} \\implies \\lambda_{\\mathrm{m}} + \\lambda_{\\mathrm{l}} = 1800\n$$\n\n力矩平衡方程变为：\n$$\nr(\\lambda_{\\mathrm{m}} - \\lambda_{\\mathrm{l}}) = M_{\\mathrm{ext}} \\implies 0.02(\\lambda_{\\mathrm{m}} - \\lambda_{\\mathrm{l}}) = 18 \\implies \\lambda_{\\mathrm{m}} - \\lambda_{\\mathrm{l}} = 900\n$$\n\n我们现在得到一个关于两个接触乘子 $\\lambda_{\\mathrm{m}}$ 和 $\\lambda_{\\mathrm{l}}$ 的二元线性方程组：\n1. $\\lambda_{\\mathrm{m}} + \\lambda_{\\mathrm{l}} = 1800$\n2. $\\lambda_{\\mathrm{m}} - \\lambda_{\\mathrm{l}} = 900$\n\n两方程相加得到 $2\\lambda_{\\mathrm{m}} = 2700$，因此 $\\lambda_{\\mathrm{m}} = 1350\\,\\mathrm{N}$。\n代回第一个方程得到 $1350 + \\lambda_{\\mathrm{l}} = 1800$，因此 $\\lambda_{\\mathrm{l}} = 450\\,\\mathrm{N}$。\n\n我们检查这些值是否满足接触力的非负约束：$\\lambda_{\\mathrm{m}} = 1350 \\ge 0$ 和 $\\lambda_{\\mathrm{l}} = 450 \\ge 0$。约束得到满足。\n\n接下来，我们检查互补性条件。由于 $\\lambda_{\\mathrm{m}} > 0$ 和 $\\lambda_{\\mathrm{l}} > 0$，间隙函数必须为零：$g_{\\mathrm{m}}(s,\\theta)=0$ 且 $g_{\\mathrm{l}}(s,\\theta)=0$。这对应于双边接触。\n这两个条件建立了一个关于运动学变量 $s$ 和 $\\theta$ 的二元线性方程组：\n1. $s + c\\theta = \\delta_{\\mathrm{m}} \\implies s + 0.01\\theta = 0.0015$\n2. $s - c\\theta = \\delta_{\\mathrm{l}} \\implies s - 0.01\\theta = 0.0010$\n\n两方程相加得到 $2s = 0.0025$，因此 $s = 0.00125\\,\\mathrm{m}$。\n第一个方程减去第二个方程得到 $0.02\\theta = 0.0005$，因此 $\\theta = 0.025\\,\\mathrm{rad}$。\n\n我们找到了一个完整的可行解集 $\\{f_1, f_2, s, \\theta, \\lambda_{\\mathrm{m}}, \\lambda_{\\mathrm{l}}\\} = \\{0, 0, 0.00125, 0.025, 1350, 450\\}$。由于该解对应于目标函数的全局最小值，因此这必须是最优解。\n\n问题要求接触乘子 $\\lambda_{\\mathrm{m}}$ 和 $\\lambda_{\\mathrm{l}}$。其值为：\n$\\lambda_{\\mathrm{m}} = 1350\\,\\mathrm{N}$\n$\\lambda_{\\mathrm{l}} = 450\\,\\mathrm{N}$\n\n问题要求将最终数值四舍五入到四位有效数字。计算出的值是精确的整数。\n对于 $\\lambda_{\\mathrm{m}} = 1350$：四舍五入到四位有效数字得到 $1350$。\n对于 $\\lambda_{\\mathrm{l}} = 450$：四舍五入到四位有效数字得到 $450.0$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1350  & 450.0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "任何肌肉骨骼模型的准确性都取决于其参数，尤其是决定肌肉产生力矩效率的力臂。这项计算练习将深入探讨这些关键参数如何从解剖结构中确定 。你将通过编程实现并比较解析法和数值法来计算力臂，从而洞察在准确性、计算成本和模型复杂性之间的权衡。对于任何希望建立或严格评估生物力学模型的人来说，这项练习至关重要。",
            "id": "4182774",
            "problem": "考虑一个具有两个旋转自由度 (DOF) 的平面肢体模型。设基座关节（关节$1$）位于世界坐标系的原点，第一个连杆的长度为$L_1 = 0.30$米，第二个连杆的长度为$L_2 = 0.25$米，并在肘部（关节$2$）连接。广义坐标是关节角度 $\\boldsymbol{q} = [q_1, q_2]^\\top$，其中$q_1$是近端关节角度，$q_2$是远端关节角度；所有角度均以弧度表示。第一个连杆的方向由$q_1$给出，第二个连杆的方向由$q_1 + q_2$给出。肘部的全局位置是第一个连杆的末端点。设平面旋转矩阵为 $R(\\theta) \\in \\mathbb{R}^{2 \\times 2}$。\n\n肌腱路径被建模为一条穿过一系列途经点的折线，这些途经点可以固定在世界坐标系中，也可以在局部连杆坐标系中以固定偏移量附着在连杆上。肌腱的总路径长度是路径上连续点之间欧几里得距离的总和。\n\n定义两条具有物理上合理的途经点的肌腱路径（肌肉 $i = 1,2$）：\n\n- 固定的世界点和连杆几何形状：\n  - 基座（关节$1$）位于原点。\n  - 肘部位置为 $p_{\\text{elbow}}(q_1) = R(q_1) \\begin{bmatrix} L_1 \\\\ 0 \\end{bmatrix}$。\n  - 腕部位置为 $p_{\\text{wrist}}(q_1,q_2) = p_{\\text{elbow}}(q_1) + R(q_1+q_2) \\begin{bmatrix} L_2 \\\\ 0 \\end{bmatrix}$。\n\n- 肌肉$1$（双关节，跨越两个关节）路径点：\n  - 世界坐标系中的近端固定锚点：$p_0 = \\begin{bmatrix} -0.05 \\\\ 0.12 \\end{bmatrix}$ 米。\n  - 第一个连杆上的途经点：$p_1(q_1) = R(q_1) \\begin{bmatrix} 0.10 \\\\ 0.03 \\end{bmatrix}$ 米。\n  - 第二个连杆上的途经点：$p_2(q_1,q_2) = p_{\\text{elbow}}(q_1) + R(q_1+q_2) \\begin{bmatrix} 0.03 \\\\ 0.02 \\end{bmatrix}$ 米。\n  - 第二个连杆上靠近腕部的远端止点：$p_3(q_1,q_2) = p_{\\text{elbow}}(q_1) + R(q_1+q_2) \\left( \\begin{bmatrix} L_2 \\\\ 0 \\end{bmatrix} + \\begin{bmatrix} -0.02 \\\\ 0.015 \\end{bmatrix} \\right)$ 米。\n\n- 肌肉$2$（类似单关节，跨越远端关节）路径点：\n  - 第一个连杆上靠近肘部的起点：$p_0'(q_1) = R(q_1) \\begin{bmatrix} L_1 - 0.02 \\\\ -0.01 \\end{bmatrix}$ 米。\n  - 第二个连杆上的途经点：$p_1'(q_1,q_2) = p_{\\text{elbow}}(q_1) + R(q_1+q_2) \\begin{bmatrix} 0.02 \\\\ -0.02 \\end{bmatrix}$ 米。\n  - 第二个连杆上的止点：$p_2'(q_1,q_2) = p_{\\text{elbow}}(q_1) + R(q_1+q_2) \\begin{bmatrix} 0.6\\,L_2 \\\\ 0.015 \\end{bmatrix}$ 米。\n\n对于肌肉$i$，令$L_i(\\boldsymbol{q})$表示其总路径长度。有效力臂矢量 $r_i(\\boldsymbol{q}) \\in \\mathbb{R}^2$ 定义为$L_i(\\boldsymbol{q})$相对于广义坐标的梯度，即 $r_i(\\boldsymbol{q}) = \\nabla_{\\boldsymbol{q}} L_i(\\boldsymbol{q})$，其分量单位为米/弧度。\n\n任务：构建一个数值方案，通过对$L_i(\\boldsymbol{q})$直接应用有限差分来近似$r_i(\\boldsymbol{q})$，并根据上述几何结构，使用第一性原理，将此近似的准确性与解析推导的梯度进行比较评估。准确性必须使用相对误差 $\\| \\hat{r}_i(\\boldsymbol{q}) - r_i(\\boldsymbol{q}) \\|_2 / \\max(\\| r_i(\\boldsymbol{q}) \\|_2, \\varepsilon)$进行量化，其中$\\varepsilon = 10^{-12}$以避免除以零。所有角度输入均为弧度；距离单位为米；力臂必须以米/弧度为单位处理；最终的准确性值为无量纲。\n\n仅从核心定义（欧几里得范数、旋转矩阵的性质以及关联刚体位置与角度的经典牛顿运动学）出发，推导解析的$r_i(\\boldsymbol{q})$，并使用前向和中心差分格式实现有限差分近似。不要引入任何临时的平滑或正则化处理。\n\n您的程序必须计算并汇总以下测试套件中每个测试用例在一组角度和两条肌腱路径上的最差情况（最大）相对误差。要求的最终输出是单行文本，包含一个用方括号括起来的逗号分隔列表形式的结果。\n\n角度单位：弧度。距离单位：米。力臂单位：米/弧度。准确性输出：无单位浮点数。\n\n测试套件：\n- 测试用例1（通用准确性，理想情况）：中心差分，步长 $h = 10^{-4}$ 弧度，角度集 $S_1 = \\{ (0.3,-0.2), (0.5,0.3), (1.0,-0.6), (0.0,0.0), (1.2,0.5) \\}$。\n- 测试用例2（格式比较）：前向差分，步长 $h = 10^{-4}$ 弧度，角度集 $S_1$ 同上。\n- 测试用例3（步长敏感性，较大步长）：中心差分，步长 $h = 5\\times 10^{-2}$ 弧度，角度集 $S_1$ 同上。\n- 测试用例4（舍入误差敏感性，极小步长）：中心差分，步长 $h = 10^{-8}$ 弧度，角度集 $S_1$ 同上。\n- 测试用例5（几何边界压力测试）：中心差分，步长 $h = 10^{-4}$ 弧度，角度集 $S_2 = \\{ (0.0,0.0), (1.55,-1.55), (1.569,-0.1) \\}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，\"[result1,result2,result3,result4,result5]\"）。每个结果是一个浮点数，等于相应测试用例在两条肌肉和所有角度上的最大相对误差。",
            "solution": "这是一个在计算生物力学领域中定义明确、有科学依据的问题。它提出了一个标准的任务：比较肌肉骨骼模型的解析导数和数值导数。\n\n### I. 理论框架\n\n该问题要求为一个作为生物肢体模型的二维自由度（$2$-DOF）平面机械臂计算肌肉力臂。肌肉$i$的力臂矢量，记为$\\boldsymbol{r}_i(\\boldsymbol{q})$，量化了该肌肉在关节周围产生力矩的有效性。它被正式定义为肌肉总路径长度$L_i$相对于广义坐标（关节角度）矢量$\\boldsymbol{q} = [q_1, q_2]^\\top$的梯度。\n$$\n\\boldsymbol{r}_i(\\boldsymbol{q}) = \\nabla_{\\boldsymbol{q}} L_i(\\boldsymbol{q}) = \\begin{bmatrix} \\frac{\\partial L_i}{\\partial q_1} \\\\ \\frac{\\partial L_i}{\\partial q_2} \\end{bmatrix}\n$$\n每条肌肉的路径表示为连接一系列途经点的折线。总长度$L_i(\\boldsymbol{q})$是连接这些点的线段的欧几里得长度之和。\n\n### II. 力臂的解析推导\n\n设一条肌肉路径由$N+1$个点$\\boldsymbol{p}_0, \\boldsymbol{p}_1, \\dots, \\boldsymbol{p}_N$组成，形成$N$个线段。总长度为：\n$$\nL(\\boldsymbol{q}) = \\sum_{j=1}^{N} \\| \\boldsymbol{p}_j(\\boldsymbol{q}) - \\boldsymbol{p}_{j-1}(\\boldsymbol{q}) \\|_2 = \\sum_{j=1}^{N} \\| \\boldsymbol{u}_j(\\boldsymbol{q}) \\|_2\n$$\n其中$\\boldsymbol{u}_j = \\boldsymbol{p}_j - \\boldsymbol{p}_{j-1}$是第$j$个线段的矢量。长度相对于广义坐标$q_k$的偏导数可使用链式法则求得：\n$$\n\\frac{\\partial L}{\\partial q_k} = \\sum_{j=1}^{N} \\frac{\\partial \\| \\boldsymbol{u}_j \\|_2}{\\partial q_k} = \\sum_{j=1}^{N} \\frac{\\boldsymbol{u}_j^\\top}{\\| \\boldsymbol{u}_j \\|_2} \\frac{\\partial \\boldsymbol{u}_j}{\\partial q_k} = \\sum_{j=1}^{N} \\hat{\\boldsymbol{u}}_j^\\top \\left( \\frac{\\partial \\boldsymbol{p}_j}{\\partial q_k} - \\frac{\\partial \\boldsymbol{p}_{j-1}}{\\partial q_k} \\right)\n$$\n其中$\\hat{\\boldsymbol{u}}_j$是沿第$j$个线段的单位矢量。该公式需要途经点位置的雅可比矩阵$\\frac{\\partial \\boldsymbol{p}_j}{\\partial q_k}$，这些矩阵根据问题中定义的运动学推导得出。\n\n### III. 力臂的数值近似\n\n将解析梯度与通过有限差分获得的数值近似进行比较。\n**前向差分格式** ($O(h)$精度):\n$$\n\\frac{\\partial L(\\boldsymbol{q})}{\\partial q_k} \\approx \\frac{L(\\boldsymbol{q} + h \\boldsymbol{e}_k) - L(\\boldsymbol{q})}{h}\n$$\n**中心差分格式** ($O(h^2)$精度):\n$$\n\\frac{\\partial L(\\boldsymbol{q})}{\\partial q_k} \\approx \\frac{L(\\boldsymbol{q} + h \\boldsymbol{e}_k) - L(\\boldsymbol{q} - h \\boldsymbol{e}_k)}{2h}\n$$\n\n### IV. 算法实现\n\n以下Python代码实现了上述解析和数值方法，并针对给定的测试套件计算了最差情况的相对误差。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the biomechanics problem.\n    It calculates moment arms for a 2-DOF planar arm model analytically and numerically,\n    and computes the worst-case relative error for a suite of test cases.\n    \"\"\"\n\n    # --- Core Kinematic and Geometric Definitions ---\n\n    L1 = 0.30  # meters\n    L2 = 0.25  # meters\n    EPSILON = 1e-12\n\n    def rot_mat(theta):\n        c, s = np.cos(theta), np.sin(theta)\n        return np.array([[c, -s], [s, c]])\n\n    def rot_mat_deriv(theta):\n        c, s = np.cos(theta), np.sin(theta)\n        return np.array([[-s, -c], [c, -s]])\n\n    # Local coordinate vectors for via points\n    # Muscle 1\n    p0_m1_world = np.array([-0.05, 0.12])\n    v1_m1_local = np.array([0.10, 0.03])\n    v2_m1_local = np.array([0.03, 0.02])\n    v3_m1_local = np.array([L2 - 0.02, 0.015])\n    # Muscle 2\n    v0_m2_local = np.array([L1 - 0.02, -0.01])\n    v1_m2_local = np.array([0.02, -0.02])\n    v2_m2_local = np.array([0.6 * L2, 0.015])\n    \n    # --- Position and Jacobian Functions ---\n    \n    class Muscle:\n        def __init__(self, name, point_definitions):\n            self.name = name\n            # point_definitions is a list of tuples:\n            # (pos_func, jac_func, is_fixed)\n            self.point_definitions = point_definitions\n            self.num_points = len(point_definitions)\n\n        def get_points(self, q):\n            return [pd[0](q) for pd in self.point_definitions]\n\n        def get_length(self, q):\n            points = self.get_points(q)\n            length = 0.0\n            for i in range(self.num_points - 1):\n                length += np.linalg.norm(points[i+1] - points[i])\n            return length\n\n        def get_analytical_moment_arm(self, q):\n            points = self.get_points(q)\n            segments = [points[i+1] - points[i] for i in range(self.num_points - 1)]\n            \n            # Add a small value to norm to prevent division by zero for co-located points\n            unit_vectors = [seg / (np.linalg.norm(seg) + EPSILON) for seg in segments]\n            \n            jacs = [pd[1](q) for pd in self.point_definitions]\n\n            r = np.zeros(2)\n            # General formula: r_k = u_N^T * J_N_k - u_1^T * J_0_k + sum_{j=1}^{N-1} (u_j - u_{j+1})^T * J_j_k\n            # where N is number of segments (num_points - 1).\n\n            N = self.num_points - 1\n            # Term for the last point\n            if not self.point_definitions[N][2]: # if not fixed\n                r += jacs[N].T @ unit_vectors[N-1]\n            \n            # Term for the first point\n            if not self.point_definitions[0][2]: # if not fixed\n                r -= jacs[0].T @ unit_vectors[0]\n\n            # Summation for intermediate points\n            for j in range(1, N):\n                if not self.point_definitions[j][2]: # if not fixed\n                    r += jacs[j].T @ (unit_vectors[j-1] - unit_vectors[j])\n            \n            return r\n\n    # --- Muscle 1: Definitions ---\n    def pos_p0_m1(q): return p0_m1_world\n    def jac_p0_m1(q): return np.zeros((2, 2))\n\n    def pos_p1_m1(q): return rot_mat(q[0]) @ v1_m1_local\n    def jac_p1_m1(q): return np.column_stack((rot_mat_deriv(q[0]) @ v1_m1_local, np.zeros(2)))\n\n    def p_elbow(q1): return rot_mat(q1) @ np.array([L1, 0])\n    def jac_p_elbow(q1): return rot_mat_deriv(q1) @ np.array([L1, 0])\n\n    def pos_p2_m1(q): return p_elbow(q[0]) + rot_mat(q[0] + q[1]) @ v2_m1_local\n    def jac_p2_m1(q):\n        dpdq1 = jac_p_elbow(q[0]) + rot_mat_deriv(q[0] + q[1]) @ v2_m1_local\n        dpdq2 = rot_mat_deriv(q[0] + q[1]) @ v2_m1_local\n        return np.column_stack((dpdq1, dpdq2))\n\n    def pos_p3_m1(q): return p_elbow(q[0]) + rot_mat(q[0] + q[1]) @ v3_m1_local\n    def jac_p3_m1(q):\n        dpdq1 = jac_p_elbow(q[0]) + rot_mat_deriv(q[0] + q[1]) @ v3_m1_local\n        dpdq2 = rot_mat_deriv(q[0] + q[1]) @ v3_m1_local\n        return np.column_stack((dpdq1, dpdq2))\n\n    muscle1 = Muscle(\"Muscle 1\", [\n        (pos_p0_m1, jac_p0_m1, True),\n        (pos_p1_m1, jac_p1_m1, False),\n        (pos_p2_m1, jac_p2_m1, False),\n        (pos_p3_m1, jac_p3_m1, False),\n    ])\n\n    # --- Muscle 2: Definitions ---\n    def pos_p0_m2(q): return rot_mat(q[0]) @ v0_m2_local\n    def jac_p0_m2(q): return np.column_stack((rot_mat_deriv(q[0]) @ v0_m2_local, np.zeros(2)))\n        \n    def pos_p1_m2(q): return p_elbow(q[0]) + rot_mat(q[0] + q[1]) @ v1_m2_local\n    def jac_p1_m2(q):\n        dpdq1 = jac_p_elbow(q[0]) + rot_mat_deriv(q[0] + q[1]) @ v1_m2_local\n        dpdq2 = rot_mat_deriv(q[0] + q[1]) @ v1_m2_local\n        return np.column_stack((dpdq1, dpdq2))\n\n    def pos_p2_m2(q): return p_elbow(q[0]) + rot_mat(q[0] + q[1]) @ v2_m2_local\n    def jac_p2_m2(q):\n        dpdq1 = jac_p_elbow(q[0]) + rot_mat_deriv(q[0] + q[1]) @ v2_m2_local\n        dpdq2 = rot_mat_deriv(q[0] + q[1]) @ v2_m2_local\n        return np.column_stack((dpdq1, dpdq2))\n\n    muscle2 = Muscle(\"Muscle 2\", [\n        (pos_p0_m2, jac_p0_m2, False),\n        (pos_p1_m2, jac_p1_m2, False),\n        (pos_p2_m2, jac_p2_m2, False),\n    ])\n\n    muscles = [muscle1, muscle2]\n\n    # --- Numerical Differentiation and Error Calculation ---\n    \n    def get_numerical_moment_arm(muscle, q, h, scheme):\n        q1, q2 = q[0], q[1]\n        \n        if scheme == 'central':\n            dq1_plus = np.array([q1 + h, q2])\n            dq1_minus = np.array([q1 - h, q2])\n            dr_dq1 = (muscle.get_length(dq1_plus) - muscle.get_length(dq1_minus)) / (2 * h)\n            \n            dq2_plus = np.array([q1, q2 + h])\n            dq2_minus = np.array([q1, q2 - h])\n            dr_dq2 = (muscle.get_length(dq2_plus) - muscle.get_length(dq2_minus)) / (2 * h)\n        \n        elif scheme == 'forward':\n            base_length = muscle.get_length(q)\n            dq1_plus = np.array([q1 + h, q2])\n            dr_dq1 = (muscle.get_length(dq1_plus) - base_length) / h\n            \n            dq2_plus = np.array([q1, q2 + h])\n            dr_dq2 = (muscle.get_length(dq2_plus) - base_length) / h\n        else:\n            raise ValueError(\"Unknown scheme\")\n            \n        return np.array([dr_dq1, dr_dq2])\n\n    def calculate_relative_error(r_hat, r):\n        r_norm = np.linalg.norm(r)\n        error_norm = np.linalg.norm(r_hat - r)\n        return error_norm / max(r_norm, EPSILON)\n\n    # --- Test Suite Execution ---\n\n    S1 = [(0.3, -0.2), (0.5, 0.3), (1.0, -0.6), (0.0, 0.0), (1.2, 0.5)]\n    S2 = [(0.0, 0.0), (1.55, -1.55), (1.569, -0.1)]\n    \n    test_cases = [\n        {'name': 'Case 1', 'scheme': 'central', 'h': 1e-4, 'angles': S1},\n        {'name': 'Case 2', 'scheme': 'forward', 'h': 1e-4, 'angles': S1},\n        {'name': 'Case 3', 'scheme': 'central', 'h': 5e-2, 'angles': S1},\n        {'name': 'Case 4', 'scheme': 'central', 'h': 1e-8, 'angles': S1},\n        {'name': 'Case 5', 'scheme': 'central', 'h': 1e-4, 'angles': S2},\n    ]\n\n    results = []\n    for case in test_cases:\n        max_error = 0.0\n        for q_tuple in case['angles']:\n            q_vec = np.array(q_tuple)\n            for muscle in muscles:\n                r_analytical = muscle.get_analytical_moment_arm(q_vec)\n                r_numerical = get_numerical_moment_arm(muscle, q_vec, case['h'], case['scheme'])\n                error = calculate_relative_error(r_numerical, r_analytical)\n                if error > max_error:\n                    max_error = error\n        results.append(f\"{max_error:.10g}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```",
            "answer": "[1.503209534e-09,0.0003057424424,0.009404641973,1.111811804e-05,5.101705856e-09]"
        }
    ]
}