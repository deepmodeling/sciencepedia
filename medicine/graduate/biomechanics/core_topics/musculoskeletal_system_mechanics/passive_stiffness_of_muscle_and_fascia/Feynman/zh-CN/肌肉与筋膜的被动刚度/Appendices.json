{
    "hands_on_practices": [
        {
            "introduction": "肌肉和筋膜等生物软组织的力学响应通常是非线性的，这意味着它们的刚度会随着拉伸而变化。本练习旨在通过一个常用的指数应力-应变模型，介绍两个关键的刚度量化指标：切线模量和正割模量，并阐明它们如何揭示组织“应变硬化”的关键特性。通过计算和比较这两个模量，你将深入理解非线性弹性行为的物理意义。",
            "id": "4197239",
            "problem": "在人体腿部筋膜的被动单轴拉伸测试中，柯西应力-工程应变响应在小到中等应变范围内，可以用凸指数关系 $\\sigma(\\varepsilon)=A\\big(\\exp(B\\varepsilon)-1\\big)$ 来描述，其中 $\\sigma$ 是应力，$\\varepsilon$ 是工程应变，$A$ 是刚度标度，$B$ 是非线性参数。考虑一个试样，其拟合参数为 $A=4.5\\,\\text{kPa}$ 和 $B=15$（无量纲）。使用连续介质力学中切线模量（应力-应变曲线的瞬时斜率）和割线模量（从原点出发的平均斜率）的标准定义，确定在 $\\varepsilon=0.1$ 处的这两个模量。将两个模量都以千帕（$\\text{kPa}$）为单位表示，并将您的答案四舍五入到四位有效数字。然后，根据组织的被动响应的非线性来解释这些模量之间的差异。您的最终数值答案必须只提供模量值，不包含解释，而解释应包含在您的推理过程中。",
            "solution": "该问题被认为是有效的，因为它在连续介质力学和生物力学方面有科学依据，问题陈述清晰且提供了所有必要信息，并以客观、正式的语言表达。\n\n腿部筋膜的被动应力-应变关系由以下本构方程给出：\n$$\n\\sigma(\\varepsilon) = A(\\exp(B\\varepsilon) - 1)\n$$\n其中 $\\sigma$ 是柯西应力，$\\varepsilon$ 是工程应变，材料参数为 $A = 4.5 \\, \\text{kPa}$ 和 $B = 15$。我们被要求确定在应变为 $\\varepsilon = 0.1$ 时的切线模量和割线模量。\n\n首先，我们定义切线模量 $E_t$。切线模量是应力-应变曲线上特定点的瞬时斜率，数学上定义为应力对应变的一阶导数。\n$$\nE_t(\\varepsilon) = \\frac{d\\sigma}{d\\varepsilon}\n$$\n我们从给定的应力函数计算这个导数：\n$$\nE_t(\\varepsilon) = \\frac{d}{d\\varepsilon} \\left[ A(\\exp(B\\varepsilon) - 1) \\right] = A \\frac{d}{d\\varepsilon} \\left[ \\exp(B\\varepsilon) - 1 \\right]\n$$\n应用链式法则进行微分，我们得到：\n$$\nE_t(\\varepsilon) = A (B \\exp(B\\varepsilon) - 0) = AB \\exp(B\\varepsilon)\n$$\n现在，我们在指定的应变 $\\varepsilon = 0.1$ 处计算切线模量。\n$$\nE_t(0.1) = AB \\exp(B \\times 0.1) = (4.5 \\, \\text{kPa})(15) \\exp(15 \\times 0.1)\n$$\n$$\nE_t(0.1) = 67.5 \\exp(1.5) \\, \\text{kPa}\n$$\n计算数值：\n$$\nE_t(0.1) \\approx 67.5 \\times 4.48168907 = 302.514012... \\, \\text{kPa}\n$$\n四舍五入到四位有效数字，切线模量为 $302.5 \\, \\text{kPa}$。\n\n其次，我们定义割线模量 $E_s$。割线模量表示从原点 $(\\varepsilon_1=0, \\sigma_1=0)$ 到曲线上一个特定点 $(\\varepsilon_2=\\varepsilon, \\sigma_2=\\sigma(\\varepsilon))$ 的平均刚度。它是连接这两点的弦的斜率。\n$$\nE_s(\\varepsilon) = \\frac{\\sigma(\\varepsilon) - \\sigma(0)}{\\varepsilon - 0} = \\frac{\\sigma(\\varepsilon)}{\\varepsilon}\n$$\n注意 $\\sigma(0) = A(\\exp(B \\times 0) - 1) = A(1-1) = 0$，这与材料在零应变时处于无应力状态是一致的。\n代入 $\\sigma(\\varepsilon)$ 的表达式：\n$$\nE_s(\\varepsilon) = \\frac{A(\\exp(B\\varepsilon) - 1)}{\\varepsilon}\n$$\n现在，我们在指定的应变 $\\varepsilon = 0.1$ 处计算割线模量。\n$$\nE_s(0.1) = \\frac{A(\\exp(B \\times 0.1) - 1)}{0.1} = \\frac{4.5 \\, \\text{kPa} (\\exp(15 \\times 0.1) - 1)}{0.1}\n$$\n$$\nE_s(0.1) = 45 (\\exp(1.5) - 1) \\, \\text{kPa}\n$$\n计算数值：\n$$\nE_s(0.1) \\approx 45 \\times (4.48168907 - 1) = 45 \\times 3.48168907 = 156.676008... \\, \\text{kPa}\n$$\n四舍五入到四位有效数字，割线模量为 $156.7 \\, \\text{kPa}$。\n\n最后，我们解释这两个模量之间的差异。在 $\\varepsilon = 0.1$ 处，我们得到 $E_t \\approx 302.5 \\, \\text{kPa}$ 和 $E_s \\approx 156.7 \\, \\text{kPa}$。切线模量显著大于割线模量（$E_t > E_s$）。这是具有“应变硬化”响应的材料的特征。应力-应变曲线是凸的，意味着它向上弯曲。这种凸性可以通过检查应力对应变的二阶导数来确认：\n$$\n\\frac{d^2\\sigma}{d\\varepsilon^2} = \\frac{d}{d\\varepsilon}(AB \\exp(B\\varepsilon)) = AB^2 \\exp(B\\varepsilon)\n$$\n由于 $A > 0$ 且 $B > 0$，二阶导数总是正的，这证实了应力-应变曲线的严格凸性。对于一个通过原点的凸函数，在任何点 $\\varepsilon > 0$ 处的切线斜率总是大于从原点到该点的割线斜率。\n在物理意义上，割线模量 $E_s$ 代表了组织在从 $0$ 到 $0.1$ 的应变范围内的平均刚度。切线模量 $E_t$ 代表了材料在 $0.1$ 这一特定应变下的瞬时刚度。$E_t$ 几乎是 $E_s$ 的两倍，这一事实表明组织在拉伸时会变得明显更硬。这种非线性的应变硬化行为是许多生物软组织（如筋膜、韧带和肌腱）的关键功能特性。它允许在低应变水平下具有柔韧性和顺应性，同时在较高应变下提供刚度的显著增加，以抵抗过载并防止损伤。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 302.5  156.7 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "除了非线性弹性，肌肉-筋膜单元还表现出显著的粘弹性，即其力学行为同时依赖于形变和形变速率。本练习使用经典的Kelvin–Voigt模型来模拟这种时间依赖性，探索在不同应变速率下组织的“表观刚度”如何变化。通过分析一个斜坡加载过程，你将揭示粘性效应如何导致组织在快速拉伸时表现出更高的刚度，这是理解其动态功能的关键。",
            "id": "4197291",
            "problem": "一个承受小幅度单轴拉伸的被动肌肉-筋膜单元，在一个适合进行线性化处理的应变范围内，通过斜坡-保持方案进行测试。在此范围内，该复合组织可以近似为一个 Kelvin-Voigt 元件，该元件由一个模量为 $E$（单位：千帕）的线性弹性弹簧和一个黏度为 $\\eta$（单位：千帕-秒）的牛顿阻尼器并联组成。假设为准静态条件（惯性可忽略）和等温行为。\n\n施加一个预设的应变历史，其形式为线性斜坡：应变从时间 $t=0$ 时的零应变开始，以恒定的应变率 $\\dot{\\varepsilon}$ 增加，直到在时间 $t=t_{f}$ 时达到最终应变 $\\varepsilon_{f}$，即对于 $0 \\le t \\le t_{f}$ 有 $\\varepsilon(t)=\\dot{\\varepsilon}\\,t$，其中 $t_{f}=\\varepsilon_{f}/\\dot{\\varepsilon}$。连续测量应力，“峰值应力”定义为在斜坡结束时达到的应力，计算为在 $t=t_{f}^{-}$ 处的左极限。\n\n仅使用弹簧和阻尼器的力学本构关系以及并联规则，推导斜坡过程中的峰值应力表达式，然后计算表观刚度（定义为在 $t=t_{f}^{-}$ 时 $K_{\\mathrm{app}}=\\sigma_{\\mathrm{peak}}/\\varepsilon_{f}$）如何随应变率变化。设 $E=120$ 千帕，$\\eta=4.5$ 千帕-秒，$\\varepsilon_{f}=0.12$。考虑两种应变率：一个“慢”斜坡，其应变率为 $\\dot{\\varepsilon}_{1}=0.01$ /秒；一个“快”斜坡，其应变率为 $\\dot{\\varepsilon}_{2}=2.0$ /秒。计算比率 $R=K_{\\mathrm{app}}(\\dot{\\varepsilon}_{2})/K_{\\mathrm{app}}(\\dot{\\varepsilon}_{1})$。将最终答案表示为无量纲比率，并四舍五入到四位有效数字。",
            "solution": "Kelvin-Voigt 模型由一个线性弹性弹簧和一个牛顿阻尼器并联组成。对于并联元件，总应力是各元件应力之和，且两个元件承受相同的应变。线性弹性弹簧的本构关系是 $\\sigma_{\\mathrm{spring}}=E\\,\\varepsilon$，其中 $E$ 是弹性模量，$\\varepsilon$ 是应变。牛顿阻尼器的本构关系是 $\\sigma_{\\mathrm{dashpot}}=\\eta\\,\\dot{\\varepsilon}$，其中 $\\eta$ 是黏度，$\\dot{\\varepsilon}$ 是应变率。因为元件是并联的，总应力为\n$$\n\\sigma(t)=\\sigma_{\\mathrm{spring}}(t)+\\sigma_{\\mathrm{dashpot}}(t)=E\\,\\varepsilon(t)+\\eta\\,\\dot{\\varepsilon}(t).\n$$\n\n在预设的斜坡加载下，应变为 $\\varepsilon(t)=\\dot{\\varepsilon}\\,t$（对于 $0\\le t\\le t_{f}$），其中在斜坡过程中 $\\dot{\\varepsilon}$ 是常数。因此，在斜坡过程中，应力随时间演变为\n$$\n\\sigma(t)=E\\,\\dot{\\varepsilon}\\,t+\\eta\\,\\dot{\\varepsilon}.\n$$\n斜坡过程中的“峰值应力”出现在斜坡结束时，计算为在 $t=t_{f}^{-}$ 处的左极限。代入 $t_{f}=\\varepsilon_{f}/\\dot{\\varepsilon}$ 得\n$$\n\\sigma_{\\mathrm{peak}}=\\lim_{t\\to t_{f}^{-}}\\sigma(t)=E\\,\\dot{\\varepsilon}\\,t_{f}+\\eta\\,\\dot{\\varepsilon}=E\\,\\varepsilon_{f}+\\eta\\,\\dot{\\varepsilon}.\n$$\n将斜坡结束时的表观刚度定义为\n$$\nK_{\\mathrm{app}}=\\frac{\\sigma_{\\mathrm{peak}}}{\\varepsilon_{f}}=\\frac{E\\,\\varepsilon_{f}+\\eta\\,\\dot{\\varepsilon}}{\\varepsilon_{f}}=E+\\frac{\\eta\\,\\dot{\\varepsilon}}{\\varepsilon_{f}}.\n$$\n因此，表观刚度通过 $\\eta\\,\\dot{\\varepsilon}/\\varepsilon_{f}$ 项对应变率产生依赖。在两个不同应变率 $\\dot{\\varepsilon}_{2}$ 和 $\\dot{\\varepsilon}_{1}$ 下的表观刚度之比为\n$$\nR=\\frac{K_{\\mathrm{app}}(\\dot{\\varepsilon}_{2})}{K_{\\mathrm{app}}(\\dot{\\varepsilon}_{1})}\n=\\frac{E+\\dfrac{\\eta\\,\\dot{\\varepsilon}_{2}}{\\varepsilon_{f}}}{E+\\dfrac{\\eta\\,\\dot{\\varepsilon}_{1}}{\\varepsilon_{f}}}.\n$$\n\n现在代入给定值 $E=120$ 千帕，$\\eta=4.5$ 千帕-秒，$\\varepsilon_{f}=0.12$，$\\dot{\\varepsilon}_{1}=0.01$ /秒，以及 $\\dot{\\varepsilon}_{2}=2.0$ /秒。\n\n首先计算分子：\n$$\nK_{\\mathrm{app}}(\\dot{\\varepsilon}_{2})=E+\\frac{\\eta\\,\\dot{\\varepsilon}_{2}}{\\varepsilon_{f}}=120+\\frac{4.5\\times 2.0}{0.12}=120+\\frac{9.0}{0.12}=120+75=195.\n$$\n然后计算分母：\n$$\nK_{\\mathrm{app}}(\\dot{\\varepsilon}_{1})=E+\\frac{\\eta\\,\\dot{\\varepsilon}_{1}}{\\varepsilon_{f}}=120+\\frac{4.5\\times 0.01}{0.12}=120+\\frac{0.045}{0.12}=120+0.375=120.375.\n$$\n因此，\n$$\nR=\\frac{195}{120.375}.\n$$\n计算该比率：\n$$\nR\\approx 1.61994\\ldots\n$$\n四舍五入到四位有效数字，无量纲比率为\n$$\nR=1.620.\n$$\n\n概念解释：在被动肌肉-筋膜的 Kelvin-Voigt 表示中，弹簧贡献了与速率无关的项 $E\\,\\varepsilon_{f}$，而阻尼器贡献了与速率相关的项 $\\eta\\,\\dot{\\varepsilon}$。因此，由斜坡结束时的峰值应力定义的表观刚度 $K_{\\mathrm{app}}$ 随应变率的增加而增加，增加量与 $\\eta\\,\\dot{\\varepsilon}/\\varepsilon_{f}$ 成正比。对于给定的参数，计算出的比率量化了快慢两种斜坡加载下表观刚度的增加情况。",
            "answer": "$$\\boxed{1.620}$$"
        },
        {
            "introduction": "理论模型只有在能够准确描述实验数据时才有价值，而模型中的参数（如 $A$ 和 $B$）必须通过实验来确定。本练习将理论与实践相结合，要求你通过编写程序，将指数模型拟合到给定的应力-应变数据上，并评估所估计参数的置信区间。这项实践不仅能锻炼你的数据分析能力，还能让你理解在量化生物力学特性时，评估参数不确定性的重要性。",
            "id": "4197305",
            "problem": "考虑一个肌肉-筋膜标本的被动应力-应变响应的单轴拉伸测量。令工程应变表示为 $\\varepsilon$（无量纲），柯西应力表示为 $\\sigma$（单位为千帕，kPa）。一个广泛用于被动刚度的唯象模型是以下指数形式\n$$\n\\sigma(\\varepsilon; A, B) = A\\left(e^{B \\varepsilon} - 1\\right),\n$$\n其中 $A$（单位为 kPa）缩放应力大小，$B$（无量纲）控制非线性程度。假设应力中的测量误差是独立同分布 (i.i.d.) 的高斯误差，其均值为零，且在所有应变下具有恒定方差。从最小二乘法的基本原理出发，构建一个程序，通过最小化测量应力与模型预测值之间的残差平方和来估计 $A$ 和 $B$。然后，基于模型在最优点处的局部线性化，评估 $A$ 和 $B$ 的 $95\\%$ 置信区间。\n\n您的程序必须仅使用为每个测试用例提供的据来执行以下步骤：\n1. 针对参数向量 $(A, B)$ 构建非线性最小二乘目标函数。\n2. 通过一种使用模型及其对参数敏感度的合适迭代方法，计算参数估计值 $(\\hat{A}, \\hat{B})$。\n3. 使用在 $(\\hat{A}, \\hat{B})$ 处求值的残差雅可比矩阵，在独立同分布高斯误差假设下，计算参数协方差矩阵的估计值。\n4. 报告 $\\hat{A}$ 和 $\\hat{B}$ 的 95% 置信区间（定义为估计值 $\\pm$ 临界值乘以标准误差）。其中，临界值取自学生t分布，其自由度等于数据点数量减去参数数量。\n\n所有关于 $A$ 及其置信区间边界的答案必须以 kPa 为单位表示。所有关于 $B$ 及其置信区间边界的答案必须表示为无量纲数。\n\n使用以下测量的应变-应力对测试套件，以 $(\\varepsilon_i, \\sigma_i)$ 列表形式提供，其中应力单位为 kPa，应变为无量纲：\n\n测试用例 1 (类肌肉标本，中等非线性):\n- 数据点:\n  - $(0.00, 0.000000)$\n  - $(0.02, 2.356833)$\n  - $(0.04, 6.101896)$\n  - $(0.06, 9.465426)$\n  - $(0.08, 15.206491)$\n  - $(0.10, 20.519382)$\n  - $(0.12, 27.841403)$\n  - $(0.15, 42.080269)$\n  - $(0.18, 59.995770)$\n  - $(0.22, 96.700162)$\n  - $(0.26, 149.264857)$\n  - $(0.30, 227.826443)$\n\n测试用例 2 (类筋膜标本，较高非线性):\n- 数据点:\n  - $(0.00, 0.000000)$\n  - $(0.01, 3.344346)$\n  - $(0.02, 9.066586)$\n  - $(0.03, 13.420137)$\n  - $(0.04, 22.288664)$\n  - $(0.05, 27.692062)$\n  - $(0.06, 39.593606)$\n  - $(0.08, 63.313900)$\n  - $(0.10, 102.792940)$\n  - $(0.13, 185.627600)$\n  - $(0.16, 339.285400)$\n  - $(0.20, 706.964680)$\n\n测试用例 3 (边缘情况：低应变范围和小样本量):\n- 数据点:\n  - $(0.00, 0.000000)$\n  - $(0.01, 0.524692)$\n  - $(0.02, 0.999975)$\n  - $(0.03, 1.617739)$\n  - $(0.05, 2.738870)$\n\n您的程序应生成单行输出，按顺序为每个测试用例包含一个包含六个浮点值的列表 $[\\hat{A}, \\hat{B}, A_{\\text{low}}, A_{\\text{high}}, B_{\\text{low}}, B_{\\text{high}}]$，其中 $A_{\\text{low}}$ 和 $A_{\\text{high}}$ 是 $A$ 的 95% 置信区间的下限和上限（单位为 kPa），$B_{\\text{low}}$ 和 $B_{\\text{high}}$ 是 $B$ 的相应边界（无量纲）。将三个测试用例的结果聚合到一个用方括号括起来的、逗号分隔的列表中。例如，最终输出格式必须严格为\n$$\n[\\,[\\hat{A}_1,\\hat{B}_1,A_{\\text{low},1},A_{\\text{high},1},B_{\\text{low},1},B_{\\text{high},1}],\\,[\\hat{A}_2,\\hat{B}_2,A_{\\text{low},2},A_{\\text{high},2},B_{\\text{low},2},B_{\\text{high},2}],\\,[\\hat{A}_3,\\hat{B}_3,A_{\\text{low},3},A_{\\text{high},3},B_{\\text{low},3},B_{\\text{high},3}]\\,]\n$$\n其中每个数值条目都是一个浮点数。打印的行不得包含任何额外文本。",
            "solution": "用户的请求是数值优化和统计推断领域中的一个有效问题，具体是非线性回归分析在生物力学模型中的应用。该问题具有科学依据，是良构、客观的，并包含了获得唯一解所需的所有必要信息。\n\n### 基于原理的设计\n\n任务是根据给定的实验数据，估计指数应力-应变模型 $\\sigma(\\varepsilon) = A(e^{B\\varepsilon} - 1)$ 的参数 $A$ 和 $B$，并确定它们的 $95\\%$ 置信区间。这是一个经典的非线性最小二乘 (NLLS) 问题。解决方案根据以下原理构建。\n\n#### 1. 非线性最小二乘 (NLLS) 公式\n\n其基本原理是找到参数值 $(\\hat{A}, \\hat{B})$，使模型与测量数据 $(\\varepsilon_i, \\sigma_i)$（其中 $i=1, \\dots, n$）达到最佳拟合。“最佳拟合”是在最小二乘的意义上定义的，该方法假设测量误差是均值为零的独立同分布 (i.i.d.) 高斯随机变量。目标是最小化残差平方和 (RSS)，即观测应力 $\\sigma_i$ 与模型预测应力 $\\sigma(\\varepsilon_i; A, B)$ 之差的平方和。\n\n需要最小化的目标函数是 RSS，表示为 $S(A, B)$：\n$$\nS(A, B) = \\sum_{i=1}^{n} \\left[ \\sigma_i - \\sigma(\\varepsilon_i; A, B) \\right]^2 = \\sum_{i=1}^{n} r_i(A, B)^2\n$$\n其中 $r_i(A, B) = \\sigma_i - A(e^{B\\varepsilon_i} - 1)$ 是第 $i$ 个残差。令 $\\mathbf{p} = [A, B]^T$ 为参数向量。目标是找到 $\\hat{\\mathbf{p}} = \\arg\\min_{\\mathbf{p}} S(\\mathbf{p})$。\n\n#### 2. 迭代优化算法\n\n与线性最小二乘不同，非线性最小二乘问题通常没有闭式解。它们必须通过迭代求解。高斯-牛顿算法及其变体（例如，Levenberg-Marquardt 算法）是标准方法。这些算法从一个初始猜测值 $\\mathbf{p}_0$ 开始，迭代地生成一系列参数估计值 $\\mathbf{p}_k$，这些估计值会收敛到最小值 $\\hat{\\mathbf{p}}$。\n\n这些方法的核心是模型的局部线性近似。在每次迭代 $k$ 中，通过求解一个线性最小二乘问题来找到更新步长 $\\Delta\\mathbf{p}$。高斯-牛顿更新规则由下式给出：\n$$\n\\mathbf{p}_{k+1} = \\mathbf{p}_k + \\Delta\\mathbf{p}_k \\quad \\text{where} \\quad (\\mathbf{J}_k^T \\mathbf{J}_k) \\Delta\\mathbf{p}_k = \\mathbf{J}_k^T \\mathbf{r}_k\n$$\n此处，$\\mathbf{r}_k$ 是在 $\\mathbf{p}_k$ 处求值的残差向量，$\\mathbf{J}_k$ 是*模型函数*关于参数的雅可比矩阵，也在 $\\mathbf{p}_k$ 处求值。雅可比矩阵的元素是模型对参数变化的敏感度：\n$$\n\\mathbf{J}_{ij} = \\frac{\\partial \\sigma(\\varepsilon_i; \\mathbf{p})}{\\partial p_j}\n$$\n对于我们的模型，雅可比矩阵 $\\mathbf{J}$ 的两列是：\n$$\n\\frac{\\partial \\sigma}{\\partial A} = e^{B\\varepsilon_i} - 1\n$$\n$$\n\\frac{\\partial \\sigma}{\\partial B} = A \\varepsilon_i e^{B\\varepsilon_i}\n$$\n实现将利用 `scipy.optimize.least_squares` 函数，该函数采用一种鲁棒的信赖域反射算法，这是高斯-牛顿方法的一种精巧变体。我们将提供解析雅可比矩阵以确保准确性和效率。\n\n#### 3. 置信区间估计\n\n在找到最优参数 $\\hat{\\mathbf{p}} = [\\hat{A}, \\hat{B}]^T$ 后，我们通过构建置信区间来评估这些估计的不确定性。这基于最小二乘估计量在独立同分布高斯误差假设下的统计特性。\n\n该过程依赖于在最优解 $\\hat{\\mathbf{p}}$ 周围对模型进行线性化。在这个线性化体系中，估计量 $\\hat{\\mathbf{p}}$ 近似服从正态分布。参数估计的协方差矩阵 $\\mathbf{C}$ 量化了它们的不确定性和相关性。它通过下式估计：\n$$\n\\mathbf{C} = s^2 (\\mathbf{J}^T \\mathbf{J})^{-1}\n$$\n其中：\n- $\\mathbf{J}$ 是在最优参数 $\\hat{\\mathbf{p}}$ 处求值的模型雅可比矩阵。请注意，一些库使用残差的雅可比矩阵 $\\mathbf{J}_r = -\\mathbf{J}$。由于 $\\mathbf{J}_r^T\\mathbf{J}_r = \\mathbf{J}^T\\mathbf{J}$，公式保持不变。\n- $s^2$ 是误差方差 $\\sigma_{\\text{error}}^2$ 的无偏估计。它是根据最小残差平方和 $S(\\hat{\\mathbf{p}})$ 计算的：\n  $$\n  s^2 = \\frac{S(\\hat{\\mathbf{p}})}{n-p}\n  $$\n  其中 $n$ 是数据点的数量，$p$ 是参数的数量（这里，$p=2$）。$n-p$ 项表示自由度。\n\n协方差矩阵的对角元素 $C_{11}$ 和 $C_{22}$ 分别是 $\\hat{A}$ 和 $\\hat{B}$ 的估计方差。每个参数的标准误差 (SE) 是其方差的平方根：\n$$\n\\text{SE}(\\hat{A}) = \\sqrt{C_{11}} \\quad \\text{and} \\quad \\text{SE}(\\hat{B}) = \\sqrt{C_{22}}\n$$\n\n参数估计值 $\\hat{p}_j$ 的 $(1-\\alpha) \\times 100\\%$ 置信区间构建如下：\n$$\n\\left[ \\hat{p}_j - t_{1-\\alpha/2, n-p} \\cdot \\text{SE}(\\hat{p}_j), \\quad \\hat{p}_j + t_{1-\\alpha/2, n-p} \\cdot \\text{SE}(\\hat{p}_j) \\right]\n$$\n此处，$t_{1-\\alpha/2, n-p}$ 是来自学生t分布的临界值，对应于 $1-\\alpha$ 的置信水平（对于 95% 置信度，$\\alpha=0.05$）和 $n-p$ 的自由度。使用t分布是合适的，因为误差方差 $\\sigma_{\\text{error}}^2$ 是从数据中估计出来的。\n\n该实现将对每个测试用例执行这些步骤，以计算参数估计值及其对应的 95% 置信区间。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Solves for the parameters and confidence intervals for a series of\n    nonlinear regression problems based on a biomechanical model.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        [\n            (0.00, 0.000000), (0.02, 2.356833), (0.04, 6.101896),\n            (0.06, 9.465426), (0.08, 15.206491), (0.10, 20.519382),\n            (0.12, 27.841403), (0.15, 42.080269), (0.18, 59.995770),\n            (0.22, 96.700162), (0.26, 149.264857), (0.30, 227.826443)\n        ],\n        # Test case 2\n        [\n            (0.00, 0.000000), (0.01, 3.344346), (0.02, 9.066586),\n            (0.03, 13.420137), (0.04, 22.288664), (0.05, 27.692062),\n            (0.06, 39.593606), (0.08, 63.313900), (0.10, 102.792940),\n            (0.13, 185.627600), (0.16, 339.285400), (0.20, 706.964680)\n        ],\n        # Test case 3\n        [\n            (0.00, 0.000000), (0.01, 0.524692), (0.02, 0.999975),\n            (0.03, 1.617739), (0.05, 2.738870)\n        ]\n    ]\n\n    all_results = []\n    for case_data in test_cases:\n        data_points = np.array(case_data, dtype=float)\n        epsilon = data_points[:, 0]\n        sigma_obs = data_points[:, 1]\n\n        def model(params, eps):\n            A, B = params\n            return A * (np.exp(B * eps) - 1)\n\n        def residuals(params, eps, sig):\n            return sig - model(params, eps)\n\n        def jacobian_residuals(params, eps, sig):\n            A, B = params\n            jac = np.empty((len(eps), 2), dtype=float)\n            exp_term = np.exp(B * eps)\n            jac[:, 0] = -(exp_term - 1)\n            jac[:, 1] = -A * eps * exp_term\n            return jac\n        \n        # Initial guess for parameters [A, B]\n        # A simple, fixed guess is often sufficient for a robust solver.\n        # Bounds ensure physically plausible (non-negative) parameters.\n        p0 = [10.0, 10.0]\n        bounds = ([0, 0], [np.inf, np.inf])\n\n        # Perform nonlinear least squares optimization\n        res = least_squares(\n            residuals, \n            p0, \n            jac=jacobian_residuals, \n            args=(epsilon, sigma_obs),\n            method='trf',\n            bounds=bounds\n        )\n        A_hat, B_hat = res.x\n        \n        # Calculate confidence intervals\n        n = len(epsilon)  # number of data points\n        p = len(p0)       # number of parameters\n\n        dof = n - p # degrees of freedom\n        \n        # Sum of squared residuals at the optimum\n        S_min = np.sum(res.fun**2)\n        \n        # Estimate of the error variance\n        s2 = S_min / dof\n        \n        # Jacobian of residuals evaluated at the solution\n        Jr = res.jac\n        \n        A_low, A_high, B_low, B_high = (np.nan,) * 4\n        try:\n            # Check for singularity/ill-conditioning\n            if np.linalg.cond(Jr.T @ Jr)  1e15:\n                # Parameter covariance matrix\n                cov_matrix = s2 * np.linalg.inv(Jr.T @ Jr)\n                \n                # Standard errors of parameters\n                se = np.sqrt(np.diag(cov_matrix))\n                se_A, se_B = se\n\n                # Critical value from Student's t-distribution for 95% CI\n                alpha = 0.05\n                t_crit = t.ppf(1 - alpha / 2, df=dof)\n\n                # Confidence intervals\n                A_low = A_hat - t_crit * se_A\n                A_high = A_hat + t_crit * se_A\n                B_low = B_hat - t_crit * se_B\n                B_high = B_hat + t_crit * se_B\n        except (np.linalg.LinAlgError, ValueError):\n            # If matrix is singular or sqrt(negative) (numerical artifact),\n            # CIs cannot be computed. np.nan will be used.\n            pass\n\n        case_results = [A_hat, B_hat, A_low, A_high, B_low, B_high]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified\n    # The format requires a list of lists, with no spaces.\n    outer_list_str = []\n    for res_list in all_results:\n        # Use str() which is sufficient for float representation\n        inner_list_str = f\"[{','.join(map(str, res_list))}]\"\n        outer_list_str.append(inner_list_str)\n    \n    final_output_str = f\"[{','.join(outer_list_str)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}