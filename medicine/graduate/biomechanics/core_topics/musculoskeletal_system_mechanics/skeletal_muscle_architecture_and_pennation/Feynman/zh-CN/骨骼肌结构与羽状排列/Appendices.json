{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在帮助您掌握连接肌肉宏观形态（如体积）与其力量产生能力的基础计算。通过一个简化的羽状肌模型，您将从基本原理出发，推导生理横截面积（PCSA）和最大肌腱力的表达式。这个实践是理解肌肉结构如何决定其功能输出的基石。",
            "id": "4203055",
            "problem": "一个羽状骨骼肌被建模为一束方向一致的肌束，其相对于肌腱轴线具有恒定的羽状角。假设该肌肉处于准静态构型，其体积恒定且肌束长度一致。设肌肉体积为 $V$，肌束长度为 $L_{f}$（沿肌束轴线测量），最大肌肉应力（比张力）为 $\\sigma_{\\max}$（均匀分布在所有肌纤维横截面上），羽状角为 $\\theta$（肌束与肌腱轴线之间的夹角）。生理横截面积（PCSA）定义为所有肌纤维横截面积之和，其中横截面垂直于肌纤维轴线。\n\n仅使用应力（$\\sigma = F/A$）的基本定义、沿肌纤维轴线的体积分解以及力的几何投影，推导计算PCSA和在最大激活状态下传递到肌腱的最大力的表达式。然后，对于数值计算，使用 $V = 250\\,\\text{cm}^{3}$，$L_{f} = 6\\,\\text{cm}$，$\\sigma_{\\max} = 0.3\\,\\text{MPa}$ 和 $\\theta = 20^{\\circ}$。\n\n将生理横截面积以平方米表示，最大肌腱力以牛顿表示。角度以度为单位。将每个最终数值四舍五入到四位有效数字。",
            "solution": "该问题要求推导和计算两个量：生理横截面积（PCSA）和传递到肌腱的最大力（$F_{t}$）。我们将首先根据所提供的定义和原理推导这些量的符号表达式，然后代入给定的数值以求得最终答案。\n\n**1. 生理横截面积（PCSA）的推导**\n\n根据问题定义，生理横截面积（PCSA）是所有肌纤维横截面积之和。肌肉的总体积 $V$ 可以看作是所有肌纤维的体积总和。在一个简化的模型中，如果所有肌纤维的长度 $L_f$ 都一致，那么总体积可以近似表示为生理横截面积与肌纤维长度的乘积：\n$$ V = \\text{PCSA} \\cdot L_{f} $$\n由此，我们可以解出 PCSA 的表达式：\n$$ \\text{PCSA} = \\frac{V}{L_{f}} $$\n\n**2. 最大肌腱力（$F_{t}$）的推导**\n\n肌肉产生的总力 $F_{f}$ 沿着肌纤维的方向，它等于最大肌肉应力（比张力）$\\sigma_{\\max}$ 乘以生理横截面积（PCSA）：\n$$ F_{f} = \\sigma_{\\max} \\cdot \\text{PCSA} $$\n这个力 $F_f$ 作用的方向与肌腱轴线成羽状角 $\\theta$。传递到肌腱的力 $F_t$ 是总肌纤维力 $F_f$ 在肌腱方向上的投影分量。根据三角学原理：\n$$ F_{t} = F_{f} \\cos(\\theta) $$\n将 $F_{f}$ 的表达式代入，得到：\n$$ F_{t} = (\\sigma_{\\max} \\cdot \\text{PCSA}) \\cos(\\theta) $$\n最后，将第一步中推导出的PCSA表达式代入，即可得到完全由初始参数表示的最大肌腱力表达式：\n$$ F_{t} = \\sigma_{\\max} \\left( \\frac{V}{L_{f}} \\right) \\cos(\\theta) $$\n\n**3. 数值计算**\n\n在计算前，需将所有单位转换为国际单位制（SI）：\n给定值：\n$V = 250\\,\\text{cm}^{3} = 250 \\times (10^{-2}\\,\\text{m})^3 = 2.5 \\times 10^{-4}\\,\\text{m}^3$\n$L_{f} = 6\\,\\text{cm} = 0.06\\,\\text{m}$\n$\\sigma_{\\max} = 0.3\\,\\text{MPa} = 0.3 \\times 10^6\\,\\text{Pa} = 3 \\times 10^5\\,\\text{N/m}^2$\n$\\theta = 20^{\\circ}$\n\n**PCSA 计算**：\n$$ \\text{PCSA} = \\frac{V}{L_{f}} = \\frac{2.5 \\times 10^{-4}\\,\\text{m}^3}{0.06\\,\\text{m}} \\approx 4.1666... \\times 10^{-3}\\,\\text{m}^2 $$\n四舍五入到四位有效数字，得到：\n$$ \\text{PCSA} \\approx 4.167 \\times 10^{-3}\\,\\text{m}^2 $$\n\n**最大肌腱力计算**：\n为保证精度，使用未四舍五入的PCSA值进行计算：\n$$ F_{t} = \\sigma_{\\max} \\cdot \\text{PCSA} \\cdot \\cos(\\theta) $$\n$$ F_{t} = (3 \\times 10^5\\,\\text{N/m}^2) \\times (4.1666... \\times 10^{-3}\\,\\text{m}^2) \\times \\cos(20^{\\circ}) $$\n$$ F_{t} = 1250 \\times \\cos(20^{\\circ})\\,\\text{N} $$\n使用 $\\cos(20^{\\circ}) \\approx 0.9396926$：\n$$ F_{t} \\approx 1250 \\times 0.9396926\\,\\text{N} \\approx 1174.6157...\\,\\text{N} $$\n四舍五入到四位有效数字，得到：\n$$ F_{t} \\approx 1175\\,\\text{N} $$\n最终结果是生理横截面积约为 $4.167 \\times 10^{-3}\\,\\text{m}^2$，最大肌腱力约为 $1175\\,\\text{N}$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 4.167 \\times 10^{-3}  1175 \\end{pmatrix}}$$"
        },
        {
            "introduction": "羽状角是肌肉结构中的一个关键变量，它直接影响着肌肉纤维产生的力传递到肌腱的效率。本练习通过一个思想实验，让您量化羽状角变化所带来的几何“成本”。通过假设肌纤维自身产生的力保持恒定，您可以清晰地分离并计算出羽状角对最终输出力（肌腱力）的直接影响。",
            "id": "4203060",
            "problem": "一块单羽状骨骼肌的肌纤维相对于肌腱作用线以羽状角 $\\theta$ 排列。考虑准静态条件，此时肌腱仅传递与肌腱方向一致的肌纤维力分量。假设如下：\n- 在两种不同的结构构型下，肌纤维应力 $\\sigma_{\\text{f}}$ 相同（激活状态相同且肌纤维内在特性恒定）。\n- 单根肌纤维的横截面积 $A_{\\text{f}}$ 和活动肌纤维的数量在不同构型之间不发生变化，因此肌纤维力的大小 $F_{\\text{f}}$ 保持恒定。\n- 横向力传递和腱膜顺应性可忽略不计，因此肌腱力等于所有肌纤维力在肌腱作用线上的投影之和。\n\n从构型1到构型2，羽状角从 $\\theta_{1} = 15^{\\circ}$ 增加到 $\\theta_{2} = 25^{\\circ}$（角度单位为度）。使用向量投影原理和上述假设，计算当羽状角从 $\\theta_{1}$ 变为 $\\theta_{2}$ 时，肌腱方向上的力的分数减少量（以原始值的十进制小数表示，不使用百分号）。将你的答案四舍五入至四位有效数字。最终答案是无单位的，并应以小数形式报告（例如，报告 $0.10$ 表示减少了百分之十）。",
            "solution": "该问题要求计算因肌肉羽状角增加而导致的肌腱力的分数减少量。核心原理是，沿肌腱传递的力是肌纤维产生的总力在肌腱作用线上的投影。\n\n设 $F_T$ 为施加在肌腱上的总力，$\\theta$ 为羽状角。根据问题中的假设，肌纤维产生的总力 $F_{\\text{fibers}}$（在两种构型中保持恒定）与肌腱力之间的关系由下式给出：\n$$ F_T(\\theta) = F_{\\text{fibers}} \\cos(\\theta) $$\n\n我们已知两种构型下的羽状角：\n1.  构型1：$\\theta_1 = 15^{\\circ}$\n2.  构型2：$\\theta_2 = 25^{\\circ}$\n\n对应的肌腱力分别为：\n$$ F_{T1} = F_{\\text{fibers}} \\cos(\\theta_1) $$\n$$ F_{T2} = F_{\\text{fibers}} \\cos(\\theta_2) $$\n\n力的分数减少量定义为力的变化量除以原始力。我们记分数减少量为 $D_{\\text{frac}}$：\n$$ D_{\\text{frac}} = \\frac{F_{T1} - F_{T2}}{F_{T1}} $$\n\n将肌腱力的表达式代入：\n$$ D_{\\text{frac}} = \\frac{F_{\\text{fibers}} \\cos(\\theta_1) - F_{\\text{fibers}} \\cos(\\theta_2)}{F_{\\text{fibers}} \\cos(\\theta_1)} $$\n\n常数项 $F_{\\text{fibers}}$ 可以消去：\n$$ D_{\\text{frac}} = \\frac{\\cos(\\theta_1) - \\cos(\\theta_2)}{\\cos(\\theta_1)} = 1 - \\frac{\\cos(\\theta_2)}{\\cos(\\theta_1)} $$\n\n现在，代入给定的数值 $\\theta_1 = 15^{\\circ}$ 和 $\\theta_2 = 25^{\\circ}$：\n$$ D_{\\text{frac}} = 1 - \\frac{\\cos(25^{\\circ})}{\\cos(15^{\\circ})} $$\n\n进行数值计算：\n$$ \\cos(15^{\\circ}) \\approx 0.9659258 $$\n$$ \\cos(25^{\\circ}) \\approx 0.9063078 $$\n\n$$ D_{\\text{frac}} \\approx 1 - \\frac{0.9063078}{0.9659258} \\approx 1 - 0.9382764 \\approx 0.0617236 $$\n\n根据题目要求，将答案四舍五入到四位有效数字：\n$$ D_{\\text{frac}} \\approx 0.06172 $$\n这个值代表肌腱方向上力的分数减少量。",
            "answer": "$$ \\boxed{0.06172} $$"
        },
        {
            "introduction": "理论模型是理解肌肉功能的有力工具，但其假设必须经过实验数据的检验。这项计算实践将带您从静态的理想模型走向动态收缩的复杂现实。您需要编写代码，利用模拟的动态测量数据（肌腱力和羽状角）来重建肌肉厚度，并以此检验“恒定体积/恒定厚度”这一核心建模假设的有效性。这项练习模拟了生物力学研究中验证模型的核心流程。",
            "id": "4203008",
            "problem": "考虑一个羽状骨骼肌，其模型为不可压缩，并连接在两个不可伸展的平行腱膜之间。设肌纤维长度表示为 $L_f(t)$，羽状角为 $\\theta(t)$，腱膜间距（肌肉厚度）为 $h(t)$，肌腱复合体长度为 $L_{mt}(t)$，肌腱长度为 $L_t(t)$，肌腱力为 $F_t(t)$。假设角度以弧度为单位。对于纤维插入平行腱膜的二维结构理想化模型，使用以下基本几何和力学关系：\n- 沿肌腱轴线的运动学投影：$L_{mt}(t) = L_t(t) + L_f(t)\\cos\\theta(t)$。\n- 厚度与纤维几何形状之间的几何关系：$h(t) = L_f(t)\\sin\\theta(t)$。\n- 具有松弛长度的线性弹性肌腱：$F_t(t) = k_t \\max\\{0, L_t(t) - L_{ts}\\}$，其中 $k_t$ 是刚度，$L_{ts}$ 是松弛长度。\n\n恒定体积厚度模型假设，在不可压缩和腱膜间距变化可忽略的条件下，收缩期间 $h(t)$ 近似恒定，即 $h(t) \\approx h^\\star$。\n\n任务：给定动态收缩期间 $\\theta(t)$ 和 $F_t(t)$ 的时间序列数据，以及已知的 $L_{mt}(t)$、$k_t$ 和 $L_{ts}$，从测量值中重建 $h(t)$，并通过最小二乘法拟合一个常数 $h^\\star$ 来检验恒定体积厚度模型是否能解释该数据。使用由下式定义的归一化均方根误差 (NRMSE) 来量化拟合优度\n$$\n\\mathrm{NRMSE} = \\frac{\\sqrt{\\frac{1}{N}\\sum_{i=1}^N\\big(h_i - h^\\star\\big)^2}}{h^\\star},\n$$\n其中 $h^\\star = \\frac{1}{N}\\sum_{i=1}^N h_i$ 是最佳常数拟合值，$N$ 是时间样本数。\n\n重建过程（将在代码中实现）：\n1. 使用 $L_t(t) = L_{ts} + \\frac{F_t(t)}{k_t}$ 从测量的肌腱力计算 $L_t(t)$，其中 $F_t(t)$ 被截断为非负值（即，如果噪声使其为负，则将其设为零）。\n2. 计算纤维轴投影 $L_f(t)\\cos\\theta(t) = L_{mt}(t) - L_t(t)$。\n3. 使用 $L_f(t) = \\frac{L_{mt}(t) - L_t(t)}{\\cos\\theta(t)}$ 恢复 $L_f(t)$。\n4. 计算重建的厚度时间序列 $h(t) = L_f(t)\\sin\\theta(t)$。\n5. 将 $h^\\star$ 拟合为所有样本上 $h(t)$ 的均值，并评估 $\\mathrm{NRMSE}$。\n\n您必须实现上述过程，并将其应用于以下包含三个合成案例的测试套件。在所有案例中，生成一个时间向量 $t$，包含在 $[0,1]$ 秒内的 $N = 201$ 个均匀间隔点。所有角度必须以弧度计算和使用，所有力以牛顿为单位，所有长度以米为单位。噪声是加性的、独立的、零均值的高斯噪声，具有指定的标准差和指定的随机种子。对于每个案例，首先生成基准信号，然后添加噪声以获得测量的 $\\theta(t)$ 和 $F_t(t)$。\n\n对于每个案例，肌腱力根据几何和肌腱力学按如下方式生成：\n- 给定基准厚度 $h_{\\text{true}}(t)$ 和基准羽状角 $\\theta_{\\text{true}}(t)$，计算基准肌腱长度 $L_t^{\\text{true}}(t) = L_{mt} - h_{\\text{true}}(t)\\cot\\theta_{\\text{true}}(t)$，其中 $\\cot\\theta = \\frac{\\cos\\theta}{\\sin\\theta}$。\n- 计算 $F_t^{\\text{true}}(t) = k_t \\max\\{0, L_t^{\\text{true}}(t) - L_{ts}\\}$。\n- 添加噪声以获得测量的 $\\theta(t)$ 和 $F_t(t)$:\n  - $\\theta(t) = \\theta_{\\text{true}}(t) + \\eta_\\theta(t)$，其中 $\\eta_\\theta(t) \\sim \\mathcal{N}(0, \\sigma_\\theta^2)$。\n  - $F_t(t) = \\max\\{0, F_t^{\\text{true}}(t) + \\eta_F(t)\\}$，其中 $\\eta_F(t) \\sim \\mathcal{N}(0, \\sigma_F^2)$。\n- 对每个案例使用指定的随机数生成器种子，以确保可复现性。\n\n测试套件：\n- 案例 A (与模型一致的动态羽状角，中等角度):\n  - 参数：$L_{mt} = 0.35$ 米，$L_{ts} = 0.18$ 米，$k_t = 50000$ 牛/米，$h_0 = 0.03$ 米。\n  - 基准羽状角：$\\theta_{\\text{true}}(t) = \\theta_0 + \\Delta\\theta \\sin(2\\pi f t)$，其中 $\\theta_0 = 20$ 度，$\\Delta\\theta = 10$ 度，$f = 1$ Hz。通过乘以 $\\pi/180$ 将度转换为弧度。\n  - 基准厚度：$h_{\\text{true}}(t) \\equiv h_0$。\n  - 测量噪声：$\\sigma_\\theta = 0.25$ 度（转换为弧度），$\\sigma_F = 25$ N，随机种子 $= 7$。\n- 案例 B (通过时变厚度违反恒定厚度):\n  - 参数：$L_{mt} = 0.35$ 米，$L_{ts} = 0.18$ 米，$k_t = 50000$ 牛/米，$h_0 = 0.03$ 米。\n  - 基准羽状角：与案例 A 相同。\n  - 基准厚度：$h_{\\text{true}}(t) = h_0\\left(1 + 0.1\\sin(2\\pi f t)\\right)$，其中 $f = 1$ Hz。\n  - 测量噪声：$\\sigma_\\theta = 0.25$ 度（转换为弧度），$\\sigma_F = 25$ N，随机种子 $= 11$。\n- 案例 C (与模型一致，低羽状角作为类边界条件):\n  - 参数：$L_{mt} = 0.25$ 米，$L_{ts} = 0.05$ 米，$k_t = 80000$ 牛/米，$h_0 = 0.01$ 米。\n  - 基准羽状角：$\\theta_{\\text{true}}(t) = \\theta_0 + \\Delta\\theta \\sin(2\\pi f t)$，其中 $\\theta_0 = 5.5$ 度，$\\Delta\\theta = 2.5$ 度，$f = 1$ Hz。通过乘以 $\\pi/180$ 将度转换为弧度。\n  - 基准厚度：$h_{\\text{true}}(t) \\equiv h_0$。\n  - 测量噪声：$\\sigma_\\theta = 0.10$ 度（转换为弧度），$\\sigma_F = 15$ N，随机种子 $= 13$。\n\n实现要求：\n- 对于每个案例，按规定生成 $t$、$\\theta_{\\text{true}}(t)$ 和 $h_{\\text{true}}(t)$，根据几何形状和肌腱刚度计算 $F_t^{\\text{true}}(t)$，然后使用指定的标准差和随机种子添加噪声，以获得测量的 $\\theta(t)$ 和 $F_t(t)$。\n- 仅使用测量的 $\\theta(t)$ 和 $F_t(t)$ 以及该案例已知的 $L_{mt}$、$k_t$ 和 $L_{ts}$，重建 $h(t)$ 并计算最佳常数 $h^\\star$ 的 $\\mathrm{NRMSE}$。\n- 在所有计算步骤中，角度必须以弧度为单位。力以牛顿为单位，长度以米为单位。\n- 您的程序应生成单行输出，其中包含案例 A、B 和 C 的三个 $\\mathrm{NRMSE}$ 值，分别四舍五入到六位小数，并以逗号分隔的列表形式包含在方括号中（例如，“[0.012345,0.067890,0.001234]”）。",
            "solution": "本题要求实现一个重建算法，用以检验羽状肌模型中的“恒定体积厚度”假说，并在三个合成测试案例上评估其性能。我们将首先概述所使用的肌肉骨骼模型，然后详细说明数据生成和厚度重建的步骤，最后解释如何使用归一化均方根误差 (NRMSE) 来量化模型的有效性。\n\n**1. 肌肉骨骼模型概述**\n\n该问题将羽状肌建模为一组长度为 $L_f(t)$ 的肌纤维，其相对于肌肉作用线的方向由羽状角 $\\theta(t)$ 定义。这些肌纤维附着在两个平行的腱膜上，腱膜之间的距离定义了肌肉厚度 $h(t)$。整个肌腱复合体单元长度为 $L_{mt}(t)$，包含一个长度为 $L_t(t)$ 的弹性肌腱。该几何结构决定了两个基本关系：\n\n- 肌肉厚度是肌纤维长度在垂直于作用线方向上的投影：\n  $$h(t) = L_f(t)\\sin\\theta(t)$$\n- 肌腱复合体总长度是肌腱长度与肌纤维长度在作用线方向上投影的总和：\n  $$L_{mt}(t) = L_t(t) + L_f(t)\\cos\\theta(t)$$\n\n联立这两个方程可以将一个变量用其他变量表示。例如，从第一个方程解出 $L_f(t)$ 并代入第二个方程，可得：\n$$L_{mt}(t) = L_t(t) + \\frac{h(t)}{\\sin\\theta(t)}\\cos\\theta(t) = L_t(t) + h(t)\\cot\\theta(t)$$\n\n肌腱被建模为一个刚度为 $k_t$、松弛长度为 $L_{ts}$ 的线性弹簧。它只承受拉伸力，因此力-长度关系为：\n$$F_t(t) = k_t \\max\\{0, L_t(t) - L_{ts}\\}$$\n\n需要测试的核心假说是恒定体积（等容）假设，在腱膜应变可忽略不计的条件下，该假设简化为肌肉厚度近似恒定，即 $h(t) \\approx h^\\star$。\n\n**2. 数据生成方法**\n\n为测试重建算法，我们首先生成已知其基准真相的合成数据。每个测试案例的流程如下：\n\n- 创建一个时间向量 $t$，包含从 $t=0$ 到 $t=1$ 秒的 $N=201$ 个点。\n- 根据每个案例的规格生成羽状角 $\\theta_{\\text{true}}(t)$ 和肌肉厚度 $h_{\\text{true}}(t)$ 的基准时间序列。所有以度为单位给出的角度都转换为弧度。\n- 使用几何关系 $L_{mt}(t) = L_t(t) + h(t)\\cot\\theta(t)$，我们计算满足该几何关系所需的基准肌腱长度：\n  $$L_t^{\\text{true}}(t) = L_{mt} - h_{\\text{true}}(t)\\cot\\theta_{\\text{true}}(t)$$\n  在这里，$L_{mt}$ 在每个案例中都作为常数给出。\n- 然后，根据肌腱的力学特性计算出基准肌腱力 $F_t^{\\text{true}}(t)$：\n  $$F_t^{\\text{true}}(t) = k_t \\max\\{0, L_t^{\\text{true}}(t) - L_{ts}\\}$$\n- 为了模拟真实的测量条件，我们向基准信号添加零均值高斯噪声。指定的随机种子确保了可复现性。\n  $$\\theta(t) = \\theta_{\\text{true}}(t) + \\eta_\\theta(t), \\quad \\text{其中 } \\eta_\\theta \\sim \\mathcal{N}(0, \\sigma_\\theta^2)$$\n  $$F_t(t) = \\max\\{0, F_t^{\\text{true}}(t) + \\eta_F(t)\\}, \\quad \\text{其中 } \\eta_F \\sim \\mathcal{N}(0, \\sigma_F^2)$$\n  得到的 $\\theta(t)$ 和 $F_t(t)$ 作为我们重建算法的“测量”输入。\n\n**3. 重建算法**\n\n目标是从测量量——肌腱力 $F_t(t)$ 和羽状角 $\\theta(t)$——反向推算，以估计肌肉厚度 $h(t)$。已知参数为 $L_{mt}$、$L_{ts}$ 和 $k_t$。\n\n- **步骤 1：估计肌腱长度。** 我们反转肌腱的力-长度关系来求得肌腱长度 $L_t(t)$。首先要确保测量的力 $F_t(t)$ 是非负的。\n  $$L_t(t) = L_{ts} + \\frac{F_t(t)}{k_t}$$\n\n- **步骤 2：确定肌纤维长度投影。** 根据整体运动学约束 $L_{mt}(t) = L_t(t) + L_f(t)\\cos\\theta(t)$，我们可以分离出沿肌腱轴投影的肌纤维贡献：\n  $$L_f(t)\\cos\\theta(t) = L_{mt} - L_t(t)$$\n\n- **步骤 3 & 4：重建厚度。** 两个基本几何方程可以结合起来，将厚度 $h(t)$ 与肌纤维的投影长度和羽状角直接关联起来。\n  $$h(t) = L_f(t)\\sin\\theta(t) = \\left(\\frac{L_f(t)\\cos\\theta(t)}{\\cos\\theta(t)}\\right)\\sin\\theta(t) = \\big(L_f(t)\\cos\\theta(t)\\big) \\tan\\theta(t)$$\n  代入步骤 2 的结果，得到时间序列 $h(t)$ 的最终重建公式：\n  $$h(t) = \\left(L_{mt} - L_t(t)\\right) \\tan\\theta(t)$$\n  这种组合形式计算效率很高。\n\n**4. 误差量化**\n\n在重建时间序列 $h(t)$ 之后，我们评估其与恒定厚度模型 $h(t) \\approx h^\\star$ 的符合程度。在最小二乘意义上，最佳常数拟合值就是重建数据的平均值：\n$$h^\\star = \\frac{1}{N}\\sum_{i=1}^N h_i$$\n重建厚度与此常数值的偏差通过归一化均方根误差 (NRMSE) 来量化。该度量是信号的标准差除以其平均值，也称为变异系数。\n$$\\mathrm{NRMSE} = \\frac{\\sqrt{\\frac{1}{N}\\sum_{i=1}^N\\big(h_i - h^\\star\\big)^2}}{h^\\star} = \\frac{\\sigma_h}{h^\\star}$$\n较小的 NRMSE 表示重建的厚度 $h(t)$ 变异性低，能很好地被一个常数近似，从而支持给定数据的恒定体积厚度模型。较大的 NRMSE 则表明该模型拟合不佳，原因可能是基础生理学违反了该假设（如案例 B），或者噪声和数值敏感性降低了重建的准确性（如案例 C 中可能出现的问题）。通过比较三个测试案例的 NRMSE，我们可以评估模型和重建方法的稳健性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the three test cases and print the results.\n    \"\"\"\n    \n    test_cases = [\n        # Case A\n        {\n            \"name\": \"A\",\n            \"L_mt\": 0.35, \"L_ts\": 0.18, \"k_t\": 50000, \"h_0\": 0.03,\n            \"theta_0_deg\": 20, \"delta_theta_deg\": 10, \"f\": 1.0,\n            \"h_true_func\": lambda h0, t, f: np.full_like(t, h0),\n            \"sigma_theta_deg\": 0.25, \"sigma_F\": 25, \"seed\": 7\n        },\n        # Case B\n        {\n            \"name\": \"B\",\n            \"L_mt\": 0.35, \"L_ts\": 0.18, \"k_t\": 50000, \"h_0\": 0.03,\n            \"theta_0_deg\": 20, \"delta_theta_deg\": 10, \"f\": 1.0,\n            \"h_true_func\": lambda h0, t, f: h0 * (1 + 0.1 * np.sin(2 * np.pi * f * t)),\n            \"sigma_theta_deg\": 0.25, \"sigma_F\": 25, \"seed\": 11\n        },\n        # Case C\n        {\n            \"name\": \"C\",\n            \"L_mt\": 0.25, \"L_ts\": 0.05, \"k_t\": 80000, \"h_0\": 0.01,\n            \"theta_0_deg\": 5.5, \"delta_theta_deg\": 2.5, \"f\": 1.0,\n            \"h_true_func\": lambda h0, t, f: np.full_like(t, h0),\n            \"sigma_theta_deg\": 0.10, \"sigma_F\": 15, \"seed\": 13\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        nrmse = calculate_nrmse_for_case(params)\n        results.append(nrmse)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef calculate_nrmse_for_case(params):\n    \"\"\"\n    Performs the full simulation and reconstruction for a single test case.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the case.\n\n    Returns:\n        float: The calculated NRMSE value.\n    \"\"\"\n    # Unpack parameters\n    L_mt = params[\"L_mt\"]\n    L_ts = params[\"L_ts\"]\n    k_t = params[\"k_t\"]\n    h_0 = params[\"h_0\"]\n    f = params[\"f\"]\n    seed = params[\"seed\"]\n    sigma_F = params[\"sigma_F\"]\n\n    # Constants and time vector\n    N = 201\n    t = np.linspace(0, 1, N)\n    \n    # Convert angles from degrees to radians\n    deg_to_rad = np.pi / 180.0\n    theta_0_rad = params[\"theta_0_deg\"] * deg_to_rad\n    delta_theta_rad = params[\"delta_theta_deg\"] * deg_to_rad\n    sigma_theta_rad = params[\"sigma_theta_deg\"] * deg_to_rad\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed=seed)\n\n    # --- 1. Generate Ground-Truth Data ---\n    # Ground-truth pennation angle\n    theta_true = theta_0_rad + delta_theta_rad * np.sin(2 * np.pi * f * t)\n    \n    # Ground-truth muscle thickness\n    h_true = params[\"h_true_func\"](h_0, t, f)\n\n    # Ground-truth tendon length from geometry: L_t = L_mt - h * cot(theta)\n    # Using 1/tan(theta) is numerically equivalent and common.\n    Lt_true = L_mt - h_true / np.tan(theta_true)\n\n    # Ground-truth tendon force from linear spring model\n    Ft_true = k_t * np.maximum(0, Lt_true - L_ts)\n\n    # --- 2. Generate Noisy Measurements ---\n    # Generate and add noise to theta\n    eta_theta = rng.normal(0, sigma_theta_rad, N)\n    theta_measured = theta_true + eta_theta\n\n    # Generate and add noise to force, ensuring it is non-negative\n    eta_F = rng.normal(0, sigma_F, N)\n    Ft_measured = np.maximum(0, Ft_true + eta_F)\n\n    # --- 3. Reconstruct Thickness from \"Measured\" Data ---\n    # Step 1: Compute tendon length from measured force\n    Lt_recon = L_ts + Ft_measured / k_t\n\n    # Step 2-4: Reconstruct thickness h(t) = (L_mt - L_t) * tan(theta)\n    # This combines the steps:\n    # Lf_cos = L_mt - Lt_recon\n    # Lf = Lf_cos / np.cos(theta_measured)\n    # h_recon = Lf * np.sin(theta_measured)\n    h_recon = (L_mt - Lt_recon) * np.tan(theta_measured)\n\n    # --- 4. Quantify Fit with NRMSE ---\n    # Best constant fit h_star is the mean of the reconstructed thickness\n    h_star = np.mean(h_recon)\n    \n    # Check for h_star being zero or close to zero to avoid division by zero\n    if np.isclose(h_star, 0):\n        # This case is not expected with the given parameters, but it's robust practice\n        return np.inf\n\n    # Calculate RMSE: sqrt(mean((h_i - h_star)^2)) which is the standard deviation\n    rmse = np.std(h_recon)\n    \n    # Calculate Normalized RMSE\n    nrmse = rmse / h_star\n    \n    return nrmse\n\n# Execute the simulation and print the final answer\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}