{
    "hands_on_practices": [
        {
            "introduction": "要理解粘着斑如何传递力，我们首先需要一个关于它们如何形成的量化模型。本练习将问题简化至其热力学核心，要求您基于二维空间中的质量作用定律等基本原理，推导出在平衡状态下形成的整合素-配体键的预期分数占据率 。通过这种方式，我们为后续更复杂的动力学和力学分析建立了一个基准。",
            "id": "4180468",
            "problem": "考虑一个细胞膜与包覆有配体的细胞外基质形成粘着斑。膜上的整合素受体在粘附界面上与配体结合。假设为一一结合，无协同效应，且分布均匀，因此结合可以被视为发生在两个充分混合的二维平面之间。设整合素受体的总表面密度为 $\\rho_{R}$，配体的总表面密度为 $\\rho_{L}$，二维 (2D) 解离常数为 $K_{d}^{2D}$。在热平衡状态下，利用二维质量作用定律以及每个表面上的质量守恒，推导出一个关于单位面积受体占据分数（定义为 $\\theta = \\rho_{RL} / \\rho_{R}$）的封闭形式解析表达式，其中 $\\rho_{RL}$ 是已结合复合物的表面密度。用 $\\rho_{R}$、$\\rho_{L}$ 和 $K_{d}^{2D}$ 表示您的最终答案。您的最终答案必须是关于 $\\theta$ 的单个解析表达式，并且必须对应于在所有非负参数值下满足 $0 \\leq \\theta \\leq 1$ 的物理上允许的分支。",
            "solution": "该问题被认为是科学基础扎实、提法明确且客观的。它基于化学动力学的既定原理（质量作用定律）和质量守恒，并应用于细胞生物学中受体-配体结合的标准模型。参数和目标都已明确定义，从而可以进行严格的数学推导。因此，有必要提供完整的解答。\n\n受体 ($R$) 和配体 ($L$) 结合形成复合物 ($RL$) 的过程可以用可逆反应表示：\n$$\nR + L \\rightleftharpoons RL\n$$\n在热平衡状态下，游离物质的表面密度与已结合复合物的表面密度之间的关系由二维 (2D) 质量作用定律决定。二维 (2D) 解离常数 $K_{d}^{2D}$ 定义为：\n$$\nK_{d}^{2D} = \\frac{\\rho_{R, \\text{free}} \\rho_{L, \\text{free}}}{\\rho_{RL}}\n$$\n其中 $\\rho_{R, \\text{free}}$ 是游离（未结合）受体的表面密度，$\\rho_{L, \\text{free}}$ 是游离（未结合）配体的表面密度，$\\rho_{RL}$ 是受体-配体复合物的表面密度。\n\n该系统还必须遵守受体和配体的质量守恒原理。总表面密度 $\\rho_{R}$ 和 $\\rho_{L}$ 是恒定的，并且在游离态和结合态之间分配：\n$$\n\\rho_{R} = \\rho_{R, \\text{free}} + \\rho_{RL}\n$$\n$$\n\\rho_{L} = \\rho_{L, \\text{free}} + \\rho_{RL}\n$$\n根据这些守恒方程，我们可以用总密度和已结合复合物密度来表示游离密度：\n$$\n\\rho_{R, \\text{free}} = \\rho_{R} - \\rho_{RL}\n$$\n$$\n\\rho_{L, \\text{free}} = \\rho_{L} - \\rho_{RL}\n$$\n将这些游离密度的表达式代入质量作用定律方程，得到：\n$$\nK_{d}^{2D} = \\frac{(\\rho_{R} - \\rho_{RL})(\\rho_{L} - \\rho_{RL})}{\\rho_{RL}}\n$$\n问题要求的是受体占据分数 $\\theta$ 的表达式，其定义为 $\\theta = \\frac{\\rho_{RL}}{\\rho_{R}}$。我们可以重新整理这个关系式，用 $\\theta$ 和 $\\rho_{R}$ 来表示 $\\rho_{RL}$：\n$$\n\\rho_{RL} = \\theta \\rho_{R}\n$$\n现在，我们将这个 $\\rho_{RL}$ 的表达式代入 $K_{d}^{2D}$ 的方程中：\n$$\nK_{d}^{2D} = \\frac{(\\rho_{R} - \\theta \\rho_{R})(\\rho_{L} - \\theta \\rho_{R})}{\\theta \\rho_{R}}\n$$\n我们可以从分子中的第一项提出 $\\rho_{R}$，并与分母中的 $\\rho_{R}$ 消去：\n$$\nK_{d}^{2D} = \\frac{\\rho_{R}(1 - \\theta)(\\rho_{L} - \\theta \\rho_{R})}{\\theta \\rho_{R}} = \\frac{(1 - \\theta)(\\rho_{L} - \\theta \\rho_{R})}{\\theta}\n$$\n为了求解 $\\theta$，我们将这个方程重新整理成多项式形式。首先，两边同乘以 $\\theta$：\n$$\nK_{d}^{2D} \\theta = (1 - \\theta)(\\rho_{L} - \\theta \\rho_{R})\n$$\n展开右侧：\n$$\nK_{d}^{2D} \\theta = \\rho_{L} - \\theta \\rho_{R} - \\theta \\rho_{L} + \\theta^2 \\rho_{R}\n$$\n将所有项移到一侧，形成一个标准二次方程 $a\\theta^2 + b\\theta + c = 0$ 的形式：\n$$\n(\\rho_{R})\\theta^2 - (\\rho_{R} + \\rho_{L} + K_{d}^{2D})\\theta + \\rho_{L} = 0\n$$\n这是一个关于 $\\theta$ 的二次方程，其系数为 $a = \\rho_{R}$，$b = -(\\rho_{R} + \\rho_{L} + K_{d}^{2D})$ 和 $c = \\rho_{L}$。我们可以使用求根公式 $\\theta = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来求解 $\\theta$：\n$$\n\\theta = \\frac{(\\rho_{R} + \\rho_{L} + K_{d}^{2D}) \\pm \\sqrt{(-(\\rho_{R} + \\rho_{L} + K_{d}^{2D}))^2 - 4(\\rho_{R})(\\rho_{L})}}{2\\rho_{R}}\n$$\n$$\n\\theta = \\frac{(\\rho_{R} + \\rho_{L} + K_{d}^{2D}) \\pm \\sqrt{(\\rho_{R} + \\rho_{L} + K_{d}^{2D})^2 - 4\\rho_{R}\\rho_{L}}}{2\\rho_{R}}\n$$\n这给出了 $\\theta$ 的两个可能的数学解。我们必须选择在所有非负参数值下满足约束条件 $0 \\le \\theta \\le 1$ 的物理上允许的分支。\n\n让我们来检验这两个根。设 $\\theta_{+}$ 是取加号的解，$\\theta_{-}$ 是取减号的解。\n考虑配体密度非常高的情况，即 $\\rho_{L} \\to \\infty$。在这种情况下，我们预期所有受体都会饱和，因此 $\\theta \\to 1$。在我们的二次方程 $(\\rho_{R})\\theta^2 - (\\rho_{R} + \\rho_{L} + K_{d}^{2D})\\theta + \\rho_{L} = 0$ 中，如果我们两边同除以 $\\rho_{L}$，会得到 $(\\frac{\\rho_R}{\\rho_L})\\theta^2 - (\\frac{\\rho_R}{\\rho_L} + 1 + \\frac{K_d^{2D}}{\\rho_L})\\theta + 1 = 0$。当 $\\rho_L \\to \\infty$ 时，方程简化为 $-\\theta + 1 \\approx 0$，即 $\\theta \\approx 1$。\n\n我们来检查哪个根能得到这个结果。\n对于 $\\theta_{+}$ 根，分子是 $(\\rho_{R} + \\rho_{L} + K_{d}^{2D}) + \\sqrt{(\\rho_{R} + \\rho_{L} + K_{d}^{2D})^2 - 4\\rho_{R}\\rho_{L}}$。当 $\\rho_{L} \\to \\infty$ 时，分子约增长为 $2\\rho_{L}$，所以 $\\theta_{+} \\approx \\frac{2\\rho_{L}}{2\\rho_{R}} = \\frac{\\rho_{L}}{\\rho_{R}}$。由于 $\\rho_{L} \\to \\infty$，这个根 $\\theta_{+} \\to \\infty$，这是不符合物理实际的。\n\n对于 $\\theta_{-}$ 根，我们面临一个 $\\infty - \\infty$ 的不定式。我们可以通过分子有理化或使用二项式近似来分析其行为。设 $S = \\rho_{R} + \\rho_{L} + K_{d}^{2D}$。\n对于大的 $S$，有 $\\sqrt{S^2 - 4\\rho_{R}\\rho_{L}} = S \\sqrt{1 - \\frac{4\\rho_{R}\\rho_{L}}{S^2}} \\approx S(1 - \\frac{2\\rho_{R}\\rho_{L}}{S^2}) = S - \\frac{2\\rho_{R}\\rho_{L}}{S}$。\n将此代入 $\\theta_{-}$ 的表达式中：\n$$\n\\theta_{-} \\approx \\frac{S - (S - \\frac{2\\rho_{R}\\rho_{L}}{S})}{2\\rho_{R}} = \\frac{2\\rho_{R}\\rho_{L}/S}{2\\rho_{R}} = \\frac{\\rho_{L}}{S} = \\frac{\\rho_{L}}{\\rho_{R} + \\rho_{L} + K_{d}^{2D}}\n$$\n当 $\\rho_{L} \\to \\infty$ 时，$\\theta_{-} \\approx \\frac{\\rho_{L}}{\\rho_{L}} = 1$。这是物理上正确的行为。\n\n另一个简单的检验是考虑没有结合的情况，这对应于 $K_{d}^{2D} \\to \\infty$。在此极限下，我们预期 $\\theta \\to 0$。从近似式 $\\theta_{-} \\approx \\frac{\\rho_{L}}{\\rho_{R} + \\rho_{L} + K_{d}^{2D}}$ 可以清楚地看到，当 $K_{d}^{2D} \\to \\infty$ 时，$\\theta_{-} \\to 0$。然而，$\\theta_{+}$ 根会发散，因为 $\\theta_{+} \\approx \\frac{K_{d}^{2D}}{\\rho_{R}} \\to \\infty$。\n\n因此，物理上正确的解对应于二次求根公式中的减号。\n受体占据分数的封闭形式解析表达式为：\n$$\n\\theta = \\frac{(\\rho_{R} + \\rho_{L} + K_{d}^{2D}) - \\sqrt{(\\rho_{R} + \\rho_{L} + K_{d}^{2D})^2 - 4\\rho_{R}\\rho_{L}}}{2\\rho_{R}}\n$$\n对于所有符合物理实际的参数（$\\rho_{R} > 0$, $\\rho_{L} \\ge 0$, $K_{d}^{2D} \\ge 0$），该表达式都满足条件 $0 \\le \\theta \\le 1$。",
            "answer": "$$\n\\boxed{\\frac{\\rho_{R} + \\rho_{L} + K_{d}^{2D} - \\sqrt{(\\rho_{R} + \\rho_{L} + K_{d}^{2D})^{2} - 4\\rho_{R}\\rho_{L}}}{2\\rho_{R}}}\n$$"
        },
        {
            "introduction": "单个分子键对力的响应是力学转导的基本构成单元。本练习超越了简单的模型，探索了整合素键复杂的“捕获-滑移”（catch-slip）行为，即力在导致其断裂之前，反而会矛盾地增强分子键的结合。您将精确计算发生这种转变的临界力 $F^*$，这是定义分子键承载能力的关键参数 。",
            "id": "4180501",
            "problem": "细胞的黏着斑通过整合素-配体键将肌动球蛋白产生的张力传递到细胞外基质。在负载下，单个整合素-配体键可以通过两条平行的热激活通路解离：一条是构象稳定的“捕获”(catch)通路，另一条是空间受限的“滑动”(slip)通路。使用以下与过渡态理论 (Eyring–Bell 模型) 和热激活一致的机理基础：\n\n- 对于一个具有力依赖性活化能垒 $\\Delta G^{\\ddagger}(F)$ 的通路，其解离速率为 $k(F)=k_{0}\\,\\exp\\!\\left(-\\Delta G^{\\ddagger}(F)/(k_{B}T)\\right)$，其中 $k_{0}$ 是尝试频率，$k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度。\n- 在“捕获”通路中，施加的拉伸力 $F$ 使能垒增加，即 $\\Delta G^{\\ddagger}_{c}(F)=\\Delta G^{\\ddagger}_{c}(0)+F x_{c}$，其中特征长度 $x_{c}>0$，导致速率随力的增加而减小。\n- 在“滑动”通路中，施加的拉伸力 $F$ 使能垒降低，即 $\\Delta G^{\\ddagger}_{s}(F)=\\Delta G^{\\ddagger}_{s}(0)-F x_{s}$，其中特征长度 $x_{s}>0$，导致速率随力的增加而增大。\n- 假设通路是独立平行的，单个键在力作用下的总解离速率是各通路速率之和。\n\n考虑在温度 $T$ 下的一个整合素-纤连蛋白键，其参数 $k_{c0}$、$k_{s0}$、$x_{c}$ 和 $x_{s}$ 由零力通路速率和能垒距离定义。令 $k_{\\text{off}}(F)$ 表示总解离速率，作为每个键所受力 $F$ 的函数。承载接合的开始对应于每个键所受的力 $F^{\\ast}$，在该力下，初始随 $F$ 减小的 $k_{\\text{off}}(F)$ 转变为随 $F$ 增大，即 $k_{\\text{off}}(F)$ 相对于 $F$ 有一个极值。\n\n给定 $k_{c0}=1.0\\,\\text{s}^{-1}$、$k_{s0}=0.50\\,\\text{s}^{-1}$、$x_{c}=0.60\\,\\text{nm}$、$x_{s}=0.30\\,\\text{nm}$ 和 $T=310\\,\\text{K}$，确定每个键的临界力 $F^{\\ast}$，在该力下，$k_{\\text{off}}(F)$ 停止随 $F$ 减小并开始增大。将你的答案四舍五入到三位有效数字。以皮牛顿 (pN) 为单位表示最终的力。",
            "solution": "其物理基础是越过经力修饰的能垒的热激活过程。对于每个通路 $i\\in\\{c,s\\}$，过渡态理论 (Eyring–Bell 模型) 给出\n$$\nk_{i}(F)=k_{i0}\\,\\exp\\!\\left(-\\frac{\\Delta G^{\\ddagger}_{i}(F)}{k_{B}T}\\right),\n$$\n其中 $k_{i0}$ 是指前因子。指定的能垒对力的线性依赖关系得出\n$$\n\\Delta G^{\\ddagger}_{c}(F)=\\Delta G^{\\ddagger}_{c}(0)+F x_{c},\\quad \\Delta G^{\\ddagger}_{s}(F)=\\Delta G^{\\ddagger}_{s}(0)-F x_{s}.\n$$\n因此，\n$$\nk_{c}(F)=k_{c0}\\,\\exp\\!\\left(-\\frac{F x_{c}}{k_{B}T}\\right),\\qquad\nk_{s}(F)=k_{s0}\\,\\exp\\!\\left(\\frac{F x_{s}}{k_{B}T}\\right),\n$$\n其中 $k_{c0}=k_{c}(0)$ 和 $k_{s0}=k_{s}(0)$ 吸收了零力能垒项。对于独立的平行通路，总解离速率是各项之和\n$$\nk_{\\text{off}}(F)=k_{c}(F)+k_{s}(F)=k_{c0}\\,\\exp\\!\\left(-\\frac{F x_{c}}{k_{B}T}\\right)+k_{s0}\\,\\exp\\!\\left(\\frac{F x_{s}}{k_{B}T}\\right).\n$$\n“捕获”机制对应于 $k_{\\text{off}}(F)$ 初始时随 $F$ 的增加而减小。从减小到增大的转变由极值条件确定\n$$\n\\frac{d k_{\\text{off}}}{dF}=0.\n$$\n求导得，\n$$\n\\frac{d k_{\\text{off}}}{dF}=-\\frac{x_{c}}{k_{B}T}\\,k_{c0}\\,\\exp\\!\\left(-\\frac{F x_{c}}{k_{B}T}\\right)+\\frac{x_{s}}{k_{B}T}\\,k_{s0}\\,\\exp\\!\\left(\\frac{F x_{s}}{k_{B}T}\\right).\n$$\n令 $\\frac{d k_{\\text{off}}}{dF}=0$ 并求解 $F$，\n$$\n-\\frac{x_{c}}{k_{B}T}\\,k_{c0}\\,\\exp\\!\\left(-\\frac{F x_{c}}{k_{B}T}\\right)+\\frac{x_{s}}{k_{B}T}\\,k_{s0}\\,\\exp\\!\\left(\\frac{F x_{s}}{k_{B}T}\\right)=0,\n$$\n这意味着\n$$\nx_{s}\\,k_{s0}\\,\\exp\\!\\left(\\frac{F x_{s}}{k_{B}T}\\right)=x_{c}\\,k_{c0}\\,\\exp\\!\\left(-\\frac{F x_{c}}{k_{B}T}\\right).\n$$\n整理得，\n$$\n\\exp\\!\\left(\\frac{F(x_{s}+x_{c})}{k_{B}T}\\right)=\\frac{x_{c}\\,k_{c0}}{x_{s}\\,k_{s0}},\n$$\n所以临界力为\n$$\nF^{\\ast}=\\frac{k_{B}T}{x_{s}+x_{c}}\\,\\ln\\!\\left(\\frac{x_{c}\\,k_{c0}}{x_{s}\\,k_{s0}}\\right).\n$$\n对于初始的捕获机制，需要满足 $x_{c}\\,k_{c0}>x_{s}\\,k_{s0}$，这使得对数为正，从而 $F^{\\ast}>0$。\n\n现在代入给定参数。首先计算 $T=310\\,\\text{K}$ 时的 $k_{B}T$：\n$$\nk_{B}=1.380649\\times 10^{-23}\\,\\text{J/K},\\quad T=310\\,\\text{K}\\quad\\Rightarrow\\quad k_{B}T=1.380649\\times 10^{-23}\\times 310\\,\\text{J}.\n$$\n数值上，\n$$\nk_{B}T=4.280012\\times 10^{-21}\\,\\text{J}.\n$$\n使用 $1\\,\\text{J}=10^{21}\\,\\text{pN}\\cdot\\text{nm}$ 将 $k_{B}T$ 转换为皮牛顿-纳米单位：\n$$\nk_{B}T=4.280012\\,\\text{pN}\\cdot\\text{nm}.\n$$\n计算分母 $x_{s}+x_{c}$：\n$$\nx_{s}+x_{c}=0.30\\,\\text{nm}+0.60\\,\\text{nm}=0.90\\,\\text{nm}.\n$$\n计算对数的自变量：\n$$\n\\frac{x_{c}k_{c0}}{x_{s}k_{s0}}=\\frac{0.60\\times 1.0}{0.30\\times 0.50}=\\frac{0.60}{0.15}=4.0.\n$$\n因此，\n$$\nF^{\\ast}=\\frac{4.280012\\,\\text{pN}\\cdot\\text{nm}}{0.90\\,\\text{nm}}\\;\\ln(4.0).\n$$\n计算：\n$$\n\\frac{4.280012}{0.90}\\,\\text{pN}=4.755569\\,\\text{pN},\\quad \\ln(4.0)=1.386294.\n$$\n所以，\n$$\nF^{\\ast}=4.755569\\times 1.386294\\,\\text{pN}=6.59384\\,\\text{pN}.\n$$\n四舍五入到三位有效数字并以皮牛顿表示，每个键的临界力为\n$$\nF^{\\ast}=6.59\\,\\text{pN}.\n$$",
            "answer": "$$\\boxed{6.59}$$"
        },
        {
            "introduction": "粘着斑并非单个分子键，而是由大量分子组成的动态集合。这项计算练习要求您从零开始构建一个“分子离合器”的随机模拟，以捕捉单个分子键结合与解离的随机性 。通过将您的模拟结果与一个确定性的平均场模型进行比较，您将深入理解分子噪声在细胞力学传递中为何以及何时成为一个关键特征。",
            "id": "4180458",
            "problem": "考虑一个随机分子离合器模型，该模型描述了整合素介导的局灶性粘连在肌动蛋白网络和细胞外基质（ECM）之间传递力的过程。假设肌动蛋白网络相对于刚性ECM以恒定速度 $v_{\\mathrm{a}}$ 进行稳定的逆行流动。每个整合素离合器在结合时，如同一个刚度为 $k_{\\mathrm{c}}$ 的线性弹簧，随着肌动蛋白网络的滑动而被拉伸。离合器的结合与脱离是由化学动力学控制的随机结合与解离事件。在本问题中，您将从第一性原理出发，推导出使用随机模拟算法（SSA）生成离合器结合的随机轨迹所需的算法步骤，并将系综平均牵引力与从常微分方程（ODEs）系统获得的确定性平均场预测进行比较。\n\n基本假设和定义：\n- 对肌动蛋白网络使用过阻尼极限下的牛顿第二定律，但施加一个恒定的肌动蛋白逆行流速 $v_{\\mathrm{a}}$，以专注于离合器介导的力传递，而不考虑对 $v_{\\mathrm{a}}$ 的反馈。\n- 胡克定律适用于每个结合的离合器：如果一个结合的离合器在时间 $t$ 的伸长量为 $x_{i}(t)$，则通过该离合器传递的瞬时力为 $f_{i}(t) = k_{\\mathrm{c}} x_{i}(t)$。\n- 当一个离合器在时间 $t_{\\mathrm{bind}}$ 结合时，其伸长量随时间增长，关系为 $x_{i}(t) = v_{\\mathrm{a}} \\left(t - t_{\\mathrm{bind}}\\right)$，直到它脱离。\n- 传递到ECM的总牵引力为 $T(t) = \\sum_{i \\in \\mathcal{B}(t)} k_{\\mathrm{c}} x_{i}(t)$，其中 $\\mathcal{B}(t)$ 是在时间 $t$ 结合的离合器集合。\n- 结合遵循质量作用动力学：每个未结合的离合器以恒定速率 $k_{\\mathrm{on}}$ 结合。\n- 解离是力依赖的，遵循Bell模型：一个结合的离合器以瞬时速率 $k_{\\mathrm{off}}(f) = k_{0} \\exp\\!\\left(f/f_{\\mathrm{d}}\\right)$ 解离，其中 $k_{0}$ 是无负载解离速率，$f_{\\mathrm{d}}$ 是一个特征力标度。\n\n任务：\n1. 从上述基本原理出发，推导在时间 $t_{\\mathrm{bind}}$ 结合的单个离合器的力的时间演化，以及相应的随时间变化的解离风险。利用随时间变化的风险和生存函数之间的关系，概述如何在随机模拟算法（SSA）框架内安排解离事件，而无需假设倾向性为常数。\n2. 使用常微分方程（ODEs）为预期结合离合器数量 $n(t)$ 和结合离合器伸长量总和 $S(t) = \\sum_{i \\in \\mathcal{B}(t)} x_{i}(t)$ 推导系综的平均场确定性描述，确保这些方程与上述物理和动力学假设一致。将牵引力表示为 $T(t) = k_{\\mathrm{c}} S(t)$，并解释在恒定 $v_{\\mathrm{a}}$ 和力依赖性解离的条件下，$S(t)$ 如何演化。\n3. 实现一个完整的程序，该程序能够：\n   - 为一个包含 $N$ 个离合器的群体，在时间范围 $[0,\\, T_{\\mathrm{end}}]$ 内，生成 $M$ 条独立的 $T(t)$ 的SSA轨迹。\n   - 在均匀间隔的采样时间点计算系综平均牵引力 $\\langle T(t) \\rangle$。\n   - 求解确定性平均场ODEs，以在相同的采样时间点预测 $T_{\\mathrm{ODE}}(t)$。\n   - 对每个测试用例，返回一个标量值，该值等于在采样网格上 $\\langle T(t) \\rangle$ 和 $T_{\\mathrm{ODE}}(t)$ 之间的均方根（RMS）差异。\n4. 实现必须使用科学上一致的国际单位制（SI units），所有输出必须以牛顿（N）为单位表示。RMS差异必须以牛顿为单位的浮点数形式返回。\n5. 您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[r1,r2,r3]”）。\n\n测试套件：\n对于所有情况，使用恒定的肌动蛋白速度 $v_{\\mathrm{a}} = 2 \\times 10^{-8}$ m/s，系综大小为 $M = 100$ 条轨迹，在 $[0,\\, T_{\\mathrm{end}}]$（其中 $T_{\\mathrm{end}} = 10$ s）上采样间隔为 $\\Delta t = 0.1$ s。使用以下参数集，每个参数均以国际单位制表示：\n- 情况A（一般情况）：$N = 40$, $k_{\\mathrm{on}} = 0.5\\, \\mathrm{s}^{-1}$, $k_{0} = 0.1\\, \\mathrm{s}^{-1}$, $k_{\\mathrm{c}} = 2 \\times 10^{-3}\\, \\mathrm{N/m}$, $f_{\\mathrm{d}} = 5 \\times 10^{-12}\\, \\mathrm{N}$。\n- 情况B（结合限制边界）：$N = 40$, $k_{\\mathrm{on}} = 0.02\\, \\mathrm{s}^{-1}$, $k_{0} = 0.1\\, \\mathrm{s}^{-1}$, $k_{\\mathrm{c}} = 2 \\times 10^{-3}\\, \\mathrm{N/m}$, $f_{\\mathrm{d}} = 5 \\times 10^{-12}\\, \\mathrm{N}$。\n- 情况C（刚性离合器边缘情况）：$N = 40$, $k_{\\mathrm{on}} = 0.5\\, \\mathrm{s}^{-1}$, $k_{0} = 0.1\\, \\mathrm{s}^{-1}$, $k_{\\mathrm{c}} = 1 \\times 10^{-2}\\, \\mathrm{N/m}$, $f_{\\mathrm{d}} = 5 \\times 10^{-12}\\, \\mathrm{N}$。\n\n最终输出规格：\n您的程序应生成单行输出，其中包含情况A、情况B和情况C的三个RMS差异，分别为一个用方括号括起来的逗号分隔列表。每个条目必须是一个以牛顿为单位的浮点数，在整个时间范围和采样网格上计算得出，例如：“[0.000123,0.000456,0.000789]”。",
            "solution": "该问题被认为是有效的，因为它科学上基于成熟的力学生物学原理，问题设定良好并提供了所有必要参数，且其表述是客观的。我们将继续推导必要的理论框架并实现计算解决方案。\n\n解决方案分为三个主要部分，与问题陈述中的任务相对应：首先，为具有状态依赖倾向性的系统推导随机模拟算法（SSA）；其次，使用常微分方程（ODEs）构建确定性平均场模型；第三，实现这两种模型，以计算它们对总牵引力预测的均方根（RMS）差异。\n\n**1. 具有时间依赖倾向性的随机模拟算法（SSA）**\n\n标准的Gillespie SSA算法假设反应倾向性在事件之间是恒定的。在这个模型中，离合器的解离速率是力依赖的，并且由于结合的离合器的力随时间增加，其解离倾向性也是时间依赖的。这需要对标准SSA进行修改。一个在时间 $t_{\\mathrm{bind}}$ 结合的离合器，在稍后时间 $t > t_{\\mathrm{bind}}$ 的伸长量由 $x(t) = v_{\\mathrm{a}}(t - t_{\\mathrm{bind}})$ 给出。它施加的力是 $f(t) = k_{\\mathrm{c}}x(t) = k_{\\mathrm{c}}v_{\\mathrm{a}}(t - t_{\\mathrm{bind}})$。根据Bell模型，瞬时解离速率，或称风险率，为 $h(t) = k_{\\mathrm{off}}(f(t)) = k_{0} \\exp\\left(\\frac{f(t)}{f_{\\mathrm{d}}}\\right)$。代入力表达式，我们得到在 $t_{\\mathrm{bind}}$ 结合的离合器的时间依赖风险率：\n$$h(t) = k_{0} \\exp\\left(\\frac{k_{\\mathrm{c}}v_{\\mathrm{a}}(t - t_{\\mathrm{bind}})}{f_{\\mathrm{d}}}\\right)$$\n为了对该离合器的寿命 $\\Delta t_{\\mathrm{life}} = t_{\\mathrm{unbind}} - t_{\\mathrm{bind}}$ 进行采样，我们可以使用逆变换采样法。生存函数 $S(t)$ 是指离合器到时间 $t$ 尚未解离的概率，它与累积风险函数 $H(t) = \\int_{t_{\\mathrm{bind}}}^{t} h(\\tau)d\\tau$ 的关系为 $S(t) = \\exp(-H(t))$。寿命可以通过找到时间 $t_{\\mathrm{unbind}}$ 来采样，使得累积风险等于一个指数随机变量 $E \\sim \\text{Exp}(1)$，即 $H(t_{\\mathrm{unbind}}) = E$。\n\n首先，我们计算累积风险积分：\n$$H(t) = \\int_{t_{\\mathrm{bind}}}^{t} k_{0} \\exp\\left(\\frac{k_{\\mathrm{c}}v_{\\mathrm{a}}(\\tau - t_{\\mathrm{bind}})}{f_{\\mathrm{d}}}\\right) d\\tau$$\n通过令 $u = \\tau - t_{\\mathrm{bind}}$，上式变为：\n$$H(t) = k_{0} \\int_{0}^{t-t_{\\mathrm{bind}}} \\exp\\left(\\frac{k_{\\mathrm{c}}v_{\\mathrm{a}}u}{f_{\\mathrm{d}}}\\right) du = k_{0} \\left[ \\frac{f_{\\mathrm{d}}}{k_{\\mathrm{c}}v_{\\mathrm{a}}} \\exp\\left(\\frac{k_{\\mathrm{c}}v_{\\mathrm{a}}u}{f_{\\mathrm{d}}}\\right) \\right]_{0}^{t-t_{\\mathrm{bind}}}$$\n$$H(t) = \\frac{k_{0}f_{\\mathrm{d}}}{k_{\\mathrm{c}}v_{\\mathrm{a}}} \\left[ \\exp\\left(\\frac{k_{\\mathrm{c}}v_{\\mathrm{a}}(t - t_{\\mathrm{bind}})}{f_{\\mathrm{d}}}\\right) - 1 \\right]$$\n设 $H(t_{\\mathrm{unbind}}) = E$，其中 $E = -\\ln(r)$ 且 $r \\sim U(0,1)$，我们求解寿命 $\\Delta t_{\\mathrm{life}} = t_{\\mathrm{unbind}} - t_{\\mathrm{bind}}$：\n$$\\frac{k_{0}f_{\\mathrm{d}}}{k_{\\mathrm{c}}v_{\\mathrm{a}}} \\left[ \\exp\\left(\\frac{k_{\\mathrm{c}}v_{\\mathrm{a}}\\Delta t_{\\mathrm{life}}}{f_{\\mathrm{d}}}\\right) - 1 \\right] = E$$\n$$\\exp\\left(\\frac{k_{\\mathrm{c}}v_{\\mathrm{a}}\\Delta t_{\\mathrm{life}}}{f_{\\mathrm{d}}}\\right) = 1 + E \\frac{k_{\\mathrm{c}}v_{\\mathrm{a}}}{k_{0}f_{\\mathrm{d}}}$$\n$$\\Delta t_{\\mathrm{life}} = \\frac{f_{\\mathrm{d}}}{k_{\\mathrm{c}}v_{\\mathrm{a}}} \\ln\\left(1 + E \\frac{k_{\\mathrm{c}}v_{\\mathrm{a}}}{k_{0}f_{\\mathrm{d}}}\\right)$$\n这个关键结果使我们能够在任何离合器结合的瞬间预先计算出其确切的解离时间。对于未结合的离合器，结合事件以恒定速率 $k_{\\mathrm{on}}$ 发生。这将问题转化为一个离散事件模拟，其中未来的事件（结合和解离）可以在一个优先队列中进行调度。该算法按时间顺序处理事件。\n\n**2. 平均场常微分方程（ODE）模型**\n\n为了推导确定性描述，我们对预期结合离合器数量 $n(t)$ 和预期结合离合器总伸长量 $S(t) = \\mathbb{E}\\left[\\sum_{i \\in \\mathcal{B}(t)} x_i(t)\\right]$ 的演化进行建模。$n(t)$ 的变化率是结合速率减去解离速率：\n$$\\frac{dn}{dt} = \\text{Rate}_{\\text{on}} - \\text{Rate}_{\\text{off}}$$\n结合速率由 $N - n(t)$ 个未结合离合器的质量作用动力学决定：\n$$\\text{Rate}_{\\text{on}} = k_{\\mathrm{on}}(N - n(t))$$\n解离速率是结合的离合器数量乘以一个有效解离速率 $k_{\\mathrm{off,eff}}$。这个有效速率取决于结合离合器上的力分布。在平均场近似中，我们假设所有结合的离合器都承受相同的平均力 $\\langle f \\rangle = \\frac{k_{\\mathrm{c}} S(t)}{n(t)}$。那么有效速率为：\n$$k_{\\mathrm{off,eff}} \\approx k_{0} \\exp\\left(\\frac{\\langle f \\rangle}{f_{\\mathrm{d}}}\\right) = k_{0} \\exp\\left(\\frac{k_{\\mathrm{c}} S(t)}{n(t) f_{\\mathrm{d}}}\\right)$$\n因此，总解离速率为 $\\text{Rate}_{\\text{off}} = n(t) k_{\\mathrm{off,eff}}$。第一个ODE是：\n$$\\frac{dn}{dt} = k_{\\mathrm{on}}(N - n) - n k_{0} \\exp\\left(\\frac{k_{\\mathrm{c}} S}{n f_{\\mathrm{d}}}\\right)$$\n对于总伸长量 $S(t)$，我们考虑其变化率。$n(t)$ 个结合的离合器中，每一个都以速率 $\\frac{dx}{dt} = v_{\\mathrm{a}}$ 伸长。这贡献了 $n(t)v_{\\mathrm{a}}$ 这一项。新结合的离合器伸长量为零。离合器解离时，会将其伸长量从总和中移除。移除的速率是每个离合器的平均伸长量 $\\langle x \\rangle = S(t)/n(t)$ 乘以总解离速率 $n(t)k_{\\mathrm{off,eff}}$。这给出了一个移除项 $(S/n) \\cdot (n k_{\\mathrm{off,eff}}) = S k_{\\mathrm{off,eff}}$。第二个ODE是：\n$$\\frac{dS}{dt} = n v_{\\mathrm{a}} - S k_{0} \\exp\\left(\\frac{k_{\\mathrm{c}} S}{n f_{\\mathrm{d}}}\\right)$$\n这个耦合的ODE系统，初始条件为 $n(0) = 0$ 和 $S(0) = 0$，描述了离合器系统的平均场演化。在 $t=0$ 时，$S/n$ 项是未定式。然而，对于很小的 $t$，$n \\propto t$ 且 $S \\propto t^2$，因此当 $t \\to 0$ 时 $S/n \\to 0$。在数值积分中，我们通过将指数的参数设为0来处理 $n=0$ 的情况。该模型预测的总牵引力为 $T_{\\mathrm{ODE}}(t) = k_{\\mathrm{c}}S(t)$。\n\n**3. 计算实现与比较**\n\n实现遵循推导出的原理。\n\n**SSA 实现**：为 $M$ 条独立轨迹实现了一个离散事件模拟。\n- 一个优先队列（最小堆）用于存储未来事件，每个事件由一个元组 `(time, clutch_index, event_type)` 表示。\n- 最初，$N$ 个离合器都处于未结合状态，通过从速率为 $k_{\\mathrm{on}}$ 的指数分布中抽取等待时间，为每个离合器安排一个‘结合’事件。\n- 模拟通过从队列中顺序提取具有最小时间的事件来进行。\n- 当离合器 $i$ 的‘结合’事件在时间 $t_{\\mathrm{bind}}$ 发生时，其状态更新为‘已结合’。立即使用第1部分推导的公式计算其寿命 $\\Delta t_{\\mathrm{life}}$，并在时间 $t_{\\mathrm{bind}} + \\Delta t_{\\mathrm{life}}$ 安排一个‘解离’事件。\n- 当一个‘解离’事件发生时，其状态更新为‘未结合’，并为其安排一个新的‘结合’事件。\n- 在均匀间隔的采样时间点上计算总牵引力 $T(t) = \\sum_{i \\in \\text{bound}} k_{\\mathrm{c}}v_{\\mathrm{a}}(t - t_{\\mathrm{bind},i})$。\n- 最终的随机牵引力 $\\langle T(t) \\rangle$ 是 $M$ 条个体牵引力轨迹的平均值。\n\n**ODE 实现**：使用 `scipy.integrate` 中的 `solve_ivp` 函数数值求解推导出的关于 $[n(t), S(t)]$ 的两个ODE组成的系统。\n- ODE函数实现了速率方程，并带有一个条件来处理 $n(t) \\approx 0$ 的情况以防止除以零，此时将有效解离速率设置为无负载速率 $k_0$。\n- 求解器以 $t=0$ 时的 $y_0 = [0, 0]$ 初始化，并在与SSA采样相同的时间网格上评估解。然后，确定性牵引力为 $T_{\\mathrm{ODE}}(t) = k_{\\mathrm{c}}S(t)$。\n\n**比较**：在采样网格 $t_k$ 上计算系综平均随机牵引力 $\\langle T(t) \\rangle$ 与确定性牵引力 $T_{\\mathrm{ODE}}(t)$ 之间的均方根（RMS）差异：\n$$\\text{RMS Difference} = \\sqrt{\\frac{1}{N_{\\text{samples}}} \\sum_{k} \\left(\\langle T(t_k) \\rangle - T_{\\mathrm{ODE}}(t_k)\\right)^2}$$\n这个标量值量化了完整随机模拟与其平均场近似之间的差异。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport heapq\n\ndef run_single_ssa_trajectory(params, rng):\n    \"\"\"\n    Runs a single stochastic simulation algorithm (SSA) trajectory for the clutch model.\n    This implementation uses a discrete-event simulation approach with a priority queue.\n    All calculations are performed using scientifically consistent SI units.\n    \"\"\"\n    N, k_on, k_0, k_c, f_d, v_a, T_end, dt = params\n\n    clutch_is_bound = np.zeros(N, dtype=bool)\n    clutch_bind_time = np.full(N, np.nan, dtype=np.float64)\n    event_queue = []  # Min-heap storing (time, clutch_idx, event_type)\n\n    # Schedule initial binding events for all clutches\n    for i in range(N):\n        wait_time = rng.exponential(1.0 / k_on)\n        heapq.heappush(event_queue, (wait_time, i, 'bind'))\n\n    t_samples = np.arange(0.0, T_end + dt / 2.0, dt)\n    traction_trajectory = np.zeros_like(t_samples, dtype=np.float64)\n    sample_idx = 0\n    t_current = 0.0\n\n    while event_queue:\n        if sample_idx >= len(t_samples):\n            break\n\n        t_event, clutch_idx, event_type = heapq.heappop(event_queue)\n        \n        # Process sample points between the current time and the next event time\n        while sample_idx  len(t_samples) and t_samples[sample_idx]  t_event:\n            t_sample = t_samples[sample_idx]\n            current_traction = 0.0\n            bound_indices = np.where(clutch_is_bound)[0]\n            if bound_indices.size > 0:\n                extensions = v_a * (t_sample - clutch_bind_time[bound_indices])\n                current_traction = np.sum(k_c * extensions)\n            traction_trajectory[sample_idx] = current_traction\n            sample_idx += 1\n        \n        if t_event >= T_end + dt/2.0:\n            break\n\n        t_current = t_event\n\n        if event_type == 'bind' and not clutch_is_bound[clutch_idx]:\n            clutch_is_bound[clutch_idx] = True\n            clutch_bind_time[clutch_idx] = t_current\n\n            # Schedule unbinding event using the derived formula for lifetime\n            E = rng.exponential(1.0)\n            alpha = (k_c * v_a) / (k_0 * f_d)\n            if alpha > 1e-9:\n                lifetime = (f_d / (k_c * v_a)) * np.log(1.0 + alpha * E)\n            else:  # Force-independent limit\n                lifetime = E / k_0\n            t_unbind = t_current + lifetime\n            heapq.heappush(event_queue, (t_unbind, clutch_idx, 'unbind'))\n\n        elif event_type == 'unbind' and clutch_is_bound[clutch_idx]:\n            clutch_is_bound[clutch_idx] = False\n            clutch_bind_time[clutch_idx] = np.nan\n\n            # Schedule next binding event\n            wait_time = rng.exponential(1.0 / k_on)\n            heapq.heappush(event_queue, (t_current + wait_time, clutch_idx, 'bind'))\n\n    # Fill in any remaining sample points after the final event\n    while sample_idx  len(t_samples):\n        t_sample = t_samples[sample_idx]\n        current_traction = 0.0\n        bound_indices = np.where(clutch_is_bound)[0]\n        if bound_indices.size > 0:\n            extensions = v_a * (t_sample - clutch_bind_time[bound_indices])\n            current_traction = np.sum(k_c * extensions)\n        traction_trajectory[sample_idx] = current_traction\n        sample_idx += 1\n        \n    return traction_trajectory\n\n\ndef ode_system(t, y, N, k_on, k_0, k_c, f_d, v_a):\n    \"\"\"\n    Defines the system of ODEs for the mean-field model.\n    y = [n, S], where n is the number of bound clutches and S is the sum of their extensions.\n    \"\"\"\n    n, S = y\n    \n    # Handle the n=0 case to avoid division by zero.\n    # As t-0, n-0 and S-0, but S/n - 0, so the average force is 0.\n    if n  1e-9:\n        k_off_eff = k_0\n    else:\n        avg_force_per_clutch = (k_c * S) / n\n        k_off_eff = k_0 * np.exp(avg_force_per_clutch / f_d)\n    \n    dndt = k_on * (N - n) - n * k_off_eff\n    dSdt = n * v_a - S * k_off_eff\n    \n    return [dndt, dSdt]\n\ndef solve():\n    \"\"\"\n    Main function to execute the simulation, solve the ODEs, and compute the RMS difference.\n    \"\"\"\n    # Global parameters for all test cases\n    v_a = 2e-8  # m/s\n    M = 100  # number of trajectories\n    T_end = 10.0  # s\n    dt = 0.1  # s\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (general case)\n        {'N': 40, 'k_on': 0.5, 'k_0': 0.1, 'k_c': 2e-3, 'f_d': 5e-12},\n        # Case B (binding-limited boundary)\n        {'N': 40, 'k_on': 0.02, 'k_0': 0.1, 'k_c': 2e-3, 'f_d': 5e-12},\n        # Case C (stiff clutch edge case)\n        {'N': 40, 'k_on': 0.5, 'k_0': 0.1, 'k_c': 1e-2, 'f_d': 5e-12},\n    ]\n\n    results = []\n    # Seed the random number generator for reproducibility of the results.\n    rng = np.random.default_rng(seed=42)\n\n    for case in test_cases:\n        params = (case['N'], case['k_on'], case['k_0'], case['k_c'],\n                  case['f_d'], v_a, T_end, dt)\n\n        # 1. Generate SSA trajectories and compute the ensemble average\n        all_trajectories = []\n        for _ in range(M):\n            traj = run_single_ssa_trajectory(params, rng)\n            all_trajectories.append(traj)\n        \n        # Ensemble-averaged traction from SSA\n        avg_ssa_traction = np.mean(np.array(all_trajectories), axis=0)\n\n        # 2. Solve the deterministic mean-field ODEs\n        t_samples = np.arange(0.0, T_end + dt / 2.0, dt)\n        y0 = [0.0, 0.0]\n        ode_args = (case['N'], case['k_on'], case['k_0'], case['k_c'], case['f_d'], v_a)\n        \n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=[0, T_end],\n            y0=y0,\n            method='RK45',\n            t_eval=t_samples,\n            args=ode_args\n        )\n        \n        # Deterministic traction from ODEs\n        S_ode = sol.y[1]\n        T_ode = case['k_c'] * S_ode\n        \n        # 3. Compute the RMS difference\n        # Ensure arrays are same length in case of small floating point issues at T_end\n        min_len = min(len(avg_ssa_traction), len(T_ode))\n        diff = avg_ssa_traction[:min_len] - T_ode[:min_len]\n        rms_diff = np.sqrt(np.mean(diff**2))\n\n        results.append(rms_diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}