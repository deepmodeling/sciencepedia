{
    "hands_on_practices": [
        {
            "introduction": "在深入研究力如何调节整合素功能之前，我们必须首先理解整合素与配体结合的基本原理。这个练习应用化学中的基本原理——质量作用定律，来模拟在热平衡状态下粘附位点的形成。通过解决这个问题，你将学会如何利用受体和配体的表面密度来预测细胞初始粘附的程度，这是理解粘着斑形成的第一步。",
            "id": "4180468",
            "problem": "考虑一个细胞膜与涂有配体的细胞外基质形成粘着斑。膜上的整合素受体在粘附界面上与配体结合。假设是一对一结合，没有协同性，且分布均匀，因此结合可以被视为发生在两个充分混合的二维平面之间。设整合素受体的总表面密度为 $\\rho_{R}$，配体的总表面密度为 $\\rho_{L}$，二维 (2D) 解离常数为 $K_{d}^{2D}$。在热平衡状态下，利用二维质量作用定律以及每个表面上的质量守恒，推导出一个关于单位面积受体分数占有率的封闭形式解析表达式，其定义为 $\\theta = \\rho_{RL} / \\rho_{R}$，其中 $\\rho_{RL}$ 是结合复合物的表面密度。用 $\\rho_{R}$、$\\rho_{L}$ 和 $K_{d}^{2D}$ 来表示你的最终答案。你的最终答案必须是关于 $\\theta$ 的单个解析表达式，并且必须对应于在所有非负参数值下满足 $0 \\leq \\theta \\leq 1$ 的物理上允许的分支。",
            "solution": "该问题被认为是具有科学依据、提法明确且客观的。它基于化学动力学的既定原理（质量作用定律）和质量守恒，并应用于细胞生物学中受体-配体结合的标准模型。参数和目标都已明确定义，从而可以进行严格的数学推导。因此，有必要提供完整的解答。\n\n受体 ($R$) 和配体 ($L$) 结合形成复合物 ($RL$) 的过程可以用可逆反应表示：\n$$\nR + L \\rightleftharpoons RL\n$$\n在热平衡状态下，游离物质的表面密度与结合复合物的表面密度之间的关系由二维 ($2D$) 质量作用定律决定。二维解离常数 $K_{d}^{2D}$ 定义为：\n$$\nK_{d}^{2D} = \\frac{\\rho_{R, \\text{free}} \\rho_{L, \\text{free}}}{\\rho_{RL}}\n$$\n其中 $\\rho_{R, \\text{free}}$ 是游离（未结合）受体的表面密度，$\\rho_{L, \\text{free}}$ 是游离（未结合）配体的表面密度，而 $\\rho_{RL}$ 是受体-配体复合物的表面密度。\n\n该系统还必须遵守受体和配体的质量守恒原理。总表面密度 $\\rho_{R}$ 和 $\\rho_{L}$ 是恒定的，并被分配到游离态和结合态：\n$$\n\\rho_{R} = \\rho_{R, \\text{free}} + \\rho_{RL}\n$$\n$$\n\\rho_{L} = \\rho_{L, \\text{free}} + \\rho_{RL}\n$$\n根据这些守恒方程，我们可以用总密度和结合复合物密度来表示游离密度：\n$$\n\\rho_{R, \\text{free}} = \\rho_{R} - \\rho_{RL}\n$$\n$$\n\\rho_{L, \\text{free}} = \\rho_{L} - \\rho_{RL}\n$$\n将这些游离密度的表达式代入质量作用定律方程，得到：\n$$\nK_{d}^{2D} = \\frac{(\\rho_{R} - \\rho_{RL})(\\rho_{L} - \\rho_{RL})}{\\rho_{RL}}\n$$\n问题要求得到受体分数占有率 $\\theta$ 的表达式，其定义为 $\\theta = \\frac{\\rho_{RL}}{\\rho_{R}}$。我们可以重新排列此式，用 $\\theta$ 和 $\\rho_{R}$ 来表示 $\\rho_{RL}$：\n$$\n\\rho_{RL} = \\theta \\rho_{R}\n$$\n现在，我们将这个 $\\rho_{RL}$ 的表达式代入 $K_{d}^{2D}$ 的方程中：\n$$\nK_{d}^{2D} = \\frac{(\\rho_{R} - \\theta \\rho_{R})(\\rho_{L} - \\theta \\rho_{R})}{\\theta \\rho_{R}}\n$$\n我们可以从分子中的第一项提出公因子 $\\rho_{R}$，并与分母中的 $\\rho_{R}$ 相消：\n$$\nK_{d}^{2D} = \\frac{\\rho_{R}(1 - \\theta)(\\rho_{L} - \\theta \\rho_{R})}{\\theta \\rho_{R}} = \\frac{(1 - \\theta)(\\rho_{L} - \\theta \\rho_{R})}{\\theta}\n$$\n为了求解 $\\theta$，我们将此方程重新整理成多项式形式。首先，两边同乘以 $\\theta$：\n$$\nK_{d}^{2D} \\theta = (1 - \\theta)(\\rho_{L} - \\theta \\rho_{R})\n$$\n展开右边：\n$$\nK_{d}^{2D} \\theta = \\rho_{L} - \\theta \\rho_{R} - \\theta \\rho_{L} + \\theta^2 \\rho_{R}\n$$\n将所有项移到一边，形成一个标准二次方程 $a\\theta^2 + b\\theta + c = 0$：\n$$\n(\\rho_{R})\\theta^2 - (\\rho_{R} + \\rho_{L} + K_{d}^{2D})\\theta + \\rho_{L} = 0\n$$\n这是一个关于 $\\theta$ 的二次方程，其系数为 $a = \\rho_{R}$，$b = -(\\rho_{R} + \\rho_{L} + K_{d}^{2D})$，以及 $c = \\rho_{L}$。我们可以使用二次公式 $\\theta = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来求解 $\\theta$：\n$$\n\\theta = \\frac{(\\rho_{R} + \\rho_{L} + K_{d}^{2D}) \\pm \\sqrt{(-(\\rho_{R} + \\rho_{L} + K_{d}^{2D}))^2 - 4(\\rho_{R})(\\rho_{L})}}{2\\rho_{R}}\n$$\n$$\n\\theta = \\frac{(\\rho_{R} + \\rho_{L} + K_{d}^{2D}) \\pm \\sqrt{(\\rho_{R} + \\rho_{L} + K_{d}^{2D})^2 - 4\\rho_{R}\\rho_{L}}}{2\\rho_{R}}\n$$\n这给出了 $\\theta$ 的两个可能的数学解。我们必须选择在所有非负参数值下都满足约束条件 $0 \\le \\theta \\le 1$ 的物理上允许的分支。\n\n我们来检验这两个根。设 $\\theta_{+}$ 是带加号的解，$\\theta_{-}$ 是带减号的解。\n考虑配体密度非常高的情况，即 $\\rho_{L} \\to \\infty$。在这种情况下，我们预期所有受体都会饱和，因此 $\\theta \\to 1$。在我们的二次方程 $(\\rho_{R})\\theta^2 - (\\rho_{R} + \\rho_{L} + K_{d}^{2D})\\theta + \\rho_{L} = 0$ 中，如果我们两边同除以 $\\rho_{L}$，会得到 $(\\frac{\\rho_R}{\\rho_L})\\theta^2 - (\\frac{\\rho_R}{\\rho_L} + 1 + \\frac{K_d^{2D}}{\\rho_L})\\theta + 1 = 0$。当 $\\rho_L \\to \\infty$ 时，方程简化为 $-\\theta + 1 \\approx 0$，这得出 $\\theta \\approx 1$。\n\n我们来检查哪个根能得到这个结果。\n对于 $\\theta_{+}$ 根，分子是 $(\\rho_{R} + \\rho_{L} + K_{d}^{2D}) + \\sqrt{(\\rho_{R} + \\rho_{L} + K_{d}^{2D})^2 - 4\\rho_{R}\\rho_{L}}$。当 $\\rho_{L} \\to \\infty$ 时，分子约增长为 $2\\rho_{L}$，因此 $\\theta_{+} \\approx \\frac{2\\rho_{L}}{2\\rho_{R}} = \\frac{\\rho_{L}}{\\rho_{R}}$。由于 $\\rho_{L} \\to \\infty$，这个根 $\\theta_{+} \\to \\infty$，这是不符合物理实际的。\n\n对于 $\\theta_{-}$ 根，我们遇到了一个 $\\infty - \\infty$ 的不定型。我们可以通过分子有理化或使用二项式近似来分析其行为。设 $S = \\rho_{R} + \\rho_{L} + K_{d}^{2D}$。\n对于大的 $S$ 值，$\\sqrt{S^2 - 4\\rho_{R}\\rho_{L}} = S \\sqrt{1 - \\frac{4\\rho_{R}\\rho_{L}}{S^2}} \\approx S(1 - \\frac{2\\rho_{R}\\rho_{L}}{S^2}) = S - \\frac{2\\rho_{R}\\rho_{L}}{S}$。\n将此代入 $\\theta_{-}$ 的表达式中：\n$$\n\\theta_{-} \\approx \\frac{S - (S - \\frac{2\\rho_{R}\\rho_{L}}{S})}{2\\rho_{R}} = \\frac{2\\rho_{R}\\rho_{L}/S}{2\\rho_{R}} = \\frac{\\rho_{L}}{S} = \\frac{\\rho_{L}}{\\rho_{R} + \\rho_{L} + K_{d}^{2D}}\n$$\n当 $\\rho_{L} \\to \\infty$ 时，$\\theta_{-} \\approx \\frac{\\rho_{L}}{\\rho_{L}} = 1$。这是物理上正确的行为。\n\n另一个简单的检验是考虑没有结合的情况，这对应于 $K_{d}^{2D} \\to \\infty$。在这个极限下，我们预期 $\\theta \\to 0$。从近似式 $\\theta_{-} \\approx \\frac{\\rho_{L}}{\\rho_{R} + \\rho_{L} + K_{d}^{2D}}$ 可以清楚地看到，当 $K_{d}^{2D} \\to \\infty$ 时，$\\theta_{-} \\to 0$。然而，$\\theta_{+}$ 根发散，$\\theta_{+} \\approx \\frac{K_{d}^{2D}}{\\rho_{R}} \\to \\infty$。\n\n因此，物理上正确的解对应于二次公式中的减号。\n受体分数占有率的封闭形式解析表达式为：\n$$\n\\theta = \\frac{(\\rho_{R} + \\rho_{L} + K_{d}^{2D}) - \\sqrt{(\\rho_{R} + \\rho_{L} + K_{d}^{2D})^2 - 4\\rho_{R}\\rho_{L}}}{2\\rho_{R}}\n$$\n对于所有物理上现实的参数（$\\rho_{R} > 0$，$\\rho_{L} \\ge 0$，$K_{d}^{2D} \\ge 0$），该表达式满足条件 $0 \\le \\theta \\le 1$。",
            "answer": "$$\n\\boxed{\\frac{\\rho_{R} + \\rho_{L} + K_{d}^{2D} - \\sqrt{(\\rho_{R} + \\rho_{L} + K_{d}^{2D})^{2} - 4\\rho_{R}\\rho_{L}}}{2\\rho_{R}}}\n$$"
        },
        {
            "introduction": "真实的生物键合远非静态，而是对力做出动态响应。与简单的“滑动键”（slip bonds）遇力变弱不同，整合素等许多生物分子键表现出“捕获键”（catch-bond）行为，即在一定力值范围内力反而会增强键的稳定性。此练习要求你分析捕获键的数学模型，以确定使键合寿命最长的临界力，这一特性对于细胞承受和传递力至关重要。",
            "id": "4180501",
            "problem": "细胞的粘着斑通过整合素-配体键将肌动球蛋白产生的张力传递给细胞外基质。在负载下，单个整合素-配体键可以通过两个平行的热激活途径解离：一个构象稳定的“捕获”途径和一个空间受限的“滑动”途径。使用以下与过渡态理论（艾林-贝尔模型）和热激活一致的机理基础：\n\n- 对于具有力依赖性激活势垒 $\\Delta G^{\\ddagger}(F)$ 的途径，其解离速率为 $k(F)=k_{0}\\,\\exp\\!\\left(-\\Delta G^{\\ddagger}(F)/(k_{B}T)\\right)$，其中 $k_{0}$ 是尝试频率，$k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度。\n- 在“捕获”途径中，施加的拉力 $F$ 使势垒增加，即 $\\Delta G^{\\ddagger}_{c}(F)=\\Delta G^{\\ddagger}_{c}(0)+F x_{c}$，其中特征长度 $x_{c}>0$，导致速率随力的增加而减小。\n- 在“滑动”途径中，施加的拉力 $F$ 使势垒降低，即 $\\Delta G^{\\ddagger}_{s}(F)=\\Delta G^{\\ddagger}_{s}(0)-F x_{s}$，其中特征长度 $x_{s}>0$，导致速率随力的增加而增加。\n- 假设途径是独立平行的，单个键在力作用下的总解离速率是各途径速率之和。\n\n考虑一个在温度 $T$ 下的整合素-纤维连接蛋白键，其参数 $k_{c0}$、$k_{s0}$、$x_{c}$ 和 $x_{s}$ 由零力下的途径速率和势垒距离定义。令 $k_{\\text{off}}(F)$ 表示总解离速率，作为每个键所受力 $F$ 的函数。承载接合的开始对应于每个键所受的力 $F^{\\ast}$，在该力下，初始随 $F$ 减小的 $k_{\\text{off}}(F)$ 转变为随 $F$ 增加，即 $k_{\\text{off}}(F)$ 相对于 $F$ 有一个极值点。\n\n给定 $k_{c0}=1.0\\,\\text{s}^{-1}$、$k_{s0}=0.50\\,\\text{s}^{-1}$、$x_{c}=0.60\\,\\text{nm}$、$x_{s}=0.30\\,\\text{nm}$ 以及 $T=310\\,\\text{K}$，确定每个键的临界力 $F^{\\ast}$，在该力下，$k_{\\text{off}}(F)$ 停止随 $F$ 减小并开始增加。将您的答案四舍五入到三位有效数字。最终的力以皮牛顿（pN）为单位表示。",
            "solution": "其物理基础是越过经力修饰的能量势垒的热激活过程。对于每个途径 $i\\in\\{c,s\\}$，过渡态理论（艾林-贝尔模型）给出\n$$\nk_{i}(F)=k_{i0}\\,\\exp\\!\\left(-\\frac{\\Delta G^{\\ddagger}_{i}(F)}{k_{B}T}\\right),\n$$\n其中 $k_{i0}$ 是指前因子。指定的势垒对力的线性依赖关系得出\n$$\n\\Delta G^{\\ddagger}_{c}(F)=\\Delta G^{\\ddagger}_{c}(0)+F x_{c},\\quad \\Delta G^{\\ddagger}_{s}(F)=\\Delta G^{\\ddagger}_{s}(0)-F x_{s}.\n$$\n因此，\n$$\nk_{c}(F)=k_{c0}\\,\\exp\\!\\left(-\\frac{F x_{c}}{k_{B}T}\\right),\\qquad\nk_{s}(F)=k_{s0}\\,\\exp\\!\\left(\\frac{F x_{s}}{k_{B}T}\\right),\n$$\n其中 $k_{c0}=k_{c}(0)$ 和 $k_{s0}=k_{s}(0)$ 吸收了零力势垒项。对于独立的平行途径，总解离速率是各项之和\n$$\nk_{\\text{off}}(F)=k_{c}(F)+k_{s}(F)=k_{c0}\\,\\exp\\!\\left(-\\frac{F x_{c}}{k_{B}T}\\right)+k_{s0}\\,\\exp\\!\\left(\\frac{F x_{s}}{k_{B}T}\\right).\n$$\n“捕获”机制对应于 $k_{\\text{off}}(F)$ 初始随 $F$ 增加而减小的情况。从减小到增加的转变由极值条件确定\n$$\n\\frac{d k_{\\text{off}}}{dF}=0.\n$$\n求导得，\n$$\n\\frac{d k_{\\text{off}}}{dF}=-\\frac{x_{c}}{k_{B}T}\\,k_{c0}\\,\\exp\\!\\left(-\\frac{F x_{c}}{k_{B}T}\\right)+\\frac{x_{s}}{k_{B}T}\\,k_{s0}\\,\\exp\\!\\left(\\frac{F x_{s}}{k_{B}T}\\right).\n$$\n令 $\\frac{d k_{\\text{off}}}{dF}=0$ 并求解 $F$，\n$$\n-\\frac{x_{c}}{k_{B}T}\\,k_{c0}\\,\\exp\\!\\left(-\\frac{F x_{c}}{k_{B}T}\\right)+\\frac{x_{s}}{k_{B}T}\\,k_{s0}\\,\\exp\\!\\left(\\frac{F x_{s}}{k_{B}T}\\right)=0,\n$$\n这意味着\n$$\nx_{s}\\,k_{s0}\\,\\exp\\!\\left(\\frac{F x_{s}}{k_{B}T}\\right)=x_{c}\\,k_{c0}\\,\\exp\\!\\left(-\\frac{F x_{c}}{k_{B}T}\\right).\n$$\n整理得，\n$$\n\\exp\\!\\left(\\frac{F(x_{s}+x_{c})}{k_{B}T}\\right)=\\frac{x_{c}\\,k_{c0}}{x_{s}\\,k_{s0}},\n$$\n所以临界力为\n$$\nF^{\\ast}=\\frac{k_{B}T}{x_{s}+x_{c}}\\,\\ln\\!\\left(\\frac{x_{c}\\,k_{c0}}{x_{s}\\,k_{s0}}\\right).\n$$\n对于初始的捕获机制，需要满足 $x_{c}\\,k_{c0}>x_{s}\\,k_{s0}$，这使得对数项为正，因此 $F^{\\ast}>0$。\n\n现在代入给定参数。首先计算 $T=310\\,\\text{K}$ 时的 $k_{B}T$：\n$$\nk_{B}=1.380649\\times 10^{-23}\\,\\text{J/K},\\quad T=310\\,\\text{K}\\quad\\Rightarrow\\quad k_{B}T=1.380649\\times 10^{-23}\\times 310\\,\\text{J}.\n$$\n数值上，\n$$\nk_{B}T=4.280012\\times 10^{-21}\\,\\text{J}.\n$$\n使用 $1\\,\\text{J}=10^{21}\\,\\text{pN}\\cdot\\text{nm}$ 将 $k_{B}T$ 转换为皮牛顿-纳米单位：\n$$\nk_{B}T=4.280012\\,\\text{pN}\\cdot\\text{nm}.\n$$\n计算分母 $x_{s}+x_{c}$：\n$$\nx_{s}+x_{c}=0.30\\,\\text{nm}+0.60\\,\\text{nm}=0.90\\,\\text{nm}.\n$$\n计算对数的参数：\n$$\n\\frac{x_{c}k_{c0}}{x_{s}k_{s0}}=\\frac{0.60\\times 1.0}{0.30\\times 0.50}=\\frac{0.60}{0.15}=4.0.\n$$\n因此，\n$$\nF^{\\ast}=\\frac{4.280012\\,\\text{pN}\\cdot\\text{nm}}{0.90\\,\\text{nm}}\\;\\ln(4.0).\n$$\n计算：\n$$\n\\frac{4.280012}{0.90}\\,\\text{pN}=4.755569\\,\\text{pN},\\quad \\ln(4.0)=1.386294.\n$$\n所以，\n$$\nF^{\\ast}=4.755569\\times 1.386294\\,\\text{pN}=6.59384\\,\\text{pN}.\n$$\n四舍五入到三位有效数字，并以皮牛顿表示，每个键的临界力为\n$$\nF^{\\ast}=6.59\\,\\text{pN}.\n$$",
            "answer": "$$\\boxed{6.59}$$"
        },
        {
            "introduction": "现在，我们将从单个分子的特性扩展到粘着斑的集体功能。这个计算练习将运用前面探讨的“捕获键”动力学知识，构建一个分子离合器集群的整体模型。通过实现这个模型，你将能够预测细胞宏观的力-速度关系，从而揭示微观动力学参数如何决定细胞尺度上的力学行为。",
            "id": "4180467",
            "problem": "考虑一个用于通过整合素-配体键将肌动蛋白产生的力传递到弹性基底上的系综分子离合器模型。每个键的行为都像一个遵循胡克定律的线性弹簧，其力 $f$ 与伸长量 $x$ 的关系为 $f = k_b x$，其中 $k_b$ 是键刚度，单位为 $\\mathrm{N}/\\mathrm{m}$。肌动蛋白的逆向流动施加了一个恒定的加载速率 $r = k_b v$，其中 $v$ 是肌动蛋白的速度，单位为 $\\mathrm{m}/\\mathrm{s}$。键以依赖于力的解离速率随机解离，该解离速率由双路径捕获键定律给出，\n$$\nk_{\\mathrm{off}}(f) = k_c \\exp\\!\\left(-\\frac{f}{f_c}\\right) + k_s \\exp\\!\\left(\\frac{f}{f_s}\\right),\n$$\n其中 $k_c$ 和 $k_s$ 分别是捕获和滑移路径的零力解离速率（单位为 $\\mathrm{s}^{-1}$），$f_c$ 和 $f_s$ 分别是捕获和滑移路径的特征力（单位为 $\\mathrm{N}$）。游离的整合素以恒定的结合速率 $k_{\\mathrm{on}}$（单位为 $\\mathrm{s}^{-1}$）进行结合。设 $N$ 为潜在键的总数。\n\n从以下公式出发：\n- 胡克定律 $f = k_b x$，\n- 恒定加载 $f(t) = r t$，其中 $r = k_b v$，\n- 对具有风险率 $k_{\\mathrm{off}}(f(t))$ 的时变非齐次泊松过程进行生存分析，\n\n推导一个计算方案，以获得稳态牵引力 $F_t(v)$ 作为肌动蛋白速度 $v$ 的函数（力-速度关系），单位为 $\\mathrm{N}$。具体而言：\n1. 在恒定加载速率 $r$ 下，作为力函数之一的生存概率为 $S(f) = \\exp\\!\\left(-\\int_{0}^{f} \\frac{k_{\\mathrm{off}}(u)}{r}\\,du\\right)$。使用此公式计算：\n   - 平均附着寿命 $E[T] = \\frac{1}{r}\\int_{0}^{\\infty} S(f)\\,df$，\n   - 有效解离速率 $k_{\\mathrm{off,eff}} = \\frac{1}{E[T]} = \\frac{r}{\\int_{0}^{\\infty} S(f)\\,df}$，\n   - 单个附着键所承载的平均力 $\\langle f_b \\rangle = \\frac{\\int_{0}^{\\infty} f S(f)\\,df}{\\int_{0}^{\\infty} S(f)\\,df}$。\n2. 在稳态下，已附着键的比例为 $n = \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off,eff}}}$，牵引力为 $F_t(v) = N\\, n\\, \\langle f_b \\rangle$。\n\n使用对 $f$ 的数值积分来计算 $S(f)$，从而实现上述计算，确保科学真实性和数值稳定性。当 $v = 0$ 时，将加载速率 $r = 0$ 视为边界情况，此时 $F_t(0) = 0$。\n\n您的程序必须根据指定的捕获键动力学，为下面每个测试用例中提供的速度计算 $F_t(v)$（单位为 $\\mathrm{N}$）。输出必须是单行，包含一个用方括号括起来的逗号分隔列表。按给定顺序连接所有测试用例的结果，每个 $F_t(v)$ 都是一个以 $\\mathrm{N}$ 为单位的浮点数。\n\n测试套件：\n- 测试用例 A（滑移键基线，正常路径）：\n  - $N = 1000$，\n  - $k_b = 0.002\\,\\mathrm{N}/\\mathrm{m}$，\n  - $k_{\\mathrm{on}} = 1.0\\,\\mathrm{s}^{-1}$，\n  - 动力学参数：$k_c = 0.0\\,\\mathrm{s}^{-1}$，$f_c = 3.0\\times 10^{-11}\\,\\mathrm{N}$，$k_s = 1.0\\,\\mathrm{s}^{-1}$，$f_s = 1.0\\times 10^{-11}\\,\\mathrm{N}$，\n  - 速度 $v \\in \\{0.0, 1.0\\times 10^{-7}, 5.0\\times 10^{-7}\\}\\,\\mathrm{m}/\\mathrm{s}$。\n- 测试用例 B（中等捕获键，用于比较）：\n  - $N = 1000$，\n  - $k_b = 0.002\\,\\mathrm{N}/\\mathrm{m}$，\n  - $k_{\\mathrm{on}} = 1.0\\,\\mathrm{s}^{-1}$，\n  - 动力学参数：$k_c = 0.8\\,\\mathrm{s}^{-1}$，$f_c = 3.0\\times 10^{-11}\\,\\mathrm{N}$，$k_s = 0.2\\,\\mathrm{s}^{-1}$，$f_s = 1.5\\times 10^{-11}\\,\\mathrm{N}$，\n  - 速度 $v \\in \\{0.0, 1.0\\times 10^{-7}, 5.0\\times 10^{-7}\\}\\,\\mathrm{m}/\\mathrm{s}$。\n- 测试用例 C（边缘情况覆盖：较软的键刚度和更宽的速度范围）：\n  - $N = 1000$，\n  - $k_b = 0.0005\\,\\mathrm{N}/\\mathrm{m}$，\n  - $k_{\\mathrm{on}} = 2.0\\,\\mathrm{s}^{-1}$，\n  - 动力学参数：$k_c = 1.2\\,\\mathrm{s}^{-1}$，$f_c = 2.5\\times 10^{-11}\\,\\mathrm{N}$，$k_s = 0.3\\,\\mathrm{s}^{-1}$，$f_s = 1.0\\times 10^{-11}\\,\\mathrm{N}$，\n  - 速度 $v \\in \\{1.0\\times 10^{-8}, 1.0\\times 10^{-7}, 1.0\\times 10^{-6}\\}\\,\\mathrm{m}/\\mathrm{s}$。\n\n物理单位要求：\n- 所有力以 $\\mathrm{N}$ 为单位报告，速度以 $\\mathrm{m}/\\mathrm{s}$ 为单位，速率以 $\\mathrm{s}^{-1}$ 为单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$），该列表按顺序连接测试用例 A、测试用例 B 和测试用例 C 中所有速度对应的 $F_t(v)$ 值（单位为 $\\mathrm{N}$）。",
            "solution": "该问题被认为是有效的，因为它科学地基于已建立的生物物理模型（分子离合器假说），在数学上是适定的、客观的，并为计算求解提供了完整且一致的信息集。\n\n目标是基于系综分子离合器模型，计算稳态牵引力 $F_t(v)$ 作为肌动蛋白逆向流速度 $v$ 的函数。解决方案遵循问题陈述中概述的理论框架和计算方案。\n\n首先，我们分析模型的组成部分。由于恒定的加载速率 $r = k_b v$（其中 $k_b$ 是键刚度，$v$ 是肌动蛋白速度），单个整合素-配体键上的力 $f$ 被假定为随时间线性增加，即 $f(t) = rt$。键的随机寿命由一个依赖于力的解离速率 $k_{\\mathrm{off}}(f)$ 控制，该速率遵循双路径捕获-滑移定律：\n$$\nk_{\\mathrm{off}}(f) = k_c \\exp\\!\\left(-\\frac{f}{f_c}\\right) + k_s \\exp\\!\\left(\\frac{f}{f_s}\\right)\n$$\n此处，$k_c$ 和 $k_s$ 是捕获和滑移路径的零力解离速率，$f_c$ 和 $f_s$ 是它们各自的特征力。\n\n在此随时变加载下，一个键的生存概率（表示为力 $f$ 的函数）由下式给出：\n$$\nS(f) = \\exp\\!\\left(-\\int_{0}^{f} \\frac{k_{\\mathrm{off}}(u)}{r}\\,du\\right)\n$$\n为了通过计算实现这一点，必须首先计算指数中的积分。设 $K(f) = \\int_0^f k_{\\mathrm{off}}(u)\\,du$。该积分可以解析求解：\n$$\nK(f) = \\int_{0}^{f} \\left[ k_c \\exp\\!\\left(-\\frac{u}{f_c}\\right) + k_s \\exp\\!\\left(\\frac{u}{f_s}\\right) \\right] du\n$$\n$$\nK(f) = \\left[ -k_c f_c \\exp\\!\\left(-\\frac{u}{f_c}\\right) + k_s f_s \\exp\\!\\left(\\frac{u}{f_s}\\right) \\right]_0^f\n$$\n$$\nK(f) = \\left( -k_c f_c e^{-f/f_c} + k_s f_s e^{f/f_s} \\right) - \\left( -k_c f_c e^0 + k_s f_s e^0 \\right)\n$$\n$$\nK(f) = k_c f_c (1 - e^{-f/f_c}) + k_s f_s (e^{f/f_s} - 1)\n$$\n该表达式允许直接计算 $S(f) = \\exp(-K(f)/r)$。为了保证数值精度，特别是当指数的参数接近于零时，像 $(e^x - 1)$ 这样的项最好使用库函数（如 `numpy.expm1(x)`）来实现。\n\n在定义了 $S(f)$ 之后，下一步是计算每个附着键的平均力 $\\langle f_b \\rangle$ 和有效解离速率 $k_{\\mathrm{off,eff}}$。这些量由力域上的积分定义：\n$$\n\\langle f_b \\rangle = \\frac{\\int_{0}^{\\infty} f S(f)\\,df}{\\int_{0}^{\\infty} S(f)\\,df} \\quad \\text{and} \\quad k_{\\mathrm{off,eff}} = \\frac{r}{\\int_{0}^{\\infty} S(f)\\,df}\n$$\n我们定义 $I_1 = \\int_{0}^{\\infty} S(f)\\,df$ 和 $I_2 = \\int_{0}^{\\infty} f S(f)\\,df$。这些积分没有通用的解析解，必须进行数值计算。由于 $S(f)$ 指数中的滑移键项 $e^{f/f_s}$，当 $f \\to \\infty$ 时，被积函数 $S(f)$ 和 $fS(f)$ 会非常迅速地衰减到零。这使得数值积分是可行的。我们可以用一个足够大的有限值 $f_{\\mathrm{max}}$ 来代替无穷大上限，使得超出此点的被积函数值可以忽略不计。鉴于特征力 $f_c$ 和 $f_s$ 的数量级为 $10^{-11}\\,\\mathrm{N}$，选择 $f_{\\mathrm{max}} = 10^{-9}\\,\\mathrm{N}$ 的上限是安全的选择。数值积分使用 `scipy.integrate` 库中的 `quad` 函数执行。\n\n在稳态下，$N$ 个可用整合素中已结合的比例由结合速率和解离速率的平衡决定：\n$$\nn = \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off,eff}}}\n$$\n总牵引力 $F_t(v)$ 是总键数 $N$、已结合键的比例 $n$ 和每个键的平均力 $\\langle f_b \\rangle$ 的乘积：\n$$\nF_t(v) = N \\cdot n \\cdot \\langle f_b \\rangle = N \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + k_{\\mathrm{off,eff}}} \\langle f_b \\rangle\n$$\n代入 $\\langle f_b \\rangle$ 和 $k_{\\mathrm{off,eff}}$ 的积分表达式：\n$$\nF_t(v) = N \\frac{k_{\\mathrm{on}}}{k_{\\mathrm{on}} + r/I_1} \\frac{I_2}{I_1}\n$$\n为了提高数值稳定性，我们可以重新整理这个公式，以避免中间步骤中被 $I_1$ 除：\n$$\nF_t(v) = N \\frac{k_{\\mathrm{on}} I_1}{k_{\\mathrm{on}} I_1 + r} \\frac{I_2}{I_1} = \\frac{N k_{\\mathrm{on}} I_2}{k_{\\mathrm{on}} I_1 + r}\n$$\n这是在代码中为任何 $v > 0$ 实现的最终表达式。对于边界情况 $v=0$，加载速率 $r=0$，导致任何附着键的 $f(t)=0$。问题规定在此极限下，传递的力为零，因此 $F_t(0) = 0$。\n\n每个测试用例的总体计算流程如下：\n1. 对于每个指定的速度 $v$：\n2. 如果 $v = 0$，则力 $F_t(v)$ 为 $0$。\n3. 如果 $v > 0$，计算加载速率 $r = k_b v$。\n4. 使用 $K(f)$ 的解析形式，构建被积函数 $S(f)$ 和 $fS(f)$ 的函数。\n5. 数值计算积分 $I_1 = \\int_0^{f_{\\mathrm{max}}} S(f)\\,df$ 和 $I_2 = \\int_0^{f_{\\mathrm{max}}} fS(f)\\,df$。\n6. 使用稳定化的公式 $F_t(v) = (N k_{\\mathrm{on}} I_2) / (k_{\\mathrm{on}} I_1 + r)$ 计算总牵引力。\n7. 收集所有测试用例中所有速度得到的力，并将它们格式化为单个逗号分隔的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes the steady-state traction force F_t(v) for a molecular clutch model.\n    \"\"\"\n    test_suite = [\n        # Test Case A (slip-bond baseline, happy path)\n        {\n            \"params\": {\n                'N': 1000, 'k_b': 0.002, 'k_on': 1.0,\n                'k_c': 0.0, 'f_c': 3.0e-11, 'k_s': 1.0, 'f_s': 1.0e-11\n            },\n            \"velocities\": [0.0, 1.0e-7, 5.0e-7]\n        },\n        # Test Case B (moderate catch-bond, comparison)\n        {\n            \"params\": {\n                'N': 1000, 'k_b': 0.002, 'k_on': 1.0,\n                'k_c': 0.8, 'f_c': 3.0e-11, 'k_s': 0.2, 'f_s': 1.5e-11\n            },\n            \"velocities\": [0.0, 1.0e-7, 5.0e-7]\n        },\n        # Test Case C (edge-case coverage: softer bond stiffness and wider velocity span)\n        {\n            \"params\": {\n                'N': 1000, 'k_b': 0.0005, 'k_on': 2.0,\n                'k_c': 1.2, 'f_c': 2.5e-11, 'k_s': 0.3, 'f_s': 1.0e-11\n            },\n            \"velocities\": [1.0e-8, 1.0e-7, 1.0e-6]\n        }\n    ]\n\n    all_results = []\n\n    def calculate_Ft(params, v):\n        \"\"\"\n        Calculates the traction force for a given set of parameters and a single velocity.\n        \"\"\"\n        if v == 0.0:\n            return 0.0\n\n        N = params['N']\n        k_b = params['k_b']\n        k_on = params['k_on']\n        k_c = params['k_c']\n        f_c = params['f_c']\n        k_s = params['k_s']\n        f_s = params['f_s']\n\n        r = k_b * v\n\n        def K_func(f):\n            \"\"\"\n            Calculates the integrated off-rate K(f) = integral_0^f k_off(u) du.\n            Uses np.expm1 for higher precision.\n            \"\"\"\n            term_c = 0.0\n            if k_c > 0 and f_c > 0:\n                # k_c*f_c*(1 - exp(-f/f_c)) = -k_c*f_c*expm1(-f/f_c)\n                term_c = -k_c * f_c * np.expm1(-f / f_c)\n\n            term_s = 0.0\n            if k_s > 0 and f_s > 0:\n                # k_s*f_s*(exp(f/f_s) - 1) = k_s*f_s*expm1(f/f_s)\n                term_s = k_s * f_s * np.expm1(f / f_s)\n                \n            return term_c + term_s\n\n        def S_func(f):\n            \"\"\"\n            Calculates the survival probability S(f) = exp(-K(f)/r).\n            \"\"\"\n            exponent = -K_func(f) / r\n            # Guard against underflow by returning 0 for very negative exponents\n            if exponent  -709:  # np.exp(-709.78) is close to float minimum\n                return 0.0\n            return np.exp(exponent)\n\n        integrand1 = S_func\n        integrand2 = lambda f: f * S_func(f)\n\n        # The upper limit for numerical integration. Chosen to be much larger\n        # than characteristic forces to approximate infinity.\n        f_max = 1.0e-9\n\n        I1, _ = quad(integrand1, 0, f_max)\n        I2, _ = quad(integrand2, 0, f_max)\n\n        # Use the numerically stable formula for F_t\n        denominator = k_on * I1 + r\n        if denominator == 0:\n            # This should not happen with physical parameters\n            return 0.0\n        \n        F_t = N * k_on * I2 / denominator\n        return F_t\n\n    for case in test_suite:\n        params = case[\"params\"]\n        velocities = case[\"velocities\"]\n        for v in velocities:\n            result = calculate_Ft(params, v)\n            all_results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}