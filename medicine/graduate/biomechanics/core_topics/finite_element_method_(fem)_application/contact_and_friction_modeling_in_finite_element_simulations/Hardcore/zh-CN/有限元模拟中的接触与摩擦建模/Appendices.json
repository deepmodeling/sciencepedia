{
    "hands_on_practices": [
        {
            "introduction": "在我们能够对接触力进行建模之前，我们必须首先检测接触并量化相互作用的几何形状。本练习 () 旨在解决“节点-表面”(node-to-surface)接触算法中最基本的几何问题：在主表面（一个三角形）上找到距离从动节点最近的点。通过从第一性原理出发实现该算法，您将深刻理解间隙和接触点等运动学变量是如何定义的，而这些变量构成了所有接触力学模型的基石。",
            "id": "4167128",
            "problem": "在有限元接触设置中，一个三角形主面元由当前构型中的三个顶点 $x_1, x_2, x_3 \\in \\mathbb{R}^3$ 定义，单位为米。一个从点 $x_s \\in \\mathbb{R}^3$ (单位为米) 接近此面元。在有限元法 (FEM) 的背景下，一个线性三角形面元使用局部坐标 $(\\xi,\\eta)$ 和形函数 $N_1 = 1 - \\xi - \\eta$, $N_2 = \\xi$, $N_3 = \\eta$，因此面元上的任意点可以插值为 $x_m(\\xi,\\eta) = N_1 x_1 + N_2 x_2 + N_3 x_3$，其中 $\\xi \\ge 0$, $\\eta \\ge 0$ 且 $\\xi + \\eta \\le 1$。该面元的单位法向量 $\\hat{\\boldsymbol{n}}$ 根据顶点顺序 $x_1 \\rightarrow x_2 \\rightarrow x_3$ 通过右手法则定义。\n\n从欧几里得几何和有限元插值的基本原理出发，构建一个算法，在给定 $x_1$、$x_2$、$x_3$ 和 $x_s$ 的情况下，找到面元上（包括其边界）距离 $x_s$ 最近的点 $x_m$。该算法必须：\n- 确定与线性三角形参数化一致的 $x_m$ 的局部坐标 $(\\xi,\\eta)$。\n- 计算法向间隙 $g_n = \\hat{\\boldsymbol{n}} \\cdot (x_s - x_m)$，单位为米。\n- 计算切向间隙向量 $\\boldsymbol{g}_t = ( \\mathbf{I} - \\hat{\\boldsymbol{n}} \\hat{\\boldsymbol{n}}^\\top )(x_s - x_m)$，单位为米，其中 $\\mathbf{I}$ 是 $\\mathbb{R}^3$ 中的单位矩阵。\n\n从以下基础推导此算法：\n- $\\mathbb{R}^3$ 中的欧几里得内积、投影和距离。\n- 使用 $N_1$、$N_2$、$N_3$ 在三角形上进行线性插值。\n- 通过两条边的叉积定义单位法向量。\n\n不要使用任何跳过这些基础推导的快捷公式。您的算法必须能正确处理 $x_s$ 在面元平面上的正交投影是位于三角形内部还是外部的情况，若在外部，则最近点位于其中一条边或一个顶点上。所有距离的单位必须是米。\n\n用一个程序实现此算法，处理以下测试用例（单位为米）。对于每个用例，给定 $x_1$、$x_2$、$x_3$ 和 $x_s$：\n\n- 情况1（内部投影，斜向偏移）：\n  $x_1 = (0.000,\\,0.000,\\,0.000)$,\n  $x_2 = (0.030,\\,0.000,\\,0.000)$,\n  $x_3 = (0.000,\\,0.020,\\,0.000)$,\n  $x_s = (0.010,\\,0.005,\\,0.001)$。\n- 情况2（最接近边 $x_1$–$x_2$）：\n  $x_1 = (0.000,\\,0.000,\\,0.000)$,\n  $x_2 = (0.030,\\,0.000,\\,0.000)$,\n  $x_3 = (0.000,\\,0.020,\\,0.000)$,\n  $x_s = (0.020,\\,-0.010,\\,0.002)$。\n- 情况3（最接近顶点 $x_3$）：\n  $x_1 = (0.000,\\,0.000,\\,0.000)$,\n  $x_2 = (0.030,\\,0.000,\\,0.000)$,\n  $x_3 = (0.000,\\,0.020,\\,0.000)$,\n  $x_s = (-0.001,\\,0.021,\\,0.0005)$。\n- 情况4（斜三角形，内部投影）：\n  $x_1 = (0.000,\\,0.000,\\,0.000)$,\n  $x_2 = (0.020,\\,0.000,\\,0.005)$,\n  $x_3 = (0.000,\\,0.030,\\,-0.004)$,\n  $x_s = (0.010,\\,0.015,\\,0.002)$。\n- 情况5（平面内内部点）：\n  $x_1 = (0.000,\\,0.000,\\,0.000)$,\n  $x_2 = (0.030,\\,0.000,\\,0.000)$,\n  $x_3 = (0.000,\\,0.020,\\,0.000)$,\n  $x_s = (0.015,\\,0.005,\\,0.000)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果由列表 $[\\xi,\\eta,g_n,g_{t,x},g_{t,y},g_{t,z}]$ 表示，单位为米，且不含空格。例如，输出必须采用以下格式：\n$[[\\xi_1,\\eta_1,g_{n,1},g_{t,x,1},g_{t,y,1},g_{t,z,1}],[\\xi_2,\\eta_2,g_{n,2},g_{t,x,2},g_{t,y,2},g_{t,z,2}],\\dots]$。",
            "solution": "问题要求开发一个算法，以找到三角形主面元上距离给定从点 $x_s$ 最近的点 $x_m$。该算法必须从欧几里得几何和有限元插值的基本原理推导得出。最终输出为最近点的局部坐标 $(\\xi, \\eta)$、法向间隙 $g_n$ 和切向间隙向量 $\\boldsymbol{g}_t$。\n\n问题的核心是在 $x_m$ 位于由顶点 $x_1, x_2, x_3 \\in \\mathbb{R}^3$ 定义的三角形面元上的约束条件下，最小化欧几里得距离的平方 $d^2 = \\|x_m - x_s\\|^2$。\n\n首先，我们建立面元的几何参数化。面元上的任意点 $x_m$ 是其顶点使用重心形函数 $N_1=1-\\xi-\\eta$、$N_2=\\xi$ 和 $N_3=\\eta$ 进行的线性插值：\n$$x_m(\\xi, \\eta) = N_1 x_1 + N_2 x_2 + N_3 x_3 = (1-\\xi-\\eta)x_1 + \\xi x_2 + \\eta x_3$$\n如果局部坐标 $(\\xi, \\eta)$ 满足条件 $\\xi \\ge 0$、$\\eta \\ge 0$ 和 $\\xi+\\eta \\le 1$，则点 $x_m$ 位于三角形内部（包括其边界）。我们可以用从顶点 $x_1$ 出发的边向量重写插值公式。令 $e_1 = x_2 - x_1$ 和 $e_2 = x_3 - x_1$。公式变为：\n$$x_m(\\xi, \\eta) = x_1 + \\xi e_1 + \\eta e_2$$\n那么，到从点 $x_s$ 的距离平方是 $(\\xi, \\eta)$ 的函数：\n$$f(\\xi, \\eta) = \\|x_m(\\xi, \\eta) - x_s\\|^2 = \\|x_1 + \\xi e_1 + \\eta e_2 - x_s\\|^2$$\n令从 $x_1$ 到 $x_s$ 的向量为 $v = x_s - x_1$。需要最小化的函数是：\n$$f(\\xi, \\eta) = \\|\\xi e_1 + \\eta e_2 - v\\|^2 = (\\xi e_1 + \\eta e_2 - v) \\cdot (\\xi e_1 + \\eta e_2 - v)$$\n展开这个内积，得到一个关于 $\\xi$ 和 $\\eta$ 的二次函数：\n$$f(\\xi, \\eta) = \\xi^2 (e_1 \\cdot e_1) + \\eta^2 (e_2 \\cdot e_2) + 2\\xi\\eta (e_1 \\cdot e_2) - 2\\xi (e_1 \\cdot v) - 2\\eta (e_2 \\cdot v) + (v \\cdot v)$$\n为了找到包含该三角形的无限平面上的最近点，我们通过将其梯度设为零：$\\nabla f = (\\frac{\\partial f}{\\partial \\xi}, \\frac{\\partial f}{\\partial \\eta}) = (0, 0)$，对 $f(\\xi, \\eta)$ 进行无约束最小化。\n$$\\frac{\\partial f}{\\partial \\xi} = 2\\xi (e_1 \\cdot e_1) + 2\\eta (e_1 \\cdot e_2) - 2(e_1 \\cdot v) = 0$$\n$$\\frac{\\partial f}{\\partial \\eta} = 2\\eta (e_2 \\cdot e_2) + 2\\xi (e_1 \\cdot e_2) - 2(e_2 \\cdot v) = 0$$\n这为最优的 $(\\xi, \\eta)$（我们记为 $(\\xi^*, \\eta^*)$）提供了一个 $2 \\times 2$ 的线性方程组：\n$$\n\\begin{pmatrix}\ne_1 \\cdot e_1 & e_1 \\cdot e_2 \\\\\ne_1 \\cdot e_2 & e_2 \\cdot e_2\n\\end{pmatrix}\n\\begin{pmatrix}\n\\xi^* \\\\\n\\eta^*\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ne_1 \\cdot v \\\\\ne_2 \\cdot v\n\\end{pmatrix}\n$$\n令 $a = e_1 \\cdot e_1$，$b = e_1 \\cdot e_2$，$c = e_2 \\cdot e_2$，$d = e_1 \\cdot v$，$e = e_2 \\cdot v$。该系统为 $A \\begin{pmatrix}\\xi^* \\\\ \\eta^*\\end{pmatrix} = \\begin{pmatrix}d \\\\ e\\end{pmatrix}$，其中 $A=\\begin{pmatrix} a & b \\\\ b & c \\end{pmatrix}$。解为：\n$$ \\xi^* = \\frac{cd - be}{ac - b^2}, \\quad \\eta^* = \\frac{ae - bd}{ac - b^2} $$\n点 $x_m(\\xi^*, \\eta^*)$ 是 $x_s$ 在三角形平面上的正交投影。\n\n如果这个无约束解 $(\\xi^*, \\eta^*)$ 满足条件 $\\xi^* \\ge 0$、$\\eta^* \\ge 0$ 和 $\\xi^*+\\eta^* \\le 1$，那么投影点位于三角形内部，我们就找到了最近点。然而，如果这些条件中的任何一个被违反，面元上的最近点必定位于其边界上（三条边或三个顶点之一）。问题就变成了一个约束优化问题。\n\n我们可以通过检查哪个边界区域离无约束解 $(\\xi^*, \\eta^*)$ 最近来系统地找到约束最小值。这等同于将 $x_s$ 投影到包含各边的直线上，并根据 $(\\xi^*, \\eta^*)$ 违反了哪个有效性条件，将结果限制在相应的边线段上。算法流程如下：\n\n令 $(\\xi, \\eta)$ 表示最终被限制的坐标。\n1.  如果 $\\xi^* < 0$：最近点位于对应 $\\xi = 0$ 的线段上，即边 $x_1-x_3$。我们求 $x_s$ 在此线段上的最近点。沿直线 $x_1 \\to x_3$ 使距离最小化的参数是 $t = \\frac{(x_s-x_1)\\cdot(x_3-x_1)}{\\|x_3-x_1\\|^2} = \\frac{e_2 \\cdot v}{e_2 \\cdot e_2} = \\frac{e}{c}$。我们将此参数限制在有效范围 $[0, 1]$ 内。最终坐标为 $(\\xi, \\eta) = (0, \\text{clamp}(t, 0, 1))$。\n\n2.  否则，如果 $\\eta^* < 0$：最近点位于边 $x_1-x_2$ 上 ($\\eta=0$)。沿直线 $x_1 \\to x_2$ 的参数是 $t = \\frac{(x_s-x_1)\\cdot(x_2-x_1)}{\\|x_2-x_1\\|^2} = \\frac{e_1 \\cdot v}{e_1 \\cdot e_1} = \\frac{d}{a}$。将其限制在 $[0, 1]$ 内，得到最终坐标 $(\\xi, \\eta) = (\\text{clamp}(t, 0, 1), 0)$。\n\n3.  否则，如果 $\\xi^*+\\eta^* > 1$：最近点位于边 $x_2-x_3$ 上 ($\\xi+\\eta=1$)。我们求 $x_s$ 在线段 $x_2-x_3$ 上的最近点。沿直线 $x_2 \\to x_3$ 的参数是 $t = \\frac{(x_s-x_2)\\cdot(x_3-x_2)}{\\|x_3-x_2\\|^2}$。将其限制在 $[0, 1]$ 内，得到 $t_{clamped}$。我们将其转换回 $(\\xi, \\eta)$ 坐标系。此边上的一点是 $x_m = (1-t)x_2 + t x_3$。在我们的重心坐标系中，这对应于 $N_1=0, N_2 = \\xi = 1-t, N_3 = \\eta = t$。因此，最终坐标为 $(\\xi, \\eta) = (1-t_{clamped}, t_{clamped})$。\n\n4.  否则：无约束解 $(\\xi^*, \\eta^*)$ 位于有效域内。最终坐标为 $(\\xi, \\eta) = (\\xi^*, \\eta^*)$。\n\n一旦确定了最终坐标 $(\\xi, \\eta)$，面元上的最近点就计算为 $x_m = x_1 + \\xi e_1 + \\eta e_2$。\n\n最后，我们计算间隙量。面元法向量由边向量的叉积定义，$\\boldsymbol{n} = e_1 \\times e_2$，基于顶点顺序 $x_1 \\rightarrow x_2 \\rightarrow x_3$ 的右手法则。单位法向量为 $\\hat{\\boldsymbol{n}} = \\boldsymbol{n} / \\|\\boldsymbol{n}\\|$。从最近点到从点的间隙向量是 $\\boldsymbol{g} = x_s - x_m$。\n\n法向间隙 $g_n$ 是 $\\boldsymbol{g}$ 在单位法向量上的投影：\n$$g_n = \\hat{\\boldsymbol{n}} \\cdot \\boldsymbol{g} = \\hat{\\boldsymbol{n}} \\cdot (x_s - x_m)$$\n切向间隙向量 $\\boldsymbol{g}_t$ 是 $\\boldsymbol{g}$ 正交于法向量的分量，可以通过从总间隙向量中减去法向分量得到：\n$$\\boldsymbol{g}_t = \\boldsymbol{g} - g_n \\hat{\\boldsymbol{n}} = (\\mathbf{I} - \\hat{\\boldsymbol{n}} \\hat{\\boldsymbol{n}}^\\top)(x_s - x_m)$$\n其中 $\\mathbf{I}$ 是 $3 \\times 3$ 的单位矩阵。这就完成了从基本原理推导所需算法的过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_closest_point_on_triangle(x1, x2, x3, xs):\n    \"\"\"\n    Finds the closest point on a triangular facet to a slave point.\n\n    The algorithm is derived from first principles:\n    1. Parameterize the triangle using local coordinates (xi, eta).\n    2. Formulate the squared distance from the slave point to a point on the\n       triangle as a quadratic function of (xi, eta).\n    3. Solve for the unconstrained minimum by setting the gradient to zero,\n       which gives the projection of the slave point onto the infinite plane\n       of the triangle.\n    4. If the projected point is outside the triangle's boundaries (xi < 0,\n       eta < 0, or xi + eta > 1), clamp the solution to the valid region\n       by projecting onto the corresponding edge or vertex.\n    5. With the final (xi, eta), calculate the closest point xm, the normal\n       gap gn, and the tangential gap vector gt.\n    \"\"\"\n    x1 = np.array(x1, dtype=float)\n    x2 = np.array(x2, dtype=float)\n    x3 = np.array(x3, dtype=float)\n    xs = np.array(xs, dtype=float)\n\n    # 1. & 2. Define geometry and formulate minimization problem\n    e1 = x2 - x1\n    e2 = x3 - x1\n    v = xs - x1\n\n    a = np.dot(e1, e1)\n    b = np.dot(e1, e2)\n    c = np.dot(e2, e2)\n    d = np.dot(e1, v)\n    e = np.dot(e2, v)\n    \n    det = a * c - b * b\n\n    # Handle degenerate triangle case (though not expected from problem statement)\n    if np.abs(det) < 1e-15:\n        # Simplified handling for degenerate case: project onto the longest edge.\n        # This is a fallback and not part of the primary algorithm requested.\n        # For simplicity in this problem, we assume non-degenerate triangles.\n        # For a robust industrial code, this part would be more complex.\n        # We can just let the division by zero happen and debug if needed,\n        # but the problem data should be well-behaved.\n        pass\n\n    # 3. Unconstrained minimization: projection onto the plane\n    xi_star = (c * d - b * e) / det\n    eta_star = (a * e - b * d) / det\n\n    # 4. Constrained minimization: clamp to the triangular region [0,1]x[0,1] s.t. xi+eta<=1\n    if xi_star < 0:\n        # Closest point is on edge x1-x3\n        t = e / c if c > 1e-15 else 0.0\n        xi_final = 0.0\n        eta_final = np.clip(t, 0.0, 1.0)\n    elif eta_star < 0:\n        # Closest point is on edge x1-x2\n        t = d / a if a > 1e-15 else 0.0\n        xi_final = np.clip(t, 0.0, 1.0)\n        eta_final = 0.0\n    elif xi_star + eta_star > 1:\n        # Closest point is on edge x2-x3\n        e32 = x3 - x2\n        vs2 = xs - x2\n        t = np.dot(vs2, e32) / np.dot(e32, e32) if np.dot(e32, e32) > 1e-15 else 0.0\n        t_clamped = np.clip(t, 0.0, 1.0)\n        xi_final = 1.0 - t_clamped\n        eta_final = t_clamped\n    else:\n        # The projection is inside the triangle\n        xi_final = xi_star\n        eta_final = eta_star\n\n    # 5. Compute the final quantities\n    xm = x1 + xi_final * e1 + eta_final * e2\n\n    # Normal vector by right-hand rule on (x1, x2, x3)\n    n = np.cross(e1, e2)\n    norm_n = np.linalg.norm(n)\n    if norm_n > 1e-15:\n        n_hat = n / norm_n\n    else: # Fallback for degenerate triangles\n        n_hat = np.array([0., 0., 1.])\n\n    g = xs - xm\n    gn = np.dot(n_hat, g)\n    gt = g - gn * n_hat\n\n    return [xi_final, eta_final, gn, gt[0], gt[1], gt[2]]\n\ndef solve():\n    \"\"\"\n    Main function to process the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.030, 0.000, 0.000), 'x3': (0.000, 0.020, 0.000), 'xs': (0.010, 0.005, 0.001)},\n        # Case 2\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.030, 0.000, 0.000), 'x3': (0.000, 0.020, 0.000), 'xs': (0.020, -0.010, 0.002)},\n        # Case 3\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.030, 0.000, 0.000), 'x3': (0.000, 0.020, 0.000), 'xs': (-0.001, 0.021, 0.0005)},\n        # Case 4\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.020, 0.000, 0.005), 'x3': (0.000, 0.030, -0.004), 'xs': (0.010, 0.015, 0.002)},\n        # Case 5\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.030, 0.000, 0.000), 'x3': (0.000, 0.020, 0.000), 'xs': (0.015, 0.005, 0.000)},\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        result_list = find_closest_point_on_triangle(case['x1'], case['x2'], case['x3'], case['xs'])\n        # Format the list of numbers into a string \"[f1,f2,...]\" without spaces\n        inner_string = f\"[{','.join(map(str, result_list))}]\"\n        results_as_strings.append(inner_string)\n\n    # Format the list of strings into the final output format \"[[...],[...]]\"\n    final_output_string = f\"[{','.join(results_as_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "定义了间隙之后，我们必须施加不可穿透的物理定律。本练习 () 将无摩擦接触问题重构为一个正式的不等式约束优化问题，其解由 Karush-Kuhn-Tucker (KKT) 条件决定。您将实现一个主动集算法 (active-set algorithm)，这是一种强大的方法，它能迭代地确定哪些表面处于接触状态，从而让您能直观地理解互补条件：只有当间隙闭合时，接触力才存在。",
            "id": "4167058",
            "problem": "考虑一个生物力学中的准静态、线性弹性有限元系统，该系统具有潜在的单边、无摩擦接触。设位移向量表示为 $u \\in \\mathbb{R}^n$，对称正定刚度矩阵表示为 $K \\in \\mathbb{R}^{n \\times n}$，外载荷向量表示为 $f \\in \\mathbb{R}^n$。总势能定义为\n$$\n\\Pi(u) = \\tfrac{1}{2} u^\\top K u - f^\\top u.\n$$\n与刚性障碍物的无摩擦接触条件被表述为对间隙函数的不等式约束，\n$$\ng(u) = B u - c \\ge 0,\n$$\n其中 $B \\in \\mathbb{R}^{m \\times n}$ 将位移映射到法向间隙分量，$c \\in \\mathbb{R}^m$ 是初始间隙（或偏移）向量，并且该不等式是逐分量理解的。相关的拉格朗日乘子（接触牵引力）是 $\\lambda \\in \\mathbb{R}^m$，且 $\\lambda \\ge 0$（逐分量）。最优性的 Karush–Kuhn–Tucker (KKT) 条件是\n$$\nK u - f - B^\\top \\lambda = 0, \\quad g(u) \\ge 0, \\quad \\lambda \\ge 0, \\quad \\lambda_i \\, g_i(u) = 0 \\text{ for } i=1,\\dots,m.\n$$\n互补条件表示，要么间隙为严格正且接触牵引力为零，要么间隙为零且牵引力为非负。\n\n任务：\n1. 从最小势能原理和不等式约束优化出发，推导无摩擦单边接触的原始-对偶 KKT 系统。明确写出当一部分约束被视为激活（作为等式强制执行）时必须求解的分块系统。\n2. 设计并实现一个活动集算法，该算法迭代地更新活动约束集和非活动约束集。在每次迭代中，将当前活动约束作为等式强制执行，并将非活动约束的乘子设为零。基于对间隙正性和乘子非负性的违反情况来更新活动集，当活动集稳定且所有 KKT 符号条件在小容差内满足时停止。\n3. 将你的算法实现为一个完整、可运行的程序。该算法必须接受预定义的测试矩阵和向量，并生成数值解。\n\n使用以下测试套件来验证你的实现。对于每个测试用例，都提供了无量纲的 $K$、$f$、$B$ 和 $c$：\n\n- 测试用例 1 (理想路径):\n  - $n=2$, $m=1$\n  - $K = \\begin{bmatrix} 1000 & 0 \\\\ 0 & 500 \\end{bmatrix}$,\n  - $f = \\begin{bmatrix} 100 \\\\ 50 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 1 & 0 \\end{bmatrix}$,\n  - $c = \\begin{bmatrix} 0.1 \\end{bmatrix}$.\n- 测试用例 2 (边界接触开始):\n  - $n=2$, $m=1$\n  - $K = \\begin{bmatrix} 1000 & -200 \\\\ -200 & 300 \\end{bmatrix}$,\n  - $f = \\begin{bmatrix} 50 \\\\ 20 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 0 & 1 \\end{bmatrix}$,\n  - $c = \\begin{bmatrix} 0.0 \\end{bmatrix}$.\n- 测试用例 3 (多个潜在接触):\n  - $n=2$, $m=3$\n  - $K = \\begin{bmatrix} 1200 & 100 \\\\ 100 & 800 \\end{bmatrix}$,\n  - $f = \\begin{bmatrix} 70 \\\\ 40 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ 1 & 1 \\end{bmatrix}$,\n  - $c = \\begin{bmatrix} 0.08 \\\\ 0.02 \\\\ 0.10 \\end{bmatrix}$.\n\n算法要求：\n- 初始化时没有活动约束，$A=\\emptyset$。\n- 在每次迭代中，为当前活动集 $A$ 求解等式约束系统：\n  $$\n  \\begin{bmatrix}\n  K & -B_A^\\top \\\\\n  B_A & 0\n  \\end{bmatrix}\n  \\begin{bmatrix}\n  u \\\\ \\lambda_A\n  \\end{bmatrix}\n  =\n  \\begin{bmatrix}\n  f \\\\ c_A\n  \\end{bmatrix},\n  $$\n  其中 $B_A$ 由 $B$ 中由 $A$ 索引的行构成，$c_A$ 由 $c$ 中相应的条目构成。对所有 $i \\notin A$ 设置 $\\lambda_i = 0$。\n- 计算间隙 $g(u) = B u - c$ 并通过以下方式更新活动集：\n  - 添加任何满足 $g_i(u) < -\\varepsilon_g$ 的索引 $i$，\n  - 移除任何满足 $\\lambda_i < -\\varepsilon_\\lambda$ 的活动索引 $i \\in A$，\n  其中 $\\varepsilon_g$ 和 $\\varepsilon_\\lambda$ 是小容差。\n- 当活动集在迭代之间不再变化，并且所有非活动约束满足 $g_i(u) \\ge -\\varepsilon_g$ 且所有活动约束满足 $\\lambda_i \\ge -\\varepsilon_\\lambda$ 时终止。\n\n输出规范：\n- 对于每个测试用例，计算位移向量 $u$、完整的乘子向量 $\\lambda$（与 $B$ 的行对齐）、标量目标值 $\\Pi(u)$ 以及活动集算法所用的整数迭代次数。\n- 你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。此列表的每个元素对应一个测试用例，并且其本身必须是 $[u_1,\\dots,u_n,\\lambda_1,\\dots,\\lambda_m,\\Pi(u),\\text{iters}]$ 的形式。例如，一个包含三个测试用例的行可能看起来像\n$[[u_{1,1},u_{1,2},\\lambda_{1,1},\\Pi_1,\\text{iters}_1],[u_{2,1},u_{2,2},\\lambda_{2,1},\\Pi_2,\\text{iters}_2],[\\dots]]$，\n打印输出中没有空格。\n\n在此问题中，所有量都是无量纲的，并且不出现角度。最终输出是纯数字。实现该算法，为所提供的测试套件生成结果。",
            "solution": "所提出的问题是一个标准的带线性不等式约束的二次规划问题，它源于线性弹性中无摩擦单边接触的有限元公式。该问题是适定的，有科学依据，并为其求解提供了所有必要的信息。我们接下来进行推导和算法实现。\n\n### 第 1 部分：Karush–Kuhn–Tucker (KKT) 系统的推导\n\n任务是找到位移向量 $u$，使其在代表非穿透的一组线性不等式约束下，最小化总势能 $\\Pi(u)$。\n\n该优化问题为：\n$$\n\\min_{u \\in \\mathbb{R}^n} \\quad \\Pi(u) = \\tfrac{1}{2} u^\\top K u - f^\\top u\n$$\n$$\n\\text{subject to} \\quad g(u) = B u - c \\ge 0\n$$\n\n这里，$K$ 是对称正定刚度矩阵，$f$ 是外力向量，$u$ 是位移向量，$B$ 是将位移映射到间隙值的约束梯度矩阵，$c$ 是初始间隙向量。由于 $K$ 是正定的，目标函数 $\\Pi(u)$ 是严格凸的，由线性约束定义的可行域也是凸的。因此，存在唯一解。\n\n为了解决这个约束优化问题，我们引入一个与 $m$ 个不等式约束相关的拉格朗日乘子向量 $\\lambda \\in \\mathbb{R}^m$。拉格朗日函数 $\\mathcal{L}(u, \\lambda)$ 是通过将目标函数与约束增广而形成的：\n$$\n\\mathcal{L}(u, \\lambda) = \\Pi(u) - \\lambda^\\top g(u) = \\tfrac{1}{2} u^\\top K u - f^\\top u - \\lambda^\\top (B u - c)\n$$\n对于这个凸问题，KKT 条件为最优性提供了充要条件。它们从拉格朗日函数的平稳性、原始可行性、对偶可行性和互补性推导而来。\n\n1.  **$\\mathcal{L}$ 关于 $u$ 的平稳性**：拉格朗日函数关于原始变量 $u$ 的梯度必须为零。\n    $$\n    \\nabla_u \\mathcal{L}(u, \\lambda) = \\frac{\\partial}{\\partial u} \\left( \\tfrac{1}{2} u^\\top K u - f^\\top u - \\lambda^\\top B u + \\lambda^\\top c \\right) = K u - f - B^\\top \\lambda = 0\n    $$\n    这个方程代表了力的平衡：内部弹性力 ($K u$) 必须与外部施加的力 ($f$) 和接触力 ($B^\\top \\lambda$) 相平衡。\n\n2.  **原始可行性**：解 $u$ 必须满足约束条件。\n    $$\n    g(u) = B u - c \\ge 0\n    $$\n    这是非穿透条件。\n\n3.  **对偶可行性**：代表接触牵引力大小的拉格朗日乘子必须是非负的。\n    $$\n    \\lambda \\ge 0\n    $$\n    这强制要求接触力是压缩性的（排斥力），而不是粘附性的（拉伸力）。\n\n4.  **互补松弛性**：对于每个约束 $i \\in \\{1, \\dots, m\\}$，乘子与间隙的乘积必须为零。\n    $$\n    \\lambda_i g_i(u) = \\lambda_i (B u - c)_i = 0\n    $$\n    这个条件表明，只有当间隙闭合时接触力才能存在（$\\lambda_i > 0 \\implies g_i(u) = 0$），而如果间隙是打开的，则不能有接触力（$g_i(u) > 0 \\implies \\lambda_i = 0$）。\n\n这四个条件共同构成了定义解 $(u, \\lambda)$ 的完整 KKT 系统。\n\n### 第 2 部分：活动集算法和子问题公式化\n\n活动集方法是一种迭代算法，它通过在每一步将约束划分为一个*活动集* $A$ 和一个*非活动集* $I$ 来求解 KKT 系统。\n-   对于活动集 $A$ 中的约束，我们将其作为等式强制执行：$g_i(u) = 0$。\n-   对于非活动集 $I$ 中的约束，我们假设它们不起作用，并将其对应的乘子设为零：$\\lambda_i = 0$。\n\n在每次迭代中，我们假设划分是正确的，并求解 $(u, \\lambda_A)$。然后我们使用该解来检查我们的假设是否有效，并相应地更新集合 $A$ 和 $I$。\n\n设 $A$ 是当前活动约束的索引集。设 $B_A$ 是 $B$ 中由 $A$ 索引的行构成的子矩阵，设 $c_A$ 是 $c$ 中对应的子向量。活动约束作为等式被强制执行：\n$$\nB_A u = c_A\n$$\n平衡方程，仅考虑与活动集相关的非零乘子 $\\lambda_A$，变为：\n$$\nK u - B_A^\\top \\lambda_A = f\n$$\n这两个矩阵方程为未知数 $u$ 和 $\\lambda_A$ 构成了一个线性系统。我们可以将其写成一个单一的分块矩阵系统，这是一个鞍点问题：\n$$\n\\begin{bmatrix}\nK & -B_A^\\top \\\\\nB_A & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\ \\lambda_A\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf \\\\ c_A\n\\end{bmatrix}\n$$\n这就是在活动集算法的每次迭代中必须求解的等式约束系统，如问题陈述中所指定。该算法按以下步骤进行：\n\n1.  **初始化**：以一个空的活动集 $A = \\emptyset$ 开始。设置一个迭代计数器。\n2.  **求解**：为当前活动集 $A$ 构建并求解分块线性系统，以找到 $u$ 和 $\\lambda_A$ 的当前试验解。如果 $A$ 为空，则系统是无约束的，$K u = f$，且所有 $\\lambda_i = 0$。否则，求解鞍点系统。通过为 $i \\notin A$ 设置 $\\lambda_i = 0$ 来重构完整的乘子向量 $\\lambda$。\n3.  **更新活动集**：检查 KKT 符号条件的违反情况。\n    -   **原始违规**：检查所有非活动约束（$i \\notin A$）。如果任何 $g_i(u) = (B u - c)_i < -\\varepsilon_g$（其中 $\\varepsilon_g$ 是一个小容差），则意味着该约束被违反（穿透）。将索引 $i$ 添加到活动集 $A$ 中。\n    -   **对偶违规**：检查所有活动约束（$i \\in A$）。如果任何 $\\lambda_i < -\\varepsilon_\\lambda$（其中 $\\varepsilon_\\lambda$ 是一个小容差），则意味着接触力是拉伸性的，这是不符合物理的。从活动集 $A$ 中移除索引 $i$。\n4.  **收敛**：将新的活动集与前一次迭代的集合进行比较。如果活动集没有改变，则算法已收敛。当前的 $u$ 和 $\\lambda$ 在所选容差内满足所有 KKT 条件。否则，增加迭代计数器并返回第 2 步。\n当活动集稳定时，算法终止，确保所有非活动约束的间隙为非负，所有活动约束的乘子为非负。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef active_set_solver(K, f, B, c, tol=1e-9, max_iters=50):\n    \"\"\"\n    Solves a quadratic programming problem with linear inequality constraints\n    arising from frictionless contact using an active-set method.\n\n    min 0.5 * u.T @ K @ u - f.T @ u\n    s.t. B @ u - c >= 0\n\n    Args:\n        K (np.ndarray): Symmetric positive-definite stiffness matrix (n, n).\n        f (np.ndarray): External load vector (n,).\n        B (np.ndarray): Constraint matrix (m, n).\n        c (np.ndarray): Initial gap vector (m,).\n        tol (float): Tolerance for constraint violation checks.\n        max_iters (int): Maximum number of iterations.\n\n    Returns:\n        tuple: A tuple containing:\n            - u (np.ndarray): Displacement vector (n,).\n            - lmbda (np.ndarray): Lagrange multiplier vector (m,).\n            - potential_energy (float): The value of the objective function.\n            - iters (int): The number of iterations taken.\n    \"\"\"\n    n = K.shape[0]\n    m = B.shape[0]\n\n    # Initialize with no active constraints.\n    active_set = set()\n    iters = 0\n\n    for i in range(max_iters):\n        iters = i + 1\n        old_active_set = active_set.copy()\n\n        # Step 1: Solve the equality-constrained subproblem for the current active set.\n        active_indices = sorted(list(active_set))\n        num_active = len(active_indices)\n        \n        # Initialize lambda for this iteration\n        lmbda = np.zeros(m)\n\n        if num_active == 0:\n            # Unconstrained problem: K u = f\n            try:\n                u = np.linalg.solve(K, f)\n            except np.linalg.LinAlgError:\n                # Fallback for ill-conditioned K; not expected for this problem's setup\n                u = np.linalg.pinv(K) @ f\n        else:\n            B_A = B[active_indices, :]\n            c_A = c[active_indices]\n\n            # Form the KKT (saddle-point) matrix and RHS vector\n            # [  K    -B_A.T ] [  u  ] = [  f  ]\n            # [ B_A      0   ] [ l_A ]   [ c_A ]\n            KKT_mat = np.block([\n                [K, -B_A.T],\n                [B_A, np.zeros((num_active, num_active))]\n            ])\n            rhs = np.concatenate([f, c_A])\n            \n            try:\n                solution = np.linalg.solve(KKT_mat, rhs)\n            except np.linalg.LinAlgError:\n                # Should not occur if constraints are LI and K is SPD\n                solution = np.linalg.pinv(KKT_mat) @ rhs\n            \n            u = solution[:n]\n            lmbda_A = solution[n:]\n            \n            # Place active multipliers back into the full lambda vector\n            for j, idx in enumerate(active_indices):\n                lmbda[idx] = lmbda_A[j]\n\n        # Step 2: Check for KKT violations and update active set.\n        gaps = B @ u - c\n        \n        # Check for inactive constraints that have become violated (g_i < -tol)\n        # Find indices to add to the active set.\n        newly_active = {j for j in range(m) if j not in active_set and gaps[j] < -tol}\n        active_set.update(newly_active)\n        \n        # Check for active constraints with negative multipliers (lambda_i < -tol)\n        # Find indices to remove from the active set.\n        newly_inactive = {j for j in active_set if lmbda[j] < -tol}\n        active_set.difference_update(newly_inactive)\n\n        # Step 3: Check for convergence.\n        if active_set == old_active_set:\n            break\n            \n    # Calculate final potential energy\n    potential_energy = 0.5 * u.T @ K @ u - f.T @ u\n    \n    return u, lmbda, potential_energy, iters\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: n=2, m=1\n        {\n            \"K\": np.array([[1000., 0.], [0., 500.]]),\n            \"f\": np.array([100., 50.]),\n            \"B\": np.array([[1., 0.]]),\n            \"c\": np.array([0.1])\n        },\n        # Test Case 2: n=2, m=1\n        {\n            \"K\": np.array([[1000., -200.], [-200., 300.]]),\n            \"f\": np.array([50., 20.]),\n            \"B\": np.array([[0., 1.]]),\n            \"c\": np.array([0.0])\n        },\n        # Test Case 3: n=2, m=3\n        {\n            \"K\": np.array([[1200., 100.], [100., 800.]]),\n            \"f\": np.array([70., 40.]),\n            \"B\": np.array([[1., 0.], [0., 1.], [1., 1.]]),\n            \"c\": np.array([0.08, 0.02, 0.10])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        u, lmbda, pi_val, iters = active_set_solver(\n            case[\"K\"], case[\"f\"], case[\"B\"], case[\"c\"]\n        )\n        \n        # Format the result list for this case: [u_1, ..., lambda_1, ..., pi, iters]\n        result_list = list(u) + list(lmbda) + [pi_val, float(iters)]\n        results.append(result_list)\n\n    # Format the final output string exactly as required, with no spaces.\n    result_str = \"[\" + \",\".join([\n        \"[\" + \",\".join(map(str, res)) + \"]\" for res in results\n    ]) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "尽管主动集算法等方法非常严谨，但罚函数法 (penalty method) 提供了一种更简单且通常计算效率更高的替代方案，尤其适用于大规模问题。然而，这种简化是有代价的：它通过允许微小的、非物理性的穿透，引入了“伪柔度”(artificial compliance)。本练习 () 的任务是通过将基于罚函数法的有限元结果与已知的解析解（Hertz 接触理论）进行比较，来量化这种数值误差，从而阐明在计算成本、稳定性和准确性之间的关键权衡。",
            "id": "4167061",
            "problem": "考虑生物力学中的一个轴对称法向接触基准问题：一个半径为 $R$ 的线性弹性球形压头在给定的法向载荷 $P$ 作用下，压在一个刚性平面上。该球体的杨氏模量为 $E_1$，泊松比为 $\\nu_1$。在有限元法 (FEM) 接触仿真中，法向接触约束可以通过罚函数法来施加，其中法向罚刚度 $k_n$ 将负间隙与接触力关联起来。这种施加方式会引入人为柔度，因为当接触力有限时，允许存在非零的互穿。您的任务是通过计算不同 $k_n$ 值下的法向趋近量来量化这种人为柔度。\n\n基本原理：\n- 根据静力学问题的牛顿定律，在法向力平衡条件下，接触力等于给定的载荷 $P$。\n- 关于球体在刚性平面上的 Hertz 接触理论指出，纯物理压痕（法向趋近量）$\\delta_{\\mathrm{H}}$ 满足经过充分检验的公式 $P = \\frac{4}{3} E^\\star R^{1/2} \\delta_{\\mathrm{H}}^{3/2}$，其中 $E^\\star$ 是等效模量，对于可变形球体与刚性平面接触的情况，其定义为 $\\frac{1}{E^\\star} = \\frac{1 - \\nu_1^2}{E_1}$。\n- FEM 中的罚函数法施加在接触力 $P$ 和互穿量 $\\delta_{\\mathrm{pen}}$ 之间应用了本构关系 $P = k_n \\,\\delta_{\\mathrm{pen}}$，从而引入了人为柔度。\n\n建模假设：\n- 将物理 Hertz 柔度和罚柔度视为在相同载荷 $P$ 下，在接触界面处沿法向串联作用，因此总法向趋近量为 $\\delta_{\\mathrm{tot}} = \\delta_{\\mathrm{H}} + \\delta_{\\mathrm{pen}}$。\n\n任务：\n1. 基于上述原理，推导出纯物理 Hertz 压痕 $\\delta_{\\mathrm{H}}$ 关于 $P$、$E^\\star$ 和 $R$ 的公式，以及罚函数引起的互穿量 $\\delta_{\\mathrm{pen}}$ 关于 $P$ 和 $k_n$ 的公式。\n2. 对于给定的罚刚度 $k_n$ 测试组，计算总法向趋近量 $\\delta_{\\mathrm{tot}} = \\delta_{\\mathrm{H}} + \\delta_{\\mathrm{pen}}$ 和人为部分占比 $f_{\\mathrm{art}} = \\delta_{\\mathrm{pen}} / \\delta_{\\mathrm{tot}}$。\n3. 将总法向趋近量以毫米表示，人为部分占比以小数（非百分比）表示。将这两个量均四舍五入至六位小数。\n\n使用以下材料、几何参数及载荷：\n- $E_1 = 5 \\times 10^6$ $\\mathrm{Pa}$。\n- $\\nu_1 = 0.49$。\n- $R = 1.0 \\times 10^{-2}$ $\\mathrm{m}$。\n- $P = 1.0 \\times 10^{1}$ $\\mathrm{N}$。\n\n$k_n$ 测试组：\n- 情况 A（理想情况，中等罚值）：$k_n = 1.0 \\times 10^{6}$ $\\mathrm{N/m}$。\n- 情况 B（边缘情况，小罚值）：$k_n = 1.0 \\times 10^{5}$ $\\mathrm{N/m}$。\n- 情况 C（覆盖性情况，较大罚值）：$k_n = 1.0 \\times 10^{8}$ $\\mathrm{N/m}$。\n- 情况 D（边界情况，接近约束极限）：$k_n = 1.0 \\times 10^{12}$ $\\mathrm{N/m}$。\n- 情况 E（覆盖性情况，中高罚值）：$k_n = 1.0 \\times 10^{9}$ $\\mathrm{N/m}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由子列表组成的逗号分隔列表，并用方括号括起来，无空格。每个子列表必须包含两个浮点数：$[\\delta_{\\mathrm{tot}}\\ \\text{（毫米）},\\ f_{\\mathrm{art}}]$，两者都四舍五入到六位小数。例如：$[[d_1,f_1],[d_2,f_2],[d_3,f_3]]$。",
            "solution": "经评估，该问题有效。它在科学上基于接触力学（Hertz 理论）和计算力学（FEM 中的罚函数法）的原理。问题是适定的，提供了所有必要的参数、方程和边界条件以推导出唯一且稳定的解。问题陈述客观、完整，且无矛盾或歧义。\n\n求解过程分为两个阶段：首先，推导控制方程；其次，对指定的测试用例进行数值计算。\n\n**1. 控制方程的推导**\n\n问题要求量化总法向趋近量 $\\delta_{\\mathrm{tot}}$，其被建模为物理压痕 $\\delta_{\\mathrm{H}}$ 与人为罚函数引起的互穿量 $\\delta_{\\mathrm{pen}}$ 之和。\n$$\n\\delta_{\\mathrm{tot}} = \\delta_{\\mathrm{H}} + \\delta_{\\mathrm{pen}}\n$$\n这代表了一个模型，其中材料的物理柔度和罚约束的数值柔度在给定的载荷 $P$ 下串联作用。\n\n首先，我们推导物理 Hertz 压痕 $\\delta_{\\mathrm{H}}$ 的表达式。关于球体在刚性平面上的 Hertz 接触理论提供了以下关系：\n$$\nP = \\frac{4}{3} E^\\star R^{1/2} \\delta_{\\mathrm{H}}^{3/2}\n$$\n其中 $P$ 是法向载荷，$R$ 是球体半径，$E^\\star$ 是等效模量。通过代数变换求解 $\\delta_{\\mathrm{H}}$：\n$$\n\\delta_{\\mathrm{H}}^{3/2} = \\frac{3P}{4 E^\\star R^{1/2}}\n$$\n将两边取 $2/3$ 次幂，得到 $\\delta_{\\mathrm{H}}$ 的公式：\n$$\n\\delta_{\\mathrm{H}} = \\left(\\frac{3P}{4 E^\\star R^{1/2}}\\right)^{2/3}\n$$\n对于可变形球体（杨氏模量为 $E_1$，泊松比为 $\\nu_1$）与刚性平面之间的接触，等效模量 $E^\\star$ 由下式给出：\n$$\n\\frac{1}{E^\\star} = \\frac{1 - \\nu_1^2}{E_1} \\implies E^\\star = \\frac{E_1}{1 - \\nu_1^2}\n$$\n\n接下来，我们推导罚函数引起的互穿量 $\\delta_{\\mathrm{pen}}$ 的表达式。FEM 中的罚函数法通过法向罚刚度 $k_n$ 在接触力（在平衡时必须等于施加的载荷 $P$）和互穿量 $\\delta_{\\mathrm{pen}}$ 之间引入了一个线性本构关系：\n$$\nP = k_n \\delta_{\\mathrm{pen}}\n$$\n求解 $\\delta_{\\mathrm{pen}}$ 得：\n$$\n\\delta_{\\mathrm{pen}} = \\frac{P}{k_n}\n$$\n这一项代表人为柔度，因为它允许非物理的互穿，该互穿量随着罚刚度 $k_n$ 的增加而减小。\n\n最后，人为部分占比 $f_{\\mathrm{art}}$ 定义为罚函数引起的互穿量与总趋近量之比：\n$$\nf_{\\mathrm{art}} = \\frac{\\delta_{\\mathrm{pen}}}{\\delta_{\\mathrm{tot}}} = \\frac{\\delta_{\\mathrm{pen}}}{\\delta_{\\mathrm{H}} + \\delta_{\\mathrm{pen}}}\n$$\n\n**2. 测试用例的数值计算**\n\n给定以下参数：\n- 杨氏模量: $E_1 = 5 \\times 10^6$ $\\mathrm{Pa}$\n- 泊松比: $\\nu_1 = 0.49$\n- 压头半径: $R = 1.0 \\times 10^{-2}$ $\\mathrm{m}$\n- 法向载荷: $P = 1.0 \\times 10^{1}$ $\\mathrm{N}$\n\n首先，我们计算常数值 $E^\\star$ 和 $\\delta_{\\mathrm{H}}$。\n等效模量 $E^\\star$ 为：\n$$\nE^\\star = \\frac{E_1}{1 - \\nu_1^2} = \\frac{5 \\times 10^6}{1 - (0.49)^2} = \\frac{5 \\times 10^6}{1 - 0.2401} = \\frac{5 \\times 10^6}{0.7599} \\approx 6.579813 \\times 10^6 \\ \\mathrm{Pa}\n$$\n物理 Hertz 压痕 $\\delta_{\\mathrm{H}}$ 对所有测试用例都是恒定的：\n$$\n\\delta_{\\mathrm{H}} = \\left(\\frac{3 \\times 10}{4 \\times (6.579813 \\times 10^6) \\times (1.0 \\times 10^{-2})^{1/2}}\\right)^{2/3} = \\left(\\frac{30}{4 \\times (6.579813 \\times 10^6) \\times 0.1}\\right)^{2/3}\n$$\n$$\n\\delta_{\\mathrm{H}} = \\left(\\frac{30}{2.631925 \\times 10^6}\\right)^{2/3} \\approx (1.140003 \\times 10^{-5})^{2/3} \\approx 5.0853335 \\times 10^{-4} \\ \\mathrm{m}\n$$\n这个 $\\delta_{\\mathrm{H}} \\approx 0.5085$ $\\mathrm{mm}$ 的值是纯物理压痕。现在我们为每个给定的罚刚度 $k_n$ 评估结果。\n\n- **情况 A:** $k_n = 1.0 \\times 10^{6}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^6} = 1.0 \\times 10^{-5}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-5}) = 5.1853335 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.518533$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-5}}{5.1853335 \\times 10^{-4}} \\approx 0.019285$\n\n- **情况 B:** $k_n = 1.0 \\times 10^{5}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^5} = 1.0 \\times 10^{-4}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-4}) = 6.0853335 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.608533$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-4}}{6.0853335 \\times 10^{-4}} \\approx 0.164330$\n\n- **情况 C:** $k_n = 1.0 \\times 10^{8}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^8} = 1.0 \\times 10^{-7}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-7}) = 5.0863335 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.508633$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-7}}{5.0863335 \\times 10^{-4}} \\approx 0.000197$\n\n- **情况 D:** $k_n = 1.0 \\times 10^{12}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^{12}} = 1.0 \\times 10^{-11}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-11}) = 5.0853336 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.508533$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-11}}{5.0853336 \\times 10^{-4}} \\approx 1.966 \\times 10^{-8} \\approx 0.000000$\n\n- **情况 E:** $k_n = 1.0 \\times 10^{9}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^9} = 1.0 \\times 10^{-8}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-8}) = 5.0854335 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.508543$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-8}}{5.0854335 \\times 10^{-4}} \\approx 1.96639 \\times 10^{-5} \\approx 0.000020$\n\n结果显示了一个清晰的趋势：随着罚刚度 $k_n$ 的增加，罚函数引起的互穿量 $\\delta_{\\mathrm{pen}}$ 减小，总趋近量 $\\delta_{\\mathrm{tot}}$ 收敛于纯物理 Hertz 压痕 $\\delta_{\\mathrm{H}}$。因此，柔度的人为部分占比 $f_{\\mathrm{art}}$ 趋近于零，表明接触约束的施加更为准确。相反，较低的罚刚度（情况 B）会导致显著的人为柔度，其中超过 16% 的总位移是非物理的互穿量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total normal approach and artificial compliance fraction\n    for a spherical indenter on a rigid flat using a penalty contact model.\n    \"\"\"\n\n    # Define material, geometric, and loading parameters from the problem statement.\n    # All units are SI (meters, Pascals, Newtons).\n    E1 = 5.0e6  # Young's modulus of the sphere in Pa\n    nu1 = 0.49  # Poisson's ratio of the sphere\n    R = 1.0e-2  # Radius of the sphere in m\n    P = 1.0e1   # Prescribed normal load in N\n\n    # Define the test suite of penalty stiffnesses (k_n in N/m).\n    # The order is Case A, B, C, D, E as specified.\n    test_cases_kn = [\n        1.0e6,   # Case A\n        1.0e5,   # Case B\n        1.0e8,   # Case C\n        1.0e12,  # Case D\n        1.0e9    # Case E\n    ]\n\n    # --- Calculations ---\n\n    # 1. Calculate the effective modulus (E*)\n    # For a deformable sphere on a rigid flat: 1/E* = (1 - nu1^2) / E1\n    E_star = E1 / (1 - nu1**2)\n\n    # 2. Calculate the purely physical Hertzian indentation (delta_H)\n    # This value is constant for all test cases.\n    # P = (4/3) * E* * R^(1/2) * delta_H^(3/2)\n    # => delta_H = ( (3*P) / (4 * E_star * R**0.5) )**(2/3)\n    delta_H = ((3 * P) / (4 * E_star * R**0.5))**(2/3)\n\n    results = []\n    # 3. Loop through each test case for k_n\n    for kn in test_cases_kn:\n        # a. Calculate penalty-induced interpenetration (delta_pen)\n        # P = kn * delta_pen => delta_pen = P / kn\n        delta_pen = P / kn\n\n        # b. Calculate total normal approach (delta_tot)\n        # delta_tot = delta_H + delta_pen\n        delta_tot = delta_H + delta_pen\n\n        # c. Calculate the artificial fraction (f_art)\n        # f_art = delta_pen / delta_tot\n        f_art = delta_pen / delta_tot\n\n        # d. Convert total approach to millimeters for output\n        delta_tot_mm = delta_tot * 1000\n\n        # e. Store the rounded results as a pair\n        # The problem requires rounding to six decimal places.\n        # String formatting is used for reliable rounding for display.\n        results.append((delta_tot_mm, f_art))\n\n    # --- Final Output Formatting ---\n\n    # Format each result pair as a sublist string \"[val1,val2]\"\n    # using format specifiers to ensure 6 decimal places.\n    sublist_strs = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    \n    # Join the sublist strings with commas and enclose in brackets.\n    # Example format: [[d1,f1],[d2,f2],[d3,f3]]\n    final_output = f\"[{','.join(sublist_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}