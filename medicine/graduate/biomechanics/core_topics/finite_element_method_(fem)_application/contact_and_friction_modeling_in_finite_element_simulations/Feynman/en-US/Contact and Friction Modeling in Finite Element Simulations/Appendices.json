{
    "hands_on_practices": [
        {
            "introduction": "The first step in any contact simulation is purely geometric: determining if, where, and by how much contacting bodies are penetrating. This is handled by a closest-point projection algorithm, which forms the kinematic basis for applying contact laws. This exercise takes you \"under the hood\" of a finite element code to implement this fundamental search algorithm for a slave point and a triangular master facet . Mastering this builds a core understanding of contact kinematics, including the crucial definitions of the normal gap $g_n$ and tangential gap vector $\\boldsymbol{g}_t$, which are the inputs for any contact enforcement law.",
            "id": "4167128",
            "problem": "A triangular master facet in a finite element contact setting is defined by three vertices in the current configuration, $x_1, x_2, x_3 \\in \\mathbb{R}^3$, with units in meters. A slave point $x_s \\in \\mathbb{R}^3$ (meters) approaches this facet. In the context of the Finite Element Method (FEM), a linear triangular facet uses local coordinates $(\\xi,\\eta)$ with shape functions $N_1 = 1 - \\xi - \\eta$, $N_2 = \\xi$, $N_3 = \\eta$, so that any point on the facet can be interpolated as $x_m(\\xi,\\eta) = N_1 x_1 + N_2 x_2 + N_3 x_3$ for $\\xi \\ge 0$, $\\eta \\ge 0$, and $\\xi + \\eta \\le 1$. The unit normal $\\hat{\\boldsymbol{n}}$ of the facet is defined by the right-hand rule based on the vertex ordering $x_1 \\rightarrow x_2 \\rightarrow x_3$.\n\nStarting from first principles of Euclidean geometry and interpolation in finite elements, construct an algorithm that, given $x_1$, $x_2$, $x_3$, and $x_s$, finds the closest point $x_m$ on the facet (including its boundary) to $x_s$. The algorithm must:\n- Determine $(\\xi,\\eta)$ of $x_m$ consistent with the linear triangular parameterization.\n- Compute the normal gap $g_n = \\hat{\\boldsymbol{n}} \\cdot (x_s - x_m)$ in meters.\n- Compute the tangential gap vector $\\boldsymbol{g}_t = ( \\mathbf{I} - \\hat{\\boldsymbol{n}} \\hat{\\boldsymbol{n}}^\\top )(x_s - x_m)$ in meters, where $\\mathbf{I}$ is the identity matrix in $\\mathbb{R}^3$.\n\nDerive this algorithm from the following foundational base:\n- Euclidean inner products, projections, and distances in $\\mathbb{R}^3$.\n- Linear interpolation on a triangle using $N_1$, $N_2$, $N_3$.\n- The definition of the unit normal from the cross product of two edges.\n\nDo not use any shortcut formulas that skip the derivation from these bases. Your algorithm must correctly handle whether the orthogonal projection of $x_s$ onto the facet plane lies inside the triangle or outside, in which case the closest point lies on one of the edges or vertices. All distances must be in meters.\n\nImplement this algorithm in a program that processes the following test suite of cases (units are meters). For each case, $x_1$, $x_2$, $x_3$, and $x_s$ are given:\n\n- Case $1$ (interior projection, oblique offset):\n  $x_1 = (0.000,\\,0.000,\\,0.000)$,\n  $x_2 = (0.030,\\,0.000,\\,0.000)$,\n  $x_3 = (0.000,\\,0.020,\\,0.000)$,\n  $x_s = (0.010,\\,0.005,\\,0.001)$.\n- Case $2$ (closest to edge $x_1$–$x_2$):\n  $x_1 = (0.000,\\,0.000,\\,0.000)$,\n  $x_2 = (0.030,\\,0.000,\\,0.000)$,\n  $x_3 = (0.000,\\,0.020,\\,0.000)$,\n  $x_s = (0.020,\\,-0.010,\\,0.002)$.\n- Case $3$ (closest to vertex $x_3$):\n  $x_1 = (0.000,\\,0.000,\\,0.000)$,\n  $x_2 = (0.030,\\,0.000,\\,0.000)$,\n  $x_3 = (0.000,\\,0.020,\\,0.000)$,\n  $x_s = (-0.001,\\,0.021,\\,0.0005)$.\n- Case $4$ (oblique triangle, interior projection):\n  $x_1 = (0.000,\\,0.000,\\,0.000)$,\n  $x_2 = (0.020,\\,0.000,\\,0.005)$,\n  $x_3 = (0.000,\\,0.030,\\,-0.004)$,\n  $x_s = (0.010,\\,0.015,\\,0.002)$.\n- Case $5$ (on-plane interior point):\n  $x_1 = (0.000,\\,0.000,\\,0.000)$,\n  $x_2 = (0.030,\\,0.000,\\,0.000)$,\n  $x_3 = (0.000,\\,0.020,\\,0.000)$,\n  $x_s = (0.015,\\,0.005,\\,0.000)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case result represented by a list $[\\xi,\\eta,g_n,g_{t,x},g_{t,y},g_{t,z}]$ in meters, and with no spaces. For example, the output must have the format:\n$[[\\xi_1,\\eta_1,g_{n,1},g_{t,x,1},g_{t,y,1},g_{t,z,1}],[\\xi_2,\\eta_2,g_{n,2},g_{t,x,2},g_{t,y,2},g_{t,z,2}],\\dots]$.",
            "solution": "The problem requires the development of an algorithm to find the closest point $x_m$ on a triangular master facet to a given slave point $x_s$. The algorithm must be derived from first principles of Euclidean geometry and finite element interpolation. The final outputs are the local coordinates $(\\xi, \\eta)$ of the closest point, the normal gap $g_n$, and the tangential gap vector $\\boldsymbol{g}_t$.\n\nThe core of the problem is to minimize the squared Euclidean distance $d^2 = \\|x_m - x_s\\|^2$ subject to the constraint that $x_m$ lies on the triangular facet defined by vertices $x_1, x_2, x_3 \\in \\mathbb{R}^3$.\n\nFirst, we establish the geometric parameterization of the facet. Any point $x_m$ on the facet is a linear interpolation of its vertices using barycentric shape functions $N_1=1-\\xi-\\eta$, $N_2=\\xi$, and $N_3=\\eta$:\n$$x_m(\\xi, \\eta) = N_1 x_1 + N_2 x_2 + N_3 x_3 = (1-\\xi-\\eta)x_1 + \\xi x_2 + \\eta x_3$$\nThe point $x_m$ is within the triangle (including its boundary) if the local coordinates $(\\xi, \\eta)$ satisfy the conditions $\\xi \\ge 0$, $\\eta \\ge 0$, and $\\xi+\\eta \\le 1$. We can rewrite the interpolation formula in terms of edge vectors originating from vertex $x_1$. Let $e_1 = x_2 - x_1$ and $e_2 = x_3 - x_1$. The formula becomes:\n$$x_m(\\xi, \\eta) = x_1 + \\xi e_1 + \\eta e_2$$\nThe squared distance to the slave point $x_s$ is then a function of $(\\xi, \\eta)$:\n$$f(\\xi, \\eta) = \\|x_m(\\xi, \\eta) - x_s\\|^2 = \\|x_1 + \\xi e_1 + \\eta e_2 - x_s\\|^2$$\nLet the vector from $x_1$ to $x_s$ be $v = x_s - x_1$. The function to minimize is:\n$$f(\\xi, \\eta) = \\|\\xi e_1 + \\eta e_2 - v\\|^2 = (\\xi e_1 + \\eta e_2 - v) \\cdot (\\xi e_1 + \\eta e_2 - v)$$\nExpanding this inner product gives a quadratic function of $\\xi$ and $\\eta$:\n$$f(\\xi, \\eta) = \\xi^2 (e_1 \\cdot e_1) + \\eta^2 (e_2 \\cdot e_2) + 2\\xi\\eta (e_1 \\cdot e_2) - 2\\xi (e_1 \\cdot v) - 2\\eta (e_2 \\cdot v) + (v \\cdot v)$$\nTo find the closest point on the infinite plane containing the triangle, we perform an unconstrained minimization of $f(\\xi, \\eta)$ by setting its gradient to zero: $\\nabla f = (\\frac{\\partial f}{\\partial \\xi}, \\frac{\\partial f}{\\partial \\eta}) = (0, 0)$.\n$$\\frac{\\partial f}{\\partial \\xi} = 2\\xi (e_1 \\cdot e_1) + 2\\eta (e_1 \\cdot e_2) - 2(e_1 \\cdot v) = 0$$\n$$\\frac{\\partial f}{\\partial \\eta} = 2\\eta (e_2 \\cdot e_2) + 2\\xi (e_1 \\cdot e_2) - 2(e_2 \\cdot v) = 0$$\nThis yields a $2 \\times 2$ linear system for the optimal $(\\xi, \\eta)$, which we denote $(\\xi^*, \\eta^*)$:\n$$\n\\begin{pmatrix}\ne_1 \\cdot e_1 & e_1 \\cdot e_2 \\\\\ne_1 \\cdot e_2 & e_2 \\cdot e_2\n\\end{pmatrix}\n\\begin{pmatrix}\n\\xi^* \\\\\n\\eta^*\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ne_1 \\cdot v \\\\\ne_2 \\cdot v\n\\end{pmatrix}\n$$\nLet $a = e_1 \\cdot e_1$, $b = e_1 \\cdot e_2$, $c = e_2 \\cdot e_2$, $d = e_1 \\cdot v$, and $e = e_2 \\cdot v$. The system is $A \\begin{pmatrix}\\xi^* \\\\ \\eta^*\\end{pmatrix} = \\begin{pmatrix}d \\\\ e\\end{pmatrix}$, where $A=\\begin{pmatrix} a & b \\\\ b & c \\end{pmatrix}$. The solution is:\n$$ \\xi^* = \\frac{cd - be}{ac - b^2}, \\quad \\eta^* = \\frac{ae - bd}{ac - b^2} $$\nThe point $x_m(\\xi^*, \\eta^*)$ is the orthogonal projection of $x_s$ onto the plane of the triangle.\n\nIf this unconstrained solution $(\\xi^*, \\eta^*)$ satisfies the conditions $\\xi^* \\ge 0$, $\\eta^* \\ge 0$, and $\\xi^*+\\eta^* \\le 1$, then the projection lies inside the triangle, and we have found the closest point. However, if any of these conditions are violated, the closest point on the facet must lie on its boundary (one of its three edges or three vertices). The problem becomes a constrained optimization.\n\nWe can systematically find the constrained minimum by checking which boundary region is closest to the unconstrained solution $(\\xi^*, \\eta^*)$. This is equivalent to projecting $x_s$ onto the lines containing the edges and clamping the result to the edge segments, determined by which validity condition on $(\\xi^*, \\eta^*)$ is violated. The algorithm proceeds as follows:\n\nLet $(\\xi, \\eta)$ represent the final, clamped coordinates.\n1.  If $\\xi^* < 0$: The closest point lies on the line segment corresponding to $\\xi = 0$, which is the edge $x_1-x_3$. We find the closest point to $x_s$ on this segment. The parameterminimizing the distance along the line $x_1 \\to x_3$ is $t = \\frac{(x_s-x_1)\\cdot(x_3-x_1)}{\\|x_3-x_1\\|^2} = \\frac{e_2 \\cdot v}{e_2 \\cdot e_2} = \\frac{e}{c}$. We clamp this parameter to the valid range $[0, 1]$. The final coordinates are $(\\xi, \\eta) = (0, \\text{clamp}(t, 0, 1))$.\n\n2.  Else if $\\eta^* < 0$: The closest point lies on the edge $x_1-x_2$ ($\\eta=0$). The parameter along the line $x_1 \\to x_2$ is $t = \\frac{(x_s-x_1)\\cdot(x_2-x_1)}{\\|x_2-x_1\\|^2} = \\frac{e_1 \\cdot v}{e_1 \\cdot e_1} = \\frac{d}{a}$. Clamping to $[0, 1]$ gives the final coordinates $(\\xi, \\eta) = (\\text{clamp}(t, 0, 1), 0)$.\n\n3.  Else if $\\xi^*+\\eta^* > 1$: The closest point lies on the edge $x_2-x_3$ ($\\xi+\\eta=1$). We find the closest point to $x_s$ on the line segment $x_2-x_3$. The parameter along the line $x_2 \\to x_3$ is $t = \\frac{(x_s-x_2)\\cdot(x_3-x_2)}{\\|x_3-x_2\\|^2}$. Clamping to $[0, 1]$ gives $t_{clamped}$. We convert this back to the $(\\xi, \\eta)$ coordinate system. A point on this edge is $x_m = (1-t)x_2 + t x_3$. In our barycentric system, this corresponds to $N_1=0, N_2 = \\xi = 1-t, N_3 = \\eta = t$. So, the final coordinates are $(\\xi, \\eta) = (1-t_{clamped}, t_{clamped})$.\n\n4.  Else: The unconstrained solution $(\\xi^*, \\eta^*)$ is inside the valid domain. The final coordinates are $(\\xi, \\eta) = (\\xi^*, \\eta^*)$.\n\nOnce the final coordinates $(\\xi, \\eta)$ are determined, the closest point on the facet is calculated as $x_m = x_1 + \\xi e_1 + \\eta e_2$.\n\nFinally, we compute the gap quantities. The facet normal vector is defined by the cross product of the edge vectors, $\\boldsymbol{n} = e_1 \\times e_2$, based on the right-hand rule for the vertex ordering $x_1 \\rightarrow x_2 \\rightarrow x_3$. The unit normal is $\\hat{\\boldsymbol{n}} = \\boldsymbol{n} / \\|\\boldsymbol{n}\\|$. The gap vector from the closest point to the slave point is $\\boldsymbol{g} = x_s - x_m$.\n\nThe normal gap $g_n$ is the projection of $\\boldsymbol{g}$ onto the unit normal:\n$$g_n = \\hat{\\boldsymbol{n}} \\cdot \\boldsymbol{g} = \\hat{\\boldsymbol{n}} \\cdot (x_s - x_m)$$\nThe tangential gap vector $\\boldsymbol{g}_t$ is the component of $\\boldsymbol{g}$ orthogonal to the normal, which can be found by subtracting the normal component from the total gap vector:\n$$\\boldsymbol{g}_t = \\boldsymbol{g} - g_n \\hat{\\boldsymbol{n}} = (\\mathbf{I} - \\hat{\\boldsymbol{n}} \\hat{\\boldsymbol{n}}^\\top)(x_s - x_m)$$\nwhere $\\mathbf{I}$ is the $3 \\times 3$ identity matrix. This completes the derivation of the required algorithm from first principles.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_closest_point_on_triangle(x1, x2, x3, xs):\n    \"\"\"\n    Finds the closest point on a triangular facet to a slave point.\n\n    The algorithm is derived from first principles:\n    1. Parameterize the triangle using local coordinates (xi, eta).\n    2. Formulate the squared distance from the slave point to a point on the\n       triangle as a quadratic function of (xi, eta).\n    3. Solve for the unconstrained minimum by setting the gradient to zero,\n       which gives the projection of the slave point onto the infinite plane\n       of the triangle.\n    4. If the projected point is outside the triangle's boundaries (xi < 0,\n       eta < 0, or xi + eta > 1), clamp the solution to the valid region\n       by projecting onto the corresponding edge or vertex.\n    5. With the final (xi, eta), calculate the closest point xm, the normal\n       gap gn, and the tangential gap vector gt.\n    \"\"\"\n    x1 = np.array(x1, dtype=float)\n    x2 = np.array(x2, dtype=float)\n    x3 = np.array(x3, dtype=float)\n    xs = np.array(xs, dtype=float)\n\n    # 1. & 2. Define geometry and formulate minimization problem\n    e1 = x2 - x1\n    e2 = x3 - x1\n    v = xs - x1\n\n    a = np.dot(e1, e1)\n    b = np.dot(e1, e2)\n    c = np.dot(e2, e2)\n    d = np.dot(e1, v)\n    e = np.dot(e2, v)\n    \n    det = a * c - b * b\n\n    # Handle degenerate triangle case (though not expected from problem statement)\n    if np.abs(det) < 1e-15:\n        # Simplified handling for degenerate case: project onto the longest edge.\n        # This is a fallback and not part of the primary algorithm requested.\n        # For simplicity in this problem, we assume non-degenerate triangles.\n        # We can just let the division by zero happen and debug if needed,\n        # but the problem data should be well-behaved.\n        pass\n\n    # 3. Unconstrained minimization: projection onto the plane\n    xi_star = (c * d - b * e) / det\n    eta_star = (a * e - b * d) / det\n\n    # 4. Constrained minimization: clamp to the triangular region [0,1]x[0,1] s.t. xi+eta<=1\n    if xi_star < 0:\n        # Closest point is on edge x1-x3\n        t = e / c if c > 1e-15 else 0.0\n        xi_final = 0.0\n        eta_final = np.clip(t, 0.0, 1.0)\n    elif eta_star < 0:\n        # Closest point is on edge x1-x2\n        t = d / a if a > 1e-15 else 0.0\n        xi_final = np.clip(t, 0.0, 1.0)\n        eta_final = 0.0\n    elif xi_star + eta_star > 1:\n        # Closest point is on edge x2-x3\n        e32 = x3 - x2\n        vs2 = xs - x2\n        t = np.dot(vs2, e32) / np.dot(e32, e32) if np.dot(e32, e32) > 1e-15 else 0.0\n        t_clamped = np.clip(t, 0.0, 1.0)\n        xi_final = 1.0 - t_clamped\n        eta_final = t_clamped\n    else:\n        # The projection is inside the triangle\n        xi_final = xi_star\n        eta_final = eta_star\n\n    # 5. Compute the final quantities\n    xm = x1 + xi_final * e1 + eta_final * e2\n\n    # Normal vector by right-hand rule on (x1, x2, x3)\n    n = np.cross(e1, e2)\n    norm_n = np.linalg.norm(n)\n    if norm_n > 1e-15:\n        n_hat = n / norm_n\n    else: # Fallback for degenerate triangles\n        n_hat = np.array([0., 0., 1.])\n\n    g = xs - xm\n    gn = np.dot(n_hat, g)\n    gt = g - gn * n_hat\n\n    return [xi_final, eta_final, gn, gt[0], gt[1], gt[2]]\n\ndef solve():\n    \"\"\"\n    Main function to process the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.030, 0.000, 0.000), 'x3': (0.000, 0.020, 0.000), 'xs': (0.010, 0.005, 0.001)},\n        # Case 2\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.030, 0.000, 0.000), 'x3': (0.000, 0.020, 0.000), 'xs': (0.020, -0.010, 0.002)},\n        # Case 3\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.030, 0.000, 0.000), 'x3': (0.000, 0.020, 0.000), 'xs': (-0.001, 0.021, 0.0005)},\n        # Case 4\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.020, 0.000, 0.005), 'x3': (0.000, 0.030, -0.004), 'xs': (0.010, 0.015, 0.002)},\n        # Case 5\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.030, 0.000, 0.000), 'x3': (0.000, 0.020, 0.000), 'xs': (0.015, 0.005, 0.000)},\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        result_list = find_closest_point_on_triangle(case['x1'], case['x2'], case['x3'], case['xs'])\n        # Format the list of numbers into a string \"[f1,f2,...]\" without spaces\n        inner_string = f\"[{','.join(map(str, result_list))}]\"\n        results_as_strings.append(inner_string)\n\n    # Format the list of strings into the final output format \"[[...],[...]]\"\n    final_output_string = f\"[{','.join(results_as_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Once contact is detected, the non-penetration condition must be enforced. The penalty method is one of the most common and robust techniques, conceptually adding a stiff spring to resist interpenetration. However, this method is an approximation and introduces a non-physical \"artificial compliance\" into the system. This practice allows you to quantify this numerical error by combining the analytical Hertz contact solution with the penalty formulation . By analyzing how the solution changes with the penalty stiffness $k_n$, you will gain practical insight into the critical trade-off between accuracy and computational stability.",
            "id": "4167061",
            "problem": "Consider an axisymmetric normal contact benchmark in biomechanics: a linearly elastic spherical indenter of radius $R$ presses against a rigid flat under a prescribed normal load $P$. The sphere has Young's modulus $E_1$ and Poisson's ratio $\\nu_1$. In a Finite Element Method (FEM) contact simulation, the normal contact constraint may be enforced using the penalty method, where a normal penalty stiffness $k_n$ relates the negative gap to the contact force. This enforcement introduces artificial compliance because nonzero interpenetration is allowed when the contact force is finite. Your task is to quantify the artificial compliance by computing the normal approach for various $k_n$ values.\n\nFundamental base:\n- Under equilibrium of forces in the normal direction (from Newton's laws for static problems), the contact force equals the prescribed load $P$.\n- Hertz contact theory for a sphere on a rigid flat states that the purely physical indentation (normal approach) $\\delta_{\\mathrm{H}}$ satisfies the well-tested formula $P = \\frac{4}{3} E^\\star R^{1/2} \\delta_{\\mathrm{H}}^{3/2}$, where $E^\\star$ is the effective modulus defined by $\\frac{1}{E^\\star} = \\frac{1 - \\nu_1^2}{E_1}$ for the deformable sphere contacting a rigid flat.\n- Penalty enforcement in FEM applies a constitutive relation $P = k_n \\,\\delta_{\\mathrm{pen}}$ between the contact force $P$ and the interpenetration $\\delta_{\\mathrm{pen}}$, introducing artificial compliance.\n\nModeling assumption:\n- Treat the physical Hertz compliance and the penalty compliance as acting in series in the normal direction at the contact interface under the same load $P$, so the total normal approach is $\\delta_{\\mathrm{tot}} = \\delta_{\\mathrm{H}} + \\delta_{\\mathrm{pen}}$.\n\nTasks:\n1. Using the above base, derive a formula for the purely physical Hertz indentation $\\delta_{\\mathrm{H}}$ in terms of $P$, $E^\\star$, and $R$, and a formula for the penalty-induced interpenetration $\\delta_{\\mathrm{pen}}$ in terms of $P$ and $k_n$.\n2. For the given test suite of penalty stiffnesses $k_n$, compute the total normal approach $\\delta_{\\mathrm{tot}} = \\delta_{\\mathrm{H}} + \\delta_{\\mathrm{pen}}$ and the artificial fraction $f_{\\mathrm{art}} = \\delta_{\\mathrm{pen}} / \\delta_{\\mathrm{tot}}$.\n3. Express the total normal approach in millimeters and the artificial fraction as a decimal (not a percentage). Round both quantities to six decimal places.\n\nUse the following material and geometric parameters and loading:\n- $E_1 = 5 \\times 10^6$ $\\mathrm{Pa}$.\n- $\\nu_1 = 0.49$.\n- $R = 1.0 \\times 10^{-2}$ $\\mathrm{m}$.\n- $P = 1.0 \\times 10^{1}$ $\\mathrm{N}$.\n\nTest suite for $k_n$:\n- Case A (happy path, moderate penalty): $k_n = 1.0 \\times 10^{6}$ $\\mathrm{N/m}$.\n- Case B (edge, small penalty): $k_n = 1.0 \\times 10^{5}$ $\\mathrm{N/m}$.\n- Case C (coverage, stiffer penalty): $k_n = 1.0 \\times 10^{8}$ $\\mathrm{N/m}$.\n- Case D (boundary, near-constraint limit): $k_n = 1.0 \\times 10^{12}$ $\\mathrm{N/m}$.\n- Case E (coverage, intermediate high penalty): $k_n = 1.0 \\times 10^{9}$ $\\mathrm{N/m}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of sublists enclosed in square brackets with no spaces. Each sublist must contain two floats: $[\\delta_{\\mathrm{tot}}\\ \\text{in mm},\\ f_{\\mathrm{art}}]$, both rounded to six decimals. For example: $[[d_1,f_1],[d_2,f_2],[d_3,f_3]]$.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of contact mechanics (Hertz theory) and computational mechanics (penalty method in FEM). It is well-posed, with all necessary parameters, equations, and boundary conditions provided to derive a unique and stable solution. The problem statement is objective, complete, and devoid of contradictions or ambiguities.\n\nThe solution proceeds in two stages: first, the derivation of the governing equations, and second, the numerical computation for the specified test cases.\n\n**1. Derivation of Governing Equations**\n\nThe problem asks to quantify the total normal approach, $\\delta_{\\mathrm{tot}}$, which is modeled as the sum of the physical indentation, $\\delta_{\\mathrm{H}}$, and the artificial penalty-induced interpenetration, $\\delta_{\\mathrm{pen}}$.\n$$\n\\delta_{\\mathrm{tot}} = \\delta_{\\mathrm{H}} + \\delta_{\\mathrm{pen}}\n$$\nThis represents a model where the physical compliance of the material and the numerical compliance of the penalty constraint act in series under the prescribed load $P$.\n\nFirst, we derive the expression for the physical Hertzian indentation, $\\delta_{\\mathrm{H}}$. The Hertz contact theory for a sphere on a rigid flat provides the relationship:\n$$\nP = \\frac{4}{3} E^\\star R^{1/2} \\delta_{\\mathrm{H}}^{3/2}\n$$\nwhere $P$ is the normal load, $R$ is the sphere's radius, and $E^\\star$ is the effective modulus. Solving for $\\delta_{\\mathrm{H}}$ involves algebraic manipulation:\n$$\n\\delta_{\\mathrm{H}}^{3/2} = \\frac{3P}{4 E^\\star R^{1/2}}\n$$\nRaising both sides to the power of $2/3$ yields the formula for $\\delta_{\\mathrm{H}}$:\n$$\n\\delta_{\\mathrm{H}} = \\left(\\frac{3P}{4 E^\\star R^{1/2}}\\right)^{2/3}\n$$\nThe effective modulus, $E^\\star$, for contact between a deformable sphere (with Young's modulus $E_1$ and Poisson's ratio $\\nu_1$) and a rigid flat is given by:\n$$\n\\frac{1}{E^\\star} = \\frac{1 - \\nu_1^2}{E_1} \\implies E^\\star = \\frac{E_1}{1 - \\nu_1^2}\n$$\n\nNext, we derive the expression for the penalty-induced interpenetration, $\\delta_{\\mathrm{pen}}$. The penalty method in FEM introduces a linear constitutive relation between the contact force (which must equal the applied load $P$ at equilibrium) and the interpenetration $\\delta_{\\mathrm{pen}}$ via the normal penalty stiffness $k_n$:\n$$\nP = k_n \\delta_{\\mathrm{pen}}\n$$\nSolving for $\\delta_{\\mathrm{pen}}$ gives:\n$$\n\\delta_{\\mathrm{pen}} = \\frac{P}{k_n}\n$$\nThis term represents an artificial compliance, as it allows for a non-physical interpenetration that decreases as the penalty stiffness $k_n$ increases.\n\nFinally, the artificial fraction, $f_{\\mathrm{art}}$, is defined as the ratio of the penalty interpenetration to the total approach:\n$$\nf_{\\mathrm{art}} = \\frac{\\delta_{\\mathrm{pen}}}{\\delta_{\\mathrm{tot}}} = \\frac{\\delta_{\\mathrm{pen}}}{\\delta_{\\mathrm{H}} + \\delta_{\\mathrm{pen}}}\n$$\n\n**2. Numerical Computation for Test Cases**\n\nWe are given the following parameters:\n- Young's Modulus: $E_1 = 5 \\times 10^6$ $\\mathrm{Pa}$\n- Poisson's Ratio: $\\nu_1 = 0.49$\n- Indenter Radius: $R = 1.0 \\times 10^{-2}$ $\\mathrm{m}$\n- Normal Load: $P = 1.0 \\times 10^{1}$ $\\mathrm{N}$\n\nFirst, we compute the constant values $E^\\star$ and $\\delta_{\\mathrm{H}}$.\nThe effective modulus $E^\\star$ is:\n$$\nE^\\star = \\frac{E_1}{1 - \\nu_1^2} = \\frac{5 \\times 10^6}{1 - (0.49)^2} = \\frac{5 \\times 10^6}{1 - 0.2401} = \\frac{5 \\times 10^6}{0.7599} \\approx 6.579813 \\times 10^6 \\ \\mathrm{Pa}\n$$\nThe physical Hertzian indentation $\\delta_{\\mathrm{H}}$ is constant across all test cases:\n$$\n\\delta_{\\mathrm{H}} = \\left(\\frac{3 \\times 10}{4 \\times (6.579813 \\times 10^6) \\times (1.0 \\times 10^{-2})^{1/2}}\\right)^{2/3} = \\left(\\frac{30}{4 \\times (6.579813 \\times 10^6) \\times 0.1}\\right)^{2/3}\n$$\n$$\n\\delta_{\\mathrm{H}} = \\left(\\frac{30}{2.631925 \\times 10^6}\\right)^{2/3} \\approx (1.140003 \\times 10^{-5})^{2/3} \\approx 5.0853335 \\times 10^{-4} \\ \\mathrm{m}\n$$\nThis value of $\\delta_{\\mathrm{H}} \\approx 0.5085$ $\\mathrm{mm}$ is the purely physical indentation. Now we evaluate the results for each given penalty stiffness $k_n$.\n\n- **Case A:** $k_n = 1.0 \\times 10^{6}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^6} = 1.0 \\times 10^{-5}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-5}) = 5.1853335 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.518533$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-5}}{5.1853335 \\times 10^{-4}} \\approx 0.019285$\n\n- **Case B:** $k_n = 1.0 \\times 10^{5}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^5} = 1.0 \\times 10^{-4}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-4}) = 6.0853335 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.608533$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-4}}{6.0853335 \\times 10^{-4}} \\approx 0.164330$\n\n- **Case C:** $k_n = 1.0 \\times 10^{8}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^8} = 1.0 \\times 10^{-7}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-7}) = 5.0863335 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.508633$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-7}}{5.0863335 \\times 10^{-4}} \\approx 0.000197$\n\n- **Case D:** $k_n = 1.0 \\times 10^{12}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^{12}} = 1.0 \\times 10^{-11}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-11}) = 5.0853336 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.508533$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-11}}{5.0853336 \\times 10^{-4}} \\approx 1.966 \\times 10^{-8} \\approx 0.000000$\n\n- **Case E:** $k_n = 1.0 \\times 10^{9}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^9} = 1.0 \\times 10^{-8}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-8}) = 5.0854335 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.508543$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-8}}{5.0854335 \\times 10^{-4}} \\approx 1.96639 \\times 10^{-5} \\approx 0.000020$\n\nThe results show a clear trend: as the penalty stiffness $k_n$ increases, the penalty-induced interpenetration $\\delta_{\\mathrm{pen}}$ decreases, and the total approach $\\delta_{\\mathrm{tot}}$ converges to the purely physical Hertzian indentation $\\delta_{\\mathrm{H}}$. Consequently, the artificial fraction of the compliance $f_{\\mathrm{art}}$ approaches zero, indicating a more accurate enforcement of the contact constraint. Conversely, a low penalty stiffness (Case B) results in significant artificial compliance, where over $16\\%$ of the total displacement is non-physical interpenetration.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total normal approach and artificial compliance fraction\n    for a spherical indenter on a rigid flat using a penalty contact model.\n    \"\"\"\n\n    # Define material, geometric, and loading parameters from the problem statement.\n    # All units are SI (meters, Pascals, Newtons).\n    E1 = 5.0e6  # Young's modulus of the sphere in Pa\n    nu1 = 0.49  # Poisson's ratio of the sphere\n    R = 1.0e-2  # Radius of the sphere in m\n    P = 1.0e1   # Prescribed normal load in N\n\n    # Define the test suite of penalty stiffnesses (k_n in N/m).\n    # The order is Case A, B, C, D, E as specified.\n    test_cases_kn = [\n        1.0e6,   # Case A\n        1.0e5,   # Case B\n        1.0e8,   # Case C\n        1.0e12,  # Case D\n        1.0e9    # Case E\n    ]\n\n    # --- Calculations ---\n\n    # 1. Calculate the effective modulus (E*)\n    # For a deformable sphere on a rigid flat: 1/E* = (1 - nu1^2) / E1\n    E_star = E1 / (1 - nu1**2)\n\n    # 2. Calculate the purely physical Hertzian indentation (delta_H)\n    # This value is constant for all test cases.\n    # P = (4/3) * E* * R^(1/2) * delta_H^(3/2)\n    # => delta_H = ( (3*P) / (4 * E_star * R**0.5) )**(2/3)\n    delta_H = ((3 * P) / (4 * E_star * R**0.5))**(2/3)\n\n    results = []\n    # 3. Loop through each test case for k_n\n    for kn in test_cases_kn:\n        # a. Calculate penalty-induced interpenetration (delta_pen)\n        # P = kn * delta_pen => delta_pen = P / kn\n        delta_pen = P / kn\n\n        # b. Calculate total normal approach (delta_tot)\n        # delta_tot = delta_H + delta_pen\n        delta_tot = delta_H + delta_pen\n\n        # c. Calculate the artificial fraction (f_art)\n        # f_art = delta_pen / delta_tot\n        f_art = delta_pen / delta_tot\n\n        # d. Convert total approach to millimeters for output\n        delta_tot_mm = delta_tot * 1000\n\n        # e. Store the rounded results as a pair\n        # The problem requires rounding to six decimal places.\n        # String formatting is used for reliable rounding for display.\n        results.append((delta_tot_mm, f_art))\n\n    # --- Final Output Formatting ---\n\n    # Format each result pair as a sublist string \"[val1,val2]\"\n    # using format specifiers to ensure 6 decimal places.\n    sublist_strs = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    \n    # Join the sublist strings with commas and enclose in brackets.\n    # Example format: [[d1,f1],[d2,f2],[d3,f3]]\n    final_output = f\"[{','.join(sublist_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "While the penalty method is simple, its inherent approximation error can be problematic for high-accuracy simulations. The Augmented Lagrangian (AL) method is a more sophisticated alternative that combines the penalty concept with Lagrange multipliers to enforce the contact constraint more precisely, often with better numerical conditioning. This exercise provides a direct, quantitative comparison between the penalty and AL methods for a simple soft tissue indentation problem . By implementing both and comparing the resulting contact pressure accuracy and system matrix conditioning, you will understand the practical benefits of the AL method and the reasons for its widespread use in modern FEA solvers.",
            "id": "4167159",
            "problem": "A rigid, frictionless, flat indenter imposes a normal displacement on the top surface of a one-dimensional, linearly elastic, compressible soft tissue layer modeled as a bar of length $L$ and cross-sectional area $A$. The bar is fixed at its bottom surface ($x=0$) and is discretized by the Finite Element Method (FEM) using $N$ equal-length linear elements under small-strain kinematics. The material has Young’s modulus $E$. The indenter imposes a downward displacement $u_0$ at the top node ($x=L$). The normal contact is frictionless, so only the normal gap constraint is active. You will compare two contact enforcement strategies: the penalty method and the Augmented Lagrangian (AL) method, and evaluate their matrix conditioning and accuracy in estimating contact pressure.\n\nFundamental base: Use linear momentum balance without inertia (static equilibrium), small-strain linear elasticity $\\sigma = E \\varepsilon$ with $\\varepsilon = du/dx$, and frictionless unilateral contact in the fully sticking regime (no tangential traction and full contact across the top surface). For the benchmark reference pressure, consider the one-dimensional exact solution for a bar of length $L$ with bottom fixed and top displacement imposed as $u(L)=u_0$, which yields a uniform axial stress $\\sigma_{\\mathrm{ref}} = E\\,u_0/L$ and a contact pressure $p_{\\mathrm{ref}} = \\sigma_{\\mathrm{ref}}$. All physical quantities must be consistently treated with units: Young’s modulus in pascals (Pa), length in meters (m), displacement in meters (m), cross-sectional area in square meters ($\\mathrm{m}^2$), stiffness in newtons per meter (N/m), and pressure in pascals (Pa).\n\nDiscretization: Assemble the global stiffness matrix $K \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ for the bar with $N$ equal-length linear elements of size $h=L/N$. Impose the fixed boundary condition at the bottom node ($x=0$) by eliminating the corresponding degree of freedom, leaving a reduced system for the $N$ free nodal displacements.\n\nPenalty formulation: Enforce the top-node displacement constraint approximately by minimizing the augmented energy with a penalty stiffness $k_p$ applied to the scalar constraint $c(u)=u(L)-u_0$. This yields a modified linear system for the free degrees of freedom,\n$$\n\\left(K + k_p\\,b\\,b^\\top\\right) u = k_p\\,u_0\\,b,\n$$\nwhere $b\\in\\mathbb{R}^{N}$ selects the top node among the free degrees of freedom. Compute the condition number of the matrix $K + k_p\\,b\\,b^\\top$ in the matrix $2$-norm and the resulting contact pressure at the top surface by evaluating the axial stress in the last element,\n$$\np_{\\mathrm{pen}} = \\sigma_{\\mathrm{last}} = E\\,\\frac{u_N - u_{N-1}}{h},\n$$\nwhere $u_N$ and $u_{N-1}$ are the global displacements of the last two nodes. Report the absolute error $|p_{\\mathrm{pen}} - p_{\\mathrm{ref}}|$ in pascals (Pa).\n\nAugmented Lagrangian formulation: Enforce the same scalar constraint $c(u)=u(L)-u_0=0$ exactly via an augmented Lagrangian with parameter $\\rho>0$ and a Lagrange multiplier $\\lambda$ (units of force, newton). The first-order optimality conditions for the reduced free displacement vector $u$ and $\\lambda$ lead to the symmetric saddle-point linear system\n$$\n\\begin{bmatrix}\nK + \\rho\\,b\\,b^\\top & b \\\\\nb^\\top & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\rho\\,u_0\\,b \\\\ u_0\n\\end{bmatrix}.\n$$\nCompute the condition number of the $(N+1)\\times(N+1)$ block matrix in the matrix $2$-norm. The physical contact pressure equals the Lagrange multiplier divided by the area, $p_{\\mathrm{AL}} = \\lambda/A$. Report the absolute error $|p_{\\mathrm{AL}} - p_{\\mathrm{ref}}|$ in pascals (Pa).\n\nBenchmark reference: Use $p_{\\mathrm{ref}} = E\\,u_0/L$ as the reference contact pressure in pascals (Pa).\n\nYour program must implement the assembly and solves for both methods for the following test suite of parameter sets. Each test case is a tuple of $(E,A,L,u_0,N,k_p,\\rho)$ with all quantities in the units specified above:\n\n- Case 1 (happy path): $(E,A,L,u_0,N,k_p,\\rho) = (12000,\\, 4\\times 10^{-4},\\, 0.02,\\, 0.002,\\, 20,\\, 240,\\, 240)$.\n- Case 2 (under-penalized boundary case): $(E,A,L,u_0,N,k_p,\\rho) = (12000,\\, 4\\times 10^{-4},\\, 0.02,\\, 0.002,\\, 10,\\, 0.24,\\, 240)$.\n- Case 3 (over-penalized edge case): $(E,A,L,u_0,N,k_p,\\rho) = (12000,\\, 4\\times 10^{-4},\\, 0.02,\\, 0.002,\\, 50,\\, 2.4\\times 10^{6},\\, 2.4\\times 10^{6})$.\n\nFor each test case, compute:\n- The penalty-system matrix condition number $\\kappa_{\\mathrm{pen}}$ (matrix $2$-norm).\n- The augmented Lagrangian saddle-point matrix condition number $\\kappa_{\\mathrm{AL}}$ (matrix $2$-norm).\n- The absolute contact pressure error for the penalty method $|p_{\\mathrm{pen}} - p_{\\mathrm{ref}}|$ in pascals (Pa) as a float.\n- The absolute contact pressure error for the augmented Lagrangian method $|p_{\\mathrm{AL}} - p_{\\mathrm{ref}}|$ in pascals (Pa) as a float.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of the form $[\\kappa_{\\mathrm{pen}},\\,\\kappa_{\\mathrm{AL}},\\,|p_{\\mathrm{pen}} - p_{\\mathrm{ref}}|,\\,|p_{\\mathrm{AL}} - p_{\\mathrm{ref}}|]$. For the three cases above, the final output must be a single list of three lists, for example, $[[\\dots],[\\dots],[\\dots]]$. All reported pressure errors must be in pascals (Pa).",
            "solution": "The problem statement has been meticulously validated and is determined to be scientifically sound, well-posed, and complete. It presents a standard problem in computational contact mechanics, suitable for analysis via the Finite Element Method.\n\nHerein, a complete solution is provided, beginning with a derivation from fundamental principles, followed by the formulation of the specified numerical methods, and culminating in an algorithmic procedure to compute the required quantities.\n\n**1. Analytical Foundation and Reference Solution**\n\nThe physical system is a one-dimensional, linearly elastic bar of length $L$, Young's modulus $E$, and cross-sectional area $A$. The governing equation for axial displacement $u(x)$ under static equilibrium (no body forces) is derived from the balance of linear momentum, which reduces to $\\frac{d\\sigma}{dx} = 0$, where $\\sigma$ is the axial stress. Using the small-strain linear elastic constitutive law, $\\sigma = E\\varepsilon$, and the strain-displacement relation, $\\varepsilon = \\frac{du}{dx}$, the governing differential equation becomes:\n$$\n\\frac{d}{dx} \\left( E \\frac{du}{dx} \\right) = 0\n$$\nAssuming a homogeneous material ($E$ is constant), this simplifies to $\\frac{d^2u}{dx^2} = 0$.\n\nThe boundary conditions are:\n1.  Fixed base: $u(0) = 0$.\n2.  Imposed displacement at the top by a rigid indenter: $u(L) = u_0$. Note that $u_0$ is a downward displacement, but for a 1D bar, we can define the coordinate system such that a positive displacement corresponds to this direction.\n\nThe general solution to $u''(x) = 0$ is $u(x) = C_1 x + C_2$. Applying the boundary conditions:\n- $u(0) = 0 \\implies C_1(0) + C_2 = 0 \\implies C_2 = 0$.\n- $u(L) = u_0 \\implies C_1 L = u_0 \\implies C_1 = u_0/L$.\n\nThe exact displacement field is thus $u(x) = \\frac{u_0}{L}x$. This corresponds to a uniform axial strain $\\varepsilon = \\frac{du}{dx} = \\frac{u_0}{L}$ and a uniform axial stress $\\sigma = E\\varepsilon = E\\frac{u_0}{L}$. The contact pressure exerted by the indenter is equal to this axial stress. Therefore, the reference pressure is:\n$$\np_{\\mathrm{ref}} = \\frac{E u_0}{L}\n$$\n\n**2. Finite Element Discretization**\n\nThe bar is discretized into $N$ equal-length linear finite elements, each of length $h = L/N$. There are $N+1$ nodes, numbered $0, 1, \\dots, N$, corresponding to positions $x_i = i \\cdot h$.\n\nFor a single 1D bar element of length $h$ connecting two nodes, the element stiffness matrix $k_e$ relates nodal forces to nodal displacements:\n$$\nk_e = \\frac{EA}{h}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix}\n$$\nThese element matrices are assembled into a global stiffness matrix $K_{\\mathrm{global}}$ of size $(N+1) \\times (N+1)$. The fixed boundary condition $u_0 = 0$ is imposed by eliminating the first row and column of $K_{\\mathrm{global}}$, resulting in a reduced stiffness matrix $K \\in \\mathbb{R}^{N\\times N}$ for the free degrees of freedom $u = [u_1, u_2, \\dots, u_N]^\\top$. This reduced matrix $K$ has the following structure:\n$$\nK = \\frac{EA}{h}\n\\begin{bmatrix}\n2 & -1 & 0 & \\dots & 0 \\\\\n-1 & 2 & -1 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & \\vdots \\\\\n\\vdots & \\dots & -1 & 2 & -1 \\\\\n0 & \\dots & 0 & -1 & 1\n\\end{bmatrix}\n$$\n\n**3. Contact Enforcement: Penalty Method**\n\nThe penalty method approximates the displacement constraint $u(L) - u_0 = 0$, which in discrete form is $u_N - u_0 = 0$, by adding a large stiffness (the penalty parameter $k_p$) to the system's potential energy. This is equivalent to adding a spring of stiffness $k_p$ between the final node and the target position. This modifies the linear system for the free displacements $u \\in \\mathbb{R}^N$ to:\n$$\n\\left(K + k_p\\,b\\,b^\\top\\right) u = k_p\\,u_0\\,b\n$$\nHere, $b = [0, \\dots, 0, 1]^\\top \\in \\mathbb{R}^N$ is a selector vector that isolates the last free degree of freedom, $u_N$. The matrix on the left, $K_{\\mathrm{pen}} = K + k_p\\,b\\,b^\\top$, has its condition number $\\kappa_{\\mathrm{pen}}$ evaluated using the matrix 2-norm. After solving for the displacement vector $u$, the contact pressure is estimated from the stress in the last element (connecting nodes $N-1$ and $N$):\n$$\np_{\\mathrm{pen}} = \\sigma_{\\mathrm{last}} = E \\frac{u_N - u_{N-1}}{h}\n$$\nwhere $u_N$ and $u_{N-1}$ are the displacements of the corresponding nodes obtained from the solution vector $u$.\n\n**4. Contact Enforcement: Augmented Lagrangian Method**\n\nThe Augmented Lagrangian (AL) method enforces the constraint $c(u) = u_N - u_0 = 0$ exactly by introducing a Lagrange multiplier $\\lambda$ (representing the contact force). The formulation is augmented with a quadratic penalty term to improve the conditioning of the resulting system. The first-order necessary conditions for the AL functional yield a symmetric indefinite (saddle-point) system for the extended unknown vector $[u^\\top, \\lambda]^\\top$:\n$$\n\\begin{bmatrix}\nK + \\rho\\,b\\,b^\\top & b \\\\\nb^\\top & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\rho\\,u_0\\,b \\\\ u_0\n\\end{bmatrix}\n$$\nwhere $\\rho > 0$ is the augmentation parameter. The $(N+1)\\times(N+1)$ block matrix on the left, let's call it $K_{\\mathrm{AL}}$, has its condition number $\\kappa_{\\mathrm{AL}}$ evaluated. Upon solving this system, the Lagrange multiplier $\\lambda$ is obtained directly. The contact pressure is then the contact force $\\lambda$ divided by the area $A$:\n$$\np_{\\mathrm{AL}} = \\frac{\\lambda}{A}\n$$\nTheoretically, this method should yield the exact pressure up to machine precision, as it can exactly represent the linear displacement field of the analytical solution.\n\n**5. Evaluation Metrics**\n\nFor both methods, we calculate the conditioning and accuracy.\n- **Condition Number**: The matrix 2-norm condition number, $\\kappa(\\mathbf{M}) = ||\\mathbf{M}||_2 ||\\mathbf{M}^{-1}||_2$, is computed for $K_{\\mathrm{pen}}$ and $K_{\\mathrm{AL}}$. A large condition number indicates that the matrix is close to singular and the solution may be sensitive to small perturbations in the input.\n- **Accuracy**: The absolute error between the computed pressure ($p_{\\mathrm{pen}}$ or $p_{\\mathrm{AL}}$) and the analytical reference pressure $p_{\\mathrm{ref}}$ is calculated, e.g., $|p_{\\mathrm{pen}} - p_{\\mathrm{ref}}|$.\n\nThe following code implements this procedure for the specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef assemble_reduced_stiffness_matrix(E, A, h, N):\n    \"\"\"\n    Assembles the reduced NxN stiffness matrix K for the N free degrees of freedom\n    (nodes 1 to N), after eliminating the DOF for the fixed node 0.\n    \"\"\"\n    if N == 0:\n        return np.array([])\n        \n    K = np.zeros((N, N))\n    k_elem_scalar = E * A / h\n\n    # Populate the diagonal. All free nodes except the last one are connected to two elements.\n    # The last free node (node N) is connected to only one element.\n    diagonal_vals = np.full(N, 2.0 * k_elem_scalar)\n    diagonal_vals[-1] = 1.0 * k_elem_scalar\n    np.fill_diagonal(K, diagonal_vals)\n\n    # Populate the off-diagonals\n    if N > 1:\n        off_diag_vals = np.full(N - 1, -1.0 * k_elem_scalar)\n        np.fill_diagonal(K[1:], off_diag_vals)\n        np.fill_diagonal(K[:, 1:], off_diag_vals)\n    \n    return K\n\ndef solve_penalty_method(K, E, h, N, u_0, k_p, p_ref):\n    \"\"\"\n    Solves the contact problem using the penalty method and computes metrics.\n    \"\"\"\n    b = np.zeros(N)\n    if N > 0:\n        b[-1] = 1.0\n\n    K_pen = K + k_p * np.outer(b, b)\n    rhs_pen = k_p * u_0 * b\n    \n    u_free = np.linalg.solve(K_pen, rhs_pen)\n    \n    kappa_pen = np.linalg.cond(K_pen, 2)\n    \n    # Get displacements for the last two nodes (N and N-1) to compute stress\n    u_N = u_free[N - 1] if N > 0 else 0.0\n    u_N_minus_1 = u_free[N - 2] if N > 1 else 0.0 # u_0 = 0\n    \n    p_pen = E * (u_N - u_N_minus_1) / h\n    \n    error_pen = np.abs(p_pen - p_ref)\n    \n    return kappa_pen, error_pen\n\ndef solve_augmented_lagrangian(K, A, N, u_0, rho, p_ref):\n    \"\"\"\n    Solves the contact problem using the Augmented Lagrangian method and computes metrics.\n    \"\"\"\n    N_aug = N + 1\n    K_al = np.zeros((N_aug, N_aug))\n    b = np.zeros(N)\n    if N > 0:\n        b[-1] = 1.0\n\n    # Build the (N+1)x(N+1) saddle-point matrix K_al\n    K_al[:N, :N] = K + rho * np.outer(b, b)\n    K_al[:N, N] = b\n    K_al[N, :N] = b.T\n    # K_al[N, N] is already 0.0\n\n    # Build the (N+1)x1 right-hand side vector\n    rhs_al = np.zeros(N_aug)\n    rhs_al[:N] = rho * u_0 * b\n    rhs_al[N] = u_0\n\n    solution = np.linalg.solve(K_al, rhs_al)\n    \n    kappa_al = np.linalg.cond(K_al, 2)\n    \n    # The Lagrange multiplier is the last component of the solution vector\n    lambda_val = solution[-1]\n    p_al = lambda_val / A\n    \n    error_al = np.abs(p_al - p_ref)\n\n    return kappa_al, error_al\n\ndef solve():\n    \"\"\"\n    Main driver function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (E, A, L, u_0, N, k_p, rho)\n        (12000.0, 4e-4, 0.02, 0.002, 20, 240.0, 240.0),\n        (12000.0, 4e-4, 0.02, 0.002, 10, 0.24, 240.0),\n        (12000.0, 4e-4, 0.02, 0.002, 50, 2.4e6, 2.4e6),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        E, A, L, u_0, N, k_p, rho = case\n\n        p_ref = E * u_0 / L\n        h = L / N\n        \n        K = assemble_reduced_stiffness_matrix(E, A, h, N)\n        \n        kappa_pen, error_pen = solve_penalty_method(K, E, h, N, u_0, k_p, p_ref)\n        kappa_al, error_al = solve_augmented_lagrangian(K, A, N, u_0, rho, p_ref)\n        \n        all_results.append([kappa_pen, kappa_al, error_pen, error_al])\n\n    # Format the output string precisely as required: [[...],[...],[...]]\n    results_str_list = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}