{
    "hands_on_practices": [
        {
            "introduction": "接触算法的第一步也是最基本的一步是“接触搜索”，即在几何上确定哪些部分可能接触。在计算任何接触力之前，仿真程序必须精确地确定表面之间的距离（即间隙）。本练习  将引导你亲手开发一个几何算法，用于寻找三角主面片上距离从动点最近的点，这是许多“点-面”接触算法的基石。",
            "id": "4167128",
            "problem": "在有限元接触设置中，一个三角形主面由当前构型中的三个顶点 $x_1, x_2, x_3 \\in \\mathbb{R}^3$ 定义，单位为米。一个从点 $x_s \\in \\mathbb{R}^3$（单位为米）接近该主面。在有限元法（FEM）的背景下，线性三角形主面使用局部坐标 $(\\xi,\\eta)$ 和形函数 $N_1 = 1 - \\xi - \\eta$, $N_2 = \\xi$, $N_3 = \\eta$，因此主面上的任何点都可以插值为 $x_m(\\xi,\\eta) = N_1 x_1 + N_2 x_2 + N_3 x_3$，其中 $\\xi \\ge 0$, $\\eta \\ge 0$, 且 $\\xi + \\eta \\le 1$。主面的单位法向量 $\\hat{\\boldsymbol{n}}$ 由基于顶点顺序 $x_1 \\rightarrow x_2 \\rightarrow x_3$ 的右手定则定义。\n\n从欧几里得几何和有限元插值的第一性原理出发，构建一个算法，在给定 $x_1$、$x_2$、$x_3$ 和 $x_s$ 的情况下，找到主面上（包括其边界）距离 $x_s$ 最近的点 $x_m$。该算法必须：\n- 确定与线性三角形参数化一致的 $x_m$ 的 $(\\xi,\\eta)$。\n- 计算法向间隙 $g_n = \\hat{\\boldsymbol{n}} \\cdot (x_s - x_m)$，单位为米。\n- 计算切向间隙向量 $\\boldsymbol{g}_t = ( \\mathbf{I} - \\hat{\\boldsymbol{n}} \\hat{\\boldsymbol{n}}^\\top )(x_s - x_m)$，单位为米，其中 $\\mathbf{I}$ 是 $\\mathbb{R}^3$ 中的单位矩阵。\n\n从以下基础推导该算法：\n- $\\mathbb{R}^3$ 中的欧几里得内积、投影和距离。\n- 使用 $N_1$、$N_2$、$N_3$ 在三角形上进行线性插值。\n- 通过两条边的叉积定义单位法向量。\n\n不要使用任何跳过从这些基础推导的快捷公式。您的算法必须正确处理 $x_s$ 在主面平面上的正交投影位于三角形内部还是外部的情况，在后一种情况下，最近点位于其中一条边或一个顶点上。所有距离的单位必须是米。\n\n在一个程序中实现此算法，该程序处理以下测试用例（单位为米）。对于每个用例，都给定了 $x_1$、$x_2$、$x_3$ 和 $x_s$：\n\n- 用例 1（内部投影，斜向偏移）：\n  $x_1 = (0.000,\\,0.000,\\,0.000)$，\n  $x_2 = (0.030,\\,0.000,\\,0.000)$，\n  $x_3 = (0.000,\\,0.020,\\,0.000)$，\n  $x_s = (0.010,\\,0.005,\\,0.001)$。\n- 用例 2（最接近边 $x_1$–$x_2$）：\n  $x_1 = (0.000,\\,0.000,\\,0.000)$，\n  $x_2 = (0.030,\\,0.000,\\,0.000)$，\n  $x_3 = (0.000,\\,0.020,\\,0.000)$，\n  $x_s = (0.020,\\,-0.010,\\,0.002)$。\n- 用例 3（最接近顶点 $x_3$）：\n  $x_1 = (0.000,\\,0.000,\\,0.000)$，\n  $x_2 = (0.030,\\,0.000,\\,0.000)$，\n  $x_3 = (0.000,\\,0.020,\\,0.000)$，\n  $x_s = (-0.001,\\,0.021,\\,0.0005)$。\n- 用例 4（斜三角形，内部投影）：\n  $x_1 = (0.000,\\,0.000,\\,0.000)$，\n  $x_2 = (0.020,\\,0.000,\\,0.005)$，\n  $x_3 = (0.000,\\,0.030,\\,-0.004)$，\n  $x_s = (0.010,\\,0.015,\\,0.002)$。\n- 用例 5（平面内点）：\n  $x_1 = (0.000,\\,0.000,\\,0.000)$，\n  $x_2 = (0.030,\\,0.000,\\,0.000)$，\n  $x_3 = (0.000,\\,0.020,\\,0.000)$，\n  $x_s = (0.015,\\,0.005,\\,0.000)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果由列表 $[\\xi,\\eta,g_n,g_{t,x},g_{t,y},g_{t,z}]$ 表示，单位为米，且不含空格。例如，输出必须采用以下格式：\n$[[\\xi_1,\\eta_1,g_{n,1},g_{t,x,1},g_{t,y,1},g_{t,z,1}],[\\xi_2,\\eta_2,g_{n,2},g_{t,x,2},g_{t,y,2},g_{t,z,2}],\\dots]$。",
            "solution": "该问题要求开发一种算法，以找到三角形主面上距离给定从点 $x_s$ 最近的点 $x_m$。该算法必须从欧几里得几何和有限元插值的第一性原理推导得出。最终输出为最近点的局部坐标 $(\\xi, \\eta)$、法向间隙 $g_n$ 和切向间隙向量 $\\boldsymbol{g}_t$。\n\n问题的核心是在 $x_m$ 位于由顶点 $x_1, x_2, x_3 \\in \\mathbb{R}^3$ 定义的三角形主面上的约束条件下，最小化欧几里得距离的平方 $d^2 = \\|x_m - x_s\\|^2$。\n\n首先，我们建立主面的几何参数化。主面上的任何点 $x_m$ 都是其顶点使用重心形函数 $N_1=1-\\xi-\\eta$、$N_2=\\xi$ 和 $N_3=\\eta$ 的线性插值：\n$$x_m(\\xi, \\eta) = N_1 x_1 + N_2 x_2 + N_3 x_3 = (1-\\xi-\\eta)x_1 + \\xi x_2 + \\eta x_3$$\n如果局部坐标 $(\\xi, \\eta)$ 满足条件 $\\xi \\ge 0$、$\\eta \\ge 0$ 和 $\\xi+\\eta \\le 1$，则点 $x_m$ 位于三角形内部（包括其边界）。我们可以用从顶点 $x_1$ 出发的边向量重写插值公式。令 $e_1 = x_2 - x_1$ 和 $e_2 = x_3 - x_1$。公式变为：\n$$x_m(\\xi, \\eta) = x_1 + \\xi e_1 + \\eta e_2$$\n与从点 $x_s$ 的距离平方是 $(\\xi, \\eta)$ 的函数：\n$$f(\\xi, \\eta) = \\|x_m(\\xi, \\eta) - x_s\\|^2 = \\|x_1 + \\xi e_1 + \\eta e_2 - x_s\\|^2$$\n令从 $x_1$ 到 $x_s$ 的向量为 $v = x_s - x_1$。要最小化的函数是：\n$$f(\\xi, \\eta) = \\|\\xi e_1 + \\eta e_2 - v\\|^2 = (\\xi e_1 + \\eta e_2 - v) \\cdot (\\xi e_1 + \\eta e_2 - v)$$\n展开此内积得到一个关于 $\\xi$ 和 $\\eta$ 的二次函数：\n$$f(\\xi, \\eta) = \\xi^2 (e_1 \\cdot e_1) + \\eta^2 (e_2 \\cdot e_2) + 2\\xi\\eta (e_1 \\cdot e_2) - 2\\xi (e_1 \\cdot v) - 2\\eta (e_2 \\cdot v) + (v \\cdot v)$$\n为了找到包含三角形的无限平面上的最近点，我们对 $f(\\xi, \\eta)$ 进行无约束最小化，方法是将其梯度设为零：$\\nabla f = (\\frac{\\partial f}{\\partial \\xi}, \\frac{\\partial f}{\\partial \\eta}) = (0, 0)$。\n$$\\frac{\\partial f}{\\partial \\xi} = 2\\xi (e_1 \\cdot e_1) + 2\\eta (e_1 \\cdot e_2) - 2(e_1 \\cdot v) = 0$$\n$$\\frac{\\partial f}{\\partial \\eta} = 2\\eta (e_2 \\cdot e_2) + 2\\xi (e_1 \\cdot e_2) - 2(e_2 \\cdot v) = 0$$\n这就得到了一个关于最优 $(\\xi, \\eta)$ 的 $2 \\times 2$ 线性系统，我们记为 $(\\xi^*, \\eta^*)$：\n$$\n\\begin{pmatrix}\ne_1 \\cdot e_1 & e_1 \\cdot e_2 \\\\\ne_1 \\cdot e_2 & e_2 \\cdot e_2\n\\end{pmatrix}\n\\begin{pmatrix}\n\\xi^* \\\\\n\\eta^*\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ne_1 \\cdot v \\\\\ne_2 \\cdot v\n\\end{pmatrix}\n$$\n令 $a = e_1 \\cdot e_1$、$b = e_1 \\cdot e_2$、$c = e_2 \\cdot e_2$、$d = e_1 \\cdot v$ 和 $e = e_2 \\cdot v$。该系统为 $A \\begin{pmatrix}\\xi^* \\\\ \\eta^*\\end{pmatrix} = \\begin{pmatrix}d \\\\ e\\end{pmatrix}$，其中 $A=\\begin{pmatrix} a & b \\\\ b & c \\end{pmatrix}$。解为：\n$$ \\xi^* = \\frac{cd - be}{ac - b^2}, \\quad \\eta^* = \\frac{ae - bd}{ac - b^2} $$\n点 $x_m(\\xi^*, \\eta^*)$ 是 $x_s$ 在三角形平面上的正交投影。\n\n如果此无约束解 $(\\xi^*, \\eta^*)$ 满足条件 $\\xi^* \\ge 0$、$\\eta^* \\ge 0$ 和 $\\xi^*+\\eta^* \\le 1$，则投影位于三角形内部，我们就找到了最近点。然而，如果这些条件中的任何一个被违反，主面上的最近点必须位于其边界上（其三条边或三个顶点之一）。问题就变成了一个约束优化问题。\n\n我们可以通过检查哪个边界区域最接近无约束解 $(\\xi^*, \\eta^*)$ 来系统地找到约束最小值。这等同于将 $x_s$ 投影到包含边的直线上，并将结果限制在边段上，这由 $(\\xi^*, \\eta^*)$ 违反了哪个有效性条件来确定。算法如下：\n\n令 $(\\xi, \\eta)$ 表示最终的、被限制的坐标。\n1.  如果 $\\xi^* < 0$：最近点位于对应于 $\\xi = 0$ 的线段上，即边 $x_1-x_3$。我们在此线段上找到距离 $x_s$ 最近的点。沿直线 $x_1 \\to x_3$ 最小化距离的参数是 $t = \\frac{(x_s-x_1)\\cdot(x_3-x_1)}{\\|x_3-x_1\\|^2} = \\frac{e_2 \\cdot v}{e_2 \\cdot e_2} = \\frac{e}{c}$。我们将此参数限制在有效范围 $[0, 1]$ 内。最终坐标是 $(\\xi, \\eta) = (0, \\text{clamp}(t, 0, 1))$。\n\n2.  否则如果 $\\eta^* < 0$：最近点位于边 $x_1-x_2$ 上（$\\eta=0$）。沿直线 $x_1 \\to x_2$ 的参数是 $t = \\frac{(x_s-x_1)\\cdot(x_2-x_1)}{\\|x_2-x_1\\|^2} = \\frac{e_1 \\cdot v}{e_1 \\cdot e_1} = \\frac{d}{a}$。限制在 $[0, 1]$ 内得到最终坐标 $(\\xi, \\eta) = (\\text{clamp}(t, 0, 1), 0)$。\n\n3.  否则如果 $\\xi^*+\\eta^* > 1$：最近点位于边 $x_2-x_3$ 上（$\\xi+\\eta=1$）。我们在直线段 $x_2-x_3$ 上找到距离 $x_s$ 最近的点。沿直线 $x_2 \\to x_3$ 的参数是 $t = \\frac{(x_s-x_2)\\cdot(x_3-x_2)}{\\|x_3-x_2\\|^2}$。限制在 $[0, 1]$ 内得到 $t_{clamped}$。我们将其转换回 $(\\xi, \\eta)$ 坐标系。此边上的一个点是 $x_m = (1-t)x_2 + t x_3$。在我们的重心坐标系中，这对应于 $N_1=0, N_2 = \\xi = 1-t, N_3 = \\eta = t$。所以，最终坐标是 $(\\xi, \\eta) = (1-t_{clamped}, t_{clamped})$。\n\n4.  否则：无约束解 $(\\xi^*, \\eta^*)$ 位于有效域内。最终坐标是 $(\\xi, \\eta) = (\\xi^*, \\eta^*)$。\n\n一旦确定了最终坐标 $(\\xi, \\eta)$，主面上的最近点就计算为 $x_m = x_1 + \\xi e_1 + \\eta e_2$。\n\n最后，我们计算间隙量。面法向量由边向量的叉积定义，$\\boldsymbol{n} = e_1 \\times e_2$，基于顶点顺序 $x_1 \\rightarrow x_2 \\rightarrow x_3$ 的右手定则。单位法向量是 $\\hat{\\boldsymbol{n}} = \\boldsymbol{n} / \\|\\boldsymbol{n}\\|$。从最近点到从点的间隙向量是 $\\boldsymbol{g} = x_s - x_m$。\n\n法向间隙 $g_n$ 是 $\\boldsymbol{g}$ 在单位法向量上的投影：\n$$g_n = \\hat{\\boldsymbol{n}} \\cdot \\boldsymbol{g} = \\hat{\\boldsymbol{n}} \\cdot (x_s - x_m)$$\n切向间隙向量 $\\boldsymbol{g}_t$ 是 $\\boldsymbol{g}$ 与法线正交的分量，可以通过从总间隙向量中减去法向分量来找到：\n$$\\boldsymbol{g}_t = \\boldsymbol{g} - g_n \\hat{\\boldsymbol{n}} = (\\mathbf{I} - \\hat{\\boldsymbol{n}} \\hat{\\boldsymbol{n}}^\\top)(x_s - x_m)$$\n其中 $\\mathbf{I}$ 是 $3 \\times 3$ 的单位矩阵。这完成了所需算法从第一性原理的推导。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_closest_point_on_triangle(x1, x2, x3, xs):\n    \"\"\"\n    Finds the closest point on a triangular facet to a slave point.\n\n    The algorithm is derived from first principles:\n    1. Parameterize the triangle using local coordinates (xi, eta).\n    2. Formulate the squared distance from the slave point to a point on the\n       triangle as a quadratic function of (xi, eta).\n    3. Solve for the unconstrained minimum by setting the gradient to zero,\n       which gives the projection of the slave point onto the infinite plane\n       of the triangle.\n    4. If the projected point is outside the triangle's boundaries (xi  0,\n       eta  0, or xi + eta > 1), clamp the solution to the valid region\n       by projecting onto the corresponding edge or vertex.\n    5. With the final (xi, eta), calculate the closest point xm, the normal\n       gap gn, and the tangential gap vector gt.\n    \"\"\"\n    x1 = np.array(x1, dtype=float)\n    x2 = np.array(x2, dtype=float)\n    x3 = np.array(x3, dtype=float)\n    xs = np.array(xs, dtype=float)\n\n    # 1.  2. Define geometry and formulate minimization problem\n    e1 = x2 - x1\n    e2 = x3 - x1\n    v = xs - x1\n\n    a = np.dot(e1, e1)\n    b = np.dot(e1, e2)\n    c = np.dot(e2, e2)\n    d = np.dot(e1, v)\n    e = np.dot(e2, v)\n    \n    det = a * c - b * b\n\n    # Handle degenerate triangle case (though not expected from problem statement)\n    if np.abs(det)  1e-15:\n        # Simplified handling for degenerate case: project onto the longest edge.\n        # This is a fallback and not part of the primary algorithm requested.\n        # For simplicity in this problem, we assume non-degenerate triangles.\n        # For a robust industrial code, this part would be more complex.\n        # We can just let the division by zero happen and debug if needed,\n        # but the problem data should be well-behaved.\n        pass\n\n    # 3. Unconstrained minimization: projection onto the plane\n    xi_star = (c * d - b * e) / det\n    eta_star = (a * e - b * d) / det\n\n    # 4. Constrained minimization: clamp to the triangular region [0,1]x[0,1] s.t. xi+eta=1\n    if xi_star  0:\n        # Closest point is on edge x1-x3 or one of its vertices\n        t = e / c if c > 1e-15 else 0.0\n        xi_final = 0.0\n        eta_final = np.clip(t, 0.0, 1.0)\n    elif eta_star  0:\n        # Closest point is on edge x1-x2 or one of its vertices\n        t = d / a if a > 1e-15 else 0.0\n        xi_final = np.clip(t, 0.0, 1.0)\n        eta_final = 0.0\n    elif xi_star + eta_star > 1:\n        # Closest point is on edge x2-x3 or one of its vertices\n        e32 = x3 - x2\n        vs2 = xs - x2\n        t = np.dot(vs2, e32) / np.dot(e32, e32) if np.dot(e32, e32) > 1e-15 else 0.0\n        t_clamped = np.clip(t, 0.0, 1.0)\n        xi_final = 1.0 - t_clamped\n        eta_final = t_clamped\n    else:\n        # The projection is inside the triangle\n        xi_final = xi_star\n        eta_final = eta_star\n\n    # 5. Compute the final quantities\n    xm = x1 + xi_final * e1 + eta_final * e2\n\n    # Normal vector by right-hand rule on (x1, x2, x3)\n    n = np.cross(e1, e2)\n    norm_n = np.linalg.norm(n)\n    if norm_n > 1e-15:\n        n_hat = n / norm_n\n    else: # Fallback for degenerate triangles\n        n_hat = np.array([0., 0., 1.])\n\n    g = xs - xm\n    gn = np.dot(n_hat, g)\n    gt = g - gn * n_hat\n\n    return [xi_final, eta_final, gn, gt[0], gt[1], gt[2]]\n\ndef solve():\n    \"\"\"\n    Main function to process the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.030, 0.000, 0.000), 'x3': (0.000, 0.020, 0.000), 'xs': (0.010, 0.005, 0.001)},\n        # Case 2\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.030, 0.000, 0.000), 'x3': (0.000, 0.020, 0.000), 'xs': (0.020, -0.010, 0.002)},\n        # Case 3\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.030, 0.000, 0.000), 'x3': (0.000, 0.020, 0.000), 'xs': (-0.001, 0.021, 0.0005)},\n        # Case 4\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.020, 0.000, 0.005), 'x3': (0.000, 0.030, -0.004), 'xs': (0.010, 0.015, 0.002)},\n        # Case 5\n        {'x1': (0.000, 0.000, 0.000), 'x2': (0.030, 0.000, 0.000), 'x3': (0.000, 0.020, 0.000), 'xs': (0.015, 0.005, 0.000)},\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        result_list = find_closest_point_on_triangle(case['x1'], case['x2'], case['x3'], case['xs'])\n        # Format the list of numbers into a string \"[f1,f2,...]\" without spaces\n        inner_string = f\"[{','.join(map(str, result_list))}]\"\n        results_as_strings.append(inner_string)\n\n    # Format the list of strings into the final output format \"[[...],[...]]\"\n    final_output_string = f\"[{','.join(results_as_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "确定间隙后，下一步是施加不可穿透约束。罚函数法是一种直观且广泛使用的技术，它相当于在接触界面上放置一个高刚度的弹簧。本练习  将通过量化“伪柔度”（该方法固有的一种误差），来探索罚函数法的核心权衡，并展示罚参数的选择如何影响求解精度。",
            "id": "4167061",
            "problem": "考虑一个生物力学中的轴对称法向接触基准问题：一个半径为 $R$ 的线性弹性球形压头在规定的法向载荷 $P$ 下压向一个刚性平面。球体的杨氏模量为 $E_1$，泊松比为 $\\nu_1$。在有限元法 (FEM) 接触仿真中，法向接触约束可以使用罚函数法来施加，其中法向罚刚度 $k_n$ 将负间隙与接触力关联起来。这种施加方式会引入人为的柔度，因为当接触力有限时，允许非零的相互穿透。您的任务是通过计算不同 $k_n$ 值下的法向趋近量来量化这种人为柔度。\n\n基本原理：\n- 根据法向力的平衡（源于静态问题的牛顿定律），接触力等于规定的载荷 $P$。\n- 球体与刚性平面接触的赫兹接触理论指出，纯物理压痕（法向趋近量）$\\delta_{\\mathrm{H}}$ 满足经过充分检验的公式 $P = \\frac{4}{3} E^\\star R^{1/2} \\delta_{\\mathrm{H}}^{3/2}$，其中 $E^\\star$ 是有效模量，对于可变形球体与刚性平面接触的情况，其定义为 $\\frac{1}{E^\\star} = \\frac{1 - \\nu_1^2}{E_1}$。\n- 有限元法中的罚函数法在接触力 $P$ 和相互穿透量 $\\delta_{\\mathrm{pen}}$ 之间应用本构关系 $P = k_n \\,\\delta_{\\mathrm{pen}}$，从而引入了人为柔度。\n\n建模假设：\n- 将物理赫兹柔度和罚函数柔度视为在相同载荷 $P$ 下，在接触界面法向串联作用，因此总法向趋近量为 $\\delta_{\\mathrm{tot}} = \\delta_{\\mathrm{H}} + \\delta_{\\mathrm{pen}}$。\n\n任务：\n1. 基于上述原理，推导纯物理赫兹压痕 $\\delta_{\\mathrm{H}}$ 关于 $P$、$E^\\star$ 和 $R$ 的公式，以及由罚函数引起的相互穿透量 $\\delta_{\\mathrm{pen}}$ 关于 $P$ 和 $k_n$ 的公式。\n2. 对于给定的罚刚度 $k_n$ 测试集，计算总法向趋近量 $\\delta_{\\mathrm{tot}} = \\delta_{\\mathrm{H}} + \\delta_{\\mathrm{pen}}$ 和人为柔度分数 $f_{\\mathrm{art}} = \\delta_{\\mathrm{pen}} / \\delta_{\\mathrm{tot}}$。\n3. 以毫米表示总法向趋近量，并以小数（非百分比）表示人为柔度分数。将两个量均四舍五入到六位小数。\n\n使用以下材料、几何参数和载荷：\n- $E_1 = 5 \\times 10^6$ $\\mathrm{Pa}$。\n- $\\nu_1 = 0.49$。\n- $R = 1.0 \\times 10^{-2}$ $\\mathrm{m}$。\n- $P = 1.0 \\times 10^{1}$ $\\mathrm{N}$。\n\n$k_n$ 的测试集：\n- 情况 A (理想情况，中等罚刚度): $k_n = 1.0 \\times 10^{6}$ $\\mathrm{N/m}$。\n- 情况 B (边界情况，小罚刚度): $k_n = 1.0 \\times 10^{5}$ $\\mathrm{N/m}$。\n- 情况 C (覆盖性情况，较大罚刚度): $k_n = 1.0 \\times 10^{8}$ $\\mathrm{N/m}$。\n- 情况 D (边界情况，接近约束极限): $k_n = 1.0 \\times 10^{12}$ $\\mathrm{N/m}$。\n- 情况 E (覆盖性情况，中高罚刚度): $k_n = 1.0 \\times 10^{9}$ $\\mathrm{N/m}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由逗号分隔的子列表列表，用方括号括起来，且没有空格。每个子列表必须包含两个浮点数：$[\\delta_{\\mathrm{tot}}\\ (\\text{单位为毫米}),\\ f_{\\mathrm{art}}]$，两者均四舍五入到六位小数。例如：$[[d_1,f_1],[d_2,f_2],[d_3,f_3]]$。",
            "solution": "该问题经评估有效。它在科学上基于接触力学（赫兹理论）和计算力学（有限元法中的罚函数法）的原理。问题提法恰当，提供了所有必要的参数、方程和边界条件，可以推导出唯一且稳定的解。问题陈述客观、完整，没有矛盾或含糊之处。\n\n求解过程分两个阶段：首先，推导控制方程；其次，对指定的测试用例进行数值计算。\n\n**1. 控制方程的推导**\n\n问题要求量化总法向趋近量 $\\delta_{\\mathrm{tot}}$，该量被建模为物理压痕 $\\delta_{\\mathrm{H}}$ 与人为罚函数引起的相互穿透量 $\\delta_{\\mathrm{pen}}$ 之和。\n$$\n\\delta_{\\mathrm{tot}} = \\delta_{\\mathrm{H}} + \\delta_{\\mathrm{pen}}\n$$\n这代表了一个模型，其中材料的物理柔度和罚函数约束的数值柔度在规定载荷 $P$ 下串联作用。\n\n首先，我们推导物理赫兹压痕 $\\delta_{\\mathrm{H}}$ 的表达式。球体与刚性平面接触的赫兹接触理论提供了以下关系：\n$$\nP = \\frac{4}{3} E^\\star R^{1/2} \\delta_{\\mathrm{H}}^{3/2}\n$$\n其中 $P$ 是法向载荷，$R$ 是球体半径，$E^\\star$ 是有效模量。求解 $\\delta_{\\mathrm{H}}$ 需要进行代数运算：\n$$\n\\delta_{\\mathrm{H}}^{3/2} = \\frac{3P}{4 E^\\star R^{1/2}}\n$$\n将两边同时取 $2/3$ 次幂，得到 $\\delta_{\\mathrm{H}}$ 的公式：\n$$\n\\delta_{\\mathrm{H}} = \\left(\\frac{3P}{4 E^\\star R^{1/2}}\\right)^{2/3}\n$$\n对于可变形球体（杨氏模量为 $E_1$，泊松比为 $\\nu_1$）与刚性平面之间的接触，有效模量 $E^\\star$ 由下式给出：\n$$\n\\frac{1}{E^\\star} = \\frac{1 - \\nu_1^2}{E_1} \\implies E^\\star = \\frac{E_1}{1 - \\nu_1^2}\n$$\n\n接下来，我们推导由罚函数引起的相互穿透量 $\\delta_{\\mathrm{pen}}$ 的表达式。有限元法中的罚函数法通过法向罚刚度 $k_n$ 在接触力（在平衡状态下必须等于施加载荷 $P$）和相互穿透量 $\\delta_{\\mathrm{pen}}$ 之间引入了线性本构关系：\n$$\nP = k_n \\delta_{\\mathrm{pen}}\n$$\n求解 $\\delta_{\\mathrm{pen}}$ 得：\n$$\n\\delta_{\\mathrm{pen}} = \\frac{P}{k_n}\n$$\n该项代表了人为柔度，因为它允许非物理的相互穿透，且穿透量随着罚刚度 $k_n$ 的增加而减小。\n\n最后，人为柔度分数 $f_{\\mathrm{art}}$ 定义为罚函数穿透量与总趋近量之比：\n$$\nf_{\\mathrm{art}} = \\frac{\\delta_{\\mathrm{pen}}}{\\delta_{\\mathrm{tot}}} = \\frac{\\delta_{\\mathrm{pen}}}{\\delta_{\\mathrm{H}} + \\delta_{\\mathrm{pen}}}\n$$\n\n**2. 测试用例的数值计算**\n\n给定以下参数：\n- 杨氏模量: $E_1 = 5 \\times 10^6$ $\\mathrm{Pa}$\n- 泊松比: $\\nu_1 = 0.49$\n- 压头半径: $R = 1.0 \\times 10^{-2}$ $\\mathrm{m}$\n- 法向载荷: $P = 1.0 \\times 10^{1}$ $\\mathrm{N}$\n\n首先，我们计算常数值 $E^\\star$ 和 $\\delta_{\\mathrm{H}}$。\n有效模量 $E^\\star$ 为：\n$$\nE^\\star = \\frac{E_1}{1 - \\nu_1^2} = \\frac{5 \\times 10^6}{1 - (0.49)^2} = \\frac{5 \\times 10^6}{1 - 0.2401} = \\frac{5 \\times 10^6}{0.7599} \\approx 6.579813 \\times 10^6 \\ \\mathrm{Pa}\n$$\n物理赫兹压痕 $\\delta_{\\mathrm{H}}$ 在所有测试用例中均为常数：\n$$\n\\delta_{\\mathrm{H}} = \\left(\\frac{3 \\times 10}{4 \\times (6.579813 \\times 10^6) \\times (1.0 \\times 10^{-2})^{1/2}}\\right)^{2/3} = \\left(\\frac{30}{4 \\times (6.579813 \\times 10^6) \\times 0.1}\\right)^{2/3}\n$$\n$$\n\\delta_{\\mathrm{H}} = \\left(\\frac{30}{2.631925 \\times 10^6}\\right)^{2/3} \\approx (1.140003 \\times 10^{-5})^{2/3} \\approx 5.0853335 \\times 10^{-4} \\ \\mathrm{m}\n$$\n这个 $\\delta_{\\mathrm{H}} \\approx 0.5085$ $\\mathrm{mm}$ 的值是纯物理压痕。现在我们为每个给定的罚刚度 $k_n$ 计算结果。\n\n- **情况 A:** $k_n = 1.0 \\times 10^{6}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^6} = 1.0 \\times 10^{-5}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-5}) = 5.1853335 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.518533$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-5}}{5.1853335 \\times 10^{-4}} \\approx 0.019285$\n\n- **情况 B:** $k_n = 1.0 \\times 10^{5}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^5} = 1.0 \\times 10^{-4}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-4}) = 6.0853335 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.608533$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-4}}{6.0853335 \\times 10^{-4}} \\approx 0.164330$\n\n- **情况 C:** $k_n = 1.0 \\times 10^{8}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^8} = 1.0 \\times 10^{-7}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-7}) = 5.0863335 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.508633$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-7}}{5.0863335 \\times 10^{-4}} \\approx 0.000197$\n\n- **情况 D:** $k_n = 1.0 \\times 10^{12}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^{12}} = 1.0 \\times 10^{-11}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-11}) = 5.0853336 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.508533$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-11}}{5.0853336 \\times 10^{-4}} \\approx 1.966 \\times 10^{-8} \\approx 0.000000$\n\n- **情况 E:** $k_n = 1.0 \\times 10^{9}$ $\\mathrm{N/m}$\n  - $\\delta_{\\mathrm{pen}} = \\frac{10}{1.0 \\times 10^9} = 1.0 \\times 10^{-8}$ $\\mathrm{m}$\n  - $\\delta_{\\mathrm{tot}} = (5.0853335 \\times 10^{-4}) + (1.0 \\times 10^{-8}) = 5.0854335 \\times 10^{-4}$ $\\mathrm{m} \\implies 0.508543$ $\\mathrm{mm}$\n  - $f_{\\mathrm{art}} = \\frac{1.0 \\times 10^{-8}}{5.0854335 \\times 10^{-4}} \\approx 1.96639 \\times 10^{-5} \\approx 0.000020$\n\n结果显示出一个清晰的趋势：随着罚刚度 $k_n$ 的增加，由罚函数引起的相互穿透量 $\\delta_{\\mathrm{pen}}$ 减小，总趋近量 $\\delta_{\\mathrm{tot}}$ 收敛于纯物理的赫兹压痕 $\\delta_{\\mathrm{H}}$。因此，人为柔度分数 $f_{\\mathrm{art}}$ 趋近于零，表明接触约束的施加更为准确。反之，较低的罚刚度（情况 B）会导致显著的人为柔度，此时超过 $16\\%$ 的总位移是非物理的相互穿透。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total normal approach and artificial compliance fraction\n    for a spherical indenter on a rigid flat using a penalty contact model.\n    \"\"\"\n\n    # Define material, geometric, and loading parameters from the problem statement.\n    # All units are SI (meters, Pascals, Newtons).\n    E1 = 5.0e6  # Young's modulus of the sphere in Pa\n    nu1 = 0.49  # Poisson's ratio of the sphere\n    R = 1.0e-2  # Radius of the sphere in m\n    P = 1.0e1   # Prescribed normal load in N\n\n    # Define the test suite of penalty stiffnesses (k_n in N/m).\n    # The order is Case A, B, C, D, E as specified.\n    test_cases_kn = [\n        1.0e6,   # Case A\n        1.0e5,   # Case B\n        1.0e8,   # Case C\n        1.0e12,  # Case D\n        1.0e9    # Case E\n    ]\n\n    # --- Calculations ---\n\n    # 1. Calculate the effective modulus (E*)\n    # For a deformable sphere on a rigid flat: 1/E* = (1 - nu1^2) / E1\n    E_star = E1 / (1 - nu1**2)\n\n    # 2. Calculate the purely physical Hertzian indentation (delta_H)\n    # This value is constant for all test cases.\n    # P = (4/3) * E* * R^(1/2) * delta_H^(3/2)\n    # => delta_H = ( (3*P) / (4 * E_star * R**0.5) )**(2/3)\n    delta_H = ((3 * P) / (4 * E_star * R**0.5))**(2/3)\n\n    results = []\n    # 3. Loop through each test case for k_n\n    for kn in test_cases_kn:\n        # a. Calculate penalty-induced interpenetration (delta_pen)\n        # P = kn * delta_pen => delta_pen = P / kn\n        delta_pen = P / kn\n\n        # b. Calculate total normal approach (delta_tot)\n        # delta_tot = delta_H + delta_pen\n        delta_tot = delta_H + delta_pen\n\n        # c. Calculate the artificial fraction (f_art)\n        # f_art = delta_pen / delta_tot\n        f_art = delta_pen / delta_tot\n\n        # d. Convert total approach to millimeters for output\n        delta_tot_mm = delta_tot * 1000\n\n        # e. Store the rounded results as a pair\n        # The problem requires rounding to six decimal places.\n        # String formatting is used for reliable rounding for display.\n        results.append((delta_tot_mm, f_art))\n\n    # --- Final Output Formatting ---\n\n    # Format each result pair as a sublist string \"[val1,val2]\"\n    # using format specifiers to ensure 6 decimal places.\n    sublist_strs = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    \n    # Join the sublist strings with commas and enclose in brackets.\n    # Example format: [[d1,f1],[d2,f2],[d3,f3]]\n    final_output = f\"[{','.join(sublist_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在有限元分析中，接触力是通过对接触界面上的牽引力（压力和剪切应力）分布进行积分来计算的。要准确计算合力，就需要对这些牽引力进行数值积分，这尤其在曲面上是一个挑战。本练习  比较了两种常见的积分方案——简单的节点集中法和更精确的“砂浆”式高斯积分法——旨在阐明数值积分方法的选择如何影响最终计算力的准确性。",
            "id": "4167059",
            "problem": "一个半径为 $R_1$ 的球形压头压缩一个曲面软骨，该软骨表面被建模为半径为 $R_2$ 的球壳。软骨被建模为均匀、各向同性的线性弹性固体，其杨氏模量为 $E_2$，泊松比为 $\\nu_2$。压头相对于软骨被假定为刚性，但其属性 $E_1$ 和 $\\nu_1$ 被用于定义组合法向响应，这通过标准的双体有效模量实现。压痕深度为 $\\delta$（假设其足够小以使经典线性弹性理论有效），切向摩擦使用库仑摩擦模型，摩擦系数为 $\\mu$。运动为切向上的完全滑动，无粘滞。接触是轴对称的，精确的牵引力分布是经典的光滑轴对称解，该解由无摩擦法向接触的线性弹性理论（赫兹型）导出，并结合标准库仑摩擦来处理切向牵引力。\n\n您的任务是，在有限元背景下比较两种不同的界面积分方案时，量化在接触界面上对接触牵引力进行积分所产生的求积误差：\n- 点对面（界面面积的节点集中）。\n- 砂浆法类型的界面上单元高斯求积。\n\n您必须为每个测试用例计算，在使用每种方案对接触斑上的总法向力和总切向（摩擦）力进行积分时，相对于解析精确值的相对求积误差。将量 $Q$ 的相对误差定义为 $|Q_{\\text{num}} - Q_{\\text{exact}}| / |Q_{\\text{exact}}|$。\n\n使用以下可用于高级推导和实现的基础：\n- 适用于接触系统的牛顿运动定律和静力平衡。\n- 适用于各向同性介质中小应变、轴对称接触的线性弹性理论，以及小变形极限下球形接触法向牵引力分布的经典闭式解。\n- 两个弹性体接触时的有效接触模量的定义。\n- 完全滑移条件下摩擦系数为 $\\mu$ 的库仑摩擦定律。\n\n实现要求与说明：\n- 设有效接触半径为 $R_{\\text{eff}}$，由两个物体的球形几何确定；有效模量为 $E^\\star$，由 $E_1$、$\\nu_1$、$E_2$ 和 $\\nu_2$ 确定。\n- 解析接触斑半径为 $a$，解析总法向力为 $N_{\\text{exact}}$。轴对称法向牵引力场 $p(r)$ 仅取决于径向坐标 $r \\in [0,a]$，在完全滑移的库仑摩擦下，总切向（摩擦）力为 $T_{\\text{exact}}$。\n- 点对面方案应通过将环形区域的面积集中到环中点半径处的节点来近似曲面积分；在轴对称设置中，这简化为对等厚度径向环和等角度周向分段应用中点法则。对于半径在 $r_{i-1}$ 和 $r_i$ 之间、面积为 $A_i$ 的环，在 $r_i^{\\text{mid}} = (r_{i-1}+r_i)/2$ 处求值并求和 $p(r_i^{\\text{mid}}) A_i$。\n- 砂浆法方案应将接触斑划分为 $N_r \\times N_t$ 个极坐标单元（径向乘以周向），并在径向应用 $q_r$ 阶高斯求积，在周向应用 $q_t$ 阶高斯求积。使用极坐标面积元 $\\mathrm{d}A = r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta$，并将每个单元从标准区间 $[-1,1]$ 映射到物理坐标。轴对称性意味着被积函数与 $\\theta$ 无关，但实现仍必须遵循两个方向上的单元高斯求积。\n\n单位：\n- 几何长度，包括 $R_1$、$R_2$ 和 $\\delta$，以米（$\\mathrm{m}$）表示。\n- 弹性模量，$E_1$ 和 $E_2$，以帕斯卡（$\\mathrm{Pa}$）表示。\n- 泊松比，$\\nu_1$ 和 $\\nu_2$，是无量纲的。\n- 力和牵引力分别以牛顿（$\\mathrm{N}$）和帕斯卡（$\\mathrm{Pa}$）表示。\n- 摩擦系数 $\\mu$ 是无量纲的。\n- 最终输出是无量纲的相对误差。\n\n测试套件：\n对于每个测试用例，提供 $(R_1, R_2, E_1, \\nu_1, E_2, \\nu_2, \\delta, \\mu, N_r, N_t, q_r, q_t)$:\n\n1. 正常路径，中等曲率和网格：\n   - $R_1 = 0.01\\,\\mathrm{m}$，$R_2 = 0.015\\,\\mathrm{m}$，$E_1 = 210\\times 10^9\\,\\mathrm{Pa}$，$\\nu_1 = 0.30$，$E_2 = 5\\times 10^6\\,\\mathrm{Pa}$，$\\nu_2 = 0.49$，$\\delta = 5\\times 10^{-5}\\,\\mathrm{m}$，$\\mu = 0.20$，$N_r = 4$，$N_t = 16$，$q_r = 2$，$q_t = 2$。\n2. 边界条件，非常粗糙的节点和砂浆法积分：\n   - $R_1 = 0.005\\,\\mathrm{m}$，$R_2 = 0.006\\,\\mathrm{m}$，$E_1 = 210\\times 10^9\\,\\mathrm{Pa}$，$\\nu_1 = 0.30$，$E_2 = 5\\times 10^6\\,\\mathrm{Pa}$，$\\nu_2 = 0.49$，$\\delta = 2\\times 10^{-5}\\,\\mathrm{m}$，$\\mu = 0.40$，$N_r = 1$，$N_t = 4$，$q_r = 1$，$q_t = 1$。\n3. 精细离散化：\n   - $R_1 = 0.02\\,\\mathrm{m}$，$R_2 = 0.03\\,\\mathrm{m}$，$E_1 = 210\\times 10^9\\,\\mathrm{Pa}$，$\\nu_1 = 0.30$，$E_2 = 5\\times 10^6\\,\\mathrm{Pa}$，$\\nu_2 = 0.49$，$\\delta = 1\\times 10^{-4}\\,\\mathrm{m}$，$\\mu = 0.10$，$N_r = 20$，$N_t = 40$，$q_r = 3$，$q_t = 3$。\n4. 近乎平坦的软骨表面：\n   - $R_1 = 0.01\\,\\mathrm{m}$，$R_2 = 1.0\\,\\mathrm{m}$，$E_1 = 210\\times 10^9\\,\\mathrm{Pa}$，$\\nu_1 = 0.30$，$E_2 = 5\\times 10^6\\,\\mathrm{Pa}$，$\\nu_2 = 0.49$，$\\delta = 2\\times 10^{-5}\\,\\mathrm{m}$，$\\mu = 0.80$，$N_r = 6$，$N_t = 24$，$q_r = 2$，$q_t = 2$。\n5. 高曲率软骨：\n   - $R_1 = 0.01\\,\\mathrm{m}$，$R_2 = 0.004\\,\\mathrm{m}$，$E_1 = 210\\times 10^9\\,\\mathrm{Pa}$，$\\nu_1 = 0.30$，$E_2 = 5\\times 10^6\\,\\mathrm{Pa}$，$\\nu_2 = 0.49$，$\\delta = 1\\times 10^{-5}\\,\\mathrm{m}$，$\\mu = 0.60$，$N_r = 6$，$N_t = 12$，$q_r = 2$，$q_t = 3$。\n\n最终输出规范：\n- 对于每个测试用例，计算并返回列表 $[\\varepsilon^{N}_{\\text{node}}, \\varepsilon^{N}_{\\text{mortar}}, \\varepsilon^{T}_{\\text{node}}, \\varepsilon^{T}_{\\text{mortar}}]$，其中 $\\varepsilon^{N}$ 和 $\\varepsilon^{T}$ 分别表示法向和切向总力的相对误差，下标表示积分方案。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表，每个测试用例的结果本身也是一个列表（例如，`[[e_{1,1}, e_{1,2}, e_{1,3}, e_{1,4}], [e_{2,1}, e_{2,2}, e_{2,3}, e_{2,4}], \\dots]`）。",
            "solution": "问题陈述经评估有效。它科学地基于赫兹接触力学、线弹性理论和库仑摩擦等公认的原理。该问题是适定的，提供了一套独立且一致的定义、参数和目标。语言精确客观，可以得出一个唯一、稳定且有意义的解。因此，我们可以进行形式化求解。\n\n### 1. 理论框架\n\n问题描述了一个球形压头（物体1）和一个球形软骨表面（物体2）之间的轴对称接触。材料被假定为均匀、各向同性和线性弹性的。\n\n**有效材料和几何属性**\n两个物体的组合弹性响应由有效弹性模量 $E^\\star$ 捕捉，定义为：\n$$\n\\frac{1}{E^\\star} = \\frac{1 - \\nu_1^2}{E_1} + \\frac{1 - \\nu_2^2}{E_2}\n$$\n其中 ($E_1, \\nu_1$) 和 ($E_2, \\nu_2$) 分别是压头和软骨的杨氏模量和泊松比。\n\n半径为 $R_1$ 和 $R_2$ 的两个球体的接触几何由有效曲率半径 $R_{\\text{eff}}$ 表征。假设是两个凸面之间的接触，其由以下公式给出：\n$$\n\\frac{1}{R_{\\text{eff}}} = \\frac{1}{R_1} + \\frac{1}{R_2}\n$$\n\n### 2. 解析（精确）解\n\n对于一个小的压痕深度 $\\delta$，经典的赫兹接触理论为所产生的接触斑和压力分布提供了解析解。\n\n**接触半径和压力分布**\n接触发生在一个半径为 $a$ 的圆形斑块上，该半径与压痕深度 $\\delta$ 的关系为：\n$$\na = \\sqrt{\\delta R_{\\text{eff}}}\n$$\n距离接触中心径向距离为 $r$ 处的法向牵引力（压力）$p(r)$ 是半椭球形的：\n$$\np(r) = \n\\begin{cases}\n    p_0 \\sqrt{1 - \\left(\\frac{r}{a}\\right)^2}  \\text{if } r \\le a \\\\\n    0  \\text{if } r  a\n\\end{cases}\n$$\n在中心（$r=0$）处的峰值压力 $p_0$ 由以下公式给出：\n$$\np_0 = \\frac{2 a E^\\star}{\\pi R_{\\text{eff}}}\n$$\n\n**总接触力**\n总法向力 $N_{\\text{exact}}$ 是通过在接触区域 $\\mathcal{A} = \\pi a^2$ 上对压力分布进行积分得到的：\n$$\nN_{\\text{exact}} = \\int_{\\mathcal{A}} p(r) \\, \\mathrm{d}A = \\int_0^{2\\pi} \\int_0^a p(r) \\, r \\, \\mathrm{d}r \\, \\mathrm{d}\\theta = 2\\pi \\int_0^a p_0 \\sqrt{1 - \\left(\\frac{r}{a}\\right)^2} r \\, \\mathrm{d}r\n$$\n计算此积分可得出著名的赫兹载荷-位移关系：\n$$\nN_{\\text{exact}} = \\frac{2}{3} \\pi p_0 a^2 = \\frac{4}{3} E^\\star R_{\\text{eff}}^{1/2} \\delta^{3/2}\n$$\n问题指定了完全滑动，并具有恒定的摩擦系数 $\\mu$。根据库仑摩擦定律，切向牵引力 $\\tau(r)$ 与法向牵引力成正比：$\\tau(r) = \\mu p(r)$。因此，总切向力 $T_{\\text{exact}}$ 为：\n$$\nT_{\\text{exact}} = \\int_{\\mathcal{A}} \\tau(r) \\, \\mathrm{d}A = \\mu \\int_{\\mathcal{A}} p(r) \\, \\mathrm{d}A = \\mu N_{\\text{exact}}\n$$\n\n### 3. 数值积分方案\n\n我们的任务是计算两种数值方案的求积误差。\n\n**A. 点对面方案**\n该方案通过将接触斑离散化为 $N_r$ 个等径向厚度 $\\Delta r = a/N_r$ 的同心环来近似积分。对于第 $i$ 个环，其半径范围从 $r_{i-1} = (i-1)\\Delta r$ 到 $r_i = i\\Delta r$，面积为 $A_i = \\pi (r_i^2 - r_{i-1}^2)$。在环的中点半径 $r_i^{\\text{mid}} = (r_{i-1} + r_i)/2$ 处评估牵引力。总法向力通过以下求和来近似：\n$$\nN_{\\text{node}} = \\sum_{i=1}^{N_r} p(r_i^{\\text{mid}}) A_i\n$$\n\n**B. 砂浆法方案**\n该方案将圆形域划分为 $N_r \\times N_t$ 个极坐标单元。每个单元上的积分使用高斯求积计算。一个单元 $(i,j)$ 覆盖域 $r \\in [r_{i-1}, r_i]$ 和 $\\theta \\in [\\theta_{j-1}, \\theta_j]$。函数 $f(r,\\theta)$ 的积分被转换到标准的双单位正方形 $(\\xi, \\eta) \\in [-1,1]\\times[-1,1]$ 上：\n$$\nI_{ij} = \\int_{\\theta_{j-1}}^{\\theta_j} \\int_{r_{i-1}}^{r_i} f(r, \\theta) r \\, \\mathrm{d}r \\, \\mathrm{d}\\theta = \\int_{-1}^1 \\int_{-1}^1 f(r(\\xi), \\theta(\\eta)) r(\\xi) \\det(J) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\n其中 $r(\\xi)$ 和 $\\theta(\\eta)$ 是线性映射，$\\det(J) = (\\frac{\\Delta r}{2})(\\frac{\\Delta \\theta}{2})$ 是变换的雅可比行列式。应用一个具有权重 $w_k, w_l$ 和点 $\\xi_k, \\eta_l$ 的 $(q_r \\times q_t)$ 点高斯求积法则：\n$$\nI_{ij} \\approx \\left(\\frac{\\Delta r}{2}\\right)\\left(\\frac{\\Delta \\theta}{2}\\right) \\sum_{l=1}^{q_t} \\sum_{k=1}^{q_r} w_l w_k f(r(\\xi_k), \\theta(\\eta_l)) r(\\xi_k)\n$$\n对于我们的轴对称问题，被积函数 $p(r)$ 与 $\\theta$ 无关。对 $\\theta$ 的积分可以解析地执行。对所有 $N_t$ 个周向单元和 $\\eta$ 方向上的 $q_t$ 个高斯点的求和简化为：\n$$\n\\sum_{j=1}^{N_t} \\left(\\frac{\\Delta \\theta}{2}\\right) \\sum_{l=1}^{q_t} w_l = \\sum_{j=1}^{N_t} \\left(\\frac{2\\pi/N_t}{2}\\right) (2) = \\sum_{j=1}^{N_t} \\frac{2\\pi}{N_t} = 2\\pi\n$$\n因此，总法向力可以通过在径向域上进行一维求积来高效计算：\n$$\nN_{\\text{mortar}} = 2\\pi \\sum_{i=1}^{N_r} \\left(\\frac{\\Delta r}{2}\\right) \\sum_{k=1}^{q_r} w_k p(r(\\xi_k)) r(\\xi_k)\n$$\n其中对于每个径向单元 $i$，$r(\\xi_k)$ 在该径向段内的第 $k$ 个高斯点处求值。\n\n### 4. 误差量化\n\n对于一个量 $Q$（法向力 $N$ 或切向力 $T$），其相对误差定义为：\n$$\n\\varepsilon^Q_{\\text{scheme}} = \\frac{|Q_{\\text{scheme}} - Q_{\\text{exact}}|}{|Q_{\\text{exact}}|}\n$$\n对于切向力，数值近似为 $T_{\\text{scheme}} = \\mu N_{\\text{scheme}}$，因为积分算子是线性的且 $\\mu$ 是一个常数。因此，对于每种方案，切向力的相对误差与法向力的相对误差相同：\n$$\n\\varepsilon^T_{\\text{scheme}} = \\frac{|\\mu N_{\\text{scheme}} - \\mu N_{\\text{exact}}|}{|\\mu N_{\\text{exact}}|} = \\frac{|N_{\\text{scheme}} - N_{\\text{exact}}|}{|N_{\\text{exact}}|} = \\varepsilon^N_{\\text{scheme}}\n$$\n因此，对于每个测试用例，我们将计算两个唯一的误差值，$\\varepsilon^N_{\\text{node}}$ 和 $\\varepsilon^N_{\\text{mortar}}$，并按 $[\\varepsilon^N_{\\text{node}}, \\varepsilon^N_{\\text{mortar}}, \\varepsilon^N_{\\text{node}}, \\varepsilon^N_{\\text{mortar}}]$ 的格式报告所要求的四个值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It orchestrates the calculation of quadrature errors for each test case\n    and prints the results in the specified format.\n    \"\"\"\n\n    test_cases = [\n        # (R1, R2, E1, nu1, E2, nu2, delta, mu, Nr, Nt, qr, qt)\n        (0.01, 0.015, 210e9, 0.30, 5e6, 0.49, 5e-5, 0.20, 4, 16, 2, 2),\n        (0.005, 0.006, 210e9, 0.30, 5e6, 0.49, 2e-5, 0.40, 1, 4, 1, 1),\n        (0.02, 0.03, 210e9, 0.30, 5e6, 0.49, 1e-4, 0.10, 20, 40, 3, 3),\n        (0.01, 1.0, 210e9, 0.30, 5e6, 0.49, 2e-5, 0.80, 6, 24, 2, 2),\n        (0.01, 0.004, 210e9, 0.30, 5e6, 0.49, 1e-5, 0.60, 6, 12, 2, 3),\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        errors = calculate_errors(case_params)\n        all_results.append(errors)\n    \n    # Format the final list of lists into the required string format.\n    # e.g., [[e1, e2, e3, e4], [f1, f2, f3, f4]]\n    result_str = \"[\" + \",\".join([f\"[{e[0]},{e[1]},{e[2]},{e[3]}]\" for e in all_results]) + \"]\"\n    print(result_str)\n\n\ndef calculate_errors(params):\n    \"\"\"\n    Calculates the relative quadrature errors for a single test case.\n\n    Args:\n        params (tuple): A tuple containing all the parameters for one test case.\n\n    Returns:\n        list: A list of four floats: \n              [err_N_node, err_N_mortar, err_T_node, err_T_mortar].\n    \"\"\"\n    R1, R2, E1, nu1, E2, nu2, delta, mu, Nr, Nt, qr, qt = params\n\n    # 1. Calculate analytical (exact) values\n    \n    # Effective radius of curvature\n    R_eff = 1.0 / (1.0 / R1 + 1.0 / R2)\n    \n    # Effective Young's modulus\n    E_star = 1.0 / ((1.0 - nu1**2) / E1 + (1.0 - nu2**2) / E2)\n    \n    # Contact radius\n    a = math.sqrt(delta * R_eff)\n    \n    # Exact total normal force\n    N_exact = (4.0/3.0) * E_star * math.sqrt(R_eff) * delta**1.5\n    \n    if N_exact == 0:\n        return [0.0, 0.0, 0.0, 0.0]\n\n    # Peak pressure\n    p0 = (2.0 * a * E_star) / (math.pi * R_eff)\n\n    def p(r):\n        \"\"\"Hertzian pressure distribution.\"\"\"\n        if r > a:\n            return 0.0\n        # Guard against floating point error where r is slightly > a\n        val_inside_sqrt = 1.0 - (r / a)**2\n        if val_inside_sqrt  0:\n            return 0.0\n        return p0 * math.sqrt(val_inside_sqrt)\n\n    # 2. Node-to-surface integration\n    N_node = 0.0\n    dr_node = a / Nr\n    for i in range(1, Nr + 1):\n        r_outer = i * dr_node\n        r_inner = (i - 1) * dr_node\n        r_mid = (r_inner + r_outer) / 2.0\n        ring_area = math.pi * (r_outer**2 - r_inner**2)\n        N_node += p(r_mid) * ring_area\n\n    # 3. Mortar-type integration\n    N_mortar = 0.0\n    dr_mortar = a / Nr\n    # Get standard Gauss-Legendre points and weights for [-1, 1]\n    xi_k, w_k = leggauss(qr)\n    \n    # Radial integration\n    radial_integral_sum = 0.0\n    for i in range(1, Nr + 1):\n        r_outer = i * dr_mortar\n        r_inner = (i - 1) * dr_mortar\n        \n        # Sum over Gauss points for this element\n        element_sum = 0.0\n        for k_idx in range(qr):\n            # Map Gauss point xi_k from [-1, 1] to [r_inner, r_outer]\n            r_k = (r_outer - r_inner) / 2.0 * xi_k[k_idx] + (r_outer + r_inner) / 2.0\n            element_sum += w_k[k_idx] * p(r_k) * r_k\n        \n        radial_integral_sum += (r_outer - r_inner) / 2.0 * element_sum\n\n    # Full integral includes the 2*pi from circumferential integration\n    N_mortar = 2.0 * math.pi * radial_integral_sum\n\n    # 4. Calculate relative errors\n    err_N_node = abs(N_node - N_exact) / abs(N_exact)\n    err_N_mortar = abs(N_mortar - N_exact) / abs(N_exact)\n    \n    # As derived, tangential force errors are identical to normal force errors\n    err_T_node = err_N_node\n    err_T_mortar = err_N_mortar\n\n    return [err_N_node, err_N_mortar, err_T_node, err_T_mortar]\n\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}