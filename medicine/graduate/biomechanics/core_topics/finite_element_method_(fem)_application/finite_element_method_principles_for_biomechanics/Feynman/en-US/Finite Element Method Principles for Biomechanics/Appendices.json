{
    "hands_on_practices": [
        {
            "introduction": "The Principle of Virtual Work (PVW) is the theoretical cornerstone of the Finite Element Method, providing the weak form of the equilibrium equations. A deep understanding of the PVW requires mastering the concept of work conjugacy, which ensures that the internal work is calculated correctly regardless of the chosen strain measure. This exercise  challenges you to apply the PVW to a one-dimensional system to derive the specific stress measure that is energetically conjugate to a generalized strain definition, a fundamental skill for developing and implementing advanced hyperelastic material models.",
            "id": "4174343",
            "problem": "A slender, fiber-dominated tendon is modeled as a one-dimensional hyperelastic bar of reference length $L_{0}$ and uniform reference cross-sectional area $A_{0}$. The tendon is subjected to a quasi-static axial traction $\\bar{t}_{0}$ per unit reference area at its free end, producing a uniform axial stretch $\\lambda = \\frac{L}{L_{0}}$, where $L$ is the current length. Ignore body forces and lateral effects. Adopt the Principle of Virtual Work formulated in the reference configuration (the weak form central to the Finite Element Method (FEM)) and use a strain measure $E(\\lambda)$ chosen as\n$$\nE(\\lambda) = \\frac{1}{p}\\left(\\lambda^{p} - 1\\right),\n$$\nwith $p \\in \\mathbb{R}\\setminus\\{0\\}$. Define the stress measure $S_{E}$ to be work-conjugate to $E$ in the sense that the internal virtual work density is $S_{E}\\,\\delta E$. Under the assumptions above and using only the virtual work statement and kinematics, derive and simplify the expression for $S_{E}$ as a function of $\\bar{t}_{0}$, $\\lambda$, and $p$. Provide your final answer as a single closed-form analytic expression. Do not compute any numerical value.",
            "solution": "The Principle of Virtual Work (PVW) in the reference configuration asserts that the internal virtual work, $\\delta W_{int}$, is equal to the external virtual work, $\\delta W_{ext}$, for any kinematically admissible virtual displacement field. This principle is expressed as:\n$$\n\\delta W_{int} = \\delta W_{ext}\n$$\nThe problem considers a one-dimensional bar of reference length $L_0$ and reference cross-sectional area $A_0$. We will formulate the expressions for both internal and external virtual work for this system.\n\nFirst, we address the internal virtual work, $\\delta W_{int}$. The problem specifies that the internal virtual work density (virtual work per unit reference volume) is $S_E \\delta E$, where $S_E$ is the stress measure work-conjugate to the given strain measure $E(\\lambda)$. The total internal virtual work is the integral of this density over the entire reference volume $V_0 = A_0 L_0$:\n$$\n\\delta W_{int} = \\int_{V_0} S_E \\delta E \\, dV_0\n$$\nAccording to the problem statement, the axial stretch $\\lambda$ is uniform throughout the bar. This implies that the strain $E$, being a function of $\\lambda$ only, is also uniform. Consequently, its variation, $\\delta E$, and the work-conjugate stress, $S_E$, are also constant throughout the volume $V_0$. We can therefore move these quantities outside the integral:\n$$\n\\delta W_{int} = S_E \\delta E \\int_{V_0} dV_0 = S_E \\delta E (A_0 L_0)\n$$\n\nNext, we formulate the external virtual work, $\\delta W_{ext}$. The only external force acting on the body is the prescribed axial traction $\\bar{t}_0$ at the free end. This traction is defined per unit reference area $A_0$. Thus, the total axial force, $F$, applied at the free end is:\n$$\nF = \\bar{t}_0 A_0\n$$\nThe displacement of the free end of the bar is $u = L - L_0$, where $L$ is the current length. The virtual work done by the force $F$ is its product with the corresponding virtual displacement, $\\delta u$. Since body forces are ignored, this constitutes the total external virtual work:\n$$\n\\delta W_{ext} = F \\delta u = (\\bar{t}_0 A_0) \\delta u\n$$\n\nTo proceed, we must connect the virtual quantities $\\delta E$ and $\\delta u$ through the problem's kinematics. The axial stretch is defined as $\\lambda = \\frac{L}{L_0}$. The current length $L$ can be expressed in terms of the end displacement $u$ as $L = L_0 + u$. Substituting this into the definition of stretch, we get:\n$$\n\\lambda = \\frac{L_0 + u}{L_0} = 1 + \\frac{u}{L_0}\n$$\nTaking the variation of this expression yields the virtual stretch $\\delta \\lambda$. Since $L_0$ is a constant, we have:\n$$\n\\delta \\lambda = \\delta \\left(1 + \\frac{u}{L_0}\\right) = \\frac{\\delta u}{L_0}\n$$\nThe strain measure is given as $E(\\lambda) = \\frac{1}{p}(\\lambda^p - 1)$. The virtual strain $\\delta E$ is related to the virtual stretch $\\delta \\lambda$ by the chain rule:\n$$\n\\delta E = \\frac{dE}{d\\lambda} \\delta \\lambda\n$$\nWe compute the derivative of $E$ with respect to $\\lambda$:\n$$\n\\frac{dE}{d\\lambda} = \\frac{d}{d\\lambda}\\left[\\frac{1}{p}(\\lambda^p - 1)\\right] = \\frac{1}{p}(p \\lambda^{p-1}) = \\lambda^{p-1}\n$$\nSubstituting this result gives the expression for the virtual strain:\n$$\n\\delta E = \\lambda^{p-1} \\delta \\lambda\n$$\nNow, we express $\\delta E$ in terms of the virtual displacement $\\delta u$ by substituting the relation $\\delta \\lambda = \\frac{\\delta u}{L_0}$:\n$$\n\\delta E = \\lambda^{p-1} \\left(\\frac{\\delta u}{L_0}\\right)\n$$\n\nWith all components defined, we return to the Principle of Virtual Work, $\\delta W_{int} = \\delta W_{ext}$:\n$$\nS_E \\delta E (A_0 L_0) = (\\bar{t}_0 A_0) \\delta u\n$$\nWe substitute the derived expression for $\\delta E$ into this equation:\n$$\nS_E \\left(\\lambda^{p-1} \\frac{\\delta u}{L_0}\\right) (A_0 L_0) = \\bar{t}_0 A_0 \\delta u\n$$\nThe reference length $L_0$ in the numerator and denominator on the left-hand side cancels out:\n$$\nS_E \\lambda^{p-1} \\delta u A_0 = \\bar{t}_0 A_0 \\delta u\n$$\nThe PVW must hold for any arbitrary, non-zero, kinematically admissible virtual displacement $\\delta u$. Therefore, we can divide both sides of the equation by the term $A_0 \\delta u$ (since $A_0 > 0$ and $\\delta u$ is arbitrary):\n$$\nS_E \\lambda^{p-1} = \\bar{t}_0\n$$\nFinally, we solve for the stress measure $S_E$ by dividing by $\\lambda^{p-1}$:\n$$\nS_E = \\frac{\\bar{t}_0}{\\lambda^{p-1}}\n$$\nThis expression can be rewritten using a negative exponent as:\n$$\nS_E = \\bar{t}_0 \\lambda^{1-p}\n$$\nThis is the final closed-form expression for the stress measure $S_E$ as a function of the applied traction $\\bar{t}_0$, the stretch $\\lambda$, and the material parameter $p$.",
            "answer": "$$\n\\boxed{\\bar{t}_{0}\\lambda^{1-p}}\n$$"
        },
        {
            "introduction": "Once the weak form is established, its terms must be integrated over the element domain, a process typically performed numerically using Gaussian quadrature. The accuracy and efficiency of this integration depend critically on the properties of the element's shape functions. This practice  explores this relationship by examining the stiffness matrix integration for a linear tetrahedral element, revealing a unique property that makes it a 'Constant Strain Tetrahedron' and leads to an exact result with even the simplest integration scheme.",
            "id": "4174351",
            "problem": "A linear four-node tetrahedral finite element in three-dimensional small-strain elasticity is used to model a homogeneous, nearly incompressible soft tissue segment in biomechanics. The tetrahedron has nodal coordinates in millimeters given by node 1 at $(0,0,0)$, node 2 at $(1,0,0)$, node 3 at $(0,2,0)$, and node 4 at $(0,0,3)$. The tissue is modeled as a homogeneous, isotropic, linear elastic solid with Young’s modulus $E$ and Poisson’s ratio $\\nu$, both constant over the element. The constitutive matrix $\\mathbf{C}$ is the standard $6 \\times 6$ elasticity matrix for three-dimensional isotropic linear elasticity.\n\nStarting from the principle of virtual work in small-strain linear elasticity and the definition of the strain-displacement matrix $\\mathbf{B}$ for linear tetrahedral shape functions, consider the element stiffness integrand\n$$\n\\mathbf{I}(\\boldsymbol{x}) = \\mathbf{B}(\\boldsymbol{x})^{T}\\,\\mathbf{C}\\,\\mathbf{B}(\\boldsymbol{x}),\n$$\nand the element stiffness integral\n$$\n\\int_{\\Omega} \\mathbf{B}^{T}\\mathbf{C}\\mathbf{B}\\,\\mathrm{d}\\Omega,\n$$\nwhere $\\Omega$ is the element domain. Using one-point integration (single Gauss point at the element centroid), the quadrature approximation is\n$$\n\\left(\\int_{\\Omega} \\mathbf{B}^{T}\\mathbf{C}\\mathbf{B}\\,\\mathrm{d}\\Omega\\right)_{\\text{1-pt}} = |\\Omega|\\,\\mathbf{I}(\\boldsymbol{x}_{c}),\n$$\nwhere $|\\Omega|$ is the element volume and $\\boldsymbol{x}_{c}$ is the centroid.\n\nDefine the normalized Frobenius error\n$$\nR = \\frac{\\left\\|\\left(\\int_{\\Omega} \\mathbf{B}^{T}\\mathbf{C}\\mathbf{B}\\,\\mathrm{d}\\Omega\\right) - \\left(\\int_{\\Omega} \\mathbf{B}^{T}\\mathbf{C}\\mathbf{B}\\,\\mathrm{d}\\Omega\\right)_{\\text{1-pt}}\\right\\|_{F}}{\\left\\|\\int_{\\Omega} \\mathbf{B}^{T}\\mathbf{C}\\mathbf{B}\\,\\mathrm{d}\\Omega\\right\\|_{F}},\n$$\nwhere $\\|\\cdot\\|_{F}$ denotes the Frobenius norm. Compute $R$. Express the final answer as a dimensionless number. No rounding is required.",
            "solution": "The problem asks for the computation of the normalized Frobenius error, $R$, between the exact element stiffness matrix and its approximation using one-point Gaussian quadrature for a linear four-node tetrahedral element.\n\nThe element stiffness matrix, $\\mathbf{K}_e$, is defined by the integral over the element volume $\\Omega$:\n$$\n\\mathbf{K}_e = \\int_{\\Omega} \\mathbf{B}^{T}\\mathbf{C}\\mathbf{B}\\,\\mathrm{d}\\Omega\n$$\nwhere $\\mathbf{B}$ is the strain-displacement matrix and $\\mathbf{C}$ is the constitutive matrix for the material.\n\nThe problem states that the element is a linear four-node tetrahedron. For such an element, the displacement field $\\mathbf{u}(\\boldsymbol{x})$ at a point $\\boldsymbol{x} = (x, y, z)^T$ is interpolated from the nodal displacement vector $\\mathbf{d}$ using linear shape functions $N_i(\\boldsymbol{x})$:\n$$\n\\mathbf{u}(\\boldsymbol{x}) = \\sum_{i=1}^{4} N_i(\\boldsymbol{x})\\mathbf{u}_i = \\mathbf{N}(\\boldsymbol{x})\\mathbf{d}\n$$\nThe shape functions for a linear tetrahedron are linear functions of the spatial coordinates, having the general form:\n$$\nN_i(x, y, z) = a_i + b_i x + c_i y + d_i z\n$$\nThe coefficients $a_i, b_i, c_i, d_i$ are constants determined by the nodal coordinates of the tetrahedron.\n\nIn small-strain elasticity, the strain vector $\\boldsymbol{\\epsilon}$ is obtained by taking the spatial derivatives of the displacement field components. This relationship is captured by the strain-displacement matrix $\\mathbf{B}$, such that $\\boldsymbol{\\epsilon} = \\mathbf{B}\\mathbf{d}$. The components of the $\\mathbf{B}$ matrix are constructed from the spatial derivatives of the shape functions. For example, for a nodal displacement $u_{ix}$ (the $x$-displacement of node $i$), its contribution to the normal strain $\\epsilon_{xx}$ is via the term $\\frac{\\partial N_i}{\\partial x} u_{ix}$.\n\nThe derivatives of the linear shape functions are:\n$$\n\\frac{\\partial N_i}{\\partial x} = b_i\n$$\n$$\n\\frac{\\partial N_i}{\\partial y} = c_i\n$$\n$$\n\\frac{\\partial N_i}{\\partial z} = d_i\n$$\nSince the coefficients $b_i, c_i, d_i$ are constants for a given element geometry, all spatial derivatives of the shape functions are constant throughout the element. Consequently, the strain-displacement matrix $\\mathbf{B}$, which is composed of these derivatives, is a constant matrix. It does not vary with the position $\\boldsymbol{x}$ within the element $\\Omega$. This is a fundamental property of the linear tetrahedral element, which is why it is often referred to as a Constant Strain Tetrahedron (CST).\n\nThe problem states that the material is homogeneous, meaning its properties, Young’s modulus $E$ and Poisson’s ratio $\\nu$, are constant over the element. Therefore, the constitutive matrix $\\mathbf{C}$ is also constant throughout the element.\n\nGiven that both $\\mathbf{B}$ and $\\mathbf{C}$ are constant matrices, the integrand of the stiffness matrix, $\\mathbf{I}(\\boldsymbol{x}) = \\mathbf{B}^{T}\\mathbf{C}\\mathbf{B}$, is also a constant matrix with respect to the integration variable $\\boldsymbol{x}$.\n\nLet us now evaluate the exact integral for the stiffness matrix, $\\mathbf{K}_e$. Since the integrand is constant, we can take it outside the integral:\n$$\n\\mathbf{K}_e = \\int_{\\Omega} (\\mathbf{B}^{T}\\mathbf{C}\\mathbf{B}) \\,\\mathrm{d}\\Omega = (\\mathbf{B}^{T}\\mathbf{C}\\mathbf{B}) \\int_{\\Omega} \\mathrm{d}\\Omega = |\\Omega| (\\mathbf{B}^{T}\\mathbf{C}\\mathbf{B})\n$$\nwhere $|\\Omega|$ is the volume of the tetrahedral element. The nodal coordinates provided, node $1$ at $(0,0,0)$, node $2$ at $(1,0,0)$, node $3$ at $(0,2,0)$, and node $4$ at $(0,0,3)$, define a non-degenerate tetrahedron. Its volume can be calculated as $|\\Omega| = \\frac{1}{6} |\\det(\\mathbf{J})|$, where $\\mathbf{J}$ is the matrix formed by the vectors from one vertex to the other three. With node $1$ at the origin, we have:\n$$\n\\mathbf{J} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 3 \\end{pmatrix}\n$$\nThe volume is $|\\Omega| = \\frac{1}{6} |1 \\cdot 2 \\cdot 3| = \\frac{6}{6} = 1$ mm$^3$. Since $|\\Omega| \\neq 0$, the element is not degenerate.\n\nNext, we evaluate the stiffness matrix using one-point Gaussian quadrature at the element centroid $\\boldsymbol{x}_c$. The formula is given as:\n$$\n\\left(\\mathbf{K}_e\\right)_{\\text{1-pt}} = \\left(\\int_{\\Omega} \\mathbf{B}^{T}\\mathbf{C}\\mathbf{B}\\,\\mathrm{d}\\Omega\\right)_{\\text{1-pt}} = |\\Omega|\\,\\mathbf{I}(\\boldsymbol{x}_{c}) = |\\Omega|\\,(\\mathbf{B}(\\boldsymbol{x}_c)^{T}\\,\\mathbf{C}\\,\\mathbf{B}(\\boldsymbol{x}_c))\n$$\nHowever, we have already established that the integrand $\\mathbf{I}(\\boldsymbol{x}) = \\mathbf{B}^{T}\\mathbf{C}\\mathbf{B}$ is a constant matrix. Its value at the centroid $\\boldsymbol{x}_c$ is the same as its value at any other point in the element. Therefore:\n$$\n\\mathbf{I}(\\boldsymbol{x}_c) = \\mathbf{B}^{T}\\mathbf{C}\\mathbf{B}\n$$\nSubstituting this into the quadrature formula gives:\n$$\n\\left(\\mathbf{K}_e\\right)_{\\text{1-pt}} = |\\Omega| (\\mathbf{B}^{T}\\mathbf{C}\\mathbf{B})\n$$\nComparing the exact stiffness matrix $\\mathbf{K}_e$ with its one-point quadrature approximation $(\\mathbf{K}_e)_{\\text{1-pt}}$, we find that they are identical:\n$$\n\\mathbf{K}_e = \\left(\\mathbf{K}_e\\right)_{\\text{1-pt}}\n$$\nThis result is expected, as one-point Gaussian quadrature is exact for integrating any constant function over the domain.\n\nThe problem requires us to compute the normalized Frobenius error, $R$:\n$$\nR = \\frac{\\left\\|\\mathbf{K}_e - \\left(\\mathbf{K}_e\\right)_{\\text{1-pt}}\\right\\|_{F}}{\\left\\|\\mathbf{K}_e\\right\\|_{F}}\n$$\nThe numerator is the Frobenius norm of the difference between the two matrices. Since the matrices are identical, their difference is the zero matrix:\n$$\n\\left\\|\\mathbf{K}_e - \\left(\\mathbf{K}_e\\right)_{\\text{1-pt}}\\right\\|_{F} = \\left\\|\\mathbf{0}\\right\\|_{F} = 0\n$$\nThe denominator is the Frobenius norm of the exact stiffness matrix, $\\|\\mathbf{K}_e\\|_F$. For a non-degenerate element and a physically realistic material (where $\\mathbf{C}$ is positive definite), the stiffness matrix $\\mathbf{K}_e = |\\Omega|\\mathbf{B}^T\\mathbf{C}\\mathbf{B}$ is a non-zero, positive semi-definite matrix. Therefore, its Frobenius norm is strictly positive: $\\|\\mathbf{K}_e\\|_F > 0$.\n\nThe error $R$ is thus:\n$$\nR = \\frac{0}{\\|\\mathbf{K}_e\\|_F} = 0\n$$\nThe explicit values of the nodal coordinates, Young's modulus $E$, and Poisson's ratio $\\nu$ are not necessary to arrive at this conclusion, as the result stems from the fundamental properties of the linear tetrahedral element itself. The one-point integration scheme is exact for this element type.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "Solving the nonlinear algebraic equations that arise in biomechanics simulations requires robust numerical strategies. The Newton-Raphson method provides rapid local convergence but can easily fail if the initial guess is poor or the problem is highly nonlinear. This hands-on coding exercise  moves from theory to practice, guiding you through the implementation of a backtracking line search with an Armijo condition—a crucial globalization strategy used in virtually all modern FEM solvers to ensure convergence by adaptively controlling the step size.",
            "id": "4174359",
            "problem": "You are tasked with implementing a backtracking line-search step length selection based on an Armijo sufficient decrease criterion for a simplified discrete model of myocardial inflation within the Finite Element Method (FEM) framework. The objective is to determine a step length $\\,\\alpha\\,\\in\\,(0,1]$ for a Newton update when the full step $\\,\\alpha = 1\\,$ fails to reduce the residual of the nonlinear equilibrium equations.\n\nStart from the fundamental biomechanical base:\n- Balance of linear momentum (in static equilibrium) yields a nonlinear algebraic residual $\\,\\mathbf{R}(\\mathbf{u}) = \\mathbf{0}\\,$ in a finite-dimensional space after spatial discretization.\n- Newton's method for solving $\\,\\mathbf{R}(\\mathbf{u}) = \\mathbf{0}\\,$ updates the displacement vector $\\,\\mathbf{u}\\,$ by solving the linear system $\\,\\mathbf{J}(\\mathbf{u})\\,\\Delta\\mathbf{u} = -\\mathbf{R}(\\mathbf{u})\\,$, where $\\,\\mathbf{J}(\\mathbf{u}) = \\partial \\mathbf{R}/\\partial \\mathbf{u}\\,$ is the Jacobian matrix.\n- To enhance robustness for strongly nonlinear tissue behavior, use a merit function $\\,\\phi(\\mathbf{u}) = \\tfrac{1}{2}\\|\\mathbf{R}(\\mathbf{u})\\|_2^2\\,$ and an Armijo condition to choose a step length $\\,\\alpha\\,$ that ensures sufficient decrease of $\\,\\phi$.\n\nFor this problem, consider a simplified two-degree-of-freedom discrete model for circumferential myocardial inflation with nonlinear stiffening, defined by the following residual and Jacobian:\n- Discrete displacement vector $\\,\\mathbf{u} = [u_1,\\,u_2]^T\\,$.\n- Residual\n$$\n\\mathbf{R}(\\mathbf{u}) =\n\\begin{bmatrix}\nk_0 u_1 + k_1 u_1^3 + k_c u_2 - p A \\\\\nk_c u_1 + k_0 u_2 + k_1 u_2^3\n\\end{bmatrix},\n$$\nwhere $\\,k_0 > 0\\,$ is the baseline stiffness, $\\,k_1 \\ge 0\\,$ is a nonlinear stiffening coefficient, $\\,k_c\\,$ is an inter-node coupling stiffness, $\\,p \\ge 0\\,$ is an internal pressure load, and $\\,A > 0\\,$ is an inner surface area factor. All quantities are nondimensional; express all results as dimensionless floats.\n- Jacobian\n$$\n\\mathbf{J}(\\mathbf{u}) =\n\\begin{bmatrix}\nk_0 + 3 k_1 u_1^2 & k_c \\\\\nk_c & k_0 + 3 k_1 u_2^2\n\\end{bmatrix}.\n$$\n\nNewton update and Armijo backtracking:\n1. Compute the full Newton step by solving $\\,\\mathbf{J}(\\mathbf{u})\\,\\Delta\\mathbf{u} = -\\mathbf{R}(\\mathbf{u})\\,$.\n2. Define the merit function $\\,\\phi(\\mathbf{u}) = \\tfrac{1}{2}\\|\\mathbf{R}(\\mathbf{u})\\|_2^2\\,$ and use the Armijo condition with parameter $\\,c_1 \\in (0,1)\\,$ and shrinkage factor $\\,\\rho \\in (0,1)\\,$:\n$$\n\\phi(\\mathbf{u} + \\alpha\\,\\Delta\\mathbf{u}) \\le \\phi(\\mathbf{u}) - c_1\\,\\alpha\\,\\|\\mathbf{R}(\\mathbf{u})\\|_2^2.\n$$\n3. Initialize $\\,\\alpha = 1\\,$ and, if the Armijo condition is not satisfied, shrink by $\\,\\alpha \\leftarrow \\rho \\alpha\\,$ and repeat until the condition holds or until $\\,\\alpha < \\alpha_{\\min}\\,$, where $\\,\\alpha_{\\min} > 0\\,$ is a lower bound. If $\\,\\alpha < \\alpha_{\\min}\\,$, return $\\,\\alpha_{\\min}\\,$.\n\nYour program must implement the above for the provided test suite. For each test case, compute and return the accepted step length $\\,\\alpha\\,$ as a dimensionless float.\n\nTest suite parameter sets:\n- Case 1 (happy path, full step accepted): $\\,\\mathbf{u} = [0.05,\\,0.0]\\,$, $\\,k_0 = 10\\,$, $\\,k_1 = 100\\,$, $\\,k_c = 2\\,$, $\\,p = 1.0\\,$, $\\,A = 1.0\\,$, $\\,c_1 = 10^{-4}\\,$, $\\,\\rho = 0.5\\,$, $\\,\\alpha_{\\min} = 10^{-8}\\,$.\n- Case 2 (full step increases residual, strong backtracking required): $\\,\\mathbf{u} = [0.0,\\,0.0]\\,$, $\\,k_0 = 10^{-3}\\,$, $\\,k_1 = 1.0\\,$, $\\,k_c = 0.0\\,$, $\\,p = 0.1\\,$, $\\,A = 1.0\\,$, $\\,c_1 = 10^{-2}\\,$, $\\,\\rho = 0.5\\,$, $\\,\\alpha_{\\min} = 10^{-12}\\,$.\n- Case 3 (full step reduces residual but not sufficiently, moderate backtracking): $\\,\\mathbf{u} = [0.5,\\,0.2]\\,$, $\\,k_0 = 5.0\\,$, $\\,k_1 = 500.0\\,$, $\\,k_c = 1.0\\,$, $\\,p = 2.0\\,$, $\\,A = 1.0\\,$, $\\,c_1 = 0.1\\,$, $\\,\\rho = 0.5\\,$, $\\,\\alpha_{\\min} = 10^{-8}\\,$.\n- Case 4 (near equilibrium, tiny residual, full step accepted): $\\,\\mathbf{u} = [0.05,\\,0.0]\\,$, $\\,k_0 = 10.0\\,$, $\\,k_1 = 100.0\\,$, $\\,k_c = 2.0\\,$, $\\,p = 0.5125\\,$, $\\,A = 1.0\\,$, $\\,c_1 = 10^{-4}\\,$, $\\,\\rho = 0.5\\,$, $\\,\\alpha_{\\min} = 10^{-8}\\,$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, $\\,\\text{[}\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4\\text{]}\\,$ where each $\\,\\alpha_i\\,$ is the accepted dimensionless step length for Case $\\,i\\,$, in the order listed above.",
            "solution": "The problem is valid as it presents a well-posed, scientifically grounded computational task within the domain of biomechanics and finite element analysis. It is self-contained, with all necessary equations, parameters, and conditions provided. The model, while simplified, is based on established principles of continuum mechanics and nonlinear numerical methods.\n\nThe core of the problem is to find an appropriate step length $\\alpha$ for a Newton-Raphson update in solving a nonlinear system of equations, $\\mathbf{R}(\\mathbf{u}) = \\mathbf{0}$, which represents the static equilibrium of a discrete biomechanical model. This is achieved using a backtracking line search governed by the Armijo sufficient decrease condition.\n\nThe procedure for each test case is as follows:\n1.  Define the current state using the provided displacement vector $\\mathbf{u}$ and model parameters $k_0$, $k_1$, $k_c$, $p$, and $A$.\n2.  Calculate the residual vector $\\mathbf{R}(\\mathbf{u})$ at the current displacement $\\mathbf{u}$.\n3.  Calculate the merit function $\\phi(\\mathbf{u}) = \\frac{1}{2}\\|\\mathbf{R}(\\mathbf{u})\\|_2^2$, which quantifies the deviation from equilibrium.\n4.  Calculate the Jacobian matrix $\\mathbf{J}(\\mathbf{u}) = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}}$ at the current displacement $\\mathbf{u}$.\n5.  Solve the linear system of equations $\\mathbf{J}(\\mathbf{u})\\,\\Delta\\mathbf{u} = -\\mathbf{R}(\\mathbf{u})$ to find the Newton search direction $\\Delta\\mathbf{u}$.\n6.  Perform the backtracking line search to find the step length $\\alpha$.\n\nThe backtracking algorithm is initialized with a full step, $\\alpha = 1$. The Armijo condition is checked:\n$$\n\\phi(\\mathbf{u} + \\alpha\\,\\Delta\\mathbf{u}) \\le \\phi(\\mathbf{u}) - c_1\\,\\alpha\\,\\|\\mathbf{R}(\\mathbf{u})\\|_2^2\n$$\n- If the condition is satisfied, $\\alpha=1$ is accepted.\n- If the condition is not satisfied, the step length is reduced by a shrinkage factor $\\rho$, i.e., $\\alpha \\leftarrow \\rho \\alpha$, and the check is repeated. This process continues iteratively until the condition is met or the step length falls below a specified minimum, $\\alpha < \\alpha_{\\min}$. If the loop terminates due to the step length becoming too small, the value $\\alpha_{\\min}$ is returned.\n\nWe will now apply this procedure to each of the four test cases.\n\nLet $\\mathbf{u} = [u_1, u_2]^T$. The residual $\\mathbf{R}(\\mathbf{u})$ and Jacobian $\\mathbf{J}(\\mathbf{u})$ are given by:\n$$\n\\mathbf{R}(\\mathbf{u}) =\n\\begin{bmatrix}\nk_0 u_1 + k_1 u_1^3 + k_c u_2 - p A \\\\\nk_c u_1 + k_0 u_2 + k_1 u_2^3\n\\end{bmatrix}\n$$\n$$\n\\mathbf{J}(\\mathbf{u}) =\n\\begin{bmatrix}\nk_0 + 3 k_1 u_1^2 & k_c \\\\\nk_c & k_0 + 3 k_1 u_2^2\n\\end{bmatrix}\n$$\n\nThe solution is implemented by defining functions for $\\mathbf{R}(\\mathbf{u})$ and $\\mathbf{J}(\\mathbf{u})$, then executing the backtracking algorithm for each parameter set.\n\n**Step-by-step procedure for a single case:**\nLet the current displacement be $\\mathbf{u}_{curr}$ and the corresponding parameters be provided.\n1.  Compute $\\mathbf{R}_{curr} = \\mathbf{R}(\\mathbf{u}_{curr})$.\n2.  Compute the squared L2-norm of the residual, $N_{curr} = \\|\\mathbf{R}_{curr}\\|_2^2$.\n3.  Compute the current merit function value, $\\phi_{curr} = \\frac{1}{2} N_{curr}$.\n4.  Compute $\\mathbf{J}_{curr} = \\mathbf{J}(\\mathbf{u}_{curr})$.\n5.  Solve for the search direction: $\\Delta\\mathbf{u} = -\\mathbf{J}_{curr}^{-1} \\mathbf{R}_{curr}$.\n6.  Initialize step length $\\alpha \\leftarrow 1.0$.\n7.  Start a loop:\n    a. Check if $\\alpha < \\alpha_{\\min}$. If so, set $\\alpha = \\alpha_{\\min}$ and terminate, returning this value.\n    b. Compute the trial displacement: $\\mathbf{u}_{trial} = \\mathbf{u}_{curr} + \\alpha \\Delta\\mathbf{u}$.\n    c. Compute the trial residual $\\mathbf{R}_{trial} = \\mathbf{R}(\\mathbf{u}_{trial})$ and its corresponding merit function value $\\phi_{trial} = \\frac{1}{2}\\|\\mathbf{R}_{trial}\\|_2^2$.\n    d. Check the Armijo condition: $\\phi_{trial} \\le \\phi_{curr} - c_1 \\alpha N_{curr}$.\n    e. If the condition is true, the current $\\alpha$ is the desired step length. Terminate and return $\\alpha$.\n    f. If the condition is false, shrink the step length: $\\alpha \\leftarrow \\rho \\alpha$, and continue the loop from step 7a.\n\nThis algorithm is applied to all four test cases provided in the problem statement to determine the accepted step length for each. The calculations are performed using floating-point arithmetic as implemented in the provided Python code.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the backtracking line-search step length for several test cases\n    of a simplified discrete model of myocardial inflation.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path, full step accepted)\n        {'u': np.array([0.05, 0.0]), 'k0': 10.0, 'k1': 100.0, 'kc': 2.0, \n         'p': 1.0, 'A': 1.0, 'c1': 1e-4, 'rho': 0.5, 'alpha_min': 1e-8},\n        # Case 2 (full step increases residual, strong backtracking required)\n        {'u': np.array([0.0, 0.0]), 'k0': 1e-3, 'k1': 1.0, 'kc': 0.0, \n         'p': 0.1, 'A': 1.0, 'c1': 1e-2, 'rho': 0.5, 'alpha_min': 1e-12},\n        # Case 3 (full step reduces residual but not sufficiently, moderate backtracking)\n        {'u': np.array([0.5, 0.2]), 'k0': 5.0, 'k1': 500.0, 'kc': 1.0, \n         'p': 2.0, 'A': 1.0, 'c1': 0.1, 'rho': 0.5, 'alpha_min': 1e-8},\n        # Case 4 (near equilibrium, tiny residual, full step accepted)\n        {'u': np.array([0.05, 0.0]), 'k0': 10.0, 'k1': 100.0, 'kc': 2.0, \n         'p': 0.5125, 'A': 1.0, 'c1': 1e-4, 'rho': 0.5, 'alpha_min': 1e-8},\n    ]\n\n    results = []\n    for params in test_cases:\n        alpha = find_step_length(**params)\n        results.append(alpha)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_residual(u, k0, k1, kc, p, A):\n    \"\"\"Calculates the residual vector R(u).\"\"\"\n    u1, u2 = u\n    R1 = k0 * u1 + k1 * u1**3 + kc * u2 - p * A\n    R2 = kc * u1 + k0 * u2 + k1 * u2**3\n    return np.array([R1, R2])\n\ndef calculate_jacobian(u, k0, k1, kc):\n    \"\"\"Calculates the Jacobian matrix J(u).\"\"\"\n    u1, u2 = u\n    J11 = k0 + 3 * k1 * u1**2\n    J12 = kc\n    J21 = kc\n    J22 = k0 + 3 * k1 * u2**2\n    return np.array([[J11, J12], [J21, J22]])\n\ndef find_step_length(u, k0, k1, kc, p, A, c1, rho, alpha_min):\n    \"\"\"\n    Implements the backtracking line search with Armijo condition.\n    \"\"\"\n    # 1. Compute current residual and merit function\n    R = calculate_residual(u, k0, k1, kc, p, A)\n    R_norm_sq = np.dot(R, R)\n    phi_u = 0.5 * R_norm_sq\n\n    # If already at equilibrium, any step is fine, a full step is conventional.\n    if np.isclose(R_norm_sq, 0.0):\n        return 1.0\n\n    # 2. Compute Jacobian and Newton step direction\n    J = calculate_jacobian(u, k0, k1, kc)\n    try:\n        delta_u = np.linalg.solve(J, -R)\n    except np.linalg.LinAlgError:\n        # If Jacobian is singular, the Newton step is not well-defined.\n        # This problem's cases are designed to avoid this, but it's good practice.\n        return alpha_min\n\n    # 3. Backtracking line search\n    alpha = 1.0\n    \n    # Armijo condition right-hand side for alpha=1\n    armijo_rhs_base_term = c1 * R_norm_sq\n    \n    while True:\n        # Check if alpha is below the minimum allowed value\n        if alpha  alpha_min:\n            return alpha_min\n        \n        # Calculate trial state and merit function\n        u_trial = u + alpha * delta_u\n        R_trial = calculate_residual(u_trial, k0, k1, kc, p, A)\n        phi_u_trial = 0.5 * np.dot(R_trial, R_trial)\n        \n        # Check Armijo sufficient decrease condition\n        armijo_rhs = phi_u - alpha * armijo_rhs_base_term\n        \n        if phi_u_trial = armijo_rhs:\n            return alpha\n        \n        # Shrink step length\n        alpha *= rho\n        \nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}