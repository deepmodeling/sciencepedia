{
    "hands_on_practices": [
        {
            "introduction": "在构建任何三维生物力学模型时，精确表示身体节段的姿态是至关重要的一步。本练习将深入探讨轴-角表示法（即指数坐标）与相应旋转矩阵之间的优美关系。通过从第一性原理推导罗德里格斯（Rodrigues）旋转公式 ，您将更深刻地理解特殊正交群 $SO(3)$ 的基础数学，并体会到小角度近似在数值模拟中的实际意义。",
            "id": "4193035",
            "problem": "在人体步态模型中，一个下肢节段被视为一个刚体，其方位使用旋转的指数坐标随时间演化。设 $\\hat{u} \\in \\mathbb{R}^{3}$ 是一个描述瞬时旋转轴（例如，由惯性测量单元(IMU)测量的膝关节屈伸轴）的单位向量，并设 $\\theta \\in \\mathbb{R}$ 是以弧度为单位的相应右手系旋转角。对于任意 $v \\in \\mathbb{R}^{3}$，通过性质 $[\\hat{u}]_{\\times} v = \\hat{u} \\times v$ 定义斜对称叉积矩阵 $[\\hat{u}]_{\\times} \\in \\mathbb{R}^{3 \\times 3}$。与 $(\\hat{u}, \\theta)$ 相关的刚体旋转由矩阵指数 $R(\\hat{u},\\theta) = \\exp\\!\\big(\\theta\\,[\\hat{u}]_{\\times}\\big) \\in \\mathbb{R}^{3 \\times 3}$ 表示。\n\n仅从矩阵指数的定义和向量三重积恒等式出发，执行以下操作：\n\n1. 推导 $R(\\hat{u},\\theta)$ 的一个闭式表达式，该表达式用 $\\hat{u}$、$\\theta$ 和基本三角函数表示，且不引用任何预先给定的闭式旋转公式。\n\n2. 当 $\\theta \\to 0$ 时，通过系统地截断相关函数的级数展开，获得 $R(\\hat{u},\\theta)$ 的一阶小角度近似，并明确指出近似误差 $E(\\hat{u},\\theta) := R(\\hat{u},\\theta) - \\big(I + \\theta\\,[\\hat{u}]_{\\times}\\big)$ 的主阶项。\n\n3. 为了量化小角度近似对节段方位更新中数值稳定性的影响，求无量纲常数\n$$\nC \\;=\\; \\lim_{\\theta \\to 0} \\frac{\\big\\|\\,R(\\hat{u},\\theta) - \\big(I + \\theta\\,[\\hat{u}]_{\\times}\\big)\\,\\big\\|_{F}}{\\theta^{2}},\n$$\n其中 $\\|\\cdot\\|_{F}$ 表示弗罗贝尼乌斯范数。您的推导必须明确 $C$ 是否依赖于 $\\hat{u}$。\n\n请以简化的闭式形式提供 $C$ 的精确值。角度以弧度表示。$C$ 的最终值是无量纲的。不要四舍五入；请提供精确表达式。",
            "solution": "该问题要求一个关于旋转的指数映射表示的三部分推导。过程首先要验证问题陈述，基于应用于生物力学的刚体运动学和李群理论的基本原理，该问题陈述在科学上是合理的、适定的和客观的。\n\n**第一部分：$R(\\hat{u},\\theta)$ 闭式表达式的推导**\n\n旋转矩阵 $R(\\hat{u},\\theta)$ 由矩阵指数 $R(\\hat{u},\\theta) = \\exp(\\theta\\,[\\hat{u}]_{\\times})$ 定义，其中 $\\hat{u}$ 是单位向量，$[\\hat{u}]_{\\times}$ 是对应的斜对称矩阵。推导从矩阵指数的泰勒级数展开开始：\n$$\nR(\\hat{u},\\theta) = \\sum_{k=0}^{\\infty} \\frac{(\\theta\\,[\\hat{u}]_{\\times})^{k}}{k!} = I + \\theta\\,[\\hat{u}]_{\\times} + \\frac{\\theta^{2}}{2!}[\\hat{u}]_{\\times}^{2} + \\frac{\\theta^{3}}{3!}[\\hat{u}]_{\\times}^{3} + \\dots\n$$\n为了找到闭式解，我们研究矩阵 $K = [\\hat{u}]_{\\times}$ 的幂。对于任意向量 $v \\in \\mathbb{R}^{3}$，$K^{2}$ 的作用是：\n$$\nK^{2}v = [\\hat{u}]_{\\times}([\\hat{u}]_{\\times}v) = \\hat{u} \\times (\\hat{u} \\times v)\n$$\n使用向量三重积恒等式 $a \\times (b \\times c) = b(a \\cdot c) - c(a \\cdot b)$，我们得到：\n$$\n\\hat{u} \\times (\\hat{u} \\times v) = \\hat{u}(\\hat{u} \\cdot v) - v(\\hat{u} \\cdot \\hat{u})\n$$\n由于 $\\hat{u}$ 是单位向量，$\\hat{u} \\cdot \\hat{u} = \\|\\hat{u}\\|^{2} = 1$。项 $\\hat{u}(\\hat{u} \\cdot v)$ 可以写成矩阵形式 $(\\hat{u}\\hat{u}^{T})v$。因此：\n$$\nK^{2}v = (\\hat{u}\\hat{u}^{T})v - v = (\\hat{u}\\hat{u}^{T} - I)v\n$$\n由于这对任意 $v \\in \\mathbb{R}^{3}$ 都成立，我们得到矩阵恒等式：\n$$\n[\\hat{u}]_{\\times}^{2} = \\hat{u}\\hat{u}^{T} - I\n$$\n接下来，我们计算三次方：\n$$\n[\\hat{u}]_{\\times}^{3} = [\\hat{u}]_{\\times}[\\hat{u}]_{\\times}^{2} = [\\hat{u}]_{\\times}(\\hat{u}\\hat{u}^{T} - I) = [\\hat{u}]_{\\times}(\\hat{u}\\hat{u}^{T}) - [\\hat{u}]_{\\times}\n$$\n第一项 $[\\hat{u}]_{\\times}(\\hat{u}\\hat{u}^{T})$ 作用于向量 $v$ 得到 $\\hat{u} \\times (\\hat{u}(\\hat{u} \\cdot v)) = (\\hat{u} \\cdot v)(\\hat{u} \\times \\hat{u})$。由于 $\\hat{u} \\times \\hat{u} = 0$，该项为零矩阵。因此：\n$$\n[\\hat{u}]_{\\times}^{3} = -[\\hat{u}]_{\\times}\n$$\n这个结果为更高次的幂建立了一个循环模式：$[\\hat{u}]_{\\times}^{4} = -[\\hat{u}]_{\\times}^{2}$，$[\\hat{u}]_{\\times}^{5} = -[\\hat{u}]_{\\times}^{3} = [\\hat{u}]_{\\times}$，以此类推。我们现在可以对级数展开中的项进行分组：\n$$\nR(\\hat{u},\\theta) = I + \\left(\\theta[\\hat{u}]_\\times - \\frac{\\theta^3}{3!} [\\hat{u}]_\\times + \\frac{\\theta^5}{5!} [\\hat{u}]_\\times - \\dots\\right) + \\left(\\frac{\\theta^2}{2!} [\\hat{u}]_\\times^2 - \\frac{\\theta^4}{4!} [\\hat{u}]_\\times^2 + \\frac{\\theta^6}{6!} [\\hat{u}]_\\times^2 - \\dots\\right)\n$$\n将常数矩阵 $[\\hat{u}]_{\\times}$ 和 $[\\hat{u}]_{\\times}^{2}$ 提取出来：\n$$\nR(\\hat{u},\\theta) = I + \\left(\\theta - \\frac{\\theta^{3}}{3!} + \\frac{\\theta^{5}}{5!} - \\dots \\right)[\\hat{u}]_{\\times} + \\left(\\frac{\\theta^{2}}{2!} - \\frac{\\theta^{4}}{4!} + \\frac{\\theta^{6}}{6!} - \\dots \\right)[\\hat{u}]_{\\times}^{2}\n$$\n括号中的级数分别是 $\\sin(\\theta)$ 和 $1-\\cos(\\theta)$ 的泰勒级数。\n$$\n\\sin(\\theta) = \\sum_{k=0}^{\\infty} \\frac{(-1)^{k}\\theta^{2k+1}}{(2k+1)!} \\quad \\text{和} \\quad 1-\\cos(\\theta) = \\sum_{k=1}^{\\infty} \\frac{(-1)^{k-1}\\theta^{2k}}{(2k)!}\n$$\n将这些代入 $R(\\hat{u},\\theta)$ 的表达式中，得到著名的罗德里格斯旋转公式：\n$$\nR(\\hat{u},\\theta) = I + \\sin(\\theta)[\\hat{u}]_{\\times} + (1-\\cos(\\theta))[\\hat{u}]_{\\times}^{2}\n$$\n\n**第二部分：小角度近似与主阶误差项**\n\n问题将一阶小角度近似定义为 $I + \\theta\\,[\\hat{u}]_{\\times}$。近似误差为 $E(\\hat{u},\\theta) = R(\\hat{u},\\theta) - (I + \\theta\\,[\\hat{u}]_{\\times})$。使用第一部分的结果：\n$$\nE(\\hat{u},\\theta) = \\big(I + \\sin(\\theta)[\\hat{u}]_{\\times} + (1-\\cos(\\theta))[\\hat{u}]_{\\times}^{2}\\big) - (I + \\theta\\,[\\hat{u}]_{\\times})\n$$\n$$\nE(\\hat{u},\\theta) = (\\sin(\\theta) - \\theta)[\\hat{u}]_{\\times} + (1-\\cos(\\theta))[\\hat{u}]_{\\times}^{2}\n$$\n为了找到当 $\\theta \\to 0$ 时误差的主阶项，我们使用三角函数在 $\\theta=0$ 附近的泰勒级数展开：\n$$\n\\sin(\\theta) = \\theta - \\frac{\\theta^{3}}{6} + O(\\theta^{5}) \\implies \\sin(\\theta) - \\theta = -\\frac{\\theta^{3}}{6} + O(\\theta^{5})\n$$\n$$\n\\cos(\\theta) = 1 - \\frac{\\theta^{2}}{2} + \\frac{\\theta^{4}}{24} + O(\\theta^{6}) \\implies 1 - \\cos(\\theta) = \\frac{\\theta^{2}}{2} - \\frac{\\theta^{4}}{24} + O(\\theta^{6})\n$$\n将这些代入 $E(\\hat{u},\\theta)$ 的表达式中：\n$$\nE(\\hat{u},\\theta) = \\left(-\\frac{\\theta^{3}}{6} + O(\\theta^{5})\\right)[\\hat{u}]_{\\times} + \\left(\\frac{\\theta^{2}}{2} + O(\\theta^{4})\\right)[\\hat{u}]_{\\times}^{2}\n$$\n主阶项是 $\\theta$ 的最低次幂项，即与 $\\theta^{2}$ 成正比的项。因此，主阶误差项是：\n$$\nE_{\\text{leading}}(\\hat{u},\\theta) = \\frac{\\theta^{2}}{2}[\\hat{u}]_{\\times}^{2}\n$$\n\n**第三部分：常数 $C$ 的求值**\n\n常数 $C$ 由以下极限定义：\n$$\nC = \\lim_{\\theta \\to 0} \\frac{\\big\\|R(\\hat{u},\\theta) - \\big(I + \\theta\\,[\\hat{u}]_{\\times}\\big)\\big\\|_{F}}{\\theta^{2}} = \\lim_{\\theta \\to 0} \\frac{\\|E(\\hat{u},\\theta)\\|_{F}}{\\theta^{2}}\n$$\n使用第二部分中误差项的展开式：\n$$\nC = \\lim_{\\theta \\to 0} \\frac{\\left\\| \\frac{\\theta^{2}}{2}[\\hat{u}]_{\\times}^{2} - \\frac{\\theta^{3}}{6}[\\hat{u}]_{\\times} + O(\\theta^{4}) \\right\\|_{F}}{\\theta^{2}}\n$$\n根据范数的齐次性 $\\|\\alpha A\\|_{F} = |\\alpha|\\|A\\|_{F}$，我们可以提出因子 $\\theta^{2}$ (因为 $\\theta^{2} \\ge 0$)：\n$$\nC = \\lim_{\\theta \\to 0} \\frac{\\theta^{2} \\left\\| \\frac{1}{2}[\\hat{u}]_{\\times}^{2} - \\frac{\\theta}{6}[\\hat{u}]_{\\times} + O(\\theta^{2}) \\right\\|_{F}}{\\theta^{2}} = \\lim_{\\theta \\to 0} \\left\\| \\frac{1}{2}[\\hat{u}]_{\\times}^{2} - \\frac{\\theta}{6}[\\hat{u}]_{\\times} + O(\\theta^{2}) \\right\\|_{F}\n$$\n弗罗贝尼乌斯范数是其矩阵元素的连续函数，而这些元素在 $\\theta$ 上是连续的。因此我们可以将极限移到范数内部：\n$$\nC = \\left\\| \\lim_{\\theta \\to 0} \\left(\\frac{1}{2}[\\hat{u}]_{\\times}^{2} - \\frac{\\theta}{6}[\\hat{u}]_{\\times} + O(\\theta^{2})\\right) \\right\\|_{F} = \\left\\| \\frac{1}{2}[\\hat{u}]_{\\times}^{2} \\right\\|_{F} = \\frac{1}{2} \\|[\\hat{u}]_{\\times}^{2}\\|_{F}\n$$\n为了计算 $\\|[\\hat{u}]_{\\times}^{2}\\|_{F}$，我们使用性质 $\\|A\\|_{F}^{2} = \\text{tr}(A^{T}A)$。矩阵 $[\\hat{u}]_{\\times}^{2}$ 是对称的，所以 $([\\hat{u}]_{\\times}^{2})^{T} = [\\hat{u}]_{\\times}^{2}$。\n$$\n\\|[\\hat{u}]_{\\times}^{2}\\|_{F}^{2} = \\text{tr}\\big(([\\hat{u}]_{\\times}^{2})^{T}[\\hat{u}]_{\\times}^{2}\\big) = \\text{tr}\\big(([\\hat{u}]_{\\times}^{2})^{2}\\big) = \\text{tr}([\\hat{u}]_{\\times}^{4})\n$$\n使用关系 $[\\hat{u}]_{\\times}^{4} = -[\\hat{u}]_{\\times}^{2}$：\n$$\n\\|[\\hat{u}]_{\\times}^{2}\\|_{F}^{2} = \\text{tr}(-[\\hat{u}]_{\\times}^{2}) = -\\text{tr}([\\hat{u}]_{\\times}^{2})\n$$\n我们代入恒等式 $[\\hat{u}]_{\\times}^{2} = \\hat{u}\\hat{u}^{T} - I$：\n$$\n\\text{tr}([\\hat{u}]_{\\times}^{2}) = \\text{tr}(\\hat{u}\\hat{u}^{T} - I) = \\text{tr}(\\hat{u}\\hat{u}^{T}) - \\text{tr}(I)\n$$\n使用迹的循环性质，$\\text{tr}(\\hat{u}\\hat{u}^{T}) = \\text{tr}(\\hat{u}^{T}\\hat{u}) = \\hat{u}^{T}\\hat{u} = \\|\\hat{u}\\|^{2} = 1$。$3 \\times 3$ 单位矩阵的迹是 $\\text{tr}(I)=3$。\n$$\n\\text{tr}([\\hat{u}]_{\\times}^{2}) = 1-3 = -2\n$$\n因此，弗罗贝尼乌斯范数的平方为：\n$$\n\\|[\\hat{u}]_{\\times}^{2}\\|_{F}^{2} = -(-2) = 2\n$$\n这得出 $\\|[\\hat{u}]_{\\times}^{2}\\|_{F} = \\sqrt{2}$。重要的是，这个值与单位向量 $\\hat{u}$ 的选择无关。\n最后，我们将这个值代回 $C$ 的表达式中：\n$$\nC = \\frac{1}{2} \\|[\\hat{u}]_{\\times}^{2}\\|_{F} = \\frac{1}{2}\\sqrt{2} = \\frac{\\sqrt{2}}{2}\n$$",
            "answer": "$$\\boxed{\\frac{\\sqrt{2}}{2}}$$"
        },
        {
            "introduction": "在掌握单个节段的运动学基础之上，本练习将问题扩展至完整的人体模型。重点将转向理解系统与环境的相互作用（例如足-地接触）如何约束其运动。通过确定双足支撑期的自由度（Degrees of Freedom, DOFs）减少量 ，您将学会应用雅可比矩阵（Jacobian matrix）的概念来分析和量化运动学约束，这是进行逆动力学和正动力学分析的一项关键技能。",
            "id": "4193025",
            "problem": "考虑一个三维自由漂浮的人体多体模型，其中广义坐标向量 $q \\in \\mathbb{R}^{n+6}$ 包括一个用于骨盆的六维自由基座（三个平移分量和三个旋转分量）和 $n$ 个内部关节坐标。内部关节如下：双侧髋关节，各含 $3$ 个旋转分量（共 $6$ 个）；双侧膝关节，各含 $1$ 个旋转分量（共 $2$ 个）；双侧踝关节，各含 $2$ 个旋转分量（共 $4$ 个）；一个腰椎关节，含 $3$ 个旋转分量（共 $3$ 个）；一个颈椎关节，含 $3$ 个旋转分量（共 $3$ 个）；双侧肩关节，各含 $3$ 个旋转分量（共 $6$ 个）；双侧肘关节，各含 $1$ 个旋转分量（共 $2$ 个）；以及双侧腕关节，各含 $2$ 个旋转分量（共 $4$ 个）。假设关节是理想且无摩擦的，并且连杆是刚性的。\n\n在水平刚性地面上的双足支撑站立阶段，左脚和右脚坐标系 $F_{L}$ 和 $F_{R}$ 均与地面保持刚性、静止、不滑动、不滚动的接触，因此每只脚相对于惯性地面坐标系的空间位置和空间姿态随时间保持恒定。令 $\\boldsymbol{\\phi}_{L}(q)$ 和 $\\boldsymbol{\\phi}_{R}(q)$ 分别表示左脚和右脚的完整接触约束，每个约束都包含三个平移和三个旋转约束，用于固定相应足部的姿态。对这些约束关于时间求导，得到速度层面的线性约束\n$$\n\\mathbf{J}_{L}(q)\\,\\dot{q} = \\mathbf{0}, \\qquad \\mathbf{J}_{R}(q)\\,\\dot{q} = \\mathbf{0},\n$$\n其中 $\\mathbf{J}_{L}(q) \\in \\mathbb{R}^{6 \\times (n+6)}$ 和 $\\mathbf{J}_{R}(q) \\in \\mathbb{R}^{6 \\times (n+6)}$ 是足部空间速度雅可比矩阵。定义组合接触约束雅可比矩阵\n$$\n\\mathbf{J}_{c}(q) \\coloneqq \\begin{bmatrix} \\mathbf{J}_{L}(q) \\\\ \\mathbf{J}_{R}(q) \\end{bmatrix} \\in \\mathbb{R}^{12 \\times (n+6)}.\n$$\n\n假设处于一个通用的、非奇异的站立构型，其中双腿均不处于运动学奇异状态，两个足部坐标系不同且不重合，并且地面是刚性、水平且惯性的。通过计算组合接触约束雅可比矩阵 $\\mathbf{J}_{c}(q)$ 的秩，确定相对于开链模型独立自由度 (DOF) 数量的减少量。将你的最终答案表示为一个无单位整数。无需四舍五入。",
            "solution": "问题要求计算在双足支撑阶段，人体多体模型的独立自由度 (DOF) 数量的减少量。这个减少量等于施加于系统的独立约束的数量，而后者可以通过求解组合接触约束雅可比矩阵 $\\mathbf{J}_{c}(q)$ 的秩来确定。\n\n首先，我们确定自由漂浮的开链模型的广义坐标总数。广义坐标向量 $q$ 有 $n+6$ 个分量，其中 $6$ 对应于骨盆的自由漂浮基座，$n$ 是内部关节坐标的数量。$n$ 的值是所有内部关节自由度 (DOF) 的总和：\n- 双侧髋关节：$2 \\times 3 = 6$ 个自由度\n- 双侧膝关节：$2 \\times 1 = 2$ 个自由度\n- 双侧踝关节：$2 \\times 2 = 4$ 个自由度\n- 腰椎关节：$3$ 个自由度\n- 颈椎关节：$3$ 个自由度\n- 双侧肩关节：$2 \\times 3 = 6$ 个自由度\n- 双侧肘关节：$2 \\times 1 = 2$ 个自由度\n- 双侧腕关节：$2 \\times 2 = 4$ 个自由度\n\n将这些相加得到内部自由度的总数：\n$$n = 6 + 2 + 4 + 3 + 3 + 6 + 2 + 4 = 30$$\n因此，无约束的开链系统的总自由度数为 $N_{open} = n + 6 = 30 + 6 = 36$。广义坐标向量为 $q \\in \\mathbb{R}^{36}$。\n\n由于双脚与地面保持静止接触，系统受到完整约束。这些约束在速度层面表示为 $\\mathbf{J}_{c}(q)\\,\\dot{q} = \\mathbf{0}$，其中 $\\mathbf{J}_{c}(q) \\in \\mathbb{R}^{12 \\times 36}$ 是组合雅可比矩阵：\n$$\n\\mathbf{J}_{c}(q) = \\begin{bmatrix} \\mathbf{J}_{L}(q) \\\\ \\mathbf{J}_{R}(q) \\end{bmatrix}\n$$\n此处，$\\mathbf{J}_{L}(q) \\in \\mathbb{R}^{6 \\times 36}$ 和 $\\mathbf{J}_{R}(q) \\in \\mathbb{R}^{6 \\times 36}$ 分别是左脚和右脚的雅可比矩阵。每个雅可比矩阵将系统的广义速度 $\\dot{q}$ 映射到相应足部的 6 维空间速度。\n\n独立约束的数量等于 $\\mathbf{J}_{c}(q)$ 的秩。分块矩阵的秩由以下公式给出：\n$$\n\\text{rank}(\\mathbf{J}_{c}) = \\text{rank}(\\mathbf{J}_{L}) + \\text{rank}(\\mathbf{J}_{R}) - \\dim(\\mathcal{R}(\\mathbf{J}_{L}^T) \\cap \\mathcal{R}(\\mathbf{J}_{R}^T))\n$$\n其中 $\\mathcal{R}(\\mathbf{A}^T)$ 表示矩阵 $\\mathbf{A}$ 的行空间。\n\n我们首先确定单个足部雅可比矩阵的秩，例如 $\\mathbf{J}_{L}(q)$。该矩阵表示从 36 维广义速度空间到左脚 6 维空间速度空间的线性变换。问题陈述系统处于“非奇异站立构型”且“双腿均不处于运动学奇异状态”。这意味着从骨盆到足部的运动链不处于奇异位姿。考虑到整个身体模型具有大量的自由度（36个），可以控制足部的 6 个自由度以实现任意的空间速度。例如，可以协调骨盆、髋、膝和踝关节的运动，以产生足部任何期望的平移和旋转。因此，由 $\\mathbf{J}_{L}(q)$ 定义的映射是满射的，其像是整个 6 维空间速度空间。因此，该雅可比矩阵的秩为 $6$。\n$$\n\\text{rank}(\\mathbf{J}_{L}(q)) = 6\n$$\n同理可得，右脚雅可比矩阵的秩也为 $6$：\n$$\n\\text{rank}(\\mathbf{J}_{R}(q)) = 6\n$$\n\n接下来，我们必须确定 $\\mathbf{J}_{L}$ 和 $\\mathbf{J}_{R}$ 行空间交集的维数。$\\mathbf{J}_{L}$ 和 $\\mathbf{J}_{R}$ 的行是线性无关的，当且仅当固定左脚所施加的约束与固定右脚所施加的约束是相互独立的。\n从物理上讲，这意味着即使一只脚被固定，另一只脚仍然可以以 6 个自由度运动。让我们考虑左脚固定在地面上。连接左脚和右脚的运动链经过左腿、骨盆和右腿。该链中的关节有：左踝（2个自由度）、左膝（1个自由度）、左髋（3个自由度）、右髋（3个自由度）、右膝（1个自由度）和右踝（2个自由度）。该链中的总自由度数为 $2+1+3+3+1+2=12$。\n这个 12 自由度的运动链的任务是控制右脚相对于固定的左脚的 6 自由度位姿。问题指明了“通用的、非奇异的站姿”以及“足部坐标系不同且不重合”。这确保了该 12 自由度链不处于会妨碍其在末端执行器（右脚）处产生任意 6 自由度运动的奇异构型中。\n既然在左脚静止时，右脚能够以完整的 6 自由度运动，那么对右脚速度的约束就独立于对左脚速度的约束。这意味着 $\\mathbf{J}_{L}(q)$ 的行向量与 $\\mathbf{J}_{R}(q)$ 的行向量线性无关。它们的行空间的交集只包含零向量。\n$$\n\\dim(\\mathcal{R}(\\mathbf{J}_{L}^T) \\cap \\mathcal{R}(\\mathbf{J}_{R}^T)) = 0\n$$\n\n因此，组合雅可比矩阵的秩是各个秩的和：\n$$\n\\text{rank}(\\mathbf{J}_{c}(q)) = \\text{rank}(\\mathbf{J}_{L}(q)) + \\text{rank}(\\mathbf{J}_{R}(q)) = 6 + 6 = 12\n$$\n\n组合约束雅可比矩阵的秩为 $12$。这意味着双足支撑接触对系统施加了 $12$ 个独立的完整约束。自由度数量的减少量等于这个数字。受约束系统的自由度数为 $N_{constrained} = N_{open} - \\text{rank}(\\mathbf{J}_{c}) = 36 - 12 = 24$。\n问题要求的是自由度数量的减少量，即 $\\text{rank}(\\mathbf{J}_{c}(q))$。",
            "answer": "$$\n\\boxed{12}\n$$"
        },
        {
            "introduction": "当系统的运动学和约束被定义后，下一个挑战便是通过求解运动方程来模拟其动态过程。本编码练习将探讨两种基本的数值积分方案：显式欧拉法和隐式欧拉法。通过为一个简单的摆体模型实现这些方法并分析它们对能量守恒的影响 ，您将直观地洞察在动力学仿真中，计算简便性、数值稳定性与物理真实性之间的关键权衡。",
            "id": "4192970",
            "problem": "考虑一个平面、均匀的刚性摆段，它代表一个单个人体肢段（例如小腿），在重力作用下绕一个无摩擦的铰链转动，无任何驱动。设质量为 $m$（单位：千克），长度为 $L$（单位：米），恒定重力加速度为 $g = 9.81$（单位：米每平方秒）。设广义坐标为角度 $\\theta$（单位：弧度），从垂直向下方向开始测量，逆时针旋转为正方向。角速度为 $\\dot{\\theta}$（单位：弧度每秒）。在这些假设下，根据旋转运动的 Newton 第二定律，并在无外部驱动力矩的情况下，可得到如下常微分方程（ODE）：\n$$ m L^2 \\, \\ddot{\\theta} = - m g L \\, \\sin(\\theta), $$\n或等价地\n$$ \\ddot{\\theta} = - \\frac{g}{L} \\, \\sin(\\theta). $$\n摆的总机械能 $E$ 是动能和重力势能之和，由下式给出：\n$$ E(\\theta, \\dot{\\theta}) = \\tfrac{1}{2} \\, m L^2 \\, \\dot{\\theta}^2 + m g L \\, (1 - \\cos(\\theta)). $$\n对于这个无源保守系统，其精确的连续时间动力学过程保持总机械能守恒，因此任何对恒定值 $E$ 的偏离都完全是由数值时间积分误差引起的。\n\n你的任务是为上述 ODE 实现两种单步数值时间积分方案：显式前向欧拉方案和隐式后向欧拉方案，两者都应用于一阶状态 $[\\theta, \\dot{\\theta}]$。显式前向欧拉方案使用当前状态来推进 $[\\theta, \\dot{\\theta}]$。隐式后向欧拉方案通过使用在下一状态下评估的加速度来计算下一状态；这需要在新的时间步为 $\\theta$ 求解一个标量非线性方程。使用 Newton 法和一个合理的初始猜测来求解关于 $\\theta$ 的隐式方程，然后相应地更新 $\\dot{\\theta}$。\n\n将模拟步态周期的持续时间 $T_\\mathrm{c}$ 定义为小角度线性化摆的周期：\n$$ T_\\mathrm{c} = 2 \\pi \\sqrt{\\frac{L}{g}}, $$\n这是对近小振幅被动摆动的一个科学标准近似，在此作为一个一致的参考持续时间。对于每次模拟，将状态推进 $N = \\lceil T_\\mathrm{c} / \\Delta t \\rceil$ 个时间步，每个时间步的大小为 $\\Delta t$ 秒。角度单位必须是弧度，长度单位是米，质量单位是千克，时间单位是秒。\n\n对于每种方案和每个测试用例，计算模拟步态周期内以下两种能量行为的定量度量：\n- 周期内的最大相对能量偏差，\n$$ \\varepsilon_\\mathrm{max} = \\max_{0 \\le k \\le N} \\left| \\frac{E_k - E_0}{E_0} \\right|, $$\n其中 $E_k$ 是 $k$ 步后的能量，$E_0$ 是初始能量。\n- 周期结束时的有符号相对能量漂移，\n$$ \\varepsilon_\\mathrm{end} = \\frac{E_N - E_0}{E_0}. $$\n\n实现一个可运行的程序，使用以下测试套件。在所有情况下，角度使用弧度，时间使用秒：\n1. $m = 10.0$, $L = 1.0$, $\\theta_0 = 0.2$, $\\dot{\\theta}_0 = 0.0$, $\\Delta t = 0.005$。\n2. $m = 50.0$, $L = 0.9$, $\\theta_0 = 1.0$, $\\dot{\\theta}_0 = 0.0$, $\\Delta t = 0.02$。\n3. $m = 5.0$, $L = 1.2$, $\\theta_0 = 0.01$, $\\dot{\\theta}_0 = 0.0$, $\\Delta t = 0.0005$。\n4. $m = 70.0$, $L = 1.0$, $\\theta_0 = 0.6$, $\\dot{\\theta}_0 = 0.3$, $\\Delta t = 0.01$。\n\n您的程序必须为每个测试用例，使用两种积分器模拟一个参考步态周期内的摆动，为每种方案计算 $\\varepsilon_\\mathrm{max}$ 和 $\\varepsilon_\\mathrm{end}$，并生成一行输出，其中包含结果，格式为逗号分隔的列表之列表，每个测试用例的结果按以下顺序排列：\n$[\\varepsilon_\\mathrm{max}^{\\mathrm{exp}}, \\varepsilon_\\mathrm{max}^{\\mathrm{imp}}, \\varepsilon_\\mathrm{end}^{\\mathrm{exp}}, \\varepsilon_\\mathrm{end}^{\\mathrm{imp}}]$。\n所有值必须是四舍五入到六位小数的十进制数。最终打印的输出必须采用以下形式：\n$$ [ [a_1, b_1, c_1, d_1], [a_2, b_2, c_2, d_2], [a_3, b_3, c_3, d_3], [a_4, b_4, c_4, d_4] ] $$\n不含任何附加文本。确保隐式求解器的数值鲁棒性以及所有参数和计算的科学真实性。",
            "solution": "该问题要求实现并比较两种数值积分方案——显式前向欧拉和隐式后向欧拉，用于模拟单摆的动力学。摆的运动由一个二阶常微分方程（ODE）描述，为了进行积分，必须首先将其转换为一个由两个一阶 ODE 组成的系统。\n\n摆在任意时刻 $t$ 的状态可以用一个状态向量 $y(t) = [\\theta(t), \\omega(t)]^T$ 来描述，其中 $\\theta(t)$ 是角度，$\\omega(t) = \\dot{\\theta}(t)$ 是角速度。给定的二阶 ODE 是 $\\ddot{\\theta} = - \\frac{g}{L} \\sin(\\theta)$。我们可以将其表示为一阶系统 $\\dot{y} = f(y)$：\n$$\n\\frac{d}{dt}\n\\begin{pmatrix} \\theta \\\\ \\omega \\end{pmatrix}\n=\n\\begin{pmatrix} \\omega \\\\ -\\frac{g}{L} \\sin(\\theta) \\end{pmatrix}\n= f(\\theta, \\omega)\n$$\n我们将从初始状态 $y_0 = [\\theta_0, \\omega_0]^T$ 开始，通过一系列大小为 $\\Delta t$ 的时间步对该系统进行数值积分。设 $y_k = [\\theta_k, \\omega_k]^T$ 表示在时间 $t_k = k \\Delta t$ 时的状态。\n\n显式前向欧拉法是一种一阶显式积分方案。它使用在当前状态 $y_k$ 下评估的导数来计算下一时间步的状态 $y_{k+1}$。其更新规则为：\n$$\ny_{k+1} = y_k + \\Delta t \\cdot f(y_k)\n$$\n以分量形式，这可转化为：\n$$\n\\theta_{k+1} = \\theta_k + \\Delta t \\cdot \\omega_k\n$$\n$$\n\\omega_{k+1} = \\omega_k - \\Delta t \\cdot \\frac{g}{L} \\sin(\\theta_k)\n$$\n该方案易于实现，因为每个新的状态变量都是直接从前一个状态计算得出的。\n\n隐式后向欧拉法是一种一阶隐式积分方案。它使用在下一时间步（未知的）状态 $y_{k+1}$ 下评估的导数来计算该状态。其更新规则为：\n$$\ny_{k+1} = y_k + \\Delta t \\cdot f(y_{k+1})\n$$\n以分量形式，这会得到一个关于未知状态 $[\\theta_{k+1}, \\omega_{k+1}]$ 的耦合方程组：\n$$\n\\theta_{k+1} = \\theta_k + \\Delta t \\cdot \\omega_{k+1} \\quad (1)\n$$\n$$\n\\omega_{k+1} = \\omega_k - \\Delta t \\cdot \\frac{g}{L} \\sin(\\theta_{k+1}) \\quad (2)\n$$\n为了求解该方程组，我们可以代入 $\\omega_{k+1}$，从而得到一个关于 $\\theta_{k+1}$ 的单一非线性代数方程。从方程(1)中，我们可得 $\\omega_{k+1} = (\\theta_{k+1} - \\theta_k) / \\Delta t$。将其代入方程(2)可得：\n$$\n\\frac{\\theta_{k+1} - \\theta_k}{\\Delta t} = \\omega_k - \\frac{g \\Delta t}{L} \\sin(\\theta_{k+1})\n$$\n重新整理该方程可以得到一个关于 $\\theta_{k+1}$ 的求根问题。令 $\\theta_{\\text{new}} \\equiv \\theta_{k+1}$。我们必须找到函数 $F(\\theta_{\\text{new}})$ 的根：\n$$\nF(\\theta_{\\text{new}}) = \\theta_{\\text{new}} - \\theta_k - \\Delta t \\cdot \\omega_k + \\frac{g (\\Delta t)^2}{L} \\sin(\\theta_{\\text{new}}) = 0\n$$\n按照规定，我们使用 Newton 法来求解此方程。变量 $z$ 的迭代更新公式为 $z_{j+1} = z_j - F(z_j)/F'(z_j)$。$F$ 关于 $\\theta_{\\text{new}}$ 的导数为：\n$$\nF'(\\theta_{\\text{new}}) = 1 + \\frac{g (\\Delta t)^2}{L} \\cos(\\theta_{\\text{new}})\n$$\n一个合理的迭代初始猜测是来自显式欧拉步的结果，$z_0 = \\theta_k + \\Delta t \\cdot \\omega_k$。迭代过程持续进行，直到 $\\theta_{\\text{new}}$ 的连续估计值之间的变化小于一个小的容差。一旦找到 $\\theta_{k+1}$ 的收敛值，就可以通过方程 $(1)$ 以代数方式计算出 $\\omega_{k+1}$：$\\omega_{k+1} = (\\theta_{k+1} - \\theta_k) / \\Delta t$。\n\n对于每个测试用例，模拟运行的持续时间由线性化的小角度摆周期定义，$T_c = 2 \\pi \\sqrt{L/g}$。步数为 $N = \\lceil T_c / \\Delta t \\rceil$。状态从 $k=0$ 到 $k=N$ 推进 $N$ 步。\n\n在两种方案模拟的每一步 $k$ 中，总机械能使用以下公式计算：\n$$\nE_k = \\frac{1}{2} m L^2 \\omega_k^2 + m g L (1 - \\cos(\\theta_k))\n$$\n初始能量为 $E_0 = E(\\theta_0, \\dot{\\theta}_0)$。在模拟轨迹 $(k=0, 1, \\dots, N)$ 上计算两个度量指标：\n1. 最大相对能量偏差，$\\varepsilon_{\\text{max}} = \\max_{0 \\le k \\le N} \\left| \\frac{E_k - E_0}{E_0} \\right|$。该度量指标捕捉了能量的最大波动（不分正负）。\n2. 周期结束时的有符号相对能量漂移，$\\varepsilon_{\\text{end}} = \\frac{E_N - E_0}{E_0}$。该度量指标测量在一个完整参考周期后的净能量增益或损失。正值表示能量增加（显式欧拉法的典型特征），而负值表示能量耗散（隐式欧拉法的典型特征）。\n\n对每个提供的测试用例执行这些计算，并按规定汇总和格式化结果。Newton 法中使用一个小的数值容差（例如 $10^{-14}$）和一个最大迭代次数（例如 20），以确保鲁棒性并防止无限循环。必须处理 $E_0 = 0$ 的情况以避免除以零的错误，但根据给定的测试用例，$E_0$ 始终为正。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the pendulum dynamics problem for all test cases.\n    \"\"\"\n    g = 9.81  # Gravitational acceleration in m/s^2\n\n    test_cases = [\n        # (m, L, theta0, omega0, dt)\n        (10.0, 1.0, 0.2, 0.0, 0.005),\n        (50.0, 0.9, 1.0, 0.0, 0.02),\n        (5.0, 1.2, 0.01, 0.0, 0.0005),\n        (70.0, 1.0, 0.6, 0.3, 0.01),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        m, L, theta0, omega0, dt = case\n        results = run_simulation(m, L, theta0, omega0, dt, g)\n        all_results.append([f\"{val:.6f}\" for val in results])\n\n    # Format the final output string exactly as required.\n    formatted_results = \", \".join([f\"[{', '.join(res)}]\" for res in all_results])\n    print(f\"[{formatted_results}]\")\n\ndef calculate_energy(m, L, g, theta, omega):\n    \"\"\"\n    Calculates the total mechanical energy of the pendulum.\n    \"\"\"\n    kinetic = 0.5 * m * (L**2) * (omega**2)\n    potential = m * g * L * (1.0 - np.cos(theta))\n    return kinetic + potential\n\ndef forward_euler_step(theta_k, omega_k, L, g, dt):\n    \"\"\"\n    Performs one step of the explicit forward Euler method.\n    \"\"\"\n    theta_kp1 = theta_k + dt * omega_k\n    omega_kp1 = omega_k - dt * (g / L) * np.sin(theta_k)\n    return theta_kp1, omega_kp1\n\ndef backward_euler_step(theta_k, omega_k, L, g, dt):\n    \"\"\"\n    Performs one step of the implicit backward Euler method using Newton's method.\n    \"\"\"\n    # Initial guess for theta_{k+1} using a forward Euler prediction\n    theta_new = theta_k + dt * omega_k\n    \n    # Newton's method to solve for theta_{k+1}\n    max_iter = 20\n    tolerance = 1e-14\n    \n    for _ in range(max_iter):\n        # F(theta_new) = theta_new - theta_k - dt*omega_k + (g*dt^2/L)*sin(theta_new) = 0\n        f_val = theta_new - theta_k - dt * omega_k + (g * dt**2 / L) * np.sin(theta_new)\n        \n        # F'(theta_new) = 1 + (g*dt^2/L)*cos(theta_new)\n        f_deriv = 1.0 + (g * dt**2 / L) * np.cos(theta_new)\n        \n        delta_theta = f_val / f_deriv\n        theta_new -= delta_theta\n        \n        if abs(delta_theta)  tolerance:\n            break\n            \n    theta_kp1 = theta_new\n    # Update omega_{k+1} from the discretized position update equation\n    omega_kp1 = (theta_kp1 - theta_k) / dt\n    \n    return theta_kp1, omega_kp1\n\ndef run_simulation(m, L, theta0, omega0, dt, g):\n    \"\"\"\n    Runs the simulation for a single test case using both integration schemes.\n    \"\"\"\n    # Simulation duration setup\n    Tc = 2.0 * np.pi * np.sqrt(L / g)\n    N = int(np.ceil(Tc / dt))\n\n    # Initial conditions\n    E0 = calculate_energy(m, L, g, theta0, omega0)\n    \n    # Run Explicit Euler Simulation\n    exp_states = np.zeros((N + 1, 2))\n    exp_states[0] = [theta0, omega0]\n    exp_energies = np.zeros(N + 1)\n    exp_energies[0] = E0\n    \n    for k in range(N):\n        theta_k, omega_k = exp_states[k]\n        theta_kp1, omega_kp1 = forward_euler_step(theta_k, omega_k, L, g, dt)\n        exp_states[k+1] = [theta_kp1, omega_kp1]\n        exp_energies[k+1] = calculate_energy(m, L, g, theta_kp1, omega_kp1)\n\n    # Run Implicit Euler Simulation\n    imp_states = np.zeros((N + 1, 2))\n    imp_states[0] = [theta0, omega0]\n    imp_energies = np.zeros(N + 1)\n    imp_energies[0] = E0\n\n    for k in range(N):\n        theta_k, omega_k = imp_states[k]\n        theta_kp1, omega_kp1 = backward_euler_step(theta_k, omega_k, L, g, dt)\n        imp_states[k+1] = [theta_kp1, omega_kp1]\n        imp_energies[k+1] = calculate_energy(m, L, g, theta_kp1, omega_kp1)\n        \n    # Handle the case E0 = 0 to avoid division by zero\n    if E0 == 0:\n        return [0.0, 0.0, 0.0, 0.0]\n\n    # Calculate metrics for explicit scheme\n    rel_err_exp = np.abs((exp_energies - E0) / E0)\n    eps_max_exp = np.max(rel_err_exp)\n    eps_end_exp = (exp_energies[-1] - E0) / E0\n\n    # Calculate metrics for implicit scheme\n    rel_err_imp = np.abs((imp_energies - E0) / E0)\n    eps_max_imp = np.max(rel_err_imp)\n    eps_end_imp = (imp_energies[-1] - E0) / E0\n    \n    return [eps_max_exp, eps_max_imp, eps_end_exp, eps_end_imp]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}