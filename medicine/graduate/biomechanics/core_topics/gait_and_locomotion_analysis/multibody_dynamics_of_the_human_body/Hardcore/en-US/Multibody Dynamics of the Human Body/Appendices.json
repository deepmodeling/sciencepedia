{
    "hands_on_practices": [
        {
            "introduction": "This exercise  provides a foundational test of your understanding of kinematic constraints and their effect on a system's mobility. You will analyze a detailed human model in a common double-support stance to determine the reduction in its degrees of freedom. Mastering this concept is the first step in correctly formulating the dynamics of any constrained multibody system, from walking to object manipulation.",
            "id": "4193025",
            "problem": "Consider a three-dimensional free-floating multibody model of a human, where the generalized coordinate vector $q \\in \\mathbb{R}^{n+6}$ comprises a six-dimensional free base for the pelvis (three translational and three rotational components) and $n$ internal joint coordinates. The internal joints are as follows: bilateral hip joints with $3$ rotational components each ($6$ total), bilateral knee joints with $1$ rotational component each ($2$ total), bilateral ankle joints with $2$ rotational components each ($4$ total), a lumbar joint with $3$ rotational components ($3$ total), a cervical joint with $3$ rotational components ($3$ total), bilateral shoulder joints with $3$ rotational components each ($6$ total), bilateral elbow joints with $1$ rotational component each ($2$ total), and bilateral wrist joints with $2$ rotational components each ($4$ total). Assume the joints are ideal and frictionless and that the segments are rigid.\n\nDuring a double-support stance phase on a level rigid ground, the left and right foot frames $F_{L}$ and $F_{R}$ are each in rigid, stationary, non-slipping, non-rolling contact with the ground, so that for each foot the spatial position and spatial orientation relative to the inertial ground frame are constant in time. Let $\\boldsymbol{\\phi}_{L}(q)$ and $\\boldsymbol{\\phi}_{R}(q)$ denote the holonomic contact constraints for the left and right feet, respectively, each comprising the three translational and three rotational constraints that fix the corresponding foot pose. Differentiating these constraints with respect to time yields the velocity-level linear constraints\n$$\n\\mathbf{J}_{L}(q)\\,\\dot{q} = \\mathbf{0}, \\qquad \\mathbf{J}_{R}(q)\\,\\dot{q} = \\mathbf{0},\n$$\nwhere $\\mathbf{J}_{L}(q) \\in \\mathbb{R}^{6 \\times (n+6)}$ and $\\mathbf{J}_{R}(q) \\in \\mathbb{R}^{6 \\times (n+6)}$ are the foot spatial-velocity Jacobians. Define the combined contact constraint Jacobian\n$$\n\\mathbf{J}_{c}(q) \\coloneqq \\begin{bmatrix} \\mathbf{J}_{L}(q) \\\\ \\mathbf{J}_{R}(q) \\end{bmatrix} \\in \\mathbb{R}^{12 \\times (n+6)}.\n$$\n\nAssume a generic, non-singular stance configuration in which neither leg is kinematically singular, the two foot frames are distinct and non-coincident, and the ground is rigid, level, and inertial. Determine the reduction in the number of independent Degrees of Freedom (DOFs) relative to the open-chain model by computing the rank of the combined contact constraint Jacobian $\\mathbf{J}_{c}(q)$. Express your final answer as a unitless integer. No rounding is required.",
            "solution": "The problem asks for the reduction in the number of independent Degrees of Freedom (DOFs) of a multibody human model during a double-support phase. This reduction is equivalent to the number of independent constraints imposed on the system, which can be determined by finding the rank of the combined contact constraint Jacobian, $\\mathbf{J}_{c}(q)$.\n\nFirst, we determine the total number of generalized coordinates for the free-floating, open-chain model. The generalized coordinate vector $q$ has $n+6$ components, where $6$ corresponds to the free-floating base of the pelvis and $n$ is the number of internal joint coordinates. The value of $n$ is the sum of the DOFs of all internal joints:\n- Bilateral hip joints: $2 \\times 3 = 6$ DOFs\n- Bilateral knee joints: $2 \\times 1 = 2$ DOFs\n- Bilateral ankle joints: $2 \\times 2 = 4$ DOFs\n- Lumbar joint: $3$ DOFs\n- Cervical joint: $3$ DOFs\n- Bilateral shoulder joints: $2 \\times 3 = 6$ DOFs\n- Bilateral elbow joints: $2 \\times 1 = 2$ DOFs\n- Bilateral wrist joints: $2 \\times 2 = 4$ DOFs\n\nSumming these gives the total number of internal DOFs:\n$$n = 6 + 2 + 4 + 3 + 3 + 6 + 2 + 4 = 30$$\nThe total number of DOFs for the unconstrained open-chain system is therefore $N_{open} = n + 6 = 30 + 6 = 36$. The generalized coordinate vector is $q \\in \\mathbb{R}^{36}$.\n\nThe system is subjected to holonomic constraints due to both feet being in stationary contact with the ground. These constraints are expressed at the velocity level as $\\mathbf{J}_{c}(q)\\,\\dot{q} = \\mathbf{0}$, where $\\mathbf{J}_{c}(q) \\in \\mathbb{R}^{12 \\times 36}$ is the combined Jacobian:\n$$\n\\mathbf{J}_{c}(q) = \\begin{bmatrix} \\mathbf{J}_{L}(q) \\\\ \\mathbf{J}_{R}(q) \\end{bmatrix}\n$$\nHere, $\\mathbf{J}_{L}(q) \\in \\mathbb{R}^{6 \\times 36}$ and $\\mathbf{J}_{R}(q) \\in \\mathbb{R}^{6 \\times 36}$ are the Jacobians for the left and right foot, respectively. Each Jacobian maps the system's generalized velocities $\\dot{q}$ to the $6$-dimensional spatial velocity of the corresponding foot.\n\nThe number of independent constraints is equal to the rank of $\\mathbf{J}_{c}(q)$. The rank of a block matrix is given by:\n$$\n\\text{rank}(\\mathbf{J}_{c}) = \\text{rank}(\\mathbf{J}_{L}) + \\text{rank}(\\mathbf{J}_{R}) - \\dim(\\mathcal{R}(\\mathbf{J}_{L}^T) \\cap \\mathcal{R}(\\mathbf{J}_{R}^T))\n$$\nwhere $\\mathcal{R}(\\mathbf{A}^T)$ denotes the row space of a matrix $\\mathbf{A}$.\n\nLet us first determine the rank of an individual foot Jacobian, for instance, $\\mathbf{J}_{L}(q)$. This matrix represents the linear transformation from the $36$-dimensional space of generalized velocities to the $6$-dimensional space of spatial velocities of the left foot. The problem states the system is in a \"non-singular stance configuration\" and \"neither leg is kinematically singular\". This implies that the kinematic chain from the pelvis to the foot is not in a singular pose. Given the large number of DOFs of the entire body model ($36$), it is possible to control the $6$ DOFs of the foot to achieve any arbitrary spatial velocity. For example, motions of the pelvis, hip, knee, and ankle can be coordinated to produce any desired translation and rotation of the foot. Therefore, the mapping defined by $\\mathbf{J}_{L}(q)$ is surjective, and its image is the full $6$-dimensional space of spatial velocities. Consequently, the rank of the Jacobian is $6$.\n$$\n\\text{rank}(\\mathbf{J}_{L}(q)) = 6\n$$\nBy the same reasoning, the rank of the right foot Jacobian is also $6$:\n$$\n\\text{rank}(\\mathbf{J}_{R}(q)) = 6\n$$\n\nNext, we must determine the dimension of the intersection of the row spaces of $\\mathbf{J}_{L}$ and $\\mathbf{J}_{R}$. The rows of $\\mathbf{J}_{L}$ and $\\mathbf{J}_{R}$ are linearly independent if and only if the constraints imposed by fixing the left foot are independent of the constraints imposed by fixing the right foot.\nPhysically, this means that even when one foot is fixed, the other foot can still move with $6$ degrees of freedom. Let's consider the left foot to be fixed to the ground. The kinematic chain connecting the left foot to the right foot passes through the left leg, the pelvis, and the right leg. The joints in this chain are: left ankle ($2$ DOFs), left knee ($1$ DOF), left hip ($3$ DOFs), right hip ($3$ DOFs), right knee ($1$ DOF), and right ankle ($2$ DOFs). The total number of degrees of freedom in this chain is $2+1+3+3+1+2=12$.\nThis $12$-DOF kinematic chain is tasked with controlling the $6$-DOF pose of the right foot relative to the fixed left foot. The problem specifies a \"generic, non-singular stance\" and that the \"foot frames are distinct and non-coincident\". This ensures that the $12$-DOF chain is not in a singular configuration that would prevent it from generating an arbitrary $6$-DOF motion at its end-effector (the right foot).\nSince it is possible to move the right foot with full $6$-DOF motion while the left foot is stationary, the constraints on the right foot's velocity are independent of the constraints on the left foot's velocity. This implies that the row vectors of $\\mathbf{J}_{L}(q)$ are linearly independent from the row vectors of $\\mathbf{J}_{R}(q)$. The intersection of their row spaces contains only the zero vector.\n$$\n\\dim(\\mathcal{R}(\\mathbf{J}_{L}^T) \\cap \\mathcal{R}(\\mathbf{J}_{R}^T)) = 0\n$$\n\nTherefore, the rank of the combined Jacobian is the sum of the individual ranks:\n$$\n\\text{rank}(\\mathbf{J}_{c}(q)) = \\text{rank}(\\mathbf{J}_{L}(q)) + \\text{rank}(\\mathbf{J}_{R}(q)) = 6 + 6 = 12\n$$\n\nThe rank of the combined constraint Jacobian is $12$. This means that the double-support contact imposes $12$ independent holonomic constraints on the system. The reduction in the number of degrees of freedom is equal to this number. The number of DOFs of the constrained system is $N_{constrained} = N_{open} - \\text{rank}(\\mathbf{J}_{c}) = 36 - 12 = 24$.\nThe question asks for the reduction in the number of DOFs, which is $\\text{rank}(\\mathbf{J}_{c}(q))$.",
            "answer": "$$\n\\boxed{12}\n$$"
        },
        {
            "introduction": "In practical biomechanics, models are often assembled from various sources, making unit consistency a critical and frequent challenge. This practice  places you in a realistic scenario where you must use dimensional analysis to diagnose and correct an inconsistency within the equations of motion. This skill is essential for ensuring the physical validity and numerical correctness of complex computational models.",
            "id": "4193017",
            "problem": "A planar lower-limb multibody model in biomechanics is assembled from multiple software components. The generalized coordinates are joint angles $q = (\\theta_{\\mathrm{hip}}, \\theta_{\\mathrm{knee}}, \\theta_{\\mathrm{ankle}})^{\\mathsf{T}}$ used in the standard Equations of Motion (EOM) of the form\n$$\nM(q)\\,\\ddot{q} + h(q,\\dot{q}) = \\tau + J(q)^{\\mathsf{T}} \\lambda,\n$$\nwhere $M(q)$ is the generalized mass matrix, $h(q,\\dot{q})$ collects Coriolis, centrifugal, and gravitational terms, $\\tau$ are the applied generalized joint torques, $J(q)$ is the constraint Jacobian associated with foot–ground holonomic constraints, and $\\lambda$ are the Lagrange multipliers representing ground contact forces. The International System of Units (SI) is used for all assembled quantities: lengths in meters, masses in kilograms, time in seconds, and angles in radians.\n\nOne component, responsible for computing the foot–ground constraint Jacobian for the ankle subchain, was implemented with non-SI conventions: lengths were coded in millimeters and joint angles were treated in degrees during the numerical differentiation that produced $J(q)$. As a result, that component outputs a Jacobian with entries carrying units of millimeters per degree. All other components (including $M(q)$, $h(q,\\dot{q})$, $\\tau$, and $\\lambda$) are consistent with SI, and $\\lambda$ is interpreted as contact forces in Newtons.\n\nUsing dimensional analysis starting from first principles appropriate to multibody dynamics, verify the SI-consistent units required for $M(q)$, $h(q,\\dot{q})$, $\\tau$, and $J(q)^{\\mathsf{T}} \\lambda$. Then determine the single dimensionless scalar factor $c$ that must be applied to the non-SI Jacobian $J(q)$ from the ankle subchain so that $J(q)^{\\mathsf{T}} \\lambda$ contributes generalized torques in Newton–meter when $\\lambda$ is in Newtons and $q$ is in radians.\n\nExpress the final scalar $c$ as an exact analytic expression. No rounding is required. Since $c$ is dimensionless, do not include any units in your final answer.",
            "solution": "The problem statement is first subjected to validation.\n\n### Step 1: Extract Givens\n-   **Equation of Motion (EOM):** $M(q)\\,\\ddot{q} + h(q,\\dot{q}) = \\tau + J(q)^{\\mathsf{T}} \\lambda$\n-   **Generalized Coordinates:** $q = (\\theta_{\\mathrm{hip}}, \\theta_{\\mathrm{knee}}, \\theta_{\\mathrm{ankle}})^{\\mathsf{T}}$ are joint angles.\n-   **Terms in EOM:**\n    -   $M(q)$: generalized mass matrix.\n    -   $h(q,\\dot{q})$: Coriolis, centrifugal, and gravitational terms.\n    -   $\\tau$: applied generalized joint torques.\n    -   $J(q)$: constraint Jacobian for foot–ground holonomic constraints.\n    -   $\\lambda$: Lagrange multipliers representing ground contact forces.\n-   **Standard Unit System (SI):** Lengths in meters ($m$), mass in kilograms ($kg$), time in seconds ($s$), angles in radians ($rad$).\n-   **Inconsistent Component:** A component computes the Jacobian $J(q)$ using lengths in millimeters ($mm$) and angles in degrees ($^{\\circ}$).\n-   **Resulting Jacobian:** The output Jacobian from this component has entries with units of millimeters per degree ($mm/^{\\circ}$).\n-   **Consistent Components:** $M(q)$, $h(q,\\dot{q})$, $\\tau$, and $\\lambda$ are SI-consistent.\n-   **Interpretation of $\\lambda$:** Contact forces in Newtons ($N$).\n-   **Task:**\n    1.  Verify the SI-consistent units for $M(q)$, $h(q,\\dot{q})$, $\\tau$, and $J(q)^{\\mathsf{T}} \\lambda$.\n    2.  Determine the single dimensionless scalar factor $c$ to correct the non-SI Jacobian.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the principles of multibody dynamics, specifically using Lagrange's equations of the second kind with holonomic constraints. The EOM presented is a standard form in robotics and biomechanics. The issue of unit inconsistency between different software modules is a practical and realistic problem in computational engineering. The problem is well-posed, objective, and contains all necessary information to perform a dimensional analysis and derive the correction factor. It does not violate any of the specified invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is valid. A full solution will be provided.\n\n### Solution Derivation\nThe solution consists of two parts as requested: verifying the units of the terms in the EOM and then determining the correction factor $c$.\n\n**Part 1: Dimensional Analysis of EOM Terms**\n\nThe Equations of Motion (EOM) are given by:\n$$\nM(q)\\,\\ddot{q} + h(q,\\dot{q}) = \\tau + J(q)^{\\mathsf{T}} \\lambda\n$$\nThis is an equation of generalized forces. Since the generalized coordinates $q$ are angles, the generalized forces are torques. According to the principle of dimensional homogeneity, every term in this equation must have the same physical units, which must be the units of torque.\n\nIn the International System of Units (SI), torque is measured in Newton-meters ($N \\cdot m$). The base units for force ($N$) are $kg \\cdot m \\cdot s^{-2}$. Therefore, the base SI units for torque are $(kg \\cdot m \\cdot s^{-2}) \\cdot m = kg \\cdot m^2 \\cdot s^{-2}$. Let's denote the units of a quantity $X$ by $[X]$.\n\n-   **Generalized Torques $\\tau$**: By definition, $\\tau$ represents the applied joint torques. Thus, its units are Newton-meters.\n    $$[\\tau] = N \\cdot m = kg \\cdot m^2 \\cdot s^{-2}$$\n\n-   **Generalized Coordinates and their Derivatives**: The generalized coordinates $q$ are angles, which are measured in radians ($rad$) in the SI system. The radian is a dimensionless unit, so for dimensional analysis, $[q] = [rad] = 1$.\n    The generalized velocities are $\\dot{q}$, so $[\\dot{q}] = [q] \\cdot [t]^{-1} = rad \\cdot s^{-1} = s^{-1}$.\n    The generalized accelerations are $\\ddot{q}$, so $[\\ddot{q}] = [q] \\cdot [t]^{-2} = rad \\cdot s^{-2} = s^{-2}$.\n\n-   **Inertial Term $M(q)\\ddot{q}$**: This term must have units of torque.\n    $$[M(q)\\ddot{q}] = [M(q)][\\ddot{q}] = kg \\cdot m^2 \\cdot s^{-2}$$\n    Substituting the units of $\\ddot{q}$:\n    $$[M(q)] \\cdot (s^{-2}) = kg \\cdot m^2 \\cdot s^{-2}$$\n    Solving for the units of the generalized mass matrix $M(q)$:\n    $$[M(q)] = kg \\cdot m^2$$\n    This is consistent with the physical meaning of a mass matrix for rotational dynamics, which has elements with units of moment of inertia.\n\n-   **Coriolis, Centrifugal, and Gravitational Term $h(q,\\dot{q})$**: This term must also have units of torque.\n    $$[h(q,\\dot{q})] = [\\tau] = N \\cdot m = kg \\cdot m^2 \\cdot s^{-2}$$\n\n-   **Constraint Force Term $J(q)^{\\mathsf{T}} \\lambda$**: This term represents the generalized torques resulting from the constraint forces. It must have units of torque.\n    $$[J(q)^{\\mathsf{T}} \\lambda] = [\\tau] = N \\cdot m$$\n    We are given that $\\lambda$ are the Lagrange multipliers corresponding to contact forces, so their units are Newtons ($N$).\n    $$[\\lambda] = N$$\n    The units of the transposed Jacobian, $[J(q)^{\\mathsf{T}}]$, can be determined from the product:\n    $$[J(q)^{\\mathsf{T}}] [\\lambda] = N \\cdot m$$\n    $$[J(q)^{\\mathsf{T}}] \\cdot N = N \\cdot m$$\n    $$[J(q)^{\\mathsf{T}}] = m$$\n    The transpose operation does not alter the units of the elements of a matrix, so $[J(q)] = [J(q)^{\\mathsf{T}}] = m$.\n\nTo confirm the units of $J(q)$, we recall its definition. The holonomic constraint equations $\\phi(q)=0$ relate the Cartesian positions of points on the body (in meters) to the generalized coordinates $q$ (in radians). The Jacobian is defined as $J(q) = \\frac{\\partial \\phi(q)}{\\partial q}$. Therefore, its units are the units of position divided by the units of angle:\n$$[J(q)] = \\frac{[\\phi]}{[q]} = \\frac{m}{rad}$$\nSince the radian is dimensionless, this simplifies to $[J(q)] = m$, which is consistent with our previous finding.\n\n**Part 2: Determination of the Correction Factor $c$**\n\nThe problem states that a software component incorrectly computes the Jacobian, which we denote as $J_{\\text{buggy}}$. This component uses lengths in millimeters ($mm$) and angles in degrees ($^{\\circ}$). The numerical entries of $J_{\\text{buggy}}$ therefore correspond to physical units of $mm/^{\\circ}$.\n\nWe want to find a dimensionless scalar $c$ such that multiplying $J_{\\text{buggy}}$ by $c$ yields the correct Jacobian, $J_{\\text{correct}}$, whose numerical entries correspond to the SI-consistent units of meters per radian ($m/rad$).\n$$J_{\\text{correct}} = c \\cdot J_{\\text{buggy}}$$\nTo find $c$, we establish the conversion factors between the unit systems.\n1.  Length conversion: $1 \\text{ m} = 1000 \\text{ mm}$, which implies $1 \\text{ mm} = 10^{-3} \\text{ m}$.\n2.  Angle conversion: $360^{\\circ} = 2\\pi \\text{ rad}$, which implies $1^{\\circ} = \\frac{2\\pi}{360} \\text{ rad} = \\frac{\\pi}{180} \\text{ rad}$.\n\nLet's consider a single numerical value $j_{\\text{buggy}}$ from the matrix $J_{\\text{buggy}}$. This value represents a physical quantity that can be expressed as:\n$$j_{\\text{buggy}} \\left[ \\frac{\\text{mm}}{^{\\circ}} \\right]$$\nWe can convert this quantity to SI units by substituting the conversion factors:\n$$j_{\\text{buggy}} \\frac{1 \\text{ mm}}{1 ^{\\circ}} = j_{\\text{buggy}} \\frac{10^{-3} \\text{ m}}{\\frac{\\pi}{180} \\text{ rad}} = j_{\\text{buggy}} \\left( \\frac{180 \\times 10^{-3}}{\\pi} \\right) \\left[ \\frac{\\text{m}}{\\text{rad}} \\right]$$\nThe numerical value of the corresponding entry in the correct Jacobian, $j_{\\text{correct}}$, is therefore:\n$$j_{\\text{correct}} = j_{\\text{buggy}} \\cdot \\frac{180 \\times 10^{-3}}{\\pi}$$\nThe dimensionless scalar factor $c$ is the multiplier that converts the numerical values.\n$$c = \\frac{180 \\times 10^{-3}}{\\pi} = \\frac{0.18}{\\pi}$$\nThis can be expressed as an exact fraction:\n$$c = \\frac{18}{100\\pi} = \\frac{9}{50\\pi}$$\nThis is the required dimensionless scalar factor.\nApplying this correction, the generalized torque from the constraint forces becomes $(c J_{\\text{buggy}})^{\\mathsf{T}} \\lambda = c (J_{\\text{buggy}})^{\\mathsf{T}} \\lambda$. Given that $\\lambda$ is in Newtons, the resulting term will correctly be in Newton-meters.",
            "answer": "$$\n\\boxed{\\frac{9}{50\\pi}}\n$$"
        },
        {
            "introduction": "The heart of any forward dynamics simulation is the numerical integration of the equations of motion, where the choice of method has profound consequences. This coding exercise  allows you to directly compare the behavior of explicit and implicit integration schemes on a simple, conservative system. By tracking the system's energy, you will gain an intuitive and quantitative understanding of numerical stability and energy drift, concepts that are paramount in long-duration or predictive simulations.",
            "id": "4192970",
            "problem": "Consider a planar, uniform rigid pendulum segment that represents a single human limb segment (for example, a shank) rotating about a frictionless hinge under gravity without any actuation. Let the mass be $m$ in kilograms, the length be $L$ in meters, and the constant gravitational acceleration be $g = 9.81$ in meters per second squared. Let the generalized coordinate be the angle $\\theta$ in radians measured from the downward vertical, with positive counterclockwise rotation. The angular velocity is $\\dot{\\theta}$ in radians per second. Under these assumptions, Newton's second law for rotation and the absence of external driving torques lead to the ordinary differential equation (ODE)\n$$ m L^2 \\ddot{\\theta} = - m g L \\sin(\\theta), $$\nor equivalently\n$$ \\ddot{\\theta} = - \\frac{g}{L} \\sin(\\theta). $$\nThe total mechanical energy $E$ of the pendulum is the sum of kinetic energy and gravitational potential energy, given by\n$$ E(\\theta, \\dot{\\theta}) = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + m g L (1 - \\cos(\\theta)). $$\nFor this passive, conservative system, the exact continuous-time dynamics conserve total mechanical energy, so any deviation from constant $E$ arises entirely from numerical time integration error.\n\nYour task is to implement two one-step numerical time integration schemes for the above ODE: an explicit forward Euler scheme and an implicit backward Euler scheme, both applied to the first-order state $[\\theta, \\dot{\\theta}]$. The explicit forward Euler scheme advances $[\\theta, \\dot{\\theta}]$ using the current state. The implicit backward Euler scheme computes the next state using the acceleration evaluated at the next state; this requires solving a scalar nonlinear equation for $\\theta$ at the new time step. Use Newton's method with a sensible initial guess to solve the implicit equation for $\\theta$ and then update $\\dot{\\theta}$ accordingly.\n\nDefine a simulated gait cycle duration $T_\\mathrm{c}$ as the small-angle linearized pendulum period\n$$ T_\\mathrm{c} = 2 \\pi \\sqrt{\\frac{L}{g}}, $$\nwhich is a scientifically standard approximation for near-small-amplitude passive swing and serves here as a consistent reference duration. For each simulation, advance the state for $N = \\lceil T_\\mathrm{c} / \\Delta t \\rceil$ time steps of size $\\Delta t$ seconds. Angles must be in radians, lengths in meters, masses in kilograms, and time in seconds.\n\nFor each scheme and test case, compute the following two quantitative measures of energy behavior over the simulated gait cycle:\n- The maximum relative energy deviation over the cycle, $\\varepsilon_\\mathrm{max}$,\n$$ \\varepsilon_\\mathrm{max} = \\max_{0 \\le k \\le N} \\left| \\frac{E_k - E_0}{E_0} \\right|, $$\nwhere $E_k$ is the energy after $k$ steps and $E_0$ is the initial energy.\n- The signed end-of-cycle relative energy drift, $\\varepsilon_\\mathrm{end}$,\n$$ \\varepsilon_\\mathrm{end} = \\frac{E_N - E_0}{E_0}. $$\n\nImplement a runnable program that uses the following test suite. In all cases, use radians for angles and seconds for time:\n1. $m = 10.0$, $L = 1.0$, $\\theta_0 = 0.2$, $\\dot{\\theta}_0 = 0.0$, $\\Delta t = 0.005$.\n2. $m = 50.0$, $L = 0.9$, $\\theta_0 = 1.0$, $\\dot{\\theta}_0 = 0.0$, $\\Delta t = 0.02$.\n3. $m = 5.0$, $L = 1.2$, $\\theta_0 = 0.01$, $\\dot{\\theta}_0 = 0.0$, $\\Delta t = 0.0005$.\n4. $m = 70.0$, $L = 1.0$, $\\theta_0 = 0.6$, $\\dot{\\theta}_0 = 0.3$, $\\Delta t = 0.01$.\n\nYour program must, for each test case, simulate the pendulum over one reference gait cycle using both integrators, compute $\\varepsilon_\\mathrm{max}$ and $\\varepsilon_\\mathrm{end}$ for each scheme, and produce a single line of output containing the results as a comma-separated list of lists in the following order per test case:\n$[\\varepsilon_\\mathrm{max}^\\mathrm{exp}, \\varepsilon_\\mathrm{max}^\\mathrm{imp}, \\varepsilon_\\mathrm{end}^\\mathrm{exp}, \\varepsilon_\\mathrm{end}^\\mathrm{imp}]$.\nAll values must be decimal numbers rounded to six decimal places. The final printed output must be of the form\n$$ [ [a_1, b_1, c_1, d_1], [a_2, b_2, c_2, d_2], [a_3, b_3, c_3, d_3], [a_4, b_4, c_4, d_4] ] $$\nwith no additional text. Ensure numerical robustness of the implicit solver and scientific realism of all parameters and computations.",
            "solution": "The problem requires the implementation and comparison of two numerical integration schemes, explicit forward Euler and implicit backward Euler, for simulating the dynamics of a simple pendulum. The pendulum's motion is described by a second-order ordinary differential equation (ODE), which must first be converted into a system of two first-order ODEs for integration.\n\nThe state of the pendulum at any time $t$ can be described by a state vector $y(t) = [\\theta(t), \\omega(t)]^T$, where $\\theta(t)$ is the angle and $\\omega(t) = \\dot{\\theta}(t)$ is the angular velocity. The given second-order ODE is $\\ddot{\\theta} = - \\frac{g}{L} \\sin(\\theta)$. We can express this as a first-order system $\\dot{y} = f(y)$:\n$$\n\\frac{d}{dt}\n\\begin{pmatrix} \\theta \\\\ \\omega \\end{pmatrix}\n=\n\\begin{pmatrix} \\omega \\\\ -\\frac{g}{L} \\sin(\\theta) \\end{pmatrix}\n= f(\\theta, \\omega)\n$$\nWe will numerically integrate this system from an initial state $y_0 = [\\theta_0, \\omega_0]^T$ over a series of time steps of size $\\Delta t$. Let $y_k = [\\theta_k, \\omega_k]^T$ denote the state at time $t_k = k \\Delta t$.\n\nThe explicit forward Euler method is a first-order, explicit integration scheme. It computes the state at the next time step, $y_{k+1}$, using the derivative evaluated at the current state, $y_k$. The update rule is:\n$$\ny_{k+1} = y_k + \\Delta t \\cdot f(y_k)\n$$\nIn component form, this translates to:\n$$\n\\theta_{k+1} = \\theta_k + \\Delta t \\cdot \\omega_k\n$$\n$$\n\\omega_{k+1} = \\omega_k - \\Delta t \\cdot \\frac{g}{L} \\sin(\\theta_k)\n$$\nThis scheme is straightforward to implement as each new state variable is calculated directly from the previous state.\n\nThe implicit backward Euler method is a first-order, implicit integration scheme. It computes the state at the next time step, $y_{k+1}$, using the derivative evaluated at that same (unknown) future state, $y_{k+1}$. The update rule is:\n$$\ny_{k+1} = y_k + \\Delta t \\cdot f(y_{k+1})\n$$\nIn component form, this yields a system of coupled equations for the unknown state $[\\theta_{k+1}, \\omega_{k+1}]$:\n$$\n\\theta_{k+1} = \\theta_k + \\Delta t \\cdot \\omega_{k+1} \\quad (1)\n$$\n$$\n\\omega_{k+1} = \\omega_k - \\Delta t \\cdot \\frac{g}{L} \\sin(\\theta_{k+1}) \\quad (2)\n$$\nTo solve this system, we can substitute for $\\omega_{k+1}$ to obtain a single nonlinear algebraic equation for $\\theta_{k+1}$. From equation $(1)$, we express $\\omega_{k+1} = (\\theta_{k+1} - \\theta_k) / \\Delta t$. Substituting this into equation $(2)$ gives:\n$$\n\\frac{\\theta_{k+1} - \\theta_k}{\\Delta t} = \\omega_k - \\frac{g \\Delta t}{L} \\sin(\\theta_{k+1})\n$$\nRearranging this equation gives a root-finding problem for $\\theta_{k+1}$. Let $\\theta_{\\text{new}} \\equiv \\theta_{k+1}$. We must find the root of the function $F(\\theta_{\\text{new}})$:\n$$\nF(\\theta_{\\text{new}}) = \\theta_{\\text{new}} - \\theta_k - \\Delta t \\cdot \\omega_k + \\frac{g (\\Delta t)^2}{L} \\sin(\\theta_{\\text{new}}) = 0\n$$\nAs specified, we use Newton's method to solve this equation. The iterative update for a variable $z$ is $z_{j+1} = z_j - F(z_j)/F'(z_j)$. The derivative of $F$ with respect to $\\theta_{\\text{new}}$ is:\n$$\nF'(\\theta_{\\text{new}}) = 1 + \\frac{g (\\Delta t)^2}{L} \\cos(\\theta_{\\text{new}})\n$$\nA sensible initial guess for the iteration is the result from an explicit Euler step, $z_0 = \\theta_k + \\Delta t \\cdot \\omega_k$. The iteration proceeds until the change between successive estimates of $\\theta_{\\text{new}}$ is below a small tolerance. Once a converged value for $\\theta_{k+1}$ is found, $\\omega_{k+1}$ is computed algebraically from equation $(1)$: $\\omega_{k+1} = (\\theta_{k+1} - \\theta_k) / \\Delta t$.\n\nFor each test case, the simulation runs for a duration defined by the linearized small-angle pendulum period, $T_c = 2 \\pi \\sqrt{L/g}$. The number of steps is $N = \\lceil T_c / \\Delta t \\rceil$. The state is advanced for $N$ steps, from $k=0$ to $k=N$.\n\nAt each step $k$ of the simulation for both schemes, the total mechanical energy is calculated using the formula:\n$$\nE_k = \\frac{1}{2} m L^2 \\omega_k^2 + m g L (1 - \\cos(\\theta_k))\n$$\nThe initial energy is $E_0 = E(\\theta_0, \\dot{\\theta}_0)$. Two metrics are computed over the simulation trajectory $(k=0, 1, \\dots, N)$:\n1. The maximum relative energy deviation, $\\varepsilon_{\\text{max}} = \\max_{0 \\le k \\le N} \\left| \\frac{E_k - E_0}{E_0} \\right|$. This metric captures the largest fluctuation in energy, regardless of sign.\n2. The signed end-of-cycle relative energy drift, $\\varepsilon_{\\text{end}} = \\frac{E_N - E_0}{E_0}$. This metric measures the net energy gain or loss after one full reference cycle. A positive value indicates energy gain (typical of explicit Euler), while a negative value indicates energy dissipation (typical of implicit Euler).\n\nThese calculations are performed for each test case provided, and the results are aggregated and formatted as specified. A small numerical tolerance (e.g., $10^{-14}$) and a maximum iteration count (e.g., $20$) are used for Newton's method to ensure robustness and prevent infinite loops. The case where $E_0 = 0$ must be handled to avoid division by zero, but given the test cases, $E_0$ is always positive.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the pendulum dynamics problem for all test cases.\n    \"\"\"\n    g = 9.81  # Gravitational acceleration in m/s^2\n\n    test_cases = [\n        # (m, L, theta0, omega0, dt)\n        (10.0, 1.0, 0.2, 0.0, 0.005),\n        (50.0, 0.9, 1.0, 0.0, 0.02),\n        (5.0, 1.2, 0.01, 0.0, 0.0005),\n        (70.0, 1.0, 0.6, 0.3, 0.01),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        m, L, theta0, omega0, dt = case\n        results = run_simulation(m, L, theta0, omega0, dt, g)\n        all_results.append([f\"{val:.6f}\" for val in results])\n\n    # Format the final output string exactly as required.\n    formatted_results = \", \".join([f\"[{', '.join(res)}]\" for res in all_results])\n    print(f\"[{formatted_results}]\")\n\ndef calculate_energy(m, L, g, theta, omega):\n    \"\"\"\n    Calculates the total mechanical energy of the pendulum.\n    \"\"\"\n    kinetic = 0.5 * m * (L**2) * (omega**2)\n    potential = m * g * L * (1.0 - np.cos(theta))\n    return kinetic + potential\n\ndef forward_euler_step(theta_k, omega_k, L, g, dt):\n    \"\"\"\n    Performs one step of the explicit forward Euler method.\n    \"\"\"\n    theta_kp1 = theta_k + dt * omega_k\n    omega_kp1 = omega_k - dt * (g / L) * np.sin(theta_k)\n    return theta_kp1, omega_kp1\n\ndef backward_euler_step(theta_k, omega_k, L, g, dt):\n    \"\"\"\n    Performs one step of the implicit backward Euler method using Newton's method.\n    \"\"\"\n    # Initial guess for theta_{k+1} using a forward Euler prediction\n    theta_new = theta_k + dt * omega_k\n    \n    # Newton's method to solve for theta_{k+1}\n    max_iter = 20\n    tolerance = 1e-14\n    \n    for _ in range(max_iter):\n        # F(theta_new) = theta_new - theta_k - dt*omega_k + (g*dt^2/L)*sin(theta_new) = 0\n        f_val = theta_new - theta_k - dt * omega_k + (g * dt**2 / L) * np.sin(theta_new)\n        \n        # F'(theta_new) = 1 + (g*dt^2/L)*cos(theta_new)\n        f_deriv = 1.0 + (g * dt**2 / L) * np.cos(theta_new)\n        \n        delta_theta = f_val / f_deriv\n        theta_new -= delta_theta\n        \n        if abs(delta_theta) < tolerance:\n            break\n            \n    theta_kp1 = theta_new\n    # Update omega_{k+1} from the discretized position update equation\n    omega_kp1 = (theta_kp1 - theta_k) / dt\n    \n    return theta_kp1, omega_kp1\n\ndef run_simulation(m, L, theta0, omega0, dt, g):\n    \"\"\"\n    Runs the simulation for a single test case using both integration schemes.\n    \"\"\"\n    # Simulation duration setup\n    Tc = 2.0 * np.pi * np.sqrt(L / g)\n    N = int(np.ceil(Tc / dt))\n\n    # Initial conditions\n    E0 = calculate_energy(m, L, g, theta0, omega0)\n    \n    # Run Explicit Euler Simulation\n    exp_states = np.zeros((N + 1, 2))\n    exp_states[0] = [theta0, omega0]\n    exp_energies = np.zeros(N + 1)\n    exp_energies[0] = E0\n    \n    for k in range(N):\n        theta_k, omega_k = exp_states[k]\n        theta_kp1, omega_kp1 = forward_euler_step(theta_k, omega_k, L, g, dt)\n        exp_states[k+1] = [theta_kp1, omega_kp1]\n        exp_energies[k+1] = calculate_energy(m, L, g, theta_kp1, omega_kp1)\n\n    # Run Implicit Euler Simulation\n    imp_states = np.zeros((N + 1, 2))\n    imp_states[0] = [theta0, omega0]\n    imp_energies = np.zeros(N + 1)\n    imp_energies[0] = E0\n\n    for k in range(N):\n        theta_k, omega_k = imp_states[k]\n        theta_kp1, omega_kp1 = backward_euler_step(theta_k, omega_k, L, g, dt)\n        imp_states[k+1] = [theta_kp1, omega_kp1]\n        imp_energies[k+1] = calculate_energy(m, L, g, theta_kp1, omega_kp1)\n        \n    # Handle the case E0 = 0 to avoid division by zero\n    if E0 == 0:\n        return [0.0, 0.0, 0.0, 0.0]\n\n    # Calculate metrics for explicit scheme\n    rel_err_exp = np.abs((exp_energies - E0) / E0)\n    eps_max_exp = np.max(rel_err_exp)\n    eps_end_exp = (exp_energies[-1] - E0) / E0\n\n    # Calculate metrics for implicit scheme\n    rel_err_imp = np.abs((imp_energies - E0) / E0)\n    eps_max_imp = np.max(rel_err_imp)\n    eps_end_imp = (imp_energies[-1] - E0) / E0\n    \n    return [eps_max_exp, eps_max_imp, eps_end_exp, eps_end_imp]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}