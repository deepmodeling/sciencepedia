{
    "hands_on_practices": [
        {
            "introduction": "在神经科学研究中，我们常常需要比较不同的脑图谱，或者将分割算法的输出与“金标准”图谱进行对比。本练习将介绍两个基本指标——Dice系数和Jaccard指数——用于量化两个脑区在空间上的重叠程度。通过从集合论基本原理出发推导这些指标，并将其应用于一个具体场景，你将掌握一项评估和比较脑区划分结果的核心技能。",
            "id": "4143491",
            "problem": "给定两个结构磁共振成像 (MRI) 脑图谱，它们各自为同一个皮层标签提供了一个二值掩模。这些掩模定义在一个共享的体素网格上，其各向同性体素大小为 $1 \\ \\mathrm{mm}^{3}$。设由图谱 $\\mathcal{A}$ 标记的体素集合表示为 $S_{\\mathcal{A}} \\subset \\Omega$，由图谱 $\\mathcal{B}$ 标记的体素集合表示为 $S_{\\mathcal{B}} \\subset \\Omega$，其中 $\\Omega$ 是脑容积中所有体素的有限集合。这些二值掩模通过为标签内的体素赋值 $1$、其他体素赋值 $0$ 来编码集合的隶属关系。通过经验计算得出以下计数：\n- 图谱 $\\mathcal{A}$ 标签的基数 $|S_{\\mathcal{A}}|$ 为 $12{,}800$个体素。\n- 图谱 $\\mathcal{B}$ 标签的基数 $|S_{\\mathcal{B}}|$ 为 $13{,}600$个体素。\n- 交集的基数 $|S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|$ 为 $12{,}000$个体素。\n\n从核心的集合论定义和性质（例如集合交集、集合并集的定义，以及容斥恒等式 $|S_{\\mathcal{A}} \\cup S_{\\mathcal{B}}| = |S_{\\mathcal{A}}| + |S_{\\mathcal{B}}| - |S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|$）出发，完成以下任务：\n\n1. 从第一性原理出发，将相似性解释为集合精确率和召回率的调和平均值，推导出用 $|S_{\\mathcal{A}}|$、$|S_{\\mathcal{B}}|$ 和 $|S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|$ 表示的 Dice 相似系数的表达式。\n2. 从第一性原理出发，将相似性解释为交并比，推导出用 $|S_{\\mathcal{A}}|$、$|S_{\\mathcal{B}}|$ 和 $|S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|$ 表示的 Jaccard 指数的表达式。\n3. 使用您推导出的表达式，计算给定掩模的 Dice 相似系数和 Jaccard 指数。\n\n将这两个指标表示为无量纲小数，并四舍五入到四位有效数字。最终答案必须以分别对应 $\\text{Dice}$ 和 $\\text{Jaccard}$ 的两个值的形式给出。",
            "solution": "我们使用体素域 $\\Omega$ 上的基本集合论定义来形式化该问题。对于任意两个标签集合 $S_{\\mathcal{A}}, S_{\\mathcal{B}} \\subset \\Omega$，其交集 $S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}$ 精确地包含被两个图谱同时标记的体素，其并集 $S_{\\mathcal{A}} \\cup S_{\\mathcal{B}}$ 包含被至少一个图谱标记的体素。容斥原理确保了\n$$\n|S_{\\mathcal{A}} \\cup S_{\\mathcal{B}}| = |S_{\\mathcal{A}}| + |S_{\\mathcal{B}}| - |S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|.\n$$\n\n我们将 $S_{\\mathcal{A}}$（作为参考）和 $S_{\\mathcal{B}}$（作为候选）的集合精确率和召回率定义如下：\n- 精确率 (Precision) 是指被图谱 $\\mathcal{B}$ 标记的体素中同时也被图谱 $\\mathcal{A}$ 标记的体素所占的比例，由下式给出\n$$\nP = \\frac{|S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|}{|S_{\\mathcal{B}}|}.\n$$\n- 召回率 (Recall) 是指被图谱 $\\mathcal{A}$ 标记的体素中同时也被图谱 $\\mathcal{B}$ 标记的体素所占的比例，由下式给出\n$$\nR = \\frac{|S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|}{|S_{\\mathcal{A}}|}.\n$$\n\nDice 相似系数可以推导为精确率和召回率的调和平均值：\n$$\n\\text{Dice} = \\frac{2 \\, P \\, R}{P + R}.\n$$\n代入 $P$ 和 $R$ 可得\n$$\n\\text{Dice} = \\frac{2 \\left( \\frac{|S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|}{|S_{\\mathcal{B}}|} \\right) \\left( \\frac{|S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|}{|S_{\\mathcal{A}}|} \\right)}{\\frac{|S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|}{|S_{\\mathcal{B}}|} + \\frac{|S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|}{|S_{\\mathcal{A}}|}} = \\frac{2 \\, |S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|}{|S_{\\mathcal{A}}| + |S_{\\mathcal{B}}|}.\n$$\n\nJaccard 指数定义为交集与并集的比率：\n$$\n\\text{Jaccard} = \\frac{|S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|}{|S_{\\mathcal{A}} \\cup S_{\\mathcal{B}}|} = \\frac{|S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|}{|S_{\\mathcal{A}}| + |S_{\\mathcal{B}}| - |S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|}.\n$$\n\n这些定义得出了两种度量指标之间的函数关系。设 $I = |S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}|$ 且 $T = |S_{\\mathcal{A}}| + |S_{\\mathcal{B}}|$。那么\n$$\n\\text{Dice} = \\frac{2 I}{T}, \\quad \\text{Jaccard} = \\frac{I}{T - I}.\n$$\n从 Dice 表达式中解出 $I$ 得到 $I = \\frac{\\text{Dice} \\cdot T}{2}$。将其代入 Jaccard 表达式中：\n$$\n\\text{Jaccard} = \\frac{\\frac{\\text{Dice} \\cdot T}{2}}{T - \\frac{\\text{Dice} \\cdot T}{2}} = \\frac{\\text{Dice}}{2 - \\text{Dice}},\n$$\n以及反向关系\n$$\n\\text{Dice} = \\frac{2 \\, \\text{Jaccard}}{1 + \\text{Jaccard}}.\n$$\n\n现在我们使用给定的计数来计算这些指标：\n$$\n|S_{\\mathcal{A}}| = 12{,}800, \\quad |S_{\\mathcal{B}}| = 13{,}600, \\quad |S_{\\mathcal{A}} \\cap S_{\\mathcal{B}}| = 12{,}000.\n$$\n首先，使用容斥原理计算并集的基数：\n$$\n|S_{\\mathcal{A}} \\cup S_{\\mathcal{B}}| = 12{,}800 + 13{,}600 - 12{,}000 = 14{,}400.\n$$\n计算 Dice 相似系数：\n$$\n\\text{Dice} = \\frac{2 \\times 12{,}000}{12{,}800 + 13{,}600} = \\frac{24{,}000}{26{,}400} = \\frac{240}{264} = \\frac{60}{66} = \\frac{10}{11}.\n$$\n因此，\n$$\n\\text{Dice} = \\frac{10}{11} \\approx 0.909090\\ldots\n$$\n计算 Jaccard 指数：\n$$\n\\text{Jaccard} = \\frac{12{,}000}{14{,}400} = \\frac{120}{144} = \\frac{5}{6} \\approx 0.833333\\ldots\n$$\n\n最后，按要求将两个小数值四舍五入到四位有效数字：\n$$\n\\text{Dice} \\approx 0.9091, \\quad \\text{Jaccard} \\approx 0.8333.\n$$\n这些是无量纲量。",
            "answer": "$$\\boxed{\\begin{pmatrix}0.9091  0.8333\\end{pmatrix}}$$"
        },
        {
            "introduction": "脑成像数据和图谱的分辨率常常不尽相同，这使得重采样成为一项常见的数据预处理步骤。本动手编程练习将探讨在改变图谱分辨率时，不同的插值方法——特别是最近邻法和多数投票法——如何影响脑图谱的保真度。通过在多种合成数据模式上实现和测试这些方法，你将对重采样可能带来的问题建立直观理解，并学会为你的分析选择合适的插值策略。",
            "id": "4143470",
            "problem": "您将分析使用两种插值策略，将带标签的脑分区图谱从 $1$ 毫米各向同性网格重采样到 $2$ 毫米各向同性网格对标签保真度的影响，并计算由此产生的错标率。将图谱视为一个整数区域标签（分区）的三维数组，其中每个元素对应一个体素。基本原则是：脑分区图谱是体素网格上的分段常数标签场，重采样标签场不得创建新标签，而应根据规则重新分配标签。您必须遵守以下精确定义，以使问题纯粹数学化且完全可复现。\n\n定义和算子：\n- 令 $A \\in \\mathbb{N}^{X \\times Y \\times Z}$ 表示原始的 $1$ 毫米分辨率标签图谱，其中 $X=Y=Z=8$。设标签集为正整数。定义下采样因子 $s=2$。\n- $2$ 毫米网格将 $1$ 毫米网格划分为大小为 $2 \\times 2 \\times 2$ 的非重叠块。粗网格体素由 $(I,J,K)$ 索引，其中 $I \\in \\{0,\\dots,\\frac{X}{2}-1\\}$，$J \\in \\{0,\\dots,\\frac{Y}{2}-1\\}$，$K \\in \\{0,\\dots,\\frac{Z}{2}-1\\}$。块中对应的细网格索引为 $i \\in \\{2I,2I+1\\}$，$j \\in \\{2J,2J+1\\}$，$k \\in \\{2K,2K+1\\}$。\n- 定义两个下采样算子：\n  1. 最近邻抽取 $D^{(\\mathrm{nn})}$：对于每个粗网格体素 $(I,J,K)$，\n     $$B^{(\\mathrm{nn})}_{I,J,K} \\equiv D^{(\\mathrm{nn})}(A)_{I,J,K} := A_{2I,\\,2J,\\,2K}.$$\n     这对应于拾取每个 $2 \\times 2 \\times 2$ 块左上角前方的标签。\n  2. 多数票块众数 $D^{(\\mathrm{mv})}$：对于每个粗网格体素 $(I,J,K)$，\n     $$B^{(\\mathrm{mv})}_{I,J,K} \\equiv D^{(\\mathrm{mv})}(A)_{I,J,K} := \\arg\\max_{\\ell \\in \\mathcal{L}} c_{\\ell}(I,J,K),$$\n     其中 $\\mathcal{L}$ 是块中存在的标签集合，$c_{\\ell}(I,J,K)$ 统计块中 $8$ 个细网格体素里有多少个体素的标签为 $\\ell$。如果最大计数值出现平局，则选择平局标签中值最小的那个。\n- 定义一个复制上采样算子 $U$，它通过将每个 $2 \\times 2 \\times 2$ 的块填充为其粗网格标签，从而将粗网格映射回细网格：\n  $$C_{i,j,k} \\equiv U(B)_{i,j,k} := B_{\\left\\lfloor \\frac{i}{2} \\right\\rfloor,\\, \\left\\lfloor \\frac{j}{2} \\right\\rfloor,\\, \\left\\lfloor \\frac{k}{2} \\right\\rfloor}.$$\n- 将重采样流程 $A \\mapsto B \\mapsto C$ 的错标率 $r$ 定义为上采样后标签与原始标签不同的细网格体素所占的比例：\n  $$r := \\frac{1}{XYZ} \\sum_{i=0}^{X-1} \\sum_{j=0}^{Y-1} \\sum_{k=0}^{Z-1} \\mathbf{1}\\big[ C_{i,j,k} \\neq A_{i,j,k} \\big],$$\n  其中 $\\mathbf{1}[\\cdot]$ 是指示函数。\n\n任务：\n- 对于下面定义的每个测试图谱，计算使用 $D^{(\\mathrm{nn})}$ 后跟 $U$ 的错标率 $r^{(\\mathrm{nn})}$，以及使用 $D^{(\\mathrm{mv})}$ 后跟 $U$ 的错标率 $r^{(\\mathrm{mv})}$。报告每个测试的 $r^{(\\mathrm{nn})}$ 和 $r^{(\\mathrm{mv})}$。\n\n测试集（每个图谱都根据索引 $i \\in \\{0,\\dots,7\\}$，$j \\in \\{0,\\dots,7\\}$，$k \\in \\{0,\\dots,7\\}$ 确定性地定义）：\n- 测试 $1$ (均匀图谱)：对所有 $(i,j,k)$，$A_{i,j,k} = 1$。\n- 测试 $2$ (每块稀疏角点杂质)：对所有 $(i,j,k)$，$A_{i,j,k} = 1$，但对于每个块的起始点 $(i,j,k)$，若 $i \\in \\{0,2,4,6\\}$，$j \\in \\{0,2,4,6\\}$，$k \\in \\{0,2,4,6\\}$，则设置 $A_{i,j,k} = 2$。\n- 测试 $3$ (对齐的平面边界)：如果 `i  4`，$A_{i,j,k} = 1$，否则 $A_{i,j,k} = 2$。\n- 测试 $4$ (未对齐的平面边界)：如果 `i  5`，$A_{i,j,k} = 1$，否则 $A_{i,j,k} = 2$。\n- 测试 $5$ (三维棋盘格)：如果 $(i + j + k) \\bmod 2 = 0$，$A_{i,j,k} = 1$，否则 $A_{i,j,k} = 2$。\n- 测试 $6$ (确定性多标签异质性)：$A_{i,j,k} = \\big( (7 i + 11 j + 13 k) \\bmod 3 \\big) + 1$。\n\n输出规格：\n- 您的程序必须生成一行包含按顺序排列的 $6$ 个测试结果的列表。每个结果都是一个双元素列表 $[r^{(\\mathrm{nn})}, r^{(\\mathrm{mv})}]$，其中每个浮点数四舍五入到六位小数。最终输出必须是以下形式：\n  $$\\big[ [r^{(\\mathrm{nn})}_1, r^{(\\mathrm{mv})}_1], [r^{(\\mathrm{nn})}_2, r^{(\\mathrm{mv})}_2], \\dots, [r^{(\\mathrm{nn})}_6, r^{(\\mathrm{mv})}_6] \\big],$$\n  精确地作为单行字符串打印，不含任何附加文本。\n\n科学真实性说明：\n- 脑分区图谱是表示感兴趣区域的标签场，标准做法是使用最近邻或多数票操作进行重采样，以保留标签而不进行平均。上述定义在离散网格上实例化了这些原则，以便结果是可复现和可测试的。\n\n交付成果：\n- 实现一个完整的、可运行的程序，该程序构建测试图谱，应用两种重采样流程，计算所定义的错标率，并以要求格式打印结果，小数部分四舍五入到六位。",
            "solution": "用户希望我通过首先验证其前提来解决一个数值问题。\n\n### 步骤1：提取给定信息\n- **原始图谱**：一个三维数组 $A \\in \\mathbb{N}^{X \\times Y \\times Z}$，表示在 $1$ 毫米网格上的标签图谱。\n- **维度**：$X=Y=Z=8$。\n- **下采样因子**：$s=2$。\n- **粗网格划分**：$8 \\times 8 \\times 8$ 的细网格被划分为不重叠的 $2 \\times 2 \\times 2$ 块。粗体素由 $(I,J,K)$ 索引，其中 $I,J,K \\in \\{0,1,2,3\\}$。一个块内的细体素由 $i \\in \\{2I, 2I+1\\}$，$j \\in \\{2J, 2J+1\\}$，$k \\in \\{2K, 2K+1\\}$ 索引。\n- **下采样算子1 (最近邻)**: $D^{(\\mathrm{nn})}$。下采样后的图谱 $B^{(\\mathrm{nn})}$ 定义为 $B^{(\\mathrm{nn})}_{I,J,K} := A_{2I, 2J, 2K}$。\n- **下采样算子2 (多数票)**: $D^{(\\mathrm{mv})}$。下采样后的图谱 $B^{(\\mathrm{mv})}$ 定义为 $B^{(\\mathrm{mv})}_{I,J,K} := \\arg\\max_{\\ell \\in \\mathcal{L}} c_{\\ell}(I,J,K)$，其中 $\\mathcal{L}$ 是块中标签的集合，$c_{\\ell}$ 是标签 $\\ell$ 的计数。平局通过选择并列标签中最小的标签值来解决。\n- **上采样算子**：$U$。上采样后的图谱 $C$ 定义为 $C_{i,j,k} := B_{\\left\\lfloor \\frac{i}{2} \\right\\rfloor, \\left\\lfloor \\frac{j}{2} \\right\\rfloor, \\left\\lfloor \\frac{k}{2} \\right\\rfloor}$。\n- **错标率**：$r := \\frac{1}{XYZ} \\sum_{i=0}^{X-1} \\sum_{j=0}^{Y-1} \\sum_{k=0}^{Z-1} \\mathbf{1}\\big[ C_{i,j,k} \\neq A_{i,j,k} \\big]$。\n- **任务**：对每个测试图谱，计算流程 $A \\to D^{(\\mathrm{nn})} \\to U \\to C^{(\\mathrm{nn})}$ 的错标率 $r^{(\\mathrm{nn})}$ 和流程 $A \\to D^{(\\mathrm{mv})} \\to U \\to C^{(\\mathrm{mv})}$ 的错标率 $r^{(\\mathrm{mv})}$。\n- **测试图谱 ($A_{i,j,k}$ for $i,j,k \\in \\{0,\\dots,7\\}$)**:\n  1. 均匀：$A_{i,j,k} = 1$。\n  2. 稀疏角点杂质：$A_{i,j,k} = 1$，但对于坐标为偶数的块起始点 $(i,j,k)$，$A_{i,j,k}=2$。\n  3. 对齐的平面边界：如果 $i  4$，$A_{i,j,k} = 1$，否则 $A_{i,j,k} = 2$。\n  4. 未对齐的平面边界：如果 $i  5$，$A_{i,j,k} = 1$，否则 $A_{i,j,k} = 2$。\n  5. 3D 棋盘格：如果 $(i + j + k) \\bmod 2 = 0$，$A_{i,j,k} = 1$，否则 $A_{i,j,k} = 2$。\n  6. 确定性多标签：$A_{i,j,k} = \\big( (7 i + 11 j + 13 k) \\bmod 3 \\big) + 1$。\n- **输出规格**：一个单行字符串，表示一个由双元素列表组成的列表 `[[r_nn_1, r_mv_1], [r_nn_2, r_mv_2], ...]`，其中浮点数四舍五入到六位小数。\n\n### 步骤2：使用提取的给定信息进行验证\n1.  **科学依据**：该问题是对神经影像数据分析中常见任务——重采样脑分区图谱——的明确数学抽象。所描述的方法，即最近邻和多数票，是重采样分类（标签）数据的标准实践，以避免因线性或三次插值等方法产生不存在的标签。该问题在科学上是合理的。\n2.  **适定性**：问题的所有方面都以数学精度进行了规定。维度、算子、多数票的平局决胜规则、测试数据以及最终度量标准都得到了明确的定义。这保证了存在一个唯一、稳定且有意义的解，并且可以计算出来。\n3.  **客观性**：问题以客观、数学的语言陈述，没有任何主观性或偏见。\n4.  **缺陷清单**：该问题没有违反任何无效性标准。它在科学上是合理的，完全可形式化，内部一致，计算上可行，并且是适定的。测试用例并非无足轻重，能有效地探究两种重采样方法之间的差异。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n该问题要求为一个被称为标签图谱的 $3$ 维分类数据场实现并比较两种不同的重采样流程。目标是量化将图谱从细网格下采样到粗网格，然后再上采样回原始分辨率所造成的信息损失，即“错标率”。\n\n解决方案的基本组成部分是：\n1.  生成六个不同的初始图谱，表示为 $A \\in \\mathbb{N}^{8 \\times 8 \\times 8}$。\n2.  实现两个下采样算子，$D^{(\\mathrm{nn})}$ 和 $D^{(\\mathrm{mv})}$，它们将 $8 \\times 8 \\times 8$ 的图谱 $A$ 映射到 $4 \\times 4 \\times 4$ 的粗糙图谱 $B$。\n3.  实现一个上采样算子 $U$，它将粗糙图谱 $B$ 映射回 $8 \\times 8 \\times 8$ 的图谱 $C$。\n4.  为每个流程和每个测试图谱计算错标率 $r$。\n\n首先，我们构建六个测试图谱中的每一个，表示为大小为 $8 \\times 8 \\times 8$ 的三维整数数组 $A$。每个图谱都根据其精确的数学定义生成，为每个体素 $(i,j,k)$ 提供一个“基准真相”标签。\n\n接下来，我们定义两种重采样流程。每个流程都包括一个下采样步骤和一个上采样步骤。大小为 $4 \\times 4 \\times 4$ 的粗网格将原始细网格划分为 $64$ 个大小为 $2 \\times 2 \\times 2$ 的非重叠块。\n\n第一个流程使用**最近邻抽取**算子 $D^{(\\mathrm{nn})}$。对于每个粗网格体素 $(I,J,K)$，其标签通过简单地从原始图谱 $A$ 中对应块的最小索引角点处获取。具体来说，$B^{(\\mathrm{nn})}_{I,J,K} = A_{2I, 2J, 2K}$。该方法计算简单，但可能对特征相对于采样网格的对齐方式敏感。\n\n第二个流程使用**多数票块众数**算子 $D^{(\\mathrm{mv})}$。对于每个块，该算子会识别出该块内 $8$ 个细体素中出现最频繁的标签。粗网格体素 $(I,J,K)$ 的标签被设置为此众数：$B^{(\\mathrm{mv})}_{I,J,K} = \\arg\\max_{\\ell} c_{\\ell}(I,J,K)$。此方法提供了对块内容更鲁棒的表示，因为它考虑了块内的所有体素。问题指定了一个确定性的平局决胜规则：如果多个标签共享相同的最大频率，则选择整数值最小的那个。这确保了结果的唯一性。\n\n然后，使用相同的上采样算子 $U$ 将两个下采样后的图谱 $B^{(\\mathrm{nn})}$ 和 $B^{(\\mathrm{mv})}$ 上采样回原始的 $8 \\times 8 \\times 8$ 分辨率。该算子定义为 $C_{i,j,k} = B_{\\left\\lfloor i/s \\right\\rfloor, \\left\\lfloor j/s \\right\\rfloor, \\left\\lfloor k/s \\right\\rfloor}$ (其中 $s=2$)，执行零阶保持或复制。它将细网格中的每个 $2 \\times 2 \\times 2$ 块填充为其对应粗体素的单一标签值。生成的上采样图谱表示为 $C^{(\\mathrm{nn})}$ 和 $C^{(\\mathrm{mv})}$。\n\n最后，我们量化每个流程引入的误差。错标率 $r$ 定义为上采样图谱 $C$ 中与原始图谱 $A$ 不匹配的体素所占的比例。这使用指示函数 $\\mathbf{1}[\\cdot]$ 计算：$$ r = \\frac{1}{XYZ} \\sum_{i=0}^{X-1} \\sum_{j=0}^{Y-1} \\sum_{k=0}^{Z-1} \\mathbf{1}\\big[ C_{i,j,k} \\neq A_{i,j,k} \\big] $$ 我们为两个流程计算此比率，得到 $r^{(\\mathrm{nn})}$ 和 $r^{(\\mathrm{mv})}$。\n\n整个算法通过迭代六个测试用例来执行。对于每个用例，生成图谱 $A$。然后，计算并存储 $r^{(\\mathrm{nn})}$ 和 $r^{(\\mathrm{mv})}$。最终输出是这些成对结果的汇总。这个系统化的过程可以直接比较最近邻重采样与多数票重采样在各种空间模式下保留标签保真度的效果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import mode\n\ndef solve():\n    \"\"\"\n    Solves the brain atlas resampling problem for all specified test cases.\n    \"\"\"\n    X, Y, Z = 8, 8, 8\n    S = 2\n    TOTAL_VOXELS = X * Y * Z\n    \n    # List of functions to generate each test atlas\n    test_generators = [\n        generate_test_1,\n        generate_test_2,\n        generate_test_3,\n        generate_test_4,\n        generate_test_5,\n        generate_test_6,\n    ]\n\n    results = []\n    for gen_func in test_generators:\n        atlas_a = gen_func(X, Y, Z)\n        \n        # Pipeline 1: Nearest-Neighbor\n        atlas_b_nn = downsample_nn(atlas_a, S)\n        atlas_c_nn = upsample_replicate(atlas_b_nn, S)\n        r_nn = np.sum(atlas_c_nn != atlas_a) / TOTAL_VOXELS\n        \n        # Pipeline 2: Majority-Vote\n        atlas_b_mv = downsample_mv(atlas_a, S)\n        atlas_c_mv = upsample_replicate(atlas_b_mv, S)\n        r_mv = np.sum(atlas_c_mv != atlas_a) / TOTAL_VOXELS\n        \n        # Format the result for the current test case as specified\n        results.append(f\"[{r_nn:.6f},{r_mv:.6f}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\ndef generate_test_1(X, Y, Z):\n    \"\"\"Test 1 (Uniform atlas): A_ijk = 1 for all (i,j,k).\"\"\"\n    return np.ones((X, Y, Z), dtype=int)\n\ndef generate_test_2(X, Y, Z):\n    \"\"\"Test 2 (Sparse corner impurity per block): A_ijk = 1, except A_ijk = 2 at block corners.\"\"\"\n    A = np.ones((X, Y, Z), dtype=int)\n    for i in range(0, X, 2):\n        for j in range(0, Y, 2):\n            for k in range(0, Z, 2):\n                A[i, j, k] = 2\n    return A\n\ndef generate_test_3(X, Y, Z):\n    \"\"\"Test 3 (Aligned planar boundary): A_ijk = 1 if i  4, else A_ijk = 2.\"\"\"\n    A = np.ones((X, Y, Z), dtype=int)\n    A[4:, :, :] = 2\n    return A\n\ndef generate_test_4(X, Y, Z):\n    \"\"\"Test 4 (Misaligned planar boundary): A_ijk = 1 if i  5, else A_ijk = 2.\"\"\"\n    A = np.ones((X, Y, Z), dtype=int)\n    A[5:, :, :] = 2\n    return A\n\ndef generate_test_5(X, Y, Z):\n    \"\"\"Test 5 (Three-dimensional checkerboard): A_ijk = 1 if (i+j+k) mod 2 = 0, else 2.\"\"\"\n    i, j, k = np.mgrid[0:X, 0:Y, 0:Z]\n    A = ((i + j + k) % 2) + 1\n    return A.astype(int)\n\ndef generate_test_6(X, Y, Z):\n    \"\"\"Test 6 (Deterministic multi-label heterogeneity): A_ijk = ((7i+11j+13k) mod 3) + 1.\"\"\"\n    i, j, k = np.mgrid[0:X, 0:Y, 0:Z]\n    A = ((7 * i + 11 * j + 13 * k) % 3) + 1\n    return A.astype(int)\n\ndef downsample_nn(A, s):\n    \"\"\"Downsamples a 3D atlas using nearest-neighbor decimation.\"\"\"\n    return A[::s, ::s, ::s]\n\ndef downsample_mv(A, s):\n    \"\"\"Downsamples a 3D atlas using majority-vote block mode.\"\"\"\n    X, Y, Z = A.shape\n    Xc, Yc, Zc = X // s, Y // s, Z // s\n    B = np.zeros((Xc, Yc, Zc), dtype=A.dtype)\n    \n    for I in range(Xc):\n        for J in range(Yc):\n            for K in range(Zc):\n                block = A[I*s:(I+1)*s, J*s:(J+1)*s, K*s:(K+1)*s]\n                # scipy.stats.mode with default parameters breaks ties by choosing the smallest value,\n                # which matches the problem specification.\n                # The returned object has attributes .mode and .count. We only need the mode.\n                B[I, J, K] = mode(block, axis=None, keepdims=False).mode\n    return B\n\ndef upsample_replicate(B, s):\n    \"\"\"Upsamples a 3D atlas by replicating coarse voxels into blocks.\"\"\"\n    # np.kron is a convenient way to perform block replication\n    return np.kron(B, np.ones((s, s, s), dtype=B.dtype))\n\nsolve()\n```"
        },
        {
            "introduction": "在分析一组被试的大脑数据时，一个关键挑战是如何处理个体间的解剖结构差异并确保其与公共图谱的精确对齐。本项高级练习将引入一种信息论方法，利用香农熵来量化皮层表面每个位置上脑区标签在不同被试间的一致性。你将编写代码来识别高变异性区域，并将其与解剖边界联系起来，从而学习一种评估被试间配准质量和定位真实解剖差异区域的强大技术。",
            "id": "4143439",
            "problem": "给定一个表示离散化皮层表面的有限顶点集、一个编码表面拓扑的邻接结构、一组个体被试的分区标签，以及一个组图谱标签。您的目标是通过计算每个顶点上标签的香农熵来评估跨被试对齐情况，量化与组图谱的一致性，并使用基于邻接的边界敏感性指数将高熵与解剖学变异性或配准错误联系起来。本问题中的所有量均无单位。\n\n基本和核心定义：\n- 设有 $V$ 个顶点，索引为 $v \\in \\{0,1,\\dots,V-1\\}$，以及 $S$ 个被试，索引为 $s \\in \\{0,1,\\dots,S-1\\}$。\n- 设标签集为一个有限集 $L = \\{0,1,\\dots,K-1\\}$。\n- 设 $l_{s,v} \\in L$ 表示被试 $s$ 在顶点 $v$ 处的标签。\n- 设 $g_v \\in L$ 表示顶点 $v$ 处的组图谱标签。\n- 设 $N(v)$ 表示在邻接关系下顶点 $v$ 的邻居集合。\n\n您必须根据经过充分测试的公式和定义执行以下计算：\n\n1. 每个顶点的经验标签分布：\n   对于每个顶点 $v$，计算经验概率\n   $$p_{v,l} = \\frac{1}{S} \\sum_{s=0}^{S-1} \\mathbf{1}\\{l_{s,v} = l\\}, \\quad \\text{对于所有 } l \\in L,$$\n   其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n2. 每个顶点的香农熵：\n   使用经验分布 $\\{p_{v,l}\\}_{l \\in L}$，计算熵\n   $$H_v = -\\sum_{l \\in L} p_{v,l} \\log p_{v,l},$$\n   约定 $0 \\log 0 = 0$ 且对数底为 $e$（自然对数）。熵以奈特（nats）为单位。\n\n3. 与组图谱的一致率：\n   对于每个顶点 $v$，计算\n   $$A_v = \\frac{1}{S} \\sum_{s=0}^{S-1} \\mathbf{1}\\{l_{s,v} = g_v\\}.$$\n\n4. 边界邻近指数：\n   仅根据组图谱标签和邻接关系定义边界敏感性：\n   $$B_v = \\frac{1}{|N(v)|} \\sum_{u \\in N(v)} \\mathbf{1}\\{g_u \\neq g_v\\},$$\n   其中 $|N(v)|$ 是顶点 $v$ 的度。该指数在图谱边界附近较高，在远离边界处为零。\n\n5. 熵与边界邻近性之间的相关性：\n   计算 $\\{H_v\\}_{v=0}^{V-1}$ 和 $\\{B_v\\}_{v=0}^{V-1}$ 之间的皮尔逊相关系数：\n   $$\\rho = \\frac{\\sum_{v=0}^{V-1} (H_v - \\bar{H})(B_v - \\bar{B})}{\\sqrt{\\sum_{v=0}^{V-1} (H_v - \\bar{H})^2}\\sqrt{\\sum_{v=0}^{V-1} (B_v - \\bar{B})^2}},$$\n   其中 $\\bar{H}$ 和 $\\bar{B}$ 是所有顶点的平均值。如果任一分母项为零（$\\{H_v\\}$ 或 $\\{B_v\\}$ 的方差为零），则按惯例定义 $\\rho = 0$。\n\n6. 配准敏感顶点分类：\n   使用阈值 $\\tau_B$ 和 $\\tau_A$，如果满足以下条件，则将顶点 $v$ 分类为配准敏感型\n   $$R_v = \\mathbf{1}\\{B_v \\ge \\tau_B \\ \\land \\ A_v  \\tau_A\\}.$$\n   然后计算配准敏感顶点的比例\n   $$F = \\frac{1}{V}\\sum_{v=0}^{V-1} R_v.$$\n\n您的程序必须实现上述计算，并为每个测试用例返回三元组 $[\\bar{H}, \\rho, F]$，其中\n$$\\bar{H} = \\frac{1}{V}\\sum_{v=0}^{V-1} H_v.$$\n\n测试套件：\n您必须使用以下三个具有指定参数的测试用例。所有标签值都是整数且无单位。\n\n- 测试用例 1（边界相关配准错误的理想路径）：\n  - $V = 12$, $S = 10$, $L = \\{0,1\\}$。\n  - 邻接关系：一个包含 $12$ 个顶点的路径图，$N(v) = \\{v-1, v+1\\}$（在有定义的情况下）；端点只有一个邻居。\n  - 组图谱标签：对于 $v \\in \\{0,1,2,3,4,5\\}$，$g_v = 0$；对于 $v \\in \\{6,7,8,9,10,11\\}$，$g_v = 1$。\n  - 个体标签：从所有 $s,v$ 的 $l_{s,v} = g_v$ 开始，然后引入边界配准错误：\n    - 在 $v = 5$ 处，对于 $s \\in \\{0,3,7\\}$，设置 $l_{s,5} = 1$。\n    - 在 $v = 6$ 处，对于 $s \\in \\{2,4\\}$，设置 $l_{s,6} = 0$。\n  - 阈值：$\\tau_B = 0.5$, $\\tau_A = 0.85$。\n\n- 测试用例 2（完美对齐）：\n  - $V = 12$, $S = 10$, $L = \\{0,1\\}$。\n  - 邻接关系：与测试用例 1 相同的路径图。\n  - 组图谱标签：与测试用例 1 相同。\n  - 个体标签：对于所有 $s,v$，$l_{s,v} = g_v$。\n  - 阈值：$\\tau_B = 0.5$, $\\tau_A = 0.85$。\n\n- 测试用例 3（远离边界的解剖学变异）：\n  - $V = 12$, $S = 10$, $L = \\{0,1\\}$。\n  - 邻接关系：与测试用例 1 相同的路径图。\n  - 组图谱标签：与测试用例 1 相同。\n  - 个体标签：从 $l_{s,v} = g_v$ 开始，然后引入内部变异：\n    - 在 $v = 2$ 处，对于 $s \\in \\{0,1,2,3,4\\}$，设置 $l_{s,2} = 1$。\n    - 在 $v = 9$ 处，对于 $s \\in \\{5,6,7,8,9\\}$，设置 $l_{s,9} = 0$。\n  - 阈值：$\\tau_B = 0.5$, $\\tau_A = 0.85$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例按顺序贡献其自己的三元素列表。所需格式为\n$$[[\\bar{H}_1,\\rho_1,F_1],[\\bar{H}_2,\\rho_2,F_2],[\\bar{H}_3,\\rho_3,F_3]],$$\n不打印任何附加文本。",
            "solution": "该问题要求实现一系列标准的神经信息学指标，以评估皮层表面分区中的被试间变异性和配准质量。验证过程证实了该问题陈述在科学上是合理的、适定的、客观的和完整的。所有定义和公式在信息论和统计学等领域都是标准的，并且直接适用于神经影像数据的分析。所提供的测试用例定义明确，用于说明数据变异性的不同场景。因此，我们可以着手进行原则性的求解。\n\n总体方法是创建一个计算流程，处理每个测试用例的给定数据——顶点数 $V$、被试数 $S$、标签集 $L$、邻接结构、组图谱标签 $g_v$ 和个体被试标签 $l_{s,v}$——以生成所需的三元组输出 $[\\bar{H}, \\rho, F]$。\n\n单个测试用例的逐步过程如下：\n\n1.  **数据表示**：输入使用数值数组表示以实现高效计算。个体被试标签 $l_{s,v}$ 构成一个大小为 $S \\times V$ 的矩阵，组图谱标签 $g_v$ 构成一个大小为 $V$ 的向量，邻接结构表示为一个列表的列表，其中每个内部列表包含相邻顶点的索引。\n\n2.  **经验标签分布 ($p_{v,l}$)**：对于每个顶点 $v$，我们统计所有 $S$ 个被试中每个可能标签 $l \\in L$ 的出现次数。然后将这些计数除以 $S$ 进行归一化，得到该顶点的经验概率分布 $\\{p_{v,l}\\}_{l \\in L}$。这将产生一个大小为 $V \\times K$ 的概率矩阵，其中 $K = |L|$。\n\n3.  **香农熵 ($H_v$)**：使用计算出的概率 $p_{v,l}$，每个顶点 $v$ 的香农熵计算为 $H_v = -\\sum_{l \\in L} p_{v,l} \\log_e p_{v,l}$。使用自然对数，并处理 $0 \\log_e 0 = 0$ 的约定，确保只对非零概率计算对数。这将产生一个熵值向量 $\\{H_v\\}_{v=0}^{V-1}$。然后通过对此向量求平均值来计算平均熵 $\\bar{H}$。\n\n4.  **与组图谱的一致性 ($A_v$)**：对于每个顶点 $v$，一致率是其标签 $l_{s,v}$ 与组图谱标签 $g_v$ 相匹配的被试所占的比例。其计算公式为 $A_v = \\frac{1}{S} \\sum_{s=0}^{S-1} \\mathbf{1}\\{l_{s,v} = g_v\\}$，从而得到一个一致率向量 $\\{A_v\\}_{v=0}^{V-1}$。\n\n5.  **边界邻近指数 ($B_v$)**：该指数用于量化顶点 $v$ 与组图谱 $g$ 中边界的接近程度。对于每个顶点 $v$，我们检查其邻居 $u \\in N(v)$。指数 $B_v$ 是其图谱标签 $g_u$ 与 $g_v$ 不同的邻居所占的比例：$B_v = \\frac{1}{|N(v)|} \\sum_{u \\in N(v)} \\mathbf{1}\\{g_u \\neq g_v\\}$。此计算产生一个向量 $\\{B_v\\}_{v=0}^{V-1}$。\n\n6.  **相关性 ($\\rho$)**：计算熵向量 $\\{H_v\\}$ 和边界邻近向量 $\\{B_v\\}$ 之间的皮尔逊相关系数 $\\rho$。计算遵循标准公式：\n    $$\\rho = \\frac{\\sum_{v=0}^{V-1} (H_v - \\bar{H})(B_v - \\bar{B})}{\\sqrt{\\sum_{v=0}^{V-1} (H_v - \\bar{H})^2}\\sqrt{\\sum_{v=0}^{V-1} (B_v - \\bar{B})^2}}$$\n    实现了一个特殊条件：如果 $\\{H_v\\}$ 或 $\\{B_v\\}$ 的方差为零（即相应的分母项为零），则 $\\rho$ 定义为 $0$。\n\n7.  **配准敏感顶点比例 ($F$)**：如果一个顶点 $v$ 位于图谱边界附近 ($B_v \\ge \\tau_B$)，同时与组图谱的一致性较低 ($A_v  \\tau_A$)，则将其分类为“配准敏感型”。通过对所有顶点求和指示函数 $R_v = \\mathbf{1}\\{B_v \\ge \\tau_B \\land A_v  \\tau_A\\}$ 并除以 $V$，计算出此类顶点的总比例 $F$。\n\n这套完整的计算序列将应用于问题中指定的三个测试用例中的每一个，最终结果汇总成所需的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_metrics(V, S, L, adj, g_v, l_sv, tau_A, tau_B):\n    \"\"\"\n    Computes all require metrics for a single test case.\n    \"\"\"\n    K = len(L)\n\n    # 1. Empirical label distribution p_{v,l}\n    p_vl = np.zeros((V, K))\n    for v in range(V):\n        # np.bincount is efficient for counting occurrences of integers in an array.\n        labels_at_v = l_sv[:, v]\n        counts = np.bincount(labels_at_v, minlength=K)\n        p_vl[v, :] = counts / S\n\n    # 2. Shannon entropy H_v and its mean H_bar\n    # The 'where' argument prevents log(0) warnings.\n    log_p = np.log(p_vl, where=(p_vl > 0), out=np.zeros_like(p_vl, dtype=float))\n    H_v = -np.sum(p_vl * log_p, axis=1)\n    H_bar = np.mean(H_v)\n\n    # 3. Agreement rate A_v\n    # Compare each subject's labels with the group atlas labels.\n    # g_v is broadcasted from (V,) to (1, V) to match l_sv's shape (S, V).\n    agreement_matrix = (l_sv == g_v[None, :])\n    A_v = np.mean(agreement_matrix, axis=0)\n\n    # 4. Boundary proximity index B_v\n    B_v = np.zeros(V, dtype=float)\n    for v in range(V):\n        neighbors = adj[v]\n        if not neighbors:\n            continue\n        num_neighbors = len(neighbors)\n        neighbor_labels = g_v[neighbors]\n        num_mismatches = np.sum(neighbor_labels != g_v[v])\n        B_v[v] = num_mismatches / num_neighbors\n\n    # 5. Correlation rho\n    # Check for zero variance as per problem specification.\n    var_H = np.var(H_v)\n    var_B = np.var(B_v)\n\n    if var_H == 0 or var_B == 0:\n        rho = 0.0\n    else:\n        # Standard Pearson correlation formula.\n        mean_H = np.mean(H_v)\n        mean_B = np.mean(B_v)\n        numerator = np.sum((H_v - mean_H) * (B_v - mean_B))\n        denominator_H = np.sqrt(np.sum((H_v - mean_H)**2))\n        denominator_B = np.sqrt(np.sum((B_v - mean_B)**2))\n        rho = numerator / (denominator_H * denominator_B)\n\n    # 6. Registration-sensitive fraction F\n    R_v_mask = (B_v >= tau_B)  (A_v  tau_A)\n    F = np.mean(R_v_mask.astype(float))\n\n    return [H_bar, rho, F]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    V = 12\n    S = 10\n    L = {0, 1}\n    adj = [([v - 1, v + 1] if 1 = v = V - 2 else ([1] if v == 0 else [V - 2])) for v in range(V)]\n    g_v = np.array([0] * 6 + [1] * 6, dtype=int)\n    tau_A = 0.85\n    tau_B = 0.5\n\n    test_cases_data = []\n\n    # Test Case 1\n    l_sv_1 = np.tile(g_v, (S, 1))\n    l_sv_1[[0, 3, 7], 5] = 1\n    l_sv_1[[2, 4], 6] = 0\n    test_cases_data.append(l_sv_1)\n\n    # Test Case 2\n    l_sv_2 = np.tile(g_v, (S, 1))\n    test_cases_data.append(l_sv_2)\n\n    # Test Case 3\n    l_sv_3 = np.tile(g_v, (S, 1))\n    l_sv_3[list(range(5)), 2] = 1\n    l_sv_3[list(range(5, 10)), 9] = 0\n    test_cases_data.append(l_sv_3)\n\n    results = []\n    for l_sv in test_cases_data:\n        case_result = compute_metrics(V, S, L, adj, g_v, l_sv, tau_A, tau_B)\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The format string ensures a compact representation.\n    # Ex: [[a,b,c],[d,e,f]]\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}