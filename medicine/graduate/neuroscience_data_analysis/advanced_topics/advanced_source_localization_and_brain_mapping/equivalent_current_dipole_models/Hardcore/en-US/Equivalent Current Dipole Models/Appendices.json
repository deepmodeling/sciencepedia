{
    "hands_on_practices": [
        {
            "introduction": "To effectively use EEG and MEG, it is essential to understand their fundamentally different sensitivities to the orientation of underlying neural currents. This exercise explores this core principle by modeling a common neuroanatomical feature: a cortical sulcus. By calculating the idealized signals from opposing dipoles , you will derive from first principles why MEG is primarily sensitive to tangential currents, while EEG is dominated by radial currents.",
            "id": "4142685",
            "problem": "Consider a spherically symmetric head model with homogeneous isotropic conductivity $\\sigma$ and radius $R$, in which the cortex is a thin shell at radius $a$ with $0<a<R$. Work under the quasi-static approximation of Maxwell's equations, where displacement currents are negligible, Ohm's law holds as $\\mathbf{J}_{v}=\\sigma \\mathbf{E}$, the electric field satisfies $\\mathbf{E}=-\\nabla V$ with $V$ the electric potential, and the magnetic field is determined by $\\nabla \\times \\mathbf{B}=\\mu_{0}(\\mathbf{J}_{p}+\\mathbf{J}_{v})$ with $\\mathbf{J}_{p}$ the primary neuronal current density. Assume that each local cortical patch can be modeled by an equivalent current dipole with moment $\\mathbf{p}$ located at $\\mathbf{r}_{0}$.\n\nA narrow sulcus is modeled as two opposing cortical walls at equal depth $a$, separated by a small distance compared to $R$, with local orthonormal basis composed of the outward spherical radial unit vector $\\hat{\\mathbf{r}}$ and a local tangential unit vector $\\hat{\\mathbf{t}}$ along the sulcal wall. Two equal-magnitude equivalent current dipoles of moments $\\mathbf{p}_{1}$ and $\\mathbf{p}_{2}$, each of magnitude $p=|\\mathbf{p}_{1}|=|\\mathbf{p}_{2}|$, are placed on the two opposing sulcal walls such that their moments align with the local cortical columns and the geometry satisfies\n$$\n\\hat{\\mathbf{n}}_{1}=\\cos\\theta\\,\\hat{\\mathbf{t}}+\\sin\\theta\\,\\hat{\\mathbf{r}},\\qquad\n\\hat{\\mathbf{n}}_{2}=-\\cos\\theta\\,\\hat{\\mathbf{t}}+\\sin\\theta\\,\\hat{\\mathbf{r}},\n$$\nwith $\\theta \\in (0,\\pi/2)$ quantifying the sulcal wall tilt relative to the local tangent $\\hat{\\mathbf{t}}$; the two walls have opposite tangential components and identical radial components. The dipole moments are $\\mathbf{p}_{1}=p\\,\\hat{\\mathbf{n}}_{1}$ and $\\mathbf{p}_{2}=p\\,\\hat{\\mathbf{n}}_{2}$.\n\nUsing the quasi-static electromagnetic equations and spherical symmetry, justify from first principles that, outside the spherical conductor, the magnetoencephalography (MEG) signal is identically insensitive to the radial component of a current dipole, while the electroencephalography (EEG) potential measured on the scalp is dominantly driven by the radial component. Define the modality-specific net signals in normalized units by\n$$\nS_{\\mathrm{EEG}}:=\\left(\\mathbf{p}_{1}\\cdot\\hat{\\mathbf{r}}\\right)+\\left(\\mathbf{p}_{2}\\cdot\\hat{\\mathbf{r}}\\right),\\qquad\nS_{\\mathrm{MEG}}:=\\left|\\left(\\mathbf{p}_{1}\\cdot\\hat{\\mathbf{t}}\\right)+\\left(\\mathbf{p}_{2}\\cdot\\hat{\\mathbf{t}}\\right)\\right|,\n$$\nwhich idealize the differential orientation sensitivities of electroencephalography (EEG) and magnetoencephalography (MEG) under spherical symmetry. Compute the pair $\\left(S_{\\mathrm{EEG}},S_{\\mathrm{MEG}}\\right)$ as a closed-form analytic expression in terms of $p$ and $\\theta$, and provide your final answer as a two-entry row matrix. Express the final answer in these dimensionless normalized units; no physical units are required. No rounding is needed.",
            "solution": "The user wants me to solve a problem in the context of biophysical modeling of EEG and MEG signals.\n\n### Step 1: Extract Givens\n- **Model:** Spherically symmetric head model with homogeneous isotropic conductivity $\\sigma$ and radius $R$.\n- **Cortex:** A thin shell at radius $a$ where $0 < a < R$.\n- **Physics:** Quasi-static approximation of Maxwell's equations.\n- **Constitutive Relations:** Ohm's law $\\mathbf{J}_{v}=\\sigma \\mathbf{E}$, and $\\mathbf{E}=-\\nabla V$.\n- **Maxwell's Equation:** $\\nabla \\times \\mathbf{B}=\\mu_{0}(\\mathbf{J}_{p}+\\mathbf{J}_{v})$.\n- **Source Model:** Equivalent current dipole with moment $\\mathbf{p}$ at location $\\mathbf{r}_{0}$.\n- **Sulcus Model:** Two opposing cortical walls at depth $a$. Local orthonormal basis is $\\{\\hat{\\mathbf{r}}, \\hat{\\mathbf{t}}\\}$.\n- **Dipole Moments:** Two dipoles $\\mathbf{p}_{1}$ and $\\mathbf{p}_{2}$ with equal magnitude $p=|\\mathbf{p}_{1}|=|\\mathbf{p}_{2}|$.\n- **Dipole Orientations:** $\\mathbf{p}_{1}=p\\,\\hat{\\mathbf{n}}_{1}$ and $\\mathbf{p}_{2}=p\\,\\hat{\\mathbf{n}}_{2}$, where the orientation vectors are:\n  $$\n  \\hat{\\mathbf{n}}_{1}=\\cos\\theta\\,\\hat{\\mathbf{t}}+\\sin\\theta\\,\\hat{\\mathbf{r}}\n  $$\n  $$\n  \\hat{\\mathbf{n}}_{2}=-\\cos\\theta\\,\\hat{\\mathbf{t}}+\\sin\\theta\\,\\hat{\\mathbf{r}}\n  $$\n  with $\\theta \\in (0,\\pi/2)$.\n- **Signal Definitions:** Idealized modality-specific signals are defined as:\n  $$\n  S_{\\mathrm{EEG}}:=\\left(\\mathbf{p}_{1}\\cdot\\hat{\\mathbf{r}}\\right)+\\left(\\mathbf{p}_{2}\\cdot\\hat{\\mathbf{r}}\\right)\n  $$\n  $$\n  S_{\\mathrm{MEG}}:=\\left|\\left(\\mathbf{p}_{1}\\cdot\\hat{\\mathbf{t}}\\right)+\\left(\\mathbf{p}_{2}\\cdot\\hat{\\mathbf{t}}\\right)\\right|\n  $$\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded:** The problem is firmly rooted in the standard biophysical framework for modeling EEG and MEG signals. The use of a spherical head model, the quasi-static approximation of Maxwell's equations, and the equivalent current dipole are all cornerstone concepts in this field. The model of a sulcus with opposing dipoles is a classical and widely used paradigm to explain differential sensitivity of EEG and MEG.\n2.  **Well-Posed:** The problem is well-posed. It first asks for a justification based on established physical principles and then requires a direct calculation based on explicitly provided definitions. The definitions and geometric setup are precise, ensuring a unique solution exists.\n3.  **Objective:** The language is formal, precise, and objective. The use of terms like \"idealize\" acknowledges the simplified nature of the signal definitions, which does not constitute a flaw but rather a standard modeling choice.\n4.  **Complete and Consistent:** All necessary information is provided. The geometric setup, physical laws, and definitions for the quantities to be computed are self-contained and consistent.\n5.  **Not Ill-Posed or Trivial:** The first part requires a non-trivial physical argument, and the second part is a straightforward but meaningful application of vector algebra that illustrates a key concept in neuroimaging.\n\n### Step 3: Verdict and Action\nThe problem is valid. It represents a standard, albeit simplified, problem in the biophysics of neuroelectromagnetic signals. I will proceed with the solution.\n\n### Part 1: Justification of EEG/MEG Sensitivity\n\nThe differential sensitivity of EEG and MEG to the orientation of neural current sources is a fundamental principle that arises from the physics of electromagnetism within a spherically symmetric volume conductor, which is a good first-order approximation for the head.\n\n**Magnetoencephalography (MEG) Sensitivity:**\nMEG works by measuring the weak magnetic fields outside the head produced by neuronal currents. Within the quasi-static approximation, the magnetic field $\\mathbf{B}$ is generated by both the primary current density $\\mathbf{J}_{p}$ (the neural source) and the volume current density $\\mathbf{J}_{v}$ (the passive return currents flowing through the conductive tissue). The contribution of the volume currents to the external magnetic field can be expressed using the Biot-Savart law as:\n$$\n\\mathbf{B}_{v}(\\mathbf{r}) = \\frac{\\mu_{0}}{4\\pi} \\int \\frac{\\mathbf{J}_{v}(\\mathbf{r}') \\times (\\mathbf{r} - \\mathbf{r}')}{|\\mathbf{r} - \\mathbf{r}'|^3} d^3 r' = -\\frac{\\mu_{0}\\sigma}{4\\pi} \\int \\frac{(\\nabla' V(\\mathbf{r}')) \\times (\\mathbf{r} - \\mathbf{r}')}{|\\mathbf{r} - \\mathbf{r}'|^3} d^3 r'\n$$\nFor a spherically symmetric conductor, a key result first shown by Geselowitz and extensively analyzed by Sarvas states that the magnetic field outside the conductor produced by a current dipole $\\mathbf{p}$ at $\\mathbf{r}_0$ is given by:\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0}{4\\pi} \\frac{F(\\mathbf{r}, \\mathbf{r}_0)(\\mathbf{p} \\times \\mathbf{r}_0) - (\\mathbf{p} \\times \\mathbf{r}_0 \\cdot \\mathbf{r})\\nabla F(\\mathbf{r}, \\mathbf{r}_0)}{F(\\mathbf{r}, \\mathbf{r}_0)^2}\n$$\nwhere $F(\\mathbf{r}, \\mathbf{r}_0) = a(ra+r^2-\\mathbf{r}_0 \\cdot \\mathbf{r})$ with $a=|\\mathbf{r}-\\mathbf{r}_0|$ and $r=|\\mathbf{r}|$.\nNow, consider a purely radial dipole, where the dipole moment $\\mathbf{p}$ is parallel to its position vector $\\mathbf{r}_0$. In this case, $\\mathbf{p} = k\\mathbf{r}_0$ for some scalar $k$. The cross product term $\\mathbf{p} \\times \\mathbf{r}_0 = (k\\mathbf{r}_0) \\times \\mathbf{r}_0 = \\mathbf{0}$. Consequently, the entire expression for $\\mathbf{B}(\\mathbf{r})$ becomes zero.\nThis means that a current dipole with a purely radial orientation generates no magnetic field outside a spherically symmetric conductor. The physical intuition is that the volume currents induced by a radial source are perfectly symmetric around the radial axis, and their magnetic fields exactly cancel the magnetic field produced by the primary current source itself when measured outside the sphere. Therefore, MEG is fundamentally insensitive to the radial component of any current source within this model. It is only sensitive to the tangential components. The problem's definition of $S_{\\mathrm{MEG}}$ is a direct idealization of this principle.\n\n**Electroencephalography (EEG) Sensitivity:**\nEEG measures the electric potential difference $V$ on the scalp surface. The potential is governed by Poisson's equation $\\nabla \\cdot (\\sigma \\nabla V) = \\nabla \\cdot \\mathbf{J}_p$. For a current dipole $\\mathbf{J}_p = \\mathbf{p} \\delta(\\mathbf{r}-\\mathbf{r}_0)$, the source term is effectively a spatial derivative of a delta function, representing a closely spaced source and sink of current.\nA radial dipole places this source and sink along a radial line. This creates a flow of current that travels radially outwards and inwards, setting up charge distributions on the boundaries between media of different conductivity (e.g., cortex-skull, skull-scalp, scalp-air). This leads to a strong potential field on the scalp that has a classic dipolar pattern.\nA tangential dipole, on the other hand, places the source and sink side-by-side tangentially to the spherical surface. While it also creates a potential field, its positive and negative extrema are closer together on the scalp surface. As the measurement point (scalp) is distant from the source (cortex), the fields from the closely spaced positive and negative poles of the tangential source tend to cancel more effectively than for a radial source. This results in the scalp potential from a tangential dipole being significantly weaker than that from a radial dipole of the same magnitude. Therefore, the EEG signal is said to be \"dominantly driven\" by the radial component of the current source. The problem's definition of $S_{\\mathrm{EEG}}$ idealizes this dominance.\n\n### Part 2: Calculation of Idealized Signals\n\nWe are given the dipole moments:\n$$\n\\mathbf{p}_{1} = p\\,\\hat{\\mathbf{n}}_{1} = p(\\cos\\theta\\,\\hat{\\mathbf{t}}+\\sin\\theta\\,\\hat{\\mathbf{r}})\n$$\n$$\n\\mathbf{p}_{2} = p\\,\\hat{\\mathbf{n}}_{2} = p(-\\cos\\theta\\,\\hat{\\mathbf{t}}+\\sin\\theta\\,\\hat{\\mathbf{r}})\n$$\nThe basis vectors $\\hat{\\mathbf{r}}$ and $\\hat{\\mathbf{t}}$ are orthonormal, meaning $\\hat{\\mathbf{r}} \\cdot \\hat{\\mathbf{r}} = 1$, $\\hat{\\mathbf{t}} \\cdot \\hat{\\mathbf{t}} = 1$, and $\\hat{\\mathbf{r}} \\cdot \\hat{\\mathbf{t}} = 0$.\n\n**Calculation of $S_{\\mathrm{EEG}}$:**\nThe definition is $S_{\\mathrm{EEG}} = (\\mathbf{p}_{1}\\cdot\\hat{\\mathbf{r}}) + (\\mathbf{p}_{2}\\cdot\\hat{\\mathbf{r}})$.\nFirst, we compute the projection of each dipole moment onto the radial unit vector $\\hat{\\mathbf{r}}$:\n$$\n\\mathbf{p}_{1}\\cdot\\hat{\\mathbf{r}} = p(\\cos\\theta\\,\\hat{\\mathbf{t}}+\\sin\\theta\\,\\hat{\\mathbf{r}}) \\cdot \\hat{\\mathbf{r}} = p(\\cos\\theta(\\hat{\\mathbf{t}}\\cdot\\hat{\\mathbf{r}}) + \\sin\\theta(\\hat{\\mathbf{r}}\\cdot\\hat{\\mathbf{r}}))\n= p(\\cos\\theta \\cdot 0 + \\sin\\theta \\cdot 1) = p\\sin\\theta\n$$\n$$\n\\mathbf{p}_{2}\\cdot\\hat{\\mathbf{r}} = p(-\\cos\\theta\\,\\hat{\\mathbf{t}}+\\sin\\theta\\,\\hat{\\mathbf{r}}) \\cdot \\hat{\\mathbf{r}} = p(-\\cos\\theta(\\hat{\\mathbf{t}}\\cdot\\hat{\\mathbf{r}}) + \\sin\\theta(\\hat{\\mathbf{r}}\\cdot\\hat{\\mathbf{r}}))\n= p(-\\cos\\theta \\cdot 0 + \\sin\\theta \\cdot 1) = p\\sin\\theta\n$$\nNow, we sum these two components:\n$$\nS_{\\mathrm{EEG}} = p\\sin\\theta + p\\sin\\theta = 2p\\sin\\theta\n$$\n\n**Calculation of $S_{\\mathrm{MEG}}$:**\nThe definition is $S_{\\mathrm{MEG}} = |(\\mathbf{p}_{1}\\cdot\\hat{\\mathbf{t}}) + (\\mathbf{p}_{2}\\cdot\\hat{\\mathbf{t}})|$.\nFirst, we compute the projection of each dipole moment onto the tangential unit vector $\\hat{\\mathbf{t}}$:\n$$\n\\mathbf{p}_{1}\\cdot\\hat{\\mathbf{t}} = p(\\cos\\theta\\,\\hat{\\mathbf{t}}+\\sin\\theta\\,\\hat{\\mathbf{r}}) \\cdot \\hat{\\mathbf{t}} = p(\\cos\\theta(\\hat{\\mathbf{t}}\\cdot\\hat{\\mathbf{t}}) + \\sin\\theta(\\hat{\\mathbf{r}}\\cdot\\hat{\\mathbf{t}}))\n= p(\\cos\\theta \\cdot 1 + \\sin\\theta \\cdot 0) = p\\cos\\theta\n$$\n$$\n\\mathbf{p}_{2}\\cdot\\hat{\\mathbf{t}} = p(-\\cos\\theta\\,\\hat{\\mathbf{t}}+\\sin\\theta\\,\\hat{\\mathbf{r}}) \\cdot \\hat{\\mathbf{t}} = p(-\\cos\\theta(\\hat{\\mathbf{t}}\\cdot\\hat{\\mathbf{t}}) + \\sin\\theta(\\hat{\\mathbf{r}}\\cdot\\hat{\\mathbf{t}}))\n= p(-\\cos\\theta \\cdot 1 + \\sin\\theta \\cdot 0) = -p\\cos\\theta\n$$\nNow, we sum these two components and take the absolute value:\n$$\nS_{\\mathrm{MEG}} = |p\\cos\\theta + (-p\\cos\\theta)| = |p\\cos\\theta - p\\cos\\theta| = |0| = 0\n$$\n\nThe calculation demonstrates that for two opposing sulcal walls, the tangential components of the dipole moments cancel perfectly, leading to a zero net tangential moment and thus a null MEG signal. The radial components, however, are oriented in the same direction and add constructively, producing a strong net radial moment which is readily detectable by EEG.\n\nThe pair of signals is $(S_{\\mathrm{EEG}}, S_{\\mathrm{MEG}}) = (2p\\sin\\theta, 0)$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2p\\sin\\theta & 0 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "The accuracy of any source localization depends on the fidelity of the \"forward model,\" which predicts the scalp signals generated by a known neural source. This practical exercise delves into the construction of a multi-shell spherical head model, a cornerstone of EEG analysis. By implementing the model and performing a sensitivity analysis , you will quantify how uncertainty in a critical biophysical parameter, the skull-to-brain conductivity ratio, impacts the predicted EEG amplitudes.",
            "id": "4159228",
            "problem": "You are tasked with quantifying how the skull-to-brain conductivity ratio affects electroencephalography (EEG) amplitudes predicted by an Equivalent Current Dipole (ECD) model under spherical symmetry. The ECD is a standard source model in neuroscience data analysis. Your analysis must begin from the governing forward model of quasistatic volume conduction: the electric potential satisfies $$\\nabla \\cdot (\\sigma \\nabla \\phi) = \\nabla \\cdot \\mathbf{J}_p,$$ where $\\sigma$ is the electrical conductivity, $\\phi$ is the electric potential, and $\\mathbf{J}_p$ is the impressed current density due to neural sources. For an ECD of moment $\\mathbf{p}$ located at the center of a spherically symmetric, piecewise homogeneous conductor, the source term is modeled as a point-dipole, and separation of variables in spherical coordinates reduces the problem to matching boundary conditions across concentric shells.\n\nConsider a three-shell spherical head model with radii and conductivities given by:\n- Brain (inner sphere): radius $a_1 = 0.08$ m, conductivity $\\sigma_1 = 0.33$ S/m.\n- Skull (middle shell): inner radius $a_1 = 0.08$ m, outer radius $a_2 = 0.085$ m, conductivity $\\sigma_2 = r \\cdot \\sigma_1$, where $r$ is the skull-to-brain conductivity ratio to be varied.\n- Scalp (outer shell): inner radius $a_2 = 0.085$ m, outer radius $a_3 = 0.09$ m, conductivity $\\sigma_3 = 0.33$ S/m.\n- Exterior (beyond $a_3$): treated as non-conductive, imposing a zero-normal-current boundary condition at $r=a_3$.\n\nLet the ECD be located at the center ($r=0$), oriented along the $z$-axis, with dipole moment magnitude $p = 1 \\times 10^{-8}$ A·m. By spherical symmetry, the solution is purely of angular order $n=1$ and depends on $\\cos\\theta$, where $\\theta$ is the polar angle measured in radians.\n\nStarting from the above fundamental laws and definitions, derive the form of the potential in each region as the sum of the central dipole’s particular solution and homogeneous solutions of Laplace’s equation, and enforce the boundary conditions:\n- Continuity of potential at $r=a_1$ and $r=a_2$.\n- Continuity of normal component of current density at $r=a_1$ and $r=a_2$.\n- Zero normal current at the outer boundary $r=a_3$.\n\nFrom these, construct and solve the resulting linear system for the coefficients of the homogeneous solutions. Use the solution to compute the scalp potential amplitude at the point directly above the dipole ($\\theta=0$) on the outer boundary ($r=a_3$). Express the amplitude in microvolts.\n\nPerform a quantitative sensitivity analysis with respect to the ratio $r$ by computing, for each test value of $r$, the relative log-sensitivity $$S_{\\mathrm{rel}} = \\frac{r}{V(r)} \\frac{dV}{dr},$$ where $V(r)$ is the scalp potential amplitude at $\\theta=0$ and $r=a_3$. Approximate the derivative $\\frac{dV}{dr}$ numerically using a symmetric finite difference with a small perturbation $\\delta r$ chosen relative to $r$ to ensure numerical stability. Report $S_{\\mathrm{rel}}$ as a dimensionless decimal.\n\nUse the following test suite for $r$:\n- $r = 1.0$ (boundary case of equal skull and brain conductivity),\n- $r = \\frac{1}{15}$ (typical value),\n- $r = \\frac{1}{30}$ (more resistive skull),\n- $r = \\frac{1}{80}$ (highly resistive skull),\n- $r = 0.001$ (extreme edge case).\n\nAll angles are in radians. All physical quantities must be treated consistently in SI units internally, and amplitudes must be reported in microvolts. For each test case, output a pair consisting of the amplitude in microvolts and the relative log-sensitivity $S_{\\mathrm{rel}}$, rounded to six decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list for a test case, of the form $$[\\,[V_{\\mu V},\\,S_{\\mathrm{rel}}],\\,[V_{\\mu V},\\,S_{\\mathrm{rel}}],\\,\\dots\\,].$$",
            "solution": "We begin from the quasistatic forward model of volume conduction, expressed as $$\\nabla \\cdot (\\sigma \\nabla \\phi) = \\nabla \\cdot \\mathbf{J}_p,$$ where $\\sigma$ is the conductivity, $\\phi$ is the electric potential, and $\\mathbf{J}_p$ is the impressed current density due to sources. For an Equivalent Current Dipole (ECD) at the center, oriented along the $z$-axis with dipole moment $\\mathbf{p} = p\\,\\hat{\\mathbf{z}}$, the particular solution in an infinite homogeneous medium of conductivity $\\sigma$ is $$\\phi_{\\mathrm{dip}}(r,\\theta) = \\frac{p \\cos\\theta}{4\\pi \\sigma r^2}.$$ In layered spherical media, the potential must satisfy Laplace’s equation within each homogeneous shell (away from the source) and be augmented by the particular solution in the inner region containing the source.\n\nBy symmetry, only the first-order spherical harmonic contributes ($n=1$), with angular dependence $P_1(\\cos\\theta) = \\cos\\theta$. The general solution in each region can thus be written as:\n- Region $1$ ($0 < r < a_1$, conductivity $\\sigma_1$): $$\\phi_1(r,\\theta) = \\underbrace{\\frac{p \\cos\\theta}{4\\pi \\sigma_1 r^2}}_{\\text{particular}} + A_1\\, r \\cos\\theta.$$\n- Region $2$ ($a_1 < r < a_2$, conductivity $\\sigma_2$): $$\\phi_2(r,\\theta) = \\left(A_2\\, r + B_2\\, r^{-2}\\right) \\cos\\theta.$$\n- Region $3$ ($a_2 < r < a_3$, conductivity $\\sigma_3$): $$\\phi_3(r,\\theta) = \\left(A_3\\, r + B_3\\, r^{-2}\\right) \\cos\\theta.$$\n\nThe coefficients $A_1$, $A_2$, $B_2$, $A_3$, and $B_3$ are determined by enforcing boundary conditions derived from physical laws:\n1. Continuity of potential at $r = a_1$: $$\\phi_1(a_1,\\theta) = \\phi_2(a_1,\\theta).$$\n2. Continuity of normal current density at $r = a_1$: $$\\sigma_1 \\left.\\frac{\\partial \\phi_1}{\\partial r}\\right|_{r=a_1} = \\sigma_2 \\left.\\frac{\\partial \\phi_2}{\\partial r}\\right|_{r=a_1}.$$\n3. Continuity of potential at $r = a_2$: $$\\phi_2(a_2,\\theta) = \\phi_3(a_2,\\theta).$$\n4. Continuity of normal current density at $r = a_2$: $$\\sigma_2 \\left.\\frac{\\partial \\phi_2}{\\partial r}\\right|_{r=a_2} = \\sigma_3 \\left.\\frac{\\partial \\phi_3}{\\partial r}\\right|_{r=a_2}.$$\n5. Zero-normal-current boundary at $r = a_3$ due to the non-conductive exterior: $$\\left.\\frac{\\partial \\phi_3}{\\partial r}\\right|_{r=a_3} = 0.$$\n\nWe compute the radial derivatives for the $n=1$ forms:\n- $$\\frac{\\partial}{\\partial r}\\left(\\frac{p \\cos\\theta}{4\\pi \\sigma_1 r^2}\\right) = -\\frac{2 p \\cos\\theta}{4\\pi \\sigma_1 r^3},\\quad \\frac{\\partial}{\\partial r}(A_1 r \\cos\\theta) = A_1 \\cos\\theta.$$\n- $$\\frac{\\partial}{\\partial r}\\left(\\left(A_2 r + B_2 r^{-2}\\right)\\cos\\theta\\right) = \\left(A_2 - 2 B_2 r^{-3}\\right) \\cos\\theta.$$\n- $$\\frac{\\partial}{\\partial r}\\left(\\left(A_3 r + B_3 r^{-2}\\right)\\cos\\theta\\right) = \\left(A_3 - 2 B_3 r^{-3}\\right) \\cos\\theta.$$\n\nBecause $\\cos\\theta$ factors out, the boundary conditions become linear equations in the coefficients. Writing them explicitly:\n- At $r=a_1$ (potential continuity): $$A_1 a_1 + \\frac{p}{4\\pi \\sigma_1 a_1^2} = A_2 a_1 + \\frac{B_2}{a_1^2}.$$\n- At $r=a_1$ (current continuity): $$\\sigma_1 A_1 - \\frac{2 p}{4\\pi a_1^3} = \\sigma_2 A_2 - \\frac{2 \\sigma_2 B_2}{a_1^3}.$$\n- At $r=a_2$ (potential continuity): $$A_2 a_2 + \\frac{B_2}{a_2^2} = A_3 a_2 + \\frac{B_3}{a_2^2}.$$\n- At $r=a_2$ (current continuity): $$\\sigma_2 A_2 - \\frac{2 \\sigma_2 B_2}{a_2^3} = \\sigma_3 A_3 - \\frac{2 \\sigma_3 B_3}{a_2^3}.$$\n- At $r=a_3$ (zero-normal-current): $$A_3 - \\frac{2 B_3}{a_3^3} = 0.$$\n\nThis is a system of five linear equations in five unknowns, which we solve using standard linear algebra. The scalp potential at the point above the dipole ($\\theta=0$) on the outer boundary is $$V(r) = \\phi_3(a_3,0) = A_3 a_3 + \\frac{B_3}{a_3^2}.$$ Using the zero-current boundary condition at $r=a_3$, we have $$B_3 = \\frac{A_3 a_3^3}{2},$$ so $$V(r) = A_3 a_3 + \\frac{A_3 a_3^3}{2 a_3^2} = \\frac{3}{2} A_3 a_3.$$\n\nAlgorithmic steps:\n1. For given $p$, $a_1$, $a_2$, $a_3$, $\\sigma_1$, $\\sigma_2 = r \\sigma_1$, and $\\sigma_3$, assemble the $5 \\times 5$ linear system representing the boundary conditions, with unknown vector $\\mathbf{x} = [A_1, A_2, B_2, A_3, B_3]^\\top$.\n2. Solve $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$ numerically to obtain the coefficients.\n3. Compute $V(r) = A_3 a_3 + B_3 / a_3^2$ in volts. Convert to microvolts by multiplying by $10^6$.\n4. For sensitivity, compute $\\frac{dV}{dr}$ using a symmetric finite difference with $\\delta r = \\epsilon r$, where $\\epsilon$ is a small dimensionless parameter (e.g., $\\epsilon = 10^{-4}$):\n   $$\\frac{dV}{dr} \\approx \\frac{V(r+\\delta r) - V(r-\\delta r)}{2 \\delta r}.$$\n   Then compute the relative log-sensitivity $$S_{\\mathrm{rel}} = \\frac{r}{V(r)} \\frac{dV}{dr}.$$\n5. For each test $r$ in $\\{1.0, 1/15, 1/30, 1/80, 0.001\\}$, output $[V_{\\mu V}, S_{\\mathrm{rel}}]$, both rounded to six decimal places.\n6. Aggregate all pairs into a single list and print exactly one line in the specified format.\n\nScientific interpretation:\n- As $\\sigma_2$ decreases relative to $\\sigma_1$ (smaller $r$), the skull presents higher resistance, typically reducing scalp potentials for EEG because the radial current crossing the skull is impeded.\n- The sensitivity $S_{\\mathrm{rel}}$ quantifies how strongly scalp potentials depend on $r$; negative values indicate that decreasing $r$ reduces $V$, and the magnitude indicates responsiveness to changes in skull conductivity.\n\nThis approach adheres to the fundamental laws, uses well-tested formulas for layered spherical solutions via separation of variables, and provides a numerically robust implementation and sensitivity analysis suitable for advanced graduate-level neuroscience data analysis.",
            "answer": "```python\nimport numpy as np\n\ndef compute_scalp_potential_microvolts(p, a1, a2, a3, sigma1, sigma2, sigma3):\n    \"\"\"\n    Solve the three-shell spherical model linear system for a central dipole (n=1 harmonic)\n    and return the scalp potential at r=a3, theta=0, in microvolts.\n    Unknowns: [A1, A2, B2, A3, B3]\n    Equations enforce:\n      - Potential continuity at r=a1 and r=a2\n      - Current continuity at r=a1 and r=a2\n      - Zero-normal-current boundary at r=a3\n    \"\"\"\n    # Build linear system A x = b\n    A = np.zeros((5, 5), dtype=float)\n    b = np.zeros(5, dtype=float)\n\n    # Equation 1: Continuity of potential at r=a1\n    # A1*a1 + p/(4π σ1 a1^2) = A2*a1 + B2/a1^2\n    A[0, 0] = a1            # A1 coefficient\n    A[0, 1] = -a1           # -A2\n    A[0, 2] = -1.0 / (a1**2)  # -B2/a1^2\n    A[0, 3] = 0.0\n    A[0, 4] = 0.0\n    b[0] = -p / (4.0 * np.pi * sigma1 * (a1**2))\n\n    # Equation 2: Continuity of current at r=a1\n    # sigma1*A1 - 2p/(4π a1^3) = sigma2*A2 - 2*sigma2*B2/a1^3\n    A[1, 0] = sigma1\n    A[1, 1] = -sigma2\n    A[1, 2] = 2.0 * sigma2 / (a1**3)\n    A[1, 3] = 0.0\n    A[1, 4] = 0.0\n    b[1] = 2.0 * p / (4.0 * np.pi * (a1**3))\n\n    # Equation 3: Continuity of potential at r=a2\n    # A2*a2 + B2/a2^2 = A3*a2 + B3/a2^2\n    A[2, 0] = 0.0\n    A[2, 1] = a2\n    A[2, 2] = 1.0 / (a2**2)\n    A[2, 3] = -a2\n    A[2, 4] = -1.0 / (a2**2)\n    b[2] = 0.0\n\n    # Equation 4: Continuity of current at r=a2\n    # sigma2*A2 - 2*sigma2*B2/a2^3 = sigma3*A3 - 2*sigma3*B3/a2^3\n    A[3, 0] = 0.0\n    A[3, 1] = sigma2\n    A[3, 2] = -2.0 * sigma2 / (a2**3)\n    A[3, 3] = -sigma3\n    A[3, 4] = 2.0 * sigma3 / (a2**3)\n    b[3] = 0.0\n\n    # Equation 5: Zero-normal-current at r=a3\n    # A3 - 2*B3/a3^3 = 0\n    A[4, 0] = 0.0\n    A[4, 1] = 0.0\n    A[4, 2] = 0.0\n    A[4, 3] = 1.0\n    A[4, 4] = -2.0 / (a3**3)\n    b[4] = 0.0\n\n    # Solve the linear system\n    try:\n        x = np.linalg.solve(A, b)\n    except np.linalg.LinAlgError:\n        # In case of numerical issues, return NaN\n        return float('nan')\n\n    A3 = x[3]\n    B3 = x[4]\n    # Scalp potential at r=a3, theta=0: V = A3*a3 + B3/a3^2 (volts)\n    V = A3 * a3 + B3 / (a3**2)\n    V_microvolts = V * 1e6\n    return V_microvolts\n\ndef compute_sensitivity(p, a1, a2, a3, sigma1, sigma3, r, eps=1e-4):\n    \"\"\"\n    Compute the relative log-sensitivity S_rel = (r/V) * dV/dr using symmetric finite differences.\n    \"\"\"\n    sigma2 = r * sigma1\n    V = compute_scalp_potential_microvolts(p, a1, a2, a3, sigma1, sigma2, sigma3)\n    # Relative perturbation\n    dr = max(r * eps, 1e-12)\n    r_plus = r + dr\n    r_minus = r - dr\n    if r_minus <= 0.0:\n        r_minus = r * (1.0 - eps)  # ensure positive\n        dr = r_plus - r_minus\n    V_plus = compute_scalp_potential_microvolts(p, a1, a2, a3, sigma1, r_plus * sigma1, sigma3)\n    V_minus = compute_scalp_potential_microvolts(p, a1, a2, a3, sigma1, r_minus * sigma1, sigma3)\n    dV_dr = (V_plus - V_minus) / (2.0 * dr)\n    # Relative log-sensitivity (dimensionless)\n    S_rel = (r / V) * dV_dr if V != 0.0 else float('nan')\n    return V, S_rel\n\ndef solve():\n    # Fixed model parameters\n    p = 1.0e-8           # A·m\n    a1 = 0.08            # m\n    a2 = 0.085           # m\n    a3 = 0.09            # m\n    sigma1 = 0.33        # S/m (brain)\n    sigma3 = 0.33        # S/m (scalp)\n\n    # Test suite of skull-to-brain conductivity ratios r\n    test_cases = [\n        1.0,\n        1.0/15.0,\n        1.0/30.0,\n        1.0/80.0,\n        0.001,\n    ]\n\n    results = []\n    for r in test_cases:\n        V_microvolts, S_rel = compute_sensitivity(p, a1, a2, a3, sigma1, sigma3, r, eps=1e-4)\n        # Round to six decimal places\n        V_round = float(f\"{V_microvolts:.6f}\")\n        S_round = float(f\"{S_rel:.6f}\")\n        results.append((V_round, S_round))\n\n    # Format the output exactly as specified: a single line, comma-separated list enclosed in brackets\n    output = \"[\" + \",\".join(f\"[{amp:.6f},{sens:.6f}]\" for amp, sens in results) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Having explored the forward problem, we now turn to the inverse problem: estimating the unknown location and moment of a neural source from measured sensor data. This is a nonlinear estimation challenge that lies at the heart of ECD analysis. This capstone exercise guides you through the implementation of the Levenberg-Marquardt algorithm , a robust method for solving such nonlinear least-squares problems, providing you with hands-on experience in building a functional source localization solver.",
            "id": "4159236",
            "problem": "You are given a forward model for electroencephalography (EEG) in an infinite, homogeneous, isotropic conductor. An Equivalent Current Dipole (ECD) located at position $\\mathbf{r} \\in \\mathbb{R}^3$ with dipole moment $\\mathbf{q} \\in \\mathbb{R}^3$ produces an electric potential at sensor location $\\mathbf{r}_i \\in \\mathbb{R}^3$ given by the well-tested expression\n$$\n\\phi_i(\\boldsymbol{\\theta}) \\;=\\; \\frac{1}{4\\pi \\sigma} \\, \\frac{\\mathbf{q} \\cdot \\left(\\mathbf{r}_i - \\mathbf{r}\\right)}{\\left\\|\\mathbf{r}_i - \\mathbf{r}\\right\\|^3},\n$$\nwhere $\\sigma > 0$ is the conductivity (in $\\mathrm{S/m}$), and $\\boldsymbol{\\theta} = \\begin{bmatrix} \\mathbf{r} \\\\ \\mathbf{q} \\end{bmatrix} \\in \\mathbb{R}^6$ is the parameter vector. Given $M$ sensors at positions $\\{\\mathbf{r}_i\\}_{i=1}^M$, define the forward mapping $\\mathbf{f}(\\boldsymbol{\\theta}) \\in \\mathbb{R}^M$ by $[\\mathbf{f}(\\boldsymbol{\\theta})]_i = \\phi_i(\\boldsymbol{\\theta})$. Noisy observations are given by $\\mathbf{y} = \\mathbf{f}(\\boldsymbol{\\theta}^\\star) + \\boldsymbol{\\varepsilon}$, where $\\boldsymbol{\\varepsilon}$ is additive zero-mean Gaussian noise with known variance. Consider the nonlinear least-squares objective\n$$\nS(\\boldsymbol{\\theta}) \\;=\\; \\frac{1}{2} \\, \\|\\mathbf{y} - \\mathbf{f}(\\boldsymbol{\\theta})\\|_2^2.\n$$\n\nTask:\n- Implement a Gauss–Newton or Levenberg–Marquardt (LM) update to estimate $\\boldsymbol{\\theta}$ by minimizing $S(\\boldsymbol{\\theta})$. Your implementation must:\n  - Construct the residual vector $\\mathbf{r}(\\boldsymbol{\\theta}) = \\mathbf{y} - \\mathbf{f}(\\boldsymbol{\\theta})$ and the Jacobian matrix $\\mathbf{J}(\\boldsymbol{\\theta}) = \\frac{\\partial \\mathbf{f}}{\\partial \\boldsymbol{\\theta}}(\\boldsymbol{\\theta}) \\in \\mathbb{R}^{M \\times 6}$.\n  - Use the Levenberg–Marquardt (LM) step $\\boldsymbol{\\delta}$ obtained by solving $(\\mathbf{J}^\\top \\mathbf{J} + \\mu \\mathbf{I}) \\boldsymbol{\\delta} = \\mathbf{J}^\\top \\mathbf{r}$ with damping parameter $\\mu > 0$, and update $\\boldsymbol{\\theta} \\leftarrow \\boldsymbol{\\theta} + \\boldsymbol{\\delta}$ with an adaptive $\\mu$ rule to ensure decrease of $S(\\boldsymbol{\\theta})$ whenever possible.\n- Justify, in your solution, the linearization assumptions required for local convergence near the optimum, starting from the definition of the forward model and Taylor’s theorem. Your justification must be grounded in the foundational forward model and general properties of smooth functions; do not assume any special structure beyond what is provided here.\n\nPhysical and numerical units to be used:\n- Positions $\\mathbf{r}$ and $\\mathbf{r}_i$ must be in $\\mathrm{m}$.\n- Dipole moment $\\mathbf{q}$ must be in $\\mathrm{A\\cdot m}$.\n- Conductivity $\\sigma$ must be in $\\mathrm{S/m}$.\n- Potentials $\\phi_i$ and observations $\\mathbf{y}$ must be in $\\mathrm{V}$.\n- All angles, if any are used for sensor generation, must be in radians.\n\nTest suite:\n- Use $M = 24$ sensors on a sphere of radius $R_\\mathrm{sens} = 0.09\\,\\mathrm{m}$ at polar angles $\\theta \\in \\{\\pi/4, \\pi/2, 3\\pi/4\\}$ and azimuth angles $\\varphi \\in \\left\\{ \\frac{2\\pi k}{8} \\,:\\, k = 0,1,\\dots,7 \\right\\}$, i.e., sensor positions $\\mathbf{r}_i = R_\\mathrm{sens} \\,[\\sin\\theta \\cos\\varphi, \\sin\\theta \\sin\\varphi, \\cos\\theta]^\\top$.\n- Set conductivity $\\sigma = 0.33\\,\\mathrm{S/m}$.\n- Define $3$ cases with true parameters, initial guesses, and noise levels as follows:\n  1. Case A (happy path): $\\mathbf{r}^\\star = [0.02,\\, 0.01,\\, 0.04]\\,\\mathrm{m}$, $\\mathbf{q}^\\star = [1.0\\times10^{-8},\\, -2.0\\times10^{-8},\\, 0.5\\times10^{-8}]\\,\\mathrm{A\\cdot m}$, noise standard deviation $\\sigma_\\varepsilon = 5.0\\times10^{-8}\\,\\mathrm{V}$, initial guess $\\mathbf{r}_0 = [0.0,\\, 0.0,\\, 0.03]\\,\\mathrm{m}$, $\\mathbf{q}_0 = [1.0\\times10^{-8},\\, -1.0\\times10^{-8},\\, 0.0]\\,\\mathrm{A\\cdot m}$.\n  2. Case B (far start, noise-free): Same $\\mathbf{r}^\\star$ and $\\mathbf{q}^\\star$ as Case A, $\\sigma_\\varepsilon = 0\\,\\mathrm{V}$, initial guess $\\mathbf{r}_0 = [-0.03,\\, 0.02,\\, 0.02]\\,\\mathrm{m}$, $\\mathbf{q}_0 = [0.5\\times10^{-8},\\, -0.5\\times10^{-8},\\, 0.2\\times10^{-8}]\\,\\mathrm{A\\cdot m}$.\n  3. Case C (low-amplitude, noisier): $\\mathbf{r}^\\star = [0.0,\\, 0.0,\\, 0.005]\\,\\mathrm{m}$, $\\mathbf{q}^\\star = [1.0\\times10^{-8},\\, 1.0\\times10^{-8},\\, 1.0\\times10^{-8}]\\,\\mathrm{A\\cdot m}$, $\\sigma_\\varepsilon = 1.0\\times10^{-7}\\,\\mathrm{V}$, initial guess $\\mathbf{r}_0 = [0.0,\\, 0.0,\\, 0.0]\\,\\mathrm{m}$, $\\mathbf{q}_0 = [0.5\\times10^{-8},\\, 0.5\\times10^{-8},\\, 0.5\\times10^{-8}]\\,\\mathrm{A\\cdot m}$.\n\nImplementation details:\n- Use Levenberg–Marquardt with at most $50$ iterations per case, initial damping $\\mu_0 = 10^{-3}\\cdot \\max\\{\\mathrm{diag}(\\mathbf{J}^\\top \\mathbf{J})\\}$, reduction factor $\\beta_\\downarrow = 1/3$, increase factor $\\beta_\\uparrow = 10$, and accept an update only if it lowers $S(\\boldsymbol{\\theta})$.\n- Terminate early if $\\|\\boldsymbol{\\delta}\\|_2 \\le 10^{-9}$ or the relative decrease in $S(\\boldsymbol{\\theta})$ is below $10^{-9}$.\n- For numerical safety, if any $\\|\\mathbf{r}_i - \\mathbf{r}\\|$ is below $10^{-6}\\,\\mathrm{m}$, clamp it to $10^{-6}\\,\\mathrm{m}$ in the forward model and Jacobian.\n\nRequired outputs:\n- For each of the $3$ cases, compute:\n  - The final Euclidean position error $\\|\\widehat{\\mathbf{r}} - \\mathbf{r}^\\star\\|_2$ in $\\mathrm{m}$.\n  - The final root-mean-square error $\\sqrt{\\frac{1}{M}\\|\\mathbf{y} - \\mathbf{f}(\\widehat{\\boldsymbol{\\theta}})\\|_2^2}$ in $\\mathrm{V}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n  $[\\text{pos\\_err\\_A}, \\text{rmse\\_A}, \\text{pos\\_err\\_B}, \\text{rmse\\_B}, \\text{pos\\_err\\_C}, \\text{rmse\\_C}]$.\n- Express all floating-point numbers in scientific notation with exactly $6$ significant digits (for example, $1.234560\\mathrm{e}{-03}$). The output must be dimensionless text, but the quantities correspond to $\\mathrm{m}$ for position errors and $\\mathrm{V}$ for root-mean-square errors.",
            "solution": "The problem requires the estimation of an Equivalent Current Dipole's (ECD) parameters from noisy potential measurements using a nonlinear least-squares approach. The parameters to be estimated are the dipole's $3$D position $\\mathbf{r}$ and its $3$D moment vector $\\mathbf{q}$, forming a $6$-dimensional parameter vector $\\boldsymbol{\\theta} = [\\mathbf{r}^\\top, \\mathbf{q}^\\top]^\\top$. The optimization is performed by implementing the Levenberg-Marquardt (LM) algorithm to minimize the sum-of-squared-errors objective function $S(\\boldsymbol{\\theta})$.\n\n### Justification of the Linearization Approach\n\nThe core of iterative optimization algorithms like Gauss-Newton and Levenberg-Marquardt lies in the local linearization of a nonlinear problem. The objective is to minimize $S(\\boldsymbol{\\theta}) = \\frac{1}{2} \\|\\mathbf{y} - \\mathbf{f}(\\boldsymbol{\\theta})\\|_2^2$, where $\\mathbf{f}(\\boldsymbol{\\theta})$ is the nonlinear forward model mapping parameters to observations.\n\nThe forward model for a single sensor $i$ is given by:\n$$\n\\phi_i(\\boldsymbol{\\theta}) = \\frac{1}{4\\pi \\sigma} \\, \\frac{\\mathbf{q} \\cdot (\\mathbf{r}_i - \\mathbf{r})}{\\|\\mathbf{r}_i - \\mathbf{r}\\|^3}\n$$\nThis function is a rational function of the components of $\\mathbf{r}$ and a linear function of the components of $\\mathbf{q}$. A function of this form is infinitely differentiable (i.e., smooth or $C^\\infty$) at all points in its domain where the denominator is non-zero. In this physical model, the denominator $\\|\\mathbf{r}_i - \\mathbf{r}\\|^3$ becomes zero only if the dipole source co-locates with a sensor, i.e., $\\mathbf{r} = \\mathbf{r}_i$. Since the dipole represents a neural source inside the head volume and the sensors $\\{\\mathbf{r}_i\\}$ are located on the scalp surface, the condition $\\mathbf{r} \\neq \\mathbf{r}_i$ is always satisfied in a physically valid context. Therefore, the vector-valued forward map $\\mathbf{f}(\\boldsymbol{\\theta})$ is a smooth function of $\\boldsymbol{\\theta}$ in the entire domain of interest.\n\nGiven the smoothness of $\\mathbf{f}(\\boldsymbol{\\theta})$, we can apply Taylor's theorem. At an iteration $k$ with current estimate $\\boldsymbol{\\theta}_k$, we seek an update step $\\boldsymbol{\\delta}$ such that $\\boldsymbol{\\theta}_{k+1} = \\boldsymbol{\\theta}_k + \\boldsymbol{\\delta}$ reduces the objective function value. For a small step $\\boldsymbol{\\delta}$, the forward model can be approximated by its first-order Taylor expansion around $\\boldsymbol{\\theta}_k$:\n$$\n\\mathbf{f}(\\boldsymbol{\\theta}_k + \\boldsymbol{\\delta}) \\approx \\mathbf{f}(\\boldsymbol{\\theta}_k) + \\mathbf{J}(\\boldsymbol{\\theta}_k) \\boldsymbol{\\delta}\n$$\nwhere $\\mathbf{J}(\\boldsymbol{\\theta}_k) = \\frac{\\partial \\mathbf{f}}{\\partial \\boldsymbol{\\theta}}(\\boldsymbol{\\theta}_k)$ is the Jacobian matrix of $\\mathbf{f}$ evaluated at $\\boldsymbol{\\theta}_k$.\n\nSubstituting this linear approximation into the objective function, we obtain a quadratic approximation of $S(\\boldsymbol{\\theta})$:\n$$\nS(\\boldsymbol{\\theta}_k + \\boldsymbol{\\delta}) \\approx \\frac{1}{2} \\|\\mathbf{y} - (\\mathbf{f}(\\boldsymbol{\\theta}_k) + \\mathbf{J}(\\boldsymbol{\\theta}_k) \\boldsymbol{\\delta})\\|_2^2 = \\frac{1}{2} \\|\\mathbf{r}(\\boldsymbol{\\theta}_k) - \\mathbf{J}(\\boldsymbol{\\theta}_k) \\boldsymbol{\\delta}\\|_2^2\n$$\nwhere $\\mathbf{r}(\\boldsymbol{\\theta}_k) = \\mathbf{y} - \\mathbf{f}(\\boldsymbol{\\theta}_k)$ is the residual vector at the current estimate. Minimizing this linearized objective with respect to $\\boldsymbol{\\delta}$ is a standard linear least-squares problem, whose solution is given by the normal equations. The Gauss-Newton algorithm directly solves $(\\mathbf{J}_k^\\top \\mathbf{J}_k) \\boldsymbol{\\delta} = \\mathbf{J}_k^\\top \\mathbf{r}_k$.\n\nThe validity and convergence of this procedure hinge on the accuracy of the linear approximation. Taylor's theorem guarantees that the error in this approximation is of order $O(\\|\\boldsymbol{\\delta}\\|^2)$. Thus, in a sufficiently small neighborhood of the true solution $\\boldsymbol{\\theta}^\\star$, the linear model is highly accurate, and the algorithm typically exhibits rapid (quadratically-like) convergence. The Levenberg-Marquardt algorithm builds upon this by introducing a damping term, which makes the method more robust when far from the solution or when the Jacobian is ill-conditioned, effectively ensuring progress toward the minimum.\n\n### Algorithmic Design and Implementation\n\nThe solution is implemented via the Levenberg-Marquardt algorithm. This requires the analytical Jacobian of the forward model.\n\n**1. Jacobian Matrix Derivation**\nThe Jacobian $\\mathbf{J}(\\boldsymbol{\\theta}) \\in \\mathbb{R}^{M \\times 6}$ has entries $J_{ij} = \\frac{\\partial \\phi_i}{\\partial \\theta_j}$. Its $i$-th row is the gradient of the potential at the $i$-th sensor with respect to the parameter vector $\\boldsymbol{\\theta} = [r_x, r_y, r_z, q_x, q_y, q_z]^\\top$. Let $\\mathbf{d}_i = \\mathbf{r}_i - \\mathbf{r}$ and $d_i = \\|\\mathbf{d}_i\\|$.\n\nThe partial derivatives with respect to the dipole moment components $\\mathbf{q}$ are straightforward due to the linearity of the numerator in $\\mathbf{q}$:\n$$\n\\nabla_\\mathbf{q} \\phi_i(\\boldsymbol{\\theta}) = \\frac{\\partial \\phi_i}{\\partial \\mathbf{q}} = \\frac{1}{4\\pi \\sigma} \\frac{\\mathbf{r}_i - \\mathbf{r}}{\\|\\mathbf{r}_i - \\mathbf{r}\\|^3} = \\frac{\\mathbf{d}_i}{4\\pi \\sigma d_i^3}\n$$\nThis forms columns $4$, $5$, and $6$ of the $i$-th row of the Jacobian.\n\nThe partial derivatives with respect to the dipole position components $\\mathbf{r}$ are more complex. Using the quotient and chain rules, we find:\n$$\n\\nabla_\\mathbf{r} \\phi_i(\\boldsymbol{\\theta}) = \\frac{\\partial \\phi_i}{\\partial \\mathbf{r}} = \\frac{1}{4\\pi \\sigma} \\left( \\frac{-\\mathbf{q}}{d_i^3} + 3 \\frac{(\\mathbf{q} \\cdot \\mathbf{d}_i) \\mathbf{d}_i}{d_i^5} \\right)\n$$\nThis vector derivative forms columns $1$, $2$, and $3$ of the $i$-th row of the Jacobian.\nFor numerical stability, any computed distance $d_i$ that is smaller than $10^{-6}\\,\\mathrm{m}$ is clamped to this minimum value.\n\n**2. Levenberg-Marquardt Iteration**\nThe algorithm proceeds as follows:\n- **Initialization**: Start with an initial guess $\\boldsymbol{\\theta}_0$. Compute the initial residual $\\mathbf{r}_0$, cost $S_0$, Jacobian $\\mathbf{J}_0$, and initial damping parameter $\\mu_0 = 10^{-3} \\cdot \\max\\{\\mathrm{diag}(\\mathbf{J}_0^\\top \\mathbf{J}_0)\\}$.\n- **Iteration Loop**: At each iteration $k$:\n    1.  Solve the damped normal equations for the step $\\boldsymbol{\\delta}_k$:\n        $$\n        (\\mathbf{J}_k^\\top \\mathbf{J}_k + \\mu_k \\mathbf{I}) \\boldsymbol{\\delta}_k = \\mathbf{J}_k^\\top \\mathbf{r}_k\n        $$\n    2.  Evaluate a candidate parameter vector $\\boldsymbol{\\theta}_\\text{new} = \\boldsymbol{\\theta}_k + \\boldsymbol{\\delta}_k$ and the corresponding cost $S_\\text{new} = S(\\boldsymbol{\\theta}_\\text{new})$.\n    3.  **Adaptive Damping**:\n        - If $S_\\text{new} < S_k$ (cost decreased), the step is accepted: $\\boldsymbol{\\theta}_{k+1} = \\boldsymbol{\\theta}_\\text{new}$. The damping parameter is reduced: $\\mu_{k+1} = \\mu_k / 3$, pushing the algorithm closer to a faster Gauss-Newton step. The Jacobian and residuals are updated for the next iteration.\n        - If $S_\\text{new} \\ge S_k$ (cost did not decrease), the step is rejected: $\\boldsymbol{\\theta}_{k+1} = \\boldsymbol{\\theta}_k$. The damping parameter is increased: $\\mu_k \\leftarrow \\mu_k \\cdot 10$, making the next attempted step smaller and more aligned with the gradient descent direction. The algorithm then retries solving for a new $\\boldsymbol{\\delta}_k$ with the increased $\\mu_k$.\n- **Termination**: The process stops if one of the following conditions is met:\n    1. The maximum number of iterations ($50$) is reached.\n    2. The norm of the accepted step is negligible: $\\|\\boldsymbol{\\delta}_k\\|_2 \\le 10^{-9}$.\n    3. The relative decrease in cost is negligible: $(S_k - S_{k+1})/S_k < 10^{-9}$.\n\n**3. Output Calculation**:\nUpon termination, the final parameter estimate $\\widehat{\\boldsymbol{\\theta}}$ is used to compute the required metrics for each test case:\n- Final position error: $\\|\\widehat{\\mathbf{r}} - \\mathbf{r}^\\star\\|_2$.\n- Final root-mean-square error: $\\sqrt{\\frac{1}{M}\\|\\mathbf{y} - \\mathbf{f}(\\widehat{\\boldsymbol{\\theta}})\\|_2^2}$.\nThe results are then formatted into a single output string as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef forward_model(theta, sensor_pos, sigma):\n    \"\"\"\n    Computes the electric potential at sensor locations for a given ECD.\n    \"\"\"\n    M = sensor_pos.shape[0]\n    r = theta[:3]\n    q = theta[3:]\n    phi = np.zeros(M)\n    \n    d_vecs = sensor_pos - r\n    d_norms = np.linalg.norm(d_vecs, axis=1)\n    # Numerical safety clamp\n    d_norms[d_norms < 1e-6] = 1e-6\n    \n    q_dot_d = d_vecs @ q\n    \n    phi = (1 / (4 * np.pi * sigma)) * (q_dot_d / (d_norms**3))\n    \n    return phi\n\ndef jacobian(theta, sensor_pos, sigma):\n    \"\"\"\n    Computes the Jacobian of the forward model.\n    \"\"\"\n    M = sensor_pos.shape[0]\n    r = theta[:3]\n    q = theta[3:]\n    J = np.zeros((M, 6))\n\n    d_vecs = sensor_pos - r\n    d_norms = np.linalg.norm(d_vecs, axis=1)\n    # Numerical safety clamp\n    d_norms[d_norms < 1e-6] = 1e-6\n    \n    d_norms_3 = d_norms**3\n    d_norms_5 = d_norms**5\n    \n    q_dot_d = d_vecs @ q\n    const = 1 / (4 * np.pi * sigma)\n    \n    # Derivatives w.r.t. r\n    # Term1: 3 * (q . d) * d / d^5\n    term1 = 3 * (q_dot_d / d_norms_5)[:, np.newaxis] * d_vecs\n    # Term2: -q / d^3\n    term2 = -q[np.newaxis, :] / d_norms_3[:, np.newaxis]\n    grad_r_phi = const * (term1 + term2)\n    \n    J[:, :3] = grad_r_phi\n    \n    # Derivatives w.r.t. q\n    grad_q_phi = const * d_vecs / d_norms_3[:, np.newaxis]\n    J[:, 3:] = grad_q_phi\n    \n    return J\n\ndef lm_fit(y, sensor_pos, sigma, theta0):\n    \"\"\"\n    Performs Levenberg-Marquardt optimization to fit ECD parameters.\n    \"\"\"\n    M = len(y)\n    \n    # LM parameters\n    max_iter = 50\n    beta_down = 1/3.0\n    beta_up = 10.0\n    term_delta_norm = 1e-9\n    term_rel_cost = 1e-9\n\n    theta = theta0.copy()\n\n    f = forward_model(theta, sensor_pos, sigma)\n    residuals = y - f\n    S = 0.5 * (residuals @ residuals)\n    \n    J = jacobian(theta, sensor_pos, sigma)\n    JtJ = J.T @ J\n    Jt_r = J.T @ residuals\n    \n    mu = 1e-3 * np.max(np.diag(JtJ))\n    \n    for k in range(max_iter):\n        S_old = S\n        \n        # Adaptive damping loop\n        max_mu_tries = 15\n        for _ in range(max_mu_tries):\n            H_lm = JtJ + mu * np.identity(6)\n            try:\n                delta = linalg.solve(H_lm, Jt_r, assume_a='sym')\n            except linalg.LinAlgError:\n                mu *= beta_up\n                continue\n            \n            theta_new = theta + delta\n            \n            f_new = forward_model(theta_new, sensor_pos, sigma)\n            res_new = y - f_new\n            S_new = 0.5 * (res_new @ res_new)\n            \n            if S_new < S:\n                theta = theta_new\n                S = S_new\n                residuals = res_new\n                \n                # Termination conditions\n                delta_norm = np.linalg.norm(delta)\n                if delta_norm <= term_delta_norm:\n                    return theta\n                \n                rel_S_change = (S_old - S) / (S_old + np.finfo(float).eps)\n                if rel_S_change < term_rel_cost:\n                    return theta\n\n                # Update for next full iteration\n                J = jacobian(theta, sensor_pos, sigma)\n                JtJ = J.T @ J\n                Jt_r = J.T @ residuals\n                \n                mu *= beta_down\n                break\n            else:\n                mu *= beta_up\n        else: # Loop finished without break, i.e. no improvement found\n            return theta\n\n    return theta\n\ndef solve():\n    # Define problem constants\n    M = 24\n    R_sens = 0.09\n    sigma = 0.33\n\n    # Generate sensor positions\n    thetas = [np.pi/4, np.pi/2, 3*np.pi/4]\n    phis = np.linspace(0, 2 * np.pi, 8, endpoint=False)\n    sensor_pos = []\n    for theta_val in thetas:\n        for phi_val in phis:\n            x = R_sens * np.sin(theta_val) * np.cos(phi_val)\n            y = R_sens * np.sin(theta_val) * np.sin(phi_val)\n            z = R_sens * np.cos(theta_val)\n            sensor_pos.append([x, y, z])\n    sensor_pos = np.array(sensor_pos)\n\n    # Define the 3 test cases\n    test_cases = [\n        { # Case A\n            'r_true': np.array([0.02, 0.01, 0.04]),\n            'q_true': np.array([1.0e-8, -2.0e-8, 0.5e-8]),\n            'noise_std': 5.0e-8,\n            'r0': np.array([0.0, 0.0, 0.03]),\n            'q0': np.array([1.0e-8, -1.0e-8, 0.0]),\n        },\n        { # Case B\n            'r_true': np.array([0.02, 0.01, 0.04]),\n            'q_true': np.array([1.0e-8, -2.0e-8, 0.5e-8]),\n            'noise_std': 0.0,\n            'r0': np.array([-0.03, 0.02, 0.02]),\n            'q0': np.array([0.5e-8, -0.5e-8, 0.2e-8]),\n        },\n        { # Case C\n            'r_true': np.array([0.0, 0.0, 0.005]),\n            'q_true': np.array([1.0e-8, 1.0e-8, 1.0e-8]),\n            'noise_std': 1.0e-7,\n            'r0': np.array([0.0, 0.0, 0.0]),\n            'q0': np.array([0.5e-8, 0.5e-8, 0.5e-8]),\n        }\n    ]\n    \n    results = []\n    np.random.seed(0) # for reproducible noise generation\n\n    for case in test_cases:\n        theta_true = np.concatenate((case['r_true'], case['q_true']))\n        theta0 = np.concatenate((case['r0'], case['q0']))\n\n        # Generate noisy measurements\n        f_true = forward_model(theta_true, sensor_pos, sigma)\n        noise = np.random.normal(0, case['noise_std'], M)\n        y = f_true + noise\n\n        # Run LM optimization\n        theta_hat = lm_fit(y, sensor_pos, sigma, theta0)\n        \n        r_hat = theta_hat[:3]\n        \n        # Calculate final position error\n        pos_err = np.linalg.norm(r_hat - case['r_true'])\n        \n        # Calculate final RMSE\n        f_hat = forward_model(theta_hat, sensor_pos, sigma)\n        final_residuals = y - f_hat\n        rmse = np.sqrt(np.mean(final_residuals**2))\n        \n        results.extend([pos_err, rmse])\n    \n    formatted_results = [\"{:.6e}\".format(x) for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}