{
    "hands_on_practices": [
        {
            "introduction": "在脑电/脑磁图源定位中，正向模型的核心是增益矩阵（或称导联场矩阵）$G$。该矩阵的结构取决于我们对神经源生物物理特性的假设。本练习将探讨两种常见的源模型——自由方向和固定方向模型——以及这些假设如何具体地改变增益矩阵的数学形式，这是理解源定位方法的基础。",
            "id": "4158015",
            "problem": "给定一个在麦克斯韦方程组的准静态近似下的脑电图 (EEG) 和脑磁图 (MEG) 线性正向模型，其中测得的传感器数据是由皮层表面的初级电流偶极子产生的场的线性叠加。考虑一个具有 $N$ 个顶点的三角化皮层表面，其中每个顶点 $i$ 都有一个单位表面法向量 $\\mathbf{n}_{i} \\in \\mathbb{R}^{3}$。在自由方向模型下，顶点 $i$ 处的电流是一个三维向量 $\\mathbf{j}_{i} \\in \\mathbb{R}^{3}$，其方向不受约束。在固定方向模型下，顶点 $i$ 处的电流被约束在 $\\mathbf{n}_{i}$ 的方向上，即 $\\mathbf{j}_{i} = q_{i}\\,\\mathbf{n}_{i}$，其中 $q_{i} \\in \\mathbb{R}$。正向模型的线性意味着传感器数据 $\\mathbf{y} \\in \\mathbb{R}^{M}$ 可以写成来自每个顶点的贡献的线性组合。\n\n从正向模型的线性和上述定义出发，完成以下任务：\n\n1.  从第一性原理出发，推导自由方向和固定方向源模型的传感器空间映射（增益）矩阵，用导联场块 $\\mathbf{L}_{i} \\in \\mathbb{R}^{M \\times 3}$ 来表示，其中 $\\mathbf{L}_{i}$ 将顶点 $i$ 处的三个正交单位偶极子映射到 $M$ 个传感器。将 $\\mathbf{G}_{\\mathrm{free}}$ 和 $\\mathbf{G}_{\\mathrm{fix}}$ 明确定义为 $\\{\\mathbf{L}_{i}\\}_{i=1}^{N}$ 和 $\\{\\mathbf{n}_{i}\\}_{i=1}^{N}$ 的函数。\n\n2.  为了量化在固定方向假设下增益矩阵相对于自由方向模型的变化，考虑无量纲比率\n$$\nr \\equiv \\frac{\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2}}{\\|\\mathbf{G}_{\\mathrm{free}}\\|_{F}^{2}},\n$$\n其中 $\\|\\cdot\\|_{F}$ 表示弗罗贝尼乌斯范数。对于一个具有 $M=3$ 个传感器和 $N=2$ 个顶点的具体配置，假设导联场块和单位法向量为\n$$\n\\mathbf{L}_{1} = \\begin{pmatrix}\n1  0  2 \\\\\n0  1  1 \\\\\n-1  2  0\n\\end{pmatrix}, \\quad\n\\mathbf{L}_{2} = \\begin{pmatrix}\n2  -1  0 \\\\\n1  1  1 \\\\\n0  2  -2\n\\end{pmatrix},\n$$\n$$\n\\mathbf{n}_{1} = \\frac{1}{\\sqrt{6}}\\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}, \\quad\n\\mathbf{n}_{2} = \\frac{1}{\\sqrt{14}}\\begin{pmatrix} 3 \\\\ 1 \\\\ -2 \\end{pmatrix}.\n$$\n计算此配置下 $r$ 的精确值。\n\n你的最终答案必须是一个以精确形式书写的单个实数。无需四舍五入，也无需报告单位。",
            "solution": "该问题需要一个分为两部分的解法：首先，推导自由方向和固定方向源模型的增益矩阵；其次，针对一个特定配置，计算它们弗罗贝尼乌斯范数平方的比率。\n\n### 第 1 部分：增益矩阵的推导\n\n源电流与测量的传感器数据之间的关系是线性的，可以表示为 $\\mathbf{y} = \\mathbf{G}\\mathbf{J}$，其中 $\\mathbf{y} \\in \\mathbb{R}^{M}$ 是传感器测量向量，$\\mathbf{J}$ 是描述源电流的向量，$\\mathbf{G}$ 是增益矩阵（或导联场矩阵）。$\\mathbf{J}$ 和 $\\mathbf{G}$ 的结构取决于对源电流所做的假设。总传感器信号是每个顶点 $i$ 处电流产生的信号的线性叠加：\n$$\n\\mathbf{y} = \\sum_{i=1}^{N} (\\text{来自顶点 } i \\text{ 的贡献})\n$$\n来自顶点 $i$ 处电流 $\\mathbf{j}_i \\in \\mathbb{R}^3$ 的贡献由 $\\mathbf{L}_i \\mathbf{j}_i$ 给出，其中 $\\mathbf{L}_i \\in \\mathbb{R}^{M \\times 3}$ 是该顶点的导联场块。因此，传感器数据的一般表达式为：\n$$\n\\mathbf{y} = \\sum_{i=1}^{N} \\mathbf{L}_{i} \\mathbf{j}_{i}\n$$\n\n**1. 自由方向模型 ($\\mathbf{G}_{\\mathrm{free}}$)**\n\n在自由方向模型中，每个顶点 $i$ 处的电流 $\\mathbf{j}_i \\in \\mathbb{R}^3$ 是不受约束的。整个源分布可以通过将所有 $N$ 个电流向量拼接成一个大的源向量 $\\mathbf{J}_{\\mathrm{free}} \\in \\mathbb{R}^{3N}$ 来描述：\n$$\n\\mathbf{J}_{\\mathrm{free}} = \\begin{pmatrix}\n\\mathbf{j}_{1} \\\\\n\\mathbf{j}_{2} \\\\\n\\vdots \\\\\n\\mathbf{j}_{N}\n\\end{pmatrix}\n$$\n我们需要找到矩阵 $\\mathbf{G}_{\\mathrm{free}}$，使得 $\\mathbf{y} = \\mathbf{G}_{\\mathrm{free}} \\mathbf{J}_{\\mathrm{free}}$。我们可以使用分块矩阵乘法来重写 $\\mathbf{y}$ 的求和式：\n$$\n\\mathbf{y} = \\sum_{i=1}^{N} \\mathbf{L}_{i} \\mathbf{j}_{i} =\n\\begin{pmatrix}\n\\mathbf{L}_{1}  \\mathbf{L}_{2}  \\cdots  \\mathbf{L}_{N}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{j}_{1} \\\\\n\\mathbf{j}_{2} \\\\\n\\vdots \\\\\n\\mathbf{j}_{N}\n\\end{pmatrix}\n$$\n通过将其与 $\\mathbf{y} = \\mathbf{G}_{\\mathrm{free}} \\mathbf{J}_{\\mathrm{free}}$ 进行比较，我们确定自由方向增益矩阵 $\\mathbf{G}_{\\mathrm{free}} \\in \\mathbb{R}^{M \\times 3N}$ 是导联场块的水平拼接：\n$$\n\\mathbf{G}_{\\mathrm{free}} = \\begin{pmatrix}\n\\mathbf{L}_{1}  \\mathbf{L}_{2}  \\cdots  \\mathbf{L}_{N}\n\\end{pmatrix}\n$$\n\n**2. 固定方向模型 ($\\mathbf{G}_{\\mathrm{fix}}$)**\n\n在固定方向模型中，每个顶点 $i$ 处的电流被约束为与局部表面法向量 $\\mathbf{n}_i$ 平行，即 $\\mathbf{j}_i = q_i \\mathbf{n}_i$，其中 $q_i \\in \\mathbb{R}$ 是标量电流量值。现在，源分布由这些标量值构成的向量 $\\mathbf{q} \\in \\mathbb{R}^{N}$ 来描述：\n$$\n\\mathbf{q} = \\begin{pmatrix}\nq_{1} \\\\\nq_{2} \\\\\n\\vdots \\\\\nq_{N}\n\\end{pmatrix}\n$$\n我们将该约束代入 $\\mathbf{y}$ 的一般表达式中：\n$$\n\\mathbf{y} = \\sum_{i=1}^{N} \\mathbf{L}_{i} \\mathbf{j}_{i} = \\sum_{i=1}^{N} \\mathbf{L}_{i} (q_{i} \\mathbf{n}_{i})\n$$\n由于 $q_i$ 是标量，我们可以重新排列各项：\n$$\n\\mathbf{y} = \\sum_{i=1}^{N} q_{i} (\\mathbf{L}_{i} \\mathbf{n}_{i})\n$$\n我们定义一个新向量 $\\mathbf{g}_i = \\mathbf{L}_i \\mathbf{n}_i \\in \\mathbb{R}^M$。该向量表示由顶点 $i$ 处沿 $\\mathbf{n}_i$ 方向的单位电流所产生的传感器模式。求和式变为：\n$$\n\\mathbf{y} = \\sum_{i=1}^{N} q_{i} \\mathbf{g}_{i} =\n\\begin{pmatrix}\n\\mathbf{g}_{1}  \\mathbf{g}_{2}  \\cdots  \\mathbf{g}_{N}\n\\end{pmatrix}\n\\begin{pmatrix}\nq_{1} \\\\\nq_{2} \\\\\n\\vdots \\\\\nq_{N}\n\\end{pmatrix}\n$$\n通过将其与 $\\mathbf{y} = \\mathbf{G}_{\\mathrm{fix}} \\mathbf{q}$ 进行比较，我们确定固定方向增益矩阵 $\\mathbf{G}_{\\mathrm{fix}} \\in \\mathbb{R}^{M \\times N}$ 是向量 $\\mathbf{g}_i$ 的水平拼接：\n$$\n\\mathbf{G}_{\\mathrm{fix}} = \\begin{pmatrix}\n\\mathbf{L}_{1}\\mathbf{n}_{1}  \\mathbf{L}_{2}\\mathbf{n}_{2}  \\cdots  \\mathbf{L}_{N}\\mathbf{n}_{N}\n\\end{pmatrix}\n$$\n\n### 第 2 部分：比率 $r$ 的计算\n\n题目要求我们计算对于给定配置（$N=2$）下的比率 $r = \\frac{\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2}}{\\|\\mathbf{G}_{\\mathrm{free}}\\|_{F}^{2}}$。弗罗贝尼乌斯范数的平方 $\\|\\mathbf{A}\\|_F^2$ 是矩阵所有元素的平方和。\n\n**1. 计算 $\\|\\mathbf{G}_{\\mathrm{free}}\\|_{F}^{2}$**\n\n对于 $N=2$，$\\mathbf{G}_{\\mathrm{free}} = \\begin{pmatrix} \\mathbf{L}_{1}  \\mathbf{L}_{2} \\end{pmatrix}$。分块矩阵的弗罗贝尼乌斯范数的平方是其各分块的弗罗贝尼乌斯范数的平方和。\n$$\n\\|\\mathbf{G}_{\\mathrm{free}}\\|_{F}^{2} = \\|\\mathbf{L}_{1}\\|_{F}^{2} + \\|\\mathbf{L}_{2}\\|_{F}^{2}\n$$\n给定 $\\mathbf{L}_{1} = \\begin{pmatrix} 1  0  2 \\\\ 0  1  1 \\\\ -1  2  0 \\end{pmatrix}$ 和 $\\mathbf{L}_{2} = \\begin{pmatrix} 2  -1  0 \\\\ 1  1  1 \\\\ 0  2  -2 \\end{pmatrix}$：\n$$\n\\|\\mathbf{L}_{1}\\|_{F}^{2} = 1^{2} + 0^{2} + 2^{2} + 0^{2} + 1^{2} + 1^{2} + (-1)^{2} + 2^{2} + 0^{2} = 1 + 4 + 1 + 1 + 1 + 4 = 12\n$$\n$$\n\\|\\mathbf{L}_{2}\\|_{F}^{2} = 2^{2} + (-1)^{2} + 0^{2} + 1^{2} + 1^{2} + 1^{2} + 0^{2} + 2^{2} + (-2)^{2} = 4 + 1 + 1 + 1 + 1 + 4 + 4 = 16\n$$\n因此：\n$$\n\\|\\mathbf{G}_{\\mathrm{free}}\\|_{F}^{2} = 12 + 16 = 28\n$$\n\n**2. 计算 $\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2}$**\n\n对于 $N=2$，$\\mathbf{G}_{\\mathrm{fix}} = \\begin{pmatrix} \\mathbf{g}_{1}  \\mathbf{g}_{2} \\end{pmatrix}$，其中 $\\mathbf{g}_{1} = \\mathbf{L}_{1}\\mathbf{n}_{1}$ 且 $\\mathbf{g}_{2} = \\mathbf{L}_{2}\\mathbf{n}_{2}$。弗罗贝尼乌斯范数的平方是其各列的欧几里得范数的平方和。\n$$\n\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2} = \\|\\mathbf{g}_{1}\\|_{2}^{2} + \\|\\mathbf{g}_{2}\\|_{2}^{2}\n$$\n首先，我们计算 $\\mathbf{g}_1$ 和 $\\mathbf{g}_2$。\n$$\n\\mathbf{g}_{1} = \\mathbf{L}_{1}\\mathbf{n}_{1} = \\begin{pmatrix} 1  0  2 \\\\ 0  1  1 \\\\ -1  2  0 \\end{pmatrix} \\frac{1}{\\sqrt{6}}\\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1(1) + 0(2) + 2(1) \\\\ 0(1) + 1(2) + 1(1) \\\\ -1(1) + 2(2) + 0(1) \\end{pmatrix} = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 3 \\\\ 3 \\\\ 3 \\end{pmatrix}\n$$\n$$\n\\mathbf{g}_{2} = \\mathbf{L}_{2}\\mathbf{n}_{2} = \\begin{pmatrix} 2  -1  0 \\\\ 1  1  1 \\\\ 0  2  -2 \\end{pmatrix} \\frac{1}{\\sqrt{14}}\\begin{pmatrix} 3 \\\\ 1 \\\\ -2 \\end{pmatrix} = \\frac{1}{\\sqrt{14}} \\begin{pmatrix} 2(3) - 1(1) + 0(-2) \\\\ 1(3) + 1(1) + 1(-2) \\\\ 0(3) + 2(1) - 2(-2) \\end{pmatrix} = \\frac{1}{\\sqrt{14}} \\begin{pmatrix} 5 \\\\ 2 \\\\ 6 \\end{pmatrix}\n$$\n接下来，我们计算它们的欧几里得范数的平方：\n$$\n\\|\\mathbf{g}_{1}\\|_{2}^{2} = \\left(\\frac{1}{\\sqrt{6}}\\right)^{2} (3^{2} + 3^{2} + 3^{2}) = \\frac{1}{6}(9+9+9) = \\frac{27}{6} = \\frac{9}{2}\n$$\n$$\n\\|\\mathbf{g}_{2}\\|_{2}^{2} = \\left(\\frac{1}{\\sqrt{14}}\\right)^{2} (5^{2} + 2^{2} + 6^{2}) = \\frac{1}{14}(25+4+36) = \\frac{65}{14}\n$$\n现在，我们将它们相加，求得 $\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2}$：\n$$\n\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2} = \\frac{9}{2} + \\frac{65}{14} = \\frac{9 \\cdot 7}{2 \\cdot 7} + \\frac{65}{14} = \\frac{63}{14} + \\frac{65}{14} = \\frac{128}{14} = \\frac{64}{7}\n$$\n\n**3. 计算比率 $r$**\n\n最后，我们计算比率 $r$：\n$$\nr = \\frac{\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2}}{\\|\\mathbf{G}_{\\mathrm{free}}\\|_{F}^{2}} = \\frac{64/7}{28} = \\frac{64}{7 \\times 28} = \\frac{64}{196}\n$$\n为了化简分数，我们将分子和分母同除以它们的最大公约数 $4$。\n$$\nr = \\frac{64 \\div 4}{196 \\div 4} = \\frac{16}{49}\n$$",
            "answer": "$$\n\\boxed{\\frac{16}{49}}\n$$"
        },
        {
            "introduction": "正向模型的特性直接决定了逆问题的难易程度。本练习将引导您从物理第一性原理出发构建一个导联场矩阵，并分析一个关键的数学特性——互相关性（mutual coherence），它量化了不同神经源在传感器上产生信号的相似性。您将进一步探索这种相关性如何根据稀疏恢复理论，限制我们能够准确重建的神经活动模式。",
            "id": "4157990",
            "problem": "考虑一个简化但科学上合理的正向建模场景中的脑电图（EEG）和脑磁图（MEG）源定位逆问题。在与生物电场相关的麦克斯韦方程组的准静态范围内，由神经电流偶极子在均匀、各向同性的体积导体中产生的电势，可以通过一个源于电势泊松方程的经典解得到很好的描述。您将使用此模型构建一个导联场矩阵，并分析源的空间间距如何影响导联场的互相干性，以及因此影响可通过凸稀疏估计算法恢复的稀疏度。\n\n给定一个均匀导体，其电导率 $\\sigma$ 等于 $0.33$ $\\mathrm{S/m}$。传感器均匀放置在 $x$-$y$ 平面内半径为 $R_{\\mathrm{e}}=0.09$ $\\mathrm{m}$ 的圆上，模拟一个理想化的头皮脑电图传感器环。传感器数量为 $M=64$。假定的神经源被建模为理想电流偶极子，位于同一平面内半径为 $R_{\\mathrm{s}}=0.08$ $\\mathrm{m}$ 的同心内圆上，每个偶极子都径向朝外。每个源的偶极矩大小为 $p_0=1\\times 10^{-8}$ $\\mathrm{A\\cdot m}$。\n\n正向模型应使用无限均匀导体中点电流偶极子的标准准静态电势，将单位源振幅（具有固定的偶极矩大小 $p_0$ 和径向方向）映射到传感器电势。由此，构建导联场矩阵 $G\\in\\mathbb{R}^{M\\times N}$，其第 $j$ 列包含由第 $j$ 个源在所有 $M$ 个传感器上产生的电势，源集合为沿源环上的半圆弧（角度为 $\\pi$ 弧度）分布的 $N$ 个源。\n\n将导联场矩阵 $G$ 的互相干性 $\\mu(G)$ 定义为 $G$ 的各列经单位 $\\ell_2$ 范数归一化后，不同列之间内积的绝对值的最大值。形式上，如果 $\\hat{\\mathbf{g}}_j=\\mathbf{g}_j/\\|\\mathbf{g}_j\\|_2$ 表示 $G$ 的第 $j$ 个归一化列，则\n$$\n\\mu(G)=\\max_{i\\neq j}\\left|\\hat{\\mathbf{g}}_i^\\top \\hat{\\mathbf{g}}_j\\right|.\n$$\n使用稀疏近似理论中基于相干性的恢复保证，根据 $\\mu(G)$ 预测在 $\\ell_1$ 最小化下理论上保证精确恢复的最大整数稀疏度 $s_{\\max}$。\n\n请实现一个程序，对于以下源间距 $d$ 的测试套件（解释为沿 $\\pi$ 弧度半圆的目标弧长间距），构建相应的导联场矩阵 $G$，计算 $\\mu(G)$，并预测 $s_{\\max}$：\n- 测试用例 1：$d=0.08$ $\\mathrm{m}$。\n- 测试用例 2：$d=0.04$ $\\mathrm{m}$。\n- 测试用例 3：$d=0.02$ $\\mathrm{m}$。\n- 测试用例 4：$d=0.01$ $\\mathrm{m}$。\n- 边界用例 5：$d=0.002$ $\\mathrm{m}$。\n\n对于每个测试用例，使用一个以 $x$ 轴为中心、角度为 $\\pi$ 弧度的弧段，并沿该弧段均匀放置源，使得源的数量 $N$ 是标称间距 $d$ 能容纳于该弧段（包括端点）的最大整数。具体来说，设弧长为 $L=\\pi R_{\\mathrm{s}}$，并设 $N=\\left\\lfloor L/d\\right\\rfloor+1$，然后在弧段上以等间距角度放置源，使得实际间距为 $L/(N-1)$。所有角度必须以弧度为单位，所有距离以米为单位，电势以伏特为单位。您可以将 $p_0$ 和 $\\sigma$ 视为常数，并且必须使用无限均匀导体模型。该程序必须：\n- 在半径为 $R_{\\mathrm{e}}$ 的环上构建传感器位置 $\\mathbf{r}_i$，$i=1,\\dots,M$。\n- 在半径为 $R_{\\mathrm{s}}$ 的半圆上均匀构建源位置 $\\mathbf{r}_0^{(j)}$，$j=1,\\dots,N$，其偶极子矢量 $\\mathbf{p}^{(j)}$ 径向朝外，大小为 $p_0$。\n- 使用无限均匀导体中的准静态偶极子电势，通过计算每个源在每个传感器处产生的电势来计算导联场矩阵 $G$。\n- 计算如上定义的 $\\mu(G)$ 以及相应的预测整数稀疏度极限 $s_{\\max}$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个形式为 $[\\mu(G), s_{\\max}]$ 的双元素列表。例如，输出应类似于 $[[\\mu_1,s_1],[\\mu_2,s_2],\\dots]$。$\\mu(G)$ 的值应为浮点数，$s_{\\max}$ 为整数。不应打印其他任何文本。",
            "solution": "该问题是有效的。它在科学上基于静电学和稀疏信号恢复的原理，是良构的，并提供了一套完整且一致的参数和定义。\n\n解决方案首先阐述了底层的物理和数学原理，然后详细说明了为每个测试用例计算所需量的算法步骤。\n\n### 1. 基本原理\n\n#### 1.1. 正向模型：电流偶极子的电势\n在与生物电场相关的准静态范围内，导电介质中电流源分布产生的电势 $\\Phi$ 由泊松方程决定。对于一个电导率为 $\\sigma$ 的均匀各向同性介质，位于 $\\mathbf{r}_0$ 处、矩为 $\\mathbf{p}$ 的理想电流偶极子在位置 $\\mathbf{r}$ 产生的电势由以下公式给出：\n$$\n\\Phi(\\mathbf{r}) = \\frac{1}{4\\pi\\sigma} \\frac{\\mathbf{p} \\cdot (\\mathbf{r} - \\mathbf{r}_0)}{\\|\\mathbf{r} - \\mathbf{r}_0\\|_2^3}\n$$\n这个公式是 $\\nabla \\cdot (\\sigma \\nabla \\Phi) = I_v$ 的解，其中偶极子的体积电流源为 $I_v = -\\nabla \\cdot (\\mathbf{p}\\delta(\\mathbf{x}-\\mathbf{r}_0))$，而 $\\delta(\\cdot)$ 是狄拉克δ函数。\n\n#### 1.2. 导联场矩阵\n导联场矩阵 $G \\in \\mathbb{R}^{M \\times N}$ 表示线性正向模型，将 $N$ 个源的振幅映射到 $M$ 个传感器上测得的电势。元素 $G_{ij}$ 是由第 $j$ 个源偶极子（位置为 $\\mathbf{r}_0^{(j)}$，矩为 $\\mathbf{p}^{(j)}$）在第 $i$ 个传感器位置 $\\mathbf{r}_i$ 产生的电势。根据上述公式，对于传感器 $i$ 和源 $j$：\n$$\nG_{ij} = \\frac{1}{4\\pi\\sigma} \\frac{\\mathbf{p}^{(j)} \\cdot (\\mathbf{r}_i - \\mathbf{r}_0^{(j)})}{\\|\\mathbf{r}_i - \\mathbf{r}_0^{(j)}\\|_2^3}\n$$\n问题规定偶极矩大小固定为 $p_0=1\\times 10^{-8}\\,\\mathrm{A\\cdot m}$，且方向为径向。这意味着对于位于 $\\mathbf{r}_0^{(j)}$ 的源，其矩为 $\\mathbf{p}^{(j)} = p_0 \\frac{\\mathbf{r}_0^{(j)}}{\\|\\mathbf{r}_0^{(j)}\\|_2}$。\n\n#### 1.3. 互相干性与稀疏恢复\n互相干性 $\\mu(G)$ 是稀疏近似理论中传感矩阵的一个关键属性。它被定义为矩阵中任意两个不同的、归一化后的列之间内积的绝对值的最大值：\n$$\n\\mu(G) = \\max_{j \\neq k} |\\langle \\hat{\\mathbf{g}}_j, \\hat{\\mathbf{g}}_k \\rangle| = \\max_{j \\neq k} \\left| \\frac{\\mathbf{g}_j^\\top \\mathbf{g}_k}{\\|\\mathbf{g}_j\\|_2 \\|\\mathbf{g}_k\\|_2} \\right|\n$$\n其中 $\\mathbf{g}_j$ 是 $G$ 的第 $j$ 列，$\\hat{\\mathbf{g}}_j$ 是其经 $\\ell_2$ 范数归一化后的版本。\n\n压缩感知中的一个基本结果保证，如果信号 $\\mathbf{s}$ 是 $s$-稀疏的（即最多有 $s$ 个非零元素），则可以通过 $\\ell_1$ 范数最小化（基追踪）从测量值 $\\mathbf{y} = G\\mathbf{s}$ 中唯一恢复它，前提是稀疏度 $s$ 满足：\n$$\ns  \\frac{1}{2}\\left(1 + \\frac{1}{\\mu(G)}\\right)\n$$\n问题要求的是此保证成立的最大整数稀疏度 $s_{\\max}$。这是满足严格不等式的最大整数 $s$。设 $X = \\frac{1}{2}(1 + 1/\\mu(G))$。$s_{\\max}$ 的值是严格小于 $X$ 的最大整数，可以计算为 $s_{\\max} = \\lceil X \\rceil - 1$。\n\n### 2. 算法实现\n\n对于每个给定的源间距 $d$，我们执行以下步骤：\n\n**步骤 1：定义几何形状和常数**\n给定的常数有：传感器半径 $R_{\\mathrm{e}}=0.09\\,\\mathrm{m}$，源半径 $R_{\\mathrm{s}}=0.08\\,\\mathrm{m}$，传感器数量 $M=64$，电导率 $\\sigma=0.33\\,\\mathrm{S/m}$，以及偶极矩大小 $p_0=1\\times 10^{-8}\\,\\mathrm{A\\cdot m}$。传感器放置在 $x$-$y$ 平面的一个圆上。对于 $i \\in \\{1, \\dots, M\\}$，传感器位置 $\\mathbf{r}_i$ 为：\n$$\n\\mathbf{r}_i = (R_{\\mathrm{e}}\\cos(\\theta_i), R_{\\mathrm{e}}\\sin(\\theta_i), 0) \\quad \\text{其中} \\quad \\theta_i = \\frac{2\\pi(i-1)}{M}\n$$\n\n**步骤 2：确定源位置**\n源位于一个以 $x$ 轴为中心（从角度 $-\\pi/2$ 到 $\\pi/2$）的半径为 $R_{\\mathrm{s}}$ 的半圆弧上。弧长为 $L=\\pi R_{\\mathrm{s}}$。对于给定的标称间距 $d$，源的数量为 $N = \\lfloor L/d \\rfloor + 1$。然后将源均匀地放置在该弧上。对于 $j \\in \\{1, \\dots, N\\}$，第 $j$ 个源的角度是：\n$$\n\\phi_j = -\\frac{\\pi}{2} + \\frac{\\pi(j-1)}{N-1} \\quad (\\text{对于 } N  1)\n$$\n第 $j$ 个源的位置是 $\\mathbf{r}_0^{(j)} = (R_{\\mathrm{s}}\\cos(\\phi_j), R_{\\mathrm{s}}\\sin(\\phi_j), 0)$。偶极矩由于是径向的，所以是 $\\mathbf{p}^{(j)} = p_0 (\\cos(\\phi_j), \\sin(\\phi_j), 0)$。\n\n**步骤 3：构建导联场矩阵 $G$**\n我们计算每个元素 $G_{ij}$。如初步分析所示，点积和范数可以简化为：\n$$\n\\mathbf{p}^{(j)} \\cdot (\\mathbf{r}_i - \\mathbf{r}_0^{(j)}) = p_0(R_{\\mathrm{e}}\\cos(\\theta_i - \\phi_j) - R_{\\mathrm{s}})\n$$\n$$\n\\|\\mathbf{r}_i - \\mathbf{r}_0^{(j)}\\|_2^2 = R_{\\mathrm{e}}^2 + R_{\\mathrm{s}}^2 - 2R_{\\mathrm{e}}R_{\\mathrm{s}}\\cos(\\theta_i - \\phi_j)\n$$\n因此，\n$$\nG_{ij} = \\frac{p_0}{4\\pi\\sigma} \\frac{R_{\\mathrm{e}}\\cos(\\theta_i - \\phi_j) - R_{\\mathrm{s}}}{(R_{\\mathrm{e}}^2 + R_{\\mathrm{s}}^2 - 2R_{\\mathrm{e}}R_{\\mathrm{s}}\\cos(\\theta_i - \\phi_j))^{3/2}}\n$$\n在计算互相干性 $\\mu(G)$ 时，常数因子 $C = p_0/(4\\pi\\sigma)$ 将在列归一化过程中被抵消。因此，我们可以计算一个不含此因子的矩阵 $G'$。\n\n**步骤 4：计算互相干性 $\\mu(G)$**\n使用上一步计算出的矩阵 $G'$：\n1. 将每列 $\\mathbf{g}'_j$ 归一化为单位 $\\ell_2$ 范数：$\\hat{\\mathbf{g}}'_j = \\mathbf{g}'_j / \\|\\mathbf{g}'_j\\|_2$。令结果矩阵为 $\\hat{G}'$。\n2. 计算内积的格拉姆矩阵：$K = (\\hat{G}')^\\top \\hat{G}'$。\n3. 互相干性是 $K$ 的非对角元素绝对值的最大值：\n   $\\mu(G) = \\max_{j \\neq k} |K_{jk}|$。\n\n**步骤 5：预测最大稀疏度 $s_{\\max}$**\n使用计算出的 $\\mu(G)$ 值：\n1. 计算恢复阈值 $X = \\frac{1}{2}(1 + 1/\\mu(G))$。\n2. 找到严格小于 $X$ 的最大整数 $s_{\\max}$：$s_{\\max} = \\lceil X \\rceil - 1$。\n\n对每个测试用例的 $d$ 值重复此过程。随着 $d$ 减小， $N$ 增加，源变得更加密集，预期会导致 $\\mu(G)$ 增加和可恢复稀疏度 $s_{\\max}$ 减小。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the EEG/MEG source localization problem for multiple test cases.\n    For each source spacing `d`, it constructs the lead-field matrix G,\n    computes its mutual coherence mu(G), and predicts the maximum guaranteed\n    recoverable sparsity s_max.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases_d = [0.08, 0.04, 0.02, 0.01, 0.002]\n\n    # --- Model Parameters ---\n    # Number of sensors\n    M = 64\n    # Radius of sensor ring (m)\n    R_e = 0.09\n    # Radius of source ring (m)\n    R_s = 0.08\n    # Conductivity and dipole moment are not needed as they form a constant\n    # factor that cancels out in the coherence calculation.\n    # sigma = 0.33\n    # p0 = 1e-8\n\n    # --- Sensor Positions ---\n    # Angles for M sensors uniformly spaced on a full circle\n    theta = np.linspace(0, 2 * np.pi, M, endpoint=False)\n\n    results = []\n\n    for d in test_cases_d:\n        # --- Source Configuration for current test case ---\n        # Total arc length of the half-circle for sources\n        arc_length = np.pi * R_s\n        \n        # Number of sources N based on spacing d\n        # Using np.floor and adding 1 as per problem spec\n        N = int(np.floor(arc_length / d)) + 1\n\n        if N == 1:\n            # Mutual coherence is not defined for N = 1\n            # This case is not expected for the given test values.\n            # We can append a placeholder and continue, e.g. [nan, 0]\n            # however, problem ensures N > 1 for given d.\n            continue\n        \n        # Angles for N sources uniformly spaced on a half-circle arc (-pi/2 to pi/2)\n        phi = np.linspace(-np.pi / 2, np.pi / 2, N)\n\n        # --- Lead-Field Matrix (G) Construction ---\n        # We can compute the matrix efficiently using numpy broadcasting.\n        # The constant factor p0/(4*pi*sigma) is ignored as it cancels out.\n        \n        # cos(theta_i - phi_j) for all i, j pairs\n        cos_diff = np.cos(theta[:, np.newaxis] - phi[np.newaxis, :])\n        \n        # Numerator of the potential formula\n        numerator = R_e * cos_diff - R_s\n        \n        # Denominator of the potential formula\n        denominator = (R_e**2 + R_s**2 - 2 * R_e * R_s * cos_diff)**1.5\n        \n        # The lead-field matrix G (without the physical constant factor)\n        G = numerator / denominator\n\n        # --- Mutual Coherence (mu) Calculation ---\n        # Normalize each column of G to have unit l2-norm\n        G_norms = np.linalg.norm(G, axis=0)\n        G_normalized = G / G_norms[np.newaxis, :]\n        \n        # Compute the Gram matrix (inner products of normalized columns)\n        gram_matrix = G_normalized.T @ G_normalized\n        \n        # Set diagonal to 0 to ignore self-correlations (i=j)\n        np.fill_diagonal(gram_matrix, 0)\n        \n        # Mutual coherence is the max absolute off-diagonal element\n        mu = np.max(np.abs(gram_matrix))\n\n        # --- Sparsity Limit (s_max) Calculation ---\n        # The recovery guarantee holds for sparsity s  0.5 * (1 + 1/mu)\n        # s_max is the largest integer satisfying this strict inequality.\n        if mu > 1e-12: # Use tolerance for float comparison\n            recovery_threshold = 0.5 * (1.0 + 1.0 / mu)\n            # s_max = ceil(X) - 1\n            s_max = int(math.ceil(recovery_threshold) - 1)\n        else:\n            # If mu is 0 (perfectly orthogonal), sparsity limit is theoretically infinite.\n            # However, N is the maximum possible sparsity.\n            # For Welch bound based guarantees, it would be M. We stick to the problem's formula.\n            s_max = N\n\n        results.append([mu, s_max])\n    \n    # --- Final Output Formatting ---\n    # The output must be a single line, e.g., [[mu1,s1],[mu2,s2],...]\n    output_str = \"[\" + \",\".join([f\"[{mu_val},{s_max_val}]\" for mu_val, s_max_val in results]) + \"]\"\n\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在求得一个逆解（即一个估计器 $W$）之后，我们必须能够量化其性能。本练习介绍分辨率矩阵 $R = WG$ 的概念，它描述了估计的源活动与真实源活动之间的关系。通过分析点扩展函数（point-spread function, PSF）及其相关指标，如半峰全宽（full-width at half-maximum, FWHM）和泄露（leakage），我们将学习一套评估任何线性逆解器空间分辨率的标准方法。",
            "id": "4158059",
            "problem": "给定一个用于脑电图 (EEG) 和脑磁图 (MEG) 的线性正向模型，其中脑电图 (EEG) 和脑磁图 (MEG) 的测量值在 Maxwell 方程组的准静态状态下被建模为神经电流源的线性叠加与加性噪声之和。在此设定下，正向模型表示为 $y = G x + n$，其中 $y \\in \\mathbb{R}^{m}$ 是传感器测量值，$x \\in \\mathbb{R}^{p}$ 是 $p$ 维源网格上的源振幅，$G \\in \\mathbb{R}^{m \\times p}$ 是由电磁学和头部电导率决定的导联场（增益）矩阵，而 $n \\in \\mathbb{R}^{m}$ 是加性噪声。假设 $n$ 是协方差为 $R_n \\in \\mathbb{R}^{m \\times m}$ 的零均值高斯分布，$x$ 是协方差为 $R_x \\in \\mathbb{R}^{p \\times p}$ 的零均值高斯分布。考虑在这些高斯假设和线性条件下，通过最小化期望平方误差得到的最小范数解。逆估计器是线性的，$ \\hat{x} = W y$，分辨率核（分辨率矩阵）是 $R = W G \\in \\mathbb{R}^{p \\times p}$。列 $R_{:,j}$ 是位于位置 $j$ 的单位振幅焦点源的点扩散函数。\n\n您的任务是使用高斯线性模型从第一性原理推导 $W$ 并计算分辨率核 $R$，然后分析指定焦点源索引 $j_0$ 的点扩散函数。为了进行分析，定义振幅点扩散向量 $p \\in \\mathbb{R}^{p}$ 为 $p_i = |R_{i,j_0}|$。如果分母非零，则将其归一化为单位 $\\ell_1$ 质量，即 $\\tilde{p} = p / \\sum_{i=1}^{p} p_i$，否则设置 $\\tilde{p} = 0$。令峰值索引为 $\\arg\\max_i p_i$。半峰全宽 (FWHM) 在一维源网格上定义为围绕 $j_0$ 的连续宽度，包括满足 $p_i \\ge \\frac{1}{2} p_{j_0}$ 的索引；如果 $p_{j_0} = 0$，则定义 FWHM 为 $0$。对于邻域半径 $r \\in \\mathbb{N}$，半径 $r$ 邻域外的泄漏分数为 $1 - \\sum_{|i-j_0|\\le r} \\tilde{p}_i$。为每个测试用例返回以下三元组：一个指示符（如果峰值在 $j_0$ 处则为 $1$，否则为 $0$），FWHM（一个非负整数），以及泄漏分数（一个四舍五入到六位小数的浮点数）。\n\n请使用以下测试套件。每个测试用例包含一个导联场矩阵 $G$、一个噪声协方差 $R_n$、一个源协方差 $R_x$、一个焦点索引 $j_0$ 和一个邻域半径 $r$。所有矩阵均为实值。网格是一维的，并按索引排序。\n\n测试用例 1（理想情况，均匀源先验，均匀噪声）：\n- $m = 4$，$p = 6$。\n- $G = \\begin{bmatrix}\n0.8  0.1  0.0  -0.2  0.3  0.5 \\\\\n0.0  0.5  0.4  0.1  -0.1  0.2 \\\\\n0.2  -0.3  0.6  0.0  0.4  -0.2 \\\\\n-0.1  0.2  -0.2  0.7  0.1  0.0\n\\end{bmatrix}$。\n- $R_n = 0.05 I_{4}$。\n- $R_x = I_{6}$。\n- $j_0 = 3$。\n- $r = 1$。\n\n测试用例 2（病态正向模型列，均匀源先验，低噪声，边界焦点索引）：\n- $m = 3$，$p = 5$。\n- $G = \\begin{bmatrix}\n0.6  0.9  0.91  0.1  0.0 \\\\\n0.0  0.2  0.21  0.0  0.5 \\\\\n0.1  0.3  0.29  0.0  -0.1\n\\end{bmatrix}$。\n- $R_n = 0.01 I_{3}$。\n- $R_x = I_{5}$。\n- $j_0 = 0$。\n- $r = 0$。\n\n测试用例 3（各向异性源先验和各向异性噪声，边界焦点索引）：\n- $m = 4$，$p = 7$。\n- $G = \\begin{bmatrix}\n0.4  -0.2  0.0  0.1  0.5  0.3  0.0 \\\\\n0.0  0.1  0.2  -0.4  0.2  0.0  0.1 \\\\\n0.1  0.0  -0.3  0.2  0.0  0.4  -0.2 \\\\\n0.2  0.3  0.1  0.0  -0.1  0.2  0.5\n\\end{bmatrix}$。\n- $R_n = \\mathrm{diag}(0.02, 0.05, 0.03, 0.08)$。\n- $R_x = \\mathrm{diag}(1.0, 0.5, 0.2, 0.2, 0.5, 1.0, 1.5)$。\n- $j_0 = 6$。\n- $r = 2$。\n\n要求：\n- 针对每个测试用例，从高斯线性模型推导 $W$ 并计算 $R = W G$，不使用除所列矩阵之外的任何外部数据。\n- 对于每个测试用例，计算：\n  $1)$ 峰值正确性指示符，如果 $\\arg\\max_i p_i = j_0$ 则为 $1$，否则为 $0$，\n  $2)$ FWHM，如上文定义的非负整数，\n  $3)$ 基于 $\\tilde{p}$ 的半径 $r$ 之外的泄漏分数，四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个元素是表示为一个用方括号括起来的逗号分隔列表的测试用例三元组。例如，三个测试用例的输出应类似于 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]$，其中 $a_k$ 是 $\\{0,1\\}$ 中的整数，$b_k$ 是非负整数，$c_k$ 是小数点后有六位的浮点数。",
            "solution": "用户提供了一个关于 EEG/MEG 源定位领域的问题。第一步是验证问题陈述。\n\n### 步骤 1：提取已知条件\n- **正向模型**：$y = Gx + n$，其中 $y \\in \\mathbb{R}^{m}$（测量值），$x \\in \\mathbb{R}^{p}$（源振幅），$G \\in \\mathbb{R}^{m \\times p}$（导联场矩阵），以及 $n \\in \\mathbb{R}^{m}$（加性噪声）。\n- **统计假设**：\n    - 源向量 $x$ 是一个零均值高斯随机变量，其协方差为 $R_x \\in \\mathbb{R}^{p \\times p}$，即 $x \\sim \\mathcal{N}(0, R_x)$。\n    - 噪声向量 $n$ 是一个零均值高斯随机变量，其协方差为 $R_n \\in \\mathbb{R}^{m \\times m}$，即 $n \\sim \\mathcal{N}(0, R_n)$。\n    - $x$ 和 $n$ 统计上独立。\n- **估计器**：逆估计器是线性的，$\\hat{x} = Wy$，并最小化期望平方误差 $E[\\|x - \\hat{x}\\|^2]$。\n- **分辨率分析**：\n    - 分辨率矩阵：$R = WG \\in \\mathbb{R}^{p \\times p}$。\n    - 源 $j_0$ 的点扩散函数 (PSF)：列向量 $R_{:,j_0}$。\n    - 振幅 PSF 向量：$p \\in \\mathbb{R}^p$，其元素为 $p_i = |R_{i,j_0}|$。\n    - 归一化振幅 PSF 向量：$\\tilde{p} = p / \\sum_{i=1}^{p} p_i$（如果 $\\sum p_i \\neq 0$，否则 $\\tilde{p}=0$）。\n- **要计算的指标**：\n    1.  **峰值正确性**：一个指示符，如果 $\\arg\\max_i p_i = j_0$ 则为 $1$，否则为 $0$。\n    2.  **半峰全宽 (FWHM)**：围绕 $j_0$ 的索引的连续宽度（整数），其中 $p_i \\ge \\frac{1}{2} p_{j_0}$。如果 $p_{j_0} = 0$，FWHM 为 $0$。\n    3.  **泄漏分数**：对于给定的半径 $r \\in \\mathbb{N}$，该分数为 $1 - \\sum_{|i-j_0|\\le r} \\tilde{p}_i$。\n- **测试用例**：提供了三个测试用例，每个都指定了矩阵 $G$、$R_n$、$R_x$ 以及参数 $j_0$、$r$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于生物电磁学中标准的线性逆问题公式，特别是针对 EEG/MEG 源定位。模型 $y=Gx+n$ 以及对源和噪声的高斯先验是贝叶斯或正则化逆解的基本组成部分，例如最小范数估计 (MNE) 及其变体（dSPM、sLORETA）。通过最小化均方误差 (MMSE) 来推导估计器以获得维纳滤波器是估计理论中的一种经典且正确的方法。使用分辨率矩阵、点扩散函数、FWHM 和泄漏是评估逆解质量的标准、成熟的方法。该问题在科学上是合理的，并基于已建立的原则。\n- **适定性**：该问题要求推导一个特定的估计器并将其应用于给定的数据。维纳滤波器的推导是一个适定的数学问题。随后的计算是确定性的。所提供的协方差矩阵被指定为单位矩阵或具有正项的对角矩阵，确保它们是正定的并且可逆。问题的结构旨在为每个测试用例产生唯一的解决方案。\n- **客观性**：问题以精确、客观的数学语言陈述。所有术语都得到了明确定义。\n- **完整性和一致性**：为每个测试用例提供了所有必要的数据（$G, R_n, R_x, j_0, r$）。矩阵的维度与数学公式一致。\n- **其他缺陷**：该问题既不琐碎，也不是隐喻性的，更不是科学上无法验证的。它是计算神经科学和信号处理领域的一个标准的、非平凡的练习。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。我将继续推导解决方案并实现所需的计算。\n\n### 基于原理的解决方案\n\n目标是找到一个线性估计器 $\\hat{x} = Wy$，以最小化期望平方误差 $J(W) = E[\\|x - \\hat{x}\\|^2]$。这是估计理论中的一个经典问题，其解被称为维纳滤波器。\n\n**1. 最小均方误差 (MMSE) 估计器的推导**\n\n估计误差为 $e = x - \\hat{x} = x - Wy$。代入正向模型 $y = Gx + n$，我们得到：\n$$ e = x - W(Gx + n) = (I - WG)x - Wn $$\n成本函数是误差协方差矩阵 $C_e = E[ee^T]$ 的迹：\n$$ J(W) = E[\\|e\\|^2] = \\mathrm{Tr}(C_e) $$\n误差协方差为：\n$$ C_e = E[((I - WG)x - Wn)((I - WG)x - Wn)^T] $$\n由于源信号 $x$ 和噪声 $n$ 是独立的且均值为零，交叉项 $E[xn^T]$ 为零。因此，期望展开为：\n$$ C_e = E[(I - WG)xx^T(I - WG)^T] + E[Wnn^TW^T] $$\n使用定义 $R_x = E[xx^T]$ 和 $R_n = E[nn^T]$，我们有：\n$$ C_e = (I - WG)R_x(I - WG)^T + WR_nW^T $$\n需要最小化的成本函数是：\n$$ J(W) = \\mathrm{Tr}((I - WG)R_x(I - WG)^T + WR_nW^T) $$\n为了找到最优的 $W$，我们计算 $J(W)$ 关于 $W$ 的矩阵导数并将其设为零。展开迹表达式：\n$$ J(W) = \\mathrm{Tr}(R_x - WGR_x - R_xG^TW^T + WGR_xG^TW^T + WR_nW^T) $$\n使用标准矩阵微积分恒等式，导数为：\n$$ \\frac{\\partial J(W)}{\\partial W} = -2R_xG^T + 2W(GR_xG^T + R_n) = 0 $$\n求解 $W$ 得：\n$$ W(GR_xG^T + R_n) = R_xG^T $$\n$$ W = R_xG^T(GR_xG^T + R_n)^{-1} $$\n项 $(GR_xG^T + R_n)$ 是测量值 $y$ 的协方差，因为 $C_y = E[yy^T] = E[(Gx+n)(Gx+n)^T] = GR_xG^T + R_n$。该项是一个 $m \\times m$ 矩阵。由于 $R_n$ 是正定的，它的可逆性得到保证。这个 $W$ 的表达式就是维纳滤波器，它是最优的线性 MMSE 估计器。\n\n**2. 分辨率分析**\n\n分辨率矩阵 $R$ 描述了估计器 $\\hat{x}$ 如何响应真实的源分布 $x$。在无噪声情况下（$n=0$，所以 $y=Gx$），估计将是 $\\hat{x} = W y = WG x = Rx$。因此，分辨率矩阵 $R$ 将真实的源活动映射到估计的源活动。\n$$ R = WG = R_xG^T(GR_xG^T + R_n)^{-1}G $$\n$R$ 的第 $j$ 列，表示为 $R_{:,j}$，是点扩散函数 (PSF)。它表示当真实活动是在位置 $j$ 的单位振幅焦点源时（即，$x$ 是一个在索引 $j$ 处为 $1$、其余为零的向量）的估计源分布。\n\n分析指标从此 PSF 计算得出。\n- 振幅 PSF 向量 $p$ 定义为 $p_i = |R_{i,j_0}|$。\n- 归一化振幅 PSF 向量 $\\tilde{p}$ 是将 $p$ 归一化以具有单位 $\\ell_1$ 范数：$\\tilde{p} = p / \\sum_i p_i$。\n\n**3. 指标计算**\n\n对于每个具有给定焦点索引 $j_0$ 和半径 $r$ 的测试用例，我们计算以下三个指标：\n\n- **峰值正确性**：我们找到振幅 PSF 向量 $p$ 的最大值的索引，即 $i_{peak} = \\arg\\max_i p_i$。如果 $i_{peak} = j_0$，指示符为 $1$，否则为 $0$。\n\n- **FWHM**：半峰全宽是根据振幅 PSF 向量 $p$ 计算的。首先，我们检查焦点源位置的振幅 $p_{j_0}$ 是否为零。如果是，则 FWHM 为 $0$。否则，我们定义一个阈值 $T = 0.5 \\times p_{j_0}$。FWHM 是包含 $j_0$ 且其中 $p_i \\ge T$ 的最大连续索引块的大小。这是通过从宽度为 $1$（对于 $j_0$ 本身）开始，并从 $j_0$ 向左和向右扩展，只要所有中间索引都满足条件 $p_i \\ge T$。\n\n- **泄漏分数**：该指标量化了估计活动有多少“泄漏”到真实源定义的邻域之外。使用归一化的振幅 PSF $\\tilde{p}$，我们对真实源 $j_0$ 半径 $r$ 范围内的概率求和。该邻域包括索引 $i$ 使得 $|i - j_0| \\le r$。泄漏是此总和的补集：\n$$ \\text{泄漏} = 1 - \\sum_{i = \\max(0, j_0-r)}^{\\min(p-1, j_0+r)} \\tilde{p}_i $$\n\n**4. 计算流程**\n\n以下算法将针对每个提供的测试用例实施：\n1.  从测试用例数据中定义矩阵 $G$、$R_n$、$R_x$ 和参数 $j_0$、$r$。\n2.  计算矩阵 $M = GR_xG^T + R_n$。\n3.  计算其逆矩阵 $M^{-1}$。\n4.  计算逆算子 $W = R_xG^T M^{-1}$。\n5.  计算分辨率矩阵 $R = WG$。\n6.  提取 PSF，即第 $j_0$ 列 $R_{:,j_0}$。\n7.  通过取 PSF 的绝对值来计算振幅 PSF 向量 $p$。\n8.  计算归一化的振幅 PSF 向量 $\\tilde{p}$。\n9.  根据上述定义计算峰值正确性指示符、FWHM 和泄漏分数。\n10. 格式化并存储得到的三元组值。\n\n此过程将对所有测试用例重复执行。",
            "answer": "```python\nimport numpy as np\n\ndef compute_metrics(G, Rn, Rx, j0, r):\n    \"\"\"\n    Computes the resolution metrics for a given EEG/MEG inverse problem setup.\n\n    Args:\n        G (np.ndarray): The lead-field matrix (m x p).\n        Rn (np.ndarray): The noise covariance matrix (m x m).\n        Rx (np.ndarray): The source covariance matrix (p x p).\n        j0 (int): The index of the focal source.\n        r (int): The radius for the leakage calculation.\n\n    Returns:\n        tuple: (peak_correctness, fwhm, leakage_fraction)\n    \"\"\"\n    p_dim = G.shape[1]\n\n    # Step 1: Compute the Wiener filter W\n    # W = Rx @ G^T @ inv(G @ Rx @ G^T + Rn)\n    M = G @ Rx @ G.T + Rn\n    try:\n        M_inv = np.linalg.inv(M)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudo-inverse if inversion fails, though not expected for this problem's setup\n        M_inv = np.linalg.pinv(M)\n        \n    W = Rx @ G.T @ M_inv\n\n    # Step 2: Compute the resolution matrix R\n    R = W @ G\n\n    # Step 3: Analyze the point-spread function (PSF) for source j0\n    psf_column = R[:, j0]\n    p_vec = np.abs(psf_column)\n\n    # Step 4: Compute the metrics\n    \n    # Metric 1: Peak Correctness\n    peak_idx = np.argmax(p_vec)\n    peak_correctness = 1 if peak_idx == j0 else 0\n\n    # Metric 2: Full-Width at Half-Maximum (FWHM)\n    p_j0 = p_vec[j0]\n    fwhm = 0\n    if p_j0 > 1e-12: # Use a small tolerance for floating point zero\n        threshold = 0.5 * p_j0\n        \n        # Check j0 itself\n        if p_vec[j0] >= threshold:\n            fwhm = 1\n            # Search right from j0\n            for i in range(j0 + 1, p_dim):\n                if p_vec[i] >= threshold:\n                    fwhm += 1\n                else:\n                    break\n            \n            # Search left from j0\n            for i in range(j0 - 1, -1, -1):\n                if p_vec[i] >= threshold:\n                    fwhm += 1\n                else:\n                    break\n\n    # Metric 3: Leakage Fraction\n    p_sum = np.sum(p_vec)\n    if p_sum > 1e-12:\n        p_tilde = p_vec / p_sum\n        \n        start_idx = max(0, j0 - r)\n        end_idx = min(p_dim - 1, j0 + r)\n        \n        neighborhood_sum = np.sum(p_tilde[start_idx : end_idx + 1])\n        leakage_fraction = 1.0 - neighborhood_sum\n    else:\n        # If p_sum is zero, the PSF is zero. All energy has \"leaked\"; leakage is 100%.\n        leakage_fraction = 1.0\n\n    return peak_correctness, fwhm, leakage_fraction\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, compute results, and print the output.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"G\": np.array([\n                [0.8, 0.1, 0.0, -0.2, 0.3, 0.5],\n                [0.0, 0.5, 0.4, 0.1, -0.1, 0.2],\n                [0.2, -0.3, 0.6, 0.0, 0.4, -0.2],\n                [-0.1, 0.2, -0.2, 0.7, 0.1, 0.0]\n            ]),\n            \"Rn\": 0.05 * np.identity(4),\n            \"Rx\": np.identity(6),\n            \"j0\": 3,\n            \"r\": 1\n        },\n        # Test case 2\n        {\n            \"G\": np.array([\n                [0.6, 0.9, 0.91, 0.1, 0.0],\n                [0.0, 0.2, 0.21, 0.0, 0.5],\n                [0.1, 0.3, 0.29, 0.0, -0.1]\n            ]),\n            \"Rn\": 0.01 * np.identity(3),\n            \"Rx\": np.identity(5),\n            \"j0\": 0,\n            \"r\": 0\n        },\n        # Test case 3\n        {\n            \"G\": np.array([\n                [0.4, -0.2, 0.0, 0.1, 0.5, 0.3, 0.0],\n                [0.0, 0.1, 0.2, -0.4, 0.2, 0.0, 0.1],\n                [0.1, 0.0, -0.3, 0.2, 0.0, 0.4, -0.2],\n                [0.2, 0.3, 0.1, 0.0, -0.1, 0.2, 0.5]\n            ]),\n            \"Rn\": np.diag([0.02, 0.05, 0.03, 0.08]),\n            \"Rx\": np.diag([1.0, 0.5, 0.2, 0.2, 0.5, 1.0, 1.5]),\n            \"j0\": 6,\n            \"r\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # A small fix for FWHM calculation for continuity.\n        peak_correctness, fwhm, leakage_fraction = compute_metrics(case[\"G\"], case[\"Rn\"], case[\"Rx\"], case[\"j0\"], case[\"r\"])\n        \n        # Re-check FWHM logic for continuity. The original logic is incorrect for non-contiguous regions.\n        p_dim = case[\"G\"].shape[1]\n        R = (case[\"Rx\"] @ case[\"G\"].T @ np.linalg.inv(case[\"G\"] @ case[\"Rx\"] @ case[\"G\"].T + case[\"Rn\"])) @ case[\"G\"]\n        p_vec = np.abs(R[:, case[\"j0\"]])\n        p_j0 = p_vec[case[\"j0\"]]\n        fwhm_fixed = 0\n        if p_j0 > 1e-12:\n            threshold = 0.5 * p_j0\n            \n            # Find the continuous block around j0\n            left_bound = case[\"j0\"]\n            while left_bound > 0 and p_vec[left_bound - 1] >= threshold:\n                left_bound -= 1\n            \n            right_bound = case[\"j0\"]\n            while right_bound  p_dim - 1 and p_vec[right_bound + 1] >= threshold:\n                right_bound += 1\n            \n            fwhm_fixed = right_bound - left_bound + 1\n        \n        results.append((peak_correctness, fwhm_fixed, leakage_fraction))\n    \n    # Format the final output string exactly as specified.\n    formatted_results = [f'[{r[0]},{r[1]},{r[2]:.6f}]' for r in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}