{
    "hands_on_practices": [
        {
            "introduction": "任何脑电源定位分析的基石都是正向模型，它通过一个称为增益矩阵（或导联场矩阵）$G$ 的关键数学对象，将大脑皮层中的神经电流源与头皮上传感器测得的信号联系起来。然而，$G$ 的具体形式并非一成不变，它取决于我们对神经源生物物理特性的基本假设。此练习  旨在通过动手计算，阐明两种最常见的源模型——“固定方向”和“自由方向”模型——是如何具体地改变增益矩阵的结构的。理解这一建模选择是进行任何有意义的源定位分析之前至关重要的第一步。",
            "id": "4158015",
            "problem": "给定一个用于脑电图 (EEG) 和脑磁图 (MEG) 的线性正向模型，该模型基于麦克斯韦方程组的准静态近似。其中，测量的传感器数据是皮层表面上一次电流偶极子产生的场的线性叠加。考虑一个具有 $N$ 个顶点的三角化皮层表面，每个顶点 $i$ 都有一个单位表面法线 $\\mathbf{n}_{i} \\in \\mathbb{R}^{3}$。在自由方向模型下，顶点 $i$ 处的电流是一个三维向量 $\\mathbf{j}_{i} \\in \\mathbb{R}^{3}$，其方向不受约束。在固定方向模型下，顶点 $i$ 处的电流被约束在 $\\mathbf{n}_{i}$ 的方向上，即 $\\mathbf{j}_{i} = q_{i}\\,\\mathbf{n}_{i}$，其中 $q_{i} \\in \\mathbb{R}$。正向模型的线性特性意味着传感器数据 $\\mathbf{y} \\in \\mathbb{R}^{M}$可以写成来自每个顶点的贡献的线性组合。\n\n从正向模型的线性特性和上述定义出发，完成以下任务：\n\n1. 从第一性原理出发，推导自由方向和固定方向源模型的传感器空间映射（增益）矩阵，并用导联场块 $\\mathbf{L}_{i} \\in \\mathbb{R}^{M \\times 3}$ 表示，其中 $\\mathbf{L}_{i}$ 将顶点 $i$ 处的三个正交单位偶极子映射到 $M$ 个传感器。将 $\\mathbf{G}_{\\mathrm{free}}$ 和 $\\mathbf{G}_{\\mathrm{fix}}$ 明确定义为 $\\{\\mathbf{L}_{i}\\}_{i=1}^{N}$ 和 $\\{\\mathbf{n}_{i}\\}_{i=1}^{N}$ 的函数。\n\n2. 为了量化在固定方向假设下增益矩阵相对于自由方向模型的变化，考虑无量纲比率\n$$\nr \\equiv \\frac{\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2}}{\\|\\mathbf{G}_{\\mathrm{free}}\\|_{F}^{2}},\n$$\n其中 $\\|\\cdot\\|_{F}$ 表示弗罗贝尼乌斯范数。对于一个具有 $M=3$ 个传感器和 $N=2$ 个顶点的具体配置，假设导联场块和单位法线为\n$$\n\\mathbf{L}_{1} = \\begin{pmatrix}\n1  0  2 \\\\\n0  1  1 \\\\\n-1  2  0\n\\end{pmatrix}, \\quad\n\\mathbf{L}_{2} = \\begin{pmatrix}\n2  -1  0 \\\\\n1  1  1 \\\\\n0  2  -2\n\\end{pmatrix},\n$$\n$$\n\\mathbf{n}_{1} = \\frac{1}{\\sqrt{6}}\\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix}, \\quad\n\\mathbf{n}_{2} = \\frac{1}{\\sqrt{14}}\\begin{pmatrix} 3 \\\\ 1 \\\\ -2 \\end{pmatrix}.\n$$\n计算此配置下 $r$ 的精确值。\n\n您的最终答案必须是一个以精确形式写出的实数。不需要四舍五入，也不需要报告单位。",
            "solution": "该问题需要一个两部分的解答：首先，推导自由方向和固定方向源模型的增益矩阵；其次，计算在特定配置下它们弗罗贝尼乌斯范数平方的比率。\n\n### 第 1 部分：增益矩阵的推导\n\n源电流与测量的传感器数据之间的关系是线性的，可以表示为 $\\mathbf{y} = \\mathbf{G}\\mathbf{J}$，其中 $\\mathbf{y} \\in \\mathbb{R}^{M}$ 是传感器测量向量，$\\mathbf{J}$ 是描述源电流的向量，$\\mathbf{G}$ 是增益矩阵（或导联场矩阵）。$\\mathbf{J}$ 和 $\\mathbf{G}$ 的结构取决于对源电流所做的假设。总传感器信号是每个顶点 $i$ 处的电流产生的信号的线性叠加：\n$$\n\\mathbf{y} = \\sum_{i=1}^{N} (\\text{来自顶点 } i \\text{ 的贡献})\n$$\n顶点 $i$ 处的电流 $\\mathbf{j}_i \\in \\mathbb{R}^3$ 的贡献由 $\\mathbf{L}_i \\mathbf{j}_i$ 给出，其中 $\\mathbf{L}_i \\in \\mathbb{R}^{M \\times 3}$ 是该顶点的导联场块。因此，传感器数据的一般表达式为：\n$$\n\\mathbf{y} = \\sum_{i=1}^{N} \\mathbf{L}_{i} \\mathbf{j}_{i}\n$$\n\n**1. 自由方向模型 ($\\mathbf{G}_{\\mathrm{free}}$)**\n\n在自由方向模型中，每个顶点 $i$ 处的电流 $\\mathbf{j}_i \\in \\mathbb{R}^3$ 是不受约束的。整个源分布可以通过将所有 $N$ 个电流向量拼接成一个大的源向量 $\\mathbf{J}_{\\mathrm{free}} \\in \\mathbb{R}^{3N}$ 来描述：\n$$\n\\mathbf{J}_{\\mathrm{free}} = \\begin{pmatrix}\n\\mathbf{j}_{1} \\\\\n\\mathbf{j}_{2} \\\\\n\\vdots \\\\\n\\mathbf{j}_{N}\n\\end{pmatrix}\n$$\n我们需要找到矩阵 $\\mathbf{G}_{\\mathrm{free}}$ 使得 $\\mathbf{y} = \\mathbf{G}_{\\mathrm{free}} \\mathbf{J}_{\\mathrm{free}}$。我们可以使用分块矩阵乘法重写 $\\mathbf{y}$ 的求和式：\n$$\n\\mathbf{y} = \\sum_{i=1}^{N} \\mathbf{L}_{i} \\mathbf{j}_{i} =\n\\begin{pmatrix}\n\\mathbf{L}_{1}  \\mathbf{L}_{2}  \\cdots  \\mathbf{L}_{N}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{j}_{1} \\\\\n\\mathbf{j}_{2} \\\\\n\\vdots \\\\\n\\mathbf{j}_{N}\n\\end{pmatrix}\n$$\n通过将其与 $\\mathbf{y} = \\mathbf{G}_{\\mathrm{free}} \\mathbf{J}_{\\mathrm{free}}$ 进行比较，我们确定自由方向增益矩阵 $\\mathbf{G}_{\\mathrm{free}} \\in \\mathbb{R}^{M \\times 3N}$ 是导联场块的水平拼接：\n$$\n\\mathbf{G}_{\\mathrm{free}} = \\begin{pmatrix}\n\\mathbf{L}_{1}  \\mathbf{L}_{2}  \\cdots  \\mathbf{L}_{N}\n\\end{pmatrix}\n$$\n\n**2. 固定方向模型 ($\\mathbf{G}_{\\mathrm{fix}}$)**\n\n在固定方向模型中，每个顶点 $i$ 处的电流被约束为与局部表面法线 $\\mathbf{n}_i$ 平行，即 $\\mathbf{j}_i = q_i \\mathbf{n}_i$，其中 $q_i \\in \\mathbb{R}$ 是标量电流量。现在，源分布由这些标量电流的向量 $\\mathbf{q} \\in \\mathbb{R}^{N}$ 描述：\n$$\n\\mathbf{q} = \\begin{pmatrix}\nq_{1} \\\\\nq_{2} \\\\\n\\vdots \\\\\nq_{N}\n\\end{pmatrix}\n$$\n我们将约束代入 $\\mathbf{y}$ 的一般表达式中：\n$$\n\\mathbf{y} = \\sum_{i=1}^{N} \\mathbf{L}_{i} \\mathbf{j}_{i} = \\sum_{i=1}^{N} \\mathbf{L}_{i} (q_{i} \\mathbf{n}_{i})\n$$\n由于 $q_i$ 是标量，我们可以重新排列各项：\n$$\n\\mathbf{y} = \\sum_{i=1}^{N} q_{i} (\\mathbf{L}_{i} \\mathbf{n}_{i})\n$$\n我们定义一个新向量 $\\mathbf{g}_i = \\mathbf{L}_i \\mathbf{n}_i \\in \\mathbb{R}^M$。该向量表示在顶点 $i$ 处沿 $\\mathbf{n}_i$ 方向的单位电流所产生的传感器模式。求和式变为：\n$$\n\\mathbf{y} = \\sum_{i=1}^{N} q_{i} \\mathbf{g}_{i} =\n\\begin{pmatrix}\n\\mathbf{g}_{1}  \\mathbf{g}_{2}  \\cdots  \\mathbf{g}_{N}\n\\end{pmatrix}\n\\begin{pmatrix}\nq_{1} \\\\\nq_{2} \\\\\n\\vdots \\\\\nq_{N}\n\\end{pmatrix}\n$$\n通过将其与 $\\mathbf{y} = \\mathbf{G}_{\\mathrm{fix}} \\mathbf{q}$ 进行比较，我们确定固定方向增益矩阵 $\\mathbf{G}_{\\mathrm{fix}} \\in \\mathbb{R}^{M \\times N}$ 是向量 $\\mathbf{g}_i$ 的水平拼接：\n$$\n\\mathbf{G}_{\\mathrm{fix}} = \\begin{pmatrix}\n\\mathbf{L}_{1}\\mathbf{n}_{1}  \\mathbf{L}_{2}\\mathbf{n}_{2}  \\cdots  \\mathbf{L}_{N}\\mathbf{n}_{N}\n\\end{pmatrix}\n$$\n\n### 第 2 部分：比率 $r$ 的计算\n\n我们被要求为给定的 $N=2$ 的配置计算 $r = \\frac{\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2}}{\\|\\mathbf{G}_{\\mathrm{free}}\\|_{F}^{2}}$。弗罗贝尼乌斯范数的平方 $\\|\\mathbf{A}\\|_F^2$ 是矩阵所有元素的平方和。\n\n**1. 计算 $\\|\\mathbf{G}_{\\mathrm{free}}\\|_{F}^{2}$**\n\n对于 $N=2$，$\\mathbf{G}_{\\mathrm{free}} = \\begin{pmatrix} \\mathbf{L}_{1}  \\mathbf{L}_{2} \\end{pmatrix}$。分块矩阵的弗罗贝尼乌斯范数平方是其各分块的弗罗贝尼乌斯范数平方之和。\n$$\n\\|\\mathbf{G}_{\\mathrm{free}}\\|_{F}^{2} = \\|\\mathbf{L}_{1}\\|_{F}^{2} + \\|\\mathbf{L}_{2}\\|_{F}^{2}\n$$\n给定 $\\mathbf{L}_{1} = \\begin{pmatrix} 1  0  2 \\\\ 0  1  1 \\\\ -1  2  0 \\end{pmatrix}$ 和 $\\mathbf{L}_{2} = \\begin{pmatrix} 2  -1  0 \\\\ 1  1  1 \\\\ 0  2  -2 \\end{pmatrix}$:\n$$\n\\|\\mathbf{L}_{1}\\|_{F}^{2} = 1^{2} + 0^{2} + 2^{2} + 0^{2} + 1^{2} + 1^{2} + (-1)^{2} + 2^{2} + 0^{2} = 1 + 4 + 1 + 1 + 1 + 4 = 12\n$$\n$$\n\\|\\mathbf{L}_{2}\\|_{F}^{2} = 2^{2} + (-1)^{2} + 0^{2} + 1^{2} + 1^{2} + 1^{2} + 0^{2} + 2^{2} + (-2)^{2} = 4 + 1 + 1 + 1 + 1 + 4 + 4 = 16\n$$\n因此：\n$$\n\\|\\mathbf{G}_{\\mathrm{free}}\\|_{F}^{2} = 12 + 16 = 28\n$$\n\n**2. 计算 $\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2}$**\n\n对于 $N=2$，$\\mathbf{G}_{\\mathrm{fix}} = \\begin{pmatrix} \\mathbf{g}_{1}  \\mathbf{g}_{2} \\end{pmatrix}$，其中 $\\mathbf{g}_{1} = \\mathbf{L}_{1}\\mathbf{n}_{1}$ 且 $\\mathbf{g}_{2} = \\mathbf{L}_{2}\\mathbf{n}_{2}$。弗罗贝尼乌斯范数平方是其各列向量的欧几里得范数平方之和。\n$$\n\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2} = \\|\\mathbf{g}_{1}\\|_{2}^{2} + \\|\\mathbf{g}_{2}\\|_{2}^{2}\n$$\n首先，我们计算 $\\mathbf{g}_1$ 和 $\\mathbf{g}_2$。\n$$\n\\mathbf{g}_{1} = \\mathbf{L}_{1}\\mathbf{n}_{1} = \\begin{pmatrix} 1  0  2 \\\\ 0  1  1 \\\\ -1  2  0 \\end{pmatrix} \\frac{1}{\\sqrt{6}}\\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1(1) + 0(2) + 2(1) \\\\ 0(1) + 1(2) + 1(1) \\\\ -1(1) + 2(2) + 0(1) \\end{pmatrix} = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 3 \\\\ 3 \\\\ 3 \\end{pmatrix}\n$$\n$$\n\\mathbf{g}_{2} = \\mathbf{L}_{2}\\mathbf{n}_{2} = \\begin{pmatrix} 2  -1  0 \\\\ 1  1  1 \\\\ 0  2  -2 \\end{pmatrix} \\frac{1}{\\sqrt{14}}\\begin{pmatrix} 3 \\\\ 1 \\\\ -2 \\end{pmatrix} = \\frac{1}{\\sqrt{14}} \\begin{pmatrix} 2(3) - 1(1) + 0(-2) \\\\ 1(3) + 1(1) + 1(-2) \\\\ 0(3) + 2(1) - 2(-2) \\end{pmatrix} = \\frac{1}{\\sqrt{14}} \\begin{pmatrix} 5 \\\\ 2 \\\\ 6 \\end{pmatrix}\n$$\n接下来，我们计算它们的欧几里得范数平方：\n$$\n\\|\\mathbf{g}_{1}\\|_{2}^{2} = \\left(\\frac{1}{\\sqrt{6}}\\right)^{2} (3^{2} + 3^{2} + 3^{2}) = \\frac{1}{6}(9+9+9) = \\frac{27}{6} = \\frac{9}{2}\n$$\n$$\n\\|\\mathbf{g}_{2}\\|_{2}^{2} = \\left(\\frac{1}{\\sqrt{14}}\\right)^{2} (5^{2} + 2^{2} + 6^{2}) = \\frac{1}{14}(25+4+36) = \\frac{65}{14}\n$$\n现在，我们将它们相加来求 $\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2}$：\n$$\n\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2} = \\frac{9}{2} + \\frac{65}{14} = \\frac{9 \\cdot 7}{2 \\cdot 7} + \\frac{65}{14} = \\frac{63}{14} + \\frac{65}{14} = \\frac{128}{14} = \\frac{64}{7}\n$$\n\n**3. 计算比率 $r$**\n\n最后，我们计算比率 $r$：\n$$\nr = \\frac{\\|\\mathbf{G}_{\\mathrm{fix}}\\|_{F}^{2}}{\\|\\mathbf{G}_{\\mathrm{free}}\\|_{F}^{2}} = \\frac{64/7}{28} = \\frac{64}{7 \\times 28} = \\frac{64}{196}\n$$\n为简化分数，我们将分子和分母除以它们的最大公约数 $4$。\n$$\nr = \\frac{64 \\div 4}{196 \\div 4} = \\frac{16}{49}\n$$",
            "answer": "$$\n\\boxed{\\frac{16}{49}}\n$$"
        },
        {
            "introduction": "构建了增益矩阵后，下一步是分析其内在属性，这些属性决定了逆问题的固有难度。逆问题的挑战性实际上被编码在增益矩阵 $G$ 本身之中，特别是体现在其不同列向量之间的相似性上。此练习  深入探讨了这一核心问题，它将源的物理空间布局（例如源之间的距离）与“相干性”这一关键数学概念联系起来。通过这个实践，你将揭示我们区分相邻神经活动能力的理论极限，从而深刻理解为何脑电源定位本质上是一个不适定问题 (ill-posed problem)。",
            "id": "4157990",
            "problem": "考虑脑电图（EEG）和脑磁图（MEG）源定位逆问题，在一个简化但科学上合理的正向建模场景中。在与生物电场相关的麦克斯韦方程组的准静态条件下，由神经电流偶极子在均匀、各向同性的体积导体中产生的电势，可以很好地用从电势的泊松方程推导出的经典解来描述。您将使用此模型构建一个导联场矩阵，并分析源的空间间距如何影响导联场的互相关性，以及因此可以被凸稀疏估计算法恢复的稀疏度水平。\n\n给定一个电导率 $\\sigma$ 等于 $0.33$ $\\mathrm{S/m}$ 的均匀导体。传感器均匀放置在 $x$-$y$ 平面上半径为 $R_{\\mathrm{e}}=0.09$ $\\mathrm{m}$ 的圆周上，模拟一个理想化的头皮脑电图传感器环。传感器数量为 $M=64$。假定的神经源被建模为理想的电流偶极子，位于同一平面上半径为 $R_{\\mathrm{s}}=0.08$ $\\mathrm{m}$ 的同心内圆上，每个偶极子都径向朝外。每个源的偶极矩大小为 $p_0=1\\times 10^{-8}$ $\\mathrm{A\\cdot m}$。\n\n正向模型应使用无限均匀导体中点电流偶极子的标准准静态电势，将单位源振幅（具有固定的偶极矩大小 $p_0$ 和径向方向）映射到传感器电势。由此，构建导联场矩阵 $G\\in\\mathbb{R}^{M\\times N}$，其第 $j$ 列包含由第 $j$ 个源在所有 $M$ 个传感器上产生的电势，其中这组 $N$ 个源沿源环上的半圆弧（角度为 $\\pi$ 弧度）分布。\n\n将导联场矩阵 $G$ 的互相关性 $\\mu(G)$ 定义为 $G$ 的不同列在归一化为单位 $\\ell_2$ 范数后，它们之间内积的绝对值的最大值。形式上，如果 $\\hat{\\mathbf{g}}_j=\\mathbf{g}_j/\\|\\mathbf{g}_j\\|_2$ 表示 $G$ 的第 $j$ 个归一化列，那么\n$$\n\\mu(G)=\\max_{i\\neq j}\\left|\\hat{\\mathbf{g}}_i^\\top \\hat{\\mathbf{g}}_j\\right|.\n$$\n使用稀疏近似理论中基于相关性的恢复保证，预测在基于 $\\mu(G)$ 的 $\\ell_1$ 最小化下，理论上保证能够精确恢复的最大整数稀疏度水平 $s_{\\max}$。\n\n实现一个程序，对于以下源间距 $d$ 的测试套件（解释为沿 $\\pi$ 弧度半圆的目标弧长间距），构建相应的导联场矩阵 $G$，计算 $\\mu(G)$，并预测 $s_{\\max}$：\n- 测试用例 1：$d=0.08$ $\\mathrm{m}$。\n- 测试用例 2：$d=0.04$ $\\mathrm{m}$。\n- 测试用例 3：$d=0.02$ $\\mathrm{m}$。\n- 测试用例 4：$d=0.01$ $\\mathrm{m}$。\n- 边缘用例 5：$d=0.002$ $\\mathrm{m}$。\n\n对于每个测试用例，使用以 $x$ 轴为中心、角度为 $\\pi$ 弧度的弧，并沿该弧均匀放置源，使得源的数量 $N$ 是标称间距 $d$ 能容纳在弧上的最大整数，且包括端点。具体来说，设弧长为 $L=\\pi R_{\\mathrm{s}}$，并设置 $N=\\left\\lfloor L/d\\right\\rfloor+1$，然后在弧上以等间距角度放置源，使得实际间距为 $L/(N-1)$。所有角度必须以弧度为单位，所有距离以米为单位，电势以伏特为单位。您可以将 $p_0$ 和 $\\sigma$ 视为常数，并且必须使用无限均匀导体模型。程序必须：\n- 构建传感器位置 $\\mathbf{r}_i$（$i=1,\\dots,M$），使其均匀分布在半径为 $R_{\\mathrm{e}}$ 的环上。\n- 构建源位置 $\\mathbf{r}_0^{(j)}$（$j=1,\\dots,N$），使其均匀分布在半径为 $R_{\\mathrm{s}}$ 的半圆上，偶极子向量 $\\mathbf{p}^{(j)}$ 径向朝外，大小为 $p_0$。\n- 通过使用无限均匀导体中的准静态偶极子电势，评估每个源在每个传感器处产生的电势，从而计算导联场矩阵 $G$。\n- 计算如上定义的 $\\mu(G)$ 以及相应的预测整数稀疏度上限 $s_{\\max}$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身是一个 $[\\mu(G), s_{\\max}]$ 形式的双元素列表。例如，输出应类似于 $[[\\mu_1,s_1],[\\mu_2,s_2],\\dots]$。$\\mu(G)$ 的值应为浮点数，$s_{\\max}$ 应为整数。不应打印任何其他文本。",
            "solution": "该问题是有效的。它在科学上基于静电学和稀疏信号恢复的原理，问题定义明确，并提供了一套完整且一致的参数和定义。\n\n解决方案首先阐述其物理和数学基本原理，然后详细说明为每个测试用例计算所需量的算法步骤。\n\n### 1. 基本原理\n\n#### 1.1. 正向模型：电流偶极子的电势\n在与生物电场相关的准静态条件下，导电介质中电流源分布产生的电势 $\\Phi$ 由泊松方程控制。对于电导率为 $\\sigma$ 的均匀各向同性介质，由位于 $\\mathbf{r}_0$、偶极矩为 $\\mathbf{p}$ 的理想电流偶极子在位置 $\\mathbf{r}$ 处产生的电势由以下公式给出：\n$$\n\\Phi(\\mathbf{r}) = \\frac{1}{4\\pi\\sigma} \\frac{\\mathbf{p} \\cdot (\\mathbf{r} - \\mathbf{r}_0)}{\\|\\mathbf{r} - \\mathbf{r}_0\\|_2^3}\n$$\n该公式是 $\\nabla \\cdot (\\sigma \\nabla \\Phi) = I_v$ 的解，其中偶极子的体积电流源 $I_v$ 为 $I_v = -\\nabla \\cdot (\\mathbf{p}\\delta(\\mathbf{x}-\\mathbf{r}_0))$，$\\delta(\\cdot)$ 是狄拉克δ函数。\n\n#### 1.2. 导联场矩阵\n导联场矩阵 $G \\in \\mathbb{R}^{M \\times N}$ 表示线性正向模型，将 $N$ 个源的振幅映射到 $M$ 个传感器上测得的电势。元素 $G_{ij}$ 是由位置为 $\\mathbf{r}_0^{(j)}$、偶极矩为 $\\mathbf{p}^{(j)}$ 的第 $j$ 个源偶极子在第 $i$ 个传感器位置 $\\mathbf{r}_i$ 处产生的电势。根据上述公式，对于传感器 $i$ 和源 $j$：\n$$\nG_{ij} = \\frac{1}{4\\pi\\sigma} \\frac{\\mathbf{p}^{(j)} \\cdot (\\mathbf{r}_i - \\mathbf{r}_0^{(j)})}{\\|\\mathbf{r}_i - \\mathbf{r}_0^{(j)}\\|_2^3}\n$$\n问题规定偶极矩大小固定为 $p_0=1\\times 10^{-8}\\,\\mathrm{A\\cdot m}$，且方向为径向。这意味着对于位于 $\\mathbf{r}_0^{(j)}$ 的源，其偶极矩为 $\\mathbf{p}^{(j)} = p_0 \\frac{\\mathbf{r}_0^{(j)}}{\\|\\mathbf{r}_0^{(j)}\\|_2}$。\n\n#### 1.3. 互相关性与稀疏恢复\n互相关性 $\\mu(G)$ 是稀疏近似理论中传感矩阵的一个关键属性。它被定义为矩阵中任意两个不同的、归一化后的列向量之间内积绝对值的最大值：\n$$\n\\mu(G) = \\max_{j \\neq k} |\\langle \\hat{\\mathbf{g}}_j, \\hat{\\mathbf{g}}_k \\rangle| = \\max_{j \\neq k} \\left| \\frac{\\mathbf{g}_j^\\top \\mathbf{g}_k}{\\|\\mathbf{g}_j\\|_2 \\|\\mathbf{g}_k\\|_2} \\right|\n$$\n其中 $\\mathbf{g}_j$ 是 $G$ 的第 $j$ 列，$\\hat{\\mathbf{g}}_j$ 是其经过 $\\ell_2$ 归一化的版本。\n\n压缩感知中的一个基本结果保证，如果信号 $\\mathbf{s}$ 是 $s$-稀疏的（即最多有 $s$ 个非零元素），只要稀疏度 $s$ 满足以下条件，就可以通过 $\\ell_1$ 范数最小化（基追踪）从测量值 $\\mathbf{y} = G\\mathbf{s}$ 中唯一地恢复 $\\mathbf{s}$：\n$$\ns  \\frac{1}{2}\\left(1 + \\frac{1}{\\mu(G)}\\right)\n$$\n问题要求找到能使此保证成立的最大整数稀疏度 $s_{\\max}$。这是满足严格不等式的最大整数 $s$。令 $X = \\frac{1}{2}(1 + 1/\\mu(G))$。$s_{\\max}$ 的值是严格小于 $X$ 的最大整数，可计算为 $s_{\\max} = \\lceil X \\rceil - 1$。\n\n### 2. 算法实现\n\n对于每个给定的源间距 $d$，我们执行以下步骤：\n\n**步骤 1：定义几何结构和常数**\n给定的常数包括：传感器半径 $R_{\\mathrm{e}}=0.09\\,\\mathrm{m}$，源半径 $R_{\\mathrm{s}}=0.08\\,\\mathrm{m}$，传感器数量 $M=64$，电导率 $\\sigma=0.33\\,\\mathrm{S/m}$，以及偶极矩大小 $p_0=1\\times 10^{-8}\\,\\mathrm{A\\cdot m}$。传感器放置在 $x$-$y$ 平面的一个圆周上。传感器位置 $\\mathbf{r}_i$（$i \\in \\{1, \\dots, M\\}$）为：\n$$\n\\mathbf{r}_i = (R_{\\mathrm{e}}\\cos(\\theta_i), R_{\\mathrm{e}}\\sin(\\theta_i), 0) \\quad \\text{with} \\quad \\theta_i = \\frac{2\\pi(i-1)}{M}\n$$\n\n**步骤 2：确定源位置**\n源位于以 $x$ 轴为中心（角度从 $-\\pi/2$ 到 $\\pi/2$）的半径为 $R_{\\mathrm{s}}$ 的半圆弧上。弧长为 $L=\\pi R_{\\mathrm{s}}$。对于给定的标称间距 $d$，源的数量为 $N = \\lfloor L/d \\rfloor + 1$。然后将源均匀地放置在该弧上。第 $j$ 个源的角度（$j \\in \\{1, \\dots, N\\}$）为：\n$$\n\\phi_j = -\\frac{\\pi}{2} + \\frac{\\pi(j-1)}{N-1} \\quad (\\text{for } N > 1)\n$$\n第 $j$ 个源的位置是 $\\mathbf{r}_0^{(j)} = (R_{\\mathrm{s}}\\cos(\\phi_j), R_{\\mathrm{s}}\\sin(\\phi_j), 0)$。偶极矩是径向的，为 $\\mathbf{p}^{(j)} = p_0 (\\cos(\\phi_j), \\sin(\\phi_j), 0)$。\n\n**步骤 3：构建导联场矩阵 $G$**\n我们计算每个元素 $G_{ij}$。如初步分析所示，点积和范数可以简化：\n$$\n\\mathbf{p}^{(j)} \\cdot (\\mathbf{r}_i - \\mathbf{r}_0^{(j)}) = p_0(R_{\\mathrm{e}}\\cos(\\theta_i - \\phi_j) - R_{\\mathrm{s}})\n$$\n$$\n\\|\\mathbf{r}_i - \\mathbf{r}_0^{(j)}\\|_2^2 = R_{\\mathrm{e}}^2 + R_{\\mathrm{s}}^2 - 2R_{\\mathrm{e}}R_{\\mathrm{s}}\\cos(\\theta_i - \\phi_j)\n$$\n因此，\n$$\nG_{ij} = \\frac{p_0}{4\\pi\\sigma} \\frac{R_{\\mathrm{e}}\\cos(\\theta_i - \\phi_j) - R_{\\mathrm{s}}}{(R_{\\mathrm{e}}^2 + R_{\\mathrm{s}}^2 - 2R_{\\mathrm{e}}R_{\\mathrm{s}}\\cos(\\theta_i - \\phi_j))^{3/2}}\n$$\n在计算互相关性 $\\mu(G)$ 时，常数因子 $C = p_0/(4\\pi\\sigma)$ 将在列归一化过程中被抵消。因此，我们可以计算一个不含此因子的矩阵 $G'$。\n\n**步骤 4：计算互相关性 $\\mu(G)$**\n使用上一步计算出的矩阵 $G'$：\n1. 将每列 $\\mathbf{g}'_j$ 归一化为单位 $\\ell_2$ 范数：$\\hat{\\mathbf{g}}'_j = \\mathbf{g}'_j / \\|\\mathbf{g}'_j\\|_2$。令结果矩阵为 $\\hat{G}'$。\n2. 计算内积的格拉姆矩阵：$K = (\\hat{G}')^\\top \\hat{G}'$。\n3. 互相关性是 $K$ 的非对角元素绝对值的最大值：$\\mu(G) = \\max_{j \\neq k} |K_{jk}|$。\n\n**步骤 5：预测最大稀疏度 $s_{\\max}$**\n使用计算出的 $\\mu(G)$ 值：\n1. 计算恢复阈值 $X = \\frac{1}{2}(1 + 1/\\mu(G))$。\n2. 找到严格小于 $X$ 的最大整数 $s_{\\max}$：$s_{\\max} = \\lceil X \\rceil - 1$。\n\n对每个测试用例的 $d$ 值重复此过程。随着 $d$ 的减小，$N$ 增加，源变得更加密集，预计会导致 $\\mu(G)$ 的增加和可恢复稀疏度 $s_{\\max}$ 的减小。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the EEG/MEG source localization problem for multiple test cases.\n    For each source spacing `d`, it constructs the lead-field matrix G,\n    computes its mutual coherence mu(G), and predicts the maximum guaranteed\n    recoverable sparsity s_max.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases_d = [0.08, 0.04, 0.02, 0.01, 0.002]\n\n    # --- Model Parameters ---\n    # Number of sensors\n    M = 64\n    # Radius of sensor ring (m)\n    R_e = 0.09\n    # Radius of source ring (m)\n    R_s = 0.08\n    # Conductivity and dipole moment are not needed as they form a constant\n    # factor that cancels out in the coherence calculation.\n    # sigma = 0.33\n    # p0 = 1e-8\n\n    # --- Sensor Positions ---\n    # Angles for M sensors uniformly spaced on a full circle\n    theta = np.linspace(0, 2 * np.pi, M, endpoint=False)\n\n    results = []\n\n    for d in test_cases_d:\n        # --- Source Configuration for current test case ---\n        # Total arc length of the half-circle for sources\n        arc_length = np.pi * R_s\n        \n        # Number of sources N based on spacing d\n        # Using np.floor and adding 1 as per problem spec\n        N = int(np.floor(arc_length / d)) + 1\n\n        if N == 1:\n            # Mutual coherence is not defined for N = 1\n            # This case is not expected for the given test values.\n            # We can append a placeholder and continue, e.g. [nan, 0]\n            # however, problem ensures N >= 2 for given d.\n            continue\n        \n        # Angles for N sources uniformly spaced on a half-circle arc (-pi/2 to pi/2)\n        phi = np.linspace(-np.pi / 2, np.pi / 2, N)\n\n        # --- Lead-Field Matrix (G) Construction ---\n        # We can compute the matrix efficiently using numpy broadcasting.\n        # The constant factor p0/(4*pi*sigma) is ignored as it cancels out.\n        \n        # cos(theta_i - phi_j) for all i, j pairs\n        cos_diff = np.cos(theta[:, np.newaxis] - phi[np.newaxis, :])\n        \n        # Numerator of the potential formula\n        numerator = R_e * cos_diff - R_s\n        \n        # Denominator of the potential formula\n        denominator = (R_e**2 + R_s**2 - 2 * R_e * R_s * cos_diff)**1.5\n        \n        # The lead-field matrix G (without the physical constant factor)\n        G = numerator / denominator\n\n        # --- Mutual Coherence (mu) Calculation ---\n        # Normalize each column of G to have unit l2-norm\n        G_norms = np.linalg.norm(G, axis=0)\n        G_normalized = G / G_norms[np.newaxis, :]\n        \n        # Compute the Gram matrix (inner products of normalized columns)\n        gram_matrix = G_normalized.T @ G_normalized\n        \n        # Set diagonal to 0 to ignore self-correlations (i=j)\n        np.fill_diagonal(gram_matrix, 0)\n        \n        # Mutual coherence is the max absolute off-diagonal element\n        mu = np.max(np.abs(gram_matrix))\n\n        # --- Sparsity Limit (s_max) Calculation ---\n        # The recovery guarantee holds for sparsity s  0.5 * (1 + 1/mu)\n        # s_max is the largest integer satisfying this strict inequality.\n        if mu > 0:\n            recovery_threshold = 0.5 * (1.0 + 1.0 / mu)\n            # s_max = ceil(X) - 1\n            s_max = int(math.ceil(recovery_threshold) - 1)\n        else:\n            # If mu is 0 (perfectly orthogonal), sparsity limit is theoretically infinite.\n            # However, N is the maximum possible sparsity.\n            # This case is unlikely here.\n            s_max = N \n\n        results.append([mu, s_max])\n    \n    # --- Final Output Formatting ---\n    # The output must be a single line, e.g., [[mu1,s1],[mu2,s2],...]\n    output_str = \"[\" + \",\".join([f\"[{mu_val},{s_max_val}]\" for mu_val, s_max_val in results]) + \"]\"\n\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了正向模型及其内在挑战之后，我们便可以着手解决逆问题并评估我们得到的解。一旦建立了正向模型，我们就能计算出一个逆解来估计大脑中的源活动。然而，由于问题的不适定性，这个估计永远不会是完美的，它会受到空间模糊和信号泄露等效应的影响。此练习  提供了一个完整的实践流程，指导你计算一个最优的线性逆解（维纳滤波器），并使用“分辨率矩阵”这一强大工具来量化其性能，从而评估空间分辨率和泄露等关键特性。",
            "id": "4158059",
            "problem": "给定一个用于脑电图 (EEG) 和脑磁图 (MEG) 的线性正演模型，其中脑电图 (EEG) 和脑磁图 (MEG) 的测量值在麦克斯韦方程组的准静态条件下被建模为神经电流源的线性叠加加上加性噪声。在此设置中，正演模型表示为 $y = G x + n$，其中 $y \\in \\mathbb{R}^{m}$ 是传感器测量值，$x \\in \\mathbb{R}^{p}$ 是 $p$ 维源空间网格上的源振幅，$G \\in \\mathbb{R}^{m \\times p}$ 是由电磁学和头部电导率决定的导联场（增益）矩阵，而 $n \\in \\mathbb{R}^{m}$ 是加性噪声。假设 $n$ 是均值为零、协方差为 $R_n \\in \\mathbb{R}^{m \\times m}$ 的高斯分布，并且 $x$ 是均值为零、协方差为 $R_x \\in \\mathbb{R}^{p \\times p}$ 的高斯分布。考虑在这些高斯假设和线性条件下，通过最小化期望平方误差得到的最小范数解。逆估计器是线性的，$ \\hat{x} = W y$，分辨率核（分辨率矩阵）为 $R = W G \\in \\mathbb{R}^{p \\times p}$。列 $R_{:,j}$ 是位于位置 $j$ 的单位振幅焦点源的点扩散函数。\n\n您的任务是使用高斯线性模型从第一性原理推导 $W$ 并计算分辨率核 $R$，然后分析指定焦点源索引 $j_0$ 的点扩散函数。为了进行分析，定义振幅点扩散向量 $p \\in \\mathbb{R}^{p}$ 为 $p_i = |R_{i,j_0}|$。如果分母非零，则将其归一化为单位 $\\ell_1$ 质量，即 $\\tilde{p} = p / \\sum_{i=1}^{p} p_i$，否则设 $\\tilde{p} = 0$。设峰值索引为 $\\arg\\max_i p_i$。半峰全宽 (FWHM) 在一维源网格上定义为围绕 $j_0$ 的连续宽度，包括满足 $p_i \\ge \\frac{1}{2} p_{j_0}$ 的索引；如果 $p_{j_0} = 0$，则定义 FWHM 为 $0$。对于邻域半径 $r \\in \\mathbb{N}$，半径为 $r$ 的邻域外的泄漏分数为 $1 - \\sum_{|i-j_0|\\le r} \\tilde{p}_i$。为每个测试用例返回以下三元组：一个指示符（如果峰值在 $j_0$ 处，则为 $1$，否则为 $0$），作为非负整数的 FWHM，以及作为浮点数并四舍五入到六位小数的泄漏分数。\n\n使用以下测试套件。每个测试用例包含一个导联场矩阵 $G$、一个噪声协方差 $R_n$、一个源协方差 $R_x$、一个焦点索引 $j_0$ 和一个邻域半径 $r$。所有矩阵都是实值的。网格是一维的，并按索引排序。\n\n测试用例 1（理想情况，均匀源先验，均匀噪声）：\n- $m = 4$, $p = 6$。\n- $G = \\begin{bmatrix}\n0.8  0.1  0.0  -0.2  0.3  0.5 \\\\\n0.0  0.5  0.4  0.1  -0.1  0.2 \\\\\n0.2  -0.3  0.6  0.0  0.4  -0.2 \\\\\n-0.1  0.2  -0.2  0.7  0.1  0.0\n\\end{bmatrix}$。\n- $R_n = 0.05 I_{4}$。\n- $R_x = I_{6}$。\n- $j_0 = 3$。\n- $r = 1$。\n\n测试用例 2（病态正演模型列，均匀源先验，低噪声，边界焦点索引）：\n- $m = 3$, $p = 5$。\n- $G = \\begin{bmatrix}\n0.6  0.9  0.91  0.1  0.0 \\\\\n0.0  0.2  0.21  0.0  0.5 \\\\\n0.1  0.3  0.29  0.0  -0.1\n\\end{bmatrix}$。\n- $R_n = 0.01 I_{3}$。\n- $R_x = I_{5}$。\n- $j_0 = 0$。\n- $r = 0$。\n\n测试用例 3（各向异性源先验和各向异性噪声，边界焦点索引）：\n- $m = 4$, $p = 7$。\n- $G = \\begin{bmatrix}\n0.4  -0.2  0.0  0.1  0.5  0.3  0.0 \\\\\n0.0  0.1  0.2  -0.4  0.2  0.0  0.1 \\\\\n0.1  0.0  -0.3  0.2  0.0  0.4  -0.2 \\\\\n0.2  0.3  0.1  0.0  -0.1  0.2  0.5\n\\end{bmatrix}$。\n- $R_n = \\mathrm{diag}(0.02, 0.05, 0.03, 0.08)$。\n- $R_x = \\mathrm{diag}(1.0, 0.5, 0.2, 0.2, 0.5, 1.0, 1.5)$。\n- $j_0 = 6$。\n- $r = 2$。\n\n要求：\n- 对于每个测试用例，从高斯线性模型推导出 $W$ 并计算 $R = W G$，不使用所列矩阵之外的任何外部数据。\n- 对于每个测试用例，计算：\n  1) 峰值正确性指示符，如果 $\\arg\\max_i p_i = j_0$ 则为 $1$，否则为 $0$，\n  2) 按上述定义，作为非负整数的 FWHM，\n  3) 基于 $\\tilde{p}$ 的半径 $r$ 之外的泄漏分数，四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是表示为一个用方括号括起来的逗号分隔列表的测试用例三元组。例如，三个测试用例的输出应类似于 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]$，其中 $a_k$是 $\\{0,1\\}$ 中的整数，$b_k$ 是一个非负整数，$c_k$ 是一个小数点后有六位的浮点数。",
            "solution": "用户提供了一个 EEG/MEG 源定位领域的问题。第一步是验证问题陈述。\n\n### 第 1 步：提取已知条件\n- **正演模型**：$y = Gx + n$，其中 $y \\in \\mathbb{R}^{m}$ (测量值)，$x \\in \\mathbb{R}^{p}$ (源振幅)，$G \\in \\mathbb{R}^{m \\times p}$ (导联场矩阵)，以及 $n \\in \\mathbb{R}^{m}$ (加性噪声)。\n- **统计假设**：\n    - 源向量 $x$ 是一个均值为零、协方差为 $R_x \\in \\mathbb{R}^{p \\times p}$ 的高斯随机变量，即 $x \\sim \\mathcal{N}(0, R_x)$。\n    - 噪声向量 $n$ 是一个均值为零、协方差为 $R_n \\in \\mathbb{R}^{m \\times m}$ 的高斯随机变量，即 $n \\sim \\mathcal{N}(0, R_n)$。\n    - $x$ 和 $n$ 统计上独立。\n- **估计器**：逆估计器是线性的，$\\hat{x} = Wy$，并最小化期望平方误差 $E[\\|x - \\hat{x}\\|^2]$。\n- **分辨率分析**：\n    - 分辨率矩阵：$R = WG \\in \\mathbb{R}^{p \\times p}$。\n    - 对于源 $j_0$ 的点扩散函数 (PSF)：列向量 $R_{:,j_0}$。\n    - 振幅 PSF 向量：$p \\in \\mathbb{R}^p$，其元素为 $p_i = |R_{i,j_0}|$。\n    - 归一化振幅 PSF 向量：$\\tilde{p} = p / \\sum_{i=1}^{p} p_i$（如果 $\\sum p_i \\neq 0$，否则 $\\tilde{p}=0$）。\n- **待计算的指标**：\n    1.  **峰值正确性**：一个指示符，如果 $\\arg\\max_i p_i = j_0$ 则为 $1$，否则为 $0$。\n    2.  **半峰全宽 (FWHM)**：围绕 $j_0$ 的索引的连续宽度（整数），其中 $p_i \\ge \\frac{1}{2} p_{j_0}$。如果 $p_{j_0} = 0$，则 FWHM 为 $0$。\n    3.  **泄漏分数**：对于给定的半径 $r \\in \\mathbb{N}$，该分数为 $1 - \\sum_{|i-j_0|\\le r} \\tilde{p}_i$。\n- **测试用例**：提供了三个测试用例，每个都指定了矩阵 $G$、$R_n$、$R_x$ 和参数 $j_0$、$r$。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题基于生物电磁学中标准的线性逆问题公式，特别是针对 EEG/MEG 源定位。模型 $y=Gx+n$ 以及源和噪声的高斯先验是贝叶斯或正则化逆解的基本组成部分，例如最小范数估计 (MNE) 及其变体 (dSPM, sLORETA)。通过最小化均方误差 (MMSE) 推导估计器以获得维纳滤波器是估计理论中的经典且正确的方法。使用分辨率矩阵、点扩散函数、FWHM 和泄漏是评估逆解质量的标准、成熟的方法。该问题在科学上是合理的，并基于已建立的原则。\n- **适定性**：该问题要求推导一个特定的估计器并将其应用于给定的数据。维纳滤波器的推导是一个适定的数学问题。后续的计算是确定性的。所提供的协方差矩阵被指定为单位矩阵或具有正项的对角矩阵，确保它们是正定的且可逆。该问题的结构旨在为每个测试用例产生唯一的解决方案。\n- **客观性**：问题以精确、客观的数学语言陈述。所有术语都有明确定义。\n- **完整性与一致性**：为每个测试用例提供了所有必要的数据（$G, R_n, R_x, j_0, r$）。矩阵的维度与数学公式一致。\n- **其他缺陷**：该问题既不普通，也非比喻，更不是科学上无法验证的。它是计算神经科学和信号处理中的一个标准的、非平凡的练习。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。我将继续推导解决方案并实现所需的计算。\n\n### 基于原理的解决方案\n\n目标是找到一个线性估计器 $\\hat{x} = Wy$，以最小化期望平方误差 $J(W) = E[\\|x - \\hat{x}\\|^2]$。这是估计理论中的一个经典问题，其解被称为维纳滤波器。\n\n**1. 最小均方误差 (MMSE) 估计器的推导**\n\n估计误差为 $e = x - \\hat{x} = x - Wy$。代入正演模型 $y = Gx + n$，我们得到：\n$$ e = x - W(Gx + n) = (I - WG)x - Wn $$\n成本函数是误差协方差矩阵 $C_e = E[ee^T]$ 的迹：\n$$ J(W) = E[\\|e\\|^2] = \\mathrm{Tr}(C_e) $$\n误差协方差为：\n$$ C_e = E[((I - WG)x - Wn)((I - WG)x - Wn)^T] $$\n由于源信号 $x$ 和噪声 $n$ 相互独立且均值为零，因此交叉项 $E[xn^T]$ 为零。因此，期望展开为：\n$$ C_e = E[(I - WG)xx^T(I - WG)^T] + E[Wnn^TW^T] $$\n使用定义 $R_x = E[xx^T]$ 和 $R_n = E[nn^T]$，我们有：\n$$ C_e = (I - WG)R_x(I - WG)^T + WR_nW^T $$\n需要最小化的成本函数是：\n$$ J(W) = \\mathrm{Tr}((I - WG)R_x(I - WG)^T + WR_nW^T) $$\n为了找到最优的 $W$，我们计算 $J(W)$ 关于 $W$ 的矩阵导数并将其设为零。展开迹表达式：\n$$ J(W) = \\mathrm{Tr}(R_x - WGR_x - R_xG^TW^T + WGR_xG^TW^T + WR_nW^T) $$\n使用标准的矩阵微积分恒等式，导数为：\n$$ \\frac{\\partial J(W)}{\\partial W} = -2R_xG^T + 2W(GR_xG^T + R_n) = 0 $$\n解出 $W$：\n$$ W(GR_xG^T + R_n) = R_xG^T $$\n$$ W = R_xG^T(GR_xG^T + R_n)^{-1} $$\n项 $(GR_xG^T + R_n)$ 是测量值 $y$ 的协方差，因为 $C_y = E[yy^T] = E[(Gx+n)(Gx+n)^T] = GR_xG^T + R_n$。该项是一个 $m \\times m$ 矩阵。由于 $R_n$ 是正定的，其可逆性得到保证。$W$ 的这个表达式就是维纳滤波器，即最优线性 MMSE 估计器。\n\n**2. 分辨率分析**\n\n分辨率矩阵 $R$ 描述了估计器 $\\hat{x}$ 如何响应真实的源分布 $x$。在无噪声的情况下（$n=0$，因此 $y=Gx$），估计将是 $\\hat{x} = W y = WG x = Rx$。因此，分辨率矩阵 $R$ 将真实的源活动映射到估计的源活动。\n$$ R = WG = R_xG^T(GR_xG^T + R_n)^{-1}G $$\n$R$ 的第 $j$ 列，表示为 $R_{:,j}$，是点扩散函数 (PSF)。它表示当真实活动是位于位置 $j$ 的单位振幅焦点源时（即，$x$ 是一个在索引 $j$ 处为 1，其余为零的向量）估计的源分布。\n\n分析指标从此 PSF 计算得出。\n- 振幅 PSF 向量 $p$ 定义为 $p_i = |R_{i,j_0}|$。\n- 归一化振幅 PSF 向量 $\\tilde{p}$ 是将 $p$ 归一化以具有单位 $\\ell_1$ 范数：$\\tilde{p} = p / \\sum_i p_i$。\n\n**3. 指标计算**\n\n对于每个具有给定焦点索引 $j_0$ 和半径 $r$ 的测试用例，我们计算以下三个指标：\n\n- **峰值正确性**：我们找到振幅 PSF 向量 $p$ 的最大值索引，即 $i_{peak} = \\arg\\max_i p_i$。如果 $i_{peak} = j_0$，指示符为 $1$，否则为 $0$。\n\n- **FWHM**：半峰全宽是基于振幅 PSF 向量 $p$ 计算的。首先，我们检查焦点源位置的振幅 $p_{j_0}$ 是否为零。如果是，则 FWHM 为 $0$。否则，我们定义一个阈值 $T = 0.5 \\times p_{j_0}$。FWHM 是包含 $j_0$ 且其中 $p_i \\ge T$ 的最大连续索引块的大小。这是通过从宽度为 $1$（对于 $j_0$ 本身）开始，并从 $j_0$ 向左和向右扩展，只要对于所有中间索引都满足条件 $p_i \\ge T$。\n\n- **泄漏分数**：该指标量化了估计活动中有多少“泄漏”到了真实源的既定邻域之外。使用归一化振幅 PSF $\\tilde{p}$，我们对焦点源 $j_0$ 半径 $r$ 范围内的概率求和。邻域包括满足 $|i - j_0| \\le r$ 的索引 $i$。泄漏是此总和的补集：\n$$ \\text{泄漏} = 1 - \\sum_{i = \\max(0, j_0-r)}^{\\min(p-1, j_0+r)} \\tilde{p}_i $$\n\n**4. 计算流程**\n\n以下算法将针对每个提供的测试用例实现：\n1.  根据测试用例数据定义矩阵 $G$、$R_n$、$R_x$ 和参数 $j_0$、$r$。\n2.  计算矩阵 $M = GR_xG^T + R_n$。\n3.  计算其逆矩阵 $M^{-1}$。\n4.  计算逆算子 $W = R_xG^T M^{-1}$。\n5.  计算分辨率矩阵 $R = WG$。\n6.  提取 PSF，即列 $R_{:,j_0}$。\n7.  通过取 PSF 的绝对值来计算振幅 PSF 向量 $p$。\n8.  计算归一化振幅 PSF 向量 $\\tilde{p}$。\n9.  根据上述定义计算峰值正确性指示符、FWHM 和泄漏分数。\n10. 格式化并存储得到的三元组值。\n\n此过程将对所有测试用例重复执行。",
            "answer": "```python\nimport numpy as np\n\ndef compute_metrics(G, Rn, Rx, j0, r):\n    \"\"\"\n    Computes the resolution metrics for a given EEG/MEG inverse problem setup.\n\n    Args:\n        G (np.ndarray): The lead-field matrix (m x p).\n        Rn (np.ndarray): The noise covariance matrix (m x m).\n        Rx (np.ndarray): The source covariance matrix (p x p).\n        j0 (int): The index of the focal source.\n        r (int): The radius for the leakage calculation.\n\n    Returns:\n        tuple: (peak_correctness, fwhm, leakage_fraction)\n    \"\"\"\n    p_dim = G.shape[1]\n\n    # Step 1: Compute the Wiener filter W\n    # W = Rx @ G^T @ inv(G @ Rx @ G^T + Rn)\n    M = G @ Rx @ G.T + Rn\n    try:\n        M_inv = np.linalg.inv(M)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudo-inverse if inversion fails, though not expected for this problem's setup\n        M_inv = np.linalg.pinv(M)\n        \n    W = Rx @ G.T @ M_inv\n\n    # Step 2: Compute the resolution matrix R\n    R = W @ G\n\n    # Step 3: Analyze the point-spread function (PSF) for source j0\n    psf_column = R[:, j0]\n    p_vec = np.abs(psf_column)\n\n    # Step 4: Compute the metrics\n    \n    # Metric 1: Peak Correctness\n    peak_idx = np.argmax(p_vec)\n    peak_correctness = 1 if peak_idx == j0 else 0\n\n    # Metric 2: Full-Width at Half-Maximum (FWHM)\n    p_j0 = p_vec[j0]\n    fwhm = 0\n    if p_j0 > 1e-12: # Use a small tolerance for floating point zero\n        threshold = 0.5 * p_j0\n        \n        # Count indices including j0 that are above threshold and form a contiguous block around j0\n        # This implementation simply counts all indices >= threshold. The problem states\n        # \"continuous width... including ... indices\". A more strict implementation\n        # would find the contiguous block. However, for a typical PSF, this is equivalent.\n        # To be safe, let's implement the contiguous search.\n        fwhm = 1\n        \n        # Search right from j0\n        for i in range(j0 + 1, p_dim):\n            if p_vec[i] >= threshold:\n                fwhm += 1\n            else:\n                break\n        \n        # Search left from j0\n        for i in range(j0 - 1, -1, -1):\n            if p_vec[i] >= threshold:\n                fwhm += 1\n            else:\n                break\n\n    # Metric 3: Leakage Fraction\n    p_sum = np.sum(p_vec)\n    if p_sum > 1e-12:\n        p_tilde = p_vec / p_sum\n        \n        start_idx = max(0, j0 - r)\n        end_idx = min(p_dim - 1, j0 + r)\n        \n        neighborhood_sum = np.sum(p_tilde[start_idx : end_idx + 1])\n        leakage_fraction = 1.0 - neighborhood_sum\n    else:\n        # If the total PSF amplitude is zero, p_tilde is a zero vector.\n        # The sum over any neighborhood is 0, so leakage is 1 - 0 = 1.\n        leakage_fraction = 1.0\n\n    return peak_correctness, fwhm, leakage_fraction\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, compute results, and print the output.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"G\": np.array([\n                [0.8, 0.1, 0.0, -0.2, 0.3, 0.5],\n                [0.0, 0.5, 0.4, 0.1, -0.1, 0.2],\n                [0.2, -0.3, 0.6, 0.0, 0.4, -0.2],\n                [-0.1, 0.2, -0.2, 0.7, 0.1, 0.0]\n            ]),\n            \"Rn\": 0.05 * np.identity(4),\n            \"Rx\": np.identity(6),\n            \"j0\": 3,\n            \"r\": 1\n        },\n        # Test case 2\n        {\n            \"G\": np.array([\n                [0.6, 0.9, 0.91, 0.1, 0.0],\n                [0.0, 0.2, 0.21, 0.0, 0.5],\n                [0.1, 0.3, 0.29, 0.0, -0.1]\n            ]),\n            \"Rn\": 0.01 * np.identity(3),\n            \"Rx\": np.identity(5),\n            \"j0\": 0,\n            \"r\": 0\n        },\n        # Test case 3\n        {\n            \"G\": np.array([\n                [0.4, -0.2, 0.0, 0.1, 0.5, 0.3, 0.0],\n                [0.0, 0.1, 0.2, -0.4, 0.2, 0.0, 0.1],\n                [0.1, 0.0, -0.3, 0.2, 0.0, 0.4, -0.2],\n                [0.2, 0.3, 0.1, 0.0, -0.1, 0.2, 0.5]\n            ]),\n            \"Rn\": np.diag([0.02, 0.05, 0.03, 0.08]),\n            \"Rx\": np.diag([1.0, 0.5, 0.2, 0.2, 0.5, 1.0, 1.5]),\n            \"j0\": 6,\n            \"r\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res = compute_metrics(case[\"G\"], case[\"Rn\"], case[\"Rx\"], case[\"j0\"], case[\"r\"])\n        results.append(res)\n    \n    # Format the final output string exactly as specified.\n    formatted_results = [f'[{r[0]},{r[1]},{r[2]:.6f}]' for r in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}