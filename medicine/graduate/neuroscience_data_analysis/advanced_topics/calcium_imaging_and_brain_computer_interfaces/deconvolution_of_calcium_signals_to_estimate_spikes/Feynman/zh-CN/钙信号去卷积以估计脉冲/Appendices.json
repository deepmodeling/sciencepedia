{
    "hands_on_practices": [
        {
            "introduction": "本练习将我们对脉冲反卷积的理解建立在强大的凸优化框架之上。你将实现快速迭代收缩阈值算法（FISTA）来解决一个稀疏的、非负的逆问题。这项练习至关重要，因为它提供了一个稳健且广泛适用的工具，用于从荧光数据中推断神经活动。",
            "id": "4154479",
            "problem": "给定一个通过荧光成像记录的单个神经元的细胞内钙动力学离散时间模型。钙浓度被建模为一个由非负脉冲序列驱动的稳定线性时不变过程。令 $t \\in \\{0,1,2,\\dots,T-1\\}$。潜在钙浓度 $c_t$ 服从 $c_t = \\alpha \\, c_{t-1} + s_t$，其中 $c_{-1} = 0$，$0 < \\alpha < 1$ 是每个时间步的衰减因子，$s_t \\ge 0$ 是以任意单位计的非负脉冲率。观测到的荧光 $y_t$ 为 $y_t = c_t + \\varepsilon_t$，其中 $\\varepsilon_t$ 是加性扰动。\n\n请编写一个完整的程序，针对下方的每个测试用例，通过求解一个凸优化问题来估计脉冲序列，然后报告一个定量的误差指标。您的程序必须不接受任何输入，并且必须打印一行包含汇总结果的输出。\n\n基本基础和定义：\n- 由 $c_t = \\alpha \\, c_{t-1} + s_t$ 和 $c_{-1}=0$ 推导出的离散时间卷积前向模型得出 $c_t = \\sum_{k=0}^{t} \\alpha^{t-k} s_k$。定义下三角托普利茨 (Toeplitz) 矩阵 $G \\in \\mathbb{R}^{T \\times T}$，其第一列为 $[1,\\alpha,\\alpha^2,\\dots,\\alpha^{T-1}]^\\top$，第一行为 $[1,0,0,\\dots,0]$。那么荧光时间序列为 $y = G s + \\varepsilon$，其中 $s \\in \\mathbb{R}_{\\ge 0}^{T}$ 是非负脉冲向量，$y \\in \\mathbb{R}^{T}$ 是观测值。\n- 脉冲推断被构建为一个惩罚最小二乘估计问题：最小化 $f(s) = \\frac{1}{2} \\lVert G s - y \\rVert_2^2 + \\lambda \\lVert s \\rVert_1$，约束条件为 $s \\ge 0$。其中 $\\lambda > 0$ 通过非负最小绝对收缩和选择算子 (LASSO) 惩罚项来控制稀疏程度。\n\n您的任务：\n1. 严格从上述基本定义出发，推导平滑项关于 $s$ 的梯度、该梯度的 Lipschitz 常数，以及对应于非负约束 $\\ell_1$ 惩罚项的近端算子。使用这些推导设计一个带 Nesterov 加速的一阶方法，即快速迭代收缩阈值算法 (FISTA)，以在 $s \\ge 0$ 的约束下最小化目标函数。\n2. 在代码中实现所推导的算法，并遵循以下数值规定：\n   - 使用固定步长，其大小等于平滑项梯度的 Lipschitz 常数的倒数。\n   - 从 $s^{(0)} = 0$ 开始初始化，并对迭代点使用标准的 Nesterov 加速。\n   - 使用基于连续迭代点之间相对 $\\ell_2$ 变化的终止准则：当 $\\lVert s^{(k)} - s^{(k-1)} \\rVert_2 / \\max\\{1,\\lVert s^{(k-1)} \\rVert_2\\} \\le \\tau$ 时停止，其中 $\\tau$ 是一个容差。\n   - 在每次迭代中，通过适当的近端算子施加非负性和 $\\ell_1$ 正则化。\n3. 对于下方的每个测试用例，根据 $\\alpha$ 和 $T$ 构建 $G$，构建真实脉冲序列 $s_{\\mathrm{true}}$，构建 $y = G s_{\\mathrm{true}} + \\varepsilon$，运行您的求解器以获得 $\\hat{s}$，并报告平均绝对误差 $\\mathrm{MAE} = \\frac{1}{T} \\sum_{t=0}^{T-1} | \\hat{s}_t - s_{\\mathrm{true},t} |$，结果为四舍五入到六位小数的浮点数。\n\n使用以下确定性测试套件（下文提到的所有角度均以弧度为单位）：\n- 测试 A (理想情况，精确模型匹配)：\n  - 长度 $T = 60$，衰减因子 $\\alpha = 0.95$，正则化参数 $\\lambda = 0.001$，容差 $\\tau = 10^{-9}$。\n  - 真实脉冲 $s_{\\mathrm{true}}$ 除 $s_{\\mathrm{true},5} = 1.0$，$s_{\\mathrm{true},20} = 0.5$，$s_{\\mathrm{true},40} = 1.5$ 外，其余均为零。\n  - 对所有 $t$，扰动 $\\varepsilon_t = 0$。\n- 测试 B (脉冲簇与结构化扰动)：\n  - 长度 $T = 80$，衰减因子 $\\alpha = 0.9$，正则化参数 $\\lambda = 0.1$，容差 $\\tau = 10^{-9}$。\n  - 真实脉冲 $s_{\\mathrm{true}}$ 除 $s_{\\mathrm{true},10} = 0.3$，$s_{\\mathrm{true},11} = 0.3$，$s_{\\mathrm{true},12} = 0.3$ 外，其余均为零。\n  - 对于 $t \\in \\{0,\\dots,79\\}$，扰动为 $\\varepsilon_t = 0.02 \\cos\\!\\big(2\\pi t / 11\\big)$。\n- 测试 C (无脉冲，强正则化，微小扰动)：\n  - 长度 $T = 50$，衰减因子 $\\alpha = 0.98$，正则化参数 $\\lambda = 0.2$，容差 $\\tau = 10^{-9}$。\n  - 真实脉冲 $s_{\\mathrm{true}}$ 全部为零。\n  - 对于 $t \\in \\{0,\\dots,49\\}$，扰动为 $\\varepsilon_t = 0.001 \\left[\\sin\\!\\big(2\\pi t / 7\\big) + 0.5 \\sin\\!\\big(2\\pi t / 3\\big)\\right]$。\n\n您的程序必须：\n- 实现一次求解器，并在三个测试用例中复用它。\n- 对每个测试用例，计算上述定义的平均绝对误差，并将其四舍五入到六位小数。\n- 生成单行输出，其中包含三个结果，以逗号分隔并用方括号括起，顺序为 A、B、C。例如，您的程序应在一行上输出类似 $[0.000123,0.045678,0.000000]$ 的值（这仅为示例；请计算实际值）。",
            "solution": "该问题是有效的，因为它在计算神经科学和信号处理领域提出了一个适定的、有科学依据且自洽的任务。它要求将标准的凸优化技术应用于一个线性逆问题。所有模型、参数和测试用例都以数学精度进行定义，没有歧义。\n\n目标是从观测到的荧光时间序列 $y \\in \\mathbb{R}^{T}$ 中估计一个非负脉冲序列 $s \\in \\mathbb{R}_{\\ge 0}^{T}$。该问题被表述为以下凸优化问题：\n$$\n\\underset{s \\ge 0}{\\text{minimize}} \\quad f(s) = \\frac{1}{2} \\lVert G s - y \\rVert_2^2 + \\lambda \\lVert s \\rVert_1\n$$\n其中 $G$ 是表示钙动力学的卷积矩阵，$\\lambda > 0$ 是一个正则化参数，用于促进估计的脉冲序列 $s$ 的稀疏性。\n\n该问题使用快速迭代收缩阈值算法 (FISTA) 求解。FISTA 是一种一阶近端梯度方法，非常适合形式为 $f(s) = L(s) + R(s)$ 的复合目标函数，其中 $L(s)$ 是一个平滑凸函数，$R(s)$ 是一个凸（可能非平滑）函数。\n\n对于我们的问题，我们定义：\n- 平滑部分（数据保真项）：$L(s) = \\frac{1}{2} \\lVert G s - y \\rVert_2^2$。\n- 非平滑部分（正则化项和约束）：$R(s) = \\lambda \\lVert s \\rVert_1 + I_+(s)$，其中 $I_+(s)$ 是非负象限的指示函数，如果 $s \\ge 0$（分量级），则其值为 $0$，否则为 $\\infty$。该项通过 $\\ell_1$ 范数强制稀疏性，并强制脉冲序列的非负性。\n\nFISTA 算法需要从此公式中推导出三个关键组成部分：平滑项的梯度、该梯度的 Lipschitz 常数以及非平滑项的近端算子。\n\n1.  **平滑项的梯度, $\\nabla L(s)$**\n    平滑项是一个标准的最小二乘目标函数。其关于 $s$ 的梯度推导如下：\n    $$\n    L(s) = \\frac{1}{2} (Gs - y)^\\top (Gs - y) = \\frac{1}{2} (s^\\top G^\\top G s - 2 y^\\top G s + y^\\top y)\n    $$\n    对向量 $s$ 求导得出：\n    $$\n    \\nabla L(s) = G^\\top G s - G^\\top y = G^\\top(Gs - y)\n    $$\n\n2.  **梯度的 Lipschitz 常数, $K$**\n    如果步长选择得当，FISTA 算法的收敛性可以得到保证。一个常见的选择是 $\\nabla L(s)$ 的 Lipschitz 常数的倒数。对于具有连续二阶导数的函数，Lipschitz 常数是其 Hessian 矩阵范数的最大值。$L(s)$ 的 Hessian 矩阵是：\n    $$\n    \\nabla^2 L(s) = G^\\top G\n    $$\n    Lipschitz 常数 $K$ 是这个半正定矩阵 $G^\\top G$ 的最大特征值 $\\lambda_{\\max}$。这等价于矩阵 $G$ 的最大奇异值 $\\sigma_{\\max}$ 的平方。\n    $$\n    K = \\lambda_{\\max}(G^\\top G) = \\sigma_{\\max}(G)^2\n    $$\n    梯度下降更新的步长将固定为 $\\gamma = 1/K$。\n\n3.  **非平滑项的近端算子, $\\text{prox}_{\\gamma R}(v)$**\n    $\\gamma R(s)$ 的近端算子定义为：\n    $$\n    \\text{prox}_{\\gamma R}(v) = \\underset{s}{\\text{argmin}} \\left( \\frac{1}{2} \\lVert s - v \\rVert_2^2 + \\gamma R(s) \\right)\n    $$\n    代入 $R(s) = \\lambda \\lVert s \\rVert_1 + I_+(s)$，我们得到：\n    $$\n    \\text{prox}_{\\gamma R}(v) = \\underset{s \\ge 0}{\\text{argmin}} \\left( \\frac{1}{2} \\lVert s - v \\rVert_2^2 + \\gamma \\lambda \\lVert s \\rVert_1 \\right)\n    $$\n    这个问题是可分离的，可以对每个分量 $s_i$ 独立求解：\n    $$\n    \\underset{s_i \\ge 0}{\\text{argmin}} \\left( \\frac{1}{2} (s_i - v_i)^2 + \\gamma \\lambda s_i \\right)\n    $$\n    目标函数是关于 $s_i$ 的抛物线，其最小值点在 $s_i = v_i - \\gamma \\lambda$。由于我们有约束 $s_i \\ge 0$，解可以通过将此最小值点投影到非负半线上找到。如果 $v_i - \\gamma \\lambda > 0$，则最小值在 $s_i = v_i - \\gamma \\lambda$。如果 $v_i - \\gamma \\lambda \\le 0$，则目标函数对所有 $s_i \\ge 0$ 都是递增的，因此最小值出现在边界处，即 $s_i = 0$。这可以紧凑地写为：\n    $$\n    s_i = \\max(0, v_i - \\gamma \\lambda)\n    $$\n    这个操作等价于软阈值操作，然后投影到非负象限上。\n\n有了这些组件，FISTA 算法的实现如下：\n\n**算法：快速迭代收缩阈值算法 (FISTA)**\n\n1.  **初始化**：\n    - 迭代计数器 $k=1$。\n    - 脉冲估计 $s^{(0)} = \\mathbf{0}$，$s^{(-1)} = \\mathbf{0}$。\n    - 辅助序列 $z^{(1)} = s^{(0)}$。\n    - 动量序列 $t_1 = 1$。\n    - 步长 $\\gamma = 1/K = 1/\\sigma_{\\max}(G)^2$。\n\n2.  **迭代循环 (对于 $k=1, 2, \\dots$)**：\n    a. 计算在辅助点 $z^{(k)}$ 处的梯度：$\\nabla_k = G^\\top(G z^{(k)} - y)$。\n    b. 执行一个梯度步：$v^{(k)} = z^{(k)} - \\gamma \\nabla_k$。\n    c. 应用近端算子以找到下一个脉冲估计 $s^{(k)}$：对每个分量 $i$，$s^{(k)}_i = \\max(0, v^{(k)}_i - \\gamma \\lambda)$。\n    d. 检查收敛性：如果 $\\lVert s^{(k)} - s^{(k-1)} \\rVert_2 / \\max(1, \\lVert s^{(k-1)} \\rVert_2) \\le \\tau$，则停止。\n    e. 更新动量项：$t_{k+1} = \\frac{1 + \\sqrt{1 + 4 t_k^2}}{2}$。\n    f. 更新用于下一次迭代的辅助序列：$z^{(k+1)} = s^{(k)} + \\frac{t_k - 1}{t_{k+1}}(s^{(k)} - s^{(k-1)})$。\n    g. 设置 $s^{(k-1)} \\leftarrow s^{(k)}$，$t_k \\leftarrow t_{k+1}$，并增加 $k$。\n\n3.  **输出**：最终估计值 $\\hat{s} = s^{(k)}$。\n\n该算法对每个测试用例进行实现。卷积矩阵 $G$ 根据其作为下三角托普利茨矩阵的定义来构建。Lipschitz 常数 $K$ 通过找到 $G$ 的最大奇异值来计算。然后求解器运行直到满足指定的容差 $\\tau$。最后，计算估计的脉冲序列 $\\hat{s}$ 和真实值 $s_{\\mathrm{true}}$ 之间的平均绝对误差 (MAE)。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import toeplitz, svd\n\ndef fista_solver(G, y, lam, tau, K):\n    \"\"\"\n    Solves the non-negative LASSO problem using FISTA.\n\n    min_s 0.5 * ||Gs - y||_2^2 + lam * ||s||_1  subject to s >= 0.\n\n    Args:\n        G (np.ndarray): The forward model matrix.\n        y (np.ndarray): The observed data vector.\n        lam (float): The regularization parameter.\n        tau (float): The convergence tolerance.\n        K (float): The Lipschitz constant of the gradient of the smooth term.\n\n    Returns:\n        np.ndarray: The estimated spike train s_hat.\n    \"\"\"\n    T = G.shape[0]\n    \n    # Initialization\n    s_prev = np.zeros(T)\n    z = np.zeros(T)\n    t_prev = 1.0\n\n    # Pre-compute G transpose for efficiency\n    GT = G.T\n    \n    # Fixed step size\n    step_size = 1.0 / K\n    \n    # Set a maximum number of iterations as a safeguard\n    max_iter = 200000 \n    \n    for _ in range(max_iter):\n        # Compute gradient at the auxiliary point z\n        grad_z = GT @ (G @ z - y)\n        \n        # Perform gradient descent step from z\n        v = z - step_size * grad_z\n        \n        # Apply proximal operator to get the current estimate s_curr\n        s_curr = np.maximum(0, v - step_size * lam)\n        \n        # Check for convergence using the specified criterion\n        norm_s_prev = np.linalg.norm(s_prev)\n        rel_diff = np.linalg.norm(s_curr - s_prev) / max(1.0, norm_s_prev)\n        \n        if rel_diff = tau:\n            break\n            \n        # Nesterov acceleration update\n        t_curr = (1.0 + np.sqrt(1.0 + 4.0 * t_prev**2)) / 2.0\n        z = s_curr + ((t_prev - 1.0) / t_curr) * (s_curr - s_prev)\n        \n        # Update variables for the next iteration\n        s_prev = s_curr\n        t_prev = t_curr\n        \n    return s_curr\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    \n    # --- Test Case A: Happy path, exact model match ---\n    T_A = 60\n    alpha_A = 0.95\n    lambda_A = 0.001\n    tau_A = 1e-9\n    s_true_A = np.zeros(T_A)\n    s_true_A[5] = 1.0\n    s_true_A[20] = 0.5\n    s_true_A[40] = 1.5\n    epsilon_A = np.zeros(T_A)\n    \n    # --- Test Case B: Burst with structured disturbance ---\n    T_B = 80\n    alpha_B = 0.9\n    lambda_B = 0.1\n    tau_B = 1e-9\n    s_true_B = np.zeros(T_B)\n    s_true_B[10:13] = 0.3\n    t_vals_B = np.arange(T_B)\n    epsilon_B = 0.02 * np.cos(2 * np.pi * t_vals_B / 11)\n    \n    # --- Test Case C: No spikes, strong regularization, tiny disturbance ---\n    T_C = 50\n    alpha_C = 0.98\n    lambda_C = 0.2\n    tau_C = 1e-9\n    s_true_C = np.zeros(T_C)\n    t_vals_C = np.arange(T_C)\n    epsilon_C = 0.001 * (np.sin(2 * np.pi * t_vals_C / 7) + 0.5 * np.sin(2 * np.pi * t_vals_C / 3))\n    \n    test_cases = [\n        (T_A, alpha_A, lambda_A, tau_A, s_true_A, epsilon_A),\n        (T_B, alpha_B, lambda_B, tau_B, s_true_B, epsilon_B),\n        (T_C, alpha_C, lambda_C, tau_C, s_true_C, epsilon_C)\n    ]\n    \n    results = []\n    \n    for T, alpha, lam, tau, s_true, epsilon in test_cases:\n        # 1. Construct the convolution matrix G\n        g_first_col = alpha**np.arange(T)\n        g_first_row = np.zeros(T)\n        g_first_row[0] = 1.0\n        G = toeplitz(g_first_col, g_first_row)\n        \n        # 2. Compute the Lipschitz constant K\n        singular_values = svd(G, compute_uv=False)\n        K = singular_values[0]**2\n        \n        # 3. Construct the observed fluorescence y\n        y = G @ s_true + epsilon\n        \n        # 4. Run the solver to obtain the spike estimate s_hat\n        s_hat = fista_solver(G, y, lam, tau, K)\n        \n        # 5. Compute the Mean Absolute Error (MAE)\n        mae = np.mean(np.abs(s_hat - s_true))\n        results.append(f\"{mae:.6f}\")\n        \n    # Print the final results in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的神经活动常常表现出复杂的时间模式，例如簇状放电和不应期。本练习将介绍如何将这些生物学约束编码为结构化先验，并融入最大后验（MAP）估计框架中。你将使用动态规划——一种解决具有序列结构优化问题的强大技术——来寻找最可能的脉冲序列。",
            "id": "4154477",
            "problem": "给定一个一维时间序列，它代表一个荧光钙信号。该信号由一个线性动力学系统建模，该系统源于尖峰诱发的钙瞬变。生成模型定义在具有固定采样间隔（以秒为单位）和已知参数的离散时间样本上。任务是计算在不应期约束和爆发先验条件下，一个受约束的尖峰序列的最大后验 (MAP) 估计，并为多个指定的测试用例输出尖峰样本索引的集合。\n\n基础和数据模型：\n- 令 $t \\in \\{0,1,\\dots,T-1\\}$ 表示由采样间隔 $\\Delta t$（单位：秒）分隔的离散时间样本。\n- 令 $s_t$ 表示样本 $t$ 处的尖峰序列。在本问题中，$s_t$ 被约束为 $0$ 或一个固定的振幅 $a  0$。\n- 钙动力学被建模为一个线性系统，其脉冲响应核为 $h_k = \\alpha \\gamma^k$，其中 $k \\in \\{0,1,\\dots,K-1\\}$。这里 $\\alpha  0$ 是每个尖峰的瞬时钙增量，$\\gamma \\in (0,1)$ 是离散时间衰减因子，通过 $\\gamma = \\exp(-\\Delta t / \\tau_c)$ 从钙衰减时间常数 $\\tau_c$ 导出。\n- 预测荧光是离散卷积 $(h * s)_t = \\sum_{k=0}^{K-1} h_k s_{t-k}$，其中小于 0 的索引被视为零。\n- 观测荧光 $y_t$ 被建模为 $y_t = (h * s)_t + \\varepsilon_t$，其中 $\\varepsilon_t$ 是零均值、方差为 $\\sigma^2$ 的独立高斯噪声样本。\n\n具有不应期约束和爆发偏好的结构化先验：\n- 在任意两个爆发的开始之间，施加一个 $r$ 个样本的不应期，其中 $r \\ge K$。这确保了来自不同爆发的脉冲响应的支撑集在时间上不重叠。\n- 尖峰序列 $s_t$ 被限制为一系列爆发的并集。一个爆发被定义为一个长度为 $L \\in \\{L_{\\min}, \\dots, L_{\\max}\\}$ 的、振幅为 $a$ 的连续尖峰样本块。在爆发区间内，$s_t = a$，在区间外，$s_t = 0$。\n- 负对数先验成本定义为 $\\lambda \\sum_t \\mathbf{1}[s_t = a] - \\rho \\sum_t \\mathbf{1}[s_t = a, s_{t+1} = a]$，其中 $\\lambda \\ge 0$ 惩罚尖峰样本的总数，而 $\\rho \\ge 0$ 为相邻的尖峰对提供折扣，以偏好更长的连续爆发。\n\nMAP 目标：\n- 给定 $y_t$，MAP 估计通过最小化以下目标函数得到\n$$\nJ(s) = \\frac{1}{2 \\sigma^2} \\sum_{t=0}^{T-1} \\left( y_t - (h * s)_t \\right)^2 \\;+\\; \\lambda \\sum_{t=0}^{T-1} \\mathbf{1}[s_t=a] \\;-\\; \\rho \\sum_{t=0}^{T-2} \\mathbf{1}[s_t=a, s_{t+1}=a],\n$$\n约束条件为上述的不应期约束和爆发结构，以及 $s_t \\in \\{0,a\\}$。\n\n算法要求：\n- 由于 $r \\ge K$，不同爆发对似然的贡献在时间上不重叠。您必须在时间线上实现一个精确的动态规划算法。该算法在每个位置 $t$ 要么选择一个从 $t$ 开始、长度为 $L \\in [L_{\\min}, L_{\\max}]$ 的爆发，要么选择一个单样本间隙（在 $t$ 处没有尖峰），并累积相应的似然成本和先验成本，然后相应地推进时间索引。当选择一个爆发时，下一个可能的爆发起始索引是 $t + L + r$。当选择一个间隙时，下一个索引是 $t + 1$。对于一个从 $t$ 开始、长度为 $L$ 的爆发，其似然成本是在其长度为 $W = \\min(L + K - 1, T - t)$ 的覆盖窗口上计算的，计算方法是 $y_t$ 与该爆发的预测卷积之间的残差平方和。您还必须加上从覆盖窗口结束到不应期所施加的下一个允许起始时间之间的任何间隙样本的仅噪声成本。使用 $\\frac{1}{2 \\sigma^2}$ 进行高斯负对数似然缩放。\n\n输出规格：\n- 对于每个测试用例，将估计的尖峰样本索引以升序整数列表的形式输出，其中每个整数是 MAP 解中 $s_t=a$ 的样本索引 $t$。将所有测试用例的结果合并为单行输出，格式为一个用方括号括起来的逗号分隔列表。例如，一个有效的输出格式是 \"[[i_1,i_2,...],[j_1,j_2,...],...]\"。所有索引都是样本索引（无量纲整数）。最终答案中不需要进行物理单位转换。\n\n测试套件：\n您必须实现您的程序来解决以下四个测试用例。在每个案例中，您必须：\n1. 使用提供的 $K$ 构建核 $h_k = \\alpha \\gamma^k$。\n2. 通过从指定的基准真相爆发生成 $s_t$ 并与 $h_k$ 进行卷积来模拟 $y_t$，然后添加标准差为 $\\sigma$ 的独立高斯噪声。\n3. 使用给定参数运行动态规划程序，以计算 MAP 估计并报告尖峰样本索引。\n\n测试用例 1 (理想路径)：\n- $T = 80$，$\\Delta t = 0.1$ 秒，$\\tau_c = 0.7$ 秒，$\\alpha = 1.0$， $K = 12$，$a = 0.8$，$\\sigma = 0.05$，不应期 $r = 12$，$\\lambda = 0.2$，$\\rho = 0.1$，$L_{\\min} = 2$，$L_{\\max} = 6$。\n- 基准真相爆发：起始点和长度 $(10,3)$, $(35,4)$, $(60,2)$。\n\n测试用例 2 (无先验影响)：\n- $T = 80$，$\\Delta t = 0.1$ 秒，$\\tau_c = 0.7$ 秒，$\\alpha = 1.0$， $K = 12$，$a = 0.8$，$\\sigma = 0.08$，不应期 $r = 12$，$\\lambda = 0.0$，$\\rho = 0.0$，$L_{\\min} = 1$，$L_{\\max} = 5$。\n- 基准真相爆发：$(20,2)$, $(50,3)$。\n\n测试用例 3 (爆发先验占主导)：\n- $T = 100$，$\\Delta t = 0.1$ 秒，$\\tau_c = 1.0$ 秒，$\\alpha = 1.0$， $K = 10$，$a = 0.7$，$\\sigma = 0.06$，不应期 $r = 10$，$\\lambda = 0.5$，$\\rho = 0.45$，$L_{\\min} = 1$，$L_{\\max} = 8$。\n- 基准真相爆发：$(15,6)$, $(40,1)$, $(70,5)$。\n\n测试用例 4 (边界和更高噪声)：\n- $T = 30$，$\\Delta t = 0.1$ 秒，$\\tau_c = 0.5$ 秒，$\\alpha = 1.0$， $K = 8$，$a = 0.9$，$\\sigma = 0.15$，不应期 $r = 8$，$\\lambda = 0.15$，$\\rho = 0.05$，$L_{\\min} = 1$，$L_{\\max} = 4$。\n- 基准真相爆发：$(5,3)$。\n\n角度单位不适用。在内部以样本为单位表示所有与时间相关的量；最终输出是作为整数的样本索引。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，格式与上文描述的完全一致。",
            "solution": "该问题要求从带有噪声的荧光钙信号中计算尖峰序列的最大后验 (MAP) 估计。其底层模型是一个线性动力学系统，其中信号是尖峰序列与一个指数衰减核的卷积，并被加性高斯噪声所破坏。尖峰序列被结构化为特定长度的爆发，且在爆发之间施加了不应期。MAP 目标函数结合了一个高斯似然项和一个结构化先验，该先验惩罚尖峰的总数，但奖励形成爆发的连续尖峰。\n\n首先，我们验证问题陈述。模型和优化的所有参数都为四个测试用例明确提供。该模型本身基于线性系统理论和贝叶斯估计 (MAP)，是计算神经科学中的标准模型。使用动态规划的算法要求是明确定义的，并且是可行的，这得益于关键约束条件，即不应期 $r$ 不短于核长度 $K$ ($r \\ge K$)。此约束确保了来自不同推断爆发的钙瞬变在时间上不重叠，使得似然项在对应于每个爆发及其间间隙的不相交时间区间上是可分的。该问题有科学依据、内容自洽且定义良好。因此，该问题被认为是有效的。\n\n解决方案是通过实现一个精确的动态规划 (DP) 算法来推进的。令 $V(t)$ 为观测信号 $y$ 在时间区间 $[t, T-1]$ 上的最小成本（负对数后验），其中 $T$ 是总样本数。我们的目标是找到与 $V(0)$ 对应的尖峰序列。我们可以通过从时间 $t = T-1$ 向后递推至 $0$ 来递归地计算 $V(t)$。基本情况是对于所有 $t \\ge T$，$V(t) = 0$。\n\n对于任何时间 $t  T$，我们有两种选择：\n1.  **在 $t$ 处没有尖峰爆发开始**。这对应于一个单样本间隙。在这种情况下，我们假设尖峰值 $s_t=0$。在 $t$ 处的预测信号为 $0$。产生的成本是在信号为 $0$ 的情况下观测到 $y_t$ 的负对数似然，即 $\\frac{1}{2\\sigma^2} y_t^2$。此选择的总成本是这个单样本成本加上信号其余部分的最小成本 $V(t+1)$。\n    $$V_{\\text{gap}}(t) = \\frac{1}{2\\sigma^2} y_t^2 + V(t+1)$$\n\n2.  **一个长度为 $L$ 的爆发从 $t$ 开始**，其中 $L \\in [L_{\\min}, L_{\\max}]$。为使此选择有效，爆发必须在时间序列内结束，即 $t+L \\le T$。此选择的总成本是三个组成部分的总和：\n    a.  **先验成本**：对于一个长度为 $L$、振幅为 $a$ 的爆发，其先验项为 $\\lambda \\sum \\mathbf{1}[s_t=a] - \\rho \\sum \\mathbf{1}[s_t=a, s_{t+1}=a]$。其计算结果为 $\\lambda L - \\rho(L-1)$。\n    b.  **似然成本**：由于 $r \\ge K$ 的条件，成本是可分的。\n        i.   *与爆发相关的成本*：我们计算观测信号 $y_t$ 与来自此单个爆发的预测信号在其整个“覆盖窗口”内的残差平方和。一个从 $t$ 开始、长度为 $L$ 的爆发，其影响持续到时间 $t+L+K-2$。令 $W = \\min(L+K-1, T-t)$ 为此窗口的有效长度。成本为 $\\frac{1}{2\\sigma^2} \\sum_{k=0}^{W-1} (y_{t+k} - c_{t+k}^{\\text{burst}})^2$，其中 $c^{\\text{burst}}$ 是单个爆发与核 $h$ 的卷积。\n        ii.  *不应期间隙成本*：不应期 $r$ 在爆发后强制产生一个零值间隙。下一个可能的爆发只能从 $t' = t+L+r$ 开始。当前爆发覆盖窗口结束和下一个决策点开始之间的时间间隔包含被约束为没有尖峰的样本。这个强制间隙的成本是仅噪声的似然：$\\frac{1}{2\\sigma^2} \\sum_{k=t+W}^{t'-1} y_k^2$。\n    c.  **未来成本**：从下一个决策点开始的信号剩余部分的最优解成本，即 $V(t' = t+L+r)$。\n\nDP 的递推关系是：\n$$V(t) = \\min \\left( V_{\\text{gap}}(t), \\min_{L \\in [L_{\\min}, L_{\\max}], t+L \\le T} V_{\\text{burst}}(t, L) \\right)$$\n其中 $V_{\\text{burst}}(t, L)$ 封装了描述的从 $t$ 开始、长度为 $L$ 的爆发的三个成本组成部分。\n\n为了高效地实现这一点，我们首先如前所述为每个测试用例模拟带噪信号 $y_t$。然后，对于 DP，我们预先计算一些辅助量：核 $h_k=\\alpha\\gamma^k$、缩放后的信号平方 $\\frac{1}{2\\sigma^2} y_t^2$ 及其用于快速计算间隙成本的累积和，以及对于每种可能长度 $L$ 的爆发的预测荧光信号。然后我们填充一个 DP 表来存储成本 $V(t)$，并填充另一个表来存储每个 $t$ 的最优选择（间隙或爆发长度 $L$）。\n\n在从 $t=T-1$ 向下填充到 $0$ 完成表格后，我们从 $t=0$ 开始执行一个回溯过程。我们遵循存储的最优选择来重建爆发序列。如果在时间 $t$ 的选择是长度为 $L$ 的爆发，我们将索引 $[t, t+1, \\dots, t+L-1]$ 添加到我们的解集中，并跳转到下一个决策点 $t' = t+L+r$。如果选择是间隙，我们只需前进到 $t+1$。这个过程产生最终解码出的尖峰索引集合。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Use a fixed seed for the random number generator to ensure that the\n    # simulated noisy calcium traces are reproducible.\n    np.random.seed(0)\n\n    # Define test cases as a list of dictionaries.\n    test_cases = [\n        {\n            \"T\": 80, \"dt\": 0.1, \"tau_c\": 0.7, \"alpha\": 1.0, \"K\": 12, \"a\": 0.8,\n            \"sigma\": 0.05, \"r\": 12, \"lam\": 0.2, \"rho\": 0.1, \"L_min\": 2, \"L_max\": 6,\n            \"ground_truth_bursts\": [(10, 3), (35, 4), (60, 2)]\n        },\n        {\n            \"T\": 80, \"dt\": 0.1, \"tau_c\": 0.7, \"alpha\": 1.0, \"K\": 12, \"a\": 0.8,\n            \"sigma\": 0.08, \"r\": 12, \"lam\": 0.0, \"rho\": 0.0, \"L_min\": 1, \"L_max\": 5,\n            \"ground_truth_bursts\": [(20, 2), (50, 3)]\n        },\n        {\n            \"T\": 100, \"dt\": 0.1, \"tau_c\": 1.0, \"alpha\": 1.0, \"K\": 10, \"a\": 0.7,\n            \"sigma\": 0.06, \"r\": 10, \"lam\": 0.5, \"rho\": 0.45, \"L_min\": 1, \"L_max\": 8,\n            \"ground_truth_bursts\": [(15, 6), (40, 1), (70, 5)]\n        },\n        {\n            \"T\": 30, \"dt\": 0.1, \"tau_c\": 0.5, \"alpha\": 1.0, \"K\": 8, \"a\": 0.9,\n            \"sigma\": 0.15, \"r\": 8, \"lam\": 0.15, \"rho\": 0.05, \"L_min\": 1, \"L_max\": 4,\n            \"ground_truth_bursts\": [(5, 3)]\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        spikes = run_deconvolution_case(params)\n        all_results.append(spikes)\n\n    # Format the final output string as specified: [[i_1,i_2,...],[j_1,j_2,...],...]\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in all_results])}]\"\n    print(output_str)\n\ndef simulate_signal(T, dt, tau_c, alpha, K, a, sigma, ground_truth_bursts):\n    \"\"\"\n    Generates a noisy calcium signal based on the generative model.\n    \"\"\"\n    # Construct spike train s_t from ground-truth bursts\n    s = np.zeros(T)\n    for start, length in ground_truth_bursts:\n        if start + length = T:\n            s[start:start + length] = a\n\n    # Construct impulse response kernel h_k\n    gamma = np.exp(-dt / tau_c)\n    k = np.arange(K)\n    h = alpha * (gamma ** k)\n\n    # Compute clean fluorescence signal by convolution\n    c = np.convolve(h, s)[:T]\n\n    # Generate and add Gaussian noise\n    noise = np.random.normal(0, sigma, T)\n    y = c + noise\n    return y\n\ndef run_deconvolution_case(params):\n    \"\"\"\n    Solves the MAP estimation problem for a single test case.\n    \"\"\"\n    # Unpack parameters\n    T = params[\"T\"]; dt = params[\"dt\"]; tau_c = params[\"tau_c\"]; alpha = params[\"alpha\"]\n    K = params[\"K\"]; a = params[\"a\"]; sigma = params[\"sigma\"]; r = params[\"r\"]\n    lam = params[\"lam\"]; rho = params[\"rho\"]; L_min = params[\"L_min\"]; L_max = params[\"L_max\"]\n    ground_truth_bursts = params[\"ground_truth_bursts\"]\n\n    # 1. Simulate the observed fluorescence signal y_t\n    y = simulate_signal(T, dt, tau_c, alpha, K, a, sigma, ground_truth_bursts)\n\n    # 2. Pre-computation for the dynamic programming algorithm\n    gamma = np.exp(-dt / tau_c)\n    k = np.arange(K)\n    h = alpha * (gamma ** k)\n    cost_scale = 1.0 / (2.0 * sigma**2)\n    y_sq_cumsum = np.zeros(T + 1)\n    y_sq_cumsum[1:] = np.cumsum(y**2)\n\n    burst_responses = {}\n    for L in range(L_min, L_max + 1):\n        s_burst = np.zeros(L + K - 1)\n        s_burst[:L] = a\n        burst_responses[L] = np.convolve(h, s_burst)[:L + K - 1]\n\n    # 3. Dynamic Programming to find the MAP estimate\n    dp_cost = np.full(T + 1, np.inf)\n    dp_choices = np.zeros(T, dtype=int)\n    dp_cost[T] = 0.0\n\n    for t in range(T - 1, -1, -1):\n        # Option 1: Place a gap (no spike) at time t\n        cost_gap = cost_scale * y[t]**2 + dp_cost[t + 1]\n        min_cost = cost_gap\n        best_choice = 0\n\n        # Option 2: Place a burst of length L starting at time t\n        for L in range(L_min, L_max + 1):\n            if t + L > T:\n                continue\n\n            prior_cost = lam * L - (rho * (L - 1) if L > 1 else 0)\n\n            c_burst = burst_responses[L]\n            W = min(L + K - 1, T - t)\n            y_window = y[t : t + W]\n            c_window = c_burst[:W]\n            ll_burst = cost_scale * np.sum((y_window - c_window)**2)\n\n            t_next = t + L + r\n            \n            gap_start_idx = t + W\n            gap_end_idx = min(t_next, T)\n            ll_refractory_gap = 0.0\n            if gap_start_idx  gap_end_idx:\n                ll_refractory_gap = cost_scale * (y_sq_cumsum[gap_end_idx] - y_sq_cumsum[gap_start_idx])\n            \n            future_cost = dp_cost[min(t_next, T)]\n            cost_burst = prior_cost + ll_burst + ll_refractory_gap + future_cost\n\n            if cost_burst  min_cost:\n                min_cost = cost_burst\n                best_choice = L\n        \n        dp_cost[t] = min_cost\n        dp_choices[t] = best_choice\n\n    # 4. Backtracking to reconstruct the optimal spike train\n    spike_indices = []\n    current_t = 0\n    while current_t  T:\n        choice = dp_choices[current_t]\n        if choice == 0:  # Gap\n            current_t += 1\n        else:  # Burst of length L = choice\n            L = choice\n            spike_indices.extend(range(current_t, current_t + L))\n            current_t += L + r\n    \n    return spike_indices\n\nsolve()\n```"
        },
        {
            "introduction": "钙成像通过离散的、时间平均的帧来捕捉一个连续的生物过程。本练习旨在解决这一根本性挑战，引导你从一个连续时间微分方程出发，推导出精确的前向模型。通过使用这个精确模型解决逆问题，你将学会如何实现时间上的“超分辨率”，以比成像帧率更高的精度估计脉冲发放时间。",
            "id": "4154469",
            "problem": "给定一个由神经元脉冲驱动的钙荧光连续时间生成模型和一个帧平均测量过程。潜在的细胞内钙离子浓度由以下线性时不变常微分方程建模\n$$\n\\frac{d c(t)}{d t} = -\\frac{1}{\\tau} c(t) + \\alpha\\, s(t),\n$$\n其中 $c(t)$ 是钙离子浓度，$s(t)$ 是脉冲序列，建模为在未知脉冲时刻的一系列狄拉克脉冲之和，$\\tau$ 是钙离子衰减时间常数，$\\alpha$是每次脉冲发生时 $c(t)$ 的瞬时跃变量。成像系统在时长为 $\\Delta$ 秒的帧上对 $c(t)$ 进行积分，并返回帧平均荧光\n$$\ny_k = \\frac{1}{\\Delta} \\int_{k\\Delta}^{(k+1)\\Delta} c(t) \\, dt + \\eta_k,\n$$\n对于帧索引 $k \\in \\{0,1,\\dots, K-1\\}$，其中包含标准差为 $\\sigma$ 的加性零均值高斯噪声 $\\eta_k$。\n\n你的任务是通过假设每帧内有一个包含 $R$ 个子区间的均匀子帧网格来实现帧内的时间超分辨率，其中子区间时长为 $\\delta = \\Delta / R$。设总帧数为 $K$，则总子区间数为 $N = K R$，并定义子区间时间 $t_n = n \\delta$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。假设脉冲发生在此子区间网格上。从上述钙离子动力学微分方程和帧平均测量定义出发，通过对每帧的脉冲响应进行解析积分，推导出将长度为 $N$ 的非负子区间脉冲向量映射到 $K$ 个帧平均荧光样本的精确线性正向算子。\n\n实现一个程序，该程序：\n- 根据模型所隐含的解析积分，精确构建正向算子，不进行任何离散时间欧拉近似。\n- 通过将正向算子与真实值子区间脉冲向量相乘，并添加指定标准差 $\\sigma$ 的独立高斯噪声，为每个测试用例模拟 $y_k$。\n- 通过求解一个非负最小二乘 (NNLS) 问题来估计非负子区间脉冲振幅，即在非负性约束下最小化平方误差。\n- 通过使用等于 $\\max(\\alpha/2, 3\\sigma)$ 的固定阈值对估计的子区间振幅进行阈值化处理，并仅选择子区间格点上的局部最大值来检测脉冲时刻，以避免每次脉冲被多次检测。通过对局部最大值周围的三点邻域拟合一个局部抛物线，并使用其顶点位置来估计一个在 $[-\\delta/2, \\delta/2]$ 范围内的子区间偏移，从而精化每个检测到的脉冲时刻（仅当两侧邻点都存在时）；否则，使用子区间的中心。所有报告的脉冲时刻均以秒为单位表示。\n- 对于每个测试用例，输出以秒为单位的估计脉冲时刻列表，按升序排序并四舍五入到 $4$ 位小数。\n\n物理单位和输出规范：\n- 时间必须以秒为单位表示，并四舍五入到 $4$ 位小数。\n- 荧光振幅以任意单位 (a.u.) 表示，但只需输出脉冲时刻。\n\n测试套件：\n使用以下四个科学上合理的测试用例，每个用例描述了 $(\\Delta, \\tau, \\alpha, R, K, \\sigma)$ 和以秒为单位的真实值脉冲时刻。所有给定的脉冲时刻都位于相应的子区间网格上。\n\n- 用例 $1$ (理想情况): $\\Delta = 0.1$ 秒, $\\tau = 0.8$ 秒, $\\alpha = 1.0$ a.u., $R = 5$, $K = 25$, $\\sigma = 0.02$ a.u., 真实值脉冲位于 $[1.22]$ 秒。\n- 用例 $2$ (帧边缘的边界条件): $\\Delta = 0.1$ 秒, $\\tau = 1.0$ 秒, $\\alpha = 1.0$ a.u., $R = 8$, $K = 20$, $\\sigma = 0.05$ a.u., 真实值脉冲位于 $[1.0]$ 秒。\n- 用例 $3$ (单帧内两次脉冲): $\\Delta = 0.1$ 秒, $\\tau = 0.5$ 秒, $\\alpha = 1.0$ a.u., $R = 10$, $K = 15$, $\\sigma = 0.01$ a.u., 真实值脉冲位于 $[0.62, 0.66]$ 秒。\n- 用例 $4$ (无脉冲，仅含噪声的边缘情况): $\\Delta = 0.1$ 秒, $\\tau = 1.2$ 秒, $\\alpha = 1.0$ a.u., $R = 5$, $K = 10$, $\\sigma = 0.03$ a.u., 真实值脉冲位于 $[]$ 秒 (空列表)。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应测试用例的脉冲时刻列表（以秒为单位，四舍五入到 $4$ 位小数），例如 $[[0.6200,0.6600],[1.0000],[1.2200],[]]$。输出中测试用例的顺序必须与上面列出的顺序一致。",
            "solution": "该问题要求推导并实现一个反卷积算法，用于从帧平均钙荧光数据中估计神经元脉冲时刻。整个过程始于对问题陈述的形式化验证，随后是正向模型的详细推导以及反演和脉冲检测算法的描述。\n\n### 问题验证\n\n**步骤 1：提取的已知条件**\n- **钙离子动力学模型：** 细胞内钙离子浓度 $c(t)$ 由线性常微分方程 (ODE) 控制：\n    $$ \\frac{d c(t)}{d t} = -\\frac{1}{\\tau} c(t) + \\alpha\\, s(t) $$\n    其中 $\\tau$ 是钙离子衰减时间常数，$\\alpha$ 是每次脉冲的浓度跃变量，$s(t)$ 是脉冲序列，建模为狄拉克 $\\delta$ 函数之和。\n- **测量模型：** 第 $k$ 帧的测量荧光 $y_k$ 是 $c(t)$ 在帧时长 $\\Delta$ 内的时间平均值，并带有加性高斯噪声 $\\eta_k$：\n    $$ y_k = \\frac{1}{\\Delta} \\int_{k\\Delta}^{(k+1)\\Delta} c(t) \\, dt + \\eta_k $$\n    其中 $k \\in \\{0, 1, \\dots, K-1\\}$ 且 $\\eta_k \\sim \\mathcal{N}(0, \\sigma^2)$。\n- **离散化方案：** 假设脉冲发生在每帧含 $R$ 个区间的均匀子帧网格上。子区间时长为 $\\delta = \\Delta / R$，总子区间数为 $N = K R$。脉冲序列由该网格上的非负振幅向量表示。\n- **任务：** 目标是推导将子区间脉冲向量映射到荧光样本的精确线性算子，模拟数据，然后使用非负最小二乘 (NNLS) 反演模型以估计脉冲时刻，随后进行阈值化、局部最大值查找和抛物线时间精化。\n- **脉冲检测标准：**\n    - 阈值：对估计的脉冲振幅使用 $\\max(\\alpha/2, 3\\sigma)$。\n    - 峰值查找：仅选择局部最大值。\n    - 精化：对峰值的3点邻域拟合抛物线以找到子区间内的时间偏移。\n- **测试用例：** 提供了四组特定的参数集 $(\\Delta, \\tau, \\alpha, R, K, \\sigma)$ 及相应的真实脉冲时刻。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据验证标准对问题陈述进行评估：\n1.  **科学依据：** 该模型是计算神经科学中钙离子动力学和荧光成像的一个标准且被广泛接受的表示方法。所有原理在科学上都是合理的。\n2.  **适定性：** 问题结构清晰，能够得到唯一且稳定的解。正向模型的推导是一个直接的解析任务。反问题被构建为一个凸优化问题 (NNLS)，该问题有唯一解。后续处理步骤是确定性的。\n3.  **客观性：** 问题通过精确的数学形式体系和客观、可量化的任务进行了规定。\n4.  **设置不完整或矛盾：** 所有必要的参数和模型定义都已提供。测试用例数据（例如，网格上的脉冲时刻）与模型的假设一致。\n5.  **不切实际或不可行：** 指定的参数和所需的计算是现实且计算上可行的。\n6.  **不适定或结构不良：** 问题结构良好，从理论到实现提供了清晰的指引。\n7.  **伪深刻、琐碎或同义反复：** 该问题涉及一个非平凡的解析推导和标准、实质性数据分析流程的实现。它并非琐碎或人为设计的。\n8.  **相关性和可验证性：** 该问题与指定主题直接相关，其解决方案在数学上和计算上都是可验证的。\n\n**步骤 3：结论和行动**\n该问题在所有标准上均被判定为 **有效**。我将继续进行推导和求解。\n\n### 正向算子的推导\n\n目标是构建一个线性算子（一个矩阵）$A$，该算子根据模型 $\\mathbf{y} = A\\mathbf{s} + \\boldsymbol{\\eta}$，将离散的脉冲振幅向量 $\\mathbf{s}$ 映射到帧平均荧光测量向量 $\\mathbf{y}$。\n\n**1. 脉冲响应函数**\n首先，我们求解在时刻 $t_j = j\\delta$ 发生单个脉冲时的常微分方程，其输入为 $\\alpha \\delta(t-t_j)$。方程为：\n$$ \\frac{d c(t)}{d t} + \\frac{1}{\\tau} c(t) = \\alpha \\, \\delta(t-t_j) $$\n假设系统在 $t  t_j$ 时处于静止状态（即 $c(t)=0$），则对于 $t \\ge t_j$ 的解是一个因果指数衰减。狄拉克 $\\delta$ 输入导致 $c(t)$ 在 $t=t_j$ 时从 $0$ 瞬时跃变到 $\\alpha$。对于 $tt_j$，方程是齐次的，$\\frac{dc}{dt} = -\\frac{c}{\\tau}$，初始条件为 $c(t_j^+) = \\alpha$。其解为：\n$$ c(t) = \\alpha \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) \\quad \\text{for } t \\ge t_j $$\n我们可以将对时刻 $t_j$ 处脉冲的完整响应（也称为脉冲响应）写为：\n$$ h(t; t_j) = \\alpha \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) U(t-t_j) $$\n其中 $U(\\cdot)$ 是 Heaviside 阶跃函数。\n\n**2. 脉冲序列的钙离子浓度**\n根据线性叠加原理，由在离散时刻 $t_j = j\\delta$ 具有振幅 $s_j$ 的一系列脉冲所产生的钙离子浓度 $c(t)$ 是各个响应的总和：\n$$ c(t) = \\sum_{j=0}^{N-1} s_j h(t; t_j) = \\sum_{j=0}^{N-1} s_j \\alpha \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) U(t-t_j) $$\n\n**3. 帧平均荧光测量**\n测量值 $y_k$ 是 $c(t)$ 在第 $k$ 帧（从 $T_k^{\\text{start}} = k\\Delta$ 到 $T_k^{\\text{end}} = (k+1)\\Delta$）上的积分，并由帧时长 $\\Delta$ 进行归一化。代入 $c(t)$ 的表达式并暂时忽略噪声项：\n$$ y_k = \\frac{1}{\\Delta} \\int_{k\\Delta}^{(k+1)\\Delta} \\left( \\sum_{j=0}^{N-1} s_j \\alpha \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) U(t-t_j) \\right) dt $$\n我们可以交换求和与积分的顺序：\n$$ y_k = \\sum_{j=0}^{N-1} s_j \\left[ \\frac{\\alpha}{\\Delta} \\int_{k\\Delta}^{(k+1)\\Delta} \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) U(t-t_j) dt \\right] $$\n该方程的形式为 $y_k = \\sum_{j=0}^{N-1} A_{kj} s_j$，其中 $A_{kj}$ 是正向算子矩阵 $A$ 的第 $k$ 行第 $j$ 列的元素。\n\n**4. 矩阵元素 $A_{kj}$ 的解析计算**\n矩阵元素 $A_{kj}$ 代表子区间 $j$ 中单位振幅脉冲对第 $k$ 帧平均荧光的贡献。\n$$ A_{kj} = \\frac{\\alpha}{\\Delta} \\int_{k\\Delta}^{(k+1)\\Delta} \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) U(t-t_j) dt $$\nHeaviside 函数 $U(t-t_j)$ 使得被积函数仅在 $t \\ge t_j$ 时非零。因此，积分的有效下限是 $\\max(k\\Delta, t_j)$。只有当 $\\max(k\\Delta, t_j)  (k+1)\\Delta$ 时，积分才非零。这意味着 $t_j  (k+1)\\Delta$。\n\n我们来计算不定积分：\n$$ \\int \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) dt = -\\tau \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) + C $$\n现在我们根据脉冲时刻（$t_j$）和帧区间 $[k\\Delta, (k+1)\\Delta]$ 的相对时间关系考虑三种情况：\n\n情况 1：脉冲发生在帧开始之前 ($t_j  k\\Delta$)。\n积分区间为 $[k\\Delta, (k+1)\\Delta]$。\n\\begin{align*} A_{kj} = \\frac{\\alpha}{\\Delta} \\left[ -\\tau \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) \\right]_{k\\Delta}^{(k+1)\\Delta} \\\\ = \\frac{\\alpha\\tau}{\\Delta} \\left[ \\exp\\left(-\\frac{k\\Delta-t_j}{\\tau}\\right) - \\exp\\left(-\\frac{(k+1)\\Delta-t_j}{\\tau}\\right) \\right] \\\\ = \\frac{\\alpha\\tau}{\\Delta} \\exp\\left(-\\frac{k\\Delta-t_j}{\\tau}\\right) \\left(1 - \\exp\\left(-\\frac{\\Delta}{\\tau}\\right)\\right)\\end{align*}\n\n情况 2：脉冲发生在帧内部 ($k\\Delta \\le t_j  (k+1)\\Delta$)。\n积分区间为 $[t_j, (k+1)\\Delta]$。\n\\begin{align*} A_{kj} = \\frac{\\alpha}{\\Delta} \\left[ -\\tau \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) \\right]_{t_j}^{(k+1)\\Delta} \\\\ = \\frac{\\alpha\\tau}{\\Delta} \\left[ \\exp\\left(-\\frac{t_j-t_j}{\\tau}\\right) - \\exp\\left(-\\frac{(k+1)\\Delta-t_j}{\\tau}\\right) \\right] \\\\ = \\frac{\\alpha\\tau}{\\Delta} \\left( 1 - \\exp\\left(-\\frac{(k+1)\\Delta-t_j}{\\tau}\\right) \\right) \\end{align*}\n\n情况 3：脉冲发生在帧结束之后 ($t_j \\ge (k+1)\\Delta$)。\n积分区间为空。\n$$ A_{kj} = 0 $$\n\n这三种情况完全定义了正向算子矩阵 $A$。\n\n### 反演与脉冲估计算法\n构建了正向算子 $A$ 之后，从带噪声的测量值 $\\mathbf{y}$ 中估计脉冲振幅 $\\mathbf{s}$ 的问题就成了一个反问题。\n\n1.  **非负最小二乘 (NNLS)：** 鉴于脉冲振幅必须为非负，我们求解以下约束优化问题：\n    $$ \\hat{\\mathbf{s}} = \\arg\\min_{\\mathbf{s} \\ge 0} || A\\mathbf{s} - \\mathbf{y} ||_2^2 $$\n    这是一个标准的 NNLS 问题，可以使用数值库高效求解。\n\n2.  **脉冲检测：** 得到的向量 $\\hat{\\mathbf{s}}$ 包含每个子区间的估计振幅。通过以下方式识别脉冲：\n    a. **阈值化：** 选择所有估计振幅 $\\hat{s}_n$ 超过阈值 $T = \\max(\\alpha/2, 3\\sigma)$ 的子区间 $n$。\n    b. **局部最大值（非极大值抑制）：** 从经过阈值处理的区间中，仅保留那些是局部最大值的区间，即 $\\hat{s}_n  \\hat{s}_{n-1}$ 且 $\\hat{s}_n  \\hat{s}_{n+1}$（适当处理边界条件）。这确保了估计中的一个对应于单个真实脉冲的较宽峰值不会被多次检测。\n\n3.  **脉冲时刻精化：** 为实现子区间内的时间超分辨率，我们对每个检测到的脉冲时刻进行精化。对于子区间 $n$ 处的一个峰值，我们用抛物线 $f(t) = at^2+bt+c$ 拟合三个点 $(\\hat{t}_{n-1}, \\hat{s}_{n-1})$、$(\\hat{t}_{n}, \\hat{s}_{n})$ 和 $(\\hat{t}_{n+1}, \\hat{s}_{n+1})$，其中 $\\hat{t}_n = n\\delta$。精化后的脉冲时刻是抛物线顶点的水平坐标。距离区间 $n$中心的偏移量 $\\Delta t$ 由下式给出：\n    $$ \\Delta t = \\frac{\\hat{s}_{n-1} - \\hat{s}_{n+1}}{2(\\hat{s}_{n-1} + \\hat{s}_{n+1} - 2\\hat{s}_n)} \\delta $$\n    精化后的脉冲时刻为 $t_{\\text{refined}} = \\hat{t}_n + \\Delta t$。仅对两侧邻点都可用的峰值执行此精化；否则，使用子区间中心时刻 $\\hat{t}_n$。算法设计至此结束。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: (Delta, tau, alpha, R, K, sigma, true_spike_times)\n        (0.1, 0.8, 1.0, 5, 25, 0.02, [1.22]),\n        # Case 2\n        (0.1, 1.0, 1.0, 8, 20, 0.05, [1.0]),\n        # Case 3\n        (0.1, 0.5, 1.0, 10, 15, 0.01, [0.62, 0.66]),\n        # Case 4\n        (0.1, 1.2, 1.0, 5, 10, 0.03, []),\n    ]\n\n    all_results = []\n    for i, case in enumerate(test_cases):\n        # Use a fixed seed for each case for reproducibility, although not strictly required\n        np.random.seed(i)\n        \n        Delta, tau, alpha, R, K, sigma, true_spike_times = case\n\n        # Derived parameters\n        delta = Delta / R\n        N = K * R  # Total number of sub-bins\n\n        # 1. Construct the forward operator A\n        A = build_forward_operator(Delta, tau, alpha, R, K, N, delta)\n\n        # 2. Build ground-truth spike vector s_true\n        s_true = np.zeros(N)\n        if true_spike_times:\n            # Note: problem statement guarantees spikes are on the grid\n            spike_indices = np.round(np.array(true_spike_times) / delta).astype(int)\n            s_true[spike_indices] = 1.0\n\n        # 3. Simulate fluorescence data y\n        y_clean = A @ s_true\n        noise = np.random.normal(0, sigma, K)\n        y = y_clean + noise\n\n        # 4. Estimate spike amplitudes s_est via NNLS\n        s_est, _ = nnls(A, y)\n\n        # 5. Detect and refine spike times\n        estimated_times = detect_and_refine_spikes(s_est, delta, N, alpha, sigma)\n        \n        # Format results to 4 decimal places\n        formatted_times = [f\"{t:.4f}\" for t in estimated_times]\n        all_results.append(f\"[{','.join(formatted_times)}]\")\n\n    # Print final output in the required format\n    print(f\"[{','.join(all_results)}]\")\n\ndef build_forward_operator(Delta, tau, alpha, R, K, N, delta):\n    \"\"\"\n    Constructs the exact K x N forward operator matrix A.\n    \"\"\"\n    A = np.zeros((K, N))\n    \n    # Grid of time points and frame indices\n    k_grid, j_grid = np.meshgrid(np.arange(K), np.arange(N), indexing='ij')\n\n    t_j = j_grid * delta\n    T_k_start = k_grid * Delta\n    T_k_end = (k_grid + 1) * Delta\n\n    # Case 1: Spike before frame (t_j  T_k_start)\n    idx1 = t_j  T_k_start\n    term1 = (alpha * tau / Delta)\n    # The exponential term can be large, but the product is well-behaved\n    # exp((t_j - T_k_start)/tau) = exp((j*delta - k*Delta)/tau)\n    # = exp((j/R - k)*Delta/tau)\n    exp_decay_across_frame = np.exp(-Delta / tau)\n    A[idx1] = term1 * np.exp((t_j[idx1] - T_k_start[idx1]) / tau) * (1 - exp_decay_across_frame)\n\n    # Case 2: Spike within frame (T_k_start = t_j  T_k_end)\n    idx2 = (t_j >= T_k_start)  (t_j  T_k_end)\n    A[idx2] = term1 * (1 - np.exp(-(T_k_end[idx2] - t_j[idx2]) / tau))\n\n    # Case 3 (spike after frame) is implicitly handled as A is initialized to zeros.\n    \n    return A\n\ndef detect_and_refine_spikes(s_est, delta, N, alpha, sigma):\n    \"\"\"\n    Detects spikes from estimated amplitudes via thresholding, non-maximum\n    suppression, and refines their timing using parabolic interpolation.\n    \"\"\"\n    if N == 0:\n        return []\n\n    threshold = max(alpha / 2.0, 3.0 * sigma)\n    \n    # Find indices of potential peaks (above threshold)\n    potential_peak_indices = np.where(s_est > threshold)[0]\n    \n    peak_indices = []\n    for n in potential_peak_indices:\n        # Check for local maximum property (non-maximum suppression)\n        is_local_max = True\n        # Check left neighbor\n        if n > 0 and s_est[n] = s_est[n-1]:\n            is_local_max = False\n        # Check right neighbor\n        if n  N - 1 and s_est[n] = s_est[n+1]:\n            is_local_max = False\n        \n        if is_local_max:\n            peak_indices.append(n)\n\n    estimated_times = []\n    for n in peak_indices:\n        t_n = n * delta\n        \n        # Perform parabolic refinement if neighbors exist\n        if 0  n  N - 1:\n            s_left, s_peak, s_right = s_est[n-1], s_est[n], s_est[n+1]\n            \n            # The denominator is 2 * (s_left + s_right - 2*s_peak)\n            # which is proportional to the second derivative (curvature)\n            denominator = 2 * (s_left + s_right - 2 * s_peak)\n            \n            if np.abs(denominator)  1e-9: # Avoid division by zero (collinear points)\n                offset = 0.0\n            else:\n                offset = delta * (s_left - s_right) / denominator\n                \n            # As per problem, offset is expected within [-delta/2, delta/2].\n            # Clip for robustness.\n            offset = np.clip(offset, -delta / 2.0, delta / 2.0)\n\n            refined_time = t_n + offset\n        else:\n            # Use sub-bin center for boundary peaks\n            refined_time = t_n\n        \n        estimated_times.append(refined_time)\n\n    estimated_times.sort()\n    return estimated_times\n\nsolve()\n```"
        }
    ]
}