{
    "hands_on_practices": [
        {
            "introduction": "在神经振荡分析中，任何定量结论都始于对功率谱密度（PSD）的准确计算。然而，原始的计算工具输出的往往是任意单位，这使得结果的物理解释和跨研究比较变得困难。本练习将指导您从第一原理出发，掌握将原始数字化信号的PSD转换为具有物理意义的单位（如 $\\mu V^2/Hz$）的关键步骤，并计算特定频带内的功率，这是频谱分析的基础技能 。",
            "id": "4138609",
            "problem": "一个脑电图 (EEG) 通道被数字化为整数计数，记为 $x[n]$，采样频率为 $F_s = 512$ 赫兹。使用汉宁窗 $w[n]$ 对一个 $N = 4096$ 个样本的片段（8秒）进行分析，在进行离散傅里叶变换 (DFT) 之前施加该窗函数，从而产生单边功率谱密度 (PSD) 估计。仪器报告的原始计数的单边PSD为 $S_{x,1}(f)$，单位为 计数$^{2}$/赫兹。在从 $8$ 赫兹到 $12$ 赫兹的α波段，报告的PSD在该水平上近似平坦，为 $S_{x,1}(f) = 1.2 \\times 10^{3}$ 计数$^{2}$/赫兹。\n\n模拟前端经过校准，使得每个计数对应 $g = 0.09$ $\\mu$V/计数，因此物理EEG信号为 $y[n] = g\\,x[n]$，单位为微伏 ($\\mu$V)。您可以假设仪器的PSD计算使用了标准的能量守恒周期图，并进行了适当的窗功率归一化和单边转换。\n\n从DFT、帕塞瓦尔定理 (Parseval’s theorem) 的基本定义以及对功率谱密度进行频率积分得到信号功率（方差）这一概念出发，完成以下任务：\n\n- 从 $y[n]$ 的加窗DFT推导出生成单位为 $\\mu$V$^{2}$/Hz 的PSD的单位一致性缩放，在您的推理中明确指出窗功率因子，并解释如何使用校准值 $g$ 将报告的 计数$^{2}$/Hz PSD转换为 $\\mu$V$^{2}$/Hz。\n- 使用推导出的单位转换和对PSD在某频带上积分得到该频带功率的原理，通过对 $S_{y,1}(f)$ 在 $f \\in [8, 12]$ Hz 上积分来计算α波段功率。\n\n将最终的频带功率以 $\\mu$V$^{2}$ 表示，并将您的答案四舍五入到四位有效数字。",
            "solution": "经评估，该问题陈述有效。所有提供的数据和条件都具有科学依据、相互一致，并且足以得出一个唯一解。该问题提法明确且客观，符合分析神经生理数据（如EEG）的标准数字信号处理（DSP）实践。\n\n该问题需要两个主要步骤：首先，推导将加窗离散傅里叶变换（DFT）转换为物理单位的单边功率谱密度（PSD）的缩放因子，并解释从仪器报告的PSD到物理PSD的转换；其次，计算α波段的功率。\n\n**第一部分：PSD缩放和单位转换的推导**\n\n设以物理单位表示的离散时间EEG信号为 $y[n]$，单位为 $\\mu$V。信号以频率 $F_s$ 采样，并分析一个包含 $N$ 个样本的片段。分析过程包括对信号片段施加一个窗函数 $w[n]$，得到加窗信号 $y_w[n] = y[n]w[n]$。\n\n加窗信号的DFT由下式给出：\n$$ Y_w[k] = \\sum_{n=0}^{N-1} y_w[n] \\exp\\left(-j \\frac{2\\pi nk}{N}\\right) $$\n$Y_w[k]$ 的单位是 $\\mu$V，因为 $w[n]$ 是无量纲的。\n\n信号的总功率等价于其方差 $\\sigma_y^2$。PSD分析的一个基本原理是，信号的总功率是其双边PSD $S_{y,2}(f)$ 在所有频率上的积分：\n$$ P_{\\text{total}} = \\sigma_y^2 = \\int_{-F_s/2}^{F_s/2} S_{y,2}(f) \\, df $$\n在离散域中，这个积分通过对DFT频率仓（bin）的求和来近似：\n$$ P_{\\text{total}} \\approx \\sum_{k=0}^{N-1} S_{y,2}[k] \\Delta f $$\n其中 $\\Delta f = F_s/N$ 是DFT的频率分辨率。\n\n周期图是PSD的一种常用估计器。对于加窗信号，PSD估计器必须进行缩放以保持功率守恒。适当的缩放因子考虑了采样频率和窗函数的功率。在频率仓 $k$ 处的双边PSD估计 $S_{y,2}[k]$ 定义为：\n$$ S_{y,2}[k] = \\frac{1}{F_s S_2} |Y_w[k]|^2 $$\n其中 $S_2 = \\sum_{n=0}^{N-1} w[n]^2$ 是窗系数的平方和，我们将其确定为**窗功率因子**。这个因子确保了从PSD估计的总功率与从时域信号估计的功率相匹配。此表达式的单位是 $(\\mu\\text{V})^2 / \\text{Hz}$，这对于PSD是正确的。\n\n对于指定的汉宁窗 $w[n] = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N}\\right)\\right)$，窗功率因子 $S_2$ 有一个众所周知的值。其精确值由以下求和推导得出：\n$$ S_2 = \\sum_{n=0}^{N-1} \\left[ \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N}\\right)\\right) \\right]^2 = \\frac{1}{4} \\sum_{n=0}^{N-1} \\left(1 - 2\\cos\\left(\\frac{2\\pi n}{N}\\right) + \\cos^2\\left(\\frac{2\\pi n}{N}\\right)\\right) $$\n使用恒等式 $\\cos^2(\\theta) = \\frac{1}{2}(1 + \\cos(2\\theta))$ 以及余弦函数在整数个完整周期上的和为零（对于非 $N$ 的倍数的整数 $k$，有 $\\sum_{n=0}^{N-1} \\cos(\\frac{2\\pi nk}{N}) = 0$），该求和可简化为：\n$$ S_2 = \\frac{1}{4} \\sum_{n=0}^{N-1} \\left(1 + \\frac{1}{2}\\right) = \\frac{1}{4} \\sum_{n=0}^{N-1} \\frac{3}{2} = \\frac{3}{8}N $$\n\n问题指定了单边PSD $S_{y,1}(f)$，这对于实值信号是常见的。对于实信号，其DFT是共轭对称的（$Y_w[k] = Y_w^*[N-k]$），因此其功率谱 $|Y_w[k]|^2$ 是对称的。单边PSD通常通过将负频率的功率折叠到正频率上来定义。对于频率 $f_k > 0$ 且非奈奎斯特频率，这意味着：\n$$ S_{y,1}(f_k) = 2 S_{y,2}(f_k) $$\n代入我们对 $S_{y,2}[k]$ 和 $S_2$ 的表达式：\n$$ S_{y,1}[k] = 2 \\left( \\frac{1}{F_s (\\frac{3}{8}N)} |Y_w[k]|^2 \\right) = \\frac{16}{3 F_s N} |Y_w[k]|^2 $$\n这就是从 $y[n]$ 的加窗DFT生成单位为 $\\mu\\text{V}^2/\\text{Hz}$ 的单边PSD所需的缩放。\n\n接下来，我们解释如何将报告的基于计数的PSD $S_{x,1}(f)$ 转换为物理PSD $S_{y,1}(f)$。物理信号 $y[n]$ 通过校准因子 $g$ 与原始计数信号 $x[n]$ 相关联：\n$$ y[n] = g \\cdot x[n] $$\n其中 $g = 0.09 \\, \\mu\\text{V/count}$。DFT是一种线性运算。因此，加窗物理信号的DFT与加窗计数信号的DFT相关：\n$$ Y_w[k] = \\text{DFT}\\{y[n]w[n]\\} = \\text{DFT}\\{g \\cdot x[n]w[n]\\} = g \\cdot \\text{DFT}\\{x[n]w[n]\\} = g \\cdot X_w[k] $$\n平方幅值通过 $g^2$ 相关联：\n$$ |Y_w[k]|^2 = g^2 |X_w[k]|^2 $$\n由于PSD与DFT的平方幅值成正比，且两种信号的缩放常数相同（因为缩放仅取决于 $F_s$、$N$ 和 $w[n]$），因此PSD直接通过 $g^2$ 相关联：\n$$ S_{y,1}(f) = g^2 S_{x,1}(f) $$\n这就提供了从单位为 $\\text{counts}^2/\\text{Hz}$ 的PSD到单位为 $\\mu\\text{V}^2/\\text{Hz}$ 的PSD的直接转换。\n\n**第二部分：α波段功率的计算**\n\n特定频带内的功率是通过对该频带上的单边PSD进行积分来求得的。α波段被指定为 $f \\in [8, 12]$ 赫兹。\n$$ P_{\\alpha} = \\int_{8\\,\\text{Hz}}^{12\\,\\text{Hz}} S_{y,1}(f) \\, df $$\n首先，我们将报告的PSD $S_{x,1}(f) = 1.2 \\times 10^3 \\, \\text{counts}^2/\\text{Hz}$ 转换为物理单位。\n$$ S_{y,1}(f) = g^2 S_{x,1}(f) = (0.09 \\, \\mu\\text{V/count})^2 \\times (1.2 \\times 10^3 \\, \\text{counts}^2/\\text{Hz}) $$\n$$ S_{y,1}(f) = (8.1 \\times 10^{-3} \\, \\mu\\text{V}^2/\\text{count}^2) \\times (1.2 \\times 10^3 \\, \\text{counts}^2/\\text{Hz}) $$\n$$ S_{y,1}(f) = 9.72 \\, \\mu\\text{V}^2/\\text{Hz} $$\n问题陈述PSD在α波段上近似平坦。这将积分简化为常数PSD值与区间带宽的乘积。\n带宽为 $\\Delta B = 12\\,\\text{Hz} - 8\\,\\text{Hz} = 4\\,\\text{Hz}$。\n$$ P_{\\alpha} = S_{y,1} \\times \\Delta B = (9.72 \\, \\mu\\text{V}^2/\\text{Hz}) \\times (4 \\, \\text{Hz}) $$\n$$ P_{\\alpha} = 38.88 \\, \\mu\\text{V}^2 $$\n问题要求答案四舍五入到四位有效数字。计算出的值 $38.88$ 已经有四位有效数字。",
            "answer": "$$ \\boxed{38.88} $$"
        },
        {
            "introduction": "神经振荡通常不是持续平稳的，而是以短暂的“爆发”形式出现，这对分析方法提出了挑战。短时傅里叶变换（STFT）是揭示这种时变动态的核心工具，但其效果严重依赖于参数选择。本练习将引导您设计一个STFT分析流程，通过权衡时间分辨率与频谱泄漏，为捕捉特定时长的beta频带爆发事件，从根本上推导出最佳的窗长和步长选择 。",
            "id": "4138622",
            "problem": "您的任务是配置短时傅里叶变换 (STFT)，用于分析神经信号中的 β 频段动态。目标是解析在 $15$ 到 $30$ 赫兹之间的 β 频段中持续时间约 $100$ 毫秒的脉冲，同时平衡时间分辨率和频谱泄漏。您编写的程序必须基于基本定义和经过充分检验的事实来推导窗长和跳跃长度，而不能依赖于问题陈述中提供给您的快捷公式。\n\n定义和假设：\n- 短时傅里叶变换 (STFT) 使用信号的加窗段来计算局部频谱。设采样率为 $f_s$ (单位赫兹)，窗长为 $N$ (单位样本数)，跳跃长度为 $H$ (单位样本数)。\n- 设窗函数为汉宁窗 (Hann window)，它因其平滑的锥形和减小的旁瓣而常用于神经信号时频分析。\n- β 频段定义为 $[f_l, f_h] = [15, 30]$ 赫兹。\n- 目标脉冲持续时间用 $\\tau$ 表示 (单位秒)。\n- 时间分辨率与窗持续时间 $T_w = N / f_s$ (单位秒) 直接相关。\n- 离散傅里叶变换的频率箱宽度为 $\\Delta f = f_s / N$ (单位赫兹)。\n- 对于汉宁窗，其在离散时间傅里叶变换中主瓣在第一零点之间的宽度等于 $4 \\Delta f$ (单位赫兹)，这个主瓣宽度是衡量单音附近频谱泄漏的一个实用代理指标。\n- 窗长和跳跃长度必须以样本数 (无单位的整数计数) 返回。所有持续时间必须以秒为单位指定，所有频率必须以赫兹为单位指定。\n\n设计目标：\n- 通过确保时间分辨率足够精细来解析持续时间为 $\\tau$ 的脉冲，这要求 $T_w$ 不超过 $\\tau$ (即 $N / f_s \\le \\tau$)。\n- 通过将汉宁窗主瓣宽度限制在一个容差 $W_{\\max} = \\alpha (f_h - f_l)$ 内来限制 β 频段的频谱泄漏，其中 $\\alpha$ 被选择为代表 β 频段宽度的可容忍部分。使用 $\\alpha = 0.5$，因此 $W_{\\max} = 0.5 \\times (30 - 15)$ 赫兹。这个界限是一个设计容差，而不是一个严格的物理限制。\n- 构建一个无量纲的凸权衡目标函数，该函数对归一化的时间分辨率惩罚项和归一化的主瓣宽度惩罚项进行同等加权。推导出一个解析的 $N$ 选择，在约束条件 $N \\le f_s \\tau$ 和整数 $N \\ge 4$ (以确保非平凡窗) 下最小化此目标函数。\n- 跳跃长度必须满足两个条件：1) 使用汉宁窗时，保持适合稳定 STFT 分析的重叠率 (使用 $50\\%$ 的重叠，这意味着 $H \\approx N/2$)，2) 在一个脉冲内提供多个分析帧以解析其起始和结束；通过选择 $H \\le f_s \\tau / 4$ 来确保一个脉冲内至少有四个帧。跳跃长度必须是整数且 $H \\ge 1$。\n\n可行性标志：\n- 对于每组参数集，判断时间分辨率约束 $N / f_s \\le \\tau$ 和频谱泄漏约束 $4 f_s / N \\le W_{\\max}$ 是否能同时满足。返回一个布尔标志来指示可行性。\n\n测试套件：\n实现您的程序来处理以下测试参数集，表示为 $(f_s, \\tau)$ 对，其中 $f_s$ 的单位是赫兹，$\\tau$ 的单位是秒：\n1) $(1000, 0.1)$\n2) $(256, 0.1)$\n3) $(1200, 0.6)$\n4) $(500, 0.08)$\n\n输出规格：\n- 对于每个测试用例，计算并返回一个包含三个值的列表 $[N, H, \\text{feasible}]$，其中 $N$ 和 $H$ 是整数 (单位为样本数)，$\\text{feasible}$ 是一个布尔值。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表 (例如, $[[N_1,H_1,\\text{feasible}_1],[N_2,H_2,\\text{feasible}_2],\\dots]$)。\n\n注意：\n- 不允许用户输入；程序必须是自包含的，并直接生成指定的输出。\n- 所有物理量必须以其适当的单位处理：频率用赫兹，持续时间用秒；窗长和跳跃长度必须以样本数返回。\n- 本问题不使用角度。\n- 如果需要，以小数形式表示任何分数量；输出中不要使用百分比。",
            "solution": "我们从关于短时傅里叶变换 (STFT) 和加窗谱分析的第一性原理和经过充分检验的事实出发，设计一个能够平衡 β 频段动态的时间分辨率和频谱泄漏的窗长和跳跃长度。\n\n基本依据：\n1) 短时傅里叶变换 (STFT) 通过将信号 $x[n]$ 与长度为 $N$ 个样本的窗 $w[n]$ 相乘，并在 $H$ 个样本的连续时间移位 (跳跃) 上计算离散时间傅里叶变换来构建局部频谱。时间分辨率由窗持续时间 $T_w = N / f_s$ 决定。\n2) 长度为 $N$ 的段的离散时间傅里叶变换的离散频率箱宽度为 $\\Delta f = f_s / N$。\n3) 对于汉宁窗，一个经过充分检验的特性是其主瓣从第一零点到第一零点的宽度为 $$W(N) = 4 \\Delta f = \\frac{4 f_s}{N}.$$ 这个主瓣宽度可作为频谱泄漏的一个实用代理指标：在加窗频谱中，一个正弦波的功率会在真实频率周围大约这个宽度的频率范围内扩展。\n4) 目标脉冲持续时间为 $\\tau$ 秒；为了在时间上解析此类脉冲，我们需要 $$T_w = \\frac{N}{f_s} \\le \\tau,$$ 这避免了将脉冲模糊到其持续时间之外。\n5) β 频段为 $[f_l, f_h] = [15, 30]$ 赫兹，我们容忍主瓣宽度为该带宽的一部分。设 $$W_{\\max} = \\alpha (f_h - f_l), \\quad \\alpha = 0.5,$$ 因此 $$W_{\\max} = 0.5 \\times (30 - 15) = 7.5 \\text{ 赫兹}.$$\n\n平衡时间分辨率和泄漏：\n我们寻求在时间分辨率和泄漏之间达成一个有原则的折衷。构建一个无量纲的凸成本函数，该函数对归一化的时间持续时间和归一化的主瓣宽度进行同等加权：\n$$J(N) = \\frac{1}{2}\\left(\\frac{T_w}{\\tau} + \\frac{W(N)}{W_{\\max}}\\right) = \\frac{1}{2}\\left(\\frac{N}{f_s \\tau} + \\frac{4 f_s}{N W_{\\max}}\\right).$$\n函数 $J(N)$ 对于 $N > 0$ 是凸的，因为它是关于 $N$ 的线性项和与 $1/N$ 成正比的项之和。对 $J(N)$ 关于 $N$ 进行最小化可以得到一个解析解。对 $N$ 求导并令其为零：\n$$\\frac{dJ}{dN} = \\frac{1}{2}\\left(\\frac{1}{f_s \\tau} - \\frac{4 f_s}{W_{\\max} N^2}\\right) = 0.$$\n求解得到：\n$$\\frac{1}{f_s \\tau} = \\frac{4 f_s}{W_{\\max} N^2} \\quad \\Rightarrow \\quad N^2 = \\frac{4 f_s^2 \\tau}{W_{\\max}} \\quad \\Rightarrow \\quad N^\\star = f_s \\sqrt{\\frac{4 \\tau}{W_{\\max}}}.$$\n这个 $N^\\star$ 平衡了归一化的时间分辨率和泄漏惩罚项。\n\n约束和整数性：\n- 我们必须强制执行时间分辨率约束 $N \\le f_s \\tau$，以使 $T_w \\le \\tau$。定义上界 $$N_{\\text{time}} = \\left\\lfloor f_s \\tau \\right\\rfloor.$$\n- 为强制执行泄漏容差界限 $W(N) \\le W_{\\max}$，我们需要 $$\\frac{4 f_s}{N} \\le W_{\\max} \\quad \\Rightarrow \\quad N \\ge \\frac{4 f_s}{W_{\\max}}.$$ 定义频率泄漏下界 $$N_{\\text{freq}} = \\left\\lceil \\frac{4 f_s}{W_{\\max}} \\right\\rceil.$$\n- 解析最小化器 $N^\\star$ 必须与这些界限和整数性要求协调一致。一个平衡且可行的整数选择是\n$$N = \n\\begin{cases}\n\\min\\left(\\max\\left(\\left\\lfloor N^\\star \\right\\rceil, N_{\\text{freq}}\\right), N_{\\text{time}}\\right),  \\text{如果 } N_{\\text{freq}} \\le N_{\\text{time}},\\\\\nN_{\\text{time}},  \\text{如果 } N_{\\text{freq}} > N_{\\text{time}} \\text{ (优先考虑时间分辨率，未满足泄漏容差)}.\n\\end{cases}$$\n这里 $\\lfloor \\cdot \\rceil$ 表示四舍五入到最近的整数。我们还强制要求最小窗长为 $N \\ge 4$ 以避免退化窗。\n\n可行性标志：\n我们设置一个布尔可行性指示器\n$$\\text{feasible} = \\left( \\frac{N}{f_s} \\le \\tau \\right) \\land \\left( \\frac{4 f_s}{N} \\le W_{\\max} \\right) \\equiv \\left( N \\le N_{\\text{time}} \\right) \\land \\left( N \\ge N_{\\text{freq}} \\right).$$\n\n跳跃长度选择：\n两个原则性条件指导跳跃长度 $H$ 的选择：\n1) 对于汉宁窗，$50\\%$ 的重叠可确保在标准的 STFT 重叠相加法中实现稳定的幅度估计和完美重构，这表明 $H \\approx N/2$。设 $$H_{\\text{ola}} = \\left\\lfloor \\frac{N}{2} \\right\\rfloor.$$\n2) 为了在一个脉冲的持续时间内用多个分析帧来解析它，要求每个脉冲至少有四个帧，得出 $$H \\le \\frac{f_s \\tau}{4} \\quad \\Rightarrow \\quad H_{\\text{burst}} = \\left\\lfloor \\frac{f_s \\tau}{4} \\right\\rfloor.$$\n我们选择\n$$H = \\max\\left(1, \\min\\left( H_{\\text{ola}}, H_{\\text{burst}} \\right)\\right).$$\n这强制了整数跳跃长度，并防止在极低持续时间的情况下出现 $H=0$。\n\n算法总结：\n给定 $(f_s, \\tau)$ 和固定的 $[f_l, f_h] = [15,30]$ 赫兹，其中 $\\alpha = 0.5$，计算：\n- $W_{\\max} = \\alpha (f_h - f_l)$，\n- $N^\\star = f_s \\sqrt{4 \\tau / W_{\\max}}$，\n- $N_{\\text{time}} = \\lfloor f_s \\tau \\rfloor$，\n- $N_{\\text{freq}} = \\lceil 4 f_s / W_{\\max} \\rceil$，\n- 根据上述选择规则计算 $N$ (要求 $N \\ge 4$)，\n- $H = \\max(1, \\min(\\lfloor N/2 \\rfloor, \\lfloor f_s \\tau / 4 \\rfloor))$，\n- $\\text{feasible} = (N \\le N_{\\text{time}}) \\land (N \\ge N_{\\text{freq}})$。\n\n这个有原则的设计在现实约束下平衡了时间分辨率和频谱泄漏。在典型的神经生理学采样率和短脉冲持续时间（例如，$\\tau \\approx 0.1$ 秒）下，泄漏容差 $W_{\\max} = 7.5$ 赫兹通常无法与 $T_w \\le \\tau$ 同时满足，这在这些情况下通过可行性标志为 false 来反映。较大的 $\\tau$ 值可以使约束条件同时变得可行。\n\n程序为测试套件实现了此逻辑：\n1) $(f_s,\\tau) = (1000, 0.1)$,\n2) $(256, 0.1)$,\n3) $(1200, 0.6)$,\n4) $(500, 0.08)$,\n并为每个案例以单行列表格式输出 $[N, H, \\text{feasible}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef configure_stft(fs, tau, f_l=15.0, f_h=30.0, alpha=0.5):\n    \"\"\"\n    Configure STFT window length N and hop size H for beta-band analysis.\n    Parameters:\n        fs (float): Sampling rate in Hz.\n        tau (float): Target burst duration in seconds.\n        f_l (float): Lower bound of beta band (Hz).\n        f_h (float): Upper bound of beta band (Hz).\n        alpha (float): Fraction of band width tolerated for main-lobe width.\n    Returns:\n        (N, H, feasible): window length (samples), hop size (samples), feasibility boolean.\n    \"\"\"\n    # Tolerable main-lobe width (Hz)\n    W_max = alpha * (f_h - f_l)\n\n    # Analytic minimizer from balancing normalized time and leakage terms\n    N_star_cont = fs * np.sqrt((4.0 * tau) / W_max)\n\n    # Bounds from constraints\n    N_time_max = int(np.floor(fs * tau))\n    N_freq_min = int(np.ceil((4.0 * fs) / W_max))\n\n    # Round N_star to nearest integer\n    N_star = int(np.round(N_star_cont))\n\n    # Select N under constraints; prioritize time resolution if infeasible\n    if N_freq_min = N_time_max:\n        N = max(N_star, N_freq_min)\n        N = min(N, N_time_max)\n    else:\n        # Constraints cannot be simultaneously satisfied; prioritize time resolution\n        N = N_time_max\n\n    # Ensure minimum N\n    N = max(N, 4)\n\n    # Hop size: 50% overlap and at least four frames per burst\n    H_ola = N // 2\n    H_burst = int(np.floor(fs * tau / 4.0))\n    # Ensure H >= 1\n    H = max(1, min(H_ola, H_burst))\n\n    # Feasibility flag: both constraints satisfied\n    feasible = (N = N_time_max) and (N >= N_freq_min)\n\n    return int(N), int(H), bool(feasible)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (fs in Hz, tau in seconds)\n    test_cases = [\n        (1000.0, 0.1),\n        (256.0, 0.1),\n        (1200.0, 0.6),\n        (500.0, 0.08),\n    ]\n\n    results = []\n    for fs, tau in test_cases:\n        N, H, feasible = configure_stft(fs, tau)\n        results.append([N, H, feasible])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的神经电生理记录不可避免地会受到各种伪影（如肌肉活动、眼动）的污染，这些伪影可能掩盖或模仿真实的神经信号。独立成分分析（ICA）是一种强大的盲源分离技术，能够有效地识别并去除这些伪影。本练习将带您完成一个完整的端到端工作流程：从合成包含神经振荡和伪影的多通道数据开始，到应用ICA进行伪影去除，并最终验证该过程在有效滤除噪声的同时，是否成功保留了我们感兴趣的神经信号 。",
            "id": "4138598",
            "problem": "您的任务是构建一个完整指定的程序，该程序能够合成包含神经振荡和肌肉伪影的多通道神经电生理记录，通过独立成分分析 (ICA) 识别抬高的宽带高频功率成分，移除这些成分，并验证神经振荡在清洗后是否被保留。该程序必须基于信号处理和统计建模中的基本原理和标准定义。\n\n基本原理和定义：\n\n- 假设多通道记录采用线性瞬时混合模型。令 $s(t) \\in \\mathbb{R}^{n_s}$ 表示 $n_s$ 个源过程，令 $x(t) \\in \\mathbb{R}^{n_c}$ 表示 $n_c$ 个观测通道。模型为\n$$\nx(t) = A s(t) + \\epsilon(t),\n$$\n其中 $A \\in \\mathbb{R}^{n_c \\times n_s}$ 是一个满列秩混合矩阵，$\\epsilon(t)$ 是加性传感器噪声。观测值以赫兹 (Hz) 为单位的采样频率 $f_s$ 进行采样，产生 $N$ 个样本，时间索引为 $t_k = k/f_s$，其中 $k \\in \\{0,1,\\dots,N-1\\}$。\n\n- 平稳过程 $x(t)$ 的功率谱密度 (PSD) $S_{xx}(f)$，根据持续时间 $T$ 内的傅里叶变换 $X_T(f)$ 定义为\n$$\nS_{xx}(f) = \\lim_{T \\to \\infty} \\frac{\\mathbb{E}\\left[|X_T(f)|^2\\right]}{T}。\n$$\n在频率带 $B=[f_l,f_h]$ 内的频带功率 $P_{B}$ 为\n$$\nP_{B} = \\int_{f_l}^{f_h} S_{xx}(f) \\, df。\n$$\n在数值实践中，您将使用 Welch 方法来近似 $S_{xx}(f)$，并通过分辨率为 $\\Delta f$ 的黎曼和来近似该积分。\n\n- 独立成分分析 (ICA) 假设源是统计独立且非高斯的。在中心化和白化之后，ICA 识别一个解混矩阵 $W$，使得\n$$\nS = W X_{\\text{white}},\n$$\n其中 $S$ 近似于独立源。白化使用协方差矩阵的特征分解。非高斯性通过一个对比函数（例如，双曲正切非线性）来操作化，并通过带有正交化的不动点迭代来求解。移除已识别的伪影成分是通过将 $S$ 中的那些成分置零，并使用 ICA 和白化的逆运算反向投影回传感器空间来实现的。\n\n场景：\n\n- 合成 $n_s = 4$ 个源：一个频率为 $f_{\\alpha} = 10$ Hz 的神经振荡，一个或两个建模为高频带 $[f_{m1,l}, f_{m1,h}]$ 和可选的 $[f_{m2,l}, f_{m2,h}]$ 内的限带宽带噪声的肌肉伪影，一个类 $1/f$ 背景噪声过程，以及一个接近 $f_o = 1$ Hz 的低频类眼动伪影。通过一个固定的随机混合矩阵 $A$ 将这些源混合到 $n_c = 8$ 个通道中，并添加微小的传感器噪声。使用 $f_s = 512$ Hz 和持续时间 $T = 10$ s，因此有 $N = T \\cdot f_s$ 个样本。所有振幅量的单位均为微伏。\n\n- 使用基于以下分数的决策准则来识别具有抬高的宽带高频功率的独立成分：\n$$\nr_i = \\frac{P_{HF,i}}{P_{\\text{tot},i}},\n$$\n其中 $P_{HF,i}$ 是成分 $i$ 在高频带 $[70,100]$ Hz 内的频带功率，而 $P_{\\text{tot},i}$ 是在 $[1,150]$ Hz 内的总频带功率。$r_i$ 超过固定阈值的成分应被标记为肌肉伪影。通过将其时间进程设置为零来移除它们，并重建清洗后的通道信号。\n\n- 验证：对每个通道，计算清洗前后的高频频带功率（在 $[70,100]$ Hz 内），以获得跨通道的平均分数下降\n$$\nR = \\frac{\\overline{P_{HF}^{\\text{pre}}} - \\overline{P_{HF}^{\\text{post}}}}{\\overline{P_{HF}^{\\text{pre}}}},\n$$\n并计算 alpha 频带 $[8,12]$ Hz 内跨通道的平均相对变化\n$$\n\\Delta_{\\alpha} = \\left|\\frac{\\overline{P_{\\alpha}^{\\text{post}}} - \\overline{P_{\\alpha}^{\\text{pre}}}}{\\overline{P_{\\alpha}^{\\text{pre}}}}\\right|。\n$$\n如果一个测试用例满足 $R \\geq 0.3$ 且 $\\Delta_{\\alpha} \\leq 0.1$，则宣布成功。任何相位计算的角度单位是弧度；频率单位是赫兹；时间单位是秒；振幅单位是微伏。最终输出是每个测试用例的布尔值，没有单位。\n\n实现要求：\n\n- 实现中心化、通过协方差矩阵的特征分解进行白化，以及一个带有双曲正切非线性的降维不动点 ICA。使用 Welch 方法计算 PSD 和频带功率。通过对白噪声进行带通滤波，将其滤波到指定的高频带，来建模肌肉伪影。\n\n- 仅使用 Python 语言和最终答案要求中指定的库。在需要时通过适当的正则化确保数值稳定性。\n\n测试套件：\n\n提供一个程序，运行以下四个测试参数集，每个参数集指定为一个元组 $(\\text{seed}, A_{\\alpha}, A_{m1}, A_{m2}, A_{\\text{bg}})$，其中 $A_{\\alpha}$ 是 alpha 振荡的振幅， $A_{m1}$ 和 $A_{m2}$ 是一个或两个肌肉伪影的振幅， $A_{\\text{bg}}$ 是 $1/f$ 背景的振幅，所有单位均为微伏：\n\n- 案例 1：$(0, 20, 0, 0, 5)$，无肌肉伪影；边缘案例测试，在无移除情况下的保留情况。\n- 案例 2：$(1, 20, 10, 0, 5)$，轻度肌肉伪影；理想路径的检测和移除。\n- 案例 3：$(2, 25, 25, 15, 7)$，强烈的双重肌肉伪影；需要显著移除。\n- 案例 4：$(3, 15, 5, 0, 10)$，具有较高背景的临界伪影；测试阈值行为。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$），其中每个 $\\text{result}$ 是一个布尔值，指示对于相应的测试用例，伪影移除是否成功同时保留了神经振荡。",
            "solution": "问题陈述被评估为有效。它具有科学依据、提法明确且客观，描述了计算神经科学中的一项标准任务：多通道神经电生理数据的仿真和清洗。模型、定义和所提出的方法——包括线性混合模型、通过 Welch 方法进行功率谱密度 (PSD) 估计，以及使用独立成分分析 (ICA) 进行伪影移除——都基于信号处理和统计建模中的既定原则。该问题为实现和验证提供了清晰的量化框架。一些次要的模糊之处，例如伪影识别阈值的精确值，可以通过合理且明确说明的假设来解决，并且不会损害问题的完整性。我们将继续提供完整的解决方案。\n\n该解决方案分三个主要阶段实现：信号合成、基于 ICA 的伪影移除和量化验证。\n\n**1. 多通道数据的合成**\n\n合成数据是基于线性瞬时混合模型生成的：\n$$x(t) = A s(t) + \\epsilon(t)$$\n其中 $s(t) \\in \\mathbb{R}^{n_s}$ 表示 $n_s=4$ 个源信号， $x(t) \\in \\mathbb{R}^{n_c}$ 表示 $n_c=8$ 个观测通道信号， $A \\in \\mathbb{R}^{n_c \\times n_s}$ 是一个随机、满列秩的混合矩阵，而 $\\epsilon(t)$ 是加性高斯传感器噪声。信号在 $T=10$ 秒的持续时间内以 $f_s=512$ Hz 的采样率生成，产生 $N=T \\cdot f_s = 5120$ 个样本。时间向量为 $t_k = k/f_s$，其中 $k \\in \\{0, 1, \\dots, N-1\\}$。\n\n四个源信号 $s(t)$ 的构建如下，以模拟不同的神经生理和伪影活动：\n- **神经振荡：** 一个代表 alpha 频带节律的纯正弦信号，定义为 $s_{0}(t) = A_{\\alpha} \\sin(2\\pi f_{\\alpha} t + \\phi)$，频率为 $f_{\\alpha}=10$ Hz，振幅 $A_{\\alpha}$ 由测试用例指定。相位 $\\phi$ 是随机选择的。\n- **肌肉伪影：** 这些被建模为限带高频噪声。生成高斯白噪声，然后进行带通滤波。在本实现中，使用了一个四阶巴特沃斯滤波器。肌肉源 1 占据频率带 $[70, 100]$ Hz。如果指定了第二个肌肉源（$A_{m2}  0$），它将占据频带 $[80, 110]$ Hz。振幅分别为 $A_{m1}$ 和 $A_{m2}$。\n- **眼动伪影：** 当 $A_{m2}=0$ 时，使用这个低频伪影代替第二个肌肉源。它被建模为经过低通滤波的高斯白噪声，截止频率为 $2$ Hz，以模拟缓慢的眼球运动或眨眼。使用一个固定的振幅。\n- **1/f 背景大脑活动：** 该源模拟了背景大脑噪声的无标度特性。它通过在频域中生成一个复值白噪声信号，将每个频率分量 $f$ 的振幅按 $1/\\sqrt{f}$ 进行缩放，然后通过快速傅里叶逆变换 (iFFT) 转换回时域来合成。强制执行埃尔米特对称性以确保得到实值时间信号。振幅由 $A_{\\text{bg}}$ 给出。\n\n这四个源被组合成一个源矩阵 $S \\in \\mathbb{R}^{4 \\times N}$。一个固定的随机混合矩阵 $A \\in \\mathbb{R}^{8 \\times 4}$ 被生成一次，并用于所有测试用例以确保一致性。混合后的信号 $X = AS$ 随后被每个通道上的微弱、独立的高斯噪声污染，形成最终的观测数据 $X_{\\text{obs}}$。\n\n**2. 伪影识别和移除**\n\n伪影移除使用 ICA 进行，其目的是找到一个线性变换，将混合信号分离成统计独立的成分。\n\n- **预处理（中心化和白化）：** 首先，通过从每个通道减去均值来对数据进行中心化：$X_c = X_{\\text{obs}} - \\mathbb{E}[X_{\\text{obs}}]$。其次，对数据进行白化。这是通过主成分分析 (PCA) 实现的。计算协方差矩阵 $C_X = \\text{cov}(X_c)$ 并找到其特征分解 $C_X = E D E^T$。白化变换将中心化后的数据投影到 $n_s=4$ 个主特征向量上，并按相应特征值的负二分之一方根对结果进行缩放。白化矩阵为 $M_{white} = D_{1:n_s}^{-1/2} E_{1:n_s}^T$，其中 $E_{1:n_s}$ 包含特征向量，$D_{1:n_s}$ 是特征值的对角矩阵。向特征值添加一个小的正则化项以确保数值稳定性。白化后的数据为 $X_w = M_{white} X_c$。\n\n- **FastICA 算法：** 使用降维不动点算法来寻找解混矩阵 $W_{ICA} \\in \\mathbb{R}^{n_s \\times n_s}$。该算法迭代地估计向量 $w_i$（$W_{ICA}$ 的行），以最大化投影数据 $w_i^T X_w$ 的非高斯性。向量 $w$ 的更新规则基于一个对比函数，在此例中为 $g(u) = \\tanh(u)$：\n    $$w^{+} \\leftarrow \\mathbb{E}[X_w g(w^T X_w)] - \\mathbb{E}[g'(w^T X_w)]w$$\n    每次更新后，向量 $w^{+}$ 与先前找到的向量进行去相关处理并进行归一化。此过程重复进行，直到所有 $n_s$ 个成分向量都被估计出来。最终估计的源是 $S_{est} = W_{ICA} X_w$。\n\n- **伪影成分识别：** 对 $S_{est}$ 中的每个估计源成分在频域中进行分析。使用 Welch 方法计算其 PSD。识别肌肉伪影的标准是其在高频带的功率与总功率的比率 $r_i$：\n    $$r_i = \\frac{P_{HF,i}}{P_{\\text{tot},i}} = \\frac{\\int_{70 \\text{Hz}}^{100 \\text{Hz}} S_{ii}(f) \\, df}{\\int_{1 \\text{Hz}}^{150 \\text{Hz}} S_{ii}(f) \\, df}$$\n    如果 $r_i  0.3$，则一个成分 $i$ 被分类为伪影。这个阈值假设肌肉活动在高频范围内贡献了其功率的很大一部分。\n\n- **信号重建：** 将 $S_{est}$ 中已识别的伪影成分的时间序列设置为零，得到一个清洗后的源矩阵 $S_{clean}$。为了在传感器空间中重建信号，需要对整个解混变换求逆。完整的解混矩阵是 $W_{unmix} = W_{ICA} M_{white}$。估计的混合矩阵是其 Moore-Penrose 伪逆，$A_{est} = W_{unmix}^{\\dagger}$。然后通过混合清洗后的源来重建清洗后的通道数据，$X_{c, \\text{clean}} = A_{est} S_{clean}$，并加回通道均值：$X_{\\text{clean}} = X_{c, \\text{clean}} + \\mathbb{E}[X_{\\text{obs}}]$。\n\n**3. 清洗性能验证**\n\n该过程的成功与否根据问题中指定的两个标准进行评估。频带功率的计算是使用 Welch 方法得到的 PSD 进行的，积分通过黎曼和近似。\n\n- **高频伪影减少 ($R$)：** 该指标量化了 $[70, 100]$ Hz 频带内伪影功率的移除程度。计算每个通道在清洗前（$P_{HF,j}^{\\text{pre}}$）和清洗后（$P_{HF,j}^{\\text{post}}$）的频带功率。该指标是跨通道平均的分数下降：\n    $$R = \\frac{\\overline{P_{HF}^{\\text{pre}}} - \\overline{P_{HF}^{\\text{post}}}}{\\overline{P_{HF}^{\\text{pre}}}}$$\n- **Alpha 频带振荡保留 ($\\Delta_{\\alpha}$):** 该指标量化了在 alpha 频带 $[8, 12]$ Hz 内感兴趣的神经信号的保留程度。它是平均 alpha 频带功率的绝对相对变化：\n    $$\\Delta_{\\alpha} = \\left|\\frac{\\overline{P_{\\alpha}^{\\text{post}}} - \\overline{P_{\\alpha}^{\\text{pre}}}}{\\overline{P_{\\alpha}^{\\text{pre}}}}\\right|$$\n\n一个测试用例当且仅当两个条件都满足时被认为是成功的：$R \\geq 0.3$ 和 $\\Delta_{\\alpha} \\leq 0.1$。根据这个严格的规则，第一个测试用例（没有肌肉伪影）预计会失败，因为 $R$ 将接近于零。",
            "answer": "```python\nimport numpy as np\nfrom scipy import signal\n\ndef bandpass_filter(data, lowcut, highcut, fs, order=4):\n    \"\"\"Applies a band-pass Butterworth filter to data.\"\"\"\n    nyq = 0.5 * fs\n    low = lowcut / nyq\n    high = highcut / nyq\n    b, a = signal.butter(order, [low, high], btype='band')\n    y = signal.filtfilt(b, a, data)\n    return y\n\ndef lowpass_filter(data, cutoff, fs, order=4):\n    \"\"\"Applies a low-pass Butterworth filter to data.\"\"\"\n    nyq = 0.5 * fs\n    normal_cutoff = cutoff / nyq\n    b, a = signal.butter(order, normal_cutoff, btype='low', analog=False)\n    y = signal.filtfilt(b, a, data)\n    return y\n\ndef generate_pink_noise(N, rng, amplitude=1.0, beta=1.0):\n    \"\"\"Generates pink (1/f) noise.\"\"\"\n    freqs = np.fft.rfftfreq(N)\n    # Generate complex noise with Hermitian symmetry\n    noise_fft = rng.standard_normal(len(freqs)) + 1j * rng.standard_normal(len(freqs))\n    noise_fft[0] = 0  # No DC component\n    \n    # Scale amplitudes by 1/f^beta\n    with np.errstate(divide='ignore'):\n        scaling = 1.0 / (freqs**(beta/2.0))\n    scaling[0] = 0\n    noise_fft *= scaling\n    \n    # Ensure Hermitian symmetry for real output\n    if N % 2 == 0:\n        noise_fft[-1] = np.conj(noise_fft[-1])\n\n    y = np.fft.irfft(noise_fft, n=N)\n    y /= np.std(y) # Normalize to std=1\n    return y * amplitude\n\ndef synthesize_data(case_params, fs, T, n_c, rng_mix):\n    \"\"\"Synthesizes multichannel data based on the problem specification.\"\"\"\n    seed, A_alpha, A_m1, A_m2, A_bg = case_params\n    N = int(fs * T)\n    t = np.arange(N) / fs\n    rng = np.random.default_rng(seed)\n\n    # 1. Alpha oscillation\n    phi_alpha = rng.uniform(0, 2 * np.pi)\n    s_alpha = A_alpha * np.sin(2 * np.pi * 10 * t + phi_alpha)\n\n    # 2. Muscle artifacts\n    s_m1 = np.zeros(N) # Initialize as zero\n    if A_m1 > 0:\n        noise_m1 = rng.standard_normal(N)\n        s_m1_filtered = bandpass_filter(noise_m1, 70, 100, fs)\n        s_m1 = (s_m1_filtered / np.std(s_m1_filtered)) * A_m1\n\n    # 3. Muscle artifact 2 OR Ocular artifact\n    if A_m2 > 0:\n        noise_m2 = rng.standard_normal(N)\n        s_m2_filtered = bandpass_filter(noise_m2, 80, 110, fs)\n        s_alternate = (s_m2_filtered / np.std(s_m2_filtered)) * A_m2\n    else:\n        # Ocular artifact\n        A_ocular = 50.0  # Ocular artifacts have large amplitude\n        noise_ocular = rng.standard_normal(N)\n        s_ocular_filtered = lowpass_filter(noise_ocular, 2, fs)\n        s_alternate = (s_ocular_filtered / np.std(s_ocular_filtered)) * A_ocular\n\n    # 4. 1/f background noise\n    s_bg = generate_pink_noise(N, rng, amplitude=A_bg, beta=1.0)\n    \n    sources = np.vstack([s_alpha, s_m1, s_alternate, s_bg])\n    n_s = sources.shape[0]\n\n    # 5. Mixing\n    A = rng_mix.standard_normal((n_c, n_s))\n    x_mixed = A @ sources\n\n    # 6. Sensor noise\n    sensor_noise_amp = 1.0\n    noise = rng.standard_normal(x_mixed.shape) * sensor_noise_amp\n    x_obs = x_mixed + noise\n\n    return x_obs\n\ndef calculate_bandpower(data, fs, band, nperseg=512):\n    \"\"\"Calculates power in a frequency band using Welch's method.\"\"\"\n    freqs, psd = signal.welch(data, fs, nperseg=nperseg)\n    freq_res = freqs[1] - freqs[0]\n    band_idx = np.where((freqs >= band[0])  (freqs = band[1]))[0]\n    if len(band_idx) == 0:\n        return 0.0\n    band_power = np.sum(psd[band_idx]) * freq_res\n    return band_power\n\ndef fast_ica(X, n_components, max_iter=200, tol=1e-6, rng=None):\n    \"\"\"Performs FastICA using deflation and tanh contrast.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    \n    n_features, n_samples = X.shape\n    W = np.zeros((n_components, n_components))\n\n    for i in range(n_components):\n        w = rng.standard_normal(n_components)\n        w /= np.linalg.norm(w)\n        \n        for _ in range(max_iter):\n            w_T_X = w.T @ X\n            g_w_T_X = np.tanh(w_T_X)\n            g_prime_w_T_X = 1 - g_w_T_X**2\n            \n            w_new = np.mean(X * g_w_T_X, axis=1) - np.mean(g_prime_w_T_X) * w\n            \n            # Decorrelate with previous components\n            w_new -= W[:i, :].T @ (W[:i, :] @ w_new)\n            w_new /= np.linalg.norm(w_new)\n            \n            # Check for convergence\n            if np.abs(np.abs(w_new @ w) - 1)  tol:\n                break\n            w = w_new\n        W[i, :] = w\n        \n    return W\n\ndef ica_clean(x_obs, n_components=4):\n    \"\"\"Applies ICA, identifies and removes artifacts, and reconstructs the signal.\"\"\"\n    n_channels, n_samples = x_obs.shape\n    fs = 512.0\n    \n    # 1. Centering\n    x_mean = np.mean(x_obs, axis=1, keepdims=True)\n    x_centered = x_obs - x_mean\n    \n    # 2. Whitening via PCA\n    cov = np.cov(x_centered)\n    eig_vals, eig_vecs = np.linalg.eigh(cov)\n    \n    # Sort in descending order\n    idx = np.argsort(eig_vals)[::-1]\n    eig_vals = eig_vals[idx]\n    eig_vecs = eig_vecs[:, idx]\n\n    # Select top n_components\n    W_pca = eig_vecs[:, :n_components]\n    D_sqrt_inv = np.diag(1.0 / np.sqrt(eig_vals[:n_components] + 1e-12))\n    \n    # Whitening matrix and whitened data\n    whitening_matrix = D_sqrt_inv @ W_pca.T\n    x_whitened = whitening_matrix @ x_centered\n\n    # 3. FastICA\n    W_ica = fast_ica(x_whitened, n_components)\n    s_est = W_ica @ x_whitened\n    \n    # 4. Identify artifact components\n    artifact_indices = []\n    hf_band = [70, 100]\n    total_band = [1, 150]\n    ratio_threshold = 0.3\n    \n    for i in range(n_components):\n        p_hf = calculate_bandpower(s_est[i, :], fs, hf_band)\n        p_total = calculate_bandpower(s_est[i, :], fs, total_band)\n        if p_total > 1e-9: # Avoid division by zero\n            ratio = p_hf / p_total\n            if ratio > ratio_threshold:\n                artifact_indices.append(i)\n\n    # 5. Remove artifacts and reconstruct\n    s_clean = s_est.copy()\n    s_clean[artifact_indices, :] = 0.0\n    \n    # Reconstruct signal\n    full_unmixing_matrix = W_ica @ whitening_matrix\n    # Estimated mixing matrix is the pseudo-inverse\n    A_est = np.linalg.pinv(full_unmixing_matrix)\n    x_c_clean = A_est @ s_clean\n    \n    # 6. Add mean back\n    x_clean = x_c_clean + x_mean\n    \n    return x_clean\n\ndef verify(x_pre, x_post, fs):\n    \"\"\"Verifies cleaning performance against the specified criteria.\"\"\"\n    n_channels = x_pre.shape[0]\n    hf_band = [70, 100]\n    alpha_band = [8, 12]\n    \n    p_hf_pre_list, p_hf_post_list = [], []\n    p_alpha_pre_list, p_alpha_post_list = [], []\n    \n    for i in range(n_channels):\n        p_hf_pre_list.append(calculate_bandpower(x_pre[i, :], fs, hf_band))\n        p_hf_post_list.append(calculate_bandpower(x_post[i, :], fs, hf_band))\n        p_alpha_pre_list.append(calculate_bandpower(x_pre[i, :], fs, alpha_band))\n        p_alpha_post_list.append(calculate_bandpower(x_post[i, :], fs, alpha_band))\n\n    avg_p_hf_pre = np.mean(p_hf_pre_list)\n    avg_p_hf_post = np.mean(p_hf_post_list)\n    avg_p_alpha_pre = np.mean(p_alpha_pre_list)\n    avg_p_alpha_post = np.mean(p_alpha_post_list)\n\n    if avg_p_hf_pre  1e-9:\n        R = 0.0\n    else:\n        R = (avg_p_hf_pre - avg_p_hf_post) / avg_p_hf_pre\n        \n    if avg_p_alpha_pre  1e-9:\n        delta_alpha = 0.0\n    else:\n        delta_alpha = np.abs(avg_p_alpha_post - avg_p_alpha_pre) / avg_p_alpha_pre\n        \n    success = R >= 0.3 and delta_alpha = 0.1\n    return success\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        (0, 20, 0, 0, 5),   # Case 1: No muscle artifact\n        (1, 20, 10, 0, 5),  # Case 2: Mild muscle artifact\n        (2, 25, 25, 15, 7), # Case 3: Strong dual muscle artifacts\n        (3, 15, 5, 0, 10)    # Case 4: Borderline artifact\n    ]\n\n    fs = 512.0\n    T = 10.0\n    n_c = 8\n    \n    # A fixed random mixing matrix for all cases\n    rng_mix = np.random.default_rng(42)\n\n    results = []\n    for case in test_cases:\n        # 1. Synthesize data\n        x_obs = synthesize_data(case, fs, T, n_c, rng_mix)\n        \n        # 2. Clean data using ICA\n        x_clean = ica_clean(x_obs, n_components=4)\n        \n        # 3. Verify the result\n        success = verify(x_obs, x_clean, fs)\n        results.append(success)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}