{
    "hands_on_practices": [
        {
            "introduction": "Before we can analyze neural oscillations, we must understand precisely what a Power Spectral Density (PSD) represents. This first practice grounds the abstract mathematics of the Fourier Transform in the physical reality of measurement, guiding you through the essential process of converting raw instrument data into a properly scaled PSD with meaningful physical units like $\\mu V^2/Hz$. Mastering this fundamental conversion  is a critical first step for ensuring your spectral estimates are accurate and comparable across different experiments or datasets.",
            "id": "4138609",
            "problem": "An Electroencephalography (EEG) channel is digitized to integer counts, denoted by $x[n]$, with a sampling frequency $F_s = 512$ Hz. A single $N = 4096$-sample segment ($8$ seconds) is analyzed using a Hann window $w[n]$ applied prior to a Discrete Fourier Transform (DFT), producing a one-sided Power Spectral Density (PSD) estimate. The instrument reports the one-sided PSD of the raw counts as $S_{x,1}(f)$ in units of counts$^{2}$/Hz. In the alpha band from $8$ Hz to $12$ Hz, the reported PSD is approximately flat at the level $S_{x,1}(f) = 1.2 \\times 10^{3}$ counts$^{2}$/Hz.\n\nThe analog front end is calibrated such that each count corresponds to $g = 0.09$ $\\mu$V/count, so the physical EEG signal is $y[n] = g\\,x[n]$ in $\\mu$V. You may assume the instrument’s PSD computation uses a standard energy-conserving periodogram with proper window power normalization and one-sided conversion.\n\nStarting from the fundamental definitions of the DFT, Parseval’s theorem, and the notion that integrating a power spectral density over frequency yields signal power (variance), do the following:\n\n- Derive the unit-consistent scaling that produces a PSD in $\\mu$V$^{2}$/Hz from the windowed DFT of $y[n]$, explicitly identifying the window power factor in your reasoning, and explain how to convert the reported counts$^{2}$/Hz PSD to $\\mu$V$^{2}$/Hz using the calibration $g$.\n- Using the derived unit conversion and the principle that integrating a PSD over a frequency band yields the band power, compute the alpha-band power by integrating $S_{y,1}(f)$ over $f \\in [8, 12]$ Hz.\n\nExpress the final band power in $\\mu$V$^{2}$ and round your answer to four significant figures.",
            "solution": "The problem statement is evaluated to be valid. All provided data and conditions are scientifically grounded, consistent, and sufficient for a unique solution. The problem is well-posed and objective, framed within standard digital signal processing (DSP) practices for analyzing neurophysiological data like EEG.\n\nThe problem requires two main steps: first, to derive the scaling factor for converting a windowed Discrete Fourier Transform (DFT) into a one-sided Power Spectral Density (PSD) in physical units, and explain the conversion from the instrument-reported PSD to the physical PSD; second, to calculate the power in the alpha frequency band.\n\n**Part 1: Derivation of PSD Scaling and Unit Conversion**\n\nLet the discrete-time EEG signal in physical units be $y[n]$, with units of $\\mu$V. The signal is sampled at a frequency $F_s$ and a segment of $N$ samples is analyzed. The analysis involves applying a window function, $w[n]$, to the signal segment, yielding the windowed signal $y_w[n] = y[n]w[n]$.\n\nThe DFT of the windowed signal is given by:\n$$ Y_w[k] = \\sum_{n=0}^{N-1} y_w[n] \\exp\\left(-j \\frac{2\\pi nk}{N}\\right) $$\nThe units of $Y_w[k]$ are $\\mu$V, as $w[n]$ is dimensionless.\n\nThe total power of a signal is equivalent to its variance, $\\sigma_y^2$. A fundamental principle of PSD analysis is that the total power of a signal is the integral of its two-sided PSD, $S_{y,2}(f)$, over all frequencies:\n$$ P_{\\text{total}} = \\sigma_y^2 = \\int_{-F_s/2}^{F_s/2} S_{y,2}(f) \\, df $$\nIn the discrete domain, this integral is approximated by a sum over the DFT frequency bins:\n$$ P_{\\text{total}} \\approx \\sum_{k=0}^{N-1} S_{y,2}[k] \\Delta f $$\nwhere $\\Delta f = F_s/N$ is the frequency resolution of the DFT.\n\nThe periodogram is a common estimator of the PSD. For a windowed signal, the PSD estimator must be scaled to conserve power. The appropriate scaling factor accounts for the sampling frequency and the power of the window function. The two-sided PSD estimate, $S_{y,2}[k]$, at frequency bin $k$ is defined as:\n$$ S_{y,2}[k] = \\frac{1}{F_s S_2} |Y_w[k]|^2 $$\nwhere $S_2 = \\sum_{n=0}^{N-1} w[n]^2$ is the sum of the squares of the window coefficients, which we identify as the **window power factor**. This factor ensures that the total power estimated from the PSD matches the power estimated from the time-domain signal. The units of this expression are $(\\mu\\text{V})^2 / \\text{Hz}$, which are correct for a PSD.\n\nFor the specified Hann window, $w[n] = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N}\\right)\\right)$, the window power factor $S_2$ has a well-known value. Its exact value is derived from the sum:\n$$ S_2 = \\sum_{n=0}^{N-1} \\left[ \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N}\\right)\\right) \\right]^2 = \\frac{1}{4} \\sum_{n=0}^{N-1} \\left(1 - 2\\cos\\left(\\frac{2\\pi n}{N}\\right) + \\cos^2\\left(\\frac{2\\pi n}{N}\\right)\\right) $$\nUsing the identity $\\cos^2(\\theta) = \\frac{1}{2}(1 + \\cos(2\\theta))$ and the fact that the sum of a cosine over an integer number of full periods is zero ($\\sum_{n=0}^{N-1} \\cos(\\frac{2\\pi nk}{N}) = 0$ for integer $k$ not a multiple of $N$), the sum simplifies to:\n$$ S_2 = \\frac{1}{4} \\sum_{n=0}^{N-1} \\left(1 + \\frac{1}{2}\\right) = \\frac{1}{4} \\sum_{n=0}^{N-1} \\frac{3}{2} = \\frac{3}{8}N $$\n\nThe problem specifies a one-sided PSD, $S_{y,1}(f)$, which is common for real-valued signals. For a real signal, the DFT is conjugate symmetric ($Y_w[k] = Y_w^*[N-k]$), so its power spectrum $|Y_w[k]|^2$ is symmetric. The one-sided PSD is typically defined by folding the power from negative frequencies onto the positive frequencies. For frequencies $f_k > 0$ and not the Nyquist frequency, this means:\n$$ S_{y,1}(f_k) = 2 S_{y,2}(f_k) $$\nSubstituting our expressions for $S_{y,2}[k]$ and $S_2$:\n$$ S_{y,1}[k] = 2 \\left( \\frac{1}{F_s (\\frac{3}{8}N)} |Y_w[k]|^2 \\right) = \\frac{16}{3 F_s N} |Y_w[k]|^2 $$\nThis is the required scaling that produces a one-sided PSD in $\\mu\\text{V}^2/\\text{Hz}$ from the windowed DFT of $y[n]$.\n\nNext, we explain how to convert the reported counts-based PSD, $S_{x,1}(f)$, to the physical PSD, $S_{y,1}(f)$. The physical signal $y[n]$ is related to the raw count signal $x[n]$ by the calibration factor $g$:\n$$ y[n] = g \\cdot x[n] $$\nwhere $g = 0.09 \\, \\mu\\text{V/count}$. The DFT is a linear operation. Therefore, the DFT of the windowed physical signal relates to the DFT of the windowed count signal:\n$$ Y_w[k] = \\text{DFT}\\{y[n]w[n]\\} = \\text{DFT}\\{g \\cdot x[n]w[n]\\} = g \\cdot \\text{DFT}\\{x[n]w[n]\\} = g \\cdot X_w[k] $$\nThe squared magnitudes are related by $g^2$:\n$$ |Y_w[k]|^2 = g^2 |X_w[k]|^2 $$\nSince the PSD is proportional to the squared magnitude of the DFT with the same scaling constant for both signals (as the scaling depends only on $F_s$, $N$, and $w[n]$), the PSDs are directly related by $g^2$:\n$$ S_{y,1}(f) = g^2 S_{x,1}(f) $$\nThis provides the direct conversion from a PSD in $\\text{counts}^2/\\text{Hz}$ to one in $\\mu\\text{V}^2/\\text{Hz}$.\n\n**Part 2: Calculation of Alpha-Band Power**\n\nThe power in a specific frequency band is found by integrating the one-sided PSD over that band. The alpha band is specified as $f \\in [8, 12]$ Hz.\n$$ P_{\\alpha} = \\int_{8\\,\\text{Hz}}^{12\\,\\text{Hz}} S_{y,1}(f) \\, df $$\nFirst, we convert the reported PSD, $S_{x,1}(f) = 1.2 \\times 10^3 \\, \\text{counts}^2/\\text{Hz}$, to physical units.\n$$ S_{y,1}(f) = g^2 S_{x,1}(f) = (0.09 \\, \\mu\\text{V/count})^2 \\times (1.2 \\times 10^3 \\, \\text{counts}^2/\\text{Hz}) $$\n$$ S_{y,1}(f) = (8.1 \\times 10^{-3} \\, \\mu\\text{V}^2/\\text{count}^2) \\times (1.2 \\times 10^3 \\, \\text{counts}^2/\\text{Hz}) $$\n$$ S_{y,1}(f) = 9.72 \\, \\mu\\text{V}^2/\\text{Hz} $$\nThe problem states that the PSD is approximately flat over the alpha band. This simplifies the integral to a multiplication of the constant PSD value by the bandwidth of the interval.\nThe bandwidth is $\\Delta B = 12\\,\\text{Hz} - 8\\,\\text{Hz} = 4\\,\\text{Hz}$.\n$$ P_{\\alpha} = S_{y,1} \\times \\Delta B = (9.72 \\, \\mu\\text{V}^2/\\text{Hz}) \\times (4 \\, \\text{Hz}) $$\n$$ P_{\\alpha} = 38.88 \\, \\mu\\text{V}^2 $$\nThe problem requires the answer to be rounded to four significant figures. The calculated value of $38.88$ already has four significant figures.",
            "answer": "$$ \\boxed{38.88} $$"
        },
        {
            "introduction": "Real neural recordings are inherently noisy, and a PSD computed from a single, long data segment is often a highly variable and unreliable estimate of the true underlying spectrum. This exercise introduces Welch's method, a cornerstone technique for reducing this variance to obtain a stable PSD by averaging the spectra of shorter, overlapping segments. You will learn to make principled choices for key parameters like segment length and overlap, actively balancing the trade-off between frequency resolution and statistical stability to reliably detect neural oscillations hidden within the noise .",
            "id": "4138591",
            "problem": "You are given a directive to design and implement a program that applies Welch’s method to estimate the Power Spectral Density (PSD) of neural time series. The program must select the segment length $L$, the overlap fraction $p$, and the window $w[n]$ based on the desired frequency resolution and variance reduction. The program should justify these choices algorithmically by adhering to the following fundamental base and definitions.\n\nFundamental base:\n- The PSD (Power Spectral Density) characterizes the distribution of signal power across frequency. Welch’s method averages periodograms from overlapping, windowed segments to reduce variance.\n- In discrete-time analysis with sampling frequency $f_s$ and segment length $L$, the frequency resolution per Discrete Fourier Transform (DFT) bin is $\\Delta f = f_s / L$.\n- The number of averaged segments $K$ influences variance reduction of the PSD estimate; more averaging reduces variance for stationary signals.\n\nDesign constraints:\n- Choose $L$ to meet the desired resolution as closely as possible by using $\\Delta f = f_s / L$, subject to $L \\leq N$, where $N$ is the total number of samples.\n- Choose $p \\in [0,1)$ as a decimal fraction to increase the number of segments $K$ for variance reduction, subject to $p \\leq 0.95$ so that the overlap in samples $L p$ is strictly less than $L$.\n- Choose $w[n]$ from common tapering windows (e.g., Hann, Hamming). Window choice must be justified by the trade-off between spectral leakage, mainlobe width, and variance reduction. In particular, use $w[n]$ that reduces leakage for detecting narrowband oscillations when the signal-to-noise ratio is moderate to low, while respecting the desired resolution constraint.\n\nSignal model for testing:\n- For each test case, simulate a discrete-time local field potential (LFP) signal $x[n]$ of length $N = \\lfloor f_s T \\rfloor$ as\n$$\nx[n] = \\sum_{i=1}^{M} A_i \\sin\\!\\left(2\\pi f_i \\frac{n}{f_s} + \\phi_i\\right) + \\eta[n],\n$$\nwhere $A_i$ and $f_i$ are sinusoid amplitudes and frequencies, $\\phi_i$ are random phases, and $\\eta[n]$ is colored noise with approximate power-law spectrum $S_\\eta(f) \\propto \\frac{1}{(f + f_0)^\\alpha}$ for $f \\ge 0$, with $f_0$ a small offset to avoid division by zero. This is a well-tested approximation to neural noise with a $1/f^\\alpha$ spectrum.\n\nAlgorithmic tasks:\n1. For each test case, compute $N$, choose $L = \\min\\!\\left(N, \\left\\lfloor \\frac{f_s}{\\Delta f_{\\text{desired}}} \\right\\rfloor \\right)$, choose $p$ to achieve at least a target minimum number of averaged segments $K_{\\min}$ if possible, and select $w[n]$ from $\\{\\text{Hann}, \\text{Hamming}\\}$ based on signal-to-noise considerations and leakage control. If $K_{\\min}$ is not attainable due to $N$ and $L$, choose $p$ to maximize $K$ under $p \\le 0.95$ and $L p < L$.\n2. Use Welch’s method to estimate the PSD of $x[n]$ with the chosen $L$, $p$, and $w[n]$.\n3. Restrict attention to the frequency band $[4, 40]$ hertz and return the frequency at which the PSD attains its maximum in this band.\n4. Express the final outputs in hertz (Hz), rounded to $3$ decimals.\n\nTest suite:\nProvide four test cases that exercise a general case, resolution constraints, short-signal boundary, and low signal-to-noise ratio:\n- Case $1$: $f_s = 1000$ hertz, $T = 60$ seconds, desired $\\Delta f_{\\text{desired}} = 0.5$ hertz, $K_{\\min} = 20$, oscillation frequencies $[8, 20]$ hertz, amplitudes $[0.6, 1.0]$, noise scale $0.5$, noise exponent $\\alpha = 1.0$.\n- Case $2$: $f_s = 500$ hertz, $T = 30$ seconds, desired $\\Delta f_{\\text{desired}} = 1.0$ hertz, $K_{\\min} = 12$, oscillation frequencies $[10, 11]$ hertz, amplitudes $[1.2, 1.0]$, noise scale $0.8$, noise exponent $\\alpha = 1.0$.\n- Case $3$ (short-signal boundary): $f_s = 500$ hertz, $T = 3$ seconds, desired $\\Delta f_{\\text{desired}} = 0.25$ hertz, $K_{\\min} = 4$, oscillation frequencies $[8]$ hertz, amplitudes $[1.0]$, noise scale $0.6$, noise exponent $\\alpha = 1.0$.\n- Case $4$ (low signal-to-noise ratio): $f_s = 800$ hertz, $T = 20$ seconds, desired $\\Delta f_{\\text{desired}} = 0.8$ hertz, $K_{\\min} = 30$, oscillation frequencies $[30]$ hertz, amplitudes $[0.7]$, noise scale $1.5$, noise exponent $\\alpha = 1.0$.\n\nFinal output format:\nYour program should produce a single line of output containing the estimated dominant oscillation frequencies for the four test cases as a comma-separated list enclosed in square brackets (e.g., $[f_1,f_2,f_3,f_4]$), in hertz, each rounded to $3$ decimals.",
            "solution": "The objective is to estimate the Power Spectral Density (PSD) of neural time series using Welch’s method and to select the segment length $L$, overlap fraction $p$, and window $w[n]$ based on desired frequency resolution and variance reduction. The design proceeds from first principles.\n\nStart with a discrete-time signal $x[n]$ sampled at frequency $f_s$ hertz, with $n = 0,1,\\dots,N-1$, where $N = \\lfloor f_s T \\rfloor$. In Welch’s method, the signal is partitioned into $K$ segments of length $L$, with overlap $L p$ samples, and each segment is windowed by $w[n]$ and transformed to the frequency domain. The PSD estimate is the average of the windowed periodograms across segments. The PSD averaging reduces variance under stationarity assumptions: more segments $K$ produce lower variance of the estimate.\n\nFrequency resolution is dictated by the Discrete Fourier Transform (DFT) bin spacing. For a segment of length $L$, the frequency bin spacing is\n$$\n\\Delta f = \\frac{f_s}{L}.\n$$\nTherefore, to meet a desired resolution $\\Delta f_{\\text{desired}}$, we select\n$$\nL^\\star = \\min\\!\\left(N, \\left\\lfloor \\frac{f_s}{\\Delta f_{\\text{desired}}} \\right\\rfloor \\right),\n$$\nensuring that $L^\\star \\le N$. If $L^\\star = N$, then only one segment can be formed and the variance reduction from averaging is minimal, but the resolution is maximal given the constraint.\n\nThe number of segments $K$ that results from a choice of $L$ and $p$ can be computed by discrete packing of overlapping windows. Let the step between segment starts be $S = L(1-p)$ samples. Then, segment start indices are $0, S, 2S, \\dots$, and the number of complete segments is\n$$\nK = \\left\\lfloor \\frac{N - L}{S} \\right\\rfloor + 1 = \\left\\lfloor \\frac{N - L}{L(1-p)} \\right\\rfloor + 1.\n$$\nTo achieve a target minimum number of averages $K_{\\min}$, we solve for $p$ ignoring the floor to obtain an initial guess,\n$$\np_0 = 1 - \\frac{N - L}{(K_{\\min} - 1)L}.\n$$\nWe clamp $p_0$ to $[0, p_{\\max}]$ with $p_{\\max} = 0.95$ to ensure $L p < L$, and then adjust $p$ upward if needed to achieve $K \\ge K_{\\min}$, subject to $p \\le p_{\\max}$. If $K_{\\min}$ is unattainable due to the finite $N$ and the constraint $p \\le p_{\\max}$, we choose the maximum feasible $p$ to maximize $K$.\n\nWindow choice $w[n]$ balances spectral leakage and mainlobe width. Tapered windows such as Hann and Hamming reduce leakage relative to a rectangular window. The Hann window has good leakage suppression, while Hamming has slightly lower equivalent noise bandwidth and can offer improved variance traits at the cost of slightly broader mainlobe width. For detecting narrowband neural oscillations in moderate to low signal-to-noise regimes, a tapered window is preferred to suppress leakage from broadband noise. A principle-based heuristic is:\n- If the estimated signal-to-noise ratio is moderate to high, choose the Hann window for strong leakage suppression while preserving frequency resolution dictated by $\\Delta f = f_s/L$.\n- If the estimated signal-to-noise ratio is low, choose the Hamming window to slightly reduce variance and leakage around the mainlobe.\n\nWe estimate a coarse signal-to-noise ratio from the known synthetic signal composition. For sinusoidal components with amplitudes $A_i$ in additive noise with scale parameter $\\sigma_\\eta$, a rough power ratio is\n$$\n\\text{SNR} \\approx \\frac{\\sum_i A_i^2 / 2}{\\sigma_\\eta^2},\n$$\nsince a sinusoid of amplitude $A$ has power $A^2/2$. A threshold at $\\text{SNR} \\approx 1$ serves as a rule-of-thumb to select between Hann ($\\text{SNR} \\ge 1$) and Hamming ($\\text{SNR} < 1$).\n\nThe PSD estimation then proceeds via Welch’s method: build segments of length $L$ with overlap $L p$, apply window $w[n]$, compute DFTs, form periodograms, and average. The resulting PSD has reduced variance relative to a single periodogram. The binning resolution is directly $\\Delta f = f_s/L$. To find the dominant oscillation, restrict the frequency axis to $[4, 40]$ hertz, and take the frequency at which the PSD attains its maximum in that band.\n\nFor the test suite:\n\n- Case $1$: $f_s = 1000$, $T = 60$, $\\Delta f_{\\text{desired}} = 0.5$, $K_{\\min} = 20$, $f_i = [8, 20]$, $A_i = [0.6, 1.0]$, noise scale $\\sigma_\\eta = 0.5$, $\\alpha = 1.0$. Compute $N = \\lfloor 1000 \\cdot 60 \\rfloor = 60000$. Select $L^\\star = \\lfloor 1000 / 0.5 \\rfloor = 2000$. The initial overlap fraction $p_0 \\approx 1 - \\frac{60000 - 2000}{(20 - 1) \\cdot 2000} = 1 - \\frac{58000}{38000} \\approx -0.526$, clamp to $0$. Increase $p$ to meet $K_{\\min}$; with $p = 0.5$, $S = 1000$, $K \\approx \\lfloor \\frac{60000 - 2000}{1000} \\rfloor + 1 = 58 + 1 = 59$, satisfying $K_{\\min}$. The estimated $\\text{SNR} \\approx \\frac{(0.6^2 + 1.0^2)/2}{0.5^2} = \\frac{(0.36 + 1.0)/2}{0.25} = \\frac{0.68}{0.25} \\approx 2.72$, choose Hann. Expect dominant peak near $20$ hertz.\n\n- Case $2$: $f_s = 500$, $T = 30$, $\\Delta f_{\\text{desired}} = 1.0$, $K_{\\min} = 12$, $f_i = [10, 11]$, $A_i = [1.2, 1.0]$, $\\sigma_\\eta = 0.8$, $\\alpha = 1.0$. Compute $N = \\lfloor 500 \\cdot 30 \\rfloor = 15000$. Select $L^\\star = \\lfloor 500 / 1.0 \\rfloor = 500$. With $p_0 \\approx 1 - \\frac{15000 - 500}{(12 - 1) \\cdot 500} = 1 - \\frac{14500}{5500} \\approx -1.636$, clamp to $0$. Increase $p$; with $p = 0.5$, $S = 250$, $K \\approx \\lfloor \\frac{15000 - 500}{250} \\rfloor + 1 = 58 + 1 = 59$. $\\text{SNR} \\approx \\frac{(1.2^2 + 1.0^2)/2}{0.8^2} = \\frac{(1.44 + 1.0)/2}{0.64} = \\frac{1.22}{0.64} \\approx 1.906$, choose Hann. Expect dominant peak near $10$ hertz because the $10$ hertz component has larger amplitude.\n\n- Case $3$: $f_s = 500$, $T = 3$, $\\Delta f_{\\text{desired}} = 0.25$, $K_{\\min} = 4$, $f_i = [8]$, $A_i = [1.0]$, $\\sigma_\\eta = 0.6$, $\\alpha = 1.0$. Compute $N = \\lfloor 500 \\cdot 3 \\rfloor = 1500$. Select $L^\\star = \\min\\!\\left(1500, \\lfloor 500 / 0.25 \\rfloor \\right) = \\min(1500, 2000) = 1500$. Only one segment is possible for any $p$, so $K = 1$; choose $p$ to maximize $K$, but $K_{\\min}$ is unattainable. $\\text{SNR} \\approx \\frac{1.0^2/2}{0.6^2} = \\frac{0.5}{0.36} \\approx 1.389$, choose Hann. Expect dominant peak near $8$ hertz.\n\n- Case $4$: $f_s = 800$, $T = 20$, $\\Delta f_{\\text{desired}} = 0.8$, $K_{\\min} = 30$, $f_i = [30]$, $A_i = [0.7]$, $\\sigma_\\eta = 1.5$, $\\alpha = 1.0$. Compute $N = \\lfloor 800 \\cdot 20 \\rfloor = 16000$. Select $L^\\star = \\lfloor 800 / 0.8 \\rfloor = 1000$. With $p = 0.9$, $S = 100$, $K \\approx \\lfloor \\frac{16000 - 1000}{100} \\rfloor + 1 = 150 + 1 = 151$, satisfying $K_{\\min}$. $\\text{SNR} \\approx \\frac{0.7^2/2}{1.5^2} = \\frac{0.245}{2.25} \\approx 0.109$, choose Hamming due to low signal-to-noise ratio. Expect dominant peak near $30$ hertz.\n\nImplementation details:\n- Generate colored noise $\\eta[n]$ with approximate $1/f^\\alpha$ spectrum by drawing complex Gaussian coefficients in the frequency domain for $f \\ge 0$, weighting by $\\frac{1}{(f + f_0)^{\\alpha/2}}$ to control spectral slope, and transforming back to the time domain via the inverse Fourier transform, with $f_0 = 1/T$ to avoid singularity at $f = 0$. Normalize to unit variance then scale by $\\sigma_\\eta$.\n- Compute Welch’s PSD using the chosen parameters. Identify the frequency in $[4, 40]$ hertz where the PSD is maximal.\n- Report the four dominant frequencies as $[f_1,f_2,f_3,f_4]$ with values rounded to $3$ decimals, in hertz.\n\nThis procedure enforces $\\Delta f = f_s/L$ for resolution, uses $p$ to increase $K$ for variance reduction within constraints, and selects $w[n]$ to minimize leakage based on signal-to-noise considerations. The test suite spans a general case, a resolution-limited case with two close oscillations, a short-signal boundary with $L = N$, and a low signal-to-noise case requiring stronger tapering and heavy averaging.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import welch\n\ndef generate_colored_noise(N, fs, alpha=1.0, scale=1.0, rng=None):\n    \"\"\"\n    Generate colored noise with approximate 1/f^alpha spectrum using frequency-domain shaping.\n    The output has length N, sampling frequency fs, and is scaled to have standard deviation 'scale'.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng(0)\n    # Positive frequency bins including DC and Nyquist (for even N)\n    freqs = np.fft.rfftfreq(N, d=1.0/fs)\n    # Avoid division by zero at DC: use a small offset f0 = 1/T\n    T = N / fs\n    f0 = 1.0 / T\n    # Amplitude weighting: 1 / (f + f0)^(alpha/2)\n    # Using alpha/2 so that the power spectrum ~ 1/(f+f0)^alpha\n    w = 1.0 / np.power(freqs + f0, alpha / 2.0)\n    # Random complex spectrum with Hermitian symmetry for real time series\n    # Draw real and imaginary parts from N(0,1)\n    real_part = rng.normal(size=freqs.shape)\n    imag_part = rng.normal(size=freqs.shape)\n    # DC and Nyquist bins must be purely real for a real signal via irfft\n    imag_part[0] = 0.0\n    if N % 2 == 0:\n        imag_part[-1] = 0.0\n    X = (real_part + 1j * imag_part) * w\n    # Inverse real FFT to obtain time-domain noise\n    noise = np.fft.irfft(X, n=N)\n    # Normalize to unit standard deviation, then scale\n    if np.std(noise) > 0:\n        noise = noise / np.std(noise)\n    noise = noise * scale\n    return noise\n\ndef choose_parameters(N, fs, desired_df, K_min, amps, noise_scale, p_max=0.95):\n    \"\"\"\n    Choose L, overlap fraction p, and window name based on desired resolution and variance reduction.\n    \"\"\"\n    # Segment length to meet desired resolution as closely as possible\n    L_target = int(np.floor(fs / desired_df))\n    L = min(N, max(1, L_target))\n    # Initial overlap to meet K_min (ignoring floor)\n    if K_min = 1:\n        p0 = 0.0\n    else:\n        p0 = 1.0 - (N - L) / ((K_min - 1) * L)\n    # Clamp p0 and refine to achieve K >= K_min\n    p = np.clip(p0, 0.0, p_max)\n    def compute_K(L, p):\n        step = max(1, int(np.floor(L * (1.0 - p))))\n        # Ensure noverlap  L\n        if step = 0:\n            step = 1\n        K = (N - L) // step + 1 if N >= L else 0\n        return K, step\n    K, step = compute_K(L, p)\n    if K  K_min and N >= L:\n        # Increase p to raise K, up to p_max\n        # Try a small search over p\n        for trial_p in np.linspace(max(p, 0.0), p_max, 21):\n            K_trial, _ = compute_K(L, trial_p)\n            if K_trial >= K_min:\n                p = float(trial_p)\n                K = K_trial\n                break\n        else:\n            # Maximize K at p_max\n            p = p_max\n            K, step = compute_K(L, p)\n    # Window choice based on coarse SNR heuristic\n    signal_power = 0.5 * np.sum(np.array(amps, dtype=float) ** 2)\n    noise_power = float(noise_scale) ** 2\n    snr = signal_power / noise_power if noise_power > 0 else np.inf\n    window = 'hann' if snr >= 1.0 else 'hamming'\n    # Return parameters and achieved K\n    return L, p, window\n\ndef estimate_dominant_frequency(fs, T, desired_df, K_min, freqs, amps, noise_scale, alpha, rng_seed=42):\n    \"\"\"\n    Simulate the LFP-like signal and estimate the dominant frequency in [4, 40] Hz using Welch's method.\n    \"\"\"\n    rng = np.random.default_rng(rng_seed)\n    N = int(np.floor(fs * T))\n    t = np.arange(N) / fs\n\n    # Construct oscillatory components with random phases\n    x = np.zeros(N, dtype=float)\n    for f, a in zip(freqs, amps):\n        phase = rng.uniform(0, 2*np.pi)\n        x += a * np.sin(2.0 * np.pi * f * t + phase)\n\n    # Add colored noise\n    noise = generate_colored_noise(N, fs, alpha=alpha, scale=noise_scale, rng=rng)\n    x = x + noise\n\n    # Choose Welch parameters\n    L, p, window = choose_parameters(N, fs, desired_df, K_min, amps, noise_scale)\n\n    # Compute Welch PSD\n    noverlap = int(np.floor(p * L))\n    if noverlap >= L:\n        noverlap = L - 1  # enforce constraint\n    f_axis, Pxx = welch(x, fs=fs, window=window, nperseg=L, noverlap=noverlap, detrend='constant', scaling='density')\n\n    # Restrict to [4, 40] Hz band and find maximum\n    band_mask = (f_axis >= 4.0)  (f_axis = 40.0)\n    if not np.any(band_mask):\n        # If band empty due to parameter choices, fallback to overall maximum\n        idx_peak = int(np.argmax(Pxx))\n    else:\n        idx_band = np.where(band_mask)[0]\n        idx_peak_band = idx_band[np.argmax(Pxx[band_mask])]\n        idx_peak = int(idx_peak_band)\n    f_peak = float(f_axis[idx_peak])\n    return f_peak\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (fs, T, desired_df, K_min, freqs_list, amps_list, noise_scale, alpha)\n    test_cases = [\n        (1000.0, 60.0, 0.5, 20, [8.0, 20.0], [0.6, 1.0], 0.5, 1.0),\n        (500.0, 30.0, 1.0, 12, [10.0, 11.0], [1.2, 1.0], 0.8, 1.0),\n        (500.0, 3.0, 0.25, 4, [8.0], [1.0], 0.6, 1.0),\n        (800.0, 20.0, 0.8, 30, [30.0], [0.7], 1.5, 1.0),\n    ]\n\n    results = []\n    # Use distinct RNG seeds for reproducibility across cases\n    for idx, case in enumerate(test_cases):\n        fs, T, desired_df, K_min, freqs, amps, noise_scale, alpha = case\n        f_peak = estimate_dominant_frequency(fs, T, desired_df, K_min, freqs, amps, noise_scale, alpha, rng_seed=100 + idx)\n        results.append(f\"{f_peak:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Neural oscillations are rarely static; they often manifest as transient bursts of activity that are crucial for brain function. To capture these dynamics, we must move from a single, time-averaged PSD to a full time-frequency representation using the Short-Time Fourier Transform (STFT). This final practice challenges you to configure an STFT to resolve brief oscillatory events, requiring you to navigate the fundamental trade-off between temporal and spectral resolution in a principled, quantitative manner .",
            "id": "4138622",
            "problem": "You are tasked with configuring a Short-Time Fourier Transform (STFT) for analyzing beta-band dynamics in neural signals. The goal is to resolve bursts of approximately $100$ milliseconds duration in the beta-band between $15$ and $30$ Hertz while balancing time resolution and spectral leakage. The program you write must derive the window length and hop size based on fundamental definitions and well-tested facts, without relying on shortcut formulas provided to you in the problem statement.\n\nDefinitions and assumptions:\n- Short-Time Fourier Transform (STFT) uses a windowed segment of the signal to compute local spectra. Let the sampling rate be $f_s$ (in Hertz), window length be $N$ (in samples), and hop size be $H$ (in samples).\n- Let the window function be the Hann window, which is commonly used in neural time-frequency analysis for its smooth tapering and reduced sidelobes.\n- The beta-band is defined as $[f_l, f_h] = [15, 30]$ Hertz.\n- The target burst duration is denoted by $\\tau$ (in seconds).\n- Time resolution is directly related to the window duration $T_w = N / f_s$ (in seconds).\n- Discrete Fourier transform frequency-bin width is $\\Delta f = f_s / N$ (in Hertz).\n- For the Hann window, the width of the main-lobe between its first zeros in the discrete-time Fourier transform is equal to $4 \\Delta f$ (in Hertz), and this main-lobe width is a practical proxy for spectral leakage near a tone.\n- The window and hop size must be returned in samples (unitless integer counts). All durations must be specified in seconds, and all frequencies in Hertz.\n\nDesign objective:\n- Resolve bursts of duration $\\tau$ by ensuring time resolution is sufficiently fine, which requires $T_w$ not exceeding $\\tau$ (i.e., $N / f_s \\le \\tau$).\n- Limit spectral leakage in the beta-band by bounding the Hann-window main-lobe width by a tolerance $W_{\\max} = \\alpha (f_h - f_l)$, with $\\alpha$ chosen to represent a tolerable fraction of the beta-band width. Use $\\alpha = 0.5$ so that $W_{\\max} = 0.5 \\times (30 - 15)$ Hertz. This bound is a design tolerance, not a hard physical limit.\n- Construct a dimensionless, convex trade-off objective that equally weights the normalized time resolution penalty and the normalized main-lobe width penalty. Derive an analytic choice for $N$ that minimizes this objective under the constraints $N \\le f_s \\tau$ and integer $N \\ge 4$ (to ensure a non-trivial window).\n- The hop size must satisfy two conditions: \n  1) Maintain overlap suitable for stable STFT analysis with the Hann window (use $50\\%$ overlap, which implies $H \\approx N/2$), \n  2) Provide multiple analysis frames across a burst to resolve its onset and offset; ensure at least four frames across a burst by choosing $H \\le f_s \\tau / 4$. The hop size must be an integer with $H \\ge 1$.\n\nFeasibility flag:\n- For each parameter set, determine whether both the time-resolution constraint $N / f_s \\le \\tau$ and the leakage constraint $4 f_s / N \\le W_{\\max}$ can be simultaneously satisfied. Return a boolean flag indicating feasibility.\n\nTest suite:\nImplement your program to process the following test parameter sets, expressed as $(f_s, \\tau)$ pairs, where $f_s$ is in Hertz and $\\tau$ is in seconds:\n1) $(1000, 0.1)$\n2) $(256, 0.1)$\n3) $(1200, 0.6)$\n4) $(500, 0.08)$\n\nOutput specification:\n- For each test case, compute and return a list of three values $[N, H, \\text{feasible}]$, where $N$ and $H$ are integers (in samples), and $\\text{feasible}$ is a boolean.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets (e.g., $[[N_1,H_1,\\text{feasible}_1],[N_2,H_2,\\text{feasible}_2],\\dots]$).\n\nNotes:\n- No user input is permitted; the program must be self-contained and produce the specified output directly.\n- All physical quantities must be handled in their appropriate units: Hertz for frequencies and seconds for durations; window length and hop size must be returned in samples.\n- Angles are not used in this problem.\n- Express any fractional quantities in decimal form if needed; do not use percentages in the output.",
            "solution": "We proceed from first principles and well-tested facts about the Short-Time Fourier Transform (STFT) and windowed spectral analysis to design a window length and hop size that balance time resolution and spectral leakage for beta-band dynamics.\n\nFundamental base:\n1) Short-Time Fourier Transform (STFT) constructs local spectra by multiplying the signal $x[n]$ with a window $w[n]$ of length $N$ samples and computing a discrete-time Fourier transform at successive time shifts (hops) of $H$ samples. The time resolution is governed by the window duration $T_w = N / f_s$.\n2) The discrete frequency bin width of the discrete-time Fourier transform of a length-$N$ segment is $\\Delta f = f_s / N$.\n3) For the Hann window, a well-tested property is that the main-lobe width from the first zero to the first zero is $$W(N) = 4 \\Delta f = \\frac{4 f_s}{N}.$$ This main-lobe width serves as a practical proxy for spectral leakage: a sinusoid’s power spreads across frequencies within approximately this width around the true frequency in the windowed spectrum.\n4) The target burst duration is $\\tau$ seconds; to resolve such bursts in time, we require $$T_w = \\frac{N}{f_s} \\le \\tau,$$ which avoids smearing the burst beyond its duration.\n5) The beta-band is $[f_l, f_h] = [15, 30]$ Hertz, and we tolerate a fraction of this bandwidth for the main-lobe width. Set $$W_{\\max} = \\alpha (f_h - f_l), \\quad \\alpha = 0.5,$$ hence $$W_{\\max} = 0.5 \\times (30 - 15) = 7.5 \\text{ Hertz}.$$\n\nBalancing time resolution and leakage:\nWe seek a principled compromise between time resolution and leakage. Construct a dimensionless convex cost that equally weights the normalized time duration and the normalized main-lobe width:\n$$J(N) = \\frac{1}{2}\\left(\\frac{T_w}{\\tau} + \\frac{W(N)}{W_{\\max}}\\right) = \\frac{1}{2}\\left(\\frac{N}{f_s \\tau} + \\frac{4 f_s}{N W_{\\max}}\\right).$$\nThe function $J(N)$ is convex for $N  0$ because it is the sum of a term linear in $N$ and a term proportional to $1/N$. Minimizing $J(N)$ with respect to $N$ yields an analytic solution. Take the derivative with respect to $N$ and set to zero:\n$$\\frac{dJ}{dN} = \\frac{1}{2}\\left(\\frac{1}{f_s \\tau} - \\frac{4 f_s}{W_{\\max} N^2}\\right) = 0.$$\nSolving gives:\n$$\\frac{1}{f_s \\tau} = \\frac{4 f_s}{W_{\\max} N^2} \\quad \\Rightarrow \\quad N^2 = \\frac{4 f_s^2 \\tau}{W_{\\max}} \\quad \\Rightarrow \\quad N^\\star = f_s \\sqrt{\\frac{4 \\tau}{W_{\\max}}}.$$\nThis $N^\\star$ balances the normalized time resolution and leakage penalties.\n\nConstraints and integrality:\n- We must enforce the time-resolution constraint $N \\le f_s \\tau$ so that $T_w \\le \\tau$. Define the upper bound $$N_{\\text{time}} = \\left\\lfloor f_s \\tau \\right\\rfloor.$$\n- To enforce the leakage tolerance bound $W(N) \\le W_{\\max}$, we require $$\\frac{4 f_s}{N} \\le W_{\\max} \\quad \\Rightarrow \\quad N \\ge \\frac{4 f_s}{W_{\\max}}.$$ Define the frequency-leakage lower bound $$N_{\\text{freq}} = \\left\\lceil \\frac{4 f_s}{W_{\\max}} \\right\\rceil.$$\n- The analytic minimizer $N^\\star$ must be reconciled with these bounds and integrality. A balanced and feasible integer selection is\n$$N = \n\\begin{cases}\n\\min\\left(\\max\\left(\\left\\lfloor N^\\star \\right\\rceil, N_{\\text{freq}}\\right), N_{\\text{time}}\\right),  \\text{if } N_{\\text{freq}} \\le N_{\\text{time}},\\\\\nN_{\\text{time}},  \\text{if } N_{\\text{freq}}  N_{\\text{time}} \\text{ (time resolution prioritized, leakage tolerance not met)}.\n\\end{cases}$$\nHere $\\lfloor \\cdot \\rceil$ denotes rounding to the nearest integer. We also enforce a minimal window length of $N \\ge 4$ to avoid degenerate windows.\n\nFeasibility flag:\nWe set a boolean feasibility indicator\n$$\\text{feasible} = \\left( \\frac{N}{f_s} \\le \\tau \\right) \\land \\left( \\frac{4 f_s}{N} \\le W_{\\max} \\right) \\equiv \\left( N \\le N_{\\text{time}} \\right) \\land \\left( N \\ge N_{\\text{freq}} \\right).$$\n\nHop size selection:\nTwo principled conditions guide hop size $H$:\n1) For the Hann window, $50\\%$ overlap ensures stable amplitude estimation and perfect reconstruction in standard STFT overlap-add, which suggests $H \\approx N/2$. Let $$H_{\\text{ola}} = \\left\\lfloor \\frac{N}{2} \\right\\rfloor.$$\n2) To resolve a burst with multiple analysis frames across its duration, require at least four frames per burst, yielding $$H \\le \\frac{f_s \\tau}{4} \\quad \\Rightarrow \\quad H_{\\text{burst}} = \\left\\lfloor \\frac{f_s \\tau}{4} \\right\\rfloor.$$\nWe choose\n$$H = \\max\\left(1, \\min\\left( H_{\\text{ola}}, H_{\\text{burst}} \\right)\\right).$$\nThis enforces integer hop size and prevents $H=0$ in extreme low-duration cases.\n\nAlgorithm summary:\nGiven $(f_s, \\tau)$ and fixed $[f_l, f_h] = [15,30]$ Hertz with $\\alpha = 0.5$, compute:\n- $W_{\\max} = \\alpha (f_h - f_l)$,\n- $N^\\star = f_s \\sqrt{4 \\tau / W_{\\max}}$,\n- $N_{\\text{time}} = \\lfloor f_s \\tau \\rfloor$,\n- $N_{\\text{freq}} = \\lceil 4 f_s / W_{\\max} \\rceil$,\n- $N$ by the selection rule above (with $N \\ge 4$),\n- $H = \\max(1, \\min(\\lfloor N/2 \\rfloor, \\lfloor f_s \\tau / 4 \\rfloor))$,\n- $\\text{feasible} = (N \\le N_{\\text{time}}) \\land (N \\ge N_{\\text{freq}})$.\n\nThis principled design balances time resolution and spectral leakage under realistic constraints. In typical neurophysiological sampling rates and short burst durations (e.g., $\\tau \\approx 0.1$ seconds), the leakage tolerance $W_{\\max} = 7.5$ Hertz is often not simultaneously satisfiable with $T_w \\le \\tau$, which is reflected by the feasibility flag being false in those cases. Larger $\\tau$ values can make the constraints simultaneously feasible.\n\nThe program implements this logic for the test suite:\n1) $(f_s,\\tau) = (1000, 0.1)$,\n2) $(256, 0.1)$,\n3) $(1200, 0.6)$,\n4) $(500, 0.08)$,\nand outputs $[N, H, \\text{feasible}]$ per case in a single-line list format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef configure_stft(fs, tau, f_l=15.0, f_h=30.0, alpha=0.5):\n    \"\"\"\n    Configure STFT window length N and hop size H for beta-band analysis.\n    Parameters:\n        fs (float): Sampling rate in Hz.\n        tau (float): Target burst duration in seconds.\n        f_l (float): Lower bound of beta band (Hz).\n        f_h (float): Upper bound of beta band (Hz).\n        alpha (float): Fraction of band width tolerated for main-lobe width.\n    Returns:\n        (N, H, feasible): window length (samples), hop size (samples), feasibility boolean.\n    \"\"\"\n    # Tolerable main-lobe width (Hz)\n    W_max = alpha * (f_h - f_l)\n\n    # Analytic minimizer from balancing normalized time and leakage terms\n    N_star_cont = fs * np.sqrt((4.0 * tau) / W_max)\n\n    # Bounds from constraints\n    N_time_max = int(np.floor(fs * tau))\n    N_freq_min = int(np.ceil((4.0 * fs) / W_max))\n\n    # Round N_star to nearest integer\n    N_star = int(np.round(N_star_cont))\n\n    # Select N under constraints; prioritize time resolution if infeasible\n    if N_time_max  4:  # ensure non-trivial window\n        N_time_max = 4\n\n    if N_freq_min = N_time_max:\n        N = max(N_star, N_freq_min)\n        N = min(N, N_time_max)\n    else:\n        # Constraints cannot be simultaneously satisfied; prioritize time resolution\n        N = N_time_max\n\n    # Ensure minimum N\n    N = max(N, 4)\n\n    # Hop size: 50% overlap and at least four frames per burst\n    H_ola = N // 2\n    H_burst = int(np.floor(fs * tau / 4.0))\n    # Ensure H >= 1\n    H = max(1, min(H_ola, H_burst))\n\n    # Feasibility flag: both constraints satisfied\n    feasible = (N = N_time_max) and (N >= N_freq_min)\n\n    return int(N), int(H), bool(feasible)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (fs in Hz, tau in seconds)\n    test_cases = [\n        (1000.0, 0.1),\n        (256.0, 0.1),\n        (1200.0, 0.6),\n        (500.0, 0.08),\n    ]\n\n    results = []\n    for fs, tau in test_cases:\n        N, H, feasible = configure_stft(fs, tau)\n        results.append([N, H, feasible])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}