{
    "hands_on_practices": [
        {
            "introduction": "在应用高级分析工具之前，理解谱分析的基本原理至关重要。本练习将离散傅里叶变换（DFT）的原始输出与具有物理意义的功率谱密度（PSD）（单位为 $\\mu V^2/Hz$）联系起来。通过从第一性原理出发完成单位转换和归一化，您将深刻理解PSD的真正含义以及如何正确解读其数值 ()。",
            "id": "4138609",
            "problem": "一个脑电图（EEG）通道被数字化为整数计数，记为 $x[n]$，采样频率为 $F_s = 512$ Hz。使用一个在离散傅里叶变换（DFT）之前应用的汉宁窗 $w[n]$，对单个 $N = 4096$ 个样本的段（8秒）进行分析，从而产生一个单边功率谱密度（PSD）估计。仪器报告的原始计数的单边PSD为 $S_{x,1}(f)$，单位是 counts$^{2}$/Hz。在 $8$ Hz到 $12$ Hz的α波段中，报告的PSD在该水平上近似平坦：$S_{x,1}(f) = 1.2 \\times 10^{3}$ counts$^{2}$/Hz。\n\n模拟前端经过校准，使得每个计数对应 $g = 0.09$ $\\mu$V/count，因此物理EEG信号为 $y[n] = g\\,x[n]$，单位是 $\\mu$V。你可以假设仪器的PSD计算使用了标准的能量守恒周期图，并带有适当的窗功率归一化和单边转换。\n\n从DFT、帕塞瓦尔定理的基本定义，以及对功率谱密度进行频率积分得到信号功率（方差）这一概念出发，完成以下任务：\n\n- 推导从 $y[n]$ 的加窗DFT生成单位为 $\\mu$V$^{2}$/Hz 的PSD所需的单位一致的缩放比例，在你的推理中明确指出窗功率因子，并解释如何使用校准值 $g$ 将报告的 counts$^{2}$/Hz 单位的PSD转换为 $\\mu$V$^{2}$/Hz。\n- 使用推导出的单位转换和对PSD在频带上积分得到频带功率的原理，通过对 $S_{y,1}(f)$ 在 $f \\in [8, 12]$ Hz上积分来计算α波段功率。\n\n用 $\\mu$V$^{2}$ 表示最终的频带功率，并将你的答案四舍五入到四位有效数字。",
            "solution": "该问题陈述经评估有效。所有提供的数据和条件均有科学依据、前后一致，且足以得出唯一解。该问题是适定的且客观的，其框架符合使用数字信号处理(DSP)分析脑电图(EEG)等神经生理数据的标准实践。\n\n该问题需要两个主要步骤：首先，推导将加窗离散傅里叶变换（DFT）转换为物理单位的单边功率谱密度（PSD）的缩放因子，并解释如何从仪器报告的PSD转换为物理PSD；其次，计算α频带的功率。\n\n**第1部分：PSD缩放和单位转换的推导**\n\n设以物理单位表示的离散时间EEG信号为 $y[n]$，单位为 $\\mu$V。信号以频率 $F_s$ 采样，并对一个长度为 $N$ 个样本的段进行分析。该分析包括将窗函数 $w[n]$ 应用于信号段，得到加窗信号 $y_w[n] = y[n]w[n]$。\n\n加窗信号的DFT由下式给出：\n$$ Y_w[k] = \\sum_{n=0}^{N-1} y_w[n] \\exp\\left(-j \\frac{2\\pi nk}{N}\\right) $$\n由于 $w[n]$ 是无量纲的，因此 $Y_w[k]$ 的单位是 $\\mu$V。\n\n信号的总功率等于其方差 $\\sigma_y^2$。PSD分析的一个基本原理是，信号的总功率是其双边PSD $S_{y,2}(f)$ 在所有频率上的积分：\n$$ P_{\\text{total}} = \\sigma_y^2 = \\int_{-F_s/2}^{F_s/2} S_{y,2}(f) \\, df $$\n在离散域中，该积分通过对DFT频率仓求和来近似：\n$$ P_{\\text{total}} \\approx \\sum_{k=0}^{N-1} S_{y,2}[k] \\Delta f $$\n其中 $\\Delta f = F_s/N$ 是DFT的频率分辨率。\n\n周期图是PSD的常用估计量。对于加窗信号，PSD估计量必须进行缩放以保持能量守恒。适当的缩放因子考虑了采样频率和窗函数的功率。在频率仓 $k$ 处的双边PSD估计 $S_{y,2}[k]$ 定义为：\n$$ S_{y,2}[k] = \\frac{1}{F_s S_2} |Y_w[k]|^2 $$\n其中 $S_2 = \\sum_{n=0}^{N-1} w[n]^2$ 是窗系数的平方和，我们将其确定为**窗函数功率因子**。该因子确保从PSD估计的总功率与从时域信号估计的功率相匹配。此表达式的单位是 $(\\mu\\text{V})^2 / \\text{Hz}$，这对于PSD是正确的。\n\n对于指定的汉宁窗 $w[n] = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N}\\right)\\right)$，窗函数功率因子 $S_2$ 有一个众所周知的值。其精确值由以下求和推导得出：\n$$ S_2 = \\sum_{n=0}^{N-1} \\left[ \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N}\\right)\\right) \\right]^2 = \\frac{1}{4} \\sum_{n=0}^{N-1} \\left(1 - 2\\cos\\left(\\frac{2\\pi n}{N}\\right) + \\cos^2\\left(\\frac{2\\pi n}{N}\\right)\\right) $$\n使用恒等式 $\\cos^2(\\theta) = \\frac{1}{2}(1 + \\cos(2\\theta))$ 以及在整数个完整周期上余弦函数的和为零（对于不是 $N$ 的倍数的整数 $k$，$\\sum_{n=0}^{N-1} \\cos(\\frac{2\\pi nk}{N}) = 0$）这一事实，该和简化为：\n$$ S_2 = \\frac{1}{4} \\sum_{n=0}^{N-1} \\left(1 + \\frac{1}{2}\\right) = \\frac{1}{4} \\sum_{n=0}^{N-1} \\frac{3}{2} = \\frac{3}{8}N $$\n\n问题指定了单边PSD $S_{y,1}(f)$，这对于实值信号是常见的。对于实信号，DFT是共轭对称的（$Y_w[k] = Y_w^*[N-k]$），因此其功率谱 $|Y_w[k]|^2$ 是对称的。单边PSD通常通过将负频率的功率折叠到正频率上而定义。对于频率 $f_k > 0$ 且不是奈奎斯特频率的情况，这意味着：\n$$ S_{y,1}(f_k) = 2 S_{y,2}(f_k) $$\n代入我们对 $S_{y,2}[k]$ 和 $S_2$ 的表达式：\n$$ S_{y,1}[k] = 2 \\left( \\frac{1}{F_s (\\frac{3}{8}N)} |Y_w[k]|^2 \\right) = \\frac{16}{3 F_s N} |Y_w[k]|^2 $$\n这是从 $y[n]$ 的加窗DFT生成单位为 $\\mu\\text{V}^2/\\text{Hz}$ 的单边PSD所需的缩放比例。\n\n接下来，我们解释如何将报告的基于计数的PSD $S_{x,1}(f)$ 转换为物理PSD $S_{y,1}(f)$。物理信号 $y[n]$ 通过校准因子 $g$ 与原始计数信号 $x[n]$ 相关：\n$$ y[n] = g \\cdot x[n] $$\n其中 $g = 0.09 \\, \\mu\\text{V/count}$。DFT是线性运算。因此，加窗物理信号的DFT与加窗计数信号的DFT相关：\n$$ Y_w[k] = \\text{DFT}\\{y[n]w[n]\\} = \\text{DFT}\\{g \\cdot x[n]w[n]\\} = g \\cdot \\text{DFT}\\{x[n]w[n]\\} = g \\cdot X_w[k] $$\n幅度的平方通过 $g^2$ 相关：\n$$ |Y_w[k]|^2 = g^2 |X_w[k]|^2 $$\n由于PSD与DFT的幅度平方成正比，且两个信号的缩放常数相同（因为缩放仅取决于 $F_s$、$N$ 和 $w[n]$），所以PSD直接通过 $g^2$ 相关：\n$$ S_{y,1}(f) = g^2 S_{x,1}(f) $$\n这提供了从单位为 $\\text{counts}^2/\\text{Hz}$ 的PSD到单位为 $\\mu\\text{V}^2/\\text{Hz}$ 的PSD的直接转换。\n\n**第2部分：α波段功率的计算**\n\n特定频带的功率通过在该频带上对单边PSD积分得到。α波段被指定为 $f \\in [8, 12]$ Hz。\n$$ P_{\\alpha} = \\int_{8\\,\\text{Hz}}^{12\\,\\text{Hz}} S_{y,1}(f) \\, df $$\n首先，我们将报告的PSD $S_{x,1}(f) = 1.2 \\times 10^3 \\, \\text{counts}^2/\\text{Hz}$ 转换为物理单位。\n$$ S_{y,1}(f) = g^2 S_{x,1}(f) = (0.09 \\, \\mu\\text{V/count})^2 \\times (1.2 \\times 10^3 \\, \\text{counts}^2/\\text{Hz}) $$\n$$ S_{y,1}(f) = (8.1 \\times 10^{-3} \\, \\mu\\text{V}^2/\\text{count}^2) \\times (1.2 \\times 10^3 \\, \\text{counts}^2/\\text{Hz}) $$\n$$ S_{y,1}(f) = 9.72 \\, \\mu\\text{V}^2/\\text{Hz} $$\n问题陈述PSD在α波段上近似平坦。这将积分简化为常数PSD值与区间带宽的乘积。\n带宽为 $\\Delta B = 12\\,\\text{Hz} - 8\\,\\text{Hz} = 4\\,\\text{Hz}$。\n$$ P_{\\alpha} = S_{y,1} \\times \\Delta B = (9.72 \\, \\mu\\text{V}^2/\\text{Hz}) \\times (4 \\, \\text{Hz}) $$\n$$ P_{\\alpha} = 38.88 \\, \\mu\\text{V}^2 $$\n问题要求答案四舍五入到四位有效数字。计算出的值 $38.88$ 已经有四位有效数字。",
            "answer": "$$ \\boxed{38.88} $$"
        },
        {
            "introduction": "单个周期图虽然能提供原始的频谱估计，但其方差很大，不够稳定。韦尔奇（Welch）方法是一种标准而稳健的技术，它通过对重叠、加窗的信号段的周期图进行平均，来降低功率谱密度估计的方差。这个编程练习将指导您实现韦尔奇方法，并根据需求在频率分辨率和估计稳定性之间做出权衡，从而合理地选择段长度、重叠率和窗函数 ()。",
            "id": "4138591",
            "problem": "您的任务是设计并实现一个程序，该程序应用Welch方法来估计神经时间序列的功率谱密度（PSD）。该程序必须根据期望的频率分辨率和方差缩减来选择段长度$L$、重叠分数$p$和窗函数$w[n]$。程序应遵循以下基本原理和定义，从算法上证明这些选择的合理性。\n\n基本原理：\n- PSD（功率谱密度）描述了信号功率在频率上的分布。Welch方法通过对重叠、加窗的段的周期图进行平均来减少方差。\n- 在采样频率为$f_s$、段长度为$L$的离散时间分析中，每个离散傅里叶变换（DFT）频点的频率分辨率为 $\\Delta f = f_s / L$。\n- 平均段的数量$K$影响PSD估计的方差缩减；对于平稳信号，更多的平均可以减少方差。\n\n设计约束：\n- 使用 $\\Delta f = f_s / L$ 来选择$L$，以尽可能地满足期望的分辨率，同时满足$L \\le N$的约束，其中$N$是总样本数。\n- 选择$p \\in [0,1)$作为小数，以增加段数$K$来实现方差缩减，同时满足$p \\le 0.95$的约束，从而使样本中的重叠$L p$严格小于$L$。\n- 从常见的锥形窗（例如Hann、Hamming）中选择$w[n]$。窗函数的选择必须根据频谱泄漏、主瓣宽度和方差缩减之间的权衡来证明其合理性。特别地，当信噪比为中等到低时，应使用能够减少泄漏的$w[n]$来检测窄带振荡，同时要遵守期望的分辨率约束。\n\n用于测试的信号模型：\n- 对于每个测试用例，模拟一个长度为$N = \\lfloor f_s T \\rfloor$的离散时间局部场电位（LFP）信号$x[n]$，其形式如下：\n$$\nx[n] = \\sum_{i=1}^{M} A_i \\sin\\!\\left(2\\pi f_i \\frac{n}{f_s} + \\phi_i\\right) + \\eta[n],\n$$\n其中，$A_i$和$f_i$是正弦波的幅度和频率，$\\phi_i$是随机相位，$\\eta[n]$是有色噪声，其近似幂律谱为$S_\\eta(f) \\propto \\frac{1}{(f + f_0)^\\alpha}$（对于$f \\ge 0$），其中$f_0$是一个小的偏移量以避免除以零。这是一个经过充分测试的、对具有$1/f^\\alpha$谱的神经噪声的近似。\n\n算法任务：\n1. 对于每个测试用例，计算$N$，选择$L = \\min\\!\\left(N, \\left\\lfloor \\frac{f_s}{\\Delta f_{\\text{desired}}} \\right\\rfloor \\right)$，选择$p$以尽可能达到目标最小平均段数$K_{\\min}$，并根据信噪比考虑和泄漏控制从$\\{\\text{Hann}, \\text{Hamming}\\}$中选择$w[n]$。如果由于$N$和$L$的限制而无法达到$K_{\\min}$，则在$p \\le 0.95$和$L p < L$的条件下选择$p$以最大化$K$。\n2. 使用所选的$L$、$p$和$w[n]$，通过Welch方法估计$x[n]$的PSD。\n3. 将注意力限制在$[4, 40]$赫兹的频带内，并返回该频带内PSD达到最大值时的频率。\n4. 以赫兹（Hz）为单位表示最终输出，并四舍五入到3位小数。\n\n测试套件：\n提供四个测试用例，分别用于检验一般情况、分辨率约束、短信号边界和低信噪比情况：\n- 用例1：$f_s = 1000$赫兹，$T = 60$秒，期望$\\Delta f_{\\text{desired}} = 0.5$赫兹，$K_{\\min} = 20$，振荡频率$[8, 20]$赫兹，幅度$[0.6, 1.0]$，噪声尺度$0.5$，噪声指数$\\alpha = 1.0$。\n- 用例2：$f_s = 500$赫兹，$T = 30$秒，期望$\\Delta f_{\\text{desired}} = 1.0$赫兹，$K_{\\min} = 12$，振荡频率$[10, 11]$赫兹，幅度$[1.2, 1.0]$，噪声尺度$0.8$，噪声指数$\\alpha = 1.0$。\n- 用例3（短信号边界）：$f_s = 500$赫兹，$T = 3$秒，期望$\\Delta f_{\\text{desired}} = 0.25$赫兹，$K_{\\min} = 4$，振荡频率$[8]$赫兹，幅度$[1.0]$，噪声尺度$0.6$，噪声指数$\\alpha = 1.0$。\n- 用例4（低信噪比）：$f_s = 800$赫兹，$T = 20$秒，期望$\\Delta f_{\\text{desired}} = 0.8$赫兹，$K_{\\min} = 30$，振荡频率$[30]$赫兹，幅度$[0.7]$，噪声尺度$1.5$，噪声指数$\\alpha = 1.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的估计主导振荡频率，格式为方括号内以逗号分隔的列表（例如$[f_1,f_2,f_3,f_4]$），单位为赫兹，每个值四舍五入到3位小数。",
            "solution": "目标是使用Welch方法估计神经时间序列的功率谱密度（PSD），并根据期望的频率分辨率和方差缩减来选择段长度$L$、重叠分数$p$和窗函数$w[n]$。设计从第一性原理出发。\n\n从一个在频率$f_s$赫兹下采样的离散时间信号$x[n]$开始，其中$n = 0,1,\\dots,N-1$，$N = \\lfloor f_s T \\rfloor$。在Welch方法中，信号被分割成$K$个长度为$L$的段，重叠$L p$个样本，每个段都由$w[n]$加窗并转换到频域。PSD估计是跨段的加窗周期图的平均值。在平稳性假设下，PSD平均可以减少方差：更多的段$K$会产生更低的估计方差。\n\n频率分辨率由离散傅里叶变换（DFT）的频点间距决定。对于长度为$L$的段，频率分箱间距为\n$$\n\\Delta f = \\frac{f_s}{L}.\n$$\n因此，为了满足期望的分辨率$\\Delta f_{\\text{desired}}$，我们选择\n$$\nL^\\star = \\min\\!\\left(N, \\left\\lfloor \\frac{f_s}{\\Delta f_{\\text{desired}}} \\right\\rfloor \\right),\n$$\n确保$L^\\star \\le N$。如果$L^\\star = N$，则只能形成一个段，平均带来的方差缩减最小，但在约束条件下分辨率最大。\n\n由$L$和$p$的选择所产生的段数$K$可以通过重叠窗的离散打包来计算。设段起始点之间的步长为$S = L(1-p)$个样本。那么，段的起始索引为$0, S, 2S, \\dots$，完整段的数量为\n$$\nK = \\left\\lfloor \\frac{N - L}{S} \\right\\rfloor + 1 = \\left\\lfloor \\frac{N - L}{L(1-p)} \\right\\rfloor + 1.\n$$\n为了达到目标最小平均数$K_{\\min}$，我们忽略向下取整函数来求解$p$，以获得一个初始猜测值，\n$$\np_0 = 1 - \\frac{N - L}{(K_{\\min} - 1)L}.\n$$\n我们将$p_0$限制在$[0, p_{\\max}]$范围内，其中$p_{\\max} = 0.95$以确保$L p < L$，然后在需要时向上调整$p$以实现$K \\ge K_{\\min}$，同时满足$p \\le 0.95$的约束。如果由于有限的$N$和$p \\le 0.95$的约束而无法达到$K_{\\min}$，我们选择最大可行的$p$以最大化$K$。\n\n窗函数$w[n]$的选择平衡了频谱泄漏和主瓣宽度。像Hann和Hamming这样的锥形窗相对于矩形窗能减少泄漏。Hann窗具有良好的泄漏抑制效果，而Hamming窗的等效噪声带宽稍低，可以提供更好的方差特性，但代价是主瓣宽度稍宽。对于在中低信噪比情况下检测窄带神经振荡，首选锥形窗来抑制宽带噪声的泄漏。一个基于原理的启发式方法是：\n- 如果估计的信噪比为中到高，选择Hann窗以获得强大的泄漏抑制，同时保持由$\\Delta f = f_s/L$决定的频率分辨率。\n- 如果估计的信噪比低，选择Hamming窗以略微减少方差和主瓣周围的泄漏。\n\n我们从已知的合成信号成分中估计一个粗略的信噪比。对于在标度参数为$\\sigma_\\eta$的加性噪声中，幅度为$A_i$的正弦分量，一个粗略的功率比如下：\n$$\n\\text{SNR} \\approx \\frac{\\sum_i A_i^2 / 2}{\\sigma_\\eta^2},\n$$\n因为幅度为$A$的正弦波功率为$A^2/2$。一个在$\\text{SNR} \\approx 1$处的阈值可作为在Hann（$\\text{SNR} \\ge 1$）和Hamming（$\\text{SNR} < 1$）之间选择的经验法则。\n\n然后通过Welch方法进行PSD估计：构建长度为$L$、重叠为$L p$的段，应用窗函数$w[n]$，计算DFT，形成周期图，然后求平均。相对于单个周期图，得到的PSD具有更小的方差。分箱分辨率直接为$\\Delta f = f_s/L$。为了找到主导振荡，将频率轴限制在$[4, 40]$赫兹，并取该频带内PSD达到最大值时的频率。\n\n对于测试套件：\n\n- 用例1：$f_s = 1000$, $T = 60$, $\\Delta f_{\\text{desired}} = 0.5$, $K_{\\min} = 20$, $f_i = [8, 20]$, $A_i = [0.6, 1.0]$, 噪声尺度 $\\sigma_\\eta = 0.5$, $\\alpha = 1.0$。计算$N = \\lfloor 1000 \\cdot 60 \\rfloor = 60000$。选择$L^\\star = \\lfloor 1000 / 0.5 \\rfloor = 2000$。初始重叠分数$p_0 \\approx 1 - \\frac{60000 - 2000}{(20 - 1) \\cdot 2000} = 1 - \\frac{58000}{38000} \\approx -0.526$，限制到$0$。增加$p$以满足$K_{\\min}$；当$p = 0.5$时，$S = 1000$，$K \\approx \\lfloor \\frac{60000 - 2000}{1000} \\rfloor + 1 = 58 + 1 = 59$，满足$K_{\\min}$。估计的$\\text{SNR} \\approx \\frac{(0.6^2 + 1.0^2)/2}{0.5^2} = \\frac{(0.36 + 1.0)/2}{0.25} = \\frac{0.68}{0.25} \\approx 2.72$，选择Hann窗。预期主导峰值在$20$赫兹附近。\n\n- 用例2：$f_s = 500$, $T = 30$, $\\Delta f_{\\text{desired}} = 1.0$, $K_{\\min} = 12$, $f_i = [10, 11]$, $A_i = [1.2, 1.0]$, $\\sigma_\\eta = 0.8$, $\\alpha = 1.0$。计算$N = \\lfloor 500 \\cdot 30 \\rfloor = 15000$。选择$L^\\star = \\lfloor 500 / 1.0 \\rfloor = 500$。当$p_0 \\approx 1 - \\frac{15000 - 500}{(12 - 1) \\cdot 500} = 1 - \\frac{14500}{5500} \\approx -1.636$，限制到$0$。增加$p$；当$p = 0.5$时，$S = 250$，$K \\approx \\lfloor \\frac{15000 - 500}{250} \\rfloor + 1 = 58 + 1 = 59$。$\\text{SNR} \\approx \\frac{(1.2^2 + 1.0^2)/2}{0.8^2} = \\frac{(1.44 + 1.0)/2}{0.64} = \\frac{1.22}{0.64} \\approx 1.906$，选择Hann窗。预期主导峰值在$10$赫兹附近，因为$10$赫兹分量的幅度更大。\n\n- 用例3：$f_s = 500$, $T = 3$, $\\Delta f_{\\text{desired}} = 0.25$, $K_{\\min} = 4$, $f_i = [8]$, $A_i = [1.0]$, $\\sigma_\\eta = 0.6$, $\\alpha = 1.0$。计算$N = \\lfloor 500 \\cdot 3 \\rfloor = 1500$。选择$L^\\star = \\min\\!\\left(1500, \\lfloor 500 / 0.25 \\rfloor \\right) = \\min(1500, 2000) = 1500$。对于任何$p$，都只能有一个段，所以$K = 1$；选择$p$以最大化$K$，但无法达到$K_{\\min}$。$\\text{SNR} \\approx \\frac{1.0^2/2}{0.6^2} = \\frac{0.5}{0.36} \\approx 1.389$，选择Hann窗。预期主导峰值在$8$赫兹附近。\n\n- 用例4：$f_s = 800$, $T = 20$, $\\Delta f_{\\text{desired}} = 0.8$, $K_{\\min} = 30$, $f_i = [30]$, $A_i = [0.7]$, $\\sigma_\\eta = 1.5$, $\\alpha = 1.0$。计算$N = \\lfloor 800 \\cdot 20 \\rfloor = 16000$。选择$L^\\star = \\lfloor 800 / 0.8 \\rfloor = 1000$。当$p = 0.9$时，$S = 100$，$K \\approx \\lfloor \\frac{16000 - 1000}{100} \\rfloor + 1 = 150 + 1 = 151$，满足$K_{\\min}$。$\\text{SNR} \\approx \\frac{0.7^2/2}{1.5^2} = \\frac{0.245}{2.25} \\approx 0.109$，由于信噪比低，选择Hamming窗。预期主导峰值在$30$赫兹附近。\n\n实现细节：\n- 通过在频域中为$f \\ge 0$抽取复高斯系数，并使用$\\frac{1}{(f + f_0)^{\\alpha/2}}$进行加权以控制谱斜率，然后通过傅里叶逆变换转换回时域，来生成具有近似$1/f^\\alpha$谱的有色噪声$\\eta[n]$，其中$f_0 = 1/T$以避免在$f=0$处的奇异点。归一化到单位方差，然后按$\\sigma_\\eta$进行缩放。\n- 使用所选参数计算Welch PSD。确定在$[4, 40]$赫兹频带内PSD最大的频率。\n- 报告四个主导频率，格式为$[f_1,f_2,f_3,f_4]$，单位为赫兹，数值四舍五入到3位小数。\n\n此过程强制使用$\\Delta f = f_s/L$来保证分辨率，利用$p$在约束内增加$K$以减少方差，并根据信噪比考虑选择$w[n]$以最小化泄漏。该测试套件涵盖了一个一般情况、一个具有两个相近振荡的分辨率受限情况、一个$L = N$的短信号边界情况，以及一个需要更强锥形窗和大量平均的低信噪比情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import welch\n\ndef generate_colored_noise(N, fs, alpha=1.0, scale=1.0, rng=None):\n    \"\"\"\n    Generate colored noise with approximate 1/f^alpha spectrum using frequency-domain shaping.\n    The output has length N, sampling frequency fs, and is scaled to have standard deviation 'scale'.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng(0)\n    # Positive frequency bins including DC and Nyquist (for even N)\n    freqs = np.fft.rfftfreq(N, d=1.0/fs)\n    # Avoid division by zero at DC: use a small offset f0 = 1/T\n    T = N / fs\n    f0 = 1.0 / T\n    # Amplitude weighting: 1 / (f + f0)^(alpha/2)\n    # Using alpha/2 so that the power spectrum ~ 1/(f+f0)^alpha\n    w = 1.0 / np.power(freqs + f0, alpha / 2.0)\n    # Random complex spectrum with Hermitian symmetry for real time series\n    # Draw real and imaginary parts from N(0,1)\n    real_part = rng.normal(size=freqs.shape)\n    imag_part = rng.normal(size=freqs.shape)\n    # DC and Nyquist bins must be purely real for a real signal via irfft\n    imag_part[0] = 0.0\n    if N % 2 == 0:\n        imag_part[-1] = 0.0\n    X = (real_part + 1j * imag_part) * w\n    # Inverse real FFT to obtain time-domain noise\n    noise = np.fft.irfft(X, n=N)\n    # Normalize to unit standard deviation, then scale\n    if np.std(noise) > 0:\n        noise = noise / np.std(noise)\n    noise = noise * scale\n    return noise\n\ndef choose_parameters(N, fs, desired_df, K_min, amps, noise_scale, p_max=0.95):\n    \"\"\"\n    Choose L, overlap fraction p, and window name based on desired resolution and variance reduction.\n    \"\"\"\n    # Segment length to meet desired resolution as closely as possible\n    L_target = int(np.floor(fs / desired_df))\n    L = min(N, max(1, L_target))\n    # Initial overlap to meet K_min (ignoring floor)\n    if K_min <= 1:\n        p0 = 0.0\n    else:\n        p0 = 1.0 - (N - L) / ((K_min - 1) * L)\n    # Clamp p0 and refine to achieve K >= K_min\n    p = np.clip(p0, 0.0, p_max)\n    def compute_K(L, p):\n        step = max(1, int(np.floor(L * (1.0 - p))))\n        # Ensure noverlap < L\n        if step <= 0:\n            step = 1\n        K = (N - L) // step + 1 if N >= L else 0\n        return K, step\n    K, step = compute_K(L, p)\n    if K < K_min and N >= L:\n        # Increase p to raise K, up to p_max\n        # Try a small search over p\n        for trial_p in np.linspace(max(p, 0.0), p_max, 21):\n            K_trial, _ = compute_K(L, trial_p)\n            if K_trial >= K_min:\n                p = float(trial_p)\n                K = K_trial\n                break\n        else:\n            # Maximize K at p_max\n            p = p_max\n            K, step = compute_K(L, p)\n    # Window choice based on coarse SNR heuristic\n    signal_power = 0.5 * np.sum(np.array(amps, dtype=float) ** 2)\n    noise_power = float(noise_scale) ** 2\n    snr = signal_power / noise_power if noise_power > 0 else np.inf\n    window = 'hann' if snr >= 1.0 else 'hamming'\n    # Return parameters and achieved K\n    return L, p, window\n\ndef estimate_dominant_frequency(fs, T, desired_df, K_min, freqs, amps, noise_scale, alpha, rng_seed=42):\n    \"\"\"\n    Simulate the LFP-like signal and estimate the dominant frequency in [4, 40] Hz using Welch's method.\n    \"\"\"\n    rng = np.random.default_rng(rng_seed)\n    N = int(np.floor(fs * T))\n    t = np.arange(N) / fs\n\n    # Construct oscillatory components with random phases\n    x = np.zeros(N, dtype=float)\n    for f, a in zip(freqs, amps):\n        phase = rng.uniform(0, 2*np.pi)\n        x += a * np.sin(2.0 * np.pi * f * t + phase)\n\n    # Add colored noise\n    noise = generate_colored_noise(N, fs, alpha=alpha, scale=noise_scale, rng=rng)\n    x = x + noise\n\n    # Choose Welch parameters\n    L, p, window = choose_parameters(N, fs, desired_df, K_min, amps, noise_scale)\n\n    # Compute Welch PSD\n    noverlap = int(np.floor(p * L))\n    if noverlap >= L:\n        noverlap = L - 1  # enforce constraint\n    f_axis, Pxx = welch(x, fs=fs, window=window, nperseg=L, noverlap=noverlap, detrend='constant', scaling='density')\n\n    # Restrict to [4, 40] Hz band and find maximum\n    band_mask = (f_axis >= 4.0) & (f_axis <= 40.0)\n    if not np.any(band_mask):\n        # If band empty due to parameter choices, fallback to overall maximum\n        idx_peak = int(np.argmax(Pxx))\n    else:\n        idx_band = np.where(band_mask)[0]\n        idx_peak_band = idx_band[np.argmax(Pxx[band_mask])]\n        idx_peak = int(idx_peak_band)\n    f_peak = float(f_axis[idx_peak])\n    return f_peak\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (fs, T, desired_df, K_min, freqs_list, amps_list, noise_scale, alpha)\n    test_cases = [\n        (1000.0, 60.0, 0.5, 20, [8.0, 20.0], [0.6, 1.0], 0.5, 1.0),\n        (500.0, 30.0, 1.0, 12, [10.0, 11.0], [1.2, 1.0], 0.8, 1.0),\n        (500.0, 3.0, 0.25, 4, [8.0], [1.0], 0.6, 1.0),\n        (800.0, 20.0, 0.8, 30, [30.0], [0.7], 1.5, 1.0),\n    ]\n\n    results = []\n    # Use distinct RNG seeds for reproducibility across cases\n    for idx, case in enumerate(test_cases):\n        fs, T, desired_df, K_min, freqs, amps, noise_scale, alpha = case\n        f_peak = estimate_dominant_frequency(fs, T, desired_df, K_min, freqs, amps, noise_scale, alpha, rng_seed=100 + idx)\n        results.append(f\"{f_peak:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "神经信号通常是非平稳的，其频率成分会随时间变化。短时傅里叶变换（STFT）是时频分析的基础工具，它使我们能够观察频谱功率如何随时间演变。本练习要求您通过量化并解决时间分辨率（捕捉短暂事件）与频率分辨率（区分相近频率）之间的权衡，来推导最佳的STFT参数，这是分析动态神经活动的核心挑战 ()。",
            "id": "4138622",
            "problem": "你的任务是配置一个短时傅里叶变换（STFT），用于分析神经信号中的 β 波段动态。目标是在 $15$ 到 $30$ 赫兹的 β 波段中解析大约 $100$ 毫秒时长的爆发活动，同时平衡时间分辨率和频谱泄漏。你编写的程序必须基于基本定义和经过充分检验的事实来推导窗长和跳跃步长，而不是依赖于问题陈述中提供给你的快捷公式。\n\n定义和假设：\n- 短时傅里叶变换（STFT）使用信号的加窗片段来计算局部频谱。设采样率为 $f_s$（单位：赫兹），窗长为 $N$（单位：样本点数），跳跃步长为 $H$（单位：样本点数）。\n- 设窗函数为 Hann 窗，因其平滑的锥形和减小的旁瓣，常用于神经信号的时频分析。\n- β 波段定义为 $[f_l, f_h] = [15, 30]$ 赫兹。\n- 目标爆发活动的时长记为 $\\tau$（单位：秒）。\n- 时间分辨率与窗长 $T_w = N / f_s$（单位：秒）直接相关。\n- 离散傅里叶变换的频率箱宽度为 $\\Delta f = f_s / N$（单位：赫兹）。\n- 对于 Hann 窗，其离散时间傅里叶变换中主瓣在两个第一零点之间的宽度等于 $4 \\Delta f$（单位：赫茲），该主瓣宽度是衡量音调附近频谱泄漏的实用指标。\n- 窗长和跳跃步长必须以样本点数（无单位整数）返回。所有时长必须以秒为单位指定，所有频率以赫兹为单位指定。\n\n设计目标：\n- 通过确保时间分辨率足够精细来解析时长为 $\\tau$ 的爆发活动，这要求 $T_w$ 不超过 $\\tau$（即 $N / f_s \\le \\tau$）。\n- 通过将 Hann 窗主瓣宽度限制在容差 $W_{\\max} = \\alpha (f_h - f_l)$ 内来限制 β 波段的频谱泄漏，其中 $\\alpha$ 被选择为代表 β 波段带宽的一个可容忍比例。使用 $\\alpha = 0.5$，因此 $W_{\\max} = 0.5 \\times (30 - 15)$ 赫兹。此界限是一个设计容差，而非严格的物理限制。\n- 构建一个无量纲的凸权衡目标函数，该函数同等加权归一化的时间分辨率惩罚和归一化的主瓣宽度惩罚。在约束条件 $N \\le f_s \\tau$ 和整数 $N \\ge 4$（以确保窗口非平凡）下，推导出最小化此目标函数的 $N$ 的解析选择。\n- 跳跃步长必须满足两个条件：\n  1) 使用 Hann 窗进行稳定的 STFT 分析时，维持合适的重叠（使用 $50\\%$ 重叠，意味着 $H \\approx N/2$），\n  2) 在一次爆发活动中提供多个分析帧以解析其起始和结束；通过选择 $H \\le f_s \\tau / 4$ 确保每次爆发活动至少有四个分析帧。跳跃步长必须为整数且 $H \\ge 1$。\n\n可行性标志：\n- 对于每组参数，判断时间分辨率约束 $N / f_s \\le \\tau$ 和频谱泄漏约束 $4 f_s / N \\le W_{\\max}$ 是否能同时满足。返回一个布尔标志指示可行性。\n\n测试套件：\n实现你的程序来处理以下测试参数集，表示为 $(f_s, \\tau)$ 对，其中 $f_s$ 的单位是赫兹，$\\tau$ 的单位是秒：\n1) $(1000, 0.1)$\n2) $(256, 0.1)$\n3) $(1200, 0.6)$\n4) $(500, 0.08)$\n\n输出规格：\n- 对于每个测试用例，计算并返回一个包含三个值的列表 $[N, H, \\text{feasible}]$，其中 $N$ 和 $H$ 是整数（单位：样本点数），$\\text{feasible}$ 是一个布尔值。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个逗号分隔的列表，并用方括号括起来（例如 $[[N_1,H_1,\\text{feasible}_1],[N_2,H_2,\\text{feasible}_2],\\dots]$）。\n\n注意事项：\n- 不允许用户输入；程序必须是自包含的，并直接生成指定的输出。\n- 所有物理量必须以其适当的单位处理：频率用赫兹，时长用秒；窗长和跳跃步长必须以样本点数返回。\n- 本问题不使用角度。\n- 如果需要，以小数形式表示任何分数量；输出中不要使用百分比。",
            "solution": "我们从短时傅里叶变换（STFT）和加窗频谱分析的基本原理和经过充分检验的事实出发，设计一个能够平衡 β 波段动态的时间分辨率和频谱泄漏的窗长和跳跃步长。\n\n基本依据：\n1) 短时傅里叶变换（STFT）通过将信号 $x[n]$ 与长度为 $N$ 个样本点的窗函数 $w[n]$ 相乘，并在连续的 $H$ 个样本点的时间移位（跳跃）上计算离散时间傅里叶变换来构建局部频谱。时间分辨率由窗长 $T_w = N / f_s$ 决定。\n2) 长度为 $N$ 的段的离散时间傅里叶变换的离散频率箱宽度为 $\\Delta f = f_s / N$。\n3) 对于 Hann 窗，一个经过充分检验的特性是其主瓣从第一个零点到第一个零点的宽度为 $$W(N) = 4 \\Delta f = \\frac{4 f_s}{N}.$$ 该主瓣宽度可作为频谱泄漏的实用指标：在加窗频谱中，正弦波的功率会扩散到真实频率周围大约这个宽度的频率范围内。\n4) 目标爆发活动时长为 $\\tau$ 秒；为了在时间上解析此类爆发，我们要求 $$T_w = \\frac{N}{f_s} \\le \\tau,$$ 这可以避免将爆发活动模糊到其持续时间之外。\n5) β 波段为 $[f_l, f_h] = [15, 30]$ 赫兹，我们容忍主瓣宽度占用该带宽的一部分。设 $$W_{\\max} = \\alpha (f_h - f_l), \\quad \\alpha = 0.5,$$ 因此 $$W_{\\max} = 0.5 \\times (30 - 15) = 7.5 \\text{ 赫兹}。$$\n\n平衡时间分辨率和泄漏：\n我们寻求在时间分辨率和泄漏之间达成一个有原则的折衷。构建一个无量纲的凸成本函数，该函数同等加权归一化的窗长和归一化的主瓣宽度：\n$$J(N) = \\frac{1}{2}\\left(\\frac{T_w}{\\tau} + \\frac{W(N)}{W_{\\max}}\\right) = \\frac{1}{2}\\left(\\frac{N}{f_s \\tau} + \\frac{4 f_s}{N W_{\\max}}\\right)。$$\n函数 $J(N)$ 在 $N > 0$ 时是凸函数，因为它是 $N$ 的线性项和与 $1/N$ 成比例的项之和。对 $J(N)$ 关于 $N$ 进行最小化可得到一个解析解。对 $N$ 求导并令其为零：\n$$\\frac{dJ}{dN} = \\frac{1}{2}\\left(\\frac{1}{f_s \\tau} - \\frac{4 f_s}{W_{\\max} N^2}\\right) = 0。$$\n求解得：\n$$\\frac{1}{f_s \\tau} = \\frac{4 f_s}{W_{\\max} N^2} \\quad \\Rightarrow \\quad N^2 = \\frac{4 f_s^2 \\tau}{W_{\\max}} \\quad \\Rightarrow \\quad N^\\star = f_s \\sqrt{\\frac{4 \\tau}{W_{\\max}}}。$$\n这个 $N^\\star$ 平衡了归一化的时间分辨率和泄漏惩罚。\n\n约束与整数性：\n- 我们必须强制执行时间分辨率约束 $N \\le f_s \\tau$，以使 $T_w \\le \\tau$。定义上界 $$N_{\\text{time}} = \\left\\lfloor f_s \\tau \\right\\rfloor.$$\n- 为了强制执行泄漏容差界限 $W(N) \\le W_{\\max}$，我们要求 $$\\frac{4 f_s}{N} \\le W_{\\max} \\quad \\Rightarrow \\quad N \\ge \\frac{4 f_s}{W_{\\max}}.$$ 定义频率泄漏下界 $$N_{\\text{freq}} = \\left\\lceil \\frac{4 f_s}{W_{\\max}} \\right\\rceil.$$\n- 解析最小化器 $N^\\star$ 必须与这些界限和整数性要求相协调。一个平衡且可行的整数选择是\n$$N = \n\\begin{cases}\n\\min\\left(\\max\\left(\\lfloor N^\\star \\rceil, N_{\\text{freq}}\\right), N_{\\text{time}}\\right),  & \\text{if } N_{\\text{freq}} \\le N_{\\text{time}},\\\\\nN_{\\text{time}},  & \\text{if } N_{\\text{freq}} > N_{\\text{time}} \\text{ (time resolution prioritized, leakage tolerance not met)}.\n\\end{cases}$$\n此处 $\\lfloor \\cdot \\rceil$ 表示四舍五入到最近的整数。我们还强制要求最小窗长为 $N \\ge 4$，以避免退化窗口。\n\n可行性标志：\n我们设置一个布尔可行性指标\n$$\\text{feasible} = (\\frac{N}{f_s} \\le \\tau) \\land (\\frac{4 f_s}{N} \\le W_{\\max}) \\equiv (N \\le N_{\\text{time}}) \\land (N \\ge N_{\\text{freq}})。$$\n\n跳跃步长选择：\n两个原则性条件指导跳跃步长 $H$ 的选择：\n1) 对于 Hann 窗，$50\\%$ 的重叠可确保标准 STFT 重叠相加法中的稳定幅度估计和完美重建，这建议 $H \\approx N/2$。设 $$H_{\\text{ola}} = \\left\\lfloor \\frac{N}{2} \\right\\rfloor.$$\n2) 为了用多个分析帧解析一次爆发活动的持续时间，要求每次爆发至少有四个帧，得出 $$H \\le \\frac{f_s \\tau}{4} \\quad \\Rightarrow \\quad H_{\\text{burst}} = \\left\\lfloor \\frac{f_s \\tau}{4} \\right\\rfloor.$$\n我们选择\n$$H = \\max\\left(1, \\min\\left( H_{\\text{ola}}, H_{\\text{burst}} \\right)\\right)。$$\n这强制了整数跳跃步长，并防止在极端低持续时间的情况下 $H=0$。\n\n算法总结：\n给定 $(f_s, \\tau)$ 和固定的 $[f_l, f_h] = [15,30]$ 赫兹及 $\\alpha = 0.5$，计算：\n- $W_{\\max} = \\alpha (f_h - f_l)$,\n- $N^\\star = f_s \\sqrt{4 \\tau / W_{\\max}}$,\n- $N_{\\text{time}} = \\lfloor f_s \\tau \\rfloor$,\n- $N_{\\text{freq}} = \\lceil 4 f_s / W_{\\max} \\rceil$,\n- 根据上述选择规则计算 $N$（且 $N \\ge 4$），\n- $H = \\max(1, \\min(\\lfloor N/2 \\rfloor, \\lfloor f_s \\tau / 4 \\rfloor))$,\n- $\\text{feasible} = (N \\le N_{\\text{time}}) \\land (N \\ge N_{\\text{freq}})$。\n\n这种有原则的设计在现实约束下平衡了时间分辨率和频谱泄漏。在典型的神经生理学采样率和短时爆发（例如 $\\tau \\approx 0.1$ 秒）的情况下，泄漏容差 $W_{\\max} = 7.5$ 赫兹通常无法与 $T_w \\le \\tau$ 同时满足，这在这些情况下通过可行性标志为 false 来反映。较大的 $\\tau$ 值可以使约束条件同时可行。\n\n程序为测试套件实现了此逻辑：1) $(f_s,\\tau) = (1000, 0.1)$，2) $(256, 0.1)$，3) $(1200, 0.6)$，4) $(500, 0.08)$，并以单行列表格式为每个案例输出 $[N, H, \\text{feasible}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef configure_stft(fs, tau, f_l=15.0, f_h=30.0, alpha=0.5):\n    \"\"\"\n    Configure STFT window length N and hop size H for beta-band analysis.\n    Parameters:\n        fs (float): Sampling rate in Hz.\n        tau (float): Target burst duration in seconds.\n        f_l (float): Lower bound of beta band (Hz).\n        f_h (float): Upper bound of beta band (Hz).\n        alpha (float): Fraction of band width tolerated for main-lobe width.\n    Returns:\n        (N, H, feasible): window length (samples), hop size (samples), feasibility boolean.\n    \"\"\"\n    # Tolerable main-lobe width (Hz)\n    W_max = alpha * (f_h - f_l)\n\n    # Analytic minimizer from balancing normalized time and leakage terms\n    N_star_cont = fs * np.sqrt((4.0 * tau) / W_max)\n\n    # Bounds from constraints\n    N_time_max = int(np.floor(fs * tau))\n    N_freq_min = int(np.ceil((4.0 * fs) / W_max))\n\n    # Round N_star to nearest integer\n    N_star = int(np.round(N_star_cont))\n\n    # Select N under constraints; prioritize time resolution if infeasible\n    if N_time_max < 4:  # ensure non-trivial window\n        N_time_max = 4\n\n    if N_freq_min <= N_time_max:\n        N = max(N_star, N_freq_min)\n        N = min(N, N_time_max)\n    else:\n        # Constraints cannot be simultaneously satisfied; prioritize time resolution\n        N = N_time_max\n\n    # Ensure minimum N\n    N = max(N, 4)\n\n    # Hop size: 50% overlap and at least four frames per burst\n    H_ola = N // 2\n    H_burst = int(np.floor(fs * tau / 4.0))\n    # Ensure H >= 1\n    H = max(1, min(H_ola, H_burst))\n\n    # Feasibility flag: both constraints satisfied\n    feasible = (N <= N_time_max) and (N >= N_freq_min)\n\n    return int(N), int(H), bool(feasible)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (fs in Hz, tau in seconds)\n    test_cases = [\n        (1000.0, 0.1),\n        (256.0, 0.1),\n        (1200.0, 0.6),\n        (500.0, 0.08),\n    ]\n\n    results = []\n    for fs, tau in test_cases:\n        N, H, feasible = configure_stft(fs, tau)\n        results.append([N, H, feasible])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}