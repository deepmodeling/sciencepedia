{
    "hands_on_practices": [
        {
            "introduction": "在二维系统中，零增长线（nullcline）是理解动力学行为的强大几何工具。通过本练习，我们将分析一个经典的兴奋性-抑制性（$E$-$I$）网络模型。我们将通过找到每个神经元群体活动变化率为零（例如 $\\frac{dE}{dt}=0$）的点集，来从几何上定位系统的平衡状态，即不动点 。",
            "id": "4163472",
            "problem": "考虑一个包含一个兴奋性群体和一个抑制性群体的皮层微环路活动的双群体发放率模型。令 $E(t)$ 和 $I(t)$ 分别表示兴奋性 (E) 和抑制性 (I) 群体的无量纲非负活动变量。其动力学由以下耦合常微分方程 (ODEs) 给出\n$$\n\\tau_{E}\\,\\frac{dE}{dt} \\;=\\; -E \\;+\\; \\phi_{E}\\!\\left(w_{EE}\\,E \\;-\\; w_{EI}\\,I \\;+\\; b_{E}\\right),\n$$\n$$\n\\tau_{I}\\,\\frac{dI}{dt} \\;=\\; -I \\;+\\; \\phi_{I}\\!\\left(w_{IE}\\,E \\;-\\; w_{II}\\,I \\;+\\; b_{I}\\right),\n$$\n其中静态输入输出函数 $\\phi_{E}$ 和 $\\phi_{I}$ 是线性阈值函数，\n$$\n\\phi_{X}(x) \\;=\\; \\left[g_{X}\\,\\big(x-\\theta_{X}\\big)\\right]_{+} \\;=\\; \\max\\!\\left(0,\\; g_{X}\\,\\big(x-\\theta_{X}\\big)\\right), \\quad X\\in\\{E,I\\}.\n$$\n假设参数值如下：$\\tau_{E} = 10$, $\\tau_{I} = 10$, $g_{E}=1$, $g_{I}=1$, $w_{EE}=\\frac{3}{2}$, $w_{EI}=1$, $w_{IE}=\\frac{6}{5}$, $w_{II}=1$, $b_{E}=\\frac{3}{5}$, $b_{I}=\\frac{2}{5}$, $\\theta_{E}=\\frac{1}{5}$，以及 $\\theta_{I}=\\frac{1}{10}$。\n\n从二维动力学系统中零斜线的定义和不动点的定义出发，完成以下任务：\n\n1) 假设两个群体都在非线性的活跃、非饱和线性区域内运作（即，$\\phi_{E}$ 和 $\\phi_{I}$ 的自变量超过其各自的阈值，因此 $\\max$ 算子不起作用），推导 $E$-零斜线（$\\frac{dE}{dt}=0$ 的集合）和 $I$-零斜线（$\\frac{dI}{dt}=0$ 的集合）的显式代数表达式。清晰地陈述为使此假设自洽必须满足的不等式。\n\n2) 仅使用第一性原理和推导出的零斜线，解释为什么 $E$-零斜线和 $I$-零斜线的交点对应于整个二维系统的不动点，然后计算位于所假设的线性区域内的不动点的坐标 $(E^{\\ast}, I^{\\ast})$。\n\n3) 以精确封闭形式的单个行矩阵 $\\big[E^{\\ast}\\;\\;I^{\\ast}\\big]$ 报告你找到的不动点。不需要四舍五入，活动变量是无量纲的，因此最终的数值报告中不应包含物理单位。",
            "solution": "该问题要求对一个二维发放率模型的零斜线和不动点进行推导和分析。该系统由以下耦合常微分方程 (ODEs) 定义：\n$$\n\\tau_{E}\\,\\frac{dE}{dt} \\;=\\; -E \\;+\\; \\phi_{E}\\!\\left(w_{EE}\\,E \\;-\\; w_{EI}\\,I \\;+\\; b_{E}\\right)\n$$\n$$\n\\tau_{I}\\,\\frac{dI}{dt} \\;=\\; -I \\;+\\; \\phi_{I}\\!\\left(w_{IE}\\,E \\;-\\; w_{II}\\,I \\;+\\; b_{I}\\right)\n$$\n输入输出函数 $\\phi_X$ 是线性阈值函数：\n$$\n\\phi_{X}(x) \\;=\\; \\max\\!\\left(0,\\; g_{X}\\,\\big(x-\\theta_{X}\\big)\\right), \\quad X\\in\\{E,I\\}\n$$\n给定的参数值为 $\\tau_{E} = 10$, $\\tau_{I} = 10$, $g_{E}=1$, $g_{I}=1$, $w_{EE}=\\frac{3}{2}$, $w_{EI}=1$, $w_{IE}=\\frac{6}{5}$, $w_{II}=1$, $b_{E}=\\frac{3}{5}$, $b_{I}=\\frac{2}{5}$, $\\theta_{E}=\\frac{1}{5}$，以及 $\\theta_{I}=\\frac{1}{10}$。\n\n第一个任务是在两个群体都在其线性区域内运作的假设下推导零斜线。这个假设意味着函数 $\\phi_E$ 和 $\\phi_I$ 的自变量大于它们各自的阈值，使得 $\\max(0, \\cdot)$ 算子变得多余。在数学上，非线性项的自变量是严格为正的。\n\n对于 $E$ 群体，其总输入为 $x_E = w_{EE}\\,E - w_{EI}\\,I + b_{E}$。线性区域的假设意味着 $g_E(x_E - \\theta_E)  0$。由于 $g_E=1  0$，这等价于 $x_E  \\theta_E$。\n对于 $I$ 群体，其总输入为 $x_I = w_{IE}\\,E - w_{II}\\,I + b_{I}$。线性区域的假设意味着 $g_I(x_I - \\theta_I)  0$。由于 $g_I=1  0$，这等价于 $x_I  \\theta_I$。\n\n因此，为使此假设自洽必须满足的不等式是：\n1. $w_{EE}\\,E - w_{EI}\\,I + b_{E}  \\theta_{E}$\n2. $w_{IE}\\,E - w_{II}\\,I + b_{I}  \\theta_{I}$\n\n在此假设下，函数 $\\phi_E$ 和 $\\phi_I$ 简化为其线性部分：\n$\\phi_E(x_E) = g_E(x_E - \\theta_E)$\n$\\phi_I(x_I) = g_I(x_I - \\theta_I)$\n\n现在，我们来推导零斜线。$E$-零斜线是满足 $\\frac{dE}{dt} = 0$ 的点 $(E, I)$ 的集合。将第一个 ODE 设为零：\n$$\n0 = -E + \\phi_{E}(w_{EE}\\,E - w_{EI}\\,I + b_{E})\n$$\n应用线性区域的简化：\n$$\nE = g_{E}(w_{EE}\\,E - w_{EI}\\,I + b_{E} - \\theta_{E})\n$$\n代入给定的参数值：$g_E=1, w_{EE}=\\frac{3}{2}, w_{EI}=1, b_E=\\frac{3}{5}, \\theta_E=\\frac{1}{5}$。\n$$\nE = 1 \\left(\\frac{3}{2}E - 1 \\cdot I + \\frac{3}{5} - \\frac{1}{5}\\right)\n$$\n$$\nE = \\frac{3}{2}E - I + \\frac{2}{5}\n$$\n解出 $I$ 以将零斜线表示为 $(E, I)$-平面上的一条直线：\n$$\nI = \\frac{3}{2}E - E + \\frac{2}{5} \\implies I = \\frac{1}{2}E + \\frac{2}{5}\n$$\n这就是在线性区域内 $E$-零斜线的代数表达式。\n\n$I$-零斜线是满足 $\\frac{dI}{dt} = 0$ 的点 $(E, I)$ 的集合。将第二个 ODE 设为零：\n$$\n0 = -I + \\phi_{I}(w_{IE}\\,E - w_{II}\\,I + b_{I})\n$$\n应用线性区域的简化：\n$$\nI = g_{I}(w_{IE}\\,E - w_{II}\\,I + b_{I} - \\theta_{I})\n$$\n代入给定的参数值：$g_I=1, w_{IE}=\\frac{6}{5}, w_{II}=1, b_I=\\frac{2}{5}, \\theta_I=\\frac{1}{10}$。\n$$\nI = 1 \\left(\\frac{6}{5}E - 1 \\cdot I + \\frac{2}{5} - \\frac{1}{10}\\right)\n$$\n$$\nI = \\frac{6}{5}E - I + \\left(\\frac{4}{10} - \\frac{1}{10}\\right)\n$$\n$$\n2I = \\frac{6}{5}E + \\frac{3}{10} \\implies I = \\frac{3}{5}E + \\frac{3}{20}\n$$\n这就是在线性区域内 $I$-零斜线的代数表达式。\n\n第二个任务是从第一性原理出发，解释为什么零斜线的交点对应于不动点，然后计算任何此类点的坐标。\n根据定义，动力学系统的不动点是状态空间中的一个点，记为 $(E^{\\ast}, I^{\\ast})$，在该点上系统的状态随时间保持不变。对于由常微分方程描述的系统，这要求该点的所有时间导数都为零。因此，不动点必须同时满足 $\\frac{dE}{dt} = 0$ 和 $\\frac{dI}{dt} = 0$。\n$E$-零斜线根据其定义，是所有满足 $\\frac{dE}{dt}=0$ 的点 $(E, I)$ 的轨迹。同样，$I$-零斜线是所有满足 $\\frac{dI}{dt}=0$ 的点的轨迹。\n$E$-零斜线和 $I$-零斜线的一个交点，由于其是交点，所以同时位于两条曲线上。因此，交点处的任何点都必须同时满足两个定义条件，即 $\\frac{dE}{dt}=0$ 和 $\\frac{dI}{dt}=0$。这正是不动点的定义。因此，零斜线的交点就是系统的不动点。\n\n为了找到线性区域内的不动点，我们求解由两条零斜线组成的线性方程组：\n1. $I = \\frac{1}{2}E + \\frac{2}{5}$\n2. $I = \\frac{3}{5}E + \\frac{3}{20}$\n\n令 $I$ 的表达式相等：\n$$\n\\frac{1}{2}E + \\frac{2}{5} = \\frac{3}{5}E + \\frac{3}{20}\n$$\n为了解出 $E$，我们将包含 $E$ 的项组合在一起：\n$$\n\\frac{2}{5} - \\frac{3}{20} = \\frac{3}{5}E - \\frac{1}{2}E\n$$\n通分：\n$$\n\\frac{8}{20} - \\frac{3}{20} = \\left(\\frac{6}{10} - \\frac{5}{10}\\right)E\n$$\n$$\n\\frac{5}{20} = \\frac{1}{10}E \\implies \\frac{1}{4} = \\frac{1}{10}E\n$$\n解出 $E^{\\ast}$：\n$$\nE^{\\ast} = \\frac{10}{4} = \\frac{5}{2}\n$$\n现在，将这个 $E^{\\ast}$ 的值代回到 $E$-零斜线的方程中以求出 $I^{\\ast}$：\n$$\nI^{\\ast} = \\frac{1}{2}E^{\\ast} + \\frac{2}{5} = \\frac{1}{2}\\left(\\frac{5}{2}\\right) + \\frac{2}{5} = \\frac{5}{4} + \\frac{2}{5}\n$$\n$$\nI^{\\ast} = \\frac{25}{20} + \\frac{8}{20} = \\frac{33}{20}\n$$\n不动点的坐标是 $(E^{\\ast}, I^{\\ast}) = \\left(\\frac{5}{2}, \\frac{33}{20}\\right)$。\n\n最后，我们必须验证这个不动点与线性区域的假设是自洽的。我们检查这两个不等式：\n1. $w_{EE}E^{\\ast} - w_{EI}I^{\\ast} + b_{E}  \\theta_{E}$\n$$\n\\frac{3}{2}\\left(\\frac{5}{2}\\right) - 1\\left(\\frac{33}{20}\\right) + \\frac{3}{5} = \\frac{15}{4} - \\frac{33}{20} + \\frac{12}{20} = \\frac{75}{20} - \\frac{33}{20} + \\frac{12}{20} = \\frac{54}{20} = \\frac{27}{10}\n$$\n条件是 $\\frac{27}{10}  \\theta_{E} = \\frac{1}{5} = \\frac{2}{10}$，这是成立的。\n\n2. $w_{IE}E^{\\ast} - w_{II}I^{\\ast} + b_{I}  \\theta_{I}$\n$$\n\\frac{6}{5}\\left(\\frac{5}{2}\\right) - 1\\left(\\frac{33}{20}\\right) + \\frac{2}{5} = 3 - \\frac{33}{20} + \\frac{8}{20} = \\frac{60}{20} - \\frac{33}{20} + \\frac{8}{20} = \\frac{35}{20} = \\frac{7}{4}\n$$\n条件是 $\\frac{7}{4}  \\theta_{I} = \\frac{1}{10}$。因为 $\\frac{7}{4} = 1.75$ 且 $\\frac{1}{10} = 0.1$，所以这个条件也成立。\n\n两个条件都满足。此外，活动变量必须是非负的，$E^{\\ast} = \\frac{5}{2}  0$ 且 $I^{\\ast} = \\frac{33}{20}  0$，这与发放率的物理解释一致。因此，计算出的不动点是假设的线性区域内唯一的不动点。\n\n第三个任务是要求以行矩阵的形式报告不动点。\n不动点是 $(E^{\\ast}, I^{\\ast}) = \\left(\\frac{5}{2}, \\frac{33}{20}\\right)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{5}{2}   \\frac{33}{20}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "对于更高维的系统，我们需要从几何直观转向更具普适性的代数分析方法。雅可比矩阵是在不动点附近线性化动力系统的关键，它能帮助我们判断不动点的稳定性。本练习将探讨一个采用现代修正线性单元（ReLU）激活函数的网络，并演示如何通过分析“激活”神经元子网络的性质来确定系统稳定性 。",
            "id": "4163476",
            "problem": "考虑一个具有按元素定义的整流线性单元 (ReLU) 激活函数的连续时间循环神经群体模型，其动力学系统由下式给出\n$$\\frac{d\\mathbf{x}}{dt}=-\\mathbf{x}+W\\,\\phi(\\mathbf{x})+\\mathbf{u},$$\n其中 $\\mathbf{x}\\in\\mathbb{R}^{n}$ 是群体活动， $W\\in\\mathbb{R}^{n\\times n}$ 是循环连接性， $\\mathbf{u}\\in\\mathbb{R}^{n}$ 是一个恒定输入，$\\phi(\\cdot)$ 是按元素应用的整流线性单元 (ReLU)，定义为 $\\phi(x_{i})=\\max\\{0,x_{i}\\}$。一个不动点 $\\mathbf{x}^{\\ast}$ 满足\n$$\\mathbf{0}=-\\mathbf{x}^{\\ast}+W\\,\\phi(\\mathbf{x}^{\\ast})+\\mathbf{u}.$$\n从这些定义出发，通过以活动集 $A=\\{i:\\,x^{\\ast}_{i}0\\}$ 为条件，推导该动力学系统在不动点 $\\mathbf{x}^{\\ast}$ 处的雅可比矩阵 $J(\\mathbf{x}^{\\ast})$。请将您的雅可比矩阵表示为分块形式，以明确显示 $W$ 限制在活动集上的子矩阵的贡献。\n\n然后，对于一个记录的 $n=4$ 的神经群体，假设循环连接性和一个观测到的不动点为\n$$W=\\begin{pmatrix}\n0.6   0.0   0.2   0.0\\\\\n0.1   0.0   -0.05   0.0\\\\\n-0.1   0.0   0.7   0.0\\\\\n0.0   0.0   0.15   0.0\n\\end{pmatrix},\\quad\n\\mathbf{x}^{\\ast}=\\begin{pmatrix}0.5\\\\-0.2\\\\0.3\\\\-0.1\\end{pmatrix},$$\n其中相应的输入 $\\mathbf{u}$ 被选择以精确满足不动点条件。请从 $\\mathbf{x}^{\\ast}$ 中确定活动集 $A$，通过以 $A$ 为条件构建 $J(\\mathbf{x}^{\\ast})$，并确定 $J(\\mathbf{x}^{\\ast})$ 的特征值中的最大实部（谱横坐标）。解释不动点的稳定性如何取决于与 $W$ 限制在活动集上的子矩阵相关的特征值。将 $J(\\mathbf{x}^{\\ast})$ 特征值的最大实部报告为一个四舍五入到四位有效数字的实数。不需要物理单位。",
            "solution": "该问题是有效的，因为它在科学上基于动力学系统理论和计算神经科学，问题提法适定，提供了所有必要信息，并以客观、正式的语言陈述。我们开始解答。\n\n动力学系统由以下方程描述：\n$$ \\frac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}) = -\\mathbf{x} + W\\,\\phi(\\mathbf{x}) + \\mathbf{u} $$\n向量场 $\\mathbf{f}(\\mathbf{x})$ 的雅可比矩阵 $J$ 是一个偏导数矩阵，其元素为 $J_{ij} = \\frac{\\partial f_i}{\\partial x_j}$。$\\mathbf{f}(\\mathbf{x})$ 的第 $i$ 个分量是：\n$$ f_i(\\mathbf{x}) = -x_i + \\sum_{k=1}^{n} W_{ik} \\phi(x_k) + u_i $$\n我们计算关于 $x_j$ 的偏导数：\n$$ \\frac{\\partial f_i}{\\partial x_j} = \\frac{\\partial}{\\partial x_j} \\left( -x_i + \\sum_{k=1}^{n} W_{ik} \\phi(x_k) + u_i \\right) $$\n利用导数的线性性质以及 $\\mathbf{u}$ 是一个常数向量，我们得到：\n$$ \\frac{\\partial f_i}{\\partial x_j} = -\\frac{\\partial x_i}{\\partial x_j} + \\sum_{k=1}^{n} W_{ik} \\frac{\\partial \\phi(x_k)}{\\partial x_j} $$\n项 $\\frac{\\partial x_i}{\\partial x_j}$ 是克罗内克δ函数 $\\delta_{ij}$。按元素激活函数 $\\phi(x_k)$ 关于 $x_j$ 的导数是：\n$$ \\frac{\\partial \\phi(x_k)}{\\partial x_j} = \\phi'(x_k) \\frac{\\partial x_k}{\\partial x_j} = \\phi'(x_k) \\delta_{kj} $$\n其中 $\\phi'(z)$ 是 ReLU 函数的导数。ReLU 函数 $\\phi(z) = \\max\\{0, z\\}$ 在 $z=0$ 处不可微。然而，对于 $z \\neq 0$，其导数是亥维赛阶跃函数：当 $z0$ 时 $\\phi'(z)=1$，当 $z0$ 时 $\\phi'(z)=0$。在不动点 $\\mathbf{x}^{\\ast}$ 处，我们通过考虑每个分量 $x_i^{\\ast}$ 的符号来评估雅可比矩阵。问题定义了活动集 $A = \\{i: x_i^{\\ast}  0\\}$，这排除了不可微的点。\n\n将其代回到 $J_{ij}$ 的表达式中：\n$$ J_{ij}(\\mathbf{x}) = -\\delta_{ij} + \\sum_{k=1}^{n} W_{ik} \\phi'(x_k) \\delta_{kj} $$\n对 $k$ 的求和会简化，只剩下 $k=j$ 的那一项：\n$$ J_{ij}(\\mathbf{x}) = -\\delta_{ij} + W_{ij} \\phi'(x_j) $$\n以矩阵形式，这可以写成：\n$$ J(\\mathbf{x}) = -I + W \\text{diag}(\\phi'(\\mathbf{x})) $$\n其中 $I$ 是单位矩阵，$\\text{diag}(\\phi'(\\mathbf{x}))$ 是一个对角矩阵，其对角线上的元素为 $\\phi'(x_j)$。\n\n在不动点 $\\mathbf{x}^{\\ast}$ 处，对角元素为：如果 $x_j^{\\ast}  0$ (即 $j \\in A$)，则 $\\phi'(x_j^{\\ast}) = 1$；如果 $x_j^{\\ast}  0$ (即 $j \\notin A$)，则 $\\phi'(x_j^{\\ast}) = 0$。令 $D^{\\ast} = \\text{diag}(\\phi'(\\mathbf{x}^{\\ast}))$。这是一个由1和0组成的对角矩阵，充当活动神经元的选择器。在不动点处的雅可比矩阵为：\n$$ J(\\mathbf{x}^{\\ast}) = -I + W D^{\\ast} $$\n为了将其表示为分块形式，我们将神经元划分为活动集 $A$ 和非活动集 $A^c = \\{i: x_i^{\\ast} \\leq 0\\}$。让我们重新排序神经元，使得所有在 $A$ 中的神经元排在前面。矩阵 $W$ 也相应地进行分块：\n$$ W = \\begin{pmatrix} W_{AA}  W_{AA^c} \\\\ W_{A^cA}  W_{A^cA^c} \\end{pmatrix} $$\n在这个重新排序的基中，矩阵 $D^{\\ast}$ 变为：\n$$ D^{\\ast} = \\begin{pmatrix} I_{|A|}  0 \\\\ 0  0 \\end{pmatrix} $$\n其中 $I_{|A|}$ 是大小为 $|A| \\times |A|$ 的单位矩阵。雅可比矩阵则为：\n$$ J(\\mathbf{x}^{\\ast}) = -\\begin{pmatrix} I_{|A|}  0 \\\\ 0  I_{|A^c|} \\end{pmatrix} + \\begin{pmatrix} W_{AA}  W_{AA^c} \\\\ W_{A^cA}  W_{A^cA^c} \\end{pmatrix} \\begin{pmatrix} I_{|A|}  0 \\\\ 0  0 \\end{pmatrix} $$\n$$ J(\\mathbf{x}^{\\ast}) = \\begin{pmatrix} -I_{|A|}  0 \\\\ 0  -I_{|A^c|} \\end{pmatrix} + \\begin{pmatrix} W_{AA}  0 \\\\ W_{A^cA}  0 \\end{pmatrix} = \\begin{pmatrix} W_{AA} - I_{|A|}  0 \\\\ W_{A^cA}  -I_{|A^c|} \\end{pmatrix} $$\n这就是所要求的雅可比矩阵的分块形式。\n\n现在，对于具体情况：\n$$ W=\\begin{pmatrix}\n0.6   0.0   0.2   0.0\\\\\n0.1   0.0   -0.05   0.0\\\\\n-0.1   0.0   0.7   0.0\\\\\n0.0   0.0   0.15   0.0\n\\end{pmatrix},\\quad\n\\mathbf{x}^{\\ast}=\\begin{pmatrix}0.5\\\\-0.2\\\\0.3\\\\-0.1\\end{pmatrix} $$\n活动集为 $A = \\{i: x_i^{\\ast}  0\\} = \\{1, 3\\}$。非活动集为 $A^c = \\{2, 4\\}$。\n导数矩阵 $D^{\\ast}$ 为：\n$$ D^{\\ast} = \\text{diag}(\\phi'(0.5), \\phi'(-0.2), \\phi'(0.3), \\phi'(-0.1)) = \\text{diag}(1, 0, 1, 0) = \\begin{pmatrix} 1  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  0 \\end{pmatrix} $$\n雅可比矩阵为 $J(\\mathbf{x}^{\\ast}) = -I + WD^{\\ast}$：\n$$ J(\\mathbf{x}^{\\ast}) = -\\begin{pmatrix} 1  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\end{pmatrix} + \\begin{pmatrix} 0.6   0.0   0.2   0.0\\\\ 0.1   0.0   -0.05   0.0\\\\ -0.1   0.0   0.7   0.0\\\\ 0.0   0.0   0.15   0.0 \\end{pmatrix} \\begin{pmatrix} 1  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  0 \\end{pmatrix} $$\n$$ J(\\mathbf{x}^{\\ast}) = -I + \\begin{pmatrix} 0.6  0  0.2  0 \\\\ 0.1  0  -0.05  0 \\\\ -0.1  0  0.7  0 \\\\ 0.0  0  0.15  0 \\end{pmatrix} = \\begin{pmatrix} -0.4  0  0.2  0 \\\\ 0.1  -1  -0.05  0 \\\\ -0.1  0  -0.3  0 \\\\ 0.0  0  0.15  -1 \\end{pmatrix} $$\n不动点 $\\mathbf{x}^{\\ast}$ 的稳定性由 $J(\\mathbf{x}^{\\ast})$ 的特征值决定。由于推导出的分块形式是分块下三角矩阵，其特征值是对角块 $(W_{AA} - I_{|A|})$ 和 $-I_{|A^c|}$ 的特征值的并集。\n对应于非活动神经元2和4的 $-I_{|A^c|}$ 的特征值就是 $-1$ (重数为 $|A^c|=2$）。这些对应于稳定模式。\n因此，不动点的稳定性由左上角块 $W_{AA} - I_{|A|}$ 的特征值决定。不动点是稳定的当且仅当该块的所有特征值都具有负实部。设 $\\lambda_{W_{AA}}$ 是 $W_{AA}$ 的一个特征值。$W_{AA} - I_{|A|}$ 的一个特征值是 $\\lambda_{W_{AA}} - 1$。为了保证稳定性，我们需要 $\\text{Re}(\\lambda_{W_{AA}} - 1)  0$，这意味着 $\\text{Re}(\\lambda_{W_{AA}})  1$。因此，不动点的稳定性取决于活动子网络连接矩阵 $W_{AA}$ 的所有特征值的实部是否都小于1。\n\n对于我们的具体情况，$A=\\{1,3\\}$，所以我们从 $W$ 中提取相应的子矩阵：\n$$ W_{AA} = \\begin{pmatrix} W_{11}  W_{13} \\\\ W_{31}  W_{33} \\end{pmatrix} = \\begin{pmatrix} 0.6  0.2 \\\\ -0.1  0.7 \\end{pmatrix} $$\n对应于活动集的雅可比矩阵的块是：\n$$ W_{AA} - I_2 = \\begin{pmatrix} 0.6-1  0.2 \\\\ -0.1  0.7-1 \\end{pmatrix} = \\begin{pmatrix} -0.4  0.2 \\\\ -0.1  -0.3 \\end{pmatrix} $$\n我们通过求解特征方程 $\\det((W_{AA} - I_2) - \\lambda I) = 0$ 来找到这个 $2 \\times 2$ 矩阵的特征值：\n$$ (-0.4 - \\lambda)(-0.3 - \\lambda) - (0.2)(-0.1) = 0 $$\n$$ \\lambda^2 + 0.7\\lambda + 0.12 + 0.02 = 0 $$\n$$ \\lambda^2 + 0.7\\lambda + 0.14 = 0 $$\n使用二次求根公式 $\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$：\n$$ \\lambda = \\frac{-0.7 \\pm \\sqrt{(0.7)^2 - 4(1)(0.14)}}{2} = \\frac{-0.7 \\pm \\sqrt{0.49 - 0.56}}{2} $$\n$$ \\lambda = \\frac{-0.7 \\pm \\sqrt{-0.07}}{2} = \\frac{-0.7 \\pm i\\sqrt{0.07}}{2} = -0.35 \\pm i\\frac{\\sqrt{0.07}}{2} $$\n来自活动块的两个特征值是一对共轭复数，其实部为 $-0.35$。\n来自非活动块的另外两个特征值是 $-1$ 和 $-1$。\n$J(\\mathbf{x}^{\\ast})$ 的完整特征值集合是 $\\{-0.35 + i\\frac{\\sqrt{0.07}}{2}, -0.35 - i\\frac{\\sqrt{0.07}}{2}, -1, -1\\}$。\n这些特征值的实部分别是 $\\{-0.35, -0.35, -1, -1\\}$。\n特征值中的最大实部（谱横坐标）是 $-0.35$。\n四舍五入到四位有效数字得到 $-0.3500$。",
            "answer": "$$\\boxed{-0.3500}$$"
        },
        {
            "introduction": "本节的压轴实践将理论分析与计算实现相结合，因为对复杂神经模型的分析通常离不开数值方法。此练习要求编写一个程序来实现数值延拓，这是一种强大的技术，用于追踪当系统参数变化时不动点及其稳定性的演变。通过这种方式，我们能够识别出系统发生动力学行为质变的临界点，即分岔点 。",
            "id": "4163515",
            "problem": "考虑以下二维发放率神经动力学系统，该系统具有S型非线性，由标量增益参数 $\\mu$ 参数化：\n$$\n\\frac{d}{dt}\\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix}\n-x + \\mu \\tanh(a x + b y + I_x) \\\\\n-y + \\mu \\tanh(c x + d y + I_y)\n\\end{bmatrix},\n$$\n其中 $x$ 和 $y$ 是状态变量，$\\tanh$ 是双曲正切函数，各常数固定为 $a = 0.7$、$b = 1.0$、$c = -1.2$、$d = 0.7$、$I_x = 0.0$ 和 $I_y = 0.0$。在给定 $\\mu$ 下，一个不动点 $(x^\\ast, y^\\ast)$ 满足向量方程\n$$\n\\mathbf{F}(x^\\ast, y^\\ast; \\mu) = \\begin{bmatrix}\n-x^\\ast + \\mu \\tanh(a x^\\ast + b y^\\ast + I_x) \\\\\n-y^\\ast + \\mu \\tanh(c x^\\ast + d y^\\ast + I_y)\n\\end{bmatrix} = \\mathbf{0}.\n$$\n在点 $(x, y)$ 处的雅可比矩阵由下式给出\n$$\nJ(x, y; \\mu) = \\begin{bmatrix}\n-1 + \\mu a \\, \\mathrm{sech}^2(z_1)   \\mu b \\, \\mathrm{sech}^2(z_1) \\\\\n\\mu c \\, \\mathrm{sech}^2(z_2)   -1 + \\mu d \\, \\mathrm{sech}^2(z_2)\n\\end{bmatrix},\n$$\n其中 $z_1 = a x + b y + I_x$ 且 $z_2 = c x + d y + I_y$，并且 $\\mathrm{sech}^2(u) = 1 - \\tanh^2(u)$。当且仅当 $J(x^\\ast, y^\\ast; \\mu)$ 的所有特征值的实部都严格为负时，一个不动点在连续时间内是（局部）渐近稳定的。\n\n任务：仅使用上述基本定义，编写一个完整的程序，在参数 $\\mu$ 上实现数值延拓，以计算不动点的轨迹及其稳定性，并从特征值交叉中识别分岔点。您必须遵守以下要求：\n\n$1.$ 不动点计算。对于每个指定的 $\\mu$，使用带有解析雅可比矩阵和回溯线搜索的 Newton–Raphson 方法求解 $\\mathbf{F}(x, y; \\mu) = \\mathbf{0}$ 来找到所有不动点。残差的欧几里得范数收敛容差为 $10^{-10}$，每次尝试最多迭代 $50$ 次。在状态空间中使用 $10^{-6}$ 的聚类容差来对收敛的解进行去重。\n\n$2.$ 种子点策略。对于每个 $\\mu$，从一个种子点集开始尝试 Newton–Raphson 方法，该集合由笛卡尔网格 $\\{-2, 0, 2\\} \\times \\{-2, 0, 2\\}$ 以及（对于第一个 $\\mu$ 之后的所有值）在前一个 $\\mu$ 值处找到的不动点共同组成。\n\n$3.$ 稳定性分类。对于每个不动点，计算雅可比矩阵的特征值，并且当且仅当所有特征值的实部均为负时，将该不动点分类为稳定。\n\n$4.$ 跨 $\\mu$ 值的分岔识别。考虑 $\\mu$ 值的有序列表，并对每个连续的对，在两个 $\\mu$ 值之间对不动点进行最近邻匹配，以形成近似分支。对于分支上的每个匹配对，计算两端的雅可比矩阵的迹和行列式。如果在该分支上的这对点之间同时满足以下条件，则宣布发生 Hopf 分岔穿越：两端的行列式均为严格正值，两端的迹符号相反，且两端的判别式 $\\Delta = \\mathrm{trace}^2 - 4 \\, \\mathrm{det}$ 均为严格负值。在这种情况下，通过对迹进行线性插值到零来估计穿越位置。如果两端的行列式符号相反，则宣布在该分支上的这对点之间发生鞍-节（折叠）分岔穿越，并通过对行列式进行线性插值到零来估计穿越位置。\n\n$5.$ 测试套件。使用以下有序的参数值测试套件：\n$$\n\\{\\mu\\} = \\{0.2, 1.0, 1.3, 1.45, 1.6, 2.0\\}.\n$$\n\n$6.$ 最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。输出必须是以下顺序的嵌套列表：\n$[C, S, H, N]$,\n其中 $C$ 是在每个 $\\mu$ 值下找到的唯一不动点数量的列表；$S$ 是在每个 $\\mu$ 值下稳定不动点数量的列表；$H$ 是在连续 $\\mu$ 值之间检测到 Hopf 穿越的估计 $\\mu$ 值（浮点数）的列表；$N$ 是在连续 $\\mu$ 值之间检测到鞍-节穿越的估计 $\\mu$ 值（浮点数）的列表。如果未检测到给定类型的分岔，则相应的列表必须为空。程序必须以指定格式精确打印一行。\n\n所有量均为无量纲。不涉及物理单位。不使用角度。问题中任何地方均不使用百分比。解决方案必须仅基于不动点、雅可比矩阵和连续时间动力学系统特征值的核心定义和广泛接受的性质，不得使用任何简化推导的快捷公式。确保所有上述指定的常数和数值阈值都按原文精确使用。",
            "solution": "用户在计算神经科学领域提供了一个定义明确的问题，要求对一个二维发放率神经动力学系统进行数值分析。任务是实现一个数值延拓算法，以跟踪不动点及其稳定性随增益参数 $\\mu$ 变化的情况，并识别分岔点。\n\n### **问题验证**\n\n**步骤1：提取的既定条件**\n- **动力学系统：** 状态变量 $x(t)$ 和 $y(t)$ 根据以下公式演化：\n$$\n\\frac{d}{dt}\\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\mathbf{F}(x, y; \\mu) = \\begin{bmatrix}\n-x + \\mu \\tanh(a x + b y + I_x) \\\\\n-y + \\mu \\tanh(c x + d y + I_y)\n\\end{bmatrix}\n$$\n- **系统参数：** $a = 0.7$, $b = 1.0$, $c = -1.2$, $d = 0.7$, $I_x = 0.0$, $I_y = 0.0$。\n- **不动点条件：** 如果 $\\mathbf{F}(x^\\ast, y^\\ast; \\mu) = \\mathbf{0}$，则点 $(x^\\ast, y^\\ast)$ 是一个不动点。\n- **雅可比矩阵：** 在点 $(x, y)$ 处 $\\mathbf{F}$ 的雅可比矩阵为：\n$$\nJ(x, y; \\mu) = \\begin{bmatrix}\n-1 + \\mu a \\, \\mathrm{sech}^2(z_1)   \\mu b \\, \\mathrm{sech}^2(z_1) \\\\\n\\mu c \\, \\mathrm{sech}^2(z_2)   -1 + \\mu d \\, \\mathrm{sech}^2(z_2)\n\\end{bmatrix}\n$$\n其中 $z_1 = a x + b y + I_x$，$z_2 = c x + d y + I_y$，且 $\\mathrm{sech}^2(u) = 1 - \\tanh^2(u)$。\n- **稳定性判据：** 当且仅当在该点计算的雅可比矩阵的所有特征值的实部都严格为负时，一个不动点是渐近稳定的。\n- **不动点数值方法：** 带有解析雅可比矩阵和回溯线搜索的 Newton-Raphson 方法。收敛要求残差的欧几里得范数 $||\\mathbf{F}||_2$ 小于 $10^{-10}$，最大迭代次数为 $50$ 次。\n- **不动点去重：** 如果解在状态空间中的欧几里得距离超过 $10^{-6}$ 的聚类容差，则认为它们是唯一的。\n- **种子点策略：** 对于每个 $\\mu$，Newton-Raphson 方法的初始猜测值取自笛卡尔网格 $\\{-2, 0, 2\\} \\times \\{-2, 0, 2\\}$，并加上在前一个 $\\mu$ 值找到的所有唯一不动点。\n- **分岔检测：** 在连续的 $\\mu$ 值之间，通过最近邻距离匹配不动点以形成分支。\n    - **Hopf 分岔：** 如果一个分支上两端的行列式均为正，迹的符号相反，且判别式 ($\\Delta = \\mathrm{trace}^2 - 4\\,\\mathrm{det}$) 均为负，则检测到该分支上发生 Hopf 分岔。通过将迹线性插值到零来估计其位置。\n    - **鞍-节分岔：** 如果两端的行列式符号相反，则检测到该分支上发生鞍-节分岔。通过将行列式线性插值到零来估计其位置。\n- **测试套件：** 在有序参数集 $\\mu \\in \\{0.2, 1.0, 1.3, 1.45, 1.6, 2.0\\}$ 上进行分析。\n- **输出格式：** 单行打印一个嵌套列表 $[C, S, H, N]$，其中 $C$ 和 $S$ 是每个 $\\mu$ 值的总不动点数和稳定不动点数的列表，$H$ 和 $N$ 分别是估计的 Hopf 分岔点和鞍-节分岔点的列表。\n\n**步骤2：使用提取的既定条件进行验证**\n- **科学依据：** 该问题描述了一个 Wilson-Cowan 类型的发放率模型，这是理论神经科学的基石。所用的分析技术——不动点分析、通过线性化（雅可比矩阵）分析稳定性以及用于寻找分岔的数值延拓——是动力学系统研究中的标准和基本方法。该问题在科学上和数学上都是合理的。\n- **适定性与完整性：** 该问题具有极好的适定性。它提供了所有必要的方程、常数、数值方法参数（容差、迭代限制）和一个精确的测试套件。指令明确无歧义且内部一致，指定了一个清晰且确定性的计算任务。\n- **客观性：** 该问题以纯粹客观的数学术语表述，不含任何主观语言或观点。\n\n**步骤3：结论与行动**\n该问题是**有效的**。这是一个定义明确、有科学依据且内容充实的、应用于神经科学的数值分析任务。下一节提供了将在最终程序中实现的完整、论证充分的解决方案。\n\n### **方法论与算法设计**\n\n该解决方案要求随着参数 $\\mu$ 的变化，对系统的状态空间进行系统的数值探索。这是通过数值延拓程序实现的，该程序涉及在 $\\mu$ 的离散值上寻找不动点，并跟踪这些不动点在不同值之间的性质。\n\n**1. 函数与雅可比矩阵的实现**\n首先，我们实现函数来计算给定状态向量 $\\mathbf{x} = [x, y]^T$ 和参数 $\\mu$ 下系统的向量场 $\\mathbf{F}(\\mathbf{x}; \\mu)$ 及其解析雅可比矩阵 $J(\\mathbf{x}; \\mu)$。\n设 $\\mathbf{x} = [x_0, x_1]^T$。向量场为：\n$$\n\\mathbf{F}(\\mathbf{x}; \\mu) = \\begin{bmatrix}\n-x_0 + \\mu \\tanh(a x_0 + b x_1) \\\\\n-x_1 + \\mu \\tanh(c x_0 + d x_1)\n\\end{bmatrix}\n$$\n双曲正切的自变量为 $z_1 = a x_0 + b x_1$ 和 $z_2 = c x_0 + d x_1$。雅可比矩阵为：\n$$\nJ(\\mathbf{x}; \\mu) = \\begin{bmatrix}\n-1 + \\mu a (1 - \\tanh^2(z_1))   \\mu b (1 - \\tanh^2(z_1)) \\\\\n\\mu c (1 - \\tanh^2(z_2))   -1 + \\mu d (1 - \\tanh^2(z_2))\n\\end{bmatrix}\n$$\n\n**2. 不动点求解器：带线搜索的 Newton-Raphson 方法**\n为找到求解 $\\mathbf{F}(\\mathbf{x}^\\ast; \\mu) = \\mathbf{0}$ 的不动点 $\\mathbf{x}^\\ast$，我们采用 Newton-Raphson 方法。从一个初始猜测 $\\mathbf{x}_k$ 开始，通过求解更新步长 $\\Delta \\mathbf{x}_k$ 的线性系统来找到下一个迭代点 $\\mathbf{x}_{k+1}$：\n$$\nJ(\\mathbf{x}_k; \\mu) \\Delta \\mathbf{x}_k = -\\mathbf{F}(\\mathbf{x}_k; \\mu)\n$$\n更新后的状态为 $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha \\Delta \\mathbf{x}_k$。步长 $\\alpha \\in (0, 1]$ 通过回溯线搜索确定，以确保稳健收敛。从 $\\alpha=1$ 开始，我们连续减小它（例如，每次乘以因子 $0.5$），直到残差范数实现充分下降，即 $||\\mathbf{F}(\\mathbf{x}_k + \\alpha \\Delta \\mathbf{x}_k)||_2  ||\\mathbf{F}(\\mathbf{x}_k)||_2$。如果 $||\\mathbf{F}(\\mathbf{x}_k)||_2  10^{-10}$，则迭代成功终止；如果达到最大迭代次数 $50$ 次，则失败。\n\n**3. 数值延拓循环**\n程序的核心是一个循环，遍历指定的有序 $\\mu$ 值列表。对于每个 $\\mu_i$：\n- **种子点生成：** 为 Newton-Raphson 求解器构建一个初始猜测集。该集合包括一个静态点网格 $\\{(-2,-2), (-2,0), ..., (2,2)\\}$，以确保对状态空间进行广泛探索。关键地，为便于跟踪解分支，该集合还增加了在前一个参数值 $\\mu_{i-1}$ 处发现的唯一不动点。\n- **求解：** 从每个唯一的种子点运行 Newton-Raphson 求解器。收集所有成功收敛的解。\n- **去重：** 收敛点的集合可能包含重复项。通过应用聚类算法来移除这些重复项：对点进行排序，任何与已接受的唯一点的欧几里得距离在 $10^{-6}$ 之内的点都将被丢弃。\n- **存储结果：** 找到的唯一不动点数量存储在列表 $C$ 中。\n\n**4. 稳定性与分岔分析**\n对于在 $\\mu_i$ 处找到的每个唯一不动点 $\\mathbf{x}^\\ast$：\n- **稳定性：** 计算雅可比矩阵 $J(\\mathbf{x}^\\ast; \\mu_i)$。计算其特征值 $\\lambda_1, \\lambda_2$。当且仅当 $\\mathrm{Re}(\\lambda_1)  0$ 且 $\\mathrm{Re}(\\lambda_2)  0$ 时，该不动点被分类为稳定。稳定不动点的数量存储在列表 $S$ 中。对于一个 $2 \\times 2$ 矩阵，此条件等价于要求其迹为负且行列式为正。\n- **分支匹配：** 对于 $i > 0$，我们比较在 $\\mu_{i-1}$ 处的不动点集和在 $\\mu_i$ 处的不动点集。对于在 $\\mu_{i-1}$ 处的每个不动点，我们在 $\\mu_i$ 处的不动点集中找到其最近邻（按欧几里得距离）。这会创建一组匹配对，代表不动点分支的片段。\n- **分岔检测：** 对于每个匹配对 $(\\mathbf{x}_{i-1}^\\ast, \\mathbf{x}_i^\\ast)$，我们分析雅可比矩阵 $J_{i-1}$ 和 $J_i$。\n    - **Hopf 穿越：** 如果 $\\mathrm{det}(J_{i-1})  0$、$\\mathrm{det}(J_i)  0$、$\\mathrm{trace}(J_{i-1})$ 和 $\\mathrm{trace}(J_i)$ 符号相反，且判别式 $\\Delta_{i-1}, \\Delta_i$ 均为负，则标记一个穿越。通过将迹线性插值到 $0$ 来找到估计的分岔点 $\\mu_H$：\n    $$\n    \\mu_H = \\mu_{i-1} - \\mathrm{trace}(J_{i-1}) \\frac{\\mu_i - \\mu_{i-1}}{\\mathrm{trace}(J_i) - \\mathrm{trace}(J_{i-1})}\n    $$\n    - **鞍-节穿越：** 如果 $\\mathrm{det}(J_{i-1})$ 和 $\\mathrm{det}(J_i)$ 符号相反，则标记一个穿越。通过将行列式线性插值到 $0$ 来找到估计的分岔点 $\\mu_N$：\n    $$\n    \\mu_N = \\mu_{i-1} - \\mathrm{det}(J_{i-1}) \\frac{\\mu_i - \\mu_{i-1}}{\\mathrm{det}(J_i) - \\mathrm{det}(J_{i-1})}\n    $$\n估计的分岔值 $\\mu_H$ 和 $\\mu_N$ 分别收集在列表 $H$ 和 $N$ 中。\n\n**5. 输出格式化**\n最后，将收集到的列表 $C$、 $S$、 $H$ 和 $N$ 组装成所需的嵌套列表结构，并作为单行文本打印到标准输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Performs numerical continuation and bifurcation analysis for the given\n    2D neural dynamical system.\n    \"\"\"\n    # System parameters\n    a = 0.7\n    b = 1.0\n    c = -1.2\n    d = 0.7\n    I_x = 0.0\n    I_y = 0.0\n\n    # Numerical parameters\n    CONV_TOL = 1e-10\n    MAX_ITER = 50\n    CLUSTER_TOL = 1e-6\n    \n    # Test suite of mu values\n    mu_values = [0.2, 1.0, 1.3, 1.45, 1.6, 2.0]\n\n    def F(x_vec, mu):\n        \"\"\"Computes the vector field F(x, y; mu).\"\"\"\n        x, y = x_vec[0], x_vec[1]\n        z1 = a * x + b * y + I_x\n        z2 = c * x + d * y + I_y\n        f1 = -x + mu * np.tanh(z1)\n        f2 = -y + mu * np.tanh(z2)\n        return np.array([f1, f2])\n\n    def compute_jacobian(x_vec, mu):\n        \"\"\"Computes the analytic Jacobian J(x, y; mu).\"\"\"\n        x, y = x_vec[0], x_vec[1]\n        z1 = a * x + b * y + I_x\n        z2 = c * x + d * y + I_y\n        sech2_z1 = 1.0 - np.tanh(z1)**2\n        sech2_z2 = 1.0 - np.tanh(z2)**2\n        \n        j11 = -1.0 + mu * a * sech2_z1\n        j12 = mu * b * sech2_z1\n        j21 = mu * c * sech2_z2\n        j22 = -1.0 + mu * d * sech2_z2\n        \n        return np.array([[j11, j12], [j21, j22]])\n\n    def newton_raphson(seed, mu):\n        \"\"\"\n        Finds a fixed point using Newton-Raphson with backtracking line search.\n        \"\"\"\n        x_k = np.array(seed, dtype=float)\n        \n        for _ in range(MAX_ITER):\n            f_k = F(x_k, mu)\n            norm_f = np.linalg.norm(f_k)\n\n            if norm_f  CONV_TOL:\n                return x_k, True\n\n            try:\n                J_k = compute_jacobian(x_k, mu)\n                # Solve the linear system J * delta_x = -F\n                delta_x = np.linalg.solve(J_k, -f_k)\n            except np.linalg.LinAlgError:\n                return x_k, False # Jacobian is singular\n\n            # Backtracking line search\n            alpha = 1.0\n            for _ in range(10): # Max 10 backtracking steps\n                x_next = x_k + alpha * delta_x\n                if np.linalg.norm(F(x_next, mu))  norm_f:\n                    break\n                alpha *= 0.5\n            else: # No suitable step size found\n                return x_k, False\n            \n            x_k = x_next\n            \n        return x_k, np.linalg.norm(F(x_k, mu))  CONV_TOL\n\n    def deduplicate_points(points):\n        \"\"\"Deduplicates a list of points based on clustering tolerance.\"\"\"\n        if not points:\n            return []\n        \n        # Sort points to make clustering easier\n        sorted_points = sorted(points, key=lambda p: (p[0], p[1]))\n        \n        unique_points = [sorted_points[0]]\n        for point in sorted_points[1:]:\n            dist = np.linalg.norm(np.array(point) - np.array(unique_points[-1]))\n            if dist > CLUSTER_TOL:\n                unique_points.append(point)\n        return unique_points\n\n    # Result lists\n    C_list = []  # Number of unique fixed points\n    S_list = []  # Number of stable fixed points\n    H_list = []  # Hopf bifurcation points\n    N_list = []  # Saddle-node bifurcation points\n\n    previous_analyzed_points = []\n    previous_mu = None\n\n    # Base seed grid\n    grid_seeds = [(x, y) for x in [-2.0, 0.0, 2.0] for y in [-2.0, 0.0, 2.0]]\n\n    for mu in mu_values:\n        # 1. Generate seeds\n        seeds = list(grid_seeds)\n        if previous_analyzed_points:\n            seeds.extend([p['point'] for p in previous_analyzed_points])\n        \n        # 2. Find fixed points from all seeds\n        converged_points = []\n        for seed in seeds:\n            point, converged = newton_raphson(seed, mu)\n            if converged:\n                converged_points.append(tuple(point))\n        \n        # 3. Deduplicate fixed points\n        unique_points_tuples = deduplicate_points(list(set(converged_points)))\n        unique_points = [np.array(p) for p in unique_points_tuples]\n        C_list.append(len(unique_points))\n\n        # 4. Analyze stability and properties\n        stable_count = 0\n        analyzed_points = []\n        for fp in unique_points:\n            J = compute_jacobian(fp, mu)\n            trace = np.trace(J)\n            det = np.linalg.det(J)\n            \n            # Stability check using Routh-Hurwitz criteria (equiv. to eigenvalue check)\n            if trace  0 and det > 0:\n                stable_count += 1\n            \n            analyzed_points.append({'point': fp, 'trace': trace, 'det': det})\n\n        S_list.append(stable_count)\n\n        # 5. Bifurcation detection\n        if previous_analyzed_points:\n            # Nearest-neighbor matching\n            prev_fps = np.array([p['point'] for p in previous_analyzed_points])\n            curr_fps = np.array([p['point'] for p in analyzed_points])\n            \n            if prev_fps.size > 0 and curr_fps.size > 0:\n                dist_matrix = cdist(prev_fps, curr_fps)\n                nn_indices = np.argmin(dist_matrix, axis=1)\n\n                for i, j in enumerate(nn_indices):\n                    p_prev = previous_analyzed_points[i]\n                    p_curr = analyzed_points[j]\n\n                    tr_prev, det_prev = p_prev['trace'], p_prev['det']\n                    tr_curr, det_curr = p_curr['trace'], p_curr['det']\n                    \n                    # Hopf bifurcation check\n                    disc_prev = tr_prev**2 - 4 * det_prev\n                    disc_curr = tr_curr**2 - 4 * det_curr\n                    if (det_prev > 0 and det_curr > 0 and\n                        np.sign(tr_prev) != np.sign(tr_curr) and\n                        disc_prev  0 and disc_curr  0):\n                        \n                        mu_H = previous_mu - tr_prev * (mu - previous_mu) / (tr_curr - tr_prev)\n                        H_list.append(mu_H)\n                    \n                    # Saddle-node bifurcation check\n                    if np.sign(det_prev) != np.sign(det_curr):\n                        # Avoid division by zero if dets are identical\n                        if not np.isclose(det_curr, det_prev):\n                            mu_N = previous_mu - det_prev * (mu - previous_mu) / (det_curr - det_prev)\n                            N_list.append(mu_N)\n        \n        # 6. Update for next iteration\n        previous_analyzed_points = sorted(analyzed_points, key=lambda p: (p['point'][0], p['point'][1]))\n        previous_mu = mu\n\n    # Final output formatting\n    # Using repr() to get standard float representation.\n    def format_list(lst):\n        return f\"[{','.join(map(repr, sorted(lst)))}]\"\n\n    C_str = f\"[{','.join(map(str, C_list))}]\"\n    S_str = f\"[{','.join(map(str, S_list))}]\"\n    H_str = format_list(H_list)\n    N_str = format_list(N_list)\n\n    print(f\"[{C_str},{S_str},{H_str},{N_str}]\")\n\nsolve()\n```"
        }
    ]
}