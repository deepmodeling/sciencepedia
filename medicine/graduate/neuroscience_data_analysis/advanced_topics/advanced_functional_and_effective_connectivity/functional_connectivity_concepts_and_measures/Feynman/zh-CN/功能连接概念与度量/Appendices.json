{
    "hands_on_practices": [
        {
            "introduction": "皮尔逊相关性是衡量功能连接的常用初步指标。然而，由于共同驱动因素或混杂变量的存在，它可能会产生误导。本练习通过一个具体的数值示例，展示了一个强相关性如何可能完全是伪关系，以及部分相关性如何揭示真实的潜在关系（或其缺失）。通过从头开始计算这些值，您将深入理解为何在解释功能连接时，控制共享影响至关重要。",
            "id": "4165717",
            "problem": "考虑一个简单的功能性连接 (FC) 场景，其中一个潜在一的共同驱动信号导致两个观测节点之间产生强相关性。假设有三个在 $n=5$ 个时间点采样的标量时间序列，对于 $t \\in \\{1,2,3,4,5\\}$，记为 $X(t)$、$Y(t)$ 和 $Z(t)$。假设其生成结构如下：$X(t) = Z(t) + \\epsilon_{X}(t)$ 和 $Y(t) = Z(t) + \\epsilon_{Y}(t)$，其中 $\\epsilon_{X}(t)$ 和 $\\epsilon_{Y}(t)$ 是小的扰动。观测值如下：\n- $Z$: $(-2, -1, 0, 1, 2)$,\n- $\\epsilon_{X}$: $(0.1, -0.2, 0, 0.2, -0.1)$,\n- $\\epsilon_{Y}$: $(0.15, -0.15, 0, -0.15, 0.15)$,\n因此\n- $X$: $(-1.9, -1.2, 0, 1.2, 1.9)$,\n- $Y$: $(-1.85, -1.15, 0, 0.85, 2.15)$。\n\n从样本均值、样本协方差、Pearson 相关性和普通最小二乘线性回归的核心定义出发（即，将 $X$ 拟合为 $Z$ 的线性函数，将 $Y$ 拟合为 $Z$ 的线性函数，然后形成残差），完成以下任务：\n1. 计算 $X$ 和 $Y$ 之间的 Pearson 相关性，以说明由共同驱动 $Z$ 引起的表观强功能性连接。\n2. 通过首先将 $X$ 对 $Z$ 回归以及将 $Y$ 对 $Z$ 回归，形成残差时间序列，然后计算这些残差之间的 Pearson 相关性，来计算以 $Z$ 为条件的 $X$ 和 $Y$ 之间的偏相关。\n\n将最终答案表示为偏相关值，它是一个无量纲量。如果需要四舍五入，将最终数值答案保留四位有效数字。其他中间结果无需进行四舍五入。",
            "solution": "该问题被验证为有科学依据、良定、客观且自洽的。所提供的数据和生成模型是用于阐释功能性连接分析中概念的标准模型。我们可以开始求解。\n\n目标是计算时间序列 $X(t)$ 和 $Y(t)$ 之间的 Pearson 相关性，然后计算以 $Z(t)$ 为条件的 $X(t)$ 和 $Y(t)$ 之间的偏相关。问题涉及 $n=5$ 个时间点。\n\n给定的时间序列是：\n$X = (-1.9, -1.2, 0, 1.2, 1.9)$\n$Y = (-1.85, -1.15, 0, 0.85, 2.15)$\n$Z = (-2, -1, 0, 1, 2)$\n\n首先，我们计算每个时间序列的样本均值。对于一个长度为 $n$ 的时间序列 $V(t)$，其样本均值 $\\bar{V}$ 定义为 $\\bar{V} = \\frac{1}{n} \\sum_{t=1}^{n} V(t)$。\n对于 $X(t)$：\n$$ \\bar{X} = \\frac{1}{5} (-1.9 - 1.2 + 0 + 1.2 + 1.9) = \\frac{0}{5} = 0 $$\n对于 $Y(t)$：\n$$ \\bar{Y} = \\frac{1}{5} (-1.85 - 1.15 + 0 + 0.85 + 2.15) = \\frac{0}{5} = 0 $$\n对于 $Z(t)$：\n$$ \\bar{Z} = \\frac{1}{5} (-2 - 1 + 0 + 1 + 2) = \\frac{0}{5} = 0 $$\n所有样本均值均为零这一事实简化了后续的计算。\n\n**1. $X$ 与 $Y$ 之间的 Pearson 相关性**\n\n两个序列 $X(t)$ 和 $Y(t)$ 之间的 Pearson 相关系数 $\\rho_{XY}$ 定义为：\n$$ \\rho_{XY} = \\frac{\\sum_{t=1}^{n}(X(t) - \\bar{X})(Y(t) - \\bar{Y})}{\\sqrt{\\sum_{t=1}^{n}(X(t) - \\bar{X})^2 \\sum_{t=1}^{n}(Y(t) - \\bar{Y})^2}} $$\n由于 $\\bar{X} = 0$ 和 $\\bar{Y} = 0$，上式简化为：\n$$ \\rho_{XY} = \\frac{\\sum_{t=1}^{n}X(t)Y(t)}{\\sqrt{\\left(\\sum_{t=1}^{n}X(t)^2\\right) \\left(\\sum_{t=1}^{n}Y(t)^2\\right)}} $$\n我们计算必要的总和：\n分子项，即乘积之和：\n$$ \\sum_{t=1}^{5}X(t)Y(t) = (-1.9)(-1.85) + (-1.2)(-1.15) + (0)(0) + (1.2)(0.85) + (1.9)(2.15) $$\n$$ = 3.515 + 1.38 + 0 + 1.02 + 4.085 = 10.0 $$\n$X(t)$ 的平方和：\n$$ \\sum_{t=1}^{5}X(t)^2 = (-1.9)^2 + (-1.2)^2 + 0^2 + 1.2^2 + 1.9^2 $$\n$$ = 3.61 + 1.44 + 0 + 1.44 + 3.61 = 10.1 $$\n$Y(t)$ 的平方和：\n$$ \\sum_{t=1}^{5}Y(t)^2 = (-1.85)^2 + (-1.15)^2 + 0^2 + (0.85)^2 + (2.15)^2 $$\n$$ = 3.4225 + 1.3225 + 0 + 0.7225 + 4.6225 = 10.09 $$\n现在，我们计算 Pearson 相关性：\n$$ \\rho_{XY} = \\frac{10.0}{\\sqrt{(10.1)(10.09)}} = \\frac{10.0}{\\sqrt{101.909}} \\approx 0.99058 $$\n这证实了由共同驱动 $Z(t)$ 引起的表观强功能性连接。\n\n**2. 以 $Z$ 为条件的 $X$ 和 $Y$ 之间的偏相关**\n\n为了求出偏相关 $\\rho_{XY|Z}$，我们首先对 $X$ 和 $Z$ 以及 $Y$ 和 $Z$ 进行普通最小二乘 (OLS) 回归，然后计算所得残差的 Pearson 相关性。\n\n**$X$ 对 $Z$ 的回归**：\n我们拟合模型 $X(t) = \\alpha_{XZ} + \\beta_{XZ} Z(t)$。截距 $\\alpha_{XZ}$ 和斜率 $\\beta_{XZ}$ 的 OLS 估计值为：\n$$ \\beta_{XZ} = \\frac{\\sum_{t=1}^{n}(X(t) - \\bar{X})(Z(t) - \\bar{Z})}{\\sum_{t=1}^{n}(Z(t) - \\bar{Z})^2} \\quad \\text{且} \\quad \\alpha_{XZ} = \\bar{X} - \\beta_{XZ} \\bar{Z} $$\n由于 $\\bar{X} = 0$ 和 $\\bar{Z} = 0$，我们有 $\\alpha_{XZ} = 0$。斜率简化为：\n$$ \\beta_{XZ} = \\frac{\\sum_{t=1}^{n}X(t)Z(t)}{\\sum_{t=1}^{n}Z(t)^2} $$\n我们计算所需的求和：\n$$ \\sum_{t=1}^{5}Z(t)^2 = (-2)^2 + (-1)^2 + 0^2 + 1^2 + 2^2 = 4 + 1 + 0 + 1 + 4 = 10 $$\n$$ \\sum_{t=1}^{5}X(t)Z(t) = (-1.9)(-2) + (-1.2)(-1) + (0)(0) + (1.2)(1) + (1.9)(2) $$\n$$ = 3.8 + 1.2 + 0 + 1.2 + 3.8 = 10 $$\n因此，斜率为 $\\beta_{XZ} = \\frac{10}{10} = 1$。预测值为 $\\hat{X}(t) = 1 \\cdot Z(t) = Z(t)$。\n$X$ 的残差，我们记为 $R_X(t)$，是：\n$$ R_X(t) = X(t) - \\hat{X}(t) = X(t) - Z(t) $$\n使用给定的值，残差序列为：\n$R_X = (-1.9 - (-2), -1.2 - (-1), 0 - 0, 1.2 - 1, 1.9 - 2) = (0.1, -0.2, 0, 0.2, -0.1)$。\n根据构造，这就是噪声序列 $\\epsilon_X(t)$。\n\n**$Y$ 对 $Z$ 的回归**：\n类似地，对于模型 $Y(t) = \\alpha_{YZ} + \\beta_{YZ} Z(t)$，由于 $\\bar{Y} = 0$ 和 $\\bar{Z} = 0$，我们有 $\\alpha_{YZ} = 0$。斜率为：\n$$ \\beta_{YZ} = \\frac{\\sum_{t=1}^{n}Y(t)Z(t)}{\\sum_{t=1}^{n}Z(t)^2} $$\n分母已知为 $10$。我们计算分子：\n$$ \\sum_{t=1}^{5}Y(t)Z(t) = (-1.85)(-2) + (-1.15)(-1) + (0)(0) + (0.85)(1) + (2.15)(2) $$\n$$ = 3.7 + 1.15 + 0 + 0.85 + 4.3 = 10 $$\n因此，斜率为 $\\beta_{YZ} = \\frac{10}{10} = 1$。预测值为 $\\hat{Y}(t) = 1 \\cdot Z(t) = Z(t)$。\n$Y$ 的残差，我们记为 $R_Y(t)$，是：\n$$ R_Y(t) = Y(t) - \\hat{Y}(t) = Y(t) - Z(t) $$\n使用给定的值，残差序列为：\n$R_Y = (-1.85 - (-2), -1.15 - (-1), 0 - 0, 0.85 - 1, 2.15 - 2) = (0.15, -0.15, 0, -0.15, 0.15)$。\n根据构造，这就是噪声序列 $\\epsilon_Y(t)$。\n\n**残差的相关性**：\n偏相关 $\\rho_{XY|Z}$ 是残差序列 $R_X(t)$ 和 $R_Y(t)$ 之间的 Pearson 相关性。\n首先，我们计算残差的均值：\n$$ \\bar{R}_X = \\frac{1}{5}(0.1 - 0.2 + 0 + 0.2 - 0.1) = 0 $$\n$$ \\bar{R}_Y = \\frac{1}{5}(0.15 - 0.15 + 0 - 0.15 + 0.15) = 0 $$\n由于均值为零，相关性公式再次简化为：\n$$ \\rho_{XY|Z} = \\rho_{R_X R_Y} = \\frac{\\sum_{t=1}^{n}R_X(t)R_Y(t)}{\\sqrt{\\left(\\sum_{t=1}^{n}R_X(t)^2\\right) \\left(\\sum_{t=1}^{n}R_Y(t)^2\\right)}} $$\n我们计算分子，即残差的乘积之和：\n$$ \\sum_{t=1}^{5}R_X(t)R_Y(t) = (0.1)(0.15) + (-0.2)(-0.15) + (0)(0) + (0.2)(-0.15) + (-0.1)(0.15) $$\n$$ = 0.015 + 0.03 + 0 - 0.03 - 0.015 = 0 $$\n由于相关性表达式的分子为 $0$，且分母不为零（因为残差序列不恒等于零），所以偏相关必为 $0$。\n这个结果表明，在剔除了共同驱动 $Z(t)$ 的线性效应后，$X(t)$ 和 $Y(t)$ 之间不存在剩余的线性关系。表观的强相关性是伪相关，完全由 $Z(t)$ 介导。\n最终答案是这个偏相关的值。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "在理解了部分相关的基本原理后，我们将这一概念推广到由多个脑区组成的完整网络中。本练习介绍了一个强大的框架——高斯图模型（GGM），它揭示了协方差矩阵、其逆矩阵（精度矩阵 $\\Theta$）以及定义网络条件独立结构的部分相关之间的深刻联系。通过这项编码实践，您将学习如何从协方差数据构建功能连接图，并通过阈值化来识别稀疏的连接模式，并解释其拓扑属性。",
            "id": "4165697",
            "problem": "给定一个从多元时间序列估计的对称半正定协方差矩阵 $\\Sigma \\in \\mathbb{R}^{p \\times p}$，其中每个变量代表一个感兴趣的脑区。在高斯图模型 (GGM) 的假设下，条件独立结构被编码在精度矩阵 $\\Theta = \\Sigma^{-1}$ 中，并且功能连接性可以通过变量之间的偏相关进行量化。从多元正态分布中协方差和条件独立性的基本定义出发，推导一个算法，通过 $\\Theta$ 从 $\\Sigma$ 计算偏相关矩阵，并通过对偏相关进行阈值化来解释稀疏模式。\n\n您的程序必须为每个测试用例实现以下步骤：\n- 给定 $\\Sigma$，为保证数值稳定性，构造一个岭正则化协方差 $\\Sigma_{\\epsilon} = \\Sigma + \\epsilon I_p$，其中 $I_p$ 是 $p \\times p$ 的单位矩阵，$\\epsilon \\ge 0$ 是给定的。\n- 计算精度矩阵 $\\Theta = \\Sigma_{\\epsilon}^{-1}$。\n- 从 $\\Theta$ 推导出偏相关矩阵 $\\Pi$，使得每个非对角线元素 $\\Pi_{ij}$ 等于在所有其他变量为条件的变量 $i$ 和变量 $j$ 之间的偏相关。按照惯例，对角线可设为 $1$。\n- 通过对绝对偏相关值进行阈值化来定义一个无向邻接矩阵 $A$：如果 $|\\Pi_{ij}| \\ge \\tau$ 且 $i \\ne j$，则 $A_{ij} = 1$，否则 $A_{ij} = 0$，其中阈值 $\\tau > 0$ 是给定的。\n- 计算整数 $E$，它等于无向边的数量，即 $E = \\sum_{1 \\le i  j \\le p} A_{ij}$。\n- 计算整数 $C$，它等于由 $A$ 诱导的无向图中的连通分量数量。\n\n您的程序必须处理以下矩阵和参数的测试套件：\n- 测试用例 1 (理想路径，三对角精度矩阵引出链式结构)：\n  协方差矩阵为\n  $$\\Sigma^{(1)} = \\begin{bmatrix}\n  1.2352941176470589  0.5882352941176471  0.23529411764705885 \\\\\n  0.5882352941176471  1.4705882352941178  0.5882352941176471 \\\\\n  0.23529411764705885  0.5882352941176471  1.2352941176470589\n  \\end{bmatrix},$$\n  其中 $\\epsilon^{(1)} = 10^{-12}$ 且 $\\tau^{(1)} = 0.05$。\n- 测试用例 2 (近奇异边界，具有强共线性的复合对称)：\n  协方差矩阵为\n  $$\\Sigma^{(2)} = \\begin{bmatrix}\n  1.0  0.95  0.95  0.95 \\\\\n  0.95  1.0  0.95  0.95 \\\\\n  0.95  0.95  1.0  0.95 \\\\\n  0.95  0.95  0.95  1.0\n  \\end{bmatrix},$$\n  其中 $\\epsilon^{(2)} = 10^{-6}$ 且 $\\tau^{(2)} = 0.2$。\n- 测试用例 3 (边界情况，暗示分离子网络的块对角结构)：\n  协方差矩阵为\n  $$\\Sigma^{(3)} = \\begin{bmatrix}\n  1.0  0.6  0.0  0.0 \\\\\n  0.6  1.0  0.0  0.0 \\\\\n  0.0  0.0  1.0  0.6 \\\\\n  0.0  0.0  0.6  1.0\n  \\end{bmatrix},$$\n  其中 $\\epsilon^{(3)} = 0.0$ 且 $\\tau^{(3)} = 0.2$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个双整数列表 $[E, C]$，并按顺序排列。例如，输出格式必须完全是\n$$[[E^{(1)},C^{(1)}],[E^{(2)},C^{(2)}],[E^{(3)},C^{(3)}]].$$\n不应打印任何附加文本。",
            "solution": "其基本原理是多元正态模型以及协方差和条件独立性的定义。设 $\\mathbf{x} \\in \\mathbb{R}^{p}$ 是联合高斯分布，均值为 $\\mathbf{0}$，协方差为 $\\Sigma \\in \\mathbb{R}^{p \\times p}$，即 $\\mathbf{x} \\sim \\mathcal{N}(\\mathbf{0}, \\Sigma)$。精度矩阵定义为 $\\Theta = \\Sigma^{-1}$。高斯图模型 (GGM) 中一个经过充分检验的结论是：$\\Theta_{ij} = 0$ 当且仅当在给定所有其他变量的情况下，变量 $i$ 和 $j$ 条件独立。这将 $\\Theta$ 中的稀疏性与条件独立结构联系起来，这是通过偏相关解释功能连接性的基础。\n\n我们从第一性原理推导偏相关公式。将 $\\mathbf{x}$ 划分为 $(x_i, x_j, \\mathbf{x}_{-ij})$，其中 $\\mathbf{x}_{-ij}$ 表示除 $x_i$ 和 $x_j$ 之外的所有变量。在给定 $\\mathbf{x}_{-ij}$ 的条件下，$(x_i, x_j)$ 的条件分布是二元正态分布。其条件协方差由 $\\Sigma$ 中对应于 $(i,j)$ 的块的舒尔补（Schur complement）给出，但一个等价且更直接的途径是使用精度矩阵。对于高斯向量，$x_i$ 对所有其他变量的回归系数向量与 $\\Theta$ 的相应行成正比。特别地，$x_i$ 对 $x_j$ 的偏回归系数（在控制所有其他变量后）是\n$$\\beta_{i \\leftarrow j \\mid -ij} = -\\frac{\\Theta_{ij}}{\\Theta_{ii}}.$$\n对称地，\n$$\\beta_{j \\leftarrow i \\mid -ij} = -\\frac{\\Theta_{ij}}{\\Theta_{jj}}.$$\n在给定 $\\mathbf{x}_{-ij}$ 的条件下，$x_i$ 和 $x_j$ 之间的偏相关 $\\Pi_{ij}$ 是它们回归残差之间的相关性。对于高斯变量，此相关性等于归一化后的非对角精度项的负值：\n$$\\Pi_{ij} = -\\frac{\\Theta_{ij}}{\\sqrt{\\Theta_{ii} \\Theta_{jj}}}, \\quad i \\ne j,$$\n并且按照惯例 $\\Pi_{ii} = 1$。这种归一化之所以出现，是因为残差方差与 $\\Theta$ 相应对角线项成反比，而相关性是由标准差的几何平均数归一化的协方差。\n\n算法上：\n- 当 $\\Sigma$ 接近奇异时，可能需要正则化以保证数值稳定性。我们构建 $\\Sigma_{\\epsilon} = \\Sigma + \\epsilon I_p$，其中岭参数 $\\epsilon \\ge 0$ 是一个小数，这能保持对称性并改善条件数。\n- 使用稳定的求逆程序计算 $\\Theta = \\Sigma_{\\epsilon}^{-1}$，并通过 $(\\Theta + \\Theta^\\top)/2$ 进行对称化以减少浮点不对称性。\n- 使用上述公式计算 $\\Pi$。令 $d = \\sqrt{\\operatorname{diag}(\\Theta)} \\in \\mathbb{R}^p$，则\n$$\\Pi = -\\Theta \\oslash (d d^\\top),$$\n其中 $\\oslash$ 表示逐元素除法，并且我们将 $\\Pi$ 的对角线设为 $1$。\n- 为了解释稀疏性，我们对绝对非对角线项进行阈值化：如果 $|\\Pi_{ij}| \\ge \\tau$ 且 $i \\ne j$，则 $A_{ij} = 1$，否则 $A_{ij} = 0$。这样可以得到一个无向图。$\\Theta$ 中的零意味着精确的条件独立，因此在总体中偏相关为零；在有限样本和有数值误差的情况下，较小幅度的 $\\Pi_{ij}$ 表明直接的功能连接性很弱或不存在，因此阈值化可以捕捉稀疏性。\n- 边的数量为 $E = \\sum_{1 \\le i  j \\le p} A_{ij}$，每条无向边计数一次。\n- 连通分量的数量 $C$ 是通过在邻接图上进行图遍历（例如，深度优先搜索或广度优先搜索）计算得出的，孤立节点也算作一个分量。\n\n应用于测试套件：\n- 测试用例 1 是由一个在 (1,3) 位置为零的三对角精度矩阵构造的；其给定的协方差 $\\Sigma^{(1)}$ 是一个精度矩阵的逆，该精度矩阵满足 $\\Theta^{(1)}_{12} = \\Theta^{(1)}_{23} \\ne 0$ 和 $\\Theta^{(1)}_{13} = 0$。当使用一个小的阈值 $\\tau^{(1)} = 0.05$ 时，结果是一个具有两条边和一个连通分量的链式图。\n- 测试用例 2 表现出具有强共线性的复合对称（$\\Sigma^{(2)}$ 的非对角线元素为 $0.95$），这是病态条件的。岭参数 $\\epsilon^{(2)} = 10^{-6}$ 稳定了求逆过程。大多数对的偏相关非零，产生一个具有许多边的稠密图；使用 $\\tau^{(2)} = 0.2$ 时，该图预计是完全连通的。\n- 测试用例 3 是块对角的，意味着有两个分离的子网络。使用 $\\tau^{(3)} = 0.2$ 进行阈值化只会在块内产生边，并生成两个连通分量。\n\n程序实现了此流程，并按规定格式输出列表 $[[E^{(1)},C^{(1)}],[E^{(2)},C^{(2)}],[E^{(3)},C^{(3)}]]$，通过从精度矩阵推导偏相关并在 GGM 框架下通过条件独立结构解释稀疏性，确保了科学真实性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_partial_correlation_from_cov(Sigma: np.ndarray, eps: float = 0.0) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute the partial correlation matrix from a covariance matrix via the precision matrix.\n    Returns (Pi, Theta), where Pi is the partial correlation matrix and Theta is the precision.\n    \"\"\"\n    p = Sigma.shape[0]\n    # Ridge regularization for numerical stability\n    Sigma_reg = Sigma + eps * np.eye(p)\n    # Invert to get precision\n    Theta = np.linalg.inv(Sigma_reg)\n    # Symmetrize to reduce numerical asymmetry\n    Theta = (Theta + Theta.T) / 2.0\n    # Compute partial correlations: Pi_ij = -Theta_ij / sqrt(Theta_ii * Theta_jj)\n    d = np.sqrt(np.diag(Theta))\n    # Avoid division by zero: if any diagonal is zero (should not happen for SPD), fallback to tiny epsilon\n    d = np.where(d == 0.0, 1e-18, d)\n    denom = np.outer(d, d)\n    Pi = -Theta / denom\n    # Set diagonal to 1 by convention\n    np.fill_diagonal(Pi, 1.0)\n    return Pi, Theta\n\ndef adjacency_from_partial_corr(Pi: np.ndarray, tau: float) -> np.ndarray:\n    \"\"\"\n    Build undirected adjacency matrix by thresholding absolute partial correlations.\n    \"\"\"\n    p = Pi.shape[0]\n    A = (np.abs(Pi) >= tau)\n    # No self-loops\n    np.fill_diagonal(A, False)\n    # Symmetrize adjacency\n    A = np.logical_or(A, A.T)\n    return A\n\ndef count_edges(A: np.ndarray) -> int:\n    \"\"\"\n    Count undirected edges in adjacency matrix (upper triangle).\n    \"\"\"\n    return int(np.sum(np.triu(A, 1)))\n\ndef count_connected_components(A: np.ndarray) -> int:\n    \"\"\"\n    Count connected components in an undirected graph with adjacency matrix A.\n    \"\"\"\n    p = A.shape[0]\n    visited = np.zeros(p, dtype=bool)\n    components = 0\n    for start in range(p):\n        if not visited[start]:\n            components += 1\n            # BFS\n            queue = [start]\n            visited[start] = True\n            while queue:\n                u = queue.pop(0)\n                neighbors = np.where(A[u])[0]\n                for v in neighbors:\n                    if not visited[v]:\n                        visited[v] = True\n                        queue.append(v)\n    return components\n\ndef solve():\n    # Define the test cases from the problem statement.\n    Sigma1 = np.array([\n        [1.2352941176470589, 0.5882352941176471, 0.23529411764705885],\n        [0.5882352941176471, 1.4705882352941178, 0.5882352941176471],\n        [0.23529411764705885, 0.5882352941176471, 1.2352941176470589]\n    ], dtype=float)\n    eps1 = 1e-12\n    tau1 = 0.05\n\n    Sigma2 = np.array([\n        [1.0, 0.95, 0.95, 0.95],\n        [0.95, 1.0, 0.95, 0.95],\n        [0.95, 0.95, 1.0, 0.95],\n        [0.95, 0.95, 0.95, 1.0]\n    ], dtype=float)\n    eps2 = 1e-6\n    tau2 = 0.2\n\n    Sigma3 = np.array([\n        [1.0, 0.6, 0.0, 0.0],\n        [0.6, 1.0, 0.0, 0.0],\n        [0.0, 0.0, 1.0, 0.6],\n        [0.0, 0.0, 0.6, 1.0]\n    ], dtype=float)\n    eps3 = 0.0\n    tau3 = 0.2\n\n    test_cases = [\n        (Sigma1, eps1, tau1),\n        (Sigma2, eps2, tau2),\n        (Sigma3, eps3, tau3),\n    ]\n\n    results = []\n    for Sigma, eps, tau in test_cases:\n        Pi, Theta = compute_partial_correlation_from_cov(Sigma, eps)\n        A = adjacency_from_partial_corr(Pi, tau)\n        E = count_edges(A)\n        C = count_connected_components(A)\n        results.append([E, C])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在学会了计算和解释连接网络之后，一个关键的步骤是评估其科学有效性。本练习探讨了重测信度这一核心问题，它是可重复科学的基石。您将通过一项模拟，并使用源自方差分析（ANOVA）的组内相关系数（ICC），来量化观测到的网络指标变异中，多大比例归因于真实的被试间差异，而非测量误差或会话效应。",
            "id": "4165640",
            "problem": "给定一个场景，其中多名人类参与者接受重复的功能性磁共振成像会话，并且在每个参与者的每次会话中，从一个功能连接矩阵中提取一个标量网络度量。目标是使用组内相关系数 (ICC) 来量化该网络度量的重测信度，并指定一个基于模拟的实验来评估其跨会话的稳定性。\n\n起点和基本基础：假设参与者 $i$ 在会话 $j$ 中观察到的标量网络度量来自一个双因素设置，其中观察值可以由参与者特定效应、会话特定效应和残差噪声等可加性分量来描述。依赖方差、协方差和双因素方差分析分解的一般定义。将用于重测信度的组内相关系数 (ICC) 定义为，在适当的建模假设下，可归因于参与者间变异性的总方差比例，其中一个定义对应于双因素随机效应框架中的绝对一致性，另一个对应于双因素混合效应框架中的一致性。不要使用任何简便公式；相反，应从双因素方差分析的方差分量估计的第一性原理出发。\n\n任务：\n- 构建一个模拟，为 $n$ 名参与者在 $k$ 次会话中，从具有 $p$ 个区域的功能连接矩阵生成标量网络度量。设无向边的数量为 $E = \\frac{p(p-1)}{2}$。对于每个参与者 $i \\in \\{1,\\dots,n\\}$ 和每次会话 $j \\in \\{1,\\dots,k\\}$，设边权重由三个独立分量的和生成：一个方差参数为 $\\sigma_S^2$ 的参与者水平的边向量，一个方差参数为 $\\sigma_B^2$ 的会话水平的边向量，以及一个方差参数为 $\\sigma_\\epsilon^2$ 的边水平的残差噪声向量。参与者 $i$ 在会话 $j$ 的标量网络度量必须是 $E$ 个上三角边权重的平均值。确保模拟的功能连接矩阵通过构造是对称的。\n- 仅使用双因素方差分析分解和全方差定律，推导在双因素随机效应模型（绝对一致性）和双因素混合效应模型（一致性）下重测信度的组内相关系数的估计量。将这两个估计量用从以参与者和会话为因子的双因素方差分析分解中获得的样本均方来表示。\n- 实现一个程序，对于下面测试套件中的每个参数集，运行模拟，计算所有参与者和会话的标量网络度量，对生成的 $n \\times k$ 数据矩阵执行双因素方差分析，并按指定顺序输出两种 ICC 值（绝对一致性和一致性）。\n\n科学真实性与推导要求：\n- 从一般双因素可加模型定义 $X_{ij} = \\mu + \\alpha_i + \\beta_j + \\varepsilon_{ij}$（其中 $i \\in \\{1,\\dots,n\\}$ 和 $j \\in \\{1,\\dots,k\\}$）以及跨参与者和会话的总方差分解开始。使用双因素框架下均方期望的性质来推导方差分量的表达式。不要在问题陈述中提供简便或记忆的公式；推导过程必须在您的解决方案中陈述。\n\n角度单位、物理单位和输出：\n- 本问题不涉及物理单位或角度单位。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，附加 $2$ 个浮点数：首先是绝对一致性 ICC（双因素随机效应，单次测量），然后是一致性 ICC（双因素混合效应，单次测量）。最终输出必须按顺序聚合所有测试用例的结果。\n\n测试套件：\n- 案例 1：$n=20$，$k=2$，$p=10$，$\\sigma_S=1.0$，$\\sigma_B=0.1$，$\\sigma_\\epsilon=0.1$，随机种子 $42$。\n- 案例 2：$n=20$，$k=3$，$p=10$，$\\sigma_S=0.5$，$\\sigma_B=0.4$，$\\sigma_\\epsilon=0.4$，随机种子 $123$。\n- 案例 3：$n=10$，$k=2$，$p=10$，$\\sigma_S=0.0$，$\\sigma_B=0.5$，$\\sigma_\\epsilon=0.5$，随机种子 $7$。\n- 案例 4：$n=15$，$k=5$，$p=6$，$\\sigma_S=1.0$，$\\sigma_B=0.0$，$\\sigma_\\epsilon=0.0$，随机种子 $99$。\n- 案例 5：$n=8$，$k=4$，$p=12$，$\\sigma_S=0.8$，$\\sigma_B=0.6$，$\\sigma_\\epsilon=0.0$，随机种子 $2023$。\n\n最终输出格式：\n- 您的程序应精确生成一行：一个用方括号括起来的逗号分隔列表，按以下顺序包含 $10$ 个浮点数：$[\\text{ICC}_{\\text{AA}}^{(1)}, \\text{ICC}_{\\text{C}}^{(1)}, \\text{ICC}_{\\text{AA}}^{(2)}, \\text{ICC}_{\\text{C}}^{(2)}, \\text{ICC}_{\\text{AA}}^{(3)}, \\text{ICC}_{\\text{C}}^{(3)}, \\text{ICC}_{\\text{AA}}^{(4)}, \\text{ICC}_{\\text{C}}^{(4)}, \\text{ICC}_{\\text{AA}}^{(5)}, \\text{ICC}_{\\text{C}}^{(5)}]$，其中 $\\text{ICC}_{\\text{AA}}$ 表示绝对一致性组内相关系数，$\\text{ICC}_{\\text{C}}$ 表示一致性组内相关系数。",
            "solution": "用户提供的问题已经过验证，被认为是有效的。它具有科学依据、是适定的且客观的。所有必要的信息都已提供，以得出一个唯一且有意义的解。\n\n解决方案将分三部分呈现。首先，我们将形式化模拟模型，并将其参数与双因素方差分析 (ANOVA) 模型的分量联系起来。其次，我们将从双因素方差分析的第一性原理出发，推导两种指定类型的组内相关系数 (ICC) 的估计量。第三，我们将概述实现模拟和计算 ICC 的计算算法。\n\n### 1. 模拟模型及其与双因素方差分析的联系\n\n该问题要求为每个参与者 $i \\in \\{1,\\dots,n\\}$ 和每次会话 $j \\in \\{1,\\dots,k\\}$ 模拟一个标量网络度量 $X_{ij}$。该网络有 $p$ 个区域，产生 $E = \\frac{p(p-1)}{2}$ 条唯一的无向边。给定参与者和会话的每条边的权重由三个独立的、零均值的高斯随机分量的和生成：一个方差为 $\\sigma_S^2$ 的参与者特定效应 $S_i$，一个方差为 $\\sigma_B^2$ 的会话特定效应 $B_j$，以及一个方差为 $\\sigma_\\epsilon^2$ 的残差噪声 $\\epsilon_{ij}$。\n\n设 $W_{ij}^{(l)}$ 为参与者 $i$ 在会话 $j$ 中边 $l \\in \\{1,\\dots,E\\}$ 的权重。边权重的生成模型为：\n$W_{ij}^{(l)} = S_i^{(l)} + B_j^{(l)} + \\epsilon_{ij}^{(l)}$\n其中 $S_i^{(l)} \\sim N(0, \\sigma_S^2)$，$B_j^{(l)} \\sim N(0, \\sigma_B^2)$ 和 $\\epsilon_{ij}^{(l)} \\sim N(0, \\sigma_\\epsilon^2)$ 都是独立的。\n\n标量网络度量 $X_{ij}$ 是这 $E$ 个边权重的平均值：\n$$X_{ij} = \\frac{1}{E} \\sum_{l=1}^{E} W_{ij}^{(l)} = \\frac{1}{E} \\sum_{l=1}^{E} \\left( S_i^{(l)} + B_j^{(l)} + \\epsilon_{ij}^{(l)} \\right)$$\n根据求和的线性性质，我们可以将其重新排列为：\n$$X_{ij} = \\left( \\frac{1}{E} \\sum_{l=1}^{E} S_i^{(l)} \\right) + \\left( \\frac{1}{E} \\sum_{l=1}^{E} B_j^{(l)} \\right) + \\left( \\frac{1}{E} \\sum_{l=1}^{E} \\epsilon_{ij}^{(l)} \\right)$$\n\n这个结构直接映射到问题中指定的双因素可加方差分析模型：\n$$X_{ij} = \\mu + \\alpha_i + \\beta_j + \\varepsilon_{ij}$$\n其中 $\\mu$ 是总均值（在我们的模拟中为 $0$），$\\alpha_i$ 是参与者 $i$ 的随机效应，$\\beta_j$ 是会话 $j$ 的随机或固定效应，$\\varepsilon_{ij}$ 是残差项。\n\n我们模拟的分量与方差分析模型效应的对应关系如下：\n- 参与者效应：$\\alpha_i = \\frac{1}{E} \\sum_{l=1}^{E} S_i^{(l)}$\n- 会话效应：$\\beta_j = \\frac{1}{E} \\sum_{l=1}^{E} B_j^{(l)}$\n- 残差：$\\varepsilon_{ij} = \\frac{1}{E} \\sum_{l=1}^{E} \\epsilon_{ij}^{(l)}$\n\n这些效应的方差，即方差分析框架中的方差分量，可以使用独立随机变量和的方差性质来推导。设 $\\sigma_R^2$、$\\sigma_C^2$ 和 $\\sigma_E^2$ 分别为参与者（行）、会话（列）和误差的方差分量。\n- $Var(\\alpha_i) = \\sigma_R^2 = Var\\left(\\frac{1}{E} \\sum_{l=1}^{E} S_i^{(l)}\\right) = \\frac{1}{E^2} \\sum_{l=1}^{E} Var(S_i^{(l)}) = \\frac{1}{E^2} (E \\sigma_S^2) = \\frac{\\sigma_S^2}{E}$\n- $Var(\\beta_j) = \\sigma_C^2 = Var\\left(\\frac{1}{E} \\sum_{l=1}^{E} B_j^{(l)}\\right) = \\frac{1}{E^2} \\sum_{l=1}^{E} Var(B_j^{(l)}) = \\frac{1}{E^2} (E \\sigma_B^2) = \\frac{\\sigma_B^2}{E}$\n- $Var(\\varepsilon_{ij}) = \\sigma_E^2 = Var\\left(\\frac{1}{E} \\sum_{l=1}^{E} \\epsilon_{ij}^{(l)}\\right) = \\frac{1}{E^2} \\sum_{l=1}^{E} Var(\\epsilon_{ij}^{(l)}) = \\frac{1}{E^2} (E \\sigma_\\epsilon^2) = \\frac{\\sigma_\\epsilon^2}{E}$\n\n### 2. ICC 估计量的推导\n\nICC 是衡量总方差中可归因于测量对象（在此例中为参与者）的比例的度量。我们首先使用矩量法，根据双因素方差分析的结果来估计方差分量（$\\sigma_R^2, \\sigma_C^2, \\sigma_E^2$）。\n\n对于一个由观测值 $X_{ij}$ 组成的 $n \\times k$ 数据矩阵 $X$：\n- 总均值：$\\bar{X}_{..} = \\frac{1}{nk} \\sum_{i=1}^n \\sum_{j=1}^k X_{ij}$\n- 参与者均值：$\\bar{X}_{i.} = \\frac{1}{k} \\sum_{j=1}^k X_{ij}$\n- 会话均值：$\\bar{X}_{.j} = \\frac{1}{n} \\sum_{i=1}^n X_{ij}$\n\n平方和为：\n- 参与者间平方和：$SS_R = k \\sum_{i=1}^n (\\bar{X}_{i.} - \\bar{X}_{..})^2$\n- 会话间平方和：$SS_C = n \\sum_{j=1}^k (\\bar{X}_{.j} - \\bar{X}_{..})^2$\n- 总平方和：$SST = \\sum_{i=1}^n \\sum_{j=1}^k (X_{ij} - \\bar{X}_{..})^2$\n- 残差（误差）平方和：$SS_E = SST - SS_R - SS_C = \\sum_{i=1}^n \\sum_{j=1}^k (X_{ij} - \\bar{X}_{i.} - \\bar{X}_{.j} + \\bar{X}_{..})^2$\n\n对应的均方 (MS) 是平方和除以其自由度：\n- $MS_R = \\frac{SS_R}{n-1}$（行/参与者均方）\n- $MS_C = \\frac{SS_C}{k-1}$（列/会话均方）\n- $MS_E = \\frac{SS_E}{(n-1)(k-1)}$（误差均方）\n\n根据方差分析理论，对于每个单元格有一个观测值的双因素模型，这些均方的期望值 (EMS) 为：\n- $E[MS_R] = k \\sigma_R^2 + \\sigma_E^2$\n- $E[MS_C] = n \\sigma_C^2 + \\sigma_E^2$\n- $E[MS_E] = \\sigma_E^2$\n\n通过将观察到的均方与其期望值相等（矩量法），我们得到方差分量的估计量：\n- $\\hat{\\sigma}_E^2 = MS_E$\n- $\\hat{\\sigma}_R^2 = \\frac{MS_R - MS_E}{k}$\n- $\\hat{\\sigma}_C^2 = \\frac{MS_C - MS_E}{n}$\n\n现在我们可以定义 ICC 估计量。\n\n**绝对一致性 ICC ($ICC_{AA}$)**：这在双因素随机效应模型下使用，其中参与者和会话都被视为从更大总体中抽样的随机因子。一个观测值的总方差包括所有方差来源。\n$$ICC_{AA} = \\frac{\\text{参与者方差}}{\\text{总方差}} = \\frac{\\sigma_R^2}{\\sigma_R^2 + \\sigma_C^2 + \\sigma_E^2}$$\n代入估计量：\n$$\\widehat{ICC}_{AA} = \\frac{\\frac{MS_R - MS_E}{k}}{\\frac{MS_R - MS_E}{k} + \\frac{MS_C - MS_E}{n} + MS_E}$$\n为简化，我们可以将分子和分母同乘以 $k$：\n$$\\widehat{ICC}_{AA} = \\frac{MS_R - MS_E}{MS_R - MS_E + \\frac{k}{n}(MS_C - MS_E) + k \\cdot MS_E} = \\frac{MS_R - MS_E}{MS_R + (k-1)MS_E + \\frac{k}{n}(MS_C - MS_E)}$$\n这是单次测量的绝对一致性 ICC，通常表示为 $ICC(2,1)$。\n\n**一致性 ICC ($ICC_C$)**：这在双因素混合效应模型下使用，其中参与者是随机的，但会话是一个固定因子。我们关心的是测量的一致性，忽略会话间的系统性差异。因此，会话方差 $\\sigma_C^2$ 从分母中移除。\n$$ICC_C = \\frac{\\text{参与者方差}}{\\text{参与者方差} + \\text{残差方差}} = \\frac{\\sigma_R^2}{\\sigma_R^2 + \\sigma_E^2}$$\n代入估计量：\n$$\\widehat{ICC}_{C} = \\frac{\\frac{MS_R - MS_E}{k}}{\\frac{MS_R - MS_E}{k} + MS_E}$$\n将分子和分母同乘以 $k$ 得到最终形式：\n$$\\widehat{ICC}_{C} = \\frac{MS_R - MS_E}{MS_R - MS_E + k \\cdot MS_E} = \\frac{MS_R - MS_E}{MS_R + (k-1)MS_E}$$\n这是单次测量的一致性 ICC，通常表示为 $ICC(3,1)$。\n\n### 3. 算法实现\n\n程序将为每个测试用例执行以下步骤：\n1.  设置随机数生成器种子以保证可复现性。\n2.  提取参数：参与者数量 $n$、会话数量 $k$、区域数量 $p$ 以及方差参数 $\\sigma_S$、$\\sigma_B$、$\\sigma_\\epsilon$。\n3.  计算边的数量 $E = p(p-1)/2$。\n4.  模拟 $n \\times k$ 数据矩阵 $X$。对于每个单元格 $(i, j)$：\n    a. 从 $N(0, \\sigma_S^2)$ 生成一个大小为 $E$ 的参与者特定效应向量。\n    b. 从 $N(0, \\sigma_B^2)$ 生成一个大小为 $E$ 的会话特定效应向量。\n    c. 从 $N(0, \\sigma_\\epsilon^2)$ 生成一个大小为 $E$ 的残差噪声向量。\n    d. 将这三个向量相加得到最终的边权重向量。\n    e. 计算边权重向量的平均值并将其存储在 $X_{ij}$ 中。\n5.  对矩阵 $X$ 执行双因素方差分析，以计算 $MS_R$、$MS_C$ 和 $MS_E$ 的估计值。\n6.  使用推导出的公式从均方计算 $\\widehat{ICC}_{AA}$ 和 $\\widehat{ICC}_{C}$。\n7.  存储得到的两个 ICC 值。\n8.  处理完所有测试用例后，将收集到的结果格式化为单个用方括号括起来的逗号分隔字符串。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation_and_get_metrics(n, k, p, sigma_S, sigma_B, sigma_epsilon, seed):\n    \"\"\"\n    Generates scalar network metrics for n participants across k sessions.\n\n    Args:\n        n (int): Number of participants.\n        k (int): Number of sessions.\n        p (int): Number of regions in the network.\n        sigma_S (float): Standard deviation of the participant-level effect.\n        sigma_B (float): Standard deviation of the session-level effect.\n        sigma_epsilon (float): Standard deviation of the edge-level residual noise.\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        np.ndarray: An n x k matrix of scalar network metrics.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    if p  2:\n        E = 0\n    else:\n        E = p * (p - 1) // 2\n\n    # Generate participant and session level effects for all edges\n    # S_effects: (n, E), B_effects: (k, E)\n    S_effects = rng.normal(0, sigma_S, size=(n, E))\n    B_effects = rng.normal(0, sigma_B, size=(k, E))\n\n    X = np.zeros((n, k))\n\n    for i in range(n):\n        for j in range(k):\n            if E > 0:\n                # Generate edge-level residual noise for this specific observation\n                noise_vector = rng.normal(0, sigma_epsilon, size=E)\n                # The total edge vector is the sum of the three components\n                edge_vector = S_effects[i, :] + B_effects[j, :] + noise_vector\n                # The scalar metric is the mean of the edge weights\n                X[i, j] = np.mean(edge_vector)\n            else:\n                # If there are no edges, the metric is 0\n                X[i, j] = 0.0\n                \n    return X\n\ndef calculate_iccs_from_data(X, n, k):\n    \"\"\"\n    Calculates Absolute Agreement and Consistency ICCs from a data matrix.\n\n    Args:\n        X (np.ndarray): The n x k data matrix (participants x sessions).\n        n (int): Number of participants.\n        k (int): Number of sessions.\n\n    Returns:\n        tuple[float, float]: A tuple containing (ICC_Absolute_Agreement, ICC_Consistency).\n    \"\"\"\n    # Calculate means\n    grand_mean = np.mean(X)\n    participant_means = np.mean(X, axis=1)\n    session_means = np.mean(X, axis=0)\n\n    # Calculate Sums of Squares (SS)\n    ss_r = k * np.sum((participant_means - grand_mean)**2)  # Between-Participants (Rows)\n    ss_c = n * np.sum((session_means - grand_mean)**2)      # Between-Sessions (Columns)\n    sst = np.sum((X - grand_mean)**2)                        # Total\n    ss_e = sst - ss_r - ss_c                                 # Error/Residual\n\n    # Calculate Degrees of Freedom (df)\n    df_r = n - 1\n    df_c = k - 1\n    df_e = (n - 1) * (k - 1)\n\n    # Calculate Mean Squares (MS)\n    # Handle edge cases where a df is 0, though not expected with problem constraints.\n    ms_r = ss_r / df_r if df_r > 0 else 0.0\n    ms_c = ss_c / df_c if df_c > 0 else 0.0\n    ms_e = ss_e / df_e if df_e > 0 else 0.0\n    \n    # Calculate ICC for Absolute Agreement (two-way random effects, single measurement, ICC(2,1))\n    # ICC_AA = (MS_R - MS_E) / (MS_R + (k-1)*MS_E + k/n * (MS_C - MS_E))\n    numerator_aa = ms_r - ms_e\n    denominator_aa = ms_r + (k - 1) * ms_e + (k / n) * (ms_c - ms_e)\n    \n    if denominator_aa == 0:\n        # This case suggests MS_R, MS_E, MS_C are all 0, or perfect anti-correlation in a way.\n        # If numerator is also 0, it's undefined. If not, it's +/- infinity.\n        # Nan is a safe bet for this pathological case.\n        icc_aa = np.nan\n    else:\n        icc_aa = numerator_aa / denominator_aa\n\n    # Calculate ICC for Consistency (two-way mixed effects, single measurement, ICC(3,1))\n    # ICC_C = (MS_R - MS_E) / (MS_R + (k-1)*MS_E)\n    numerator_c = ms_r - ms_e\n    denominator_c = ms_r + (k - 1) * ms_e\n\n    if denominator_c == 0:\n        # Denominator is 0 if MS_R=0 and MS_E=0 (and k>1). Perfect homogeneity.\n        # Numerator is also 0. ICC is undefined.\n        icc_c = np.nan\n    else:\n        icc_c = numerator_c / denominator_c\n        \n    return icc_aa, icc_c\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # n, k, p, sigma_S, sigma_B, sigma_epsilon, random_seed\n        (20, 2, 10, 1.0, 0.1, 0.1, 42),\n        (20, 3, 10, 0.5, 0.4, 0.4, 123),\n        (10, 2, 10, 0.0, 0.5, 0.5, 7),\n        (15, 5, 6, 1.0, 0.0, 0.0, 99),\n        (8, 4, 12, 0.8, 0.6, 0.0, 2023),\n    ]\n\n    all_results = []\n    for n, k, p, sigma_S, sigma_B, sigma_epsilon, seed in test_cases:\n        # Step 1: Run simulation to get the data matrix X\n        X = run_simulation_and_get_metrics(n, k, p, sigma_S, sigma_B, sigma_epsilon, seed)\n        \n        # Step 2: Calculate the two ICC types from the data\n        icc_absolute_agreement, icc_consistency = calculate_iccs_from_data(X, n, k)\n        \n        all_results.append(icc_absolute_agreement)\n        all_results.append(icc_consistency)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}