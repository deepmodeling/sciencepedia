{
    "hands_on_practices": [
        {
            "introduction": "在编写任何代码之前，至关重要的是要理解正确的计算步骤顺序。本练习旨在挑战你识别从向量自回归（VAR）模型计算频域格兰杰因果关系的正确算法，并特别关注处理新息（innovations）中同期相关性这一关键步骤。正确掌握这个顺序是任何有效实现的基础。",
            "id": "4165323",
            "problem": "一个来自两个皮层位点的双变量局部场电位（LFP）记录 $\\mathbf{x}_t = [x_t, y_t]^\\top$ 以频率 $f_s$ 采样，并被建模为一个p阶稳定向量自回归（VAR）模型，即 $\\mathbf{x}_t = \\sum_{k=1}^{p} A_k \\mathbf{x}_{t-k} + \\boldsymbol{\\varepsilon}_t$，其中 $\\boldsymbol{\\varepsilon}_t$ 是一个零均值宽义白噪声新息，其同期协方差为 $\\Sigma$。您计划在一个包含 $N$ 个角频率 $\\{\\omega_m\\}_{m=0}^{N-1}$ 的网格上计算从 $y$ 到 $x$ 的频域格兰杰因果关系，记为 $f_{Y\\to X}(\\omega)$，该网格覆盖 $[0,\\pi]$（单位：弧度/样本）。该计算必须从第一性原理出发，通过以下步骤进行：拟合$\\mathrm{VAR}(p)$模型，获取传递函数 $H(\\omega)$，获取谱密度 $S(\\omega)$，识别 $x$ 的内蕴谱，并最终在每个网格频率上构建 $f_{Y\\to X}(\\omega)$。\n\n哪个选项最正确、最完整地列举了从已拟合的$\\mathrm{VAR}(p)$模型到 $H(\\omega)$、$S(\\omega)$、$x$的内蕴谱，并最终在整个频率网格上得到 $f_{Y\\to X}(\\omega)$ 的计算步骤，同时保留了该度量的有向性、动态性和基于新息的基础？\n\nA. 通过普通最小二乘法（OLS）对 $\\mathbf{x}_t$ 拟合$\\mathrm{VAR}(p)$模型，通过检查 $\\det\\!\\big(I - \\sum_{k=1}^{p} A_k z^k\\big)$ 的所有零点都位于单位圆外来验证稳定性，并估计 $\\Sigma$。对于每个网格频率 $\\omega_m$，构建滞后多项式 $A(e^{-i\\omega_m}) = I - \\sum_{k=1}^{p} A_k e^{-i\\omega_m k}$ 并求逆以获得传递函数 $H(\\omega_m) = A(e^{-i\\omega_m})^{-1}$。计算一个下三角同期变换 $T$，使得 $T \\Sigma T^\\ast$ 为对角矩阵（例如，通过基于Cholesky的三角正交化），并定义变换后的传递函数 $H_T(\\omega_m) = H(\\omega_m) T^{-1}$ 以及对角化的新息协方差 $D = T \\Sigma T^\\ast$。将谱密度构建为 $S(\\omega_m) = H_T(\\omega_m) D H_T(\\omega_m)^\\ast$，并将 $x$ 的内蕴谱识别为在正交化表示中 $x$ 自身新息的贡献，即仅来自第一个变换后新息的功率。最后，在每个 $\\omega_m$ 处，通过计算 $x$ 的总谱与其内蕴谱之比的自然对数来计算该有向度量，并报告 $\\{f_{Y\\to X}(\\omega_m)\\}_{m=0}^{N-1}$。\n\nB. 对 $\\mathbf{x}_t$ 拟合$\\mathrm{VAR}(p)$模型，并从残差的周期图中计算 $x_t$ 和 $y_t$ 之间的幅度平方相干性。通过在每个频率上应用变换 $-\\log(1 - \\text{coherence}^2)$ 将相干性转换为因果谱。这避免了传递函数求逆和新息正交化，并直接从频域依赖结构中得出 $f_{Y\\to X}(\\omega)$。\n\nC. 跳过$\\mathrm{VAR}(p)$模型，通过对原始时间序列 $\\mathbf{x}_t$ 进行快速傅里叶变换（FFT）来计算 $H(\\omega)$，以获得一个经验传递函数。使用这个 $H(\\omega)$ 构建 $S(\\omega) = H(\\omega) H(\\omega)^\\ast$，通过将交叉谱置零来定义 $x$ 的内蕴谱，然后在整个频率网格上将 $f_{Y\\to X}(\\omega)$ 计算为总谱和内蕴谱之间的差异。\n\nD. 拟合$\\mathrm{VAR}(p)$模型并估计 $\\Sigma$，但绕过同期正交化。对于每个 $\\omega_m$，计算 $A(e^{+i\\omega_m}) = I - \\sum_{k=1}^{p} A_k e^{+i\\omega_m k}$，求逆得到 $H(\\omega_m) = A(e^{+i\\omega_m})^{-1}$，并构建 $S(\\omega_m) = H(\\omega_m) \\Sigma H(\\omega_m)^\\ast$。通过在拟合模型中将所有交叉滞后自回归系数 $A_{xy}(k)$ 设置为零并重新计算谱来定义 $x$ 的内蕴谱，然后将 $f_{Y\\to X}(\\omega)$ 计算为原始谱和修改后谱的比率。\n\nE. 拟合$\\mathrm{VAR}(p)$模型并估计 $\\Sigma$。对于每个 $\\omega_m$，计算 $H(\\omega_m) = \\big(I - \\sum_{k=1}^{p} A_k e^{-i\\omega_m k}\\big)^{-1}$。通过一个对称平方根变换 $W$（使得 $W \\Sigma W^\\ast = I$ 且 $W$ 是对称的）对新息进行白化，设置 $H_W(\\omega_m) = H(\\omega_m) W$，并计算 $S(\\omega_m) = H_W(\\omega_m) H_W(\\omega_m)^\\ast$。将 $x$ 的内蕴谱定义为与 $H_W(\\omega_m)$ 的第一列相关的功率，然后通过在频率网格上进行对数比来计算 $f_{Y\\to X}(\\omega)$。这种对称白化在消除瞬时相关性的同时保留了能量。",
            "solution": "用户希望对一个关于计算频域格兰杰因果关系的问题进行批判性评估。我将首先验证问题陈述，如果有效，则继续对所提供的选项进行详细的推导和评估。\n\n### 问题验证\n\n**第1步：提取已知条件**\n-   观测数据是一个双变量局部场电位（LFP）记录，表示为向量时间序列 $\\mathbf{x}_t = [x_t, y_t]^\\top$。\n-   采样频率为 $f_s$。\n-   数据被建模为一个p阶稳定向量自回归模型，记为$\\mathrm{VAR}(p)$：\n    $$ \\mathbf{x}_t = \\sum_{k=1}^{p} A_k \\mathbf{x}_{t-k} + \\boldsymbol{\\varepsilon}_t $$\n-   新息过程 $\\boldsymbol{\\varepsilon}_t$ 是零均值、宽义白噪声。\n-   新息的同期协方差矩阵为 $\\Sigma = E[\\boldsymbol{\\varepsilon}_t \\boldsymbol{\\varepsilon}_t^\\top]$。\n-   目标是计算从 $y$ 到 $x$ 的频域格兰杰因果关系，记为 $f_{Y\\to X}(\\omega)$。\n-   计算将在一个包含 $N$ 个角频率 $\\{\\omega_m\\}_{m=0}^{N-1}$ 的网格上进行，该网格覆盖区间 $[0,\\pi]$（单位：弧度/样本）。\n-   计算过程必须从第一性原理出发，并包括以下阶段：拟合$\\mathrm{VAR}(p)$模型，获取传递函数 $H(\\omega)$，获取谱密度矩阵 $S(\\omega)$，识别 $x$ 的内蕴谱，并最终构建因果关系度量 $f_{Y\\to X}(\\omega)$。\n\n**第2步：使用提取的已知条件进行验证**\n-   **科学上成立：** 该问题牢固地植根于时间序列分析理论及其在神经科学中的应用，特别是计算由Geweke发展的频域格兰杰因果关系。所有概念——VAR模型、传递函数、谱密度、新息协方差及其相互关系——在科学文献中都是标准且公认的。\n-   **良构的：** 该问题是良构的。它要求正确列举从一个标准统计模型（$\\mathrm{VAR}(p)$）计算一个明确定义的数学量（$f_{Y\\to X}(\\omega)$）所需的计算步骤。鉴于已有的理论，存在一个唯一正确的程序。\n-   **客观的：** 问题陈述使用精确、客观、无歧义的数学语言表达。它不含主观主张或意见。\n\n**缺陷清单：**\n1.  **科学或事实上的不健全：** 无。前提是时间序列理论的标准定义。\n2.  **不可形式化或不相关：** 无。该问题直接且形式化地关于指定主题。\n3.  **不完整或矛盾的设置：** 无。问题提供了定义所需计算路径的所有必要理论构造。\n4.  **不切实际或不可行：** 无。所描述的分析是计算神经科学中的一个常用程序。\n5.  **病态的或结构不良的：** 无。问题清晰，并根据既定理论有明确的答案。\n6.  **伪深刻、琐碎或同义反复：** 无。该问题测试了格兰杰因果关系中一个关键且常被误解的方面：如何正确处理同期相关的新息。不同矩阵分解（三角与对称）之间的区别是一个实质性的概念点。\n7.  **超出科学可验证性范围：** 无。该程序基于可验证的数学推导。\n\n**第3步：结论与行动**\n问题陈述是**有效的**。我将继续推导解决方案并评估选项。\n\n### 频域格兰杰因果关系的推导\n格兰杰因果关系的基础是可预测性。在频域中，我们评估在给定频率 $\\omega$ 下，通过包含另一个信号 $y_t$ 的历史，对信号 $x_t$ 的预测能力提高了多少。这通过比较 $x_t$ 的总功率谱与其“内蕴”功率谱——即由其自身新息过程产生、独立于来自 $y_t$ 影响的功率——来正式量化。\n\n1.  **VAR模型和传递函数：**\n    $\\mathrm{VAR}(p)$ 模型是 $\\left(I - \\sum_{k=1}^{p} A_k L^k\\right) \\mathbf{x}_t = \\boldsymbol{\\varepsilon}_t$，其中 $L$ 是滞后算子。在频域中，这变为 $A(e^{-i\\omega}) \\mathbf{x}(\\omega) = \\boldsymbol{\\varepsilon}(\\omega)$，其中 $A(z) = I - \\sum_{k=1}^{p} A_k z^k$。\n    传递函数矩阵 $H(\\omega)$ 将新息映射到观测信号，$\\mathbf{x}(\\omega) = H(\\omega)\\boldsymbol{\\varepsilon}(\\omega)$，它由矩阵多项式的逆给出：\n    $$ H(\\omega) = \\left(I - \\sum_{k=1}^{p} A_k e^{-i\\omega k}\\right)^{-1} $$\n\n2.  **谱密度矩阵：**\n    交叉谱密度矩阵 $S(\\omega)$ 由传递函数和新息协方差导出：\n    $$ S(\\omega) = H(\\omega) \\Sigma H(\\omega)^\\ast $$\n    其中 $H(\\omega)^\\ast$ 表示 $H(\\omega)$ 的共轭转置。对角元素 $S_{xx}(\\omega)$ 代表过程 $x_t$ 的总功率谱。\n\n3.  **新息正交化：**\n    一个关键步骤是处理新息中的同期相关性，这由 $\\Sigma$ 的非对角元素捕获。新息 $\\varepsilon_{xt}$ 和 $\\varepsilon_{yt}$ 通常是相关的。为了分离因果贡献，我们必须将它们转换为一组正交的新息。这需要施加一个因果顺序。为了计算 $f_{Y \\to X}$，我们考虑顺序 $(x, y)$，这意味着任何共享的瞬时方差都归因于 $x$。这是通过使用 $\\Sigma$ 的三角分解来实现的。\n    标准方法是Cholesky分解，$\\Sigma = P P^\\ast$，其中 $P$ 是一个下三角矩阵。对于我们的双变量情况 $\\mathbf{x}_t = [x_t, y_t]^\\top$，$P$ 的形式为：\n    $$ P = \\begin{pmatrix} p_{11}  0 \\\\ p_{21}  p_{22} \\end{pmatrix} $$\n    我们可以定义一组新的不相关新息 $\\boldsymbol{\\eta}_t$（具有单位协方差），使得 $\\boldsymbol{\\varepsilon}_t = P \\boldsymbol{\\eta}_t$。然后过程可以写成 $\\mathbf{x}(\\omega) = H(\\omega) P \\boldsymbol{\\eta}(\\omega)$。矩阵 $H'(\\omega) = H(\\omega) P$ 是从正交新息 $\\boldsymbol{\\eta}$ 到信号 $\\mathbf{x}$ 的传递函数。\n\n4.  **内蕴谱和总谱：**\n    新的谱密度矩阵是 $S(\\omega) = H'(\\omega) (H'(\\omega))^\\ast$。第 $(1,1)$ 个元素 $S_{xx}(\\omega)$ 是 $x$ 的总功率：\n    $$ S_{xx}(\\omega) = |H'_{11}(\\omega)|^2 + |H'_{12}(\\omega)|^2 $$\n    第一项 $|H'_{11}(\\omega)|^2$ 表示由第一个正交新息 $\\eta_{1t}$ 贡献给 $x$ 的功率，根据我们的构造，这是 $x$ 新息的内蕴部分。这被定义为 $x$ 的*内蕴谱*：\n    $$ S_{xx, \\text{int}}(\\omega) = |H'_{11}(\\omega)|^2 = |(H(\\omega)P)_{11}|^2 = |H_{xx}(\\omega)p_{11} + H_{xy}(\\omega)p_{21}|^2 $$\n    第二项 $|H'_{12}(\\omega)|^2$ 表示从第二个正交新息 $\\eta_{2t}$ 传递的功率，这在因果上依赖于 $y$。\n\n5.  **因果关系度量：**\n    从 $y$ 到 $x$ 的频域格兰杰因果关系定义为 $x$ 的总功率与其内蕴功率之比的自然对数：\n    $$ f_{Y\\to X}(\\omega) = \\ln\\left(\\frac{S_{xx}(\\omega)}{S_{xx, \\text{int}}(\\omega)}\\right) $$\n\n### 逐项分析\n\n**A. 拟合$\\mathrm{VAR}(p)$模型...基于Cholesky的三角正交化...对数比。**\n该选项正确地描述了整个过程。让我们对照我们的推导来追踪它的步骤：\n- 它正确地将拟合VAR模型、检查稳定性和估计 $\\Sigma$ 作为第一步。\n- 它正确地定义了从VAR系数计算传递函数 $H(\\omega_m)$ 的方法。\n- 它正确地指出了需要进行三角变换来正交化新息，以解决同期相关性问题。“计算一个下三角同期变换 $T$ 使得 $T \\Sigma T^\\ast$ 为对角矩阵”的描述准确地描述了使用Cholesky因子的逆或LDL分解的结果，这保留了必要的因果顺序。\n- 它正确地定义了变换后的传递函数（$H_T = H T^{-1}$）和由此产生的谱密度（$S = H_T D H_T^\\ast$）。\n- 它正确地将内蕴谱识别为来自变换后新息向量的第一个分量的功率贡献，该分量对应于变量 $x$。\n- 最后，它正确地将格兰杰因果关系度量定义为 $x$ 的总谱与其内蕴谱之比的自然对数。\n这个选项的每个部分都与既定理论一致。\n**结论：正确。**\n\n**B. ...计算幅度平方相干性...应用变换 $-\\log(1 - \\text{coherence}^2)$...**\n这描述的是一种总谱相互依赖性的度量，而不是有向因果关系。相干性 $C_{xy}(\\omega)$ 是对称的（$C_{xy}(\\omega) = C_{yx}(\\omega)$），无法区分 $x$ 和 $y$ 之间的影响方向。格兰杰因果关系根本上是非对称的。这个选项混淆了两个不同的概念。\n**结论：不正确。**\n\n**C. 跳过$\\mathrm{VAR}(p)$模型，通过对原始时间序列进行快速傅里叶变换（FFT）来计算 $H(\\omega)$...**\n这是对概念的根本性误解。时间序列的FFT，$\\mathbf{x}(\\omega)$，是信号傅里叶表示的估计，而不是系统的传递函数 $H(\\omega)$。VAR模型对于估计封装在 $H(\\omega)$ 中的系统动态是必不可少的。此外，它错误地将谱密度表述为 $S(\\omega) = H(\\omega)H(\\omega)^\\ast$，忽略了至关重要的新息协方差矩阵 $\\Sigma$。所提出的方法在理论上是不健全的。\n**结论：不正确。**\n\n**D. ...绕过同期正交化...通过将所有交叉滞后自回归系数 $A_{xy}(k)$ 设置为零来定义内蕴谱...**\n这个选项犯了两个关键错误。首先，它使用了 $e^{+i\\omega_m k}$ 这一项，这是一个非标准的约定。其次，更重要的是，它“绕过同期正交化”。这是一个致命的缺陷。未能正确处理 $\\Sigma$ 中的相关新息意味着任何“瞬时因果关系”（一个采样区间内的影响）都被忽略了，度量可能会严重不准确。所描述的通过将交叉系数设置为零来定义内蕴模型的过程，与一种不同的、不太稳健的因果关系表述有关，而这种表述正是因这个问题而受到诟病。题目明确要求一种保留“基于新息的基础”的方法，而这种方法未能做到这一点。\n**结论：不正确。**\n\n**E. ...通过一个对称平方根变换 $W$ 对新息进行白化，使得 $W \\Sigma W^\\ast = I$...**\n这个选项建议使用一个对称白化矩阵，例如 $W=\\Sigma^{-1/2}$。虽然这确实能产生不相关的新息，但它是通过对称地混合原始新息（$\\varepsilon_{xt}$ 和 $\\varepsilon_{yt}$）来实现的。由此产生的正交新息 $\\eta_1$ 和 $\\eta_2$ 都是原始新息的混合物。这破坏了对于归因影响至关重要的因果顺序。“第一列”所衍生的功率没有明确的解释为“内蕴”功率，因为该列的效果是由所有原始来源的混合驱动的。需要一个三角分解（如选项A中）来创建一个允许因果解释的递归结构。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在建立了计算蓝图之后，我们现在转向一个完整的实现。本练习将指导你模拟神经数据，估计格兰杰因果关系谱，以及最重要的一点——使用置换检验（permutation testing）这一强大的非参数技术来评估其统计显著性。你还将学习如何控制跨频率的多重比较问题，这是任何谱分析中必不可少的一步。",
            "id": "4165291",
            "problem": "给定一个包含两神经活动变量（表示为 $x_t$ 和 $y_t$）的成对试验记录集合，每个试验以 $f_s$ Hz 的频率采样，持续 $T$ 个时间点，共有 $N$ 个独立试验。假设信号遵循一个具有高斯新息的1阶平稳双变量向量自回归（VAR）过程，并且各次试验是同一过程的独立实现。分析目标是估计并评估从 $x$ 到 $y$ 的频域格兰杰因果（GC）谱的统计显著性，使用通过跨试验的置换检验构建的经验零分布，并对跨频率的多重比较进行校正。\n\n从以下基本原理和定义开始：\n\n- 线性自回归过程的平稳性：具有稳定系数的 VAR 过程具有明确定义的光谱特性，带有协方差矩阵的线性新息为其二阶统计量提供了完整描述。\n- VAR 过程的谱密度是其自协方差函数的傅里叶变换，可以通过频域传递函数表示，该函数将新息与观测信号联系起来。\n- 频域格兰杰因果（GC）的定义为：通过具有高斯新息的线性预测移除源分量的影响后，将目标分量的全谱与其内在分量的谱进行比较。\n\n跨试验的置换检验以构建经验零谱，应通过相对于目标变量 $y_t$ 独立地置换候选源变量 $x_t$ 的试验配对来实现。这样做会破坏潜在因果影响的跨试验对齐，同时保留每个变量在试验内部的时间结构。对于每次置换，根据置换后的配对重新估计 VAR 模型并计算 GC 谱。这样，对于每个频率，在从 $x$ 到 $y$ 无因果影响的零假设下，都会产生一个 GC 值的经验零分布。\n\n跨频率的多重比较必须使用两种不同的程序进行校正：\n\n1. 在水平 $q = 0.05$ 下进行 Benjamini–Hochberg 错误发现率（FDR）控制。\n2. 在水平 $\\alpha = 0.05$ 下使用最大统计量方法进行族错误率（FWER）控制，该方法使用频率网格上置换最大值的分布来调整p值。\n\n实现以下计算任务：\n\n1. 仿真模型：对于每个测试用例，生成一个 VAR($1$) 双变量过程的 $N$ 次试验，每次试验长度为 $T$ 个时间点，其中自滞后系数为 $a_x$ 和 $a_y$，从 $x$ 到 $y$ 的交叉滞后系数为 $b$。新息是均值为零、协方差为\n   $$\\Sigma = \\begin{bmatrix} \\sigma_x^2  \\rho \\sigma_x \\sigma_y \\\\ \\rho \\sigma_x \\sigma_y  \\sigma_y^2 \\end{bmatrix},$$\n   的高斯分布，其中 $\\rho$ 是 $x$ 和 $y$ 的新息之间的相关系数。在收集 $T$ 个样本之前，每个试验使用 $B$ 个样本的预烧期以达到平稳状态。所有试验都是从同一 VAR 过程和噪声分布中独立抽取的。确保系数能产生一个稳定过程。\n\n2. VAR($1$) 估计：给定成对的试验，通过普通最小二乘法，汇集所有试验中初始滞后之后的所有时间点，来估计 VAR($1$) 系数矩阵和新息协方差 $\\Sigma$。\n\n3. 频域格兰杰因果：使用估计的 VAR($1$) 矩阵和新息协方差，在 $[1, 40]$ Hz 频带内的一组 $M$ 个均匀间隔的频率上，计算从 $x$ 到 $y$ 的 GC 谱。您必须通过频域传递函数计算全谱密度，并通过在高斯新息下线性移除 $x$ 的影响后，将 $y$ 的全功率与其内在分量进行比较，来形成 GC 谱。\n\n4. 通过试验置换生成经验零谱：对于 $P$ 次独立的试验索引随机置换中的每一次，相对于 $y$ 试验的分配，置换 $x$ 试验的分配，重新估计 VAR($1$)，并在相同频率上重新计算 GC 谱。对于每个频率，这将产生一个包含 $P$ 个零假设下 GC 值的样本。\n\n5. P值：对于每个频率，计算经验 p 值，即大于或等于观测 GC 值的零假设 GC 值的比例，使用在分子和分母中都加 1 的标准置换 p 值公式。\n\n6. 多重比较校正：\n   - 对每个频率的 p 值集应用水平 $q = 0.05$ 的 Benjamini–Hochberg 错误发现率（FDR）控制，并为每个频率生成一个布尔决策。\n   - 通过为每次置换计算跨频率的最大零假设 GC 值，应用水平 $\\alpha = 0.05$ 的最大统计量族错误率（FWER）控制；然后，对于每个观测频率，根据此最大零分布计算调整后的 p 值，并在指定的 $\\alpha$ 水平下生成一个布尔决策。\n\n7. 输出规范：对于每个测试用例，分别计算在 FDR 和最大统计量 FWER 控制下被声明为显著的频率数量。您的程序应为下面的测试套件生成单行输出，其中包含每个测试用例两个整数的列表的列表，格式完全如下：\n   $$\\texttt{[[n\\_FDR\\_1,n\\_FWER\\_1],[n\\_FDR\\_2,n\\_FWER\\_2],\\dots]}.$$\n\n使用以下参数集测试套件，这些参数集涵盖了一系列场景：\n\n- 案例 A（预期从 $x$ 到 $y$ 有因果影响）：\n  - $N = 40$，$T = 900$，$f_s = 200$ Hz，在 $[1, 40]$ Hz 范围内的 $M = 64$ 个频率\n  - VAR 系数：$a_x = 0.5$，$a_y = 0.5$，$b = 0.6$\n  - 新息：$\\sigma_x = 1.0$，$\\sigma_y = 1.0$，$\\rho = 0.0$\n  - 预烧期：$B = 100$\n  - 置换次数：$P = 150$\n\n- 案例 B（无因果影响且噪声相关）：\n  - $N = 40$，$T = 900$，$f_s = 200$ Hz，在 $[1, 40]$ Hz 范围内的 $M = 64$ 个频率\n  - VAR 系数：$a_x = 0.5$，$a_y = 0.5$，$b = 0.0$\n  - 新息：$\\sigma_x = 1.0$，$\\sigma_y = 1.0$，$\\rho = 0.7$\n  - 预烧期：$B = 100$\n  - 置换次数：$P = 150$\n\n- 案例 C（弱因果影响且试验次数较少）：\n  - $N = 20$，$T = 600$，$f_s = 200$ Hz，在 $[1, 40]$ Hz 范围内的 $M = 64$ 个频率\n  - VAR 系数：$a_x = 0.5$，$a_y = 0.5$，$b = 0.2$\n  - 新息：$\\sigma_x = 1.0$，$\\sigma_y = 1.0$，$\\rho = 0.0$\n  - 预烧期：$B = 100$\n  - 置换次数：$P = 100$\n\n答案要求：\n\n- 您的程序必须是一个完整的、可运行的实现，能够执行仿真、估计、谱 GC 计算、置换检验、多重比较校正，并输出每个测试用例的计数。\n- 角度和频率必须一致地以弧度或赫兹处理；您必须以赫兹计算频率，并在需要时将其转换为以弧度为单位的角频率。\n- 最终输出必须是指定格式的单行。输出中无需打印任何单位。",
            "solution": "该问题要求对模拟的双变量向量自回归（VAR）过程进行频域格兰杰因果（GC）分析的全面实现，包括使用置换检验进行统计评估和多重比较校正。解决方案围绕指定的计算任务构建。\n\n### 1. 双变量向量自回归（VAR）模型与仿真\n\n基础过程是一个1阶（$p=1$）平稳双变量VAR模型。令两个时间序列表示为向量 $\\mathbf{z}_t = [x_t, y_t]^\\top$。VAR($1$) 模型表示为：\n$$\n\\mathbf{z}_t = A_1 \\mathbf{z}_{t-1} + \\mathbf{e}_t\n$$\n其中 $A_1$ 是一个 $2 \\times 2$ 的系数矩阵，$\\mathbf{e}_t = [e_{x,t}, e_{y,t}]^\\top$ 是一个白噪声新息向量，其均值为零，协方差矩阵为 $\\Sigma$。\n$$\nA_1 = \\begin{bmatrix} a_{11}  a_{12} \\\\ a_{21}  a_{22} \\end{bmatrix}, \\quad \\Sigma = \\text{cov}(\\mathbf{e}_t) = \\begin{bmatrix} \\sigma_x^2  \\rho \\sigma_x \\sigma_y \\\\ \\rho \\sigma_x \\sigma_y  \\sigma_y^2 \\end{bmatrix}\n$$\n问题指定了从 $x$ 到 $y$ 的定向因果结构，这意味着 $y_{t-1}$ 不影响 $x_t$。这对应于设置 $a_{12}=0$。给定的系数为 $a_{11} = a_x$（$x$ 的自滞后），$a_{22} = a_y$（$y$ 的自滞后），以及 $a_{21} = b$（从 $x$ 到 $y$ 的交叉滞后）。因此，用于仿真的系数矩阵为：\n$$\nA_1 = \\begin{bmatrix} a_x  0 \\\\ b  a_y \\end{bmatrix}\n$$\n如果 $A_1$ 的所有特征值的模都小于1，则 VAR($1$) 过程的稳定性得到保证。对于这个下三角矩阵，特征值是其对角线元素 $a_x$ 和 $a_y$。给定值（$a_x=0.5, a_y=0.5$）满足此条件（$|0.5|  1$）。\n\n模拟 $N$ 个独立的试验，每个试验长度为 $T$，其过程是首先从多元正态分布 $\\mathcal{N}(0, \\Sigma)$ 生成新息向量 $\\mathbf{e}_t$。然后从 $\\mathbf{z}_0 = [0, 0]^\\top$ 开始迭代生成时间序列。每个试验都会生成并丢弃一个长度为 $B$ 个样本的预烧期，以确保过程在收集用于分析的 $T$ 个样本之前达到其平稳分布。\n\n### 2. VAR(1) 参数估计\n\n给定 $N$ 个试验的成对时间序列数据 $\\{x_t^{(i)}, y_t^{(i)}\\}_{t=1..T}^{i=1..N}$，估计参数 $\\hat{A}_1$ 和 $\\hat{\\Sigma}$。为最大化统计功效，所有试验的数据被汇集在一起。用于估计的模型是完整的双变量 VAR($1$)，因此 $\\hat{A}_1$ 是一个完整的 $2 \\times 2$ 矩阵。\n回归方程为 $\\mathbf{Z}_\\text{target} = A_1 \\mathbf{Z}_\\text{predictor} + \\mathbf{E}$，其中 $\\mathbf{Z}_\\text{target}$ 是一个 $2 \\times (N(T-1))$ 矩阵，包含向量 $[\\mathbf{z}_1^{(1)}, \\dots, \\mathbf{z}_{T-1}^{(1)}, \\mathbf{z}_1^{(2)}, \\dots, \\mathbf{z}_{T-1}^{(N)}]$，$\\mathbf{Z}_\\text{predictor}$ 是一个 $2 \\times (N(T-1))$ 矩阵，包含相应的滞后向量 $[\\mathbf{z}_0^{(1)}, \\dots, \\mathbf{z}_{T-2}^{(1)}, \\mathbf{z}_0^{(2)}, \\dots, \\mathbf{z}_{T-2}^{(N)}]$。\n\n$A_1$ 的普通最小二乘（OLS）估计量为：\n$$\n\\hat{A}_1 = (\\mathbf{Z}_\\text{target} \\mathbf{Z}_\\text{predictor}^\\top) (\\mathbf{Z}_\\text{predictor} \\mathbf{Z}_\\text{predictor}^\\top)^{-1}\n$$\n残差计算为 $\\hat{\\mathbf{E}} = \\mathbf{Z}_\\text{target} - \\hat{A}_1 \\mathbf{Z}_\\text{predictor}$。然后从残差中估计新息协方差矩阵 $\\Sigma$：\n$$\n\\hat{\\Sigma} = \\frac{1}{N(T-1)} \\hat{\\mathbf{E}} \\hat{\\mathbf{E}}^\\top\n$$\n\n### 3. 频域格兰杰因果\n\nVAR 过程的谱表示是计算频域 GC 的关键。对 VAR($1$) 方程进行傅里叶变换可得：\n$$\n\\mathbf{Z}(f) = A_1 e^{-i\\omega} \\mathbf{Z}(f) + \\mathbf{E}(f) \\implies (\\mathbf{I} - A_1 e^{-i\\omega}) \\mathbf{Z}(f) = \\mathbf{E}(f)\n$$\n其中 $\\omega = 2\\pi f / f_s$ 是给定频率 $f$（单位为 Hz）对应的角频率。将新息映射到观测过程的传递函数矩阵 $H(f)$ 是：\n$$\nH(f) = (\\mathbf{I} - \\hat{A}_1 e^{-i\\omega})^{-1}\n$$\n谱密度矩阵 $S(f)$ 由下式给出：\n$$\nS(f) = H(f) \\hat{\\Sigma} H(f)^*\n$$\n其中 $H(f)^*$ 表示 $H(f)$ 的共轭转置。$S(f)$ 的对角线元素是 $x_t$ 和 $y_t$ 的功率谱。\n\n在频率 $f$ 上从 $x$ 到 $y$ 的格兰杰因果，表示为 $GC_{x \\to y}(f)$，衡量了在该频率下 $y_t$ 的功率中可归因于 $x_t$ 的部分。其正式定义为 $y_t$ 的总功率与其内在功率（无法由 $x_t$ 解释的功率）之比的对数。一种分离这些分量的标准方法是通过协方差矩阵的 Cholesky 分解（$\\hat{\\Sigma} = G G^\\top$，其中 $G$ 为下三角矩阵）来正交化新息。\n这就得到了从正交新息 $\\mathbf{W}(f)$到输出的更新后的传递函数：$\\tilde{H}(f) = H(f)G$。谱矩阵可以写为 $S(f) = \\tilde{H}(f) \\tilde{H}(f)^*$。$y_t$（第二个分量，索引为1）的功率谱为 $S_{yy}(f) = |\\tilde{H}_{10}(f)|^2 + |\\tilde{H}_{11}(f)|^2$。第一项 $|\\tilde{H}_{10}(f)|^2$ 表示源于 $x$ 的正交新息的 $y$ 的功率，而第二项 $|\\tilde{H}_{11}(f)|^2$ 是源于 $y$ 自身正交新息的内在功率。因此，GC 谱为：\n$$\nGC_{x \\to y}(f) = \\ln \\left( \\frac{S_{yy}(f)}{\\text{Intrinsic Power}_y(f)} \\right) = \\ln \\left( \\frac{|\\tilde{H}_{10}(f)|^2 + |\\tilde{H}_{11}(f)|^2}{|\\tilde{H}_{11}(f)|^2} \\right) = \\ln \\left( 1 + \\frac{|\\tilde{H}_{10}(f)|^2}{|\\tilde{H}_{11}(f)|^2} \\right)\n$$\n此计算在指定的 $[1, 40]$ Hz 范围内的 $M$ 个离散频率上执行。\n\n### 4. 通过置换进行统计显著性检验\n\n为了评估统计显著性，我们在从 $x$ 到 $y$ 无因果影响的零假设下，为 GC 谱生成一个经验零分布。这是通过逐试验置换实现的。通过随机置换源信号 $x_t$ 的试验索引，同时保持目标信号 $y_t$ 的试验顺序不变，可以打破信号间的跨试验关联。这保留了两个信号的自谱特性和试验内的时间结构，但破坏了任何一致的试验间因果关系。\n\n对于 $P$ 次置换中的每一次，都会形成一个置换后的数据集，重新估计 VAR($1$) 模型，并计算一个零假设下的 GC 谱。该过程为每个频率生成一组 $P$ 个零假设下的 GC 值，从而形成该频率下的经验零分布。\n\n对于每个频率 $f_k$ 的观测 GC 值 $GC_\\text{obs}(f_k)$，其经验 p 值的计算公式为：\n$$\np(f_k) = \\frac{1 + \\sum_{j=1}^{P} \\mathbb{I}(GC_\\text{null}^{(j)}(f_k) \\ge GC_\\text{obs}(f_k))}{P + 1}\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。这个公式可以防止 p 值为 0，是置换检验的标准做法。\n\n### 5. 多重比较校正\n\n由于我们在 $M$ 个频率上各进行了一次检验，我们必须对多重比较进行校正，以控制整个检验族的错误率。\n\n#### Benjamini–Hochberg 错误发现率（FDR）\n此程序控制在所有被拒绝的零假设中假阳性的期望比例。对于一个期望的 FDR 水平 $q$：\n1.  将 $M$ 个未校正的 p 值按升序排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(M)}$。\n2.  找到满足 $p_{(k)} \\le \\frac{k}{M} q$ 的最大索引 $k$。\n3.  拒绝所有对应于 p 值 $p_{(1)}, \\dots, p_{(k)}$ 的零假设。\n显著频率的数量就是被拒绝的假设的数量。\n\n#### 最大统计量族错误率（FWER）\n此方法控制在所有频率上至少出现一次假阳性发现的概率。它比 FDR 更严格。\n1.  对于 $P$ 次置换中的每一次，计算零假设下的 GC 谱，并找到其在所有 $M$ 个频率上的最大值：$GC_\\text{max}^{(j)} = \\max_{k=1..M} \\{GC_\\text{null}^{(j)}(f_k)\\}$。\n2.  这会产生一个包含 $P$ 个最大统计量值的单一零分布 $\\{GC_\\text{max}^{(j)}\\}_{j=1..P}$。\n3.  对于每个频率 $f_k$ 上的观测 GC 值，其 FWER 校正后的 p 值是根据此最大统计量分布计算的：\n    $$\n    p_\\text{adj}(f_k) = \\frac{1 + \\sum_{j=1}^{P} \\mathbb{I}(GC_\\text{max}^{(j)} \\ge GC_\\text{obs}(f_k))}{P + 1}\n    $$\n4.  如果一个频率的调整后 p 值 $p_\\text{adj}(f_k)$ 小于或等于 FWER 水平 $\\alpha$，则该频率被声明为显著。统计此类频率的数量。\n\n最终输出是每个测试用例的一对计数 [FDR 显著频率数, FWER 显著频率数]。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef simulate_bivar_var1(N, T, B, A, Sigma, seed):\n    \"\"\"\n    Simulates N trials of a bivariate VAR(1) process.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    num_channels = 2\n    total_len = T + B\n    \n    data = np.zeros((N, num_channels, total_len))\n    \n    for i in range(N):\n        innovations = rng.multivariate_normal(np.zeros(num_channels), Sigma, size=total_len)\n        for t in range(1, total_len):\n            data[i, :, t] = A @ data[i, :, t-1] + innovations[t, :]\n            \n    return data[:, :, B:]\n\ndef estimate_var1_ols(data):\n    \"\"\"\n    Estimates VAR(1) parameters A and Sigma using OLS on pooled data.\n    data shape: (N, num_channels, T)\n    \"\"\"\n    N, num_channels, T = data.shape\n    num_points = N * (T - 1)\n\n    Y = data[:, :, 1:].transpose(1, 0, 2).reshape(num_channels, -1)\n    X = data[:, :, :-1].transpose(1, 0, 2).reshape(num_channels, -1)\n    \n    # OLS estimation: A = (Y @ X.T) @ inv(X @ X.T)\n    XX_T = X @ X.T\n    YX_T = Y @ X.T\n    \n    try:\n        A_hat = YX_T @ np.linalg.inv(XX_T)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudo-inverse if matrix is singular.\n        A_hat = YX_T @ np.linalg.pinv(XX_T)\n\n    residuals = Y - A_hat @ X\n    Sigma_hat = (residuals @ residuals.T) / num_points\n    \n    return A_hat, Sigma_hat\n\ndef compute_gc_spectrum(A, Sigma, freqs, fs):\n    \"\"\"\n    Computes the Granger Causality spectrum from x to y.\n    x is channel 0, y is channel 1.\n    \"\"\"\n    M = len(freqs)\n    gc_spectrum = np.zeros(M)\n    \n    try:\n        G = np.linalg.cholesky(Sigma)\n    except np.linalg.LinAlgError:\n        # If Sigma is not positive definite (can happen with estimation noise)\n        # return a zero spectrum.\n        return gc_spectrum\n\n    g_11 = G[0, 0]\n    g_21 = G[1, 0]\n    g_22 = G[1, 1]\n\n    # Pre-calculate components for GC formula that don't depend on frequency\n    # We use the formulation GC_xy = log(1 + |H_21*g11 + H_22*g21|^2 / |H_22*g22|^2)\n    # The term inside log simplifies to log( S_yy / S_yy_intrinsic )\n    # This reduces to evaluating H_21 and H_22 at each frequency\n    # H = (I - A*z)^-1\n    \n    for i, f in enumerate(freqs):\n        if f == 0:\n            gc_spectrum[i] = 0\n            continue\n        omega = 2 * np.pi * f / fs\n        z = np.exp(-1j * omega)\n        \n        I_minus_Az = np.eye(2) - A * z\n        try:\n            H = np.linalg.inv(I_minus_Az)\n        except np.linalg.LinAlgError:\n            continue\n            \n        H_21 = H[1, 0]\n        H_22 = H[1, 1]\n        \n        # Numerator: causal flow from x to y's orthogonalized innovations\n        num_term = H_21 * g_11 + H_22 * g_21\n        \n        # Denominator: intrinsic component from y's own orthogonalized innovation\n        den_term = H_22 * g_22\n        \n        if np.abs(den_term) > 1e-12: # Avoid division by zero\n            gc_spectrum[i] = np.log(1 + (np.abs(num_term)**2) / (np.abs(den_term)**2))\n\n    return gc_spectrum\n\ndef solve():\n    test_cases = [\n        # Case A\n        {'N': 40, 'T': 900, 'fs': 200, 'M': 64, 'freq_range': [1, 40],\n         'a_x': 0.5, 'a_y': 0.5, 'b': 0.6,\n         'sigma_x': 1.0, 'sigma_y': 1.0, 'rho': 0.0,\n         'B': 100, 'P': 150, 'q': 0.05, 'alpha': 0.05, 'seed': 0},\n        # Case B\n        {'N': 40, 'T': 900, 'fs': 200, 'M': 64, 'freq_range': [1, 40],\n         'a_x': 0.5, 'a_y': 0.5, 'b': 0.0,\n         'sigma_x': 1.0, 'sigma_y': 1.0, 'rho': 0.7,\n         'B': 100, 'P': 150, 'q': 0.05, 'alpha': 0.05, 'seed': 1},\n        # Case C\n        {'N': 20, 'T': 600, 'fs': 200, 'M': 64, 'freq_range': [1, 40],\n         'a_x': 0.5, 'a_y': 0.5, 'b': 0.2,\n         'sigma_x': 1.0, 'sigma_y': 1.0, 'rho': 0.0,\n         'B': 100, 'P': 100, 'q': 0.05, 'alpha': 0.05, 'seed': 2},\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        N, T, B, P = params['N'], params['T'], params['B'], params['P']\n        fs, M, q, alpha = params['fs'], params['M'], params['q'], params['alpha']\n        seed = params['seed']\n        rng = np.random.default_rng(seed)\n\n        A_sim = np.array([[params['a_x'], 0], [params['b'], params['a_y']]])\n        cov_xy = params['rho'] * params['sigma_x'] * params['sigma_y']\n        Sigma_sim = np.array([[params['sigma_x']**2, cov_xy], [cov_xy, params['sigma_y']**2]])\n        \n        freqs = np.linspace(params['freq_range'][0], params['freq_range'][1], M)\n\n        data = simulate_bivar_var1(N, T, B, A_sim, Sigma_sim, seed)\n        data_x, data_y = data[:, 0, :], data[:, 1, :]\n        \n        # 1. Observed GC\n        A_obs, Sigma_obs = estimate_var1_ols(data)\n        gc_obs = compute_gc_spectrum(A_obs, Sigma_obs, freqs, fs)\n\n        # 2. Permutation testing\n        null_gc_spectra = np.zeros((P, M))\n        max_null_gc = np.zeros(P)\n        \n        for p in range(P):\n            perm_indices = rng.permutation(N)\n            perm_data_x = data_x[perm_indices, :]\n            perm_data = np.stack([perm_data_x, data_y], axis=1)\n            \n            A_perm, Sigma_perm = estimate_var1_ols(perm_data)\n            gc_perm = compute_gc_spectrum(A_perm, Sigma_perm, freqs, fs)\n            \n            null_gc_spectra[p, :] = gc_perm\n            if gc_perm.size > 0:\n                max_null_gc[p] = np.max(gc_perm)\n\n        # 3. P-values\n        p_vals = (1 + np.sum(null_gc_spectra >= gc_obs, axis=0)) / (P + 1)\n        \n        # 4. FDR correction\n        sorted_indices = np.argsort(p_vals)\n        sorted_p_vals = p_vals[sorted_indices]\n        \n        fdr_thresholds = q * (np.arange(1, M + 1)) / M\n        significant_mask = sorted_p_vals = fdr_thresholds\n        \n        n_fdr = 0\n        if np.any(significant_mask):\n            k = np.where(significant_mask)[0].max()\n            n_fdr = k + 1\n\n        # 5. Max-statistic FWER correction\n        fwer_p_vals = (1 + np.sum(max_null_gc[:, np.newaxis] >= gc_obs, axis=0)) / (P + 1)\n        n_fwer = np.sum(fwer_p_vals = alpha)\n\n        all_results.append([n_fdr, n_fwer])\n    \n    print(f\"{all_results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们如何能确定我们复杂的分析流程是正确有效的？最后一个练习通过让你构建一个验证框架来回答这个至关重要的问题。你将生成具有已知“基准真相”连接性的合成数据，应用你的格兰杰因果关系分析，并系统地测量其准确性、鲁棒性和特异性。这项实践旨在培养一种至关重要的科学习惯：在将方法应用于真实的、未知的实验数据之前，先对其进行验证。",
            "id": "4165340",
            "problem": "您的任务是设计并实现一种完整的频域格兰杰因果关系验证方法，该方法使用具有已知基准真相的合成神经数据，并适用于高级研究生水平的神经科学数据分析。您的程序必须从多元自回归 (MVAR) 模型生成合成双通道时间序列，估计 MVAR 参数，计算频域格兰杰因果度量，并量化不同实验条件下的准确性和鲁棒性。\n\n从以下基本原理出发：\n- 格兰杰因果关系原理：如果过程 $x$ 的过去信息有助于改进对过程 $y$ 的预测（超越仅使用 $y$ 自身过去信息进行预测），则称过程 $x$ 格兰杰导致 (in the sense of Clive Granger) 过程 $y$。\n- 多元自回归 (MVAR) 建模：一个平稳的 $n$ 维离散时间过程 $\\mathbf{X}_t$ 可以建模为 $\\mathbf{X}_t = \\sum_{k=1}^{p} \\mathbf{A}_k \\mathbf{X}_{t-k} + \\mathbf{E}_t$，其中 $p$ 是模型阶数，$\\mathbf{A}_k$ 是系数矩阵，$\\mathbf{E}_t$ 是协方差为 $\\boldsymbol{\\Sigma}$ 的新息过程。\n- 从 MVAR 参数导出的、用于量化方向性影响的频域度量被用于神经科学中，以检测特定振荡频率下的有向相互作用。\n\n您的实现必须：\n1. 使用具有振荡动力学的稳定二维 MVAR$(2)$ 模型生成合成双通道神经时间序列。使用以赫兹 (Hz) 为单位的采样率 $f_s$，并设计自回归系数以在指定的频率 $f_0$ (Hz) 处产生振荡。通过在第一阶滞后自回归矩阵中添加非对角系数，引入从通道 $x$ 到通道 $y$ 的单向耦合。新息协方差必须是正定且符合实际的。\n2. 使用普通最小二乘法对堆叠的滞后回归量进行回归，从生成的数据中估计 MVAR 参数，并计算新息协方差。\n3. 基于 MVAR 表示推导一个频域格兰杰因果度量。该度量必须反映作为频率函数的方向性影响，并且能够从估计的 MVAR 参数中计算得出，而无需重新拟合简化模型。\n4. 通过检查从 $x$ 到 $y$ 的主要有向影响是否集中在已知的基准真相振荡频率 $f_0$ 附近来验证准确性。\n5. 通过对数据段进行自助法 (bootstrapping) 重采样，并量化在目标频带内识别出正确方向的重采样比例，来验证鲁棒性。\n6. 通过在一个没有耦合的零模型中量化假阳性检测，来验证特异性。\n\n您的程序必须实现以下流水线步骤：\n- 合成数据生成：从一个 MVAR$(2)$ 模型模拟两个通道 $(x, y)$ 的数据，该模型具有以 $f_0$ Hz 为中心的振荡自回归动力学，以及在滞后 1 处从 $x$ 到 $y$ 的强度为 $c$ 的耦合。确保模型稳定性，并执行一个预烧期 (burn-in period) 以消除瞬态效应。\n- 参数估计：使用最小二乘法将 MVAR$(p)$ 模型拟合到数据上，并计算新息协方差 $\\boldsymbol{\\Sigma}$。\n- 频域分析：在频率网格 $f \\in [1, f_s/2]$ Hz 上计算一个方向性频域度量，分辨率为均匀的 1 Hz。\n- 准确性度量：计算从 $x$ 到 $y$ 的有向影响的峰值频率与基准真相振荡频率 $f_0$ 之间的绝对误差（单位：Hz，浮点数）。\n- 鲁棒性度量：通过数据段执行自助法重采样，并计算在 $[f_0-5, f_0+5]$ Hz 频带内，从 $x$ 到 $y$ 的积分有向影响超过反向影响的重采样比例（以小数表示，浮点数）。\n- 特异性度量：对于零耦合情况，计算任一方向上所有频率的最大有向影响是否低于给定阈值（返回一个布尔值）。\n\n测试套件：\n实现以下三个测试用例以全面评估流水线：\n- 案例 A (理想路径)：$f_s = 200$ Hz, $f_0 = 40$ Hz, $p = 2$, 耦合 $c = 0.25$, 两通道噪声标准差均为 $0.5$, 时间序列长度 $N = 20000$ 个样本, 预烧期 $= 1000$ 个样本。输出绝对峰值频率误差（单位：Hz，浮点数）。\n- 案例 B (噪声和短数据下的鲁棒性)：$f_s = 200$ Hz, $f_0 = 40$ Hz, $p = 2$, 耦合 $c = 0.25$, 两通道噪声标准差均为 $1.0$, 时间序列长度 $N = 5000$ 个样本, 预烧期 $= 1000$ 个样本, 自助法重采样次数 $B = 50$, 数据段长度 $L = 500$ 个样本。输出鲁棒性比例（以小数表示，浮点数）。\n- 案例 C (用于特异性测试的零模型)：$f_s = 200$ Hz, $f_0 = 40$ Hz, $p = 2$, 耦合 $c = 0.0$, 两通道噪声标准差均为 $0.5$, 时间序列长度 $N = 20000$ 个样本, 预烧期 $= 1000$ 个样本, 检测阈值 $T = 0.25$。输出任一方向的最大有向影响是否保持在 $T$ 以下（布尔值）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”）。这三个结果必须分别对应于案例 A、案例 B 和案例 C。第一个结果必须是赫兹 (Hz) 为单位的浮点数，第二个是小数形式的浮点数，第三个是布尔值。",
            "solution": "验证频域格兰杰因果度量的问题，通过实现一个全面的模拟和分析流水线来解决。该过程涉及从一个已知的基准真相模型生成合成数据，从数据中估计模型参数，计算因果度量，并根据已知的基准真相量化其性能。在计算神经科学中，这种方法是基础性的，它确保在将一种分析方法应用于底层连接未知的真实实验数据之前，该方法是准确、鲁棒和特异的。\n\n解决方案分为四个主要部分：\n1.  **合成数据生成**：一个二阶 ($p=2$) 的双通道多元自回归 (MVAR) 模型作为基准真相的数据生成过程。\n2.  **MVAR 参数估计**：使用普通最小二乘法 (OLS) 从生成的时间序列中估计模型参数。\n3.  **频域因果关系计算**：选择部分有向相干 (Partial Directed Coherence, PDC) 作为方向性影响的频域度量。\n4.  **性能度量计算**：使用问题描述中指定的度量来量化准确性、鲁棒性和特异性。\n\n**1. 合成数据生成：MVAR(2) 模型**\n\n一个双通道或二元离散时间过程 $\\mathbf{X}_t = [x_t, y_t]^T$ 由一个 MVAR($p$) 过程建模：\n$$\n\\mathbf{X}_t = \\sum_{k=1}^{p} \\mathbf{A}_k \\mathbf{X}_{t-k} + \\mathbf{E}_t\n$$\n其中 $p$ 是模型阶数，$\\mathbf{A}_k$ 是 $2 \\times 2$ 的系数矩阵，而 $\\mathbf{E}_t = [\\epsilon_{x,t}, \\epsilon_{y,t}]^T$ 是一个不相关的白噪声新息向量，从均值为零、协方差矩阵为对角阵 $\\boldsymbol{\\Sigma} = \\text{diag}(\\sigma_x^2, \\sigma_y^2)$ 的高斯分布中抽取。\n\n为了在特定频率 $f_0$ 处引入振荡动力学，系统传递函数的极点被放置在单位圆附近，其角度对应于 $f_0$。对于一个稳定的二阶自回归过程，系数是基于一对极点 $z = r e^{\\pm i\\omega_0}$ 设计的，其中 $\\omega_0 = 2\\pi f_0 / f_s$ 是归一化角频率，而 $r  1$ 是一个控制振荡锐度的阻尼因子（越接近 1 的值产生越尖锐的峰值）。这导致系数矩阵的对角元素为：\n- $a_{ii}^{(1)} = 2r \\cos(\\omega_0)$\n- $a_{ii}^{(2)} = -r^2$\n\n对于本问题，这些系数被设定用于 $x$ 和 $y$ 过程的内生动力学。通过设置非对角元素 $a_{21}^{(1)} = c$ 来引入从 $x$ 到 $y$ 的单向因果链，其中 $c$ 是耦合强度。所有其他非对角元素都设置为 0。对于一个具有 $x \\to y$ 耦合的系统，其系数矩阵为：\n$$\n\\mathbf{A}_1 = \\begin{pmatrix} 2r \\cos(\\omega_0)  0 \\\\ c  2r \\cos(\\omega_0) \\end{pmatrix}, \\quad \\mathbf{A}_2 = \\begin{pmatrix} -r^2  0 \\\\ 0  -r^2 \\end{pmatrix}\n$$\n所得 MVAR 模型的稳定性至关重要，通过确认其伴随矩阵 $\\mathbf{F}$ 的所有特征值的模都小于 1 来进行验证。对于一个二元 MVAR(2) 模型，其 $4 \\times 4$ 的伴随矩阵是：\n$$\n\\mathbf{F} = \\begin{pmatrix} \\mathbf{A}_1  \\mathbf{A}_2 \\\\ \\mathbf{I}  \\mathbf{0} \\end{pmatrix}\n$$\n其中 $\\mathbf{I}$ 是 $2 \\times 2$ 的单位矩阵，$\\mathbf{0}$ 是 $2 \\times 2$ 的零矩阵。数据使用 MVAR 方程迭代生成，并丢弃一个初始的预烧期，以确保过程达到平稳状态。\n\n**2. MVAR 参数估计**\n\nMVAR 模型系数是从长度为 $N$ 的生成时间序列 $\\mathbf{X}$ 中估计出来的。模型方程可以写成线性回归形式 $\\mathbf{Y} = \\mathbf{B} \\mathbf{Z} + \\text{误差}$，其中：\n- $\\mathbf{B} = [\\mathbf{A}_1, \\mathbf{A}_2, \\dots, \\mathbf{A}_p]$ 是所有系数组成的 $n \\times np$ 矩阵。\n- $\\mathbf{Y} = [\\mathbf{X}_{p+1}, \\mathbf{X}_{p+2}, \\dots, \\mathbf{X}_N]$ 是因变量组成的 $n \\times (N-p)$ 矩阵。\n- $\\mathbf{Z}$ 是由滞后数据构建的 $np \\times (N-p)$ 回归量矩阵：\n$$\n\\mathbf{Z}_t = [\\mathbf{X}_{t-1}^T, \\mathbf{X}_{t-2}^T, \\dots, \\mathbf{X}_{t-p}^T]^T \\quad \\text{for } t=p+1, \\dots, N\n$$\n$\\mathbf{B}$ 的普通最小二乘 (OLS) 估计由 $\\hat{\\mathbf{B}} = \\mathbf{Y} \\mathbf{Z}^T (\\mathbf{Z} \\mathbf{Z}^T)^{-1}$ 给出。这可以使用数值线性代数程序高效求解。一旦找到 $\\hat{\\mathbf{B}}$，就可以计算估计的残差 $\\hat{\\mathbf{E}}_t = \\mathbf{X}_t - \\sum_{k=1}^p \\hat{\\mathbf{A}}_k \\mathbf{X}_{t-k}$，其协方差矩阵估计为 $\\hat{\\boldsymbol{\\Sigma}} = \\frac{1}{N-p} \\sum_{t=p+1}^{N} \\hat{\\mathbf{E}}_t \\hat{\\mathbf{E}}_t^T$。\n\n**3. 频域因果关系：部分有向相干 (PDC)**\n\n该问题要求一个频域格兰杰因果度量，该度量可以从 MVAR 参数计算得出，而无需重新拟合简化模型。部分有向相干 (Partial Directed Coherence, PDC) 满足此要求，并且是一种用于识别多变量系统中直接因果影响的成熟方法。\n\nPDC 是从 MVAR 模型的频域表示中推导出来的。令 $\\mathbf{A}(f)$ 为系数矩阵的傅里叶变换：\n$$\n\\mathbf{A}(f) = \\mathbf{I} - \\sum_{k=1}^{p} \\mathbf{A}_k e^{-i 2\\pi f k / f_s}\n$$\n该矩阵的元素 $A_{ij}(f)$ 表示在频率 $f$ 处通道 $j$ 对通道 $i$ 的线性影响。从通道 $j$ 到通道 $i$ 的 PDC，记作 $\\pi_{ij}(f)$，是通过将此影响除以从通道 $j$ 发出的总影响来进行归一化定义的：\n$$\n\\pi_{ij}(f) = \\frac{A_{ij}(f)}{\\sqrt{\\sum_{k=1}^{n} |A_{kj}(f)|^2}}\n$$\n其模的平方 $|\\pi_{ij}(f)|^2$ 被用作格兰杰因果度量。它是一个介于 0 和 1 之间的值，反映了在频率 $f$ 处从通道 $j$ 到通道 $i$ 的有向影响相对于从通道 $j$ 到所有通道（包括其自身）的总影响的比例。对于我们的双通道系统（$x=1$, $y=2$），我们计算 $|\\pi_{21}(f)|^2$ 来表示 $x \\to y$ 的影响，计算 $|\\pi_{12}(f)|^2$ 来表示 $y \\to x$ 的影响。\n\n**4. 性能度量**\n\n该流水线通过以下三个度量进行验证：\n- **准确性 (案例 A)**：在生成具有已知 $x \\to y$ 耦合和 $f_0=40$ Hz 振荡的数据后，计算 PDC 谱 $|\\pi_{21}(f)|^2$。准确性是绝对误差 $|f_{\\text{peak}} - f_0|$，其中 $f_{\\text{peak}}$ 是从 $x \\to y$ 的 PDC 达到其最大值时的频率。\n- **鲁棒性 (案例 B)**：该度量评估在较短、噪声较大的数据下的性能。时间序列被划分为不重叠的数据段。通过有放回地对这些数据段进行抽样来创建新的时间序列，从而执行自助法重采样。对于每次重采样，计算 PDC，并在 $f_0$ 周围的频带（$[35, 45]$ Hz）内比较两个方向（$x \\to y$ vs. $y \\to x$）的积分功率。鲁棒性是在正确方向（$x \\to y$）上的影响更强的自助法样本所占的比例。\n- **特异性 (案例 C)**：为测试假阳性，从一个通道间无耦合（$c=0$）的零模型生成数据。计算两个方向的 PDC。如果在所有频率和两个方向上的最大 PDC 值保持在预定义阈值 $T$ 以下，则确认了特异性。该函数返回一个布尔值，指示此条件是否满足。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef design_mvar_coeffs(f0, fs, r, c):\n    \"\"\"\n    Designs MVAR(2) coefficients for a 2-channel system with oscillatory dynamics.\n    \n    Args:\n        f0 (float): Target oscillation frequency in Hz.\n        fs (float): Sampling frequency in Hz.\n        r (float): Damping factor for oscillations (pole radius).\n        c (float): Coupling strength from channel 1 to 2 at lag 1.\n\n    Returns:\n        list: A list of two 2x2 numpy arrays [A1, A2].\n    \"\"\"\n    w0 = 2 * np.pi * f0 / fs\n    a1_diag = 2 * r * np.cos(w0)\n    a2_diag = -r**2\n\n    A1 = np.array([\n        [a1_diag, 0.0],\n        [c, a1_diag]\n    ])\n    A2 = np.array([\n        [a2_diag, 0.0],\n        [0.0, a2_diag]\n    ])\n    return [A1, A2]\n\ndef check_stability(A_coeffs):\n    \"\"\"\n    Checks the stability of an MVAR model.\n    A_coeffs is a list of coefficient matrices [A1, A2, ..., Ap].\n    \"\"\"\n    n, _ = A_coeffs[0].shape\n    p = len(A_coeffs)\n    \n    # Companion matrix\n    F = np.zeros((n * p, n * p))\n    for i in range(p):\n        F[:n, i*n:(i+1)*n] = A_coeffs[i]\n    for i in range(p - 1):\n        F[(i+1)*n:(i+2)*n, i*n:(i+1)*n] = np.eye(n)\n        \n    eigenvalues = np.linalg.eigvals(F)\n    return np.all(np.abs(eigenvalues)  1)\n\ndef generate_mvar_data(N, A_coeffs, sigma_cov, burn_in):\n    \"\"\"\n    Generates synthetic data from a stable MVAR model.\n    \"\"\"\n    if not check_stability(A_coeffs):\n        raise ValueError(\"MVAR model is not stable.\")\n\n    n, _ = A_coeffs[0].shape\n    p = len(A_coeffs)\n    total_samples = N + burn_in\n\n    # Generate noise\n    E = np.random.multivariate_normal(np.zeros(n), sigma_cov, total_samples).T\n    \n    # Initialize time series\n    X = np.zeros((n, total_samples))\n    \n    # Generate data\n    for t in range(p, total_samples):\n        for k in range(p):\n            X[:, t] += A_coeffs[k] @ X[:, t - (k + 1)]\n        X[:, t] += E[:, t]\n        \n    return X[:, burn_in:]\n\ndef fit_mvar(X, p):\n    \"\"\"\n    Fits an MVAR(p) model to time series data X using OLS.\n    X is an n x N matrix (channels x time).\n    \"\"\"\n    n, N = X.shape\n    \n    # Create regressor matrix Z and target matrix Y\n    Y = X[:, p:]\n    Z = np.zeros((n * p, N - p))\n    for t in range(p, N):\n        for k in range(p):\n            Z[k*n:(k+1)*n, t-p] = X[:, t - (k + 1)]\n\n    # Solve for coefficients using least squares\n    # We solve Y = B @ Z => Y.T = Z.T @ B.T\n    B_T, _, _, _ = np.linalg.lstsq(Z.T, Y.T, rcond=None)\n    B = B_T.T\n\n    # Reshape B into A_k matrices\n    A_coeffs_est = [B[:, k*n:(k+1)*n] for k in range(p)]\n\n    # Compute innovation covariance\n    E_est = Y - B @ Z\n    Sigma_est = (E_est @ E_est.T) / (N - p)\n    \n    return A_coeffs_est, Sigma_est\n\ndef compute_pdc(A_coeffs, fs):\n    \"\"\"\n    Computes Partial Directed Coherence (PDC) from MVAR coefficients.\n    \"\"\"\n    n, _ = A_coeffs[0].shape\n    p = len(A_coeffs)\n    \n    freqs = np.arange(1, fs / 2 + 1)\n    pdc_12 = np.zeros(len(freqs)) # y -> x\n    pdc_21 = np.zeros(len(freqs)) # x -> y\n\n    for i, f in enumerate(freqs):\n        Af = np.eye(n, dtype=complex)\n        for k in range(p):\n            Af -= A_coeffs[k] * np.exp(-1j * 2 * np.pi * f * (k + 1) / fs)\n\n        # Denominators for PDC (norm of columns of Af)\n        col_norms = np.sum(np.abs(Af)**2, axis=0)\n\n        # PDC from j to i is |Aij|^2 / sum_k(|Akj|^2)\n        # We need PDC x->y (1->2) and y->x (2->1)\n        if col_norms[0] > 0:\n            pdc_21[i] = np.abs(Af[1, 0])**2 / col_norms[0]\n        if col_norms[1] > 0:\n            pdc_12[i] = np.abs(Af[0, 1])**2 / col_norms[1]\n\n    return freqs, pdc_12, pdc_21\n\ndef solve():\n    np.random.seed(42) # For reproducibility\n    results = []\n    \n    # --- Case A: Accuracy ---\n    fs_a = 200.0\n    f0_a = 40.0\n    p_a = 2\n    c_a = 0.25\n    noise_std_a = 0.5\n    N_a = 20000\n    burn_in_a = 1000\n    r_a = 0.98\n\n    A_coeffs_true_a = design_mvar_coeffs(f0_a, fs_a, r_a, c_a)\n    sigma_cov_true_a = np.diag([noise_std_a**2, noise_std_a**2])\n    X_a = generate_mvar_data(N_a, A_coeffs_true_a, sigma_cov_true_a, burn_in_a)\n    A_coeffs_est_a, _ = fit_mvar(X_a, p_a)\n    freqs_a, _, pdc_21_a = compute_pdc(A_coeffs_est_a, fs_a)\n    peak_freq_a = freqs_a[np.argmax(pdc_21_a)]\n    error_a = float(abs(peak_freq_a - f0_a))\n    results.append(error_a)\n\n    # --- Case B: Robustness ---\n    fs_b = 200.0\n    f0_b = 40.0\n    p_b = 2\n    c_b = 0.25\n    noise_std_b = 1.0\n    N_b = 5000\n    burn_in_b = 1000\n    B_b = 50\n    L_b = 500\n    r_b = 0.98\n\n    A_coeffs_true_b = design_mvar_coeffs(f0_b, fs_b, r_b, c_b)\n    sigma_cov_true_b = np.diag([noise_std_b**2, noise_std_b**2])\n    X_b = generate_mvar_data(N_b, A_coeffs_true_b, sigma_cov_true_b, burn_in_b)\n    \n    n_segments = N_b // L_b\n    segments = [X_b[:, i*L_b:(i+1)*L_b] for i in range(n_segments)]\n    \n    correct_direction_count = 0\n    freq_band = (freqs_a >= f0_b - 5)  (freqs_a = f0_b + 5)\n\n    for _ in range(B_b):\n        bootstrap_indices = np.random.choice(n_segments, size=n_segments, replace=True)\n        X_boot = np.hstack([segments[i] for i in bootstrap_indices])\n        \n        A_coeffs_est_b, _ = fit_mvar(X_boot, p_b)\n        _, pdc_12_b, pdc_21_b = compute_pdc(A_coeffs_est_b, fs_b)\n        \n        integ_21 = np.sum(pdc_21_b[freq_band])\n        integ_12 = np.sum(pdc_12_b[freq_band])\n        \n        if integ_21 > integ_12:\n            correct_direction_count += 1\n            \n    robustness_b = float(correct_direction_count / B_b)\n    results.append(robustness_b)\n\n    # --- Case C: Specificity ---\n    fs_c = 200.0\n    f0_c = 40.0\n    p_c = 2\n    c_c = 0.0 # Null model\n    noise_std_c = 0.5\n    N_c = 20000\n    burn_in_c = 1000\n    T_c = 0.25\n    r_c = 0.98\n\n    A_coeffs_true_c = design_mvar_coeffs(f0_c, fs_c, r_c, c_c)\n    sigma_cov_true_c = np.diag([noise_std_c**2, noise_std_c**2])\n    X_c = generate_mvar_data(N_c, A_coeffs_true_c, sigma_cov_true_c, burn_in_c)\n    A_coeffs_est_c, _ = fit_mvar(X_c, p_c)\n    _, pdc_12_c, pdc_21_c = compute_pdc(A_coeffs_est_c, fs_c)\n    \n    max_spurious_pdc = max(np.max(pdc_12_c), np.max(pdc_21_c))\n    specificity_c = bool(max_spurious_pdc  T_c)\n    results.append(specificity_c)\n    \n    # Final print statement\n    print(f\"[{results[0]},{results[1]},{str(results[2]).lower()}]\")\n\n\nsolve()\n```"
        }
    ]
}