{
    "hands_on_practices": [
        {
            "introduction": "Before diving into complex data analysis pipelines, it is essential to build a solid intuition for the fundamental definition of Inter-trial Phase Coherence (ITPC). This exercise guides you through deriving ITPC from first principles, treating individual trial phases as vectors in the complex plane . By manually computing the ITPC and the circular mean for a small, illustrative dataset, you will solidify your understanding of how these metrics quantify phase consistency and central tendency across trials.",
            "id": "4171087",
            "problem": "In a visual event-related potential study, a continuous intracranial electroencephalography signal is analyzed with a complex time–frequency transform. At a fixed time–frequency coordinate $(t^{\\ast}, f^{\\ast})$, the instantaneous phase of the analytic signal is extracted for $N$ independent trials of the same stimulus. The phases are measured in radians and given by the multiset\n$$\n\\{\\phi_n\\}_{n=1}^{N}=\\{0,\\,0,\\,0,\\,0,\\,0,\\,\\pi,\\,\\pi,\\,\\pi,\\,\\tfrac{\\pi}{3},\\,\\tfrac{\\pi}{3},\\,-\\tfrac{\\pi}{3},\\,-\\tfrac{\\pi}{3}\\}.\n$$\nHere $N=12$. Starting only from the fundamental identification that each phase $\\phi_n$ determines a direction on the unit circle in the complex plane and that the net directional tendency across trials is captured by the vector sum of these unit directions, derive from first principles the definitions for inter-trial phase coherence (ITPC) and the circular mean direction at $(t^{\\ast}, f^{\\ast})$. Then compute their values for the given phases.\n\nExpress the circular mean direction in radians. Provide your final answer as a single row matrix containing, in order, the inter-trial phase coherence and the circular mean direction. Do not include units in the final boxed answer. No rounding is required; report exact values if they exist.",
            "solution": "The problem requires the derivation of the definitions for inter-trial phase coherence (ITPC) and circular mean direction from first principles, followed by their computation for a given set of phase data. The fundamental principle provided is the representation of each phase $\\phi_n$ as a unit-length vector in the complex plane, with the net directional tendency given by their vector sum.\n\n**1. Derivation from First Principles**\n\nLet the number of independent trials be $N$. The phase of the signal at a specific time-frequency point in trial $n$ is $\\phi_n$, where $n \\in \\{1, 2, \\dots, N\\}$. Following the problem's guiding principle, each phase $\\phi_n$ is represented as a unit vector on the unit circle in the complex plane. This vector can be written as a complex number $z_n$ using Euler's formula:\n$$\nz_n = e^{i\\phi_n} = \\cos(\\phi_n) + i\\sin(\\phi_n)\n$$\nThe magnitude of each vector is $|z_n| = \\sqrt{\\cos^2(\\phi_n) + \\sin^2(\\phi_n)} = 1$.\n\nThe problem states that the net directional tendency is captured by the vector sum of these unit directions. We define this resultant vector, $R$, as the sum of all individual complex vectors:\n$$\nR = \\sum_{n=1}^{N} z_n = \\sum_{n=1}^{N} e^{i\\phi_n}\n$$\nTo find the *average* directional tendency, we normalize this sum by the number of trials, $N$. This yields the mean resultant vector, $\\bar{R}$:\n$$\n\\bar{R} = \\frac{1}{N} \\sum_{n=1}^{N} e^{i\\phi_n}\n$$\nThis mean resultant vector $\\bar{R}$ is a complex number that can be expressed in polar form as $\\bar{R} = |\\bar{R}| e^{i\\bar{\\phi}}$, where $|\\bar{R}|$ is its magnitude and $\\bar{\\phi}$ is its angle (argument).\n\nThe magnitude, $|\\bar{R}|$, quantifies the consistency or clustering of the phases across trials. If all phases are identical, i.e., $\\phi_n = \\phi$ for all $n$, then $\\bar{R} = \\frac{1}{N} \\sum_{n=1}^{N} e^{i\\phi} = \\frac{1}{N}(N e^{i\\phi}) = e^{i\\phi}$, and its magnitude is $|\\bar{R}| = 1$. This represents perfect phase coherence. Conversely, if the phases are uniformly distributed around the unit circle, the vector sum tends to cancel out, $\\sum e^{i\\phi_n} \\to 0$, so $|\\bar{R}| \\to 0$. This represents a complete lack of phase coherence. Therefore, the magnitude of the mean resultant vector is the formal definition of **Inter-Trial Phase Coherence (ITPC)**.\n$$\n\\text{ITPC} = \\left| \\frac{1}{N} \\sum_{n=1}^{N} e^{i\\phi_n} \\right|\n$$\nThe value of ITPC is bounded between $0$ and $1$.\n\nThe angle, $\\bar{\\phi} = \\arg(\\bar{R})$, of the mean resultant vector represents the central tendency of the distribution of phases. This angle is the **circular mean direction**. It is the argument of the sum of the vectors, as dividing by the positive real number $N$ does not change the angle.\n$$\n\\bar{\\phi} = \\arg\\left( \\sum_{n=1}^{N} e^{i\\phi_n} \\right)\n$$\nTo compute this, we can first express the sum in Cartesian form:\n$$\n\\sum_{n=1}^{N} e^{i\\phi_n} = \\sum_{n=1}^{N} \\cos(\\phi_n) + i \\sum_{n=1}^{N} \\sin(\\phi_n)\n$$\nThe argument $\\bar{\\phi}$ is then found using the two-argument arctangent function, $\\text{atan2}(y, x)$:\n$$\n\\bar{\\phi} = \\text{atan2}\\left(\\sum_{n=1}^{N} \\sin(\\phi_n), \\sum_{n=1}^{N} \\cos(\\phi_n)\\right)\n$$\n\n**2. Computation for the Given Data**\n\nThe problem provides $N=12$ trials with the following multiset of phases in radians:\n$$\n\\{\\phi_n\\}_{n=1}^{12}=\\{0,\\,0,\\,0,\\,0,\\,0,\\,\\pi,\\,\\pi,\\,\\pi,\\,\\tfrac{\\pi}{3},\\,\\tfrac{\\pi}{3},\\,-\\tfrac{\\pi}{3},\\,-\\tfrac{\\pi}{3}\\}\n$$\nWe compute the resultant vector $R$ by summing the corresponding complex exponentials. We can group the terms by their phase value:\n- $5$ trials with $\\phi = 0$\n- $3$ trials with $\\phi = \\pi$\n- $2$ trials with $\\phi = \\frac{\\pi}{3}$\n- $2$ trials with $\\phi = -\\frac{\\pi}{3}$\n\nThe sum is:\n$$\nR = \\sum_{n=1}^{12} e^{i\\phi_n} = 5 \\cdot e^{i0} + 3 \\cdot e^{i\\pi} + 2 \\cdot e^{i\\pi/3} + 2 \\cdot e^{-i\\pi/3}\n$$\nWe evaluate the complex exponentials:\n- $e^{i0} = \\cos(0) + i\\sin(0) = 1$\n- $e^{i\\pi} = \\cos(\\pi) + i\\sin(\\pi) = -1$\n- $e^{i\\pi/3} = \\cos(\\pi/3) + i\\sin(\\pi/3) = \\frac{1}{2} + i\\frac{\\sqrt{3}}{2}$\n- $e^{-i\\pi/3} = \\cos(-\\pi/3) + i\\sin(-\\pi/3) = \\frac{1}{2} - i\\frac{\\sqrt{3}}{2}$\n\nSubstituting these values into the sum for $R$:\n$$\nR = 5(1) + 3(-1) + 2\\left(\\frac{1}{2} + i\\frac{\\sqrt{3}}{2}\\right) + 2\\left(\\frac{1}{2} - i\\frac{\\sqrt{3}}{2}\\right)\n$$\n$$\nR = 5 - 3 + (1 + i\\sqrt{3}) + (1 - i\\sqrt{3})\n$$\nGrouping the real and imaginary parts:\n$$\nR = (5 - 3 + 1 + 1) + i(\\sqrt{3} - \\sqrt{3})\n$$\n$$\nR = 4 + i0 = 4\n$$\nNow we compute the mean resultant vector $\\bar{R}$:\n$$\n\\bar{R} = \\frac{R}{N} = \\frac{4}{12} = \\frac{1}{3}\n$$\nThe **Inter-Trial Phase Coherence (ITPC)** is the magnitude of $\\bar{R}$:\n$$\n\\text{ITPC} = |\\bar{R}| = \\left|\\frac{1}{3}\\right| = \\frac{1}{3}\n$$\nThe **circular mean direction** $\\bar{\\phi}$ is the argument of $\\bar{R}$:\n$$\n\\bar{\\phi} = \\arg(\\bar{R}) = \\arg\\left(\\frac{1}{3}\\right)\n$$\nSince $\\frac{1}{3}$ is a positive real number, its angle on the complex plane is $0$.\n$$\n\\bar{\\phi} = 0 \\text{ radians}\n$$\nThe required values are an ITPC of $\\frac{1}{3}$ and a circular mean direction of $0$ radians.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{3} & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Observing a non-zero ITPC value is only the first step; the critical next question is whether this coherence is statistically significant or could have arisen by chance. This practice introduces a powerful non-parametric method for statistical inference: permutation testing based on random circular shifts . You will implement an algorithm to create a null distribution that preserves the temporal dynamics within each trial while breaking the cross-trial phase alignment, allowing for a robust assessment of your observed ITPC.",
            "id": "4171116",
            "problem": "You are given phase time series across trials at a single frequency and asked to estimate the statistical significance of inter-trial phase coherence using a permutation-based null constructed by random circular shifts within trials. The inter-trial phase coherence quantifies the consistency of phase across trials at a given time and frequency. For a single time index $t^{\\star}$ and frequency index $f^{\\star}$, the observed inter-trial phase coherence is computed from the phase values across trials at that $(t^{\\star}, f^{\\star})$. All phase angles are measured in radians. The permutation-based null is constructed by independently circularly shifting each trial’s phase time series along the time axis by a random lag sampled uniformly from $\\{0,1,\\dots,T-1\\}$, where $T$ is the number of time samples per trial, and recomputing the inter-trial phase coherence at $(t^{\\star}, f^{\\star})$. Repeating this procedure yields a distribution of null inter-trial phase coherence values that preserves within-trial temporal structure while disrupting cross-trial alignment at the analysis time point.\n\nFundamental base definitions: Let there be $N$ trials and $T$ time samples per trial. At a fixed frequency, denote the phase for trial $n$ at time $t$ by $\\phi_{n}(t)$, for $n \\in \\{1,2,\\dots,N\\}$ and $t \\in \\{0,1,\\dots,T-1\\}$. Define the unit complex phasor associated with $\\phi_{n}(t)$ by $z_{n}(t) = e^{i \\phi_{n}(t)}$, where $i$ is the imaginary unit. The inter-trial phase coherence at time $t$ is the magnitude of the mean unit phasor across trials at that time, namely\n$$\n\\mathrm{ITPC}(t) = \\left| \\frac{1}{N} \\sum_{n=1}^{N} z_{n}(t) \\right| = \\left| \\frac{1}{N} \\sum_{n=1}^{N} e^{i \\phi_{n}(t)} \\right|.\n$$\n\nPermutation-based null construction: For each permutation $p \\in \\{1,2,\\dots,P\\}$, independently sample a circular shift lag $k_{n}^{(p)} \\in \\{0,1,\\dots,T-1\\}$ for each trial $n$ and form the shifted phase time series $\\phi_{n}^{(p)}(t) = \\phi_{n}\\big((t - k_{n}^{(p)}) \\bmod T\\big)$. Compute the inter-trial phase coherence at $t^{\\star}$ from the shifted trials,\n$$\n\\mathrm{ITPC}^{(p)}(t^{\\star}) = \\left| \\frac{1}{N} \\sum_{n=1}^{N} e^{i \\phi_{n}^{(p)}(t^{\\star})} \\right|.\n$$\nThe collection $\\{\\mathrm{ITPC}^{(p)}(t^{\\star})\\}_{p=1}^{P}$ is the permutation-based null distribution at $(t^{\\star}, f^{\\star})$.\n\nStatistical assessment: Use the permutation-based null to compute a one-sided $p$-value for the observed inter-trial phase coherence $\\mathrm{ITPC}_{\\mathrm{obs}}(t^{\\star})$ as the fraction of null values that are greater than or equal to the observed value, with a standard finite-sample correction to avoid a zero probability estimate.\n\nYour task is to implement a program that:\n1. Constructs specified synthetic phase time series $\\phi_{n}(t)$ (in radians) for each test case below.\n2. Computes the observed inter-trial phase coherence $\\mathrm{ITPC}_{\\mathrm{obs}}(t^{\\star})$.\n3. Generates $P$ permutation-based null samples by random circular shifts per trial and computes the null distribution $\\{\\mathrm{ITPC}^{(p)}(t^{\\star})\\}_{p=1}^{P}$.\n4. Computes the one-sided $p$-value for each test case as a decimal in $[0,1]$, rounded to six decimal places.\n5. Produces a single line of output containing the $p$-values for all test cases as a comma-separated list enclosed in square brackets.\n\nAngle unit requirement: All phases are expressed in radians. No degree values should be used.\n\nTest suite and data generation specifications:\n- For each case, the program must use the specified random number seed to ensure reproducibility. Random sampling is performed using a pseudo-random number generator initialized with the given seed. All phases must be wrapped into the interval $[-\\pi, \\pi]$ after construction to ensure valid angle values.\n\n- Case A (happy path with partial alignment at the analysis time):\n  - Trials $N = 24$, time samples $T = 400$, permutations $P = 2000$, analysis time index $t^{\\star} = 200$, seed $s = 42$.\n  - Data construction: Initialize $\\phi_{n}(t)$ as independent samples from $\\mathcal{U}([-\\pi,\\pi])$ for all $n$ and $t$. Impose partial alignment at $t^{\\star}$ by setting $\\phi_{n}(t^{\\star}) = \\theta + \\epsilon_{n}$ for all $n$, where $\\theta = 1.0$ and $\\epsilon_{n} \\sim \\mathcal{N}(0, \\sigma^{2})$ with $\\sigma = 0.3$. Wrap angles into $[-\\pi,\\pi]$.\n\n- Case B (random phases, no alignment):\n  - Trials $N = 24$, time samples $T = 400$, permutations $P = 2000$, analysis time index $t^{\\star} = 123$, seed $s = 123$.\n  - Data construction: $\\phi_{n}(t)$ are independent samples from $\\mathcal{U}([-\\pi,\\pi])$ for all $n$ and $t$. Wrap angles into $[-\\pi,\\pi]$.\n\n- Case C (perfect alignment at the analysis time):\n  - Trials $N = 50$, time samples $T = 300$, permutations $P = 2000$, analysis time index $t^{\\star} = 150$, seed $s = 7$.\n  - Data construction: Initialize $\\phi_{n}(t)$ as independent samples from $\\mathcal{U}([-\\pi,\\pi])$ for all $n$ and $t$. Impose perfect alignment at $t^{\\star}$ by setting $\\phi_{n}(t^{\\star}) = 0$ for all $n$. Wrap angles into $[-\\pi,\\pi]$.\n\n- Case D (boundary case with a degenerate time axis):\n  - Trials $N = 10$, time samples $T = 1$, permutations $P = 1000$, analysis time index $t^{\\star} = 0$, seed $s = 2024$.\n  - Data construction: $\\phi_{n}(t)$ are independent samples from $\\mathcal{U}([-\\pi,\\pi])$ for all $n$ and $t$. Wrap angles into $[-\\pi,\\pi]$.\n\nAnswer specification:\n- For each case, the program must compute the one-sided permutation $p$-value defined as\n$$\np = \\frac{1 + \\sum_{p=1}^{P} \\mathbf{1}\\left\\{\\mathrm{ITPC}^{(p)}(t^{\\star}) \\ge \\mathrm{ITPC}_{\\mathrm{obs}}(t^{\\star})\\right\\}}{P + 1},\n$$\nwhere $\\mathbf{1}\\{\\cdot\\}$ is the indicator function.\n- The final program output must be a single line with the format $[\\text{p\\_A},\\text{p\\_B},\\text{p\\_C},\\text{p\\_D}]$, where each $\\text{p\\_X}$ is the $p$-value for case $X$ rounded to six decimal places and expressed as a decimal in $[0,1]$ with no percent sign.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$).",
            "solution": "The problem requires the implementation of a permutation-based statistical test to evaluate the significance of inter-trial phase coherence (ITPC) in synthetic time series data. The solution involves data generation, computation of the observed ITPC, construction of a null distribution using circular shifts, and calculation of a $p$-value. The process is validated against fundamental principles of signal processing and non-parametric statistics in neuroscience.\n\nThe core quantity of interest is the Inter-Trial Phase Coherence, $\\mathrm{ITPC}(t)$. For a given time point $t$ and a fixed frequency, we have a set of phase angles $\\{\\phi_{n}(t)\\}_{n=1}^{N}$ across $N$ trials. Each phase angle $\\phi_{n}(t)$ can be represented as a unit vector, or phasor, $z_{n}(t) = e^{i \\phi_{n}(t)}$ in the complex plane, where $i$ is the imaginary unit. The $\\mathrm{ITPC}(t)$ is defined as the magnitude of the average of these phasors:\n$$\n\\mathrm{ITPC}(t) = \\left| \\frac{1}{N} \\sum_{n=1}^{N} z_{n}(t) \\right| = \\left| \\frac{1}{N} \\sum_{n=1}^{N} e^{i \\phi_{n}(t)} \\right|\n$$\nThis value ranges from $0$ to $1$. An $\\mathrm{ITPC}$ value near $1$ indicates that the phase angles across trials are highly consistent (i.e., tightly clustered), suggesting a strong neural synchronization to an event. Conversely, an $\\mathrm{ITPC}$ value near $0$ indicates that the phases are distributed randomly or uniformly across trials, suggesting a lack of consistent synchronization.\n\nTo determine if an observed $\\mathrm{ITPC}_{\\mathrm{obs}}$ at a specific time $t^{\\star}$ is statistically significant, we must compare it to a null hypothesis. The null hypothesis, $H_0$, posits that there is no true phase consistency across trials at time $t^{\\star}$. Any observed coherence is merely due to chance. A powerful, non-parametric method to generate a distribution under $H_0$ is permutation testing.\n\nThe specific permutation strategy employed here is the random circular shift of each trial's time series. For each of $P$ permutations, and for each trial $n \\in \\{1, 2, \\dots, N\\}$, the entire phase time series $\\phi_n(t)$ is circularly shifted by a random lag $k_n^{(p)}$, chosen uniformly from $\\{0, 1, \\dots, T-1\\}$, where $T$ is the number of time points. This creates a new set of permuted phase time series, $\\phi_n^{(p)}(t) = \\phi_n\\big((t - k_n^{(p)}) \\pmod T\\big)$.\n\nThis procedure is principled because it selectively disrupts the cross-trial temporal alignment at the analysis time $t^{\\star}$ while preserving the intrinsic temporal structure (like autocorrelation) within each trial. By drawing the phase for trial $n$ from a random time point within that same trial, we effectively simulate the null hypothesis: the phase at time $t^{\\star}$ for trial $n$ is unrelated to the phase at $t^{\\star}$ for any other trial $m \\neq n$.\n\nThe algorithmic procedure for each test case is as follows:\n\n1.  **Data Generation**: The phase data matrix $\\phi_{n}(t)$ of size $N \\times T$ is constructed according to the specifications for each case. A pseudo-random number generator is initialized with the given seed $s$ for reproducibility. For all cases, after the initial values are generated and specific alignments are imposed, all phase angles in the matrix are wrapped to the interval $[-\\pi, \\pi]$ to ensure they are valid. This is achieved using the function `arctan2(sin(angle), cos(angle))`.\n\n2.  **Observed Statistic Calculation**: The observed inter-trial phase coherence, $\\mathrm{ITPC}_{\\mathrm{obs}}(t^{\\star})$, is computed using the generated phase data at the analysis time index $t^{\\star}$. The phases $\\phi_n(t^{\\star})$ from all $N$ trials are extracted, converted to complex phasors $e^{i \\phi_n(t^{\\star})}$, averaged, and the absolute value of this complex mean is taken.\n\n3.  **Null Distribution Construction**: A loop is executed $P$ times to generate the null distribution. In each iteration $p$:\n    a. A vector of $N$ random integer lags, $\\{k_n^{(p)}\\}_{n=1}^N$, is sampled uniformly from $\\{0, 1, \\dots, T-1\\}$.\n    b. For each trial $n$, the phase at the shifted time index, $(t^{\\star} - k_n^{(p)}) \\pmod T$, is retrieved from the original data matrix $\\phi_n(t)$. This forms the set of permuted phases for this iteration.\n    c. The null ITPC, $\\mathrm{ITPC}^{(p)}(t^{\\star})$, is calculated from this set of permuted phases in the same way as $\\mathrm{ITPC}_{\\mathrm{obs}}(t^{\\star})$.\n    d. The resulting value is stored, forming the null distribution $\\{\\mathrm{ITPC}^{(p)}(t^{\\star})\\}_{p=1}^{P}$.\n\n4.  **p-Value Computation**: The one-sided $p$-value is calculated to assess the significance of $\\mathrm{ITPC}_{\\mathrm{obs}}(t^{\\star})$. It is the proportion of null ITPC values that are greater than or equal to the observed value. A standard finite-sample correction is applied to prevent $p$-values of $0$ and provide a more conservative estimate:\n    $$\n    p = \\frac{1 + \\sum_{p=1}^{P} \\mathbf{1}\\left\\{\\mathrm{ITPC}^{(p)}(t^{\\star}) \\ge \\mathrm{ITPC}_{\\mathrm{obs}}(t^{\\star})\\right\\}}{P + 1}\n    $$\n    where $\\mathbf{1}\\{\\cdot\\}$ is the indicator function, which is $1$ if the condition is true and $0$ otherwise. The final value is rounded to six decimal places.\n\nThis entire process is systematically applied to each of the four test cases defined in the problem, yielding four distinct $p$-values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _wrap_to_pi(angles):\n    \"\"\"\n    Wraps angles to the interval [-pi, pi].\n    This is a robust way to handle angle wrapping for any real-valued input.\n    \"\"\"\n    return np.arctan2(np.sin(angles), np.cos(angles))\n\ndef calculate_itpc_p_value(N, T, P, t_star, seed, data_gen_params):\n    \"\"\"\n    Calculates the permutation-based p-value for inter-trial phase coherence (ITPC).\n\n    Args:\n        N (int): Number of trials.\n        T (int): Number of time samples per trial.\n        P (int): Number of permutations.\n        t_star (int): Analysis time index.\n        seed (int): Seed for the random number generator.\n        data_gen_params (dict): Parameters for data generation.\n\n    Returns:\n        float: The computed p-value.\n    \"\"\"\n    # 1. Initialization and RNG\n    rng = np.random.default_rng(seed)\n\n    # 2. Data Generation\n    # Initialize with uniform random phases\n    phi_nt = rng.uniform(-np.pi, np.pi, size=(N, T))\n\n    # Apply case-specific modifications\n    case_type = data_gen_params.get('type', 'random')\n    if case_type == 'partial_alignment':\n        theta = data_gen_params['theta']\n        sigma = data_gen_params['sigma']\n        noise = rng.normal(loc=0.0, scale=sigma, size=N)\n        phi_nt[:, t_star] = theta + noise\n    elif case_type == 'perfect_alignment':\n        phi_nt[:, t_star] = 0.0\n\n    # Wrap all generated phases to [-pi, pi] as per problem specification.\n    phi_nt = _wrap_to_pi(phi_nt)\n\n    # 3. Compute Observed ITPC\n    phases_obs = phi_nt[:, t_star]\n    itpc_obs = np.abs(np.mean(np.exp(1j * phases_obs)))\n\n    # 4. Generate Null Distribution\n    itpc_null = np.zeros(P)\n    \n    # Pre-generate all random shifts for efficiency\n    all_shifts = rng.integers(0, T, size=(P, N))\n\n    for p in range(P):\n        shifts = all_shifts[p, :]\n        permuted_time_indices = (t_star - shifts) % T\n\n        # Use fancy indexing to get all permuted phases for this iteration\n        permuted_phases = phi_nt[np.arange(N), permuted_time_indices]\n\n        itpc_null[p] = np.abs(np.mean(np.exp(1j * permuted_phases)))\n\n    # 5. Compute p-value\n    count = np.sum(itpc_null >= itpc_obs)\n    p_value = (1.0 + count) / (P + 1.0)\n\n    return p_value\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: happy path with partial alignment\n        {'N': 24, 'T': 400, 'P': 2000, 't_star': 200, 'seed': 42,\n         'data_gen_params': {'type': 'partial_alignment', 'theta': 1.0, 'sigma': 0.3}},\n        # Case B: random phases, no alignment\n        {'N': 24, 'T': 400, 'P': 2000, 't_star': 123, 'seed': 123,\n         'data_gen_params': {'type': 'random'}},\n        # Case C: perfect alignment\n        {'N': 50, 'T': 300, 'P': 2000, 't_star': 150, 'seed': 7,\n         'data_gen_params': {'type': 'perfect_alignment'}},\n        # Case D: boundary case with degenerate time axis\n        {'N': 10, 'T': 1, 'P': 1000, 't_star': 0, 'seed': 2024,\n         'data_gen_params': {'type': 'degenerate'}}\n    ]\n\n    results = []\n    for case in test_cases:\n        p_val = calculate_itpc_p_value(**case)\n        results.append(f\"{p_val:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world neural recordings are often imperfect, with timing jitter and even missed stimulus events that can corrupt ITPC estimates by misaligning trials. This advanced practice tackles this critical data quality issue head-on by having you design and implement a matched-filter-based correction algorithm . This exercise demonstrates how to create a template of the expected neural response to precisely detect event onsets, reject unreliable trials, and ultimately improve the accuracy of your phase coherence analysis.",
            "id": "4171109",
            "problem": "You are tasked with designing, deriving, and implementing an algorithm that detects and corrects misaligned trials in event-locked neural time series to prevent misleading Inter-Trial Phase Coherence (ITPC) estimates. The educational context is neuroscience data analysis at the advanced graduate level, and the core topic is inter-trial phase coherence. Your program must be a complete, runnable program that generates its own synthetic data and produces the required outputs with no external inputs. All mathematical entities must be expressed in LaTeX. Acronyms must be defined at first use.\n\nConsider a continuous neural signal modeled as a Local Field Potential (LFP), denoted by $x(t)$, sampled at a rate $f_s$ samples per second. There are $N$ intended stimulus events, nominally scheduled at times $t_n^{\\mathrm{sch}} = n T$ for $n \\in \\{0,1,\\dots,N-1\\}$, where $T$ is the inter-event interval in seconds. The true event times $t_n^{\\mathrm{true}}$ deviate from the schedule due to jitter, and occasionally an event is physically absent (a “missed” stimulus), even though a naive segmentation might assume that all scheduled events occurred. The signal $x(t)$ is composed of the sum of stationary background noise and an evoked oscillation at frequency $f_0$ that resets phase to zero at each true event and decays exponentially with time constant $\\tau$:\n$$\nx(t) = \\eta(t) + \\sum_{n \\in \\mathcal{E}} A \\, e^{-(t - t_{n}^{\\mathrm{true}})/\\tau} \\cos\\left(2\\pi f_0 (t - t_{n}^{\\mathrm{true}})\\right) \\, \\mathbf{1}_{t \\ge t_{n}^{\\mathrm{true}}},\n$$\nwhere $\\eta(t)$ is zero-mean stationary noise, $A$ is the evoked amplitude, $\\tau$ is the decay time constant, $f_0$ is the phase-reset frequency of interest, and $\\mathcal{E}$ is the set of indices of trials where the stimulus physically occurred. The indicator function $\\mathbf{1}_{t \\ge t_{n}^{\\mathrm{true}}}$ enforces causality. The naive segmentation defines trial onsets at $t_n^{\\mathrm{sch}}$ without correcting for jitter or missed stimuli. Your algorithm must estimate corrected trial onsets $\\hat{t}_n$ near each $t_n^{\\mathrm{sch}}$ by detecting a phase-reset-consistent evoked response and must reject trials judged to lack a verifiable onset.\n\nStarting base: Use fundamental definitions and well-tested formulas only. Specifically:\n- Use the Fourier transform definition, the concept of instantaneous phase via the analytic signal, and the principle that a matched filter maximizing signal-to-noise ratio for a known template in additive Gaussian noise is the time-reversed template.\n- Use the definition that Inter-Trial Phase Coherence (ITPC) at a given time $t^\\*$ and frequency $f_0$ is the magnitude of the average of unit phasors derived from trial-wise phases, expressed as a decimal in $[0,1]$ (no percentage sign).\n- Angle unit must be radians.\n\nAlgorithmic task:\n1. Derive a matched-filter-based onset detector appropriate for an exponentially decaying cosine template at frequency $f_0$ with decay constant $\\tau$ that resets at zero phase at the event time. Formally, derive the decision statistic and the onset estimate $\\hat{t}_n$ within a search window of half-width $w$ seconds around each scheduled onset $t_n^{\\mathrm{sch}}$.\n2. Provide a principled thresholding rule to reject trials where no reliable onset is detected within the window. The threshold must be defined in relation to the distribution of the matched-filter scores within the search window and must not rely on arbitrary shortcuts.\n3. After obtaining the corrected onsets, compute ITPC at frequency $f_0$ and at a fixed post-onset time $t^\\*$ seconds, using the analytic signal (Hilbert transform of a band-pass filtered version of $x(t)$ centered on $f_0$). Angles must be measured in radians.\n\nEvaluation metrics and outputs:\n- For each test case, compute the mean absolute onset error (MAE) before correction, defined over the set of trials where the stimulus physically occurred and your algorithm ultimately accepts them, as\n$$\n\\mathrm{MAE}_{\\mathrm{before}} = \\frac{1}{M} \\sum_{m=1}^{M} \\left| t_{i_m}^{\\mathrm{sch}} - t_{i_m}^{\\mathrm{true}} \\right|,\n$$\nand after correction,\n$$\n\\mathrm{MAE}_{\\mathrm{after}} = \\frac{1}{M} \\sum_{m=1}^{M} \\left| \\hat{t}_{i_m} - t_{i_m}^{\\mathrm{true}} \\right|,\n$$\nwhere $\\{i_m\\}_{m=1}^{M}$ indexes the subset of physically occurring trials that your algorithm accepts (after thresholding), and $M$ is the count of accepted trials. Then compute the alignment improvement ratio\n$$\nr_{\\mathrm{align}} = \\frac{\\mathrm{MAE}_{\\mathrm{after}}}{\\mathrm{MAE}_{\\mathrm{before}}}.\n$$\n- For ITPC at the specified $t^\\*$ and $f_0$, compute the ground-truth ITPC using true onsets $\\{t_{i_m}^{\\mathrm{true}}\\}$, the naive ITPC using scheduled onsets $\\{t_{i_m}^{\\mathrm{sch}}\\}$, and the corrected ITPC using detected onsets $\\{\\hat{t}_{i_m}\\}$, all restricted to the same accepted set $\\{i_m\\}_{m=1}^{M}$. Let these be $\\mathrm{ITPC}_{\\mathrm{true}}$, $\\mathrm{ITPC}_{\\mathrm{naive}}$, and $\\mathrm{ITPC}_{\\mathrm{corr}}$, respectively. Define the ITPC error improvement ratio\n$$\nr_{\\mathrm{itpc}} = \\begin{cases}\n\\frac{\\left|\\mathrm{ITPC}_{\\mathrm{corr}} - \\mathrm{ITPC}_{\\mathrm{true}}\\right|}{\\left|\\mathrm{ITPC}_{\\mathrm{naive}} - \\mathrm{ITPC}_{\\mathrm{true}}\\right|}, & \\text{if } \\left|\\mathrm{ITPC}_{\\mathrm{naive}} - \\mathrm{ITPC}_{\\mathrm{true}}\\right| > 0, \\\\\n1, & \\text{otherwise.}\n\\end{cases}\n$$\n\nAngle unit requirement: All phases must be in radians. Frequency unit must be Hertz (Hz). Time unit must be seconds (s). Express all numerical outputs as decimals (no percentage sign).\n\nTest suite:\nImplement your algorithm on the following four synthetic test cases. In all cases, compute within a total duration sufficient to contain all scheduled events and their evoked decays.\n\n- Case $1$: $f_s = 1000$, $N = 60$, $T = 1.0$, $f_0 = 12.0$, $\\tau = 0.2$, $A = 1.0$, noise standard deviation $\\sigma_\\eta = 0.5$, jitter standard deviation $\\sigma_J = 0.005$, missed stimulus probability $p_{\\mathrm{miss}} = 0.05$, search half-width $w = 0.05$, matched filter kernel length $L_k = 0.5$, band-pass half-width $\\Delta f = 2.0$, post-onset phase sampling time $t^\\* = 0.1$, robust z-threshold $z_{\\mathrm{thr}} = 3.0$.\n- Case $2$: $f_s = 1000$, $N = 60$, $T = 1.0$, $f_0 = 12.0$, $\\tau = 0.2$, $A = 1.0$, $\\sigma_\\eta = 0.5$, $\\sigma_J = 0.02$, $p_{\\mathrm{miss}} = 0.0$, $w = 0.05$, $L_k = 0.5$, $\\Delta f = 2.0$, $t^\\* = 0.1$, $z_{\\mathrm{thr}} = 3.0$.\n- Case $3$: $f_s = 1000$, $N = 60$, $T = 1.0$, $f_0 = 12.0$, $\\tau = 0.2$, $A = 1.0$, $\\sigma_\\eta = 0.5$, $\\sigma_J = 0.02$, $p_{\\mathrm{miss}} = 0.2$, $w = 0.05$, $L_k = 0.5$, $\\Delta f = 2.0$, $t^\\* = 0.1$, $z_{\\mathrm{thr}} = 3.0$.\n- Case $4$: $f_s = 1000$, $N = 30$, $T = 1.0$, $f_0 = 10.0$, $\\tau = 0.2$, $A = 0.6$, $\\sigma_\\eta = 0.7$, $\\sigma_J = 0.05$, $p_{\\mathrm{miss}} = 0.1$, $w = 0.07$, $L_k = 0.5$, $\\Delta f = 2.0$, $t^\\* = 0.12$, $z_{\\mathrm{thr}} = 3.0$.\n\nOutput specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$$\n\\left[ r_{\\mathrm{align}}^{(1)}, r_{\\mathrm{itpc}}^{(1)}, r_{\\mathrm{align}}^{(2)}, r_{\\mathrm{itpc}}^{(2)}, r_{\\mathrm{align}}^{(3)}, r_{\\mathrm{itpc}}^{(3)}, r_{\\mathrm{align}}^{(4)}, r_{\\mathrm{itpc}}^{(4)} \\right],\n$$\nwhere the superscript indicates the test case index. Each element must be a decimal number.\n\nAngle unit: radians. Frequency unit: Hertz. Time unit: seconds.\n\nYour program must be self-contained and runnable without any user input. It must use only Python with the specified libraries and must adhere to the exact output format above.",
            "solution": "The problem as stated is scientifically sound, well-posed, and provides sufficient information for a unique algorithmic implementation and solution. The premises are grounded in established principles of neuroscience data analysis and signal processing. Therefore, a full solution is warranted.\n\nThe overarching goal is to correct for timing inaccuracies (jitter) and absences (missed stimuli) in event-related neural data to obtain a more accurate estimate of Inter-Trial Phase Coherence (ITPC), a measure of neural response consistency across trials. The solution comprises four main stages: (1) generation of synthetic data according to the specified model; (2) detection of event onsets using a matched filter; (3) rejection of trials lacking a clear event-related response based on a robust statistical threshold; and (4) computation of ITPC and evaluation metrics based on the corrected trial alignments.\n\n### 1. Synthetic Data Generation\n\nFirst, we synthesize the neural time series $x(t)$ according to the provided model:\n$$\nx(t) = \\eta(t) + \\sum_{n \\in \\mathcal{E}} A \\, e^{-(t - t_{n}^{\\mathrm{true}})/\\tau} \\cos\\left(2\\pi f_0 (t - t_{n}^{\\mathrm{true}})\\right) \\, \\mathbf{1}_{t \\ge t_{n}^{\\mathrm{true}}}\n$$\nA continuous time vector is created with a sampling frequency $f_s$. The scheduled event times are $t_n^{\\mathrm{sch}} = nT$. For each trial $n \\in \\{0, 1, \\dots, N-1\\}$, a pseudo-random determination is made as to whether the stimulus is missed, with probability $p_{\\mathrm{miss}}$. If the stimulus occurs (index $n \\in \\mathcal{E}$), its true onset time $t_n^{\\mathrm{true}}$ is generated by adding Gaussian jitter with standard deviation $\\sigma_J$ to the scheduled time: $t_n^{\\mathrm{true}} = t_n^{\\mathrm{sch}} + \\mathcal{N}(0, \\sigma_J^2)$. The background noise $\\eta(t)$ is modeled as a sequence of independent and identically distributed random variables from a Gaussian distribution with zero mean and standard deviation $\\sigma_\\eta$. The final signal $x(t)$ is the sum of this noise and the evoked responses from all non-missed trials.\n\n### 2. Matched Filter for Onset Detection\n\nTo find the most likely onset time of an evoked response near each scheduled time $t_n^{\\mathrm{sch}}$, we use a matched filter. A matched filter is optimal for detecting a known signal template in additive white Gaussian noise, as it maximizes the signal-to-noise ratio (SNR) of the filter's output.\n\n**Template and Kernel Derivation:**\nThe template signal, representing the expected evoked response starting at time $t=0$, is an exponentially decaying cosine wave:\n$$\nh(t') = e^{-t'/\\tau} \\cos(2\\pi f_0 t') \\quad \\text{for } t' \\in [0, L_k]\n$$\nwhere $L_k$ is the kernel length. The amplitude $A$ is a scaling constant and can be omitted from the template definition without loss of generality. According to signal detection theory, the impulse response of the matched filter, denoted $k(t')$, is the time-reversed version of the template:\n$$\nk(t') = h(L_k - t') = e^{-(L_k - t')/\\tau} \\cos\\left(2\\pi f_0 (L_k - t')\\right) \\quad \\text{for } t' \\in [0, L_k]\n$$\n\n**Decision Statistic and Onset Estimation:**\nThe decision statistic is obtained by convolving the input signal $x(t)$ with the matched filter kernel $k(t')$. The output of this convolution, $y(t) = (x * k)(t)$, will exhibit a peak when the pattern in $x(t)$ matches the template $h(t')$. A known property of convolution is that if the signal $x(t)$ contains the template starting at $t_{true}$, $h(t-t_{true})$, the convolution output $y(t)$ will peak at time $t = t_{true} + L_k$.\n\nTherefore, for each scheduled trial $n$, we perform the following steps:\n1.  Compute the matched filter output $y(t)$ by convolving the entire time series $x(t)$ with $k(t')$.\n2.  Define a search window in the output signal $y(t)$ corresponding to the temporal window $[t_n^{\\mathrm{sch}} - w, t_n^{\\mathrm{sch}} + w]$ in the input signal. Accounting for the $L_k$ delay, the search is performed in $y(t)$ over the interval $[t_n^{\\mathrm{sch}} - w + L_k, t_n^{\\mathrm{sch}} + w + L_k]$.\n3.  Find the time $t_{peak}$ at which $y(t)$ reaches its maximum value within this search window.\n4.  The estimated onset time for trial $n$ is then corrected for the filter-induced delay: $\\hat{t}_n = t_{peak} - L_k$.\n5.  The peak value $S_n = y(t_{peak})$ serves as the detection score for the trial.\n\n### 3. Trial Rejection with a Robust Threshold\n\nNot all scheduled trials will contain a detectable evoked response, either due to a missed stimulus or the response being obscured by noise. A principled thresholding rule is required to reject such trials. The problem specifies a \"robust z-threshold,\" which we implement using the distribution of the matched filter scores within the search window itself.\n\nFor each trial $n$, we consider the set of matched filter output values $\\{y(t)\\}$ for $t$ within the search interval $[t_n^{\\mathrm{sch}} - w + L_k, t_n^{\\mathrm{sch}} + w + L_k]$. These values primarily reflect filtered noise. We can robustly estimate the location and scale of this noise distribution using the median and Median Absolute Deviation (MAD):\n-   Median: $m_y = \\mathrm{median}(\\{y(t)\\})$\n-   Median Absolute Deviation: $\\mathrm{MAD}_y = \\mathrm{median}(\\{|y(t) - m_y|\\})$\n\nThe standard deviation $\\sigma_y$ of the noise scores can be robustly estimated from the MAD as $\\hat{\\sigma}_y = 1.4826 \\times \\mathrm{MAD}_y$. The constant $1.4826$ is derived from the inverse of the Gaussian cumulative distribution function at $0.75$, which makes this estimate consistent for normally distributed data.\n\nThe robust z-score for the peak detection score $S_n$ is:\n$$\nz_n = \\frac{S_n - m_y}{\\hat{\\sigma}_y}\n$$\nA trial $n$ is accepted if its peak score is sufficiently prominent relative to the background noise, i.e., if $z_n \\ge z_{\\mathrm{thr}}$. Otherwise, the trial is rejected.\n\n### 4. ITPC and Metric Calculation\n\nThe final analysis is performed on the set of trials that were both physically present (indices in $\\mathcal{E}$) and accepted by the algorithm. Let this set contain $M$ trials, indexed by $\\{i_m\\}_{m=1}^M$.\n\n**Inter-Trial Phase Coherence (ITPC):**\nITPC measures the phase consistency of neural oscillations across trials at a specific time and frequency. Its calculation involves:\n1.  **Epoching:** For each trial $i_m$ in the accepted set, extract an epoch of the signal $x(t)$ centered around the relevant onset time (true, naive, or corrected).\n2.  **Band-Pass Filtering:** Each epoch is band-pass filtered around the frequency of interest $f_0$ with a filter passband of $[f_0 - \\Delta f, f_0 + \\Delta f]$. A zero-phase filter (e.g., a Butterworth filter applied forwards and backwards) is crucial to avoid introducing phase distortions.\n3.  **Analytic Signal:** The analytic signal of the filtered epoch, $z_{i_m}(t')$, is computed using the Hilbert transform. $z_{i_m}(t') = x_{i_m, \\text{filt}}(t') + i \\mathcal{H}\\{x_{i_m, \\text{filt}}(t')\\}$, where $t'$ is time relative to the epoch's onset.\n4.  **Instantaneous Phase:** The instantaneous phase is extracted as the angle of the analytic signal: $\\phi_{i_m}(t') = \\arg(z_{i_m}(t'))$. Angles must be in radians.\n5.  **ITPC Value:** The phase is sampled at the post-onset time $t^\\*$. ITPC is the magnitude of the mean of the resulting unit phasors:\n    $$\n    \\mathrm{ITPC} = \\left| \\frac{1}{M} \\sum_{m=1}^{M} e^{i \\phi_{i_m}(t^\\*)} \\right|\n    $$\nThis procedure is repeated for three sets of onsets to compute $\\mathrm{ITPC}_{\\mathrm{true}}$, $\\mathrm{ITPC}_{\\mathrm{naive}}$, and $\\mathrm{ITPC}_{\\mathrm{corr}}$.\n\n**Evaluation Metrics:**\nThe performance of the alignment algorithm is quantified by two ratios:\n-   **Alignment Improvement Ratio ($r_{\\mathrm{align}}$):** This measures the reduction in timing error. It is the ratio of the Mean Absolute Error (MAE) after correction to the MAE before correction.\n    $$\n    r_{\\mathrm{align}} = \\frac{\\mathrm{MAE}_{\\mathrm{after}}}{\\mathrm{MAE}_{\\mathrm{before}}} = \\frac{\\frac{1}{M} \\sum_{m=1}^{M} \\left| \\hat{t}_{i_m} - t_{i_m}^{\\mathrm{true}} \\right|}{\\frac{1}{M} \\sum_{m=1}^{M} \\left| t_{i_m}^{\\mathrm{sch}} - t_{i_m}^{\\mathrm{true}} \\right|}\n    $$\n-   **ITPC Error Improvement Ratio ($r_{\\mathrm{itpc}}$):** This measures how much closer the corrected ITPC estimate is to the ground-truth ITPC compared to the naive estimate.\n    $$\n    r_{\\mathrm{itpc}} = \\frac{\\left|\\mathrm{ITPC}_{\\mathrm{corr}} - \\mathrm{ITPC}_{\\mathrm{true}}\\right|}{\\left|\\mathrm{ITPC}_{\\mathrm{naive}} - \\mathrm{ITPC}_{\\mathrm{true}}\\right|}\n    $$\nA value of $1$ is assigned if the denominator is zero. For both ratios, a value less than $1$ indicates an improvement due to the correction algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        {'fs': 1000, 'N': 60, 'T': 1.0, 'f0': 12.0, 'tau': 0.2, 'A': 1.0, 'sigma_eta': 0.5, 'sigma_J': 0.005, 'p_miss': 0.05, 'w': 0.05, 'L_k': 0.5, 'delta_f': 2.0, 't_star': 0.1, 'z_thr': 3.0},\n        {'fs': 1000, 'N': 60, 'T': 1.0, 'f0': 12.0, 'tau': 0.2, 'A': 1.0, 'sigma_eta': 0.5, 'sigma_J': 0.02, 'p_miss': 0.0, 'w': 0.05, 'L_k': 0.5, 'delta_f': 2.0, 't_star': 0.1, 'z_thr': 3.0},\n        {'fs': 1000, 'N': 60, 'T': 1.0, 'f0': 12.0, 'tau': 0.2, 'A': 1.0, 'sigma_eta': 0.5, 'sigma_J': 0.02, 'p_miss': 0.2, 'w': 0.05, 'L_k': 0.5, 'delta_f': 2.0, 't_star': 0.1, 'z_thr': 3.0},\n        {'fs': 1000, 'N': 30, 'T': 1.0, 'f0': 10.0, 'tau': 0.2, 'A': 0.6, 'sigma_eta': 0.7, 'sigma_J': 0.05, 'p_miss': 0.1, 'w': 0.07, 'L_k': 0.5, 'delta_f': 2.0, 't_star': 0.12, 'z_thr': 3.0},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        r_align, r_itpc = run_single_case(params)\n        all_results.extend([r_align, r_itpc])\n\n    # Format output precisely as required.\n    output_str = \",\".join([f\"{res:.8f}\" for res in all_results])\n    print(f\"[{output_str}]\")\n\n\ndef calculate_itpc(x_signal, onsets, fs, f0, delta_f, t_star, epoch_half_width=0.5):\n    \"\"\"\n    Calculates ITPC for a given signal and a set of onsets.\n    \"\"\"\n    if len(onsets) == 0:\n        return 0.0\n\n    nyquist = 0.5 * fs\n    low = (f0 - delta_f) / nyquist\n    high = (f0 + delta_f) / nyquist\n    b, a = signal.butter(4, [low, high], btype='band')\n\n    phases_at_t_star = []\n    \n    epoch_len_samples = int(2 * epoch_half_width * fs)\n    t_star_sample = int((epoch_half_width + t_star) * fs)\n\n    for onset_time in onsets:\n        onset_sample = int(onset_time * fs)\n        start_sample = onset_sample - int(epoch_half_width * fs)\n        end_sample = start_sample + epoch_len_samples\n\n        if start_sample  0 or end_sample > len(x_signal):\n            continue\n\n        epoch = x_signal[start_sample:end_sample]\n        filtered_epoch = signal.filtfilt(b, a, epoch)\n        analytic_signal = signal.hilbert(filtered_epoch)\n        \n        phase = np.angle(analytic_signal[t_star_sample])\n        phases_at_t_star.append(phase)\n    \n    if not phases_at_t_star:\n        return 0.0\n\n    phasors = np.exp(1j * np.array(phases_at_t_star))\n    itpc = np.abs(np.mean(phasors))\n    \n    return itpc\n\ndef run_single_case(params):\n    \"\"\"\n    Executes the full pipeline for a single test case.\n    \"\"\"\n    fs = params['fs']\n    N = params['N']\n    T = params['T']\n    f0 = params['f0']\n    tau = params['tau']\n    A = params['A']\n    sigma_eta = params['sigma_eta']\n    sigma_J = params['sigma_J']\n    p_miss = params['p_miss']\n    w = params['w']\n    L_k = params['L_k']\n    delta_f = params['delta_f']\n    t_star = params['t_star']\n    z_thr = params['z_thr']\n\n    # 1. Generate Synthetic Data\n    total_duration = N * T\n    t_vec = np.arange(0, total_duration, 1/fs)\n    x_signal = np.random.normal(0, sigma_eta, len(t_vec))\n    \n    scheduled_onsets = np.array([n * T for n in range(N)])\n    true_onsets_map = {}\n    physically_present_indices = []\n\n    for n in range(N):\n        if np.random.rand() >= p_miss:\n            jitter = np.random.normal(0, sigma_J)\n            t_true = scheduled_onsets[n] + jitter\n            true_onsets_map[n] = t_true\n            physically_present_indices.append(n)\n            \n            # Add evoked response to signal\n            onset_sample = int(t_true * fs)\n            if onset_sample  len(t_vec):\n                times_after_onset = t_vec[onset_sample:] - t_true\n                decay = A * np.exp(-times_after_onset / tau)\n                oscillation = np.cos(2 * np.pi * f0 * times_after_onset)\n                x_signal[onset_sample:] += decay * oscillation\n\n    # 2. Matched Filter Onset Detection\n    L_k_samples = int(L_k * fs)\n    t_kernel = np.arange(0, L_k_samples) / fs\n    template = np.exp(-t_kernel / tau) * np.cos(2 * np.pi * f0 * t_kernel)\n    kernel = template[::-1] # Time-reversal\n    \n    matched_filter_output = np.convolve(x_signal, kernel, mode='full')\n\n    detected_onsets_map = {}\n    accepted_trial_indices = []\n\n    w_samples = int(w * fs)\n    \n    for n in range(N):\n        t_sch = scheduled_onsets[n]\n        t_sch_sample = int(t_sch * fs)\n\n        # Search window in the convolved output (accounts for kernel length delay)\n        search_start_sample = t_sch_sample - w_samples + (L_k_samples - 1)\n        search_end_sample = t_sch_sample + w_samples + (L_k_samples - 1)\n        \n        if search_start_sample  0 or search_end_sample >= len(matched_filter_output):\n            continue\n\n        window_scores = matched_filter_output[search_start_sample:search_end_sample]\n        \n        peak_idx_in_window = np.argmax(window_scores)\n        peak_score = window_scores[peak_idx_in_window]\n        \n        # Robust z-score calculation\n        median_score = np.median(window_scores)\n        mad_score = np.median(np.abs(window_scores - median_score))\n        if mad_score > 1e-9:\n            sigma_robust = mad_score * 1.4826\n            z_score = (peak_score - median_score) / sigma_robust\n        else:\n            z_score = np.inf # If no variability, any peak is significant\n            \n        if z_score >= z_thr:\n            peak_sample_global = search_start_sample + peak_idx_in_window\n            # Correct for convolution delay to get onset time\n            onset_sample_est = peak_sample_global - (L_k_samples - 1)\n            detected_onsets_map[n] = onset_sample_est / fs\n            accepted_trial_indices.append(n)\n\n    # 3. Final trial selection for metrics\n    # Intersection of physically present and algorithmically accepted trials\n    final_indices = sorted(list(set(physically_present_indices)  set(accepted_trial_indices)))\n    \n    M = len(final_indices)\n    if M == 0:\n        # If no trials are accepted, metrics are undefined. Return non-improvement.\n        return 1.0, 1.0\n\n    # 4. Calculate Metrics\n    t_true_final = np.array([true_onsets_map[i] for i in final_indices])\n    t_sch_final = np.array([scheduled_onsets[i] for i in final_indices])\n    t_corr_final = np.array([detected_onsets_map[i] for i in final_indices])\n\n    mae_before = np.mean(np.abs(t_sch_final - t_true_final))\n    mae_after = np.mean(np.abs(t_corr_final - t_true_final))\n\n    r_align = mae_after / mae_before if mae_before > 0 else 1.0\n\n    itpc_true = calculate_itpc(x_signal, t_true_final, fs, f0, delta_f, t_star)\n    itpc_naive = calculate_itpc(x_signal, t_sch_final, fs, f0, delta_f, t_star)\n    itpc_corr = calculate_itpc(x_signal, t_corr_final, fs, f0, delta_f, t_star)\n    \n    itpc_err_naive = np.abs(itpc_naive - itpc_true)\n    itpc_err_corr = np.abs(itpc_corr - itpc_true)\n\n    r_itpc = itpc_err_corr / itpc_err_naive if itpc_err_naive > 0 else 1.0\n\n    return r_align, r_itpc\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}