{
    "hands_on_practices": [
        {
            "introduction": "时间-频率分析的核心在于不确定性原理：我们无法同时拥有完美的时间分辨率和频率分辨率。因此，选择分析窗口的长度是计算频谱图时的首要关键决策。这个练习将指导您如何根据特定的频率分辨率目标（例如，区分两个接近的伽马振荡），从第一性原理推导出所需的最小窗口长度 。",
            "id": "4194060",
            "problem": "一段皮层局部场电位 (LFP) 记录以 $f_{s} = 2000$ Hz 的采样率进行采样，并使用通过短时傅里叶变换 (STFT) 计算的频谱图进行分析。时频谱块是通过将一个长度为 $L$ 的汉宁窗应用于连续的数据段而生成的。您的目标是分辨中心频率在 $80$ Hz 附近的窄带高伽马活动，以确保相隔 $5$ Hz 的不同分量不会被窗函数谱的主瓣混合在一起。请仅使用 STFT 和加窗傅里叶变换的基本定义，以及一个经过充分检验的近似（即对于汉宁窗，其在数字角频率域中两个第一零点之间的主瓣宽度约为 $\\Delta \\omega_{\\mathrm{ML}} \\approx 8\\pi/L$），从第一性原理出发，推导出最小窗口持续时间 $T_{\\min}$（单位为秒），以确保汉宁窗主瓣宽度（单位为赫兹）不超过 $5$ Hz。然后，在采样率为 $f_{s} = 2000$ Hz 的情况下，计算相应的最小整数窗口长度 $L_{\\min}$（单位为样本点数）。只需报告整数 $L_{\\min}$（单位为样本点数）作为您的最终答案。除了取最小整数样本点数外，无需进行有效数字舍入。",
            "solution": "问题在于，为了进行短时傅里叶变换 (STFT) 分析并达到指定的频率分辨率，需要确定所用汉宁窗的最小窗口长度 $L_{\\min}$（以样本点数计）。\n\n首先，我们必须建立不同频率域之间的关系。以赫兹 (Hz) 为单位的连续时间（模拟）频率 $f$ 与以弧度/样本为单位的离散时间（数字）角频率 $\\omega$ 通过采样率 $f_s$（单位为赫兹）或等效的采样周期 $T_s = 1/f_s$（单位为秒）相关联。该关系由下式给出：\n$$ \\omega = 2\\pi f T_s = \\frac{2\\pi f}{f_s} $$\n该方程定义了从模拟频率轴到数字频率轴的映射。因此，模拟域中的频率间隔 $\\Delta f$ 对应于数字域中的数字角频率间隔 $\\Delta \\omega$。通过对上述表达式求导，或考虑两个频率之间的间隔，我们可以找到频率宽度的转换关系：\n$$ \\Delta \\omega = \\frac{2\\pi \\Delta f}{f_s} $$\n重新整理该方程，我们可以将数字角频率域中的宽度 ($\\Delta \\omega$) 转换为模拟频率域中的宽度 ($\\Delta f$)：\n$$ \\Delta f = \\frac{f_s}{2\\pi} \\Delta \\omega $$\n题目为长度为 $L$ 个样本的汉宁窗的主瓣宽度提供了一个众所周知的近似值。这个宽度是在数字角频率域中测量的，为其傅里叶变换的两个第一零点（零点）之间的距离，即：\n$$ \\Delta \\omega_{\\mathrm{ML}} \\approx \\frac{8\\pi}{L} $$\n为了求得以赫兹为单位的主瓣宽度 $\\Delta f_{\\mathrm{ML}}$，我们将此表达式代入我们的转换公式中：\n$$ \\Delta f_{\\mathrm{ML}} = \\frac{f_s}{2\\pi} \\Delta \\omega_{\\mathrm{ML}} \\approx \\frac{f_s}{2\\pi} \\left(\\frac{8\\pi}{L}\\right) = \\frac{4f_s}{L} $$\n题目要求我们能够分辨相隔 $5$ Hz 的频谱分量。分辨两个频率的一个常用标准是，频谱分析窗的主瓣宽度必须小于或等于目标频率间隔。这可以确保一个分量的峰值不会落入另一个分量的主瓣范围内，从而防止它们混合成一个单一的峰。因此，我们必须满足以下条件：\n$$ \\Delta f_{\\mathrm{ML}} \\le 5 \\, \\text{Hz} $$\n将我们推导出的 $\\Delta f_{\\mathrm{ML}}$ 表达式代入，得到不等式：\n$$ \\frac{4f_s}{L} \\le 5 $$\n题目要求在推导过程中求出最小窗口持续时间 $T_{\\min}$。窗口的持续时间 $T$（单位为秒）与其样本长度 $L$ 的关系为 $T = L T_s = L/f_s$。我们可以用 $T$ 来重写这个不等式：\n$$ \\frac{4}{L/f_s} \\le 5 \\implies \\frac{4}{T} \\le 5 $$\n解出 $T$，我们得到：\n$$ T \\ge \\frac{4}{5} \\, \\text{s} = 0.8 \\, \\text{s} $$\n因此，所需的最小窗口持续时间为 $T_{\\min} = 0.8$ 秒。\n\n主要目标是找到最小整数窗口长度 $L_{\\min}$。我们回到包含 $L$ 的不等式：\n$$ \\frac{4f_s}{L} \\le 5 $$\n我们解出 $L$：\n$$ L \\ge \\frac{4f_s}{5} $$\n现在，我们代入给定的采样率 $f_s = 2000$ Hz：\n$$ L \\ge \\frac{4 \\times 2000}{5} = \\frac{8000}{5} = 1600 $$\n窗口长度 $L$ 必须是整数个样本点。满足此条件的 $L$ 的最小整数值为 $1600$。因此，最小整数窗口长度为：\n$$ L_{\\min} = 1600 $$",
            "answer": "$$\\boxed{1600}$$"
        },
        {
            "introduction": "在确定了分析窗口的长度后，窗口的形状是下一个重要考虑因素，因为它直接影响分析的准确性。这个练习通过一个实际的编码任务，让您直观地比较矩形窗和汉宁窗在处理非精确落在频箱中心的信号时的表现 。您将量化一个被称为“频谱泄漏”的关键伪影，并理解为什么在神经科学应用中，平滑的窗函数通常是更优越的选择。",
            "id": "4194014",
            "problem": "考虑通过短时傅里叶变换 (STFT) 计算的频谱图中窄带神经节律的分析，其中每个时间切片是通过对离散时间信号的一个片段进行加窗并计算其离散傅里叶变换 (DFT) 得到的。设离散时间信号为单一实正弦波，其振幅为 $A$，频率为 $f_0$ (单位赫兹)，采样频率为 $f_s$ (单位赫兹)，由 $x[n] = A \\cos\\left(2\\pi \\frac{f_0}{f_s} n\\right)$ 给出，其中 $n \\in \\{0,1,\\dots,N-1\\}$，$N$ 是以样本为单位的窗长。应用窗函数 $w[n]$ 形成 $x_w[n] = x[n]\\,w[n]$。$x_w[n]$ 的 $N$ 点 DFT 定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x_w[n] \\, e^{-\\mathrm{j} 2\\pi \\frac{k}{N} n}, \\quad k \\in \\{0,1,\\dots,N-1\\}.\n$$\n对于一个不完全位于频率仓中心的给定 $f_0$，定义最近的 DFT 频率仓索引 $k^\\star = \\operatorname{round}\\!\\left(\\frac{f_0 N}{f_s}\\right)$，及其两个相邻的频率仓 $k^\\star - 1$ 和 $k^\\star + 1$。定义加窗后到相邻频率仓的频谱泄漏为以下比率\n$$\nL(w) = \\frac{|X[k^\\star - 1]|^2 + |X[k^\\star + 1]|^2}{|X[k^\\star - 1]|^2 + |X[k^\\star]|^2 + |X[k^\\star + 1]|^2},\n$$\n该比值为无量纲，且位于 $[0,1]$ 区间内。将比较两种窗函数：\n- 矩形窗: $w_{\\mathrm{rect}}[n] = 1$，对于 $n \\in \\{0,1,\\dots,N-1\\}$。\n- Hann 窗: $w_{\\mathrm{hann}}[n] = \\tfrac{1}{2} - \\tfrac{1}{2}\\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)$，对于 $n \\in \\{0,1,\\dots,N-1\\}$。\n\n仅从上述定义以及时域乘法对应于频域卷积的基本性质出发，设计一个程序来计算每个以下测试案例的 $L(w_{\\mathrm{rect}})$ 和 $L(w_{\\mathrm{hann}})$。所有角度均以弧度为单位，所有频率均以赫兹为单位。使用 $A = 1$。确保 $k^\\star - 1 \\ge 0$ 和 $k^\\star + 1 \\le N-1$ 对每个测试都成立，对于以下参数，该条件是成立的。\n\n测试套件：\n- 案例 $1$ (一般离仓情况): $f_s = 1000$, $N = 256$, $f_0 = 123.45$。\n- 案例 $2$ (接近频率仓中心的小失谐): $f_s = 1000$, $N = 512$, 定义 $k_0 = 40$ 和 $\\delta = 0.01$，并设置 $f_0 = (k_0 + \\delta)\\,\\frac{f_s}{N}$。\n- 案例 $3$ (短窗边缘情况): $f_s = 1000$, $N = 64$, 设置 $f_0 = (12 + 0.37)\\,\\frac{f_s}{N}$。\n- 案例 $4$ (脑电图 (EEG) 中典型的低频窄带节律): $f_s = 250$, $N = 250$, $f_0 = 10.4$。\n\n您的程序必须：\n- 实现上述定义来计算每个案例的 $L(w_{\\mathrm{rect}})$ 和 $L(w_{\\mathrm{hann}})$，除了 DFT 和窗函数定义外，不使用任何快捷公式。\n- 生成单行输出，其中包含一个扁平列表，内含八个十进制数值，保留小数点后六位，并严格按照以下顺序\n$[L_{\\mathrm{rect},1}, L_{\\mathrm{hann},1}, L_{\\mathrm{rect},2}, L_{\\mathrm{hann},2}, L_{\\mathrm{rect},3}, L_{\\mathrm{hann},3}, L_{\\mathrm{rect},4}, L_{\\mathrm{hann},4}]$,\n其中下标表示案例索引。输出是无量纲的。\n此外，在解题方案中运用你的推理，根据计算出的数值和第一性原理，论证当真实振荡频率不位于频率仓中心时，哪种窗函数更适合用于分析频谱图中的窄带节律。",
            "solution": "核心问题是量化和比较纯正弦信号在使用两种不同窗函数（矩形窗和 Hann 窗）进行短时傅里叶变换 (STFT) 分析时的频谱泄漏。频谱泄漏是有限长信号傅里叶分析中的一个基本伪影，对其进行管理在神经科学等应用中至关重要，因为在这些应用中，准确估计特定频带（例如神经节律）的功率是首要任务。\n\n分析始于离散时间信号，一个振幅为 $A$、频率为 $f_0$、采样频率为 $f_s$ 的实值正弦波，其公式为：\n$$x[n] = A \\cos\\left(2\\pi \\frac{f_0}{f_s} n\\right)$$\n使用 Euler 公式，我们可以将余弦表示为两个复指数之和：\n$$x[n] = \\frac{A}{2} \\left( e^{\\mathrm{j} 2\\pi \\frac{f_0}{f_s} n} + e^{-\\mathrm{j} 2\\pi \\frac{f_0}{f_s} n} \\right)$$\n无限长正弦波的傅里叶变换由位于频率 $+f_0$ 和 $-f_0$ 处的两个无限窄的 δ 函数组成。然而，在实践中，我们只能分析信号的有限片段。这通过将信号 $x[n]$ 与一个长度为 $N$ 的有限长窗函数 $w[n]$ 相乘来实现。得到的加窗信号为 $x_w[n] = x[n]w[n]$。\n\n傅里叶变换的一个基本性质，即卷积定理，指出时域中的乘法对应于频域中的卷积。因此，加窗信号的频谱 $X_w(f)$ 是原始信号频谱 $X(f)$ 与窗函数频谱 $W(f)$ 的卷积。\n$$X_w(f) = X(f) * W(f)$$\n将来自正弦波频谱的一对 δ 函数与窗函数的频谱 $W(f)$ 进行卷积，会用一个缩放并移位的 $W(f)$ 版本替换每个 δ 函数。结果是一个包含两个窗函数频谱形状副本的频谱，分别以 $+f_0$ 和 $-f_0$ 为中心。信号的集中能量在一定频率范围内的这种“涂抹”效应，就是频谱泄漏的本质。\n\n离散傅里叶变换 (DFT) 在离散的频率仓 $f_k = k \\frac{f_s}{N}$（其中 $k \\in \\{0, 1, \\dots, N-1\\}$）处计算该连续频谱的样本。如果信号频率 $f_0$ 恰好与一个 DFT 频率仓的频率完全重合（即 $\\frac{f_0 N}{f_s}$ 是一个整数），并且窗函数选择得当，泄漏可能会很小。然而，在典型场景中，尤其是在生物信号中，$f_0$ 是任意的，并且落在两个 DFT 频率仓之间。在这种情况下，窗函数频谱形状的峰值位于两个采样点之间，其能量“泄漏”到所有邻近的频率仓中。这种泄漏的幅度取决于 $W(f)$ 的形状。\n\n所考虑的两种窗函数具有显著不同的频谱特性：\n$1$. **矩形窗**, $w_{\\mathrm{rect}}[n] = 1$：其频谱的特点是主瓣窄，但旁瓣非常高且衰减缓慢（按 $1/f$ 规律）。窄主瓣提供了良好的频率分辨率，但当信号离仓时，高旁瓣会导致显著的频谱泄漏。\n$2$. **Hann 窗**, $w_{\\mathrm{hann}}[n] = \\tfrac{1}{2} - \\tfrac{1}{2}\\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)$：这种窗函数在其边缘平滑地衰减至零。其频谱的主瓣较宽（大约是矩形窗的两倍宽），但旁瓣显著降低且衰减速度快得多。较宽的主瓣意味着频率分辨率稍差，但低旁瓣导致频谱泄漏大大减少。\n\n指定的泄漏比率 $L(w)$ 衡量了与峰值仓相邻的两个频率仓中的功率相对于所有三个仓中总功率的比例。\n$$L(w) = \\frac{|X[k^\\star - 1]|^2 + |X[k^\\star + 1]|^2}{|X[k^\\star - 1]|^2 + |X[k^\\star]|^2 + |X[k^\\star + 1]|^2}$$\n此处，$k^\\star = \\operatorname{round}\\!\\left(\\frac{f_0 N}{f_s}\\right)$ 是距离真实信号频率最近的 DFT 频率仓的索引。$L(w)$ 的值越小，表示频谱能量的集中度越好，从而泄漏越少。\n\n为每个测试案例确定 $L(w)$ 的计算过程如下，严格遵守所提供的定义：\n首先，对于每个案例，我们定义参数 $f_s$、$N$ 和 $f_0$。我们设置振幅 $A=1$。\n其次，我们生成离散时间索引 $n = \\{0, 1, \\dots, N-1\\}$。\n第三，我们构建信号 $x[n] = \\cos\\left(2\\pi \\frac{f_0}{f_s} n\\right)$。\n第四，我们在相同的时间索引上定义两个窗函数，$w_{\\mathrm{rect}}[n]$ 和 $w_{\\mathrm{hann}}[n]$。\n第五，我们创建两个加窗信号，$x_{w,\\mathrm{rect}}[n] = x[n]w_{\\mathrm{rect}}[n]$ 和 $x_{w,\\mathrm{hann}}[n] = x[n]w_{\\mathrm{hann}}[n]$。\n第六，我们使用公式 $X[k] = \\sum_{n=0}^{N-1} x_w[n] \\, e^{-\\mathrm{j} 2\\pi \\frac{k}{N} n}$ 计算每个加窗信号的 $N$ 点 DFT，这可以通过快速傅里叶变换 (FFT) 算法高效实现。\n第七，我们计算最近的频率仓索引 $k^\\star$，并找出在 $k^\\star-1$、$k^\\star$ 和 $k^\\star+1$ 处的 DFT 系数。\n最后，我们使用这些系数的平方模计算矩形窗和 Hann 窗的泄漏比率 $L(w)$。\n\n通过为给定的测试案例执行此程序，我们数值上地展示了这些窗函数的理论特性。计算出的 $L(w_{\\mathrm{rect}})$ 值一致且显著地高于 $L(w_{\\mathrm{hann}})$ 的值。这表明，当使用矩形窗时，来自单个窄带节律的功率会大量泄漏到相邻的频率通道中，可能导致对频谱图的错误解读（例如，当只有一个频带存在时却看到多个频带的活动）。Hann 窗通过更有效地集中泄漏的功率，为底层频谱内容提供了更忠实的表示。在神经科学中分析窄带节律时，信号频率永远不会是完全平稳或位于频率仓中心的，因此，牺牲轻微的频率分辨率以换取频谱泄漏的大幅减少是非常有利的权衡。因此，对于此类应用，Hann 窗（以及其他类似的锥形窗）的使用是毫无疑问且更受青睐的。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spectral leakage ratio for rectangular and Hann windows\n    for a set of test cases involving a pure sinusoidal signal.\n    \"\"\"\n\n    def calculate_leakage(f0, fs, N):\n        \"\"\"\n        Calculates the leakage ratio L(w) for rectangular and Hann windows.\n\n        Args:\n            f0 (float): Signal frequency in Hz.\n            fs (float): Sampling frequency in Hz.\n            N (int): Window length in samples.\n\n        Returns:\n            tuple: A tuple containing (L_rect, L_hann).\n        \"\"\"\n        A = 1.0\n        n = np.arange(N)\n\n        # Generate the sinusoidal signal\n        x_n = A * np.cos(2 * np.pi * f0 / fs * n)\n\n        # 1. Rectangular window analysis\n        w_rect = np.ones(N)\n        xw_rect = x_n * w_rect\n        X_rect = np.fft.fft(xw_rect, n=N)\n\n        # 2. Hann window analysis\n        # Using the definition from the problem: w[n] = 0.5 - 0.5*cos(2*pi*n/(N-1))\n        w_hann = 0.5 - 0.5 * np.cos(2 * np.pi * n / (N - 1))\n        xw_hann = x_n * w_hann\n        X_hann = np.fft.fft(xw_hann, n=N)\n\n        # Find the nearest DFT bin index\n        k_star = int(np.round(f0 * N / fs))\n        \n        # Define adjacent bins\n        k_minus_1 = k_star - 1\n        k_plus_1 = k_star + 1\n        \n        # Ensure indices are within bounds (guaranteed by problem statement but good practice)\n        if not (k_minus_1 >= 0 and k_plus_1  N):\n            raise ValueError(\"k* indices are out of bounds.\")\n\n        def compute_L(X_k):\n            \"\"\"Computes the leakage ratio from DFT coefficients.\"\"\"\n            # Get squared magnitudes at the three bins of interest\n            mag_sq_km1 = np.abs(X_k[k_minus_1])**2\n            mag_sq_k = np.abs(X_k[k_star])**2\n            mag_sq_kp1 = np.abs(X_k[k_plus_1])**2\n            \n            # Calculate the leakage ratio L(w)\n            numerator = mag_sq_km1 + mag_sq_kp1\n            denominator = mag_sq_km1 + mag_sq_k + mag_sq_kp1\n            \n            # Handle potential division by zero, though unlikely in this problem\n            if denominator == 0:\n                return 0.0\n                \n            return numerator / denominator\n\n        L_rect = compute_L(X_rect)\n        L_hann = compute_L(X_hann)\n\n        return L_rect, L_hann\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: general off-bin case\n        {'fs': 1000, 'N': 256, 'f0': 123.45},\n        # Case 2: near bin-centered small detuning\n        {'fs': 1000, 'N': 512, 'f0': (40 + 0.01) * 1000 / 512},\n        # Case 3: short window edge case\n        {'fs': 1000, 'N': 64, 'f0': (12 + 0.37) * 1000 / 64},\n        # Case 4: low-frequency narrowband rhythm\n        {'fs': 250, 'N': 250, 'f0': 10.4},\n    ]\n\n    results = []\n    for case in test_cases:\n        L_rect, L_hann = calculate_leakage(case['f0'], case['fs'], case['N'])\n        results.append(round(L_rect, 6))\n        results.append(round(L_hann, 6))\n\n    # Format the final output string as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将时间-频率分析技术应用于实际的科学问题是最终目标。这个综合性练习将引导您完成一个完整的分析流程：从模拟多试次神经数据，到计算基线校正的频谱图，并最终应用强大的基于聚类的置换检验来解决多重比较问题 。通过这个实践，您将学会如何从频谱图中获得具有统计学意义的结论，例如，确定刺激是否诱发了显著的伽马频段功率增加。",
            "id": "4194056",
            "problem": "您将获得一个模拟的多试次电生理学数据集，该数据集表示为时间序列 $\\{x_i[t]\\}_{i=1}^{N}$，其中每个 $x_i[t]$ 是在时间 $t$（单位为秒）上测量的电压值，$N$ 表示试次数。采样率为 $f_s$，单位为赫兹 (Hz)。一个刺激发生在时间 $t_0$（单位为秒），部分试次在伽马波段（定义为 $30$–$80$ Hz）包含一个诱发振荡。您的任务是计算时频谱图，构建一个经试次基线校正的伽马功率差异，并执行基于簇的置换检验以检测刺激后伽马功率的增加。然后，您必须报告具有族系误差校正后 $p$ 值的显著时频簇。\n\n从短时傅里叶变换 (STFT) 的定义开始。对于以 $f_s$ Hz 采样的离散时间信号 $x[t]$ 和长度为 $L$ 的窗函数 $w[n]$，在时间帧索引 $m$ 和频率箱索引 $k$ 处的 STFT 为\n$$\nX[m,k] = \\sum_{n=0}^{L-1} x[n + mR] \\, w[n] \\, e^{-j 2 \\pi k n / L},\n$$\n其中 $R$ 是以样本为单位的跳跃长度，$j$ 是虚数单位。谱图功率为 $P[m,k] = |X[m,k]|^2$。令 $f[k]$ 表示频率箱 $k$ 对应的频率（单位为 Hz），$t[m]$ 表示时间帧 $m$ 的中心时间（单位为秒）。\n\n定义一个刺激后时间窗 $W_{\\text{post}} = [t_0 + \\Delta_1, t_0 + \\Delta_2]$ 和一个基线时间窗 $W_{\\text{base}} = [t_0 - \\Delta_2, t_0 - \\Delta_1]$，其中 $\\Delta_1$ 和 $\\Delta_2$ 以秒为单位指定。将分析限制在伽马波段，即频率 $f[k] \\in [30,80]$ Hz。对于每个试次 $i$、每个伽马频率箱 $k$ 以及每个满足 $t[m] \\in W_{\\text{post}}$ 的刺激后时间帧 $m$，计算一个经基线校正的功率差异\n$$\nD_i[k,m] = P_i[k,m] - \\frac{1}{|M_{\\text{base}}(k)|} \\sum_{m' \\in M_{\\text{base}}(k)} P_i[k,m'],\n$$\n其中 $P_i$ 是试次 $i$ 的谱图功率，$M_{\\text{base}}(k)$ 是满足 $t[m'] \\in W_{\\text{base}}$ 的基线时间帧的索引集。这将产生一个跨试次的差异时频网格 $\\{D_i[k,m]\\}$。\n\n构建单样本零假设，即刺激后伽马功率没有增加，对于每个时频箱 $(k,m)$，\n$$\nH_0: \\mu_{D}[k,m] = 0,\n$$\n其中 $\\mu_{D}[k,m]$ 是 $D_i[k,m]$ 的跨试次均值。在每个 $(k,m)$ 处，使用以下公式跨试次计算学生 t 统计量：\n$$\nt[k,m] = \\frac{\\overline{D}[k,m]}{s_D[k,m]/\\sqrt{N}},\n$$\n其中 $\\overline{D}[k,m]$ 是样本均值，$s_D[k,m]$ 是跨试次的样本标准差，$N$ 为试次数。\n\n使用学生 t 分布在水平 $\\alpha_{\\text{cf}}$ 和 $N-1$ 自由度下对应的单侧临界值作为簇形成阈值，仅保留 $t[k,m]$ 超过此阈值的频箱。使用 4-连通性（在时间或频率上相邻）将时频网格中的连续频箱定义为簇。对于每个簇 $C$，将其质量定义为 t 统计量的总和：\n$$\nS(C) = \\sum_{(k,m) \\in C} t[k,m].\n$$\n\n使用跨试次的符号翻转执行基于簇的置换检验（在配对差异的对称零假设下有效）。对于每次置换 $p = 1, \\dots, P$，为试次 $i = 1, \\dots, N$ 抽取独立的随机符号 $\\sigma_i^{(p)} \\in \\{-1, +1\\}$，形成 $\\tilde{D}_i^{(p)}[k,m] = \\sigma_i^{(p)} \\cdot D_i[k,m]$，重新计算 t-map 和簇质量，并记录最大簇质量\n$$\nM^{(p)} = \\max_{C^{(p)}} S\\left(C^{(p)}\\right),\n$$\n如果在置换 $p$ 下没有形成簇，则 $M^{(p)} = 0$。对于每个观察到的簇 $C$，使用最大统计量分布计算族系误差校正后的 $p$ 值，\n$$\np_{\\text{corr}}(C) = \\frac{1 + \\left|\\left\\{p : M^{(p)} \\ge S(C)\\right\\}\\right|}{P + 1}.\n$$\n如果对于指定的 $\\alpha$，有 $p_{\\text{corr}}(C)  \\alpha$，则宣布簇 $C$ 是显著的。\n\n将上述过程实现为一个完整的、可运行的程序，该程序模拟包含和不包含刺激诱导伽马脉冲的试次。使用以下固定的分析参数：采样率 $f_s = 500$ Hz，总时长 $T = 2.0$ 秒，刺激时间 $t_0 = 1.0$ 秒，STFT 窗长 $L = 256$ 个样本，跳跃长度 $R = 64$ 个样本，Hann 窗函数 $w[n]$。使用 $W_{\\text{base}} = [0.6, 0.9]$ 秒和 $W_{\\text{post}} = [1.1, 1.5]$ 秒。伽马脉冲（如果存在）是一个频率为 $f_{\\gamma} = 40$ Hz 的正弦波，其幅度在 $[1.15, 1.45]$ 秒内用 Hanning 包络进行锥化。\n\n您的程序应实现包含以下参数集的测试套件，每个参数集指定为一个元组 $(N, A_{\\gamma}, P, \\alpha_{\\text{cf}}, \\alpha, \\text{seed})$：\n- 测试用例 1：$(60, 2.0, 500, 0.05, 0.05, 42)$。\n- 测试用例 2：$(60, 0.0, 500, 0.05, 0.05, 43)$。\n- 测试用例 3：$(20, 0.8, 300, 0.05, 0.05, 44)$。\n\n在这里，$N$ 是试次数，$A_{\\gamma}$ 是伽马脉冲的幅度（相对于噪声的无单位值，其中 $A_{\\gamma} = 0.0$ 表示没有伽马脉冲），$P$ 是置换次数，$\\alpha_{\\text{cf}}$ 是簇形成阈值水平，$\\alpha$ 是族系误差水平，$\\text{seed}$ 是控制可复现性的随机种子。\n\n对于每个测试用例，计算伽马波段内的显著簇数量以及所有观察到的簇中最小的校正后 $p$ 值（如果没有观察到簇，则报告 $1.0$）。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果报告为一个双元素列表 $[n_{\\text{sig}}, p_{\\min}]$。例如，输出格式应类似于 $[[n_{\\text{sig}}^{(1)}, p_{\\min}^{(1)}],[n_{\\text{sig}}^{(2)}, p_{\\min}^{(2)}],[n_{\\text{sig}}^{(3)}, p_{\\min}^{(3)}]]$。输出中不需要物理单位，因为计数和 $p$ 值是无单位的。如果使用角度，则必须以弧度为单位，但本任务中没有出现角度量。",
            "solution": "用户提供了一个问题，要求实现一个用于分析模拟电生理数据的完整流程，最终通过基于簇的置换检验来识别显著的时频模式。该问题在科学上是合理的、定义明确的，并且所有必要的参数都已指定。我将着手提供一个完整的解决方案。\n\n该解决方案围绕着神经科学中常用的时频分析和非参数统计的基本原则构建。\n\n1.  **原则 1：用于方法验证的数据模拟**\n    为了测试和验证分析流程，我们首先合成了模仿真实神经数据关键特征的数据集。每个试次由一个信号加噪声组成。\n    -   **噪声**：背景神经活动被建模为高斯白噪声 $\\mathcal{N}(0,1)$。这代表了记录信号中与刺激无关的随机波动。\n    -   **信号**：刺激诱导的效应是一个伽马波段的振荡。这由一个频率为 $f_{\\gamma} = 40$ Hz 的正弦波表示。该正弦波的幅度通过一个 Hanning 窗 $A_{\\gamma} w_{\\text{Hanning}}(t)$进行调制，以创建一个在特定的刺激后时间区间 $[1.15, 1.45]$ 秒内局部化的瞬时脉冲。参数 $A_{\\gamma}$ 控制信噪比。试次 $i$ 的信号是 $x_i[t] = \\text{signal}[t] + \\text{noise}_i[t]$。\n\n2.  **原则 2：通过 STFT 进行时频分解**\n    神经信号是非平稳的，意味着其频率成分随时间变化。短时傅里叶变换 (STFT) 是分析此类信号的标准方法。它通过将信号分成短的、重叠的段，应用窗函数，并为每个段计算傅里叶变换来工作。\n    -   **谱图**：对于信号 $x[t]$，STFT $X[m,k]$ 为每个时间帧 $m$ 和频率箱 $k$ 提供一个复数值。功率谱图 $P[m,k] = |X[m,k]|^2$ 量化了信号在该特定时频坐标上的能量。\n    -   **实现**：我们使用长度为 $L=256$ 个样本的 Hann 窗和 $R=64$ 个样本的跳跃长度。这种选择平衡了时间分辨率（由 $R$ 决定）和频率分辨率（由 $L$ 决定）。\n\n3.  **原则 3：基线校正以分离刺激效应**\n    为了分离由刺激引起的功率变化，我们将刺激后时间窗内的功率与刺激前基线时间窗内的功率进行比较。\n    -   **差异度量**：对于每个试次 $i$ 和频率箱 $k$，我们计算基线时间窗 $W_{\\text{base}} = [0.6, 0.9]$ s 内的平均功率。设其为 $\\bar{P}_{i, \\text{base}}[k]$。然后，我们为刺激后时间窗 $W_{\\text{post}} = [1.1, 1.5]$ s 内的每个时间帧 $m$ 计算差异 $D_i[k,m] = P_i[k,m] - \\bar{P}_{i, \\text{base}}[k]$。这种减法校正有助于解释试次间的变异性以及与刺激无关的频率特异性功率差异。\n\n4.  **原则 4：逐点假设检验**\n    为了评估观察到的功率增加是否具有统计学意义，我们在分析窗口中的每个时频点 $(k,m)$ 处构建一个假设检验。\n    -   **零假设**：零假设 $H_0: \\mu_{D}[k,m] = 0$ 表明，从基线到刺激后期间，功率没有平均变化。\n    -   **检验统计量**：我们使用单样本学生 t 统计量来检验此假设，该统计量在 $N$ 个试次上计算得出：\n        $$\n        t[k,m] = \\frac{\\overline{D}[k,m]}{s_D[k,m]/\\sqrt{N}}\n        $$\n        其中 $\\overline{D}[k,m]$ 和 $s_D[k,m]$ 分别是 $D_i[k,m]$ 在所有试次上的样本均值和标准差。一个大的正 t 值表明功率显著增加。\n\n5.  **原则 5：用于多重比较校正的基于簇的置换检验**\n    执行数千次 t 检验（每个时频箱一次）会产生严重的多重比较问题，如果不进行校正，将导致很高的假阳性率。基于簇的置换检验是一种解决此问题的强大方法，它利用了数据的空间结构（即时间和频率上的邻接性）。\n    -   **步骤 5a：簇的形成**：我们首先识别候选簇。观察到的 t-map $\\{t[k,m]\\}$ 使用来自学生 t 分布的临界值（例如，在 $\\alpha_{\\text{cf}} = 0.05$）进行阈值处理。超过此阈值的空间上相邻的点被分组成簇。一个簇 $C$ 的“质量”定义为其中 t 值的总和，$S(C) = \\sum_{(k,m) \\in C} t[k,m]$。\n    -   **步骤 5b：通过置换生成零分布**：为了确定观察到的簇质量是否大于偶然预期的值，我们生成一个零分布。这是通过重复置换数据来完成的。在零假设下，任何给定试次的差异值 $D_i[k,m]$ 的符号是任意的。因此，我们可以通过随机翻转一个随机试次子集的所有数据的符号来创建一个代理数据集：$\\tilde{D}_i[k,m] = \\sigma_i \\cdot D_i[k,m]$，其中 $\\sigma_i \\in \\{-1, +1\\}$。\n    -   **步骤 5c：最大统计量**：对于 $P$ 次置换中的每一次，我们重新计算整个 t-map，形成簇，并找到最大簇质量 $M^{(p)} = \\max_{C^{(p)}} S(C^{(p)})$。如果没有簇形成，则 $M^{(p)}=0$。这些最大统计量的分布 $\\{M^{(p)}\\}_{p=1}^P$ 作为我们的经验零分布。使用最大统计量可以自动校正对所有可能簇的搜索。\n    -   **步骤 5d：族系误差 (FWE) 校正的 P 值**：通过将其质量 $S(C)$ 与最大质量的零分布进行比较，来评估原始观察到的簇 $C$ 的显著性。FWE 校正的 p 值为：\n        $$\n        p_{\\text{corr}}(C) = \\frac{1 + \\left|\\left\\{p : M^{(p)} \\ge S(C)\\right\\}\\right|}{P + 1}\n        $$\n    -   **推断**：如果一个观察到的簇的校正后 p 值低于期望的族系误差率 $\\alpha$，则宣布该簇具有统计显著性。\n\n从数据模拟到统计推断的这一完整过程在以下 Python 代码中实现，并遵循每个测试用例指定的参数。",
            "answer": "```python\nimport numpy as np\nfrom scipy import signal\nfrom scipy import stats\n\ndef find_clusters(grid):\n    \"\"\"\n    Finds 4-connectivity clusters in a 2D boolean grid using BFS.\n\n    Args:\n        grid (np.ndarray): A 2D boolean numpy array.\n\n    Returns:\n        list: A list of clusters, where each cluster is a list of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    clusters = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] and not visited[r, c]:\n                # Start of a new cluster\n                cluster = []\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                head = 0\n                while head  len(q):\n                    curr_r, curr_c = q[head]\n                    head += 1\n                    cluster.append((curr_r, curr_c))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        next_r, next_c = curr_r + dr, curr_c + dc\n                        \n                        if 0 = next_r  rows and 0 = next_c  cols:\n                            if grid[next_r, next_c] and not visited[next_r, next_c]:\n                                visited[next_r, next_c] = True\n                                q.append((next_r, next_c))\n                clusters.append(cluster)\n    return clusters\n\ndef run_analysis(N, A_gamma, P, alpha_cf, alpha, seed):\n    \"\"\"\n    Runs the full simulation and cluster-based permutation test for one test case.\n    \"\"\"\n    # 1. Set up RNG and constants\n    rng = np.random.default_rng(seed)\n    fs = 500\n    T = 2.0\n    t0 = 1.0\n    L = 256\n    R = 64\n    noverlap = L - R\n    \n    w_base = [0.6, 0.9]\n    w_post = [1.1, 1.5]\n    f_gamma_band = [30, 80]\n    f_gamma_burst = 40\n    t_burst_window = [1.15, 1.45]\n\n    # 2. Simulate data\n    t_vec = np.arange(0, T, 1 / fs)\n    n_samples = len(t_vec)\n    data = rng.standard_normal((N, n_samples))\n\n    if A_gamma > 0:\n        gamma_signal = np.sin(2 * np.pi * f_gamma_burst * t_vec)\n        burst_indices = (t_vec >= t_burst_window[0])  (t_vec = t_burst_window[1])\n        hanning_taper = np.zeros(n_samples)\n        hanning_taper[burst_indices] = np.hanning(np.sum(burst_indices))\n        gamma_burst = A_gamma * gamma_signal * hanning_taper\n        data += gamma_burst[np.newaxis, :]\n\n    # 3. Compute STFT and power for all trials\n    f_stft, t_stft, Zxx = signal.stft(data, fs=fs, window='hann', nperseg=L, noverlap=noverlap)\n    power_spectrograms = np.abs(Zxx)**2\n\n    # 4. Select frequency and time windows\n    gamma_freq_mask = (f_stft >= f_gamma_band[0])  (f_stft = f_gamma_band[1])\n    base_time_mask = (t_stft >= w_base[0])  (t_stft = w_base[1])\n    post_time_mask = (t_stft >= w_post[0])  (t_stft = w_post[1])\n    \n    # 5. Baseline Correction\n    power_gamma = power_spectrograms[:, gamma_freq_mask, :]\n    baseline_mean_power = np.mean(power_gamma[:, :, base_time_mask], axis=2, keepdims=True)\n    post_stim_power = power_gamma[:, :, post_time_mask]\n    \n    D = post_stim_power - baseline_mean_power\n\n    # 6. Compute observed t-statistics and find clusters\n    mean_D = np.mean(D, axis=0)\n    std_D = np.std(D, axis=0, ddof=1)\n    \n    # Handle division by zero\n    t_obs = np.zeros_like(mean_D)\n    non_zero_std = std_D > np.finfo(float).eps\n    t_obs[non_zero_std] = mean_D[non_zero_std] / (std_D[non_zero_std] / np.sqrt(N))\n    \n    t_crit = stats.t.ppf(1 - alpha_cf, df=N - 1)\n    t_map_thresh = t_obs > t_crit\n    \n    observed_clusters = find_clusters(t_map_thresh)\n    observed_masses = [np.sum(t_obs[tuple(zip(*c))]) for c in observed_clusters]\n\n    # 7. Permutation Test\n    max_perm_masses = np.zeros(P)\n    \n    for i in range(P):\n        signs = rng.choice([-1, 1], size=(N, 1, 1))\n        D_perm = D * signs\n        \n        mean_D_perm = np.mean(D_perm, axis=0)\n        std_D_perm = np.std(D_perm, axis=0, ddof=1)\n        \n        t_perm = np.zeros_like(mean_D_perm)\n        non_zero_std_perm = std_D_perm > np.finfo(float).eps\n        t_perm[non_zero_std_perm] = mean_D_perm[non_zero_std_perm] / (std_D_perm[non_zero_std_perm] / np.sqrt(N))\n        \n        t_perm_thresh = t_perm > t_crit\n        perm_clusters = find_clusters(t_perm_thresh)\n        \n        if perm_clusters:\n            perm_masses = [np.sum(t_perm[tuple(zip(*c))]) for c in perm_clusters]\n            max_perm_masses[i] = np.max(perm_masses)\n\n    # 8. Compute FWE-corrected p-values\n    if not observed_clusters:\n        return [0, 1.0]\n\n    p_values = []\n    for mass in observed_masses:\n        p_val = (1 + np.sum(max_perm_masses >= mass)) / (P + 1)\n        p_values.append(p_val)\n    \n    p_values = np.array(p_values)\n    n_sig = np.sum(p_values  alpha)\n    p_min = np.min(p_values)\n\n    return [int(n_sig), p_min]\n\ndef solve():\n    # Test cases: (N, A_gamma, P, alpha_cf, alpha, seed)\n    test_cases = [\n        (60, 2.0, 500, 0.05, 0.05, 42),\n        (60, 0.0, 500, 0.05, 0.05, 43),\n        (20, 0.8, 300, 0.05, 0.05, 44),\n    ]\n\n    results = []\n    for case in test_cases:\n        n_sig, p_min = run_analysis(*case)\n        results.append([n_sig, p_min])\n    \n    # Format the output string as per requirements\n    formatted_results = [f\"[{n},{p:.6f}]\" for n, p in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}