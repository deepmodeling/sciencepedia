{
    "hands_on_practices": [
        {
            "introduction": "Before applying a complex tool like the Hilbert transform, it is essential to understand its behavior in the simplest, ideal scenario. This foundational exercise guides you through the derivation of the analytic signal for the canonical cosine and sine waves . By working through this derivation, you will solidify your understanding of how the Hilbert transform generates the quadrature component, effectively turning a real-valued sinusoid into a complex exponential with a one-sided spectrum.",
            "id": "4199768",
            "problem": "In intracranial electrophysiology and electroencephalography (EEG), narrowband oscillations are often approximated locally as deterministic sinusoids to study instantaneous amplitude and instantaneous phase via the Hilbert transform. Consider the real-valued signal $x(t) = \\cos(\\omega_{0} t)$, where $\\omega_{0} > 0$ is a constant angular frequency expressed in radians per second and $t$ is time in seconds. The Hilbert transform $\\mathcal{H}\\{x\\}(t)$ of a real signal $x(t)$ is defined by the Cauchy principal value convolution with the kernel $h(t) = \\frac{1}{\\pi t}$, i.e., $\\mathcal{H}\\{x\\}(t) = \\bigl(x * h\\bigr)(t)$, and the associated analytic signal $z(t)$ is formed by combining $x(t)$ with its quadrature component $\\mathcal{H}\\{x\\}(t)$.\n\nUsing only fundamental transform definitions and properties of linear time-invariant systems and distributions, derive $\\mathcal{H}\\{\\cos(\\omega_{0} t)\\}(t)$ and the corresponding analytic signal $z_{\\cos}(t)$, and use the Fourier transform to verify rigorously that $z_{\\cos}(t)$ has a one-sided spectrum (i.e., no negative-frequency support). Then generalize the derivation to $x(t) = \\sin(\\omega_{0} t)$ to obtain $\\mathcal{H}\\{\\sin(\\omega_{0} t)\\}(t)$ and $z_{\\sin}(t)$, and verify the same one-sided spectrum property.\n\nFinally, provide the exact closed-form expressions for the analytic signals $z_{\\cos}(t)$ and $z_{\\sin}(t)$ in terms of $\\omega_{0}$ and $t$. Angles must be in radians. No numerical rounding is required, and no units should appear in the final expressions.",
            "solution": "The problem is valid as it is scientifically grounded in signal processing theory, well-posed with clear definitions and objectives, and free from any factual or logical inconsistencies. We will proceed with the derivation using the Fourier transform properties.\n\nThe Hilbert transform $\\mathcal{H}\\{x(t)\\}$ is defined by the convolution $x(t) * h(t)$, where the kernel is $h(t) = \\frac{1}{\\pi t}$. By the convolution theorem, this operation corresponds to multiplication in the frequency domain. We define the Fourier transform and its inverse as:\n$$\nX(\\omega) = \\mathcal{F}\\{x(t)\\} = \\int_{-\\infty}^{\\infty} x(t) e^{-i\\omega t} dt\n$$\n$$\nx(t) = \\mathcal{F}^{-1}\\{X(\\omega)\\} = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} X(\\omega) e^{i\\omega t} d\\omega\n$$\nThe Fourier transform of the kernel $h(t)$ is a standard result:\n$$\nH(\\omega) = \\mathcal{F}\\left\\{\\frac{1}{\\pi t}\\right\\}(\\omega) = -i \\cdot \\text{sgn}(\\omega)\n$$\nwhere $\\text{sgn}(\\omega)$ is the signum function. Thus, the Hilbert transform can be calculated as:\n$$\n\\mathcal{H}\\{x\\}(t) = \\mathcal{F}^{-1}\\{ -i \\cdot \\text{sgn}(\\omega) \\cdot X(\\omega) \\}\n$$\nThe analytic signal $z(t)$ is then $z(t) = x(t) + i\\mathcal{H}\\{x\\}(t)$. In the frequency domain, its transform $Z(\\omega)$ is:\n$$\nZ(\\omega) = \\mathcal{F}\\{x(t) + i\\mathcal{H}\\{x\\}(t)\\} = X(\\omega) + i(-i \\cdot \\text{sgn}(\\omega) \\cdot X(\\omega)) = X(\\omega) + \\text{sgn}(\\omega)X(\\omega)\n$$\nThis simplifies to:\n$$\nZ(\\omega) = (1 + \\text{sgn}(\\omega))X(\\omega) = \\begin{cases} 2X(\\omega), & \\omega > 0 \\\\ X(0), & \\omega = 0 \\\\ 0, & \\omega < 0 \\end{cases}\n$$\nThis relationship inherently shows that the analytic signal has a one-sided spectrum for any real signal $x(t)$ with no DC component ($X(0)=0$). We will now verify this explicitly for the given sinusoidal signals.\n\n**Part 1: Derivation for $x(t) = \\cos(\\omega_{0} t)$**\n\nFirst, we find the Fourier transform of $x(t) = \\cos(\\omega_{0} t)$. Using Euler's identity, $\\cos(\\omega_{0} t) = \\frac{1}{2}(\\exp(i\\omega_{0} t) + \\exp(-i\\omega_{0} t))$, and the known transform $\\mathcal{F}\\{\\exp(i\\omega_{c}t)\\} = 2\\pi\\delta(\\omega - \\omega_{c})$, we get:\n$$\nX_{\\cos}(\\omega) = \\mathcal{F}\\{\\cos(\\omega_{0} t)\\} = \\frac{1}{2} [2\\pi\\delta(\\omega - \\omega_{0}) + 2\\pi\\delta(\\omega + \\omega_{0})] = \\pi[\\delta(\\omega - \\omega_{0}) + \\delta(\\omega + \\omega_{0})]\n$$\nNow, we find the Fourier transform of the Hilbert-transformed signal, denoted by $Y_{\\cos}(\\omega)$:\n$$\nY_{\\cos}(\\omega) = H(\\omega)X_{\\cos}(\\omega) = -i \\cdot \\text{sgn}(\\omega) \\cdot \\pi[\\delta(\\omega - \\omega_{0}) + \\delta(\\omega + \\omega_{0})]\n$$\nUsing the sifting property of the Dirac delta distribution, $\\phi(\\omega)\\delta(\\omega - a) = \\phi(a)\\delta(\\omega - a)$, and noting that $\\omega_{0} > 0$:\n$$\nY_{\\cos}(\\omega) = -i\\pi[\\text{sgn}(\\omega_{0})\\delta(\\omega - \\omega_{0}) + \\text{sgn}(-\\omega_{0})\\delta(\\omega + \\omega_{0})]\n$$\n$$\nY_{\\cos}(\\omega) = -i\\pi[(1)\\delta(\\omega - \\omega_{0}) + (-1)\\delta(\\omega + \\omega_{0})] = -i\\pi[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})]\n$$\nTo find the Hilbert transform in the time domain, we take the inverse Fourier transform of $Y_{\\cos}(\\omega)$. Recognizing that $\\mathcal{F}\\{\\sin(\\omega_{0} t)\\} = \\frac{\\pi}{i}[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})]$, we can write:\n$$\nY_{\\cos}(\\omega) = -i\\pi[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})] = \\frac{\\pi}{i}[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})] = \\mathcal{F}\\{\\sin(\\omega_{0} t)\\}\n$$\nTherefore, the Hilbert transform of $\\cos(\\omega_{0} t)$ is:\n$$\n\\mathcal{H}\\{\\cos(\\omega_{0} t)\\}(t) = \\sin(\\omega_{0} t)\n$$\nThe corresponding analytic signal $z_{\\cos}(t)$ is:\n$$\nz_{\\cos}(t) = x(t) + i\\mathcal{H}\\{x(t)\\}(t) = \\cos(\\omega_{0} t) + i\\sin(\\omega_{0} t) = \\exp(i\\omega_{0} t)\n$$\nTo verify its one-sided spectrum, we compute its Fourier transform $Z_{\\cos}(\\omega)$:\n$$\nZ_{\\cos}(\\omega) = \\mathcal{F}\\{\\exp(i\\omega_{0} t)\\} = 2\\pi\\delta(\\omega - \\omega_{0})\n$$\nSince $\\omega_{0} > 0$, the spectrum $Z_{\\cos}(\\omega)$ is non-zero only at the positive frequency $\\omega = \\omega_{0}$. It has no support for negative frequencies, confirming it is a one-sided spectrum.\n\n**Part 2: Derivation for $x(t) = \\sin(\\omega_{0} t)$**\n\nWe follow the same procedure for $x(t) = \\sin(\\omega_{0} t)$. Using Euler's identity, $\\sin(\\omega_{0} t) = \\frac{1}{2i}(\\exp(i\\omega_{0} t) - \\exp(-i\\omega_{0} t))$, the Fourier transform is:\n$$\nX_{\\sin}(\\omega) = \\mathcal{F}\\{\\sin(\\omega_{0} t)\\} = \\frac{1}{2i} [2\\pi\\delta(\\omega - \\omega_{0}) - 2\\pi\\delta(\\omega + \\omega_{0})] = \\frac{\\pi}{i}[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})]\n$$\nThe Fourier transform of its Hilbert transform, $Y_{\\sin}(\\omega)$, is:\n$$\nY_{\\sin}(\\omega) = H(\\omega)X_{\\sin}(\\omega) = (-i \\cdot \\text{sgn}(\\omega)) \\left( \\frac{\\pi}{i}[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})] \\right)\n$$\n$$\nY_{\\sin}(\\omega) = -\\pi \\cdot \\text{sgn}(\\omega)[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})]\n$$\nApplying the sifting property and using $\\omega_{0} > 0$:\n$$\nY_{\\sin}(\\omega) = -\\pi[\\text{sgn}(\\omega_{0})\\delta(\\omega - \\omega_{0}) - \\text{sgn}(-\\omega_{0})\\delta(\\omega + \\omega_{0})]\n$$\n$$\nY_{\\sin}(\\omega) = -\\pi[(1)\\delta(\\omega - \\omega_{0}) - (-1)\\delta(\\omega + \\omega_{0})] = -\\pi[\\delta(\\omega - \\omega_{0}) + \\delta(\\omega + \\omega_{0})]\n$$\nWe recognize this as the negative of the Fourier transform of $\\cos(\\omega_{0} t)$:\n$$\nY_{\\sin}(\\omega) = -\\mathcal{F}\\{\\cos(\\omega_{0} t)\\}\n$$\nTherefore, the Hilbert transform of $\\sin(\\omega_{0} t)$ is:\n$$\n\\mathcal{H}\\{\\sin(\\omega_{0} t)\\}(t) = -\\cos(\\omega_{0} t)\n$$\nThe corresponding analytic signal $z_{\\sin}(t)$ is:\n$$\nz_{\\sin}(t) = x(t) + i\\mathcal{H}\\{x(t)\\}(t) = \\sin(\\omega_{0} t) + i(-\\cos(\\omega_{0} t)) = \\sin(\\omega_{0} t) - i\\cos(\\omega_{0} t)\n$$\nThis can be rewritten as:\n$$\nz_{\\sin}(t) = -i(\\cos(\\omega_{0} t) + i\\sin(\\omega_{0} t)) = -i\\exp(i\\omega_{0} t)\n$$\nTo verify its one-sided spectrum, we compute its Fourier transform $Z_{\\sin}(\\omega)$:\n$$\nZ_{\\sin}(\\omega) = \\mathcal{F}\\{-i\\exp(i\\omega_{0} t)\\} = -i \\mathcal{F}\\{\\exp(i\\omega_{0} t)\\} = -i \\cdot 2\\pi\\delta(\\omega - \\omega_{0})\n$$\nSince $\\omega_{0} > 0$, the spectrum $Z_{\\sin}(\\omega)$ is also non-zero only at the positive frequency $\\omega = \\omega_{0}$, confirming it is a one-sided spectrum.\n\n**Final Expressions**\n\nThe exact closed-form expressions for the analytic signals are:\nFor $x(t) = \\cos(\\omega_{0} t)$, the analytic signal is $z_{\\cos}(t) = \\exp(i\\omega_{0} t)$.\nFor $x(t) = \\sin(\\omega_{0} t)$, the analytic signal is $z_{\\sin}(t) = -i\\exp(i\\omega_{0} t)$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\exp(i \\omega_{0} t) & -i \\exp(i \\omega_{0} t)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Real-world neural oscillations are rarely pure sinusoids; their amplitudes fluctuate over time, creating modulated signals. This practice delves into the critical requirements for accurately separating this amplitude envelope from the carrier oscillation using the Hilbert transform . By systematically constructing signals that both satisfy and violate the spectral separation conditions of Bedrosian's theorem, you will directly observe and quantify the estimation bias that arises from spectral overlap, a common challenge in analyzing neural data.",
            "id": "4199775",
            "problem": "Consider a real-valued neural time series model $x(t)$ formed by amplitude modulation of a narrowband carrier, defined by $x(t) = A(t)\\cos\\left(\\phi(t)\\right)$, where the true instantaneous amplitude is $A(t)$ and the true instantaneous phase is $\\phi(t)$. The analytic signal $z(t)$ of $x(t)$ is given by $z(t) = x(t) + i\\,\\mathcal{H}\\{x\\}(t)$, where $\\mathcal{H}\\{\\cdot\\}$ denotes the Hilbert Transform (HT), defined by the principal-value convolution $\\mathcal{H}\\{x\\}(t) = \\left(x * \\frac{1}{\\pi t}\\right)(t)$. The standard Hilbert-based estimators for amplitude and phase are $\\widehat{A}(t) = |z(t)|$ and $\\widehat{\\phi}(t) = \\arg\\big(z(t)\\big)$, respectively. Bedrosian’s theorem states that if the Fourier transform supports of $A(t)$ and $\\cos\\left(\\phi(t)\\right)$ are disjoint in frequency (that is, $A(t)$ is strictly lowpass and $\\cos\\left(\\phi(t)\\right)$ is strictly highpass with non-overlapping support), then $\\mathcal{H}\\{A(t)\\cos\\left(\\phi(t)\\right)\\}(t) = A(t)\\,\\mathcal{H}\\{\\cos\\left(\\phi(t)\\right)\\}(t)$, and the Hilbert-based estimators recover $A(t)$ and $\\phi(t)$ exactly. In practice, neural signals may exhibit overlapping spectra between $A(t)$ and the carrier, violating the conditions of Bedrosian’s theorem and inducing bias in $\\widehat{A}(t)$ and $\\widehat{\\phi}(t)$.\n\nYour task is to construct counterexamples with overlapping spectra and compute bias metrics that quantify the deviation of the Hilbert-based estimators from the ground truth. Work in discrete time at sampling frequency $f_s$ (in $\\mathrm{Hz}$), over a duration $T$ (in $\\mathrm{s}$), with angle quantities in radians. Use the following model components:\n\n- True phase: $\\phi(t) = 2\\pi f_c t$, with carrier frequency $f_c$ (in $\\mathrm{Hz}$).\n- True amplitude: $A(t) = 1 + a_\\ell \\cos(2\\pi f_\\ell t) + a_h \\cos(2\\pi f_h t) + a_{h2} \\cos(2\\pi f_{h2} t)$, where $a_\\ell, a_h, a_{h2} \\in [0,1)$ are amplitude coefficients, and $f_\\ell, f_h, f_{h2}$ (in $\\mathrm{Hz}$) are modulation frequencies. Ensure that $A(t) > 0$ for all $t$ to avoid trivial envelope sign ambiguities.\n\nGiven $x(t) = A(t)\\cos(2\\pi f_c t)$, construct the analytic signal $z(t)$ and compute the Hilbert-based estimates $\\widehat{A}(t)$ and $\\widehat{\\phi}(t)$ by the definitions above. To mitigate end effects inherent to the Hilbert Transform, discard the first and last $10\\%$ of the samples when computing metrics.\n\nDefine the following bias metrics:\n- Amplitude bias $b_A = \\frac{1}{N}\\sum_{n=1}^N \\left(\\widehat{A}[n] - A[n]\\right)$, where $N$ is the number of retained samples.\n- Phase bias $b_\\phi$ as the circular mean of the phase difference $\\Delta\\phi[n] = \\mathrm{arg}\\left(e^{i(\\widehat{\\phi}[n] - \\phi[n])}\\right)$, namely\n$$\nb_\\phi = \\mathrm{atan2}\\!\\left(\\frac{1}{N}\\sum_{n=1}^N \\sin\\left(\\Delta\\phi[n]\\right),\\;\\frac{1}{N}\\sum_{n=1}^N \\cos\\left(\\Delta\\phi[n]\\right)\\right).\n$$\nThis $b_\\phi$ is a signed angle in radians indicating the central tendency of the phase error on the unit circle.\n\nImplement a program that constructs the following four test cases and computes $(b_A, b_\\phi)$ for each:\n\n- Case 1 (disjoint spectra; Bedrosian conditions satisfied): $f_s = 1000\\,\\mathrm{Hz}$, $T = 2\\,\\mathrm{s}$, $f_c = 40\\,\\mathrm{Hz}$, $a_\\ell = 0.4$, $f_\\ell = 3\\,\\mathrm{Hz}$, $a_h = 0.0$, $f_h = 0\\,\\mathrm{Hz}$, $a_{h2} = 0.0$, $f_{h2} = 0\\,\\mathrm{Hz}$.\n- Case 2 (mild overlap at the carrier): $f_s = 1000\\,\\mathrm{Hz}$, $T = 2\\,\\mathrm{s}$, $f_c = 40\\,\\mathrm{Hz}$, $a_\\ell = 0.4$, $f_\\ell = 3\\,\\mathrm{Hz}$, $a_h = 0.1$, $f_h = 40\\,\\mathrm{Hz}$, $a_{h2} = 0.0$, $f_{h2} = 0\\,\\mathrm{Hz}$.\n- Case 3 (strong overlap at the carrier): $f_s = 1000\\,\\mathrm{Hz}$, $T = 2\\,\\mathrm{s}$, $f_c = 40\\,\\mathrm{Hz}$, $a_\\ell = 0.2$, $f_\\ell = 3\\,\\mathrm{Hz}$, $a_h = 0.4$, $f_h = 40\\,\\mathrm{Hz}$, $a_{h2} = 0.0$, $f_{h2} = 0\\,\\mathrm{Hz}$.\n- Case 4 (overlap at and near the carrier): $f_s = 1000\\,\\mathrm{Hz}$, $T = 2\\,\\mathrm{s}$, $f_c = 40\\,\\mathrm{Hz}$, $a_\\ell = 0.2$, $f_\\ell = 3\\,\\mathrm{Hz}$, $a_h = 0.3$, $f_h = 40\\,\\mathrm{Hz}$, $a_{h2} = 0.2$, $f_{h2} = 41\\,\\mathrm{Hz}$.\n\nYour program should produce a single line of output containing the eight floating-point results as a comma-separated list enclosed in square brackets, ordered by test case and metric: $[b_{A,1},b_{\\phi,1},b_{A,2},b_{\\phi,2},b_{A,3},b_{\\phi,3},b_{A,4},b_{\\phi,4}]$. Angles must be in radians. No other text should be printed.",
            "solution": "The problem requires the computation of bias in Hilbert-based estimators of instantaneous amplitude and phase for a simulated neural time series. The bias arises when the conditions of Bedrosian's theorem are violated due to spectral overlap between the amplitude envelope and the carrier signal. A systematic solution involves constructing the signal, computing the analytic signal via the Hilbert transform, extracting the estimated attributes, and then calculating the specified bias metrics.\n\nThe model for the real-valued signal is $x(t) = A(t)\\cos(\\phi(t))$, where $A(t)$ is the instantaneous amplitude and $\\phi(t)$ is the instantaneous phase. The objective is to estimate $A(t)$ and $\\phi(t)$ from $x(t)$. The standard method utilizes the analytic signal, $z(t)$, which is a complex signal whose real part is $x(t)$ and whose imaginary part is the Hilbert transform of $x(t)$, denoted $\\mathcal{H}\\{x\\}(t)$.\n$$\nz(t) = x(t) + i\\,\\mathcal{H}\\{x\\}(t)\n$$\nThe Hilbert transform is defined by the convolution $\\mathcal{H}\\{x\\}(t) = (x * \\frac{1}{\\pi t})(t)$. From the analytic signal, the instantaneous amplitude and phase are estimated as:\n$$\n\\widehat{A}(t) = |z(t)| \\quad \\text{and} \\quad \\widehat{\\phi}(t) = \\arg\\left(z(t)\\right)\n$$\nBedrosian's theorem provides sufficient conditions for these estimators to be exact, i.e., $\\widehat{A}(t) = A(t)$ and $\\widehat{\\phi}(t) = \\phi(t)$. The theorem states that if the Fourier spectrum of the low-pass signal $A(t)$ is limited to frequencies below some $f_{max}$, and the spectrum of the high-pass signal $\\cos(\\phi(t))$ is contained in frequencies above $f_{min}$, with $f_{max} < f_{min}$ (i.e., their spectral supports are disjoint), then the Hilbert transform of their product separates:\n$$\n\\mathcal{H}\\{A(t)\\cos(\\phi(t))\\}(t) = A(t)\\,\\mathcal{H}\\{\\cos(\\phi(t))\\}\n$$\nFor the specific carrier $\\cos(\\phi(t)) = \\cos(2\\pi f_c t)$, its Hilbert transform is $\\mathcal{H}\\{\\cos(2\\pi f_c t)\\}(t) = \\sin(2\\pi f_c t)$. Under Bedrosian's conditions, the analytic signal becomes:\n$$\nz(t) = A(t)\\cos(2\\pi f_c t) + i\\,A(t)\\sin(2\\pi f_c t) = A(t)e^{i2\\pi f_c t}\n$$\nTaking the magnitude and angle of this ideal $z(t)$ correctly yields $\\widehat{A}(t) = A(t)$ and $\\widehat{\\phi}(t) = 2\\pi f_c t = \\phi(t)$.\n\nThe problem investigates scenarios where the spectral-disjointness condition is violated. The true amplitude is defined as $A(t) = 1 + a_\\ell \\cos(2\\pi f_\\ell t) + a_h \\cos(2\\pi f_h t) + a_{h2} \\cos(2\\pi f_{h2} t)$. The spectrum of $A(t)$ contains frequencies $f_\\ell$, $f_h$, and $f_{h2}$. The carrier frequency is $f_c$. If any of the modulation frequencies in $A(t)$ are comparable to or greater than $f_c$, their spectra will overlap, Bedrosian's theorem will not hold, and the estimators $\\widehat{A}(t)$ and $\\widehat{\\phi}(t)$ will be biased.\n\nThe algorithmic procedure to quantify this bias for the given discrete-time test cases is as follows:\n$1$. For each case, define the parameters: sampling frequency $f_s$, duration $T$, carrier frequency $f_c$, and amplitude modulation parameters $a_\\ell, f_\\ell, a_h, f_h, a_{h2}, f_{h2}$.\n$2$. Generate a discrete time vector $t[n] = n/f_s$ for $n = 0, 1, \\dots, N_{total}-1$, where $N_{total} = \\lfloor f_s T \\rfloor$.\n$3$. Construct the ground-truth signals: true amplitude $A[n]$ and true phase $\\phi[n]$ using the provided equations.\n$4$. Construct the time-series signal $x[n] = A[n]\\cos(\\phi[n])$.\n$5$. Compute the discrete analytic signal $z[n]$ of $x[n]$. This is efficiently done using the Fast Fourier Transform (FFT) method, as implemented in `scipy.signal.hilbert`. This function computes the FFT of $x[n]$, zeros out the coefficients corresponding to negative frequencies, doubles the coefficients for positive frequencies (with special care for DC and Nyquist), and then computes the inverse FFT.\n$6$. From $z[n]$, calculate the estimated amplitude $\\widehat{A}[n] = |z[n]|$ and estimated phase $\\widehat{\\phi}[n] = \\arg(z[n])$.\n$7$. To mitigate boundary artifacts from the circular convolution inherent in the FFT-based Hilbert transform, the first and last $10\\%$ of all time series ($A[n]$, $\\phi[n]$, $\\widehat{A}[n]$, and $\\widehat{\\phi}[n]$) are discarded.\n$8$. On the remaining $N$ samples, compute the bias metrics. The amplitude bias $b_A$ is the simple arithmetic mean of the error:\n$$\nb_A = \\frac{1}{N}\\sum_{n=1}^N \\left(\\widehat{A}[n] - A[n]\\right)\n$$\nThe phase bias $b_\\phi$ is a circular mean, which properly handles the wrapped nature of phase. It is the angle of the mean resultant vector of the phase errors on the unit circle:\n$$\nb_\\phi = \\mathrm{atan2}\\!\\left(\\frac{1}{N}\\sum_{n=1}^N \\sin\\left(\\Delta\\phi[n]\\right),\\;\\frac{1}{N}\\sum_{n=1}^N \\cos\\left(\\Delta\\phi[n]\\right)\\right)\n$$\nwhere the phase difference $\\Delta\\phi[n]$ is wrapped to the interval $(-\\pi, \\pi]$ by computing $\\Delta\\phi[n] = \\arg(e^{i(\\widehat{\\phi}[n] - \\phi[n])})$. This is computationally equivalent to finding the angle of the average of the complex phasors representing the phase errors: $b_\\phi = \\arg\\left(\\frac{1}{N}\\sum_{n=1}^{N} e^{i(\\widehat{\\phi}[n] - \\phi[n])}\\right)$.\n\nThe four test cases are designed to illustrate the effect of increasing spectral overlap:\n- Case $1$: The maximum frequency in $A(t)$ is $f_\\ell = 3\\,\\mathrm{Hz}$, which is much smaller than the carrier $f_c = 40\\,\\mathrm{Hz}$. The spectra are well-separated, satisfying Bedrosian's condition. We expect negligible bias.\n- Case $2$: A modulation component is introduced at $f_h = 40\\,\\mathrm{Hz}$, which is equal to the carrier frequency $f_c$. This creates direct spectral overlap, violating the theorem's conditions. We expect non-zero bias.\n- Case $3$: The overlap condition from Case $2$ is intensified by increasing the coefficient $a_h$. A larger bias is anticipated.\n- Case $4$: Additional overlap is introduced via a modulation frequency $f_{h2} = 41\\,\\mathrm{Hz}$, which is very close to the carrier frequency. This creates a complex overlap scenario involving multiple interfering spectral components.\n\nThe following program implements this entire procedure to compute the required bias metrics for all four cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import hilbert\n\ndef calculate_biases(fs, T, fc, al, fl, ah, fh, ah2, fh2):\n    \"\"\"\n    Constructs a signal and computes amplitude and phase biases.\n\n    Args:\n        fs (float): Sampling frequency in Hz.\n        T (float): Signal duration in seconds.\n        fc (float): Carrier frequency in Hz.\n        al (float): Amplitude coefficient for low-frequency modulation.\n        fl (float): Frequency for low-frequency modulation in Hz.\n        ah (float): Amplitude coefficient for high-frequency modulation.\n        fh (float): Frequency for high-frequency modulation in Hz.\n        ah2 (float): Amplitude coefficient for second high-frequency modulation.\n        fh2 (float): Frequency for second high-frequency modulation in Hz.\n\n    Returns:\n        tuple[float, float]: A tuple containing the amplitude bias (b_A) and\n                             phase bias (b_phi) in radians.\n    \"\"\"\n    # 1. Create time vector and ground-truth signal components\n    n_total = int(fs * T)\n    t = np.arange(n_total) / fs\n\n    A_t = 1.0 + al * np.cos(2 * np.pi * fl * t) + \\\n          ah * np.cos(2 * np.pi * fh * t) + \\\n          ah2 * np.cos(2 * np.pi * fh2 * t)\n\n    phi_t = 2 * np.pi * fc * t\n    x_t = A_t * np.cos(phi_t)\n\n    # 2. Compute the analytic signal and extract estimated attributes\n    z_t = hilbert(x_t)\n    A_hat = np.abs(z_t)\n    phi_hat = np.angle(z_t)  # This is the wrapped instantaneous phase\n\n    # 3. Trim data to mitigate end effects\n    trim_samples = int(0.1 * n_total)\n    retained_slice = slice(trim_samples, -trim_samples)\n\n    A_t_trimmed = A_t[retained_slice]\n    A_hat_trimmed = A_hat[retained_slice]\n    phi_t_trimmed = phi_t[retained_slice]\n    phi_hat_trimmed = phi_hat[retained_slice]\n\n    # 4. Compute bias metrics\n    # Amplitude bias: simple mean of the error\n    b_A = np.mean(A_hat_trimmed - A_t_trimmed)\n\n    # Phase bias: circular mean of the phase error\n    phase_diff = phi_hat_trimmed - phi_t_trimmed\n    # The mean of complex phasors gives the resultant vector; its angle is the circular mean.\n    b_phi = np.angle(np.mean(np.exp(1j * phase_diff)))\n\n    return b_A, b_phi\n\ndef solve():\n    \"\"\"\n    Runs the four test cases and prints the results in the specified format.\n    \"\"\"\n    # (fs, T, fc, al, fl, ah, fh, ah2, fh2)\n    test_cases = [\n        # Case 1: Disjoint spectra (Bedrosian conditions satisfied)\n        (1000, 2, 40, 0.4, 3, 0.0, 0, 0.0, 0),\n        # Case 2: Mild overlap at the carrier\n        (1000, 2, 40, 0.4, 3, 0.1, 40, 0.0, 0),\n        # Case 3: Strong overlap at the carrier\n        (1000, 2, 40, 0.2, 3, 0.4, 40, 0.0, 0),\n        # Case 4: Overlap at and near the carrier\n        (1000, 2, 40, 0.2, 3, 0.3, 40, 0.2, 41),\n    ]\n\n    results = []\n    for params in test_cases:\n        b_A, b_phi = calculate_biases(*params)\n        results.extend([b_A, b_phi])\n\n    # Format the final output string as per the problem specification.\n    # A precision of 8 decimal places is used for clear representation.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The very concept of a single, unambiguous \"instantaneous frequency\" at each moment in time rests on the assumption that the signal is \"monocomponent.\" This exercise demonstrates the breakdown of this interpretation when the signal is composed of multiple oscillatory components, a frequent occurrence in brain signals . You will construct such a signal and observe how violations of the monocomponent assumption can lead to physically counterintuitive results, such as negative instantaneous frequencies, thereby learning to identify a major pitfall in time-frequency analysis.",
            "id": "4199794",
            "problem": "You are given the task of analyzing instantaneous quantities derived from the Hilbert transform of a real-valued signal to determine conditions under which the instantaneous frequency $f(t)$ can become negative or undefined, and to demonstrate the failure of the monocomponent assumption on a constructed multi-component signal. The base definitions are restricted to the following: the Hilbert transform, the analytic signal, the instantaneous amplitude, and the instantaneous phase. You must derive all subsequent quantities from these base definitions without employing any shortcut formulas that bypass the derivation steps implied by these bases.\n\nStarting point and definitions: For a real-valued signal $x(t)$, define the Hilbert transform $\\mathcal{H}\\{x\\}(t)$ and the associated analytic signal $z(t) = x(t) + i\\,\\mathcal{H}\\{x\\}(t)$, where $i$ is the imaginary unit. Then define the instantaneous amplitude $A(t)$ and instantaneous phase $\\phi(t)$ through $A(t) = |z(t)|$ and $\\phi(t) = \\arg(z(t))$, with angles measured in radians. Finally, define the instantaneous frequency $f(t)$ from the time derivative of the unwrapped instantaneous phase, appropriately normalized to the unit Hertz (Hz). All frequencies must be expressed in Hertz.\n\nYour program must implement the following steps for each provided test case:\n1. Construct the real-valued signal $x(t)$ according to the test case specification on a uniform grid $t_n = n / f_s$ for $n = 0,1,\\dots,N-1$, with sampling rate $f_s$ in Hertz and duration $T$ in seconds, where $N = \\lfloor T \\cdot f_s \\rfloor$.\n2. Compute the analytic signal $z(t)$ of $x(t)$ using the Hilbert transform.\n3. Compute $A(t)$ and $\\phi(t)$ from $z(t)$, unwrap $\\phi(t)$ to remove $2\\pi$ discontinuities, and compute $f(t)$ in Hertz from the time derivative of the unwrapped phase.\n4. Identify time samples where $f(t)$ is negative and where $f(t)$ is undefined. A sample is considered undefined if either $A(t) \\le \\epsilon$ for a small amplitude threshold $\\epsilon$ or if the computed $f(t)$ is not a finite real number. Use $\\epsilon = 10^{-8}$ and treat any $f(t)$ with non-finite value as undefined.\n5. Quantify the fractions (as decimals) of total samples where $f(t)$ is negative and where $f(t)$ is undefined. A sample is counted as negative if $f(t) < -\\delta$ with tolerance $\\delta = 10^{-6}$; do not count samples that are undefined as negative.\n6. Assess whether the monocomponent assumption fails using a frequency-domain criterion: compute the real-valued discrete Fourier transform magnitude of $x(t)$ over nonnegative frequencies, and count the number of significant peaks above a relative threshold. Declare failure if there are more than one significant peak above the threshold. Use a peak-height threshold of $0.6$ times the maximum magnitude and ignore any peaks below $1\\,\\mathrm{Hz}$ to exclude the direct-current component.\n\nTest suite specification (all angles measured in radians; all frequencies in Hertz):\n- Case A (happy path, narrowband monocomponent): $f_s = 1000$, $T = 2.0$, and $x(t) = \\cos(2\\pi \\cdot 10\\, t)$.\n- Case B (envelope crossing zero causing undefined $f(t)$): $f_s = 1000$, $T = 2.0$, and $x(t) = \\big(1 - \\cos(2\\pi \\cdot 1\\, t)\\big)\\cos(2\\pi \\cdot 10\\, t)$.\n- Case C (explicit multi-component mixture): $f_s = 1000$, $T = 2.0$, and $x(t) = \\cos(2\\pi \\cdot 10\\, t) + 0.8\\cos(2\\pi \\cdot 30\\, t)$.\n- Case D (fast envelope violating slow-envelope condition): $f_s = 1000$, $T = 2.0$, and $x(t) = \\big(1 + 0.9\\cos(2\\pi \\cdot 15\\, t)\\big)\\cos(2\\pi \\cdot 20\\, t)$.\n\nFor each case, your program must produce a list of three values: the fraction of samples with negative $f(t)$ expressed as a decimal, the fraction of samples with undefined $f(t)$ expressed as a decimal, and a boolean indicating whether the monocomponent assumption fails (true means failure). Your program should produce a single line of output containing the results for all four cases as a comma-separated list of these case-wise lists, enclosed in square brackets, for example, $[\\,[r_{A1},r_{A2},r_{A3}],\\,[r_{B1},r_{B2},r_{B3}],\\,[r_{C1},r_{C2},r_{C3}],\\,[r_{D1},r_{D2},r_{D3}]\\,]$ where each $r_{\\cdot}$ is one of the specified outputs for the corresponding case. Angles must be in radians and frequencies must be in Hertz throughout.",
            "solution": "The objective is to analyze the instantaneous frequency of several test signals, derived via the Hilbert transform, to identify conditions under which this frequency becomes negative or undefined. We will also assess the validity of the monocomponent signal assumption using Fourier analysis. The analysis adheres strictly to the fundamental definitions provided.\n\nA real-valued signal $x(t)$ can be associated with a unique complex-valued signal called the analytic signal, $z(t)$, whose imaginary part is the Hilbert transform of $x(t)$. The Hilbert transform, denoted $\\mathcal{H}\\{x\\}(t)$, is formally defined as the convolution of $x(t)$ with the function $1/(\\pi t)$:\n$$ \\mathcal{H}\\{x\\}(t) = \\frac{1}{\\pi} \\text{p.v.} \\int_{-\\infty}^{\\infty} \\frac{x(\\tau)}{t - \\tau} d\\tau $$\nwhere p.v. signifies the Cauchy principal value of the integral. Computationally, it is more efficient to implement the Hilbert transform in the frequency domain. If $X(f)$ is the Fourier transform of $x(t)$, then the Fourier transform of $\\mathcal{H}\\{x\\}(t)$ is given by $-i \\cdot \\text{sgn}(f) \\cdot X(f)$, where $\\text{sgn}(f)$ is the signum function.\n\nThe analytic signal $z(t)$ is defined as:\n$$ z(t) = x(t) + i\\mathcal{H}\\{x\\}(t) $$\nThis complex signal provides a representation of the original real signal in terms of instantaneous amplitude and phase. The instantaneous amplitude $A(t)$ is the magnitude of $z(t)$, and the instantaneous phase $\\phi(t)$ is its argument:\n$$ A(t) = |z(t)| = \\sqrt{x(t)^2 + (\\mathcal{H}\\{x\\}(t))^2} $$\n$$ \\phi(t) = \\arg(z(t)) = \\text{atan2}(\\mathcal{H}\\{x\\}(t), x(t)) $$\nThe function $\\text{atan2}$ correctly computes the angle in all four quadrants. The raw phase $\\phi(t)$ is typically wrapped into the interval $(-\\pi, \\pi]$. To obtain a continuous phase function suitable for differentiation, we must \"unwrap\" it by adding or subtracting integer multiples of $2\\pi$ at phase jumps. Let this unwrapped phase be denoted $\\phi_{\\text{unw}}(t)$.\n\nThe instantaneous frequency, $f(t)$, expressed in Hertz, is defined as the scaled time derivative of the unwrapped instantaneous phase:\n$$ f(t) = \\frac{1}{2\\pi} \\frac{d\\phi_{\\text{unw}}(t)}{dt} $$\nThis definition provides a measure of the local rate of change of phase at each point in time.\n\nFor a discrete signal $x[n]$ sampled at a rate $f_s$, the time step is $\\Delta t = 1/f_s$. The continuous derivative is approximated using a finite difference method. For a sequence of unwrapped phase values $\\phi_{\\text{unw}}[n]$, the instantaneous frequency sequence $f[n]$ is computed as:\n$$ f[n] \\approx \\frac{1}{2\\pi} \\left( \\frac{\\phi_{\\text{unw}}[n+1] - \\phi_{\\text{unw}}[n-1]}{2\\Delta t} \\right) = \\frac{f_s}{4\\pi} (\\phi_{\\text{unw}}[n+1] - \\phi_{\\text{unw}}[n-1]) $$\nThis central difference scheme is implemented efficiently by `numpy.gradient`.\n\nThe concept of instantaneous frequency is physically meaningful only when the signal is \"monocomponent\". A monocomponent signal is one that can be unambiguously represented as $x(t) = A(t)\\cos(\\theta(t))$ with a non-negative, slowly varying envelope $A(t)$ and a monotonically increasing phase $\\theta(t)$.\n\n1.  **Undefined Frequency**: The instantaneous phase $\\phi(t)$ is mathematically undefined when $z(t) = 0$, which occurs if and only if the instantaneous amplitude $A(t) = 0$. In a practical setting with finite precision, we check for $A(t) \\le \\epsilon$ for a small threshold $\\epsilon = 10^{-8}$. This situation arises, for example, in amplitude-modulated signals where the envelope passes through zero.\n\n2.  **Negative Frequency**: Negative instantaneous frequencies can appear when the monocomponent assumption is violated. This occurs in multi-component signals (a sum of two or more sinusoids) or in signals where the bandwidth of the amplitude modulation is not well-separated from the carrier frequency. This latter case is a violation of the conditions of Bedrosian's theorem, which specifies when the Hilbert transform of a product of two functions separates cleanly. A negative value for $f(t)$ indicates a momentary reversal in the direction of phase rotation.\n\n3.  **Monocomponent Assumption Test**: A signal that is truly monocomponent should have its energy concentrated in a single band in the frequency domain. A straightforward test is to compute the signal's Fourier spectrum and count the number of significant peaks. If more than one significant peak is found (ignoring DC and very low frequencies), the signal is multi-component, and the monocomponent assumption fails. The problem specifies a peak threshold of $0.6$ times the maximum spectral magnitude.\n\nThe algorithmic procedure for each test case is as follows:\n1.  Generate the discrete signal $x[n]$ for $n = 0, \\ldots, N-1$ where $N = \\lfloor T \\cdot f_s \\rfloor$.\n2.  Compute the discrete analytic signal $z[n]$ using `scipy.signal.hilbert`.\n3.  Calculate the instantaneous amplitude $A[n] = |z[n]|$ and the unwrapped instantaneous phase $\\phi_{\\text{unw}}[n]$ using `np.abs`, `np.angle`, and `np.unwrap`.\n4.  Compute the instantaneous frequency $f[n]$ using `np.gradient` on $\\phi_{\\text{unw}}[n]$, scaled appropriately by $f_s/(2\\pi)$.\n5.  Identify samples where $f[n]$ is undefined (if $A[n] \\le \\epsilon$ or $f[n]$ is not finite) and where it is negative (if $f[n] < -\\delta$ for a tolerance $\\delta=10^{-6}$, and not undefined). The fractions of the total number of samples are then calculated.\n6.  Compute the magnitude of the real-valued discrete Fourier transform of $x[n]$. Use `scipy.signal.find_peaks` to identify spectral peaks above $0.6$ times the maximum magnitude, for frequencies greater than or equal to $1\\,\\mathrm{Hz}$. If more than one such peak exists, the monocomponent assumption is declared to have failed.\n7.  The final result for each case is a list containing the fraction of negative frequency samples, the fraction of undefined frequency samples, and a boolean indicating the failure of the monocomponent assumption.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import hilbert, find_peaks\nfrom scipy.fft import rfftfreq\n\ndef solve():\n    \"\"\"\n    Analyzes instantaneous frequency and monocomponent assumption for given signals.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path, narrowband monocomponent)\n        {\n            \"fs\": 1000, \"T\": 2.0,\n            \"signal_func\": lambda t: np.cos(2 * np.pi * 10 * t),\n            \"name\": \"Case A\"\n        },\n        # Case B (envelope crossing zero)\n        {\n            \"fs\": 1000, \"T\": 2.0,\n            \"signal_func\": lambda t: (1 - np.cos(2 * np.pi * 1 * t)) * np.cos(2 * np.pi * 10 * t),\n            \"name\": \"Case B\"\n        },\n        # Case C (explicit multi-component mixture)\n        {\n            \"fs\": 1000, \"T\": 2.0,\n            \"signal_func\": lambda t: np.cos(2 * np.pi * 10 * t) + 0.8 * np.cos(2 * np.pi * 30 * t),\n            \"name\": \"Case C\"\n        },\n        # Case D (fast envelope violating slow-envelope condition)\n        {\n            \"fs\": 1000, \"T\": 2.0,\n            \"signal_func\": lambda t: (1 + 0.9 * np.cos(2 * np.pi * 15 * t)) * np.cos(2 * np.pi * 20 * t),\n            \"name\": \"Case D\"\n        }\n    ]\n\n    results = []\n    \n    # Constants from the problem\n    epsilon = 1e-8\n    delta = 1e-6\n    peak_threshold_ratio = 0.6\n    min_peak_freq = 1.0\n\n    for case in test_cases:\n        fs = case[\"fs\"]\n        T = case[\"T\"]\n        signal_func = case[\"signal_func\"]\n\n        # 1. Construct the signal\n        N = int(T * fs)\n        t = np.arange(N) / fs\n        x = signal_func(t)\n\n        # 2. Compute the analytic signal\n        z = hilbert(x)\n\n        # 3. Compute instantaneous amplitude, phase, and frequency\n        A = np.abs(z)\n        phi = np.angle(z)\n        phi_unwrapped = np.unwrap(phi)\n        \n        # Derivative of phase: d(phi)/dt. \n        # np.gradient computes the difference, which needs to be divided by dt.\n        # dt = 1/fs, so dividing by dt is multiplying by fs.\n        # f = (1/(2*pi)) * d(phi)/dt\n        inst_freq = (np.gradient(phi_unwrapped) * fs) / (2 * np.pi)\n\n        # 4. Identify negative and undefined samples\n        is_undefined = (A <= epsilon) | (~np.isfinite(inst_freq))\n        \n        # A sample is negative only if it's not undefined\n        is_negative = (inst_freq < -delta) & (~is_undefined)\n\n        # 5. Quantify fractions\n        frac_negative = np.sum(is_negative) / N\n        frac_undefined = np.sum(is_undefined) / N\n\n        # 6. Assess monocomponent assumption failure\n        # Compute DFT\n        yf = np.abs(np.fft.rfft(x))\n        xf = rfftfreq(N, 1/fs)\n        \n        # Find peaks above the relative threshold\n        peak_height_threshold = np.max(yf) * peak_threshold_ratio\n        peaks_indices, _ = find_peaks(yf, height=peak_height_threshold)\n        \n        # Filter out peaks below the minimum frequency\n        significant_peaks_indices = peaks_indices[xf[peaks_indices] >= min_peak_freq]\n        \n        monocomp_fails = len(significant_peaks_indices) > 1\n\n        results.append([frac_negative, frac_undefined, monocomp_fails])\n\n    # Format the final output string exactly as required\n    case_strings = []\n    for res in results:\n        # Format boolean as 'true' or 'false'\n        formatted_bool = str(res[2]).lower()\n        # Format the list for one case\n        s = f\"[{res[0]},{res[1]},{formatted_bool}]\"\n        case_strings.append(s)\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}