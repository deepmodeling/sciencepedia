{
    "hands_on_practices": [
        {
            "introduction": "BOLD信号是神经活动的间接测量，由复杂的血流动力学变化驱动。其中一个关键关系是控制血流量和血容量的耦合方式。这个练习让你能够应用经验性的Grubb关系，从脑血流量（CBF）的变化来量化脑血容量（CBV）的变化。它还要求你将这些动态变化与血流动力学反应的一个显著特征——刺激后下冲——联系起来，从而加深你对信号生物物理基础的理解。",
            "id": "3998822",
            "problem": "考虑一个短暂的神经刺激，它在短时间内使脑血流量（Cerebral Blood Flow, CBF）增加一个恒定的比例。设基线CBF由$f_{0}$表示，基线脑血容量（Cerebral Blood Volume, CBV）由$v_{0}$表示。定义相对变化为$r_{f} = f/f_{0}$和$r_{v} = v/v_{0}$。假设在峰值响应期间血流动力学处于准稳态，并且经验建立的Grubb关系$v \\propto f^{\\alpha}$在局部成立，其中指数$\\alpha$表征微血管顺应性。根据质量平衡，血容量动力学遵循$dv/dt = \\text{流入} - \\text{流出}$，在峰值处的准稳态条件下，瞬时$r_{v}$可以通过Grubb关系与$r_{f}$相关联。\n\n假设刺激在峰值时产生$20\\%$的CBF增加，即$r_{f} = 1.2$，且局部Grubb指数为$\\alpha = 0.2$。仅使用上述定义和Grubb耦合关系，推导峰值时CBV分数变化$\\Delta v / v_{0} = r_{v} - 1$的闭式表达式，然后计算其数值。将最终数值答案四舍五入到四位有效数字。将分数变化表示为无量纲的小数（不要使用百分号）。\n\n最后，定性地讨论，使用脱氧血红蛋白含量和容量的定义，并且不引用任何特定的血氧水平依赖（Blood Oxygenation Level Dependent, BOLD）信号方程，这种CBV变化的幅度及其相对于CBF可能出现的延迟恢复如何导致BOLD信号中的刺激后下冲。首次使用时定义所有缩略词：血氧水平依赖（BOLD），脑血容量（CBV），脑血流量（CBF）。",
            "solution": "该问题要求基于给定的脑血流量（CBF）变化和已建立的经验关系，推导并计算脑血容量（CBV）的分数变化，然后定性讨论血氧水平依赖（BOLD）信号中的刺激后下冲。\n\n首先，我们推导峰值时CBV分数变化的闭式表达式。\n问题陈述了经验建立的Grubb关系，该关系将由$v$表示的CBV与由$f$表示的CBF耦合起来：\n$$v \\propto f^{\\alpha}$$\n这种正比关系可以写成一个带有比例常数$k$的方程：\n$$v = k f^{\\alpha}$$\n这种关系在不同的生理状态下都成立，包括基线状态和激活状态。设基线CBV为$v_{0}$，基线CBF为$f_{0}$。在基线状态下，方程为：\n$$v_{0} = k f_{0}^{\\alpha}$$\n在刺激引起的响应峰值处，CBV为$v$，CBF为$f$。方程为：\n$$v = k f^{\\alpha}$$\n为了找到相对变化之间的关系，我们可以用峰值激活时的方程除以基线时的方程：\n$$\\frac{v}{v_{0}} = \\frac{k f^{\\alpha}}{k f_{0}^{\\alpha}}$$\n常数$k$被消去，得到：\n$$\\frac{v}{v_{0}} = \\left(\\frac{f}{f_{0}}\\right)^{\\alpha}$$\n问题将相对变化定义为$r_{v} = v/v_{0}$和$r_{f} = f/f_{0}$。将这些定义代入方程，得到相对变化之间的耦合关系：\n$$r_{v} = r_{f}^{\\alpha}$$\n问题要求的是CBV的分数变化，定义为$\\frac{\\Delta v}{v_{0}}$。我们可以用$r_v$来表示它：\n$$\\frac{\\Delta v}{v_{0}} = \\frac{v - v_{0}}{v_{0}} = \\frac{v}{v_{0}} - \\frac{v_{0}}{v_{0}} = r_{v} - 1$$\n通过代入$r_{v}$的表达式，我们得到以CBF分数变化表示的CBV分数变化的最终闭式表达式：\n$$\\frac{\\Delta v}{v_{0}} = r_{f}^{\\alpha} - 1$$\n\n接下来，我们使用所提供的数据计算此分数变化的数值。\n刺激产生$20\\%$的CBF增加，这意味着峰值流量$f$是基线流量$f_0$的$120\\%$。这对应于相对变化$r_{f}$为：\n$$r_{f} = \\frac{f}{f_{0}} = \\frac{1.20 f_{0}}{f_{0}} = 1.2$$\n给定的局部Grubb指数为$\\alpha = 0.2$。\n将这些值代入我们推导的表达式中：\n$$\\frac{\\Delta v}{v_{0}} = (1.2)^{0.2} - 1$$\n我们可以计算其数值。注意，指数$0.2$等同于5次方根：\n$$(1.2)^{0.2} = (1.2)^{1/5} = \\sqrt[5]{1.2} \\approx 1.037137$$\n因此，分数变化为：\n$$\\frac{\\Delta v}{v_{0}} \\approx 1.037137 - 1 = 0.037137$$\n将此结果四舍五入到四位有效数字，得到：\n$$\\frac{\\Delta v}{v_{0}} \\approx 0.03714$$\n\n最后，我们定性讨论这种CBV变化的幅度及其相对于CBF可能出现的延迟恢复如何导致刺激后下冲。\n血氧水平依赖（BOLD）信号，用于功能性磁共振成像，通过检测血氧合的变化来间接测量神经活动。该信号对局部脱氧血红蛋白的浓度敏感，脱氧血红蛋白是顺磁性的，会引起磁场不均匀性。较低的脱氧血红蛋白浓度会导致较高的BOLD信号。\n\n在神经刺激期间，脑血流量（CBF），即血液输送的速率，会大幅增加。这种血流增加显著超过了氧气消耗的微小增加。结果是脱氧血红蛋白从毛细血管床的静脉端被“冲走”，导致其浓度降低，从而使BOLD信号增加。CBF的增加也迫使脑血容量（CBV），即给定脑区中的总血量，增加，因为血管为了容纳更高的血流而扩张。\n\n刺激后下冲是指在神经刺激停止后的一段时间内，BOLD信号降至其刺激前基线水平以下的现象。关于此效应的一个主要假设集中在CBF和CBV恢复的不同时间动态上。\n刺激停止后，CBF倾向于相对较快地恢复到其基线水平。然而，被拉伸过的静脉血管具有顺应性，并且倾向于更慢地恢复到其基线容量。这种生物力学特性导致了一个瞬时状态，其中CBF已恢复正常（或接近正常），但CBV仍然升高。\n\n在这个特定的刺激后时期：\n1.  **CBF处于基线水平**：新鲜的含氧血液供应恢复正常。\n2.  **CBV升高**：静脉室的容量仍大于其基线状态。\n\n由于代谢性氧耗继续以接近基线的速率进行，脱氧血红蛋白仍在产生。这些脱氧血红蛋白现在汇集在仍然增大的静脉容量中。成像体素内的脱氧血红蛋白总量（即其浓度与静脉血容量的乘积）变得比初始基线时更大。增加的顺磁性脱氧血红蛋白总量会产生更强的局部磁场扭曲，导致更快的信号衰减，因此，BOLD信号低于初始基线水平。这种效应会一直持续到静脉CBV完全恢复到其基线状态，此时BOLD信号也恢复到基线水平。因此，快速恢复的CBF和缓慢恢复的CBV之间恢复时间尺度的不匹配，是提出的刺激后BOLD下冲的一个关键机制。",
            "answer": "$$\n\\boxed{0.03714}\n$$"
        },
        {
            "introduction": "通用线性模型（GLM）是分析fMRI数据的主要工具，但其参数估计对实验设计结构非常敏感。当实验条件或其他回归量不独立时，会使结果的解释变得复杂。这个问题具体探讨了多重共线性问题，即GLM设计矩阵中相关的回归量会如何“放大”参数估计的方差。通过推导和计算方差膨胀因子（VIF），你将定量地理解如何诊断这一常见的统计问题，并体会到谨慎进行实验设计的重要性。",
            "id": "4198478",
            "problem": "一个单体素的血氧水平依赖 (BOLD) 时间序列通过通用线性模型 (GLM) 进行建模。设观测时间序列为 $y \\in \\mathbb{R}^{N}$，设计矩阵为 $X \\in \\mathbb{R}^{N \\times p}$，其中 $p=3$ 个回归变量对应两个任务条件和一个干扰运动参数，并假设参数向量为 $\\beta \\in \\mathbb{R}^{3}$。假设经典线性模型具有独立同分布的高斯噪声：$\\epsilon \\sim \\mathcal{N}(0, \\sigma^{2} I_{N})$，且 $y = X \\beta + \\epsilon$，参数通过普通最小二乘法 (OLS) 进行估计。$X$ 的 3 列是通过将事件序列与标准血流动力学响应函数 (HRF) 进行卷积，然后按列进行标准化，使其均值为零，方差为一而构建的。样本量为 $N=200$。将回归变量分别记为 $A$、$B$ 和 $M$（分别对应两个任务条件和运动干扰）。$X$ 各列的样本相关矩阵为\n$$\nR \\;=\\; \\begin{pmatrix}\n1  r  0 \\\\\nr  1  0 \\\\\n0  0  1\n\\end{pmatrix},\n$$\n其中 $r = 0.8$。根据在这种列标准化下样本相关矩阵的定义，有 $X^{\\top} X = N R$。\n\n从经典线性模型下普通最小二乘估计量的基本性质出发，并仅使用上面给出的信息，推导 OLS 系数估计的方差与设计相关性结构之间的关系。使用此关系将每个系数的方差膨胀因子定义为其在给定设计下的方差与一个反事实设计下方差的比率，在该反事实设计中，三列相互正交，但具有与给定设计中相同的列范数。对于给定的 $R$ 和 $N$，计算回归变量 $A$、$B$ 和 $M$ 的方差膨胀因子。\n\n使用 LaTeX 的 $\\texttt{pmatrix}$ 环境将 $(A, B, M)$ 的三个方差膨胀因子报告为一个单行矩阵。不要对答案进行四舍五入。",
            "solution": "该问题要求推导并计算应用于 BOLD 时间序列的通用线性模型 (GLM) 中参数的普通最小二乘 (OLS) 估计的方差膨胀因子 (VIF)。\n\n首先，我们确定 OLS 估计量的基本性质。模型由 $y = X \\beta + \\epsilon$ 给出，其中 $y \\in \\mathbb{R}^{N}$ 是观测数据，$X \\in \\mathbb{R}^{N \\times p}$ 是设计矩阵，$\\beta \\in \\mathbb{R}^{p}$ 是参数向量，$\\epsilon$ 是噪声向量。给定 $p=3$ 和 $N=200$。噪声被假定为高斯白噪声，$\\epsilon \\sim \\mathcal{N}(0, \\sigma^{2} I_{N})$，其中 $\\sigma^2$ 是噪声方差，$I_N$ 是 $N \\times N$ 单位矩阵。\n\n$\\beta$ 的 OLS 估计量由表达式 $\\hat{\\beta} = (X^{\\top} X)^{-1} X^{\\top} y$ 给出。此估计量的协方差矩阵 $\\text{Cov}(\\hat{\\beta})$ 推导如下：\n$$\n\\text{Cov}(\\hat{\\beta}) = \\text{Cov}((X^{\\top} X)^{-1} X^{\\top} y)\n$$\n由于 $X$ 是一个固定的回归变量矩阵，我们可以写出：\n$$\n\\text{Cov}(\\hat{\\beta}) = (X^{\\top} X)^{-1} X^{\\top} \\text{Cov}(y) ( (X^{\\top} X)^{-1} X^{\\top} )^{\\top}\n$$\n数据 $y$ 的协方差为 $\\text{Cov}(y) = \\text{Cov}(X\\beta + \\epsilon) = \\text{Cov}(\\epsilon) = \\sigma^2 I_N$。将此代入 $\\text{Cov}(\\hat{\\beta})$ 的表达式中，得到：\n$$\n\\text{Cov}(\\hat{\\beta}) = (X^{\\top} X)^{-1} X^{\\top} (\\sigma^2 I_N) X (X^{\\top} X)^{-1} = \\sigma^2 (X^{\\top} X)^{-1} (X^{\\top} X) (X^{\\top} X)^{-1}\n$$\n这简化为众所周知的结果：\n$$\n\\text{Cov}(\\hat{\\beta}) = \\sigma^2 (X^{\\top} X)^{-1}\n$$\n单个系数估计 $\\hat{\\beta}_j$ 的方差是该协方差矩阵的第 $j$ 个对角元素：\n$$\n\\text{Var}(\\hat{\\beta}_j) = [\\text{Cov}(\\hat{\\beta})]_{jj} = \\sigma^2 [(X^{\\top} X)^{-1}]_{jj}\n$$\n问题陈述，对于给定的设计矩阵 $X$，关系 $X^{\\top} X = N R$ 成立，其中 $N=200$ 是样本量，$R$ 是 $X$ 各列的样本相关矩阵。将此代入方差表达式中，我们发现估计的方差与设计相关性结构之间的关系：\n$$\n\\text{Var}(\\hat{\\beta}_j) = \\sigma^2 [(N R)^{-1}]_{jj} = \\frac{\\sigma^2}{N} [R^{-1}]_{jj}\n$$\n方差膨胀因子 (VIF) 定义为在给定设计下系数估计的方差与一个反事实设计下方差的比率，在该反事实设计中，回归变量相互正交但具有相同的列范数。\n\n首先，让我们确定反事实正交设计（记为 $X_{ortho}$）中的方差。问题陈述 $X_{ortho}$ 的列与 $X$ 的列具有相同的范数。$X^{\\top}X = NR$ 的对角元素为 $(X^{\\top}X)_{jj} = X_j^{\\top}X_j = \\|X_j\\|^2$。由于 $R_{jj}=1$，对于每一列 $j$，我们有 $\\|X_j\\|^2 = N \\cdot 1 = N$。因此，反事实设计 $X_{ortho}$ 具有正交列，且 $\\|X_{ortho,j}\\|^2 = N$。此正交设计的格拉姆矩阵是一个对角矩阵：\n$$\nX_{ortho}^{\\top} X_{ortho} = \\begin{pmatrix} N  0  0 \\\\ 0  N  0 \\\\ 0  0  N \\end{pmatrix} = N I_3\n$$\n在这种情况下，估计 $\\hat{\\beta}_{j, ortho}$ 的方差为：\n$$\n\\text{Var}(\\hat{\\beta}_{j, ortho}) = \\sigma^2 [(N I_3)^{-1}]_{jj} = \\sigma^2 \\left[\\frac{1}{N} I_3\\right]_{jj} = \\frac{\\sigma^2}{N}\n$$\n现在，我们可以按定义计算第 $j$ 个系数的 VIF：\n$$\n\\text{VIF}_j = \\frac{\\text{Var}(\\hat{\\beta}_j)}{\\text{Var}(\\hat{\\beta}_{j, ortho})} = \\frac{\\frac{\\sigma^2}{N} [R^{-1}]_{jj}}{\\frac{\\sigma^2}{N}} = [R^{-1}]_{jj}\n$$\n因此，每个系数的 VIF 就是相关矩阵 $R$ 的逆矩阵的相应对角元素。\n\n给定的相关矩阵为：\n$$\nR = \\begin{pmatrix}\n1  r  0 \\\\\nr  1  0 \\\\\n0  0  1\n\\end{pmatrix} \\quad\\text{with}\\quad r = 0.8\n$$\n这是一个块对角矩阵。它的逆矩阵是其块的逆矩阵组成的块对角矩阵。设左上角的 $2 \\times 2$ 块为 $R_{12} = \\begin{pmatrix} 1  r \\\\ r  1 \\end{pmatrix}$。\n该块的行列式为 $\\det(R_{12}) = 1 \\cdot 1 - r \\cdot r = 1 - r^2$。\n其逆矩阵为 $R_{12}^{-1} = \\frac{1}{1-r^2} \\begin{pmatrix} 1  -r \\\\ -r  1 \\end{pmatrix}$。\n右下角的块只是标量 $1$，其逆为 $1$。\n因此，完整相关矩阵的逆矩阵为：\n$$\nR^{-1} = \\begin{pmatrix}\n\\frac{1}{1-r^2}  \\frac{-r}{1-r^2}  0 \\\\\n\\frac{-r}{1-r^2}  \\frac{1}{1-r^2}  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n三个回归变量 (A, B, M) 的 VIF 是该矩阵的对角元素：\n$\\text{VIF}_A = [R^{-1}]_{11} = \\frac{1}{1-r^2}$\n$\\text{VIF}_B = [R^{-1}]_{22} = \\frac{1}{1-r^2}$\n$\\text{VIF}_M = [R^{-1}]_{33} = 1$\n\n我们代入给定的值 $r=0.8$：\n$r^2 = (0.8)^2 = 0.64$\n$1 - r^2 = 1 - 0.64 = 0.36$\n回归变量 $A$ 和 $B$ 的 VIF 为：\n$\\text{VIF}_A = \\text{VIF}_B = \\frac{1}{0.36} = \\frac{1}{36/100} = \\frac{100}{36} = \\frac{25}{9}$\n回归变量 $M$ 的 VIF 为：\n$\\text{VIF}_M = 1$\n这个结果是符合预期的，因为回归变量 $M$ 与回归变量 $A$ 和 $B$ 不相关，所以其方差不会因为后两者的存在而膨胀。而 $A$ 和 $B$ 之间的高相关性导致了它们各自系数估计的方差显著膨胀。\n\n$(A, B, M)$ 的三个方差膨胀因子是 $(\\frac{25}{9}, \\frac{25}{9}, 1)$。我们将其报告为单行矩阵。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{25}{9}  \\frac{25}{9}  1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在实践中，真实的血流动力学反应在不同脑区和个体之间可能存在差异，常常偏离标准分析中使用的“标准”HRF。这种模型不匹配会导致神经活动估计的偏差。这个编程练习提供了一个动手模拟的机会，来研究HRF模型不匹配的后果。你将通过实现一个GLM分析，量化由时间延迟引起的估计偏差，并展示如何通过增加时间导数基函数——一种源自泰勒级数近似的技术——来显著提高估计的准确性。",
            "id": "3998785",
            "problem": "考虑功能性磁共振成像（fMRI）血氧水平依赖（BOLD）信号的卷积模型，将其视为一个线性时不变系统：观测到的信号是刺激时间序列与血流动力学响应函数（HRF）进行卷积的结果。设刺激为一个以固定时间分辨率采样的离散时间序列。BOLD信号遵循卷积的线性叠加和时移特性。通用线性模型（GLM）为线性回归参数提供了一个普通最小二乘估计量。\n\n您的任务是，当将一个不匹配的经典HRF拟合由一个延迟的HRF生成的数据时，量化所引入的偏差，并衡量当使用时间导数基增强GLM时所带来的改善。使用基于卷积模型和线性回归的原理推导，来定义和计算幅度偏差及其减少量。\n\n使用以下基础：\n\n- 观测到的BOLD信号被建模为卷积：对于一个刺激序列 $s[n]$ 和一个HRF $h[n]$，无噪声响应为 $y[n] = \\sum_{k=0}^{\\infty} s[k] h[n-k] \\Delta t$，其中 $\\Delta t$ 是采样间隔（单位：秒）。\n- GLM假设 $y = X \\beta + \\varepsilon$，并使用普通最小二- 乘法来估计 $\\hat{\\beta} = (X^{\\top} X)^{-1} X^{\\top} y$，其中 $X$ 是设计矩阵，$\\varepsilon$ 是残差（在此，设 $\\varepsilon = 0$ 以隔离模型不匹配带来的偏差）。\n- 经典血流动力学响应函数（HRF）$h_{0}(t)$ 定义为伽马密度函数的差，这在神经影像学中被广泛使用。在离散时间内，以 $\\Delta t$ 的间隔在有限支撑上对其进行采样。\n\n请精确实现以下内容：\n\n1.  设采样间隔为 $\\Delta t = 0.5$ 秒。设总模拟时长为 $T = 120$ 秒。构建离散时间网格 $t = 0, \\Delta t, 2\\Delta t, \\ldots, T - \\Delta t$。\n\n2.  定义 $t \\ge 0$ 时的经典HRF $h_{0}(t)$ 为\n    $$h_{0}(t) = g(t; a_{1}, b_{1}) - c \\, g(t; a_{2}, b_{2}),$$\n    其中 $g(t; a, b)$ 是伽马密度函数\n    $$g(t; a, b) = \\frac{t^{a-1} e^{-t/b}}{b^{a} \\Gamma(a)}, \\quad t \\ge 0,$$\n    并使用参数 $a_{1} = 6$，$b_{1} = 1$，$a_{2} = 16$，$b_{2} = 1$ 以及 $c = 1/6$。在 $t = 0, \\Delta t, \\ldots, t_{\\max}$ 上对 $h_{0}(t)$ 进行采样，其中 $t_{\\max} = 32$ 秒，并对 $t < 0$ 设 $h_{0}(t) = 0$。\n\n3.  构建一个刺激序列 $s[n]$，包含五个1秒的盒状事件，分别在时间点 $10$ 秒、$30$ 秒、$50$ 秒、$70$ 秒和 $90$ 秒。即，如果一个事件在时间 $t_{e}$ 开始，那么对于索引 $n$ 使得 $t[n] \\in [t_{e}, t_{e} + 1)$，设置 $s[n] = 1$，否则 $s[n] = 0$。\n\n4.  将延迟的HRF定义为 $h_{d}(t) = h_{0}(t - d)$，其中对于 $t - d < 0$ 有 $h_{d}(t) = 0$，$d$ 是一个以秒为单位的恒定延迟，可以是正值（延迟响应）或负值（提前响应）。通过 $d/\\Delta t$ 的整数样本位移，实现采样后HRF的离散时间平移。\n\n5.  通过离散卷积生成无噪声的观测数据 $y[n]$：\n    $$y[n] = \\Delta t \\sum_{k=0}^{N-1} s[k] h_{d}[n-k],$$\n    并截断至刺激的长度 $N$。\n\n6.  构建仅含经典HRF的GLM设计矩阵 $X_{1} = [r_{c}, \\mathbf{1}]$，其中 $\\mathbf{1}$ 是全为1的列向量，而\n    $$r_{c}[n] = \\Delta t \\sum_{k=0}^{N-1} s[k] h_{0}[n-k],$$\n    是经典回归量。计算普通最小二乘估计 $\\hat{\\beta}_{1}$，并将幅度估计 $\\hat{A}_{1}$ 定义为经典回归量的系数，即 $\\hat{\\beta}_{1}$ 的第一个分量。设真实幅度为 $A_{\\text{true}} = 1$。将偏差定义为 $b_{1} = \\hat{A}_{1} - A_{\\text{true}}$。\n\n7.  构建导数增强的GLM设计矩阵 $X_{2} = [r_{c}, r_{d}, \\mathbf{1}]$，其中 $r_{d}[n]$ 是通过将刺激与经典HRF的时间导数进行卷积得到的回归量：\n    $$r_{d}[n] = \\Delta t \\sum_{k=0}^{N-1} s[k] \\left(\\frac{d}{dt} h_{0}\\right)[n-k],$$\n    其中导数通过有限差分在采样后的 $h_{0}(t)$ 上进行数值计算。计算 $\\hat{\\beta}_{2}$ 并将 $\\hat{A}_{2}$ 定义为 $\\hat{\\beta}_{2}$ 的第一个分量，其偏差为 $b_{2} = \\hat{A}_{2} - A_{\\text{true}}$。\n\n8.  将由导数基带来的改善量化为绝对偏差的减少量：\n    $$R = |b_{1}| - |b_{2}|.$$\n    一个正的 $R$ 值表示幅度偏差减小。\n\n测试套件：\n\n为以下延迟 $d$（单位：秒）评估改善量 $R$：\n\n-   案例1：$d = 0.0$（无延迟，边界情况）。\n-   案例2：$d = 0.5$（小的正延迟）。\n-   案例3：$d = 2.0$（中等正延迟）。\n-   案例4：$d = 4.0$（大的正延迟）。\n-   案例5：$d = -0.5$（小的负延迟）。\n\n要求输出：\n\n您的程序应生成单行输出，包含一个方括号括起来的逗号分隔列表（例如，$[r_{1}, r_{2}, r_{3}, r_{4}, r_{5}]$），其中每个 $r_{i}$ 是对应测试案例计算出的改善量 $R$。所有数字都表示为十进制浮点数。整个过程时间单位为秒；幅度无量纲，偏差也无量纲。",
            "solution": "该问题要求对功能性磁共振成像（fMRI）信号模型中，当真实与建模的血流动力学响应函数（HRF）存在不匹配时，对幅度估计中的偏差进行定量分析，并评估通过时间导数基函数增强通用线性模型（GLM）以校正此偏差的有效性。整个过程基于线性时不变（LTI）系统和普通最小二乘（OLS）估计的理论。\n\n首先，我们按规定建立数学和计算框架。\n\n**1. 时间离散化与刺激定义**\n模拟在总时长 $T = 120$ 秒内进行，采样间隔为 $\\Delta t = 0.5$ 秒。这定义了一个离散时间网格 $t_n = n \\Delta t$，其中 $n = 0, 1, \\ldots, N-1$，$N = T/\\Delta t = 240$。\n刺激 $s[n]$ 是一个表示神经事件的二元序列。它由五个1秒的盒状函数组成，分别在时间 $t_e \\in \\{10, 30, 50, 70, 90\\}$ 秒开始。对于每个在 $t_e$ 开始的事件，所有满足 $t_e \\le t_n < t_e + 1$ 的时间点 $t_n$ 对应的离散刺激样本 $s[n]$ 被设为1，其他则为0。\n\n**2. 血流动力学响应函数（HRF）定义**\n经典HRF，记为 $h_0(t)$，模拟了BOLD信号对一个短暂的、脉冲状神经事件的响应。它被定义为两个伽马概率密度函数的差：\n$$h_{0}(t) = g(t; a_{1}, b_{1}) - c \\, g(t; a_{2}, b_{2})$$\n其中伽马密度函数 $g(t; a, b)$ 由下式给出：\n$$g(t; a, b) = \\frac{t^{a-1} e^{-t/b}}{b^{a} \\Gamma(a)}, \\quad t \\ge 0$$\n参数指定为 $a_{1} = 6$，$b_{1} = 1$，$a_{2} = 16$，$b_{2} = 1$，$c = 1/6$。我们在时间分辨率 $\\Delta t$ 下，对一个有限支撑 $t_{max} = 32$ 秒上的 $h_0(t)$ 进行采样，得到离散滤波器核 $h_0[n]$。\n\n数据所基于的真实HRF是经典HRF的时移版本，$h_d(t) = h_0(t-d)$，其中 $d$ 是以秒为单位的延迟。正值 $d$ 对应延迟响应，负值 $d$ 对应提前响应。在离散域中，这是通过将采样后的核 $h_0[n]$ 平移 $d/\\Delta t$ 个样本来实现的。对于 $k = d/\\Delta t$ 个样本的平移，如果 $k>0$，我们在 $h_0[n]$ 前面加上 $k$ 个零并截断末尾；如果 $k<0$，我们移除前 $|k|$ 个样本并在末尾追加 $|k|$ 个零。这样便产生了离散的延迟核 $h_d[n]$。\n\n**3. 通过卷积生成数据**\n在LTI系统假设下，无噪声的BOLD信号 $y[n]$ 是刺激 $s[n]$ 与真实（延迟的）HRF核 $h_d[n]$ 的离散卷积，并按采样间隔 $\\Delta t$ 进行缩放：\n$$y[n] = \\Delta t \\sum_{k=0}^{N-1} s[k] h_{d}[n-k]$$\n此操作模拟了对刺激序列各组成部分响应的线性叠加。\n\n**4. GLM估计与偏差计算**\n通用线性模型（GLM）框架用于估计响应的幅度。模型为 $y = X \\beta + \\varepsilon$。我们考虑一个无噪声情景（$\\varepsilon=0$）来隔离由模型不匹配引起的偏差。参数 $\\beta$ 的OLS估计为 $\\hat{\\beta} = (X^{\\top} X)^{-1} X^{\\top} y$。\n\n**模型1：仅含经典HRF的GLM**\n第一个模型尝试仅使用经典HRF来解释数据 $y$。设计矩阵 $X_1$ 由两个回归量构成：\n1.  经典回归量 $r_c[n]$，由刺激 $s[n]$ 与经典HRF $h_0[n]$ 卷积形成：$r_c[n] = \\Delta t \\sum_k s[k] h_0[n-k]$。\n2.  一个截距项，即一个全为1的列，用于模拟基线信号水平。\n因此，$X_1 = [r_c, \\mathbf{1}]$。我们求解系统 $y = X_1 \\beta_1$ 得到 $\\hat{\\beta}_1 = [\\hat{A}_1, \\text{intercept}]^{\\top}$。根据构造，响应的真实幅度为 $A_{\\text{true}} = 1$。这第一个估计量的偏差是 $b_1 = \\hat{A}_1 - A_{\\text{true}}$。当 $d \\neq 0$ 时，$y$ 与 $r_c$ 不匹配，导致非零偏差 $b_1$。\n\n**模型2：导数增强的GLM**\n第二个模型基于延迟HRF的一阶泰勒级数近似：\n$$h_d(t) = h_0(t-d) \\approx h_0(t) - d \\cdot \\frac{d}{dt}h_0(t)$$\n与刺激 $s(t)$ 卷积表明，得到的信号 $y(t)$ 可以近似为 $r_c(t) = s(t) * h_0(t)$ 和 $s(t) * \\frac{d}{dt}h_0(t)$ 的线性组合。这启发我们在GLM中加入一个基于HRF时间导数的回归量。\n\n经典HRF的导数 $\\frac{d}{dt}h_0(t)$，通过在采样核 $h_0[n]$ 上使用有限差分法进行数值计算。该导数核与刺激进行卷积，创建导数回归量：$r_d[n] = \\Delta t \\sum_k s[k] (\\frac{d}{dt}h_0)[n-k]$。\n\n增强后的设计矩阵是 $X_2 = [r_c, r_d, \\mathbf{1}]$。我们求解 $y = X_2 \\beta_2$ 得到 $\\hat{\\beta}_2 = [\\hat{A}_2, \\hat{\\beta}_{d}, \\text{intercept}]^{\\top}$。幅度估计 $\\hat{A}_2$ 是经典回归量的系数。其偏差为 $b_2 = \\hat{A}_2 - A_{\\text{true}}$。通过考虑时间平移，该模型预计能提供更准确的幅度估计，从而使得偏差 $|b_2|$ 相较于 $|b_1|$ 更小。\n\n**5. 量化改善**\n包含时间导数基所带来的改善被量化为绝对偏差的减少量：\n$$R = |b_1| - |b_2|$$\n一个正的 $R$ 值表示增强模型提供了偏差更小的响应幅度估计。我们为测试套件中每个指定的延迟 $d$ 计算 $R$。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma\n\ndef solve():\n    \"\"\"\n    Computes the reduction in amplitude estimation bias for an fMRI GLM\n    by augmenting the model with a temporal derivative basis function.\n    \"\"\"\n\n    def g_pdf(t, a, b):\n        \"\"\"Gamma probability density function.\"\"\"\n        # Handle t=0 case where t**(a-1) is 0 for a > 1\n        t_safe = np.maximum(t, 1e-12)\n        val = (t_safe**(a - 1) * np.exp(-t_safe / b)) / (b**a * gamma(a))\n        val[t == 0] = 0.0\n        return val\n\n    def calculate_improvement(d):\n        \"\"\"\n        Calculates the bias improvement R for a given delay d.\n        \"\"\"\n        # 1. Setup time grid and constants\n        dt = 0.5  # Sampling interval in seconds\n        T = 120.0  # Total duration in seconds\n        t_max_hrf = 32.0  # HRF support duration\n        time_vec = np.arange(0, T, dt)\n        N = len(time_vec)\n        A_true = 1.0\n\n        # 2. Define canonical HRF h0(t)\n        hrf_time_vec = np.arange(0, t_max_hrf + dt, dt)\n        a1, b1 = 6.0, 1.0\n        a2, b2 = 16.0, 1.0\n        c = 1.0 / 6.0\n        h0_sampled = g_pdf(hrf_time_vec, a1, b1) - c * g_pdf(hrf_time_vec, a2, b2)\n\n        # 3. Construct stimulus train s[n]\n        s = np.zeros(N)\n        event_times = [10.0, 30.0, 50.0, 70.0, 90.0]\n        event_duration = 1.0\n        for t_e in event_times:\n            event_indices = (time_vec >= t_e)  (time_vec  t_e + event_duration)\n            s[event_indices] = 1.0\n\n        # 4. Define the delayed HRF h_d(t)\n        shift_samples = int(round(d / dt))\n        h_d_sampled = np.zeros_like(h0_sampled)\n        if shift_samples == 0:\n            h_d_sampled = h0_sampled.copy()\n        elif shift_samples > 0:\n            h_d_sampled[shift_samples:] = h0_sampled[:-shift_samples]\n        else: # shift_samples  0\n            h_d_sampled[:shift_samples] = h0_sampled[-shift_samples:]\n\n        # 5. Generate noise-free observed data y[n]\n        y = dt * np.convolve(s, h_d_sampled, mode='full')[:N]\n\n        # 6. Canonical-only GLM (GLM 1)\n        r_c = dt * np.convolve(s, h0_sampled, mode='full')[:N]\n        intercept = np.ones(N)\n        X1 = np.vstack([r_c, intercept]).T\n        \n        beta1, _, _, _ = np.linalg.lstsq(X1, y, rcond=None)\n        A1_hat = beta1[0]\n        b1 = A1_hat - A_true\n\n        # 7. Derivative-augmented GLM (GLM 2)\n        h0_deriv = np.gradient(h0_sampled, dt)\n        r_d = dt * np.convolve(s, h0_deriv, mode='full')[:N]\n        X2 = np.vstack([r_c, r_d, intercept]).T\n        \n        beta2, _, _, _ = np.linalg.lstsq(X2, y, rcond=None)\n        A2_hat = beta2[0]\n        b2 = A2_hat - A_true\n\n        # 8. Quantify improvement R\n        R = abs(b1) - abs(b2)\n        return R\n\n    # Test Suite: Delays d in seconds\n    test_cases = [\n        0.0,   # Case 1: no delay\n        0.5,   # Case 2: small positive delay\n        2.0,   # Case 3: moderate positive delay\n        4.0,   # Case 4: large positive delay\n        -0.5   # Case 5: small negative delay\n    ]\n\n    results = []\n    for d_val in test_cases:\n        improvement = calculate_improvement(d_val)\n        results.append(improvement)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```",
            "answer": "[0.0,0.08985652152865766,0.4901985394541703,0.6756855146522306,0.0933753232675988]"
        }
    ]
}