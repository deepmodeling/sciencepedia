{
    "hands_on_practices": [
        {
            "introduction": "Our theoretical models of the brain often exist in continuous time, but our fMRI data is collected at discrete intervals. This practice bridges that gap by walking through the conversion of the continuous-time convolution model of the BOLD signal to its discrete-time form, which is essential for implementation in any analysis software. This exercise also confronts a critical pitfall of this discretization process: the phenomenon of aliasing, where high-frequency signals masquerade as lower frequencies after sampling, potentially corrupting our data. ",
            "id": "4178405",
            "problem": "A common approach for modeling the Blood Oxygen Level Dependent (BOLD) signal in functional magnetic resonance imaging is to treat the neurovascular pathway as a Linear Time-Invariant (LTI) system whose output is the convolution between the stimulus time course and the Hemodynamic Response Function (HRF). Let the continuous-time stimulus be $x(t)$ and the continuous-time HRF be $h(t)$, with the BOLD output $y(t)$ modeled as a causal convolution. The scanner measurement is obtained by uniform sampling at Repetition Time (TR) $\\Delta$ seconds, producing a discrete-time sequence $y[n] = y(n\\Delta)$.\n\nStarting from a causal continuous-time convolution model and the definition of uniform sampling at TR $\\Delta$, derive the discrete-time convolution form $y[n] = \\sum_{k=0}^{K-1} h[k]\\,x[n-k]$ by passing through an appropriate Riemann-sum approximation of the continuous-time convolution. Explicitly state the discretization step and the relationship between the discrete-time sequence $\\{h[k]\\}$ and the continuous-time function $h(t)$, and express $K$ in terms of the effective support length of $h(t)$ and $\\Delta$.\n\nConsider aliasing when the HRF $h(t)$ has non-negligible energy at frequencies above the Nyquist limit imposed by sampling at TR $\\Delta$. As a concrete scenario, suppose $h(t)$ contains a small-amplitude damped oscillatory component\n$$\nh_{\\text{fast}}(t) = \\alpha\\,\\exp(-\\beta t)\\,\\cos(2\\pi f_{0} t)\\,u(t),\n$$\nwhere $u(t)$ is the unit step function, $\\alpha$ and $\\beta$ are positive constants, and $f_{0} = 0.9$ Hertz. The HRF is sampled at TR $\\Delta = 1.5$ seconds, and assume idealized sampling with no anti-aliasing prefiltering.\n\nUnder these conditions, determine the aliased frequency $f_{\\text{alias}}$ that will appear in the sampled sequence due solely to the component at frequency $f_{0}$ after sampling. Express your final answer in Hertz (Hz) and round your result to four significant figures. The final answer must be a single real number.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of linear systems theory and digital signal processing as applied to fMRI data analysis. The problem is well-posed, providing all necessary parameters for the calculation, and is stated in objective, formal language. There are no contradictions, ambiguities, or factual inaccuracies.\n\nThe problem consists of two parts. The first is a derivation of the discrete-time convolution model from its continuous-time counterpart. The second is a specific calculation of an aliased frequency.\n\nFirst, we derive the discrete-time convolution model. The BOLD signal $y(t)$ is modeled as the causal convolution of the stimulus $x(t)$ and the hemodynamic response function (HRF) $h(t)$. For a causal Linear Time-Invariant (LTI) system, this is expressed as:\n$$\ny(t) = (h * x)(t) = \\int_{0}^{\\infty} h(\\tau) x(t - \\tau) d\\tau\n$$\nThe lower limit of integration is $0$ because the HRF is causal, i.e., $h(\\tau) = 0$ for $\\tau  0$.\n\nThe continuous-time signal $y(t)$ is sampled uniformly at intervals of the Repetition Time (TR), denoted by $\\Delta$. This produces the discrete-time sequence $y[n] = y(n\\Delta)$. Substituting $t = n\\Delta$ into the convolution integral gives:\n$$\ny[n] = y(n\\Delta) = \\int_{0}^{\\infty} h(\\tau) x(n\\Delta - \\tau) d\\tau\n$$\nTo obtain a discrete-time convolution sum, we approximate this integral using a Riemann sum. We discretize the integration variable $\\tau$ with a step size equal to the sampling interval $\\Delta$, so that $\\tau = k\\Delta$ for integer $k \\ge 0$. The differential $d\\tau$ is replaced by the finite step $\\Delta$. The integral is thus approximated by a sum:\n$$\ny[n] \\approx \\sum_{k=0}^{\\infty} h(k\\Delta) x(n\\Delta - k\\Delta) \\Delta\n$$\nWe can rearrange the terms and define the discrete-time sequences. The stimulus is sampled as $x[m] = x(m\\Delta)$. Substituting this into the sum gives:\n$$\ny[n] \\approx \\sum_{k=0}^{\\infty} \\left[ \\Delta \\cdot h(k\\Delta) \\right] x[n-k]\n$$\nThis expression has the form of a discrete-time convolution, $y[n] = \\sum_{k} h_{d}[k] x[n-k]$. By comparison, we establish the relationship between the discrete-time HRF filter coefficients $h[k]$ and the continuous-time HRF $h(t)$:\n$$\nh[k] = \\Delta \\cdot h(k\\Delta)\n$$\nThe factor of $\\Delta$ is a scaling term that arises from the Riemann sum approximation of the convolution integral.\n\nThe HRF $h(t)$ is effectively time-limited. Let its effective support length be $T_h$, meaning $h(t) \\approx 0$ for $t  T_h$. Consequently, the terms in the sum are negligible for $k\\Delta  T_h$, or $k  T_h/\\Delta$. The sum can be truncated at the largest integer $k$ for which $k \\le T_h/\\Delta$, which is $k_{max} = \\lfloor T_h/\\Delta \\rfloor$. The sum is over $k$ from $0$ to $k_{max}$. The problem uses $K$ for the number of elements in the discrete HRF sequence $\\{h[k]\\}$, so the index runs from $k=0$ to $K-1$. Therefore, $K-1 = \\lfloor T_h/\\Delta \\rfloor$, which implies $K = \\lfloor T_h/\\Delta \\rfloor + 1$. This completes the derivation.\n\nNext, we address the aliasing calculation. Sampling a continuous-time signal at a rate of $f_s$ causes frequencies in the original signal to be aliased. The sampling interval is given as $\\Delta = 1.5$ seconds. The sampling frequency $f_s$ is the reciprocal of the sampling interval:\n$$\nf_s = \\frac{1}{\\Delta} = \\frac{1}{1.5} = \\frac{2}{3} \\text{ Hz}\n$$\nThe Nyquist frequency, $f_N$, is half the sampling frequency. It represents the maximum frequency that can be unambiguously represented after sampling.\n$$\nf_N = \\frac{f_s}{2} = \\frac{1}{2\\Delta} = \\frac{1}{2 \\times 1.5} = \\frac{1}{3} \\text{ Hz}\n$$\nThe HRF component $h_{\\text{fast}}(t)$ contains a cosine term $\\cos(2\\pi f_0 t)$ with a frequency $f_0 = 0.9$ Hz. Since $f_0  f_N$ ($0.9 \\text{ Hz}  1/3 \\approx 0.3333 \\text{ Hz}$), this frequency component will be aliased.\n\nWhen a signal is sampled, any frequency $f$ in the original signal becomes indistinguishable from frequencies $f \\pm k f_s$ for any integer $k$. The aliased frequency, $f_{\\text{alias}}$, is the frequency in the principal alias range $[0, f_N]$ that is produced by this phenomenon. It can be calculated as:\n$$\nf_{\\text{alias}} = |f_0 - k \\cdot f_s|\n$$\nwhere the integer $k$ is chosen such that the resulting $f_{\\text{alias}}$ falls within the range $[0, f_N]$. We need to find an integer $k$ such that $|0.9 - k \\cdot (2/3)| \\le 1/3$.\n\nLet's test integer values of $k$:\nFor $k=0$, the frequency is $|0.9 - 0| = 0.9$ Hz, which is greater than $f_N$.\nFor $k=1$, the frequency is:\n$$\nf_{\\text{alias}} = \\left| 0.9 - 1 \\cdot \\frac{2}{3} \\right| = \\left| \\frac{9}{10} - \\frac{2}{3} \\right| = \\left| \\frac{27 - 20}{30} \\right| = \\frac{7}{30} \\text{ Hz}\n$$\nLet's check if this value is in the range $[0, f_N]$.\n$$\n\\frac{7}{30} \\approx 0.2333... \\text{ Hz}\n$$\nThe Nyquist frequency is $f_N = 1/3 \\approx 0.3333...$ Hz. Since $0 \\le 7/30 \\le 1/3$, this is a valid aliased frequency.\n\nFor other integer values of $k$, such as $k=2$, we get $|0.9 - 2 \\cdot (2/3)| = |0.9 - 4/3| = |-13/30| = 13/30 \\approx 0.4333$ Hz, which is outside the range $[0, f_N]$. Thus, $k=1$ is the correct integer.\n\nThe aliased frequency is exactly $f_{\\text{alias}} = 7/30$ Hz. The problem requires the answer to be rounded to four significant figures.\n$$\nf_{\\text{alias}} = 0.233333... \\text{ Hz} \\approx 0.2333 \\text{ Hz}\n$$",
            "answer": "$$\n\\boxed{0.2333}\n$$"
        },
        {
            "introduction": "Having established how we sample the BOLD signal, we must ask: what are the fundamental limits of this sampling process? This thought experiment explores how fMRI acquisition parameters can make certain neural phenomena difficult, or even impossible, to reliably detect. By modeling the brief, and often debated, \"initial dip\" of the HRF, you will use basic probability to quantify the likelihood of missing this event entirely due to the random timing of scanner acquisitions relative to the stimulus. ",
            "id": "4178474",
            "problem": "A brief negative deflection known as the initial dip in the Hemodynamic Response Function (HRF) $h(t)$ is hypothesized to occur immediately after stimulus onset and to last for a finite duration. Consider an impulse stimulus at time $t=0$, and assume that the initial dip is a strictly negative segment of $h(t)$ supported on the interval $[0,\\Delta]$ with $\\Delta=1\\,\\text{s}$. Functional magnetic resonance imaging (fMRI) data are acquired at discrete sampling times separated by the repetition time (TR), denoted $T_R=2\\,\\text{s}$. Let the sampling times be $t_k=\\phi+kT_R$ for integers $k\\geq 0$, where the phase $\\phi$ is the unknown offset between the first acquisition time following stimulus onset and the stimulus onset itself. Assume $\\phi$ is uniformly distributed on $[0,T_R)$ due to uncontrolled synchronization between stimulus onset and scanner acquisition.\n\nDefine the event that the initial dip is \"captured\" as the existence of at least one $k\\geq 0$ such that $t_k\\in[0,\\Delta]$. Otherwise, the initial dip is \"missed\" due solely to the sampling phase. Starting from first principles about discrete-time sampling of a continuous-time process and the uniform phase model, derive whether the initial dip can be reliably detected in this acquisition regime and compute the probability that the initial dip is missed due to sampling phase alone. Express the final probability as a fraction. No rounding is required.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n-   The Hemodynamic Response Function (HRF) is denoted by $h(t)$.\n-   An impulse stimulus occurs at time $t=0$.\n-   An initial dip in $h(t)$ is a strictly negative segment supported on the interval $[0, \\Delta]$.\n-   The duration of the dip is $\\Delta=1\\,\\text{s}$.\n-   The repetition time for fMRI data acquisition is $T_R=2\\,\\text{s}$.\n-   The discrete sampling times are $t_k = \\phi + k T_R$ for integers $k \\geq 0$.\n-   The sampling phase, $\\phi$, is a random variable uniformly distributed on the interval $[0, T_R)$.\n-   The event \"captured\" is defined as the existence of at least one integer $k \\geq 0$ such that the sampling time $t_k$ falls within the dip's interval, i.e., $t_k \\in [0, \\Delta]$.\n-   The event \"missed\" is the complement of \"captured\".\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientifically Grounded**: The problem is well-grounded in the field of neuroscience data analysis, specifically functional magnetic resonance imaging (fMRI). The concepts of the HRF, its initial dip, the repetition time ($T_R$), and the effect of sampling phase ($\\phi$) are standard and fundamental to understanding fMRI signal properties. The parameter values $\\Delta=1\\,\\text{s}$ and $T_R=2\\,\\text{s}$ are realistic for fMRI experiments.\n-   **Well-Posed**: The problem is mathematically well-posed. The variables and parameters are clearly defined. The random variable $\\phi$ has a specified probability distribution. The events \"captured\" and \"missed\" are unambiguously defined, allowing for the calculation of a unique probability.\n-   **Objective**: The problem is stated in precise, objective language, free of subjective claims or ambiguity.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically sound, well-posed, and objective. A solution will be derived.\n\n### Derivation\nThe objective is to compute the probability that the initial dip is \"missed\". This is the probability that no sampling time $t_k$ falls within the interval $[0, \\Delta]$. The sampling times are given by the sequence $t_k = \\phi + k T_R$ for non-negative integers $k$, where $\\phi$ is a random variable uniformly distributed on $[0, T_R)$.\n\nThe event \"captured\" occurs if there exists at least one $k \\ge 0$ such that $t_k \\in [0, \\Delta]$. This condition can be written as:\n$$0 \\le \\phi + k T_R \\le \\Delta$$\n\nThe event \"missed\" is the complement, meaning that for all $k \\ge 0$, $t_k \\notin [0, \\Delta]$. We seek to compute $P(\\text{missed})$. It is often simpler to compute the probability of the complement event, $P(\\text{captured})$, and use the relation $P(\\text{missed}) = 1 - P(\\text{captured})$.\n\nLet's analyze the condition $0 \\le \\phi + k T_R \\le \\Delta$ for different values of $k$.\n\nCase 1: $k=0$\nThe sampling time is $t_0 = \\phi$. The condition for capturing the dip at this time point is $0 \\le \\phi \\le \\Delta$. Since the domain of $\\phi$ is $[0, T_R)$ and we are given $\\Delta = 1\\,\\text{s}$ and $T_R = 2\\,\\text{s}$, so $\\Delta  T_R$, this is a possible outcome. The dip is captured at $t_0$ if $\\phi \\in [0, \\Delta]$.\n\nCase 2: $k \\ge 1$\nThe sampling times are $t_k = \\phi + k T_R$ for $k=1, 2, 3, \\ldots$. The condition for capturing the dip is $0 \\le \\phi + k T_R \\le \\Delta$.\nSince $\\phi \\in [0, T_R)$, we know $\\phi \\ge 0$. Also, since $k \\ge 1$ and $T_R0$, the term $k T_R$ is positive. Thus, the lower bound $0 \\le \\phi + k T_R$ is always satisfied.\nThe critical part of the condition is the upper bound:\n$$\\phi + k T_R \\le \\Delta$$\nRearranging for $\\phi$, we get:\n$$\\phi \\le \\Delta - k T_R$$\nLet's substitute the given values $\\Delta=1$ and $T_R=2$:\n$$\\phi \\le 1 - 2k$$\nNow we examine this for $k \\ge 1$:\n-   For $k=1$: $\\phi \\le 1 - 2(1) = -1$.\n-   For $k=2$: $\\phi \\le 1 - 2(2) = -3$.\n-   For any integer $k \\ge 1$, the value $1 - 2k$ is a negative number.\n\nHowever, the random variable $\\phi$ is defined on the interval $[0, T_R) = [0, 2)$, which means $\\phi$ can only take non-negative values. There is no value of $\\phi$ in its domain $[0, 2)$ that can satisfy the condition $\\phi \\le \\text{negative number}$.\nTherefore, it is impossible for any sampling time $t_k$ with $k \\ge 1$ to fall within the interval $[0, \\Delta]$.\n\nThis analysis shows that the initial dip can be captured if and only if the very first sample, $t_0$, falls within the interval $[0, \\Delta]$. All subsequent samples will necessarily occur after the dip has ended.\nThe event \"captured\" is thus equivalent to the event $\\{t_0 \\in [0, \\Delta]\\}$, which is equivalent to $\\{\\phi \\in [0, \\Delta]\\}$.\nThe event \"missed\" is equivalent to the event $\\{t_0 \\notin [0, \\Delta]\\}$, which, given that $\\phi \\in [0, T_R)$, is equivalent to $\\{\\phi \\in (\\Delta, T_R)\\}$.\n\nWe can now compute the probability of the \"missed\" event directly. The variable $\\phi$ is uniformly distributed on $[0, T_R)$. The probability of $\\phi$ falling into a sub-interval is the ratio of the length of the sub-interval to the length of the total interval $[0, T_R)$.\n\nThe length of the total interval of possible values for $\\phi$ is $L_{total} = T_R - 0 = T_R$.\nThe \"missed\" event corresponds to $\\phi$ being in the sub-interval $(\\Delta, T_R)$. The length of this sub-interval is $L_{missed} = T_R - \\Delta$.\n\nThe probability of the dip being missed is:\n$$P(\\text{missed}) = \\frac{L_{missed}}{L_{total}} = \\frac{T_R - \\Delta}{T_R} = 1 - \\frac{\\Delta}{T_R}$$\n\nSubstituting the given numerical values $\\Delta = 1\\,\\text{s}$ and $T_R = 2\\,\\text{s}$:\n$$P(\\text{missed}) = 1 - \\frac{1\\,\\text{s}}{2\\,\\text{s}} = 1 - \\frac{1}{2} = \\frac{1}{2}$$\n\nThe question also asks whether the initial dip can be \"reliably detected\". A probability of $1/2$ for missing the event entirely due to random sampling phase means that in $50\\%$ of cases, no data point will be acquired during the initial dip. A detection method that fails half the time purely by chance cannot be considered reliable. Therefore, in this acquisition regime, the initial dip cannot be reliably detected.\n\nThe final computed value is the probability that the initial dip is missed.",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "Even if we could measure the HRF perfectly, could we uniquely determine the physiological parameters that generated it? This simulation-based practice addresses the critical issue of parameter non-identifiability, where different combinations of underlying parameters can produce nearly indistinguishable HRF shapes. By constructing and comparing HRFs from two distinct, hypothetical parameter sets, you will gain an intuitive understanding of why recovering a single \"true\" set of parameters from BOLD data is a profound challenge. ",
            "id": "4178455",
            "problem": "You will implement a principled simulation in the context of modeling the Hemodynamic Response Function (HRF) to demonstrate parameter non-identifiability from Blood Oxygen Level Dependent (BOLD) data. The Hemodynamic Response Function (HRF) is a causal impulse response that maps latent neural activity to observed BOLD fluctuations in functional Magnetic Resonance Imaging (fMRI) under the assumption that the mapping is approximately linear and time-invariant. Your program must use a difference-of-gammas model for the HRF and compute quantitative metrics that reveal epistemic limits of parameter recovery.\n\nFundamental base. The mapping from neural drive to the BOLD signal is modeled as a linear time-invariant system where the BOLD signal is the convolution of the latent neural time course with the HRF. The HRF is modeled as a difference of two gamma density functions, which is a widely used and empirically supported form in fMRI analysis. The gamma density for shape parameter $k$ and scale parameter $\\theta$ evaluated at time $t \\ge 0$ is\n$$\ng(t; k, \\theta) = \\frac{t^{k - 1} e^{-t/\\theta}}{\\Gamma(k) \\, \\theta^{k}},\n$$\nwhere $\\Gamma(k)$ is the Euler gamma function. The difference-of-gammas HRF is defined by\n$$\nh(t; k_1, \\theta_1, k_2, \\theta_2, c, s) = s \\left( g(t; k_1, \\theta_1) - c \\, g(t; k_2, \\theta_2) \\right),\n$$\nwith $k_1 \\gt 0$, $k_2 \\gt 0$, $\\theta_1 \\gt 0$, $\\theta_2 \\gt 0$, $c \\gt 0$, and $s \\gt 0$. The parameter $c$ controls the relative weight of the post-stimulus undershoot, and $s$ is a global amplitude scaling.\n\nNumerical grid. Compute the HRF on a uniform grid $t_n = n \\Delta t$ for $n = 0, 1, \\dots, N$ with $t_N = T_{\\max}$, where $\\Delta t$ is the sampling step and $T_{\\max}$ is the maximum time span. You will also compute a discretized version on a coarser grid with sampling interval equal to the repetition time $TR$ used in fMRI acquisition.\n\nMetrics. For each test case, given two parameter sets $\\Theta_A$ and $\\Theta_B$, compute three metrics:\n1. The minimal normalized root-mean-square error (NRMSE) between $h_A(t)$ and $h_B(t)$ under optimal global amplitude rescaling of $h_B(t)$:\n   - First compute $\\alpha^\\star$ that minimizes\n   $$\n   J(\\alpha) = \\sum_{n=0}^{N} \\left( h_A(t_n) - \\alpha \\, h_B(t_n) \\right)^2,\n   $$\n   which is given by\n   $$\n   \\alpha^\\star = \\frac{\\sum_{n=0}^{N} h_A(t_n) h_B(t_n)}{\\sum_{n=0}^{N} h_B(t_n)^2}.\n   $$\n   - Then compute the NRMSE\n   $$\n   \\mathrm{NRMSE} = \\sqrt{ \\frac{ \\sum_{n=0}^{N} \\left( h_A(t_n) - \\alpha^\\star h_B(t_n) \\right)^2 }{ \\sum_{n=0}^{N} h_A(t_n)^2 } }.\n   $$\n   This metric is dimensionless and evaluates shape similarity modulo global amplitude differences.\n2. The absolute difference in time-to-peak (TTP) between $h_A(t)$ and $h_B(t)$, defined as\n   $$\n   \\Delta \\mathrm{TTP} = \\left| t^{\\mathrm{peak}}_A - t^{\\mathrm{peak}}_B \\right|,\n   $$\n   where $t^{\\mathrm{peak}}$ is the time $t_n$ at which $h(t_n)$ attains its maximum on the grid. Express $\\Delta \\mathrm{TTP}$ in seconds.\n3. The Pearson correlation coefficient between the coarse samples $\\{ h_A(m \\cdot TR) \\}_{m}$ and $\\{ h_B(m \\cdot TR) \\}_{m}$:\n   $$\n   \\rho = \\frac{ \\sum_{m} \\left( h_A(m \\cdot TR) - \\overline{h_A} \\right) \\left( h_B(m \\cdot TR) - \\overline{h_B} \\right) }{ \\sqrt{ \\sum_{m} \\left( h_A(m \\cdot TR) - \\overline{h_A} \\right)^2 } \\sqrt{ \\sum_{m} \\left( h_B(m \\cdot TR) - \\overline{h_B} \\right)^2 } },\n   $$\n   where $\\overline{h_A}$ and $\\overline{h_B}$ denote the sample means over the coarse grid. This metric is dimensionless.\n\nTime units. When reporting the time-to-peak difference, express the answer in seconds. Angles are not used. Percentages must not be used; all ratios must be decimal values.\n\nTest suite. Use the following three cases to expose different facets of epistemic limits:\n\n- Case A (happy path: amplitude-only degeneracy). Let $T_{\\max} = 32$ seconds, $\\Delta t = 0.1$ seconds, $TR = 2.0$ seconds. Define\n  $$\n  \\Theta_A = (k_1 = 6, \\theta_1 = 1, k_2 = 12, \\theta_2 = 1, c = 0.35, s = 1.0),\n  $$\n  $$\n  \\Theta_B = (k_1 = 6, \\theta_1 = 1, k_2 = 12, \\theta_2 = 1, c = 0.35, s = 1.5).\n  $$\n  These sets differ only by the amplitude $s$, which is not identifiable under global rescaling.\n- Case B (near-shape degeneracy via trade-offs in rise and dispersion). Let $T_{\\max} = 32$ seconds, $\\Delta t = 0.1$ seconds, $TR = 2.0$ seconds. Define\n  $$\n  \\Theta_A = (k_1 = 5, \\theta_1 = 1.2, k_2 = 14, \\theta_2 = 1.0, c = 0.34, s = 1.0),\n  $$\n  $$\n  \\Theta_B = (k_1 = 4.5, \\theta_1 = 1.33, k_2 = 13.5, \\theta_2 = 1.04, c = 0.32, s = 1.03).\n  $$\n  These sets are designed to have similar effective means $k \\theta$ for each gamma component while perturbing dispersion and undershoot ratio, yielding near-identical $h(t)$ curves in practice.\n- Case C (edge case: coarse sampling reduces distinguishability). Let $T_{\\max} = 32$ seconds, $\\Delta t = 0.1$ seconds, $TR = 3.0$ seconds. Define\n  $$\n  \\Theta_A = (k_1 = 3, \\theta_1 = 1.8, k_2 = 7, \\theta_2 = 1.8, c = 0.35, s = 1.0),\n  $$\n  $$\n  \\Theta_B = (k_1 = 6, \\theta_1 = 0.9, k_2 = 12, \\theta_2 = 0.9, c = 0.35, s = 1.0).\n  $$\n  These sets differ in time scaling but can appear similar on coarse $TR$ sampling, stressing epistemic limits arising from acquisition constraints.\n\nOutput specification. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Specifically, output a list of three sublists, one per case, where each sublist contains three floating-point values in the order $\\left[ \\mathrm{NRMSE}, \\Delta \\mathrm{TTP} \\text{ in seconds}, \\rho \\right]$. For example, an output might look like\n$$\n\\left[ [0.000000, 0.000000, 1.000000], [0.023451, 0.400000, 0.997812], [0.083519, 1.500000, 0.982301] \\right].\n$$\nRound all floating-point outputs to $6$ decimal places. The output must contain only this single line in the specified format.",
            "solution": "The user-provided problem statement is valid. It is scientifically grounded in the principles of fMRI data analysis, specifically the modeling of the hemodynamic response function (HRF) using a linear time-invariant system framework. The mathematical definitions for the difference-of-gammas HRF model and the quantitative metrics (NRMSE, $\\Delta \\mathrm{TTP}$, $\\rho$) are standard and well-posed. The problem is self-contained, providing all necessary parameters and conditions for the three test cases. The objective is clear and unambiguous, leading to a unique and verifiable numerical solution.\n\nThe solution proceeds by first implementing the core mathematical models and then applying them to calculate the specified metrics for each test case. The entire process is encapsulated in a Python program that adheres to the specified execution environment.\n\n1.  **Hemodynamic Response Function (HRF) Model Implementation**\n    The foundation of the simulation is the difference-of-gammas model for the HRF. The gamma probability density function, $g(t; k, \\theta)$, for a shape parameter $k  0$ and a scale parameter $\\theta  0$ is defined as:\n    $$\n    g(t; k, \\theta) = \\frac{t^{k - 1} e^{-t/\\theta}}{\\Gamma(k) \\, \\theta^{k}}, \\quad t \\ge 0\n    $$\n    where $\\Gamma(k)$ is the Euler gamma function, which will be computed using `scipy.special.gamma`. A helper function is implemented to compute $g(t; k, \\theta)$ over a discrete time vector $t$. Special care is taken for the point $t=0$. Since all shape parameters $k$ provided in the test cases are greater than $1$, $g(0; k, \\theta) = 0$. The implementation handles this by evaluating the formula only for $t  0$ and setting the value at $t=0$ to $0$.\n\n    The HRF, $h(t)$, is then constructed as a weighted difference of two such gamma functions:\n    $$\n    h(t; k_1, \\theta_1, k_2, \\theta_2, c, s) = s \\left( g(t; k_1, \\theta_1) - c \\, g(t; k_2, \\theta_2) \\right)\n    $$\n    Another function implements this by calling the gamma PDF function twice with the respective parameters $(k_1, \\theta_1)$ and $(k_2, \\theta_2)$, and then combining them according to the formula with the undershoot ratio $c$ and the global scaling factor $s$.\n\n2.  **Numerical Grid Generation**\n    For each test case, a high-resolution time grid is created, spanning from $t=0$ to $T_{\\max}$ with a step size of $\\Delta t$. This grid, denoted as $\\{t_n\\}$, is used for the primary computation of the HRF shapes and for two of the three metrics. The number of points on this grid is $N+1$, where $N = T_{\\max} / \\Delta t$.\n\n3.  **Metric Computation Algorithm**\n    For each pair of parameter sets, $\\Theta_A$ and $\\Theta_B$, the corresponding HRFs, $h_A(t)$ and $h_B(t)$, are generated on the fine time grid. Subsequently, three metrics are computed to quantify their similarity and differences.\n\n    -   **Normalized Root-Mean-Square Error (NRMSE)**: This metric assesses the shape similarity between $h_A(t)$ and $h_B(t)$ independent of global amplitude. First, an optimal scaling factor $\\alpha^\\star$ is computed to minimize the squared error between $h_A$ and a rescaled $h_B$. This is a standard linear least-squares problem, and the solution is given by:\n        $$\n        \\alpha^\\star = \\frac{\\sum_{n=0}^{N} h_A(t_n) h_B(t_n)}{\\sum_{n=0}^{N} h_B(t_n)^2} = \\frac{\\mathbf{h}_A \\cdot \\mathbf{h}_B}{\\mathbf{h}_B \\cdot \\mathbf{h}_B}\n        $$\n        where $\\mathbf{h}_A$ and $\\mathbf{h}_B$ are vectors of the HRF values on the fine grid. The NRMSE is then the root-mean-square of the residual error, normalized by the norm of $\\mathbf{h}_A$:\n        $$\n        \\mathrm{NRMSE} = \\sqrt{ \\frac{ \\sum_{n=0}^{N} \\left( h_A(t_n) - \\alpha^\\star h_B(t_n) \\right)^2 }{ \\sum_{n=0}^{N} h_A(t_n)^2 } }\n        $$\n\n    -   **Difference in Time-to-Peak ($\\Delta \\mathrm{TTP}$)**: This metric captures differences in the temporal dynamics. The time-to-peak for each HRF, $t^{\\mathrm{peak}}_A$ and $t^{\\mathrm{peak}}_B$, is found by locating the index of the maximum value of the function on the fine discrete grid and retrieving the corresponding time value. The absolute difference is then calculated:\n        $$\n        \\Delta \\mathrm{TTP} = \\left| t^{\\mathrm{peak}}_A - t^{\\mathrm{peak}}_B \\right|\n        $$\n\n    -   **Pearson Correlation ($\\rho$)**: This metric evaluates the linear relationship between the two HRFs, but specifically on a coarse grid that simulates the temporal resolution of an fMRI acquisition. The coarse grid is defined by the repetition time, $TR$. The HRF time courses are downsampled by selecting values at time points $m \\cdot TR$ for $m=0, 1, 2, \\dots$. Since $TR$ is an integer multiple of $\\Delta t$ in all test cases, this is achieved by simple array slicing with a step of $TR/\\Delta t$. The Pearson correlation coefficient $\\rho$ is then computed between these two coarse-sampled vectors, $\\{h_A(m \\cdot TR)\\}_m$ and $\\{h_B(m \\cdot TR)\\}_m$.\n\n4.  **Execution and Output Formatting**\n    The main program logic iterates through the three test cases provided. For each case, it unpacks the grid parameters ($T_{\\max}, \\Delta t, TR$) and the two HRF parameter sets ($\\Theta_A, \\Theta_B$). It orchestrates the generation of the HRF curves and the computation of the three metrics. The resulting triplet of floating-point numbers $[\\mathrm{NRMSE}, \\Delta \\mathrm{TTP}, \\rho]$ for each case is collected. Finally, the results for all cases are formatted into a single string as a list of lists, with each numerical value rounded to $6$ decimal places, and printed to standard output as per the problem specification.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma as gamma_function\n\ndef gamma_pdf(t: np.ndarray, k: float, theta: float) - np.ndarray:\n    \"\"\"\n    Computes the Gamma probability density function.\n    \n    Args:\n        t (np.ndarray): Time vector.\n        k (float): Shape parameter.\n        theta (float): Scale parameter.\n        \n    Returns:\n        np.ndarray: The values of the Gamma PDF at times t.\n    \"\"\"\n    if k = 0 or theta = 0:\n        return np.zeros_like(t, dtype=float)\n\n    # For k  1 (as in this problem), g(0) = 0. For k=1, g(0)=1/theta. \n    # For k  1, g(0) is infinite.\n    # The current implementation is robust for k  0.\n    result = np.zeros_like(t, dtype=float)\n    \n    # Calculate for t  0 to avoid numerical issues like 0**negative_power if k  1.\n    mask = t  0\n    t_pos = t[mask]\n    \n    numerator = np.power(t_pos, k - 1) * np.exp(-t_pos / theta)\n    denominator = gamma_function(k) * np.power(theta, k)\n    \n    if denominator  0:\n        result[mask] = numerator / denominator\n        \n    return result\n\ndef hrf(t: np.ndarray, k1: float, theta1: float, k2: float, theta2: float, c: float, s: float) - np.ndarray:\n    \"\"\"\n    Computes the difference-of-gammas Hemodynamic Response Function (HRF).\n    \n    Args:\n        t (np.ndarray): Time vector.\n        k1, theta1: Parameters for the first gamma function.\n        k2, theta2: Parameters for the second gamma function.\n        c (float): Relative weight of the second gamma (undershoot).\n        s (float): Global amplitude scaling.\n        \n    Returns:\n        np.ndarray: The HRF evaluated at times t.\n    \"\"\"\n    g1 = gamma_pdf(t, k1, theta1)\n    g2 = gamma_pdf(t, k2, theta2)\n    return s * (g1 - c * g2)\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'label': 'Case A',\n            'T_max': 32.0, 'dt': 0.1, 'TR': 2.0,\n            'Theta_A': {'k1': 6.0, 'theta1': 1.0, 'k2': 12.0, 'theta2': 1.0, 'c': 0.35, 's': 1.0},\n            'Theta_B': {'k1': 6.0, 'theta1': 1.0, 'k2': 12.0, 'theta2': 1.0, 'c': 0.35, 's': 1.5}\n        },\n        {\n            'label': 'Case B',\n            'T_max': 32.0, 'dt': 0.1, 'TR': 2.0,\n            'Theta_A': {'k1': 5.0, 'theta1': 1.2, 'k2': 14.0, 'theta2': 1.0, 'c': 0.34, 's': 1.0},\n            'Theta_B': {'k1': 4.5, 'theta1': 1.33, 'k2': 13.5, 'theta2': 1.04, 'c': 0.32, 's': 1.03}\n        },\n        {\n            'label': 'Case C',\n            'T_max': 32.0, 'dt': 0.1, 'TR': 3.0,\n            'Theta_A': {'k1': 3.0, 'theta1': 1.8, 'k2': 7.0, 'theta2': 1.8, 'c': 0.35, 's': 1.0},\n            'Theta_B': {'k1': 6.0, 'theta1': 0.9, 'k2': 12.0, 'theta2': 0.9, 'c': 0.35, 's': 1.0}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        T_max, dt, TR = case['T_max'], case['dt'], case['TR']\n        \n        # 1. Generate time grid and HRFs\n        num_points = int(T_max / dt) + 1\n        t = np.linspace(0, T_max, num_points)\n        \n        h_A = hrf(t, **case['Theta_A'])\n        h_B = hrf(t, **case['Theta_B'])\n\n        # 2. Compute metrics\n        \n        # Metric 1: NRMSE\n        hA_dot_hB = np.dot(h_A, h_B)\n        hB_dot_hB = np.dot(h_B, h_B)\n        alpha_star = hA_dot_hB / hB_dot_hB if hB_dot_hB  0 else 0.0\n        \n        hA_dot_hA = np.dot(h_A, h_A)\n        residual_sq_sum = np.sum(np.power(h_A - alpha_star * h_B, 2))\n        nrmse = np.sqrt(residual_sq_sum / hA_dot_hA) if hA_dot_hA  0 else 0.0\n\n        # Metric 2: Delta TTP\n        t_peak_A = t[np.argmax(h_A)]\n        t_peak_B = t[np.argmax(h_B)]\n        delta_ttp = np.abs(t_peak_A - t_peak_B)\n\n        # Metric 3: Pearson Correlation on coarse grid\n        coarse_sample_step = int(round(TR / dt))\n        h_A_coarse = h_A[::coarse_sample_step]\n        h_B_coarse = h_B[::coarse_sample_step]\n        \n        # Ensure there are at least 2 points for correlation\n        if len(h_A_coarse)  2:\n            rho = np.nan # Undefined correlation\n        else:\n            correlation_matrix = np.corrcoef(h_A_coarse, h_B_coarse)\n            rho = correlation_matrix[0, 1]\n\n        all_results.append([nrmse, delta_ttp, rho])\n\n    # 3. Format and print output\n    formatted_case_results = []\n    for R in all_results:\n        # Format each triplet [nrmse, dttp, rho] with 6 decimal places\n        formatted_case_results.append(f\"[{R[0]:.6f},{R[1]:.6f},{R[2]:.6f}]\")\n    \n    final_output_string = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}