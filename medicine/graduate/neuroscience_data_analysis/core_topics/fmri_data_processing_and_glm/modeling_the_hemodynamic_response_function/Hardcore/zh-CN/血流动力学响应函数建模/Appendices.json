{
    "hands_on_practices": [
        {
            "introduction": "通用线性模型（GLM）是功能性磁共振成像（fMRI）分析的基石。这个实践练习将指导你完成其中最关键的一步：构建设计矩阵。通过亲手实现从连续时间的神经事件和血流动力学响应函数（HRF）卷积理论到离散时间的 fMRI 数据分析的转换，你将深刻理解模型构建的细节与挑战 ()。",
            "id": "4149325",
            "problem": "您正在使用通用线性模型（GLM）分析功能性磁共振成像（fMRI）时间序列，其中每个条件的神经事件被建模为事件回归量，并与血流动力学响应函数（HRF）进行卷积。从连续时间卷积和GLM的定义出发，推导并实现通过将事件回归量与HRF核进行卷积并在采集时间点上采样来构建离散时间设计矩阵的过程。此外，解释并实现如何使用一组基函数对HRF进行灵活建模，将其表示为基元的线性组合。\n\n使用以下基础知识：\n- 离散样本的通用线性模型（GLM）定义为 $y[n] = \\sum_{j=1}^{p} X[n,j] \\,\\beta_j + \\varepsilon[n]$，其中 $y[n]$ 是在样本索引 $n$ 处测量的信号，$X[n,j]$ 是回归量（设计矩阵的列），$\\beta_j$ 是系数，$\\varepsilon[n]$ 是噪声。\n- 两个函数 $s(t)$ 和 $h(t)$ 的连续时间卷积定义为 $(s * h)(t) = \\int_{-\\infty}^{\\infty} s(\\tau)\\,h(t - \\tau)\\,d\\tau$。在此设置中，$s(t)$ 是事件回归量，$h(t)$ 是HRF。\n- 在采集时间 $t_n = n\\,\\Delta$ 处的离散时间采样被建模为 $x[n] = (s * h)(t_n)$，其中 $\\Delta$ 是采样间隔（重复时间，TR）。\n\n您必须使用在步长为 $\\delta t$ 的高分辨率时间网格上对卷积积分进行数值稳定的黎曼和近似，然后在采集时间 $t_n = n\\,\\mathrm{TR}$ 进行采样，来实现设计矩阵的构建。所有时间量必须以秒为单位处理，并且答案必须尊重单位一致性。振幅是无量纲的。\n\n将条件 $c$ 的事件回归量 $s_c(t)$ 定义为单位振幅的箱形函数之和：\n$$\ns_c(t) = \\sum_{i=1}^{N_c} \\mathbf{1}\\{t \\in [o_{c,i},\\,o_{c,i} + d_{c,i})\\},\n$$\n其中 $o_{c,i}$ 是以秒为单位的起始时间，$d_{c,i}$ 是以秒为单位的持续时间，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。设计矩阵的每一列对应一对 $(c,k)$，其中 $c$ 索引条件，$k$ 索引HRF基函数。对于单个HRF $h(t)$，条件 $c$ 的列是 $x_c[n] = (s_c * h)(t_n)$。对于一组基函数 $\\{b_k(t)\\}_{k=1}^K$，使用列 $x_{c,k}[n] = (s_c * b_k)(t_n)$，这样灵活的HRF $h(t)$ 就可以表示为 $h(t) = \\sum_{k=1}^K \\alpha_k\\,b_k(t)$，并通过GLM系数 $\\{\\alpha_k\\}$ 进行估计。\n\n为保证科学真实性和数值稳定性：\n- 使用黎曼和离散化，在步长为 $\\delta t$ 的高分辨率网格上（例如 $\\delta t = 0.1\\,\\mathrm{s}$）通过近似 $(s * h)(t) \\approx \\delta t \\sum_{m} s(m\\,\\delta t)\\,h(t - m\\,\\delta t)$ 来实现卷积。\n- 通过设置当 $t  0$ 时 $h(t) = 0$ 来确保因果性，并将卷积截断到采集窗口 $[0, T)$ 内，其中 $T$ 是总扫描时长（秒）。\n- 基函数必须是因果的，并且支撑集在 $[0,\\infty)$ 上。对于此问题，使用双伽马HRF作为规范基元，并通过将规范基元以固定延迟进行时间平移来构建额外的基元。具体来说，将规范HRF $b_1(t)$ 定义为\n$$\nb_1(t) = g(t; k_1, \\theta_1) - r\\,g(t; k_2, \\theta_2),\n$$\n其中 $g(t;k,\\theta) = \\frac{t^{k-1} e^{-t/\\theta}}{\\theta^k \\,\\Gamma(k)}$ 对于 $t \\ge 0$ 成立，而当 $t  0$ 时 $g(t;k,\\theta) = 0$。参数 $(k_1,\\theta_1)$ 和 $(k_2,\\theta_2)$ 在下面的测试套件中指定。令 $b_2(t) = b_1(t - \\delta_1)$ 和 $b_3(t) = b_1(t - \\delta_2)$，其中 $\\delta_1$ 和 $\\delta_2$ 是以秒为单位的固定延迟，并且当 $t  0$ 时 $b_k(t) = 0$。\n\n所有时间都以秒表示。不涉及角度。所有输出必须是无量纲的实数。\n\n实现一个程序，为每个测试用例构建设计矩阵并计算指定的标量诊断指标。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”）。每个测试用例的指标如下：\n\n- 测试用例 $1$（理想路径，单个HRF）：\n  - 参数：总扫描时长 $T = 60\\,\\mathrm{s}$，$\\mathrm{TR} = 2\\,\\mathrm{s}$，高分辨率步长 $\\delta t = 0.1\\,\\mathrm{s}$，条件数 $C = 2$。\n  - 条件 $1$：起始时间 $[0, 12, 24]\\,\\mathrm{s}$，持续时间 $[1, 1, 1]\\,\\mathrm{s}$。\n  - 条件 $2$：起始时间 $[6, 18, 30]\\,\\mathrm{s}$，持续时间 $[2, 2, 2]\\,\\mathrm{s}$。\n  - 规范HRF参数：$(k_1, \\theta_1) = (6, 1)$，$(k_2, \\theta_2) = (12, 1)$，比率 $r = 0.35$，HRF支撑集在 $L = 32\\,\\mathrm{s}$ 处截断。\n  - 基：单个元素 $b_1(t)$。\n  - 指标：设计矩阵的弗罗贝尼乌斯范数，即 $\\|X\\|_F = \\sqrt{\\sum_{n,j} X[n,j]^2}$。\n\n- 测试用例 $2$（通过时间平移实现基的灵活性）：\n  - 参数：$T = 60\\,\\mathrm{s}$，$\\mathrm{TR} = 2\\,\\mathrm{s}$，$\\delta t = 0.1\\,\\mathrm{s}$，条件数 $C = 1$。\n  - 条件 $1$：起始时间 $[10, 20, 40]\\,\\mathrm{s}$，持续时间 $[0.5, 0.5, 0.5]\\,\\mathrm{s}$。\n  - 规范HRF $b_1(t)$ 与测试用例1中相同，HRF支撑集 $L = 32\\,\\mathrm{s}$。\n  - 基：三个元素 $\\{b_1(t), b_1(t - \\delta_1), b_1(t - \\delta_2)\\}$，延迟 $\\delta_1 = 1\\,\\mathrm{s}$，$\\delta_2 = 2\\,\\mathrm{s}$。\n  - 指标：$X$ 的最小奇异值，即 $\\min \\sigma_i(X)$。\n\n- 测试用例 $3$（扫描结束附近的边界条件）：\n  - 参数：$T = 50\\,\\mathrm{s}$，$\\mathrm{TR} = 2\\,\\mathrm{s}$，$\\delta t = 0.1\\,\\mathrm{s}$，条件数 $C = 1$。\n  - 条件 $1$：起始时间 $[45]\\,\\mathrm{s}$，持续时间 $[2]\\,\\mathrm{s}$。\n  - 基：单个元素 $b_1(t)$，规范参数与测试用例1中相同，HRF支撑集 $L = 32\\,\\mathrm{s}$。\n  - 指标：单列设计矩阵中最后 $5$ 个采样项之和，即 $\\sum_{n = N-5}^{N-1} X[n,1]$，其中 $N = T / \\mathrm{TR}$。\n\n- 测试用例 $4$（粗略采样下的混叠，两种卷积方案的比较）：\n  - 参数：$T = 64\\,\\mathrm{s}$，$\\mathrm{TR} = 4\\,\\mathrm{s}$，高分辨率步长 $\\delta t = 0.1\\,\\mathrm{s}$，条件数 $C = 1$。\n  - 条件 $1$：起始时间 $[0, 8, 16, 24, 32, 40, 48, 56]\\,\\mathrm{s}$，持续时间 $[1, 1, 1, 1, 1, 1, 1, 1]\\,\\mathrm{s}$。\n  - 基：单个元素 $b_1(t)$，规范参数与测试用例1中相同，HRF支撑集 $L = 32\\,\\mathrm{s}$。\n  - 计算两个设计列：\n    - 方法A（朴素的TR网格卷积）：构建 $s_{\\mathrm{TR}}[n] = \\mathbf{1}\\{[n\\,\\mathrm{TR}, (n+1)\\,\\mathrm{TR})$ 包含任何事件$\\}$，在TR网格上采样 $b_1$ 为 $h_{\\mathrm{TR}}[m] = b_1(m\\,\\mathrm{TR})$，然后计算离散卷积 $x_A[n] \\approx \\mathrm{TR}\\sum_{m} s_{\\mathrm{TR}}[m]\\,h_{\\mathrm{TR}}[n-m]$ 并截断到采集窗口。\n    - 方法B（高分辨率卷积后采样）：使用步长为 $\\delta t$ 的高分辨率黎曼和近似计算 $x_B[n] = (s * b_1)(n\\,\\mathrm{TR})$。\n  - 指标：最大绝对差异 $\\max_{0 \\le n  N} |x_A[n] - x_B[n]|$，其中 $N = T / \\mathrm{TR}$。\n\n您的程序应生成单行输出，其中包含一个按测试用例1、2、3、4顺序排列的逗号分隔列表，并用方括号括起来，即“[r1,r2,r3,r4]”。所有数值输出必须是实值浮点数（无量纲）。不应打印其他文本。",
            "solution": "该问题要求推导并实现一种方法，用于在fMRI数据分析的背景下构建通用线性模型（GLM）的设计矩阵。此过程涉及将神经活动建模为事件回归量，将它们与血流动力学响应函数（HRF）或一组HRF基函数进行卷积，并在fMRI采集时间点对结果进行采样。\n\n分析的基础是GLM，它将离散采样点 $n$ 处观测到的fMRI时间序列 $y[n]$ 建模为预测变量的线性组合。该模型由下式给出：\n$$\ny[n] = X \\vec{\\beta} + \\vec{\\varepsilon} \\quad \\text{或分量形式} \\quad y[n] = \\sum_{j=1}^{p} X[n,j] \\,\\beta_j + \\varepsilon[n]\n$$\n这里，$y[n]$ 是在第 $n$ 个采集时间 $t_n = n \\cdot \\mathrm{TR}$ 处的信号，其中 $\\mathrm{TR}$ 是重复时间。$X$ 是设计矩阵，其列是回归量。$\\vec{\\beta}$ 是待估计的系数向量，$\\vec{\\varepsilon}$ 代表噪声。核心任务是构建设计矩阵 $X$。\n\n底层的神经过程在连续时间 $t$ 中被概念化。GLM中的一个回归量 $X[n, j]$ 表示在时间 $t_n$ 处由特定实验条件引起的预测BOLD信号。这个预测是通过将模拟神经活动的刺激函数 $s(t)$ 与模拟生理血管响应的血流动力学响应函数 $h(t)$ 进行卷积来生成的。连续时间卷积定义为：\n$$\n(s * h)(t) = \\int_{-\\infty}^{\\infty} s(\\tau)\\,h(t - \\tau)\\,d\\tau\n$$\n采样后的回归量则为 $x[n] = (s * h)(t_n)$。\n\n该过程可以分解为以下步骤：\n\n1.  **时间离散化**：\n    为了在数值上执行卷积，我们必须从连续时间 $t$ 转换到离散表示。有两个时间网格是相关的：\n    a. 一个具有小时间步长 $\\delta t$（例如 $\\delta t = 0.1\\,\\mathrm{s}$）的高分辨率网格。该网格用于精确表示事件回归量和HRF的形状，并近似卷积积分。时间点为整数 $m$ 的 $m\\,\\delta t$。\n    b. 采集网格（或TR网格），其时间步长等于扫描仪的重复时间 $\\mathrm{TR}$（例如 $\\mathrm{TR} = 2\\,\\mathrm{s}$）。最终的设计矩阵在此网格上定义，时间点为 $t_n = n\\,\\mathrm{TR}$。\n\n2.  **在高分辨率网格上构建事件回归量**：\n    对于每个实验条件 $c$，事件回归量 $s_c(t)$ 被定义为一系列箱形函数：\n    $$\n    s_c(t) = \\sum_{i=1}^{N_c} \\mathbf{1}\\{t \\in [o_{c,i},\\,o_{c,i} + d_{c,i})\\}\n    $$\n    其中 $\\{o_{c,i}\\}$ 是事件起始时间，$\\{d_{c,i}\\}$ 是事件持续时间。这个连续函数在高分辨率网格上被离散化。对于此网格上的每个时间点 $m\\,\\delta t$，我们计算 $s_c(m\\,\\delta t)$，创建一个向量 $s_c[m]$，如果 $m\\,\\delta t$ 落在条件 $c$ 的任何事件窗口内，则其值为1，否则为0。\n\n3.  **构建HRF基核**：\n    问题指定了一组基函数 $\\{b_k(t)\\}$ 来灵活地建模HRF。规范基函数 $b_1(t)$ 是双伽马函数：\n    $$\n    b_1(t) = g(t; k_1, \\theta_1) - r\\,g(t; k_2, \\theta_2) \\quad \\text{对于 } t \\ge 0\n    $$\n    其中 $g(t;k,\\theta) = \\frac{t^{k-1} e^{-t/\\theta}}{\\theta^k \\,\\Gamma(k)}$ 是伽马分布的概率密度函数（经过缩放）。函数 $\\Gamma(k)$ 是伽马函数。此函数以及由它派生的任何其他基元（例如 $b_2(t) = b_1(t - \\delta_1)$）都在高分辨率网格上进行求值。由于因果性，$t  0$ 时 $b_k(t) = 0$。我们为每个基函数创建离散核 $b_k[m] = b_k(m\\,\\delta t)$。这些核在指定的支撑长度 $L$ 处被截断。\n\n4.  **数值卷积**：\n    连续卷积积分通过在分辨率网格上使用黎曼和的离散卷积来近似。对于给定的时间 $t_j = j\\,\\delta t$：\n    $$\n    (s_c * b_k)(t_j) = \\int_0^{t_j} s_c(\\tau)\\,b_k(t_j - \\tau)\\,d\\tau \\approx \\sum_{m=0}^{j} s_c(m\\,\\delta t)\\,b_k(t_j - m\\,\\delta t) \\,\\delta t\n    $$\n    积分限反映了因果性（当 $\\tau  0$ 时 $s_c(\\tau)=0$，当 $\\tau > t_j$ 时 $b_k(t_j - \\tau)=0$）。表达式 $\\sum_{m=0}^{j} s_c[m]\\,b_k[j-m]$ 是一个标准的离散时间卷积。执行此卷积后，结果乘以 $\\delta t$ 以正确逼近积分值。这会在高分辨率时间网格上产生一个预测的BOLD响应。\n\n5.  **在采集时间点采样**：\n    高分辨率的预测BOLD信号必须在采集时间 $t_n = n\\,\\mathrm{TR}$ 进行采样，以形成设计矩阵 $X$ 的列。设高分辨率卷积信号为 $x^{\\text{high-res}}_{c,k}[m]$。最终的回归列是：\n    $$\n    x_{c,k}[n] = x^{\\text{high-res}}_{c,k}[m] \\quad \\text{其中} \\quad m\\,\\delta t = n\\,\\mathrm{TR}\n    $$\n    这实际上是一个降采样操作，我们从高分辨率信号中选择与TR时间点对应的值。\n\n6.  **组装设计矩阵**：\n    最终的设计矩阵 $X$ 是通过连接生成的回归列 $x_{c,k}[n]$ 而形成的。每一列对应一个唯一的条件 $c$ 和基函数 $k$ 的组合。$X$ 的行数等于扫描持续时间内的TR数量，$N = T/\\mathrm{TR}$。列数是回归量的总数，即（条件数）$\\times$（基函数数）。\n\n7.  **与朴素卷积的比较（测试用例4）**：\n    一种朴素的方法可能是将刺激 $s(t)$ 和HRF $h(t)$ 直接在粗糙的TR网格上离散化，并在此网格上执行卷积。这是问题陈述中的方法A。具体来说，将通过检查区间 $[n\\,\\mathrm{TR}, (n+1)\\,\\mathrm{TR})$ 内是否发生任何刺激事件来创建 $s_{\\mathrm{TR}}[n]$，并创建 $h_{\\mathrm{TR}}[m] = h(m\\,\\mathrm{TR})$。然后计算离散卷积 $x_A[n] = \\mathrm{TR}\\sum_m s_{\\mathrm{TR}}[m]\\,h_{\\mathrm{TR}}[n-m]$。这种方法是有缺陷的，因为它模糊了刺激起始和持续时间的精确性，并且对HRF进行了欠采样，导致混叠。先进行高分辨率卷积再采样（方法B）是正确的方法，因为它在采样前尊重了信号的时间结构，与采样定理一致。差异 $|x_A[n] - x_B[n]|$ 突显了朴素方法引入的误差。\n\n这个有原则的程序确保设计矩阵能准确反映神经事件的时间和血流动力学响应的连续动态，为使用GLM进行统计推断提供了坚实的基础。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import convolve\nfrom scipy.special import gamma as gamma_func\n\ndef solve():\n    \"\"\"\n    Solves all four test cases for constructing an fMRI design matrix and computes the required metrics.\n    \"\"\"\n\n    def get_gamma_pdf(t, k, theta):\n        \"\"\"\n        Computes the value of the gamma distribution's PDF-like function g(t; k, theta).\n        \"\"\"\n        # Ensure t is non-negative for the formula to be valid\n        t_non_negative = np.maximum(t, 0)\n        # Avoid division by zero or log of zero for t=0 and k=1\n        with np.errstate(divide='ignore', invalid='ignore'):\n            val = (t_non_negative**(k - 1) * np.exp(-t_non_negative / theta)) / (theta**k * gamma_func(k))\n        val[t  0] = 0\n        val[np.isnan(val)] = 0 # Handle potential 0^0 issues when k=1 and t=0\n        return val\n\n    def get_double_gamma_hrf(t, k1, theta1, k2, theta2, r):\n        \"\"\"\n        Computes the double-gamma HRF.\n        \"\"\"\n        h = get_gamma_pdf(t, k1, theta1) - r * get_gamma_pdf(t, k2, theta2)\n        return h\n\n    def construct_design_matrix(T, TR, dt, conditions, basis_kernels):\n        \"\"\"\n        Constructs the design matrix using high-resolution convolution and TR sampling.\n        \"\"\"\n        num_scans = int(T / TR)\n        high_res_t = np.arange(0, T, dt)\n        num_high_res_points = len(high_res_t)\n\n        regressors = []\n\n        for cond_onsets, cond_durations in conditions:\n            # Create a high-resolution stimulus regressor\n            stim_hr = np.zeros(num_high_res_points)\n            for onset, duration in zip(cond_onsets, cond_durations):\n                start_idx = int(np.round(onset / dt))\n                end_idx = int(np.round((onset + duration) / dt))\n                stim_hr[start_idx:end_idx] = 1\n\n            for kernel in basis_kernels:\n                # Convolve stimulus with HRF kernel\n                # The convolution approximates the integral, so we must scale by dt.\n                convolved_hr = convolve(stim_hr, kernel, mode='full') * dt\n                \n                # Truncate to scan length\n                convolved_hr = convolved_hr[:num_high_res_points]\n\n                # Sample at TRs\n                sample_indices = (np.arange(num_scans) * TR / dt).astype(int)\n                \n                # Ensure indices are within bounds\n                valid_indices = sample_indices[sample_indices  len(convolved_hr)]\n                regressor = np.zeros(num_scans)\n                regressor[:len(valid_indices)] = convolved_hr[valid_indices]\n                \n                regressors.append(regressor)\n\n        # Handle the case of no regressors\n        if not regressors:\n            return np.zeros((num_scans, 0))\n\n        return np.column_stack(regressors)\n\n    results = []\n\n    # --- Test Case 1 ---\n    T1, TR1, dt1 = 60.0, 2.0, 0.1\n    conditions1 = [\n        (np.array([0, 12, 24]), np.array([1, 1, 1])),\n        (np.array([6, 18, 30]), np.array([2, 2, 2])),\n    ]\n    k1, theta1, k2, theta2, r = 6, 1, 12, 1, 0.35\n    L = 32.0\n    hrf_t_basis = np.arange(0, L, dt1)\n    \n    b1_kernel = get_double_gamma_hrf(hrf_t_basis, k1, theta1, k2, theta2, r)\n    basis_kernels1 = [b1_kernel]\n    \n    X1 = construct_design_matrix(T1, TR1, dt1, conditions1, basis_kernels1)\n    metric1 = np.linalg.norm(X1, 'fro')\n    results.append(metric1)\n\n    # --- Test Case 2 ---\n    T2, TR2, dt2 = 60.0, 2.0, 0.1\n    conditions2 = [\n        (np.array([10, 20, 40]), np.array([0.5, 0.5, 0.5])),\n    ]\n    delta1, delta2 = 1.0, 2.0\n\n    b1_t_shifted_0 = get_double_gamma_hrf(hrf_t_basis, k1, theta1, k2, theta2, r)\n    b1_t_shifted_1 = get_double_gamma_hrf(hrf_t_basis - delta1, k1, theta1, k2, theta2, r)\n    b1_t_shifted_2 = get_double_gamma_hrf(hrf_t_basis - delta2, k1, theta1, k2, theta2, r)\n    basis_kernels2 = [b1_t_shifted_0, b1_t_shifted_1, b1_t_shifted_2]\n\n    X2 = construct_design_matrix(T2, TR2, dt2, conditions2, basis_kernels2)\n    singular_values = np.linalg.svd(X2, compute_uv=False)\n    metric2 = singular_values.min() if singular_values.size  0 else 0.0\n    results.append(metric2)\n\n    # --- Test Case 3 ---\n    T3, TR3, dt3 = 50.0, 2.0, 0.1\n    conditions3 = [\n        (np.array([45]), np.array([2])),\n    ]\n    basis_kernels3 = [b1_kernel]\n\n    X3 = construct_design_matrix(T3, TR3, dt3, conditions3, basis_kernels3)\n    metric3 = np.sum(X3[-5:, 0]) if X3.shape[0] = 5 else np.sum(X3[:, 0])\n    results.append(metric3)\n\n    # --- Test Case 4 ---\n    T4, TR4, dt4 = 64.0, 4.0, 0.1\n    onsets4 = np.arange(0, 64, 8)\n    durations4 = np.ones_like(onsets4)\n    conditions4 = [(onsets4, durations4)]\n    basis_kernels4 = [b1_kernel]\n    num_scans4 = int(T4 / TR4)\n    tr_grid_t = np.arange(num_scans4) * TR4\n\n    # Method B (correct high-resolution)\n    X_B_matrix = construct_design_matrix(T4, TR4, dt4, conditions4, basis_kernels4)\n    x_B = X_B_matrix[:, 0]\n\n    # Method A (naïve TR-grid convolution)\n    s_tr = np.zeros(num_scans4)\n    for n in range(num_scans4):\n        tr_start, tr_end = n * TR4, (n + 1) * TR4\n        for onset, duration in zip(onsets4, durations4):\n            event_start, event_end = onset, onset + duration\n            if max(tr_start, event_start)  min(tr_end, event_end):\n                s_tr[n] = 1\n                break\n    \n    h_tr_t = np.arange(0, L, TR4)\n    h_tr = get_double_gamma_hrf(h_tr_t, k1, theta1, k2, theta2, r)\n\n    # Perform discrete convolution and scale by TR\n    x_A_full = convolve(s_tr, h_tr, mode='full') * TR4\n    x_A = x_A_full[:num_scans4]\n\n    metric4 = np.max(np.abs(x_A - x_B))\n    results.append(metric4)\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在建立了分析模型之后，我们必须考虑数据采集本身的物理局限性。这个思想实验探讨了 fMRI 相对较慢的采样率（重复时间，即 $T_R$）如何可能导致我们完全错过短暂的神经生理现象，例如血流动力学响应函数（HRF）中假设存在的“初始下降” ()。该练习强调了生理事件的持续时间与测量工具时间分辨率之间的关键关系，这是理解实验设计约束的核心。",
            "id": "4178474",
            "problem": "在血流动力学响应函数 (HRF) $h(t)$ 中，有一个被称为初始下降的短暂负向偏转，假设它在刺激开始后立即发生并持续一段有限的时间。考虑在时间 $t=0$ 时有一个脉冲刺激，并假设初始下降是 $h(t)$ 在区间 $[0,\\Delta]$ 上的一个严格为负的部分，其中 $\\Delta=1\\,\\text{s}$。功能性磁共振成像 (fMRI) 数据是在离散的采样时间点上采集的，这些时间点由重复时间 (TR) 分隔，记为 $T_R=2\\,\\text{s}$。设采样时间为 $t_k=\\phi+kT_R$，其中整数 $k\\geq 0$，相位 $\\phi$ 是刺激开始后的第一个采集时间与刺激开始本身之间的未知偏移量。假设由于刺激开始与扫描仪采集之间的同步不受控制，$\\phi$ 在 $[0,T_R)$ 上均匀分布。\n\n定义初始下降被“捕获”的事件为：存在至少一个 $k\\geq 0$ 使得 $t_k\\in[0,\\Delta]$。否则，初始下降仅因采样相位而被“错过”。从连续时间过程的离散时间采样和均匀相位模型的基本原理出发，推导在这种采集方案下是否可以可靠地检测到初始下降，并计算仅因采样相位而错过初始下降的概率。将最终概率表示为分数。无需四舍五入。",
            "solution": "首先验证问题，以确保其科学上成立、适定且客观。\n\n### 步骤 1：提取已知条件\n-   血流动力学响应函数 (HRF) 记为 $h(t)$。\n-   一个脉冲刺激发生在时间 $t=0$。\n-   $h(t)$ 中的初始下降是在区间 $[0, \\Delta]$ 上的一个严格为负的部分。\n-   初始下降的持续时间为 $\\Delta=1\\,\\text{s}$。\n-   fMRI 数据采集的重复时间为 $T_R=2\\,\\text{s}$。\n-   离散采样时间为 $t_k = \\phi + k T_R$，其中整数 $k \\geq 0$。\n-   采样相位 $\\phi$ 是在区间 $[0, T_R)$ 上均匀分布的随机变量。\n-   “捕获”事件定义为：存在至少一个整数 $k \\geq 0$，使得采样时间 $t_k$ 落在初始下降的区间内，即 $t_k \\in [0, \\Delta]$。\n-   “错过”事件是“捕获”事件的补集。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学上成立**：该问题在神经科学数据分析领域，特别是功能性磁共振成像 (fMRI) 领域，有充分的依据。HRF、其初始下降、重复时间 ($T_R$) 以及采样相位 ($\\phi$) 的影响等概念，是理解 fMRI 信号特性的标准和基本内容。参数值 $\\Delta=1\\,\\text{s}$ 和 $T_R=2\\,\\text{s}$ 对于 fMRI 实验是符合实际的。\n-   **适定性**：该问题在数学上是适定的。变量和参数定义清晰。随机变量 $\\phi$ 有明确的概率分布。“捕获”和“错过”事件的定义明确，可以计算出唯一的概率。\n-   **客观性**：问题以精确、客观的语言陈述，没有主观论断或含糊之处。\n\n### 步骤 3：结论与行动\n该问题是有效的，因为它在科学上成立、适定且客观。将推导解答。\n\n### 推导\n目标是计算初始下降被“错过”的概率。这是指没有采样时间 $t_k$ 落在区间 $[0, \\Delta]$ 内的概率。采样时间由序列 $t_k = \\phi + k T_R$ 给出，其中 $k$ 为非负整数，$\\phi$ 是在 $[0, T_R)$ 上均匀分布的随机变量。\n\n如果存在至少一个 $k \\ge 0$ 使得 $t_k \\in [0, \\Delta]$，“捕获”事件就会发生。这个条件可以写成：\n$$0 \\le \\phi + k T_R \\le \\Delta$$\n\n“错过”事件是其补集，意味着对于所有 $k \\ge 0$，都有 $t_k \\notin [0, \\Delta]$。我们要求解 $P(\\text{错过})$。通常计算补集事件的概率 $P(\\text{捕获})$ 会更简单，然后利用关系式 $P(\\text{错过}) = 1 - P(\\text{捕获})$。\n\n我们来分析对于不同 $k$ 值，条件 $0 \\le \\phi + k T_R \\le \\Delta$ 的情况。\n\n情况 1：$k=0$\n采样时间为 $t_0 = \\phi$。在该时间点捕获初始下降的条件是 $0 \\le \\phi \\le \\Delta$。由于 $\\phi$ 的定义域是 $[0, T_R)$，并且给定 $\\Delta = 1\\,\\text{s}$ 和 $T_R = 2\\,\\text{s}$，因此 $\\Delta  T_R$，这是一个可能的结果。如果在 $t_0$ 时捕获到初始下降，则有 $\\phi \\in [0, \\Delta]$。\n\n情况 2：$k \\ge 1$\n采样时间为 $t_k = \\phi + k T_R$，其中 $k=1, 2, 3, \\ldots$。捕获初始下降的条件是 $0 \\le \\phi + k T_R \\le \\Delta$。\n由于 $\\phi \\in [0, T_R)$，我们知道 $\\phi \\ge 0$。此外，由于 $k \\ge 1$ 且 $T_R>0$，项 $k T_R$ 是正数。因此，下界 $0 \\le \\phi + k T_R$ 总是满足的。\n该条件的关键部分是上界：\n$$\\phi + k T_R \\le \\Delta$$\n对 $\\phi$ 进行整理，我们得到：\n$$\\phi \\le \\Delta - k T_R$$\n代入给定值 $\\Delta=1$ 和 $T_R=2$：\n$$\\phi \\le 1 - 2k$$\n现在我们对 $k \\ge 1$ 的情况进行检验：\n-   当 $k=1$ 时：$\\phi \\le 1 - 2(1) = -1$。\n-   当 $k=2$ 时：$\\phi \\le 1 - 2(2) = -3$。\n-   对于任何整数 $k \\ge 1$，值 $1 - 2k$ 都是一个负数。\n\n然而，随机变量 $\\phi$ 定义在区间 $[0, T_R) = [0, 2)$ 上，这意味着 $\\phi$ 只能取非负值。在其定义域 $[0, 2)$ 内，没有 $\\phi$ 的值可以满足条件 $\\phi \\le \\text{负数}$。\n因此，任何 $k \\ge 1$ 的采样时间 $t_k$ 都不可能落在区间 $[0, \\Delta]$ 内。\n\n该分析表明，初始下降能被捕获的充要条件是第一个样本 $t_0$ 落在区间 $[0, \\Delta]$ 内。所有后续样本必然会在初始下降结束后发生。\n因此，“捕获”事件等价于事件 $\\{t_0 \\in [0, \\Delta]\\}$，而这又等价于 $\\{\\phi \\in [0, \\Delta]\\}$。\n“错过”事件等价于事件 $\\{t_0 \\notin [0, \\Delta]\\}$，考虑到 $\\phi \\in [0, T_R)$，这等价于 $\\{\\phi \\in (\\Delta, T_R)\\}$。\n\n现在我们可以直接计算“错过”事件的概率。变量 $\\phi$ 在 $[0, T_R)$ 上均匀分布。$\\phi$ 落入某个子区间的概率是该子区间的长度与总区间 $[0, T_R)$ 长度之比。\n\n$\\phi$ 可能取值的总区间长度为 $L_{总} = T_R - 0 = T_R$。\n“错过”事件对应于 $\\phi$ 位于子区间 $(\\Delta, T_R)$。该子区间的长度为 $L_{错过} = T_R - \\Delta$。\n\n错过初始下降的概率是：\n$$P(\\text{错过}) = \\frac{L_{错过}}{L_{总}} = \\frac{T_R - \\Delta}{T_R} = 1 - \\frac{\\Delta}{T_R}$$\n\n代入给定的数值 $\\Delta = 1\\,\\text{s}$ 和 $T_R = 2\\,\\text{s}$：\n$$P(\\text{错过}) = 1 - \\frac{1\\,\\text{s}}{2\\,\\text{s}} = 1 - \\frac{1}{2} = \\frac{1}{2}$$\n\n问题还问到初始下降是否可以被“可靠地检测”。由于随机采样相位，完全错过该事件的概率为 $1/2$，这意味着在 $50\\%$ 的情况下，在初始下降期间不会采集到任何数据点。一种纯粹因为偶然性而有一半几率失败的检测方法不能被认为是可靠的。因此，在这种采集方案下，初始下降无法被可靠地检测到。\n\n最终计算出的值是错过初始下降的概率。",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "最后，我们来探讨一个更深层次的、存在于数学模型内部的局限性。这个模拟练习旨在揭示参数混淆（parameter confounding）的概念，即不同的血流动力学响应函数（HRF）参数组合可以产生几乎无法区分的响应曲线 ()。通过这个练习，你将直观地认识到模型解释能力的认知边界，并学会在解释模型拟合参数时持一种审慎的态度。",
            "id": "4178455",
            "problem": "您将实现一个基于原则的模拟，在模拟血流动力学响应函数（HRF）的背景下，以展示从血氧水平依赖（BOLD）数据中恢复参数的不可辨识性。血流动力学响应函数（HRF）是一种因果脉冲响应，它在映射近似为线性时不变的假设下，将潜在的神经活动映射到功能性磁共振成像（fMRI）中观测到的BOLD波动。您的程序必须使用差分伽马模型来模拟HRF，并计算能够揭示参数恢复认知极限的量化指标。\n\n基本原理。从神经驱动到BOLD信号的映射被建模为一个线性时不变系统，其中BOLD信号是潜在神经时间过程与HRF的卷积。HRF被建模为两个伽马密度函数的差，这是fMRI分析中一种广泛使用并得到经验支持的形式。对于形状参数 $k$ 和尺度参数 $\\theta$，在时间 $t \\ge 0$ 处评估的伽马密度为\n$$\ng(t; k, \\theta) = \\frac{t^{k - 1} e^{-t/\\theta}}{\\Gamma(k) \\, \\theta^{k}},\n$$\n其中 $\\Gamma(k)$ 是欧拉伽马函数。差分伽马HRF定义为\n$$\nh(t; k_1, \\theta_1, k_2, \\theta_2, c, s) = s \\left( g(t; k_1, \\theta_1) - c \\, g(t; k_2, \\theta_2) \\right),\n$$\n其中 $k_1 > 0$, $k_2 > 0$, $\\theta_1 > 0$, $\\theta_2 > 0$, $c > 0$ 且 $s > 0$。参数 $c$ 控制刺激后下冲的相对权重，而 $s$ 是一个全局振幅缩放因子。\n\n数值网格。在一个均匀网格 $t_n = n \\Delta t$（$n = 0, 1, \\dots, N$，$t_N = T_{\\max}$）上计算HRF，其中 $\\Delta t$ 是采样步长，$T_{\\max}$ 是最大时间跨度。您还需要在一个更粗糙的网格上计算一个离散化版本，其采样间隔等于fMRI采集中使用的重复时间 $TR$。\n\n指标。对于每个测试用例，给定两个参数集 $\\Theta_A$ 和 $\\Theta_B$，计算三个指标：\n1. 在对 $h_B(t)$ 进行最优全局振幅重缩放后，$h_A(t)$ 和 $h_B(t)$ 之间的最小归一化均方根误差 (NRMSE)：\n   - 首先计算使下式最小化的 $\\alpha^\\star$\n   $$\n   J(\\alpha) = \\sum_{n=0}^{N} \\left( h_A(t_n) - \\alpha \\, h_B(t_n) \\right)^2,\n   $$\n   其由下式给出\n   $$\n   \\alpha^\\star = \\frac{\\sum_{n=0}^{N} h_A(t_n) h_B(t_n)}{\\sum_{n=0}^{N} h_B(t_n)^2}.\n   $$\n   - 然后计算NRMSE\n   $$\n   \\mathrm{NRMSE} = \\sqrt{ \\frac{ \\sum_{n=0}^{N} \\left( h_A(t_n) - \\alpha^\\star h_B(t_n) \\right)^2 }{ \\sum_{n=0}^{N} h_A(t_n)^2 } }.\n   $$\n   该指标是无量纲的，用于评估在排除全局振幅差异影响下的形状相似性。\n2. $h_A(t)$ 和 $h_B(t)$ 之间的峰值时间（TTP）的绝对差，定义为\n   $$\n   \\Delta \\mathrm{TTP} = \\left| t^{\\mathrm{peak}}_A - t^{\\mathrm{peak}}_B \\right|,\n   $$\n   其中 $t^{\\mathrm{peak}}$ 是 $h(t_n)$ 在网格上达到其最大值时的时间 $t_n$。以秒为单位表示 $\\Delta \\mathrm{TTP}$。\n3. 粗糙样本 $\\{ h_A(m \\cdot TR) \\}_{m}$ 和 $\\{ h_B(m \\cdot TR) \\}_{m}$ 之间的皮尔逊相关系数：\n   $$\n   \\rho = \\frac{ \\sum_{m} \\left( h_A(m \\cdot TR) - \\overline{h_A} \\right) \\left( h_B(m \\cdot TR) - \\overline{h_B} \\right) }{ \\sqrt{ \\sum_{m} \\left( h_A(m \\cdot TR) - \\overline{h_A} \\right)^2 } \\sqrt{ \\sum_{m} \\left( h_B(m \\cdot TR) - \\overline{h_B} \\right)^2 } },\n   $$\n   其中 $\\overline{h_A}$ 和 $\\overline{h_B}$ 表示在粗糙网格上的样本均值。该指标是无量纲的。\n\n时间单位。报告峰值时间差时，请以秒为单位表示答案。不使用角度。不得使用百分比；所有比率必须是十进制值。\n\n测试套件。使用以下三个案例来揭示认知极限的不同方面：\n\n- 案例 A（理想情况：仅振幅简并）。设 $T_{\\max} = 32$ 秒，$\\Delta t = 0.1$ 秒，$TR = 2.0$ 秒。定义\n  $$\n  \\Theta_A = (k_1 = 6, \\theta_1 = 1, k_2 = 12, \\theta_2 = 1, c = 0.35, s = 1.0),\n  $$\n  $$\n  \\Theta_B = (k_1 = 6, \\theta_1 = 1, k_2 = 12, \\theta_2 = 1, c = 0.35, s = 1.5).\n  $$\n  这些集合仅在振幅 $s$ 上有所不同，而在全局重缩放下是不可辨识的。\n- 案例 B（通过上升和弥散的权衡实现近似形状简并）。设 $T_{\\max} = 32$ 秒，$\\Delta t = 0.1$ 秒，$TR = 2.0$ 秒。定义\n  $$\n  \\Theta_A = (k_1 = 5, \\theta_1 = 1.2, k_2 = 14, \\theta_2 = 1.0, c = 0.34, s = 1.0),\n  $$\n  $$\n  \\Theta_B = (k_1 = 4.5, \\theta_1 = 1.33, k_2 = 13.5, \\theta_2 = 1.04, c = 0.32, s = 1.03).\n  $$\n  这些集合被设计为在每个伽马分量上具有相似的有效均值 $k \\theta$，同时扰动弥散和下冲比率，从而在实践中产生几乎相同的 $h(t)$ 曲线。\n- 案例 C（边缘情况：粗糙采样降低可区分性）。设 $T_{\\max} = 32$ 秒，$\\Delta t = 0.1$ 秒，$TR = 3.0$ 秒。定义\n  $$\n  \\Theta_A = (k_1 = 3, \\theta_1 = 1.8, k_2 = 7, \\theta_2 = 1.8, c = 0.35, s = 1.0),\n  $$\n  $$\n  \\Theta_B = (k_1 = 6, \\theta_1 = 0.9, k_2 = 12, \\theta_2 = 0.9, c = 0.35, s = 1.0).\n  $$\n  这些集合在时间尺度上有所不同，但在粗糙的 $TR$ 采样上可能看起来相似，这突显了由采集约束引起的认知极限。\n\n输出规范。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。具体来说，输出一个包含三个子列表的列表，每个案例对应一个子列表，每个子列表按顺序包含三个浮点值 $\\left[ \\mathrm{NRMSE}, \\Delta \\mathrm{TTP} \\text{ (秒)}, \\rho \\right]$。例如，输出可能如下所示\n$$\n\\left[ [0.000000, 0.000000, 1.000000], [0.023451, 0.400000, 0.997812], [0.083519, 1.500000, 0.982301] \\right].\n$$\n将所有浮点输出四舍五入到 $6$ 位小数。输出必须只包含指定格式的这一行。",
            "solution": "用户提供的问题陈述是有效的。它在科学上基于fMRI数据分析的原理，特别是使用线性时不变系统框架对血流动力学响应函数（HRF）进行建模。差分伽马HRF模型和量化指标（NRMSE, $\\Delta \\mathrm{TTP}$, $\\rho$）的数学定义是标准的且适定的。该问题是自包含的，为三个测试案例提供了所有必要的参数和条件。目标明确无歧义，可以得出一个唯一且可验证的数值解。\n\n解决方案首先实现核心数学模型，然后应用这些模型为每个测试用例计算指定的指标。整个过程被封装在一个遵循指定执行环境的Python程序中。\n\n1.  **血流动力学响应函数（HRF）模型实现**\n    模拟的基础是用于HRF的差分伽马模型。对于形状参数 $k > 0$ 和尺度参数 $\\theta > 0$ 的伽马概率密度函数 $g(t; k, \\theta)$ 定义如下：\n    $$\n    g(t; k, \\theta) = \\frac{t^{k - 1} e^{-t/\\theta}}{\\Gamma(k) \\, \\theta^{k}}, \\quad t \\ge 0\n    $$\n    其中 $\\Gamma(k)$ 是欧拉伽马函数，将使用 `scipy.special.gamma` 进行计算。实现了一个辅助函数，用于在离散时间向量 $t$ 上计算 $g(t; k, \\theta)$。对于 $t=0$ 这个点需要特别注意。由于测试用例中提供的所有形状参数 $k$ 都大于 $1$，因此 $g(0; k, \\theta) = 0$。实现通过仅对 $t > 0$ 的情况评估公式，并将 $t=0$ 处的值设为 $0$ 来处理此问题。\n\n    然后，HRF $h(t)$ 被构造为两个此类伽马函数的加权差：\n    $$\n    h(t; k_1, \\theta_1, k_2, \\theta_2, c, s) = s \\left( g(t; k_1, \\theta_1) - c \\, g(t; k_2, \\theta_2) \\right)\n    $$\n    另一个函数通过使用各自的参数 $(k_1, \\theta_1)$ 和 $(k_2, \\theta_2)$ 两次调用伽马PDF函数，然后根据公式使用下冲比率 $c$ 和全局缩放因子 $s$ 将它们组合起来，来实现此功能。\n\n2.  **数值网格生成**\n    对于每个测试用例，创建一个高分辨率时间网格，范围从 $t=0$ 到 $T_{\\max}$，步长为 $\\Delta t$。这个表示为 $\\{t_n\\}$ 的网格用于HRF形状的主要计算以及三个指标中的两个。该网格上的点数为 $N+1$，其中 $N = T_{\\max} / \\Delta t$。\n\n3.  **指标计算算法**\n    对于每对参数集 $\\Theta_A$ 和 $\\Theta_B$，在精细时间网格上生成相应的HRF $h_A(t)$ 和 $h_B(t)$。随后，计算三个指标以量化它们的相似性和差异。\n\n    -   **归一化均方根误差 (NRMSE)**：该指标评估 $h_A(t)$ 和 $h_B(t)$ 之间与全局振幅无关的形状相似性。首先，计算一个最优缩放因子 $\\alpha^\\star$ 以最小化 $h_A$ 和重缩放后的 $h_B$ 之间的平方误差。这是一个标准的线性最小二乘问题，其解由下式给出：\n        $$\n        \\alpha^\\star = \\frac{\\sum_{n=0}^{N} h_A(t_n) h_B(t_n)}{\\sum_{n=0}^{N} h_B(t_n)^2} = \\frac{\\mathbf{h}_A \\cdot \\mathbf{h}_B}{\\mathbf{h}_B \\cdot \\mathbf{h}_B}\n        $$\n        其中 $\\mathbf{h}_A$ 和 $\\mathbf{h}_B$ 是精细网格上HRF值的向量。然后，NRMSE是残差的均方根，通过 $\\mathbf{h}_A$ 的范数进行归一化：\n        $$\n        \\mathrm{NRMSE} = \\sqrt{ \\frac{ \\sum_{n=0}^{N} \\left( h_A(t_n) - \\alpha^\\star h_B(t_n) \\right)^2 }{ \\sum_{n=0}^{N} h_A(t_n)^2 } }\n        $$\n\n    -   **峰值时间差 ($\\Delta \\mathrm{TTP}$)**：该指标捕捉时间动态上的差异。每个HRF的峰值时间 $t^{\\mathrm{peak}}_A$ 和 $t^{\\mathrm{peak}}_B$ 是通过在精细离散网格上定位函数最大值的索引并检索相应的时间值来找到的。然后计算绝对差：\n        $$\n        \\Delta \\mathrm{TTP} = \\left| t^{\\mathrm{peak}}_A - t^{\\mathrm{peak}}_B \\right|\n        $$\n\n    -   **皮尔逊相关性 ($\\rho$)**: 该指标评估两个HRF之间的线性关系，但特别是在一个模拟fMRI采集时间分辨率的粗糙网格上进行。粗糙网格由重复时间 $TR$ 定义。通过在时间点 $m \\cdot TR$（其中 $m=0, 1, 2, \\dots$）选择数值，对HRF时间过程进行降采样。由于在所有测试用例中 $TR$ 都是 $\\Delta t$ 的整数倍，这可以通过步长为 $TR/\\Delta t$ 的简单数组切片来实现。然后计算这两个粗糙采样向量 $\\{h_A(m \\cdot TR)\\}_m$ 和 $\\{h_B(m \\cdot TR)\\}_m$ 之间的皮尔逊相关系数 $\\rho$。\n\n4.  **执行和输出格式化**\n    主程序逻辑遍历提供的三个测试用例。对于每个案例，它会解包网格参数（$T_{\\max}, \\Delta t, TR$）和两个HRF参数集（$\\Theta_A, \\Theta_B$）。它协调HRF曲线的生成和三个指标的计算。收集每个案例得到的浮点数三元组 $[\\mathrm{NRMSE}, \\Delta \\mathrm{TTP}, \\rho]$。最后，将所有案例的结果格式化为列表的列表形式的单个字符串，每个数值都四舍五入到6位小数，并根据问题规范打印到标准输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma as gamma_function\n\ndef gamma_pdf(t: np.ndarray, k: float, theta: float) - np.ndarray:\n    \"\"\"\n    Computes the Gamma probability density function.\n    \n    Args:\n        t (np.ndarray): Time vector.\n        k (float): Shape parameter.\n        theta (float): Scale parameter.\n        \n    Returns:\n        np.ndarray: The values of the Gamma PDF at times t.\n    \"\"\"\n    if k = 0 or theta = 0:\n        return np.zeros_like(t, dtype=float)\n\n    # For k  1 (as in this problem), g(0) = 0. For k=1, g(0)=1/theta. \n    # For k  1, g(0) is infinite.\n    # The current implementation is robust for k  0.\n    result = np.zeros_like(t, dtype=float)\n    \n    # Calculate for t  0 to avoid numerical issues like 0**negative_power if k  1.\n    mask = t  0\n    t_pos = t[mask]\n    \n    numerator = np.power(t_pos, k - 1) * np.exp(-t_pos / theta)\n    denominator = gamma_function(k) * np.power(theta, k)\n    \n    if denominator  0:\n        result[mask] = numerator / denominator\n        \n    return result\n\ndef hrf(t: np.ndarray, k1: float, theta1: float, k2: float, theta2: float, c: float, s: float) - np.ndarray:\n    \"\"\"\n    Computes the difference-of-gammas Hemodynamic Response Function (HRF).\n    \n    Args:\n        t (np.ndarray): Time vector.\n        k1, theta1: Parameters for the first gamma function.\n        k2, theta2: Parameters for the second gamma function.\n        c (float): Relative weight of the second gamma (undershoot).\n        s (float): Global amplitude scaling.\n        \n    Returns:\n        np.ndarray: The HRF evaluated at times t.\n    \"\"\"\n    g1 = gamma_pdf(t, k1, theta1)\n    g2 = gamma_pdf(t, k2, theta2)\n    return s * (g1 - c * g2)\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'label': 'Case A',\n            'T_max': 32.0, 'dt': 0.1, 'TR': 2.0,\n            'Theta_A': {'k1': 6.0, 'theta1': 1.0, 'k2': 12.0, 'theta2': 1.0, 'c': 0.35, 's': 1.0},\n            'Theta_B': {'k1': 6.0, 'theta1': 1.0, 'k2': 12.0, 'theta2': 1.0, 'c': 0.35, 's': 1.5}\n        },\n        {\n            'label': 'Case B',\n            'T_max': 32.0, 'dt': 0.1, 'TR': 2.0,\n            'Theta_A': {'k1': 5.0, 'theta1': 1.2, 'k2': 14.0, 'theta2': 1.0, 'c': 0.34, 's': 1.0},\n            'Theta_B': {'k1': 4.5, 'theta1': 1.33, 'k2': 13.5, 'theta2': 1.04, 'c': 0.32, 's': 1.03}\n        },\n        {\n            'label': 'Case C',\n            'T_max': 32.0, 'dt': 0.1, 'TR': 3.0,\n            'Theta_A': {'k1': 3.0, 'theta1': 1.8, 'k2': 7.0, 'theta2': 1.8, 'c': 0.35, 's': 1.0},\n            'Theta_B': {'k1': 6.0, 'theta1': 0.9, 'k2': 12.0, 'theta2': 0.9, 'c': 0.35, 's': 1.0}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        T_max, dt, TR = case['T_max'], case['dt'], case['TR']\n        \n        # 1. Generate time grid and HRFs\n        num_points = int(T_max / dt) + 1\n        t = np.linspace(0, T_max, num_points)\n        \n        h_A = hrf(t, **case['Theta_A'])\n        h_B = hrf(t, **case['Theta_B'])\n\n        # 2. Compute metrics\n        \n        # Metric 1: NRMSE\n        hA_dot_hB = np.dot(h_A, h_B)\n        hB_dot_hB = np.dot(h_B, h_B)\n        alpha_star = hA_dot_hB / hB_dot_hB if hB_dot_hB  0 else 0.0\n        \n        hA_dot_hA = np.dot(h_A, h_A)\n        residual_sq_sum = np.sum(np.power(h_A - alpha_star * h_B, 2))\n        nrmse = np.sqrt(residual_sq_sum / hA_dot_hA) if hA_dot_hA  0 else 0.0\n\n        # Metric 2: Delta TTP\n        t_peak_A = t[np.argmax(h_A)]\n        t_peak_B = t[np.argmax(h_B)]\n        delta_ttp = np.abs(t_peak_A - t_peak_B)\n\n        # Metric 3: Pearson Correlation on coarse grid\n        coarse_sample_step = int(round(TR / dt))\n        h_A_coarse = h_A[::coarse_sample_step]\n        h_B_coarse = h_B[::coarse_sample_step]\n        \n        # Ensure there are at least 2 points for correlation\n        if len(h_A_coarse)  2:\n            rho = np.nan # Undefined correlation\n        else:\n            correlation_matrix = np.corrcoef(h_A_coarse, h_B_coarse)\n            rho = correlation_matrix[0, 1]\n\n        all_results.append([nrmse, delta_ttp, rho])\n\n    # 3. Format and print output\n    formatted_case_results = []\n    for R in all_results:\n        # Format each triplet [nrmse, dttp, rho] with 6 decimal places\n        formatted_case_results.append(f\"[{R[0]:.6f},{R[1]:.6f},{R[2]:.6f}]\")\n    \n    final_output_string = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}