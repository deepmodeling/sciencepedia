{
    "hands_on_practices": [
        {
            "introduction": "在功能性磁共振成像（fMRI）分析中，一个核心任务是将连续的生理过程与离散的扫描数据联系起来。本练习旨在通过从第一性原理出发，推导离散时间卷积模型，来巩固您对这一过程的理解。通过将连续时间卷积积分近似为黎曼和，您将亲手构建在fMRI分析软件中广泛使用的离散卷积公式，并明确离散和连续血流动力学响应函数（HRF）之间的关系。此外，本练习还通过一个具体的计算任务 ，揭示了在采样率（即重复时间 $TR$）不足以捕捉HRF最快动态时，奈奎斯特采样定理被违反，从而产生“混叠”（aliasing）这一关键问题。",
            "id": "4178405",
            "problem": "一种对功能性磁共振成像中的血氧水平依赖（BOLD）信号进行建模的常用方法是将神经血管通路视为一个线性时不变（LTI）系统，其输出是刺激时间进程与血流动力学响应函数（HRF）之间的卷积。设连续时间刺激为 $x(t)$，连续时间HRF为 $h(t)$，BOLD输出 $y(t)$ 被建模为因果卷积。扫描仪的测量是通过以重复时间（TR）$\\Delta$秒进行均匀采样获得的，从而产生离散时间序列 $y[n] = y(n\\Delta)$。\n\n从因果连续时间卷积模型和以TR $\\Delta$进行均匀采样的定义出发，通过对连续时间卷积进行适当的黎曼和近似，推导出离散时间卷积形式 $y[n] = \\sum_{k=0}^{K-1} h[k]\\,x[n-k]$。明确说明离散化步长、离散时间序列 $\\{h[k]\\}$ 与连续时间函数 $h(t)$ 之间的关系，并用 $h(t)$ 的有效支撑长度和 $\\Delta$ 来表示 $K$。\n\n考虑当HRF $h(t)$ 在超过以TR $\\Delta$ 采样所施加的奈奎斯特极限的频率上具有不可忽略的能量时发生的混叠现象。作为一个具体场景，假设 $h(t)$ 包含一个小编幅的阻尼振荡分量\n$$\nh_{\\text{fast}}(t) = \\alpha\\,\\exp(-\\beta t)\\,\\cos(2\\pi f_{0} t)\\,u(t),\n$$\n其中 $u(t)$ 是单位阶跃函数，$\\alpha$ 和 $\\beta$ 是正常数，且 $f_{0} = 0.9$ 赫兹。HRF以TR $\\Delta = 1.5$ 秒进行采样，并假设是理想采样，没有抗混叠预滤波。\n\n在这些条件下，确定采样后仅由频率 $f_{0}$ 处的 分量所导致的、将出现在采样序列中的混叠频率 $f_{\\text{alias}}$。请用赫兹（Hz）表示您的最终答案，并将结果四舍五入到四位有效数字。最终答案必须是一个实数。",
            "solution": "问题陈述经评估有效。它在科学上基于应用于fMRI数据分析的线性系统理论和数字信号处理原理。该问题提法恰当，为计算提供了所有必要的参数，并以客观、正式的语言陈述。没有矛盾、歧义或事实不准确之处。\n\n该问题包含两部分。第一部分是从连续时间卷积模型推导其离散时间对应形式。第二部分是混叠频率的具体计算。\n\n首先，我们推导离散时间卷积模型。BOLD信号 $y(t)$ 被建模为刺激 $x(t)$ 和血流动力学响应函数（HRF）$h(t)$ 的因果卷积。对于一个因果线性时不变（LTI）系统，这表示为：\n$$\ny(t) = (h * x)(t) = \\int_{0}^{\\infty} h(\\tau) x(t - \\tau) d\\tau\n$$\n积分下限为$0$，因为HRF是因果的，即当 $\\tau  0$ 时，$h(\\tau) = 0$。\n\n连续时间信号 $y(t)$ 以重复时间（TR）$\\Delta$ 为间隔进行均匀采样。这产生离散时间序列 $y[n] = y(n\\Delta)$。将 $t = n\\Delta$ 代入卷积积分，得到：\n$$\ny[n] = y(n\\Delta) = \\int_{0}^{\\infty} h(\\tau) x(n\\Delta - \\tau) d\\tau\n$$\n为了获得离散时间卷积和，我们使用黎曼和来近似该积分。我们将积分变量 $\\tau$ 以等于采样间隔 $\\Delta$ 的步长进行离散化，因此 $\\tau = k\\Delta$，其中整数 $k \\ge 0$。微分量 $d\\tau$ 被有限步长 $\\Delta$ 替代。因此，积分被近似为一个和式：\n$$\ny[n] \\approx \\sum_{k=0}^{\\infty} h(k\\Delta) x(n\\Delta - k\\Delta) \\Delta\n$$\n我们可以重新排列各项并定义离散时间序列。刺激被采样为 $x[m] = x(m\\Delta)$。将其代入和式中，得到：\n$$\ny[n] \\approx \\sum_{k=0}^{\\infty} \\left[ \\Delta \\cdot h(k\\Delta) \\right] x[n-k]\n$$\n这个表达式具有离散时间卷积的形式，$y[n] = \\sum_{k} h_{d}[k] x[n-k]$。通过比较，我们建立了离散时间HRF滤波器系数 $h[k]$ 和连续时间HRF $h(t)$ 之间的关系：\n$$\nh[k] = \\Delta \\cdot h(k\\Delta)\n$$\n因子 $\\Delta$ 是一个源于卷积积分的黎曼和近似的缩放项。\n\nHRF $h(t)$ 实际上是时间有限的。设其有效支撑长度为 $T_h$，意味着当 $t > T_h$ 时 $h(t) \\approx 0$。因此，当 $k\\Delta > T_h$ 或 $k > T_h/\\Delta$ 时，和式中的项可以忽略不计。和式可以在满足 $k \\le T_h/\\Delta$ 的最大整数 $k$ 处截断，即 $k_{max} = \\lfloor T_h/\\Delta \\rfloor$。求和的范围是从 $k=0$ 到 $k_{max}$。问题中使用 $K$ 表示离散HRF序列 $\\{h[k]\\}$ 中元素的数量，因此索引从 $k=0$ 到 $K-1$。所以，$K-1 = \\lfloor T_h/\\Delta \\rfloor$，这意味着 $K = \\lfloor T_h/\\Delta \\rfloor + 1$。推导到此完成。\n\n接下来，我们处理混叠的计算。以速率 $f_s$ 对连续时间信号进行采样会导致原始信号中的频率发生混叠。给定的采样间隔为 $\\Delta = 1.5$ 秒。采样频率 $f_s$ 是采样间隔的倒数：\n$$\nf_s = \\frac{1}{\\Delta} = \\frac{1}{1.5} = \\frac{2}{3} \\text{ Hz}\n$$\n奈奎斯特频率 $f_N$ 是采样频率的一半。它表示采样后可以被明确表示的最大频率。\n$$\nf_N = \\frac{f_s}{2} = \\frac{1}{2\\Delta} = \\frac{1}{2 \\times 1.5} = \\frac{1}{3} \\text{ Hz}\n$$\nHRF分量 $h_{\\text{fast}}(t)$ 包含一个余弦项 $\\cos(2\\pi f_0 t)$，其频率为 $f_0 = 0.9$ Hz。由于 $f_0 > f_N$ ($0.9 \\text{ Hz} > 1/3 \\approx 0.3333 \\text{ Hz}$)，该频率分量将会发生混叠。\n\n当一个信号被采样时，原始信号中的任何频率 $f$ 都变得与频率 $f \\pm k f_s$（其中 $k$ 为任意整数）无法区分。混叠频率 $f_{\\text{alias}}$ 是由这种现象产生的主混叠范围 $[0, f_N]$ 内的频率。它可以计算如下：\n$$\nf_{\\text{alias}} = |f_0 - k \\cdot f_s|\n$$\n其中整数 $k$ 的选择应使得到的 $f_{\\text{alias}}$ 落在范围 $[0, f_N]$ 内。我们需要找到一个整数 $k$ 使得 $|0.9 - k \\cdot (2/3)| \\le 1/3$。\n\n让我们测试 $k$ 的整数值：\n当 $k=0$ 时，频率为 $|0.9 - 0| = 0.9$ Hz，大于 $f_N$。\n当 $k=1$ 时，频率为：\n$$\nf_{\\text{alias}} = \\left| 0.9 - 1 \\cdot \\frac{2}{3} \\right| = \\left| \\frac{9}{10} - \\frac{2}{3} \\right| = \\left| \\frac{27 - 20}{30} \\right| = \\frac{7}{30} \\text{ Hz}\n$$\n让我们检查该值是否在范围 $[0, f_N]$ 内。\n$$\n\\frac{7}{30} \\approx 0.2333... \\text{ Hz}\n$$\n奈奎斯特频率为 $f_N = 1/3 \\approx 0.3333...$ Hz。由于 $0 \\le 7/30 \\le 1/3$，这是一个有效的混叠频率。\n\n对于 $k$ 的其他整数值，例如 $k=2$，我们得到 $|0.9 - 2 \\cdot (2/3)| = |0.9 - 4/3| = |-13/30| = 13/30 \\approx 0.4333$ Hz，这超出了范围 $[0, f_N]$。因此，$k=1$ 是正确的整数。\n\n混叠频率恰好是 $f_{\\text{alias}} = 7/30$ Hz。问题要求答案四舍五入到四位有效数字。\n$$\nf_{\\text{alias}} = 0.233333... \\text{ Hz} \\approx 0.2333 \\text{ Hz}\n$$",
            "answer": "$$\n\\boxed{0.2333}\n$$"
        },
        {
            "introduction": "在理解了从连续到离散的转换之后，下一步是将其应用于fMRI数据分析的核心工具——通用线性模型（GLM）中。本练习将指导您通过编程实践，为GLM构建设计矩阵 $X$。您将实现一个数值上稳健的卷积过程：首先在高时间分辨率上表示神经事件，然后将其与HRF基函数进行卷积，最后在扫描仪的采集时间点（$TR$）上进行采样 。这个过程不仅能加深您对理论的理解，还将让您掌握一项关键的实践技能，并揭示了为什么相比于在粗糙的 $TR$ 网格上直接进行卷积，高分辨率卷积后降采样的方法更为精确。",
            "id": "4149325",
            "problem": "您正在使用通用线性模型（General Linear Model, GLM）分析功能性磁共振成像（functional Magnetic Resonance Imaging, fMRI）时间序列，其中每个条件的神经元事件被建模为事件回归量，并与血流动力学响应函数（Hemodynamic Response Function, HRF）进行卷积。请从连续时间卷积和GLM的定义出发，推导并实现通过将事件回归量与HRF核进行卷积并在采集时间点上采样，来构建一个离散时间设计矩阵的过程。此外，请解释并实现一组基函数如何能够将HRF灵活地建模为基元素的线性组合。\n\n使用以下基础知识：\n- 离散样本的通用线性模型（GLM）定义为 $y[n] = \\sum_{j=1}^{p} X[n,j] \\,\\beta_j + \\varepsilon[n]$，其中 $y[n]$ 是在样本索引 $n$ 处的测量信号，$X[n,j]$ 是回归量（设计矩阵的列），$\\beta_j$ 是系数，$\\varepsilon[n]$ 是噪声。\n- 两个函数 $s(t)$ 和 $h(t)$ 的连续时间卷积定义为 $(s * h)(t) = \\int_{-\\infty}^{\\infty} s(\\tau)\\,h(t - \\tau)\\,d\\tau$。在此情境下，$s(t)$ 是事件回归量，$h(t)$ 是HRF。\n- 在采集时间点 $t_n = n\\,\\Delta$ 上的离散时间采样被建模为 $x[n] = (s * h)(t_n)$，其中 $\\Delta$ 是采样间隔（重复时间，Repetition Time, TR）。\n\n您必须使用一个在时间步长为 $\\delta t$ 的高分辨率时间网格上对卷积积分进行数值稳定的黎曼和（Riemann-sum）近似，来实现设计矩阵的构建，随后在采集时间点 $t_n = n\\,\\mathrm{TR}$ 进行采样。所有时间量必须以秒为单位处理，且答案必须尊重单位一致性。振幅是无量纲的。\n\n将条件 $c$ 的事件回归量 $s_c(t)$ 定义为单位振幅的箱型函数（boxcar functions）之和：\n$$\ns_c(t) = \\sum_{i=1}^{N_c} \\mathbf{1}\\{t \\in [o_{c,i},\\,o_{c,i} + d_{c,i})\\},\n$$\n其中 $o_{c,i}$ 是以秒为单位的起始时间，$d_{c,i}$ 是以秒为单位的持续时间，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。设计矩阵的每一列对应一对 $(c,k)$，其中 $c$ 索引条件，$k$ 索引HRF基函数。对于单个HRF $h(t)$，条件 $c$ 对应的列是 $x_c[n] = (s_c * h)(t_n)$。对于一组基函数 $\\{b_k(t)\\}_{k=1}^K$，使用列 $x_{c,k}[n] = (s_c * b_k)(t_n)$，这样灵活的HRF $h(t)$ 就可以表示为 $h(t) = \\sum_{k=1}^K \\alpha_k\\,b_k(t)$ 并通过GLM系数 $\\{\\alpha_k\\}$ 进行估计。\n\n为保证科学真实性和数值稳定性：\n- 通过在步长为 $\\delta t$（例如 $\\delta t = 0.1\\,\\mathrm{s}$）的高分辨率网格上进行黎曼和离散化来实现卷积，使用近似式 $(s * h)(t) \\approx \\delta t \\sum_{m} s(m\\,\\delta t)\\,h(t - m\\,\\delta t)$。\n- 通过设定当 $t  0$ 时 $h(t) = 0$ 来确保因果性，并将卷积截断至采集窗口 $[0, T)$，其中 $T$ 是总扫描时长（以秒为单位）。\n- 基函数必须是因果的，并且其支撑集在 $[0,\\infty)$ 上。对于本问题，使用双伽马（double-gamma）HRF作为标准基元素，并通过对标准元素进行固定延迟的时间平移来构建额外的基元素。具体来说，将标准HRF $b_1(t)$ 定义为\n$$\nb_1(t) = g(t; k_1, \\theta_1) - r\\,g(t; k_2, \\theta_2),\n$$\n其中 $g(t;k,\\theta) = \\frac{t^{k-1} e^{-t/\\theta}}{\\theta^k \\,\\Gamma(k)}$（当 $t \\ge 0$ 时）和 $g(t;k,\\theta) = 0$（当 $t  0$ 时），参数 $(k_1,\\theta_1)$ 和 $(k_2,\\theta_2)$ 在下面的测试套件中指定。令 $b_2(t) = b_1(t - \\delta_1)$ 和 $b_3(t) = b_1(t - \\delta_2)$，其中 $\\delta_1$ 和 $\\delta_2$ 是以秒为单位的固定延迟，并且当 $t  0$ 时 $b_k(t) = 0$。\n\n所有时间都以秒表示。不涉及任何角度。所有输出必须是无量纲的实数。\n\n实现一个程序，为每个测试用例构建设计矩阵并计算指定的标量诊断指标。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。每个测试用例的指标如下：\n\n- 测试用例 $1$（正常路径，单个HRF）：\n  - 参数：总扫描时长 $T = 60\\,\\mathrm{s}$，$\\mathrm{TR} = 2\\,\\mathrm{s}$，高分辨率步长 $\\delta t = 0.1\\,\\mathrm{s}$，条件数 $C = 2$。\n  - 条件 $1$：起始时间 $[0, 12, 24]\\,\\mathrm{s}$，持续时间 $[1, 1, 1]\\,\\mathrm{s}$。\n  - 条件 $2$：起始时间 $[6, 18, 30]\\,\\mathrm{s}$，持续时间 $[2, 2, 2]\\,\\mathrm{s}$。\n  - 标准HRF参数：$(k_1, \\theta_1) = (6, 1)$，$(k_2, \\theta_2) = (12, 1)$，比率 $r = 0.35$，HRF支撑集截断于 $L = 32\\,\\mathrm{s}$。\n  - 基：单个元素 $b_1(t)$。\n  - 指标：设计矩阵的弗罗贝尼乌斯范数（Frobenius norm），即 $\\|X\\|_F = \\sqrt{\\sum_{n,j} X[n,j]^2}$。\n\n- 测试用例 $2$（通过时间平移实现基的灵活性）：\n  - 参数：$T = 60\\,\\mathrm{s}$，$\\mathrm{TR} = 2\\,\\mathrm{s}$，$\\delta t = 0.1\\,\\mathrm{s}$，条件数 $C = 1$。\n  - 条件 $1$：起始时间 $[10, 20, 40]\\,\\mathrm{s}$，持续时间 $[0.5, 0.5, 0.5]\\,\\mathrm{s}$。\n  - 标准HRF $b_1(t)$ 与测试用例 $1$ 中相同，HRF支撑集 $L = 32\\,\\mathrm{s}$。\n  - 基：三个元素 $\\{b_1(t), b_1(t - \\delta_1), b_1(t - \\delta_2)\\}$，延迟为 $\\delta_1 = 1\\,\\mathrm{s}$，$\\delta_2 = 2\\,\\mathrm{s}$。\n  - 指标：$X$的最小奇异值，即 $\\min \\sigma_i(X)$。\n\n- 测试用例 $3$（接近扫描结束时的边界条件）：\n  - 参数：$T = 50\\,\\mathrm{s}$，$\\mathrm{TR} = 2\\,\\mathrm{s}$，$\\delta t = 0.1\\,\\mathrm{s}$，条件数 $C = 1$。\n  - 条件 $1$：起始时间 $[45]\\,\\mathrm{s}$，持续时间 $[2]\\,\\mathrm{s}$。\n  - 基：单个元素 $b_1(t)$，标准参数与测试用例 $1$ 中相同，HRF支撑集 $L = 32\\,\\mathrm{s}$。\n  - 指标：单列设计矩阵中最后 $5$ 个采样条目的总和，即 $\\sum_{n = N-5}^{N-1} X[n,1]$，其中 $N = T / \\mathrm{TR}$。\n\n- 测试用例 $4$（粗糙采样下的混叠，两种卷积方案的比较）：\n  - 参数：$T = 64\\,\\mathrm{s}$，$\\mathrm{TR} = 4\\,\\mathrm{s}$，高分辨率步长 $\\delta t = 0.1\\,\\mathrm{s}$，条件数 $C = 1$。\n  - 条件 $1$：起始时间 $[0, 8, 16, 24, 32, 40, 48, 56]\\,\\mathrm{s}$，持续时间 $[1, 1, 1, 1, 1, 1, 1, 1]\\,\\mathrm{s}$。\n  - 基：单个元素 $b_1(t)$，标准参数与测试用例 $1$ 中相同，HRF支撑集 $L = 32\\,\\mathrm{s}$。\n  - 计算两个设计列：\n    - 方法A（朴素的TR网格卷积）：构建 $s_{\\mathrm{TR}}[n] = \\mathbf{1}\\{[n\\,\\mathrm{TR}, (n+1)\\,\\mathrm{TR})$ 包含任何事件\\}，在TR网格上对 $b_1$ 进行采样得到 $h_{\\mathrm{TR}}[m] = b_1(m\\,\\mathrm{TR})$，然后计算离散卷积 $x_A[n] \\approx \\mathrm{TR}\\sum_{m} s_{\\mathrm{TR}}[m]\\,h_{\\mathrm{TR}}[n-m]$ 并截断至采集窗口。\n    - 方法B（高分辨率卷积后采样）：使用步长为 $\\delta t$ 的高分辨率黎曼和近似计算 $x_B[n] = (s * b_1)(n\\,\\mathrm{TR})$。\n  - 指标：最大绝对差异 $\\max_{0 \\le n  N} |x_A[n] - x_B[n]|$，其中 $N = T / \\mathrm{TR}$。\n\n您的程序应生成单行输出，其中包含按测试用例1、测试用例2、测试用例3和测试用例4的顺序排列的、用方括号括起来的逗号分隔的结果列表，即“[r1,r2,r3,r4]”。所有数值输出必须是无量纲的实值浮点数。不应打印任何额外文本。",
            "solution": "该问题要求在fMRI数据分析的背景下，推导并实现一种为通用线性模型（General Linear Model, GLM）构建设计矩阵的方法。此过程涉及将神经活动建模为事件回归量，将其与血流动力学响应函数（Hemodynamic Response Function, HRF）或一组HRF基函数进行卷积，并在fMRI采集时间点对结果进行采样。\n\n分析的基础是GLM，它将在离散采样点 $n$ 观测到的fMRI时间序列 $y[n]$ 建模为预测变量的线性组合。该模型由下式给出：\n$$\ny[n] = X \\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon} \\quad \\text{或分量形式} \\quad y[n] = \\sum_{j=1}^{p} X[n,j] \\,\\beta_j + \\varepsilon[n]\n$$\n这里，$y[n]$ 是在第 $n$ 个采集时间点 $t_n = n \\cdot \\mathrm{TR}$ 的信号，其中 $\\mathrm{TR}$ 是重复时间（Repetition Time）。$X$ 是设计矩阵，其列是回归量。$\\boldsymbol{\\beta}$ 是待估计的系数向量，$\\boldsymbol{\\varepsilon}$ 代表噪声。核心任务是构建设计矩阵 $X$。\n\n底层的神经过程在连续时间 $t$ 上进行概念化。GLM中的一个回归量 $X[n, j]$ 代表由特定实验条件在时间 $t_n$ 引起的预测BOLD信号。该预测是通过将模拟神经活动的刺激函数 $s(t)$ 与模拟生理血管响应的血流动力学响应函数 $h(t)$ 进行卷积而生成的。连续时间卷积定义为：\n$$\n(s * h)(t) = \\int_{-\\infty}^{\\infty} s(\\tau)\\,h(t - \\tau)\\,d\\tau\n$$\n然后，采样后的回归量为 $x[n] = (s * h)(t_n)$。\n\n该过程可分解为以下步骤：\n\n1.  **时间离散化：**\n    为了数值化地执行卷积，我们必须从连续时间 $t$ 转换为离散表示。有两个时间网格是相关的：\n    a. 一个具有小时间步长 $\\delta t$（例如，$\\delta t = 0.1\\,\\mathrm{s}$）的高分辨率网格。该网格用于精确表示事件回归量和HRF的形状，并近似卷积积分。时间点为 $m\\,\\delta t$，其中 $m$ 为整数。\n    b. 采集网格（或TR网格），其时间步长等于扫描仪的重复时间 $\\mathrm{TR}$（例如，$\\mathrm{TR} = 2\\,\\mathrm{s}$）。最终的设计矩阵定义在该网格上，时间点为 $t_n = n\\,\\mathrm{TR}$。\n\n2.  **在高分辨率网格上构建事件回归量：**\n    对于每个实验条件 $c$，事件回归量 $s_c(t)$ 被定义为一系列箱型函数：\n    $$\n    s_c(t) = \\sum_{i=1}^{N_c} \\mathbf{1}\\{t \\in [o_{c,i},\\,o_{c,i} + d_{c,i})\\}\n    $$\n    其中 $\\{o_{c,i}\\}$ 是事件的起始时间，$\\{d_{c,i}\\}$ 是事件的持续时间。这个连续函数在高分辨率网格上进行离散化。对于该网格上的每个时间点 $m\\,\\delta t$，我们计算 $s_c(m\\,\\delta t)$，创建一个向量 $s_c[m]$。如果 $m\\,\\delta t$ 落在条件 $c$ 的任何事件窗口内，则该向量的值为 $1$，否则为 $0$。\n\n3.  **构建HRF基核：**\n    问题指定了一组基函数 $\\{b_k(t)\\}$ 来灵活地建模HRF。标准基函数 $b_1(t)$ 是双伽马函数：\n    $$\n    b_1(t) = g(t; k_1, \\theta_1) - r\\,g(t; k_2, \\theta_2) \\quad \\text{对于 } t \\ge 0\n    $$\n    其中 $g(t;k,\\theta) = \\frac{t^{k-1} e^{-t/\\theta}}{\\theta^k \\,\\Gamma(k)}$ 是经过缩放的伽马分布的概率密度函数。函数 $\\Gamma(k)$ 是伽马函数。此函数以及由它衍生的任何其他基元素（例如 $b_2(t) = b_1(t - \\delta_1)$）都在高分辨率网格上进行评估。由于因果性，$b_k(t) = 0$ 对所有 $t  0$ 成立。我们为每个基函数创建离散核 $b_k[m] = b_k(m\\,\\delta t)$。这些核在指定的支撑长度 $L$ 处被截断。\n\n4.  **数值卷积：**\n    连续卷积积分通过使用黎曼和在高分辨率网格上进行离散卷积来近似。对于给定的时间 $t_j = j\\,\\delta t$：\n    $$\n    (s_c * b_k)(t_j) = \\int_0^{t_j} s_c(\\tau)\\,b_k(t_j - \\tau)\\,d\\tau \\approx \\sum_{m=0}^{j} s_c(m\\,\\delta t)\\,b_k(t_j - m\\,\\delta t) \\,\\delta t\n    $$\n    积分限反映了因果性（对于 $\\tau0$，$s_c(\\tau)=0$；对于 $\\tau>t_j$，$b_k(t_j - \\tau)=0$）。表达式 $\\sum_{m=0}^{j} s_c[m]\\,b_k[j-m]$ 是一个标准的离散时间卷积。执行此卷积后，结果乘以 $\\delta t$ 以正确逼近积分值。这样就在高分辨率时间网格上得到了预测的BOLD响应。\n\n5.  **在采集时间点采样：**\n    必须在采集时间点 $t_n = n\\,\\mathrm{TR}$ 对高分辨率的预测BOLD信号进行采样，以形成设计矩阵 $X$ 的列。设高分辨率卷积信号为 $x^{\\text{high-res}}_{c,k}[m]$。最终的回归量列为：\n    $$\n    x_{c,k}[n] = x^{\\text{high-res}}_{c,k}[m] \\quad \\text{其中} \\quad m\\,\\delta t = n\\,\\mathrm{TR}\n    $$\n    这实际上是一个降采样操作，我们从高分辨率信号中选择与TR时间点对应的值。\n\n6.  **组装设计矩阵：**\n    最终的设计矩阵 $X$ 是通过连接生成的回归量列 $x_{c,k}[n]$ 而形成的。每一列对应一个唯一的条件 $c$ 和基函数 $k$ 的组合。$X$ 的行数等于扫描持续时间内的TR数量，即 $N = T/\\mathrm{TR}$。列数是回归量的总数，即（条件数）$\\times$（基函数数）。\n\n7.  **与朴素卷积的比较（测试用例4）：**\n    一种朴素的方法可能是将刺激 $s(t)$ 和HRF $h(t)$ 直接在粗糙的TR网格上离散化，并在此网格上执行卷积。这是问题描述中的方法A。具体来说，将通过检查区间 $[n\\,\\mathrm{TR}, (n+1)\\,\\mathrm{TR})$ 内是否发生任何刺激事件来创建 $s_{\\mathrm{TR}}[n]$，并创建 $h_{\\mathrm{TR}}[m] = h(m\\,\\mathrm{TR})$。然后计算离散卷积 $x_A[n] = \\mathrm{TR}\\sum_m s_{\\mathrm{TR}}[m]\\,h_{\\mathrm{TR}}[n-m]$。这种方法是有缺陷的，因为它模糊了刺激起始和持续时间的精确性，并且对HRF欠采样，导致混叠。高分辨率卷积后采样（方法B）是正确的方法，因为它在采样前尊重了信号的时间结构，这与采样定理一致。差异 $|x_A[n] - x_B[n]|$ 突显了朴素方法引入的误差。\n\n这个有原则的程序确保设计矩阵准确反映神经事件的时间和血流动力学响应的连续动态，为使用GLM进行统计推断提供了坚实的基础。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import convolve\nfrom scipy.special import gamma as gamma_func\n\ndef solve():\n    \"\"\"\n    Solves all four test cases for constructing an fMRI design matrix and computes the required metrics.\n    \"\"\"\n\n    def get_gamma_pdf(t, k, theta):\n        \"\"\"\n        Computes the value of the gamma distribution's PDF-like function g(t; k, theta).\n        \"\"\"\n        # Ensure t is non-negative for the formula to be valid\n        t_non_negative = np.maximum(t, 0)\n        # Avoid division by zero or log of zero for t=0 and k=1\n        with np.errstate(divide='ignore', invalid='ignore'):\n            val = (t_non_negative**(k - 1) * np.exp(-t_non_negative / theta)) / (theta**k * gamma_func(k))\n        val[t  0] = 0\n        val[np.isnan(val)] = 0 # Handle potential 0^0 issues when k=1 and t=0\n        return val\n\n    def get_double_gamma_hrf(t, k1, theta1, k2, theta2, r):\n        \"\"\"\n        Computes the double-gamma HRF.\n        \"\"\"\n        h = get_gamma_pdf(t, k1, theta1) - r * get_gamma_pdf(t, k2, theta2)\n        return h\n\n    def construct_design_matrix(T, TR, dt, conditions, basis_kernels):\n        \"\"\"\n        Constructs the design matrix using high-resolution convolution and TR sampling.\n        \"\"\"\n        num_scans = int(T / TR)\n        high_res_t = np.arange(0, T, dt)\n        num_high_res_points = len(high_res_t)\n\n        regressors = []\n\n        for cond_onsets, cond_durations in conditions:\n            # Create a high-resolution stimulus regressor\n            stim_hr = np.zeros(num_high_res_points)\n            for onset, duration in zip(cond_onsets, cond_durations):\n                start_idx = int(np.round(onset / dt))\n                end_idx = int(np.round((onset + duration) / dt))\n                stim_hr[start_idx:end_idx] = 1\n\n            for kernel in basis_kernels:\n                # Convolve stimulus with HRF kernel\n                # The convolution approximates the integral, so we must scale by dt.\n                convolved_hr = convolve(stim_hr, kernel, mode='full') * dt\n                \n                # Truncate to scan length\n                convolved_hr = convolved_hr[:num_high_res_points]\n\n                # Sample at TRs\n                sample_indices = (np.arange(num_scans) * TR / dt).astype(int)\n                \n                # Ensure indices are within bounds\n                valid_indices = sample_indices[sample_indices  len(convolved_hr)]\n                regressor = np.zeros(num_scans)\n                regressor[:len(valid_indices)] = convolved_hr[valid_indices]\n                \n                regressors.append(regressor)\n\n        # Handle the case of no regressors\n        if not regressors:\n            return np.zeros((num_scans, 0))\n\n        return np.column_stack(regressors)\n\n    results = []\n\n    # --- Test Case 1 ---\n    T1, TR1, dt1 = 60.0, 2.0, 0.1\n    conditions1 = [\n        (np.array([0, 12, 24]), np.array([1, 1, 1])),\n        (np.array([6, 18, 30]), np.array([2, 2, 2])),\n    ]\n    k1, theta1, k2, theta2, r = 6, 1, 12, 1, 0.35\n    L = 32.0\n    hrf_t_basis = np.arange(0, L, dt1)\n    \n    b1_kernel = get_double_gamma_hrf(hrf_t_basis, k1, theta1, k2, theta2, r)\n    basis_kernels1 = [b1_kernel]\n    \n    X1 = construct_design_matrix(T1, TR1, dt1, conditions1, basis_kernels1)\n    metric1 = np.linalg.norm(X1, 'fro')\n    results.append(metric1)\n\n    # --- Test Case 2 ---\n    T2, TR2, dt2 = 60.0, 2.0, 0.1\n    conditions2 = [\n        (np.array([10, 20, 40]), np.array([0.5, 0.5, 0.5])),\n    ]\n    delta1, delta2 = 1.0, 2.0\n\n    b1_t_shifted_0 = get_double_gamma_hrf(hrf_t_basis, k1, theta1, k2, theta2, r)\n    b1_t_shifted_1 = get_double_gamma_hrf(hrf_t_basis - delta1, k1, theta1, k2, theta2, r)\n    b1_t_shifted_2 = get_double_gamma_hrf(hrf_t_basis - delta2, k1, theta1, k2, theta2, r)\n    basis_kernels2 = [b1_t_shifted_0, b1_t_shifted_1, b1_t_shifted_2]\n\n    X2 = construct_design_matrix(T2, TR2, dt2, conditions2, basis_kernels2)\n    singular_values = np.linalg.svd(X2, compute_uv=False)\n    metric2 = singular_values.min() if singular_values.size  0 else 0.0\n    results.append(metric2)\n\n    # --- Test Case 3 ---\n    T3, TR3, dt3 = 50.0, 2.0, 0.1\n    conditions3 = [\n        (np.array([45]), np.array([2])),\n    ]\n    basis_kernels3 = [b1_kernel]\n\n    X3 = construct_design_matrix(T3, TR3, dt3, conditions3, basis_kernels3)\n    metric3 = np.sum(X3[-5:, 0]) if X3.shape[0] = 5 else np.sum(X3[:, 0])\n    results.append(metric3)\n\n    # --- Test Case 4 ---\n    T4, TR4, dt4 = 64.0, 4.0, 0.1\n    onsets4 = np.arange(0, 64, 8)\n    durations4 = np.ones_like(onsets4)\n    conditions4 = [(onsets4, durations4)]\n    basis_kernels4 = [b1_kernel]\n    num_scans4 = int(T4 / TR4)\n    tr_grid_t = np.arange(num_scans4) * TR4\n\n    # Method B (correct high-resolution)\n    X_B_matrix = construct_design_matrix(T4, TR4, dt4, conditions4, basis_kernels4)\n    x_B = X_B_matrix[:, 0]\n\n    # Method A (naïve TR-grid convolution)\n    s_tr = np.zeros(num_scans4)\n    for n in range(num_scans4):\n        tr_start, tr_end = n * TR4, (n + 1) * TR4\n        for onset, duration in zip(onsets4, durations4):\n            event_start, event_end = onset, onset + duration\n            if max(tr_start, event_start)  min(tr_end, event_end):\n                s_tr[n] = 1\n                break\n    \n    h_tr_t = np.arange(0, L, TR4)\n    h_tr = get_double_gamma_hrf(h_tr_t, k1, theta1, k2, theta2, r)\n\n    # Perform discrete convolution and scale by TR\n    x_A_full = convolve(s_tr, h_tr, mode='full') * TR4\n    x_A = x_A_full[:num_scans4]\n\n    metric4 = np.max(np.abs(x_A - x_B))\n    results.append(metric4)\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "即使我们能够精确地构建模型，我们能从数据中唯一地确定HRF的生理参数吗？本练习通过一个模拟任务，探讨了HRF建模中的一个深层问题：参数的非唯一性或不可识别性。您将实现一个“伽马函数差”模型，并计算比较两组不同参数集生成的HRF曲线，量化它们在形状、峰值时间等方面的相似性 。这项实践揭示了模型拟合的认知局限性——不同的参数组合（例如，幅度和宽度的权衡）可能产生几乎无法区分的预测信号，这提醒我们在解释模型参数的生理意义时必须保持审慎。",
            "id": "4178455",
            "problem": "您将实现一个基于原理的模拟，在建模血流动力学响应函数（HRF）的背景下，以展示从血氧水平依赖（BOLD）数据中恢复参数时的不可辨识性问题。血流动力学响应函数（HRF）是一种因果脉冲响应，在线性时不变的近似假设下，它将潜在的神经活动映射到功能性磁共振成像（fMRI）中观测到的BOLD信号波动。您的程序必须使用双伽马差模型来表示HRF，并计算能够揭示参数恢复认知极限的量化指标。\n\n基本原理。从神经驱动到BOLD信号的映射被建模为一个线性时不变系统，其中BOLD信号是潜在神经时间过程与HRF的卷积。HRF被建模为两个伽马密度函数之差，这是fMRI分析中一种被广泛使用并得到经验支持的形式。对于形状参数 $k$ 和尺度参数 $\\theta$，在时间 $t \\ge 0$ 处求值的伽马密度函数为\n$$\ng(t; k, \\theta) = \\frac{t^{k - 1} e^{-t/\\theta}}{\\Gamma(k) \\, \\theta^{k}},\n$$\n其中 $\\Gamma(k)$ 是欧拉伽马函数。双伽马差HRF定义为\n$$\nh(t; k_1, \\theta_1, k_2, \\theta_2, c, s) = s \\left( g(t; k_1, \\theta_1) - c \\, g(t; k_2, \\theta_2) \\right),\n$$\n其中 $k_1 \\gt 0$, $k_2 \\gt 0$, $\\theta_1 \\gt 0$, $\\theta_2 \\gt 0$, $c \\gt 0$ 且 $s \\gt 0$。参数 $c$ 控制刺激后下冲的相对权重，而 $s$ 是一个全局振幅缩放因子。\n\n数值网格。在一个均匀网格 $t_n = n \\Delta t$（$n = 0, 1, \\dots, N$，$t_N = T_{\\max}$）上计算HRF，其中 $\\Delta t$ 是采样步长，$T_{\\max}$ 是最大时间跨度。您还需要在一个更粗糙的网格上计算一个离散化版本，其采样间隔等于fMRI采集中使用的重复时间 $TR$。\n\n度量指标。对于每个测试用例，给定两组参数集 $\\Theta_A$ 和 $\\Theta_B$，计算三个度量指标：\n1. 在对 $h_B(t)$ 进行最优全局振幅重缩放后，$h_A(t)$ 和 $h_B(t)$ 之间的最小归一化均方根误差 (NRMSE)：\n   - 首先计算使下式最小化的 $\\alpha^\\star$：\n   $$\n   J(\\alpha) = \\sum_{n=0}^{N} \\left( h_A(t_n) - \\alpha \\, h_B(t_n) \\right)^2,\n   $$\n   其解为\n   $$\n   \\alpha^\\star = \\frac{\\sum_{n=0}^{N} h_A(t_n) h_B(t_n)}{\\sum_{n=0}^{N} h_B(t_n)^2}.\n   $$\n   - 然后计算NRMSE\n   $$\n   \\mathrm{NRMSE} = \\sqrt{ \\frac{ \\sum_{n=0}^{N} \\left( h_A(t_n) - \\alpha^\\star h_B(t_n) \\right)^2 }{ \\sum_{n=0}^{N} h_A(t_n)^2 } }.\n   $$\n   该指标是无量纲的，用于评估在排除全局振幅差异影响下的形状相似性。\n2. $h_A(t)$ 和 $h_B(t)$ 之间的峰值时间（TTP）绝对差，定义为\n   $$\n   \\Delta \\mathrm{TTP} = \\left| t^{\\mathrm{peak}}_A - t^{\\mathrm{peak}}_B \\right|,\n   $$\n   其中 $t^{\\mathrm{peak}}$ 是 $h(t_n)$ 在网格上达到其最大值时的时间 $t_n$。以秒为单位表示 $\\Delta \\mathrm{TTP}$。\n3. 粗采样样本 $\\{ h_A(m \\cdot TR) \\}_{m}$ 和 $\\{ h_B(m \\cdot TR) \\}_{m}$ 之间的皮尔逊相关系数：\n   $$\n   \\rho = \\frac{ \\sum_{m} \\left( h_A(m \\cdot TR) - \\overline{h_A} \\right) \\left( h_B(m \\cdot TR) - \\overline{h_B} \\right) }{ \\sqrt{ \\sum_{m} \\left( h_A(m \\cdot TR) - \\overline{h_A} \\right)^2 } \\sqrt{ \\sum_{m} \\left( h_B(m \\cdot TR) - \\overline{h_B} \\right)^2 } },\n   $$\n   其中 $\\overline{h_A}$ 和 $\\overline{h_B}$ 表示在粗糙网格上的样本均值。该指标是无量纲的。\n\n时间单位。报告峰值时间差时，请以秒为单位表示。不使用角度。不得使用百分比；所有比率必须是十进制值。\n\n测试套件。使用以下三个案例来揭示认知极限的不同方面：\n\n- 案例 A（理想情况：仅振幅简并）。设 $T_{\\max} = 32$ 秒，$\\Delta t = 0.1$ 秒，$TR = 2.0$ 秒。定义\n  $$\n  \\Theta_A = (k_1 = 6, \\theta_1 = 1, k_2 = 12, \\theta_2 = 1, c = 0.35, s = 1.0),\n  $$\n  $$\n  \\Theta_B = (k_1 = 6, \\theta_1 = 1, k_2 = 12, \\theta_2 = 1, c = 0.35, s = 1.5).\n  $$\n  这两组参数仅在振幅 $s$ 上有所不同，而在全局重缩放下，该参数是不可辨识的。\n- 案例 B（通过上升和离散的权衡实现近似形状简并）。设 $T_{\\max} = 32$ 秒，$\\Delta t = 0.1$ 秒，$TR = 2.0$ 秒。定义\n  $$\n  \\Theta_A = (k_1 = 5, \\theta_1 = 1.2, k_2 = 14, \\theta_2 = 1.0, c = 0.34, s = 1.0),\n  $$\n  $$\n  \\Theta_B = (k_1 = 4.5, \\theta_1 = 1.33, k_2 = 13.5, \\theta_2 = 1.04, c = 0.32, s = 1.03).\n  $$\n  这些参数集被设计为在扰动离散度和下冲比率的同时，使每个伽马分量的有效均值 $k \\theta$ 相似，从而在实践中产生几乎相同的 $h(t)$ 曲线。\n- 案例 C（边缘情况：粗采样降低可区分性）。设 $T_{\\max} = 32$ 秒，$\\Delta t = 0.1$ 秒，$TR = 3.0$ 秒。定义\n  $$\n  \\Theta_A = (k_1 = 3, \\theta_1 = 1.8, k_2 = 7, \\theta_2 = 1.8, c = 0.35, s = 1.0),\n  $$\n  $$\n  \\Theta_B = (k_1 = 6, \\theta_1 = 0.9, k_2 = 12, \\theta_2 = 0.9, c = 0.35, s = 1.0).\n  $$\n  这些参数集在时间尺度上有所不同，但在粗糙的 $TR$ 采样下可能看起来相似，这凸显了由采集约束引起的认知极限。\n\n输出规范。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。具体来说，输出一个包含三个子列表的列表，每个子列表对应一个案例，其中每个子列表按顺序包含三个浮点值：$\\left[ \\mathrm{NRMSE}, \\Delta \\mathrm{TTP} \\text{（单位：秒）}, \\rho \\right]$。例如，输出可能如下所示：\n$$\n\\left[ [0.000000, 0.000000, 1.000000], [0.023451, 0.400000, 0.997812], [0.083519, 1.500000, 0.982301] \\right].\n$$\n将所有浮点输出四舍五入到 $6$ 位小数。输出必须只包含此指定格式的单行内容。",
            "solution": "用户提供的问题陈述是有效的。它在科学上植根于fMRI数据分析的原理，特别是使用线性时不变系统框架对血流动力学响应函数（HRF）进行建模。双伽马差HRF模型和量化指标（NRMSE、$\\Delta \\mathrm{TTP}$、$\\rho$）的数学定义是标准且适定的。问题是自包含的，为三个测试用例提供了所有必要的参数和条件。目标清晰明确，可以导出一个唯一且可验证的数值解。\n\n解决方案的步骤是首先实现核心数学模型，然后应用这些模型为每个测试用例计算指定的指标。整个过程被封装在一个遵循指定执行环境的Python程序中。\n\n1.  **血流动力学响应函数（HRF）模型实现**\n    该模拟的基础是用于HRF的双伽马差模型。对于形状参数 $k  0$ 和尺度参数 $\\theta  0$，伽马概率密度函数 $g(t; k, \\theta)$ 定义如下：\n    $$\n    g(t; k, \\theta) = \\frac{t^{k - 1} e^{-t/\\theta}}{\\Gamma(k) \\, \\theta^{k}}, \\quad t \\ge 0\n    $$\n    其中 $\\Gamma(k)$ 是欧拉伽马函数，将使用 `scipy.special.gamma` 进行计算。我们实现了一个辅助函数来计算离散时间向量 $t$ 上的 $g(t; k, \\theta)$。对于 $t=0$ 这个点需要特殊处理。由于测试用例中提供的所有形状参数 $k$ 都大于1，因此 $g(0; k, \\theta) = 0$。实现中通过仅对 $t  0$ 的情况计算公式，并将 $t=0$ 处的值设为0来处理这一点。\n\n    然后，HRF $h(t)$ 被构造为这两个伽马函数的加权差：\n    $$\n    h(t; k_1, \\theta_1, k_2, \\theta_2, c, s) = s \\left( g(t; k_1, \\theta_1) - c \\, g(t; k_2, \\theta_2) \\right)\n    $$\n    另一个函数通过使用各自的参数 $(k_1, \\theta_1)$ 和 $(k_2, \\theta_2)$ 两次调用伽马PDF函数来实现这一点，然后根据公式，使用下冲比率 $c$ 和全局缩放因子 $s$ 将它们组合起来。\n\n2.  **数值网格生成**\n    对于每个测试用例，都会创建一个高分辨率时间网格，范围从 $t=0$ 到 $T_{\\max}$，步长为 $\\Delta t$。这个网格表示为 $\\{t_n\\}$，用于HRF形状的主要计算以及三个指标中的两个。此网格上的点数为 $N+1$，其中 $N = T_{\\max} / \\Delta t$。\n\n3.  **指标计算算法**\n    对于每对参数集 $\\Theta_A$ 和 $\\Theta_B$，在精细时间网格上生成相应的HRF $h_A(t)$ 和 $h_B(t)$。随后，计算三个指标以量化它们的相似性和差异。\n\n    -   **归一化均方根误差 (NRMSE)**：该指标评估 $h_A(t)$ 和 $h_B(t)$ 之间与全局振幅无关的形状相似性。首先，计算一个最优缩放因子 $\\alpha^\\star$，以最小化 $h_A$ 和重缩放后的 $h_B$ 之间的平方误差。这是一个标准的线性最小二乘问题，其解由下式给出：\n        $$\n        \\alpha^\\star = \\frac{\\sum_{n=0}^{N} h_A(t_n) h_B(t_n)}{\\sum_{n=0}^{N} h_B(t_n)^2} = \\frac{\\mathbf{h}_A \\cdot \\mathbf{h}_B}{\\mathbf{h}_B \\cdot \\mathbf{h}_B}\n        $$\n        其中 $\\mathbf{h}_A$ 和 $\\mathbf{h}_B$ 是精细网格上HRF值的向量。然后，NRMSE是残差的均方根，通过 $\\mathbf{h}_A$ 的范数进行归一化：\n        $$\n        \\mathrm{NRMSE} = \\sqrt{ \\frac{ \\sum_{n=0}^{N} \\left( h_A(t_n) - \\alpha^\\star h_B(t_n) \\right)^2 }{ \\sum_{n=0}^{N} h_A(t_n)^2 } }\n        $$\n\n    -   **峰值时间差 ($\\Delta \\mathrm{TTP}$)**：该指标捕捉时间动态上的差异。每个HRF的峰值时间 $t^{\\mathrm{peak}}_A$ 和 $t^{\\mathrm{peak}}_B$，是通过在精细离散网格上定位函数最大值的索引并检索相应的时间值来找到的。然后计算其绝对差：\n        $$\n        \\Delta \\mathrm{TTP} = \\left| t^{\\mathrm{peak}}_A - t^{\\mathrm{peak}}_B \\right|\n        $$\n\n    -   **皮尔逊相关系数 ($\\rho$)**：该指标评估两个HRF之间的线性关系，但特别是在模拟fMRI采集时间分辨率的粗糙网格上进行。粗糙网格由重复时间 $TR$ 定义。通过选择时间点 $m \\cdot TR$（$m=0, 1, 2, \\dots$）处的值对HRF时间过程进行下采样。由于在所有测试用例中 $TR$ 都是 $\\Delta t$ 的整数倍，这可以通过步长为 $TR/\\Delta t$ 的简单数组切片来实现。然后在这两个粗采样向量 $\\{h_A(m \\cdot TR)\\}_m$ 和 $\\{h_B(m \\cdot TR)\\}_m$ 之间计算皮尔逊相关系数 $\\rho$。\n\n4.  **执行与输出格式化**\n    主程序逻辑遍历所提供的三个测试用例。对于每个用例，它会解包网格参数（$T_{\\max}, \\Delta t, TR$）和两个HRF参数集（$\\Theta_A, \\Theta_B$）。它协调HRF曲线的生成和三个指标的计算。每个用例得到的浮点数三元组 $[\\mathrm{NRMSE}, \\Delta \\mathrm{TTP}, \\rho]$ 被收集起来。最后，所有用例的结果被格式化为单个字符串，形式为列表的列表，每个数值都四舍五入到 $6$ 位小数，并按照问题规范打印到标准输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma as gamma_function\n\ndef gamma_pdf(t: np.ndarray, k: float, theta: float) - np.ndarray:\n    \"\"\"\n    Computes the Gamma probability density function.\n    \n    Args:\n        t (np.ndarray): Time vector.\n        k (float): Shape parameter.\n        theta (float): Scale parameter.\n        \n    Returns:\n        np.ndarray: The values of the Gamma PDF at times t.\n    \"\"\"\n    if k == 0 or theta == 0:\n        return np.zeros_like(t, dtype=float)\n\n    # For k  1 (as in this problem), g(0) = 0. For k=1, g(0)=1/theta. \n    # For k  1, g(0) is infinite.\n    # The current implementation is robust for k  0.\n    result = np.zeros_like(t, dtype=float)\n    \n    # Calculate for t  0 to avoid numerical issues like 0**negative_power if k  1.\n    mask = t  0\n    t_pos = t[mask]\n    \n    numerator = np.power(t_pos, k - 1) * np.exp(-t_pos / theta)\n    denominator = gamma_function(k) * np.power(theta, k)\n    \n    if denominator  0:\n        result[mask] = numerator / denominator\n        \n    return result\n\ndef hrf(t: np.ndarray, k1: float, theta1: float, k2: float, theta2: float, c: float, s: float) - np.ndarray:\n    \"\"\"\n    Computes the difference-of-gammas Hemodynamic Response Function (HRF).\n    \n    Args:\n        t (np.ndarray): Time vector.\n        k1, theta1: Parameters for the first gamma function.\n        k2, theta2: Parameters for the second gamma function.\n        c (float): Relative weight of the second gamma (undershoot).\n        s (float): Global amplitude scaling.\n        \n    Returns:\n        np.ndarray: The HRF evaluated at times t.\n    \"\"\"\n    g1 = gamma_pdf(t, k1, theta1)\n    g2 = gamma_pdf(t, k2, theta2)\n    return s * (g1 - c * g2)\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'label': 'Case A',\n            'T_max': 32.0, 'dt': 0.1, 'TR': 2.0,\n            'Theta_A': {'k1': 6.0, 'theta1': 1.0, 'k2': 12.0, 'theta2': 1.0, 'c': 0.35, 's': 1.0},\n            'Theta_B': {'k1': 6.0, 'theta1': 1.0, 'k2': 12.0, 'theta2': 1.0, 'c': 0.35, 's': 1.5}\n        },\n        {\n            'label': 'Case B',\n            'T_max': 32.0, 'dt': 0.1, 'TR': 2.0,\n            'Theta_A': {'k1': 5.0, 'theta1': 1.2, 'k2': 14.0, 'theta2': 1.0, 'c': 0.34, 's': 1.0},\n            'Theta_B': {'k1': 4.5, 'theta1': 1.33, 'k2': 13.5, 'theta2': 1.04, 'c': 0.32, 's': 1.03}\n        },\n        {\n            'label': 'Case C',\n            'T_max': 32.0, 'dt': 0.1, 'TR': 3.0,\n            'Theta_A': {'k1': 3.0, 'theta1': 1.8, 'k2': 7.0, 'theta2': 1.8, 'c': 0.35, 's': 1.0},\n            'Theta_B': {'k1': 6.0, 'theta1': 0.9, 'k2': 12.0, 'theta2': 0.9, 'c': 0.35, 's': 1.0}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        T_max, dt, TR = case['T_max'], case['dt'], case['TR']\n        \n        # 1. Generate time grid and HRFs\n        num_points = int(T_max / dt) + 1\n        t = np.linspace(0, T_max, num_points)\n        \n        h_A = hrf(t, **case['Theta_A'])\n        h_B = hrf(t, **case['Theta_B'])\n\n        # 2. Compute metrics\n        \n        # Metric 1: NRMSE\n        hA_dot_hB = np.dot(h_A, h_B)\n        hB_dot_hB = np.dot(h_B, h_B)\n        alpha_star = hA_dot_hB / hB_dot_hB if hB_dot_hB  0 else 0.0\n        \n        hA_dot_hA = np.dot(h_A, h_A)\n        residual_sq_sum = np.sum(np.power(h_A - alpha_star * h_B, 2))\n        nrmse = np.sqrt(residual_sq_sum / hA_dot_hA) if hA_dot_hA  0 else 0.0\n\n        # Metric 2: Delta TTP\n        t_peak_A = t[np.argmax(h_A)]\n        t_peak_B = t[np.argmax(h_B)]\n        delta_ttp = np.abs(t_peak_A - t_peak_B)\n\n        # Metric 3: Pearson Correlation on coarse grid\n        coarse_sample_step = int(round(TR / dt))\n        h_A_coarse = h_A[::coarse_sample_step]\n        h_B_coarse = h_B[::coarse_sample_step]\n        \n        # Ensure there are at least 2 points for correlation\n        if len(h_A_coarse)  2:\n            rho = np.nan # Undefined correlation\n        else:\n            correlation_matrix = np.corrcoef(h_A_coarse, h_B_coarse)\n            rho = correlation_matrix[0, 1]\n\n        all_results.append([nrmse, delta_ttp, rho])\n\n    # 3. Format and print output\n    formatted_case_results = []\n    for R in all_results:\n        # Format each triplet [nrmse, dttp, rho] with 6 decimal places\n        formatted_case_results.append(f\"[{R[0]:.6f},{R[1]:.6f},{R[2]:.6f}]\")\n    \n    final_output_string = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}