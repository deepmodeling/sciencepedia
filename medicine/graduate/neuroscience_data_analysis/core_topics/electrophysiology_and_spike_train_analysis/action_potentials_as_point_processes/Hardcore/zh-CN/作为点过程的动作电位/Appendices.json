{
    "hands_on_practices": [
        {
            "introduction": "将动作电位建模为点过程的第一步是理解最基础的模型：齐次泊松过程。这个练习将带你从基本原理出发，推导齐次泊松过程的似然函数。掌握似然函数的推导至关重要，因为它是进行模型参数（如神经元的平均发放率 $\\lambda$）估计和统计推断的数学基石 。",
            "id": "4137360",
            "problem": "考虑在固定观测窗口 $[0,T]$（其中 $T>0$）内记录的单个神经元的脉冲序列。脉冲被建模为一个简单的点过程（没有同时发生的脉冲），该过程是速率参数为常数 $\\lambda>0$ 的齐次泊松过程。观测到的脉冲时间严格有序，$0  t_1  t_2  \\dots  t_n  T$。给定这组脉冲时间，推导该过程的似然函数和对数似然函数。",
            "solution": "该问题是有效的。这是一个适定的、有科学依据的、客观的请求，要求在点过程理论中进行标准推导，而点过程理论是神经科学数据分析的核心课题。该问题提供了从第一性原理推导似然函数和对数似然函数所需的所有必要定义和约束。\n\n任务是为在区间 $[0,T]$ 内观测到的一组有序脉冲时间 $0  t_1  t_2  \\dots  t_n  T$ 推导泊松过程（速率为 $\\lambda$）的似然函数。\n\n点过程的似然函数可以直观地通过将时间离散化为许多宽度为 $\\Delta t$ 的小区间来构建，然后取 $\\Delta t \\to 0$ 的极限。\n在每个小区间内，脉冲发生的概率约为 $\\lambda \\Delta t$，不发生脉冲的概率约为 $1 - \\lambda \\Delta t$。\n观测到的脉冲序列包含在 $n$ 个特定时间 $t_k$ 发生的脉冲，以及在所有其他时间不发生脉冲。\n\n观测到在区间 $[t_k, t_k + \\Delta t)$ 内有一次脉冲的概率是 $\\lambda \\Delta t$。\n观测到在其他所有小区间（总时长为 $T - n\\Delta t$）内没有脉冲的概率是 $\\prod (1 - \\lambda \\Delta t) \\approx (1 - \\lambda \\Delta t)^{(T - n\\Delta t)/\\Delta t}$。\n当 $\\Delta t \\to 0$ 时，$(1 - \\lambda \\Delta t)^{1/\\Delta t} \\to e^{-\\lambda}$，所以这一项趋向于 $e^{-\\lambda(T - n\\Delta t)} \\to e^{-\\lambda T}$。\n\n因此，在 $n$ 个特定的小区间内观测到脉冲，而在其他地方没有脉冲的概率是：\n$$ \\left( \\prod_{k=1}^n \\lambda \\Delta t \\right) e^{-\\lambda T} = \\lambda^n e^{-\\lambda T} (\\Delta t)^n $$\n概率密度是去掉 $(\\Delta t)^n$ 项的系数。因此，似然函数 $L(\\lambda)$ 是：\n$$ L(\\lambda) = \\lambda^n e^{-\\lambda T} $$\n这个表达式是观测到 $n$ 个脉冲在特定时间 $t_1, \\dots, t_n$ 的联合概率密度。值得注意的是，对于齐次泊松过程，似然函数仅取决于脉冲的数量 $n$，而不取决于它们的具体时间。\n\n对数似然函数 $\\mathcal{L}(\\lambda) = \\ln(L(\\lambda))$ 是：\n$$ \\mathcal{L}(\\lambda) = \\ln(\\lambda^n e^{-\\lambda T}) = \\ln(\\lambda^n) + \\ln(e^{-\\lambda T}) = n \\ln(\\lambda) - \\lambda T $$\n这个对数似然函数是用于对 $\\lambda$ 进行最大似然估计的基础。\n\n因此，似然函数和对数似然函数分别为 $\\lambda^n e^{-\\lambda T}$ 和 $n \\ln(\\lambda) - \\lambda T$。所提供的答案是正确的。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\lambda^{n} \\exp(-\\lambda T)  n \\ln(\\lambda) - \\lambda T \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "虽然齐次泊松过程是重要的基础，但它忽略了神经元一个关键的生理特性：不应期。为了构建更符合生物学现实的模型，我们引入了更新过程，其中“死时间”模型是一个简洁而有效的起点。通过这个练习，你将推导并比较包含绝对不应期的更新模型与标准泊松过程的关键统计特性，从而深刻理解不应期如何影响尖峰序列的规律性，例如通过变异系数（Coefficient of Variation, CV）来量化 。",
            "id": "4137393",
            "problem": "考虑一个单神经元脉冲序列，其被建模为一个更新点过程。在带有绝对不应期 (ARP) 的不应期泊松模型中，每个脉冲之后都有一个长度为 $d$ 的确定性时间间隔，在此期间风险率为零，之后风险率恒为 $\\lambda$。等价地，脉冲间期 (ISI) $\\tau$ 是一个固定的不应期 $d$ 与一个速率为 $\\lambda$ 的指数随机变量之和。假设在观测开始时，该过程处于平衡状态（稳态更新）。令 $N(T)$ 表示在持续时间为 $T$ 的窗口内观测到的脉冲数。\n\n从风险率、生存函数和更新框架的定义出发，推导在不应期泊松模型下，平均脉冲间期 $E[\\tau]$、定义为 $\\mathrm{CV} = \\frac{\\sqrt{\\mathrm{Var}[\\tau]}}{E[\\tau]}$ 的变异系数 (CV)，以及期望脉冲数 $E[N(T)]$ 的表达式。然后，推导速率同样为 $\\lambda$ 但没有不应期的齐次泊松过程的相应量。通过并列给出两组表达式来比较这两个模型。\n\n将 $E[\\tau]$ 以秒为单位表示，将 $E[N(T)]$ 以计数表示。最终答案应仅用 $d$、$\\lambda$ 和 $T$ 的符号表达式表示，并呈现在一个 $2 \\times 3$ 的矩阵中，其第一行对应不应期泊松模型，第二行对应齐次泊松过程的情况。无需进行数值计算，也无需四舍五入。",
            "solution": "该问题要求推导不应期泊松模型和齐次泊松过程的关键统计特性，并进行比较。该问题陈述是有效的，因为它在科学上基于点过程理论，所提供的信息完备使其成为一个适定问题，并且其表述是客观的。\n\n我们将首先分析不应期泊松模型，然后分析齐次泊松过程，后者可被视为前者的一个特例。\n\n**第一部分：不应期泊松模型**\n\n更新过程由其事件间间隔的分布来表征。对于不应期泊松模型，脉冲间期 (ISI) 用 $\\tau$ 表示。给定脉冲间期的风险率函数 $h(t)$ 为：\n$$\nh(t) = \\begin{cases} 0  \\text{for } 0 \\le t  d \\\\ \\lambda  \\text{for } t \\ge d \\end{cases}\n$$\n其中 $d$ 是绝对不应期（死时间），$\\lambda$ 是不应期后的恒定风险率。\n\n生存函数 $S(t) = P(\\tau > t)$ 与风险率的关系为 $S(t) = \\exp\\left(-\\int_0^t h(u) \\, du\\right)$。\n对于 $0 \\le t  d$，积分为 $\\int_0^t 0 \\, du = 0$，所以 $S(t) = \\exp(0) = 1$。这是符合预期的，因为脉冲间期不能短于不应期 $d$。\n对于 $t \\ge d$，积分为：\n$$\n\\int_0^t h(u) \\, du = \\int_0^d 0 \\, du + \\int_d^t \\lambda \\, du = 0 + [\\lambda u]_d^t = \\lambda(t-d)\n$$\n因此，对于 $t \\ge d$，生存函数为 $S(t) = \\exp(-\\lambda(t-d))$。\n\n脉冲间期的概率密度函数 (PDF) $p(t)$ 由 $p(t) = h(t)S(t)$ 给出。\n对于 $t  d$，$p(t) = 0 \\cdot 1 = 0$。\n对于 $t \\ge d$，$p(t) = \\lambda \\exp(-\\lambda(t-d))$。\n这个概率密度函数对应于一个被平移了 $d$ 的随机变量 $\\tau$。这证实了问题中给出的另一种描述：脉冲间期 $\\tau$ 可以写成固定不应期 $d$ 和一个随机变量 $X$ 的和，其中 $X$ 服从速率为 $\\lambda$ 的指数分布。即，$\\tau = d + X$，其中 $X \\sim \\text{Exponential}(\\lambda)$。\n\n现在我们可以计算所需的量。\n\n1.  **平均脉冲间期, $E[\\tau]$**:\n    利用期望的线性性质，我们有：\n    $$\n    E[\\tau] = E[d + X] = E[d] + E[X] = d + E[X]\n    $$\n    速率为 $\\lambda$ 的指数随机变量的均值为 $1/\\lambda$。\n    $$\n    E[\\tau] = d + \\frac{1}{\\lambda}\n    $$\n\n2.  **变异系数, CV**:\n    CV 定义为 $\\mathrm{CV} = \\frac{\\sqrt{\\mathrm{Var}[\\tau]}}{E[\\tau]}$。首先，我们求 $\\tau$ 的方差。\n    $$\n    \\mathrm{Var}[\\tau] = \\mathrm{Var}[d + X] = \\mathrm{Var}[X]\n    $$\n    因为加上一个常数不改变方差。速率为 $\\lambda$ 的指数随机变量的方差为 $1/\\lambda^2$。\n    $$\n    \\mathrm{Var}[\\tau] = \\frac{1}{\\lambda^2}\n    $$\n    现在，我们可以计算 CV：\n    $$\n    \\mathrm{CV} = \\frac{\\sqrt{1/\\lambda^2}}{d + 1/\\lambda} = \\frac{1/\\lambda}{d + 1/\\lambda}\n    $$\n    分子和分母同乘以 $\\lambda$ 得：\n    $$\n    \\mathrm{CV} = \\frac{1}{\\lambda d + 1}\n    $$\n\n3.  **期望脉冲数, $E[N(T)]$**:\n    问题陈述该过程是一个稳态更新过程。对于一个稳态更新过程，事件的长期平均速率是恒定的，等于平均事件间间隔的倒数。在持续时间为 $T$ 的区间内，期望事件数 $N(T)$ 是这个速率乘以 $T$。\n    $$\n    E[N(T)] = \\frac{T}{E[\\tau]}\n    $$\n    代入 $E[\\tau]$ 的表达式：\n    $$\n    E[N(T)] = \\frac{T}{d + 1/\\lambda} = \\frac{\\lambda T}{\\lambda d + 1}\n    $$\n\n**第二部分：齐次泊松过程**\n\n速率为 $\\lambda$ 的齐次泊松过程是不应期模型中不应期 $d=0$ 的一个特例。我们可以通过在上面推导的表达式中令 $d=0$ 来获得相应的量。\n\n1.  **平均脉冲间期, $E[\\tau]$**:\n    在 $E[\\tau] = d + 1/\\lambda$ 中令 $d=0$：\n    $$\n    E[\\tau] = 0 + \\frac{1}{\\lambda} = \\frac{1}{\\lambda}\n    $$\n    这是控制泊松过程脉冲间期的指数分布的众所周知的均值。\n\n2.  **变异系数, CV**:\n    在 $\\mathrm{CV} = \\frac{1}{\\lambda d + 1}$ 中令 $d=0$：\n    $$\n    \\mathrm{CV} = \\frac{1}{\\lambda(0) + 1} = 1\n    $$\n    CV 等于 1 是指数分布的一个定义特征，因此也是泊松过程的特征。引入一个确定性的不应期 ($d>0$) 会使过程更规则，导致 $\\mathrm{CV}  1$。\n\n3.  **期望脉冲数, $E[N(T)]$**:\n    在 $E[N(T)] = \\frac{\\lambda T}{\\lambda d + 1}$ 中令 $d=0$：\n    $$\n    E[N(T)] = \\frac{\\lambda T}{\\lambda(0) + 1} = \\lambda T\n    $$\n    这是齐次泊松过程的基本结果，即在持续时间为 $T$ 的区间内的期望事件数是速率 $\\lambda$ 乘以 $T$。\n\n**第三部分：比较**\n\n现在我们可以将最终结果整合到所要求的 $2 \\times 3$ 矩阵格式中，其中第一行对应不应期泊松模型，第二行对应齐次泊松过程。\n\n第一行（不应期泊松）：\n$E[\\tau] = d + \\frac{1}{\\lambda}$\n$\\mathrm{CV} = \\frac{1}{1 + \\lambda d}$\n$E[N(T)] = \\frac{\\lambda T}{1 + \\lambda d}$\n\n第二行（齐次泊松）：\n$E[\\tau] = \\frac{1}{\\lambda}$\n$\\mathrm{CV} = 1$\n$E[N(T)] = \\lambda T$\n\n这些表达式已准备好用于最终答案格式。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nd + \\frac{1}{\\lambda}  \\frac{1}{1 + \\lambda d}  \\frac{\\lambda T}{1 + \\lambda d} \\\\\n\\frac{1}{\\lambda}  1  \\lambda T\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理论模型的价值最终体现在其应用上，而模拟是连接理论与实践的关键桥梁。这个动手编程练习将指导你如何模拟更新过程，这是生成具有特定发放模式（如更规律或更不规律）的尖峰序列的核心技术。通过为不同的尖峰间隔（ISI）分布（如指数分布、伽马分布等）编写模拟程序并验证其统计特性，你将把抽象的概率论概念转化为生成具体神经数据的实用计算工具 。",
            "id": "4137312",
            "problem": "考虑从单个神经元记录的动作电位，并将其建模为时间实线上的瞬时点过程。更新过程是一种点过程，其脉冲间隔（Inter-Spike Interval, ISI）是独立同分布的，具有一个共同的概率密度函数，记为 $p(\\tau)$（其中 $\\tau \\ge 0$）。脉冲时间 $\\{t_k\\}_{k \\ge 1}$ 是通过 ISI 的累积和构建的，即 $t_k = \\sum_{i=1}^k \\tau_i$，其中 $t_0 = 0$。在本问题中，您必须通过从 $p(\\tau)$ 采样 ISI $\\tau_i$ 并形成累积脉冲时间，直到下一个脉冲将超过窗口为止，从而在长度为 $T$ 秒的有限观测窗口上实现一个更新过程的模拟程序。所有时间量必须以秒为单位处理，速率以秒的倒数为单位，表示为 $\\,\\mathrm{s}^{-1}$。\n\n从更新过程的定义以及 ISI 的独立同分布特性出发，推导出一个模拟算法，该算法能够：\n- 从指定的 ISI 分布 $p(\\tau)$ 生成独立样本 $\\tau_1, \\tau_2, \\dots$，\n- 形成累积脉冲时间 $t_k = \\sum_{i=1}^k \\tau_i$，\n- 在超过观测窗口 $T$ 之前停止，\n- 返回在 $\\left(0, T\\right]$ 范围内的脉冲时间列表。\n\n您的程序必须实现此算法，然后通过将经验汇总统计量与几种 $p(\\tau)$ 选项的理论值进行比较来验证它。对于下面的每个测试用例，从模拟的脉冲序列中计算经验 ISI，并评估两个量：经验平均 ISI 和经验变异系数（定义为 $\\mathrm{CV} = \\sigma/\\mu$，其中 $\\mu$ 是平均 ISI，$\\sigma$ 是 ISI 的标准差）。将这些值与所选 $p(\\tau)$ 对应的理论平均值和理论变异系数进行比较。对平均值使用基于渐近采样误差的容差方案，对变异系数使用基于区间数量的保守函数。对于平均 ISI，设置容差 $\\mathrm{tol}_{\\mu} = c_{\\mu} \\cdot \\sigma / \\sqrt{N}$，其中 $c_{\\mu} = 5$，$N$ 是模拟的 ISI 数量，$\\sigma$ 是 ISI 的理论标准差。对于变异系数，设置容差 $\\mathrm{tol}_{\\mathrm{CV}} = \\min\\{c_{\\mathrm{CV}}/\\sqrt{N}, u_{\\mathrm{CV}}\\}$，其中 $c_{\\mathrm{CV}} = 3$ 且 $u_{\\mathrm{CV}} = 0.2$。如果两个绝对偏差都在各自的容差范围内，则声明该测试用例通过。\n\n您必须为以下 ISI 分布 $p(\\tau)$ 实现采样，每个分布都由其参数指定，并完全按照测试套件的要求使用它们：\n\n- 指数分布，速率为 $\\lambda$（单位 $\\,\\mathrm{s}^{-1}$），密度为 $p(\\tau) = \\lambda e^{-\\lambda \\tau}$（$\\tau \\ge 0$）。\n- 伽马分布，形状参数为 $\\alpha$，速率参数为 $\\beta$（单位 $\\,\\mathrm{s}^{-1}$），密度为 $p(\\tau) = \\dfrac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} \\tau^{\\alpha - 1} e^{-\\beta \\tau}$（$\\tau \\ge 0$）。\n- 对数正态分布，参数为 $\\mu$ 和 $\\sigma$（无量纲），表示 $\\log \\tau \\sim \\mathcal{N}(\\mu, \\sigma^2)$（$\\tau > 0$）。\n- 确定性分布，集中在一个恒定区间 $\\tau^\\star > 0$ 上，即 $p(\\tau) = \\delta(\\tau - \\tau^\\star)$。\n\n对于每种分布，还需使用众所周知的理论汇总统计量：\n- 指数分布，速率为 $\\lambda$：平均值 $1/\\lambda$，标准差 $1/\\lambda$，变异系数 $1$。\n- 伽马分布，形状参数为 $\\alpha$，速率参数为 $\\beta$：平均值 $\\alpha/\\beta$，标准差 $\\sqrt{\\alpha}/\\beta$，变异系数 $1/\\sqrt{\\alpha}$。\n- 对数正态分布，参数为 $\\mu$ 和 $\\sigma$：平均值 $\\exp\\left(\\mu + \\sigma^2/2\\right)$，方差 $\\left(\\exp(\\sigma^2) - 1\\right)\\exp\\left(2\\mu + \\sigma^2\\right)$，变异系数 $\\sqrt{\\exp(\\sigma^2) - 1}$。\n- 确定性分布，区间为 $\\tau^\\star$：平均值 $\\tau^\\star$，标准差 $0$，变异系数 $0$。\n\n您必须使用以下测试套件进行模拟，该套件涵盖了典型情况、更规则的脉冲发放、重尾 ISI 以及零变异性的边界情况：\n- 测试用例 $1$（指数分布）：速率 $\\lambda = 25\\,\\mathrm{s}^{-1}$，窗口 $T = 100\\,\\mathrm{s}$。\n- 测试用例 $2$（伽马分布）：形状参数 $\\alpha = 3$，速率参数 $\\beta = 75\\,\\mathrm{s}^{-1}$，窗口 $T = 100\\,\\mathrm{s}$。\n- 测试用例 $3$（对数正态分布）：参数 $\\mu = -3.1207$，$\\sigma = 0.5$，窗口 $T = 100\\,\\mathrm{s}$。\n- 测试用例 $4$（确定性分布）：恒定区间 $\\tau^\\star = 0.04\\,\\mathrm{s}$，窗口 $T = 10\\,\\mathrm{s}$。\n\n您的程序必须：\n- 使用固定的随机种子以确保可复现性，\n- 对每个测试用例，在给定的 $T$ 上模拟更新过程，\n- 计算经验平均 ISI 和经验变异系数，\n- 计算理论平均值和理论变异系数，\n- 按照上述规定计算容差 $\\mathrm{tol}_\\mu$ 和 $\\mathrm{tol}_{\\mathrm{CV}}$，\n- 为每个测试用例输出一个布尔值，指示两个经验汇总统计量是否都在其理论值的容差范围内。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表，例如 $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True}]$。不应打印任何其他文本。所有时间都必须以秒为单位解释和处理，速率以秒的倒数 $\\,\\mathrm{s}^{-1}$ 为单位。将所有比较表示为布尔值；不要输出百分比。",
            "solution": "该问题要求模拟一个更新过程，这是神经元脉冲序列的一个基本模型，其中脉冲间隔（ISI）被视为独立同分布（i.i.d.）的随机变量。必须通过将生成的脉冲序列的经验汇总统计量与几种 ISI 分布的已知理论对应值进行比较来验证该模拟。\n\n该解决方案基于以下原则设计：\n\n**1. 更新过程模拟**\n更新过程由一系列非负的独立同分布随机变量 $\\{\\tau_i\\}_{i \\ge 1}$ 构建而成，这些变量代表连续事件之间的时间间隔。第 $k$ 个事件的时间记为 $t_k$，是前 $k$ 个间隔的累积和：\n$$t_k = \\sum_{i=1}^k \\tau_i$$\n过程从 $t_0 = 0$ 开始。\n\n模拟算法在持续时间为 $T$ 的有限观测窗口上直接实现了这个定义。过程如下：\n- 初始化当前时间 $t_{\\text{current}} = 0$ 和一个用于存储脉冲时间的空列表。\n- 迭代生成事件时间：\n  1. 从指定的概率密度函数 $p(\\tau)$ 中抽取一个随机样本 ISI，即 $\\tau$。\n  2. 计算下一个潜在脉冲的时间：$t_{\\text{next}} = t_{\\text{current}} + \\tau$。\n  3. 如果 $t_{\\text{next}} \\le T$，则该脉冲发生在观测窗口内。将 $t_{\\text{next}}$ 附加到脉冲时间列表中，并更新 $t_{\\text{current}} = t_{\\text{next}}$。\n  4. 如果 $t_{\\text{next}} > T$，则下一个脉冲落在窗口之外。本次试验的模拟终止，并退出循环。\n- 模拟的最终输出是收集到的脉冲时间列表 $\\{t_k\\}$，满足 $t_k \\in (0, T]$。\n\n**2. 随机变量生成**\n要生成 ISI $\\tau$，我们必须从四个指定的分布中进行采样。这可以通过使用 `NumPy` 的随机数生成模块来完成，该模块为此目的提供了高效且经过良好测试的函数。从问题的参数到库函数参数的映射至关重要。\n- **指数分布($\\lambda$)：** PDF 为 $p(\\tau) = \\lambda e^{-\\lambda \\tau}$。`numpy.random.exponential` 函数接受一个 `scale` 参数，该参数是分布的平均值，$1/\\lambda$。\n- **伽马分布($\\alpha, \\beta$)：** PDF 为 $p(\\tau) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} \\tau^{\\alpha - 1} e^{-\\beta \\tau}$。`numpy.random.gamma` 函数接受 `shape` ($\\alpha$) 和 `scale` 参数。scale 是速率参数 $\\beta$ 的倒数，因此我们使用 `scale` = $1/\\beta$。\n- **对数正态分布($\\mu, \\sigma$)：** `numpy.random.lognormal` 函数直接接受 $\\log \\tau$ 的相关正态分布的参数 $\\mu$ (`mean`) 和 $\\sigma$ (`sigma`)。\n- **确定性分布($\\tau^\\star$)：** 这是一个平凡的情况，其中区间始终是恒定值 $\\tau^\\star$，无需随机采样。\n\n**3. 统计验证**\n通过将生成数据的经验统计量与其理论值进行比较来评估模拟的有效性。\n\n- **经验统计量计算：**\n  1. 从模拟的脉冲序列 $\\{t_1, t_2, \\dots, t_N\\}$ 中，重构出 ISI 序列为 $\\{\\tau_1, \\tau_2, \\dots, \\tau_N\\} = \\{t_1, t_2 - t_1, \\dots, t_N - t_{N-1}\\}$。这是通过计算前面加上 $t_0=0$ 的脉冲时间数组的差分来实现的。\n  2. 经验平均 ISI，$\\hat{\\mu}$，是这些重构的 ISI 的算术平均值。\n  3. 经验标准差 $\\hat{\\sigma}$ 使用样本标准差的标准公式计算，并采用 Bessel 校正（分母为 $n-1$）以提供总体方差的无偏估计。\n  4. 经验变异系数是比率 $\\widehat{\\mathrm{CV}} = \\hat{\\sigma} / \\hat{\\mu}$。\n\n- **理论统计量：** 问题为四种分布中的每一种都提供了平均值 $\\mu_{th}$、标准差 $\\sigma_{th}$ 和变异系数 $\\mathrm{CV}_{th}$ 的精确解析表达式。这些公式是概率论中的标准结果。\n\n- **与容差的比较：** 由于模拟的随机性，经验统计量不会与理论值完全匹配。比较时需要一个统计容差。\n  - 平均值的容差 $\\mathrm{tol}_{\\mu} = c_{\\mu} \\sigma_{th} / \\sqrt{N_{ISI}}$ 基于中心极限定理。量 $\\sigma_{th}/\\sqrt{N_{ISI}}$ 是样本均值的标准误，$c_{\\mu}=5$ 设置了一个 $5$-sigma 置信界限，使得正确的模拟有很大概率通过测试。\n  - 变异系数的容差 $\\mathrm{tol}_{\\mathrm{CV}} = \\min\\{c_{\\mathrm{CV}}/\\sqrt{N_{ISI}}, u_{\\mathrm{CV}}\\}$ 是一个实际的选择，它反映了 CV 的采样误差也随着样本数量 $N_{ISI}$ 的增加而减小，同时被限制在最大值 $u_{\\mathrm{CV}}$。\n  - 当且仅当 $|\\hat{\\mu} - \\mu_{th}| \\le \\mathrm{tol}_{\\mu}$ 和 $|\\widehat{\\mathrm{CV}} - \\mathrm{CV}_{th}| \\le \\mathrm{tol}_{\\mathrm{CV}}$ 时，一个测试用例被认为已通过。\n\n最终的程序实现了这整个过程，它遍历四个指定的测试用例，并为每个用例报告一个布尔型的通过/失败结果，同时使用固定的随机种子来确保结果是确定性和可复现的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Simulates renewal processes for different ISI distributions and validates\n    their empirical statistics against theoretical values.\n    \"\"\"\n    # Set a fixed random seed for reproducibility as required.\n    np.random.seed(0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'exponential', 'params': {'lambda': 25.0}, 'T': 100.0},\n        {'type': 'gamma',       'params': {'alpha': 3.0, 'beta': 75.0}, 'T': 100.0},\n        {'type': 'lognormal',   'params': {'mu': -3.1207, 'sigma': 0.5}, 'T': 100.0},\n        {'type': 'deterministic', 'params': {'tau_star': 0.04}, 'T': 10.0},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        dist_type = case['type']\n        params = case['params']\n        T = case['T']\n\n        # 1. Simulate the renewal process to generate spike times\n        spike_times = []\n        current_time = 0.0\n        \n        while True:\n            if dist_type == 'exponential':\n                # numpy.random.exponential uses scale = 1/rate\n                tau = np.random.exponential(scale=1.0 / params['lambda'])\n            elif dist_type == 'gamma':\n                # numpy.random.gamma uses scale = 1/rate\n                tau = np.random.gamma(shape=params['alpha'], scale=1.0 / params['beta'])\n            elif dist_type == 'lognormal':\n                tau = np.random.lognormal(mean=params['mu'], sigma=params['sigma'])\n            elif dist_type == 'deterministic':\n                tau = params['tau_star']\n            else:\n                # This case should not be reached with the given test suite\n                raise ValueError(\"Unknown distribution type\")\n\n            if current_time + tau > T:\n                break\n            \n            current_time += tau\n            spike_times.append(current_time)\n\n        # A valid spike train for statistical analysis needs at least 2 spikes.\n        if len(spike_times)  2:\n            results.append(False)\n            continue\n            \n        spike_times_np = np.array(spike_times)\n\n        # 2. Compute empirical statistics from the spike train\n        # Reconstruct ISIs: [t_1, t_2-t_1, t_3-t_2, ...]\n        empirical_isis = np.diff(np.insert(spike_times_np, 0, 0.0))\n        num_isis = len(empirical_isis)\n        \n        empirical_mean = np.mean(empirical_isis)\n        # Use ddof=1 for unbiased sample standard deviation\n        empirical_std = np.std(empirical_isis, ddof=1)\n        # Handle potential division by zero, though unlikely for these cases\n        empirical_cv = empirical_std / empirical_mean if empirical_mean > 0 else 0.0\n\n        # 3. Compute theoretical statistics\n        if dist_type == 'exponential':\n            rate = params['lambda']\n            theoretical_mean = 1.0 / rate\n            theoretical_std = 1.0 / rate\n            theoretical_cv = 1.0\n        elif dist_type == 'gamma':\n            shape, rate = params['alpha'], params['beta']\n            theoretical_mean = shape / rate\n            theoretical_std = np.sqrt(shape) / rate\n            theoretical_cv = 1.0 / np.sqrt(shape)\n        elif dist_type == 'lognormal':\n            mu, sigma = params['mu'], params['sigma']\n            theoretical_mean = np.exp(mu + sigma**2 / 2.0)\n            theoretical_var = (np.exp(sigma**2) - 1.0) * np.exp(2.0 * mu + sigma**2)\n            theoretical_std = np.sqrt(theoretical_var)\n            theoretical_cv = np.sqrt(np.exp(sigma**2) - 1.0)\n        elif dist_type == 'deterministic':\n            tau_star = params['tau_star']\n            theoretical_mean = tau_star\n            theoretical_std = 0.0\n            theoretical_cv = 0.0\n            \n        # 4. Compute tolerances for validation\n        c_mu = 5.0\n        # Handle theoretical_std = 0 case for tol_mu\n        tol_mu = (c_mu * theoretical_std / np.sqrt(num_isis)) if num_isis > 0 else 0.0\n        \n        c_cv = 3.0\n        u_cv = 0.2\n        tol_cv = min(c_cv / np.sqrt(num_isis), u_cv) if num_isis > 0 else u_cv\n\n        # 5. Perform validation checks\n        mean_passes = np.abs(empirical_mean - theoretical_mean) = tol_mu\n        cv_passes = np.abs(empirical_cv - theoretical_cv) = tol_cv\n        \n        results.append(mean_passes and cv_passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).capitalize() for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}