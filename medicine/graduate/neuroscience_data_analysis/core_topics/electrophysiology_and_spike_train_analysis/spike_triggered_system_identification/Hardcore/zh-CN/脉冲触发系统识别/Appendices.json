{
    "hands_on_practices": [
        {
            "introduction": "在应用任何分析技术之前，至关重要的是要理解其基本假设和潜在的缺陷。这个练习将引导您从第一性原理出发，严格推导由刺激相关性引入脉冲触发平均（STA）的偏差。通过这个过程，您将深刻理解为何像白化这样的数据预处理步骤在系统辨识中至关重要，并为使用更高级的模型打下坚实的理论基础 。",
            "id": "4195527",
            "problem": "考虑一个在小信号近似下，根据线性-非线性-泊松 (LNP) 框架建模的神经元。设每个时间窗的刺激是一个 $p$ 维随机向量 $s \\in \\mathbb{R}^{p}$，其独立同分布地从一个零均值多元高斯分布中抽取，该分布的协方差矩阵为 $C \\in \\mathbb{R}^{p \\times p}$。其中 $C$ 是对称正定矩阵，其特征值 $\\{\\lambda_{i}\\}_{i=1}^{p}$ 横跨了几个数量级。给定刺激下，脉冲发放的瞬时条件强度近似为 $\\lambda(s) = \\lambda_{0} + \\lambda_{1}\\,k^{\\top}s$，其中 $\\lambda_{0}  0$，且 $k \\in \\mathbb{R}^{p}$ 是一个满足 $\\|k\\|_{2} = 1$ 的固定的未知单位范数滤波器。假设在小信号机制下，几乎必然有 $|\\lambda_{1}\\,k^{\\top}s| \\ll \\lambda_{0}$，这确保了模型的非负性和稳定性。脉冲触发平均 (STA) 定义为给定一个脉冲时刺激的条件期望，即 $\\mathrm{STA} = \\mathbb{E}[s \\mid \\text{spike}]$，它通过对观测到的脉冲之前的刺激进行平均来凭经验估计。\n\n滤波器的朴素脉冲触发平均估计器（记作 $\\hat{k}_{\\mathrm{naive}}$）直接将 STA 等同于滤波器，而没有考虑刺激的相关性。采用一种刺激单位的归一化，使得 $\\lambda_{1}/\\lambda_{0} = 1$，因此朴素估计器为 $\\hat{k}_{\\mathrm{naive}} = \\mathrm{STA}$。将平方估计误差定义为 $\\|\\hat{k}_{\\mathrm{naive}} - k\\|_{2}^{2}$。\n\n从脉冲触发平均的基本定义和多元高斯随机变量的性质出发，当真实滤波器方向 $k$ 从 $\\mathbb{R}^{p}$ 中的单位球面上均匀随机抽取时，推导期望平方估计误差 $\\mathbb{E}_{k}\\big[\\|\\hat{k}_{\\mathrm{naive}} - k\\|_{2}^{2}\\big]$ 的闭式表达式，该表达式应是关于 $C$ 的特征值 $\\{\\lambda_{i}\\}_{i=1}^{p}$ 的函数。最后，根据此推导解释为什么用一个满足 $W C W^{\\top} = I$ 的对称矩阵 $W$ 对刺激进行白化预处理，可以在期望意义上消除此误差。你的最终答案必须是仅含 $\\{\\lambda_{i}\\}$ 和 $p$ 的单个闭式解析表达式。不需要进行数值取整，也无需报告单位。",
            "solution": "用户要求详细推导朴素脉冲触发平均估计器的期望平方误差，并解释为什么刺激白化能减轻此误差。该问题是计算神经科学中一个定义明确且有科学依据的练习，我将开始进行解答。\n\n首先，我们必须推导脉冲触发平均 (STA) 的表达式。STA 定义为神经元产生一个脉冲的条件下，刺激 $s$ 的条件期望：\n$$\n\\mathrm{STA} = \\mathbb{E}[s \\mid \\text{spike}]\n$$\n使用全期望定律，给定一个脉冲的条件下刺激的概率密度 $p(s \\mid \\text{spike})$，可以与无条件的刺激密度 $p(s)$ 和条件脉冲概率 $P(\\text{spike} \\mid s)$ 相关联：\n$$\np(s \\mid \\text{spike}) = \\frac{P(\\text{spike} \\mid s) p(s)}{P(\\text{spike})}\n$$\n在 LNP 模型中，一个小时间窗 $\\Delta t$ 内出现脉冲的概率由瞬时强度函数 $\\lambda(s)$ 给出，即 $P(\\text{spike} \\mid s) = \\lambda(s) \\Delta t$。无条件的脉冲概率是其在所有刺激上的期望：$P(\\text{spike}) = \\mathbb{E}_{s}[P(\\text{spike} \\mid s)] = \\mathbb{E}_{s}[\\lambda(s)] \\Delta t$。\n将这些代入条件密度的表达式，得到：\n$$\np(s \\mid \\text{spike}) = \\frac{\\lambda(s) \\Delta t p(s)}{\\mathbb{E}_{s}[\\lambda(s)] \\Delta t} = \\frac{\\lambda(s) p(s)}{\\mathbb{E}_{s}[\\lambda(s)]}\n$$\n现在，STA 可以写成在刺激空间上的积分：\n$$\n\\mathrm{STA} = \\int s \\, p(s \\mid \\text{spike}) \\, ds = \\frac{\\int s \\, \\lambda(s) p(s) \\, ds}{\\mathbb{E}_{s}[\\lambda(s)]} = \\frac{\\mathbb{E}_{s}[s \\lambda(s)]}{\\mathbb{E}_{s}[\\lambda(s)]}\n$$\n我们已知发放率的线性近似为：$\\lambda(s) = \\lambda_{0} + \\lambda_{1}\\,k^{\\top}s$。刺激 $s$ 从零均值多元高斯分布中抽取，即 $s \\sim \\mathcal{N}(0, C)$，所以 $\\mathbb{E}_{s}[s] = 0$。\n分母是平均发放率：\n$$\n\\mathbb{E}_{s}[\\lambda(s)] = \\mathbb{E}_{s}[\\lambda_{0} + \\lambda_{1}\\,k^{\\top}s] = \\lambda_{0} + \\lambda_{1}\\,k^{\\top}\\mathbb{E}_{s}[s] = \\lambda_{0}\n$$\n分子是：\n$$\n\\mathbb{E}_{s}[s \\lambda(s)] = \\mathbb{E}_{s}[s (\\lambda_{0} + \\lambda_{1}\\,k^{\\top}s)] = \\lambda_{0}\\mathbb{E}_{s}[s] + \\lambda_{1}\\mathbb{E}_{s}[s (s^{\\top}k)]\n$$\n由于 $\\mathbb{E}_{s}[s] = 0$，第一项消失。对于第二项，我们使用这样一个性质：对于零均值随机向量 $s$，其协方差矩阵为 $C = \\mathbb{E}[ss^{\\top}]$。\n$$\n\\mathbb{E}_{s}[s (s^{\\top}k)] = \\mathbb{E}_{s}[ss^{\\top}]k = Ck\n$$\n因此，分子是 $\\lambda_{1}Ck$。\n结合分子和分母，我们得到 STA：\n$$\n\\mathrm{STA} = \\frac{\\lambda_{1}Ck}{\\lambda_{0}}\n$$\n题目指定了一个归一化，使得 $\\lambda_{1} / \\lambda_{0} = 1$。由此，STA 简化为：\n$$\n\\mathrm{STA} = Ck\n$$\n滤波器的朴素估计器 $\\hat{k}_{\\mathrm{naive}}$ 被定义为等于 STA。因此，$\\hat{k}_{\\mathrm{naive}} = Ck$。这表明在存在相关刺激（$C \\neq I$）的情况下，朴素 STA 估计器是真实滤波器 $k$ 的一个有偏估计器。\n\n接下来，我们计算对于一个固定滤波器 $k$ 的平方估计误差：\n$$\n\\|\\hat{k}_{\\mathrm{naive}} - k\\|_{2}^{2} = \\|Ck - k\\|_{2}^{2} = \\|(C-I)k\\|_{2}^{2}\n$$\n其中 $I$ 是 $p \\times p$ 单位矩阵。这个平方范数可以写成一个二次型：\n$$\n\\|(C-I)k\\|_{2}^{2} = \\big((C-I)k\\big)^{\\top}\\big((C-I)k\\big) = k^{\\top}(C-I)^{\\top}(C-I)k\n$$\n由于协方差矩阵 $C$ 是对称的（$C^{\\top}=C$），矩阵 $C-I$ 也是对称的。所以，$(C-I)^{\\top} = C-I$。平方误差变为：\n$$\n\\|\\hat{k}_{\\mathrm{naive}} - k\\|_{2}^{2} = k^{\\top}(C-I)^{2}k\n$$\n题目要求我们计算这个误差的期望 $\\mathbb{E}_{k}[\\cdot]$，其中真实滤波器 $k$ 是从 $\\mathbb{R}^{p}$ 中的单位球面上均匀随机抽取的（即 $\\|k\\|_{2}=1$）。我们需要计算二次型 $k^{\\top}Ak$ 的期望，其中 $A = (C-I)^2$。对于在 $\\mathbb{R}^{p}$ 球面上均匀分布的随机单位向量 $k$，这个二次型的期望由下式给出：\n$$\n\\mathbb{E}_{k}[k^{\\top}Ak] = \\frac{1}{p}\\mathrm{Tr}(A)\n$$\n其中 $\\mathrm{Tr}(A)$ 是矩阵 $A$ 的迹。\n将此结果应用于我们的误差表达式：\n$$\n\\mathbb{E}_{k}\\big[\\|\\hat{k}_{\\mathrm{naive}} - k\\|_{2}^{2}\\big] = \\mathbb{E}_{k}\\big[k^{\\top}(C-I)^{2}k\\big] = \\frac{1}{p}\\mathrm{Tr}\\big((C-I)^{2}\\big)\n$$\n为了用 $C$ 的特征值 $\\{\\lambda_i\\}$ 来表示这个表达式，我们使用迹和矩阵对角化的性质。由于 $C$ 是对称的，它可以被对角化为 $C = U \\Lambda U^{\\top}$，其中 $U$ 是特征向量构成的正交矩阵（$U^{\\top}U = I$），而 $\\Lambda = \\mathrm{diag}(\\lambda_{1}, \\dots, \\lambda_{p})$ 是特征值构成的对角矩阵。\n我们可以将 $(C-I)^2$ 写为：\n$$\n(C-I)^{2} = (U \\Lambda U^{\\top} - U I U^{\\top})^{2} = (U(\\Lambda - I)U^{\\top})^{2} = U(\\Lambda - I)^{2}U^{\\top}\n$$\n使用迹的循环性质（$\\mathrm{Tr}(XY) = \\mathrm{Tr}(YX)$）：\n$$\n\\mathrm{Tr}\\big((C-I)^{2}\\big) = \\mathrm{Tr}\\big(U(\\Lambda - I)^{2}U^{\\top}\\big) = \\mathrm{Tr}\\big((\\Lambda - I)^{2}U^{\\top}U\\big) = \\mathrm{Tr}\\big((\\Lambda - I)^{2}\\big)\n$$\n矩阵 $(\\Lambda - I)^{2}$ 是一个对角矩阵，其对角线元素为 $(\\lambda_{i}-1)^2$。对角矩阵的迹是其对角元素的和。\n$$\n\\mathrm{Tr}\\big((\\Lambda - I)^{2}\\big) = \\sum_{i=1}^{p}(\\lambda_{i}-1)^2\n$$\n将此代回我们的期望误差表达式中，我们得到最终的闭式表达式：\n$$\n\\mathbb{E}_{k}\\big[\\|\\hat{k}_{\\mathrm{naive}} - k\\|_{2}^{2}\\big] = \\frac{1}{p}\\sum_{i=1}^{p}(\\lambda_{i}-1)^2\n$$\n\n最后，我们解释为什么通过白化对刺激进行预处理可以在期望上消除此误差。白化刺激涉及应用一个线性变换 $s' = Ws$，使得新刺激的协方差 $C' = \\mathbb{E}[s'(s')^{\\top}]$ 是单位矩阵 $I$。题目指出 $W$ 是一个满足 $WCW^{\\top}=I$ 的对称矩阵。当我们对白化后的刺激 $s'$ 进行脉冲触发分析时，计算中相关的刺激协方差矩阵是 $C' = I$。单位矩阵的特征值都等于1，即对于所有 $i=1, \\dots, p$，都有 $\\lambda'_{i} = 1$。\n我们可以将刚刚推导的误差公式应用于这个白化场景，只需将 $C$ 的特征值 $\\{\\lambda_i\\}$ 替换为 $C'$ 的特征值 $\\{\\lambda'_i\\}$。\n在白化空间中，朴素估计器的期望平方误差为：\n$$\n\\text{Expected Error}_{\\text{whitened}} = \\frac{1}{p}\\sum_{i=1}^{p}(\\lambda'_{i}-1)^2 = \\frac{1}{p}\\sum_{i=1}^{p}(1-1)^2 = \\frac{1}{p}\\sum_{i=1}^{p}0 = 0\n$$\n这表明，当刺激被白化时，朴素 STA 估计器的期望估计误差变为零。由刺激相关性（由不等于1的特征值表示）引入的偏差被完全消除，STA 成为滤波器的一个无偏估计器（在白化坐标系中）。",
            "answer": "$$\n\\boxed{\\frac{1}{p}\\sum_{i=1}^{p}(\\lambda_{i} - 1)^{2}}\n$$"
        },
        {
            "introduction": "仅仅估计出一个神经元的滤波器只是分析的第一步；真正的科学洞见来自于对这个估计进行统计推断。本练习提供了一个动手实践的编码任务，旨在量化所估计滤波器特征（例如，峰值时间）的不确定性。您将通过应用强大且广泛适用的蒙特卡洛方法来检验关于滤波器结构的假设，这是从原始数据中提取有意义结论的关键技能 。",
            "id": "4195506",
            "problem": "在给定一个离散时间线性-非线性-泊松（LNP）脉冲模型的背景下，其中包含高斯白噪声刺激，使用脉冲触发平均（STA）来对时间滤波器进行系统辨识。脉冲触发平均被定义为在给定脉冲发生的情况下，脉冲前刺激的条件期望。在零均值和单位方差的独立同分布高斯输入下，STA 与真实线性滤波器成正比。对于大量的脉冲，STA 的每个时间滞后系数都具有近似高斯分布的采样分布，其均值等于真实滤波器相应的系数，方差约等于刺激方差除以脉冲总数。您需要实现一种有原则的方法，以分离一个多峰时间滤波器的早期和晚期成分，并使用 STA 采样分布的蒙特卡洛近似来检验它们的峰值时间是否存在显著差异。所有时间索引都是没有物理单位的离散样本索引。\n\n您的任务是编写一个程序，该程序：\n- 从以下基本原理出发：\n  - 滞后 $t$ 处的脉冲触发平均（STA）是在给定脉冲的情况下，该滞后处刺激 $s$ 的条件期望。在高斯白噪声输入下，STA 与真实滤波器 $k(t)$ 成正比。\n  - 对于方差为 $\\sigma_s^2$ 的独立同分布高斯刺激和 $N_{\\text{spk}}$ 个脉冲，每个滞后处 STA 的采样波动可以近似为方差为 $\\sigma^2 = \\sigma_s^2 / N_{\\text{spk}}$ 的高斯分布。\n- 将一个合成的多峰时间滤波器 $k(t)$ 构建为两个高斯形分量的和，这些分量在离散滞后 $t \\in \\{0,1,\\dots,L-1\\}$ 上具有指定的振幅、中心和标准差。\n- 通过生成 $M$ 个 $\\hat{k}^{(m)}(t) = k(t) + \\epsilon^{(m)}(t)$ 的独立样本来近似 STA 估计量 $\\hat{k}(t)$ 的采样分布，其中 $\\epsilon^{(m)}(t)$ 是每个滞后处方差为 $\\sigma^2$ 的独立高斯噪声项。\n- 通过一个边界滞后 $\\tau_b$ 将早期和晚期成分分开，具体如下：\n  - 早期成分支撑集：所有满足 $t \\le \\tau_b$ 的滞后 $t$。\n  - 晚期成分支撑集：所有满足 $t \\ge \\tau_b$ 的滞后 $t$。\n- 对于每个复制样本 $\\hat{k}^{(m)}(t)$：\n  - 将早期峰值时间 $t_{\\text{early}}^{(m)}$ 确定为早期支撑集上使 $\\hat{k}^{(m)}(t)$ 达到最大值的最小滞后。\n  - 将晚期峰值时间 $t_{\\text{late}}^{(m)}$ 确定为晚期支撑集上使 $\\hat{k}^{(m)}(t)$ 达到最大值的最小滞后。\n  - 计算差值 $\\Delta^{(m)} = t_{\\text{late}}^{(m)} - t_{\\text{early}}^{(m)}$。\n- 使用 $\\{\\Delta^{(m)}\\}_{m=1}^M$ 的经验分布，通过取 $\\alpha$ 和 $(1-\\alpha)$ 分位数来构建一个名义水平为 $1-2\\alpha$ 的双侧置信区间，其中 $\\alpha = 0.025$。\n- 当且仅当 $0$ 不在该经验置信区间内时，声明峰值时间存在显著差异。\n- 为每个测试用例返回一个布尔值，指示峰值时间的差异是否显著。\n\n使用以下测试套件。在所有情况下，使用刺激方差 $\\sigma_s^2 = 1$ 和显著性水平 $\\alpha = 0.025$。振幅为 $a$、中心为 $\\mu$、标准差为 $\\sigma$ 的高斯分量在每个离散滞后 $t$ 处对 $k(t)$ 的贡献为 $a \\exp\\left(-\\frac{(t-\\mu)^2}{2\\sigma^2}\\right)$。\n\n- 测试用例 1（峰值分离良好且脉冲数高的理想情况）：\n  - 滤波器长度 $L = 120$。\n  - 早期成分：振幅 $a_1 = 1.0$，中心 $\\mu_1 = 20$，标准差 $\\sigma_1 = 4$。\n  - 晚期成分：振幅 $a_2 = 0.8$，中心 $\\mu_2 = 70$，标准差 $\\sigma_2 = 6$。\n  - 边界滞后 $\\tau_b = 45$。\n  - 脉冲总数 $N_{\\text{spk}} = 20000$。\n  - 复制样本数 $M = 2000$。\n\n- 测试用例 2（峰值时间接近，振幅低，脉冲数中等；预期结果为不显著）：\n  - 滤波器长度 $L = 100$。\n  - 早期成分：振幅 $a_1 = 0.1$，中心 $\\mu_1 = 35$，标准差 $\\sigma_1 = 8$。\n  - 晚期成分：振幅 $a_2 = 0.1$，中心 $\\mu_2 = 37$，标准差 $\\sigma_2 = 8$。\n  - 边界滞后 $\\tau_b = 36$。\n  - 脉冲总数 $N_{\\text{spk}} = 300$。\n  - 复制样本数 $M = 2000$。\n\n- 测试用例 3（峰值分离良好但脉冲数较低；预期结果仍为显著）：\n  - 滤波器长度 $L = 120$。\n  - 早期成分：振幅 $a_1 = 1.0$，中心 $\\mu_1 = 15$，标准差 $\\sigma_1 = 3$。\n  - 晚期成分：振幅 $a_2 = 0.7$，中心 $\\mu_2 = 90$，标准差 $\\sigma_2 = 5$。\n  - 边界滞后 $\\tau_b = 50$。\n  - 脉冲总数 $N_{\\text{spk}} = 300$。\n  - 复制样本数 $M = 2000$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的布尔决策，形式为方括号括起来的逗号分隔列表（例如，“[True,False,True]”）。\n\n答案没有物理单位。不涉及角度。不需要百分比。所有数值输出均为布尔值。请通过在内部固定任何随机种子来确保您的程序是完全确定性的，以便结果是可复现的。",
            "solution": "该问题是有效的。它在科学上基于神经系统辨识的原理，特别是在线性-非线性-泊松（LNP）模型框架内使用脉冲触发平均（STA）。问题设定是适定的，为基于蒙特卡洛的假设检验提供了所有必要的参数和清晰的、算法上定义好的程序。语言是客观的，要求是可形式化的。\n\n目标是，在给定一个由有限数量脉冲得出的估计值的情况下，确定一个时间滤波器的早期和晚期成分的峰值时间是否可以被区分为具有统计显著性。要实现的方法是蒙特卡洛模拟，它适用于估计一个复杂统计量的采样分布——在本例中是峰值时间的差异——其解析形式不易获得。\n\n解决方案遵循以下原则进行：\n\n1.  **使用脉冲触发平均（STA）进行系统辨识：** 在由高斯白噪声刺激 $s(t)$ 驱动的 LNP 模型背景下，一个基本结果表明，脉冲触发平均与神经元的真实线性滤波器 $k(t)$ 成正比。STA 是每个脉冲前刺激波形的平均值。对于有限数量的脉冲 $N_{\\text{spk}}$，我们得到一个估计值 $\\hat{k}(t)$。\n\n2.  **STA 估计量的采样分布：** 根据中心极限定理，对于足够大量的脉冲 $N_{\\text{spk}}$，STA 估计量在每个时间滞后 $t$ 处的采样波动可以近似为高斯分布。该分布的均值是真实的滤波器值 $k(t)$，其方差由 $\\sigma^2 = \\sigma_s^2 / N_{\\text{spk}}$ 给出，其中 $\\sigma_s^2$ 是刺激的方差。在这个问题中，我们给定 $\\sigma_s^2 = 1$。这种近似允许我们通过向已知的真实滤波器添加适当的噪声来模拟获得实验性 STA 的过程。\n\n3.  **用于假设检验的蒙特卡洛模拟：** 我们感兴趣的统计量是 $\\Delta = t_{\\text{late}} - t_{\\text{early}}$，即晚期成分峰值时间与早期成分峰值时间之差。用于寻找这些峰值时间的操作（$\\arg\\max$）是非线性的，这使得对 $\\Delta$ 的概率分布进行解析推导变得困难。因此，我们采用蒙特卡洛模拟来构建 $\\Delta$ 的经验分布。这包括以下步骤：\n    a.  **构建真实滤波器：** 真实滤波器 $k(t)$ 被定义为在长度为 $L$ 的离散时域上两个高斯形分量的和：\n        $$k(t) = a_1 \\exp\\left(-\\frac{(t-\\mu_1)^2}{2\\sigma_1^2}\\right) + a_2 \\exp\\left(-\\frac{(t-\\mu_2)^2}{2\\sigma_2^2}\\right)$$\n        适用于滞后 $t \\in \\{0, 1, \\dots, L-1\\}$。\n    b.  **模拟实验估计：** 我们通过向真实滤波器添加独立的高斯噪声来生成 $M$ 个复制的 STA 估计值 $\\hat{k}^{(m)}(t)$。对于每个复制样本 $m=1, \\dots, M$：\n        $$\\hat{k}^{(m)}(t) = k(t) + \\epsilon^{(m)}(t)$$\n        其中每个噪声样本 $\\epsilon^{(m)}(t)$ 从正态分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽取，且 $\\sigma^2 = \\sigma_s^2 / N_{\\text{spk}}$。\n    c.  **提取峰值时间差异：** 对于每个带噪声的复制样本 $\\hat{k}^{(m)}(t)$，滤波器被分为早期部分（滞后 $t \\le \\tau_b$）和晚期部分（滞后 $t \\ge \\tau_b$）。每个部分的峰值时间 $t_{\\text{early}}^{(m)}$ 和 $t_{\\text{late}}^{(m)}$ 被确定为在各自支撑集内使滤波器值最大化的最小滞后。然后计算差值 $\\Delta^{(m)} = t_{\\text{late}}^{(m)} - t_{\\text{early}}^{(m)}$。\n    d.  **构建置信区间：** $M$ 个差值的集合 $\\{\\Delta^{(m)}\\}_{m=1}^M$ 构成了峰值时间差的经验概率分布。通过找到该经验分布的 $\\alpha$ 和 $(1-\\alpha)$ 分位数来构建一个水平为 $1-2\\alpha$ 的双侧置信区间。在指定的 $\\alpha=0.025$ 下，这对应于第 $2.5$ 个和第 $97.5$ 个百分位数。\n    e.  **统计决策：** 零假设是真实的峰值时间差为零。我们拒绝此假设——并宣布观察到的差异是显著的——当且仅当值 $0$ 不包含在所构建的置信区间内。对于预期为正的差值 $\\Delta=t_{late}-t_{early}$，这等同于检查置信区间的下限是否大于 $0$。更一般地，显著性的条件是 $(CI_{lower}  0)$ 或 $(CI_{upper}  0)$。\n\n将此程序应用于每个具有其指定参数的测试用例，以产生关于峰值时间分离显著性的布尔决策。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spike-triggered system identification problem for three test cases.\n    \"\"\"\n    # Fix the random seed for the generator to ensure reproducible results.\n    rng = np.random.default_rng(0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path with well-separated peaks and high spike count)\n        {\n            \"L\": 120,\n            \"early_comp\": (1.0, 20, 4),  # (a1, mu1, sigma1)\n            \"late_comp\": (0.8, 70, 6),   # (a2, mu2, sigma2)\n            \"tau_b\": 45,\n            \"N_spk\": 20000,\n            \"M\": 2000\n        },\n        # Test case 2 (peaks close in time, low amplitude, moderate spike count)\n        {\n            \"L\": 100,\n            \"early_comp\": (0.1, 35, 8),\n            \"late_comp\": (0.1, 37, 8),\n            \"tau_b\": 36,\n            \"N_spk\": 300,\n            \"M\": 2000\n        },\n        # Test case 3 (well-separated peaks but lower spike count)\n        {\n            \"L\": 120,\n            \"early_comp\": (1.0, 15, 3),\n            \"late_comp\": (0.7, 90, 5),\n            \"tau_b\": 50,\n            \"N_spk\": 300,\n            \"M\": 2000\n        }\n    ]\n    \n    # Global parameters given in the problem\n    sigma_s2 = 1.0\n    alpha = 0.025\n\n    results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        a1, mu1, sigma1 = case[\"early_comp\"]\n        a2, mu2, sigma2 = case[\"late_comp\"]\n        tau_b = case[\"tau_b\"]\n        N_spk = case[\"N_spk\"]\n        M = case[\"M\"]\n\n        # 1. Construct the synthetic temporal filter k(t)\n        t = np.arange(L)\n        k_early_comp = a1 * np.exp(-((t - mu1)**2) / (2 * sigma1**2))\n        k_late_comp = a2 * np.exp(-((t - mu2)**2) / (2 * sigma2**2))\n        k_true = k_early_comp + k_late_comp\n\n        # 2. Calculate the standard deviation of the STA sampling fluctuation\n        sta_variance = sigma_s2 / N_spk\n        sta_std_dev = np.sqrt(sta_variance)\n\n        # 3. Monte Carlo simulation\n        delta_peaks = np.zeros(M)\n        for m in range(M):\n            # Generate a simulated STA estimate k_hat(t) = k(t) + noise\n            noise = rng.normal(loc=0.0, scale=sta_std_dev, size=L)\n            k_hat = k_true + noise\n\n            # 4. Identify early and late peak times\n            \n            # Early component support: t = tau_b\n            # In Python slicing, this corresponds to indices 0 through tau_b.\n            early_support_values = k_hat[:tau_b + 1]\n            t_early = np.argmax(early_support_values)\n\n            # Late component support: t >= tau_b\n            late_support_values = k_hat[tau_b:]\n            # np.argmax returns the index relative to the start of the slice.\n            t_late_relative = np.argmax(late_support_values)\n            t_late = tau_b + t_late_relative\n\n            # Compute the difference and store it\n            delta_peaks[m] = t_late - t_early\n\n        # 5. Form the confidence interval and test for significance\n        ci_lower, ci_upper = np.quantile(delta_peaks, [alpha, 1 - alpha])\n        \n        # The difference is significant if 0 does not lie within the CI.\n        is_significant = not (ci_lower = 0 and ci_upper >= 0)\n        results.append(is_significant)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当我们转向更强大的模型，如包含脉冲历史和正则化项的广义线性模型（GLM）时，正确的模型验证变得至关重要。这个练习挑战您辨别出适用于时间序列数据的严谨交叉验证流程，以避免信息泄漏等常见陷阱。掌握这项技能对于构建能够稳健泛化到新数据的预测性神经编码模型是必不可少的 。",
            "id": "4195514",
            "problem": "从单个神经元在时变刺激下收集了一个脉冲序列数据集，该数据集以宽度为 $\\Delta$ 的离散时间窗进行分箱。令 $t \\in \\{1,\\dots,T\\}$ 为时间窗的索引，令 $\\mathbf{s}_t \\in \\mathbb{R}^d$ 表示时间 $t$ 的刺激特征向量，令 $y_t \\in \\{0,1,2,\\dots\\}$ 表示在时间窗 $t$ 中观测到的脉冲计数。假设一个点过程广义线性模型（GLM；Generalized Linear Model），该模型具有泊松观测模型和标准对数连接函数，其条件强度为\n$$\n\\lambda_t(\\boldsymbol{\\theta}) \\equiv \\exp\\!\\left(\\mathbf{k}^\\top \\mathbf{s}_t + \\mathbf{h}^\\top \\mathbf{y}_{t-1:t-p} + c\\right),\n$$\n其中 $\\boldsymbol{\\theta} = (\\mathbf{k},\\mathbf{h},c)$ 是参数，$\\mathbf{y}_{t-1:t-p} = (y_{t-1},\\dots,y_{t-p})$ 编码了延迟至多为 $p$ 的脉冲历史，$c$ 是一个标量偏置。在宽度为 $\\Delta$ 的分箱下，假设以协变量和过去的脉冲为条件，各时间窗之间独立地满足 $y_t \\sim \\text{Poisson}(\\lambda_t(\\boldsymbol{\\theta}) \\Delta)$。在不考虑一个与 $\\boldsymbol{\\theta}$ 无关的加性常数的情况下，对数似然为\n$$\n\\ell(\\boldsymbol{\\theta};\\{y_t,\\mathbf{s}_t\\}_{t=1}^T) = \\sum_{t=1}^T \\left[ y_t \\log \\lambda_t(\\boldsymbol{\\theta}) - \\lambda_t(\\boldsymbol{\\theta}) \\Delta \\right].\n$$\n为防止过拟合，模型使用由一个非负正则化参数 $\\lambda \\ge 0$ 加权的 $\\ell_2$ 惩罚项 $R(\\boldsymbol{\\theta}) = \\|\\mathbf{k}\\|_2^2 + \\|\\mathbf{h}\\|_2^2$ 进行拟合。您希望通过 $K$ 折交叉验证来选择 $\\lambda$，该方法需要尊重由 $\\mathbf{y}_{t-1:t-p}$ 引起的时间依赖性，并能对样本外预测性能给出一个科学上可辩护的近似。\n\n哪个选项正确地概述了用于选择 $\\lambda$ 的科学合理的 $K$ 折交叉验证过程，并指定了需要对 $\\lambda$ 最小化的正确目标函数？\n\nA. 将 $T$ 个时间窗划分为 $K$ 个大致等长的连续验证折 $\\{V_k\\}_{k=1}^K$，对于每个验证折 $V_k$，将其训练集 $U_k$ 定义为 $\\{1,\\dots,T\\}$ 中 $V_k$ 的补集，并加上紧邻 $V_k$ 之前的一个长度为 $p$ 的缓冲区到 $U_k$ 中，但将其从验证评分中排除，以防止脉冲历史项造成的信息泄漏。对于网格 $\\Lambda$ 上的每个候选 $\\lambda$，通过在 $U_k$ 上最大化 $\\ell(\\boldsymbol{\\theta};\\{y_t,\\mathbf{s}_t\\}_{t \\in U_k}) - \\lambda R(\\boldsymbol{\\theta})$ 来拟合 $\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}$。然后在 $V_k$（排除其前 $p$ 个时间窗）上计算每个时间窗的验证负对数似然，\n$$\nL_k(\\lambda) = -\\frac{1}{|V_k'|} \\sum_{t \\in V_k'} \\left[ y_t \\log \\lambda_t\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right) - \\lambda_t\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right)\\Delta \\right],\n$$\n其中 $V_k'$ 是移除了前 $p$ 个时间窗的验证索引。选择 $\\lambda^\\star = \\arg\\min_{\\lambda \\in \\Lambda} \\bar{L}(\\lambda)$，其中 $\\bar{L}(\\lambda) = \\frac{1}{K} \\sum_{k=1}^K L_k(\\lambda)$。\n\nB. 随机排列 $T$ 个时间窗，将它们分成 $K$ 个大小相等的非连续折，对于每个 $\\lambda$，通过在训练索引上最大化 $\\ell(\\boldsymbol{\\theta};\\{y_t,\\mathbf{s}_t\\}_{t \\in U_k}) - \\lambda R(\\boldsymbol{\\theta})$ 来拟合 $\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}$。然后通过最小化各折的平均正则化训练目标来选择 $\\lambda$，\n$$\n\\frac{1}{K} \\sum_{k=1}^K \\left\\{ -\\ell\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)};\\{y_t,\\mathbf{s}_t\\}_{t \\in U_k}\\right) + \\lambda R\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right) \\right\\}.\n$$\n\nC. 将 $T$ 个时间窗划分为 $K$ 个连续的折。对于每个 $\\lambda$，通过在 $U_k$ 上最大化 $\\ell(\\boldsymbol{\\theta};\\{y_t,\\mathbf{s}_t\\}_{t \\in U_k}) - \\lambda R(\\boldsymbol{\\theta})$ 来拟合 $\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}$。然后在 $V_k$ 上计算验证分数，作为带惩罚的负对数似然，\n$$\nL_k^{\\text{pen}}(\\lambda) = - \\sum_{t \\in V_k} \\left[ y_t \\log \\lambda_t\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right) - \\lambda_t\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right)\\Delta \\right] + \\lambda R\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right),\n$$\n并选择 $\\lambda$ 以最小化 $\\frac{1}{K} \\sum_{k=1}^K L_k^{\\text{pen}}(\\lambda)$。\n\nD. 将 $T$ 个时间窗划分为 $K$ 个连续的折。对于每个 $\\lambda$，在 $U_k$ 上拟合 $\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}$。在 $V_k$ 上，计算预测速率与单位时间观测脉冲计数之间的均方误差，\n$$\n\\text{MSE}_k(\\lambda) = \\frac{1}{|V_k|} \\sum_{t \\in V_k} \\left( \\lambda_t\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right) - \\frac{y_t}{\\Delta} \\right)^2,\n$$\n并选择最小化 $\\frac{1}{K} \\sum_{k=1}^K \\text{MSE}_k(\\lambda)$ 的 $\\lambda$。",
            "solution": "用户提供了一个关于将点过程广义线性模型（GLM）应用于神经脉冲序列数据的超参数调整问题。我的任务是首先验证问题陈述，如果其有效，则推导出正确解并评估给定的选项。\n\n### 问题验证\n\n#### 第1步：提取给定信息\n\n-   **数据来源**：来自单个神经元的脉冲序列数据集。\n-   **时间离散化**：宽度为 $\\Delta$ 的离散时间窗，由 $t \\in \\{1,\\dots,T\\}$ 索引。\n-   **刺激数据**：$\\mathbf{s}_t \\in \\mathbb{R}^d$ 是时间 $t$ 的刺激特征向量。\n-   **脉冲数据**：$y_t \\in \\{0,1,2,\\dots\\}$ 是时间窗 $t$ 内的脉冲计数。\n-   **模型**：具有泊松观测模型和标准对数连接函数的点过程 GLM。\n-   **条件强度**：模型的条件强度函数由下式给出\n    $$\n    \\lambda_t(\\boldsymbol{\\theta}) \\equiv \\exp\\!\\left(\\mathbf{k}^\\top \\mathbf{s}_t + \\mathbf{h}^\\top \\mathbf{y}_{t-1:t-p} + c\\right)\n    $$\n-   **参数**：参数向量为 $\\boldsymbol{\\theta} = (\\mathbf{k},\\mathbf{h},c)$。\n-   **历史依赖性**：模型依赖于延迟至多为 $p$ 的脉冲历史向量 $\\mathbf{y}_{t-1:t-p} = (y_{t-1},\\dots,y_{t-p})$。\n-   **观测模型**：假设每个时间窗中的脉冲计数服从泊松分布，$y_t \\sim \\text{Poisson}(\\lambda_t(\\boldsymbol{\\theta}) \\Delta)$，以协变量和过去的脉冲为条件，并且在各个时间窗之间独立。\n-   **对数似然函数**：在不考虑一个与 $\\boldsymbol{\\theta}$ 无关的常数的情况下，对数似然为\n    $$\n    \\ell(\\boldsymbol{\\theta};\\{y_t,\\mathbf{s}_t\\}_{t=1}^T) = \\sum_{t=1}^T \\left[ y_t \\log \\lambda_t(\\boldsymbol{\\theta}) - \\lambda_t(\\boldsymbol{\\theta}) \\Delta \\right].\n    $$\n-   **正则化**：应用由超参数 $\\lambda \\ge 0$ 加权的 $\\ell_2$ 惩罚项 $R(\\boldsymbol{\\theta}) = \\|\\mathbf{k}\\|_2^2 + \\|\\mathbf{h}\\|_2^2$。\n-   **目标**：使用 $K$ 折交叉验证选择最优的正则化参数 $\\lambda$。\n-   **约束**：交叉验证过程必须在科学上是可辩护的，特别是要尊重数据中的时间依赖性，并提供对样本外预测性能的良好估计。\n\n#### 第2步：使用提取的给定信息进行验证\n\n-   **科学依据**：该问题描述了一个泊松 GLM，这是用于建模神经脉冲序列的一个标准且非常成功的框架。条件强度的公式、泊松观测模型、由此产生的对数似然函数（这是泊松过程的正确形式，忽略了常数）以及 $\\ell_2$ 正则化的使用，都是计算神经科学中标准且科学上合理的实践。\n-   **良定性**：该问题是良定的。它要求为给定的统计模型通过交叉验证选择超参数（$\\lambda$）的正确程序。这是统计学习中一个明确定义的任务。\n-   **客观性**：该问题使用精确、客观和标准的数学及统计术语来陈述。没有主观或含糊的陈述。\n-   **缺陷检查**：\n    1.  **科学/事实不合理**：无。模型和方法都是标准的。\n    2.  **非形式化/不相关**：无。该问题是神经科学数据分析中一个形式化且相关的问题。\n    3.  **设置不完整/矛盾**：无。模型和任务的所有必要组成部分都已定义。\n    4.  **不切实际/不可行**：无。这是研究人员面临的一个常见且实际的问题。\n    5.  **病态/结构不良**：无。问题清晰，要求从一组选项中确定正确的程序。\n    6.  **伪深刻/琐碎**：无。该问题解决了将交叉验证应用于时间序列数据的一个关键微妙之处，即保持时间结构和处理历史依赖性。这是一个非凡的概念点。\n    7.  **超出科学可验证性**：无。统计程序的正确性在数学和理论上是可验证的。\n\n#### 第3步：结论与行动\n\n问题陈述是**有效的**。它在科学上是合理的，是良定的，并且没有任何列出的缺陷。我现在将着手解决这个问题。\n\n### 解题推导\n\n核心任务是为时间序列模型设计一个交叉验证方案。标准的 $K$ 折交叉验证涉及数据的随机划分，这并不合适，因为它破坏了数据中固有的时间依赖性。对于一个在时间 $t$ 的预测依赖于时间 $t-1, \\dots, t-p$ 的输出的模型，使用“未来”的数据点进行训练来预测“过去”，将违反时间之箭，并导致对模型真实样本外性能的高度乐观和不正确的估计。\n\n针对时间序列数据的科学合理的交叉验证程序必须遵守两个主要原则：\n1.  **保持时间顺序**：必须以保持时间顺序的方式分割数据。这通常通过使用连续的数据块进行训练和验证来实现。$K$ 折交叉验证可以通过将时间序列分割成 $K$ 个连续、不重叠的块来调整。对于每次运行，一个块用于验证，其余块用于训练。\n2.  **正确处理历史依赖性**：模型的预测 $\\lambda_t$ 依赖于脉冲历史 $\\mathbf{y}_{t-1:t-p}$。在验证块 $V_k$ 上评估模型时，必须特别注意前 $p$ 个时间窗。这些时间窗的历史可能落在训练块内。使用模型训练期间可用的历史来为这些时间窗进行预测，可能导致信息泄漏。防止这种情况最严谨的方法是将验证块的这前 $p$ 个时间窗从验证误差的计算中排除。\n\n交叉验证的目标是选择能够最大化模型预测新的、未见数据的能力的超参数（$\\lambda$）。对于像泊松 GLM 这样的概率模型，衡量预测性能的自然且理论上正确的度量是在训练好的模型下验证数据的似然。因此，要优化的交叉验证指标应该是留出验证集上的平均对数似然。惯例是最小化*负*对数似然。\n\n至关重要的是，正则化项 $\\lambda R(\\boldsymbol{\\theta})$ *不应*包含在验证集性能指标中。惩罚项是训练目标函数的一部分，旨在将参数估计偏向于更简单的模型以防止过拟合。在留出集上的性能应该只衡量预测准确性，这由未惩罚的对数似然来捕捉。\n\n基于这些原则，正确的程序是：\n1.  将时间序列 $\\{1, \\dots, T\\}$ 划分为 $K$ 个连续的块。\n2.  对于每个折 $k \\in \\{1, \\dots, K\\}$，使用块 $k$ 作为验证集 $V_k$，其余 $K-1$ 个块作为训练集 $U_k$。\n3.  对于每个候选超参数 $\\lambda$，通过最大化惩罚对数似然 $\\ell(\\boldsymbol{\\theta}; U_k) - \\lambda R(\\boldsymbol{\\theta})$，在 $U_k$ 上训练模型，以获得参数 $\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}$。\n4.  在修剪过的验证集 $V_k'$ 上评估模型，其中 $V_k'$ 是 $V_k$ 去掉其前 $p$ 个时间窗后的集合。\n5.  折 $k$ 的性能分数是 $V_k'$ 上的负对数似然，通常按每个时间窗进行平均：$-\\frac{1}{|V_k'|} \\ell(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}; V_k')$。\n6.  对所有 $K$ 个折的分数进行平均，以获得 $\\lambda$ 的样本外误差估计。\n7.  选择最小化此平均误差的 $\\lambda$。\n\n### 逐项分析\n\n**A. 将 $T$ 个时间窗划分为 $K$ 个大致等长的连续验证折 $\\{V_k\\}_{k=1}^K$，对于每个验证折 $V_k$，将其训练集 $U_k$ 定义为 $\\{1,\\dots,T\\}$ 中 $V_k$ 的补集，并加上紧邻 $V_k$ 之前的一个长度为 $p$ 的缓冲区到 $U_k$ 中，但将其从验证评分中排除，以防止脉冲历史项造成的信息泄漏。对于网格 $\\Lambda$ 上的每个候选 $\\lambda$，通过在 $U_k$ 上最大化 $\\ell(\\boldsymbol{\\theta};\\{y_t,\\mathbf{s}_t\\}_{t \\in U_k}) - \\lambda R(\\boldsymbol{\\theta})$ 来拟合 $\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}$。然后在 $V_k$（排除其前 $p$ 个时间窗）上计算每个时间窗的验证负对数似然，**\n$$ L_k(\\lambda) = -\\frac{1}{|V_k'|} \\sum_{t \\in V_k'} \\left[ y_t \\log \\lambda_t\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right) - \\lambda_t\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right)\\Delta \\right], $$\n**其中 $V_k'$ 是移除了前 $p$ 个时间窗的验证索引。选择 $\\lambda^\\star = \\arg\\min_{\\lambda \\in \\Lambda} \\bar{L}(\\lambda)$，其中 $\\bar{L}(\\lambda) = \\frac{1}{K} \\sum_{k=1}^K L_k(\\lambda)$。**\n\n该选项正确地实施了上述所有原则。它使用连续的折，尊重时间顺序，并通过从评分中移除验证集的前 $p$ 个时间窗来正确处理时间序列交叉验证的一个关键微妙之处，以防止信息泄漏。验证指标是留出数据上的未惩罚负对数似然，这是该模型的适当评分规则。训练目标和最终选择标准都是正确的。提及“缓冲区”是一个次要细节，但修剪验证集（$V_k'$）的关键操作被正确指定，并使过程严谨。\n**结论：正确。**\n\n**B. 随机排列 $T$ 个时间窗，将它们分成 $K$ 个大小相等的非连续折，对于每个 $\\lambda$，通过在训练索引上最大化 $\\ell(\\boldsymbol{\\theta};\\{y_t,\\mathbf{s}_t\\}_{t \\in U_k}) - \\lambda R(\\boldsymbol{\\theta})$ 来拟合 $\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}$。然后通过最小化各折的平均正则化训练目标来选择 $\\lambda$，**\n$$ \\frac{1}{K} \\sum_{k=1}^K \\left\\{ -\\ell\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)};\\{y_t,\\mathbf{s}_t\\}_{t \\in U_k}\\right) + \\lambda R\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right) \\right\\}. $$\n该选项在两个基本点上是错误的。首先，对于时间序列数据，随机排列时间窗是错误的，因为它破坏了模型旨在捕捉的时间结构。其次，它建议通过最小化*训练目标*而不是*验证*指标来选择 $\\lambda$。这违背了交叉验证的目的，并会导致选择一个过拟合训练数据的模型（通常会选择 $\\lambda \\approx 0$）。\n**结论：不正确。**\n\n**C. 将 $T$ 个时间窗划分为 $K$ 个连续的折。对于每个 $\\lambda$，通过在 $U_k$ 上最大化 $\\ell(\\boldsymbol{\\theta};\\{y_t,\\mathbf{s}_t\\}_{t \\in U_k}) - \\lambda R(\\boldsymbol{\\theta})$ 来拟合 $\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}$。然后在 $V_k$ 上计算验证分数，作为带惩罚的负对数似然，**\n$$ L_k^{\\text{pen}}(\\lambda) = - \\sum_{t \\in V_k} \\left[ y_t \\log \\lambda_t\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right) - \\lambda_t\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right)\\Delta \\right] + \\lambda R\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right), $$\n**并选择 $\\lambda$ 以最小化 $\\frac{1}{K} \\sum_{k=1}^K L_k^{\\text{pen}}(\\lambda)$。**\n该选项正确地使用了连续的折，但犯了两个错误。首先，它在验证分数中包含了正则化惩罚项 $\\lambda R(\\boldsymbol{\\theta})$。验证分数应仅衡量对新数据的预测拟合度，而不是模型复杂度。包含惩罚项会使超参数选择产生偏差。其次，它未能解决验证折开始处的历史依赖性问题，使其不如选项 A 严谨。\n**结论：不正确。**\n\n**D. 将 $T$ 个时间窗划分为 $K$ 个连续的折。对于每个 $\\lambda$，在 $U_k$ 上拟合 $\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}$。在 $V_k$ 上，计算预测速率与单位时间观测脉冲计数之间的均方误差，**\n$$ \\text{MSE}_k(\\lambda) = \\frac{1}{|V_k|} \\sum_{t \\in V_k} \\left( \\lambda_t\\!\\left(\\hat{\\boldsymbol{\\theta}}_\\lambda^{(k)}\\right) - \\frac{y_t}{\\Delta} \\right)^2, $$\n**并选择最小化 $\\frac{1}{K} \\sum_{k=1}^K \\text{MSE}_k(\\lambda)$ 的 $\\lambda$。**\n该选项正确地使用了连续的折，但有两个缺陷。首先，它使用均方误差（MSE）作为验证指标。对于泊松分布的计数变量，MSE 不是最合适的评分规则。对数似然是统计学上更具原则性的选择，因为它直接关系到模型下观测数据的概率，并恰当地考虑了泊松分布的均值-方差关系。其次，与选项 C 一样，它未能解决折边界处的历史依赖性问题。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}