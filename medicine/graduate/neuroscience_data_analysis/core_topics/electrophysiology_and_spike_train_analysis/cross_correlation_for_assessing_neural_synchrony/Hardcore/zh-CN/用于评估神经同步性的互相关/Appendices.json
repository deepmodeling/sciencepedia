{
    "hands_on_practices": [
        {
            "introduction": "在识别神经同步性之前，我们必须首先理解在没有同步性的情况下，互相关图应该是什么样子。这个练习为完全独立这一零假设建立了理论基线，即两个神经元的放电活动毫无关联。\n\n通过将脉冲序列严谨地建模为独立的泊松过程，你将能够推导出它们互相关图的期望形状。完成这个推导练习  能让你深刻理解，对于统计上独立的神经元，其巧合放电的期望数量在所有时间延迟上是恒定的，从而产生一个“平坦”的互相关图，其高度仅取决于各个神经元的平均放电率。",
            "id": "4151144",
            "problem": "两个同时记录的神经元产生的脉冲序列被建模为观测区间 $[0,T]$ 上的独立同质泊松点过程，分别记为 $X$ 和 $Y$，其恒定强度（率）分别为 $\\lambda_{x}$ 和 $\\lambda_{y}$。根据同质性，对于任意长度为 $L$ 的区间，脉冲计数的期望值为 $\\lambda L$；根据独立性，不相交区间内以及不同过程之间的脉冲计数是独立的。考虑以下在时滞 $\\tau \\in \\mathbb{R}$ 处、窗宽为 $\\Delta > 0$ 的分箱互相关图估计量，用于估计单位时间内的滞后巧合：\n$$\n\\hat{C}_{xy}(\\tau) \\equiv \\frac{1}{T} \\sum_{t_{i} \\in X \\cap [0,T]} N_{Y}\\big([t_{i} + \\tau,\\, t_{i} + \\tau + \\Delta)\\big),\n$$\n其中 $N_{Y}(I)$ 表示过程 $Y$ 在区间 $I$ 内的脉冲计数。假设 $T$ 很大且 $|\\tau| + \\Delta \\ll T$，因此在计算期望值时可以忽略边界效应。仅从同质泊松过程的定义以及 $X$ 和 $Y$ 的独立性出发，推导出期望值 $\\mathbb{E}[\\hat{C}_{xy}(\\tau)]$ 关于 $\\lambda_{x}$、$\\lambda_{y}$ 和 $\\Delta$ 的显式表达式，并证明其不依赖于 $\\tau$。请以单一闭式解析表达式的形式给出最终答案。不需要进行数值近似。",
            "solution": "问题要求计算分箱互相关图估计量的期望值 $\\mathbb{E}[\\hat{C}_{xy}(\\tau)]$，其中涉及两个独立的同质泊松脉冲序列 $X$ 和 $Y$，其恒定强度分别为 $\\lambda_x$ 和 $\\lambda_y$。\n\n该估计量定义为：\n$$\n\\hat{C}_{xy}(\\tau) \\equiv \\frac{1}{T} \\sum_{t_{i} \\in X \\cap [0,T]} N_{Y}\\big([t_{i} + \\tau,\\, t_{i} + \\tau + \\Delta)\\big)\n$$\n其中 $T$ 是观测区间时长，$\\Delta$ 是窗宽，$\\tau$ 是时滞，$t_i$ 是过程 $X$ 的脉冲时间，$N_Y(I)$ 是过程 $Y$ 在给定区间 $I$ 内的脉冲数量。\n\n我们首先对 $\\hat{C}_{xy}(\\tau)$ 的定义应用期望算子：\n$$\n\\mathbb{E}[\\hat{C}_{xy}(\\tau)] = \\mathbb{E}\\left[ \\frac{1}{T} \\sum_{t_{i} \\in X \\cap [0,T]} N_{Y}\\big([t_{i} + \\tau,\\, t_{i} + \\tau + \\Delta)\\big) \\right]\n$$\n根据期望的线性性质，常数因子 $\\frac{1}{T}$ 可以移到期望符号外面：\n$$\n\\mathbb{E}[\\hat{C}_{xy}(\\tau)] = \\frac{1}{T} \\mathbb{E}\\left[ \\sum_{t_{i} \\in X \\cap [0,T]} N_{Y}\\big([t_{i} + \\tau,\\, t_{i} + \\tau + \\Delta)\\big) \\right]\n$$\n求和是针对点过程 $X$ 的脉冲时间 $\\{t_i\\}$ 进行的，而这些脉冲时间本身就是随机变量。为了计算这个和的期望，我们应用全期望定律（也称为塔性质），通过对脉冲序列 $X$ 的实现进行条件化。设过程 $X$ 的特定实现为脉冲时间集合 $\\{t_i\\}$。\n$$\n\\mathbb{E}\\left[ \\sum_{t_{i} \\in X \\cap [0,T]} \\dots \\right] = \\mathbb{E}_{X}\\left[ \\mathbb{E}_{Y}\\left[ \\sum_{t_{i} \\in X \\cap [0,T]} N_{Y}\\big([t_{i} + \\tau,\\, t_{i} + \\tau + \\Delta)\\big) \\bigg| X = \\{t_i\\} \\right] \\right]\n$$\n问题陈述过程 $X$ 和 $Y$ 是独立的。因此，以 $X$ 为条件不会改变 $Y$ 的统计特性。内部对 $Y$ 的期望可以通过将 $X$ 的脉冲时间 $\\{t_i\\}$ 视为固定值来计算。\n$$\n= \\mathbb{E}_{X}\\left[ \\sum_{t_{i} \\in X \\cap [0,T]} \\mathbb{E}_{Y}\\left[ N_{Y}\\big([t_{i} + \\tau,\\, t_{i} + \\tau + \\Delta)\\big) \\right] \\right]\n$$\n接下来，我们计算内部期望 $\\mathbb{E}_{Y}[\\dots]$。过程 $Y$ 是一个强度为 $\\lambda_y$ 的同质泊松过程。这种过程的一个基本性质是，在长度为 $L$ 的区间内，事件的期望数量是 $\\lambda_y L$。我们感兴趣的区间是 $[t_i + \\tau, t_i + \\tau + \\Delta)$，其长度为 $\\Delta$。因此，期望计数为：\n$$\n\\mathbb{E}_{Y}\\left[ N_{Y}\\big([t_{i} + \\tau,\\, t_{i} + \\tau + \\Delta)\\big) \\right] = \\lambda_y \\Delta\n$$\n这个结果是一个常数，与特定的脉冲时间 $t_i$ 和时滞 $\\tau$ 无关。这是过程 $Y$ 同质性的直接结果。将这个常数值代回我们的主表达式中：\n$$\n\\mathbb{E}\\left[ \\sum_{t_{i} \\in X \\cap [0,T]} \\dots \\right] = \\mathbb{E}_{X}\\left[ \\sum_{t_{i} \\in X \\cap [0,T]} (\\lambda_y \\Delta) \\right]\n$$\n常数项 $\\lambda_y \\Delta$ 可以从求和中提出来：\n$$\n= \\mathbb{E}_{X}\\left[ (\\lambda_y \\Delta) \\sum_{t_{i} \\in X \\cap [0,T]} 1 \\right]\n$$\n根据定义，和 $\\sum_{t_{i} \\in X \\cap [0,T]} 1$ 是过程 $X$ 在观测区间 $[0, T]$ 内的总脉冲数。这被记为 $N_X([0, T])$。\n$$\n= \\mathbb{E}_{X}\\left[ (\\lambda_y \\Delta) N_X([0, T]) \\right]\n$$\n将常数项 $\\lambda_y \\Delta$ 从期望中提出来，得到：\n$$\n= (\\lambda_y \\Delta) \\mathbb{E}_{X}\\left[ N_X([0, T]) \\right]\n$$\n现在，我们必须计算过程 $X$ 的期望脉冲数。由于 $X$ 是一个恒定强度为 $\\lambda_x$ 的同质泊松过程，在长度为 $T$ 的区间内的期望脉冲数为：\n$$\n\\mathbb{E}_{X}\\left[ N_X([0, T]) \\right] = \\lambda_x T\n$$\n问题陈述中提到我们可以忽略边界效应，这一点由假设 $|\\tau| + \\Delta \\ll T$ 所保证。这确保了我们的计算在整个区间上都成立。\n\n综合以上部分，求和项的期望为：\n$$\n\\mathbb{E}\\left[ \\sum_{t_{i} \\in X \\cap [0,T]} \\dots \\right] = (\\lambda_y \\Delta) (\\lambda_x T) = \\lambda_x \\lambda_y T \\Delta\n$$\n最后，我们将此结果代回到 $\\mathbb{E}[\\hat{C}_{xy}(\\tau)]$ 的表达式中：\n$$\n\\mathbb{E}[\\hat{C}_{xy}(\\tau)] = \\frac{1}{T} (\\lambda_x \\lambda_y T \\Delta) = \\lambda_x \\lambda_y \\Delta\n$$\n这个表达式是互相关图的期望值。它取决于两个神经元的发放率 $\\lambda_x$ 和 $\\lambda_y$，以及窗宽 $\\Delta$。正如所要求的，结果不依赖于时滞 $\\tau$，这是独立同质过程的一个特征，代表了随机巧合的期望率。",
            "answer": "$$\n\\boxed{\\lambda_{x} \\lambda_{y} \\Delta}\n$$"
        },
        {
            "introduction": "当从真实的、有限长度的神经记录中计算互相关时，一个被称为“边缘效应”的微妙偏差可能会扭曲结果。本练习旨在探讨这种偏差的来源，并指导你如何从根本上对其进行校正，这是确保分析准确性的关键一步。\n\n这个问题的核心在于，随着时间延迟 $|\\tau|$ 的增加，两个信号之间可用于计算相关的重叠数据量会减少。通过这个练习 ，你将推导出数学上正确的无偏估计量，并理解为什么归一化因子必须是 $1/(T-|\\tau|)$。掌握这一校正方法对于在不同时间延迟之间进行公允的相关强度比较至关重要。",
            "id": "4151174",
            "problem": "在灵长类动物视觉皮层中，同时记录的两个神经元产生脉冲序列，这些脉冲序列通过将每个脉冲序列与高斯核进行卷积，然后减去记录时段内的样本均值，从而转换为连续的速率信号，得到零均值信号。将这些零均值的连续时间过程表示为 $x(t)$ 和 $y(t)$，并假设其基础联合过程是宽平稳的（WSS），意味着其二阶统计量不依赖于绝对时间；并且是遍历的，意味着在长时间记录的极限情况下，集总平均等于时间平均。目标是从时长为 $T>0$ 秒的单次有限记录中，估计连续时间互相关函数 $R_{xy}(\\tau) = \\mathbb{E}[x(t)\\,y(t+\\tau)]$。记录的信号被截断到观测窗口内：$x_T(t) = x(t)\\,\\mathbb{1}_{[0,T]}(t)$ 和 $y_T(t) = y(t)\\,\\mathbb{1}_{[0,T]}(t)$，其中 $\\mathbb{1}_{A}(t)$ 是指示函数，当 $t\\in A$ 时其值为 $1$，否则为 $0$。一个自然的估计量是时间平均 $\\hat{R}_{0}(\\tau) = \\dfrac{1}{T}\\int_{0}^{T} x_T(t)\\,y_T(t+\\tau)\\,dt$，当 $|\\tau|$ 较大时，该估计量会受到边缘效应的影响，因为对于 $t$ 和 $t+\\tau$，只有部分窗口发生重叠。\n\n从上述定义以及宽平稳和遍历性假设出发，推断有限窗口的重叠如何影响 $\\hat{R}_{0}(\\tau)$ 的期望值，并找出一个归一化方法来消除这种 $|\\tau|$ 依赖性的偏差，从而得到一个无偏估计量。假设 $\\tau \\ge 0$，以下哪个是 $R_{xy}(\\tau)$ 的无偏估计量？\n\nA) $\\hat{R}_{A}(\\tau) = \\dfrac{1}{T}\\int_{0}^{T-\\tau} x(t)\\,y(t+\\tau)\\,dt$\n\nB) $\\hat{R}_{B}(\\tau) = \\dfrac{1}{T-\\tau}\\int_{0}^{T-\\tau} x(t)\\,y(t+\\tau)\\,dt$\n\nC) $\\hat{R}_{C}(\\tau) = \\dfrac{1}{T+\\tau}\\int_{0}^{T} x(t)\\,y(t+\\tau)\\,dt$\n\nD) $\\hat{R}_{D}(\\tau) = \\dfrac{1}{T}\\int_{0}^{T} x(t)\\,y(t+\\tau)\\,dt$",
            "solution": "该问题要求我们从一个有偏的互相关估计量出发，推导出一个无偏的估计量来校正边缘效应。\n\n#### 1. 分析有偏估计量\n\n给定的有偏估计量是：\n$$ \\hat{R}_{0}(\\tau) = \\frac{1}{T}\\int_{0}^{T} x_T(t)\\,y_T(t+\\tau)\\,dt $$\n其中 $x_T(t) = x(t)\\,\\mathbb{1}_{[0,T]}(t)$ 和 $y_T(t) = y(t)\\,\\mathbb{1}_{[0,T]}(t)$。\n为了评估其偏差，我们计算它的期望值 $\\mathbb{E}[\\hat{R}_{0}(\\tau)]$。\n$$ \\mathbb{E}[\\hat{R}_{0}(\\tau)] = \\mathbb{E}\\left[ \\frac{1}{T}\\int_{0}^{T} x_T(t)\\,y_T(t+\\tau)\\,dt \\right] $$\n利用期望的线性性质，我们可以将期望算子移到积分内部（根据Fubini-Tonelli定理）：\n$$ \\mathbb{E}[\\hat{R}_{0}(\\tau)] = \\frac{1}{T}\\int_{0}^{T} \\mathbb{E}[x_T(t)\\,y_T(t+\\tau)]\\,dt $$\n现在我们分析被积函数 $\\mathbb{E}[x_T(t)\\,y_T(t+\\tau)]$。代入 $x_T$ 和 $y_T$ 的定义：\n$$ \\mathbb{E}[x_T(t)\\,y_T(t+\\tau)] = \\mathbb{E}[x(t)\\,\\mathbb{1}_{[0,T]}(t) \\cdot y(t+\\tau)\\,\\mathbb{1}_{[0,T]}(t+\\tau)] $$\n指示函数 $\\mathbb{1}$ 是确定性的，可以移出期望：\n$$ = \\mathbb{E}[x(t)\\,y(t+\\tau)] \\cdot \\mathbb{1}_{[0,T]}(t) \\cdot \\mathbb{1}_{[0,T]}(t+\\tau) $$\n根据宽平稳（WSS）假设，$\\mathbb{E}[x(t)\\,y(t+\\tau)]$ 等于真实的互相关函数 $R_{xy}(\\tau)$，它不依赖于 $t$。\n$$ = R_{xy}(\\tau) \\cdot \\mathbb{1}_{[0,T]}(t) \\cdot \\mathbb{1}_{[0,T]}(t+\\tau) $$\n\n#### 2. 确定积分的有效范围\n\n被积函数不为零的条件是两个指示函数都为1，即：\n1.  $t \\in [0, T]$\n2.  $t+\\tau \\in [0, T]$  =>  $t \\in [-\\tau, T-\\tau]$\n\n问题中假设 $\\tau \\ge 0$。因此，要同时满足这两个条件，$t$ 必须在两个区间的交集内：\n$$ t \\in [0, T] \\cap [-\\tau, T-\\tau] = [0, T-\\tau] $$\n这意味着积分的有效范围是 $[0, T-\\tau]$，其长度为 $T-\\tau$。在此范围之外，被积函数为零。\n\n#### 3. 计算期望值并推导无偏估计量\n\n将上述结果代回期望值的计算中：\n$$ \\mathbb{E}[\\hat{R}_{0}(\\tau)] = \\frac{1}{T}\\int_{0}^{T-\\tau} R_{xy}(\\tau)\\,dt $$\n由于 $R_{xy}(\\tau)$ 是一个关于 $t$ 的常数，我们可以将其移出积分：\n$$ \\mathbb{E}[\\hat{R}_{0}(\\tau)] = \\frac{R_{xy}(\\tau)}{T} \\int_{0}^{T-\\tau} 1\\,dt = \\frac{R_{xy}(\\tau)}{T} (T-\\tau) = \\left(1 - \\frac{\\tau}{T}\\right) R_{xy}(\\tau) $$\n这个结果表明，原始估计量 $\\hat{R}_{0}(\\tau)$ 是有偏的，其期望值会随着 $\\tau$ 的增加而衰减。\n\n为了得到一个无偏估计量 $\\hat{R}_{\\text{unbiased}}(\\tau)$，其期望值应为 $R_{xy}(\\tau)$。我们可以通过对原始积分进行不同的归一化来实现。原始积分部分为：\n$$ \\int_{0}^{T} x_T(t)\\,y_T(t+\\tau)\\,dt = \\int_{0}^{T-\\tau} x(t)\\,y(t+\\tau)\\,dt $$\n我们已经知道这个积分的期望值是 $(T-\\tau)R_{xy}(\\tau)$。因此，要得到无偏估计，我们应该将这个积分除以它的有效时长 $(T-\\tau)$：\n$$ \\hat{R}_{\\text{unbiased}}(\\tau) = \\frac{1}{T-\\tau} \\int_{0}^{T-\\tau} x(t)\\,y(t+\\tau)\\,dt $$\n对于任意 $\\tau$ (正或负)，归一化因子是 $T-|\\tau|$。\n\n#### 4. 评估选项\n\n现在我们比较这个结果和给出的选项（假设 $\\tau \\ge 0$）：\n- A) $\\hat{R}_{A}(\\tau) = \\dfrac{1}{T}\\int_{0}^{T-\\tau} x(t)\\,y(t+\\tau)\\,dt$：这个估计量的期望值是 $\\frac{T-\\tau}{T}R_{xy}(\\tau)$，因此它是有偏的。\n- B) $\\hat{R}_{B}(\\tau) = \\dfrac{1}{T-\\tau}\\int_{0}^{T-\\tau} x(t)\\,y(t+\\tau)\\,dt$：这个估计量的期望值是 $\\frac{1}{T-\\tau} \\cdot (T-\\tau)R_{xy}(\\tau) = R_{xy}(\\tau)$。它是无偏的。\n- C) $\\hat{R}_{C}(\\tau) = \\dfrac{1}{T+\\tau}\\int_{0}^{T} x(t)\\,y(t+\\tau)\\,dt$：归一化因子和积分范围都不正确。\n- D) $\\hat{R}_{D}(\\tau) = \\dfrac{1}{T}\\int_{0}^{T} x(t)\\,y(t+\\tau)\\,dt$：积分范围不考虑信号的截断，这在物理上是不现实的，并且会导致在 $t > T-\\tau$ 处对未定义的 $y(t+\\tau)$ 进行积分。\n\n因此，选项 B 是正确的无偏估计量。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在互相关图中识别出一个峰值只是分析的第一步，更关键的问题是：这个峰值是真实神经相互作用的体现，还是仅仅源于数据的随机波动？这个编程练习将引导你实现一个完整的、现代化的统计流程，以对神经同步性进行严格的假设检验。\n\n本练习的核心是解决在多个时间延迟上进行检验时产生的多重比较问题。你将通过构建“代理”数据并采用非参数的最大统计量（max-statistic）置换检验方法，来有效控制族群错误率（Family-Wise Error Rate, FWER）。通过亲手构建这个模拟与分析工具 ，你将获得宝贵的实践经验，学会如何运用强大的统计框架来自信地区分真实的同步信号与背景噪声。",
            "id": "4151171",
            "problem": "考虑两个离散时间脉冲计数序列 $x_{t}$ 和 $y_{t}$，它们在持续时间 $T$ 内以固定的时间窗宽度 $d t$进行采样，其中 $t \\in \\{0,1,2,\\dots,N-1\\}$ 且 $N = \\lfloor T / d t \\rfloor$。目标是通过互相关图评估神经同步性，同时控制因跨延迟进行多重比较而增加的假阳性风险。从以下基础开始：\n\n- 两个等长（长度为 $m$）的有限序列 $a_{t}$ 和 $b_{t}$ 之间的 Pearson 相关系数定义为\n$$\nr(a,b) = \\frac{\\sum_{t=0}^{m-1} (a_{t} - \\bar{a})(b_{t} - \\bar{b})}{\\sqrt{\\sum_{t=0}^{m-1}(a_{t}-\\bar{a})^{2}} \\sqrt{\\sum_{t=0}^{m-1}(b_{t}-\\bar{b})^{2}}},\n$$\n其中 $\\bar{a}$ 和 $\\bar{b}$ 分别是 $a_{t}$ 和 $b_{t}$ 的样本均值。\n\n- $x_{t}$ 和 $y_{t}$ 之间的互相关图是关于整数延迟 $\\ell$ 的函数，其定义为计算 $x_{t}$ 和 $y_{t}$ 在该延迟下重叠片段的 Pearson 相关系数，即，对于 $\\ell \\geq 0$\n$$\nr(\\ell) = r\\big(x_{0:(N-1-\\ell)}, y_{\\ell:(N-1)}\\big),\n$$\n对于 $\\ell < 0$\n$$\nr(\\ell) = r\\big(x_{(-\\ell):(N-1)}, y_{0:(N-1+\\ell)}\\big).\n$$\n\n- 族错误率 (Family-Wise Error Rate, FWER) 是在一族同步假设检验中至少做出一次错误拒绝的概率。在此设定中，每个延迟 $\\ell \\in \\{-L,\\dots,+L\\}$ 都定义了一个在该延迟下是否存在过度相关的检验。为了将 FWER 控制在水平 $\\alpha$，您必须使用最大统计量方法：在无真实同步性的零假设下，通过对 $y_{t}$ 进行随机偏移量的循环平移（在保持平稳性的允许平移范围内均匀分布）来生成零代理数据，以破坏对齐关系，同时保留边际属性；为每个代理数据计算互相关图；对每个代理数据，取所有延迟下的最大绝对相关值；并使用这些最大值的经验 $(1-\\alpha)$ 分位数作为阈值 $t_{\\alpha}$，该阈值控制了整个延迟检验族的 FWER。然后，将那些观测到的绝对相关值超过 $t_{\\alpha}$ 的延迟宣告为显著。\n\n任务。实现一个程序，该程序：\n\n1. 通过将独立的泊松脉冲生成与一个附加的同步分量相结合，模拟具有真实神经脉冲结构的分箱脉冲计数序列 $x_{t}$ 和 $y_{t}$：\n   - 独立背景：将每个时间窗的 $x_{t}$ 和 $y_{t}$ 计数值作为独立的泊松随机变量进行抽取，其均值分别为 $\\lambda_{x} d t$ 和 $\\lambda_{y} d t$。\n   - 同步分量：在 $[0,T)$ 上以速率 $\\lambda_{\\mathrm{sync}}$ 抽取泊松数量的同步事件，将每个事件时间 $u$ 在 $x_{t}$ 中置于 $u + \\varepsilon_{x}$ 处，在 $y_{t}$ 中置于 $u + \\tau + \\varepsilon_{y}$ 处，其中 $\\tau$ 是一个固定的同步延迟，$\\varepsilon_{x}, \\varepsilon_{y}$ 是标准差为 $\\sigma$ 的独立高斯抖动（值被限制在 $[0,T)$ 范围内）。通过增加相应时间窗的计数值，将这些事件分箱到 $x_{t}$ 和 $y_{t}$ 中。\n\n2. 计算整数延迟 $\\ell \\in \\{-L,\\dots,+L\\}$ 的观测互相关图 $r(\\ell)$，其中 $L$ 以秒为单位指定，并通过 $L_{\\mathrm{bins}} = \\lfloor L / d t \\rfloor$ 转换为时间窗单位。\n\n3. 通过生成 $y_{t}$ 的 $K$ 个循环平移代理数据（每个代理数据 $y^{(k)}_{t}$ 是 $y_{(t+s_{k}) \\bmod N}$，其中 $s_{k}$ 是一个随机选择的平移量），为最大统计量构建一个零分布，为每个代理数据计算互相关图 $r^{(k)}(\\ell)$，并记录 $M_{k} = \\max_{\\ell \\in \\{-L,\\dots,+L\\}} \\left| r^{(k)}(\\ell) \\right|$。\n\n4. 将阈值 $t_{\\alpha}$ 确定为 $\\{M_{1},\\dots,M_{K}\\}$ 的经验 $(1-\\alpha)$ 分位数，并返回满足 $\\left| r(\\ell) \\right| \\geq t_{\\alpha}$ 的观测延迟 $\\ell$ 的集合，表示为以秒为单位的延迟值 $\\ell \\cdot d t$，四舍五入到三位小数。\n\n假设和约束：\n- 您必须将 $\\ell$ 视为整数个时间窗，并将延迟值转换为秒作为最终输出。\n- 使用循环平移生成代理数据，以在无同步性的零假设下保留 $y_{t}$ 的平稳性，同时打破其与 $x_{t}$ 的对齐关系。\n- 如果任何重叠片段的方差为零（所有计数值相同），则将该延迟下的相关性定义为 $0$，以避免出现未定义的值。\n- 所有时间量必须以秒为单位表示；延迟输出必须以秒为单位四舍五入到三位小数。\n- 每个测试用例的输出必须是一个浮点数列表（以秒为单位的延迟值），程序的聚合输出必须是一个单一列表，其中包含每个测试用例的这样一个列表。\n\n测试套件：\n为以下参数集实现程序。每个参数集是一个元组，指定了 $(T, d t, \\lambda_{x}, \\lambda_{y}, \\lambda_{\\mathrm{sync}}, \\tau, \\sigma, L, K, \\alpha, \\text{seed})$。使用提供的种子以确保确定性输出。\n\n- 案例 1：$(T = \\, 20, d t = \\, 0.005, \\lambda_{x} = \\, 15, \\lambda_{y} = \\, 15, \\lambda_{\\mathrm{sync}} = \\, 5, \\tau = \\, 0, \\sigma = \\, 0.003, L = \\, 0.025, K = \\, 200, \\alpha = \\, 0.05, \\text{seed} = \\, 101)$。\n\n- 案例 2：$(T = \\, 20, d t = \\, 0.005, \\lambda_{x} = \\, 15, \\lambda_{y} = \\, 15, \\lambda_{\\mathrm{sync}} = \\, 5, \\tau = \\, 0.015, \\sigma = \\, 0.003, L = \\, 0.025, K = \\, 200, \\alpha = \\, 0.05, \\text{seed} = \\, 102)$。\n\n- 案例 3：$(T = \\, 20, d t = \\, 0.005, \\lambda_{x} = \\, 15, \\lambda_{y} = \\, 15, \\lambda_{\\mathrm{sync}} = \\, 0, \\tau = \\, 0, \\sigma = \\, 0, L = \\, 0.025, K = \\, 200, \\alpha = \\, 0.05, \\text{seed} = \\, 103)$。\n\n- 案例 4（仅含零延迟的边界条件）：$(T = \\, 10, d t = \\, 0.005, \\lambda_{x} = \\, 20, \\lambda_{y} = \\, 20, \\lambda_{\\mathrm{sync}} = \\, 5, \\tau = \\, 0, \\sigma = \\, 0.002, L = \\, 0, K = \\, 200, \\alpha = \\, 0.05, \\text{seed} = \\, 104)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、逗号分隔的结果列表，每个元素是一个测试用例的显著延迟值列表（以秒为单位，四舍五入到三位小数）。例如，包含四个测试用例的输出必须类似于 $[\\,[0.000,0.015],\\,[0.000],\\,[\\,],\\,[0.000]\\,]$，其中空列表 $[\\,]$ 表示未检测到显著延迟。",
            "solution": "该方法基于统计检验原理和互相关图的定义。我们分步骤进行。\n\n1. 基本定义。对于在持续时间 $T$ 内以时间窗宽度 $d t$ 采样的离散时间脉冲计数序列 $x_{t}$ 和 $y_{t}$（其中有 $N = \\lfloor T / d t \\rfloor$ 个时间窗），两个等长片段的 Pearson 相关系数定义为\n$$\nr(a,b) = \\frac{\\sum_{t=0}^{m-1} (a_{t} - \\bar{a})(b_{t} - \\bar{b})}{\\sqrt{\\sum_{t=0}^{m-1}(a_{t}-\\bar{a})^{2}} \\sqrt{\\sum_{t=0}^{m-1}(b_{t}-\\bar{b})^{2}}}.\n$$\n互相关图 $r(\\ell)$ 在整数延迟 $\\ell$ 上应用此相关性于重叠片段。对于 $\\ell \\geq 0$，\n$$\nr(\\ell) = r\\big(x_{0:(N-1-\\ell)}, y_{\\ell:(N-1)}\\big),\n$$\n对于 $\\ell < 0$，\n$$\nr(\\ell) = r\\big(x_{(-\\ell):(N-1)}, y_{0:(N-1+\\ell)}\\big).\n$$\n如果任一重叠片段的方差为零，则相关性未定义；为保证稳健性，我们设定 $r(\\ell) = 0$。\n\n2. 跨延迟的多重比较和族错误率（FWER）。在每个延迟 $\\ell \\in \\{-L,\\dots,+L\\}$ 处检验 $H_{0}:\\text{无同步性}$ 会引入一族检验。族错误率（FWER）是 $P(\\text{在这些检验中至少出现一个假阳性})$。如果每个延迟检验都独立地在水平 $\\alpha$ 下运行，那么至少出现一个假阳性的概率会随着延迟数量的增加而增加。为了在水平 $\\alpha$ 控制 FWER 而不使用过于保守的校正，我们采用一种针对跨延迟依赖结构量身定制的最大统计量方法。\n\n3. 最大统计量方法。在无真实同步性的 $H_{0}$ 下，一个有效的零假设程序是通过随机偏移量 $s$（在 $\\{0,1,\\dots,N-1\\}$ 上均匀分布）循环平移 $y_{t}$ 来生成 $y^{(k)}_{t} = y_{(t+s_{k}) \\bmod N}$。这保留了 $y_{t}$ 的平稳性和边际分布，同时破坏了其与 $x_{t}$ 的对齐关系。对于每个代理数据 $k \\in \\{1,\\dots,K\\}$，计算在 $\\ell \\in \\{-L_{\\mathrm{bins}},\\dots,+L_{\\mathrm{bins}}\\}$ 上的互相关图 $r^{(k)}(\\ell)$ 并记录最大统计量\n$$\nM_{k} = \\max_{\\ell \\in \\{-L_{\\mathrm{bins}},\\dots,+L_{\\mathrm{bins}}\\}} \\left| r^{(k)}(\\ell) \\right|.\n$$\n$M_{k}$ 的零分布近似了 $H_{0}$ 下最大绝对相关性的抽样分布。令 $t_{\\alpha}$ 为 $\\{M_{1},\\dots,M_{K}\\}$ 的经验 $(1-\\alpha)$ 分位数。那么\n$$\nP\\left(\\max_{\\ell} \\left| r(\\ell) \\right| \\geq t_{\\alpha} \\,\\big|\\, H_{0}\\right) \\approx \\alpha,\n$$\n这意味着对于该延迟检验族，FWER 被控制在近似水平 $\\alpha$。因此，将满足 $\\left| r(\\ell) \\right| \\geq t_{\\alpha}$ 的延迟 $\\ell$ 宣告为显著，可以得到一组 FWER 受控的发现。\n\n4. 脉冲序列的模拟。为了生成真实的序列，我们将独立的泊松背景与同步事件相结合。对于每个时间窗，抽取独立的计数值：\n$$\nx_{t}^{\\text{bg}} \\sim \\text{Poisson}(\\lambda_{x} d t), \\quad y_{t}^{\\text{bg}} \\sim \\text{Poisson}(\\lambda_{y} d t).\n$$\n对于同步分量，以均值 $\\lambda_{\\mathrm{sync}} T$ 抽样一个泊松数量的事件。对于每个基准时间为 $u$ 的事件，生成受扰动的时间\n$$\nu_{x} = \\mathrm{clip}(u + \\varepsilon_{x}, 0, T), \\quad u_{y} = \\mathrm{clip}(u + \\tau + \\varepsilon_{y}, 0, T),\n$$\n其中 $\\varepsilon_{x}, \\varepsilon_{y} \\sim \\mathcal{N}(0,\\sigma^{2})$。通过增加相应时间窗的计数值，将这些时间分箱到 $x_{t}$ 和 $y_{t}$ 中：\n$$\nt_{x} = \\left\\lfloor \\frac{u_{x}}{d t} \\right\\rfloor, \\quad t_{y} = \\left\\lfloor \\frac{u_{y}}{d t} \\right\\rfloor.\n$$\n最终得到的序列是 $x_{t} = x_{t}^{\\text{bg}} + x_{t}^{\\text{sync}}$ 和 $y_{t} = y_{t}^{\\text{bg}} + y_{t}^{\\text{sync}}$。\n\n5. 算法步骤。\n- 将 $L$ 秒转换为时间窗单位：$L_{\\mathrm{bins}} = \\lfloor L / d t \\rfloor$。\n- 计算所有整数 $\\ell \\in \\{-L_{\\mathrm{bins}},\\dots,+L_{\\mathrm{bins}}\\}$ 的观测值 $r(\\ell)$。\n- 对于 $k = 1$ 到 $K$：从 $\\{0,1,\\dots,N-1\\}$ 中均匀抽取一个随机平移量 $s_{k}$，设置 $y^{(k)}_{t} = y_{(t+s_{k}) \\bmod N}$，计算跨延迟的 $r^{(k)}(\\ell)$，记录 $M_{k} = \\max_{\\ell} |r^{(k)}(\\ell)|$。\n- 计算 $t_{\\alpha}$ 作为 $\\{M_{k}\\}$ 的经验 $(1-\\alpha)$ 分位数。\n- 以秒为单位输出集合 $\\{\\ell \\cdot d t : |r(\\ell)| \\geq t_{\\alpha}\\}$，并四舍五入到三位小数。\n\n6. 边缘情况和边界条件。如果 $L=0$，则只执行零延迟检验；最大统计量简化为零延迟处的绝对相关值。如果任何重叠片段的方差为零，则设置 $r(\\ell)=0$ 以避免除以零。循环平移代理数据保留了 $y_t$ 中的自相关性，但在 $H_0$ 下使其与 $x_t$ 的对齐关系在效果上是随机的，这为其用于零最大统计量提供了理由。\n\n7. 输出规格。对于每个测试用例，程序返回一个以秒为单位的显著延迟值列表（四舍五入到三位小数）。最终的程序输出是包含这些列表的、用方括号括起来的、逗号分隔的单行列表。输出中所有延迟值的单位都是秒，$\\alpha$ 以小数形式指定（例如，$0.05$）。\n\n通过这些步骤，该实现使用跨延迟的最大统计量来控制族错误率（FWER），从而在互相关图中提供了有统计学原理支持的同步峰值检测。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_spike_counts(T, dt, rate_x, rate_y, sync_rate, tau, sigma, rng):\n    \"\"\"\n    Simulate binned spike-count sequences x_t and y_t:\n    - Independent Poisson background per bin.\n    - Add synchronous events with jitter and lag tau.\n    \"\"\"\n    N = int(np.floor(T / dt))\n    # Background Poisson counts\n    mean_x = rate_x * dt\n    mean_y = rate_y * dt\n    x_bg = rng.poisson(mean_x, size=N)\n    y_bg = rng.poisson(mean_y, size=N)\n\n    x = x_bg.copy()\n    y = y_bg.copy()\n\n    # Synchronous component\n    if sync_rate > 0:\n        n_sync = rng.poisson(sync_rate * T)\n        if n_sync > 0:\n            # Draw base event times uniformly over [0, T)\n            base_times = rng.random(n_sync) * T\n            # Jitters\n            jitter_x = rng.normal(0.0, sigma, size=n_sync) if sigma > 0 else np.zeros(n_sync)\n            jitter_y = rng.normal(0.0, sigma, size=n_sync) if sigma > 0 else np.zeros(n_sync)\n            # Compute event times for x and y, apply lag tau to y\n            times_x = base_times + jitter_x\n            times_y = base_times + tau + jitter_y\n            # Clamp to [0, T)\n            times_x = np.clip(times_x, 0.0, T - 1e-12)\n            times_y = np.clip(times_y, 0.0, T - 1e-12)\n            # Bin indices\n            bins_x = np.floor(times_x / dt).astype(int)\n            bins_y = np.floor(times_y / dt).astype(int)\n            # Increment counts\n            # Multiple events can land in the same bin; use add.at for correctness\n            np.add.at(x, bins_x, 1)\n            np.add.at(y, bins_y, 1)\n\n    return x, y\n\ndef pearson_corr(x_seg, y_seg):\n    \"\"\"\n    Compute Pearson correlation for two equal-length 1D arrays.\n    If std dev of either segment is zero, return 0.\n    Uses sample correlation with denominator (n-1)*std_x*std_y.\n    \"\"\"\n    n = x_seg.size\n    if n  2:\n        return 0.0\n    x_mean = x_seg.mean()\n    y_mean = y_seg.mean()\n    x_center = x_seg - x_mean\n    y_center = y_seg - y_mean\n    sx = x_center.std(ddof=1)\n    sy = y_center.std(ddof=1)\n    if sx == 0 or sy == 0:\n        return 0.0\n    cov = np.dot(x_center, y_center) / (n - 1)\n    return cov / (sx * sy)\n\ndef correlogram(x, y, L_bins):\n    \"\"\"\n    Compute Pearson cross-correlogram r(lag) for lags in [-L_bins, ..., +L_bins].\n    \"\"\"\n    N = x.size\n    lags = np.arange(-L_bins, L_bins + 1, dtype=int)\n    r_vals = np.zeros(lags.shape[0], dtype=float)\n    for i, lag in enumerate(lags):\n        if lag >= 0:\n            x_seg = x[:N - lag] if lag != 0 else x\n            y_seg = y[lag:] if lag != 0 else y\n        else:\n            k = -lag\n            x_seg = x[k:]\n            y_seg = y[:N - k]\n        r_vals[i] = pearson_corr(x_seg, y_seg)\n    return lags, r_vals\n\ndef max_stat_threshold(x, y, L_bins, K, alpha, rng):\n    \"\"\"\n    Build null distribution via circular shifts of y and return the (1-alpha) quantile threshold.\n    \"\"\"\n    N = x.size\n    max_vals = np.empty(K, dtype=float)\n    # Precompute shifts\n    shifts = rng.integers(0, N, size=K)\n    for k in range(K):\n        y_shift = np.roll(y, shifts[k])\n        _, r_vals = correlogram(x, y_shift, L_bins)\n        max_vals[k] = np.max(np.abs(r_vals))\n    # Empirical (1 - alpha) quantile; use 'higher' to be conservative in FWER control\n    threshold = np.quantile(max_vals, 1.0 - alpha, method='higher')\n    return threshold\n\ndef run_test_case(params):\n    \"\"\"\n    Execute one test case: simulate data, compute correlogram, compute max-stat threshold,\n    and return list of significant lags (in seconds, rounded to 3 decimals).\n    params: (T, dt, rate_x, rate_y, sync_rate, tau, sigma, L, K, alpha, seed)\n    \"\"\"\n    T, dt, rate_x, rate_y, sync_rate, tau, sigma, L, K, alpha, seed = params\n    rng = np.random.default_rng(seed)\n    x, y = simulate_spike_counts(T, dt, rate_x, rate_y, sync_rate, tau, sigma, rng)\n    L_bins = int(np.floor(L / dt))\n    lags_bins, r_obs = correlogram(x, y, L_bins)\n    thr = max_stat_threshold(x, y, L_bins, K, alpha, rng)\n    sig_mask = np.abs(r_obs) >= thr\n    sig_lags_sec = (lags_bins[sig_mask].astype(float) * dt).tolist()\n    # Round to 3 decimals for output\n    sig_lags_sec_rounded = [round(val, 3) for val in sig_lags_sec]\n    return sig_lags_sec_rounded\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (T, dt, lambda_x, lambda_y, lambda_sync, tau, sigma, L, K, alpha, seed)\n    test_cases = [\n        (20.0, 0.005, 15.0, 15.0, 5.0, 0.0,    0.003, 0.025, 200, 0.05, 101),\n        (20.0, 0.005, 15.0, 15.0, 5.0, 0.015,  0.003, 0.025, 200, 0.05, 102),\n        (20.0, 0.005, 15.0, 15.0, 0.0, 0.0,    0.0,   0.025, 200, 0.05, 103),\n        (10.0, 0.005, 20.0, 20.0, 5.0, 0.0,    0.002, 0.000, 200, 0.05, 104),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Print a single list of lists, each inner list contains floats rounded to 3 decimals.\n    # Build the string manually to ensure formatting.\n    def format_list(lst):\n        # Handles empty list case as well\n        return \"[\" + \",\".join([f\"{x:.3f}\" if x != 0 else \"0.000\" for x in sorted(lst)]) + \"]\"\n    \n    # Use repr to get a string representation, then customize it\n    print(str(results).replace(\"'\", \"\").replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}