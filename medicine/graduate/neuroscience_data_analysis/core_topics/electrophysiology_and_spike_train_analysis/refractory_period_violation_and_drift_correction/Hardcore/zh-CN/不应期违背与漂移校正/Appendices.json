{
    "hands_on_practices": [
        {
            "introduction": "本节的第一个练习将提供一个关于漂移校正核心概念的直接上手体验。您将从一组“原始”脉冲时间开始，其中一些似乎违反了不应期，然后应用一个给定的漂移模型来“校正”这些时间。这项实践练习 () 旨在展示表面上的生理学不可能性是如何由测量伪影引起的，以及数学校正如何恢复数据的完整性。",
            "id": "4189789",
            "problem": "您将获得测量的脉冲发放时间和测量时钟的漂移模型，您必须分析相对于绝对不应期阈值的脉冲间间隔（ISI）违规情况。请使用以下背景和定义作为您推导和算法的基础。\n\n定义和事实：\n- 脉冲序列被建模为在测量时间轴上的一系列事件时间 $\\{\\tilde{t}_i\\}_{i=1}^N$，其中 $\\tilde{t}_i$ 的单位是毫秒。\n- 脉冲间间隔（ISI）定义为 $x_k = t_{k+1} - t_k$，其中 $t_i$ 是考虑了时钟漂移后校正的时间。同样地，在校正前的测量轴上，其定义为 $x_k^{\\mathrm{raw}} = \\tilde{t}_{k+1} - \\tilde{t}_k$。\n- 绝对不应期是来自单个神经元的两次动作电位之间的最短时间；在许多哺乳动物神经元中，一个广泛接受的下限约为 $1\\,\\mathrm{ms}$。如果任何 $x_k$ 低于阈值 $\\tau$，则表明对于一个假定的单个单元存在不应期违规。\n- 漂移校正：设 $a(t)$ 是一个瞬时乘法比例因子，它将测量的增量 $d\\tilde{t}$ 映射到校正的增量 $dt$。校正后的时间由积分 $t(\\tilde{t}) = \\int_0^{\\tilde{t}} a(u)\\,du$ 定义。如果 $a(t)$ 是分段常数，该积分可简化为缩放后各部分的总和。\n\n任务：\n1. 对于每个测试用例，在校正后的时间轴 $t_i$ 上计算 ISI 直方图，组距宽度为 $\\Delta = 0.1\\,\\mathrm{ms}$，使用覆盖 $[0,10]\\,\\mathrm{ms}$ 的组。同时，在原始轴 $\\tilde{t}_i$ 上使用相同的分箱方式计算 ISI 直方图。直方图是一个内部计算步骤；最终输出在下面指定。\n2. 对于每个测试用例，计算严格小于 $\\tau = 1.5\\,\\mathrm{ms}$ 的原始 ISI $x_k^{\\mathrm{raw}}$ 的比例 $f_{\\tau}^{\\mathrm{raw}}$，以小数形式表示。如果脉冲数少于 2 个，则定义 $f_{\\tau}^{\\mathrm{raw}} = 0$。\n3. 使用提供的 $a(t)$ 执行漂移校正，计算校正后的时间 $t_i$，并由此计算校正后的 ISI $x_k$。计算 $f_{\\tau}^{\\mathrm{corr}} > 0$ 是否成立，其中 $f_{\\tau}^{\\mathrm{corr}}$ 是严格小于 $\\tau = 1.5\\,\\mathrm{ms}$ 的校正后 ISI 的比例。仅报告其布尔值解释 $b^{\\mathrm{corr}} = (f_{\\tau}^{\\mathrm{corr}} > 0)$。\n4. 物理单位：所有时间单位均为毫秒，直方图单位为毫秒，比例是无单位的小数。\n\n测试套件：\n为以下五个测试用例提供解决方案。在每个用例中，列出以毫秒为单位的测量脉冲发放时间 $\\{\\tilde{t}_i\\}$ 和作为分段常数段的漂移模型 $a(t)$。这里，$a(t)$ 作用于以毫秒为单位的测量时间轴。\n\n- 测试用例 1（干净的单个单元，稳定时钟）：\n  - 测量的脉冲发放时间：$[0,5,10,15,20]\\,\\mathrm{ms}$。\n  - 漂移：对于 $t \\in [0,\\infty)$，$a(t) = 1.0$。\n\n- 测试用例 2（一个短 ISI，稳定时钟）：\n  - 测量的脉冲发放时间：$[0,1.0,5.0,10.0]\\,\\mathrm{ms}$。\n  - 漂移：对于 $t \\in [0,\\infty)$，$a(t) = 1.0$。\n\n- 测试用例 3（由于时钟速度漂移导致的表观短 ISI，通过拉伸测量轴进行校正）：\n  - 测量的脉冲发放时间：$[0,1.2,3.2]\\,\\mathrm{ms}$。\n  - 漂移：对于 $t \\in [0,4.0)\\,\\mathrm{ms}$，$a(t) = 1.6666666667$；对于 $t \\in [4.0,\\infty)$，$a(t) = 1.0$。\n\n- 测试用例 4（边缘情况，单个脉冲）：\n  - 测量的脉冲发放时间：$[100.0]\\,\\mathrm{ms}$。\n  - 漂移：对于 $t \\in [0,\\infty)$，$a(t) = 1.0$。\n\n- 测试用例 5（多个短 ISI，局部时钟速度漂移）：\n  - 测量的脉冲发放时间：$[0,0.8,1.6,5.0,10.0]\\,\\mathrm{ms}$。\n  - 漂移：对于 $t \\in [0,2.0)\\,\\mathrm{ms}$，$a(t) = 1.25$；对于 $t \\in [2.0,\\infty)$，$a(t) = 1.0$。\n\n解释标准：\n- 对于一个假定的单个单元，任何严格小于 $\\tau$ 的校正后 ISI $x_k$ 的存在都意味着一次不应期违规。因此，如果 $f_{\\tau}^{\\mathrm{corr}} > 0$，则报告 $b^{\\mathrm{corr}} = \\mathrm{True}$；否则报告 $b^{\\mathrm{corr}} = \\mathrm{False}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。元素必须按 $[f_{\\tau,1}^{\\mathrm{raw}},b^{\\mathrm{corr}}_1,f_{\\tau,2}^{\\mathrm{raw}},b^{\\mathrm{corr}}_2,f_{\\tau,3}^{\\mathrm{raw}},b^{\\mathrm{corr}}_3,f_{\\tau,4}^{\\mathrm{raw}},b^{\\mathrm{corr}}_4,f_{\\tau,5}^{\\mathrm{raw}},b^{\\mathrm{corr}}_5]$ 的顺序排列，其中每个 $f_{\\tau,i}^{\\mathrm{raw}}$ 是一个小数，每个 $b^{\\mathrm{corr}}_i \\in \\{\\mathrm{True},\\mathrm{False}\\}$。",
            "solution": "该问题要求分析来自神经元脉冲序列数据的脉冲间间隔（ISI），包括对测量时钟漂移的校正。核心任务是计算原始数据中违反不应期阈值的 ISI 比例，并确定在应用漂移校正模型后是否存在任何此类违规。\n\n对问题陈述的验证证实了其具有科学依据、问题适定、客观，并包含了推导出唯一且有意义的解所需的所有信息。不应期、时钟漂移以及用于校正的数学模型等概念在计算神经科学中都是标准内容。\n\n解决此问题的基本原则如下：\n\n1.  **脉冲间间隔（ISI）计算**：给定一个脉冲时间序列 $\\{s_i\\}_{i=1}^N$，ISI 是连续脉冲之间的时间差，即 $\\{x_k = s_{k+1} - s_k\\}_{k=1}^{N-1}$。我们需要对测量的（原始）脉冲时间（表示为 $\\{\\tilde{t}_i\\}$）和漂移校正后的脉冲时间（表示为 $\\{t_i\\}$）分别进行计算。\n    -   原始 ISI: $\\tilde{x}_k = \\tilde{t}_{k+1} - \\tilde{t}_k$。\n    -   校正后 ISI: $x_k = t_{k+1} - t_k$。\n\n2.  **不应期违规**：如果任何 ISI 短于指定的绝对不应期阈值 $\\tau$，则标记为不应期违规。对于此问题，阈值给定为 $\\tau = 1.5\\,\\mathrm{ms}$。因此，如果校正后的 ISI 存在 $x_k  \\tau$ 或原始 ISI 存在 $\\tilde{x}_k  \\tau$，则发生违规。\n\n3.  **漂移校正模型**：测量的时间间隔 $d\\tilde{t}$ 与校正的时间间隔 $dt$ 之间的关系由 $dt = a(\\tilde{t}) \\, d\\tilde{t}$ 给出，其中 $a(\\tilde{t})$ 是一个作用于测量时间轴、随时间变化的比例因子。为了找到与测量时间 $\\tilde{t}_i$ 对应的校正时间 $t_i$，我们必须从一个公共参考点（通常为 $t_0=\\tilde{t}_0=0$）开始对该关系进行积分：\n    $$t(\\tilde{t}_i) = \\int_0^{\\tilde{t}_i} a(u)\\,du$$\n    其中 $u$ 是沿测量时间轴的积分变量。\n\n    问题指明 $a(u)$ 是一个分段常数函数。假设 $a(u)$ 在一系列区间 $[b_{j-1}, b_j)$ 上定义，每个区间内有一个恒定的比例因子 $a_j$，其中 $b_0 = 0$。要计算落入第 $m$ 个区间（即 $b_{m-1} \\le \\tilde{t}_i  b_m$）的测量时间 $\\tilde{t}_i$ 的积分，该积分变为一个和：\n    $$t(\\tilde{t}_i) = \\left( \\sum_{j=1}^{m-1} \\int_{b_{j-1}}^{b_j} a_j \\,du \\right) + \\int_{b_{m-1}}^{\\tilde{t}_i} a_m \\,du$$\n    $$t(\\tilde{t}_i) = \\left( \\sum_{j=1}^{m-1} a_j (b_j - b_{j-1}) \\right) + a_m (\\tilde{t}_i - b_{m-1})$$\n    这个公式提供了一个直接的算法，用于将每个测量的脉冲时间 $\\tilde{t}_i$ 映射到其校正后的时间 $t_i$。\n\n每个测试用例的算法流程如下：\n1.  给定测量的脉冲时间 $\\{\\tilde{t}_i\\}$，通过计算连续元素之间的差来计算原始 ISI $\\{\\tilde{x}_k\\}$。如果脉冲数 $N  2$，则不存在 ISI。\n2.  计算严格小于 $\\tau = 1.5\\,\\mathrm{ms}$ 的原始 ISI 的比例 $f_{\\tau}^{\\mathrm{raw}}$。如果 $N  2$，则定义 $f_{\\tau}^{\\mathrm{raw}}$ 为 $0$。\n3.  将上述分段积分公式应用于每个测量的脉冲时间 $\\tilde{t}_i$，以获得校正后的脉冲时间集合 $\\{t_i\\}$。\n4.  通过计算连续校正后脉冲时间之间的差来计算校正后的 ISI $\\{x_k\\}$。\n5.  判断是否有任何校正后的 ISI 严格小于 $\\tau = 1.5\\,\\mathrm{ms}$。这等同于检查违反规则的校正后 ISI 的比例 $f_{\\tau}^{\\mathrm{corr}}$ 是否大于 $0$。结果是一个布尔值，$b^{\\mathrm{corr}} = (f_{\\tau}^{\\mathrm{corr}} > 0)$。\n\n让我们以测试用例 5 为例进行说明：\n-   测量的脉冲时间：$\\{\\tilde{t}_i\\} = [0, 0.8, 1.6, 5.0, 10.0]\\,\\mathrm{ms}$。\n-   漂移模型：对于 $u \\in [0, 2.0)\\,\\mathrm{ms}$，$a(u) = 1.25$；对于 $u \\in [2.0, \\infty)\\,\\mathrm{ms}$，$a(u) = 1.0$。\n-   阈值：$\\tau = 1.5\\,\\mathrm{ms}$。\n\n**原始数据分析：**\n-   原始 ISI：$\\{\\tilde{x}_k\\} = [0.8 - 0, 1.6 - 0.8, 5.0 - 1.6, 10.0 - 5.0] = [0.8, 0.8, 3.4, 5.0]\\,\\mathrm{ms}$。\n-   两个 ISI（$0.8$ 和 $0.8$）小于 $1.5\\,\\mathrm{ms}$。\n-   $f_{\\tau}^{\\mathrm{raw}} = 2/4 = 0.5$。\n\n**漂移校正：**\n-   $t_1 = t(\\tilde{t}_1=0) = 0$。\n-   $t_2 = t(\\tilde{t}_2=0.8) = \\int_0^{0.8} 1.25 du = 1.25 \\times 0.8 = 1.0\\,\\mathrm{ms}$。\n-   $t_3 = t(\\tilde{t}_3=1.6) = \\int_0^{1.6} 1.25 du = 1.25 \\times 1.6 = 2.0\\,\\mathrm{ms}$。\n-   $t_4 = t(\\tilde{t}_4=5.0) = \\int_0^{2.0} 1.25 du + \\int_{2.0}^{5.0} 1.0 du = (1.25 \\times 2.0) + (1.0 \\times (5.0 - 2.0)) = 2.5 + 3.0 = 5.5\\,\\mathrm{ms}$。\n-   $t_5 = t(\\tilde{t}_5=10.0) = \\int_0^{2.0} 1.25 du + \\int_{2.0}^{10.0} 1.0 du = (1.25 \\times 2.0) + (1.0 \\times (10.0 - 2.0)) = 2.5 + 8.0 = 10.5\\,\\mathrm{ms}$。\n-   校正后的脉冲时间：$\\{t_i\\} = [0, 1.0, 2.0, 5.5, 10.5]\\,\\mathrm{ms}$。\n\n**校正后分析：**\n-   校正后 ISI：$\\{x_k\\} = [1.0 - 0, 2.0 - 1.0, 5.5 - 2.0, 10.5 - 5.5] = [1.0, 1.0, 3.5, 5.0]\\,\\mathrm{ms}$。\n-   两个校正后的 ISI（$1.0$ 和 $1.0$）小于 $1.5\\,\\mathrm{ms}$。\n-   $f_{\\tau}^{\\mathrm{corr}} = 2/4 = 0.5$。由于 $f_{\\tau}^{\\mathrm{corr}} > 0$，布尔值报告为 $b^{\\mathrm{corr}} = \\mathrm{True}$。\n\n这个结构化流程被应用于所有测试用例以生成最终结果。提供的 Python 代码实现了该算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes refractory period violation statistics for raw and drift-corrected spike times.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case includes measured spike times and a piecewise drift model.\n    # The drift model is a list of tuples (boundary_time, scale_factor).\n    test_cases = [\n        {\n            \"spikes\": [0.0, 5.0, 10.0, 15.0, 20.0],\n            \"drift\": [(float('inf'), 1.0)]\n        },\n        {\n            \"spikes\": [0.0, 1.0, 5.0, 10.0],\n            \"drift\": [(float('inf'), 1.0)]\n        },\n        {\n            \"spikes\": [0.0, 1.2, 3.2],\n            \"drift\": [(4.0, 1.6666666667), (float('inf'), 1.0)]\n        },\n        {\n            \"spikes\": [100.0],\n            \"drift\": [(float('inf'), 1.0)]\n        },\n        {\n            \"spikes\": [0.0, 0.8, 1.6, 5.0, 10.0],\n            \"drift\": [(2.0, 1.25), (float('inf'), 1.0)]\n        }\n    ]\n\n    # Refractory period violation threshold in milliseconds.\n    tau = 1.5\n\n    results = []\n    \n    for case in test_cases:\n        measured_times = np.array(case[\"spikes\"])\n        drift_model = case[\"drift\"]\n\n        # --- Part 1: Raw ISI Analysis ---\n        \n        # Calculate the fraction of raw ISIs violating the threshold.\n        # If there are fewer than 2 spikes, the fraction is 0 by definition.\n        if len(measured_times)  2:\n            f_tau_raw = 0.0\n        else:\n            raw_isis = np.diff(measured_times)\n            num_violations = np.sum(raw_isis  tau)\n            f_tau_raw = num_violations / len(raw_isis)\n\n        # --- Part 2: Drift Correction ---\n\n        # Apply the piecewise integral to correct each measured spike time.\n        # t(t_tilde) = integral from 0 to t_tilde of a(u) du.\n        corrected_times = []\n        for mt in measured_times:\n            ct = 0.0\n            last_boundary = 0.0\n            for boundary, factor in drift_model:\n                # If the measured time exceeds the current segment boundary\n                if mt > boundary:\n                    ct += (boundary - last_boundary) * factor\n                    last_boundary = boundary\n                # If the measured time is within the current segment\n                else:\n                    ct += (mt - last_boundary) * factor\n                    break\n            corrected_times.append(ct)\n        \n        corrected_times_np = np.array(corrected_times)\n\n        # --- Part 3: Corrected ISI Analysis ---\n\n        # Determine if any corrected ISI violates the threshold.\n        # If there are fewer than 2 spikes, no violations can occur.\n        if len(corrected_times_np)  2:\n            b_corr = False\n        else:\n            corrected_isis = np.diff(corrected_times_np)\n            # Check if any corrected ISI is strictly less than the threshold.\n            any_violation = np.any(corrected_isis  tau)\n            b_corr = bool(any_violation)\n            \n        results.append(f_tau_raw)\n        results.append(b_corr)\n\n    # Final print statement in the exact required format.\n    # str() will convert floats to decimal strings and booleans to 'True'/'False'.\n    output_str = ','.join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的神经科学数据分析常常需要在各种因素之间进行权衡，而这项实践将让您置身于这样一个情景之中。您将面对一个“簇放电”神经元，其快速且生理上合理的放电模式很难与由噪声或污染引起的不应期违例区分开来。这个练习 () 将挑战您设计一个自适应的不应期阈值 $τ$，该阈值既要考虑到生理学限制，又要考虑到测量的不确定性，从而凸显了高质量脉冲分选所需的精细决策过程。",
            "id": "4189758",
            "problem": "使用高密度探针从啮齿动物新皮层记录到的一个单单元簇，表现出与簇放电一致的短峰间间隔行为。设峰电位时间为 $t_1, t_2, \\dots, t_N$，并定义峰间间隔 (Interspike Interval, ISI) 为 $\\Delta t_i = t_{i+1} - t_i$。生理绝对不应期为 $\\tau_{\\mathrm{abs}} = 1.4\\,\\mathrm{ms}$，这是由钠通道的失活和恢复所决定的。为了评估不应期违例 (Refractory Period Violations, RPV)，一个峰电位分拣质量标准规定，如果比选定的不应期窗口 $\\tau$ 更短的 ISI 的比例至多为 $\\alpha = 1\\%$，则该单元被接受。数据已经过探针漂移校正 (Probe Drift Correction, PDC)，残余的时间对齐抖动近似为高斯分布，校正后的标准差为 $\\sigma_{\\mathrm{post}} = 0.1\\,\\mathrm{ms}$；校正前的抖动标准差为 $\\sigma_{\\mathrm{pre}} = 0.2\\,\\mathrm{ms}$。在去除伪迹后，对 $N \\gg 1$ 个峰间间隔进行计算，该单元校正后的经验 ISI 分位数为：\n- $Q(0.5\\%) = 1.6\\,\\mathrm{ms}$，\n- $Q(1.0\\%) = 1.8\\,\\mathrm{ms}$，\n- $Q(1.5\\%) = 2.0\\,\\mathrm{ms}$，\n- $Q(2.0\\%) = 2.2\\,\\mathrm{ms}$，\n- $Q(5.0\\%) = 3.0\\,\\mathrm{ms}$，\n- $Q(10.0\\%) = 4.0\\,\\mathrm{ms}$，\n其中 $Q(p)$ 表示满足 $\\mathbb{P}(\\Delta t \\le Q(p)) = p$ 的值。该单元表现出簇放电行为，有许多 ISI 处于 $2$–$6\\,\\mathrm{ms}$ 范围内，这些在生理上是合理的，不应被错误地归类为违例。\n\n您必须评估使用更严格的不应期窗口（更大的 $\\tau$ 会导致更多的 RPV 计数，并可能拒绝簇放电单元）与保留簇放电神经元之间的权衡，并根据 ISI 分布和漂移校正后的抖动设计一个自适应的 $\\tau$ 选择方法。该自适应设计应使用恰好位于一个由 $\\tau_{\\mathrm{abs}}$ 和校正后残余时间不确定性构建的保守生理保护阈之上的最小 ISI 百分位数值来选择 $\\tau$。基于此设计和接受标准 $\\alpha$，哪个选项正确地指定了 $\\tau$ 和保留决定，同时恰当地解释了与簇放电的权衡？\n\nA. 在 PDC 后选择 $\\tau = Q(1.0\\%) = 1.8\\,\\mathrm{ms}$。由此产生的 RPV 比例为 $1.0\\% \\le \\alpha$，因此该单元被接受。这个 $\\tau$ 值恰好位于一个保守的生理保护阈之上，并且在很大程度上保留了 ISI 在 $2$–$6\\,\\mathrm{ms}$ 范围内的簇放电；将 $\\tau$ 设得更大将会不必要地将更多的簇放电 ISI 计为违例。\n\nB. 在 PDC 后选择 $\\tau = Q(2.0\\%) = 2.2\\,\\mathrm{ms}$。由此产生的 RPV 比例为 $2.0\\% > \\alpha$，因此该单元被拒绝。这个更严格的窗口能更好地防止漂移引起的污染，并提高簇放电的保留率。\n\nC. 使用校正前的考量选择 $\\tau = Q(1.5\\%) = 2.0\\,\\mathrm{ms}$。由此产生的 RPV 比例为 $1.5\\% > \\alpha$，因此该单元被拒绝。这是最优的，因为它基于校正前的抖动，从而避免了在 PDC 后低估违例。\n\nD. 在 PDC 后选择 $\\tau = Q(5.0\\%) = 3.0\\,\\mathrm{ms}$ 以保留簇放电。由此产生的 RPV 比例为 $5.0\\% \\le \\alpha$，因此该单元被接受且簇放电被完全保留；更严格的 $\\tau$ 值会在没有明显好处的情况下损害保留率。",
            "solution": "用户要求对问题陈述进行严格验证，然后对解决方案进行完整推导并对所有选项进行评估。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 峰电位时间：$t_1, t_2, \\dots, t_N$。\n- 峰间间隔 (ISI)：$\\Delta t_i = t_{i+1} - t_i$。\n- 生理绝对不应期：$\\tau_{\\mathrm{abs}} = 1.4\\,\\mathrm{ms}$。\n- 接受标准：比所选不应期窗口 $\\tau$ 更短的 ISI 比例至多为 $\\alpha = 1\\%$。\n- 已应用探针漂移校正 (PDC)。\n- 校正后残余时间对齐抖动标准差：$\\sigma_{\\mathrm{post}} = 0.1\\,\\mathrm{ms}$。\n- 校正前抖动标准差：$\\sigma_{\\mathrm{pre}} = 0.2\\,\\mathrm{ms}$。\n- 校正后经验 ISI 分位数：\n  - $Q(0.5\\%) = 1.6\\,\\mathrm{ms}$\n  - $Q(1.0\\%) = 1.8\\,\\mathrm{ms}$\n  - $Q(1.5\\%) = 2.0\\,\\mathrm{ms}$\n  - $Q(2.0\\%) = 2.2\\,\\mathrm{ms}$\n  - $Q(5.0\\%) = 3.0\\,\\mathrm{ms}$\n  - $Q(10.0\\%) = 4.0\\,\\mathrm{ms}$\n- 分位数定义：$\\mathbb{P}(\\Delta t \\le Q(p)) = p$。\n- 单元行为：簇放电，许多 ISI 在 $2$–$6\\,\\mathrm{ms}$ 范围内。\n- 任务指令：通过选择恰好位于一个由 $\\tau_{\\mathrm{abs}}$ 和校正后残余时间不确定性构建的保守生理保护阈之上的最小 ISI 百分位数值，来设计一个自适应的 $\\tau$ 选择方法。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在细胞外电生理学和峰电位分拣数据分析的原理上有充分的依据。绝对不应期、峰间间隔 (ISI)、作为质量指标的不应期违例 (RPV)、探针漂移和时间抖动等概念都是标准概念。提供的 $\\tau_{\\mathrm{abs}}$、$\\sigma_{\\mathrm{post}}$ 和 ISI 分位数的数值对于皮层神经元记录是符合实际的。\n- **适定性**：该问题是适定的。它提供了所有必要的数据和一个清晰（尽管复杂）的关于设计参数 $\\tau$ 的指令。这个指令的存在使得问题可以通过唯一的、合理的答案来解决。\n- **客观性**：该问题使用该领域通用的精确、客观和技术性语言进行陈述。它提出了一个定量的分析任务，不含主观或基于意见的陈述。\n\n**步骤3：结论与行动**\n问题陈述是有效的。它在科学上是合理的，自洽的，并且是可定量求解的。我将继续进行推导。\n\n### 解题推导\n\n主要任务是为不应期窗口 $\\tau$ 实现指定的自适应设计。设计规则是“使用恰好位于一个由 $\\tau_{\\mathrm{abs}}$ 和校正后残余时间不确定性构建的保守生理保护阈之上的最小 ISI 百分位数值来选择 $\\tau$”。\n\n1.  **构建保守生理保护阈 ($G$)**：\n    该保护阈必须根据生理绝对不应期 $\\tau_{\\mathrm{abs}} = 1.4\\,\\mathrm{ms}$ 和校正后残余时间不确定性（其特征为标准差 $\\sigma_{\\mathrm{post}} = 0.1\\,\\mathrm{ms}$）来构建。\n\n    绝对不应期 $\\tau_{\\mathrm{abs}}$ 设定了一个硬性的生理极限：单个神经元的真实 ISI 不可能比这个值短。然而，峰电位时间抖动使测量复杂化。如果我们将分析窗口 $\\tau$ 精确地设置在 $\\tau_{\\mathrm{abs}}$，由于对称的抖动分布，任何略高于 $\\tau_{\\mathrm{abs}}$ 的真实 ISI 都有很大可能被测量为低于 $\\tau_{\\mathrm{abs}}$，从而导致 RPV 的过高估计。\n\n    因此，分析窗口 $\\tau$ 必须设置在一个大于 $\\tau_{\\mathrm{abs}}$ 的值。“生理保护阈”（$G$）作为我们选择 $\\tau$ 的下限。构建这个保护阈的一个保守方法是在 $\\tau_{\\mathrm{abs}}$ 上增加一个安全边际，以考虑时间抖动。一种常见的“保守”做法是使用标准差的倍数。让我们将保护阈定义为 $G = \\tau_{\\mathrm{abs}} + k \\cdot \\sigma_{\\mathrm{post}}$，其中 $k$ 是一个小整数（例如 $2$ 或 $3$），以创建一个可靠的缓冲。注意，抖动影响的是 ISI，即两个峰电位时间的差。如果时间误差是独立的，ISI 上的抖动标准差应为 $\\sqrt{2}\\sigma_{\\mathrm{post}}$。然而，问题指明使用给定的“时间不确定性” $\\sigma_{\\mathrm{post}}$，这表明意图是直接使用该值，这是一种常见的简化。让我们测试这个更简单的构建方法。\n\n    让我们选择 $k=3$ 来构建一个高度保守的保护阈：\n    $$G = \\tau_{\\mathrm{abs}} + 3 \\cdot \\sigma_{\\mathrm{post}} = 1.4\\,\\mathrm{ms} + 3 \\cdot (0.1\\,\\mathrm{ms}) = 1.7\\,\\mathrm{ms}$$\n    即使选择一个稍不保守的 $k=2$：\n    $$G = \\tau_{\\mathrm{abs}} + 2 \\cdot \\sigma_{\\mathrm{post}} = 1.4\\,\\mathrm{ms} + 2 \\cdot (0.1\\,\\mathrm{ms}) = 1.6\\,\\mathrm{ms}$$\n    所以，我们的保守生理保护阈 $G$ 位于 $[1.6, 1.7]\\,\\mathrm{ms}$ 的范围内。\n\n2.  **根据保护阈和 ISI 分位数选择 $\\tau$**：\n    规则是选择 $\\tau$ 为“恰好位于”保护阈 $G$ 之上的“最小 ISI 百分位数值”。可用的百分位数值（分位数）有：$1.6\\,\\mathrm{ms}$、$1.8\\,\\mathrm{ms}$、$2.0\\,\\mathrm{ms}$ 等。\n\n    -   如果我们使用 $G = 1.6\\,\\mathrm{ms}$，我们需要严格大于 $1.6\\,\\mathrm{ms}$ 的最小分位数值。这个值是 $1.8\\,\\mathrm{ms}$。\n    -   如果我们使用 $G = 1.7\\,\\mathrm{ms}$，我们需要严格大于 $1.7\\,\\mathrm{ms}$ 的最小分位数值。这个值也是 $1.8\\,\\mathrm{ms}$。\n\n    两种合理的保护阈构建方法都指向同一个选择。因此，自适应设计选择：\n    $$\\tau = Q(1.0\\%) = 1.8\\,\\mathrm{ms}$$\n\n3.  **应用接受标准并评估权衡**：\n    当 $\\tau = 1.8\\,\\mathrm{ms}$ 时，小于或等于 $\\tau$ 的 ISI 比例由分位数函数的定义给出：$\\mathbb{P}(\\Delta t \\le 1.8\\,\\mathrm{ms}) = 1.0\\%$。这就是我们的 RPV 比例。\n\n    接受标准是 RPV 比例必须至多为 $\\alpha = 1\\%$。由于我们计算出的 RPV 比例是 $1.0\\%$，条件 $1.0\\% \\le 1.0\\%$ 得到满足。因此，该单元应该被**接受**。\n\n    对 $\\tau = 1.8\\,\\mathrm{ms}$ 的选择还必须在该单元的簇放电行为（许多 ISI 在 $2$–$6\\,\\mathrm{ms}$ 范围内）的背景下进行评估。我们选择的窗口 $\\tau = 1.8\\,\\mathrm{ms}$ 低于这个簇放电范围的起始值 ($2\\,\\mathrm{ms}$)。这是一个很好的选择，因为它避免了将来自簇放电的、生理上合理的短 ISI 错误地归类为不应期违例。一个更大的 $\\tau$（例如 $2.2\\,\\mathrm{ms}$ 或 $3.0\\,\\mathrm{ms}$）会开始侵入簇放电的分布范围，导致人为的高 RPV 计数，并可能错误地拒绝一个有效的簇放电神经元。\n\n### 逐项选项分析\n\n**A. 在 PDC 后选择 $\\tau = Q(1.0\\%) = 1.8\\,\\mathrm{ms}$。由此产生的 RPV 比例为 $1.0\\% \\le \\alpha$，因此该单元被接受。这个 $\\tau$ 值恰好位于一个保守的生理保护阈之上，并且在很大程度上保留了 ISI 在 $2$–$6\\,\\mathrm{ms}$ 范围内的簇放电；将 $\\tau$ 设得更大将会不必要地将更多的簇放电 ISI 计为违例。**\n- **$\\tau$ 的选择**：与我们的推导一致。它正确地使用了 PDC 后的信息。\n- **决定**：RPV 比例是 $1.0\\%$。标准是 $\\le 1\\%$。该单元被正确接受。\n- **理由**：解释是准确的。$\\tau = 1.8\\,\\mathrm{ms}$ 恰好位于我们构建的生理保护阈（$1.6$–$1.7\\,\\mathrm{ms}$）之上。它正确地避开了 $2$–$6\\,\\mathrm{ms}$ 的簇放电 ISI 范围，并且反对使用更大 $\\tau$ 的论点是合理的。\n- **结论**：**正确**。\n\n**B. 在 PDC 后选择 $\\tau = Q(2.0\\%) = 2.2\\,\\mathrm{ms}$。由此产生的 RPV 比例为 $2.0\\% > \\alpha$，因此该单元被拒绝。这个更严格的窗口能更好地防止漂移引起的污染，并提高簇放电的保留率。**\n- **$\\tau$ 的选择**：这个选择 $\\tau = 2.2\\,\\mathrm{ms}$ 违反了问题中选择保护阈之上*最小*百分位数值的指令。$1.8\\,\\mathrm{ms}$ 和 $2.0\\,\\mathrm{ms}$ 是更小的合格值。\n- **决定**：计算是正确的：如果选择 $\\tau = 2.2\\,\\mathrm{ms}$，RPV 比例将是 $2.0\\%$，由于 $2.0\\% > 1\\%$，该单元将被拒绝。\n- **理由**：声称这“提高簇放电的保留率”是直接矛盾的。一个更大（更严格）的窗口 $\\tau$ 会通过包含短 ISI 的簇放电来增加 RPV 计数，从而*降低*簇放电单元被保留的机会。\n- **结论**：**不正确**。\n\n**C. 使用校正前的考量选择 $\\tau = Q(1.5\\%) = 2.0\\,\\mathrm{ms}$。由此产生的 RPV 比例为 $1.5\\% > \\alpha$，因此该单元被拒绝。这是最优的，因为它基于校正前的抖动，从而避免了在 PDC 后低估违例。**\n- **$\\tau$ 的选择**：这个选择是有缺陷的。它使用了“校正前的考量”（$\\sigma_{\\mathrm{pre}}$），这在应用了 PDC 之后是不合逻辑的。我们必须使用校正后数据的属性，即 $\\sigma_{\\mathrm{post}}$。基于使用 $\\sigma_{\\mathrm{post}}$ 的正确保护阈构建，该选择也违反了“最小百分位数”规则。\n- **决定**：计算是正确的：如果 $\\tau = 2.0\\,\\mathrm{ms}$，RPV 比例是 $1.5\\%$，由于 $1.5\\% > 1\\%$，导致拒绝。\n- **理由**：这个理由是无稽之谈。使用更大的校正前抖动会导致一个更宽的窗口 $\\tau$，这会*高估* RPV，而不是“避免低估”它们。必须信任漂移校正并使用校正后的不确定性。\n- **结论**：**不正确**。\n\n**D. 在 PDC 后选择 $\\tau = Q(5.0\\%) = 3.0\\,\\mathrm{ms}$ 以保留簇放电。由此产生的 RPV 比例为 $5.0\\% \\le \\alpha$，因此该单元被接受且簇放电被完全保留；更严格的 $\\tau$ 值会在没有明显好处的情况下损害保留率。**\n- **$\\tau$ 的选择**：这个选择 $\\tau=3.0\\,\\mathrm{ms}$ 与设计原则严重不符。\n- **决定**：该陈述包含一个基本错误：“RPV 比例为 $5.0\\% \\le \\alpha$”。RPV 比例将是 $5.0\\%$，而 $\\alpha=1\\%$。不等式 $5.0\\% \\le 1.0\\%$ 是错误的。该单元将被拒绝，而不是接受。\n- **理由**：声称这个选择有助于“保留簇放电”是错误的。一个 $\\tau = 3.0\\,\\mathrm{ms}$ 的窗口直接切入了指定的 $2$–$6\\,\\mathrm{ms}$ 簇放电范围，将许多有效的簇放电 ISI 计为违例，并确保该单元被拒绝。\n- **结论**：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在应用和解读了漂移校正之后，这最后一个高级实践将要求您从第一性原理出发，设计一个漂移估计算法。您将开发一个动态规划解决方案，以寻找能够最好地解释脉冲波形能量随时间变化的最优漂移轨迹。这项练习 () 揭示了如何构建复杂的漂移校正工具，它将数据驱动的建模与强大的优化技术相结合，从而让您对该领域的前沿方法有更深刻的理解。",
            "id": "4189827",
            "problem": "给定一个区块序列，代表了来自细胞外电极阵列的尖峰记录的连续时间段。对于每个区块 $i \\in \\{0,1,\\dots,N-1\\}$，您会得到区块中心时间 $t_i$（单位为秒）、观测到的平均模板能量 $E^{\\mathrm{obs}}_i$（单位为 $\\mu\\mathrm{V}^2$）、从匹配的尖峰模板派生出的预期模板能量 $E^{\\mathrm{exp}}_i$（单位为 $\\mu\\mathrm{V}^2$），以及测得的不应期违例（RPV）计数 $r_i$。RPV 定义为在区块内分配给该模板的尖峰中，其尖峰间隔低于 $2\\,\\mathrm{ms}$ 固定不应期阈值的数量。不应期违例可衡量聚类质量，当漂移导致模板与真实尖峰波形错位时，其数量往往会增加。\n\n一个核心假设是，记录探针随时间的平移漂移会导致观测能量发生缓慢变化，该变化可建模为一个加性漂移函数 $d(t)$，因此在没有噪声的情况下，能量应满足 $E^{\\mathrm{obs}}_i \\approx E^{\\mathrm{exp}}_i + d(t_i)$。目标是跨区块估计一个分段线性漂移函数 $d(t)$，该函数能同时解释能量失配并减少不应期违例。\n\n从以下基本原则出发：\n- 细胞外尖峰记录中的不应期意味着同一个神经元很少在 $2\\,\\mathrm{ms}$ 内发放两次尖峰，因此具有许多违例的区块表明存在分配错误，这可以通过更好的漂移校正来减少。\n- 最小二乘原理建议在高斯噪声假设下，通过惩罚模型预测值与观测值之间的平方差来获得鲁棒的估计。\n- 分段线性可以通过惩罚离散曲率来鼓励，当区块在时间上等距分布时，这可以通过区块序列中的二阶差分来建模。\n\n将一个漂移值 $d_i := d(t_i)$ 的每区块数据保真度成本定义为\n$$\nC_i(d_i) \\equiv w_i\\left(E^{\\mathrm{obs}}_i - E^{\\mathrm{exp}}_i - d_i\\right)^2,\n$$\n其中权重 $w_i$ 随不应期违例计数增加而增加，具体为\n$$\nw_i \\equiv 1 + \\beta r_i,\n$$\n其中 $\\beta \\ge 0$ 是一个参数。\n\n为激励分段线性，定义一个曲率惩罚，通过绝对二阶差分来惩罚跨越时间上等距的连续区块的斜率变化\n$$\nP(d_{i-2},d_{i-1},d_i) \\equiv \\gamma\\,\\left|\\left(d_i - d_{i-1}\\right) - \\left(d_{i-1} - d_{i-2}\\right)\\right| = \\gamma\\,|d_i - 2d_{i-1} + d_{i-2}|,\n$$\n其中 $\\gamma \\ge 0$ 是一个参数。对于第一个过渡，定义一个零值的初始斜率先验，并通过以下方式惩罚第一个斜率\n$$\nP_1(d_0,d_1) \\equiv \\gamma\\,|d_1 - d_0|.\n$$\n\n您将设计一个动态规划方法，在一个离散网格上估计一个漂移值序列 $\\{d_i\\}_{i=0}^{N-1}$\n$$\n\\mathcal{D} \\equiv \\{d_{\\min}, d_{\\min}+\\Delta, d_{\\min}+2\\Delta, \\dots, d_{\\max}\\},\n$$\n其中 $d_{\\min}$、$d_{\\max}$ 和 $\\Delta$ 以 $\\mu\\mathrm{V}^2$ 为单位给出，并且假设区块在时间上是等距的。目标是最小化总成本\n$$\nJ(d_0,\\dots,d_{N-1}) = \\sum_{i=0}^{N-1} C_i(d_i) \\;+\\; \\left[ P_1(d_0,d_1) + \\sum_{i=2}^{N-1} P(d_{i-2},d_{i-1},d_i) \\right].\n$$\n\n您的程序必须：\n1. 实现一个动态规划算法，该算法利用最优子结构原理，在 $\\mathcal{D}$ 上产生最小化 $J$ 的全局最优离散序列 $\\{d_i\\}$。\n2. 处理所有边界情况，特别是 $N=1$、$N=2$ 和 $N\\ge 3$。\n3. 对每个提供的测试用例，返回估计的漂移值序列 $\\{d_i\\}$，单位为 $\\mu\\mathrm{V}^2$，四舍五入到四位小数。\n\n测试套件：\n使用以下测试用例。在每个案例中，区块在时间上都是等距的。\n\n- 案例1（通用正常路径）：\n    - $t = [0,1,2,3,4,5]$ 秒\n    - $E^{\\mathrm{exp}} = [100,100,100,100,100,100]$ $\\mu\\mathrm{V}^2$\n    - $E^{\\mathrm{obs}} = [98,99,101,103,105,108]$ $\\mu\\mathrm{V}^2$\n    - $r = [2,3,3,4,5,5]$\n    - $d_{\\min} = -10$ $\\mu\\mathrm{V}^2$, $d_{\\max} = 10$ $\\mu\\mathrm{V}^2$, $\\Delta = 1$ $\\mu\\mathrm{V}^2$\n    - $\\gamma = 0.5$, $\\beta = 0.05$\n\n- 案例2（无失配，零RPV）：\n    - $t = [0,1,2,3,4]$ 秒\n    - $E^{\\mathrm{exp}} = [50,50,50,50,50]$ $\\mu\\mathrm{V}^2$\n    - $E^{\\mathrm{obs}} = [50,50,50,50,50]$ $\\mu\\mathrm{V}^2$\n    - $r = [0,0,0,0,0]$\n    - $d_{\\min} = -5$ $\\mu\\mathrm{V}^2$, $d_{\\max} = 5$ $\\mu\\mathrm{V}^2$, $\\Delta = 1$ $\\mu\\mathrm{V}^2$\n    - $\\gamma = 1.0$, $\\beta = 0.2$\n\n- 案例3（恒定负失配，高RPV权重）：\n    - $t = [0,1,2,3,4,5,6]$ 秒\n    - $E^{\\mathrm{exp}} = [120,120,120,120,120,120,120]$ $\\mu\\mathrm{V}^2$\n    - $E^{\\mathrm{obs}} = [115,115,115,115,115,115,115]$ $\\mu\\mathrm{V}^2$\n    - $r = [10,11,9,12,10,11,10]$\n    - $d_{\\min} = -10$ $\\mu\\mathrm{V}^2$, $d_{\\max} = 0$ $\\mu\\mathrm{V}^2$, $\\Delta = 1$ $\\mu\\mathrm{V}^2$\n    - $\\gamma = 0.3$, $\\beta = 0.1$\n\n- 案例4（网格边界饱和）：\n    - $t = [0,1,2,3]$ 秒\n    - $E^{\\mathrm{exp}} = [80,80,80,80]$ $\\mu\\mathrm{V}^2$\n    - $E^{\\mathrm{obs}} = [60,60,100,100]$ $\\mu\\mathrm{V}^2$\n    - $r = [1,1,1,1]$\n    - $d_{\\min} = -10$ $\\mu\\mathrm{V}^2$, $d_{\\max} = 10$ $\\mu\\mathrm{V}^2$, $\\Delta = 1$ $\\mu\\mathrm{V}^2$\n    - $\\gamma = 0.7$, $\\beta = 0.05$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表中的每个元素本身是针对一个测试用例的估计漂移值列表（单位为 $\\mu\\mathrm{V}^2$），四舍五入到四位小数。例如，对于两个案例的有效输出将类似于“[[0.0000,0.0000],[1.0000,2.0000,3.0000]]”。请确保打印的行中没有任何空格。",
            "solution": "该问题要求我们为一系列 $N$ 个时间块估计一个漂移值序列 $\\{d_i\\}_{i=0}^{N-1}$。估计必须在一个离散的值网格 $\\mathcal{D} = \\{d_{\\min}, d_{\\min}+\\Delta, \\dots, d_{\\max}\\}$ 上执行。最优序列被定义为使总成本函数 $J$ 最小化的序列。此成本函数是两部分之和：一个惩罚与能量模型偏差的数据保真度项，以及一个惩罚漂移序列缺乏分段线性的正则化项。\n\n总成本由下式给出：\n$$\nJ(d_0,\\dots,d_{N-1}) = \\sum_{i=0}^{N-1} C_i(d_i) \\;+\\; \\left[ P_1(d_0,d_1) + \\sum_{i=2}^{N-1} P(d_{i-2},d_{i-1},d_i) \\right]\n$$\n其中：\n- 数据保真度成本为 $C_i(d_i) = w_i(E^{\\mathrm{obs}}_i - E^{\\mathrm{exp}}_i - d_i)^2$，权重为 $w_i = 1 + \\beta r_i$。\n- 初始斜率惩罚为 $P_1(d_0,d_1) = \\gamma|d_1 - d_0|$。\n- 曲率惩罚为 $P(d_{i-2}, d_{i-1}, d_i) = \\gamma|d_i - 2d_{i-1} + d_{i-2}|$。\n\n成本函数的结构，即步骤 $i$ 的成本取决于在步骤 $i-1$ 和 $i-2$ 做出的决策，使得该问题适合使用动态规划来解决。最优性原理适用：到达步骤 $i$ 的最优路径必须由到达步骤 $i-1$ 的最优路径构成。\n\n我们根据计算未来成本所需的信息来定义动态规划算法的状态。由于惩罚项 $P(d_{i-2}, d_{i-1}, d_i)$ 取决于最后三个漂移值，因此步骤 $i$ 的状态必须编码 $d_{i-1}$ 和 $d_i$ 的选择。\n\n设 $\\mathcal{D}$ 为包含 $M$ 个可能漂移值的网格。我们将此网格中的第 $k$ 个值表示为 $\\mathcal{D}[k]$。\n设 $dp[i][j][k]$ 表示区块 $0, \\dots, i$ 的最小累积成本，前提是区块 $i-1$ 的漂移值为 $d_{i-1} = \\mathcal{D}[j]$，区块 $i$ 的漂移值为 $d_i = \\mathcal{D}[k]$。\n\n通用算法流程如下：\n\n1.  **处理 $N=1$ 的情况**：如果只有一个区块，成本函数简化为 $J(d_0) = C_0(d_0)$。我们找到使这个二次函数最小化的漂移值 $d_0 \\in \\mathcal{D}$。无约束最小值出现在 $d_0 = E^{\\mathrm{obs}}_0 - E^{\\mathrm{exp}}_0$。解是 $\\mathcal{D}$ 中最接近此值的网格点。\n\n2.  **处理 $N \\ge 2$ 的情况**：\n    - **预计算**：为提高效率，我们首先计算一个表格 `C_costs[i][k] = C_i(\\mathcal{D}[k])`，涵盖所有区块 $i$ 和所有网格索引 $k$。\n    - **初始化 ($i=1$)**：我们计算前两个区块（$i=0, 1$）的成本。对于每对可能的漂移值 $(d_0=\\mathcal{D}[j], d_1=\\mathcal{D}[k])$，成本是数据保真度项和初始斜率惩罚之和。\n      $$\n      dp[1][j][k] = \\text{C\\_costs}[0][j] + \\text{C\\_costs}[1][k] + \\gamma |\\mathcal{D}[k] - \\mathcal{D}[j]|\n      $$\n    - **递推 ($i=2, \\dots, N-1$)**：我们从区块 $i=2$ 迭代到 $N-1$。对于每对当前和前一个漂移值 $(d_{i-1}=\\mathcal{D}[j], d_i=\\mathcal{D}[k])$，我们找到最优的前一个漂移值 $d_{i-2}=\\mathcal{D}[l]$，以最小化直到步骤 $i$ 的成本。\n      $$\n      dp[i][j][k] = \\text{C\\_costs}[i][k] + \\min_{l=0}^{M-1} \\left\\{ dp[i-1][l][j] + \\gamma |\\mathcal{D}[k] - 2\\mathcal{D}[j] + \\mathcal{D}[l]| \\right\\}\n      $$\n      为了重构解，我们将达到此最小值的索引 $l$ 存储在一个回溯指针表 $ptr[i][j][k]$ 中。\n\n3.  **终止与路径重构**：\n    - 在填满DP表直到 $i = N-1$ 后，总的最小成本是 $\\min_{j, k} dp[N-1][j][k]$。设 $(j^*, k^*)$ 是达到此最小值的索引。\n    - 最优序列中的最后两个漂移值是 $d_{N-1} = \\mathcal{D}[k^*]$ 和 $d_{N-2} = \\mathcal{D}[j^*]$。\n    - 我们使用回溯指针表来追溯最优序列的其余部分。从 $i=N-1$ 开始，我们使用 $ptr[i][j^*][k^*]$ 找到 $d_{i-2}$ 的索引，并重复此过程，直到找到所有漂移值，直至 $d_0$。\n\n该方法系统地探索了离散网格上的所有可能路径，并保证能找到一个全局最小化总成本 $J$ 的序列 $\\{d_i\\}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the drift correction algorithm on all test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (general happy path)\n        {\n            \"t\": [0, 1, 2, 3, 4, 5],\n            \"E_exp\": [100, 100, 100, 100, 100, 100],\n            \"E_obs\": [98, 99, 101, 103, 105, 108],\n            \"r\": [2, 3, 3, 4, 5, 5],\n            \"d_min\": -10, \"d_max\": 10, \"Delta\": 1,\n            \"gamma\": 0.5, \"beta\": 0.05\n        },\n        # Case 2 (no mismatch, zero RPV)\n        {\n            \"t\": [0, 1, 2, 3, 4],\n            \"E_exp\": [50, 50, 50, 50, 50],\n            \"E_obs\": [50, 50, 50, 50, 50],\n            \"r\": [0, 0, 0, 0, 0],\n            \"d_min\": -5, \"d_max\": 5, \"Delta\": 1,\n            \"gamma\": 1.0, \"beta\": 0.2\n        },\n        # Case 3 (constant negative mismatch, high RPV weights)\n        {\n            \"t\": [0, 1, 2, 3, 4, 5, 6],\n            \"E_exp\": [120, 120, 120, 120, 120, 120, 120],\n            \"E_obs\": [115, 115, 115, 115, 115, 115, 115],\n            \"r\": [10, 11, 9, 12, 10, 11, 10],\n            \"d_min\": -10, \"d_max\": 0, \"Delta\": 1,\n            \"gamma\": 0.3, \"beta\": 0.1\n        },\n        # Case 4 (grid boundary saturation)\n        {\n            \"t\": [0, 1, 2, 3],\n            \"E_exp\": [80, 80, 80, 80],\n            \"E_obs\": [60, 60, 100, 100],\n            \"r\": [1, 1, 1, 1],\n            \"d_min\": -10, \"d_max\": 10, \"Delta\": 1,\n            \"gamma\": 0.7, \"beta\": 0.05\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        drift_sequence = estimate_drift_dp(params)\n        all_results.append(drift_sequence)\n        \n    # Custom format printing\n    output_parts = []\n    for seq in all_results:\n        formatted_seq = \",\".join([f\"{val:.4f}\" for val in seq])\n        output_parts.append(f\"[{formatted_seq}]\")\n    print(f\"[{','.join(output_parts)}]\")\n\ndef estimate_drift_dp(params):\n    \"\"\"\n    Estimates the drift sequence using dynamic programming.\n    \"\"\"\n    t = params[\"t\"]\n    E_exp = np.array(params[\"E_exp\"])\n    E_obs = np.array(params[\"E_obs\"])\n    r = np.array(params[\"r\"])\n    d_min, d_max, Delta = params[\"d_min\"], params[\"d_max\"], params[\"Delta\"]\n    gamma, beta = params[\"gamma\"], params[\"beta\"]\n    \n    N = len(t)\n    d_grid = np.round(np.arange(d_min, d_max + Delta * 0.5, Delta), 5)\n    M = len(d_grid)\n\n    if N == 0:\n        return []\n\n    if N == 1:\n        unconstrained_d0 = E_obs[0] - E_exp[0]\n        best_d_idx = np.argmin(np.abs(d_grid - unconstrained_d0))\n        return [d_grid[best_d_idx]]\n\n    C_costs = np.zeros((N, M))\n    weights = 1 + beta * r\n    mismatches = E_obs - E_exp\n    for i in range(N):\n        for k in range(M):\n            C_costs[i, k] = weights[i] * (mismatches[i] - d_grid[k])**2\n\n    dp_table = np.full((N, M, M), np.inf)\n    ptr_table = np.zeros((N, M, M), dtype=int)\n\n    for j in range(M): # index for d_0\n        for k in range(M): # index for d_1\n            p1_cost = gamma * np.abs(d_grid[k] - d_grid[j])\n            dp_table[1, j, k] = C_costs[0, j] + C_costs[1, k] + p1_cost\n    \n    if N == 2:\n        # Backtracking for N=2 is simpler\n        path_indices = np.zeros(N, dtype=int)\n        min_val = np.min(dp_table[1])\n        min_indices = np.argwhere(dp_table[1] == min_val)[0]\n        path_indices[0], path_indices[1] = min_indices[0], min_indices[1]\n        return [d_grid[idx] for idx in path_indices]\n\n    for i in range(2, N):\n        transition_costs = np.zeros((M, M, M))\n        for j in range(M): # d_i-1\n            for k in range(M): # d_i\n                for l in range(M): # d_i-2\n                    p_cost = gamma * np.abs(d_grid[k] - 2 * d_grid[j] + d_grid[l])\n                    transition_costs[l, j, k] = dp_table[i-1, l, j] + p_cost\n        \n        min_costs = np.min(transition_costs, axis=0)\n        best_indices = np.argmin(transition_costs, axis=0)\n        \n        dp_table[i, :, :] = C_costs[i, :] + min_costs\n        ptr_table[i, :, :] = best_indices\n\n    path_indices = np.zeros(N, dtype=int)\n    \n    final_step_idx = N - 1\n    min_val = np.min(dp_table[final_step_idx])\n    min_indices = np.argwhere(dp_table[final_step_idx] == min_val)[0]\n    best_j, best_k = min_indices[0], min_indices[1]\n\n    path_indices[final_step_idx] = best_k\n    path_indices[final_step_idx - 1] = best_j\n\n    for i in range(N - 1, 1, -1):\n        prev_l = ptr_table[i, path_indices[i-1], path_indices[i]]\n        path_indices[i-2] = prev_l\n\n    return [d_grid[idx] for idx in path_indices]\n\n# Running this block will execute the solution and print the output.\n# If you are running this in a standard Python environment, uncomment the next line:\n# solve()\n# As per instructions, the final file must contain the runnable code.\n# The following is a hack to allow the solve function to be callable but not run on import\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}