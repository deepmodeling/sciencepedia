{
    "hands_on_practices": [
        {
            "introduction": "在分析神经元放电模式之前，我们必须确保其时间戳的准确性。记录电极的物理漂移会扭曲测量到的时间，可能导致错误的科学结论。本练习提供了一个具体的动手实践机会，让您将一个已知的漂移模型应用于原始尖峰时间序列，并直接观察这种校正如何“修复”虚假的不应期违规，从而为后续分析清理数据。这是脉冲分选质量控制中的一项基本技能 。",
            "id": "4189789",
            "problem": "您会获得测量的脉冲发放时间和测量时钟的漂移模型，您必须分析相对于绝对不应期阈值的脉冲间期（Inter-Spike Interval, ISI）违规情况。请使用以下背景和定义作为您推导和算法的基础。\n\n定义与事实：\n- 脉冲序列被建模为测量时间轴上的一系列事件时间 $\\{\\tilde{t}_i\\}_{i=1}^N$，其中 $\\tilde{t}_i$ 以毫秒为单位。\n- 脉冲间期（ISI）定义为 $x_k = t_{k+1} - t_k$，其中 $t_i$ 是考虑时钟漂移后校正的时间；等效地，在校正前的测量轴上，其定义为 $x_k^{\\mathrm{raw}} = \\tilde{t}_{k+1} - \\tilde{t}_k$。\n- 绝对不应期是来自单个神经元的两个动作电位之间的最短时间；在许多哺乳动物神经元中，一个被广泛接受的下限约为 $1\\,\\mathrm{ms}$。如果任何 $x_k$ 低于阈值 $\\tau$，则表明一个推定的单个单元存在不应期违规。\n- 漂移校正：令 $a(t)$ 为将测量增量 $d\\tilde{t}$ 映射到校正增量 $dt$ 的瞬时乘性尺度因子。校正后的时间由积分 $t(\\tilde{t}) = \\int_0^{\\tilde{t}} a(u)\\,du$ 定义。如果 $a(t)$ 是分段常数，该积分简化为缩放后重叠部分的总和。\n\n任务：\n1. 对于每个测试用例，在校正时间轴 $t_i$ 上计算 ISI 直方图，箱宽 $\\Delta = 0.1\\,\\mathrm{ms}$，使用覆盖 $[0,10]\\,\\mathrm{ms}$ 的箱。同时，在原始轴 $\\tilde{t}_i$ 上使用相同的分箱方式计算 ISI 直方图。直方图是一个内部计算步骤；最终输出在下面指定。\n2. 对于每个测试用例，计算严格小于 $\\tau = 1.5\\,\\mathrm{ms}$ 的原始 ISI $x_k^{\\mathrm{raw}}$ 的比例 $f_{\\tau}^{\\mathrm{raw}}$，表示为小数。如果脉冲数少于 2 个，则定义 $f_{\\tau}^{\\mathrm{raw}} = 0$。\n3. 使用提供的 $a(t)$ 执行漂移校正，计算校正后的时间 $t_i$，并由此计算校正后的 ISI $x_k$。计算 $f_{\\tau}^{\\mathrm{corr}} > 0$ 是否成立，其中 $f_{\\tau}^{\\mathrm{corr}}$ 是严格小于 $\\tau = 1.5\\,\\mathrm{ms}$ 的校正后 ISI 的比例。仅报告其布尔值解释 $b^{\\mathrm{corr}} = (f_{\\tau}^{\\mathrm{corr}} > 0)$。\n4. 物理单位：所有时间单位为毫秒，直方图单位为毫秒，比例是无单位的小数。\n\n测试套件：\n为以下五个测试用例提供解决方案。在每个案例中，列出以毫秒为单位的测量脉冲发放时间 $\\{\\tilde{t}_i\\}$ 和作为分段常数段的漂移模型 $a(t)$。这里，$a(t)$ 作用于以毫秒为单位的测量时间轴。\n\n- 测试用例 1（干净的单个单元，静态时钟）：\n  - 测量的脉冲发放时间：$[0,5,10,15,20]\\,\\mathrm{ms}$。\n  - 漂移：对于 $t \\in [0,\\infty)$，$a(t) = 1.0$。\n\n- 测试用例 2（一个短 ISI，静态时钟）：\n  - 测量的脉冲发放时间：$[0,1.0,5.0,10.0]\\,\\mathrm{ms}$。\n  - 漂移：对于 $t \\in [0,\\infty)$，$a(t) = 1.0$。\n\n- 测试用例 3（由于时钟速度漂移导致的表面短 ISI，通过拉伸测量轴进行校正）：\n  - 测量的脉冲发放时间：$[0,1.2,3.2]\\,\\mathrm{ms}$。\n  - 漂移：对于 $t \\in [0,4.0)\\,\\mathrm{ms}$，$a(t) = 1.6666666667$；对于 $t \\in [4.0,\\infty)$，$a(t) = 1.0$。\n\n- 测试用例 4（边缘情况，单个脉冲）：\n  - 测量的脉冲发放时间：$[100.0]\\,\\mathrm{ms}$。\n  - 漂移：对于 $t \\in [0,\\infty)$，$a(t) = 1.0$。\n\n- 测试用例 5（多个短 ISI，局部时钟速度漂移）：\n  - 测量的脉冲发放时间：$[0,0.8,1.6,5.0,10.0]\\,\\mathrm{ms}$。\n  - 漂移：对于 $t \\in [0,2.0)\\,\\mathrm{ms}$，$a(t) = 1.25$；对于 $t \\in [2.0,\\infty)$，$a(t) = 1.0$。\n\n解释标准：\n- 对于一个推定的单个单元，任何校正后 ISI $x_k$ 严格小于 $\\tau$ 的存在都意味着一次不应期违规。因此，如果 $f_{\\tau}^{\\mathrm{corr}} > 0$，则报告 $b^{\\mathrm{corr}} = \\mathrm{True}$；否则报告 $b^{\\mathrm{corr}} = \\mathrm{False}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。元素必须按 $[f_{\\tau,1}^{\\mathrm{raw}},b^{\\mathrm{corr}}_1,f_{\\tau,2}^{\\mathrm{raw}},b^{\\mathrm{corr}}_2,f_{\\tau,3}^{\\mathrm{raw}},b^{\\mathrm{corr}}_3,f_{\\tau,4}^{\\mathrm{raw}},b^{\\mathrm{corr}}_4,f_{\\tau,5}^{\\mathrm{raw}},b^{\\mathrm{corr}}_5]$ 的顺序排列，其中每个 $f_{\\tau,i}^{\\mathrm{raw}}$ 是一个小数，每个 $b^{\\mathrm{corr}}_i \\in \\{\\mathrm{True},\\mathrm{False}\\}$。",
            "solution": "该问题要求对来自神经元脉冲序列数据的脉冲间期（ISI）进行分析，其中包括对测量时钟漂移的校正。核心任务是计算原始数据中违反不应期阈值的 ISI 比例，并确定在应用漂移校正模型后是否存在任何此类违规。\n\n对问题陈述的验证证实了其具有科学依据、问题适定、客观，并包含推导唯一且有意义的解决方案所需的所有信息。不应期、时钟漂移以及用于校正的数学模型等概念在计算神经科学中都是标准内容。\n\n解决此问题的基本原则如下：\n\n1.  **脉冲间期（ISI）计算**：给定一个脉冲时间序列 $\\{s_i\\}_{i=1}^N$，ISI 是连续脉冲之间的时间差，即 $\\{x_k = s_{k+1} - s_k\\}_{k=1}^{N-1}$。我们对测量的（原始）脉冲时间（表示为 $\\{\\tilde{t}_i\\}$）和经漂移校正的脉冲时间（表示为 $\\{t_i\\}$）都进行此计算。\n    -   原始 ISI：$\\tilde{x}_k = \\tilde{t}_{k+1} - \\tilde{t}_k$。\n    -   校正后 ISI：$x_k = t_{k+1} - t_k$。\n\n2.  **不应期违规**：如果任何 ISI 短于指定的绝对不应期阈值 $\\tau$，则标记为不应期违规。对于此问题，阈值定为 $\\tau = 1.5\\,\\mathrm{ms}$。因此，如果校正后的 ISI 存在 $x_k  \\tau$ 或原始 ISI 存在 $\\tilde{x}_k  \\tau$，则发生违规。\n\n3.  **漂移校正模型**：测量的时间间隔 $d\\tilde{t}$ 与校正的时间间隔 $dt$ 之间的关系由 $dt = a(\\tilde{t}) \\, d\\tilde{t}$ 给出，其中 $a(\\tilde{t})$ 是一个作用于测量时间轴上的随时间变化的尺度因子。为了找到与测量时间 $\\tilde{t}_i$ 对应的校正时间 $t_i$，我们必须从一个共同的参考点（通常为 $t_0=\\tilde{t}_0=0$）对此关系进行积分：\n    $$t(\\tilde{t}_i) = \\int_0^{\\tilde{t}_i} a(u)\\,du$$\n    其中 $u$ 是沿测量时间轴的积分变量。\n\n    问题指明 $a(u)$ 是一个分段常数函数。假设 $a(u)$ 在一系列区间 $[b_{j-1}, b_j)$ 上定义，每个区间内都有一个常数尺度因子 $a_j$，其中 $b_0 = 0$。要计算落入第 $m$ 个区间的测量时间 $\\tilde{t}_i$（即 $b_{m-1} \\le \\tilde{t}_i  b_m$）的积分，该积分变为一个和：\n    $$t(\\tilde{t}_i) = \\left( \\sum_{j=1}^{m-1} \\int_{b_{j-1}}^{b_j} a_j \\,du \\right) + \\int_{b_{m-1}}^{\\tilde{t}_i} a_m \\,du$$\n    $$t(\\tilde{t}_i) = \\left( \\sum_{j=1}^{m-1} a_j (b_j - b_{j-1}) \\right) + a_m (\\tilde{t}_i - b_{m-1})$$\n    该公式提供了一个将每个测量脉冲时间 $\\tilde{t}_i$ 映射到其校正时间 $t_i$ 的直接算法。\n\n每个测试用例的算法步骤如下：\n1.  给定测量的脉冲时间 $\\{\\tilde{t}_i\\}$，通过取连续元素之差来计算原始 ISI $\\{\\tilde{x}_k\\}$。如果脉冲数 $N  2$，则没有 ISI。\n2.  计算严格小于 $\\tau = 1.5\\,\\mathrm{ms}$ 的原始 ISI 的比例 $f_{\\tau}^{\\mathrm{raw}}$。如果 $N  2$，根据定义 $f_{\\tau}^{\\mathrm{raw}}$ 为 $0$。\n3.  将上述分段积分公式应用于每个测量的脉冲时间 $\\tilde{t}_i$，以获得校正后的脉冲时间集合 $\\{t_i\\}$。\n4.  通过取连续校正脉冲时间之差来计算校正后的 ISI $\\{x_k\\}$。\n5.  确定是否有任何校正后的 ISI 严格小于 $\\tau = 1.5\\,\\mathrm{ms}$。这等同于检查校正后的违规 ISI 比例 $f_{\\tau}^{\\mathrm{corr}}$ 是否大于 $0$。结果是一个布尔值，$b^{\\mathrm{corr}} = (f_{\\tau}^{\\mathrm{corr}} > 0)$。\n\n我们以测试用例 5 为例进行说明：\n-   测量的脉冲发放时间：$\\{\\tilde{t}_i\\} = [0, 0.8, 1.6, 5.0, 10.0]\\,\\mathrm{ms}$。\n-   漂移模型：对于 $u \\in [0, 2.0)\\,\\mathrm{ms}$，$a(u) = 1.25$；对于 $u \\in [2.0, \\infty)\\,\\mathrm{ms}$，$a(u) = 1.0$。\n-   阈值：$\\tau = 1.5\\,\\mathrm{ms}$。\n\n**原始数据分析：**\n-   原始 ISI：$\\{\\tilde{x}_k\\} = [0.8 - 0, 1.6 - 0.8, 5.0 - 1.6, 10.0 - 5.0] = [0.8, 0.8, 3.4, 5.0]\\,\\mathrm{ms}$。\n-   两个 ISI（$0.8$ 和 $0.8$）小于 $1.5\\,\\mathrm{ms}$。\n-   $f_{\\tau}^{\\mathrm{raw}} = 2/4 = 0.5$。\n\n**漂移校正：**\n-   $t_1 = t(\\tilde{t}_1=0) = 0$。\n-   $t_2 = t(\\tilde{t}_2=0.8) = \\int_0^{0.8} 1.25 du = 1.25 \\times 0.8 = 1.0\\,\\mathrm{ms}$。\n-   $t_3 = t(\\tilde{t}_3=1.6) = \\int_0^{1.6} 1.25 du = 1.25 \\times 1.6 = 2.0\\,\\mathrm{ms}$。\n-   $t_4 = t(\\tilde{t}_4=5.0) = \\int_0^{2.0} 1.25 du + \\int_{2.0}^{5.0} 1.0 du = (1.25 \\times 2.0) + (1.0 \\times (5.0 - 2.0)) = 2.5 + 3.0 = 5.5\\,\\mathrm{ms}$。\n-   $t_5 = t(\\tilde{t}_5=10.0) = \\int_0^{2.0} 1.25 du + \\int_{2.0}^{10.0} 1.0 du = (1.25 \\times 2.0) + (1.0 \\times (10.0 - 2.0)) = 2.5 + 8.0 = 10.5\\,\\mathrm{ms}$。\n-   校正后脉冲发放时间：$\\{t_i\\} = [0, 1.0, 2.0, 5.5, 10.5]\\,\\mathrm{ms}$。\n\n**校正后分析：**\n-   校正后 ISI：$\\{x_k\\} = [1.0 - 0, 2.0 - 1.0, 5.5 - 2.0, 10.5 - 5.5] = [1.0, 1.0, 3.5, 5.0]\\,\\mathrm{ms}$。\n-   两个校正后 ISI（$1.0$ 和 $1.0$）小于 $1.5\\,\\mathrm{ms}$。\n-   $f_{\\tau}^{\\mathrm{corr}} = 2/4 = 0.5$。由于 $f_{\\tau}^{\\mathrm{corr}} > 0$，布尔报告为 $b^{\\mathrm{corr}} = \\mathrm{True}$。\n\n此结构化过程将应用于所有测试用例以生成最终结果。提供的 Python 代码实现了该算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes refractory period violation statistics for raw and drift-corrected spike times.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case includes measured spike times and a piecewise drift model.\n    # The drift model is a list of tuples (boundary_time, scale_factor).\n    test_cases = [\n        {\n            \"spikes\": [0.0, 5.0, 10.0, 15.0, 20.0],\n            \"drift\": [(float('inf'), 1.0)]\n        },\n        {\n            \"spikes\": [0.0, 1.0, 5.0, 10.0],\n            \"drift\": [(float('inf'), 1.0)]\n        },\n        {\n            \"spikes\": [0.0, 1.2, 3.2],\n            \"drift\": [(4.0, 1.6666666667), (float('inf'), 1.0)]\n        },\n        {\n            \"spikes\": [100.0],\n            \"drift\": [(float('inf'), 1.0)]\n        },\n        {\n            \"spikes\": [0.0, 0.8, 1.6, 5.0, 10.0],\n            \"drift\": [(2.0, 1.25), (float('inf'), 1.0)]\n        }\n    ]\n\n    # Refractory period violation threshold in milliseconds.\n    tau = 1.5\n\n    results = []\n    \n    for case in test_cases:\n        measured_times = np.array(case[\"spikes\"])\n        drift_model = case[\"drift\"]\n\n        # --- Part 1: Raw ISI Analysis ---\n        \n        # Calculate the fraction of raw ISIs violating the threshold.\n        # If there are fewer than 2 spikes, the fraction is 0 by definition.\n        if len(measured_times)  2:\n            f_tau_raw = 0.0\n        else:\n            raw_isis = np.diff(measured_times)\n            num_violations = np.sum(raw_isis  tau)\n            f_tau_raw = num_violations / len(raw_isis)\n\n        # --- Part 2: Drift Correction ---\n\n        # Apply the piecewise integral to correct each measured spike time.\n        # t(t_tilde) = integral from 0 to t_tilde of a(u) du.\n        corrected_times = []\n        for mt in measured_times:\n            ct = 0.0\n            last_boundary = 0.0\n            for boundary, factor in drift_model:\n                # If the measured time exceeds the current segment boundary\n                if mt > boundary:\n                    ct += (boundary - last_boundary) * factor\n                    last_boundary = boundary\n                # If the measured time is within the current segment\n                else:\n                    ct += (mt - last_boundary) * factor\n                    break\n            corrected_times.append(ct)\n        \n        corrected_times_np = np.array(corrected_times)\n\n        # --- Part 3: Corrected ISI Analysis ---\n\n        # Determine if any corrected ISI violates the threshold.\n        # If there are fewer than 2 spikes, no violations can occur.\n        if len(corrected_times_np)  2:\n            b_corr = False\n        else:\n            corrected_isis = np.diff(corrected_times_np)\n            # Check if any corrected ISI is strictly less than the threshold.\n            any_violation = np.any(corrected_isis  tau)\n            b_corr = bool(any_violation)\n            \n        results.append(f_tau_raw)\n        results.append(b_corr)\n\n    # Final print statement in the exact required format.\n    # str() will convert floats to decimal strings and booleans to 'True'/'False'.\n    output_str = ','.join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在完成漂移校正后，我们仍需设定一个阈值 $\\tau$ 来统计剩余的不应期违规。这个选择并非一成不变，特别是对于以高频“簇放电”（bursting）模式发放动作电位的神经元。本练习将挑战您像神经科学家一样思考，权衡严格的质量标准与误解神经元自然放电特性的风险。这是一个关于如何在数据分析中做出明智、数据驱动决策的案例研究 。",
            "id": "4189758",
            "problem": "使用高密度探针从啮齿动物新皮层记录到的一个单单元簇表现出与脉冲簇放电一致的短脉冲间期行为。设脉冲发放时间为 $t_1, t_2, \\dots, t_N$，定义脉冲间期 (Interspike Interval, ISI) 为 $\\Delta t_i = t_{i+1} - t_i$。生理绝对不应期为 $\\tau_{\\mathrm{abs}} = 1.4\\,\\mathrm{ms}$，这是由钠离子通道的失活和恢复所决定的。为了评估不应期违规 (Refractory Period Violations, RPV)，一个脉冲分选质量标准规定，如果短于所选不应期窗口 $\\tau$ 的 ISI 比例至多为 $\\alpha = 1\\%$，则接受该单元。已应用电极漂移校正 (Probe Drift Correction, PDC)，校正后的残余时间对齐抖动近似为高斯分布，其标准差为 $\\sigma_{\\mathrm{post}} = 0.1\\,\\mathrm{ms}$；校正前的抖动标准差为 $\\sigma_{\\mathrm{pre}} = 0.2\\,\\mathrm{ms}$。该单元在校正后（去除伪影后，基于 $N \\gg 1$ 个脉冲间期计算）的经验 ISI 分位数如下：\n- $Q(0.5\\%) = 1.6\\,\\mathrm{ms}$,\n- $Q(1.0\\%) = 1.8\\,\\mathrm{ms}$,\n- $Q(1.5\\%) = 2.0\\,\\mathrm{ms}$,\n- $Q(2.0\\%) = 2.2\\,\\mathrm{ms}$,\n- $Q(5.0\\%) = 3.0\\,\\mathrm{ms}$,\n- $Q(10.0\\%) = 4.0\\,\\mathrm{ms}$,\n其中 $Q(p)$ 表示满足 $\\mathbb{P}(\\Delta t \\le Q(p)) = p$ 的值。该单元表现出簇状放电，许多 ISI 位于 $2$–$6\\,\\mathrm{ms}$ 范围内，这些在生理上是合理的，不应被错误地归类为违规。\n\n你必须评估使用更严格的不应期窗口（更大的 $\\tau$ 会导致更多的 RPV 计数，并可能拒绝簇状放电单元）与保留簇状放电神经元之间的权衡，并根据 ISI 分布和漂移校正后的抖动设计一个自适应的 $\\tau$ 选择方案。该自适应设计应选择恰好位于一个保守生理保护区上方的最小 ISI 百分位数值作为 $\\tau$。该保护区由 $\\tau_{\\mathrm{abs}}$ 和校正后的残余时间不确定性构建。根据此设计和接受标准 $\\alpha$，哪个选项正确地指定了 $\\tau$ 和保留决定，同时恰当地解释了与簇状放电的权衡？\n\nA. 在 PDC 后选择 $\\tau = Q(1.0\\%) = 1.8\\,\\mathrm{ms}$。由此产生的 RPV 比例为 $1.0\\% \\le \\alpha$，因此该单元被接受。这个 $\\tau$ 值恰好位于一个保守的生理保护区之上，并且在很大程度上保留了 ISI 在 $2$–$6\\,\\mathrm{ms}$ 范围内的脉冲簇；增大 $\\tau$ 会不必要地将更多的脉冲簇 ISI 计为违规。\n\nB. 在 PDC 后选择 $\\tau = Q(2.0\\%) = 2.2\\,\\mathrm{ms}$。由此产生的 RPV 比例为 $2.0\\% > \\alpha$，因此该单元被拒绝。这个更严格的窗口能更好地防止漂移引起的污染，并改善脉冲簇的保留。\n\nC. 考虑校正前的情况，选择 $\\tau = Q(1.5\\%) = 2.0\\,\\mathrm{ms}$。由此产生的 RPV 比例为 $1.5\\% > \\alpha$，因此该单元被拒绝。这是最优的，因为它基于校正前的抖动，避免了在 PDC 后低估违规。\n\nD. 在 PDC 后选择 $\\tau = Q(5.0\\%) = 3.0\\,\\mathrm{ms}$ 以保留簇状放电。由此产生的 RPV 比例为 $5.0\\% \\le \\alpha$，因此该单元被接受，并且脉冲簇被完全保留；更严格的 $\\tau$ 值会在没有明显好处的情况下损害保留。",
            "solution": "用户要求对问题陈述进行严格验证，然后进行完整的解题推导并评估所有选项。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n- 脉冲发放时间: $t_1, t_2, \\dots, t_N$。\n- 脉冲间期 (Interspike Interval, ISI): $\\Delta t_i = t_{i+1} - t_i$。\n- 生理绝对不应期: $\\tau_{\\mathrm{abs}} = 1.4\\,\\mathrm{ms}$。\n- 接受标准: 短于所选不应期窗口 $\\tau$ 的 ISI 比例至多为 $\\alpha = 1\\%$。\n- 已应用电极漂移校正 (PDC)。\n- 校正后残余时间对齐抖动标准差: $\\sigma_{\\mathrm{post}} = 0.1\\,\\mathrm{ms}$。\n- 校正前抖动标准差: $\\sigma_{\\mathrm{pre}} = 0.2\\,\\mathrm{ms}$。\n- 校正后经验 ISI 分位数:\n  - $Q(0.5\\%) = 1.6\\,\\mathrm{ms}$\n  - $Q(1.0\\%) = 1.8\\,\\mathrm{ms}$\n  - $Q(1.5\\%) = 2.0\\,\\mathrm{ms}$\n  - $Q(2.0\\%) = 2.2\\,\\mathrm{ms}$\n  - $Q(5.0\\%) = 3.0\\,\\mathrm{ms}$\n  - $Q(10.0\\%) = 4.0\\,\\mathrm{ms}$\n- 分位数定义: $\\mathbb{P}(\\Delta t \\le Q(p)) = p$。\n- 单元行为: 簇状放电，许多 ISI 在 $2$–$6\\,\\mathrm{ms}$ 范围内。\n- 任务指令: 设计一个自适应的 $\\tau$ 选择方案，选择恰好位于一个保守生理保护区上方的最小 ISI 百分位数值作为 $\\tau$。该保护区由 $\\tau_{\\mathrm{abs}}$ 和校正后的残余时间不确定性构建。\n\n**步骤2：使用提取的给定条件进行验证**\n- **科学基础**: 该问题在细胞外电生理学和脉冲分选数据分析的原理上有很好的基础。绝对不应期、脉冲间期(ISI)、作为质量指标的不应期违规(RPV)、电极漂移和时间抖动等概念都是标准概念。提供的 $\\tau_{\\mathrm{abs}}$、$\\sigma_{\\mathrm{post}}$ 和 ISI 分位数的数值对于皮层神经元记录是现实的。\n- **适定性**: 该问题是适定的。它提供了所有必要的数据和一个清晰（尽管复杂）的指令来设计参数 $\\tau$。该指令的存在使得问题可以通过一个唯一的、合理的答案来解决。\n- **客观性**: 该问题使用该领域通用的精确、客观和技术性语言进行陈述。它提出了一个定量的分析任务，不含主观或基于意见的陈述。\n\n**步骤3：结论与行动**\n问题陈述是有效的。它在科学上是合理的，自洽的，并且可以定量求解。我将继续进行推导。\n\n### 解题推导\n\n主要任务是为不应期窗口 $\\tau$ 实现指定的自适应设计。设计规则是“选择恰好位于一个保守生理保护区上方的最小 ISI 百分位数值作为 $\\tau$。该保护区由 $\\tau_{\\mathrm{abs}}$ 和校正后的残余时间不确定性构建”。\n\n1.  **构建保守生理保护区 ($G$)**:\n    该保护区必须由生理绝对不应期 $\\tau_{\\mathrm{abs}} = 1.4\\,\\mathrm{ms}$ 和残余的校正后时间不确定性构建，后者的特征是标准差 $\\sigma_{\\mathrm{post}} = 0.1\\,\\mathrm{ms}$。\n\n    绝对不应期 $\\tau_{\\mathrm{abs}}$ 设定了一个严格的生理极限：单个神经元的真实 ISI 不可能比这个值短。然而，脉冲时间抖动使测量复杂化。如果我们将分析窗口 $\\tau$ 精确地设置在 $\\tau_{\\mathrm{abs}}$，任何略高于 $\\tau_{\\mathrm{abs}}$ 的真实 ISI 由于对称的抖动分布，将有很大几率被测量到低于 $\\tau_{\\mathrm{abs}}$，从而导致 RPV 的高估。\n\n    因此，分析窗口 $\\tau$ 必须设置在大于 $\\tau_{\\mathrm{abs}}$ 的值上。“生理保护区” ($G$) 作为我们选择 $\\tau$ 的下限。构建这个保护区的一个保守方法是在 $\\tau_{\\mathrm{abs}}$ 上加上一个考虑了时间抖动的安全边际。一种常见的“保守”做法是使用标准差的倍数。我们将保护区定义为 $G = \\tau_{\\mathrm{abs}} + k \\cdot \\sigma_{\\mathrm{post}}$，其中 $k$ 是一个小的整数（例如 $2$ 或 $3$）以创建一个可靠的缓冲区。请注意，抖动会影响 ISI，即两个脉冲时间的差值。如果时间误差是独立的，ISI 上的抖动标准差是 $\\sqrt{2}\\sigma_{\\mathrm{post}}$。然而，问题指定使用给定的“时间不确定性” $\\sigma_{\\mathrm{post}}$，这表明意图是直接使用该值，这是一种常见的简化。让我们测试这种更简单的构建方法。\n\n    我们选择 $k=3$ 来构建一个非常保守的保护区：\n    $$G = \\tau_{\\mathrm{abs}} + 3 \\cdot \\sigma_{\\mathrm{post}} = 1.4\\,\\mathrm{ms} + 3 \\cdot (0.1\\,\\mathrm{ms}) = 1.7\\,\\mathrm{ms}$$\n    即使选择一个稍不保守的 $k=2$：\n    $$G = \\tau_{\\mathrm{abs}} + 2 \\cdot \\sigma_{\\mathrm{post}} = 1.4\\,\\mathrm{ms} + 2 \\cdot (0.1\\,\\mathrm{ms}) = 1.6\\,\\mathrm{ms}$$\n    所以，我们的保守生理保护区 $G$ 位于 $[1.6, 1.7]\\,\\mathrm{ms}$ 的范围内。\n\n2.  **根据保护区和 ISI 分位数选择 $\\tau$**:\n    规则是选择 $\\tau$ 为“恰好位于”保护区 $G$ 上方的“最小 ISI 百分位数值”。可用的百分位数值（分位数）有：$1.6\\,\\mathrm{ms}$、$1.8\\,\\mathrm{ms}$、$2.0\\,\\mathrm{ms}$ 等。\n\n    -   如果我们使用 $G = 1.6\\,\\mathrm{ms}$，我们需要严格大于 $1.6\\,\\mathrm{ms}$ 的最小分位数值。这个值是 $1.8\\,\\mathrm{ms}$。\n    -   如果我们使用 $G = 1.7\\,\\mathrm{ms}$，我们需要严格大于 $1.7\\,\\mathrm{ms}$ 的最小分位数值。这个值也是 $1.8\\,\\mathrm{ms}$。\n\n    两种合理的保护区构建方法都指向同一个选择。因此，自适应设计选择：\n    $$\\tau = Q(1.0\\%) = 1.8\\,\\mathrm{ms}$$\n\n3.  **应用接受标准并评估权衡**:\n    当 $\\tau = 1.8\\,\\mathrm{ms}$ 时，小于或等于 $\\tau$ 的 ISI 比例由分位数函数的定义给出：$\\mathbb{P}(\\Delta t \\le 1.8\\,\\mathrm{ms}) = 1.0\\%$。这就是我们的 RPV 比例。\n\n    接受标准是 RPV 比例必须最多为 $\\alpha = 1\\%$。由于我们计算出的 RPV 比例是 $1.0\\%$，条件 $1.0\\% \\le 1.0\\%$ 得到满足。因此，该单元应被**接受**。\n\n    选择 $\\tau = 1.8\\,\\mathrm{ms}$ 还必须在该单元的簇状放电行为（许多 ISI 在 $2$–$6\\,\\mathrm{ms}$ 范围内）的背景下进行评估。我们选择的窗口 $\\tau = 1.8\\,\\mathrm{ms}$ 低于这个簇状放电范围的起始值（$2\\,\\mathrm{ms}$）。这是一个好的选择，因为它避免了将来自脉冲簇的短时、生理性的 ISI 错误地归类为不应期违规。一个更大的 $\\tau$（例如 $2.2\\,\\mathrm{ms}$ 或 $3.0\\,\\mathrm{ms}$）将会侵入到簇状放电的分布中，导致人为地提高 RPV 计数，并可能错误地拒绝一个有效的簇状放电神经元。\n\n### 逐项分析\n\n**A. 在 PDC 后选择 $\\tau = Q(1.0\\%) = 1.8\\,\\mathrm{ms}$。由此产生的 RPV 比例为 $1.0\\% \\le \\alpha$，因此该单元被接受。这个 $\\tau$ 值恰好位于一个保守的生理保护区之上，并且在很大程度上保留了 ISI 在 $2$–$6\\,\\mathrm{ms}$ 范围内的脉冲簇；增大 $\\tau$ 会不必要地将更多的脉冲簇 ISI 计为违规。**\n- **$\\tau$ 的选择**: 与我们的推导一致。它正确地使用了 PDC 后的信息。\n- **决定**: RPV 比例为 $1.0\\%$。标准是 $\\le 1\\%$。该单元被正确地接受。\n- **理由**: 解释是准确的。$\\tau = 1.8\\,\\mathrm{ms}$ 恰好位于我们构建的生理保护区（$1.6$–$1.7\\,\\mathrm{ms}$）之上。它正确地避开了 $2$–$6\\,\\mathrm{ms}$ 的簇状放电 ISI 范围，并且反对使用更大 $\\tau$ 的论点是合理的。\n- **结论**: **正确**。\n\n**B. 在 PDC 后选择 $\\tau = Q(2.0\\%) = 2.2\\,\\mathrm{ms}$。由此产生的 RPV 比例为 $2.0\\% > \\alpha$，因此该单元被拒绝。这个更严格的窗口能更好地防止漂移引起的污染，并改善脉冲簇的保留。**\n- **$\\tau$ 的选择**: 这个选择 $\\tau = 2.2\\,\\mathrm{ms}$ 违反了问题中选择保护区上方*最小*百分位数值的指令。$1.8\\,\\mathrm{ms}$ 和 $2.0\\,\\mathrm{ms}$ 是更小的合格值。\n- **决定**: 计算是正确的：如果选择 $\\tau = 2.2\\,\\mathrm{ms}$，RPV 比例将是 $2.0\\%$，由于 $2.0\\% > 1\\%$，该单元将被拒绝。\n- **理由**: 声称这“改善脉冲簇的保留”是完全矛盾的。一个更大（更严格）的窗口 $\\tau$ 会通过包含短 ISI 的脉冲簇来增加 RPV 计数，从而*减少*了保留簇状放电单元的机会。\n- **结论**: **不正确**。\n\n**C. 考虑校正前的情况，选择 $\\tau = Q(1.5\\%) = 2.0\\,\\mathrm{ms}$。由此产生的 RPV 比例为 $1.5\\% > \\alpha$，因此该单元被拒绝。这是最优的，因为它基于校正前的抖动，避免了在 PDC 后低估违规。**\n- **$\\tau$ 的选择**: 这个选择是有缺陷的。它使用“校正前考虑”($\\sigma_{\\mathrm{pre}}$)，这在应用 PDC 后是不合逻辑的。我们必须使用校正后数据的属性，即 $\\sigma_{\\mathrm{post}}$。该选择也违反了基于使用 $\\sigma_{\\mathrm{post}}$ 正确构建保护区的“最小百分位数”规则。\n- **决定**: 计算是正确的：如果 $\\tau = 2.0\\,\\mathrm{ms}$，RPV 比例是 $1.5\\%$，导致拒绝，因为 $1.5\\% > 1\\%$。\n- **理由**: 其理由是荒谬的。使用更大的校正前抖动会导致一个更宽的窗口 $\\tau$，这会*高估*RPV，而不是“避免低估”它们。必须信任漂移校正并使用校正后的不确定性。\n- **结论**: **不正确**。\n\n**D. 在 PDC 后选择 $\\tau = Q(5.0\\%) = 3.0\\,\\mathrm{ms}$ 以保留簇状放电。由此产生的 RPV 比例为 $5.0\\% \\le \\alpha$，因此该单元被接受，并且脉冲簇被完全保留；更严格的 $\\tau$ 值会在没有明显好处的情况下损害保留。**\n- **$\\tau$ 的选择**: 这个选择 $\\tau=3.0\\,\\mathrm{ms}$ 与设计原则严重不符。\n- **决定**: 该陈述包含一个基本错误：“RPV 比例为 $5.0\\% \\le \\alpha$”。RPV 比例将是 $5.0\\%$，而 $\\alpha=1\\%$。不等式 $5.0\\% \\le 1.0\\%$ 是错误的。该单元将被拒绝，而不是接受。\n- **理由**: 声称这个选择有助于“保留簇状放电”是错误的。一个 $\\tau = 3.0\\,\\mathrm{ms}$ 的窗口直接切入了指定的 $2$–$6\\,\\mathrm{ms}$ 簇状放电范围，将许多有效的脉冲簇 ISI 算作违规，并确保该单元被拒绝。\n- **结论**: **不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在真实的实验中，漂移函数通常是未知的，我们必须从数据本身来估计它。这个高级练习将指导您设计一个复杂的动态规划算法，以找到最可能的漂移轨迹。该算法融合了波形能量和不应期违规计数等多个数据特征来构建一个稳健的估计，这反映了该领域最前沿的技术方法 。",
            "id": "4189827",
            "problem": "给定一个区块序列，这些区块代表来自细胞外电极阵列的尖峰信号记录的连续时间段。对于每个区块 $i \\in \\{0,1,\\dots,N-1\\}$，为您提供区块中心时间 $t_i$（单位：秒）、观测到的平均模板能量 $E^{\\mathrm{obs}}_i$（单位：$\\mu\\mathrm{V}^2$）、从匹配的尖峰模板中推导出的预期模板能量 $E^{\\mathrm{exp}}_i$（单位：$\\mu\\mathrm{V}^2$），以及测得的不应期违规（RPV）计数 $r_i$。不应期违规定义为在区块内分配给该模板的尖峰中，尖峰间期低于 $2\\,\\mathrm{ms}$ 固定不应期阈值的数量。不应期违规可衡量聚类质量，并且当漂移导致模板与真实尖峰波形错位时，其数量往往会增加。\n\n一个核心假设是，记录探头随时间的平移漂移会导致观测能量发生缓慢变化，这种变化可以建模为一个加性漂移函数 $d(t)$，因此，在没有噪声的情况下，能量应满足 $E^{\\mathrm{obs}}_i \\approx E^{\\mathrm{exp}}_i + d(t_i)$。目标是估计一个跨区块的分段线性漂移函数 $d(t)$，该函数能同时解释能量失配问题并减少不应期违规。\n\n从以下基本出发点开始：\n- 细胞外尖峰记录中的不应期意味着同一个神经元很少在 $2\\,\\mathrm{ms}$ 内发放两次尖峰，因此具有许多违规的区块表明存在错误分配，这可以通过更好的漂移校正来减少。\n- 最小二乘法原理建议通过惩罚模型预测值与观测值之间的平方差，从而在高斯噪声假设下获得稳健的估计。\n- 可以通过惩罚离散曲率来鼓励分段线性，当区块在时间上等间距时，这可以通过区块序列中的二阶差分来建模。\n\n将漂移值 $d_i := d(t_i)$ 的每个区块的数据保真度成本定义为\n$$\nC_i(d_i) \\equiv w_i\\left(E^{\\mathrm{obs}}_i - E^{\\mathrm{exp}}_i - d_i\\right)^2,\n$$\n其中权重 $w_i$ 随着不应期违规计数增加而增加，如下所示\n$$\nw_i \\equiv 1 + \\beta r_i,\n$$\n其中 $\\beta \\ge 0$ 是一个参数。\n\n为了激励分段线性，定义一个曲率惩罚项，通过绝对二阶差分来惩罚时间上等间距的连续区块间的斜率变化\n$$\nP(d_{i-2},d_{i-1},d_i) \\equiv \\gamma\\,\\left|\\left(d_i - d_{i-1}\\right) - \\left(d_{i-1} - d_{i-2}\\right)\\right| = \\gamma\\,|d_i - 2d_{i-1} + d_{i-2}|,\n$$\n其中 $\\gamma \\ge 0$ 是一个参数。对于第一个过渡，定义一个初始斜率为零的先验，并通过以下方式惩罚第一个斜率\n$$\nP_1(d_0,d_1) \\equiv \\gamma\\,|d_1 - d_0|.\n$$\n\n您将设计一种动态规划方法，用于在一个离散网格上估计一个漂移值序列 $\\{d_i\\}_{i=0}^{N-1}$\n$$\n\\mathcal{D} \\equiv \\{d_{\\min}, d_{\\min}+\\Delta, d_{\\min}+2\\Delta, \\dots, d_{\\max}\\},\n$$\n其中 $d_{\\min}$、$d_{\\max}$ 和 $\\Delta$ 以 $\\mu\\mathrm{V}^2$ 为单位给出，并假设区块在时间上是等间距的。目标是最小化总成本\n$$\nJ(d_0,\\dots,d_{N-1}) = \\sum_{i=0}^{N-1} C_i(d_i) \\;+\\; \\left[ P_1(d_0,d_1) + \\sum_{i=2}^{N-1} P(d_{i-2},d_{i-1},d_i) \\right].\n$$\n\n您的程序必须：\n1. 实现一个动态规划算法，该算法利用最优子结构原理，在 $\\mathcal{D}$ 上生成一个使 $J$ 最小化的全局最优离散序列 $\\{d_i\\}$。\n2. 处理所有边界情况，特别是 $N=1$、$N=2$ 和 $N\\ge 3$。\n3. 对每个提供的测试用例，返回估计的漂移值序列 $\\{d_i\\}$，结果以 $\\mu\\mathrm{V}^2$ 为单位，四舍五入到小数点后四位。\n\n测试套件：\n使用以下测试用例。在每个用例中，区块在时间上都是等间距的。\n\n- 用例 1（通用正常路径）：\n    - $t = [0,1,2,3,4,5]$ 秒\n    - $E^{\\mathrm{exp}} = [100,100,100,100,100,100]$ $\\mu\\mathrm{V}^2$\n    - $E^{\\mathrm{obs}} = [98,99,101,103,105,108]$ $\\mu\\mathrm{V}^2$\n    - $r = [2,3,3,4,5,5]$\n    - $d_{\\min} = -10$ $\\mu\\mathrm{V}^2$, $d_{\\max} = 10$ $\\mu\\mathrm{V}^2$, $\\Delta = 1$ $\\mu\\mathrm{V}^2$\n    - $\\gamma = 0.5$, $\\beta = 0.05$\n\n- 用例 2（无失配，零 RPV）：\n    - $t = [0,1,2,3,4]$ 秒\n    - $E^{\\mathrm{exp}} = [50,50,50,50,50]$ $\\mu\\mathrm{V}^2$\n    - $E^{\\mathrm{obs}} = [50,50,50,50,50]$ $\\mu\\mathrm{V}^2$\n    - $r = [0,0,0,0,0]$\n    - $d_{\\min} = -5$ $\\mu\\mathrm{V}^2$, $d_{\\max} = 5$ $\\mu\\mathrm{V}^2$, $\\Delta = 1$ $\\mu\\mathrm{V}^2$\n    - $\\gamma = 1.0$, $\\beta = 0.2$\n\n- 用例 3（恒定负失配，高 RPV 权重）：\n    - $t = [0,1,2,3,4,5,6]$ 秒\n    - $E^{\\mathrm{exp}} = [120,120,120,120,120,120,120]$ $\\mu\\mathrm{V}^2$\n    - $E^{\\mathrm{obs}} = [115,115,115,115,115,115,115]$ $\\mu\\mathrm{V}^2$\n    - $r = [10,11,9,12,10,11,10]$\n    - $d_{\\min} = -10$ $\\mu\\mathrm{V}^2$, $d_{\\max} = 0$ $\\mu\\mathrm{V}^2$, $\\Delta = 1$ $\\mu\\mathrm{V}^2$\n    - $\\gamma = 0.3$, $\\beta = 0.1$\n\n- 用例 4（网格边界饱和）：\n    - $t = [0,1,2,3]$ 秒\n    - $E^{\\mathrm{exp}} = [80,80,80,80]$ $\\mu\\mathrm{V}^2$\n    - $E^{\\mathrm{obs}} = [60,60,100,100]$ $\\mu\\mathrm{V}^2$\n    - $r = [1,1,1,1]$\n    - $d_{\\min} = -10$ $\\mu\\mathrm{V}^2$, $d_{\\max} = 10$ $\\mu\\mathrm{V}^2$, $\\Delta = 1$ $\\mu\\mathrm{V}^2$\n    - $\\gamma = 0.7$, $\\beta = 0.05$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素本身是针对一个测试用例的估计漂移值列表（单位为 $\\mu\\mathrm{V}^2$），四舍五入到小数点后四位。例如，两个用例的有效输出应类似于“[[0.0000,0.0000],[1.0000,2.0000,3.0000]]”。请确保打印的行中没有任何空格。",
            "solution": "该问题要求我们为一系列 $N$ 个时间区块估计一个漂移值序列 $\\{d_i\\}_{i=0}^{N-1}$。该估计必须在一个由可能值组成的离散网格 $\\mathcal{D} = \\{d_{\\min}, d_{\\min}+\\Delta, \\dots, d_{\\max}\\}$ 上进行。最优序列被定义为使总成本函数 $J$ 最小化的序列。此成本函数是两部分之和：一个数据保真度项，用于惩罚与能量模型的偏差；以及一个正则化项，用于惩罚漂移序列中缺乏分段线性的特性。\n\n总成本由以下公式给出：\n$$\nJ(d_0,\\dots,d_{N-1}) = \\sum_{i=0}^{N-1} C_i(d_i) \\;+\\; \\left[ P_1(d_0,d_1) + \\sum_{i=2}^{N-1} P(d_{i-2},d_{i-1},d_i) \\right]\n$$\n其中：\n- 数据保真度成本为 $C_i(d_i) = w_i(E^{\\mathrm{obs}}_i - E^{\\mathrm{exp}}_i - d_i)^2$，权重为 $w_i = 1 + \\beta r_i$。\n- 初始斜率惩罚为 $P_1(d_0,d_1) = \\gamma|d_1 - d_0|$。\n- 曲率惩罚为 $P(d_{i-2}, d_{i-1}, d_i) = \\gamma|d_i - 2d_{i-1} + d_{i-2}|$。\n\n成本函数的结构（即步骤 $i$ 的成本取决于在步骤 $i-1$ 和 $i-2$ 做出的决策）使得该问题适合使用动态规划来解决。最优性原理适用：到达步骤 $i$ 的最优路径必须由到达步骤 $i-1$ 的最优路径组成。\n\n我们根据计算未来成本所需的信息来定义动态规划算法的状态。由于惩罚项 $P(d_{i-2}, d_{i-1}, d_i)$ 依赖于最后三个漂移值，步骤 $i$ 的状态必须编码对 $d_{i-1}$ 和 $d_i$ 的选择。\n\n设 $\\mathcal{D}$ 为包含 $M$ 个可能漂移值的网格。我们用 $\\mathcal{D}[k]$ 表示该网格中的第 $k$ 个值。\n设 $dp[i][j][k]$ 表示区块 $0, \\dots, i$ 的最小累积成本，假定区块 $i-1$ 的漂移值为 $d_{i-1} = \\mathcal{D}[j]$，区块 $i$ 的漂移值为 $d_i = \\mathcal{D}[k]$。\n\n通用算法流程如下：\n\n1.  **处理 $N=1$ 的情况**：如果只有一个区块，成本函数简化为 $J(d_0) = C_0(d_0)$。我们找到 $d_0 \\in \\mathcal{D}$ 以最小化此二次函数。无约束最小值出现在 $d_0 = E^{\\mathrm{obs}}_0 - E^{\\mathrm{exp}}_0$。解是 $\\mathcal{D}$ 中最接近此值的网格点。\n\n2.  **处理 $N \\ge 2$ 的情况**：\n    - **预计算**：为提高效率，我们首先计算一个表格 `C_costs[i][k] = C_i(\\mathcal{D}[k])`，涵盖所有区块 $i$ 和所有网格索引 $k$。\n    - **初始化 ($i=1$)**：我们计算前两个区块（$i=0, 1$）的成本。对于每一对可能的漂移值 $(d_0=\\mathcal{D}[j], d_1=\\mathcal{D}[k])$，成本是数据保真度项和初始斜率惩罚项的总和。\n      $$\n      dp[1][j][k] = \\text{C\\_costs}[0][j] + \\text{C\\_costs}[1][k] + \\gamma |\\mathcal{D}[k] - \\mathcal{D}[j]|\n      $$\n    - **递推 ($i=2, \\dots, N-1$)**：我们从区块 $i=2$ 迭代到 $N-1$。对于每个可能的当前和前一个漂移值对 $(d_{i-1}=\\mathcal{D}[j], d_i=\\mathcal{D}[k])$，我们找到最优的前一个漂移值 $d_{i-2}=\\mathcal{D}[l]$，以最小化截至步骤 $i$ 的成本。\n      $$\n      dp[i][j][k] = \\text{C\\_costs}[i][k] + \\min_{l=0}^{M-1} \\left\\{ dp[i-1][l][j] + \\gamma |\\mathcal{D}[k] - 2\\mathcal{D}[j] + \\mathcal{D}[l]| \\right\\}\n      $$\n      为了重构解，我们将实现此最小值的索引 $l$ 存储在一个回溯指针表 $ptr[i][j][k]$ 中。\n\n3.  **终止与路径重构**：\n    - 在填充完截至 $i = N-1$ 的 DP 表后，总体最小成本为 $\\min_{j, k} dp[N-1][j][k]$。设 $(j^*, k^*)$ 是实现此最小值的索引。\n    - 最优序列中的最后两个漂移值是 $d_{N-1} = \\mathcal{D}[k^*]$ 和 $d_{N-2} = \\mathcal{D}[j^*]$。\n    - 我们使用回溯指针表来追溯最优序列的其余部分。从 $i=N-1$ 开始，我们使用 $ptr[i][j^*][k^*]$ 找到 $d_{i-2}$ 的索引，并重复此过程，直到找到所有漂移值，直至 $d_0$。\n\n此方法系统地探索了离散网格上的所有可能路径，并保证找到一个能使总成本 $J$ 全局最小化的序列 $\\{d_i\\}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the drift correction algorithm on all test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (general happy path)\n        {\n            \"t\": [0, 1, 2, 3, 4, 5],\n            \"E_exp\": [100, 100, 100, 100, 100, 100],\n            \"E_obs\": [98, 99, 101, 103, 105, 108],\n            \"r\": [2, 3, 3, 4, 5, 5],\n            \"d_min\": -10, \"d_max\": 10, \"Delta\": 1,\n            \"gamma\": 0.5, \"beta\": 0.05\n        },\n        # Case 2 (no mismatch, zero RPV)\n        {\n            \"t\": [0, 1, 2, 3, 4],\n            \"E_exp\": [50, 50, 50, 50, 50],\n            \"E_obs\": [50, 50, 50, 50, 50],\n            \"r\": [0, 0, 0, 0, 0],\n            \"d_min\": -5, \"d_max\": 5, \"Delta\": 1,\n            \"gamma\": 1.0, \"beta\": 0.2\n        },\n        # Case 3 (constant negative mismatch, high RPV weights)\n        {\n            \"t\": [0, 1, 2, 3, 4, 5, 6],\n            \"E_exp\": [120, 120, 120, 120, 120, 120, 120],\n            \"E_obs\": [115, 115, 115, 115, 115, 115, 115],\n            \"r\": [10, 11, 9, 12, 10, 11, 10],\n            \"d_min\": -10, \"d_max\": 0, \"Delta\": 1,\n            \"gamma\": 0.3, \"beta\": 0.1\n        },\n        # Case 4 (grid boundary saturation)\n        {\n            \"t\": [0, 1, 2, 3],\n            \"E_exp\": [80, 80, 80, 80],\n            \"E_obs\": [60, 60, 100, 100],\n            \"r\": [1, 1, 1, 1],\n            \"d_min\": -10, \"d_max\": 10, \"Delta\": 1,\n            \"gamma\": 0.7, \"beta\": 0.05\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        drift_sequence = estimate_drift_dp(params)\n        formatted_seq = [f\"{val:.4f}\" for val in drift_sequence]\n        all_results.append(f\"[{','.join(formatted_seq)}]\")\n        \n    print(f\"[{','.join(all_results)}]\")\n\ndef estimate_drift_dp(params):\n    \"\"\"\n    Estimates the drift sequence using dynamic programming.\n    \"\"\"\n    t = params[\"t\"]\n    E_exp = np.array(params[\"E_exp\"])\n    E_obs = np.array(params[\"E_obs\"])\n    r = np.array(params[\"r\"])\n    d_min, d_max, Delta = params[\"d_min\"], params[\"d_max\"], params[\"Delta\"]\n    gamma, beta = params[\"gamma\"], params[\"beta\"]\n    \n    N = len(t)\n    # Use np.arange carefully for floating point steps\n    d_grid = np.arange(d_min, d_max + Delta / 2.0, Delta)\n    M = len(d_grid)\n\n    if N == 0:\n        return []\n\n    if N == 1:\n        unconstrained_d0 = E_obs[0] - E_exp[0]\n        # Find closest grid point\n        best_d_idx = np.argmin(np.abs(d_grid - unconstrained_d0))\n        return [d_grid[best_d_idx]]\n\n    # Pre-compute data fidelity costs C_i(d_k)\n    C_costs = np.zeros((N, M))\n    weights = 1 + beta * r\n    mismatches = E_obs - E_exp\n    for i in range(N):\n        for k in range(M):\n            C_costs[i, k] = weights[i] * (mismatches[i] - d_grid[k])**2\n\n    # Initialize DP tables\n    dp_table = np.full((N, M, M), np.inf)\n    ptr_table = np.zeros((N, M, M), dtype=int)\n\n    # Base case (i=1 for blocks 0 and 1)\n    for j in range(M): # index for d_0\n        for k in range(M): # index for d_1\n            p1_cost = gamma * np.abs(d_grid[k] - d_grid[j])\n            dp_table[1, j, k] = C_costs[0, j] + C_costs[1, k] + p1_cost\n            \n    # Recurrence for i = 2 to N-1\n    for i in range(2, N):\n        for j in range(M): # index for d_{i-1}\n            for k in range(M): # index for d_i\n                min_prev_cost = np.inf\n                best_l = -1\n                for l in range(M): # index for d_{i-2}\n                    p_cost = gamma * np.abs(d_grid[k] - 2 * d_grid[j] + d_grid[l])\n                    current_cost = dp_table[i-1, l, j] + p_cost\n                    if current_cost  min_prev_cost:\n                        min_prev_cost = current_cost\n                        best_l = l\n                dp_table[i, j, k] = C_costs[i, k] + min_prev_cost\n                ptr_table[i, j, k] = best_l\n\n    # Find the optimal path by backtracking\n    path_indices = np.zeros(N, dtype=int)\n    \n    # Find the minimum cost at the last step\n    min_final_cost = np.inf\n    best_j, best_k = -1, -1\n    \n    # For N=2, the final table is at i=1. For N>2, it's at i=N-1\n    final_step_idx = N - 1\n    \n    min_val = np.min(dp_table[final_step_idx])\n    min_indices = np.argwhere(dp_table[final_step_idx] == min_val)[0]\n    best_j, best_k = min_indices[0], min_indices[1]\n\n    path_indices[final_step_idx] = best_k\n    path_indices[final_step_idx - 1] = best_j\n\n    # Backtrack from N-1 down to 2\n    for i in range(N - 1, 1, -1):\n        prev_l = ptr_table[i, path_indices[i-1], path_indices[i]]\n        path_indices[i-2] = prev_l\n\n    # Convert indices to drift values\n    optimal_drift = [d_grid[idx] for idx in path_indices]\n    return optimal_drift\n\nsolve()\n```"
        }
    ]
}