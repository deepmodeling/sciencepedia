{
    "hands_on_practices": [
        {
            "introduction": "许多现代脉冲分选算法依赖于模板匹配来将脉冲分配给神经元。本练习将指导您通过最小化一个正则化代价函数，来推导出簇的最佳模板。掌握这一推导过程，有助于您理解这些算法的数学核心，以及正则化在防止模型拟合噪声而非真实脉冲波形方面的关键作用。",
            "id": "4146401",
            "problem": "一个多通道尖峰排序系统处理在 $C$ 个通道上记录的白化细胞外波形，每个片段包含 $T$ 个时间样本。每个片段被向量化为 $\\mathbb{R}^{d}$ 中的一个向量，其中 $d = C T$。对于单个簇，假设我们有 $N$ 个候选尖峰，其波形为 $\\{\\mathbf{x}_{i} \\in \\mathbb{R}^{d}\\}_{i=1}^{N}$，对此簇的软责任为 $\\{r_{i} \\in [0,1]\\}_{i=1}^{N}$，以及从前一个振幅估计步骤中获得的标量振幅 $\\{a_{i} \\in \\mathbb{R}\\}_{i=1}^{N}$。令簇模板为 $\\mathbf{t} \\in \\mathbb{R}^{d}$。定义一个目标函数，该函数惩罚所有已分配尖峰的期望残差能量，并包含用于控制过拟合的正则化：\n$$\nJ(\\mathbf{t}) \\;=\\; \\frac{1}{2} \\sum_{i=1}^{N} r_{i} \\left\\| \\mathbf{x}_{i} - a_{i} \\mathbf{t} \\right\\|_{2}^{2} \\;+\\; \\frac{\\lambda}{2} \\left\\| \\mathbf{t} \\right\\|_{2}^{2} \\;+\\; \\frac{\\gamma}{2} \\left\\| \\mathbf{L} \\mathbf{t} \\right\\|_{2}^{2},\n$$\n其中 $\\lambda > 0$ 控制模板的整体幅度，$\\gamma \\ge 0$ 控制粗糙度，$\\mathbf{L} \\in \\mathbb{R}^{m \\times d}$ 是一个固定的线性算子，它沿时间轴独立地对每个通道应用二阶有限差分（在通道间是块对角矩阵）。假设噪声已被白化，从而残差被各向同性地加权。\n\n任务：\n- 从最小二乘法和线性算子的基本原理出发，推导梯度 $\\nabla_{\\mathbf{t}} J(\\mathbf{t})$。\n- 对于步长 $\\eta > 0$，由此推导出梯度下降更新 $\\mathbf{t}^{(+)} = \\mathbf{t}^{(-)} - \\eta \\nabla_{\\mathbf{t}} J(\\mathbf{t}^{(-)})$。\n- 通过将梯度设为零，推导以 $\\{r_{i}\\}$、$\\{a_{i}\\}$、$\\{\\mathbf{x}_{i}\\}$、$\\lambda$、$\\gamma$ 和 $\\mathbf{L}$ 表示的唯一闭式最小化子 $\\hat{\\mathbf{t}}$。明确指出表达式中出现的单位矩阵 $\\mathbf{I} \\in \\mathbb{R}^{d \\times d}$。\n- 用一两句话简要解释，由 $\\lambda$ 和 $\\gamma$ 控制的正则化项如何在模板更新中防止对噪声的过拟合。\n\n提供 $\\hat{\\mathbf{t}}$ 的单一闭式解析表达式作为最终答案。无需进行数值计算，也无需单位。不要将任何中间结果作为最终答案报告。",
            "solution": "所述问题具有科学依据、内容完整且是良定的。目标函数 $J(\\mathbf{t})$ 是关于模板向量 $\\mathbf{t}$ 的严格凸函数，这保证了唯一最小化子的存在。因此，我们可以开始推导。\n\n需要关于模板 $\\mathbf{t} \\in \\mathbb{R}^{d}$ 最小化的目标函数是：\n$$\nJ(\\mathbf{t}) = \\frac{1}{2} \\sum_{i=1}^{N} r_{i} \\left\\| \\mathbf{x}_{i} - a_{i} \\mathbf{t} \\right\\|_{2}^{2} + \\frac{\\lambda}{2} \\left\\| \\mathbf{t} \\right\\|_{2}^{2} + \\frac{\\gamma}{2} \\left\\| \\mathbf{L} \\mathbf{t} \\right\\|_{2}^{2}\n$$\n为求最小化子，我们必须首先计算 $J(\\mathbf{t})$ 关于 $\\mathbf{t}$ 的梯度, 记作 $\\nabla_{\\mathbf{t}} J(\\mathbf{t})$。为方便求导，我们使用向量转置来表示 $L_2$ 范数的平方：\n$$\nJ(\\mathbf{t}) = \\frac{1}{2} \\sum_{i=1}^{N} r_{i} (\\mathbf{x}_{i} - a_{i} \\mathbf{t})^{\\top}(\\mathbf{x}_{i} - a_{i} \\mathbf{t}) + \\frac{\\lambda}{2} \\mathbf{t}^{\\top}\\mathbf{t} + \\frac{\\gamma}{2} (\\mathbf{L}\\mathbf{t})^{\\top}(\\mathbf{L}\\mathbf{t})\n$$\n我们展开第一项：\n$$\n(\\mathbf{x}_{i} - a_{i} \\mathbf{t})^{\\top}(\\mathbf{x}_{i} - a_{i} \\mathbf{t}) = \\mathbf{x}_{i}^{\\top}\\mathbf{x}_{i} - 2a_{i}\\mathbf{x}_{i}^{\\top}\\mathbf{t} + a_{i}^{2}\\mathbf{t}^{\\top}\\mathbf{t}\n$$\n并重写第三项：\n$$\n(\\mathbf{L}\\mathbf{t})^{\\top}(\\mathbf{L}\\mathbf{t}) = \\mathbf{t}^{\\top}\\mathbf{L}^{\\top}\\mathbf{L}\\mathbf{t}\n$$\n目标函数变为：\n$$\nJ(\\mathbf{t}) = \\frac{1}{2} \\sum_{i=1}^{N} r_{i} (\\mathbf{x}_{i}^{\\top}\\mathbf{x}_{i} - 2a_{i}\\mathbf{x}_{i}^{\\top}\\mathbf{t} + a_{i}^{2}\\mathbf{t}^{\\top}\\mathbf{t}) + \\frac{\\lambda}{2} \\mathbf{t}^{\\top}\\mathbf{t} + \\frac{\\gamma}{2} \\mathbf{t}^{\\top}\\mathbf{L}^{\\top}\\mathbf{L}\\mathbf{t}\n$$\n现在我们使用标准矩阵微积分恒等式 $\\nabla_{\\mathbf{v}} (\\mathbf{b}^{\\top}\\mathbf{v}) = \\mathbf{b}$ 和 $\\nabla_{\\mathbf{v}} (\\mathbf{v}^{\\top}\\mathbf{A}\\mathbf{v}) = (\\mathbf{A} + \\mathbf{A}^{\\top})\\mathbf{v}$，对 $J(\\mathbf{t})$ 关于 $\\mathbf{t}$ 逐项求导。\n\n第一项的梯度是：\n$$\n\\nabla_{\\mathbf{t}} \\left( \\frac{1}{2} \\sum_{i=1}^{N} r_{i} (\\mathbf{x}_{i}^{\\top}\\mathbf{x}_{i} - 2a_{i}\\mathbf{x}_{i}^{\\top}\\mathbf{t} + a_{i}^{2}\\mathbf{t}^{\\top}\\mathbf{t}) \\right) = \\frac{1}{2} \\sum_{i=1}^{N} r_{i} (-2a_{i}\\mathbf{x}_{i} + 2a_{i}^{2}\\mathbf{t}) = \\sum_{i=1}^{N} r_{i} (a_{i}^{2}\\mathbf{t} - a_{i}\\mathbf{x}_{i})\n$$\n$$\n= \\left(\\sum_{i=1}^{N} r_{i} a_{i}^{2}\\right)\\mathbf{t} - \\sum_{i=1}^{N} r_{i} a_{i}\\mathbf{x}_{i}\n$$\n第二项（岭）正则化项的梯度是：\n$$\n\\nabla_{\\mathbf{t}} \\left( \\frac{\\lambda}{2} \\mathbf{t}^{\\top}\\mathbf{t} \\right) = \\frac{\\lambda}{2} (2\\mathbf{t}) = \\lambda \\mathbf{t}\n$$\n第三项（平滑）正则化项的梯度是：\n$$\n\\nabla_{\\mathbf{t}} \\left( \\frac{\\gamma}{2} \\mathbf{t}^{\\top}\\mathbf{L}^{\\top}\\mathbf{L}\\mathbf{t} \\right) = \\frac{\\gamma}{2} (2\\mathbf{L}^{\\top}\\mathbf{L}\\mathbf{t}) = \\gamma \\mathbf{L}^{\\top}\\mathbf{L}\\mathbf{t}\n$$\n注意，$\\mathbf{L}^{\\top}\\mathbf{L}$ 是一个对称矩阵。\n\n综合这些结果，总梯度 $\\nabla_{\\mathbf{t}} J(\\mathbf{t})$ 为：\n$$\n\\nabla_{\\mathbf{t}} J(\\mathbf{t}) = \\left(\\sum_{i=1}^{N} r_{i} a_{i}^{2}\\right)\\mathbf{t} - \\sum_{i=1}^{N} r_{i} a_{i}\\mathbf{x}_{i} + \\lambda \\mathbf{t} + \\gamma \\mathbf{L}^{\\top}\\mathbf{L}\\mathbf{t}\n$$\n将乘以 $\\mathbf{t}$ 的项组合在一起，并为确保维度正确引入单位矩阵 $\\mathbf{I} \\in \\mathbb{R}^{d \\times d}$，便得到梯度的最终表达式：\n$$\n\\nabla_{\\mathbf{t}} J(\\mathbf{t}) = \\left( \\left(\\sum_{i=1}^{N} r_{i} a_{i}^{2} + \\lambda \\right)\\mathbf{I} + \\gamma \\mathbf{L}^{\\top}\\mathbf{L} \\right) \\mathbf{t} - \\sum_{i=1}^{N} r_{i} a_{i}\\mathbf{x}_{i}\n$$\n根据此梯度，对于当前估计为 $\\mathbf{t}^{(-)}$ 且步长为 $\\eta > 0$ 的模板，其梯度下降更新规则为：\n$$\n\\mathbf{t}^{(+)} = \\mathbf{t}^{(-)} - \\eta \\nabla_{\\mathbf{t}} J(\\mathbf{t}^{(-)})\n$$\n$$\n\\mathbf{t}^{(+)} = \\mathbf{t}^{(-)} - \\eta \\left[ \\left( \\left(\\sum_{i=1}^{N} r_{i} a_{i}^{2} + \\lambda \\right)\\mathbf{I} + \\gamma \\mathbf{L}^{\\top}\\mathbf{L} \\right) \\mathbf{t}^{(-)} - \\sum_{i=1}^{N} r_{i} a_{i}\\mathbf{x}_{i} \\right]\n$$\n为求得唯一闭式最小化子 $\\hat{\\mathbf{t}}$，我们将梯度设为零，即 $\\nabla_{\\mathbf{t}} J(\\hat{\\mathbf{t}}) = \\mathbf{0}$：\n$$\n\\left( \\left(\\sum_{i=1}^{N} r_{i} a_{i}^{2} + \\lambda \\right)\\mathbf{I} + \\gamma \\mathbf{L}^{\\top}\\mathbf{L} \\right) \\hat{\\mathbf{t}} - \\sum_{i=1}^{N} r_{i} a_{i}\\mathbf{x}_{i} = \\mathbf{0}\n$$\n这是一个形如 $\\mathbf{A}\\hat{\\mathbf{t}} = \\mathbf{b}$ 的线性方程组，其中：\n$$\n\\mathbf{A} = \\left(\\sum_{i=1}^{N} r_{i} a_{i}^{2} + \\lambda \\right)\\mathbf{I} + \\gamma \\mathbf{L}^{\\top}\\mathbf{L}\n$$\n$$\n\\mathbf{b} = \\sum_{i=1}^{N} r_{i} a_{i}\\mathbf{x}_{i}\n$$\n矩阵 $\\mathbf{A}$ 是目标函数 $J(\\mathbf{t})$ 的 Hessian 矩阵。因为 $\\lambda > 0$，所以项 $(\\sum r_i a_i^2 + \\lambda)\\mathbf{I}$ 是正定的。由于 $\\gamma \\ge 0$ 且 $\\mathbf{L}^{\\top}\\mathbf{L}$ 是半正定的，它们的乘积也是半正定的。一个正定矩阵与一个半正定矩阵之和是正定的，因此 $\\mathbf{A}$ 是可逆的。因此，我们可以通过左乘 $\\mathbf{A}$ 的逆矩阵来解出 $\\hat{\\mathbf{t}}$：\n$$\n\\hat{\\mathbf{t}} = \\mathbf{A}^{-1}\\mathbf{b} = \\left( \\left(\\sum_{i=1}^{N} r_{i} a_{i}^{2} + \\lambda \\right)\\mathbf{I} + \\gamma \\mathbf{L}^{\\top}\\mathbf{L} \\right)^{-1} \\left( \\sum_{i=1}^{N} r_{i} a_{i}\\mathbf{x}_{i} \\right)\n$$\n该表达式代表了最小化正则化残差能量的最优模板。\n\n最后，正则化项可防止过拟合。$\\lambda$ 正则化项惩罚模板的整体幅度（$L_2$ 范数的平方），通过收缩其系数来防止模板拟合噪声。$\\gamma$ 正则化项惩罚由有限差分算子 $\\mathbf{L}$ 衡量的粗糙度，从而促进生成更平滑、更符合物理实际且不易受高频噪声影响的模板波形。",
            "answer": "$$\n\\boxed{\\left( \\left(\\sum_{i=1}^{N} r_{i} a_{i}^{2} + \\lambda \\right)\\mathbf{I} + \\gamma \\mathbf{L}^{\\top}\\mathbf{L} \\right)^{-1} \\left( \\sum_{i=1}^{N} r_{i} a_{i}\\mathbf{x}_{i} \\right)}\n$$"
        },
        {
            "introduction": "当脉冲分选器将脉冲分配到不同的簇后，一个根本性的问题是：其结果的准确性如何？本练习将介绍混淆矩阵，这是在有“基准真相”（ground-truth）数据时评估性能的基石。通过计算精确率（precision）和召回率（recall），您将学会以标准化的方式量化常见的排序错误，例如“合并”（merges）和“分裂”（splits）。",
            "id": "4146355",
            "problem": "一个脉冲分选算法产生了三个分选单元，记为 $U_1$、$U_2$ 和 $U_3$。一项同步胞内记录为三个神经元提供了真值标签，记为 $GT_1$、$GT_2$ 和 $GT_3$。每个检测到的脉冲都已与一个真值神经元匹配，或被视为不匹配（噪声/背景），得到以下计数：\n\n- 对于 $U_1$：$100$ 个脉冲匹配 $GT_1$，$45$ 个脉冲匹配 $GT_2$，$0$ 个脉冲匹配 $GT_3$，还有 $5$ 个脉冲不匹配。\n- 对于 $U_2$：$5$ 个脉冲匹配 $GT_1$，$0$ 个脉冲匹配 $GT_2$，$65$ 个脉冲匹配 $GT_3$，还有 $0$ 个脉冲不匹配。\n- 对于 $U_3$：$0$ 个脉冲匹配 $GT_1$，$55$ 个脉冲匹配 $GT_2$，$5$ 个脉冲匹配 $GT_3$，还有 $30$ 个脉冲不匹配。\n\n每个神经元的真值脉冲总数是：$GT_1$ 有 $120$ 个脉冲，$GT_2$ 有 $100$ 个脉冲，以及 $GT_3$ 有 $80$ 个脉冲。\n\n使用脉冲分选质量的标准评估框架：\n- 构建混淆矩阵 $M$，其行由分选单元 $\\{U_1,U_2,U_3\\}$ 索引，列由真值标签 $\\{GT_1,GT_2,GT_3,\\text{None}\\}$ 索引，其中 $\\text{None}$ 表示不匹配的脉冲。\n- 对于每个分选单元 $U_i$，将其行中计数最大的列确定为它的主要真值标签，并计算相对于该主要标签的单元精确率和单元召回率。解释合并（一个分选单元包含来自多个真值神经元的脉冲）和分裂（一个真值神经元的脉冲分布在多个分选单元中）如何影响这些指标。\n\n选择所有正确的陈述：\n\nA. 混淆矩阵 $M$ 中对应于 $U_1$ 的行为 $(100,\\,45,\\,0,\\,5)$，且 $U_1$ 相对于 $GT_1$ 的单元精确率和召回率分别为 $100/150$ 和 $100/120$。\n\nB. $GT_3$ 被分裂到 $U_2$ 和 $U_3$ 中，这相对于 $GT_3$ 的脉冲总数降低了 $U_2$ 的单元召回率；对于 $U_2$ ，其相对于 $GT_3$ 的单元精确率和召回率分别为 $65/70$ 和 $65/80$。\n\nC. $U_1$ 代表了 $GT_1$ 和 $GT_2$ 的合并，因此其相对于 $GT_1$ 的单元精确率很高；具体来说，它等于 $100/120$。\n\nD. $U_3$ 相对于 $GT_2$ 的单元召回率是 $55/90$。\n\nE. 综合考虑所有分选单元，$GT_1$ 的聚合召回率为 $105/120$。",
            "solution": "问题陈述提供了关于一个脉冲分选算法性能的数据，并要求评估几个关于质量指标的陈述。该问题有科学依据，是良定的，并且内部一致。\n\n首先，我们通过验证设置和定义必要的术语来将问题形式化。\n\n已知条件是：\n分选单元：$U_1$、$U_2$、$U_3$。\n真值神经元：$GT_1$、$GT_2$、$GT_3$。\n\n每个分选单元的匹配和不匹配脉冲的计数如下：\n- 对于 $U_1$：$100$ 个脉冲匹配 $GT_1$，$45$ 个脉冲匹配 $GT_2$，$0$ 个脉冲匹配 $GT_3$，还有 $5$ 个脉冲不匹配。\n- 对于 $U_2$：$5$ 个脉冲匹配 $GT_1$，$0$ 个脉冲匹配 $GT_2$，$65$ 个脉冲匹配 $GT_3$，还有 $0$ 个脉冲不匹配。\n- 对于 $U_3$：$0$ 个脉冲匹配 $GT_1$，$55$ 个脉冲匹配 $GT_2$，$5$ 个脉冲匹配 $GT_3$，还有 $30$ 个脉冲不匹配。\n\n每个神经元的真值脉冲总数是：\n- $N_{GT_1} = 120$\n- $N_{GT_2} = 100$\n- $N_{GT_3} = 80$\n\n任务是构建混淆矩阵 $M$ 并评估关于单元精确率和召回率的陈述。\n\n混淆矩阵 $M$ 的行由分选单元 $\\{U_1, U_2, U_3\\}$ 索引，列由真值标签 $\\{GT_1, GT_2, GT_3, \\text{None}\\}$ 索引。条目 $M_{ij}$ 是单元 $U_i$ 中与真值神经元 $GT_j$ 匹配的脉冲数量。\n\n根据所提供的数据，混淆矩阵 $M$ 为：\n$$ M = \\begin{pmatrix} 100  45  0  5 \\\\ 5  0  65  0 \\\\ 0  55  5  30 \\end{pmatrix} $$\n\n每个分选单元中的脉冲总数是其在 $M$ 中对应行的总和：\n- $U_1$ 中的脉冲总数：$N_{U_1} = 100 + 45 + 0 + 5 = 150$\n- $U_2$ 中的脉冲总数：$N_{U_2} = 5 + 0 + 65 + 0 = 70$\n- $U_3$ 中的脉冲总数：$N_{U_3} = 0 + 55 + 5 + 30 = 90$\n\n对于一个给定的分选单元 $U_i$，我们将其在 $M$ 的第 $i$ 行中（忽略 'None' 列）计数最高的真值标签 $GT_j$ 确定为它的主要真值标签。\n- 对于 $U_1$，主要标签是 $GT_1$ ($100 > 45$)。\n- 对于 $U_2$，主要标签是 $GT_3$ ($65 > 5$)。\n- 对于 $U_3$，主要标签是 $GT_2$ ($55 > 5$)。\n\n我们现在为单元 $U_i$ 定义相对于其主要真值标签 $GT_j$ 的单元精确率和召回率：\n- **精确率 (Precision)**：$U_i$ 中正确来自 $GT_j$ 的脉冲所占的比例。\n  $$ \\text{Precision}(U_i, GT_j) = \\frac{\\text{Number of spikes in } U_i \\text{ from } GT_j}{\\text{Total number of spikes in } U_i} = \\frac{M_{ij}}{N_{U_i}} $$\n- **召回率 (Recall)**：所有来自 $GT_j$ 的脉冲中被正确捕获在 $U_i$ 中的比例。\n  $$ \\text{Recall}(U_i, GT_j) = \\frac{\\text{Number of spikes in } U_i \\text{ from } GT_j}{\\text{Total number of spikes from } GT_j} = \\frac{M_{ij}}{N_{GT_j}} $$\n\n现在我们评估每个选项。\n\n**A. 混淆矩阵 $M$ 中对应于 $U_1$ 的行为 $(100,\\,45,\\,0,\\,5)$，且 $U_1$ 相对于 $GT_1$ 的单元精确率和召回率分别为 $100/150$ 和 $100/120$。**\n根据问题描述，$U_1$ 对应的行确实是 $(100, 45, 0, 5)$。$U_1$ 的主要真值标签是 $GT_1$。\n- $U_1$ 中的脉冲总数是 $N_{U_1} = 150$。\n- 来自 $GT_1$ 的脉冲总数是 $N_{GT_1} = 120$。\n- $U_1$ 中来自 $GT_1$ 的脉冲数是 $M_{11} = 100$。\n- $U_1$ 相对于 $GT_1$ 的精确率是 $\\frac{M_{11}}{N_{U_1}} = \\frac{100}{150}$。\n- $U_1$ 相对于 $GT_1$ 的召回率是 $\\frac{M_{11}}{N_{GT_1}} = \\frac{100}{120}$。\n该陈述的两个部分在计算上和概念上都是正确的。来自 $GT_2$ 的 $45$ 个脉冲和 $5$ 个不匹配脉冲的存在降低了精确率，这展示了一个“合并”错误。未能捕获 $GT_1$ 的全部 $120$ 个脉冲降低了召回率。\n**结论：正确。**\n\n**B. $GT_3$ 被分裂到 $U_2$ 和 $U_3$ 中，这相对于 $GT_3$ 的脉冲总数降低了 $U_2$ 的单元召回率；对于 $U_2$ ，其相对于 $GT_3$ 的单元精确率和召回率分别为 $65/70$ 和 $65/80$。**\n首先，我们检查 $GT_3$ 是否被分裂。\n- $U_2$ 包含 $65$ 个来自 $GT_3$ 的脉冲。\n- $U_3$ 包含 $5$ 个来自 $GT_3$ 的脉冲。\n因为来自单个真值神经元 $GT_3$ 的脉冲在多个分选单元中被发现，所以根据定义，它被“分裂”了。这种分裂，加上任何遗漏的脉冲（为 $GT_3$ 找到的总数是 $65+5=70$，而总共有 $80$ 个），意味着没有单个分选单元能捕获 $GT_3$ 的所有脉冲，因此降低了任何相关单元的单元召回率。这个推理是合理的。\n接下来，我们检查对 $U_2$ 的计算。$U_2$ 的主要标签是 $GT_3$。\n- $U_2$ 中的脉冲总数是 $N_{U_2} = 70$。\n- 来自 $GT_3$ 的脉冲总数是 $N_{GT_3} = 80$。\n- $U_2$ 中来自 $GT_3$ 的脉冲数是 $M_{23} = 65$。\n- $U_2$ 相对于 $GT_3$ 的精确率是 $\\frac{M_{23}}{N_{U_2}} = \\frac{65}{70}$。\n- $U_2$ 相对于 $GT_3$ 的召回率是 $\\frac{M_{23}}{N_{GT_3}} = \\frac{65}{80}$。\n推理和计算值都是正确的。\n**结论：正确。**\n\n**C. $U_1$ 代表了 $GT_1$ 和 $GT_2$ 的合并，因此其相对于 $GT_1$ 的单元精确率很高；具体来说，它等于 $100/120$。**\n$U_1$ 包含 $100$ 个来自 $GT_1$ 的脉冲和 $45$ 个来自 $GT_2$ 的脉冲。这是一个“合并”。合并错误本质上会*降低*精确率，因为精确率公式的分母（单元中的脉冲总数）被假阳性（来自其他神经元的脉冲）增加了。“因此其单元精确率...很高”的推理是有缺陷的。此外，该陈述声称精确率为 $\\frac{100}{120}$。\n- 根据选项 A 的计算，$U_1$ 相对于 $GT_1$ 的精确率是 $\\frac{100}{150}$。\n- 值 $\\frac{100}{120}$ 是召回率，而不是精确率。\n该陈述包含了有缺陷的推理和不正确的精确率值。\n**结论：不正确。**\n\n**D. $U_3$ 相对于 $GT_2$ 的单元召回率是 $55/90$。**\n$U_3$ 的主要真值标签是 $GT_2$。我们计算 $U_3$ 相对于 $GT_2$ 的召回率。\n- 来自 $GT_2$ 的脉冲总数是 $N_{GT_2} = 100$。\n- $U_3$ 中来自 $GT_2$ 的脉冲数是 $M_{32} = 55$。\n- $U_3$ 相对于 $GT_2$ 的召回率是 $\\frac{M_{32}}{N_{GT_2}} = \\frac{55}{100}$。\n该陈述声称召回率是 $\\frac{55}{90}$。让我们分析这个值。$U_3$ 中的脉冲总数是 $N_{U_3} = 90$。因此，$\\frac{55}{90}$ 是 $U_3$ 相对于 $GT_2$ 的*精确率*，而不是召回率。该陈述将精确率误认为是召回率。\n**结论：不正确。**\n\n**E. 综合考虑所有分选单元，$GT_1$ 的聚合召回率为 $105/120$。**\n一个真值神经元 $GT_j$ 的聚合召回率是其在所有分选单元中检测到的脉冲总数，除以该神经元的脉冲总数。\n- 在 $U_1$ 中找到的来自 $GT_1$ 的脉冲：$100$。\n- 在 $U_2$ 中找到的来自 $GT_1$ 的脉冲：$5$。\n- 在 $U_3$ 中找到的来自 $GT_1$ 的脉冲：$0$。\n- 算法检测到的来自 $GT_1$ 的脉冲总数 = $100 + 5 + 0 = 105$。\n- 来自 $GT_1$ 的实际脉冲总数是 $N_{GT_1} = 120$。\n- $GT_1$ 的聚合召回率 = $\\frac{\\text{Total } GT_1 \\text{ spikes detected}}{\\text{Total } GT_1 \\text{ spikes}} = \\frac{105}{120}$。\n该陈述是正确的。\n**结论：正确。**\n\n总而言之，陈述 A、B 和 E 是正确的。",
            "answer": "$$\\boxed{ABE}$$"
        },
        {
            "introduction": "在大多数实验中，基准真相数据是缺失的，因此我们必须依赖内在指标来评估簇的质量。L-比率（L-ratio）是一个强大的指标，它通过衡量有多少“其他”脉冲落入某个簇的统计边界内，来量化该簇的污染程度。本练习将教您如何根据马氏距离（Mahalanobis distances）计算L-比率，从而为簇的纯度提供一个统计学上的估计。",
            "id": "4146418",
            "problem": "给定一组用于尖峰排序质量评估的尖峰波形特征距离和簇统计量。假设单个候选簇的特征向量由均值为 $\\boldsymbol{\\mu}$、协方差矩阵为 $\\boldsymbol{\\Sigma}_{C}$ 的多元正态分布生成。在此模型下，样本与簇之间的马氏距离平方 $d^{2}$ 服从自由度为 $p$ 的卡方分布，其中 $p$ 是特征空间的维度，等于 $\\boldsymbol{\\Sigma}_{C}$ 的大小。\n\n您的任务是为每个测试用例计算一个称为L-比率的数值污染可能性代理指标。对于为未分配给该簇的尖峰计算的一系列马氏距离 $\\{d_{i}\\}$，该污染可能性代理指标要求对每个 $d_{i}$，评估在自由度为 $p$ 的卡方分布下，一个真实的簇成员其马氏距离平方大于或等于 $d_{i}^{2}$ 的概率。将这些概率对所有非簇内尖峰求和，得到一个量，该量通过分配给该簇的尖峰数量 $N_{\\mathrm{cluster}}$ 进行归一化后，提供了一个污染可能性代理指标。您必须使用卡方生存函数（累积分布函数（CDF）的补函数）来实现此计算，以确保数值稳定性。\n\n科学假设：\n- 簇特征服从多元正态分布。\n- 真实簇成员的马氏距离平方服从自由度为 $p$ 的卡方分布，其中 $p$ 等于 $\\boldsymbol{\\Sigma}_{C}$ 的维度。\n- 非簇内马氏距离 $\\{d_{i}\\}$ 是相对于该簇的均值和协方差 $\\boldsymbol{\\Sigma}_{C}$ 计算的。\n\n对于每个测试用例，计算L-比率作为一个实数，并四舍五入到 $6$ 位小数。不涉及物理单位。最终输出必须将所有测试用例的结果聚合到一行，形式为方括号括起来的逗号分隔列表，例如 $[r_{1},r_{2},r_{3}]$，其中每个 $r_{i}$ 是测试用例 $i$ 四舍五入后的L-比率。\n\n测试套件：\n- 测试用例 1：\n  - 簇协方差 $\\boldsymbol{\\Sigma}_{C} = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  0.5 \\end{bmatrix}$。\n  - 非簇内马氏距离 $[2.0, 3.0, 5.0]$。\n  - 分配给该簇的尖峰数量 $N_{\\mathrm{cluster}} = 150$。\n- 测试用例 2：\n  - 簇协方差 $\\boldsymbol{\\Sigma}_{C} = \\begin{bmatrix} 1.0  0.2  0.0 \\\\ 0.2  1.5  0.1 \\\\ 0.0  0.1  0.8 \\end{bmatrix}$。\n  - 非簇内马氏距离 $[0.1, 0.2, 0.05, 0.3]$。\n  - 分配给该簇的尖峰数量 $N_{\\mathrm{cluster}} = 50$。\n- 测试用例 3：\n  - 簇协方差 $\\boldsymbol{\\Sigma}_{C} = \\begin{bmatrix} 2.0  0.0 \\\\ 0.0  2.0 \\end{bmatrix}$。\n  - 非簇内马氏距离 $[10.0, 12.0]$。\n  - 分配给该簇的尖峰数量 $N_{\\mathrm{cluster}} = 200$。\n- 测试用例 4：\n  - 簇协方差 $\\boldsymbol{\\Sigma}_{C} = \\begin{bmatrix} 1.0 \\end{bmatrix}$。\n  - 非簇内马氏距离 $[0.0, 10^{-8}]$。\n  - 分配给该簇的尖峰数量 $N_{\\mathrm{cluster}} = 1$。\n\n您的程序应生成单行输出，其中包含四个测试用例的L-比率结果，格式为方括号括起来的逗号分隔列表，每个值四舍五入到 $6$ 位小数，格式严格为 $[r_{1},r_{2},r_{3},r_{4}]$。",
            "solution": "问题陈述已经过严格验证，被认为是科学可靠、定义明确且客观的。它为计算L-比率提供了完整且一致的定义和数据，L-比率是神经科学数据分析中尖峰排序领域公认的质量度量标准。其基础统计假设是标准的，并且适用于该情境。因此，可以推导出一个唯一、稳定且有意义的解。\n\n主要任务是为几个测试用例计算L-比率。L-比率可作为候选尖峰簇污染程度的代理指标。它基于簇特征分布的统计特性来定义。该问题假设属于给定簇的尖峰的特征向量是从均值为 $\\boldsymbol{\\mu}$、协方差矩阵为 $\\boldsymbol{\\Sigma}_{C}$ 的多元正态分布中抽取的样本。该分布的一个基本性质是，一个真实成员到簇中心的马氏距离平方 $d^2$ 服从自由度为 $p$ 的卡方($\\chi^2$)分布，其中 $p$ 是特征空间的维度。\n\nL-比率的正式定义为：\n$$\nL_{\\text{ratio}} = \\frac{1}{N_{\\text{cluster}}} \\sum_{i} P(\\chi^2_p \\ge d_i^2)\n$$\n在此方程中：\n- $N_{\\text{cluster}}$ 是分配给候选簇的尖峰总数。\n- 求和是针对所有*未*分配给该簇的尖峰。\n- $\\{d_i\\}$ 是这些非簇内尖峰的马氏距离集合，该距离是相对于候选簇的均值和协方差计算的。\n- $p$ 是卡方分布的自由度，等于特征空间的维度，由协方差矩阵 $\\boldsymbol{\\Sigma}_{C}$ 的大小给出。对于一个 $n \\times n$ 的矩阵 $\\boldsymbol{\\Sigma}_{C}$，我们有 $p=n$。\n- $P(\\chi^2_p \\ge d_i^2)$ 是从自由度为 $p$ 的 $\\chi^2$ 分布中随机抽取一个值，该值大于或等于马氏距离平方 $d_i^2$ 的概率。此概率对应于 $\\chi^2$ 分布的生存函数(SF)，它是累积分布函数(CDF)的补函数，即 $S(x; p) = 1 - \\text{CDF}(x; p)$。为了获得更好的数值精度，特别是在参数值很大（此时CDF会接近1）的情况下，规定直接使用生存函数。\n\n每个测试用例的计算过程如下：\n\n1.  **确定自由度 ($p$)**: 从给定的簇协方差矩阵 $\\boldsymbol{\\Sigma}_{C}$ 中提取维度 $p$。如果 $\\boldsymbol{\\Sigma}_{C}$ 是一个 $n \\times n$ 矩阵，则 $p = n$。\n\n2.  **计算概率**: 对于所提供列表中的每个非簇内马氏距离 $d_i$，首先计算其平方 $d_i^2$。然后，用自由度 $p$ 对该值评估卡方生存函数，即 $S(d_i^2; p) = P(\\chi^2_p \\ge d_i^2)$。\n\n3.  **求和与归一化**: 将上一步计算出的所有概率相加：$\\text{Sum} = \\sum_i S(d_i^2; p)$。\n\n4.  **计算L-比率**: 将总和除以簇中的尖峰数量 $N_{\\text{cluster}}$，得到最终的L-比率：$L_{\\text{ratio}} = \\frac{\\text{Sum}}{N_{\\text{cluster}}}$。\n\n5.  **四舍五入**: 按要求将计算出的L-比率四舍五入到 $6$ 位小数。\n\n此过程将应用于所有四个测试用例。\n\n**测试用例 1:**\n- $\\boldsymbol{\\Sigma}_{C}$ 是一个 $2 \\times 2$ 矩阵，所以 $p=2$。\n- 非簇内马氏距离为 $[2.0, 3.0, 5.0]$。平方距离为 $[4.0, 9.0, 25.0]$。\n- $N_{\\text{cluster}} = 150$。\n- $L_{\\text{ratio}} = \\frac{1}{150} \\left( P(\\chi^2_2 \\ge 4.0) + P(\\chi^2_2 \\ge 9.0) + P(\\chi^2_2 \\ge 25.0) \\right)$。\n\n**测试用例 2:**\n- $\\boldsymbol{\\Sigma}_{C}$ 是一个 $3 \\times 3$ 矩阵，所以 $p=3$。\n- 非簇内马氏距离为 $[0.1, 0.2, 0.05, 0.3]$。平方距离为 $[0.01, 0.04, 0.0025, 0.09]$。\n- $N_{\\text{cluster}} = 50$。\n- $L_{\\text{ratio}} = \\frac{1}{50} \\left( P(\\chi^2_3 \\ge 0.01) + P(\\chi^2_3 \\ge 0.04) + P(\\chi^2_3 \\ge 0.0025) + P(\\chi^2_3 \\ge 0.09) \\right)$。\n\n**测试用例 3:**\n- $\\boldsymbol{\\Sigma}_{C}$ 是一个 $2 \\times 2$ 矩阵，所以 $p=2$。\n- 非簇内马氏距离为 $[10.0, 12.0]$。平方距离为 $[100.0, 144.0]$。\n- $N_{\\text{cluster}} = 200$。\n- $L_{\\text{ratio}} = \\frac{1}{200} \\left( P(\\chi^2_2 \\ge 100.0) + P(\\chi^2_2 \\ge 144.0) \\right)$。\n\n**测试用例 4:**\n- $\\boldsymbol{\\Sigma}_{C}$ 是一个 $1 \\times 1$ 矩阵，所以 $p=1$。\n- 非簇内马氏距离为 $[0.0, 10^{-8}]$。平方距离为 $[0.0, 10^{-16}]$。\n- $N_{\\text{cluster}} = 1$。\n- $L_{\\text{ratio}} = \\frac{1}{1} \\left( P(\\chi^2_1 \\ge 0.0) + P(\\chi^2_1 \\ge 10^{-16}) \\right)$。注意，对于任何 $p > 0$，$P(\\chi^2_p \\ge 0.0) = 1$。\n\n实现将使用数值库来准确评估卡方生存函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Computes the L-ratio for a set of test cases based on spike sorting statistics.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"Sigma_C\": np.array([[1.0, 0.0], [0.0, 0.5]]),\n            \"non_cluster_distances\": np.array([2.0, 3.0, 5.0]),\n            \"N_cluster\": 150\n        },\n        # Test case 2\n        {\n            \"Sigma_C\": np.array([[1.0, 0.2, 0.0], [0.2, 1.5, 0.1], [0.0, 0.1, 0.8]]),\n            \"non_cluster_distances\": np.array([0.1, 0.2, 0.05, 0.3]),\n            \"N_cluster\": 50\n        },\n        # Test case 3\n        {\n            \"Sigma_C\": np.array([[2.0, 0.0], [0.0, 2.0]]),\n            \"non_cluster_distances\": np.array([10.0, 12.0]),\n            \"N_cluster\": 200\n        },\n        # Test case 4\n        {\n            \"Sigma_C\": np.array([[1.0]]),\n            \"non_cluster_distances\": np.array([0.0, 1e-8]),\n            \"N_cluster\": 1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        Sigma_C = case[\"Sigma_C\"]\n        non_cluster_distances = case[\"non_cluster_distances\"]\n        N_cluster = case[\"N_cluster\"]\n\n        # The number of degrees of freedom p is the dimensionality of Sigma_C.\n        p = Sigma_C.shape[0]\n\n        # Square the Mahalanobis distances for non-cluster spikes.\n        squared_distances = non_cluster_distances**2\n\n        # For each squared distance, compute the probability P(X >= d^2)\n        # using the Chi-Square survival function (1 - CDF).\n        # This is more numerically stable than 1 - cdf(x) for large x.\n        probabilities = chi2.sf(squared_distances, df=p)\n\n        # Sum these probabilities.\n        sum_of_probs = np.sum(probabilities)\n\n        # Normalize by the number of spikes in the cluster to get the L-ratio.\n        l_ratio = sum_of_probs / N_cluster\n\n        # Round the result to 6 decimal places.\n        rounded_l_ratio = round(l_ratio, 6)\n        results.append(rounded_l_ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}