{
    "hands_on_practices": [
        {
            "introduction": "在神经科学研究中，比较两组受试者（例如，患者组与对照组）的平均反应是一项基本任务。此练习将指导您为两个独立样本的均值差异构建一个基础的自助法置信区间。通过为功能性磁共振成像（fMRI）数据实现这一核心算法，您将掌握所有自助法应用所需的基础编程和统计技能。",
            "id": "4142996",
            "problem": "给定两组独立的功能性磁共振成像 (fMRI) 受试者，每组包含从感兴趣区域中为单一条件提取的受试者水平回归系数（“贝塔系数”）。在标准假设下，即每组内的受试者水平贝塔系数是独立同分布的，且两组相互独立，我们将两组之间平均贝塔系数的差异视为感兴趣的估计量。令 $x_1, x_2, \\dots, x_{n_1}$ 表示第一组的贝塔系数， $y_1, y_2, \\dots, y_{n_2}$ 表示第二组的贝塔系数。均值差异的估计量为\n$$\n\\hat{\\Delta} = \\frac{1}{n_2} \\sum_{j=1}^{n_2} y_j \\;-\\; \\frac{1}{n_1} \\sum_{i=1}^{n_1} x_i.\n$$\n您必须使用 $B=2000$ 次自助法重抽样，对每组内的受试者进行有放回的重抽样，为 $\\hat{\\Delta}$ 计算一个基本的自助法置信区间，并报告在置信水平 $1-\\alpha$（其中 $\\alpha = 0.05$，以小数形式表示）下得到的区间。\n\n基本自助法区间是通过对估计量相对于观测估计值的误差的经验分布进行反转来定义的。对于每次自助法重抽样，通过在每组内重抽样索引并重新计算均值差异来构建一个自助法复制值 $\\hat{\\Delta}^\\ast$。定义自助法误差复制值 $E^\\ast = \\hat{\\Delta}^\\ast - \\hat{\\Delta}$。令 $q_{p}$ 为自助法误差分布 $\\{E^\\ast_b\\}_{b=1}^B$ 的经验 $p$-分位数。$\\hat{\\Delta}$ 的 $100 \\cdot (1-\\alpha)\\%$ 基本自助法区间为\n$$\n\\left[ \\hat{\\Delta} - q_{1-\\alpha/2}, \\; \\hat{\\Delta} - q_{\\alpha/2} \\right].\n$$\n\n请实现此过程并将其应用于以下测试套件。对于每个案例，$n_1 = 20$ 且 $n_2 = 22$（受试者数量），且 $B = 2000$。使用等于 $12345$ 的固定随机数生成器种子，以确保自助法重抽样的可复现性。下面的数据数组列出了每组观测到的受试者水平系数；将这些观测值视为用于自助法抽样的全部可用样本。\n\n测试用例 $1$（近似对称分布，均值有中等差异）：\n- 第 $1$ 组：$x^{(1)} = \\{0.39, 0.61, 0.52, 0.47, 0.58, 0.44, 0.73, 0.36, 0.49, 0.67, 0.42, 0.55, 0.63, 0.40, 0.51, 0.59, 0.46, 0.57, 0.48, 0.60\\}$\n- 第 $2$ 组：$y^{(1)} = \\{0.70, 0.68, 0.75, 0.81, 0.62, 0.77, 0.69, 0.73, 0.66, 0.79, 0.71, 0.74, 0.78, 0.65, 0.72, 0.76, 0.67, 0.80, 0.64, 0.82, 0.63, 0.85\\}$\n\n测试用例 $2$（偏态、重尾正系数）：\n- 第 $1$ 组：$x^{(2)} = \\{0.12, 0.09, 0.15, 0.08, 0.20, 0.07, 0.11, 0.10, 0.13, 0.06, 0.18, 0.05, 0.25, 0.14, 0.09, 0.30, 0.04, 0.21, 0.16, 0.28\\}$\n- 第 $2$ 组：$y^{(2)} = \\{0.18, 0.16, 0.24, 0.20, 0.27, 0.15, 0.19, 0.23, 0.21, 0.26, 0.17, 0.22, 0.30, 0.14, 0.28, 0.25, 0.33, 0.13, 0.29, 0.31, 0.12, 0.35\\}$\n\n测试用例 $3$（通过构造使均值相等）：\n- 第 $1$ 组：$x^{(3)} = \\{0.45, 0.55, 0.50, 0.52, 0.48, 0.51, 0.49, 0.53, 0.47, 0.54, 0.46, 0.56, 0.44, 0.57, 0.43, 0.58, 0.42, 0.59, 0.41, 0.60\\}$\n- 第 $2$ 组：$y^{(3)} = \\{0.45, 0.55, 0.50, 0.52, 0.48, 0.51, 0.49, 0.53, 0.47, 0.54, 0.46, 0.56, 0.44, 0.57, 0.43, 0.58, 0.42, 0.59, 0.41, 0.60, 0.505, 0.505\\}$\n\n测试用例 $4$（低方差、近乎恒定的系数，有小的均值漂移）：\n- 第 $1$ 组：$x^{(4)} = \\{1.00, 1.01, 0.99, 1.02, 0.98, 1.00, 1.01, 0.99, 1.02, 0.98, 1.00, 1.01, 0.99, 1.02, 0.98, 1.00, 1.01, 0.99, 1.02, 0.98\\}$\n- 第 $2$ 组：$y^{(4)} = \\{1.03, 1.04, 1.02, 1.05, 1.01, 1.03, 1.04, 1.02, 1.05, 1.01, 1.03, 1.04, 1.02, 1.05, 1.01, 1.03, 1.04, 1.02, 1.05, 1.01, 1.03, 1.04\\}$\n\n您的程序必须：\n- 使用 $B = 2000$ 次重抽样和 $\\alpha = 0.05$ 实现上述定义的基本自助法置信区间。\n- 对于每个测试用例，计算并返回 $\\hat{\\Delta}$ 的区间下界和上界，其中 $\\hat{\\Delta}$ 定义为第 2 组的均值减去第 1 组的均值。\n- 对所有自助法重抽样步骤使用等于 $12345$ 的固定随机数生成器种子。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是对应测试用例的一个包含两个浮点数元素 $[\\text{下界}, \\text{上界}]$ 的列表，按测试用例 1 到 4 的顺序排列。例如，输出格式必须为 $[[L_1,U_1],[L_2,U_2],[L_3,U_3],[L_4,U_4]]$。",
            "solution": "该问题是有效的。它提出了一个定义明确的计算统计任务，该任务基于构建置信区间的自助法重抽样的标准、科学合理的原则，并应用于神经科学数据分析中的现实场景。所有必要的数据、参数和定义均已提供，且该问题是自洽且客观的。\n\n目标是为两个独立受试者组之间的均值差异计算一个基本的自助法置信区间。令两组的观测数据分别表示为集合 $X = \\{x_1, x_2, \\dots, x_{n_1}\\}$ 和 $Y = \\{y_1, y_2, \\dots, y_{n_2}\\}$，其中 $n_1$ 和 $n_2$ 是各自的样本量。\n\n感兴趣的参数（估计量）是总体均值的真实差异，$\\Delta = \\mu_Y - \\mu_X$。该参数的点估计是观测到的样本均值差异：\n$$\n\\hat{\\Delta} = \\bar{y} - \\bar{x} = \\frac{1}{n_2} \\sum_{j=1}^{n_2} y_j \\;-\\; \\frac{1}{n_1} \\sum_{i=1}^{n_1} x_i\n$$\n我们的任务是为 $\\Delta$ 构建一个 $100 \\cdot (1-\\alpha)\\%$ 的置信区间，其中置信水平由 $\\alpha = 0.05$ 指定。要使用的方法是基本自助法，也称为反向百分位区间。\n\n自助法的基本思想是通过从观测数据中重复重抽样来近似估计量的抽样分布。基本自助法区间是通过假设估计误差 $\\hat{\\Delta} - \\Delta$ 的分布可以由自助法误差的经验分布 $E^\\ast = \\hat{\\Delta}^\\ast - \\hat{\\Delta}$ 来近似推导出来的。\n\n算法流程如下：\n\n1.  **计算观测统计量**：首先，从原始数据样本中计算均值差异 $\\hat{\\Delta}$。这作为我们的点估计。\n\n2.  **生成自助法重抽样样本和复制值**：对 $b = 1, 2, \\dots, B$，重复以下过程 $B$ 次：\n    a.  通过从原始样本 $X$ 中有放回地抽取 $n_1$ 个观测值，为第 1 组生成一个自助法样本，记为 $X^{\\ast b}$。\n    b.  通过从原始样本 $Y$ 中有放回地抽取 $n_2$ 个观测值，为第 2 组生成一个自助法样本，记为 $Y^{\\ast b}$。\n    c.  对于每对自助法样本 $(X^{\\ast b}, Y^{\\ast b})$，计算统计量的自助法复制值：\n        $$\n        \\hat{\\Delta}^{\\ast b} = \\overline{y^{\\ast b}} - \\overline{x^{\\ast b}}\n        $$\n    此过程产生一个包含 $B$ 个自助法复制值的集合，$\\{\\hat{\\Delta}^{\\ast b}\\}_{b=1}^B$。\n\n3.  **计算自助法误差分布**：根据自助法复制值，我们构建自助法误差的经验分布。对于每个复制值，误差定义为与原始估计值的偏差：\n    $$\n    E^{\\ast b} = \\hat{\\Delta}^{\\ast b} - \\hat{\\Delta}\n    $$\n    这得到一个包含 $B$ 个自助法误差值的集合，$\\{E^{\\ast b}\\}_{b=1}^B$。\n\n4.  **确定误差分布的分位数**：令 $q_p$ 表示排序后的自助法误差分布 $\\{E^{\\ast b}\\}$ 的经验 $p$-分位数。我们需要与置信区间尾部相对应的分位数，特别是 $q_{\\alpha/2}$ 和 $q_{1-\\alpha/2}$。对于 $\\alpha=0.05$，这些是 $0.025$ 和 $0.975$ 分位数（即第 $2.5$ 和第 $97.5$ 百分位数）。\n\n5.  **构建置信区间**：$\\Delta$ 的 $100 \\cdot (1-\\alpha)\\%$ 基本自助法置信区间是通过使用误差分位数，以观测统计量 $\\hat{\\Delta}$ 为枢轴构建的：\n    $$\n    \\text{CI}_{1-\\alpha}(\\Delta) = \\left[ \\hat{\\Delta} - q_{1-\\alpha/2}, \\quad \\hat{\\Delta} - q_{\\alpha/2} \\right]\n    $$\n    这种构建方法围绕点估计反转了误差分布。置信区间的下界由误差分布的上分位数校正，上界由误差分布的下分位数校正。\n\n对于此问题，给定 $n_1 = 20$，$n_2 = 22$，自助法重抽样次数 $B = 2000$，以及置信参数 $\\alpha = 0.05$。使用固定的随机数生成器种子 $12345$ 以确保重抽样过程的可复现性。这整个过程将应用于所提供的四个测试用例中的每一个。\n\n实现将利用 `numpy` 库进行高效的数组操作，通过 `numpy.random.choice` 进行重抽样，并通过 `numpy.quantile` 计算分位数。一个使用 $12345$ 作为种子的单一随机数生成器实例将用于所有测试用例的所有重抽样步骤，以确保严格遵守问题的可复现性要求。",
            "answer": "```python\nimport numpy as np\n\ndef compute_basic_bootstrap_ci(x, y, B, alpha, rng):\n    \"\"\"\n    Computes the basic bootstrap confidence interval for the difference in means.\n\n    Args:\n        x (np.ndarray): Data for group 1.\n        y (np.ndarray): Data for group 2.\n        B (int): Number of bootstrap resamples.\n        alpha (float): Significance level for the confidence interval.\n        rng (np.random.Generator): A NumPy random number generator.\n\n    Returns:\n        list: A list containing the lower and upper bounds of the confidence interval.\n    \"\"\"\n    # Get sample sizes\n    n1 = len(x)\n    n2 = len(y)\n\n    # Step 1: Calculate the observed statistic (difference in means)\n    delta_hat = np.mean(y) - np.mean(x)\n\n    # Step 2  3: Generate bootstrap replicates and compute the statistic\n    bootstrap_deltas = np.empty(B)\n    for i in range(B):\n        # Resample with replacement from each group\n        x_star = rng.choice(x, size=n1, replace=True)\n        y_star = rng.choice(y, size=n2, replace=True)\n        \n        # Compute the bootstrap replicate of the statistic\n        bootstrap_deltas[i] = np.mean(y_star) - np.mean(x_star)\n\n    # Step 4: Compute the bootstrap distribution of the error\n    bootstrap_errors = bootstrap_deltas - delta_hat\n\n    # Step 5: Find the quantiles of the error distribution\n    q_alpha_2 = np.quantile(bootstrap_errors, alpha / 2.0)\n    q_1_minus_alpha_2 = np.quantile(bootstrap_errors, 1 - alpha / 2.0)\n\n    # Step 6: Construct the confidence interval\n    lower_bound = delta_hat - q_1_minus_alpha_2\n    upper_bound = delta_hat - q_alpha_2\n\n    return [lower_bound, upper_bound]\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([0.39, 0.61, 0.52, 0.47, 0.58, 0.44, 0.73, 0.36, 0.49, 0.67, 0.42, 0.55, 0.63, 0.40, 0.51, 0.59, 0.46, 0.57, 0.48, 0.60]),\n            np.array([0.70, 0.68, 0.75, 0.81, 0.62, 0.77, 0.69, 0.73, 0.66, 0.79, 0.71, 0.74, 0.78, 0.65, 0.72, 0.76, 0.67, 0.80, 0.64, 0.82, 0.63, 0.85]),\n        ),\n        (\n            np.array([0.12, 0.09, 0.15, 0.08, 0.20, 0.07, 0.11, 0.10, 0.13, 0.06, 0.18, 0.05, 0.25, 0.14, 0.09, 0.30, 0.04, 0.21, 0.16, 0.28]),\n            np.array([0.18, 0.16, 0.24, 0.20, 0.27, 0.15, 0.19, 0.23, 0.21, 0.26, 0.17, 0.22, 0.30, 0.14, 0.28, 0.25, 0.33, 0.13, 0.29, 0.31, 0.12, 0.35]),\n        ),\n        (\n            np.array([0.45, 0.55, 0.50, 0.52, 0.48, 0.51, 0.49, 0.53, 0.47, 0.54, 0.46, 0.56, 0.44, 0.57, 0.43, 0.58, 0.42, 0.59, 0.41, 0.60]),\n            np.array([0.45, 0.55, 0.50, 0.52, 0.48, 0.51, 0.49, 0.53, 0.47, 0.54, 0.46, 0.56, 0.44, 0.57, 0.43, 0.58, 0.42, 0.59, 0.41, 0.60, 0.505, 0.505]),\n        ),\n        (\n            np.array([1.00, 1.01, 0.99, 1.02, 0.98, 1.00, 1.01, 0.99, 1.02, 0.98, 1.00, 1.01, 0.99, 1.02, 0.98, 1.00, 1.01, 0.99, 1.02, 0.98]),\n            np.array([1.03, 1.04, 1.02, 1.05, 1.01, 1.03, 1.04, 1.02, 1.05, 1.01, 1.03, 1.04, 1.02, 1.05, 1.01, 1.03, 1.04, 1.02, 1.05, 1.01, 1.03, 1.04]),\n        ),\n    ]\n\n    # Parameters from the problem\n    B = 2000\n    alpha = 0.05\n    seed = 12345\n\n    # Initialize random number generator once for all resampling steps\n    rng = np.random.default_rng(seed)\n\n    results = []\n    for x_data, y_data in test_cases:\n        ci = compute_basic_bootstrap_ci(x_data, y_data, B, alpha, rng)\n        results.append(ci)\n\n    # Custom formatting to avoid spaces inside the inner lists, though\n    # the template suggests `map(str, results)` which would add spaces.\n    # To be fully compliant with the example `[L_1,U_1]`, this manual format is better.\n    inner_results_str = [f\"[{l},{u}]\" for l, u in results]\n    print(f\"[{','.join(inner_results_str)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "神经科学数据通常具有分层或嵌套结构，例如，试验嵌套于神经元内，神经元又嵌套于受试者内。直接应用基础自助法会因忽略这种结构而导致错误的结论。本练习将基础自助法扩展到一个嵌套重抽样程序，这对于正确地从分层实验的各个层面传播不确定性至关重要，从而让您能够处理更复杂、更真实的数据结构。",
            "id": "4142939",
            "problem": "给定一个分层数据集，其中包含从多个被试的多个神经元记录的试验级实值观测数据。推断目标是跨神经元的群体水平中位数响应，同时要尊重神经元嵌套在被试内、试验嵌套在神经元内的分层结构。设数据集表示为一个三层嵌套列表，其中外层列表索引被试，下一层内层列表索引被试内的神经元，最内层列表包含一个神经元的试验级响应。将被试表示为 $s \\in \\{1,\\dots,S\\}$，被试 $s$ 内的神经元表示为 $i \\in \\{1,\\dots,N_s\\}$，神经元 $(s,i)$ 内的试验表示为 $j \\in \\{1,\\dots,T_{s,i}\\}$。观测到的试验响应为 $x_{s,i,j} \\in \\mathbb{R}$。对于每个神经元 $(s,i)$，将其神经元水平中位数 $m_{s,i}$ 定义为 $\\{x_{s,i,1},\\dots,x_{s,i,T_{s,i}}\\}$ 的中位数。我们感兴趣的群体水平统计量是跨神经元中位数\n$$\nM = \\operatorname{median}\\left(\\{m_{s,i} : s \\in \\{1,\\dots,S\\}, i \\in \\{1,\\dots,N_s\\}\\}\\right).\n$$\n\n从以下基本原则出发：\n- 自助法重采样原则：通过在适当层级上从经验分布中有放回地重采样，同时保持分层结构，来近似统计量的抽样分布。\n- 在抽样设计下，各层级内的可交换性：在被试层级，被试是可交换的；在被试内部，神经元是可交换的；在神经元内部，试验是可交换的。\n- 中位数和分位数的定义：对于一个具有经验分布的实值随机变量，中位数是其 $0.5$ 分位数，而一个水平为 $(1-\\alpha)$ 的双侧置信区间可以通过取自助法复制样本的经验 $(\\alpha/2)$ 和 $(1-\\alpha/2)$ 分位数来构建。\n\n你的任务是设计并实现一个程序，通过以下步骤为 $M$ 构建一个分层自助法百分位数区间：\n- 有放回地重采样被试：从 $\\{1,\\dots,S\\}$ 中有放回地抽取 $S$ 个被试索引。\n- 对于每个重采样出的被试，有放回地重采样神经元：对于该被试，从其 $\\{1,\\dots,N_s\\}$ 个神经元索引中有放回地抽取 $N_s$ 个。\n- 对于每个重采样出的神经元，有放回地重采样试验：对于该神经元，从其 $\\{1,\\dots,T_{s,i}\\}$ 个试验索引中有放回地抽取 $T_{s,i}$ 个。\n- 对于每个自助法采样出的神经元，计算其重采样试验的神经元水平中位数，然后计算重采样样本中所有自助法采样出的神经元的总体中位数 $M^\\ast$。\n- 重复以上步骤，获得 $B$ 个自助法复制样本 $\\{M^\\ast_b\\}_{b=1}^B$。\n- 将 $M$ 的水平为 $(1-\\alpha)$ 的双侧百分位数置信区间构造成 $[q_{\\alpha/2}, q_{1-\\alpha/2}]$，其中 $q_p$ 表示自助法复制样本分布的经验 $p$-分位数。\n\n在实现上述过程时，除了各层级内的可交换性和观测数据外，不得引入任何额外假设，并确保你的程序通过使用伪随机数生成器指定的随机种子来产生可复现的结果。\n\n测试套件与参数：\n对于以下每个测试用例，计算 $M$ 的分层自助法百分位数区间 $[q_{\\alpha/2}, q_{1-\\alpha/2}]$，并将其作为包含两个浮点数的列表返回。测试用例指定了数据集、自助法复制样本数 $B$、置信水平参数 $\\alpha$ 以及用于可复现性的随机种子。\n\n- 测试用例 1（各层级均有变异性的一般情况）：\n  - 数据 $D_1$：\n    - 被试 1：神经元 1 的试验 $[0.8, 0.9, 1.1, 1.0, 0.95]$，神经元 2 的试验 $[1.2, 1.1, 1.3, 1.25, 1.15]$。\n    - 被试 2：神经元 1 的试验 $[0.5, 0.55, 0.6]$，神经元 2 的试验 $[0.7, 0.75, 0.72, 0.74]$，神经元 3 的试验 $[0.65, 0.6, 0.62]$。\n    - 被试 3：神经元 1 的试验 $[1.5, 1.45, 1.55, 1.6]$，神经元 2 的试验 $[1.0, 1.05, 0.95, 1.02]$。\n  - 复制样本数 $B = 5000$。\n  - Alpha $\\alpha = 0.05$。\n  - 种子 $123$。\n\n- 测试用例 2（边界情况：单个被试，单个神经元，单个试验）：\n  - 数据 $D_2$：被试 1：神经元 1 的试验 $[0.37]$。\n  - 复制样本数 $B = 1000$。\n  - Alpha $\\alpha = 0.10$。\n  - 种子 $7$。\n\n- 测试用例 3（边缘情况：各被试的神经元和试验数量不均衡）：\n  - 数据 $D_3$：\n    - 被试 1：神经元 1 的试验 $[0.2, 0.25]$，神经元 2 的试验 $[0.3]$，神经元 3 的试验 $[0.18, 0.22, 0.24]$。\n    - 被试 2：神经元 1 的试验 $[0.5, 0.55, 0.58, 0.52]$，神经元 2 的试验 $[0.4, 0.42]$。\n  - 复制样本数 $B = 4000$。\n  - Alpha $\\alpha = 0.10$。\n  - 种子 $999$。\n\n最终输出格式：\n你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个测试用例的置信区间本身是一个包含两个浮点数的列表。例如，输出结构必须是 $[[\\ell_1,u_1],[\\ell_2,u_2],[\\ell_3,u_3]]$ 的形式，前后无任何附加文本。浮点数可以格式化为固定小数位数；单位是任意实数值，没有关联的物理单位。角度单位不适用。不应使用百分比；任何置信水平的规定都通过上面提供的小数值 $\\alpha$ 进行。",
            "solution": "该问题已经过验证，被确定为一个定义明确、具有科学依据的计算统计学问题。它是自洽的、一致的，并且没有任何歧义或谬误。任务是实现一个分层自助法程序，为源自嵌套数据结构（在神经科学中很常见）的群体水平中位数（$M$）构建一个百分位置信区间。\n\n**原则与算法设计**\n\n该解决方案通过将提供的基本原则直接转化为计算算法来设计。问题的核心在于为分层结构的数据集正确地模拟抽样过程。\n\n**1. 数据表示与目标统计量**\n\n数据集包含实值试验响应 $x_{s,i,j}$，组织在一个三层分层结构中：试验（$j$）嵌套在神经元（$i$）内，神经元又嵌套在被试（$s$）内。\n我们感兴趣的统计量是群体水平中位数 $M$，定义为：\n$$\nM = \\operatorname{median}\\left(\\{m_{s,i} : s \\in \\{1,\\dots,S\\}, i \\in \\{1,\\dots,N_s\\}\\}\\right)\n$$\n其中 $m_{s,i}$ 是神经元 $(s,i)$ 的试验响应的中位数：\n$$\nm_{s,i} = \\operatorname{median}\\left(\\{x_{s,i,1}, \\dots, x_{s,i,T_{s,i}}\\}\\right)\n$$\n这里，$S$ 是被试总数，$N_s$ 是被试 $s$ 的神经元数量，$T_{s,i}$ 是神经元 $(s,i)$ 的试验次数。\n\n**2. 分层自助法原则**\n\n自助法的核心宗旨是通过从观测数据中重复重采样来近似统计量的抽样分布。对于分层数据，为了保证有效性，这种重采样必须尊重其嵌套结构。这一点由**各层级的可交换性**原则来证明：\n-   假设被试是从一个更大的被试群体中进行的可交换抽样。\n-   在给定的被试内部，其神经元被假定为可交换的。\n-   在给定的神经元内部，其试验被假定为可交换的。\n\n该算法通过在分层结构的每个层级上进行有放回的重采样来实现这一点。对于单个自助法复制样本，其过程如下：\n\n-   **步骤 2a：被试重采样。** 通过从原始被试集合 $\\{1, \\dots, S\\}$ 中有放回地抽取 $S$ 次，创建一个新的包含 $S$ 个被试的集合。这意味着一些原始被试可能在自助法样本中出现多次，而另一些则可能根本不出现。\n\n-   **步骤 2b：神经元重采样。** 对于上述步骤中选中的每个被试（例如，原始被试 $s$ 的一个重采样副本），对其神经元进行重采样。如果原始被试 $s$ 有 $N_s$ 个神经元，我们就从该被试的原始神经元池中有放回地抽取 $N_s$ 次。此操作对重采样被试列表中的每个被试独立执行。\n\n-   **步骤 2c：试验重采样。** 对于上述步骤中选中的每个神经元（例如，原始神经元 $(s,i)$ 的一个重采样副本，其有 $T_{s,i}$ 次试验），对其试验进行重采样。我们从该神经元的原始试验集 $\\{x_{s,i,1}, \\dots, x_{s,i,T_{s,i}}\\}$ 中有放回地抽取 $T_{s,i}$ 次。\n\n**3. 生成自助法分布**\n\n多层重采样过程会生成一个“自助法数据集”。从该数据集中，我们计算出我们感兴趣的统计量的单个自助法复制样本 $M^\\ast_b$：\n1.  对于自助法数据集中的每个重采样神经元，我们从其重采样的试验中计算出中位数。这样就得到了一组自助法神经元水平中位数。这些中位数的总数等于原始数据集中的神经元总数 $\\sum_{s=1}^S N_s$。\n2.  计算这组自助法神经元水平中位数的中位数。该值就是一个自助法复制样本 $M^\\ast_b$。\n\n整个过程重复 $B$ 次（例如，在测试用例 1 中 $B=5000$），以生成一个复制样本集合 $\\{M^\\ast_1, M^\\ast_2, \\dots, M^\\ast_B\\}$。该集合可作为 $M$ 的抽样分布的经验近似。\n\n**4. 置信区间的构建**\n\n最后一步是构建 $(1-\\alpha)$ 双侧百分位置信区间。这是通过计算排序后的自助法分布的经验分位数来实现的。\n-   置信区间的下界 $q_{\\alpha/2}$ 是分布 $\\{M^\\ast_b\\}_{b=1}^B$ 的 $(\\alpha/2)$-分位数。\n-   上界 $q_{1-\\alpha/2}$ 是同一分布的 $(1-\\alpha/2)$-分位数。\n\n对于置信参数 $\\alpha = 0.05$ 的测试用例，该区间由自助法复制样本的 $0.025$ 和 $0.975$ 分位数构成。此方法直接应用了问题陈述中提供的原则。使用带种子的伪随机数生成器可确保随机抽样过程是确定性的，并且结果是可复现的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes hierarchical bootstrap percentile confidence intervals for the \n    population-level median of neuron-level medians for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"data\": [\n                # Subject 1\n                [[0.8, 0.9, 1.1, 1.0, 0.95], [1.2, 1.1, 1.3, 1.25, 1.15]],\n                # Subject 2\n                [[0.5, 0.55, 0.6], [0.7, 0.75, 0.72, 0.74], [0.65, 0.6, 0.62]],\n                # Subject 3\n                [[1.5, 1.45, 1.55, 1.6], [1.0, 1.05, 0.95, 1.02]]\n            ],\n            \"B\": 5000,\n            \"alpha\": 0.05,\n            \"seed\": 123\n        },\n        {\n            \"data\": [[[0.37]]],  # Subject 1, Neuron 1, Trial 1\n            \"B\": 1000,\n            \"alpha\": 0.10,\n            \"seed\": 7\n        },\n        {\n            \"data\": [\n                # Subject 1\n                [[0.2, 0.25], [0.3], [0.18, 0.22, 0.24]],\n                # Subject 2\n                [[0.5, 0.55, 0.58, 0.52], [0.4, 0.42]]\n            ],\n            \"B\": 4000,\n            \"alpha\": 0.10,\n            \"seed\": 999\n        }\n    ]\n\n    results = []\n    \n    # Pre-convert trial data from lists to numpy arrays for efficient processing.\n    for case in test_cases:\n        case['data'] = [[np.array(neuron_trials) for neuron_trials in subject_neurons] for subject_neurons in case['data']]\n\n    for case in test_cases:\n        data = case['data']\n        B = case['B']\n        alpha = case['alpha']\n        seed = case['seed']\n        \n        # Initialize a pseudo-random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n        \n        num_subjects = len(data)\n        \n        bootstrap_replicates = np.zeros(B)\n        \n        for b in range(B):\n            # This list will hold the neuron-level medians for one bootstrap sample.\n            bootstrapped_neuron_medians = []\n            \n            # Level 1: Resample subjects with replacement.\n            resampled_subject_indices = rng.choice(num_subjects, size=num_subjects, replace=True)\n            \n            for subject_idx in resampled_subject_indices:\n                original_subject_neurons = data[subject_idx]\n                num_neurons_in_subject = len(original_subject_neurons)\n                \n                if num_neurons_in_subject == 0:\n                    continue\n\n                # Level 2: Resample neurons within the selected subject with replacement.\n                resampled_neuron_indices = rng.choice(num_neurons_in_subject, size=num_neurons_in_subject, replace=True)\n                \n                for neuron_idx in resampled_neuron_indices:\n                    original_neuron_trials = original_subject_neurons[neuron_idx]\n                    num_trials_in_neuron = len(original_neuron_trials)\n                    \n                    if num_trials_in_neuron == 0:\n                        continue\n\n                    # Level 3: Resample trials within the selected neuron with replacement.\n                    resampled_trial_indices = rng.choice(num_trials_in_neuron, size=num_trials_in_neuron, replace=True)\n                    resampled_trials = original_neuron_trials[resampled_trial_indices]\n                    \n                    # Compute the median for the resampled neuron.\n                    neuron_median = np.median(resampled_trials)\n                    bootstrapped_neuron_medians.append(neuron_median)\n\n            # Compute the population-level median for this bootstrap replicate.\n            if bootstrapped_neuron_medians:\n                M_star = np.median(bootstrapped_neuron_medians)\n                bootstrap_replicates[b] = M_star\n            else:\n                # This case occurs if the bootstrap sample contains no trials.\n                bootstrap_replicates[b] = np.nan\n\n        # Remove any NaN replicates before computing quantiles.\n        valid_replicates = bootstrap_replicates[~np.isnan(bootstrap_replicates)]\n\n        # Construct the percentile confidence interval.\n        lower_quantile = alpha / 2.0\n        upper_quantile = 1.0 - (alpha / 2.0)\n        \n        if len(valid_replicates) > 0:\n            ci = np.quantile(valid_replicates, [lower_quantile, upper_quantile])\n        else:\n            # If no valid replicates, CI is undefined.\n            ci = [np.nan, np.nan]\n        \n        # Store the result as a list of floats.\n        results.append(list(ci))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "标准自助法的有效性依赖于一个核心假设：数据是独立同分布的（IID）。然而，在神经生理学记录中，如随时间变化的神经反应，这一假设常常被违背。本练习提出了一个时间序列数据中存在漂移和自相关的常见情景，挑战您批判性地思考朴素自助法在何种情况下会失效。您将学习如何使用诊断工具来识别这些违规行为，并了解处理相关数据的必要替代方法。",
            "id": "4142975",
            "problem": "一个系统神经科学实验室在一个小时的实验中，记录了单个神经元对重复刺激的响应。实验重复了 $T$ 个试次，记录了试次平均发放响应 $y_t$，其中试次索引为 $t \\in \\{1,\\dots,T\\}$。目标是为会话平均响应构建一个 $95\\%$ 的置信区间 (CI)。该会话平均响应被定义为一个假设的平稳过程的期望，该过程代表了神经元在稳定条件下的状态。\n\n实验室计划使用非参数自助法（nonparametric bootstrap），通过对 $T$ 个试次进行有放回的重抽样，并计算每个重抽样样本的均值，来近似均值的抽样分布。然而，观察到了以下经验模式：\n\n- $\\{y_t\\}$ 的样本自相关函数 (ACF, autocorrelation function) 显示，在滞后最高约为 $15$ 时，存在显著的正自相关。\n- 将 $y_t$ 对时间 $t$ 进行线性回归，结果表明存在显著的线性漂移；在 $5\\%$ 的显著性水平下，通过 Ljung–Box 检验，该回归的残差 $\\hat{\\epsilon}_t$ 在滞后 $1$ 和滞后 $2$ 时仍然显示出显著的正自相关。\n- $\\{y_t\\}$ 的边缘直方图近似对称且单峰，没有极端离群值。\n\n假设神经元的响应可以建模为 $y_t = \\mu + f(t) + \\epsilon_t$，其中 $\\mu$ 是一个常数，$f(t)$ 是一个随试次变化的平滑漂移项，而 $\\{\\epsilon_t\\}$ 是一个零均值的弱平稳过程，具有短程依赖性和在小滞后下的正自相关。实验室的目标参数是平稳均值 $\\mu$。自助法必须在对所记录神经元来说合理的数据生成机制下，近似 $\\mu$ 的估计量的抽样分布。\n\n哪个选项最能描述朴素独立同分布 (IID) 自助法在此处可能失败的方式和原因，如何在实践中诊断出这种违规，以及恢复目标 CI 有效性的适当修正方法？\n\nA. 诊断：对 $\\{y_t\\}$ 进行 Shapiro–Wilk 正态性检验。补救措施：在进行自助法之前，对 $\\{y_t\\}$ 中最大和最小的 $5\\%$ 数据进行缩尾处理 (Winsorize)。预期失败：朴素 IID 自助法将产生过宽的置信区间，因为自相关会夸大重抽样的变异性。\n\nB. 诊断：检查 $\\{y_t\\}$ 的 ACF，并在通过对 $t$ 进行回归去除漂移后，检查残差 $\\{\\hat{\\epsilon}_t\\}$ 的 ACF 和联合检验 (portmanteau tests)。补救措施：去除漂移以确定目标 $\\mu$，然后对 $\\{\\hat{\\epsilon}_t\\}$ 应用移动块自助法 (moving block bootstrap)，块长度凭经验选择，并将序列重构为 $\\hat{\\mu} + \\hat{f}(t) + \\text{自助法残差}$。预期失败：朴素 IID 自助法将是反保守的 (anti-conservative)，由于未建模的正自相关而产生过窄的置信区间，并且可能以时间平均量为中心，而不是平稳均值。\n\nC. 诊断：检查 $\\{y_t\\}$ 的直方图对称性以确认近似高斯性。补救措施：对 $\\{y_t\\}$ 使用学生化自助法 (Studentized bootstrap) 来纠正偏度。预期失败：朴素 IID 自助法的主要失败在于产生不对称的置信区间；覆盖率大致保持正确。\n\nD. 诊断：计算跨实验条件的相邻试次之间的滞后为 $0$ 的互相关以检查独立性。补救措施：按 $y_t$ 的十分位数对自助重抽样进行分层，以保留边缘分布。预期失败：朴素 IID 自助法的中心将保持正确，但会高估方差，并因随时间变化的非同分布而产生过宽的置信区间。",
            "solution": "问题陈述要求对使用朴素独立同分布 (IID) 自助法为神经元响应时间序列 $\\{y_t\\}$ 的平稳均值参数 $\\mu$ 构建置信区间的方法进行批判性评估，并确定适当的诊断和补救程序。\n\n提供的神经元响应模型是 $y_t = \\mu + f(t) + \\epsilon_t$，其中 $\\mu$ 是我们感兴趣的恒定平稳均值，$f(t)$ 是一个平滑的时间漂移，而 $\\{\\epsilon_t\\}$ 是一个零均值的弱平稳过程，在短滞后下具有正自相关。\n\n首先，让我们分析朴素 IID 自助法在这些条件下的有效性。IID 自助法依赖于一个核心假设，即数据点是独立且同分布的。问题陈述提供了明确的证据，表明这两个假设都未被满足。\n\n1.  **违反“同分布”假设**：漂移项 $f(t)$ 的存在意味着响应的期望值随试次编号 $t$ 而变化：\n    $$E[y_t] = \\mu + f(t)$$\n    由于 $f(t)$ 不是常数（如“显著的线性漂移”所示），不同 $t$ 的随机变量 $y_t$ 不具有相同的均值。因此，它们不是同分布的。\n\n2.  **违反“独立性”假设**：问题陈述指出，噪声过程 $\\{\\epsilon_t\\}$ 具有“短程依赖性和在小滞后下的正自相关”。这一点通过 $\\{y_t\\}$ 的显著样本自相关函数 (ACF) 以及至关重要的、在去除线性漂移后的残差 $\\{\\hat{\\epsilon}_t\\}$ 的ACF 得到了经验证实。这直接违反了独立性假设。\n\n接下来，我们评估这些违反对朴素 IID 自助法的影响。朴素自助法程序包括从原始数据 $\\{y_t\\}_{t=1}^T$ 中有放回地抽取 $T$ 个样本 $\\{y_t^*\\}$，并计算它们的均值 $\\bar{y}^* = \\frac{1}{T}\\sum y_t^*$。这个过程重复多次，以形成自助均值的分布。\n\n*   **漂移项 $f(t)$ 的影响**：原始数据的样本均值为 $\\bar{y} = \\frac{1}{T}\\sum_{t=1}^T y_t = \\mu + \\frac{1}{T}\\sum_{t=1}^T f(t) + \\frac{1}{T}\\sum_{t=1}^T \\epsilon_t = \\mu + \\bar{f} + \\bar{\\epsilon}$。朴素自助法分布将围绕这个样本均值 $\\bar{y}$。然而，推断的目标是 $\\mu$。由于项 $\\bar{f}$（即会话期间的平均漂移），样本均值 $\\bar{y}$ 是 $\\mu$ 的一个有偏估计量。因此，最终的置信区间将围绕一个与真实目标参数 $\\mu$ 有系统性偏差的值。\n\n*   **正自相关的影响**：对于一个方差为 $\\sigma_\\epsilon^2$、自相关为 $\\rho(k)$ 的平稳时间序列 $\\{\\epsilon_t\\}$，样本均值 $\\bar{\\epsilon}$ 的方差由下式给出：\n    $$\\text{Var}(\\bar{\\epsilon}) = \\frac{\\sigma_\\epsilon^2}{T} \\left[ 1 + 2 \\sum_{k=1}^{T-1} \\left(1-\\frac{k}{T}\\right) \\rho(k) \\right]$$\n    问题陈述指出 $\\{\\epsilon_t\\}$ 在小滞后下具有正自相关（对于小的 $k$，$\\rho(k)  0$）。这意味着方括号中的项大于 $1$，因此 $\\text{Var}(\\bar{\\epsilon})  \\frac{\\sigma_\\epsilon^2}{T}$。\n    朴素 IID 自助法通过打乱数据的时间顺序来破坏自相关结构。自助均值分布的方差将是在 IID 假设下对真实方差的估计，即 $\\frac{\\text{Var}(y_t)}{T}$（或者更准确地说，如果应用于残差，则是对 $\\frac{\\text{Var}(\\epsilon_t)}{T}$ 的估计）。这会系统性地低估样本均值的真实方差。被低估的方差会导致置信区间过窄。这种区间被称为“反保守的”，因为它们的真实覆盖概率低于名义水平（例如，低于 $95\\%$）。\n\n因此，一个有效的程序必须包含两个步骤：\n1.  **诊断和校正非平稳性**：必须识别并移除数据的非平稳性（漂移）。正确的做法是检查数据的趋势（例如，绘制 $y_t$ vs. $t$ 的图），然后对趋势进行建模并减去它。问题中提到对 $y_t$ 和 $t$ 进行线性回归，得到残差 $\\hat{\\epsilon}_t$。该回归的截距提供了对 $\\mu$ 的估计（如果我们假设线性模型 $f(t)=\\beta_1 t$ 中 $f(0)=0$）。\n2.  **诊断和校正依赖性**：必须检查残差 $\\{\\hat{\\epsilon}_t\\}$ 中是否仍存在自相关。问题陈述中提到，这是通过使用 ACF 和 Ljung-Box 检验完成的，该检验正确地发现了显著的依赖性。为了生成一个能解释这种依赖性的自助置信区间，需要一种能够保留时间结构的方法。移动块自助法 (MBB) 是实现这一目的的标准技术。它涉及重抽样连续残差块，从而保留块内的短程相关结构。块长度必须仔细选择，使其大于过程的相关长度。\n\n现在我们来评估给出的选项。\n\n**A. 诊断：对 $\\{y_t\\}$ 进行 Shapiro–Wilk 正态性检验。补救措施：在进行自助法之前，对 $\\{y_t\\}$ 中最大和最小的 $5\\%$ 数据进行缩尾处理。预期失败：朴素 IID 自助法将产生过宽的置信区间，因为自相关会夸大重抽样的变异性。**\n*   **诊断**：主要的违规是非平稳性和依赖性，而不是非正态性。问题陈述说分布是对称和单峰的。这个诊断是错误的。\n*   **补救措施**：缩尾处理是处理离群值的方法。问题陈述说没有极端离群值。这个补救措施没有解决漂移或自相关问题。\n*   **预期失败**：这个陈述是错误的。朴素自助法*忽略*了正自相关的影响，导致对真实方差的*低估*，从而产生过**窄**（反保守）的置信区间，而不是过宽。\n*   **结论**：**不正确**。\n\n**B. 诊断：检查 $\\{y_t\\}$ 的 ACF，并在通过对 $t$ 进行回归去除漂移后，检查残差 $\\{\\hat{\\epsilon}_t\\}$ 的 ACF 和联合检验。补救措施：去除漂移以确定目标 $\\mu$，然后对 $\\{\\hat{\\epsilon}_t\\}$ 应用移动块自助法，块长度凭经验选择，并将序列重构为 $\\hat{\\mu} + \\hat{f}(t) + \\text{自助法残差}$。预期失败：朴素 IID 自助法将是反保守的 (anti-conservative)，由于未建模的正自相关而产生过窄的置信区间，并且可能以时间平均量为中心，而不是平稳均值。**\n*   **诊断**：这是正确的诊断程序。ACF 识别了依赖性，并且在去趋势后检查残差，正确地分离出了噪声过程 $\\{\\epsilon_t\\}$ 的依赖结构。\n*   **补救措施**：这是适当的补救措施。它正确地解决了两个问题：首先去除漂移以正确定位目标 $\\mu$，然后对残差使用移动块自助法以考虑其序列相关性。关于重构序列的描述是回归自助法的一种有效方法。\n*   **预期失败**：这正确定位了我们上面推导出的两个主要失败模式：由于忽略了正自相关，置信区间是反保守的（过窄），并且由于未建模的漂移，其中心是错误的。\n*   **结论**：**正确**。\n\n**C. 诊断：检查 $\\{y_t\\}$ 的直方图对称性以确认近似高斯性。补救措施：对 $\\{y_t\\}$ 使用学生化自助法来纠正偏度。预期失败：朴素 IID 自助法的主要失败在于产生不对称的置信区间；覆盖率大致保持正确。**\n*   **诊断**：与 A 类似，这关注的是边缘分布的形状，而这不是这里的关键问题。关键问题是漂移和依赖性。\n*   **补救措施**：学生化自助法可以提高置信区间的二阶准确性，但它本身并不能纠正序列相关性或非平稳性。将其应用于原始的、非平稳的、相关的序列 $\\{y_t\\}$ 无法解决根本问题。\n*   **预期失败**：对失败的描述有缺陷。主要的失败是覆盖率不佳（反保守），而不仅仅是不对称。在存在显著正自相关的情况下，“覆盖率大致保持正确”的说法是错误的。\n*   **结论**：**不正确**。\n\n**D. 诊断：计算跨实验条件的相邻试次之间的滞后为 $0$ 的互相关以检查独立性。补救措施：按 $y_t$ 的十分位数对自助重抽样进行分层，以保留边缘分布。预期失败：朴素 IID 自助法的中心将保持正确，但会高估方差，并因随时间变化的非同分布而产生过宽的置信区间。**\n*   **诊断**：措辞令人困惑。很可能指的是滞后为 1 的自相关。标准工具是在一系列滞后上使用 ACF。\n*   **补救措施**：分层重抽样在这里是不合适的。它用于来自离散亚群的数据，而不是具有连续时间趋势的数据。按 $y_t$ 的值进行分层并不能解决数据的时间结构问题。\n*   **预期失败**：这个描述在多个方面都是错误的。由于漂移，置信区间的中心将*不*正确。在存在正自相关的情况下，IID 自助法将*低估*而不是高估方差，导致置信区间过窄，而不是过宽。\n*   **结论**：**不正确**。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}