{
    "hands_on_practices": [
        {
            "introduction": "为了严格控制在多重检验中哪怕只犯一个I类错误的概率，研究人员需要确保对族系误差率（Family-Wise Error Rate, FWER）的强控制。封闭测试原则（Closed Testing Principle）提供了一个通用且强大的框架来实现这一目标。这个练习将引导你通过构建一个包含所有交集假设的“闭包”，并对每个假设应用局部检验，来深入理解强控制的内在逻辑，并体会为什么拒绝一个特定的初步假设不仅仅取决于其自身的$p$值 。",
            "id": "4179727",
            "problem": "在一项皮层微电路实验中，一位研究人员对来自单个感兴趣区域的多次试验局部场电位数据拟合了一个通用线性模型（GLM），以检验对应于不同任务操控的三个预先指定的正交对比：对比 $\\mathrm{C}_1$（早期感觉增益）、对比 $\\mathrm{C}_2$（晚期决策偏差）和对比 $\\mathrm{C}_3$（自上而下预期）。该研究人员希望使用闭合检验原则，在每个交集零假设上应用Simes局部检验，从而在水平 $\\alpha=0.05$ 上对这 $3$ 个对比的族系误差率（FWER）进行强控制。假设这三个对比的边际 $p$ 值在其零假设下是连续的、超均匀分布的，并且满足子集上的正回归依赖性（PRDS），因此Simes局部检验对该族中的所有交集均有效。观察到的边际 $p$ 值按 $(\\mathrm{C}_1,\\mathrm{C}_2,\\mathrm{C}_3)$ 的顺序为 $p=(0.001,\\,0.06,\\,0.04)$。\n\n从族系误差率、交集零假设和闭合检验原则的基本定义出发，为这 $3$ 个对比构建完整的闭包（所有交集假设），并应用水平为 $\\alpha$ 的Simes局部检验来确定基本假设 $\\{\\mathrm{C}_1,\\mathrm{C}_2,\\mathrm{C}_3\\}$ 中的哪一个被闭合检验拒绝。将您对 $(\\mathrm{C}_1,\\mathrm{C}_2,\\mathrm{C}_3)$ 的最终决策以一个 $1 \\times 3$ 指示行向量的形式报告，其中条目 $1$ 表示“拒绝”，$0$ 表示“保留”。不需要四舍五入，也不适用物理单位。",
            "solution": "该问题要求将闭合检验原则应用于一个包含三个假设的族，以在指定的水平 $\\alpha$ 上控制族系误差率（FWER）。解决方案包括三个主要步骤：(1) 定义所有交集假设的集合（闭包），(2) 对每个交集假设应用局部检验（Simes检验），以及 (3) 应用闭合检验规则来确定哪些基本假设可以被拒绝。\n\n首先，我们定义基本概念。族系误差率（FWER）是在一系列假设检验中犯下一次或多次 I 型错误（错误地拒绝一个为真的零假设）的概率。在水平 $\\alpha$ 上对FWER进行强控制意味着，无论零假设的哪个子集为真，这个概率都不大于 $\\alpha$。\n\n设对应于对比 $\\mathrm{C}_1$、$\\mathrm{C}_2$ 和 $\\mathrm{C}_3$ 的三个基本零假设分别为 $H_1$、$H_2$ 和 $H_3$。给定的边际 $p$ 值为 $p_1 = 0.001$、$p_2 = 0.06$ 和 $p_3 = 0.04$。期望的FWER控制水平是 $\\alpha = 0.05$。\n\n步骤1：构建假设族的完整闭包。\n闭合检验原则要求我们考虑所有可能的交集零假设。对于一个包含 $k=3$ 个基本假设 $\\{H_1, H_2, H_3\\}$ 的族，其闭包是所有交集假设 $H_I = \\bigcap_{i \\in I} H_i$ 的集合，其中 $I$ 是 $\\{1, 2, 3\\}$ 的所有非空子集。需要检验的完整交集假设集是：\n- 规模 3: $H_{\\{1,2,3\\}} = H_1 \\cap H_2 \\cap H_3$\n- 规模 2: $H_{\\{1,2\\}} = H_1 \\cap H_2$, $H_{\\{1,3\\}} = H_1 \\cap H_3$, $H_{\\{2,3\\}} = H_2 \\cap H_3$\n- 规模 1: $H_{\\{1\\}} = H_1$, $H_{\\{2\\}} = H_2$, $H_{\\{3\\}} = H_3$\n\n步骤2：应用Simes局部检验。\n对每个交集假设 $H_I$，我们应用水平为 $\\alpha = 0.05$ 的Simes检验。设对应于 $I$ 中假设的 $p$ 值集合为 $\\{p_i\\}_{i \\in I}$，并设 $p_{(1:I)} \\le p_{(2:I)} \\le \\dots \\le p_{(|I|:I)}$ 为这些 $p$ 值按非递减顺序排序的结果。如果存在至少一个 $j \\in \\{1, \\dots, |I|\\}$ 使得 $p_{(j:I)} \\le \\frac{j \\alpha}{|I|}$，则Simes检验拒绝 $H_I$。问题陈述PRDS条件成立，这验证了Simes检验的有效性。\n\n对 $H_{\\{1,2,3\\}}$ 的检验：\n- $p$ 值集合为 $\\{0.001, 0.06, 0.04\\}$。\n- 排序后的 $p$ 值为 $p_{(1)} = 0.001$, $p_{(2)} = 0.04$, $p_{(3)} = 0.06$。\n- 交集的大小为 $|I|=3$。\n- Simes 条件：\n  - 对于 $j=1$：$p_{(1)} \\le \\frac{1 \\cdot 0.05}{3}$ 是否成立？$0.001 \\le 0.016\\overline{6}$。是。\n- 因为 $j=1$ 的条件满足，我们 **拒绝** $H_{\\{1,2,3\\}}$。\n\n对 $H_{\\{1,2\\}}$ 的检验：\n- $p$ 值集合为 $\\{0.001, 0.06\\}$。\n- 排序后的 $p$ 值为 $p_{(1)} = 0.001$, $p_{(2)} = 0.06$。\n- 交集的大小为 $|I|=2$。\n- Simes 条件：\n  - 对于 $j=1$：$p_{(1)} \\le \\frac{1 \\cdot 0.05}{2}$ 是否成立？$0.001 \\le 0.025$。是。\n- 我们 **拒绝** $H_{\\{1,2\\}}$。\n\n对 $H_{\\{1,3\\}}$ 的检验：\n- $p$ 值集合为 $\\{0.001, 0.04\\}$。\n- 排序后的 $p$ 值为 $p_{(1)} = 0.001$, $p_{(2)} = 0.04$。\n- 交集的大小为 $|I|=2$。\n- Simes 条件：\n  - 对于 $j=1$：$p_{(1)} \\le \\frac{1 \\cdot 0.05}{2}$ 是否成立？$0.001 \\le 0.025$。是。\n- 我们 **拒绝** $H_{\\{1,3\\}}$。\n\n对 $H_{\\{2,3\\}}$ 的检验：\n- $p$ 值集合为 $\\{0.06, 0.04\\}$。\n- 排序后的 $p$ 值为 $p_{(1)} = 0.04$, $p_{(2)} = 0.06$。\n- 交集的大小为 $|I|=2$。\n- Simes 条件：\n  - 对于 $j=1$：$p_{(1)} \\le \\frac{1 \\cdot 0.05}{2}$ 是否成立？$0.04 \\le 0.025$。否。\n  - 对于 $j=2$：$p_{(2)} \\le \\frac{2 \\cdot 0.05}{2}$ 是否成立？$0.06 \\le 0.05$。否。\n- 因为所有条件都不满足，我们 **不拒绝（保留）** $H_{\\{2,3\\}}$。\n\n对 $H_{\\{1\\}}$, $H_{\\{2\\}}$, $H_{\\{3\\}}$ （规模为1的交集）的检验：\n对于单个假设，Simes检验简化为将 $p$ 值与 $\\alpha$ 进行简单比较。\n- 对于 $H_{\\{1\\}}$：$p_1 \\le \\alpha$ 是否成立？$0.001 \\le 0.05$。是。我们 **拒绝** $H_{\\{1\\}}$。\n- 对于 $H_{\\{2\\}}$：$p_2 \\le \\alpha$ 是否成立？$0.06 \\le 0.05$。否。我们 **保留** $H_{\\{2\\}}$。\n- 对于 $H_{\\{3\\}}$：$p_3 \\le \\alpha$ 是否成立？$0.04 \\le 0.05$。是。我们 **拒绝** $H_{\\{3\\}}$。\n\n局部检验结果摘要：\n- $H_{\\{1,2,3\\}}$: 拒绝\n- $H_{\\{1,2\\}}$: 拒绝\n- $H_{\\{1,3\\}}$: 拒绝\n- $H_{\\{2,3\\}}$: 保留\n- $H_{\\{1\\}}$: 拒绝\n- $H_{\\{2\\}}$: 保留\n- $H_{\\{3\\}}$: 拒绝\n\n步骤3：应用闭合检验规则。\n一个基本假设 $H_k$ 被拒绝，当且仅当 **所有** 包含 $H_k$ 的交集假设 $H_I$（即 $k \\in I$）都被它们各自的局部检验所拒绝。\n\n对 $H_1$ （对比 $\\mathrm{C}_1$）的决策：\n- 包含 $H_1$ 的交集集合是 $\\{H_{\\{1\\}}, H_{\\{1,2\\}}, H_{\\{1,3\\}}, H_{\\{1,2,3\\}}\\}$。\n- 对这些假设的局部检验结果为：拒绝、拒绝、拒绝、拒绝。\n- 因为所有相关的交集都被拒绝，我们 **拒绝** $H_1$。\n\n对 $H_2$ （对比 $\\mathrm{C}_2$）的决策：\n- 包含 $H_2$ 的交集集合是 $\\{H_{\\{2\\}}, H_{\\{1,2\\}}, H_{\\{2,3\\}}, H_{\\{1,2,3\\}}\\}$。\n- 对这些假设的局部检验结果为：保留、拒绝、保留、拒绝。\n- 因为并非所有相关的交集都被拒绝（具体来说，$H_{\\{2\\}}$ 和 $H_{\\{2,3\\}}$ 被保留），我们必须 **保留** $H_2$。\n\n对 $H_3$ （对比 $\\mathrm{C}_3$）的决策：\n- 包含 $H_3$ 的交集集合是 $\\{H_{\\{3\\}}, H_{\\{1,3\\}}, H_{\\{2,3\\}}, H_{\\{1,2,3\\}}\\}$。\n- 对这些假设的局部检验结果为：拒绝、拒绝、保留、拒绝。\n- 因为并非所有相关的交集都被拒绝（具体来说，$H_{\\{2,3\\}}$ 被保留），我们必须 **保留** $H_3$。\n\n对基本假设 $(H_1, H_2, H_3)$ 的最终决策是（拒绝、保留、保留）。这些决策被编码为一个指示向量 $(1, 0, 0)$。值得注意的是，尽管 $H_3$ 的边际p值 $p_3 = 0.04  \\alpha$，但它并未被闭合检验程序拒绝，因为交集假设 $H_{\\{2,3\\}}$ 未能被拒绝。这展示了该程序如何通过对拒绝集合施加逻辑一致性来防止族系误差。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  0  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在处理大规模神经科学数据时，控制错误发现率（False Discovery Rate, FDR）通常是在统计功效和错误控制之间的一个更优平衡。Benjamini-Hochberg（BH）程序不仅提供了一种决策规则，还允许我们为每个检验计算一个$q$值，它代表了在该$p$值水平上拒绝所有假设时预期的错误发现比例。这项练习将通过一个简化的$p$值模型，帮助你揭示$q$值的计算过程，并促使你批判性地思考该程序在面对真实数据（如具有相关性的频谱功率）时其有效性的关键假设 。",
            "id": "4179721",
            "problem": "您正在分析两种神经状态在 $m=100$ 个离散傅里叶频率点上的谱功率差异，使用每个状态的试验平均功率估计值，并在每个频率点上进行双样本 $t$ 检验。假设在标准条件下 $p$ 值是有效的：在给定频率的原假设下，$p$ 值是连续的，并且随机地大于或等于 $[0,1]$ 上的一个均匀分布随机变量；在备择假设下，$p$ 值倾向于较小。在计算了所有频率的 $p$ 值并将其从小到大排序为 $p_{(1)} \\leq p_{(2)} \\leq \\dots \\leq p_{(m)}$ 后，您根据经验发现顺序统计量中存在一个近似线性的关系，该关系与 $p_{(k)} = \\lambda k$ 对所有 $k \\in \\{1,2,\\dots,100\\}$ 均成立，其中 $\\lambda = 5 \\times 10^{-3}$。\n\n使用 Benjamini–Hochberg (BH) 假发现率程序，当 $p_{(k)} = \\lambda k$ 时，从第一性原理出发，推导 BH 校正的 $q$ 值 $q_{(k)}$ 关于 $m$ 和 $\\lambda$ 的表达式，然后计算 BH 校正的 $q$ 值 $q_{(40)}$ 的数值。\n\n另外，讨论谱功率中频率间的依赖性（例如，由于周期图或 Welch 方法中的加窗和谱泄漏）如何影响 BH 假发现率控制的有效性。您的讨论应指出在哪种依赖条件下 BH 方法被证明是有效的，以及违反这些条件如何促使人们采用其他替代方法。\n\n将 $q_{(40)}$ 的最终数值答案表示为一个无单位的纯数字。无需四舍五入，报告精确值。",
            "solution": "问题要求分三部分作答：首先，在指定的有序 $p$ 值线性模型下，推导 Benjamini-Hochberg (BH) 校正 $q$ 值的表达式；其次，计算其中一个 $q$ 值的具体数值；第三，讨论统计依赖性对 BH 程序有效性的理论影响。\n\n**第一部分：BH 校正 $q$ 值表达式的推导**\n\nBenjamini-Hochberg (BH) 程序可以控制假发现率 (False Discovery Rate, FDR)。实现该程序的一种方法是计算校正后的 $p$ 值，通常称为 $q$ 值。对于一组 $m$ 个原始 $p$ 值 $p_1, p_2, \\dots, p_m$，将其排序得到 $p_{(1)} \\leq p_{(2)} \\leq \\dots \\leq p_{(m)}$，第 $k$ 个有序 $p$ 值 $p_{(k)}$ 的 BH 校正 $q$ 值的定义是为了确保原始校正值的单调性。定义如下：\n$$\nq_{(k)} = \\min_{j=k, \\dots, m} \\left( \\frac{m}{j} p_{(j)} \\right)\n$$\n这也可以通过一个保证 $q_{(1)} \\leq q_{(2)} \\leq \\dots \\leq q_{(m)}$ 的递归过程来表示：\n设 $q'_{(k)} = \\frac{m}{k} p_{(k)}$。则校正后的 $q$ 值为 $q_{(m)} = p_{(m)}$ 和 $q_{(k)} = \\min(q_{(k+1)}, p_{(k)} \\frac{m}{k})$，对于 $k = m-1, \\dots, 1$。这两种表述是等价的。我们将使用第一种更直接的定义进行推导。\n\n问题指出，有序的 $p$ 值根据经验遵循以下线性关系：\n$$\np_{(k)} = \\lambda k\n$$\n对所有 $k \\in \\{1, 2, \\dots, m\\}$ 均成立，其中 $m=100$ 是检验次数（频率点数），$\\lambda = 5 \\times 10^{-3}$ 是一个常数。首先，我们必须确保这些是有效的 $p$ 值，即它们位于区间 $[0,1]$ 内。最大的 $p$ 值是 $p_{(m)} = \\lambda m = (5 \\times 10^{-3}) \\times 100 = 0.5$，它小于或等于 $1$，所以该模型是良定义的。\n\n我们将给定的 $p_{(j)}$ 表达式代入 $q_{(k)}$ 的定义中：\n$$\nq_{(k)} = \\min_{j=k, \\dots, m} \\left( \\frac{m}{j} (\\lambda j) \\right)\n$$\n分子和分母中的索引变量 $j$ 被消去：\n$$\nq_{(k)} = \\min_{j=k, \\dots, m} \\left( m \\lambda \\right)\n$$\n最小化运算符内的表达式 $m \\lambda$ 是一个关于索引 $j$ 的常数。因此，这个常数值在从 $k$ 到 $m$ 的任何索引 $j$ 范围内的最小值就是这个常数值本身。\n\n这就得到了 BH 校正 $q$ 值的推导表达式：\n$$\nq_{(k)} = m \\lambda\n$$\n这个表达式对所有 $k \\in \\{1, 2, \\dots, m\\}$ 都成立。它表明，对于这种特定的 $p$ 值线性模型，所有假设的 BH 校正 $q$ 值都是恒定的。\n\n**第二部分：$q_{(40)}$ 的数值计算**\n\n使用推导出的表达式 $q_{(k)} = m \\lambda$，我们可以计算 $q_{(40)}$ 的数值。给定值为：\n- 检验次数（频率点数），$m=100$。\n- 比例常数，$\\lambda = 5 \\times 10^{-3}$。\n\n将这些值代入我们的表达式中：\n$$\nq_{(40)} = m \\lambda = 100 \\times (5 \\times 10^{-3}) = 100 \\times 0.005 = 0.5\n$$\n因此，第 $40$ 个有序 $p$ 值的 BH 校正 $q$ 值的数值是 $0.5$。\n\n**第三部分：关于依赖性与 BH 程序的讨论**\n\nBenjamini-Hochberg (BH) 程序被证明在对 $m$ 个检验的两个主要条件下，能将假发现率 (FDR) 控制在水平 $\\alpha$（即 $\\text{FDR} \\leq \\alpha$）：\n$1$. 这 $m$ 个检验是统计独立的。\n$2$. 这 $m$ 个检验表现出一种特定的正相关形式，称为在真实原假设子集上的正回归依赖性 (Positive Regression Dependency on the Subset of true null hypotheses, PRDS)。\n\nPRDS 条件是一项技术性要求，但在许多常见情况下都会满足，例如当检验统计量服从具有非负相关矩阵的多元正态分布时。\n\n在分析神经数据的谱功率时，不同频率点之间相互独立的假设通常是不成立的。相邻频率的功率估计值通常由于方法学和生理学两方面的原因而呈正相关：\n- **方法学相关性（谱泄漏）：** 使用快速傅里叶变换等方法（例如在周期图或 Welch 方法中）分析有限时长的时序数据时，需要对数据进行加窗。这个过程等同于将真实频谱与窗函数的傅里叶变换进行卷积。这种卷积会导致特定频率的功率“泄漏”到相邻的频率点中，从而在相邻频率的功率估计值之间引起正相关。\n- **生理学相关性：** 神经振荡并非单一频率的完美正弦波，而通常具有一定的带宽。因此，一个单一的振荡过程可以为一系列相邻的频率点贡献功率，从而产生一个生理学来源的正相关。\n\n鉴于谱功率分析中的依赖性主要是正向的，PRDS 条件通常被假定是满足的。因此，标准的 BH 程序被认为是该领域内控制 FDR 的一种有效且稳健的方法，并在神经科学中得到广泛应用。\n\n然而，如果检验之间的依赖结构是任意的或包含显著的负相关，BH 程序就不能保证控制 FDR。在这种情况下，实际的 FDR 可能会超过名义水平 $\\alpha$。为了解决这个问题，已经开发了其他替代程序：\n- **Benjamini-Yekutieli (BY) 程序：** 这是 BH 程序的一个更保守的修正版，它被证明可以在任意依赖结构下控制 FDR。它通过对显著性阈值应用一个更严格的校正因子来实现这一点，通常是 $c(m) = \\sum_{i=1}^{m} \\frac{1}{i}$。这种保证控制的代价是，与标准 BH 程序相比，其统计功效有所降低。\n- **基于置换的方法：** 非参数方法，如置换检验，为在存在复杂和未知依赖结构的情况下控制错误率（无论是族系错误率还是 FDR）提供了一个强有力的替代方案。通过多次置换条件标签并重新计算检验统计量，这些方法生成一个经验零分布，该分布保留了数据中固有的复杂相关模式。基于聚类的置换检验在电生理学中尤其常见，用于处理强烈的时空或频谱相关性。",
            "answer": "$$\\boxed{0.5}$$"
        },
        {
            "introduction": "统计学理论为我们提供了在特定条件下（例如，独立性或正相关性）误差率能够被控制的保证，但在实践中，数据科学家必须能够验证这些方法在具体情境下的表现。蒙特卡洛模拟是连接理论与实践的桥梁，它能帮助我们建立直觉并检验方法的稳健性。这个编程练习将让你亲手验证Simes检验（一个与BH程序密切相关的方法）在神经科学数据中常见的相关性结构下，是如何有效控制I类错误率的，从而将抽象的理论转化为可观察的经验证据 。",
            "id": "4179770",
            "problem": "考虑一个全局零假设多重检验情景，其中 $m$ 个同步检验统计量联合呈高斯分布，均值为 $0$，其相关矩阵的对角线元素为 $1$，所有非对角线元素对均为恒定相关系数 $\\rho$。在全局零假设下，每个单独的检验统计量边缘分布为标准正态分布，因此产生一个有效的双边 $p$ 值。在此设定中，Simes 全局零假设检验的动因是 I 型错误的基本定义（拒绝一个真实的全局零假设）以及在零假设下每个 $p$ 值在随机意义上不小于来自区间 $(0,1)$ 上均匀分布的一个样本这一事实。目标是通过模拟来经验性地验证，在存在具有非负成对相关性的等相关高斯检验统计量的情况下，Simes 决策规则是否能将 I 型错误率维持在接近名义显著性水平的水平。\n\n基本原理：\n- 在全局零假设下，每个检验统计量边缘分布为 $N(0,1)$，其双边 $p$ 值是有效的，意味着在连续极限下它在 $(0,1)$ 上均匀分布。\n- Simes 全局零假设检验的定义是：对观察到的 $p$ 值进行排序，并将它们的有序组合与显著性水平进行比较。具体来说，如果 $p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$ 是排序后的 $p$ 值，当 $\\min_{1 \\le i \\le m} \\left\\{ \\frac{m\\,p_{(i)}}{i} \\right\\} \\le \\alpha$ 时，Simes 决策规则拒绝全局零假设，其中 $\\alpha$ 是所选的显著性水平。\n- 经验 I 型错误率是指在全局零假设实际上为真时，决策规则拒绝该假设的模拟实验所占的比例。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n1. 对于下面测试套件中的每一组参数，生成 $n$ 个独立的 $m$ 维高斯检验统计量的实现，其均值向量为 $0$，协方差矩阵 $\\Sigma$ 为等相关矩阵，即 $\\Sigma_{ii} = 1$ 且当 $i \\ne j$ 时 $\\Sigma_{ij} = \\rho$。所有模拟都在全局零假设下进行。\n2. 使用边缘标准正态分布将每个检验统计量转换为双边 $p$ 值。\n3. 实现上述的 Simes 全局零假设决策规则。\n4. 通过拒绝的模拟实现所占的比例，以小数形式估计经验 I 型错误率。\n5. 生成单行最终输出，其中包含所有测试用例的结果，格式为方括号内以逗号分隔的列表。每个值必须四舍五入到四位小数，并以小数形式表示，而不是百分比。\n\n角度单位不适用。无物理单位适用。所有最终结果均以小数表示。\n\n测试套件（每个用例是一个元组 $(m,\\rho,\\alpha,n,\\text{seed})$）：\n- 用例 A (理想路径)：$(5,\\,0.4,\\,0.05,\\,200000,\\,12345)$。\n- 用例 B (独立性基线)：$(5,\\,0.0,\\,0.05,\\,100000,\\,271828)$。\n- 用例 C (强正相关)：$(5,\\,0.9,\\,0.05,\\,100000,\\,1618033)$。\n- 用例 D (小检验族规模)：$(2,\\,0.4,\\,0.05,\\,100000,\\,101)$。\n- 用例 E (更高名义水平)：$(5,\\,0.4,\\,0.10,\\,100000,\\,2025)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\"[0.0512,0.0498,0.0501,0.0499,0.0987]\"$）。每个条目对应于相应测试用例的经验 I 型错误率，四舍五入到四位小数。",
            "solution": "该问题要求在检验统计量之间存在特定依赖结构的情况下，对 Simes 全局零假设检验的 I 型错误率进行经验估计。该方法涉及蒙特卡洛模拟，这是计算统计学中一种标准而强大的技术，用于在解析解难以获得时研究统计程序的性质。该解决方案是通过执行一系列基于统计理论的步骤来构建的。\n\n首先，我们对相关的检验统计量进行建模。问题假设了一个包含 $m$ 个同步假设检验的情景。在全局零假设下（即所有单个零假设都为真），相应的检验统计量 $Z = (Z_1, Z_2, \\dots, Z_m)$ 从一个多元正态分布中抽取，该分布的均值向量为零向量 $\\mathbf{0}$，并具有一个特定的协方差矩阵 $\\Sigma$。这表示为 $Z \\sim \\mathcal{N}_m(\\mathbf{0}, \\Sigma)$。协方差矩阵被指定为具有等相关结构：所有对角线元素为 $1$，即 $\\Sigma_{ii} = 1$，所有非对角线元素为常数 $\\rho$，即当 $i \\neq j$ 时 $\\Sigma_{ij} = \\rho$。这种结构意味着每个检验统计量边缘分布为标准正态分布，$Z_k \\sim \\mathcal{N}(0,1)$，并且任意一对检验统计量 $(Z_i, Z_j)$ 的相关系数为 $\\rho$。为使 $\\Sigma$ 成为一个有效（半正定）的协方差矩阵，$\\rho$ 必须满足条件 $-\\frac{1}{m-1} \\le \\rho \\le 1$。测试套件中给出的 $\\rho$ 值均满足此条件。为实现此步骤，我们首先为给定的 $m$ 和 $\\rho$ 构建 $m \\times m$ 矩阵 $\\Sigma$。然后，我们从这个 $\\mathcal{N}_m(\\mathbf{0}, \\Sigma)$ 分布中生成 $n$ 个独立的随机向量，从而得到一个 $n \\times m$ 的模拟检验统计量数组。\n\n第二，我们将生成的检验统计量转换为 $p$ 值。由于在零假设下，每个检验统计量 $Z_k$ 边缘上服从标准正态分布 $\\mathcal{N}(0,1)$，因此我们可以为每个观察到的统计量 $z_k$ 计算一个双边 $p$ 值。$p$ 值的定义是：假设零假设为真，观察到至少与已观察到的检验统计量一样极端的检验统计量的概率。对于双边检验，这个概率是 $p_k = P(|Z_k| \\ge |z_k|)$。鉴于标准正态分布的对称性，这可以计算为 $p_k = 2 \\times P(Z_k \\le -|z_k|) = 2 \\times \\Phi(-|z_k|)$，其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)。这种转换被逐元素地应用于整个 $n \\times m$ 的模拟检验统计量数组，从而生成一个 $n \\times m$ 的 $p$ 值数组。\n\n第三，我们应用 Simes 全局零假设决策规则。Simes 检验提供了一种方法，用于合并 $m$ 个单独的 $p$ 值，以对全局零假设做出单一决策。该过程首先将每次模拟的 $p$ 值按非递减顺序排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。如果排序后的 $p$ 值中至少有一个相对于其秩“足够小”，Simes 检验便会拒绝全局零假设。形式上，在显著性水平 $\\alpha$ 下，如果 Simes 统计量小于或等于 $\\alpha$，则满足拒绝条件：\n$$\n\\min_{1 \\le i \\le m} \\left\\{ \\frac{m\\,p_{(i)}}{i} \\right\\} \\le \\alpha\n$$\n这在逻辑上等同于检查是否存在任何索引 $i \\in \\{1, \\dots, m\\}$ 使得 $p_{(i)} \\le \\frac{i\\alpha}{m}$。对于 $n$ 次模拟中的每一次（即 $p$ 值矩阵的每一行），我们对 $p$ 值进行排序，计算项序列 $\\frac{m p_{(i)}}{i}$，找到该序列中的最小值，并检查它是否小于或等于指定的 $\\alpha$。这个过程确定了 $n$ 次试验中哪些导致了对全局零假设的拒绝。\n\n最后，我们估计经验 I 型错误率。在此背景下，I 型错误意味着在全局零假设实际上为真时拒绝它。由于我们的整个模拟都是在全局零假设下构建的，因此 Simes 规则的任何拒绝都是 I 型错误。在这种多重检验的背景下，经验 I 型错误率（通常表示为族错误率，FWER）被估计为导致拒绝的模拟所占的比例。其计算公式为：\n$$\n\\widehat{\\text{FWER}} = \\frac{\\text{拒绝次数}}{n}\n$$\n其中 $n$ 是模拟实验的总次数。这个蒙特卡洛估计为 Simes 检验的性能提供了经验验证。对测试套件中提供的每一组参数重复整个过程，并为每个用例重新设定随机数生成器的种子，以确保可复现性。然后将每个用例的最终结果四舍五入到四位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Empirically estimates the type I error rate of the Simes global null test\n    for equicorrelated Gaussian test statistics through Monte Carlo simulation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, rho, alpha, n, seed)\n        (5, 0.4, 0.05, 200000, 12345),\n        (5, 0.0, 0.05, 100000, 271828),\n        (5, 0.9, 0.05, 100000, 1618033),\n        (2, 0.4, 0.05, 100000, 101),\n        (5, 0.4, 0.10, 100000, 2025),\n    ]\n\n    results = []\n    for m, rho, alpha, n, seed in test_cases:\n        # Step 1: Initialize random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # Step 2: Generate m-dimensional Gaussian test statistics.\n        # Define the mean vector (all zeros under the null).\n        mean_vector = np.zeros(m)\n        \n        # Construct the equicorrelation covariance matrix.\n        cov_matrix = np.full((m, m), rho)\n        np.fill_diagonal(cov_matrix, 1)\n\n        # Generate n realizations from the multivariate normal distribution.\n        # test_stats is an (n, m) array.\n        test_stats = rng.multivariate_normal(mean_vector, cov_matrix, size=n)\n\n        # Step 3: Transform test statistics to two-sided p-values.\n        # p = 2 * P(Z > |z|) = 2 * (1 - CDF(|z|))\n        p_values = 2 * (1 - norm.cdf(np.abs(test_stats)))\n\n        # Step 4: Implement the Simes global null decision rule.\n        # Sort p-values for each simulation (along rows).\n        sorted_p = np.sort(p_values, axis=1)\n\n        # Create an array of indices [1, 2, ..., m].\n        i_array = np.arange(1, m + 1)\n\n        # Calculate the Simes terms {m*p_(i) / i} for each simulation.\n        # Broadcasting rules apply i_array to each row of sorted_p.\n        simes_terms = (m * sorted_p) / i_array\n        \n        # Find the Simes statistic for each simulation (minimum term).\n        simes_statistics = np.min(simes_terms, axis=1)\n\n        # Count the number of rejections (where statistic = alpha).\n        num_rejections = np.sum(simes_statistics = alpha)\n\n        # Step 5: Estimate the empirical type I error rate.\n        error_rate = num_rejections / n\n        \n        # Store the result, formatted to four decimal places.\n        results.append(f\"{error_rate:.4f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}