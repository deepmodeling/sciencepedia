{
    "hands_on_practices": [
        {
            "introduction": "在深入探讨卷积定理的强大功能之前，我们必须首先掌握卷积运算本身的基本机制。第一个练习是一个基础的、按部就班的离散卷积计算。通过这个练习，你将直观地理解一个信号如何“滑过”并修改另一个信号，这是理解滤波等信号处理操作的基石。",
            "id": "26438",
            "problem": "在数字信号处理和数学中，离散卷积是一种基本运算，它将两个序列组合起来生成第三个序列。对于两个有限离散时间序列 $x[n]$ 和 $h[n]$，它们的卷积，记为 $y[n] = (x * h)[n]$，由以下求和定义：\n\n$$y[n] = \\sum_{k=-\\infty}^{\\infty} x[k]h[n-k]$$\n\n这里，$n$ 和 $k$ 是整数索引。对于有限序列，我们假设其在指定范围之外的值为零。\n\n考虑以下两个有限序列：\n1. $x[n]$，仅在 $n=0, 1, 2$ 时非零，其值为 $x[0]=1$，$x[1]=2$ 和 $x[2]=1$。\n2. $h[n]$，仅在 $n=0, 1, 2$ 时非零，其值为 $h[0]=1$，$h[1]=0$ 和 $h[2]=-1$。\n\n这些序列可以用集合表示法表示为 $x[n] = \\{1, 2, 1\\}$ 和 $h[n] = \\{1, 0, -1\\}$，其中第一个元素对应索引 $n=0$。\n\n推导结果序列 $y[n] = (x * h)[n]$。",
            "solution": "有限序列 $x[n]$ 和 $h[n]$ 的离散卷积定义为\n$$y[n]=\\sum_{k=-\\infty}^{\\infty}x[k]\\,h[n-k].$$  \n由于 $x[k]$ 和 $h[k]$ 在 $0\\le k\\le2$ 之外为零，求和范围缩减为 $k=0\\ldots2$。此外，除非 $0\\le n-k\\le2$，否则 $h[n-k]=0$，因此只有当 $0\\le n\\le4$ 时 $y[n]\\neq0$。\n\n当 $n=0$ 时：\n$$y[0]=\\sum_{k=0}^{2}x[k]\\,h[0-k]=x[0]\\,h[0]=1\\cdot1=1.$$\n\n当 $n=1$ 时：\n$$y[1]=\\sum_{k=0}^{2}x[k]\\,h[1-k]\n=x[0]\\,h[1]+x[1]\\,h[0]\n=1\\cdot0+2\\cdot1=2.$$\n\n当 $n=2$ 时：\n$$y[2]=x[0]\\,h[2]+x[1]\\,h[1]+x[2]\\,h[0]\n=1\\cdot(-1)+2\\cdot0+1\\cdot1=0.$$\n\n当 $n=3$ 时：\n$$y[3]=x[1]\\,h[2]+x[2]\\,h[1]\n=2\\cdot(-1)+1\\cdot0=-2.$$\n\n当 $n=4$ 时：\n$$y[4]=x[2]\\,h[2]=1\\cdot(-1)=-1.$$\n\n因此，结果序列为\n$$y[n]=\\{1,2,0,-2,-1\\}\\quad,\\;0\\le n\\le4.$$",
            "answer": "$$\\boxed{\\{1,2,0,-2,-1\\}}$$"
        },
        {
            "introduction": "理解了卷积的计算方法后，让我们来看一下卷积定理的威力。这个练习将挑战你进行逆向思考：给定一个卷积的结果，你能否找出原始信号？这个被称为“反卷积”的过程是一个经典的反问题，通过将问题转换到频域，可以优雅地求解。",
            "id": "540100",
            "problem": "已知函数 $f(t)$ 的自卷积为 $e^{-|t|}$，利用卷积定理和傅里叶变换求 $f(t)$。卷积定理指出，若 $(f * f)(t) = g(t)$，则其傅里叶变换满足 $\\mathcal{F}\\{g\\}(\\omega) = [\\mathcal{F}\\{f\\}(\\omega)]^2$。函数 $h(t)$ 的傅里叶变换 $\\mathcal{F}\\{h\\}(\\omega)$ 定义为 $\\int_{-\\infty}^{\\infty} h(t) e^{-i\\omega t}  dt$。请用闭合形式表示最终答案，其中可能包含特殊函数，如修正贝塞尔函数 $K_0$。",
            "solution": "1. 卷积与傅里叶变换关系\n   - 若 $g(t)=(f*f)(t)$，则根据卷积定理\n     \n$$\n       \\mathcal F\\{g\\}(\\omega)=\\bigl[\\mathcal F\\{f\\}(\\omega)\\bigr]^2\\,.\n     $$\n  \n   - 定义\n     \n$$\n       G(\\omega)=\\mathcal F\\{g\\}(\\omega)=\\int_{-\\infty}^{\\infty}g(t)e^{-i\\omega t}\\,dt,\n       \\quad\n       f(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}F(\\omega)e^{i\\omega t}\\,d\\omega.\n     $$\n\n\n2. $g(t)=e^{-|t|}$ 的傅里叶变换\n   \n$$\n     G(\\omega)=\\int_{-\\infty}^{\\infty}e^{-|t|}e^{-i\\omega t}\\,dt\n     =\\frac{2}{1+\\omega^2}\\,.\n   $$\n\n\n3. 求解 $F(\\omega)$\n   \n$$\n     F(\\omega)^2=G(\\omega)=\\frac{2}{1+\\omega^2}\n     \\quad\\Longrightarrow\\quad\n     F(\\omega)=\\sqrt{\\frac{2}{1+\\omega^2}},\n   $$\n  \n   对于实偶函数 $f(t)$，选择正分支。\n\n4. 傅里叶逆变换求 $f(t)$\n   \n$$\n     f(t)\n     =\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}\\sqrt{\\frac{2}{1+\\omega^2}}\\,e^{i\\omega t}\\,d\\omega\n     =\\frac{\\sqrt{2}}{2\\pi}\\int_{-\\infty}^{\\infty}\\frac{e^{i\\omega t}}{\\sqrt{1+\\omega^2}}\\,d\\omega.\n   $$\n\n\n5. 利用偶函数性质和修正贝塞尔函数的积分表示\n   \n$$\n     f(t)\n     =\\frac{\\sqrt{2}}{\\pi}\\int_{0}^{\\infty}\\frac{\\cos(\\omega t)}{\\sqrt{1+\\omega^2}}\\,d\\omega\n     =\\frac{\\sqrt{2}}{\\pi}K_{0}(|t|)\\,,\n   $$\n  \n   因为 $\\displaystyle\\int_{0}^{\\infty}\\frac{\\cos(\\omega t)}{\\sqrt{\\omega^2+1}}\\,d\\omega=K_{0}(|t|).$",
            "answer": "$$\\boxed{\\frac{\\sqrt{2}}{\\pi}K_{0}(|t|)}$$"
        },
        {
            "introduction": "解析解虽然富有洞察力，但真实世界的数据分析是在计算机上完成的。这最后一个练习将通过使用快速傅里叶变换（FFT）实现卷积，从而将理论与应用联系起来。你将探索关键的实践细节，例如通过补零来正确计算线性卷积，并了解这些技术如何应用于模拟的神经科学数据。",
            "id": "4198907",
            "problem": "考虑离散采样的神经时间序列及其在神经科学数据分析背景下使用离散傅里叶变换 (DFT) 和快速傅里叶变换 (FFT) 的处理。设离散时间信号表示为 $x[n]$，其中 $n$ 为整数索引，以采样频率 $f_s$（单位为 $\\mathrm{Hz}$）在持续时间 $T$（单位为 $\\mathrm{s}$）内采样。设核（脉冲响应）表示为长度为 $M$ 的 $h[n]$。线性卷积定义为 $y[n] = \\sum_{m=0}^{M-1} h[m] x[n-m]$，适用于那些使该和有明确定义的索引 $n$，当索引超出 $x[n]$ 的支撑集时，$y[n] = 0$。一个长度为 $N$ 的序列 $x[n]$ 的 $N$ 点离散傅里叶变换 (DFT) 是 $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2 \\pi k n / N}$，其中 $k = 0,1,\\dots,N-1$，其逆 DFT 是 $x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] e^{i 2 \\pi k n / N}$。\n\n你的任务是从上述基本定义出发：\n\n1. 仅使用线性卷积、由 $N$ 点 DFT 导出的循环卷积以及 DFT/逆 DFT 对的定义，推导对线性卷积对 $x[n]$ 和 $h[n]$ 应用 DFT 与使用适当补零时产生的频域操作之间的精确关系。明确说明以 $x[n]$ 的长度 $L$ 和 $h[n]$ 的长度 $M$ 表示的最小补零标准，该标准需确保通过逆 DFT 计算的时域操作能够重现线性卷积而无时域混叠，并解释不充分的补零如何表现为线性卷积的循环回绕。然后，论述在频率 $f_s$ 下采样和奈奎斯特频率 $f_N = \\frac{f_s}{2}$：解释在何种条件下，给定一个设计为相对于 $f_N$ 具有截止频率 $f_c$ 的低通核 $h[n]$，时域卷积（滤波）不会引入频域混叠。\n\n2. 实现一个程序，该程序在以下测试套件上计算基于 FFT 的卷积，并将其与直接时域卷积进行比较。三角函数中的角度必须是弧度。所有物理速率必须以 $\\mathrm{Hz}$ 表示，持续时间以 $\\mathrm{s}$ 表示。程序必须以无量纲浮点数的形式生成所有最终结果。\n\n测试套件：\n- 测试用例 1（脉冲序列和指数核）：\n    - 采样频率 $f_s = 1000$ $\\mathrm{Hz}$，持续时间 $T = 10$ $\\mathrm{s}$，因此 $L = 10000$ 个样本。\n    - 使用泊松率 $\\lambda = 10$ $\\mathrm{Hz}$ 生成具有独立样本的二进制脉冲序列 $x[n]$，即每个样本的脉冲概率 $p = \\lambda / f_s = 10 / 1000$。使用固定的伪随机数种子 $12345$ 以确保可复现性。\n    - 使用因果指数核 $h[n] = \\exp\\left(-\\frac{n}{\\tau f_s}\\right)$，其中 $n = 0,1,\\dots,M-1$，时间常数 $\\tau = 0.02$ $\\mathrm{s}$，支撑集为 $0.2$ $\\mathrm{s}$；具体地，设置 $M = \\lfloor 0.2 f_s \\rfloor + 1$。\n    - 定义 $N_{\\text{lin}} = L + M - 1$，$N_{\\text{circ}} = \\max(L, M)$，以及 $N_{\\text{pow2}} = 2^{\\lceil \\log_2(N_{\\text{lin}}) \\rceil}$。\n    - 计算三个误差：\n        - $E_{\\text{circ}}$：通过 FFT 计算的 $N_{\\text{circ}}$ 点循环卷积与线性卷积 $y[n]$ 的循环回绕（通过将 $y[n]$ 按模 $N_{\\text{circ}}$ 折叠得到）之间的最大绝对差。\n        - $E_{\\text{lin}}$：使用 $N_{\\text{lin}}$ 补零的基于 FFT 的卷积与直接线性卷积 $y[n]$ 之间的最大绝对差。\n        - $E_{\\text{pow2}}$：使用 $N_{\\text{pow2}}$ 补零的基于 FFT 的卷积与直接线性卷积 $y[n]$ 之间的最大绝对差。\n- 测试用例 2（局部场电位滤波）：\n    - 采样频率 $f_s = 1000$ $\\mathrm{Hz}$，持续时间 $T = 8$ $\\mathrm{s}$，角度参数以弧度为单位，因此 $L = 8000$ 个样本。\n    - 生成 $x[n] = 1.0 \\cdot \\sin(2 \\pi \\cdot 10 \\cdot n/f_s) + 0.5 \\cdot \\sin(2 \\pi \\cdot 80 \\cdot n/f_s) + \\eta[n]$，其中 $\\eta[n]$ 是均值为零、标准差为 $0.2$ 的独立同分布高斯噪声。使用固定的伪随机数种子 $54321$ 以确保可复现性。\n    - 使用 Hann 窗 sinc 方法设计一个长度为 $M = 801$ 的有限脉冲响应低通核 $h[n]$，其截止频率为 $f_c = 40$ $\\mathrm{Hz}$；确保通带为低通（$0$ 到 $f_c$）。你可以使用一个标准的、经过良好测试的加窗 sinc 滤波器设计例程，该例程接受 $f_s$ 并生成 $h[n]$。\n    - 设 $N_{\\text{pow2}} = 2^{\\lceil \\log_2(L + M - 1) \\rceil}$。计算补零到 $N_{\\text{pow2}}$ 的基于 FFT 的卷积 $y_{\\text{fft}}[n]$，以及直接线性卷积 $y_{\\text{dir}}[n]$。\n    - 计算相对误差 $E_{\\text{lfp}} = \\frac{\\|y_{\\text{fft}} - y_{\\text{dir}}\\|_2}{\\|y_{\\text{dir}}\\|_2}$。\n- 测试用例 3（边界情况，最小长度）：\n    - $x[n] = [1.0]$，$h[n] = [0.5]$。设置 $N_{\\text{lin}} = 2$。\n    - 计算 $E_{\\text{short}}$，即使用补零长度 $N_{\\text{lin}}$ 的基于 FFT 的卷积与直接线性卷积之间的绝对差。\n\n你的程序应生成一行输出，其中包含按 $[E_{\\text{circ}},E_{\\text{lin}},E_{\\text{pow2}},E_{\\text{lfp}},E_{\\text{short}}]$ 精确顺序排列的结果，形式为用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4,result_5]$）。所有输出必须是浮点数。不应打印任何额外文本。结果是无量纲和无单位的浮点数。",
            "solution": "所提出的问题是有效的，因为它在科学上基于数字信号处理理论，通过指定数值参数和种子以保证可复现性而设定良好，并使用客观、标准的术语进行表述。我们将首先进行所要求的理论推导，然后是实现细节，这些细节将封装在最终答案中。\n\n### 1. 卷积定理：从循环卷积到线性卷积\n\n我们首先建立线性卷积与循环卷积之间的关系。线性卷积是时域中期望的滤波操作，而循环卷积则是在离散傅里叶变换 (DFT) 域中自然地由乘法表示的操作。\n\n设 $x[n]$ 是一个长度为 $L$ 的离散时间信号，意味着它仅在 $n \\in \\{0, 1, \\dots, L-1\\}$ 时非零；设 $h[n]$ 是一个长度为 $M$ 的滤波器核（脉冲响应），仅在 $n \\in \\{0, 1, \\dots, M-1\\}$ 时非零。\n\n$x[n]$ 和 $h[n]$ 的**线性卷积**，记为 $(x * h)[n]$，定义为：\n$$\ny[n] = (x * h)[n] = \\sum_{m=0}^{M-1} h[m] x[n-m]\n$$\n得到的序列 $y[n]$ 长度为 $N_{\\text{lin}} = L + M - 1$，其非零值出现在索引 $n \\in \\{0, 1, \\dots, L+M-2\\}$ 处。\n\n**DFT 的卷积定理**指出，两个信号的循环卷积的 DFT 是它们各自 DFT 的逐元素乘积。设 $x_p[n]$ 和 $h_p[n]$ 是两个长度均为 $N$ 的信号。它们的 $N$ 点**循环卷积**是：\n$$\n(x_p \\circledast_N h_p)[n] = \\sum_{m=0}^{N-1} x_p[m] h_p[(n-m) \\pmod N]\n$$\n其中 $(n-m) \\pmod N$ 表示 $(n-m)$ 除以 $N$ 的余数。该定理指出：\n$$\n\\text{DFT}_N\\{(x_p \\circledast_N h_p)[n]\\} = X_p[k] \\cdot H_p[k]\n$$\n其中 $X_p[k] = \\text{DFT}_N\\{x_p[n]\\}$ 且 $H_p[k] = \\text{DFT}_N\\{h_p[n]\\}$。因此，我们可以使用逆 DFT (IDFT) 计算循环卷积：\n$$\n(x_p \\circledast_N h_p)[n] = \\text{IDFT}_N\\{X_p[k] \\cdot H_p[k]\\}\n$$\n这个属性非常强大，因为 DFT 可以使用快速傅里叶变换 (FFT) 算法高效计算，对于长信号而言，频域乘法比直接时域卷积快得多。\n\n我们的目标是使用这种高效的方法来计算*线性*卷积 $y[n]$。关键在于认识到线性卷积和循环卷积之间的关系。两个序列的 $N$ 点循环卷积可以表示为其线性卷积的一个“回绕”或混叠版本：\n$$\n(x_p \\circledast_N h_p)[n] = \\sum_{j=-\\infty}^{\\infty} y[n + jN]\n$$\n其中 $y[n]$ 是线性卷积的结果。项 $y[n+jN]$ 表示线性卷积的“尾部”，这些尾部被回绕并加到前 $N$ 个样本上。这种现象称为**时域混叠**。\n\n为了确保循环卷积的结果与线性卷积的结果相同，我们必须防止这种混叠。这可以通过使 DFT 长度 $N$ 足够大，以容纳整个线性卷积结果而无任何回绕来实现。由于线性卷积 $y[n]$ 的长度为 $L+M-1$，我们必须选择一个 DFT 长度 $N$，使得 $N \\ge L+M-1$。\n\n**最小补零标准：**为使用 DFT/FFT 计算长度为 $L$ 的信号 $x[n]$ 和长度为 $M$ 的信号 $h[n]$ 的线性卷积，两个信号都必须补零到一个满足 $N \\ge L+M-1$ 的公共长度 $N$。\n\n步骤如下：\n1.  选择一个变换长度 $N \\ge L+M-1$。为了 FFT 算法的计算效率，_N_ 通常被选为下一个 2 的最高次幂，即 $N = 2^{\\lceil \\log_2(L+M-1) \\rceil}$。\n2.  通过在原始信号 $x[n]$ 和 $h[n]$ 后面追加零来创建长度为 $N$ 的补零信号 $x_p[n]$ 和 $h_p[n]$。\n3.  计算它们的 $N$ 点 FFT：$X_p[k] = \\text{FFT}\\{x_p[n]\\}$ 和 $H_p[k] = \\text{FFT}\\{h_p[n]\\}$。\n4.  将结果逐元素相乘：$Y_p[k] = X_p[k] \\cdot H_p[k]$。\n5.  计算 $N$ 点逆 FFT (IFFT)：$y_p[n] = \\text{IFFT}\\{Y_p[k]\\}$。\n\n得到的序列 $y_p[n]$ 将是实数值（在机器精度范围内），其前 $L+M-1$ 个样本将与线性卷积 $y[n]$ 相同。剩下的 $N - (L+M-1)$ 个样本将为零。\n\n如果使用的补零长度 $N  L+M-1$ 不足，IFFT 的结果将是混叠的循环卷积，其中线性卷积 $y[k]$ 在 $k \\ge N$ 处的值会被回绕并加到 $y[k \\pmod N]$ 的值上。这就是问题中描述的循环回绕效应。\n\n### 2. 滤波与频域混叠\n\n问题询问在何种条件下时域卷积（滤波）不会引入**频域混叠**。这需要谨慎使用术语。\n\n频域混叠是**采样过程**的产物，即从连续时间信号 $x_c(t)$ 转换为离散时间信号 $x[n] = x_c(nT_s)$ 的过程，其中 $T_s = 1/f_s$ 是采样周期。根据奈奎斯特-香农采样定理，如果连续时间信号 $x_c(t)$ 中的最高频率分量（记为 $f_{\\text{max}}$）大于奈奎斯特频率 $f_N = f_s/2$，那么高于 $f_N$ 的频率分量将“折叠”到频率范围 $[0, f_N]$ 内，与较低的频率混杂在一起。这就是混叠。一旦信号被采样且发生混叠，就无法撤销。\n\n线性卷积 $y[n] = (x * h)[n]$ 是一种**线性时不变 (LTI)** 操作。LTI 系统的一个基本属性是它们不能在输出中产生输入中不存在的新频率分量。输出信号的频谱 $Y(e^{j\\omega})$ 仅仅是输入信号频谱 $X(e^{j\\omega})$ 与滤波器频率响应 $H(e^{j\\omega})$ 的乘积：\n$$\nY(e^{j\\omega}) = X(e^{j\\omega}) H(e^{j\\omega})\n$$\n因此，离散时间线性卷积操作**本身不会引入频域混叠**。混叠是由信号 $x[n]$ 的初始采样决定的一个特性。\n\n截止频率为 $f_c$（其中 $f_c  f_N$）的低通滤波器的作用不是防止卷积*引入*混叠，而是*移除*或*衰减*信号 $x[n]$ 中高于 $f_c$ 的频率分量。\n- 如果 $x[n]$ 已经被正确采样（即未混叠），低通滤波器只是简单地移除其高频内容。得到的信号 $y[n]$ 带宽被限制在大约 $f_c$。这是分离特定感兴趣频带的标准程序。\n- 如果 $x[n]$ 是一个混叠信号，低通滤波器将作用于其折叠后的频谱。它将通过低频内容（其中可能包含被混叠到低频带的原始高频内容），并衰减 $[0, f_N]$ 范围内的较高频率。它无法纠正已经发生的混叠。\n- 这种滤波器的一个常见用途是在*降采样之前*用作**抗混叠滤波器**。如果希望降低信号的采样率，必须首先用一个截止频率低于新目标奈奎斯特频率的低通滤波器对其进行滤波，以防止在降采样后的信号中产生混叠。\n\n总而言之，时域卷积不引入频域混叠的条件是该操作是线性的，根据所指定的卷积定义，这是成立的。滤波器 $h[n]$ 的属性和采样率 $f_s$ 决定了输出的频谱内容，但滤波操作本身不是新混叠的来源。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft\nfrom scipy.signal import convolve, firwin\n\ndef solve():\n    \"\"\"\n    Solves the problem by performing theoretical derivations and numerical computations\n    for three test cases related to FFT-based convolution.\n    \"\"\"\n    \n    # --- Test Case 1: Spike train and exponential kernel ---\n    \n    # Parameters\n    fs_1 = 1000.0  # Hz\n    T_1 = 10.0   # s\n    L_1 = int(fs_1 * T_1)\n    lambda_rate = 10.0  # Hz\n    p_spike = lambda_rate / fs_1\n    seed_1 = 12345\n    \n    # Generate spike train\n    rng_1 = np.random.default_rng(seed_1)\n    x_1 = rng_1.binomial(1, p_spike, size=L_1).astype(float)\n    \n    # Generate kernel\n    tau_1 = 0.02  # s\n    support_dur = 0.2 # s\n    M_1 = int(np.floor(support_dur * fs_1)) + 1\n    n_h1 = np.arange(M_1)\n    h_1 = np.exp(-n_h1 / (tau_1 * fs_1))\n    \n    # Define convolution lengths\n    N_lin_1 = L_1 + M_1 - 1\n    N_circ_1 = max(L_1, M_1)\n    N_pow2_1 = 1  (N_lin_1 - 1).bit_length() # Equivalent to 2**ceil(log2(N_lin))\n\n    # Direct linear convolution\n    y_lin_1 = convolve(x_1, h_1, mode='full', method='direct')\n\n    # E_circ computation\n    # 1. FFT-based circular convolution\n    h_pad_circ = np.zeros(N_circ_1)\n    h_pad_circ[:M_1] = h_1\n    y_fft_circ = ifft(fft(x_1, n=N_circ_1) * fft(h_pad_circ, n=N_circ_1)).real\n\n    # 2. Wrapped linear convolution\n    y_wrap = np.copy(y_lin_1[:N_circ_1])\n    if len(y_lin_1) > N_circ_1:\n         y_wrap[:len(y_lin_1) - N_circ_1] += y_lin_1[N_circ_1:]\n\n    E_circ = np.max(np.abs(y_fft_circ - y_wrap))\n    \n    # E_lin computation\n    y_fft_lin = ifft(fft(x_1, n=N_lin_1) * fft(h_1, n=N_lin_1)).real\n    E_lin = np.max(np.abs(y_fft_lin - y_lin_1))\n\n    # E_pow2 computation\n    y_fft_pow2 = ifft(fft(x_1, n=N_pow2_1) * fft(h_1, n=N_pow2_1)).real\n    E_pow2 = np.max(np.abs(y_fft_pow2[:N_lin_1] - y_lin_1))\n\n    # --- Test Case 2: LFP filtering ---\n\n    # Parameters\n    fs_2 = 1000.0  # Hz\n    T_2 = 8.0    # s\n    L_2 = int(fs_2 * T_2)\n    seed_2 = 54321\n\n    # Generate LFP-like signal\n    rng_2 = np.random.default_rng(seed_2)\n    n_2 = np.arange(L_2)\n    t_2 = n_2 / fs_2\n    x_2 = (1.0 * np.sin(2 * np.pi * 10.0 * t_2) + \n           0.5 * np.sin(2 * np.pi * 80.0 * t_2) +\n           rng_2.normal(0, 0.2, size=L_2))\n\n    # Design FIR filter\n    M_2 = 801\n    fc_2 = 40.0  # Hz\n    h_2 = firwin(numtaps=M_2, cutoff=fc_2, fs=fs_2, window='hann', pass_zero='lowpass')\n\n    # Define convolution length\n    N_lin_2 = L_2 + M_2 - 1\n    N_pow2_2 = 1  (N_lin_2 - 1).bit_length()\n\n    # Direct and FFT-based convolution\n    y_dir_2 = convolve(x_2, h_2, mode='full', method='direct')\n    y_fft_2 = ifft(fft(x_2, n=N_pow2_2) * fft(h_2, n=N_pow2_2)).real\n    y_fft_2_trimmed = y_fft_2[:len(y_dir_2)]\n    \n    # Compute relative error\n    norm_diff = np.linalg.norm(y_fft_2_trimmed - y_dir_2)\n    norm_dir = np.linalg.norm(y_dir_2)\n    E_lfp = norm_diff / norm_dir if norm_dir > 0 else 0.0\n\n    # --- Test Case 3: Boundary case ---\n\n    x_3 = np.array([1.0])\n    h_3 = np.array([0.5])\n    N_lin_3 = 2 # As per problem statement\n    \n    # Direct convolution\n    y_dir_3 = convolve(x_3, h_3, mode='full')\n    \n    # FFT-based convolution\n    y_fft_3 = ifft(fft(x_3, n=N_lin_3) * fft(h_3, n=N_lin_3)).real\n    \n    # Compute absolute difference\n    E_short = np.max(np.abs(y_fft_3[:len(y_dir_3)] - y_dir_3))\n\n    # --- Final Output ---\n    results = [E_circ, E_lin, E_pow2, E_lfp, E_short]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}