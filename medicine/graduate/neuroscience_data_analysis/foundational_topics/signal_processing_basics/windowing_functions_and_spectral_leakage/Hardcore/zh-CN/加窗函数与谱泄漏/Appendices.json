{
    "hands_on_practices": [
        {
            "introduction": "这个练习为我们奠定了理论基础。它将我们从对谱泄漏的定性理解，提升到精确的解析推导。通过对一个未精确落在频箱中心的单一正弦波进行离散傅里叶变换（DFT）的数学推导，学生们将直接看到有限时长观测（即矩形窗）如何导致信号能量“泄漏”到相邻的频率箱中。本练习旨在加深对狄利克雷核（Dirichlet kernel）的理解，它是矩形窗在频谱上的标志性形态()。",
            "id": "4204104",
            "problem": "您正在分析一段皮层记录中的局部场电位，并希望量化在离散傅里叶变换 (DFT) 中使用矩形窗所导致的频谱泄漏。考虑一个经过矩形窗加窗的长度为 $N$ 的时间序列，其中测得的信号段包含一个单一的复正弦波\n$$\nx[n] = A \\exp\\!\\Big(j\\big(2\\pi \\tfrac{k_{0}+\\varepsilon}{N}\\,n + \\phi\\big)\\Big), \\quad n=0,1,\\dots,N-1,\n$$\n其幅度为 $A \\in \\mathbb{C}$，任意相位为 $\\phi \\in \\mathbb{R}$，整数频率仓索引为 $k_{0}$，以及一个非频率仓中心的频率小数偏移 $0  \\varepsilon  \\frac{1}{2}$。$N$ 点离散傅里叶变换 (DFT) 定义如下\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\!\\Big(-j\\,2\\pi \\tfrac{k}{N}\\,n\\Big), \\quad k=0,1,\\dots,N-1.\n$$\n从 DFT 的定义和关于有限几何级数的首要原理出发，推导当正弦波不落在频率仓中心时，由矩形窗产生的泄漏到两个直接相邻的 DFT 频率仓 $k=k_{0}-1$ 和 $k=k_{0}+1$ 中的总泄漏功率的闭式表达式。也就是说，计算\n$$\nP_{\\text{leak}} \\equiv |X[k_{0}-1]|^{2} + |X[k_{0}+1]|^{2}\n$$\n将其表示为以 $A$、$N$ 和 $\\varepsilon$ 表示的闭式解析表达式。请以单个简化的解析表达式给出最终答案。不要代入数值。最终答案无需单位。",
            "solution": "该问题陈述是数字信号处理领域一个适定且有科学依据的练习，而数字信号处理是定量神经科学的核心组成部分。它要求从第一性原理出发，推导一个与频谱泄漏相关的特定物理量。该问题是有效的，将按如下方式求解。\n\n我们的目标是计算加窗复正弦波中心频率分量相邻的 DFT 频率仓中的总泄漏功率 $P_{\\text{leak}}$。信号由下式给出\n$$\nx[n] = A \\exp\\left(j\\left(2\\pi \\frac{k_{0}+\\varepsilon}{N}\\,n + \\phi\\right)\\right), \\quad n=0, 1, \\dots, N-1\n$$\n其中 $A \\in \\mathbb{C}$ 是复振幅，$\\phi$ 是任意相位，$k_{0}$ 是整数频率仓索引， $0  \\varepsilon  \\frac{1}{2}$ 是频率的小数偏移量。\n\n$N$ 点离散傅里叶变换 (DFT) 定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j\\,2\\pi \\frac{k}{N}\\,n\\right)\n$$\n我们首先将 $x[n]$ 的表达式代入 DFT 定义中：\n$$\nX[k] = \\sum_{n=0}^{N-1} \\left[ A \\exp\\left(j\\left(2\\pi \\frac{k_{0}+\\varepsilon}{N}\\,n + \\phi\\right)\\right) \\right] \\exp\\left(-j\\,2\\pi \\frac{k}{N}\\,n\\right)\n$$\n我们可以将不依赖于求和索引 $n$ 的项（即 $A$ 和 $\\exp(j\\phi)$）提取出来，并合并求和内的指数项：\n$$\nX[k] = A \\exp(j\\phi) \\sum_{n=0}^{N-1} \\exp\\left(j\\,2\\pi \\frac{k_{0}+\\varepsilon}{N}\\,n - j\\,2\\pi \\frac{k}{N}\\,n\\right)\n$$\n$$\nX[k] = A \\exp(j\\phi) \\sum_{n=0}^{N-1} \\exp\\left(j\\,2\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\,n\\right)\n$$\n这个求和是一个形式为 $\\sum_{n=0}^{N-1} r^n$ 的有限几何级数，其公比 $r$ 由下式给出：\n$$\nr = \\exp\\left(j\\,2\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right)\n$$\n有限几何级数的和由公式 $\\sum_{n=0}^{N-1} r^n = \\frac{1-r^N}{1-r}$ 给出，条件是 $r \\neq 1$。条件 $r=1$ 意味着指数是 $j2\\pi$ 的整数倍。这将意味着 $\\frac{k_{0}+\\varepsilon-k}{N}$ 是一个整数。然而，由于 $k_0$ 和 $k$ 是整数，且 $0  \\varepsilon  \\frac{1}{2}$，项 $k_0+\\varepsilon-k$ 永远不会是 $N$ 的整数倍（除非 $N=1$，此时 $k_0+\\varepsilon-k$ 不是整数）。因此，对于所有整数 $k$ 值，$r \\neq 1$，该公式适用。\n\n让我们计算 $r^N$：\n$$\nr^N = \\left[\\exp\\left(j\\,2\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right)\\right]^N = \\exp\\left(j\\,2\\pi (k_{0}+\\varepsilon-k)\\right)\n$$\n由于 $k_0$ 和 $k$ 是整数，$\\exp(j\\,2\\pi(k_0-k)) = (\\exp(j2\\pi))^{k_0-k} = 1^{k_0-k} = 1$。因此，\n$$\nr^N = \\exp(j\\,2\\pi\\varepsilon)\n$$\n将此代入求和公式，我们得到：\n$$\n\\sum_{n=0}^{N-1} r^n = \\frac{1 - \\exp(j\\,2\\pi\\varepsilon)}{1 - \\exp\\left(j\\,2\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right)}\n$$\n现在，我们可以写出 $X[k]$ 的完整表达式：\n$$\nX[k] = A \\exp(j\\phi) \\frac{1 - \\exp(j\\,2\\pi\\varepsilon)}{1 - \\exp\\left(j\\,2\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right)}\n$$\n为了简化此表达式并求其幅值，我们使用恒等式 $1 - \\exp(j\\theta) = \\exp(j\\theta/2)(\\exp(-j\\theta/2) - \\exp(j\\theta/2)) = -2j\\exp(j\\theta/2)\\sin(\\theta/2)$。将其应用于分子和分母：\n- 分子： $1 - \\exp(j\\,2\\pi\\varepsilon) = -2j\\exp(j\\pi\\varepsilon)\\sin(\\pi\\varepsilon)$\n- 分母： $1 - \\exp\\left(j\\,2\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right) = -2j\\exp\\left(j\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right)\\sin\\left(\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right)$\n\n将这些代回 $X[k]$ 的表达式中：\n$$\nX[k] = A \\exp(j\\phi) \\frac{-2j\\exp(j\\pi\\varepsilon)\\sin(\\pi\\varepsilon)}{-2j\\exp\\left(j\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right)\\sin\\left(\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right)}\n$$\n$$\nX[k] = A \\exp(j\\phi) \\exp\\left(j\\pi\\varepsilon - j\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right) \\frac{\\sin(\\pi\\varepsilon)}{\\sin\\left(\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right)}\n$$\n这个表达式是矩形窗加窗正弦波的离散时间傅里叶变换，它是一个经过缩放和频移的狄利克雷核。\n\n我们需要计算特定频率仓的功率，即 $|X[k]|^2$。任何形式为 $\\exp(j\\theta)$ 的复指数项的幅值都为 $1$。相位项 $\\exp(j\\phi)$ 和推导出的相位项也具有单位幅值。因此，幅值的平方为：\n$$\n|X[k]|^2 = |A|^2 \\left| \\frac{\\sin(\\pi\\varepsilon)}{\\sin\\left(\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right)} \\right|^2 = |A|^2 \\frac{\\sin^2(\\pi\\varepsilon)}{\\sin^2\\left(\\pi \\frac{k_{0}+\\varepsilon-k}{N}\\right)}\n$$\n题目要求的是泄漏到两个直接相邻频率仓 $k=k_0-1$ 和 $k=k_0+1$ 中的总功率。我们对这两个 $k$ 值计算 $|X[k]|^2$。\n\n对于频率仓 $k=k_0-1$：\n分母中正弦函数的自变量变为 $\\pi \\frac{k_0+\\varepsilon-(k_0-1)}{N} = \\pi \\frac{1+\\varepsilon}{N}$。\n该频率仓的功率为：\n$$\n|X[k_0-1]|^2 = |A|^2 \\frac{\\sin^2(\\pi\\varepsilon)}{\\sin^2\\left(\\pi \\frac{1+\\varepsilon}{N}\\right)}\n$$\n对于频率仓 $k=k_0+1$：\n分母中正弦函数的自变量变为 $\\pi \\frac{k_0+\\varepsilon-(k_0+1)}{N} = \\pi \\frac{\\varepsilon-1}{N}$。\n该频率仓的功率为：\n$$\n|X[k_0+1]|^2 = |A|^2 \\frac{\\sin^2(\\pi\\varepsilon)}{\\sin^2\\left(\\pi \\frac{\\varepsilon-1}{N}\\right)}\n$$\n使用性质 $\\sin(-x) = -\\sin(x)$，我们有 $\\sin^2(-x) = (-\\sin(x))^2 = \\sin^2(x)$。因此：\n$$\n\\sin^2\\left(\\pi \\frac{\\varepsilon-1}{N}\\right) = \\sin^2\\left(-\\pi \\frac{1-\\varepsilon}{N}\\right) = \\sin^2\\left(\\pi \\frac{1-\\varepsilon}{N}\\right)\n$$\n所以，频率仓 $k=k_0+1$ 中的功率为：\n$$\n|X[k_0+1]|^2 = |A|^2 \\frac{\\sin^2(\\pi\\varepsilon)}{\\sin^2\\left(\\pi \\frac{1-\\varepsilon}{N}\\right)}\n$$\n总泄漏功率 $P_{\\text{leak}}$ 是这两个频率仓中功率的和：\n$$\nP_{\\text{leak}} = |X[k_0-1]|^2 + |X[k_0+1]|^2\n$$\n$$\nP_{\\text{leak}} = |A|^2 \\frac{\\sin^2(\\pi\\varepsilon)}{\\sin^2\\left(\\pi \\frac{1+\\varepsilon}{N}\\right)} + |A|^2 \\frac{\\sin^2(\\pi\\varepsilon)}{\\sin^2\\left(\\pi \\frac{1-\\varepsilon}{N}\\right)}\n$$\n提出公因子 $|A|^2 \\sin^2(\\pi\\varepsilon)$，我们得到最终的闭式表达式：\n$$\nP_{\\text{leak}} = |A|^2 \\sin^2(\\pi\\varepsilon) \\left[ \\frac{1}{\\sin^2\\left(\\frac{\\pi(1+\\varepsilon)}{N}\\right)} + \\frac{1}{\\sin^2\\left(\\frac{\\pi(1-\\varepsilon)}{N}\\right)} \\right]\n$$\n该表达式仅依赖于 $|A|^2$、$N$ 和 $\\varepsilon$，符合题目要求。",
            "answer": "$$\n\\boxed{|A|^{2} \\sin^{2}(\\pi\\varepsilon) \\left[ \\frac{1}{\\sin^{2}\\left(\\frac{\\pi(1+\\varepsilon)}{N}\\right)} + \\frac{1}{\\sin^{2}\\left(\\frac{\\pi(1-\\varepsilon)}{N}\\right)} \\right]}\n$$"
        },
        {
            "introduction": "虽然减少旁瓣泄漏至关重要，但这通常以加宽主瓣为代价，从而影响谱分辨率。本练习直接探讨了这一权衡，要求学生判断在何种条件下两个频率相近的正弦信号可以在频谱中被区分开。通过编程实现一个量化的峰值可分辨性判据，学生将对瑞利判据（Rayleigh criterion）建立直观和实践性的认识，并理解窗长 $N$ 如何决定了谱分辨率的基本极限 $\\Delta f = f_s/N$ ()。",
            "id": "4204076",
            "problem": "一个神经科学实验室正在分析一段脑电图 (EEG) 数据，以区分两个频率相近的振荡分量。该观测被建模为两个正弦波之和，并由一个有限长度的窗进行截断。您需要通过严谨的频谱分析，确定在何种条件下，矩形窗会因其窗函数引起的谱核主瓣宽度而无法分离两个邻近的峰值。所有计算都必须在下文指定的合成信号上进行。\n\n基本假设和定义：\n- 离散时间信号为 $x[n] = a_1 \\cos\\!\\left(2\\pi \\frac{f_1}{f_s} n + \\phi_1\\right) + a_2 \\cos\\!\\left(2\\pi \\frac{f_2}{f_s} n + \\phi_2\\right)$，$n \\in \\{0,1,\\dots,N-1\\}$，其中 $f_s$ 是采样频率（单位为 $\\mathrm{Hz}$），$N$ 是窗长（单位为采样点数），$f_1$ 和 $f_2$ 是正弦波频率（单位为 $\\mathrm{Hz}$），$a_1$ 和 $a_2$ 是振幅，$\\phi_1$ 和 $\\phi_2$ 是相位（单位为弧度）。\n- 矩形窗为 $w[n]=1$（对于 $0\\le n \\le N-1$）且在其他情况下 $w[n]=0$。加窗后的信号为 $x_w[n]=x[n] w[n]$。\n- 离散傅里叶变换 (DFT) 对 $k\\in\\{0,1,\\dots,N-1\\}$ 定义为 $X[k]=\\sum_{n=0}^{N-1} x_w[n] e^{-j 2\\pi kn/N}$，其快速傅里叶变换 (FFT) 是计算 DFT 采样点的一种高效算法。在离散时间傅里叶变换 (DTFT) 下，时域中的乘法对应于频域中的卷积。矩形窗的频谱响应具有 sinc 形的幅值，其主瓣的第一个零点位于频率偏移 $\\pm \\Delta f$ 处，其中 $\\Delta f = f_s/N$。\n- DFT 频率仓间距为 $\\Delta f = f_s/N$（单位 $\\mathrm{Hz}$），矩形窗主瓣在第一零点之间的宽度为 $2\\,\\Delta f$（单位 $\\mathrm{Hz}$）。\n\n任务：\n- 对于下方的每个测试用例，生成 $a_1=a_2=1$ 和 $\\phi_1=\\phi_2=0$（弧度）的信号 $x[n]$，应用长度为 $N$ 的矩形窗，并通过在 FFT 之前对加窗序列进行补零来计算一个精细采样的幅度谱 $|X(f)|$，以获得一个分辨率远高于 $\\Delta f$ 的频率网格。利用此结果来判断在真实正弦波频率附近是否存在两个可分辨的峰值。\n- 峰值可分辨性的判定定义如下。令 $f_{\\min}=\\min(f_1,f_2)$ 且 $f_{\\max}=\\max(f_1,f_2)$。考虑一个搜索频带 $[f_{\\min}-1, f_{\\max}+1]$（单位 $\\mathrm{Hz}$）。当且仅当以下所有条件都成立时，声明这两个峰值是可分辨的：\n  1. 在搜索频带中，存在至少两个 $|X(f)|$ 的局部最大值，其突起度至少为该频带内最大幅值的固定比例 $\\alpha$，$\\alpha$ 的值在下文指定。\n  2. 频带中两个最突出的最大值之间的频率间隔至少为 $0.49\\,\\mathrm{Hz}$。\n  3. 这两个最大值之间的最小幅值（谷底）至多是两个峰值幅值中较小者的 $\\tau$ 倍，$\\tau$ 的值在下文指定。\n- 对所有测试用例使用 $\\alpha=0.2$ 和 $\\tau=0.85$。如果满足上述所有条件，则输出布尔值 $ \\mathrm{True}$，否则输出 $ \\mathrm{False}$。\n\n测试套件：\n- 情况 A（仓中，间隔等于矩形窗的一个频率仓宽度）：$f_s=500\\,\\mathrm{Hz}$，$N=1000$，$f_1=10.0\\,\\mathrm{Hz}$，$f_2=10.5\\,\\mathrm{Hz}$。\n- 情况 B（每个偏离频率仓四分之一，标称间隔相同）：$f_s=500\\,\\mathrm{Hz}$，$N=1000$，$f_1=10.125\\,\\mathrm{Hz}$，$f_2=10.625\\,\\mathrm{Hz}$。\n- 情况 C（间隔小于一个频率仓宽度）：$f_s=500\\,\\mathrm{Hz}$，$N=1000$，$f_1=10.0\\,\\mathrm{Hz}$，$f_2=10.4\\,\\mathrm{Hz}$。\n- 情况 D（较短的窗使得一个频率仓的宽度大于间隔）：$f_s=500\\,\\mathrm{Hz}$，$N=500$，$f_1=10.0\\,\\mathrm{Hz}$，$f_2=10.5\\,\\mathrm{Hz}$。\n\n实现要求：\n- 在补零网格上计算 FFT 幅值，以使频率分辨率至多为 $0.01\\,\\mathrm{Hz}$。\n- 所有内部角度计算使用弧度，所有频率使用 $\\mathrm{Hz}$。\n- 最终输出必须是单行，包含一个 Python 列表字面量，其中按顺序包含对应于情况 A、B、C 和 D 的四个布尔值，例如：$[True, False, False, True]$（不含任何附加文本）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3,result4]”）。",
            "solution": "该问题要求基于一组精确的量化标准，判断两个频率相近的正弦波的频谱可分辨性。该分析基于傅里叶分析的原理以及加窗对离散时间信号的影响。\n\n**1. 理论框架**\n\n我们考虑的信号是两个离散时间正弦波的和：\n$$\nx[n] = a_1 \\cos\\left(2\\pi \\frac{f_1}{f_s} n + \\phi_1\\right) + a_2 \\cos\\left(2\\pi \\frac{f_2}{f_s} n + \\phi_2\\right)\n$$\n该信号在从 $n=0$ 到 $n=N-1$ 的有限时长内被观测。这种有限观测等效于将无限时长的信号乘以一个矩形窗 $w[n]$，其中：\n$$\nw[n] = \\begin{cases} 1  0 \\le n \\le N-1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n观测到的信号是 $x_w[n] = x[n] w[n]$。根据傅里叶变换的卷积定理，时域中的乘法对应于频域中的卷积。加窗信号的离散时间傅里叶变换 (DTFT) $X_w(e^{j\\omega})$ 是理想信号的 DTFT $X(e^{j\\omega})$ 与窗函数的 DTFT $W(e^{j\\omega})$ 的循环卷积：\n$$\nX_w(e^{j\\omega}) = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} X(e^{j\\theta}) W(e^{j(\\omega-\\theta)}) d\\theta\n$$\n理想信号 $x[n]$ 的 DTFT 由位于对应于 $\\pm f_1$ 和 $\\pm f_2$ 的归一化频率上的多对狄拉克δ函数组成。矩形窗的 DTFT $W(e^{j\\omega})$ 由下式给出：\n$$\nW(e^{j\\omega}) = \\sum_{n=0}^{N-1} e^{-j\\omega n} = e^{-j\\omega\\frac{N-1}{2}} \\frac{\\sin(\\omega N/2)}{\\sin(\\omega/2)}\n$$\n该函数 $|W(e^{j\\omega})|$ 的幅值是一个类似 sinc 的函数，具有一个主瓣和衰减的旁瓣。卷积运算实际上是用窗谱 $W(e^{j\\omega})$ 的一个缩放和平移版本替换了信号频谱中的每个理想δ函数。\n\n**2. 频谱分辨率**\n\n如果频谱中两个频率分量对应的主瓣可以区分为独立的峰，则认为它们是可分辨的。一个经典的经验法则是瑞利判据，该判据指出，如果一个峰的最大值恰好落在另一个峰的第一个最小值（零点）上，则这两个峰刚好可分辨。对于矩形窗，主瓣的第一个零点出现在距中心频率 $\\pm f_s/N$ 的频率偏移处。因此，瑞利判据表明，如果两个等幅正弦波的频率间隔 $|f_1 - f_2|$ 至少为一个 DFT 频率仓间距 $\\Delta f = f_s/N$，它们就是可分辨的。\n\n本问题基于应用于计算出的幅度谱的三个特定条件，提供了一个更严谨和定量的可分辨性定义。\n\n**3. 计算步骤**\n\n对于每个测试用例，执行以下步骤：\n\n1.  **信号合成**：使用指定的参数 $f_s, N, f_1, f_2$，以及振幅 $a_1=a_2=1$ 和相位 $\\phi_1=\\phi_2=0$，为 $n \\in \\{0, 1, \\dots, N-1\\}$ 生成离散时间信号 $x[n]$。\n\n2.  **高分辨率频谱计算**：为了精确评估连续 DTFT 的形状，我们在一个精细采样的频率网格上计算离散傅里叶变换 (DFT)。这是通过在应用快速傅里叶变换 (FFT) 算法之前，将 $N$ 个采样的信号 $x[n]$ 补零到一个更长的长度 $N_{\\text{FFT}}$ 来实现的。要求频率网格分辨率至多为 $0.01\\,\\mathrm{Hz}$，这决定了长度 $N_{\\text{FFT}} \\ge f_s / 0.01$。对于 $f_s = 500\\,\\mathrm{Hz}$，这意味着 $N_{\\text{FFT}} \\ge 50000$。一个标准的选择是 2 的幂，例如 $N_{\\text{FFT}} = 2^{16} = 65536$。\n\n3.  **搜索频带内的频谱分析**：\n    a. 从 FFT 结果计算幅度谱 $|X(f)|$。\n    b. 在频域中定义一个特定的搜索频带为 $[f_{\\min}-1, f_{\\max}+1]\\,\\mathrm{Hz}$，其中 $f_{\\min} = \\min(f_1, f_2)$ 且 $f_{\\max} = \\max(f_1, f_2)$。\n    c. 通过在该频带内应用三个可分辨性条件来进行分析。\n\n4.  **可分辨性标准的应用**：\n\n    *   **条件 1 (峰值突起度)**：我们识别出搜索频带内所有局部最大值，其突起度至少为该频带内最大频谱幅值的比例 $\\alpha=0.2$。一个峰的突起度是其峰顶到环绕它但不环绕任何更高峰的最低等高线之间的垂直距离。如果找到的此类突起峰少于两个，则认为这些分量是不可分辨的。\n\n    *   **条件 2 (峰值间隔)**：如果两个或更多峰满足条件 1，我们选择突起度值最高的两个峰。然后我们检查这两个最突出的峰之间的频率间隔是否至少为 $0.49\\,\\mathrm{Hz}$。如果不满足此条件，则分量是不可分辨的。\n\n    *   **条件 3 (谷底深度)**：我们找到两个最突出的峰之间频率范围内的最小频谱幅值（“谷底”）。这个谷底幅值必须不大于两个峰值幅值中较小者的比例 $\\tau=0.85$。如果谷底太浅，则认为这些分量是不可分辨的。\n\n    只有当所有三个条件都满足时，才返回 `True`（可分辨）的结果。否则，结果为 `False`（不可分辨）。\n\n**4. 测试用例分析**\n\n*   **情况 A**：$f_s=500\\,\\mathrm{Hz}, N=1000, f_1=10.0\\,\\mathrm{Hz}, f_2=10.5\\,\\mathrm{Hz}$。这里，DFT 频率仓间距为 $\\Delta f = f_s/N = 0.5\\,\\mathrm{Hz}$。频率间隔为 $|f_1-f_2| = 0.5\\,\\mathrm{Hz}$，恰好是 $\\Delta f$。根据瑞利判据，这是一个临界情况。所提供的量化标准将给出一个明确的答案。\n\n*   **情况 B**：$f_s=500\\,\\mathrm{Hz}, N=1000, f_1=10.125\\,\\mathrm{Hz}, f_2=10.625\\,\\mathrm{Hz}$。频率间隔同样是 $0.5\\,\\mathrm{Hz}$，但此时频率位于 DFT 频率仓之间。与仓中情况相比，这通常会导致峰间谷底更高，可能导致不满足条件 3。\n\n*   **情况 C**：$f_s=500\\,\\mathrm{Hz}, N=1000, f_1=10.0\\,\\mathrm{Hz}, f_2=10.4\\,\\mathrm{Hz}$。频率间隔为 $|f_1-f_2| = 0.4\\,\\mathrm{Hz}$，小于 $\\Delta f = 0.5\\,\\mathrm{Hz}$。预计主瓣会显著合并，很可能无法产生满足突起度和谷底深度标准的两个不同峰值。\n\n*   **情况 D**：$f_s=500\\,\\mathrm{Hz}, N=500, f_1=10.0\\,\\mathrm{Hz}, f_2=10.5\\,\\mathrm{Hz}$。窗更短，因此频率仓间距更宽：$\\Delta f = f_s/N = 1.0\\,\\mathrm{Hz}$。频率间隔为 $0.5\\,\\mathrm{Hz}$，仅为 $0.5\\,\\Delta f$。窗谱的主瓣宽度是情况 A 的两倍。预计两个频谱分量将合并成一个无法分辨的单峰。\n\n所提供的 Python 代码实现了这整个过程，以确定每种情况下的可分辨性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print the results.\n    \"\"\"\n    \n    test_cases = [\n        # Case A: bin-centered, separation equals one bin\n        {'fs': 500.0, 'N': 1000, 'f1': 10.0, 'f2': 10.5},\n        # Case B: off-bin, same separation\n        {'fs': 500.0, 'N': 1000, 'f1': 10.125, 'f2': 10.625},\n        # Case C: separation less than one bin\n        {'fs': 500.0, 'N': 1000, 'f1': 10.0, 'f2': 10.4},\n        # Case D: shorter window, larger bin width\n        {'fs': 500.0, 'N': 500, 'f1': 10.0, 'f2': 10.5},\n    ]\n\n    # Parameters from the problem statement\n    alpha = 0.2\n    tau = 0.85\n    min_peak_sep_hz = 0.49\n    freq_resolution_hz = 0.01\n\n    results = []\n    for case in test_cases:\n        is_resolved = analyze_case(\n            fs=case['fs'],\n            N=case['N'],\n            f1=case['f1'],\n            f2=case['f2'],\n            alpha=alpha,\n            tau=tau,\n            min_peak_sep_hz=min_peak_sep_hz,\n            freq_resolution_hz=freq_resolution_hz\n        )\n        results.append(is_resolved)\n\n    # Format output exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef analyze_case(fs, N, f1, f2, alpha, tau, min_peak_sep_hz, freq_resolution_hz):\n    \"\"\"\n    Analyzes a single case for spectral resolvability based on the problem's criteria.\n\n    Returns:\n        bool: True if peaks are resolved, False otherwise.\n    \"\"\"\n    # 1. Signal Generation\n    t = np.arange(N) / fs\n    signal = np.cos(2 * np.pi * f1 * t) + np.cos(2 * np.pi * f2 * t)\n\n    # 2. High-Resolution Spectrum Calculation (FFT with Zero-Padding)\n    # Determine FFT size for required frequency resolution\n    n_fft = int(np.ceil(fs / freq_resolution_hz))\n    # Use a power of 2 for efficiency, greater than or equal to required n_fft\n    n_fft = 1  (n_fft - 1).bit_length()\n\n    fft_result = np.fft.fft(signal, n=n_fft)\n    fft_freq = np.fft.fftfreq(n_fft, d=1.0/fs)\n    \n    # We only need the positive frequency part of the spectrum\n    positive_freq_mask = fft_freq >= 0\n    freqs = fft_freq[positive_freq_mask]\n    magnitudes = np.abs(fft_result[positive_freq_mask])\n\n    # 3. Define Search Band and Isolate Spectrum\n    f_min = min(f1, f2)\n    f_max = max(f1, f2)\n    search_band_mask = (freqs >= f_min - 1.0)  (freqs = f_max + 1.0)\n\n    freqs_search = freqs[search_band_mask]\n    mags_search = magnitudes[search_band_mask]\n\n    # Handle empty search band (edge case)\n    if mags_search.size == 0:\n        return False\n        \n    # 4. Apply Resolvability Criteria\n    \n    # Condition 1: Find prominent peaks\n    max_mag_in_band = np.max(mags_search)\n    prominence_threshold = alpha * max_mag_in_band\n    \n    peak_indices, properties = find_peaks(mags_search, prominence=prominence_threshold)\n    \n    if len(peak_indices)  2:\n        return False\n\n    # Select the two most prominent peaks\n    prominences = properties['prominences']\n    sorted_prominence_indices = np.argsort(prominences)[::-1]\n    \n    top2_indices_in_peak_list = sorted_prominence_indices[:2]\n    \n    p1_idx = peak_indices[top2_indices_in_peak_list[0]]\n    p2_idx = peak_indices[top2_indices_in_peak_list[1]]\n    \n    f_p1, mag_p1 = freqs_search[p1_idx], mags_search[p1_idx]\n    f_p2, mag_p2 = freqs_search[p2_idx], mags_search[p2_idx]\n    \n    # Condition 2: Check frequency separation\n    if np.abs(f_p1 - f_p2)  min_peak_sep_hz:\n        return False\n        \n    # Condition 3: Check valley depth\n    # Find the valley between the two peaks\n    start_idx = min(p1_idx, p2_idx)\n    end_idx = max(p1_idx, p2_idx)\n    \n    # The valley is the minimum magnitude strictly between the peaks\n    if end_idx > start_idx + 1:\n        valley_mag = np.min(mags_search[start_idx + 1 : end_idx])\n    else: # Peaks are adjacent samples, no valley between them\n        valley_mag = min(mags_search[start_idx], mags_search[end_idx])\n\n    valley_threshold = tau * min(mag_p1, mag_p2)\n    \n    if valley_mag > valley_threshold:\n        return False\n\n    # If all conditions pass, the peaks are resolved\n    return True\n\nsolve()\n```"
        },
        {
            "introduction": "在第一个练习理解了泄漏的原理之后，这个练习展示了一个实用的解决方案。学生将分析一个真实的神经科学信号模型——一个具有急剧起始点的事件相关电位（ERP），这种信号极易产生泄漏。通过比较标准矩形窗和Tukey窗所产生的谱泄漏，这个动手编程问题量化了锥形窗所带来的显著改善，并强化了加窗作为一种管理主瓣宽度和旁瓣抑制之间权衡的核心原则 ()。",
            "id": "4204150",
            "problem": "您的任务是在对具有急剧起始的事件相关电位 (ERP) 片段进行频域分析时，量化其频谱泄漏。考虑一个离散时间信号，它被建模为一个在零时刻有因果性急剧起始的阻尼正弦波，对于样本 $n \\in \\{0,1,\\dots,N-1\\}$，其定义由以下方程给出：\n$$\nx[n] = A \\, e^{-n / (\\tau f_s)} \\, \\sin\\left(2\\pi f_0 \\frac{n}{f_s}\\right),\n$$\n其中 $A$ 是振幅，$f_s$ 是采样频率（单位为赫兹），$f_0$ 是主振荡频率（单位为赫兹），$\\tau$ 是衰减时间常数（单位为秒）。正弦函数中的角度参数以弧度为单位。\n\n您需要计算应用 Tukey 窗（由锥度分数 $\\alpha \\in [0,1]$ 参数化）相对于矩形窗（等效于 $\\alpha = 0$ 的 Tukey 窗）所实现的频谱泄漏减少量。加窗操作对应于将 $x[n]$ 与 $w[n]$ 相乘，这在频域中表现为 $x[n]$ 和 $w[n]$ 频谱的卷积。此处，频谱泄漏在操作上定义为：离散傅里叶变换 (DFT) 的幅度平方能量中，位于以主振荡频率为中心的感兴趣频带之外的部分所占的比例。具体来说，令 $X_w[k]$ 表示加窗信号 $x[n] w[n]$ 的 DFT，令 $f[k]$ 表示 DFT 频率点（单位为赫兹）。感兴趣频带的半宽度定义为\n$$\nB = \\frac{2}{T},\n$$\n其中 $T = \\frac{N}{f_s}$ 是片段的持续时间（单位为秒）。感兴趣频带包含两个对称区间，宽度均为 $2B$，分别以 $+f_0$ 和 $-f_0$ 为中心（以适应实值信号的共轭对称性）。总频谱能量为\n$$\nP_{\\text{tot}} = \\sum_{k=0}^{N-1} \\left|X_w[k]\\right|^2,\n$$\n泄漏能量为\n$$\nP_{\\text{leak}} = \\sum_{k=0}^{N-1} \\left|X_w[k]\\right|^2 \\cdot \\mathbf{1}\\left(\\min\\left(\\left|f[k]-f_0\\right|,\\left|f[k]+f_0\\right|\\right)  B\\right),\n$$\n其中 $\\mathbf{1}(\\cdot)$ 是指示函数。泄漏比例则为\n$$\nL = \\frac{P_{\\text{leak}}}{P_{\\text{tot}}}.\n$$\n对于给定的 $(f_s, T, f_0, \\tau, \\alpha)$，使用矩形窗 $w_{\\text{rect}}[n] = 1$ 计算 $L_{\\text{rect}}$，并使用锥度分数为 $\\alpha$ 的 Tukey 窗计算 $L_{\\text{tukey}}$。最后，计算泄漏的相对减少量\n$$\nR = \\frac{L_{\\text{rect}} - L_{\\text{tukey}}}{L_{\\text{rect}}},\n$$\n结果表示为一个十进制数。如果 $L_{\\text{rect}} = 0$，则定义 $R = 0$。\n\n实现一个程序，对于下面测试套件中的每一组参数，该程序生成 $A = 1$ 的 ERP 片段 $x[n]$，应用矩形窗和 Tukey 窗，使用标准离散傅里叶变换计算 DFT，并输出 $R$ 作为四舍五入到 $6$ 位小数的浮点数。请使用以下测试套件，其中包括一般情况、边界条件和边缘情况：\n\n- 测试用例 1：$f_s = 1000$ Hz, $T = 0.5$ s, $f_0 = 20$ Hz, $\\tau = 0.08$ s, $\\alpha = 0.5$。\n- 测试用例 2：$f_s = 500$ Hz, $T = 1.0$ s, $f_0 = 37.3$ Hz, $\\tau = 0.1$ s, $\\alpha = 0.8$。\n- 测试用例 3：$f_s = 1000$ Hz, $T = 0.2$ s, $f_0 = 60$ Hz, $\\tau = 0.03$ s, $\\alpha = 0.2$。\n- 测试用例 4：$f_s = 2000$ Hz, $T = 0.25$ s, $f_0 = 100$ Hz, $\\tau = 0.05$ s, $\\alpha = 0.6$。\n- 测试用例 5 (边界条件)：$f_s = 1000$ Hz, $T = 0.5$ s, $f_0 = 20$ Hz, $\\tau = 0.08$ s, $\\alpha = 0.0$。\n\n所有时间和频率量必须分别以秒和赫兹为单位处理。角度以弧度为单位。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$），其中每个条目对应于相应测试用例的 $R$ 值，并四舍五入到 $6$ 位小数。",
            "solution": "该问题要求在分析瞬态振荡信号时量化频谱泄漏的减少量，这是神经科学等领域研究事件相关电位 (ERP) 的一项常见任务。分析过程首先要识别频谱泄漏的来源，为其定义一个清晰的度量标准，然后通过算法为两种不同的窗函数计算该度量，以找出相对的改进程度。\n\n所考虑的信号是一个具有急剧起始的离散时间阻尼正弦波，对于时间样本 $n \\in \\{0, 1, \\dots, N-1\\}$，其模型为：\n$$\nx[n] = A \\, e^{-n / (\\tau f_s)} \\, \\sin\\left(2\\pi f_0 \\frac{n}{f_s}\\right)\n$$\n此处，$A$ 是振幅，设为 $1$。样本数量为 $N = T f_s$，其中 $f_s$ 是采样频率，$T$ 是信号片段的总持续时间。信号以主频率 $f_0$ 振荡，并以时间常数 $\\tau$ 衰减。\n\n使用离散傅里叶变换 (DFT) 分析有限时长信号，在数学上等效于分析一个无限长信号乘以一个持续时间为 $T$ 的矩形窗。这个隐式矩形窗的急剧开始和结束会在频域中引入宽带伪影，这种现象被称为频谱泄漏。这可以通过傅里叶变换的卷积定理来理解：如果一个加窗信号是 $x_w[n] = x[n] \\cdot w[n]$，其频谱就是各自频谱的卷积，$X_w(f) = X(f) * W(f)$。矩形窗的频谱是一个 sinc 函数，其高幅度的旁瓣会将信号的真实频谱 $X(f)$ “涂抹”到整个频域。\n\n为减轻此效应，可以应用一个不同的窗函数 $w[n]$，其频谱具有较低的旁瓣，但代价是主瓣更宽。本问题比较了默认矩形窗 $w_{\\text{rect}}[n] = 1$ 与 Tukey 窗的性能，Tukey 窗是一个两端带有锥形余弦的矩形窗。Tukey 窗由锥度分数 $\\alpha$ 参数化。\n\n文中提供了一个严谨、定量的频谱泄漏定义。分析在频域中进行，使用加窗信号的 DFT $X_w[k]$。每个 DFT 频率点 $k$ 对应的频率由 $f[k] = k f_s / N$ 给出。首先，在已知的主频率 $f_0$ 周围定义一个感兴趣频带。该频带由两个对称区间 $[f_0 - B, f_0 + B]$ 和 $[-f_0 - B, -f_0 + B]$ 组成，其中半宽度 $B = 2/T$ 是根据矩形窗变换的主瓣宽度选择的。包含负频率带是必要的，因为实值信号的 DFT 具有共轭对称性。\n\n根据帕塞瓦尔定理，信号在频域中的总能量为：\n$$\nP_{\\text{tot}} = \\sum_{k=0}^{N-1} \\left|X_w[k]\\right|^2\n$$\n泄漏能量 $P_{\\text{leak}}$ 定义为总能量中落在感兴趣频带*之外*的部分：\n$$\nP_{\\text{leak}} = \\sum_{k=0}^{N-1} \\left|X_w[k]\\right|^2 \\cdot \\mathbf{1}\\left(\\min\\left(\\left|f[k]-f_0\\right|,\\left|f[k]+f_0\\right|\\right)  B\\right)\n$$\n其中 $\\mathbf{1}(\\cdot)$ 是指示函数。泄漏比例是比率 $L = P_{\\text{leak}} / P_{\\text{tot}}$。\n\n该解决方案通过以下算法实现：\n1.  对于给定的一组参数 $(f_s, T, f_0, \\tau, \\alpha)$，计算样本数 $N = \\text{int}(T f_s)$。\n2.  在时间索引 $n = 0, 1, \\dots, N-1$ 上生成离散信号 $x[n]$。\n3.  定义一个专用函数来计算给定窗口的泄漏比例 $L$。该函数执行以下步骤：\n    a. 它接收信号参数和一个加窗参数（在此例中为 $\\alpha$）。\n    b. 它生成长度为 $N$ 的相应窗口 $w[n]$。矩形窗对应于 $\\alpha=0$ 的 Tukey 窗。\n    c. 它计算加窗信号 $x_w[n] = x[n] \\cdot w[n]$。\n    d. 它计算加窗信号的 DFT $X_w[k]$。\n    e. 它确定每个 DFT 索引 $k$ 对应的频率点 $f[k]$。\n    f. 它通过分别对所有频率点和频带外频率点的 $X_w[k]$ 的幅度平方求和，来计算总能量 $P_{\\text{tot}}$ 和泄漏能量 $P_{\\text{leak}}$。\n    g. 它返回泄漏比例 $L$。\n4.  此函数被调用两次：一次使用 $\\alpha=0$ 来获取 $L_{\\text{rect}}$，另一次使用测试用例中指定的 $\\alpha$ 来获取 $L_{\\text{tukey}}$。\n5.  最终的度量，即泄漏的相对减少量 $R$，计算如下：\n$$\nR = \\frac{L_{\\text{rect}} - L_{\\text{tukey}}}{L_{\\text{rect}}}\n$$\n对 $L_{\\text{rect}} = 0$ 的特殊情况，通过设置 $R = 0$ 来处理。\n6.  对每个提供的测试用例重复此过程，并将得到的 $R$ 值按要求进行四舍五入和格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal.windows import tukey\n\ndef solve():\n    \"\"\"\n    Computes the fractional reduction in spectral leakage by applying a Tukey\n    window relative to a rectangular window for a given damped sinusoidal signal.\n    \"\"\"\n    # Test cases: (fs, T, f0, tau, alpha)\n    test_cases = [\n        (1000, 0.5, 20, 0.08, 0.5),\n        (500, 1.0, 37.3, 0.1, 0.8),\n        (1000, 0.2, 60, 0.03, 0.2),\n        (2000, 0.25, 100, 0.05, 0.6),\n        (1000, 0.5, 20, 0.08, 0.0),  # Boundary case where alpha = 0\n    ]\n\n    results = []\n\n    def calculate_leakage_fraction(fs, T, f0, tau, alpha_val):\n        \"\"\"\n        Calculates the spectral leakage fraction for the given signal parameters\n        and a Tukey window with a specific alpha.\n        \"\"\"\n        # Determine number of samples\n        N = int(fs * T)\n        if N == 0:\n            return 1.0  # No samples, so all energy is effectively leakage\n\n        # 1. Generate the base signal x[n]\n        A = 1.0  # Amplitude is fixed at 1\n        n = np.arange(N)\n        time_decay_factor = -n / (tau * fs)\n        angle = 2 * np.pi * f0 * n / fs\n        x = A * np.exp(time_decay_factor) * np.sin(angle)\n\n        # 2. Generate the window w[n]\n        # A rectangular window is a Tukey window with alpha = 0.\n        w = tukey(N, alpha=alpha_val, sym=True)\n\n        # 3. Apply the window to the signal\n        x_w = x * w\n\n        # 4. Compute the Discrete Fourier Transform (DFT)\n        X_w = np.fft.fft(x_w)\n\n        # 5. Compute the frequencies corresponding to the DFT bins\n        freq_bins = np.fft.fftfreq(N, d=1/fs)\n\n        # 6. Define the band-of-interest and calculate energies\n        B = 2.0 / T  # Band-of-interest half-width\n\n        # Squared magnitude of DFT coefficients\n        mag_sq_X_w = np.abs(X_w)**2\n\n        # Total energy (sum of squared magnitudes over all frequencies)\n        P_tot = np.sum(mag_sq_X_w)\n\n        if P_tot == 0:\n            return 0.0  # No signal, thus no leakage\n\n        # Identify frequency bins outside the band-of-interest\n        # A frequency f is outside if its distance to the nearest of f0 or -f0 is > B\n        is_outside_band = np.minimum(np.abs(freq_bins - f0), np.abs(freq_bins + f0)) > B\n        \n        # Leakage energy is the sum of energy in out-of-band bins\n        P_leak = np.sum(mag_sq_X_w[is_outside_band])\n\n        # 7. Calculate the leakage fraction\n        L = P_leak / P_tot\n        return L\n\n    for case in test_cases:\n        fs, T, f0, tau, alpha = case\n        \n        # Calculate leakage fraction for the rectangular window (alpha = 0)\n        l_rect = calculate_leakage_fraction(fs, T, f0, tau, 0.0)\n        \n        # Calculate leakage fraction for the Tukey window with the given alpha\n        l_tukey = calculate_leakage_fraction(fs, T, f0, tau, alpha)\n        \n        # Calculate the fractional reduction in leakage, R\n        if l_rect == 0:\n            R = 0.0\n        else:\n            R = (l_rect - l_tukey) / l_rect\n        \n        results.append(round(R, 6))\n\n    # Print the final results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}