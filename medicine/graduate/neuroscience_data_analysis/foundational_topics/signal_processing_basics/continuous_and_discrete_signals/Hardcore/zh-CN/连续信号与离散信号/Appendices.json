{
    "hands_on_practices": [
        {
            "introduction": "神经科学数字分析的第一步是将连续的脑电压波动转换为离散的数字。本练习旨在深入探讨这一转换过程的核心——量化，通过推导信号质量的理论上限，即信号量化噪声比（$SQNR$）。通过完成这个练习 ，你将对模数转换器（ADC）的位深度如何直接影响数据保真度，并为所有后续分析设定噪声基底有一个基本的理解。",
            "id": "4148626",
            "problem": "一个神经数据采集系统在校准运行时，对来自单个电极的细胞外电压波动进行数字化。其模拟前端产生一个正弦测试信号，其峰值幅度与模数转换器 (ADC) 的满量程范围相匹配，以便在尖峰排序前评估量化性能。该 ADC 是均匀且对称的，具有 $N$ 位的分辨率和 $\\pm V_{\\text{FS}}/2$ 的满量程输入范围，其中 $V_{\\text{FS}}$ 是总的峰峰值范围。假设使用以下模型和定义：\n1. 正弦输入为 $x(t)=A\\sin(2\\pi f_{0} t)$，其中 $A=V_{\\text{FS}}/2$（一个不发生削波的满量程正弦波）。\n2. ADC 应用均匀量化，步长为 $\\Delta=V_{\\text{FS}}/2^{N}$。\n3. 在加性白噪声 (AWN) 模型下，量化误差 $q(t)$ 被视为一个零均值、信号无关的随机过程，它在 $[-\\Delta/2,\\Delta/2]$ 上均匀分布，且与 $x(t)$ 不相关。\n\n仅从正弦波的均方根功率、均匀随机变量的方差以及信噪比的核心定义出发，推导该满量程正弦波的信号量化噪声比 (SQNR) 作为 $N$ 的函数的解析表达式（以分贝为单位）。最终答案需以分贝表示，并提供一个包含 $\\log_{10}$ 的单一闭式表达式；不要用数值近似代替常数。不存在其他噪声源或失真。最终答案必须是关于 $N$ 的精确解析表达式，且表达式框内不得包含单位。",
            "solution": "首先对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **输入信号**：一个正弦测试信号，$x(t)=A\\sin(2\\pi f_{0} t)$。\n- **信号幅度**：峰值幅度为 $A=V_{\\text{FS}}/2$，对应于一个不发生削波的满量程正弦波。$V_{\\text{FS}}$ 是总的峰峰值范围。\n- **ADC 特性**：模数转换器 (ADC) 是均匀且对称的，具有 $N$ 位的分辨率。\n- **ADC 输入范围**：满量程输入范围为 $\\pm V_{\\text{FS}}/2$。\n- **量化步长**：步长定义为 $\\Delta=V_{\\text{FS}}/2^{N}$。\n- **量化误差模型**：量化误差 $q(t)$ 被建模为一个加性白噪声 (AWN) 过程，具有以下特性：\n    - 零均值：$E[q(t)] = 0$。\n    - 分布：在区间 $[-\\Delta/2, \\Delta/2]$ 上均匀分布。\n    - 独立性：信号无关，且与 $x(t)$ 不相关。\n- **目标**：推导信号量化噪声比 (SQNR) 作为比特数 $N$ 的函数的解析表达式，以分贝 (dB) 为单位。\n- **约束**：推导必须从正弦波的均方根 (RMS) 功率、均匀随机变量的方差以及信噪比的核心定义出发。最终答案必须是包含 $\\log_{10}$ 的单一闭式表达式，且不得包含对常数的数值近似。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据。所提出的模型——一个满量程正弦波输入到一个均匀量化器，以及将量化误差近似为加性、均匀分布的白噪声——是数字信号处理和通信系统理论中的一个经典基础问题。这是用于确定理想 ADC 性能理论上限的标准方法。该问题是适定的，提供了推导唯一解所需的所有必要定义和约束（$x(t)$、$A$、$N$、$\\Delta$ 以及 $q(t)$ 的统计特性）。语言客观而精确。问题是完整的、一致的，且科学上是合理的。它没有违反任何无效性标准。\n\n### 步骤 3：结论与行动\n问题被判定为**有效**。将按要求推导解答。\n\n### 推导\n信号量化噪声比 (SQNR) 定义为信号功率 $P_S$ 与量化噪声功率 $P_Q$ 之比。以分贝 (dB) 表示，其表达式为：\n$$\n\\text{SQNR}_{\\text{dB}} = 10 \\log_{10}\\left(\\frac{P_S}{P_Q}\\right)\n$$\n我们现在将根据给定的条件推导 $P_S$ 和 $P_Q$ 的表达式。\n\n**1. 信号功率 ($P_S$)**\n输入信号是正弦波 $x(t) = A\\sin(2\\pi f_0 t)$。周期信号的功率是其均方值，即其均方根 (RMS) 值的平方。对于幅度为 $A$ 的正弦波，其 RMS 值为 $A/\\sqrt{2}$。因此，功率 $P_S$ 为：\n$$\nP_S = \\left(\\frac{A}{\\sqrt{2}}\\right)^2 = \\frac{A^2}{2}\n$$\n或者，根据平均功率在一个周期 $T_0 = 1/f_0$ 上的积分定义进行计算：\n$$\nP_S = \\frac{1}{T_0} \\int_{0}^{T_0} x^2(t) \\, dt = \\frac{1}{T_0} \\int_{0}^{T_0} A^2 \\sin^2(2\\pi f_0 t) \\, dt\n$$\n使用三角恒等式 $\\sin^2(\\theta) = \\frac{1 - \\cos(2\\theta)}{2}$：\n$$\nP_S = \\frac{A^2}{T_0} \\int_{0}^{T_0} \\frac{1 - \\cos(4\\pi f_0 t)}{2} \\, dt = \\frac{A^2}{2T_0} \\left[ t - \\frac{\\sin(4\\pi f_0 t)}{4\\pi f_0} \\right]_{0}^{T_0}\n$$\n$$\nP_S = \\frac{A^2}{2T_0} \\left( (T_0 - 0) - (0 - 0) \\right) = \\frac{A^2}{2}\n$$\n问题陈述该正弦波是“满量程”的，其峰值幅度为 $A = V_{\\text{FS}}/2$。将此代入信号功率的表达式中，得到：\n$$\nP_S = \\frac{(V_{\\text{FS}}/2)^2}{2} = \\frac{V_{\\text{FS}}^2/4}{2} = \\frac{V_{\\text{FS}}^2}{8}\n$$\n\n**2. 量化噪声功率 ($P_Q$)**\n量化误差 $q(t)$ 被建模为一个在区间 $[-\\Delta/2, \\Delta/2]$ 上均匀分布的随机变量。其概率密度函数 (PDF) $p(q)$ 为：\n$$\np(q) = \\begin{cases} \\frac{1}{\\Delta}  \\text{for } -\\frac{\\Delta}{2} \\le q \\le \\frac{\\Delta}{2} \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n噪声功率 $P_Q$ 是该随机变量的方差，$\\sigma_q^2 = E[q^2] - (E[q])^2$。由于问题陈述误差是零均值，$E[q]=0$，所以功率就是均方误差 $E[q^2]$。\n$$\nP_Q = \\sigma_q^2 = E[q^2] = \\int_{-\\infty}^{\\infty} q^2 p(q) \\, dq = \\int_{-\\Delta/2}^{\\Delta/2} q^2 \\frac{1}{\\Delta} \\, dq\n$$\n$$\nP_Q = \\frac{1}{\\Delta} \\left[ \\frac{q^3}{3} \\right]_{-\\Delta/2}^{\\Delta/2} = \\frac{1}{3\\Delta} \\left[ \\left(\\frac{\\Delta}{2}\\right)^3 - \\left(-\\frac{\\Delta}{2}\\right)^3 \\right]\n$$\n$$\nP_Q = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{8} + \\frac{\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( \\frac{2\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{4} \\right) = \\frac{\\Delta^2}{12}\n$$\n量化步长 $\\Delta$ 由 $\\Delta = V_{\\text{FS}}/2^N$ 给出。将此代入噪声功率的表达式中：\n$$\nP_Q = \\frac{1}{12} \\left( \\frac{V_{\\text{FS}}}{2^N} \\right)^2 = \\frac{V_{\\text{FS}}^2}{12 \\cdot (2^N)^2} = \\frac{V_{\\text{FS}}^2}{12 \\cdot 2^{2N}}\n$$\n\n**3. 信号量化噪声比 (SQNR)**\n现在我们构建信号功率与噪声功率之比：\n$$\n\\frac{P_S}{P_Q} = \\frac{V_{\\text{FS}}^2 / 8}{V_{\\text{FS}}^2 / (12 \\cdot 2^{2N})} = \\frac{V_{\\text{FS}}^2}{8} \\cdot \\frac{12 \\cdot 2^{2N}}{V_{\\text{FS}}^2}\n$$\n$V_{\\text{FS}}^2$ 项相互抵消，剩下：\n$$\n\\frac{P_S}{P_Q} = \\frac{12 \\cdot 2^{2N}}{8} = \\frac{3}{2} \\cdot 2^{2N}\n$$\n\n**4. 以分贝表示的 SQNR**\n最后，我们将此比率转换为分贝：\n$$\n\\text{SQNR}_{\\text{dB}} = 10 \\log_{10}\\left( \\frac{3}{2} \\cdot 2^{2N} \\right)\n$$\n使用对数性质 $\\log(ab) = \\log(a) + \\log(b)$ 和 $\\log(x^y) = y\\log(x)$：\n$$\n\\text{SQNR}_{\\text{dB}} = 10 \\left( \\log_{10}\\left(\\frac{3}{2}\\right) + \\log_{10}\\left(2^{2N}\\right) \\right)\n$$\n$$\n\\text{SQNR}_{\\text{dB}} = 10 \\log_{10}\\left(\\frac{3}{2}\\right) + 10 \\cdot (2N) \\log_{10}(2)\n$$\n$$\n\\text{SQNR}_{\\text{dB}} = 20 N \\log_{10}(2) + 10 \\log_{10}\\left(\\frac{3}{2}\\right)\n$$\n这就是根据要求从基本原理推导出的，满量程正弦波的 SQNR 作为比特数 $N$ 的函数的最终解析表达式。",
            "answer": "$$\n\\boxed{20 N \\log_{10}(2) + 10 \\log_{10}\\left(\\frac{3}{2}\\right)}\n$$"
        },
        {
            "introduction": "分析神经信号通常需要关注特定的频段，而这在较低的采样率下可以更高效地完成。本练习探讨了降采样（或称抽取）这一关键过程，以及为防止数据损坏所需采取的步骤。通过这个推导 ，你将掌握设计必要抗混叠滤波器的原理，确保重采样后的数据能准确反映潜在的神经动力学，而不会引入虚假的伪影。",
            "id": "4148600",
            "problem": "一个皮层局部场电位 (LFP) 时间序列以均匀采样率 $f_{s}$ (单位为 $\\mathrm{Hz}$) 进行采样。为了进行专注于慢波振荡的下游分析，您计划以一个整数因子 $M \\geq 2$ 对该离散时间信号进行抽取，从而产生一个新的采样序列，其采样率为 $f_{s}/M$。为避免在此抽取过程中因混叠引起的频谱失真，您将在降采样之前应用一个因果、稳定、线性时不变的低通抗混叠滤波器。假设该滤波器具有单调的幅频响应和有限宽度的过渡带，由一个相对于抽取后采样率 $f_{s}/M$ 的无量纲设计余量 $\\delta \\in (0, \\frac{1}{2})$ 来描述，这意味着通带边缘与混叠边界之间的距离为 $f_{s}/M$ 的 $\\delta$ 倍。\n\n仅从以下基础出发：\n\n- 奈奎斯特-香农采样定理指出，对于以速率 $f_{s}$ 采样的离散时间信号，只有当其连续时间频谱支撑局限于 $|f|  f_{s}/2$ 时，才能无混叠失真地重建。\n- 以整数因子 $M$ 进行抽取会将采样率从 $f_{s}$ 降低到 $f_{s}/M$，从而将奈奎斯特频率从 $f_{s}/2$ 降低到 $(f_{s}/2)/M$。\n\n推导以因子 $M$ 进行抽取时避免混叠所必需的频域条件，这些条件表示为对抽取前低通滤波器的通带和阻带边缘相对于 $f_{s}/M$ 的要求，并包含余量 $\\delta$。请以有序对 $\\left(f_{p}^{\\max}, f_{sb}^{\\min}\\right)$ 的形式给出您的最终答案，其中 $f_{p}^{\\max}$ 是允许的最大通带边缘频率，$f_{sb}^{\\min}$ 是防止抽取后发生混叠的允许的最小阻带边缘频率。请以 $\\mathrm{Hz}$ 为单位表示您的最终答案对。不需要进行数值近似；请提供精确的符号表达式。",
            "solution": "所述问题需要进行验证。\n\n### 步骤 1：提取已知条件\n-   初始均匀采样率：$f_s$ (单位为 $\\mathrm{Hz}$)。\n-   整数抽取因子：$M \\geq 2$。\n-   抽取后的新采样率：$f_s / M$。\n-   滤波器类型：因果、稳定、线性时不变低通抗混叠滤波器。\n-   滤波器幅频响应：单调，具有有限宽度的过渡带。\n-   无量纲设计余量：$\\delta \\in (0, \\frac{1}{2})$。\n-   设计余量定义：“通带边缘与混叠边界之间的距离为 $f_s/M$ 的 $\\delta$ 倍”。\n-   基础 1 (奈奎斯特-香农采样定理)：对于采样率 $f_s$，连续时间信号的频谱支撑必须在 $|f|  f_s/2$ 范围内以避免混叠。\n-   基础 2 (抽取效应)：以因子 $M$ 进行抽取会将采样率降低到 $f_s/M$，并将奈奎斯特频率降低到 $(f_s/2)/M$。\n-   目标：推导有序对 $\\left(f_{p}^{\\max}, f_{sb}^{\\min}\\right)$，其中 $f_{p}^{\\max}$ 是允许的最大通带边缘频率，$f_{sb}^{\\min}$ 是允许的最小阻带边缘频率，单位为 $\\mathrm{Hz}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据：**该问题牢固地植根于数字信号处理 (DSP) 的原理，特别是关于采样、混叠和用于抽取的滤波器设计。这些是工程学和应用物理学的核心概念。应用于局部场电位 (LFP) 分析是计算神经科学中一个标准且现实的场景。\n-   **适定性：**该问题提供了所有必要的变量 ($f_s$, $M$, $\\delta$) 和清晰的定义。目标明确，约束条件足以确定一个唯一且有意义的解。\n-   **客观性：**语言技术性强、精确，不含主观性或个人观点。\n-   **结论：**该问题没有科学上的不健全、模糊或矛盾之处。它是在指定领域内一个适定的、可形式化的问题。\n\n### 步骤 3：结论与行动\n问题有效。将推导解答。\n\n### 推导过程\n抗混叠滤波器的主要目标是防止在抽取的降采样阶段可能发生的频谱混叠。我们首先确定由新的、较低的采样率所施加的临界频率限制。\n\n设初始采样率为 $f_s$。信号分析受初始奈奎斯特频率 $f_N = f_s / 2$ 的限制。\n\n以整数因子 $M$ 进行抽取后，新的采样率变为 $f'_s = f_s/M$。根据奈奎斯特-香农采样定理，对于这个新的采样率 $f'_s$，被采样的信号必须被带限到新的奈奎斯特频率 $f'_N$ 以避免混叠。这个新的奈奎斯特频率是：\n$$f'_N = \\frac{f'_s}{2} = \\frac{f_s/M}{2} = \\frac{f_s}{2M}$$\n这个频率 $f_s/(2M)$ 代表了问题中提到的“混叠边界”。在降采样步骤之前，信号中任何等于或高于 $f'_N$ 的频率内容都将被混叠（折叠）到抽取后信号的频带 $[0, f'_N]$ 中，从而导致频谱失真。\n\n低通抗混叠滤波器的目的是在降采样发生前，充分衰减所有等于或高于此混叠边界的频率分量。一个实际的滤波器由通带边缘频率 $f_p$ 和阻带边缘频率 $f_{sb}$ 来表征。\n\n为了防止混叠，滤波器的阻带必须在混叠边界处或之前开始。这对阻带边缘频率 $f_{sb}$ 施加了以下条件：\n$$f_{sb} \\leq f'_N = \\frac{f_s}{2M}$$\n问题要求的是允许的最小阻带边缘频率 $f_{sb}^{\\min}$，这对应于刚好满足抗混叠要求的最有效滤波器设计。这种情况发生在阻带恰好在混叠边界处开始时。因此：\n$$f_{sb}^{\\min} = \\frac{f_s}{2M}$$\n\n接下来，我们确定允许的最大通带边缘频率 $f_{p}^{\\max}$。问题为此提供了一个特定约束：“通带边缘与混叠边界之间的距离为 $f_s/M$ 的 $\\delta$ 倍”。通带边缘 $f_p$ 与混叠边界 $f_s/(2M)$ 之间的间隔定义了滤波器的过渡带。我们可以将给定的约束形式化为一个方程：\n$$(\\text{aliasing boundary}) - (\\text{passband edge}) = \\delta \\times \\frac{f_s}{M}$$\n代入这些项，我们得到在给定最小阻带边缘 $f_{sb}^{\\min} = f_s/(2M)$ 的情况下，最大可能通带边缘 $f_{p}^{\\max}$ 的关系：\n$$f_{sb}^{\\min} - f_{p}^{\\max} = \\delta \\frac{f_s}{M}$$\n代入 $f_{sb}^{\\min}$ 的推导表达式：\n$$\\frac{f_s}{2M} - f_{p}^{\\max} = \\delta \\frac{f_s}{M}$$\n现在我们可以解出 $f_{p}^{\\max}$：\n$$f_{p}^{\\max} = \\frac{f_s}{2M} - \\delta \\frac{f_s}{M}$$\n提出公因式 $\\frac{f_s}{M}$ 可以得到一个更紧凑的表达式：\n$$f_{p}^{\\max} = \\frac{f_s}{M} \\left(\\frac{1}{2} - \\delta\\right)$$\n给定的条件 $\\delta \\in (0, 1/2)$ 确保了 $f_{p}^{\\max}$ 是一个正频率，并且严格小于 $f_{sb}^{\\min}$，这是具有有限非零过渡带宽的低通滤波器的必要条件。\n\n因此，所需的频域条件对为 $\\left(f_{p}^{\\max}, f_{sb}^{\\min}\\right)$。",
            "answer": "$$\\boxed{\\left( \\frac{f_s}{M} \\left( \\frac{1}{2} - \\delta \\right), \\frac{f_s}{2M} \\right)}$$"
        },
        {
            "introduction": "系统神经科学的一个核心目标是超越静态特性，理解大脑区域间动态的通信。这个综合性练习要求你构建一个完整的分析流程，用以测量时变相干性——一种衡量功能连接性的关键指标。通过实现这个算法 ，它融合了稳健的多窗谱估计与先进的移动块自举统计方法，你将掌握揭示神经交互如何随时间演变的实用技能。",
            "id": "4148557",
            "problem": "考虑两个连续时间过程 $x(t)$ 和 $y(t)$，它们代表从两个大脑区域记录的局部场电位。这些过程以采样频率 $f_s$ 进行均匀采样，得到离散时间序列 $x[n]$ 和 $y[n]$，其中 $n$ 是样本索引，$t = n / f_s$。您的任务是通过在短滑动窗口中计算的幅度平方相干性来估计目标振荡频率 $f_0$ 上的时变交互作用，并使用明确考虑数据中时间依赖性的置信区间来量化不确定性。目标是为每个窗口判断在 $f_0$ 处是否存在统计上显著的相干性。\n\n仅从离散时间傅里叶变换和谱密度的基本定义、卷积定理以及用于谱集中的正交锥削概念出发，推导并实现一个算法，该算法：\n- 使用滑动窗口方法，窗口时长固定为 $T_w$，跳跃大小为 $T_h$，并在每个窗口内应用 $K$ 个时间带宽积为 $NW$ 的正交离散扁长球状序列（DPSS）锥削，以生成多锥削谱估计。\n- 通过组合 $x[n]$ 和 $y[n]$ 的加窗和锥削后的谱，计算每个窗口中 $f_0$ 处的幅度平方相 coherent性。\n- 通过保留时间依赖性的移动块自举法，为每个窗口中的相干性构建一个 $(1 - \\alpha)$ 置信区间。块长度必须根据基于自相关时间的有原则标准，从该窗口数据的经验自相关函数中选择，并且必须有放回地对块进行重采样以形成自举复制样本。相同的块索引必须应用于 $x[n]$ 和 $y[n]$ 以保持其联合结构。\n- 通过将自举置信区间的下界与一个基于多锥削估计中有效平均谱数量的、理论上合理的相干性零假设阈值进行比较来确定显著性。决策规则必须在您的解决方案中从第一性原理推导得出。\n\n您将在已知 $f_0$ 处时变耦合的真实基准的合成数据上测试您的程序。对于每个测试用例，您的程序必须输出在指定的“耦合区间”内，根据上述决策规则被判定为相干性显著的窗口所占的比例。将每个比例表示为小数。角度（如果存在）应理解为弧度。\n\n测试套件由三组参数集组成。在所有情况下，信号都是由一个1阶自回归噪声过程 (AR(1)) 和一个仅在耦合区间内出现的频率为 $f_0$ 的正弦波之和生成的。$x[n]$ 的 AR(1) 过程为 $x_{\\text{noise}}[n] = \\phi_x \\, x_{\\text{noise}}[n-1] + \\varepsilon_x[n]$，$y[n]$ 的过程类似，其中 $\\varepsilon_x[n]$ 和 $\\varepsilon_y[n]$ 是独立同分布、零均值、具有指定标准差的高斯新息。在耦合情况下，正弦分量共享相同的随机相位。所有时长单位为秒，采样频率单位为赫兹。\n\n- 测试用例1（理想路径）：\n  - $f_s = 200$，总时长 $T = 10$，目标频率 $f_0 = 20$。\n  - 窗口时长 $T_w = 1$，跳跃 $T_h = 0.5$。\n  - 多锥削参数: $NW = 2.5$，$K = 5$。\n  - AR(1) 参数: $\\phi_x = 0.8$，$\\phi_y = 0.8$，新息标准差 $\\sigma_x = 0.5$，$\\sigma_y = 0.5$。\n  - 耦合区间：$[4, 8)$，在此期间 $x[n]$ 和 $y[n]$ 都包含频率为 $f_0$、振幅为 $a_x = 1.0$ 和 $a_y = 1.0$、共享随机相位的正弦波。\n  - 置信水平：$1 - \\alpha = 0.95$。\n  - 自举复制样本数：$R = 200$。\n\n- 测试用例2（无耦合，边界条件）：\n  - $f_s = 200$, $T = 10$, $f_0 = 20$.\n  - $T_w = 1$, $T_h = 0.5$.\n  - $NW = 2.5$, $K = 5$.\n  - $\\phi_x = 0.8$, $\\phi_y = 0.8$, $\\sigma_x = 0.5$, $\\sigma_y = 0.5$.\n  - 耦合区间：$[4, 8)$，但 $y[n]$ 不包含频率为 $f_0$ 的正弦波（即 $a_y = 0$），而 $x[n]$ 在此区间内包含一个频率为 $f_0$、振幅为 $a_x = 1.0$ 的正弦波。\n  - $1 - \\alpha = 0.95$, $R = 200$.\n\n- 测试用例3（边缘情况：更短的窗口和更高的噪声）：\n  - $f_s = 200$, $T = 10$, $f_0 = 20$.\n  - $T_w = 0.8$, $T_h = 0.4$.\n  - $NW = 2.5$, $K = 5$.\n  - $\\phi_x = 0.8$, $\\phi_y = 0.8$, $\\sigma_x = 1.0$, $\\sigma_y = 1.0$.\n  - 耦合区间：$[5, 7)$，在此区间内有 $a_x = 0.7$，$a_y = 0.7$ 和共享的随机相位。\n  - $1 - \\alpha = 0.95$, $R = 200$.\n\n您的程序必须：\n- 根据上述规范生成信号。\n- 使用 $T_w$ 和 $T_h$ 将数据划分为滑动窗口。\n- 在每个窗口中，使用移动块自举法计算 $f_0$ 处的多锥削相干性和一个 $(1-\\alpha)$ 置信区间，其中块长度由窗口的自相关时间确定。使用推导出的相干性零假设阈值和置信区间下界来判断每个窗口的显著性。\n- 对于每个测试用例，报告其中心时间落在指定耦合区间内且被判定为显著的窗口的比例。\n\n最终输出格式：您的程序应生成单行输出，其中包含三个结果，格式为方括号括起来的逗号分隔列表（例如，“[$r_1$, $r_2$, $r_3$]”）。不应打印任何其他文本。除了无量纲的分数外，输出中没有物理单位。",
            "solution": "该问题要求开发并实现一个统计程序，用于检测两个神经生理信号 $x(t)$ 和 $y(t)$ 之间的时变功能连接。该方法涉及在滑动窗口内进行多锥削相干性估计，通过移动块自举法进行不确定性量化，并进行正式的显著性检验。我们将从第一性原理推导必要的组成部分。\n\n让两个连续时间信号 $x(t)$ 和 $y(t)$ 以频率 $f_s$ 采样，得到离散时间序列 $x[n]$ 和 $y[n]$，其中 $t = n/f_s$。分析在时长为 $T_w$（长度为 $N_w = \\text{round}(T_w f_s)$ 个样本）的滑动窗口中进行，跳跃步长为 $T_h$（长度为 $N_h = \\text{round}(T_h f_s)$ 个样本）。在每个窗口内，我们分析数据段，记为 $x_w[n]$ 和 $y_w[n]$，$n \\in \\{0, 1, \\dots, N_w-1\\}$。\n\n### 1. 多锥削谱估计\n\n相干性分析的基础是功率谱密度和互谱密度的估计。多锥削方法缓解了谱估计中固有的偏差-方差权衡问题，特别是谱泄漏问题。\n\n**1.1. 锥削傅里叶变换（特征系数）**\n长度为 $N_w$ 的有限序列 $z[n]$ 的离散时间傅里叶变换（DTFT）由下式给出\n$$ \\tilde{Z}(f) = \\sum_{n=0}^{N_w-1} z[n] e^{-i 2\\pi f n / f_s} $$\n其中 $f$ 是频率。使用单个矩形窗（即无锥削）的标准谱估计会遭受显著的谱泄漏。锥削是在进行傅里叶变换之前，将数据乘以一个在边缘平滑地趋于零的窗函数 $v[n]$，即 $z_v[n] = v[n] z[n]$。\n\n多锥削方法使用一组 $K$ 个正交锥削 $\\{v_k[n]\\}_{k=0}^{K-1}$，这些锥削被设计为在半宽为 $W$ 的频带内最优集中。这些锥削的规范选择是离散扁长球状序列（DPSS），或 Slepian 序列。这些是与期望频带相关的托普利茨矩阵的最大特征值所对应的特征向量。给定时间带宽积 $NW$（在我们的离散情况下，参数为 $N_w W$），大约有 $2 N_w W$ 个这样的锥削，其能量几乎完全包含在感兴趣的频带内，从而最小化了来自该频带之外频率的泄漏。\n\n对于每个数据段 $x_w[n]$ 和 $y_w[n]$ 以及每个锥削 $v_k[n]$，我们计算目标频率 $f_0$ 处的第 $k$ 个特征系数：\n$$ \\tilde{x}_k(f_0) = \\sum_{n=0}^{N_w-1} v_k[n] x_w[n] e^{-i 2\\pi f_0 n / f_s} $$\n$$ \\tilde{y}_k(f_0) = \\sum_{n=0}^{N_w-1} v_k[n] y_w[n] e^{-i 2\\pi f_0 n / f_s} $$\n这些 $\\tilde{x}_k(f_0)$ 和 $\\tilde{y}_k(f_0)$ 是复数值，代表通过第 $k$ 个锥削看到的 $f_0$ 处数据的谱内容。\n\n**1.2. 谱密度估计**\n自谱（$S_{xx}, S_{yy}$）和互谱（$S_{xy}$）的多锥削估计是通过对来自 $K$ 个锥削的信息进行平均得到的。\n$x$ 在 $f_0$ 处的自谱密度估计为其特征系数的平均功率：\n$$ \\hat{S}_{xx}(f_0) = \\frac{1}{K} \\sum_{k=0}^{K-1} |\\tilde{x}_k(f_0)|^2 = \\frac{1}{K} \\sum_{k=0}^{K-1} \\tilde{x}_k(f_0) \\tilde{x}_k^*(f_0) $$\n对于 $y$ 也是类似的：\n$$ \\hat{S}_{yy}(f_0) = \\frac{1}{K} \\sum_{k=0}^{K-1} |\\tilde{y}_k(f_0)|^2 $$\n互谱密度是通过对特征系数的互积进行平均来估计的：\n$$ \\hat{S}_{xy}(f_0) = \\frac{1}{K} \\sum_{k=0}^{K-1} \\tilde{x}_k(f_0) \\tilde{y}_k^*(f_0) $$\n其中 $(\\cdot)^*$ 表示复共轭。\n\n### 2. 幅度平方相干性\n\n幅度平方相干性 $C_{xy}(f)$ 衡量两个信号在特定频率 $f$ 处的线性相关性。其定义为：\n$$ C_{xy}(f) = \\frac{|S_{xy}(f)|^2}{S_{xx}(f) S_{yy}(f)} $$\n$C_{xy}(f)$ 的值界于 $0$（无线性相关）和 $1$（完全线性相关）之间。\n\n使用我们的多锥削谱估计，频率 $f_0$ 处的样本相干性为：\n$$ \\hat{C}_{xy}(f_0) = \\frac{|\\hat{S}_{xy}(f_0)|^2}{\\hat{S}_{xx}(f_0) \\hat{S}_{yy}(f_0)} = \\frac{|\\sum_{k=0}^{K-1} \\tilde{x}_k(f_0) \\tilde{y}_k^*(f_0)|^2}{\\left(\\sum_{k=0}^{K-1} |\\tilde{x}_k(f_0)|^2\\right) \\left(\\sum_{k=0}^{K-1} |\\tilde{y}_k(f_0)|^2\\right)} $$\n注意因子 $1/K$ 会消掉。\n\n### 3. 显著性检验与置信区间\n\n为了确定观测到的相干性值是否在统计上显著，我们需要一个零假设和一个计算置信区间的过程。\n\n**3.1. 零假设与显著性阈值**\n零假设 $H_0$ 是两个过程在 $f_0$ 处是真正不相干的，即 $C_{xy}(f_0) = 0$。在 $H_0$ 下，并假设特征系数是近似独立同分布的复高斯随机变量，估计的相干性 $\\hat{C}_{xy}(f_0)$ 服从一个已知分布。对于使用 $K$ 个锥削的多锥削估计，被平均的独立谱样本数量有效地为 $K$。在零假设下，观测到样本相干性值大于某个值 $\\hat{C}$ 的概率由下式给出：\n$$ P(\\hat{C}_{xy}(f_0) > \\hat{C} | H_0) = (1 - \\hat{C})^{K-1} $$\n为了找到在显著性水平 $\\alpha$ 下的阈值，我们寻找值 $C_{thresh}$，使得偶然超过它的概率为 $\\alpha$：\n$$ \\alpha = (1 - C_{thresh})^{K-1} $$\n解出 $C_{thresh}$ 得到理论上合理的零假设阈值：\n$$ C_{thresh} = 1 - \\alpha^{1/(K-1)} $$\n问题中指定的决策规则是，如果一个 $(1-\\alpha)$ 置信区间的下界超过此阈值，则判定相干性为显著。\n\n**3.2. 用于置信区间的移动块自举法**\n关于相干性置信区间的标准方法通常假设谱估计（特征系数）的独立性，如果底层过程不是白噪声，这个假设可能会被违反。问题规定对每个窗口内的原始时间序列数据使用移动块自举法，以构建一个对时间相关性具有鲁棒性的置信区间。\n\n单个窗口的算法如下：\n1.  **确定块长度 ($L$)**：自举法必须保留数据的时间依赖结构。这种依赖的长度从经验自相关函数（ACF）中估计。对于数据段 $x_w[n]$，我们计算其 ACF $\\rho_x(\\tau)$。自相关时间 $\\tau_{ac}$ 是过程记忆的一种度量。我们将其定义为 ACF 幅度降至或低于 $1/e$ 的第一个滞后 $\\tau$。\n    $$ \\tau_x = \\min\\{\\tau > 0 \\: : \\: |\\rho_x(\\tau)| \\le 1/e\\} $$\n    我们对 $x_w[n]$ 和 $y_w[n]$ 都进行此计算以得到 $\\tau_x$ 和 $\\tau_y$。块长度的一个保守选择是 $L = \\max(1, \\lfloor \\max(\\tau_x, \\tau_y) \\rfloor)$。这确保了块足够长，能够捕捉两个信号中的主要时间相关性。\n\n2.  **生成自举复制样本**：对于 $r = 1, \\dots, R$：\n    a. 创建一个长度为 $N_w$ 的自举时间序列 $(x_w^{*,r}, y_w^{*,r})$。这是通过首先从原始加窗数据 $(x_w, y_w)$ 中定义一组 $N_w - L + 1$ 个长度为 $L$ 的重叠块来完成的。\n    b. 我们*有放回地*抽取 $B = \\lceil N_w / L \\rceil$ 个这样的块。至关重要的是，对 $x_w$ 和 $y_w$ 使用相同的随机块索引，以保留它们的联合时间结构。\n    c. 将这 $B$ 个块拼接起来，形成一个长度为 $B \\times L$ 的新时间序列，然后将其截断到原始窗口长度 $N_w$。这个新序列 $(x_w^{*,r}, y_w^{*,r})$ 就是一个自举复制样本。\n\n3.  **计算自举分布**：对于每个自举复制样本，我们使用与原始数据完全相同的过程计算多锥削相干性估计 $\\hat{C}^{*,r}_{xy}(f_0)$。这个过程产生一个包含 $R$ 个自举相干性值的分布，即 $\\{\\hat{C}^{*,r}_{xy}(f_0)\\}_{r=1}^R$。\n\n4.  **构建置信区间**：这个经验分布可作为相干性估计量的抽样分布的近似。$(1-\\alpha)$ 百分位数置信区间是通过取排序后的自举分布的分位数形成的。下界 $CI_{lower}$ 是处于 $100 \\cdot (\\alpha/2)$ 百分位数的值。\n\n### 4. 最终决策规则与输出\n\n对于中心时间落在指定 `coupling_interval` 内的每个窗口：\n1.  如上所述，计算 $\\hat{C}_{xy}(f_0)$ 的 $(1-\\alpha)$ 置信区间。\n2.  获得置信下界 $CI_{lower}$。\n3.  计算零假设阈值 $C_{thresh} = 1 - \\alpha^{1/(K-1)}$。\n4.  如果 $CI_{lower} > C_{thresh}$，则宣布该窗口中的相干性在统计上是显著的。\n\n每个测试用例的最终输出是在耦合区间内被宣布为显著的窗口所占的比例。此过程集成了鲁棒谱估计、非参数不确定性量化和一个有原则的统计检验。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import windows, lfilter\n\ndef solve():\n    \"\"\"\n    Main function to run the time-varying coherence analysis for all test cases.\n    \"\"\"\n    # Set random seed for reproducibility of data generation and bootstrap\n    np.random.seed(0)\n\n    test_cases = [\n        # Test Case 1: Happy path with coupling\n        {'fs': 200, 'T': 10, 'f0': 20, 'Tw': 1, 'Th': 0.5, 'NW': 2.5, 'K': 5,\n         'phi_x': 0.8, 'phi_y': 0.8, 'sigma_x': 0.5, 'sigma_y': 0.5,\n         'coupling_interval': [4, 8], 'ax': 1.0, 'ay': 1.0, 'coupled': True,\n         'alpha': 0.05, 'R': 200},\n        # Test Case 2: No coupling\n        {'fs': 200, 'T': 10, 'f0': 20, 'Tw': 1, 'Th': 0.5, 'NW': 2.5, 'K': 5,\n         'phi_x': 0.8, 'phi_y': 0.8, 'sigma_x': 0.5, 'sigma_y': 0.5,\n         'coupling_interval': [4, 8], 'ax': 1.0, 'ay': 0.0, 'coupled': False,\n         'alpha': 0.05, 'R': 200},\n        # Test Case 3: Edge case, shorter windows, higher noise\n        {'fs': 200, 'T': 10, 'f0': 20, 'Tw': 0.8, 'Th': 0.4, 'NW': 2.5, 'K': 5,\n         'phi_x': 0.8, 'phi_y': 0.8, 'sigma_x': 1.0, 'sigma_y': 1.0,\n         'coupling_interval': [5, 7], 'ax': 0.7, 'ay': 0.7, 'coupled': True,\n         'alpha': 0.05, 'R': 200},\n    ]\n\n    results = []\n    e_val = 1.0 / np.e\n\n    for params in test_cases:\n        fs, T, f0 = params['fs'], params['T'], params['f0']\n        Tw, Th, NW, K = params['Tw'], params['Th'], params['NW'], params['K']\n        phi_x, phi_y, sigma_x, sigma_y = params['phi_x'], params['phi_y'], params['sigma_x'], params['sigma_y']\n        c_int, ax, ay, coupled = params['coupling_interval'], params['ax'], params['ay'], params['coupled']\n        alpha, R = params['alpha'], params['R']\n\n        # 1. Generate Signals\n        N = int(T * fs)\n        t = np.arange(N) / fs\n        \n        # AR(1) noise\n        epsilon_x = np.random.normal(0, sigma_x, N)\n        epsilon_y = np.random.normal(0, sigma_y, N)\n        x_noise = lfilter([1], [1, -phi_x], epsilon_x)\n        y_noise = lfilter([1], [1, -phi_y], epsilon_y)\n        \n        # Sinusoidal component\n        x_sig = np.zeros(N)\n        y_sig = np.zeros(N)\n        \n        start_sample = int(c_int[0] * fs)\n        end_sample = int(c_int[1] * fs)\n        \n        phase = np.random.uniform(0, 2 * np.pi)\n        phase_y = phase if coupled else np.random.uniform(0, 2 * np.pi)\n\n        x_sig[start_sample:end_sample] = ax * np.sin(2 * np.pi * f0 * t[start_sample:end_sample] + phase)\n        y_sig[start_sample:end_sample] = ay * np.sin(2 * np.pi * f0 * t[start_sample:end_sample] + phase_y)\n        \n        x = x_noise + x_sig\n        y = y_noise + y_sig\n\n        # 2. Window and Analysis Parameters\n        Nw = int(Tw * fs)\n        Nh = int(Th * fs)\n        \n        # Pre-compute tapers and DFT vector\n        tapers = windows.dpss(Nw, NW, K)\n        dft_vec = np.exp(-1j * 2 * np.pi * f0 * np.arange(Nw) / fs)\n\n        def compute_coherence(data_x, data_y, tapers_in, dft_vec_in):\n            dft_x_k = (data_x * tapers_in).dot(dft_vec_in)\n            dft_y_k = (data_y * tapers_in).dot(dft_vec_in)\n            \n            Sxy = np.sum(dft_x_k * np.conj(dft_y_k))\n            Sxx = np.sum(dft_x_k * np.conj(dft_x_k))\n            Syy = np.sum(dft_y_k * np.conj(dft_y_k))\n            \n            if Sxx == 0 or Syy == 0:\n                return 0.0\n            \n            return np.abs(Sxy)**2 / (Sxx * Syy)\n\n        # 3. Main Loop over Windows\n        window_starts = np.arange(0, N - Nw + 1, Nh)\n        significant_count = 0\n        coupling_windows_count = 0\n\n        for start in window_starts:\n            end = start + Nw\n            window_center_time = (start + Nw / 2) / fs\n            \n            if not (c_int[0] = window_center_time  c_int[1]):\n                continue\n            \n            coupling_windows_count += 1\n            \n            x_w = x[start:end]\n            y_w = y[start:end]\n            \n            # Moving Block Bootstrap\n            # a. Determine block length L\n            def get_block_len(series):\n                mean_subtracted = series - np.mean(series)\n                acf = np.correlate(mean_subtracted, mean_subtracted, mode='full')\n                acf = acf[acf.size // 2:]\n                if acf[0] == 0: return int(Nw**0.5) # Fallback\n                acf /= acf[0]\n                \n                crossings = np.where(np.abs(acf) = e_val)[0]\n                tau = crossings[0] if len(crossings) > 0 else int(Nw**0.5) # Fallback\n                return max(1, tau)\n\n            L = max(get_block_len(x_w), get_block_len(y_w))\n            \n            # b. Bootstrap replicates\n            num_blocks_to_draw = int(np.ceil(Nw / L))\n            block_indices = np.arange(Nw - L + 1)\n            \n            bootstrap_coherences = np.zeros(R)\n            for i in range(R):\n                # Resample block indices\n                rand_indices = np.random.choice(block_indices, size=num_blocks_to_draw, replace=True)\n                \n                # Create bootstrap time series\n                x_w_star = np.concatenate([x_w[j:j+L] for j in rand_indices])[:Nw]\n                y_w_star = np.concatenate([y_w[j:j+L] for j in rand_indices])[:Nw]\n                \n                bootstrap_coherences[i] = compute_coherence(x_w_star, y_w_star, tapers, dft_vec)\n\n            # c. Construct CI\n            ci_lower_bound = np.percentile(bootstrap_coherences, 100 * alpha / 2)\n\n            # d. Decision\n            C_thresh = 1 - alpha**(1 / (K - 1))\n            if ci_lower_bound > C_thresh:\n                significant_count += 1\n        \n        fraction = significant_count / coupling_windows_count if coupling_windows_count > 0 else 0\n        results.append(fraction)\n\n    print(f\"[{','.join(f'{r:.16f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}