{
    "hands_on_practices": [
        {
            "introduction": "对神经数据的任何分析都始于其数字化过程。将连续的模拟电压转换为离散数字序列的这一过程并非完美，会引入一种称为量化噪声的误差。本练习旨在探索模数转换器（ADC）分辨率（以比特 $N$ 为单位）与最大可能信噪比（SQNR）之间的基本关系。通过从第一性原理出发，为一个理想化的正弦信号推导出这种关系，您将对数据采集的核心原则获得深刻的定量理解：每增加一个分辨率比特，都能显著提高信号的保真度。",
            "id": "4148626",
            "problem": "一个神经数据采集系统在校准运行期间，对来自单个电极的细胞外电压波动进行数字化。其模拟前端产生一个正弦测试信号，其峰值振幅与模数转换器（ADC）的全量程范围相匹配，以便在尖峰排序前评估量化性能。该 ADC 是均匀且对称的，具有 $N$ 位的分辨率和 $\\pm V_{\\text{FS}}/2$ 的全量程输入范围，其中 $V_{\\text{FS}}$ 是总的峰峰值范围。假设以下模型和定义：\n1. 正弦输入为 $x(t)=A\\sin(2\\pi f_{0} t)$，其中 $A=V_{\\text{FS}}/2$（一个不发生削波的全量程正弦波）。\n2. ADC 应用均匀量化，量化步长为 $\\Delta=V_{\\text{FS}}/2^{N}$。\n3. 在加性白噪声（AWN）模型下，量化误差 $q(t)$ 被视为一个零均值、与信号无关的随机过程，其在 $[-\\Delta/2,\\Delta/2]$ 上均匀分布，且与 $x(t)$ 不相关。\n\n仅从正弦波的均方根功率、均匀分布随机变量的方差以及信噪比的核心定义出发，推导该全量程正弦波的信号量化噪声比（SQNR）关于 $N$ 的解析表达式（以分贝为单位）。最终答案需以分贝表示，并提供一个包含 $\\log_{10}$ 的单一闭合形式表达式；不要用数值近似代替常数。不存在其他噪声或失真源。最终答案必须是关于 $N$ 的精确解析表达式，并且表达式框内不得包含单位。",
            "solution": "首先对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- **输入信号**：一个正弦测试信号，$x(t)=A\\sin(2\\pi f_{0} t)$。\n- **信号振幅**：峰值振幅为 $A=V_{\\text{FS}}/2$，对应一个不发生削波的全量程正弦波。$V_{\\text{FS}}$ 是总的峰峰值范围。\n- **ADC 特性**：模数转换器（ADC）是均匀且对称的，具有 $N$ 位的分辨率。\n- **ADC 输入范围**：全量程输入范围为 $\\pm V_{\\text{FS}}/2$。\n- **量化步长**：步长定义为 $\\Delta=V_{\\text{FS}}/2^{N}$。\n- **量化误差模型**：量化误差 $q(t)$ 被建模为一个具有以下特性的加性白噪声（AWN）过程：\n    - 零均值：$E[q(t)] = 0$。\n    - 分布：在区间 $[-\\Delta/2, \\Delta/2]$ 上均匀分布。\n    - 独立性：与信号无关，且与 $x(t)$ 不相关。\n- **目标**：推导信号量化噪声比（SQNR）关于比特数 $N$ 的解析表达式，单位为分贝（dB）。\n- **约束条件**：推导必须从正弦波的均方根（RMS）功率、均匀分布随机变量的方差以及信噪比的核心定义开始。最终答案必须是包含 $\\log_{10}$ 的单一闭合形式表达式，且不得包含常数的数值近似。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据。所提出的模型——一个全量程正弦输入到均匀量化器，以及将量化误差近似为加性、均匀分布的白噪声——是数字信号处理和通信系统理论中的一个典型且基本的问题。这是一种用于确定理想 ADC 性能理论上限的标准方法。该问题是适定的（well-posed），提供了推导唯一解所需的所有必要定义和约束条件（$x(t)$、$A$、$N$、$\\Delta$ 以及 $q(t)$ 的统计特性）。语言客观而精确。该问题是完整的、一致的，且科学上是合理的。它没有违反任何无效性标准。\n\n### 步骤3：结论与行动\n该问题被判定为 **有效**。将按要求推导解答。\n\n### 推导过程\n信号量化噪声比（SQNR）定义为信号功率 $P_S$ 与量化噪声功率 $P_Q$ 之比。以分贝（dB）表示，其表达式为：\n$$\n\\text{SQNR}_{\\text{dB}} = 10 \\log_{10}\\left(\\frac{P_S}{P_Q}\\right)\n$$\n我们现在将根据给定的条件推导 $P_S$ 和 $P_Q$ 的表达式。\n\n**1. 信号功率 ($P_S$)**\n输入信号是一个正弦波 $x(t) = A\\sin(2\\pi f_0 t)$。周期信号的功率是其均方值，也就是其均方根（RMS）值的平方。对于振幅为 $A$ 的正弦波，其 RMS 值为 $A/\\sqrt{2}$。因此，功率 $P_S$ 为：\n$$\nP_S = \\left(\\frac{A}{\\sqrt{2}}\\right)^2 = \\frac{A^2}{2}\n$$\n或者，可以通过在一个周期 $T_0 = 1/f_0$ 内对平均功率的积分定义进行计算：\n$$\nP_S = \\frac{1}{T_0} \\int_{0}^{T_0} x^2(t) \\, dt = \\frac{1}{T_0} \\int_{0}^{T_0} A^2 \\sin^2(2\\pi f_0 t) \\, dt\n$$\n使用三角恒等式 $\\sin^2(\\theta) = \\frac{1 - \\cos(2\\theta)}{2}$：\n$$\nP_S = \\frac{A^2}{T_0} \\int_{0}^{T_0} \\frac{1 - \\cos(4\\pi f_0 t)}{2} \\, dt = \\frac{A^2}{2T_0} \\left[ t - \\frac{\\sin(4\\pi f_0 t)}{4\\pi f_0} \\right]_{0}^{T_0}\n$$\n$$\nP_S = \\frac{A^2}{2T_0} \\left( (T_0 - 0) - (0 - 0) \\right) = \\frac{A^2}{2}\n$$\n问题陈述该正弦波是“全量程”的，峰值振幅为 $A = V_{\\text{FS}}/2$。将此代入信号功率的表达式中，得到：\n$$\nP_S = \\frac{(V_{\\text{FS}}/2)^2}{2} = \\frac{V_{\\text{FS}}^2/4}{2} = \\frac{V_{\\text{FS}}^2}{8}\n$$\n\n**2. 量化噪声功率 ($P_Q$)**\n量化误差 $q(t)$ 被建模为一个在区间 $[-\\Delta/2, \\Delta/2]$ 上均匀分布的随机变量。其概率密度函数（PDF）$p(q)$ 为：\n$$\np(q) = \\begin{cases} \\frac{1}{\\Delta}  \\text{for } -\\frac{\\Delta}{2} \\le q \\le \\frac{\\Delta}{2} \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n噪声功率 $P_Q$ 是该随机变量的方差，即 $\\sigma_q^2 = E[q^2] - (E[q])^2$。由于问题陈述误差是零均值的，即 $E[q]=0$，因此功率就是均方误差 $E[q^2]$。\n$$\nP_Q = \\sigma_q^2 = E[q^2] = \\int_{-\\infty}^{\\infty} q^2 p(q) \\, dq = \\int_{-\\Delta/2}^{\\Delta/2} q^2 \\frac{1}{\\Delta} \\, dq\n$$\n$$\nP_Q = \\frac{1}{\\Delta} \\left[ \\frac{q^3}{3} \\right]_{-\\Delta/2}^{\\Delta/2} = \\frac{1}{3\\Delta} \\left[ \\left(\\frac{\\Delta}{2}\\right)^3 - \\left(-\\frac{\\Delta}{2}\\right)^3 \\right]\n$$\n$$\nP_Q = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{8} + \\frac{\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( \\frac{2\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{4} \\right) = \\frac{\\Delta^2}{12}\n$$\n量化步长 $\\Delta$ 已知为 $\\Delta = V_{\\text{FS}}/2^N$。将此代入噪声功率的表达式中：\n$$\nP_Q = \\frac{1}{12} \\left( \\frac{V_{\\text{FS}}}{2^N} \\right)^2 = \\frac{V_{\\text{FS}}^2}{12 \\cdot (2^N)^2} = \\frac{V_{\\text{FS}}^2}{12 \\cdot 2^{2N}}\n$$\n\n**3. 信号量化噪声比 (SQNR)**\n现在我们计算信号功率与噪声功率之比：\n$$\n\\frac{P_S}{P_Q} = \\frac{V_{\\text{FS}}^2 / 8}{V_{\\text{FS}}^2 / (12 \\cdot 2^{2N})} = \\frac{V_{\\text{FS}}^2}{8} \\cdot \\frac{12 \\cdot 2^{2N}}{V_{\\text{FS}}^2}\n$$\n$V_{\\text{FS}}^2$ 项相互抵消，剩下：\n$$\n\\frac{P_S}{P_Q} = \\frac{12 \\cdot 2^{2N}}{8} = \\frac{3}{2} \\cdot 2^{2N}\n$$\n\n**4. 以分贝表示的 SQNR**\n最后，我们将这个比率转换为分贝：\n$$\n\\text{SQNR}_{\\text{dB}} = 10 \\log_{10}\\left( \\frac{3}{2} \\cdot 2^{2N} \\right)\n$$\n使用对数的性质 $\\log(ab) = \\log(a) + \\log(b)$ 和 $\\log(x^y) = y\\log(x)$：\n$$\n\\text{SQNR}_{\\text{dB}} = 10 \\left( \\log_{10}\\left(\\frac{3}{2}\\right) + \\log_{10}\\left(2^{2N}\\right) \\right)\n$$\n$$\n\\text{SQNR}_{\\text{dB}} = 10 \\log_{10}\\left(\\frac{3}{2}\\right) + 10 \\cdot (2N) \\log_{10}(2)\n$$\n$$\n\\text{SQNR}_{\\text{dB}} = 20 N \\log_{10}(2) + 10 \\log_{10}\\left(\\frac{3}{2}\\right)\n$$\n这就是根据要求从第一性原理推导出的，全量程正弦波的 SQNR 关于比特数 $N$ 的最终解析表达式。",
            "answer": "$$\n\\boxed{20 N \\log_{10}(2) + 10 \\log_{10}\\left(\\frac{3}{2}\\right)}\n$$"
        },
        {
            "introduction": "在神经科学数据分析中，为了专注于低频现象或管理计算负载，通常需要降低信号的采样率（这一过程称为抽取）。然而，如果操作不当，这个过程可能会引入严重的光谱失真。本练习在抽取的背景下，深入探讨了奈奎斯特-香农采样定理，重点关注如何防止混叠。通过推导抗混叠低通滤波器的精确规格，您将学习到安全地对离散时间信号进行降采样而又不破坏其频谱内容的关键步骤。",
            "id": "4148600",
            "problem": "一个皮层局部场电位 (LFP) 时间序列以均匀采样率 $f_{s}$ (单位为 $\\mathrm{Hz}$) 进行采样。为进行专注于慢波振荡的下游分析，你计划将该离散时间信号以一个整数因子 $M \\geq 2$ 进行抽取，从而产生一个新的采样率为 $f_{s}/M$ 的采样序列。为了避免在抽取过程中因混叠而引起的频谱失真，你将在降采样前应用一个因果、稳定、线性时不变的低通抗混叠滤波器。假设该滤波器具有单调的幅频响应和有限宽度的过渡带，由一个相对于抽取后采样率 $f_{s}/M$ 的无量纲设计裕度 $\\delta \\in (0, \\frac{1}{2})$ 描述，这意味着通带边缘与混叠边界相隔 $f_{s}/M$ 的 $\\delta$ 倍。\n\n仅从以下基础出发：\n\n- 奈奎斯特-香农采样定理指出，一个以采样率 $f_{s}$ 采样的离散时间信号，仅当其连续时间频谱支撑被限制在 $|f| < f_{s}/2$ 内时，才能无混叠失真地重建。\n- 以整数因子 $M$ 进行抽取会将采样率从 $f_{s}$ 降低到 $f_{s}/M$，从而将奈奎斯特频率从 $f_{s}/2$ 降低到 $(f_{s}/2)/M$。\n\n推导以因子 $M$ 进行抽取时避免混叠所必需的频域条件，这些条件表示为对抽取前低通滤波器的通带和阻带边缘相对于 $f_{s}/M$ 的要求，并包含裕度 $\\delta$。请以有序对 $\\left(f_{p}^{\\max}, f_{sb}^{\\min}\\right)$ 的形式给出你的最终答案，其中 $f_{p}^{\\max}$ 是允许的最大通带边缘频率，$f_{sb}^{\\min}$ 是允许的最小阻带边缘频率，它们可以防止抽取后的混叠。你的最终答案对请以 $\\mathrm{Hz}$ 为单位表示。无需数值近似；请提供精确的符号表达式。",
            "solution": "所述问题需经过验证。\n\n### 步骤 1：提取已知条件\n-   初始均匀采样率：$f_s$ (单位：$\\mathrm{Hz}$)。\n-   整数抽取因子：$M \\geq 2$。\n-   抽取后新采样率：$f_s / M$。\n-   滤波器类型：因果、稳定、线性时不变低通抗混叠滤波器。\n-   滤波器幅频响应：单调，具有有限宽度的过渡带。\n-   无量纲设计裕度：$\\delta \\in (0, \\frac{1}{2})$。\n-   设计裕度定义：“通带边缘与混叠边界相隔 $f_s/M$ 的 $\\delta$ 倍”。\n-   基础 1 (奈奎斯特-香农采样定理)：对于采样率 $f_s$，连续时间信号的频谱支撑必须在 $|f| < f_s/2$ 内以避免混叠。\n-   基础 2 (抽取效应)：以因子 $M$ 抽取将采样率降低到 $f_s/M$，并将奈奎斯特频率降低到 $(f_s/2)/M$。\n-   目标：推导有序对 $\\left(f_{p}^{\\max}, f_{sb}^{\\min}\\right)$，其中 $f_{p}^{\\max}$ 是允许的最大通带边缘频率，$f_{sb}^{\\min}$ 是允许的最小阻带边缘频率，单位为 $\\mathrm{Hz}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题牢固地植根于数字信号处理 (DSP) 的原理，特别是关于采样、混叠和用于抽取的滤波器设计。这些是工程和应用物理学的核心概念。应用于局部场电位 (LFP) 分析是计算神经科学中一个标准且现实的场景。\n-   **良态问题**：该问题提供了所有必要的变量 ($f_s$、$M$、$\\delta$) 和清晰的定义。目标明确，约束条件足以确定一个唯一且有意义的解。\n-   **客观性**：语言技术性强、精确，且不含主观性或个人观点。\n-   **结论**：该问题没有科学上的不健全、模糊不清和矛盾之处。它是在指定领域内一个定义良好、可形式化的问题。\n\n### 步骤 3：结论与行动\n问题有效。将推导解答。\n\n### 推导过程\n抗混叠滤波器的主要目标是防止在抽取的降采样阶段可能发生的频谱混叠。我们首先确定由新的、较低的采样率所施加的临界频率限制。\n\n设初始采样率为 $f_s$。信号分析受到初始奈奎斯特频率 $f_N = f_s / 2$ 的约束。\n\n以整数因子 $M$ 进行抽取后，新的采样率变为 $f'_s = f_s/M$。根据奈奎斯特-香农采样定理，对于这个新的采样率 $f'_s$，被采样的信号必须被带限在新的奈奎斯特频率 $f'_N$ 内，以避免混叠。这个新的奈奎斯特频率是：\n$$f'_N = \\frac{f'_s}{2} = \\frac{f_s/M}{2} = \\frac{f_s}{2M}$$\n这个频率 $f_s/(2M)$ 代表了问题中提到的“混叠边界”。在降采样步骤之前，信号中任何等于或高于 $f'_N$ 的频率内容都将被混叠（折叠）到抽取后信号的频带 $[0, f'_N]$ 中，从而导致频谱失真。\n\n低通抗混叠滤波器的作用是在降采样发生前，充分衰减所有等于或高于此混叠边界的频率分量。一个实际的滤波器由通带边缘频率 $f_p$ 和阻带边缘频率 $f_{sb}$ 来表征。\n\n为防止混叠，滤波器的阻带必须在混叠边界处或之前开始。这对阻带边缘频率 $f_{sb}$ 施加了以下条件：\n$$f_{sb} \\leq f'_N = \\frac{f_s}{2M}$$\n问题要求的是允许的最小阻带边缘频率 $f_{sb}^{\\min}$，这对应于刚好满足抗混叠要求的最有效滤波器设计。这种情况发生在阻带恰好从混叠边界开始时。因此：\n$$f_{sb}^{\\min} = \\frac{f_s}{2M}$$\n\n接下来，我们确定允许的最大通带边缘频率 $f_{p}^{\\max}$。问题为此提供了一个特定约束：“通带边缘与混叠边界相隔 $f_s/M$ 的 $\\delta$ 倍”。通带边缘 $f_p$ 与混叠边界 $f_s/(2M)$ 之间的间隔定义了滤波器的过渡带。我们可以将给定的约束形式化为一个方程：\n$$(\\text{混叠边界}) - (\\text{通带边缘}) = \\delta \\times \\frac{f_s}{M}$$\n代入各项，我们找到在给定最小阻带边缘 $f_{sb}^{\\min} = f_s/(2M)$ 的情况下，最大可能通带边缘 $f_{p}^{\\max}$ 的关系：\n$$f_{sb}^{\\min} - f_{p}^{\\max} = \\delta \\frac{f_s}{M}$$\n代入已推导出的 $f_{sb}^{\\min}$ 表达式：\n$$\\frac{f_s}{2M} - f_{p}^{\\max} = \\delta \\frac{f_s}{M}$$\n现在我们可以解出 $f_{p}^{\\max}$：\n$$f_{p}^{\\max} = \\frac{f_s}{2M} - \\delta \\frac{f_s}{M}$$\n提取公因式 $\\frac{f_s}{M}$ 可以得到一个更紧凑的表达式：\n$$f_{p}^{\\max} = \\frac{f_s}{M} \\left(\\frac{1}{2} - \\delta\\right)$$\n给定的条件 $\\delta \\in (0, 1/2)$ 确保了 $f_{p}^{\\max}$ 是一个正频率，并且严格小于 $f_{sb}^{\\min}$，这是具有有限、非零过渡带宽的低通滤波器的必要条件。\n\n因此，所需的频域条件对为 $\\left(f_{p}^{\\max}, f_{sb}^{\\min}\\right)$。",
            "answer": "$$\\boxed{\\left( \\frac{f_s}{M} \\left( \\frac{1}{2} - \\delta \\right), \\frac{f_s}{2M} \\right)}$$"
        },
        {
            "introduction": "神经科学的一个核心目标是理解不同大脑区域如何进行交流，这通常通过测量它们电活动之间的特定频率相关性来实现。这需要复杂的时频分析技术，以捕捉神经同步的动态变化。这个综合性的编码练习将指导您实现一个完整的流程，用于估计时变相干性——一种衡量功能连接性的关键指标。它集成了用于获得稳健结果的多窗谱估计和用于获得统计上可靠的置信区间的移动块自举法。通过从头开始构建这个工具并在合成数据上进行测试，您不仅将掌握高级信号处理概念的实际应用，还将学会如何严格评估您发现的统计显著性。",
            "id": "4148557",
            "problem": "考虑两个连续时间过程 $x(t)$ 和 $y(t)$，它们代表从两个大脑区域记录的局部场电位。这些信号以采样频率 $f_s$ 进行均匀采样，得到离散时间序列 $x[n]$ 和 $y[n]$，其中 $n$ 是样本索引，$t = n / f_s$。你需要通过在短滑动窗口中计算的幅值平方相干性来估计目标振荡频率 $f_0$ 上的时变相互作用，并使用显式考虑数据中时间依赖性的置信区间来量化不确定性。目标是为每个窗口判断在 $f_0$ 处是否存在统计上显著的相干性。\n\n仅从离散时间傅里叶变换和谱密度的基本定义、卷积定理以及用于谱集中的正交锥形窗的概念出发，推导并实现一个算法，该算法能够：\n- 使用滑动窗口方法，窗口具有固定时长 $T_w$ 和跳跃步长 $T_h$，并在每个窗口内应用 $K$ 个时间带宽积为 $NW$ 的正交离散扁长球状序列（DPSS）锥形窗，以生成多锥形窗谱估计。\n- 通过组合 $x[n]$ 和 $y[n]$ 的加窗和锥形窗处理后的频谱，计算每个窗口中 $f_0$ 处的幅值平方相干性。\n- 通过保留时间依赖性的移动块自举法（moving block bootstrap）为每个窗口中的相干性构建一个 $(1 - \\alpha)$ 置信区间。块长度必须根据基于自相关时间的原则性标准，从该窗口数据的经验自相关函数中选择，并且必须通过有放回重采样来形成自举复制。相同的块索引必须应用于 $x[n]$ 和 $y[n]$ 以保持其联合结构。\n- 通过将自举置信区间的下界与一个基于多锥形窗估计中有效平均谱数量的、理论上合理的相干性零假设阈值进行比较来确定显著性。决策规则必须在您的解决方案中从第一性原理推导出来。\n\n你将在已知 $f_0$ 处时变耦合基准真相的合成数据上测试你的程序。对于每个测试用例，你的程序必须输出在指定的“耦合区间”内，根据上述决策规则被判定为相干性显著的窗口所占的比例。每个比例表示为一个十进制数。如果涉及角度，单位均理解为弧度。\n\n测试套件包含三组参数。在所有情况下，信号都是由一个1阶自回归噪声过程（AR(1)）和一个仅在耦合区间内存在的频率为 $f_0$ 的正弦波相加生成。$x[n]$ 的 AR(1) 过程为 $x_{\\text{noise}}[n] = \\phi_x \\, x_{\\text{noise}}[n-1] + \\varepsilon_x[n]$，$y[n]$ 的过程类似，其中 $\\varepsilon_x[n]$ 和 $\\varepsilon_y[n]$ 是均值为零、具有指定标准差的独立同分布高斯新息。在耦合情况下，正弦分量共享相同的随机相位。所有时长单位为秒，采样频率单位为赫兹。\n\n- 测试用例1（理想情况）：\n  - $f_s = 200$，总时长 $T = 10$，目标频率 $f_0 = 20$。\n  - 窗口时长 $T_w = 1$，跳跃步长 $T_h = 0.5$。\n  - 多锥形窗参数：$NW = 2.5$，$K = 5$。\n  - AR(1) 参数：$\\phi_x = 0.8$，$\\phi_y = 0.8$，新息标准差 $\\sigma_x = 0.5$，$\\sigma_y = 0.5$。\n  - 耦合区间：$[4, 8)$，在此期间 $x[n]$ 和 $y[n]$ 均包含频率为 $f_0$、振幅为 $a_x = 1.0$ 和 $a_y = 1.0$ 且具有共享随机相位的正弦波。\n  - 置信水平：$1 - \\alpha = 0.95$。\n  - 自举复制次数：$R = 200$。\n\n- 测试用例2（无耦合，边界条件）：\n  - $f_s = 200$，$T = 10$，$f_0 = 20$。\n  - $T_w = 1$，$T_h = 0.5$。\n  - $NW = 2.5$，$K = 5$。\n  - $\\phi_x = 0.8$，$\\phi_y = 0.8$，$\\sigma_x = 0.5$，$\\sigma_y = 0.5$。\n  - 耦合区间：$[4, 8)$，但 $y[n]$ 不含频率为 $f_0$ 的正弦波（即 $a_y = 0$），而 $x[n]$ 在此区间内包含频率为 $f_0$、振幅为 $a_x = 1.0$ 的正弦波。\n  - $1 - \\alpha = 0.95$，$R = 200$。\n\n- 测试用例3（边缘情况：更短的窗口和更高的噪声）：\n  - $f_s = 200$，$T = 10$，$f_0 = 20$。\n  - $T_w = 0.8$，$T_h = 0.4$。\n  - $NW = 2.5$，$K = 5$。\n  - $\\phi_x = 0.8$，$\\phi_y = 0.8$，$\\sigma_x = 1.0$，$\\sigma_y = 1.0$。\n  - 耦合区间：$[5, 7)$，在此期间 $a_x = 0.7$，$a_y = 0.7$ 且具有共享随机相位。\n  - $1 - \\alpha = 0.95$，$R = 200$。\n\n你的程序必须：\n- 根据上述规范生成信号。\n- 使用 $T_w$ 和 $T_h$ 将数据划分为滑动窗口。\n- 在每个窗口中，计算 $f_0$ 处的多锥形窗相干性，并使用移动块自举法计算 $(1-\\alpha)$ 置信区间，其中块长度根据窗口的自相关时间确定。使用推导出的相干性零假设阈值和置信下界，在每个窗口中判定显著性。\n- 对每个测试用例，报告其中心时间落在指定耦合区间内且被判定为显著的窗口所占的比例。\n\n最终输出格式：你的程序应生成单行输出，其中包含三个结果，形式为逗号分隔的列表并用方括号括起（例如，“[$r_1$, $r_2$, $r_3$]”）。不应打印任何其他文本。除无量纲的比例外，输出中没有物理单位。",
            "solution": "该问题要求开发并实现一个统计程序，用于检测两个神经生理信号 $x(t)$ 和 $y(t)$ 之间的时变功能连接性。该方法涉及在滑动窗口内进行多锥形窗相干性估计，通过移动块自举法进行不确定性量化，并进行正式的显著性检验。我们将从第一性原理推导出必要的组成部分。\n\n让两个连续时间信号 $x(t)$ 和 $y(t)$ 以频率 $f_s$ 进行采样，得到离散时间序列 $x[n]$ 和 $y[n]$，其中 $t = n/f_s$。分析在时长为 $T_w$（长度为 $N_w = \\text{round}(T_w f_s)$ 个样本）、跳跃步长为 $T_h$（长度为 $N_h = \\text{round}(T_h f_s)$ 个样本）的滑动窗口中进行。在每个窗口内，我们分析数据段，记为 $x_w[n]$ 和 $y_w[n]$，其中 $n \\in \\{0, 1, \\dots, N_w-1\\}$。\n\n### 1. 多锥形窗谱估计\n\n相干性分析的基础是功率谱密度和互谱密度的估计。多锥形窗方法缓解了谱估计中固有的偏差-方差权衡问题，特别是谱泄漏问题。\n\n**1.1. 锥形窗傅里叶变换（特征系数）**\n长度为 $N_w$ 的有限序列 $z[n]$ 的离散时间傅里叶变换（DTFT）由下式给出：\n$$ \\tilde{Z}(f) = \\sum_{n=0}^{N_w-1} z[n] e^{-i 2\\pi f n / f_s} $$\n其中 $f$ 是频率。使用单个矩形窗（即无锥形窗处理）的标准谱估计会遭受显著的谱泄漏。锥形窗处理涉及在进行傅里叶变换之前，将数据乘以一个在边缘平滑地趋于零的窗函数 $v[n]$，即 $z_v[n] = v[n] z[n]$。\n\n多锥形窗方法使用一组 $K$ 个正交锥形窗 $\\{v_k[n]\\}_{k=0}^{K-1}$，这些窗经设计可在半宽为 $W$ 的频带内实现最佳集中。这些锥形窗的经典选择是离散扁长球状序列（DPSS），或称 Slepian 序列。它们是与所需频带相关的 Toeplitz 矩阵最大特征值对应的特征向量。给定一个时间带宽积 $NW$（在我们的离散情况下，参数是 $N_w W$），大约有 $2 N_w W$ 个这样的锥形窗的能量几乎完全包含在目标频带内，从而最大限度地减少了来自该频带之外频率的泄漏。\n\n对于每个数据段 $x_w[n]$ 和 $y_w[n]$ 以及每个锥形窗 $v_k[n]$，我们计算目标频率 $f_0$ 处的第 $k$ 个特征系数：\n$$ \\tilde{x}_k(f_0) = \\sum_{n=0}^{N_w-1} v_k[n] x_w[n] e^{-i 2\\pi f_0 n / f_s} $$\n$$ \\tilde{y}_k(f_0) = \\sum_{n=0}^{N_w-1} v_k[n] y_w[n] e^{-i 2\\pi f_0 n / f_s} $$\n这些 $\\tilde{x}_k(f_0)$ 和 $\\tilde{y}_k(f_0)$ 是复数值，代表通过第 $k$ 个锥形窗观察到的数据在 $f_0$ 处的谱含量。\n\n**1.2. 谱密度估计**\n自谱（$S_{xx}, S_{yy}$）和互谱（$S_{xy}$）的多锥形窗估计是通过平均来自 $K$ 个锥形窗的信息获得的。\n$x$ 在 $f_0$ 处的自谱密度估计为其特征系数的平均功率：\n$$ \\hat{S}_{xx}(f_0) = \\frac{1}{K} \\sum_{k=0}^{K-1} |\\tilde{x}_k(f_0)|^2 = \\frac{1}{K} \\sum_{k=0}^{K-1} \\tilde{x}_k(f_0) \\tilde{x}_k^*(f_0) $$\n对 $y$ 也类似：\n$$ \\hat{S}_{yy}(f_0) = \\frac{1}{K} \\sum_{k=0}^{K-1} |\\tilde{y}_k(f_0)|^2 $$\n互谱密度通过平均特征系数的交叉乘积来估计：\n$$ \\hat{S}_{xy}(f_0) = \\frac{1}{K} \\sum_{k=0}^{K-1} \\tilde{x}_k(f_0) \\tilde{y}_k^*(f_0) $$\n其中 $(\\cdot)^*$ 表示复共轭。\n\n### 2. 幅值平方相干性\n\n幅值平方相干性 $C_{xy}(f)$ 衡量两个信号在特定频率 $f$ 处的线性相关性。其定义为：\n$$ C_{xy}(f) = \\frac{|S_{xy}(f)|^2}{S_{xx}(f) S_{yy}(f)} $$\n$C_{xy}(f)$ 的值界于 $0$（无线性相关）和 $1$（完全线性相关）之间。\n\n使用我们的多锥形窗谱估计，频率 $f_0$ 处的样本相干性为：\n$$ \\hat{C}_{xy}(f_0) = \\frac{|\\hat{S}_{xy}(f_0)|^2}{\\hat{S}_{xx}(f_0) \\hat{S}_{yy}(f_0)} = \\frac{|\\sum_{k=0}^{K-1} \\tilde{x}_k(f_0) \\tilde{y}_k^*(f_0)|^2}{\\left(\\sum_{k=0}^{K-1} |\\tilde{x}_k(f_0)|^2\\right) \\left(\\sum_{k=0}^{K-1} |\\tilde{y}_k(f_0)|^2\\right)} $$\n注意，因子 $1/K$ 被消掉了。\n\n### 3. 显著性检验和置信区间\n\n为了确定一个观测到的相干性值是否在统计上是显著的，我们需要一个零假设和一个计算置信区间的过程。\n\n**3.1. 零假设和显著性阈值**\n零假设 $H_0$ 是指两个过程在 $f_0$ 处实际上是不相干的，即 $C_{xy}(f_0) = 0$。在 $H_0$ 下，并假设特征系数是近似独立同分布的复高斯随机变量，估计的相干性 $\\hat{C}_{xy}(f_0)$ 服从一个已知分布。对于使用 $K$ 个锥形窗的多锥形窗估计，被平均的独立谱样本数量实际上是 $K$。在零假设下，观测到样本相干性值大于某个值 $\\hat{C}$ 的概率由下式给出：\n$$ P(\\hat{C}_{xy}(f_0) > \\hat{C} | H_0) = (1 - \\hat{C})^{K-1} $$\n为了找到显著性水平为 $\\alpha$ 的阈值，我们寻找值 $C_{thresh}$，使得偶然超过它的概率为 $\\alpha$：\n$$ \\alpha = (1 - C_{thresh})^{K-1} $$\n解出 $C_{thresh}$ 得到理论上合理的零假设阈值：\n$$ C_{thresh} = 1 - \\alpha^{1/(K-1)} $$\n问题中指定的决策规则是，如果一个 $(1-\\alpha)$ 置信区间的下界超过此阈值，则宣布相干性是显著的。\n\n**3.2. 用于置信区间的移动块自举法**\n关于相干性置信区间的标准方法通常假设谱估计（特征系数）是独立的，如果基础过程不是白噪声，这个假设可能不成立。该问题规定在每个窗口内的原始时间序列数据上使用移动块自举法来构建一个对时间相关性具有鲁棒性的置信区间。\n\n单个窗口的算法如下：\n1.  **确定块长度（$L$）**：自举法必须保留数据的时间依赖结构。这种依赖的长度可以从经验自相关函数（ACF）中估计。对于数据段 $x_w[n]$，我们计算其 ACF $\\rho_x(\\tau)$。自相关时间 $\\tau_{ac}$ 是衡量过程记忆性的一个指标。我们将其定义为自相关函数（ACF）的幅度降至或低于 $1/e$ 的第一个延迟 $\\tau$。\n    $$ \\tau_x = \\min\\{\\tau > 0 \\: : \\: |\\rho_x(\\tau)| \\le 1/e\\} $$\n    我们对 $x_w[n]$ 和 $y_w[n]$ 都进行计算，得到 $\\tau_x$ 和 $\\tau_y$。一个保守的块长度选择是 $L = \\max(1, \\lfloor \\max(\\tau_x, \\tau_y) \\rfloor)$。这确保了块足够长，以捕捉两个信号中的主要时间相关性。\n\n2.  **生成自举复制**：对于 $r = 1, \\dots, R$：\n    a. 创建一个长度为 $N_w$ 的自举时间序列 $(x_w^{*,r}, y_w^{*,r})$。这是通过首先从原始加窗数据 $(x_w, y_w)$ 中定义一组 $N_w - L + 1$ 个长度为 $L$ 的重叠块来完成的。\n    b. 我们*有放回地*抽取 $B = \\lceil N_w / L \\rceil$ 个这样的块。至关重要的是，对 $x_w$ 和 $y_w$ 使用相同的随机块索引，以保留它们的联合时间结构。\n    c. 将这 $B$ 个块连接起来，形成一个新的长度为 $B \\times L$ 的时间序列，然后截断至原始窗口长度 $N_w$。这个新序列 $(x_w^{*,r}, y_w^{*,r})$ 就是一个自举复制。\n\n3.  **计算自举分布**：对于每个自举复制，我们使用与原始数据完全相同的过程计算多锥形窗相干性估计 $\\hat{C}^{*,r}_{xy}(f_0)$。这个过程产生一个包含 $R$ 个自举相干性值的分布，$\\{\\hat{C}^{*,r}_{xy}(f_0)\\}_{r=1}^R$。\n\n4.  **构建置信区间**：这个经验分布可作为相干性估计量抽样分布的近似。$(1-\\alpha)$ 百分位数置信区间是通过取排序后的自举分布的分位数形成的。下界 $CI_{lower}$ 是位于 $100 \\cdot (\\alpha/2)$ 百分位数的值。\n\n### 4. 最终决策规则和输出\n\n对于每个中心时间落在指定的 `coupling_interval` 内的窗口：\n1.  如上所述，计算 $\\hat{C}_{xy}(f_0)$ 的 $(1-\\alpha)$ 置信区间。\n2.  获得置信下界 $CI_{lower}$。\n3.  计算零假设阈值 $C_{thresh} = 1 - \\alpha^{1/(K-1)}$。\n4.  如果 $CI_{lower} > C_{thresh}$，则该窗口中的相干性被判定为统计显著。\n\n每个测试用例的最终输出是在耦合区间内被判定为显著的窗口所占的比例。此过程集成了鲁棒的谱估计、非参数不确定性量化和原则性的统计检验。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import windows, lfilter\n\ndef solve():\n    \"\"\"\n    Main function to run the time-varying coherence analysis for all test cases.\n    \"\"\"\n    # Set random seed for reproducibility of data generation and bootstrap\n    np.random.seed(0)\n\n    test_cases = [\n        # Test Case 1: Happy path with coupling\n        {'fs': 200, 'T': 10, 'f0': 20, 'Tw': 1, 'Th': 0.5, 'NW': 2.5, 'K': 5,\n         'phi_x': 0.8, 'phi_y': 0.8, 'sigma_x': 0.5, 'sigma_y': 0.5,\n         'coupling_interval': [4, 8], 'ax': 1.0, 'ay': 1.0, 'coupled': True,\n         'alpha': 0.05, 'R': 200},\n        # Test Case 2: No coupling\n        {'fs': 200, 'T': 10, 'f0': 20, 'Tw': 1, 'Th': 0.5, 'NW': 2.5, 'K': 5,\n         'phi_x': 0.8, 'phi_y': 0.8, 'sigma_x': 0.5, 'sigma_y': 0.5,\n         'coupling_interval': [4, 8], 'ax': 1.0, 'ay': 0.0, 'coupled': False,\n         'alpha': 0.05, 'R': 200},\n        # Test Case 3: Edge case, shorter windows, higher noise\n        {'fs': 200, 'T': 10, 'f0': 20, 'Tw': 0.8, 'Th': 0.4, 'NW': 2.5, 'K': 5,\n         'phi_x': 0.8, 'phi_y': 0.8, 'sigma_x': 1.0, 'sigma_y': 1.0,\n         'coupling_interval': [5, 7], 'ax': 0.7, 'ay': 0.7, 'coupled': True,\n         'alpha': 0.05, 'R': 200},\n    ]\n\n    results = []\n    e_val = 1.0 / np.e\n\n    for params in test_cases:\n        fs, T, f0 = params['fs'], params['T'], params['f0']\n        Tw, Th, NW, K = params['Tw'], params['Th'], params['NW'], params['K']\n        phi_x, phi_y, sigma_x, sigma_y = params['phi_x'], params['phi_y'], params['sigma_x'], params['sigma_y']\n        c_int, ax, ay, coupled = params['coupling_interval'], params['ax'], params['ay'], params['coupled']\n        alpha, R = params['alpha'], params['R']\n\n        # 1. Generate Signals\n        N = int(T * fs)\n        t = np.arange(N) / fs\n        \n        # AR(1) noise\n        epsilon_x = np.random.normal(0, sigma_x, N)\n        epsilon_y = np.random.normal(0, sigma_y, N)\n        x_noise = lfilter([1], [1, -phi_x], epsilon_x)\n        y_noise = lfilter([1], [1, -phi_y], epsilon_y)\n        \n        # Sinusoidal component\n        x_sig = np.zeros(N)\n        y_sig = np.zeros(N)\n        \n        start_sample = int(c_int[0] * fs)\n        end_sample = int(c_int[1] * fs)\n        \n        phase = np.random.uniform(0, 2 * np.pi)\n        phase_y = phase if coupled else np.random.uniform(0, 2 * np.pi)\n\n        x_sig[start_sample:end_sample] = ax * np.sin(2 * np.pi * f0 * t[start_sample:end_sample] + phase)\n        y_sig[start_sample:end_sample] = ay * np.sin(2 * np.pi * f0 * t[start_sample:end_sample] + phase_y)\n        \n        x = x_noise + x_sig\n        y = y_noise + y_sig\n\n        # 2. Window and Analysis Parameters\n        Nw = int(Tw * fs)\n        Nh = int(Th * fs)\n        \n        # Pre-compute tapers and DFT vector\n        tapers = windows.dpss(Nw, NW, K)\n        dft_vec = np.exp(-1j * 2 * np.pi * f0 * np.arange(Nw) / fs)\n\n        def compute_coherence(data_x, data_y, tapers_in, dft_vec_in):\n            dft_x_k = (data_x * tapers_in).dot(dft_vec_in)\n            dft_y_k = (data_y * tapers_in).dot(dft_vec_in)\n            \n            Sxy = np.sum(dft_x_k * np.conj(dft_y_k))\n            Sxx = np.sum(dft_x_k * np.conj(dft_x_k))\n            Syy = np.sum(dft_y_k * np.conj(dft_y_k))\n            \n            if Sxx == 0 or Syy == 0:\n                return 0.0\n            \n            return np.abs(Sxy)**2 / (Sxx * Syy)\n\n        # 3. Main Loop over Windows\n        window_starts = np.arange(0, N - Nw + 1, Nh)\n        significant_count = 0\n        coupling_windows_count = 0\n\n        for start in window_starts:\n            end = start + Nw\n            window_center_time = (start + Nw / 2) / fs\n            \n            if not (c_int[0] <= window_center_time < c_int[1]):\n                continue\n            \n            coupling_windows_count += 1\n            \n            x_w = x[start:end]\n            y_w = y[start:end]\n            \n            # Moving Block Bootstrap\n            # a. Determine block length L\n            def get_block_len(series):\n                mean_subtracted = series - np.mean(series)\n                acf = np.correlate(mean_subtracted, mean_subtracted, mode='full')\n                acf = acf[acf.size // 2:]\n                if acf[0] == 0: return int(Nw**0.5) # Fallback\n                acf /= acf[0]\n                \n                crossings = np.where(np.abs(acf) <= e_val)[0]\n                tau = crossings[0] if len(crossings) > 0 else int(Nw**0.5) # Fallback\n                return max(1, tau)\n\n            L = max(get_block_len(x_w), get_block_len(y_w))\n            \n            # b. Bootstrap replicates\n            num_blocks_to_draw = int(np.ceil(Nw / L))\n            block_indices = np.arange(Nw - L + 1)\n            \n            bootstrap_coherences = np.zeros(R)\n            for i in range(R):\n                # Resample block indices\n                rand_indices = np.random.choice(block_indices, size=num_blocks_to_draw, replace=True)\n                \n                # Create bootstrap time series\n                x_w_star = np.concatenate([x_w[j:j+L] for j in rand_indices])[:Nw]\n                y_w_star = np.concatenate([y_w[j:j+L] for j in rand_indices])[:Nw]\n                \n                bootstrap_coherences[i] = compute_coherence(x_w_star, y_w_star, tapers, dft_vec)\n\n            # c. Construct CI\n            ci_lower_bound = np.percentile(bootstrap_coherences, 100 * alpha / 2)\n\n            # d. Decision\n            C_thresh = 1 - alpha**(1 / (K - 1))\n            if ci_lower_bound > C_thresh:\n                significant_count += 1\n        \n        fraction = significant_count / coupling_windows_count if coupling_windows_count > 0 else 0\n        results.append(fraction)\n\n    print(f\"[{','.join(f'{r:.16f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}