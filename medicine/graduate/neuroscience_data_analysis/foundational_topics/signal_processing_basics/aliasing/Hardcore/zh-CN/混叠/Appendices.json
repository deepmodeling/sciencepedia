{
    "hands_on_practices": [
        {
            "introduction": "理解混叠现象的第一步是掌握其背后的数学原理。这个练习将引导你从第一性原理出发，推导出一个高于奈奎斯特频率的信号分量在采样后将表现为何种频率。通过这个基础计算（），你将能够准确预测高频伪影如何“折叠”进你的目标频带。",
            "id": "4137810",
            "problem": "一个实验室在啮齿动物进行行为任务时，采集其海马体的局部场电位（LFP）信号。采集系统以 $f_{s} = 1\\,\\mathrm{kHz}$ 的速率进行均匀采样。由于上游设备的影响，在采样前的连续时间信号中存在一个频率为 $f = 780\\,\\mathrm{Hz}$ 的窄带正弦伪影。模拟抗混叠滤波器配置不当，导致该伪影进入数字化器并产生混叠。\n\n从均匀采样的基本定义和连续时间复指数的离散时间表示出发，推导出一个精确的规则，该规则描述了两个连续时间正弦分量 $f$ 和 $f'$ 在以速率 $f_{s}$ 采样时，如何产生相同的离散时间序列，且仅使用 $f_{s}$ 的整数倍。然后，使用此规则确定频率为 $f = 780\\,\\mathrm{Hz}$ 的伪影在基带区间 $[0, f_{s}/2]$ 内的唯一折叠频率。将最终的折叠频率以 $\\mathrm{Hz}$ 为单位表示。无需四舍五入；请提供精确值。",
            "solution": "首先验证问题陈述的正确性和完整性。\n\n### 步骤 1：提取已知条件\n- 均匀采样率：$f_{s} = 1\\,\\mathrm{kHz} = 1000\\,\\mathrm{Hz}$\n- 连续时间伪影频率：$f = 780\\,\\mathrm{Hz}$\n- 任务1：推导一个规则，该规则描述了两个连续时间正弦分量 $f$ 和 $f'$ 在以速率 $f_{s}$ 采样时，如何产生相同的离散时间序列，且仅使用 $f_{s}$ 的整数倍。\n- 任务2：确定频率为 $f = 780\\,\\mathrm{Hz}$ 的伪影在基带区间 $[0, f_{s}/2]$ 内的唯一折叠频率。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，提法得当且客观。它描述了数字信号处理中混叠的标准场景，这是工程学和数据分析中的一个基本概念。所提供的值对于电生理记录是符合实际的。该问题是自洽的，提供了推导所需规则和计算最终值所需的所有信息。其中没有科学或逻辑上的矛盾、模糊之处或不切实际的条件。\n\n### 步骤 3：结论与行动\n该问题有效。将提供完整的解决方案。\n\n### 解题推导\n问题要求分为两部分：首先，推导混叠的一般条件；其次，应用此规则找到一个特定的折叠频率。\n\n**第 1 部分：混叠规则的推导**\n\n我们从均匀采样的基本定义开始。一个连续时间信号 $x(t)$ 以速率 $f_s$ 进行采样，对应的采样周期为 $T_s = 1/f_s$。得到的离散时间序列 $x[n]$ 由连续信号在 $T_s$ 的整数倍时刻的值组成：\n$$x[n] = x(t)|_{t=nT_s} = x(nT_s)$$\n其中 $n$ 是一个整数。\n\n为了推导混叠条件，最方便的方法是使用复指数，因为任何实正弦信号都可以通过欧拉公式（$\\cos(\\theta) = \\frac{1}{2}(\\exp(j\\theta) + \\exp(-j\\theta))$）表示为复指数的和。为复指数推导出的结果直接适用于实正弦信号。\n\n让我们考虑一个频率为 $f$ 的连续时间复指数信号：\n$$x_1(t) = \\exp(j2\\pi f t)$$\n以速率 $f_s$ 采样后，得到的离散时间序列为：\n$$x_1[n] = x_1(nT_s) = \\exp(j2\\pi f nT_s) = \\exp\\left(j2\\pi \\frac{f}{f_s} n\\right)$$\n\n现在，考虑第二个具有不同频率 $f'$ 的连续时间复指数信号：\n$$x_2(t) = \\exp(j2\\pi f' t)$$\n其对应的离散时间序列为：\n$$x_2[n] = x_2(nT_s) = \\exp(j2\\pi f' nT_s) = \\exp\\left(j2\\pi \\frac{f'}{f_s} n\\right)$$\n\n如果两个连续时间频率 $f$ 和 $f'$ 产生了相同的离散时间序列，即对于所有整数 $n$ 都有 $x_1[n] = x_2[n]$，我们就说它们发生了混叠。这要求：\n$$\\exp\\left(j2\\pi \\frac{f}{f_s} n\\right) = \\exp\\left(j2\\pi \\frac{f'}{f_s} n\\right)$$\n复指数函数 $\\exp(j\\theta)$ 的周期为 $2\\pi$。这意味着对于任何整数 $k$，都有 $\\exp(j\\theta) = \\exp(j(\\theta + 2\\pi k))$。因此，为了使等式对所有 $n$ 都成立，指数的参数对于每个 $n$ 必须相差 $2\\pi$ 的整数倍。这意味着归一化频率 $\\frac{f}{f_s}$ 和 $\\frac{f'}{f_s}$ 必须以一种特定的方式相关。\n如果归一化频率（即指数中 $n$ 的系数）相差一个整数，则等式成立。\n$$2\\pi \\frac{f}{f_s} = 2\\pi \\frac{f'}{f_s} + 2\\pi k$$\n对于某个整数 $k$。整个方程除以 $2\\pi$ 得：\n$$\\frac{f}{f_s} = \\frac{f'}{f_s} + k$$\n乘以 $f_s$ 得到 $f$ 和 $f'$ 之间的关系：\n$$f = f' + k f_s$$\n这就是规则：如果两个频率为 $f$ 和 $f'$ 的连续时间正弦分量的频率之差是采样率 $f_s$ 的整数倍，那么在以速率 $f_s$ 采样后，它们是不可区分的。\n\n**第 2 部分：折叠频率的计算**\n\n给定采样率 $f_s = 1000\\,\\mathrm{Hz}$ 和伪影频率 $f = 780\\,\\mathrm{Hz}$。问题要求在基带区间 $[0, f_s/2]$ 内唯一的“折叠频率”。\n\n基带区间为 $[0, 1000/2]\\,\\mathrm{Hz} = [0, 500]\\,\\mathrm{Hz}$。\n\n根据上面推导的规则，频率为 $f$ 的伪影将有无数个混叠频率 $f_k'$，由下式给出：\n$$f_k' = f + k f_s$$\n对于任何整数 $k \\in \\mathbb{Z}$。\n\n我们需要找到落入主混叠范围的特定混叠频率，即奈奎斯特区间 $[-f_s/2, f_s/2]$。该区间为 $[-500, 500]\\,\\mathrm{Hz}$。我们必须找到一个整数 $k$ 使得：\n$$-500 \\le f + k f_s \\le 500$$\n代入给定值：\n$$-500 \\le 780 + k(1000) \\le 500$$\n为了找到 $k$，我们解这个不等式：\n$$-500 - 780 \\le 1000k \\le 500 - 780$$\n$$-1280 \\le 1000k \\le -280$$\n除以 $1000$：\n$$-1.28 \\le k \\le -0.28$$\n满足此不等式的唯一整数是 $k=-1$。\n\n使用 $k=-1$，我们可以找到主混叠的频率，我们将其表示为 $f_{alias}$：\n$$f_{alias} = f + (-1)f_s = 780\\,\\mathrm{Hz} - 1000\\,\\mathrm{Hz} = -220\\,\\mathrm{Hz}$$\n这个频率 $f_{alias} = -220\\,\\mathrm{Hz}$ 位于主混叠范围 $[-500, 500]\\,\\mathrm{Hz}$ 内。\n\n然而，问题要求的是非负区间 $[0, f_s/2]$ 内的*折叠频率*，这对应于频率在实值信号的标准单边功率谱中的表现形式。对于实信号，其频谱表现出共轭对称性，意味着幅度谱关于 $0\\,\\mathrm{Hz}$ 对称。一个在负频率 $-f_0$ 处的分量在幅度上与一个在正频率 $+f_0$ 处的分量是无法区分的。\n\n因此，折叠频率 $f_{folded}$ 是主混叠频率的绝对值：\n$$f_{folded} = |f_{alias}| = |-220\\,\\mathrm{Hz}| = 220\\,\\mathrm{Hz}$$\n这个值 $220\\,\\mathrm{Hz}$ 位于指定的目标区间 $[0, 500]\\,\\mathrm{Hz}$ 内。这就是 $780\\,\\mathrm{Hz}$ 伪影的唯一折叠频率。",
            "answer": "$$ \\boxed{220} $$"
        },
        {
            "introduction": "奈奎斯特-香农采样定理通常规定采样率必须*严格大于*信号最高频率的两倍。那么，如果恰好在临界点上采样会发生什么呢？这个练习（）探讨了这一特殊的边界情况，揭示了采样相位如何成为决定信号能否被正确捕获的关键因素，从而加深了你对采样定理严谨性的理解。",
            "id": "2373313",
            "problem": "给定一个连续时间正弦信号 $f(t)=\\sin(\\omega_{N} t+\\phi)$，其中 $\\omega_{N}$ 是一个正角频率，$\\phi$ 是一个恒定相位。该信号以速率 $f_{s}$ 进行均匀采样，使得正弦波的普通频率等于奈奎斯特频率，即 $f_{s}=2 f_{N}$，其中 $f_{N}=\\omega_{N}/(2\\pi)$，等效于 $f_{s}=\\omega_{N}/\\pi$。采样时刻为 $t_{n}=n/f_{s}$，其中 $n$ 为整数。所有角度均以弧度为单位。仅使用基本原理和定义，确定精确的采样序列 $x[n]=f(t_{n})$，并将其表示为关于 $n$ 和 $\\phi$ 的闭式解析表达式。请以 $x[n]$ 的单个解析表达式形式提供最终答案。无需进行四舍五入，且最终表达式中不应包含任何单位。",
            "solution": "在尝试求解之前，需对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 连续时间信号：$f(t)=\\sin(\\omega_{N} t+\\phi)$\n- 角频率 $\\omega_{N}$ 为正。\n- 相位 $\\phi$ 为常数。\n- 采样率：$f_{s}$\n- 采样条件：正弦波的普通频率 $f_{N} = \\frac{\\omega_{N}}{2\\pi}$ 等于奈奎斯特频率 $\\frac{f_{s}}{2}$。这给出了关系式 $f_{s}=2 f_{N}$，题目说明其等效于 $f_{s}=\\frac{\\omega_{N}}{\\pi}$。\n- 采样时刻：$t_{n}=\\frac{n}{f_{s}}$，其中 $n$ 为整数。\n- 角度以弧度为单位。\n- 目标是求出采样序列 $x[n]=f(t_{n})$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它涉及奈奎斯特-香农采样定理，这是信号处理和计算物理学的基石。信号频率等于奈奎斯特频率的特定情况是一个临界情况，常因其与混叠相关的特性而被研究。该问题是适定的，提供了推导唯一解析解所需的所有必要定义和约束条件。给定的条件是自洽的：如果 $f_{s}=2f_{N}$ 且 $f_{N}=\\frac{\\omega_{N}}{2\\pi}$，则代入 $f_{N}$ 可得 $f_{s}=2\\left(\\frac{\\omega_{N}}{2\\pi}\\right) = \\frac{\\omega_{N}}{\\pi}$，这与明确给出的等效条件相符。该问题是客观的，并使用了精确的数学语言。没有科学缺陷、不一致之处或模糊之处。\n\n**步骤 3：结论与行动**\n问题有效。现在将进行严格的推导。\n\n采样序列记为 $x[n]$，是通过在离散采样时刻 $t_{n}$ 处对连续时间信号 $f(t)$ 求值得到的。定义如下：\n$$x[n] = f(t_{n})$$\n我们已知信号 $f(t)$ 和采样时刻 $t_{n}$ 的表达式：\n$$f(t) = \\sin(\\omega_{N} t + \\phi)$$\n$$t_{n} = \\frac{n}{f_{s}}$$\n将 $t_{n}$ 的表达式代入 $f(t)$，我们得到采样序列 $x[n]$ 的公式：\n$$x[n] = \\sin\\left(\\omega_{N} \\left(\\frac{n}{f_{s}}\\right) + \\phi\\right)$$\n问题陈述提供了信号角频率 $\\omega_{N}$ 与采样率 $f_{s}$ 之间的一个关键关系。这个关系是 $f_{s} = \\frac{\\omega_{N}}{\\pi}$。必须使用这个条件来简化 $x[n]$ 的表达式。根据这个条件，我们可以用采样率 $f_{s}$ 来表示角频率 $\\omega_{N}$：\n$$\\omega_{N} = \\pi f_{s}$$\n现在，我们将这个 $\\omega_{N}$ 的表达式代回到 $x[n]$ 的方程中：\n$$x[n] = \\sin\\left((\\pi f_{s}) \\left(\\frac{n}{f_{s}}\\right) + \\phi\\right)$$\n正弦函数自变量中的 $f_{s}$ 项相互抵消，从而显著简化了表达式：\n$$x[n] = \\sin(n\\pi + \\phi)$$\n为了得到最终的闭式表达式，我们必须应用正弦函数的和角恒等式，即 $\\sin(A+B) = \\sin(A)\\cos(B) + \\cos(A)\\sin(B)$。在我们的例子中，$A = n\\pi$，$B = \\phi$。应用此恒等式可得：\n$$x[n] = \\sin(n\\pi)\\cos(\\phi) + \\cos(n\\pi)\\sin(\\phi)$$\n对于任意整数 $n$，三角函数 $\\sin(n\\pi)$ 和 $\\cos(n\\pi)$ 都有明确定义的值：\n- 对于所有整数 $n$，$\\sin(n\\pi) = 0$。\n- 对于所有整数 $n$，$\\cos(n\\pi) = (-1)^{n}$。\n\n将这些值代入 $x[n]$ 的表达式中，得到：\n$$x[n] = (0)\\cos(\\phi) + (-1)^{n}\\sin(\\phi)$$\n这可以简化为采样序列的最终表达式：\n$$x[n] = (-1)^{n}\\sin(\\phi)$$\n这个表达式是关于整数索引 $n$ 和恒定相位 $\\phi$ 的闭式解析函数形式的精确采样序列，符合问题陈述的要求。这个结果表明，当一个正弦波恰好以其奈奎斯特速率被采样时，得到的离散序列是一个交替序列，其幅值由正弦波的初始相位决定。如果相位 $\\phi$ 是 $\\pi$ 的整数倍，即 $\\phi=k\\pi$（其中 $k$ 为整数），那么 $\\sin(\\phi)=0$，采样序列将恒等于零，这是临界采样模糊性的一种体现。",
            "answer": "$$\\boxed{(-1)^{n}\\sin(\\phi)}$$"
        },
        {
            "introduction": "在掌握了混叠的理论基础后，下一步是亲眼见证其在数据中的影响。本练习（）要求你构建一个仿真程序，将已知的高频分量注入合成的神经信号中，并量化在不同采样率下产生的混叠误差。这项实践将理论知识转化为可量化的结果，让你直观地感受欠采样对信号分析的破坏性影响。",
            "id": "4137791",
            "problem": "要求您设计并实现一个完整的、可运行的程序，通过向合成信号中注入已知的高频分量来模拟采样神经信号中的混叠效应，并量化不同采样频率下的折叠误差。这个问题的基本原理是奈奎斯特-香农采样定理 (Nyquist-Shannon sampling theorem, NSST)，该定理断言，如果一个带限连续时间信号的最大频率成分低于采样频率的一半，那么该信号可以从其样本中完美重建。当信号包含高于奈奎斯特频率的频率分量时，采样会产生与基带重叠的频谱副本，从而导致混叠。\n\n构建一个连续时间信号 $x(t)$，作为低频分量 $s_{\\mathrm{lf}}(t)$ 和高频分量 $s_{\\mathrm{hf}}(t)$ 的和。设采样频率为 $f_s$，采样周期为 $T_s = 1/f_s$，信号持续时间为 $T$。低频分量由两个代表典型神经振荡的正弦波定义：\n- $s_{\\mathrm{lf}}(t) = A_1 \\sin\\left(2\\pi f_1 t\\right) + A_2 \\sin\\left(2\\pi f_2 t\\right)$，\n其中 $f_1 = 8$ $\\mathrm{Hz}$，$f_2 = 30$ $\\mathrm{Hz}$，振幅分别为 $A_1 = 1$ $\\mathrm{a.u.}$ 和 $A_2 = 0.5$ $\\mathrm{a.u.}$。所有角度都必须以弧度为单位进行处理。\n\n高频分量被定义为一系列正弦波之和，其频率严格大于给定采样频率 $f_s$ 所对应的奈奎斯特频率：\n- $s_{\\mathrm{hf}}(t) = \\sum_{m} B_m \\sin\\left(2\\pi F_m t\\right)$，\n其中每个 $F_m$ 根据测试用例指定，并且对所有 $m$，$B_m = 0.8$ $\\mathrm{a.u.}$。总信号为 $x(t) = s_{\\mathrm{lf}}(t) + s_{\\mathrm{hf}}(t)$。\n\n在持续时间 $T$ 内以速率 $f_s$ 对 $x(t)$ 进行采样，得到离散时间样本 $x[n] = x(n T_s)$，其中 $n = 0, 1, \\dots, N-1$ 且 $N = \\lfloor T f_s \\rfloor$。定义一个理想的低通重建算子，该算子将所有高于频带限制 $f_{\\mathrm{band}} = 50$ $\\mathrm{Hz}$ 的离散傅里叶变换（DFT）频点置零，然后执行逆变换以重建一个带限于 $[0, f_{\\mathrm{band}}]$ 的时域信号。将此算子分别应用于采样后的总信号和仅含低频分量的信号，以获得 $y_{\\mathrm{total}}[n]$ 和 $y_{\\mathrm{lf}}[n]$。\n\n通过计算 $y_{\\mathrm{total}}[n]$ 和 $y_{\\mathrm{lf}}[n]$ 之间的均方根误差 (RMSE) 来量化混叠折叠效应：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y_{\\mathrm{total}}[n] - y_{\\mathrm{lf}}[n]\\right)^2}.\n$$\n这衡量了目标低频带被混叠的高频内容污染的程度。请将 RMSE 表示为浮点数，单位为任意单位 (a.u.)。\n\n使用以下测试套件，其中所有频率单位为 $\\mathrm{Hz}$，所有振幅单位为 $\\mathrm{a.u.}$，持续时间为 $T = 2$ $\\mathrm{s}$，角度单位为弧度：\n- 用例 1（具有明显折叠的理想路径）：$f_s = 1000$, $F_m \\in \\{960, 980\\}$。\n- 用例 2（中等采样率）：$f_s = 500$, $F_m \\in \\{480, 495\\}$。\n- 用例 3（频带边缘混叠）：$f_s = 200$, $F_m \\in \\{450\\}$。\n- 用例 4（近奈奎斯特条件）：$f_s = 120$, $F_m \\in \\{115, 235\\}$。\n- 用例 5（边界压力测试：略低于/高于倍频）：$f_s = 100$, $F_m \\in \\{99, 101, 199\\}$。\n\n您的程序应计算每个用例的 RMSE，并生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。每个结果必须是一个浮点数，表示相应案例的 RMSE（单位为 a.u.），且顺序与上述列表一致。",
            "solution": "问题陈述已根据指定标准进行了严格验证。它在科学上是合理的、定义明确的、客观的，并且包含了获得唯一解所需的所有必要信息。该问题是数字信号处理中的一个标准练习，专门用于演示由奈奎斯特-香农采样定理所描述的混叠现象。所提出的方法是正确的，并且在计算上是可行的。因此，我们可以着手进行求解。\n\n这个问题的核心在于演示和量化混叠，这是信号处理中的一个基本概念。奈奎斯特-香农采样定理指出，如果一个连续时间信号的频率不高于最大频率 $f_{\\mathrm{max}}$，并且采样频率 $f_s$ 严格大于最大频率的两倍（即 $f_s > 2 f_{\\mathrm{max}}$），那么该信号可以从其样本中完美重建。频率 $f_s/2$ 被称为奈奎斯特频率，记为 $f_{\\mathrm{Nyq}}$。如果信号包含高于 $f_{\\mathrm{Nyq}}$ 的频率分量，这些分量会被“折叠”到频率范围 $[0, f_{\\mathrm{Nyq}}]$ 内，从而破坏低频内容。这种现象就是混叠。\n\n解决方案设计为四个不同的步骤：信号合成、采样、频域滤波和误差量化。\n\n**1. 信号合成**\n\n我们构建一个合成的连续时间信号 $x(t)$，它由两部分组成：代表感兴趣信号的低频分量 $s_{\\mathrm{lf}}(t)$，以及代表污染或噪声的高频分量 $s_{\\mathrm{hf}}(t)$。\n\n低频信号 $s_{\\mathrm{lf}}(t)$ 被定义为两个正弦波的和，其频率为 $f_1 = 8$ $\\mathrm{Hz}$ 和 $f_2 = 30$ $\\mathrm{Hz}$，这两个频率都在神经数据的典型感兴趣频带（例如，alpha 和 beta 波段）之内。\n$$\ns_{\\mathrm{lf}}(t) = A_1 \\sin(2\\pi f_1 t) + A_2 \\sin(2\\pi f_2 t)\n$$\n振幅为 $A_1 = 1$ 和 $A_2 = 0.5$，单位为任意单位 (a.u.)。\n\n高频信号 $s_{\\mathrm{hf}}(t)$ 是一系列正弦波的和，其频率 $F_m$ 在每个测试用例中都被特意选择为高于奈奎斯特频率。\n$$\ns_{\\mathrm{hf}}(t) = \\sum_{m} B_m \\sin(2\\pi F_m t)\n$$\n所有分量的振幅均为 $B_m = 0.8$ a.u.。\n\n总信号是这两个分量的线性叠加：$x(t) = s_{\\mathrm{lf}}(t) + s_{\\mathrm{hf}}(t)$。\n\n**2. 信号采样（离散化）**\n\n连续信号在 $T = 2$ $\\mathrm{s}$ 的持续时间内以速率 $f_s$ 进行采样。这将产生离散时间序列。采样的时间点为 $t_n = n T_s = n/f_s$，其中 $n = 0, 1, \\dots, N-1$，$N = \\lfloor T f_s \\rfloor$ 是样本总数。\n\n我们生成两个离散时间信号：\n- 采样后的总信号：$x[n] = x(t_n) = s_{\\mathrm{lf}}(t_n) + s_{\\mathrm{hf}}(t_n)$\n- 采样后的参考低频信号：$s_{\\mathrm{lf}}[n] = s_{\\mathrm{lf}}(t_n)$\n\n采样时，频率为 $F > f_{\\mathrm{Nyq}}$ 的高频正弦波会伪装成频率范围在 $[0, f_{\\mathrm{Nyq}}]$ 内的低频正弦波，其频率为 $f_{\\mathrm{alias}}$。混叠后的频率由 $f_{\\mathrm{alias}} = |F - k \\cdot f_s|$ 给出，其中 $k$ 是一个整数，其选择要使 $f_{\\mathrm{alias}} \\le f_{\\mathrm{Nyq}}$ 成立。这种频谱折叠是我们旨在量化的误差的来源。\n\n**3. 频域低通滤波**\n\n为了在特定的感兴趣频带内分离混叠效应，我们应用一个截止频率为 $f_{\\mathrm{band}} = 50$ $\\mathrm{Hz}$ 的理想低通滤波器。这个操作在频域中执行，使用离散傅里叶变换 (DFT)，并通过快速傅里叶变换 (FFT) 算法实现。\n\n首先，我们计算采样信号 $x[n]$ 和 $s_{\\mathrm{lf}}[n]$ 的 DFT，以分别获得它们的复值频谱 $X[k]$ 和 $S_{\\mathrm{lf}}[k]$。每个 DFT 频点 $k$ 对应的频率由采样率 $f_s$ 和点数 $N$ 决定。\n\n理想低通滤波器通过创建一个频率掩码来实现。我们识别出所有对应于频率 $|f| > f_{\\mathrm{band}}$ 的频点，并将其对应的 DFT 系数设置为零。对于实值输入信号，其 DFT 频谱是共轭对称的，因此滤波器必须对称地应用于正频率和负频率分量。\n\n设 $Y_{\\mathrm{total}}[k]$ 和 $Y_{\\mathrm{lf}}[k]$ 为滤波后的频谱。它们定义如下：\n$$\nY[k] =\n\\begin{cases}\nX[k]  \\text{if } |f_k| \\le f_{\\mathrm{band}} \\\\\n0  \\text{if } |f_k| > f_{\\mathrm{band}}\n\\end{cases}\n$$\n其中 $X[k]$ 是原始频谱，$f_k$ 是第 $k$ 个频点的频率。\n\n最后，我们将逆离散傅里叶变换（通过 IFFT 实现）应用于滤波后的频谱 $Y_{\\mathrm{total}}[k]$ 和 $Y_{\\mathrm{lf}}[k]$，以获得滤波后的时域信号 $y_{\\mathrm{total}}[n]$ 和 $y_{\\mathrm{lf}}[n]$。由于输入信号是实数且滤波器是对称的，因此得到的时域信号必须是实数。任何残留的虚部都是由数值精度误差引起的，应予以丢弃。\n\n**4. 误差量化**\n\n信号 $y_{\\mathrm{lf}}[n]$ 代表了在经过采样和滤波后应有的“真实”低频内容，没有任何高频污染。信号 $y_{\\mathrm{total}}[n]$ 包含这个相同的真实内容，外加任何混叠到 $[0, 50]$ $\\mathrm{Hz}$ 通带内的高频分量。\n\n因此，差分信号 $y_{\\mathrm{total}}[n] - y_{\\mathrm{lf}}[n]$ 分离出了混叠污染。我们使用均方根误差 (RMSE) 来量化这种污染的幅度：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y_{\\mathrm{total}}[n] - y_{\\mathrm{lf}}[n]\\right)^2}\n$$\n该指标提供了一个稳健的度量，用于衡量由混叠引入的误差信号的平均功率。该过程被系统地应用于每个测试用例，以评估采样率 $f_s$ 的选择和特定的高频 $F_m$ 如何影响混叠的严重程度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates and quantifies aliasing in sampled neural signals.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'fs': 1000, 'Fm': [960, 980]},\n        {'fs': 500, 'Fm': [480, 495]},\n        {'fs': 200, 'Fm': [450]},\n        {'fs': 120, 'Fm': [115, 235]},\n        {'fs': 100, 'Fm': [99, 101, 199]},\n    ]\n\n    # Signal parameters\n    T = 2.0  # s\n    A1, f1 = 1.0, 8.0  # a.u., Hz\n    A2, f2 = 0.5, 30.0 # a.u., Hz\n    Bm_val = 0.8  # a.u.\n    f_band = 50.0  # Hz\n\n    def create_signal(t_samples, freq_list, amp):\n        \"\"\"Generates a sum of sinusoids.\"\"\"\n        signal = np.zeros_like(t_samples)\n        if not freq_list:\n            return signal\n        for f in freq_list:\n            # Using np.sin with a scalar amplitude\n            signal += amp * np.sin(2 * np.pi * f * t_samples)\n        return signal\n\n    def apply_ideal_lpf(signal_samples, fs, N, f_cutoff):\n        \"\"\"\n        Applies an ideal low-pass filter in the frequency domain.\n        \"\"\"\n        # 1. Compute DFT\n        dft_coeffs = np.fft.fft(signal_samples)\n        \n        # 2. Get frequency bins\n        freqs = np.fft.fftfreq(N, d=1.0/fs)\n        \n        # 3. Create mask to zero out frequencies above the cutoff\n        mask = np.abs(freqs) > f_cutoff\n        dft_coeffs[mask] = 0\n        \n        # 4. Compute Inverse DFT\n        filtered_signal = np.fft.ifft(dft_coeffs)\n        \n        # Return the real part to discard numerical noise\n        return np.real(filtered_signal)\n\n    results = []\n    \n    for case in test_cases:\n        fs = case['fs']\n        Fm_list = case['Fm']\n        \n        # Calculate number of samples\n        N = int(T * fs) # Per problem, floor is implicit as T*fs is integer\n        \n        # Create the discrete time vector\n        t_samples = np.arange(N) / fs\n        \n        # 1. Signal Synthesis and Sampling\n        # Low-frequency signal (s_lf[n])\n        s_lf_n = A1 * np.sin(2 * np.pi * f1 * t_samples) + \\\n                 A2 * np.sin(2 * np.pi * f2 * t_samples)\n\n        # High-frequency signal (s_hf[n])\n        s_hf_n = create_signal(t_samples, Fm_list, Bm_val)\n\n        # Total signal (x[n])\n        x_n = s_lf_n + s_hf_n\n        \n        # 2. Low-pass filtering\n        # Apply LPF to the reference low-frequency signal\n        y_lf_n = apply_ideal_lpf(s_lf_n, fs, N, f_band)\n        \n        # Apply LPF to the total signal\n        y_total_n = apply_ideal_lpf(x_n, fs, N, f_band)\n        \n        # 3. Quantify aliasing with RMSE\n        # The difference contains the aliased components\n        error_signal = y_total_n - y_lf_n\n        \n        # Calculate RMSE\n        rmse = np.sqrt(np.mean(error_signal**2))\n        \n        results.append(rmse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}