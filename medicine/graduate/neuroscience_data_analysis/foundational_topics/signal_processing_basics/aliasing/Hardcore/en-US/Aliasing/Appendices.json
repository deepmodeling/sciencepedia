{
    "hands_on_practices": [
        {
            "introduction": "Before we can simulate or prevent aliasing, we must first understand its mathematical basis. This exercise challenges you to derive the fundamental rule of frequency folding from first principles and apply it to a common scenario in electrophysiology—a high-frequency artifact contaminating a signal sampled at $f_s = 1000 \\text{ Hz}$ . Mastering this calculation for how an out-of-band frequency appears within the Nyquist interval $[0, f_s/2]$ is the first step toward building an intuition for how aliasing manifests in your data.",
            "id": "4137810",
            "problem": "A laboratory acquires a Local Field Potential (LFP) signal in a rodent hippocampus during a behavioral task. The acquisition system samples uniformly at rate $f_{s} = 1\\,\\mathrm{kHz}$. Due to an upstream device, a narrowband sinusoidal artifact at frequency $f = 780\\,\\mathrm{Hz}$ is present in the continuous-time signal prior to sampling. The analog anti-alias filter is misconfigured, so the artifact passes into the digitizer and aliases.\n\nStarting from the fundamental definition of uniform sampling and the discrete-time representation of continuous-time complex exponentials, derive the precise rule that characterizes when two continuous-time sinusoidal components $f$ and $f'$ produce identical discrete-time sequences upon sampling at rate $f_{s}$, using only integer multiples of $f_{s}$. Then, use this rule to determine the unique folded frequency of the $f = 780\\,\\mathrm{Hz}$ artifact inside the baseband interval $[0, f_{s}/2]$. Express the final folded frequency in $\\mathrm{Hz}$. No rounding is required; provide the exact value.",
            "solution": "The problem statement is first validated for correctness and completeness.\n\n### Step 1: Extract Givens\n- Uniform sampling rate: $f_{s} = 1\\,\\mathrm{kHz} = 1000\\,\\mathrm{Hz}$\n- Continuous-time artifact frequency: $f = 780\\,\\mathrm{Hz}$\n- Task 1: Derive the rule that characterizes when two continuous-time sinusoidal components $f$ and $f'$ produce identical discrete-time sequences upon sampling at rate $f_{s}$, using only integer multiples of $f_{s}$.\n- Task 2: Determine the unique folded frequency of the $f = 780\\,\\mathrm{Hz}$ artifact inside the baseband interval $[0, f_{s}/2]$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard scenario of aliasing in digital signal processing, a fundamental concept in engineering and data analysis. The provided values are realistic for electrophysiological recordings. The problem is self-contained, with all necessary information provided to derive the requested rule and compute the final value. There are no scientific or logical contradictions, ambiguities, or unrealistic conditions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\nThe problem asks for two parts: first, a derivation of the general condition for aliasing, and second, an application of this rule to find a specific folded frequency.\n\n**Part 1: Derivation of the Aliasing Rule**\n\nWe begin from the fundamental definition of uniform sampling. A continuous-time signal $x(t)$ is sampled at a rate $f_s$, which corresponds to a sampling period $T_s = 1/f_s$. The resulting discrete-time sequence, $x[n]$, consists of values of the continuous signal at integer multiples of $T_s$:\n$$x[n] = x(t)|_{t=nT_s} = x(nT_s)$$\nwhere $n$ is an integer.\n\nTo derive the condition for aliasing, it is most convenient to use complex exponentials, as any real sinusoid can be expressed as a sum of complex exponentials via Euler's formula ($\\cos(\\theta) = \\frac{1}{2}(\\exp(j\\theta) + \\exp(-j\\theta))$). The results derived for complex exponentials apply directly to real sinusoids.\n\nLet us consider a continuous-time complex exponential signal with frequency $f$:\n$$x_1(t) = \\exp(j2\\pi f t)$$\nUpon sampling at rate $f_s$, the discrete-time sequence is:\n$$x_1[n] = x_1(nT_s) = \\exp(j2\\pi f nT_s) = \\exp\\left(j2\\pi \\frac{f}{f_s} n\\right)$$\n\nNow, consider a second continuous-time complex exponential signal with a different frequency, $f'$:\n$$x_2(t) = \\exp(j2\\pi f' t)$$\nIts corresponding discrete-time sequence is:\n$$x_2[n] = x_2(nT_s) = \\exp(j2\\pi f' nT_s) = \\exp\\left(j2\\pi \\frac{f'}{f_s} n\\right)$$\n\nTwo continuous-time frequencies, $f$ and $f'$, are said to alias if they produce identical discrete-time sequences, i.e., if $x_1[n] = x_2[n]$ for all integers $n$. This requires:\n$$\\exp\\left(j2\\pi \\frac{f}{f_s} n\\right) = \\exp\\left(j2\\pi \\frac{f'}{f_s} n\\right)$$\nThe complex exponential function $\\exp(j\\theta)$ is periodic with period $2\\pi$. This means $\\exp(j\\theta) = \\exp(j(\\theta + 2\\pi k))$ for any integer $k$. Therefore, for the equality to hold for all $n$, the arguments of the exponentials must differ by an integer multiple of $2\\pi$ for each $n$. This implies that the normalized frequencies, $\\frac{f}{f_s}$ and $\\frac{f'}{f_s}$, must be related in a specific way.\nThe equality is satisfied if the coefficients of $n$ in the exponents differ by an integer.\n$$2\\pi \\frac{f}{f_s} = 2\\pi \\frac{f'}{f_s} + 2\\pi k$$\nfor some integer $k$. Dividing the entire equation by $2\\pi$ yields:\n$$\\frac{f}{f_s} = \\frac{f'}{f_s} + k$$\nMultiplying by $f_s$ gives the relationship between $f$ and $f'$:\n$$f = f' + k f_s$$\nThis is the rule: two continuous-time sinusoidal components with frequencies $f$ and $f'$ are indistinguishable after sampling at a rate $f_s$ if their frequencies differ by an integer multiple of the sampling rate $f_s$.\n\n**Part 2: Calculation of the Folded Frequency**\n\nWe are given the sampling rate $f_s = 1000\\,\\mathrm{Hz}$ and the artifact frequency $f = 780\\,\\mathrm{Hz}$. The problem asks for the unique \"folded frequency\" within the baseband interval $[0, f_s/2]$.\n\nThe baseband interval is $[0, 1000/2]\\,\\mathrm{Hz} = [0, 500]\\,\\mathrm{Hz}$.\n\nAccording to the rule derived above, the artifact at frequency $f$ will have an infinite number of aliases at frequencies $f_k'$ given by:\n$$f_k' = f + k f_s$$\nfor any integer $k \\in \\mathbb{Z}$.\n\nWe need to find the specific alias that falls into the principal alias range, which is the Nyquist interval $[-f_s/2, f_s/2]$. This interval is $[-500, 500]\\,\\mathrm{Hz}$. We must find an integer $k$ such that:\n$$-500 \\le f + k f_s \\le 500$$\nSubstituting the given values:\n$$-500 \\le 780 + k(1000) \\le 500$$\nTo find $k$, we solve the inequality:\n$$-500 - 780 \\le 1000k \\le 500 - 780$$\n$$-1280 \\le 1000k \\le -280$$\nDividing by $1000$:\n$$-1.28 \\le k \\le -0.28$$\nThe only integer $k$ that satisfies this inequality is $k=-1$.\n\nUsing $k=-1$, we can find the frequency of the principal alias, which we denote $f_{alias}$:\n$$f_{alias} = f + (-1)f_s = 780\\,\\mathrm{Hz} - 1000\\,\\mathrm{Hz} = -220\\,\\mathrm{Hz}$$\nThis frequency $f_{alias} = -220\\,\\mathrm{Hz}$ lies within the principal alias range $[-500, 500]\\,\\mathrm{Hz}$.\n\nThe problem, however, asks for the *folded frequency* in the non-negative interval $[0, f_s/2]$, which corresponds to how frequencies appear in a standard one-sided power spectrum of a real-valued signal. For real signals, the spectrum exhibits conjugate symmetry, meaning the magnitude spectrum is symmetric about $0\\,\\mathrm{Hz}$. A component at a negative frequency $-f_0$ is indistinguishable in magnitude from a component at the positive frequency $+f_0$.\n\nTherefore, the folded frequency $f_{folded}$ is the absolute value of the principal alias:\n$$f_{folded} = |f_{alias}| = |-220\\,\\mathrm{Hz}| = 220\\,\\mathrm{Hz}$$\nThis value, $220\\,\\mathrm{Hz}$, lies within the specified target interval $[0, 500]\\,\\mathrm{Hz}$. This is the unique folded frequency of the $780\\,\\mathrm{Hz}$ artifact.",
            "answer": "$$ \\boxed{220} $$"
        },
        {
            "introduction": "Theoretical understanding is crucial, but seeing aliasing in action provides a deeper insight into its practical consequences. In this exercise, you will write a simulation to create a synthetic neural signal, deliberately contaminate it with high-frequency components, and then sample it to induce aliasing . By quantifying the resulting distortion using the root-mean-square error (RMSE), you will gain a tangible appreciation for how aliasing corrupts the low-frequency bands of interest.",
            "id": "4137791",
            "problem": "You are asked to design and implement a complete, runnable program that simulates aliasing in sampled neural signals by injecting known high-frequency components into synthetic signals and quantifies the fold-in error for different sampling frequencies. The fundamental base of this problem is the Nyquist-Shannon sampling theorem (NSST), which asserts that a band-limited continuous-time signal with maximum frequency content below half the sampling frequency can be perfectly reconstructed from its samples. When a signal contains frequency components above the Nyquist frequency, sampling produces spectral replicas that overlap the baseband, causing aliasing.\n\nConstruct a continuous-time signal $x(t)$ as a sum of a low-frequency component $s_{\\mathrm{lf}}(t)$ and a high-frequency component $s_{\\mathrm{hf}}(t)$. Let the sampling frequency be $f_s$, the sampling period be $T_s = 1/f_s$, and the duration be $T$. The low-frequency component is defined by two sinusoids that are representative of typical neural oscillations:\n- $s_{\\mathrm{lf}}(t) = A_1 \\sin\\left(2\\pi f_1 t\\right) + A_2 \\sin\\left(2\\pi f_2 t\\right)$,\nwhere $f_1 = 8$ $\\mathrm{Hz}$ and $f_2 = 30$ $\\mathrm{Hz}$, with amplitudes $A_1 = 1$ $\\mathrm{a.u.}$ and $A_2 = 0.5$ $\\mathrm{a.u.}$. All angles must be treated in radians.\n\nThe high-frequency component is defined as a sum of sinusoids with frequencies strictly greater than the Nyquist frequency for the given $f_s$:\n- $s_{\\mathrm{hf}}(t) = \\sum_{m} B_m \\sin\\left(2\\pi F_m t\\right)$,\nwhere each $F_m$ is specified per test case and $B_m = 0.8$ $\\mathrm{a.u.}$ for all $m$. The total signal is $x(t) = s_{\\mathrm{lf}}(t) + s_{\\mathrm{hf}}(t)$.\n\nSample $x(t)$ at rate $f_s$ over duration $T$ to obtain discrete-time samples $x[n] = x(n T_s)$ for $n = 0, 1, \\dots, N-1$ with $N = \\lfloor T f_s \\rfloor$. Define an ideal low-pass reconstruction operator that zeros out all discrete Fourier transform bins above a band limit $f_{\\mathrm{band}} = 50$ $\\mathrm{Hz}$, and then performs an inverse transform to reconstruct a time-domain signal band-limited to $[0, f_{\\mathrm{band}}]$. Apply this operator to both the sampled total signal and the sampled low-frequency-only signal to obtain $y_{\\mathrm{total}}[n]$ and $y_{\\mathrm{lf}}[n]$, respectively.\n\nQuantify alias fold-in by computing the root-mean-square error (RMSE) between $y_{\\mathrm{total}}[n]$ and $y_{\\mathrm{lf}}[n]$:\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y_{\\mathrm{total}}[n] - y_{\\mathrm{lf}}[n]\\right)^2}.\n$$\nThis measures contamination of the target low-frequency band by aliased high-frequency content. Express the RMSE as a float in arbitrary units (a.u.).\n\nUse the following test suite, where all frequencies are in $\\mathrm{Hz}$, all amplitudes are in $\\mathrm{a.u.}$, the duration is $T = 2$ $\\mathrm{s}$, and angles are in radians:\n- Case $1$ (happy path with clear fold-in): $f_s = 1000$, $F_m \\in \\{960, 980\\}$.\n- Case $2$ (moderate sampling): $f_s = 500$, $F_m \\in \\{480, 495\\}$.\n- Case $3$ (alias at band edge): $f_s = 200$, $F_m \\in \\{450\\}$.\n- Case $4$ (near-Nyquist conditions): $f_s = 120$, $F_m \\in \\{115, 235\\}$.\n- Case $5$ (boundary stress: just below/above multiples): $f_s = 100$, $F_m \\in \\{99, 101, 199\\}$.\n\nYour program should compute the RMSE for each case and produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each result must be a float representing the RMSE in $\\mathrm{a.u.}$ for the corresponding case, in the same order as listed above.",
            "solution": "The problem statement has been rigorously validated against the specified criteria. It is scientifically sound, well-posed, objective, and contains all necessary information for a unique solution. The problem is a standard exercise in digital signal processing, specifically demonstrating the phenomenon of aliasing as dictated by the Nyquist-Shannon sampling theorem. The proposed methodology is correct and computationally feasible. We may therefore proceed with the solution.\n\nThe core of this problem lies in demonstrating and quantifying aliasing, a fundamental concept in signal processing. The Nyquist-Shannon sampling theorem states that a continuous-time signal with frequencies no higher than a maximum frequency $f_{\\mathrm{max}}$ can be perfectly reconstructed from its samples if the sampling frequency $f_s$ is strictly greater than twice the maximum frequency, i.e., $f_s  2 f_{\\mathrm{max}}$. The frequency $f_s/2$ is known as the Nyquist frequency, $f_{\\mathrm{Nyq}}$. If a signal contains frequency components above $f_{\\mathrm{Nyq}}$, these components are \"folded\" into the frequency range $[0, f_{\\mathrm{Nyq}}]$, corrupting the low-frequency content. This phenomenon is aliasing.\n\nThe solution is designed in four distinct steps: signal synthesis, sampling, frequency-domain filtering, and error quantification.\n\n**1. Signal Synthesis**\n\nWe construct a synthetic continuous-time signal $x(t)$ composed of two parts: a low-frequency component $s_{\\mathrm{lf}}(t)$ representing the signal of interest, and a high-frequency component $s_{\\mathrm{hf}}(t)$ representing contamination or noise.\n\nThe low-frequency signal $s_{\\mathrm{lf}}(t)$ is defined as the sum of two sinusoids with frequencies $f_1 = 8$ $\\mathrm{Hz}$ and $f_2 = 30$ $\\mathrm{Hz}$, which are well within the typical bands of interest for neural data (e.g., alpha and beta bands).\n$$\ns_{\\mathrm{lf}}(t) = A_1 \\sin(2\\pi f_1 t) + A_2 \\sin(2\\pi f_2 t)\n$$\nwith amplitudes $A_1 = 1$ and $A_2 = 0.5$ in arbitrary units (a.u.).\n\nThe high-frequency signal $s_{\\mathrm{hf}}(t)$ is a sum of sinusoids whose frequencies $F_m$ are explicitly chosen to be above the Nyquist frequency for each test case.\n$$\ns_{\\mathrm{hf}}(t) = \\sum_{m} B_m \\sin(2\\pi F_m t)\n$$\nwith amplitude $B_m = 0.8$ a.u. for all components.\n\nThe total signal is the linear superposition of these two components: $x(t) = s_{\\mathrm{lf}}(t) + s_{\\mathrm{hf}}(t)$.\n\n**2. Signal Sampling (Discretization)**\n\nThe continuous signals are sampled at a rate $f_s$ over a duration $T = 2$ $\\mathrm{s}$. This produces discrete-time sequences. The time instances for sampling are $t_n = n T_s = n/f_s$ for $n = 0, 1, \\dots, N-1$, where $N = \\lfloor T f_s \\rfloor$ is the total number of samples.\n\nWe generate two discrete-time signals:\n- The sampled total signal: $x[n] = x(t_n) = s_{\\mathrm{lf}}(t_n) + s_{\\mathrm{hf}}(t_n)$\n- The sampled reference low-frequency signal: $s_{\\mathrm{lf}}[n] = s_{\\mathrm{lf}}(t_n)$\n\nWhen sampled, a high-frequency sinusoid with frequency $F  f_{\\mathrm{Nyq}}$ masquerades as a low-frequency sinusoid with frequency $f_{\\mathrm{alias}}$ in the range $[0, f_{\\mathrm{Nyq}}]$. The aliased frequency is given by $f_{\\mathrm{alias}} = |F - k \\cdot f_s|$, where $k$ is an integer chosen such that $f_{\\mathrm{alias}} \\le f_{\\mathrm{Nyq}}$. This folding of the spectrum is the source of the error we aim to quantify.\n\n**3. Frequency-Domain Low-Pass Filtering**\n\nTo isolate the effect of aliasing within a specific band of interest, we apply an ideal low-pass filter with a cutoff frequency $f_{\\mathrm{band}} = 50$ $\\mathrm{Hz}$. This operation is performed in the frequency domain using the Discrete Fourier Transform (DFT), implemented via the Fast Fourier Transform (FFT) algorithm.\n\nFirst, we compute the DFT of the sampled signals $x[n]$ and $s_{\\mathrm{lf}}[n]$ to obtain their complex-valued spectra, $X[k]$ and $S_{\\mathrm{lf}}[k]$, respectively. The frequency corresponding to each DFT bin $k$ is determined by the sampling rate $f_s$ and the number of points $N$.\n\nThe ideal low-pass filter is implemented by creating a frequency mask. We identify all frequency bins corresponding to frequencies $|f|  f_{\\mathrm{band}}$ and set their corresponding DFT coefficients to zero. For a real-valued input signal, the DFT spectrum is conjugate symmetric, so the filter must be applied symmetrically to both positive and negative frequency components.\n\nLet $Y_{\\mathrm{total}}[k]$ and $Y_{\\mathrm{lf}}[k]$ be the filtered spectra. They are defined as:\n$$\nY[k] =\n\\begin{cases}\nX[k]  \\text{if } |f_k| \\le f_{\\mathrm{band}} \\\\\n0  \\text{if } |f_k|  f_{\\mathrm{band}}\n\\end{cases}\n$$\nwhere $X[k]$ is the original spectrum and $f_k$ is the frequency of the $k$-th bin.\n\nFinally, we apply the Inverse DFT (implemented via IFFT) to the filtered spectra $Y_{\\mathrm{total}}[k]$ and $Y_{\\mathrm{lf}}[k]$ to obtain the filtered time-domain signals, $y_{\\mathrm{total}}[n]$ and $y_{\\mathrm{lf}}[n]$. Because the input signals are real and the filter is symmetric, the resulting time-domain signals must be real. Any residual imaginary components are due to numerical precision errors and are discarded.\n\n**4. Error Quantification**\n\nThe signal $y_{\\mathrm{lf}}[n]$ represents the \"true\" low-frequency content as it would appear after sampling and filtering, without any high-frequency contamination. The signal $y_{\\mathrm{total}}[n]$ contains this same true content, plus any high-frequency components that aliased into the $[0, 50]$ $\\mathrm{Hz}$ passband.\n\nThe difference signal, $y_{\\mathrm{total}}[n] - y_{\\mathrm{lf}}[n]$, therefore isolates the aliased contamination. We quantify the magnitude of this contamination using the Root-Mean-Square Error (RMSE):\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y_{\\mathrm{total}}[n] - y_{\\mathrm{lf}}[n]\\right)^2}\n$$\nThis metric provides a robust measure of the average power of the error signal introduced by aliasing. The procedure is systematically applied to each test case to evaluate how the choice of sampling rate $f_s$ and the specific high frequencies $F_m$ affect the severity of aliasing.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates and quantifies aliasing in sampled neural signals.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'fs': 1000, 'Fm': [960, 980]},\n        {'fs': 500, 'Fm': [480, 495]},\n        {'fs': 200, 'Fm': [450]},\n        {'fs': 120, 'Fm': [115, 235]},\n        {'fs': 100, 'Fm': [99, 101, 199]},\n    ]\n\n    # Signal parameters\n    T = 2.0  # s\n    A1, f1 = 1.0, 8.0  # a.u., Hz\n    A2, f2 = 0.5, 30.0 # a.u., Hz\n    Bm_val = 0.8  # a.u.\n    f_band = 50.0  # Hz\n\n    def create_signal(t_samples, freq_list, amp):\n        \"\"\"Generates a sum of sinusoids.\"\"\"\n        signal = np.zeros_like(t_samples)\n        if not freq_list:\n            return signal\n        for f in freq_list:\n            # Using np.sin with a scalar amplitude\n            signal += amp * np.sin(2 * np.pi * f * t_samples)\n        return signal\n\n    def apply_ideal_lpf(signal_samples, fs, N, f_cutoff):\n        \"\"\"\n        Applies an ideal low-pass filter in the frequency domain.\n        \"\"\"\n        # 1. Compute DFT\n        dft_coeffs = np.fft.fft(signal_samples)\n        \n        # 2. Get frequency bins\n        freqs = np.fft.fftfreq(N, d=1.0/fs)\n        \n        # 3. Create mask to zero out frequencies above the cutoff\n        mask = np.abs(freqs)  f_cutoff\n        dft_coeffs[mask] = 0\n        \n        # 4. Compute Inverse DFT\n        filtered_signal = np.fft.ifft(dft_coeffs)\n        \n        # Return the real part to discard numerical noise\n        return np.real(filtered_signal)\n\n    results = []\n    \n    for case in test_cases:\n        fs = case['fs']\n        Fm_list = case['Fm']\n        \n        # Calculate number of samples\n        N = int(T * fs) # Per problem, floor is implicit as T*fs is integer\n        \n        # Create the discrete time vector\n        t_samples = np.arange(N) / fs\n        \n        # 1. Signal Synthesis and Sampling\n        # Low-frequency signal (s_lf[n])\n        s_lf_n = A1 * np.sin(2 * np.pi * f1 * t_samples) + \\\n                 A2 * np.sin(2 * np.pi * f2 * t_samples)\n\n        # High-frequency signal (s_hf[n])\n        s_hf_n = create_signal(t_samples, Fm_list, Bm_val)\n\n        # Total signal (x[n])\n        x_n = s_lf_n + s_hf_n\n        \n        # 2. Low-pass filtering\n        # Apply LPF to the reference low-frequency signal\n        y_lf_n = apply_ideal_lpf(s_lf_n, fs, N, f_band)\n        \n        # Apply LPF to the total signal\n        y_total_n = apply_ideal_lpf(x_n, fs, N, f_band)\n        \n        # 3. Quantify aliasing with RMSE\n        # The difference contains the aliased components\n        error_signal = y_total_n - y_lf_n\n        \n        # Calculate RMSE\n        rmse = np.sqrt(np.mean(error_signal**2))\n        \n        results.append(rmse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having understood and simulated aliasing, the final step is to learn how to prevent it. This practice guides you through the design of a Finite Impulse Response (FIR) anti-aliasing filter, the most critical tool for ensuring signal fidelity during data acquisition . You will translate performance specifications, such as passband ripple and stopband attenuation, into a practical digital filter and verify that it meets the required criteria for protecting neural recordings from high-frequency contamination.",
            "id": "4137766",
            "problem": "You are analyzing extracellular neural recordings that are being digitized at a sampling frequency $f_s = 2\\,000\\ \\mathrm{Hz}$. To prevent aliasing of high-frequency noise and muscle artifacts into the neural band during acquisition and potential downsampling, you must design a Finite Impulse Response (FIR) anti-alias low-pass filter whose passband is $[0,400]\\ \\mathrm{Hz}$, whose stopband starts at $450\\ \\mathrm{Hz}$, whose passband ripple is bounded by $0.1\\ \\mathrm{dB}$ or less, and whose stopband attenuation is at least $60\\ \\mathrm{dB}$. Your task is to estimate the minimum FIR filter order required using standard approximation methods, then construct a candidate equiripple FIR filter of that order and evaluate whether it meets the specifications.\n\nStarting from fundamental bases appropriate to neuroscience data analysis:\n- The Nyquist–Shannon sampling theorem states that a discrete-time system sampled at frequency $f_s$ can represent frequency content up to the Nyquist frequency $f_N = f_s/2$ without aliasing. Aliasing occurs when signal content above $f_N$ is not sufficiently attenuated prior to sampling or downsampling and folds into lower frequencies.\n- A linear time-invariant FIR filter $h[n]$ has a frequency response $H(\\omega)$ obtained by the discrete-time Fourier transform, and its magnitude response in the passband should be close to unity with bounded ripple, while the stopband should provide sufficient attenuation to suppress out-of-band content.\n- Widely used engineering approximations relate the allowable amplitude ripple in the passband and stopband (in linear units) to specifications in decibels. The allowable ripple values, together with the transition width in digital radians per sample, determine an estimated FIR order via a standard window-based bound, which can be used as an order estimate for equiripple design.\n\nYour program must:\n1. Convert passband ripple and stopband attenuation specifications from decibels to linear tolerances appropriate for amplitude constraints. Let the passband ripple be $R_p$ (in $\\mathrm{dB}$) and stopband attenuation be $A_s$ (in $\\mathrm{dB}$). Define the linear passband tolerance $\\delta_p$ and the linear stopband tolerance $\\delta_s$ based on $R_p$ and $A_s$ respectively. Use the tightest tolerance $\\delta = \\min(\\delta_p,\\delta_s)$ to define the design attenuation in decibels $A$.\n2. Compute the digital transition width $\\Delta \\Omega$ in radians per sample from the transition band width $\\Delta f = f_{\\mathrm{stop,start}} - f_{\\mathrm{pass,end}}$ and sampling frequency $f_s$, i.e., $\\Delta \\Omega$ derived from $\\Delta f$ and $f_s$.\n3. Estimate the minimum FIR order $N_{\\mathrm{est}}$ using standard, widely accepted approximation methods that relate $A$ and $\\Delta \\Omega$ to the order of a linear-phase FIR filter. Use the ceiling to ensure the estimated order is an integer that should meet or exceed the constraints.\n4. For each test case, design an equiripple low-pass FIR filter with $N_{\\mathrm{est}}+1$ taps (filter length), passband $[0,f_{\\mathrm{pass,end}}]$, and stopband $[f_{\\mathrm{stop,start}}, f_N]$, weighting the passband and stopband error according to $\\delta_p$ and $\\delta_s$. Evaluate its magnitude response to compute:\n   - The maximum absolute passband deviation in decibels from $0\\ \\mathrm{dB}$ over $[0, f_{\\mathrm{pass,end}}]$.\n   - The achieved stopband attenuation in decibels computed as $-20\\log_{10}\\left(\\max_{f \\in [f_{\\mathrm{stop,start}}, f_N]} |H(f)|\\right)$.\n   Declare that the design meets the specifications if the passband deviation is $\\le R_p$ and the achieved stopband attenuation is $\\ge A_s$.\n5. Output, for each test case, the triple $[N_{\\mathrm{est}}, N_{\\mathrm{used}}, \\text{meets}]$ where $N_{\\mathrm{used}} = N_{\\mathrm{est}}$, and $\\text{meets}$ is a boolean indicating whether the designed filter meets the specifications when evaluated with sufficiently fine frequency resolution.\n\nTest suite:\nProvide solutions for the following parameter sets, expressed in $\\mathrm{Hz}$ and $\\mathrm{dB}$:\n- Case $1$ (happy path): $f_s = 2\\,000$, $f_{\\mathrm{pass,end}} = 400$, $f_{\\mathrm{stop,start}} = 450$, $R_p = 0.1$, $A_s = 60$.\n- Case $2$ (balanced tolerances): $f_s = 2\\,000$, $f_{\\mathrm{pass,end}} = 700$, $f_{\\mathrm{stop,start}} = 750$, $R_p = 0.086427$, $A_s = 40$.\n- Case $3$ (narrow transition, high attenuation): $f_s = 2\\,000$, $f_{\\mathrm{pass,end}} = 475$, $f_{\\mathrm{stop,start}} = 500$, $R_p = 0.05$, $A_s = 80$.\n- Case $4$ (low attenuation, wide transition): $f_s = 2\\,000$, $f_{\\mathrm{pass,end}} = 600$, $f_{\\mathrm{stop,start}} = 800$, $R_p = 1.0$, $A_s = 20$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list $[N_{\\mathrm{est}},N_{\\mathrm{used}},\\text{meets}]$ for each test case in the order listed above. For example, the output must have the form $[[n_1,n_1,\\text{True}],[n_2,n_2,\\text{False}],\\dots]$ with integers and booleans only, using the exact characters and delimiters shown.",
            "solution": "The user requests a solution to a problem in digital signal processing, specifically the design and verification of a Finite Impulse Response (FIR) anti-alias low-pass filter for neuroscience data. The problem is scientifically grounded, well-posed, and provides all necessary parameters and constraints for a unique solution. It is a standard exercise in filter design.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Sampling frequency: $f_s$\n- Passband edge frequency: $f_{\\mathrm{pass,end}}$\n- Stopband edge frequency: $f_{\\mathrm{stop,start}}$\n- Maximum passband ripple: $R_p$ (in $\\mathrm{dB}$)\n- Minimum stopband attenuation: $A_s$ (in $\\mathrm{dB}$)\n- Nyquist frequency definition: $f_N = f_s/2$\n- FIR filter design method: Equiripple (Parks-McClellan)\n- FIR order estimation method: A standard approximation using a single attenuation value $A$ derived from $\\delta = \\min(\\delta_p, \\delta_s)$, and the digital transition width $\\Delta \\Omega$.\n- Test cases:\n    1. $f_s = 2000$, $f_{\\mathrm{pass,end}} = 400$, $f_{\\mathrm{stop,start}} = 450$, $R_p = 0.1$, $A_s = 60$.\n    2. $f_s = 2000$, $f_{\\mathrm{pass,end}} = 700$, $f_{\\mathrm{stop,start}} = 750$, $R_p = 0.086427$, $A_s = 40$.\n    3. $f_s = 2000$, $f_{\\mathrm{pass,end}} = 475$, $f_{\\mathrm{stop,start}} = 500$, $R_p = 0.05$, $A_s = 80$.\n    4. $f_s = 2000$, $f_{\\mathrm{pass,end}} = 600$, $f_{\\mathrm{stop,start}} = 800$, $R_p = 1.0$, $A_s = 20$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is based on the fundamental principles of digital signal processing (DSP), including the Nyquist-Shannon sampling theorem, FIR filter theory, and standard design specifications (passband/stopband ripple, attenuation). These are core concepts in electrical engineering and data analysis. The application to neuroscience is appropriate and realistic.\n- **Well-Posed:** The problem provides a clear, quantitative objective and all necessary data for each test case. The specified procedures for estimation and design are standard and lead to a unique, verifiable solution.\n- **Objective:** The language is precise and technical, free of subjectivity or ambiguity.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n### Principle-Based Solution Design\n\nThe design and verification of the FIR anti-alias filter proceed through four principal stages, as detailed below.\n\n**1. Conversion of Specifications to Linear Tolerances**\nThe filter specifications are given in decibels ($\\mathrm{dB}$), which is a logarithmic scale convenient for representing wide dynamic ranges. However, filter design algorithms like the Parks-McClellan algorithm operate on linear amplitude tolerances. We must convert the passband ripple $R_p$ and stopband attenuation $A_s$ into linear deviation parameters $\\delta_p$ and $\\delta_s$.\n\n- The passband tolerance, $\\delta_p$, defines the maximum allowable deviation from the desired unity gain ($1$, or $0\\ \\mathrm{dB}$). The specification on the passband deviation from $0\\ \\mathrm{dB}$ is $R_p$. We relate this to $\\delta_p$ by the equation:\n  $$R_p = 20 \\log_{10}(1 + \\delta_p)$$\n  Solving for $\\delta_p$ yields:\n  $$\\delta_p = 10^{R_p/20} - 1$$\n\n- The stopband tolerance, $\\delta_s$, defines the maximum permissible amplitude in the stopband. The stopband attenuation, $A_s$, is related to $\\delta_s$ by:\n  $$A_s = -20 \\log_{10}(\\delta_s)$$\n  Solving for $\\delta_s$ gives:\n  $$\\delta_s = 10^{-A_s/20}$$\n\n**2. Estimation of Minimum Filter Order**\nThe order of an FIR filter, $N$, determines its length ($N+1$ coefficients or \"taps\") and is the primary factor governing its ability to meet performance specifications. A sharper transition between the passband and stopband, and/or higher attenuation, requires a higher order. The problem asks for an estimation based on a standard approximation. We use Kaiser's empirical formula, which relates the filter order to the transition bandwidth and required attenuation:\n$$N \\ge \\frac{A - 8}{2.285 \\Delta\\Omega}$$\nwhere:\n- $N$ is the filter order. We take the ceiling of the result, $N_{\\mathrm{est}} = \\lceil\\frac{A-8}{2.285\\Delta\\Omega}\\rceil$, to ensure the order is an integer sufficient to meet the specification.\n- $A$ is the required attenuation in $\\mathrm{dB}$, defined using the more stringent of the two tolerances: $A = -20 \\log_{10}(\\min(\\delta_p, \\delta_s))$.\n- $\\Delta\\Omega$ is the normalized digital transition width in radians per sample. It is calculated from the analog transition width $\\Delta f = f_{\\mathrm{stop,start}} - f_{\\mathrm{pass,end}}$ and the sampling frequency $f_s$:\n  $$\\Delta\\Omega = 2\\pi \\frac{\\Delta f}{f_s}$$\n\n**3. Equiripple FIR Filter Synthesis**\nWith the estimated order $N_{\\mathrm{est}}$, we design the filter using the Parks-McClellan algorithm. This algorithm finds the optimal set of $N_{\\mathrm{est}}+1$ filter coefficients that minimizes the maximum weighted approximation error across the specified frequency bands. This results in an \"equiripple\" frequency response, where the error ripples are of equal magnitude in the passband and stopband (when weighted).\nThe algorithm requires the following inputs:\n- **Number of taps:** $N_{\\mathrm{est}}+1$.\n- **Frequency bands:** For a low-pass filter, these are the passband $[0, f_{\\mathrm{pass,end}}]$ and the stopband $[f_{\\mathrm{stop,start}}, f_N]$, where $f_N = f_s/2$ is the Nyquist frequency. These are normalized by $f_N$.\n- **Desired response:** $[1, 0]$ corresponding to unity gain in the passband and zero gain in the stopband.\n- **Weights:** The weights for each band are set to be inversely proportional to the desired tolerances to ensure the algorithm strives to meet the specifications. To achieve maximum errors of $\\delta_p$ and $\\delta_s$ in the two bands, the ratio of stopband weight $W_s$ to passband weight $W_p$ must be $W_s/W_p = \\delta_p/\\delta_s$. We can set the weights as $[1, \\delta_p/\\delta_s]$.\n\n**4. Performance Verification**\nThe filter designed using the estimated order $N_{\\mathrm{est}}$ is a candidate. Its actual performance must be rigorously evaluated to confirm it meets the original specifications. This is done by computing the filter's magnitude frequency response $|H(f)|$ at a high resolution and measuring its characteristics.\n- The frequency response is computed using the Fast Fourier Transform (FFT) on the filter's impulse response $h[n]$.\n- **Passband Verification:** The maximum absolute deviation from $0\\ \\mathrm{dB}$ is found across the passband frequency range $[0, f_{\\mathrm{pass,end}}]$:\n  $$R_{p, \\text{actual}} = \\max_{f \\in [0, f_{\\mathrm{pass,end}}]} |20 \\log_{10}(|H(f)|)|$$\n  The filter meets the passband specification if $R_{p, \\text{actual}} \\le R_p$.\n- **Stopband Verification:** The achieved stopband attenuation is calculated from the maximum linear magnitude in the stopband $[f_{\\mathrm{stop,start}}, f_N]$:\n  $$A_{s, \\text{actual}} = -20 \\log_{10} \\left( \\max_{f \\in [f_{\\mathrm{stop,start}}, f_N]} |H(f)| \\right)$$\n  The filter meets the stopband specification if $A_{s, \\text{actual}} \\ge A_s$.\n\nA boolean flag, $\\text{meets}$, is set to true if and only if both the passband and stopband specifications are met. The final output for each case is the triplet $[N_{\\mathrm{est}}, N_{\\mathrm{used}}, \\text{meets}]$, where $N_{\\mathrm{used}} = N_{\\mathrm{est}}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal as sp_signal\n\ndef solve():\n    \"\"\"\n    Solves the FIR filter design and verification problem for a given set of test cases.\n    \"\"\"\n    \n    # Test cases: (fs, f_pass_end, f_stop_start, R_p, A_s)\n    test_cases = [\n        # Case 1 (happy path)\n        (2000.0, 400.0, 450.0, 0.1, 60.0),\n        # Case 2 (balanced tolerances)\n        (2000.0, 700.0, 750.0, 0.086427, 40.0),\n        # Case 3 (narrow transition, high attenuation)\n        (2000.0, 475.0, 500.0, 0.05, 80.0),\n        # Case 4 (low attenuation, wide transition)\n        (2000.0, 600.0, 800.0, 1.0, 20.0),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        f_s, f_pass_end, f_stop_start, R_p, A_s = case\n\n        # Step 1: Convert passband ripple and stopband attenuation from dB to linear tolerances.\n        # R_p = 20 * log10(1 + delta_p) = delta_p = 10^(R_p/20) - 1\n        delta_p = 10**(R_p / 20.0) - 1\n        # A_s = -20 * log10(delta_s) = delta_s = 10^(-A_s/20)\n        delta_s = 10**(-A_s / 20.0)\n\n        # Step 2: Compute digital transition width and design attenuation for order estimation.\n        # Transition width in Hz\n        delta_f = f_stop_start - f_pass_end\n        # Digital transition width in radians per sample\n        delta_omega = 2.0 * np.pi * delta_f / f_s\n        \n        # Design attenuation A based on the tightest tolerance, as per problem spec\n        A = -20.0 * np.log10(min(delta_p, delta_s))\n\n        # Step 3: Estimate minimum FIR order using Kaiser's approximation.\n        # N_est = (A - 8) / (2.285 * delta_omega)\n        # We use ceil to ensure the order is sufficient.\n        N_est = int(np.ceil((A - 8.0) / (2.285 * delta_omega)))\n        \n        # The problem specifies using N_est as the order for the candidate filter.\n        N_used = N_est\n\n        # Step 4: Design an equiripple FIR filter and evaluate its performance.\n        num_taps = N_used + 1\n        nyquist_freq = f_s / 2.0\n        \n        # Define bands for remez: [passband_edge, stopband_edge] normalized to Nyquist freq.\n        bands = [0, f_pass_end, f_stop_start, nyquist_freq]\n        \n        # Define desired response for each band: [passband_gain, stopband_gain]\n        desired = [1, 0]\n        \n        # Define weights for each band. The ratio should be Ws/Wp = delta_p/delta_s.\n        weights = [1.0, delta_p / delta_s]\n\n        # Design the equiripple filter using the Parks-McClellan algorithm\n        try:\n            fir_coeffs = sp_signal.remez(num_taps, bands, desired, weight=weights, fs=f_s)\n        except ValueError:\n            # remez can fail if specs are impossible for the given order, although unlikely here.\n            # Or if N_est is too low, resulting in not enough extrema.\n            # Handle this gracefully by marking as not meeting specs.\n            results.append([N_est, N_used, False])\n            continue\n\n        # Evaluate the filter's frequency response with high resolution\n        num_freq_points = 16384\n        w, h_freq_response = sp_signal.freqz(fir_coeffs, worN=num_freq_points)\n        \n        # Convert angular frequencies (rad/sample) to Hz\n        freqs_hz = w * f_s / (2.0 * np.pi)\n\n        # Evaluate passband performance\n        passband_indices = np.where(freqs_hz = f_pass_end)[0]\n        passband_magnitudes_db = 20.0 * np.log10(np.abs(h_freq_response[passband_indices]))\n        \n        # Max absolute deviation from 0 dB in the passband\n        actual_passband_ripple_db = np.max(np.abs(passband_magnitudes_db))\n        \n        # Evaluate stopband performance\n        stopband_indices = np.where(freqs_hz = f_stop_start)[0]\n        # Max magnitude in stopband\n        max_stopband_magnitude = np.max(np.abs(h_freq_response[stopband_indices]))\n        \n        # Achieved attenuation in dB\n        actual_stopband_attenuation_db = -20.0 * np.log10(max_stopband_magnitude)\n        \n        # Check if specifications are met\n        meets_passband = actual_passband_ripple_db = R_p\n        meets_stopband = actual_stopband_attenuation_db = A_s\n        meets_specs = bool(meets_passband and meets_stopband)\n        \n        results.append([N_est, N_used, meets_specs])\n\n    # Final print statement in the exact required format.\n    # The default str() for a list uses spaces. We build the string manually.\n    result_strings = []\n    for res in results:\n        # Format each inner list as '[val1,val2,BoolVal]'\n        result_strings.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}