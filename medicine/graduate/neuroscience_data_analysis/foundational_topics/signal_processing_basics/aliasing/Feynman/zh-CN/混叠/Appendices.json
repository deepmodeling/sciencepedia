{
    "hands_on_practices": [
        {
            "introduction": "掌握混叠现象的第一步是理解其数学基础。本练习将通过一个在电生理学记录中常见的场景，引导您从第一性原理推导出频率折叠的基本规则。通过完成这个练习，您将能够精确计算出超出奈奎斯特频率的信号分量在采样后会“伪装”成哪个低频信号，这是所有混叠分析的基石。",
            "id": "4137810",
            "problem": "一个实验室在一次行为任务中，从一只啮齿动物的海马体中采集了局部场电位（LFP）信号。采集系统以 $f_{s} = 1\\,\\mathrm{kHz}$ 的速率进行均匀采样。由于上游设备的影响，采样前的连续时间信号中存在一个频率为 $f = 780\\,\\mathrm{Hz}$ 的窄带正弦伪影。模拟抗混叠滤波器配置错误，导致该伪影进入数字化仪并发生混叠。\n\n从均匀采样的基本定义以及连续时间复指数的离散时间表示出发，推导出一个精确法则，该法则描述了两个连续时间正弦分量 $f$ 和 $f'$ 在以采样率 $f_{s}$ 采样时，如何产生相同的离散时间序列，且仅使用 $f_{s}$ 的整数倍。然后，使用该法则确定 $f = 780\\,\\mathrm{Hz}$ 的伪影在基带区间 $[0, f_{s}/2]$ 内的唯一折叠频率。以 $\\mathrm{Hz}$ 为单位表示最终的折叠频率。无需四舍五入，请提供精确值。",
            "solution": "首先验证问题陈述的正确性和完整性。\n\n### 第 1 步：提取已知条件\n- 均匀采样率：$f_{s} = 1\\,\\mathrm{kHz} = 1000\\,\\mathrm{Hz}$\n- 连续时间伪影频率：$f = 780\\,\\mathrm{Hz}$\n- 任务 1：推导一个精确法则，该法则描述了两个连续时间正弦分量 $f$ 和 $f'$ 在以采样率 $f_{s}$ 采样时，如何产生相同的离散时间序列，且仅使用 $f_{s}$ 的整数倍。\n- 任务 2：确定 $f = 780\\,\\mathrm{Hz}$ 的伪影在基带区间 $[0, f_{s}/2]$ 内的唯一折叠频率。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据，提法恰当且客观。它描述了数字信号处理中一个标准的混叠场景，这是工程和数据分析中的一个基本概念。所提供的值对于电生理记录是符合实际的。该问题是自洽的，提供了推导所求法则和计算最终值所需的所有信息。不存在科学或逻辑上的矛盾、歧义或不切实际的条件。\n\n### 第 3 步：结论与行动\n问题有效。将提供完整的解答。\n\n### 解题推导\n该问题要求两部分：首先，推导混叠的一般条件；其次，应用该法则找出一个特定的折叠频率。\n\n**第 1 部分：混叠法则的推导**\n\n我们从均匀采样的基本定义开始。一个连续时间信号 $x(t)$ 以采样率 $f_s$ 进行采样，这对应于一个采样周期 $T_s = 1/f_s$。得到的离散时间序列 $x[n]$ 由连续信号在 $T_s$ 整数倍时刻的值组成：\n$$x[n] = x(t)|_{t=nT_s} = x(nT_s)$$\n其中 $n$ 是一个整数。\n\n为了推导混叠条件，使用复指数最为方便，因为任何实正弦波都可以通过欧拉公式（$\\cos(\\theta) = \\frac{1}{2}(\\exp(j\\theta) + \\exp(-j\\theta))$）表示为复指数之和。为复指数推导出的结果直接适用于实正弦波。\n\n让我们考虑一个频率为 $f$ 的连续时间复指数信号：\n$$x_1(t) = \\exp(j2\\pi f t)$$\n以采样率 $f_s$ 采样后，离散时间序列为：\n$$x_1[n] = x_1(nT_s) = \\exp(j2\\pi f nT_s) = \\exp\\left(j2\\pi \\frac{f}{f_s} n\\right)$$\n\n现在，考虑第二个频率为 $f'$ 的连续时间复指数信号：\n$$x_2(t) = \\exp(j2\\pi f' t)$$\n其对应的离散时间序列为：\n$$x_2[n] = x_2(nT_s) = \\exp(j2\\pi f' nT_s) = \\exp\\left(j2\\pi \\frac{f'}{f_s} n\\right)$$\n\n如果两个连续时间频率 $f$ 和 $f'$ 产生相同的离散时间序列，即对所有整数 $n$ 都有 $x_1[n] = x_2[n]$，我们称它们发生了混叠。这要求：\n$$\\exp\\left(j2\\pi \\frac{f}{f_s} n\\right) = \\exp\\left(j2\\pi \\frac{f'}{f_s} n\\right)$$\n复指数函数 $\\exp(j\\theta)$ 的周期为 $2\\pi$。这意味着对于任何整数 $k$，都有 $\\exp(j\\theta) = \\exp(j(\\theta + 2\\pi k))$。因此，为了使等式对所有 $n$ 都成立，指数的参数对于每个 $n$ 必须相差 $2\\pi$ 的整数倍。这意味着归一化频率 $\\frac{f}{f_s}$ 和 $\\frac{f'}{f_s}$ 必须以一种特定的方式关联。\n如果指数中 $n$ 的系数相差一个整数，则等式成立。\n$$2\\pi \\frac{f}{f_s} = 2\\pi \\frac{f'}{f_s} + 2\\pi k$$\n对于某个整数 $k$。将整个方程除以 $2\\pi$ 得到：\n$$\\frac{f}{f_s} = \\frac{f'}{f_s} + k$$\n两边乘以 $f_s$ 得到 $f$ 和 $f'$ 之间的关系：\n$$f = f' + k f_s$$\n这就是该法则：如果两个频率为 $f$ 和 $f'$ 的连续时间正弦分量在以采样率 $f_s$ 采样后无法区分，那么它们的频率相差采样率 $f_s$ 的整数倍。\n\n**第 2 部分：折叠频率的计算**\n\n我们已知采样率 $f_s = 1000\\,\\mathrm{Hz}$ 和伪影频率 $f = 780\\,\\mathrm{Hz}$。问题要求在基带区间 $[0, f_s/2]$ 内唯一的“折叠频率”。\n\n基带区间为 $[0, 1000/2]\\,\\mathrm{Hz} = [0, 500]\\,\\mathrm{Hz}$。\n\n根据上面推导的法则，频率为 $f$ 的伪影将有无数个混叠频率 $f_k'$，由下式给出：\n$$f_k' = f + k f_s$$\n对于任何整数 $k \\in \\mathbb{Z}$。\n\n我们需要找到落入主混叠范围，即奈奎斯特区间 $[-f_s/2, f_s/2]$ 内的特定混叠。该区间为 $[-500, 500]\\,\\mathrm{Hz}$。我们必须找到一个整数 $k$ 使得：\n$$-500 \\le f + k f_s \\le 500$$\n代入给定值：\n$$-500 \\le 780 + k(1000) \\le 500$$\n为了找到 $k$，我们解这个不等式：\n$$-500 - 780 \\le 1000k \\le 500 - 780$$\n$$-1280 \\le 1000k \\le -280$$\n除以 $1000$：\n$$-1.28 \\le k \\le -0.28$$\n满足这个不等式的唯一整数 $k$ 是 $k=-1$。\n\n使用 $k=-1$，我们可以找到主混叠的频率，我们将其表示为 $f_{alias}$：\n$$f_{alias} = f + (-1)f_s = 780\\,\\mathrm{Hz} - 1000\\,\\mathrm{Hz} = -220\\,\\mathrm{Hz}$$\n这个频率 $f_{alias} = -220\\,\\mathrm{Hz}$ 位于主混叠范围 $[-500, 500]\\,\\mathrm{Hz}$ 内。\n\n然而，问题要求的是在非负区间 $[0, f_s/2]$ 内的*折叠频率*，这对应于频率在实值信号的标准单边功率谱中的表现形式。对于实信号，频谱表现出共轭对称性，意味着幅度谱关于 $0\\,\\mathrm{Hz}$ 对称。一个在负频率 $-f_0$ 的分量在幅度上与一个在正频率 $+f_0$ 的分量是无法区分的。\n\n因此，折叠频率 $f_{folded}$ 是主混叠频率的绝对值：\n$$f_{folded} = |f_{alias}| = |-220\\,\\mathrm{Hz}| = 220\\,\\mathrm{Hz}$$\n这个值 $220\\,\\mathrm{Hz}$ 位于指定的目标区间 $[0, 500]\\,\\mathrm{Hz}$ 内。这就是 $780\\,\\mathrm{Hz}$ 伪影的唯一折叠频率。",
            "answer": "$$ \\boxed{220} $$"
        },
        {
            "introduction": "在掌握了单个频率混叠的理论计算之后，下一步是观察并量化其在更复杂信号中的影响。本练习要求您编写一个仿真程序，将已知的高频成分注入一个模拟的神经信号中，并观察在不同采样率下这些高频成分如何“折叠”进我们感兴趣的低频段。通过计算均方根误差（RMSE），您将学会一种量化混叠污染程度的实用方法，从而将抽象的理论转化为可度量的实践。",
            "id": "4137791",
            "problem": "要求您设计并实现一个完整的、可运行的程序，通过将已知的高频分量注入合成信号中，来模拟采样神经信号中的混叠现象，并量化不同采样频率下的折叠误差。该问题的根本基础是奈奎斯特-香农采样定理 (Nyquist-Shannon sampling theorem, NSST)，该定理断言，一个最大频率含量低于采样频率一半的带限连续时间信号，可以从其样本中完美重建。当信号包含高于奈奎斯特频率的频率分量时，采样会产生与基带重叠的频谱副本，从而导致混叠。\n\n构建一个连续时间信号 $x(t)$，作为低频分量 $s_{\\mathrm{lf}}(t)$ 和高频分量 $s_{\\mathrm{hf}}(t)$ 的和。设采样频率为 $f_s$，采样周期为 $T_s = 1/f_s$，持续时间为 $T$。低频分量由两个代表典型神经振荡的正弦波定义：\n- $s_{\\mathrm{lf}}(t) = A_1 \\sin\\left(2\\pi f_1 t\\right) + A_2 \\sin\\left(2\\pi f_2 t\\right)$,\n其中 $f_1 = 8$ $\\mathrm{Hz}$ 和 $f_2 = 30$ $\\mathrm{Hz}$，振幅 $A_1 = 1$ $\\mathrm{a.u.}$ 和 $A_2 = 0.5$ $\\mathrm{a.u.}$。所有角度必须以弧度处理。\n\n高频分量定义为频率严格大于给定 $f_s$ 的奈奎斯特频率的正弦波之和：\n- $s_{\\mathrm{hf}}(t) = \\sum_{m} B_m \\sin\\left(2\\pi F_m t\\right)$,\n其中每个 $F_m$ 按测试用例指定，$B_m = 0.8$ $\\mathrm{a.u.}$ 对所有 $m$ 成立。总信号为 $x(t) = s_{\\mathrm{lf}}(t) + s_{\\mathrm{hf}}(t)$。\n\n在持续时间 $T$ 内以速率 $f_s$ 对 $x(t)$ 进行采样，以获得离散时间样本 $x[n] = x(n T_s)$，其中 $n = 0, 1, \\dots, N-1$ 且 $N = \\lfloor T f_s \\rfloor$。定义一个理想的低通重构算子，该算子将所有高于频带限制 $f_{\\mathrm{band}} = 50$ $\\mathrm{Hz}$ 的离散傅里叶变换单元（bins）置零，然后执行逆变换以重构一个带限于 $[0, f_{\\mathrm{band}}]$ 的时域信号。将此算子分别应用于采样后的总信号和仅含低频的采样信号，以获得 $y_{\\mathrm{total}}[n]$ 和 $y_{\\mathrm{lf}}[n]$。\n\n通过计算 $y_{\\mathrm{total}}[n]$ 和 $y_{\\mathrm{lf}}[n]$ 之间的均方根误差 (RMSE) 来量化混叠折叠：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y_{\\mathrm{total}}[n] - y_{\\mathrm{lf}}[n]\\right)^2}.\n$$\n这衡量了目标低频带被混叠的高频内容污染的程度。将 RMSE 表示为以任意单位 (a.u.) 为单位的浮点数。\n\n使用以下测试套件，其中所有频率单位为 $\\mathrm{Hz}$，所有振幅单位为 $\\mathrm{a.u.}$，持续时间为 $T = 2$ $\\mathrm{s}$，角度单位为弧度：\n- 情况 1 (具有明显折叠的理想路径)：$f_s = 1000$, $F_m \\in \\{960, 980\\}$。\n- 情况 2 (中等采样)：$f_s = 500$, $F_m \\in \\{480, 495\\}$。\n- 情况 3 (频带边缘的混叠)：$f_s = 200$, $F_m \\in \\{450\\}$。\n- 情况 4 (近奈奎斯特条件)：$f_s = 120$, $F_m \\in \\{115, 235\\}$。\n- 情况 5 (边界压力测试：略低于/高于倍数)：$f_s = 100$, $F_m \\in \\{99, 101, 199\\}$。\n\n您的程序应计算每种情况的 RMSE，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果 (例如, \"[result1,result2,result3]\")。每个结果必须是代表相应情况的 RMSE 的浮点数 (单位为 a.u.)，顺序与上面列出的一致。",
            "solution": "问题陈述已根据指定标准进行了严格验证。它在科学上是合理的，问题定义清晰，客观，并包含唯一解所需的所有必要信息。该问题是数字信号处理中的一个标准练习，旨在具体展示由奈奎斯特-香农采样定理所决定的混叠现象。所提出的方法是正确的且计算上可行。因此，我们可以继续进行求解。\n\n这个问题的核心在于演示和量化混叠，这是信号处理中的一个基本概念。奈奎斯特-香农采样定理指出，如果采样频率 $f_s$ 严格大于最大频率的两倍，即 $f_s > 2 f_{\\mathrm{max}}$，那么一个频率不高于最大频率 $f_{\\mathrm{max}}$ 的连续时间信号可以从其样本中完美重建。频率 $f_s/2$ 被称为奈奎斯特频率, $f_{\\mathrm{Nyq}}$。如果一个信号包含高于 $f_{\\mathrm{Nyq}}$ 的频率分量，这些分量将被“折叠”到频率范围 $[0, f_{\\mathrm{Nyq}}]$ 内，从而破坏低频内容。这种现象就是混叠。\n\n解决方案设计为四个不同的步骤：信号合成、采样、频域滤波和误差量化。\n\n**1. 信号合成**\n\n我们构建一个合成的连续时间信号 $x(t)$，它由两部分组成：代表目标信号的低频分量 $s_{\\mathrm{lf}}(t)$ 和代表污染或噪声的高频分量 $s_{\\mathrm{hf}}(t)$。\n\n低频信号 $s_{\\mathrm{lf}}(t)$ 定义为两个正弦波的和，其频率为 $f_1 = 8$ $\\mathrm{Hz}$ 和 $f_2 = 30$ $\\mathrm{Hz}$，这些频率都在神经数据的典型感兴趣频带内 (例如，alpha 和 beta 频带)。\n$$\ns_{\\mathrm{lf}}(t) = A_1 \\sin(2\\pi f_1 t) + A_2 \\sin(2\\pi f_2 t)\n$$\n振幅为 $A_1 = 1$ 和 $A_2 = 0.5$ 任意单位 (a.u.)。\n\n高频信号 $s_{\\mathrm{hf}}(t)$ 是一个正弦波之和，其频率 $F_m$ 被明确选择为高于每个测试用例的奈奎斯特频率。\n$$\ns_{\\mathrm{hf}}(t) = \\sum_{m} B_m \\sin(2\\pi F_m t)\n$$\n所有分量的振幅均为 $B_m = 0.8$ a.u.。\n\n总信号是这两个分量的线性叠加：$x(t) = s_{\\mathrm{lf}}(t) + s_{\\mathrm{hf}}(t)$。\n\n**2. 信号采样 (离散化)**\n\n连续信号在 $T = 2$ $\\mathrm{s}$ 的持续时间内以速率 $f_s$ 进行采样。这将产生离散时间序列。采样的时间点为 $t_n = n T_s = n/f_s$，其中 $n = 0, 1, \\dots, N-1$，$N = \\lfloor T f_s \\rfloor$ 是总样本数。\n\n我们生成两个离散时间信号：\n- 采样后的总信号：$x[n] = x(t_n) = s_{\\mathrm{lf}}(t_n) + s_{\\mathrm{hf}}(t_n)$\n- 采样后的参考低频信号：$s_{\\mathrm{lf}}[n] = s_{\\mathrm{lf}}(t_n)$\n\n采样时，一个频率为 $F > f_{\\mathrm{Nyq}}$ 的高频正弦波会伪装成一个频率为 $f_{\\mathrm{alias}}$ 的低频正弦波，该频率在 $[0, f_{\\mathrm{Nyq}}]$ 范围内。混叠后的频率由 $f_{\\mathrm{alias}} = |F - k \\cdot f_s|$ 给出，其中 $k$ 是一个整数，其选择使得 $f_{\\mathrm{alias}} \\le f_{\\mathrm{Nyq}}$。这种频谱的折叠是我们旨在量化的误差来源。\n\n**3. 频域低通滤波**\n\n为了在特定的感兴趣频带内分离混叠效应，我们应用一个截止频率为 $f_{\\mathrm{band}} = 50$ $\\mathrm{Hz}$ 的理想低通滤波器。此操作在频域中使用离散傅里叶变换 (DFT) 执行，通过快速傅里叶变换 (FFT) 算法实现。\n\n首先，我们计算采样信号 $x[n]$ 和 $s_{\\mathrm{lf}}[n]$ 的 DFT，以分别获得它们的复数值谱 $X[k]$ 和 $S_{\\mathrm{lf}}[k]$。每个 DFT 单元 $k$ 对应的频率由采样率 $f_s$ 和点数 $N$ 决定。\n\n理想低通滤波器通过创建频率掩码来实现。我们识别出所有对应于频率 $|f| > f_{\\mathrm{band}}$ 的频率单元，并将其对应的 DFT 系数置零。对于实值输入信号，DFT 谱是共轭对称的，因此滤波器必须对称地应用于正频率和负频率分量。\n\n设 $Y_{\\mathrm{total}}[k]$ 和 $Y_{\\mathrm{lf}}[k]$ 为滤波后的频谱。它们定义为：\n$$\nY[k] =\n\\begin{cases}\nX[k]  \\text{if } |f_k| \\le f_{\\mathrm{band}} \\\\\n0  \\text{if } |f_k| > f_{\\mathrm{band}}\n\\end{cases}\n$$\n其中 $X[k]$ 是原始频谱，$f_k$ 是第 $k$ 个单元的频率。\n\n最后，我们将逆离散傅里叶变换 (通过 IFFT 实现) 应用于滤波后的频谱 $Y_{\\mathrm{total}}[k]$ 和 $Y_{\\mathrm{lf}}[k]$，以获得滤波后的时域信号 $y_{\\mathrm{total}}[n]$ 和 $y_{\\mathrm{lf}}[n]$。由于输入信号是实数且滤波器是对称的，因此得到的时域信号必须是实数。任何残余的虚部都是由数值精度误差引起的，应予以丢弃。\n\n**4. 误差量化**\n\n信号 $y_{\\mathrm{lf}}[n]$ 代表了在没有任何高频污染的情况下，经过采样和滤波后应有的“真实”低频内容。信号 $y_{\\mathrm{total}}[n]$ 包含这个相同的真实内容，外加任何混叠到 $[0, 50]$ $\\mathrm{Hz}$ 通带内的高频分量。\n\n因此，差分信号 $y_{\\mathrm{total}}[n] - y_{\\mathrm{lf}}[n]$ 分离出了混叠污染。我们使用均方根误差 (RMSE) 来量化这种污染的幅度：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y_{\\mathrm{total}}[n] - y_{\\mathrm{lf}}[n]\\right)^2}\n$$\n该指标提供了一个鲁棒的度量，用于衡量由混叠引入的误差信号的平均功率。该过程被系统地应用于每个测试用例，以评估采样率 $f_s$ 的选择和特定高频 $F_m$ 如何影响混叠的严重程度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates and quantifies aliasing in sampled neural signals.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'fs': 1000, 'Fm': [960, 980]},\n        {'fs': 500, 'Fm': [480, 495]},\n        {'fs': 200, 'Fm': [450]},\n        {'fs': 120, 'Fm': [115, 235]},\n        {'fs': 100, 'Fm': [99, 101, 199]},\n    ]\n\n    # Signal parameters\n    T = 2.0  # s\n    A1, f1 = 1.0, 8.0  # a.u., Hz\n    A2, f2 = 0.5, 30.0 # a.u., Hz\n    Bm_val = 0.8  # a.u.\n    f_band = 50.0  # Hz\n\n    def create_signal(t_samples, freq_list, amp):\n        \"\"\"Generates a sum of sinusoids.\"\"\"\n        signal = np.zeros_like(t_samples)\n        if not freq_list:\n            return signal\n        for f in freq_list:\n            # Using np.sin with a scalar amplitude\n            signal += amp * np.sin(2 * np.pi * f * t_samples)\n        return signal\n\n    def apply_ideal_lpf(signal_samples, fs, N, f_cutoff):\n        \"\"\"\n        Applies an ideal low-pass filter in the frequency domain.\n        \"\"\"\n        # 1. Compute DFT\n        dft_coeffs = np.fft.fft(signal_samples)\n        \n        # 2. Get frequency bins\n        freqs = np.fft.fftfreq(N, d=1.0/fs)\n        \n        # 3. Create mask to zero out frequencies above the cutoff\n        mask = np.abs(freqs) > f_cutoff\n        dft_coeffs[mask] = 0\n        \n        # 4. Compute Inverse DFT\n        filtered_signal = np.fft.ifft(dft_coeffs)\n        \n        # Return the real part to discard numerical noise\n        return np.real(filtered_signal)\n\n    results = []\n    \n    for case in test_cases:\n        fs = case['fs']\n        Fm_list = case['Fm']\n        \n        # Calculate number of samples\n        N = int(T * fs) # Per problem, floor is implicit as T*fs is integer\n        \n        # Create the discrete time vector\n        t_samples = np.arange(N) / fs\n        \n        # 1. Signal Synthesis and Sampling\n        # Low-frequency signal (s_lf[n])\n        s_lf_n = A1 * np.sin(2 * np.pi * f1 * t_samples) + \\\n                 A2 * np.sin(2 * np.pi * f2 * t_samples)\n\n        # High-frequency signal (s_hf[n])\n        s_hf_n = create_signal(t_samples, Fm_list, Bm_val)\n\n        # Total signal (x[n])\n        x_n = s_lf_n + s_hf_n\n        \n        # 2. Low-pass filtering\n        # Apply LPF to the reference low-frequency signal\n        y_lf_n = apply_ideal_lpf(s_lf_n, fs, N, f_band)\n        \n        # Apply LPF to the total signal\n        y_total_n = apply_ideal_lpf(x_n, fs, N, f_band)\n        \n        # 3. Quantify aliasing with RMSE\n        # The difference contains the aliased components\n        error_signal = y_total_n - y_lf_n\n        \n        # Calculate RMSE\n        rmse = np.sqrt(np.mean(error_signal**2))\n        \n        results.append(rmse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在处理真实世界的未知数据时，我们如何才能判断观察到的信号峰值是真实的，还是高频噪声混叠后的幻象？本练习介绍了一种先进且巧妙的检测策略，它利用了在不同采样率下重新记录同一信号的思想。您将构建一个假设检验框架，通过检查观测到的频谱峰在不同采样条件下是否满足折叠一致性，来判断是否存在混叠，这是将混叠原理应用于实验设计和数据验证的强大工具。",
            "id": "4137717",
            "problem": "您正在分析来自连续时间神经信号（例如，局部场电位）的频域峰值，该信号已通过两种不同的采样率重新记录。在离散时间采集中，对连续时间信号进行采样会以采样频率的整数倍复制其频谱，并产生基带观测值，其位置取决于原始连续时间频率折叠到奈奎斯特区间的情况。从采样产生以采样频率 $f_s$ 为间隔的频谱副本，且可观测基带频谱位于 $[0, f_s/2]$ 这一基本原理出发，构建一个假设检验来检测混叠。该检验通过比较两次记录中观测到的峰值位置是否与一组单一的潜在连续时间频率一致来实现。\n\n设两次记录的采样率分别为 $f_{s1}$ 和 $f_{s2}$。设其观测到的峰值集合分别为 $\\{p_1^{(i)}\\}_{i=1}^{N_1}$ 和 $\\{p_2^{(j)}\\}_{j=1}^{N_2}$，单位为赫兹。由于折叠效应，一个单一的潜在连续时间频率 $f$ 会根据采样率的不同而出现在不同的基带位置。您的任务是为每个给定的测试用例判断，是否至少有一个观测峰值只能用一个超过某次记录奈奎斯特极限的潜在频率 $f$ 来解释，这种情况即表明发生了混叠。\n\n您必须按照以下方式设计决策规则，仅基于上述基本属性，而不使用问题陈述中的任何快捷公式：\n\n- 将零假设 $\\mathcal{H}_0$ 定义为：存在一个一致的潜在连续时间频率集合 $\\{f^{(k)}\\}$，所有频率都满足 $f^{(k)} \\le \\min(f_{s1}/2, f_{s2}/2)$，使得它们折叠后的基带位置在容差 $\\varepsilon$ 内与观测到的集合相匹配。\n- 将备择假设 $\\mathcal{H}_1$ 定义为：为了在容差 $\\varepsilon$ 内匹配两次记录中至少一对观测峰值位置，解释该对峰值的每一个一致潜在频率 $f$ 都满足 $f > f_{s1}/2$ 或 $f > f_{s2}/2$；或者不存在能在 $\\varepsilon$ 内解释该对峰值的一致潜在频率。\n\n为了使问题在计算上是良定义的，通过枚举从每个采样率为 $f_s$ 的观测峰值 $p$ 生成的序列来约束对候选潜在频率的搜索。这些序列通过 $n f_s$ 的整数位移和围绕零的符号对称性生成，并限制在最大频率界限 $f_{\\max}$ 和非负频率范围内。也就是说，考虑形式为 $f = s \\, p + n f_s$ 的候选频率，其中 $s \\in \\{+1, -1\\}$ 且 $n \\in \\mathbb{Z}$，并保留满足 $0 \\le f \\le f_{\\max}$ 的频率。对于每个候选频率 $f$，确定其在另一采样率下的预测基带位置，并与那里的观测峰值进行比较；如果最小绝对差在 $\\varepsilon$ 范围内，则接受 $f$ 作为该对峰值的一个一致解释。\n\n您的程序必须为以下测试套件实现此决策规则，所有频率均使用赫兹，并以布尔值表示最终输出。在所有测试用例中，使用 $\\varepsilon = 1.0$ 赫兹和 $f_{\\max} = 2000.0$ 赫兹。\n\n测试套件（每个测试用例是一个元组 $(f_{s1}, \\{p_1^{(i)}\\}, f_{s2}, \\{p_2^{(j)}\\})$）：\n1. $(f_{s1} = 1000, \\{50, 200, 350\\}, f_{s2} = 1500, \\{50, 200, 350\\})$\n2. $(f_{s1} = 400, \\{100\\}, f_{s2} = 1000, \\{300\\})$\n3. $(f_{s1} = 500, \\{80\\}, f_{s2} = 600, \\{180\\})$\n4. $(f_{s1} = 800, \\{400\\}, f_{s2} = 1000, \\{400\\})$\n5. $(f_{s1} = 300, \\{90, 80, 130\\}, f_{s2} = 700, \\{90, 220, 270\\})$\n\n您的程序应生成单行输出，其中包含这五个测试用例的结果，格式为方括号内以逗号分隔的列表，例如，“[result1,result2,result3,result4,result5]”。每个结果必须是一个布尔值，其中 True 表示拒绝 $\\mathcal{H}_0$ 并接受 $\\mathcal{H}_1$（检测到混叠），False 表示未能拒绝 $\\mathcal{H}_0$（未检测到混叠）。不应打印任何其他文本。",
            "solution": "该问题要求构建并实现一个假设检验，通过比较在两种不同采样率 $f_{s1}$ 和 $f_{s2}$ 下两次独立记录中观测到的频谱峰值，来检测信号中的混叠。问题的核心在于数字信号处理的基本原理。\n\n### 采样与混叠原理\n\n当一个包含频率分量 $f$ 的连续时间信号以速率 $f_s$ 被采样时，其频谱会在采样频率的所有整数倍 $n f_s$（其中 $n \\in \\mathbb{Z}$）处被复制。在离散域中观测到的信号是所有这些频谱副本的叠加。能够被明确表示的频率内容位于奈奎斯特区间内，定义为 $[0, f_s/2]$。\n\n一个高于奈奎斯特频率 $f_s/2$ 的潜在连续时间频率 $f$ 将被“折叠”到奈奎斯特区间内，表现为一个较低频率的混叠分量。对于一个潜在频率 $f \\ge 0$，其观测到的基带频率 $p$ 是该频率与任意频谱副本网格线 $n f_s$ 的最小距离。这可以表示为函数 $Fold(f, f_s)$：\n$$\np = Fold(f, f_s) = \\min_{n \\in \\mathbb{Z}} |f - n f_s|\n$$\n该计算等效于对频率取模 $f_s$，然后将 $[0, f_s)$ 区间的上半部分折叠回下半部分。具体来说，令 $f' = f \\pmod{f_s}$。折叠后的频率为 $p = \\min(f', f_s - f')$。\n\n反之，一个在基带区间 $[0, f_s/2]$ 内观测到的峰值 $p$ 可能源于任何满足 $p = Fold(f, f_s)$ 的潜在频率 $f$。这个条件成立的条件是，对于某个整数 $n$，要么 $f - n f_s = p$，要么 $f - n f_s = -p$。对 $f$ 进行整理，我们得到所有可能的源频率集合：\n$$\nf = s \\cdot p + n \\cdot f_s, \\quad \\text{where } s \\in \\{+1, -1\\} \\text{ and } n \\in \\mathbb{Z}\n$$\n这种关系构成了从一个观测峰值生成候选潜在频率的基础。\n\n### 假设检验的构建\n\n我们的任务是基于在 $f_{s1}$ 采样率下观测到的峰值集合 $\\{p_1^{(i)}\\}$ 和在 $f_{s2}$ 采样率下观测到的峰值集合 $\\{p_2^{(j)}\\}$，在两个假设之间做出抉择。\n\n零假设 $\\mathcal{H}_0$ 假定解释这些观测结果无需混叠。形式上：\n$\\mathcal{H}_0$：存在一个潜在频率集合 $\\{f^{(k)}\\}$，其中所有频率相对于两个采样率都是非混叠的（即 $\\forall k, f^{(k)} \\le \\min(f_{s1}/2, f_{s2}/2)$），使得这个单一集合能够在容差 $\\varepsilon$ 内解释所有观测到的峰值 $\\{p_1^{(i)}\\}$ 和 $\\{p_2^{(j)}\\}$。\n\n备择假设 $\\mathcal{H}_1$ 是其逻辑对立面，指出解释数据需要混叠。\n$\\mathcal{H}_1$：对于至少一个观测峰值，任何一致的解释都需要一个相对于至少一个采样率是混叠的潜在频率 $f$（即 $f > f_{s1}/2$ 或 $f > f_{s2}/2$）。这也包括某个峰值完全没有一致解释的情况。\n\n### 算法决策规则\n\n决策规则是：如果在任一记录中能找到哪怕一个观测峰值无法用非混叠的潜在频率来解释，则拒绝 $\\mathcal{H}_0$（并断定存在混叠）。否则，如果两个集合中的每个峰值都至少有一个合理的非混叠解释，我们则未能拒绝 $\\mathcal{H}_0$。\n\n对于来自一次记录（例如，速率为 $f_{s,source}$）的峰值 $p_{source}$ 的“解释”，包括在另一次记录（速率为 $f_{s,target}$）中找到一个伙伴峰值 $p_{target}$，以及一个与两者都一致的潜在频率 $f$。即 $p_{source} \\approx Fold(f, f_{s,source})$（这通过候选频率的构造方式保证为真）并且 $p_{target} \\approx Fold(f, f_{s,target})$。如果潜在频率 $f$ 满足 $f \\le f_{Nyquist, min}$，其中 $f_{Nyquist, min} = \\min(f_{s1}/2, f_{s2}/2)$，则该解释是“非混叠”的。\n\n算法流程如下：\n1. 对每个测试用例，确定最小奈奎斯特频率 $f_{Nyquist, min} = \\min(f_{s1}/2, f_{s2}/2)$。这是混叠的阈值。\n2. 定义一个函数 `has_non_aliased_explanation`，它接受一个源峰值 $p_{source}$、其采样率 $f_{s,source}$、目标峰值集合 $\\{p_{target}\\}$ 和目标采样率 $f_{s,target}$。\n3. 在此函数内部：\n    a. 使用公式 $f = s \\cdot p_{source} + n \\cdot f_{s,source}$，为 $p_{source}$ 生成所有候选潜在频率 $f$，受限于约束条件 $s \\in \\{+1, -1\\}$、$n \\in \\mathbb{Z}$ 和 $0 \\le f \\le f_{\\max}$。$n$ 的范围可以从频率界限推导出来：对于每个 $s$，$n$ 必须在整数范围 $[\\lceil -s \\cdot p_{source} / f_{s,source} \\rceil, \\lfloor (f_{\\max} - s \\cdot p_{source}) / f_{s,source} \\rfloor]$ 内。\n    b. 遍历生成的候选频率 $f$。对每一个频率，检查它是否构成一个非混叠解释：\n        i. 验证候选频率是否为非混叠：$f \\le f_{Nyquist, min}$。\n        ii. 如果它是非混叠的，计算其在目标采样率下的预测折叠频率：$p_{pred} = Fold(f, f_{s,target})$。\n        iii. 检查此预测是否与目标集合中的任何峰值匹配：$\\exists p_{target} \\text{ such that } |p_{pred} - p_{target}| \\le \\varepsilon$。\n        iv. 如果条件（i）和（iii）都满足，则已为 $p_{source}$ 找到了一个非混叠解释。函数可以立即返回 `True`。\n    c. 如果遍历所有候选频率的循环完成而没有找到任何此类解释，则意味着 $p_{source}$ 无法用非混叠频率来解释。函数返回 `False`。\n4. 主决策逻辑接着遍历第一个集合中的每个峰值 $p_1^{(i)}$ 并调用 `has_non_aliased_explanation`。如果任何一次调用返回 `False`，则表示有一个峰值只能通过混叠来解释（或根本无法解释）。因此我们拒绝 $\\mathcal{H}_0$ 并得出结论 `True`（检测到混叠）。\n5. 如果第一个集合中的所有峰值都有非混叠解释，我们还必须以同样的方式检查第二个集合中的每个峰值 $p_2^{(j)}$。如果这些检查中有任何一个失败，我们同样得出结论 `True`。\n6. 如果发现两个集合中的所有峰值都至少有一个非混叠解释，我们未能拒绝 $\\mathcal{H}_0$ 并得出结论 `False`（未检测到混叠）。\n\n这种严谨的、逐个峰值的验证直接实现了所提供的假设检验结构所蕴含的逻辑，为每个测试用例提供了明确的结论。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the aliasing detection test suite.\n    \"\"\"\n    \n    # Define parameters from the problem statement.\n    eps = 1.0\n    f_max = 2000.0\n\n    # Test suite data.\n    test_cases = [\n        (1000.0, {50.0, 200.0, 350.0}, 1500.0, {50.0, 200.0, 350.0}),\n        (400.0, {100.0}, 1000.0, {300.0}),\n        (500.0, {80.0}, 600.0, {180.0}),\n        (800.0, {400.0}, 1000.0, {400.0}),\n        (300.0, {90.0, 80.0, 130.0}, 700.0, {90.0, 220.0, 270.0}),\n    ]\n\n    def fold(f, fs):\n        \"\"\"\n        Calculates the folded frequency of an underlying frequency f\n        when sampled at rate fs. The result is in the baseband [0, fs/2].\n        \"\"\"\n        if fs == 0:\n            return f\n        f_rem = f % fs\n        return min(f_rem, fs - f_rem)\n\n    def generate_candidates(p, fs, f_max):\n        \"\"\"\n        Generates a set of candidate underlying frequencies f for an observed\n        peak p, given sampling rate fs and max frequency f_max.\n        f = s*p + n*fs, where s in {+1, -1}, n is an integer, and 0 = f = f_max.\n        \"\"\"\n        candidates = set()\n        if fs == 0:\n            if 0 = p = f_max:\n                candidates.add(p)\n            return candidates\n\n        # Case s = +1\n        n_min_s1 = math.ceil(-p / fs)\n        n_max_s1 = math.floor((f_max - p) / fs)\n        for n in range(n_min_s1, n_max_s1 + 1):\n            f = p + n * fs\n            if 0 = f = f_max:\n                candidates.add(f)\n        \n        # Case s = -1\n        n_min_s_neg1 = math.ceil(p / fs)\n        n_max_s_neg1 = math.floor((f_max + p) / fs)\n        for n in range(n_min_s_neg1, n_max_s_neg1 + 1):\n            f = -p + n * fs\n            if 0 = f = f_max:\n                candidates.add(f)\n        \n        return candidates\n\n    def has_non_aliased_explanation(p_source, fs_source, p_target_set, fs_target, nyquist_limit, eps, f_max):\n        \"\"\"\n        Checks if a given source peak has at least one non-aliased explanation.\n        An explanation is a non-aliased underlying frequency f that, when folded\n        at the target sampling rate, matches a peak in the target set.\n        \"\"\"\n        candidates = generate_candidates(p_source, fs_source, f_max)\n        \n        for f in candidates:\n            # Check if the candidate frequency is non-aliased\n            if f = nyquist_limit:\n                # If non-aliased, check if it explains a target peak\n                p_pred = fold(f, fs_target)\n                for p_target in p_target_set:\n                    if abs(p_pred - p_target) = eps:\n                        # Found a non-aliased explanation, so this peak is explainable\n                        return True\n                        \n        # If loop finishes, no non-aliased explanation was found for this source peak\n        return False\n\n    def solve_case(fs1, p1_set, fs2, p2_set, eps, f_max):\n        \"\"\"\n        Solves a single test case, returning True if aliasing is detected\n        and False otherwise.\n        \"\"\"\n        nyquist_limit = min(fs1 / 2.0, fs2 / 2.0)\n\n        # Check if every peak in the first set has a non-aliased explanation\n        for p1 in p1_set:\n            if not has_non_aliased_explanation(p1, fs1, p2_set, fs2, nyquist_limit, eps, f_max):\n                # This peak can only be explained by aliasing (or not at all).\n                return True\n\n        # Check if every peak in the second set has a non-aliased explanation\n        for p2 in p2_set:\n            if not has_non_aliased_explanation(p2, fs2, p1_set, fs1, nyquist_limit, eps, f_max):\n                # This peak can only be explained by aliasing (or not at all).\n                return True\n        \n        # All peaks have at least one non-aliased explanation, so fail to reject H0.\n        return False\n\n    results = []\n    for case in test_cases:\n        fs1, p1_set, fs2, p2_set = case\n        result = solve_case(fs1, p1_set, fs2, p2_set, eps, f_max)\n        results.append(result)\n\n    # Format the final output as a comma-separated list of booleans\n    # The map(str,...) is used to ensure True/False are correctly capitalized.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}