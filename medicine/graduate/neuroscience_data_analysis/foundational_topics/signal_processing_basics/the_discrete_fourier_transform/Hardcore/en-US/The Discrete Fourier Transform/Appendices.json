{
    "hands_on_practices": [
        {
            "introduction": "The Discrete Fourier Transform (DFT) is fundamentally a tool for projecting a signal onto a set of basis functions, which are complex sinusoids of different frequencies. To build an intuition for how this works, our first practice involves analyzing the simplest possible signal: a pure complex exponential that perfectly matches one of the DFT's basis functions. Working through this derivation  illuminates the core \"sifting\" property of the DFT, revealing how it isolates and quantifies the energy at a specific frequency.",
            "id": "1759639",
            "problem": "In digital signal processing, the Discrete Fourier Transform (DFT) is a fundamental tool for analyzing the frequency content of a finite-length signal. Consider a simplified model of a pure tone signal after sampling. This signal, denoted as $x[n]$, is represented by a single complex exponential.\n\nThe signal is a sequence of length $N$ defined as:\n$$x[n] = \\exp\\left(i \\frac{2\\pi k_0 n}{N}\\right)$$\nfor the time index $n = 0, 1, \\ldots, N-1$. Here, $k_0$ is an integer constant representing the normalized frequency of the tone, and it satisfies $0 \\le k_0 < N$.\n\nYour task is to compute the $N$-point DFT of this signal. The DFT, denoted by $X[k]$, is defined by the analysis equation:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-i \\frac{2\\pi kn}{N}\\right)$$\nwhere $k$ is the frequency index, taking integer values from $k = 0, 1, \\ldots, N-1$.\n\nFind a single, closed-form analytic expression for $X[k]$ in terms of $N$, $k$, and $k_0$.",
            "solution": "We start from the DFT analysis equation and substitute the given signal. By definition,\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-i \\frac{2\\pi kn}{N}\\right).\n$$\nWith $x[n] = \\exp\\left(i \\frac{2\\pi k_{0} n}{N}\\right)$, this becomes\n$$\nX[k] = \\sum_{n=0}^{N-1} \\exp\\left(i \\frac{2\\pi k_{0} n}{N}\\right)\\exp\\left(-i \\frac{2\\pi k n}{N}\\right) \n= \\sum_{n=0}^{N-1} \\exp\\left(i \\frac{2\\pi (k_{0}-k) n}{N}\\right).\n$$\nDefine the ratio\n$$\nr \\triangleq \\exp\\left(i \\frac{2\\pi (k_{0}-k)}{N}\\right).\n$$\nThen\n$$\nX[k] = \\sum_{n=0}^{N-1} r^{n}.\n$$\nThis is a finite geometric series. Using the geometric series sum,\n$$\n\\sum_{n=0}^{N-1} r^{n} = \n\\begin{cases}\n\\frac{1 - r^{N}}{1 - r}, & r \\neq 1, \\\\\nN, & r = 1,\n\\end{cases}\n$$\nand noting that\n$$\nr^{N} = \\exp\\left(i \\frac{2\\pi (k_{0}-k) N}{N}\\right) = \\exp\\left(i 2\\pi (k_{0}-k)\\right) = 1,\n$$\nwe have:\n- If $r \\neq 1$ (equivalently $k \\neq k_{0}$ for $k,k_{0}\\in\\{0,\\ldots,N-1\\}$), then $1 - r^{N} = 0$ while $1 - r \\neq 0$, so $X[k] = 0$.\n- If $r = 1$ (equivalently $k = k_{0}$), then every term of the sum equals $1$, so $X[k] = N$.\n\nCombining these cases gives the closed-form expression\n$$\nX[k] = N\\,\\delta_{k,k_{0}},\n$$\nwhere $\\delta_{k,k_{0}}$ is the Kronecker delta, equal to $1$ if $k=k_{0}$ and $0$ otherwise.",
            "answer": "$$\\boxed{N\\,\\delta_{k,k_{0}}}$$"
        },
        {
            "introduction": "One of the most powerful applications of the DFT in neuroscience data analysis is the implementation of fast, efficient filtering. This is made possible by the Convolution Theorem, which transforms the computationally intensive process of convolution into simple multiplication in the frequency domain. This exercise  challenges you to bridge the gap between theory and practice by using the DFT's inherent *circular* convolution to implement the *linear* convolution required for filtering, a task that requires a careful understanding of zero-padding to avoid wrap-around errors.",
            "id": "3222797",
            "problem": "You are asked to reason from first principles about the Discrete Fourier Transform (DFT) and its use in implementing linear convolution through circular convolution with zero-padding. The starting point is the core definitions of the Discrete Fourier Transform (DFT), the inverse Discrete Fourier Transform (IDFT), and circular convolution on a finite-length sequence. You must use these definitions to justify how zero-padding prevents boundary wrap-around, and to quantify the error that occurs when zero-padding is omitted.\n\nLet $x = (x_{0}, x_{1}, \\dots, x_{L-1})$ and $h = (h_{0}, h_{1}, \\dots, h_{M-1})$ be real-valued finite-length sequences of lengths $L$ and $M$ respectively. Define their linear convolution $c = x * h$ of length $L + M - 1$ in the usual sense on the integers, and define circular convolution modulo $N$ in the usual sense on the ring of integers modulo $N$.\n\nTasks:\n1. Starting from the core definitions of the Discrete Fourier Transform (DFT) and inverse Discrete Fourier Transform (IDFT), and the definition of circular convolution, derive the sufficient condition on the transform length $N$ such that computing circular convolution of $x$ and $h$ after zero-padding them to length $N$ yields the exact linear convolution on the nonnegative integer indices without any boundary wrap-around. You must identify and justify the minimal integer $N$ satisfying $N \\ge L + M - 1$ that achieves this.\n\n2. When zero-padding is omitted and a shorter transform length $N$ is used that does not satisfy $N \\ge L + M - 1$, the circular convolution suffers wrap-around (also called aliasing). Starting from the definitions, characterize precisely how the circular convolution relates to the linear convolution via periodic summation. Define the aliasing error vector $e \\in \\mathbb{R}^{N}$ whose components measure the difference between the circular convolution of length $N$ and the first $N$ samples of the linear convolution. Provide a principled way to quantify this aliasing error using the infinity norm, defined as $\\|e\\|_{\\infty} = \\max_{0 \\le n \\le N-1} |e_{n}|$.\n\n3. Implement a complete and runnable program that:\n   - For each test case, computes the minimal zero-padding length $N_{\\min} = L + M - 1$, performs circular convolution via the DFT at length $N_{\\min}$, and checks whether this matches the direct linear convolution exactly (within standard floating-point tolerance).\n   - For an additional run without padding at length $N_{\\text{nopad}} = \\max(L,M)$, computes the circular convolution via the DFT and the corresponding aliasing error vector with respect to the first $N_{\\text{nopad}}$ samples of the linear convolution, and computes the infinity norm of this aliasing error and the count of indices where the absolute aliasing error exceeds a small tolerance threshold.\n   - Produces, for each test case, a result list of the form $[N_{\\min}, \\text{eq\\_flag}, \\|e\\|_{\\infty}, \\text{aliasing\\_count}]$, where $N_{\\min}$ is an integer, $\\text{eq\\_flag}$ is a boolean indicating equality at $N_{\\min}$ within tolerance, $\\|e\\|_{\\infty}$ is a float, and $\\text{aliasing\\_count}$ is an integer.\n\nTest suite:\n- Case $1$: $L = 4$, $M = 3$, $x^{(1)} = (\\,1,\\,-1,\\,2,\\,0\\,)$, $h^{(1)} = (\\,2,\\,0,\\,-1\\,)$.\n- Case $2$: $L = 1$, $M = 5$, $x^{(2)} = (\\,3\\,)$, $h^{(2)} = (\\,0,\\,1,\\,0,\\,-1,\\,2\\,)$.\n- Case $3$: $L = 8$, $M = 8$, $x^{(3)} = (\\,0.5,\\,-1.0,\\,2.0,\\,-2.5,\\,0.0,\\,1.5,\\,-0.5,\\,3.0\\,)$, $h^{(3)} = (\\,1.0,\\,0.0,\\,-0.5,\\,0.25,\\,0.0,\\,-0.25,\\,0.5,\\,-1.0\\,)$.\n- Case $4$: $L = 5$, $M = 1$, $x^{(4)} = (\\,1.2,\\,-0.3,\\,0.0,\\,2.1,\\,-1.1\\,)$, $h^{(4)} = (\\,1.0\\,)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces. The list should aggregate the per-case results in order, each per-case result itself being a comma-separated list enclosed in square brackets. For example, the output should look like $[[N_{\\min}^{(1)},\\text{eq\\_flag}^{(1)},\\|e^{(1)}\\|_{\\infty},\\text{aliasing\\_count}^{(1)}],[N_{\\min}^{(2)},\\text{eq\\_flag}^{(2)},\\|e^{(2)}\\|_{\\infty},\\text{aliasing\\_count}^{(2)}],\\dots]$.\n\nThere are no physical units or angle units involved in this problem. All outputs must be of fundamental types (boolean, integer, float, or lists of these). The program must be self-contained and require no input. The implementation language is unrestricted at the problem level but will be specified in the final answer. Ensure scientific realism and self-consistency in all reasoning and computations.",
            "solution": "The problem requires a derivation of the conditions for performing linear convolution using circular convolution via the Discrete Fourier Transform (DFT), and an analysis of the aliasing error when these conditions are not met. This is followed by a computational task to verify these principles.\n\nLet $x$ be a sequence of length $L$ and $h$ be a sequence of length $M$. Their linear convolution, denoted by $c = x * h$, is a sequence of length $L+M-1$ given by:\n$$c_n = (x * h)_n = \\sum_{m=0}^{L-1} x_m h_{n-m}, \\quad \\text{for } n = 0, 1, \\dots, L+M-2$$\nThe DFT-based method for computing convolution relies on the Convolution Theorem, which states that for two $N$-point sequences $a$ and $b$:\n$$\\text{DFT}(a \\circledast_N b) = \\text{DFT}(a) \\cdot \\text{DFT}(b)$$\nwhere $\\cdot$ denotes element-wise multiplication. This implies that circular convolution can be computed as:\n$$a \\circledast_N b = \\text{IDFT}(\\text{DFT}(a) \\cdot \\text{DFT}(b))$$\nOur goal is to use this property to compute the linear convolution $c$. To do this, we must embed the problem in a circular convolution framework. This is achieved by zero-padding the sequences $x$ and $h$ to a common length $N$. Let $x_p$ and $h_p$ be the zero-padded sequences of length $N$:\n$$x_{p,n} = \\begin{cases} x_n & 0 \\le n < L \\\\ 0 & L \\le n < N \\end{cases}$$\n$$h_{p,n} = \\begin{cases} h_n & 0 \\le n < M \\\\ 0 & M \\le n < N \\end{cases}$$\nThe circular convolution of these padded sequences is a sequence $y$ of length $N$:\n$$y_n = (x_p \\circledast_N h_p)_n = \\sum_{m=0}^{N-1} x_{p,m} h_{p,(n-m) \\pmod{N}}$$\nSince $x_{p,m} = 0$ for $m \\ge L$, the sum simplifies to:\n$$y_n = \\sum_{m=0}^{L-1} x_m h_{p,(n-m) \\pmod{N}}$$\n\n**1. Condition for Equivalence of Linear and Circular Convolution**\n\nWe want to find the condition on $N$ such that the output $y_n$ of the circular convolution is identical to the output $c_n$ of the linear convolution for all samples where $c_n$ is defined, i.e., for $n = 0, 1, \\dots, L+M-2$. By comparing the expressions for $y_n$ and $c_n$:\n$$y_n = \\sum_{m=0}^{L-1} x_m h_{p,(n-m) \\pmod{N}}$$\n$$c_n = \\sum_{m=0}^{L-1} x_m h_{n-m}$$\nFor $y_n$ to equal $c_n$, we need the filter terms to match for each $m \\in [0, L-1]$:\n$$h_{p,(n-m) \\pmod{N}} = h_{n-m}$$\nThe established property relating circular and linear convolution is:\n$$y_n = \\sum_{r=-\\infty}^{\\infty} c_{n+rN}$$\nFor $y_n$ to equal $c_n$ for $n = 0, \\dots, N-1$, we require the summation to have only one non-zero term, which is $c_n$ itself. This means $c_{n+rN} = 0$ for all $r \\ne 0$.\n- For $r \\ge 1$, we need $c_{n+rN} = 0$. Since $c_k = 0$ for $k \\ge L+M-1$, we need $n+rN \\ge L+M-1$ for all $n \\in [0, N-1]$ and $r \\ge 1$. The most restrictive case is for the smallest $n$ and $r$, i.e., $n=0, r=1$. This gives $N \\ge L+M-1$.\n- For $r \\le -1$, we need $c_{n+rN} = 0$. Since $c_k = 0$ for $k < 0$, we need $n+rN < 0$ for all $n \\in [0, N-1]$ and $r \\le -1$. The most restrictive case is for the largest $n$ and $r$, i.e., $n=N-1, r=-1$. This gives $(N-1) - N < 0$, which is $-1 < 0$. This condition is always satisfied.\nCombining these, the sufficient condition is $N \\ge L+M-1$. To capture all $L+M-1$ samples of the linear convolution, the DFT size must be at least this large. Therefore, the minimal integer value for $N$ is $N_{\\min} = L+M-1$.\n\n**2. Aliasing Error Characterization**\n\nWhen the transform length $N$ is chosen such that $N < L+M-1$, time-domain aliasing occurs. The circular convolution $y_n$ is the periodic summation of the linear convolution $c_n$:\n$$y_n = \\sum_{r=-\\infty}^{\\infty} c_{n+rN}, \\quad \\text{for } n = 0, 1, \\dots, N-1$$\nSince $c_k=0$ for $k<0$ and $k \\ge L+M-1$, this simplifies to:\n$$y_n = \\sum_{r=0}^{\\lfloor (L+M-2-n)/N \\rfloor} c_{n+rN} = c_n + c_{n+N} + c_{n+2N} + \\dots$$\nThe aliasing error vector $e \\in \\mathbb{R}^N$ is the difference between the circular convolution result $y$ and the first $N$ samples of the true linear convolution $c$:\n$$e_n = y_n - c_n, \\quad \\text{for } n = 0, 1, \\dots, N-1$$\nSubstituting the expression for $y_n$:\n$$e_n = \\left(c_n + \\sum_{r=1}^{\\infty} c_{n+rN}\\right) - c_n = \\sum_{r=1}^{\\infty} c_{n+rN}$$\nThis expression precisely characterizes the error: the $n$-th component of the error is the sum of all samples of the linear convolution that \"wrap around\" and alias to the index $n$. These are the samples at indices $n+N, n+2N, \\dots$ which are folded back into the range $[0, N-1]$.\nTo quantify this error, we use the infinity norm:\n$$\\|e\\|_{\\infty} = \\max_{0 \\le n \\le N-1} |e_n| = \\max_{0 \\le n \\le N-1} \\left| \\sum_{r=1}^{\\infty} c_{n+rN} \\right|$$\nThis gives the maximum absolute deviation at any single point between the computed circular convolution and the desired linear convolution over the first $N$ samples.\n\n**3. Implementation**\nThe program will implement the procedures described above for each test case.\n- For the correctness check, we will use $N = N_{\\min} = L+M-1$.\n- For the aliasing error calculation, we will use $N = N_{\\text{nopad}} = \\max(L, M)$, which generally does not satisfy the condition $N \\ge L+M-1$. The aliasing error $e_n = y_n - c_n$ for $n=0, \\dots, N_{\\text{nopad}}-1$ will be computed, where $y$ is the circular convolution of length $N_{\\text{nopad}}$ and $c$ is the true linear convolution.\nThe logic will proceed as follows for each test case $(x, h)$:\n1. Determine lengths $L=\\text{len}(x)$, $M=\\text{len}(h)$.\n2. Calculate $N_{\\min} = L+M-1$.\n3. Compute the linear convolution $c_{\\text{linear}} = \\text{np.convolve}(x, h)$.\n4. **Verification**:\n   a. Pad $x$ and $h$ to length $N_{\\min}$.\n   b. Compute DFTs, multiply, and compute IDFT to get $c_{\\text{circular}}$.\n   c. Check if $c_{\\text{linear}}$ and $c_{\\text{circular}}$ are equal within a small tolerance using `np.allclose()`. Store the boolean result as $\\text{eq\\_flag}$.\n5. **Aliasing Analysis**:\n   a. Set $N_{\\text{nopad}} = \\max(L, M)$.\n   b. Pad $x$ and $h$ to length $N_{\\text{nopad}}$.\n   c. Compute the circular convolution $y$ of length $N_{\\text{nopad}}$.\n   d. Extract the first $N_{\\text{nopad}}$ samples of the linear convolution: $c_{\\text{ref}} = c_{\\text{linear}}[:N_{\\text{nopad}}]$.\n   e. Compute the error vector $e = y - c_{\\text{ref}}$.\n   f. Compute $\\|e\\|_{\\infty} = \\text{np.max(np.abs(e))}$.\n   g. Compute the number of elements in $e$ with magnitude greater than a tolerance (e.g., $10^{-9}$): $\\text{aliasing\\_count} = \\text{np.sum(np.abs(e) > 1e-9)}$.\n6. Collect $[N_{\\min}, \\text{eq\\_flag}, \\|e\\|_{\\infty}, \\text{aliasing\\_count}]$ for the test case.\nFinally, the results from all test cases will be formatted into the specified string format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT convolution problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: L=4, M=3\n        (np.array([1., -1., 2., 0.]), np.array([2., 0., -1.])),\n        # Case 2: L=1, M=5\n        (np.array([3.]), np.array([0., 1., 0., -1., 2.])),\n        # Case 3: L=8, M=8\n        (np.array([0.5, -1.0, 2.0, -2.5, 0.0, 1.5, -0.5, 3.0]),\n         np.array([1.0, 0.0, -0.5, 0.25, 0.0, -0.25, 0.5, -1.0])),\n        # Case 4: L=5, M=1\n        (np.array([1.2, -0.3, 0.0, 2.1, -1.1]), np.array([1.0]))\n    ]\n    \n    TOLERANCE = 1e-9\n    all_results = []\n\n    for x, h in test_cases:\n        L = len(x)\n        M = len(h)\n\n        # Task 1: Minimal zero-padding length and verification\n        N_min = L + M - 1\n\n        # Direct linear convolution as ground truth\n        c_linear = np.convolve(x, h)\n\n        # Circular convolution via DFT with proper zero-padding\n        x_pad_min = np.zeros(N_min)\n        h_pad_min = np.zeros(N_min)\n        x_pad_min[:L] = x\n        h_pad_min[:M] = h\n\n        X_fft_min = np.fft.fft(x_pad_min)\n        H_fft_min = np.fft.fft(h_pad_min)\n        c_circular_min = np.real(np.fft.ifft(X_fft_min * H_fft_min))\n\n        # Check for equality within floating-point tolerance\n        eq_flag = np.allclose(c_linear, c_circular_min, atol=TOLERANCE)\n\n        # Task 2: Aliasing error analysis without sufficient padding\n        N_nopad = max(L, M)\n        \n        # In cases where L+M-1 <= max(L,M), there is no aliasing.\n        # This happens if L=1 or M=1.\n        if N_nopad >= N_min:\n            norm_e_inf = 0.0\n            aliasing_count = 0\n        else:\n            x_pad_nopad = np.zeros(N_nopad)\n            h_pad_nopad = np.zeros(N_nopad)\n            x_pad_nopad[:L] = x\n            h_pad_nopad[:M] = h\n            \n            X_fft_nopad = np.fft.fft(x_pad_nopad)\n            H_fft_nopad = np.fft.fft(h_pad_nopad)\n            y_circular_nopad = np.real(np.fft.ifft(X_fft_nopad * H_fft_nopad))\n\n            # Reference is the first N_nopad samples of the true linear convolution\n            c_linear_ref = c_linear[:N_nopad]\n            \n            # Aliasing error vector\n            error_vector = y_circular_nopad - c_linear_ref\n            \n            # Infinity norm of the error\n            norm_e_inf = np.max(np.abs(error_vector))\n            \n            # Count of indices with significant aliasing\n            aliasing_count = np.sum(np.abs(error_vector) > TOLERANCE)\n\n        all_results.append([N_min, eq_flag, norm_e_inf, aliasing_count])\n    \n    # Format the final output string exactly as required\n    formatted_results = []\n    for res in all_results:\n        # res is [N_min, eq_flag, norm_e_inf, aliasing_count]\n        # Convert boolean to lowercase string 'true'/'false'\n        # Format float to ensure it's not in scientific notation for small numbers.\n        inner_parts = [\n            str(res[0]),\n            str(res[1]).lower(),\n            f\"{res[2]:.15f}\".rstrip('0').rstrip('.'), # Clean floating point representation\n            str(res[3])\n        ]\n        formatted_results.append(f\"[{','.join(inner_parts)}]\")\n    \n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "This coding exercise provides a rigorous, hands-on demonstration of the difference between spectral interpolation and resolution, a crucial distinction in the analysis of neural oscillations. Zero-padding is a common technique that produces smoother-looking spectra, but it only interpolates the underlying spectrum rather than improving true frequency resolvability, which is set by the signal's observation duration. Completing this practice  will empower you to correctly interpret spectral plots and avoid the common pitfall of mistaking a denser-sampled peak for a better-resolved one.",
            "id": "4199087",
            "problem": "Construct a program that demonstrates rigorously, using a synthetic finite-duration sinusoid and two-tone mixtures, that zero-padding increases the interpolation density of the Discrete Fourier Transform (DFT) but does not improve true frequency resolution. Begin from foundational definitions in discrete-time signal processing pertinent to neuroscience data analysis, and ensure all calculations respect physical units. You must not use any external files or inputs; all parameters must be defined within the program.\n\nFundamental base to use:\n- Let a discrete-time signal be $x[n]$, $n=0,1,\\dots,N-1$, sampled at sampling frequency $f_s$ (in Hz). The DFT $X[k]$ is defined by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2 \\pi k n / N}, \\quad k=0,1,\\dots,N-1.\n$$\n- The frequency associated with bin $k$ is $f_k = \\frac{k f_s}{N}$ (in Hz) for the $N$-point DFT. For a real-valued sequence, you may use the nonnegative frequency half-spectrum (for example, $k=0,\\dots,\\lfloor N/2 \\rfloor$).\n- Zero-padding to length $N'$ with $N' > N$ changes the DFT sample grid to $f_k' = \\frac{k f_s}{N'}$ but does not change the observation duration $T = \\frac{N}{f_s}$ or the underlying spectral spreading induced by the finite window.\n- The true resolvability of adjacent sinusoids is governed by the observation duration $T$ and the window function. For a rectangular window of duration $T$, the dominant spectral feature that sets the separation scale is the main-lobe width of the windowâ€™s transform, which is proportional to $\\frac{1}{T}$.\n\nYour program must implement the following tasks, using the explicit parameter values below and producing a single final line of output in the format described.\n\nTask A: Single-tone interpolation density versus resolution.\n1. Generate a synthetic sinusoid $x[n] = \\sin(2 \\pi f_0 n / f_s)$ of length $N$ with $f_s = 1000$ (Hz), $N=512$, and $f_0 = 123.45$ (Hz). The finite-duration window is rectangular and implicit in the length $N$.\n2. Compute the magnitude of the DFT using no zero-padding (effective $N' = N$) and with zero-padding by a factor $8$ (effective $N' = 8N$). For each case:\n   - Estimate the sinusoid frequency by the naive maximum-bin method, $f_{\\text{naive}}$, by taking the frequency of the bin with maximum magnitude.\n   - Estimate the sinusoid frequency by three-point quadratic interpolation around the maximum magnitude bin, yielding an estimate $f_{\\text{interp}}$ (in Hz). Use adjacent bins to the maximum to fit a parabola in the discrete bin domain.\n   - Compute the absolute errors $|f_{\\text{naive}} - f_0|$ and $|f_{\\text{interp}} - f_0|$ (in Hz).\n3. From these two zero-padding conditions, return the four floating-point results (in Hz):\n   - $E_{\\text{naive},1}$ for zero-padding factor $1$,\n   - $E_{\\text{naive},8}$ for zero-padding factor $8$,\n   - $E_{\\text{interp},1}$ for zero-padding factor $1$,\n   - $E_{\\text{interp},8}$ for zero-padding factor $8$.\n4. Also return two booleans:\n   - $B_{\\text{naive\\_improves}}$ which is $\\text{True}$ if $E_{\\text{naive},8} < E_{\\text{naive},1}$, showing that finer sampling reduces naive peak-picking error.\n   - $B_{\\text{interp\\_consistent}}$ which is $\\text{True}$ if $|f_{\\text{interp},8} - f_{\\text{interp},1}| < 0.01$ (Hz), showing that quadratic interpolation estimates are consistent across zero-padding levels because they estimate the underlying continuous-spectrum peak rather than depending on grid density.\n\nTask B: Two-tone resolvability with and without zero-padding.\n1. Construct two mixtures $x[n] = \\sin(2 \\pi f_1 n / f_s) + \\sin(2 \\pi f_2 n / f_s)$ with $f_s = 1000$ (Hz), $N=512$, and $f_1 = 200$ (Hz). Use two separations:\n   - Case B1: $f_2 = f_1 + \\delta_1$ with $\\delta_1 = 1.0$ (Hz), which is smaller than $\\frac{1}{T}$ for the given $N$ and $f_s$.\n   - Case B2: $f_2 = f_1 + \\delta_2$ with $\\delta_2 = 5.0$ (Hz), which is larger than $\\frac{1}{T}$ for the given $N$ and $f_s$.\n2. For each case, compute the DFT magnitude with zero-padding factor $1$ (effective $N' = N$) and factor $8$ (effective $N' = 8N$). Determine the count of resolved peaks using the following rule:\n   - Detect local maxima in the magnitude spectrum over nonnegative frequencies and keep those whose magnitudes exceed a fraction of the global maximum (use a fixed fraction to suppress side lobes, for example $0.3$).\n   - Cluster local maxima into distinct peaks if their frequency separation is at least $\\frac{1}{T}$ (in Hz), where $T = \\frac{N}{f_s}$ (seconds) is the original observation duration. Treat maxima closer than $\\frac{1}{T}$ as belonging to the same spectral lobe.\n   - The number of clusters is the number of resolved peaks.\n3. Return four booleans:\n   - $B_{\\text{unresolved\\_nopad}}$ which is $\\text{True}$ if Case B1 yields exactly one resolved peak for zero-padding factor $1$.\n   - $B_{\\text{unresolved\\_pad}}$ which is $\\text{True}$ if Case B1 yields exactly one resolved peak for zero-padding factor $8$.\n   - $B_{\\text{resolved\\_nopad}}$ which is $\\text{True}$ if Case B2 yields exactly two resolved peaks for zero-padding factor $1$.\n   - $B_{\\text{resolved\\_pad}}$ which is $\\text{True}$ if Case B2 yields exactly two resolved peaks for zero-padding factor $8$.\n\nPhysical units and angle unit specifics:\n- All frequency quantities, including errors, must be expressed in Hz.\n- Time duration $T$ must be implicitly used as $T = \\frac{N}{f_s}$ (in seconds).\n- No angle unit is required because all computations are in the frequency domain.\n\nTest suite parameters to implement in your program:\n- $f_s = 1000$ (Hz), $N=512$, $f_0 = 123.45$ (Hz), zero-padding factors $\\{1,8\\}$.\n- $f_1 = 200$ (Hz), $\\delta_1 = 1.0$ (Hz), $\\delta_2 = 5.0$ (Hz).\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n  $[E_{\\text{naive},1},E_{\\text{naive},8},E_{\\text{interp},1},E_{\\text{interp},8},B_{\\text{naive\\_improves}},B_{\\text{interp\\_consistent}},B_{\\text{unresolved\\_nopad}},B_{\\text{unresolved\\_pad}},B_{\\text{resolved\\_nopad}},B_{\\text{resolved\\_pad}}]$.\n- The four numeric entries must be floats in Hz, and the six logical entries must be booleans.",
            "solution": "The problem requires a computational demonstration of two fundamental properties of the Discrete Fourier Transform (DFT) concerning zero-padding: its ability to increase the density of frequency-domain samples (interpolation) versus its inability to improve true frequency resolution. This is a critical concept in signal processing, particularly in fields like neuroscience where spectral analysis of time-series data (e.g., EEG, LFP) is common. The solution will be developed from first principles.\n\nLet a finite-duration, discrete-time signal be $x[n]$ for $n=0, 1, \\dots, N-1$, obtained by sampling a continuous signal at a frequency $f_s$. The observation duration is $T = N/f_s$. The $N$-point DFT of this signal is defined as:\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2 \\pi k n / N}, \\quad k=0, 1, \\dots, N-1.\n$$\nThe frequencies corresponding to the DFT bins are $f_k = k \\frac{f_s}{N}$.\n\nZero-padding consists of appending zeros to the signal $x[n]$ to create a new, longer signal $x'[n]$ of length $N' > N$. The DFT of $x'[n]$, an $N'$-point DFT, provides samples of the underlying spectrum at a finer grid of frequencies $f'_k = k \\frac{f_s}{N'}$. This process is equivalent to evaluating the Discrete-Time Fourier Transform (DTFT) of the original signal $x[n]$ at more frequency points. The DTFT, $X(e^{i\\omega})$, is a continuous function of the normalized angular frequency $\\omega$. The $N'$-point DFT gives samples of this function at $\\omega_k = 2\\pi k/N'$. Since the observation duration $T$ is unchanged, the shape of the underlying continuous spectrum, which is determined by the convolution of the signal's true spectrum with the Fourier transform of the time-domain window (here, a rectangular window of duration $T$), is not altered. The width of the main lobe of the window's transform, proportional to $1/T$, sets the limit on frequency resolution.\n\nThe program will demonstrate this through two tasks.\n\nTask A: Single-tone interpolation density versus resolution.\nThis task examines the estimation of the frequency of a single sinusoid. The signal is $x[n] = \\sin(2 \\pi f_0 n / f_s)$ for $n=0, \\dots, N-1$, with $f_s = 1000$ Hz, $N=512$, and $f_0 = 123.45$ Hz. The frequency $f_0$ is intentionally chosen to fall between DFT bins. The DTFT of this windowed sinusoid has a sinc-like shape, with its peak at $f_0$. We estimate this peak location from the DFT samples.\n\n1.  **Naive Frequency Estimation**: The frequency is estimated as that of the DFT bin with the maximum magnitude. Without zero-padding ($N' = N$), the frequency grid is coarse: $\\Delta f = f_s/N \\approx 1.953$ Hz. The bin with maximum amplitude will be the one closest to $f_0$, but there can be a significant error. With zero-padding ($N' = 8N$), the grid becomes much finer ($\\Delta f' = f_s/(8N) \\approx 0.244$ Hz), so the maximum-magnitude bin will be much closer to the true peak $f_0$. Consequently, the naive estimation error is expected to decrease significantly, so $B_{\\text{naive\\_improves}}$ should be True.\n\n2.  **Quadratic Interpolation**: This method provides a more accurate estimate of the peak of the underlying continuous spectrum. A parabola is fitted to the DFT magnitude at the peak sample and its two immediate neighbors. The location of the vertex of this parabola gives a refined frequency estimate. Let the DFT magnitude at the maximum bin $k_{\\text{max}}$ be $y_0$, and its neighbors at $k_{\\text{max}}-1$ and $k_{\\text{max}}+1$ be $y_{-1}$ and $y_1$ respectively. The fractional offset $\\delta$ from $k_{\\text{max}}$ is given by:\n    $$\n    \\delta = \\frac{1}{2} \\frac{y_{-1} - y_1}{y_{-1} - 2y_0 + y_1}\n    $$\n    The interpolated frequency is $f_{\\text{interp}} = (k_{\\text{max}} + \\delta) \\frac{f_s}{N'}$. Since this method estimates the peak of the continuous DTFT spectrum, its accuracy is largely independent of the DFT grid density, provided the grid is fine enough to capture the peak's shape. We expect the estimates with and without padding to be very similar, so $B_{\\text{interp\\_consistent}}$ should be True.\n\nTask B: Two-tone resolvability.\nThis task demonstrates that zero-padding does not improve the ability to resolve two closely spaced frequencies. The fundamental resolution limit is dictated by the observation period $T = N/f_s$. For a rectangular window, two equal-amplitude tones are generally considered resolvable if their frequency separation $\\Delta f$ is greater than $1/T$. Here, $T=512/1000 = 0.512$ s, so the resolution limit is approximately $1/T \\approx 1.953$ Hz.\n\nWe analyze two cases for the signal $x[n] = \\sin(2 \\pi f_1 n / f_s) + \\sin(2 \\pi f_2 n / f_s)$ with $f_1 = 200$ Hz:\n1.  **Case B1 (Unresolved)**: $f_2 = f_1 + 1.0$ Hz. The separation $\\delta_1 = 1.0$ Hz is less than $1/T$. The spectral responses of the two tones will overlap significantly, creating a single merged peak in the frequency spectrum. Zero-padding will provide a more detailed view of this single peak but will not split it into two. We expect to find one resolved peak both with and without zero-padding, making $B_{\\text{unresolved\\_nopad}}$ and $B_{\\text{unresolved\\_pad}}$ True.\n2.  **Case B2 (Resolved)**: $f_2 = f_1 + 5.0$ Hz. The separation $\\delta_2 = 5.0$ Hz is greater than $1/T$. The two tones are sufficiently far apart to be resolved. Their spectral responses should form two distinct peaks. Without padding, the coarse DFT grid might or might not clearly show two maxima, but with sufficient zero-padding, two distinct peaks will definitely emerge. The peak counting logic, which clusters local maxima based on the physical resolution limit $1/T$, is designed to correctly identify the number of fundamentally resolved spectral components. We expect to find two resolved peaks in both padding scenarios, making $B_{\\text{resolved\\_nopad}}$ and $B_{\\text{resolved\\_pad}}$ True.\n\nThe peak counting algorithm proceeds by finding all local maxima in the magnitude spectrum that are above a threshold ($30\\%$ of the global maximum, to discard sidelobes). Then, these maxima are clustered. Any set of maxima where adjacent frequencies are separated by less than the resolution limit $1/T$ are considered part of the same underlying spectral feature. The number of such clusters gives the count of resolved peaks. This procedure formalizes the distinction between fine-grained ripples on a single spectral peak (due to interpolation) and genuinely separate peaks from distinct signal components.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Task A parameters\n    fs = 1000.0  # Hz\n    N = 512\n    f0 = 123.45  # Hz\n    padding_factors_A = [1, 8]\n\n    # Task B parameters\n    f1 = 200.0  # Hz\n    delta1 = 1.0  # Hz\n    delta2 = 5.0  # Hz\n    padding_factors_B = [1, 8]\n\n    results = []\n\n    # --- Task A: Single-tone interpolation density versus resolution ---\n    \n    def analyze_single_tone(padding_factor):\n        N_padded = padding_factor * N\n        n = np.arange(N)\n        x = np.sin(2 * np.pi * f0 * n / fs)\n        \n        # Compute DFT\n        X_fft = np.fft.fft(x, n=N_padded)\n        \n        # Use only non-negative frequencies\n        num_positive_freqs = N_padded // 2\n        X_mag = np.abs(X_fft[:num_positive_freqs])\n        freqs = np.fft.fftfreq(N_padded, d=1.0/fs)[:num_positive_freqs]\n\n        # Naive frequency estimation\n        k_max = np.argmax(X_mag)\n        f_naive = freqs[k_max]\n\n        # Quadratic interpolation\n        if k_max == 0 or k_max == num_positive_freqs - 1:\n            # Peak is at boundary, interpolation is not possible\n            f_interp = f_naive\n        else:\n            y_m1 = X_mag[k_max - 1]\n            y_0 = X_mag[k_max]\n            y_1 = X_mag[k_max + 1]\n            \n            # Per the formula, handle potential division by zero\n            denominator = (y_m1 - 2*y_0 + y_1)\n            if denominator == 0:\n                 p = 0\n            else:\n                 p = 0.5 * (y_m1 - y_1) / denominator\n            \n            k_interp = k_max + p\n            # The frequency of bin k is k * fs / N_padded\n            f_interp = k_interp * fs / N_padded\n            \n        return f_naive, f_interp\n\n    # No zero-padding (factor 1)\n    f_naive_1, f_interp_1 = analyze_single_tone(padding_factors_A[0])\n    E_naive_1 = abs(f_naive_1 - f0)\n    E_interp_1 = abs(f_interp_1 - f0)\n\n    # Zero-padding by factor 8\n    f_naive_8, f_interp_8 = analyze_single_tone(padding_factors_A[1])\n    E_naive_8 = abs(f_naive_8 - f0)\n    E_interp_8 = abs(f_interp_8 - f0)\n\n    # Boolean checks for Task A\n    B_naive_improves = E_naive_8 < E_naive_1\n    B_interp_consistent = abs(f_interp_8 - f_interp_1) < 0.01\n\n    results.extend([E_naive_1, E_naive_8, E_interp_1, E_interp_8, \n                    B_naive_improves, B_interp_consistent])\n\n    # --- Task B: Two-tone resolvability ---\n\n    def count_resolved_peaks(f_a, f_b, padding_factor):\n        N_padded = padding_factor * N\n        T = N / fs\n        resolution_limit = 1.0 / T\n\n        n = np.arange(N)\n        x = np.sin(2 * np.pi * f_a * n / fs) + np.sin(2 * np.pi * f_b * n / fs)\n\n        # Compute DFT\n        X_fft = np.fft.fft(x, n=N_padded)\n        num_positive_freqs = N_padded // 2\n        X_mag = np.abs(X_fft[:num_positive_freqs])\n        freqs = np.fft.fftfreq(N_padded, d=1.0/fs)[:num_positive_freqs]\n\n        # Find local maxima\n        global_max = np.max(X_mag)\n        peak_indices, _ = find_peaks(X_mag, height=0.3 * global_max)\n        \n        if len(peak_indices) == 0:\n            return 0\n        \n        peak_freqs = freqs[peak_indices]\n        \n        # Cluster peaks\n        if len(peak_freqs) <= 1:\n            return len(peak_freqs)\n            \n        num_clusters = 1\n        # Frequencies from find_peaks are already sorted by their index\n        for i in range(len(peak_freqs) - 1):\n            if (peak_freqs[i+1] - peak_freqs[i]) >= resolution_limit:\n                num_clusters += 1\n        \n        return num_clusters\n\n    # Case B1: Unresolvable\n    f2_case1 = f1 + delta1\n    peaks_B1_nopad = count_resolved_peaks(f1, f2_case1, padding_factors_B[0])\n    peaks_B1_pad = count_resolved_peaks(f1, f2_case1, padding_factors_B[1])\n    \n    B_unresolved_nopad = (peaks_B1_nopad == 1)\n    B_unresolved_pad = (peaks_B1_pad == 1)\n\n    # Case B2: Resolvable\n    f2_case2 = f1 + delta2\n    peaks_B2_nopad = count_resolved_peaks(f1, f2_case2, padding_factors_B[0])\n    peaks_B2_pad = count_resolved_peaks(f1, f2_case2, padding_factors_B[1])\n\n    B_resolved_nopad = (peaks_B2_nopad == 2)\n    B_resolved_pad = (peaks_B2_pad == 2)\n    \n    results.extend([B_unresolved_nopad, B_unresolved_pad,\n                    B_resolved_nopad, B_resolved_pad])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}