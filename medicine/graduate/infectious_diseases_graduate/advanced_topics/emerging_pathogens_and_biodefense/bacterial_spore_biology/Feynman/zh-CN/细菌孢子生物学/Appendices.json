{
    "hands_on_practices": [
        {
            "introduction": "细菌形成芽孢的决定并非一蹴而就，而是由关键信号分子——磷酸化Spo0A（Spo0A~P）的浓度累积所控制的。本练习  将运用化学动力学原理，为这一累积过程建模，并计算达到芽孢形成“不归点”所需的时间。通过这个实践，你将学会如何从基本原理出发构建定量模型，从而对一个复杂的生物决策过程进行预测，深刻理解分子间的相互作用（如磷酸化与去磷酸化）是如何驱动细胞层面的决策的。",
            "id": "4629255",
            "problem": "考虑一个进入营养限制状态的均匀混合的 *Bacillus subtilis* 细胞种群，其中孢子形成的起始受磷酸化 Spo0A (Spo0A~P) 的浓度控制。设 $S(t)$ 表示在时间 $t$ 时磷酸化 Spo0A 的浓度，设 $S_{tot}$ 表示 Spo0A 的总浓度，在所关注的时间尺度上，由于其合成和降解可忽略不计，假定 $S_{tot}$ 为常数。磷酸化作用以准一级反应速率常数 $k_{phos}$ 将未磷酸化的 Spo0A 转化为 Spo0A~P，而去磷酸化作用以一级反应速率常数 $k_{dephos}$ 将 Spo0A~P 转化回未磷酸化的 Spo0A。假设在一个封闭系统中遵循质量作用动力学，并且没有其他的汇或源。\n\n从质量平衡和一级反应动力学的核心定义出发，在给定初始条件 $S(0) = S_0$（其中 $0 \\le S_0 \\le S_{tot}$）的情况下，推导出时间进程 $S(t)$，并确定 $S(t)$ 首次达到孢子形成起始的承诺阈值 $\\theta$ 的时间 $t_{\\theta}$。假设参数满足 $S(t)$ 从 $S_0$ 开始单调增加，并在有限时间内从下方穿过 $\\theta$，且 $0  \\theta  S_{tot}$。以分钟为单位表示最终时间。你的最终答案必须是一个关于 $t_{\\theta}$ 的、用 $k_{phos}$、$k_{dephos}$、$S_{tot}$、$S_0$ 和 $\\theta$ 表示的单一闭式解析表达式。",
            "solution": "该问题要求推导出磷酸化 Spo0A 的浓度（用 $S(t)$ 表示）达到阈值 $\\theta$ 的时间 $t_{\\theta}$。推导过程必须从质量平衡和反应动力学原理开始。\n\n首先，我们根据问题陈述来定义物种和参数。\n- $S(t)$：在时间 $t$ 时磷酸化 Spo0A (Spo0A~P) 的浓度。\n- $S_u(t)$：在时间 $t$ 时未磷酸化 Spo0A 的浓度。\n- $S_{tot}$：Spo0A 的总浓度，为常数。$S_{tot} = S(t) + S_u(t)$。\n- $k_{phos}$：Spo0A 磷酸化为 Spo0A~P 的准一级反应速率常数。\n- $k_{dephos}$：Spo0A~P 去磷酸化为 Spo0A 的一级反应速率常数。\n- $S(0) = S_0$：Spo0A~P 的初始浓度。\n- $\\theta$：Spo0A~P 的承诺阈值浓度。\n\n反应方案可以写成：\n$$ \\text{Spo0A} \\xrightarrow{k_{phos}} \\text{Spo0A~P} $$\n$$ \\text{Spo0A~P} \\xrightarrow{k_{dephos}} \\text{Spo0A} $$\n\nSpo0A~P 浓度的变化率 $\\frac{dS}{dt}$ 是其生成速率与移除速率之差。\n\n生成速率是未磷酸化的 Spo0A ($S_u(t)$) 的磷酸化。这是一个相对于 $S_u(t)$ 的准一级反应：\n$$ \\text{Rate}_{\\text{formation}} = k_{phos} S_u(t) $$\n使用质量平衡关系 $S_u(t) = S_{tot} - S(t)$，我们可以用 $S(t)$ 来表示生成速率：\n$$ \\text{Rate}_{\\text{formation}} = k_{phos} (S_{tot} - S(t)) $$\n\n移除速率是 Spo0A~P ($S(t)$) 的去磷酸化。这是一个一级反应：\n$$ \\text{Rate}_{\\text{removal}} = k_{dephos} S(t) $$\n\n结合这些速率，我们建立控制 $S(t)$ 时间演化的微分方程：\n$$ \\frac{dS}{dt} = \\text{Rate}_{\\text{formation}} - \\text{Rate}_{\\text{removal}} $$\n$$ \\frac{dS}{dt} = k_{phos} (S_{tot} - S(t)) - k_{dephos} S(t) $$\n\n为了求解这个方程，我们将其重排为线性一阶常微分方程的标准形式。\n$$ \\frac{dS}{dt} = k_{phos} S_{tot} - k_{phos} S(t) - k_{dephos} S(t) $$\n$$ \\frac{dS}{dt} = k_{phos} S_{tot} - (k_{phos} + k_{dephos}) S(t) $$\n$$ \\frac{dS}{dt} + (k_{phos} + k_{dephos}) S(t) = k_{phos} S_{tot} $$\n\n这是一个形式为 $\\frac{dy}{dt} + P(t)y = Q(t)$ 的非齐次线性常微分方程，其中 $y=S(t)$，$P(t) = k_{phos} + k_{dephos}$，$Q(t) = k_{phos} S_{tot}$。$P$ 和 $Q$ 都是常数。\n\n该方程的通解是齐次解与一个特解之和。当 $\\frac{dS}{dt} = 0$ 时，达到稳态浓度 $S_{ss}$。\n$$ 0 = k_{phos} S_{tot} - (k_{phos} + k_{dephos}) S_{ss} $$\n$$ S_{ss} = \\frac{k_{phos} S_{tot}}{k_{phos} + k_{dephos}} $$\n$S(t)$ 的通解可以写成趋近于此稳态的形式：\n$$ S(t) = S_{ss} + C \\exp(-(k_{phos} + k_{dephos})t) $$\n其中 $C$ 是由初始条件 $S(0) = S_0$ 决定的积分常数。\n$$ S(0) = S_0 = S_{ss} + C \\exp(0) = S_{ss} + C $$\n$$ C = S_0 - S_{ss} $$\n将 $C$ 代回通解，得到 $S(t)$ 的显式时间进程：\n$$ S(t) = S_{ss} + (S_0 - S_{ss}) \\exp(-(k_{phos} + k_{dephos})t) $$\n这可以重写为：\n$$ S(t) = S_{ss} - (S_{ss} - S_0) \\exp(-(k_{phos} + k_{dephos})t) $$\n\n问题要求我们找到使 $S(t_{\\theta}) = \\theta$ 成立的时间 $t_{\\theta}$。我们在推导出的表达式中令 $S(t) = \\theta$ 和 $t = t_{\\theta}$：\n$$ \\theta = S_{ss} - (S_{ss} - S_0) \\exp(-(k_{phos} + k_{dephos})t_{\\theta}) $$\n\n现在，我们必须通过代数方法求解 $t_{\\theta}$。\n$$ (S_{ss} - S_0) \\exp(-(k_{phos} + k_{dephos})t_{\\theta}) = S_{ss} - \\theta $$\n$$ \\exp(-(k_{phos} + k_{dephos})t_{\\theta}) = \\frac{S_{ss} - \\theta}{S_{ss} - S_0} $$\n\n对两边取自然对数 ($\\ln$)：\n$$ -(k_{phos} + k_{dephos})t_{\\theta} = \\ln\\left(\\frac{S_{ss} - \\theta}{S_{ss} - S_0}\\right) $$\n$$ t_{\\theta} = -\\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{S_{ss} - \\theta}{S_{ss} - S_0}\\right) $$\n利用性质 $\\ln(1/x) = -\\ln(x)$，我们可以将对数的参数取倒数，以去掉前面的负号：\n$$ t_{\\theta} = \\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{S_{ss} - S_0}{S_{ss} - \\theta}\\right) $$\n\n问题陈述保证了 $S(t)$ 单调增加并从下方穿过 $\\theta$，这意味着 $S_0  \\theta  S_{ss}$。这确保了对数内分数的分子 ($S_{ss} - S_0$) 和分母 ($S_{ss} - \\theta$) 均为正值，并且由于 $S_0  \\theta$，因此 $S_{ss} - S_0  S_{ss} - \\theta$ 成立，使得对数的参数大于 1。因此，$t_{\\theta}$ 是正的且良定义的，这与物理时间的预期相符。\n\n最后，我们代入 $S_{ss}$ 的表达式，以获得用给定参数表示的最终答案：\n$$ t_{\\theta} = \\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{\\frac{k_{phos} S_{tot}}{k_{phos} + k_{dephos}} - S_0}{\\frac{k_{phos} S_{tot}}{k_{phos} + k_{dephos}} - \\theta}\\right) $$\n为简化对数内的表达式，我们对分子和分母进行通分：\n$$ t_{\\theta} = \\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{\\frac{k_{phos} S_{tot} - S_0(k_{phos} + k_{dephos})}{k_{phos} + k_{dephos}}}{\\frac{k_{phos} S_{tot} - \\theta(k_{phos} + k_{dephos})}{k_{phos} + k_{dephos}}}\\right) $$\n$$ t_{\\theta} = \\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{k_{phos} S_{tot} - S_0(k_{phos} + k_{dephos})}{k_{phos} S_{tot} - \\theta(k_{phos} + k_{dephos})}\\right) $$\n\n这就是 $t_{\\theta}$ 的最终闭式解析表达式。如果速率常数 $k_{phos}$ 和 $k_{dephos}$ 的单位是 $\\text{min}^{-1}$，那么 $t_{\\theta}$ 的单位将是分钟，满足问题的描述性要求。",
            "answer": "$$ \\boxed{ \\frac{1}{k_{phos} + k_{dephos}} \\ln \\left( \\frac{k_{phos} S_{tot} - S_0(k_{phos} + k_{dephos})}{k_{phos} S_{tot} - \\theta(k_{phos} + k_{dephos})} \\right) } $$"
        },
        {
            "introduction": "一旦细胞决定形成芽孢，一个复杂的遗传程序便会按特定顺序展开，这个过程由一系列σ因子构成的级联调控网络精确控制。本练习  将引导你从连续的动态变化转向离散的逻辑关系，使用布尔网络来模拟这一调控级联的时间序列。这项实践要求你像系统生物学家一样思考，将已知的生物学事实抽象成一个形式化的逻辑模型，并通过模拟野生型和突变体的表型来验证模型的正确性，从而深入理解芽孢发育过程中σ因子级联调控的鲁棒性和内在逻辑。",
            "id": "4629277",
            "problem": "您的任务是构建并验证一个最小化的同步布尔网络，该网络能够捕获细菌孢子形成过程中的区室化 sigma 因子级联反应。此过程始于传染病背景下 Spo0A 的激活，并重点关注细菌孢子生物学。该问题必须根据调控逻辑的第一性原理来解决，使用最小化的节点集合和单调的相互作用，这些相互作用需反映关于孢子形成的公认事实。您的程序应构建一个具体的网络实例，在野生型和突变扰动下进行模拟，并验证其动力学行为是否与典型的突变表型一致。\n\n基础和建模约束。使用同步布尔网络 (SBN)，其中每个节点都是一个在离散时间步中演化的布尔变量。对于节点 $X$，其在时间 $t$ 的状态，记为 $X(t) \\in \\{0,1\\}$，由一个使用时间 $t$ 输入的确定性布尔函数更新。该网络必须由对应以下生物实体和状态的节点组成：Spo0A (记为 $A$)、sigma 因子 $\\sigma^{\\mathrm{F}}$ (记为 $F$)、SpoIIR (记为 $R$)、sigma 因子 $\\sigma^{\\mathrm{E}}$ (记为 $E$)、吞噬完成 (记为 $G_{\\mathrm{eng}}$)、sigma 因子 $\\sigma^{\\mathrm{G}}$ (记为 $G$)、SpoIVB 蛋白酶 (记为 $B$) 和 sigma 因子 $\\sigma^{\\mathrm{K}}$ (记为 $K$)。您选择的更新规则必须相对于激活是单调的（在激活因子中仅使用逻辑合取和析取，并可选地包含保持已激活状态的自我维持机制），并且必须反映以下经过充分检验的生物学事实：\n- Spo0A 的激活先于 $\\sigma^{\\mathrm{F}}$ 的激活，并且是其必要条件。\n- $\\sigma^{\\mathrm{F}}$ 的活性是 SpoIIR 产生的必要条件。\n- SpoIIR 的活性是母细胞中 $\\sigma^{\\mathrm{E}}$ 激活的必要条件。\n- $\\sigma^{\\mathrm{E}}$ 的活性驱动吞噬过程，最终达到吞噬完成状态。\n- 前孢子中 $\\sigma^{\\mathrm{G}}$ 的激活需要吞噬完成和依赖于 $\\sigma^{\\mathrm{E}}$ 的因子。\n- SpoIVB 的产生需要 $\\sigma^{\\mathrm{G}}$。\n- 母细胞中 $\\sigma^{\\mathrm{K}}$ 的激活需要依赖于 $\\sigma^{\\mathrm{E}}$ 的加工过程以及来自前孢子的 SpoIVB 信号。\n\n初始条件、更新语义和强制。使用时间 $t=0$ 时的初始状态，其中 $A(0)=1$ 且所有其他节点均设为 $0$。对所有节点使用同步更新。为模拟突变体，您必须允许节点强制：一组节点在所有 $t \\ge 0$ 的时间内保持固定的布尔值，这会覆盖这些节点的任何更新逻辑；例如，$\\sigma^{\\mathrm{F}}$ 的缺失突变体通过在所有 $t \\ge 0$ 时间内强制 $F(t)=0$ 来建模。\n\n时间目标和验证谓词。您的模型必须在野生型条件下复现有序的级联反应：必须存在严格递增的激活时间 $t_F  t_E  t_G  t_K$，在这些时间点 $F$、然后是 $E$、然后是 $G$、然后是 $K$ 首次变为激活状态（即首次达到值 $1$）。在突变体中，您的模型必须复现上述事实所蕴含的典型阻断表型。您应该在一个足够大的有限时间范围 $T$ 内进行模拟，以允许激活在可能的情况下传播，其中 $T$ 设为 $12$。\n\n测试套件。实现以下测试用例，每个用例由一组节点强制约束定义；对于每个用例，在同步更新下模拟网络从 $t=0$ 到 $t=T$ 的行为，并将相应的谓词评估为布尔结果：\n- 用例 1 (野生型)：无强制。谓词：存在首次激活时间 $t_F, t_E, t_G, t_K \\in \\{0,1,\\dots,T\\}$，且满足 $t_F  t_E  t_G  t_K$。\n- 用例 2 (Spo0A 缺失)：在所有 $t \\ge 0$ 时间内强制 $A(t)=0$。谓词：$F$、$E$、$G$ 和 $K$ 在 $\\{0,1,\\dots,T\\}$ 时间内从未激活。\n- 用例 3 ($\\sigma^{\\mathrm{F}}$ 缺失)：在所有 $t \\ge 0$ 时间内强制 $F(t)=0$。谓词：$E$、$G$ 和 $K$ 在 $\\{0,1,\\dots,T\\}$ 时间内从未激活。\n- 用例 4 (SpoIIR 缺失)：在所有 $t \\ge 0$ 时间内强制 $R(t)=0$。谓词：$E$、$G$ 和 $K$ 在 $\\{0,1,\\dots,T\\}$ 时间内从未激活。\n- 用例 5 (吞噬受损)：在所有 $t \\ge 0$ 时间内强制 $G_{\\mathrm{eng}}(t)=0$。谓词：$E$ 在某个 $t \\in \\{0,1,\\dots,T\\}$ 时刻激活，但 $G$ 和 $K$ 从未激活。\n- 用例 6 (SpoIVB 缺失)：在所有 $t \\ge 0$ 时间内强制 $B(t)=0$。谓词：$E$ 和 $G$ 都在 $\\{0,1,\\dots,T\\}$ 的某个时刻激活，但 $K$ 从未激活。\n\n输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按用例 1 到 6 的顺序排列。每个条目必须是布尔字面量。例如，六个用例的输出形式为 $[b_1,b_2,b_3,b_4,b_5,b_6]$，其中每个 $b_i$ 是 True 或 False。此问题不涉及单位。角度和百分比不适用。您的程序不得读取任何输入。",
            "solution": "该问题要求构建并验证一个最小化的同步布尔网络 (SBN)，以模拟细菌孢子形成过程中的 sigma 因子级联。该模型必须基于调控逻辑的第一性原理构建，遵守指定的生物学约束，并根据典型的野生型和突变表型进行测试。\n\n首先，我们对系统进行形式化。在任何离散时间步 $t$，网络的状态由一个包含 8 个布尔变量的向量给出：\n$S(t) = (A(t), F(t), R(t), E(t), G_{\\mathrm{eng}}(t), G(t), B(t), K(t))$，其中每个分量都在 $\\{0, 1\\}$ 中。节点缩写对应于 Spo0A ($A$)、$\\sigma^{\\mathrm{F}}$ ($F$)、SpoIIR ($R$)、$\\sigma^{\\mathrm{E}}$ ($E$)、吞噬完成 ($G_{\\mathrm{eng}}$)、$\\sigma^{\\mathrm{G}}$ ($G$)、SpoIVB ($B$) 和 $\\sigma^{\\mathrm{K}}$ ($K$)。系统根据同步更新规则 $S(t+1) = \\mathbf{f}(S(t))$ 演化，其中 $\\mathbf{f}$ 是一个布尔更新函数的向量。\n\n更新函数的构建受到所提供的生物学事实和建模约束的指导。约束强制要求使用单调逻辑（仅使用合取和析取），并允许可选的自我维持机制以保持激活状态。对此建模的一种标准方法是 $X(t+1) = X(t) \\lor \\text{activation_logic}(t)$，这确保了节点一旦变为 $1$ 就会保持为 $1$。这反映了孢子形成过程中发育检查点的不可逆性质。“...是...的必要条件”这类生物学规则在激活逻辑中被转化为合取 ($\\land$)。\n\n基于这些原则，我们定义了最小化的更新规则：\n\n1.  **Spo0A ($A$)**: $A$ 是主调控因子，在开始时即为激活状态。在这个最小化模型中，它不受其他节点调控，因此它会保持自身状态。\n    $$A(t+1) = A(t)$$\n2.  **$\\sigma^{\\mathrm{F}}$ ($F$)**: 激活需要 Spo0A ($A$)。\n    $$F(t+1) = F(t) \\lor A(t)$$\n3.  **SpoIIR ($R$)**: 产生需要 $\\sigma^{\\mathrm{F}}$ ($F$)。\n    $$R(t+1) = R(t) \\lor F(t)$$\n4.  **$\\sigma^{\\mathrm{E}}$ ($E$)**: 激活需要 SpoIIR ($R$)。\n    $$E(t+1) = E(t) \\lor R(t)$$\n5.  **吞噬 ($G_{\\mathrm{eng}}$)**: 完成过程由 $\\sigma^{\\mathrm{E}}$ ($E$) 驱动。\n    $$G_{\\mathrm{eng}}(t+1) = G_{\\mathrm{eng}}(t) \\lor E(t)$$\n6.  **$\\sigma^{\\mathrm{G}}$ ($G$)**: 激活需要吞噬完成 ($G_{\\mathrm{eng}}$) 和依赖于 $\\sigma^{\\mathrm{E}}$ 的因子 ($E$)。\n    $$G(t+1) = G(t) \\lor (G_{\\mathrm{eng}}(t) \\land E(t))$$\n7.  **SpoIVB ($B$)**: 产生需要 $\\sigma^{\\mathrm{G}}$ ($G$)。\n    $$B(t+1) = B(t) \\lor G(t)$$\n8.  **$\\sigma^{\\mathrm{K}}$ ($K$)**: 激活需要来自前孢子经由 SpoIVB ($B$) 的信号，以及在母细胞中依赖于 $\\sigma^{\\mathrm{E}}$ ($E$) 的加工过程。\n    $$K(t+1) = K(t) \\lor (E(t) \\land B(t))$$\n\n模拟从 $t=0$ 时的初始状态开始，此时 $A(0)=1$ 且所有其他节点均为 $0$。对于突变体分析，特定节点在所有时间步 $t \\ge 0$ 被“强制”为固定值（$0$ 或 $1$），从而覆盖其更新规则。模拟运行的时间范围为 $T=12$ 步。\n\n为实现该解决方案，程序将为六个测试用例中的每一个模拟网络动力学。对于每个用例，它将：\n1.  为 $t \\in \\{0, 1, \\dots, T\\}$ 初始化一个状态历史数组。初始状态 $S(0)$ 设置为 $(1, 0, 0, 0, 0, 0, 0, 0)$。\n2.  应用特定测试用例的任何强制规则，这些规则可能会修改初始状态，并将在随后的每个步骤中覆盖更新。\n3.  使用上面定义的布尔函数，对 $t = 0, \\dots, T-1$ 迭代地从 $S(t)$ 计算 $S(t+1)$。计算出新状态后，应用强制规则。\n4.  模拟结束后，分析状态历史以评估该测试用例对应的布尔谓词。\n\n例如，要评估野生型谓词（用例 1），我们找到每个节点 $X \\in \\{F, E, G, K\\}$ 从 $0$ 变为 $1$ 的第一个时间步 $t_X$。然后我们验证严格不等式 $t_F  t_E  t_G  t_K$ 是否成立。对于突变体用例，谓词涉及检查某些节点是否在任何时间点激活，或在整个模拟过程中保持非激活状态。例如，在 $A$ 缺失突变体（用例 2）中，我们检查状态历史中对应于 $F、E、G、K$ 的列是否只包含零。最终输出是这六个谓词中每个谓词的布尔结果列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs, simulates, and validates a Boolean network model of\n    bacterial sporulation sigma factor cascade.\n    \"\"\"\n    \n    # Node mapping to indices in the state vector\n    NODE_MAP = {\n        'A': 0, 'F': 1, 'R': 2, 'E': 3, \n        'G_eng': 4, 'G': 5, 'B': 6, 'K': 7\n    }\n    NUM_NODES = len(NODE_MAP)\n    T = 12  # Simulation horizon\n\n    def get_update_rules(state):\n        \"\"\"\n        Calculates the next state based on the current state.\n        state: np.ndarray of shape (NUM_NODES,)\n        \"\"\"\n        A, F, R, E, G_eng, G, B, K = state\n        \n        next_state = np.zeros_like(state)\n        \n        # Apply the update logic based on the derived Boolean functions\n        next_state[NODE_MAP['A']] = A or A  # Self-maintenance\n        next_state[NODE_MAP['F']] = F or A\n        next_state[NODE_MAP['R']] = R or F\n        next_state[NODE_MAP['E']] = E or R\n        next_state[NODE_MAP['G_eng']] = G_eng or E\n        next_state[NODE_MAP['G']] = G or (G_eng and E)\n        next_state[NODE_MAP['B']] = B or G\n        next_state[NODE_MAP['K']] = K or (E and B)\n        \n        return next_state\n\n    def simulate(forcing_rules: dict):\n        \"\"\"\n        Simulates the Synchronous Boolean Network.\n        forcing_rules: A dictionary mapping node names to their forced values.\n        \"\"\"\n        history = np.zeros((T + 1, NUM_NODES), dtype=bool)\n        \n        # Initial state at t=0\n        history[0, NODE_MAP['A']] = 1\n        \n        # Apply forcing at t=0\n        for node_name, value in forcing_rules.items():\n            history[0, NODE_MAP[node_name]] = value\n            \n        # Synchronous updates for t = 0 to T-1\n        for t in range(T):\n            # Calculate next state based on current state\n            next_state = get_update_rules(history[t])\n            \n            # Apply forcing rules to the new state\n            for node_name, value in forcing_rules.items():\n                next_state[NODE_MAP[node_name]] = value\n            \n            history[t + 1] = next_state\n            \n        return history\n\n    def find_first_activation(history, node_idx):\n        \"\"\"Finds the first time step a node becomes 1.\"\"\"\n        activations = np.where(history[:, node_idx] == 1)[0]\n        return activations[0] if len(activations) > 0 else float('inf')\n\n    # Define test cases with their specific forcing rules\n    test_cases = [\n        {'name': 'Case 1 (wild type)', 'forcing': {}},\n        {'name': 'Case 2 (Spo0A deletion)', 'forcing': {'A': 0}},\n        {'name': 'Case 3 (sigmaF deletion)', 'forcing': {'F': 0}},\n        {'name': 'Case 4 (SpoIIR deletion)', 'forcing': {'R': 0}},\n        {'name': 'Case 5 (engulfment-impaired)', 'forcing': {'G_eng': 0}},\n        {'name': 'Case 6 (SpoIVB deletion)', 'forcing': {'B': 0}},\n    ]\n\n    results = []\n    \n    for i, case in enumerate(test_cases):\n        history = simulate(case['forcing'])\n        \n        if i == 0:  # Case 1 Predicate\n            t_F = find_first_activation(history, NODE_MAP['F'])\n            t_E = find_first_activation(history, NODE_MAP['E'])\n            t_G = find_first_activation(history, NODE_MAP['G'])\n            t_K = find_first_activation(history, NODE_MAP['K'])\n            # Check for activation within horizon and strict ordering\n            predicate_val = (t_F  t_E  t_G  t_K) and (t_K = T)\n            results.append(predicate_val)\n        \n        elif i == 1:  # Case 2 Predicate\n            # Check if F, E, G, K never activate\n            never_active = np.all(history[:, [NODE_MAP['F'], NODE_MAP['E'], NODE_MAP['G'], NODE_MAP['K']]] == 0)\n            results.append(never_active)\n            \n        elif i == 2:  # Case 3 Predicate\n            # Check if E, G, K never activate\n            never_active = np.all(history[:, [NODE_MAP['E'], NODE_MAP['G'], NODE_MAP['K']]] == 0)\n            results.append(never_active)\n\n        elif i == 3:  # Case 4 Predicate\n            # Check if E, G, K never activate\n            never_active = np.all(history[:, [NODE_MAP['E'], NODE_MAP['G'], NODE_MAP['K']]] == 0)\n            results.append(never_active)\n            \n        elif i == 4:  # Case 5 Predicate\n            # E activates, but G and K never activate\n            e_activates = np.any(history[:, NODE_MAP['E']] == 1)\n            g_k_never_active = np.all(history[:, [NODE_MAP['G'], NODE_MAP['K']]] == 0)\n            results.append(e_activates and g_k_never_active)\n            \n        elif i == 5:  # Case 6 Predicate\n            # E and G activate, but K never activates\n            e_activates = np.any(history[:, NODE_MAP['E']] == 1)\n            g_activates = np.any(history[:, NODE_MAP['G']] == 1)\n            k_never_activates = np.all(history[:, NODE_MAP['K']] == 0)\n            results.append(e_activates and g_activates and k_never_activates)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "芽孢最显著的特征之一是其惊人的环境抗性，尤其是耐热性，这在食品安全和医疗领域引起了高度关注。本练习  将芽孢的基础生物学知识与公共卫生领域的关键应用相结合。通过推导和应用热力致死动力学中的关键概念，如$D$值（十分之一缩减时间），你将学会如何量化芽孢的耐热性，并掌握设计有效灭菌方案以控制食源性或医源性芽孢污染的定量基础。",
            "id": "4629224",
            "problem": "罐装低酸食品的加工过程旨在灭活与传染病相关的耐热细菌芽孢。假设在等温暴露条件下，芽孢的灭活遵循活菌数的一级动力学。在温度 $T$ 下的十进制缩减时间（D值），记为 $D(T)$，定义为在温度 $T$ 下将活菌数减少 $10$ 倍所需的时间。$z$值定义为使D值减少 $10$ 倍所需的温度升高值。\n\n仅使用这些核心定义和一级灭活动力学的假设，从第一性原理推导出一个关于 $D(T)$ 的显式表达式，该表达式用参考温度 $T_{\\mathrm{ref}}$ 下的参考D值 $D_{\\mathrm{ref}}$、$z$值 $z$ 和目标温度 $T$ 来表示。然后，使用您推导出的关系式，计算当参考D值 $D_{\\mathrm{ref}} = 0.600\\,\\mathrm{min}$（在参考温度 $T_{\\mathrm{ref}} = 121\\,^{\\circ}\\mathrm{C}$ 时）、$z$值 $z = 8.5\\,^{\\circ}\\mathrm{C}$、目标温度 $T = 115\\,^{\\circ}\\mathrm{C}$ 时，芽孢的 $D(T)$ 值。\n\n将您的最终数值答案四舍五入至三位有效数字，并以分钟为单位表示时间。您的最终答案必须是一个实数值。",
            "solution": "该问题是有效的，因为它科学地基于热死时间动力学原理，这是食品微生物学中用于确保免受芽孢形成菌等传染性病原体危害的标准方法。该问题提法明确，提供了推导所求表达式和计算数值结果所需的所有必要定义和数据。\n\n推导过程从所提供的基本原理出发。\n\n首先，我们将芽孢灭活遵循一级动力学的陈述形式化。设 $N(t)$ 为在温度 $T$ 下的等温过程中，时间 $t$ 时的活菌数。灭活速率由以下微分方程给出：\n$$\n-\\frac{dN(t)}{dt} = k(T) N(t)\n$$\n其中 $k(T)$ 是与温度相关的一级反应速率常数。我们可以通过分离变量法求解该方程，从时间 $t=0$（初始芽孢数为 $N(0)=N_0$）积分到稍后的时间 $t$：\n$$\n\\int_{N_0}^{N(t)} \\frac{dN}{N} = -\\int_{0}^{t} k(T) dt'\n$$\n由于温度 $T$ 是恒定的，所以 $k(T)$ 相对于时间也是一个常数。积分得到：\n$$\n\\ln\\left(\\frac{N(t)}{N_0}\\right) = -k(T)t\n$$\n\n接下来，我们使用十进制缩减时间 $D(T)$ 的定义。这是将活菌数减少 $10$ 倍所需的时间。在 $t = D(T)$ 时，我们有 $N(D(T)) = \\frac{N_0}{10}$。将此条件代入积分速率方程：\n$$\n\\ln\\left(\\frac{N_0/10}{N_0}\\right) = -k(T)D(T)\n$$\n$$\n\\ln\\left(\\frac{1}{10}\\right) = -k(T)D(T)\n$$\n$$\n-\\ln(10) = -k(T)D(T)\n$$\n这给出了D值和速率常数之间的关系：\n$$\nD(T) = \\frac{\\ln(10)}{k(T)}\n$$\n\n现在，我们使用 $z$ 值的定义。$z$值是使D值减少 $10$ 倍所需的温度升高值。该定义意味着 $\\log(D)$ 和 $T$ 之间存在特定的关系。在热处理中，这被建模为D值的常用对数（以10为底）与温度之间的线性关系。也就是说，$\\log_{10}(D(T))$ 相对于 $T$ 的图像是一条直线。\n\n我们考虑这条直线上的两个点：$(T_1, \\log_{10}(D(T_1)))$ 和 $(T_2, \\log_{10}(D(T_2)))$。这条直线的斜率为：\n$$\nm = \\frac{\\log_{10}(D(T_2)) - \\log_{10}(D(T_1))}{T_2 - T_1}\n$$\n根据 $z$ 值的定义，如果我们将温度升高 $z$，即 $T_2 - T_1 = z$，则D值将减少 $10$ 倍，因此 $D(T_2) = \\frac{D(T_1)}{10}$。将此代入斜率方程的分子中：\n$$\n\\log_{10}(D(T_2)) - \\log_{10}(D(T_1)) = \\log_{10}\\left(\\frac{D(T_1)}{10}\\right) - \\log_{10}(D(T_1)) = \\log_{10}\\left(\\frac{1}{10}\\right) = -1\n$$\n因此，该直线的斜率为 $m = \\frac{-1}{z}$。\n\n使用参考点 $(T_{\\mathrm{ref}}, \\log_{10}(D_{\\mathrm{ref}}))$ 和一个通用点 $(T, \\log_{10}(D(T)))$ 的点斜式方程，我们得到：\n$$\n\\log_{10}(D(T)) - \\log_{10}(D_{\\mathrm{ref}}) = m(T - T_{\\mathrm{ref}})\n$$\n代入 $m = -1/z$：\n$$\n\\log_{10}(D(T)) - \\log_{10}(D_{\\mathrm{ref}}) = -\\frac{1}{z}(T - T_{\\mathrm{ref}})\n$$\n$$\n\\log_{10}\\left(\\frac{D(T)}{D_{\\mathrm{ref}}}\\right) = -\\frac{T - T_{\\mathrm{ref}}}{z}\n$$\n为了得到 $D(T)$ 的显式表达式，我们对等式两边取反对数（以10为底）：\n$$\n\\frac{D(T)}{D_{\\mathrm{ref}}} = 10^{-\\frac{T - T_{\\mathrm{ref}}}{z}}\n$$\n可以将其重新排列，得到所需的 $D(T)$ 表达式：\n$$\nD(T) = D_{\\mathrm{ref}} \\cdot 10^{\\frac{T_{\\mathrm{ref}} - T}{z}}\n$$\n这就是从第一性原理推导出的所需表达式。\n\n现在，我们使用这个关系式来计算给定参数下的 $D(T)$ 值：\n- 参考D值，$D_{\\mathrm{ref}} = 0.600\\,\\mathrm{min}$\n- 参考温度，$T_{\\mathrm{ref}} = 121\\,^{\\circ}\\mathrm{C}$\n- $z$值，$z = 8.5\\,^{\\circ}\\mathrm{C}$\n- 目标温度，$T = 115\\,^{\\circ}\\mathrm{C}$\n\n将这些值代入推导出的公式中：\n$$\nD(115\\,^{\\circ}\\mathrm{C}) = 0.600 \\cdot 10^{\\frac{121 - 115}{8.5}}\n$$\n指数中的温差为 $T_{\\mathrm{ref}} - T = 121 - 115 = 6\\,^{\\circ}\\mathrm{C}$。\n$$\nD(115\\,^{\\circ}\\mathrm{C}) = 0.600 \\cdot 10^{\\frac{6}{8.5}}\n$$\n我们现在计算数值：\n$$\n\\frac{6}{8.5} \\approx 0.70588235...\n$$\n$$\n10^{6/8.5} \\approx 10^{0.70588235...} \\approx 5.08010...\n$$\n$$\nD(115\\,^{\\circ}\\mathrm{C}) \\approx 0.600 \\times 5.08010... \\approx 3.04806...\n$$\n问题要求将最终答案四舍五入至三位有效数字。计算值为 $3.04806...\\,\\mathrm{min}$。四舍五入至三位有效数字得到 $3.05$。单位是分钟。",
            "answer": "$$\\boxed{3.05}$$"
        }
    ]
}