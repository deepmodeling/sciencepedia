{
    "hands_on_practices": [
        {
            "introduction": "病毒在宿主间传播时，通常只有少数病毒颗粒能够成功建立新的感染，这一过程被称为传播瓶颈。这个瓶颈对病毒的进化轨迹有深远影响，因为它引入了强烈的随机性（遗传漂变），可能导致供体宿主体内的低频变异在受体宿主中丢失或偶然被固定。这项练习将通过一个基础的概率模型，帮助您量化一个宿主内变异（iSNV）通过一个紧密瓶颈传播的概率，从而加深对病毒传播过程中随机性的理解 。",
            "id": "4707057",
            "problem": "在一次急性病毒爆发中，一个供体携带一种宿主内单核苷酸变异 (iSNV)，其在传染性病毒颗粒中的频率为 $f = 0.1$。在传播过程中，受体的感染由一个大小为 $b = 3$ 的紧密瓶颈引发，意味着恰好有 $b$ 个病毒颗粒建立了新的感染。假设在传染病的谱系动力学和全基因组测序 (WGS) 中，采用以下有经验依据且广泛使用的建模假设：供体病毒群体数量庞大，因此病毒颗粒可被视为独立同分布；每个病毒颗粒独立地以概率 $f$ 携带 iSNV；瓶颈是从供体群体中对 $b$ 个病毒颗粒进行的简单随机抽样。将“iSNV 传播”定义为至少有一个创始病毒颗粒携带 iSNV 的事件。从概率论的核心公理和独立伯努利试验的定义出发，推导在这些假设下 iSNV 得以传播的概率，然后计算当 $f=0.1$ 和 $b=3$ 时的概率值。将最终概率以小数形式表示，并四舍五入到四位有效数字。",
            "solution": "首先对问题进行验证，以确保其科学上成立、良定且客观。\n\n### 第 1 步：提取已知条件\n-   供体中宿主内单核苷酸变异 (iSNV) 的频率：$f = 0.1$。\n-   传播瓶颈的大小：$b = 3$。\n-   假设 1：供体病毒群体数量庞大。\n-   假设 2：病毒颗粒是独立同分布的 (i.i.d.)。\n-   假设 3：每个病毒颗粒独立地以概率 $f$ 携带 iSNV。\n-   假设 4：瓶颈是对 $b$ 个病毒颗粒的简单随机抽样。\n-   定义：“iSNV 传播”是至少有一个创始病毒颗粒携带 iSNV 的事件。\n\n### 第 2 步：使用提取的已知条件进行验证\n问题陈述描述了病毒谱系动力学和群体遗传学中的一个标准基础模型，特别是通过种群瓶颈的遗传漂变过程。\n-   **科学上成立：** 该模型是研究病毒进化和传播的基石。使用二项抽样过程来模拟传播瓶颈是一种被广泛接受且有经验支持的简化方法。给定的参数（$f=0.1$, $b=3$）对于急性病毒感染是符合实际的。该问题不含伪科学。\n-   **良定：** 所有必要的变量（$f$, $b$）、假设（独立同分布的伯努利试验）和定义（“iSNV 传播”）都已明确给出。问题是自洽的，其结构保证了存在唯一且有意义的解。\n-   **客观：** 问题以精确、正式的语言陈述，不含任何主观或基于观点的内容。\n\n### 第 3 步：结论与行动\n该问题被认为是有效的，因为它在科学上是合理的、良定的和客观的。将推导解答。\n\n### 推导过程\n问题要求从概率论的核心公理和独立伯努利试验的定义出发，推导 iSNV 传播的概率。\n\n设 $T$ 为 iSNV 被传播的事件。根据定义，这意味着建立新感染的 $b$ 个病毒颗粒中至少有一个携带 iSNV。\n\n直接计算 $T$ 的概率需要将恰好有 1 个病毒颗粒携带 iSNV、恰好有 2 个病毒颗粒携带 iSNV、... 直到恰好有 $b$ 个病毒颗粒携带 iSNV 的概率相加。一个更直接的方法是计算其对立事件 $T^c$ 的概率，并利用概率公理 $P(T) = 1 - P(T^c)$。\n\n对立事件 $T^c$ 是 iSNV *未*被传播的事件。这当且仅当 $b$ 个创始病毒颗粒中*没有一个*携带 iSNV 时发生。\n\n设 $A_i$ 为瓶颈样本中第 $i$ 个病毒颗粒携带 iSNV 的事件，其中 $i \\in \\{1, 2, \\dots, b\\}$。\n问题陈述每个病毒颗粒独立地以概率 $f$ 携带 iSNV。这构成了一个包含 $b$ 次独立伯努利试验的序列，其中“成功”定义为病毒颗粒携带 iSNV。\n任何一次试验成功的概率是 $P(A_i) = f$。\n“失败”（病毒颗粒不携带 iSNV）的概率，用事件 $A_i^c$ 表示，为 $P(A_i^c) = 1 - P(A_i) = 1 - f$。\n\n事件 $T^c$（无传播）对应于所有 $b$ 个病毒颗粒都未能携带 iSNV。这可以表示为各个失败事件的交集：\n$$T^c = A_1^c \\cap A_2^c \\cap \\dots \\cap A_b^c$$\n因为问题陈述病毒颗粒是独立的（假设 3），这些事件交集的概率是它们各自概率的乘积：\n$$P(T^c) = P(A_1^c \\cap A_2^c \\cap \\dots \\cap A_b^c) = P(A_1^c) \\times P(A_2^c) \\times \\dots \\times P(A_b^c)$$\n由于这些试验是同分布的，对所有 $i$ 都有 $P(A_i^c) = 1 - f$。因此：\n$$P(T^c) = (1 - f) \\times (1 - f) \\times \\dots \\times (1 - f) \\quad (b \\text{ 次})$$\n$$P(T^c) = (1 - f)^b$$\n该表达式给出了 $b$ 个病毒颗粒中没有一个携带 iSNV 的概率。这个结果等同于在具有 $b$ 次试验和成功概率为 $f$ 的二项分布中获得 $k=0$ 次成功的概率，即 $P(k=0) = \\binom{b}{0} f^0 (1-f)^{b-0} = (1-f)^b$。\n\n现在，我们可以使用对立事件概率公式来求得传播概率 $P(T)$：\n$$P(T) = 1 - P(T^c)$$\n$$P(T) = 1 - (1 - f)^b$$\n在所述假设下，这是一个频率为 $f$ 的变异通过大小为 $b$ 的瓶颈进行传播的通用概率公式。\n\n我们已知具体数值 $f = 0.1$ 和 $b = 3$。将这些值代入推导出的公式中：\n$$P(T) = 1 - (1 - 0.1)^3$$\n$$P(T) = 1 - (0.9)^3$$\n计算乘方：\n$$(0.9)^3 = 0.9 \\times 0.9 \\times 0.9 = 0.81 \\times 0.9 = 0.729$$\n现在，将这个值代回：\n$$P(T) = 1 - 0.729$$\n$$P(T) = 0.271$$\n问题要求答案以小数形式表示，并四舍五入到四位有效数字。精确答案 $0.271$ 有三位有效数字。为了用四位有效数字表示，我们必须在末尾添加一个零，在这种情况下，这个零是有效的。\n$$P(T) = 0.2710$$",
            "answer": "$$\\boxed{0.2710}$$"
        },
        {
            "introduction": "在疫情调查中，利用全基因组测序（WGS）的一个核心目标是重建传播链，即确定“谁感染了谁”。然而，仅靠基因组数据往往不足以做出明确判断。这项练习将引导您学习如何在一个贝叶斯框架下，正式地整合基因组证据（例如，序列完全相同）和流行病学证据（例如，病例采样时间间隔），以评估两个病例之间存在直接传播关系的可能性 。通过这个案例，您将掌握一种量化和权衡不同来源证据以进行传播推断的强大方法。",
            "id": "4706992",
            "problem": "在一次医院爆发的急性病毒感染中，全基因组测序 (WGS) 显示，两个病例的共有序列完全相同，其采样时间相隔 $\\Delta t = 5$ 天。为了整合基因组和流行病学的时间信息以进行疫情溯源，我们采用以下建模框架：序列间隔（从传染者症状出现到被传染者症状出现的时间）由一个伽马分布建模，其均值为 $m = 4$ 天，方差为 $v = 2$ 天$^{2}$。假设所有病例的采样延迟相同，因此采样时间差等于传播链上序列间隔的总和。进一步假设，在给定传播链长度的条件下，传播链上的序列间隔是独立同分布的。考虑到在短时间内基因组序列相同，我们采用一个双假设模型：要么是单次直接传播 ($N=1$)，要么是存在一个中间宿主 ($N=2$)。这两种情况的先验概率相等，即 $P(N=1) = P(N=2) = \\tfrac{1}{2}$，且 $P(N \\ge 3) = 0$。在假设 $N=n$ 的情况下，$\\Delta t$ 是 $n$ 个独立序列间隔的和。在 $t=\\Delta t$ 附近的小窗口极限下，用在 $t$ 处取值的相应概率密度来近似事件概率。仅使用这些假设，并从伽马分布均值和方差的基本定义以及具有相同尺度参数的独立伽马变量的可加性出发，计算在给定 $\\Delta t = 5$ 天的情况下，这两个病例之间存在直接传播联系的后验概率。最终答案以小数形式表示，并四舍五入到四位有效数字。最终答案中不包含任何单位。",
            "solution": "目标是计算在观测到样本间时间差为 $\\Delta t = 5$ 天的情况下，直接传播的后验概率 $P(N=1)$。这是一个贝叶斯推断问题，所求的量是 $P(N=1 | \\Delta t = 5)$。\n\n根据贝叶斯定理，后验概率由下式给出：\n$$ P(N=1 | \\Delta t = 5) = \\frac{P(\\Delta t = 5 | N=1) P(N=1)}{P(\\Delta t = 5)} $$\n分母是观测值的边缘概率，可以通过全概率定律对所有可能的假设求和得到：\n$$ P(\\Delta t = 5) = P(\\Delta t = 5 | N=1) P(N=1) + P(\\Delta t = 5 | N=2) P(N=2) $$\n问题陈述中提到，我们可以用在 $\\Delta t$ 附近的概率密度函数 (pdf) 的值来近似该点周围小窗口内事件的概率。设 $f_n(t)$ 为在 $n$ 次传播假设下时间差 $\\Delta t$ 的概率密度函数。因此，我们可以写出 $P(\\Delta t=5 | N=n) \\propto f_n(5)$。后验概率变为：\n$$ P(N=1 | \\Delta t = 5) \\approx \\frac{f_1(5) P(N=1)}{f_1(5) P(N=1) + f_2(5) P(N=2)} $$\n已知先验概率相等，$P(N=1) = P(N=2) = \\frac{1}{2}$。代入这些值可以简化表达式：\n$$ P(N=1 | \\Delta t = 5) \\approx \\frac{f_1(5) \\cdot \\frac{1}{2}}{f_1(5) \\cdot \\frac{1}{2} + f_2(5) \\cdot \\frac{1}{2}} = \\frac{f_1(5)}{f_1(5) + f_2(5)} $$\n为了求解该式，我们必须首先确定概率密度函数 $f_1(t)$ 和 $f_2(t)$。\n\n首先，我们求出单个序列间隔的伽马分布参数。设单个序列间隔 $T$ 为一个服从伽马分布的随机变量，$T \\sim \\text{Gamma}(\\alpha, \\beta)$，其形状参数为 $\\alpha > 0$，率参数为 $\\beta > 0$。其概率密度函数为 $f(t; \\alpha, \\beta) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} t^{\\alpha-1} \\exp(-\\beta t)$。该分布的均值 $m$ 和方差 $v$ 由下式给出：\n$$ m = E[T] = \\frac{\\alpha}{\\beta} $$\n$$ v = \\text{Var}(T) = \\frac{\\alpha}{\\beta^2} $$\n已知 $m = 4$ 天，$v = 2$ 天$^2$。我们可以求解 $\\alpha$ 和 $\\beta$：\n$$ \\frac{m}{v} = \\frac{\\alpha/\\beta}{\\alpha/\\beta^2} = \\beta \\implies \\beta = \\frac{4}{2} = 2 $$\n使用 $\\beta=2$，我们可以求出 $\\alpha$：\n$$ \\alpha = m \\cdot \\beta = 4 \\cdot 2 = 8 $$\n因此，单个序列间隔由一个 $\\text{Gamma}(\\alpha=8, \\beta=2)$ 分布建模。\n\n在假设 $N=1$ 的情况下，时间差 $\\Delta t$ 是单个序列间隔的持续时间。因此，$\\Delta t$ 的分布是 $\\text{Gamma}(8, 2)$，其概率密度函数 $f_1(t)$ 为：\n$$ f_1(t) = f(t; 8, 2) = \\frac{2^8}{\\Gamma(8)} t^{8-1} \\exp(-2t) = \\frac{256}{7!} t^7 \\exp(-2t) $$\n\n在假设 $N=2$ 的情况下，$\\Delta t$ 是两个独立同分布的序列间隔之和，即 $\\Delta t = T_1 + T_2$，其中 $T_1, T_2 \\sim \\text{Gamma}(8, 2)$。伽马分布的一个基本性质是，具有相同率参数的独立伽马变量之和仍然是伽马变量。新的形状参数是各个形状参数之和。\n$$ \\Delta t \\sim \\text{Gamma}(\\alpha_1+\\alpha_2, \\beta) = \\text{Gamma}(8+8, 2) = \\text{Gamma}(16, 2) $$\n这种情况下，概率密度函数 $f_2(t)$ 为：\n$$ f_2(t) = f(t; 16, 2) = \\frac{2^{16}}{\\Gamma(16)} t^{16-1} \\exp(-2t) = \\frac{65536}{15!} t^{15} \\exp(-2t) $$\n\n现在我们可以通过计算在 $t = \\Delta t = 5$ 时这些密度的比值来计算后验概率：\n$$ P(N=1 | \\Delta t = 5) \\approx \\frac{f_1(5)}{f_1(5) + f_2(5)} = \\frac{1}{1 + \\frac{f_2(5)}{f_1(5)}} $$\n让我们计算比值 $R = \\frac{f_2(5)}{f_1(5)}$：\n$$ R = \\frac{\\frac{2^{16}}{15!} 5^{15} \\exp(-2 \\cdot 5)}{\\frac{2^8}{7!} 5^7 \\exp(-2 \\cdot 5)} = \\frac{2^{16} \\cdot 5^{15} \\cdot 7!}{2^8 \\cdot 5^7 \\cdot 15!} $$\n$\\exp(-10)$ 项相互抵消。简化幂和阶乘：\n$$ R = \\frac{2^{16-8} \\cdot 5^{15-7}}{15!/7!} = \\frac{2^8 \\cdot 5^8}{15 \\cdot 14 \\cdot 13 \\cdot 12 \\cdot 11 \\cdot 10 \\cdot 9 \\cdot 8} = \\frac{(2 \\cdot 5)^8}{15 \\cdot 14 \\cdot 13 \\cdot 12 \\cdot 11 \\cdot 10 \\cdot 9 \\cdot 8} $$\n$$ R = \\frac{10^8}{259459200} = \\frac{100000000}{259459200} $$\n为了简化这个分数，我们可以将分母表示为其质因数的乘积。\n分母是 $15!/7! = (3 \\cdot 5) \\cdot (2 \\cdot 7) \\cdot 13 \\cdot (2^2 \\cdot 3) \\cdot 11 \\cdot (2 \\cdot 5) \\cdot 3^2 \\cdot 2^3 = 2^7 \\cdot 3^4 \\cdot 5^2 \\cdot 7 \\cdot 11 \\cdot 13$。\n分子是 $10^8 = (2 \\cdot 5)^8 = 2^8 \\cdot 5^8$。\n因此，比值 $R$ 为：\n$$ R = \\frac{2^8 \\cdot 5^8}{2^7 \\cdot 3^4 \\cdot 5^2 \\cdot 7 \\cdot 11 \\cdot 13} = \\frac{2 \\cdot 5^6}{3^4 \\cdot 7 \\cdot 11 \\cdot 13} = \\frac{2 \\cdot 15625}{81 \\cdot 1001} = \\frac{31250}{81081} $$\n现在，我们将此代回到后验概率的表达式中：\n$$ P(N=1 | \\Delta t = 5) \\approx \\frac{1}{1 + R} = \\frac{1}{1 + \\frac{31250}{81081}} = \\frac{1}{\\frac{81081 + 31250}{81081}} = \\frac{81081}{112331} $$\n进行除法运算得到最终的数值答案：\n$$ P(N=1 | \\Delta t = 5) \\approx 0.721815... $$\n四舍五入到四位有效数字，后验概率为 $0.7218$。",
            "answer": "$$\\boxed{0.7218}$$"
        },
        {
            "introduction": "在理解了单个变异的传播和两个病例间的传播联系之后，系统动力学分析的最终目标是揭示整个疫情的宏观动态。这项综合性练习将理论与实践相结合，要求您编写程序，直接从重建的传播树中估算一个关键的流行病学参数——有效再生数 ($R_e$)。通过计算总传播事件和总感染时间，您将估算传播率，并结合感染持续时间来计算$\\hat{R}_e$，这个过程将弥合系统发育理论与实际疫情参数估计之间的鸿沟 。",
            "id": "4707035",
            "problem": "您将获得一组根据传染病暴发中病原体的全基因组测序 (WGS) 重建的传播树。每棵树代表随时间推移的宿主之间的推断传播事件，其中一个节点对应一个受感染的宿主，具有传染性开始时间和传染性结束时间（移除）。从父节点到子节点的边表示在子节点的感染时间，由父节点向子节点的一次传播。目标是通过结合平均分支强度（单位时间内的传播率）和传染性分支持续时间的估计值，从树中估计有效再生数 ($R_e$)，其定义为在当前条件下，一个典型传染性宿主产生的预期继发感染数，然后将所得估计值与每棵树的独立流行病学估计值进行比较。\n\n基本原理和定义：\n- 有效再生数 ($R_e$) 定义为当前条件下的 $R_e = \\mathbb{E}[\\text{每个传染性宿主的传播数量}]$。\n- 考虑一个用于传播的均匀出生-死亡模型，其中每个传染性宿主的传播事件作为速率为 $\\beta$（单位时间）的泊松过程发生，宿主移除以速率 $\\gamma$ 发生。传染期 $D$ 的均值为 $\\mathbb{E}[D] = 1/\\gamma$。在这些假设下，每个宿主的预期传播数量为 $R_e = \\beta \\cdot \\mathbb{E}[D]$。\n- 对于一组具有观测到的传染区间，并可能在研究结束时间 $T_{\\text{end}}$ 处存在右删失的宿主，均匀泊松率 $\\hat{\\beta}$ 的最大似然估计 (MLE) 是观测到的总传播事件数 $N$ 除以观测到的总暴露时间 $\\sum_i T_i$，其中 $T_i$ 是宿主 $i$ 的观测到的传染风险时间。具体来说，$\\hat{\\beta} = N / \\sum_i T_i$。如果所有传染期都被完全观测且未经删失，$\\mathbb{E}[D]$ 的一个经验估计是样本均值 $\\widehat{\\mathbb{E}}[D] = \\frac{1}{n_{\\text{unc}}} \\sum_{i: e_i \\le T_{\\text{end}}} (e_i - s_i)$。如果传染期是删失的，则可以使用均值传染期的独立流行病学估计值 $D_{\\text{epi}}$ 来代表 $\\mathbb{E}[D]$。\n- 由此产生的基于树的 $R_e$ 估计值为 $\\hat{R}_e = \\hat{\\beta} \\cdot \\widehat{\\mathbb{E}}[D]$，其中 $\\widehat{\\mathbb{E}}[D]$ 是未删失的样本均值或独立的流行病学均值。\n\n您的任务：\n- 实现一个程序，使用上述原理为每棵树计算 $\\hat{R}_e$。\n- 对于每个宿主 $i$，您将获得一个感染开始时间 $s_i$（以天为单位），一个传染结束时间 $e_i$（以天为单位），该时间可能未知（表示为删失），以及一个指示来自 $i$ 的传播的子节点列表。研究结束时间为 $T_{\\text{end}}$（以天为单位）。\n- 宿主 $i$ 的观测风险时间为 $T_i = \\max\\{0, \\min(e_i, T_{\\text{end}}) - s_i\\}$（以天为单位）。如果子节点 $j$ 的感染时间 $s_j \\le T_{\\text{end}}$ 且 $s_j \\in [s_i, \\min(e_i, T_{\\text{end}})]$，则从宿主 $i$ 到其子节点 $j$ 的一次传播被计数。\n- 计算观测到的总传播数 $N$、总观测暴露时间 $\\sum_i T_i$ 和 $\\hat{\\beta} = N / \\sum_i T_i$。\n- 按如下方式计算 $\\widehat{\\mathbb{E}}[D]$：\n  - 如果树指定使用从树中导出的均值，则选取所有满足 $e_i \\le T_{\\text{end}}$ 的非删失持续时间的宿主，并计算 $\\widehat{\\mathbb{E}}[D] = \\frac{1}{n_{\\text{unc}}} \\sum_{i: e_i \\le T_{\\text{end}}} (e_i - s_i)$（以天为单位）。如果 $n_{\\text{unc}} = 0$，则回退到使用提供的独立均值 $D_{\\text{epi}}$（以天为单位）。\n  - 否则，使用提供的独立均值 $D_{\\text{epi}}$（以天为单位）。\n- 计算基于树的 $R_e$ 估计值 $\\hat{R}_e = \\hat{\\beta} \\cdot \\widehat{\\mathbb{E}}[D]$（无量纲）。\n- 通过计算绝对差 $|\\hat{R}_e - R_{e,\\text{epi}}|$ 和一个布尔值来比较 $\\hat{R}_e$ 与提供的独立流行病学估计值 $R_{e,\\text{epi}}$（无量纲），该布尔值指示此差异是否在给定的容差 $\\tau$（无量纲）之内，其中容差是为每个测试指定的（例如，$\\tau = 0.1$）。\n\n单位和输出规范：\n- 所有时间必须以天为单位处理。速率是每天。有效再生数 $R_e$ 是无量纲的。报告数值结果时，将所有浮点数四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表。每个测试用例结果本身必须是一个列表，包含四舍五入的 $\\hat{R}_e$（浮点数）、四舍五入的 $R_{e,\\text{epi}}$（浮点数）、四舍五入的绝对差（浮点数）和容差内布尔指示符。例如：\"[[r1_tree,r1_epi,diff1,ok1],[r2_tree,r2_epi,diff2,ok2],...]\"。\n\n测试套件：\n使用以下四棵树作为输入测试套件。在每棵树中，确保传播时间在每个父节点的传染区间内，并正确处理删失的持续时间。\n\n- 测试用例 1（具有右删失的早期增长窗口；使用独立的均值持续时间）：\n  - $T_{\\text{end}} = 10$ 天，使用 $D_{\\text{epi}} = 8.0$ 天，$\\tau = 0.1$，$R_{e,\\text{epi}} = 1.5$。\n  - 节点 (id: ($s_i,e_i$) 天, 子节点列表):\n    - $0$：$(0, 15)$，子节点 $[1,2,3]$；子节点感染时间：$s_1 = 2, s_2 = 4, s_3 = 7$。\n    - $1$：$(2, 12)$，子节点 $[4,5]$；子节点感染时间：$s_4 = 5, s_5 = 9$。\n    - $2$：$(4, 12)$，子节点 $[6]$；子节点感染时间：$s_6 = 7$。\n    - $3$：$(7, \\text{删失})$，子节点 $[7]$；子节点感染时间：$s_7 = 9$。\n    - $4$：$(5, 13)$，子节点 $[]$。\n    - $5$：$(9, \\text{删失})$，子节点 $[]$。\n    - $6$：$(7, 14)$，子节点 $[]$。\n    - $7$：$(9, \\text{删失})$，子节点 $[]$。\n- 测试用例 2（已完成的缓慢传播暴发；使用从树中导出的均值持续时间）：\n  - $T_{\\text{end}} = 100$ 天，使用树均值，$\\tau = 0.1$，$R_{e,\\text{epi}} = 0.8$。\n  - 节点：\n    - $0$：$(0, 8)$，子节点 $[1,2]$；$s_1 = 2, s_2 = 4$。\n    - $1$：$(2, 6)$，子节点 $[]$。\n    - $2$：$(4, 9)$，子节点 $[3]$；$s_3 = 7$。\n    - $3$：$(7, 10)$，子节点 $[]$。\n- 测试用例 3（无观测到的传播；使用从树中导出的均值持续时间）：\n  - $T_{\\text{end}} = 10$ 天，使用树均值，$\\tau = 0.1$，$R_{e,\\text{epi}} = 0.05$。\n  - 节点：\n    - $0$：$(0, 5)$，子节点 $[]$。\n- 测试用例 4（已完成的中度传播；使用从树中导出的均值持续时间）：\n  - $T_{\\text{end}} = 100$ 天，使用树均值，$\\tau = 0.1$，$R_{e,\\text{epi}} = 0.85$。\n  - 节点：\n    - $0$：$(0, 10)$，子节点 $[1,2]$；$s_1 = 3, s_2 = 6$。\n    - $1$：$(3, 8)$，子节点 $[3]$；$s_3 = 5$。\n    - $2$：$(6, 15)$，子节点 $[4,5]$；$s_4 = 8, s_5 = 9$。\n    - $3$：$(5, 9)$，子节点 $[]$。\n    - $4$：$(8, 13)$，子节点 $[]$。\n    - $5$：$(9, 12)$，子节点 $[]$。\n\n您的程序必须精确地实现上述逻辑，并按规定生成单行输出，浮点数四舍五入到三位小数，布尔值指示容差满足情况。不需要外部输入；程序必须在内部嵌入测试套件。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于传染病系统动力学的既定原则，在数学上是适定的，并提供了一套完整且一致的定义和数据。\n\n核心任务是从重建的传播树中估计有效再生数 $R_e$，并将其与独立的流行病学估计值 $R_{e,\\text{epi}}$ 进行比较。基本原理基于均匀出生-死亡传播模型，其中 $R_e$ 是每个传染性宿主的传播率 $\\beta$ 与平均传染期 $\\mathbb{E}[D]$ 的乘积。该关系由以下公式给出：\n$$R_e = \\beta \\cdot \\mathbb{E}[D]$$\n\n算法过程涉及从提供的树数据中估计两个分量：$\\beta$ 和 $\\mathbb{E}[D]$。\n\n**1. 传播率的估计 ($\\hat{\\beta}$)**\n\n传播率使用其对均匀泊松过程的最大似然估计 (MLE) 进行估计，即观测到的事件总数除以总观察时间。在此背景下：\n$$\\hat{\\beta} = \\frac{N}{\\sum_i T_i}$$\n其中 $N$ 是观测到的总传播事件数，$\\sum_i T_i$ 是研究中所有传染性宿主风险时间的总和。\n\n-   **总观测传播数 ($N$)：** 我们通过检查树中每个父-子传播链来确定 $N$。如果从父宿主 $i$ 到子宿主 $j$ 的一次传播发生在观察窗口内，则被计数。这需要满足两个条件：子节点的感染时间 $s_j$ 必须发生在研究结束时间 $T_{\\text{end}}$ 或之前，并且必须落在父节点的观测传染期内。宿主 $i$ 的有效传播区间为 $[s_i, \\min(e_i, T_{\\text{end}})]$。因此，如果 $s_j \\le T_{\\text{end}}$ 且 $s_i \\le s_j \\le \\min(e_i, T_{\\text{end}})$，则一次传播被计数。\n\n-   **总风险时间 ($\\sum_i T_i$)：** 这个量代表所有宿主在其传染期间并可能被观察到传播病原体的总持续时间。对于每个宿主 $i$，其感染开始时间为 $s_i$，结束时间为 $e_i$，其观测风险时间 $T_i$ 会被研究结束时间 $T_{\\text{end}}$ 截断。如果传染性结束时间 $e_i$ 未知（删失），则将其视为延伸到 $T_{\\text{end}}$ 之后。单个宿主贡献的公式为：\n    $$T_i = \\max\\{0, \\min(e_i, T_{\\text{end}}) - s_i\\}$$\n    总风险时间是树中所有宿主这些值的总和。\n\n**2. 平均传染期的估计 ($\\widehat{\\mathbb{E}}[D]$)**\n\n问题指定了两种不同的方法来估计平均传染期 $\\mathbb{E}[D]$：\n\n-   **从树中导出的均值：** 当指定时，此估计值是根据特定宿主子集的传染期样本均值计算得出的。只有当宿主 $i$ 的传染期被完全观察到（即 $e_i$ 未被删失）且其传染期在研究结束时间 $T_{\\text{end}}$ 或之前结束（$e_i \\le T_{\\text{end}}$）时，才将其纳入此计算。如果满足这些条件的宿主数量为 $n_{\\text{unc}}$，则估计值为：\n    $$\\widehat{\\mathbb{E}}[D] = \\frac{1}{n_{\\text{unc}}} \\sum_{i: e_i \\le T_{\\text{end}}} (e_i - s_i)$$\n    如果没有宿主满足这些标准（$n_{\\text{unc}} = 0$），则计算回退到使用提供的独立流行病学均值 $D_{\\text{epi}}$。\n\n-   **独立的流行病学均值：** 当指定时，直接使用外部提供的值 $D_{\\text{epi}}$ 作为 $\\widehat{\\mathbb{E}}[D]$。当树数据严重删失或被认为不足以进行可靠的内部估计时，这是一种常见做法。\n\n**3. 最终计算与比较**\n\n有了这两个分量的估计值后，基于树的有效再生数 $\\hat{R}_e$ 计算如下：\n$$\\hat{R}_e = \\hat{\\beta} \\cdot \\widehat{\\mathbb{E}}[D]$$\n这个无量纲值表示从传播树的结构和时间推断出的每个宿主的平均继发感染数。\n\n最后，将此估计值与独立的流行病学值 $R_{e,\\text{epi}}$ 进行比较。通过绝对差 $|\\hat{R}_e - R_{e,\\text{epi}}|$ 和一个布尔检查来量化这种比较，以确定此差异是否在给定的容差 $\\tau$ 之内：\n$$|\\hat{R}_e - R_{e,\\text{epi}}| \\le \\tau$$\n实现将根据这些原则处理每个测试用例，得出 $\\hat{R}_e$、$R_{e,\\text{epi}}$、它们的绝对差以及容差检查的值，所有浮点结果均四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares tree-based and epidemiological estimates of the\n    effective reproductive number (R_e) for a suite of transmission trees.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # np.inf is used to represent censored end-of-infectiousness times.\n    test_cases = [\n        # Test case 1: early-growth window with right-censoring; use independent mean duration\n        {\n            \"T_end\": 10.0,\n            \"d_epi\": 8.0,\n            \"tau\": 0.1,\n            \"r_epi\": 1.5,\n            \"use_tree_mean\": False,\n            \"nodes\": {\n                0: {'s': 0.0, 'e': 15.0, 'children': [1, 2, 3]},\n                1: {'s': 2.0, 'e': 12.0, 'children': [4, 5]},\n                2: {'s': 4.0, 'e': 12.0, 'children': [6]},\n                3: {'s': 7.0, 'e': np.inf, 'children': [7]},\n                4: {'s': 5.0, 'e': 13.0, 'children': []},\n                5: {'s': 9.0, 'e': np.inf, 'children': []},\n                6: {'s': 7.0, 'e': 14.0, 'children': []},\n                7: {'s': 9.0, 'e': np.inf, 'children': []}\n            }\n        },\n        # Test case 2: completed slow-spread outbreak; use tree-derived mean duration\n        {\n            \"T_end\": 100.0,\n            \"d_epi\": 0,  # Not used, but provided for fallback consistency\n            \"tau\": 0.1,\n            \"r_epi\": 0.8,\n            \"use_tree_mean\": True,\n            \"nodes\": {\n                0: {'s': 0.0, 'e': 8.0, 'children': [1, 2]},\n                1: {'s': 2.0, 'e': 6.0, 'children': []},\n                2: {'s': 4.0, 'e': 9.0, 'children': [3]},\n                3: {'s': 7.0, 'e': 10.0, 'children': []}\n            }\n        },\n        # Test case 3: no observed transmission; use tree-derived mean duration\n        {\n            \"T_end\": 10.0,\n            \"d_epi\": 5.0,  # Fallback value\n            \"tau\": 0.1,\n            \"r_epi\": 0.05,\n            \"use_tree_mean\": True,\n            \"nodes\": {\n                0: {'s': 0.0, 'e': 5.0, 'children': []}\n            }\n        },\n        # Test case 4: completed moderate transmission; use tree-derived mean duration\n        {\n            \"T_end\": 100.0,\n            \"d_epi\": 0,  # Not used\n            \"tau\": 0.1,\n            \"r_epi\": 0.85,\n            \"use_tree_mean\": True,\n            \"nodes\": {\n                0: {'s': 0.0, 'e': 10.0, 'children': [1, 2]},\n                1: {'s': 3.0, 'e': 8.0, 'children': [3]},\n                2: {'s': 6.0, 'e': 15.0, 'children': [4, 5]},\n                3: {'s': 5.0, 'e': 9.0, 'children': []},\n                4: {'s': 8.0, 'e': 13.0, 'children': []},\n                5: {'s': 9.0, 'e': 12.0, 'children': []}\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        T_end = case[\"T_end\"]\n        nodes_data = case[\"nodes\"]\n        \n        total_exposure_time = 0.0\n        total_transmissions = 0\n        \n        # Calculate total exposure time and total number of transmissions\n        for host_id, data in nodes_data.items():\n            s_i = data['s']\n            e_i = data['e']\n            \n            # Calculate observed time-at-risk for host i\n            time_at_risk = max(0, min(e_i, T_end) - s_i)\n            total_exposure_time += time_at_risk\n            \n            # Check for observed transmissions from host i\n            parent_risk_end = min(e_i, T_end)\n            for child_id in data['children']:\n                child_data = nodes_data[child_id]\n                s_j = child_data['s']\n                \n                # Check if transmission is observed within the valid time window\n                if s_j = T_end and s_i = s_j = parent_risk_end:\n                    total_transmissions += 1\n\n        # Calculate beta_hat (transmission rate)\n        if total_exposure_time > 0:\n            beta_hat = total_transmissions / total_exposure_time\n        else:\n            beta_hat = 0.0\n\n        # Calculate mean infectious duration (E[D])\n        mean_D = 0.0\n        if case[\"use_tree_mean\"]:\n            uncensored_durations = []\n            for host_id, data in nodes_data.items():\n                if data['e'] != np.inf and data['e'] = T_end:\n                    duration = data['e'] - data['s']\n                    uncensored_durations.append(duration)\n            \n            if len(uncensored_durations) > 0:\n                mean_D = sum(uncensored_durations) / len(uncensored_durations)\n            else:\n                # Fallback to provided independent mean if no hosts qualify\n                mean_D = case[\"d_epi\"]\n        else:\n            mean_D = case[\"d_epi\"]\n\n        # Calculate tree-based R_e\n        r_e_hat = beta_hat * mean_D\n        \n        # Compare with epidemiological R_e\n        r_epi = case[\"r_epi\"]\n        abs_diff = abs(r_e_hat - r_epi)\n        is_within_tolerance = abs_diff = case[\"tau\"]\n        \n        # Format results as specified: list of [float, float, float, bool]\n        result_list = [\n            round(r_e_hat, 3),\n            round(r_epi, 3),\n            round(abs_diff, 3),\n            is_within_tolerance\n        ]\n        results.append(result_list)\n        \n    # Final print statement must produce the single-line format specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}