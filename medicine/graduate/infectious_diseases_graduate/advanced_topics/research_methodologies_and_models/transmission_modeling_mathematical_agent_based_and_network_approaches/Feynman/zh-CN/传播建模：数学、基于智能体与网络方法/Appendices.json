{
    "hands_on_practices": [
        {
            "introduction": "基本再生数 $R_0$ 是流行病学建模的基石。相比于仅仅记忆公式，理解其如何从传播和恢复等基本机制中推导出来更为关键。本练习  将指导你从第一性原理出发，通过显式计算一个典型感染者在其随机感染期内产生的预期二次感染数，来推导出 $R_0$ 的表达式，从而深化你对这一核心概念的理解。",
            "id": "4700719",
            "problem": "考虑一个大的、封闭的、均匀混合的种群，该种群在个体层面通过易感-感染-康复 (SIR) 框架进行建模。在时间 $t=0$ 时，一个感染者被引入到一个规模为 $N$ 的完全易感的种群中，因此 $S(0)\\approx N$。假设以下基本机理：\n- 在感染期间，个体产生可能导致传播事件的潜在感染性接触，这是一个时间齐次泊松过程，其瞬时速率为 $\\lambda(t)=\\beta\\,\\frac{S(t)}{N}$，其中 $\\beta$ 的单位是 $\\mathrm{day}^{-1}$，$S(t)$ 是在时间 $t$ 的易感者数量。\n- 感染者的康复是一个无记忆事件，具有恒定的风险（率）$\\gamma$（单位为 $\\mathrm{day}^{-1}$），因此感染期 $T$ 是指数分布的，其生存函数为 $\\Pr(T>t)=\\exp(-\\gamma t)$。\n\n仅从基本再生数（一个典型感染者在其他方面均为易感人群的种群中产生的二代感染的期望数）的定义和上述机理假设出发，通过显式计算在随机感染期内产生的传播事件总数的期望，推导出基本再生数 $R_0$ 关于 $\\beta$ 和 $\\gamma$ 的表达式。然后，用 $\\beta=0.25$ $\\mathrm{day}^{-1}$ 和 $\\gamma=0.2$ $\\mathrm{day}^{-1}$ 计算你的表达式。提供确切的数值；不要四舍五入。\n\n最后，根据你推导的表达式和关于无病平衡点的线性化论证，说明单个感染病例的引入是否会导致入侵（感染的初始增长），并根据你计算的 $R_0$ 简要证明其阈值条件。你的最终数值答案应该是计算出的 $R_0$ 值，不带单位。",
            "solution": "该问题陈述是数理流行病学中的一个有效练习。它具有科学依据、问题明确、客观，并包含推导所需量和得出所需结论的所有必要信息。\n\n基本再生数 $R_0$ 定义为一个典型感染者在一个其他方面完全易感的种群中产生的二代感染的期望数。我们被要求根据这个定义和所提供的机理假设来推导 $R_0$ 的表达式。\n\n设 $K$ 为单个指示病例产生的二代感染数的随机变量。根据定义，$R_0 = E[K]$。\n\n问题陈述指出，来自一个感染者的传播事件是作为时间齐次泊松过程发生的。该过程的瞬时速率为 $\\lambda(t) = \\beta \\frac{S(t)}{N}$。为了计算 $R_0$，我们考虑一个被引入到一个几乎完全易感的种群中的个体。因此，我们可以设定在该个体的整个感染期内 $S(t) \\approx N$。这将传播速率简化为一个常数：\n$$ \\lambda = \\beta \\frac{N}{N} = \\beta $$\n感染期 $T$ 是一个随机变量。问题指明它服从指数分布，具有恒定的风险率 $\\gamma$。$T$ 的概率密度函数 (PDF) 为 $f_T(t) = \\gamma \\exp(-\\gamma t)$，对于 $t \\ge 0$。\n\n为了求出二代感染的期望数 $E[K]$，我们可以通过以感染期 $T$ 的持续时间为条件，使用全期望定律。\n$$ R_0 = E[K] = E[E[K|T]] $$\n对于一个固定的持续时间为 $T=t$ 的感染期，二代感染数 $K$ 是一个在长度为 $t$ 的区间上观察到的、具有恒定速率 $\\beta$ 的泊松过程的随机变量。这样一个过程的期望事件数是速率乘以持续时间。因此，给定 $T=t$ 时 $K$ 的条件期望是：\n$$ E[K | T=t] = \\beta t $$\n这意味着 $E[K|T] = \\beta T$，其中 $T$ 仍然是一个随机变量。\n\n接下来，我们对这个表达式关于 $T$ 的分布求期望：\n$$ R_0 = E[\\beta T] = \\beta E[T] $$\n一个速率为 $\\gamma$ 的指数分布随机变量的期望值 $E[T]$，是 $t$ 乘以其概率密度函数在其支撑集上的积分：\n$$ E[T] = \\int_0^\\infty t f_T(t) dt = \\int_0^\\infty t \\gamma \\exp(-\\gamma t) dt $$\n这是指数分布均值的定义，是一个标准结果：\n$$ E[T] = \\frac{1}{\\gamma} $$\n将此结果代入 $R_0$ 的表达式，我们得到推导出的表达式：\n$$ R_0 = \\beta \\left(\\frac{1}{\\gamma}\\right) = \\frac{\\beta}{\\gamma} $$\n这个表达式证实了一个经典结果，即基本再生数是单位时间的传播率与平均感染持续时间的乘积。\n\n现在，我们用给定的参数值来计算这个表达式：$\\beta = 0.25 \\ \\mathrm{day}^{-1}$ 和 $\\gamma = 0.2 \\ \\mathrm{day}^{-1}$。\n$$ R_0 = \\frac{0.25}{0.2} = \\frac{25/100}{2/10} = \\frac{25}{100} \\times \\frac{10}{2} = \\frac{25}{20} = \\frac{5}{4} = 1.25 $$\n量 $R_0$ 是无量纲的，因为 $\\beta$ 和 $\\gamma$ 的单位（$\\mathrm{day}^{-1}$）相互抵消了。\n\n最后，我们评估单个病例的引入是否会导致入侵。这可以通过分析无病平衡点（DFE）附近感染人群 $I(t)$ 的初始增长来确定，其中 $(S, I, R) = (N, 0, 0)$。在SIR模型中，控制感染者数量的微分方程是：\n$$ \\frac{dI}{dt} = \\beta \\frac{S(t)I(t)}{N} - \\gamma I(t) = I(t) \\left( \\beta \\frac{S(t)}{N} - \\gamma \\right) $$\n对于流行病的初始阶段，我们可以通过设置 $S(t) \\approx N$ 在无病平衡点附近对该方程进行线性化。方程变为：\n$$ \\frac{dI}{dt} \\approx I(t) \\left( \\beta \\frac{N}{N} - \\gamma \\right) = I(t) (\\beta - \\gamma) $$\n为了使感染在种群中入侵，感染者数量必须在初期增加，即 $\\frac{dI}{dt} > 0$。由于 $I(t)$ 必须为正，这要求：\n$$ \\beta - \\gamma > 0 \\implies \\beta > \\gamma \\implies \\frac{\\beta}{\\gamma} > 1 $$\n由于我们推导出 $R_0 = \\frac{\\beta}{\\gamma}$，入侵的条件恰好是 $R_0 > 1$。这是流行病学的基本阈值条件。如果 $R_0 > 1$，每个原发感染平均产生超过一个二代感染，导致疫情暴发初期的指数级增长。如果 $R_0 < 1$，每个感染平均产生少于一个新感染，疫情将会自行消亡。\n在这种情况下，我们计算出的值为 $R_0 = 1.25$。由于 $1.25 > 1$，入侵的条件得到满足。因此，单个感染病例的引入预计将导致一场流行病。",
            "answer": "$$\\boxed{1.25}$$"
        },
        {
            "introduction": "真实的易感人群并非完全同质，无症状传播等异质性因素会显著改变流行病的动态。本练习  引入下一代矩阵法，这是一个在包含不同人群分组（如有症状和无症状）的模型中计算 $R_0$ 的强大工具。通过这个练习，你将学会如何量化和修正因数据不完整（例如忽略无症状病例）而导致的 $R_0$ 估计偏差，这是一项极为重要的现实世界技能。",
            "id": "4700655",
            "problem": "考虑一种在完全易感人群中传播的病原体，每个新感染的个体有 $p_A$ 的概率为无症状感染者，有 $1 - p_A$ 的概率为有症状感染者。所有感染者具有相同的平均传染期 $\\tau$ 和相同的接触模式，但无症状病例相对于有症状病例具有一个恒定的相对传染性 $\\alpha$。假设有症状病例的人均传播率为 $\\beta$，因此在一个完全易感的人群中，一个有症状病例平均产生 $\\beta \\tau$ 个二代感染。假设二代感染的类型（无症状或有症状）与传染源的类型无关，任何二代感染成为无症状感染的概率为 $p_A$，成为有症状感染的概率为 $1 - p_A$。\n\n一位研究人员分析了仅包含有症状病例的个案数据，并拟合了一个完全忽略无症状感染的单一类型易感-感染-恢复模型，这相当于隐含地设置了 $p_A = 0$。通过这个拟合，研究人员得到了仅基于有症状传播的基本再生数估计值 $R_{\\text{neg}} = \\beta \\tau$。\n\n从基本再生数在多类型流行病过程中作为下一代算子谱半径的定义出发，推导在忽略无症状感染时，估计的基本再生数中的乘性偏差，将其表示为 $p_A$ 和 $\\alpha$ 的函数。然后，提出了一个将 $R_{\\text{neg}}$ 映射到真实基本再生数的乘性校正因子。将你的最终答案表示为校正后的基本再生数关于 $R_{\\text{neg}}$、$p_A$ 和 $\\alpha$ 的单个闭式解析表达式。不要进行四舍五入。",
            "solution": "首先将根据指定标准对问题进行验证。\n\n**步骤1：提取已知条件**\n- 病原体在完全易感人群中传播。\n- 每个新感染的个体有 $p_A$ 的概率为无症状。\n- 每个新感染的个体有 $1 - p_A$ 的概率为有症状。\n- 所有感染者具有相同的平均传染期 $\\tau$。\n- 无症状病例相对于有症状病例具有一个恒定的相对传染性 $\\alpha$。\n- 有症状病例的人均传播率为 $\\beta$。\n- 在一个完全易感的人群中，一个有症状病例平均产生 $\\beta \\tau$ 个二代感染。\n- 二代感染的类型与传染源的类型无关。\n- 一位研究人员拟合了一个忽略无症状感染的模型（隐含地设置了 $p_A=0$）。\n- 研究人员对基本再生数的估计值为 $R_{\\text{neg}} = \\beta \\tau$。\n- 任务是使用下一代算子方法推导乘性偏差，并找到对 $R_{\\text{neg}}$ 的校正。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题使用了数学流行病学中标准的、公认的概念，即基本再生数（$R_0$）、多类型疾病模型和下一代矩阵（NGM）方法。这些是分析传染病传播的基本工具。\n- **适定性：** 该问题定义清晰。它提供了所有必要的参数（$p_A$、$\\alpha$、$\\beta$、$\\tau$），并要求进行特定的推导，以得到一个唯一的解析表达式。\n- **客观性：** 该问题以精确、无偏见的数学和流行病学术语表述。它不包含任何主观或基于观点的陈述。\n- **完整性与一致性：** 该问题是自洽的。所提供的信息足以构建下一代矩阵（NGM）并推导出真实的$R_0$。定义 $R_{\\text{neg}} = \\beta \\tau$ 与仅考虑有症状个体的单一类型模型是一致的。没有矛盾之处。\n- **现实性：** 在现实世界的传染病监测和建模中，漏报或忽略无症状病例是一个常见且重要的问题。参数是符号化的，因此不会出现物理上的不一致性。\n- **结构与平凡性：** 该问题需要使用一种标准但非平凡的方法（针对 $2 \\times 2$ 系统的NGM）进行形式化推导。它不是一个同义反复，而是解决了流行病学中的一个核心概念问题。\n\n**步骤3：结论与行动**\n该问题是有效的。它在科学上是合理的，具有适定性、客观性，并且需要一个形式化的、非平凡的推导。现在开始解题过程。\n\n**求解推导**\n病原体的传播可以被建模为一个多类型分支过程，其中感染个体的类型由其临床表现决定。我们定义两种类型的感染个体：\n- 类型1：无症状（A）\n- 类型2：有症状（S）\n\n基本再生数 $R_0$ 是下一代矩阵 $K$ 的谱半径。该矩阵的元素 $K_{ij}$ 表示在一个完全易感的人群中，由单个 j 型感染个体引起的 i 型新感染的期望数量。\n\n让我们计算 $2 \\times 2$ 矩阵 $K$ 的元素。\n\n**由类型1（无症状）个体引起的感染：**\n- 有症状病例的人均传播率为 $\\beta$。\n- 无症状病例的相对传染性为 $\\alpha$。因此，其人均传播率为 $\\alpha \\beta$。\n- 平均传染期为 $\\tau$。\n- 单个无症状个体产生的二代感染总平均数为 $(\\alpha \\beta) \\tau$。\n- 这些新感染中有 $p_A$ 的比例将是无症状的（类型1），有 $1 - p_A$ 的比例将是有症状的（类型2）。\n- 因此：\n  - $K_{11}$（无症状感染源导致的无症状感染）= $p_A (\\alpha \\beta \\tau)$\n  - $K_{21}$（无症状感染源导致的有症状感染）= $(1 - p_A) (\\alpha \\beta \\tau)$\n\n**由类型2（有症状）个体引起的感染：**\n- 人均传播率为 $\\beta$。\n- 平均传染期为 $\\tau$。\n- 单个有症状个体产生的二代感染总平均数为 $\\beta \\tau$。\n- 这些新感染中有 $p_A$ 的比例将是无症状的（类型1），有 $1 - p_A$ 的比例将是有症状的（类型2）。\n- 因此：\n  - $K_{12}$（有症状感染源导致的无症状感染）= $p_A (\\beta \\tau)$\n  - $K_{22}$（有症状感染源导致的有症状感染）= $(1 - p_A) (\\beta \\tau)$\n\n下一代矩阵 $K$ 为：\n$$\nK = \\begin{pmatrix} p_A \\alpha \\beta \\tau & p_A \\beta \\tau \\\\ (1 - p_A) \\alpha \\beta \\tau & (1 - p_A) \\beta \\tau \\end{pmatrix}\n$$\n问题提供了研究人员的估计值 $R_{\\text{neg}} = \\beta \\tau$。我们可以将其代入矩阵中：\n$$\nK = \\begin{pmatrix} p_A \\alpha R_{\\text{neg}} & p_A R_{\\text{neg}} \\\\ (1 - p_A) \\alpha R_{\\text{neg}} & (1 - p_A) R_{\\text{neg}} \\end{pmatrix}\n$$\n该矩阵可以表示为两个向量的外积：\n$$\nK = R_{\\text{neg}} \\begin{pmatrix} p_A \\alpha & p_A \\\\ (1 - p_A) \\alpha & 1 - p_A \\end{pmatrix} = \\begin{pmatrix} p_A \\\\ 1 - p_A \\end{pmatrix} \\begin{pmatrix} \\alpha R_{\\text{neg}} & R_{\\text{neg}} \\end{pmatrix}\n$$\n这是一个秩为1的矩阵，形式为 $u v^T$，其中 $u = \\begin{pmatrix} p_A \\\\ 1 - p_A \\end{pmatrix}$ 且 $v^T = \\begin{pmatrix} \\alpha R_{\\text{neg}} & R_{\\text{neg}} \\end{pmatrix}$。一个秩为1的矩阵只有一个非零特征值，该值由矩阵的迹给出，或者更一般地，由标量积 $v^T u$ 给出。\n\n真实的再生数 $R_{0, \\text{true}}$ 是 $K$ 的谱半径 $\\rho(K)$，也就是 $K$ 的主特征值。\n$$\nR_{0, \\text{true}} = v^T u = \\begin{pmatrix} \\alpha R_{\\text{neg}} & R_{\\text{neg}} \\end{pmatrix} \\begin{pmatrix} p_A \\\\ 1 - p_A \\end{pmatrix}\n$$\n$$\nR_{0, \\text{true}} = (\\alpha R_{\\text{neg}}) p_A + R_{\\text{neg}} (1 - p_A)\n$$\n将 $R_{\\text{neg}}$ 因子提取出来：\n$$\nR_{0, \\text{true}} = R_{\\text{neg}} (\\alpha p_A + 1 - p_A) = R_{\\text{neg}} (1-p_A + p_A \\alpha)\n$$\n这个表达式给出了真实的再生数 $R_{0, \\text{true}}$。\n\n估计值 $R_{\\text{neg}}$ 中的乘性偏差源于忽略了无症状病例的贡献。真实值与估计值的比率为：\n$$\n\\frac{R_{0, \\text{true}}}{R_{\\text{neg}}} = 1 - p_A + p_A \\alpha\n$$\n该项表示朴素估计 $R_{\\text{neg}}$ 低估或高估真实值的因子。如果 $\\alpha > 1$，忽略无症状病例会导致低估。如果 $\\alpha < 1$，会导致高估。如果 $\\alpha=1$，则没有偏差，因为所有病例的传染性相同。\n\n问题要求一个将 $R_{\\text{neg}}$ 映射到真实基本再生数的乘性校正因子。这正是上面推导出的因子。校正后的基本再生数是 $R_{0, \\text{true}}$。因此，校正后数值的最终解析表达式为：\n校正后的 $R_0 = R_{\\text{neg}} (1 - p_A + p_A \\alpha)$.",
            "answer": "$$\\boxed{R_{\\text{neg}}(1 - p_A + p_A\\alpha)}$$"
        },
        {
            "introduction": "基于智能体的模型（Agent-Based Models, ABMs）对于捕捉复杂的个体层面互动至关重要，但其复杂性也使其容易出现实施错误。本动手编程练习  演示了模型验证这一关键过程。你将通过在简化的、具有解析解的场景下进行测试，来验证你的模拟程序是否正确地实现了其理论基础，这是确保模型可靠性的核心步骤。",
            "id": "4700645",
            "problem": "您的任务是为一种传染病传播的基于智能体的模型（ABM）设计验证测试，通过在受控的随机种子下，将事件计数和状态占用与可解析的基准进行比较。模型必须根据连续时间随机过程和网络传播的基本原理从头构建，并且结果必须以纯粹的数学术语表达，不得调用特定领域的捷径。您的程序必须是一个完整的、可运行的实现，它执行模拟并为固定的测试套件计算量化差异。输出必须是单行，包含一个浮点数列表（四舍五入到六位小数），代表每个测试用例在指定指标上的最大绝对相对误差。\n\n基本原理：\n- 一个连续时间马尔可夫链，其状态代表感染个体数量，该链源于事件的独立指数等待时间以及指数分布的无记忆性。\n- 一个泊松过程，其速率等于独立人均风险之和，以及指数事件间隔时间与泊松计数过程之间的等价性。\n- 一个星形图网络传播过程，其中边以独立的指数时间传播感染。\n\n模型类别：\n1. 具有无限易感者池的均匀混合线性生死（分支）感染过程。感染人口 $I(t)$ 作为一个连续时间马尔可夫链演化，其人均感染（出生）率为 $b$，人均恢复（死亡）率为 $d$。在时间 $t$，总感染事件率为 $b \\, I(t)$，总恢复事件率为 $d \\, I(t)$。ABM必须使用速率为 $(b+d)I(t)$ 的指数分布的事件间隔时间来模拟事件，并以 $b/(b+d)$ 的概率选择感染事件，以 $d/(b+d)$ 的概率选择恢复事件。初始感染计数为 $I(0)=I_0$。该过程运行直到时间 $T$ 或灭绝 $I(t)=0$。\n\n分支过程的解析基准：\n- $T$时刻的期望占用数：$$\\mathbb{E}[I(T)] = I_0 \\, e^{(b-d)T}.$$\n- $[0,T]$内感染事件的期望数量：$$\\mathbb{E}[N_{\\text{inf}}(0,T)] = \\int_0^T b \\, \\mathbb{E}[I(t)] \\, dt = \\begin{cases} b I_0 \\dfrac{e^{(b-d)T}-1}{b-d}, & b \\neq d, \\\\ b I_0 T, & b=d, \\end{cases}$$\n- $[0,T]$内恢复事件的期望数量：$$\\mathbb{E}[N_{\\text{rec}}(0,T)] = \\int_0^T d \\, \\mathbb{E}[I(t)] \\, dt = \\begin{cases} d I_0 \\dfrac{e^{(b-d)T}-1}{b-d}, & b \\neq d, \\\\ d I_0 T, & b=d. \\end{cases}$$\n\n2. 具有独立指数边风险且无恢复的星形网络传播。考虑一个有 $M$ 个叶节点和一个中心节点的星形图，中心节点初始为感染状态。对于每个叶节点，感染通过其到中心的边独立地以速率 $\\beta$ 发生。如果中心节点保持感染状态且没有恢复，则每个边上的感染时间是参数为 $\\beta$ 的指数分布，且在叶节点之间是独立的。ABM必须模拟叶节点的感染时间，并计算到时间 $T$ 为止被感染的叶节点数量。$T$时刻的占用数是 $I(T)=1 + N_{\\text{inf}}(0,T)$，因为中心节点保持感染状态。\n\n星形网络的解析基准：\n- 给定叶节点在时间 $T$ 前被感染的概率为 $$p(T) = 1 - e^{-\\beta T}.$$\n- 到时间 $T$ 为止感染事件的期望数量为 $$\\mathbb{E}[N_{\\text{inf}}(0,T)] = M \\, p(T).$$\n- $T$时刻的期望占用数为 $$\\mathbb{E}[I(T)] = 1 + M \\, p(T).$$\n\n验证指标：\n- 对于每个测试用例，计算所有可用解析指标中的最大绝对相对误差。对于分支用例，计算\n$$\\delta_I = \\frac{\\left| I(T) - \\mathbb{E}[I(T)] \\right|}{\\max(1, \\mathbb{E}[I(T)])}, \\quad \\delta_{\\text{inf}} = \\frac{\\left| N_{\\text{inf}}(0,T) - \\mathbb{E}[N_{\\text{inf}}(0,T)] \\right|}{\\max(1, \\mathbb{E}[N_{\\text{inf}}(0,T)])}, \\quad \\delta_{\\text{rec}} = \\frac{\\left| N_{\\text{rec}}(0,T) - \\mathbb{E}[N_{\\text{rec}}(0,T)] \\right|}{\\max(1, \\mathbb{E}[N_{\\text{rec}}(0,T)])},$$\n并将单个用例的得分报告为 $$\\Delta = \\max\\{\\delta_I, \\delta_{\\text{inf}}, \\delta_{\\text{rec}}\\}.$$\n- 对于星形网络用例，计算\n$$\\delta_I = \\frac{\\left| I(T) - \\mathbb{E}[I(T)] \\right|}{\\max(1, \\mathbb{E}[I(T)])}, \\quad \\delta_{\\text{inf}} = \\frac{\\left| N_{\\text{inf}}(0,T) - \\mathbb{E}[N_{\\text{inf}}(0,T)] \\right|}{\\max(1, \\mathbb{E}[N_{\\text{inf}}(0,T)])},$$\n并报告 $$\\Delta = \\max\\{\\delta_I, \\delta_{\\text{inf}}\\}.$$\n\n受控的随机种子：\n- 所有模拟都必须为伪随机数生成器使用固定的种子，以确保可复现性。\n\n测试套件：\n- 用例 $1$（分支，正常路径）：$(b, d, I_0, T, \\text{seed}) = (0.6, 0.2, 10, 5.0, 42)$。\n- 用例 $2$（分支，边界条件 $b=d$）：$(b, d, I_0, T, \\text{seed}) = (0.5, 0.5, 20, 4.0, 123)$。\n- 用例 $3$（星形网络，独立边）：$(M, \\beta, T, \\text{seed}) = (100, 0.05, 10.0, 2021)$。\n- 用例 $4$（星形网络，边界情况 $T=0$）：$(M, \\beta, T, \\text{seed}) = (50, 1.0, 0.0, 7)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个浮点数四舍五入到六位小数，顺序与上述测试用例一致（例如，$[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是用例 $i$ 的 $\\Delta$）。\n\n不涉及物理单位。不使用角度。请根据情况将所有量表示为小数或分数，不使用百分号。",
            "solution": "该问题要求为两类传染病传播的基于智能体的模型（ABM）设计并实现验证测试。验证是通过将使用固定随机种子以保证可复现性的随机模拟输出与已知的解析基准进行比较来执行的。差异使用指定的相对误差指标进行量化。这两个模型是一个均匀混合线性生死过程和一个星形图网络传播过程。\n\n这些模型的基本原理是连续时间随机过程。事件，如感染或恢复，在随机时间发生。对于一个无记忆过程，到下一个事件的等待时间遵循指数分布。如果可以发生多个独立事件，那么到*下一个*（任何类型）事件的时间是指数分布的，其速率等于各个事件速率的总和。这是Gillespie算法的基石，该算法是模拟此类连续时间马尔可夫链（CTMC）的标准方法。\n\n**模型1：均匀混合线性生死过程**\n\n该模型描述了在一个易感者供应被视为无限的群体中，感染者数量 $I(t)$ 的变化。该过程是一个在非负整数上的连续时间马尔可夫链。\n- **感染**（出生）事件使计数增加1：$I \\to I+1$。人均速率为 $b$，总感染事件速率为 $b I(t)$。\n- **恢复**（死亡）事件使计数减少1：$I \\to I-1$。人均速率为 $d$，总恢复事件速率为 $d I(t)$。\n\n在时间 $t$ 发生任何事件的总速率是个体速率之和：$$\\lambda(t) = b I(t) + d I(t) = (b+d)I(t).$$\n到下一个事件的时间 $\\Delta t$ 是一个速率为 $\\lambda(t)$ 的指数随机变量，即 $\\Delta t \\sim \\text{Exponential}((b+d)I(t))$。其概率密度函数为 $f(\\tau) = \\lambda e^{-\\lambda \\tau}$。\n\n假定一个事件已经发生，它是感染事件的概率是感染速率与总速率的比值：$$P(\\text{infection} | \\text{event}) = \\frac{b I(t)}{(b+d)I(t)} = \\frac{b}{b+d}.$$\n类似地，恢复的概率是 $P(\\text{recovery} | \\text{event}) = \\frac{d}{b+d}$。\n\n模拟算法如下：\n$1$. 初始化时间 $t=0$，感染计数 $I=I_0$，感染事件计数 $N_{\\text{inf}}=0$，恢复事件计数 $N_{\\text{rec}}=0$。\n$2$. 当当前时间 $t$ 小于最终时间 $T$ 且种群未灭绝 ($I>0$) 时：\n    a. 计算总事件速率 $\\lambda = (b+d)I$。\n    b. 通过从速率为 $\\lambda$ 的指数分布中抽样，生成一个时间步长 $\\Delta t$。这可以计算为 $\\Delta t = -(\\ln u_1) / \\lambda$，其中 $u_1 \\sim U(0,1)$ 是一个均匀随机变量。\n    c. 如果 $t + \\Delta t > T$，则在模拟窗口内没有更多事件发生。循环终止，最终状态是当前状态 $I$。\n    d. 否则，推进模拟时间：$t \\leftarrow t + \\Delta t$。\n    e. 确定事件类型。生成第二个均匀随机变量 $u_2 \\sim U(0,1)$。如果 $u_2  b/(b+d)$，事件为感染：$I \\leftarrow I+1$ 且 $N_{\\text{inf}} \\leftarrow N_{\\text{inf}}+1$。否则，为恢复：$I \\leftarrow I-1$ 且 $N_{\\text{rec}} \\leftarrow N_{\\text{rec}}+1$。\n$3$. 模拟输出是最终计数 $I(T)$（即循环终止时 $I$ 的值），以及总事件计数 $N_{\\text{inf}}(0,T)$ 和 $N_{\\text{rec}}(0,T)$。\n\n提供的解析基准是该过程期望值主方程的解。感染个体数的期望值 $\\mathbb{E}[I(t)]$ 根据微分方程 $\\frac{d}{dt}\\mathbb{E}[I(t)] = (b-d)\\mathbb{E}[I(t)]$ 演化。在初始条件 $\\mathbb{E}[I(0)] = I_0$ 下，解为 $\\mathbb{E}[I(T)] = I_0 e^{(b-d)T}$。事件的期望数量是通过对时间积分期望速率得到的：$\\mathbb{E}[N_{\\text{event}}(0,T)] = \\int_0^T \\text{rate}_{\\text{event}}(t) dt = \\int_0^T k \\mathbb{E}[I(t)] dt$，其中 $k$ 是人均事件速率（$b$ 或 $d$）。这个积分得出了问题陈述中提供的公式。\n\n**模型2：星形网络传播**\n\n该模型简化为一组 $M$ 个独立的伯努利试验。一个中心节点是感染性的，并且永不恢复。它连接到 $M$ 个易感的叶节点。感染沿每条边独立传播，具有恒定的风险率 $\\beta$。\n任何单个叶节点的感染时间 $T_{\\text{inf}}$ 是一个速率为 $\\beta$ 的指数随机变量：$T_{\\text{inf}} \\sim \\text{Exponential}(\\beta)$。\n一个叶节点在时间 $T$ 之前被感染，当且仅当其感染事件发生在时间 $T$ 或之前，即 $T_{\\text{inf}} \\leq T$。此事件的概率由指数分布的累积分布函数（CDF）给出：$$p(T) = P(T_{\\text{inf}} \\leq T) = \\int_0^T \\beta e^{-\\beta \\tau} d\\tau = 1 - e^{-\\beta T}.$$\n由于所有 $M$ 个感染过程都是独立的，到时间 $T$ 为止被感染的叶节点总数 $N_{\\text{inf}}(0,T)$ 服从二项分布：$N_{\\text{inf}}(0,T) \\sim \\text{Binomial}(M, p(T))$。\n\n模拟算法是该过程的直接实现：\n$1$. 对于 $M$ 个叶节点中的每一个，从 $\\text{Exponential}(\\beta)$ 分布中生成一个独立的感染时间 $T_i$。\n$2$. 统计 $T_i \\leq T$ 的叶节点数量。这个计数是模拟中 $N_{\\text{inf}}(0,T)$ 的实现。\n$3$. 最终的感染种群是 $I(T) = 1 + N_{\\text{inf}}(0,T)$，因为中心节点保持感染状态。\n\n解析基准基于二项分布的期望。感染的期望数量是 $\\mathbb{E}[N_{\\text{inf}}(0,T)] = M \\times p(T)$。总感染种群的期望是 $\\mathbb{E}[I(T)] = 1 + \\mathbb{E}[N_{\\text{inf}}(0,T)]$。\n\n**验证指标与实现**\n\n对于每个指定的测试用例，程序将使用给定的参数和随机种子执行相应的模拟。然后，它将使用提供的公式计算解析基准。模拟输出（例如，$I(T)$, $N_{\\text{inf}}$）将与它们的期望值（例如，$\\mathbb{E}[I(T)]$, $\\mathbb{E}[N_{\\text{inf}}]$）使用绝对相对误差进行比较。分母 $\\max(1, \\mathbb{E}[\\cdot])$ 用于防止当期望值很小时出现除以零或误差膨胀的情况。每个测试用例的最终得分 $\\Delta$ 是这些单个相对误差中的最大值。\n\n实现将为每个模拟模型和基准计算包含独立的函数，以保持清晰的逻辑结构。`solve`主函数将遍历测试套件，分派到适当的函数，为每个用例计算 $\\Delta$，并将集体结果格式化为所需的输出字符串。使用 `numpy` 对于数值计算及其伪随机数生成器至关重要，必须为后者设定种子以保证可复现性。\n\n测试用例如下：\n- 用例 $1$（分支）：$(b, d, I_0, T, \\text{seed}) = (0.6, 0.2, 10, 5.0, 42)$。\n- 用例 $2$（分支）：$(b, d, I_0, T, \\text{seed}) = (0.5, 0.5, 20, 4.0, 123)$。\n- 用例 $3$（星形网络）：$(M, \\beta, T, \\text{seed}) = (100, 0.05, 10.0, 2021)$。\n- 用例 $4$（星形网络）：$(M, \\beta, T, \\text{seed}) = (50, 1.0, 0.0, 7)$。\n\n最终的代码将系统地处理这些用例，并生成一行包含计算出的$\\Delta$值的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def simulate_branching(b, d, I0, T, seed):\n        \"\"\"\n        Simulates the linear birth-death (branching) process.\n        This is an implementation of the Gillespie algorithm.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        t = 0.0\n        I = I0\n        n_inf = 0\n        n_rec = 0\n\n        while t  T and I > 0:\n            total_rate = (b + d) * I\n            if total_rate == 0:\n                break\n            \n            # Time to next event\n            dt = rng.exponential(1.0 / total_rate)\n\n            if t + dt > T:\n                # No more events occur before T\n                break\n            \n            t += dt\n            \n            # Determine event type\n            prob_inf = b / (b + d)\n            if rng.random()  prob_inf:\n                # Infection event (birth)\n                I += 1\n                n_inf += 1\n            else:\n                # Recovery event (death)\n                I -= 1\n                n_rec += 1\n        \n        # The state I at the end of the loop is the state at time T\n        return I, n_inf, n_rec\n\n    def benchmark_branching(b, d, I0, T):\n        \"\"\"\n        Calculates the analytical benchmarks for the branching process.\n        \"\"\"\n        exp_I_T = I0 * np.exp((b - d) * T)\n        \n        if b == d:\n            exp_n_inf = b * I0 * T\n            exp_n_rec = d * I0 * T\n        else:\n            common_factor = I0 * (np.exp((b - d) * T) - 1.0) / (b - d)\n            exp_n_inf = b * common_factor\n            exp_n_rec = d * common_factor\n            \n        return exp_I_T, exp_n_inf, exp_n_rec\n\n    def simulate_star(M, beta, T, seed):\n        \"\"\"\n        Simulates the star-network transmission process.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        \n        # For each of M leaves, draw an infection time from Exp(beta)\n        infection_times = rng.exponential(1.0 / beta, size=M)\n        \n        # Count how many get infected by time T\n        n_inf = np.sum(infection_times = T)\n        \n        # Total infectious population at T is 1 (center) + infected leaves\n        I_T = 1 + n_inf\n        \n        return I_T, n_inf\n\n    def benchmark_star(M, beta, T):\n        \"\"\"\n        Calculates the analytical benchmarks for the star-network process.\n        \"\"\"\n        p_T = 1.0 - np.exp(-beta * T)\n        exp_n_inf = M * p_T\n        exp_I_T = 1.0 + exp_n_inf\n        \n        return exp_I_T, exp_n_inf\n\n    def calculate_relative_error(sim_val, exp_val):\n        \"\"\"\n        Calculates the absolute relative error with a floor of 1 for the denominator.\n        \"\"\"\n        return np.abs(sim_val - exp_val) / np.max([1.0, exp_val])\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'branching', 'params': {'b': 0.6, 'd': 0.2, 'I0': 10, 'T': 5.0, 'seed': 42}},\n        {'type': 'branching', 'params': {'b': 0.5, 'd': 0.5, 'I0': 20, 'T': 4.0, 'seed': 123}},\n        {'type': 'star', 'params': {'M': 100, 'beta': 0.05, 'T': 10.0, 'seed': 2021}},\n        {'type': 'star', 'params': {'M': 50, 'beta': 1.0, 'T': 0.0, 'seed': 7}},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'branching':\n            p = case['params']\n            I_T_sim, n_inf_sim, n_rec_sim = simulate_branching(p['b'], p['d'], p['I0'], p['T'], p['seed'])\n            I_T_exp, n_inf_exp, n_rec_exp = benchmark_branching(p['b'], p['d'], p['I0'], p['T'])\n            \n            delta_I = calculate_relative_error(I_T_sim, I_T_exp)\n            delta_inf = calculate_relative_error(n_inf_sim, n_inf_exp)\n            delta_rec = calculate_relative_error(n_rec_sim, n_rec_exp)\n            \n            max_delta = max(delta_I, delta_inf, delta_rec)\n            results.append(max_delta)\n\n        elif case['type'] == 'star':\n            p = case['params']\n            I_T_sim, n_inf_sim = simulate_star(p['M'], p['beta'], p['T'], p['seed'])\n            I_T_exp, n_inf_exp = benchmark_star(p['M'], p['beta'], p['T'])\n\n            delta_I = calculate_relative_error(I_T_sim, I_T_exp)\n            delta_inf = calculate_relative_error(n_inf_sim, n_inf_exp)\n\n            max_delta = max(delta_I, delta_inf)\n            results.append(max_delta)\n\n    # Format results to six decimal places\n    formatted_results = [f\"{r:.6f}\" for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}