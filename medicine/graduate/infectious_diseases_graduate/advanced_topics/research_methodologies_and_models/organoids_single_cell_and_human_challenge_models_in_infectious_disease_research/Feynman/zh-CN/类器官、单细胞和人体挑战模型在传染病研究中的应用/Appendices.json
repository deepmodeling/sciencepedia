{
    "hands_on_practices": [
        {
            "introduction": "病毒感染的第一个关键步骤是其附着于宿主细胞表面的特异性受体。这个练习将带你从化学动力学的第一性原理出发，推导描述受体占用率（即被病毒配体占据的受体比例）的基本方程。通过这个实践，你将学会如何利用这一模型来量化比较不同实验系统（如类器官与人体挑战模型）中病毒进入效率的差异，这对于转化研究至关重要 。",
            "id": "4676509",
            "problem": "一个人类气道类器官培养物被用于研究一种呼吸道病原体的顶端进入，该病原体能与细胞表面受体结合。单细胞定量分析表明，每个上皮细胞有 $N_{R}$ 个顶端受体。顶端膜上的配体-受体相互作用被建模为一个可逆结合反应 $L + R \\rightleftharpoons LR$，该反应遵循质量作用定律，其正向速率常数为 $k_{\\mathrm{on}}$，逆向速率常数为 $k_{\\mathrm{off}}$。解离常数定义为 $K_{d} = \\frac{k_{\\mathrm{off}}}{k_{\\mathrm{on}}}$。假设相对于下游的内化过程，结合能迅速达到平衡，使得系统在顶端表面的结合达到准稳态。每个细胞的进入通量由 $J = k_{\\mathrm{entry}} N_{R} \\theta$ 建模，其中 $k_{\\mathrm{entry}}$ 是每个被占据受体的进入速率常数，$\\theta$ 是被占据受体的分数。\n\n第1部分：从质量作用定律和 $K_{d}$ 的定义出发，推导稳态受体占有率 $\\theta$ 关于游离配体浓度 $[L]$ 和 $K_{d}$ 的表达式。\n\n第2部分：在类器官实验中，顶端游离配体浓度为 $[L]_{\\mathrm{org}} = 5~\\mathrm{nM}$，$K_{d,\\mathrm{org}} = 15~\\mathrm{nM}$，$N_{R} = 2.0 \\times 10^{5}$ 个受体/细胞，且 $k_{\\mathrm{entry}} = 2.0 \\times 10^{-5}~\\mathrm{s}^{-1}$。在鼻腔接种的人类挑战模型（HCM）中，黏膜蛋白酶的处理使亲和力增加了一个因子 $\\alpha = 0.40$（因此 $K_{d,\\mathrm{HCM}} = \\alpha K_{d,\\mathrm{org}}$），而诱饵结合使顶端游离配体浓度减少了一个因子 $\\beta = 0.60$（因此 $[L]_{\\mathrm{HCM}} = \\beta [L]_{\\mathrm{org}}$）。在相同的 $N_{R}$ 和 $k_{\\mathrm{entry}}$ 条件下，计算每个细胞进入通量的倍数变化 $F = \\frac{J_{\\mathrm{HCM}}}{J_{\\mathrm{org}}}$。\n\n将 $F$ 报告为一个无量纲数，四舍五入到四位有效数字。在最终报告的值中不要包含单位。",
            "solution": "该问题经评估有效。它在科学上基于化学动力学和受体药理学原理，问题陈述清晰，提供了足够的信息以获得唯一解，并且表述客观。我将提供完整解答。\n\n问题分为两部分。第一，推导稳态受体占有率分数 $\\theta$。第二，计算两种条件下病原体进入通量的倍数变化 $F$。\n\n第1部分：受体占有率 $\\theta$ 的推导\n\n配体-受体结合由可逆反应描述：\n$$L + R \\underset{k_{\\mathrm{off}}}{\\stackrel{k_{\\mathrm{on}}}{\\rightleftharpoons}} LR$$\n这里，$L$ 代表游离配体，$R$ 代表游离受体，$LR$ 代表配体-受体复合物。正向和逆向速率常数分别为 $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$。\n\n根据质量作用定律，复合物的形成速率与游离反应物浓度 $[L]$ 和 $[R]$ 成正比：\n$$\\text{Rate}_{\\mathrm{forward}} = k_{\\mathrm{on}} [L] [R]$$\n复合物的解离速率与复合物浓度 $[LR]$ 成正比：\n$$\\text{Rate}_{\\mathrm{reverse}} = k_{\\mathrm{off}} [LR]$$\n问题指出结合能迅速达到平衡，这意味着系统达到准稳态，此时形成速率等于解离速率：\n$$k_{\\mathrm{on}} [L] [R] = k_{\\mathrm{off}} [LR]$$\n重排该方程，我们可以将速率常数组合在一起：\n$$\\frac{[L] [R]}{[LR]} = \\frac{k_{\\mathrm{off}}}{k_{\\mathrm{on}}}$$\n问题将解离常数 $K_{d}$ 定义为 $K_{d} = \\frac{k_{\\mathrm{off}}}{k_{\\mathrm{on}}}$。代入此定义得到平衡关系：\n$$K_{d} = \\frac{[L] [R]}{[LR]}$$\n受体占有率 $\\theta$ 定义为被配体占据的总受体的分数。设 $[R]_{\\mathrm{total}}$ 为总受体浓度。总浓度是游离受体 $[R]$ 和被占据受体 $[LR]$ 的总和：\n$$[R]_{\\mathrm{total}} = [R] + [LR]$$\n因此，占有率分数为：\n$$\\theta = \\frac{[LR]}{[R]_{\\mathrm{total}}} = \\frac{[LR]}{[R] + [LR]}$$\n为了用 $[L]$ 和 $K_{d}$ 表示 $\\theta$，我们首先重排平衡方程来解出 $[R]$：\n$$[R] = K_{d} \\frac{[LR]}{[L]}$$\n现在，我们将这个 $[R]$ 的表达式代入 $\\theta$ 方程的分母中：\n$$\\theta = \\frac{[LR]}{\\left(K_{d} \\frac{[LR]}{[L]}\\right) + [LR]}$$\n项 $[LR]$ 在分子和分母的所有项中都是公因式，可以消去：\n$$\\theta = \\frac{1}{\\frac{K_{d}}{[L]} + 1}$$\n分子和分母同乘以 $[L]$ 得到最终表达式，这通常被称为非协同结合的希尔-朗缪尔方程：\n$$\\theta = \\frac{[L]}{K_{d} + [L]}$$\n这完成了第1部分的推导。\n\n第2部分：进入通量倍数变化的计算\n\n每个细胞的进入通量 $J$ 由模型 $J = k_{\\mathrm{entry}} N_{R} \\theta$ 给出。我们需要计算倍数变化 $F = \\frac{J_{\\mathrm{HCM}}}{J_{\\mathrm{org}}}$，其中下标 `org` 和 `HCM` 分别代表类器官和人类挑战模型条件。\n\n类器官模型的通量为：\n$$J_{\\mathrm{org}} = k_{\\mathrm{entry}} N_{R} \\theta_{\\mathrm{org}}$$\n人类挑战模型的通量为：\n$$J_{\\mathrm{HCM}} = k_{\\mathrm{entry}} N_{R} \\theta_{\\mathrm{HCM}}$$\n问题指出 $k_{\\mathrm{entry}}$ 和 $N_{R}$ 在两种条件下是相同的。因此，倍数变化 $F$ 简化为占有率的比值：\n$$F = \\frac{J_{\\mathrm{HCM}}}{J_{\\mathrm{org}}} = \\frac{k_{\\mathrm{entry}} N_{R} \\theta_{\\mathrm{HCM}}}{k_{\\mathrm{entry}} N_{R} \\theta_{\\mathrm{org}}} = \\frac{\\theta_{\\mathrm{HCM}}}{\\theta_{\\mathrm{org}}}$$\n使用第1部分的结果，我们可以写出 $\\theta_{\\mathrm{org}}$ 和 $\\theta_{\\mathrm{HCM}}$ 的表达式：\n$$\\theta_{\\mathrm{org}} = \\frac{[L]_{\\mathrm{org}}}{K_{d,\\mathrm{org}} + [L]_{\\mathrm{org}}}$$\n$$\\theta_{\\mathrm{HCM}} = \\frac{[L]_{\\mathrm{HCM}}}{K_{d,\\mathrm{HCM}} + [L]_{\\mathrm{HCM}}}$$\n问题提供了两个模型中参数之间的关系：\n$$[L]_{\\mathrm{HCM}} = \\beta [L]_{\\mathrm{org}}$$\n$$K_{d,\\mathrm{HCM}} = \\alpha K_{d,\\mathrm{org}}$$\n其中 $\\alpha = 0.40$ 且 $\\beta = 0.60$。\n将这些代入 $\\theta_{\\mathrm{HCM}}$ 的表达式中：\n$$\\theta_{\\mathrm{HCM}} = \\frac{\\beta [L]_{\\mathrm{org}}}{\\alpha K_{d,\\mathrm{org}} + \\beta [L]_{\\mathrm{org}}}$$\n现在我们可以写出 $F$ 的完整表达式：\n$$F = \\frac{\\theta_{\\mathrm{HCM}}}{\\theta_{\\mathrm{org}}} = \\frac{\\frac{\\beta [L]_{\\mathrm{org}}}{\\alpha K_{d,\\mathrm{org}} + \\beta [L]_{\\mathrm{org}}}}{\\frac{[L]_{\\mathrm{org}}}{K_{d,\\mathrm{org}} + [L]_{\\mathrm{org}}}}$$\n我们可以简化这个繁分数：\n$$F = \\frac{\\beta [L]_{\\mathrm{org}}}{\\alpha K_{d,\\mathrm{org}} + \\beta [L]_{\\mathrm{org}}} \\times \\frac{K_{d,\\mathrm{org}} + [L]_{\\mathrm{org}}}{[L]_{\\mathrm{org}}}$$\n项 $[L]_{\\mathrm{org}}$ 消去，得到倍数变化的一般表达式：\n$$F = \\beta \\left( \\frac{K_{d,\\mathrm{org}} + [L]_{\\mathrm{org}}}{\\alpha K_{d,\\mathrm{org}} + \\beta [L]_{\\mathrm{org}}} \\right)$$\n现在我们代入给定的数值：$[L]_{\\mathrm{org}} = 5~\\mathrm{nM}$，$K_{d,\\mathrm{org}} = 15~\\mathrm{nM}$，$\\alpha = 0.40$ 和 $\\beta = 0.60$。注意浓度单位（nM）是一致的，将会抵消，所以我们可以直接使用数值进行计算。\n$$F = 0.60 \\left( \\frac{15 + 5}{(0.40)(15) + (0.60)(5)} \\right)$$\n$$F = 0.60 \\left( \\frac{20}{6 + 3} \\right)$$\n$$F = 0.60 \\left( \\frac{20}{9} \\right)$$\n$$F = \\frac{12}{9} = \\frac{4}{3}$$\n数值为 $F = 1.3333...$。问题要求答案四舍五入到四位有效数字。\n$$F \\approx 1.333$$\n这是进入通量的无量纲倍数变化。",
            "answer": "$$\\boxed{1.333}$$"
        },
        {
            "introduction": "在评估抗病毒疗法时，一个核心任务是量化感染过程中的病毒载量动态。本练习模拟了一个典型的人体挑战研究场景，你需要处理从每日样本中获得的定量PCR（qPCR）数据。你将学习如何利用标准曲线将原始的循环阈值（$C_t$）数据转换为病毒载量（$N$），并应用数值积分方法（梯形法则）来计算病毒排出曲线下的面积（AUC），这是一个衡量总病毒负担和药物效力的关键指标 。",
            "id": "4676472",
            "problem": "一项抗病毒药物的随机人体挑战研究通过定量聚合酶链式反应（qPCR）测量上呼吸道的病毒脱落。在 qPCR 中，循环阈值 $C_{t}$ 与初始模板数量的对数（以 10 为底）成反比，对于一个已建立的检测方法，该关系可以用标准曲线表示。假设以下在类器官衍生的病毒校准品上验证的检测标准曲线，在临床拭子的动态范围内成立：\n$$C_{t}=\\alpha-\\beta \\log_{10}\\left(N\\right),$$ \n其中 $N$ 是病毒载量（单位：拷贝数/毫升），$\\alpha=40.0$，$\\beta=3.3$。任何严格大于 38 的 $C_{t}$ 值都被视为未检测到，并设 $N=0$。\n\n参与者从第 0 天（接种）到第 10 天（含）每天采样一次。安慰剂组（对照组）随时间变化的平均 $C_{t}$ 值为：第 0 天：$40$，第 1 天：$34$，第 2 天：$28$，第 3 天：$22$，第 4 天：$20$，第 5 天：$24$，第 6 天：$30$，第 7 天：$34$，第 8 天：$37$，第 9 天：$40$，第 10 天：$40$。抗病毒药物组（治疗组）的平均 $C_{t}$ 值为：第 0 天：$40$，第 1 天：$36$，第 2 天：$32$，第 3 天：$26$，第 4 天：$24$，第 5 天：$28$，第 6 天：$34$，第 7 天：$38$，第 8 天：$40$，第 9 天：$40$，第 10 天：$40$。\n\n仅使用证明标准曲线和定积分定义的第一性原理，将每个 $C_{t}$ 值转换为 $N$ 值，并通过对每日测量值应用梯形法则来近似计算每个组从第 0 天到第 10 天的病毒载量曲线下面积（AUC）。然后，计算两组之间的 AUC 差异（对照组减去治疗组）。将最终差异以“拷贝数-天/毫升”为单位表示，并将您的答案四舍五入到三位有效数字。最终答案必须是单个实数。",
            "solution": "问题陈述已经过严格评估，被认为是有效的。它在科学上基于定量聚合酶链式反应（qPCR）和病毒动力学的原理，问题设定良好，数据充分且一致，并以客观、正式的语言表达。该问题与传染病研究中的定量分析直接相关。因此，我们可以继续进行解答。\n\n该问题要求计算一项人体挑战研究中，对照组和治疗组之间病毒载量曲线下面积（AUC）的差异。步骤如下：首先，将给定的循环阈值（$C_t$）值转换为每个组的病毒载量（$N$，单位：拷贝数/mL）；其次，使用梯形法则近似计算每个组的 AUC；第三，计算这些 AUC 之间的差异。\n\n首先，我们必须建立将 $C_t$ 转换为 $N$ 的关系。问题提供了标准曲线方程：\n$$C_{t}=\\alpha-\\beta \\log_{10}(N)$$\n参数为 $\\alpha=40.0$ 和 $\\beta=3.3$。为了求出 $N$ 作为 $C_t$ 的函数，我们重新整理这个方程：\n$$ \\log_{10}(N) = \\frac{\\alpha - C_t}{\\beta} $$\n$$ N(C_t) = 10^{\\frac{\\alpha - C_t}{\\beta}} $$\n代入 $\\alpha$ 和 $\\beta$ 的给定值：\n$$ N(C_t) = 10^{\\frac{40.0 - C_t}{3.3}} $$\n一个关键条件是，任何严格大于 38 的 $C_t$ 值都被视为未检测到，相应的病毒载量 $N$ 被设为 0。这个条件覆盖了 $C_t > 38$ 时的公式。这就为 $N$ 建立了一个分段函数：\n$$ N(C_t) = \\begin{cases} 10^{\\frac{40.0 - C_t}{3.3}}  \\text{若 } C_t \\le 38 \\\\ 0  \\text{若 } C_t > 38 \\end{cases} $$\n\n接下来，我们计算对照组在第 0 天到第 10 天的每个时间点 $t$ 的每日病毒载量 $N_c(t)$。对照组给定的 $C_t$ 值为 $[40, 34, 28, 22, 20, 24, 30, 34, 37, 40, 40]$。\n- $t=0, C_t=40 > 38 \\implies N_c(0) = 0$\n- $t=1, C_t=34 \\le 38 \\implies N_c(1) = 10^{\\frac{40-34}{3.3}} = 10^{\\frac{6}{3.3}}$\n- $t=2, C_t=28 \\le 38 \\implies N_c(2) = 10^{\\frac{40-28}{3.3}} = 10^{\\frac{12}{3.3}}$\n- $t=3, C_t=22 \\le 38 \\implies N_c(3) = 10^{\\frac{40-22}{3.3}} = 10^{\\frac{18}{3.3}}$\n- $t=4, C_t=20 \\le 38 \\implies N_c(4) = 10^{\\frac{40-20}{3.3}} = 10^{\\frac{20}{3.3}}$\n- $t=5, C_t=24 \\le 38 \\implies N_c(5) = 10^{\\frac{40-24}{3.3}} = 10^{\\frac{16}{3.3}}$\n- $t=6, C_t=30 \\le 38 \\implies N_c(6) = 10^{\\frac{40-30}{3.3}} = 10^{\\frac{10}{3.3}}$\n- $t=7, C_t=34 \\le 38 \\implies N_c(7) = 10^{\\frac{40-34}{3.3}} = 10^{\\frac{6}{3.3}}$\n- $t=8, C_t=37 \\le 38 \\implies N_c(8) = 10^{\\frac{40-37}{3.3}} = 10^{\\frac{3}{3.3}}$\n- $t=9, C_t=40 > 38 \\implies N_c(9) = 0$\n- $t=10, C_t=40 > 38 \\implies N_c(10) = 0$\n\n我们使用梯形法则，根据从 $t_0=0$ 到 $t_{10}=10$ 的每日测量值，来近似计算病毒载量曲线下面积 $AUC_c = \\int_0^{10} N_c(t) dt$。时间步长为常数 $\\Delta t = 1$ 天。梯形法则的公式是：\n$$ AUC = \\Delta t \\left( \\frac{N(t_0) + N(t_{10})}{2} + \\sum_{i=1}^{9} N(t_i) \\right) $$\n对于对照组，$\\Delta t=1$，$N_c(0)=0$，$N_c(10)=0$：\n$$ AUC_c = 1 \\cdot \\left( \\frac{0 + 0}{2} + \\sum_{i=1}^{9} N_c(i) \\right) = \\sum_{i=1}^{9} N_c(i) $$\n$$ AUC_c = N_c(1)+N_c(2)+N_c(3)+N_c(4)+N_c(5)+N_c(6)+N_c(7)+N_c(8)+N_c(9) $$\n$$ AUC_c = 10^{\\frac{6}{3.3}} + 10^{\\frac{12}{3.3}} + 10^{\\frac{18}{3.3}} + 10^{\\frac{20}{3.3}} + 10^{\\frac{16}{3.3}} + 10^{\\frac{10}{3.3}} + 10^{\\frac{6}{3.3}} + 10^{\\frac{3}{3.3}} + 0 $$\n数值上，这等于：\n$AUC_c \\approx 65.793 + 4328.741 + 284803.589 + 1149799.305 + 70543.604 + 1072.304 + 65.793 + 8.113 \\approx 1510687.24$ 拷贝数-天/mL。\n\n接下来，我们对治疗组重复此过程。给定的 $C_t$ 值为 $[40, 36, 32, 26, 24, 28, 34, 38, 40, 40, 40]$。每日病毒载量 $N_t(t)$ 为：\n- $t=0, C_t=40 > 38 \\implies N_t(0) = 0$\n- $t=1, C_t=36 \\le 38 \\implies N_t(1) = 10^{\\frac{40-36}{3.3}} = 10^{\\frac{4}{3.3}}$\n- $t=2, C_t=32 \\le 38 \\implies N_t(2) = 10^{\\frac{40-32}{3.3}} = 10^{\\frac{8}{3.3}}$\n- $t=3, C_t=26 \\le 38 \\implies N_t(3) = 10^{\\frac{40-26}{3.3}} = 10^{\\frac{14}{3.3}}$\n- $t=4, C_t=24 \\le 38 \\implies N_t(4) = 10^{\\frac{40-24}{3.3}} = 10^{\\frac{16}{3.3}}$\n- $t=5, C_t=28 \\le 38 \\implies N_t(5) = 10^{\\frac{40-28}{3.3}} = 10^{\\frac{12}{3.3}}$\n- $t=6, C_t=34 \\le 38 \\implies N_t(6) = 10^{\\frac{40-34}{3.3}} = 10^{\\frac{6}{3.3}}$\n- $t=7, C_t=38 \\le 38 \\implies N_t(7) = 10^{\\frac{40-38}{3.3}} = 10^{\\frac{2}{3.3}}$\n- $t=8, C_t=40 > 38 \\implies N_t(8) = 0$\n- $t=9, C_t=40 > 38 \\implies N_t(9) = 0$\n- $t=10, C_t=40 > 38 \\implies N_t(10) = 0$\n\n我们对治疗组应用梯形法则，计算 $AUC_t$。这里，$\\Delta t=1$，$N_t(0)=0$，$N_t(10)=0$：\n$$ AUC_t = 1 \\cdot \\left( \\frac{0 + 0}{2} + \\sum_{i=1}^{9} N_t(i) \\right) = \\sum_{i=1}^{9} N_t(i) $$\n$$ AUC_t = N_t(1)+N_t(2)+N_t(3)+N_t(4)+N_t(5)+N_t(6)+N_t(7)+N_t(8)+N_t(9) $$\n$$ AUC_t = 10^{\\frac{4}{3.3}} + 10^{\\frac{8}{3.3}} + 10^{\\frac{14}{3.3}} + 10^{\\frac{16}{3.3}} + 10^{\\frac{12}{3.3}} + 10^{\\frac{6}{3.3}} + 10^{\\frac{2}{3.3}} + 0 + 0 $$\n数值上，这等于：\n$AUC_t \\approx 16.295 + 265.772 + 17475.228 + 70543.604 + 4328.741 + 65.793 + 4.037 \\approx 92699.470$ 拷贝数-天/mL。\n\n最后，我们计算对照组和治疗组之间的 AUC 差异，$\\Delta AUC = AUC_c - AUC_t$。\n$$ \\Delta AUC \\approx 1510687.24 - 92699.470 = 1417987.77 \\text{ 拷贝数-天/mL} $$\n问题要求将此结果四舍五入到三位有效数字。前三位有效数字是 $1$、$4$ 和 $1$。第四位数字是 $7$，大于或等于 $5$，所以我们将第三位数字向上取整。\n$$ \\Delta AUC \\approx 1420000 $$\n这可以用科学记数法表示为 $1.42 \\times 10^6$。",
            "answer": "$$\\boxed{1.42 \\times 10^6}$$"
        },
        {
            "introduction": "单细胞测序为理解细胞异质性提供了前所未有的分辨率，但它本质上是静态的快照。本练习将引导你应用RNA速度（RNA velocity）这一前沿概念，通过比较新生（未剪接）和成熟（已剪接）的转录本，为每个细胞的基因表达状态赋予一个“方向”。你将亲手构建一个马尔可夫链模型，通过它学习如何量化细胞在状态空间中的转换概率，例如，从一个健康的旁观者细胞转变为一个被病毒感染的细胞 。这个练习让你能够深入理解如何从单细胞数据中挖掘动态信息，重构感染过程中的细胞命运轨迹。",
            "id": "4676480",
            "problem": "考虑一组源自类器官或人体攻击研究数据的单细胞状态，这些状态在一个低维基因表达空间中表示，其中每个细胞都有一个位置和相应的 RNA 速度。RNA 速度是一种经过充分验证的单细胞方法，它通过比较剪接和未剪接的转录本，来估计信使核糖核酸 (mRNA) 丰度的时间导数，从而在基因表达流形上生成一个向量场。纯粹从数学角度来说，假设有 $n$ 个细胞，索引为 $i \\in \\{0,1,\\dots,n-1\\}$。每个细胞都有一个状态向量 $x_i \\in \\mathbb{R}^G$ 和一个 RNA 速度向量 $v_i \\in \\mathbb{R}^G$。通过欧几里得距离 $d_{ij} = \\lVert x_j - x_i \\rVert_2$ 定义 $k$-最近邻 (kNN) 图，其中有向邻居集合 $N_k(i)$ 包含距离细胞 $i$ 最近的 $k$ 个细胞的索引（不包括 $i$ 本身）。\n\n为了推断从旁观细胞状态到感染细胞状态的有向流，我们在 kNN 图上构建一个马尔可夫链，其转移概率倾向于与 RNA 速度对齐的移动，并惩罚远距离的步骤。对于每个有向边 $(i \\to j)$，其中 $j \\in N_k(i)$：\n- 定义对齐度\n$$\na_{ij} = \n\\begin{cases}\n\\dfrac{v_i \\cdot (x_j - x_i)}{\\lVert v_i \\rVert_2 \\, \\lVert x_j - x_i \\rVert_2},  \\text{if } \\lVert v_i \\rVert_2 > 0, \\\\\n0,  \\text{if } \\lVert v_i \\rVert_2 = 0,\n\\end{cases}\n$$\n这是 RNA 速度与邻居位移之间夹角的余弦值，一个在 $[-1,1]$ 范围内的无量纲量。\n- 定义未归一化的边权重\n$$\nw_{ij} = \\exp(\\lambda \\, a_{ij}) \\, \\exp(-\\mu \\, d_{ij}),\n$$\n其中参数 $\\lambda > 0$ 和 $\\mu \\ge 0$，且当 $j \\notin N_k(i)$ 时，$w_{ij} = 0$。\n\n对行进行归一化，得到一个行随机转移矩阵 $P \\in \\mathbb{R}^{n \\times n}$，其元素为\n$$\nP_{ij} = \\frac{w_{ij}}{\\sum\\limits_{l \\in N_k(i)} w_{il}},\n$$\n且当 $j \\notin N_k(i)$ 时，$P_{ij} = 0$。\n\n令 $B \\subset \\{0,\\dots,n-1\\}$ 为旁观细胞索引集合，$I \\subset \\{0,\\dots,n-1\\}$ 为感染细胞索引集合。定义初始分布 $\\pi_0 \\in \\mathbb{R}^n$，通过设置 $\\pi_0(i) = \\frac{1}{|B|}$ (当 $i \\in B$) 和 $\\pi_0(i) = 0$ (其他情况)。从旁观细胞到感染细胞的单步有向流为\n$$\nF = \\sum_{i \\in B} \\pi_0(i) \\sum_{j \\in I} P_{ij} = \\frac{1}{|B|} \\sum_{i \\in B} \\sum_{j \\in I} P_{ij}.\n$$\n对于一个正整数 $T$，其 $T$ 步分布为 $\\pi_T = \\pi_0 P^T$，其 $T$ 步感染概率为\n$$\np_T = \\sum_{j \\in I} [\\pi_T]_j.\n$$\n\n你的任务是实现一个程序，对每个测试用例，使用上述方程构建 $P$，计算 $F$ 和 $p_T$，并输出结果。角度通过基于点积的余弦值隐式处理；不需要明确的角度单位。不涉及物理单位。\n\n测试套件：\n- 案例 1 (理想情况，速度朝向感染细胞对齐):\n  - $n = 6$, $G = 2$, \n  - $X = \\begin{bmatrix}\n  0.0  0.0 \\\\\n  1.0  0.2 \\\\\n  0.5  -0.2 \\\\\n  5.0  0.0 \\\\\n  5.5  0.5 \\\\\n  6.0  -0.3\n  \\end{bmatrix}$,\n  - $V = \\begin{bmatrix}\n  1.0  0.0 \\\\\n  1.0  0.0 \\\\\n  1.0  0.1 \\\\\n  0.2  0.0 \\\\\n  -0.1  -0.1 \\\\\n  -0.2  0.0\n  \\end{bmatrix}$,\n  - $k = 3$, $\\lambda = 5.0$, $\\mu = 0.1$, $B = [0,1,2]$, $I = [3,4,5]$, $T = 4$。\n- 案例 2 (边界条件，零速度):\n  - $n = 6$, $G = 2$, \n  - $X$ 与案例 1 相同，\n  - $V = \\begin{bmatrix}\n  0.0  0.0 \\\\\n  0.0  0.0 \\\\\n  0.0  0.0 \\\\\n  0.0  0.0 \\\\\n  0.0  0.0 \\\\\n  0.0  0.0\n  \\end{bmatrix}$,\n  - $k = 3$, $\\lambda = 5.0$, $\\mu = 0.1$, $B = [0,1,2]$, $I = [3,4,5]$, $T = 4$。\n- 案例 3 (边缘情况，速度偏离感染细胞):\n  - $n = 6$, $G = 2$, \n  - $X$ 与案例 1 相同，\n  - $V = \\begin{bmatrix}\n  -1.0  0.0 \\\\\n  -1.0  -0.1 \\\\\n  -1.0  0.0 \\\\\n  0.0  0.0 \\\\\n  -0.2  0.2 \\\\\n  -0.1  0.0\n  \\end{bmatrix}$,\n  - $k = 3$, $\\lambda = 7.0$, $\\mu = 0.1$, $B = [0,1,2]$, $I = [3,4,5]$, $T = 4$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素都是一个形式为 $[F, p_T]$ 的双元素列表，对应于相应的测试用例。例如，输出应类似于 $[[F_1,p_{T,1}],[F_2,p_{T,2}],[F_3,p_{T,3}]]$. 每个 $F$ 和 $p_T$ 都必须是浮点数。",
            "solution": "问题陈述在科学上是合理的，在数学上是适定的，并为获得唯一解提供了所有必要的信息。该公式是计算生物学中一个有效且公认的方法，用于基于单细胞 RNA 测序数据对细胞状态转换进行建模。它将 k-最近邻 (kNN) 图的构建与 RNA 速度信息相结合来定义一个马尔可夫链，这是轨迹推断的标准技术。测试用例的所有参数和数据都已提供且一致。\n\n解决方案通过实现所述的数学模型分三个主要阶段进行：构建 k-最近邻图，计算马尔可夫转移矩阵 $P$，以及计算指定的流和概率指标 $F$ 和 $p_T$。\n\n### 1. k-最近邻 (kNN) 图的构建\n\n该模型的基础是一个有向图，其中节点代表细胞，边连接每个细胞与其在基因表达空间中最近的邻居。其结构按以下方式确定：\n\n首先，我们为 $n$ 个细胞计算成对的欧几里得距离矩阵 $D \\in \\mathbb{R}^{n \\times n}$，其中每个条目 $D_{ij}$ 是基于它们的状态向量 $x_i, x_j \\in \\mathbb{R}^G$ 计算出的细胞 $i$ 和细胞 $j$ 之间的距离：\n$$\nD_{ij} = d_{ij} = \\lVert x_j - x_i \\rVert_2 = \\sqrt{\\sum_{g=1}^{G} (x_{j,g} - x_{i,g})^2}.\n$$\n对于每个细胞 $i$，我们通过对 $D$ 的第 $i$ 行中的距离进行排序来确定其 $k$ 个最近邻。由于问题规定一个细胞不能是自身的邻居，我们排除细胞 $i$ 本身（其距离为 $0$），并选择具有最小非零距离的 $k$ 个细胞。这就为每个细胞 $i \\in \\{0, 1, \\dots, n-1\\}$ 定义了有向邻居集合 $N_k(i)$。\n\n### 2. 转移矩阵 $P$ 的构建\n\n马尔可夫链的转移矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 是基于分配给 kNN 图的边的权重构建的。对于一个有向边 $(i \\to j)$，其中 $j \\in N_k(i)$，其权重被设计为倾向于那些距离短且与细胞的 RNA 速度向量 $v_i$ 对齐的转移。\n\n对于每个边 $(i \\to j)$，其中 $j \\in N_k(i)$，我们首先计算对齐度 $a_{ij}$，即速度向量 $v_i$ 和位移向量 $(x_j - x_i)$ 之间夹角的余弦值：\n$$\na_{ij} = \\frac{v_i \\cdot (x_j - x_i)}{\\lVert v_i \\rVert_2 \\, \\lVert x_j - x_i \\rVert_2}.\n$$\n当一个细胞的速度向量是零向量时（$\\lVert v_i \\rVert_2 = 0$），会出现一种特殊情况；根据定义，此时对齐度设置为 $a_{ij} = 0$。\n\n接下来，使用对齐度 $a_{ij}$ 和距离 $d_{ij}$ 计算未归一化的权重 $w_{ij}$：\n$$\nw_{ij} = \\exp(\\lambda \\, a_{ij}) \\, \\exp(-\\mu \\, d_{ij}).\n$$\n在这里，$\\lambda > 0$ 是一个控制速度对齐影响的参数，而 $\\mu \\ge 0$ 控制对距离的惩罚。对于任何 $j$ 不是 $i$ 的邻居的配对 $(i, j)$ (即 $j \\notin N_k(i)$)，权重为 $w_{ij} = 0$。\n\n最后，通过对每一行 $i$ 的权重进行归一化来获得转移概率 $P_{ij}$，使得从细胞 $i$ 转移到其所有邻居的概率之和为 1：\n$$\nP_{ij} = \\frac{w_{ij}}{\\sum\\limits_{l \\in N_k(i)} w_{il}}.\n$$\n如果 $j \\notin N_k(i)$，则 $P_{ij} = 0$。最终得到的矩阵 $P$ 是一个行随机矩阵。\n\n### 3. 流 $F$ 和概率 $p_T$ 的计算\n\n在建立转移矩阵 $P$ 后，我们可以计算感兴趣的量。\n\n从旁观细胞集合 $B$ 到感染细胞集合 $I$ 的单步有向流 $F$ 是指一个起始于旁观细胞集合的细胞在单一步骤内转移到感染细胞集合的平均概率。初始分布 $\\pi_0$ 假设在旁观细胞上是均匀概率，即对于 $i \\in B$，$\\pi_0(i) = 1/|B|$，否则为 0。流由以下公式给出：\n$$\nF = \\sum_{i \\in B} \\pi_0(i) \\sum_{j \\in I} P_{ij} = \\frac{1}{|B|} \\sum_{i \\in B} \\sum_{j \\in I} P_{ij}.\n$$\n在计算上，这是由集合 $B$ 的行和集合 $I$ 的列定义的 $P$ 的子矩阵中所有元素的总和，再除以旁观细胞的数量 $|B|$。\n\n$T$ 步感染概率 $p_T$ 是一个从旁观状态分布 $\\pi_0$ 开始的进程，在 $T$ 步后最终处于任何一个感染状态的总概率。$T$ 步后的分布 $\\pi_T$ 是通过将转移矩阵应用于初始分布 $T$ 次得到的：\n$$\n\\pi_T = \\pi_0 P^T.\n$$\n这里，$P^T$ 是 $P$ 的 $T$ 次矩阵幂。概率 $p_T$ 则是 $\\pi_T$ 中对应于感染细胞索引的概率之和：\n$$\np_T = \\sum_{j \\in I} [\\pi_T]_j.\n$$\n该实现将为每个提供的测试用例计算这些值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef calculate_F_and_pT(X, V, k, lambda_p, mu_p, B, I, T):\n    \"\"\"\n    Constructs the transition matrix P and computes F and p_T.\n    \"\"\"\n    n, G = X.shape\n\n    # 1. kNN graph construction\n    # Compute pairwise Euclidean distances\n    dist_matrix = cdist(X, X, 'euclidean')\n\n    # Get neighbor indices for each cell by sorting distances.\n    # The first element [:, 0] is the cell itself, so we skip it.\n    neighbor_indices = np.argsort(dist_matrix, axis=1)[:, 1:k+1]\n\n    # 2. Transition Matrix P construction\n    P = np.zeros((n, n))\n\n    for i in range(n):\n        neighbors = neighbor_indices[i]\n        \n        # We will store unnormalized weights and sum them up for normalization\n        unnormalized_weights = {}\n        row_weight_sum = 0.0\n\n        v_i = V[i]\n        v_i_norm = np.linalg.norm(v_i)\n\n        for j in neighbors:\n            x_j_minus_x_i = X[j] - X[i]\n            d_ij = dist_matrix[i, j]\n\n            a_ij = 0.0\n            # Check norms to avoid division by zero\n            # v_i_norm is pre-calculated. d_ij > 0 since i != j and points are distinct.\n            if v_i_norm > 1e-12:\n                dot_product = np.dot(v_i, x_j_minus_x_i)\n                a_ij = dot_product / (v_i_norm * d_ij)\n\n            w_ij = np.exp(lambda_p * a_ij) * np.exp(-mu_p * d_ij)\n            \n            unnormalized_weights[j] = w_ij\n            row_weight_sum += w_ij\n        \n        # Normalize weights for the current row to get probabilities\n        if row_weight_sum > 1e-12:\n            for j, w_ij in unnormalized_weights.items():\n                P[i, j] = w_ij / row_weight_sum\n\n    # 3. Calculate F (One-step directional flow)\n    F = 0.0\n    if len(B) > 0:\n        # Select submatrix corresponding to transitions from B to I\n        sub_matrix_P_BI = P[np.ix_(B, I)]\n        F = np.sum(sub_matrix_P_BI) / len(B)\n\n    # 4. Calculate p_T (T-step infection probability)\n    pi_0 = np.zeros(n)\n    if len(B) > 0:\n        pi_0[B] = 1.0 / len(B)\n    \n    # Calculate P^T using matrix exponentiation\n    P_pow_T = np.linalg.matrix_power(P, T)\n\n    # Calculate T-step distribution: pi_T = pi_0 @ P^T\n    pi_T = pi_0 @ P_pow_T\n\n    # Sum probabilities for infected states\n    p_T = np.sum(pi_T[I])\n\n    return [F, p_T]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the common X matrix for all test cases\n    X = np.array([\n        [0.0, 0.0],\n        [1.0, 0.2],\n        [0.5, -0.2],\n        [5.0, 0.0],\n        [5.5, 0.5],\n        [6.0, -0.3]\n    ])\n\n    test_cases = [\n        # Case 1 (happy path, velocities aligned toward infected)\n        {\n            \"X\": X,\n            \"V\": np.array([\n                [1.0, 0.0], [1.0, 0.0], [1.0, 0.1],\n                [0.2, 0.0], [-0.1, -0.1], [-0.2, 0.0]\n            ]),\n            \"k\": 3, \"lambda_p\": 5.0, \"mu_p\": 0.1,\n            \"B\": [0, 1, 2], \"I\": [3, 4, 5], \"T\": 4\n        },\n        # Case 2 (boundary condition, zero velocities)\n        {\n            \"X\": X,\n            \"V\": np.array([\n                [0.0, 0.0], [0.0, 0.0], [0.0, 0.0],\n                [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]\n            ]),\n            \"k\": 3, \"lambda_p\": 5.0, \"mu_p\": 0.1,\n            \"B\": [0, 1, 2], \"I\": [3, 4, 5], \"T\": 4\n        },\n        # Case 3 (edge case, velocities misaligned away from infected)\n        {\n            \"X\": X,\n            \"V\": np.array([\n                [-1.0, 0.0], [-1.0, -0.1], [-1.0, 0.0],\n                [0.0, 0.0], [-0.2, 0.2], [-0.1, 0.0]\n            ]),\n            \"k\": 3, \"lambda_p\": 7.0, \"mu_p\": 0.1,\n            \"B\": [0, 1, 2], \"I\": [3, 4, 5], \"T\": 4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_F_and_pT(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Example: [[F1,pT1],[F2,pT2],[F3,pT3]]\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}