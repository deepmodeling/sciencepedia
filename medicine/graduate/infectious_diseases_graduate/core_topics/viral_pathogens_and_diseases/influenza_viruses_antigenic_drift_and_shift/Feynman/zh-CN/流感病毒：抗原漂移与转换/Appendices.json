{
    "hands_on_practices": [
        {
            "introduction": "抗原漂移过程是由帮助病毒逃避宿主免疫系统的突变所驱动的。研究此现象的关键第一步是量化这种“逃逸”突变所赋予的适应性优势，即选择系数（$s$）。这项练习  提供了一个动手实践的机会，让你学习如何使用一个标准的对数映射，将实验测量值——中和滴度的降低倍数——与这个基本进化参数联系起来。",
            "id": "4657332",
            "problem": "一个正在经历抗原漂移的甲型流感病毒谱系，其血凝素发生单氨基酸取代，导致在标准微量中和试验中针对参考抗血清测得的同源中和滴度降低了$k$倍。在此类试验中，抗原距离通常以2为底的标度表示，其中2倍的变化对应一个抗原单位。考虑一个简单的选择映射，其中抗原逃逸突变的选择优势与滴度倍数变化所隐含的抗原距离成正比。具体来说，假设该映射经过校准，使得以选择系数为单位时，比例常数为1。\n\n使用以下核心定义：(i) 抗原距离 $d$ 是中和滴度倍数变化的以2为底的对数；(ii) 选择系数 $s$ 量化了每一代的相对适应性优势。请在此简单映射下，推导逃逸突变的选择系数 $s$ 作为 $k$ 的函数表达式。\n\n请用一个关于 $k$ 的闭式解析表达式来表示你的最终答案。由于 $s$ 是无量纲的，报告答案时无需带单位。无需进行数值取整。",
            "solution": "首先将根据既定程序对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 一个甲型流感病毒谱系，其血凝素发生单氨基酸取代。\n- 该取代使同源中和滴度降低了 $k$ 倍。\n- 抗原距离以2为底的标度表示。\n- 滴度的2倍变化对应一个抗原单位。\n- 抗原逃逸突变的选择优势与抗原距离成正比。\n- 比例常数为1。\n- 定义 (i)：抗原距离 $d$ 是中和滴度倍数变化的以2为底的对数。\n- 定义 (ii)：选择系数 $s$ 量化了每一代的相对适应性优势。\n- 目标是推导选择系数 $s$ 作为滴度降低因子 $k$ 的函数表达式。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据充分：** 该问题牢固地植根于病毒学和进化生物学的原理，特别是关于流感病毒的抗原进化。中和滴度、抗原距离和选择系数等概念是该领域的标准。使用对数标度（特别是以2为底）从滴度数据量化抗原距离是一种公认的惯例，在抗原图谱绘制中尤其常用。\n- **提法明确：** 问题提供了一套清晰的定义和关系，可以唯一地确定待求的量。信息是充分且自洽的。\n- **客观性：** 语言是形式化和定量的，没有主观或模糊的术语。\n- **完整且一致：** 所提供的定义和条件不相矛盾，并且足以推导出所需的表达式。\n- **现实性：** 虽然比例常数为1的假设是一种简化，但这是构建基本理论模型以建立变量之间基本关系的标准方法。\n- **结论：** 该问题被认为是有效的，因为它科学上合理、提法明确、客观，并包含了进行严谨推导所需的所有必要信息。\n\n### 步骤3：表达式推导\n求解过程通过将给定的定义转化为数学方程，并组合它们来找出选择系数 $s$ 和滴度降低因子 $k$ 之间的期望关系。\n\n首先，我们将抗原距离 $d$ 与中和滴度倍数变化 $k$ 之间的关系形式化。问题明确指出：“抗原距离 $d$ 是中和滴度倍数变化的以2为底的对数。”倍数变化为 $k$。因此，我们可以写出抗原距离的方程：\n$$\nd = \\log_{2}(k)\n$$\n这个定义与所提供的信息一致，即2倍的变化（$k=2$）对应一个抗原单位（$d=\\log_{2}(2)=1$）。\n\n接下来，我们将选择系数 $s$ 与抗原距离 $d$ 之间的关系形式化。问题指出：“抗原逃逸突变的选择优势与滴度倍数变化所隐含的抗原距离成正比。”选择系数 $s$ 量化了这种选择优势。这种比例关系可以表示为：\n$$\ns \\propto d\n$$\n引入一个比例常数，我们称之为 $C$，可以将其写成一个方程：\n$$\ns = C \\cdot d\n$$\n问题进一步明确指出“该映射经过校准，使得比例常数为1。”这意味着常数 $C$ 的值为 $1$。\n$$\nC = 1\n$$\n将此值代入 $s$ 的方程，得到选择系数和抗原距离之间的直接等式：\n$$\ns = d\n$$\n最后，为了将 $s$ 表示为 $k$ 的函数，我们将第一步中得到的 $d$ 的表达式代入这个最终方程。\n我们有 $s=d$ 和 $d=\\log_{2}(k)$。因此，通过代换，我们得到选择系数 $s$ 关于滴度降低因子 $k$ 的表达式：\n$$\ns(k) = \\log_{2}(k)\n$$\n这就是在问题所描述的简单映射下，选择系数作为 $k$ 的函数的最终闭式解析表达式。该表达式是无量纲的，符合要求。",
            "answer": "$$\n\\boxed{\\log_{2}(k)}\n$$"
        },
        {
            "introduction": "来自宿主免疫的持续正选择是抗原漂移的引擎，这种强烈的进化压力在病毒基因组中留下了独特的印记。通过比较非同义替换率（$dN$）和同义替换率（$dS$），我们可以识别出基因中正在快速演化的特定位点。这项编程练习  将指导你实现一个基于密码子的模型来计算 $dN/dS$ 比率（$\\omega$），这是检测血凝素等蛋白质中正选择的基石技术。",
            "id": "4657325",
            "problem": "您的任务是使用密码子上的连续时间马尔可夫链，对流感血凝素 (HA) 蛋白质编码序列实施非同义与同义替换速率之比（记为 $dN/dS$，通常称为 $\\omega$）的逐位点推断，并将抗原位点上较高的 $\\omega$ 值解释为与抗原漂移一致的正选择证据。您的程序必须构建一个密码子替换模型，在一个小型的固定星状系统发育树上计算 $\\omega$ 的位点特异性最大似然估计，然后总结抗原位点相对于非抗原位点的 $\\omega$ 是否升高。\n\n基本原理：\n- 遗传密码将每个有义密码子映射到一个氨基酸，另有三个不编码氨基酸的终止密码子。\n- 一个在密码子上状态空间仅限于有义密码子的连续时间马尔可夫链可以模拟密码子替换，其中瞬时速率反映了单核苷酸变化、转换与颠换突变偏好以及对非同义变化的缩放因子。\n- 对于一个速率矩阵 $Q$，时间为 $t$ 的转移概率矩阵是 $P(t) = \\exp(Qt)$，在星状系统发育树上观察到的叶尖状态的似然性，是通过平稳分布 $\\pi$ 对未观察到的祖先状态进行边缘化得到的。\n- 非同义与同义替换速率之比 $\\omega = dN/dS$ 捕捉了在选择压力下非同义替换与同义替换的相对固定速率；$\\omega > 1$ 表示正选择，$\\omega \\approx 1$ 表示中性选择，$\\omega < 1$ 表示纯化选择。\n\n需实现的模型假设：\n- 状态空间由标准遗传密码下的所有有义密码子组成（不包括终止密码子）。\n- 瞬时速率 $q_{ij}$ 仅在密码子 $i$ 和 $j$ 相差一个核苷酸时才非零。设核苷酸突变偏好由一个转换与颠换比率参数 $\\kappa$ 控制。对于单核苷酸变化，如果该变化是转换，则使用与 $\\kappa$ 成正比的基础突变率；如果是颠换，则使用与 $1$ 成正比的基础突变率。如果变化是非同义的，则将此基础速率乘以 $\\omega$；如果是同义的，则乘以 $1$。设置 $q_{ii}$ 使每行之和为零。\n- 对有义密码子使用均匀的平稳频率，即 $\\pi_i = 1/N$，其中 $N$ 是有义密码子的数量。\n- 缩放 $Q$ 以使在分布 $\\pi$ 下，单位时间的平均替换率为 $1$，即 $-\\sum_i \\pi_i q_{ii} = 1$。通过此缩放，枝长 $t$ 以每个密码子的期望替换数来衡量。\n\n系统发育与似然：\n- 使用一个具有三个叶节点且枝长相等的星状系统发育树。对于每个位点，三个叶节点上观察到的密码子表示为 $(x_1, x_2, x_3)$。对于给定的 $\\omega$，枝长为 $t$ 的位点似然为\n$$\n\\mathcal{L}(\\omega) \\;=\\; \\sum_{a} \\pi_a \\prod_{\\ell=1}^{3} P_{a,x_\\ell}(t),\n$$\n其中 $P(t) = \\exp(Qt)$ 是转移概率矩阵。位点特异性最大似然估计 $\\widehat{\\omega}$ 是在指定网格上使 $\\mathcal{L}(\\omega)$ 最大化的 $\\omega$ 值。\n- 使用固定的转换/颠换偏好 $\\kappa = 3.0$（无量纲）和枝长 $t = 0.5$（单位为每个密码子的期望替换数）。\n\n抗原漂移与解释：\n- HA 的抗原区域受到免疫压力，预计在正选择下会表现出较高的 $\\omega$ 值。您将计算一组抗原位点和一组非抗原位点上 $\\widehat{\\omega}$ 的均值，然后报告其差异。\n\n计算任务：\n1. 根据标准遗传密码，通过排除终止密码子来构建大小为 $N$ 的密码子字母表。\n2. 对于一个 $\\omega$ 值的网格 $\\Omega = \\{0.05, 0.1, 0.2, 0.5, 0.8, 1.0, 1.2, 1.5, 2.0, 3.0, 5.0\\}$，按上述方式构建 $Q(\\omega)$，将其缩放至单位平均速率，并对于给定的 $t$ 计算 $P_\\omega(t) = \\exp(Q(\\omega) t)$。\n3. 对于每个位点和每个数据集，通过对所有祖先密码子状态求和并在三个叶节点上取乘积来计算位点似然 $\\mathcal{L}(\\omega)$。选择使该位点的 $\\mathcal{L}(\\omega)$ 最大化的网格值作为 $\\widehat{\\omega}$。\n4. 对于每个数据集，计算抗原位点上 $\\widehat{\\omega}$ 的均值和非抗原位点上 $\\widehat{\\omega}$ 的均值，然后计算差值 $\\Delta = \\overline{\\omega}_{\\text{antigenic}} - \\overline{\\omega}_{\\text{non-antigenic}}$。\n\n输入数据在程序内部固定；无需用户输入。\n\n使用以下三个数据集（每个数据集包含三个标记为 $A$、$B$、$C$ 的序列和六个密码子位置）。密码子由集合 $\\{A,C,G,T\\}$ 中的核苷酸写成：\n\n- 数据集 1（抗原位点主要为同义或保守的）：\n  - 抗原位点索引：$\\{2,5\\}$（基于 1 的索引）。\n  - $A$: [GCT, GAA, TTT, ATG, CTA, CGT]\n  - $B$: [GCT, GAG, TTC, ATG, TTA, CGC]\n  - $C$: [GCT, GAA, TTT, ATA, CTA, AGT]\n\n- 数据集 2（抗原位点具有多个非同义差异）：\n  - 抗原位点索引：$\\{2,5\\}$。\n  - $A$: [GCT, GAA, TTT, ATG, CTA, CGT]\n  - $B$: [GCT, AAA, TTC, ATG, GTA, CGC]\n  - $C$: [GCT, GCA, TTT, ATG, TCA, CGT]\n\n- 数据集 3（具有混合的同义和非同义变化的模糊信号）：\n  - 抗原位点索引：$\\{2,5\\}$。\n  - $A$: [GCT, GAA, TTT, ATG, CTA, CGT]\n  - $B$: [GCT, GAG, TTC, ATA, CTT, CGT]\n  - $C$: [GCT, AAA, TTT, ATG, CTA, CGC]\n\n角度单位不适用。不涉及物理单位。所有结果均为无量纲。\n\n测试套件和要求输出：\n- 使用 $\\kappa = 3.0$、$t = 0.5$ 和指定的 $\\Omega$ 对上述三个数据集实施计算。\n- 对于每个数据集，计算定义的 $\\Delta$。您的程序应生成一行输出，其中包含三个数据集的结果，格式为由三个浮点数组成的逗号分隔列表，四舍五入到三位小数，并用方括号括起，顺序为数据集 1、数据集 2、数据集 3（例如，“[0.123,0.456,-0.789]”）。",
            "solution": "该问题被认为是有效的，因为它在分子进化原理上具有科学依据，问题陈述清晰完整，表述客观。任务是实现一个位点特异性密码子替换模型，以推断非同义与同义替换速率之比 $\\omega$，并确定流感血凝素 (HA) 蛋白中的抗原位点是否显示出正选择的证据。\n\n解决方案分为四个主要阶段：\n1.  定义密码子模型和状态空间。\n2.  构建瞬时速率矩阵 $Q$。\n3.  计算星状系统发育树上的位点似然。\n4.  对每个位点进行 $\\omega$ 的最大似然估计并分析结果。\n\n**1. 密码子模型状态空间**\n\n该模型对密码子（即核苷酸三联体）进行操作。标准遗传密码将 64 个可能的密码子映射到 20 种氨基酸和 3 个终止信号。我们的连续时间马尔可夫链的状态空间被限制在 $N=61$ 个有义密码子，不包括三个终止密码子（`TAA`、`TAG`、`TGA`）。我们建立了一个包含这 61 个密码子的确定性列表，并为每个密码子字符串创建了一个到从 $0$ 到 $60$ 的唯一整数索引的映射，以便进行矩阵运算。平稳分布 $\\pi$ 假定在该状态空间上是均匀的，因此任何有义密码子 $i$ 的频率为 $\\pi_i = 1/N = 1/61$。\n\n**2. 瞬时速率矩阵 $Q(\\omega, \\kappa)$**\n\n从密码子 $i$ 到密码子 $j$ 的瞬时替换速率，记为 $q_{ij}$（当 $i \\neq j$ 时），是基于核苷酸突变和选择的机理模型定义的。矩阵 $Q$ 的大小为 $N \\times N$，即 $61 \\times 61$。\n\n速率 $q_{ij}$ 仅在密码子 $i$ 和 $j$ 相差一个核苷酸时才非零。对于这样的密码子对，速率由以下公式给出：\n$$\nq_{ij} =\n\\begin{cases}\n    \\kappa              \\text{如果是同义转换} \\\\\n    1                   \\text{如果是同义颠换} \\\\\n    \\omega \\cdot \\kappa   \\text{如果是非同义转换} \\\\\n    \\omega \\cdot 1        \\text{如果是非同义颠换}\n\\end{cases}\n$$\n- **转换**是嘌呤之间（A $\\leftrightarrow$ G）或嘧啶之间（C $\\leftrightarrow$ T）的替换。**颠换**是任何其他替换（嘌呤 $\\leftrightarrow$ 嘧啶）。转换/颠换速率比固定为 $\\kappa = 3.0$。\n- 如果替换不改变密码子编码的氨基酸，则该替换是**同义的**。此类变化的速率按因子 $1$ 进行缩放。\n- 如果替换导致不同的氨基酸，则该替换是**非同义的**。此类变化的速率按参数 $\\omega = dN/dS$ 进行缩放，该参数代表选择压力。\n\n速率矩阵的对角线元素被定义为确保行和为零：\n$$\nq_{ii} = - \\sum_{j \\neq i} q_{ij}\n$$\n最后，整个矩阵 $Q$ 被缩放以确保单位时间内的平均替换率为 $1$。在均匀平稳分布 $\\pi_i = 1/N$ 的情况下，此条件为 $-\\sum_{i=0}^{N-1} \\pi_i q_{ii} = 1$，可简化为：\n$$\nS = -\\frac{1}{N} \\sum_{i=0}^{N-1} q_{ii} = 1\n$$\n因此，我们先构建一个未缩放的矩阵，然后将其每个元素除以缩放因子 $S = -\\frac{1}{N} \\sum_i q_{ii}^{\\text{unscaled}}$。对于指定网格 $\\Omega = \\{0.05, 0.1, 0.2, 0.5, 0.8, 1.0, 1.2, 1.5, 2.0, 3.0, 5.0\\}$ 中的每个 $\\omega$ 值，都构建一个单独的速率矩阵。\n\n**3. 系统发育似然计算**\n\n问题指定了一个具有三个叶节点（序列 $A、B、C$）和一个共同祖先的星状系统发育树。从祖先到叶节点的三个枝具有相等的长度 $t = 0.5$，单位为每个密码子的期望替换数。\n\n在长度为 $t$ 的枝上，密码子 $i$ 变为密码子 $j$ 的概率由转移概率矩阵 $P(t) = \\exp(Q t)$ 给出，其中 $Q$ 是缩放后的速率矩阵。对每个 $Q(\\omega)$ 矩阵计算该矩阵指数。\n\n对于比对中的单个位点，设三个叶节点上观察到的密码子为 $(x_1, x_2, x_3)$。在给定 $\\omega$ 值的情况下，观察到此数据的似然是通过对所有可能的祖先密码子 $a$ 进行边缘化来计算的：\n$$\n\\mathcal{L}(\\omega) = \\sum_{a=0}^{N-1} \\pi_a \\prod_{\\ell=1}^{3} P_{a,x_\\ell}(t)\n$$\n鉴于我们假设平稳频率是均匀的，$\\pi_a = 1/N$，该公式变为：\n$$\n\\mathcal{L}(\\omega) = \\frac{1}{N} \\sum_{a=0}^{N-1} P_{a,x_1}(t) \\cdot P_{a,x_2}(t) \\cdot P_{a,x_3}(t)\n$$\n对于每个位点和网格 $\\Omega$ 中的每个 $\\omega$ 值，都会计算此似然。\n\n**4. 估计与分析**\n\n对于每个位点，omega 的最大似然估计 $\\widehat{\\omega}$ 是通过在网格 $\\Omega$ 中找到使位点似然 $\\mathcal{L}(\\omega)$ 最大化的值来确定的。\n\n在计算完一个数据集中所有六个位点的 $\\widehat{\\omega}$ 后，根据提供的索引（位点 2 和 5 是抗原位点），将这些位点分为两组：抗原位点和非抗原位点。然后为每组计算平均 $\\widehat{\\omega}$：\n$$\n\\overline{\\omega}_{\\text{antigenic}} = \\frac{1}{2}\\sum_{i \\in \\{2,5\\}} \\widehat{\\omega}_i \\quad \\text{和} \\quad \\overline{\\omega}_{\\text{non-antigenic}} = \\frac{1}{4}\\sum_{i \\in \\{1,3,4,6\\}} \\widehat{\\omega}_i\n$$\n每个数据集的最终结果是这些均值之间的差值 $\\Delta = \\overline{\\omega}_{\\text{antigenic}} - \\overline{\\omega}_{\\text{non-antigenic}}$。正的 $\\Delta$ 值表示，平均而言，抗原位点比非抗原位点受到更强的正选择，这与抗原漂移的理论一致。对所有三个提供的数据集重复此完整过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Implements a codon substitution model to infer site-wise dN/dS ratios (omega)\n    and analyze differences between antigenic and non-antigenic sites for influenza HA.\n    \"\"\"\n    \n    # --- 1. Model and Problem Constants ---\n\n    KAPPA = 3.0  # Transition/transversion rate ratio\n    T = 0.5  # Branch length\n    OMEGA_GRID = [0.05, 0.1, 0.2, 0.5, 0.8, 1.0, 1.2, 1.5, 2.0, 3.0, 5.0]\n\n    GENETIC_CODE = {\n        'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAT': 'N',\n        'ACA': 'T', 'ACC': 'T', 'ACG': 'T', 'ACT': 'T',\n        'AGA': 'R', 'AGC': 'S', 'AGG': 'R', 'AGT': 'S',\n        'ATA': 'I', 'ATC': 'I', 'ATG': 'M', 'ATT': 'I',\n        'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAT': 'H',\n        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCT': 'P',\n        'CGA': 'R', 'CGC': 'R', 'CGG': 'R', 'CGT': 'R',\n        'CTA': 'L', 'CTC': 'L', 'CTG': 'L', 'CTT': 'L',\n        'GAA': 'E', 'GAC': 'D', 'GAG': 'E', 'GAT': 'D',\n        'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCT': 'A',\n        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGT': 'G',\n        'GTA': 'V', 'GTC': 'V', 'GTG': 'V', 'GTT': 'V',\n        'TAA': '*', 'TAC': 'Y', 'TAG': '*', 'TAT': 'Y',\n        'TCA': 'S', 'TCC': 'S', 'TCG': 'S', 'TCT': 'S',\n        'TGA': '*', 'TGC': 'C', 'TGG': 'W', 'TGT': 'C',\n        'TTA': 'L', 'TTC': 'F', 'TTG': 'L', 'TTT': 'F',\n    }\n    \n    # --- 2. Helper Functions ---\n\n    def get_codons_and_maps(genetic_code):\n        \"\"\"Generates the list of sense codons and their index mappings.\"\"\"\n        codons = sorted([c for c, aa in genetic_code.items() if aa != '*'])\n        codon_to_idx = {c: i for i, c in enumerate(codons)}\n        n_codons = len(codons)\n        return codons, codon_to_idx, n_codons\n\n    def is_transition(n1, n2):\n        \"\"\"Checks if a nucleotide change is a transition.\"\"\"\n        purines = 'AG'\n        pyrimidines = 'CT'\n        return (n1 in purines and n2 in purines) or (n1 in pyrimidines and n2 in pyrimidines)\n\n    def build_q_matrix(omega, kappa, codons, codon_to_idx, n_codons, genetic_code):\n        \"\"\"Builds the unscaled codon substitution rate matrix Q.\"\"\"\n        q = np.zeros((n_codons, n_codons))\n        for i in range(n_codons):\n            for j in range(n_codons):\n                if i == j:\n                    continue\n                \n                codon1, codon2 = codons[i], codons[j]\n                \n                # Check for single nucleotide difference\n                diff_pos = -1\n                diff_count = 0\n                for k in range(3):\n                    if codon1[k] != codon2[k]:\n                        diff_count += 1\n                        diff_pos = k\n                \n                if diff_count == 1:\n                    rate = kappa if is_transition(codon1[diff_pos], codon2[diff_pos]) else 1.0\n                    \n                    is_synonymous = genetic_code[codon1] == genetic_code[codon2]\n                    if not is_synonymous:\n                        rate *= omega\n                    \n                    q[i, j] = rate\n        return q\n\n    def scale_q_matrix(q, n_codons):\n        \"\"\"Sets diagonal elements and scales the Q matrix.\"\"\"\n        row_sums = q.sum(axis=1)\n        np.fill_diagonal(q, -row_sums)\n        \n        # Scaling factor: -sum(pi_i * q_ii) where pi_i = 1/n_codons\n        # This is equivalent to (1/n_codons) * sum of absolute values of diagonal\n        scaling_factor = -np.diag(q).sum() / n_codons\n        if scaling_factor > 0:\n            q /= scaling_factor\n        return q\n\n    def precompute_p_matrices(omega_grid, kappa, t, codons, codon_to_idx, n_codons, genetic_code):\n        \"\"\"Precomputes transition probability matrices P(t) for all omega values.\"\"\"\n        p_matrices = {}\n        for omega in omega_grid:\n            q_unscaled = build_q_matrix(omega, kappa, codons, codon_to_idx, n_codons, genetic_code)\n            q_scaled = scale_q_matrix(q_unscaled, n_codons)\n            p_matrices[omega] = expm(q_scaled * t)\n        return p_matrices\n\n    def calculate_site_omega(site_codons, codon_to_idx, p_matrices, omega_grid, n_codons):\n        \"\"\"Calculates the maximum likelihood estimate of omega for a single site.\"\"\"\n        max_likelihood = -1.0\n        best_omega = -1.0\n        \n        c1, c2, c3 = site_codons\n        idx1, idx2, idx3 = codon_to_idx[c1], codon_to_idx[c2], codon_to_idx[c3]\n\n        for omega in omega_grid:\n            P_t = p_matrices[omega]\n            # Vectorized calculation of likelihood\n            # P_t[:, idx] gives the column vector of probabilities of transitioning to codon `idx` from any ancestor\n            likelihood_vec = P_t[:, idx1] * P_t[:, idx2] * P_t[:, idx3]\n            # Marginalize over all ancestors, with uniform prior pi_a = 1/n_codons\n            site_likelihood = likelihood_vec.sum() / n_codons\n            \n            if site_likelihood > max_likelihood:\n                max_likelihood = site_likelihood\n                best_omega = omega\n        \n        return best_omega\n\n    # --- 3. Main Execution Logic ---\n    \n    codons, codon_to_idx, n_codons = get_codons_and_maps(GENETIC_CODE)\n    p_matrices = precompute_p_matrices(OMEGA_GRID, KAPPA, T, codons, codon_to_idx, n_codons, GENETIC_CODE)\n    \n    ds1_A = [\"GCT\", \"GAA\", \"TTT\", \"ATG\", \"CTA\", \"CGT\"]\n    ds1_B = [\"GCT\", \"GAG\", \"TTC\", \"ATG\", \"TTA\", \"CGC\"]\n    ds1_C = [\"GCT\", \"GAA\", \"TTT\", \"ATA\", \"CTA\", \"AGT\"]\n    \n    ds2_A = [\"GCT\", \"GAA\", \"TTT\", \"ATG\", \"CTA\", \"CGT\"]\n    ds2_B = [\"GCT\", \"AAA\", \"TTC\", \"ATG\", \"GTA\", \"CGC\"]\n    ds2_C = [\"GCT\", \"GCA\", \"TTT\", \"ATG\", \"TCA\", \"CGT\"]\n\n    ds3_A = [\"GCT\", \"GAA\", \"TTT\", \"ATG\", \"CTA\", \"CGT\"]\n    ds3_B = [\"GCT\", \"GAG\", \"TTC\", \"ATA\", \"CTT\", \"CGT\"]\n    ds3_C = [\"GCT\", \"AAA\", \"TTT\", \"ATG\", \"CTA\", \"CGC\"]\n\n    test_cases = [\n        {'seqs': (ds1_A, ds1_B, ds1_C), 'antigenic_sites': {2, 5}},\n        {'seqs': (ds2_A, ds2_B, ds2_C), 'antigenic_sites': {2, 5}},\n        {'seqs': (ds3_A, ds3_B, ds3_C), 'antigenic_sites': {2, 5}},\n    ]\n    \n    final_results = []\n    \n    for case in test_cases:\n        seq_A, seq_B, seq_C = case['seqs']\n        antigenic_sites_1based = case['antigenic_sites']\n        num_sites = len(seq_A)\n        \n        antigenic_omegas = []\n        non_antigenic_omegas = []\n        \n        for i in range(num_sites):\n            site_codons = (seq_A[i], seq_B[i], seq_C[i])\n            site_omega_hat = calculate_site_omega(site_codons, codon_to_idx, p_matrices, OMEGA_GRID, n_codons)\n            \n            if (i + 1) in antigenic_sites_1based:\n                antigenic_omegas.append(site_omega_hat)\n            else:\n                non_antigenic_omegas.append(site_omega_hat)\n        \n        mean_antigenic = np.mean(antigenic_omegas) if antigenic_omegas else 0.0\n        mean_non_antigenic = np.mean(non_antigenic_omegas) if non_antigenic_omegas else 0.0\n        \n        delta = mean_antigenic - mean_non_antigenic\n        final_results.append(f\"{delta:.3f}\")\n\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "病毒的分子进化对其在群体水平的传播动力学具有深远影响。抗原漂移通过不断补充易感个体库，可以驱动流行病的周期性爆发。这项练习  旨在连接分子进化与流行病学，要求你分析一个包含了免疫逃逸的 SIR 模型，从而在数学上确定这一过程如何导致疾病发病率的周期性模式。",
            "id": "4657414",
            "problem": "给定一个包含抗原漂移的流感传播仓室模型，该模型被表述为具有人口周转和免疫逃逸的易感–感染–恢复（SIR）模型。易感–感染–恢复（SIR）表示标准的流行病学仓室：易感者 $S$、感染者 $I$ 和恢复者（免疫者） $R$。人口周转由人均出生和死亡率 $\\nu$ 表示，抗原漂移驱动的免疫逃逸由一个速率 $\\mu_a$ 表示，该速率使个体从 $R$ 仓室返回到 $S$ 仓室。传播遵循质量作用发病率，速率为 $\\beta$，恢复以速率 $\\gamma$ 发生。总人口规模 $N$ 是恒定的，因为出生与死亡相平衡。该模型为\n$$\n\\frac{dS}{dt} = \\nu N - \\frac{\\beta S I}{N} + \\mu_a R - \\nu S,\\quad\n\\frac{dI}{dt} = \\frac{\\beta S I}{N} - \\gamma I - \\nu I,\\quad\n\\frac{dR}{dt} = \\gamma I - \\mu_a R - \\nu R,\n$$\n其中 $N = S + I + R$ 为常数。\n\n仅从这些定义和模型结构出发，判断地方性平衡点周围的微小扰动是否会在发病率（即 $I$）中产生阻尼振荡。当存在振荡时，计算由局部线性动力学所隐含的振荡周期（以年为单位）；当不存在振荡时，将周期定义为 $0.0$ 年。您的方法必须有理有据：在条件 $\\mathcal{R}_0 > 1$ 下推导 $I>0$ 的地方性平衡点，其中基本再生数 $\\mathcal{R}_0$ 满足 $\\mathcal{R}_0 = \\beta / (\\gamma + \\nu)$，然后构建 $(S,I)$ 简化系统的雅可比矩阵，分析其特征值，并在特征值为复数时从其虚部提取周期。将最终周期以年为单位表示，并四舍五入到 $3$ 位小数的实数。\n\n物理单位：所有速率 $\\beta$、$\\gamma$、$\\nu$ 和 $\\mu_a$ 均为每年，输出周期必须以年为单位表示。如果 $\\beta \\le \\gamma + \\nu$（不存在 $I^*>0$ 的地方性平衡点）或线性化仅产生实数特征值（无振荡分量），则输出 $0.0$。\n\n您的程序必须评估以下测试套件。每个测试用例是一个元组 $(N,\\beta,\\gamma,\\nu,\\mu_a)$，其中 $N$ 的单位是人，速率的单位是每年，并且应根据上述规则为每个测试用例返回一个浮点数，即四舍五入到 $3$ 位小数的振荡周期（以年为单位）：\n\n- 案例 1：$N = 10^6$, $\\beta = 140.0$, $\\gamma = 121.0$, $\\nu = 1/70 \\approx 0.0142857$, $\\mu_a = 0.5$。\n- 案例 2（接近阈值且漂移可忽略，预期为非振荡）：$N = 10^6$, $\\beta = 121.1$, $\\gamma = 121.0$, $\\nu = 1/70 \\approx 0.0142857$, $\\mu_a = 0.0$。\n- 案例 3（较高的传播率和显著的漂移）：$N = 10^6$, $\\beta = 200.0$, $\\gamma = 121.0$, $\\nu = 1/70 \\approx 0.0142857$, $\\mu_a = 5.0$。\n- 案例 4（恢复较慢的情景）：$N = 10^6$, $\\beta = 60.0$, $\\gamma = 52.0$, $\\nu = 1/70 \\approx 0.0142857$, $\\mu_a = 0.5$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是相应测试用例的周期（以年为单位），四舍五入到 $3$ 位小数，并以标准十进制表示。",
            "solution": "用户提供的问题被评估为 **有效**，因为它在科学上基于已建立的流行病学建模理论，在数学上是适定的，并且其指令是客观和自洽的。任务是确定一个指定的易感–感染–恢复（SIR）模型的地方性平衡点周围阻尼振荡的周期。解决方案需要基于线性稳定性分析进行有理有据的推导。\n\n该模型由以下常微分方程组（ODEs）描述：\n$$\n\\frac{dS}{dt} = \\nu N - \\frac{\\beta S I}{N} + \\mu_a R - \\nu S\n$$\n$$\n\\frac{dI}{dt} = \\frac{\\beta S I}{N} - (\\gamma + \\nu) I\n$$\n$$\n\\frac{dR}{dt} = \\gamma I - \\mu_a R - \\nu R\n$$\n总人口 $N = S + I + R$ 是恒定的，因为导数之和为零：$\\frac{d(S+I+R)}{dt} = \\nu N - \\nu(S+I+R) = \\nu N - \\nu N = 0$。这使我们可以通过代入 $R = N - S - I$ 来降低系统的维度。动力学可以完全由一个关于 $S$ 和 $I$ 的二维系统描述：\n$$\n\\frac{dS}{dt} = \\nu N - \\frac{\\beta S I}{N} + \\mu_a (N - S - I) - \\nu S = (\\nu + \\mu_a)N - (\\nu+\\mu_a)S - \\frac{\\beta S I}{N} - \\mu_a I\n$$\n$$\n\\frac{dI}{dt} = \\frac{\\beta S I}{N} - (\\gamma + \\nu)I\n$$\n\n我们通过将导数设为零，在条件 $I^* > 0$ 下寻找地方性平衡点 $(S^*, I^*)$。从 $\\frac{dI}{dt} = 0$，我们得到：\n$$\n\\left( \\frac{\\beta S^*}{N} - (\\gamma + \\nu) \\right) I^* = 0\n$$\n由于 $I^* > 0$，我们必须有：\n$$\n\\frac{\\beta S^*}{N} - (\\gamma + \\nu) = 0 \\implies S^* = \\frac{N(\\gamma + \\nu)}{\\beta}\n$$\n为了使地方性流行状态有意义（$S^*  N$），我们必须有 $\\beta > \\gamma+\\nu$，这等同于基本再生数 $\\mathcal{R}_0 = \\frac{\\beta}{\\gamma+\\nu}  1$。这是存在具有正患病率的地方性平衡点的条件。如果 $\\mathcal{R}_0 \\le 1$，则不存在这样的平衡点，周期定义为 $0.0$。\n\n接下来，我们通过设置 $\\frac{dS}{dt} = 0$ 来求解 $I^*$：\n$$\n(\\nu + \\mu_a)N - (\\nu+\\mu_a)S^* - \\frac{\\beta S^* I^*}{N} - \\mu_a I^* = 0\n$$\n代入 $\\frac{\\beta S^*}{N} = \\gamma + \\nu$：\n$$\n(\\nu + \\mu_a)N - (\\nu+\\mu_a)S^* - (\\gamma + \\nu)I^* - \\mu_a I^* = 0\n$$\n$$\n(\\nu + \\mu_a)(N - S^*) = (\\gamma + \\nu + \\mu_a)I^*\n$$\n$$\nI^* = \\frac{(\\nu + \\mu_a)(N - S^*)}{\\gamma + \\nu + \\mu_a} = \\frac{(\\nu + \\mu_a) N \\left(1 - \\frac{\\gamma+\\nu}{\\beta}\\right)}{\\gamma + \\nu + \\mu_a}\n$$\n\n为了分析 $(S^*, I^*)$ 周围的稳定性和振荡行为，我们计算简化系统的雅可比矩阵 $J$：\n$$\nJ = \\begin{pmatrix} \\frac{\\partial}{\\partial S}(\\frac{dS}{dt})  \\frac{\\partial}{\\partial I}(\\frac{dS}{dt}) \\\\ \\frac{\\partial}{\\partial S}(\\frac{dI}{dt})  \\frac{\\partial}{\\partial I}(\\frac{dI}{dt}) \\end{pmatrix}_{(S^*, I^*)}\n$$\n偏导数是：\n$$\n\\frac{\\partial}{\\partial S}(\\frac{dS}{dt}) = -(\\nu+\\mu_a) - \\frac{\\beta I}{N}, \\quad \\frac{\\partial}{\\partial I}(\\frac{dS}{dt}) = -\\frac{\\beta S}{N} - \\mu_a\n$$\n$$\n\\frac{\\partial}{\\partial S}(\\frac{dI}{dt}) = \\frac{\\beta I}{N}, \\quad \\frac{\\partial}{\\partial I}(\\frac{dI}{dt}) = \\frac{\\beta S}{N} - (\\gamma+\\nu)\n$$\n在平衡点 $(S^*, I^*)$ 处计算这些值，得到：\n$$\nJ = \\begin{pmatrix} -(\\nu+\\mu_a) - \\frac{\\beta I^*}{N}  -(\\gamma+\\nu) - \\mu_a \\\\ \\frac{\\beta I^*}{N}  0 \\end{pmatrix} = \\begin{pmatrix} -(\\nu+\\mu_a) - \\frac{\\beta I^*}{N}  -(\\gamma+\\nu+\\mu_a) \\\\ \\frac{\\beta I^*}{N}  0 \\end{pmatrix}\n$$\n$J$ 的特征值 $\\lambda$ 是特征方程 $\\lambda^2 - \\text{Tr}(J)\\lambda + \\det(J) = 0$ 的根，其中：\n$$\n\\text{Tr}(J) = -(\\nu+\\mu_a) - \\frac{\\beta I^*}{N}\n$$\n$$\n\\det(J) = \\left(\\frac{\\beta I^*}{N}\\right) (\\gamma+\\nu+\\mu_a)\n$$\n由于所有参数（$\\nu, \\mu_a, \\beta, \\gamma$）都是非负的且 $I^*0$，很明显 $\\text{Tr}(J)  0$。这确保了特征值的实部为负，意味着平衡点是局部稳定的（扰动是阻尼的）。\n\n如果特征值是一对共轭复数，则会发生振荡。这种情况发生在特征方程的判别式 $\\Delta = \\text{Tr}(J)^2 - 4\\det(J)$ 为负时。\n$$\n\\Delta = \\left(-(\\nu+\\mu_a) - \\frac{\\beta I^*}{N}\\right)^2 - 4\\left(\\frac{\\beta I^*}{N}\\right)(\\gamma+\\nu+\\mu_a)  0\n$$\n如果 $\\Delta \\ge 0$，特征值为实数，不存在振荡，周期 $T$ 为 $0.0$。\n如果 $\\Delta  0$，特征值为 $\\lambda = \\frac{\\text{Tr}(J)}{2} \\pm i\\omega$，其中振荡的角频率 $\\omega$ 为：\n$$\n\\omega = \\frac{\\sqrt{-\\Delta}}{2} = \\frac{\\sqrt{4\\det(J) - \\text{Tr}(J)^2}}{2}\n$$\n振荡周期 $T$ 由 $T = \\frac{2\\pi}{\\omega}$ 给出。\n\n计算算法如下：\n1. 对于每组参数 $(N, \\beta, \\gamma, \\nu, \\mu_a)$，计算 $\\mathcal{R}_0 = \\beta / (\\gamma+\\nu)$。\n2. 如果 $\\mathcal{R}_0 \\le 1$，则周期 $T = 0.0$。\n3. 如果 $\\mathcal{R}_0 > 1$，则继续计算平衡点和稳定性属性。\n4. 计算 $I^* = \\frac{(\\nu + \\mu_a) N (1 - 1/\\mathcal{R}_0)}{\\gamma + \\nu + \\mu_a}$。\n5. 定义一个辅助变量 $X = \\frac{\\beta I^*}{N}$。\n6. 计算迹 $\\text{Tr}(J) = -(\\nu+\\mu_a) - X$ 和行列式 $\\det(J) = X(\\gamma+\\nu+\\mu_a)$。\n7. 计算判别式 $\\Delta = \\text{Tr}(J)^2 - 4\\det(J)$。\n8. 如果 $\\Delta \\ge 0$，则周期 $T=0.0$。\n9. 如果 $\\Delta  0$，计算角频率 $\\omega = \\frac{\\sqrt{-\\Delta}}{2}$ 和周期 $T = \\frac{2\\pi}{\\omega}$。\n10. 将最终周期 $T$ 四舍五入到 $3$ 位小数。\n\n此过程是稳健的，并直接遵循问题陈述。对于案例 2 的评论“预期为非振荡”已被注意到，但计算必须严格遵守推导出的数学条件。如果满足振荡条件，将计算出非零周期。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_period(N, beta, gamma, nu, mu_a):\n    \"\"\"\n    Calculates the oscillation period for the given SIR model with immune escape.\n\n    Args:\n        N (float): Total population size.\n        beta (float): Transmission rate (per year).\n        gamma (float): Recovery rate (per year).\n        nu (float): Per capita birth and death rate (per year).\n        mu_a (float): Rate of immune escape (per year).\n\n    Returns:\n        float: The oscillation period in years. Returns 0.0 if no oscillations\n               or if the endemic equilibrium does not exist.\n    \"\"\"\n    # The combination gamma + nu appears frequently.\n    gamma_nu = gamma + nu\n\n    # Check for existence of the endemic equilibrium, which requires R0 > 1.\n    if beta = gamma_nu:\n        return 0.0\n\n    R0 = beta / gamma_nu\n    \n    # Calculate the endemic equilibrium for the number of infectious individuals, I*.\n    # Using the expression derived from the model equations.\n    # N = S + I + R, dI/dt = beta*S*I/N - (gamma+nu)*I = 0 => S* = N*(gamma+nu)/beta\n    # dS/dt = nu*N - beta*S*I/N + mu_a*R - nu*S = 0\n    # I* = (nu + mu_a) * N * (1 - 1/R0) / (gamma + nu + mu_a)\n    I_star_num = (nu + mu_a) * N * (1.0 - 1.0 / R0)\n    I_star_den = gamma + nu + mu_a\n    \n    # It's possible for the denominator to be zero in an unphysical limit, but not for these cases.\n    if I_star_den == 0:\n        return 0.0 # Avoid division by zero\n    \n    I_star = I_star_num / I_star_den\n    \n    # Construct the Jacobian matrix elements at the equilibrium (S*, I*).\n    # The reduced system is in (S, I).\n    # J = [[- (nu + mu_a) - beta*I*/N,   - (gamma + nu + mu_a)],\n    #      [beta*I*/N,                   0                  ]]\n    \n    # For convenience, let X = beta * I* / N\n    X = beta * I_star / N\n\n    # The trace and determinant of the Jacobian matrix.\n    tr_J = - (nu + mu_a) - X\n    det_J = X * (gamma + nu + mu_a)\n    \n    # The eigenvalues are complex (implying oscillations) if the discriminant is negative.\n    discriminant = tr_J**2 - 4.0 * det_J\n    \n    if discriminant >= 0:\n        # Real eigenvalues, no oscillations.\n        return 0.0\n    else:\n        # Complex eigenvalues, oscillations occur.\n        # Eigenvalues are lambda = (tr_J / 2) +/- i * omega\n        # where omega is the angular frequency.\n        omega = np.sqrt(-discriminant) / 2.0\n        \n        # The period of oscillation T = 2*pi / omega.\n        if omega > 0:\n            period = 2.0 * np.pi / omega\n            return period\n        else:\n             # Should not happen if discriminant is negative.\n            return 0.0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (N, beta, gamma, nu, mu_a)\n    test_cases = [\n        (1e6, 140.0, 121.0, 1.0/70.0, 0.5),\n        (1e6, 121.1, 121.0, 1.0/70.0, 0.0),\n        (1e6, 200.0, 121.0, 1.0/70.0, 5.0),\n        (1e6, 60.0, 52.0, 1.0/70.0, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        period = calculate_period(*case)\n        results.append(period)\n\n    # Format the results to 3 decimal places and print in the specified format.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}