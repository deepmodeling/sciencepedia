{
    "hands_on_practices": [
        {
            "introduction": "理解溶组织内阿米巴的传播动力学始于其生命周期。本练习要求您将寄生虫的生物学阶段——从环境中的包囊到侵袭性滋养体，再回到包囊——转化为一个数学框架。通过构建一个房室模型，您将对寄生虫如何持续存在和传播形成定量的理解，这是传染病流行病学中的一项基本技能。",
            "id": "4628262",
            "problem": "由溶组织内阿米巴（Entamoeba histolytica）引起的阿米巴病经历一个生命周期，包括具环境抵抗力的包囊、宿主摄入包囊、脱囊形成滋养体、在结肠内形成包囊以及排出新包囊。假设单个代表性宿主与一个大型环境宿主库相互作用。设房室变量为：$C_{e}(t)$ 表示环境包囊，$C_{u}(t)$ 表示存在于上消化道（GI）的摄入包囊，$T(t)$ 表示结肠中的滋养体，$C_{s}(t)$ 表示宿主体内等待释放到环境中的排出包囊。假设所有转换和损失均遵循一级质量作用动力学。\n\n定义速率常数：$k_{\\mathrm{in}}$ 为从环境摄入至上消化道的速率，$k_{\\mathrm{ex}}$ 为从上消化道包囊脱囊形成结肠滋养体的速率，$k_{\\mathrm{en}}$ 为从滋养体形成排出包囊的速率，$k_{\\mathrm{sh}}$ 为从排出包囊释放到环境的速率。包括一级损失速率 $\\delta_{e}$（环境包囊衰变），$\\delta_{u}$（上消化道包囊未经脱囊而损失），$\\delta_{t}$（滋养体清除或死亡），以及 $\\delta_{s}$（排出包囊在到达环境前损失）。假设除所研究的宿主外无其他外部来源。\n\n1) 使用这些定义并假设线性、一级转换，写出关于 $C_{e}(t)$, $C_{u}(t)$, $T(t)$, 和 $C_{s}(t)$ 的常微分方程组。\n\n2) 在低密度（线性）机制下，将每个环境包囊通过一次完整的宿主生命周期最终产生的环境包囊的期望数量定义为每个正向转换在其相应损失发生之前发生的逐步概率的乘积。使用竞争性指数风险的标准结果，即如果两个速率分别为 $a$ 和 $b$ 的独立过程相互竞争，则速率为 $a$ 的过程先发生的概率是 $a/(a+b)$，推导这个期望数量关于 $k_{\\mathrm{in}},k_{\\mathrm{ex}},k_{\\mathrm{en}},k_{\\mathrm{sh}},\\delta_{e},\\delta_{u},\\delta_{t},\\delta_{s}$ 的封闭形式表达式。\n\n3) 对给定的参数值对此表达式进行数值计算\n$$\nk_{\\mathrm{in}}=0.05\\ \\text{day}^{-1},\\quad \\delta_{e}=0.02\\ \\text{day}^{-1},\\quad\nk_{\\mathrm{ex}}=2.0\\ \\text{day}^{-1},\\quad \\delta_{u}=0.50\\ \\text{day}^{-1},\\quad\nk_{\\mathrm{en}}=1.0\\ \\text{day}^{-1},\\quad \\delta_{t}=0.30\\ \\text{day}^{-1},\\quad\nk_{\\mathrm{sh}}=0.50\\ \\text{day}^{-1},\\quad \\delta_{s}=0.20\\ \\text{day}^{-1}.\n$$\n将最终答案表示为无单位小数，并四舍五入到四位有效数字。",
            "solution": "问题陈述已经过验证，被认为是合理的。它提出了一个清晰、自洽且具有科学依据的练习，涉及房室模型和概率论在寄生虫学中的应用。所有必要的定义、参数和假设均已提供，足以构建和解决该问题。\n\n### 第1部分：常微分方程组（ODEs）\n\n该常微分方程组描述了每个房室中种群数量的变化率。给定房室的变化率是所有流入速率之和减去所有流出速率之和。我们应用一级质量作用动力学原理，其中一个过程的速率与源房室的大小成正比。\n\n1.  **环境包囊, $C_{e}(t)$**：\n    -   流入：包囊从宿主的“排出包囊”房室 $C_{s}$ 中以速率 $k_{\\mathrm{sh}} C_{s}(t)$ 排出。\n    -   流出：包囊被宿主以速率 $k_{\\mathrm{in}} C_{e}(t)$ 摄入。\n    -   流出：包囊因环境衰变以速率 $\\delta_{e} C_{e}(t)$ 损失。\n    由此得到的微分方程是：\n    $$ \\frac{dC_{e}}{dt} = k_{\\mathrm{sh}} C_{s} - k_{\\mathrm{in}} C_{e} - \\delta_{e} C_{e} = k_{\\mathrm{sh}} C_{s} - (k_{\\mathrm{in}} + \\delta_{e}) C_{e} $$\n\n2.  **上消化道包囊, $C_{u}(t)$**：\n    -   流入：包囊从环境 $C_e$ 中以速率 $k_{\\mathrm{in}} C_{e}(t)$ 摄入。\n    -   流出：包囊以速率 $k_{\\mathrm{ex}} C_{u}(t)$ 脱囊形成滋养体 $T$。\n    -   流出：包囊未经脱囊从上消化道以速率 $\\delta_{u} C_{u}(t)$ 损失。\n    由此得到的微分方程是：\n    $$ \\frac{dC_{u}}{dt} = k_{\\mathrm{in}} C_{e} - k_{\\mathrm{ex}} C_{u} - \\delta_{u} C_{u} = k_{\\mathrm{in}} C_{e} - (k_{\\mathrm{ex}} + \\delta_{u}) C_{u} $$\n\n3.  **结肠滋养体, $T(t)$**：\n    -   流入：滋养体由上消化道包囊 $C_u$ 脱囊产生，速率为 $k_{\\mathrm{ex}} C_{u}(t)$。问题没有指明滋养体的任何复制，因此不包括自我增殖项。\n    -   流出：滋养体以速率 $k_{\\mathrm{en}} T(t)$ 形成排出包囊 $C_s$。\n    -   流出：滋养体以速率 $\\delta_{t} T(t)$ 被清除或死亡。\n    由此得到的微分方程是：\n    $$ \\frac{dT}{dt} = k_{\\mathrm{ex}} C_{u} - k_{\\mathrm{en}} T - \\delta_{t} T = k_{\\mathrm{ex}} C_{u} - (k_{\\mathrm{en}} + \\delta_{t}) T $$\n\n4.  **排出包囊, $C_{s}(t)$**：\n    -   流入：排出包囊由滋养体 $T$ 形成，速率为 $k_{\\mathrm{en}} T(t)$。\n    -   流出：包囊以速率 $k_{\\mathrm{sh}} C_{s}(t)$ 排入环境 $C_e$。\n    -   流出：包囊在排出前于宿主体内以速率 $\\delta_{s} C_{s}(t)$ 损失。\n    由此得到的微分方程是：\n    $$ \\frac{dC_{s}}{dt} = k_{\\mathrm{en}} T - k_{\\mathrm{sh}} C_{s} - \\delta_{s} C_{s} = k_{\\mathrm{en}} T - (k_{\\mathrm{sh}} + \\delta_{s}) C_{s} $$\n\n完整的常微分方程组为：\n$$ \\frac{dC_{e}}{dt} = k_{\\mathrm{sh}} C_{s} - (k_{\\mathrm{in}} + \\delta_{e}) C_{e} $$\n$$ \\frac{dC_{u}}{dt} = k_{\\mathrm{in}} C_{e} - (k_{\\mathrm{ex}} + \\delta_{u}) C_{u} $$\n$$ \\frac{dT}{dt} = k_{\\mathrm{ex}} C_{u} - (k_{\\mathrm{en}} + \\delta_{t}) T $$\n$$ \\frac{dC_{s}}{dt} = k_{\\mathrm{en}} T - (k_{\\mathrm{sh}} + \\delta_{s}) C_{s} $$\n\n### 第2部分：包囊期望数量的推导\n\n问题要求计算单个环境包囊在宿主体内完成一次完整生命周期后产生的环境包囊的期望数量。我们将此数量称为 $R_{cycle}$，它被定义为生命周期中每一步成功转换的概率的乘积。每一步的概率由正向转换过程与损失过程之间的竞争决定。使用所提供的竞争性指数风险公式，即过程“a”在过程“b”之前发生的概率为 $a/(a+b)$，我们可以推导出每一步的概率。\n\n1.  **摄入**：一个环境包囊 ($C_e$) 可以被摄入（速率 $k_{\\mathrm{in}}$）或衰变（速率 $\\delta_e$）。在衰变前成功摄入的概率是：\n    $$ P_{\\mathrm{in}} = \\frac{k_{\\mathrm{in}}}{k_{\\mathrm{in}} + \\delta_{e}} $$\n\n2.  **脱囊**：一个在上消化道 ($C_u$) 的摄入包囊可以脱囊成为滋养体（速率 $k_{\\mathrm{ex}}$）或损失（速率 $\\delta_u$）。成功脱囊的概率是：\n    $$ P_{\\mathrm{ex}} = \\frac{k_{\\mathrm{ex}}}{k_{\\mathrm{ex}} + \\delta_{u}} $$\n\n3.  **形成包囊**：一个滋养体 ($T$) 可以形成包囊（速率 $k_{\\mathrm{en}}$）或被清除/死亡（速率 $\\delta_t$）。成功形成包囊的概率是：\n    $$ P_{\\mathrm{en}} = \\frac{k_{\\mathrm{en}}}{k_{\\mathrm{en}} + \\delta_{t}} $$\n\n4.  **排出**：一个准备排出的包囊 ($C_s$) 可以成功排入环境（速率 $k_{\\mathrm{sh}}$）或损失（速率 $\\delta_s$）。成功排出的概率是：\n    $$ P_{\\mathrm{sh}} = \\frac{k_{\\mathrm{sh}}}{k_{\\mathrm{sh}} + \\delta_{s}} $$\n\n由于问题假设为线性、一级动力学，且没有扩增（即阶段之间是一对一的转换），每个初始包囊产生的包囊的总期望数量是这些顺序概率的乘积：\n$$ R_{cycle} = P_{\\mathrm{in}} \\times P_{\\mathrm{ex}} \\times P_{\\mathrm{en}} \\times P_{\\mathrm{sh}} $$\n代入每个概率的表达式，得到最终的封闭形式表达式：\n$$ R_{cycle} = \\left( \\frac{k_{\\mathrm{in}}}{k_{\\mathrm{in}} + \\delta_{e}} \\right) \\left( \\frac{k_{\\mathrm{ex}}}{k_{\\mathrm{ex}} + \\delta_{u}} \\right) \\left( \\frac{k_{\\mathrm{en}}}{k_{\\mathrm{en}} + \\delta_{t}} \\right) \\left( \\frac{k_{\\mathrm{sh}}}{k_{\\mathrm{sh}} + \\delta_{s}} \\right) $$\n\n### 第3部分：数值计算\n\n我们现在将给定的数值参数值代入 $R_{cycle}$ 的表达式中。\n参数值为：\n$k_{\\mathrm{in}}=0.05\\ \\text{day}^{-1}$, $\\delta_{e}=0.02\\ \\text{day}^{-1}$\n$k_{\\mathrm{ex}}=2.0\\ \\text{day}^{-1}$, $\\delta_{u}=0.50\\ \\text{day}^{-1}$\n$k_{\\mathrm{en}}=1.0\\ \\text{day}^{-1}$, $\\delta_{t}=0.30\\ \\text{day}^{-1}$\n$k_{\\mathrm{sh}}=0.50\\ \\text{day}^{-1}$, $\\delta_{s}=0.20\\ \\text{day}^{-1}$\n\n计算每个概率项：\n$$ P_{\\mathrm{in}} = \\frac{0.05}{0.05 + 0.02} = \\frac{0.05}{0.07} = \\frac{5}{7} $$\n$$ P_{\\mathrm{ex}} = \\frac{2.0}{2.0 + 0.50} = \\frac{2.0}{2.5} = \\frac{20}{25} = \\frac{4}{5} $$\n$$ P_{\\mathrm{en}} = \\frac{1.0}{1.0 + 0.30} = \\frac{1.0}{1.3} = \\frac{10}{13} $$\n$$ P_{\\mathrm{sh}} = \\frac{0.50}{0.50 + 0.20} = \\frac{0.5}{0.7} = \\frac{5}{7} $$\n\n将这些概率相乘以求得 $R_{cycle}$：\n$$ R_{cycle} = \\left(\\frac{5}{7}\\right) \\left(\\frac{4}{5}\\right) \\left(\\frac{10}{13}\\right) \\left(\\frac{5}{7}\\right) $$\n$$ R_{cycle} = \\frac{5 \\times 4 \\times 10 \\times 5}{7 \\times 5 \\times 13 \\times 7} = \\frac{4 \\times 10 \\times 5}{7 \\times 13 \\times 7} = \\frac{200}{637} $$\n现在，我们将此分数转换为小数，并四舍五入到四位有效数字：\n$$ R_{cycle} = \\frac{200}{637} \\approx 0.3139717425... $$\n四舍五入到四位有效数字，我们得到 $0.3140$。",
            "answer": "$$\\boxed{0.3140}$$"
        },
        {
            "introduction": "准确的监测对于控制阿米巴病至关重要，但诊断测试很少是完美的。本实践探讨了一个现实世界中的问题：如何区分致病的溶组织内阿米巴与非致病的迪斯帕内阿米巴，这是一个常见的误分类来源。您将推导出一个公式来校正观察到的发病率，学习如何根据诊断分析的局限性进行调整，从而更准确地了解疾病负担。",
            "id": "4628273",
            "problem": "一家乡村诊所使用粪便抗原捕获法对由溶组织内阿米巴（Entamoeba histolytica）引起的阿米巴结肠炎进行监测。显微镜检查无法可靠地区分溶组织内阿米巴（Entamoeba histolytica）和迪斯帕内阿米巴（Entamoeba dispar），并且交叉反应可能在被迪斯帕内阿米巴（Entamoeba dispar）定植的个体中产生假阳性结果。经聚合酶链式反应（PCR）参考标准验证，该抗原捕获法在检测由溶组织内阿米巴（Entamoeba histolytica）引起的真实阿米巴结肠炎时，具有恒定的灵敏度 $Se$ 和特异性 $Sp$。\n\n在一个固定的监测区间内对一个封闭队列进行监测，期间每位成员都接受一次检测，并记录下原始的检测阳性比例。令 $r_{\\text{obs}}$ 表示在该区间内观测到的检测阳性比例。令 $I_{\\text{true}}$ 表示该区间内由溶组织内阿米巴（Entamoeba histolytica）引起的阿米巴结肠炎的真实发病比例（即，一名随机选择的队列成员在该区间内确实患有阿米巴结肠炎的概率，无论检测结果如何）。\n\n仅使用灵敏度和特异性的定义以及贝叶斯定理，推导一个用 $r_{\\text{obs}}$、$Se$ 和 $Sp$ 表示 $I_{\\text{true}}$ 的闭式表达式。明确说明你所做的任何假设。以单个解析表达式的形式给出最终答案。无需四舍五入。答案应表示为无量纲的比例。",
            "solution": "问题陈述被评估为有效。其科学基础在于医学流行病学和微生物学的原理，在数学上是适定的，并使用了客观、明确的术语。这是一个可以形式化的问题，并且可以从所提供的信息中推导出唯一且有意义的解。\n\n目标是推导一个用观测到的阳性检测比例 $r_{\\text{obs}}$、检测灵敏度 $Se$ 和检测特异性 $Sp$ 来表示真实发病比例 $I_{\\text{true}}$ 的表达式。\n\n令 $D$ 表示从队列中随机选择一个个体在监测区间内确实患有阿米巴结肠炎的事件。令 $T^+$ 表示该个体使用抗原捕获法检测呈阳性的事件。互补事件为 $D^c$（无病）和 $T^-$（检测阴性）。\n\n根据问题陈述，我们用概率来定义给定的量：\n- 真实发病比例是患病的概率：$I_{\\text{true}} = P(D)$。\n- 观测到的检测阳性比例是检测结果为阳性的概率：$r_{\\text{obs}} = P(T^+)$。\n- 灵敏度（$Se$）是在患病条件下检测结果为阳性的条件概率：$Se = P(T^+ | D)$。\n- 特异性（$Sp$）是在无病条件下检测结果为阴性的条件概率：$Sp = P(T^- | D^c)$。\n\n我们的推导将使用全概率公式，它是贝叶斯定理的一个基本组成部分。一个事件（在此情况下为检测阳性）的总概率可以通过将其在一组互斥且完备的事件（在此情况下为患病或不患病）下的条件概率相加来求得。\n\n检测结果为阳性的概率 $P(T^+)$ 可以表示为：\n$$P(T^+) = P(T^+ \\cap D) + P(T^+ \\cap D^c)$$\n使用条件概率的定义 $P(A \\cap B) = P(A|B)P(B)$，我们可以将其重写为：\n$$P(T^+) = P(T^+ | D)P(D) + P(T^+ | D^c)P(D^c)$$\n\n现在我们可以将已定义的项代入此方程。我们有 $P(T^+) = r_{\\text{obs}}$，$P(D) = I_{\\text{true}}$，以及 $P(T^+ | D) = Se$。我们还必须使用给定的信息来表示 $P(D^c)$ 和 $P(T^+ | D^c)$ 这两项。\n\n不患病的概率是患病概率的补集：\n$$P(D^c) = 1 - P(D) = 1 - I_{\\text{true}}$$\n\n$P(T^+ | D^c)$ 项是在无病条件下检测结果为阳性的概率，即假阳性率。它可以从特异性 $Sp$ 推导出来。由于一个未患病的个体检测结果必然是阳性或阴性，其概率之和必须为 $1$：\n$$P(T^+ | D^c) + P(T^- | D^c) = 1$$\n代入 $Sp = P(T^- | D^c)$，我们得到：\n$$P(T^+ | D^c) = 1 - Sp$$\n\n现在，我们将所有这些表达式代回全概率公式方程：\n$$r_{\\text{obs}} = (Se)(I_{\\text{true}}) + (1 - Sp)(1 - I_{\\text{true}})$$\n\n这个方程提供了观测值 $r_{\\text{obs}}$ 和目标量 $I_{\\text{true}}$ 之间的关系。下一步是用代数方法求解 $I_{\\text{true}}$。\n首先，我们展开方程的右边：\n$$r_{\\text{obs}} = Se \\cdot I_{\\text{true}} + 1 - Sp - (1 - Sp) \\cdot I_{\\text{true}}$$\n\n接下来，我们将所有包含 $I_{\\text{true}}$ 的项集中到方程的一边：\n$$r_{\\text{obs}} - (1 - Sp) = Se \\cdot I_{\\text{true}} - (1 - Sp) \\cdot I_{\\text{true}}$$\n$$r_{\\text{obs}} - 1 + Sp = I_{\\text{true}} (Se - (1 - Sp))$$\n$$r_{\\text{obs}} + Sp - 1 = I_{\\text{true}} (Se + Sp - 1)$$\n\n最后，我们通过除以其系数来分离出 $I_{\\text{true}}$：\n$$I_{\\text{true}} = \\frac{r_{\\text{obs}} + Sp - 1}{Se + Sp - 1}$$\n\n这就是所求的真实发病比例的闭式表达式。在流行病学中，这个公式通常被称为 Rogan-Gladen 估计量。\n\n为使此表达式有效且有意义，所需的主要假设是分母不为零，即 $Se + Sp - 1 \\neq 0$。如果 $Se + Sp = 1$，则该检测是无信息的（其阳性似然比为 $1$），意味着其表现不优于随机猜测，因此无法从观测到的检测结果中确定真实发病率。问题的设定意味着这是一个有用的诊断检测，因此这个假设被默许满足。",
            "answer": "$$\\boxed{\\frac{r_{\\text{obs}} + Sp - 1}{Se + Sp - 1}}$$"
        },
        {
            "introduction": "除了流行病学，定量方法对于研究致病机理的分子机制也至关重要。本练习模拟了一项在动物模型中评估关键毒力因子 Gal/GalNAc 凝集素作用的实验。您将应用生存分析技术来比较野生型和基因改造寄生虫株的感染结局，从而获得用于验证传染病研究中分子靶点的统计工具的实践经验。",
            "id": "4628274",
            "problem": "您将获得来自动物队列的右删失生存数据，这些动物分别感染了溶组织内阿米巴 (Entamoeba histolytica) 的野生型 (WT) 和凝集素沉默 (LS) 菌株。任务是基于第一性原理，使用非参数生存分析方法，严谨地分析两组之间的生存差异。\n\n使用生存分析中的以下基本概念：\n\n- 生存函数 $S(t)$ 定义为非负的事件时间随机变量 $T$ 超过时间 $t$ 的概率，即 $S(t) = \\mathbb{P}(T > t)$。\n- 允许存在右删失，并假设其为非信息性的：如果一个观测值在时间 $t$ 被删失，它在时间 $t$ 之前对风险集有贡献，但不会在时间 $t$ 直接确定一个事件。\n- 在生存率相等的零假设下，两组的生存函数满足 $S_1(t) = S_2(t)$ 对所有 $t$ 成立，其中组1为WT，组2为LS。\n\n推导、实现并应用 Kaplan–Meier (KM) 分析来估计每组的生存函数，并计算中位生存时间，即满足估计生存函数 $S(t) \\le 0.5$ 的最小时间 $t$。然后，实现对数秩检验 (log-rank test) 来评估两组的生存经历是否存在差异，其基础是在零假设 $S_1(t) = S_2(t)$ 对所有 $t$ 成立的条件下，比较每个不同事件时间的观测事件计数和期望事件计数。您必须正确处理时间平局 (tied event times)，并在每个事件时间点考虑风险集中的删失情况。如果因为估计的生存函数从未降至 $0.5$ 以下而导致中位生存时间未定义，则该中位生存时间输出为 $-1$。\n\n所有生存时间必须以天为单位处理，任何报告的时间都应以天表示。对数秩检验统计量及其相关的尾部概率必须是无量纲的。将尾部概率（p值）表示为小数（不带百分号）。\n\n实现一个程序，对每个测试用例，输出一个包含四个值的列表：对数秩卡方统计量、对数秩p值、WT组的中位生存时间（天）和LS组的中位生存时间（天）。将所有四个值四舍五入到 $4$ 位小数。\n\n您的程序必须使用以下测试套件。每个测试用例包含两个数组：生存时间（天）和相应的事件指示符（事件指示符等于 $1$ 表示死亡，等于 $0$ 表示右删失）。WT和LS组的数组仅按组成员关系对齐；两组之间没有配对。\n\n- 测试用例 1（差异明显：WT毒性更强，LS毒性较弱）：\n  - WT 时间：$[3,5,6,7,9,9,12,15]$\n  - WT 事件：$[1,1,1,1,1,0,1,0]$\n  - LS 时间：$[5,10,12,14,16,18,20,25]$\n  - LS 事件：$[1,0,1,1,0,1,1,0]$\n\n- 测试用例 2（无差异：生存经历相同）：\n  - WT 时间：$[4,8,10,10,12,14]$\n  - WT 事件：$[1,1,0,1,0,1]$\n  - LS 时间：$[4,8,10,10,12,14]$\n  - LS 事件：$[1,1,0,1,0,1]$\n\n- 测试用例 3（边界条件：大量时间平局和显著删失）：\n  - WT 时间：$[2,2,4,4,6,8]$\n  - WT 事件：$[1,0,1,0,1,0]$\n  - LS 时间：$[2,3,4,4,6,8,10]$\n  - LS 事件：$[0,1,0,1,0,1,0]$\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3]$）。每个 $result_i$ 本身必须是一个形式为 $[\\chi^2, p, m_{\\mathrm{WT}}, m_{\\mathrm{LS}}]$ 的列表，其中 $\\chi^2$ 是对数秩卡方统计量，$p$ 是相关的p值，$m_{\\mathrm{WT}}$ 是WT组的中位生存时间（天），$m_{\\mathrm{LS}}$ 是LS组的中位生存时间（天）。所有数值必须四舍五入到 $4$ 位小数。除此单个方括号列表外，输出不得包含任何其他文本。",
            "solution": "该问题要求对存在右删失的两个组进行生存分析：溶组织内阿米巴 (Entamoeba histolytica) 的野生型 (WT) 菌株与凝集素沉默 (LS) 菌株。我们使用两种工具将生物学背景与统计推导联系起来：Kaplan–Meier (KM) 估计量和对数秩检验 (LRT)，并从生存分析的第一性原理出发推导这两种工具。\n\n基本定义：\n- 设 $T$ 是一个表示事件发生时间（死亡）的非负随机变量，$S(t) = \\mathbb{P}(T > t)$ 是生存函数。我们观察的是右删失数据：对于某些受试者，我们只知道他们在时间 $t$ 之前一直存活，但并未在时间 $t$ 之前经历事件。\n- 假设删失是非信息性的：在删失时间之前一直存活的条件下，被删失受试者中 $T$ 的分布与未被删失受试者中的相同。\n\nKaplan–Meier 估计量推导：\n- 考虑某个组中发生事件的独特、有序的时间点 $\\{t_1, t_2, \\dots, t_J\\}$。设 $n_j$ 为紧邻 $t_j$ 之前的风险集人数，设 $d_j$ 为在时间 $t_j$ 发生的事件数。在 $t_j$ 时的右删失观测值在计入 $t_j$ 的事件后，从风险集中移除。\n- Kaplan–Meier (KM) 估计量，也称为乘积极限估计量，由下式给出\n$$\n\\hat{S}(t) = \\prod_{t_j \\le t} \\left(1 - \\frac{d_j}{n_j}\\right).\n$$\n该估计量源于将生存视为在每个事件时间点上条件失败概率的乘法补集，并假设删失是独立的、非信息性的。\n- 算法上，随时间计算 $\\hat{S}(t)$ 的步骤如下：\n  1. 对组内所有观测时间（事件和删失）进行排序。\n  2. 初始化 $\\hat{S}(t_0) = 1$，$n$ 为受试者总数。\n  3. 在每个独特的时间点 $t$：\n     - 计算在 $t$ 时的事件数 $d$ 和删失数 $c$。\n     - 如果 $d > 0$，更新 $\\hat{S}(t) \\leftarrow \\hat{S}(t^{-}) \\cdot \\left(1 - \\frac{d}{n}\\right)$，其中 $t^{-}$ 表示紧邻 $t$ 之前的时刻。\n     - 更新风险集 $n \\leftarrow n - d - c$。\n  4. 中位生存时间 $\\hat{m}$ 是满足 $\\hat{S}(t) \\le 0.5$ 的最小时间 $t$。如果对于所有观测时间都有 $\\hat{S}(t) > 0.5$，则定义 $\\hat{m} = -1$。\n\n对数秩检验推导：\n- 对数秩检验 (LRT) 评估零假设 $H_0: S_1(t) = S_2(t)$ 对所有 $t$ 成立，其备择假设为生存函数在某个 $t$ 上存在差异。它在所有不同的事件时间点上汇总观测事件计数与期望事件计数之间的偏差，并以 $H_0$ 下的逆方差进行加权。\n- 在两个组合并的每个不同事件时间 $t_j$，定义：\n  - $n_{1j}$ 和 $n_{2j}$ 分别为在紧邻 $t_j$ 之前组1和组2中的风险集人数。\n  - $d_{1j}$ 和 $d_{2j}$ 分别为在 $t_j$ 时各组的事件数。\n  - 总计 $n_j = n_{1j} + n_{2j}$ 和 $d_j = d_{1j} + d_{2j}$。\n- 在 $H_0$ 下，组1在 $t_j$ 时的期望事件数为\n$$\ne_{1j} = d_j \\cdot \\frac{n_{1j}}{n_j},\n$$\n在超几何抽样模型下，$d_{1j} - e_{1j}$ 这一差值的方差为\n$$\nv_{1j} = \\frac{n_{1j} n_{2j} d_j (n_j - d_j)}{n_j^2 (n_j - 1)}.\n$$\n- 对所有事件时间进行汇总：\n$$\nZ = \\sum_{j} (d_{1j} - e_{1j}), \\quad V = \\sum_{j} v_{1j}.\n$$\n- 对数秩卡方统计量为\n$$\n\\chi^2 = \\begin{cases}\n\\frac{Z^2}{V},  V > 0, \\\\\n0,  V = 0,\n\\end{cases}\n$$\n在 $H_0$ 下近似服从自由度为 $1$ 的卡方分布。p值为 $p = 1 - F_{\\chi^2_1}(\\chi^2)$，其中 $F_{\\chi^2_1}$ 是自由度为 $1$ 的卡方分布的累积分布函数。\n- 实践说明：\n  - 在时间 $t$ 的删失个体在时间 $t$ 属于风险集（已知他们存活至 $t$），但其贡献为 $d_{gj} = 0$；他们在 $t$ 之后立即从风险集中移除。\n  - 如果某个时间的 $n_j \\le 1$，则将 $v_{1j}$ 取为 $0$ 以避免除以零；如果汇总后 $V = 0$，则设 $\\chi^2 = 0$ 且 $p = 1$。\n\n算法规划：\n- 对每个组，计算KM阶梯函数，并确定中位数 $\\hat{m}$ 为满足 $\\hat{S}(t) \\le 0.5$ 的最早时间 $t$，如果未达到则为 $-1$。\n- 对于对数秩检验，合并两组的所有不同事件时间，在每个 $t_j$ 计算 $n_{1j}, n_{2j}, d_{1j}, d_{2j}$，汇总 $Z$ 和 $V$，然后计算 $\\chi^2$ 和 $p$。\n- 将上述方法应用于所有测试用例，并输出包含四元组 $[\\chi^2, p, m_{\\mathrm{WT}}, m_{\\mathrm{LS}}]$ 列表的单行文本，按指定格式四舍五入到 $4$ 位小数。\n\n所提供测试套件中的边缘情况：\n- 测试用例 1 展示了明显的组间差异（WT组事件发生更早且更频繁）。\n- 测试用例 2 的两组数据完全相同，因此 $\\chi^2$ 应接近 $0$，$p$ 接近 $1$，且中位数相等。\n- 测试用例 3 包含大量时间平局和显著删失，用以检验对风险集和方差累积的正确处理。\n\n所有中位生存时间的输出必须以天为单位，并且所有输出必须按要求四舍五入到 $4$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef km_median(times, events):\n    \"\"\"\n    Compute the Kaplan–Meier survival step function and return the median survival time.\n    times: list or array of survival times (days)\n    events: list or array of event indicators (1=death, 0=censored)\n    Returns median survival time (days); -1 if survival never drops to 0.5.\n    \"\"\"\n    times = np.array(times, dtype=float)\n    events = np.array(events, dtype=int)\n\n    # Sort unique times (include both events and censors for risk set updates)\n    unique_times = np.unique(times)\n\n    # Precompute counts at each time\n    # d(t): number of events at time t\n    # c(t): number of censors at time t\n    d_counts = {}\n    c_counts = {}\n    for t in unique_times:\n        at_t = (times == t)\n        d_counts[t] = int(np.sum(at_t  (events == 1)))\n        c_counts[t] = int(np.sum(at_t  (events == 0)))\n\n    n = len(times)\n    S = 1.0\n    # Record survival steps only when an event occurs (since censoring does not change S)\n    step_times = []\n    step_surv = []\n\n    for t in unique_times:\n        d = d_counts[t]\n        c = c_counts[t]\n        if n == 0:\n            break\n        if d > 0:\n            S *= (n - d) / n\n            step_times.append(t)\n            step_surv.append(S)\n        # Update risk set after accounting for events and censors at t\n        n -= (d + c)\n\n    # Determine median survival: earliest time where S = 0.5\n    median = -1.0\n    for t, s in zip(step_times, step_surv):\n        if s = 0.5:\n            median = float(t)\n            break\n    return median\n\ndef logrank_test(times1, events1, times2, events2):\n    \"\"\"\n    Compute the log-rank test statistic and p-value comparing two groups.\n    Returns (chi_square_stat, p_value).\n    \"\"\"\n    times1 = np.array(times1, dtype=float)\n    events1 = np.array(events1, dtype=int)\n    times2 = np.array(times2, dtype=float)\n    events2 = np.array(events2, dtype=int)\n\n    # Distinct pooled event times across both groups\n    event_times1 = np.unique(times1[events1 == 1])\n    event_times2 = np.unique(times2[events2 == 1])\n    pooled_event_times = np.unique(np.concatenate([event_times1, event_times2]))\n    pooled_event_times.sort()\n\n    Z = 0.0\n    V = 0.0\n\n    for t in pooled_event_times:\n        # Number at risk just prior to t (include those with time == t)\n        n1 = int(np.sum(times1 >= t))\n        n2 = int(np.sum(times2 >= t))\n        n = n1 + n2\n\n        # Number of events at t\n        d1 = int(np.sum((times1 == t)  (events1 == 1)))\n        d2 = int(np.sum((times2 == t)  (events2 == 1)))\n        d = d1 + d2\n\n        if n == 0 or d == 0:\n            # No risk or no events; skip (pooled_event_times ensures d > 0 typically)\n            continue\n\n        e1 = d * (n1 / n)\n        # Variance under hypergeometric sampling; guard against division by zero\n        if n > 1:\n            v1 = (n1 * n2 * d * (n - d)) / (n**2 * (n - 1))\n        else:\n            v1 = 0.0\n\n        Z += (d1 - e1)\n        V += v1\n\n    if V > 0.0:\n        chi_sq = (Z ** 2) / V\n        p_val = 1.0 - chi2.cdf(chi_sq, df=1)\n    else:\n        chi_sq = 0.0\n        p_val = 1.0\n\n    return chi_sq, p_val\n\ndef format_no_spaces(obj):\n    \"\"\"\n    Convert a Python list or number into a string without spaces, with default repr for numbers.\n    \"\"\"\n    if isinstance(obj, list):\n        return '[' + ','.join(format_no_spaces(x) for x in obj) + ']'\n    elif isinstance(obj, float):\n        # Ensure standard float string without spaces\n        return str(obj)\n    elif isinstance(obj, int):\n        return str(obj)\n    else:\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (WT_times, WT_events, LS_times, LS_events)\n    test_cases = [\n        (\n            [3, 5, 6, 7, 9, 9, 12, 15],\n            [1, 1, 1, 1, 1, 0, 1, 0],\n            [5, 10, 12, 14, 16, 18, 20, 25],\n            [1, 0, 1, 1, 0, 1, 1, 0],\n        ),\n        (\n            [4, 8, 10, 10, 12, 14],\n            [1, 1, 0, 1, 0, 1],\n            [4, 8, 10, 10, 12, 14],\n            [1, 1, 0, 1, 0, 1],\n        ),\n        (\n            [2, 2, 4, 4, 6, 8],\n            [1, 0, 1, 0, 1, 0],\n            [2, 3, 4, 4, 6, 8, 10],\n            [0, 1, 0, 1, 0, 1, 0],\n        ),\n    ]\n\n    results = []\n    for wt_times, wt_events, ls_times, ls_events in test_cases:\n        # Log-rank test\n        chi_sq, p_val = logrank_test(wt_times, wt_events, ls_times, ls_events)\n        # Kaplan–Meier medians\n        m_wt = km_median(wt_times, wt_events)\n        m_ls = km_median(ls_times, ls_events)\n\n        # Round all outputs to 4 decimal places\n        chi_sq_r = round(float(chi_sq), 4)\n        p_val_r = round(float(p_val), 4)\n        m_wt_r = round(float(m_wt), 4)\n        m_ls_r = round(float(m_ls), 4)\n\n        results.append([chi_sq_r, p_val_r, m_wt_r, m_ls_r])\n\n    # Final print statement in the exact required format: single line, bracketed list, no spaces.\n    print(format_no_spaces(results))\n\nsolve()\n```"
        }
    ]
}