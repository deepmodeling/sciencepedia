{
    "hands_on_practices": [
        {
            "introduction": "在设计下一代测序（NGS）实验时，一个核心问题是确定需要多少测序数据才能达到足够的覆盖深度。本练习将指导您从基本原理出发，推导出一个连接总测序产量、样本数量、靶向捕获效率和目标区域大小与平均覆盖深度之间关系的关键公式。掌握这种估算能力是有效规划测序项目和成本控制的基础。",
            "id": "4380718",
            "problem": "一个进行新一代测序（NGS）的临床实验室，使用一个总靶标大小为 $T$ 个碱基对的杂交捕获基因panel，在单次测序运行中对 $S$ 个样本进行多重化处理。该仪器总共产生 $R$ 个测序碱基（指在修剪和过滤后，所有读长两端的全部碱基检出之和）。比对后，根据经验测得的靶向率 $\\alpha$ 定义为这些测序碱基中映射到预期目标区间内的部分所占的比例。假设文库均一性理想，因此每个样本获得相等份额的测序碱基；并假设在靶标区域内进行均匀随机抽样，因此预期覆盖度在靶标上均匀分布。\n\n仅使用基本定义，即一个样本的预期平均覆盖深度 $\\bar{d}$ 是归属于该样本的靶向总碱基数除以该样本的靶标大小，请推导出一个用 $R$、$S$、$\\alpha$ 和 $T$ 表示 $\\bar{d}$ 的表达式。\n\n然后，使用以下符合实际的运行参数计算您的表达式：$R = 9.6 \\times 10^{10}$，$S = 30$，$\\alpha = 0.72$，$T = 4.2 \\times 10^{6}$。将您最终的 $\\bar{d}$ 数值结果四舍五入到四位有效数字。将最终的预期深度表示为一个无量纲数。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n### 步骤 1：提取已知条件\n问题陈述中提供的数据、变量、定义和假设如下：\n- $T$：总靶标大小，单位为碱基对。\n- $S$：多重化样本的数量。\n- $R$：仪器产生的测序碱基总数。\n- $\\alpha$：经验测得的靶向率，定义为映射到预期目标区间内的测序碱基所占的比例。\n- 假设 1：文库均一性理想，意味着每个样本获得相等份额的测序碱基。\n- 假设 2：在靶标区域内进行均匀随机抽样，意味着预期覆盖度均匀分布。\n- 定义：一个样本的预期平均深度 $\\bar{d}$ 是归属于该样本的靶向总碱基数与该样本的靶标大小之比。\n- 任务 1：推导一个用 $R$、$S$、$\\alpha$ 和 $T$ 表示 $\\bar{d}$ 的表达式。\n- 任务 2：使用参数 $R = 9.6 \\times 10^{10}$，$S = 30$，$\\alpha = 0.72$，$T = 4.2 \\times 10^{6}$ 计算该表达式。\n- 任务 3：将最终的 $\\bar{d}$ 数值结果四舍五入到四位有效数字。\n- 任务 4：将最终的预期深度表示为一个无量纲数。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学依据：** 该问题牢固地植根于新一代测序（NGS）数据分析的原理，这是现代基因组学和精准医疗的核心组成部分。测序产量（$R$）、多重化（$S$）、靶标大小（$T$）、靶向率（$\\alpha$）和平均覆盖深度（$\\bar{d}$）等概念是该领域使用的标准指标。所提供的数值对于高通量测序实验（例如，在Illumina NovaSeq仪器上运行的多样本外显子组或大型基因panel）是符合实际的。\n- **问题适定性：** 该问题为待推导的量 $\\bar{d}$ 提供了清晰明确的定义。它提供了构建唯一数学关系所需的所有必要变量（$R$、$S$、$\\alpha$、$T$）和简化假设（均一的文库代表性、均匀分布）。解的存在性和唯一性得到保证。\n- **客观性：** 问题以精确、定量且无偏见的技术语言陈述。它要求基于既定定义进行推导和计算，不含任何主观或推测性元素。\n\n该问题没有表现出说明中列出的任何缺陷。它在事实上是合理的，形式上是可解的，完整的，现实的，并且结构良好。\n\n### 步骤 3：结论与行动\n该问题被判定为 **有效**。将提供完整的解答。\n\n### 推导与求解\n目标是推导单个样本的预期平均覆盖深度 $\\bar{d}$ 的表达式。我们从提供的基本量开始。\n\n仪器为所有样本组合产生的测序碱基总数为 $R$。\n\n靶向率 $\\alpha$ 是这些碱基中比对到目标基因组区域的部分所占的比例。因此，所有样本的总靶向碱基数，我们可记为 $B_{\\text{on-target, total}}$，由下式给出：\n$$B_{\\text{on-target, total}} = \\alpha R$$\n\n问题陈述中有 $S$ 个样本在一次运行中进行多重化处理，并假设文库均一性理想。这意味着总靶向碱基在 $S$ 个样本中平均分配。因此，单个样本的靶向碱基数 $B_{\\text{on-target, sample}}$ 为：\n$$B_{\\text{on-target, sample}} = \\frac{B_{\\text{on-target, total}}}{S} = \\frac{\\alpha R}{S}$$\n\n问题为预期平均深度 $\\bar{d}$ 提供了精确定义：它是该样本的靶向总碱基数与靶标大小 $T$ 之比。靶标大小 $T$ 是被测量覆盖度的基因组区域的长度。\n$$\\bar{d} = \\frac{B_{\\text{on-target, sample}}}{T}$$\n分子的单位是碱基，分母的单位是碱基对。最终得到的量 $\\bar{d}$ 是无量纲的，代表靶标区域中每个碱基被测序的平均次数。这通常用“X”表示（例如，$500$X 覆盖度）。\n\n将 $B_{\\text{on-target, sample}}$ 的表达式代入 $\\bar{d}$ 的方程，我们得到通用公式：\n$$\\bar{d} = \\frac{\\left(\\frac{\\alpha R}{S}\\right)}{T}$$\n这可以简化为每个样本的预期平均覆盖深度的最终表达式：\n$$\\bar{d} = \\frac{\\alpha R}{S T}$$\n\n现在，我们使用提供的数值参数来计算这个表达式：\n- $R = 9.6 \\times 10^{10}$\n- $S = 30$\n- $\\alpha = 0.72$\n- $T = 4.2 \\times 10^{6}$\n\n将这些值代入推导出的公式中：\n$$\\bar{d} = \\frac{(0.72)(9.6 \\times 10^{10})}{(30)(4.2 \\times 10^{6})}$$\n\n首先，我们分别计算分子和分母。\n分子：\n$$0.72 \\times 9.6 \\times 10^{10} = 6.912 \\times 10^{10}$$\n分母：\n$$30 \\times 4.2 \\times 10^{6} = 126 \\times 10^{6} = 1.26 \\times 10^{8}$$\n\n现在，我们进行除法运算：\n$$\\bar{d} = \\frac{6.912 \\times 10^{10}}{1.26 \\times 10^{8}}$$\n$$\\bar{d} = \\frac{6.912}{1.26} \\times 10^{(10-8)}$$\n$$\\bar{d} = 5.4857142... \\times 10^{2}$$\n$$\\bar{d} = 548.57142...$$\n\n问题要求最终答案四舍五入到四位有效数字。前四位有效数字是 $5$、$4$、$8$ 和 $5$。第五位数字是 $7$，大于或等于 $5$，所以我们将第四位有效数字向上取整。\n$$\\bar{d} \\approx 548.6$$\n该值表示预期平均覆盖深度约为 $548.6$X。",
            "answer": "$$\n\\boxed{548.6}\n$$"
        },
        {
            "introduction": "平均覆盖深度虽然是一个有用的起始指标，但它无法完全反映测序数据的真实质量，尤其是在靶向测序中普遍存在的覆盖不均一性。本练习将通过分析一个假设的深度分布数据，让您亲手计算并比较平均深度、中位深度和覆盖广度等多个关键指标。通过此实践，您将学会如何解读这些指标间的差异，从而更深刻地理解覆盖度的非均一性及其对临床变异检测的实际影响。",
            "id": "4380739",
            "problem": "一个用于精准肿瘤学的临床级新一代测序（NGS）靶向基因包覆盖了$1\\,\\text{megabase}$（$1{,}000{,}000$个碱基）的外显子区域。后续处理包括去除聚合酶链式反应（PCR）扩增重复，并通过过滤仅保留比对质量$\\geq$某一严格阈值的唯一比对读段对，从而得到一个逐碱基深度分布（即每个碱基的独立读段观测数）。考虑在整个基因包上经验观测到的以下深度分布，其中每个碱基具有一个整数深度值，且碱基计数总和恰好等于基因包大小：\n- 深度为$5\\times$的碱基有$40{,}000$个，\n- 深度为$10\\times$的碱基有$120{,}000$个，\n- 深度为$20\\times$的碱基有$180{,}000$个，\n- 深度为$30\\times$的碱基有$300{,}000$个，\n- 深度为$40\\times$的碱基有$200{,}000$个，\n- 深度为$80\\times$的碱基有$160{,}000$个。\n\n仅使用逐碱基深度、集中趋势和覆盖广度的基本定义，计算以下指标：\n- 整个基因包的平均深度，\n- 整个基因包的中位深度，\n- 深度$\\geq 30\\times$的碱基所占的比例。\n\n以覆盖倍数（$\\times$）报告平均深度和中位深度。以小数形式报告深度$\\geq 30\\times$的碱基比例（不要使用百分号）。如果任何计算产生无限小数，则将该值四舍五入到四位有效数字；否则，报告精确值。最后，基于NGS捕获和扩增过程的定义及公认特性，提供一个简要的解释，说明在用于临床变异检测的靶向基因包中，这些指标为何以及如何会产生差异。",
            "solution": "该问题提供了一个靶向基因组panel的测序深度的离散分布，并要求计算三个关键统计指标：平均深度、中位深度以及覆盖深度达到或超过指定阈值的碱基比例。此外，还要求在新一代测序（NGS）技术的背景下对这些指标进行解释。\n\n基因包大小为 $N = 1{,}000{,}000$ 个碱基。深度分布以一组数据对 $(n_i, d_i)$ 的形式给出，其中 $n_i$ 是深度为 $d_i$ 的碱基数量。数据点如下：\n\\begin{itemize}\n    \\item $(n_1, d_1) = (40000, 5)$\n    \\item $(n_2, d_2) = (120000, 10)$\n    \\item $(n_3, d_3) = (180000, 20)$\n    \\item $(n_4, d_4) = (300000, 30)$\n    \\item $(n_5, d_5) = (200000, 40)$\n    \\item $(n_6, d_6) = (160000, 80)$\n\\end{itemize}\n碱基总数为 $\\sum_{i=1}^{6} n_i = 40000 + 120000 + 180000 + 300000 + 200000 + 160000 = 1000000$，这与给定的基因包大小 $N$ 一致。\n\n1.  **平均深度 ($\\bar{d}$)**\n\n平均深度是深度值的加权平均值，其中权重是每个深度的碱基数。它的计算方法是，将所有碱基上测序的总读段数除以基因包中的总碱基数。\n平均深度的计算公式为：\n$$ \\bar{d} = \\frac{\\sum_{i=1}^{6} n_i d_i}{\\sum_{i=1}^{6} n_i} = \\frac{\\sum_{i=1}^{6} n_i d_i}{N} $$\n分子代表比对上的总读段数：\n$$ \\sum_{i=1}^{6} n_i d_i = (40000 \\times 5) + (120000 \\times 10) + (180000 \\times 20) + (300000 \\times 30) + (200000 \\times 40) + (160000 \\times 80) $$\n$$ \\sum_{i=1}^{6} n_i d_i = 200000 + 1200000 + 3600000 + 9000000 + 8000000 + 12800000 = 34800000 $$\n因此，平均深度为：\n$$ \\bar{d} = \\frac{34800000}{1000000} = 34.8 $$\n平均深度为 $34.8\\times$。这是一个精确值。\n\n2.  **中位深度 ($d_{\\text{median}}$)**\n\n中位深度是一个值，基因包中一半的碱基深度小于或等于该值，另一半则大于或等于该值。为了找到中位数，我们必须将 $1{,}000{,}000$ 个碱基按其深度排序，并找到位于中点的碱基的值。由于 $N=1{,}000{,}000$ 是一个偶数，中位数是位于第 $N/2 = 500{,}000$ 和第 $N/2 + 1 = 500{,}001$ 位置上碱基深度的平均值。\n\n我们构建一个累积频率分布：\n\\begin{itemize}\n    \\item 深度$\\leq 5\\times$的碱基数：$40000$\n    \\item 深度$\\leq 10\\times$的碱基数：$40000 + 120000 = 160000$\n    \\item 深度$\\leq 20\\times$的碱基数：$160000 + 180000 = 340000$\n    \\item 深度$\\leq 30\\times$的碱基数：$340000 + 300000 = 640000$\n\\end{itemize}\n深度达到 $20\\times$ 的累积碱基数为 $340{,}000$。深度达到 $30\\times$ 的累积碱基数为 $640{,}000$。这意味着在排序列表中，从第 $340{,}001$ 个到第 $640{,}000$ 个位置的碱基深度均为 $30\\times$。\n第 $500{,}000$ 和第 $500{,}001$ 个位置都落在这个范围内。因此，这两个位置的深度都是 $30\\times$。\n中位数是这两个值的平均值：\n$$ d_{\\text{median}} = \\frac{30 + 30}{2} = 30 $$\n中位深度为 $30\\times$。这是一个精确值。\n\n3.  **深度$\\geq 30\\times$的碱基比例 ($f_{\\geq 30\\times}$)**\n\n这个指标是衡量覆盖广度的一种方法，需要将达到或超过 $30\\times$ 深度阈值的碱基数量相加，然后除以总碱基数。\n满足此条件的深度为 $30\\times$、$40\\times$ 和 $80\\times$。这些深度的碱基数量分别为：\n\\begin{itemize}\n    \\item 深度为$30\\times$的碱基数：$300000$\n    \\item 深度为$40\\times$的碱基数：$200000$\n    \\item 深度为$80\\times$的碱基数：$160000$\n\\end{itemize}\n深度$\\geq 30\\times$的总碱基数为：\n$$ N_{\\geq 30\\times} = 300000 + 200000 + 160000 = 660000 $$\n该比例为：\n$$ f_{\\geq 30\\times} = \\frac{N_{\\geq 30\\times}}{N} = \\frac{660000}{1000000} = 0.66 $$\n这是一个精确值。\n\n**解释**\n\n计算出的指标为：平均深度 $\\bar{d} = 34.8\\times$，中位深度 $d_{\\text{median}} = 30\\times$，深度$\\geq 30\\times$的碱基比例 $f_{\\geq 30\\times} = 0.66$。平均深度大于中位深度（$\\bar{d} > d_{\\text{median}}$）这一观察结果是根本性的。它表明深度分布是右偏（或正偏）的，这是靶向NGS数据集的一个典型特征。\n\n这种偏态源于基于捕获的测序工作流程中固有的两个主要系统性偏差来源：\n1.  **杂交/捕获偏差**：靶向基因包使用寡核苷酸探针从复杂的文库中捕获特定的DNA片段。这种杂交过程的效率在所有靶向区域并非均一。GC含量、重复序列的存在以及DNA二级结构等因素导致某些基因组区域比其他区域被更有效地捕获。这些“热点”区域会累积非常高的读段数。\n2.  **PCR扩增偏差**：捕获之后，所选的片段通过聚合酶链式反应（PCR）进行扩增，以产生足够的测序材料。这个扩增过程同样是不均一的；某些片段（例如，GC含量适中且长度较短的片段）被更有效地扩增。尽管通过生物信息学方法去除了PCR重复，但扩增初始循环中的偏差仍然会传播并加剧在捕获阶段形成的不均一性。\n\n这些偏差的影响直接反映在计算出的指标中：\n-   **平均深度 ($34.8\\times$)**：该指标对极值敏感。少数具有非常高深度的碱基（例如，深度为 $80\\times$ 的 $160{,}000$ 个碱基）会不成比例地拉高平均值。虽然它反映了每兆碱基靶区的总测序产出，但它可能通过掩盖潜在的不均一性，从而对整体覆盖质量给出一个过于乐观的印象。\n-   **中位深度 ($30\\times$)**：作为一种稳健的集中趋势度量，中位数不受高深度离群值的显著影响。它指出了基因包中一个“典型”碱基的深度，揭示了 $50\\%$ 的靶向区域的覆盖深度为 $30\\times$ 或更低。中位数低于平均值是右偏分布的直接结果。\n-   **深度$\\geq 30\\times$的碱基比例 ($0.66$)**：对于肿瘤学中的体细胞变异检测等临床应用，需要一个最低深度来保证统计置信度。该指标提供了一个直接且具有临床相关性的**覆盖广度**度量——即在指定质量阈值下，基因包中实际可分析部分的比例。在这里，尽管平均深度接近 $35\\times$，但有三分之一的基因包区域（$1.0 - 0.66 = 0.34$）未能达到 $30\\times$ 的最低要求，这可能导致这些区域无法用于高置信度的变异检出。\n\n总之，平均深度和中位深度之间的差异量化了覆盖度的不均一性，这是NGS实验方案中生物化学偏差的直接结果。虽然平均值和中位数描述了覆盖深度的集中趋势，但覆盖广度指标可以说是评估靶向测序panel诊断效用最关键的指标。全面的评估需要所有这三个指标，以了解总体测序量及其在靶向区域的有效分布。",
            "answer": "$$\\boxed{\\begin{pmatrix} 34.8 & 30 & 0.66 \\end{pmatrix}}$$"
        },
        {
            "introduction": "不同的生物信息学工具在计算同一基因组区域的覆盖深度时，有时会给出不同的结果，这常常让研究者感到困惑。本练习将带您深入测序比对文件（BAM）的底层细节，通过亲手实现不同的覆盖度计算策略来揭示这些差异的根源。您将学习如何解析CIGAR字符串、应用SAM标志位过滤器以及区分基于比对（alignment-level）和基于片段（fragment-level）的计数，从而彻底理解覆盖度这一核心指标是如何被精确计算和定义的。",
            "id": "4380689",
            "problem": "给定一份二进制比对/图谱 (BAM) 内容的综合摘要，您需要通过计算来演示不同的覆盖策略如何在相同的基因组区域上产生不同的深度值。目标是通过严格应用源自序列比对/图谱 (SAM) 标志、映射质量、碱基质量和片段级计数规则的过滤器来调和这些差异。请使用以下基本定义和事实，从第一性原理实现该算法。\n\n基本定义：\n- 参考位置 $p$ 处的覆盖深度定义为根据指定的计数策略，与位置 $p$ 重叠的测序证据的数量。\n- 在 SAM/BAM 中，紧凑特异性缺口比对报告 (CIGAR) 编码了比对片段的操作。此处使用的操作有匹配 ($M$)、插入 ($I$)、删除 ($D$) 和软剪切 ($S$)。操作 $M$ 同时消耗读段和参考序列：它在消耗的参考位置上贡献覆盖度。操作 $I$ 消耗读段但不消耗参考序列：它不在任何参考位置上贡献覆盖度。操作 $D$ 消耗参考序列但不消耗读段：它在该读段的已删除参考位置上贡献零覆盖度。操作 $S$ 消耗读段但不消耗参考序列：它在软剪切位置上贡献零覆盖度。比对起始坐标是 CIGAR 消耗的第一个参考位置。\n- 此处相关的 SAM 标志位：成对 ($0x1$)、正常成对 ($0x2$)、未映射 ($0x4$)、次要比对 ($0x100$)、供应商质控失败 ($0x200$)、重复 ($0x400$)、补充比对 ($0x800$)。\n- 映射质量 ($\\mathrm{MAPQ}$) 是一个非负整数，用于评估比对位置的置信度。碱基质量是与每个碱基相关联的 Phred 标度质量分数 ($Q$)，在此我们仅针对由 $M$ 消耗的位置进行定义。\n- 一个片段指的是底层的 DNA 分子；如果执行双末端测序，两个读段 (mates) 源自单个片段并共享一个片段标识。在位置 $p$ 进行片段级计数意味着即使两个配对读段都与 $p$ 重叠，一个片段对 $p$ 处的深度贡献最多为 $1$。\n\n需要实现的策略：\n- 策略 $\\mathrm{U}$ (“未过滤的比对计数”)：对于每个比对及其 $M$ 操作消耗的每个参考位置，在该位置的深度上加 $1$。不根据标志、映射质量或碱基质量排除任何比对。按比对计数（重叠的配对读段会加 $2$）。\n- 策略 $\\mathrm{F}$ (“过滤后的比对计数”)：排除设置了以下任一标志的比对：未映射 ($0x4$)、次要 ($0x100$)、补充 ($0x800$)、重复 ($0x400$)、供应商质控失败 ($0x200$)。要求映射质量 $\\geq m_{\\min}$。计数时忽略碱基质量。按比对计数（重叠的配对读段会加 $2$）。\n- 策略 $\\mathrm{C}$ (“带碱基质量过滤的片段计数”)：应用与策略 $\\mathrm{F}$ 相同的比对级别过滤器。此外，在决定一个比对是否贡献时，要求每个参考位置的碱基质量 $\\geq q_{\\min}$。在每个位置 $p$，通过取配对读段中所有合格位置的并集，每个片段最多计数 $1$ 次。\n\n算法约束：\n- 对于给定的具有起始坐标 $s$ 和 CIGAR 字符串的比对，从左到右解析 CIGAR。维护一个初始化为 $s$ 的当前参考位置。对于长度为 $\\ell$ 的 $M$ 操作，该比对覆盖参考位置 $s, s+1, \\dots, s+\\ell-1$。对于长度为 $\\ell$ 的 $I$ 操作，在读段中前进，但在参考序列中不前进；不贡献覆盖度。对于长度为 $\\ell$ 的 $D$ 操作，在参考序列中前进 $\\ell$；不贡献覆盖度。对于长度为 $\\ell$ 的 $S$ 操作，在读段中前进，但在参考序列中不前进；不贡献覆盖度。提供的碱基质量仅按顺序对应于 $M$ 操作消耗的碱基。\n- 将计数限制在指定长度为 $L$ 的区域内的位置，即 $\\{1,2,\\dots,L\\}$ 中的位置。\n\n测试套件：\n对于每个测试用例 $i \\in \\{1,2,3\\}$，计算三个输出：\n- $S^{(i)}_{\\mathrm{U}}$: 在策略 $\\mathrm{U}$ 下，区域中所有位置的深度总和。\n- $S^{(i)}_{\\mathrm{F}}$: 在策略 $\\mathrm{F}$ 下（$m_{\\min} = 20$），区域中所有位置的深度总和。\n- $S^{(i)}_{\\mathrm{C}}$: 在策略 $\\mathrm{C}$ 下（$m_{\\min} = 20$ 且 $q_{\\min} = 20$），区域中所有位置的深度总和。\n\n读段的数据模型：\n每个读段由一个元组指定：$(\\text{read\\_id}, \\text{fragment\\_id}, s, \\text{CIGAR}, \\mathrm{MAPQ}, \\text{flags}, \\text{base\\_qualities})$，其中 $s$ 是比对起始坐标，$\\mathrm{MAPQ}$ 是一个整数，$\\text{flags}$ 是整数位掩码，$\\text{base\\_qualities}$ 是一个列表，其长度等于 CIGAR 字符串中总的 $M$ 长度。\n\n测试用例 1 (区域长度 $L = 20$):\n- $m_{\\min} = 20$, $q_{\\min} = 20$.\n- 读段:\n  - $(\\text{\"A1\"}, \\text{\"A\"}, 5, \\text{\"10M\"}, 60, 0x3, [30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"A2\"}, \\text{\"A\"}, 10, \\text{\"10M\"}, 60, 0x3, [30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"B\"}, \\text{\"B\"}, 8, \\text{\"10M\"}, 60, 0x400, [30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"C\"}, \\text{\"C\"}, 1, \\text{\"5M\"}, 60, 0x100, [30,30,30,30,30])$.\n  - $(\\text{\"D\"}, \\text{\"D\"}, 15, \\text{\"5M\"}, 60, 0x800, [30,30,30,30,30])$.\n  - $(\\text{\"E\"}, \\text{\"E\"}, 12, \\text{\"5M\"}, 60, 0x200, [30,30,30,30,30])$.\n  - $(\\text{\"F\"}, \\text{\"F\"}, 6, \\text{\"5M\"}, 10, 0x0, [30,30,30,30,30])$.\n  - $(\\text{\"G\"}, \\text{\"G\"}, 9, \\text{\"5M\"}, 60, 0x0, [30,30,10,30,30])$.\n  - $(\\text{\"H\"}, \\text{\"H\"}, 13, \\text{\"2M1D3M\"}, 60, 0x0, [30,30,30,30,30])$.\n  - $(\\text{\"I\"}, \\text{\"I\"}, 1, \\text{\"2S8M\"}, 60, 0x0, [30,30,30,30,30,30,30,30])$.\n\n测试用例 2 (区域长度 $L = 10$):\n- $m_{\\min} = 20$, $q_{\\min} = 20$.\n- 读段:\n  - $(\\text{\"J1\"}, \\text{\"J\"}, 1, \\text{\"5M\"}, 60, 0x3, [30,30,30,30,30])$.\n  - $(\\text{\"J2\"}, \\text{\"J\"}, 4, \\text{\"5M\"}, 60, 0x3, [30,30,30,30,30])$.\n  - $(\\text{\"K\"}, \\text{\"K\"}, 2, \\text{\"2M2I3M\"}, 60, 0x0, [30,30,30,30,30])$.\n  - $(\\text{\"L\"}, \\text{\"L\"}, 3, \\text{\"3M2D3M\"}, 60, 0x0, [30,30,30,30,30,30])$.\n  - $(\\text{\"M\"}, \\text{\"M\"}, 1, \\text{\"10M\"}, 60, 0x400, [30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"N\"}, \\text{\"N\"}, 5, \\text{\"5M\"}, 60, 0x100, [30,30,30,30,30])$.\n  - $(\\text{\"O\"}, \\text{\"O\"}, 7, \\text{\"3M\"}, 0, 0x0, [30,30,30])$.\n  - $(\\text{\"P\"}, \\text{\"P\"}, 5, \\text{\"5M\"}, 60, 0x0, [30,30,30,10,30])$.\n\n测试用例 3 (区域长度 $L = 30$):\n- $m_{\\min} = 20$, $q_{\\min} = 20$.\n- 读段:\n  - $(\\text{\"Q1\"}, \\text{\"Q\"}, 5, \\text{\"20M\"}, 60, 0x3, [30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"Q2\"}, \\text{\"Q\"}, 10, \\text{\"20M\"}, 60, 0x3, [30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"R\"}, \\text{\"R\"}, 15, \\text{\"10M\"}, 60, 0x400, [30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"S\"}, \\text{\"S\"}, 20, \\text{\"10M\"}, 60, 0x800, [30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"T\"}, \\text{\"T\"}, 8, \\text{\"10M\"}, 60, 0x200, [30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"U\"}, \\text{\"U\"}, 18, \\text{\"10M\"}, 60, 0x100, [30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"V\"}, \\text{\"V\"}, 12, \\text{\"15M\"}, 15, 0x0, [30,30,30,30,30,30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"W1\"}, \\text{\"W\"}, 7, \\text{\"10M\"}, 60, 0x3, [30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"W2\"}, \\text{\"W\"}, 12, \\text{\"10M\"}, 10, 0x3, [30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"X\"}, \\text{\"X\"}, 9, \\text{\"10M\"}, 60, 0x0, [30,30,30,30,10,30,30,30,30,30])$.\n  - $(\\text{\"Y\"}, \\text{\"Y\"}, 10, \\text{\"5M1D5M\"}, 60, 0x0, [30,30,30,30,30,30,30,30,30,30])$.\n  - $(\\text{\"Z\"}, \\text{\"Z\"}, 14, \\text{\"3M2I7M\"}, 60, 0x0, [30,30,30,30,30,30,30,30,30,30])$.\n\n要求的输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表包含 9 个结果，顺序如下\n$[S^{(1)}_{\\mathrm{U}}, S^{(1)}_{\\mathrm{F}}, S^{(1)}_{\\mathrm{C}}, S^{(2)}_{\\mathrm{U}}, S^{(2)}_{\\mathrm{F}}, S^{(2)}_{\\mathrm{C}}, S^{(3)}_{\\mathrm{U}}, S^{(3)}_{\\mathrm{F}}, S^{(3)}_{\\mathrm{C}}]$。\n\n不允许外部输入。所有计算必须源自提供的基本定义和指定的数据集。所有答案都是整数（每种策略下区域内各位置深度的总和）。",
            "solution": "该解决方案通过从覆盖度和比对语义的基本定义推导出一个基于原则的算法，然后实现三种不同的计数策略来展开。其核心科学概念是：深度是受比对有效性、映射置信度、碱基水平置信度和片段身份约束的测序证据的位置计数。\n\n步骤 $1$：CIGAR 解释和位置覆盖度。\n- 从一个由起始坐标 $s$、CIGAR 字符串和仅附加到 $M$ 操作的碱基质量所描述的比对开始。\n- 维护一个初始化为 $s$ 的参考指针 $r$ 和一个初始化为 $0$ 的碱基质量列表索引 $i$。\n- 按顺序处理每个 CIGAR 操作 $(\\text{op}, \\ell)$：\n  - 如果 $\\text{op} = M$，则对于从 $0$ 到 $\\ell-1$ 的每个 $k$：位置 $p = r + k$ 被此比对覆盖。关联碱基质量 $Q[p] = \\text{base\\_qualities}[i + k]$。处理完后，递增 $r \\leftarrow r + \\ell$ 和 $i \\leftarrow i + \\ell$。\n  - 如果 $\\text{op} = I$，则在读段中前进 $\\ell$ 而不改变参考位置：覆盖度不改变，且 $i$ 不前进，因为这里的碱基质量仅为 $M$ 操作定义。\n  - 如果 $\\text{op} = D$，则在参考序列中前进 $\\ell$：$r \\leftarrow r + \\ell$，在那些被删除的位置上不贡献覆盖度。\n  - 如果 $\\text{op} = S$，则在读段中前进 $\\ell$ 而不改变 $r$：覆盖度不改变，且 $i$ 不前进，因为软剪切的碱基未被比对。\n- 将覆盖位置限制在区域边界 $1 \\leq p \\leq L$ 内。\n\n步骤 $2$：比对级别过滤器。\n- 一个比对被认为是合格的，当且仅当它没有设置任何被排除的标志，并且满足映射质量阈值。被排除的标志是未映射 ($0x4$)、次要 ($0x100$)、补充 ($0x800$)、重复 ($0x400$) 和供应商质控失败 ($0x200$)。形式上，一个标志位掩码为 $f$ 的比对，如果 `(f  (0x4 | 0x100 | 0x800 | 0x400 | 0x200)) = 0` 且 $\\mathrm{MAPQ} \\ge m_{\\min}$，则为合格。\n\n步骤 $3$：碱基级别过滤器。\n- 在由 $M$ 操作贡献的每个被覆盖位置 $p$，碱基质量 $Q[p]$ 是可用的。如果在 $p$ 处的碱基水平贡献满足 $Q[p] \\ge q_{\\min}$，则认为其是合格的。\n\n步骤 $4$：计数策略。\n- 策略 $\\mathrm{U}$：对于每个比对，对于步骤 $1$ 中每个被覆盖的位置 $p$，将深度 $\\mathrm{depth}_{\\mathrm{U}}[p] \\leftarrow \\mathrm{depth}_{\\mathrm{U}}[p] + 1$，不使用任何过滤器。重叠的配对读段独立贡献，因此在两个配对读段都重叠的位置，片段可以贡献 $2$。\n- 策略 $\\mathrm{F}$：对于每个通过步骤 $2$ 的合格比对，对于步骤 $1$ 中每个被覆盖的位置 $p$，递增 $\\mathrm{depth}_{\\mathrm{F}}[p] \\leftarrow \\mathrm{depth}_{\\mathrm{F}}[p] + 1$。不考虑碱基水平质量；如果一个比对合格，其所有被 $M$ 覆盖的位置都贡献计数。\n- 策略 $\\mathrm{C}$：对于每个片段标识 $\\phi$，聚合属于 $\\phi$ 的所有合格比对（步骤 $2$）。在一个位置 $p$，如果片段 $\\phi$ 的至少一个合格比对覆盖了 $p$ 并且该比对在该处的相应碱基质量满足 $Q[p] \\ge q_{\\min}$，则该片段 $\\phi$ 贡献计数。形式上，定义集合 $P_{\\phi} = \\{p : \\exists \\text{ 属于 } \\phi \\text{ 的比对 } a \\text{ 使得 } a \\text{ 合格并以 } Q[p] \\ge q_{\\min} \\text{ 覆盖 } p\\}$。然后，每个位置每个片段递增一次片段级深度：对于每个 $p \\in P_{\\phi}$，设置 $\\mathrm{depth}_{\\mathrm{C}}[p] \\leftarrow \\mathrm{depth}_{\\mathrm{C}}[p] + 1$。此并集规则确保如果两个配对读段都覆盖了位置 $p$，该片段对 $\\mathrm{depth}_{\\mathrm{C}}[p]$ 的贡献仍然最多为 $1$。\n\n步骤 $5$：区域总和输出。\n- 对于每个策略 $\\in \\{\\mathrm{U}, \\mathrm{F}, \\mathrm{C}\\}$ 和每个测试用例 $i$，计算总和 $S^{(i)}_{\\mathrm{policy}} = \\sum_{p=1}^{L} \\mathrm{depth}_{\\mathrm{policy}}[p]$。这些总和是整数。\n\n步骤 $6$：通过标志和过滤器调和差异。\n- $\\mathrm{U}$ 和 $\\mathrm{F}$ 之间的差异源于在 $\\mathrm{F}$ 中对次要、补充、重复、供应商质控失败和低映射质量的比对进行了比对级别的排除。在 $\\mathrm{U}$ 和 $\\mathrm{F}$ 中，被两个配对读段重叠的位置都被双重计数。\n- $\\mathrm{F}$ 和 $\\mathrm{C}$ 之间的差异源于每个位置的碱基质量过滤和片段级别的并集计数。低碱基质量的位点会使 $\\mathrm{C}$ 的计数相较于 $\\mathrm{F}$ 减少。重叠的配对读段在 $\\mathrm{F}$ 中贡献两次，但在 $\\mathrm{C}$ 中最多贡献一次。\n- 删除 ($D$) 会在所有策略中减少该比对在那些位置的覆盖度；插入 ($I$) 从不贡献覆盖度；软剪切 ($S$) 从不贡献覆盖度。因此，CIGAR 结构独立于过滤器来调节深度。\n\n实现说明：\n- CIGAR 字符串可以扫描数字和操作字母来解析成 $(\\text{op}, \\ell)$ 标记。\n- 在比对级别构建覆盖图：一个从位置 $p$ 到 $M$ 操作的碱基质量 $Q[p]$ 的字典，限制在 $1 \\leq p \\leq L$。\n- 根据步骤 $2$–$4$ 应用过滤器并跨比对和片段进行组合。\n- 最后，按规定顺序生成单行输出：$[S^{(1)}_{\\mathrm{U}}, S^{(1)}_{\\mathrm{F}}, S^{(1)}_{\\mathrm{C}}, S^{(2)}_{\\mathrm{U}}, S^{(2)}_{\\mathrm{F}}, S^{(2)}_{\\mathrm{C}}, S^{(3)}_{\\mathrm{U}}, S^{(3)}_{\\mathrm{F}}, S^{(3)}_{\\mathrm{C}}]$。\n\n此方法基于 SAM/BAM 的基本语义、CIGAR 的解释以及广泛使用的映射和碱基质量概念。它通过明确过滤器和计数规则，为深度差异提供了一个基于原则的调和方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Define SAM flag constants for readability\nFLAG_PAIRED = 0x1\nFLAG_PROPER_PAIR = 0x2\nFLAG_UNMAP = 0x4\nFLAG_SECONDARY = 0x100\nFLAG_QCFAIL = 0x200\nFLAG_DUP = 0x400\nFLAG_SUPPL = 0x800\n\nEXCLUDED_FLAGS_MASK = FLAG_UNMAP | FLAG_SECONDARY | FLAG_SUPPL | FLAG_DUP | FLAG_QCFAIL\n\ndef parse_cigar(cigar: str):\n    \"\"\"\n    Parse a CIGAR string into a list of (op, length) tuples.\n    Supports operations: M, I, D, S. Other ops are not used in this dataset.\n    \"\"\"\n    ops = []\n    num = ''\n    for ch in cigar:\n        if ch.isdigit():\n            num += ch\n        else:\n            if num == '':\n                raise ValueError(f\"Invalid CIGAR: missing length before op {ch}\")\n            ops.append((ch, int(num)))\n            num = ''\n    if num != '':\n        raise ValueError(f\"Invalid CIGAR: trailing number {num} without op\")\n    return ops\n\ndef alignment_coverage(start: int, cigar: str, base_quals: list, region_len: int):\n    \"\"\"\n    Compute coverage positions and per-position base qualities for an alignment.\n    Only M operations contribute coverage. I and S consume read only; D consumes reference only.\n    Restrict positions to [1, region_len].\n    Returns: dict {position: base_quality} for positions covered by M.\n    \"\"\"\n    ops = parse_cigar(cigar)\n    ref_pos = start\n    bq_index = 0\n    cov = {}\n    for op, length in ops:\n        if op == 'M':\n            # Consume both ref and read, contribute coverage\n            for k in range(length):\n                p = ref_pos + k\n                if 1 = p = region_len:\n                    if bq_index + k >= len(base_quals):\n                        raise ValueError(\"Base qualities list too short for M operations\")\n                    cov[p] = base_quals[bq_index + k]\n            ref_pos += length\n            bq_index += length\n        elif op == 'I':\n            # Insertion: consume read only; base_quals are defined only for M in our dataset\n            # Advance read (implicitly by advancing bq_index if we tracked read positions),\n            # but base_quals list excludes I, so do nothing here.\n            pass\n        elif op == 'D':\n            # Deletion: consume reference only; no coverage from read\n            ref_pos += length\n        elif op == 'S':\n            # Soft-clip: consume read only; no coverage\n            # base_quals list excludes S, so do nothing here.\n            pass\n        else:\n            raise ValueError(f\"Unsupported CIGAR op: {op}\")\n    # Sanity check: ensure we consumed exactly sum(M) base qualities\n    m_len = sum(length for op, length in ops if op == 'M')\n    if bq_index != m_len:\n        raise ValueError(\"Base qualities length mismatch with total M length\")\n    return cov\n\ndef alignment_passes(flags: int, mapq: int, m_min: int) -> bool:\n    \"\"\"\n    Determine if an alignment passes filters: exclude certain flags and require MAPQ >= m_min.\n    \"\"\"\n    if (flags  EXCLUDED_FLAGS_MASK) != 0:\n        return False\n    if mapq  m_min:\n        return False\n    return True\n\ndef compute_depth_sums(region_len: int, reads: list, m_min: int, q_min: int):\n    \"\"\"\n    Compute summed depths across the region for three policies:\n    U: unfiltered alignment-count\n    F: filtered alignment-count (flags + MAPQ)\n    C: filtered fragment-count with base-quality (flags + MAPQ + per-base Q + fragment union)\n    \"\"\"\n    # Initialize per-position depth arrays\n    depth_U = np.zeros(region_len, dtype=int)\n    depth_F = np.zeros(region_len, dtype=int)\n    depth_C = np.zeros(region_len, dtype=int)\n\n    # Precompute coverage maps for each alignment\n    # Also track passing status per alignment for F and C policies\n    alignments = []\n    for read in reads:\n        read_id, frag_id, start, cigar, mapq, flags, bqs = read\n        cov = alignment_coverage(start, cigar, bqs, region_len)\n        passes = alignment_passes(flags, mapq, m_min)\n        alignments.append({\n            \"read_id\": read_id,\n            \"frag_id\": frag_id,\n            \"cov\": cov,            # dict pos -> baseQ\n            \"mapq\": mapq,\n            \"flags\": flags,\n            \"passes\": passes\n        })\n\n    # Policy U: count all alignments' coverage regardless of filters\n    for aln in alignments:\n        for p in aln[\"cov\"].keys():\n            depth_U[p - 1] += 1\n\n    # Policy F: count only passing alignments (flags + MAPQ), ignore base quality, per alignment\n    for aln in alignments:\n        if aln[\"passes\"]:\n            for p in aln[\"cov\"].keys():\n                depth_F[p - 1] += 1\n\n    # Policy C: fragment-level union across passing alignments with base quality >= q_min\n    # Build fragment -> set of positions covered with baseQ >= q_min by any passing alignment\n    frag_pos = {}\n    for aln in alignments:\n        if not aln[\"passes\"]:\n            continue\n        fid = aln[\"frag_id\"]\n        if fid not in frag_pos:\n            frag_pos[fid] = set()\n        for p, q in aln[\"cov\"].items():\n            if q >= q_min:\n                frag_pos[fid].add(p)\n    # Count once per fragment per position\n    for positions in frag_pos.values():\n        for p in positions:\n            depth_C[p - 1] += 1\n\n    # Compute summed depths across the region for each policy\n    sum_U = int(depth_U.sum())\n    sum_F = int(depth_F.sum())\n    sum_C = int(depth_C.sum())\n    return sum_U, sum_F, sum_C\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test case 1: Region length 20\n    L1 = 20\n    m_min = 20\n    q_min = 20\n    reads1 = [\n        (\"A1\", \"A\", 5, \"10M\", 60, FLAG_PAIRED | FLAG_PROPER_PAIR, [30]*10),\n        (\"A2\", \"A\", 10, \"10M\", 60, FLAG_PAIRED | FLAG_PROPER_PAIR, [30]*10),\n        (\"B\", \"B\", 8, \"10M\", 60, FLAG_DUP, [30]*10),\n        (\"C\", \"C\", 1, \"5M\", 60, FLAG_SECONDARY, [30]*5),\n        (\"D\", \"D\", 15, \"5M\", 60, FLAG_SUPPL, [30]*5),\n        (\"E\", \"E\", 12, \"5M\", 60, FLAG_QCFAIL, [30]*5),\n        (\"F\", \"F\", 6, \"5M\", 10, 0x0, [30]*5),\n        (\"G\", \"G\", 9, \"5M\", 60, 0x0, [30,30,10,30,30]),\n        (\"H\", \"H\", 13, \"2M1D3M\", 60, 0x0, [30,30,30,30,30]),\n        (\"I\", \"I\", 1, \"2S8M\", 60, 0x0, [30]*8),\n    ]\n\n    # Test case 2: Region length 10\n    L2 = 10\n    reads2 = [\n        (\"J1\", \"J\", 1, \"5M\", 60, FLAG_PAIRED | FLAG_PROPER_PAIR, [30]*5),\n        (\"J2\", \"J\", 4, \"5M\", 60, FLAG_PAIRED | FLAG_PROPER_PAIR, [30]*5),\n        (\"K\", \"K\", 2, \"2M2I3M\", 60, 0x0, [30]*5),\n        (\"L\", \"L\", 3, \"3M2D3M\", 60, 0x0, [30]*6),\n        (\"M\", \"M\", 1, \"10M\", 60, FLAG_DUP, [30]*10),\n        (\"N\", \"N\", 5, \"5M\", 60, FLAG_SECONDARY, [30]*5),\n        (\"O\", \"O\", 7, \"3M\", 0, 0x0, [30]*3),\n        (\"P\", \"P\", 5, \"5M\", 60, 0x0, [30,30,30,10,30]),\n    ]\n\n    # Test case 3: Region length 30\n    L3 = 30\n    reads3 = [\n        (\"Q1\", \"Q\", 5, \"20M\", 60, FLAG_PAIRED | FLAG_PROPER_PAIR, [30]*20),\n        (\"Q2\", \"Q\", 10, \"20M\", 60, FLAG_PAIRED | FLAG_PROPER_PAIR, [30]*20),\n        (\"R\", \"R\", 15, \"10M\", 60, FLAG_DUP, [30]*10),\n        (\"S\", \"S\", 20, \"10M\", 60, FLAG_SUPPL, [30]*10),\n        (\"T\", \"T\", 8, \"10M\", 60, FLAG_QCFAIL, [30]*10),\n        (\"U\", \"U\", 18, \"10M\", 60, FLAG_SECONDARY, [30]*10),\n        (\"V\", \"V\", 12, \"15M\", 15, 0x0, [30]*15),\n        (\"W1\", \"W\", 7, \"10M\", 60, FLAG_PAIRED | FLAG_PROPER_PAIR, [30]*10),\n        (\"W2\", \"W\", 12, \"10M\", 10, FLAG_PAIRED | FLAG_PROPER_PAIR, [30]*10),\n        (\"X\", \"X\", 9, \"10M\", 60, 0x0, [30,30,30,30,10,30,30,30,30,30]),\n        (\"Y\", \"Y\", 10, \"5M1D5M\", 60, 0x0, [30]*10),\n        (\"Z\", \"Z\", 14, \"3M2I7M\", 60, 0x0, [30]*10),\n    ]\n\n    results = []\n\n    # Compute for test case 1\n    sum_U1, sum_F1, sum_C1 = compute_depth_sums(L1, reads1, m_min, q_min)\n    results.extend([sum_U1, sum_F1, sum_C1])\n\n    # Compute for test case 2\n    sum_U2, sum_F2, sum_C2 = compute_depth_sums(L2, reads2, m_min, q_min)\n    results.extend([sum_U2, sum_F2, sum_C2])\n\n    # Compute for test case 3\n    sum_U3, sum_F3, sum_C3 = compute_depth_sums(L3, reads3, m_min, q_min)\n    results.extend([sum_U3, sum_F3, sum_C3])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}