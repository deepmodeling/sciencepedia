{
    "hands_on_practices": [
        {
            "introduction": "在将基因组数据整合到电子健康记录（EHR）系统的过程中，首要的挑战是处理来自不同实验室和数据源的原始数据。这些数据源通常采用不同的格式约定，例如，染色体标签（如“1” vs “chr1”）和基因组坐标系统（0-based vs 1-based）可能存在差异。本练习旨在通过一个模拟场景，帮助您掌握如何系统性地定义和应用规范化转换规则来纠正这些不一致性，并量化数据质量的提升，这是构建任何稳健数据整合流程的基石。",
            "id": "4336609",
            "problem": "一个医院级别的电子健康记录（EHR）集成管道从三个外部实验室数据源中提取单核苷酸变异记录，并且必须将每条记录归一化为与基因组参考联盟人类第38版（GRCh38）对齐的规范表示。规范表示使用基于$1$的基因组坐标和染色体标签 $\\{\\text{chr}1,\\dots,\\text{chr}22,\\text{chrX},\\text{chrY},\\text{chrM}\\}$。在归一化之前，观察到两种规范化失败的来源：坐标基准不匹配（基于零与基于一）和染色体标签不一致。假设为单核苷酸变异，并且所有记录均引用GRCh38。\n\n使用错误率的频率解释，即失败次数占总记录数的分数。也就是说，如果 $E$ 是规范化失败的总次数，$N$ 是提取的总记录数，则错误率为 $e = \\frac{E}{N}$。\n\n三个数据源具有以下特征和归一化前的失败计数：\n\n- 数据源 $A$：$N_A = 6 \\times 10^{5}$ 条记录，报告为基于零的坐标和来自 $\\{1,\\dots,22,\\text{X},\\text{Y},\\text{MT}\\}$ 的标签。诊断将 $C_A = 6.6 \\times 10^{4}$ 次失败归因于坐标基准不匹配（在常染色体上评估，其中标签解析在此检查中成功），将 $L_A = 4.2 \\times 10^{4}$ 次失败归因于标签解析不匹配（在性染色体和线粒体染色体上评估，其中未运行基准不匹配诊断）。将 $C_A$ 和 $L_A$ 视为不相交，因此数据源 $A$ 的归一化前规范化失败次数为 $E_A^{\\text{pre}} = C_A + L_A$。\n- 数据源 $B$：$N_B = 8 \\times 10^{5}$ 条记录，报告为基于一的坐标和规范的 $\\text{chr}$-前缀标签。数据源 $B$ 的归一化前规范化失败次数为 $E_B^{\\text{pre}} = 0$。\n- 数据源 $C$：$N_C = 7 \\times 10^{5}$ 条记录，报告为基于一的坐标和来自 $\\{1,\\dots,25\\}$ 的标签，其中 $\\{23,24,25\\}$ 分别表示 $\\{\\text{X},\\text{Y},\\text{MT}\\}$。诊断识别出 $L_C = 3.5 \\times 10^{4}$ 次标签解析不匹配和 $Q_C = 2.8 \\times 10^{3}$ 次位置字段解析失败（非整数或超出范围的值）。将 $L_C$ 和 $Q_C$ 视为不相交，因此 $E_C^{\\text{pre}} = L_C + Q_C$。\n\n您必须指定将任何数据源的记录映射到规范表示的归一化转换。形式上定义：\n\n- 一个位置归一化函数 $f_{\\text{pos}}(p,b)$，其中 $p$ 是报告的位置，$b \\in \\{0,1\\}$ 编码报告的坐标基准，该函数返回 GRCh38 上的一个规范的基于一的位置。\n- 一个染色体标签归一化函数 $f_{\\text{chr}}(\\ell)$，它将任何数据源提供的标签映射到 $\\{\\text{chr}1,\\dots,\\text{chr}22,\\text{chrX},\\text{chrY},\\text{chrM}\\}$ 中的一个。\n\n应用这些转换后，观察到的残余失败如下：\n\n- 对于数据源 $A$：在 $C_A$ 次坐标基准失败中，$99.5\\%$ 被纠正；残余的坐标基准失败为 $R_{A,C} = 3.3 \\times 10^{2}$。所有标签不匹配 $L_A$ 都被纠正，因此 $R_{A,L} = 0$。\n- 对于数据源 $B$：没有引入或纠正规范化失败，因此 $R_B = 0$。\n- 对于数据源 $C$：在 $L_C$ 次标签不匹配中，$98\\%$ 被纠正；残余的标签失败为 $R_{C,L} = 7.0 \\times 10^{2}$。位置字段解析失败 $Q_C$ 仍未被纠正，因此 $R_{C,Q} = 2.8 \\times 10^{3}$。\n\n令 $N_{\\text{tot}} = N_A + N_B + N_C$ 表示所有数据源的总记录数。使用错误率的基本定义 $e = \\frac{E}{N}$ 和指定的转换，计算所有数据源的归一化后规范化错误率 $e^{\\text{post}}$，以小数形式表示并四舍五入到四位有效数字。清晰地陈述您使用的归一化转换，然后从第一性原理推导 $e^{\\text{post}}$。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在生物信息学和基因组数据处理领域有科学依据，定量上是适定的，内部一致且客观。所有必要的数据都已提供，没有矛盾之处。该问题要求定义归一化函数并计算归一化后的错误率，这是数据质量评估中的标准程序。\n\n任务是计算从三个数据源聚合的基因组数据的归一化后规范化错误率 $e^{\\text{post}}$。这需要定义归一化转换，计算总记录数，计算归一化后的残余错误总数，然后计算它们的比率。\n\n首先，我们按照规定定义先验的归一化转换。\n\n规范表示需要基于$1$的基因组坐标。对于报告基于$0$的坐标的数据源，需要进行转换。\n设 $p$ 为报告的位置，$b \\in \\{0, 1\\}$ 为坐标基准的指示符，其中 $b=0$ 表示基于零，$b=1$ 表示基于一。位置归一化函数 $f_{\\text{pos}}(p, b)$ 将输入映射到规范的基于$1$的位置。基于零的坐标通过加 $1$ 转换为基于一的坐标。基于一的坐标无需更改。\n因此，该函数定义为：\n$$\nf_{\\text{pos}}(p, b) = p + (1 - b)\n$$\n等价地，以分段形式表示：\n$$\nf_{\\text{pos}}(p, b) = \\begin{cases} p+1  \\text{if } b=0 \\text{ (zero-based)} \\\\ p  \\text{if } b=1 \\text{ (one-based)} \\end{cases}\n$$\n此函数将应用于数据源 $A$ 的记录，它们是基于零的。数据源 $B$ 和 $C$ 是基于一的，因此对于它们，位置保持不变。\n\n规范表示需要来自集合 $\\{\\text{chr}1,\\dots,\\text{chr}22,\\text{chrX},\\text{chrY},\\text{chrM}\\}$ 的染色体标签。对于使用不同标签格式的数据源，需要进行转换。\n设 $\\ell$ 为报告的染色体标签。染色体标签归一化函数 $f_{\\text{chr}}(\\ell)$ 必须将所有数据源的标签映射到规范集。这些数据源提供以下格式的标签：\n- 数据源 $A$：$\\{1, \\dots, 22, \\text{X}, \\text{Y}, \\text{MT}\\}$\n- 数据源 $B$：$\\{\\text{chr}1, \\dots, \\text{chr}22, \\text{chrX}, \\text{chrY}, \\text{chrM}\\}$（已经是规范格式）\n- 数据源 $C$：$\\{1, \\dots, 25\\}$，其映射关系为 $\\{23 \\to \\text{X}, 24 \\to \\text{Y}, 25 \\to \\text{MT}\\}$，然后必须将其映射为规范格式。\n\n一个涵盖所有情况的综合函数定义如下，其中 $\\oplus$ 表示字符串拼接：\n$$\nf_{\\text{chr}}(\\ell) = \\begin{cases} \\text{'chr'} \\oplus \\text{string}(\\ell)  \\text{if } \\ell \\in \\{1, 2, \\dots, 22\\} \\\\ \\text{'chrX'}  \\text{if } \\ell \\in \\{\\text{'X'}, 23\\} \\\\ \\text{'chrY'}  \\text{if } \\ell \\in \\{\\text{'Y'}, 24\\} \\\\ \\text{'chrM'}  \\text{if } \\ell \\in \\{\\text{'MT'}, 25\\} \\\\ \\ell  \\text{if } \\ell \\text{ is already in the canonical set} \\end{cases}\n$$\n该函数处理所有三个数据源的标签格式。\n\n接下来，我们计算提取的总记录数 $N_{\\text{tot}}$。\n已知：\n- 数据源 $A$ 的记录数：$N_A = 6 \\times 10^{5}$\n- 数据源 $B$ 的记录数：$N_B = 8 \\times 10^{5}$\n- 数据源 $C$ 的记录数：$N_C = 7 \\times 10^{5}$\n\n总记录数是它们的和：\n$$\nN_{\\text{tot}} = N_A + N_B + N_C = (6 \\times 10^{5}) + (8 \\times 10^{5}) + (7 \\times 10^{5}) = (6+8+7) \\times 10^{5} = 21 \\times 10^{5} = 2.1 \\times 10^{6}\n$$\n\n现在，我们计算归一化后规范化失败的总数 $E_{\\text{tot}}^{\\text{post}}$。这是应用归一化转换后每个数据源的后验残余失败的总和。\n$$\nE_{\\text{tot}}^{\\text{post}} = E_A^{\\text{post}} + E_B^{\\text{post}} + E_C^{\\text{post}}\n$$\n\n对于数据源 $A$，归一化后的失败次数 $E_A^{\\text{post}}$ 是残余坐标和标签失败的总和。\n- 残余坐标基准失败：$R_{A,C} = 3.3 \\times 10^{2} = 330$。这与初始计数 $C_A = 6.6 \\times 10^4$ 和 $99.5\\%$ 的纠正率一致，因为 $(1 - 0.995) \\times 6.6 \\times 10^4 = 0.005 \\times 66000 = 330$。\n- 残余标签失败：$R_{A,L} = 0$，因为所有初始标签不匹配 $L_A$ 都被纠正。\n因此，数据源 $A$ 的归一化后总失败次数为：\n$$\nE_A^{\\text{post}} = R_{A,C} + R_{A,L} = 330 + 0 = 330\n$$\n\n对于数据源 $B$，记录已是规范格式。不应用归一化，也没有引入或纠正失败。\n- 残余失败：$R_B = 0$。\n因此，数据源 $B$ 的归一化后总失败次数为：\n$$\nE_B^{\\text{post}} = 0\n$$\n\n对于数据源 $C$，归一化后的失败次数 $E_C^{\\text{post}}$ 是残余标签和位置字段解析失败的总和。\n- 残余标签失败：$R_{C,L} = 7.0 \\times 10^{2} = 700$。这与初始计数 $L_C = 3.5 \\times 10^4$ 和 $98\\%$ 的纠正率一致，因为 $(1 - 0.98) \\times 3.5 \\times 10^4 = 0.02 \\times 35000 = 700$。\n- 位置字段解析失败 $Q_C$ 未被纠正。这些失败是由于格式错误的数据（非整数或超出范围的位置值），定义的句法归一化函数 $f_{\\text{pos}}$ 无法处理。因此，残余计数等于初始计数：$R_{C,Q} = Q_C = 2.8 \\times 10^{3} = 2800$。\n因此，数据源 $C$ 的归一化后总失败次数为：\n$$\nE_C^{\\text{post}} = R_{C,L} + R_{C,Q} = 700 + 2800 = 3500\n$$\n\n所有数据源的归一化后失败总数为：\n$$\nE_{\\text{tot}}^{\\text{post}} = E_A^{\\text{post}} + E_B^{\\text{post}} + E_C^{\\text{post}} = 330 + 0 + 3500 = 3830\n$$\n\n最后，我们使用基本定义 $e = \\frac{E}{N}$ 计算归一化后规范化错误率 $e^{\\text{post}}$。\n$$\ne^{\\text{post}} = \\frac{E_{\\text{tot}}^{\\text{post}}}{N_{\\text{tot}}} = \\frac{3830}{2.1 \\times 10^{6}}\n$$\n计算小数值：\n$$\ne^{\\text{post}} = \\frac{3830}{2100000} \\approx 0.0018238095238...\n$$\n问题要求结果四舍五入到四位有效数字。前四位有效数字是 $1$、$8$、$2$、$3$。第五位有效数字是 $8$，它 $\\ge 5$，因此我们将第四位数字向上取整。\n$$\ne^{\\text{post}} \\approx 0.001824\n$$\n这是应用归一化管道后的最终聚合错误率。",
            "answer": "$$\n\\boxed{0.001824}\n$$"
        },
        {
            "introduction": "在确保了基础数据格式的一致性之后，下一个关键步骤是将变异信息翻译成临床医生和研究人员普遍理解的标准语言。本练习将引导您完成一个核心的转换任务：将一个变异从机器可读的变异调用格式（VCF）转换为人类基因组变异学会（HGVS）命名法，后者是临床报告和科学文献的标准。通过这个练习，您将深化对基因组坐标和转录本编码序列（CDS）坐标之间映射关系的理解，尤其是在处理位于反义链上的基因时，这是一个常见且容易出错的环节。",
            "id": "4336669",
            "problem": "一个电子健康记录 (EHR) 集成流程必须将变异调用格式 (VCF; Variant Call Format) 记录中的变异描述标准化为人类基因组变异协会 (HGVS; Human Genome Variation Society) 的基因组和编码DNA表达形式。请考虑以下一个基于基因组参考联盟人类第38版 (GRCh38) 的真实场景，其中染色体$7$的参考序列登录号为 NC_000007.14。\n\n一个单核苷酸变异在 VCF 记录中提供，包含以下字段：CHROM、POS、ID、REF、ALT、QUAL、FILTER、INFO、FORMAT 以及一个样本的基因型。该记录为：\n\nCHROM=7, POS=101115, ID=., REF=C, ALT=T, QUAL=50, FILTER=PASS, INFO=AC=1;AN=2;DP=30, FORMAT=GT:AD:DP:GQ:PL, SAMPLE=0/1:15,15:30:99:0,99,999。\n\n该变异位于一个蛋白质编码基因的 RefSeq 转录本 NM_999999.1 内，该转录本在负链（反义链）上。转录本结构（所有坐标均为基因组坐标，包含边界，且方向为$5'$到$3'$的参考基因组坐标方向）如下：\n\n- 外显子$1$：$g.[102050, 102200]$\n- 外显子$2$：$g.[101000, 101150]$\n- 外显子$3$：$g.[100000, 100300]$\n\nNM_999999.1 的编码序列 (CDS) 起始于外显子$2$中起始密码子的第一个碱基。起始密码子碱基的基因组位置为 $g.101120$、$g.101121$ 和 $g.101122$，并且第一个编码碱基（ATG密码子的腺嘌呤）对应于 $c.1$，并映射到基因组坐标 $g.101122$，因为该转录本在负链上（编码从较高的基因组坐标向较低的基因组坐标进行）。假设所有提供的坐标相对于 NC_000007.14 都是正确的，并且该变异位于编码区内（而不是非翻译区）。\n\n仅使用以下基本规则：(i) VCF POS 是在参考基因组正链坐标系上报告的，REF 和 ALT 核苷酸也采用正链约定；(ii) HGVS 基因组表达 $g.$ 使用正链方向的参考序列；以及 (iii) HGVS 编码表达 $c.$ 使用转录方向上的转录本序列，并将起始密码子的第一个编码碱基定为 $c.1$。请推导出此变异的 HGVS 基因组和编码DNA表达。然后，为了进行 EHR 字段映射，将 $g.$ 表达中使用的基因组位置数值和 $c.$ 表达中使用的编码位置数值报告为一个双元素行矩阵。\n\n将最终的数值答案表示为一个包含两个整数的行矩阵 $\\begin{pmatrix}x  y\\end{pmatrix}$，其中 $x$ 是 HGVS $g.$ 表达中使用的基因组坐标，$y$ 是 HGVS $c.$ 表达中使用的编码DNA坐标。无需四舍五入；请报告精确的整数。",
            "solution": "用户请求推导一个遗传变异的基因组和编码DNA坐标，并以适合电子健康记录 (EHR) 集成的格式呈现。该过程始于对问题陈述的严格验证。\n\n### 问题验证\n\n**第1步：提取给定信息**\n\n问题陈述中提供的数据和条件如下：\n-   **参考基因组**：基因组参考联盟人类第38版 (GRCh38)，染色体$7$的参考序列为 NC_000007.14。\n-   **VCF 记录**：\n    -   CHROM = $7$\n    -   POS = $101115$\n    -   REF = C\n    -   ALT = T\n-   **转录本信息**：\n    -   RefSeq ID: NM_999999.1\n    -   链：负链（反义链）\n    -   外显子结构（基因组坐标，包含边界，$5' \\to 3'$ 参考方向）：\n        -   外显子 $1$：$g.[102050, 102200]$\n        -   外显子 $2$：$g.[101000, 101150]$\n        -   外显子 $3$：$g.[100000, 100300]$\n-   **编码序列 (CDS) 信息**：\n    -   CDS 起始于外显子$2$中的起始密码子。\n    -   起始密码子的基因组位置：$g.101120$, $g.101121$, $g.101122$。\n    -   第一个编码碱基 $c.1$ 映射到基因组坐标 $g.101122$。\n-   **假设**：\n    -   所有坐标相对于 NC_000007.14 都是正确的。\n    -   变异位于编码区内。\n-   **推导规则**：\n    -   (i) VCF 的 POS、REF 和 ALT 均基于参考基因组正链。\n    -   (ii) HGVS $g.$ 表达使用正链方向的参考序列。\n    -   (iii) HGVS $c.$ 表达使用转录方向的转录本序列，其中 $c.1$ 位于第一个编码碱基。\n-   **要求输出**：一个包含基因组位置数值 ($g.$) 和编码位置数值 ($c.$) 的双元素行矩阵。\n\n**第2步：使用提取的给定信息进行验证**\n\n根据验证标准评估该问题：\n-   **科学依据**：该问题基于生物信息学和临床基因组学中的标准、公认的惯例，包括 VCF 规范、HGVS 命名法以及参考基因组上的基因模型概念。该场景是基因组数据分析中的一个现实且基础的任务。此标准已满足。\n-   **定义明确**：该问题提供了所有必要的数据（VCF 记录、转录本结构、链、CDS 起始映射）和一套清晰的规则，以推导出唯一的数值答案。问题具体且无歧义。此标准已满足。\n-   **客观性**：该问题使用精确的技术语言（例如，“GRCh38”、“VCF”、“HGVS”、“负链”），不含主观或基于观点的陈述。此标准已满足。\n-   **一致性检查**：变异位于基因组位置 $g.101115$。该位置落在外显子$2$的边界 $g.[101000, 101150]$ 内。CDS 起始于 $g.101122$，并由于基因位于负链上而朝向较低的基因组坐标进行。由于 $101115  101122$，变异位置与它位于编码区内的陈述一致。数据是自洽的，没有矛盾。\n\n**第3步：结论与行动**\n\n该问题科学合理、定义明确、客观且内部一致。因此，它被判定为**有效**。现在开始推导解决方案。\n\n### 解决方案推导\n\n任务是找到用于 HGVS $g.$ 表达的基因组位置数值和用于 HGVS $c.$ 表达的编码位置数值。\n\n**1. 基因组坐标 ($g.$) 的推导**\n\nHGVS 基因组 ($g.$) 命名法是相对于参考基因组序列来描述变异的。根据规则(ii)，这使用的是参考染色体的正链方向。规则(i) 指出 VCF 的 `POS` 字段也是在参考基因组的正链、1-based 坐标系上报告的。\n\nVCF 记录提供：\n-   `CHROM` = $7$\n-   `POS` = $101115$\n-   `REF` = C\n-   `ALT` = T\n\n因此，基因组位置直接由 VCF 记录中的 `POS` 字段给出。这个单核苷酸替换的完整 HGVS 基因组表达将是 `NC_000007.14:g.101115C>T`。\n\n最终答案所需的基因组位置数值 $x$ 是 $101115$。\n\n**2. 编码DNA坐标 ($c.$) 的推导**\n\nHGVS 编码DNA ($c.$) 命名法是相对于转录本的编码序列来描述变异的。规则(iii) 规定，$c.$ 坐标是从翻译起始（起始）密码子的第一个碱基 ($c.1$) 开始，沿转录方向计数的。\n\n此推导的关键信息：\n-   转录本位于**负链**上。这意味着转录从较高的基因组坐标向较低的基因组坐标进行。因此，随着 $g.$ 坐标编号的减少，$c.$ 坐标编号会增加。\n-   给定的参考点映射为：$c.1$ 对应于基因组位置 $g.101122$。我们将其表示为 $g_{c.1} = 101122$。\n-   变异的基因组位置是 $g_{var} = 101115$。\n\n要找到变异的编码位置 $c_{var}$，我们需要计算它与 CDS 起始点的距离。沿基因组的碱基距离是其基因组坐标的差值。由于基因在负链上，位于基因组位置 $g_{var}  g_{c.1}$ 的变异将在转录本中位于起始密码子的“下游”。\n\n$c_{var}$ 的位置可以如下计算：\n从 $g_{c.1}$ 到 $g_{var}$ 沿转录方向的碱基数由它们的基因组坐标差值给出。\n$$ \\text{距离} = g_{c.1} - g_{var} $$\n$$ \\text{距离} = 101122 - 101115 = 7 $$\n该变异距离第一个编码碱基沿转录方向有 $7$ 个碱基。因此，它在 $c.$ 坐标系中的位置是：\n$$ c_{var} = 1 + \\text{距离} $$\n$$ c_{var} = 1 + 7 = 8 $$\n最终答案所需的编码位置数值 $y$ 是 $8$。\n\n为求完整性，我们可以确定完整的 $c.$ 表达。由于转录本在负链上，转录本上的等位基因是参考基因组正链上等位基因的反向互补序列。\n-   VCF `REF`（正链）：`C`。其反向互补序列是 `G`。\n-   VCF `ALT`（正链）：`T`。其反向互补序列是 `A`。\n因此，该变异是转录本上的一个 `G` 到 `A` 的替换。完整的 HGVS 编码DNA表达将是 `NM_999999.1:c.8G>A`。\n\n**3. 最终答案的构建**\n\n问题要求一个双元素行矩阵 $\\begin{pmatrix}x  y\\end{pmatrix}$，其中 $x$ 是基因组位置数值，$y$ 是编码位置数值。\n-   基因组位置, $x = 101115$。\n-   编码DNA位置, $y = 8$。\n\n得到的矩阵是 $\\begin{pmatrix}101115  8\\end{pmatrix}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix}101115  8\\end{pmatrix}}\n$$"
        },
        {
            "introduction": "随着时间的推移，基因组数据通常是基于不同版本的人类参考基因组序列产生的。为了将这些宝贵的历史数据整合到使用最新参考基因组（如 GRCh38）的现代 EHR 系统中，必须将旧版本（如 GRCh37）中的变异坐标进行“转换”（Liftover）。本实践是一个动手编码练习，您将实现一个简化的 Liftover 算法。这个过程不仅能帮助您理解跨基因组版本进行坐标转换的核心逻辑，还能让您学会如何处理变异在转换过程中可能出现的映射丢失或模糊不清等关键问题。",
            "id": "4336648",
            "problem": "电子健康记录 (EHR) 系统越来越多地将临床变异存储在规范参考基因组构建版本中，以驱动可互操作的临床决策支持。当临床变异是根据 Genome Reference Consortium 人类基因组构建版本 37 (GRCh37) 生成，但 EHR 系统在 Genome Reference Consortium 人类基因组构建版本 38 (GRCh38) 上运行时，就需要进行坐标转换（“liftover”）。在一个简化的、算法上精确且符合成熟基因组组装比对原则的模型中，一次 liftover 操作由一组比对“链”（chains）定义，每条链由两个组装版本之间的一个或多个完美匹配的区块组成。每个区块指定了源组装上的一个连续区间及其在目标组装上对应的连续区间，可能在反向互补链上。基本事实和定义如下：\n- 一个链由一个源染色体整数 $c_s$、一个目标染色体整数 $c_t$、一个链方向 $\\sigma \\in \\{+1,-1\\}$ 和一个有限的比对区块列表 $B = \\{(s_i, t_i, \\ell_i)\\}_{i=1}^n$ 组成。每个区块 $(s_i, t_i, \\ell_i)$ 将源上的半开区间 $[s_i, s_i + \\ell_i)$ 映射到目标上的区间 $[t_i, t_i + \\ell_i)$。所有坐标都是以碱基对为单位的 0-基整数。\n- 位于染色体 $c$ 上源坐标 $x$ 处的单核苷酸变异，当且仅当 $s_i \\le x  s_i + \\ell_i$ 且 $c = c_s$ 时，称其被一个区块 $(s_i, t_i, \\ell_i)$ 覆盖。\n- 如果被覆盖且 $\\sigma = +1$，则映射的目标坐标为 $y = t_i + (x - s_i)$，位于染色体 $c_t$ 上。\n- 如果被覆盖且 $\\sigma = -1$，则映射的目标坐标为 $y = t_i + \\left(\\ell_i - 1 - (x - s_i)\\right)$，位于染色体 $c_t$ 上。\n- 当且仅当所有链的所有区块只产生一个唯一的目标元组 $(c_t, y)$ 时，一个变异具有唯一的 liftover。如果没有区块覆盖 $x$，则映射为缺失（missing）。如果产生多个不同的目标元组，则映射为模糊（ambiguous）。\n\n您的任务是实现一个程序，为每个提供的测试用例执行以下操作：\n- 通过将上述定义应用于提供的链集，为所有 GRCh37 变异计算 GRCh38 目标坐标 $(c_t, y)$。\n- 将每个变异分类为唯一转换（uniquely lifted）、缺失（missing）或模糊（ambiguous）。\n- 为每个测试用例返回因模糊或缺失映射而导致 liftover 失败的变异比例（以小数形式），定义为 $f = \\dfrac{N_{\\text{fail}}}{N_{\\text{total}}}$，其中 $N_{\\text{fail}}$ 是映射缺失或模糊的变异数量，$N_{\\text{total}}$ 是该测试用例中的总变异数量。\n\n假设和约定：\n- 所有染色体均由正整数表示（例如，1 代表 1 号染色体）。\n- 所有坐标都是以碱基对为单位计数的 0-基整数。\n- 输入链方向 $\\sigma$ 使用 $+1$ 表示正向，$-1$ 表示反向。\n- 一个变异是坐标 $x$ 处的一个单碱基。\n- 映射规则使用半开区间 $[s_i, s_i + \\ell_i)$；坐标 $x = s_i + \\ell_i$ 不被该区块覆盖。\n\n程序内部需实现的测试套件：\n- 测试用例 1（理想情况，全部唯一）：\n  - 链：\n    - 一条链，其参数为 $(c_s = 1, c_t = 1, \\sigma = +1, B = [(10, 100, 10)])$。\n  - 变异（以 $(c, x)$ 对形式表示）：$[(1, 10), (1, 12), (1, 15), (1, 18), (1, 19)]$。\n  - 预期失败率：$0.0$。\n- 测试用例 2（边界与缺失覆盖）：\n  - 链：\n    - 一条链，其参数为 $(c_s = 1, c_t = 1, \\sigma = +1, B = [(10, 100, 10)])$。\n  - 变异：$[(1, 9), (1, 10), (1, 19), (1, 20)]$。坐标 $x = 9$ 和 $x = 20$ 未被覆盖，因为区块是 $[10, 20)$。\n  - 预期失败率：$0.5$。\n- 测试用例 3（模糊性与反向链）：\n  - 链：\n    - 链 A：$(c_s = 2, c_t = 2, \\sigma = +1, B = [(150, 3000, 30)])$。\n    - 链 B：$(c_s = 2, c_t = 2, \\sigma = +1, B = [(160, 4000, 30)])$。\n    - 链 C：$(c_s = 2, c_t = 2, \\sigma = -1, B = [(200, 5000, 10)])$。\n  - 变异：$[(2, 155), (2, 165), (2, 175), (2, 205)]$。坐标为 $x = 165$ 和 $x = 175$ 的变异被链 A 和链 B 同时覆盖，但目标不同，因此是模糊的；$x = 155$ 通过链 A 进行唯一映射；$x = 205$ 通过链 C 进行唯一映射（反向）。\n  - 预期失败率：$0.5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含测试用例 1、2 和 3 的失败率 $f$，每个都格式化为恰好 $6$ 位小数（例如，$[0.000000,0.500000,0.500000]$）。\n- 将每个比例表示为小数，而不是百分比。\n\n该问题是完全自包含的；不要从文件读取或请求用户输入。请完全按照上述规定实现链和变异，并使用所提供的定义计算所需的失败率。",
            "solution": "问题陈述提出了一个明确定义的计算任务，该任务基于一个简化但科学上合理的基因组坐标转换模型，这个过程在生物信息学中被称为“liftover”。该问题经确认为合理、完整且无歧义。它基于成熟的基因组组装比对原则，使用了比对链、匹配区块、染色体坐标和链方向等概念。对于正向（$\\sigma = +1$）和反向（$\\sigma = -1$）链的坐标覆盖和映射的定义是精确的，并且可以用算法形式化。将映射分类为唯一（unique）、缺失（missing）或模糊（ambiguous）的标准是互斥且完备的。因此，该问题是有效的，可以设计出确定的解决方案。\n\n解决方案将通过迭代给定测试用例中提供的每个变异来实现。对于每个变异，我们必须通过对照每个提供的比对链中的每个区块来评估它，以确定所有可能的目标映射。集合（set）数据结构非常适合收集这些映射，因为它会自动只存储唯一的目标元组 $(c_t, y)$。\n\n处理单个变异 $(c, x)$ 的过程如下：\n1. 初始化一个空集合 `mappings`，用于存储找到的不同目标坐标。\n2. 遍历测试用例中定义的每个链。一个链由源染色体 $c_s$、目标染色体 $c_t$、链方向 $\\sigma$ 和一个比对区块列表 $B$ 描述。\n3. 如果变异的染色体 $c$ 与链的源染色体 $c_s$ 不匹配，则整个链都无关紧要，我们继续处理下一个链。\n4. 如果染色体匹配 ($c = c_s$)，则遍历链的列表 $B$ 中的每个区块 $(s_i, t_i, \\ell_i)$。\n5. 对于每个区块，检查变异的源坐标 $x$ 是否被覆盖。根据所述的半开区间规则，条件为 $s_i \\le x  s_i + \\ell_i$。\n6. 如果坐标 $x$ 被该区块覆盖，则根据链的方向 $\\sigma$ 计算目标坐标 $y$：\n   - 如果 $\\sigma = +1$（正向链），位置偏移量保持不变。目标坐标为 $y = t_i + (x - s_i)$。\n   - 如果 $\\sigma = -1$（反向链），位置偏移量在区块内反转。目标坐标为 $y = t_i + (\\ell_i - 1 - (x - s_i))$。\n   产生的目标映射是元组 $(c_t, y)$。此元组被添加到 `mappings` 集合中。\n7. 检查完所有链的所有区块后，`mappings` 集合的大小决定了变异 $(c, x)$ 的 liftover 状态：\n   - 如果集合为空（大小为 $0$），则没有区块覆盖该变异的坐标。映射为**缺失（missing）**。\n   - 如果集合恰好包含一个元素（大小为 $1$），则映射是**唯一（unique）**的。\n   - 如果集合包含多个元素（大小  $1$），则找到了多个冲突的映射。映射是**模糊（ambiguous）**的。\n\n如果一个变异的映射是缺失或模糊的，则认为它在 liftover 过程中失败了。对于每个测试用例，我们将计算变异总数 $N_{\\text{total}}$ 和失败变异数 $N_{\\text{fail}}$。然后计算失败率 $f = \\dfrac{N_{\\text{fail}}}{N_{\\text{total}}}$。此过程将应用于所有三个测试用例，并将所得比例按要求格式化和呈现。\n\n让我们用反向链映射规则来追踪测试用例 3 中位于染色体 $c=2$、坐标 $x=205$ 处的变异。相关的链是链 C：$(c_s = 2, c_t = 2, \\sigma = -1, B = [(200, 5000, 10)])$。区块是 $(s_i, t_i, \\ell_i) = (200, 5000, 10)$。\n源坐标是 $x=205$。\n该变异位于正确的染色体上 ($2=c_s$)，其坐标位于区块的源区间 $[200, 200+10) = [200, 210)$ 内，因为 $200 \\le 205  210$。\n映射在反向链上 ($\\sigma = -1$)。目标坐标 $y$ 的计算如下：\n$$ y = t_i + (\\ell_i - 1 - (x - s_i)) $$\n$$ y = 5000 + (10 - 1 - (205 - 200)) $$\n$$ y = 5000 + (9 - 5) $$\n$$ y = 5004 $$\n由于这是覆盖该坐标的唯一区块，因此唯一映射为 $(c_t, y) = (2, 5004)$。这证实了反向链映射的逻辑被正确应用。算法设计因此根据问题规范得到了验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats # Scipy is specified, importing a submodule for completeness.\n\ndef solve():\n    \"\"\"\n    Solves the liftover problem for the defined test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (happy path, all unique)\n        {\n            \"chains\": [\n                {\n                    \"cs\": 1, \"ct\": 1, \"sigma\": 1,\n                    \"blocks\": [(10, 100, 10)]\n                }\n            ],\n            \"variants\": [(1, 10), (1, 12), (1, 15), (1, 18), (1, 19)]\n        },\n        # Test case 2 (boundary and missing coverage)\n        {\n            \"chains\": [\n                {\n                    \"cs\": 1, \"ct\": 1, \"sigma\": 1,\n                    \"blocks\": [(10, 100, 10)]\n                }\n            ],\n            \"variants\": [(1, 9), (1, 10), (1, 19), (1, 20)]\n        },\n        # Test case 3 (ambiguity and reverse strand)\n        {\n            \"chains\": [\n                {  # Chain A\n                    \"cs\": 2, \"ct\": 2, \"sigma\": 1,\n                    \"blocks\": [(150, 3000, 30)]\n                },\n                {  # Chain B\n                    \"cs\": 2, \"ct\": 2, \"sigma\": 1,\n                    \"blocks\": [(160, 4000, 30)]\n                },\n                {  # Chain C\n                    \"cs\": 2, \"ct\": 2, \"sigma\": -1,\n                    \"blocks\": [(200, 5000, 10)]\n                }\n            ],\n            \"variants\": [(2, 155), (2, 165), (2, 175), (2, 205)]\n        }\n    ]\n\n    failure_fractions = []\n\n    for case in test_cases:\n        chains = case[\"chains\"]\n        variants = case[\"variants\"]\n        n_total = len(variants)\n        n_fail = 0\n\n        for c_var, x_var in variants:\n            found_mappings = set()\n\n            for chain in chains:\n                cs = chain[\"cs\"]\n                ct = chain[\"ct\"]\n                sigma = chain[\"sigma\"]\n                \n                # Skip chain if it's for a different source chromosome\n                if c_var != cs:\n                    continue\n\n                for s_i, t_i, l_i in chain[\"blocks\"]:\n                    # Check if the variant is covered by the block's source interval [s_i, s_i + l_i)\n                    if s_i = x_var  s_i + l_i:\n                        y = 0\n                        # Forward strand mapping\n                        if sigma == 1:\n                            y = t_i + (x_var - s_i)\n                        # Reverse strand mapping\n                        elif sigma == -1:\n                            y = t_i + (l_i - 1 - (x_var - s_i))\n                        \n                        found_mappings.add((ct, y))\n            \n            # Classify the liftover result\n            # A failure is defined as a missing (0 mappings) or ambiguous (1 mapping) result.\n            if len(found_mappings) != 1:\n                n_fail += 1\n\n        if n_total > 0:\n            fraction = n_fail / n_total\n        else:\n            fraction = 0.0\n        \n        failure_fractions.append(f\"{fraction:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(failure_fractions)}]\")\n\nsolve()\n```"
        }
    ]
}