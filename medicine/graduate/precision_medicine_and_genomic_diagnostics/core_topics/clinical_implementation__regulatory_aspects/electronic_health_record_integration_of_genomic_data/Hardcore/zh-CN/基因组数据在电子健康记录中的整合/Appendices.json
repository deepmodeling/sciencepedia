{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在解决变异表示中的一个基本挑战：模糊性。对于重复DNA序列中的插入和缺失（indels），序列比对算法可能会产生多种同样有效的放置方式。该练习要求您从序列比对的基本原理出发，理解这种模糊性产生的原因，并应用标准解决方案——左对齐标准化——来为一个indel推导出唯一的、规范的表示形式。这对于确保任何电子健康记录（EHR）系统中的数据完整性至关重要。",
            "id": "4336681",
            "problem": "电子健康记录 (EHR) 系统越来越多地存储离散的基因组变异以用于临床决策支持 (CDS)。然而，发生在均聚物重复序列或串联重复序列中的短插入和删除 (indels) 可以通过多种得分相同的方式进行比对，如果不对其进行标准化，将导致不同实验室和知识库对同一生物学事件使用非唯一的键。考虑一个基于核苷酸字母表的参考序列 $R$ 和一个患者单倍型 $H$，两者在一个最大均聚物重复序列内部因单个短 indel 而不同。请使用双序列比对的动态规划 (DP) 基本原理，在匹配奖励为 $+m$、错配罚分为 $-u$、以及线性或仿射空位罚分（空位开放为 $-g$，空位延伸为 $-e$，其中 $e \\ge 0$）的条件下，论证为何存在多个等价的最优比对。然后，使用变异调用格式 (VCF) 的最小等位基因规则（修剪共同的前缀和后缀，同时保持参考等位基因长度至少为 $1$）作为标准等位基因最小化步骤，描述一种算法，用于在能从 $R$ 生成 $H$ 的等效表示类中，计算最左侧的等效 indel 表示。最后，将您的推理应用于以下示例，并报告左对齐标准化的 VCF 表示：\n\n- 参考序列: $R = \\text{GAAAAC}$ (索引从 $1$ 到 $6$）。\n- 观察到的单倍型: $H = \\text{GAAAAAC}$ (在 $\\text{AAAA}$ 重复序列中插入一个 $\\text{A}$）。\n- 某个实验室报告的变异为位置 $p = 4$，其中 $\\text{REF} = \\text{A}$ 且 $\\text{ALT} = \\text{AA}$ (即，使用 VCF 左锚定规则，在 $R[4]$ 之后插入一个 $\\text{A}$）。\n\n哪个选项正确地从 DP 比对原理推导了为何需要左对齐标准化来为 EHR 集成获取唯一的标准表示，并且正确地指定了一种计算均聚物中 indel 最左等效表示的算法，从而为该示例生成了正确的标准化 VCF？\n\nA. 在均聚物中，任何置于重复序列内任意位置的单碱基空位，在线性或仿射空位罚分下都会产生相同的 DP 分数，因为在相同字符内的横向移动下，匹配数和空位事件数是不变的。因此，存在多个最优比对，同一个生物学 indel 有多个等价的最优放置位置。为确保 EHR 和 CDS 的唯一键，将变异等效性定义为“从 $R$ 生成相同的单倍型 $H$”，并通过左对齐标准化选择标准代表：首先通过修剪共同的后缀和前缀使等位基因最小化（在 $\\text{REF}$ 中保留至少一个碱基），然后在重复序列上通过反复测试紧邻左侧的碱基来左移。对于位置 $p$ 处长度为 $D$ 的删除，当 $p > 1$ 且 $R[p-1] = R[p+|D|-1]$ 时，将 $p$ 减一并将删除窗口向左滑动一个碱基；对于最小 $\\text{REF} = b$ 和 $\\text{ALT} = bI$ 的插入，当 $p > 1$ 且 $R[p-1] = I[|I|]$ 时，设置 $p \\leftarrow p-1$，通过将其最后一个字符移到前面来旋转 $I$，并更新 $b \\leftarrow R[p]$。在 $\\text{A}$ 的均聚物中，这将移动到重复序列的左边界。将此应用于 $R = \\text{GAAAAC}$ 以及报告的在 $p = 4$ 处插入 $I = \\text{A}$ 的情况，会连续移动到 $p = 3$，然后是 $p = 2$，因为 $R[1] = \\text{G} \\ne \\text{A}$ 而停止。左对齐标准化的 VCF 是位置 $2$，$\\text{REF} = \\text{A}$ 且 $\\text{ALT} = \\text{AA}$。\n\nB. 因为读段的合成和比对方向是 $3'$ 到 $5'$，所以 DP 倾向于将空位放置在均聚物的最右侧；因此右对齐标准化可产生唯一表示。其算法是：在最小等位基因修剪后，对于位置 $p$ 处长度为 $D$ 的删除，当 $p+|D| \\le |R|$ 且 $R[p] = R[p+|D|]$ 时，将 $p$ 加一；对于 $\\text{ALT} = bI$ 的插入，当 $p+1 \\le |R|$ 且 $R[p+1] = I[1]$ 时，将 $p$ 加一。将此应用于该示例会将位置移动到 $p = 5$，得到在位置 $5$ 处的 $\\text{REF} = \\text{A}$ 和 $\\text{ALT} = \\text{AA}$。\n\nC. 使用仿射空位罚分时，DP 会打破平局并即使在均聚物中也能产生唯一的比对，因此左对齐标准化是不必要的。EHR 集成的正确程序是信任比对软件报告的位置，无需进一步调整。对于该示例，原始报告的位置 $p = 4$，$\\text{REF} = \\text{A}$ 和 $\\text{ALT} = \\text{AA}$ 已经是标准的。\n\nD. 左对齐标准化是必要的，但它应定义为在所有等效表示中选择字典序最小的 $(\\text{REF}, \\text{ALT})$ 字符串对，而不管其基因组位置。其算法是枚举均聚物内所有可能的位置，构建每个可能的 $(\\text{REF}, \\text{ALT})$，并选择字典序最小的对。对于该示例，位置 $p = 3$ 处的 $(\\text{REF}, \\text{ALT}) = (\\text{AA}, \\text{AAA})$ 是字典序最小的，因此这是标准化的变异。\n\nE. 均聚物中的多个最优 DP 比对需要一个标准化规则。左对齐标准化的实现方式是：首先只修剪共同的前缀（忽略后缀），然后对于最小 $\\text{REF} = b$ 和 $\\text{ALT} = bI$ 的插入，当 $R[p-1] = R[p]$ 时，将 $p$ 减一；对于长度为 $D$ 的删除，当 $R[p-1] = R[p]$ 时，将 $p$ 减一。将此应用于该示例会得到位置 $2$，其中 $\\text{REF} = \\text{A}$ 和 $\\text{ALT} = \\text{AA}$。",
            "solution": "用户要求对问题陈述进行严格验证，然后基于基本原理推导解决方案并评估所有选项。\n\n### 问题验证\n\n**第 1 步：提取已知信息**\n-   **背景：** 将离散的基因组变异集成到电子健康记录 (EHR) 系统中，用于临床决策支持 (CDS)。\n-   **问题：** 均聚物重复序列或串联重复序列内的短插入和删除 (indels) 可能有多个得分相同的比对，导致同一生物学变异有多种非唯一的表示方法。\n-   **参考序列：** $R = \\text{GAAAAC}$ (索引从 $1$ 到 $6$）。\n-   **观察到的单倍型：** $H = \\text{GAAAAAC}$。这对应于在 $R$ 的 'AAAA' 均聚物重复序列中插入一个核苷酸 'A'。\n-   **比对模型：** 通过动态规划 (DP) 进行双序列比对，匹配奖励为 $+m$，错配罚分为 $-u$，以及线性或仿射空位罚分（空位开放为 $-g$，空位延伸为 $-e$，其中 $e \\ge 0$）。\n-   **标准化规则：** VCF (变异调用格式) 最小等位基因规则，描述为“修剪共同的前缀和后缀，同时保持参考等位基因长度至少为 $1$”，然后进行左对齐标准化步骤。\n-   **实验室报告示例：** 位置 $p = 4$，$\\text{REF} = \\text{A}$，$\\text{ALT} = \\text{AA}$。这表示一个 'A' 的插入，其中位置 $4$ 的参考碱基 ('A') 被替换为 'AA'。\n-   **任务：**\n    1.  从 DP 基本原理出发，解释为什么此类 indel 存在多个等价的最优比对。\n    2.  描述一种计算最左等效 indel 表示（左对齐标准化）的算法。\n    3.  将该推理和算法应用于所提供的示例，并报告标准化的 VCF 表示。\n    4.  选择正确执行这些任务的选项。\n\n**第 2 步：使用提取的已知信息进行验证**\n-   **科学依据：** 该问题在科学上是合理的，并且与生物信息学和临床基因组学高度相关。重复区域中变异表示的模糊性是一个有据可查的挑战。用于序列比对的动态规划、VCF 规范和变异标准化都是该领域的标准概念。\n-   **定义明确：** 该问题定义明确。它提供了清晰的输入（$R$、$H$、一个初始表示），并要求基于一组定义的原则（DP、VCF 规则）得出特定的输出（标准的、左对齐的表示）。预期会有一个唯一的解决方案。\n-   **客观性：** 该问题以精确、客观和技术性的语言陈述。\n-   **一致性检查：** 初始的实验室报告（$p=4, \\text{REF}=\\text{A}, \\text{ALT}=\\text{AA}$）能从参考序列 $R$ 正确生成观察到的单倍型 $H$。\n    -   参考序列 $R$: $\\text{G}_1\\text{A}_2\\text{A}_3\\text{A}_4\\text{A}_5\\text{C}_6$。\n    -   该变异调用将位置 $4$ 处与 $\\text{REF}$ 匹配的子串替换为 $\\text{ALT}$ 字符串。\n    -   结果：$R[1..3] + \\text{ALT} + R[5..6] = (\\text{GAA}) + (\\text{AA}) + (\\text{AC}) = \\text{GAAAAAC}$。这与 $H$ 匹配。\n-   **结论：** 问题陈述有效。它具有科学依据，定义明确，客观且内部一致。\n\n**第 3 步：裁定与行动**\n-   **裁定：** 问题是**有效的**。\n-   **行动：** 继续进行解决方案推导和选项分析。\n\n### 解决方案推导\n\n**1. 多个最优比对的理由**\n\n双序列比对的总分是使用动态规划算法（如 Needleman-Wunsch 或 Smith-Waterman）计算的，它是比对中每一列得分的总和。在一个评分为匹配 $+m$、错配 $-u$ 和空位罚分的方案中，总分 $S$ 取决于匹配数 ($N_{match}$)、错配数 ($N_{mismatch}$) 以及空位的数量和长度。对于仿射空位罚分，长度为 $L$ 的空位成本为 $-(g + (L-1)e)$。对于线性罚分，成本为 $-L \\cdot g$。\n\n考虑将单倍型 $H = \\text{GAAAAAC}$ 与参考序列 $R = \\text{GAAAAC}$ 进行比对。这需要在 $H$ 中引入一个 1 碱基的插入（或在 $R$ 中引入一个 1 碱基的删除）。该 indel 必须发生在 'A' 的均聚物重复序列内。让我们检查该区域内可能的比对（$R' = \\text{AAAA}$，$H' = \\text{AAAAA}$）。\n\n比对 1（在 $R'$ 的第 2 位出现空位）：\n$H': \\text{A A A A A}$\n$R': \\text{A - A A A}$\n\n比对 2（在 $R'$ 的第 3 位出现空位）：\n$H': \\text{A A A A A}$\n$R': \\text{A A - A A}$\n\n...以此类推。在原始的 4 碱基均聚物中，有 4 种这样的可能性。\n\n在这些比对中的每一种，'A'-'A' 匹配的数量是恒定的（4 个匹配），错配的数量是恒定的（0），并且只有一个长度为 1 的空位。对于仿射和线性模型，此空位的得分都是 $-g$（因为 $L=1$）。因为总分 $S = (N_{matches}) \\cdot m - \\text{gap\\_penalty}$ 对于所有这些比对都是相同的，所以 DP 算法会找到多条具有相同最高分数的比对路径。每条路径对应于 indel 的不同放置位置，导致其报告位置的模糊性。为了解决这个问题，必须选择一个标准表示。\n\n**2. 左对齐标准化算法**\n\n为 indel 创建标准表示的标准程序包括两个步骤：\n1.  **等位基因最小化（或修剪）：** 使 VCF 表示 $(p, \\text{REF}, \\text{ALT})$ 尽可能小。这通过以下方式实现：\n    a. 只要两个等位基因都保持非空，就从 $\\text{REF}$ 和 $\\text{ALT}$ 等位基因的末尾重复修剪相同的字符。\n    b. 从 $\\text{REF}$ 和 $\\text{ALT}$ 等位基因的开头重复修剪相同的字符，每删除一个字符就将位置 $p$ 加一。\n    该过程必须确保最终的 $\\text{REF}$ 和 $\\text{ALT}$ 等位基因不为空。如果其中一个变为空，则将紧邻变异之前的参考序列中的一个碱基加到两者的前面。问题将其简化为保持 $\\text{REF}$ 长度至少为 $1$。\n    对于给定的示例，$p=4, \\text{REF}=\\text{A}, \\text{ALT}=\\text{AA}$，该表示已经是最小的，因为 $\\text{REF}$ 的长度为 $1$。\n\n2.  **左移：** 最小化之后，将变异尽可能地向左移动，同时仍然表示完全相同的单倍型变化。如果参考序列中新位置的字符与被移动的字符相同，则可以将 indel向左移动一个位置。对于均聚物内的 indel，这意味着将其移动直到到达均聚物的左边界。\n\n让我们为示例追踪这个过程：\n-   **初始状态：** $p = 4, \\text{REF} = \\text{A}, \\text{ALT} = \\text{AA}$。这是该变化的有效表示。$R = \\text{GAAAAC}$。\n-   **等效表示：** 同一个生物学事件可以通过在均聚物重复序列内移动 'A' 插入的位置来表示。\n    -   $p = 5, \\text{REF}=\\text{A}, \\text{ALT}=\\text{AA}$ 产生 $R[1..4] + \\text{ALT} + R[6..] = \\text{GAAA} + \\text{AA} + \\text{C} = \\text{GAAAAAC}$。有效。\n    -   $p = 3, \\text{REF}=\\text{A}, \\text{ALT}=\\text{AA}$ 产生 $R[1..2] + \\text{ALT} + R[4..] = \\text{GA} + \\text{AA} + \\text{AAC} = \\text{GAAAAAC}$。有效。\n    -   $p = 2, \\text{REF}=\\text{A}, \\text{ALT}=\\text{AA}$ 产生 $R[1..1] + \\text{ALT} + R[3..] = \\text{G} + \\text{AA} + \\text{AAAC} = \\text{GAAAAAC}$。有效。\n-   **移位算法应用：** 我们希望找到这些有效表示中最左边的一个。\n    -   从 $p=4$ 开始。我们可以向左移动到 $p=3$ 吗？可以，因为 $p=3$ 和 $p=4$ 之间的区域是 'A' 均聚物的一部分。\n    -   我们可以从 $p=3$ 向左移动到 $p=2$ 吗？可以， $p=2$ 和 $p=3$ 之间的区域也是 'A' 均聚物的一部分。\n    -   我们可以从 $p=2$ 向左移动到 $p=1$ 吗？不可以。位置 $1$ 的参考碱基是 'G'，它不属于 'A' 均聚物。移动必须在重复单元的边界处停止。\n-   **最终标准表示：** 最左边的位置是 $p=2$。表示为位置 $2$，$\\text{REF}=\\text{A}$，$\\text{ALT}=\\text{AA}$。\n\n### 逐项选项分析\n\n**A. 在均聚物中，任何单碱基空位放置在重复序列的任何位置都会产生相同的 DP 分数... 因此，存在多个最优比对... 为确保唯一键...通过左对齐标准化选择标准代表... 首先使等位基因最小化... 然后左移... 在 A 的均聚物中，这将移动到重复序列的左边界。将此应用于 R = GAAAAC 以及报告的在 p = 4 处的插入...会连续移动到 p = 3，然后是 p = 2，因为 R[1] = G != A 而停止。左对齐标准化的 VCF 是位置 2，REF = A 且 ALT = AA。**\n\n-   **理由：** 关于多个最优比对的理由是正确的。通过最小化和左移进行标准化的描述在概念上是正确的，并且与标准的生物信息学实践一致。\n-   **算法：** 所描述的插入算法，虽然对于复杂的串联重复序列来说可能比较复杂且可能不正确，但对于问题中给出的简单均聚物插入情况，可以正确地简化。它正确地识别了停止条件是均聚物重复序列的边界。\n-   **应用：** 对示例的应用是完美的。它正确地追踪了从 $p=4$ 到 $p=3$ 再到 $p=2$ 的移动，并在正确的边界停止，得出了正确的最终标准化 VCF。\n-   **裁定：** **正确**。此选项提供了正确的解释，一个对于指定问题类别功能上正确的算法，以及正确的结果。\n\n**B. 因为读段的合成和比对方向是 $3'$ 到 $5'$，所以 DP 倾向于将空位放置在均聚物的最右侧；因此右对齐标准化可产生唯一表示...**\n\n-   **理由：** 前提不正确。DNA/RNA 的合成方向是 $5' \\to 3'$。标准的 DP 比对算法对于最右侧与最左侧的空位放置没有内在偏好；任何一致的行为都是实现上的细节，除非被明确编码。右对齐标准化是一种可能的约定，但左对齐标准化是社区标准。\n-   **裁定：** **不正确**。其推理基于错误的科学和计算前提。\n\n**C. 使用仿射空位罚分时，DP 会打破平局并即使在均聚物中也能产生唯一的比对，因此左对齐标准化是不必要的...**\n\n-   **理由：** 这个陈述根本上是错误的。正如推导中所示，比对分数对于均聚物内的空位放置是不变的，无论空位罚分是线性的还是仿射的。仿射罚分改变了较长空位相对于较短空位的成本，但没有解决给定长度空位的位置模糊性。因此，左对齐标准化是必要的。\n-   **裁定：** **不正确**。核心前提是错误的。\n\n**D. 左对齐标准化是必要的，但它应定义为在所有等效表示中选择字典序最小的 $(\\text{REF}, \\text{ALT})$ 字符串对...**\n\n-   **理由：** 这提出了一种非标准的、任意的标准化规则。标准是基于位置的（最左），而不是字典序的。此外，它对示例的应用所建议的结果 `(AA, AAA)` 并不是一个最小表示（它可以被修剪为 `(A, AA)`)，并且在字典序上也不比 `(A, AA)` 小。\n-   **裁定：** **不正确**。提议的标准化规则不标准，并且应用错误。\n\n**E. 均聚物中的多个最优 DP 比对需要一个标准化规则。左对齐标准化的实现方式是：首先只修剪共同的前缀（忽略后缀），然后对于插入...当 $R[p-1] = R[p]$ 时，将 $p$ 减一；对于长度为 $D$ 的删除，当 $R[p-1] = R[p]$ 时，将 $p$ 减一。**\n\n-   **理由：** 等位基因最小化步骤的描述（“只修剪共同的前缀”）是不正确的；标准方法会同时修剪前缀和后缀。移位算法 `while R[p-1] = R[p], decrement p` 是一个过于简化的描述。虽然对于这个简单的插入它恰好能得出正确的位置，但它没有描述如何更新 $\\text{REF}$ 和 $\\text{ALT}$ 等位基因，这对于更复杂的情况（例如删除）是必要的，并且如果不更新等位基因将导致错误的单倍型。\n-   **裁定：** **不正确**。算法的描述不完整，并且基于对 VCF 最小化规则有缺陷的简化。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "当一个变异被规范地定义后，为了实现互操作性，它必须能在不同的标准命名法之间被准确转换。这项实践操作将挑战您将一个变异从生物信息学流程中常见的变异调用格式（VCF）转换为临床报告中使用的“人类基因组变异学会”（HGVS）命名法。此任务将考验您对基因组坐标与编码坐标之间转换的理解，特别是在处理位于DNA负链上的基因这一棘手但常见的情景时。",
            "id": "4336669",
            "problem": "一个电子健康记录 (EHR) 集成流程必须将来自变异调用格式 (VCF; Variant Call Format) 记录的变异描述标准化为人类基因组变异协会 (HGVS; Human Genome Variation Society) 的基因组和编码DNA表达形式。考虑以下一个基于基因组参考联盟人类第38版 (GRCh38) 的真实场景，其中$7$号染色体的参考序列登录号为 NC_000007.14。\n\n一个单核苷酸变异在一条VCF记录中提供，包含以下字段：CHROM、POS、ID、REF、ALT、QUAL、FILTER、INFO、FORMAT 以及一个样本基因型。该记录为：\n\nCHROM=7, POS=101115, ID=., REF=C, ALT=T, QUAL=50, FILTER=PASS, INFO=AC=1;AN=2;DP=30, FORMAT=GT:AD:DP:GQ:PL, SAMPLE=0/1:15,15:30:99:0,99,999.\n\n该变异位于一个蛋白质编码基因的RefSeq转录本 NM_999999.1 内，该基因在负（反义）链上。转录本结构（所有坐标均为基因组坐标，包含边界，并采用$5'$到$3'$的参考基因组坐标方向）如下：\n\n- 外显子 $1$：$g.[102050, 102200]$\n- 外显子 $2$：$g.[101000, 101150]$\n- 外显子 $3$：$g.[100000, 100300]$\n\nNM_999999.1的编码序列 (CDS) 起始于外显子$2$内起始密码子的第一个碱基。起始密码子碱基的基因组位置是 $g.101120$、$g.101121$ 和 $g.101122$，第一个编码碱基（ATG密码子中的腺嘌呤）对应于 $c.1$，并映射到基因组坐标 $g.101122$，因为该转录本位于负链上（编码从较高的基因组坐标向较低的基因组坐标进行）。假设所有提供的坐标相对于 NC_000007.14 都是正确的，并且该变异位于编码区内（而非非翻译区）。\n\n仅使用以下基本规则：(i) VCF的POS是在参考基因组正链坐标系上报告的，REF和ALT核苷酸也以正链约定给出；(ii) HGVS基因组表达形式 $g.$ 使用正链方向的参考序列；以及 (iii) HGVS编码表达形式 $c.$ 使用转录方向上的转录本序列，并将起始密码子的第一个编码碱基定为 $c.1$，推导出该变异的HGVS基因组和编码DNA表达形式。然后，为了进行EHR字段映射，将用于 $g.$ 表达形式的数字基因组位置和用于 $c.$ 表达形式的数字编码位置以一个包含两个元素的行矩阵形式报告。\n\n将最终数值答案表示为一个由两个整数组成的行矩阵 $\\begin{pmatrix}x  y\\end{pmatrix}$，其中 $x$ 是HGVS $g.$ 表达形式中使用的基因组坐标，$y$ 是HGVS $c.$ 表达形式中使用的编码DNA坐标。不需要四舍五入；请报告精确整数。",
            "solution": "用户要求推导一个基因变异的基因组和编码DNA坐标，并以适合电子健康记录 (EHR) 集成的格式呈现。该过程始于对问题陈述的严格验证。\n\n### 问题验证\n\n**第1步：提取已知条件**\n\n问题陈述中提供的数据和条件如下：\n-   **参考基因组**: 基因组参考联盟人类第38版 (GRCh38)，$7$号染色体的参考序列为 NC_000007.14。\n-   **VCF记录**:\n    -   CHROM = $7$\n    -   POS = $101115$\n    -   REF = C\n    -   ALT = T\n-   **转录本信息**:\n    -   RefSeq ID: NM_999999.1\n    -   链: 负（反义）链\n    -   外显子结构 (基因组坐标，包含边界，$5' \\to 3'$ 参考方向):\n        -   外显子 $1$: $g.[102050, 102200]$\n        -   外显子 $2$: $g.[101000, 101150]$\n        -   外显子 $3$: $g.[100000, 100300]$\n-   **编码序列 (CDS) 信息**:\n    -   CDS起始于外显子$2$的起始密码子。\n    -   起始密码子的基因组位置: $g.101120$, $g.101121$, $g.101122$。\n    -   第一个编码碱基 $c.1$ 映射到基因组坐标 $g.101122$。\n-   **假设**:\n    -   所有坐标相对于 NC_000007.14 都是正确的。\n    -   变异位于编码区内。\n-   **推导规则**:\n    -   (i) VCF的POS、REF和ALT位于参考基因组正链上。\n    -   (ii) HGVS $g.$ 表达形式使用正链方向的参考序列。\n    -   (iii) HGVS $c.$ 表达形式使用转录方向上的转录本序列，并将第一个编码碱基定为 $c.1$。\n-   **要求输出**: 一个包含数字基因组位置 ($g.$) 和数字编码位置 ($c.$) 的双元素行矩阵。\n\n**第2步：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行评估：\n-   **科学依据充分**：该问题基于生物信息学和临床基因组学中标准、公认的惯例，包括VCF规范、HGVS命名法以及参考基因组上的基因模型概念。该场景是基因组数据分析中一个真实且基础的任务。此标准已满足。\n-   **定义明确**：该问题提供了所有必要的数据（VCF记录、转录本结构、链、CDS起始映射）和一套清晰的规则来推导唯一的数值答案。问题具体且无歧义。此标准已满足。\n-   **客观性**：该问题使用了精确的技术语言（例如“GRCh38”、“VCF”、“HGVS”、“负链”），并且不含主观或基于观点的陈述。此标准已满足。\n-   **一致性检查**：变异位于基因组位置 $g.101115$。该位置落在外显子$2$的边界 $g.[101000, 101150]$ 内。由于基因位于负链上，CDS从 $g.101122$ 开始并向较低的基因组坐标延伸。因为 $101115  101122$，所以该变异的位置与它位于编码区内的陈述是一致的。数据具有自洽性，没有矛盾。\n\n**第3步：结论与行动**\n\n该问题科学上合理、定义明确、客观且内部一致。因此，它被判定为**有效**。现在开始推导解决方案。\n\n### 解决方案推导\n\n任务是找到用于HGVS $g.$ 表达形式的数字基因组位置和用于HGVS $c.$ 表达形式的数字编码位置。\n\n**1. 基因组坐标 ($g.$) 的推导**\n\nHGVS基因组 ($g.$) 命名法相对于参考基因组序列描述变异。根据规则(ii)，这使用参考染色体的正链方向。规则(i)指出，VCF的 `POS` 字段也是在参考基因组的正链、1-based坐标系上报告的。\n\nVCF记录提供：\n-   `CHROM` = $7$\n-   `POS` = $101115$\n-   `REF` = C\n-   `ALT` = T\n\n因此，基因组位置由VCF记录中的 `POS` 字段直接给出。这个单核苷酸替换的完整HGVS基因组表达形式将是 `NC_000007.14:g.101115C>T`。\n\n最终答案所需的数字基因组位置 $x$ 是 $101115$。\n\n**2. 编码DNA坐标 ($c.$) 的推导**\n\nHGVS编码DNA ($c.$) 命名法相对于转录本的编码序列描述变异。规则(iii)规定，$c.$ 坐标从翻译起始（起始）密码子的第一个碱基 ($c.1$) 开始，沿转录方向计数。\n\n此推导的关键信息：\n-   转录本位于**负链**上。这意味着转录从较高的基因组坐标向较低的基因组坐标进行。因此，随着 $g.$ 坐标编号的减小，$c.$ 坐标编号会增加。\n-   给出了参考点映射：$c.1$ 对应于基因组位置 $g.101122$。我们将其表示为 $g_{c.1} = 101122$。\n-   变异的基因组位置是 $g_{var} = 101115$。\n\n为了找到变异的编码位置 $c_{var}$，我们计算它与CDS起点的距离。沿基因组的碱基距离是基因组坐标之间的差值。由于基因位于负链上，位于基因组位置 $g_{var}  g_{c.1}$ 的变异将在转录本中位于起始密码子的“下游”。\n\n位置 $c_{var}$ 可以如下计算：\n从 $g_{c.1}$ 到 $g_{var}$ 沿转录方向的碱基数由它们基因组坐标的差值给出。\n$$ \\text{distance} = g_{c.1} - g_{var} $$\n$$ \\text{distance} = 101122 - 101115 = 7 $$\n该变异在转录方向上距离第一个编码碱基 $7$ 个碱基。因此，它在 $c.$ 坐标系中的位置是：\n$$ c_{var} = 1 + \\text{distance} $$\n$$ c_{var} = 1 + 7 = 8 $$\n最终答案所需的数字编码位置 $y$ 是 $8$。\n\n为了完整起见，我们可以确定完整的 $c.$ 表达形式。由于转录本在负链上，转录本上的等位基因是参考基因组正链上等位基因的反向互补序列。\n-   VCF `REF` (正链): `C`。反向互补序列是 `G`。\n-   VCF `ALT` (正链): `T`。反向互补序列是 `A`。\n因此，该变异是转录本上的一个 `G`到`A`的替换。完整的HGVS编码DNA表达形式将是 `NM_999999.1:c.8G>A`。\n\n**3. 最终答案的构建**\n\n问题要求一个包含两个元素的行矩阵 $\\begin{pmatrix}x  y\\end{pmatrix}$，其中 $x$ 是数字基因组位置，$y$ 是数字编码位置。\n-   基因组位置，$x = 101115$。\n-   编码DNA位置，$y = 8$。\n\n得到的矩阵是 $\\begin{pmatrix}101115  8\\end{pmatrix}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix}101115  8\\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在处理单个变异之后，整合整个基因组数据集会带来系统层面的挑战，例如协调在不同版本参考基因组上生成的数据。本练习模拟了关键的“坐标转换”（liftover）过程，即将变异坐标从旧的基因组组装版本（如GRCh37）映射到当前版本（如GRCh38）。您将通过实现一个简化但原理严谨的liftover算法，深入了解这种大规模数据转换是如何执行的，以及为何某些变异可能无法唯一映射。",
            "id": "4336648",
            "problem": "电子健康记录 (EHR) 系统越来越多地将临床变异存储在规范的参考基因组构建版本中，以驱动可互操作的临床决策支持。当临床变异是基于基因组参考联盟人类构建版本 37 (GRCh37) 生成，但 EHR 系统在基因组参考联盟人类构建版本 38 (GRCh38) 上运行时，就需要进行坐标转换（“liftover”）。在一个与经过充分测试的基因组组装比对原则一致的、简化的、算法上精确的模型中，一个 liftover 由一组比对“链”定义，每个链由组装版本之间的一个或多个完美匹配的区块组成。每个区块指定了源组装版本上的一个连续区间及其在目标组装版本上对应的连续区间，可能在反向互补链上。基本事实和定义如下：\n- 一个链由一个源染色体整数 $c_s$、一个目标染色体整数 $c_t$、一个链方向 $\\sigma \\in \\{+1,-1\\}$ 以及一个有限的比对区块列表 $B = \\{(s_i, t_i, \\ell_i)\\}_{i=1}^n$ 组成。每个区块 $(s_i, t_i, \\ell_i)$ 将源上的半开区间 $[s_i, s_i + \\ell_i)$ 映射到目标上的区间 $[t_i, t_i + \\ell_i)$。所有坐标都是以碱基对为单位的 0-基整数。\n- 位于染色体 $c$ 上源坐标 $x$ 的单核苷酸变异，当且仅当 $s_i \\le x  s_i + \\ell_i$ 且 $c = c_s$ 时，称其被区块 $(s_i, t_i, \\ell_i)$ 覆盖。\n- 如果被覆盖且 $\\sigma = +1$，则映射的目标坐标为染色体 $c_t$ 上的 $y = t_i + (x - s_i)$。\n- 如果被覆盖且 $\\sigma = -1$，则映射的目标坐标为染色体 $c_t$ 上的 $y = t_i + \\left(\\ell_i - 1 - (x - s_i)\\right)$。\n- 一个变异具有唯一的 liftover，当且仅当从所有链的所有区块中只产生一个唯一的目标元组 $(c_t, y)$。如果没有区块覆盖 $x$，则映射缺失。如果产生多个不同的目标元组，则映射模糊。\n\n您的任务是实现一个程序，对每个提供的测试用例执行以下操作：\n- 通过将上述定义应用于所提供的链集，计算所有 GRCh37 变异的 GRCh38 目标坐标 $(c_t, y)$。\n- 将每个变异分类为唯一转换、缺失或模糊。\n- 对于每个测试用例，返回因映射模糊或缺失而导致 liftover 失败的变异比例（以小数形式表示），定义为 $f = \\dfrac{N_{\\text{fail}}}{N_{\\text{total}}}$，其中 $N_{\\text{fail}}$ 是映射缺失或模糊的变异计数，$N_{\\text{total}}$ 是该测试用例中的总变异数。\n\n假设和约定：\n- 所有染色体均由正整数表示（例如，1 代表 1 号染色体）。\n- 所有坐标都是以碱基对为单位计数的 0-基整数。\n- 输入的链方向 $\\sigma$ 使用 $+1$ 表示正向，$-1$ 表示反向。\n- 一个变异是坐标 $x$ 处的一个碱基。\n- 映射规则使用半开区间 $[s_i, s_i + \\ell_i)$；坐标 $x = s_i + \\ell_i$ 不被该区块覆盖。\n\n程序内部需实现的测试套件：\n- 测试用例 1（理想路径，全部唯一）：\n  - 链：\n    - 一条链，其参数为 $(c_s = 1, c_t = 1, \\sigma = +1, B = [(10, 100, 10)])$。\n  - 变异（以 $(c, x)$ 对表示）：$[(1, 10), (1, 12), (1, 15), (1, 18), (1, 19)]$。\n  - 预期失败率：$0.0$。\n- 测试用例 2（边界和缺失覆盖）：\n  - 链：\n    - 一条链，其参数为 $(c_s = 1, c_t = 1, \\sigma = +1, B = [(10, 100, 10)])$。\n  - 变异：$[(1, 9), (1, 10), (1, 19), (1, 20)]$。坐标 $x = 9$ 和 $x = 20$ 未被覆盖，因为区块是 $[10, 20)$。\n  - 预期失败率：$0.5$。\n- 测试用例 3（模糊性和反向链）：\n  - 链：\n    - 链 A: $(c_s = 2, c_t = 2, \\sigma = +1, B = [(150, 3000, 30)])$。\n    - 链 B: $(c_s = 2, c_t = 2, \\sigma = +1, B = [(160, 4000, 30)])$。\n    - 链 C: $(c_s = 2, c_t = 2, \\sigma = -1, B = [(200, 5000, 10)])$。\n  - 变异：$[(2, 155), (2, 165), (2, 175), (2, 205)]$。坐标 $x = 165$ 和 $x = 175$ 的变异同时被链 A 和链 B 覆盖，但目标不同，因此是模糊的；$x = 155$ 通过链 A 唯一映射；$x = 205$ 通过链 C（反向）唯一映射。\n  - 预期失败率：$0.5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含测试用例 1、2 和 3 的失败率 $f$，每个失败率格式化为恰好 6 位小数（例如，$[0.000000,0.500000,0.500000]$）。\n- 将每个比例表示为小数，而不是百分比。\n\n该问题是完全自包含的；不要从文件读取或请求用户输入。请完全按照上述规定实现链和变异，并使用所提供的定义计算所需的失败率。",
            "solution": "问题陈述提出了一个明确定义的计算任务，该任务基于一个简化但科学上合理的基因组坐标转换模型，这个过程在生物信息学中被称为“liftover”。该问题经证实是合理、完整且无歧义的。它基于成熟的基因组组装比对原则，使用了比对链、匹配区块、染色体坐标和链方向等概念。对于正向（$\\sigma = +1$）和反向（$\\sigma = -1$）链的坐标覆盖和映射的定义是精确且可算法形式化的。将映射分类为唯一、缺失或模糊的标准是互斥且完备的。因此，该问题是有效的，可以设计出确定的解决方案。\n\n解决方案将通过迭代给定测试用例中提供的每个变异来实现。对于每个变异，我们必须通过对照每个提供的比对链中的每个区块来评估它，以确定所有可能的目标映射。集合（set）数据结构非常适合收集这些映射，因为它会自动只存储唯一的目标元组 $(c_t, y)$。\n\n单个变异 $(c, x)$ 的处理过程如下：\n1. 初始化一个空集合 `mappings`，用于存储找到的不同目标坐标。\n2. 遍历为测试用例定义的每个链。一个链由源染色体 $c_s$、目标染色体 $c_t$、链方向 $\\sigma$ 和一个比对区块列表 $B$ 描述。\n3. 如果变异的染色体 $c$ 与链的源染色体 $c_s$ 不匹配，则整个链都无关，我们继续处理下一个链。\n4. 如果染色体匹配 ($c = c_s$)，则遍历链的列表 $B$ 中的每个区块 $(s_i, t_i, \\ell_i)$。\n5. 对于每个区块，检查变异的源坐标 $x$ 是否被覆盖。根据所述的半开区间规则，条件是 $s_i \\le x  s_i + \\ell_i$。\n6. 如果坐标 $x$ 被区块覆盖，则根据链的链方向 $\\sigma$ 计算目标坐标 $y$：\n   - 如果 $\\sigma = +1$（正向链），位置偏移量保持不变。目标坐标为 $y = t_i + (x - s_i)$。\n   - 如果 $\\sigma = -1$（反向链），位置偏移量在区块内反转。目标坐标为 $y = t_i + (\\ell_i - 1 - (x - s_i))$。\n   得到的目标映射是元组 $(c_t, y)$。此元组被添加到 `mappings` 集合中。\n7. 在检查完所有链的所有区块后，`mappings` 集合的大小决定了变异 $(c, x)$ 的 liftover 状态：\n   - 如果集合为空（大小为 $0$），则没有区块覆盖该变异的坐标。映射为**缺失**。\n   - 如果集合恰好包含一个元素（大小为 $1$），则映射为**唯一**。\n   - 如果集合包含多个元素（大小 $> 1$），则找到了多个冲突的映射。映射为**模糊**。\n\n如果一个变异的映射是缺失或模糊的，则认为其 liftover 过程失败。对于每个测试用例，我们将计算变异总数 $N_{\\text{total}}$ 和失败变异数 $N_{\\text{fail}}$。然后计算失败率 $f = \\dfrac{N_{\\text{fail}}}{N_{\\text{total}}}$。此过程将应用于所有三个测试用例，并将所得比例按要求格式化并呈现。\n\n让我们用反向链映射规则追踪测试用例 3 中染色体 $c=2$ 上坐标 $x=205$ 的变异。相关链是链 C：$(c_s = 2, c_t = 2, \\sigma = -1, B = [(200, 5000, 10)])$。区块是 $(s_i, t_i, \\ell_i) = (200, 5000, 10)$。\n源坐标是 $x=205$。\n该变异位于正确的染色体上（$2=c_s$），其坐标在区块的源区间 $[200, 200+10) = [200, 210)$ 内，因为 $200 \\le 205  210$。\n映射在反向链上（$\\sigma = -1$）。目标坐标 $y$ 计算如下：\n$$ y = t_i + (\\ell_i - 1 - (x - s_i)) $$\n$$ y = 5000 + (10 - 1 - (205 - 200)) $$\n$$ y = 5000 + (9 - 5) $$\n$$ y = 5004 $$\n由于这是覆盖此坐标的唯一区块，唯一的映射是 $(c_t, y) = (2, 5004)$。这证实了反向链映射的逻辑被正确应用。算法设计因此根据问题的规范得到了验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats # Scipy is specified, importing a submodule for completeness.\n\ndef solve():\n    \"\"\"\n    Solves the liftover problem for the defined test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (happy path, all unique)\n        {\n            \"chains\": [\n                {\n                    \"cs\": 1, \"ct\": 1, \"sigma\": 1,\n                    \"blocks\": [(10, 100, 10)]\n                }\n            ],\n            \"variants\": [(1, 10), (1, 12), (1, 15), (1, 18), (1, 19)]\n        },\n        # Test case 2 (boundary and missing coverage)\n        {\n            \"chains\": [\n                {\n                    \"cs\": 1, \"ct\": 1, \"sigma\": 1,\n                    \"blocks\": [(10, 100, 10)]\n                }\n            ],\n            \"variants\": [(1, 9), (1, 10), (1, 19), (1, 20)]\n        },\n        # Test case 3 (ambiguity and reverse strand)\n        {\n            \"chains\": [\n                {  # Chain A\n                    \"cs\": 2, \"ct\": 2, \"sigma\": 1,\n                    \"blocks\": [(150, 3000, 30)]\n                },\n                {  # Chain B\n                    \"cs\": 2, \"ct\": 2, \"sigma\": 1,\n                    \"blocks\": [(160, 4000, 30)]\n                },\n                {  # Chain C\n                    \"cs\": 2, \"ct\": 2, \"sigma\": -1,\n                    \"blocks\": [(200, 5000, 10)]\n                }\n            ],\n            \"variants\": [(2, 155), (2, 165), (2, 175), (2, 205)]\n        }\n    ]\n\n    failure_fractions = []\n\n    for case in test_cases:\n        chains = case[\"chains\"]\n        variants = case[\"variants\"]\n        n_total = len(variants)\n        n_fail = 0\n\n        for c_var, x_var in variants:\n            found_mappings = set()\n\n            for chain in chains:\n                cs = chain[\"cs\"]\n                ct = chain[\"ct\"]\n                sigma = chain[\"sigma\"]\n                \n                # Skip chain if it's for a different source chromosome\n                if c_var != cs:\n                    continue\n\n                for s_i, t_i, l_i in chain[\"blocks\"]:\n                    # Check if the variant is covered by the block's source interval [s_i, s_i + l_i)\n                    if s_i = x_var  s_i + l_i:\n                        y = 0\n                        # Forward strand mapping\n                        if sigma == 1:\n                            y = t_i + (x_var - s_i)\n                        # Reverse strand mapping\n                        elif sigma == -1:\n                            y = t_i + (l_i - 1 - (x_var - s_i))\n                        \n                        found_mappings.add((ct, y))\n            \n            # Classify the liftover result\n            # A failure is defined as a missing (0 mappings) or ambiguous (>1 mapping) result.\n            if len(found_mappings) != 1:\n                n_fail += 1\n\n        if n_total > 0:\n            fraction = n_fail / n_total\n        else:\n            fraction = 0.0\n        \n        failure_fractions.append(f\"{fraction:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(failure_fractions)}]\")\n\nsolve()\n```"
        }
    ]
}