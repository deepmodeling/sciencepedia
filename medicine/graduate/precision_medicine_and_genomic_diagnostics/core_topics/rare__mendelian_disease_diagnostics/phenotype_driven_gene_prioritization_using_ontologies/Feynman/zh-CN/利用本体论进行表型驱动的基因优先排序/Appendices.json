{
    "hands_on_practices": [
        {
            "introduction": "从本质上讲，表型驱动的基因优先排序是一个更新我们信念的过程。我们首先对哪些基因可能是致病基因有一个先验的怀疑，然后利用患者的具体症状（表型）作为证据来修正这些怀疑。本练习让您亲手实践这一过程背后的数学引擎——贝叶斯定理，计算表型证据如何直接改变一个基因相对于另一个基因的致病几率。",
            "id": "4368540",
            "problem": "在使用人类表型本体 (HPO) 进行孟德尔诊断的表型驱动基因优先排序中，候选基因根据基因组证据被赋予先验概率，然后使用表型术语通过概率推断来更新这些先验概率。考虑一个仅表现出单一 HPO 术语（记为 $t_{1}$）的患者。您正在评估两个候选基因 $g_{1}$ 和 $g_{2}$，它们作为该患者致病基因的先验概率分别为 $P(g_{1})=0.01$ 和 $P(g_{2})=0.005$。表型术语 $t_{1}$ 具有基因特异性的外显率样似然 $P(t_{1}\\mid g_{1})=0.8$ 和 $P(t_{1}\\mid g_{2})=0.4$，这表示携带 $g_{1}$ 或 $g_{2}$ 致病性变异的患者表现出 $t_{1}$ 的概率。\n\n假设证据集为 $\\{t_{1}\\}$，并且所考虑的候选基因对于该患者的致病假设构成一个互斥集合。仅使用概率论的核心定义，推导出后验比率 $\\dfrac{P(g_{1}\\mid \\{t_{1}\\})}{P(g_{2}\\mid \\{t_{1}\\})}$（用先验概率和似然表示），然后根据所提供的值进行计算。请以精确数值（无量纲）的形式提供您的最终结果。",
            "solution": "该问题被验证为具有科学依据、良定、客观且完整。所有必要数据均已提供，所要求的任务是贝叶斯概率理论在基因组诊断学领域的标准应用。没有可识别的缺陷。\n\n此问题的核心在于应用贝叶斯定理，根据表型证据更新关于基因致病性的先验信念。我们被要求在观察到单个表型术语 $t_1$ 的情况下，计算两个候选基因 $g_1$ 和 $g_2$ 的后验比率。\n\n令 $g_i$ 代表基因 $g_i$ 是患者病情的致病基因这一假设。令 $t_1$ 为观察到的证据。我们已知以下先验概率和似然：\n- $g_1$ 是致病基因的先验概率：$P(g_1) = 0.01$\n- $g_2$ 是致病基因的先验概率：$P(g_2) = 0.005$\n- 在 $g_1$ 是致病基因的条件下观察到 $t_1$ 的似然：$P(t_1 \\mid g_1) = 0.8$\n- 在 $g_2$ 是致病基因的条件下观察到 $t_1$ 的似然：$P(t_1 \\mid g_2) = 0.4$\n\n需要推导的量是后验比率，即两个假设的后验概率之比：$\\dfrac{P(g_1 \\mid t_1)}{P(g_2 \\mid t_1)}$。\n\n贝叶斯定理指出，在给定证据 $E$ 的情况下，假设 $H$ 的后验概率由以下公式给出：\n$$ P(H \\mid E) = \\frac{P(E \\mid H) P(H)}{P(E)} $$\n其中 $P(H)$ 是假设的先验概率，$P(E \\mid H)$ 是给定假设下证据的似然，$P(E)$ 是证据的边际概率。\n\n将此定理应用于我们的特定假设 $g_1$ 和 $g_2$ 以及证据 $t_1$：\n基因 $g_1$ 的后验概率为：\n$$ P(g_1 \\mid t_1) = \\frac{P(t_1 \\mid g_1) P(g_1)}{P(t_1)} $$\n基因 $g_2$ 的后验概率为：\n$$ P(g_2 \\mid t_1) = \\frac{P(t_1 \\mid g_2) P(g_2)}{P(t_1)} $$\n\n后验比率是这两个表达式的比值：\n$$ \\frac{P(g_1 \\mid t_1)}{P(g_2 \\mid t_1)} = \\frac{\\left( \\frac{P(t_1 \\mid g_1) P(g_1)}{P(t_1)} \\right)}{\\left( \\frac{P(t_1 \\mid g_2) P(g_2)}{P(t_1)} \\right)} $$\n\n项 $P(t_1)$ 代表在所有可能的遗传原因下观察到表型 $t_1$ 的总概率，它同时出现在分子和分母中。因此，它可以被消去。这种消去是处理比率的一个关键特性，因为它避免了计算通常难以获得的证据的边际概率。问题中说明基因是互斥的，这个条件在计算完整假设集上的 $P(t_1)$ 时是必需的，但在这里其计算并非必要。\n\n推导出的后验比率表达式简化为：\n$$ \\frac{P(g_1 \\mid t_1)}{P(g_2 \\mid t_1)} = \\frac{P(t_1 \\mid g_1) P(g_1)}{P(t_1 \\mid g_2) P(g_2)} $$\n这个关系表明，后验比率是先验比率 $\\frac{P(g_1)}{P(g_2)}$ 与似然比（也称为贝叶斯因子）$\\frac{P(t_1 \\mid g_1)}{P(t_1 \\mid g_2)}$ 的乘积。\n\n现在，我们将提供的数值代入这个推导出的公式来计算后验比率：\n$$ \\frac{P(g_1 \\mid t_1)}{P(g_2 \\mid t_1)} = \\frac{(0.8) \\times (0.01)}{(0.4) \\times (0.005)} $$\n让我们分别计算分子和分母。\n分子：\n$$ (0.8) \\times (0.01) = 0.008 $$\n分母：\n$$ (0.4) \\times (0.005) = 0.002 $$\n因此，比率为：\n$$ \\frac{0.008}{0.002} = 4 $$\n后验比率等于 $4$。这意味着在考虑了患者的表型 $t_1$ 后，基因 $g_1$ 是致病基因的可能性是基因 $g_2$ 的 $4$ 倍。该结果是一个无量纲量。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "在使用表型作为证据的基础上，我们现在来探讨一个至关重要的实践细节：如何量化一个表型的“信息量”？这通常通过一个称为信息量（Information Content, $IC$）的指标来完成，它取决于一个术语出现的频率。本练习揭示了一个常见的陷阱：如果不尊重本体论的层次结构（即“真实路径规则”）而天真地计算术语频率，可能会导致不正确且违反直觉的基因排序。通过这个例子，您将更深刻地理解为什么遵循本体论原则对于获得准确结果至关重要。",
            "id": "4368546",
            "problem": "在使用人类表型本体 (HPO) 进行表型驱动的基因优先级排序中，该本体是一个具有“is-a”层级结构的有向无环图，并遵循真实路径规则：如果一个基因被注释到术语 $t$，那么它也被隐式地注释到 $t$ 的所有祖先。考虑一个包含 $N=1000$ 个基因的背景语料库，其直接术语注释构成以下小型本体片段：一个根节点有两个子节点 $t_{1}$ 和 $t_{2}$；$t_{1}$ 有子节点 $t_{1a}$ 和 $t_{1b}$；$t_{2}$ 有子节点 $t_{2a}$。语料库中直接分配的注释如下：\n- $300$ 个基因直接注释到 $t_{1a}$，\n- $300$ 个基因直接注释到 $t_{1b}$，\n- $5$ 个基因直接注释到 $t_{1}$，\n- $10$ 个基因直接注释到 $t_{2a}$，\n- $0$ 个基因直接注释到 $t_{2}$ 或此片段中的任何其他术语。\n\n您必须比较一个术语 $t$ 的两种背景术语概率估计，记为 $p(t)$：\n- 原始术语频率：$p_{\\mathrm{raw}}(t)$ 等于直接注释到 $t$ 的基因所占的比例。\n- 术语频率加后代（真实路径闭包）：$p_{\\mathrm{clo}}(t)$ 等于注释到 $t$ 或 $t$ 的任何后代的基因所占的比例。\n\n假设一个患者具有单个 HPO 查询术语 $Q=\\{t_{1a}\\}$。给定两个候选基因：\n- 基因 $G_{A}$ 直接注释到 $t_{1}$。\n- 基因 $G_{B}$ 直接注释到 $t_{1a}$。\n\n定义 $Q$ 和候选基因 $g$ 之间的相似性为查询术语与基因注释的“信息量最丰富的共同祖先 (MICA)”的“信息含量 (IC)”之和（对所有查询术语求和）。其中，IC 定义为 $\\mathrm{IC}(t)=-\\ln p(t)$（使用自然对数），而 $\\mathrm{MICA}(q,a)$ 是在所选 $p(t)$ 下，$q$ 和 $a$ 共享的具有最大 IC 的祖先。对于此设置，基因 $g$ 的相似性得分简化为 $\\mathrm{IC}(\\mathrm{MICA}(t_{1a},a_{g}))$，其中 $a_{g}$ 是 $g$ 的单个注释。\n\n使用上述语料库，计算在 $p_{\\mathrm{raw}}(t)$ 和 $p_{\\mathrm{clo}}(t)$ 下的得分，并确定在每种 $p(t)$ 定义下 $G_{A}$ 和 $G_{B}$ 之间的导出排序。哪个选项是正确的？\n\nA. 在 $p_{\\mathrm{raw}}(t)$ 下，$G_{A}$ 的排名高于 $G_{B}$；在 $p_{\\mathrm{clo}}(t)$ 下，$G_{B}$ 的排名高于 $G_{A}$。\n\nB. 在 $p_{\\mathrm{raw}}(t)$ 和 $p_{\\mathrm{clo}}(t)$ 下，$G_{B}$ 的排名都高于 $G_{A}$。\n\nC. 在 $p_{\\mathrm{raw}}(t)$ 和 $p_{\\mathrm{clo}}(t)$ 下，$G_{A}$ 的排名都高于 $G_{B}$。\n\nD. 在 $p_{\\mathrm{raw}}(t)$ 下，$G_{B}$ 的排名高于 $G_{A}$；在 $p_{\\mathrm{clo}}(t)$ 下，$G_{A}$ 的排名高于 $G_{B}$。",
            "solution": "用户提供了一个生物信息学领域的计算问题，要求使用人类表型本体 (HPO) 基于表型相似性对基因进行优先级排序。我将首先验证问题陈述，然后进行完整的推导和选项评估。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n-   **本体：** 一个具有“is-a”层级结构的有向无环图 (DAG)。\n-   **真实路径规则：** 如果一个基因被注释到术语 $t$，它也被隐式地注释到 $t$ 的所有祖先。\n-   **语料库大小：** $N=1000$ 个基因。\n-   **本体片段：** 一个根术语有子节点 $t_1$ 和 $t_2$。$t_1$ 有子节点 $t_{1a}$ 和 $t_{1b}$。$t_2$ 有子节点 $t_{2a}$。\n-   **直接注释计数：**\n    -   $n_{\\mathrm{direct}}(t_{1a}) = 300$\n    -   $n_{\\mathrm{direct}}(t_{1b}) = 300$\n    -   $n_{\\mathrm{direct}}(t_1) = 5$\n    -   $n_{\\mathrm{direct}}(t_{2a}) = 10$\n    -   $n_{\\mathrm{direct}}(t_2) = 0$\n    -   $0$ 个基因直接注释到此片段中的任何其他术语。\n-   **概率定义：**\n    -   原始术语频率：$p_{\\mathrm{raw}}(t) = n_{\\mathrm{direct}}(t) / N$。\n    -   术语频率加后代（闭包）：$p_{\\mathrm{clo}}(t) = n_{\\mathrm{clo}}(t) / N$，其中 $n_{\\mathrm{clo}}(t)$ 是注释到 $t$ 或 $t$ 的任何后代的基因计数。\n-   **患者查询：** $Q = \\{t_{1a}\\}$。\n-   **候选基因：**\n    -   $G_A$ 直接注释到 $a_A = t_1$。\n    -   $G_B$ 直接注释到 $a_B = t_{1a}$。\n-   **相似性得分：**\n    -   信息含量 (IC): $\\mathrm{IC}(t) = -\\ln p(t)$。\n    -   信息量最丰富的共同祖先 (MICA): $\\mathrm{MICA}(q,a)$ 是 $q$ 和 $a$ 的共同祖先中具有最大 IC 的那个。\n    -   基因 $g$ 的得分：$\\mathrm{Score}(g) = \\mathrm{IC}(\\mathrm{MICA}(t_{1a}, a_g))$。更高的得分对应更高的排名。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **有科学依据：** 该问题使用了生物信息学中用于表型驱动基因优先级排序的标准、成熟概念，包括 HPO、真实路径规则、信息含量 (IC) 和信息量最丰富的共同祖先 (MICA)。这些是语义相似性度量的基础。\n-   **适定性：** 提供了计算所需分数和确定排名的所有必要数据和定义。直接注释的基因总数为 $300+300+5+10 = 615$，小于总语料库大小 $N=1000$。这是现实的，因为并非背景集中的所有基因都必然被注释。该设置是自洽且一致的。\n-   **客观性：** 问题以精确的、定量的术语陈述，没有主观性或歧义。\n\n**步骤 3：结论与行动**\n问题陈述有效。它在科学上是合理的，具有适定性和客观性。我现在开始解题。\n\n### 解题推导\n\n任务是计算基因 $G_A$ 和 $G_B$ 相对于查询术语 $t_{1a}$ 在两种不同概率模型 $p_{\\mathrm{raw}}(t)$ 和 $p_{\\mathrm{clo}}(t)$ 下的相似性得分，并确定最终的排序。\n\n对于一个带有注释 $a_g$ 的基因 $g$，其得分为 $\\mathrm{Score}(g) = \\mathrm{IC}(\\mathrm{MICA}(t_{1a}, a_g))$。\n-   对于基因 $G_A$，其注释为 $a_A = t_1$。得分为 $\\mathrm{Score}(G_A) = \\mathrm{IC}(\\mathrm{MICA}(t_{1a}, t_1))$。\n-   对于基因 $G_B$，其注释为 $a_B = t_{1a}$。得分为 $\\mathrm{Score}(G_B) = \\mathrm{IC}(\\mathrm{MICA}(t_{1a}, t_{1a}))$。\n\n让我们分别分析每种概率模型。\n\n**1. 在原始术语频率 $p_{\\mathrm{raw}}(t)$ 下的分析**\n\n首先，我们计算相关术语的概率及其对应的信息含量 (IC) 值。基因总数为 $N=1000$。\n-   $p_{\\mathrm{raw}}(t_{1a}) = \\frac{n_{\\mathrm{direct}}(t_{1a})}{N} = \\frac{300}{1000} = 0.3$。\n-   $p_{\\mathrm{raw}}(t_1) = \\frac{n_{\\mathrm{direct}}(t_1)}{N} = \\frac{5}{1000} = 0.005$。\n\nIC 值为：\n-   $\\mathrm{IC}_{\\mathrm{raw}}(t_{1a}) = -\\ln(0.3) \\approx 1.204$。\n-   $\\mathrm{IC}_{\\mathrm{raw}}(t_1) = -\\ln(0.005) \\approx 5.298$。\n\n一个重要的观察是，$\\mathrm{IC}_{\\mathrm{raw}}(t_1) > \\mathrm{IC}_{\\mathrm{raw}}(t_{1a})$，尽管 $t_1$ 是 $t_{1a}$ 的祖先。这种信息量的倒置是使用原始直接注释频率时的一个已知的人为现象。\n\n现在我们计算 $G_A$ 和 $G_B$ 的得分：\n\n**$G_A$ 的得分：**\n-   我们需要找到 $\\mathrm{MICA}(t_{1a}, t_1)$。$t_{1a}$ 和 $t_1$ 的共同祖先集合（包括术语自身）是 $\\{t_1, \\text{Root}\\}$。\n-   问题没有指定根节点的直接注释数，通常假设 $n_{\\mathrm{direct}}(\\text{Root}) = 0$。这将导致 $p_{\\mathrm{raw}}(\\text{Root}) = 0$ 和 $\\mathrm{IC}_{\\mathrm{raw}}(\\text{Root}) = \\infty$。在实践中，此类术语在考虑 MICA 时被排除，或者使用一个概率下限。我们将只考虑具有有限 IC 的祖先。\n-   唯一具有非零概率的共同祖先是 $t_1$。因此，$\\mathrm{MICA}_{\\mathrm{raw}}(t_{1a}, t_1) = t_1$。\n-   $\\mathrm{Score}_{\\mathrm{raw}}(G_A) = \\mathrm{IC}_{\\mathrm{raw}}(\\mathrm{MICA}_{\\mathrm{raw}}(t_{1a}, t_1)) = \\mathrm{IC}_{\\mathrm{raw}}(t_1) = -\\ln(0.005) \\approx 5.298$。\n\n**$G_B$ 的得分：**\n-   我们需要找到 $\\mathrm{MICA}(t_{1a}, t_{1a})$。MICA 的问题定义是“$q$ 和 $a$ 共享的具有最大 IC 的祖先”。\n-   如果我们按字面意思应用这个定义，$t_{1a}$ 与自身的共同祖先集合是 $\\{t_{1a}, t_1, \\text{Root}\\}$。它们的 IC 值是 $\\mathrm{IC}_{\\mathrm{raw}}(t_{1a}) \\approx 1.204$ 和 $\\mathrm{IC}_{\\mathrm{raw}}(t_1) \\approx 5.298$。由于 IC 倒置，MICA 将是 $t_1$，而不是 $t_{1a}$，从而导致与 $G_A$ 相同的得分。这是反直觉的；一个完美的匹配应该具有最大程度的相似性。\n-   语义相似性的标准惯例是，一个术语与自身的相似性是其自身的信息含量，这意味着 $\\mathrm{MICA}(t, t) = t$。我们采用这种标准解释，因为它解决了歧义，并且是唯一能够像选项所暗示的那样进行严格排序的途径。\n-   因此，$\\mathrm{MICA}_{\\mathrm{raw}}(t_{1a}, t_{1a}) = t_{1a}$。\n-   $\\mathrm{Score}_{\\mathrm{raw}}(G_B) = \\mathrm{IC}_{\\mathrm{raw}}(t_{1a}) = -\\ln(0.3) \\approx 1.204$。\n\n**在 $p_{\\mathrm{raw}}(t)$ 下的排名：**\n-   $\\mathrm{Score}_{\\mathrm{raw}}(G_A) \\approx 5.298$。\n-   $\\mathrm{Score}_{\\mathrm{raw}}(G_B) \\approx 1.204$。\n-   由于 $\\mathrm{Score}_{\\mathrm{raw}}(G_A) > \\mathrm{Score}_{\\mathrm{raw}}(G_B)$，$G_A$ 的排名高于 $G_B$。\n\n**2. 在闭包术语频率 $p_{\\mathrm{clo}}(t)$ 下的分析**\n\n首先，我们根据真实路径规则，通过将一个术语及其所有后代的直接注释相加，来计算传播后的基因计数 $n_{\\mathrm{clo}}(t)$。\n-   $n_{\\mathrm{clo}}(t_{1a}) = n_{\\mathrm{direct}}(t_{1a}) = 300$。\n-   $n_{\\mathrm{clo}}(t_1) = n_{\\mathrm{direct}}(t_1) + n_{\\mathrm{direct}}(t_{1a}) + n_{\\mathrm{direct}}(t_{1b}) = 5 + 300 + 300 = 605$。\n-   （为完整起见，其他术语：$n_{\\mathrm{clo}}(t_{1b}) = 300$；$n_{\\mathrm{clo}}(t_{2a})=10$；$n_{\\mathrm{clo}}(t_2)=10$；$n_{\\mathrm{clo}}(\\text{Root})=615$）。\n\n现在，计算概率 $p_{\\mathrm{clo}}(t)$ 和 IC。\n-   $p_{\\mathrm{clo}}(t_{1a}) = \\frac{300}{1000} = 0.3$。\n-   $p_{\\mathrm{clo}}(t_1) = \\frac{605}{1000} = 0.605$。\n\nIC 值为：\n-   $\\mathrm{IC}_{\\mathrm{clo}}(t_{1a}) = -\\ln(0.3) \\approx 1.204$。\n-   $\\mathrm{IC}_{\\mathrm{clo}}(t_1) = -\\ln(0.605) \\approx 0.5025$。\n\n使用闭包频率恢复了 IC 的预期单调性：$p_{\\mathrm{clo}}(t_{1a})  p_{\\mathrm{clo}}(t_1)$，所以 $\\mathrm{IC}_{\\mathrm{clo}}(t_{1a})  \\mathrm{IC}_{\\mathrm{clo}}(t_1)$。子术语比其父术语信息量更大。\n\n现在我们计算 $G_A$ 和 $G_B$ 的得分：\n\n**$G_A$ 的得分：**\n-   我们需要 $\\mathrm{MICA}(t_{1a}, t_1)$。共同祖先是 $\\{t_1, \\text{Root}\\}$。\n-   $\\mathrm{IC}_{\\mathrm{clo}}(t_1) \\approx 0.5025$。根节点的 IC 会更低，因为它的概率更高。\n-   $\\mathrm{MICA}_{\\mathrm{clo}}(t_{1a}, t_1) = t_1$。\n-   $\\mathrm{Score}_{\\mathrm{clo}}(G_A) = \\mathrm{IC}_{\\mathrm{clo}}(t_1) = -\\ln(0.605) \\approx 0.5025$。\n\n**$G_B$ 的得分：**\n-   我们需要 $\\mathrm{MICA}(t_{1a}, t_{1a})$。共同祖先是 $\\{t_{1a}, t_1, \\text{Root}\\}$。\n-   IC 值为 $\\mathrm{IC}_{\\mathrm{clo}}(t_{1a}) \\approx 1.204$ 和 $\\mathrm{IC}_{\\mathrm{clo}}(t_1) \\approx 0.5025$。\n-   MICA 是具有最大 IC 的那个，即 $t_{1a}$。$\\mathrm{MICA}_{\\mathrm{clo}}(t_{1a}, t_{1a}) = t_{1a}$。\n-   $\\mathrm{Score}_{\\mathrm{clo}}(G_B) = \\mathrm{IC}_{\\mathrm{clo}}(t_{1a}) = -\\ln(0.3) \\approx 1.204$。\n\n**在 $p_{\\mathrm{clo}}(t)$ 下的排名：**\n-   $\\mathrm{Score}_{\\mathrm{clo}}(G_A) \\approx 0.5025$。\n-   $\\mathrm{Score}_{\\mathrm{clo}}(G_B) \\approx 1.204$。\n-   由于 $\\mathrm{Score}_{\\mathrm{clo}}(G_B)  \\mathrm{Score}_{\\mathrm{clo}}(G_A)$，$G_B$ 的排名高于 $G_A$。\n\n### 总结与选项评估\n\n-   在 $p_{\\mathrm{raw}}(t)$ 下，$G_A$ 的排名高于 $G_B$。\n-   在 $p_{\\mathrm{clo}}(t)$ 下，$G_B$ 的排名高于 $G_A$。\n\n这表明背景概率模型的选择，特别是其处理本体结构的方式，如何关键性地影响基因优先级排序。原始频率模型由于 IC 倒置可能会产生反直觉的结果，而闭包模型则尊重本体的特异性层级。\n\n现在，我们评估所提供的选项：\n\n**A. 在 $p_{\\mathrm{raw}}(t)$ 下，$G_{A}$ 的排名高于 $G_{B}$；在 $p_{\\mathrm{clo}}(t)$ 下，$G_{B}$ 的排名高于 $G_{A}$。**\n这与我们的推导结果相符。\n\n**B. 在 $p_{\\mathrm{raw}}(t)$ 和 $p_{\\mathrm{clo}}(t)$ 下，$G_{B}$ 的排名都高于 $G_{A}$。**\n这是不正确的。在 $p_{\\mathrm{raw}}(t)$ 下的排名是相反的。\n\n**C. 在 $p_{\\mathrm{raw}}(t)$ 和 $p_{\\mathrm{clo}}(t)$ 下，$G_{A}$ 的排名都高于 $G_{B}$。**\n这是不正确的。在 $p_{\\mathrm{clo}}(t)$ 下的排名是相反的。\n\n**D. 在 $p_{\\mathrm{raw}}(t)$ 下，$G_{B}$ 的排名高于 $G_{A}$；在 $p_{\\mathrm{clo}}(t)$ 下，$G_{A}$ 的排名高于 $G_{B}$。**\n这与我们的推导结果完全相反，是不正确的。\n\n因此，选项 A 是唯一正确的陈述。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在对候选基因进行排序后，一个关键问题依然存在：排名靠前的基因获得高分是真正有意义的，还是可能仅仅是偶然发生的？本练习超越了简单的排序，进入了统计验证这一核心步骤。您将探索强大的置换检验技术来生成零分布并计算经验p值，然后使用Benjamini-Hochberg程序来控制检验多个基因时的假阳性发现率。这项练习模拟了真实生物信息学分析流程的关键部分，使您具备区分统计显著结果与随机噪声的能力。",
            "id": "4368614",
            "problem": "设计并实现一个完整的程序，该程序在给定一个固定的人类表型本体（HPO; Human Phenotype Ontology）全集、基因注释和若干患者表型集的情况下，通过置换患者的HPO集来计算基因分数的经验p值，然后使用Benjamini-Hochberg程序（Benjamini-Hochberg）估计错误发现率（FDR; False Discovery Rate）。您的程序必须遵守以下规范。\n\n您必须使用以下基本构造和定义作为基础：\n- 人类表型注释表示为本体术语标识符的集合。一个术语的信息含量（IC; Information Content）权重根据经验频率定义为该频率的负自然对数。一个基因相对于一个患者表型集的分数是共享术语的IC权重之和。\n- 检验统计量的p值是在原假设下，获得一个至少与观察到的统计量一样极端的值的概率。在置换框架中，空分布是通过根据固定模型随机化表型集来生成的。\n- 错误发现率是在已声明的发现集合中，假阳性的预期比例，可以使用Benjamini-Hochberg升阶程序进行控制。\n\n数据模型：\n- 共有$N=8$个HPO术语$\\{t_1,\\dots,t_8\\}$，其经验频率$f(t_i)$由向量给出\n$$\n[f(t_1),f(t_2),f(t_3),f(t_4),f(t_5),f(t_6),f(t_7),f(t_8)] \n= [0.25,0.12,0.06,0.18,0.10,0.04,0.09,0.16].\n$$\n- 定义每个术语$t$的IC权重为$w(t)=-\\log(f(t))$。\n- 共有$m=5$个基因，其注释为HPO术语集：\n  - 基因 $A$: $\\{t_2,t_6\\}$。\n  - 基因 $B$: $\\{t_1,t_4,t_8\\}$。\n  - 基因 $C$: $\\{t_3,t_6,t_7\\}$。\n  - 基因 $D$: $\\{t_5\\}$。\n  - 基因 $E$: $\\{t_2,t_3,t_5\\}$。\n- 对于一个患者表型集$S \\subseteq \\{t_1,\\dots,t_8\\}$，定义基因分数为基因注释与$S$之间共享术语的权重之和。\n\n通过置换计算经验p值：\n- 空模型：从$\\{t_1,\\dots,t_8\\}$中不放回地随机抽取与$S$大小相同的表型集$S^\\ast$，其中每个术语$t$被选择的概率与$f(t)$成正比，并且$S^\\ast$的所有元素都是唯一的。这保留了集合的基数和术语的边际频率。\n- 对于每个基因，将其观察分数与从置换集计算出的空分数进行比较。当置换分数大于或等于观察分数时，将该置换分数计为至少一样极端。\n- 使用单一计数连续性校正，通过在蒙特卡洛估计量的分子和分母上都加一，来避免p值为零。\n- 对于每个测试用例，使用下面指定的置换次数$M$。所有随机性必须通过使用种子$42$初始化一个伪随机数生成器一次，并按给定顺序对所有测试用例一致使用它，来保证是可复现的。\n\nBenjamini-Hochberg FDR校正：\n- 给定$m$个基因的$m$个经验p值的向量，通过以下步骤计算Benjamini-Hochberg校正值（也称为$q$值）：\n  - 将p值升序排列，并从最小的$1$到最大的$m$分配秩次。\n  - 对于每个有序的p值，乘以总假设数与其秩次的比率。\n  - 通过从最大秩次遍历到最小秩次时，将每个校正值替换为到目前为止看到的最小值，来强制执行单调性。\n  - 将所有校正值的上限设为$1$。\n  - 恢复原始基因顺序以报告最终的校正值。\n\n实现的评分定义：\n- 对于一个由集合$A_g$注释的基因和一个患者集$S$，分数是所有$t \\in A_g \\cap S$的$w(t)$之和。\n\n测试套件：\n- 报告结果时使用基因顺序$[A,B,C,D,E]$。\n- 使用以下患者表型集和置换次数：\n  1. 测试用例 1：$S_1=\\{t_2,t_6,t_7\\}$，使用$M=4000$次置换。\n  2. 测试用例 2：$S_2=\\{t_1,t_4,t_8\\}$，使用$M=4000$次置换。\n  3. 测试用例 3：$S_3=\\{t_2,t_3,t_6\\}$，使用$M=200$次置换。\n  4. 测试用例 4：$S_4=\\{t_6\\}$，使用$M=1000$次置换。\n\n程序要求：\n- 对每个测试用例，使用指定的置换模型和连续性校正，计算$m=5$个基因的经验p值，然后为这$5$个p值计算Benjamini-Hochberg校正值。\n- 将每个校正值四舍五入到$6$位小数。值必须是小数（而不是百分比）。\n- 最终输出格式：您的程序应生成一行输出，包含一个逗号分隔的列表的列表，其中每个内部列表对应于按指定顺序的一个测试用例，并包含按基因顺序$[A,B,C,D,E]$排列的$5$个四舍五入的校正值。例如，一个包含两个假设案例的输出看起来像$[[0.1,0.2,0.3,0.4,0.5],[0.2,0.2,0.2,0.2,0.2]]$；您的输出必须为四个测试用例遵循相同的方括号、逗号分隔的结构。",
            "solution": "问题陈述已经过评估，并被确定为有效。它是科学合理的、提法恰当的、客观的，并包含构建一个唯一、可验证解所需的所有必要信息和定义。所描述的方法——信息含量（IC）、置换检验和Benjamini-Hochberg（BH）程序——在生物信息学领域用于表型驱动的基因优先级排序是标准且成熟的方法。\n\n该解决方案通过为每个提供的测试用例遵循一个系统的、多步骤的计算过程来实现。\n\n**1. 数据初始化和预计算**\n\n首先，定义人类表型本体（HPO）术语的全集和相关的基因注释。给定$N=8$个HPO术语，$\\{t_1, \\dots, t_8\\}$，其经验频率由向量给出：\n$$\n[f(t_1), \\dots, f(t_8)] = [0.25, 0.12, 0.06, 0.18, 0.10, 0.04, 0.09, 0.16]\n$$\n这些频率的总和是$\\sum_{i=1}^8 f(t_i) = 1.0$，证实了这是一个有效的概率分布。\n\n每个术语$t_i$的信息含量（IC）权重计算为其频率的负自然对数：\n$$\nw(t_i) = -\\log(f(t_i))\n$$\n这将产生一个权重向量$[w(t_1), \\dots, w(t_8)]$。较高的权重表示一个更具体或更罕见的术语。\n\n给定$m=5$个基因，表示为$\\{A, B, C, D, E\\}$，具有以下作为HPO术语集的注释：\n- 基因 $A$: $\\{t_2, t_6\\}$\n- 基因 $B$: $\\{t_1, t_4, t_8\\}$\n- 基因 $C$: $\\{t_3, t_6, t_7\\}$\n- 基因 $D$: $\\{t_5\\}$\n- 基因 $E$: $\\{t_2, t_3, t_5\\}$\n\n为了计算方便，我们将每个术语$t_i$映射到一个整数索引$i-1$。\n\n**2. 基因评分**\n\n对于给定的患者，其临床表现由一组HPO术语$S$描述。基因$g$与患者表型的相关性通过一个分数来量化。基因$g$（由术语集$A_g$注释）相对于患者表型集$S$的分数定义为$A_g$和$S$之间共享术语的IC权重之和：\n$$\n\\text{Score}(g, S) = \\sum_{t \\in A_g \\cap S} w(t)\n$$\n对于每个测试用例，我们首先计算所有$m=5$个基因相对于给定患者表型集的这些“观察分数”。\n\n**3. 通过置换检验计算经验p值**\n\n为了评估一个观察分数的统计显著性，我们将其与一个空分布进行比较。该分布通过置换检验凭经验生成。原假设$H_0$是，观察到的高分基因是由于偶然性造成的。\n\n程序如下：\n- 对于一个给定的大小为$|S|=k$的患者表型集$S$，我们生成大量的随机表型集$S^\\ast$，数量为$M$。\n- 每个随机集$S^\\ast$的生成旨在模拟在指定空模型下随机抽取的集合的属性。具体来说，每个$S^\\ast$与原始集$S$具有相同的基数$k$。$S^\\ast$中的术语是从$N=8$个术语的全集中不放回抽取的，其中选择任何术语$t_i$的概率与其频率$f(t_i)$成正比。由于给定的频率总和为$1$，它们被直接用作选择概率。\n- 对于$M$个生成的集合$S^\\ast$中的每一个，我们为每个基因$g$计算一个“空分数”：$\\text{Score}(g, S^\\ast)$。这样，每个$m$个基因都得到$M$个空分数，为每个基因的分数形成一个经验空分布。\n- 基因$g$的经验p值是至少与观察分数一样极端的空分数的比例。为了避免p值为零并提供更稳定的估计，应用了单一计数连续性校正。p值的公式为：\n$$\np_g = \\frac{C_g + 1}{M + 1}\n$$\n其中$C_g$是$\\text{Score}(g, S^\\ast) \\ge \\text{Score}(g, S)$的置换次数。这个过程产生一个包含$m=5$个p值的向量，每个基因一个。\n\n**4. 使用Benjamini-Hochberg（BH）控制错误发现率（FDR）**\n\n当执行多重假设检验时（每个基因一次），犯至少一个I类错误（假阳性）的概率会膨胀。Benjamini-Hochberg（BH）程序是一种控制错误发现率（FDR）的方法，FDR是在所有被拒绝的原假设中，假阳性的预期比例。BH程序产生校正后的p值，通常称为q值。\n\nBH程序的算法如下：\n1.  设上一步计算出的$m$个p值为$\\{p_1, p_2, \\dots, p_m\\}$。\n2.  将这些p值从小到大排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。记录这些排序值的原始索引，以便稍后恢复顺序。\n3.  对于每个有序的p值$p_{(i)}$，计算一个原始校正值：$\\frac{p_{(i)} \\cdot m}{i}$。\n4.  为确保单调性（即$q_{(1)} \\le q_{(2)} \\le \\dots$），秩次为$i$的最终校正p值（表示为$q_{(i)}$）被调整为所有秩次大于或等于$i$的原始校正值中的最小值。这是通过从最大秩次（$m$）到最小秩次（$1$）遍历原始校正值来计算的：\n    $$\n    q_{(i)} = \\min(q_{(i+1)}, \\frac{p_{(i)} \\cdot m}{i}) \\quad \\text{for } i = m-1, \\dots, 1, \\quad \\text{with } q_{(m)} = \\frac{p_{(m)} \\cdot m}{m}\n    $$\n5.  将所有得到的q值上限设为1.0。因此，最终值为$q'_{(i)} = \\min(1.0, q_{(i)})$。\n6.  计算出的q值$\\{q'_{(1)}, \\dots, q'_{(m)}\\}$然后根据原始基因顺序$[A, B, C, D, E]$重新排序。\n\n**5. 算法实现**\n\n整个过程在一个单独的程序中实现。使用固定的种子42初始化一个伪随机数生成器，以确保置换检验的可复现性。程序遍历四个指定的测试用例中的每一个。对于每个案例，它执行观察评分、通过置换检验找到p值以及通过BH校正找到q值的步骤。最终的q值四舍五入到6位小数，并格式化为所需的输出结构。使用NumPy有助于进行高效的基于数组的计算，用于评分、置换和统计调整。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes empirical p-values and Benjamini-Hochberg adjusted q-values\n    for gene-phenotype associations.\n    \"\"\"\n    \n    # --- 1. Data Initialization and Pre-computation ---\n\n    # HPO term frequencies\n    frequencies = np.array([0.25, 0.12, 0.06, 0.18, 0.10, 0.04, 0.09, 0.16])\n    \n    # HPO Information Content (IC) weights\n    ic_weights = -np.log(frequencies)\n    \n    # Map term names to indices (0-7)\n    term_indices = {f\"t{i+1}\": i for i in range(8)}\n    \n    # Gene annotations with term indices\n    gene_annotations_str = {\n        'A': {'t2', 't6'},\n        'B': {'t1', 't4', 't8'},\n        'C': {'t3', 't6', 't7'},\n        'D': {'t5'},\n        'E': {'t2', 't3', 't5'},\n    }\n    gene_order = ['A', 'B', 'C', 'D', 'E']\n    gene_annotations = {\n        gene: {term_indices[t] for t in annots} \n        for gene, annots in gene_annotations_str.items()\n    }\n    num_genes = len(gene_order)\n    num_terms = len(frequencies)\n    \n    # Test suite: (patient phenotype set, number of permutations)\n    test_cases_str = [\n        ({'t2', 't6', 't7'}, 4000),\n        ({'t1', 't4', 't8'}, 4000),\n        ({'t2', 't3', 't6'}, 200),\n        ({'t6'}, 1000),\n    ]\n    test_cases = [\n        ({term_indices[t] for t in s}, M) for s, M in test_cases_str\n    ]\n    \n    # Initialize a single Pseudorandom Number Generator for reproducibility\n    rng = np.random.default_rng(seed=42)\n    \n    all_results = []\n\n    # --- Process each test case ---\n    for patient_phenotypes, M in test_cases:\n        \n        # --- 2. Gene Scoring (Observed Scores) ---\n        observed_scores = np.zeros(num_genes)\n        for i, gene in enumerate(gene_order):\n            annot_set = gene_annotations[gene]\n            intersection = patient_phenotypes.intersection(annot_set)\n            if intersection:\n                observed_scores[i] = np.sum(ic_weights[list(intersection)])\n\n        # --- 3. Empirical p-value Calculation ---\n        \n        # Generate null distribution\n        null_scores = np.zeros((M, num_genes))\n        phenotype_set_size = len(patient_phenotypes)\n        \n        for k in range(M):\n            # Null model: draw terms without replacement, weighted by frequency\n            permuted_set = set(rng.choice(\n                num_terms,\n                size=phenotype_set_size,\n                replace=False,\n                p=frequencies\n            ))\n            \n            # Calculate scores for the permuted set\n            for i, gene in enumerate(gene_order):\n                annot_set = gene_annotations[gene]\n                intersection = permuted_set.intersection(annot_set)\n                if intersection:\n                    null_scores[k, i] = np.sum(ic_weights[list(intersection)])\n\n        # Calculate p-values with continuity correction\n        p_values = np.zeros(num_genes)\n        for i in range(num_genes):\n            # Count permutations with score >= observed score\n            count_extreme = np.sum(null_scores[:, i] >= observed_scores[i])\n            # Apply single-count continuity correction\n            p_values[i] = (count_extreme + 1) / (M + 1)\n\n        # --- 4. Benjamini-Hochberg FDR Control ---\n        \n        # Get sorting indices for p-values\n        p_sorted_indices = np.argsort(p_values)\n        p_sorted = p_values[p_sorted_indices]\n        \n        # Ranks from 1 to m\n        ranks = np.arange(1, num_genes + 1)\n        \n        # Calculate raw q-values\n        q_raw_sorted = p_sorted * num_genes / ranks\n        \n        # Enforce monotonicity by taking cumulative minimum from right to left\n        q_monotonic_sorted = np.minimum.accumulate(q_raw_sorted[::-1])[::-1]\n        \n        # Cap all values at 1.0\n        q_final_sorted = np.minimum(q_monotonic_sorted, 1.0)\n        \n        # Reorder q-values to original gene order\n        q_values = np.empty_like(q_final_sorted)\n        q_values[p_sorted_indices] = q_final_sorted\n        \n        # Round to 6 decimal places\n        rounded_q_values = [round(q, 6) for q in q_values]\n        \n        all_results.append(rounded_q_values)\n        \n    # --- 5. Final Output Formatting ---\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        }
    ]
}