{
    "hands_on_practices": [
        {
            "introduction": "差异基因表达分析始于两个基本步骤：对测序深度等技术差异进行归一化，以及对计数数据进行恰当的建模。本练习通过一个动手计算来揭示这些核心概念的奥秘，引导您在一个精心构建的数据集上实践比率中位数归一化方法，并接着拟合一个广义线性模型 (GLM) 。从第一性原理掌握这一过程，是理解主流生物信息学工具底层工作机制的关键。",
            "id": "4333076",
            "problem": "一个由$4$个肿瘤样本组成的队列已通过高通量测序进行了分析，得到了$5$个基因的整数读取计数。样本$\\{1,2\\}$属于条件$\\mathrm{A}$，样本$\\{3,4\\}$属于条件$\\mathrm{B}$。观测到的计数$K_{ij}$（样本$i$中的基因$j$）如下：\n\n- 基因$G_{1}$: $(75, 110, 100, 140)$\n- 基因$G_{2}$: $(225, 330, 300, 420)$\n- 基因$G_{3}$: $(45, 66, 60, 84)$\n- 基因$G_{4}$: $(150, 220, 400, 560)$\n- 基因$G_{5}$: $(90, 132, 120, 168)$\n\n假设标准的比率中位数归一化方法适用于这些数据。仅使用在所有样本中都具有严格正计数的基因，通过几何平均数法计算样本特异性的大小因子$s_{i}$：对每个基因$j$，计算其跨样本的几何平均数$g_{j}$；对每个样本$i$，计算符合条件的基因的比率$r_{ij} = K_{ij} / g_{j}$；将$s_{i}$设为这些比率的样本特异性中位数。你可以将$s_{i}$的定义保留到一个公共乘法常数为止；不要对它们进行重新缩放。\n\n然后，将这些$s_{i}$作为基因$G_{4}$的广义线性模型（GLM）中的偏移量（offset），该模型使用泊松似然和对数连接函数，拟合模型\n$$\n\\ln \\mu_{i} \\;=\\; \\ln s_{i} \\;+\\; \\beta_{0} \\;+\\; \\beta_{1}\\, x_{i},\n$$\n其中$\\mu_{i}$是样本$i$的期望计数，$x_{i} = 0$表示条件$\\mathrm{A}$，$x_{i} = 1$表示条件$\\mathrm{B}$，而$\\beta_{1}$则代表了条件对基因$G_{4}$的影响。\n\n仅从几何平均数和带对数连接的泊松GLM的核心定义出发，从第一性原理推导出$\\beta_{1}$的闭式最大似然估计量，并使用所提供的计数将其完全简化。将你的最终答案表示为单个精确的解析表达式，不进行数值舍入。不包括单位。",
            "solution": "我们从定义开始。对于在所有样本中都具有严格正计数的每个基因$j$，其跨$n=4$个样本的几何平均数定义为\n$$\ng_{j} \\;=\\; \\left(\\prod_{i=1}^{4} K_{ij}\\right)^{1/4}.\n$$\n对每个样本$i$，定义比率$r_{ij} = K_{ij}/g_{j}$并设置大小因子\n$$\ns_{i} \\;=\\; \\operatorname{median}_{j\\in\\mathcal{J}} \\left( \\frac{K_{ij}}{g_{j}} \\right),\n$$\n其中$\\mathcal{J}$索引了符合条件的基因（在所有样本中都具有严格正计数）。在这些数据中，所有$5$个基因在所有样本中都具有严格正计数，所以$\\mathcal{J} = \\{1,2,3,4,5\\}$。\n\n我们注意到给定计数中存在一个经验结构。对于基因$G_{1}, G_{2}, G_{3}, G_{5}$，其样本间的模式在基因之间是成比例的：\n- 基因$G_{1}$的跨样本比率为$(75:110:100:140)$，可简化为$(15:22:20:28)$。\n- 对于$G_{2}$，$(225:330:300:420)$也可简化为$(15:22:20:28)$。\n- 对于$G_{3}$，$(45:66:60:84)$也可简化为$(15:22:20:28)$。\n- 对于$G_{5}$，$(90:132:120:168)$也可简化为$(15:22:20:28)$。\n\n这种比例关系表明，对于$j \\in \\{1,2,3,5\\}$，计数可以写成\n$$\nK_{ij} \\;=\\; s_{i}\\, m_{j},\n$$\n对于某个不依赖于条件的样本特异性因子$s_{i}$（反映文库大小或测序深度）和基因特异性基线$m_{j}$。虽然$s_{i}$和$m_{j}$不是先验已知的，但它们的存在是由这些基因间的精确比例关系保证的。\n\n对于任何这样的基因$j \\in \\{1,2,3,5\\}$，其跨样本几何平均数为\n$$\ng_{j} \\;=\\; \\left( \\prod_{i=1}^{4} s_{i}\\, m_{j} \\right)^{1/4} \\;=\\; m_{j} \\left( \\prod_{i=1}^{4} s_{i} \\right)^{1/4}.\n$$\n因此，对于$j \\in \\{1,2,3,5\\}$，\n$$\n\\frac{K_{ij}}{g_{j}} \\;=\\; \\frac{s_{i}\\, m_{j}}{ m_{j}\\, \\left( \\prod_{i'=1}^{4} s_{i'} \\right)^{1/4} } \\;=\\; \\frac{s_{i}}{ \\left( \\prod_{i'=1}^{4} s_{i'} \\right)^{1/4} }.\n$$\n右侧不再依赖于基因索引$j$，因此对于每个样本$i$，由$G_{1}, G_{2}, G_{3}, G_{5}$贡献的四个比率是相同的，均等于$s_{i}/S_{\\mathrm{geo}}$，其中我们简写\n$$\nS_{\\mathrm{geo}} \\;=\\; \\left( \\prod_{i=1}^{4} s_{i} \\right)^{1/4}.\n$$\n\n对于基因$G_{4}$，其计数在不同条件下有所不同，这表明存在基因特异性的条件效应。观测到的元组$(150, 220, 400, 560)$保持了与上述相同的样本间比例关系，但在条件$\\mathrm{B}$中相对于条件$\\mathrm{A}$额外乘以了一个因子$2$。具体来说，我们可以写成\n$$\nK_{i,4} \\;=\\; s_{i}\\, m_{4}\\, c_{i},\n$$\n其中$c_{i} = 1$（对于$i \\in \\{1,2\\}$，条件$\\mathrm{A}$）和$c_{i} = 2$（对于$i \\in \\{3,4\\}$，条件$\\mathrm{B}$）。其几何平均数为\n$$\ng_{4} \\;=\\; \\left( \\prod_{i=1}^{4} s_{i}\\, m_{4}\\, c_{i} \\right)^{1/4} \\;=\\; m_{4}\\, \\left( \\prod_{i=1}^{4} s_{i} \\right)^{1/4} \\left( \\prod_{i=1}^{4} c_{i} \\right)^{1/4} \\;=\\; m_{4}\\, S_{\\mathrm{geo}} \\, \\left(1\\cdot 1\\cdot 2\\cdot 2\\right)^{1/4} \\;=\\; m_{4}\\, S_{\\mathrm{geo}}\\, \\sqrt{2}.\n$$\n因此，对于$G_{4}$，\n$$\n\\frac{K_{i,4}}{g_{4}} \\;=\\; \\frac{s_{i}\\, m_{4}\\, c_{i}}{ m_{4}\\, S_{\\mathrm{geo}}\\, \\sqrt{2} } \\;=\\; \\frac{s_{i}}{S_{\\mathrm{geo}}}\\, \\frac{c_{i}}{\\sqrt{2}}.\n$$\n\n汇总每个样本$i$的五个比率：\n- 其中四个（来自$G_{1}, G_{2}, G_{3}, G_{5}$）恰好是$\\dfrac{s_{i}}{S_{\\mathrm{geo}}}$。\n- 第五个（来自$G_{4}$）对于$i \\in \\{1,2\\}$是$\\dfrac{s_{i}}{S_{\\mathrm{geo}}}\\, \\dfrac{1}{\\sqrt{2}}$，对于$i \\in \\{3,4\\}$是$\\dfrac{s_{i}}{S_{\\mathrm{geo}}}\\, \\sqrt{2}$。\n\n因此，对于每个$i$，这五个值的中位数是$\\dfrac{s_{i}}{S_{\\mathrm{geo}}}$，因为四个相同的值在顺序统计量中占主导地位，而第五个值要么严格小一个因子$\\dfrac{1}{\\sqrt{2}}$，要么严格大一个因子$\\sqrt{2}$。因此计算出的大小因子是\n$$\ns_{i}^{\\ast} \\;=\\; \\frac{s_{i}}{S_{\\mathrm{geo}}}, \\quad i \\in \\{1,2,3,4\\}.\n$$\n这些$s_{i}^{\\ast}$的定义相差一个公共乘法常数$S_{\\mathrm{geo}}^{-1}$，这在下游建模中无关紧要，因为它会被截距项吸收。\n\n我们现在为基因$G_4$拟合一个带有对数连接和偏移量$\\ln s_{i}^{\\ast}$的泊松广义线性模型（GLM）。模型是\n$$\nK_{i,4} \\sim \\mathrm{Poisson}(\\mu_{i}), \\qquad \\ln \\mu_{i} \\;=\\; \\ln s_{i}^{\\ast} \\;+\\; \\beta_{0} \\;+\\; \\beta_{1}\\, x_{i},\n$$\n其中$x_{i} = 0$（对于$i \\in \\{1,2\\}$）和$x_{i} = 1$（对于$i \\in \\{3,4\\}$）。\n\n令$e_{i} = s_{i}^{\\ast}$表示偏移暴露量。定义$\\theta_{\\mathrm{A}} = \\exp(\\beta_{0})$和$\\theta_{\\mathrm{B}} = \\exp(\\beta_{0}+\\beta_{1})$。那么样本$i$的均值可以写成\n$$\n\\mu_{i} \\;=\\; \\begin{cases}\ne_{i}\\, \\theta_{\\mathrm{A}},  i \\in \\{1,2\\} \\\\\ne_{i}\\, \\theta_{\\mathrm{B}},  i \\in \\{3,4\\}.\n\\end{cases}\n$$\n对数似然函数，在不依赖于参数的加性常数$\\sum_{i} -\\ln(K_{i,4}!)$的意义下，为\n$$\n\\ell(\\theta_{\\mathrm{A}}, \\theta_{\\mathrm{B}}) \\;=\\; \\sum_{i \\in \\{1,2\\}} \\left[ K_{i,4}\\, \\ln(e_{i}\\, \\theta_{\\mathrm{A}}) - e_{i}\\, \\theta_{\\mathrm{A}} \\right] \\;+\\; \\sum_{i \\in \\{3,4\\}} \\left[ K_{i,4}\\, \\ln(e_{i}\\, \\theta_{\\mathrm{B}}) - e_{i}\\, \\theta_{\\mathrm{B}} \\right].\n$$\n通过将导数设为零分别对$\\theta_{\\mathrm{A}}$和$\\theta_{\\mathrm{B}}$进行最大化，可以得到标准的泊松暴露量加权平均值：\n$$\n\\frac{\\partial \\ell}{\\partial \\theta_{\\mathrm{A}}} \\;=\\; \\sum_{i \\in \\{1,2\\}} \\left( \\frac{K_{i,4}}{\\theta_{\\mathrm{A}}} - e_{i} \\right) \\;=\\; 0 \\;\\;\\Rightarrow\\;\\; \\widehat{\\theta}_{\\mathrm{A}} \\;=\\; \\frac{\\sum_{i \\in \\{1,2\\}} K_{i,4}}{\\sum_{i \\in \\{1,2\\}} e_{i}},\n$$\n$$\n\\frac{\\partial \\ell}{\\partial \\theta_{\\mathrm{B}}} \\;=\\; \\sum_{i \\in \\{3,4\\}} \\left( \\frac{K_{i,4}}{\\theta_{\\mathrm{B}}} - e_{i} \\right) \\;=\\; 0 \\;\\;\\Rightarrow\\;\\; \\widehat{\\theta}_{\\mathrm{B}} \\;=\\; \\frac{\\sum_{i \\in \\{3,4\\}} K_{i,4}}{\\sum_{i \\in \\{3,4\\}} e_{i}}.\n$$\n因此，条件系数的最大似然估计量是\n$$\n\\widehat{\\beta}_{1} \\;=\\; \\ln \\widehat{\\theta}_{\\mathrm{B}} \\;-\\; \\ln \\widehat{\\theta}_{\\mathrm{A}} \\;=\\; \\ln\\!\\left( \\frac{\\sum_{i \\in \\{3,4\\}} K_{i,4}}{\\sum_{i \\in \\{3,4\\}} e_{i}} \\right) \\;-\\; \\ln\\!\\left( \\frac{\\sum_{i \\in \\{1,2\\}} K_{i,4}}{\\sum_{i \\in \\{1,2\\}} e_{i}} \\right).\n$$\n\n我们现在使用提供的计数和$e_{i} = s_{i}^{\\ast} = s_{i}/S_{\\mathrm{geo}}$的结构来计算这些和。首先计算$G_4$的计数总和：\n$$\n\\sum_{i \\in \\{1,2\\}} K_{i,4} \\;=\\; 150 \\;+\\; 220 \\;=\\; 370, \\qquad \\sum_{i \\in \\{3,4\\}} K_{i,4} \\;=\\; 400 \\;+\\; 560 \\;=\\; 960.\n$$\n接下来，计算偏移量的总和。因为$s_{i}^{\\ast}$与底层的$s_i$成正比，公共因子为$S_{\\mathrm{geo}}^{-1}$，所以它们的分组总和是\n$$\n\\sum_{i \\in \\{1,2\\}} e_{i} \\;=\\; \\frac{s_{1} + s_{2}}{S_{\\mathrm{geo}}}, \\qquad \\sum_{i \\in \\{3,4\\}} e_{i} \\;=\\; \\frac{s_{3} + s_{4}}{S_{\\mathrm{geo}}}.\n$$\n公共因子$S_{\\mathrm{geo}}^{-1}$在$\\widehat{\\beta}_{1}$中被抵消了。确实，\n$$\n\\widehat{\\beta}_{1} \\;=\\; \\ln\\!\\left( \\frac{960}{(s_{3} + s_{4})/S_{\\mathrm{geo}}} \\right) \\;-\\; \\ln\\!\\left( \\frac{370}{(s_{1} + s_{2})/S_{\\mathrm{geo}}} \\right)\n\\;=\\; \\ln(960) \\;-\\; \\ln(370) \\;+\\; \\ln\\!\\left( \\frac{s_{1} + s_{2}}{s_{3} + s_{4}} \\right).\n$$\n我们直接从非差异表达基因$G_{1}, G_{2}, G_{3}, G_{5}$确定$\\dfrac{s_{1} + s_{2}}{s_{3} + s_{4}}$。对于任何这样的基因$j$，期望计数遵循$K_{ij} \\propto s_{i}$，因此分组总和的比率估计了比率$(s_{1} + s_{2})/(s_{3} + s_{4})$，而不依赖于$m_j$。为具体起见，使用$G_{1}$，\n$$\n\\frac{s_{1} + s_{2}}{s_{3} + s_{4}} \\;=\\; \\frac{K_{1,1} + K_{2,1}}{K_{3,1} + K_{4,1}} \\;=\\; \\frac{75 + 110}{100 + 140} \\;=\\; \\frac{185}{240} \\;=\\; \\frac{37}{48}.\n$$\n从$G_{2}$、$G_{3}$和$G_{5}$也可以得到相同的比率，因为它们的样本间比例关系是相同的。因此，\n$$\n\\widehat{\\beta}_{1} \\;=\\; \\ln(960) \\;-\\; \\ln(370) \\;+\\; \\ln\\!\\left( \\frac{37}{48} \\right)\n\\;=\\; \\ln\\!\\left( \\frac{960}{370} \\cdot \\frac{37}{48} \\right)\n\\;=\\; \\ln\\!\\left( \\frac{960 \\cdot 37}{370 \\cdot 48} \\right).\n$$\n我们简化这个分数：\n$$\n\\frac{960}{48} \\;=\\; 20, \\qquad \\frac{37}{370} \\;=\\; \\frac{1}{10}.\n$$\n因此，\n$$\n\\frac{960 \\cdot 37}{370 \\cdot 48} \\;=\\; 20 \\cdot \\frac{1}{10} \\;=\\; 2,\n$$\n所以\n$$\n\\widehat{\\beta}_{1} \\;=\\; \\ln(2).\n$$\n这就是在指定的归一化方法和GLM下，基因$G_{4}$的条件系数的精确闭式最大似然估计。",
            "answer": "$$\\boxed{\\ln(2)}$$"
        },
        {
            "introduction": "基因组学研究中最常见的陷阱之一是未能校正批次效应，这可能导致大量假阳性结果。本模拟练习通过生成带有已知批次效应的数据，并比较正确建模与天真忽略该效应的分析结果，有力地展示了这一原理 。通过这个练习，您将对在统计模型中包含所有相关协变量的至关重要性，获得直观且定量的理解。",
            "id": "2385475",
            "problem": "编写一个完整、可运行的程序，该程序在一个具有强批次效应的线性模型下模拟基因表达数据，并评估在差异基因表达分析中忽略批次协变量的影响。您的程序必须实现以下科学上合理且被广泛接受的基本原则，而不依赖于问题陈述中提供的任何快捷公式。\n\n使用的基本原则：\n- 在适当的转换尺度（例如，对数尺度）上，基因表达可以用带有高斯噪声的线性模型来建模。对于基因索引 $g$ 和样本索引 $i$，令 $y_{g i}$ 表示表达量。该模型包括一个基因特异性基线项、一个条件项、一个批次项和一个独立的噪声项。\n- 在高斯噪声假设下，普通最小二乘法（OLS）在正确指定的线性模型中产生无偏估计量，并为关于模型系数的假设提供在零假设下服从学生 $t$ 分布的检验统计量。\n- 对多个基因进行的多重假设检验应使用错误发现率（FDR）进行控制。使用 Benjamini–Hochberg (BH) 程序，目标水平为 $q = 0.05$。\n\n模拟设计与假设检验：\n- 所有基因共享相同的生成模型结构，并在两种生物学条件之间无真实差异表达的全局零假设下进行模拟。具体来说，对于每个基因 $g$，条件效应为 $0$；批次效应作为两个批次之间的固定偏移量在所有基因中共享；基线水平可能因基因而异；噪声在单个基因的样本间是独立同分布的高斯噪声，且方差恒定。\n- 程序必须为每个基因估计条件系数为零的零假设的双边 $p$ 值，使用以下两种模型：\n  1. 一个忽略了批次协变量的错误指定模型（仅条件分析）。\n  2. 一个包含了条件和批次协变量的正确指定模型（条件加批次分析）。\n- 在每次分析中，对所有基因应用目标水平为 $q = 0.05$ 的 Benjamini–Hochberg (BH) 程序，以获得发现的数量（由于数据是在全局零假设下模拟的，这些发现都是错误发现）。\n\n需要证明的科学原理：\n- 当条件和批次协变量相关（混杂）且批次效应很强时，忽略批次协变量会在估计的条件效应中引入偏差，并夸大错误发现的数量；而包含批次协变量则会消除偏差，并将错误发现控制在目标 FDR 水平附近。\n- 当条件和批次协变量正交时，忽略批次协变量不会在估计的条件效应中引入偏差；即使不进行校正，错误发现也应接近目标 FDR 水平。\n- 作为一个边界情况，当批次效应为零时，包含或忽略批次协变量应该会产生相似的行为。\n\n测试套件：\n在每种情况下模拟 $m = 2000$ 个基因。对 $g = 1, \\dots, m$ 使用独立的基线水平 $\\mu_g \\sim \\mathcal{N}(0, 1)$。对于每种情况，生成独立的带有 $\\sigma = 0.5$ 的高斯噪声 $\\varepsilon_{g i} \\sim \\mathcal{N}(0, \\sigma^2)$。\n\n将两种条件的二元条件协变量编码为 $x_i \\in \\{0, 1\\}$，将两种批次的二元批次协变量编码为 $z_i \\in \\{0, 1\\}$。批次偏移是一个常数 $\\gamma$，当 $z_i = 1$ 时加入，当 $z_i = 0$ 时为 $0$。所有基因的真实条件效应均为 $0$。使用以下三种情况，每种情况都有指定的跨条件和批次的样本构成：\n- 情况 $1$（高度混杂，强批次效应）：批次 $1$ 有 $19$ 个来自条件 $0$ 的样本和 $1$ 个来自条件 $1$ 的样本；批次 $2$ 有 $1$ 个来自条件 $0$ 的样本和 $19$ 个来自条件 $1$ 的样本；$\\gamma = 1.5$；总样本数 $n = 40$。\n- 情况 $2$（正交设计，强批次效应）：批次 $1$ 有 $10$ 个来自条件 $0$ 的样本和 $10$ 个来自条件 $1$ 的样本；批次 $2$ 有 $10$ 个来自条件 $0$ 的样本和 $10$ 个来自条件 $1$ 的样本；$\\gamma = 1.5$；总样本数 $n = 40$。\n- 情况 $3$（高度混杂，无批次效应）：批次 $1$ 有 $9$ 个来自条件 $0$ 的样本和 $1$ 个来自条件 $1$ 的样本；批次 $2$ 有 $1$ 个来自条件 $0$ 的样本和 $9$ 个来自条件 $1$ 的样本；$\\gamma = 0.0$；总样本数 $n = 20$。\n\n随机性与可复现性：\n- 使用固定的随机种子 $20240513$ 来初始化情况 $1$ 的生成器。对于情况 $2$ 和 $3$，您必须将情况索引添加到基础种子中（即 $20240513 + 2$ 和 $20240513 + 3$），以确保各情况之间的独立性，同时保持可复现性。\n\n统计分析要求：\n- 对于每个基因和每种情况，使用以下模型计算检验条件系数等于 $0$ 的零假设的双边 $p$ 值：\n  1. 一个带截距的仅条件线性模型。\n  2. 一个带截距的条件加批次线性模型。\n- 在每次分析中，对 $m$ 个 $p$ 值的集合使用水平为 $q = 0.05$ 的 Benjamini–Hochberg (BH) 程序，以确定发现（拒绝原假设）的数量。由于根据设计，所有零假设均为真，因此每个发现都是一个假阳性。报告两种分析的发现数量。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含 $6$ 个用逗号分隔的整数，并用方括号括起来，顺序如下：$[\\text{case1\\_naive}, \\text{case1\\_adjusted}, \\text{case2\\_naive}, \\text{case2\\_adjusted}, \\text{case3\\_naive}, \\text{case3\\_adjusted}]$，其中“naive”表示仅条件分析，“adjusted”表示条件加批次分析。\n\n无外部输入：\n- 程序必须完全自包含，不得读取任何输入或文件，也不得访问任何网络资源。所有数值必须如上所述进行硬编码。\n\n角度单位和物理单位：\n- 不涉及角度或物理单位。\n\n答案类型：\n- 报告的 $6$ 个值中的每一个都必须是整数。\n\n您的目标是实现模拟和分析，以便输出通过这些测试用例证明，在差异基因表达分析中，忽略一个强的、混杂的批次效应如何夸大错误发现，而包含批次指示符则可以恢复有效的推断。",
            "solution": "所提出的问题是计算统计学中一个有效的、适定的练习，旨在展示分析高通量生物数据时的一个关键原则：遗漏变量偏差的危险。具体背景是差异基因表达分析，其中未测量或未建模的技术因素（如实验批次）可能会混淆感兴趣的生物信号。该问题具有科学依据，使用了标准的线性模型、普通最小二乘法（OLS）、学生 $t$ 检验以及用于错误发现率（FDR）控制的 Benjamini-Hochberg (BH) 程序，这些都是该领域的基础方法。模拟参数被明确指定，确保了问题的自包含性和可复现性。我们将开始进行解答。\n\n问题的核心在于通用线性模型，我们将其对单个基因写成矩阵形式 $Y = X\\beta + \\epsilon$。在这里，$Y$ 是一个 $n \\times 1$ 的向量，表示 $n$ 个样本的表达量测量值；$X$ 是一个 $n \\times p$ 的设计矩阵，为 $p$ 个参数编码实验协变量；$\\beta$ 是一个 $p \\times 1$ 的待估计系数向量；$\\epsilon$ 是一个 $n \\times 1$ 的独立同分布误差项向量，假设服从高斯分布 $\\mathcal{N}(0, \\sigma^2)$。\n\n数据是在“全局零假设”情景下模拟的，这意味着没有真正的差异表达。对于 $m=2000$ 个基因中的每一个（由 $g$ 索引）和 $n$ 个样本中的每一个（由 $i$ 索引），表达量 $y_{gi}$ 根据真实模型生成：\n$$y_{gi} = \\mu_g + \\gamma z_i + \\varepsilon_{gi}$$\n其中 $\\mu_g \\sim \\mathcal{N}(0, 1)$ 是基因特异性基线表达，$\\gamma$ 是批次效应的大小，$z_i \\in \\{0, 1\\}$ 是批次指示协变量，而 $\\varepsilon_{gi} \\sim \\mathcal{N}(0, \\sigma^2)$ 是噪声项，其中 $\\sigma=0.5$。生物学条件的真实系数为零。\n\n我们将使用两种不同的模型为每个基因分析这些模拟数据：\n\n1.  一个**错误指定或“朴素”模型**，它忽略了批次协变量：$y_{gi} = \\beta_{g0} + \\beta_{g1} x_i + e_{gi}$。设计矩阵 $X_{\\text{naive}}$ 有两列：一个截距（一个全为1的向量）和条件协变量向量 $x$。我们检验零假设 $H_0: \\beta_{g1} = 0$。\n\n2.  一个**正确指定或“校正”模型**，它包含了批次协变量：$y_{gi} = \\beta'_{g0} + \\beta'_{g1} x_i + \\beta'_{g2} z_i + e'_{gi}$。设计矩阵 $X_{\\text{adj}}$ 有三列：一个截距、条件向量 $x$ 和批次向量 $z$。我们检验零假设 $H_0: \\beta'_{g1} = 0$。\n\n对于这两种模型，系数 $\\beta$ 都使用普通最小二乘法（OLS）进行估计，其解为 $\\hat{\\beta} = (X^T X)^{-1}X^T Y$。这可以同时对所有 $m$ 个基因进行高效求解。\n\n为了检验条件系数 $\\hat{\\beta}_1$（其中下标 $1$ 表示条件协变量 $x$ 的系数）的显著性，我们计算学生 $t$ 统计量：\n$$t = \\frac{\\hat{\\beta}_1}{\\text{SE}(\\hat{\\beta}_1)}$$\n标准误 $\\text{SE}(\\hat{\\beta}_1)$ 是该系数估计量的估计方差的平方根。估计量的方差-协方差矩阵由 $\\text{Var}(\\hat{\\beta}) = \\sigma^2 (X^T X)^{-1}$ 给出。我们用其无偏估计量，即均方误差来估计未知的误差方差 $\\sigma^2$：\n$$\\hat{\\sigma}^2 = \\frac{1}{n-p} \\sum_{i=1}^n (y_i - \\hat{y}_i)^2 = \\frac{\\text{RSS}}{n-p}$$\n其中 $\\hat{y}_i$ 是模型的拟合值，$\\text{RSS}$ 是残差平方和，$n$ 是样本数，$p$ 是模型中的参数数量（$X$ 的列数）。令 $C = (X^T X)^{-1}$。$\\hat{\\beta}_1$ 的具体方差为 $\\hat{\\sigma}^2 C_{11}$（假设条件协变量是 $X$ 的第二列，索引为 $1$）。因此，标准误为 $\\text{SE}(\\hat{\\beta}_1) = \\sqrt{\\hat{\\sigma}^2 C_{11}}$。在零假设下，这个 $t$ 统计量服从具有 $n-p$ 个自由度的学生 $t$ 分布。根据此分布，我们为每个基因计算一个双边 $p$ 值。\n\n由于我们要对每个基因进行一次假设检验，总共进行 $m=2000$ 次，我们必须进行多重检验校正以控制错误发现的数量。我们将使用 Benjamini-Hochberg (BH) 程序，目标错误发现率（FDR）为 $q = 0.05$。该程序如下：\n1.  将 $m$ 个 $p$ 值按升序排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。\n2.  找到满足 $p_{(k)} \\le \\frac{k}{m} q$ 的最大整数 $k$。\n3.  如果存在这样的 $k$，则拒绝所有对应于 $p_{(1)}, \\dots, p_{(k)}$ 的检验的零假设。发现的数量为 $k$。如果不存在这样的 $k$，则不拒绝任何假设，发现数量为 $0$。\n\n我们将对三种指定的情况实施这整个过程，这些情况在实验设计（混杂 vs. 正交）和批次效应的强度上有所不同。\n\n-   **情况 1 (混杂):** 条件和批次协变量强相关。当批次效应 $\\gamma$ 很大时，忽略批次协变量 $z$ 将导致对条件系数 $\\beta_1$ 的有偏估计。这种被称为遗漏变量偏差的偏差，与真实批次效应以及批次和条件协变量之间的相关性成正比。这种偏差会系统地将估计的条件效应从零移开，导致大量的小 $p$ 值，并在朴素分析中造成错误发现数量的大幅膨胀。而校正模型通过考虑 $z$ 来消除这种偏差，并提供有效的推断，错误发现的数量将被恰当地控制在预期水平附近。\n\n-   **情况 2 (正交):** 条件和批次协变量不相关（正交设计）。在这种情况下，遗漏变量偏差项为零。因此，即使存在强烈的批次效应，朴素模型中条件系数的估计仍然是无偏的。预计朴素分析和校正分析都能正确地控制错误发现率。\n\n-   **情况 3 (混杂，无批次效应):** 设计与情况 1 一样是混杂的，但批次效应大小 $\\gamma$ 为零。遗漏变量偏差与 $\\gamma$ 成正比，因此如果 $\\gamma=0$，则没有偏差。朴素模型和校正模型都应该能正确执行，结果与情况 2 类似。\n\n该程序将系统地执行这些模拟，为每种情况执行朴素和校正两种分析，应用 BH 程序，并报告由此产生的错误发现数量，从而定量地证明这些基本的统计学原理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation suite and print the final results.\n    \"\"\"\n\n    # Global parameters\n    m = 2000  # Number of genes\n    sigma = 0.5  # Noise standard deviation\n    q_level = 0.05  # Target FDR level for BH procedure\n\n    # Case 1: High confounding, strong batch\n    case1_params = {\n        'n_cond0_batch1': 19, 'n_cond1_batch1': 1,\n        'n_cond0_batch2': 1, 'n_cond1_batch2': 19\n    }\n    case1_gamma = 1.5\n    case1_seed = 20240513\n    \n    # Case 2: Orthogonal design, strong batch\n    case2_params = {\n        'n_cond0_batch1': 10, 'n_cond1_batch1': 10,\n        'n_cond0_batch2': 10, 'n_cond1_batch2': 10\n    }\n    case2_gamma = 1.5\n    case2_seed = 20240513 + 2\n\n    # Case 3: High confounding, no batch effect\n    case3_params = {\n        'n_cond0_batch1': 9, 'n_cond1_batch1': 1,\n        'n_cond0_batch2': 1, 'n_cond1_batch2': 9\n    }\n    case3_gamma = 0.0\n    case3_seed = 20240513 + 3\n    \n    test_cases = [\n        (case1_params, case1_gamma, m, sigma, q_level, case1_seed),\n        (case2_params, case2_gamma, m, sigma, q_level, case2_seed),\n        (case3_params, case3_gamma, m, sigma, q_level, case3_seed),\n    ]\n\n    results = []\n    for params in test_cases:\n        naive_discoveries, adjusted_discoveries = run_simulation(*params)\n        results.extend([naive_discoveries, adjusted_discoveries])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(case_params, gamma, m, sigma, q, seed):\n    \"\"\"\n    Runs a single simulation case.\n    \n    Generates data, performs naive and adjusted analyses, and returns the number of discoveries for each.\n    \"\"\"\n    np.random.seed(seed)\n\n    # 1. Construct design vectors (x for condition, z for batch)\n    n01 = case_params['n_cond0_batch1']\n    n11 = case_params['n_cond1_batch1']\n    n02 = case_params['n_cond0_batch2']\n    n12 = case_params['n_cond1_batch2']\n    \n    n_batch1 = n01 + n11\n    n_batch2 = n02 + n12\n    n = n_batch1 + n_batch2\n\n    x = np.array([0]*n01 + [1]*n11 + [0]*n02 + [1]*n12)\n    z = np.array([0]*n_batch1 + [1]*n_batch2)\n\n    # 2. Generate gene expression data\n    # True model: y = mu + gamma*z + noise\n    mu_g = np.random.normal(0, 1, size=(m, 1))\n    noise = np.random.normal(0, sigma, size=(m, n))\n    Y = mu_g + gamma * z[np.newaxis, :] + noise\n\n    # 3. Define design matrices\n    X_naive = np.vstack([np.ones(n), x]).T\n    X_adjusted = np.vstack([np.ones(n), x, z]).T\n\n    # 4. Perform analyses and get discovery counts\n    naive_discoveries = perform_analysis(Y, X_naive, q)\n    adjusted_discoveries = perform_analysis(Y, X_adjusted, q)\n\n    return naive_discoveries, adjusted_discoveries\n\ndef perform_analysis(Y, X, q):\n    \"\"\"\n    Performs OLS regression and multiple testing correction for a set of genes.\n    \"\"\"\n    n, p = X.shape # n = samples, p = parameters\n    m = Y.shape[0] # m = genes\n    \n    # 1. Fit linear model for all genes at once using np.linalg.lstsq\n    # Y is (m, n), X is (n, p). We need to solve X @ B.T = Y.T for B.\n    # B will be (m, p). lstsq returns coefficients as (p, m).\n    beta_hat, rss_per_gene, _, _ = np.linalg.lstsq(X, Y.T, rcond=None)\n\n    # 2. Calculate t-statistics for the condition coefficient (at index 1)\n    df = n - p\n    sigma_sq_hat = rss_per_gene / df\n    \n    # The variance of beta_hat is diag(inv(X'X)) * sigma_hat^2\n    # We are interested in the coefficient for the condition 'x', which is at index 1\n    C = np.linalg.inv(X.T @ X)\n    se_beta1 = np.sqrt(sigma_sq_hat * C[1, 1])\n\n    # Avoid division by zero if standard error is somehow zero\n    # This should not happen in this problem's setup\n    t_stats = np.zeros(m)\n    valid_se = se_beta1 > 0\n    t_stats[valid_se] = beta_hat[1, valid_se] / se_beta1[valid_se]\n    \n    # 3. Calculate two-sided p-values\n    p_values = 2 * t.sf(np.abs(t_stats), df=df)\n\n    # 4. Apply Benjamini-Hochberg procedure\n    num_discoveries = bh_procedure(p_values, q)\n    \n    return num_discoveries\n\ndef bh_procedure(p_values, q):\n    \"\"\"\n    Applies the Benjamini-Hochberg procedure to control FDR.\n    \"\"\"\n    m = len(p_values)\n    if m == 0:\n        return 0\n        \n    p_values_sorted = np.sort(p_values)\n    ranks = np.arange(1, m + 1)\n    thresholds = (ranks / m) * q\n    \n    # Find all p-values that are below the BH threshold\n    significant_mask = p_values_sorted = thresholds\n    \n    if np.any(significant_mask):\n        # The number of discoveries is the rank of the last p-value\n        # that is below its threshold\n        k = np.max(np.where(significant_mask))\n        num_discoveries = k + 1\n    else:\n        num_discoveries = 0\n        \n    return num_discoveries\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "当同时检验数千个基因时，纯粹由偶然性导致显著结果的概率成为一个主要问题。为解决此问题，我们必须调整显著性阈值以控制假阳性的比例，这一概念由错误发现率 (FDR) 来量化。本练习提供了一个直接的机会，让您将最常用的 FDR 控制方法——Benjamini-Hochberg 程序——应用于一个来自真实药物基因组学研究的$p$值列表 。",
            "id": "4333017",
            "problem": "在一项用于精准肿瘤学分层的靶向药物基因组学检测中，使用负二项广义线性模型评估一个由 $12$ 个预先指定的基因组成的子集，在治疗响应组和非响应组之间的差异表达。基因水平的假设检验产生一个p值向量 $\\mathbf{p} \\in [0,1]^{12}$，其中较小的p值提供了更强的证据来反驳无差异表达的原假设。在此背景下，目标是使用Benjamini-Hochberg (BH) 程序来控制错误发现率 (FDR)，FDR定义为在被拒绝的原假设集合中，假阳性所占的期望比例。Benjamini-Hochberg (BH) 程序提供了校正后的值，通常称为q值。这些q值相对于排序后的p值是单调不减的，并被解释为将每个基因判定为显著所需的最小FDR水平。\n\n假设基因水平的检验统计量是独立的或表现出正回归依赖性，在此条件下，已知BH程序能将FDR控制在目标水平。按给定顺序由基因 $G_{1},G_{2},\\dots,G_{12}$ 索引的p值向量为\n$$\n\\mathbf{p} = \\big(0.0008,\\;0.013,\\;0.22,\\;0.051,\\;0.004,\\;0.17,\\;0.089,\\;0.0003,\\;0.74,\\;0.032,\\;0.0065,\\;0.41\\big).\n$$\n使用Benjamini-Hochberg (BH) 程序，计算所有12个基因经BH校正后的q值，并确定在FDR水平 $q=0.05$ 时哪些基因是显著的。将每个经BH校正的q值四舍五入到四位有效数字。按升序报告显著基因的索引作为最终答案。",
            "solution": "该问题具有科学依据、提法明确且客观。它提供了一组来自真实药物基因组学实验的标准p值，并要求应用Benjamini-Hochberg (BH) 程序，这是基因组学中多重假设检验的基石。所有必要的数据和条件都已提供，任务明确。该问题是有效的。\n\nBenjamini-Hochberg (BH) 程序用于在执行多个同步假设检验时控制错误发现率 (FDR)。该程序为每个假设计算一个校正后的p值，通常称为q值。\n\n假设（基因）的总数为 $m=12$。给定的p值向量为：\n$$\n\\mathbf{p} = \\big(0.0008,\\;0.013,\\;0.22,\\;0.051,\\;0.004,\\;0.17,\\;0.089,\\;0.0003,\\;0.74,\\;0.032,\\;0.0065,\\;0.41\\big)\n$$\n对应的基因索引为 $G_{1}, G_{2}, \\dots, G_{12}$。\n\n第一步是将p值按升序排序。设 $p_{(i)}$ 为第 $i$ 小的p值。我们必须记录每个p值的原始索引。\n排序后的p值为：\n- $p_{(1)} = 0.0003$ (来自 $G_8$)\n- $p_{(2)} = 0.0008$ (来自 $G_1$)\n- $p_{(3)} = 0.004$ (来自 $G_5$)\n- $p_{(4)} = 0.0065$ (来自 $G_{11}$)\n- $p_{(5)} = 0.013$ (来自 $G_2$)\n- $p_{(6)} = 0.032$ (来自 $G_{10}$)\n- $p_{(7)} = 0.051$ (来自 $G_4$)\n- $p_{(8)} = 0.089$ (来自 $G_7$)\n- $p_{(9)} = 0.17$ (来自 $G_6$)\n- $p_{(10)} = 0.22$ (来自 $G_3$)\n- $p_{(11)} = 0.41$ (来自 $G_{12}$)\n- $p_{(12)} = 0.74$ (来自 $G_9$)\n\n对于第 $i$ 个排序后的p值 $p_{(i)}$，其经BH校正的q值由以下公式给出：\n$$\nq_{(i)} = \\min_{k=i}^{m} \\left( \\frac{m \\cdot p_{(k)}}{k} \\right)\n$$\n这个公式确保了q值序列 $q_{(1)}, q_{(2)}, \\dots, q_{(m)}$ 是单调不减的。\n一种实用的计算方法是，首先为每个排名 $i=1, \\dots, m$ 计算值 $q'_{i} = \\frac{m \\cdot p_{(i)}}{i}$。然后，为强制单调性，从列表末尾开始取累积最小值来计算最终的q值：$q_{(m)} = q'_{m}$，且对于 $i = m-1, \\dots, 1$，$q_{(i)} = \\min(q'_{i}, q_{(i+1)})$。\n\n当 $m=12$ 时，我们计算 $q'_{i}$ 值：\n- $q'_{1} = \\frac{12 \\times 0.0003}{1} = 0.0036$\n- $q'_{2} = \\frac{12 \\times 0.0008}{2} = 0.0048$\n- $q'_{3} = \\frac{12 \\times 0.004}{3} = 0.016$\n- $q'_{4} = \\frac{12 \\times 0.0065}{4} = 0.0195$\n- $q'_{5} = \\frac{12 \\times 0.013}{5} = 0.0312$\n- $q'_{6} = \\frac{12 \\times 0.032}{6} = 0.064$\n- $q'_{7} = \\frac{12 \\times 0.051}{7} \\approx 0.08742857$\n- $q'_{8} = \\frac{12 \\times 0.089}{8} = 0.1335$\n- $q'_{9} = \\frac{12 \\times 0.17}{9} \\approx 0.22666667$\n- $q'_{10} = \\frac{12 \\times 0.22}{10} = 0.264$\n- $q'_{11} = \\frac{12 \\times 0.41}{11} \\approx 0.44727273$\n- $q'_{12} = \\frac{12 \\times 0.74}{12} = 0.74$\n\n现在我们强制执行单调性条件：\n- $q_{(12)} = q'_{12} = 0.74$\n- $q_{(11)} = \\min(q'_{11}, q_{(12)}) = \\min(0.44727..., 0.74) = 0.44727...$\n- $q_{(10)} = \\min(q'_{10}, q_{(11)}) = \\min(0.264, 0.44727...) = 0.264$\n- $q_{(9)} = \\min(q'_{9}, q_{(10)}) = \\min(0.22666..., 0.264) = 0.22666...$\n- $q_{(8)} = \\min(q'_{8}, q_{(9)}) = \\min(0.1335, 0.22666...) = 0.1335$\n- $q_{(7)} = \\min(q'_{7}, q_{(8)}) = \\min(0.08742..., 0.1335) = 0.08742...$\n- $q_{(6)} = \\min(q'_{6}, q_{(7)}) = \\min(0.064, 0.08742...) = 0.064$\n- $q_{(5)} = \\min(q'_{5}, q_{(6)}) = \\min(0.0312, 0.064) = 0.0312$\n- $q_{(4)} = \\min(q'_{4}, q_{(5)}) = \\min(0.0195, 0.0312) = 0.0195$\n- $q_{(3)} = \\min(q'_{3}, q_{(4)}) = \\min(0.016, 0.0195) = 0.016$\n- $q_{(2)} = \\min(q'_{2}, q_{(3)}) = \\min(0.0048, 0.016) = 0.0048$\n- $q_{(1)} = \\min(q'_{1}, q_{(2)}) = \\min(0.0036, 0.0048) = 0.0036$\n\n将得到的q值映射回原始基因索引，并四舍五入到四位有效数字，结果如下：\n- $G_1$ (排名第2): $q = 0.004800$\n- $G_2$ (排名第5): $q = 0.03120$\n- $G_3$ (排名第10): $q = 0.2640$\n- $G_4$ (排名第7): $q = 0.08743$\n- $G_5$ (排名第3): $q = 0.01600$\n- $G_6$ (排名第9): $q = 0.2267$\n- $G_7$ (排名第8): $q = 0.1335$\n- $G_8$ (排名第1): $q = 0.003600$\n- $G_9$ (排名第12): $q = 0.7400$\n- $G_{10}$ (排名第6): $q = 0.06400$\n- $G_{11}$ (排名第4): $q = 0.01950$\n- $G_{12}$ (排名第11): $q = 0.4473$\n\n如果一个基因的q值小于或等于指定的FDR水平，即 $q \\le 0.05$，则该基因被认为是显著的。我们为每个基因检查此条件：\n- $G_1$: $0.004800 \\le 0.05$ (显著)\n- $G_2$: $0.03120 \\le 0.05$ (显著)\n- $G_3$: $0.2640  0.05$ (不显著)\n- $G_4$: $0.08743  0.05$ (不显著)\n- $G_5$: $0.01600 \\le 0.05$ (显著)\n- $G_6$: $0.2267  0.05$ (不显著)\n- $G_7$: $0.1335  0.05$ (不显著)\n- $G_8$: $0.003600 \\le 0.05$ (显著)\n- $G_9$: $0.7400  0.05$ (不显著)\n- $G_{10}$: $0.06400  0.05$ (不显著)\n- $G_{11}$: $0.01950 \\le 0.05$ (显著)\n- $G_{12}$: $0.4473  0.05$ (不显著)\n\n显著基因的索引是 $1$、$2$、$5$、$8$ 和 $11$。问题要求按升序报告这些索引。\n显著基因索引的集合是 $\\{1, 2, 5, 8, 11\\}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  2  5  8  11\n\\end{pmatrix}\n}\n$$"
        }
    ]
}