{
    "hands_on_practices": [
        {
            "introduction": "在深入研究个体化药物剂量调整之前，理解相关基因变异在特定人群中的分布频率至关重要。哈迪-温伯格平衡（Hardy-Weinberg Equilibrium, HWE）原理是群体遗传学中的基石，它使我们能够根据等位基因频率预测基因型频率。这项练习  提供了将HWE应用于一个多等位基因位点的实践机会，这是理解药物基因组学变异的公共卫生意义和设计临床研究所需的一项关键技能。",
            "id": "4395976",
            "problem": "一个正在接受华法林治疗基因分型的大型欧洲血统队列被筛选，以检测细胞色素P450家族2亚家族C成员9（Cytochrome P450 Family 2 Subfamily C Member 9, CYP2C9）的功能减退等位基因CYP2C9*2和CYP2C9*3，已知这些等位基因会降低华法林的代谢清除率。为进行本分析，假设该基因座在此种群中为三等位基因，分别为CYP2C9*1（野生型）、CYP2C9*2和CYP2C9*3，并且该种群满足哈代-温伯格平衡（Hardy–Weinberg equilibrium, HWE）的各项假设，即随机交配、无选择、无迁移、无突变和种群规模庞大。设CYP2C9*2的等位基因频率为 $p_{\\ast 2} = 0.12$，CYP2C9*3的等位基因频率为 $p_{\\ast 3} = 0.06$；假设野生型等位基因频率为 $p_{\\ast 1} = 1 - p_{\\ast 2} - p_{\\ast 3}$，并且该基因座不存在其他等位基因。\n\n仅从作为配子随机结合和大数定律结果的哈代-温伯格原理出发，推导仅由两个功能减退等位基因构成的三种二倍体型（CYP2C9*2/*2、CYP2C9*2/*3 和 CYP2C9*3/*3）的预期基因型概率，并用 $p_{\\ast 2}$ 和 $p_{\\ast 3}$ 表示。然后，使用给定的等位基因频率计算它们的数值。\n\n按 (CYP2C9*2/*2, CYP2C9*2/*3, CYP2C9*3/*3) 的顺序，以行矩阵形式报告您的最终答案。将每个条目四舍五入至四位有效数字。将最终值表示为无单位的小数。",
            "solution": "此问题有效。其前提具有科学合理性，问题本身阐述清晰，并为获得唯一解提供了所有必要信息。\n\n问题要求计算在一个假定处于哈代-温伯格平衡（Hardy-Weinberg equilibrium, HWE）的种群中，`CYP2C9` 基因座上三种特定二倍体型的预期基因型概率。该基因座被视为三等位基因，分别为 `CYP2C9*1`（野生型）、`CYP2C9*2`（功能减退型）和 `CYP2C9*3`（功能减退型）。设它们在种群基因库中的各自频率为 $p_{\\ast 1}$、$p_{\\ast 2}$ 和 $p_{\\ast 3}$。问题提供了两个功能减退等位基因的频率：$p_{\\ast 2} = 0.12$ 和 $p_{\\ast 3} = 0.06$。根据定义，一个基因座上所有等位基因的频率之和必须为1，因此 $p_{\\ast 1} + p_{\\ast 2} + p_{\\ast 3} = 1$。\n\n哈代-温伯格原理指出，如果一个种群规模庞大、随机交配，并且不受突变、迁移和选择等进化因素的影响，那么其等位基因频率和基因型频率将代代保持不变。在这些假设下，一个多等位基因座的基因型频率由等位基因频率之和的平方的多项式展开项给出。对于一个三等位基因系统，即为 $(p_{\\ast 1} + p_{\\ast 2} + p_{\\ast 3})^2$ 的展开式。\n\n$$ (p_{\\ast 1} + p_{\\ast 2} + p_{\\ast 3})^2 = p_{\\ast 1}^2 + p_{\\ast 2}^2 + p_{\\ast 3}^2 + 2p_{\\ast 1}p_{\\ast 2} + 2p_{\\ast 1}p_{\\ast 3} + 2p_{\\ast 2}p_{\\ast 3} $$\n\n此展开式中的每一项代表一个特定基因型的预期频率：\n- $P(\\text{CYP2C9*1/*1}) = p_{\\ast 1}^2$\n- $P(\\text{CYP2C9*2/*2}) = p_{\\ast 2}^2$\n- $P(\\text{CYP2C9*3/*3}) = p_{\\ast 3}^2$\n- $P(\\text{CYP2C9*1/*2}) = 2p_{\\ast 1}p_{\\ast 2}$\n- $P(\\text{CYP2C9*1/*3}) = 2p_{\\ast 1}p_{\\ast 3}$\n- $P(\\text{CYP2C9*2/*3}) = 2p_{\\ast 2}p_{\\ast 3}$\n\n这些公式是直接从配子随机结合原理推导出来的。对于二倍体生物，个体的基因型由一个父源配子和一个母源配子的随机组合形成。\n\n题目要求我们推导仅由功能减退等位基因构成的三种基因型（`CYP2C9*2/*2`、`CYP2C9*2/*3` 和 `CYP2C9*3/*3`）的预期概率。\n\n1.  **`CYP2C9*2/*2` 基因型的概率：**\n    这是一个纯合基因型。个体从父源配子遗传一个 `*2` 等位基因（概率为 $p_{\\ast 2}$），并从母源配子遗传一个 `*2` 等位基因（概率也为 $p_{\\ast 2}$）。由于这些是独立事件，两者同时发生的概率是它们各自概率的乘积。\n    $$ P(\\text{CYP2C9*2/*2}) = p_{\\ast 2} \\times p_{\\ast 2} = p_{\\ast 2}^2 $$\n\n2.  **`CYP2C9*3/*3` 基因型的概率：**\n    这也是一个纯合基因型。根据同样的逻辑，遗传两个 `*3` 等位基因的概率是它们频率的乘积。\n    $$ P(\\text{CYP2C9*3/*3}) = p_{\\ast 3} \\times p_{\\ast 3} = p_{\\ast 3}^2 $$\n\n3.  **`CYP2C9*2/*3` 基因型的概率：**\n    这是一个复合杂合基因型。形成此基因型有两种方式：\n    a) 从父源配子遗传 `*2`（概率为 $p_{\\ast 2}$），并从母源配子遗传 `*3`（概率为 $p_{\\ast 3}$）。此组合的概率为 $p_{\\ast 2}p_{\\ast 3}$。\n    b) 从父源配子遗传 `*3`（概率为 $p_{\\ast 3}$），并从母源配子遗传 `*2`（概率为 $p_{\\ast 2}$）。此组合的概率为 $p_{\\ast 3}p_{\\ast 2}$。\n    由于这两种情况是互斥的，`*2/*3` 基因型的总概率是它们概率的总和。\n    $$ P(\\text{CYP2C9*2/*3}) = p_{\\ast 2}p_{\\ast 3} + p_{\\ast 3}p_{\\ast 2} = 2p_{\\ast 2}p_{\\ast 3} $$\n\n因此，推导出的表达式为：`CYP2C9*2/*2` 的概率为 $p_{\\ast 2}^2$，`CYP2C9*2/*3` 的概率为 $2p_{\\ast 2}p_{\\ast 3}$，`CYP2C9*3/*3` 的概率为 $p_{\\ast 3}^2$。\n\n现在我们使用给定的等位基因频率 $p_{\\ast 2} = 0.12$ 和 $p_{\\ast 3} = 0.06$ 来计算数值。结果必须四舍五入到四位有效数字。\n\n- 对于 `CYP2C9*2/*2`:\n  $$ P(\\text{CYP2C9*2/*2}) = (0.12)^2 = 0.0144 $$\n  为了用四位有效数字表示，我们在末尾加一个零：$0.01440$。\n\n- 对于 `CYP2C9*2/*3`:\n  $$ P(\\text{CYP2C9*2/*3}) = 2 \\times 0.12 \\times 0.06 = 2 \\times 0.0072 = 0.0144 $$\n  为了用四位有效数字表示，我们在末尾加一个零：$0.01440$。\n\n- 对于 `CYP2C9*3/*3`:\n  $$ P(\\text{CYP2C9*3/*3}) = (0.06)^2 = 0.0036 $$\n  为了用四位有效数字表示，我们在末尾加两个零：$0.003600$。\n\n最终答案按指定顺序以这三个概率的行矩阵形式呈现。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0.01440  0.01440  0.003600 \\end{pmatrix} } $$"
        },
        {
            "introduction": "在掌握了群体频率之后，我们的焦点转向个体层面：特定的`CYP2C9`和`VKORC1`基因变异如何定量地影响华法林的所需剂量？此问题模拟了酶动力学（药代动力学，PK）与药物靶点敏感性（药效动力学，PD）之间的相互作用，并运用内源性清除率（$Cl_{int} = V_{max}/K_m$）的概念来量化代谢能力。这项练习  旨在从基本原理出发，构建一个简洁而有效的机理模型，要求您整合生化数据（$K_m$，$V_{max}$）和药效学信息，以做出定量的临床预测，从而架起实验室发现与临床实践之间的桥梁。",
            "id": "4395948",
            "problem": "一种针对抗凝剂S-华法林的药物基因组学给药模型，整合了由细胞色素P450 2C9（CYP2C9）介导的肝脏代谢和通过维生素K环氧化物还原酶复合体亚基1（VKORC1）调节的药效学敏感性。假设以下内容为基本依据：\n\n- S-华法林是一种低提取率、低底物浓度的肝清除药物，其氧化清除主要由CYP2C9介导的7-羟基化反应主导。\n- 在稳态口服给药条件下，对于固定的目标抗凝强度（国际标准化比值（INR）），所需的维持剂量与肝清除率和药效学所需的有效浓度的乘积成正比。\n- 重组CYP2C9等位基因变体对S-华法林的7-羟基化反应表现出Michaelis–Menten动力学特征，且体内底物浓度远低于Michaelis–Menten常数。\n- 在二倍体基因型中，两个CYP2C9等位基因均等表达，且肝脏总CYP2C9浓度在不同基因型中是保守的；净催化效率是两个等位基因特异性催化效率的平均值。\n\n给定S-华法林与重组人CYP2C9变体反应的体外动力学参数：\n\n- CYP2C9$^{\\ast}1$: $K_{m,1} = 3.0\\,\\mu\\mathrm{M}$, $V_{\\max,1} = 9.0\\,\\mathrm{pmol}\\,\\mathrm{min}^{-1}\\,\\mathrm{pmol}^{-1}$.\n- CYP2C9$^{\\ast}2$: $K_{m,2} = 3.2\\,\\mu\\mathrm{M}$, $V_{\\max,2} = 5.4\\,\\mathrm{pmol}\\,\\mathrm{min}^{-1}\\,\\mathrm{pmol}^{-1}$.\n- CYP2C9$^{\\ast}3$: $K_{m,3} = 4.5\\,\\mu\\mathrm{M}$, $V_{\\max,3} = 1.2\\,\\mathrm{pmol}\\,\\mathrm{min}^{-1}\\,\\mathrm{pmol}^{-1}$.\n\n此外，VKORC1启动子-1639位点的基因型影响达到固定INR所需的药效学浓度。假设所需有效浓度与VKORC1丰度呈线性关系，且基因型GA相对于GG所需浓度的比率为$0.70$。\n\n仅使用上述基本依据，计算基因型为CYP2C9$^{\\ast}2/\\!^{\\ast}3$和VKORC1 $-1639$ GA的患者相对于基因型为CYP2C9$^{\\ast}1/\\!^{\\ast}1$和VKORC1 $-1639$ GG的参考患者的维持剂量的预测比率。将您的答案四舍五入至四位有效数字，并以无量纲小数形式表示（不带百分号）。",
            "solution": "该问题陈述是药物基因组学中一个有效且定义明确的问题。它包含了所有必要信息，并具有科学依据。我们开始解题。\n\n问题要求计算一名测试患者与一名参考患者的S-华法林稳态维持剂量的比率。测试患者的基因型为CYP2C9$^{\\ast}2/\\!^{\\ast}3$和VKORC1 $-1639$ GA。参考患者的基因型为CYP2C9$^{\\ast}1/\\!^{\\ast}1$和VKORC1 $-1639$ GG。\n\n设 $D_{test}$ 和 $D_{ref}$ 分别为测试患者和参考患者的维持剂量。根据题意，所需的维持剂量 $D$ 与肝清除率 $Cl_H$ 和药效学所需的有效浓度 $C_{eff}$ 的乘积成正比。\n$$ D \\propto Cl_H \\times C_{eff} $$\n因此，剂量的比率可以表示为：\n$$ \\frac{D_{test}}{D_{ref}} = \\frac{Cl_{H, test}}{Cl_{H, ref}} \\times \\frac{C_{eff, test}}{C_{eff, ref}} $$\n\n我们必须分别评估清除率的比率和有效浓度的比率。\n\n首先，我们分析肝清除率 $Cl_H$。题中指出S-华法林是一种低提取率药物。对于此类药物，肝清除率不受肝血流量的限制，而是由肝脏的内在代谢能力决定。因此，肝清除率与内在清除率 $Cl_{int}$ 成正比。\n$$ Cl_H \\propto Cl_{int} $$\n内在清除率由代谢酶CYP2C9的Michaelis–Menten动力学定义。反应速度 $v$ 由下式给出：\n$$ v = \\frac{V_{max} [S]}{K_m + [S]} $$\n其中 $[S]$ 是底物浓度，$V_{max}$ 是最大反应速度，$K_m$ 是Michaelis–Menten常数。内在清除率定义为在低底物浓度的极限下，单位底物浓度的代谢速率：\n$$ Cl_{int} = \\frac{v}{[S]} = \\frac{V_{max}}{K_m + [S]} $$\n题中指出，体内底物浓度远低于Michaelis–Menten常数，即 $[S] \\ll K_m$。在此条件下，内在清除率的表达式简化为：\n$$ Cl_{int} \\approx \\frac{V_{max}}{K_m} $$\n这个比率 $V_{max}/K_m$ 代表了酶的催化效率，我们将其表示为 $\\eta$。因此，肝清除率与肝脏中总CYP2C9酶库的催化效率成正比。\n$$ Cl_H \\propto \\eta_{total} $$\n题中明确指出，在二倍体个体中，净催化效率是两个组成等位基因效率的算术平均值。对于由等位基因 $A$ 和 $B$ 组成的基因型，总效率为：\n$$ \\eta_{A/B} = \\frac{1}{2}(\\eta_A + \\eta_B) = \\frac{1}{2}\\left(\\frac{V_{max, A}}{K_{m, A}} + \\frac{V_{max, B}}{K_{m, B}}\\right) $$\n现在我们可以使用提供的动力学数据计算各个CYP2C9等位基因的催化效率。\n对于CYP2C9$^{\\ast}1$：\n$$ \\eta_1 = \\frac{V_{max,1}}{K_{m,1}} = \\frac{9.0\\,\\mathrm{pmol}\\,\\mathrm{min}^{-1}\\,\\mathrm{pmol}^{-1}}{3.0\\,\\mu\\mathrm{M}} = 3.0\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{pmol}\\,\\mathrm{min}^{-1}\\,\\mathrm{pmol}^{-1} $$\n对于CYP2C9$^{\\ast}2$：\n$$ \\eta_2 = \\frac{V_{max,2}}{K_{m,2}} = \\frac{5.4\\,\\mathrm{pmol}\\,\\mathrm{min}^{-1}\\,\\mathrm{pmol}^{-1}}{3.2\\,\\mu\\mathrm{M}} = 1.6875\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{pmol}\\,\\mathrm{min}^{-1}\\,\\mathrm{pmol}^{-1} $$\n对于CYP2C9$^{\\ast}3$：\n$$ \\eta_3 = \\frac{V_{max,3}}{K_{m,3}} = \\frac{1.2\\,\\mathrm{pmol}\\,\\mathrm{min}^{-1}\\,\\mathrm{pmol}^{-1}}{4.5\\,\\mu\\mathrm{M}} \\approx 0.2667\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{pmol}\\,\\mathrm{min}^{-1}\\,\\mathrm{pmol}^{-1} $$\n为保证精度，使用分数计算：$\\eta_3 = \\frac{1.2}{4.5} = \\frac{12}{45} = \\frac{4}{15}$。\n\n接下来，我们计算参考患者和测试患者基因型的净催化效率。\n参考患者 (CYP2C9$^{\\ast}1/\\!^{\\ast}1$)：\n$$ \\eta_{ref} = \\frac{1}{2}(\\eta_1 + \\eta_1) = \\eta_1 = 3.0\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{pmol}\\,\\mathrm{min}^{-1}\\,\\mathrm{pmol}^{-1} $$\n测试患者 (CYP2C9$^{\\ast}2/\\!^{\\ast}3$)：\n$$ \\eta_{test} = \\frac{1}{2}(\\eta_2 + \\eta_3) = \\frac{1}{2}\\left(1.6875 + \\frac{4}{15}\\right) = \\frac{1}{2}\\left(\\frac{27}{16} + \\frac{4}{15}\\right) $$\n$$ \\eta_{test} = \\frac{1}{2}\\left(\\frac{27 \\times 15 + 4 \\times 16}{16 \\times 15}\\right) = \\frac{1}{2}\\left(\\frac{405 + 64}{240}\\right) = \\frac{469}{480} \\approx 0.977083\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{pmol}\\,\\mathrm{min}^{-1}\\,\\mathrm{pmol}^{-1} $$\n肝清除率的比率等于其净催化效率的比率：\n$$ \\frac{Cl_{H, test}}{Cl_{H, ref}} = \\frac{\\eta_{test}}{\\eta_{ref}} = \\frac{469/480}{3} = \\frac{469}{1440} $$\n\n其次，我们分析有效浓度 $C_{eff}$ 的比率。题中指出，VKORC1 $-1639$ GA基因型所需的有效浓度是GG基因型所需浓度的一部分。测试患者为GA基因型，参考患者为GG基因型。该比率已直接给出：\n$$ \\frac{C_{eff, test}}{C_{eff, ref}} = \\frac{C_{eff, GA}}{C_{eff, GG}} = 0.70 $$\n\n最后，我们将清除率比率和浓度比率结合起来，求得最终的剂量比率：\n$$ \\frac{D_{test}}{D_{ref}} = \\left(\\frac{Cl_{H, test}}{Cl_{H, ref}}\\right) \\times \\left(\\frac{C_{eff, test}}{C_{eff, ref}}\\right) = \\left(\\frac{469}{1440}\\right) \\times 0.70 $$\n$$ \\frac{D_{test}}{D_{ref}} = \\frac{469}{1440} \\times \\frac{7}{10} = \\frac{3283}{14400} \\approx 0.22798611... $$\n题目要求将答案四舍五入至四位有效数字。\n$$ \\frac{D_{test}}{D_{ref}} \\approx 0.2280 $$",
            "answer": "$$\\boxed{0.2280}$$"
        },
        {
            "introduction": "实践的最后一步是将这些原理转化为稳健、可用于真实世界的工具。我们如何将临床和遗传数据结合起来，创建一个可预测的剂量算法？此练习介绍了一种现代数据科学方法，用于开发药物基因组学算法，涵盖了特征工程、模型训练（岭回归）、超参数调优以及使用交叉验证进行的严格评估。这项高级的编码实践  模拟了开发和验证药物基因组学剂量算法的全过程，通过亲手实现这一流程，您将对如何评估遗传信息的预测价值以及如何构建可重复的、基于证据的临床决策支持工具有了深刻而实际的理解。",
            "id": "4395995",
            "problem": "您的任务是在药物基因组学背景下，为预测华法林稳定维持剂量，实现两个线性给药算法的可复现、交叉验证校准。您必须依赖的科学基础包括：线性模型的定义、使用自然对数变换稳定乘性变异的性质，以及平均绝对误差（MAE）和平均有符号误差（偏差）等标准评估指标。您不得依赖任何已发表的华法林“快捷”给药公式；相反，您必须直接根据数据和以下定义构建模型。所有计算和答案都必须以毫克/天（mg/day）表示。您的程序必须产生一行输出，包含一个用方括号括起来的逗号分隔列表。\n\n您将拟合两个线性模型来预测稳定剂量的自然对数，并使用交叉验证（CV）在留出数据上评估预测结果。然后，必须将预测结果取指数转换回 mg/day，以计算原始单位的误差。\n\n定义和建模框架：\n- 设 $n$ 表示个体数量，$\\mathbf{x}_i \\in \\mathbb{R}^p$ 表示个体 $i$ 的预测变量向量，其对应的观测稳定剂量为 $d_i$（单位：mg/day）。设 $y_i = \\ln(d_i)$ 表示剂量的自然对数（无量纲）。\n- 您将在对数剂量空间中拟合一个形式为 $y \\approx \\beta_0 + \\sum_{j=1}^{p} \\beta_j z_j$ 的线性模型，其中 $z_j$ 是从 $\\mathbf{x}$ 派生的标准化预测变量。\n- 标准化：对于每个非截距项的预测变量 $x_j$，计算训练折的均值 $\\mu_j$ 和标准差 $\\sigma_j$，并仅使用训练折的统计数据定义 $z_j = \\frac{x_j - \\mu_j}{\\sigma_j}$。如果 $\\sigma_j = 0$，则将其替换为 $1$ 以避免除以零。\n- 在每个训练折内需要进行岭正则化拟合：通过最小化对数剂量空间中的带惩罚项的平方误差来估计 $\\boldsymbol{\\beta}$，惩罚项为 $\\lambda \\sum_{j=1}^p \\beta_j^2$。截距项 $\\beta_0$ 不得被惩罚。\n- 超参数选择：在每个训练折内，从候选集 $\\{\\;0,\\,0.1,\\,1,\\,10\\;\\}$ 中选择岭惩罚系数 $\\lambda$，以在确定性的 $3$ 折内部交叉验证中最小化平均绝对误差（MAE），且仅使用该训练折的数据。内部的 $3$ 个折必须通过索引模 $3$ 的方式确定性地分配（见下文）。\n- 选择 $\\lambda$ 后，在整个训练折上重新拟合模型，并在留出折上预测对数剂量；然后取指数以获得以 mg/day 为单位的预测剂量。\n\n评估指标：\n- 将平均绝对误差（MAE）定义为 $\\frac{1}{n} \\sum_{i=1}^{n} \\left| \\hat{d}_i - d_i \\right|$，其中 $\\hat{d}_i$ 是预测剂量（mg/day），$d_i$ 是观测剂量（mg/day）。\n- 将偏差（平均有符号误差）定义为 $\\frac{1}{n} \\sum_{i=1}^{n} \\left( \\hat{d}_i - d_i \\right)$，单位为 mg/day。\n- 对每个模型，在所有外部折的留出预测聚合结果上分别计算这些指标。\n\n交叉验证分区：\n- 使用 $K=5$ 的外部交叉验证，通过从零开始的索引 $i$ 确定性地将个体分配到折中，外部折 $f_{\\text{outer}}(i) = i \\bmod 5$。\n- 对于给定训练集上的超参数选择期间的内部交叉验证，通过训练集内从零开始的索引确定性地分配内部折，$f_{\\text{inner}}(j) = j \\bmod 3$。\n\n预测变量构建：\n- 纯临床模型预测变量（不包括截距项）：年龄（年），体表面积（BSA）（平方米），性别（二进制，$1$ 为男性，$0$ 为女性），吸烟状况（二进制，$1$ 为当前吸烟者，$0$ 为其他），胺碘酮联合治疗（二进制，$1$ 为是，$0$ 为否）。\n- 基因型指导模型预测变量（不包括截距项）：所有纯临床模型的预测变量，外加两个遗传预测变量：\n  - 细胞色素P450 2C9（CYP2C9）活性评分，根据二倍体型编码，使用以下映射：$*1/*1 \\mapsto 2.0$, $*1/*2 \\mapsto 1.5$, $*1/*3 \\mapsto 1.0$, $*2/*2 \\mapsto 1.0$, $*2/*3 \\mapsto 0.5$, $*3/*3 \\mapsto 0.0$。\n  - 维生素K环氧化物还原酶复合物亚基1（VKORC1）$-1639\\mathrm{G}>\\mathrm{A}$ 基因型，编码为 $\\mathrm{A}$ 等位基因的数量：$\\mathrm{GG} \\mapsto 0$, $\\mathrm{GA} \\mapsto 1$, $\\mathrm{AA} \\mapsto 2$。\n- 体表面积（BSA）必须根据体重（公斤）和身高（厘米），通过 Du Bois 公式计算：$\\mathrm{BSA} = 0.007184 \\times \\mathrm{weight}^{0.425} \\times \\mathrm{height}^{0.725}$，BSA 单位为平方米。\n\n单位和四舍五入：\n- 所有模型拟合都在对数剂量空间中进行，但所有评估和最终报告都必须以 mg/day 为单位。\n- 最终的 MAE 和偏差值以 mg/day 表示，并四舍五入到恰好 $3$ 位小数。\n\n数据集和测试套件：\n- 使用以下包含 $20$ 个个体的队列。每条记录是一个元组，顺序为 $(\\text{年龄（岁）}, \\text{体重（kg）}, \\text{身高（cm）}, \\text{男性}, \\text{吸烟者}, \\text{胺碘酮}, \\text{CYP2C9 二倍体型}, \\text{VKORC1 基因型}, \\text{观测到的稳定剂量（mg/day）})$。\n- 这 $20$ 条记录是：\n  1. $(55,\\,82,\\,178,\\,1,\\,0,\\,0,\\,*1/*1,\\,GG,\\,5.5)$\n  2. $(70,\\,68,\\,165,\\,0,\\,0,\\,0,\\,*1/*2,\\,GA,\\,3.5)$\n  3. $(45,\\,90,\\,185,\\,1,\\,1,\\,0,\\,*1/*1,\\,GG,\\,6.5)$\n  4. $(80,\\,60,\\,160,\\,0,\\,0,\\,1,\\,*1/*3,\\,GA,\\,2.0)$\n  5. $(62,\\,75,\\,172,\\,1,\\,0,\\,0,\\,*1/*2,\\,GG,\\,4.5)$\n  6. $(50,\\,95,\\,190,\\,1,\\,1,\\,0,\\,*1/*1,\\,GA,\\,6.0)$\n  7. $(65,\\,70,\\,168,\\,0,\\,0,\\,0,\\,*2/*2,\\,AA,\\,2.5)$\n  8. $(58,\\,85,\\,180,\\,1,\\,0,\\,1,\\,*1/*1,\\,GA,\\,4.0)$\n  9. $(40,\\,62,\\,170,\\,0,\\,1,\\,0,\\,*1/*2,\\,GA,\\,4.2)$\n  10. $(75,\\,80,\\,175,\\,1,\\,0,\\,0,\\,*1/*3,\\,GG,\\,3.0)$\n  11. $(68,\\,72,\\,165,\\,0,\\,0,\\,0,\\,*1/*1,\\,AA,\\,3.0)$\n  12. $(52,\\,78,\\,172,\\,1,\\,1,\\,0,\\,*1/*2,\\,GG,\\,5.0)$\n  13. $(35,\\,88,\\,182,\\,1,\\,1,\\,0,\\,*1/*1,\\,GG,\\,7.0)$\n  14. $(60,\\,64,\\,160,\\,0,\\,0,\\,0,\\,*2/*3,\\,GA,\\,2.2)$\n  15. $(72,\\,70,\\,168,\\,1,\\,0,\\,1,\\,*1/*2,\\,AA,\\,2.5)$\n  16. $(48,\\,82,\\,178,\\,0,\\,0,\\,0,\\,*1/*1,\\,GA,\\,4.8)$\n  17. $(66,\\,90,\\,175,\\,1,\\,1,\\,0,\\,*1/*2,\\,GA,\\,4.6)$\n  18. $(59,\\,73,\\,170,\\,0,\\,0,\\,0,\\,*1/*3,\\,GA,\\,3.3)$\n  19. $(77,\\,68,\\,165,\\,0,\\,0,\\,1,\\,*3/*3,\\,AA,\\,1.0)$\n  20. $(42,\\,100,\\,188,\\,1,\\,1,\\,0,\\,*1/*1,\\,GG,\\,7.5)$\n\n算法要求：\n- 按所述实现外部 $5$ 折交叉验证。\n- 在每个外部训练折中，执行内部 $3$ 折交叉验证以选择能够最小化内部折平均 MAE（单位 mg/day）的 $\\lambda \\in \\{\\;0,\\,0.1,\\,1,\\,10\\;\\}$。使用训练折的标准化方法和选定的 $\\lambda$（截距项不被惩罚），在对数剂量空间中拟合岭正则化线性模型。使用数值稳定的闭式解。\n- 对于每个外部测试实例，通过对预测的对数剂量取指数来计算预测剂量。聚合所有外部折的预测结果，以计算每个模型的总体 MAE 和偏差。\n\n最终输出规范：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按以下顺序和单位包含四个结果：$[\\text{MAE 纯临床模型}, \\text{偏差 纯临床模型}, \\text{MAE 基因型指导模型}, \\text{偏差 基因型指导模型}]$，所有值均以 mg/day 为单位，且每个值都四舍五入到恰好 $3$ 位小数。例如，输出可能看起来像 $[4.123,-0.250,3.876,-0.100]$（这只是一个格式示例；您的实际数值结果必须根据指定的数据和过程计算得出）。",
            "solution": "我们从线性建模和交叉验证估计的基本原理开始。设 $d_i$ 表示个体 $i$ 的观测稳定华法林剂量（单位 mg/day），$y_i = \\ln(d_i)$ 为其自然对数，该变换将乘性变异性转换为加性结构，并通常能稳定方差。我们假定在对数剂量空间中存在线性关系，\n$$\ny_i \\approx \\beta_0 + \\sum_{j=1}^{p} \\beta_j z_{ij},\n$$\n其中 $z_{ij}$ 是通过 $z_{ij} = (x_{ij} - \\mu_j)/\\sigma_j$ 从原始预测变量 $x_{ij}$ 计算得出的标准化预测变量，而 $\\mu_j$ 和 $\\sigma_j$ 仅根据训练数据计算。如果 $\\sigma_j = 0$，我们设 $\\sigma_j = 1$ 以避免除以零，这使得该特征在中心化后不进行缩放，并防止数值不稳定。\n\n为了防止过拟合并将模型校准到未见过的数据上，我们使用交叉验证（CV）。外部交叉验证有 $K=5$ 个折，通过索引模 $5$ 的方式确定性地分配。对于每个外部折，模型在 $4$ 个折上进行训练，并在留出的那个折上进行评估。在每个训练折内，我们必须选择岭惩罚系数 $\\lambda$ 来平衡偏差和方差。岭回归通过最小化以下表达式来估计 $\\boldsymbol{\\beta}$：\n$$\n\\sum_{i \\in \\mathcal{T}} \\left( y_i - \\beta_0 - \\sum_{j=1}^{p} \\beta_j z_{ij} \\right)^2 + \\lambda \\sum_{j=1}^{p} \\beta_j^2,\n$$\n其中 $\\mathcal{T}$ 索引训练集，截距项 $\\beta_0$ 被明确地排除在惩罚项之外。我们通过在训练集内进行 $3$ 折内部交叉验证来从 $\\{0, 0.1, 1, 10\\}$ 中选择 $\\lambda$，内部折通过索引模 $3$ 的方式确定性地分配。对于每个候选 $\\lambda$，我们执行内部交叉验证：基于内部训练划分来标准化预测变量，以闭式解拟合岭模型，对留出的内部划分进行预测，将预测结果取指数转换回 mg/day，并计算平均绝对误差（MAE）（单位 mg/day）。然后我们对内部折的 MAE 求平均，并选择具有最低平均 MAE 的 $\\lambda$。如果出现平局，可以通过选择最小的 $\\lambda$ 来解决，这是确定性的。\n\n对于带无惩罚截距项的岭回归，其闭式解可以通过在标准化设计矩阵 $Z$ 前增加一列全为 1 的向量来得到增广矩阵 $X = [\\mathbf{1}, Z]$，并定义一个惩罚矩阵 $P = \\operatorname{diag}(0, \\lambda, \\ldots, \\lambda)$。估计量为\n$$\n\\hat{\\boldsymbol{\\beta}} = \\left( X^\\top X + P \\right)^{-1} X^\\top \\mathbf{y},\n$$\n其中 $\\mathbf{y}$ 是训练响应 $y_i$ 的向量。当 $\\lambda = 0$ 时，该解退化为普通最小二乘法，此时我们使用 Moore–Penrose 伪逆来确保即使 $X^\\top X$ 是奇异矩阵时的数值稳定性。当 $\\lambda > 0$ 时，在标准条件下 $X^\\top X + P$ 是正定的，一个稳定的求解器（例如，通过线性系统求解或伪逆）可以得出 $\\hat{\\boldsymbol{\\beta}}$。\n\n在内部交叉验证上选择 $\\lambda$ 后，我们使用选定的 $\\lambda$ 和训练标准化参数 $(\\mu_j, \\sigma_j)$ 在完整的外部训练集上重新拟合模型，然后在外部测试折上进行预测。对于每个带有原始预测变量 $\\mathbf{x}$ 的测试实例，我们使用外部训练参数计算 $z_j = (x_j - \\mu_j)/\\sigma_j$，得到预测的对数剂量 $\\hat{y}$，然后取指数得到 $\\hat{d} = \\exp(\\hat{y})$，单位为 mg/day。\n\n我们在所有折的聚合外部测试预测上定义评估指标：\n- 平均绝对误差（MAE）：\n$$\n\\mathrm{MAE} = \\frac{1}{n} \\sum_{i=1}^{n} \\left| \\hat{d}_i - d_i \\right|.\n$$\n- 偏差（平均有符号误差）：\n$$\n\\mathrm{Bias} = \\frac{1}{n} \\sum_{i=1}^{n} \\left( \\hat{d}_i - d_i \\right).\n$$\n\n我们构建两个仅在预测变量上有所不同的模型：\n- 纯临床预测变量：年龄（年）、体表面积（BSA）、性别（二进制）、吸烟（二进制）、胺碘酮（二进制）。\n- 基因型指导预测变量：纯临床预测变量加上 CYP2C9 活性评分和 VKORC1 $-1639\\mathrm{G}>\\mathrm{A}$ 的 A 等位基因计数。\n\nBSA 是通过 Du Bois 公式根据体重（kg）和身高（cm）计算的：\n$$\n\\mathrm{BSA} = 0.007184 \\times \\mathrm{weight}^{0.425} \\times \\mathrm{height}^{0.725} \\quad (\\mathrm{m}^2).\n$$\n\n遗传编码如下：\n- CYP2C9 活性评分：$*1/*1 \\to 2.0$, $*1/*2 \\to 1.5$, $*1/*3 \\to 1.0$, $*2/*2 \\to 1.0$, $*2/*3 \\to 0.5$, $*3/*3 \\to 0.0$。\n- VKORC1 基因型 A-等位基因计数：$\\mathrm{GG} \\to 0$, $\\mathrm{GA} \\to 1$, $\\mathrm{AA} \\to 2$。\n\n通过索引模运算进行的确定性交叉验证分区确保了可复现性和普遍适用性，无需依赖随机性。最终输出要求将每个指标四舍五入到恰好 $3$ 位小数，并按以下顺序报告四个值：$[\\mathrm{MAE\\ 临床模型}, \\mathrm{Bias\\ 临床模型}, \\mathrm{MAE\\ 基因型模型}, \\mathrm{Bias\\ 基因型模型}]$。\n\n通过对提供的 $20$ 个个体的数据集遵循此程序，可以为每个模型获得一对以 mg/day 为单位的交叉验证性能指标，从而能够在遵循严格的模型校准和评估原则的同时，对仅使用临床变量与额外添加基因型信息所带来的价值进行有原则的比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef du_bois_bsa(weight_kg, height_cm):\n    # BSA in m^2 per Du Bois formula\n    return 0.007184 * (weight_kg ** 0.425) * (height_cm ** 0.725)\n\ndef map_cyp2c9_activity(diplotype: str) -> float:\n    mapping = {\n        \"*1/*1\": 2.0,\n        \"*1/*2\": 1.5,\n        \"*1/*3\": 1.0,\n        \"*2/*2\": 1.0,\n        \"*2/*3\": 0.5,\n        \"*3/*3\": 0.0,\n    }\n    if diplotype not in mapping:\n        raise ValueError(f\"Unknown CYP2C9 diplotype: {diplotype}\")\n    return mapping[diplotype]\n\ndef map_vkorc1_a_count(genotype: str) -> int:\n    mapping = {\"GG\": 0, \"GA\": 1, \"AA\": 2}\n    if genotype not in mapping:\n        raise ValueError(f\"Unknown VKORC1 genotype: {genotype}\")\n    return mapping[genotype]\n\ndef build_features(records, include_genetics: bool):\n    \"\"\"\n    Build feature matrix and target vector.\n    Clinical predictors: age, BSA, male, smoker, amiodarone\n    Genetic predictors: CYP2C9 activity score, VKORC1 A-allele count\n    Target: ln(dose)\n    \"\"\"\n    X_list = []\n    y_list = []\n    for rec in records:\n        age, weight, height, male, smoker, amio, cyp, vkor, dose = rec\n        bsa = du_bois_bsa(weight, height)\n        features = [age, bsa, male, smoker, amio]\n        if include_genetics:\n            cyp_act = map_cyp2c9_activity(cyp)\n            vkor_a = map_vkorc1_a_count(vkor)\n            features.extend([cyp_act, vkor_a])\n        X_list.append(features)\n        y_list.append(np.log(dose))\n    X = np.array(X_list, dtype=float)\n    y = np.array(y_list, dtype=float)\n    return X, y\n\ndef standardize_train(X):\n    mu = X.mean(axis=0)\n    sd = X.std(axis=0, ddof=0)\n    sd_safe = np.where(sd == 0.0, 1.0, sd)\n    Z = (X - mu) / sd_safe\n    return Z, mu, sd_safe\n\ndef standardize_apply(X, mu, sd):\n    sd_safe = np.where(sd == 0.0, 1.0, sd)\n    return (X - mu) / sd_safe\n\ndef ridge_fit_predict(X_train, y_train, X_test, lam):\n    \"\"\"\n    Fit ridge regression in log-dose space with unpenalized intercept.\n    X_train, X_test are standardized feature matrices (no intercept column).\n    \"\"\"\n    n_train, p = X_train.shape\n    # Add intercept\n    ones_train = np.ones((n_train, 1))\n    Xtr = np.hstack([ones_train, X_train])\n    # Penalty matrix: 0 for intercept, lam for others\n    P = np.diag(np.concatenate([[0.0], np.full(p, lam, dtype=float)]))\n    # Closed-form solution: beta = (X^T X + P)^-1 X^T y\n    XtX = Xtr.T @ Xtr + P\n    Xty = Xtr.T @ y_train\n    # Use pseudoinverse for numerical stability (handles lam=0 too)\n    beta = np.linalg.pinv(XtX) @ Xty\n    # Predict\n    ones_test = np.ones((X_test.shape[0], 1))\n    Xte = np.hstack([ones_test, X_test])\n    y_pred = Xte @ beta\n    return y_pred\n\ndef kfold_indices(n, k):\n    # Deterministic fold assignment by index mod k\n    folds = {f: [] for f in range(k)}\n    for i in range(n):\n        folds[i % k].append(i)\n    return folds\n\ndef inner_cv_select_lambda(X_train_raw, y_train, lambdas, n_inner=3):\n    # Determine inner folds on training indices by relative order, modulo n_inner\n    ntr = X_train_raw.shape[0]\n    # Build indices per inner fold by local order\n    inner_folds = {f: [] for f in range(n_inner)}\n    for j in range(ntr):\n        inner_folds[j % n_inner].append(j)\n\n    best_lam = None\n    best_score = np.inf\n    for lam in lambdas:\n        # Compute average MAE across inner folds\n        maes = []\n        for f in range(n_inner):\n            inner_test_idx = np.array(inner_folds[f], dtype=int)\n            inner_train_idx = np.array(\n                [idx for idx in range(ntr) if idx not in inner_folds[f]],\n                dtype=int\n            )\n            X_tr_raw = X_train_raw[inner_train_idx]\n            y_tr = y_train[inner_train_idx]\n            X_te_raw = X_train_raw[inner_test_idx]\n            y_te = y_train[inner_test_idx]\n            # Standardize on inner training\n            Z_tr, mu, sd = standardize_train(X_tr_raw)\n            Z_te = standardize_apply(X_te_raw, mu, sd)\n            # Fit and predict in log space\n            y_hat_log = ridge_fit_predict(Z_tr, y_tr, Z_te, lam)\n            # Back-transform to mg/day\n            d_hat = np.exp(y_hat_log)\n            d_true = np.exp(y_te)\n            mae = np.mean(np.abs(d_hat - d_true))\n            maes.append(mae)\n        avg_mae = float(np.mean(maes))\n        if (avg_mae  best_score) or (np.isclose(avg_mae, best_score) and (best_lam is not None and lam  best_lam)):\n            best_score = avg_mae\n            best_lam = lam\n        if best_lam is None:\n            best_lam = lam\n            best_score = avg_mae\n    return best_lam\n\ndef cross_validated_metrics(records):\n    # Prepare full datasets for each model\n    X_clin, y = build_features(records, include_genetics=False)\n    X_gen, _ = build_features(records, include_genetics=True)\n\n    n = X_clin.shape[0]\n    outer_folds = kfold_indices(n, 5)\n    lambdas = [0.0, 0.1, 1.0, 10.0]\n\n    # Storage for predictions\n    pred_clin = np.zeros(n, dtype=float)\n    pred_gen = np.zeros(n, dtype=float)\n\n    for f in range(5):\n        test_idx = np.array(outer_folds[f], dtype=int)\n        train_idx = np.array([i for i in range(n) if i not in test_idx], dtype=int)\n\n        # Clinical-only\n        Xtr_c = X_clin[train_idx]\n        ytr = y[train_idx]\n        Xte_c = X_clin[test_idx]\n\n        lam_c = inner_cv_select_lambda(Xtr_c, ytr, lambdas, n_inner=3)\n        Ztr_c, mu_c, sd_c = standardize_train(Xtr_c)\n        Zte_c = standardize_apply(Xte_c, mu_c, sd_c)\n        yhat_log_c = ridge_fit_predict(Ztr_c, ytr, Zte_c, lam_c)\n        pred_clin[test_idx] = np.exp(yhat_log_c)\n\n        # Genotype-guided\n        Xtr_g = X_gen[train_idx]\n        Xte_g = X_gen[test_idx]\n\n        lam_g = inner_cv_select_lambda(Xtr_g, ytr, lambdas, n_inner=3)\n        Ztr_g, mu_g, sd_g = standardize_train(Xtr_g)\n        Zte_g = standardize_apply(Xte_g, mu_g, sd_g)\n        yhat_log_g = ridge_fit_predict(Ztr_g, ytr, Zte_g, lam_g)\n        pred_gen[test_idx] = np.exp(yhat_log_g)\n\n    # True doses\n    doses = np.array([rec[-1] for rec in records], dtype=float)\n\n    # Metrics\n    mae_clin = float(np.mean(np.abs(pred_clin - doses)))\n    bias_clin = float(np.mean(pred_clin - doses))\n    mae_gen = float(np.mean(np.abs(pred_gen - doses)))\n    bias_gen = float(np.mean(pred_gen - doses))\n\n    return mae_clin, bias_clin, mae_gen, bias_gen\n\ndef solve():\n    # Dataset as specified in the problem statement\n    # Each record: (age, weight, height, male, smoker, amiodarone, CYP2C9, VKORC1, observed dose mg/day)\n    records = [\n        (55, 82, 178, 1, 0, 0, \"*1/*1\", \"GG\", 5.5),\n        (70, 68, 165, 0, 0, 0, \"*1/*2\", \"GA\", 3.5),\n        (45, 90, 185, 1, 1, 0, \"*1/*1\", \"GG\", 6.5),\n        (80, 60, 160, 0, 0, 1, \"*1/*3\", \"GA\", 2.0),\n        (62, 75, 172, 1, 0, 0, \"*1/*2\", \"GG\", 4.5),\n        (50, 95, 190, 1, 1, 0, \"*1/*1\", \"GA\", 6.0),\n        (65, 70, 168, 0, 0, 0, \"*2/*2\", \"AA\", 2.5),\n        (58, 85, 180, 1, 0, 1, \"*1/*1\", \"GA\", 4.0),\n        (40, 62, 170, 0, 1, 0, \"*1/*2\", \"GA\", 4.2),\n        (75, 80, 175, 1, 0, 0, \"*1/*3\", \"GG\", 3.0),\n        (68, 72, 165, 0, 0, 0, \"*1/*1\", \"AA\", 3.0),\n        (52, 78, 172, 1, 1, 0, \"*1/*2\", \"GG\", 5.0),\n        (35, 88, 182, 1, 1, 0, \"*1/*1\", \"GG\", 7.0),\n        (60, 64, 160, 0, 0, 0, \"*2/*3\", \"GA\", 2.2),\n        (72, 70, 168, 1, 0, 1, \"*1/*2\", \"AA\", 2.5),\n        (48, 82, 178, 0, 0, 0, \"*1/*1\", \"GA\", 4.8),\n        (66, 90, 175, 1, 1, 0, \"*1/*2\", \"GA\", 4.6),\n        (59, 73, 170, 0, 0, 0, \"*1/*3\", \"GA\", 3.3),\n        (77, 68, 165, 0, 0, 1, \"*3/*3\", \"AA\", 1.0),\n        (42, 100, 188, 1, 1, 0, \"*1/*1\", \"GG\", 7.5),\n    ]\n\n    mae_clin, bias_clin, mae_gen, bias_gen = cross_validated_metrics(records)\n\n    # Round to exactly 3 decimals\n    results = [\n        f\"{mae_clin:.3f}\",\n        f\"{bias_clin:.3f}\",\n        f\"{mae_gen:.3f}\",\n        f\"{bias_gen:.3f}\",\n    ]\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}