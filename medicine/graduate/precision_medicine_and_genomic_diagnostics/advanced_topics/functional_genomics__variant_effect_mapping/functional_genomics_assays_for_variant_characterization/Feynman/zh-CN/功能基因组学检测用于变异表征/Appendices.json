{
    "hands_on_practices": [
        {
            "introduction": "表征变异的功能性影响通常始于最基础的层面：其对分子相互作用的影响。像生物膜干涉技术（BLI）这样的方法使我们能够直接测量分子间结合的动力学，例如蛋白质与DNA之间的结合。本练习  将指导您完成分析BLI数据的全过程，以提取结合速率常数（$k_{\\text{on}}$）和解离速率常数（$k_{\\text{off}}$），从而为变异如何改变结合亲和力提供定量衡量。通过模拟数据并拟合模型，您将对底层的生物物理原理获得深刻而实践性的理解。",
            "id": "4342352",
            "problem": "一个实验室使用生物膜干涉技术（BLI）来表征一种基因组调控蛋白的不同变体与一个DNA基序的结合动力学。在质量输运可忽略不计的一对一结合模型下，测得的传感器响应与表面结合的复合物成正比。令结合响应表示为 $R(t)$，最大结合容量为 $R_{\\max}$，分析物浓度为 $C$，结合速率常数为 $k_{\\text{on}}$，解离速率常数为 $k_{\\text{off}}$。在结合阶段，样品暴露于固定浓度的分析物 $C$ 一段时间；在解离阶段，分析物浓度设为零。假设以下基本前提：\n- 系统遵循质量作用定律，且在检测层面中心法则得到遵守：唯一测量的过程是分析物与表面配体的可逆结合，在检测的时间尺度上，没有合成或降解过程影响 $R(t)$。\n- 控制常微分方程为 $\\,\\dfrac{dR}{dt} = k_{\\text{on}}\\,C\\,(R_{\\max} - R) - k_{\\text{off}}\\,R\\,$（当 $C$ 恒定时），以及 $\\,\\dfrac{dR}{dt} = -k_{\\text{off}}\\,R\\,$（当 $C = 0$ 时）。\n- 解离常数为 $\\,K_d = \\frac{k_{\\text{off}}}{k_{\\text{on}}}\\,$.\n\n任务：编写一个完整的程序，对下面的每个测试用例，通过对上述模型进行数值计算来构建无噪声的结合和解离时间进程，然后通过拟合结合和解离阶段，从模拟数据中估计 $k_{\\text{on}}$、$k_{\\text{off}}$ 和 $K_d$。你的算法必须：\n- 使用解离段通过指数衰减拟合来估计 $k_{\\text{off}}$。\n- 使用多个浓度下的结合段来估计每个浓度下的观测速率 $k_{\\text{obs}}$，然后将 $k_{\\text{obs}}$ 作为 $C$ 的函数进行线性拟合，以求出 $k_{\\text{on}}$（斜率）和 $k_{\\text{off}}$（截距），这与质量作用动力学基础一致。\n- 报告每个测试用例的 $k_{\\text{on}}$、$k_{\\text{off}}$ 和 $K_d$ 的最终估计值。\n\n科学真实性约束：\n- 所有测试用例均使用结合持续时间 $\\,T_{\\text{assoc}} = 60\\,\\text{s}\\,$（每 $\\,\\Delta t = 0.5\\,\\text{s}\\,$ 采样一次）和解离持续时间 $\\,T_{\\text{diss}} = 120\\,\\text{s}\\,$（每 $\\,\\Delta t = 0.5\\,\\text{s}\\,$ 采样一次）。\n- 将 $k_{\\text{on}}$ 以 $\\text{M}^{-1}\\,\\text{s}^{-1}$ 为单位表示，$k_{\\text{off}}$ 以 $\\text{s}^{-1}$ 为单位表示，$K_d$ 以 $\\text{M}$ 为单位表示。\n\n测试套件：\n- 测试用例 1 (Variant A): $\\,k_{\\text{on}}^{\\text{true}} = 1.7\\times 10^{5}\\,\\text{M}^{-1}\\,\\text{s}^{-1}\\,$, $\\,k_{\\text{off}}^{\\text{true}} = 9.0\\times 10^{-3}\\,\\text{s}^{-1}\\,$, $\\,R_{\\max} = 1.1\\,\\text{nm}\\,$, 浓度 $\\,C \\in \\{1.0\\times 10^{-9},\\,1.0\\times 10^{-8},\\,5.0\\times 10^{-8}\\}\\,\\text{M}\\,$.\n- 测试用例 2 (Variant B): $\\,k_{\\text{on}}^{\\text{true}} = 8.0\\times 10^{4}\\,\\text{M}^{-1}\\,\\text{s}^{-1}\\,$, $\\,k_{\\text{off}}^{\\text{true}} = 2.5\\times 10^{-3}\\,\\text{s}^{-1}\\,$, $\\,R_{\\max} = 0.9\\,\\text{nm}\\,$, 浓度 $\\,C \\in \\{2.0\\times 10^{-9},\\,1.5\\times 10^{-8},\\,6.0\\times 10^{-8}\\}\\,\\text{M}\\,$.\n- 测试用例 3 (Variant C): $\\,k_{\\text{on}}^{\\text{true}} = 2.2\\times 10^{5}\\,\\text{M}^{-1}\\,\\text{s}^{-1}\\,$, $\\,k_{\\text{off}}^{\\text{true}} = 5.0\\times 10^{-4}\\,\\text{s}^{-1}\\,$, $\\,R_{\\max} = 1.0\\,\\text{nm}\\,$, 浓度 $\\,C \\in \\{5.0\\times 10^{-10},\\,5.0\\times 10^{-9},\\,5.0\\times 10^{-8}\\}\\,\\text{M}\\,$.\n\n数据生成要求：\n- 对于一个测试用例中的每个浓度 $C$，模拟一个结合段，初始条件为 $\\,R(0)=0\\,$，在 $\\,T_{\\text{assoc}}\\,$ 期间 $C$ 恒定；随后模拟一个解离段，在 $\\,T_{\\text{diss}}\\,$ 期间 $\\,C=0\\,$，并以结合结束时的值作为初始条件。使用与上述微分方程一致的精确数值计算。\n\n拟合与输出规范：\n- 对每个测试用例，通过对每个解离段拟合单指数衰减并在各浓度间进行汇总来估计 $k_{\\text{off}}$，并通过将结合段拟合得到的 $k_{\\text{obs}}$ 值与相应的浓度 $C$ 进行线性回归来估计 $k_{\\text{on}}$。\n- 计算 $\\,K_d = \\frac{k_{\\text{off}}}{k_{\\text{on}}}\\,$.\n- 你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身也是一个列表 $[k_{\\text{on}},k_{\\text{off}},K_d]$。每个数字必须以科学记数法打印，小数点后精确到六位。例如：$[[1.234567\\text{e}{+05},2.345678\\text{e}{-03},1.901234\\text{e}{-08}],[\\dots],[\\dots]]$。",
            "solution": "该问题被评估为有效。它在科学上基于化学动力学原理，特别是应用于生物膜干涉技术（BLI）等基于表面的生物传感器检测的质量作用定律。该问题是适定的、客观的，并为数据模拟和分析提供了一套完整且一致的参数和指令。所要求的任务构成了生物物理数据分析中的一个标准且可验证的练习。\n\n解决方案分为两个主要阶段：首先，基于所提供的动力学模型和参数，生成合成的、无噪声的BLI数据；其次，使用指定的拟合方法，从这些合成数据中估计动力学常数。\n\n**1. 数据生成：动力学模型的解析解**\n\n结合过程由一个常微分方程组（ODEs）描述，该方程组源于一对一相互作用 $A + L \\rightleftharpoons AL$ 的质量作用定律，其中 $A$ 是溶液中的分析物，$L$ 是固定在传感器表面的配体。测量的响应 $R(t)$ 与形成的复合物 $AL$ 的浓度成正比。\n\n**结合阶段：**\n在结合阶段，分析物以恒定浓度 $C$ 存在。控制常微分方程为：\n$$\n\\frac{dR}{dt} = k_{\\text{on}}C(R_{\\max} - R) - k_{\\text{off}}R\n$$\n其中 $k_{\\text{on}}$ 是结合速率常数，$k_{\\text{off}}$ 是解离速率常数，$R_{\\max}$ 是最大可能响应。这是一个一阶线性常微分方程。它可以重排为：\n$$\n\\frac{dR}{dt} + (k_{\\text{on}}C + k_{\\text{off}})R = k_{\\text{on}}CR_{\\max}\n$$\n我们定义观测速率常数 $k_{\\text{obs}}$ 为 $k_{\\text{obs}} = k_{\\text{on}}C + k_{\\text{off}}$。方程变为：\n$$\n\\frac{dR}{dt} + k_{\\text{obs}}R = k_{\\text{on}}CR_{\\max}\n$$\n在初始条件 $R(0) = 0$ 下，结合阶段的解析解为：\n$$\nR_{\\text{assoc}}(t) = \\frac{k_{\\text{on}}CR_{\\max}}{k_{\\text{obs}}}(1 - e^{-k_{\\text{obs}}t})\n$$\n项 $\\frac{k_{\\text{on}}CR_{\\max}}{k_{\\text{obs}}}$ 代表平衡响应 $R_{eq}$，如果结合过程可以无限期地进行，则会达到该响应。因此，该方程通常写作：\n$$\nR_{\\text{assoc}}(t) = R_{eq}(1 - e^{-k_{\\text{obs}}t})\n$$\n通过在离散时间点 $t_i = i \\cdot \\Delta t$ (for $i=0, 1, ..., T_{\\text{assoc}}/\\Delta t$) 对该函数求值，可生成持续时间为 $T_{\\text{assoc}}$ 的结合阶段的无噪声数据。\n\n**解离阶段：**\n在解离阶段，分析物被移除，因此 $C=0$。控制常微分方程简化为：\n$$\n\\frac{dR}{dt} = -k_{\\text{off}}R\n$$\n这是一个一阶衰减过程。其解析解的初始条件为结合阶段结束时的响应，$R_{\\text{end\\_assoc}} = R_{\\text{assoc}}(T_{\\text{assoc}})$，解析解为：\n$$\nR_{\\text{diss}}(t') = R_{\\text{end\\_assoc}} e^{-k_{\\text{off}}t'}\n$$\n其中 $t'$ 是自解离阶段开始以来经过的时间。通过在离散时间点 $t'_j = j \\cdot \\Delta t$ (for $j=0, 1, ..., T_{\\text{diss}}/\\Delta t$) 对该函数求值，可生成持续时间为 $T_{\\text{diss}}$ 的解离阶段的无噪声数据。\n\n**2. 从模拟数据中进行参数估计**\n\n任务要求从生成的时间进程数据中恢复动力学参数（$k_{\\text{on}}$，$k_{\\text{off}}$）。这通过一个两步拟合程序来实现。\n\n**A部分：从解离数据中估计 $k_{\\text{off}}$**\n解离阶段提供了对 $k_{\\text{off}}$ 的直接测量。模型是简单的指数衰减：$R_{\\text{diss}}(t') = R_{\\text{end\\_assoc}} e^{-k_{\\text{off}}t'}$。为了执行稳健的线性拟合，通过取自然对数来转换此方程：\n$$\n\\ln(R_{\\text{diss}}(t')) = \\ln(R_{\\text{end\\_assoc}}) - k_{\\text{off}}t'\n$$\n该方程是 $y=mx+b$ 的直线形式，其中 $y = \\ln(R_{\\text{diss}}(t'))$，$x = t'$，斜率 $m = -k_{\\text{off}}$，y轴截距 $b = \\ln(R_{\\text{end\\_assoc}})$。对于每个浓度，对经过对数转换的解离数据进行线性回归。拟合斜率的负值即为 $k_{\\text{off}}$ 的一个估计值。$k_{\\text{off}}$ 的最终估计值是通过对一个测试用例中所有浓度下的解离曲线得出的值进行平均而获得的。\n\n**B部分：从结合数据中估计 $k_{\\text{on}}$**\n结合阶段数据遵循模型 $R_{\\text{assoc}}(t) = R_{eq}(1 - e^{-k_{\\text{obs}}t})$。对于每个浓度 $C$，对结合曲线进行非线性最小二乘拟合，以估计参数 $R_{eq}$ 和 $k_{\\text{obs}}$。这将产生一组数对 $(C_i, k_{\\text{obs},i})$。\n\n根据动力学模型，$k_{\\text{obs}}$ 线性依赖于分析物浓度 $C$：\n$$\nk_{\\text{obs}} = k_{\\text{on}}C + k_{\\text{off}}\n$$\n这同样是直线形式 $y = mx+b$，其中 $y=k_{\\text{obs}}$，$x=C$，斜率 $m = k_{\\text{on}}$，y轴截距 $b = k_{\\text{off}}$。通过对这组 $(C_i, k_{\\text{obs},i})$ 点进行线性回归，我们从斜率中获得 $k_{\\text{on}}$ 的估计值，并从截距中获得 $k_{\\text{off}}$ 的独立估计值。根据问题的指示，此拟合的斜率被作为 $k_{\\text{on}}$ 的最终估计值。\n\n**3. 最终计算和报告**\n每个测试用例最终报告的值是：\n- $k_{\\text{on}}$：$k_{\\text{obs}}$ 对 $C$ 的线性拟合的斜率。\n- $k_{\\text{off}}$：来自单个解离曲线指数拟合的估计值的平均值。\n- $K_d$：解离常数，由上述估计值计算得出，$K_d = \\frac{k_{\\text{off}}}{k_{\\text{on}}}$。\n\n由于输入数据是由用于拟合的相同模型人工合成生成的，并且不含噪声，因此这个“往返”过程预计能够高精度地恢复原始真实参数，其精度仅受限于拟合算法的数值精度。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Main function to simulate BLI data and estimate kinetic parameters.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Variant A\",\n            \"k_on_true\": 1.7e5,\n            \"k_off_true\": 9.0e-3,\n            \"R_max\": 1.1,\n            \"concentrations\": np.array([1.0e-9, 1.0e-8, 5.0e-8]),\n        },\n        {\n            \"name\": \"Variant B\",\n            \"k_on_true\": 8.0e4,\n            \"k_off_true\": 2.5e-3,\n            \"R_max\": 0.9,\n            \"concentrations\": np.array([2.0e-9, 1.5e-8, 6.0e-8]),\n        },\n        {\n            \"name\": \"Variant C\",\n            \"k_on_true\": 2.2e5,\n            \"k_off_true\": 5.0e-4,\n            \"R_max\": 1.0,\n            \"concentrations\": np.array([5.0e-10, 5.0e-9, 5.0e-8]),\n        },\n    ]\n\n    T_assoc = 60.0\n    T_diss = 120.0\n    dt = 0.5\n\n    t_assoc_vec = np.arange(0, T_assoc + dt, dt)\n    t_diss_vec = np.arange(0, T_diss + dt, dt)\n\n    final_results = []\n\n    for case in test_cases:\n        k_on_true = case[\"k_on_true\"]\n        k_off_true = case[\"k_off_true\"]\n        R_max = case[\"R_max\"]\n        concentrations = case[\"concentrations\"]\n\n        estimated_k_offs_from_diss = []\n        k_obs_pairs = []\n\n        for C in concentrations:\n            # 1. Data Generation\n            # Association phase\n            k_obs_true = k_on_true * C + k_off_true\n            R_eq = (k_on_true * C * R_max) / k_obs_true\n            R_assoc = R_eq * (1 - np.exp(-k_obs_true * t_assoc_vec))\n            \n            # Dissociation phase\n            R_end_assoc = R_assoc[-1]\n            R_diss = R_end_assoc * np.exp(-k_off_true * t_diss_vec)\n\n            # 2. Parameter Estimation\n            # Part A: Estimate k_off from dissociation data\n            # Using log-linear fit: log(R) = log(R0) - k_off * t\n            # The slope of the linear fit of log(R) vs. t is -k_off\n            # We filter out any R values that are too small to avoid log(0) issues,\n            # though it is not expected with this noiseless data.\n            valid_diss_indices = R_diss > 1e-12 \n            slope, _ = np.polyfit(t_diss_vec[valid_diss_indices], np.log(R_diss[valid_diss_indices]), 1)\n            k_off_est = -slope\n            estimated_k_offs_from_diss.append(k_off_est)\n\n            # Part B: Estimate k_obs from association data\n            # Non-linear fit to R(t) = Req * (1 - exp(-k_obs * t))\n            def assoc_model(t, Req, k_obs):\n                return Req * (1 - np.exp(-k_obs * t))\n            \n            # Provide initial guesses to aid the fitter\n            p0 = (np.max(R_assoc), 0.01) \n            popt, _ = curve_fit(assoc_model, t_assoc_vec, R_assoc, p0=p0)\n            k_obs_est = popt[1]\n            k_obs_pairs.append((C, k_obs_est))\n\n        # 3. Finalize parameter estimates for the test case\n        # Final k_off is the average from all dissociation curves\n        k_off_final = np.mean(estimated_k_offs_from_diss)\n\n        # Final k_on is from the slope of k_obs vs. C\n        C_vals = np.array([pair[0] for pair in k_obs_pairs])\n        k_obs_vals = np.array([pair[1] for pair in k_obs_pairs])\n        \n        # Linear regression: k_obs = k_on * C + k_off\n        slope, intercept = np.polyfit(C_vals, k_obs_vals, 1)\n        k_on_final = slope\n        \n        # Calculate Kd\n        Kd_final = k_off_final / k_on_final\n\n        final_results.append([k_on_final, k_off_final, Kd_final])\n\n    # Format the final output string as specified\n    output_str = \"[\"\n    for i, result in enumerate(final_results):\n        k_on, k_off, Kd = result\n        output_str += f\"[{k_on:.6e},{k_off:.6e},{Kd:.6e}]\"\n        if i  len(final_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n        \n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "变异引起的生物物理特性改变，其效应会级联传递到关键的细胞过程中，例如可变剪接。RNA测序（RNA-seq）为我们提供了转录组的快照，使我们能够量化不同剪接异构体的相对丰度。一个关键指标——剪接包含百分比（Percent Spliced-In, $\\Psi$）——被用来总结这些效应。本练习  要求您从第一性原理出发，推导 $\\Psi$ 的统计估计量及其方差。掌握这一基础推导对于严格解释任何基于测序技术的计数数据至关重要。",
            "id": "4342287",
            "problem": "在一次使用核糖核酸测序 (RNA-seq) 来表征基因组变异对盒式外显子影响的功能性基因组学分析中，“剪接包含百分比”(PSI) 是指在所有携带包含或排除连接的分子中，包含该外显子的信使核糖核酸分子所占的比例。形式上，对于一个具有两种互斥连接结果（包含和排除）的二元剪接事件，PSI 是根据真实的连接使用概率来定义的。假设以下符合情景的基本依据：分子生物学的中心法则；RNA-seq 读数计数提供了底层转录本丰度的带噪声样本这一概念；以及一个二项采样模型，其中每个跨连接的读数都是从异构体使用分布中进行的独立同分布抽样。\n\n您在单个样本中观察到该外显子有 $N_{\\text{inc}}$ 个包含连接的读数和 $N_{\\text{exc}}$ 个排除连接的读数。在上述假设下：\n- 精确定义 PSI（记为 $\\,\\Psi\\,$）作为底层连接使用分布的一个参数。\n- 从二项似然出发，基于观察到的计数 $\\,N_{\\text{inc}}\\,$ 和 $\\,N_{\\text{exc}}\\,$，推导 $\\,\\Psi\\,$ 的最大似然估计量。\n- 在二项模型下，推导该估计量的抽样方差，并提供一个仅依赖于 $\\,N_{\\text{inc}}\\,$ 和 $\\,N_{\\text{exc}}\\,$ 的一致插件估计量。\n- 使用观察到的计数 $\\,N_{\\text{inc}} = 87\\,$ 和 $\\,N_{\\text{exc}} = 213\\,$，计算抽样方差的插件估计值。将您的答案四舍五入到四位有效数字。将您的最终答案表示为标准科学记数法 $a \\times 10^{b}$（其中 $1 \\leq |a|  10$）的无量纲小数。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于核糖核酸测序 (RNA-seq) 数据的标准统计建模，问题提法恰当，信息充分，可得出唯一解，并且以客观、正式的语言表述。因此，我们可以开始解题。\n\n该问题要求进行几项与来自 RNA-seq 数据的剪接包含百分比（$\\text{PSI}$ 或 $\\Psi$）相关的推导，并最终进行一次数值计算。我们将按顺序处理每个部分。\n\n首先，我们必须精确定义参数 $\\Psi$。问题陈述指出，对于一个二元剪接事件，每个跨连接的读数都是一次独立同分布的抽样。这对应于一个伯努利试验序列。设 $X_i$ 是一个随机变量，表示第 $i$ 个读数的结果，其中 $i = 1, \\dots, N$。我们可以定义，如果读数来自包含连接，则结果 $X_i=1$；如果来自排除连接，则结果 $X_i=0$。参数 $\\Psi$ 是每次试验的成功概率，即一个随机选择的跨连接读数支持外显子包含异构体的概率。\n$$\nP(X_i = 1) = \\Psi\n$$\n$$\nP(X_i = 0) = 1 - \\Psi\n$$\n因此，$\\Psi$ 是支配任何单个观察分子的剪接结果的底层伯努利分布的参数。\n\n第二，我们推导 $\\Psi$ 的最大似然估计量 ($\\text{MLE}$)。我们观察到 $N_{\\text{inc}}$ 个包含读数和 $N_{\\text{exc}}$ 个排除读数。观察到的跨连接读数总数为 $N = N_{\\text{inc}} + N_{\\text{exc}}$。包含读数的数量 $N_{\\text{inc}}$ 可以被建模为一个随机变量，服从试验次数为 $N$、成功概率为 $\\Psi$ 的二项分布。其概率质量函数为：\n$$\nP(N_{\\text{inc}} | N, \\Psi) = \\binom{N}{N_{\\text{inc}}} \\Psi^{N_{\\text{inc}}} (1-\\Psi)^{N-N_{\\text{inc}}}\n$$\n给定观察到的数据（$N_{\\text{inc}}$ 和 $N_{\\text{exc}}$），似然函数 $L(\\Psi)$ 是观察到这些数据的概率，它被看作是参数 $\\Psi$ 的函数：\n$$\nL(\\Psi | N_{\\text{inc}}, N_{\\text{exc}}) = \\binom{N_{\\text{inc}}+N_{\\text{exc}}}{N_{\\text{inc}}} \\Psi^{N_{\\text{inc}}} (1-\\Psi)^{N_{\\text{exc}}}\n$$\n为了找到 $\\text{MLE}$，计算上更简单的方法是最大化对数似然函数 $\\ell(\\Psi) = \\ln(L(\\Psi))$：\n$$\n\\ell(\\Psi) = \\ln\\left(\\binom{N_{\\text{inc}}+N_{\\text{exc}}}{N_{\\text{inc}}}\\right) + N_{\\text{inc}}\\ln(\\Psi) + N_{\\text{exc}}\\ln(1-\\Psi)\n$$\n我们通过对 $\\Psi$ 求导并令其为零来找到最大值。\n$$\n\\frac{d\\ell}{d\\Psi} = \\frac{N_{\\text{inc}}}{\\Psi} - \\frac{N_{\\text{exc}}}{1-\\Psi}\n$$\n将导数设为 $0$：\n$$\n\\frac{N_{\\text{inc}}}{\\hat{\\Psi}} - \\frac{N_{\\text{exc}}}{1-\\hat{\\Psi}} = 0 \\implies \\frac{N_{\\text{inc}}}{\\hat{\\Psi}} = \\frac{N_{\\text{exc}}}{1-\\hat{\\Psi}}\n$$\n$$\nN_{\\text{inc}}(1-\\hat{\\Psi}) = N_{\\text{exc}}\\hat{\\Psi}\n$$\n$$\nN_{\\text{inc}} - N_{\\text{inc}}\\hat{\\Psi} = N_{\\text{exc}}\\hat{\\Psi}\n$$\n$$\nN_{\\text{inc}} = (N_{\\text{inc}} + N_{\\text{exc}})\\hat{\\Psi}\n$$\n解出 $\\hat{\\Psi}$，即 $\\Psi$ 的最大似然估计量，我们得到：\n$$\n\\hat{\\Psi} = \\frac{N_{\\text{inc}}}{N_{\\text{inc}} + N_{\\text{exc}}}\n$$\n\n第三，我们推导估计量 $\\hat{\\Psi}$ 的抽样方差。估计量 $\\hat{\\Psi}$ 是随机变量 $N_{\\text{inc}}$ 和总计数 $N = N_{\\text{inc}} + N_{\\text{exc}}$ 的函数，后者被视为固定的试验次数。\n$$\n\\hat{\\Psi} = \\frac{N_{\\text{inc}}}{N}\n$$\n该估计量的方差为：\n$$\n\\text{Var}(\\hat{\\Psi}) = \\text{Var}\\left(\\frac{N_{\\text{inc}}}{N}\\right) = \\frac{1}{N^2}\\text{Var}(N_{\\text{inc}})\n$$\n由于 $N_{\\text{inc}}$ 服从二项分布 $\\text{Bin}(N, \\Psi)$，其方差为 $\\text{Var}(N_{\\text{inc}}) = N\\Psi(1-\\Psi)$。将此代入 $\\text{Var}(\\hat{\\Psi})$ 的方程中：\n$$\n\\text{Var}(\\hat{\\Psi}) = \\frac{1}{N^2} \\left[N\\Psi(1-\\Psi)\\right] = \\frac{\\Psi(1-\\Psi)}{N}\n$$\n代入 $N = N_{\\text{inc}} + N_{\\text{exc}}$，该估计量的抽样方差为：\n$$\n\\text{Var}(\\hat{\\Psi}) = \\frac{\\Psi(1-\\Psi)}{N_{\\text{inc}} + N_{\\text{exc}}}\n$$\n这个表达式依赖于真实的、未知的参数 $\\Psi$。该方差的一个一致插件估计量，记为 $\\widehat{\\text{Var}}(\\hat{\\Psi})$，是通过将未知参数 $\\Psi$ 替换为其一致估计量 $\\hat{\\Psi}$ 来获得的：\n$$\n\\widehat{\\text{Var}}(\\hat{\\Psi}) = \\frac{\\hat{\\Psi}(1-\\hat{\\Psi})}{N} = \\frac{\\hat{\\Psi}(1-\\hat{\\Psi})}{N_{\\text{inc}} + N_{\\text{exc}}}\n$$\n我们可以通过代入 $\\hat{\\Psi}$ 的表达式，将其完全用观察到的计数来表示：\n$$\n\\hat{\\Psi} = \\frac{N_{\\text{inc}}}{N_{\\text{inc}} + N_{\\text{exc}}} \\quad \\text{和} \\quad 1-\\hat{\\Psi} = \\frac{N_{\\text{exc}}}{N_{\\text{inc}} + N_{\\text{exc}}}\n$$\n$$\n\\widehat{\\text{Var}}(\\hat{\\Psi}) = \\frac{\\left(\\frac{N_{\\text{inc}}}{N_{\\text{inc}} + N_{\\text{exc}}}\\right)\\left(\\frac{N_{\\text{exc}}}{N_{\\text{inc}} + N_{\\text{exc}}}\\right)}{N_{\\text{inc}} + N_{\\text{exc}}} = \\frac{N_{\\text{inc}}N_{\\text{exc}}}{(N_{\\text{inc}} + N_{\\text{exc}})^3}\n$$\n这就是所要求的抽样方差的一致插件估计量。\n\n第四，我们使用观察到的计数 $N_{\\text{inc}} = 87$ 和 $N_{\\text{exc}} = 213$ 来计算该插件估计的数值。\n读数总数为 $N = N_{\\text{inc}} + N_{\\text{exc}} = 87 + 213 = 300$。\n估计的 PSI 为 $\\hat{\\Psi} = \\frac{87}{300} = 0.29$。\n方差的插件估计值为：\n$$\n\\widehat{\\text{Var}}(\\hat{\\Psi}) = \\frac{\\hat{\\Psi}(1-\\hat{\\Psi})}{N} = \\frac{(0.29)(1 - 0.29)}{300} = \\frac{(0.29)(0.71)}{300}\n$$\n$$\n\\widehat{\\text{Var}}(\\hat{\\Psi}) = \\frac{0.2059}{300} \\approx 0.000686333...\n$$\n或者，使用估计量的另一种形式：\n$$\n\\widehat{\\text{Var}}(\\hat{\\Psi}) = \\frac{(87)(213)}{(87+213)^3} = \\frac{18531}{300^3} = \\frac{18531}{27000000} \\approx 0.000686333...\n$$\n问题要求答案四舍五入到四位有效数字，并用标准科学记数法表示。\n该值为 $0.000686333...$。前四位有效数字是 $6$、$8$、$6$ 和 $3$。四舍五入后得到 $0.0006863$。\n在标准科学记数法 $a \\times 10^b$（其中 $1 \\leq |a|  10$）下，这表示为 $6.863 \\times 10^{-4}$。",
            "answer": "$$\\boxed{6.863 \\times 10^{-4}}$$"
        },
        {
            "introduction": "为了在基因组尺度上理解基因功能和变异效应，我们采用高通量方法，如混合CRISPR筛选。这些筛选产生大量的计数数据，反映了靶向基因扰动如何影响细胞适应性或其他表型。分析这些数据需要复杂的统计模型，以从实验噪音中辨别出真实的生物学效应。在这个高级实践中 ，您将为CRISPR筛选数据实施一个核心分析流程，使用加权最小二乘法的广义线性模型（GLM）。这将使您具备处理现代功能基因组学数据集的复杂性和规模的技能。",
            "id": "4342320",
            "problem": "您将获得来自成簇规律间隔短回文重复序列 (CRISPR) 池化筛选的计数数据，其中每个向导RNA (gRNA) 靶向一个基因，并在两个时间点测量其读数计数。目标是计算经文库大小归一化的对数倍数变化，然后拟合一个广义线性模型 (GLM) 以从靶向同一基因的多个 gRNA 中推断基因水平的效应。\n\n基本原理：\n- 在池化 CRISPR 筛选中，给定时间点每个 gRNA 的测序读数计数可以很好地用一个泊松抽样过程来近似，其均值与真实丰度和文库大小成正比。如果 $c_i(t)$ 表示 gRNA $i$ 在时间 $t$ 的观测计数，$L_t$ 表示在时间 $t$ 的总文库大小，那么 gRNA $i$ 在时间 $t$ 的归一化丰度为 $n_i(t) = \\dfrac{c_i(t) + s}{L_t}$，其中 $s  0$ 是一个小的伪计数，用于稳定比率并避免除以零。\n- gRNA $i$ 在时间 $t_0$ 和 $t_1$ 之间的对数倍数变化定义为\n$$\n\\ell_i = \\log_2\\left(\\frac{n_i(t_1)}{n_i(t_0)}\\right) = \\log_2\\left(\\frac{c_i(t_1)+s}{c_i(t_0)+s}\\right) + \\log_2\\left(\\frac{L_{t_0}}{L_{t_1}}\\right)\n$$.\n- 在泊松模型以及 $c_i(t_0)$ 和 $c_i(t_1)$ 相互独立的假设下，delta 方法给出了以 2 为底的对数倍数变化的近似方差：\n$$\n\\operatorname{Var}(\\ell_i) \\approx \\frac{1}{(\\ln 2)^2} \\left(\\frac{1}{c_i(t_1)+s} + \\frac{1}{c_i(t_0)+s}\\right)\n$$.\n- 为了推断基因水平的效应，使用高斯 GLM（正态分布与恒等连接函数）和异方差误差来对 gRNA 水平的对数倍数变化进行建模，并采用加权最小二乘法：\n$$\n\\ell_i = \\alpha + \\sum_{g \\in \\mathcal{G}\\setminus\\{g_{\\text{base}}\\}} \\beta_g \\cdot \\mathbf{1}\\{g_i = g\\} + \\varepsilon_i\n$$,\n其中 $g_i$ 是 gRNA $i$ 靶向的基因，$\\alpha$ 是截距，$g_{\\text{base}}$ 是一个选定的基线基因（例如，非靶向对照），$\\beta_g$ 是相对于基线的基因水平效应，$\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma_i^2)$ 且 $\\sigma_i^2 \\approx \\operatorname{Var}(\\ell_i)$。加权最小二乘法得出\n$$\n\\hat{\\boldsymbol{\\theta}} = \\left(\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X}\\right)^{-1} \\mathbf{X}^\\top \\mathbf{W} \\mathbf{y}\n$$,\n其中 $\\mathbf{y}$ 是 $\\ell_i$ 的向量，$\\mathbf{X}$ 是设计矩阵，包含一列全为 1（截距）以及除基线基因外每个基因的独热指示变量，$\\mathbf{W}$ 是一个对角矩阵，其对角线元素为 $w_i = 1/\\sigma_i^2$。\n\n任务：\n编写一个 Python 程序来：\n1. 对于每个提供的测试用例，使用上述公式计算所有 gRNA 的经文库大小归一化的以 2 为底的对数倍数变化 $\\ell_i$。\n2. 使用上述方差近似值计算权重 $w_i = 1/\\operatorname{Var}(\\ell_i)$。\n3. 构建设计矩阵 $\\mathbf{X}$，该矩阵包含一个截距列和除给定基线基因外的每个基因的独热编码列。\n4. 拟合加权最小二乘模型以估计相对于基线的基因水平效应 $\\beta_g$。\n5. 对于每个测试用例，输出一个列表，其中包含按基因标签（不包括基线基因）字典序排列的估计基因效应。将每个估计效应四舍五入到六位小数。\n\n假设：\n- 所有计数 $c_i(t)$ 都是非负整数。\n- 伪计数 $s$ 是一个给定的严格正数。\n- 对于每个测试用例，文库大小 $L_{t_0}$ 和 $L_{t_1}$ 是已知的正常数。\n\n角度单位不适用。答案中不使用物理单位。所有输出必须是四舍五入到六位小数的浮点数。\n\n测试套件：\n- 案例 1（一般情况，每个基因有多个向导，文库大小平衡）：\n    - $t_0$ 时的计数：$[1000, 1200, 900, 1100, 800, 850]$\n    - $t_1$ 时的计数：$[980, 1180, 600, 700, 1200, 1300]$\n    - 基因标签：$[\\text{NTC}, \\text{NTC}, \\text{G1}, \\text{G1}, \\text{G2}, \\text{G2}]$\n    - 基线基因：$\\text{NTC}$\n    - 文库大小：$(L_{t_0}, L_{t_1}) = (1000000, 1000000)$\n    - 伪计数：$s = 1$\n- 案例 2（包含零计数和不等文库大小的边缘情况）：\n    - $t_0$ 时的计数：$[500, 600, 400, 450]$\n    - $t_1$ 时的计数：$[520, 590, 0, 10]$\n    - 基因标签：$[\\text{NTC}, \\text{NTC}, \\text{G3}, \\text{G3}]$\n    - 基线基因：$\\text{NTC}$\n    - 文库大小：$(L_{t_0}, L_{t_1}) = (1000000, 800000)$\n    - 伪计数：$s = 1$\n- 案例 3（一个基因只有一个向导的边界情况）：\n    - $t_0$ 时的计数：$[2000, 2100, 1500]$\n    - $t_1$ 时的计数：$[1990, 2050, 1600]$\n    - 基因标签：$[\\text{NTC}, \\text{NTC}, \\text{G4}]$\n    - 基线基因：$\\text{NTC}$\n    - 文库大小：$(L_{t_0}, L_{t_1}) = (2000000, 2000000)$\n    - 伪计数：$s = 1$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的列表的逗号分隔列表。每个内部列表对应一个测试用例，并包含按基因标签字典序排列的估计基因效应（不包括基线基因），并四舍五入到六位小数。例如，打印的输出必须如下所示\n`[[x_1,x_2],[y_1],[z_1]]`\n其中 $x_i$、$y_i$ 和 $z_i$ 是具有六位小数的浮点数。",
            "solution": "该问题要求使用广义线性模型 (GLM) 从 CRISPR 池化筛选计数数据中估计基因水平的效应。所提供的框架是分析此类数据的标准且统计上可靠的方法。解决方案通过实施指定的分析工作流程来推进，该流程涉及数据归一化、方差估计和拟合加权最小二乘 (WLS) 模型。\n\n问题的核心在于求解 WLS 估计的矩阵方程：\n$$\n\\hat{\\boldsymbol{\\theta}} = \\left(\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X}\\right)^{-1} \\mathbf{X}^\\top \\mathbf{W} \\mathbf{y}\n$$\n其中 $\\hat{\\boldsymbol{\\theta}}$ 是估计系数（截距和基因效应）的向量，$\\mathbf{X}$ 是设计矩阵，$\\mathbf{W}$ 是对角权重矩阵，$\\mathbf{y}$ 是观测到的对数倍数变化向量。\n\n每个测试用例的步骤如下：\n\n1.  **计算对数倍数变化 (LFCs)**：响应向量，表示为 $\\mathbf{y}$，由每个 gRNA $i$ 的经文库大小归一化的以 2 为底的对数倍数变化 $\\ell_i$ 组成。给定时间 $t_0$ 和 $t_1$ 的原始计数 $c_i(t_0)$ 和 $c_i(t_1)$，总文库大小 $L_{t_0}$ 和 $L_{t_1}$，以及伪计数 $s  0$，gRNA $i$ 的 LFC 计算如下：\n    $$\n    \\ell_i = \\log_2\\left(\\frac{c_i(t_1)+s}{c_i(t_0)+s}\\right) + \\log_2\\left(\\frac{L_{t_0}}{L_{t_1}}\\right)\n    $$\n    这个 $\\ell_i$ 值的向量构成了 WLS 模型中的响应向量 $\\mathbf{y}$。\n\n2.  **计算权重**：每个 LFC 测量值 $\\ell_i$ 的精度取决于原始读数计数。delta 方法为 $\\ell_i$ 提供了一个近似方差：\n    $$\n    \\sigma_i^2 = \\operatorname{Var}(\\ell_i) \\approx \\frac{1}{(\\ln 2)^2} \\left(\\frac{1}{c_i(t_1)+s} + \\frac{1}{c_i(t_0)+s}\\right)\n    $$\n    在加权最小二乘法中，每个观测值都按其方差的倒数进行加权，以便为更精确的测量值赋予更大的影响。因此，观测值 $i$ 的权重 $w_i$ 为 $w_i = 1/\\sigma_i^2$。这些权重构成了权重矩阵 $\\mathbf{W}$ 的对角线元素，其中所有非对角线元素均为零。\n    $$\n    w_i = \\frac{(\\ln 2)^2}{\\frac{1}{c_i(t_1)+s} + \\frac{1}{c_i(t_0)+s}}\n    $$\n\n3.  **构建设计矩阵**：设计矩阵 $\\mathbf{X}$ 编码了 gRNA 与待估计基因效应之间的关系。模型为：\n    $$\n    \\ell_i = \\alpha + \\sum_{g \\in \\mathcal{G}\\setminus\\{g_{\\text{base}}\\}} \\beta_g \\cdot \\mathbf{1}\\{g_i = g\\} + \\varepsilon_i\n    $$\n    在这里，$\\alpha$ 是截距，代表基线基因（$g_{\\text{base}}$）的效应，$\\beta_g$ 是基因 $g$ 相对于此基线的差异效应。为了构建 $\\mathbf{X}$，我们首先识别出唯一的非基线基因集合，并按字典序对其进行排序。$\\mathbf{X}$ 的第一列是一列全为 1 的值，对应于截距 $\\alpha$。后续列是每个非基线基因的指示变量（独热编码）。对于给定的基因 $g$，如果 gRNA $i$ 靶向基因 $g$，则其对应列的第 $i$ 行将为 $1$，否则为 $0$。这种表示法可以防止完全多重共线性（“虚拟变量陷阱”），并使模型参数可识别。\n\n4.  **求解 WLS 系统**：构建好 $\\mathbf{y}$、$\\mathbf{W}$ 和 $\\mathbf{X}$ 后，通过求解 WLS 的“正规方程组”来找到系数向量 $\\hat{\\boldsymbol{\\theta}} = [\\hat{\\alpha}, \\hat{\\beta}_{g_1}, \\hat{\\beta}_{g_2}, \\dots]^\\top$。我们不直接计算矩阵逆 $(\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X})^{-1}$（这在数值上可能不稳定），而是求解等价且更稳定的线性系统：\n    $$\n    \\left(\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X}\\right) \\hat{\\boldsymbol{\\theta}} = \\mathbf{X}^\\top \\mathbf{W} \\mathbf{y}\n    $$\n    这是一个标准的线性代数问题。解向量 $\\hat{\\boldsymbol{\\theta}}$ 的第一个元素是估计的截距 $\\hat{\\alpha}$，其后是按构建 $\\mathbf{X}$ 时所用相同字典序排列的估计基因效应 $\\hat{\\beta}_g$。\n\n5.  **生成输出**：最后一步是从向量 $\\hat{\\boldsymbol{\\theta}}$ 中提取基因效应 $\\hat{\\beta}_g$（即除第一个元素外的所有元素），将它们四舍五入到指定的六位小数，并根据每个测试用例的输出要求进行格式化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"c0\": [1000, 1200, 900, 1100, 800, 850],\n            \"c1\": [980, 1180, 600, 700, 1200, 1300],\n            \"gene_labels\": [\"NTC\", \"NTC\", \"G1\", \"G1\", \"G2\", \"G2\"],\n            \"baseline_gene\": \"NTC\",\n            \"library_sizes\": (1000000, 1000000),\n            \"s\": 1\n        },\n        {\n            \"c0\": [500, 600, 400, 450],\n            \"c1\": [520, 590, 0, 10],\n            \"gene_labels\": [\"NTC\", \"NTC\", \"G3\", \"G3\"],\n            \"baseline_gene\": \"NTC\",\n            \"library_sizes\": (1000000, 800000),\n            \"s\": 1\n        },\n        {\n            \"c0\": [2000, 2100, 1500],\n            \"c1\": [1990, 2050, 1600],\n            \"gene_labels\": [\"NTC\", \"NTC\", \"G4\"],\n            \"baseline_gene\": \"NTC\",\n            \"library_sizes\": (2000000, 2000000),\n            \"s\": 1\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        betas = _estimate_gene_effects(**case)\n        all_results.append(betas)\n\n    # Format the final output string as specified.\n    case_strings = []\n    for result_list in all_results:\n        num_strings = [f\"{b:.6f}\" for b in result_list]\n        case_strings.append(f'[{\",\".join(num_strings)}]')\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\ndef _estimate_gene_effects(c0, c1, gene_labels, baseline_gene, library_sizes, s):\n    \"\"\"\n    Performs CRISPR screen analysis for a single case.\n    Computes log-fold changes, weights, and fits a WLS model to get gene effects.\n    \"\"\"\n    # Ensure inputs are numpy arrays for vectorized operations\n    c0 = np.array(c0, dtype=float)\n    c1 = np.array(c1, dtype=float)\n    gene_labels = np.array(gene_labels)\n    L0, L1 = library_sizes\n\n    # 1. Compute log fold changes (the response vector y)\n    # l_i = log2((c1_i+s)/(c0_i+s)) + log2(L0/L1)\n    log2_lib_ratio = np.log2(L0 / L1)\n    y = np.log2(c1 + s) - np.log2(c0 + s) + log2_lib_ratio\n\n    # 2. Compute weights for WLS (the weight matrix W)\n    # Var(l_i) approx (1/ln(2)^2) * (1/(c1+s) + 1/(c0+s))\n    # w_i = 1 / Var(l_i)\n    ln2_squared = np.log(2)**2\n    # Add a small epsilon to denominator to prevent division by zero if c0+s or c1+s is somehow zero\n    var_lfc = (1 / ln2_squared) * (1 / (c1 + s + 1e-9) + 1 / (c0 + s + 1e-9))\n    weights = 1 / var_lfc\n    W = np.diag(weights)\n\n    # 3. Construct the design matrix X\n    # Get unique non-baseline genes, sorted lexicographically\n    unique_genes = np.unique(gene_labels)\n    target_genes = sorted([g for g in unique_genes if g != baseline_gene])\n\n    # First column is the intercept\n    intercept_col = np.ones(len(gene_labels))\n    X_cols = [intercept_col]\n\n    # Add a one-hot encoded column for each target gene\n    for gene in target_genes:\n        gene_col = (gene_labels == gene).astype(int)\n        X_cols.append(gene_col)\n\n    X = np.stack(X_cols, axis=1)\n\n    # 4. Solve the WLS system for coefficients theta\n    # (X.T @ W @ X) @ theta = X.T @ W @ y\n    # Use np.linalg.solve for numerical stability\n    XT_W = X.T @ W\n    XT_W_X = XT_W @ X\n    XT_W_y = XT_W @ y\n\n    theta = np.linalg.solve(XT_W_X, XT_W_y)\n\n    # 5. Extract gene effects (betas)\n    # The estimated coefficients in theta are [alpha, beta_g1, beta_g2, ...]\n    # The gene effects are all coefficients after the first (intercept).\n    betas = theta[1:]\n\n    return betas\n\nsolve()\n```"
        }
    ]
}