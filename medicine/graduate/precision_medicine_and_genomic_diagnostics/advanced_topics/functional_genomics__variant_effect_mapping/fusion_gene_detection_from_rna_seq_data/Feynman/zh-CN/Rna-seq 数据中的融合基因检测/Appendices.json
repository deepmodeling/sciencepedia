{
    "hands_on_practices": [
        {
            "introduction": "在融合基因检测中，首要的挑战是如何从一堆在基因边界处被“软剪切”的测序片段中，识别出未知的融合伴侣基因序列。本练习将指导你构建一个简化的生物信息学流程，从这些零散的读长（reads）中新生（de novo）组装出一段共有序列，然后将其定位到转录组上，从而锁定融合伴侣。这个过程模拟了许多真实世界中融合基因检测工具的核心逻辑 。",
            "id": "4342701",
            "problem": "给定一个在基因边界处出现的软剪切（soft-clipped）核糖核酸测序（RNA-Seq）读取簇（cluster）。每条软剪切读取都是一条读取的未比对后缀，该读取的前缀已比对到边界基因上。目标是从这些软剪切读取中从头组装（de novo）伴侣侧的融合连接点序列，然后在不知道伴侣基因身份的情况下，将组装好的序列映射到一组候选转录本序列中，以识别最可能的伴侣基因及其断点坐标。\n\n使用以下基本依据和定义作为出发点：\n- 分子生物学中心法则：脱氧核糖核酸（DNA）转录为核糖核酸（RNA），RNA被测序以产生短读取。每条读取都是一个表达的转录本的子字符串，可能带有随机的碱基识别错误。\n- 测序错误模型：对于某个位置上的真实核苷酸，观测到的碱基以概率 $e \\in [0,1)$ 被独立地、均等地随机替换为其他碱基之一；以概率 $(1-e)$ 观测到的碱基是正确的。\n- 基因组比对与软剪切：软剪切后缀表示一条读取的前缀比对到参考位点，而其后缀没有比对上。在基因融合事件中，边界基因处的软剪切后缀簇在伴侣转录本中有一个共同的来源，始于融合断点。\n\n设计并实现一个程序，在给定软剪切读取簇和转录组参考的情况下，对每个簇执行以下操作：\n1. 通过对假定在融合断点处共同起始的软剪切读取进行按位置投票，组装出一致性连接点序列：\n   - 令 $S = \\{s_1, \\ldots, s_n\\}$ 为软剪切序列的集合，其长度为 $\\ell_i$。\n   - 对于位置 $j = 0,1,\\ldots$，考虑所有长度 $\\ell_i > j$ 的读取。令 $c_{j,b}$ 为位置 $j$ 处碱基 $b \\in \\{A,C,G,T\\}$ 的计数，令 $m_j = \\max_b c_{j,b}$ 且 $t_j = \\sum_b c_{j,b}$。\n   - 定义一个包含两个参数的纳入阈值：相对多数比例 $\\alpha \\in (0.5,1]$ 和最小绝对覆盖度 $C_{\\min} \\in \\mathbb{N}$。\n   - 当且仅当 $m_j \\ge \\alpha \\cdot t_j$ 且 $t_j \\ge C_{\\min}$ 时，一致性序列延伸到位置 $j$。当此条件首次不满足时，组装停止。组装好的一致性序列长度 $L_{\\text{cons}}$ 等于被纳入位置的数量。\n   - 定义组装好的一致性序列的支持度为 $M_{\\min} = \\min_{0 \\le j  L_{\\text{cons}}} m_j$，如果 $L_{\\text{cons}} = 0$，则为 $0$。\n2. 在不知道伴侣基因的情况下，将组装好的一致性序列映射到转录组：\n   - 使用种子投票（seed-and-vote）方法。令 $k$-mer 的大小为 $k \\in \\mathbb{N}$。\n   - 为每个长度为 $L_r$ 的参考转录本 $T_r$（$r \\in \\{0,1,\\ldots,R-1\\}$）的所有 $k$-mer 构建一个到其位置的索引。对于长度为 $L_{\\text{cons}}$ 的一致性序列 $x$，对于每个位置 $u \\in \\{0,\\ldots,L_{\\text{cons}}-k\\}$ 处的 $k$-mer $x[u:u+k)$，检索其在转录本中的出现位置，并计算偏移量投票 $d = p - u$，其中 $p$ 是转录本中的位置。对于每个转录本 $r$，选择获得最多投票的偏移量 $d_r^\\star$。\n   - 对于每个 $(r, d_r^\\star)$，计算 $x$ 和转录本窗口 $T_r[d_r^\\star: d_r^\\star + L_{\\text{cons}})$ 之间的编辑距离 $E_r$，前提是 $0 \\le d_r^\\star$ 且 $d_r^\\star + L_{\\text{cons}} \\le L_r$。\n   - 如果归一化编辑距离满足 $E_{r^\\star} / L_{\\text{cons}} \\le \\tau$（其中 $\\tau \\in (0,1)$ 为一个阈值），则接受最佳的 $(r^\\star, d^\\star)$。如果没有候选者满足此条件，则映射失败。\n3. 定义一个簇的成功为一个布尔值，表示组装产生 $L_{\\text{cons}} \\ge k$ 并且映射成功。\n\n你的程序必须实现上述过程，并运行下面定义的固定测试套件。没有外部输入；所有参数和数据生成都必须完全按照规定嵌入程序中。最终输出必须是一行，打印所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果是一个列表，形式如下：\n- $[ \\text{success}, L_{\\text{cons}}, r^\\star, d^\\star, M_{\\min} ]$\n其中 $\\text{success}$ 是一个布尔值，$L_{\\text{cons}}$ 是一个整数，$r^\\star$ 是预测的伴侣转录本整数标识符（如果映射失败则为 $-1$），$d^\\star$ 是预测的伴侣断点偏移量整数（如果映射失败则为 $-1$），$M_{\\min}$ 是组装好的一致性序列中每个位置的最小支持度整数。\n\n对所有测试用例使用以下固定参数：\n- 多数阈值 $\\alpha = 0.6$。\n- 最小覆盖度 $C_{\\min} = 3$。\n- 种子大小 $k = 7$。\n- 映射接受阈值 $\\tau = 0.15$。\n\n转录组参考生成：\n- 使用以种子 $s_{\\text{tx}} = 1$ 初始化的伪随机数生成器，生成 $R = 3$ 个长度分别为 $[400, 420, 380]$ 的转录本，字母表为 $\\{A,C,G,T\\}$，碱基概率均等。转录本标识符按生成顺序为 $r \\in \\{0,1,2\\}$。\n\n测试套件（每个用例提供一个软剪切读取簇）：\n- 用例1（理想路径）：\n  - 使用种子 $s_1 = 11$ 进行读取模拟。\n  - 真实伴侣转录本 $r = 1$，起始位置 $s = 120$，目标片段长度 $L = 40$。\n  - 软剪切读取数量 $n = 20$。\n  - 每碱基错误率 $e = 0.02$。\n  - 对于读取 $i$，从 $[30, 40]$ 内的整数中均匀随机抽取一个读取长度 $\\ell_i$；每条读取等于真实片段的前 $\\ell_i$ 个碱基，并以错误率 $e$ 进行独立替换。\n- 用例2（边界条件：最小簇）：\n  - 使用种子 $s_2 = 12$。\n  - 真实伴侣 $r = 0$，起始位置 $s = 50$，目标长度 $L = 25$。\n  - $n = 3$, $e = 0.01$，$\\ell_i$ 从 $[18, 25]$ 中均匀抽取。\n- 用例3（噪声鲁棒性：信号和噪声的混合）：\n  - 使用种子 $s_3 = 13$ 生成信号读取，使用 $s_3' = 131$ 生成噪声读取。\n  - 真实伴侣 $r = 2$，起始位置 $s = 180$，目标长度 $L = 35$。\n  - 信号读取：$n_{\\text{sig}} = 12$，$e = 0.03$，$\\ell_i$ 如上从 $[20, 35]$ 中抽取。\n  - 噪声读取：$n_{\\text{noise}} = 7$，每条是一个随机DNA字符串，其长度从 $[18, 35]$ 中均匀抽取，且与任何转录本无关。\n- 用例4（边缘情况：无真实信号）：\n  - 使用种子 $s_4 = 14$。\n  - 纯噪声：$n = 10$，每条是一个随机DNA字符串，其长度从 $[10, 20]$ 中均匀抽取。\n\n不涉及角度单位，也没有物理单位。所有整数区间都是闭区间（包含端点）。编辑距离是标准的Levenshtein距离，替换、插入和删除的成本均为单位成本。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个结果列表，每个测试用例一个结果，其中每个结果本身也是一个指定格式的列表。例如，一个有效的格式是\n  - $[[\\text{True}, 37, 1, 120, 12],[\\text{False}, 0, -1, -1, 0],\\ldots]$\n并且项之间不需要空格。",
            "solution": "该问题要求设计并实现一个计算流程，从一批软剪切RNA-Seq读取中识别融合转录本事件中的伴侣基因。此过程分为两个主要阶段：首先，从头组装（de novo assembly）代表融合连接点伴侣侧的一致性序列；其次，将该一致性序列与参考转录组进行比对，以识别伴侣基因和断点。\n\n该解决方案遵循分子生物学的原理和标准的生物信息学算法。整个过程始于模拟生物学和技术上的产物，即基于所提供的随机模型，生成参考转录组和带错误的测序读取。这确保了测试算法的环境是可复现且定义明确的。\n\n**1. 数据模拟：转录组和读取**\n\n首先，生成一个参考转录组。它作为识别融合伴侣的搜索空间。使用一个以固定种子 $s_{\\text{tx}} = 1$ 初始化的伪随机数生成器，创建 $R=3$ 个长度分别为 $[400, 420, 380]$ 的转录本。每个转录本是来自集合 $\\{A, C, G, T\\}$ 的核苷酸序列，每个碱基以均等概率选择。这模拟了一个碱基组成均一的简化基因组。\n\n接下来，为每个测试用例模拟一个软剪切读取簇。此过程模拟了两个关键现象：\n- **融合转录本结构**：一个真实的融合事件产生的读取源于伴侣转录本的特定片段。因此，读取是根据参考转录本之一的“真实”目标片段的子字符串生成的，始于一个已定义的断点。\n- **测序错误**：高通量测序过程并非完美。这里采用一个简单的替换错误模型，即读取中的每个碱基有概率 $e$ 被错误地识别为其他三种碱基之一（概率均等）。有 $1-e$ 的概率碱基被正确读取。\n\n每个测试用例的模拟由一个独立的随机种子控制，以确保整个实验是确定性且可验证的。不同的用例模拟了多种情景：清晰的信号（用例1）、处于检测阈值的最小信号（用例2）、与随机噪声读取混合的信号（用例3），以及只有噪声的用例（用例4）。\n\n**2. 步骤1：从头一致性序列组装**\n\n给定一个软剪切读取簇 $S = \\{s_1, \\ldots, s_n\\}$，目标是重建伴侣转录本连接点最可能的序列。这是通过一种按位置投票的机制实现的。其基本原理是，源于同一融合事件的读取在序列上会高度一致，而测序错误或混杂的无关“噪声”读取将表现为少数信号。\n\n算法从位置 $j=0$ 开始，逐列进行：\n- 对于每个位置 $j$，对所有足够长以覆盖此位置的读取，统计每个碱基 $b \\in \\{A, C, G, T\\}$ 的计数 $c_{j,b}$。\n- 覆盖位置 $j$ 的总读取数即为覆盖度，$t_j = \\sum_b c_{j,b}$。\n- 最常见碱基的计数（多数票）为 $m_j = \\max_b c_{j,b}$。\n- 仅当满足两个质量控制标准时，一致性序列的组装才会延伸到位置 $j$：\n    1. **相对多数**：多数票必须占读取的显著比例，$m_j \\ge \\alpha \\cdot t_j$。参数 $\\alpha = 0.6$ 要求至少有 $60\\%$ 的一致性。\n    2. **最小覆盖度**：必须有足够数量的读取支持该投票，$t_j \\ge C_{\\min}$。参数 $C_{\\min} = 3$ 防止基于极少数读取做出决策。\n- 如果两个标准都满足，则将多数碱基附加到一致性序列上。该过程在第一个不满足任一标准的位置 $j$ 处终止。\n\n所得序列的长度为一致性序列长度 $L_{\\text{cons}}$。该组装的鲁棒性由最小支持度 $M_{\\min} = \\min_{0 \\le j  L_{\\text{cons}}} m_j$ 来量化，它是在组装好的一致性序列中任何位置上表示同意的读取的最小数量。如果没有形成一致性序列（$L_{\\text{cons}}=0$），则 $M_{\\min}=0$。\n\n**3. 步骤2：伴侣转录本映射**\n\n一旦组装出长度为 $L_{\\text{cons}}$ 的一致性序列 $x$，就必须将其映射到参考转录组以确定其来源。对所有转录本中所有可能的位置进行直接的暴力比对计算成本高昂。因此，采用了一种更高效的‘种子投票’（seed-and-vote）启发式方法。\n\n- **播种（Seeding）**：将一致性序列和所有参考转录本分解为长度固定为 $k=7$ 的短重叠子串，称为 $k$-mer。构建一个索引（哈希图），将转录组中找到的每个唯一 $k$-mer 映射到其所有位置 $(r, p)$ 的列表，其中 $r$ 是转录本标识符，p 是起始位置。\n- **投票（Voting）**：扫描一致性序列 $x$ 以获取其自身的 $k$-mer $x[u:u+k)$。对于每个这样的 $k$-mer，从索引中检索其在转录组中的位置。每个匹配，即 $x[u:u+k)$ 与 $T_r[p:p+k)$ 相同，都会为一个潜在的比对偏移量 $d = p - u$ “投票”。该偏移量代表了一致性序列在转录本 $r$ 内的假设起始位置。所有投票按转录本和偏移量进行聚合。\n- **候选选择（Candidate Selection）**：对于每个转录本 $r$，获得最多投票的偏移量 $d_r^\\star$ 被确定为最可能的比对起始位置。这构成了一个候选比对 $(r, d_r^\\star)$。\n\n- **验证（Verification）**：‘种子投票’方法仅提供候选者；它不保证良好的全长比对。通过计算完整一致性序列 $x$ 与转录本中相应窗口 $T_r[d_r^\\star : d_r^\\star + L_{\\text{cons}})$ 之间的 Levenshtein 编辑距离 $E_r$ 来验证每个候选 $(r, d_r^\\star)$。这只对不超出转录本边界的有效窗口进行。Levenshtein 距离计算将一个字符串变为另一个字符串所需的最少单字符插入、删除或替换次数，提供了一个鲁棒的相似性度量。\n\n- **接受（Acceptance）**：为了在不同长度的一致性序列之间进行公平比较，编辑距离通过一致性序列的长度进行归一化，$E_r / L_{\\text{cons}}$。选择具有最小归一化编辑距离的候选比对 $(r^\\star, d^\\star)$ 作为最佳匹配。只有当其归一化编辑距离低于指定的容忍阈值，$E_{r^\\star} / L_{\\text{cons}} \\le \\tau$（其中 $\\tau=0.15$），这个匹配才最终被接受为成功映射。该阈值允许少量差异，以适应一致性序列或测序中的残留错误。如果最佳匹配不满足此标准，或者没有找到有效的候选者，则映射过程失败。\n\n**4. 最终成功评估**\n\n对于给定的读取簇，成功检测到融合伴侣取决于通过两个检查点，这反映了对组装序列及其映射的置信度：\n1. 组装的一致性序列必须足够长以具有特异性，即 $L_{\\text{cons}} \\ge k$。长度短于种子大小 $k=7$ 的序列无法为种子投票映射策略提供基础。\n2. 该一致性序列到转录组的映射必须按照上述定义的标准成功。\n\n如果两个条件都满足，`success` 标志设置为 `True`。否则，设置为 `False`。每个测试用例的最终结果是一个结构化列表，包含此布尔标志、一致性序列长度 $L_{\\text{cons}}$、识别出的伴侣转录本 $r^\\star$ 和断点 $d^\\star$（如果映射失败则为 -1），以及最小组装支持度 $M_{\\min}$。",
            "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to run the full pipeline for all test cases.\n    \"\"\"\n    \n    # --- Fixed Parameters ---\n    ALPHA = 0.6  # Majority threshold for consensus assembly\n    C_MIN = 3    # Minimum coverage for consensus assembly\n    K = 7        # k-mer size for seed-and-vote mapping\n    TAU = 0.15   # Normalized edit distance threshold for mapping acceptance\n    BASES = ['A', 'C', 'G', 'T']\n    \n    # --- Transcriptome Generation ---\n    def generate_transcriptome(seed, lengths, bases):\n        rng = np.random.default_rng(seed)\n        transcripts = []\n        for length in lengths:\n            transcript = \"\".join(rng.choice(bases, size=length))\n            transcripts.append(transcript)\n        return transcripts\n\n    tx_lengths = [400, 420, 380]\n    transcriptome = generate_transcriptome(seed=1, lengths=tx_lengths, bases=BASES)\n\n    # --- Levenshtein Distance Implementation ---\n    def levenshtein_distance(s1, s2):\n        m, n = len(s1), len(s2)\n        if m  n:\n            return levenshtein_distance(s2, s1)\n        if n == 0:\n            return m\n        \n        prev_row = np.arange(n + 1)\n        for i, c1 in enumerate(s1):\n            curr_row = np.zeros(n + 1, dtype=np.int32)\n            curr_row[0] = i + 1\n            for j, c2 in enumerate(s2):\n                insertions = prev_row[j + 1] + 1\n                deletions = curr_row[j] + 1\n                substitutions = prev_row[j] + (c1 != c2)\n                curr_row[j+1] = min(insertions, deletions, substitutions)\n            prev_row = curr_row\n        return int(prev_row[n])\n\n    # --- Read Generation ---\n    def generate_reads_for_case(case_params, transcripts):\n        reads = []\n        bases = BASES\n        \n        # Signal reads\n        if 's_sig' in case_params:\n            rng_sig = np.random.default_rng(case_params['s_sig'])\n            r, s, L, n, e = case_params['partner_info']\n            l_min, l_max = case_params['read_len_range_sig']\n            true_segment = transcripts[r][s : s + L]\n            \n            for _ in range(n):\n                read_len = rng_sig.integers(l_min, l_max, endpoint=True)\n                read = list(true_segment[:read_len])\n                for i in range(len(read)):\n                    if rng_sig.random()  e:\n                        original_base = read[i]\n                        alt_bases = [b for b in bases if b != original_base]\n                        read[i] = rng_sig.choice(alt_bases)\n                reads.append(\"\".join(read))\n\n        # Noise reads\n        if 's_noise' in case_params:\n            rng_noise = np.random.default_rng(case_params['s_noise'])\n            n_noise = case_params['n_noise']\n            l_min, l_max = case_params['read_len_range_noise']\n            for _ in range(n_noise):\n                read_len = rng_noise.integers(l_min, l_max, endpoint=True)\n                noise_read = \"\".join(rng_noise.choice(bases, size=read_len))\n                reads.append(noise_read)\n                \n        return reads\n\n    # --- Consensus Assembly ---\n    def assemble_consensus(reads, alpha, c_min):\n        if not reads:\n            return \"\", 0, 0\n        \n        max_len = max(len(r) for r in reads) if reads else 0\n        consensus_seq = []\n        support_values = []\n        \n        for j in range(max_len):\n            counts = defaultdict(int)\n            for read in reads:\n                if j  len(read):\n                    counts[read[j]] += 1\n            \n            t_j = sum(counts.values())\n            if t_j == 0:\n                break\n                \n            m_j = 0\n            majority_base = ''\n            if counts:\n                m_j = max(counts.values())\n                majority_base = max(counts, key=counts.get)\n            \n            if m_j >= alpha * t_j and t_j >= c_min:\n                consensus_seq.append(majority_base)\n                support_values.append(m_j)\n            else:\n                break\n        \n        consensus = \"\".join(consensus_seq)\n        L_cons = len(consensus)\n        M_min = min(support_values) if support_values else 0\n        \n        return consensus, L_cons, M_min\n\n    # --- Mapping ---\n    def map_consensus(consensus, L_cons, transcripts, k, tau):\n        # 1. Build k-mer index from transcriptome\n        kmer_index = defaultdict(list)\n        for r_idx, transcript in enumerate(transcripts):\n            for p in range(len(transcript) - k + 1):\n                kmer = transcript[p : p + k]\n                kmer_index[kmer].append((r_idx, p))\n\n        # 2. Vote for offsets\n        votes = defaultdict(lambda: defaultdict(int))\n        for u in range(L_cons - k + 1):\n            kmer = consensus[u : u + k]\n            if kmer in kmer_index:\n                for r_idx, p in kmer_index[kmer]:\n                    offset = p - u\n                    votes[r_idx][offset] += 1\n        \n        # 3. Find best candidate offsets and compute edit distance\n        candidates = []\n        for r_idx, offset_counts in votes.items():\n            if not offset_counts:\n                continue\n            \n            d_star = max(offset_counts, key=offset_counts.get)\n            \n            # Check if alignment window is valid\n            if 0 = d_star and d_star + L_cons = len(transcripts[r_idx]):\n                target_window = transcripts[r_idx][d_star : d_star + L_cons]\n                edit_dist = levenshtein_distance(consensus, target_window)\n                norm_dist = edit_dist / L_cons\n                candidates.append((norm_dist, r_idx, d_star))\n        \n        # 4. Find best overall candidate and check threshold\n        if not candidates:\n            return False, -1, -1\n        \n        candidates.sort() # Sort by normalized distance\n        best_norm_dist, best_r, best_d = candidates[0]\n        \n        if best_norm_dist = tau:\n            return True, best_r, best_d\n        else:\n            return False, -1, -1\n\n    # --- Main Processing Logic per Case ---\n    def process_case(case_params, transcripts, alpha, c_min, k, tau):\n        reads = generate_reads_for_case(case_params, transcripts)\n        consensus, L_cons, M_min = assemble_consensus(reads, alpha, c_min)\n        \n        r_star, d_star = -1, -1\n        map_succeeded = False\n        \n        if L_cons >= k:\n            map_succeeded, r_star, d_star = map_consensus(consensus, L_cons, transcripts, k, tau)\n        \n        success = (L_cons >= k) and map_succeeded\n        \n        return [success, L_cons, r_star, d_star, M_min]\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        { # Case 1: Happy path\n            's_sig': 11, 'partner_info': (1, 120, 40, 20, 0.02),\n            'read_len_range_sig': (30, 40)\n        },\n        { # Case 2: Boundary condition: minimal cluster\n            's_sig': 12, 'partner_info': (0, 50, 25, 3, 0.01),\n            'read_len_range_sig': (18, 25)\n        },\n        { # Case 3: Noise robustness\n            's_sig': 13, 'partner_info': (2, 180, 35, 12, 0.03),\n            'read_len_range_sig': (20, 35),\n            's_noise': 131, 'n_noise': 7,\n            'read_len_range_noise': (18, 35)\n        },\n        { # Case 4: No true signal (pure noise)\n            's_noise': 14, 'n_noise': 10,\n            'read_len_range_noise': (10, 20)\n        }\n    ]\n\n    # --- Run Suite and Format Output ---\n    results = []\n    for case in test_cases:\n        result = process_case(case, transcriptome, ALPHA, C_MIN, K, TAU)\n        results.append(result)\n\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, r))}]' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "识别出候选的融合事件后，关键的下一步是预测其生物学功能。本练习将深入探讨蛋白质翻译的规则，利用“外显子相位”（exon phase）这一概念来判断一个融合事件是否为“框内融合”（in-frame），即能否产生一个连续的蛋白质。你将把这一原理应用于一个临床场景，评估一个涉及激酶基因的融合是否保留了其关键的活性位点，这是判断其作为治疗靶点潜力的核心依据 。",
            "id": "4342762",
            "problem": "通过核糖核酸测序（RNA-seq）检测到的一种临床RNA融合，将上游伴侣基因 $A$ 的编码序列与下游激酶基因 $B$ 的编码序列连接起来。分子生物学的中心法则指出，脱氧核糖核酸转录为核糖核酸，再翻译成蛋白质，翻译过程以固定的阅读框，按每个氨基酸对应3个核苷酸长度的三联体密码子读取信使核糖核酸。在外显子连接处，使用外显子相位的概念：外显子边界处的相位 $p \\in \\{0,1,2\\}$ 是指到该边界为止的累积编码核苷酸计数除以 $3$ 后的余数。相位 $p=0$ 表示边界位于密码子之间；$p=1$ 或 $p=2$ 分别表示有1个或2个来自不完整密码子的核苷酸跨越了该连接点。\n\n一个RNA-seq断点将基因 $A$（供体）的外显子 $E^{(A)}_{5}$ 的末端与基因 $B$（受体）的外显子 $E^{(B)}_{7}$ 的起始端连接起来。供体外显子末端的相位为 $p_{\\text{up}}=1$。受体外显子起始端的相位为 $p_{\\text{down}}=1$。在外显子 $E^{(B)}_{7}$ 的下游，来自基因 $B$ 的所有编码序列都被保留，没有进一步的改变。外显子 $E^{(B)}_{7}$ 贡献了基因 $B$ 典型蛋白质中索引为 $[30,120]$ 的氨基酸。基因 $B$ 中已注释的蛋白激酶结构域跨越氨基酸索引 $[45,310]$，其催化活性位点的特征在基因 $B$ 的以下典型位置被注释：\n- 保守的赖氨酸 $K$ 位于索引 $a_{K}=72$ 处，\n- 催化环基序 $\\mathrm{HRD}$ 位于索引 $a_{H}=160$、$a_{R}=161$、$a_{D}=162$ 处，\n- 激活段基序 $\\mathrm{DFG}$ 位于索引 $a_{D'}=185$、$a_{F}=186$、$a_{G}=187$ 处。\n\n仅从上面的密码子三联体定义和外显子相位定义出发，首先推导出一个标准，用供体末端相位 $p_{\\text{up}}$ 和受体起始端相位 $p_{\\text{down}}$ 来判断阅读框在融合连接处是否被保留。然后，使用给定的数值，确定该融合是否保留了激酶的活性位点（意味着索引为 $a_{K}$、$a_{H}$、$a_{R}$、$a_{D}$、$a_{D'}$、$a_{F}$、$a_{G}$ 的残基在融合蛋白中出现的序列与在基因 $B$ 中注释的完全相同）。将你的最终答案表示为一个整数，用 $0$ 表示“未保留”，用 $1$ 表示“已保留”。",
            "solution": "该问题要求完成两个主要任务：首先，基于外显子相位，推导出一个用于判断RNA融合连接处阅读框是否保留的通用标准；其次，将此标准应用于一个特定的基因融合案例，以确定激酶的活性位点是否被保留。\n\n首先，我们来建立阅读框保留的标准。阅读框是由信使RNA（mRNA）核苷酸分组为长度为3的密码子决定的。只有当这些三联体分组得以维持时，连续的蛋白质序列才能被正确翻译。\n\n设上游伴侣基因为 $A$，下游伴侣基因为 $B$。融合发生在外显子边界处。设 $N_{\\text{up}}$ 为基因 $A$ 编码序列（CDS）中从起始密码子到融合断点（供体外显子末端）的核苷酸总数。此供体外显子边界处的相位 $p_{\\text{up}}$ 定义为 $N_{\\text{up}}$ 除以 $3$ 的余数。\n$$p_{\\text{up}} = N_{\\text{up}} \\pmod{3}$$\n这意味着来自基因 $A$ 的上游序列由整数个密码子加上 $p_{\\text{up}}$ 个额外的核苷酸组成。\n\n类似地，设 $N_{\\text{pre-down}}$ 为典型基因 $B$ 编码序列（CDS）中从起始密码子到融合断点（受体外显子起始端）的核苷酸总数。此受体外显子边界处的相位 $p_{\\text{down}}$ 定义为 $N_{\\text{pre-down}}$ 除以 $3$ 的余数。\n$$p_{\\text{down}} = N_{\\text{pre-down}} \\pmod{3}$$\n这意味着在典型基因 $B$ 的背景下，受体外显子之前是一个由整数个密码子加上 $p_{\\text{down}}$ 个额外核苷酸组成的CDS序列。\n\n为了使下游基因 $B$ 的阅读框在融合转录本中得以保留，从受体外显子开始的核苷酸序列必须以与其在典型背景下相同的框架进行翻译。\n在基因 $B$ 的典型转录本中，一个核苷酸在其密码子中的位置由其与起始密码子的距离决定。受体外显子内位置为 $j$（1-索引）的核苷酸，距离基因 $B$ CDS起点的总位置为 $N_{\\text{pre-down}} + j$。其在密码子中的位置（0、1或2）由 $( (N_{\\text{pre-down}} + j) - 1 ) \\pmod 3$ 给出。\n\n在融合转录本中，受体外显子内位置为 $j$ 的同一个核苷酸前面有来自基因 $A$ 的 $N_{\\text{up}}$ 个核苷酸。其距离融合CDS起点的总位置为 $N_{\\text{up}} + j$。因此，其在密码子中的位置为 $( (N_{\\text{up}} + j) - 1 ) \\pmod 3$。\n\n为了保留阅读框，对于受体外显子序列中的任何核苷酸 $j$，这两个密码子位置必须相同。\n$$ ( (N_{\\text{pre-down}} + j) - 1 ) \\pmod 3 = ( (N_{\\text{up}} + j) - 1 ) \\pmod 3 $$\n这可以简化为：\n$$ ( N_{\\text{pre-down}} - 1 ) \\pmod 3 = ( N_{\\text{up}} - 1 ) \\pmod 3 $$\n这个同余式成立的充要条件是 $N_{\\text{pre-down}} \\equiv N_{\\text{up}} \\pmod 3$。\n使用相位的定义，这等价于条件：\n$$ p_{\\text{down}} = p_{\\text{up}} $$\n这个方程是判断融合连接处阅读框是否保留的标准。满足此条件的融合被称为“框内融合”(in-frame)。\n\n接下来，我们将此标准应用于所提供的具体案例。问题陈述供体外显子末端的相位为 $p_{\\text{up}}=1$，受体外显子起始端的相位为 $p_{\\text{down}}=1$。\n由于 $p_{\\text{up}} = 1$ 且 $p_{\\text{down}} = 1$，条件 $p_{\\text{up}} = p_{\\text{down}}$ 得到满足。因此，该融合是框内融合，阅读框在连接处得以保留。\n\n现在，我们必须确定激酶的活性位点是否被保留。活性位点的保留需要满足两个条件：\n1. 阅读框必须被保留，以确保下游基因外显子编码的氨基酸序列被正确翻译。我们已经确定这一点是成立的。\n2. 编码活性位点特定氨基酸残基的编码序列部分必须包含在最终的融合转录本中。\n\n该融合将基因 $A$ 的外显子 $E^{(A)}_{5}$ 的末端与基因 $B$ 的外显子 $E^{(B)}_{7}$ 的起始端连接起来。问题陈述外显子 $E^{(B)}_{7}$ 贡献了基因 $B$ 典型蛋白质中索引为 $[30, 120]$ 的氨基酸。它还指出，在外显子 $E^{(B)}_{7}$ 的下游，来自基因 $B$ 的所有编码序列都被保留。这意味着最终的融合蛋白将包含一个来自蛋白 $A$ 的N端部分，其后是蛋白 $B$ 从氨基酸位置30开始一直到其C末端的序列。\n\n蛋白 $B$ 中活性位点残基的典型位置如下：\n- $K$ 位于索引 $a_{K}=72$ 处\n- $\\mathrm{HRD}$ 基序位于索引 $a_{H}=160$、$a_{R}=161$、$a_{D}=162$ 处\n- $\\mathrm{DFG}$ 基序位于索引 $a_{D'}=185$、$a_{F}=186$、$a_{G}=187$ 处\n\n我们必须检查这些氨基酸位置是否包含在融合蛋白中保留的蛋白 $B$ 的部分，即从索引30开始的序列。\n- 对于赖氨酸（$K$），位于 $a_{K}=72$ 处：$72 \\ge 30$。该残基被包含。\n- 对于 $\\mathrm{HRD}$ 基序，位于 $a_{H}=160, a_{R}=161, a_{D}=162$ 处：$160 \\ge 30$。该基序被包含。\n- 对于 $\\mathrm{DFG}$ 基序，位于 $a_{D'}=185, a_{F}=186, a_{G}=187$ 处：$185 \\ge 30$。该基序被包含。\n\n由于阅读框被保留，并且所有指定活性位点残基的编码序列都存在于融合转录本中（因为它们的位置都大于或等于来自蛋白 $B$ 的起始氨基酸索引30），所以活性位点将被正确翻译，因此在融合蛋白中得以保留。\n\n问题要求将答案表示为一个整数，用 $1$ 表示“已保留”，用 $0$ 表示“未保留”。根据我们的分析，活性位点被保留。因此，答案是 $1$。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "并非所有嵌合读长（chimeric reads）都代表着真实的基因融合，有些可能源于技术或生物学假象。本练习将聚焦于一种常见的模拟现象：转录“通读”（transcriptional read-through）。你将建立并应用一个数学模型来量化这种假象出现的可能性，学习如何设定一个基于距离的阈值，以可靠地区分真实的融合事件与背景噪音。这凸显了在确保基因组诊断准确性方面，定量推理和统计建模的重要性 。",
            "id": "4342694",
            "problem": "您的任务是形式化并计算在核糖核酸测序 (RNA-seq) 中，基因间转录通读何时会模拟真实的染色体融合，这需要通过对终止效率和聚合酶持续合成能力进行建模来完成。您的推导应基于分子生物学中心法则和经过广泛验证的转录随机过程模型。\n\n假设一个上游基因在其多聚腺苷酸化信号处表现出不完全终止，使得一部分 RNA 聚合酶 II 分子无法终止，并继续进入下游位点。令终止效率表示为 $e \\in [0,1]$，其中 $e$ 是在指定位点成功终止的概率，而 $1-e$ 是通读起始的概率。将通读聚合酶的下游进程建模为一个每碱基具有恒定解离风险率 $\\lambda$（单位为 $\\text{bp}^{-1}$）的过程，这导致跨越距离 $d$ 的存活概率为 $S(d) = \\exp(-\\lambda d)$。令 $\\gamma  0$ 表示在假设没有终止的情况下（即，一个综合了转录本丰度、文库取样和连接检测倾向的检测比例因子），在 $d=0$ 处可检测到的连接样读段 (junction-like reads) 的期望数量。在不完全终止的情况下，可检测到的通读连接样读段的期望数量作为距离 $d$（以碱基对为单位）的函数为\n$$\n\\mu(d) = \\gamma \\,(1-e)\\,\\exp(-\\lambda d).\n$$\n\n如果根据通读模型观察到至少 $t$ 个连接样读段的概率，其上界为一个用户指定的假模拟风险水平 $\\beta$，即满足以下不等式时，通读事件被认为“不可能模拟真正的基因融合”：\n$$\n\\mathbb{P}(K \\ge t) \\le \\beta,\n$$\n其中 $K \\sim \\text{Poisson}(\\mu(d))$。\n\n您的目标是编写一个完整、可运行的程序，对于每个给定的测试用例 $(e, \\lambda, \\gamma, t, \\beta)$，计算满足不等式 $\\mathbb{P}(K \\ge t) \\le \\beta$ 的最小整数距离阈值 $d^\\star$（以碱基对为单位）。如果 $\\lambda = 0$（无下游解离），那么 $\\mu(d)$ 是关于 $d$ 的常数；在这种特殊情况下，如果不等式在 $d=0$ 时已经满足，则输出 $0$；如果不存在有限距离可以满足该不等式，则输出 $-1$。所有输出必须以碱基对 (bp) 为单位表示为整数。\n\n程序设计要求：\n\n- 使用上述模型定义，并从第一性原理推导算法，不使用简便公式。\n- 利用 $\\mathbb{P}(K \\ge t)$ 通过 $\\mu(d)$ 对 $d$ 的单调依赖性来高效地找到 $d^\\star$。\n- 对边界条件（包括 $\\lambda = 0$ 和 $e = 1$）具有鲁棒性。\n\n测试套件：\n\n为以下参数集计算 $d^\\star$，其中每个元组为 $(e, \\lambda, \\gamma, t, \\beta)$：\n\n- 情况 1：$(0.9, 1\\times 10^{-4}, 50, 3, 10^{-3})$\n- 情况 2：$(0.99, 5\\times 10^{-5}, 10, 1, 0.01)$\n- 情况 3：$(0.8, 5\\times 10^{-3}, 100, 5, 10^{-6})$\n- 情况 4：$(0.5, 0, 2, 2, 0.05)$\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,result_3,result_4]$），其中每个 $result_i$ 是对应测试用例的整数 $d^\\star$（以碱基对为单位），或者在上述规则下不存在有限阈值时为 $-1$。",
            "solution": "该问题被认为是有效的，因为它具有科学依据、定义明确、客观且自洽。该模型使用了分子生物学和随机过程的既定原理，其目标是一个数学上易于处理的优化问题。\n\n问题要求的是最小整数距离 $d^\\star$，在该距离上，转录通读不太可能被误认为是基因融合。该条件被正式表述为一个涉及泊松分布随机变量的不等式，该变量的均值是距离 $d$ 的函数。\n\n我们的任务是找到最小的整数 $d^\\star \\ge 0$，使得 $\\mathbb{P}(K \\ge t) \\le \\beta$，其中 $K \\sim \\text{Poisson}(\\mu(d))$，均值参数由 $\\mu(d) = \\gamma (1-e) \\exp(-\\lambda d)$ 给出。这些参数是终止效率 $e$、聚合酶解离风险率 $\\lambda$、检测比例因子 $\\gamma$、读段计数阈值 $t$ 和风险水平 $\\beta$。\n\n解决方案的核心原理是距离 $d$ 与我们关注的概率 $\\mathbb{P}(K \\ge t)$ 之间的单调关系。泊松生存函数 $\\mathbb{P}(K \\ge t | \\mu)$ 是其均值参数 $\\mu$ 的单调递增函数。对于任何正的解离风险率 $\\lambda  0$，均值 $\\mu(d)$ 是距离 $d$ 的单调递减函数。因此，复合函数 $g(d) = \\mathbb{P}(K \\ge t | \\mu(d))$ 是 $d$ 的单调递减函数。这种单调性保证了如果条件 $\\mathbb{P}(K \\ge t) \\le \\beta$ 在 $d=0$ 时不满足，则存在一个唯一的阈值距离 $d^\\star$，超过该距离后不等式将成立。\n\n我们的算法策略是首先确定最大允许均值，我们称之为 $\\mu_{max}$，在该均值下泊松生存概率不超过 $\\beta$。然后我们找到将实际均值 $\\mu(d)$ 降低到该水平所需的最小距离 $d$。\n\n首先，我们通过求解边界条件方程来找到 $\\mu_{max}$：\n$$\n\\mathbb{P}(K \\ge t | \\mu_{max}) = \\beta\n$$\n具有整数阈值 $t  0$ 的泊松分布变量 $K$ 的生存函数与正则化下不完全伽玛函数 $P(a, x) = \\frac{\\gamma(a,x)}{\\Gamma(a)}$ 相关，其中 $\\gamma(a,x) = \\int_0^x u^{a-1}e^{-u}du$。关系如下：\n$$\n\\mathbb{P}(K \\ge t | \\mu) = \\sum_{k=t}^{\\infty} \\frac{e^{-\\mu}\\mu^k}{k!} = P(t, \\mu)\n$$\n因此，我们必须求解 $P(t, \\mu_{max}) = \\beta$。这是一个逆问题。解由正则化下不完全伽玛函数的反函数给出，该函数在计算库中可用。我们将 $\\mu_{max}$ 定义为：\n$$\n\\mu_{max} = P^{-1}(t, \\beta)\n$$\n任何均值 $\\mu \\le \\mu_{max}$ 都将满足该概率不等式。\n\n接下来，我们将此条件施加于我们依赖于距离的均值 $\\mu(d)$：\n$$\n\\mu(d) \\le \\mu_{max}\n$$\n$$\n\\gamma (1-e) \\exp(-\\lambda d) \\le \\mu_{max}\n$$\n$d$ 的解取决于参数，从而导致几种不同的情况。\n\n情况 1：正常解离 ($\\lambda  0$)\n我们首先考虑 $d=0$ 时的初始状态，此时均值为 $\\mu_0 = \\mu(0) = \\gamma(1-e)$。如果 $\\mu_0 \\le \\mu_{max}$，则条件在 $d=0$ 时已经满足。由于我们寻求最小整数距离，因此 $d^\\star = 0$。\n如果 $\\mu_0  \\mu_{max}$，我们需要找到一个距离 $d  0$。我们求解关于 $d$ 的不等式：\n$$\n\\exp(-\\lambda d) \\le \\frac{\\mu_{max}}{\\gamma(1-e)}\n$$\n由于 $\\mu_0  \\mu_{max}$，右侧小于 $1$。我们可以对两边取自然对数：\n$$\n-\\lambda d \\le \\ln\\left(\\frac{\\mu_{max}}{\\gamma(1-e)}\\right)\n$$\n除以 $-\\lambda$（其中 $\\lambda  0$）会反转不等号：\n$$\nd \\ge -\\frac{1}{\\lambda} \\ln\\left(\\frac{\\mu_{max}}{\\gamma(1-e)}\\right) = \\frac{1}{\\lambda} \\ln\\left(\\frac{\\gamma(1-e)}{\\mu_{max}}\\right)\n$$\n满足此条件的最小距离是 $d_{min} = \\frac{1}{\\lambda} \\ln\\left(\\frac{\\mu_0}{\\mu_{max}}\\right)$。由于问题要求整数距离，我们必须对此值取上整：\n$$\nd^\\star = \\left\\lceil \\frac{1}{\\lambda} \\ln\\left(\\frac{\\gamma(1-e)}{\\mu_{max}}\\right) \\right\\rceil\n$$\n\n情况 2：无解离 ($\\lambda = 0$)\n如果 $\\lambda=0$，聚合酶永不解离。平均读段计数对于所有距离都是恒定的：\n$$\n\\mu(d) = \\gamma(1-e) = \\mu_0\n$$\n概率 $\\mathbb{P}(K \\ge t)$ 也是恒定的。我们使用 $\\mu_0$ 来评估这个概率。\n- 如果 $\\mathbb{P}(K \\ge t | \\mu_0) \\le \\beta$，则该条件对所有距离都满足，包括 $d=0$。最小整数距离为 $d^\\star=0$。\n- 如果 $\\mathbb{P}(K \\ge t | \\mu_0)  \\beta$，则该条件对任何有限距离都不满足。根据问题规范，输出必须是 $d^\\star = -1$。\n\n情况 3：完全终止 ($e=1$)\n如果终止是完全的，则 $1-e=0$。这意味着对所有 $d$ 都有 $\\mu(d) = 0$。对于任何阈值 $t \\ge 1$ 和风险 $\\beta \\ge 0$，$\\mathbb{P}(K \\ge t | \\mu=0) = 0 \\le \\beta$。条件在 $d=0$ 时得到满足，因此 $d^\\star = 0$。这是一个物理上直观的边界情况。\n\n最终算法如下：\n1. 对于一组给定的参数 $(e, \\lambda, \\gamma, t, \\beta)$：\n2. 如果 $e=1$，结果为 $d^\\star = 0$。\n3. 如果 $\\lambda=0$：\n    a. 计算恒定均值 $\\mu_0 = \\gamma(1-e)$。\n    b. 对于 $K \\sim \\text{Poisson}(\\mu_0)$，计算概率 $P_0 = \\mathbb{P}(K \\ge t)$。\n    c. 如果 $P_0 \\le \\beta$，则设置 $d^\\star=0$。否则，设置 $d^\\star=-1$。\n4. 如果 $\\lambda > 0$ 且 $e  1$：\n    a. 通过计算正则化不完全伽玛函数的反函数来计算最大允许均值 $\\mu_{max}$，即 $\\mu_{max} = P^{-1}(t, \\beta)$。\n    b. 计算初始均值 $\\mu_0 = \\gamma(1-e)$。\n    c. 如果 $\\mu_0 \\le \\mu_{max}$，则设置 $d^\\star=0$。\n    d. 否则，计算 $d^\\star = \\left\\lceil \\frac{1}{\\lambda} \\ln(\\frac{\\mu_0}{\\mu_{max}}) \\right\\rceil$ 并转换为整数。\n这为解决所有指定条件下的问题提供了一个完整而鲁棒的程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special, stats\n\ndef solve():\n    \"\"\"\n    Computes the minimal integer distance threshold d* for transcriptional \n    read-through to be considered an unlikely mimic of a gene fusion.\n    \"\"\"\n    # Test cases are tuples of (e, lambda, gamma, t, beta)\n    test_cases = [\n        # Case 1: (e=0.9, lambda=1e-4, gamma=50, t=3, beta=1e-3)\n        (0.9, 1e-4, 50, 3, 1e-3),\n        # Case 2: (e=0.99, lambda=5e-5, gamma=10, t=1, beta=0.01)\n        (0.99, 5e-5, 10, 1, 0.01),\n        # Case 3: (e=0.8, lambda=5e-3, gamma=100, t=5, beta=1e-6)\n        (0.8, 5e-3, 100, 5, 1e-6),\n        # Case 4: (e=0.5, lambda=0, gamma=2, t=2, beta=0.05)\n        (0.5, 0, 2, 2, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        e, lam, gamma, t, beta = case\n        \n        # Boundary case: perfect termination (e=1)\n        # mu(d) is always 0. For t=1, P( K=t | mu=0 ) = 0 = beta.\n        # Thus, the condition is met at d=0.\n        if e == 1.0:\n            results.append(0)\n            continue\n            \n        # Case: No polymerase disengagement (lambda = 0)\n        if lam == 0:\n            mu_0 = gamma * (1 - e)\n            # The probability P(K = t) is constant for all d.\n            # We check if the condition is met.\n            # scipy.stats.poisson.sf(k, mu) calculates P(K  k) = P(K = k+1)\n            prob_at_0 = stats.poisson.sf(t - 1, mu_0)\n            \n            if prob_at_0 = beta:\n                # Condition is met at d=0, and for all d. Minimal distance is 0.\n                results.append(0)\n            else:\n                # Condition is never met.\n                results.append(-1)\n            continue\n\n        # Main case: Imperfect termination (e1) and polymerase disengagement (lambda > 0)\n        \n        # Step 1: Find the maximum allowed Poisson mean (mu_max) such that\n        # P(K = t | mu_max) = beta.\n        # This is equivalent to solving P(t, mu_max) = beta, where P is the\n        # regularized lower incomplete gamma function.\n        # mu_max = gammaincinv(t, beta).\n        # We need to handle potential edge cases for gammaincinv.\n        # If beta is 0, mu_max is 0. If beta is 1, mu_max is inf. Test cases are well-behaved.\n        if t = 0: # t must be a positive integer for a valid threshold\n            # This case is not in the test suite but is a good practice check.\n            # P(K=0) is 1, P(K=t) for t0 is 1. If beta  1.0, impossible.\n            if beta  1.0:\n                results.append(-1) # Cannot be satisfied\n            else:\n                results.append(0) # Satisfied for any mu\n            continue\n\n        mu_max = special.gammaincinv(t, beta)\n\n        # Step 2: Calculate the mean at distance 0 (mu_0).\n        mu_0 = gamma * (1 - e)\n\n        # Step 3: Determine d_star based on mu_0 and mu_max.\n        if mu_0 = mu_max:\n            # The condition is already satisfied at d=0.\n            d_star = 0\n        else:\n            # We need to find the minimal d such that mu(d) = mu_max.\n            # gamma * (1-e) * exp(-lambda * d) = mu_max\n            # exp(-lambda * d) = mu_max / (gamma * (1-e))\n            # -lambda * d = log(mu_max / mu_0)\n            # d >= -1/lambda * log(mu_max / mu_0)\n            # d >= 1/lambda * log(mu_0 / mu_max)\n            d_min = (1 / lam) * np.log(mu_0 / mu_max)\n            d_star = int(np.ceil(d_min))\n            \n        results.append(d_star)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}