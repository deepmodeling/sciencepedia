{
    "hands_on_practices": [
        {
            "introduction": "描述免疫组库的多样性是免疫基因组学中的一项基本任务。本练习将介绍希尔数（Hill numbers）这一多样性量化统一框架，它使我们能够理解T细胞群体的克隆结构，从其总丰富度到扩增克隆的优势度。通过计算不同敏感度下的多样性，您将深入了解组库的均匀度及其在活性免疫应答中的意义。",
            "id": "4352355",
            "problem": "在一项旨在指导精准免疫治疗的肿瘤浸润淋巴细胞研究中，对T细胞受体（TCR）β链的互补决定区3（CDR3）进行了高通量测序。使用独特分子标识（UMI）校正的克隆型计数被标准化为频率，从而得到单个患者样本中观察到的所有克隆型的完整谱系。设标准化后的克隆型频率向量为\n$$\n\\mathbf{p}=\\big(0.22,\\,0.18,\\,0.12,\\,0.10,\\,0.08,\\,0.07,\\,0.06,\\,0.05,\\,0.05,\\,0.04,\\,0.03\\big),\n$$\n其总和为$1$，代表了该样本中所有非零克隆型的完整集合。\n\n使用 Hill 数 $^{q}D$ 的定义，它是由阶数 $q$ 参数化的一族多样性度量，其中当 $q\\neq 1$ 时，\n$$\n^{q}D=\\left(\\sum_{i=1}^{R} p_{i}^{\\,q}\\right)^{\\frac{1}{1-q}},\n$$\n并通过连续性，对于 $q\\to 1$ 的情况，\n$$\n^{1}D=\\exp\\!\\left(-\\sum_{i=1}^{R} p_{i}\\ln p_{i}\\right),\n$$\n计算该谱系在 $q=0$、$q=1$ 和 $q=2$ 时的 Hill 数。从核心的概率定义和极限出发，对包括 $q\\to 1$ 极限在内的每种情况进行论证。然后，在T细胞和B细胞受体（BCR）谱分析的免疫基因组学背景下，解释改变 $q$ 值如何重新加权丰度（richness）与优势度（dominance），以及为什么这对于揭示免疫谱系中的克隆扩增具有信息价值。\n\n将你计算出的三个多样性值以行向量 $\\big(^{0}D,\\,^{1}D,\\,^{2}D\\big)$ 的形式报告，并将每个条目四舍五入到四位有效数字。最终的数值不需要单位。如果出现任何角度，请使用弧度。",
            "solution": "该问题是有效的，因为它在免疫基因组学和生物统计学方面有科学依据，问题提出得很好，包含了所有必要的数据和定义，并且其表述是客观的。Hill 数、Shannon 熵和 Simpson 指数是标准的多样性度量，它们在T细胞受体谱系分析中的应用是定量免疫学的基石。\n\n任务是为一个给定的T细胞受体（TCR）克隆型频率分布计算阶数 $q=0$、$q=1$ 和 $q=2$ 的 Hill 数，并在免疫谱系分析的背景下对这些度量提供生物学解释。所提供的克隆型频率向量为 $\\mathbf{p}=\\big(0.22,\\,0.18,\\,0.12,\\,0.10,\\,0.08,\\,0.07,\\,0.06,\\,0.05,\\,0.05,\\,0.04,\\,0.03\\big)$。观察到的克隆型总数（丰度）为 $R=11$。这些频率的总和是 $\\sum_{i=1}^{11} p_i = 1.00$。\n\nHill 数，记为 $^{q}D$，是由阶数 $q$ 参数化的一族多样性指数。对于 $q \\neq 1$ 的通用公式是：\n$$\n^{q}D=\\left(\\sum_{i=1}^{R} p_{i}^{\\,q}\\right)^{\\frac{1}{1-q}}\n$$\n我们现在将计算 $q=0$、$q=2$ 和 $q=1$ 时的 Hill 数。\n\n**情况1：阶数 $q=0$ 的 Hill 数（丰度）**\n\n对于 $q=0$，直接应用通用公式。\n$$\n^{0}D = \\left(\\sum_{i=1}^{R} p_{i}^{\\,0}\\right)^{\\frac{1}{1-0}} = \\sum_{i=1}^{R} p_{i}^{\\,0}\n$$\n根据定义，对于任何非零概率 $p_i > 0$，$p_i^{\\,0}$ 的值为 $1$。由于问题陈述向量 $\\mathbf{p}$ 代表“所有非零克隆型的完整集合”，因此总和中的每个 $p_i$ 都大于 $0$。因此，该总和变成了对项数的计数：\n$$\n^{0}D = \\sum_{i=1}^{R} 1 = R\n$$\n这个度量 $^{0}D$ 就是在样本中观察到的独特克隆型的总数，也称为物种丰度。它对克隆型的相对丰度完全不敏感，将频率为 $0.22$ 的克隆型和频率为 $0.03$ 的克隆型视为对多样性的同等贡献者。\n对于给定的向量 $\\mathbf{p}$，有 $R=11$ 个不同的克隆型频率。\n$$\n^{0}D = 11\n$$\n\n**情况2：阶数 $q=2$ 的 Hill 数（Simpson 指数的倒数）**\n\n对于 $q=2$，通用公式给出：\n$$\n^{2}D = \\left(\\sum_{i=1}^{R} p_{i}^{\\,2}\\right)^{\\frac{1}{1-2}} = \\left(\\sum_{i=1}^{R} p_{i}^{\\,2}\\right)^{-1} = \\frac{1}{\\sum_{i=1}^{R} p_{i}^{\\,2}}\n$$\n分母中的项 $\\lambda = \\sum_{i=1}^{R} p_{i}^{\\,2}$ 是 Simpson 指数。它代表从群体中随机（有放回地）选择的两个T细胞属于同一克隆型的概率。Hill 数 $^{2}D$ 是 Simpson 指数的倒数，可以解释为优势克隆型的有效数量。频率的平方给予了最丰富的克隆型不成比例的更大权重。\n\n让我们为给定的数据计算 $\\sum p_i^2$：\n$$\n\\sum_{i=1}^{11} p_i^{\\,2} = (0.22)^2 + (0.18)^2 + (0.12)^2 + (0.10)^2 + (0.08)^2 + (0.07)^2 + (0.06)^2 + (0.05)^2 + (0.05)^2 + (0.04)^2 + (0.03)^2\n$$\n$$\n\\sum_{i=1}^{11} p_i^{\\,2} = 0.0484 + 0.0324 + 0.0144 + 0.0100 + 0.0064 + 0.0049 + 0.0036 + 0.0025 + 0.0025 + 0.0016 + 0.0009 = 0.1276\n$$\n现在我们可以计算 $^{2}D$：\n$$\n^{2}D = \\frac{1}{0.1276} \\approx 7.8369905956...\n$$\n\n**情况3：阶数 $q=1$ 的 Hill 数（Shannon 熵的指数）**\n\n当 $q \\to 1$ 时，通用公式 $^{q}D = (\\sum p_i^{\\,q})^{1/(1-q)}$ 趋近于不定式 $1^{\\infty}$，因为 $\\sum p_i^1 = 1$。为了解决这个问题，我们分析其对数 $\\ln(^{q}D)$ 的极限。\n$$\n\\ln(^{q}D) = \\frac{\\ln\\left(\\sum_{i=1}^{R} p_i^{\\,q}\\right)}{1-q}\n$$\n当 $q \\to 1$ 时，分子趋近于 $\\ln(\\sum p_i) = \\ln(1) = 0$，分母趋近于 $0$。这是一个 $0/0$ 类型的不定式，所以我们可以应用洛必达法则（L'Hôpital's rule）。我们对分子和分母关于 $q$ 求导：\n设 $f(q) = \\ln\\left(\\sum p_i^{\\,q}\\right)$ 且 $g(q) = 1-q$。\n$$\nf'(q) = \\frac{d}{dq}\\ln\\left(\\sum p_i^{\\,q}\\right) = \\frac{1}{\\sum p_i^{\\,q}} \\cdot \\frac{d}{dq}\\left(\\sum p_i^{\\,q}\\right) = \\frac{\\sum (p_i^{\\,q} \\ln p_i)}{\\sum p_i^{\\,q}}\n$$\n$$\ng'(q) = \\frac{d}{dq}(1-q) = -1\n$$\n应用洛必达法则：\n$$\n\\lim_{q \\to 1} \\ln(^{q}D) = \\lim_{q \\to 1} \\frac{f'(q)}{g'(q)} = \\lim_{q \\to 1} \\frac{\\sum (p_i^{\\,q} \\ln p_i) / (\\sum p_i^{\\,q})}{-1}\n$$\n代入 $q=1$：\n$$\n\\lim_{q \\to 1} \\ln(^{q}D) = \\frac{\\sum (p_i^{\\,1} \\ln p_i) / (\\sum p_i^{\\,1})}{-1} = \\frac{\\sum p_i \\ln p_i}{ -1} = -\\sum_{i=1}^{R} p_i \\ln p_i\n$$\n这个表达式就是 Shannon 熵 $H$。因此，$\\lim_{q\\to 1} \\ln(^{q}D) = H$，这意味着 $^{q}D$ 的极限是：\n$$\n^{1}D = \\lim_{q \\to 1} {^q D} = \\exp(H) = \\exp\\left(-\\sum_{i=1}^{R} p_i \\ln p_i\\right)\n$$\n这个度量可以被解释为常见克隆型的有效数量，因为每个克隆型都恰好按其频率加权。\n\n让我们为给定的数据计算 Shannon 熵 $H$：\n$$\nH = - \\sum_{i=1}^{11} p_i \\ln p_i = - [ 0.22\\ln(0.22) + 0.18\\ln(0.18) + 0.12\\ln(0.12) + 0.10\\ln(0.10) + 0.08\\ln(0.08) + 0.07\\ln(0.07) + 0.06\\ln(0.06) + 2 \\times 0.05\\ln(0.05) + 0.04\\ln(0.04) + 0.03\\ln(0.03) ]\n$$\n$$\nH \\approx - [ -0.333107 - 0.308664 - 0.254432 - 0.230259 - 0.202058 - 0.186148 - 0.168805 - 2 \\times 0.149787 - 0.128755 - 0.105197 ]\n$$\n$$\nH \\approx - [ -2.216999 ] \\approx 2.216999\n$$\n现在我们计算 $^{1}D$：\n$$\n^{1}D = \\exp(H) \\approx \\exp(2.216999) \\approx 9.18029\n$$\n\n**在免疫基因组学中的解释**\n\nHill 多样性数中的参数 $q$ 控制了该度量对克隆型频率的敏感度。这为表征免疫谱系的结构提供了一个强大的工具。\n- **$q=0$ (${^{0}D}$)**：这是丰度（richness），即独特的 TCR/BCR 克隆型的总数。它给予每个克隆型相等的权重，而不管其丰度如何。因此，它对稀有克隆型高度敏感。在肿瘤微环境中，高 $^{0}D$ 值表明具有广泛的抗原识别潜力。\n- **$q=1$ (${^{1}D}$)**：这个度量是 Shannon 熵的指数，它根据克隆型的频率对其进行成比例加权。它通常被解释为“常见克隆型的有效数量”。它代表了一个假设所有克隆型丰度均等的谱系的多样性。\n- **$q=2$ (${^{2}D}$)**：这个度量是 Simpson 指数的倒数，由于频率的平方（$p_i^2$），它不成比例地加权了最常见的克隆型。它被解释为“优势克隆型的有效数量”，并且对大的、扩增的克隆的存在高度敏感。\n\n**揭示克隆扩增**：这些值之间的关系揭示了谱系的均匀度。一个健康的、初始的（naive）免疫谱系是高度多样且均匀的，意味着它有许多不同的克隆型，且频率较低且相似。在这种情况下，$^{0}D \\approx {^{1}D} \\approx {^{2}D}$。相比之下，强烈的免疫反应，例如本研究中研究的抗肿瘤反应，其特征在于**克隆扩增**：少数识别肿瘤抗原的特定T细胞克隆急剧增殖。这会产生一个高度不均匀的谱系，其中有少数优势克隆和许多稀有克隆。这种不均匀性被 Hill 数的分布特征所捕捉：$^{0}D$ 将远大于 $^{2}D$，而 $^{1}D$ 介于两者之间。\n该患者的计算值为 $^{0}D = 11$、$^{1}D \\approx 9.180$ 和 $^{2}D \\approx 7.837$。清晰的层级关系 $^{0}D > {^{1}D} > {^{2}D}$ ($11 > 9.180 > 7.837$) 定量地表明肿瘤浸润淋巴细胞群体中存在显著程度的不均匀性和克隆优势，这是活跃的、抗原驱动的免疫反应的典型特征。这一信息对于精准医疗至关重要，因为高度克隆化的反应可能预示着更好的预后，或预测对抗体检查点抑制剂免疫疗法的良好反应。\n\n**最终数值**\n\n将结果四舍五入到四位有效数字：\n$^{0}D = 11.00$\n$^{1}D \\approx 9.180$\n$^{2}D \\approx 7.837$\n\n最终答案是这三个值的行向量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n11.00 & 9.180 & 7.837\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在比较不同个体间的免疫组库时，“克隆型”的定义本身会极大地影响我们的结论。本练习探讨了通过核苷酸序列与翻译后的氨基酸序列定义克隆型之间的关键区别。您将量化将核苷酸多样性“折叠”为氨基酸同一性如何高估“公共”克隆的表观共享度并改变多样性指标，这是在群体水平研究中的一个关键考量。",
            "id": "4352254",
            "problem": "在精准医疗中，免疫基因组学的一项核心任务是从T细胞受体（TCR）或B细胞受体（BCR）组库中定义克隆型，并量化分析选择如何影响多样性以及共享公共克隆的推断。考虑基于互补决定区$3$（CDR3）的克隆型定义，分别在核苷酸水平（独特的CDR3核苷酸序列）和氨基酸水平（独特的CDR3氨基酸序列）上。两个个体$X$和$Y$各自拥有TCR $\\beta$组库数据，其中观察到的CDR3核苷酸克隆型和读数计数如下，由于密码子翻译，每个核苷酸克隆型都映射到一个氨基酸克隆型：\n\n对于个体$X$：$s_1 \\to A$有$40$个读数，$s_2 \\to A$有$10$个读数，$s_3 \\to B$有$25$个读数，$s_4 \\to C$有$15$个读数，$s_5 \\to D$有$10$个读数。\n\n对于个体$Y$：$s_6 \\to A$有$20$个读数，$s_7 \\to B$有$30$个读数，$s_8 \\to B$有$10$个读数，$s_9 \\to C$有$30$个读数，$s_{10} \\to E$有$10$个读数。\n\n假设$s_7$与$s_3$是相同的核苷酸克隆型（即，在$X$和$Y$中都存在的相同CDR3核苷酸序列），而所有其他核苷酸克隆型在$X$和$Y$之间是不同的。在氨基酸水平上，克隆型映射关系为：$A$对应$\\{s_1, s_2, s_6\\}$，$B$对应$\\{s_3, s_7, s_8\\}$，$C$对应$\\{s_4, s_9\\}$，$D$对应$\\{s_5\\}$，$E$对应$\\{s_{10}\\}$。\n\n使用以下基本原理：\n- 分子生物学的中心法则确立了由于密码子简并性，不同的核苷酸序列可以编码相同的氨基酸序列。\n- 对于离散分布，香农熵$H$定义为$H = -\\sum_{i} p_i \\ln(p_i)$，其中$p_i$是相对频率，$\\ln$是自然对数。\n- 克隆型的有效数量（1阶Hill数）为$D = \\exp(H)$。\n\n将塌陷诱导的偏倚指数$B$定义为\n$$\nB \\equiv \\left(\\frac{S_{\\mathrm{aa}}}{S_{\\mathrm{nt}}}\\right)\\left(\\frac{D_{\\mathrm{aa}}^{\\mathrm{pool}}}{D_{\\mathrm{nt}}^{\\mathrm{pool}}}\\right),\n$$\n其中，$S_{\\mathrm{aa}}$和$S_{\\mathrm{nt}}$分别是个体$X$和$Y$之间在氨基酸水平和核苷酸水平上的共享克隆型数量，而$D_{\\mathrm{aa}}^{\\mathrm{pool}}$和$D_{\\mathrm{nt}}^{\\mathrm{pool}}$分别是根据来自$X$和$Y$的合并数据在氨基酸和核苷酸水平上计算出的克隆型有效数量。\n\n根据提供的数据计算$B$。熵计算使用自然对数。将$B$的最终答案四舍五入到四位有效数字。将最终量表示为无单位的纯数。",
            "solution": "目标是计算塌陷诱导的偏倚指数$B$，其定义为$B \\equiv \\left(\\frac{S_{\\mathrm{aa}}}{S_{\\mathrm{nt}}}\\right)\\left(\\frac{D_{\\mathrm{aa}}^{\\mathrm{pool}}}{D_{\\mathrm{nt}}^{\\mathrm{pool}}}\\right)$。这需要计算四个量：共享核苷酸克隆型的数量（$S_{\\mathrm{nt}}$）、共享氨基酸克隆型的数量（$S_{\\mathrm{aa}}$）、合并核苷酸组库中克隆型的有效数量（$D_{\\mathrm{nt}}^{\\mathrm{pool}}$），以及合并氨基酸组库中克隆型的有效数量（$D_{\\mathrm{aa}}^{\\mathrm{pool}}$）。\n\n首先，我们确定个体$X$和$Y$之间的共享克隆型数量。\n\n共享核苷酸克隆型的数量$S_{\\mathrm{nt}}$由问题陈述直接给出。陈述中提到“$s_7$与$s_3$是相同的核苷酸克隆型”，并且“所有其他核苷酸克隆型在$X$和$Y$之间是不同的”。因此，恰好有一个共享的核苷酸克隆型。\n$$\nS_{\\mathrm{nt}} = 1\n$$\n为了找到共享氨基酸克隆型的数量$S_{\\mathrm{aa}}$，我们必须首先确定每个个体中存在的氨基酸克隆型集合。\n对于个体$X$，核苷酸克隆型为$\\{s_1, s_2, s_3, s_4, s_5\\}$，它们映射到氨基酸克隆型$\\{A, A, B, C, D\\}$。$X$中独特的氨基酸克隆型集合为$\\{A, B, C, D\\}$。\n对于个体$Y$，核苷酸克隆型为$\\{s_6, s_7, s_8, s_9, s_{10}\\}$，它们映射到氨基酸克隆型$\\{A, B, B, C, E\\}$。$Y$中独特的氨基酸克隆型集合为$\\{A, B, C, E\\}$。\n共享的氨基酸克隆型是这两个集合的交集：$\\{A, B, C, D\\} \\cap \\{A, B, C, E\\} = \\{A, B, C\\}$。因此，共享氨基酸克隆型的数量是$3$。\n$$\nS_{\\mathrm{aa}} = 3\n$$\n\n接下来，我们计算合并数据的克隆型有效数量，从核苷酸水平开始。为了找到$D_{\\mathrm{nt}}^{\\mathrm{pool}}$，我们首先将两个个体中每个独特核苷酸序列的读数合并。\n个体$X$的总读数是$40 + 10 + 25 + 15 + 10 = 100$。\n个体$Y$的总读数是$20 + 30 + 10 + 30 + 10 = 100$。\n合并数据的总读数是$100 + 100 = 200$。\n合并组库中的独特核苷酸克隆型及其总读数计数如下：\n- $s_1$：$40$个读数\n- $s_2$：$10$个读数\n- $s_3/s_7$：$25$（来自$X$）+ $30$（来自$Y$）= $55$个读数\n- $s_4$：$15$个读数\n- $s_5$：$10$个读数\n- $s_6$：$20$个读数\n- $s_8$：$10$个读数\n- $s_9$：$30$个读数\n- $s_{10}$：$10$个读数\n\n这$9$个独特核苷酸克隆型的相对频率（$p_i$）是：\n$p_1 = \\frac{40}{200} = 0.2$, $p_2 = \\frac{10}{200} = 0.05$, $p_3 = \\frac{55}{200} = 0.275$, $p_4 = \\frac{15}{200} = 0.075$, $p_5 = \\frac{10}{200} = 0.05$, $p_6 = \\frac{20}{200} = 0.1$, $p_7 = \\frac{10}{200} = 0.05$, $p_8 = \\frac{30}{200} = 0.15$, $p_9 = \\frac{10}{200} = 0.05$.\n\n香农熵$H_{\\mathrm{nt}}^{\\mathrm{pool}}$按$H = -\\sum_{i} p_i \\ln(p_i)$计算：\n$$\nH_{\\mathrm{nt}}^{\\mathrm{pool}} = - \\begin{pmatrix} 0.2 \\ln(0.2) + 0.05 \\ln(0.05) + 0.275 \\ln(0.275) + 0.075 \\ln(0.075) \\\\ + 0.05 \\ln(0.05) + 0.1 \\ln(0.1) + 0.05 \\ln(0.05) + 0.15 \\ln(0.15) + 0.05 \\ln(0.05) \\end{pmatrix}\n$$\n$$\nH_{\\mathrm{nt}}^{\\mathrm{pool}} = - [ 0.2 \\ln(0.2) + 0.275 \\ln(0.275) + 0.15 \\ln(0.15) + 0.1 \\ln(0.1) + 0.075 \\ln(0.075) + 4(0.05 \\ln(0.05)) ]\n$$\n$$\nH_{\\mathrm{nt}}^{\\mathrm{pool}} \\approx - [-0.321888 - 0.355021 - 0.284568 - 0.230259 - 0.194270 + 4(-0.149787)]\n$$\n$$\nH_{\\mathrm{nt}}^{\\mathrm{pool}} \\approx - [-1.386006 - 0.599148] = -(-1.985154) \\approx 1.985154\n$$\n克隆型的有效数量$D_{\\mathrm{nt}}^{\\mathrm{pool}}$是$\\exp(H_{\\mathrm{nt}}^{\\mathrm{pool}})$：\n$$\nD_{\\mathrm{nt}}^{\\mathrm{pool}} = \\exp(1.985154) \\approx 7.280145\n$$\n\n现在，我们计算合并氨基酸数据的克隆型有效数量$D_{\\mathrm{aa}}^{\\mathrm{pool}}$。我们根据其独特的氨基酸序列合并读数。\n- 克隆型$A$：来自$s_1, s_2, s_6$的读数$\\implies 40 + 10 + 20 = 70$个读数。\n- 克隆型$B$：来自$s_3, s_7, s_8$的读数$\\implies 25 + 30 + 10 = 65$个读数。\n- 克隆型$C$：来自$s_4, s_9$的读数$\\implies 15 + 30 = 45$个读数。\n- 克隆型$D$：来自$s_5$的读数$\\implies 10$个读数。\n- 克隆型$E$：来自$s_{10}$的读数$\\implies 10$个读数。\n总读数为$70 + 65 + 45 + 10 + 10 = 200$。\n这$5$个独特氨基酸克隆型的相对频率（$p_i$）是：\n$p_A = \\frac{70}{200} = 0.35$, $p_B = \\frac{65}{200} = 0.325$, $p_C = \\frac{45}{200} = 0.225$, $p_D = \\frac{10}{200} = 0.05$, $p_E = \\frac{10}{200} = 0.05$.\n\n香农熵$H_{\\mathrm{aa}}^{\\mathrm{pool}}$是：\n$$\nH_{\\mathrm{aa}}^{\\mathrm{pool}} = - [ 0.35 \\ln(0.35) + 0.325 \\ln(0.325) + 0.225 \\ln(0.225) + 2(0.05 \\ln(0.05)) ]\n$$\n$$\nH_{\\mathrm{aa}}^{\\mathrm{pool}} \\approx - [-0.367438 - 0.365278 - 0.335622 + 2(-0.149787)]\n$$\n$$\nH_{\\mathrm{aa}}^{\\mathrm{pool}} \\approx - [-1.068338 - 0.299574] = -(-1.367912) \\approx 1.367912\n$$\n克隆型的有效数量$D_{\\mathrm{aa}}^{\\mathrm{pool}}$是$\\exp(H_{\\mathrm{aa}}^{\\mathrm{pool}})$：\n$$\nD_{\\mathrm{aa}}^{\\mathrm{pool}} = \\exp(1.367912) \\approx 3.927118\n$$\n\n最后，我们计算塌陷诱导的偏倚指数$B$：\n$$\nB = \\left(\\frac{S_{\\mathrm{aa}}}{S_{\\mathrm{nt}}}\\right)\\left(\\frac{D_{\\mathrm{aa}}^{\\mathrm{pool}}}{D_{\\mathrm{nt}}^{\\mathrm{pool}}}\\right) = \\left(\\frac{3}{1}\\right) \\left(\\frac{3.927118}{7.280145}\\right)\n$$\n$$\nB = 3 \\times 0.5394295 \\approx 1.6182885\n$$\n将结果四舍五入到四位有效数字，我们得到$1.618$。",
            "answer": "$$\n\\boxed{1.618}\n$$"
        },
        {
            "introduction": "单细胞测序通过实现对来自同一细胞的TCR $\\alpha$ 和 $\\beta$ 链（或BCR重链和轻链）的直接配对，彻底改变了免疫基因组学。本练习模拟了处理单细胞数据的核心生物信息学挑战，要求您实现一个能够过滤噪声读数、识别生物学上不合理的“多重态”（multiplets）、并正确配对受体链的流程。掌握这一逻辑对于准确重建介导适应性免疫的功能性异二聚体至关重要。",
            "id": "4352259",
            "problem": "您将获得一个形式化的单细胞免疫受体读数版本，用于 T 细胞受体 (TCR) 和 B 细胞受体 (BCR) 的分析。目标是实现一种确定性的配对逻辑，该逻辑将观察到的链映射到有效的异源二聚体，同时处理由多重细胞（multiplet）和孤儿链（orphan chain）引起的模糊情况。您的解决方案必须源于免疫基因组学中的基本定义和经过充分检验的观察结果，并且必须是完全算法化的。\n\n从以下基本依据开始：\n- 在适应性免疫中，一个 T 细胞受体 (TCR) 是由一条 TCR alpha 链和一条 TCR beta 链组成的异源二聚体。一个 B 细胞受体 (BCR) 是由一条免疫球蛋白重链和一条免疫球蛋白轻链组成的异源二聚体。这是一个在脊椎动物中观察到的、经过充分检验的生物学事实。\n- 在单细胞测序中，唯一分子标识符 (UMI) 计数被用作衡量一个细胞条码内转录本丰度的代理指标，并且只有生产性重排才能编码功能性蛋白链。与同一基因座中的显性链相比，环境或污染序列的 UMI 计数往往较低。\n\n需要实现的定义和约束：\n1. 基因座和链的表示：\n   - 对于 TCR：两个基因座，alpha 和 beta。对于 BCR：两个基因座，重链和轻链。\n   - 每个基因座包含零条或多条观察到的链，每条链由一个有序对 $(u, p)$ 表示，其中 $u$ 是一个非负整数 UMI 计数，$p$ 是一个布尔值，表示是否为生产性（True 表示生产性，False 表示非生产性）。生产性是 V(D)J 重排的一个属性。\n2. 过滤：\n   - 最小 UMI 阈值 $\\theta_{\\mathrm{umi}} = 3$。仅保留 $u \\ge \\theta_{\\mathrm{umi}}$ 且 $p = \\text{True}$ 的链。\n   - 通过显性分数 $\\phi = 0.2$ 排除环境污染：在对一个基因座内的生产性链进行阈值处理后，计算该基因座中保留链的最大 UMI 为 $u_{\\max}$；仅保留那些满足 $u \\ge \\phi \\cdot u_{\\max}$ 的链。如果没有生产性链通过 UMI 阈值，则该基因座为空。\n3. 每个基因座的最大可能链数，以避免多重细胞：\n   - 对于 TCR：一个单细胞最多有 $2$ 条 alpha 链和最多 $1$ 条 beta 链被认为是合理的。如果在过滤后，某个基因座的链数超过其限制，则标记为 TCR 多重细胞。\n   - 对于 BCR：一个单细胞最多有 $1$ 条重链和最多 $2$ 条轻链被认为是合理的。如果在过滤后，某个基因座的链数超过其限制，则标记为 BCR 多重细胞。\n4. 配对：\n   - 如果任何受体系统（TCR 或 BCR）被标记为多重细胞，则在该测试用例中不报告该受体系统的任何配对或孤儿链（将其视为该受体系统不可用）。\n   - 否则，如果一个受体系统中的两个基因座都至少有一条保留链，则通过计算两个基因座中保留链的笛卡尔积来形成异源二聚体对，但每个受体系统最多报告 $\\kappa_{\\max} = 2$ 个配对，选择 UMI 计数乘积最高的配对（如果需要打破平局，任何确定性的打破平局方法都是可接受的）。如果报告了至少一个配对，则在该测试用例中不为该受体系统计算任何孤儿链。\n   - 如果一个受体系统中只有一个基因座有保留链而另一个基因座为空，则报告零个配对，并报告一个孤儿链计数，其数量等于该受体系统中非空基因座的保留链数量。\n   - 如果两个基因座都为空，则报告零个配对和零个孤儿链。\n5. 每个测试用例的输出：\n   - 对于 TCR：输出一个三元组 $[n_{\\mathrm{pair}}^{\\mathrm{TCR}}, n_{\\mathrm{orphan}}^{\\mathrm{TCR}}, m^{\\mathrm{TCR}}]$，其中 $n_{\\mathrm{pair}}^{\\mathrm{TCR}}$ 是报告的 TCR 配对数（一个整数），$n_{\\mathrm{orphan}}^{\\mathrm{TCR}}$ 是 TCR 的孤儿链计数（一个整数），$m^{\\mathrm{TCR}}$ 是 TCR 的多重细胞标志，编码为 $0$ 表示 False，$1$ 表示 True。\n   - 对于 BCR：输出一个具有类似含义的三元组 $[n_{\\mathrm{pair}}^{\\mathrm{BCR}}, n_{\\mathrm{orphan}}^{\\mathrm{BCR}}, m^{\\mathrm{BCR}}]$。\n6. 最终输出格式：\n   - 对于一个测试用例列表，生成单行输出，其中包含所有测试用例按顺序连接、展平为一个由方括号括起来的逗号分隔列表的结果。例如，如果有 $T$ 个测试用例，输出 $[t_{1,1}, t_{1,2}, t_{1,3}, b_{1,1}, b_{1,2}, b_{1,3}, \\ldots, t_{T,1}, t_{T,2}, t_{T,3}, b_{T,1}, b_{T,2}, b_{T,3}]$。\n\n实现上述逻辑，并为以下测试套件计算输出。每个测试用例按基因座提供观察到的链，形式为 UMI 计数和括号内的生产性标签。阈值固定为 $\\theta_{\\mathrm{umi}} = 3$，$\\phi = 0.2$ 和 $\\kappa_{\\max} = 2$。\n\n测试用例 1：\n- TCR alpha: UMI $10$ (生产性), UMI $20$ (非生产性)。TCR beta: UMI $12$ (生产性)。\n- BCR heavy: UMI $15$ (生产性)。BCR light: UMI $9$ (生产性), UMI $2$ (生产性), UMI $100$ (非生产性)。\n\n测试用例 2：\n- TCR alpha: UMI $10$ (生产性), UMI $8$ (生产性)。TCR beta: UMI $5$ (生产性)。\n- BCR heavy: UMI $12$ (生产性)。BCR light: UMI $7$ (生产性), UMI $6$ (生产性)。\n\n测试用例 3：\n- TCR alpha: UMI $12$ (生产性), UMI $5$ (生产性), UMI $4$ (生产性)。TCR beta: UMI $6$ (生产性)。\n- BCR heavy: UMI $10$ (生产性), UMI $4$ (生产性)。BCR light: UMI $8$ (生产性)。\n\n测试用例 4：\n- TCR alpha: 无。TCR beta: UMI $9$ (生产性)。\n- BCR heavy: UMI $8$ (生产性)。BCR light: 无。\n\n测试用例 5：\n- TCR alpha: UMI $2$ (生产性), UMI $1$ (生产性)。TCR beta: UMI $2$ (生产性)。\n- BCR heavy: UMI $20$ (生产性)。BCR light: UMI $1$ (生产性)。\n\n测试用例 6：\n- TCR alpha: UMI $10$ (生产性), UMI $1$ (生产性)。TCR beta: UMI $9$ (生产性), UMI $3$ (生产性)。\n- BCR heavy: UMI $10$ (生产性)。BCR light: UMI $9$ (生产性), UMI $8$ (生产性), UMI $7$ (生产性)。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果，每个测试用例的展平顺序为 $[n_{\\mathrm{pair}}^{\\mathrm{TCR}}, n_{\\mathrm{orphan}}^{\\mathrm{TCR}}, m^{\\mathrm{TCR}}, n_{\\mathrm{pair}}^{\\mathrm{BCR}}, n_{\\mathrm{orphan}}^{\\mathrm{BCR}}, m^{\\mathrm{BCR}}]$。",
            "solution": "该问题提供了一套确定性规则，用于处理 T 细胞受体 (TCR) 和 B 细胞受体 (BCR) 的单细胞免疫受体测序数据。目标是根据观察到的受体链的 UMI 计数和生产性，识别有效的异源二聚体对、孤儿链或标记多重细胞。该问题在免疫基因组学方面有科学依据，定义明确且客观，因此被认为是有效的。\n\n解决方案需要逐步实现所提供的生物信息学流程。这个过程可以封装在一个函数中，该函数根据在给定受体系统（TCR 或 BCR）的两个组成基因座（例如 TCR alpha 和 TCR beta）中观察到的链来处理该系统。假设一个受体系统由两个基因座（基因座1和基因座2）定义。每个基因座都有一组观察到的链，其中每条链由一个对 $(u, p)$ 表示，其中 $u$ 是UMI计数，$p$ 是生产性状态。\n\n单个受体系统的处理过程如下：\n\n**1. 链的过滤**\n\n对于每个基因座，我们必须过滤观察到的链，以仅保留那些可能代表功能性、细胞内源性转录本的链。这是一个两步过程。\n\n   a. **生产性和 UMI 阈值处理**：仅当一条链 $(u, p)$ 是生产性的（$p = \\text{True}$）且其 UMI 计数满足最小阈值 $u \\ge \\theta_{\\mathrm{umi}}$ 时，该链才被初步保留。问题指定 $\\theta_{\\mathrm{umi}} = 3$。\n\n   b. **显性过滤**：此步骤移除可能为环境污染物的低丰度链。在初始阈值处理后，如果基因座中仍有链保留，我们识别其中的最大 UMI 计数 $u_{\\max}$。然后，我们仅从该集合中保留那些 UMI 计数满足 $u \\ge \\phi \\cdot u_{\\max}$ 的链。问题指定显性分数为 $\\phi = 0.2$。如果没有链通过初始的生产性和 UMI 阈值，则该基因座被视为空，此步骤不执行。\n\n在所有过滤步骤之后，设 $C_1$ 和 $C_2$ 分别为基因座 1 和基因座 2 的保留链的 UMI 计数集合。\n\n**2. 多重细胞检测**\n\n由于等位基因排斥，一个单细胞通常只表达有限数量的独特受体链。过多数量的链表明数据可能来源于一个‘多重细胞’（两个或更多细胞被一同捕获）。我们根据预定义的限制检查保留链的数量。\n\n   - 对于 TCR：限制是最多 $2$ 条 alpha 链和 $1$ 条 beta 链。如果 $|C_{\\alpha}| > 2$ 或 $|C_{\\beta}| > 1$，则标记为多重细胞。\n   - 对于 BCR：限制是最多 $1$ 条重链和 $2$ 条轻链。如果 $|C_{H}| > 1$ 或 $|C_{L}| > 2$，则标记为多重细胞。\n\n如果为某个受体系统检测到多重细胞，则对该系统的分析终止，输出为 $[n_{\\mathrm{pair}}, n_{\\mathrm{orphan}}, m] = [0, 0, 1]$，其中 $m=1$ 表示多重细胞。\n\n**3. 配对与孤儿链识别**\n\n如果没有检测到多重细胞，我们继续进行配对或孤儿链的识别。\n\n   a. **配对**：如果两个基因座都含有至少一条保留链（即 $C_1$ 和 $C_2$ 均非空），我们形成潜在的异源二聚体对。所有可能配对的集合是笛卡尔积 $C_1 \\times C_2$。对于每对 $(u_1, u_2)$，我们计算一个配对分数，即其 UMI 计数的乘积 $s = u_1 \\cdot u_2$。我们按分数降序对所有配对进行排序。报告得分最高的配对，最多为 $\\kappa_{\\max}=2$ 个。报告的配对数量为 $n_{\\mathrm{pair}}$。如果报告了至少一个配对，孤儿链的数量定义为零，$n_{\\mathrm{orphan}}=0$。这种情况的输出为 $[n_{\\mathrm{pair}}, 0, 0]$。\n\n   b. **孤儿链**：如果两个基因座中只有一个含有保留链（例如，$C_1$ 非空而 $C_2$ 为空），则无法形成配对。非空基因座中的链被视为孤儿链。配对数量为 $n_{\\mathrm{pair}}=0$，孤儿链数量 $n_{\\mathrm{orphan}}$ 是非空基因座中的链数。这种情况的输出为 $[0, n_{\\mathrm{orphan}}, 0]$。\n\n   c. **空情况**：如果在过滤后两个基因座都为空（$C_1$ 和 $C_2$ 均为空），则没有配对也没有孤儿链。输出为 $[0, 0, 0]$。\n\n这套完整的逻辑将应用于每个测试用例的 TCR 和 BCR 系统。最终输出是所有测试用例中每个系统产生的三元组 $[n_{\\mathrm{pair}}, n_{\\mathrm{orphan}}, m]$ 的串联结果。\n\n作为一个例子，我们来追踪测试用例 2 的 TCR 系统。\n- TCR alpha 链: $(10, \\text{True}), (8, \\text{True})$。TCR beta 链: $(5, \\text{True})$。\n- 常量: $\\theta_{\\mathrm{umi}}=3, \\phi=0.2$。TCR 限制: $|C_{\\alpha}| \\le 2, |C_{\\beta}| \\le 1$。$\\kappa_{\\max}=2$。\n\n1.  **过滤 TCR alpha**:\n    - 两条链都是生产性的。它们的 $u \\ge 3$。保留集合为 $\\{(10, \\text{True}), (8, \\text{True})\\}$。\n    - $u_{\\max} = 10$。显性阈值为 $\\phi \\cdot u_{\\max} = 0.2 \\cdot 10 = 2$。\n    - 两条链都满足 $u \\ge 2$。都被保留。\n    - $C_{\\alpha} = \\{10, 8\\}$。$|C_{\\alpha}| = 2$。\n\n2.  **过滤 TCR beta**:\n    - 链 $(5, \\text{True})$ 是生产性的且 $u \\ge 3$。保留集合为 $\\{(5, \\text{True})\\}$。\n    - $u_{\\max} = 5$。显性阈值为 $\\phi \\cdot u_{\\max} = 0.2 \\cdot 5 = 1$。\n    - 该链满足 $u \\ge 1$。它被保留。\n    - $C_{\\beta} = \\{5\\}$。$|C_{\\beta}| = 1$。\n\n3.  **多重细胞检查**:\n    - $|C_{\\alpha}| = 2 \\le 2$ (正常)。$|C_{\\beta}| = 1 \\le 1$ (正常)。\n    - 没有多重细胞。$m^{\\mathrm{TCR}} = 0$。\n\n4.  **配对**:\n    - $C_{\\alpha}$ 和 $C_{\\beta}$ 均非空。我们进行配对。\n    - 笛卡尔积 $C_{\\alpha} \\times C_{\\beta} = \\{(10, 5), (8, 5)\\}$。\n    - 分数: $s_1 = 10 \\cdot 5 = 50$, $s_2 = 8 \\cdot 5 = 40$。\n    - 按分数排序的配对: $((10, 5), (8, 5))$。\n    - 我们最多可以报告 $\\kappa_{\\max}=2$ 个配对。我们有 $2$ 个配对。\n    - $n_{\\mathrm{pair}}^{\\mathrm{TCR}} = 2$。由于报告了配对，因此 $n_{\\mathrm{orphan}}^{\\mathrm{TCR}} = 0$。\n\n测试用例 2 中 TCR 的结果是 $[2, 0, 0]$。此过程被系统地应用于所有提供的数据。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the full logic for TCR/BCR pairing, orphan counting, and multiplet detection.\n    \"\"\"\n    # Define problem constants\n    THETA_UMI = 3\n    PHI = 0.2\n    KAPPA_MAX = 2\n\n    # Define receptor-specific multiplet limits\n    TCR_LIMITS = {'alpha': 2, 'beta': 1}\n    BCR_LIMITS = {'heavy': 1, 'light': 2}\n\n    # Define the test suite\n    test_cases = [\n        # Test case 1\n        {\n            'tcr_alpha': [(10, True), (20, False)], 'tcr_beta': [(12, True)],\n            'bcr_heavy': [(15, True)], 'bcr_light': [(9, True), (2, True), (100, False)]\n        },\n        # Test case 2\n        {\n            'tcr_alpha': [(10, True), (8, True)], 'tcr_beta': [(5, True)],\n            'bcr_heavy': [(12, True)], 'bcr_light': [(7, True), (6, True)]\n        },\n        # Test case 3\n        {\n            'tcr_alpha': [(12, True), (5, True), (4, True)], 'tcr_beta': [(6, True)],\n            'bcr_heavy': [(10, True), (4, True)], 'bcr_light': [(8, True)]\n        },\n        # Test case 4\n        {\n            'tcr_alpha': [], 'tcr_beta': [(9, True)],\n            'bcr_heavy': [(8, True)], 'bcr_light': []\n        },\n        # Test case 5\n        {\n            'tcr_alpha': [(2, True), (1, True)], 'tcr_beta': [(2, True)],\n            'bcr_heavy': [(20, True)], 'bcr_light': [(1, True)]\n        },\n        # Test case 6\n        {\n            'tcr_alpha': [(10, True), (1, True)], 'tcr_beta': [(9, True), (3, True)],\n            'bcr_heavy': [(10, True)], 'bcr_light': [(9, True), (8, True), (7, True)]\n        }\n    ]\n\n    def filter_locus(chains):\n        \"\"\"\n        Applies productivity, UMI threshold, and dominance filters to a list of chains.\n        \n        Args:\n            chains (list): A list of (umi, productive) tuples.\n            \n        Returns:\n            list: A list of UMI counts for the retained chains.\n        \"\"\"\n        # 1. Retain only productive chains with UMI count >= THETA_UMI\n        thresholded_chains = [u for u, p in chains if p and u >= THETA_UMI]\n        \n        if not thresholded_chains:\n            return []\n            \n        # 2. Apply ambient exclusion by dominance fraction\n        u_max = max(thresholded_chains)\n        retained_umis = [u for u in thresholded_chains if u >= PHI * u_max]\n        \n        return retained_umis\n\n    def process_receptor(locus1_chains, locus2_chains, max1, max2):\n        \"\"\"\n        Processes a single receptor system (TCR or BCR).\n        \n        Args:\n            locus1_chains (list): Chains for the first locus.\n            locus2_chains (list): Chains for the second locus.\n            max1 (int): Max plausible chain count for locus 1.\n            max2 (int): Max plausible chain count for locus 2.\n            \n        Returns:\n            list: A triple [n_pair, n_orphan, m_flag].\n        \"\"\"\n        retained1 = filter_locus(locus1_chains)\n        retained2 = filter_locus(locus2_chains)\n\n        # 3. Check for multiplets\n        if len(retained1) > max1 or len(retained2) > max2:\n            return [0, 0, 1]  # Multiplet flagged\n\n        n_retained1 = len(retained1)\n        n_retained2 = len(retained2)\n\n        # 4. Pairing logic\n        if n_retained1 > 0 and n_retained2 > 0:\n            # Form pairs and score them\n            pairs = []\n            for u1 in retained1:\n                for u2 in retained2:\n                    pairs.append({'u1': u1, 'u2': u2, 'product': u1 * u2})\n            \n            # Sort by UMI product, descending\n            sorted_pairs = sorted(pairs, key=lambda x: x['product'], reverse=True)\n            \n            # Report up to KAPPA_MAX pairs\n            n_pair = min(len(sorted_pairs), KAPPA_MAX)\n            return [n_pair, 0, 0] # Report pairs, no orphans\n        \n        # 5. Orphan chain logic\n        elif n_retained1 > 0 or n_retained2 > 0:\n            n_orphan = n_retained1 + n_retained2\n            return [0, n_orphan, 0] # Report orphans, no pairs\n            \n        # 6. Empty case\n        else:\n            return [0, 0, 0] # No pairs, no orphans\n\n\n    final_results = []\n    for case in test_cases:\n        # Process TCR\n        tcr_result = process_receptor(\n            case['tcr_alpha'], case['tcr_beta'], \n            TCR_LIMITS['alpha'], TCR_LIMITS['beta']\n        )\n        final_results.extend(tcr_result)\n        \n        # Process BCR\n        bcr_result = process_receptor(\n            case['bcr_heavy'], case['bcr_light'],\n            BCR_LIMITS['heavy'], BCR_LIMITS['light']\n        )\n        final_results.extend(bcr_result)\n        \n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}