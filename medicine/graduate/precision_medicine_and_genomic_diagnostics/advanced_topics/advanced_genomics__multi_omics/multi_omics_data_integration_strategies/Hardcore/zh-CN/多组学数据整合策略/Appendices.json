{
    "hands_on_practices": [
        {
            "introduction": "在进行任何多组学分析之前，识别并处理可能扭曲结果的异常样本是至关重要的一步。本练习将指导您构建一个系统的质量控制（QC）流程，它结合了两种强大的统计技术。您将使用主成分分析（PCA）的杠杆值来识别高维数据中的多变量异常点，并利用稳健的中位数绝对偏差（MAD）方法来检测关键质量指标中的单变量异常点 。这项实践旨在强调对多组学数据进行系统性和多方面质量评估的必要性。",
            "id": "5033985",
            "problem": "您的任务是为转化医学中的多组学整合构建一个质量控制流程，该流程使用主成分分析 (PCA) 的杠杆值和应用于关键质量指标的中位数绝对偏差 (MAD) 阈值来检测跨组学的异常样本。该流程必须实现为一个无需输入并产生单行输出的完整、可运行的程序。该程序必须为提供的测试套件计算异常样本的索引。\n\n使用的基础和定义：\n- 设组学数据矩阵表示为 $X \\in \\mathbb{R}^{n \\times p}$，其中有 $n$ 个样本（行）和 $p$ 个特征（列）。在进行后续计算之前，必须将 $X$ 的每一列标准化为零均值和单位方差。\n- 主成分分析 (PCA) 可通过奇异值分解 (SVD) 定义，$X = U \\Sigma V^\\mathsf{T}$，其中 $U \\in \\mathbb{R}^{n \\times r}$ 和 $V \\in \\mathbb{R}^{p \\times r}$ 具有标准正交列，$\\Sigma \\in \\mathbb{R}^{r \\times r}$ 是对角矩阵，其对角线元素为非负奇异值，且 $r = \\operatorname{rank}(X)$。\n- 对于选定的组分数 $k$，且 $k \\leq p$，将到前 $k$ 个左奇异子空间的投影定义为 $U_k \\in \\mathbb{R}^{n \\times k}$，即当 $r \\geq k$ 时为 $U$ 的前 $k$ 列，否则为 $U_k \\in \\mathbb{R}^{n \\times r}$。样本 $i$ 的 PCA 杠杆值是到该子空间的投影矩阵的对角线元素，$h_i = \\sum_{j=1}^{\\min(k, r)} U_{ij}^2$。\n- 投影矩阵 $H_k = U_k U_k^\\mathsf{T}$ 是对称且幂等的，并满足 $\\operatorname{trace}(H_k) = \\min(k, r)$。因此，平均杠杆值等于 $\\operatorname{trace}(H_k)/n = \\min(k, r)/n$。可以通过将 $h_i$ 与阈值 $\\alpha \\cdot \\min(k, r)/n$ 进行比较来定义基于杠杆值的异常值，其中放大因子 $\\alpha > 1$。\n- 对于一个质量指标向量 $q \\in \\mathbb{R}^n$，定义 $\\operatorname{median}(q)$，中位数绝对偏差 $d_i = |q_i - \\operatorname{median}(q)|$，$\\operatorname{MAD}(q) = \\operatorname{median}(d)$，以及稳健缩放偏差 $z_i = d_i / (c \\cdot \\operatorname{MAD}(q))$，其中 $c = 1.4826$（正态性下的一致性常数）。基于指标的异常值是任何满足 $z_i$ 超过阈值 $t$ 的 $i$。\n- 跨组学整合：给定 $O$ 个组学矩阵 $\\{X^{(o)}\\}_{o=1}^O$，为每个样本 $i$ 定义跨组学的杠杆值超限计数 $C^{\\text{lev}}_i$，以及跨所提供指标的指标超限计数 $C^{\\text{met}}_i$。如果 $C^{\\text{lev}}_i \\geq \\theta$ 或 $C^{\\text{met}}_i \\geq \\phi$，则将样本 $i$ 标记为整合异常值，其中 $\\theta$ 和 $\\phi$ 是给定的整数阈值。\n\n实现要求：\n- 按列将每个组学矩阵标准化为零均值和单位方差；如果某列的方差为零，则将其标准化值视为全零。\n- 使用上述基于 SVD 的定义，通过 $U_k$ 和 $h_i$ 计算 PCA 杠杆值。\n- 使用基于 MAD 的稳健偏差计算质量指标异常值。如果 $\\operatorname{MAD}(q) = 0$，则该指标没有异常值，除非存在任何 $q_i \\neq \\operatorname{median}(q)$；在后一种情况下，将那些 $q_i \\neq \\operatorname{median}(q)$ 的样本视为异常值。\n- 使用 0-based 索引报告异常样本的索引。\n\n测试套件：\n- 测试用例 1 (一般多组学，在一个组学和指标中存在明显异常值)：\n    - 样本数：$n = 6$；组学数：$O = 3$；组分数 $k = 2$；杠杆放大因子 $\\alpha = 2.0$；杠杆计数阈值 $\\theta = 1$；指标阈值 $t = 3.0$；指标计数阈值 $\\phi = 1$。\n    - 基因组学矩阵 $X^{(1)}$ ($6 \\times 4$):\n      $$\n      \\begin{bmatrix}\n      0.5  & 1.0  & -0.3  & 0.2 \\\\\n      0.6  & 0.8  & -0.1  & 0.0 \\\\\n      0.4  & 1.1  & -0.2  & 0.1 \\\\\n      0.5  & 0.9  & -0.3  & 0.2 \\\\\n      0.6  & 1.0  & -0.2  & 0.3 \\\\\n      0.5  & 0.95 & -0.25 & 0.15\n      \\end{bmatrix}\n      $$\n    - 转录组学矩阵 $X^{(2)}$ ($6 \\times 5$):\n      $$\n      \\begin{bmatrix}\n      10 & 12 & 9  & 11 & 10 \\\\\n      11 & 12 & 9  & 10 & 11 \\\\\n      10 & 11 & 10 & 11 & 10 \\\\\n      10 & 12 & 9  & 11 & 10 \\\\\n      11 & 11 & 9  & 10 & 12 \\\\\n      10 & 12 & 10 & 11 & 11\n      \\end{bmatrix}\n      $$\n    - 蛋白质组学矩阵 $X^{(3)}$ ($6 \\times 3$):\n      $$\n      \\begin{bmatrix}\n      0  & 0  & 1 \\\\\n      0  & 0  & 1 \\\\\n      0  & 0  & 1 \\\\\n      10 & 10 & 1 \\\\\n      0  & 0  & 1 \\\\\n      0  & 0  & 1\n      \\end{bmatrix}\n      $$\n    - 质量指标：\n      - 指标 1 (例如，RNA质量)：$[8.0,\\, 8.2,\\, 7.9,\\, 3.0,\\, 8.1,\\, 8.0]$\n      - 指标 2 (例如，文库大小)：$[5{,}000{,}000,\\, 5{,}100{,}000,\\, 4{,}900{,}000,\\, 1{,}000{,}000,\\, 5{,}200{,}000,\\, 5{,}000{,}000]$\n    - 预期行为：一个整合异常值，对应于蛋白质组学样本和指标中的异常值。\n- 测试用例 2 (边界条件：零方差特征和无指标偏差)：\n    - $n = 4$, $O = 2$, $k = 2$, $\\alpha = 2.0$, $\\theta = 1$, $t = 3.0$, $\\phi = 1$。\n    - 组学矩阵 $$X^{(1)} = X^{(2)} = \\begin{bmatrix}1 & 2 & 3 \\\\ 1 & 2 & 3 \\\\ 1 & 2 & 3 \\\\ 1 & 2 & 3 \\end{bmatrix}$$\n    - 质量指标：\n      - 指标 1：$[10,\\, 10,\\, 10,\\, 10]$\n      - 指标 2：$[100,\\, 100,\\, 100,\\, 100]$\n    - 预期行为：无整合异常值。\n- 测试用例 3 (边缘情况：仅通过指标产生的异常值)：\n    - $n = 5$, $O = 2$, $k = 2$, $\\alpha = 2.0$, $\\theta = 2$, $t = 3.0$, $\\phi = 2$。\n    - 组学矩阵：\n      - $$X^{(1)} = \\begin{bmatrix} 1 & 2 \\\\ 1 & 2 \\\\ 1.1 & 1.9 \\\\ 0.9 & 2.1 \\\\ 1 & 2 \\end{bmatrix}$$\n      - $$X^{(2)} = \\begin{bmatrix} 5 & 5 \\\\ 5 & 5 \\\\ 5.1 & 4.9 \\\\ 4.9 & 5.1 \\\\ 5 & 5 \\end{bmatrix}$$\n    - 质量指标：\n      - 指标 1：$[0.1,\\, 5.0,\\, 0.2,\\, 0.1,\\, 0.0]$\n      - 指标 2：$[100,\\, 1000,\\, 105,\\, 98,\\, 97]$\n    - 预期行为：通过指标产生一个整合异常值 (第二个样本)。\n输出规范：\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个结果必须是相应测试用例中被标记为整合异常值的样本的 0-based 索引列表。例如，形式为 $[[i\\_1, i\\_2],[\\,], [j]]$ 的输出是有效的。最终输出必须在一行上精确打印为单个 Python 列表的列表字面量，不带任何额外文本。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于已建立的统计方法（主成分分析杠杆值，中位数绝对偏差），其确定性算法使其定义明确，语言客观，数据和参数的规范完整。该问题是转化医学中多组学数据质量控制的一个可形式化且相关的任务。其中没有矛盾，没有违反科学原则，也没有会妨碍得出唯一、可验证解的歧义。\n\n以下是一个完整的、经过推理的解决方案。\n\n### **算法流程**\n\n该质量控制流程通过整合跨多个组学数据集和质量指标向量的两种不同类型的统计度量来识别异常样本：基于 PCA 的杠杆值和基于 MAD 的稳健偏差。对于给定的测试用例，流程如下。\n\n**1. 初始化**\n设 $n$ 为样本数量。初始化两个整数向量来为每个样本存储异常值计数：\n- $C^{\\text{lev}} \\in \\mathbb{Z}^n$，初始化为零，用于计算基于杠杆值的异常值标志。\n- $C^{\\text{met}} \\in \\mathbb{Z}^n$，初始化为零，用于计算基于指标的异常值标志。\n\n**2. 基于杠杆值的异常值检测（每个组学数据集）**\n对于 $O$ 个组学数据矩阵中的每一个 $X^{(o)} \\in \\mathbb{R}^{n \\times p}$，其中 $o \\in \\{1, \\dots, O\\}$：\n\n**a. 标准化：**\n将 $X^{(o)}$ 的每一列 $j$ 标准化，使其均值为 $0$，标准差为 $1$。设 $X^{(o)}_{:,j}$ 为第 $j$ 列。计算其均值 $\\mu_j$ 和标准差 $\\sigma_j$。标准化后的列 $X'^{(o)}_{:,j}$ 由下式给出：\n$$\nX'^{(o)}_{i,j} = \\begin{cases} (X^{(o)}_{i,j} - \\mu_j) / \\sigma_j  \\text{if } \\sigma_j > 0 \\\\ 0  \\text{if } \\sigma_j = 0 \\end{cases}\n$$\n这就创建了标准化矩阵 $X'^{(o)}$。\n\n**b. 奇异值分解 (SVD)：**\n计算标准化矩阵的 SVD：$X'^{(o)} = U^{(o)} \\Sigma^{(o)} (V^{(o)})^\\mathsf{T}$。此处，$U^{(o)} \\in \\mathbb{R}^{n \\times n}$ 是左奇异向量矩阵。\n\n**c. 秩和组分选择：**\n确定矩阵的秩 $r^{(o)} = \\operatorname{rank}(X'^{(o)})$。这对应于非零奇异值的数量。需要考虑的主成分数量为 $k' = \\min(k, r^{(o)})$，其中 $k$ 是用户指定的组分数。我们将 $U_{k'}^{(o)}$ 定义为包含 $U^{(o)}$ 前 $k'$ 列的矩阵。\n\n**d. 杠杆值计算：**\n对于每个样本 $i \\in \\{1, \\dots, n\\}$，其杠杆值 $h_i^{(o)}$ 是 $U_{k'}^{(o)}$ 第 $i$ 行元素平方和：\n$$\nh_i^{(o)} = \\sum_{j=1}^{k'} (U^{(o)}_{ij})^2\n$$\n\n**e. 异常值标记：**\n基于平均杠杆值计算杠杆阈值 $\\tau_{\\text{lev}}^{(o)}$：\n$$\n\\tau_{\\text{lev}}^{(o)} = \\frac{\\alpha \\cdot k'}{n}\n$$\n其中 $\\alpha$ 是给定的放大因子。如果样本的杠杆值 $h_i^{(o)}$ 超过此阈值，则其杠杆异常值计数 $C^{\\text{lev}}_i$ 增加：\n$$\n\\text{if } h_i^{(o)} > \\tau_{\\text{lev}}^{(o)}, \\text{ then } C^{\\text{lev}}_i \\leftarrow C^{\\text{lev}}_i + 1\n$$\n\n**3. 基于指标的异常值检测（每个质量指标）**\n对于每个提供的质量指标向量 $q \\in \\mathbb{R}^n$：\n\n**a. 中位数和中位数绝对偏差 (MAD)：**\n计算指标的中位数 $m = \\operatorname{median}(q)$。对所有样本计算与中位数的绝对偏差 $d_i = |q_i - m|$。MAD 是这些绝对偏差的中位数：$\\operatorname{MAD}(q) = \\operatorname{median}(d)$。\n\n**b. 异常值标记：**\n标记异常值的方法取决于 $\\operatorname{MAD}(q)$ 的值：\n- 如果 $\\operatorname{MAD}(q) > 0$：为每个样本计算稳健缩放偏差 $z_i$：\n  $$\n  z_i = \\frac{d_i}{c \\cdot \\operatorname{MAD}(q)} = \\frac{|q_i - \\operatorname{median}(q)|}{1.4826 \\cdot \\operatorname{MAD}(q)}\n  $$\n  如果 $z_i$ 超过指标阈值 $t$，则该样本的指标异常值计数 $C^{\\text{met}}_i$ 增加。\n- 如果 $\\operatorname{MAD}(q) = 0$：任何指标值 $q_i$ 不等于中位数 $m$ 的样本 $i$ 都被视为异常值。对于每个这样的样本，$C^{\\text{met}}_i$ 增加。如果所有 $q_i$ 都等于中位数，则此指标没有异常值被标记。\n\n**4. 整合异常值识别**\n在处理完所有组学矩阵和质量指标后，通过将每个样本 $i$ 的累积计数 $C^{\\text{lev}}_i$ 和 $C^{\\text{met}}_i$ 与相应的整数阈值 $\\theta$ 和 $\\phi$ 进行比较，来确定其最终的异常值状态：\n$$\n\\text{样本 } i \\text{ 是整合异常值，如果 } (C^{\\text{lev}}_i \\geq \\theta) \\lor (C^{\\text{met}}_i \\geq \\phi)\n$$\n满足此条件的所有样本的 0-based 索引被收集起来，作为该测试用例的最终结果。\n\n---\n### **应用于测试用例**\n\n**测试用例 1**\n- 参数：$n=6, O=3, k=2, \\alpha=2.0, \\theta=1, t=3.0, \\phi=1$。\n- **杠杆值：**\n  - 对于 $X^{(1)}$ 和 $X^{(2)}$，数据点相对同质。标准化后，SVD 产生的杠杆值中没有单个样本占主导地位。秩分别为 $r^{(1)}=4$ 和 $r^{(2)}=5$。那么 $k' = \\min(2,4)=2$ 和 $k'=\\min(2,5)=2$。阈值为 $\\tau_{\\text{lev}}^{(1)} = 2.0 \\cdot 2 / 6 \\approx 0.667$ 和 $\\tau_{\\text{lev}}^{(2)} = 2.0 \\cdot 2 / 6 \\approx 0.667$。所有计算出的 $h_i^{(1)}$ 和 $h_i^{(2)}$ 值都被发现低于此阈值。\n  - 对于 $X^{(3)}$，第4个样本（索引为3）是异常的：$[10, 10, 1]$。标准化后，矩阵的秩为 $r^{(3)}=1$。因此，$k'=\\min(2,1)=1$。杠杆阈值为 $\\tau_{\\text{lev}}^{(3)} = 2.0 \\cdot 1 / 6 \\approx 0.333$。杠杆值约为 $h^{(3)} = [0.038, 0.038, 0.038, 0.769, 0.038, 0.038]$。只有 $h_3^{(3)} \\approx 0.769 > 0.333$。\n  - 杠杆计数为 $C^{\\text{lev}} = [0, 0, 0, 1, 0, 0]$。\n- **指标：**\n  - 指标1：$q = [8.0, 8.2, 7.9, 3.0, 8.1, 8.0]$。中位数为 $8.0$。偏差为 $[0.0, 0.2, 0.1, 5.0, 0.1, 0.0]$。MAD 为 $0.1$。样本4（索引为3）的z分数为 $z_3 = 5.0 / (1.4826 \\cdot 0.1) \\approx 33.72 > 3.0$。\n  - 指标2：$q = [5\\text{e}6, 5.1\\text{e}6, 4.9\\text{e}6, 1\\text{e}6, 5.2\\text{e}6, 5\\text{e}6]$。中位数为 $5\\text{e}6$。MAD 为 $1\\text{e}5$。样本4的z分数为 $z_3 = 4\\text{e}6 / (1.4826 \\cdot 1\\text{e}5) \\approx 26.98 > 3.0$。\n  - 指标计数为 $C^{\\text{met}} = [0, 0, 0, 2, 0, 0]$。\n- **整合：**\n  - 对于样本4（索引为3）：$C^{\\text{lev}}_3=1 \\geq \\theta=1$ 且 $C^{\\text{met}}_3=2 \\geq \\phi=1$。该样本是异常值。\n  - 对于所有其他样本 $i \\neq 3$，$C^{\\text{lev}}_i=0  1$ 且 $C^{\\text{met}}_i=0  1$。它们不是异常值。\n- **结果：** `[3]`\n\n**测试用例 2**\n- 参数：$n=4, O=2, k=2, \\alpha=2.0, \\theta=1, t=3.0, \\phi=1$。\n- **杠杆值：**\n  - $X^{(1)}$ 和 $X^{(2)}$ 都由相同的行组成。每一列的标准差都为 0。\n  - 根据规则，两个标准化矩阵 $X'^{(1)}$ 和 $X'^{(2)}$ 都是零矩阵。\n  - 零矩阵的秩为 $r=0$。因此 $k'=\\min(2, 0)=0$。\n  - 杠杆值 $h_i$ 均为 0，阈值 $\\tau_{\\text{lev}}$ 也为 0。条件 $h_i > \\tau_{\\text{lev}}$ 永远不会满足。\n  - 杠杆计数为 $C^{\\text{lev}} = [0, 0, 0, 0]$。\n- **指标：**\n  - 两个指标向量 $[10, 10, 10, 10]$ 和 $[100, 100, 100, 100]$ 都由相同的值组成。\n  - 对于两者，中位数都是常数值，所有偏差都为 0，因此 MAD 也为 0。\n  - 适用 $\\operatorname{MAD}=0$ 的特殊情况。由于没有 $q_i$ 与中位数不同，因此没有标记异常值。\n  - 指标计数为 $C^{\\text{met}} = [0, 0, 0, 0]$。\n- **整合：**\n  - 对于所有样本，$C^{\\text{lev}}_i=0$ 且 $C^{\\text{met}}_i=0$。条件 $C^{\\text{lev}}_i \\geq 1$ 或 $C^{\\text{met}}_i \\geq 1$ 永远不会满足。\n- **结果：** `[]`\n\n**测试用例 3**\n- 参数：$n=5, O=2, k=2, \\alpha=2.0, \\theta=2, t=3.0, \\phi=2$。\n- **杠杆值：**\n  - 矩阵 $X^{(1)}$ 和 $X^{(2)}$ 由非常相似的样本组成。\n  - 对于 $X^{(1)}$，$r^{(1)}=2, k'=2$。$\\tau_{\\text{lev}}^{(1)} = 2.0 \\cdot 2 / 5 = 0.8$。所有 $h_i^{(1)}$ 都低于此阈值。\n  - 对于 $X^{(2)}$，$r^{(2)}=2, k'=2$。$\\tau_{\\text{lev}}^{(2)} = 2.0 \\cdot 2 / 5 = 0.8$。所有 $h_i^{(2)}$ 都低于此阈值。\n  - 没有任何样本在任何组学中被标记为杠杆异常值。杠杆计数为 $C^{\\text{lev}} = [0, 0, 0, 0, 0]$。\n- **指标：**\n  - 指标1：$q = [0.1, 5.0, 0.2, 0.1, 0.0]$。中位数为 $0.1$。MAD 为 $0.1$。样本2（索引为1）的z分数为 $z_1 = 4.9 / (1.4826 \\cdot 0.1) \\approx 33.05 > 3.0$。样本2是异常值。\n  - 指标2：$q = [100, 1000, 105, 98, 97]$。中位数为 $100$。MAD 为 $3$。样本2的z分数为 $z_1 = 900 / (1.4826 \\cdot 3) \\approx 202.41 > 3.0$。样本2是异常值。\n  - 指标计数为 $C^{\\text{met}} = [0, 2, 0, 0, 0]$。\n- **整合：**\n  - 阈值很高：$\\theta=2, \\phi=2$。\n  - 对于样本2（索引为1）：$C^{\\text{lev}}_1=0  \\theta=2$，但 $C^{\\text{met}}_1=2 \\geq \\phi=2$。该样本是异常值。\n  - 对于所有其他样本，计数太低。\n- **结果：** `[1]`",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import svd\n\ndef solve():\n    \"\"\"\n    Main function to run the multi-omics outlier detection pipeline on a predefined test suite.\n    \"\"\"\n    \n    test_cases = [\n        # Test Case 1\n        {\n            \"params\": {\"n\": 6, \"O\": 3, \"k\": 2, \"alpha\": 2.0, \"theta\": 1, \"t\": 3.0, \"phi\": 1},\n            \"omics_data\": [\n                np.array([\n                    [0.5, 1.0, -0.3, 0.2],\n                    [0.6, 0.8, -0.1, 0.0],\n                    [0.4, 1.1, -0.2, 0.1],\n                    [0.5, 0.9, -0.3, 0.2],\n                    [0.6, 1.0, -0.2, 0.3],\n                    [0.5, 0.95, -0.25, 0.15]\n                ]),\n                np.array([\n                    [10, 12, 9, 11, 10],\n                    [11, 12, 9, 10, 11],\n                    [10, 11, 10, 11, 10],\n                    [10, 12, 9, 11, 10],\n                    [11, 11, 9, 10, 12],\n                    [10, 12, 10, 11, 11]\n                ]),\n                np.array([\n                    [0, 0, 1],\n                    [0, 0, 1],\n                    [0, 0, 1],\n                    [10, 10, 1],\n                    [0, 0, 1],\n                    [0, 0, 1]\n                ])\n            ],\n            \"quality_metrics\": [\n                np.array([8.0, 8.2, 7.9, 3.0, 8.1, 8.0]),\n                np.array([5_000_000, 5_100_000, 4_900_000, 1_000_000, 5_200_000, 5_000_000])\n            ]\n        },\n        # Test Case 2\n        {\n            \"params\": {\"n\": 4, \"O\": 2, \"k\": 2, \"alpha\": 2.0, \"theta\": 1, \"t\": 3.0, \"phi\": 1},\n            \"omics_data\": [\n                np.array([[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]),\n                np.array([[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]])\n            ],\n            \"quality_metrics\": [\n                np.array([10, 10, 10, 10]),\n                np.array([100, 100, 100, 100])\n            ]\n        },\n        # Test Case 3\n        {\n            \"params\": {\"n\": 5, \"O\": 2, \"k\": 2, \"alpha\": 2.0, \"theta\": 2, \"t\": 3.0, \"phi\": 2},\n            \"omics_data\": [\n                np.array([[1, 2], [1, 2], [1.1, 1.9], [0.9, 2.1], [1, 2]]),\n                np.array([[5, 5], [5, 5], [5.1, 4.9], [4.9, 5.1], [5, 5]])\n            ],\n            \"quality_metrics\": [\n                np.array([0.1, 5.0, 0.2, 0.1, 0.0]),\n                np.array([100, 1000, 105, 98, 97])\n            ]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        params = case[\"params\"]\n        n = params[\"n\"]\n        k = params[\"k\"]\n        alpha = params[\"alpha\"]\n        theta = params[\"theta\"]\n        t = params[\"t\"]\n        phi = params[\"phi\"]\n        \n        c_lev = np.zeros(n, dtype=int)\n        c_met = np.zeros(n, dtype=int)\n\n        # Leverage-based outlier detection\n        for X in case[\"omics_data\"]:\n            # Standardize matrix\n            mean = np.mean(X, axis=0)\n            std = np.std(X, axis=0)\n            X_std = np.zeros_like(X, dtype=float)\n            for j in range(X.shape[1]):\n                if std[j] > 1e-9: # Use tolerance for float comparison\n                    X_std[:, j] = (X[:, j] - mean[j]) / std[j]\n            \n            # SVD and rank\n            try:\n                U, s, Vh = svd(X_std, full_matrices=False)\n                # Rank is number of singular values greater than a tolerance\n                rank = np.linalg.matrix_rank(X_std)\n            except np.linalg.LinAlgError:\n                # SVD can fail on some ill-conditioned matrices, though unlikely here\n                continue\n\n            num_components = min(k, rank)\n            if num_components == 0:\n                continue\n\n            # Leverage calculation\n            U_k = U[:, :num_components]\n            h = np.sum(U_k**2, axis=1)\n            \n            # Leverage outlier flagging\n            leverage_threshold = alpha * num_components / n\n            c_lev[h > leverage_threshold] += 1\n\n        # Metric-based outlier detection\n        c_consistency = 1.4826\n        for q in case[\"quality_metrics\"]:\n            median_q = np.median(q)\n            deviations = np.abs(q - median_q)\n            mad_q = np.median(deviations)\n\n            if mad_q > 1e-9: # Use tolerance for float comparison\n                z_scores = deviations / (c_consistency * mad_q)\n                c_met[z_scores > t] += 1\n            else:\n                # Special case for MAD == 0\n                c_met[q != median_q] += 1\n        \n        # Integrated outlier identification\n        integrated_outliers = np.where((c_lev >= theta) | (c_met >= phi))[0].tolist()\n        results.append(integrated_outliers)\n\n    # Final print statement must produce the exact single-line format.\n    # The format `f\"[{','.join(map(str, results))}]\"` is explicitly requested,\n    # resulting in a string like '[[3],[],[1]]'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "整合来自不同技术平台的数据，例如RNA测序（计数数据）和蛋白质组学（连续数据），其主要挑战之一在于它们迥异的统计特性。本练习将深入探讨为何原始RNA-seq数据在样本间或特征间不具有直接可比性，这一特性被称为异方差性。通过从第一性原理推导计数数据的均值-方差关系，并据此设计一个有效的方差稳定变换（VST），您将深刻理解在联合分析前协调多组学数据集所必需的核心预处理步骤 。",
            "id": "4362390",
            "problem": "一个转化基因组学小组计划在一项精准肿瘤学的队列研究中，整合核糖核酸测序 (RNA-seq) 的基因水平计数与蛋白质组学的强度数据。他们将计算跨串联特征的联合潜在因子，以发现生物标志物。已知 RNA-seq 计数会受到样本特异性的文库大小和生物学过度离散的影响，而蛋白质组学强度在经过仪器水平的归一化后近似呈对数正态分布。为了避免由尺度和均值依赖的方差带来的偏差，该小组考虑通过样本特异性的大小因子（例如通过 Trimmed Mean of M-values (TMM) 或 Differential Expression sequencing 2 (DESeq2) 大小因子估计的那些）进行归一化，然后进行方差稳定变换 (VST)。\n\n从以下基础出发，推导并量化在数据串联前进行归一化和 VST 的必要性：\n\n- RNA-seq 计数源于泊松抽样过程，其样本 $i$ 和基因 $g$ 的率为 $\\lambda_{ig}$，其中 $\\lambda_{ig} = s_i q_g$，$s_i$ 是样本特异性的文库大小（一个乘性大小因子），$q_g$ 是基因 $g$ 在生物群体中的真实丰度。\n- 对于固定的 $i$ 和 $g$，假设泊松率 $\\lambda_{ig}$ 在重复实现中遵循伽马分布，可以对生物学和技术上的过度离散进行建模，这将计数 $Y_{ig}$ 的边缘分布转化为一个负二项式类模型。\n- 特征 $p$ 的蛋白质组学强度近似呈对数正态分布，因此经过对数变换后，其方差近似与其均值无关。\n\n任务：\n\n1. 从泊松-伽马混合模型出发，并使用经过充分检验的恒等式 $\\operatorname{Var}(Y)=\\operatorname{E}[\\operatorname{Var}(Y\\mid \\lambda)]+\\operatorname{Var}(\\operatorname{E}[Y\\mid \\lambda])$，推导 RNA-seq 计数 $Y_{ig}$ 的均值-方差关系 $v(\\mu)$，该关系是其均值 $\\mu_{ig} = s_i q_g$ 和一个概括伽马变异性的过度离散参数 $\\alpha$ 的函数。不要假设任何目标形式；从混合模型中明确推导它。\n2. 使用推导出的 $v(\\mu)$，解释为什么需要通过大小因子 $s_i$ 进行归一化（即分析 $\\tilde{Y}_{ig}=Y_{ig}/s_i$）以使特征在样本间具有可比性，以及为什么基因间的异方差性在归一化后仍然存在。\n3. 对于一个单参数均值-方差族，使用方差稳定变换 $g$ 的一般定义，推导出一个显式闭合形式 $g(y;\\alpha)$，使得 delta 方法近似 $\\operatorname{Var}(g(Y_{ig})) \\approx \\left(g'(\\mu_{ig})\\right)^{2} v(\\mu_{ig})$ 在不同 $\\mu_{ig}$ 间近似为常数。施加 $g(0)=0$ 来固定加性常数。\n4. 考虑单个样本 $i$，其大小因子 $s_i = 3$，以及两个基因，真实丰度分别为 $q_{1}=20$ 和 $q_{2}=2000$。设离散参数为 $\\alpha = 0.02$。将变换前的异方差性比率定义为 $R_{\\text{before}} = \\frac{v(\\mu_{i2})}{v(\\mu_{i1})}$，将在 delta 方法近似下应用推导出的 $g$ 变换后的异方差性比率定义为 $R_{\\text{after}} = \\frac{\\operatorname{Var}(g(Y_{i2}))}{\\operatorname{Var}(g(Y_{i1}))}$。计算 $R_{\\text{before}}$ 和 $R_{\\text{after}}$，并在最终答案中以单行矩阵的形式报告这两个量。不需要物理单位。\n\n您的最终答案必须是一个计算结果，并以单行矩阵的形式呈现 $R_{\\text{before}}$ 和 $R_{\\text{after}}$ 这两个数字。",
            "solution": "该问题是有效的，因为它在科学上基于已建立的基因组数据统计模型，问题是适定的，有足够的信息得到唯一解，并且使用客观、技术性的语言表述。\n\n解决方案分为四个部分，对应题目陈述中的四个任务。\n\n**任务1：均值-方差关系的推导**\n\n我们已知，对于样本 $i$ 和基因 $g$，RNA-seq 计数 $Y_{ig}$ 在给定率参数 $\\lambda_{ig}$ 的条件下，遵循泊松分布：\n$$Y_{ig} \\mid \\lambda_{ig} \\sim \\text{Poisson}(\\lambda_{ig})$$\n泊松分布的性质给出了条件均值和条件方差：\n$$\\operatorname{E}[Y_{ig} \\mid \\lambda_{ig}] = \\lambda_{ig}$$\n$$\\operatorname{Var}(Y_{ig} \\mid \\lambda_{ig}) = \\lambda_{ig}$$\n率参数 $\\lambda_{ig}$ 本身是一个随机变量，假设其遵循伽马分布以模拟过度离散。我们被要求使用全方差公式推导 $Y_{ig}$ 的边缘均值-方差关系：\n$$\\operatorname{Var}(Y_{ig}) = \\operatorname{E}[\\operatorname{Var}(Y_{ig} \\mid \\lambda_{ig})] + \\operatorname{Var}(\\operatorname{E}[Y_{ig} \\mid \\lambda_{ig}])$$\n代入泊松分布的条件矩，我们得到：\n$$\\operatorname{Var}(Y_{ig}) = \\operatorname{E}[\\lambda_{ig}] + \\operatorname{Var}(\\lambda_{ig})$$\n计数的边缘均值 $\\mu_{ig}$ 可通过全期望公式求得：\n$$\\mu_{ig} = \\operatorname{E}[Y_{ig}] = \\operatorname{E}[\\operatorname{E}[Y_{ig} \\mid \\lambda_{ig}]] = \\operatorname{E}[\\lambda_{ig}]$$\n问题陈述指出，伽马分布率的变异性由过度离散参数 $\\alpha$ 概括。在计数数据的负二项式模型的标准参数化中（如 DESeq2 和其他常用工具所使用的），率参数的方差通过一个二次项与其均值相关联：\n$$\\operatorname{Var}(\\lambda_{ig}) = \\alpha (\\operatorname{E}[\\lambda_{ig}])^2$$\n代入 $\\operatorname{E}[\\lambda_{ig}] = \\mu_{ig}$，我们有：\n$$\\operatorname{Var}(\\lambda_{ig}) = \\alpha \\mu_{ig}^2$$\n现在，我们将 $\\operatorname{E}[\\lambda_{ig}]$ 和 $\\operatorname{Var}(\\lambda_{ig})$ 代回 $\\operatorname{Var}(Y_{ig})$ 的表达式中：\n$$\\operatorname{Var}(Y_{ig}) = \\mu_{ig} + \\alpha \\mu_{ig}^2$$\n这给出了 RNA-seq 计数的均值-方差关系 $v(\\mu)$：\n$$v(\\mu_{ig}) = \\mu_{ig} + \\alpha \\mu_{ig}^2$$\n该关系表明，计数的方差是均值的二次函数。方差有两个组成部分：$\\mu_{ig}$ 对应于泊松“散粒噪声”，$\\alpha \\mu_{ig}^2$ 对应于由伽马分布建模的生物学和技术上的过度离散。\n\n**任务2：归一化的理由和持续异方差性的解释**\n\n样本 $i$ 中基因 $g$ 的原始计数的均值由 $\\mu_{ig} = s_i q_g$ 给出，其中 $s_i$ 是样本特异性的大小因子（与测序文库深度相关），$q_g$ 是该基因的真实潜在丰度。\n\n**归一化的必要性：**\n均值计数 $\\mu_{ig}$ 是一个技术因子 $s_i$ 和一个生物学因子 $q_g$ 的乘积。如果我们比较同一个基因 $g$ 在两个不同样本 $i$ 和 $j$ 中的原始计数 $Y_{ig}$ 和 $Y_{jg}$，即使生物学状态相同，只要 $s_i \\neq s_j$，它们的期望值 $\\mu_{ig} = s_i q_g$ 和 $\\mu_{jg} = s_j q_g$ 就会不同。在为下游分析（如 PCA 或潜在因子模型）串联特征时，具有更大大小因子（即更高测序深度）的样本在所有基因上都会系统性地具有更大的计数值。这种技术性伪影将主导分析，掩盖了我们感兴趣的真实生物学变异。为了使测量值在样本间具有可比性，我们必须对这些大小因子进行归一化。一种常见的方法是分析归一化后的计数 $\\tilde{Y}_{ig} = Y_{ig} / s_i$。这个归一化量的期望是：\n$$\\operatorname{E}[\\tilde{Y}_{ig}] = \\operatorname{E}[Y_{ig} / s_i] = \\frac{\\mu_{ig}}{s_i} = \\frac{s_i q_g}{s_i} = q_g$$\n归一化后，基因 $g$ 特征的期望值为 $q_g$，它与样本特异性的文库大小无关，反映了真实的生物学丰度。这使得特征在不同样本间具有可比性。\n\n**异方差性的持续存在：**\n虽然归一化校正了均值，但它没有解决均值依赖方差（异方差性）的问题。让我们计算归一化计数 $\\tilde{Y}_{ig}$ 的方差：\n$$\\operatorname{Var}(\\tilde{Y}_{ig}) = \\operatorname{Var}\\left(\\frac{Y_{ig}}{s_i}\\right) = \\frac{1}{s_i^2} \\operatorname{Var}(Y_{ig})$$\n使用均值-方差关系 $v(\\mu_{ig}) = \\mu_{ig} + \\alpha \\mu_{ig}^2$：\n$$\\operatorname{Var}(\\tilde{Y}_{ig}) = \\frac{1}{s_i^2} (\\mu_{ig} + \\alpha \\mu_{ig}^2)$$\n代入 $\\mu_{ig} = s_i q_g$：\n$$\\operatorname{Var}(\\tilde{Y}_{ig}) = \\frac{1}{s_i^2} (s_i q_g + \\alpha (s_i q_g)^2) = \\frac{q_g}{s_i} + \\alpha q_g^2$$\n归一化计数的均值为 $\\tilde{\\mu}_g = q_g$。方差是该均值的函数：$\\operatorname{Var}(\\tilde{Y}_{ig}) = \\tilde{\\mu}_g/s_i + \\alpha \\tilde{\\mu}_g^2$。这个方差显然不是常数；它取决于基因的丰度 $q_g$（或 $\\tilde{\\mu}_g$）。丰度越高的基因将具有越大的方差。对于许多对输入特征尺度敏感的多变量技术来说，这种异方差性是有问题的，这证明了后续进行方差稳定变换的必要性。\n\n**任务3：方差稳定变换 (VST) 的推导**\n\n方差稳定变换 $g(y)$ 是一个函数，使得变换后的随机变量 $g(Y)$ 的方差近似为常数。使用一阶泰勒展开（delta 方法），$g(Y)$ 的方差可以近似为：\n$$\\operatorname{Var}(g(Y)) \\approx (g'(\\mu))^2 \\operatorname{Var}(Y) = (g'(\\mu))^2 v(\\mu)$$\n其中 $\\mu = \\operatorname{E}[Y]$。为了获得一个常数方差，比如 $C$，我们必须有：\n$$(g'(\\mu))^2 v(\\mu) = C$$\n使用我们推导出的方差函数 $v(\\mu) = \\mu + \\alpha \\mu^2$，我们有：\n$$(g'(\\mu))^2 (\\mu + \\alpha \\mu^2) = C$$\n解出 $g'(\\mu)$：\n$$g'(\\mu) = \\frac{\\sqrt{C}}{\\sqrt{\\mu + \\alpha \\mu^2}}$$\n为了找到 $g(y)$，我们将 $g'(\\mu)$ 对 $\\mu$ 积分。我们可以将常数 $\\sqrt{C}$ 吸收到 $g$ 的定义中，实际上是将其设为 1。\n$$g(y) = \\int_0^y \\frac{1}{\\sqrt{u + \\alpha u^2}} du$$\n我们从 $0$ 积分到 $y$ 以满足条件 $g(0)=0$。该积分可以如下求解：\n$$g(y) = \\int_0^y \\frac{1}{\\sqrt{u(1 + \\alpha u)}} du$$\n令 $v = \\sqrt{\\alpha u}$。那么 $u = v^2/\\alpha$，且 $du = (2v/\\alpha)dv$。积分上下限变为 $0$ 到 $\\sqrt{\\alpha y}$。\n\\begin{align*} g(y) = \\int_0^{\\sqrt{\\alpha y}} \\frac{1}{\\sqrt{\\frac{v^2}{\\alpha}(1 + v^2)}} \\left(\\frac{2v}{\\alpha}\\right) dv \\\\ = \\int_0^{\\sqrt{\\alpha y}} \\frac{1}{\\frac{v}{\\sqrt{\\alpha}}\\sqrt{1 + v^2}} \\left(\\frac{2v}{\\alpha}\\right) dv \\\\ = \\frac{2\\sqrt{\\alpha}}{\\alpha} \\int_0^{\\sqrt{\\alpha y}} \\frac{v}{v\\sqrt{1+v^2}} dv \\\\ = \\frac{2}{\\sqrt{\\alpha}} \\int_0^{\\sqrt{\\alpha y}} \\frac{1}{\\sqrt{1+v^2}} dv \\end{align*}\n$(1+v^2)^{-1/2}$ 的积分是 $\\operatorname{arsinh}(v)$。\n$$g(y) = \\frac{2}{\\sqrt{\\alpha}} \\Big[ \\operatorname{arsinh}(v) \\Big]_0^{\\sqrt{\\alpha y}} = \\frac{2}{\\sqrt{\\alpha}} (\\operatorname{arsinh}(\\sqrt{\\alpha y}) - \\operatorname{arsinh}(0))$$\n由于 $\\operatorname{arsinh}(0)=0$，显式闭合形式的 VST 是：\n$$g(y; \\alpha) = \\frac{2}{\\sqrt{\\alpha}} \\operatorname{arsinh}(\\sqrt{\\alpha y})$$\n通过这种变换，近似方差变为 $\\operatorname{Var}(g(Y)) \\approx 1$，一个常数。\n\n**任务4：异方差性比率的计算**\n\n我们得到单个样本 $i$ 的参数：大小因子 $s_i = 3$，离散度 $\\alpha = 0.02$，以及两个基因的真实丰度 $q_1 = 20$ 和 $q_2 = 2000$。\n\n首先，我们计算这两个基因的平均计数：\n$$\\mu_{i1} = s_i q_1 = 3 \\times 20 = 60$$\n$$\\mu_{i2} = s_i q_2 = 3 \\times 2000 = 6000$$\n\n接下来，我们使用 $v(\\mu) = \\mu + \\alpha \\mu^2$ 计算每个基因的方差：\n$$v(\\mu_{i1}) = 60 + 0.02 \\times (60)^2 = 60 + 0.02 \\times 3600 = 60 + 72 = 132$$\n$$v(\\mu_{i2}) = 6000 + 0.02 \\times (6000)^2 = 6000 + 0.02 \\times 36,000,000 = 6000 + 720,000 = 726,000$$\n\n变换前的异方差性比率 $R_{\\text{before}}$ 是这些方差的比值：\n$$R_{\\text{before}} = \\frac{v(\\mu_{i2})}{v(\\mu_{i1})} = \\frac{726,000}{132} = 5500$$\n\n现在，我们考虑应用 VST 后的比率 $R_{\\text{after}}$。VST $g(y)$ 是被专门推导出来的，以使变换后变量的方差近似为常数，且与均值无关。如任务3所示，delta 方法近似给出：\n$$\\operatorname{Var}(g(Y_{ig})) \\approx (g'(\\mu_{ig}))^2 v(\\mu_{ig}) = \\left(\\frac{1}{\\sqrt{\\mu_{ig} + \\alpha \\mu_{ig}^2}}\\right)^2 (\\mu_{ig} + \\alpha \\mu_{ig}^2) = 1$$\n因此，对于这两个基因，变换后的方差近似为 $1$：\n$$\\operatorname{Var}(g(Y_{i1})) \\approx 1$$\n$$\\operatorname{Var}(g(Y_{i2})) \\approx 1$$\n因此，变换后的异方差性比率 $R_{\\text{after}}$ 是：\n$$R_{\\text{after}} = \\frac{\\operatorname{Var}(g(Y_{i2}))}{\\operatorname{Var}(g(Y_{i1}))} \\approx \\frac{1}{1} = 1$$\n这个计算量化了 VST 的有效性：它将一个 5500 的方差比率降低到 1，成功地稳定了在具有巨大不同平均表达水平的特征间的方差。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 5500  1 \\end{pmatrix} } $$"
        },
        {
            "introduction": "多组学整合的一个核心目标是构建不仅具有高预测性能，而且具有生物学可解释性的模型。本项高级练习将介绍重叠组套索（overlapping group lasso）这一强大的正则化技术，它能够鼓励模型以具有生物学意义的“组”为单位选择特征（例如，与单个基因相关的所有组学测量值，或单一模态下的所有基因）。您将通过实现一个先进的加速近端梯度算法来解决该优化问题，从而学习如何将先验生物学知识直接融入模型结构中，以发现稳健的生物标志物 。",
            "id": "4362368",
            "problem": "考虑一个精准医疗场景，其目标是根据每个基因在三种模态下测量的多组学特征来预测一个连续的临床结果：拷贝数变异 (CNV)、信使核糖核酸 (mRNA) 表达和脱氧核糖核酸 (DNA) 甲基化。令 $X \\in \\mathbb{R}^{n \\times p}$ 表示设计矩阵，其中有 $n$ 个样本和 $p$ 个特征。我们考虑 $n = 8$ 名患者和 $p = 9$ 个特征，这些特征按 3 个基因的模态块排序如下：基因 $1,2,3$ 的 CNV (第 $0,1,2$ 列)，基因 $1,2,3$ 的 mRNA 表达 (第 $3,4,5$ 列)，基因 $1,2,3$ 的 DNA 甲基化 (第 $6,7,8$ 列)。这些特征被组织成重叠的组，以反映两种生物学上相关的结构：(i) 跨模态的基因组和 (ii) 跨基因的模态组。\n\n现给定显式数据矩阵 $X$ 和一个确定性目标向量 $y$，该向量由已知的真实系数向量 $\\beta^\\star \\in \\mathbb{R}^p$ 构造而成，即 $y = X \\beta^\\star$。矩阵 $X$ (各行堆叠) 和向量 $\\beta^\\star$ 如下：\n- $X \\in \\mathbb{R}^{8 \\times 9}$，各行为：\n  - 第 1 行：$[1, 0, -1, 0.5, -1.2, 0.3, 0.8, 0.1, 0.2]$\n  - 第 2 行：$[0, 1, 1, 1.0, 0.3, -0.4, 0.6, 0.2, 0.9]$\n  - 第 3 行：$[-1, -1, 0, -0.7, 0.5, 1.2, 0.1, 0.4, 0.3]$\n  - 第 4 行：$[2, 0, 1, 0.2, -0.3, -0.5, 0.9, 0.7, 0.5]$\n  - 第 5 行：$[0, -2, 1, 1.5, 0.7, 0.0, 0.2, 0.8, 0.6]$\n  - 第 6 行：$[1, 1, 0, -0.4, 1.1, -1.3, 0.3, 0.5, 0.4]$\n  - 第 7 行：$[-1, 2, -1, 0.0, -0.6, 0.9, 0.4, 0.6, 0.7]$\n  - 第 8 行：$[0, 0, 2, 0.8, -0.9, 0.4, 0.5, 0.2, 0.1]$\n- $\\beta^\\star = [0.3, 0.0, -0.2, 1.0, 0.0, 0.5, -0.8, 0.0, 0.2]^\\mathsf{T}$\n- $y = X \\beta^\\star$\n\n定义以下重叠组 $\\mathcal{G}$，它们反映了跨模态的基因水平整合和跨基因的模态水平整合：\n- 跨模态的基因组：\n  - $G_{\\text{gene},1} = \\{0, 3, 6\\}$\n  - $G_{\\text{gene},2} = \\{1, 4, 7\\}$\n  - $G_{\\text{gene},3} = \\{2, 5, 8\\}$\n- 跨基因的模态组：\n  - $G_{\\text{CNV}} = \\{0, 1, 2\\}$\n  - $G_{\\text{Expr}} = \\{3, 4, 5\\}$\n  - $G_{\\text{Meth}} = \\{6, 7, 8\\}$\n\n令每个组 $g \\in \\mathcal{G}$ 的权重为 $\\alpha_g = \\sqrt{|g|}$，其中 $|g|$ 表示组 $g$ 的基数。重叠组套索惩罚项为\n$$\n\\Omega(w) \\;=\\; \\sum_{g \\in \\mathcal{G}} \\alpha_g \\, \\|w_g\\|_2,\n$$\n其中 $w_g$ 表示由 $g$ 索引的 $w \\in \\mathbb{R}^p$ 的子向量。要最小化的目标是带有平方损失的线性回归的惩罚经验风险，\n$$\nF_\\lambda(w) \\;=\\; \\frac{1}{2n}\\,\\|X w - y\\|_2^2 \\;+\\; \\lambda\\,\\Omega(w),\n$$\n其中正则化参数 $\\lambda \\ge 0$ 且 $n = 8$。\n\n使用的基本依据和定义：\n- 平方损失 $f(w) = \\frac{1}{2n}\\|X w - y\\|_2^2$ 的梯度为 $\\nabla f(w) = \\frac{1}{n} X^\\mathsf{T} (X w - y)$，并且是凸的，其梯度 $\\nabla f$ 是 $L$-利普希茨的，其中 $L = \\lambda_{\\max}\\!\\left(\\frac{1}{n}X^\\mathsf{T} X\\right)$。\n- 对于 $\\tau > 0$，凸函数 $\\phi$ 的近端算子为 $\\operatorname{prox}_{\\tau \\phi}(v) = \\arg\\min_{x} \\left\\{\\frac{1}{2}\\|x-v\\|_2^2 + \\tau \\phi(x)\\right\\}$。\n- 对于索引 $g$ 上的组 $\\ell_2$-范数 $\\phi_g(x) = \\alpha_g \\|x_g\\|_2$，近端算子对 $x_g$ 进行块软阈值操作，同时保持 $x_{-g}$ 不变。\n\n任务：\n- 使用给定的组和权重，数学上指定重叠组套索惩罚项 $\\Omega(w)$，并给出平滑损失 $f(w)$ 的显式梯度。\n- 设计一个带有 Nesterov 加速的近端梯度算法 (快速迭代收缩阈值算法) 来最小化 $F_\\lambda(w)$。由于组是重叠的，$\\tau \\lambda \\Omega$ 的近端映射在坐标上是不可分的。使用一个基于逐组近端算子 $\\operatorname{prox}_{\\tau \\lambda \\alpha_g \\|\\cdot\\|_{2,g}}$ 的循环 Dykstra 方案来计算 $\\operatorname{prox}_{\\tau \\lambda \\Omega}$；每个逐组近端步骤应仅对 $g$ 中的坐标执行块软阈值操作，并在其他地方作为恒等变换。假设固定步长 $t = 1/L$，其中 $L = \\lambda_{\\max}\\!\\left(\\frac{1}{n}X^\\mathsf{T} X\\right)$。\n\n程序要求：\n- 实现带有用于重叠惩罚项的循环 Dykstra 近端子程序的加速近端梯度方法。在 $w^{(0)} = \\mathbf{0}$ 处初始化。使用停止准则 $\\|w^{(k+1)} - w^{(k)}\\|_2 \\le \\varepsilon \\max\\{1, \\|w^{(k)}\\|_2\\}$，容差 $\\varepsilon = 10^{-8}$ 或 1000 次迭代上限，以先到者为准。对于 Dykstra 内循环，每次外循环使用 $10^{-10}$ 的容差或 500 次内循环迭代的上限。\n- 测试套件：为正则化参数 $\\lambda \\in \\{0.0, 0.05, 0.2, 10.0\\}$ 运行求解器。\n- 对于每个 $\\lambda$，计算在收敛解 $w_\\lambda$ 处的最终目标值 $F_\\lambda(w_\\lambda)$。\n- 最终输出格式：您的程序应生成一行，其中包含四个目标值的浮点数列表，按测试套件的顺序排列，每个值都精确到小数点后六位，打印为用方括号括起来的逗号分隔列表 (例如 $[0.123456,1.234567,2.345678,3.456789]$)。",
            "solution": "用户提供了一个计算统计学中的良定问题，具体专注于解决一个用重叠组套索惩罚项正则化的线性回归问题。所有数据、定义和算法要求都已明确说明，并且在科学和数学上都是合理的。\n\n**问题陈述形式化**\n\n问题是找到一个系数向量 $w \\in \\mathbb{R}^p$ 来最小化目标函数 $F_\\lambda(w)$，该函数是一个平滑损失函数和一个非平滑惩罚函数的复合：\n$$\nF_\\lambda(w) \\;=\\; f(w) \\;+\\; \\lambda\\,\\Omega(w)\n$$\n其中：\n- $n=8$ 是样本数，$p=9$ 是特征数。\n- 损失函数是经验平方误差：$f(w) = \\frac{1}{2n}\\|X w - y\\|_2^2$，其中 $X \\in \\mathbb{R}^{n \\times p}$ 和 $y \\in \\mathbb{R}^n$ 分别是给定的数据矩阵和目标向量。\n- 惩罚函数是重叠组套索惩罚项：$\\Omega(w) = \\sum_{g \\in \\mathcal{G}} \\alpha_g \\|w_g\\|_2$。\n- $\\lambda \\ge 0$ 是一个非负的正则化参数。\n\n**1. 惩罚项和损失梯度规范**\n\n首先，我们使用所提供的信息来完整地指定目标函数的各个组成部分。\n\n组集合 $\\mathcal{G}$ 总共包含六个组：\n- 跨模态的基因组：$G_{\\text{gene},1} = \\{0, 3, 6\\}$，$G_{\\text{gene},2} = \\{1, 4, 7\\}$，$G_{\\text{gene},3} = \\{2, 5, 8\\}$。\n- 跨基因的模态组：$G_{\\text{CNV}} = \\{0, 1, 2\\}$，$G_{\\text{Expr}} = \\{3, 4, 5\\}$，$G_{\\text{Meth}} = \\{6, 7, 8\\}$。\n\n每个组 $g \\in \\mathcal{G}$ 的基数 $|g|$ 都是 $3$。因此，每个组的权重为 $\\alpha_g = \\sqrt{|g|} = \\sqrt{3}$。惩罚函数显式地由下式给出：\n$$\n\\Omega(w) = \\sqrt{3} \\left( \\|w_{\\{0,3,6\\}}\\|_2 + \\|w_{\\{1,4,7\\}}\\|_2 + \\|w_{\\{2,5,8\\}}\\|_2 + \\|w_{\\{0,1,2\\}}\\|_2 + \\|w_{\\{3,4,5\\}}\\|_2 + \\|w_{\\{6,7,8\\}}\\|_2 \\right)\n$$\n其中 $w_g$ 是 $w$ 中索引在 $g$ 内的子向量。\n\n损失函数 $f(w)$ 是平滑且凸的。其梯度由下式给出：\n$$\n\\nabla f(w) = \\frac{1}{n} X^\\mathsf{T} (Xw - y)\n$$\n该梯度是利普希茨连续的，常数为 $L = \\lambda_{\\max}\\!\\left(\\frac{1}{n}X^\\mathsf{T} X\\right)$，其中 $\\lambda_{\\max}(\\cdot)$ 表示矩阵的最大特征值。\n\n**2. 算法设计：带 Dykstra 方案的加速近端梯度**\n\n为了最小化复合目标函数 $F_\\lambda(w)$，我们采用一种加速近端梯度方法，具体来说是快速迭代收缩阈值算法 (FISTA)。每次 FISTA 迭代的核心是计算惩罚项的近端算子 $\\operatorname{prox}_{\\tau \\Omega}(\\cdot)$。由于惩罚项 $\\Omega(w)$ 是变量重叠组上范数的总和，其近端算子是不可分的，无法以闭式形式计算。我们使用 Dykstra 投影算法来迭代计算它。\n\n**2.1. FISTA (外循环)**\n\n该算法维护两个迭代序列，一个主序列 $z^{(k)}$ 和一个加速序列 $w^{(k)}$。\n- **初始化**：\n  - $z^{(0)} = \\mathbf{0} \\in \\mathbb{R}^p$\n  - $w^{(0)} = z^{(0)}$\n  - $\\theta_0 = 1$\n  - 步长 $t = 1/L$，其中 $L = \\lambda_{\\max}(\\frac{1}{n}X^\\mathsf{T} X)$。\n- **迭代 $k=0, 1, \\dots$**：\n  1. 计算加速点处的梯度：$g^{(k)} = \\nabla f(w^{(k)}) = \\frac{1}{n} X^\\mathsf{T} (Xw^{(k)} - y)$。\n  2. 执行梯度下降步骤：$v^{(k)} = w^{(k)} - t \\cdot g^{(k)}$。\n  3. 对整个惩罚项应用近端算子：$z^{(k+1)} = \\operatorname{prox}_{t \\lambda \\Omega}(v^{(k)})$。此步骤使用下面描述的 Dykstra 算法计算。\n  4. 更新动量参数：$\\theta_{k+1} = \\frac{1 + \\sqrt{1 + 4\\theta_k^2}}{2}$。\n  5. 计算下一个加速点：$w^{(k+1)} = z^{(k+1)} + \\frac{\\theta_k - 1}{\\theta_{k+1}} (z^{(k+1)} - z^{(k)})$。\n- **终止**：当 $\\|w^{(k+1)} - w^{(k)}\\|_2 \\le \\varepsilon \\max\\{1, \\|w^{(k)}\\|_2\\}$ (容差 $\\varepsilon = 10^{-8}$) 或达到 $1000$ 次迭代后，循环终止。\n\n**2.2. 用于近端算子的 Dykstra 算法 (内循环)**\n\n关键步骤 $z^{(k+1)} = \\operatorname{prox}_{t \\lambda \\Omega}(v^{(k)})$ 旨在解决：\n$$\n\\operatorname{prox}_{t \\lambda \\Omega}(v) = \\arg\\min_{x \\in \\mathbb{R}^p} \\left\\{ \\frac{1}{2}\\|x-v\\|_2^2 + t \\lambda \\sum_{g \\in \\mathcal{G}} \\alpha_g \\|x_g\\|_2 \\right\\}\n$$\n令 $\\phi_g(x) = \\alpha_g \\|x_g\\|_2$ 且 $\\tau = t \\lambda$。问题是计算 $\\operatorname{prox}_{\\tau \\sum_g \\phi_g}(v)$。Dykstra 算法通过循环应用每个单独组惩罚项的近端算子来实现这一点。\n- **初始化**：\n  - 令 $M=|\\mathcal{G}|=6$ 为组的数量。\n  - $x_{(0)} = v$。\n  - 为每个组 $g \\in \\mathcal{G}$ 初始化辅助变量 (残差) $p_{g,(0)} = \\mathbf{0} \\in \\mathbb{R}^p$。\n- **迭代 $j=0, 1, \\dots$**：\n  1. 令 $x_{\\text{prev}} = x_{(j)}$。\n  2. 对所有组 $g \\in \\mathcal{G}$ 执行一个循环：\n     - 近端算子的参数：$u_g = x_{(j)} + p_{g,(j)}$。\n     - 应用逐组近端算子：$x'_{g} = \\operatorname{prox}_{\\tau \\phi_g}(u_g)$。\n     - 更新辅助变量：$p_{g,(j+1)} = u_g - x'_{g}$。\n     - 为循环中的下一个组更新迭代值：$x_{(j)} \\leftarrow x'_{g}$。\n  3. 在一个完整循环之后，主迭代值被更新：$x_{(j+1)} = x_{(j)}$。\n- **终止**：当 $\\|x_{(j+1)} - x_{(j)}\\|_2$ 小于容差 $10^{-10}$ 或在 500 次迭代后，内循环终止。最终的 $x_{(j+1)}$ 是近端映射的结果。\n\n**2.3. 逐组近端算子**\n\n单个组 $g$ 的近端算子 $\\operatorname{prox}_{\\tau \\phi_g}(u)$ 执行块软阈值操作。它更新属于组 $g$ 的 $u$ 的分量，并保持其他分量不变。令 $z = \\operatorname{prox}_{\\tau \\phi_g}(u)$。\n- 对于索引 $j \\in g$：\n  $$\n  z_g = u_g \\cdot \\max \\left(0, 1 - \\frac{\\tau \\alpha_g}{\\|u_g\\|_2} \\right) = \\left(1 - \\frac{\\tau \\alpha_g}{\\|u_g\\|_2} \\right)_+ u_g\n  $$\n  此操作将子向量 $u_g$ 向原点收缩。如果 $\\|u_g\\|_2 \\le \\tau \\alpha_g$，则 $z_g$ 变为零向量。\n- 对于索引 $j \\notin g$，$z_j = u_j$。\n\n通过组合这些组件——用于加速的 FISTA、用于处理重叠惩罚项的 Dykstra 算法，以及用于每个组的近端算子的块软阈值操作——我们可以有效地最小化目标函数 $F_\\lambda(w)$。实现将遵循这些数学规范。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the overlapping group lasso problem for the given test suite.\n    \"\"\"\n    #\n    # Step 1: Define problem data from the problem statement.\n    #\n    X = np.array([\n        [1.0, 0.0, -1.0, 0.5, -1.2, 0.3, 0.8, 0.1, 0.2],\n        [0.0, 1.0, 1.0, 1.0, 0.3, -0.4, 0.6, 0.2, 0.9],\n        [-1.0, -1.0, 0.0, -0.7, 0.5, 1.2, 0.1, 0.4, 0.3],\n        [2.0, 0.0, 1.0, 0.2, -0.3, -0.5, 0.9, 0.7, 0.5],\n        [0.0, -2.0, 1.0, 1.5, 0.7, 0.0, 0.2, 0.8, 0.6],\n        [1.0, 1.0, 0.0, -0.4, 1.1, -1.3, 0.3, 0.5, 0.4],\n        [-1.0, 2.0, -1.0, 0.0, -0.6, 0.9, 0.4, 0.6, 0.7],\n        [0.0, 0.0, 2.0, 0.8, -0.9, 0.4, 0.5, 0.2, 0.1],\n    ])\n\n    beta_star = np.array([0.3, 0.0, -0.2, 1.0, 0.0, 0.5, -0.8, 0.0, 0.2])\n    n, p = X.shape\n    y = X @ beta_star\n    \n    # Define groups\n    groups = [\n        [0, 3, 6],  # Gene 1\n        [1, 4, 7],  # Gene 2\n        [2, 5, 8],  # Gene 3\n        [0, 1, 2],  # CNV modality\n        [3, 4, 5],  # mRNA modality\n        [6, 7, 8],  # Methylation modality\n    ]\n    \n    # Calculate group weights\n    group_weights = [np.sqrt(len(g)) for g in groups]\n    \n    #\n    # Step 2: Define helper functions for the optimization algorithm.\n    #\n    \n    def soft_threshold(u_g, threshold):\n        \"\"\"Block soft-thresholding for a single group.\"\"\"\n        norm_u_g = np.linalg.norm(u_g)\n        if norm_u_g == 0:\n            return np.zeros_like(u_g)\n        \n        scale = 1 - threshold / norm_u_g\n        return u_g * max(0, scale)\n\n    def dykstra_prox(v, tau, tol=1e-10, max_iter=500):\n        \"\"\"\n        Computes the proximal operator for the sum of group lasso penalties using\n        Dykstra's cyclic projection algorithm.\n        \"\"\"\n        x = v.copy()\n        residuals = np.zeros((len(groups), p))\n        \n        for _ in range(max_iter):\n            x_prev = x.copy()\n            for i, (g_indices, g_weight) in enumerate(zip(groups, group_weights)):\n                # Proximal argument\n                u = x + residuals[i]\n                \n                # Apply block soft-thresholding\n                x_prox = u.copy()\n                u_g = u[g_indices]\n                threshold = tau * g_weight\n                x_prox[g_indices] = soft_threshold(u_g, threshold)\n                \n                # Update residual and iterate\n                residuals[i] = u - x_prox\n                x = x_prox\n                \n            if np.linalg.norm(x - x_prev) = tol:\n                break\n        return x\n\n    def calculate_objective(w, lambda_reg):\n        \"\"\"Calculates the value of the objective function F_lambda(w).\"\"\"\n        loss = (1 / (2 * n)) * np.linalg.norm(X @ w - y)**2\n        penalty = 0.0\n        for g_indices, g_weight in zip(groups, group_weights):\n            penalty += g_weight * np.linalg.norm(w[g_indices])\n        return loss + lambda_reg * penalty\n\n    def solve_fista_dykstra(lambda_reg, tol=1e-8, max_iter=1000):\n        \"\"\"\n        Solves the overlapping group lasso problem using FISTA with Dykstra's algorithm.\n        \"\"\"\n        # Lipschitz constant and step size\n        L = np.linalg.eigvalsh(X.T @ X / n).max()\n        step_size = 1.0 / L\n\n        # FISTA initialization\n        w = np.zeros(p)\n        z = np.zeros(p)\n        theta = 1.0\n\n        for k in range(max_iter):\n            w_prev = w.copy()\n            z_prev = z.copy()\n            \n            # Gradient step from the accelerated point w\n            grad = (1.0 / n) * X.T @ (X @ w - y)\n            v = w - step_size * grad\n            \n            # Proximal step using Dykstra's algorithm\n            z = dykstra_prox(v, step_size * lambda_reg)\n            \n            # Nesterov momentum update\n            theta_prev = theta\n            theta = (1.0 + np.sqrt(1.0 + 4.0 * theta_prev**2)) / 2.0\n            \n            # Update the accelerated point\n            w = z + ((theta_prev - 1.0) / theta) * (z - z_prev)\n            \n            # Check for convergence on the 'w' iterate\n            stop_crit_val = np.linalg.norm(w - w_prev)\n            stop_crit_threshold = tol * max(1.0, np.linalg.norm(w_prev))\n\n            # Special case for lambda=0: objective can be zero\n            if lambda_reg == 0 and calculate_objective(w, lambda_reg)  1e-12:\n                break\n                \n            if stop_crit_val = stop_crit_threshold:\n                break\n        \n        return w\n        \n    #\n    # Step 3: Run the test suite and collect results.\n    #\n    test_suite = [0.0, 0.05, 0.2, 10.0]\n    results = []\n\n    for lambda_reg in test_suite:\n        w_final = solve_fista_dykstra(lambda_reg)\n        objective_value = calculate_objective(w_final, lambda_reg)\n        results.append(f\"{objective_value:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}