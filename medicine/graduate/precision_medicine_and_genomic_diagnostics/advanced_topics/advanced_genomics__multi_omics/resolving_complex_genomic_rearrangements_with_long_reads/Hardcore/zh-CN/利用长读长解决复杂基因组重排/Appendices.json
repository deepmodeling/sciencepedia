{
    "hands_on_practices": [
        {
            "introduction": "解析复杂的基因组重排，根本上依赖于单条测序读长能够物理上跨越所有相关的断点。本练习将帮助您将这一要求形式化，通过推导所需的最小读长，不仅考虑重排片段的大小，还要顾及可信比对所必需的侧翼序列。掌握这一概念，可以阐明为何长读长测序技术在结构变异分析中具有独特的优势。",
            "id": "4377786",
            "problem": "一个影响癌症驱动基因的复杂结构变异，表现为沿重排单倍型的一系列交替出现的连接点（断点）和连接点间区间。假设有一条连续路径穿过 $k$ 个连接点，并且该路径上的 $k$ 个连接点间区间的长度分别为 $d_1, d_2, \\dots, d_k$ 个碱基对。在临床基因组诊断环境中，为了能够解析此重排，来自单分子实时测序（SMRT）或牛津纳米孔技术（Oxford Nanopore Technologies）的单个长读长必须跨越这整条路径。\n\n基本前提：\n- 断点是两个基因组位点之间的连接点；其几何范围与区间长度相比可以忽略不计，并被视为一个点。\n- 一个长度为 $L$ 的长读长覆盖一个连续序列，为了能够被可靠地比对，其左端和右端必须各自包含至少 $u$ 个碱基的唯一可比对侧翼序列，其中 $u$ 是比对过程所需的最小唯一种子长度（例如，在比对算法的容错率下实现可靠唯一性的最小 $k$-mer 种子长度）。\n- 在读长内部，每个内部断点必须被嵌入到其左右两侧足够的序列之间才能被观察到，但这些碱基来自读长已经跨越的连接点间区间。\n\n仅从这些基本事实和定义出发，推导出一个解析表达式，用于计算跨越整个重排路径并能可靠比对读长两端所需且充足的最小读长长度 $L_{\\min}$。然后，使用您推导的表达式，计算以下情况的 $L_{\\min}$：\n$$\nk = 5, \\quad (d_1, d_2, d_3, d_4, d_5) = (2400,\\ 13150,\\ 820,\\ 29900,\\ 412)\\ \\text{bp}, \\quad u = 150\\ \\text{bp}.\n$$\n假设区间长度足够大，以至于每个内部断点在读长内部的两侧都至少有 $u$ 个碱基作为侧翼。以碱基对（bp）为单位表示最终长度。提供精确的整数碱基对数量，不要四舍五入。",
            "solution": "用户希望我解决以下问题。\n\n该问题要求推导解析一个复杂基因组重排所需的最小读长长度 $L_{\\min}$ 的解析表达式，并将此表达式应用于一个具体案例。\n\n首先，对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 穿过的连接点数量：$k$。\n- 连接点间区间的数量：$k$，长度分别为 $d_1, d_2, \\dots, d_k$。\n- 比对所需的最小唯一种子长度：$u$。\n- 一个读长的左端和右端必须各自包含至少 $u$ 个碱基的侧翼序列。\n- 假设：区间长度足够大，以至于每个内部断点在读长内部的两侧都至少有 $u$ 个碱基作为侧翼。\n- 用于计算的具体值：$k = 5$，$(d_1, d_2, d_3, d_4, d_5) = (2400, 13150, 820, 29900, 412)$ 碱基对 (bp)，以及 $u = 150$ bp。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在科学上基于长读长测序和结构变异分析的原理。其术语和概念是基因组学领域的标准。问题是客观且可形式化的。\n\n问题陈述中存在一个微小的歧义。它指明了“穿过 $k$ 个连接点”和“$k$ 个连接点间区间”。一个由 $k$ 个区间首尾相连构成的连续路径包含 $k-1$ 个内部连接点（断点）。这表明语言上存在轻微的不精确。然而，问题始终使用 $k$ 作为区间的数量，给出了 $k=5$ 以及对应的5个区间长度列表 $(d_1, \\dots, d_5)$。问题的核心取决于这些区间的总长度，而不是连接点的数量。因此，这个歧义被认为是一个非致命的不精确性，不会妨碍得出唯一且逻辑的解。最合理的解释是该路径由 $k$ 个不同的片段组成。除此之外，该问题是自洽、适定的，没有矛盾或不科学的前提。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。将推导解答。\n\n### 最小读长 $L_{\\min}$ 的推导\n\n该问题要求确定一个测序读长的最小长度 $L$，该读长既能跨越一个复杂的结构变异，又能可靠地比对到参考基因组上。\n\n设重排的基因组路径被定义为一个由 $k$ 个长度为 $d_1, d_2, \\dots, d_k$ 的区间串联而成的连续序列。连接点被视作长度为零的点。构成该重排的序列总长度，记为 $D$，是这些区间长度的总和：\n$$D = \\sum_{i=1}^{k} d_i$$\n\n为了让一个读长能够解析此结构，必须满足两个条件：\n1.  读长必须完全跨越整个长度为 $D$ 的重排路径。\n2.  读长必须是可比对的。问题陈述指出，这要求读长的左端和右端必须各自包含至少 $u$ 个碱基的唯一可比对侧翼序列。这些侧翼序列与重排路径是连续的，但不是它的一部分。\n\n让我们在一个一维坐标系上对重排路径进行建模。我们可以将路径的起点定义在坐标 $0$ 处，终点在坐标 $D$ 处。因此，该路径占据区间 $[0, D]$。\n- 左侧翼区域是坐标 $x  0$ 的序列。\n- 右侧翼区域是坐标 $x > D$ 的序列。\n\n一个长度为 $L$ 的测序读长覆盖了基因组上的一个连续区间。设该区间为 $[x_0, x_0 + L]$。\n\n为满足比对条件，读长必须从左侧翼区域捕获至少 $u$ 个碱基，并从右侧翼区域捕获至少 $u$ 个碱基。\n- 为了从左侧翼（区域 $x  0$）捕获 $u$ 个碱基，读长必须在坐标 $-u$ 或之前开始。这施加了约束 $x_0 \\le -u$。\n- 为了从右侧翼（区域 $x > D$）捕获 $u$ 个碱基，读长必须在坐标 $D + u$ 或之后结束。这施加了约束 $x_0 + L \\ge D + u$。\n\n读长还必须跨越从坐标 $0$ 到 $D$ 的整个重排路径。上述两个条件更为严格，并自动确保了路径被跨越。如果 $x_0 \\le -u$ 且 $x_0 + L \\ge D+u$，那么读长区间 $[x_0, x_0+L]$ 必然包含 $[0, D]$，因为 $u > 0$ 且 $D > 0$。\n\n我们寻求最小读长 $L_{\\min}$。从第二个约束条件，我们有：\n$$L \\ge D + u - x_0$$\n为了最小化 $L$，我们必须最大化 $x_0$ 的值。从第一个约束条件， $x_0$ 的最大允许值为 $-u$。\n\n将 $x_0 = -u$ 代入关于 $L$ 的不等式：\n$$L \\ge D + u - (-u)$$\n$$L \\ge D + 2u$$\n\n因此，满足所有条件的最小可能读长长度 $L_{\\min}$ 为：\n$$L_{\\min} = D + 2u$$\n代入 $D$ 的表达式：\n$$L_{\\min} = \\left(\\sum_{i=1}^{k} d_i\\right) + 2u$$\n这个表达式代表了重排序列本身的长度，加上两端两个最小唯一锚定序列的长度。\n\n问题中包含一个假设，即“区间长度足够大，以至于每个内部断点在读长内部的两侧都至少有 $u$ 个碱基作为侧翼”。我们推导出的最小长度读长覆盖了所有区间 $d_1, \\dots, d_k$ 的全部，因此将包含每个区间的完整序列。因此，对于区间 $d_i$ 和 $d_{i+1}$ 之间的连接点，读长将包含连接点左侧的所有 $d_i$ 和右侧的所有 $d_{i+1}$。所以该假设简化为条件 $d_i \\ge u$ 对所有与内部连接点相邻的区间 $i$ 都成立。这个假设确保了问题是适定的，不需要更复杂的断点检测模型，但它不改变 $L_{\\min}$ 的推导，因为 $L_{\\min}$ 是由整个重排路径外部末端的要求决定的。\n\n### 具体案例计算\n\n给定以下数值：\n- $k = 5$\n- $(d_1, d_2, d_3, d_4, d_5) = (2400, 13150, 820, 29900, 412)$ bp\n- $u = 150$ bp\n\n首先，我们计算重排路径的总长度 $D$：\n$$D = \\sum_{i=1}^{5} d_i = d_1 + d_2 + d_3 + d_4 + d_5$$\n$$D = 2400 + 13150 + 820 + 29900 + 412$$\n$$D = 46682\\ \\text{bp}$$\n\n接下来，我们使用推导出的 $L_{\\min}$ 公式：\n$$L_{\\min} = D + 2u$$\n$$L_{\\min} = 46682 + 2 \\times 150$$\n$$L_{\\min} = 46682 + 300$$\n$$L_{\\min} = 46982\\ \\text{bp}$$\n\n所需的最小读长为 $46982$ 个碱基对。",
            "answer": "$$\\boxed{46982}$$"
        },
        {
            "introduction": "获得了跨越断点的长读长后，关键的下一步是精确地描绘连接点的序列特征。这项动手编程练习让您扮演生物信息学家的角色，任务是从多个含噪声的读长中构建一致性序列，并识别如微同源性等关键的连接点特征。本练习揭示了原始比对数据是如何被提炼成高可信度结构变异的过程。",
            "id": "4377754",
            "problem": "您将获得跨越一个基因组断裂点的多个长读长序列的含空位比对。每个比对由一个基于字母表 {A, C, G, T, -} 的字符串表示，其中短横线符号代表比对引入的空位。在单个测试用例中，所有字符串长度相等，并提供一个断裂点索引，该索引将比对列划分为左片段和右片段。您的任务是使用偏序比对形式化方法计算共有连接序列，并量化在连接处推断的微同源长度的置信度。\n\n使用的基本依据和定义：\n- 偏序比对可以通过一个有向无环图 (DAG) 进行建模，其中节点代表比对的字符状态，有向边代表逐列的演进。对于长度相等的预比对字符串，该 DAG 退化为一个线性的列链，每列最多有一个共有字符和可选的空位状态。这种表示方法允许在每个位置上对跨读长的证据进行明确的聚合。\n- 在一个具有对称核苷酸先验的独立单碱基观测模型下，某一列的最大后验概率共有碱基是在忽略空位的情况下，在所有读长中观测计数最高的核苷酸，并通过字典序进行确定性的平局打破。这一选择的合理性由序列共有建模中经过充分检验的多项-狄利克雷框架所支持。\n- 连接处的微同源性定义为：在从左片段和右片段中移除空位后，两者之间最长精确匹配的长度，该匹配是左片段的后缀与右片段的前缀之间的匹配。设断裂点索引为 $b$，设 $s$ 为一个读长或长度为 $L$ 的共有比对字符串。定义左子串 $s[0:b]$ 和右子串 $s[b:L]$。移除空位后，将它们表示为 $s_{\\text{left}}$ 和 $s_{\\text{right}}$。微同源长度 $\\ell$ 是满足以下条件的最大整数 $\\ell \\in \\{0, 1, \\dots, \\min(|s_{\\text{left}}|, |s_{\\text{right}}|)\\}$：$s_{\\text{left}}$ 长度为 $\\ell$ 的后缀等于 $s_{\\text{right}}$ 长度为 $\\ell$ 的前缀。\n- 推断的微同源长度的置信度使用对称狄利克雷后验预测模型进行量化。设 $N$ 为读长总数，设在所有读长中观察到的长度构成 $K$ 个不同类别，并设 $c_{\\ell^\\ast}$ 是在下述平局打破规则下选定的（最优）微同源长度 $\\ell^\\ast$ 的计数。使用对称狄利克雷先验参数 $\\alpha = 1$，$\\ell^\\ast$ 的后验预测概率（置信度）为 $\\displaystyle \\frac{c_{\\ell^\\ast} + \\alpha}{N + K\\alpha}$。\n\n计算要求：\n1. 构建偏序比对共有序列：\n   - 对于每个列索引 $i \\in \\{0, 1, \\dots, L-1\\}$，统计所有读长中 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 核苷酸的数量，忽略空位。\n   - 选择计数最大的核苷酸作为共有碱基。如果出现平局，则在 $\\text{A}  \\text{C}  \\text{G}  \\text{T}$ 中选择字典序最小的。如果某列所有读长都是空位，则该列的共有序列也是空位。\n   - 通过从完整的共有比对字符串中移除空位来定义共有连接序列。\n2. 将微同源性定义应用于共有比对字符串的断裂点索引 $b$ 处，计算共有微同源长度 $\\ell_{\\text{cons}}$。\n3. 对每个读长，使用相同定义计算其微同源长度 $\\ell_r$。\n4. 确定选定的微同源长度 $\\ell^\\ast$，该长度是在所有读长中计数最多的长度；如果出现平局，则选择较大的长度（临床惯例，在证据均等的情况下倾向于支持最大的重叠）。\n5. 将置信度值 $\\displaystyle \\frac{c_{\\ell^\\ast} + 1}{N + K}$ 计算为一个十进制数。\n\n测试套件：\n为以下测试用例提供结果。每个用例给出一个比对读长数组和断裂点索引 $b$。\n\n- 用例 $1$（理想路径；清晰的微同源性）：\n  - 读长：[\"TTACGACGGAA\", \"TTACGACGGAA\", \"TTACGACGGAA\", \"TTACGACGGAA\", \"TTACGATGGAA\"]\n  - 断裂点索引 $b = 5$\n- 用例 $2$（微同源长度出现平局）：\n  - 读长：[\"AGGTACCT\", \"AGGTTCCT\", \"AGGTACCT\", \"AGGTTCCT\"]\n  - 断裂点索引 $b = 4$\n- 用例 $3$（连接处附近有空位；一致的微同源性）：\n  - 读长：[\"AAGCT-CTGAA\", \"AAGC-TCTGAA\", \"AA-GCTCTGAA\"]\n  - 断裂点索引 $b = 6$\n- 用例 $4$（边界情况；所有读长均无微同源性）：\n  - 读长：[\"GTCGATTGCT\", \"GTCGATTGCT\", \"GTCGATTGCT\"]\n  - 断裂点索引 $b = 5$\n\n答案规格：\n对于每个测试用例，计算并返回一个包含以下内容的三元组：\n- 无空位共有连接序列的长度（一个整数），\n- 共有微同源长度 $\\ell_{\\text{cons}}$（一个整数），\n- 按上述定义计算的置信度值（一个浮点数）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是针对一个测试用例的三个值的列表。例如，格式为 \"[[x1,y1,z1],[x2,y2,z2],[x3,y3,z3],[x4,y4,z4]]\"，其中每个 $x_i$ 和 $y_i$ 是整数，每个 $z_i$ 是浮点数。不涉及物理单位；所有数值输出都是无量纲的。不出现角度，因此不需要角度单位。不得使用百分比；请将置信度报告为小数。",
            "solution": "问题陈述是有效的。它在科学上是合理的，基于计算生物学和统计学中已确立的原则，例如序列共有建模和贝叶斯推断。问题是适定的，提供了明确的定义、约束和计算过程，包括显式的平局打破规则，这保证了唯一且可验证的解。所有必要的数据都在测试用例中提供。\n\n解决方案是通过系统地遵循问题陈述中列出的计算要求得出的。该过程应用于每个测试用例，每个测试用例包含一组含空位的序列比对和一个断裂点索引 $b$。\n\n1.  **共有序列生成**：此步骤的核心是从一组比对读长中确定最具代表性的序列。共有比对字符串是逐列构建的。对于每个列索引 $i \\in \\{0, 1, \\dots, L-1\\}$（其中 $L$ 是比对长度），我们统计所有 $N$ 个读长中每个核苷酸（$\\text{A}$、$\\text{C}$、$\\text{G}$、$\\text{T}$）的出现次数。由 '-' 表示的空位被排除在此计数之外。\n    - 第 $i$ 列的共有碱基是基于最大后验概率 (MAP) 原则选择的。如前所述，在对称先验下，这简化为选择频率最高的核苷酸。\n    - 如果在给定列中所有读长都包含空位，则该列的共有序列也被定义为空位。\n    - 如果核苷酸计数出现平局，则通过选择字典序最小的核苷酸来解决，遵循 $\\text{A}  \\text{C}  \\text{G}  \\text{T}$ 的顺序。\n    - 此过程产生一个全长的共有比对字符串。最终的“共有连接序列”是通过从此字符串中移除所有空位字符生成的。这个无空位序列的长度是该测试用例所需的第一个输出值。\n\n2.  **微同源长度计算**：此过程量化连接断裂点处的短序列一致性，并应用于共有序列和每个单独的读长。对于任何给定的字符串 $s$ 和断裂点索引 $b$：\n    - 字符串被划分为左子串 $s[0:b]$ 和右子串 $s[b:L]$。\n    - 从这两个子串中移除所有空位字符 ('-')，以得到无空位序列 $s_{\\text{left}}$ 和 $s_{\\text{right}}$。\n    - 微同源长度 $\\ell$ 是既是 $s_{\\text{left}}$ 的后缀又是 $s_{\\text{right}}$ 的前缀的最长字符串的长度。为找到此值，我们从 $k = \\min(|s_{\\text{left}}|, |s_{\\text{right}}|)$ 向下迭代到 $1$，检查长度为 $k$ 的 $s_{\\text{left}}$ 后缀与长度为 $k$ 的 $s_{\\text{right}}$ 前缀是否相等。找到的第一个匹配项即为 $\\ell$ 的值。如果没有找到非空匹配，则 $\\ell=0$。\n    - 当对共有比对字符串执行此计算时，可提供共有微同源长度 $\\ell_{\\text{cons}}$，这是所需的第二个输出。\n\n3.  **置信度分数量化**：微同源性的置信度是使用贝叶斯框架，从各个读长中微同源长度的统计分布推导出来的。\n    - 首先，为 $N$ 个读长中的每一个计算微同源长度 $\\ell_r$。\n    - 然后，统计所得长度的频率。设 $K$ 为在读长集合中观察到的唯一微同源长度的数量。\n    - “选定的”微同源长度 $\\ell^\\ast$ 定义为出现最频繁的长度。如果最高频率出现平局，则通过在平局候选中选择最大的长度来打破平局。\n    - 设 $c_{\\ell^\\ast}$ 为这个选定长度 $\\ell^\\ast$ 的计数。\n    - 然后，使用给定的对称狄利克雷模型在均匀先验（$\\alpha = 1$）下的后验预测概率公式计算置信度分数：\n    $$ \\text{置信度} = \\frac{c_{\\ell^\\ast} + \\alpha}{N + K\\alpha} = \\frac{c_{\\ell^\\ast} + 1}{N + K} $$\n    - 这个置信度值，表示为十进制浮点数，是该测试用例所需的第三个也是最后一个输出。\n\n设计了一个 Python 程序来封装此逻辑。一个主函数遍历所有测试用例，将每个用例的数据传递给一个子函数，该子函数执行三个计算步骤并返回结果三元组。最终输出格式化为这些三元组的列表。",
            "answer": "```python\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the genomic rearrangement problem by computing consensus sequences,\n    microhomology lengths, and confidence scores for a suite of test cases.\n    \"\"\"\n\n    def compute_results(reads: list[str], b: int) - list:\n        \"\"\"\n        Computes the required metrics for a single test case.\n\n        Args:\n            reads: A list of aligned sequence strings.\n            b: The breakpoint index.\n\n        Returns:\n            A list containing [length of gapless consensus, consensus microhomology, confidence].\n        \"\"\"\n        num_reads = len(reads)\n        if num_reads == 0:\n            return [0, 0, 0.0]\n        \n        len_reads = len(reads[0])\n        \n        # Requirement 1: Build a partial order alignment consensus\n        consensus_alignment_list = []\n        for i in range(len_reads):\n            # Tally non-gap bases in the current column\n            bases_in_col = [read[i] for read in reads if read[i] != '-']\n            \n            if not bases_in_col:\n                # If all reads have a gap, consensus is a gap\n                consensus_alignment_list.append('-')\n            else:\n                counts = collections.Counter(bases_in_col)\n                max_count = max(counts.values())\n                \n                # Tie-breaking: select the lexicographically smallest nucleotide\n                tied_bases = sorted([base for base, count in counts.items() if count == max_count])\n                consensus_alignment_list.append(tied_bases[0])\n\n        consensus_alignment_str = \"\".join(consensus_alignment_list)\n        consensus_junction_seq = consensus_alignment_str.replace('-', '')\n        len_consensus_junction = len(consensus_junction_seq)\n\n        def calculate_microhomology(s: str, b_idx: int) - int:\n            \"\"\"\n            Calculates microhomology length for a given sequence and breakpoint.\n            \"\"\"\n            left_part_raw = s[:b_idx]\n            right_part_raw = s[b_idx:]\n            \n            left_part = left_part_raw.replace('-', '')\n            right_part = right_part_raw.replace('-', '')\n            \n            max_l = min(len(left_part), len(right_part))\n            for l in range(max_l, 0, -1):\n                if left_part[-l:] == right_part[:l]:\n                    return l\n            return 0\n\n        # Requirement 2: Compute consensus microhomology length\n        l_cons = calculate_microhomology(consensus_alignment_str, b)\n\n        # Requirement 3: Compute per-read microhomology lengths\n        read_mh_lengths = [calculate_microhomology(read, b) for read in reads]\n\n        # Requirement 4  5: Determine selected length and compute confidence\n        mh_counts = collections.Counter(read_mh_lengths)\n        \n        # Determine the selected microhomology length l_star\n        max_count_mh = 0\n        if mh_counts:\n            max_count_mh = max(mh_counts.values())\n        \n        # Tie-breaking rule for l_star: select the larger length\n        tied_lengths = [length for length, count in mh_counts.items() if count == max_count_mh]\n        l_star = max(tied_lengths) if tied_lengths else 0\n        \n        c_l_star = mh_counts.get(l_star, 0)\n        \n        N = num_reads\n        K = len(mh_counts)  # Number of distinct microhomology length categories\n        \n        # Compute confidence using the Dirichlet posterior predictive model\n        confidence = (c_l_star + 1) / (N + K)\n\n        return [len_consensus_junction, l_cons, confidence]\n\n    test_cases = [\n        {\"reads\": [\"TTACGACGGAA\", \"TTACGACGGAA\", \"TTACGACGGAA\", \"TTACGACGGAA\", \"TTACGATGGAA\"], \"b\": 5},\n        {\"reads\": [\"AGGTACCT\", \"AGGTTCCT\", \"AGGTACCT\", \"AGGTTCCT\"], \"b\": 4},\n        {\"reads\": [\"AAGCT-CTGAA\", \"AAGC-TCTGAA\", \"AA-GCTCTGAA\"], \"b\": 6},\n        {\"reads\": [\"GTCGATTGCT\", \"GTCGATTGCT\", \"GTCGATTGCT\"], \"b\": 5}\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = compute_results(case[\"reads\"], case[\"b\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "全基因组范围的结构变异检测是由复杂的软件完成的，但没有哪个工具是完美的。无论是开发者还是使用者，一项至关重要的技能是能够量化地评估工具的性能。本练习将介绍精确率 (precision)、召回率 (recall) 和 $F_1$ 分数等基本度量指标，通过一个真实的基准测试场景，来演示我们如何衡量结构变异检出的准确性和灵敏度。",
            "id": "4377762",
            "problem": "一项临床基因组学研究旨在使用长读长测序，对解析复杂基因组重排的结构变异（SV）检出性能进行基准测试。一个由 $120$ 个SV组成的高置信度真实集是通过正交实验和综合管理策展得到的。一个长读长SV检出工具报告了 $110$ 个变异检出。由于长读长断点估计可能存在微小差异，当且仅当SV类型相同且每个相关断点位于真实断点 $\\pm 50$ 个碱基对（bp）范围内时，一个预测的检出才被视为与一个真实SV匹配。对于双断点SV（例如，缺失和倒位），两个断点都必须满足容差；对于单断点SV（例如，插入），单个断点必须满足相同的容差。在这些规则下，构建了一个真实SV与预测SV之间的一对一二分匹配，以最大化匹配的总数。\n\n匹配后，汇总的混淆矩阵计数为：真阳性 $TP = 84$，假阳性 $FP = 26$，以及假阴性 $FN = 36$。\n\n从二元分类的核心定义出发，根据上述容错匹配范式，用 $TP$、$FP$ 和 $FN$ 来定义用于SV基准测试的精确率、召回率和 $F_1$ 分数。然后计算给定计数的 $F_1$ 分数。将最终数值四舍五入至四位有效数字。最终答案以纯数字形式表示，不带单位。",
            "solution": "对问题陈述进行验证。\n\n**步骤1：提取给定信息**\n-   真实集中的结构变异（SV）数量：$120$。\n-   长读长检出工具报告的SV检出数量：$110$。\n-   断点的匹配容差：$\\pm 50$ bp。\n-   真阳性（$TP$）：$84$。\n-   假阳性（$FP$）：$26$。\n-   假阴性（$FN$）：$36$。\n\n**步骤2：使用提取的给定信息进行验证**\n该问题具有科学依据，提法明确且客观。它描述了对基因组变异检出工具进行基准测试的标准程序。所提供的数据是完整的且内部一致的。\n\n-   实际阳性案例的总数（真实集中的SV）为 $120$。这必须等于真阳性（被正确识别的真实SV）和假阴性（被遗漏的真实SV）之和。检查数据：$TP + FN = 84 + 36 = 120$。这与数据一致。\n-   预测为阳性的案例总数（算法检出的SV）为 $110$。这必须等于真阳性（正确的检出）和假阳性（错误的检出）之和。检查数据：$TP + FP = 84 + 26 = 110$。这也与数据一致。\n\n该问题是有效的，因为它没有科学上的不健全性、矛盾、模糊性或任何其他列出的缺陷。可以从所提供的信息中推导出一个完整的解决方案。\n\n**求解过程**\n任务是在二元分类的背景下定义精确率、召回率和 $F_1$ 分数，然后根据给定的数据计算 $F_1$ 分数。这些指标是评估分类模型（在此案例中是SV检出工具）性能的基础。\n\n**真阳性（$TP$）**是模型正确预测阳性类别的结果。在这里，它是一个与真实SV匹配的检出SV。给定 $TP = 84$。\n\n**假阳性（$FP$）**是模型错误预测阳性类别的结果。在这里，它是一个不与任何真实SV匹配的检出SV。给定 $FP = 26$。这对应于过度检出或虚假检出。\n\n**假阴性（$FN$）**是模型错误预测阴性类别的结果。在这里，它是一个未被检出工具检测到的真实SV。给定 $FN = 36$。这对应于灵敏度不足。\n\n**1. 指标的定义**\n\n**精确率（Precision）**：精确率，也称为阳性预测值（PPV），衡量的是阳性预测中实际正确的比例。它回答了这样一个问题：“在算法检出的所有SV中，有多大比例是真实的？”其定义为：\n$$ \\text{Precision} = \\frac{TP}{TP + FP} $$\n\n**召回率（Recall）**：召回率，也称为灵敏度（Sensitivity）或真阳性率（TPR），衡量的是实际阳性样本中被正确识别的比例。它回答了这样一个问题：“在样本中存在的所有真实SV中，算法找到了多大比例？”其定义为：\n$$ \\text{Recall} = \\frac{TP}{TP + FN} $$\n\n**$F_1$ 分数**：$F_1$ 分数是精确率和召回率的调和平均数。它提供了一个平衡两者的单一指标，在类别分布不均时尤其有用。两个数 $a$ 和 $b$ 的调和平均数的通用公式是 $2 / (\\frac{1}{a} + \\frac{1}{b})$。因此，$F_1$ 分数是：\n$$ F_1 = 2 \\cdot \\frac{\\text{Precision} \\cdot \\text{Recall}}{\\text{Precision} + \\text{Recall}} $$\n为了直接用 $TP$、$FP$ 和 $FN$ 表示 $F_1$ 分数，我们代入精确率和召回率的定义：\n$$ F_1 = 2 \\cdot \\frac{\\left(\\frac{TP}{TP + FP}\\right) \\cdot \\left(\\frac{TP}{TP + FN}\\right)}{\\left(\\frac{TP}{TP + FP}\\right) + \\left(\\frac{TP}{TP + FN}\\right)} $$\n为了简化，我们为主分式的分母中的和式找到一个公分母：\n$$ F_1 = 2 \\cdot \\frac{\\frac{TP^2}{(TP + FP)(TP + FN)}}{\\frac{TP(TP + FN) + TP(TP + FP)}{(TP + FP)(TP + FN)}} $$\n从分子和分母中消去公因式 $(TP + FP)(TP + FN)$：\n$$ F_1 = \\frac{2 \\cdot TP^2}{TP(TP + FN) + TP(TP + FP)} $$\n从分母中提出因子 $TP$：\n$$ F_1 = \\frac{2 \\cdot TP^2}{TP((TP + FN) + (TP + FP))} = \\frac{2 \\cdot TP}{TP + FN + TP + FP} $$\n这简化为标准公式：\n$$ F_1 = \\frac{2 \\cdot TP}{2 \\cdot TP + FP + FN} $$\n\n**2. $F_1$ 分数的计算**\n\n使用给定的计数：$TP = 84$，$FP = 26$ 和 $FN = 36$。我们将这些值代入推导出的 $F_1$ 分数公式中。\n\n$$ F_1 = \\frac{2 \\cdot 84}{2 \\cdot 84 + 26 + 36} $$\n$$ F_1 = \\frac{168}{168 + 26 + 36} $$\n$$ F_1 = \\frac{168}{168 + 62} $$\n$$ F_1 = \\frac{168}{230} $$\n现在，我们计算数值：\n$$ F_1 = \\frac{168}{230} \\approx 0.73043478... $$\n问题要求将最终答案四舍五入至四位有效数字。前四位有效数字是 $7$、$3$、$0$ 和 $4$。第五位有效数字是 $3$，小于 $5$，所以我们向下舍入。\n$$ F_1 \\approx 0.7304 $$",
            "answer": "$$\\boxed{0.7304}$$"
        }
    ]
}